#include "tlpp-core.th"

#define LOG_FILE_NAME "unimed-cadbenef-api-risksharing.log"

namespace totvs.protheus.health.plan.unimed

using namespace totvs.protheus.health.plan.api.util

/*/{Protheus.doc} ReverseTokenAuth
Autenticação Unimed Brasil - Autenticação reversa do token
@type class
@version 12.1.2410 
@author vinicius.queiros
@since 13/07/2024
/*/
class ReverseTokenAuth from RestClient

	protected data cHealthInsurerCode as character
	protected data cBearer as character
	protected data cCookie as character
	protected data cLogin as character
	protected data cUrl as character

	public method new() constructor
	public method valid(jHeader as json) as logical
	public method destroy()

	protected method getTokenAuthData() as logical

endclass

/*/{Protheus.doc} new
Método construtor da classe
@type method
@version 12.1.2410
@author vinicius.queiros
@since 13/07/2024
@return object, objeto da classe ReverseTokenAuth
/*/
method new() class ReverseTokenAuth

	_Super:new()

	self:cHealthInsurerCode := plsIntPad()

return self

/*/{Protheus.doc} valid
Realiza a validação do token no GIU da Unimed Brasil.
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 13/07/2024
@return logical, se o token está valido
/*/
method valid(jHeader as json) as logical class ReverseTokenAuth

	local lOk := .F. as logical
	local aHeaders := {} as array
	local jBody as json
	local cAuthorizationLabel as character
	local cCookieLabel as character

	cAuthorizationLabel := iif(jHeader:hasProperty("Authorization"), "Authorization", "authorization")
	cCookieLabel := iif(jHeader:hasProperty("Cookie"), "Cookie", "cookie")

	plsLogFil("[authorization]", LOG_FILE_NAME)

	if jHeader:hasProperty(cAuthorizationLabel) .and. jHeader:hasProperty(cCookieLabel) .and.;
	   !empty(jHeader[cAuthorizationLabel]) .and. !empty(jHeader[cCookieLabel])

		self:cBearer := jHeader[cAuthorizationLabel]
		self:cCookie := jHeader[cCookieLabel]

		if self:getTokenAuthData()
			plsLogFil("*** request", LOG_FILE_NAME)
			plsLogFil("* Authorization: " + self:cBearer, LOG_FILE_NAME)
			plsLogFil("* Cookie: " + self:cCookie, LOG_FILE_NAME)
			plsLogFil("* X-LOGIN-INTERNO: " + self:cLogin, LOG_FILE_NAME)
			plsLogFil("", LOG_FILE_NAME)

			aAdd(aHeaders, {"key": "Content-Type", "value": "application/json"})
			aAdd(aHeaders, {"key": "Authorization", "value": self:cBearer})
			aAdd(aHeaders, {"key": "Cookie", "value": self:cCookie})
			aAdd(aHeaders, {"key": "X-LOGIN-INTERNO", "value": self:cLogin})

			jBody := {"grant_type": "refresh_token"}

			self:setHeaderParams(aHeaders)
			self:setEndpoint(self:cUrl)
			self:setBody(jBody:toJson())

			if self:post() .and. self:getStatusCode() == 200 // Ok
				lOk := .T.
			endif

			plsLogFil("*** response", LOG_FILE_NAME)
			plsLogFil("* status code: " + cValToChar(self:getStatusCode()), LOG_FILE_NAME)
			plsLogFil("* message: " + self:getBody(), LOG_FILE_NAME)
			plsLogFil("", LOG_FILE_NAME)
		endif
	else
		plsLogFil("* Authorization e Cookie not found", LOG_FILE_NAME)
		plsLogFil("", LOG_FILE_NAME)
	endif

	plsLogFil("*** final status = " + iif(lOk, "authorized", "unauthorized"), LOG_FILE_NAME)
	plsLogFil("", LOG_FILE_NAME)

	fwFreeArray(aHeaders)
	freeObj(jBody)

return lOk

/*/{Protheus.doc} destroy
Limpa da memória as variáveis (objeto, array e json) da classe
@type method
@version 12.1.2410
@author vinicius.queiros
@since 13/07/2024
/*/
method destroy() class ReverseTokenAuth

	_Super:destroy()

return

/*/{Protheus.doc} getTokenAuthData
Obtem os dados necessários para validação do token (url e login)
@type method
@version 12.1.2410
@author vinicius.queiros
@since 13/07/2024
@return logical, se dados foram obtidos com sucesso
/*/
method getTokenAuthData() as logical class ReverseTokenAuth

	local lOk := .F. as logical

	if BA0->(fieldPos("BA0_URLVTK")) > 0
		BA0->(dbSetOrder(1))
		if BA0->(msSeek(xFilial("BA0") + self:cHealthInsurerCode))
			if !empty(BA0->BA0_URLVTK) .and. !empty(BA0->BA0_UBCLID)
				self:cUrl := alltrim(BA0->BA0_URLVTK)
				self:cLogin := alltrim(BA0->BA0_UBCLID)

				lOk := .T.
			endif
		endif
	endif

return lOk
