#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "health.plan.unimed.cadbenef.api.contracts.ch"

#define INCLUSION_TYPE "0" // Inclusão
#define UPDATE_TYPE "1" // Atualização
#define SEARCH_TYPE "4" // Consultar

#define REQUIRED .T.
#define OPTIONAL .F.

namespace totvs.protheus.health.plan.unimed

using namespace totvs.protheus.health.plan.api.util

/*/{Protheus.doc} CadBenefApiContracts
Possibilita que seja enviado as informações de novos contratos para posteriormente vínculo com beneficiários
quando não utilizado o fluxo de prospecção de vendas. (Validação do Contrato).
Limite máximo: 1 Contrato por mensagem.
@type class
@version 12.1.2510
@author giovanna.charlo 
@since 16/04/2025
/*/
class CadBenefApiContracts from RestClient                            

	protected data jBody as json
	protected data aParams as array
	protected data jResponse as json
	protected data cMessage as character
	protected data lIsError as logical
	protected data oToken as object
	protected data cUnimedOrigin as character
	protected data cOperation as character
	protected data cContract as character
	protected data jContractData as json
	protected data jStatusCodeMessage as json
	protected data cProtocolNumber as character

	public method new(cHealthInsurerCode) constructor
	public method addContracts(cContract as character, cOperation as numeric, cTransactionCode as character, jContractData as json) as logical
	public method send() as logical
	public method getRequest() as json
	public method getResponse() as json
	public method getParamsToString() as character
	public method getMessage() as character
	public method getProtocolNumber() as character
	public method destroy()

	protected method openUsedTables()
	protected method loadHeader()
	protected method loadContractsData()
	protected method loadTypeContractor()
	protected method loadAgreementData()

	protected method loadApiConfig(cHealthInsurerCode as character) as logical
	protected method setResponse() as logical
	protected method setError(cCode as character, cMessage as character, cDetailedMessage as character, aDetails as array) as json
	protected method setAttribute(jData as json)
	protected method getStatusCodeMessage(cStatusCode as character, cOperation as character) as character

endclass

/*/{Protheus.doc} new
Método construtor da classe
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@param cHealthInsurerCode, character, código da operadora para buscar as configurações
@return object, objeto da instância da classe
/*/
method new(cHealthInsurerCode) class CadBenefApiContracts

	_Super:new()

	self:oToken := TokenOAuth():new(PLSINTPAD())
	self:jBody := JsonObject():new()
	self:aParams := {}
	self:jResponse := JsonObject():new()
	self:lIsError := .F.

return self

/*/{Protheus.doc} addContracts
Adiciona o contrato que será enviado para o validador comercial unimed.
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@param cContract, character, contrato a ser adicionado

@param cOperation, character, operação a ser executada: inclusão, alteração ou exclusão
@param cTransactionCode, character, código que foi gerado para a transação
@return logical, se o contrato foi adicionado com sucesso para ser enviado
/*/
method addContracts(cContract as character, cOperation as character, cTransactionCode as character, jContractData as json) as logical class CadBenefApiContracts

	local lAdd := .f. as logical

	self:jBody := JsonObject():new()
	self:cContract := cContract
	self:cUnimedOrigin := jContractData["healthInsurerCode"]
	self:cOperation := cOperation
	self:jContractData := jContractData

	do case
			case self:cOperation == INCLUSION_TYPE  
				self:openUsedTables()
				self:loadHeader(cTransactionCode)
				self:loadContractsData()
				self:loadAgreementData()

			case self:cOperation == UPDATE_TYPE
				self:loadHeader(cTransactionCode)
			
			case self:cOperation == SEARCH_TYPE
				self:loadHeader(cTransactionCode)
		endcase

	if !self:lIsError
		lAdd := .T.
	endif

return lAdd

/*/{Protheus.doc} send
Envia o contrato adicionado pelo método addContracts para o validador comercial unimed.
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@return logical, se o contrato foi validado com sucesso
/*/
method send() as logical class CadBenefApiContracts

	local lSuccess := .F. as logical
	local aHeaders := {} as array
	local aFormData := {} as array
	local aAttachment := {} as array

	if self:oToken:getToken()
		if self:loadApiConfig()

			aAttachment := searchKnowledgeBank(self:jContractData["alias"], alltrim(xFilial(self:jContractData["alias"]) + self:cContract))

			aAdd(aHeaders, {"key": "Authorization", "value": "Bearer " + self:oToken:getBearer()})
			aAdd(aHeaders, {"key": "Content-Type", "value": "multipart/form-data"})

			if valType(aAttachment) == "A" .and. !empty(aAttachment)
				aAdd(aHeaders, {"key": "Content-Disposition", "value": "inline; filename=" + AllTrim(aAttachment[1]["filename"]) })
			endif

			aAdd(aHeaders, {"key": "Accept-Charset", "value": "*/*"})
			aAdd(aHeaders, {"key": "Connection", "value": "keep-alive"})
			//aAdd(aHeaders, {"key": "Content-Security-Policy", "value": "default-src 'self'; script-src 'self'"})
			self:setHeaderParams(aHeaders)

			do case
				case self:cOperation == INCLUSION_TYPE

					aAdd(aFormData, {"key": "body", "value": self:jBody:toJson(),"contentType": "application/json"})

					if valType(aAttachment) == "A" .and. !empty(aAttachment)
						aAdd(aFormData, {"key": "arquivoAcordo", "value": aAttachment[1]["value"], "contentType": "application/pdf", "fileName": aAttachment[1]["filename"]})
						//aAdd(aFormData, {"key": "arquivoAcordo", "contentType": "application/pdf", "fileName": aAttachment[1]["filename"]})
					endif

					self:setFormData(aFormData)
					
					lSuccess := self:post()

				case self:cOperation == UPDATE_TYPE
					self:setPath("/" + self:cSubscriberId)
					self:setBody(self:jBody:toJson())

					lSuccess := self:patch()
			endcase

			self:jResponse:fromJson(self:getBody())
			self:cMessage := self:getStatusCodeMessage(cValToChar(self:getStatusCode()), self:cOperation)

			if empty(self:cMessage) .and. self:jResponse:hasProperty("statusProcessamento") .and. self:jResponse:hasProperty("descricaoMensagem")
				self:cMessage :=  self:jResponse["statusProcessamento"]["descricaoMensagem"]
			endif
		else
			lSuccess := .F.
		endif
	else
		lSuccess := .F.
		self:cMessage := self:oToken:getMessage()
		self:jResponse := self:oToken:getBody()
	endif

	fwFreeArray(aHeaders)
	fwFreeArray(aFormData)

return lSuccess

/*/{Protheus.doc} getRequest
obter json de envio do contrato
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@return json, objeto json com os dados da solicitação
/*/
method getRequest() as json class CadBenefApiContracts

return self:jBody

/*/{Protheus.doc} getResponse
Obter json de resposta do envio do contrato
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@return json, objeto json com os dados da resposta
/*/
method getResponse() as json class CadBenefApiContracts

return self:jResponse

/*/{Protheus.doc} getMessage
Obter mensagem de resposta do processamento
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@return character, mensagem de erro ou sucesso
/*/
method getMessage() as character class CadBenefApiContracts

return self:cMessage

/*/{Protheus.doc} destroy
Limpa da memória as variáveis (objeto, array e json) da clase
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
/*/
method destroy() class CadBenefApiContracts

	freeObj(self:jBody)
	freeObj(self:jResponse)
	freeObj(self:oToken)
	freeObj(self:jStatusCodeMessage)
	fwFreeArray(self:aParams)

return

/*/{Protheus.doc} getResponse
Obter json de resposta do envio do contrato
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@return json, objeto json com os dados da resposta
/*/
method getProtocolNumber() as character class CadBenefApiContracts

	if self:jResponse:hasProperty("protocoloContrato")
		self:cProtocolNumber := self:jResponse["protocoloContrato"]
	endif

return self:cProtocolNumber

/*/{Protheus.doc} openUsedTables
Abri as tabelas a serem utilizadas na montagem do json de envio
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025

/*/
method openUsedTables() class CadBenefApiContracts

	if self:jContractData["alias"] == "BA3"
		BA1->(dbSetOrder(1))		
		//BA1->(dbSeek(xFilial("BA1") + BA3->(BA3_CODINT + BA3_CODEMP + BA3_MATRIC) + GetNewPar("MV_PLTRTIT")))
		BA1->(dbSeek(xFilial("BA1") + BA3->(BA3_CODINT + BA3_CODEMP + BA3_MATRIC) + "T"))
		BG9->(dbSetOrder(1))
		BG9->(dbSeek(xFilial("BG9") + BA3->(BA3_CODINT + BA3_CODEMP)))
	else
		BG9->(dbSetOrder(1))
		BG9->(dbSeek(xFilial("BG9") + BQC->(BQC_CODIGO)))
	endif                                 
return 

/*/{Protheus.doc} loadHeader
Carrega os dados do cabeçalho na requisição (body) a ser enviado para o validador comercial unimed.
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@param cTransactionCode, character, código da transação gerado
/*/
method loadHeader(cTransactionCode as character) class CadBenefApiContracts

	local cOrigin := "cabecalho" as character

	self:jBody["cabecalho"] := JsonObject():new()
	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "codigoControleTransacao", "value": cTransactionCode, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0001}) // Regra: Não deve ser repetido

	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "codigoVersaoPTU", "value": "001", "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0002}) // F"001"

	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "codigoUnimedOrigem", "value": self:cUnimedOrigin, "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0003})

	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "codigoUnimedDestino", "value": 999, "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0004}) // Fixo 0999

	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "dataGeracao", "value": dDataBase, "type": "date5", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0005})
return

/*/{Protheus.doc} loadContractsData
Carrega os dados do contrato na requisição (body) a ser enviado para o validador comercial unimed.
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
/*/
method loadContractsData() class CadBenefApiContracts

	local cOrigin := "dadosContratante" as character

	self:jBody["dadosContratante"] := JsonObject():new()

	self:loadTypeContractor()

	self:setAttribute({"body": self:jBody["dadosContratante"], "attribute": "nomeEmpresa",;
					   "value": BG9->BG9_DESCRI, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0008})

	self:setAttribute({"body": self:jBody["dadosContratante"], "attribute": "quantidadeBeneficiarios",;
					   "value": iif(self:jContractData["alias"] == "BA3", BA3->BA3_QTBVC, BQC->BQC_QTBVC), "type": "numeric", "required": iif(self:jContractData["sendContract"] == "1", .t., .f.), "origin": cOrigin,;
					   "errorDetailedMessage": STR0009})


	self:setAttribute({"body": self:jBody["dadosContratante"], "attribute": "indicadorProcesso",;
		   			   "value": iif(self:jContractData["alias"] == "BA3", BA3->BA3_OPEVC, BQC->BQC_OPEVC), "type": "character", "required": REQUIRED, "origin": cOrigin,;
		   			   "errorDetailedMessage": STR0010}) 
					
return

/*/{Protheus.doc} loadTypeCompany
Carrega os dados de tipo do Contratante na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
/*/
method loadTypeContractor() class CadBenefApiContracts

	local jContractorType as json
	local cOrigin := "tipoContratante" as character

	self:jBody["dadosContratante"]["tipoContratante"] := JsonObject():new()

	jContractorType := getContractorType(self:jContractData["alias"])

	// Regras: Obrigatório o preenchimento de um dos campos
	self:setAttribute({"body": self:jBody["dadosContratante"]["tipoContratante"], "attribute": "cnpj",;
					   "value": jContractorType["cnpj"], "type": "character", "required": empty(jContractorType["cpf"]), "origin": cOrigin,;
					   "errorDetailedMessage": STR0006}) 

	self:setAttribute({"body": self:jBody["dadosContratante"]["tipoContratante"], "attribute": "cpf",;
					   "value": jContractorType["cpf"], "type": "character", "required": empty(jContractorType["cnpj"]), "origin": cOrigin,;
					   "errorDetailedMessage": STR0007})

	freeObj(jContractorType)

return

/*/{Protheus.doc} loadContractsData
Carrega os dados do acordo  sobre a comercialização na requisição (body) a ser enviado para o validador comercial unimed.
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
/*/
method loadAgreementData() class CadBenefApiContracts

	local cOrigin := "dadosAcordo" as character
	

	self:jBody["dadosAcordo"] := JsonObject():new()

	self:setAttribute({"body": self:jBody["dadosAcordo"], "attribute": "indicadorAcordo",;
					   "value": isAgreement(self:jContractData["alias"]), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0011})

return

/*/{Protheus.doc} loadApiConfig
Carrega as configurações necessárias para comunicar com o VCOM (validador comercial unimed),
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@param cHealthInsurerCode, character, código da operadora para buscar as configurações
@return logical, se as configurações foram carregadas com sucesso
/*/
method loadApiConfig() as logical class CadBenefApiContracts
    local lOk := .T. as logical
    local cPassword as character
    local cFileNamePFX as character
    local cCertificateDirectory := superGetMV("MV_PLCBCER", .F., "\cadbenef\certificados\") as character
    local jStatus as json

    BA0->(dbSetOrder(1))
    if BA0->(dbSeek(xFilial("BA0") + PLSINTPAD()))
        self:setEndpoint(alltrim(BA0->BA0_VCOURL))
        cFileNamePFX := alltrim(BA0->BA0_CDBPFX)
        cPassword := alltrim(BA0->BA0_CDBPAS)

        if !empty(cFileNamePFX)
            jStatus := self:appendValidCertificate(cCertificateDirectory, cFileNamePFX, cPassword)

            if jStatus["status"]
                lOk := .T.
            else
                lOk := .F.
                self:setError("401", jStatus["message"], jStatus["error"])
            endif
        endif
    endif

    freeObj(jStatus)

return lOk

/*/{Protheus.doc} setAttribute
Defini os campos a ser adicionado no body para comunicar com o CadBenef.
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@param jData, json, dados do campo a ser adicionado body da requisição
/*/
method setAttribute(jData as json) class CadBenefApiContracts

	local lEmpty as logical
	local aDetails := {} as array

	lEmpty := ((valtype(jData["value"]) <> "L" .and. empty(jData["value"])) .or. (jData["type"] == "logical" .and. valtype(jData["value"]) <> "L" ))

	if !empty(jData["value"])

		do case
			case jData["type"] == "numeric"
				if valType(jData["value"]) == "C"
					jData["value"] := val(jData["value"])
				endif

			case jData["type"] == "character"
				if valType(jData["value"]) == "C"
					jData["value"] := alltrim(jData["value"])
				endif

			case jData["type"] == "date5" // Formato YYYY-MM-DDTHH:MI:SS-00:00 (padrão ISO-8601)
				if valType(jData["value"]) == "D"
					jData["value"] := fwTimeStamp(5, jData["value"])
				endif
		endcase
	endif

	// Mandatório (Obrigatório envio da informação)
	if jData["required"] .and. lEmpty
		aAdd(aDetails, {"code": "400.001", "message": STR0012 + jData["attribute"] + STR0013, "detailedMessage": iif(jData:hasProperty("errorDetailedMessage"), jData["errorDetailedMessage"], "")}) // "O campo ";" é obrigatório." 

		self:setError("400.001",;
					   STR0014,; // "Existem campos obrigatórios do beneficiário que não foram preenchidos."
					   STR0015,; // "Verifique a lisata de erros para mais detalhes."
				      aDetails)
	else
		if !lEmpty
			jData["body"][jData["attribute"]] := jData["value"]
		else
			if self:cOperation == UPDATE_TYPE .and. !jData["required"]
				jData["body"][jData["attribute"]] := nil
			endif
		endif
	endif

	fwFreeArray(aDetails)

return

/*/{Protheus.doc} setError
Defini os dados de erro no json de resposta
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@param cCode, character, código do erro (status code)
@param cMessage, character, mensagem do erro
@param cDetailedMessage, character, detalhes do erro
@param aDetails, character, lista de objetos de erro com mais detalhes sobre o erro principal
@return json, objeto json de resposta
/*/
method setError(cCode as character, cMessage as character, cDetailedMessage as character, aDetails as array) as json class CadBenefApiContracts

	local nCount as numeric

	default aDetails := {}

	self:jResponse["code"] := cCode
	self:jResponse["message"] := cMessage
	self:jResponse["detailedMessage"] := cDetailedMessage

	if len(aDetails) > 0
		if self:jResponse:hasProperty("details")
			for nCount := 1 to len(aDetails)
				aAdd(self:jResponse["details"], aDetails[nCount])
			next nCount
		else
			self:jResponse["details"] = aClone(aDetails)
		endif
	endif

	self:lIsError := .T.
	self:cMessage := cMessage

return self:jResponse

/*/{Protheus.doc} getStatusCodeMessage
Obter a mensagem de acordo com o status code
@type method
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@return character, mensagem do status code
/*/
method getStatusCodeMessage(cStatusCode as character, cOperation as character) as character class CadBenefApiContracts

	local cMessage := "" as character
	local jStatusCodeMessage := JsonObject():new() as json

	jStatusCodeMessage["201"] := STR0016 // "Contrato cadastrado com sucesso."
	jStatusCodeMessage["400"] := STR0017 // "A requisição foi malformada, omitindo atributos necessários, seja no payload ou através de atributos no header, ou na URL."
	jStatusCodeMessage["401"] := STR0018 // "Cabeçalho de autenticação ausente/inválido ou token inválido."
	jStatusCodeMessage["405"] := STR0019 // "O consumidor tentou acessar o recurso com um método que não existe."
	jStatusCodeMessage["422"] := STR0020 // "Erro de negócio."
	jStatusCodeMessage["429"] := STR0021 // "A operação foi recusada, por exceder o limite de chamadas feitas dentro de um determinado período ou o limite de requisições concorrentes foi atingido."
	jStatusCodeMessage["500"] := STR0022 // "Erro do servidor, ocorreu um erro no gateway da API ou no microsserviço."
	jStatusCodeMessage["504"] := STR0023 // "A requisição não foi atendida dentro do tempo limite estabelecido, gateway time out."

	if jStatusCodeMessage:hasProperty(cStatusCode)
		cMessage := jStatusCodeMessage[cStatusCode]
	endif

return cMessage

/*/{Protheus.doc} getCompanyType
Obter os dados de cnpj ou cpf da empresa contratante
@type function
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@return json, dados do tipo da empresa contratante
/*/
static function getContractorType(cAlias as character) as json

	local cCnpj := "" as character
	local cCpf := "" as character
	local jContractorType as json

	if cAlias == "BA3"
		if !empty(BA3->BA3_GRPFAM)

			cCpf := GetAdvFVal("BA1","BA1_CPFUSR", xFilial("BA1") + BA3->BA3_GRPFAM, 1, "")[1]

			cCpf := strZero(val(cCpf), 11)
		else
			cCpf := strZero(val(BA1->BA1_CPFUSR), 11)
		endif
	else
		if !empty(BQC->BQC_CNPJ)
			cCnpj := strZero(val(BQC->BQC_CNPJ), 14)
		else
			SA1->(dbSetOrder(1))
			if SA1->(msSeek(xFilial("SA1") + BQC->(BQC_CODCLI + BQC_LOJA))) .and. !empty(SA1->A1_CGC)
				cCnpj := strZero(val(SA1->A1_CGC), 14)
			endif
		endif
	endif

	jContractorType := {"cnpj": cCnpj, "cpf": cCpf}

return jContractorType

/*/{Protheus.doc} isAgreement
Verifica se será realizado o envio do arquivo de acordo entre as Unimeds.
@type function
@version 12.1.2510
@author giovanna.charlo
@return logical, se será enviado o arquivo de acordo
/*/
static function isAgreement(cAlias) as logical
	local lisAgreement := .f. as logical
 
	if &(cAlias+"->"+cAlias+"_ACDVC") == "1"
		lisAgreement := .t.
	endif
return lisAgreement

/*/{Protheus.doc} searchKnowledgeBank
Consulta a Base de Conhecimento o arquivo de acordo
@type method
@version 12.1.2510
@author giovanna.charlo
@since 02/05/2025
@param cActiveAlias, character, alias da tabela referente a rotina atual
@param cSearchKey, character, chave de busca
@return array, leitura e nome do arquivo
/*/
static function searchKnowledgeBank(cActiveAlias as character, cSearchKey as character) as array 

	local cQuery as character
	local nOrder := 1 as numeric
	local cAliasTemp := "" as character
	local aAttachment := {} as array
	local oStatement as object
	local oFile as object
	local cFile := "" as character
	local cFileDirectory := lower(Alltrim(MsDocPath())) + "\" as character	
	local cFilePath := "" as character

	default cActiveAlias := ""
	default cSearchKey := ""

	cQuery += "SELECT ? "
	cQuery += " FROM ? AC9 "
	cQuery += " INNER JOIN ? ACB "
	cQuery += "  ON ACB.ACB_FILIAL = AC9.AC9_FILIAL "
	cQuery += " AND ACB.ACB_CODOBJ = AC9.AC9_CODOBJ "
	cQuery += " AND ACB.D_E_L_E_T_ = ?  "

	cQuery += " WHERE AC9.AC9_FILIAL = ? "
	cQuery += " AND AC9.AC9_ENTIDA = ? "
	cQuery += " AND AC9.AC9_CODENT = ? "
	cQuery += " AND AC9.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY ? "

	cQuery := changeQuery(cQuery)

	oStatement := FWExecStatement():new(cQuery)

	oStatement:setUnsafe(nOrder++, "ACB.ACB_OBJETO")
	oStatement:setUnsafe(nOrder++, retSqlName("AC9"))
	oStatement:setUnsafe(nOrder++, retSqlName("ACB"))
	oStatement:setString(nOrder++, " ")
	oStatement:setString(nOrder++, xFilial("AC9"))
	oStatement:setString(nOrder++, cActiveAlias)
	oStatement:setString(nOrder++, cSearchKey)
	oStatement:setString(nOrder++, " ")
	oStatement:setUnsafe(nOrder++,"ACB.ACB_OBJETO")

	cAliasTemp := oStatement:openAlias()

    (cAliasTemp)->(dbGoTop())

	while !(cAliasTemp)->(eof())
	
		cFilePath := cFileDirectory + (cAliasTemp)->ACB_OBJETO
		oFile := FwFileReader():New(cFilePath)

		if (oFile:Open())
			cFile := oFile:FullRead()
		endif

		aAdd(aAttachment, {"key": "attachment", "value": cFile, "filename": cFilePath})

		oFile:Close()
		(cAliasTemp)->(dbSkip())
	enddo

	(cAliasTemp)->(DbCloseArea())

return aAttachment

/*/{Protheus.doc} vcomGetFieldSolution
Retorna em qual cadastro e campo o usuário deverá preencher/alterar o campo criticado
@type function
@version 12.1.2510
@author giovanna.charlo
@since 16/04/2025
@param cField, character, campo a ser obtido a soluçaõ de preenchimento
@return character, solução de preenchimento do campo
/*/
function vcomGetFieldSolution(cField as character) as character

	local cSolution := "" as character
	local jFieldSolution := JsonObject():new() as json

	jFieldSolution["cabecalho.codigoControleTransacao"] := STR0001 // "Transação gerada automaticamente pelo sistema."
	jFieldSolution["cabecalho.codigoVersaoPTU"] := STR0002 // "Fixo 010"
	jFieldSolution["cabecalho.unimed.codigoUnimedOrigem"] := STR0003 // "Grupo Empresa (BG9), campo Operadora (BG9_CODINT)."
	jFieldSolution["cabecalho.unimed.codigoUnimedDestino"] := STR0004 // "Fixo 999."
	jFieldSolution["cabecalho.dataGeracao"] := STR0005 // "Fixo data base do sistema"

	jFieldSolution["dadosContratante.tipoContratante.cnpj"] := STR0006 // "Cadastro do subcontrato (BQC), campo CNPJ (BQC_CNPJ) ou cadastro do cliente (SA1), campo CNPJ/CPF (A1_CGC) procurado pelos campos Cod. Cliente e Loja (BQC_CODCLI + BQC_LOJA)."
	jFieldSolution["dadosContratante.tipoContratante.cpf"] := STR0007  // "Cadastro do beneficiário (BA1), campo CPF (BA1_CPFUSR)."
	jFieldSolution["dadosContratante.nomeEmpresa"] := STR0008 // "Cadastro da empresa (BG9), campo Grp/Empresa (BG9_DESCRI)."
	jFieldSolution["dadosContratante.quantidadeBeneficiarios"] := STR0009 // "Cadastro do subcontrato (BQC), campo Qtd Benef (BQC_QTBVC) ou Cadastro da família (BA3), campo Qtd Benef (BA3_QTBVC)."
	jFieldSolution["dadosContratante.indicadorProcesso"] := STR0010 // "Cadastro do subcontrato (BQC), campo Opção Envio (BQC_OPEVC) ou Cadastro da família (BA3), campo Opção Envio (BA3_OPEVC)."
	
	jFieldSolution["dadosAcordo.indicadorAcordo"] := STR0011 // "Cadastro do subcontrato (BQC), campo Ind Acordo (BQC_ACDVC) ou Cadastro da família (BA3), campo Ind Acordo (BA3_ACDVC)."
	
	if jFieldSolution:hasProperty(cField)
		cSolution := jFieldSolution[cField]
	endif

	freeObj(jFieldSolution)

return cSolution
