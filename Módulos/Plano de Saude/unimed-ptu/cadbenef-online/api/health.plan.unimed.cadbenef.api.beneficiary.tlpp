#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "health.plan.unimed.cadbenef.api.beneficiary.ch"

#define INCLUSION_TYPE "1" // Inclusão
#define UPDATE_TYPE "2" // Atualização
#define EXCLUSION_TYPE "3" // Exclusão

#define REQUIRED .T.
#define OPTIONAL .F.

namespace totvs.protheus.health.plan.unimed

using namespace totvs.protheus.health.plan.api.util

/*/{Protheus.doc} CadBenefApiBeneficiaries
Possibilita que seja enviado a movimentação cadastro do beneficiário (Inclusão, Alteração e Exclusão) 
para o CadBenef. Limite máximo: 1 Beneficiário por mensagem.
@type class
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
/*/
class CadBenefApiBeneficiaries from RestClient

	protected data jBody as json
	protected data aParams as array
	protected data jResponse as json
	protected data cMessage as character
	protected data lIsError as logical
	protected data oToken as object
	protected data cSubscriberId as character
	protected data cUnimedOrigin as character
	protected data cOperation as character
	protected data jHolderData as json
	protected data lIsSubcontract as logical
	protected data jStatusCodeMessage as json
	protected data lAllFalseIndicators as logical
	protected data lPEPTU001JSN as logical
	protected data lIsRiskSharing as logical
	protected data lIsPlanHolder as logical
	protected data lIsRuled as logical
	protected data lIsTotalCoverage as logical

	public method new(cHealthInsurerCode) constructor
	public method addBeneficiary(cSubscriberId as character, cUnimedOrigin as character, cOperation as character, cTransactionCode as character) as logical
	public method send() as logical
	public method getRequest() as json
	public method getResponse() as json
	public method getParamsToString() as character
	public method getMessage() as character
	public method destroy()
	
	protected method openUsedTables()
	protected method loadHeader()
	protected method loadBeneficiaryData()
	protected method loadMemberData()
	protected method loadAggregateProduct()
	protected method loadPreexistence()
	protected method loadContractingCompanyData()
	protected method loadPlanData()
	protected method loadPersonData()
	protected method loadRiskSharing()
	protected method loadTypeCompany()
	protected method loadAddressCompany()
	protected method loadPhoneCompany()
	protected method loadScopes()
	protected method loadGracePeriod()
	protected method loadCoveragePeriod()
	protected method loadComplementsRegistrations()
	protected method loadQueryParamsDelete(cTransactionCode as character)

	protected method loadApiConfig(cHealthInsurerCode as character) as logical
	protected method setResponse() as logical
	protected method setError(cCode as character, cMessage as character, cDetailedMessage as character, aDetails as array) as json
	protected method setParams(jData as json)
	protected method setAttribute(jData as json)
	protected method getStatusCodeMessage(cStatusCode as character, cOperation as character) as character

	protected method isContractProtocol() as logical

endclass

/*/{Protheus.doc} new
Método construtor da classe
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param cHealthInsurerCode, character, código da operadora para autenticação
@return object, objeto da instância da classe
/*/
method new(cHealthInsurerCode) class CadBenefApiBeneficiaries

	_Super:new()

	self:oToken := TokenOAuth():new(cHealthInsurerCode)
	self:jBody := JsonObject():new()
	self:aParams := {}
	self:jResponse := JsonObject():new()
	self:lIsError := .F.
	self:lIsSubcontract := .F.
	self:lPEPTU001JSN := existBlock("PTU001JSN")
	self:lIsPlanHolder := .F.
	self:lIsRuled := .F.
	self:lIsTotalCoverage := .F.

return self

/*/{Protheus.doc} addBeneficiary
Adiciona o beneficiário que será enviado para o CadBenef
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param cSubscriberId, character, matricula do beneficiário a ser adicionado
@param cUnimedOrigin, character, código da unimed origem do envio
@param cOperation, character, operação a ser executada: inclusão, alteração ou exclusão
@param cTransactionCode, character, código que foi gerado para a transação
@return logical, se o beneficiário foi adicionado com sucesso para ser enviado
/*/
method addBeneficiary(cSubscriberId as character, cUnimedOrigin as character, cOperation as character, cTransactionCode as character) as logical class CadBenefApiBeneficiaries

	local lAdd := .F. as logical

	self:jBody := JsonObject():new()

	BA1->(dbSetOrder(2))
	if BA1->(dbSeek(xFilial("BA1") + cSubscriberId))
		self:cSubscriberId := cSubscriberId
		self:cUnimedOrigin := cUnimedOrigin
		self:cOperation := cOperation

		do case
			case self:cOperation == INCLUSION_TYPE .or. self:cOperation == UPDATE_TYPE
				self:jHolderData := getHolderData()
				self:openUsedTables()
				// Obrigatório quando todos os indicadores abaixo estiver preenchido com valor 0 (False): indicadorAutoGestao / indicadorPlanoAcidenteTrabalho / indicadorPlanoSaudeOcupacional / indicadorPlanoAPS
				self:lAllFalseIndicators := allFalseIndicators(self:lIsSubcontract, {"selfManagement": .T., "lowCostPlan": .F., "workAccidentPlan": .T., "occupationalHealthPlan": .T., "APSPlan": .T.})
				self:lIsRiskSharing := isRiskSharing()
				self:lIsPlanHolder := isPlanHolder()

				self:loadHeader(cTransactionCode)
				self:loadBeneficiaryData()
				self:loadContractingCompanyData()
				self:loadPlanData()
				self:loadPersonData()
				self:loadRiskSharing()

			case self:cOperation == EXCLUSION_TYPE
				self:loadHeader(cTransactionCode)
				self:loadQueryParamsDelete(cTransactionCode)
		endcase

		if !self:lIsError
			lAdd := .T.
		endif
	else
		self:setError("422.001",;
					  STR0001,; // "Beneficiário não encontrado."
					  STR0002 + cSubscriberId + ".") // "Não foi encontrado nenhum beneficiário com a matrícula "
		lAdd := .F.
	endif

	if existBlock("PTU001OBJ")
		self:jBody := execBlock("PTU001OBJ", .F., .F., {self:jBody, cOperation})
	endif

return lAdd

/*/{Protheus.doc} send
Envia o beneficiário adicionado pelo método addBeneficiary para CadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@return logical, se o beneficiário foi enviado com sucesso para o CadBenef
/*/
method send() as logical class CadBenefApiBeneficiaries

	local lSuccess := .F. as logical
	local aHeaders := {} as array

	if self:oToken:getToken()
		if self:loadApiConfig(self:cUnimedOrigin)
			aAdd(aHeaders, {"key": "Content-Type", "value": "application/json"})
			aAdd(aHeaders, {"key": "Authorization", "value": "Bearer " + self:oToken:getBearer()})

			self:setHeaderParams(aHeaders)

			do case
				case self:cOperation == INCLUSION_TYPE
					self:setBody(self:jBody:toJson())

					lSuccess := self:post()

				case self:cOperation == UPDATE_TYPE
					self:setPath("/" + self:cSubscriberId)
					self:setBody(self:jBody:toJson())

					lSuccess := self:patch()

				case self:cOperation == EXCLUSION_TYPE
					self:setPath("/" + self:cSubscriberId)
					self:setQueryParams(self:aParams)

					lSuccess := self:delete()
			endcase

			if lSuccess
				lSuccess := self:setResponse()
			else
				self:jResponse:fromJson(self:getBody())
			endif

			self:cMessage := self:getStatusCodeMessage(cValToChar(self:getStatusCode()), self:cOperation)

			if empty(self:cMessage) .and. self:jResponse:hasProperty("message")
				self:cMessage := self:jResponse["message"]
			endif
		else
			lSuccess := .F.
		endif
	else
		lSuccess := .F.
		self:cMessage := self:oToken:getMessage()
		self:jResponse := self:oToken:getBody()
	endif

	fwFreeArray(aHeaders)

return lSuccess

/*/{Protheus.doc} getRequest
obter json de envio do beneficiário
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@return json, objeto json com os dados da solicitação
/*/
method getRequest() as json class CadBenefApiBeneficiaries

return self:jBody

/*/{Protheus.doc} getResponse
Obter json de resposta do envio do beneficiário
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@return json, objeto json com os dados da resposta
/*/
method getResponse() as json class CadBenefApiBeneficiaries

return self:jResponse

/*/{Protheus.doc} getParamsToString
Obter os parâmetros no formato de string
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@return character, string com os parâmetros
/*/
method getParamsToString() as character class CadBenefApiBeneficiaries

	local cParams as character
	local nCount as numeric

	cParams := "["
	for nCount := 1 to len(self:aParams)
		if nCount > 1
			cParams += ","
		endif

		cParams += self:aParams[nCount]:toJson()

	next nCount
	cParams += "]"

return cParams

/*/{Protheus.doc} getMessage
Obter mensagem de resposta do processamento
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@return character, mensagem de erro ou sucesso
/*/
method getMessage() as character class CadBenefApiBeneficiaries

return self:cMessage

/*/{Protheus.doc} destroy
Limpa da memória as variáveis (objeto, array e json) da clase
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
/*/
method destroy() class CadBenefApiBeneficiaries

	freeObj(self:jBody)
	freeObj(self:jResponse)
	freeObj(self:oToken)
	freeObj(self:jHolderData)
	freeObj(self:jStatusCodeMessage)
	fwFreeArray(self:aParams)

return

/*/{Protheus.doc} openUsedTables
Abri as tabelas do beneficiário para ser utilizado na montagem do json de envio
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
/*/
method openUsedTables() class CadBenefApiBeneficiaries

	BA0->(dbSetOrder(1))
	BA0->(dbSeek(xFilial("BA0") + BA1->BA1_CODINT))

	BG9->(dbSetOrder(1))
	BG9->(dbSeek(xFilial("BG9") + BA1->(BA1_CODINT + BA1_CODEMP)))

	BQC->(dbSetOrder(1))
	self:lIsSubcontract := BQC->(dbSeek(xFilial("BQC") + BA1->(BA1_CODINT + BA1_CODEMP + BA1_CONEMP + BA1_VERCON + BA1_SUBCON + BA1_VERSUB)))			

	BA3->(dbSetOrder(1))
	BA3->(dbSeek(xFilial("BA1") + BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_CONEMP + BA1_VERCON + BA1_SUBCON + BA1_VERSUB)))

	BI3->(dbSetOrder(1))
	BI3->(dbSeek(xFilial("BI3") + iif(empty(BA1->BA1_CODPLA), BA3->(BA3_CODINT + BA3_CODPLA + BA3_VERSAO), BA1->(BA1_CODINT + BA1_CODPLA + BA1_VERSAO))))
	self:lIsRuled := iif(BI3->BI3_APOSRG == "1", .T., .F.)

	BTS->(dbSetOrder(1))
	BTS->(dbSeek(xFilial("BTS") + BA1->BA1_MATVID))

return

/*/{Protheus.doc} loadHeader
Carrega os dados do cabeçalho na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param cTransactionCode, character, código da transação gerado
/*/
method loadHeader(cTransactionCode as character) class CadBenefApiBeneficiaries

	local cOrigin := "cabecalho" as character

	self:jBody["cabecalho"] := JsonObject():new()
	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "codigoControleTransacao", "value": cTransactionCode, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0021}) // Regra: Não deve ser repetido

	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "codigoVersaoPTU", "value": "012", "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0022}) // F"012"

	self:jBody["cabecalho"]["unimed"] := JsonObject():new()
	self:setAttribute({"body": self:jBody["cabecalho"]["unimed"], "attribute": "codigoUnimedOrigem", "value": self:cUnimedOrigin, "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0023})

	self:setAttribute({"body": self:jBody["cabecalho"]["unimed"], "attribute": "codigoUnimedDestino", "value": 999, "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0024}) // Fixo 0999

	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "dataGeracao", "value": dDataBase, "type": "date5", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0025})

	self:setAttribute({"body": self:jBody["cabecalho"], "attribute": "protocoloContrato", "value": iif(BG9->BG9_TIPO == "1", BA3->BA3_NPROVC,BQC->BQC_MSGRVC), "type": "character", "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": ""})

return

/*/{Protheus.doc} loadBeneficiaryData
Carrega os dados do beneficiário na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
/*/
method loadBeneficiaryData() class CadBenefApiBeneficiaries

	local cOrigin := "dadosBeneficiario" as character
	local cDependencyCode as character
	
	self:jBody["dadosBeneficiario"] := JsonObject():new()

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "carteirinhaBeneficiario",;
					   "value": BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0026})

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "codigoControleUnimedBrasil",;
					   "value": BA1->BA1_CODUBR, "type": "character", "required": self:cOperation == UPDATE_TYPE, "origin": cOrigin,;
					   "errorDetailedMessage": STR0027}) // Regra: Obrigatório quando Atualização de Beneficiário ; Número será gerado pela Unimed do Brasil

	if self:lIsRiskSharing
		self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "codigoFamiliaBenef",;
						   "value": BA1->BA1_MATRIC, "type": "numeric", "required": self:lIsRiskSharing, "origin": cOrigin,;
						   "errorDetailedMessage": STR0028}) // Regra: Obrigatório quando Compartilhamento de Risco
	endif

	cDependencyCode := getDependencyCode()

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "codigoDependenciaBeneficiario",;
		   			   "value": cDependencyCode, "type": "character", "required": self:lAllFalseIndicators, "origin": cOrigin,;
		   			   "errorDetailedMessage": STR0029}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)
					
	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "carteirinhaBeneficiarioTitular",;
					   "value": self:jHolderData["subscriberId"], "type": "character", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0030}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	if !self:lIsPlanHolder .and. isRedeemed()
		cBeneficiaryRedeemedCode := getBeneficiaryRedeemedCode()
		self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "codigoControleRemido",;
						"value": cBeneficiaryRedeemedCode, "type": "character", "required": OPTIONAL, "origin": cOrigin,;
						"errorDetailedMessage": STR0027})
	endif

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "numeroPlanoPortabilidade",;
					   "value": BA1->BA1_PLPOR, "type": "character", "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": STR0031}) // Regra: Obrigatório para portabilidade

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "indicadorSib",;
					   "value": iif(BA1->BA1_INFSIB == "1" .and. self:lAllFalseIndicators, .T., .F.), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0032}) // Regra: Quando um dos indicadores estiver preenchido com valor 1 (True), esse campo terá valor fixo 0 (False)

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "indicadorRemido",;
					   "value": iif(!self:lAllFalseIndicators, .F., isRedeemed()), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0033}) // Regra: Quando um dos indicadores estiver preenchido com valor 1 (True), esse campo terá valor fixo 0 (False)

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "indicadorAutoGestao",;
					   "value": isSelfManagement(self:lIsSubcontract), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0034})

	if self:jBody["dadosBeneficiario"]["indicadorAutoGestao"]
		self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "codigoAutoGestaoAns",;
						   "value": BA0->BA0_SUSEP, "type": "numeric", "required": self:jBody["dadosBeneficiario"]["indicadorAutoGestao"], "origin": cOrigin,;
						   "errorDetailedMessage": STR0035}) // Regra: Obrigatorio se indicadorAutoGestao = 1 (True)
	endif

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "indicadorBeneficiarioCooperado",;
					   "value": iif(BA1->BA1_COOPER == "1" .and. self:lAllFalseIndicators, .T., .F.), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0036}) // Regra: Quando um dos indicadores estiver preenchido com valor 1 (True), esse campo terá valor fixo 0 (False)

	if self:jBody["dadosBeneficiario"]["indicadorBeneficiarioCooperado"] // Regra: Obrigatório quando indicadorBeneficiarioCooperado = 1 (True)
		self:loadMemberData()
	endif

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "dataInclusaoUnimed",;
					   "value": BA1->BA1_DATINC, "type": "date3", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0037})

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "dataExclusaoBeneficiario",;
					   "value": BA1->BA1_DATBLO, "type": "date3", "required": iif(!empty(BA1->BA1_DATBLO), REQUIRED, OPTIONAL), "origin": cOrigin,;
					   "errorDetailedMessage": STR0038}) // Regra: Obrigatório quando existir exclusão

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "motivoExclusaoBeneficiario",;
					   "value": getReasonExclusion(), "type": "character",;
					   "required": self:jBody["dadosBeneficiario"]:hasProperty("dataExclusaoBeneficiario") .and. !empty(self:jBody["dadosBeneficiario"]["dataExclusaoBeneficiario"]), "origin": cOrigin,;
					   "errorDetailedMessage": STR0039}) // Regra: Obrigatório quando dataExclusaoBeneficiario estiver preenchido

	if self:lIsRiskSharing
		self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "codigoPlanoInter",;
						   "value": getInterPlanCode(), "type": "character", "required": self:lIsRiskSharing, "origin": cOrigin,;
						   "errorDetailedMessage": STR0040}) // Regra: Obrigatório quando compartilhamento de Risco

		self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "numeroMatricula",;
						   "value": nil, "type": "character", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": ""}) // Regra: Obrigatório quando compartilhamento de Risco

		self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "codigoLotacao",;
						   "value": nil, "type": "character", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": ""}) // Regra: Obrigatório quando compartilhamento de Risco

		self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "descricaoLotacao",;
						   "value": nil, "type": "character", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": ""}) // Regra: Obrigatório quando compartilhamento de Risco

		self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "dataInclusaoPlanoDestino",;
						   "value": BA1->BA1_DATREP, "type": "date3", "required": self:lIsRiskSharing, "origin": cOrigin,;
						   "errorDetailedMessage": STR0042}) // Regra: Obrigatório quando compartilhamento de Risco
	endif

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "indicadorExcRN561",;
					   "value": iif(empty(BA1->BA1_DATBLO), .F., isExclusionRN561()), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0041}) // Regra: Quando dataExclusaoBeneficiario não estiver preenchido, esse campo terá valor fixo 0 (False)

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "indicadorNato",;
					   "value": iif(BA1->BA1_RECNAS == "1" .and. self:lAllFalseIndicators, .T., .F.), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0043}) // Regra: Quando um dos indicadores estiver preenchido com valor 1 (True), esse campo terá valor fixo 0 (False)

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "carteirinhaAnterior",;
					   "value": BA1->BA1_MATANT, "type": "character", "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": STR0121}) // Regra: mandatório em casos de transferência de código de benefciciário.

	self:setAttribute({"body": self:jBody["dadosBeneficiario"], "attribute": "idFilho", "value": getChildId(),;
					   "type": "character", "required": cDependencyCode $ "10-70-75" .and. calc_Idade(dDataBase, BA1->BA1_DATNAS) >= 18, "origin": cOrigin,;
					   "errorDetailedMessage": STR0122}) //Regra: Obrigatório sempre que CD_DEPE = 10, 70 ou 75 e que tenha atingido a maioridade.
	
	self:loadAggregateProduct()
	self:loadPreexistence()

return

/*/{Protheus.doc} loadMemberData
Carrega os dados do cooperado na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadMemberData() class CadBenefApiBeneficiaries

	local cCodigoCrm := "" as character
	local cCodigoUfConselho := "" as character
	local cOrigin := "dadosCooperado" as character

	self:jBody["dadosBeneficiario"]["dadosCooperado"] := JsonObject():new()

	BAU->(dbSetOrder(4))
	if BAU->(dbSeek(xFilial("BAU") + BA1->BA1_CPFUSR))
		cCodigoCrm := BAU->BAU_CONREG
		cCodigoUfConselho := BAU->BAU_ESTCR
	endif

	self:setAttribute({"body": self:jBody["dadosBeneficiario"]["dadosCooperado"], "attribute": "codigoCrm",;
					   "value": cCodigoCrm, "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0044})

	self:setAttribute({"body": self:jBody["dadosBeneficiario"]["dadosCooperado"], "attribute": "codigoUfConselho",;
					   "value": cCodigoUfConselho, "type": "uf", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0045})

return

/*/{Protheus.doc} loadAggregateProduct
Carrega os dados do produto do agregado na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadAggregateProduct() class CadBenefApiBeneficiaries

	local jAggregateProduct as json
	local aAreaBI3 := BI3->(getArea())
	local cOrigin := "produtoAgregado" as character
	local cPlanCode := BI3->BI3_CODPTU as character

	BF4->(dbSetOrder(1))
	if BF4->(dbSeek(xFilial("BF4") + BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG)))

		while !BF4->(eof()) .and. BF4->(BF4_FILIAL + BF4_CODINT + BF4_CODEMP + BF4_MATRIC + BF4_TIPREG) == ;
								  xFilial("BF4") + BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG)

			if Empty(BF4->BF4_DATBLO) .Or. BF4->BF4_DATBLO >= dDataBase
				if !self:jBody["dadosBeneficiario"]:hasProperty("produtoAgregado")
					self:jBody["dadosBeneficiario"]["produtoAgregado"] := {}
				endif

				if BI3->(dbSeek(xFilial("BI3") + BF4->(BF4_CODINT + BF4_CODPRO + BF4_VERSAO)))
					jAggregateProduct := JsonObject():new()

					self:setAttribute({"body": jAggregateProduct, "attribute": "indicadorCompartilhamento",;
									   "value": self:lIsRiskSharing, "type": "logical", "required": OPTIONAL, "origin": cOrigin,;
									   "errorDetailedMessage": STR0128}) // Regra: Se o beneficiário for de compartilhamento de risco, preencher com valor 1 (true).

					self:setAttribute({"body": jAggregateProduct, "attribute": "codigoUnimedDestino",;
									   "value": BA1->BA1_OPEDES, "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
									   "errorDetailedMessage": STR0049}) // Regra: Obrigatório quando beneficiário tiver Produto Agregado 

					self:setAttribute({"body": jAggregateProduct, "attribute": "tipoProduto",;
									   "value": BI3->BI3_CODPTU, "type": "character", "required": REQUIRED, "origin": cOrigin,;
									   "errorDetailedMessage": STR0046}) // Regra: Obrigatório quando beneficiário tiver Produto Agregado 

					self:setAttribute({"body": jAggregateProduct, "attribute": "descricaoProduto",;
									   "value": BI3->BI3_DESCRI, "type": "character", "size": 20, "required": OPTIONAL, "origin": cOrigin,;
									   "errorDetailedMessage": STR0047})

					self:setAttribute({"body": jAggregateProduct, "attribute": "codigoPlanoDestino",;
									   "value": iif(self:lIsRiskSharing, getInterPlanCode(), cPlanCode), "type": "character",;
									   "required": jAggregateProduct:hasProperty("indicadorCompartilhamento") .and. !jAggregateProduct["indicadorCompartilhamento"], "origin": cOrigin,;
									   "errorDetailedMessage": STR0137}) // Regra: Obrigatório quando beneficiário tiver Produto Agregado E IndicadorCompartilhamento igual a FALSE (0)
									
					self:setAttribute({"body": jAggregateProduct, "attribute": "dataRepasseUnimedDestino",;
									   "value": iif(self:lIsRiskSharing, BA1->BA1_DATREP, BA1->BA1_DATINC), "type": "date3",;
									   "required": jAggregateProduct:hasProperty("indicadorCompartilhamento") .and. !jAggregateProduct["indicadorCompartilhamento"], "origin": cOrigin,;
									   "errorDetailedMessage": STR0136}) // Regra: Obrigatório quando beneficiário tiver Produto Agregado E IndicadorCompartilhamento igual a FALSE (0)

					self:setAttribute({"body": jAggregateProduct, "attribute": "dataInicioVigenciaProduto",;
									   "value": BF4->BF4_DATBAS, "type": "date3",;
									   "required": jAggregateProduct:hasProperty("indicadorCompartilhamento") .and. !jAggregateProduct["indicadorCompartilhamento"], "origin": cOrigin,;
									   "errorDetailedMessage": STR0131}) // Regra: Obrigatório quando beneficiário tiver Produto Agregado E IndicadorCompartilhamento igual a FALSE (0)

					self:setAttribute({"body": jAggregateProduct, "attribute": "dataFimVigenciaProduto",;
									   "value": BF4->BF4_DATBLO, "type": "date3", "required": OPTIONAL, "origin": cOrigin,;
									   "errorDetailedMessage": STR0135}) 

					self:setAttribute({"body": jAggregateProduct, "attribute": "dataBaseCarencia",;
									   "value": BF4->BF4_DATBAS, "type": "date3",;
									   "required": jAggregateProduct:hasProperty("indicadorCompartilhamento") .and. !jAggregateProduct["indicadorCompartilhamento"], "origin": cOrigin,;
									   "errorDetailedMessage": STR0134}) // Regra: Obrigatório quando beneficiário tiver Produto Agregado E IndicadorCompartilhamento igual a FALSE (0)

					self:setAttribute({"body": jAggregateProduct, "attribute": "valorMensalidade",;
										"value": getMonthlyValue(), "type": "numeric", "required": OPTIONAL , "origin": cOrigin,;
										"errorDetailedMessage": STR0120}) 

					aAdd(self:jBody["dadosBeneficiario"]["produtoAgregado"], jAggregateProduct)
				endif
			endif
		
			BF4->(dbSkip())
		enddo
	endif

	restArea(aAreaBI3)

	freeObj(jAggregateProduct)
	fwFreeArray(aAreaBI3)

return

/*/{Protheus.doc} loadPreexistence
Carrega os dados de preexistencia na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadPreexistence() class CadBenefApiBeneficiaries

	local jCID as json
	local cOrigin := "preexistencia" as character

	BF3->(dbSetOrder(1))
	if BF3->(dbSeek(xFilial("BF3") + BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG)))
		self:jBody["dadosBeneficiario"]["preexistencia"] := {}

		while !BF3->(eof()) .and. BF3->(BF3_FILIAL + BF3_CODINT + BF3_CODEMP + BF3_MATRIC + BF3_TIPREG) == ;
								  xFilial("BF3") + BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG)
			jCID := JsonObject():new()

			self:setAttribute({"body": jCID, "attribute": "codigoCID",;
							   "value": BF3->BF3_CODDOE, "type": "character", "required": REQUIRED, "origin": cOrigin,;
							   "errorDetailedMessage": STR0048}) // Regra: Obrigatório quando beneficiário tiver preexistencia

			self:setAttribute({"body": jCID, "attribute": "codigoTUSS",;
							   "value": nil, "type": "character", "required": OPTIONAL, "origin": cOrigin,;
							   "errorDetailedMessage": ""})

			self:setAttribute({"body": jCID, "attribute": "dataFimCarencia",;
							   "value": getGracePeriodEndDate(), "type": "date3", "required": REQUIRED, "origin": cOrigin,;
							   "errorDetailedMessage": STR0051}) // Regra: Obrigatório quando beneficiário tiver preexistencia

			aAdd(self:jBody["dadosBeneficiario"]["preexistencia"], jCID)

			BF3->(dbSkip())
		enddo
	endif

	freeObj(jCID)

return

/*/{Protheus.doc} loadContractingCompanyData
Carrega os dados de empresa contratante na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadContractingCompanyData() class CadBenefApiBeneficiaries

	local cOrigin := "dadosEmpresaContratante" as character

	if self:lIsSubcontract

		self:jBody["dadosEmpresaContratante"] := JsonObject():new()

		self:loadTypeCompany()

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"], "attribute": "nomeEmpresa",;
						   "value": BG9->BG9_DESCRI, "type": "character", "size": 40, "required": self:lAllFalseIndicators, "origin": cOrigin,;
						   "errorDetailedMessage": STR0056}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"], "attribute": "nomeFantasiaEmpresa",;
						   "value": BG9->BG9_DESCRI, "type": "character", "size": 40, "required": self:lAllFalseIndicators, "origin": cOrigin,;
						   "errorDetailedMessage": STR0056}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"], "attribute": "nomeEmpresaAbreviado",;
						   "value": BG9->BG9_NREDUZ, "type": "character", "size": 30, "required": self:lAllFalseIndicators, "origin": cOrigin,;
						   "errorDetailedMessage": STR0057}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"], "attribute": "inscricaoEstadual",;
						   "value": nil, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": ""}) // Não utilizado

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"], "attribute": "codigoFilial",;
						   "value": nil, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": ""}) // Não utilizado

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"], "attribute": "dataInclusaoEmpresaUnimed",;
						   "value": BQC->BQC_DATCON, "type": "date3", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": STR0129}) // Regra: Obrigatorio quando Produtos

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"], "attribute": "dataExclusaoEmpresaUnimed",;
						   "value": BQC->BQC_DATBLO, "type": "date3", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": STR0130})

		self:loadAddressCompany()

		self:loadPhoneCompany()

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"], "attribute": "codigoEmpresaOrigem",;
						   "value": BG9->BG9_CODIGO, "type": "numeric", "required": self:lAllFalseIndicators, "origin": cOrigin,;
						   "errorDetailedMessage": STR0058}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"], "attribute": "tipoContratoLocal",;
						   "value": iif(alltrim(BI3->BI3_MODPAG) == "1", "1", "2"), "type": "numeric", "required": self:lAllFalseIndicators, "origin": cOrigin,;
						   "errorDetailedMessage": STR0050}) // 1 – Pré-Pagamento 2 – Pós-Pagamento - Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)
	endif

return

/*/{Protheus.doc} loadTypeCompany
Carrega os dados de tipo de empresa na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadTypeCompany() class CadBenefApiBeneficiaries

	local jCompanyType as json
	local cOrigin := "tipoEmpresa" as character

	self:jBody["dadosEmpresaContratante"]["tipoEmpresa"] := JsonObject():new()

	jCompanyType := getCompanyType()

	// Regras: Obrigatório o preenchimento de um dos campos
	self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["tipoEmpresa"], "attribute": "cnpj",;
					   "value": jCompanyType["cnpj"], "type": "character", "required": empty(jCompanyType["caepf"]), "origin": cOrigin,;
					   "errorDetailedMessage": STR0059}) // Regra: Quando um dos indicadores estiver preenchido com valor 1 (True), o campo CNPJ será Obrigatório:

	self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["tipoEmpresa"], "attribute": "caepf",;
					   "value": jCompanyType["caepf"], "type": "character", "required": empty(jCompanyType["cnpj"]), "origin": cOrigin,;
					   "errorDetailedMessage": STR0060})

	freeObj(jCompanyType)

return

/*/{Protheus.doc} loadAddressCompany
Carrega os dados de de endereco da empresa contratante na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadAddressCompany() class CadBenefApiBeneficiaries

	local lHasValue as logical
	local cOrigin := "endereco" as character

	lHasValue := !empty(BQC->BQC_LOGRAD) .or. !empty(BQC->BQC_COMPLE) .or. !empty(BQC->BQC_NUMERO) .or.;
				 !empty(BQC->BQC_BAIRRO) .or. !empty(BQC->BQC_CODMUN) .or. !empty(BQC->BQC_CEP)

	if lHasValue .or. self:lAllFalseIndicators

		self:jBody["dadosEmpresaContratante"]["endereco"] := JsonObject():new()

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["endereco"], "attribute": "logradouroPrincipal",;
						   "value": BQC->BQC_LOGRAD, "type": "character", "size": 80, "required": self:lAllFalseIndicators, "origin": cOrigin,;
						   "errorDetailedMessage": STR0061}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["endereco"], "attribute": "complementoLogradouro",;
						   "value": BQC->BQC_COMPLE, "type": "character", "size": 80, "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": STR0062})

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["endereco"], "attribute": "numeroLogradouro",;
						   "value": iif(empty(BQC->BQC_NUMERO), "S/N", BQC->BQC_NUMERO), "type": "character", "required": self:lAllFalseIndicators, "origin": cOrigin,;
						   "errorDetailedMessage": STR0063}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["endereco"], "attribute": "bairro",;
						   "value": BQC->BQC_BAIRRO, "type": "character", "size": 45, "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": STR0064})

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["endereco"], "attribute": "codigoMunicipio",;
						   "value": BQC->BQC_CODMUN, "type": "numeric", "required": self:lAllFalseIndicators, "origin": cOrigin,;
						   "errorDetailedMessage": STR0065}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["endereco"], "attribute": "cep",;
						   "value": BQC->BQC_CEP, "type": "character", "required": self:lAllFalseIndicators, "origin": cOrigin,;
						   "errorDetailedMessage": STR0066})
	endif

return

/*/{Protheus.doc} loadPhoneCompany
Carrega os dados do telefone da empresa contratante na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2510 
@author giovanna.charlo
@since 07/01/2025
/*/
method loadPhoneCompany() class CadBenefApiBeneficiaries

	local cOrigin := "dadosEmpresaContratante" as character

	if BQC->(fieldPos("BQC_TIPTEL")) > 0 .and. BQC->(fieldPos("BQC_DDD")) > 0 

		if empty(alltrim(BQC->BQC_TIPTEL)) .and. empty(alltrim(BQC->BQC_DDD)) .and. empty(alltrim(BQC->BQC_TEL))
			return
		endif
		
		self:jBody["dadosEmpresaContratante"]["telefone"] := JsonObject():new()

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["telefone"], "attribute": "tipoTelefone",;
						   "value": BQC->BQC_TIPTEL, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": STR0124}) 

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["telefone"], "attribute": "ddd",;
						   "value": BQC->BQC_DDD, "type": "numeric", "required": BQC->BQC_TIPTEL $ "1-2-3", "origin": cOrigin,;
						   "errorDetailedMessage": STR0125}) // Regra: Obrigatório se tipoTelefone = 1, 2 ou 3 

		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["telefone"], "attribute": "numero",;
						   "value": BQC->BQC_TEL, "type": "numeric", "size": 9, "required": BQC->BQC_TIPTEL $ "1-2-3", "origin": cOrigin,;
						   "errorDetailedMessage": STR0126}) // Regra: Obrigatório se tipoTelefone = 1, 2 ou 3 
						   
		self:setAttribute({"body": self:jBody["dadosEmpresaContratante"]["telefone"], "attribute": "ramal",;
						   "value": nil, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": "" }) // Não utilizado 

	endif

return

/*/{Protheus.doc} loadPlanData
Carrega os dados do plano na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadPlanData() class CadBenefApiBeneficiaries

	local nTypeContract as numeric
	local dLastDateCPT := ctod(" / / ") as date
	local cOrigin := "dadosPlano" as character
	local lHasIndicPlan := BI3->(fieldPos("BI3_INDPLA")) > 0 as logical
	local lIsProtocol := self:isContractProtocol()

	self:jBody["dadosPlano"] := JsonObject():new()

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "codigoPlanoOrigem",;
					   "value": BI3->BI3_CODIGO, "type": "character", "required": self:lIsRiskSharing, "origin": cOrigin,;
					   "errorDetailedMessage": STR0067}); // Regra: Obrigatório quando conter compartilhamento de Riscos

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "dataInicioVigencia",;
					   "value": BA1->BA1_DATINC, "type": "date3", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0037})

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "dataFimVigencia",;
					   "value": BA1->BA1_DATBLO, "type": "date3", "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": ""})

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "tipoAbrangencia",;
					   "value": posicione("BF7", 1, xFilial("BF7") + BI3->BI3_ABRANG, "BF7_CODEDI"), "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0068}) // Quando tipo 2, obrigatório preencher abrangências.codigoUf; Quando tipo 4, obrigatório preencher

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "tipoContratacao",;
					   "value": BI3->BI3_CLAPLS, "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0069})

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "tipoAcomodacao",;
					   "value": getTypeAccommodation(), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0070})

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "codigoOperadoraAns",;
					   "value": BA0->BA0_SUSEP, "type": "numeric", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0035}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "tipoRegistroPlanoAns",;
					   "value": getPlanTypeANS(), "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0071})

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "codigoRegistroPlanoAns",;
					   "value": iif(BI3->BI3_APOSRG == "1", BI3->BI3_SUSEP, BI3->BI3_SCPA), "type": "character", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0072}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "segmentacaoPlano",;
					   "value": posicione("BI6", 1, xFilial("BI6") + BI3->BI3_CODSEG, "BI6_CODEDI"), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0073})

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "codigoRedeReferenciada",;
					   "value": iif(!empty(BI3->BI3_REDREF) .and. alltrim(BI3->BI3_REDREF) <> "1", BI3->BI3_REDREF, substr(BI3->BI3_REDEDI, 1, 4)),;
					   "type": "character", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0074}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "nomeRede",;
					   "value": BI3->BI3_RRFDES, "type": "character", "size": 40, "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0075}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "viaCartao",;
					   "value": BA1->BA1_VIACAR, "type": "numeric", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0076}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "dataValidadeCartao",;
					   "value": BA1->BA1_DTVLCR, "type": "date3", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0077}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "codigoLocalAtendimento",;
					   "value": BI3->BI3_LATEDI, "type": "numeric", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0078}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	dLastDateCPT := getLastDateCPT()
	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "indicadorCoberturaParcialTemporaria",;
					   "value": iif(!empty(BA1->BA1_DATCPT) .or. !empty(dLastDateCPT), .T., .F.), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0051})

	if self:jBody["dadosPlano"]["indicadorCoberturaParcialTemporaria"]
		self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "dataFimCoberturaParcialTemporaria",;
						   "value": iif(!empty(dLastDateCPT), dLastDateCPT, BA1->BA1_DATCPT), "type": "date3", "required": self:jBody["dadosPlano"]["indicadorCoberturaParcialTemporaria"], "origin": cOrigin,;
						   "errorDetailedMessage": STR0051}) // Regra: Obrigatório se indicadorCoberturaParcialTemporaria = 1 (true)
	endif

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "tipoContrato",;
					   "value": iif(alltrim(BI3->BI3_MODPAG) == "1", "P", "C"), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0050})

	nTypeContract := iif(self:jBody["dadosPlano"]:hasProperty("tipoContratacao") .and. !empty(self:jBody["dadosPlano"]["tipoContratacao"]), self:jBody["dadosPlano"]["tipoContratacao"], 0)

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "cnpjAdmBeneficios",;
					   "value": BQC->BQC_CNPADM, "type": "character", "required": nTypeContract == 3 .and. lIsProtocol, "origin": cOrigin,;
					   "errorDetailedMessage": STR0079}) // Regra: Obrigatório quando tipoContratacao = 3 (Coletivo por adesão) e protocoloProspeccao ou protocoloContrato estiver preenchido

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "registroANSAdmBeneficios",;
					   "value": BQC->BQC_RECANS, "type": "numeric", "required": nTypeContract == 3 .and. lIsProtocol, "origin": cOrigin,;
					   "errorDetailedMessage": STR0127}) // Regra: Obrigatório quando tipoContratacao = 3 (Coletivo por adesão) e protocoloProspeccao ou protocoloContrato estiver preenchido

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "nomeAdmBeneficios",;
					   "value": BQC->BQC_RAZSBE, "type": "character", "size": 40, "required": nTypeContract == 3 .and. lIsProtocol, "origin": cOrigin,;
					   "errorDetailedMessage": STR0080}) // Regra: Obrigatório quando tipoContratacao = 3 (Coletivo por adesão) e protocoloProspeccao ou protocoloContrato estiver preenchido

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "nomeFantasiaAdmBeneficios",;
					   "value": BQC->BQC_SEASPL, "type": "character", "size": 40, "required": nTypeContract == 3 .and. lIsProtocol, "origin": cOrigin,;
					   "errorDetailedMessage": STR0081}) // Regra: Obrigatório quando tipoContratacao = 3 (Coletivo por adesão) e protocoloProspeccao ou protocoloContrato estiver preenchido

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "nomeProduto",;
					   "value": BI3->BI3_DESCRI, "type": "character", "size": 60, "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0082}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "numeroContrato",;
					   "value": iif(self:lIsSubcontract, alltrim(BQC->BQC_NUMCON) + alltrim(BQC->BQC_VERCON), BA1->(BA1_CODINT + BA1_CODEMP)), "type": "character", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0083}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "dataContratacaoPlano",;
					   "value": iif(self:lIsSubcontract, BQC->BQC_DATCON, BA1->BA1_DATINC), "type": "date3", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0084}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "tipoRede",;
					   "value": BI3->BI3_TIPRED, "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0055})

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "indicadorPlanoLowCost",;
					   "value": iif(lHasIndicPlan, iif(BI3->BI3_INDPLA == "1", .T., .F. ), .F.), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0085}) // 1 = Plano LowCost

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "indicadorPlanoAcidenteTrabalho",;
					   "value": iif(lHasIndicPlan, iif(BI3->BI3_INDPLA == "2", .T., .F. ), .F.), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0085}) // 2 = Plano de Acidente de Trabalho

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "indicadorPlanoSaudeOcupacional",;
					   "value": iif(lHasIndicPlan, iif(BI3->BI3_INDPLA == "3", .T., .F. ), .F.), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0085}) // 3 = Plano de Saúde Ocupacional

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "indicadorPlanoAPS",;
					   "value": iif(lHasIndicPlan, iif(BI3->BI3_INDPLA == "4", .T., .F. ), .F.), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0085}) // 4 = Plano APS

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "complemento1",;
					   "value": nil, "type": "logical", "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": ""}) // Não utilizado

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "complemento2",;
					   "value": nil, "type": "logical", "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": ""}) // Não utilizado

	self:setAttribute({"body": self:jBody["dadosPlano"], "attribute": "indicadorAtendimentoUrgencia",;
					   "value": iif(self:jBody["dadosPlano"]["tipoAbrangencia"] == 1, .T., .F.),;
					   "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0068})

	self:loadScopes()
	self:loadGracePeriod()
	self:loadCoveragePeriod()

return

/*/{Protheus.doc} loadScopes
Carrega os dados de abrangência na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadScopes() class CadBenefApiBeneficiaries

	local nTypeScopes := 0 as numeric
	local cFilialB9B := xFilial("B9B") as character
	local cFilialB9C := xFilial("B9C") as character
	local jScope as json
	local cOrigin := "abrangencias" as character

	if self:jBody["dadosPlano"]:hasProperty("tipoAbrangencia") .and. !empty(self:jBody["dadosPlano"]["tipoAbrangencia"])
		nTypeScopes := self:jBody["dadosPlano"]["tipoAbrangencia"]
	endif

	BF7->(dbSetOrder(1))
	if BF7->(dbSeek(xFilial("BF7") + BI3->BI3_ABRANG))
		do case
			case BF7->BF7_CODEDI == "2" // Regional A - Grupo de Estados
				B9C->(dbSetOrder(1))
				if B9C->(dbSeek(cFilialB9C + BF7->BF7_CODORI))
					self:jBody["dadosPlano"]["abrangencias"] := {}

					while !B9C->(Eof()) .and. B9C->B9C_FILIAL + B9C->B9C_CODORI == cFilialB9C + BF7->BF7_CODORI
						jScope := JsonObject():new()

						self:setAttribute({"body": jScope, "attribute": "codigoUf", "value": B9C->B9C_ESTADO, "type": "uf", "required": REQUIRED, "origin": cOrigin,;
										   "errorDetailedMessage": STR0116}) // Regra: Obrigatório quando tp_abrangencia = 2

						aAdd(self:jBody["dadosPlano"]["abrangencias"], jScope)

						B9C->(dbSkip())
					enddo
				endif

			case BF7->BF7_CODEDI == "4" // Regional B - Grupo de Municípios
				B9B->(dbSetOrder(1))
				if B9B->(dbSeek(cFilialB9B + BF7->BF7_CODORI))
					self:jBody["dadosPlano"]["abrangencias"] := {}

					while !B9B->(Eof()) .and. B9B->B9B_FILIAL + B9B->B9B_CODORI == cFilialB9B + BF7->BF7_CODORI
						jScope := JsonObject():new()

						self:setAttribute({"body": jScope, "attribute": "codigoMunicipio", "value": B9B->B9B_CODMUN, "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
										   "errorDetailedMessage": STR0117}) // Regra: Obrigatório quando tp_abrangencia = 4

						aAdd(self:jBody["dadosPlano"]["abrangencias"], jScope)

						B9B->(dbSkip())
					enddo
				endif
		endcase
	endif

	freeObj(jScope)

return

/*/{Protheus.doc} loadGracePeriod
Carrega os dados de carência na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadGracePeriod() class CadBenefApiBeneficiaries

	local aGracePeriod := {} as array
	local nCount as numeric
	local nPos as numeric
	local cOrigin := "carencias" as character
	local jGracePeriod as json

	aGracePeriod := PLSCLACAR(BA1->BA1_CODINT, BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO))

	if len(aGracePeriod) > 0 .and. aGracePeriod[1]
		for nCount := 1 to len(aGracePeriod[2])
			If len(aGracePeriod[2][nCount]) > 7 .and. !aGracePeriod[2][nCount][5]
				if !empty(aGracePeriod[2][nCount][8])

					if !self:jBody["dadosPlano"]:hasProperty("carencias")
						self:jBody["dadosPlano"]["carencias"] := {}
					endif

					nPos := aScan(self:jBody["dadosPlano"]["carencias"], {|x| alltrim(x["tipoCarencia"]) == aGracePeriod[2][nCount][8]})

					if nPos > 0
						if transform(dtos(aGracePeriod[2][nCount][3]), "@R 9999-99-99") > self:jBody["dadosPlano"]["carencias"][nPos]["dataFimCarencia"]
							self:setAttribute({"body": self:jBody["dadosPlano"]["carencias"][nPos], "attribute": "dataFimCarencia",;
											   "value": aGracePeriod[2][nCount][3], "type": "date3", "required": REQUIRED, "origin": cOrigin,;
											   "errorDetailedMessage": STR0086})
						endif
					else
						jGracePeriod := JsonObject():new()

						self:setAttribute({"body": jGracePeriod, "attribute": "tipoCarencia",;
											"value": aGracePeriod[2][nCount][8], "type": "character", "required": REQUIRED, "origin": cOrigin,;
											"errorDetailedMessage": STR0086}) // Regra: Obrigatório se Beneficiário possuir Carencia

						self:setAttribute({"body": jGracePeriod, "attribute": "dataFimCarencia",;
										   "value": aGracePeriod[2][nCount][3], "type": "date3", "required": !empty(aGracePeriod[2][nCount][8]), "origin": cOrigin,;
										   "errorDetailedMessage": STR0086}) // Regra: Obrigatório se campo tipoCarencia estiver preenchido

						aAdd(self:jBody["dadosPlano"]["carencias"], jGracePeriod)	
					endif
				endif
			endif
		next nCount
	endif

	fwFreeArray(aGracePeriod)
	freeObj(jGracePeriod)

return

/*/{Protheus.doc} loadCoveragePeriod
Carrega os dados de cobertura na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2510 
@author giovanna.charlo
@since 07/02/2025
/*/
method loadCoveragePeriod() class CadBenefApiBeneficiaries

	local aCoveragePeriod := {} as array
	local jCoveragePeriod as json
	local nCount as numeric
	local cOrigin := "coberturas" as character
	local nSizeArray as numeric
	local nPosCoverage := 0 as numeric

	getBeneficiaryCoverage(@aCoveragePeriod)
    getFamilyCoverage(@aCoveragePeriod)
    getSubcontractCoverage(@aCoveragePeriod)
    getProductCoverage(@aCoveragePeriod)

	if self:lIsRuled .and. len(aCoveragePeriod) == 0 
		getTotalCoverage(@aCoveragePeriod)
		self:lIsTotalCoverage := .T.
	endif

	if len(aCoveragePeriod) > 0 
		nSizeArray := len(aCoveragePeriod)

		for nCount := 1 to nSizeArray
			if !self:jBody["dadosPlano"]:hasProperty("coberturas")
				self:jBody["dadosPlano"]["coberturas"] := {}
			endif

			nPosCoverage := aScan(self:jBody["dadosPlano"]["coberturas"], {|x| alltrim(x["tipoCobertura"]) == aCoveragePeriod[nCount]["code"]})
			if nPosCoverage == 0 .and. !empty(alltrim(aCoveragePeriod[nCount]["code"]))
				jCoveragePeriod := JsonObject():new()

				self:setAttribute({"body": jCoveragePeriod, "attribute": "tipoCobertura",;
									"value": aCoveragePeriod[nCount]["code"], "type": "character", "required": REQUIRED, "origin": cOrigin,;
									"errorDetailedMessage": STR0132}) // Regra: Obrigatório se Beneficiário possuir Cobertura

				self:setAttribute({"body": jCoveragePeriod, "attribute": "dataFimCobertura",;
									"value": aCoveragePeriod[nCount]["date"] , "type": "date3", "required": REQUIRED, "origin": cOrigin,;
									"errorDetailedMessage": STR0133})// Regra: Obrigatório se campo tipoCobertura estiver preenchido
											
				aAdd(self:jBody["dadosPlano"]["coberturas"], jCoveragePeriod)
			endif
		next
	endif

	fwFreeArray(aCoveragePeriod)
	freeObj(jCoveragePeriod)

return

/*/{Protheus.doc} loadPersonData
Carrega os dados da pessoa na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadPersonData() class CadBenefApiBeneficiaries

	local cOrigin := "dadosPessoa" as character

	self:jBody["dadosPessoa"] := JsonObject():new()

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "nomeCompletoBeneficiario",;
					   "value": alltrim(BTS->BTS_NOMUSR) + " " + alltrim(BTS->BTS_SOBRN), "type": "character", "size": 70, "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0087})

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "nomeAbreviadoBeneficiario",;
					   "value": BTS->BTS_NOMCAR, "type": "character", "size": 25, "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0088}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "nomeSocial",;
					   "value": BTS->BTS_NOMSOC, "type": "character", "size": 70, "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": STR0089})

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "nomeSocialCartao",;
					   "value": BTS->BTS_NOMSOC, "type": "character", "size": 25, "required": !empty(BTS->BTS_NOMSOC), "origin": cOrigin,;
					   "errorDetailedMessage": STR0089}) // Regra: Obrigatório quando nomeSocial estiver preenchido

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "genero",;
					   "value": iif(BTS->BTS_SEXO == "1", "M", iif(BTS->BTS_SEXO == "2", "F", "")), "type": "character", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0090})

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "generoSocial",;
					   "value": iif(BTS->BTS_GENSOC == "1", "F", iif(BTS->BTS_GENSOC == "2", "M", "N")), "type": "character", "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": STR0091}) // Regra: Obrigatório quando nomeSocial estiver preenchido.

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "dataNascimento",;
					   "value": BA1->BA1_DATNAS, "type": "date3", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0092})

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "indicadorBeneficiarioEstrangeiro",;
					   "value": iif((cPaisLoc == "BRA" .and. BTS->BTS_NACION == "10") .or. (cPaisLoc == "URU" .and. BTS->BTS_NACION == "25") .or. empty(BTS->BTS_NACION), .F., .T.),;
					   "type": "logical", "required": REQUIRED, "origin": cOrigin,;
					   "errorDetailedMessage": STR0093})

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "cpf",;
					   "value": BA1->BA1_CPFUSR, "type": "date3", "required": !(calc_idade(dDataBase, BA1->BA1_DATNAS) < 18 .or. self:jBody["dadosPessoa"]["indicadorBeneficiarioEstrangeiro"]), "origin": cOrigin,;
					   "errorDetailedMessage": STR0094}) // Regras: Opcional quando beneficiário menor de idade ou se indicadorBeneficiarioEstrangeiro = 1

	if !empty(BTS->BTS_CDIDEN)
		self:jBody["dadosPessoa"]["rg"] := JsonObject():new()

		self:setAttribute({"body": self:jBody["dadosPessoa"]["rg"], "attribute": "codigoIdentidade",;
						   "value": BTS->BTS_CDIDEN, "type": "character", "size": 15, "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": STR0095})

		self:setAttribute({"body": self:jBody["dadosPessoa"]["rg"], "attribute": "orgaoEmissor",;
						   "value": BTS->BTS_ORGEMI, "type": "character", "size": 30, "required": !empty(BTS->BTS_CDIDEN), "origin": cOrigin,;
						   "errorDetailedMessage": STR0096}) // Regra: Obrigatório quando codigoIdentidade estiver preenchido

		self:setAttribute({"body": self:jBody["dadosPessoa"]["rg"], "attribute": "uf",;
						   "value": BTS->BTS_RGEST, "type": "character", "required": !empty(BTS->BTS_CDIDEN), "origin": cOrigin,;
						   "errorDetailedMessage": STR0097}) // Regra: Obrigatório quando codigoIdentidade estiver preenchido

		self:setAttribute({"body": self:jBody["dadosPessoa"]["rg"], "attribute": "codigoPais",;
						   "value": BTS->BTS_CDPAIS, "type": "character", "size": 3, "required": !empty(BTS->BTS_CDIDEN), "origin": cOrigin,;
						   "errorDetailedMessage": STR0098}) // Regra: Obrigatório quando codigoIdentidade estiver preenchido
	endif

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "cns",;
					   "value": BTS->BTS_NRCRNA, "type": "character", "size": 15, "required": !self:jBody["dadosBeneficiario"]["indicadorAutoGestao"] .and. self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0099}) // Regra: Obrigatório quando indicadorAutoGestao = 0. Obrigatório quando todos os indicadores abaixo estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "codigoEstadoCivil",;
					   "value": getMaritalStatus(), "type": "character", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0100}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "nomeMae",;
					   "value": BA1->BA1_MAE, "type": "character", "size": 70, "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": STR0101}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "pisPasep",;
					   "value": iif(!empty(BA1->BA1_PISPAS), BA1->BA1_PISPAS, BTS->BTS_PISPAS), "type": "character", "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": STR0102})

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "codigoMunicipioNaturalidade",;
					   "value": BTS->BTS_CDMNAS, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": STR0119})

	self:setAttribute({"body": self:jBody["dadosPessoa"], "attribute": "codigoMunicipioResidencia",;
					   "value": getCityCode(self:jHolderData), "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": STR0103})

	self:loadComplementsRegistrations()

return

/*/{Protheus.doc} loadRiskSharing
Carrega os dados de compartilhamento de risco em pré-pagamento (repasse) do beneficiário quando houver
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 07/08/2024
/*/
method loadRiskSharing() class CadBenefApiBeneficiaries

	local cOrigin := "compartilhamentoRisco" as character

	if self:lIsRiskSharing

		self:jBody["compartilhamentoRisco"] := JsonObject():new()

		self:setAttribute({"body": self:jBody["compartilhamentoRisco"], "attribute": "codigoUnimedDestino",;
						   "value": BA1->BA1_OPEDES, "type": "numeric", "required": REQUIRED, "origin": cOrigin,;
						   "errorDetailedMessage": STR0049})

		self:setAttribute({"body": self:jBody["compartilhamentoRisco"], "attribute": "tipoCompartilhamentoRisco",;
						   "value": iif(alltrim(BI3->BI3_MODPAG) == "1", "P", "C"), "type": "character", "required": REQUIRED, "origin": cOrigin,;
						   "errorDetailedMessage": STR0050}) // P = em Pré-Pagamento C = em Custo Operacional

		self:setAttribute({"body": self:jBody["compartilhamentoRisco"], "attribute": "dataInicioCompartilhamentoRisco",;
						   "value": BA1->BA1_DATREP, "type": "date3", "required": REQUIRED, "origin": cOrigin,;
						   "errorDetailedMessage": STR0042}) // Regra: Data a partir da qual deve ser tratado o compartilhamento de risco conforme RN561.

		self:setAttribute({"body": self:jBody["compartilhamentoRisco"], "attribute": "dataFimCompartilhamentoRisco",;
						   "value": iif(BA1->(fieldPos("BA1_FINREP")) > 0, BA1->BA1_FINREP, nil), "type": "date3", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": STR0118})

		self:setAttribute({"body": self:jBody["compartilhamentoRisco"], "attribute": "indicadorGeracaoLogomarca",;
						   "value": iif(BA1->BA1_LOCEMI == "1", .T., .F.), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
						   "errorDetailedMessage": STR0052}) // 1 = Unimed de Origem é a responsavel pela geração logomarca no cartão beneficiário

		self:setAttribute({"body": self:jBody["compartilhamentoRisco"], "attribute": "indicadorGeracaoCodigo",;
						   "value": iif(BA1->BA1_LOCEMI == "1", .T., .F.), "type": "logical", "required": REQUIRED, "origin": cOrigin,;
						   "errorDetailedMessage": STR0052}) // 1 = Unimed Origem é a responsavel pela geração do codgo no cartão beneficiário

		self:setAttribute({"body": self:jBody["compartilhamentoRisco"], "attribute": "indicadorSuspensaoAtendimento",;
						   "value": .F., "type": "logical", "required": REQUIRED, "origin": cOrigin,;
						   "errorDetailedMessage": ""}) 
	endif

return

/*/{Protheus.doc} loadComplementsRegistrations
Carrega os dados complementares cadastrais na requisição (body) a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
/*/
method loadComplementsRegistrations() class CadBenefApiBeneficiaries

	local lIsResidential as logical
	local cPhoneType as character
	local aEmails as array
	local nCount as numeric
	local nLenArray as numeric
	local cOrigin := "complementosCadastrais" as character

	self:jBody["dadosPessoa"]["complementosCadastrais"] := JsonObject():new()
	self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"] := {JsonObject():new()}

	self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1], "attribute": "tipoResidencia",;
					   "value": iif(BTS->BTS_RESEXT == "1" , "2", "1"), "type": "numeric", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0104})  // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	lIsResidential := self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1]:hasProperty("tipoResidencia") .and.;
				      self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1]["tipoResidencia"] == 1

	self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1], "attribute": "tipoEndereco",;
					   "value": iif(BTS->BTS_TIPEND == "1" , "2", "1"), "type": "numeric", "required": self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0105}) // Regra: Obrigatório quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1], "attribute": "tipoLogradouro",;
					   "value": getTypeAddress(self:jHolderData), "type": "character",;
					   "required": lIsResidential .and. self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0106}) // Regra: Obrigatório quando tipoResidencia = 1 e quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1], "attribute": "logradouro",;
					   "value": getAddress(self:jHolderData), "type": "character", "size": 80,;
					   "required": lIsResidential .and. self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0107}) // Regra: Obrigatório quando tipoResidencia = 1 e quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1], "attribute": "numeroLogradouro",;
					   "value": getHouseNumbering(self:jHolderData), "type": "character", "size": 6, "required": lIsResidential .and. self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0108}) // Regra: Obrigatório quando tipoResidencia = 1 e quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1], "attribute": "bairro", "size": 30,;
					   "value": getDistrict(self:jHolderData), "type": "character", "size": 45, "required": lIsResidential .and. self:lAllFalseIndicators, "origin": cOrigin,;
					   "errorDetailedMessage": STR0109}) // Regra: Obrigatório quando tipoResidencia = 1 e quando todos os indicadores estiver preenchido com valor 0 (False)

	self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1], "attribute": "complemento",;
					   "value": getAddressComplement(self:jHolderData), "type": "character", "size": 80, "required": OPTIONAL, "origin": cOrigin,;
					   "errorDetailedMessage": STR0110})

	self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1], "attribute": "codigoMunicipio",;
					   "value": getCityCode(self:jHolderData), "type": "numeric", "required": lIsResidential, "origin": cOrigin,;
					   "errorDetailedMessage": STR0111}) // Regra: obrigatório quando tipoResidencia = 1

	self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["enderecos"][1], "attribute": "cep",;
					   "value": getZipCode(self:jHolderData), "type": "character", "required": lIsResidential, "origin": cOrigin,;
					   "errorDetailedMessage": STR0112}) // Regra: obrigatório quando tipoResidencia = 1

	cPhoneType := getTypeTelephone(self:jHolderData)

	if !empty(cPhoneType)
		self:jBody["dadosPessoa"]["complementosCadastrais"]["telefones"] := {JsonObject():new()}

		self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["telefones"][1], "attribute": "tipoTelefone",;
						   "value": cPhoneType, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": STR0113})

		self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["telefones"][1], "attribute": "ddd",;
						   "value": getDDD(self:jHolderData), "type": "numeric", "required": cPhoneType $ "1-2-3", "origin": cOrigin,;
						   "errorDetailedMessage": STR0114}) // Regra: Obrigatório se tipoTelefone = 1, 2 ou 3

		self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["telefones"][1], "attribute": "numero",;
						   "value": getNumberTelephone(self:jHolderData), "type": "numeric", "size": 9, "required": cPhoneType $ "1-2-3", "origin": cOrigin,;
						   "specialChar": .T., "errorDetailedMessage": STR0115}) // Regra: Obrigatório se tipoTelefone = 1, 2 ou 3

		self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["telefones"][1], "attribute": "ramal",;
						   "value": nil, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
						   "errorDetailedMessage": ""}) // Não utilizado
	else
		if self:cOperation == UPDATE_TYPE
			self:jBody["dadosPessoa"]["complementosCadastrais"]["telefones"] := {JsonObject():new()}

			self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["telefones"][1], "attribute": "tipoTelefone",;
							   "value": nil, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
							   "errorDetailedMessage": STR0113})

			self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["telefones"][1], "attribute": "ddd",;
							   "value": nil, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
							   "errorDetailedMessage": STR0114})

			self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["telefones"][1], "attribute": "numero",;
							   "value": nil, "type": "numeric", "size": 9, "required": OPTIONAL, "origin": cOrigin,;
							   "errorDetailedMessage": STR0115})

			self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["telefones"][1], "attribute": "ramal",;
							   "value": nil, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
							   "errorDetailedMessage": ""})
		endif
	endif

	aEmails := getEmail(self:jHolderData)

	nLenArray := len(aEmails)

	if nLenArray > 0
		self:jBody["dadosPessoa"]["complementosCadastrais"]["emails"] := array(nLenArray)

		for nCount := 1 to nLenArray
			self:jBody["dadosPessoa"]["complementosCadastrais"]["emails"][nCount] := JsonObject():new()

			self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["emails"][nCount], "attribute": "tipoEmail",;
							   "value": aEmails[nCount]["tipoEmail"], "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
							   "errorDetailedMessage": STR0053})

			self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["emails"][nCount], "attribute": "email",;
							   "value": aEmails[nCount]["email"], "type": "character", "size": 70, "required": OPTIONAL, "origin": cOrigin,;
							   "errorDetailedMessage": STR0054})

		next nCount
	else
		if self:cOperation == UPDATE_TYPE
			self:jBody["dadosPessoa"]["complementosCadastrais"]["emails"] := {JsonObject():new()}

			self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["emails"][1], "attribute": "tipoEmail",;
							   "value": nil, "type": "numeric", "required": OPTIONAL, "origin": cOrigin,;
							   "errorDetailedMessage": STR0053})

			self:setAttribute({"body": self:jBody["dadosPessoa"]["complementosCadastrais"]["emails"][1], "attribute": "email",;
							   "value": nil, "type": "character", "size": 70, "required": OPTIONAL, "origin": cOrigin,;
							   "errorDetailedMessage": STR0054})
		endif
	endif

	fwFreeArray(aEmails)

return

/*/{Protheus.doc} loadQueryParamsDelete
Carrega os dados do query param do verbo delete a ser enviado para o cadBenef.
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@param cTransactionCode, character, código da transação gerada
/*/
method loadQueryParamsDelete(cTransactionCode as character) class CadBenefApiBeneficiaries

	self:setParams({"key": "codigoControleTransacao", "value": cTransactionCode, "type": "character", "required": REQUIRED})
	self:setParams({"key": "codigoUnimedOrigem", "value": self:self:cUnimedOrigin, "type": "character", "required": REQUIRED})
	self:setParams({"key": "codigoControleUnimedBrasil", "value": BA1->BA1_CODUBR, "type": "character", "required": REQUIRED})
	self:setParams({"key": "motivoExclusaoBeneficiario", "value": getReasonExclusion(), "type": "character", "required": REQUIRED})
	self:setParams({"key": "dataExclusaoBeneficiario", "value": BA1->BA1_DATBLO, "type": "date3", "required": REQUIRED})
	self:setParams({"key": "dataFimVigencia", "value": BA1->BA1_DATBLO, "type": "date3", "required": OPTIONAL})

return

/*/{Protheus.doc} loadApiConfig
Carrega as configurações necessárias para comunicar com o CadBenef
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param cHealthInsurerCode, character, código da operadora para buscar as configurações
@return logical, se as configurações foram carregadas com sucesso
/*/
method loadApiConfig(cHealthInsurerCode as character) as logical class CadBenefApiBeneficiaries

	local lOk := .T. as logical
	local cPFXFile as character
	local cCertificate as character
	local cPrivKey as character
	local cPassword as character
	local cError as character
	local cFileNamePFX as character
	local cCertificateDirectory := superGetMV("MV_PLCBCER", .F., "\cadbenef\certificados\") as character

	BA0->(dbSetOrder(1))
	if BA0->(dbSeek(xFilial("BA0") + cHealthInsurerCode))
		self:setEndpoint(alltrim(BA0->BA0_CDBURL))
		cFileNamePFX := alltrim(BA0->BA0_CDBPFX)
		cPassword := alltrim(BA0->BA0_CDBPAS)

		if !empty(cFileNamePFX)
			cPFXFile := PLSMudSis(cCertificateDirectory + cFileNamePFX)
			cCertificate := PLSMudSis(cCertificateDirectory + "certificate.pem")
			cPrivKey := PLSMudSis(cCertificateDirectory + "privKey.pem")

			if file(cPFXFile)
				do case
					case !file(cCertificate) .and. !PFXCert2PEM(cPFXFile, cCertificate, @cError, cPassword)
						lOk := .F.
						self:setError("401",;
									  STR0003,; // "Falha ao extrair o certificado de cliente para geração do arquivo no formato .PEM (Privacy Enhanced Mail)."
									  cError)

					case !file(cPrivKey) .and. !PFXKey2PEM(cPFXFile, cPrivKey, @cError, cPassword)
						lOk := .F.
						self:setError("401",;
									  STR0004,; // "Falha ao extrair a chave privada para geração do arquivo no formato .PEM (Privacy Enhanced Mail)."
									  cError)
					otherwise
						lOk := .T.
						self:setDigitalCertificate(cCertificate, cPrivKey, cPassword)
				endcase
			else
				lOk := .F.
				self:setError("401",;
							  STR0005,; // "Certificado digital (PFX) não encontrado no diretório (RootPath) do servidor."
							  cError)
			endif
		endif
	endif

return lOk

/*/{Protheus.doc} setResponse
Defini os dados de resposta da comunicação com o CadBenef.
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@return logical, se a resposta foi processada com sucesso
/*/
method setResponse() as logical class CadBenefApiBeneficiaries

	local xRet as variant
	local lSuccess := .F. as logical
	local aAreaBA1 := BA1->(getArea()) as array

	xRet := self:jResponse:fromJson(self:getBody())

	if xRet == nil
		if self:cOperation == INCLUSION_TYPE
			if self:jResponse:hasProperty("dadosBeneficiario") .and. self:jResponse["dadosBeneficiario"]:hasProperty("carteirinhaBeneficiario")
				BA1->(dbSetOrder(2))
				if BA1->(msSeek(xFilial("BA1") + self:jResponse["dadosBeneficiario"]["carteirinhaBeneficiario"]))
					if self:jResponse["dadosBeneficiario"]:hasProperty("codigoControleUnimedBrasil")

						BA1->(recLock("BA1", .F.))
						BA1->BA1_CODUBR := getUBControlCode(self:getBody())
						BA1->(msUnLock())

						lSuccess := .T.
					endif
				endif
			endif
		else
			lSuccess := .T.
		endif
	endif

	restArea(aAreaBA1)

return lSuccess

/*/{Protheus.doc} setError
Defini os dados de erro no json de resposta
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param cCode, character, código do erro (status code)
@param cMessage, character, mensagem do erro
@param cDetailedMessage, character, detalhes do erro
@param aDetails, character, lista de objetos de erro com mais detalhes sobre o erro principal
@return json, objeto json de resposta
/*/
method setError(cCode as character, cMessage as character, cDetailedMessage as character, aDetails as array) as json class CadBenefApiBeneficiaries

	local nCount as numeric

	default aDetails := {}

	self:jResponse["code"] := cCode
	self:jResponse["message"] := cMessage
	self:jResponse["detailedMessage"] := cDetailedMessage

	if len(aDetails) > 0
		if self:jResponse:hasProperty("details")
			for nCount := 1 to len(aDetails)
				aAdd(self:jResponse["details"], aDetails[nCount])
			next nCount
		else
			self:jResponse["details"] = aClone(aDetails)
		endif
	endif

	self:lIsError := .T.
	self:cMessage := cMessage

return self:jResponse

/*/{Protheus.doc} setParams
Defini os parâmetros (query param) para ser utilizado na comunicação com o CadBenef
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@param jData, json, dados do parâmetro a ser adicionado na lista do query param
/*/
method setParams(jData as json) class CadBenefApiBeneficiaries

	local aDetails := {} as array

	if !empty(jData["value"])
		do case
			case jData["type"] == "character"
				if valType(jData["value"]) == "C"
					jData["value"] := alltrim(jData["value"])
				endif

			case jData["type"] == "date3" // Formato YYYY-MM-DD
				if valType(jData["value"]) == "D"
					jData["value"] := transform(dtos(jData["value"]), "@R 9999-99-99")
				endif
		endcase

		aAdd(self:aParams, {"key": jData["key"], "value": jData["value"]})
	else
		if jData["required"]
			aAdd(aDetails, {"code": "400.001", "message": STR0006 + jData["key"] + STR0007, "detailedMessage": iif(jData:hasProperty("errorDetailedMessage"), jData["errorDetailedMessage"], "")}) // "O campo ";" é obrigatório."

			self:setError("400.001",;
						  STR0008,; // "Existem campos obrigatórios do beneficiário que não foram preenchidos."
						  STR0009,; // "Verifique a lista de erros para mais detalhes."
						  aDetails)
		endif
	endif

return

/*/{Protheus.doc} setAttribute
Defini os campos a ser adicionado no body para comunicar com o CadBenef.
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param jData, json, dados do campo a ser adicionado body da requisição
/*/
method setAttribute(jData as json) class CadBenefApiBeneficiaries

	local lEmpty as logical
	local aDetails := {} as array

	if self:lPEPTU001JSN
		jData := execBlock("PTU001JSN", .F., .F., {jData, self:lIsTotalCoverage})
	endif

	lEmpty := ((valtype(jData["value"]) <> "L" .and. empty(jData["value"])) .or. (jData["type"] == "logical" .and. valtype(jData["value"]) <> "L" ))

	if !empty(jData["value"])

		if jData:hasProperty("specialChar") .and. jData["specialChar"]
			if valType(jData["value"]) == "C"
				jData["value"] := self:removeSpecialChar(jData["value"])
			endif
		endif

		do case
			case jData["type"] == "numeric"
				if valType(jData["value"]) == "C"
					jData["value"] := val(jData["value"])
				endif

			case jData["type"] == "character"
				if valType(jData["value"]) == "C"
					if jData:hasProperty("size")
						jData["value"] := padr(jData["value"], jData["size"])
					endif

					jData["value"] := alltrim(jData["value"])
				endif

			case jData["type"] == "date3" // Formato YYYY-MM-DD
				if valType(jData["value"]) == "D"
					jData["value"] := transform(dtos(jData["value"]), "@R 9999-99-99")
				endif

			case jData["type"] == "date5" // Formato YYYY-MM-DDTHH:MI:SS-00:00 (padrão ISO-8601)
				if valType(jData["value"]) == "D"
					jData["value"] := fwTimeStamp(5, jData["value"])
				endif

			case jData["type"] == "uf" // Unidade Federativa - Formato XX, onde XX pertence ao domínio {RS,SC,PR,SP,MG,RJ,ES,MS,MT,GO,TO,PA,AM,RO,RR,AC,DF,BA,SE,CE,PI,PB,RN,AL,MA,PE,AP}
				jData["value"] := getCodeUF(jData["value"])
		endcase
	endif

	// Mandatório (Obrigatório envio da informação)
	if jData["required"] .and. lEmpty
		aAdd(aDetails, {"code": "400.001", "message": STR0006 + jData["attribute"] + STR0007, "detailedMessage": iif(jData:hasProperty("errorDetailedMessage"), jData["errorDetailedMessage"], "")}) // "O campo ";" é obrigatório." 

		self:setError("400.001",;
					  STR0008,; // "Existem campos obrigatórios do beneficiário que não foram preenchidos."
					  STR0009,; // "Verifique a lista de erros para mais detalhes."
				      aDetails)
	else
		if !lEmpty
			jData["body"][jData["attribute"]] := jData["value"]
		else
			if self:cOperation == UPDATE_TYPE .and. !jData["required"]
				jData["body"][jData["attribute"]] := nil
			endif
		endif
	endif

	fwFreeArray(aDetails)

return

/*/{Protheus.doc} getStatusCodeMessage
Obter a mensagem de acordo com o status code
@type method
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@return character, mensagem do status code
/*/
method getStatusCodeMessage(cStatusCode as character, cOperation as character) as character class CadBenefApiBeneficiaries

	local cMessage := "" as character
	local jStatusCodeMessage := JsonObject():new() as json

	jStatusCodeMessage["200"] := iif(cOperation == UPDATE_TYPE, STR0010, STR0011 ) // "Beneficiário atualizado com sucesso.";"Beneficiário removido com sucesso."
	jStatusCodeMessage["201"] := STR0012 // "Beneficiário cadastrado com sucesso."
	jStatusCodeMessage["400"] := STR0013 // "A requisição foi malformada, omitindo atributos necessários, seja no payload ou através de atributos no header, ou na URL."
	jStatusCodeMessage["401"] := STR0014 // "Cabeçalho de autenticação ausente/inválido ou token inválido."
	jStatusCodeMessage["403"] := STR0015 // "Acesso negado para este ambiente do cadBenef."
	jStatusCodeMessage["405"] := STR0016 // "O consumidor tentou acessar o recurso com um método que não existe."
	jStatusCodeMessage["422"] := STR0017 // "Erro de negócio."
	jStatusCodeMessage["429"] := STR0018 // "A operação foi recusada, por exceder o limite de chamadas feitas dentro de um determinado período ou o limite de requisições concorrentes foi atingido."
	jStatusCodeMessage["500"] := STR0019 // "Erro do servidor, ocorreu um erro no gateway da API ou no microsserviço."
	jStatusCodeMessage["504"] := STR0020 // "A requisição não foi atendida dentro do tempo limite estabelecido, gateway time out."

	if jStatusCodeMessage:hasProperty(cStatusCode)
		cMessage := jStatusCodeMessage[cStatusCode]
	endif

return cMessage

/*/{Protheus.doc} method isContractProtocol
Retorna se o beneficiário possui o Número do Protocolo gerado pelo VCOM no recebimento da mensagem contrato
@type function
@version 12.1.2510 
@author giovanna.charlo
@since 07/02/2025
@return logical, beneficiario tem número de protocolo
/*/
method isContractProtocol() as logical class CadBenefApiBeneficiaries

    local lIsProtocol := .F. as logical

return lIsProtocol

/*/{Protheus.doc} getDependencyCode
Obter o código PTU do grau de parentesco
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@return character, código de dependencia do beneficiário
/*/
static function getDependencyCode() as character

	local cCode := "" as character

	BRP->(dbSetOrder(1))
	if BRP->(dbSeek(xFilial("BRP") + BA1->BA1_GRAUPA))
		cCode := BRP->BRP_CODPTU
	endif

return cCode

/*/{Protheus.doc} getHolderData
Obter os dados do titular de acordo com o beneficiário posicionado (BA1)
@type function
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@return json, dados do titular
/*/
static function getHolderData() as json

	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character
	local aAreaBA1 := BA1->(getArea()) as array
	local lHolderFound := .F. as logical
	local jHolderData := JsonObject():new()

	if BA1->BA1_TIPUSU == cHolderType
		lHolderFound := .T.
	else
		BA1->(dbSetOrder(1))
		if BA1->(dbSeek(xFilial("BA1") + BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC) + cHolderType))
			lHolderFound := .T.
		endif
	endif

	if lHolderFound
		jHolderData["subscriberId"] := BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)
		jHolderData["address"] := alltrim(BA1->BA1_ENDERE)
		jHolderData["houseNumbering"] := alltrim(BA1->BA1_NR_END)
		jHolderData["addressComplement"] := alltrim(BA1->BA1_COMEND)
		jHolderData["district"] := alltrim(BA1->BA1_BAIRRO)
		jHolderData["cityCode"] := alltrim(BA1->BA1_CODMUN)
		jHolderData["cityCodeResidence"] := alltrim(BA1->BA1_MUNICI)
		jHolderData["stateAbbreviation"] := alltrim(BA1->BA1_ESTADO)
		jHolderData["ZIPCode"] := alltrim(BA1->BA1_CEPUSR)
		jHolderData["ddd"] := alltrim(BA1->BA1_DDD)
		jHolderData["telephone"] := alltrim(BA1->BA1_TELEFO)
		jHolderData["phoneType"] := alltrim(BA1->BA1_TIPTEL)
		jHolderData["email"] := alltrim(BA1->BA1_EMAIL)
		jHolderData["alternativeEmail"] := iif(BA1->(fieldPos("BA1_AEMAIL")) > 0, allTrim(BA1->BA1_AEMAIL), "")
	endif

	restArea(aAreaBA1)
	fwFreeArray(aAreaBA1)

return jHolderData

/*/{Protheus.doc} isRedeemed
Verifica se o beneficiário é indicado remido
@type function
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@return logical, se o beneficiário é indicado remido
/*/
static function isRedeemed() as logical

	local lIsRedeemed as logical
	local cRedeemedCompany := superGetMV("MV_PLSCPEA", .F., "") as character
	local lUseRedeemed := superGetMV("MV_PLUSARD", .F., .F.) as logical

	if lUseRedeemed
		lIsRedeemed := iif(BA1->BA1_REMIDO == "1", .T., .F.)
	else
		lIsRedeemed := iif(BA1->BA1_CODEMP == cRedeemedCompany, .T., .F.)
	endif

return lIsRedeemed

/*/{Protheus.doc} getReasonExclusion
Obter o motivo (CodEdi) do bloqueio do beneficiário
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@return character, motivo de bloqueio do beneficiário
/*/
static function getReasonExclusion() as character

	local cReason := "" as character

	if !empty(BA1->BA1_MOTBLO)
		do case
			case BA1->BA1_CONSID == "U"
				BG3->(dbSetOrder(1))
				if BG3->(dbSeek(xFilial("BG3") + BA1->BA1_MOTBLO))
					cReason := BG3->BG3_CODEDI
				endif

			case BA1->BA1_CONSID == "F"
				BG1->(dbSetOrder(1))
				if BG1->(dbSeek(xFilial("BG1") + BA1->BA1_MOTBLO))
					cReason := BG1->BG1_CODEDI
				endif

			case BA1->BA1_CONSID == "S"
				BQU->(dbSetOrder(1))
				if BQU->(dbSeek(xFilial("BQU") + BA1->BA1_MOTBLO))
					cReason := BQU->BQU_CODEDI
				endif
		endcase
	endif

return cReason

/*/{Protheus.doc} isSelfManagement
Verifica se o subcontrato ou operadora do beneficiário é de auto gestão
@type function
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param lIsSubcontract, logical, beneficiário tem subcontrato (pessoa juridica)
@return logical, se o subcontrato ou operadora é de auto gestão
/*/
static function isSelfManagement(lIsSubcontract) as logical

	local lIsSelfManag := .F. as logical

	if lIsSubcontract .and. BQC->BQC_AUTGES == "1"
		lIsSelfManag := .T.
	else
		if BA0->BA0_AUTGES == "1"
			lIsSelfManag := .T.
		endif
	endif

return lIsSelfManag

/*/{Protheus.doc} getCompanyType
Obter os dados de cnpj ou caepf da empresa contratante do beneficiário
@type function
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@return json, dados do tipo da empresa contratante
/*/
static function getCompanyType() as json

	local cCnpj := "" as character
	local cCaepf := "" as character
	local jCompanyType as json

	do case
		case !empty(BQC->BQC_CNPJ)
			cCnpj := strZero(val(BQC->BQC_CNPJ), 14)

		case !empty(BQC->BQC_CAEPF)
			cCaepf := strZero(val(BQC->BQC_CAEPF), 14)

		case !empty(BQC->BQC_CEINSS)
			cCaepf := strZero(val(BQC->BQC_CEINSS), 14)
	endcase

	if empty(BQC->BQC_CNPJ) .and. empty(BQC->BQC_CAEPF) .And. empty(BQC->BQC_CEINSS)
		SA1->(dbSetOrder(1))
		if SA1->(dbSeek(xFilial("SA1") + BQC->(BQC_CODCLI + BQC_LOJA)))
			do case
				case !empty(SA1->A1_CGC)
					cCnpj := strZero(val(SA1->A1_CGC), 14)

				case !empty(SA1->A1_CEINSS)
					cCaepf := strZero(val(SA1->A1_CEINSS), 14)
			endcase
		endif
	endif

	jCompanyType := {"cnpj": cCnpj, "caepf": cCaepf}

return jCompanyType

/*/{Protheus.doc} getPlanTypeANS
Obter o tipo de plano ANS do produto saúde
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@return character, tipo do plano ANS
/*/
function getPlanTypeANS() as character

	local cPlanTypeANS := "" as character

	do case
		case BI3->BI3_APOSRG == "0"
			cPlanTypeANS := "1" // Plano Não Regulamentado

		case BI3->BI3_APOSRG == "1"
			cPlanTypeANS := "3" // Plano Regulamentado

		case BI3->BI3_APOSRG == "2"
			cPlanTypeANS := "2" // Plano Adaptado
	endcase

return cPlanTypeANS

/*/{Protheus.doc} getTypeAccommodation
Obter o tipo de acomodação do produto saúde
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@return character, tipo de acomodação
/*/
static function getTypeAccommodation() as character

	local cType := "" as character

	BI4->(dbSetOrder(1))
	if BI4->(dbSeek(xFilial("BI4") + BI3->BI3_CODACO))
		cType := BI4->BI4_CODEDI

		do case
			case BI4->BI4_CODEDI == "1"
				cType := "B" // B = Individual

			case BI4->BI4_CODEDI == "2"
				cType := "A" // A = Coletiva

			case BI4->BI4_CODEDI == "3" .or. BI4->BI4_CODEDI == "4"
				cType := "C" // C= Não se Aplica
		endcase
	endif

return cType

/*/{Protheus.doc} getMaritalStatus
Obter o código do estado cívil do beneficiário/vidas
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@return character, código do estado cívil
/*/
static function getMaritalStatus() as character

	local cStatus := "" as character
	local cListMartialStatus := "C-D-M-Q-S-V" as character

	do Case
		case BA1->BA1_ESTCIV == "C" .or. (!(BA1->BA1_ESTCIV $ cListMartialStatus) .and. BTS->BTS_ESTCIV == "C") // Casado(a)
			cStatus := "M"
		case BA1->BA1_ESTCIV == "D" .or. (!(BA1->BA1_ESTCIV $ cListMartialStatus) .and. BTS->BTS_ESTCIV == "D") // Divorciado(a)
			cStatus := "D"
		case BA1->BA1_ESTCIV == "M" .or. (!(BA1->BA1_ESTCIV $ cListMartialStatus) .and. BTS->BTS_ESTCIV == "M") // Marital
			cStatus := "U"
		case BA1->BA1_ESTCIV == "Q" .or. (!(BA1->BA1_ESTCIV $ cListMartialStatus) .and. BTS->BTS_ESTCIV == "Q") // Desquitado(a)
			cStatus := "A"
		case BA1->BA1_ESTCIV == "S" .or. (!(BA1->BA1_ESTCIV $ cListMartialStatus) .and. BTS->BTS_ESTCIV == "S") // Solteiro(a)
			cStatus := "S"
		case BA1->BA1_ESTCIV == "V" .or. (!(BA1->BA1_ESTCIV $ cListMartialStatus) .and. BTS->BTS_ESTCIV == "V") // Viuvo(a)
			cStatus := "W"
	endcase

return cStatus

/*/{Protheus.doc} getCityCode
Obter código do municipio do beneficiário ou do titular quando não houver.
@type function
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, codigo do municipio
/*/
static function getCityCode(jHolderData as json) as character

	local cCode := "" as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character

	cCode := strzero(val(BA1->BA1_CODMUN), 7)

	if empty(BA1->BA1_CODMUN) .and. BA1->BA1_TIPUSU <> cHolderType
		if !empty(BTS->BTS_CODMUN)
			cCode := strzero(val(BTS->BTS_CODMUN), 7)
		else
			if jHolderData:hasProperty("cityCode")
				cCode := strzero(val(jHolderData["cityCode"]), 7)
			endif
		endif
	endif

return cCode

/*/{Protheus.doc} getTypeAddress
Obter o tipo de endereço do beneficiário ou do titular quando o mesmo não tiver
@type function
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, tipo do endereço
/*/
static function getTypeAddress(jHolderData as json) as character

	local cType as character
	local cZipCode as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character

	do case
		case !empty(BA1->BA1_CEPUSR)
			cZipCode := BA1->BA1_CEPUSR

		case !empty(BTS->BTS_CEPUSR)
			cZipCode := BTS->BTS_CEPUSR

		case BA1->BA1_TIPUSU <> cHolderType .and. jHolderData:hasProperty("ZIPCode")
			cZipCode := jHolderData["ZIPCode"]
	endcase

	BC9->(dbSetOrder(1))
	if !empty(cZipCode) .and. BC9->(dbSeek(xFilial("BC9") + cZipCode))

		B18->(dbSetOrder(1))
		If !empty(BC9->BC9_TIPLOG) .and. B18->(dbSeek(xFilial("B18") + BC9->BC9_TIPLOG))
			cType := B18->B18_CODEDI
		endif
	endif

	if empty(cType)
		cType := superGetMV("MV_TLOGPTU", .F., "")
	endif

return cType

/*/{Protheus.doc} getAddress
Obter o endereço do beneficiário ou do titular quando não não houver.
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, endereço
/*/
static function getAddress(jHolderData as json) as character

	local cAddress as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character

	cAddress := BA1->BA1_ENDERE

	if empty(cAddress) .and. BA1->BA1_TIPUSU <> cHolderType
		if !empty(BTS->BTS_ENDERE)
			cAddress := BTS->BTS_ENDERE
		else
			if jHolderData:hasProperty("address")
				cAddress := jHolderData["address"]
			endif	
		endif
	endif

return cAddress

/*/{Protheus.doc} getHouseNumbering
Obter o número do endereço do beneficiário ou do titular quando não houver.
@type function
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, número do endereço
/*/
static function getHouseNumbering(jHolderData as json) as character

	local cNumber as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character

	cNumber := BA1->BA1_NR_END

	if empty(cNumber) .and. BA1->BA1_TIPUSU <> cHolderType
		if !empty(BTS->BTS_NR_END)
			cNumber := BTS->BTS_NR_END
		else
			if jHolderData:hasProperty("houseNumbering")
				cNumber := jHolderData["houseNumbering"]
			endif
		endif
	endif

	if empty(cNumber)
		cNumber := "S/N"
	endif

return cNumber

/*/{Protheus.doc} getDistrict
Obter o bairro do beneficiário ou do titular quando não houver
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, bairro
/*/
static function getDistrict(jHolderData as json) as character

	local cDistrict as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character

	cDistrict := BA1->BA1_BAIRRO

	if empty(cDistrict) .and. BA1->BA1_TIPUSU <> cHolderType
		if !empty(BTS->BTS_BAIRRO)
			cDistrict := BTS->BTS_BAIRRO
		else
			if jHolderData:hasProperty("district")
				cDistrict := jHolderData["district"]
			endif
		endif
	endif

return cDistrict

/*/{Protheus.doc} getAddressComplement
Obter o complemento do endereço do beneficiário ou do titular quando não houver
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, complemento do endereço
/*/
static function getAddressComplement(jHolderData as json) as character

	local cComplement as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character

	cComplement := BA1->BA1_COMEND

	if empty(cComplement) .and. BA1->BA1_TIPUSU <> cHolderType
		if !empty(BTS->BTS_COMEND)
			cComplement := BTS->BTS_COMEND
		else
			if jHolderData:hasProperty("addressComplement")
				cComplement := jHolderData["addressComplement"]
			endif
		endif
	endif

return cComplement

/*/{Protheus.doc} getZipCode
Obter o CEP do beneficiário ou do titular quando não houver.
@type function
@version 12.1.2410
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, CEP
/*/
static function getZipCode(jHolderData as json) as character

	local cZipCode as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character

	cZipCode := strZero(val(BA1->BA1_CEPUSR), 8)

	if empty(BA1->BA1_CEPUSR) .and. BA1->BA1_TIPUSU <> cHolderType
		if !empty(BTS->BTS_CEPUSR)
			cZipCode := strZero(val(BTS->BTS_CEPUSR), 8)
		else
			if jHolderData:hasProperty("ZIPCode")
				cZipCode := strZero(val(jHolderData["ZIPCode"]), 8)
			endif
		endif
	endif

return cZipCode

/*/{Protheus.doc} getTypeTelephone
Obter o tipo de telefone do beneficiário ou do titular quando não houver.
@type function
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, tipo de telefone
/*/
static function getTypeTelephone(jHolderData as json) as character

	local cType as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character

	cType := BA1->BA1_TIPTEL

	if empty(BA1->BA1_TELEFO) .and. BA1->BA1_TIPUSU <> cHolderType
		if !Empty(BTS->BTS_TELEFO)
			cType := BTS->BTS_TIPTEL
		else
			if jHolderData:hasProperty("phoneType")
				cType := jHolderData["phoneType"]
			endif
		endif
	endif

return cType

/*/{Protheus.doc} getDDD
Obter o DDD do telefone do beneficiário ou do titular quando não houver.
@type function
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, DDD do telefone
/*/
static function getDDD(jHolderData as json) as character

	local cDDD as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character

	if empty(BA1->BA1_DDD) .and. BA1->BA1_TIPUSU <> cHolderType
		do case
			case !empty(BTS->BTS_DDD)
				cDDD := strZero(val(BTS->BTS_DDD), 4)

			case jHolderData:hasProperty("ddd") .and. !empty(jHolderData["ddd"])
				cDDD := strZero(val(jHolderData["ddd"]), 4)
		endcase
	else
		if !empty(BA1->BA1_DDD)
			cDDD := strZero(val(BA1->BA1_DDD), 4)
		endif
	endif

return cDDD

/*/{Protheus.doc} getNumberTelephone
Obter o número do telefone do beneficiário ou do titular quando não houver.
@type function
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, número do telefone
/*/
static function getNumberTelephone(jHolderData as json) as character

	local cNumber as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character

	cNumber := BA1->BA1_TELEFO

	if empty(BA1->BA1_TELEFO) .and. BA1->BA1_TIPUSU <> cHolderType
		if !Empty(BTS->BTS_TELEFO)
			cNumber := BTS->BTS_TELEFO
		else
			if jHolderData:hasProperty("telephone")
				cNumber := jHolderData["telephone"]
			endif
		endif
	endif

return cNumber

/*/{Protheus.doc} getEmail
Obter o e-mail do beneficiário ou do titular quando não houver
@type function
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
@param jHolderData, json, dados do titular
@return character, email
/*/
static function getEmail(jHolderData as json) as array

	local cEmail := "" as character
	local cAlternativeEmail := "" as character
	local cHolderType := superGetMV("MV_PLCDTIT", .F., "T") as character
	local aEmails := {} as array

	cEmail := iif(!empty(BA1->BA1_EMAIL), BA1->BA1_EMAIL, BTS->BTS_EMAIL)
	cAlternativeEmail := iif(BA1->(fieldPos("BA1_AEMAIL")) > 0, BA1->BA1_AEMAIL, "")

	if BA1->BA1_TIPUSU <> cHolderType
		if empty(cEmail) .and. jHolderData:hasProperty("email")
			cEmail := jHolderData["email"]
		endif

		if empty(cAlternativeEmail) .and. jHolderData:hasProperty("alternativeEmail")
			cAlternativeEmail := jHolderData["alternativeEmail"]
		endif
	endif

	if !empty(cEmail)
		aAdd(aEmails, {"tipoEmail": "1", "email": cEmail}) // 1 = Principal
	endif

	if !empty(cAlternativeEmail)
		aAdd(aEmails, {"tipoEmail": "2", "email": cAlternativeEmail}) // 2 = Alternativo
	endif

return aEmails

/*/{Protheus.doc} getCodeUF
Obter o código do estado de acordo com o UF
@type function
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
@param cUF, character, sigla do estado (UF)
@return character, código do estado
/*/
function getCodeUF(cUF as character) as character

	local jCodes := JsonObject():new() as json
	local cCodeUF := "" as character

	jCodes["RO"] := "11"
	jCodes["AC"] := "12"
	jCodes["AM"] := "13"
	jCodes["RR"] := "14"
	jCodes["PA"] := "15"
	jCodes["AP"] := "16"
	jCodes["TO"] := "17"
	jCodes["MA"] := "21"
	jCodes["PI"] := "22"
	jCodes["CE"] := "23"
	jCodes["RN"] := "24"
	jCodes["PB"] := "25"
	jCodes["PE"] := "26"
	jCodes["AL"] := "27"
	jCodes["SE"] := "28"
	jCodes["BA"] := "29"
	jCodes["MG"] := "31"
	jCodes["ES"] := "32"
	jCodes["RJ"] := "33"
	jCodes["SP"] := "35"
	jCodes["PR"] := "41"
	jCodes["SC"] := "42"
	jCodes["RS"] := "43"
	jCodes["MS"] := "50"
	jCodes["MT"] := "51"
	jCodes["GO"] := "52"
	jCodes["DF"] := "53"
	jCodes["EX"] := "98"

	if jCodes:hasProperty(cUF)
		cCodeUF := jCodes[cUF]
	endif

return cCodeUF

/*/{Protheus.doc} isExclusionRN561
Verifica se o beneficiário foi bloqueado pela RN 561
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@return logical, se o beneficiário foi bloqueado pela RN 561
/*/
static function isExclusionRN561() as logical

	local lIsRN561 := .F. as logical
	local cQuery as character
	local nOrder := 1 as numeric
	local oExecStmt as object

	cQuery := " SELECT COUNT(?) TOTAL "
	cQuery += " FROM ? BCA "
	cQuery += " WHERE "
	cQuery += "     BCA.BCA_FILIAL = ? AND "
	cQuery += "     BCA.BCA_MATRIC = ? AND "
	cQuery += "     BCA.BCA_TIPREG = ? AND "
	cQuery += "     BCA.BCA_TIPO = ? AND "
	cQuery += "     BCA.BCA_DATA = ? AND "
	cQuery += "     BCA.BCA_SOL412 = ? AND "
	cQuery += "     BCA.D_E_L_E_T_ = ? "

	oExecStmt := FwExecStatement():new(cQuery)

	oExecStmt:setUnsafe(nOrder++, "BCA_MATRIC")
	oExecStmt:setUnsafe(nOrder++, retSqlName("BCA"))
	oExecStmt:setString(nOrder++, xFilial("BCA"))
	oExecStmt:setString(nOrder++, BA1->BA1_CODINT + BA1->BA1_CODEMP + BA1->BA1_MATRIC)
	oExecStmt:setString(nOrder++, BA1->BA1_TIPREG)
	oExecStmt:setString(nOrder++, "0") // Bloqueio
	oExecStmt:setDate(nOrder++, BA1->BA1_DATBLO)
	oExecStmt:setString(nOrder++, "1") // 1 = sim (RN412 foi substituida pela RN561)
	oExecStmt:setString(nOrder++, " ")

	if oExecStmt:execScalar("TOTAL") > 0
		lIsRN561 := .T.
	endif

	freeObj(oExecStmt)

return lIsRN561

/*/{Protheus.doc} allFalseIndicators
Verifica se todos os indicadores informados no parametro estão falsos
@type function
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
@param lIsSubcontract, logical, se o beneficiário possui subcontrato (pessoa juridica)
@param jIndicatorsToCheck, json, indicadores a serem verificados
@return logical, se todos os indicadores estão falsos
/*/
static function allFalseIndicators(lIsSubcontract as logical, jIndicatorsToCheck as json) as logical

	local lAllFalse as logical
	local lSelfManagement := .F. as logical
	local lLowCostPlan := .F. as logical
	local lWorkAccidentPlan := .F. as logical
	local lOccupationalHealthPlan := .F. as logical
	local lAPSPlan := .F. as logical
	local lHasIndicPlan := BI3->(fieldPos("BI3_INDPLA")) > 0 as logical

	// Indicador Auto Gestao
	if jIndicatorsToCheck:hasProperty("selfManagement") .and. jIndicatorsToCheck["selfManagement"]
		lSelfManagement := isSelfManagement(lIsSubcontract)
	endif

	// Indicador Plano Low Cost
	if jIndicatorsToCheck:hasProperty("lowCostPlan") .and. jIndicatorsToCheck["lowCostPlan"]
		lLowCostPlan := iif(lHasIndicPlan, iif(BI3->BI3_INDPLA == "1", .T., .F. ), .F.)
	endif

	// Indicador Plano Acidente Trabalho
	if jIndicatorsToCheck:hasProperty("workAccidentPlan") .and. jIndicatorsToCheck["workAccidentPlan"]
		lWorkAccidentPlan := iif(lHasIndicPlan, iif(BI3->BI3_INDPLA == "2", .T., .F. ), .F.)
	endif

	// Indicador Plano Saude Ocupacional
	if jIndicatorsToCheck:hasProperty("occupationalHealthPlan") .and. jIndicatorsToCheck["occupationalHealthPlan"]
		lOccupationalHealthPlan := iif(lHasIndicPlan, iif(BI3->BI3_INDPLA == "3", .T., .F. ), .F.)
	endif

	// Indicador Plano APS
	if jIndicatorsToCheck:hasProperty("APSPlan") .and. jIndicatorsToCheck["APSPlan"]
		lAPSPlan := iif(lHasIndicPlan, iif(BI3->BI3_INDPLA == "4", .T., .F. ), .F.)
	endif

	// Regra: Obrigatório quando todos os indicadores abaixo estiver preenchido com valor 0 (False):
	lAllFalse := !lSelfManagement .and. !lLowCostPlan .and. !lWorkAccidentPlan .and. !lOccupationalHealthPlan .and. !lAPSPlan

return lAllFalse

/*/{Protheus.doc} getLastDateCPT
Obter a ultima data de cobertura parcial temporaria do beneficiário
@type function
@version 12.1.2410  
@author vinicius.queiros
@since 21/05/2024
@return date, ultima data da cobertura 
/*/
function getLastDateCPT() as date

	local cFilialBF3 := xFilial("BF3") as character
	local dDateCPT := ctod(" / / ") as date
	local dLastDate := ctod(" / / ") as date
	local nDays as numeric

	BF3->(dbSetOrder(1))
	if BF3->(dbSeek(cFilialBF3 + BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG)))
		while !BF3->(eof()) .and. BF3->(BF3_FILIAL + BF3_CODINT + BF3_CODEMP + BF3_MATRIC + BF3_TIPREG) == ;
								  cFilialBF3 + BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG)

			if BF3->BF3_UNAGR == "3" // Meses
				if empty(BF3->BF3_DATCPT)
					if empty(BA1->BA1_DATCPT)
						nDays := abs(date() - monthSum(date(), 0))
						dDateCPT := date() + nDays
					else
						nDays := abs(BA1->BA1_DATCPT - monthSum(BA1->BA1_DATCPT, BF3->BF3_MESAGR))
						dDateCPT:= BA1->BA1_DATCPT + nDays
					endif
				else
					nDays := abs(BF3->BF3_DATCPT - monthSum(BF3->BF3_DATCPT, BF3->BF3_MESAGR))
					dDateCPT := BF3->BF3_DATCPT + nDays
				endif
			else
				if empty(BF3->BF3_DATCPT)
					if empty(BA1->BA1_DATCPT)
						nDays := abs(date() - monthSum(date(), 0))
						dDateCPT := date() + nDays
					else
						nDays := PLSCarDias(BF3->BF3_MESAGR, BF3->BF3_UNAGR)
						dLastDate := BA1->BA1_DATCPT + nDays
					endif
				else
					nDays := PLSCarDias(BF3->BF3_MESAGR, BF3->BF3_UNAGR)
					dLastDate := BF3->BF3_DATCPT + nDays
				endif

				if dLastDate > dDateCPT
					dDateCPT := dLastDate
				endif
			endif

			BF3->(dbSkip())
		enddo
	endif

return dDateCPT

/*/{Protheus.doc} getAggregateProductType
Obter o tipo do produto do agregado
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@param cCode, character, código do produto agregado
@param cVersion, character, versão do produto
@return character, tipo do produto
/*/
static function getAggregateProductType(cCode as character, cVersion as character) as character

	local cProductType as character
	local aAreaBI3 := BI3->(getArea())

	if BI3->(dbSeek(xFilial("BI3") + cCode + cVersion))
		cProductType := BI3->BI3_TIPRED
	endif

	restArea(aAreaBI3)

return cProductType

/*/{Protheus.doc} getGracePeriodEndDate
Obter a data final de carência da preexistencia posicionada do beneficiário
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 21/05/2024
@return date, data final de carência
/*/
static function getGracePeriodEndDate() as date

	local dDateCPT := ctod(" / / ") as date
	local dLastDate := ctod(" / / ") as date
	local nDays as numeric

	if BF3->BF3_UNAGR == "3" // Meses
		if empty(BF3->BF3_DATCPT)
			if empty(BA1->BA1_DATCPT)
				nDays := abs(date() - monthSum(date(), 0))
				dDateCPT := date() + nDays
			else
				nDays := abs(BA1->BA1_DATCPT - monthSum(BA1->BA1_DATCPT, BF3->BF3_MESAGR))
				dDateCPT:= BA1->BA1_DATCPT + nDays
			endif
		else
			nDays := abs(BF3->BF3_DATCPT - monthSum(BF3->BF3_DATCPT, BF3->BF3_MESAGR))
			dDateCPT := BF3->BF3_DATCPT + nDays
		endif
	else
		if empty(BF3->BF3_DATCPT)
			if empty(BA1->BA1_DATCPT)
				nDays := abs(date() - monthSum(date(), 0))
				dDateCPT := date() + nDays
			else
				nDays := PLSCarDias(BF3->BF3_MESAGR, BF3->BF3_UNAGR)
				dLastDate := BA1->BA1_DATCPT + nDays
			endif
		else
			nDays := PLSCarDias(BF3->BF3_MESAGR, BF3->BF3_UNAGR)
			dLastDate := BF3->BF3_DATCPT + nDays
		endif

		if dLastDate > dDateCPT
			dDateCPT := dLastDate
		endif
	endif

return dDateCPT

/*/{Protheus.doc} getInterPlanCode
Obter o código do plano de intercâmbio do beneficiário no campartilhamento de risco
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 07/08/2024
@return character, código do plano de acordo com o anexo F e G do PTU
/*/
static function getInterPlanCode() as character

	local aAreaBI3 as array
	local cPlanCode := "" as character

	if !empty(BA1->BA1_PLAINT)
		aAreaBI3 := BI3->(getArea())

		if BI3->(dbSeek(xFilial("BI3") + BA1->(BA1_CODINT + BA1_PLAINT)))
			if !empty(BI3->BI3_CODPTU)
				cPlanCode := strZero(val(BI3->BI3_CODPTU), 3)
			endif
		endif

		restArea(aAreaBI3)
	endif

	fwFreeArray(aAreaBI3)

return cPlanCode

/*/{Protheus.doc} cadBenefGetFieldSolution
Retorna em qual cadastro e campo o usuário deverá preencher/alterar o campo criticado
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 07/08/2024
@param cField, character, campo a ser obtido a soluçaõ de preenchimento
@return character, solução de preenchimento do campo
/*/
function cadBenefGetFieldSolution(cField as character) as character

	local cSolution := "" as character
	local jFieldSolution := JsonObject():new() as json

	jFieldSolution["cabecalho.codigoControleTransacao"] := STR0021 // "Transação gerada automaticamente pelo sistema."
	jFieldSolution["cabecalho.codigoVersaoPTU"] := STR0022 // "Fixo 010"
	jFieldSolution["cabecalho.unimed.codigoUnimedOrigem"] := STR0023 // "Cadastro do Lote (BPW), campo Unimed Orig. (BPW_UNIORI)."
	jFieldSolution["cabecalho.unimed.codigoUnimedDestino"] := STR0024 // "Fixo 999"
	jFieldSolution["cabecalho.dataGeracao"] := STR0025 // "Fixo data base do sistema"
	jFieldSolution["cabecalho.protocoloContrato"] := "" // Protocolo gerado pelo VCOM no recebimento do envio de um novo Contrato

	jFieldSolution["dadosBeneficiario.carteirinhaBeneficiario"] := STR0026 // "Cadastro do beneficiário (BA1), campos da Carteirinha (BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)."
	jFieldSolution["dadosBeneficiario.codigoControleUnimedBrasil"] := STR0027 // "Cadastro do beneficiário (BA1), campo Código UB (BA1_CODUBR)."
	jFieldSolution["dadosBeneficiario.codigoFamiliaBenef"] := STR0028 // "Cadastro do beneficiário (BA1), campo Matrícula (BA1_MATRIC)."
	jFieldSolution["dadosBeneficiario.codigoDependenciaBeneficiario"] := STR0029 // "Cadastro Graus de Parentesco (BRP), campo Código EDI (BRP_CODPTU), procurado pelo campo Grau Parent (BA1_GRAUPA)."
	jFieldSolution["dadosBeneficiario.carteirinhaBeneficiarioTitular"] := STR0030 // "Cadastro do beneficiário titular (BA1), campos da Carteirinha (BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)."
	jFieldSolution["dadosBeneficiario.numeroPlanoPortabilidade"] := STR0031 // "Cadastro do beneficiário (BA1), campo Pln Portab. (BA1_PLPOR)."
	jFieldSolution["dadosBeneficiario.indicadorSib"] := STR0032 // "Cadastro do beneficiário (BA1), campo Consid. SIB (BA1_INFSIB)."
	jFieldSolution["dadosBeneficiario.indicadorRemido"] := STR0033 // "Cadastro do beneficiário (BA1), campo Beneficiário Remido (BA1_REMIDO) quando o MV_PLUSARD habilitado, desabilitado Cód. Empresa (BA1_CODEMP) igual a MV_PLSCPEA."
	jFieldSolution["dadosBeneficiario.indicadorAutoGestao"] := STR0034 // "Cadastro do subcontrato (BQC), campo Autogestao (BQC_AUTGES) ou cadastro da operadora (BA0), campo Autogestao (BA0_AUTGES)."
	jFieldSolution["dadosBeneficiario.codigoAutoGestaoAns"] := STR0035 // "Cadastro da operadora (BA0), campo Num Reg ANS (BA0_SUSEP)."
	jFieldSolution["dadosBeneficiario.indicadorBeneficiarioCooperado"] := STR0036 // "Cadastro do beneficiário (BA1), campo Cooperado (BA1_COOPER)."
	jFieldSolution["dadosBeneficiario.dataInclusaoUnimed"] := STR0037 // "Cadastro do beneficiário (BA1), campo Dt. Inclusão (BA1_DATINC)."
	jFieldSolution["dadosBeneficiario.dataExclusaoBeneficiario"] := STR0038 // "Cadastro do beneficiário (BA1), campo  Data Bloq. (BA1_DATBLO)."
	jFieldSolution["dadosBeneficiario.motivoExclusaoBeneficiario"] := STR0039 // "Cadastro motivo de bloqueio (BG3, BG1 ou BQU), campo Código EDI (BG3_CODEDI, BG1_CODEDI ou BQU_CODEDI), definido pelo campo Consid.Bloq. (BA1_CONSID)."
	jFieldSolution["dadosBeneficiario.codigoPlanoInter"] := STR0040 // "Cadastro do produto saúde (BI3), campo Cod EDI (BI3_CODPTU), procurado pelo campo Prod.Interc. (BA1_PLAINT)"
	jFieldSolution["dadosBeneficiario.numeroMatricula"] := ""
	jFieldSolution["dadosBeneficiario.codigoLotacao"] := ""
	jFieldSolution["dadosBeneficiario.descricaoLotacao"] := ""
	jFieldSolution["dadosBeneficiario.dataInclusaoPlanoDestino"] := STR0042 // "Cadastro do beneficiário (BA1), campo Data Repasse (BA1_DATREP)."
	jFieldSolution["dadosBeneficiario.indicadorExcRN561"] := STR0041 // "Bloqueio do beneficiário (BCA), campo Sol.RN412 (BCA_SOL412)."
	jFieldSolution["dadosBeneficiario.indicadorNato"] := STR0043 // "Cadastro do beneficiário (BA1), campo Recém-Nascid (BA1_RECNAS)."
	jFieldSolution["dadosBeneficiario.valorMensalidade"] := STR0120 // "Valor da Mensalidade do Beneficiário, calculado pelos campos da matrícula da família, ano e o mês da cobrança."
	jFieldSolution["dadosBeneficiario.carteirinhaAnterior"] := STR0121 // "Cadastro do beneficiário (BA1), Campo Mat.Sist.Ant (BA1_MATANT)."
	jFieldSolution["dadosBeneficiario.idFilho"] := STR0122 // "Cadastro de vidas (BTS), campo Universit. ? (BTS_UNIVER) e Def. Fisico? (BTS_DEFFIS)."
	jFieldSolution["dadosBeneficiario.dadosCooperado.codigoCrm"] := STR0044 // "Cadastro rede de atendimento (BAU), campo Numero CR (BAU_CONREG), procurado pelo cpf do beneficiário (BA1_CPFUSR)."
	jFieldSolution["dadosBeneficiario.dadosCooperado.codigoUfConselho"] := STR0045 // "Cadastro rede de atendimento (BAU), campo Estado CR (BAU_ESTCR), procurado pelo cpf do beneficiário (BA1_CPFUSR).
	jFieldSolution["dadosBeneficiario.produtoAgregado.indicadorCompartilhamento"] := STR0128 // "Indicador de Compartilhamento de Risco, verdadeiro quando o Campo Operadora Origem (BA1_OPEORI) for diferente do Campo Operadora Destino (BA1_OPEDES)."
	jFieldSolution["dadosBeneficiario.produtoAgregado.codigoUnimedDestino"] := STR0049 // "Cadastro do beneficiário (BA1), campo Op. Destino (BA1_OPEDES)."
	jFieldSolution["dadosBeneficiario.produtoAgregado.tipoProduto"] := STR0046 // "Cadastro do produto saúde (BI3), campo Cod EDI (BI3_CODPTU), procurado pelo campo Cd. Opcional (BF4_CODPRO)."
	jFieldSolution["dadosBeneficiario.produtoAgregado.descricaoProduto"] := STR0047 // "Cadastro do produto saúde (BI3), campo Produto (BI3_DESCRI), procurado pelo campo Cd. Opcional (BF4_CODPRO)."
	jFieldSolution["dadosBeneficiario.produtoAgregado.codigoPlanoDestino"] := STR0137 // "Cadastro do produto saúde (BI3), campo Cod EDI (BI3_CODPTU), quando ocorrer o compartilhamento de risco é procurado pelo campo Prod.Interc. (BA1_PLAINT), caso contrário é procurado pelo campo Cód.Plano (BA1_CODPLA)." 
	jFieldSolution["dadosBeneficiario.produtoAgregado.dataRepasseUnimedDestino"] := STR0136 // "Cadastro do beneficiário (BA1), quando ocorrer o compartilhamento de risco será o campo Data Repasse (BA1_DATREP), caso contrário será o campo Dt. Inclusão (BA1_DATINC)."
	jFieldSolution["dadosBeneficiario.produtoAgregado.dataInicioVigenciaProduto"] := STR0131 // "Cadastro do beneficiário (BA1), em Opcional do Beneficiário (BF4), campo Data Base (BF4_DATBAS)."
	jFieldSolution["dadosBeneficiario.produtoAgregado.dataFimVigenciaProduto"] := STR0135 // "Cadastro do beneficiário (BA1), campo Dt. Bloqueio (BF4_DATBLO)."
	jFieldSolution["dadosBeneficiario.produtoAgregado.dataBaseCarencia"] := STR0134 //"Cadastro do beneficiário (BA1), campo Dt. Carência (BA1_DATCAR)."
	
	jFieldSolution["dadosBeneficiario.preexistencia.codigoCID"] := STR0048 // "Cadastro Doenças Preexistentes (BF3), campo C.I.D. (BF3_CODDOE), procurado pelo carteirinha (BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG)."
	jFieldSolution["dadosBeneficiario.preexistencia.codigoTUSS"] := ""
	jFieldSolution["dadosBeneficiario.preexistencia.dataFimCarencia"] := STR0051 // "Cadastro doenças preexistentes (BF3), data de acordo com a regra dos campos Unidade (BF3_UNAGR), T.Agravo/CPT (BF3_MESAGR), Dt. Base CPT (BF3_DATCPT ou BA1_DATCPT)."

	jFieldSolution["dadosBeneficiario.codigoControleRemido"] :=  STR0027 // "Cadastro do beneficiário (BA1), campo Código UB (BA1_CODUBR) do titular."
	
	jFieldSolution["dadosEmpresaContratante.nomeEmpresa"] := STR0056 // "Cadastro da empresa (BG9), campo Grp/Empresa (BG9_DESCRI)."
	jFieldSolution["dadosEmpresaContratante.nomeFantasiaEmpresa"] := STR0056 // "Cadastro da empresa (BG9), campo Grp/Empresa (BG9_DESCRI)."
	jFieldSolution["dadosEmpresaContratante.nomeEmpresaAbreviado"] := STR0057 // "Cadastro da empresa (BG9), campo Nm. Reduzido (BG9_NREDUZ)."
	jFieldSolution["dadosEmpresaContratante.inscricaoEstadual"] := ""
	jFieldSolution["dadosEmpresaContratante.codigoFilial"] := ""
	jFieldSolution["dadosEmpresaContratante.dataInclusaoEmpresaUnimed"] := STR0129 // "Cadastro do subcontrato (BQC), campo Dt.Sub-Cont. (BQC_DATCON)."
	jFieldSolution["dadosEmpresaContratante.dataExclusaoEmpresaUnimed"] := STR0130 // "Cadastro do subcontrato (BQC), campo Data Bloq. (BQC_DATBLO)."

	jFieldSolution["dadosEmpresaContratante.codigoEmpresaOrigem"] := STR0058 // "Cadastro da empresa (BG9), campo Codigo (BG9_CODIGO)."
	jFieldSolution["dadosEmpresaContratante.tipoContratoLocal"] := STR0050 // "Cadastro do produto saúde (BI3), campo Modal. Cobr. (BI3_MODPAG)."
	jFieldSolution["dadosEmpresaContratante.tipoEmpresa.cnpj"] := STR0059 // "Cadastro do subcontrato (BQC), campo CNPJ (BQC_CNPJ) ou cadastro do cliente (SA1), campo CNPJ/CPF (A1_CGC) procurado pelos campos Cod. Cliente e Loja (BQC_CODCLI + BQC_LOJA)."
	jFieldSolution["dadosEmpresaContratante.tipoEmpresa.caepf"] := STR0060 // "Cadastro do subcontrato (BQC), campo Número CAEPF (BQC_CAEPF) ou Cad Esp INSS (BQC_CEINSS) ou cadastro do cliente (SA1), campo Cad Esp INSS (A1_CEINSS) procurado pelos campos Cod. Cliente e Loja (BQC_CODCLI + BQC_LOJA)."
	jFieldSolution["dadosEmpresaContratante.endereco.logradouroPrincipal"] := STR0061 // "Cadastro do subcontrato (BQC), campo Logradouro (BQC_LOGRAD)."
	jFieldSolution["dadosEmpresaContratante.endereco.complementoLogradouro"] := STR0062 // "Cadastro do subcontrato (BQC), campo Complemento (BQC_COMPLE)."
	jFieldSolution["dadosEmpresaContratante.endereco.numeroLogradouro"] := STR0063 // "Cadastro do subcontrato (BQC), campo Numero (BQC_NUMERO)."
	jFieldSolution["dadosEmpresaContratante.endereco.bairro"] := STR0064 // "Cadastro do subcontrato (BQC), campo Bairro (BQC_BAIRRO)."
	jFieldSolution["dadosEmpresaContratante.endereco.codigoMunicipio"] := STR0065 // "Cadastro do subcontrato (BQC), campo Cd Municipio (BQC_CODMUN)."
	jFieldSolution["dadosEmpresaContratante.endereco.cep"] := STR0066 // "Cadastro do subcontrato (BQC), campo Cep (BQC_CEP)."
	jFieldSolution["dadosEmpresaContratante.telefone.tipoTelefone"] := STR0124 // "Cadastro do subcontrato (BQC), campo Tipo Telef. (BQC_TIPTEL)."
	jFieldSolution["dadosEmpresaContratante.telefone.ddd"] := STR0125 // "Cadastro do subcontrato (BQC), campo DDD (BQC_DDD)."
	jFieldSolution["dadosEmpresaContratante.telefone.numero"] := STR0126 // "Cadastro do subcontrato (BQC), campo Telefone (BQC_TEL)."
	jFieldSolution["dadosEmpresaContratante.telefone.ramal"] := ""

	jFieldSolution["dadosPlano.codigoPlanoOrigem"] := STR0067 // "Cadastro do produto saúde (BI3), campo Codigo (BI3_CODIGO)."
	jFieldSolution["dadosPlano.dataInicioVigencia"] := STR0037 // "Cadastro do beneficiário (BA1), campo Dt. Inclusão (BA1_DATINC)."
	jFieldSolution["dadosPlano.dataFimVigencia"] := STR0038 // "Cadastro do beneficiário (BA1), campo  Data Bloq. (BA1_DATBLO)."
	jFieldSolution["dadosPlano.tipoAbrangencia"] := STR0068 // "Cadastro de abrangências (BF7), campo Cód. EDI (BF7_CODEDI), procurado pelo campo Abrangencia (BI3_ABRANG) do cadastro do produto saúde (BI3)."
	jFieldSolution["dadosPlano.tipoContratacao"] := STR0069 // "Cadastro do produto saúde (BI3), campo Clas. Planos (BI3_CLAPLS)."
	jFieldSolution["dadosPlano.tipoAcomodacao"] := STR0070 // "Cadastro de tipos de acomodação internação (BI4), campo Acomod. EDI (BI4_CODEDI), procurado pelo campo Acomodacao (BI3_CODACO) do cadastro do produto saúde (BI3)."
	jFieldSolution["dadosPlano.codigoOperadoraAns"] := STR0035 // "Cadastro da operadora (BA0), campo Num Reg ANS (BA0_SUSEP)."
	jFieldSolution["dadosPlano.tipoRegistroPlanoAns"] := STR0071 // "Cadastro do produto saúde (BI3), campo Regulament. (BI3_APOSRG)."
	jFieldSolution["dadosPlano.codigoRegistroPlanoAns"] := STR0072 // "Cadastro do produto saúde (BI3), campo Nr. Reg. ANS (BI3_SUSEP) ou Cod. SCPA (BI3_SCPA), de acordo com o campo Regulament. (BI3_APOSRG)."
	jFieldSolution["dadosPlano.segmentacaoPlano"] := STR0073 // "Cadastro de segmentação (BI6), campo Código EDI (BI6_CODEDI), procurado pelo campo segmentacao (BI3_CODSEG)."
	jFieldSolution["dadosPlano.codigoRedeReferenciada"] := STR0074 // "Cadastro do produto saúde (BI3), campo Red.Referen. (BI3_REDREF) ou campo Rd. At. EDI (BI3_REDEDI)."
	jFieldSolution["dadosPlano.nomeRede"] := STR0075 // "Cadastro do produto saúde (BI3), campo Rd.Refer.Des (BI3_RRFDES)."
	jFieldSolution["dadosPlano.viaCartao"] := STR0076 // "Cadastro do beneficiário (BA1), campo Num.Via.Cart (BA1_VIACAR)."
	jFieldSolution["dadosPlano.dataValidadeCartao"] := STR0077 // "Cadastro do beneficiário (BA1), campo Data Vld Car (BA1_DTVLCR)."
	jFieldSolution["dadosPlano.codigoLocalAtendimento"] := STR0078 // "Cadastro do produto saúde (BI3), campo Cd.Lc.At.EDI (BI3_LATEDI)."
	jFieldSolution["dadosPlano.indicadorCoberturaParcialTemporaria"] := STR0051 // "Cadastro doenças preexistentes (BF3), data de acordo com a regra dos campos Unidade (BF3_UNAGR), T.Agravo/CPT (BF3_MESAGR), Dt. Base CPT (BF3_DATCPT ou BA1_DATCPT)."
	jFieldSolution["dadosPlano.dataFimCoberturaParcialTemporaria"] := STR0051 // "Cadastro doenças preexistentes (BF3), data de acordo com a regra dos campos Unidade (BF3_UNAGR), T.Agravo/CPT (BF3_MESAGR), Dt. Base CPT (BF3_DATCPT ou BA1_DATCPT)."
	jFieldSolution["dadosPlano.tipoContrato"] := STR0050 // "Cadastro do produto saúde (BI3), campo Modal. Cobr. (BI3_MODPAG)."
	jFieldSolution["dadosPlano.cnpjAdmBeneficios"] := STR0079 // "Cadastro do subcontrato (BQC), campo CNPJ ADM (BQC_CNPADM)."
	jFieldSolution["dadosPlano.registroANSAdmBeneficios"] := STR0127 // "Cadastro do subcontrato (BQC), campo Reg ANS REC (BQC_RECANS)."
	jFieldSolution["dadosPlano.nomeAdmBeneficios"] := STR0080 // "Cadastro do subcontrato (BQC), campo Raz.Soc.Adm (BQC_RAZSBE)."
	jFieldSolution["dadosPlano.nomeFantasiaAdmBeneficios"] := STR0081 // "Cadastro do subcontrato (BQC), campo Adm.Benefi. (BQC_SEASPL)."
	jFieldSolution["dadosPlano.nomeProduto"] := STR0082 // "Cadastro do produto saúde (BI3), campo Produto (BI3_DESCRI)."
	jFieldSolution["dadosPlano.numeroContrato"] := STR0083 // "Cadastro do subcontrato (BQC), campo Num.Contrato e Versao Cont. (BQC_NUMCON + BQC_VERCON) para pessoa juridica ou cadastro do beneficiário (BA1), campo Operadora e Cód. Empresa (BA1_CODINT + BA1_CODEMP) para pessoa fisica."
	jFieldSolution["dadosPlano.dataContratacaoPlano"] := STR0084 // "Cadastro do subcontrato (BQC), campo Dt.Sub-Cont. (BQC_DATCON) para pessoa juridica ou cadastro do beneficiário (BA1), campo Dt. Inclusão (BA1_DATINC) para pessoa fisica."
	jFieldSolution["dadosPlano.tipoRede"] := STR0055 // "Cadastro do produto saúde (BI3), campo Tp Rede Edi (BI3_TIPRED)."
	jFieldSolution["dadosPlano.indicadorPlanoLowCost"] := STR0085 // "Cadastro do produto saúde (BI3), campo Indic. Plano (BI3_INDPLA)."
	jFieldSolution["dadosPlano.indicadorPlanoAcidenteTrabalho"] := STR0085 // "Cadastro do produto saúde (BI3), campo Indic. Plano (BI3_INDPLA)."
	jFieldSolution["dadosPlano.indicadorPlanoSaudeOcupacional"] := STR0085 // "Cadastro do produto saúde (BI3), campo Indic. Plano (BI3_INDPLA)."
	jFieldSolution["dadosPlano.indicadorPlanoAPS"] := STR0085 // "Cadastro do produto saúde (BI3), campo Indic. Plano (BI3_INDPLA)."
	jFieldSolution["dadosPlano.complemento1"] := ""
	jFieldSolution["dadosPlano.complemento2"] := ""
	jFieldSolution["dadosPlano.abrangencias.codigoUf"] := STR0116 // "Cadastro do Grp de Estados - Abrangência (B9C), campo Estado (B9C_ESTADO), procurado pelo Cód. Abrang. (BF7_CODORI) vinculado no produto saúde, campo Abrangencia (BI3_ABRANG)."
	jFieldSolution["dadosPlano.abrangencias.codigoMunicipio"] := STR0117 // "Cadastro do Grp de Municipio - Abrangência (B9B), campo Cód.Municip. (B9B_CODMUN), procurado pelo Cód. Abrang. (BF7_CODORI) vinculado no produto saúde, campo Abrangencia (BI3_ABRANG)."
	jFieldSolution["dadosPlano.carencias.tipoCarencia"] := STR0086 // "Cadastro de carências conforme o nível configurado, calculado pelos campos data base de carência, unidade e quantidade de carência."
	jFieldSolution["dadosPlano.carencias.dataFimCarencia"] := STR0086 // "Cadastro de carências conforme o nível configurado, calculado pelos campos data base de carência, unidade e quantidade de carência."
	jFieldSolution["dadosPlano.coberturas.tipoCobertura"] := STR0132 // "Cadastro do tipo de cobertura conforme o nível configurado."
	jFieldSolution["dadosPlano.coberturas.dataFimCobertura"] := STR0133 // "Cadastro da data de cobertura conforme o nível configurado."

	jFieldSolution["dadosPessoa.nomeCompletoBeneficiario"] := STR0087 // "Cadastro de vidas (BTS), campo Nome (BTS_NOMUSR) e Sobrenome (BTS_SOBRN)."
	jFieldSolution["dadosPessoa.nomeAbreviadoBeneficiario"] := STR0088 // "Cadastro de vidas (BTS), campo Nome Cart. (BTS_NOMCAR)."
	jFieldSolution["dadosPessoa.nomeSocial"] := STR0089 // "Cadastro de vidas (BTS), campo Nome Social (BTS_NOMSOC)."
	jFieldSolution["dadosPessoa.nomeSocialCartao"] := STR0089 // "Cadastro de vidas (BTS), campo Nome Social (BTS_NOMSOC)."
	jFieldSolution["dadosPessoa.genero"] := STR0090 // "Cadastro de vidas (BTS), campo Sexo (BTS_SEXO)."
	jFieldSolution["dadosPessoa.generoSocial"] := STR0091 // "Cadastro de vidas (BTS), campo Genero Soc. (BTS_GENSOC)."
	jFieldSolution["dadosPessoa.dataNascimento"] := STR0092 // "Cadastro do beneficiário (BA1), campo Dt. Nascto. (BA1_DATNAS)."
	jFieldSolution["dadosPessoa.indicadorBeneficiarioEstrangeiro"] := STR0093 // "Cadastro de vidas (BTS), campo Nacionalid. (BTS_NACION)."
	jFieldSolution["dadosPessoa.cpf"] := STR0094 // "Cadastro do beneficiário (BA1), campo CPF (BA1_CPFUSR)."
	jFieldSolution["dadosPessoa.rg.codigoIdentidade"] := STR0095 // "Cadastro de vidas (BTS), campo Cd.Ident.Edi (BTS_CDIDEN)."
	jFieldSolution["dadosPessoa.rg.orgaoEmissor"] := STR0096 // "Cadastro de vidas (BTS), campo Org.Emis.Edi (BTS_ORGEMI)."
	jFieldSolution["dadosPessoa.rg.uf"] := STR0097 // "Cadastro de vidas (BTS), campo Est. Emissor (BTS_RGEST)."
	jFieldSolution["dadosPessoa.rg.codigoPais"] := STR0098 // "Cadastro de vidas (BTS), campo Pais Emis.Ed (BTS_CDPAIS)."
	jFieldSolution["dadosPessoa.cns"] := STR0099 // "Cadastro de vidas (BTS), campo Nr Cart Nac. (BTS_NRCRNA)."
	jFieldSolution["dadosPessoa.codigoEstadoCivil"] := STR0100 // "Cadastro do beneficiário (BA1), campo Estado Civil (BA1_ESTCIV)."
	jFieldSolution["dadosPessoa.nomeMae"] := STR0101 // "Cadastro do beneficiário (BA1), campo Mãe (BA1_MAE)."
	jFieldSolution["dadosPessoa.pisPasep"] := STR0102 // "Cadastro do beneficiário (BA1), campo PIS/PASEP (BA1_PISPAS) ou cadastro de vidas (BTS), campo PIS/PASEP (BTS_PISPAS)."
	jFieldSolution["dadosPessoa.codigoMunicipioNaturalidade"] := STR0119 //  "Cadastro de vidas (BTS), campo Cod. Mun Nas (BTS_CDMNAS)."
	jFieldSolution["dadosPessoa.codigoMunicipioResidencia"] := STR0103 //  "Cadastro do beneficiário, campo Cd Município (BA1_CODMUN) ou cadastro de vidas (BTS), campo Cd Município (BTS_CODMUN), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo Cd Município (BA1_CODMUN) do titular."
	jFieldSolution["dadosPessoa.enderecos.tipoResidencia"] := STR0104 // "Cadastro de vidas (BTS), campo R.Exterior? (BTS_RESEXT)."
	jFieldSolution["dadosPessoa.enderecos.tipoEndereco"] := STR0105 // "Cadastro de vidas (BTS), campo Tipo Enderec (BTS_TIPEND)."
	jFieldSolution["dadosPessoa.enderecos.tipoLogradouro"] := STR0106 // "Cadastro Tipos de Logradouro (B18), campo Tp.Logra.EDI (B18_CODEDI), procurado pelo cadastro de CEP (BC9), conforme o cadastro do beneficiário, campo CEP (BA1_CEPUSR) ou cadastro de vidas (BTS), campo CEP (BTS_CEPUSR), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo Cd Município (BA1_CODMUN) do titular."
	jFieldSolution["dadosPessoa.enderecos.logradouro"] := STR0107 // "Cadastro do beneficiário (BA1), campo Endereço (BA1_ENDERE) ou cadastro de vidas (BTS), campo Endereço (BTS_ENDERE), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo Endereço (BA1_ENDERE) do titular."
	jFieldSolution["dadosPessoa.enderecos.numeroLogradouro"] := STR0108 // "Cadastro do beneficiário (BA1), campo Numero (BA1_NR_END) ou cadastro de vidas (BTS), campo Numero (BTS_NR_END), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo Numero (BA1_NR_END) do titula"
	jFieldSolution["dadosPessoa.enderecos.bairro"] := STR0109 // "Cadastro do beneficiário (BA1), campo Bairro (BA1_BAIRRO) ou cadastro de vidas (BTS), campo Bairro (BTS_BAIRRO), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo Bairro (BA1_BAIRRO) do titular."
	jFieldSolution["dadosPessoa.enderecos.complemento"] := STR0110 // "Cadastro do beneficiário (BA1), campo Complemento (BA1_COMEND) ou cadastro de vidas (BTS), campo Complemento (BTS_COMEND), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo Complemento (BA1_COMEND) do titular."
	jFieldSolution["dadosPessoa.enderecos.codigoMunicipio"] := STR0111 // "Cadastro do beneficiário, campo Cd Município (BA1_CODMUN) ou cadastro de vidas (BTS), campo Cd Município (BTS_CODMUN), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo Cd Município (BA1_CODMUN) do titular."
	jFieldSolution["dadosPessoa.enderecos.cep"] := STR0112 // "Cadastro do beneficiário (BA1), campo CEP (BA1_CEPUSR) ou cadastro de vidas (BTS), campo CEP (BTS_CEPUSR), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo CEP (BA1_CEPUSR) do titular."
	jFieldSolution["dadosPessoa.complementosCadastrais.telefone.tipoTelefone"] := STR0113 // "Cadastro do beneficiário (BA1), campo Tipo Telef. (BA1_TIPTEL) ou cadastro de vidas (BTS), campo Tipo Telef. (BTS_TIPTEL), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo Tipo Telef. (BA1_TIPTEL) do titular."
	jFieldSolution["dadosPessoa.complementosCadastrais.telefone.ddd"] := STR0114 // "Cadastro do beneficiário (BA1), campo DDD (BA1_DDD) ou cadastro de vidas (BTS), campo DDD (BTS_DDD), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo DDD (BA1_DDD) do titular."
	jFieldSolution["dadosPessoa.complementosCadastrais.telefone.numero"] := STR0115 // "Cadastro do beneficiário (BA1), campo Telefone (BA1_TELEFO) ou cadastro de vidas (BTS), campo Telefone (BTS_TELEFO), caso não seja informado e o beneficiário, seja um dependente, será utilizado o campo Telefone (BA1_TELEFO) do titular."
	jFieldSolution["dadosPessoa.complementosCadastrais.telefone.ramal"] := ""
	jFieldSolution["dadosPessoa.complementosCadastrais.email.tipoEmail"] := STR0053 // "Fixo 1 - Principal ou 2 - Alternativo"
	jFieldSolution["dadosPessoa.complementosCadastrais.email.email"] := STR0054 // "Cadastro do beneficiário (BA1), campo email (BA1_EMAIL) ou email alternativo (BA1_AEMAIL)"

	jFieldSolution["compartilhamentoRisco.codigoUnimedDestino"] := STR0049 // "Cadastro do beneficiário (BA1), campo Op. Destino (BA1_OPEDES)."
	jFieldSolution["compartilhamentoRisco.tipoCompartilhamentoRisco"] := STR0050 // "Cadastro do produto saúde (BI3), campo Modal. Cobr. (BI3_MODPAG)."
	jFieldSolution["compartilhamentoRisco.dataInicioCompartilhamentoRisco"] := STR0042 // "Cadastro do beneficiário (BA1), campo Data Repasse (BA1_DATREP)."
	jFieldSolution["compartilhamentoRisco.dataFimCompartilhamentoRisco"] := STR0118 // "Cadastro do beneficiário (BA1), campo Fin. Repasse (BA1_FINREP)."
	jFieldSolution["compartilhamentoRisco.indicadorGeracaoLogomarca"] := STR0052 // "Cadastro do beneficiário (BA1), campo Carteirinha (BA1_LOCEMI)."
	jFieldSolution["compartilhamentoRisco.indicadorGeracaoCodigo"] := STR0052 // "Cadastro do beneficiário (BA1), campo Carteirinha (BA1_LOCEMI)."
	jFieldSolution["compartilhamentoRisco.indicadorSuspensaoAtendimento"] := "" // "Cadastro do beneficiário (BA1), campo ."

	if jFieldSolution:hasProperty(cField)
		cSolution := jFieldSolution[cField]
	endif

	freeObj(jFieldSolution)

return cSolution

/*/{Protheus.doc} isRiskSharing
Retorna se o beneficiário tem compartilhamento de risco em pré-pagamento (repasse)
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 08/08/2024
@return logical, beneficiário tem compartilhamento de risco
/*/
static function isRiskSharing() as logical

	local lIsRiskSharing := .F. as logical

	lIsRiskSharing := !empty(BA1->BA1_OPEORI) .and. !empty(BA1->BA1_OPEDES) .and. BA1->BA1_OPEORI <> BA1->BA1_OPEDES

return lIsRiskSharing

/*/{Protheus.doc} getUBControlCode
Obter o codigo de controle da Unimed Brasil no formato caracter (string) sem arredondamento
que a classe JsonObject faz (fromJson)
@type function
@version 12.1.2410 
@author vinicius.queiros
@since 09/09/2024
@param cResponseJson, character, json de resposta para busca do codigo de controle
@return character, código de controle no formato caracter
/*/
function getUBControlCode(cResponseJson as character) as character

	local cControlCode as character
	local aAttributes as array
	local aValues as array
	local nCount as numeric
	local nSizeArray as numeric
	local cAttribute := "codigoControleUnimedBrasil" as character

	aAttributes := strTokArr(cResponseJson, ",")
	nSizeArray := len(aAttributes)

	if nSizeArray > 0
		for nCount := 1 to nSizeArray
			if cAttribute $ aAttributes[nCount]
				aValues := strTokArr(aAttributes[nCount], ":")

				if len(aValues) >= 2 // ["atributo", "value"]
					cControlCode := strTran(aValues[len(aValues)], '"', "")
				endif

				exit
			endif
		next nCount
	endif

	fwFreeArray(aAttributes)
	fwFreeArray(aValues)

return cControlCode

/*/{Protheus.doc} getMonthlyValue
Obter o valor da mensalidade do beneficiário calculado a partir da composição de cobrança do beneficiário
@type function
@version 12.1.2510 
@author giovanna.charlo
@since 07/02/2025
@return character, valor da mensalidade do beneficiário
/*/
static function getMonthlyValue() as numeric 

	local nMonthly := 0 as numeric
	local aBilling := {} as array
	local nX := 0 as numeric
	local nSizeArray as numeric
	local aAreaBA1 := BA1->(getArea()) as array
	local aAreaBA3 := BA3->(getArea()) as array

	aBilling := PLSVALOPC(BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC),year2Str(BF4->BF4_DATBAS), month2Str(BF4->BF4_DATBAS),nil,nil,.F.,nil,nil,"1","102")

	If Len(aBilling) > 0
		nSizeArray := len(aBilling)

		For nX := 1 To nSizeArray
			If alltrim(aBilling[nX][11]) == alltrim(BF4->BF4_CODPRO) .And. BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO) == aBilling[nX][1]

				nMonthly := aBilling[nX][24]
				exit
			Endif
		Next nX
	Endif

	restArea(aAreaBA1)
	restArea(aAreaBA3)

return nMonthly

/*/{Protheus.doc} getChildId
Obter o código identificador do Filho do beneficiário
@type function
@version 12.1.2510 
@author giovanna.charlo
@since 07/02/2025
@return character, identificador do Filho 
/*/
static function getChildId() as character

	local cId as character

	Do Case
		Case BTS->BTS_UNIVER == "1"
			cId := "01

		Case BTS->BTS_DEFFIS ==  "1"
			cId := "02"

		Otherwise
			cId := "99"
	EndCase

return cId

/*/{Protheus.doc} getBeneficiaryCoverage
Obter os dados de cobertura no nível do beneficiário
@type function
@version 12.1.2510 
@author giovanna.charlo
@since 07/02/2025
@param cSubscriberId, character, carterinha do beneficiário
@return array, coberturas do beneficiário
/*/
static function getBeneficiaryCoverage(aData as array) as array

	local cAlias as character
	local cQuery as character
	local cCoverageCode as character
	local nOrder := 1 as numeric
	local oStatement as object

	cQuery += "SELECT DISTINCT ? "
	cQuery += " FROM ? BFE "
	cQuery += " INNER JOIN ? BG7 ON "
	cQuery += "		BG7.BG7_FILIAL = BFE.BFE_FILIAL AND "
	cQuery += "		BG7.BG7_CODGRU = BFE.BFE_CODGRU AND "
	cQuery += "		BG7.D_E_L_E_T_ = ? "
	cQuery += " WHERE BFE.BFE_FILIAL = ? AND "
	cQuery += " 	  BFE.BFE_CODINT = ? AND "
	cQuery += " 	  BFE.BFE_CODEMP = ? AND "
	cQuery += " 	  BFE.BFE_MATRIC = ? AND "
	cQuery += " 	  BFE.BFE_TIPREG = ? AND "
	cQuery += " 	  BFE.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY ? "

	cQuery := changeQuery(cQuery)

	oStatement := FwExecStatement():new(cQuery)

	oStatement:setUnsafe(nOrder++, "BG7_CODGRU, BG7_DESCRI, BFE_DATCAR" + iif(BG7->(fieldPos("BG7_CODEDI")) > 0, ",BG7_CODEDI", ""))
	oStatement:setUnsafe(nOrder++, retSqlName("BFE"))
	oStatement:setUnsafe(nOrder++, retSqlName("BG7"))
	oStatement:setString(nOrder++, "")
	oStatement:setString(nOrder++, xFilial("BFE"))
	oStatement:setString(nOrder++, BA1->BA1_CODINT)
	oStatement:setString(nOrder++, BA1->BA1_CODEMP)
	oStatement:setString(nOrder++, BA1->BA1_MATRIC)
	oStatement:setString(nOrder++, BA1->BA1_TIPREG)
	oStatement:setString(nOrder++,"")
	oStatement:setUnsafe(nOrder++,"BG7_CODGRU, BG7_DESCRI, BFE_DATCAR")

	cAlias := oStatement:openAlias()

	(cAlias)->(dbGoTop())

	while !(cAlias)->(Eof())
		cCoverageCode := iif(BG7->(fieldPos("BG7_CODEDI")) > 0, (cAlias)->BG7_CODEDI, (cAlias)->BG7_CODGRU)
		aAdd(aData, {"code": cCoverageCode, "date": STOD((cAlias)->BFE_DATCAR)})

		(cAlias)->(DBSkip())
	enddo

	(cAlias)->(dbCloseArea())

	freeObj(oStatement)

return aData


/*/{Protheus.doc} getFamilyCoverage
Obter os dados de cobertura no nível da família
@type function
@version 12.1.2510 
@author giovanna.charlo
@since 07/02/2025
@param cSubscriberId, character, carterinha do beneficiário
@return array, cobertura da familia do beneficiário
/*/
static function getFamilyCoverage(aData as array) as array

	local cAlias as character
	local cQuery as character
	local cCoverageCode as character
	local nOrder := 1 as numeric
	local oStatement as object

	cQuery += "SELECT DISTINCT ? "
	cQuery += " FROM ? BFC "
	cQuery += " INNER JOIN ? BG7 ON "
	cQuery += "		BG7.BG7_FILIAL = BFC.BFC_FILIAL AND "
	cQuery += "		BG7.BG7_CODGRU = BFC.BFC_CODGRU AND "
	cQuery += "		BG7.D_E_L_E_T_ = ? "
	cQuery += " WHERE BFC.BFC_FILIAL = ? AND "
	cQuery += " 	  BFC.BFC_CODINT = ? AND "
	cQuery += " 	  BFC.BFC_CODEMP = ? AND "
	cQuery += " 	  BFC.BFC_MATRIC = ? AND "
	cQuery += " 	  BFC.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY ? "

	cQuery := changeQuery(cQuery)

	oStatement := FwExecStatement():new(cQuery)

	oStatement:setUnsafe(nOrder++, "BG7_CODGRU, BG7_DESCRI" + iif(BG7->(fieldPos("BG7_CODEDI")) > 0, ",BG7_CODEDI", ""))
	oStatement:setUnsafe(nOrder++, retSqlName("BFC"))
	oStatement:setUnsafe(nOrder++, retSqlName("BG7"))
	oStatement:setString(nOrder++, "")
	oStatement:setString(nOrder++, xFilial("BFC"))
	oStatement:setString(nOrder++, BA3->BA3_CODINT)
	oStatement:setString(nOrder++, BA3->BA3_CODEMP)
	oStatement:setString(nOrder++, BA3->BA3_MATRIC)
	oStatement:setString(nOrder++,"")
	oStatement:setUnsafe(nOrder++,"BG7_CODGRU, BG7_DESCRI")

	cAlias := oStatement:openAlias()

	(cAlias)->(dbGoTop())

	while !(cAlias)->(Eof())
		cCoverageCode := iif(BG7->(fieldPos("BG7_CODEDI")) > 0, (cAlias)->BG7_CODEDI, (cAlias)->BG7_CODGRU)
		aAdd(aData, {"code": cCoverageCode, "date": BA1->BA1_DATCAR})

		(cAlias)->(DBSkip())
	enddo

	(cAlias)->(dbCloseArea())

	freeObj(oStatement)

return aData

/*/{Protheus.doc} getSubcontractCoverage
Obter os dados de cobertura vinculado ao subcontrato do beneficiário, em casos de pessoa juridica.
@type function
@version 12.1.2510 
@author giovanna.charlo
@since 07/02/2025
@param cSubscriberId, character, carterinha do beneficiário
@return array, cobertura vinculado ao subcontrato do beneficiário
/*/
static function getSubcontractCoverage(aData as array) as array

	local cAlias as character
	local cQuery as character
	local cCoverageCode as character
	local nOrder := 1 as numeric
	local oStatement as object

	cQuery += "SELECT DISTINCT ? "
	cQuery += " FROM ? BT7 "
	cQuery += " INNER JOIN ? BG7 ON "
	cQuery += "		BG7.BG7_FILIAL = BT7.BT7_FILIAL AND "
	cQuery += "		BG7.BG7_CODGRU = BT7.BT7_CODGRU AND "
	cQuery += "		BG7.D_E_L_E_T_ = ? "
	cQuery += " WHERE BT7.BT7_FILIAL = ? AND "
	cQuery += " 	  BT7.BT7_CODINT = ? AND "
	cQuery += " 	  BT7.BT7_CODIGO = ? AND "
	cQuery += " 	  BT7.BT7_NUMCON = ? AND "
	cQuery += " 	  BT7.BT7_VERCON = ? AND "
	cQuery += " 	  BT7.BT7_SUBCON = ? AND "
	cQuery += " 	  BT7.BT7_VERSUB = ? AND "
	cQuery += " 	  BT7.BT7_CODPRO = ? AND "
	cQuery += " 	  BT7.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY ? "
	
	cQuery := changeQuery(cQuery)

	oStatement := FwExecStatement():new(cQuery)

	oStatement:setUnsafe(nOrder++, "BG7_CODGRU, BG7_DESCRI" + iif(BG7->(fieldPos("BG7_CODEDI")) > 0, ",BG7_CODEDI", ""))
	oStatement:setUnsafe(nOrder++, retSqlName("BT7"))
	oStatement:setUnsafe(nOrder++, retSqlName("BG7"))
	oStatement:setString(nOrder++, "")
	oStatement:setString(nOrder++, xFilial("BT7"))
	oStatement:setString(nOrder++, BA3->BA3_CODINT)
	oStatement:setString(nOrder++, BA3->BA3_CODEMP)
	oStatement:setString(nOrder++, BA3->BA3_CONEMP)
	oStatement:setString(nOrder++, BA3->BA3_VERCON)
	oStatement:setString(nOrder++, BA3->BA3_SUBCON)
	oStatement:setString(nOrder++, BA3->BA3_VERSUB)
	oStatement:setString(nOrder++, BA3->BA3_CODPLA)
	oStatement:setString(nOrder++,"")
	oStatement:setUnsafe(nOrder++,"BG7_CODGRU, BG7_DESCRI")

	cAlias := oStatement:openAlias()

	(cAlias)->(dbGoTop())

	while !(cAlias)->(Eof())
		cCoverageCode := iif(BG7->(fieldPos("BG7_CODEDI")) > 0, (cAlias)->BG7_CODEDI, (cAlias)->BG7_CODGRU)
		aAdd(aData, {"code": cCoverageCode, "date": BA1->BA1_DATCAR})

		(cAlias)->(DBSkip())
	enddo

	(cAlias)->(dbCloseArea())

	freeObj(oStatement)

return aData

/*/{Protheus.doc} getProductCoverage
Obter os dados de cobertura vinculado ao produto do beneficiário, em casos de pessoa fisica.
@type function
@version 12.1.2510 
@author giovanna.charlo
@since 07/02/2025
@param cSubscriberId, character, carterinha do beneficiário
@return array, cobertura vinculado ao produto do beneficiário
/*/
static function getProductCoverage(aData as array) as array

	local cAlias as character
	local cQuery as character
	local cCoverageCode as character
	local nOrder := 1 as numeric
	local oStatement as object

	cQuery += "SELECT DISTINCT ? "
	cQuery += " FROM ? BRV "
	cQuery += " INNER JOIN ? BG7 ON "
	cQuery += "		BG7.BG7_FILIAL = BRV.BRV_FILIAL AND "
	cQuery += "		BG7.BG7_CODGRU = BRV.BRV_CODGRU AND "
	cQuery += "		BG7.D_E_L_E_T_ = ? "
	cQuery += " WHERE BRV.BRV_FILIAL = ? AND "
	cQuery += " 	  BRV.BRV_CODPLA = ? AND "
	cQuery += " 	  BRV.BRV_VERSAO = ? AND "
	cQuery += " 	  BRV.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY ? "

	cQuery := changeQuery(cQuery)

	oStatement := FwExecStatement():new(cQuery)

	oStatement:setUnsafe(nOrder++, "BG7_CODGRU, BG7_DESCRI" + iif(BG7->(fieldPos("BG7_CODEDI")) > 0, ",BG7_CODEDI", ""))
	oStatement:setUnsafe(nOrder++, retSqlName("BRV"))
	oStatement:setUnsafe(nOrder++, retSqlName("BG7"))
	oStatement:setString(nOrder++, "")
	oStatement:setString(nOrder++, xFilial("BRV"))
	oStatement:setString(nOrder++, BA3->BA3_CODINT + BA3->BA3_CODPLA)
	oStatement:setString(nOrder++, BA3->BA3_VERSAO)
	oStatement:setString(nOrder++,"")
	oStatement:setUnsafe(nOrder++,"BG7_CODGRU, BG7_DESCRI")

	cAlias := oStatement:openAlias()

	(cAlias)->(dbGoTop())

	while !(cAlias)->(Eof())
		cCoverageCode := iif(BG7->(fieldPos("BG7_CODEDI")) > 0, (cAlias)->BG7_CODEDI, (cAlias)->BG7_CODGRU)
		aAdd(aData, {"code": cCoverageCode, "date": BA1->BA1_DATCAR})

		(cAlias)->(DBSkip())
	enddo

	(cAlias)->(dbCloseArea())

	freeObj(oStatement)

return aData

/*/{Protheus.doc} getTotalCoverage
Retorna todos os códigos da tabela K do PTU
@type function
@version 12.1.2410 
@author gabriel.lakatos
@since 11/09/2025
@return array, cobertura total vinculado ao produto
/*/
static function getTotalCoverage(aData as array) as array

	local aCodTabK := {} as array
	local nCount as numeric

	aCodTabK := FWGetSX5("CY")
	for nCount := 1 to len(aCodTabK)
		aAdd(aData, {"code": alltrim(aCodTabK[nCount][3]), "date": BA1->BA1_DATCAR})
	next

return aData

/*/{Protheus.doc} isPlanHolder
Retorna se o beneficiário é titular do plano ou não
@type function
@version 12.1.2410 
@author gabriel.lakatos
@since 29/08/2025
@return character, código de dependencia do beneficiário
/*/
static function isPlanHolder() as logical

	local lIsHolder := .F. as logical

	BRP->(dbSetOrder(1))
	if BRP->(dbSeek(xFilial("BRP") + BA1->BA1_GRAUPA))
		if BRP->BRP_CODPTU == "00"
			lIsHolder := .T.
		endif
	endif

return lIsHolder


/*/{Protheus.doc} getBeneficiaryRedeemedCode
Retorna código controle unimed do beneficiário titular
@type function
@version 12.1.2410 
@author gabriel.lakatos
@since 05/09/2025
@return character, código de dependencia do beneficiário
/*/
static function getBeneficiaryRedeemedCode() as character

	local cBeneficiaryCode := "" as character
	local cQuery as character
	local cAlias as character
	local nOrder := 1 as numeric
	local oExecStmt as object

	cQuery := " SELECT ? "
	cQuery += " FROM ? BA1 "
	cQuery += " WHERE "
	cQuery += "     BA1.BA1_FILIAL = ? AND "
	cQuery += "     BA1.BA1_CODEMP = ? AND "
	cQuery += "     BA1.BA1_MATRIC = ? AND "
	cQuery += "     BA1.D_E_L_E_T_ = ? "
	cQuery := changeQuery(cQuery)

	oExecStmt := FwExecStatement():new(cQuery)
	oExecStmt:setUnsafe(nOrder++, "BA1_TIPUSU, BA1_CODUBR")
	oExecStmt:setUnsafe(nOrder++, retSqlName("BA1"))
	oExecStmt:setString(nOrder++, xFilial("BA1"))
	oExecStmt:setString(nOrder++, BA1->BA1_CODEMP)
	oExecStmt:setString(nOrder++, BA1->BA1_MATRIC)
	oExecStmt:setString(nOrder++, " ")

	cAlias := oExecStmt:openAlias()

	(cAlias)->(dbGoTop())
	while !(cAlias)->(eof())
 
		if alltrim((cAlias)->BA1_TIPUSU) == "T"
			cBeneficiaryCode := (cAlias)->BA1_CODUBR
		endif

		(cAlias)->(dbSkip())
	enddo

	(cAlias)->(dbCloseArea())

	freeObj(oExecStmt)

return cBeneficiaryCode
