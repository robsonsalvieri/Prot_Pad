
#include "tlpp-core.th"

namespace totvs.protheus.health.plan.api.util

/*/{Protheus.doc} RestClient
Classe para comunicação rest do modulo plano de saúde (SIGAPLS)
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
/*/
class RestClient

    protected data cEndpoint as character
    protected data cPath as character
    protected data cBody as character
    protected data cResponseBody as character
    protected data cResponseCookie as character
    protected data cErrorMessage as character
    protected data aHeaderParams as array
    protected data aQueryParams as array
    protected data cStatusCode as character
    protected data lRobotTest as logical
    protected data cCertificate as character
    protected data cPrivKey as character
    protected data cPassword as character

    public method new() constructor
    public method setRobotTest(cResponseBody as character, cResponseCookie as character) as logical
    public method post() as logical
    public method delete() as logical
    public method patch() as logical
    public method destroy()
    public method removeSpecialChar() as character

    public method getCookie() as character
    public method getBody() as character
    public method getErrorMessage() as character
    public method getStatusCode() as numeric
    
    public method setEndpoint(cEndpoint as character) as logical
    public method setHeaderParams(aHeaderParams as array) as logical
    public method setQueryParams(aQueryParams as array) as logical
    public method setPath(cPath as character) as logical
    public method setBody(cBody as character) as logical
    public method appendValidCertificate(cCertificateDirectory as character, cFileNamePFX as character, cPassword as character) as json 
    public method setDigitalCertificate(cCertificate as character, cPrivKey as character, cPassword as character)
 
endclass

/*/{Protheus.doc} new
Método construtor da classe
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
/*/
method new() class RestClient
return self

/*/{Protheus.doc} setRobotTest
Defini que o retorno da comunicação é pelo robô de testes
@type method
@version 12.1.2410  
@author vinicius.queiros
@return logical, sucesso ao definir os dados
@since 15/01/2024
/*/
method setRobotTest(cResponseBody as character, cResponseCookie as character) as logical class RestClient

    self:cResponseBody := cResponseBody
    self:cResponseCookie := cResponseCookie
    self:lRobotTest := .T.

return self:lRobotTest

/*/{Protheus.doc} post
Realiza a comunicação POST
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 10/01/2024
/*/
method post() as logical class RestClient

    local oRestClient as object
    local aHeader := {} as array
    local nPosCookie as numeric
    local lOk := .F. as logical
    local nX as numeric

    if len(self:aHeaderParams) > 0
        for nX := 1 to len(self:aHeaderParams)
            aAdd(aHeader, self:aHeaderParams[nX]["key"]+": "+self:aHeaderParams[nX]["value"])
        next nX
    endif

    if !empty(self:cCertificate)
        self:cResponseBody := httpSQuote(self:cEndpoint + self:cPath, self:cCertificate, self:cPrivKey, self:cPassword, "POST", nil, self:cBody, nil, aHeader)
        self:cStatusCode := cValToChar(httpGetStatus(@self:cErrorMessage))

        if self:cStatusCode $ "200-201"
            lOk := .T.
        endif
    else
        oRestClient := FWRest():new(self:cEndpoint)
        oRestClient:setPath(self:cPath)
        oRestClient:setPostParams(self:cBody)

        if self:lRobotTest .or. oRestClient:post(aHeader)
            if !self:lRobotTest
                self:cResponseBody := oRestClient:getResult()

                if len(oRestClient:oResponseH:aHeaderFields) > 0
                    nPosCookie := aScan(oRestClient:oResponseH:aHeaderFields, {|x| upper(allTrim(x[1])) == "SET-COOKIE"})
                    if nPosCookie > 0
                        self:cResponseCookie := oRestClient:oResponseH:aHeaderFields[nPosCookie][2]
                    endif
                endif
            endif

            lOk := .T.
        else
            lOk := .F.
            self:cErrorMessage := oRestClient:getLastError()
            self:cResponseBody := oRestClient:getResult()
        endif

        self:cStatusCode := oRestClient:getHttpCode()
    endif

    freeObj(oRestClient)
    fwFreeArray(aHeader)

return lOk

/*/{Protheus.doc} delete
Realiza a comunicação DELETE
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 03/04/2024
@return logical, sucesso ao realizar a comunicaçao
/*/
method delete() as logical class RestClient 

    local lOk := .F. as logical
    local oRestClient as object
    local nX as numeric
    local aHeaders := {} as array
    local cParams := "" as character
    local cPathParams := "" as character

    if len(self:aHeaderParams) > 0
        for nX := 1 to len(self:aHeaderParams)
            aAdd(aHeaders, self:aHeaderParams[nX]["key"]+": "+self:aHeaderParams[nX]["value"])
        next nX
    endif

    if len(self:aQueryParams) > 0
        for nX := 1 to len(self:aQueryParams)
            if !empty(cParams)
                cParams += "&"
            endif

            cParams += self:aQueryParams[nX]["key"] + "=" + self:aQueryParams[nX]["value"]
        next nX
    endif

    if !empty(self:cCertificate)
        self:cResponseBody := httpSQuote(self:cEndpoint + self:cPath + iif(!empty(cParams), "?" + cParams, ""), self:cCertificate, self:cPrivKey, self:cPassword, "DELETE", nil, self:cBody, nil, aHeaders)
        self:cStatusCode := cValToChar(httpGetStatus(@self:cErrorMessage))

        if self:cStatusCode $ "200-201"
            lOk := .T.
        endif
    else
        cPathParams := self:cPath

        if !empty(cParams)
            cPathParams += "?" + cParams
        endif

        oRestClient := FWRest():new(self:cEndpoint)
        oRestClient:setPath(cPathParams)

        if self:lRobotTest .or. oRestClient:delete(aHeaders)
            if !self:lRobotTest
                self:cResponseBody := oRestClient:getResult()
            endif

            lOk := .T.
        else
            lOk := .F.
            self:cErrorMessage := oRestClient:getLastError()
            self:cResponseBody := oRestClient:getResult()
        endif

        self:cStatusCode := oRestClient:getHttpCode()
    endif

    freeObj(oRestClient)
    fwFreeArray(aHeaders)

return lOk

/*/{Protheus.doc} patch
Realiza a comunicação PATCH
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 04/04/2024
@return logical, sucesso ao realizar a comunicaçao
/*/
method patch() as logical class RestClient

    local lOk := .F. as logical
    local nX as numeric
    local aHeaders := {} as array

    if len(self:aHeaderParams) > 0
        for nX := 1 to len(self:aHeaderParams)
            aAdd(aHeaders, self:aHeaderParams[nX]["key"]+": "+self:aHeaderParams[nX]["value"])
        next nX
    endif

    self:cResponseBody := httpSQuote(self:cEndpoint + self:cPath, self:cCertificate, self:cPrivKey, self:cPassword, "PATCH", nil, self:cBody, nil, aHeaders)
    self:cStatusCode := cValToChar(httpGetStatus(@self:cErrorMessage))

    if self:cStatusCode == "200"
        lOk := .T.
    endif
   
    fwFreeArray(aHeaders)

return lOk

/*/{Protheus.doc} destroy
Limpa as propriedades para liberar a memoria alocada no Server
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
/*/
method destroy() class RestClient

    fwFreeArray(self:aHeaderParams)
    fwFreeArray(self:aQueryParams)

return

/*/{Protheus.doc} getCookie
Obter cookie da resposta da comunicação rest
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
@return character, Cookie recebido
/*/
method getCookie() as character class RestClient

return self:cResponseCookie

/*/{Protheus.doc} getBody
Obter body da resposta da comunicação rest
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
@return character, Body recebido
/*/
method getBody() as character class RestClient

    local cError as character
    local jBody := JsonObject():new() as json
    local cMessage := "" as character

    cError := jBody:fromJson(self:cResponseBody)

    if !empty(cError)
        cMessage := iif(valType(self:cResponseBody) == "C", self:cResponseBody, iif(valType(self:cErrorMessage) == "C", self:cErrorMessage, ""))

        self:cResponseBody := '{"code": "' + cValToChar(self:getStatusCode()) + '", "message": "' + cMessage + '", "detailedMessage": ""}'
    endif

    freeObj(jBody)

return self:cResponseBody

/*/{Protheus.doc} getErrorMessage
Obter messagem de erro
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
@return character, messagem de erro
/*/
method getErrorMessage() as character class RestClient

return self:cErrorMessage

/*/{Protheus.doc} getStatusCode
Obter o código de status http
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
@return character, codigo de status da requisição
/*/
method getStatusCode() as numeric class RestClient

    local nStatusCode := 500 as numeric // Internal server error

    if !empty(self:cStatusCode)
        if valType(self:cStatusCode) == "C"
            nStatusCode := val(self:cStatusCode)
        endif
    endif

return nStatusCode

/*/{Protheus.doc} setEndpoint
Defini o endpoint da requisição para comunicação rest
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
@param cEndpoint, character, endpoint da requisição
@return logical, sucesso ao definir
/*/

method setEndpoint(cEndpoint as character) as logical class RestClient

    self:cEndpoint := cEndpoint

return .t.

/*/{Protheus.doc} setHeaderParams
Defini o Headers da requisição para comunicação rest
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
@param aHeaderParams, array, array de objetos json contendo a key e value do header
@return logical, sucesso ao definir
/*/
method setHeaderParams(aHeaderParams as array) as logical class RestClient

    self:aHeaderParams := aClone(aHeaderParams)

return .t.

/*/{Protheus.doc} setQueryParams
Defini o query params da requisição para comunicação rest
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 03/04/2024
@param aQueryParams, array, Oobjetos json contendo a key e value do query params
@return logical, sucesso ao definir
/*/
method setQueryParams(aQueryParams as array) as logical class RestClient

    self:aQueryParams := aClone(aQueryParams)

return .T.

/*/{Protheus.doc} setPath
Defini o path da requisição para comunicação rest
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
@param cPath, character, Path da requisição 
@return logical, sucesso ao definir
/*/
method setPath(cPath as character) as logical class RestClient

    self:cPath := cPath

return .t.

/*/{Protheus.doc} setBody
Defini o body da requisição para comunicação rest
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 11/01/2024
@param cBody, character, Body (json) da requisição
@return logical, sucesso ao definir
/*/
method setBody(cBody as character) as logical class RestClient

    self:cBody := cBody

return .t.

/*/{Protheus.doc} setDigitalCertificate
Defini os dados do certificado digital PEM (modelo Apache)
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 04/04/2024
@param cCertificate, character, Indica o path do arquivo, em formato PEM (modelo Apache), do arquivo que contém o certificado digital.
@param cPrivKey, character, Indica o path da chave privada, em formato PEM (modelo Apache), do arquivo que contém a chave privada, referente ao certificado digital.
@param cPassword, character, Indica a senha que será utilizada para a abertura da chave privada. Para uma chave privada que não possua senha deve ser informada uma string vazia.
/*/
method setDigitalCertificate(cCertificate as character, cPrivKey as character, cPassword as character) class RestClient

    self:cCertificate := cCertificate
    self:cPrivKey := cPrivKey
    self:cPassword := cPassword

return

/*/{Protheus.doc}
Método para remover caracteres especiais das strings
@type method
@version 12.1.2410
@author guilherme.carreiro
@since 28/08/2024
@param cText, character, Texto recebido que será tratado e retornado no método.
/*/
method removeSpecialChar(cText as character) as character class RestClient

    default cText := ""

    cText := strTran(cText, "'", "")
    cText := strTran(cText, "#", "")
    cText := strTran(cText, "%", "")
    cText := strTran(cText, "*", "")
    cText := strTran(cText, "&", "")
    cText := strTran(cText, ">", "")
    cText := strTran(cText, "<", "")
    cText := strTran(cText, "!", "")
    cText := strTran(cText, "@", "")
    cText := strTran(cText, "$", "")
    cText := strTran(cText, "(", "")
    cText := strTran(cText, ")", "")
    cText := strTran(cText, "=", "")
    cText := strTran(cText, "+", "")
    cText := strTran(cText, "{", "")
    cText := strTran(cText, "}", "")
    cText := strTran(cText, "[", "")
    cText := strTran(cText, "]", "")
    cText := strTran(cText, "/", "")
    cText := strTran(cText, "?", "")
    cText := strTran(cText, ".", "")
    cText := strTran(cText, "\", "")
    cText := strTran(cText, "|", "")
    cText := strTran(cText, ":", "")
    cText := strTran(cText, ";", "")
    cText := strTran(cText, '"', '')
    cText := strTran(cText, '°', '')
    cText := strTran(cText, 'ª', '')
    cText := strTran(cText, ",", "")
    cText := strTran(cText, "-", "")
    
    cText := fwNoAccent(cText)

return cText

/*/{Protheus.doc} appendValidCertificate
Adiciona um certificado válido ao cliente REST, a partir de um arquivo PFX e senha fornecidos.
@type method
@version 12.1.2510
@since 17/04/2025
@author giovanna.charlo
@param cCertificateDirectory, character, diretório onde está localizado o arquivo do certificado
@param cFileNamePFX, character, nome do arquivo .pfx que contém o certificado digital
@param cPassword, character, senha de acesso ao certificado
@return json, estrutura JSON contendo o resultado da operação
/*/
method appendValidCertificate(cCertificateDirectory as character, cFileNamePFX as character, cPassword as character) as json class RestClient

    local cPFXFile as character
    local cCertificate as character
    local cPrivKey as character
    local cError as character
    local jStatus := {"status": .F., "message": "", "error": ""} as json

    cPFXFile := PLSMudSis(cCertificateDirectory + cFileNamePFX)
    cCertificate := PLSMudSis(cCertificateDirectory + "certificate.pem")
    cPrivKey := PLSMudSis(cCertificateDirectory + "privKey.pem")

    if file(cPFXFile)
        do case
            case !file(cCertificate) .and. !PFXCert2PEM(cPFXFile, cCertificate, @cError, cPassword)
                jStatus["message"] := "Falha ao extrair o certificado de cliente para geração do arquivo no formato .PEM (Privacy Enhanced Mail)."
                jStatus["error"] := cError

            case !file(cPrivKey) .and. !PFXKey2PEM(cPFXFile, cPrivKey, @cError, cPassword)
                jStatus["message"] := "Falha ao extrair a chave privada para geração do arquivo no formato .PEM (Privacy Enhanced Mail)."
                jStatus["error"] := cError

            otherwise
                jStatus["status"] := .T.
                self:setDigitalCertificate(cCertificate, cPrivKey, cPassword)
        endcase
    else
        jStatus["message"] := "Certificado digital (PFX) não encontrado no diretório (RootPath) do servidor."
        jStatus["error"] := cError
    endif

return jStatus
