#include "tlpp-core.th"
#include "health.plan.api.familycontract.beneficiaryprotocol.service.ch"
#include "fwmvcdef.ch"

#define STATUS_CODE_OK 200
#define STATUS_CODE_CREATED 201
#define STATUS_CODE_BAD_REQUEST 400
#define STATUS_CODE_NOT_FOUND 404

#define PROTOCOL_STATUS_PENDING_DOC "1" // Pendente de documentação
#define PROTOCOL_STATUS_UNDER_REVIEW "2" // Em análise
#define PROTOCOL_STATUS_PROCESSED "3" // Processado
#define PROTOCOL_STATUS_APPROVED "4" // Aprovado
#define PROTOCOL_STATUS_REJECTED "5" // Rejeitado
#define PROTOCOL_STATUS_PARTIALLY_APPROVED "6" // Aprovado Parcialmente
#define PROTOCOL_STATUS_AUTO_APPROVED "7" // Aprovado Automaticamente

#define PROTOCOL_TYPE_INCLUSION "1" // Inclusão
#define PROTOCOL_TYPE_UPDATE "2" // Alteração
#define PROTOCOL_TYPE_BLOCK "3" // Bloqueio

#define PORTAL_COMPANY 2
#define PORTAL_BENEFICIARY 3

namespace totvs.protheus.health.plan.api.familycontract

using namespace totvs.protheus.health.plans.api.util

/*/{Protheus.doc} BeneficiaryProtocolService
Classe responsável por gerenciar os serviços relacionados ao protocolo de beneficiários, incluindo a obtenção de protocolos, anexos e dados em base64.
@type class
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
*/
class BeneficiaryProtocolService from BaseService

	protected data aFormFields as array

	public method new() constructor
	public method destroy()

	public method getProtocols(lTotals as logical) as logical
	public method getBase64Protocol() as logical
	public method postAttachments() as logical
	public method getProtocolId() as logical
	public method addBlockProtocol() as logical

	protected method getBeneficiaries(cProtocolCode as character) as array
	protected method getChangedFields(cProtocolCode as character, cStatus as character) as array
	protected method validateProtocolExists(cProtocol as character, cErrorCode as character) as logical
	protected method getFieldLabel(cField as character) as character
	protected method getFieldValue(cField as character, cValue as character) as character
	protected method setProtocolData() as logical
	protected method processAttachedFiles() as array

endclass

/*/{Protheus.doc} new
Método construtor da classe, inicializando a classe `BeneficiaryProtocolService` e chamando o construtor da classe pai.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@return object, retorna a instância da classe `BeneficiaryProtocolService`
*/
method new() class BeneficiaryProtocolService

	_Super:new()

return self

/*/{Protheus.doc} destroy
Libera os recursos da classe `BeneficiaryProtocolService`, incluindo os campos de formulário, e chama o destruidor da classe pai.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
*/
method destroy() class BeneficiaryProtocolService

	fwFreeArray(self:aFormFields)

	_Super:destroy()

return

/*/{Protheus.doc} getProtocols
Obtém os protocolos de beneficiários, configurando o resultado e o código de status com base na resposta do adaptador.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param lTotals, logical, indica se deve retornar os totais de protocolos
@return logical, retorna verdadeiro se os protocolos foram obtidos com sucesso, falso caso contrário
/*/
method getProtocols(lTotals as logical) as logical class BeneficiaryProtocolService

	local lSuccess := .F. as logical
	local oAdapter as object

	default lTotals := .F.

	oAdapter := BeneficiaryProtocolAdapter():new()
	oAdapter:setQueryParams(self:jParams)

	if lTotals
		self:jResult := oAdapter:getTotalProtocols()
		self:nCodeStatus := STATUS_CODE_OK
		lSuccess := .T.
	else
		if oAdapter:getBeneficiaryProtocols()
			lSuccess := .T.
			self:nCodeStatus := STATUS_CODE_OK
			self:jResult := oAdapter:getJsonResult()
		endif
	endIf

	oAdapter:destroy()
	freeObj(oAdapter)

return lSuccess

/*/{Protheus.doc} getBase64Protocol
Obtém o protocolo em base64 a partir de um arquivo, retornando o conteúdo codificado se o arquivo for encontrado.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@return logical, retorna verdadeiro se o protocolo foi encontrado e convertido em base64 com sucesso, falso caso contrário
/*/
method getBase64Protocol() as logical class BeneficiaryProtocolService

	local lSuccess := .F. as logical
	local cDiretory := superGetMV("MV_RELT", .F., "") as character
	local cFileName as character

	if self:validateProtocolExists(self:jPath["idProtocol"], "E001")
		cFileName := PLSR956(BBA->(recno()), .T., cDiretory)[1]

		if file(cDiretory + lower(cFileName))
			self:setAttributeJson({"attribute" : "fileName", "value" : lower(cFileName), "type" : "C"})
            self:setAttributeJson({"attribute" : "file", "value" : self:convertFileToBase64(cDiretory + cFileName), "type" : "C"})                      

			lSuccess := .T.
            self:nCodeStatus := STATUS_CODE_OK
		else
			self:setError("E002",;
					      STR0001,; // "Não foi possível gerar o arquivo do protocolo para download. Tente novamente mais tarde ou entre em contato com o suporte."
					      STR0002,; // "Erro no processamento do arquivo PDF do protocolo na função PLSR956. Verifique se a função está atualizada e funcionando corretamente."
					      STATUS_CODE_BAD_REQUEST)
		endif                     
	endif

return lSuccess

/*/{Protheus.doc} postAttachments
Realiza o processamento e anexação de arquivos a um protocolo, incluindo validações e conversões dos arquivos em base64.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@return logical, retorna verdadeiro se os anexos foram processados e adicionados com sucesso, falso em caso de erro
/*/
method postAttachments() as logical class BeneficiaryProtocolService

	local lSuccess := .T. as logical
	local aFields := {} as array
	local jAttachment as json
	local nCount as numeric
	local nAttachmentSize as numeric
	local aErrorDetails := {} as array
	local aAttachments := {} as array
	local lError := .F. as logical
	local cFileName as character
	local cBase64 as character
	local oModel as object

	aAdd(aFields, {"field": "protocol", "required": .T., "type": "C"})
	aAdd(aFields, {"field": "attachments", "required": .T., "type": "A"})

	if self:checkBodyFields(aFields, "E002")
		if self:validateProtocolExists(self:jBody["protocol"], "E003")
			if BBA->BBA_STATUS == "1" // Pendente de documentação
				aFields := {}
				aAdd(aFields, {"field": "fileName", "required": .T., "type": "C"})
				aAdd(aFields, {"field": "file", "required": .T., "type": "C"})

				nAttachmentSize := len(self:jBody["attachments"])

				for nCount := 1 to nAttachmentSize
					if self:checkBodyFields(aFields, "E005", self:jBody["attachments"][nCount])
						cFileName := self:jBody["attachments"][nCount]["fileName"]
						cBase64 := self:jBody["attachments"][nCount]["file"]

						jAttachment := self:base64ToFile({"fileName": cFileName, "base64": cBase64})

						if jAttachment["sucess"]
							aAdd(aAttachments, {"fileDirectory" : jAttachment["fileDirectory"]})
						else
							lSuccess := .F.
							aAdd(aErrorDetails, {"code" : "E006-400",; // Bad Request
												 "message" : jAttachment["message"],;
												 "detailedMessage" : jAttachment["detailedMessage"]})
						endif
					else	
						lError := .T.
						lSuccess := .F.
						exit
					endif
				next nCount

				if lSuccess
					if BBA->BBA_TIPMAN == PROTOCOL_TYPE_BLOCK
						if self:addknowledgeBank(aAttachments, "BBA", xFilial("BBA") + BBA->BBA_CODSEQ)
							BBA->(recLock("BBA", .F.))
								BBA->BBA_STATUS := PROTOCOL_STATUS_UNDER_REVIEW
							BBA->(msUnLock())

							if self:setProtocolData()
								lSuccess := .T.
								self:nCodeStatus := 201 // Created
							endif
						endif
					else
						oModel := fwLoadModel(iif(BBA->BBA_TIPMAN == PROTOCOL_TYPE_UPDATE, "PLAltBenModel", "PLIncBenModel"))

						oModel:setOperation(MODEL_OPERATION_UPDATE)
						oModel:activate()

						oModel:loadValue("MASTERBBA", "BBA_STATUS", PROTOCOL_STATUS_UNDER_REVIEW)

						if oModel:vldData() .and. self:addknowledgeBank(aAttachments, "BBA", xFilial("BBA") + BBA->BBA_CODSEQ)
							oModel:commitData()

							self:setAttributeJson({"attribute" : "protocol", "value" : BBA->BBA_NROPRO, "type" : "C"})
							self:setAttributeJson({"attribute" : "status", "value" : BBA->BBA_STATUS, "type" : "C"})       

							lSuccess := .T.
							self:nCodeStatus := 201 // Created
						else
							lSuccess := .F.
							lError := .T.
							self:setError("E007",;
											STR0009,; // "Foram encontradas inconsistências no preenchimento do formulário. Verifique os dados enviados no protocolo antes de anexar os documentos." 
											STR0010 + oModel:getErrorMessage()[6],; // "Inconsistências detectadas nos dados do formulário. Favor revisar o protocolo enviado antes de proceder com o envio dos anexos: " 
											STATUS_CODE_BAD_REQUEST)
						endif

						oModel:deActivate()
						oModel:destroy()				
					endif
				endif
			else
				lSuccess := .F.
				lError := .T.
				self:setError("E004",;
						  	  STR0005,; // "Para anexar o protocolo, é necessário que ele esteja com o status 'Pendente de Documentação'. Por favor, verifique e tente novamente." 
						  	  STR0006,; // "A inclusão de anexos no protocolo só é permitida quando o campo 'BBA_STATUS' está preenchido com o valor '1', indicando o status 'pendente de documentação'." 
						  	  STATUS_CODE_BAD_REQUEST)
			endif
		else
			lSuccess := .F.
			lError := .T.
		endif
	else
		lError := .T.
		lSuccess := .F.
	endif

	if !lError .and. len(aErrorDetails)
		self:setError("E006",;
					  STR0007,; // "Não foi possível anexar o documento ao sistema. Por favor, tente novamente mais tarde. Caso o problema persista, entre em contato com o suporte."
					  STR0008,; // "Falha ao realizar a conversão e gravação do arquivo em formato base64 no servidor. Verifique as permissões de gravação ou possíveis inconsistências no formato do arquivo."
					  STATUS_CODE_BAD_REQUEST,;
					  aErrorDetails)
	endif

	fwFreeArray(aFields)
	fwFreeArray(aErrorDetails)
	fwFreeArray(aAttachments)
	freeObj(jAttachment)
	freeObj(oModel)

return lSuccess

/*/{Protheus.doc} getProtocolId
Obtém as informações de um protocolo, incluindo dados do beneficiário, tipo de protocolo e status.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@return logical, retorna verdadeiro se o protocolo foi encontrado e as informações foram obtidas com sucesso, falso caso contrário
/*/
method getProtocolId() class BeneficiaryProtocolService

	local lSuccess := .F. as logical

	if self:validateProtocolExists(self:jPath["idProtocol"], "E001")
		if self:setProtocolData()
			lSuccess := .T.
			self:nCodeStatus := STATUS_CODE_OK
		endif	
	endif

return lSuccess

/*/{Protheus.doc} addBlockProtocol
Adiciona um novo protocolo de bloqueio para um beneficiário
@type method
@version 12.1.2510
@author vinicius.queiros
@since 20/08/2025
@return logical, indica se o protocolo de bloqueio foi adicionado com sucesso
/*/
method addBlockProtocol() as logical class BeneficiaryProtocolService

	local lSuccess := .F. as logical
	local jPendingProtocol as json
	local cLoginUser as character
	local cProtocolCode as character
	local cHealthInsurerCode := plsIntPad() as character
	local aAttachments as array
	local dBlockDate as date
	local lHasAttachments as logical

	jPendingProtocol := hasPendingBlockProtocol(self:jBody["subscriberId"])

	if !jPendingProtocol["hasProtocol"]	
		BA1->(dbSetOrder(2))
		B9G->(dbSetOrder(1))
		BBA->(dbSetOrder(1))

		if BA1->(msSeek(xFilial("BA1") + self:jBody["subscriberId"]))
			dBlockDate := self:convertDateFormat(self:jBody["blockDate"])

			if !PLChHiBlo("BCA", dBlockDate, BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC), BA1->BA1_TIPREG)
				if B9G->(msSeek(xFilial("B9G") + cHealthInsurerCode + self:jBody["reason"]))
					lHasAttachments := self:jBody:hasProperty("attachments") .and. len(self:jBody["attachments"]) > 0

					if lHasAttachments
						aAttachments := self:processAttachedFiles()

						if len(aAttachments) == 0
							// "Não foi possível processar os arquivos anexados. Verifique o formato e tente novamente."
							// "Falha ao processar os anexos: formato inválido ou erro durante a conversão dos arquivos."
							self:setError("", STR0017, STR0018, STATUS_CODE_BAD_REQUEST)
						endif
					endif

					if !lHasAttachments .or. (lHasAttachments .and. len(aAttachments) > 0)
						if self:jBody:hasProperty("loginUser")
							cLoginUser := upper(self:jBody["loginUser"])
						endif

						begin transaction
							cProtocolCode := strTokArr(PLXPR997AB(cLoginUser, PORTAL_COMPANY, cValToChar(BA1->(recno())), self:jBody["reason"], "", ""), "~")[1]
				
							if BBA->(msSeek(xFilial("BBA") + cProtocolCode))
								if lHasAttachments 
									self:addknowledgeBank(aAttachments, "BBA", xFilial("BBA") + BBA->BBA_CODSEQ)
								endif

								PLS977ABPS(BBA->(recno()), self:jBody["reason"], dBlockDate)

								if self:setProtocolData()
									lSuccess := .T.
									self:nCodeStatus := STATUS_CODE_CREATED
								endif		
							endif
						end transaction
					endif		
				else
					// "Não encontramos nenhum motivo contratual de bloqueio. Verifique as informações e tente novamente."
					// "Motivo contratual de bloqueio não localizado na tabela B9G para os parâmetros informados (reason = B9G_COD)."
					self:setError("", STR0015, STR0016, STATUS_CODE_NOT_FOUND)
				endif
			else
				// "O beneficiário encontra-se bloqueado na data informada."
				// "Beneficiário bloqueado na tabela BBA para a data de bloqueio informada."
				self:setError("", STR0019, STR0020, STATUS_CODE_BAD_REQUEST)
			endif
		else
			// "Não encontramos nenhum beneficiário com os dados informados. Verifique as informações e tente novamente."
			// "Beneficiário não localizado na tabela BA1 para o parâmetro informado (subscriberId = BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)."
			self:setError("", STR0013, STR0014, STATUS_CODE_NOT_FOUND)
		endif
	else
		// "Há uma solicitação de exclusão em análise. Aguarde a conclusão do processo. Protocolo: "
		// "Foi encontrado um protocolo de bloqueio (BBA) para o beneficiário informado (BBA_MATRIC) com status não permitido: Pendente, Em análise, Aprovado ou Aprovado Parcialmente (BBA_STATUS)."
		self:setError("", STR0011 + jPendingProtocol["protocol"], STR0012, STATUS_CODE_BAD_REQUEST)
	endif

	freeObj(jPendingProtocol)
	fwFreeArray(aAttachments)

return lSuccess

/*/{Protheus.doc} getBeneficiaries
Obtém a lista de beneficiários relacionados a um protocolo específico, incluindo dados como nome, CPF, status e grau de parentesco.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025 
@param cProtocolCode, character, código do protocolo para consulta dos beneficiários
@return array, retorna um array de objetos JSON contendo os dados dos beneficiários relacionados ao protocolo
/*/
method getBeneficiaries(cProtocolCode as character) as array class BeneficiaryProtocolService

	local aBeneficiaries := {} as array
	local cQuery as character
	local oExecStmt as object
	local nOrder := 1 as numeric
	local cAlias as character
	local jBeneficiary as json

	cQuery := " SELECT ? "
	cQuery += " FROM ? B2N "
	cQuery += " WHERE "
	cQuery += " 	B2N.B2N_FILIAL = ? AND "
	cQuery += " 	B2N.B2N_PROTOC = ? AND "
	cQuery += " 	B2N.D_E_L_E_T_ = ? "

	oExecStmt := FwExecStatement():new(cQuery)

	oExecStmt:setUnsafe(nOrder++, "B2N.B2N_NOMUSR, B2N.B2N_CPFUSR, B2N.B2N_STATUS, B2N.B2N_MATGRF, B2N.B2N_FLGCTR, B2N.B2N_TIPUSU, B2N.B2N_GRAUPA, B2N.B2N_CODMOT, B2N.B2N_DTBLOQ")
	oExecStmt:setUnsafe(nOrder++, retSqlName("B2N"))
	oExecStmt:setString(nOrder++, xFilial("B2N"))
	oExecStmt:setString(nOrder++, cProtocolCode)
	oExecStmt:setString(nOrder++, " ")

	cAlias := oExecStmt:openAlias()

	if !(cAlias)->(eof())
		while !(cAlias)->(eof())
			jBeneficiary := JsonObject():new()

			self:setAttributeJson({"attribute" : "name", "value" : (cAlias)->B2N_NOMUSR, "type" : "C"}, @jBeneficiary)
			self:setAttributeJson({"attribute" : "cpf", "value" : (cAlias)->B2N_CPFUSR, "type" : "C"}, @jBeneficiary)
			self:setAttributeJson({"attribute" : "subscriberId", "value" : iif(BBA->BBA_TIPMAN == PROTOCOL_TYPE_BLOCK, BBA->BBA_MATRIC, (cAlias)->B2N_MATGRF), "type" : "C"}, @jBeneficiary)
			self:setAttributeJson({"attribute" : "type", "value" : (cAlias)->B2N_TIPUSU, "type" : "C"}, @jBeneficiary)
			self:setAttributeJson({"attribute" : "status", "value" : getBeneficiaryStatus((cAlias)->B2N_STATUS, (cAlias)->B2N_FLGCTR), "type" : "C"}, @jBeneficiary)
			self:setAttributeJson({"attribute" : "kinshipCode", "value" : (cAlias)->B2N_GRAUPA, "type" : "C"}, @jBeneficiary)
			self:setAttributeJson({"attribute" : "kinshipDescription", "value" : posicione("BRP", 1, xFilial("BRP") + (cAlias)->B2N_GRAUPA, "BRP_DESCRI"), "type" : "C"}, @jBeneficiary)
			self:setAttributeJson({"attribute" : "reasonBlock", "value" : (cAlias)->B2N_CODMOT, "type" : "C"}, @jBeneficiary)
			self:setAttributeJson({"attribute" : "reasonDescription", "value" : posicione("B9G", 1, xFilial("BRP") + BBA->BBA_CODINT + (cAlias)->B2N_CODMOT, "B9G_MOTIVO"), "type" : "C"}, @jBeneficiary)
			self:setAttributeJson({"attribute" : "blockDate", "value" : stod((cAlias)->B2N_DTBLOQ), "type" : "D"}, @jBeneficiary)                 
			
			aAdd(aBeneficiaries, jBeneficiary)

			freeObj(jBeneficiary)

			(cAlias)->(dbSkip())
		enddo
	endif

	(cAlias)->(dbCloseArea())

	freeObj(oExecStmt)

return aBeneficiaries

/*/{Protheus.doc} getChangedFields
Obtém os campos alterados de um protocolo, incluindo status, rótulo, valor anterior e novo valor de cada campo alterado.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025
@param cProtocolCode, character, código do protocolo para consulta dos campos alterados
@param cStatus, character, status do protocolo utilizado para verificar o estado dos campos alterados
@return array, retorna um array de objetos JSON contendo os campos alterados, com informações sobre o status, rótulo, valor anterior e valor atual dos campos
/*/
method getChangedFields(cProtocolCode as character, cStatus as character) as array class BeneficiaryProtocolService

	local aFields := {} as array
	local cQuery as character
	local oExecStmt as object
	local nOrder := 1 as numeric
	local cAlias as character
	local jField as json
	local oFormStruct as object
	local aFormFields as array

	cQuery := " SELECT ? "
	cQuery += " FROM ? B7L "
	cQuery += " WHERE "
	cQuery += " 	B7L.B7L_FILIAL = ? AND "
	cQuery += " 	B7L.B7L_CHAVE = ? AND "
	cQuery += " 	B7L.B7L_ALIAS = ? AND "
	cQuery += " 	B7L.B7L_ALIACH = ? AND "
	cQuery += " 	B7L.D_E_L_E_T_ = ? "

	oExecStmt := FwExecStatement():new(cQuery)

	oExecStmt:setUnsafe(nOrder++, "B7L.B7L_CAMPO, B7L.B7L_VLANT, B7L.B7L_VLPOS, B7L.B7L_GRAVAD")
	oExecStmt:setUnsafe(nOrder++, retSqlName("B7L"))
	oExecStmt:setString(nOrder++, xFilial("B7L"))
	oExecStmt:setString(nOrder++, cProtocolCode)
	oExecStmt:setString(nOrder++, "BA1")
	oExecStmt:setString(nOrder++, "BBA")
	oExecStmt:setString(nOrder++, " ")

	cAlias := oExecStmt:openAlias()

	if !(cAlias)->(eof())
		oFormStruct := totvs.protheus.health.plan.api.portal.formstruct.BeneficiaryService():new()
		oFormStruct:setFormFields("2") // Alteração
		self:aFormFields := oFormStruct:getFieldsBase("BA1")

		while !(cAlias)->(eof())
			jField := JsonObject():new()

			self:setAttributeJson({"attribute" : "status", "value" : getStatusChangedField((cAlias)->B7L_GRAVAD, cStatus), "type" : "C"}, @jField)
			self:setAttributeJson({"attribute" : "label", "value" : self:getFieldLabel(alltrim((cAlias)->B7L_CAMPO)), "type" : "C"}, @jField)
			self:setAttributeJson({"attribute" : "previousValue", "value" : self:getFieldValue(alltrim((cAlias)->B7L_CAMPO), alltrim((cAlias)->B7L_VLANT)), "type" : "C"}, @jField)
			self:setAttributeJson({"attribute" : "value", "value" : self:getFieldValue(alltrim((cAlias)->B7L_CAMPO), alltrim((cAlias)->B7L_VLPOS)), "type" : "C"}, @jField)

			aAdd(aFields, jField)

			freeObj(jField)

			(cAlias)->(dbSkip())
		enddo

		oFormStruct:destroy()
		freeObj(oFormStruct)
		fwFreeArray(aFormFields)
	endif

	(cAlias)->(dbCloseArea())

	freeObj(oExecStmt)

return aFields

/*/{Protheus.doc} validateProtocolExists
Valida se um protocolo existe no sistema com base no código fornecido, retornando um erro se não encontrado.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025
@param cProtocol, character, código do protocolo a ser validado
@param cErrorCode, character, código de erro utilizado caso o protocolo não seja encontrado
@return logical, retorna .T. se o protocolo existir, .F. caso contrário
/*/
method validateProtocolExists(cProtocol as character, cErrorCode as character) as logical class BeneficiaryProtocolService

	local lExists := .T. as logical

    BBA->(dbSetOrder(4))
    if !BBA->(msSeek(xFilial("BBA") + padr(cProtocol, tamSX3("BBA_NROPRO")[1])))
		lExists = .F.
        self:setError(cErrorCode,;
					  STR0003,; // "O protocolo informado não foi encontrado no sistema. Verifique os dados fornecidos e tente novamente."
					  STR0004,; // "O protocolo informado no parâmetro idProtocolo da requisição não foi localizado na tabela de solicitações do sistema (Tabela BBA), com base no campo BBA_NROPRO."
					  STATUS_CODE_BAD_REQUEST)
    endif

return lExists

/*/{Protheus.doc} getFieldLabel
Retorna o rótulo (label) de um campo baseado no nome do campo fornecido.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025
@param cField, character, nome do campo para o qual o rótulo será retornado
@return character, o rótulo associado ao campo fornecido
/*/
method getFieldLabel(cField as character) as character class BeneficiaryProtocolService

	local cLabel as character
	local nPos as numeric

	if (nPos := aScan(self:aFormFields, {|x| x["property"] == cField})) > 0
		cLabel := self:aFormFields[nPos]["label"]
	endif

return cLabel

/*/{Protheus.doc} getFieldValue
Retorna o valor de um campo com base no nome do campo e valor fornecido. Se o campo tiver opções, o valor é substituído pelo rótulo correspondente à opção selecionada.
@type method
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025
@param cField, character, nome do campo para o qual o valor será retornado
@param cValue, character, valor do campo para a conversão
@return character, valor ou rótulo do campo baseado na opção selecionada
/*/
method getFieldValue(cField as character, cValue as character) as character class BeneficiaryProtocolService

	local nFieldPos as numeric
	local nOptionPos as numeric

	if (nFieldPos := aScan(self:aFormFields, {|x| x["property"] == cField})) > 0
		if self:aFormFields[nFieldPos]:hasProperty("options")
			if (nOptionPos := aScan(self:aFormFields[nFieldPos]["options"], {|x| x["value"] == cValue})) > 0
				cValue := self:aFormFields[nFieldPos]["options"][nOptionPos]["label"]
			endif
		endif
	endif

return cValue

/*/{Protheus.doc} setProtocolData
Define os dados do protocolo no JSON de resposta
@type method
@version 12.1.2510
@author vinicius.queiros
@since 21/08/2025
@return logical, indica se a operação foi realizada com sucesso
/*/
method setProtocolData() as logical class BeneficiaryProtocolService

	self:setAttributeJson({"attribute" : "protocol", "value" : BBA->BBA_NROPRO, "type" : "C"})
	self:setAttributeJson({"attribute" : "status", "value" : BBA->BBA_STATUS, "type" : "C"})
	self:setAttributeJson({"attribute" : "type", "value" : BBA->BBA_TIPMAN, "type" : "C"})
	self:setAttributeJson({"attribute" : "subscriberId", "value" : BBA->BBA_MATRIC, "type" : "C"})
	self:setAttributeJson({"attribute" : "beneficiaryName", "value" : BBA->BBA_EMPBEN, "type" : "C"})
	self:setAttributeJson({"attribute" : "date", "value" : BBA->BBA_DATSOL, "type" : "D"})
	self:setAttributeJson({"attribute" : "time", "value" : BBA->BBA_HORSOL, "type" : "C"})
	self:setAttributeJson({"attribute" : "observation", "value" : BBA->BBA_OBSERV, "type" : "C"})

	do case
		case BBA->BBA_TIPMAN == PROTOCOL_TYPE_INCLUSION .or. BBA->BBA_TIPMAN == PROTOCOL_TYPE_BLOCK
			self:setAttributeJson({"attribute" : "beneficiaries", "value" : self:getBeneficiaries(BBA->BBA_CODSEQ)})

		case BBA->BBA_TIPMAN == PROTOCOL_TYPE_UPDATE
			self:setAttributeJson({"attribute" : "changedFields", "value" : self:getChangedFields(BBA->BBA_CODSEQ, BBA->BBA_STATUS)})
	endcase

return .T.

/*/{Protheus.doc} processAttachedFiles
Converte os arquivos anexados e retorna em formato de array (pronto para adicionar ao banco de conhecimento)
quando não houver erro
@type method
@version 12.1.2510
@author vinicius.queiros
@since 21/08/2025
@return array, arquivos convertidos e prontos para retorno
/*/
method processAttachedFiles() as array class BeneficiaryProtocolService

	local aAttachments := {} as array
	local nAttachmentSize := len(self:jBody["attachments"]) as numeric
	local nCount as numeric
	local jAttachedFile as json
	local cFileName as character
	local cFileBase64 as character

	for nCount := 1 to nAttachmentSize
		if valType(self:jBody["attachments"][nCount]) == "J"
			if self:jBody["attachments"][nCount]:hasProperty("fileName") .and. self:jBody["attachments"][nCount]:hasProperty("file")
				cFileName := self:jBody["attachments"][nCount]["fileName"]
				cFileBase64 := self:jBody["attachments"][nCount]["file"]

				jAttachedFile := self:base64ToFile({"fileName": cFileName, "base64": cFileBase64})

				if jAttachedFile["sucess"]
					aAdd(aAttachments, {"fileDirectory": jAttachedFile["fileDirectory"]})
				else
					aAttachments := {}
					exit
				endif
			endif
		endif
	next nCount

	freeObj(jAttachedFile)

return aAttachments

/*/{Protheus.doc} getBeneficiaryStatus
Retorna o status de um beneficiário com base no status atual e no código adicional de beneficiário fornecido. O status é mapeado conforme as condições específicas.
@type function
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025
@param cStatus, character, status atual do beneficiário
@param cAddBeneficiary, character, código indicando se o beneficiário foi gerado
@return character, novo status do beneficiário conforme as condições especificadas
/*/
static function getBeneficiaryStatus(cStatus as character, cAddBeneficiary as character) as character

	do case
		case cStatus == "1" // Pendente de Documentação
			cStatus := "1"
		
		case cStatus == "2" .or. cAddBeneficiary == "1" // Aprovado
			cStatus := "4"

		case cStatus == "3" // Reprovado
			cStatus := "5"

		case empty(cStatus) // Em Análise
			cStatus := "2"
	endcase

return cStatus

/*/{Protheus.doc} getStatusChangedField
Determina o novo status de um campo alterado, com base no status de aprovação e no status do protocolo.
@type function
@version 12.1.2510  
@author vinicius.queiros
@since 03/02/2025
@param cApproved, character, status de aprovação do campo (T = Aprovado, F = Reprovado)
@param cProtocolStatus, character, status atual do protocolo
@return character, novo status do campo alterado
/*/
static function getStatusChangedField(cApproved as character, cProtocolStatus as character) as character

	local cStatus as character

	do case
		case cApproved == "T" // Aprovado
			cStatus := "4"

		case cProtocolStatus == "1" .or. cProtocolStatus == "2" // Em Análise
			cStatus := "2"

		case cApproved == "F" // Reprovado
			cStatus := "5"
	endcase

return cStatus

/*/{Protheus.doc} hasPendingBlockProtocol
Verifica se o beneficiário possui protocolo de bloqueio pendente (em aberto)
@type function
@version 12.1.2510
@author vinicius.queiros
@since 20/08/2025
@param cSubscriberId, character, identificador do beneficiário
@return json, indica se existe protocolo de bloqueio pendente para o beneficiário
/*/
function hasPendingBlockProtocol(cSubscriberId as character) as json

	local lHasProtocol := .F. as logical
	local cProtocol := "" as character
	local cQuery as character
	local nOrder := 1 as numeric
	local oExecStmt as object
	local cAlias as character

	cQuery := " SELECT ? "
	cQuery += " FROM ? BBA "
	cQuery += " WHERE "
	cQuery += "     BBA.BBA_FILIAL = ? AND "
	cQuery += "     BBA.BBA_MATRIC = ? AND "
	cQuery += "		BBA.BBA_TIPMAN = ? AND "
	cQuery += "		BBA.BBA_STATUS NOT IN (?, ?, ?) AND "
	cQuery += "     BBA.D_E_L_E_T_ = ? "

	oExecStmt := FwExecStatement():new(cQuery)

	oExecStmt:setUnsafe(nOrder++, "BBA_NROPRO")
	oExecStmt:setUnsafe(nOrder++, retSqlName("BBA"))
	oExecStmt:setString(nOrder++, xFilial("BBA"))
	oExecStmt:setString(nOrder++, cSubscriberId)
	oExecStmt:setString(nOrder++, PROTOCOL_TYPE_BLOCK)
	oExecStmt:setString(nOrder++, PROTOCOL_STATUS_PROCESSED)
	oExecStmt:setString(nOrder++, PROTOCOL_STATUS_REJECTED)
	oExecStmt:setString(nOrder++, PROTOCOL_STATUS_AUTO_APPROVED)
	oExecStmt:setString(nOrder++, " ")

	cAlias := oExecStmt:openAlias()

	if !(cAlias)->(eof())
		lHasProtocol := .T.
		cProtocol := alltrim((cAlias)->BBA_NROPRO)
	endif

	(cAlias)->(dbCloseArea())

	oExecStmt:destroy()
	freeObj(oExecStmt)

return {"hasProtocol": lHasProtocol, "protocol": cProtocol}
