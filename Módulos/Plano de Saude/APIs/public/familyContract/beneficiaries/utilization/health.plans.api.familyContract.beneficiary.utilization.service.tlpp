#Include "tlpp-core.th"

Namespace totvs.protheus.health.plans.api.familyContract.beneficiary.utilization

Using Namespace totvs.protheus.health.plans.api.util

/*/{Protheus.doc} UtilizationService
Classe de serviço de Titulos - Regra de Negócio

@type class
@author Cesar Almeida
@since 27/04/2023
@version Protheus 12
/*/
Class UtilizationService From BaseService

    Private Data oService As Object
    Private Data nMaximumData As Numeric

    Public Method new() Constructor
    Public Method getUtilizationStatementBase64() As Logical
    Public Method checkDate() As Logical

EndClass

/*/{Protheus.doc} new
Método construtor da classe

@type method
@author Cesar Almeida
@since 27/04/2023
@version Protheus 12
/*/
Method new() Class UtilizationService

    _Super:new()

    Self:nMaximumData := 180

Return Self

/*/{Protheus.doc} getUtilizationStatementBase64
Método responsavel por retornar o boleto bancário do título em Base 64

@type method
@author Cesar Almeida
@since 27/04/2023
@version Protheus 12
/*/
Method getUtilizationStatementBase64() As Logical Class UtilizationService

    local lSucess := .F. As Logical
    local aFields := {} As Array
    local aRet := {} As Array
    local cDiretory := getNewPar("MV_RELT", "\SPOOL\") As Character
    local lSeekSemester := .f. as Logical
    local aSemester := {} As Array
    local cSemester As Character
    local cYear As Character
    local dDateOf As Date
    local dUntilDate As Date
    local nCopart := 1 As Numeric

    If self:jParams:hasProperty("semester")
        lSeekSemester := .t.
    endif

    if existDir(cDiretory)
        aAdd(aFields, {"field" : "subscriberId", "required" : .T., "type" : "C", "size" : tamSX3("BA1_CODINT")[1]+tamSX3("BA1_CODEMP")[1]+tamSX3("BA1_MATRIC")[1]+tamSX3("BA1_TIPREG")[1]+tamSX3("BA1_DIGITO")[1]})
        
        If Self:checkBodyFields(aFields, "E001",self:jPath) 

            aFields := {} 

            aAdd(aFields, {"field" : "dateOf", "required" : !lSeekSemester, "type" : "D"})
            aAdd(aFields, {"field" : "untilDate", "required" : !lSeekSemester, "type" : "D"})
      
            If Self:checkBodyFields(aFields, "E002",self:jParams)

                if lSeekSemester        
                    aSemester := strToKarr(self:jParams["semester"], "-")

                    if len(aSemester) == 2 .and. aSemester[1] $ "1,2" .and. len(aSemester[2]) == 4 
                        cSemester := aSemester[1]
                        cYear := aSemester[2]

                        if cSemester == "1" // Primeiro semestre
                            dDateOf := stod(cYear+"0101")
                            dUntilDate := lastDay(stod(cYear+"0601"))
                        else // Segundo semestre
                            dDateOf := stod(cYear+"0701")
                            dUntilDate := lastDay(stod(cYear+"1201"))
                        endif

                        self:setAttributeJson({"attribute" : "dateOf", "value" : dDateOf, "type" : "D", "setResponse" : .t.}, self:jParams)
                        self:setAttributeJson({"attribute" : "untilDate", "value" : dUntilDate, "type" : "D", "setResponse" : .t.}, self:jParams)
                    else
                        self:setError("E007", "Formato do parâmetro semester inválido",;
                                              "Deve ser informado o semestrer no formato S-YYYY, onde S é 1 ou 2, e YYYY o ano.",;
                                              406) // Not Acceptable
                        lSucess := .f.
                        return lSucess
                    endif
                endif

                If lSeekSemester .or. !Self:checkDate()
        
                    BA1->(DbSetOrder(2))
                    If BA1->(MsSeek(xFilial("BA1")+Self:jPath["subscriberId"]))

                        self:setAttributeJson({"attribute" : "fileName", "value" : "", "type" : "C"})
                        self:setAttributeJson({"attribute" : "file", "value" : "", "type" : "C"})
                        
                        if Self:jParams:hasProperty("coparticipation")
                            nCopart := Val(Self:jParams["coparticipation"])
                        endif

                        aRet := PLSR022( BA1->BA1_CODINT,BA1->BA1_CODEMP,BA1->BA1_CONEMP,BA1->BA1_SUBCON,'',Self:jPath["subscriberId"],;
                        Self:convertDateFormat(Self:jParams["dateOf"]),Self:convertDateFormat(Self:jParams["untilDate"]),'','','ZZZZ','ZZ', cDiretory, nCopart )

                        If aRet[1] .and. file(cDiretory+lower(aRet[3]))
                            Self:setAttributeJson({"attribute" : "fileName", "value" : Lower(aRet[3]), "type" : "C"})
                            Self:setAttributeJson({"attribute" : "file", "value" : Self:convertFileToBase64(cDiretory+aRet[3]), "type" : "C"})                      
                        EndIf
                        
                        lSucess := .T.
                        Self:nCodeStatus := 200 // Ok
                    Else
                        Self:SetError("E003", "Usuário não encontrado",;
                                            "Não foi possível retornar os dados do beneficiário através da matrícula informada.",;
                                            404) // Not found
                    EndIf

                EndIf 

            EndIf

        EndIf
    else
        self:setError("E006", "Diretório para impressão do relatório não encontrado.",;
                              "Verifique se existe o diretório informado no parâmetro MV_RELT no servidor.",;
                              400) // Bad Request
    endif

Return lSucess

/*/{Protheus.doc} checkDate
Método responsavel por verificar a data informada

@type method
@author Cesar Almeida
@since 28/04/2023
@version Protheus 12
/*/
Method checkDate() As Logical Class UtilizationService

    Local lCheck := .F. As Logical
    Local nDiffDay := 0 As Numeric 
    Local dDateOf := Self:convertDateFormat(Self:jParams["dateOf"]) As Date
    Local dUntilDate := Self:convertDateFormat(Self:jParams["untilDate"]) As Date

    nDiffDay := DateDiffDay(dDateOf, dUntilDate)

    If Year(dDateOf) != Year(dUntilDate)

        lCheck := .T.
        Self:SetError("E004", "Periodo informado não permitido",;
                        "Período permitido somente para o mesmo ano. Ex: De 01/01/2023 a 31/12/2023.",;
                        400)

    ElseIf nDiffDay > Self:nMaximumData

        lCheck := .T.
        Self:SetError("E005", "Intervalo de dias não permitido",;
                        "Permitido somente intervalo de no máximo " + cValToChar(Self:nMaximumData) + " dia(s).",;
                        400)

    EndIf

Return lCheck
