#Include "tlpp-core.th"
#Include "fwmvcdef.ch"

Namespace totvs.protheus.health.plans.api.familyContract.blockProtocol

Using Namespace totvs.protheus.health.plans.api.util

/*/{Protheus.doc} BlockProtocolsService
Classe de serviço de solicitação de cancelamento de planos - Regra de Negócio

@type class
@author Guilherme Carreiro da Silva
@since 01/04/2023
@version Protheus 12
/*/
Class BlockProtocolsService From BaseService

    Private Data cProtocolNumber As Character
    Private Data lRequesterHolder As Logical
    Private Data oAdapter as object

    Public Method new() Constructor
    Public Method postBlockProtocols() As Logical
    public method getBlockProtocols() as logical
    public method getInformation() as logical
    public method getBeneficiaries() as logical
    public method getProtocolBase64() as logical
    public method destroy()

    Private Method checkProtocolRequest() As Logical
    Private Method validBeneficiary(cSubscriberId As Character, lRequester As Logical, cRequesterSubscriberId As Character, aDetailsError As Array) As Logical
    Private Method getProtocol(cSubscriberId As Character) As Array
    Private Method getAllBeneficiaries() As Array
    Private Method addBlockProtocols() As Logical
    Private Method setJsonResponse() As Logical
        
EndClass

/*/{Protheus.doc} new
Método construtor da classe

@type method
@author Guilherme Carreiro da Silva
@since 01/04/2023
@version Protheus 12
/*/
Method new() Class BlockProtocolsService

    _Super:new()

    Self:cProtocolNumber := ""
    Self:lRequesterHolder := .F.

Return Self

/*/{Protheus.doc} postBlockProtocols
Método responsavel por enviar a solicitação de cancelamento de planos

@type method
@author Guilherme Carreiro da Silva
@since 01/04/2023
@version Protheus 12
/*/
Method postBlockProtocols() As Logical Class BlockProtocolsService

    Local lSucess := .F. As Logical
    Local aFields := {} As Array

    // Verifica se os campos do body estão validos
    aAdd(aFields, {"field" : "subscriberId", "required" : .T., "type" : "C", "size" : tamSX3("BA1_CODINT")[1]+tamSX3("BA1_CODEMP")[1]+tamSX3("BA1_MATRIC")[1]+tamSX3("BA1_TIPREG")[1]+tamSX3("BA1_DIGITO")[1]})
    aAdd(aFields, {"field" : "allFamily", "required" : .F., "type" : "L"})
    aAdd(aFields, {"field" : "beneficiaries", "required" : .F., "type" : "A"})

    If Self:checkBodyFields(aFields, "E002")

        If Self:checkProtocolRequest()
            If Self:addBlockProtocols()
                lSucess := .T.
                Self:nCodeStatus := 201 // Create 
            EndIf
        EndIf
    EndIf

    fwFreeArray(aFields) 

Return lSucess

/*/{Protheus.doc} getReasons
Retorna os protocolos de solicitação de cancelamento de planos do beneficiário 
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 03/06/2024
@return logical, se os motivos foram retornados com sucesso
/*/
method getBlockProtocols() as logical class BlockProtocolsService

    local lSuccess := .F. as logical

    self:oAdapter := BlockProtocolsAdapter():new()
    self:oAdapter:setQueryParams(self:jParams)
        
    if self:oAdapter:getBlockProtocolsPages()          
        self:nCodeStatus := 200 // OK
        self:jResult := self:oAdapter:getJsonResult()
        lSuccess := .T.
    endIf

    self:oAdapter:destroy()
           
return lSuccess

/*/{Protheus.doc} getInformation
Retorna as informações sobre as consequências do cancelamento ou exclusão do 
contrato de Plano de Saúde. (artigo 15 )
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 05/07/2024
@return logical, se a inform. foi retornada com sucesso
/*/
method getInformation() as logical class BlockProtocolsService

    local cMessage := "" as character
    local lSuccess := .T. as logical

    if existBlock("PL99BART")
	    cMessage := execBlock("PL99BART", .F., .F., {cMessage})
    else
        cMessage := "I – eventual ingresso em novo plano de saúde poderá importar:<br>" +;
                    "<br>" +;
                    "a) no cumprimento de novos períodos de carência, observado o disposto no inciso V do artigo 12, da Lei nº 9.656, de 1998;<br>" +;
                    "<br>" +;
                    "b) na perda do direito à portabilidade de carências, caso não tenha sido este o motivo do pedido, nos termos previstos na Resolução Normativa nº 438, de 2018 ou norma que vier a sucedê-la, que dispõe, em especial, sobre a regulamentação da portabilidade das carências previstas no inciso V do art. 12 da Lei nº 9.656, de 1998;<br>" +;
                    "<br>" +;
                    "c) no preenchimento de nova declaração de saúde, e, caso haja doença ou lesão preexistente – DLP, no cumprimento de Cobertura Parcial Temporária – CPT, que determina, por um período ininterrupto de até vinte e quatro meses, a partir da data da contratação ou adesão ao novo plano, a suspensão da cobertura de Procedimentos de Alta Complexidade (PAC), leitos de alta tecnologia e procedimentos cirúrgicos;<br>" +;
                    "<br>" +;
                    "d) na perda imediata do direito de remissão, quando houver, devendo o beneficiário arcar com o pagamento de um novo contrato de plano de saúde que venha a contratar;<br>" +;
                    "<br>" +;
                    "II - efeito imediato e caráter irrevogável da solicitação de cancelamento do contrato ou exclusão de beneficiário, a partir da ciência da operadora ou administradora de benefícios;<br>" +;
                    "<br>" +;
                    "III – as contraprestações pecuniárias vencidas e/ou eventuais coparticipações devidas, nos planos em pré-pagamento ou em pós-pagamento, pela utilização de serviços realizados antes da solicitação de cancelamento ou exclusão do plano de saúde são de responsabilidade do beneficiário;<br>" +;
                    "<br>" +;
                    "IV - as despesas decorrentes de eventuais utilizações dos serviços pelos beneficiários após a data de solicitação de cancelamento ou exclusão do plano de saúde, inclusive nos casos de urgência ou emergência, correrão por sua conta;<br>" +;
                    "<br>" +;
                    "V – a exclusão do beneficiário titular do contrato individual ou familiar não extingue o contrato, sendo assegurado aos dependentes já inscritos o direito à manutenção das mesmas condições contratuais, com a assunção das obrigações decorrentes; e<br>" +;
                    "<br>" +;
                    "VI – a exclusão do beneficiário titular do contrato coletivo empresarial ou por adesão observará as disposições contratuais quanto à exclusão ou não dos dependentes, conforme o disposto na Resolução Normativa nº 195, de 2009, que dispõe sobre a classificação e características dos planos privados de assistência à saúde, regulamenta a sua contratação, institui a orientação para contratação de planos privados de assistência à saúde e dá outras providências, ou norma que vier a sucedê-la.<br>"
    endif

    self:setAttributeJson({"attribute" : "message", "value": cMessage, "type" : "C", "setResponse" : .T.})
    self:nCodeStatus := 200 // OK

return lSuccess

/*/{Protheus.doc} getBeneficiaries
Retorna os beneficiários do protocolo
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 08/07/2024
@return logical, se o processo foi executado  com sucesso
/*/
method getBeneficiaries() as logical class BlockProtocolsService

    local lSuccess := .F. as logical
    local aKeys := {} as array

    aAdd(aKeys, {"type" : "pathParams", "key" : "protocol"})
 
    if self:checkRequiredKeys(aKeys, "E001")
        self:oAdapter := BlockProtocolsAdapter():new()
        self:oAdapter:setPathParams(self:jPath)
            
        if self:oAdapter:getBeneficiariesPages()          
            self:nCodeStatus := 200 // OK
            self:jResult := self:oAdapter:getJsonResult()
            lSuccess := .T.
        endIf

        self:oAdapter:destroy()
    endif

    fwFreeArray(aKeys)
           
return lSuccess

/*/{Protheus.doc} getProtocolBase64
Retorna a impressão em base 64 (PDF) do protocolo de cancelamento
@type method
@version 12.1.2410  
@author vinicius.queiros
@since 08/07/2024
@return logical, se o processo foi executado  com sucesso
/*/
method getProtocolBase64() as logical class BlockProtocolsService

    local lSuccess := .F. as logical
    local aKeys := {} as array
    local cFileName as character
    local cDiretory := PlsMudSis(getWebDir() + getSkinPls() + "\relatorios\") as character

    aAdd(aKeys, {"type" : "pathParams", "key" : "protocol"})
 
    if self:checkRequiredKeys(aKeys, "E001")
        if existBlock("PL99BSol")
            B5J->(dbSetOrder(2))
            if B5J->(msSeek(xFilial("B5J") + self:jPath["protocol"]))
                PL99BRelat(.F., nil, .F., "S", .F., .T., @cFileName)

                if !empty(cFileName) .and. file(cDiretory + cFileName)
                    self:setAttributeJson({"attribute" : "fileName", "value" : lower(cFileName), "type" : "C"})
                    self:setAttributeJson({"attribute" : "file", "value" : self:convertFileToBase64(cDiretory + cFileName), "type" : "C"})                  
                    
                    lSuccess := .T.
                    self:nCodeStatus := 200 // Ok
                endif
            else
                self:setError("E002",;
                            "Protocolo de cancelamento de plano não encontrado.",;
                            "Não foi localizado nenhum protocolo através do número informado na tabela B5J (campo B5J_PROTOC).",;
                            404) // Not found
            endif
        else
            self:setError("E003",;
                          "Comprovante do protocolo de cancelamento não disponível, entre em contato com a operadora de saúde.",;
                          "Rdmake PL99BSol para impressão do comprovante do protocolo de cancelamento não compilado no ambiente.",;
                          400) // Bad request
        endif
    endif

    fwFreeArray(aKeys)
           
return lSuccess

/*/{Protheus.doc} destroy
Limpa da memória as variáveis (objeto, array e json) da clase
@type method
@version 12.1.2410
@author vinicius.queiros
@since 18/06/2024
/*/
method destroy() class BlockProtocolsService

    _Super:destroy()

    freeObj(self:oAdapter)

return

/*/{Protheus.doc} checkProtocolRequest
Método responsavel por checkar as informações recebidas no json.

@type method
@author Guilherme Carreiro da Silva
@since 01/04/2023
@version Protheus 12
/*/
Method checkProtocolRequest() As Logical Class BlockProtocolsService

    Local lCheck := .F. As Logical
    Local aFields := {} As Array
    Local aDetailsError := {} As Array
    Local nX := 0 As Numeric

    If Self:validBeneficiary(Self:jBody["subscriberId"], .T., nil, @aDetailsError)

        If Self:jBody["allFamily"] .And. Self:lRequesterHolder
                Self:jBody["beneficiaries"] := aClone(Self:getAllBeneficiaries())
        EndIf

        If Len(Self:jBody["beneficiaries"]) > 0

            aAdd(aFields, {"field" : "subscriberId", "required" : .T., "type" : "C", "size" : tamSX3("BA1_CODINT")[1]+tamSX3("BA1_CODEMP")[1]+tamSX3("BA1_MATRIC")[1]+tamSX3("BA1_TIPREG")[1]+tamSX3("BA1_DIGITO")[1]})

            For nX := 1 To Len(Self:jBody["beneficiaries"])

                If Self:checkBodyFields(aFields, "E005."+cValToChar(nX), Self:jBody["beneficiaries"][nX], @aDetailsError, .F.)

                    Self:validBeneficiary(Self:jBody["beneficiaries"][nX]["subscriberId"], .F., Self:jBody["subscriberId"], @aDetailsError)

                EndIf

            Next nX

        EndIf

    EndIf

    If Len(aDetailsError) > 0
         Self:setError("E006", "Erro ao incluir solicitação de cancelamento de planos.",;
                              "Verifique a lista de erros para mais detalhes",;
                              400,; // Bad Request
                              aDetailsError)
    Else
        lCheck := .T.
    EndIf

Return lCheck

//-------------------------------------------------------------------
/*/{Protheus.doc} getAllBeneficiaries
Retorna todos os beneficiários da familia, quando o solicitante for o
titular e o atributo do json 'allFamily' estiver com true

@author Guilherme Carreiro da Silva
@version Protheus 12
@since 01/04/2023
/*/
//------------------------------------------------------------------
Method getAllBeneficiaries() As Array Class BlockProtocolsService

    Local cAliasTemp := GetNextAlias() As Character
    Local cHealthInsurerCode := Substr(Self:jBody["subscriberId"],1,4) As Character
    Local cCompanyCode := Substr(Self:jBody["subscriberId"],5,4) As Character
    Local cSubscriberId := Substr(Self:jBody["subscriberId"],9,6) As Character
    Local aBlockBeneficiaries := {} As Array
    
    BeginSQL Alias cAliasTemp
        SELECT BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG, BA1_DIGITO FROM %Table:BA1% BA1
          WHERE BA1_FILIAL = %XFilial:BA1% 
            AND BA1_CODINT = %exp:cHealthInsurerCode% 
            AND BA1_CODEMP = %exp:cCompanyCode% 
            AND BA1_MATRIC = %exp:cSubscriberId% 
            AND BA1_MOTBLO = ''
            AND BA1.%notDel%
    EndSQL

    While !(cAliasTemp)->(EoF())

        aAdd(aBlockBeneficiaries, {"subscriberId": (cAliasTemp)->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)})

        (cAliasTemp)->(DbSkip())
    EndDo

    (cAliasTemp)->(DbCloseArea())

Return aBlockBeneficiaries

/*/{Protheus.doc} addBlockProtocols
Método responsavel por adicionar as solicitações de
cancelamento de planos.

@type method
@author Guilherme Carreiro da Silva
@since 01/04/2023
@version Protheus 12
/*/
Method addBlockProtocols() As Logical Class BlockProtocolsService

    Local oModel := nil As Object
    Local oModelB5J := nil As Object
    Local oModelB5K := nil As Object
    Local nX := 0 As Numeric
    Local cCodigo As Character
    Local lAdd := .F. As Logical

    oModel := FwLoadModel("PLSA99B") 
    oModelB5J := oModel:getModel("B5JMASTER")
    oModelB5K := oModel:getModel("B5KDETAIL")

    oModel:setOperation(MODEL_OPERATION_INSERT)
    oModel:Activate()
    
    cCodigo := GetSX8Num("B5J","B5J_CODIGO")    
    
    oModel:setValue( 'B5JMASTER', 'B5J_FILIAL', xFilial("B5J") )
    oModel:setValue( 'B5JMASTER', 'B5J_CODIGO', cCodigo )
    
    oModel:setValue( 'B5JMASTER', 'B5J_MATSOL', Self:jBody["subscriberId"] )
    oModel:setValue( 'B5JMASTER', 'B5J_DATSOL', dDataBase )
    oModel:setValue( 'B5JMASTER', 'B5J_STATUS', "0" )
    oModel:setValue( 'B5JMASTER', 'B5J_ORISOL', "3" )
    oModel:setValue( 'B5JMASTER', 'B5J_PROTOC', P773GerPro())

    if self:jBody:hasProperty("email") .and. !empty(self:jBody["email"])
        oModel:setValue('B5JMASTER', 'B5J_EMAIL', self:jBody["email"])
    else
        B49->(DbSetOrder(2))//B49_FILIAL+B49_BENEFI
        If B49->(MsSeek(xFilial("B49")+Self:jBody["subscriberId"]))   
            BSW->(DbSetOrder(5))//BSW_FILIAL+BSW_CODUSR
            If BSW->(MsSeek(xFilial("BSW")+B49->B49_CODUSR))
                oModel:setValue( 'B5JMASTER', 'B5J_EMAIL', Alltrim(BSW->BSW_EMAIL) )
            Endif
        EndIf
    endif

    For nX := 1 To Len(Self:jBody["beneficiaries"])
        If nX > 1
            oModelB5K:addLine(.T.)
        EndIf

        oModelB5K:setValue("B5K_MATUSU", Self:jBody["beneficiaries"][nX]["subscriberId"])
    Next nX
    
    If oModel:vldData()
        
        oModel:commitData()

        Self:cProtocolNumber := oModelB5J:GetValue("B5J_PROTOC")
                    
        lAdd := Self:setJsonResponse()
    Else
        Self:setError("E007", AllTrim(oModel:getErrorMessage()[6]),;
                            "Id do campo de erro: "+AllTrim(oModel:getErrorMessage()[4])+"; Id do erro: "+AllTrim(oModel:getErrorMessage()[5]),;
                            400) // Bad Request
    EndIf

    oModel:deActivate()
	oModel:destroy()

	FreeObj(oModel)
	oModel := Nil
    
    FreeObj(oModelB5J)
	oModelB5J := Nil

    FreeObj(oModelB5K)
	oModelB5K := Nil

    If ExistBlock("PL99GRVSOL")
        BA1->(DbSetOrder(2)) 
        For nX := 1 To Len(Self:jBody["beneficiaries"])
            If BA1->(MsSeek(xFilial("BA1")+Self:jBody["beneficiaries"][nX]["subscriberId"]))
                // Ponto de Entrada para manipulação da solicitação de cancelamento de beneficiario                                                     
                ExecBlock("PL99GRVSOL", .F., .F., {BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO), ""})
            EndIf
        Next nX
    EndIf
Return lAdd

/*/{Protheus.doc} setJsonResponse
Método responsavel por setar o json de resposta das solicitações de
cancelamento de planos.

@type method
@author Guilherme Carreiro da Silva
@since 01/04/2023
@version Protheus 12
/*/
Method setJsonResponse() As Logical Class BlockProtocolsService

    Local lOk := .F. As Logical
    Local nPos := 0 As Numeric
    Local aBeneficiaries := {} As Array
    
    B5J->(DbSetOrder(2))
    If B5J->(MsSeek(xFilial("B5J")+Self:cProtocolNumber))
        lOk := .T.
        Self:setAttributeJson({"attribute" : "protocol", "value": B5J->B5J_PROTOC, "type" : "C", "setResponse" : .T.})
        Self:setAttributeJson({"attribute" : "subscriberId", "value": B5J->B5J_MATSOL, "type" : "C", "setResponse" : .T.})
        Self:setAttributeJson({"attribute" : "requester", "value": Posicione("BA1", 2, xFilial("BA1")+B5J->B5J_MATSOL, "BA1_NOMUSR"), "type" : "C", "setResponse" : .T.})
        Self:setAttributeJson({"attribute" : "requestDate", "value": B5J->B5J_DATSOL, "type" : "D", "setResponse" : .T.})
        Self:setAttributeJson({"attribute" : "requestTime", "value": B5J->B5J_HORSOL, "type" : "C", "setResponse" : .T.})
        Self:setAttributeJson({"attribute" : "email", "value": B5J->B5J_EMAIL, "type" : "C", "setResponse" : .T.})

        Self:setAttributeJson({"attribute" : "beneficiaries", "value": aBeneficiaries, "type" : "A"})

        B5K->(DbSetOrder(1))
        If B5K->(MsSeek(xFilial("B5K")+B5J->B5J_CODIGO))

            While !B5K->(Eof()) .AND. B5K->(B5K_FILIAL+B5K_CODIGO)==xFilial("B5J")+B5J->B5J_CODIGO

                BA1->(DbSetOrder(2))

                If BA1->(MsSeek(xFilial("BA1")+B5K->B5K_MATUSU))

                    aAdd(Self:jResult["beneficiaries"], JsonObject():new())
                        nPos := Len(Self:jResult["beneficiaries"])

                    Self:setAttributeJson({"attribute" : "subscriberId", "value" : B5K->B5K_MATUSU, "type" : "C", "setResponse" : .T.}, Self:jResult["beneficiaries"][nPos])
                    Self:setAttributeJson({"attribute" : "name", "value" : BA1->BA1_NOMUSR, "type" : "C", "setResponse" : .T.}, Self:jResult["beneficiaries"][nPos])
                    Self:setAttributeJson({"attribute" : "beneficiaryCPF", "value" : BA1->BA1_CPFUSR, "type" : "C", "setResponse" : .T.}, Self:jResult["beneficiaries"][nPos])

                EndIf

                B5K->(dbSkip())

            EndDo
        EndIf
    EndIf

Return lOk

//-------------------------------------------------------------------
/*/{Protheus.doc} validBeneficiary
Valida os dados de cada beneficiário solicitado para bloqueio

@author Guilherme Carreiro da Silva
@version Protheus 12
@since 01/04/2023
/*/
//------------------------------------------------------------------
Method validBeneficiary(cSubscriberId As Character, lRequester As Logical, cRequesterSubscriberId As Character, aDetailsError As Array) As Logical Class BlockProtocolsService

    Local cHolderType := GetNewPar("MV_PLCDTIT", "T") As Character
    Local lValid := .F. As Logical
    Local lHldAct := .F. As Logical
    Local lBenefDesm := .F. As Logical

    Default lRequester := .F.
    Default cRequesterSubscriberId := ""

    BA1->(DbSetOrder(2))
    If BA1->(MsSeek(xFilial("BA1")+cSubscriberId))

        If lRequester .And. BA1->BA1_TIPUSU == cHolderType
            Self:lRequesterHolder := .T.
        EndIf

        If BA1->BA1_TIPUSU <> cHolderType
            if PLIsFamHldAct(substr(cSubscriberId, 1, 4), substr(cSubscriberId, 5, 4), substr(cSubscriberId, 9, 6))
		    	lHldAct := .T.
		    else
		        BA3->(DbSetOrder(1))
		        if BA3->(msSeek(xFilial("BA3")+substr(cSubscriberId, 1, 14))) .and. !empty(BA3->BA3_GRPFAM)
		    	    if PLIsFamHldAct(substr(BA3->BA3_GRPFAM, 1, 4), substr(BA3->BA3_GRPFAM, 5, 4), substr(BA3->BA3_GRPFAM, 9, 6))
		    		    lBenefDesm := .T.
		    	    endif
                endif
		    endif
        endif

        BA3->(DbSetOrder(1))
		BA3->(MsSeek(xFilial("BA3")+Substr(cSubscriberId, 1,14)))

        Do Case
            Case !Self:jBody:hasProperty("allFamily") .And. !Self:jBody:hasProperty("beneficiaries")
                aAdd(aDetailsError, {"code" : "E003A-406",;
                                     "message" : "Não foi informado nenhum beneficiário para solicitação de bloqueio",;
                                     "detailedMessage" : "Enviar a requisição preenchendo o campo 'Allfamily' ou informando os beneficiários em 'beneficiaries'"})
            
            Case  lRequester .And. lHldAct
                  aAdd(aDetailsError, {"code" : "E003B-400",;
                                     "message" : "Beneficiário dependente "+cSubscriberId+" possui um titular ativo na família.",;
                                     "detailedMessage" : "Somente o Titular pode realizar o cancelamento desse dependente"})
            Case  lRequester .And. lBenefDesm
                  aAdd(aDetailsError, {"code" : "E003B-400",;
                                     "message" : "Beneficiário dependente "+cSubscriberId+" possui um titular responsável ativo.",;
                                     "detailedMessage" : "Somente o Titular responsável pode realizar o cancelamento desse dependente"})
            Case  lRequester .And. !Self:lRequesterHolder .And. BA1->BA1_RESFAM == '0'
                  aAdd(aDetailsError, {"code" : "E003B-400",;
                                     "message" : "Beneficiário dependente "+cSubscriberId+" deve ser responsável da família sem a presença do Titular para realizar a solicitação.",;
                                     "detailedMessage" : "Beneficiário deve ser o responsável da família através do campo BA1_RESFAM"})

            Case lRequester .And. BA1->BA1_TIPUSU <> cHolderType .And.;
                     (Len(Self:jBody["beneficiaries"]) > 1 .Or. Self:jBody["allFamily"] .Or. Self:jBody["beneficiaries"][1]["subscriberId"] <> cSubscriberId)
                aAdd(aDetailsError, {"code" : "E003C-400",;
                                     "message" : "Beneficiário dependente "+cSubscriberId+" só pode realizar a solicitação para ele mesmo.",;
                                     "detailedMessage" : "Informado o atributo 'beneficiaries' no body da requisição."})
                
            Case !Empty(BA1->BA1_MOTBLO)
                aAdd(aDetailsError, {"code" : "E003D-400",;
                                     "message" : "Beneficiário "+cSubscriberId+" já está bloqueado.",;
                                     "detailedMessage" : "Campo BA1_MOTBLO do beneficiário já preenchido."})

            Case !lRequester .and. len(Self:getProtocol(cSubscriberId)) > 0
                aAdd(aDetailsError, {"code" : "E003E-409",;
                                     "message" : "Beneficiário(a) " + alltrim(BA1->BA1_NOMUSR) + " já tem uma solicitação de cancelamento de plano pendente.",;
                                     "detailedMessage" : "Beneficiário com solicitação pendente na tabela B5J com o B5J_STATUS igual a 0."})

            Case !lRequester .And. (Substr(cSubscriberId, 1, 14) <> Substr(cRequesterSubscriberId, 1, 14)) .or.;
                     (!empty(BA3->BA3_GRPFAM) .and. substr(BA3->BA3_GRPFAM,1,14) <> substr(cSubscriberId,1,14))
                aAdd(aDetailsError, {"code" : "E003F-400",;
                                     "message" : "Beneficiário "+cSubscriberId+" solicitado é de uma família diferente do solicitante.",;
                                     "detailedMessage" : "Campos BA1_CODINT, BA1_CODEMP, BA1_MATRIC diferente dos beneficiarios."})

            Case !Self:jBody["allFamily"] .And. (!Self:jBody:hasProperty("beneficiaries") .Or. Len(Self:jBody["beneficiaries"]) == 0)
                aAdd(aDetailsError, {"code" : "E003G-406",;
                                     "message" : "Não foi informado nenhum beneficiário para solicitação de bloqueio",;
                                     "detailedMessage" : "Enviar a requisição preenchendo o campo 'Allfamily' ou informando os beneficiários em 'beneficiaries'"})
            
            OtherWise
                lValid := .T.
        EndCase
    Else
        aAdd(aDetailsError, {"code" : "E004-404",;
                                "message" : "Matrícula "+cSubscriberId+" não foi encontrada",;
                                "detailedMessage" : "Matricula não encontrada na tabela BA1 pela chave: "+"BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG, BA1_DIGITO"})
    EndIf

Return lValid

//-------------------------------------------------------------------
/*/{Protheus.doc} getProtocol
Retorna o protocolo de solicitação de bloqueio do beneficiário

@author Guilherme Carreiro da Silva
@version Protheus 12
@since 01/04/2023
/*/
//------------------------------------------------------------------
Method getProtocol(cSubscriberId As Character) As Array Class BlockProtocolsService

    Local cAliasTemp := GetNextAlias() As Character
    Local aData := {} As Array

    Default cSubscriberId := ""


    BeginSQL Alias cAliasTemp
        SELECT B5J.B5J_STATUS, B5J.B5J_DATSOL, B5J.B5J_HORSOL, B5J.B5J_ORISOL, B5J.B5J_PROTOC FROM %Table:B5K% B5K 
            INNER JOIN  %Table:B5J% B5J 
             ON B5J.B5J_FILIAL = %XFilial:B5J% 
            AND B5J.B5J_CODIGO = B5K.B5K_CODIGO
            AND B5J.%notDel%

          WHERE B5K.B5K_FILIAL = %XFilial:B5K% 
            AND B5K.B5K_MATUSU = %exp:cSubscriberId% 
            AND B5K.%notDel%
    EndSQL

    While !(cAliasTemp)->(EoF())

        If (cAliasTemp)->B5J_STATUS == "0"

            aAdd(aData, {"requestDate": (cAliasTemp)->B5J_DATSOL, "requestOrigin": (cAliasTemp)->B5J_ORISOL,;
                         "status": (cAliasTemp)->B5J_STATUS, "protocol": (cAliasTemp)->B5J_PROTOC})

        EndIf

        (cAliasTemp)->(DbSkip())
    EndDo

    (cAliasTemp)->(DbCloseArea())

Return aData
