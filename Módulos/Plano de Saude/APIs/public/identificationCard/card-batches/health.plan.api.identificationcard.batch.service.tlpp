#include "tlpp-core.th"
#include "fwmvcdef.ch"
#include "health.plan.api.identificationcard.batch.service.ch"

#define STATUS_CODE_OK 200
#define STATUS_CODE_ACCEPTED 202
#define STATUS_CODE_NO_CONTENT 204
#define STATUS_CODE_BAD_REQUEST 400
#define STATUS_CODE_NOT_FOUND 404

#define SELECT_NO "0" // Não
#define SELECT_YES "1" // Sim

#define GEN_TYPE_FILE "1" // Arquivo
#define GEN_TYPE_PRINT "2" // Impressão

#define BATCH_STATUS_OPEN "1" // Em aberto
#define BATCH_STATUS_CLOSED "2" // Encerrado
#define BATCH_STATUS_STATUS_BLOCKED  "3" // Bloqueado
#define BATCH_STATUS_STATUS_PARTIALLY_BLOCKED   "4" // Bloqueio Parcial
#define BATCH_STATUS_PROCESSING  "5" // Em Processamento
#define BATCH_STATUS_INVALID  "6" // Inválido

namespace totvs.protheus.health.plan.identificationcard.batch

using namespace totvs.protheus.health.plans.api.util

/*/{Protheus.doc} CardBatchService
Classe de serviço responsável pela regra de negócio relacionada aos lotes de cartão.
@type class
@version 12.1.2510
@autor vinicius.queiros
@since 01/08/2025
/*/
class CardBatchService from BaseService

	private data cBatchCode as character

	public method new() constructor
	public method destroy()

	public method addCardBatch() as logical
	public method getCardBatches() as logical
	public method getCardBatchBeneficiaries() as logical
	public method getBatchCode() as character
	public method getCardBatchCriticisms() as logical

	private method hasBeneficiariesToProcess() as logical
	private method getCardBatchQueryCount() as character
	private method setCardBatchData() as logical
	private method getKnowledgeBankFile() as logical

endclass

/*/{Protheus.doc} new
Construtor da classe CardBatchService.
@type method
@version 12.1.2510
@author vinicius.queiros
@since 01/08/2025
@return self, instancia da classe CardBatchService.
*/
method new() class CardBatchService

	_Super:new()

return self

/*/{Protheus.doc} destroy
Libera os recursos utilizados pela classe CardBatchService ao final do processamento
@type method
@version 12.1.2510
@autor vinicius.queiros
@since 01/08/2025
/*/
method destroy() class CardBatchService

	_Super:destroy()

return

/*/{Protheus.doc} addCardBatch
Realiza a inclusão de um novo lote de cartão com base nos parâmetros informados.
@type method
@version 12.1.2510
@autor vinicius.queiros
@since 01/08/2025
@return logical, Indica se o lote foi incluído com sucesso
/*/
method addCardBatch() as logical class CardBatchService

	local lOk := .F. as logical

	if self:hasBeneficiariesToProcess()
		regToMemory("BDE", .T.)

		if self:setCardBatchData()
			self:cBatchCode := M->BDE_CODIGO

			BDE->(PLUPTENC("BDE", MODEL_OPERATION_INSERT))

			startJob("totvs.protheus.health.plan.identificationcard.batch.startCardBatchJob", getEnvServer(), .F., cEmpAnt, cFilAnt, self:jBody["healthInsurerCode"], self:cBatchCode)

			self:nCodeStatus := STATUS_CODE_ACCEPTED
			self:setAttributeJson({"attribute": "batchCode", "value": self:cBatchCode, "type": "C"})
			lOk := .T.
		endif

		confirmSX8()
	else
		self:nCodeStatus := STATUS_CODE_NO_CONTENT
	endif

return lOk

/*/{Protheus.doc} getCardBatches
Executa a lógica de negócio para buscar os lotes de cartões
@type method
@version 12.1.2510
@author vinicius.queiros
@since 05/08/2025
@return logical, indica se os dados dos lotes de cartões foram obtidos com sucesso
/*/
method getCardBatches() as logical class CardBatchService

	local oAdapter as object
	local lSuccess := .F. as logical

	oAdapter := CardBatchAdapter():new()
	oAdapter:setQueryParams(self:jParams)

	lSuccess := oAdapter:getCardBatches()

	if lSuccess
		self:nCodeStatus := STATUS_CODE_OK
		self:jResult := oAdapter:getJsonResult()
	endIf

	oAdapter:destroy()
	freeObj(oAdapter)

return lSuccess

/*/{Protheus.doc} getCardBatchBeneficiaries
Executa a lógica de negócio para buscar os beneficiários vinculados a um lote de cartões
@type method
@version 12.1.2510
@author vinicius.queiros
@since 05/08/2025
@return logical, indica se os dados dos beneficiários foram obtidos com sucesso
/*/
method getCardBatchBeneficiaries() as logical class CardBatchService

	local oAdapter as object
	local lSuccess := .F. as logical

	BDE->(dbSetOrder(1))
	if BDE->(msSeek(xFilial("BED") + plsIntPad() + self:jPath["batchCode"]))
		oAdapter := CardBatchAdapter():new()
		oAdapter:setPathParams(self:jPath)
		oAdapter:setQueryParams(self:jParams)

		lSuccess := oAdapter:getBatchBeneficiaries()

		if lSuccess
			self:nCodeStatus := STATUS_CODE_OK
			self:jResult := oAdapter:getJsonResult()
		endIf

		oAdapter:destroy()
	else
		// "O lote informado não foi encontrado. Verifique o código e tente novamente."
		// "Lote de cartões com o código informado não localizado na tabela BDE (campo BDE_CODIGO)."
		self:setError("", STR0001, STR0002, STATUS_CODE_NOT_FOUND)
	endif

	freeObj(oAdapter)

return lSuccess

/*/{Protheus.doc} getBatchCode
Retorna o código do lote de cartão gerado após a inclusão, permitindo sua identificação nas operações subsequentes.
@type method
@version 12.1.2510
@autor vinicius.queiros
@since 01/08/2025
@return character, Código do lote de cartão gerado
/*/
method getBatchCode() as character class CardBatchService

return self:cBatchCode

/*/{Protheus.doc} getCardBatchCriticisms
Obtém as críticas relacionadas a um lote específico de cartões, gerando um arquivo XLS em base64.
@type method
@version 12.1.2510
@author vinicius.queiros
@since 01/10/2025
@return logical, verdadeiro caso o processamento das críticas seja concluído com sucesso
/*/
method getCardBatchCriticisms() as logical class CardBatchService

	local lSuccess := .F. as logical

	BDE->(dbSetOrder(1))
	if BDE->(msSeek(xFilial("BDE") + plsIntPad() + self:jPath["batchCode"]))
		if BDE->BDE_QTCRIT > 0
			if self:getKnowledgeBankFile()
				Self:nCodeStatus := STATUS_CODE_OK
			endif
		else
			// "Não foram encontradas críticas para o lote informado."
			// "O campo BDE_QTCRIT está com valor igual a 0, indicando ausência de críticas registradas para o lote."
			self:setError("", STR0003, STR0004, STATUS_CODE_BAD_REQUEST)
		endif
	else
		// "O lote informado não foi encontrado. Verifique o código e tente novamente."
		// "Lote de cartões com o código informado não localizado na tabela BDE (campo BDE_CODIGO)."
		self:setError("", STR0001, STR0002, STATUS_CODE_NOT_FOUND)
	endif

return lSuccess

/*/{Protheus.doc} hasBeneficiariesToProcess
Verifica se existem beneficiários válidos para processamento no lote de cartão, com base nos parâmetros definidos.
@type method
@version 12.1.2510
@autor vinicius.queiros
@since 01/08/2025
@return logical, Indica se há beneficiários disponíveis para processamento
/*/
method hasBeneficiariesToProcess() as logical class CardBatchService

	local oStatement as object
	local cQuery := self:getCardBatchQueryCount() as character
	local nTotal as numeric

	oStatement := FwExecStatement():new(cQuery)

	nTotal := oStatement:execScalar("TOTAL")

	oStatement:destroy()
	freeObj(oStatement)

return nTotal > 0

/*/{Protheus.doc} getCardBatchQueryCount
Retorna a query SQL responsável por contar a quantidade de beneficiários no lote de cartão, de acordo com os filtros aplicados.
@type method
@version 12.1.2510
@autor vinicius.queiros
@since 01/08/2025
@return character, Instrução SQL para contagem de beneficiários no lote
/*/
method getCardBatchQueryCount() as character class CardBatchService

	local cCountQuery as character
	local cFieldsQuery as character
	local cWhereQuery as character
	local aResultPE as array

	cCountQuery := " SELECT "
	cCountQuery += "    COUNT(BA1_NOMUSR) TOTAL "
	cCountQuery += " FROM " + retSQLName("BA1") + " BA1, " + retSQLName("BA3") + " BA3, " + retSQLName("BTS") + " BTS "

	cFieldsQuery := " SELECT "
	cFieldsQuery := "   BA1.R_E_C_N_O_ BA1REG, BA3.R_E_C_N_O_ BA3REG, BA1_DATNAS, BA1_DATINC, BA1_DTVLCR, BA1_DTVLCR, "
	cFieldsQuery += "   BA1_CODINT, BA1_CONEMP, BA1_VERCON, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG, BA1_DIGITO, BA1_TIPUSU, "
	cFieldsQuery += "   BA1_NOMUSR, BA1_DATCAR, BA1_VIACAR, BA1_OPERES, BA1_SEXO, BA3_CODPLA, BA3_VERSAO, BA3_CODINT, "
	cFieldsQuery += "   BA3_CODEMP, BA3_SUBCON, BA3_VERSUB, BA3_VERCON, BA3_TIPCON, BA3_TIPOUS, BA3_CONEMP, BTS_NOMCAR,"
	cFieldsQuery += "   BA1_TIPUSU, BA1_MATVID, BTS_NOMUSR, BTS_NRCRNA, BTS_NOMSOC "

	cFieldsQuery += " FROM " + retSQLName("BA1") + " BA1, " + retSQLName("BA3") + " BA3, " + retSQLName("BTS")+ " BTS "

	cWhereQuery := " WHERE "
	cWhereQuery += "    BA1.BA1_FILIAL = '" + xFilial("BA1") + "' AND "
	cWhereQuery += "    BA3.BA3_FILIAL = '" + xFilial("BA3") + "' AND "
	cWhereQuery += "    BTS.BTS_FILIAL = '" + xFilial("BTS") + "' AND "
	cWhereQuery += "    BA1.BA1_CODINT = '" + self:jBody["healthInsurerCode"] + "' AND "
	cWhereQuery += "    BA1.BA1_CODEMP BETWEEN '" + self:jBody["companyCode"] + "' AND '" + self:jBody["companyCode"] + "' AND "
	cWhereQuery += "    BA1.BA1_CONEMP BETWEEN '" + self:jBody["contractCode"] + "' AND '" + self:jBody["contractCode"] + "' AND "
	cWhereQuery += "    BA1.BA1_SUBCON BETWEEN '" + self:jBody["subcontractCode"] + "' AND '" + self:jBody["subcontractCode"] + "' AND "
	cWhereQuery += "    CONCAT(BA1.BA1_MATRIC, BA1.BA1_TIPREG) BETWEEN '" + substr(self:jBody["subscriberIdFrom"], 9, 8) + "' AND '" + substr(self:jBody["subscriberIdTo"], 9, 8) + "' AND "

	if self:jBody:hasProperty("validityPeriod") .and. !empty(self:jBody["validityPeriod"]["start"]) .and. !empty(self:jBody["validityPeriod"]["end"])
		cWhereQuery += " BA1.BA1_DTVLCR BETWEEN '" + dtos(self:jBody["validityPeriod"]["start"]) + "' AND '" + dtos(self:jBody["validityPeriod"]["end"]) + "' AND "
	endif

	if self:jBody["reason"] == getNewPar("MV_PLSMP1V", "4")
		cWhereQuery += " BA1.BA1_VIACAR = 0 AND "
	else
		cWhereQuery += " BA1.BA1_VIACAR <> 0 AND "
	endif

	cWhereQuery += " BA3.BA3_TIPOUS = '" + self:jBody["groupType"] + "' AND "

	BPX->(dbSetOrder(1))
	if BPX->(msSeek(xFilial("BPX") + self:jBody["healthInsurerCode"] + self:jBody["reason"])) .and. BPX->BPX_TIPEMI == "2"
		cWhereQuery += " (BA1.BA1_EMICAR = '1' OR BA1.BA1_EMICAR = '2') AND "
	else
		cWhereQuery += " BA1.BA1_EMICAR <> '0' AND "
	endif

	cWhereQuery += " BA3.BA3_CODINT = BA1.BA1_CODINT AND "
	cWhereQuery += " BA3.BA3_CODEMP = BA1.BA1_CODEMP AND "
	cWhereQuery += " BA3.BA3_MATRIC = BA1.BA1_MATRIC AND "
	cWhereQuery += " BTS.BTS_MATVID = BA1.BA1_MATVID AND "
	cWhereQuery += " BA1.D_E_L_E_T_ = ' ' AND BA3.D_E_L_E_T_ = ' ' AND BTS.D_E_L_E_T_ = ' ' "

	if existBlock("PL264QRY")
		aResultPE := execBlock("PL264QRY", .F., .F.,{cCountQuery, cFieldsQuery, cWhereQuery})

		if len(aResultPE) > 0
			cCountQuery := aResultPE[1]
			cFieldsQuery := aResultPE[2]
			cWhereQuery := aResultPE[3]
		endif
	endif

	fwFreeArray(aResultPE)

return (cCountQuery + cWhereQuery)

/*/{Protheus.doc} setCardBatchData
Armazena os dados do lote de cartão em memória para uso nas etapas seguintes do processamento, com base nos parâmetros recebidos.
@type method
@version 12.1.2510
@autor vinicius.queiros
@since 01/08/2025
@return logical, Indica se os dados foram armazenados com sucesso
/*/
method setCardBatchData() as logical class CardBatchService

	local lOk := .F. as logical

	if !empty(M->BDE_CODIGO)
		M->BDE_CODINT := self:jBody["healthInsurerCode"]
		M->BDE_MOTIVO := self:jBody["reason"]
		M->BDE_TIPGRU := self:jBody["groupType"]
		M->BDE_EMPDE := self:jBody["companyCode"]
		M->BDE_EMPATE := self:jBody["companyCode"]
		M->BDE_CONDE := self:jBody["contractCode"]
		M->BDE_CONATE := self:jBody["contractCode"]
		M->BDE_SUBDE := self:jBody["subcontractCode"]
		M->BDE_SUBATE := self:jBody["subcontractCode"]

		if self:jBody:hasProperty("subscriberIdFrom") .and. !empty(self:jBody["subscriberIdFrom"])
			M->BDE_MATDE := substr(self:jBody["subscriberIdFrom"], 9, 8)
		endif

		if self:jBody:hasProperty("subscriberIdTo") .and. !empty(self:jBody["subscriberIdTo"])
			M->BDE_MATATE := substr(self:jBody["subscriberIdTo"], 9, 8)
		else
			M->BDE_MATATE := replicate("Z", tamSX3("BDE_MATATE")[1])
		endif

		M->BDE_DIRGRV := getNewPar("MV_RELT", "\spool\")
		M->BDE_STACAR := BATCH_STATUS_PROCESSING

		if self:jBody:hasProperty("validityPeriod") .and. !empty(self:jBody["validityPeriod"]["start"])
			M->BDE_DATA1 := self:jBody["validityPeriod"]["start"]
		endif

		if self:jBody:hasProperty("validityPeriod") .and. !empty(self:jBody["validityPeriod"]["end"])
			M->BDE_DATA2 := self:jBody["validityPeriod"]["end"]
		endif

		if self:jBody:hasProperty("changeValidity")
			M->BDE_MUDVAL := iif(self:jBody["changeValidity"], SELECT_YES, SELECT_NO)
		endif

		if self:jBody:hasProperty("newValidityDate") .and. !empty(self:jBody["newValidityDate"])
			M->BDE_DATVAL := self:convertDateFormat(self:jBody["newValidityDate"])
		endif

		M->BDE_TIPGER := GEN_TYPE_FILE
		M->BDE_PROTOC := getSxENum("BDE", "BDE_PROTOC")

		if self:jParams:hasProperty("loginUser")
			M->BDE_EMPRES := alltrim(substr(upper(self:jParams["loginUser"]), 1, tamSX3("BDE_EMPRES")[1]))
		endif

		lOk := .T.
	endif

return lOk

/*/{Protheus.doc} getKnowledgeBankFile
Obtém o arquivo de críticas do lote no banco de conhecimento
@type method
@version 12.1.2510
@author vinicius.queiros
@since 01/10/2025
@return logical, indica se o arquivo foi obtido com sucesso
/*/
method getKnowledgeBankFile() as logical class CardBatchService

	local lSuccess := .F. as logical
	local oExecStmt as object
	local cQuery as character
	local nOrder := 1 as numeric
	local cAlias as character
	local cFile as character
	local cFileDir as character

	cQuery := " SELECT ? "
	cQuery += " FROM ? AC9 "
	cQuery += " INNER JOIN ? ACB ON "
	cQuery += "		ACB.ACB_FILIAL = ? AND "
	cQuery += "		ACB.ACB_CODOBJ = AC9.AC9_CODOBJ AND "
	cQuery += "		ACB.D_E_L_E_T_ = ? "
	cQuery += " WHERE "
	cQuery += " 	AC9.AC9_FILIAL = ? AND "
	cQuery += " 	AC9.AC9_ENTIDA = ? AND "
	cQuery += " 	AC9.AC9_FILENT = ? AND "
	cQuery += " 	AC9.AC9_CODENT = ? AND "
	cQuery += " 	AC9.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY AC9_CODOBJ DESC"

	oExecStmt := FwExecStatement():new(cQuery)

	oExecStmt:setUnsafe(nOrder++, "ACB.ACB_OBJETO")
	oExecStmt:setUnsafe(nOrder++, retSqlName("AC9"))
	oExecStmt:setUnsafe(nOrder++, retSqlName("ACB"))
	oExecStmt:setString(nOrder++, xFilial("ACB"))
	oExecStmt:setString(nOrder++, " ")
	oExecStmt:setString(nOrder++, xFilial("AC9"))
	oExecStmt:setString(nOrder++, "BDE")
	oExecStmt:setString(nOrder++, xFilial("BDE"))
	oExecStmt:setString(nOrder++, xFilial("BDE") + BDE->(BDE_CODINT + BDE_CODIGO))
	oExecStmt:setString(nOrder++, " ")

	cAlias := oExecStmt:openAlias()

	if !(cAlias)->(eof())
		cFile := alltrim((cAlias)->ACB_OBJETO)
		cFileDir := iif(msMultDir(), msRetPath(cFile), msDocPath()) + "/" + cFile

		if file(cFileDir)
			self:setAttributeJson({"attribute" : "fileName", "value" : lower(cFile), "type" : "C"})
			self:setAttributeJson({"attribute" : "file", "value" : self:convertFileToBase64(cFileDir), "type" : "C"})

			lSuccess := .T.
		else
			// O arquivo de críticas não pôde ser acessado.
			// O arquivo cadastrado no banco de conhecimento não foi localizado no diretório configurado.
			self:setError("", STR0007, STR0008, STATUS_CODE_NOT_FOUND)
		endif
	else
		// "O arquivo de críticas do lote não está disponível."
		// "Não foram encontrados registros relacionados ao lote nas tabelas AC9 e ACB do banco de conhecimento."
		self:setError("", STR0005, STR0006, STATUS_CODE_NOT_FOUND)
	endif

	(cAlias)->(dbCloseArea())

	oExecStmt:destroy()
	freeObj(oExecStmt)

return lSuccess
