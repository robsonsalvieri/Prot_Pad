#include "tlpp-core.th"
#include "backoffice.apportionmentfromto.data.ch"

namespace totvs.protheus.backoffice.ApportionmentFromTo
using namespace totvs.protheus.backoffice.reconciliation.util

//-------------------------------------------------------------------
/*/{Protheus.doc} ApportionmentPromToProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class ApportionmentFromToProtheusData from FWAdapterBaseV2

    Public method new()
    Public method getAll()
    Public method setApportionmentFromTo()
    Public method procApportionmentFromTo()
    Public method deleteApportionmentFromTo()
    static method getData() As object


endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} ApportionmentFromToProtheusData
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class ApportionmentFromToProtheusData
    Default cVerbo := "GET"
    Default lList  := .T.
    _Super:New(cVerbo, lList)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} ApportionmentFromToProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class ApportionmentFromToProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := ApportionmentFromToProtheusData():new()
    EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca das configuracoes do De Para

@author Totvs
/*/
//-------------------------------------------------------------------
method getAll(nPage as Numeric, nPageSize as Numeric, cId as character) class ApportionmentFromToProtheusData
    Local aArea  := GetArea() As Array
    Local cWhere := GetBranchiesForConditional("QLL") As Character
    Default nPage     := 1
    Default nPageSize := 10
    Default cId := ""

    addMapFields(self)

    ::setPage(nPage)
    ::setPageSize(nPageSize)

    If !Empty(cId)
        cWhere += " AND QLL.QLL_CODIGO = '"+Padr(cId, TamSx3("QLL_CODIGO")[1])+"'"
        ::SetQuery(getQueryId())
    else
        cWhere += " AND QLL.QLL_SEQ = '0001' "
        ::SetQuery(getQuery())
    EndIf

    cWhere += " AND QLL.D_E_L_E_T_ = ' ' "

    ::SetWhere(cWhere)
    ::SetOrder("QLL.QLL_FILIAL, QLL.QLL_CODIGO, QLL.QLL_SEQ ")

    If ::Execute()
        ::FillGetResponse()
    EndIf

    RestArea(aArea)
    FwFreeArray(aArea)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} addMapFields
Realiza o mapeamento dos campos que serão retornados

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function addMapFields(oSelf as Object)
    Local nTamField := TamSx3("QLL_FILIAL")[1] + TamSx3("QLL_CODIGO")[1] As Numeric
    Local cField    := "" as character
    Local cValue    := "" as character
    Local cConcat   := tcRetConcat()+"'|'"+tcRetConcat() as character
    Local nI        := 0 as numeric
    Local aAllFields:= FWSX3Util():GetAllFields("QLL", .F.) as array
    Local aFieldSX3 := {} as Array
    Local aStruct   := {} as Array
    Local cTitulo   := "" as character

    For nI := 1 To Len(aAllFields)
        cField  := aAllFields[nI]
        aStruct := FWSX3Util():GetFieldStruct(cField, .F.)

        cTitulo := AllTrim(FWX3Titulo(cField))
        aAdd(aFieldSX3,{GetSx3Cache(cField, "X3_ORDEM"),;
                        AllTrim(Lower(cField)),;
                        AllTrim(If(Empty(cTitulo), Lower(cField), cTitulo)),;
                        aStruct[2],;
                        aStruct[3],;
                        aStruct[4],;
                        AllTrim(X3Picture(cField)),""})
    Next

    oSelf:addMapFields("value", "value", .T., .F., {"value", "C", nTamField, 0}, "'"+cEmpAnt+"'"+cConcat+"RTRIM(QLL_FILIAL)"+;
                      cConcat+"QLL_CODIGO")

    For nI := 1 To Len(aFieldSX3)
        cField := Upper(aFieldSX3[nI][2])
        
        If cField == "QLL_EVERAT"
            cValue := "CASE WHEN QLL_EVERAT = '1' THEN 'true' ELSE 'false' END"                    
        Else
            cValue := cField
        EndIf

        oSelf:addMapFields(cField, cField, .T., .F., {cField, aFieldSX3[nI][4], aFieldSX3[nI][5], aFieldSX3[nI][6]}, cValue)
    Next nI

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getQuery() As Character
    Local cQuery As Character

    cQuery := " SELECT #QueryFields# "
    cQuery += " FROM " + RetSqlName("QLL") + " QLL "
    cQuery += " WHERE #QueryWhere# "

Return cQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} getQueryId
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getQueryId() As Character
    Local cQuery As Character

    cQuery := " SELECT DISTINCT #QueryFields#"
    cQuery += " FROM " + RetSqlName("QLL") + " QLL "
    cQuery += " WHERE #QueryWhere#"

Return cQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} setApportionmentFromTo
Insere ou Altera uma novo registro na QLL

@author Totvs
/*/
//-------------------------------------------------------------------
method setApportionmentFromTo( oJBody as json, nOpcAuto as numeric) class ApportionmentFromToProtheusData
	Local cCod      as character
	Local oJsRes    as json
    Local lResult   as Logical
	Local cResult   as character
    Local cFil      as character
    Local aResult   as array
    Local nX        as Numeric
    Local yX        as Numeric
    Local yC        as Numeric

    cFil    := fwxFilial("QLL")
    cCod 	:= " "
	oJsRes	:= JsonObject():new()
    lResult := .T.
    cResult	:= ""
    aResult := {}
    nX      := 0
    yX      := 0
    yC      := 0

	dbSelectArea("QLL")
	QLL->(dbSetOrder(1))

    If nOpcAuto = 5

       cCod := oJBody["items"][1]["qll_codigo"]
       If QLL->(dbSeek( fwxFilial("QLL") + cCod))
            While !QLL->(EOF()) .AND. QLL->QLL_CODIGO = cCod
                  RecLock("QLL", .F.)
                  QLL->(dbDelete())
                  QLL->(msUnlock())
                  QLL->(dbSkip())
            EndDo
            cResult := STR0001 //"Exclusão realizada com sucesso"
            oJsRes["result"]  := cResult
            oRest:setStatusCode ( 200 )
        else
            cResult := STR0002 //"Não haviam registros para exclusão"
            oJsRes["result"]  := cResult
            oRest:setStatusCode ( 200 )
        EndIF
        QLL->(dbCloseArea())

        aAdd(aResult, .T.)
        aAdd(aResult, cResult)

    ElseIf nOpcAuto = 3 .OR. nOpcAuto = 4

        For yX := 1 to Len(oJBody["items"])
            cCod := oJBody["items"][yX]["qll_codigo"]
            while QLL->(dbSeek(fwxFilial("QLL") + cCod)) .AND. !Empty(cCod)
                RecLock("QLL", .F.)
                QLL->(dbDelete())
                QLL->(msUnlock())
            endDo
            cCod := ""
        Next yX

        For nX := 1 to Len(oJBody["items"])

            if Empty(oJBody["items"][nX]["qll_codigo"]) .AND. Empty(cCod)
                cCod := GetSXENum('QLL', 'QLL_CODIGO')
                QLL->(ConfirmSx8())
            elseIf Empty(cCod)
                cCod := oJBody["items"][nX]["qll_codigo"]
            EndIf
            RecLock("QLL", .T.)

            QLL->QLL_FILIAL	:= cFil
            QLL->QLL_CODIGO	:= cCod
            QLL->QLL_TIPO 	:= oJBody["items"][nX]["qll_tipo"]
            QLL->QLL_SEQ 	:= Subs(StrZero(nX),-4,4)
            QLL->QLL_DESCRI	:= DecodeUTF8(oJBody["items"][nX]["qll_descri"])
            QLL->QLL_ENTORI := oJBody["items"][nX]["qll_entori"]
            QLL->QLL_TAMORI := oJBody["items"][nX]["qll_tamori"]
            QLL->QLL_ENTDES := oJBody["items"][nX]["qll_entdes"]
            QLL->QLL_TAMDES	:= oJBody["items"][nX]["qll_tamdes"]
            QLL->QLL_SELORI := oJBody["items"][nX]["qll_selori"]
            QLL->QLL_SELDES := oJBody["items"][nX]["qll_seldes"]
            QLL->QLL_POSORI := oJBody["items"][nX]["qll_posori"]
            QLL->QLL_VALORI := oJBody["items"][nX]["qll_valori"]
            QLL->QLL_POSDES := oJBody["items"][nX]["qll_posdes"]
            QLL->QLL_VALDES := oJBody["items"][nX]["qll_valdes"]
            QLL->QLL_EVERAT := IIF(AllTrim(oJBody["items"][nX]["qll_everat"]) == "true", "1", "2")
            QLL->(msUnlock())
        Next nX

    EndIf

    oJsRes["result"] 	:= cCod

    QLL->(dbCloseArea())

    oRest:setStatusCode ( 200 )

    aAdd(aResult, .T.)
    aAdd(aResult, cCod )

return aResult
