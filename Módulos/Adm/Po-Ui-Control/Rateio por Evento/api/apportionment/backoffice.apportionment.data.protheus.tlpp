#include "tlpp-core.th"
#include "backoffice.apportionment.data.protheus.ch"

namespace totvs.protheus.backoffice.apportionment
using namespace totvs.protheus.backoffice.reconciliation.util

//-------------------------------------------------------------------
/*/{Protheus.doc} ApportionmentProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class ApportionmentProtheusData from FWAdapterBaseV2
    private Data aHeaderCTQ as array
    private Data aItemsCTQ  as array

    Public method new()
    Public method getAll()
    Public method setApportionments()
    Public method updateEvent()

    Private method procApportionments()
    private method sortFieldsByX3Seq(cTipo as character, aArr as array )
    private method setStructCTQ()    
    private method insertCTQ()
    private method deleteCTQbyEvent()

    static method getData() As object    
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} ApportionmentProtheusData
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class ApportionmentProtheusData
    Default cVerbo := "GET"
    Default lList  := .T.
    _Super:New(cVerbo, lList)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} ApportionmentProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class ApportionmentProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := ApportionmentProtheusData():new()
    EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca das configuracoes do Rateio

@author Totvs
/*/
//-------------------------------------------------------------------
method getAll(  nPage as Numeric, nPageSize as Numeric, lHeader as logical, ;
                cId as character, cSearchValue as character) class ApportionmentProtheusData
    Local aArea  := GetArea() As Array
    Local cWhere := GetBranchiesForConditional("CTQ") As Character
    local cRatP := "" as character
    local cDscP := "" as character
    Default nPage     := 1
    Default nPageSize := 10
    Default lHeader   := .F.
    Default cId       := ""
    Default cSearchValue := ""

    If lHeader
        addMapFieldsHeadder(self)
    Else
        addMapFields(self)
    EndIf
    ::setUseSpaces(.T.)
    ::setPage(nPage)
    ::setPageSize(nPageSize)
    ::SetQuery(getQuery())

    If lHeader
        cWhere += " AND CTQ.CTQ_SEQUEN = '001' "
    EndIf
    If !Empty(cId)
        cWhere += " AND CTQ.CTQ_RATEIO = '"+Padr(cId, TamSx3("CTQ_RATEIO")[1])+"'"
    EndIf
    If !Empty(cSearchValue)
        cRatP := allTrim(Padr(cSearchValue, TamSx3("CTQ_RATEIO")[1]))
        cDscP := allTrim(Padr(cSearchValue, TamSx3("CTQ_DESC")[1]))
        cWhere += " AND (CTQ.CTQ_RATEIO LIKE '%" + cRatP  + "%' OR CTQ.CTQ_DESC LIKE '%" + cDscP + "%' ) "
    EndIf

    cWhere += " AND CTQ.D_E_L_E_T_ = ' '"

    ::SetWhere(cWhere)
    ::SetOrder("CTQ.CTQ_FILIAL, CTQ.CTQ_RATEIO, CTQ.CTQ_SEQUEN")

    If ::Execute()
        ::FillGetResponse()
    EndIf

    RestArea(aArea)
    FwFreeArray(aArea)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} addMapFields
Realiza o mapeamento dos campos que serão retornados

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function addMapFields(oSelf as Object)
    Local nTamField := TamSx3("CTQ_FILIAL")[1] + TamSx3("CTQ_RATEIO")[1] As Numeric
    Local cField    := "" as character
    Local cConcat   := tcRetConcat()+"'|'"+tcRetConcat() as character
    Local nI        := 0 as numeric
    Local aAllFields:= FWSX3Util():GetAllFields("CTQ", .F.) as array
    Local aFieldSX3 := {} as Array
    Local aStruct   := {} as Array
    Local cTitulo   := "" as character

    For nI := 1 To Len(aAllFields)
        cField  := aAllFields[nI]
        aStruct := FWSX3Util():GetFieldStruct(cField, .F.)

        cTitulo := AllTrim(FWX3Titulo(cField))
        aAdd(aFieldSX3,{GetSx3Cache(cField, "X3_ORDEM"),;
                        AllTrim(Lower(cField)),;
                        AllTrim(If(Empty(cTitulo), Lower(cField), cTitulo)),;
                        aStruct[2],;
                        aStruct[3],;
                        aStruct[4],;
                        AllTrim(X3Picture(cField)),""})
    Next

    oSelf:addMapFields("value", "value", .T., .F., {"value", "C", nTamField, 0}, "'"+cEmpAnt+"'"+cConcat+"RTRIM(CTQ_FILIAL)"+;
                      cConcat+"CTQ_RATEIO")

    For nI := 1 To Len(aFieldSX3)
        cField := Upper(aFieldSX3[nI][2])
        oSelf:addMapFields(cField, cField, .T., .F., {cField, aFieldSX3[nI][4], aFieldSX3[nI][5], aFieldSX3[nI][6]}, cField)
    Next nI

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getQuery() As Character
    Local cQuery As Character

    cQuery := " SELECT #QueryFields#"
    cQuery += " FROM " + RetSqlName("CTQ") + " CTQ "
    cQuery += " WHERE #QueryWhere#"
Return cQuery

/*/{Protheus.doc} setApportionments
Metodo responsavel pela gravacao dos Cadastros de Rateio

@author Totvs
/*/
method setApportionments(jBody as Json, nOpcaAuto as numeric) class ApportionmentProtheusData
    Local aResponse := {} as Array
    Local lContinue := .T. as Logical
    Local cResponse := "" as Character
    Local nOpcExec  := 0 as Numeric
    Local nI := 0 as Numeric    

    For nI := 1 to Len(jBody["rules"])  
        //A variável nOpcExec é manipulada dentro dos métodos, por isso sempre restauro com o que veio da chamada
        
        nOpcExec := nOpcaAuto    
        lContinue := ::setStructCTQ(jBody["rules"][nI], @nOpcExec, @cResponse)    
        
        //Somente para teste, depois precisamos 
        If lContinue
            lContinue := ::procApportionments(::aHeaderCTQ, ::aItemsCTQ, nOpcExec, @cResponse)            
        EndIf
        
        If !lContinue
            Exit
        EndIf
    Next nI   

    aAdd(aResponse, lContinue)
    aAdd(aResponse, cResponse)
return aResponse

/*/{Protheus.doc} procApportionments
Metodo responsavel pela execucao do ExecAuto do Cadastro de Rateios

@author Totvs
/*/
method procApportionments(aHeader as array, aItems as array, nOpcAuto as numeric,;
                            cResponse as character) class ApportionmentProtheusData
    Local lContinue := .T. as logical
    Local nI        := 0   as numeric
    Local nPosCode  := 0   as numeric
    Local aErroAuto := {}  as array

    Private lMsErroAuto	   := .F. as logical
    Private lMsHelpAuto    := .T. as logical
    Private lAutoErrNoFile := .T. as logical

    If Len(aHeader) > 0 .And. (Len(aItems) > 0 .Or. nOpcAuto == 5)
        Begin TRANSACTION
            //Se for alteração, apago primeiro

            If nOpcAuto == 4                
                MSExecAuto({|x, y, z| CTBA270(x, y, z)}, aHeader, aItems, 5)
                lContinue := !lMsErroAuto
                //Ja exclui, agora preciso incluir novamente
                nOpcAuto := 3               
            EndIf

            If lContinue 
                MSExecAuto({|x, y, z| CTBA270(x, y, z)}, aHeader, aItems, nOpcAuto)

                If lMsErroAuto
                    DisarmTransaction()
                    aErroAuto := GetAutoGRLog()
                    For nI := 1 To Len(aErroAuto)
                        cResponse += aErroAuto[nI]+"|"
                        cResponse := StrTran(cResponse, CHR(13)+CHR(10), "") //Remove quebra de linha
                    Next nI
                    lContinue := .F.
                Else
                    nPosCode := aScan(aHeader, {|x| AllTrim(Upper(x[1])) == "CTQ_RATEIO"})
                    If nPosCode > 0
                        cResponse := aHeader[nPosCode][2]
                    EndIf
                    If nOpcAuto == 3
                        CTQ->(ConfirmSx8())
                    EndIf
                    lContinue := .T.
                EndIf
            EndIf

        End Transaction
    Else
        cResponse := STR0001 //"Informações de rateio não encontrados"
        lContinue := .F.
    EndIf
return lContinue


Static Function addMapFieldsHeadder(oSelf as Object)

    oSelf:addMapFields("CTQ_FILIAL", "CTQ_FILIAL", .T., .F., {"CTQ_FILIAL", "C", TamSx3("CTQ_FILIAL")[1], 0}, "CTQ.CTQ_FILIAL")
    oSelf:addMapFields("CTQ_RATEIO", "CTQ_RATEIO", .T., .F., {"CTQ_RATEIO", "C", TamSx3("CTQ_RATEIO")[1], 0}, "CTQ.CTQ_RATEIO")
    oSelf:addMapFields("CTQ_DESC", "CTQ_DESC", .T., .F., {"CTQ_DESC", "C", TamSx3("CTQ_DESC")[1], 0}, "CTQ.CTQ_DESC")
    oSelf:addMapFields("CTQ_TIPO", "CTQ_TIPO", .T., .F., {"CTQ_TIPO", "C", TamSx3("CTQ_TIPO")[1], 0}, "CTQ.CTQ_TIPO")
    oSelf:addMapFields("CTQ_MSBLQL", "CTQ_MSBLQL", .T., .F., {"CTQ_MSBLQL", "C", TamSx3("CTQ_MSBLQL")[1], 0}, "CTQ.CTQ_MSBLQL")

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} setStructCTQ
Alimenta arrays de header e itens para Cadastro de Rateio - CTQ

@author Totvs
/*/
//-------------------------------------------------------------------
method setStructCTQ(jBody as Json, nOpcAuto as numeric, cResponse as Character) class ApportionmentProtheusData
    Local nI        := 0  as numeric
    Local nX        := 0  as numeric
    Local nPosRat   := 0  as numeric
    Local cfield    := "" as character    
    Local cCodRat   := "" as character
    Local cFilArq   := "" as Character
    Local aFields   := {} as array
    Local aItemsAux := {} as array
    Local lContinue := .T. as Logical
    Local xValue                                                                                                                               
    
    ::aHeaderCTQ := {}
    ::aItemsCTQ := {}
    
    //Armazena header      
    aFields := jBody["header"]:GetNames()                                   
    For nI := 1 To Len(aFields)
        If ("FILIAL" $ Upper(aFields[nI]))
            cFilArq := jBody["header"][aFields[nI]]
        Else
            cField := AllTrim(Upper(aFields[nI]))
            xValue := jBody["header"][aFields[nI]]
                        
            aAdd(::aHeaderCTQ, {cField,;
                                xValue,; 
                                Nil})

            If nOpcAuto == 4 .And. "RATEIO" $ cField
                cCodRat := xValue               
            EndIf
        EndIf
    Next nI

    If !Empty(cFilArq) .And. cFilAnt <> cFilArq         
        If FWFilExist(cEmpAnt,cFilArq)
            RPCClearEnv()
            RpcSetType(3)
            RpcSetEnv(cEmpAnt, cFilArq,,,'CTB')
        Else
            cResponse := STR0002 + ' "'+cFilArq+'" ' + STR0003 //"A filial" //enviada no arquivo não existe na base de dados.
            lContinue := .F.
        EndIf
    EndIf

    If lContinue
        //Se alteracao e codigo do rateio nao enviado ou nao encontrado, realiza inclusao
        If nOpcAuto == 4
            CTQ->(dbSetOrder(1)) //ctq_filial+ctq_rateio+ctq_sequen  
            If Empty(cCodRat) .Or. !CTQ->(dbSeek(xFilial("CTQ")+cCodRat))                        
                nOpcAuto := 3                   
            EndIf
        EndIf

        If nOpcAuto == 3 //Busca numero do Rateio para inclusao                
            nPosRat := aScan(::aHeaderCTQ, {|x| AllTrim(Upper(x[1])) == "CTQ_RATEIO"})
            If nPosRat > 0 .and. Empty(::aHeaderCTQ[nPosRat][2])
                ::aHeaderCTQ[nPosRat][2] := GetSxeNum("CTQ", "CTQ_RATEIO") 
            EndIf
        EndIf                        
        
        //Armazena itens
        For nI := 1 To Len(jBody["items"])
            aFields := jBody["items"][nI]:GetNames()            
            aItemsAux := {}                         
            For nX := 1 To Len(aFields)
                If !("FILIAL" $ Upper(aFields[nI]))
                    aAdd(aItemsAux, {AllTrim(Upper(aFields[nX])),; 
                                        jBody["items"][nI][aFields[nX]],;
                                        Nil})
                EndIf
            Next nX
            aAdd(::aItemsCTQ, aItemsAux)
        Next nI
    EndIf

return lContinue

/*/{Protheus.doc} updateEvent
Metodo responsavel por atualizar os Eventos

@author Totvs
/*/
method updateEvent(jBody as Json) class ApportionmentProtheusData
    Local aResponse := {} as Array
    Local lContinue := .T. as Logical
    Local cResponse := "" as Character
    Local cFilArq   := "" as Character
    Local cCodEve   := "" as Character
    Local nI        := 0 as Numeric
    Local nTamFil   := FwSizeFilial() as Numeric
    Local nTamEve   := TamSX3("CTQ_EVERAT")[1] as Numeric

    //Primeiro deleto os rateios vinculados ao Evento
    For nI := 1 to Len(jBody["rules"])  
        
        cFilArq := PadR(jBody["rules"][nI]["header"]["ctq_filial"],nTamFil)
        cCodEve := PadR(jBody["rules"][nI]["header"]["ctq_everat"],nTamEve)
        
        ::deleteCTQbyEvent(cFilArq, cCodEve, @cResponse)

    Next nI   

    //Se tudo deu certo, incluo os novos rateios baseados no evento
    If lContinue
        lContinue := ::insertCTQ(jBody, @cResponse)    
    EndIf      

    aAdd(aResponse, lContinue)
    aAdd(aResponse, cResponse)
return aResponse

//-------------------------------------------------------------------
/*/{Protheus.doc} setStructCTQ
Faz a inclusão da CTQ utilizando a classe FWBULK
@author Totvs
/*/
//-------------------------------------------------------------------
method insertCTQ(jBody as Json, cResponse as Character) class ApportionmentProtheusData
    Local oBulk   := FWBulk():new(RetSqlName("CTQ")) as Object
    Local lRet    := .T. as Logical
    Local aFields := {} as Array
    Local aItems  := {} as Array
    Local nI      := 0 as Numeric
    Local nJ      := 0 as Numeric
    Local nTamSeq := TamSX3("CTQ_SEQUEN")[1] as Numeric
    Local nTamEve := TamSX3("CTQ_EVERAT")[1] as Numeric
    Local nTamFil := FwSizeFilial() as Numeric
    Local cFilArq := "" as Character
    Local cCodEve := "" as Character
    Local cCodReg := "" as Character
    Local cCodRat := "" as Character
    Local cDescRt := "" as Character
    Local cTipoRr := "" as Character
    Local cPerBas := "" as Character
    Local cMSBLQL := "" as Character
    Local cStatus := "" as Character
    Local cFilIns := "" as Character
    Local cResponseAux := "" as Character

    cResponseAux    := cResponse
    cResponse       := STR0006 //"Erro ao incluir rateio"

    aAdd(aFields, {"CTQ_FILIAL"})    
    aAdd(aFields, {"CTQ_RATEIO"})
    aAdd(aFields, {"CTQ_DESC"})  
    aAdd(aFields, {"CTQ_TIPO"})  
    aAdd(aFields, {"CTQ_PERBAS"})
    aAdd(aFields, {"CTQ_SEQUEN"})

    //Origem
    aAdd(aFields, {"CTQ_CTORI"})
    aAdd(aFields, {"CTQ_CCORI"})
    aAdd(aFields, {"CTQ_ITORI"})
    aAdd(aFields, {"CTQ_CLORI"})
    
    //Partida
    aAdd(aFields, {"CTQ_CTPAR"})
    aAdd(aFields, {"CTQ_CCPAR"})
    aAdd(aFields, {"CTQ_ITPAR"})
    aAdd(aFields, {"CTQ_CLPAR"})
    
    //C.Partida
    aAdd(aFields, {"CTQ_CTCPAR"})
    aAdd(aFields, {"CTQ_CCCPAR"})
    aAdd(aFields, {"CTQ_ITCPAR"})
    aAdd(aFields, {"CTQ_CLCPAR"})

    aAdd(aFields, {"CTQ_PERCEN"})
    aAdd(aFields, {"CTQ_MSBLQL"})
    aAdd(aFields, {"CTQ_STATUS"})
    aAdd(aFields, {"CTQ_EVERAT"})
    aAdd(aFields, {"CTQ_REGRA"})
    aAdd(aFields, {"CTQ_INTERC"})

    oBulk:setFields(aFields)

    For nI := 1 to Len(jBody["rules"])
        
        cFilIns := IIF(empty(jBody["rules"][nI]["header"]["ctq_filial"]), xFilial("CTQ"), jBody["rules"][nI]["header"]["ctq_filial"])
        cFilArq := PadR(cFilIns,nTamFil)
        cCodEve := PadR(jBody["rules"][nI]["header"]["ctq_everat"],nTamEve)
        cCodReg := IIf(jBody["rules"][nI]["header"]["ctq_regra"]==Nil,"",jBody["rules"][nI]["header"]["ctq_regra"])
        cCodRat := IIf(jBody["rules"][nI]["header"]["ctq_rateio"]==Nil,"",jBody["rules"][nI]["header"]["ctq_rateio"])
        cDescRt := IIf(jBody["rules"][nI]["header"]["ctq_desc"]==Nil,"",jBody["rules"][nI]["header"]["ctq_desc"])
        cTipoRr := IIf(jBody["rules"][nI]["header"]["ctq_tipo"]==Nil,"1",jBody["rules"][nI]["header"]["ctq_tipo"])
        cPerBas := IIf(jBody["rules"][nI]["header"]["ctq_perbas"]==Nil,"100",jBody["rules"][nI]["header"]["ctq_perbas"])
        cMSBLQL := IIf(jBody["rules"][nI]["header"]["ctq_msblql"]==Nil,"2",jBody["rules"][nI]["header"]["ctq_msblql"])
        cStatus := IIf(jBody["rules"][nI]["header"]["ctq_status"]==Nil,"1",jBody["rules"][nI]["header"]["ctq_status"])
       
        For nJ := 1 to Len(jBody["rules"][nI]["items"])

            aItems := { xFilial("CTQ",cFilArq),;
                        cCodRat,;
                        cDescRt,;
                        cTipoRr,; //Saldo ou Movimento?
                        cPerBas,;
                        StrZero(nJ,nTamSeq),;
                        jBody["rules"][nI]["header"]["ctq_ctori"],;
                        jBody["rules"][nI]["header"]["ctq_ccori"],;
                        jBody["rules"][nI]["header"]["ctq_itori"],;
                        jBody["rules"][nI]["header"]["ctq_clori"],;
                        jBody["rules"][nI]["header"]["ctq_ctpar"],;
                        jBody["rules"][nI]["header"]["ctq_ccpar"],;
                        jBody["rules"][nI]["header"]["ctq_itpar"],;
                        jBody["rules"][nI]["header"]["ctq_clpar"],;
                        jBody["rules"][nI]["items"][nJ]["ctq_ctcpar"],;
                        jBody["rules"][nI]["items"][nJ]["ctq_cccpar"],;
                        jBody["rules"][nI]["items"][nJ]["ctq_itcpar"],;
                        jBody["rules"][nI]["items"][nJ]["ctq_clcpar"],;
                        jBody["rules"][nI]["items"][nJ]["ctq_percen"],;
                        cMSBLQL,;
                        cStatus,;
                        cCodEve,;
                        cCodReg,;
                        "2";
                        }
                        
            If !CTQ->(dbSeek(xFilial("CTQ",cFilArq)+cCodRat+StrZero(nJ,nTamSeq)))
                oBulk:addData(aItems)                
            EndIf
        Next nJ              
    Next nI

    oBulk:close()
    lRet := Empty(oBulk:cError)
    
    If lRet
        cResponse := cResponseAux
    EndIf
    oBulk:destroy()

    FreeObj(oBulk)
return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} setStructCTQ
Exclui os objetos vinculados ao evento
 
@author Totvs
/*/
//-------------------------------------------------------------------
method deleteCTQbyEvent(cFilArq as Character, cCodEve as Character, cResponse as Character) class ApportionmentProtheusData
Local lRet as Logical
Local cDeleteQry := "" as Character
Local cResponseAux := "" as Character 

cResponseAux := cResponse
cResponse := STR0004+cCodEve //"Erro na exclusão dos rateios vinculados ao evento: "

cDeleteQry :=   " DELETE FROM "+RetSqlName("CTQ")+;
                " WHERE CTQ_FILIAL = '"+cFilArq+"' AND CTQ_RATEIO IN("+;
                " SELECT CQK_CODRAT FROM "+RetSqlName("CQK")+;
                " WHERE CQK_FILIAL = '"+xFilial("CQK",cFilArq)+"' AND CQK_CODEVE = '"+cCodEve+"' AND D_E_L_E_T_ = ' ') AND "+;
                " D_E_L_E_T_ = ' ' "

lRet := (TCSQLExec(cDeleteQry) == 0)

If lRet 
    cResponse := cResponseAux 
EndIf

return lRet
