#include "PROTHEUS.CH"
#include "tlpp-core.th"
#include "BACKOFFICE.ACCOUNTINGCLOSING.ACCOUNTINGCALENDAR.DATA.PROTHEUS.CH"

namespace totvs.protheus.backoffice.accountingclosing.accountingcalendar
using namespace totvs.protheus.backoffice.accountingclosing.util
using namespace totvs.protheus.backoffice.reconciliation.util

//-------------------------------------------------------------------
/*/{Protheus.doc} AccountingCalendarProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class AccountingCalendarProtheusData from FWAdapterBaseV2
    Public method new()
    Public method getAll()
    Public method postBlockCalendar()
    static method getData() As object
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} AccountingCalendarProtheusData
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class AccountingCalendarProtheusData
    Default cVerbo := "GET"
    Default lList  := .T.
    _Super:New(cVerbo, lList)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} AccountingCalendarProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class AccountingCalendarProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := AccountingCalendarProtheusData():new()
    EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca das definições do fechamento contabil

@author Totvs
/*/
//-------------------------------------------------------------------
method getAll(nPage as Numeric, nPageSize as Numeric, cDatIni as Character, cDatFin as Character, cType as Character) class AccountingCalendarProtheusData
    Local aArea  := GetArea() As Array

    Private cGetDB  := Upper(AllTrim(TCGetDB()))
    
    Default nPage     := 1
    Default nPageSize := 10

    addMapFields(self, cType)

    ::setUseSpaces(.T.)
    ::setPage(nPage)
    ::setPageSize(nPageSize)
    ::SetQuery(getQuery(cType))
    
    ::SetWhere(getWhere(cDatIni, cDatFin, cType))

    If cType == "1" 
        ::SetOrder("CTG.CTG_FILIAL, CTG.CTG_CALEND, CTG.CTG_EXERC, CTG.CTG_PERIOD")
    Else
        ::SetOrder("CQD.CQD_FILIAL, CQD.CQD_CALEND, CQD.CQD_EXERC, CQD.CQD_PERIOD")
    EndIf

    If ::Execute()
        ::FillGetResponse()
    EndIf

    RestArea(aArea)
    FwFreeArray(aArea)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} addMapFields
Realiza o mapeamento dos campos que serão retornados

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function addMapFields(oSelf as Object, cType as Character)
    
    Local cSubstr as Character
    LOcal cConcat as Character

    cSubstr := IIf(cGetDB $ "ORACLE/POSTGRES","SUBSTR","SUBSTRING")
    cConcat := IIf("SQL"$cGetDB,"+","||")    

    If cType == "1" // Busca por calendario CTG
        oSelf:addMapFields("branch",    "branch",   .T., .F., {"branch",    "C", TamSx3("CTG_FILIAL")[1], 0}, "CTG.CTG_FILIAL")
        oSelf:addMapFields("calendar",  "calendar", .T., .F., {"calendar",  "C", TamSx3("CTG_CALEND")[1], 0}, "CTG.CTG_CALEND")
        oSelf:addMapFields("year" ,     "year" ,    .T., .F., {"year" ,     "C", TamSx3("CTG_EXERC" )[1], 0}, "CTG.CTG_EXERC" ) 
        oSelf:addMapFields("period",    "period",   .T., .F., {"period",    "C", TamSx3("CTG_PERIOD")[1], 0}, "CTG.CTG_PERIOD")
        oSelf:addMapFields("status",    "status",   .T., .F., {"status",    "C", TamSx3("CTG_STATUS")[1], 0}, "CTG.CTG_STATUS")

    Else //Busca por processo CQD
        oSelf:addMapFields("branch",    "branch",   .T., .F., {"branch",    "C", TamSx3("CQD_FILIAL")[1], 0}, "CQD.CQD_FILIAL")
        oSelf:addMapFields("calendar",  "calendar", .T., .F., {"calendar",  "C", TamSx3("CQD_CALEND")[1], 0}, "CQD.CQD_CALEND")
        oSelf:addMapFields("year" ,     "year" ,    .T., .F., {"year" ,     "C", TamSx3("CQD_EXERC" )[1], 0}, "CQD.CQD_EXERC" ) 
        oSelf:addMapFields("period",    "period",   .T., .F., {"period",    "C", TamSx3("CQD_PERIOD")[1], 0}, "CQD.CQD_PERIOD")
        oSelf:addMapFields("process",  "process",   .T., .F., {"process",   "C", TamSx3("CQD_PROC")[1], 0}, "CQD.CQD_PROC")
        oSelf:addMapFields("descri",  "descri",     .T., .F., {"descri",    "C", TamSx3("CQD_DESC")[1], 0}, "CQD.CQD_DESC")
        oSelf:addMapFields("status",    "status",   .T., .F., {"status",    "C", TamSx3("CQD_STATUS")[1], 0}, "CQD.CQD_STATUS")
    EndIf

    // Campo de data da CTG presente nas duas consultas
    oSelf:addMapFields("dateini",   "dateini",  .T., .F., {"dateini",   "C", TamSx3("CTG_DTINI" )[1], 0},;
    cSubstr+"(CTG.CTG_DTINI,7,2)"+cConcat+"'/'"+cConcat+; 
    cSubstr+"(CTG.CTG_DTINI,5,2)"+cConcat+"'/'"+cConcat+;
    cSubstr+"(CTG.CTG_DTINI,1,4)")  
    oSelf:addMapFields("datefin",   "datefin",  .T., .F., {"datefin",   "C", TamSx3("CTG_DTFIM" )[1], 0},;    
    cSubstr+"(CTG.CTG_DTFIM,7,2)"+cConcat+"'/'"+cConcat+; 
    cSubstr+"(CTG.CTG_DTFIM,5,2)"+cConcat+"'/'"+cConcat+;
    cSubstr+"(CTG.CTG_DTFIM,1,4)")
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getQuery(cType As Character) As Character
    Local cQuery As Character

    If cType == "1"
        cQuery := " SELECT #QueryFields#"
        cQuery += " FROM " + RetSqlName("CTG") + " CTG "
        cQuery += " WHERE #QueryWhere#"
    Else
        cQuery := " SELECT #QueryFields#"
        cQuery += " FROM " + RetSqlName("CQD") + " CQD "
        cQuery += " LEFT JOIN " + RetSqlName("CTG") + " CTG "
        cQuery += " ON CQD.CQD_FILIAL = CTG.CTG_FILIAL AND "
        cQuery += " CQD.CQD_CALEND = CTG.CTG_CALEND AND "
        cQuery += " CQD.CQD_EXERC = CTG.CTG_EXERC AND "
        cQuery += " CQD.CQD_PERIOD = CTG.CTG_PERIOD "
        cQuery += " WHERE #QueryWhere#"
    EndIf

Return cQuery


//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca das definições do fechamento contabil

@author Totvs
/*/
//-------------------------------------------------------------------
method postBlockCalendar(jBody as Json, cResponse as Character) class AccountingCalendarProtheusData
    Local aArea         := GetArea() As Array
    Local lReturn       := .T. As Logical
    Local nI            := 0 As Numeric
    Local cCalendar     := "" As Character
    Local cYear         := "" As Character
    Local cPeriod       := "" As Character
    Local cBranch    := "" As Character
    Local cChaves       := "" As Character
    Local cProcess      := "" As Character
    Local lProcessBlock := .F. As Logical

    lProcessBlock := jBody["items"][1]["process"] <> Nil // Se o processo foi enviando em alguma posição, todos os bloqueios serão por processo

    For nI := 1 to Len(jBody["items"])

        cBranch     := jBody["items"][nI]["branch"]
        cCalendar   := jBody["items"][nI]["calendar"]
        cYear       := jBody["items"][nI]["year"]
        cPeriod     := jBody["items"][nI]["period"]

        If lProcessBlock // Se for bloqueio por processo
            cProcess := jBody["items"][nI]["process"]
            //CQD_FILIAL+CQD_CALEND+CQD_EXERC+CQD_PERIOD+CQD_PROC
            CQD->(DBSetOrder(1))
            If CQD->(dbSeek(cBranch + cCalendar + cYear + cPeriod + cProcess))
                CQD->(RecLock("CQD", .F.))
                    CQD->CQD_STATUS := "4"
                CQD->(MSUNLOCK())
            Else 
                cChaves += cBranch + cCalendar + cYear + cPeriod + cProcess + CRLF
                lReturn := .F. 
            EndIf
        Else // Se for bloqueio por calendário
            //CTG_FILIAL, CTG_CALEND, CTG_EXERC, CTG_PERIOD
            CTG->(dbSetOrder(1))
            If CTG->(dbSeek(cBranch+cCalendar+cYear+cPeriod))        
                CTG->(RecLock("CTG",.F.))
                    CTG->CTG_STATUS := "4"
                CTG->(MsUnLock())                
            Else            
                cChaves += cBranch+cCalendar+cYear+cPeriod+CRLF
                lReturn := .F.            
            EndIf    
        EndIf 

    Next nI
    
    If !lReturn
        If !lProcessBlock
            cResponse := STR0001 + CRLF //"Não foi possível encontrar o calendário por processo com os dados informados."
            cResponse += STR0002 + " - CTG_FILIAL+CTG_CALEND+CTG_EXERC+CTG_PERIOD"+CRLF //"Chave
        Else
            cResponse := STR0003 + CRLF //"Não foi possível encontrar o calendário com os dados informados."
            cResponse += STR0002 + " - CQD_FILIAL+CQD_CALEND+CQD_EXERC+CQD_PERIOD+CQD_PROC"+CRLF //"Chave
        EndIf
        cResponse += cChaves
    EndIf

    RestArea(aArea)
    FwFreeArray(aArea)
return lReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} getWhere
Função que retorna o where que será utilizado na busca
@param 
    cType, character, Tipo de busca que será utilizado para retornar os calendários 
        "1" para calendários e "2" para processos" 
@return
    cWhere, character, clausula where que será utiizado na busca
@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getWhere(cDatIni as Character, cDatFin as Character, cType as Character)
    Local cSubstr As Character
    Local cWhere AS Character
    Local cSelectedMod As Character
    Local cBranchesCTG As Character
    Local cBranchesCQD As Character

    cBranchesCTG := GetBranchiesForConditional("CTG", "CTBA960")
    cSubstr := IIf(cGetDB $"ORACLE/POSTGRES","SUBSTR","SUBSTRING")

    If cType == "1"
        cWhere +=   " " + cBranchesCTG + " AND "+;
                    cSubstr+"(CTG.CTG_DTINI,1,6) >= '"+SubStr(cDatIni,1,6)+"' AND "+;
                    cSubstr+"(CTG.CTG_DTFIM,1,6) <= '"+SubStr(cDatFin,1,6)+"' AND CTG.D_E_L_E_T_ = ' '"
    Else
        cSelectedMod := GetModules()
        cBranchesCQD := GetBranchiesForConditional("CQD", "CTBA960")
        
        cWhere +=   " " + cBranchesCTG + " AND "+;
                    " " + cBranchesCQD + " AND "+;
                    cSubstr+"(CTG.CTG_DTINI,1,6) >= '"+SubStr(cDatIni,1,6)+"' AND "+;
                    cSubstr+"(CTG.CTG_DTFIM,1,6) <= '"+SubStr(cDatFin,1,6)+"' "+;
                    " AND " + cSubstr + "(CQD.CQD_PROC, 1, 3) IN (" + cSelectedMod + ")" +;
                    " AND CTG.D_E_L_E_T_ = ' ' AND CQD.D_E_L_E_T_ =  ' ' "
    EndIf

Return cWhere

//-------------------------------------------------------------------
/*/{Protheus.doc} GetModules
Função que retorna os modulos utilizados na QLF para fazer a comparação com os processos contidos na CQD
@param nil
@return
    cSelectedMod, character, string com os modulos utilizados para serem comparados com a CQD
@author Totvs
/*/
//-------------------------------------------------------------------
Static Function GetModules()

    Local cAliasTmp     as Character        
    Local cSelectedMod   as Character
    
    cAliasTmp := GetNextAlias()
    cSelectedMod := ""

    BeginSQL Alias cAliasTmp
    SELECT
        QLF.QLF_MODULE, QLF.QLF_ITENS
    FROM
        %Table:QLF% QLF
    WHERE
        QLF_FILIAL = %xFilial:QLF%
        AND QLF.%NotDel%
    EndSQL
    
    (cAliasTmp)->(DBGoTop())
    While (cAliasTmp)->(!EOF())
        If (cAliasTmp)->QLF_ITENS <> ""
            If !Empty(cSelectedMod)
                cSelectedMod += ","
            EndIf
            cSelectedMod += " '" + SubStr((cAliasTmp)->QLF_MODULE, 5, 3) + "' "
        EndIf 
        (cAliasTmp)->(DBSkip())
    End

    (cAliasTmp)->(dbCloseArea()) //Fecha temporario

Return cSelectedMod
