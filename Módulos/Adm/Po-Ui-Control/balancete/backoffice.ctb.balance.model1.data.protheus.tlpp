#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "backoffice.ctb.balance.model1.data.protheus.ch"

namespace totvs.protheus.backoffice.ctb.balance.model1
using namespace totvs.protheus.backoffice.reconciliation.util

//-------------------------------------------------------------------
/*/{Protheus.doc} GetBalanceteProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------

class GetBalanceModel1ProtheusData from FWAdapterBaseV2
	public method new()
	public method getAll()
	public method getAllGesp()
	public method getAllData()
	private method infoPlanReferencial()
	method getDataWithPlanoRef()

	static method getData() As object
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} new
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class GetBalanceModel1ProtheusData
	Default cVerbo := "GET"
	Default lList  := .T.
	_Super:New(cVerbo, lList)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} GetBalanceModel1ProtheusData
Método para retornar a instancia do objeto

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class GetBalanceModel1ProtheusData As Object
	static __oActiveData As Object

	If ValType(__oActiveData) == "U"
		__oActiveData := GetBalanceModel1ProtheusData():new()
	EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAllData
Metodo responsável pela geracao do balancete

@author Totvs
/*/
//-------------------------------------------------------------------
method getAllData( oJBody as json, aUrlFilter as array, aFils as array ) class GetBalanceModel1ProtheusData	
	local cSql			as character
	local afieldAPI		as array
	local cArqTmp		as character
	local cAlias		as character    
	local cWhere        as character
	local aStru			as array
	local cQryFields	as character
	local cSubQryField	as character
	local cTableNam1	as character
	local aArea 		as array
	local aSelFil		as Array 		
	local cDataini  	as character	
	local cDataFim  	as character	
	local cContaDe  	as character
	local cContaAte 	as character
	local nImprContas   as numeric
	local cMoeda		as character
	local cTpSaldo  	as character
	local cFiltroSeg 	as character
	local cFiltroSegIni as character
	local cFiltroSegFim as character
	local cFiltroSegCon as character
	local nImpMovimento	as numeric
	local nDivide		as numeric
	local lVlrZerado    as logical
	local lImpAntLp		as logical
	local cDtPosAntLp	as character
	local lRecDesp0 	as logical
	local cGrpRecDesp   as character
	local aSetOfBook	as array
	local cPlanRef      as character
	local cPlanRefVer   as character
	local cPlanRefEnt   as character
	local nPage     	as numeric
    local nPageSize 	as numeric
	local lTecFin  		as logical
	local cTbResult 	as character
	local cInto			as character
	local cOracle 		as character
	local cFimoracle 	as character
	local cDb := TcGetDb() as character
	Local lUsaplano 	as logical

	cTbResult 	 := "%SHTMP%" 
	cSql		 := ""
	cWhere 		 := ""
	cAlias		 := "CT7"
	cQryFields	 := ""
	cSubQryField := ""
	cTableNam1	 := ""
	cArqTmp		 := "" 
	aArea 		 := fwGetArea()
	aSelFil		 := {}

	cDataini 	 := ojBody["DATA_INICIAL"]				
	cDataFim  	 := ojBody["DATA_FINAL"]				
	cContaDe  	 := iif( vazio(ojBody["CONTA_INICIAL"]), padR(" ", tamSx3("CT1_CONTA")[1], " "), ojBody["CONTA_INICIAL"] ) 						
	cContaAte 	 := iif( vazio(ojBody["CONTA_FINAL"]), padR("", tamSx3("CT1_CONTA")[1],"Z"), ojBody["CONTA_FINAL"] ) 
	nImprContas  := iif( Vazio(ojBody["IMPRIME_CONTAS"]),  3, ojBody["IMPRIME_CONTAS"]  )
	aSetOfBook	 := iif( Vazio(ojBody["COD_CONFIG_LIVROS"]), CTBSetOf(""), CTBSetOf(ojBody["COD_CONFIG_LIVROS"]) )
	lVlrZerado   := iif( Vazio(ojBody["SALDOS_ZERADOS"]), .T., iif(ojBody["SALDOS_ZERADOS"] == 1, .T., .F.)   )	
	cMoeda		 := iif( Vazio(ojBody["MOEDA"]),  "01", ojBody["MOEDA"]  )	
	cTpSaldo     := iif( Vazio(ojBody["TIPO_DE_SALDO"]), "1", ojBody["TIPO_DE_SALDO"]  )	
	cFiltroSeg	 := iif( Vazio(ojBody["FILTRA_SEGMENTO_NO"]), padR(" ", tamSx3("CTM_SEGMEN")[1]) , ojBody["FILTRA_SEGMENTO_NO"]  )	  
	cFiltroSegIni:= iif( Vazio(ojBody["CONTEUDO_INI_SEGMEN"]),  "", ojBody["CONTEUDO_INI_SEGMEN"]  )	  
	cFiltroSegFim:= iif( Vazio(ojBody["CONTEUDO_FIM_SEGMEN"]),  "", ojBody["CONTEUDO_FIM_SEGMEN"]  )	  
	cFiltroSegCon:= iif( Vazio(ojBody["CONTEUDO_CONTIDO_EM"]),  "", ojBody["CONTEUDO_CONTIDO_EM"]  )	  
	nImpMovimento:= iif( Vazio(ojBody["IMPRIME_COLUNA_MOV"]),  1, ojBody["IMPRIME_COLUNA_MOV"]  )	  
	nDivide		 := iif( Vazio(ojBody["DIVIDE_POR"]),  1, ojBody["DIVIDE_POR"])	
	lImpAntLp	 := iif( Vazio(ojBody["POSICAO_ANT_L_P"]), .F., iif(ojBody["POSICAO_ANT_L_P"] = 2, .F., .T.) )	
	cDtPosAntLp	 := iif( Vazio(ojBody["DATA_LUCRO_PERDAS"]), ojBody["DATA_INICIAL"], ojBody["DATA_LUCRO_PERDAS"]  )		
	lRecDesp0 	 := iif( Vazio(ojBody["IGNORA_SL_ANT_REC_DES"]), .T., iif(ojBody["IGNORA_SL_ANT_REC_DES"] == 1, .T., .F.)  )	
	cGrpRecDesp  := iif( Vazio(ojBody["GRUPOS_RECEITAS_DESPESAS"]),  "", ojBody["GRUPOS_RECEITAS_DESPESAS"]  )	
	dDtZeraRD    := iif( Vazio(ojBody["DATA_SLD_ANT_RECEITAS_DESP"]), ojBody["DATA_INICIAL"], ojBody["DATA_SLD_ANT_RECEITAS_DESP"]  )
	if len(aFils)> 0 
		aSelFil := afils
	else		
		aSelFil		 := separa( ojBody["FILIAL"], ";" ) 
	endIf
	cPlanRef	 := iif( Vazio(ojBody["COD_PLANO_REF"]), "", ojBody["COD_PLANO_REF"]  )
	cPlanRefVer	 := iif( Vazio(ojBody["PLANO_REF_VERSAO"]), "", ojBody["PLANO_REF_VERSAO"]  )
	cPlanRefEnt  := iif( Vazio(ojBody["PLANO_REF_ENTIDADE"]), "", ojBody["PLANO_REF_ENTIDADE"]  )
	nPage		 := iif( Vazio(ojBody["PAGE"]),  0, ojBody["PAGE"]  )
	nPageSize    := iif( Vazio(ojBody["PAGESIZE"]),  0, ojBody["PAGESIZE"]  )
	lTecFin 	 := iif( Vazio(ojBody["TECHFIN"]), .F., iif(ojBody["TECHFIN"] == 1, .T., .F.) )

	lUsaplano:= Vazio(cPlanRef + cPlanRefVer + cPlanRefEnt ) == .F.

	if !Vazio(ojBody["CNPJ"]) 
		lTecFin := .T.
	endIf

	if lTecFin .AND. ( Vazio(cPlanRef) .or. Vazio(cPlanRefVer) .or. Vazio(cPlanRefEnt))
		::infoPlanReferencial(cDataIni, cDataFim, @cPlanRef, @cPlanRefVer, @cPlanRefEnt)
	endif

	if nDivide >= 1 .AND. nDivide <= 4
		nDivide := {1, 100, 1000, 1000000}[nDivide]
	else 
		nDivide := 1
	EndIf
	
	CTGerPlan(,,, .F., @cArqTmp,;
	ctoD(cDataini), cToD(cDataFim), cAlias, "", cContaDe, cContaAte,,,,,,, cMoeda,;
	cTpSaldo, aSetOfBook, cFiltroSeg, ;
	cFiltroSegIni, cFiltroSegFim, cFiltroSegCon,;
	.F.,.F.,,, lImpAntLP, ctoD(cDtPosAntLp)-1, nDivide, ;
	lVlrZerado,,,,,,,,,,,,,,.T.,"", lRecDesp0,;
	cGrpRecDesp, ctoD(dDtZeraRD)-1,,,,,,,,,aSelFil,,,,,,,,,,,,,,,@cTableNam1)

	afieldAPI := getfieldReturn(nImpMovimento, (cPlanRef + cPlanRefVer + cPlanRefEnt), substr( cDataFim, 4, 7),lTecFin,aSelFil,cDataIni, cDataFim)

	aStru :=  getAstru(cArqTmp->(dbStruct()), afieldAPI, (cPlanRef + cPlanRefVer + cPlanRefEnt),lTecFin )

	aEval( aFieldAPI, {|aCampo| cQryFields += aCampo[1] +", "})
	cQryFields := substr( cQryFields, 1, len(cQryFields)-2)

	self:SetFields(cQryFields)

	aEval( aFieldAPI, {|aCampo| cSubQryField  += aCampo[3] +", "})
	cSubQryField := substr( cSubQryField, 1, len(cSubQryField)-2)

	addMapFields(self, @aStru, afieldAPI )

	TCDelFile( cTbResult )

    fwDbCreate(cTbResult, aStru, "TOPCONN", .F.)
	
    cTbResult := TCConfig("GETTEMPNAME=" + cTbResult)

	If cDb != "MSSQL"
		cInto := " INTO "
	EndIf
	If lTecFin .and. lUsaplano .and. cDb == "ORACLE"
		cOracle:= " ( "
		cFimoracle := " ) "
	EndIf
	
	cSql := " INSERT "+ cInto + cTbResult + " ( " + cQryFields + " ) " + char(13)+char(10) + ;
			cOracle+ " SELECT " + cSubQryField 	 					 						+ ;
			" FROM "  + cTableNam1 													
	
	if lTecFin

		if Vazio(cPlanRef + cPlanRefVer + cPlanRefEnt ) == .F.
			cSql += " LEFT JOIN "+ RetSqlName("CVD")  +" CVD ON CVD.D_E_L_E_T_ = ' '  " 				+ ;
					" 	AND CVD_FILIAL = '" + fwXFilial("CVD") + "'  " 				+ ;
					" 	AND CVD_CODPLA = '" + cPlanRef    + "'  " 					+ ;
					" 	AND CVD_ENTREF = '" + cPlanRefEnt + "'  " 					+ ;
					" 	AND CVD_VERSAO = '" + cPlanRefVer + "'  " 					+ ;
					" 	AND CVD_CONTA  = CONTA  "									+ ;
					" LEFT JOIN "+ RetSqlName("CVN")  +" CVN ON CVN.D_E_L_E_T_ = ' ' "  				+ ;
					" 	AND CVN_FILIAL = '" + fwXFilial("CVN") + "'  "				+ ;
					" 	AND CVN_CODPLA = '" + cPlanRef    + "'  "					+ ;
					" 	AND CVN_ENTREF = '" + cPlanRefEnt + "'  "					+ ;
					" 	AND CVN_VERSAO = '" + cPlanRefVer + "'  "					+ ;
					" 	AND CVN_CTAREF = CVD_CTAREF "+ cFimoracle
		endIf
	endIf

	cwhere += iif( (nImprContas == 1 .or. nImprContas == 2), " AND TIPOCONTA = '" + cValToChar(nImprContas) + "' ", "")

	if Vazio(cWhere) == .F.
		cSql += " WHERE CONTA <> ' ' " + cwhere
	endIf
	
	Iif( TcSqlExec( cSql ) < 0 ,FWLogMsg("ERROR", "", "APIBALANCE", "", " ", , "Error: "+ STR0004 + tcSqlError(), , ) ,)

	self:SetQuery(" SELECT #QueryFields# FROM " + cTbResult + " WHERE #QueryWhere# " )

	self:SetWhere(" 1 = 1 ")
	
	self:setOrder("SUPERIOR, CONTA ")
		

	Iif( Vazio(aUrlFilter) == .F. , self:SetUrlFilter(aUrlFilter), )	
	
	if nPage == 0 .OR. nPageSize == 0		
		self:setPage(1)
		self:setPageSize( cArqTmp->(recCount()) )
	else
		self:setPage(nPage)
		self:setPageSize( nPageSize )
	endIf

	If self:Execute()
		self:FillGetResponse()
	EndIf

	Iif(TCDelFile( cTbResult ) ,,FWLogMsg("ERROR", "", "APIBALANCE", "", " ", , "Error: "+ STR0007 + cTbResult , , )  ) // "Erro ao remover a tabela temporaria gerada pelo CTGerPlan "

	restArea(aArea)

	CTBGerClean()
return
//-------------------------------------------------------------------
/*/{Protheus.doc} addMapFields
	Metodo responsável por retornar os fields de retorno

	@author Totvs
/*/
//-------------------------------------------------------------------
Static Function addMapFields(oSelf as object, aStru as array, afieldAPI)
	local i  as numeric

	for i:=1 to len(aStru)
		oSelf:addMapFields(afieldAPI[i,2], afieldAPI[i, 1], .T., .T., {afieldAPI[i,1], aStru[i,2], aStru[i,3], aStru[i,4]} )
	next
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} addMapFields
	array com os campos usado no add map fields e na qry  para obtencao dos dados da area da ctgerplan
	@author Totvs
/*/
//-------------------------------------------------------------------

static function getfieldReturn(nImpMovimento as numeric, cPlanoRef as character, cCompetencia as character, lTecFin as logical, aSelFil as Array,cDataIni as character,cDataFim as character)
	local aField as array
	Local cAliasQry as character
	Local cQuery as character
	Local cStmov as character
	Local aArea  as array	
	aField := {}

	aadd(afield, {"CONTA", "CONTA", "CONTA" })
	aadd(afield, {"NORMAL", "CONDICAO_NORMAL", "NORMAL"} )
	aadd(afield, {"SUPERIOR", "SUPERIOR", "SUPERIOR"} )
	aadd(afield, {"TIPOCONTA", "CLASSE", "TIPOCONTA"} )
	aadd(afield, {"NATCTA", "NATUREZA", "NATCTA"} )
	aadd(afield, {"DESCCTA", "DESCRICAO", "DESCCTA"} )
	aadd(afield, {"SALDOANT", "SALDO_ANTERIOR", "SALDOANT" })
	aadd(afield, {"SALDODEB", "DEBITO", "SALDODEB" })
	aadd(afield, {"SALDOCRD", "CREDITO", "SALDOCRD"  })
	aadd(afield, {"SALDOATU", "SALDO_ATUAL", "SALDOATU" })

	if nImpMovimento ==1 
		aadd(afield, {"MOVIMENTO", "MOVIMENTO", "MOVIMENTO" })
	endIf

	if lTecFin
		aArea := GetArea()
		if Vazio(cPlanoRef) == .F.
			aadd(afield, {"CTAREF", "CONTA_REFERENCIAL", "coalesce(CVD_CTAREF, ' ') as CTAREF" })
			aadd(afield, {"CTAREFDESC", "DESCRICAO_REFERENCIAL", "coalesce(CVN_DSCCTA, ' ') as CTAREFDES"})
		endIf
		
		aadd(afield, {"COMPETENC", "COMPETENCIA", " '" + cCompetencia + "' AS COMPETENC" })

		cAliasQry := GetNextAlias()
		cQuery +=	" SELECT CASE CTG_STATUS WHEN '1' THEN 'Aberto' WHEN '2' THEN 'Fechado' WHEN '3' THEN 'Transportado' WHEN '4' THEN 'Bloqueado'"+ ;
			" ELSE ' ' END as ST_MOV  FROM " + retSqlName("CTG") + " CTG " 			+ ;
			" WHERE CTG.D_E_L_E_T_ =  ' ' " 										+ ;
			" 	AND CTG_FILIAL = '" + aSelFil[1]           + "' "	                + ;
			" 	AND CTG_DTINI <= '" + dtos(cTod(cDataIni)) + "' "   				+ ;
			" 	AND CTG_DTFIM >= '" + dtos(cTod(cDataFim)) + "' " 					+ ; 
			" 	AND CTG_CALEND = ( SELECT MIN(CTG2.CTG_CALEND) " 					+ ;
			"	FROM " + retSqlName("CTG") + " CTG2 WHERE CTG2.D_E_L_E_T_ =  ' ' "	+ ;
			" 	AND CTG_FILIAL = '" + aSelFil[1] 	 	   + "' " 					+ ;
			" 	AND CTG_DTINI <= '" + dtos(cTod(cDataIni)) + "' " 					+ ;
			" 	AND CTG_DTFIM >= '" + dtos(cTod(cDataFim)) + "') " 

		cQuery := ChangeQuery(cQuery) 

		MPSysOpenQuery(cQuery,cAliasQry)

		If (cAliasQry)->(!Eof()) 
			cStmov := SubSTR((cAliasQry)->ST_MOV, 1, 10)
		EndIF
		(cAliasQry)->(DbCloseArea())
		Iif(Empty(cStmov),cStmov:= ' ',)

		aadd(afield, {"ST_MOV", "STATUS_COMPETENCIA", "'"+cStmov + "' as ST_MOV "  })
		RestArea(aArea)
	endIf												
return aField

//-------------------------------------------------------------------
/*/{Protheus.doc} addMapFields
	Retorna o array com a strutura dos campos que deverao ser retornados pela API
	@author Totvs
/*/
//-------------------------------------------------------------------
static function getAstru(aStru as array, afieldAPI as array, cStrplanRef as character,lTecFin as logical)
	local i		  as numeric	
	local id      as numeric
	local aAux    as array
	local aRes	  := {}

	for i:=1 to len(afieldAPI) 
		id := aScan(aStru, {|x| x[1] == afieldAPI[i][1]})
		if id > 0
			aadd(aRes, aStru[id])
		endIf
	next

	if lTecFin
		if Vazio(cStrplanRef) == .F.
			aAux := tamSx3("CVD_CTAREF")
			aadd(aRes, {"CTAREF", aAux[3], aAux[1], aAux[2]  })
			
			aAux := tamSx3("CVN_DSCCTA")
			aadd(aRes, {"CTAREFDESC", aAux[3], aAux[1], aAux[2]  })
		endIf

		aadd(aRes, {"COMPETENC", "C", 10, 0})
		aadd(aRes, {   "ST_MOV", "C", 10, 0})
	endIf
return aRes

method infoPlanReferencial(cDtIni as character, cDtFim as character, cPlanoRef as character, ;
						   cPlanRefVer as character, cPlanRefEnt as character) class GetBalanceModel1ProtheusData
	local cmd  as character
	local cAux1 := "" as character
	local cAux2 := "" as character
	Local aArea   := GetArea()
	local cDb 	:= TcGetDb() as character
	local cAlias := GetNextAlias() as character


	If cDb == "MSSQL"
		cAux1 := " TOP 1 "		
	Elseif TcGetDb() == "ORACLE"
		cAux2 := " AND ROWNUM <=1 "
	Else 
		cAux2 := " LIMIT 1 "
	EndIf

	cmd := ;
	" SELECT " + cAux1 + " CVN_CODPLA, CVN_ENTREF, "						+ ;
	" CVN_VERSAO, CVN_DTVIGI, CVN_DTVIGF " 									+ ; 
	" FROM " + RetSqlName("CVN") 											+ ; 
	" WHERE "																+ ;
	" CVN_FILIAL = '" + fwXFilial("CVN") + "' " 							+ ;
	" AND '" + dTos(ctoD(cDtIni)) + "' BETWEEN CVN_DTVIGI AND CVN_DTVIGF " 	+ ;
	" AND '" + dTos(ctoD(cDtFim)) + "' BETWEEN CVN_DTVIGI AND CVN_DTVIGF " 	+ ;
	" AND D_E_L_E_T_ = ' ' " 							 					+ ;
	cAux2

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cmd), cAlias, .F., .T.)
	dbSelectarea(cAlias)

	cPlanoRef   := (cAlias)->CVN_CODPLA  
	cPlanRefEnt := (cAlias)->CVN_ENTREF
	cPlanRefVer := (cAlias)->CVN_VERSAO

	(calias)->(DBCLOSEAREA())
	RestArea(aArea)
return

/*/{Protheus.doc} getAllData
Metodo responsável pela geracao do balancete

@author Totvs
/*/
//-------------------------------------------------------------------
method getAllGesp( oJBody as json, aUrlFilter as array, aFils as array ) class GetBalanceModel1ProtheusData	
	local afieldAPI		as array
	local cArqTmp		as character
	local cWhere        as character
	local aStruTmp		as array
	local aStru			as array
	local cQryFields	as character
	local cSubQryField	as character
	local cTableNam1	as character
	local aArea 		as array
	local nImprContas   as numeric
	Local i as numeric

	aArea 		 := fwGetArea()
	cTableNam1:= Ctr040getData(oJBody,aFils , @cTableNam1,@cArqTmp)

	afieldAPI := getfieldReturnGesp()
	aStruTmp:= cArqTmp->(dbStruct())
	aStru :={}
	For i:=1 to len(afieldAPI) 
		id := aScan(aStruTmp, {|x| x[1] == afieldAPI[i][1]})
		If id > 0
			aadd(aStru, aStruTmp[id])
		EndIf
	Next

	aEval( aFieldAPI, {|aCampo| cQryFields += aCampo[1] +", "})
	cQryFields := substr( cQryFields, 1, len(cQryFields)-2)

	self:SetFields(cQryFields)

	aEval( aFieldAPI, {|aCampo| cSubQryField  += aCampo[3] +", "})
	cSubQryField := substr( cSubQryField, 1, len(cSubQryField)-2)

	addMapFields(self, @aStru, afieldAPI )

	self:SetQuery(" SELECT #QueryFields# FROM " + cTableNam1 + " WHERE #QueryWhere# " )

	cwhere := " CONTA <> ' ' "
	cwhere += iif( (nImprContas == 1 .or. nImprContas == 2), " AND TIPOCONTA = '" + cValToChar(nImprContas) + "' ", "")

	self:SetWhere(cwhere)
	
	self:setOrder("CONTA ")
		

	Iif( Vazio(aUrlFilter) == .F. , self:SetUrlFilter(aUrlFilter), )	
	
	self:setPage(1)
	self:setPageSize( len(ojBody["CODIGO_EXTERNO"]) )

	If self:Execute()
		self:FillGetResponse()
	EndIf

	restArea(aArea)

	CTBGerClean()
return
