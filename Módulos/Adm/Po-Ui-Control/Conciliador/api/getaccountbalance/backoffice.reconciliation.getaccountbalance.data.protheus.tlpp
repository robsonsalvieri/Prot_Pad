#include "tlpp-core.th"

namespace totvs.protheus.backoffice.reconciliation.getaccountbalance
using namespace totvs.protheus.backoffice.reconciliation.util

static _lPostgres

//-------------------------------------------------------------------
/*/{Protheus.doc} GetAccountBalanceProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class GetAccountBalanceProtheusData from FWAdapterBaseV2
    Public method new()
    Public method getAll()
    static method getData() As object
    static method getTable() As object
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} GetAccountBalanceProtheusData
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class GetAccountBalanceProtheusData
    Default cVerbo := "GET"
    Default lList  := .T.
    _Super:New(cVerbo, lList)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} GetAccountBalanceProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class GetAccountBalanceProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := GetAccountBalanceProtheusData():new()
    EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca das configuracoes do conciliador

@author Totvs
/*/
//-------------------------------------------------------------------
method getAll(nPage as Numeric, nPageSize as Numeric, cTable as Character, cDateCQ1 as Character, cTpSald as Character) class GetAccountBalanceProtheusData

    Default nPage     := 1
    Default nPageSize := 10

    addMapFields(self)

    ::setPage(nPage)
    ::setPageSize(nPageSize)
    ::SetQuery(getQuery(cTable,cDateCQ1,cTpSald))

    cWhere := "CONTA <> ' '"
    cWhere += "GROUP BY CONTA, DESCRICAO, SALDO_ANTERIOR"

    ::SetWhere(cWhere)
    ::SetOrder("CONTA")
    If ::Execute()
        ::FillGetResponse()
    EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} addMapFields
Realiza o mapeamento dos campos que serão retornados

@author Totvs
/*/
//-------------------------------------------------------------------

Static Function addMapFields(oSelf as Object)
    oSelf:addMapFields("account", "account", .T., .F.,         {"account", "C",      TamSx3("CT2_DEBITO")[1], 0}, "CONTA")
    oSelf:addMapFields("descr", "descr", .T., .F.,             {"descr", "C",        TamSx3("CT1_DESC01")[1], 0}, "DESCRICAO")
    oSelf:addMapFields("saldAnt", "saldAnt", .T., .F.,         {"saldAnt", "N",      TamSx3("CT2_VALOR")[1], 0},  "SALDO_ANTERIOR")
    oSelf:addMapFields("typesalAnt", "typesalAnt", .T., .F.,   {"typesalAnt", "C",   TamSx3("CT1_DESC01")[1], 0}, "CASE WHEN SALDO_ANTERIOR = 0 THEN '' WHEN SALDO_ANTERIOR > 0 THEN 'C' ELSE 'D' END ")
    oSelf:addMapFields("totMovDebi", "totMovDebi", .T., .F.,   {"totMovDebi", "N",   TamSx3("CT2_VALOR")[1], 0},  "SUM(DEBITO)")
    oSelf:addMapFields("totMovCredi", "totMovCredi", .T., .F., {"totMovCredi", "N",  TamSx3("CT2_VALOR")[1], 0},  "SUM(CREDITO)")
    oSelf:addMapFields("saldAtu", "saldAtu", .T., .F.,         {"saldAtu", "N",      TamSx3("CT2_VALOR")[1], 0},  "ROUND(SUM(CREDITO) - SUM(DEBITO) + SALDO_ANTERIOR, 2)")
    oSelf:addMapFields("typesalAtu", "typesalAtu", .T., .F.,   {"typesalAtu", "C",   TamSx3("CT1_DESC01")[1], 0}, "CASE WHEN ROUND(SUM(CREDITO) - SUM(DEBITO) + SALDO_ANTERIOR, 2) = 0 THEN '' WHEN ROUND(SUM(CREDITO) - SUM(DEBITO) + SALDO_ANTERIOR, 2) > 0 THEN 'C' ELSE 'D' END ")
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getQuery(cTabelaTemp as Character, cDataCQ1 as Character, cTpSald as Character) As Character
    Local cQuery As Character
    Local nLenCompany  := Len(FWSM0Layout(, 1))
    Local nLenUnit     := Len(FWSM0Layout(, 2))
    Local nLenBranchId := Len(FWSM0Layout(, 3))
    Local nLenFilCT1   := 0
    Local nLenFilCQ1   := 0
    Local nLenSpace    := 0
    Local cGetDB       := Upper(AllTrim(TCGetDB()))
    Local cSubStr      := IIf(cGetDB $ "ORACLE/POSTGRES","SUBSTR","SUBSTRING")
    Local cCT2Fil      := GetBranchiesForConditional("CT2")

    // CT1
    If FWModeAccess("CT1",1) = "E"
        nLenFilCT1 += nLenCompany
    Else
        nLenSpace += nLenCompany
    EndIf
    If FWModeAccess("CT1",2) = "E"
        nLenFilCT1 += nLenUnit
    Else
        nLenSpace += nLenUnit
    EndIf
    If FWModeAccess("CT1",3) = "E"
        nLenFilCT1 += nLenBranchId
    Else
        nLenSpace += nLenBranchId
    EndIf

    // CQ1
    If FWModeAccess("CQ1",1) = "E"
        nLenFilCQ1 += nLenCompany
    Else
        nLenSpace += nLenCompany
    EndIf
    If FWModeAccess("CQ1",2) = "E"
        nLenFilCQ1 += nLenUnit
    Else
        nLenSpace += nLenUnit
    EndIf
    If FWModeAccess("CQ1",3) = "E"
        nLenFilCQ1 += nLenBranchId
    Else
        nLenSpace += nLenBranchId
    EndIf

    /* ---------------------------------------------------------------
    -- -------------------- ATENÇÃO!  --------------------------------
    --
    -- Caso seja necessário adicionar mais campos da tabela temporária (cTabelaTemp) para a consulta abaixo, 
    -- Adicione também na lista de campos a serem incluídos forçadamente no método tcValidFields 
    -- na API matchprocessing.data.protheus
    ------------------------------------------------------------------ */

    cQuery := "SELECT #QueryFields# "
    cQuery += "     FROM ("
    //Crédito
    cQuery += "     SELECT "
    cQuery += "         CT2.CT2_CREDIT AS CONTA, "
    // MAX para atribuir a primeira descrição de conta encontrada. Semelhante ao CTBR040 e CTBR400
    cQuery += "         MAX(CT1.CT1_DESC01) AS DESCRICAO, " 
    cQuery += "         ROUND(COALESCE(CQ1_SUM.SALDO_ANTERIOR, 0), 2) AS SALDO_ANTERIOR, "
    cQuery += "         0 AS DEBITO, "
    cQuery += "         ROUND(SUM(CT2.CT2_VALOR), 2) AS CREDITO, "
    cQuery += "         ROUND(SUM(CT2.CT2_VALOR) + COALESCE(CQ1_SUM.SALDO_ANTERIOR, 0), 2) AS SALDO_ATUAL "
    cQuery += "     FROM "+cTabelaTemp+" CT2 "
    cQuery += "     INNER JOIN "+RetSQLName("CT1")+" CT1 "
    cQuery += "     ON CT2.CT2_CREDIT = CT1.CT1_CONTA "
    cQuery += "     AND "+cSubStr+"(CT2.CT2_FILIAL,1,"+cValtoChar(nLenFilCT1)+") = "+cSubStr+"(CT1.CT1_FILIAL,1,"+cValtoChar(nLenFilCT1)+")"
    cQuery += "     LEFT JOIN ( "
    cQuery += "         SELECT  "
    cQuery += "             CQ1.CQ1_CONTA, "
    cQuery += "             SUM(CQ1.CQ1_CREDIT)-SUM(CQ1.CQ1_DEBITO) AS SALDO_ANTERIOR "
    cQuery += "         FROM "+RetSQLName("CQ1")+ " CQ1 "
    cQuery += "         WHERE  "
    cQuery += "             CQ1.CQ1_DATA < '"+cDataCQ1+"' "
    cQuery += "             AND CQ1.CQ1_MOEDA = '01' "
    If !Empty(&cTpSald) .And. &cTpSald <> "null"
        cQuery += "         AND CQ1.CQ1_TPSALD IN ("+cTpSald+") "
    EndIf
    cQuery += "             AND CQ1.D_E_L_E_T_ = ' ' "
    cQuery += "         GROUP BY CQ1.CQ1_CONTA "
    cQuery += "     ) CQ1_SUM "
    cQuery += "         ON CQ1_SUM.CQ1_CONTA = CT2.CT2_CREDIT "
    cQuery += "     WHERE "
    cQuery += "         CT2.D_E_L_E_T_ = ' ' "
    cQuery += "         AND " + cCT2Fil + " " // No lugar de xFilial
    cQuery += "         AND CT2.CT2_CREDIT <> ' ' "
    cQuery += "         AND CT2.CT2_DC IN('2','3')  "
    cQuery += "         AND CT2.CT2_MOEDLC = '01' "
    // Não agrupar por descrição (CT1_DESC01) para não separar as contas em filiais diferentes que serão aglutinadas. Semelhante ao CTBR040 e CTBR400
    cQuery += "     GROUP BY CT2.CT2_CREDIT, CQ1_SUM.SALDO_ANTERIOR " 
    cQuery += "     UNION ALL "
    //Débito
    cQuery += "     SELECT "
    cQuery += "         CT2.CT2_DEBITO AS CONTA,"
    // MAX para atribuir a primeira descrição de conta encontrada. Semelhante ao CTBR040 e CTBR400
    cQuery += "         MAX(CT1.CT1_DESC01) AS DESCRICAO, " 
    cQuery += "         ROUND(COALESCE(CQ1_SUM.SALDO_ANTERIOR, 0), 2) AS SALDO_ANTERIOR, "
    cQuery += "         ROUND(SUM(CT2.CT2_VALOR), 2) AS DEBITO, "
    cQuery += "         0 AS CREDITO, "
    cQuery += "         ROUND(SUM(CT2.CT2_VALOR), 2) AS SALDO_ATUAL "
    cQuery += "     FROM "+cTabelaTemp+" CT2     "
    cQuery += "     INNER JOIN "+RetSQLName("CT1")+" CT1 "
    cQuery += "         ON CT2.CT2_DEBITO = CT1.CT1_CONTA "
    cQuery += "     AND "+cSubStr+"(CT2.CT2_FILIAL,1,"+cValtoChar(nLenFilCT1)+") = "+cSubStr+"(CT1.CT1_FILIAL,1,"+cValtoChar(nLenFilCT1)+")"
    cQuery += "     LEFT JOIN ( "
    cQuery += "         SELECT "
    cQuery += "             CQ1.CQ1_CONTA,     "
    cQuery += "             SUM(CQ1.CQ1_CREDIT)-SUM(CQ1.CQ1_DEBITO) AS SALDO_ANTERIOR "
    cQuery += "         FROM "+RetSQLName("CQ1")+ " CQ1     "
    cQuery += "         WHERE      "
    cQuery += "             CQ1.CQ1_DATA < '"+cDataCQ1+"'
    cQuery += "             AND CQ1.CQ1_MOEDA = '01' "
    If !Empty(&cTpSald) .And. &cTpSald <> "null"
        cQuery += "         AND CQ1.CQ1_TPSALD IN ("+cTpSald+") "
    EndIf
    cQuery += "             AND CQ1.D_E_L_E_T_ = ' ' "
    cQuery += "         GROUP BY CQ1.CQ1_CONTA "
    cQuery += "     ) CQ1_SUM "
    cQuery += "         ON CQ1_SUM.CQ1_CONTA = CT2.CT2_DEBITO "
    cQuery += "     WHERE "
    cQuery += "         CT2.D_E_L_E_T_ = ' ' "
    cQuery += "         AND " + cCT2Fil + " " // No lugar de xFilial
    cQuery += "         AND CT2.CT2_DEBITO <> ' ' "
    cQuery += "         AND CT2.CT2_DC IN('1','3')  "
    cQuery += "         AND CT2.CT2_MOEDLC = '01' "
    // Não agrupar por descrição (CT1_DESC01) para não separar as contas em filiais diferentes que serão aglutinadas. Semelhante ao CTBR040 e CTBR400
    cQuery += "     GROUP BY CT2.CT2_DEBITO, CQ1_SUM.SALDO_ANTERIOR "
    cQuery += "     ) combined "
    cQuery += " WHERE #QueryWhere# "

    Return cQuery
