#include "tlpp-core.th"
#include "backoffice.reconciliation.ignore.data.protheus.ch"  

namespace totvs.protheus.backoffice.reconciliation.ignore
using namespace totvs.protheus.backoffice.reconciliation.util

//-------------------------------------------------------------------
/*/{Protheus.doc} IgnoreProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class IgnoreProtheusData
    Public  method new()    
    Public  method postByBody() As Array
    Public  method getData() As Object
    Private method tcGetIgnore()
    Private method tcSetIgnore()
endclass

/*/{Protheus.doc} IgnoreProtheusData
Metodo construtor

@author Totvs
/*/
method new() class IgnoreProtheusData
return

/*/{Protheus.doc} getData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
method getData() class IgnoreProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := IgnoreProtheusData():new()
    EndIf
return __oActiveData

/*/{Protheus.doc} postByBody
Metodo responsável pela busca e gravacao dos matches manuais

@author Totvs
/*/
method postByBody(jBody) class IgnoreProtheusData
Local aResponse := {} As Array
Local aMatches  := {} As Array

//Get Matches 
aMatches := ::tcGetignore(jBody)

//Set Matches
If Len(aMatches) > 0
    aResponse := ::tcSetignore(aMatches, jBody)
Else
    aAdd(aResponse, .F.)
    aAdd(aResponse, STR0001) //"Conteúdo do corpo inválido"
EndIf

FwFreeArray(aMatches)
return aResponse

/*/{Protheus.doc} tcGetIgnore
Metodo responsável pela busca dos matches manuais

@author Totvs
/*/
method tcGetIgnore(jBody As Json) class IgnoreProtheusData
Local aMatches := {} as Array
Local cTable         as Character
Local cCodCfg        as Character
Local cIdConc        as Character
Local cCondition     as Character
Local cOriDes        as character
Local aUUID          as Array
Local nI             as Numeric

If Valtype(jBody) == "J" .And. ValType(jBody:GetJsonText("codcfg")) == "C"
    cCodCfg := jBody:GetJsonText("codcfg")

    If ValType(jBody:GetJsonText("type")) == "C"
        cOriDes := jBody:GetJsonText("type")        //Origem ou Destino
    Endif

    If jBody:hasProperty("uuid")
        aUUID := jBody['uuid']                      //Ids dos registros selecionados
    Endif

    If !Empty(cCodCfg)
        //Armazena informacoes de origem
        If cOriDes == 'tabori'
            cIdConc  := AllTrim(Posicione("QLB", 1, xFilial("QLB")+Padr(cCodCfg, TamSx3("QLB_CODCFG")[1]), "QLB_CIDORI"))
        Else    
            cIdConc  := AllTrim(Posicione("QLB", 1, xFilial("QLB")+Padr(cCodCfg, TamSx3("QLB_CODCFG")[1]), "QLB_CIDDES"))    
        Endif    
        cTable := jBody:GetJsonText("table") 
                 
        If !Empty(cIdConc) .And. !Empty(cTable) .And. ValType(aUUID) == "A" .And. Len(aUUID) > 0                                    
            cCondition := "" //Inicializa condicionais 
            For nI := 1 To Len(aUUID)
                cCondition += "'"+aUUID[nI]+"',"
            Next
            cCondition := SubStr(cCondition, 1 , Len(cCondition)-1)

            If !Empty(cCondition)
                aAdd(aMatches, { cIdConc, cCondition})
            EndIf             
        EndIf                                      
   
     EndIf                                     
EndIf
return aMatches

/*/{Protheus.doc} tcSetignore
Metodo responsável pela atualizacao dos matches manuais
nas temporarias e json de retorno

@author Totvs
/*/
method tcSetIgnore(aMatches As Array, jBody As Json) class IgnoreProtheusData

Local cQryUpdt  := ""  as Character
Local cRegMatch := ""  as Character
Local cDesMatch := ""  as Character
Local cSeqMatch := ""  as Character
Local cError    := ""  as Character
Local cIdMatch  := ""  as Character
Local cTable    := ""  as Character
Local lContinue := .T. as Logical
Local aResponse := {}  as Array

//Verifica se temporarios existem
If Len(aMatches) > 0
    If Valtype(jBody) == "J" .And. ValType(jBody:GetJsonText("table")) == "C"
        cTable := jBody:GetJsonText("table")            
        If TCCanOpen(cTable) 
            cRegMatch := "998"
            tcNextSeqMatch(cTable, @cSeqMatch, cRegMatch) //Next match   //funcao para determinar a proxima sequencia
            cIdMatch  := cRegMatch+cSeqMatch  //construir  reg+seq
            cDesMatch := "ignore"
            
            //Atualiza tabela temporaria de origem
            cQryUpdt := "UPDATE " + cTable
            cQryUpdt += " SET REGMATCH = '" + cRegMatch + "', DESMATCH = '" + cDesMatch + "', SEQMATCH = '" + cSeqMatch + "'," 
            cQryUpdt += " IDMATCH = '"+ cIdMatch + "',"
            cQryUpdt += " TYPEMATCH = 'I'"
            cQryUpdt += " WHERE " + aMatches[1][1] + " IN (" + aMatches[1][2] + ")"    
            cQryUpdt += " AND REGMATCH = '"+ Space(TamSx3("QLD_REGMAT")[1]) +"'"
            cQryUpdt += " AND RECONCILED = 'N' "          
            cQryUpdt += " AND D_E_L_E_T_ = ' ' "

            If TcSqlExec(cQryUpdt) <> 0
                Conout(TCSqlError())
                cError := STR0002 //"ignore Error: Nao foi possivel atualizar a tabela temporaria: "
                cError += aMatches[1][1] + STR0003 //". Para mais detalhes, verificar arquivo console.log"
                lContinue := .F.
            EndIf
        Else
            lContinue := .F.
            cError    := STR0005 //"Tabela temporária inválida"    
        Endif
    Endif
EndIf

//Retorno
If lContinue
    aAdd(aResponse, lContinue)
    aAdd(aResponse, '{"regmatch": "'+cRegMatch+'", "desmatch": "'+cDesMatch+'", "seqmatch": "'+cSeqMatch+'"}')
Else
    aAdd(aResponse, lContinue)
    aAdd(aResponse, cError)
EndIf

TcRefresh(aMatches[1][1]) // Resetar tempo de timeout

return aResponse
