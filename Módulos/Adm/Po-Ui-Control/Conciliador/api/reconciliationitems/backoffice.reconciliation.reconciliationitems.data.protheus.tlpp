#include "tlpp-core.th"
#include "backoffice.reconciliation.conciliateitems.data.protheus.ch"

namespace totvs.protheus.backoffice.reconciliation.reconciliationitems
using namespace totvs.protheus.backoffice.reconciliation.util

//-------------------------------------------------------------------
/*/{Protheus.doc} ReconciliationItemsProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class ReconciliationItemsProtheusData from FWAdapterBaseV2
    Public method new()
    Public method getAll()
    Public method tcRetSQLExpression()
    Private method tcRetTempUnion()
    Private method tcSetSQLUnion()
    static method getData() As object    
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} ReconciliationItemsProtheusData
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class ReconciliationItemsProtheusData
    Default cVerbo := "GET"
    Default lList  := .T.
    _Super:New(cVerbo, lList)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} ReconciliationItemsProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class ReconciliationItemsProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := ReconciliationItemsProtheusData():new()
    EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca das configuracoes do conciliador

@author Totvs
/*/
//-------------------------------------------------------------------
method getAll(nPage as Numeric, nPageSize as Numeric, aFieldsApi as Array, cCodcfg as Character,;
 cMatch as Character, cCodCon as Character, cFilPos as Character, cResponse as Character) class ReconciliationItemsProtheusData
    Local aArea         := GetArea()                                        As Array        
    Local cWhere        := ""                                               As Character
    Local cCpoId        := ""                                               As Character
    Local cCpoIdUni     := ""                                               As Character
    Local cSQLSel       := ""                                               As Character       
    Local jHeaders      := JsonObject():new()                               As Json
    Local jUnion        := JsonObject():new()                               As Json    
    Local lProgress     := .T.                                              As Logical
    Local lUnion        := .F.                                              As Logical
    Local lIsFk5        := .F.                                              As Logical
    Local aStruct       := {}                                               As Array    
    Local cTable        := ""                                               As Character    
    Local cTableUni     := ""                                               As Character
    Local cAliasTmp     := ""                                               As Character    
    Local uRet          := Nil        
    Local cConcat       := IIF("MSSQL" $ Alltrim(TcGetDB()), "+", "||")     As Character

    Default cCodCfg   := "" 
    Default nPage     := 1
    Default nPageSize := 10

    lProgress := ValType(cCodCfg)=="C" .And. !Empty(cCodCfg)
    If lProgress
        lProgress := RetConfiguration(cCodCfg)
        If lProgress
            QLB->(dbSelectArea("QLB"))
            QLB->(dbSetOrder(1))
            If QLB->(dbSeek(FWxFilial("QLB")+cCodcfg))
                uRet := jHeaders:FromJson(AllTrim(QLB->QLB_FIELDS)) 
                If cMatch = "1"
                    If Empty(QLB->QLB_CIDORI)
                        lProgress := .F.
                    Else
                        cCpoId := QLB->QLB_CIDORI
                        cTable := QLB->QLB_TABORI
                        
                        //Tratamento para tabela union na origem
                        If !Empty(QLB->QLB_TABGRP)
                            lUnion := .T.
                            uRet := jUnion:FromJson(AllTrim(QLB->QLB_TABGRP))
                            If ValType(uRet) == "U" .And. ValType(jUnion["unionori"]) == "A" .And. Len(jUnion["unionori"]) > 0
                                cCpoIdUni := jUnion["unionori"][Len(jUnion["unionori"])]["cpoid"]
                                cTableUni := jUnion["unionori"][Len(jUnion["unionori"])]["table"]
                            Else
                                lProgress := .F.    
                            EndIf
                        EndIf
                    EndIf
                Else
                    If Empty(QLB->QLB_CIDDES)
                        lProgress := .F.
                    Else
                        cCpoId := QLB->QLB_CIDDES
                        cTable := QLB->QLB_TABDES
                    EndIf
                EndIf
            EndIf
        Else
            cResponse := STR0005+" "+cCodCfg+" "+STR0006 //"A configuração" //"foi excluída pela rotina de Setup"   
        EndIf
    EndIf
    If lProgress        
        If lUnion            
            cSQLSel := ::tcRetTempUnion(@cAliasTmp, cTable, cTableUni, cCpoId, cCpoIdUni, cCodCon, cMatch, cFilPos, jUnion) //Tratamento para Union            
        ElseIf cMatch = "1"
            cSQLSel := ::tcRetSQLExpression(jHeaders["data_ori"],",") //Cabecalho da query (origem)
        Else
            lIsFk5 := ((cCodCfg $ '0023|0024') .Or. ((QLB->(FieldPos("QLB_CFGORI")) > 0) .And. (QLB->QLB_CFGORI $ '0023|0024')))
            cSQLSel := ::tcRetSQLExpression(jHeaders["data_des"],",",lIsFk5) //Cabecalho da query (destino)
        EndIf

        lProgress := !Empty(cSQLSel)
    EndIf
    
    If lProgress               
        //Alimenta campos para obter estrutura
        aStruct := StrTokArr2(cSQLSel, ",") //Armazena campos em array
         
        addMapFields(self,aStruct,aFieldsApi,cTable,cConcat)

        ::setPage(nPage)
        ::setPageSize(nPageSize)
        ::SetQuery(getQuery(cTable,cCpoId,lUnion,cAliasTmp))

        If lUnion
            cWhere := " D_E_L_E_T_ = ' '"            
        Else
            cWhere := " QLD.QLD_FILIAL = '"+cFilPos+"'"
            cWhere += " AND QLD.QLD_CODCON = '"+Alltrim(cCodCon)+"'"
            cWhere += " AND QLD.QLD_TPITEM = '"+Alltrim(cMatch)+"'"
            cWhere += " AND QLD.D_E_L_E_T_ = ' '"
        EndIf
        ::SetWhere(cWhere)
        ::SetOrder("(QLD_REGMAT "+cConcat+" QLD_SEQMAT)") 

        If ::Execute()
            ::FillGetResponse()
        EndIf
        
        TcRefresh(cTable) // Resetar tempo de timeout
    EndIf
    
    If lUnion .And. !Empty(cAliasTmp)
        If Select(cAliasTmp) > 0
            (cAliasTmp)->(dbCloseArea())
            MsErase(cAliasTmp)
        EndIf
    EndIf

    RestArea(aArea)
    FwFreeArray(aArea)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetTempUnion
    Método para criacao do temporario quando existe union de tabelas
    @author TOTVS
    @since 23/06/2023
    @version version
    @param cAliasTmp, cTable, cTableUni, cCpoId, cCpoIdUni, cCodCon, 
    cMatch, cFilPos, jUnion
    @return cReturn
/*/
//-------------------------------------------------------------------
Method tcRetTempUnion(cAliasTmp as Character, cTable as Character, cTableUni as Character, cCpoId as Character,; 
                        cCpoIdUni as Character,cCodCon as Character, cMatch as Character, cFilPos as Character,;
                        jUnion as Json) class ReconciliationItemsProtheusData
Local cReturn    := "" as Character
Local cHeaders   := "" as Character
Local cSQLSel    := "" as Character
Local cSQLSelUni := "" as Character
Local cTipoField := "" as Character
Local nI         := 0 as Numeric
Local nUnionOri  := Len(jUnion["unionori"]) as Numeric
Local nTotFields := Len(jUnion["unionori"][nUnionOri]["fields"]) as Numeric
Local aHeaders   := {} as Array
Local aCposPai   := {} as Array
Local aCposFil   := {} as Array
Local aCamposTmp := {} as Array

For nI := 1 To nTotFields
    If Empty(jUnion["unionori"][nUnionOri]["fields"][nI]["cpopai"])                        
        cTipoField := GetSx3Cache(jUnion["unionori"][nUnionOri]["fields"][nI]["cpofil"], "X3_TIPO")
        aAdd(aHeaders, jUnion["unionori"][nUnionOri]["fields"][nI]["cpofil"])        
        aAdd(aCposPai, IIF(cTipoField == "N","0 ","' ' ")+jUnion["unionori"][nUnionOri]["fields"][nI]["cpofil"])
    Else
        aAdd(aHeaders, jUnion["unionori"][nUnionOri]["fields"][nI]["cpopai"])
        aAdd(aCposPai, jUnion["unionori"][nUnionOri]["fields"][nI]["cpopai"])                                                                                        
    EndIf

    If Empty(jUnion["unionori"][nUnionOri]["fields"][nI]["cpofil"])
        cTipoField := GetSx3Cache(jUnion["unionori"][nUnionOri]["fields"][nI]["cpopai"], "X3_TIPO")
        aAdd(aCposFil, IIF(cTipoField == "N","0 ","' ' ")+jUnion["unionori"][nUnionOri]["fields"][nI]["cpopai"])
    Else
        aAdd(aCposFil, jUnion["unionori"][nUnionOri]["fields"][nI]["cpofil"])
    EndIf                 
Next nI

//Adiciona campos UUID, REGMAT e SEQMAT
aAdd(aHeaders, cCpoId)
aAdd(aHeaders, "QLD_REGMAT")
aAdd(aHeaders, "QLD_SEQMAT")

aAdd(aCposPai, cCpoId)
aAdd(aCposPai, "QLD_REGMAT")
aAdd(aCposPai, "QLD_SEQMAT")

aAdd(aCposFil, cCpoIdUni)
aAdd(aCposFil, "QLD_REGMAT")
aAdd(aCposFil, "QLD_SEQMAT")

//Alimenta array com campos para temporario
For nI := 1 To Len(aHeaders)
    aAdd(aCamposTmp,{aHeaders[nI],;
            GetSx3Cache(aHeaders[nI], "X3_TIPO"),;
            TamSx3(aHeaders[nI])[1],; 
            TamSx3(aHeaders[nI])[2]})
Next nI

cHeaders   := ::tcRetSQLExpression(aHeaders, ",") //Cabecalho da query
cSQLSel    := ::tcRetSQLExpression(aCposPai, ",") //Campos Tabela Principal
cSQLSelUni := ::tcRetSQLExpression(aCposFil, ",") //Campos Tabela Union

//Criacao da tabela temporaria
cAliasTmp := GetNextAlias()
MsErase(cAliasTmp)
MsCreate(cAliasTmp, aCamposTmp, "TOPCONN")
Sleep(1000)
dbUseArea(.T., "TOPCONN", cAliasTmp, cAliasTmp, .F., .F.)

cReturn := IIf(::tcSetSQLUnion(cAliasTmp, cHeaders, cTable, cTableUni, cSQLSel,; 
                                cSQLSelUni, cCpoId, cCpoIdUni, cFilPos, cCodCon, cMatch), cHeaders, "")

//Limpa arrays
FWFreeArray(aHeaders)
FWFreeArray(aCposPai)
FWFreeArray(aCposFil)
FWFreeArray(aCamposTmp)
Return cReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} tcSetSQLUnion
    Método para alimentar temporario quando existe union de tabelas
    @author TOTVS
    @since 23/06/2023
    @version version
    @param cAliasTmp, cHeaders, cTable, cTableUni, cSQLSel
    cSQLSelUni, cCpoId, cCpoIdUni, cFilPos, cCodCon, cMatch
    @return lReturn
/*/
//-------------------------------------------------------------------
Method tcSetSQLUnion(cAliasTmp as Character, cHeaders as Character, cTable as Character, cTableUni as Character,; 
                        cSQLSel as Character, cSQLSelUni as Character, cCpoId as Character, cCpoIdUni as Character,;
                        cFilPos as Character, cCodCon as Character, cMatch as Character) class ReconciliationItemsProtheusData
Local lReturn    := .T. as Logical
Local cQryUpdate := "" as Character
Local cNameDB    := AllTrim(TcGetDB()) as Character

cQryUpdate := "INSERT INTO "+cAliasTmp
cQryUpdate += " ("+cHeaders+", R_E_C_N_O_)"            
cQryUpdate += " SELECT "+cSQLSel+","+cTable+".R_E_C_N_O_"
cQryUpdate += " FROM " + RetSQLName(cTable)+" "+cTable
cQryUpdate += " INNER JOIN "+RetSqlName("QLD")+" QLD ON"
If cNameDB $ "POSTGRES"
    cQryUpdate += " QLD.QLD_IDITEM = CAST("+cTable+"."+AllTrim(cCpoId)+" AS VARCHAR)"
ElseIf cNameDB $ "ORACLE"        
    cQryUpdate += " RTRIM(QLD.QLD_IDITEM) = COALESCE("+cTable+"."+AllTrim(cCpoId)+", SYS_GUID())"
Else
    cQryUpdate += " RTRIM(QLD.QLD_IDITEM) = "+cTable+"."+AllTrim(cCpoId)
EndIf
cQryUpdate += " AND "+cTable+"."+AllTrim(cCpoId)+" IS NOT NULL "
cQryUpdate += " AND "+cTable+".D_E_L_E_T_ = ' '"
cQryUpdate += " WHERE QLD.QLD_FILIAL = '"+cFilPos+"'"
cQryUpdate += " AND QLD.QLD_CODCON = '"+AllTrim(cCodCon)+"'"
cQryUpdate += " AND QLD.QLD_TPITEM = '"+AllTrim(cMatch)+"'"
cQryUpdate += " AND QLD.D_E_L_E_T_ = ' '"
cQryUpdate += " UNION ALL"
cQryUpdate += " SELECT "+cSQLSelUni+","+cTableUni+".R_E_C_N_O_"
cQryUpdate += " FROM " + RetSQLName(cTableUni)+" "+cTableUni
cQryUpdate += " INNER JOIN "+RetSqlName("QLD")+" QLD ON"
If cNameDB $ "POSTGRES"
    cQryUpdate += " QLD.QLD_IDITEM = CAST("+cTableUni+"."+AllTrim(cCpoIdUni)+" AS VARCHAR)"
ElseIf cNameDB $ "ORACLE"        
    cQryUpdate += " RTRIM(QLD.QLD_IDITEM) = COALESCE("+cTableUni+"."+AllTrim(cCpoIdUni)+", SYS_GUID())"
Else
    cQryUpdate += " RTRIM(QLD.QLD_IDITEM) = "+cTableUni+"."+AllTrim(cCpoIdUni)
EndIf
cQryUpdate += " AND "+cTableUni+"."+AllTrim(cCpoIdUni)+" IS NOT NULL "
cQryUpdate += " AND "+cTableUni+".D_E_L_E_T_ = ' '"
cQryUpdate += " WHERE QLD.QLD_FILIAL = '"+cFilPos+"'"                                                
cQryUpdate += " AND QLD.QLD_CODCON = '"+AllTrim(cCodCon)+"'"
cQryUpdate += " AND QLD.QLD_TPITEM = '"+AllTrim(cMatch)+"'"
cQryUpdate += " AND QLD.D_E_L_E_T_ = ' '"

IIf(TCSQLExec(cQryUpdate) != 0,;
    (Conout(TCSQLError()),;
    lReturn := .F.),;
    lReturn := .T.)

Return lReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetSQLExpression
    @author TOTVS
    @since 29/07/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
/*/
//-------------------------------------------------------------------
Method tcRetSQLExpression(aSQLArr as Array, cSeparator as Character, lIsFk5 as Logical) class ReconciliationItemsProtheusData
Local cRet      := "" as Character
Local nI        := 0 as Numeric

Default aSQLArr := {}
Default lIsFK5  := .F.

For nI := 1 to Len(aSQLArr)
    If nI > 1
        cRet += cSeparator
    EndIf
    //Específico para regras 0023|0024 - Financeiro
    If lIsFK5 .and. Substr(aSQLArr[nI],1,3) !=  "FK5"
        Loop
    Endif
    cRet += aSQLArr[nI]    
Next
Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} addMapFields
Realiza o mapeamento dos campos que serão retornados

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function addMapFields(oSelf as Object, aStruct as Array, aFieldsApi as Array, cTable as Character, cConcat as Character)
    Local nI         := 0  As Numeric
    Local cOrdem     := "00" As Character
    Local cTipo      := "" As Character
    Local cWidth     := "" As Character
    Local nTamanho   := 0  As Numeric
    Local nDecimal   := 0  As Numeric   
    Local aStructSX3 := {}  As Array 
    Local cMSUIDT    := "" As Character

    //  Obtem o MSUIDT da tabela posicionada
    If !(cTable)->(FieldPos(cTable+"_FILIAL") > 0)
        cMSUIDT := SubStr(cTable, 2, 2)+"_MSUIDT"
    Else 
        cMSUIDT := cTable+"_MSUIDT"
    EndIf  

    For nI := 1 to Len(aStruct)

        If nI == 1 
            cOrdem := "01"                        
            oSelf:AddMapFields("IDMATCH", "IDMATCH", .T., .F., {"IDMATCH", "C", 13, 0}, "(QLD_REGMAT"+cConcat+"QLD_SEQMAT)")                

            //Adiciona informacoes do dicionario - SX3 dos campos                
            aAdd(aFieldsApi, {  cOrdem,;
                                "idmatch",;
                                STR0004,; //"Id Match"
                                "C",;
                                14,;
                                0,;
                                "999.9999999999",;
                                "140px",;
                                "" })  

            cOrdem := "02"
            oSelf:AddMapFields("MSUIDT", "MSUIDT", .T., .F., {"MSUIDT", "C", 36, 0}, cMSUIDT)
            //Adiciona informacoes do MSUIDT (QLD_IDITEM)
                    aAdd(aFieldsApi, {  cOrdem,;
                                        "msuidt",;
                                        "msuidt",; //"ID Item"
                                        "C",;
                                        36,;
                                        0,;
                                        "",;
                                        "120px",;
                                        "" })
        EndIf

        cField := aStruct[nI]
        cOrdem  := Soma1(cOrdem)
        aStructSX3 := FWSX3Util():GetFieldStruct(cField) // Retorna um array com os dados da estrutura do campo na SX3
        cTitulo := FWX3Titulo(cField) //Adiciona informacoes do dicionario - SX3 dos campos             
        cTipo   := FWSX3Util():GetFieldType(aStruct[nI]) //Retorna o tipo do campo no SX3  
        nTamTit := Len(AllTrim(FWX3Titulo(cField)))
        nTamanho:= aStructSX3[3]
        nDecimal:= aStructSX3[4]
        
        oSelf:AddMapFields(cField, cField, .T., .F., {cField, cTipo, nTamanho, nDecimal}, cField)
        
        If nTamTit < 10 .And. nTamanho < 10
            //DEFAULT - Tratamento para campos pequenos
            cWidth := "100px"
        Else
            If nTamTit > nTamanho
                cWidth := CValToChar(nTamTit * 12) + "px"
            Else
                cWidth := CValToChar(nTamanho * 12) + "px"
            EndIf            
        EndIf                    

        aAdd(aFieldsApi, { cOrdem,;
                        AllTrim(Lower(cField)),;
                        AllTrim(If(Empty(cTitulo), Lower(cField), cTitulo)),;
                        cTipo,;
                        nTamanho,;
                        nDecimal,;
                        AllTrim(X3Picture(cField)),;
                        cWidth}) 
    Next

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getQuery(cTable,cCpoId,lUnion,cAliasTmp) As Character
    Local cQuery As Character
    Local cNameDB   := Alltrim(TcGetDB()) as Character
        
    cQuery := " SELECT #QueryFields#"
    If lUnion
        cQuery += " FROM "+cAliasTmp
    Else
        cQuery += " FROM "+RetSqlName(cTable)+" "+cTable
        cQuery += " INNER JOIN "+RetSqlName("QLD")+" QLD ON"        
        If cNameDB $ "POSTGRES"
            cQuery += " QLD.QLD_IDITEM = CAST("+cTable+"."+Alltrim(cCpoId)+" AS VARCHAR)"
        ElseIf cNameDB $ "ORACLE"        
            cQuery += " RTRIM(QLD.QLD_IDITEM) = COALESCE("+cTable+"."+Alltrim(cCpoId)+", SYS_GUID())"
        Else
            cQuery += " RTRIM(QLD.QLD_IDITEM) = "+cTable+"."+Alltrim(cCpoId)
        EndIf
        cQuery += " AND "+cTable+"."+Alltrim(cCpoId)+" IS NOT NULL "
        cQuery += " AND "+cTable+".D_E_L_E_T_ = ' '"
    EndIf    
    cQuery += " WHERE #QueryWhere#"       
Return cQuery
