#include "tlpp-core.th"
#include "backoffice.reconciliation.matchtotal.data.protheus.ch"

namespace totvs.protheus.backoffice.reconciliation.matchtotal
using namespace totvs.protheus.backoffice.reconciliation.util
using namespace totvs.protheus.backoffice.reconciliation.matchprocessing

//-------------------------------------------------------------------
/*/{Protheus.doc} MatchTotalProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class MatchTotalProtheusData
    Public  method new()
    Public  method getTotal() As Array
    Private method tcGetConditions()
    Private method tcGetQueryTotals()
    Private method tcGetWhereTotal()
    Public method getCustom()
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} MatchTotalProtheusData
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new() class MatchTotalProtheusData
return

//-------------------------------------------------------------------
/*/{Protheus.doc} getTotal
Metodo responsável pela busca dos totais da conciliação

@author Totvs
/*/
//-------------------------------------------------------------------
method getTotal(cBody) class MatchTotalProtheusData
Local cCodCfg    := tcGetQryParams("codcfg") as Character
Local cType      := tcGetQryParams("type")   as Character
Local aTotals    := {}                       as Array
Local aResponse  := {}                       as Array
Local aResult    := {}                       as Array
Local cWhereDeb  := ""                       as Character
Local cWhereCred := ""                       as Character
Local uRet       := nil                      as Variant
Local jBody      := JsonObject():New()
Local lContinue  := .T.

If !Empty(cCodCfg) .And. !Empty(cType)
    QLB->(dbSetOrder(1))
    If QLB->(dbSeek(xFilial("QLB")+cCodCfg))
        cTable :=  IIf(cType=="1", QLB->QLB_TABORI, QLB->QLB_TABDES)
    Else
        lContinue := .F.
        aAdd(aResponse, .F.)
        aAdd(aResponse, STR0003) //"Código da configuração inválido"
    EndIf

    If lContinue
        If cTable == "CT2" .And. ValType(cBody)=="C" .And. !Empty(cBody)
            uRet := jBody:fromJson(cBody)
            If ValType(uRet) == "U"
                cWhereDeb := ::tcGetWhereTotal(jBody, cType, "1") // Débito
                cWhereCred := ::tcGetWhereTotal(jBody, cType, "2") // Crédito
            Else
                lContinue := .F.
                aAdd(aResponse, .F.)
                aAdd(aResponse, STR0004) //"Conteúdo do body inválido"
            EndIf
        EndIf
    EndIf
Else
    lContinue := .F.
    aAdd(aResponse, .F.)
    aAdd(aResponse, STR0005) //"Parâmetros inválidos: codcfg - type"
Endif

If lContinue
    //Get Conditions
    aTotals := ::tcGetConditions(cCodCfg, cType)

    //Get Query Totals
    If Len(aTotals) > 0
        aResult := ::tcGetQueryTotals(aTotals, cWhereDeb, cWhereCred)
        //Retorno OK
        aAdd(aResponse, .T.)
        aAdd(aResponse, aClone(aResult))
    Else //Retorno erro
        aAdd(aResponse, .F.)
        aAdd(aResponse, STR0001) //"Json inválido - Tabela: QLB - field: QLB_TOTAL"
    EndIf
EndIf

FwFreeArray(aTotals)
FwFreeArray(aResult)
return aResponse

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetConditions
Metodo responsável pela busca dos matches manuais

@author Totvs
/*/
//-------------------------------------------------------------------
method tcGetConditions(cCodCfg As Character, cType As Character) class MatchTotalProtheusData
Local cLabelTot  := "" As Character
Local cValueTot  := "" As Character
Local cCondition := "" As Character
Local cTotals    := "" AS Character
Local nI         := 0  As Numeric
Local nPos       := 0  As Numeric
Local nIdTot     := 1  As Numeric
Local aTotals    := {} As Array
Local JTotals    := JsonObject():new() As Json
Local uRet       := Nil

DEFAULT cCodCfg := ""
DEFAULT cType   := ""

If !Empty(cCodCfg) .And. !Empty(cType)
    cTotals := AllTrim(Posicione("QLB", 1, xFilial("QLB")+Padr(cCodCfg, TamSx3("QLB_CODCFG")[1]), "QLB_TOTAL"))
    If ValType(cTotals) == "C"
        uRet := JTotals:fromJson(cTotals)
        If ValType(uRet) == "U"
            If cType == "1" //Tipo Origem
                For nI := 1 To Len(JTotals["totalori"])
                    If !Empty(JTotals["totalori"][nI]["condition"]) //Possui condicional
                        cLabelTot  := "'" + AllTrim(JTotals["totalori"][nI]["label"]) + "' AS LABEL01"
                        cValueTot  := "SUM(" + AllTrim(JTotals["totalori"][nI]["total"]) + ") AS TOTAL01"
                        cValueTot  += ",COUNT(" + AllTrim(JTotals["totalori"][nI]["total"]) + ") AS RECS01"
                        cCondition := AllTrim(JTotals["totalori"][nI]["condition"])
                        aAdd(aTotals, {cLabelTot + "," + cValueTot, cCondition, 1})
                    Else
                        //Verifica se agrega na mesma consulta
                        If (nPos := aScan(aTotals, {|x| Empty(x[2])})) > 0
                            nIdTot++

                            If nIdTot <= 9
                                cLabelTot := "'" + AllTrim(JTotals["totalori"][nI]["label"]) + "' AS LABEL" + StrZero(nIdTot, 2)
                                cValueTot := "SUM(" + AllTrim(JTotals["totalori"][nI]["total"]) + ") AS TOTAL" + StrZero(nIdTot, 2)
                                cValueTot  += ",COUNT(" + AllTrim(JTotals["totalori"][nI]["total"]) + ") AS RECS" + StrZero(nIdTot, 2)
                            Else
                                cLabelTot := "'" + AllTrim(JTotals["totalori"][nI]["label"]) + "' AS LABEL" + CValToChar(nIdTot)
                                cValueTot := "SUM(" + AllTrim(JTotals["totalori"][nI]["total"]) + ") AS TOTAL" + CValToChar(nIdTot)
                                cValueTot  += ",COUNT(" + AllTrim(JTotals["totalori"][nI]["total"]) + ") AS RECS" + CValToChar(nIdTot)
                            EndIf

                            aTotals[nPos][1] += "," + cLabelTot + "," + cValueTot
                            aTotals[nPos][3] := nIdTot
                        Else
                            cLabelTot  := "'" + AllTrim(JTotals["totalori"][nI]["label"]) + "' AS LABEL01"
                            cValueTot  := "SUM(" + AllTrim(JTotals["totalori"][nI]["total"]) + ") AS TOTAL01"
                            cValueTot  += ",COUNT(" + AllTrim(JTotals["totalori"][nI]["total"]) + ") AS RECS01"
                            cCondition := AllTrim(JTotals["totalori"][nI]["condition"])
                            aAdd(aTotals, {cLabelTot + "," + cValueTot, cCondition, 1})
                        EndIf
                    EndIf
                Next
            ElseIf cType == "2" //Tipo Destino
                For nI := 1 To Len(JTotals["totaldes"])
                    If !Empty(JTotals["totaldes"][nI]["condition"]) //Possui condicional
                        cLabelTot  := "'" + AllTrim(JTotals["totaldes"][nI]["label"]) + "' AS LABEL01"
                        cValueTot  := "SUM(" + AllTrim(JTotals["totaldes"][nI]["total"]) + ") AS TOTAL01"
                        cValueTot  += ",COUNT(" + AllTrim(JTotals["totaldes"][nI]["total"]) + ") AS RECS01"
                        cCondition := AllTrim(JTotals["totaldes"][nI]["condition"])
                        aAdd(aTotals, {cLabelTot + "," + cValueTot, cCondition, 1})
                    Else
                        //Verifica se agrega na mesma consulta
                        If (nPos := aScan(aTotals, {|x| Empty(x[2])})) > 0
                            nIdTot++

                            If nIdTot <= 9
                                cLabelTot := "'" + AllTrim(JTotals["totaldes"][nI]["label"]) + "' AS LABEL" + StrZero(nIdTot, 2)
                                cValueTot := "SUM(" + AllTrim(JTotals["totaldes"][nI]["total"]) + ") AS TOTAL" + StrZero(nIdTot, 2)
                                cValueTot  += ",COUNT(" + AllTrim(JTotals["totaldes"][nI]["total"]) + ") AS RECS" + StrZero(nIdTot, 2)
                            Else
                                cLabelTot := "'" + AllTrim(JTotals["totaldes"][nI]["label"]) + "' AS LABEL" + CValToChar(nIdTot)
                                cValueTot := "SUM(" + AllTrim(JTotals["totaldes"][nI]["total"]) + ") AS TOTAL" + CValToChar(nIdTot)
                                cValueTot  += ",COUNT(" + AllTrim(JTotals["totaldes"][nI]["total"]) + ") AS RECS" + CValToChar(nIdTot)
                            EndIf

                            aTotals[nPos][1] += "," + cLabelTot + "," + cValueTot
                            aTotals[nPos][3] := nIdTot
                        Else
                            cLabelTot  := "'" + AllTrim(JTotals["totaldes"][nI]["label"]) + "' AS LABEL01"
                            cValueTot  := "SUM(" + AllTrim(JTotals["totaldes"][nI]["total"]) + ") AS TOTAL01"
                            cValueTot  += ",COUNT(" + AllTrim(JTotals["totaldes"][nI]["total"]) + ") AS RECS01"
                            cCondition := AllTrim(JTotals["totaldes"][nI]["condition"])
                            aAdd(aTotals, {cLabelTot + "," + cValueTot, cCondition, 1})
                        EndIf
                    EndIf
                Next
            EndIf
        EndIf
    EndIf
EndIf
return aTotals

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetQueryTotals
Retorna a proxima sequencia disponivel na temporaria

@author Totvs
/*/
//-------------------------------------------------------------------
method tcGetQueryTotals(aTotals As Array, cWhereDeb As Character, cWhereCred As Character) class MatchTotalProtheusData
Local cQuery    := "" As Character
Local cAliasTmp := "" As Character
Local cTable    := tcGetQryParams("table") As Character
Local lMatch    := IIF(AllTrim(Lower(tcGetQryParams("match"))) == "false", .F., .T.) As Logical
Local nI        := 0 As Numeric
Local nX        := 0 As Numeric
Local nLenJson  := 0 As Numeric
Local aResult   := {} As Array

Default aTotals    := {}
Default cWhereDeb  := ""
Default cWhereCred := ""

If TCCanOpen(cTable)

    For nI := 1 To Len(aTotals)
        cAliasTmp := GetNextAlias()

        //Query para buscar totalizadores
        cQuery := "SELECT " + aTotals[nI][1]
        cQuery += " FROM " + cTable
        cQuery += " WHERE D_E_L_E_T_ = ' '"
        cQuery += " AND TYPEMATCH <> 'I' "
        If !Empty(aTotals[nI][2])
            cQuery += " AND (" + aTotals[nI][2] + ")"
        EndIf
        If lMatch //Com match
            cQuery += " AND REGMATCH <> '"+Space(TamSx3("QLD_REGMAT")[1])+"'"
        Else //Sem match
            cQuery += " AND REGMATCH = '"+Space(TamSx3("QLD_REGMAT")[1])+"'"
        EndIf

        If !Empty(cWhereDeb) .And. !Empty(aTotals[nI][2]) .And. aTotals[nI][2] == "CT2_DC = '1' OR CT2_DC = '3'"
            cQuery += "AND " + cWhereDeb
        EndIf
        If !Empty(cWhereCred) .And. !Empty(aTotals[nI][2]) .And. aTotals[nI][2]  == "CT2_DC = '2' OR CT2_DC = '3'"
            cQuery += "AND " + cWhereCred
        EndIf

        dbUseArea(.T., "TOPCONN", TcGenQry(,, cQuery), cAliasTmp, .T., .F.)

        //Armazena SeqMatch
        If (cAliasTmp)->(!EOF())
            For nX := 1 To aTotals[nI][3]
                nLenJson++
                aAdd(aResult, JsonObject():new())

                If nX <= 9
                    aResult[nLenJson]["label"] := &("(cAliasTmp)->LABEL"+StrZero(nX, 2))+IIF(lMatch, "", "-"+STR0002) //"Não Conciliados"
                    aResult[nLenJson]["value"] := &("(cAliasTmp)->TOTAL"+StrZero(nX, 2))
                    aResult[nLenJson]["count"] := &("(cAliasTmp)->RECS"+StrZero(nX, 2))
                Else
                    aResult[nLenJson]["label"] := &("(cAliasTmp)->LABEL"+CValToChar(nX))+IIF(lMatch, "", "-"+STR0002) //"Não Conciliados"
                    aResult[nLenJson]["value"] := &("(cAliasTmp)->TOTAL"+CValToChar(nX))
                    aResult[nLenJson]["count"] := &("(cAliasTmp)->RECS"+StrZero(nX, 2))
                EndIf
            Next
        EndIf

        (cAliasTmp)->(dbCloseArea()) //Fecha temporario

    Next

    TcRefresh(cTable) // Resetar tempo de timeout
EndIf

return aResult

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetWhereTotal
Retorna o Where do Total condicional

@author Totvs
/*/
//-------------------------------------------------------------------
method tcGetWhereTotal(jBody As Json, cType As Character, cDebCred As Character) class MatchTotalProtheusData
Local cWhere     := "" As Character
Local aWhere     := {} As Array

aWhere := IIf(cType=="1", jBody["tabori"], jBody["tabdes"])
cWhere := RetWhereEntity(aWhere, cDebCred)

Return cWhere

//-------------------------------------------------------------------
/*/{Protheus.doc} getCustom
    Busca as informações dos saldos bancários para a tela de consulta
    das regras de conciliação bancária no Conciliador BackOffice

@author Totvs
/*/
//-------------------------------------------------------------------
method getCustom(cRegra as Character, cBody as Character) class MatchTotalProtheusData
    Do Case
        Case "finext" $ cRegra
            Return finext(cBody)
    EndCase
Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} finext
    Informações dos saldos bancários para a tela de consulta
    das regras de conciliação bancária no Conciliador BackOffice

@author Totvs
/*/
//-------------------------------------------------------------------
Function finext(cBody as Character) as Json
    Local cTable        := ""                      as Character
    Local cQuery        := ""                      as Character
    Local cAlias        := ""                      as Character
    Local cBanco        := ""                      as Character
    Local cAgencia      := ""                      as Character
    Local cConta        := ""                      as Character
    Local cMV_MOEDAP    := "MV_MOEDP"              as Character
    Local nMoeda        := 1                       as Numeric
    Local cMoeda        := "1"                     as Character
    Local nSalAtu       := 0                       as Numeric
    Local nSalReco      := 0                       as Numeric
    Local nSalAtDay     := 0                       as Numeric
    Local nSalRcDay     := 0                       as Numeric
    Local jBalance      := JsonObject():new()      as Json
    Local jBalancePrev  := JsonObject():new()      as Json
    Local jBodyRequest  := JsonObject():new()      as Json
    Local cStartDate    := ""                      as Character
    Local cEndDate      := ""                      as Character
    Local cAuxDate      := CtoD("  /  /    ")      as Date
    Local oQryBalance                              as Object
    Local oQrySig                                  as Object

    If Empty(jBodyRequest:fromJson(cBody)) .And. jBodyRequest:HasProperty('startDate') .And. jBodyRequest:HasProperty('endDate') .And. jBodyRequest:HasProperty('bank') .And. jBodyRequest:HasProperty('agency') .And. jBodyRequest:HasProperty('account');
        .And. !Empty(jBodyRequest["startDate"]) .And. !Empty(jBodyRequest["endDate"]) .And. !Empty(jBodyRequest["bank"]);
        .And. !Empty(jBodyRequest["agency"]) .And. !Empty(jBodyRequest["account"])
        cStartDate  := StrTran(jBodyRequest['startDate'], "-", "")
        cEndDate    := StrTran(jBodyRequest['endDate'], "-", "")
        cBanco      := jBodyRequest['bank']
        cAgencia    := jBodyRequest['agency']
        cConta      := jBodyRequest['account']
    Else
        cTable := tcGetQryParams("table")
        cQuery := "SELECT MIN(IG_DTEXTR) DATAINI, IG_BCOEXT, IG_AGEEXT, IG_CONEXT FROM "
        cQuery += cTable
        cQuery += " WHERE "
        cQuery += " IG_FILIAL ? "
        cQuery += " GROUP BY IG_BCOEXT, IG_AGEEXT, IG_CONEXT"

        oQrySig := FWExecStatement():New(changeQuery(cQuery))
        oQrySig:setUnSafe(1, FinSelFil(GetListOfProfileBranchies("SIG"), "SIG", .F., .T., 50))

        cAlias := oQrySig:OpenAlias()

        If (cAlias)->(!EoF())
            cBanco      := (cAlias)->IG_BCOEXT
            cAgencia    := (cAlias)->IG_AGEEXT
            cConta      := (cAlias)->IG_CONEXT
            cStartDate  := (cAlias)->DATAINI
            cEndDate    := (cAlias)->DATAINI
        EndIf
        (cAlias)->(dbCloseArea())
        oQrySig:destroy()
    EndIf

    jBalancePrev := getPreviousBalanceQuery(@oQryBalance, cStartDate, cBanco, cAgencia, cConta)
    nSalAtu      := jBalancePrev['current_balance']
    nSalReco     := jBalancePrev['reconciled_balance']

    jBalancePrev := JsonObject():new()
    cAuxDate     := DaySum(StoD(cEndDate), 1) // Soma um dia na data final pois o filtro da query considera apenas < não <=
    jBalancePrev := getPreviousBalanceQuery(@oQryBalance, DtoS(cAuxDate), cBanco, cAgencia, cConta)
    nSalAtDay    := jBalancePrev['current_balance']
    nSalRcDay    := jBalancePrev['reconciled_balance']

    SA6->(DbSetOrder(1))
    If SA6->(MSSeek(xFilial("SA6") + cBanco + cAgencia + cConta))
        nMoeda  := SA6->A6_MOEDA
        cMoeda  := CVALTOCHAR(nMoeda)
    EndIf

    jBalance["balance"]        := nSalAtu
    jBalance["reconciled"]     := nSalReco
    jBalance["balanceDay"]     := nSalAtDay
    jBalance["reconciledDay"]  := nSalRcDay
    jBalance["bank"]           := cBanco
    jBalance["agency"]         := cAgencia
    jBalance["account"]        := cConta
    jBalance["currencySymbol"] := SuperGetMv("MV_SIMB" + cMoeda, .F., "")

    If nMoeda < 10
        cMV_MOEDAP := "MV_MOEDAP"
    EndIf

    jBalance["currencyLabel"]  := SuperGetMv(cMV_MOEDAP + cMoeda, .F., "")
    oQryBalance:destroy()
    FinEraseTmpFil()

Return jBalance

/*/{Protheus.doc} getPreviousBalanceQuery
    Retorna a query para obtenção dos saldos bancários anteriores 
    a data informada.
    
    @author Totvs
    @param cDateBalance, character, data para consulta yyyymmdd
    @param cBanco, character, código do banco
    @param cAgencia, character, agência
    @param cConta, character, conta
    @return json, {
        'current_balance':numeric      // saldo da data
        'reconciled_balance': numeric  // saldo conciliado da data
        }
/*/
//-------------------------------------------------------------------
Function getPreviousBalanceQuery(oQryBalance as object, cDateBalance as Character, cBanco as Character, cAgencia as Character, cConta as Character) as Json
    Local cQueryBalance := "" as Character
    Local cAliasBalance := "" as Character
    Local jResponse     := JsonObject():New() as Json

    jResponse['current_balance']    := 0
    jResponse['reconciled_balance'] := 0

    If oQryBalance == NIL
        cQueryBalance := " SELECT "
        cQueryBalance +=     " SUM(SE8.E8_SALATUA) SALATUA, "
        cQueryBalance +=     " SUM(SE8.E8_SALRECO) SALRECO "
        cQueryBalance += " FROM "
        cQueryBalance +=     RetSQLName("SE8") + " SE8 "
        cQueryBalance += " WHERE "
        cQueryBalance +=     " SE8.E8_FILIAL ? "
        cQueryBalance +=     " AND SE8.E8_BANCO = ? "
        cQueryBalance +=     " AND SE8.E8_AGENCIA = ? "
        cQueryBalance +=     " AND SE8.E8_CONTA = ? "
        cQueryBalance +=     " AND SE8.D_E_L_E_T_ = ? "
        cQueryBalance +=     " AND SE8.E8_DTSALAT = ( "
        cQueryBalance +=         " SELECT "
        cQueryBalance +=             " MAX(SE8DT.E8_DTSALAT) "
        cQueryBalance +=         " FROM "
        cQueryBalance +=             RetSQLName("SE8") + " SE8DT "
        cQueryBalance +=         " WHERE "
        cQueryBalance +=             " SE8DT.E8_FILIAL = SE8.E8_FILIAL "
        cQueryBalance +=             " AND SE8DT.E8_BANCO = SE8.E8_BANCO "
        cQueryBalance +=             " AND SE8DT.E8_AGENCIA = SE8.E8_AGENCIA "
        cQueryBalance +=             " AND SE8DT.E8_CONTA = SE8.E8_CONTA "
        cQueryBalance +=             " AND SE8DT.E8_DTSALAT < ? "
        cQueryBalance +=             " AND SE8DT.D_E_L_E_T_ = ? "
        cQueryBalance +=     " ) "

        oQryBalance := FWExecStatement():New(changeQuery(cQueryBalance))
    EndIf

    oQryBalance:setUnSafe(1, FinSelFil(GetListOfProfileBranchies("SE8"), "SE8", .F., .T., 50))
    oQryBalance:setString(2, cBanco)
    oQryBalance:setString(3, cAgencia)
    oQryBalance:setString(4, cConta)
    oQryBalance:setString(5, " ")
    oQryBalance:setString(6, cDateBalance)
    oQryBalance:setString(7, " ")

    cAliasBalance := oQryBalance:OpenAlias()

    If (cAliasBalance)->(!EOF())
        jResponse['current_balance']    := (cAliasBalance)->SALATUA
        jResponse['reconciled_balance'] := (cAliasBalance)->SALRECO
    EndIf

    (cAliasBalance)->(dbCloseArea())

Return jResponse
