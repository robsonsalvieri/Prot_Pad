#include "tlpp-core.th"

namespace totvs.protheus.backoffice.reconciliation.useradmingroup
using namespace totvs.protheus.backoffice.reconciliation.util

//-------------------------------------------------------------------
/*/{Protheus.doc} UserAdminGroupProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class UserAdminGroupProtheusData
    Public method new()
    Public method getAll()
    Public method getAllUsers()
    Private method controlAccessActivated()
    Private method tcGetQueryUsers()
    static method getData() As object
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} UserAdminGroupProtheusData
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class UserAdminGroupProtheusData
    Default cVerbo := "GET"
    Default lList  := .T.
return

//-------------------------------------------------------------------
/*/{Protheus.doc} UserAdminGroupProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class UserAdminGroupProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := UserAdminGroupProtheusData():new()
    EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca das configuracoes do conciliador

@author Totvs
/*/
//-------------------------------------------------------------------
method getAll() class UserAdminGroupProtheusData
    Local jResposta := {} as Json
	Local lUserAdmin := .F. As Logical

    If FWIsAdmin()
        lUserAdmin := .T.
    EndIf

    jResposta := JsonObject():new()
    jResposta["isadm"]      := lUserAdmin

Return jResposta

//-------------------------------------------------------------------
/*/{Protheus.doc} getAllUsers
Metodo responsável pela busca das configuracoes do conciliador que o
usuário logado tem acesso

@author Totvs
/*/
//-------------------------------------------------------------------
method getAllUsers(cRotina as Character) class UserAdminGroupProtheusData
    Local aGroupUsers  := {} as Array
    Local cReturn      := "" as Character
    Local nI           := 0  As Numeric
    Local cUsersString := "" As Character
    Local aArea        := GetArea() As Array
    Local cUser        := ""
    Local lCtrlAccessAtivated         := .F. as Logical

    cReturn := '{ "accesscontrolactivated": "false", "items": []}'
    lCtrlAccessAtivated := ::controlAccessActivated(cRotina)

    If lCtrlAccessAtivated // Se não existir nenhuma QLM ativa, o controle de acesso está desativado
        cUser := RetCodUsr()
        aGroupUsers := UsrRetGrp(,cUser)
        // Verifique se o array possui mais de um elemento
        
        If Len(aGroupUsers) > 1
            For nI:= 1 to Len(aGroupUsers) - 1
                cUsersString += aGroupUsers[nI] + ","
            Next nI
            cUsersString += aGroupUsers[Len(aGroupUsers)]
        ElseIf Len(aGroupUsers) == 1 
            cUsersString := aGroupUsers[1]
        EndIf

        If cUsersString <> "" .Or. cUser <> ""
            cReturn := ::tcGetQueryUsers(cUser,cUsersString,cRotina)
        EndIf
    EndIf

    RestArea(aArea)
    FwFreeArray(aArea)

Return cReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} getAllUsers
Metodo responsável pela busca das configuracoes do conciliador que o
usuário logado tem acesso

@author Totvs
/*/
//-------------------------------------------------------------------
method tcGetQueryUsers(cUser As Character, cUsersString As Character, cRotina as Character) class UserAdminGroupProtheusData
    Local cQuery    := "" As Character
    Local cAliasTmp := "" As Character
    Local cReturn   := "" as Character
    Local aJson     := {} as Array
    Local aConfigs  := {} As Array
    Local oReturn   := JsonObject():New() as Json
    Local jReturn   := JsonObject():New() as Json

    Default cUser := ""
    Default cUsersString := ""
    Default cRotina := ""

    cAliasTmp := GetNextAlias()
    //Query para buscar os acessos do usuário
    cQuery := " SELECT QLM.QLM_FILIAL, QLM.QLM_CODIGO, QLM.QLM_DESCRI, QLM.QLM_TIPO, QLM.QLM_ROTINA, QLM.QLM_USRGRP, QLM.QLM_CONFIG, QLM.QLM_STATUS"
    cQuery += " FROM "+RetSQLName("QLM")+" QLM "
    cQuery += " WHERE QLM.QLM_FILIAL = '"+xFilial("QLM")+"' AND QLM.D_E_L_E_T_ = ' '"
    cQuery += " AND QLM.QLM_ROTINA = '"+cRotina+"' AND QLM.QLM_STATUS = '1'"
    cQuery += " ORDER BY QLM.QLM_ROTINA, QLM.QLM_USRGRP, QLM.QLM_TIPO"

    dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTmp,.T.,.T.)

    While !(cAliasTmp)->(Eof())
        If ((cAliasTmp)->QLM_TIPO == '2' .And. (cAliasTmp)->QLM_USRGRP == cUser)
            If (Len(aJson) > 0)
                aJson := {} // Zero o array, pois a regra que prevalece é a do usuário
            EndIf
            // Busca as configurações do usuário
            QLM->(dbSetOrder(1))
            If QLM->(dbSeek(FWxFilial("QLM")+(cAliasTmp)->QLM_CODIGO))
                cResult := oReturn:FromJson(AllTrim(QLM->QLM_CONFIG))
                If ValType(cResult) == "U"
                    If !Empty(oReturn["configs"]) .And. Len(oReturn["configs"]) > 0
                        aConfigs := oReturn["configs"]
                        Aadd(aJson, aConfigs)
                    EndIf
                EndIf
            EndIf
            (cAliasTmp)->(dbSkip())
        ElseIf (cAliasTmp)->QLM_TIPO == '1' .And. (cAliasTmp)->QLM_USRGRP $ cUsersString// Busca as configurações do usuário no grupo
            QLM->(dbSetOrder(1))
            If QLM->(dbSeek(FWxFilial("QLM")+(cAliasTmp)->QLM_CODIGO))
                cResult := oReturn:FromJson(AllTrim(QLM->QLM_CONFIG))
                If ValType(cResult) == "U"
                    If !Empty(oReturn["configs"]) .And. Len(oReturn["configs"]) > 0
                        aConfigs := oReturn["configs"]
                        Aadd(aJson, aConfigs)
                    EndIf
                EndIf
            EndIf
        EndIf
        (cAliasTmp)->(dbSkip())
    EndDo

    (cAliasTmp)->(dbCloseArea())
    If Len(aJson) > 0
        jReturn["accesscontrolactivated"] := "true"
        jReturn["items"] := aJson[1]
        // jReturn["configs"] := aJson[1]
        cReturn := jReturn:toJson()
    Else 
        cReturn := '{"accesscontrolactivated": "true", "items":[]}'
    EndIf
    FreeObj(oReturn)
    FreeObj(jReturn)

Return cReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} controlAccessActivated
Metodo responsável pela busca das configuracoes do conciliador que o
usuário logado tem acesso

@author Totvs
/*/
//-------------------------------------------------------------------
method controlAccessActivated(cRotina as Character) class UserAdminGroupProtheusData
    
    Local cQuery    as Character
    Local cAliasTmp as Character
    Local lReturn   as Logical

    cQuery    := ""
    cAliasTmp := ""
    lReturn   := .F.

    If ChkFile("QLM")

        cAliasTmp := GetNextAlias()
        //Query para buscar os acessos do usuário
        cQuery := " SELECT QLM.QLM_CODIGO"
        cQuery += " FROM "+RetSQLName("QLM")+" QLM "
        cQuery += " WHERE QLM.QLM_FILIAL = '"+xFilial("QLM")+"' AND QLM.D_E_L_E_T_ = ' '"
        cQuery += " AND QLM.QLM_ROTINA = '"+cRotina+"' AND QLM.QLM_STATUS = '1' "

        dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTmp,.T.,.T.)

        If !(cAliasTmp)->(Eof())
            lReturn := .T.
        EndIf
    EndIf

Return lReturn
