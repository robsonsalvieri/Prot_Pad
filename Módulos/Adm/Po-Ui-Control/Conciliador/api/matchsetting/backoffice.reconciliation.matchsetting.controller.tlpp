#include "tlpp-core.th"
#include "backoffice.reconciliation.matchsetting.controller.ch"

namespace totvs.protheus.backoffice.reconciliation.matchsetting
using namespace totvs.protheus.backoffice.reconciliation.util
using namespace totvs.protheus.backoffice.reconciliation.userprofile

//-------------------------------------------------------------------
/*/{Protheus.doc} MatchSetting
Classe principal de controle, onde é inicializado o EndPoint

@author Totvs
/*/
//-------------------------------------------------------------------
class MatchSetting
    public method new()

    @Get("/api/tc/matchsetting/")
    public method getAllMatchSettings()
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} MatchSetting
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new() class MatchSetting
return

//-------------------------------------------------------------------
/*/{Protheus.doc} getAllMatchSettings
Metodo que inicia a chamada das configuracoes de match do conciliador

@author Totvs
/*/
//-------------------------------------------------------------------
method getAllMatchSettings() class MatchSetting
    Local oService  As Object
    Local oField    As Object
    Local oProfile  As Object
    Local jResposta As Json
    Local cFilBkp   As Character
    Local cFilters  As Character 
    Local nPage     As Numeric
    Local nPageSize As Numeric
    Local nAt       As Numeric
    Local aFilters  As Array
    Local lResponse As Logical
    Local lRet      As Logical
    Local cChaveRes As Character
    Local cResponse As Character
    Local cBranchesCondition  As Character  
    Local lExclusiveQLC As Logical
    lExclusiveQLC := FWModeAccess("QLC", 1) == "E" .And. FWModeAccess("QLC", 2) == "E" .And. FWModeAccess("QLC", 3) == "E" 

    If lExclusiveQLC //Verifica compartilhamento da QLC, se exclusiva, usuario só tem acesso a filial logada
        oProfile := UserProfileProtheusData():new()        
        oProfile:deleteProfile(__cUserId, "CONCILIAD") //Deleta profile do usuario
    EndIf	

    //Inicilaiza variaveis
    oService  := MatchSettingService():getInstance()
    oField    := tcTreatsFilter():new()
    jResposta := JsonObject():new()
    cFilBkp   := cFilAnt
    cFilters  := ""
    aFilters  := {}
    nPage     := 1
    nPageSize := 10
    nAt       := 0
    lResponse := .F.
    cChaveRes := "message"
    cResponse := STR0001 //"Resposta inválida."
    lRet      := .T.
    cBranchesCondition := GetBranchiesForConditional("QLB")

    // Se for exclusívo, o profile já terá sido apagado nas linhas acima
    If !lExclusiveQLC .And. cBranchesCondition == ""
        cResponse := STR0002 +; //"Não há filiais validas na seleção de filiais que podem ser acessadas desta filial, de acordo com seu compartilhamento de tabelas. "
                     STR0003    //"Acesse a rotina por outra filial ou altere sua seleção de filiais"
        lRet := .F.
    EndIf
    
    If lRet
        tcGetHeaders()
        aFilters := tcGetFilters()
        
        If ValType(aFilters) == "A" .And. Len(aFilters) > 0
            nAt := At("=", aFilters[1][2])
            cFilters := AllTrim(SubStr(aFilters[1][2], nAt+1, Len(aFilters[1][2])))
        EndIf

        tcGetPageAndPageSize(@nPage, @nPageSize)

        jResposta:fromJson(oService:getAllMatchSetting(cFilters, nPage, nPageSize, cBranchesCondition))

        IIf(ValType(jResposta:GetJsonText("items")) <> "U",; 
            tcAnswerRest(jResposta, .T.),;    
            tcSetResponse(lResponse, cChaveRes, cResponse, .F.))
    Else
        tcSetResponse(lResponse, cChaveRes, cResponse, .F.)
    EndIf

    //Restaura empresa e filial
    cFilAnt := cFilBkp

    //Limpa array
	FWFreeArray(aFilters)
return
