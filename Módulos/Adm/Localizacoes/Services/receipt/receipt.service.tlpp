#include 'tlpp-core.th'
#include "FWMVCDEF.CH"
#include 'receiptservice.ch'

namespace tr.receipt
using namespace tr.util.receipt
using namespace tr.util
using namespace tr.paymentForm

Static __instance As Object

/*/{Protheus.doc} receiptService
Servicio que contiene la regla de negocio de los recibos
@type class
@version  1
@author luis.aboytes
@since 14/02/2021
/*/
Class receiptService
	Public Method new()
	Public Method getInstance()
	Public Method receiptNumberService()
	Public Method receiptNumberSerieService()
	Public Method lastNumberSerieService()
	Public Method receiptsService()
	Public Method receiptStatusService()
	Public Method receiptsDataService()
	Public Method timbradoPdfService()
	Public Method getCompenFactService()
	Public Method compensaValidService()
	Public Method getreceiptForm()
	Public Method createJson()
	Public Method AddField()
	Public Method validTamA1()
	Public Method dateFormat()
	Public Method receiptRollBack()
	Public Method getDataHdrSrv()
	Public Method f887RotSer() 
EndClass

//-------------------------------------------------------------------
/*/{Protheus.doc} receiptService::new
Constructor de la clase 
@type method
@version  1
@author luis.aboytes
@since 14/02/2021
/*/
Method new() Class receiptService
Return

/*/{Protheus.doc} receiptService::getInstance
Retorna una instancia activa, si no existe crea una nueva
@type method
@version  1
@author luis.aboytes
@since 14/02/2021
@return Object, instancia
/*/
Method getInstance() Class receiptService
	If(__instance == Nil)
		__instance := receiptService():new()
	EndIf
Return __instance

//-------------------------------------------------------------------
/*/{Protheus.doc} receiptService::receiptNumberService
Retorna si el numero de recibo es valido y no esta repetido en la tabla SEL
@type method
@version  1
@author luis.aboytes
@since 14/02/2021
@param jParamsRequest, Jobject, numero de recibo
@return JsonObject, {
   			 			"success": false,
   			 			"message": "Numero de recibo ya en uso, verifique numero"
			 		}
/*/
Method receiptNumberService(jParamsRequest) Class receiptService
	Local oReceiptAdapter	
	Local oResponse 		
	Local oTemp 			

	oReceiptAdapter := receiptAdapter():New('GET')

	oResponse := JsonObject():New()
	oTemp := oReceiptAdapter:valRecNumber("cRecibo",jParamsRequest['receiptnumber'], "")

	oResponse["result"] := .T.
	oResponse["response"] := oTemp

Return oResponse

/*/{Protheus.doc} receiptService::receiptNumberSerieService
Metodo que retorna si el numero de recibo es valido y no esta repetido en la tabla SEL
@type method
@version  1
@author luis.aboytes
@since 14/02/2021
@param jParamsRequest, Jobject, numero de recibo y serie
@return JsonObject, {
    					"success": false,
    					"message": "Numero de recibo ya en uso, verifique numero"
			 		}
/*/
Method receiptNumberSerieService(jParamsRequest ) Class receiptService
	Local oReceiptAdapter 	
	Local oResponse 		
	Local oTemp 			

	oReceiptAdapter := receiptAdapter():New('GET')

	oResponse := JsonObject():New()
	oTemp := oReceiptAdapter:valRecNumber("cRecibo",jParamsRequest['receiptnumber'],jParamsRequest['serie'])

	oResponse["result"] := .T.
	oResponse["response"] := oTemp

Return oResponse

/*/{Protheus.doc} receiptService::lastNumberSerieService
Obtiene el ultimo numero registrado en serie en la tabla SX5 nombre de tabla RN
@type method
@version  1
@author luis.aboytes
@since 16/02/2021
@param paramsRequest, Jobject, serie
@return JsonObject, {
    				 "serie": "A  ",
    				 "receipt": "000002",
    				 "details": {
        						  "success": true,
        						  "message": "Consulta correcta"
   			 					 }
			 		}
/*/
Method lastNumberSerieService (jParamsRequest ) Class receiptService
	Local oReceiptAdapter 
	Local oResponse 	
	Local JTempData		

	oReceiptAdapter := receiptAdapter():New('GET')

	oResponse 	:= JsonObject():New()
	JTempData		:= JsonObject():New()
	JTempData 		:= oReceiptAdapter:lastRN(jParamsRequest['serie'], "")

	oResponse["result"] := .T.
	oResponse["response"] := JTempData

Return oResponse

/*/{Protheus.doc} financialTitlesService::receiptsService 
Metodo que retorna un Json con los recibos de un cliente o clientes
@type method
@version  1
@author luis.aboytes
@since 31/3/2021
/*/
Method receiptsService(jBody , jQueryRequestParams ) Class receiptService
	Local oReceiptAdapter 
	Local oResponse 	
	Local lStatus := !VAZIO(jBody['status']) .Or. (jBody:HasProperty('form') .And. !VAZIO(jBody['form']['mv_par10']))

	oReceiptAdapter := receiptAdapter():New('GET')

	//Indica cual pagina debemos retornar
	If jQueryRequestParams:hasproperty('page')
		oReceiptAdapter:setPage(IIF(lStatus,1,Val(jQueryRequestParams['page'])))
	EndIf

	//Indica el tamaño de la pagina
	If jQueryRequestParams:hasproperty('pageSize')
		oReceiptAdapter:setPageSize(IIF(lStatus,SEL->(LastRec()),Val(jQueryRequestParams['pageSize'])))
	EndIf

	oReceiptAdapter:receiptsAdapter(jBody,"SEL", .T.)

	oResponse := JsonObject():New()
	If oReceiptAdapter:lOk
		oResponse["result"] := .T.
		oResponse["response"] := oReceiptAdapter:getJSONResponse()
	Else
		oResponse := answerErrorFormat(oReceiptAdapter:GetCode(), oReceiptAdapter:GetMessage(), oReceiptAdapter:GetMessage())
	EndIf

	oReceiptAdapter:DeActivate()
	oReceiptAdapter := nil

Return oResponse

/*/{Protheus.doc} receiptService::receiptStatusService() As JsonObject
Metodo que obtiene los estados de los recibos 
@type method
@version  1
@author luis.aboytes
@since 7/4/2021
@return JsonObject, [
    					{
        				"status": ""
    					}
					]
/*/
Method receiptStatusService() Class receiptService
	Local jResponse := JsonObject():New()
	Local jTemp 	:= JsonObject():New()
	Local aArray 	As Array
	Local nCont 	As Numeric
	Local aJson 	As Array
	Local nPos 		As Numeric

	aJson  := {}
	//Obtenemos los estados de un recibo y se asigna a un array
	aArray := getStatusReceipt()

	//Se obtienen los nombres de los estados
	For nCont := 1 to LEN(aArray)
		Aadd(aJson,JsonObject():new())
		nPos := Len(aJson)
		aJson[nPos]["status"] := aArray[nCont][2]
	Next
	//Se forma el Json
	jTemp:set(aJson)
	jResponse["result"] := .T.
	jResponse["response"]:= jTemp

Return jResponse

/*/{Protheus.doc} receiptService::receiptsDataService(jResponse As Jobject) As JsonObject
Metodo que buscara por medio del ID que viene en jResponse los datos correspondientes para aplicar la regla de negocio y obtener los campos (status,total bruto, retenciones, Rc anticipados y total neto)
@type method
@version  1
@author luis.aboytes
@since 8/4/2021
@return JsonObject, {
    "values": [
        {
            "status": "",
            "anticipated": 0,
            "withholdings": 0,
            "id": "",
            "grossTotal": 0,
            "nettotal": 0
        }
    ],
    "receipts": {
        "items": [
            {
                "collector": "",
                "receipt": "",
                "store": "",
                "stampdate": "",
                "generatecfd": "",
                "prefix": "",
                "currency": "",
                "bankaccount": "",
                "bank": "",
                "valcurr1": ,
                "numberreceipt": "",
                "storecode": "",
                "typingdate": "",
                "client": "",
                "branch": "",
                "class": "",
                "taxsheet": "",
                "valuetype": "",
                "date": ""
                "agency": "",
                "typebill": "",
                "cancelled": ,
                "time": "",
                "value": ,
                "id": "",
                "serie": "",
                "installment": ""
            },
            {
                "collector": "",
                "receipt": "",
                "store": "",
                "stampdate": "",
                "generatecfd": "",
                "prefix": "",
                "currency": "",
                "bankaccount": "",
                "bank": "",
                "valcurr1": ,
                "numberreceipt": "",
                "storecode": "",
                "typingdate": "",
                "client": "",
                "branch": "",
                "class": "",
                "taxsheet": "",
                "valuetype": "",
                "date": "",
                "agency": "",
                "typebill": "",
                "cancelled": ,
                "time": "",
                "value": ,
                "id": "",
                "serie": "",
                "installment": ""
            }
        ],
        "hasNext": true
    }
}
/*/
Method receiptsDataService(jDataRec ,jBody )  Class receiptService
	Local jResponse 	:= JsonObject():New()
	Local jDatasService := JsonObject():New()
	Local jDF887Rot	:= JsonObject():New()
	Local jTemp		:= JsonObject():New()
	Local aAux	:= {} As Array
	Local lF887ROT	:= .F. As logical
	Local jJsonUnited 	:= JsonObject():New()
	Local cColor 		As Character
	Local cId 			As Character
	Local aJson,a998Data As Array
	Local aResponse 	As Array
	Local nCont,n998	As Numeric
	Local nTB 			As Numeric
	Local nTR 			As Numeric
	Local nTRa 			As Numeric
	Local nComp 		As Numeric
	Local mv_par06 		:= 1
	Local nDecs 		:= MsDecimais(mv_par06)
	Local cTipoDoc 		As Character
	Local cTipo			As Character
	Local nTotalBruto 	As Numeric
	Local nTotalRet 	As Numeric
	Local nTotalRas 	As Numeric
	Local nTotalNeto 	As Numeric
	Local cSerAnt 		As Character
	Local cRcboAnt 		As Character
	Local cForAnt 		As Character
	Local cLojaAnt 		As Character
	Local cCancelada 	As Character
	Local cCliente 		As Character
	Local cSucursal 	As Character
	Local cEmision 		As Character
	Local cSerie 		As Character
	Local cParcela 		As Character
	Local cNumero 		As Character
	Local cCliOrig 		As Character
	Local cSucOrig 		As Character
	Local cNatureza 	As Character
	Local cCobrador 	As Character
	Local cFecTimb 		As Character
	Local cUuidd 		As Character
	Local cVlmoed1 		
	Local cValor 		
	Local cMoeda 		
	Local cDtDigit 		As Character
	Local cNumRecAnt	As Numeric
	Local cHora			As Character
	Local cGenCFD		As Character
	Local cPode 		As Character
	Local oReceiptAdapter 	As Object
	Local cCheque 		As Character
	Local oTemp			As Object
	Local cTipos As Character
	Local aTipos As Array
	Local nType	As Numeric
	Local cver := ""	
	Local cver1	:= ""		
	Local lCancelada
	local cretgan	
	Local lRecsus := .F.
	local lRecsuslig := .F.
	Local lDifCam    := .F.
	local aReclig 	 := {}
	local cSerligado :=""
	local cRecligado :=""
	local cCompen := ""
	Local lELRECSUS 	As logical
	Local lELSERSUS 	As logical
	Local lSerRec		As logical
	Local dDataFin		As character
	Local lF998BRMCOL 	As logical
	Local jData
	Local oRecAdpAux	As Object
	Local jBodyAux
	Local aJsonFil		As array
	Local aSFR			As array
	Local cPrefixoTemp	As character 
	Local cNumeroTemp	As character
	Local cParcelaTemp	As character
	Local cTipoTemp		As character
	Local cClienteTemp	As character
	Local cLogaTemp		As character
	Local cBancoTemp	As character
	Local cAgenciaTemp	As character
	Local cContaTemp	As character
	Local cTipoDocTemp	As character
	Local cChequeBank	As character
	Local cChequeBranch	As character
	Local cChequeAccount As character

	aResponse 	:= {}
	aJson 		:= {}
	aJsonFil	:= {}
	nCont 		:= 1
	cColor 		:= ""
	cHora		:= ""
	cGenCFD		:= ""
	cCheque		:= ""
	oReceiptAdapter	:= receiptAdapter():New('GET')
	oTemp 		:= JsonObject():New()

	lELRECSUS 	:= SEL->(ColumnPos("EL_RECSUS"))  > 0
	lELSERSUS 	:= SEL->(ColumnPos("EL_SERSUS")) > 0
	lSerRec		:= SuperGetMv("MV_SERREC",.F.,.F.)
	dDataFin	:= GetMV("MV_DATAFIN")
	lF998BRMCOL := ExistBlock("F998BRMCOL") 
	lF887ROT	:= ExistBlock("F887ROT")
	
	cTipos := MVRECANT+"/"+MV_CRNEG
	aTipos := StrTokArr(cTipos, "/")
	
	jBodyAux := jBody

	jData :=  JsonObject():New()
	If Len(jDataRec['items']) > 0
		jBodyAux['initialReceipt'] 	:= jDataRec['items'][1]['receipt']
		jBodyAux['finalReceipt'] 	:= jDataRec['items'][Len(jDataRec['items'])]['receipt']
		oRecAdpAux := receiptAdapter():New('GET')
		oRecAdpAux:setPageSize(SEL->(LastRec()))
		oRecAdpAux:receiptsAdapter(jBodyAux,"SEL",/*lGroup*/,.F.)
		jData['items'] := oRecAdpAux:OJSONOBJ:OJSONOBJ['items']
	else
		
		jData['items'] := {}
	EndIf

	

	nCont := 1
	//Regla de negocio del archivo archivo FINA088.PRW metodo GeraTRB
	WHILE nCont <= LEN (jData['items'])
		nTB 		:= 0
		nTR 		:= 0
		nTRa 		:= 0
		nComp 		:= 0
		cTipoDoc 	:= jData['items'][nCont]['valuetype']
		cTipo 		:= jData['items'][nCont]['typebill']
		cId			:= jData['items'][nCont]['id']
		nTotalBruto := 0
		nTotalRet 	:= 0
		nTotalRas 	:= 0
		nTotalNeto 	:= 0
		cNumRecAnt	:= nCont
		cPode		:= ""
		cCheque		:= ""
		lRecsuslig	:= .F.
		cSerligado 	:= ""
		cRecligado	:= ""
		aSFR 		:= {}

		//Verifica que los titulos pertenezacan a los recibos filtrados en buscar recibo
		//Ya que en la busqueda de titulos no toma en cuenta la loja
		IF ASCAN(jDataRec['items'], {|x|x['id'] == cId}) == 0
			nCont++
			LOOP
		EndIF

		//VldUltOp()
		If cTipoDoc <>  "TJ"
			cCancelada := ""
			cCompen :=""
			cSerAnt 	:= jData['items'][nCont]['serie']
			cRcboAnt 	:= jData['items'][nCont]['receipt']
			If lELRECSUS
				lRecsus 	:= ValidSust(cSerAnt, cRcboAnt, @aReclig)
				If Len(aReclig) > 0
					lRecsuslig := aReclig[1]
					cSerligado := aReclig[2]
					cRecligado := aReclig[3]
				EndIf
			EndIf
			cForAnt 	:= jData['items'][nCont]['client']
			cLojaAnt 	:= jData['items'][nCont]['store']
			cver		:= jData['items'][nCont]['version']
			cretgan	:= jData['items'][nCont]['retgan']
			If cretgan == "S"
				cCancelada := "P"
			Else 
				lCancelada 	:= jData['items'][nCont]['cancelled']
			EndIf
			
			cCliente 	:= jData['items'][nCont]['client']
			cSucursal 	:= jData['items'][nCont]['store']
			cEmision 	:= jData['items'][nCont]['date']
			cSerie 		:= jData['items'][nCont]['serie']
			cParcela 	:= jData['items'][nCont]['installment']
			cNumero 	:= jData['items'][nCont]['receipt']
			cver1		:= jData['items'][nCont]['version']
			cCliOrig 	:= jData['items'][nCont]['client']
			cSucOrig 	:= jData['items'][nCont]['storecode']
			cNatureza 	:= jData['items'][nCont]['time']
			cCobrador 	:= jData['items'][nCont]['collector']
			cHora		:= jData['items'][nCont]['time']

			//Timbrado Mexico
			If cPaisLoc == "MEX"
				cFecTimb 	:= jData['items'][nCont]['stampdate']
				cUuidd 		:= jData['items'][nCont]['taxsheet']
				cGenCFD		:= jData['items'][nCont]['generatecfd']
			EndIf

			If dDataFin >= STOD(jData['items'][nCont]['typingdate'])
				cPode:= "N"
			Endif

			aRegs := {}

			//Ciclo para hacer las sumatorias de los valores "total bruto, retenciones, anticipados, totalneto y status
			While cNumero==cRcboAnt .And. cSerie == cSerAnt .And. cver ==cver1 .and. nCont <= LEN (jData['items'])
				cVlmoed1 	:= jData['items'][nCont]['valcurr1']
				cValor 		:= jData['items'][nCont]['value']
				cMoeda 		:= jData['items'][nCont]['currency']
				cDtDigit 	:= jData['items'][nCont]['typingdate']

				If Subs(cTipoDoc,1,2)=="TB"
					If ctipo $ "NCC|RA"
						cCompen := "S"
					EndIf
					nType := AScanx(aTipos,{|x| ALLTRIM(cTipo) $ ALLTRIM(x)})
					IF nType != 0
						nComp += If( mv_par06 == 1,cVlmoed1,xMoeda(cValor,Max(Val(cMoeda),1),mv_par06,cDtDigit,nDecs+1) )
					Else
						nTB+= If( mv_par06==1,cVlmoed1,xMoeda(cValor,Max(Val(cMoeda),1),mv_par06,cDtDigit,nDecs+1))
					EndIf
					//Diferencia de cambio
					If cPaisLoc $ "ARG|URU"
						If !Empty(jData['items'][nCont]['origkey'])
							aAdd(aSFR, jData['items'][nCont]['origkey'])
						EndIf
					EndIf
				Elseif Subs(cTipoDoc,1,2)$"RI|RG|RB|RS|RR"
					nTR+= If( mv_par06==1,cVlmoed1,xMoeda(cValor,Max(Val(cMoeda),1),mv_par06,cDtDigit,nDecs+1))
				Else

					cPrefixoTemp	:= jData['items'][nCont]['prefix']
					cNumeroTemp		:= jData['items'][nCont]['numberreceipt']
					cParcelaTemp	:= jData['items'][nCont]['installment']
					cTipoTemp		:= jData['items'][nCont]['typebill']
					cClienteTemp	:= jData['items'][nCont]['client']
					cLogaTemp		:= jData['items'][nCont]['store']
					cBancoTemp		:= jData['items'][nCont]['bank']
					cAgenciaTemp	:= jData['items'][nCont]['agency']
					cContaTemp		:= jData['items'][nCont]['bankaccount']
					cTipoDocTemp	:= jData['items'][nCont]['valuetype']
					cChequeBank		:= jData['items'][nCont]['chkbank']
					cChequeBranch	:= jData['items'][nCont]['chqbranch']
					cChequeAccount	:= jData['items'][nCont]['chkaccount']

					//CONTROL DE CONCILACION BANCARIA
					If cPaisLoc != "BRA" .AND. !Empty(jData['items'][nCont]['reconctit']) .and. RecVldConc(jData['items'][nCont])
						cPode := "C" //Conciliado
					EndIf

					If cPode == ""
						IF (IIf(Subs(cTipoDocTemp,1,2)=="RA",.F.,!jData['items'][nCont]['situationtit']$"0 ").OR.jData['items'][nCont]['balancetit']<>jData['items'][nCont]['valuetit'])
							If cPaisLoc $"ARG"
								If RTRIM(cTipoDocTemp) <> "CH"
									cPode:="N"
								Else
									nRet := RecCkSEF(jData['items'][nCont]) //verifica se existe historico ou foi usado na OP
									If nRet == 0
										cCheque	:=  "U"
										cPode	:=	"N"
									Elseif nRet==2
										cCheque	:=	"L"
									Else
										cCheque	:=	"N"
									Endif
								Endif
							Endif
						EndIf
					EndIf

					If Subs(cTipoDoc,1,2)=="RA"
						nTRa+=If( mv_par06==1,cVlmoed1,xMoeda(cValor,Max(Val(cMoeda),1),mv_par06,cDtDigit,nDecs+1))
					Endif

					//Se deja por verificación de front, 
					//para revisar si el recibo tiene cheques - Argentina.
					If cPaisLoc == "ARG" .and. RTRIM(cTipoDocTemp) == "CH"
						Aadd(aJsonFil,JsonObject():new())
						aJsonFil[LEN(aJsonFil)] := jData['items'][nCont]
					EndIf
					
				EndIf
				//Se deja por verificación de front, 
				//para validaciones de México, serán migrados para no usar este arreglo.
				If cPaisLoc == "MEX"
					Aadd(aJsonFil,JsonObject():new())
					aJsonFil[LEN(aJsonFil)] := jData['items'][nCont]
				EndIf

				nCont++
				If nCont <= LEN (jData['items'])
					cNumero 	:= jData['items'][nCont]['receipt']
					cSerie 		:= jData['items'][nCont]['serie']
					cTipoDoc 	:= jData['items'][nCont]['valuetype']
					cTipo 		:= jData['items'][nCont]['typebill']
					cver1		:= jData['items'][nCont]['version']
				EndIf
			End
		EndIf

		nTotalBruto := Round(nTB,nDecs)
		nTotalRet 	:= Round(nTR,nDecs)
		nTotalRas 	:= Round(nTRa,nDecs)
		nTotalNeto 	:= nTB-nComp+nTRa

		//Definicion de status del recibo
		If cPaisLoc == "ARG" .And. cNumRecAnt <= LEN (jData['items'])
			If jData['items'][cNumRecAnt]['cancel'] $ "1"
				cColor := "BR_RED"
			Elseif jData['items'][cNumRecAnt]['versionatu'] $ "0"
				cColor := "BR_BLACK"
			Elseif jData['items'][cNumRecAnt]['versionatu'] $ "1"
				cColor := "BR_GREEN"
			else
				If (jData['items'][cNumRecAnt]['cancelled'])
					cColor := "BR_RED"
				Else
					cColor := "BR_GREEN"
				EndIf
			Endif
		elseif  cPaisLoc == "MEX" .And. cNumRecAnt <= LEN (jData['items'])
			If cCancelada == "P"  
				cColor := "BR_AMARELO"
			Elseif cCompen == "S"
				cColor := "BR_PINK"   
			Elseif jData['items'][cNumRecAnt]['cancelled'] .AND. cCancelada <> "P"	
				cColor := "BR_VERMELHO"
			Elseif EMPTY(jData['items'][cNumRecAnt]['cancelled']) .AND. EMPTY(jData['items'][cNumRecAnt]['stampdate']) .AND. EMPTY(jData['items'][cNumRecAnt]['taxsheet'])
				cColor := "BR_VERDE"
			Elseif !EMPTY(jData['items'][cNumRecAnt]['stampdate']) .AND. !EMPTY(jData['items'][cNumRecAnt]['taxsheet'])
				cColor := "BR_AZUL"
			EndIf
		Else
			//Para los recibos diferentes de ARG y MEXICO
			If (jData['items'][cNumRecAnt]['cancelled'])
				cColor := "BR_VERMELHO"
			Else
				cColor := "BR_VERDE"
			EndIf
		EndIf
		If cPaisLoc $ "ARG|URU"
			lDifCam := Len(aSFR) > 0
			If lDifCam
				cColor := "BR_PINK"
			Endif
		Endif

		//Obtenidos los valores se asignam a un Json para posteriormente hacer un arreglo de objetos
		jDatasService := JsonObject():New()
		jDatasService['id'] 			:= 	cId 
		jDatasService['grossTotal'] 	:= nTotalBruto
		jDatasService['withholdings'] 	:= nTotalRet
		jDatasService['anticipated'] 	:= nTotalRas
		jDatasService['nettotal'] 		:= nTotalNeto
		jDatasService['check'] 			:= cCheque
		jDatasService['pode'] 			:= cPode
		jDatasService['valuetype']		:= jData['items'][cNumRecAnt]['valuetype']
		jDatasService['receipt'] 		:= jData['items'][cNumRecAnt]['receipt']
		jDatasService['serie'] 			:= jData['items'][cNumRecAnt]['serie']
		jDatasService['client']			:= jData['items'][cNumRecAnt]['clientorigin']
		jDatasService['date']			:= IIF(EMPTY(jData['items'][cNumRecAnt]['emissafjt']),jData['items'][cNumRecAnt]['date'],jData['items'][cNumRecAnt]['emissafjt'])
		jDatasService['time']           := jData['items'][cNumRecAnt]['time']
		jDatasService['store']			:= jData['items'][cNumRecAnt]['store']
		jDatasService['branch']			:= jData['items'][cNumRecAnt]['branch']
		jDatasService['version'] 		:= jData['items'][cNumRecAnt]['version']
		jDatasService['taxsheet']		:= jData['items'][cNumRecAnt]['taxsheet']
		jDatasService['class']			:= jData['items'][cNumRecAnt]['class']
		jDatasService['collector'] 		:= jData['items'][cNumRecAnt]['collector']
		jDatasService['prefix']			:= jData['items'][cNumRecAnt]['prefix']
		jDatasService['numberreceipt']	:= jData['items'][cNumRecAnt]['numberreceipt']
		jDatasService['installment']	:= jData['items'][cNumRecAnt]['installment']
		jDatasService['typebill']		:= jData['items'][cNumRecAnt]['typebill']
		jDatasService['validCancelation']   := lRecsus
		jDatasService['validNoCancelation'] := lRecsuslig
		jDatasService['currency'] := jData['items'][cNumRecAnt]['currency']
		If lRecsuslig
			jDatasService['messageCancelation'] :=  STR0004 + cSerligado + "-" + cRecligado +" "+STR0005
		Else
			jDatasService['messageCancelation'] := ""
		EndIf
		if lDifCam
			jDatasService['messageCancelation'] := MsgDifCam(aSFR)
		EndIf
		jDatasService['status'] 		:= setStatusColor(cColor)
		If lELSERSUS
			jDatasService['sersus']		:= jData['items'][cNumRecAnt]['sersus']
		EndIf 
		If lELRECSUS
			jDatasService['recsus']		:= jData['items'][cNumRecAnt]['recsus']
		EndIf
		jDatasService['nameClient']		:= jData['items'][cNumRecAnt]['clientname']
		IF lF998BRMCOL
			a998Ret := ExecBlock("F998BRMCOL",.F.,.F.,{jDatasService['serie'],jDatasService['receipt'],jDatasService['client']})
			For n998 := 1	To LEN(a998Ret)
				jDatasService[a998Ret[n998][4]] := a998Ret[n998][2]
			Next
		ENDIF

		AADD(aResponse,jDatasService)
	End

	//Se genera un objeto de arreglos json
	For nCont := 1 to LEN(aResponse)
		Aadd(aJson,JsonObject():new())
		nPos := LEN(aJson)
		aJson[nPos] := aResponse[nPos]
	Next

	IF lF998BRMCOL .AND. LEN(jData['items']) > 0
		a998Ret := ExecBlock("F998BRMCOL",.F.,.F.,{jDatasService['serie'],jDatasService['receipt'],jDatasService['client']})
		a998Data := {}

		For n998 := 1 to LEN(a998Ret)
			Aadd(a998Data,JsonObject():new())
			nPos := Len(a998Data)
			a998Data[nPos]['label'] := a998Ret[n998][1]
			a998Data[nPos]['property'] := a998Ret[n998][4]
			a998Data[nPos]['visible'] := a998Ret[n998][3]
		Next
	ENDIF

	IF lF887ROT
		aAux := ExecBlock("F887ROT",.F.,.F.)
		jDF887Rot['data'] 	    := JsonObject():New()
		jDF887Rot['actived']	:=.T.
		jDF887Rot['data']['label']		:= aAux[1]
		jDF887Rot['data']['function']	:= aAux[2]
	ENDIF

	//Se asignan los valores de los recibos mas el arreglo de objetos
	jJsonUnited["columns"] := a998Data
	jJsonUnited['clientFunction']:=	jDF887Rot
	jJsonUnited["values"] := aJson
	jJsonUnited["receipts"] := aJsonFil
	jJsonUnited["hasNext"] := jDataRec["hasNext"]
	jJsonUnited["remainingRecords"] := jDataRec["remainingRecords"]
	jTemp:set(aJson)
	jResponse["result"] := .T.
	jResponse["response"] := jJsonUnited

Return jResponse

/*/{Protheus.doc} reemplaceArrayReceipt
Unificacion a un Json solamente
@type function
@version  1
@author luis.aboytes
@since 25/5/2021
@param jData, JsonObject, Datos originales
@param jArray, JsonObject, Json donde se unificara
/*/
Static Function  reemplaceArrayReceipt(jData ,jArray)
	Local jResponse 
	Local nCont 	
	Local nCont2 	
	Local aJson 	

	aJson := {}

	For nCont := 1 to LEN(jArray)
		For nCont2 := 1  to LEN(jData['items'])
			If jData['items'][nCont2]['id'] == jArray[nCont]['id']
				AADD(aJson,JsonObject():New())
				aJson[LEN(aJson)] := jData['items'][nCont2]
			EndIf
		Next
	Next

	jResponse := aJson
Return jResponse

/*/{Protheus.doc} receiptService::timbradoPdfService(jBody As JsonObject) As JsonObject
Metodo que verifica en la tabla SEL dado los parametros como cliente, recibo, tienda y serie si un recibo esta timbrado en la DB para posteriormente si retorna un True 
por medio de la FINA998 mande a llamar el metodo para imprimir el PDF
@type method
@version  1
@author luis.aboytes
@since 7/6/2021
@return JsonObject, {
    					"success": true,
    					"imprPdf": true
					}
					o en caso de error
					{
    					"code": "400",
    					"message": "Solo es posible Imprimir recibos Timbrados.",
    					"detailedMessage": "El numero de recibo '000006' serie 'A' no esta timbrado.",
    					"success": false
					}
/*/
Method timbradoPdfService(jBody )Class receiptService
	Local oReceiptAdapter 	
	Local lIsTimbDB  		
	Local jError			
	Local jResponse			
	Local jTemp				

	oReceiptAdapter	:= receiptAdapter():New('GET')
	jError 			:= JsonObject():New()
	jResponse		:= JsonObject():New()
	jTemp			:= JsonObject():New()

	lIsTimbDB := oReceiptAdapter:isTimbDB(jBody["client"],jBody["receipt"],jBody["store"],jBody["serie"])

	If lIsTimbDB == .F.
		jError := answerErrorFormat(400, "Solo es posible Imprimir recibos Timbrados.", "El numero de recibo '"+jBody["receipt"]+"' serie '"+jBody["serie"]+"' no esta timbrado.")
		Return jError
	Else
		//Se prepara la respuesta
		jTemp["success"] := .T.
		jTemp["imprPdf"] := .T.

		//Se prepara el json final
		jResponse["result"] := .T.
		jResponse["response"] := jTemp
	EndIf

Return jResponse

/*/{Protheus.doc} getCompenFactService
Metodo encargado de obtener los registros a compensar
@type class
@version  1
@author luis.aboytes
@since 4/4/2022
/*/
Method getCompenFactService (jBody)Class receiptService
	Local 	oReceiptAdapter 		
	Local 	jResponse, jTemp		
	Local 	aResponse
	Local 	cMensaje	As Character

	jResponse		:= JsonObject():New()	
	jTemp			:= JsonObject():New()
	oReceiptAdapter	:= receiptAdapter():New('GET')
	cMensaje 		:= ""

	//Se obtienen los titulos a compensar
	aResponse:=oReceiptAdapter:getCompenData(jBody,@cMensaje)

	jTemp['compensations'] := aResponse
	jTemp['hasCompen'] 	:= IIF(!VAZIO(aResponse),.T.,.F.)//Json que determinara si se mostrara la ventana de las compensaciones 
	jTemp['message']	:= 	cMensaje
	jTemp['sameClient']	:= IIF(VAZIO(cMensaje),.F.,.T.)

	jResponse["result"] := .T.
	jResponse['response'] := jTemp

Return jResponse


/*/{Protheus.doc} receiptService::compensaValidService
Metodo que realizara retornara los mensajes de advertencia dependiendo la cantidad de titulos a compensar 
@type method
@version  1
@author luis.aboytes
@since 5/4/2022
/*/
Method compensaValidService (jBody) Class receiptService
	Local 	oReceiptAdapter As Object		
	Local 	cMens	:=""	As Character
	Local 	jResponse,jTemp	
	Local 	nCompensa := 0	As Numeric	
	Local 	nCont			As Numeric

	jResponse		:= JsonObject():New()	
	jTemp			:= JsonObject():New()
	oReceiptAdapter	:= receiptAdapter():New('GET')

	If !VAZIO(jBody['items']) 
		IF LEN(jBody['items'])  > 1
			cMens := STR0002 //Hay selección de más de una compensación. En el CFDI de REP, se generará un solo nodo Pago, del total, por operaciones de factoraje financiero.
		ELSEIF LEN(jBody['items']) == 1
			cMens := STR0003 //¿Está de acuerdo en generar nodo Pago de la compensación en el CFDI de REP?
		ENDIF
	ELSE
		cMens := STR0001 //No hay selección de compensación. En el CFDI de REP, no se generará nodo Pago por operaciones de factoraje financiero.
	ENDIF

	FOR nCont := 1 To LEN(jBody['items'])
		nCompensa += jBody['items'][nCont]['value']
	NEXT

	jTemp['message'] 		:= cMens //Se asigna el mensaje al json
	jTemp['compensation']	:= nCompensa //Valor a compensar
	
	jResponse["result"] := .T.
	jResponse['response'] := jTemp
Return jResponse

/*/{Protheus.doc} ValidSust
Validación para identificar si el recibo fue sustituto
@type function
@author José Gonzáñez
@since 23/02/2022
@version 1.0
@param cSerSus, caracter, Serie el Recibo cancelado.
@param cRecSus, caracter, Folio de Recibo cancelado.
@param aReclig, array, datos del recibo sustituto
/*/
Function ValidSust(cSerSEL, cRecSEL, aReclig)
	Local cAliasSEL := getNextAlias()
	Local nCount    := 0
	Local lExiste   := .F.

	Default cSerSEL  := ""
	Default cRecSEL  := ""
	Default aReclig  := {}


	BeginSql alias cAliasSEL
		SELECT EL_SERIE, EL_RECIBO, EL_UUID, EL_FECTIMB
		FROM %table:SEL% SEL
		WHERE SEL.EL_FILIAL = %xFilial:SEL% 
		AND EL_SERSUS = %exp:cSerSEL% 
		AND EL_RECSUS = %exp:cRecSEL% 
		AND SEL.%notDel%
	EndSql

	count to nCount

	aReclig := {}
	If nCount > 0
		(cAliasSEL)->(DbGoTop())
		If AllTrim((cAliasSEL)->EL_UUID) <> '' .and. AllTrim((cAliasSEL)->EL_FECTIMB) <> ''
			lExiste := .T.
		Else
			aadd(aReclig, .T.)
			aadd(aReclig, (cAliasSEL)->EL_SERIE)
			aadd(aReclig, (cAliasSEL)->EL_RECIBO)
		EndIf
	EndIf

	(cAliasSEL)->(DbCloseArea())

Return lExiste

/*/{Protheus.doc} MsgDifCam
	Función encargada de dar tratamiendo a las observaciones encontradas en el proceso a borrado/anulado
	de un recibo de cobro con status Diferencia cambiaria.
	@type function
	@author eduardo.manriquez
	@since 11/08/2022
	@version 1.0
	@param aDifCam,array, Arreglo que contine las diferencias cambiarias.
	@return cMsg, caracter, Mensaje con el tratamiento realizado.
/*/
Function MsgDifCam(aDifCam)
	Local cCRLF	    := (chr(10)+chr(13))
	Local nI        := 1
	Local cMsg      := ""
	DEFAULT aDifCam := {}
	
	cMsg := STR0006 //"Existen las siguientes diferencias cambiarias vinculadas al recibo: "

	For nI := 1 to Len(aDifCam)
	   cMsg += cCRLF +"- "+aDifCam[nI]
	Next nI
	cMsg += cCRLF+STR0007 //"Para continuar con el proceso, por favor elimine primero las diferencias cambiarias relacionadas desde la rutina Diferencia Cambio Cta Por cobrar(FINA074)."

Return cMsg

/*/{Protheus.doc} getreceiptForm
	Función encargada de generar el json con los campos del encabezado para el recibo.
	@type function
	@author raul.medina
	@since 02/12/2022
	@version 1.0
	@param 
	@return oResponse, json, json con los campos del encabezado del recibo.
/*/
Method getreceiptForm() Class receiptService
Local oResponse 	:= JsonObject():New()
Local oReceiptForm 	:= JsonObject():new()
Local oModel	:= FwLoadModel("FINA887")
Local oStruFJT		:= Nil 	As object
Local aJson			:= {}	As array
Local lSerie 		:= .F.	As logical
Local aCposNo 		:= {} 	As array
Local jCposNo		:= Nil 	As json
Local aCposRec 		:= {} 	As array
Local jCposRec		:= Nil 	As json
Local nX			:= 0	As numeric
Local aFields		:= {}	As array
Local nPos			:= 0	As numeric
Local nOrden		:= 0	As numeric
Local lEncabez		:= .F.	As logical
Local cSpaceSer		:= ""	As character
Local cIniNum		:= ""	As character
Local aArea			:= {}	As character
Local lLoop			:= .T.	As logical
Local cNumAux		:= ""	As character

	oModel:SetOperation( MODEL_OPERATION_INSERT )
	oModel:ACTIVATE()

	SetFunName("FINA998")
	lSerie := SuperGetMv("MV_SERREC",.F.,.F.) 

	//Obtiene la estructura de la tabla FJT.
	oStruFJT := FWFormStruct( 2, 'FJT' ,,.F.) //2-View

	//Campos que no son considerados para mostrar en el encabezado
	aCposNo := {'FJT_FILIAL', 'FJT_DTDIGI', 'FJT_VERSAO', 'FJT_VALDOC', 'FJT_VALBX', 'FJT_VALRA', 'FJT_VLRRET', 'FJT_CANCEL', 'FJT_VERATU', 'FJT_SDOC' }
	
	//Campos del encabezado que deben ser considerados
	aCposRec := {'FJT_SERIE','FJT_RECIBO', 'FJT_EMISSA', 'FJT_CLIENT', 'FJT_LOJA', 'FJT_NATURE'}


	//Creación de los objetos json.
	jCposNo 	:= self:createJson(aCposNo) 	//Objeto json con campos que no son considerados para el encabezado
	jCposRec 	:= self:createJson(aCposRec) 	//Campos que deben ser considerados en el encabezado

	//Se obtiene el arreglo de campos
	aFields	:= oStruFJT:GetFields()

	nOrden := 8
	//Se procesan los campos
	For nX := 1 to Len(aFields)
		
		//Si no es un campo de los que no se deben mostrar en pantalla es considerado.
		If !(jCposNo:hasProperty(AllTrim(aFields[nX,1])))
			
			lEncabez := .F.
			//Si es un campo que debe ir a pantalla lo pone visible.
			If jCposRec:hasProperty(AllTrim(aFields[nX,1])) 
				lEncabez := .T.
			ElseIf X3Uso(GetSx3Cache(AllTrim(aFields[nX,1]),"X3_USADO"))
				lEncabez := .T.
			EndIf

			//Creación del json correspondiente al campo que irá a pantalla.
			If lEncabez
				aAdd(aJson,self:AddField(aFields[nX]))
				nPos := Len(aJson)
					aJson[nPos]['visible' ] := .T.
					aJson[nPos]['showRequired'] := IIF(aJson[nPos]['required'],.T.,.F.)
					aJson[nPos]['mask'] := ""
				Do Case
					Case AllTrim(aFields[nX,1]) == "FJT_SERIE"
						aJson[nPos]['order' ] 		:= 1
						aJson[nPos]['gridColumns' ]	:= 1
					Case AllTrim(aFields[nX,1]) == "FJT_RECIBO"
						aJson[nPos]['order' ] := 2
						aJson[nPos]['gridColumns']	:= 2 
							If !Empty(aJson[nPos]['value']) 
								cSpaceSer := Space(Getsx3Cache( "FJT_SERIE" , 'X3_TAMANHO' ))
								aArea := GetArea()
								DbSelectArea("FJT")
								FJT->(DbSetOrder(1))
								While lLoop //Se busca el siguiente número no usado
									cIniNum := aJson[nPos]['value']
									If !(FJT->(DbSeek(xFilial("FJT") + cSpaceSer + cIniNum )))
										Exit
									EndIf
									ConfirmSX8()
									lLoop := Iif(!Empty(cNumAux),!(cIniNum==cNumAux),Iif(Empty(cIniNum),.F.,.T.)) //Si el ciclo ha pasado más de una vez se verifica que no esté validando el mismo número
									cNumAux := cIniNum
								Enddo
								RestArea(aArea)
								aJson[nPos]['value'] := cIniNum
							EndIf 
					Case AllTrim(aFields[nX,1]) == "FJT_EMISSA"
						aJson[nPos]['order'] := 3
					Case AllTrim(aFields[nX,1]) == "FJT_CLIENT"
						aJson[nPos]['order'] 		:= 4
						aJson[nPos]['gridColumns']	:= 2
					Case AllTrim(aFields[nX,1]) == "FJT_LOJA"
						aJson[nPos]['order'] 		:= 5
						aJson[nPos]['gridColumns']	:= 1	
					Case AllTrim(aFields[nX,1]) == "FJT_NOME"
						aJson[nPos]['order'] 		:= 6
						aJson[nPos]['gridColumns']	:= 3
					Case AllTrim(aFields[nX,1]) == "FJT_NATURE"
						aJson[nPos]['order'] := 7
					Case AllTrim(aFields[nX,1]) == "FJT_NIT"
						aJson[nPos]['order'] := nOrden
						nOrden++
						aJson[nPos]['mask'] := Substr(Alltrim(Replace(GetSX3Cache(aFields[nX,1],"X3_PICTURE")," ","")),3)
					OTHERWISE
						aJson[nPos]['order'] := nOrden
						nOrden++
				EndCase
			EndIf

		EndIf

	Next
	oModel:DeActivate()
	oReceiptForm:set(aJson)

	oResponse['result'] := .T.
	oResponse[ 'response' ] := oReceiptForm

Return oResponse

/*/{Protheus.doc} getreceiptForm
	Función encargada generar un json con el campo que va a ser procesado
	@type function
	@author raul.medina
	@since 02/12/2022
	@version 1.0
	@param aField, array, arreglo del campo a ser procesado, obtenido de la función FWFormStruct
	@return oField, json, json del campo del encabezado para el recibo.
/*/
Method AddField(aField As Array) Class receiptService
Local oField	:= JsonObject():new()
Local oModel	:= FwLoadModel("FINA887")
Local oMdlFJT	:= oModel:GetModel('FJT_MASTER'):oFormModelStruct
Local cCampo 	:= ""	As character
Local cTipo		:= ""	As character
Local nTamanho	:= 0	As numeric
Local cTitulo	:= ""	As character
Local cValid	:= ""	As character
Local cVldUser	:= ""	As character
Local aOptions	:= {}	As array
Local nOptions	:= 0	As numeric
Local nY		:= 0	As numeric
Local aCombo	:= {}	As array
Local cRelacao	:= ""	As character
Local cX3_F3	:= ""	As character
Local nGridCol	:= 1	As numeric
Local cX3_Tipo	:= ""	As character
Local cFormatd := ""	As character
Local cFordat := UPPER(GetPvProfString(GetEnvServer(), "DateFormat", "undefined", GetAdv97()))
Local lRecMvc   := SuperGetMv("MV_RECMVC",.F.,.F.)

	oModel:SetOperation( MODEL_OPERATION_INSERT )
	oModel:ACTIVATE()
	//Campo que está siendo procesado
	cCampo := aField[1]

	//Se obtiene el tipo
	cX3_Tipo := Getsx3Cache( cCampo,'X3_TIPO' )

	//Se verifica el tipo y tamaño del campo
	Do Case
		Case cX3_Tipo == 'C'
			cTipo 		:= 'string'
			nTamanho 	:= Getsx3Cache( cCampo,'X3_TAMANHO' )
		Case cX3_Tipo == 'D'
			cTipo 		:= 'date'
			nTamanho 	:= Getsx3Cache( cCampo,'X3_TAMANHO' )
			IF cFordat == "AMERICAN"
				cFormatd := 'mm/dd/yyyy' 
			EndIF
			IF cFordat == "DEFAULT"
				cFormatd := 'dd/mm/yyyy'
			EndIF
		Case cX3_Tipo == 'N'
			cTipo 		:= 'currency'
			nTamanho 	:= Getsx3Cache( cCampo,"X3_TAMANHO" ) - ( Getsx3Cache( cCampo,"X3_DECIMAL" ) +1)
		Case cX3_Tipo == 'M'
			cTipo 		:= 'string'
			nTamanho 	:= 80
		Case cX3_Tipo == 'L'
			cTipo 		:= 'boolean'
			nTamanho 	:= 1
	EndCase

	//Validaciones y titulo
	cTitulo 	:= Alltrim(FWX3Titulo(cCampo))
	cValid 		:= Alltrim(Getsx3Cache(cCampo,'X3_VALID'))
	cVldUser 	:= Alltrim(GetSX3Cache(cCampo,"X3_VLDUSER"))

	//Validaciones del usuario
	If !Empty(cVldUser)
		cValid += IIf( Empty(cValid), "", ".And.") + cVldUser
	EndIf
	
	//Si el campo tiene opciones las agrega al json.
	nOptions := Len(aField[13])
	If nOptions > 1
		For nY := 1 to nOptions
			Aadd(aOptions,JsonObject():new())
			If Alltrim(aField[13][nY])<>''
				aadd( aCombo ,separa(aField[13][nY], "=") )
				aOptions[nY]['value'] :=  Alltrim(aCombo[nY][1])
				aOptions[nY]['label'] := aCombo[nY][2]
			EndIf
		Next
		oField['options' ]	:=  aOptions
	EndIf

	oField['maxLength' ] 			:= 	nTamanho
	oField['decimalsLength' ] 		:= 	Getsx3Cache( cCampo,"X3_DECIMAL" )
	oField['thousandMaxlength' ] 	:= 	nTamanho
	oField['label' ] 				:=	cTitulo
	oField['valid' ] 				:=  cValid
	oField['campo' ] 				:=  cCampo
	oField['property' ] 			:=	lower(Alltrim(substr(cCampo,at("_",cCampo)+1)))
	oField['required' ] 			:=	oMdlFJT:getproperty(cCampo,MODEL_FIELD_OBRIGAT)
	oField['value'] 				:= ''
	oField['visible' ] 				:= .F.
	oField['format' ] 			 	:= cFormatd
	
	//Verifica los campos que tienen un inicializador.
	cRelacao := GetSX3Cache(cCampo,"X3_RELACAO")
	If aField[6] == "COMBO"
		oField['value' ] 	:= alltrim(IIF(VAZIO(cRelacao),"",oModel:GetModel("FJT_MASTER"):GetValue(cCampo)))	
	Else
		If Alltrim(cRelacao) <> ''
			If cTipo == 'date'
				oField['value'] := self:dateFormat(oModel:GetModel("FJT_MASTER"):GetValue(cCampo))
			Else
				If cCampo == "FJT_RECIBO" .And. !lRecMvc
					oField['value'] :=  Alltrim(InitPad(cRelacao))
				Else
					oField['value'] := Alltrim(oModel:GetModel("FJT_MASTER"):GetValue(cCampo))
				EndIF
			EndIf
		EndIf
		oField['type' ] 	:= cTipo
	Endif
	oField['advplView']:=.F.
	//Verifica los campos que tienen una consulta estandar.
	cX3_F3 := Alltrim(Getsx3Cache( cCampo,'X3_F3' ))
	If cX3_F3 <> ''
		//Para el campo de cliente que tiene una extensión muy grande se usa la consulta páginada.
		If cCampo == "FJT_CLIENT" 
			oField['searchService' ]  := '/api/v1/totvsRecibos/clients1'
		Else
			oField['optionsService' ]  := "/api/v1/totvsRecibos/catalogs/" + cX3_F3
		EndIf
		oField['catalog']:= cX3_F3
		oField['advplView']:=.T.
	EndIf

	
	Do Case
		Case cX3_Tipo == "D"
			nGridCol := 2
		Case aField[6] == "COMBO"
			nGridCol := 2
		Case cX3_F3 <> ''
			nGridCol := 2
		Case nTamanho >= 20
			nGridCol := 3
		Case nTamanho >= 6
			nGridCol := 2
	EndCase

	oField['gridColumns' ]	:=	nGridCol

	//Deshabilita los campos visuales.
	If Alltrim(Getsx3Cache(cCampo,"X3_VISUAL")) == "V" .or. !oModel:GetModel('FJT_MASTER'):CansetValue(cCampo)
		oField['disabled' ]:= 	.T.
	Else
		oField['disabled' ]:= 	.F.
	EndIf	
	oModel:DeActivate()
Return oField

/*/{Protheus.doc} createJson
	Función utilizada para generar un objeto json utilizado para validar existencia de campos.
	@type  Method
	@author raul.medina
	@since 02/12/2022
	@param aJsonF - arreglo con los campos a ser considerados para el objeto json.
	@return Json - Json con los campos
	/*/
Method createJson(aJsonF As Array) Class receiptService
Local json              As json
Local nX        := 0    As numeric

    json := JsonObject():New()

	For nX := 1 To Len(aJsonF)
		json[aJsonF[nX]] := ''
    Next

Return Json


/*/{Protheus.doc} dateFormat
Regresa fechas en el formato esperado por el front
@type Function
@version  
@author Raúl Ortiz
@since 15/12/2022
/*/
Method dateFormat(dDate As date) Class receiptService
Local cDate := "" As character

	If ValType(dDate) == "D"
		cDate := StrZero(Year(dDate),4) + "-" + StrZero(Month(dDate),2)  + "-" + StrZero(Day(dDate),2)
	EndIf

Return cDate

/*/{Protheus.doc} receiptRollBack
Metodo utilizado para inicializar realizar el llamado el rollback cuando hay un inicializador
@type Method
@author Raúl Ortiz
@since 26/12/2022
/*/
Method receiptRollBack() Class receiptService
Local lSerie :=	.F. As logical
Local oResponse 
Local jTemp 	

	oResponse 	:= JsonObject():New()
	jTemp		:= JsonObject():New()

	If !Empty(GetSx3Cache("FJT_RECIBO","X3_RELACAO"))
		FJT->(RollBackSX8())
	EndIf

	jTemp["success"] 		:= .T.
	oResponse["result"] 	:= .T.
	oResponse["response"] 	:= JTemp

Return oResponse

/*/{Protheus.doc} RecVldConc
Función para retornar si existe conciliacion bancaria.
@type Function
@version  1
@author raul.medina
@since 23/02/2023
@return lConc, logico, indica si existen conciliaciones bancarias.
/*/

Static Function RecVldConc(aSE5)
Local lConc			As logical
Local aArea			As array

Default aSE5 := {}

	lConc 	:= .F.

	If aSE5['recpagtit'] == "P" .Or. (aSE5['recpagtit'] == "R" .And. !(aSE5['typetit'] $ MVCHEQUE))
		If aSE5['banktit'] <> aSE5['bank'] .And. aSE5['agencytit'] <> aSE5['agency'] .And. aSE5['bankaccounttit'] <> aSE5['bankaccount']  
			lConc 	:= .F.
		EndIf
	Else
		If aSE5['chkbanktit'] <> aSE5['bank'] .And. aSE5['chqbranchtit'] <> aSE5['agency'] .And. aSE5['chkaccounttit'] <> aSE5['bankaccount'] 
			lConc 	:= .F.
		EndIf	
	EndIf

	If cPaisLoc == "ARG"
		lConc := .T.	
	Else
		aArea 	:= GetArea()
		dbSelectArea("FJG") // extractos bancarios FINA472
		FJG->(dbSetOrder(2))
		If FJG->(MsSeek(xFilial("FJG")+"SE5"+StrZero(aSE5['recnotit'],TamSx3("FJG_REGCON")[1],0))) 
			lConc := .T.
		EndIf
		RestArea(aArea)
	EndIf

Return lConc

/*/{Protheus.doc} RecCkSEF
Función para retornar las validaciones del estatus de cheque
@type Function
@version  1
@author raul.medina
@since 23/02/2023
@return nRet, numerico, 
/*/
Static function RecCkSEF(aSEF)
Local nRet 		:= 2
Local aArea 	:= {}

Default aSEF := {}

	If !Empty(aSEF['statuschq'])
		aArea := GetArea()
		If aSEF['statuschq'] <> "00"
			If aSEF['statuschq'] <> "01"
			   nRet := 0
			Elseif aSEF['statuschq'] == "01" .and. FRF->(dbSeek(xFilial("FRF")+PADR(aSEF['bankchq'], GetSx3Cache("EF_BANCO","X3_TAMANHO"))+PADR(aSEF['agencychq'], GetSx3Cache("EF_AGENCIA","X3_TAMANHO"))+PADR(aSEF['accountchq'], GetSx3Cache("EF_CONTA","X3_TAMANHO"))+PADR(aSEF['prefixchq'], GetSx3Cache("EF_PREFIXO","X3_TAMANHO"))+PADR(aSEF['numberchq'], GetSx3Cache("EF_NUM","X3_TAMANHO"))))
   	      		nRet := 0
   	   		Else
   	   			nRet := 1
			Endif
		Else
			If FRF->(dbSeek(xFilial("FRF")+PADR(aSEF['bankchq'], GetSx3Cache("EF_BANCO","X3_TAMANHO"))+PADR(aSEF['agencychq'], GetSx3Cache("EF_AGENCIA","X3_TAMANHO"))+PADR(aSEF['accountchq'], GetSx3Cache("EF_CONTA","X3_TAMANHO"))+PADR(aSEF['prefixchq'], GetSx3Cache("EF_PREFIXO","X3_TAMANHO"))+PADR(aSEF['numberchq'], GetSx3Cache("EF_NUM","X3_TAMANHO"))))
				nRet := 0
			Else
				nRet := 2
			Endif
		EndIf
		RestArea(aArea)	
	EndIf

Return nRet

/*/{Protheus.doc} receiptService::getDataHdrSrv
Metodo que da estructura al json que contiene la informacion del encabezado del recibo a visualizar
@type method
@version  1
@author luis.aboytes
@since 6/2/2024
/*/
Method getDataHdrSrv(jBody) Class receiptService
Local oResponse := JsonObject():New() As Object
Local oAux 		:= JsonObject():New() As Object
Local oStruFJT	:= FWFormStruct( 2, 'FJT' ,,.F.) As object //Obtiene la estructura de la tabla FJT. - 2-View 	
Local oModel	:= FwLoadModel("FINA887") As Object
Local aFields	:= {} As Array
Local nCont 	:= 0  As Numeric
Local cProperty := "" As Character
Local cTipoDato := "" As Character
Local aArea		:= {} As Array

oAux["items"] := {}
AADD(oAux["items"],JsonObject():New())
//Se obtiene el arreglo de campos de la tabla FJT
aFields	:= oStruFJT:GetFields()

If !jBody:HasProperty('version') .Or. Empty(jBody['version'])
	jBody['version'] := "00"
EndIf

aArea := GetArea()
DbSelectArea("FJT")
FJT->(DbSetorder(1)) //FJT_FILIAL+FJT_SERIE+FJT_RECIBO+FJT_VERSAO                                                                                                                    
IF FJT->(MSSeek(xFilial("FJT")+PADR(jBody['serie'], GetSx3Cache("FJT_SERIE","X3_TAMANHO"))+PADR(jBody['number'], GetSx3Cache("FJT_RECIBO","X3_TAMANHO"))+PADR(jBody['version'], GetSx3Cache("FJT_VERSAO","X3_TAMANHO"))))
	oModel:SetOperation(MODEL_OPERATION_VIEW)
	oModel:ACTIVATE()

	FOR nCont := 1 To Len(aFields)
		cProperty := lower(Alltrim(substr(aFields[nCont][1],AT("_",aFields[nCont][1])+1)))
		cTipoDato := oModel:GetModel('FJT_MASTER'):oFormModelStruct:GetProperty(aFields[nCont][1],4)
		IF cTipoDato == "D"
			oAux["items"][1][cProperty] := self:dateFormat(oModel:GetValue('FJT_MASTER',aFields[nCont][1]))	
		ELSE
			oAux["items"][1][cProperty] := Alltrim(oModel:GetValue('FJT_MASTER',aFields[nCont][1]))
		ENDIF
	NEXT nCont
ELSE
	DbSelectArea("SEL")
	SEL->(DbSetOrder(8)) //EL_FILIAL+EL_SERIE+EL_RECIBO+EL_TIPODOC+EL_PREFIXO+EL_NUMERO+EL_PARCELA+EL_TIPO  
	IF SEL->(MsSeek(xFilial("SEL")+PADR(jBody['serie'], GetSx3Cache("EL_SERIE","X3_TAMANHO"))+PADR(jBody['number'], GetSx3Cache("EL_RECIBO","X3_TAMANHO"))))  
		FOR nCont := 1 To Len(aFields)
			cProperty := lower(Alltrim(substr(aFields[nCont][1],AT("_",aFields[nCont][1])+1)))
			oAux["items"][1][cProperty] := ""
		NEXT nCont
		oAux['items'][1]['filial'] := Alltrim(SEL->EL_FILIAL)
		oAux['items'][1]['dtdigi'] := self:dateFormat(SEL->EL_DTDIGIT)
		oAux['items'][1]['serie']  := Alltrim(SEL->EL_SERIE)
		oAux['items'][1]['recibo'] := Alltrim(SEL->EL_RECIBO)
		oAux['items'][1]['versao'] := "00"
		oAux['items'][1]['emissa'] := self:dateFormat(SEL->EL_EMISSAO)
		oAux['items'][1]['nature'] := Alltrim(SEL->EL_NATUREZ)
		oAux['items'][1]['client'] := Alltrim(SEL->EL_CLIORIG)
		oAux['items'][1]['loja']   := Alltrim(SEL->EL_LOJA)
		oAux['items'][1]['veratu'] := "1"
	ENDIF
ENDIF

oResponse["result"] 	:= .T.
oResponse['response'] := oAux['items'][1]

oModel:DeActivate()
DbCloseArea()
RestArea(aArea)

Return oResponse


/*/{Protheus.doc} receiptService::f887RotSer
Servicio para la ejecución correcta de la funcion del PE F887ROT
@type method
@version  1
@author luis.aboytes
@since 25/6/2024
/*/
Method f887RotSer(oParams) Class receiptService
	Local oResponse As Object
	Local jresp	:= JsonObject():New()
	Local cBranch := '', cSerie:= '', cRecibo:= '', cVersion := '', cTipodoc := '', cPrefixo := '' , cNumero := '', cParcela := '' , cTipo := '' As Character
	Local aRet	:= {}
	Default oParams := Nil

	IF oParams <> Nil
		IF !VAZIO(oParams['function'])
			cBranch := PADR(ALLTRIM(oParams['receipt']['branch'])	,GetSx3Cache("FJT_FILIAL","X3_TAMANHO"))
			cSerie  := PADR(ALLTRIM(oParams['receipt']['serie'])	,GetSx3Cache("FJT_SERIE ","X3_TAMANHO"))
			cRecibo := PADR(ALLTRIM(oParams['receipt']['receipt'])	,GetSx3Cache("FJT_RECIBO","X3_TAMANHO")) 
			cVersion:= PADR(IIF(VAZIO(ALLTRIM(oParams['receipt']['version'])),"00",ALLTRIM(oParams['receipt']['version']))	,GetSx3Cache("FJT_VERSAO","X3_TAMANHO")) 

			FJT->(DbSetorder(1)) //FJT_FILIAL+FJT_SERIE+FJT_RECIBO+FJT_VERSAO
			IF FJT->(MSSeek(cBranch+cSerie+cRecibo+cVersion))
				aRet := ExecBlock(oParams['function'],.F.,.F.,{"FJT"})
				FJT->(dbCloseArea())
			ELSE
				cBranch := PADR(ALLTRIM(oParams['receipt']['branch'])	,GetSx3Cache("EL_FILIAL","X3_TAMANHO"))
				cRecibo := PADR(ALLTRIM(oParams['receipt']['receipt'])	,GetSx3Cache("EL_RECIBO","X3_TAMANHO")) 
				cTipoDoc:= PADR(ALLTRIM(oParams['receipt']['valuetype']),GetSx3Cache("EL_TIPODOC","X3_TAMANHO")) 
				cPrefixo:= PADR(ALLTRIM(oParams['receipt']['prefix'])	,GetSx3Cache("EL_PREFIXO","X3_TAMANHO")) 
				cNumero	:= PADR(ALLTRIM(oParams['receipt']['numberreceipt']),GetSx3Cache("EL_NUMERO","X3_TAMANHO")) 
				cParcela:= PADR(ALLTRIM(oParams['receipt']['installment'])	,GetSx3Cache("EL_PARCELA","X3_TAMANHO")) 
				cTipo	:= PADR(ALLTRIM(oParams['receipt']['typebill'])	,GetSx3Cache("EL_TIPO","X3_TAMANHO")) 
				SEL->(DBSetOrder(1)) //EL_FILIAL+EL_RECIBO+EL_TIPODOC+EL_PREFIXO+EL_NUMERO+EL_PARCELA+EL_TIPO+EL_VERSAO
				IF SEL->(ColumnPos("EL_POSTAL"))>0
					SEL->(MSSeek(cBranch+cRecibo+cTipoDoc+cPrefixo+cNumero+cParcela+cTipo+cVersion))
				ELSE
					SEL->(MSSeek(cBranch+cRecibo+cTipoDoc+cPrefixo+cNumero+cParcela+cTipo))
				ENDIF
				aRet := ExecBlock(oParams['function'],.F.,.F.,{"SEL"})
				SEL->(dbCloseArea())
			ENDIF

			IF aRet[1] 
				jresp['success'] :=  .T.
				jresp['message'] :=	IIF(VAZIO(aRet[2]),STR0012,aRet[2]) //STR0012 - "PE F887ROT Ejecutado"
			else
				jresp['success'] :=  .F.
				jresp['message'] :=	IIF(VAZIO(aRet[2]),STR0012,aRet[2]) //STR0012 - "PE F887ROT Ejecutado"
			EndIF

		ELSE
			jresp['success'] :=  .F.
			jresp['message'] :=	STR0013 //STR0013 - "La función del PE F887ROT no fue informada"
		ENDIF
	EndIF
 
	oResponse := JsonObject():New()
	oResponse["result"] := .T.
	oResponse["response"] := jresp
	
Return oResponse
