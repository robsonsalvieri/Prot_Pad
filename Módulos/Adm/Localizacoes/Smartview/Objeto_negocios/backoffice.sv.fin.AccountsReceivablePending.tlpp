#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'tlpp-core.th'
#INCLUDE 'tlpp-rest.th'
#INCLUDE 'backoffice.sv.fin.AccountsReceivablePending.ch'

namespace custom.financeiro.cuentasporcobrar.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} AccountsReceivablePendingTReportsBusinessObject
Classe para creación del Objeto de Negocio de compras para TReports
@author Welinton Fernandes
@since 13/12/2023
@version 1.0   
*/    
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAFIN", name="Cuentas por cobrar pendientes", tables="SE1", country="ALL", initialRelease="12.1.2310", customTables='ALL')
class AccountsReceivablePendingTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	Public Method new() 		   as Object
	Public Method getData() 	   as Object
	Public Method getSchema() 	   as Object

	Protected data aFields 		as Array
	Protected data aStruct 		as Array

	Protected data jItems		as Json

endclass

//-------------------------------------------------------------------
	/*{Protheus.doc} new
	Método de instância da classe
	 
	@Return object: self
	 
	@author Welinton Fernandes
	@since 13/12/2023
	@version 1.0
	*/
//-------------------------------------------------------------------
Method new(oFilter as object) as object class AccountsReceivablePendingTReportsBusinessObject

	Local aCpos 	as Array

	aCpos	 := {}

	_Super:new()

	// Define a Área
	self:appendArea(STR0001) //"Financiero"

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0006) //"Cuentas por cobrar pendientes"

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0006) //"Cuentas por cobrar pendientes"

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte('FINSV88')
		IIf(!self:setErrorStatus( 400, STR0002, STR0003 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0004,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0005 ,,, ) //'¡Grupo de preguntas no encontrado!'
	EndIf

	// Adiciona os campos virtuais/calculados
	aAdd( aCpos, { 'E1_NOMBCO1', STR0023, 'string', STR0023 } ) //'Banco Dep(Nom.)'
	aAdd( aCpos, { 'E1_NOMBCO2', STR0024, 'string', STR0024 } ) //'Banco Dep(Cód.)'
	aAdd( aCpos, { 'E1_NOMBCO3', STR0031, 'string', STR0031 } ) //'Banco. Orig.'
	aAdd( aCpos, { 'E1_DESMOE' , STR0025, 'string', STR0026 } ) //'Descripción de la moneda' ## 'Desc. Moneda'
	aAdd( aCpos, { 'E1_MES'    , STR0019, 'string', STR0019 } ) //'Mes'
	aAdd( aCpos, { 'E1_DESCSIT', STR0032, 'string', STR0032 } ) //'Situación'
	aAdd( aCpos, { 'E1_VLRTITC', STR0033, 'number', STR0033 } ) //'Vlr Tít. (Tasa Día)'

	self:aFields := {'E1_CLIENTE', 'E1_LOJA', 'E1_NOMCLI', 'E1_PREFIXO', 'E1_NUM', 'E1_PARCELA', 'E1_EMISSAO', 'E1_BCOCHQ', 'E1_AGECHQ', 'E1_CTACHQ', 'E1_STATUS', 'E1_VENCTO', 'E1_VALOR', 'E1_NOMBCO1','E1_NOMBCO2','E1_NOMBCO3', 'E1_MOEDA', 'E1_DESMOE','E1_MES','E1_DESCSIT', 'E1_VLRTITC'}

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return(self)

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio	
@param oFilter, objeto, contiene el filtro del TReports	
@Return object: self:oData
@author Welinton Fernandes
@since 13/12/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getData( nPage as numeric, oFilter as object ) as object class AccountsReceivablePendingTReportsBusinessObject

	Local aPDFields 	as Array
	Local aFiltro		as Array
	Local aCpos			as Array
	Local aTipDoc		as Array
	Local aTpCheques	as Array
	Local aMes			as Array
	Local aNomeMoed     as Array

	Local lObfuscated	as Logical

	Local jItems 		as json

	Local cFiltro		as Character
	Local cExp			as Character
	Local cQuery		as Character

	Local cCampo		as Character
	Local cCodBanco		as Character
	Local cCodPostal	as Character
	Local cCodAgenc		as Character
	Local cCodCuenta	as Character
	Local cTipo 		as Character
	Local cCnvValor 	as Character
	Local cNeg   		as Character
	Local dVencto		as Character
	Local cVencto		as Character
	Local cCpoSE1		as Character
	Local cFilSE1       as Character
	Local cFilSEL       as Character
	Local cFilSA6       as Character
	Local cDescMon      as Character

	Local nSigno 		as Numeric
	Local nSaldo 		as Numeric
	Local nCount 		as Numeric
	Local nX 			as Numeric
	Local nPosExp       as Numeric
	Local nC 			as Numeric
	Local n1 			as Numeric
	Local nQtMoedas     as Numeric
	Local nPosMon       as Numeric
	Local nSeq			as Numeric

	Local oQuery		as object

	Private cAlias 		:= GetNextAlias() as character

	aPDFields 		:= {}
	aFiltro			:= {}
	aCpos				:= {}
	aTipDoc 			:= {{ "FT ", "FT" }, { "NF ", "FT" }, { "NCC", "NC" }, { "NDC", "ND" }}
	lObfuscated		:= Len( aPDFields ) != Len( self:aFields )
	aTpCheques		:= {}
	aMes				:= {OemToAnsi(STR0007),OemToAnsi(STR0008),OemToAnsi(STR0009),OemToAnsi(STR0010),OemToAnsi(STR0011),OemToAnsi(STR0012),; //"ENERO" //"FEBRERO" //"MARZO" //"ABRIL" //"MAYO" //"JUNIO"
	OemToAnsi(STR0013),OemToAnsi(STR0014),OemToAnsi(STR0015),OemToAnsi(STR0016),OemToAnsi(STR0017),OemToAnsi(STR0018)} //"JULIO" //"AGOSTO" //"SEPT." //"OCTUBRE" //"NOVIEM." //"DICIEM." //
	aNomeMoed       := {}

	cExp				:= ''
	cQuery			:= ''
	cCampo			:= ''
	cCodBanco		:= ''
	cCodAgenc		:= ''
	cCodCuenta		:= ''
	cCodPostal		:= ''
	cTipo				:= ''
	cCnvValor		:= ''
	cNeg				:= ''
	cVencto			:= ''
	dVencto			:= ''
	cCpoSE1			:= ''
	cFilSE1        := xFilial("SE1")
	cFilSEL        := xFilial("SEL")
	cFilSA6        := xFilial("SA6")
	cMVCARTEIR     := SuperGetMv("MV_CARTEIR")

	nSigno 			:= 0
	nSaldo 			:= 0
	nCount 			:= 0
	nX 				:= 0
	nPosExp        := 0
	nC					:= 0
	n1					:= 0
	nQtMoedas      := Moedfin()
	nPosMon        := 0

	//--- Tipos de cheque
	If Type('MVCHEQUES') == 'C'
		aTpCheques := StrTokArr(MVCHEQUES, "|")
	EndIf

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	// Lista as moedas e suas descrições
	For nX := 1 To nQtMoedas
		aAdd( aNomeMoed, { Str(nX), SuperGetMv( 'MV_MOEDA' + AllTrim( Str( nX ) ) ) } )
	Next

	If oFilter:hasFilter()
		cFiltro := oFilter:getSQLExpression( )

		// Converte string de parametros em array
		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )

		// Realiza tratamento de filtro para limpar os que não serão utilizados na query
		If ( nPosExp > 0 )
			// Exclui o elemento do Array
			aDel( aFiltro, nPosExp )

			// Redimensiona o Array
			aSize( aFiltro, ( Len( aFiltro ) - 1 ) )
		EndIf

		//Converter valores para?
		nPosExp := aScan( aFiltro, { | x | AllTrim( x[1] ) == 'EF_CNVVLR' } )
		If ( nPosExp > 0 )
			cCNVValor := SubStr( aFiltro[nPosExp, 3], 2, 1 )
		EndIf

		// Realiza tratamento de filtro para limpar os que não serão utilizados na query
		If ( nPosExp > 0 )
			// Exclui o elemento do Array
			aDel( aFiltro, nPosExp )

			// Redimensiona o Array
			aSize( aFiltro, ( Len( aFiltro ) - 1 ) )
		EndIf
	EndIf

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	// Coleta os campos personalizados pra agregar na query
	cCpoSE1 := getCpoUser( aCustomFields, 'SE1', 'E1', ',' )

	cQuery += " SELECT "
	cQuery += " SE1.E1_CLIENTE, "
	cQuery += " SE1.E1_LOJA, "
	cQuery += " SE1.E1_NOMCLI, "
	cQuery += " SE1.E1_SERREC, "
	cQuery += " SE1.E1_RECIBO, "
	cQuery += " SE1.E1_PREFIXO, "
	cQuery += " SE1.E1_NUM, "
	cQuery += " SE1.E1_PARCELA, "
	cQuery += " SE1.E1_EMISSAO, "
	cQuery += " SE1.E1_VENCTO, "
	cQuery += " SE1.E1_VALOR, "
	cQuery += " SE1.E1_MOEDA, "
	cQuery += " SE1.E1_STATUS, "
	cQuery += " SE1.E1_SITUACA, "
	cQuery += " SE1.E1_PORTADO, "
	cQuery += " SE1.E1_AGEDEP, "
	cQuery += " SE1.E1_CONTA, "
	cQuery += " SE1.E1_BCOCHQ, "
	cQuery += " SE1.E1_AGECHQ, "
	cQuery += " SE1.E1_CTACHQ, "
	cQuery += " ? "
	cQuery += " SE1.E1_DTACRED "

	cQuery += "  FROM " + RetSqlName("SE1") + " SE1 "

	//Cliente De Ate?
	cQuery += "  WHERE SE1.E1_CLIENTE BETWEEN ? AND ? "

	//¿De fecha de emision ? - ¿A fecha de emision ?
	cQuery += " AND SE1.E1_EMISSAO BETWEEN ? AND ? "

	//¿De fecha de vencimiento ? - ¿A fecha de vencimiento ?
	cQuery += " AND SE1.E1_VENCREA BETWEEN ? AND ? "

	//--- Tipos Cheques
	If !Empty( aTpCheques )
		cQuery += " AND E1_TIPO IN(?) "
	EndIf

	//--- Titulos abertos
	cQuery += " AND E1_SALDO > ? "
	cQuery += " AND SE1.D_E_L_E_T_ = ? "

	// Agrega os filtros do SMARTVIEW na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += " AND ? " + ' ' + " ? ? "
	Next

	cQuery += "  ORDER BY ? "

	If !Empty( cQuery )
		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		cQuery := ChangeQuery( cQuery )

		oQuery := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQuery:SetQuery( cQuery )

		nSeq := 0
		oQuery:SetUnSafe( nSeq += 1, cCpoSE1 )
		oQuery:SetString( nSeq += 1, jParams['MV_PAR01'][1] )
		oQuery:SetString( nSeq += 1, jParams['MV_PAR02'][1] )
		oQuery:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR03'][1] )[1] ) )
		oQuery:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR04'][1] )[1] ) )
		oQuery:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR05'][1] )[1] ) )
		oQuery:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR06'][1] )[1] ) )

		If !Empty( aTpCheques )
			oQuery:SetIn( ( nSeq += 1 ), aTpCheques )
		Endif
		oQuery:SetNumeric( ( nSeq += 1 ), 0 )
		oQuery:SetString( ( nSeq += 1 ), ' ' )

		For nX := 1 To Len( aFiltro )
			oQuery:SetUnSafe ( nSeq += 1, aFiltro[nX, 1] )
			oQuery:SetUnSafe ( nSeq += 1, aFiltro[nX, 2] )
			oQuery:SetUnSafe ( nSeq += 1, aFiltro[nX, 3] )
		Next

		oQuery:SetUnsafe( ( nSeq += 1 ), 'SE1.E1_FILIAL,SE1.E1_PREFIXO,SE1.E1_NUM,SE1.E1_PARCELA,SE1.E1_TIPO' )

		// cria alias
		oQuery:OpenAlias( cAlias )

		While !((cAlias))->(Eof())
			jItems := JsonObject():new()

			// Verifica se precisa fazer o tratamento para LGPD
			aPDFields := FwProtectedDataUtil():UsrAccessPDField(__cUserID, self:aFields)
			lObfuscated := Len(aPDFields) != Len(self:aFields)

			For nX := 1 To Len(self:aStruct)
				If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
					jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize(((cAlias))->& (self:aStruct[nX][5]))
				Else
					If ( self:aStruct[nx][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAlias )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][1] == 'E1_DESMOE' )
						// Moneda
						nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == Alltrim(Str((cAlias)->E1_MOEDA)) } )
						cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
						jItems[self:aStruct[nX][1]] := cDescMon
					ElseIf ( self:aStruct[nx][1] == 'E1_VLRTITC' )
						jItems[self:aStruct[nX][1]] := xMoeda((cAlias)->E1_VALOR,(cAlias)->E1_MOEDA,jParams['MV_PAR07'][1], dDataBase)
					ElseIf ( self:aStruct[nx][1] == 'E1_MES' )
						jItems[self:aStruct[nX][1]] := aMes[Month(STOD((cAlias)->E1_VENCTO))]
					ElseIf ( self:aStruct[nx][1] == 'E1_STATUS' )
						jItems[self:aStruct[nX][1]] := IIf((cAlias)->E1_STATUS == "R",STR0027,IIf(StoD((cAlias)->E1_DTACRED) >= dDataBase,STR0028,IIf(StoD((cAlias)->E1_VENCTO) < dDataBase,STR0029,STR0030))) //"Rechazado" //"Clearing" //"Vencido" //"En Fch"
					ElseIf ( self:aStruct[nx][1] == 'E1_NOMBCO1' )
						jItems[self:aStruct[nX][1]] :=  FBcoCtaP(cFilSE1, cFilSEL, cFilSA6, 1, cMVCARTEIR)
					ElseIf ( self:aStruct[nx][1] == 'E1_NOMBCO2' )
						jItems[self:aStruct[nX][1]] :=  FBcoCtaP(cFilSE1, cFilSEL, cFilSA6, 2, cMVCARTEIR)
					ElseIf ( self:aStruct[nx][1] == 'E1_NOMBCO3' )
						jItems[self:aStruct[nX][1]] :=  FBcoCtaP(cFilSE1, cFilSEL, cFilSA6, 3, cMVCARTEIR)
					ElseIf ( self:aStruct[nx][1] == 'E1_DESCSIT' ) //Situación
						jItems[self:aStruct[nX][1]] :=  IIf((cAlias)->E1_SITUACA == "0",STR0034,STR0035) //"Cartera" //"Banco"
					Else
						jItems[self:aStruct[nX][1]] := (((cAlias)))->&(self:aStruct[nX][5])
					EndIF
				EndIf
			Next nX

			// Inclui os dados no objeto para retorno ao SmartView
			self:oData:appendData( jItems )

			( cAlias )->( DbSkip( ) )
			nCount++
		End

		// Se não for o último registro indica que terá próxima página
		self:setHasNext( !( ( cAlias ) )->( EOF( ) ) )

		// Checa se o arquivo já esta aberto
		If ( SELECT( cAlias ) > 0 )
			( cAlias )->( DbCloseArea( ) )
		EndIf
	EndIf

	// fecha objeto
	If oQuery <> Nil
		oQuery:Destroy()
		oQuery := NIL
		FwFreeObj(oQuery)
	EndIf

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna la estructura de los campos	
@Return object: self:oSchema	
@author Welinton Fernandes
@since 13/12/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getSchema() as object class AccountsReceivablePendingTReportsBusinessObject
	Local nX as numeric

	//Estructura con los campos para el objeto de negocios.
	For nX:=1 To Len(self:aStruct)
		self:addProperty(self:aStruct[nX][1],self:aStruct[nX][2],self:aStruct[nX][3],self:aStruct[nX][4],self:aStruct[nX][5])
	Next nX
Return self:oSchema


/*/{Protheus.doc} FBcoCtaP
	obtiene la descripción de la columna de Banco
	@type  Function
	@author Welinton Fernandes
	@since 30/01/2024
	@version version
	@param cFilSE1, caracter, Filial de la tabla SE1
	@param cFilSEL, caracter, Filial de la tabla SEL
	@param cFilSA6, caracter, Filial de la tabla SA6
	@param nOpc, Numérico, Opción de impresión del Banco 1=Bco.Dep(Nombre), 2=Bco. Dep. (Cod) y 3=Bco. Orig.)
	@param cMVCARTEIR, caracter, Valor de parámetro MV_CARTEIR
	@return cBanco, caracter, Cadena con el Banco de acuerdo lo recibido en el parámetro nOpc
	@example
	FBcoCtaP(cFilSE1, cFilSEL, cFilSA6, nOpc, cMVCARTEIR)
	@see (links_or_references)
	/*/
Static Function FBcoCtaP(cFilSE1, cFilSEL, cFilSA6, nOpc, cMVCARTEIR)

	Local cBanco  := ""
	Local aOrigin := GetArea()

	Default cFilSE1    := ""
	Default cFilSEL    := ""
	Default cFilSA6    := ""
	Default nOpc       := 0
	Default cMVCARTEIR := ""

	If nOpc == 3
		//--- Recibos de Cobranca
		dbSelectArea("SEL")
		SEL->(dbSetOrder(8)) //EL_FILIAL+EL_SERIE+EL_RECIBO+EL_TIPODOC+EL_PREFIXO+EL_NUMERO+EL_PARCELA+EL_TIPO
		MsSeek(cFilSEL + (cAlias)->E1_SERREC + (cAlias)->E1_RECIBO + "CH" + (cAlias)->E1_PREFIXO + (cAlias)->E1_NUM + (cAlias)->E1_PARCELA)
		If Found() .And. !Empty(SEL->EL_BCOCHQ)
			cBanco := IIf(Empty(SEL->EL_OBSBCO),SEL->EL_BCOCHQ + "/" + SEL->EL_AGECHQ +"/" + Right(Alltrim(SEL->EL_CTACHQ),8),SEL->EL_OBSBCO)
		Else
			cBanco	:=	 OemToAnsi(STR0020) //"No registrado"
		EndIf
	Else
		If Empty( (cAlias)->E1_PORTADO )
			cBanco := OemToAnsi(STR0021) // "En Cartera"
		Else
			If (cAlias)->E1_PORTADO $ cMVCARTEIR
				cBanco := OemToAnsi(STR0022) + (cAlias)->E1_PORTADO //"Caja "
			Else
				If nOpc == 1
					dbSelectArea( "SA6" )
					SA6->(dbSetOrder(1)) //A6_FILIAL+A6_COD+A6_AGENCIA+A6_NUMCON
					If SA6->(MsSeek( cFilSA6 + (cAlias)->E1_PORTADO + (cAlias)->E1_AGEDEP + (cAlias)->E1_CONTA))
						cBanco := SubStr( SA6->A6_NREDUZ,1,27 )
					EndIf
				Else
					cBanco := (cAlias)->E1_PORTADO + "/" + (cAlias)->E1_AGEDEP + "/" + Right(Alltrim((cAlias)->E1_CONTA),8)
				EndIf
			EndIf
		EndIf
	EndIf

	RestArea( aOrigin )

Return( cBanco )
