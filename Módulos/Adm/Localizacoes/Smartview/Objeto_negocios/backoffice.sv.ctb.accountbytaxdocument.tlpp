#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.ctb.accountbytaxdocument.ch'

namespace custom.contabil.accountbytaxdocument.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} backoffice.sv.ctb.accountbytaxdocument
@description Classe para creación del Objeto de Negocio de Cuenta por documento fiscal para TReports
@author Marcelo Hruschka
@since 28/11/2024
@version 1.1
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGACTB', tables='CT1,CWS,CWT,CT2,CV3,CT5', name='Cuenta por documento fiscal', country='ARG', initialRelease='12.1.2410', customTables='CT1,CWS,CWT,CT2,CV3,CT5' )
class accountbytaxdocumentTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array
	protected data nRecno as numeric
	protected data jItems as json

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe 
@Return object: self
@author Marcelo Hruschka
@since 28/11/2024
@version 1.0
*/
//-------------------------------------------------------------------
Method new() class accountbytaxdocumentTReportsBusinessObject

	Local aCpos := {} as array

	_Super:new()

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 )  // 'Cuenta por documento fiscal'

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 )  // 'Cuenta por documento fiscal'

	// Define a Área
	self:appendArea( STR0002 ) // 'Contabilidad de Gestión'

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'CTBSV811' )
		IIf(!self:setErrorStatus( 400, STR0003, STR0004 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0005,,, ),'') // 'Sin Preguntas' // '¡Verifique el grupo de preguntas dado!' // 'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0006,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// campos adicionais
	aAdd( aCpos, {'TABELA'      , STR0007 , 'string', STR0007 } ) // 'Tabla'
	aAdd( aCpos, {'RAZON_SOCIAL', STR0008 , 'string', STR0008 } ) // 'Razon Social'
	aAdd( aCpos, {'DEBITO'      , STR0009 , 'number', STR0009 } ) // 'Debito'
	aAdd( aCpos, {'CREDITO'     , STR0010 , 'number', STR0010 } ) // 'Credito'
	aAdd( aCpos, {'MODULO'      , STR0011 , 'string', STR0011 } ) // 'Modul'

	// demais campos
	self:aFields := {'CWS_FILIAL','CWS_LANC','CWS_GRUPO','CWS_DSCGRP','CWT_CONTA','CT1_DESC01','CT2_LOTE','CT2_SBLOTE','CT2_DOC','CT2_DATA','CT2_DC','DEBITO','CREDITO','CT2_HIST','CT2_MOEDLC','CT2_TPSALD','MODULO','CV3_KEY','CV3_TABORI','TABELA','CV3_LP','CV3_LPSEQ','CT5_DESC','RAZON_SOCIAL'}

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio
@param nPage, numérico, indica la pagina actual del relatório
@param oFilter, objeto, contiene el filtro del TReports
@return object: self:oData
@author Marcelo Hruschka
@since 28/11/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class accountbytaxdocumentTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery		as character
	Local cFiltro 		as character

	Local nX			as numeric
	Local n1			as numeric
	Local nPosMon		as numeric
	Local nPosExp		as numeric
	Local nDecs 		as numeric

	Local jParams 		as json

	Local aPDFields		as array
	Local aFiltro		as array
	Local aCustomFields as array

	Local lObfuscated	as logical

	Local oExecA		as object
	Local cAliasA       as character
	Local cExp          as character

	cFiltro 			:= ''
	cAliasA			    := ''
	cExp                := ''

	nPosMon   		:= 0
	nPosExp 		:= 0
	nDecs 			:= 0
	nX 				:= 0
	n1				:= 0

	aPDFields		:= { }
	aFiltro			:= { }
	aCustomFields	:= { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )
	cCpoCT1 := getCpoUser( aCustomFields, 'CT1', 'CT1', ',' )
	cCpoCWS := getCpoUser( aCustomFields, 'CWS', 'CWS', ',' )
	cCpoCWT := getCpoUser( aCustomFields, 'CWT', 'CWT', ',' )
	cCpoCT2 := getCpoUser( aCustomFields, 'CT2', 'CT2', ',' )
	cCpoCV3 := getCpoUser( aCustomFields, 'CV3', 'CV3', ',' )
	cCpoCT5 := getCpoUser( aCustomFields, 'CT5', 'CT5', ',' )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	If oFilter:hasFilter( )
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )
		aFiltro := getParamToArr( cFiltro )
		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )
	EndIf

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQuery := "SELECT DISTINCT CWS_FILIAL, CWS_LANC, CWS_GRUPO, CWS_DSCGRP, CWT_CONTA, CT1_DESC01, CT2_LOTE, CT2_SBLOTE, CT2_DOC, CT2_DATA, CT2_DC,"
	cQuery += " CASE WHEN CWT_CREDIT > 0 THEN CT2_VALOR ELSE 0 END CREDITO,"
	cQuery += " CASE WHEN CWT_DEBITO > 0 THEN CT2_VALOR ELSE 0 END DEBITO,"
	cQuery += " CT2_HIST, CT2_MOEDLC, CT2_TPSALD,"
	cQuery += " CV3_TABORI MODULO,"
	cQuery += " ? "
	cQuery += " ? "
	cQuery += " ? "
	cQuery += " ? "
	cQuery += " ? "
	cQuery += " ? "
	cQuery += " CV3_TABORI, X2_NOMESPA AS TABELA, CV3_KEY, CV3_LP, CV3_LPSEQ, CT5_DESC, '' RAZON_SOCIAL, CT2.R_E_C_N_O_ AS REG"
	cQuery += " FROM " + RetSqlName("CWS") + " CWS"
	cQuery += " INNER JOIN " + RetSqlName("CWT") + " CWT ON CWT.CWT_FILIAL = ? AND CWT.CWT_LANC = CWS.CWS_LANC AND CWT.D_E_L_E_T_ = ?"
	cQuery += " INNER JOIN " + RetSqlName("CT1") + " CT1 ON CT1.CT1_FILIAL = ? AND CT1.CT1_CONTA = CWT.CWT_CONTA AND CT1.D_E_L_E_T_ = ?"
	cQuery += " INNER JOIN " + RetSqlName("CT2") + " CT2 ON CT2.CT2_FILIAL = ? AND CT2.CT2_DATA = CWS.CWS_DTLANC AND CT2.CT2_LOTE = CWT.CWT_LOTE AND CT2.CT2_SBLOTE = CWT.CWT_SUBLOT AND CT2.CT2_DOC = CWT.CWT_DOC AND CT2.CT2_LANC = CWS.CWS_LANC AND ( CT2.CT2_DEBITO = CWT.CWT_CONTA OR CT2.CT2_CREDIT = CWT.CWT_CONTA ) AND CT2.D_E_L_E_T_ = ?"
	cQuery += " LEFT JOIN  " + RetSqlName("CV3") + " CV3 ON CV3.CV3_FILIAL = ? AND CV3.CV3_RECDES = CT2.R_E_C_N_O_ AND CV3.D_E_L_E_T_ = ?"
	cQuery += " LEFT JOIN  " + RetSqlName("SX2") + " SX2 ON SX2.X2_CHAVE = CV3.CV3_TABORI AND SX2.D_E_L_E_T_ = ?"
	cQuery += " LEFT JOIN  " + RetSqlName("CT5") + " CT5 ON CT5.CT5_FILIAL = ? AND CT5.CT5_LANPAD = CV3.CV3_LP AND CT5.CT5_SEQUEN = CV3.CV3_LPSEQ AND CV3.D_E_L_E_T_ = ?"
	cQuery += " WHERE CWS.CWS_FILIAL = ?"
	cQuery += "   AND CWS.CWS_LANC   BETWEEN ? AND ?"
	cQuery += "   AND CWS.CWS_GRUPO  BETWEEN ? AND ?"
	cQuery += "   AND CWS.CWS_DTLANC BETWEEN ? AND ?"
	cQuery += "   AND CWS.D_E_L_E_T_ = ?"

	// Agrega os filtros na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += " AND ? " + ' ' + " ? ? "
	Next

	cQuery := ChangeQuery(cQuery)
	oExecA := FwExecStatement():New( cQuery )

	oExecA:SetUnSafe( 01, cCpoCT1 )
	oExecA:SetUnSafe( 02, cCpoCWS )
	oExecA:SetUnSafe( 03, cCpoCWT )
	oExecA:SetUnSafe( 04, cCpoCT2 )
	oExecA:SetUnSafe( 05, cCpoCV3 )
	oExecA:SetUnSafe( 06, cCpoCT5 )
	oExecA:SetString( 07, xFilial("CWT") )			// CWT_FILIAL
	oExecA:SetString( 08, '' 			 )			// CWT.D_E_L_E_T_
	oExecA:SetString( 09, xFilial("CT1") )			// CT1_FILIAL
	oExecA:SetString( 10, '' 			 )			// CT1.D_E_L_E_T_
	oExecA:SetString( 11, xFilial("CT2") )			// CT2_FILIAL
	oExecA:SetString( 12, '' 			 )			// CT2.D_E_L_E_T_
	oExecA:SetString( 13, xFilial("CV3") )			// CV3_FILIAL
	oExecA:SetString( 14, '' 			 )			// CV3.D_E_L_E_T_
	oExecA:SetString( 15, '' 			 )			// SX2.D_E_L_E_T_
	oExecA:SetString( 16, xFilial("CT5") )			// CT5_FILIAL
	oExecA:SetString( 17, '' 			 )			// CT5.D_E_L_E_T_
	oExecA:SetString( 18, xFilial("CWS") )			// CWS_FILIAL
	oExecA:SetString( 19, jParams['MV_PAR01'][1] )	// CWS_LANC
	oExecA:SetString( 20, jParams['MV_PAR02'][1] )	// CWS_LANC
	oExecA:SetString( 21, jParams['MV_PAR03'][1] )	// CWS_GRUPO
	oExecA:SetString( 22, jParams['MV_PAR04'][1] )	// CWS_GRUPO
	oExecA:SetString( 23, DtoS( FwDateTimeToLocal( jParams['MV_PAR05'][1] )[1] ) )			// CWS_DTLANC
	oExecA:SetString( 24, DtoS( FwDateTimeToLocal( jParams['MV_PAR06'][1] )[1] ) )			// CWS_DTLANC
	oExecA:SetString( 25, '' 			 )			// CWS.D_E_L_E_T_

	nSeq := 25
	For nX := 1 To Len( aFiltro )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 1] )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 2] )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 3] )
	Next

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	cAliasA := oExecA:OpenAlias( )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( cAliasA )->( EOF( ) )

		self:jItems := JsonObject():new( )
		self:nRecno := ( cAliasA )->REG

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf ( self:aStruct[nX][3] == 'date' )
				self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
			ElseIf ( self:aStruct[nX][5] == "MODULO" )
				self:jItems[self:aStruct[nX][1]] := "N/A"
				If ( cAliasA )->&( self:aStruct[nX][5] ) $ "SF1,SF2"
					self:jItems[self:aStruct[nX][1]] := STR0012 // 'Compras y Facturacion'
				ElseIf ( cAliasA )->&( self:aStruct[nX][5] ) $ "SE1,SE2,SE5,SEF"
					self:jItems[self:aStruct[nX][1]] := STR0013 // 'Financiero'
				ElseIf ( cAliasA )->&( self:aStruct[nX][5] ) $ "SN3"
					self:jItems[self:aStruct[nX][1]] := STR0014 // 'Activo fijo'
				ElseIf ( cAliasA )->&( self:aStruct[nX][5] ) $ "SD3"
					self:jItems[self:aStruct[nX][1]] := STR0015 // 'Stock/Costos'
				ElseIf ( cAliasA )->&( self:aStruct[nX][5] ) $ "SRZ"
					self:jItems[self:aStruct[nX][1]] := STR0016 // 'Gestion de personal'
				Endif
			Else
				self:jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
			Endif
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		//self:processData()
		self:oData:appendData( self:jItems )

		( cAliasA )->( DbSkip( ) )

	End
	( cAliasA )->( DbCloseArea( ) )

	oExecA:Destroy( )
	oExecA := Nil

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
@description Retorna la estructura de los campos
@return object: self:oSchema
@author Marcelo Hruschka
@since 28/11/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema() as object class accountbytaxdocumentTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTView
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )
