#INCLUDE 'msobject.ch'
#INCLUDE 'tlpp-rest.th'
#INCLUDE 'tlpp-core.th'
#INCLUDE 'fwlibversion.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fin.PreOrder.ch'

//-------------------------------------------------------------------------------
/*{Protheus.doc} ListadecomprasTReportsBusinessObject
Classe para criação do Objeto de Negocio de compras para SmartView
@author Leonardo Pereira
@since 27/07/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
namespace custom.financeiro.PreOrdenPago.integratedprovider

// Annotation
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFIN', tables='FJK,FJL,FVC,SE2,SA2', name='Pre-Orden de Pago', country='ARG', initialRelease='12.1.2410', customTables='SA2,FJK,SE2' )
class PreOrdenPagoTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} NEW
Método de instância da classe: Define a lista de campos que serão acessados no objeto de negocios
@return object: self
@author Leonardo Pereira
@since 27/07/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method new() class PreOrdenPagoTReportsBusinessObject

	Local aCpos := { }

	_Super:new()

	// Define a Área
	self:appendArea( STR0001 )  // 'Financiero'

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0024 ) // 'Pre-Orden de Pago'

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0025 ) // 'Lista detallada de Pre-Ordenes de Pago'

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'FINSV851' ) // Indica o pergunte que será utilizado
		IIf(!self:setErrorStatus( 400, STR0002, STR0003 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0004,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0005 ,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// Adiciona os campos virtuais/calculados
	aAdd( aCpos, { 'FJK_STATUS', STR0006 , 'string', STR0007 } ) // 'Estatus del Pre-Orden' # 'Estatus'
	aAdd( aCpos, { 'FJK_DESMOE', STR0008 , 'string', STR0009 } ) // 'Descripción de la moneda Pre-Orden' # 'Desc. Moneda Pre-Orden'
	aAdd( aCpos, { 'E2_DESMOE' , STR0010 , 'string', STR0011 } ) // 'Descripción de la moneda Titulo' # 'Desc. Moneda Titulo'
	aAdd( aCpos, { 'E2_SLDCONV', STR0012 , 'number', STR0012 } ) // 'Saldo Convertido'
	aAdd( aCpos, { 'FVC_IVA'   , STR0013 , 'number', STR0013 } ) // 'IVA'
	aAdd( aCpos, { 'FVC_GAN'   , STR0014 , 'number', STR0014 } ) // 'Ganancias'
	aAdd( aCpos, { 'FVC_BRT'   , STR0015 , 'number', STR0016 } ) // 'Ingresos Brutos' # 'Brutos'
	aAdd( aCpos, { 'FVC_SUS'   , STR0017 , 'number', STR0017 } ) // 'SUSS'
	aAdd( aCpos, { 'FVC_MUN'   , STR0018 , 'number', STR0019 } ) // 'Impuestos Municipales' # 'Municipales'
	aAdd( aCpos, { 'FVC_XLI'   , STR0020 , 'number', STR0021 } ) // 'Impuesto SLI' # 'SLI'
	aAdd( aCpos, { 'FVC_YSI'   , STR0022 , 'number', STR0023 } ) // 'Impuesto ISI' # 'ISI'

	// Define os campos que serão retornados no objeto de negocios
	self:aFields := { 'FJK_FILIAL', 'FJK_PREOP', 'FJK_STATUS', 'FJK_ORDPAG', 'FJK_DTDIG', 'FJK_FORNEC', 'FJK_LOJA', 'A2_NOME', 'FJK_DTANLI', 'FJK_DTCANC', 'E2_PREFIXO', 'E2_NUM', 'E2_PARCELA', 'E2_TIPO', 'E2_EMISSAO', 'E2_VENCREA', 'E2_MOEDA', 'E2_DESMOE', 'E2_SALDO', 'E2_SLDCONV', 'FJK_MOEDA', 'FJK_DESMOE', 'FJK_VLRPRE', 'FJK_VLCONV', 'FJK_CCR', 'FVC_TIPO', 'FVC_CONCEP', 'FVC_VALBAS', 'FVC_ALIQ', 'FVC_DEDUC', 'FVC_IVA', 'FVC_GAN', 'FVC_BRT', 'FVC_SUS', 'FVC_MUN', 'FVC_XLI', 'FVC_YSI' }

	self:aStruct := getStrutObj( self:aFields, aCpos, .T. )

Return( self )


//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os datos do objeto de negócios
@param nPage, numérico, indica a pagina atual
@param oFilter, objeto, contém o filtro do SmartView
@return object: self:oData
@author Leonardo Pereira
@since 27/07/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class PreOrdenPagoTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery as character
	Local cAliasA := GetNextAlias() as character
	Local cAliasB := GetNextAlias() as character
	Local cDescMon as character
	Local cCpoSA2 as character
	Local cCpoFJK as character
	Local cCpoSE2 as character
	Local cFiltro as character

	Local nPosMon as numeric
	Local nPosExp as numeric
	Local nX as numeric
	Local nQtMoedas as numeric
	Local nDecs as numeric
	Local n1 as numeric
	Local nMVPAR07 as numeric

	Local jParams as json
	Local jItems as json

	Local aPDFields as array
	Local aNomeMoed as array
	Local aFiltro as array
	Local aParam as array
	Local aCustomFields as array

	Local lObfuscated as logical

	Local oQueryA as object
	Local oQueryB as object

	cDescMon := ''
	cCpoSA2 := ''
	cCpoFJK := ''
	cCpoSE2 := ''

	nPosMon := 0
	nPosExp := 0
	nX := 0
	n1 := 0
	nQtMoedas := Moedfin()
	nMVPAR07 := 0

	aNomeMoed := { }
	aFiltro := { }
	aParam := { }
	aCustomFields := { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	If oFilter:hasFilter()
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )

		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )
	EndIf

	nMVPAR07 := IIf( ( ValType( jParams['MV_PAR07'][1] ) == 'C' ), Val( jParams['MV_PAR07'][1] ), jParams['MV_PAR07'][1] )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	// Coleta os campos personalizados pra agregar na query
	cCpoSA2 := getCpoUser( aCustomFields, 'SA2', 'A2', ',' )
	cCpoFJK := getCpoUser( aCustomFields, 'FJK', 'FJK', ',' )
	cCpoSE2 := getCpoUser( aCustomFields, 'SE2', 'E2', ',' )

	// Lista as moedas e suas descrições
	For nX := 1 To nQtMoedas
		aAdd( aNomeMoed, { AllTrim( Str( nX ) ), SuperGetMv( 'MV_MOEDA' + AllTrim( Str( nX ) ) ) } )
	Next

	nDecs := MsDecimais( nMVPAR07 )

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQuery := "SELECT FJK.FJK_FILIAL, FJK.FJK_PREOP, '' AS FJK_STATUS, FJK.FJK_ORDPAG, FJK.FJK_DTDIG, FJK.FJK_FORNEC, FJK.FJK_LOJA, FJK.FJK_DTANLI, FJK.FJK_DTCANC, FJK_MOEDA, '' AS FJK_DESMOE, FJK.FJK_VLRPRE, FJK.FJK_VLCONV, FJK.FJK_CCR, " + cCpoFJK
	cQuery += " SA2.A2_NOME, " + cCpoSA2
	cQuery += " SE2.E2_PREFIXO, SE2.E2_NUM, SE2.E2_PARCELA, SE2.E2_TIPO, SE2.E2_EMISSAO, SE2.E2_VENCREA, SE2.E2_MOEDA, '' AS E2_DESMOE, SE2.E2_SALDO, 0 AS E2_SLDCONV, " + cCpoSE2
	cQuery += " '' AS FVC_TIPO, '' AS FVC_CONCEP, 0 AS FVC_VALBAS, 0 AS FVC_ALIQ, 0 AS FVC_DEDUC "
	cQuery += "FROM " + RetSQLName( 'FJK' ) + ' FJK '
	cQuery += "INNER JOIN " + RetSQLName( 'FJL' ) + " FJL "
	cQuery += "   ON FJK.FJK_FILIAL = ? "
	cQuery += "      AND FJK.FJK_PREOP = FJL.FJL_PREOP "
	cQuery += "      AND FJK.FJK_FORNEC = FJL.FJL_FORNEC "
	cQuery += "      AND FJK.FJK_LOJA = FJL.FJL_LOJA "
	cQuery += "      AND FJL.D_E_L_E_T_ = ? "
	cQuery += "INNER JOIN " + RetSQLName( 'SE2' ) + " SE2 "
	cQuery += "   ON SE2.E2_FILIAL = ? "
	cQuery += "      AND SE2.E2_PREOP = FJL.FJL_PREOP "
	cQuery += "      AND SE2.E2_FORNECE = FJL.FJL_FORNEC "
	cQuery += "      AND SE2.E2_LOJA = FJL.FJL_LOJA "
	cQuery += "      AND SE2.E2_NUM = FJL.FJL_NUM "
	cQuery += "      AND (SE2.E2_NUM = FJL.FJL_NUM OR FJL.FJL_NUM = ?) "
	cQuery += "      AND SE2.E2_TIPO = FJL.FJL_TIPO "
	cQuery += "      AND SE2.D_E_L_E_T_ = ? "
	cQuery += "INNER JOIN " + RetSQLName( 'SA2' ) + " SA2 "
	cQuery += "   ON SA2.A2_FILIAL = ? "
	cQuery += "      AND SA2.A2_COD = FJK.FJK_FORNEC "
	cQuery += "      AND SA2.A2_LOJA = FJK.FJK_LOJA "
	cQuery += "      AND SA2.D_E_L_E_T_ = ? "
	cQuery += " WHERE FJK.FJK_FILIAL = ? "
	cQuery += " AND FJK.FJK_FORNEC BETWEEN ? AND ? "
	cQuery += " AND FJK.FJK_LOJA BETWEEN ? AND ? "
	cQuery += " AND FJK.FJK_DTDIG BETWEEN ? AND ? "
	cQuery += " AND FJK.D_E_L_E_T_ = ? "

	// Agrega os filtros do SMARTVIEW na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += "   AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
	Next

	cQuery += "ORDER BY ? "

	cQuery := ChangeQuery( cQuery )

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	oQueryA := FwExecStatement():New()

	//Define a consulta e os parâmetros
	oQueryA:SetQuery( cQuery )

	oQueryA:SetString( 1, FwxFilial( 'FJK' ) )
	oQueryA:SetString( 2, ' ' )
	oQueryA:SetString( 3, FwxFilial( 'SE2' ) )
	oQueryA:SetString( 4, '' )
	oQueryA:SetString( 5, ' ' )
	oQueryA:SetString( 6, FwxFilial( 'SA2' ) )
	oQueryA:SetString( 7, ' ' )
	oQueryA:SetString( 8, FwxFilial( 'FJK' ) )
	oQueryA:SetString( 9, jParams['MV_PAR01'][1] )
	oQueryA:SetString( 10, jParams['MV_PAR02'][1] )
	oQueryA:SetString( 11, jParams['MV_PAR03'][1] )
	oQueryA:SetString( 12, jParams['MV_PAR04'][1] )
	oQueryA:SetString( 13, DtoS( FwDateTimeToLocal( jParams['MV_PAR05'][1] )[1] ) )
	oQueryA:SetString( 14, DtoS( FwDateTimeToLocal( jParams['MV_PAR06'][1] )[1] ) )
	oQueryA:SetString( 15, ' ' )
	oQueryA:SetUnsafe( 16, 'FJK.FJK_FORNEC, FJK.FJK_LOJA, FJK.FJK_ORDPAG' )

	cQuery := oQueryA:getFixQuery( )

	// cria alias
	oQueryA:OpenAlias( cAliasA )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( cAliasA )->( EOF( ) )
		jItems := JsonObject():new()

		// Realiza a montagem da QUERY que será enviada para o banco de dados
		If !Empty( cAliasB )
			If ( SELECT( cAliasB ) > 0 )
				( cAliasB )->( DbCloseArea( ) )
			EndIf
		EndIf
		cQuery := "SELECT FVC.FVC_TIPO, FVC.FVC_CONCEP, FVC.FVC_VALBAS, FVC.FVC_ALIQ, FVC.FVC_DEDUC, FVC.FVC_RETENC "
		cQuery += "FROM " + RetSQLName( 'FVC' ) + " FVC "
		cQuery += "WHERE FVC_FILIAL = ? "
		cQuery += "AND FVC_PREOP = ? "
		cQuery += "AND FVC_FORNEC = ? "
		cQuery += "AND FVC_LOJA = ? "
		cQuery += "AND FVC.D_E_L_E_T_ = ? "

		cQuery := ChangeQuery( cQuery )

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		oQueryB := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQueryB:SetQuery( cQuery )

		oQueryB:SetString( 1, ( cAliasA )->FJK_FILIAL )
		oQueryB:SetString( 2, ( cAliasA )->FJK_PREOP )
		oQueryB:SetString( 3, ( cAliasA )->FJK_FORNEC )
		oQueryB:SetString( 4, ( cAliasA )->FJK_LOJA )
		oQueryB:SetString( 5, ' ' )

		cQuery := oQueryB:getFixQuery( )

		// cria alias
		oQueryB:OpenAlias( cAliasB )

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf ( self:aStruct[nX][3] == 'date' )
				jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
			Else
				If ( self:aStruct[nx][5] == 'FJK_DESMOE' )
					// Moneda
					nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == StrZero( Val( ( cAliasA )->FJK_MOEDA ) , 1 ) } )
					cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )

					jItems[self:aStruct[nX][1]] := cDescMon
				ElseIf ( self:aStruct[nx][5] == 'E2_DESMOE' )
					// Moneda
					nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == StrZero( ( cAliasA )->E2_MOEDA , 1 ) } )
					cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )

					jItems[self:aStruct[nX][1]] := cDescMon
				ElseIf ( self:aStruct[nX][5] == 'FJK_STATUS' )
					// Status
					If ( !Empty( ( cAliasA )->FJK_DTANLI ) .And. Empty( ( cAliasA )->FJK_DTCANC ) .And. Empty( ( cAliasA )->FJK_ORDPAG ) )
						jItems[self:aStruct[nX][1]] := STR0026 // 'Aprobada'
					ElseIf !Empty( ( cAliasA )->FJK_ORDPAG )
						jItems[self:aStruct[nX][1]] := STR0027 // 'Efectivada'
					ElseIf ( Empty( ( cAliasA )->FJK_DTANLI ) .And. Empty( ( cAliasA )->FJK_DTCANC ) .And. Empty( ( cAliasA )->FJK_ORDPAG ) )
						jItems[self:aStruct[nX][1]] := STR0028 // 'Original'
					ElseIf !Empty( ( cAliasA )->FJK_DTCANC )
						jItems[self:aStruct[nX][1]] := STR0029 // 'Reprobada/Cancelada'
					EndIf
				ElseIf ( self:aStruct[nx][5] == 'E2_SLDCONV' )
					jItems[self:aStruct[nX][1]] := Round( xMoeda( ( cAliasA )->E2_SALDO, ( cAliasA )->E2_MOEDA, nMVPAR07 ), nDecs )
				ElseIf ( self:aStruct[nx][5] == 'FJK_VLCONV' )
					jItems[self:aStruct[nX][1]] := Round( xMoeda( ( cAliasA )->FJK_VLRPRE, Val( ( cAliasA )->FJK_MOEDA ), nMVPAR07 ), nDecs )
				ElseIf ( self:aStruct[nx][5] == 'FVC_CONCEP' )
					jItems[self:aStruct[nX][1]] := ( cAliasB )->FVC_CONCEP
				ElseIf ( self:aStruct[nx][5] == 'FVC_VALBAS' )
					jItems[self:aStruct[nX][1]] := ( cAliasB )->FVC_VALBAS
				ElseIf ( self:aStruct[nx][5] == 'FVC_ALIQ' )
					jItems[self:aStruct[nX][1]] := ( cAliasB )->FVC_ALIQ
				ElseIf ( self:aStruct[nx][5] == 'FVC_DEDUC' )
					jItems[self:aStruct[nX][1]] := ( cAliasB )->FVC_DEDUC
				ElseIf ( self:aStruct[nx][5] == 'FVC_IVA' ) .Or. ( self:aStruct[nx][5] == 'FVC_GAN' ) .Or. ( self:aStruct[nx][5] == 'FVC_BRT' ) .Or. ( self:aStruct[nx][5] == 'FVC_SUS' ) .Or. ( self:aStruct[nx][5] == 'FVC_MUN' ) .Or. ( self:aStruct[nx][5] == 'FVC_XLI' ) .Or. ( self:aStruct[nx][5] == 'FVC_YSI' )
					jItems[self:aStruct[nX][1]] := IIf( ValType( jItems[self:aStruct[nX][1]] ) == 'U', 0, jItems[self:aStruct[nX][1]] )
					( cAliasB )->( DbGoTop( ) )
					While !( cAliasB )->( EOF( ) )
						If ( ( cAliasB )->FVC_TIPO == SubStr( self:aStruct[nx][5], 5, 1 ) )
							jItems[self:aStruct[nX][1]] += ( cAliasB )->FVC_RETENC
						EndIf
						( cAliasB )->( DbSkip( ) )
					End
				Else
					jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
				EndIf
			EndIf
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		self:oData:appendData( jItems )

		( cAliasA )->( DbSkip( ) )
	End

	( cAliasA )->( DbCloseArea( ) )

	// fecha objeto
	If ( oQueryA <> Nil )
		oQueryA:Destroy( )
		oQueryA := Nil
		FwFreeObj( oQueryA )
	EndIf

	If ( oQueryB <> Nil )
		oQueryB:Destroy( )
		oQueryB := Nil
		FwFreeObj( oQueryB )
	EndIf

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura de campos 
@return object: self:oSchema 
@author Leonardo Pereira
@since 20/04/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema() as object class PreOrdenPagoTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTView
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )
