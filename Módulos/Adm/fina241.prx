#INCLUDE "FINA240.ch"
#INCLUDE "PROTHEUS.Ch"
#INCLUDE "FWADAPTEREAI.CH"
#INCLUDE "FWMVCDEF.CH"

#DEFINE RECNOSE2			1
#DEFINE MARCADO				2
#DEFINE SALDO				3
#DEFINE BORDERATUAL			4
#DEFINE DATABORDERO			5
#DEFINE NUMBORDERO			6
#DEFINE VENCIMENTO			7
#DEFINE RECNOSTR			8
#DEFINE CHAVE				9
#DEFINE CAMPOUSER			10
#DEFINE IMPMOTOR			11
					
#DEFINE SIGAFIN 6

Static __aCTBPrv As Array

STATIC dDtMinPCC 			//necessario pois utiliza no FINA590.
STATIC __lPCCBaixa	:= NIL	// Verifica o momento da retencao do PCC 
STATIC aSelFil		:= {}
Static dLastPcc		:= CTOD("22/06/2015")
Static lIsIssBx		:= FindFunction("IsIssBx")
Static lF240EASY 	:= ExistBlock("F240EASY")
Static lF240ADCM	:= ExistBlock("F240ADCM")
Static lF241DTBOR	:= ExistBlock("F241DTBOR")
Static lF240FIL		:= ExistBlock("F240FIL")
Static lF241MARK	:= ExistBlock("F241MARK")
Static lF241IRAN	:= ExistBlock("F241IRAN")
Static __lMT103FRT	:= ExistBlock("MT103FRT")
Static __lMotorRet  := NIL
Static __lPccMR     := .F.
Static __lIrfMR     := .F.
Static __lIssMR     := .F.
Static __oPreparB   := NIL
Static __lLocBra    := cPaisLoc == 'BRA'
Static __lFKCodRet  := NIL
Static lSubCtaEA	:= .F.
Static __cFilCtb    := ""
Static __oRatIRF	:= Nil		// Rateio IR Progressivo
Static _oBorDtCan	:= Nil
Static __lAPICP     := NIL
Static __lDicSimpl  As Logical
STATIC __lTemFKY    As Logical
STATIC __oDelFKY	As Object
STATIC __oAtuFKY	As Object
//------------------------------------------------------------------------------------
/*/
{Protheus.doc} FINA241
Envia titulo para bordero de Pagamento  - Impostos

@author Mauricio Pequim Jr

@since 28/01/05
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function FinA241(nPosArotina As Numeric, aBorAut As Array, lAutomato As Logical) As Logical

    Local lRet As Logical

    Private aGetMark As Array
    Private aRotina As Array
    Private c240FilBT As Character
    Private cAgen240 As Character
    Private cAgencia As Character
    Private cBanco As Character
    Private cBenef As Character
    Private cCadastro As Character
    Private cConta As Character
    Private cConta240 As Character
    Private cCtBaixa As Character
    Private cFil240 As Character
    Private cLote As Character
    Private cLoteFin As Character
    Private cMarca As Character
    Private cModPgto As Character
    Private cPadrao As Character
    Private cTipoPag As Character
    Private lBorAut As Logical
    Private nAcresc As Numeric
    Private nDecresc As Numeric
    Private nTotADesc As Numeric
    Private nTotADesp As Numeric
    Private nTotAGer As Numeric
    Private nTotAJur As Numeric
    Private nTotAMul As Numeric
    Private nValEstrang As Numeric
    Private nValPadrao As Numeric
    Private nVlRetIrf As Numeric

    Default nPosArotina 	:= 0
    Default aBorAut 		:= {}
    DEFAULT lAutomato   	:= .F.

    __aCTBPrv := {}

	If __lTemFKY == NIL
		__lTemFKY := AliasInDic("FKY") .and. cPaisLoc == "BRA"
	Endif

    //-- Valida a licença do módulo
    If lRet := VldLicenca()

        SetKey (VK_F12,{|a,b| AcessaPerg("F240BR",.T.)})
        Pergunte("F240BR",.F.)

        //Motor Retenção
        __lMotorRet := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
        __lFKCodRet := (__lLocBra .and. FK3->(FieldPos("FK3_CODRET")) > 0 .and. FK4->(FieldPos("FK4_CODRET")) > 0)

        //------------------------------------------------------------------------
        // Parametros
        //------------------------------------------------------------------------
        // mv_par01		Considera Titulos ?	  			Normais / Adiantamentos
        // mv_par02		Considera Filial ?  			Sem Efeito atualmente
        // mv_par03		Da Filial ?						Sem Efeito atualmente
        // mv_par04		Ate a Filial ?					Sem Efeito atualmente
        // mv_par05		Marcar Titulos Automatic. ?
        // mv_par06		Calculo dos Impostos ?			1-Vencimento Real
        // 			                                 	2-Geracao Bordero
        //												3-Ambas
        // mv_par07		Mostra Lancamento ?
        // mv_par08		Considera Agendamento ?
        // mv_par09		Data Agend.De?
        // mv_par10		Data Agend.Ate?
        // mv_par11		Seleciona Filiais ?
        //------------------------------------------------------------------------

        cFil240		:= ""
        c240FilBT	:= space(60)
        aRotina		:= MenuDef()
        cLoteFin	:= Space(04)
        cPadrao 	:= ""
        cBenef		:= CriaVar("E5_BENEF")
        nTotAGer 	:= 0
        nTotADesp	:= 0
        nTotADesc	:= 0
        nTotAMul 	:= 0
        nTotAJur 	:= 0
        nValPadrao	:= 0
        nValEstrang	:= 0
        cBanco   	:= CriaVar("E1_PORTADO")
        cAgencia 	:= CriaVar("E1_AGEDEP")
        cConta 		:= CriaVar("E1_CONTA")
        cCtBaixa 	:= GetMv("MV_CTBAIXA")
        cAgen240 	:= CriaVar("A6_AGENCIA")
        cConta240	:= CriaVar("A6_NUMCON")
        cModPgto  	:= CriaVar("EA_MODELO")
        cTipoPag 	:= CriaVar("EA_TIPOPAG")
        cSubConta 	:= ""
        cMarca   	:= GetMark( )
        cCadastro	:= STR0005  //"Border“ de Pagamentos"
        aGetMark 	:= {}
        lBorAut		:= !Empty(aBorAut)
        nVlRetIrf	:= 0
        nAcresc 	:= 0 // para a função F080JuMuDe
        nDecresc 	:= 0 // para a função F080JuMuDe

        lSubCtaEA := SEA->(FieldPos("EA_SUBCTA")) > 0

        If lSubCtaEA
            cSubConta 	:= CriaVar("EA_SUBCTA")
        EndIf

        // Procura o Lote do Financeiro
        LoteCont( "FIN" )

        IF FUNNAME() != "FINA750" //Para garantir que o indice usado na FINA750 será usado no processo
            dbSelectArea("SE2")
            dbSetOrder(1)
        EndIf

        If GetNewPar("MV_CNBIMPG",.F.)
            Help(" ",1,"CNBIMPG")//Não é permitido colocar títulos em borderô que gerem impostos, com o parâmetro MV_CNBIMPG ativado.
            Return
        Endif

        If lBorAut
            FA241Borde(,,,aBorAut)
        Else
            If nPosArotina > 0 // Sera executada uma opcao diretamento de aRotina, sem passar pela mBrowse
                dbSelectArea("SE2")
                bBlock := &( "{ |a,b,c,d,e,f| " + aRotina[ nPosArotina,2 ] + "(a,b,c,d,e,f) }" )
                Eval( bBlock, Alias(), (Alias())->(Recno()),nPosArotina,,lAutomato)
            Else
                mBrowse( 6, 1,22,75,"SE2",,"E2_NUMBOR",,,,FA040Legenda("SE2"))
            Endif
        EndIf

        dbSelectArea("SE2")
        dbSetOrder(1)  //devolve ordem principal
    EndIf

Return(lRet)

//------------------------------------------------------------------------------------
/*/
{Protheus.doc} FA241Borde
Define os titulos a serem incluidos no bordero do pagamento

@author Mauricio Pequim Jr
@since 28/01/05
@version 1.0
/*/
//------------------------------------------------------------------------------------

Function FA241Borde(cAlias As Character, nReg As Numeric, nOpcx As Numeric, aBorAut As Array, lAutomato As Logical)

Local cFilOriAnt As Character

Local lPanelFin 	:= IsPanelFin()
Local oPanel		:= NIL
Local cMoeda240		:= ""
Local cVar			:= ""
Local lInverte 		:= .F.
Local aMoedas 		:= GetMoedas()
Local oFnt			:= NIL
Local cContrato		:= CriaVar("E9_NUMERO")
Local cSubConta		:= CriaVar("EE_SUBCTA")
Local nSavRec 		:= SE2->(RecNo())
Local nHdlLock		:= 0
Local nOpca 		:= If(lBorAut, 1, 0)
Local cSetFilter	:= SE2->(DBFILTER()) // Salva o filtro atual, para restaurar no final da rotina
Local cOldPort240   := ""
Local bOk1			:= NIL
Local bOk2			:= NIL
Local bOk3			:= NIL
Local nVlMinImp		:= GetNewPar("MV_VL10925",5000)
Local cModRetPIS	:= GetNewPar( "MV_RT10925", "1" )
Local cModTot		:= GetNewPar( "MV_MT10925", "1" )
Local lBaseSE2		:= SuperGetMv("MV_BS10925",.T.,"1") == "1"
Local cFilBck := ""

//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
//3-Nao Controla
Local cNccRet		:= SuperGetMv("MV_NCCRET",.F.,"1")
Local aRetencao		:= {}
Local cArquivo		:= ""
Local nTotal		:= 0
Local nHdlPrv		:= 0
Local nX			:= 0
Local lContabil		:= .T.
Local nValTot		:= 0
Local nLoop			:= 0
Local aChaveTit 	:= {}
Local aSize			:= {}
Local dDataAtu		:= dDataBase
Local lIRPFBaixa	:= .F.
Local aValPgto		:= {0,0}
Local aFlagCTB 		:= {}
Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local aCampos 		:= {}
Local aRestrict 	:= {}
Local cArqNew		:= ""
Local lTEMP			:= .F.
Local cIndTemp1		:= If(lBorAut,"",CriaTrab(,.F.))
Local cIndTemp2		:= If(lBorAut,"",CriaTrab(,.F.))
Local nIndice		:= 1
Local nIndBaseIR	:= 0
Local aBut240       := {}
Local bSet16 		:= NIL
Local lBlqBor 		:= .T.
Local lCarret  		:= .F.
Local cFilBak 		:= cFilAnt
Local lFinVDoc		:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios
Local aTitSE2Bx 	:= {}
Local nValoIRPF		:= 0
Local aVars    		:= {}
Local aVarsOld 		:= {}
Local lF240TBor		:= ExistBlock("F240TBOR")
Local lF240Semaf	:= ExistBlock("F240SEMA")
Local lF240Bord		:= ExistBlock("F240BORD")
Local lF240TDOK		:= ExistBlock("F240TDOK")
Local lF241CTB		:= ExistBlock("F241CTB")
Local lF241GAVE		:= ExistBlock("F241GAVE")
Local l241Bor       := Existblock("F241BOR")
Local lF241BTN		:= ExistBlock("F241BTN")
Local lF241IND		:= ExistBlock("F241IND")
Local lPCCBaixa 	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lPergDtAg  	:= Type("mv_par11") == "D" .and. Type("mv_par12") == "D" .and. mv_par10 == 1
Local dDtAgIni   	:= ""
Local dDtAgFim   	:= ""
Local lGestao   := FWSizeFilial() > 2
Local cFilFwSE2 := IIF( lGestao, FwFilial("SE2") , xFilial("SE2") )
Local aTmpFil	:= {}
Local aAreaSED  := {}
Local lRetIss 	:= .F.
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local lJFilBco  := SuperGetMv( "MV_JFILBCO", .F., .F. ) .And. FindFunction("JURF3SA6") .And. FindFunction("JurVldSA6") //Indica se filtra as contas correntes vinculadas ao escritório logado - SIGAPFS.
Local cEscrit   := Iif(lJFilBco, JurGetDados("NS7", 4, xFilial("NS7") + cFilant + cEmpAnt, "NS7_COD"), "") // Código do escritório relacionado a filial logada - SIGAPFS.
Local cF3Bco    := Iif(lJFilBco, "SA6JUR", "SA6")
Local cOldImpos		:= ""
Local aMotRet	:= {}
Local nRetMotor := 0
Local l241Versao := SEA->( ColumnPos( "EA_VERSAO" ) ) > 0
Local cChaveTit  := ""
Local lImpMotRet := .F.
Local lCanBorder := GetMv("MV_CANBORP") == "S"//Cancelamento do borderô
Local lClearBrd	 := ExistFunc("FClearBrd")	//Função para ajuste de base
Local cFilSEA       := ""
Local nTamNroBor    := Len(SE2->E2_NUMBOR)
Local cFilBor		:= ""
Local cUpdate       := ""
Local nErro         := 0
Local nIndiceSE2    := 0
Local aLstTipos     := {}
Local lIRTabProg  	:= .F. 
Local oAbatiment    := Nil
Local oGetBco		As Object
Local oGetAge		As Object
Local oGetCon		As Object 
Local aRetIRRF		As Array

cFilOriAnt := ""
aRetIRRF := {}

aBut240 := {{"PESQUISA",{||Fa240Pesq(oMark,cAliasSE2,nIndice)}, STR0053,STR0001}} //"Pesquisar..(CTRL-P)"###"Pesquisar"
bSet16 := SetKey(16,{||Fa240Pesq(oMark,cAliasSE2,nIndice)})

Private nValor		:= 0
Private nQtdTit 	:= 0
Private cPort240 	:= Criavar("EF_BANCO")
Private nMoeda		:= 1
Private dVenIni240	:= dDataBase
Private dVenFim240	:= dDataBase
Private cNumBor		:= Space(6)
Private lVldAD		:= .F.
Private nLimite 	:= 0
Private lMVBP10925  := SuperGetMv("MV_BP10925",.F., "1") == "2" // Default (Bruto)
Private aContab  	:= {}
Private aDadosIR	:= Array(3)
Private nBaseIrpf	:= 0	//Essa variavel era Local e foi tornada Private por necessidades do
							//novo metodo de calculo do IRRF. NAO VOLTE PARA Local
Private cAliasSE2		:= "SE2"
//Reestruturacao SE5
Private	nIrfBaseR 	:= 0
Private	nIssBaseR 	:= 0
Private	nIrfBaseC 	:= 0
Private	nIssBaseC 	:= 0
Private nIrfCalc	:= 0
Private lEmpPub 	:= IsEmpPub()
Private nVlMPub 	:= SuperGetMv("MV_VLMPUB" ,.T.,10)
Private lAplMinP 	:= .F.
Private nTPis		:= 0
Private	nTCof		:= 0
Private	nTcsll		:= 0
Private dDataBord	:= dDataBase
Private nMoedaBco	:= 1
Private lChkTCB	 	:= .F.
Private lChkAPI	 	:= .F.
Private lLibTCB	 	:= .F.
Private lLibAPI	 	:= .F.
Private lVldBco		:= .T.

//Variaveis que serão utilizadas na consulta padrão SEEBOR
PRIVATE cPort060	:= Criavar("EF_BANCO",.F.)
Private cAgen060    := CriaVar("EF_AGENCIA",.F.)
Private cConta060   := Criavar("EF_CONTA",.F.)

DEFAULT lAutomato := .F.

If __lMotorRet
	cOldImpos := FSE2ColImp()
EndIf

__lPccMR 	:= .F.
__lIrfMR	:= .F.
__lIssMR	:= .F.

aBut240 := {{"PESQUISA",{||Fa240Pesq(oMark,cAliasSE2,nIndice)}, STR0053,STR0001}} //"Pesquisar..(CTRL-P)"###"Pesquisar"
bSet16 := SetKey(16,{||Fa240Pesq(oMark,cAliasSE2,nIndice)})

aFill(aDadosIR ,0)

f241LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

// Zerar ABATIMENTO para contabilizacao.
ABATIMENTO := 0
__cFilCtb  := ""

F241PccBx() //Verificar PCC

// Verifica se data do movimento n„o ‚ menor que data limite de movimentacao no financeiro
If !DtMovFin(,,"1")
	Return
Endif

// Semáforo para utilização do Borderô
// Não permite o acesso simultâneo da rotina por mais de 1 usuario.
If lF240Semaf

	// Ponto de entrada para executar o semaforo
	If ExecBlock("F240SEMA",.F.,.F.) //DEM
		IF ( nHdlLock := MSFCREATE("FINA240.L"+cEmpAnt)) < 0
			MsgAlert(STR0042+chr(13)+chr(10)+;	// "A Funcao de geracao de bordero esta sendo utilizada por"
						STR0043+chr(13)+chr(10)+;	// "outro usuario. Por questoes de integridade de dados, nao"
						STR0044+chr(13)+chr(10)+;	// "‚ permitida a utiliza‡„o desta rotina por mais de um usu rio"
						STR0045,STR0005)				// "simultaneamente. Tente novamente mais tarde."###Border“ de Pagamentos
			Return
		Endif

		// Grava no semáforo informações sobre quem está utilizando o Bordero
		FWrite(nHdlLock,"Operador: "+substr(cUsuario,7,15)+chr(13)+chr(10)+;
					"Empresa.: "+cEmpAnt+chr(13)+chr(10)+;
					"Filial..: "+cFilAnt+chr(13)+chr(10))
	Endif
Endif

//--------------------------------------------------------------------
// POR MAIS ESTRANHO QUE PARE€A, ESTA FUNCAO DEVE SER CHAMADA AQUI!
//
// A função SomaAbat reabre o SE2 com outro nome pela ChkFile para
// efeito de performance. Se o alias auxiliar para a SumAbat() não
// estiver aberto antes da IndRegua, ocorre Erro de na ChkFile,
// pois o Filtro do SE2 ultrapassa 255 Caracteres.
//--------------------------------------------------------------------
SomaAbat("","","","P")

// Inicializa a gravacao dos lancamentos do SIGAPCO
PcoIniLan("000023")

//Verifica numero do ultimo Bordero Gerado
If Empty(cNumBor := GetMV("MV_NUMBORP"))
	cNumbor := "000000"
EndIf

cFilBor := SX6->X6_FIL
cNumBor := Soma1(Pad(cNumbor, nTamNroBor), nTamNroBor)	 
cFilSEA := xFilial("SEA")
SEA->(dbSetOrder(2))

While .T.
	If SEA->(MsSeek(cFilSEA+cNumBor+"P", .T.))
		cNumBor := Soma1(cNumBor)
	Else
		Exit
	Endif	
Enddo	

SEA->(dbSetOrder(1))

If !lBorAut .AND. GetNewPar("MV_VLTITAD",.F.)
	Aadd( aBut240, { 'PENDENTE', { || F090VlMark(.T.,cAliasSE2,cMarca,oValor,oQtda,oMark,nValor,"FINA240")}, STR0056, STR0057 } ) //"Verifica se ha Titulos com Adiantamento ou Devolucao"###"Validador"
Endif

If __lMotorRet	//Motor de Retenção
	Aadd( aBut240, { 'RETENCOES', { || FRTCONPOS ("SE2",(cAliasSE2)->NUM_REG)}, STR0139, STR0139 } ) //'Consulta de Retenções'
Endif

While .T.
	If !lBorAut

		// Inicializa variaveis de banco, agencia e conta
		cPort240  := Criavar("A6_COD")
		cAgen240  := CriaVar("A6_AGENCIA")
		cConta240 := CriaVar("A6_NUMCON")

		// Busca por um novo numero de bordero (ainda nao usado)
		lTEMP := .F.

		//Guardo o indice de entrada para a rotina de pesquisa
		nIndice := SE2->(IndexOrd())

		While .T.
			If !MayIUseCode("E2_NUMBOR" + cFilBor + cNumBor)  //verifica se esta na memoria, sendo usado busca o proximo numero disponivel
				cNumBor := Soma1(cNumBor)	
			Else
				Exit
			EndIf
		Enddo

		//Restaura a database do sistema
		dDataBase := dDataAtu
		dDataBord := dDataAtu

		cMoeda240 := cVar := aMoedas[1]
		nOpc := 0

		//Ponto de entrada que permite manipular a data do bordero
		If lF241DTBOR
			dDataBord:=ExecBlock("F241DTBOR",.F.,.F.,{dDataBord})
		EndIf

		If !lF241GAVE
			aSize := MSADVSIZE()
			If lPanelFin //Chamado pelo Painel Financeiro
				dbSelectArea(cAlias)
				oPanelDados := FinWindow:GetVisPanel()
				oPanelDados:FreeChildren()
				aDim := DLGinPANEL(oPanelDados)
				DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )
				//-----------------------------------------------------------------------
				// Observacao Importante quanto as coordenadas calculadas abaixo:
				//-----------------------------------------------------------------------
				// a funcao DlgWidthPanel() retorna o dobro do valor da area do painel,
				// sendo assim este deve ser dividido por 2 antes da subtracao
				// e redivisao por 2 para a centralizacao.
				//-----------------------------------------------------------------------
				nEspLarg := ((DlgWidthPanel(oPanelDados)/2) - 196) /2
				nEspLin  := 0
			Else
		   		nEspLarg := 2
			  	nEspLin  := 2
				DEFINE MSDIALOG oDlg FROM  15,6 TO 380,412 TITLE STR0014 PIXEL  //"Border“s de Pagamentos"   
			Endif

			oDlg:lMaximized := .F.
			oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
			oPanel:Align := CONTROL_ALIGN_ALLCLIENT

			@ 00+nEspLin, nEspLarg TO 32+nEspLin, 200+nEspLarg OF oPanel  PIXEL
			@ 34+nEspLin, nEspLarg TO 91+nEspLin, 200+nEspLarg OF oPanel  PIXEL
			@ 93+nEspLin, nEspLarg TO 120+nEspLin, 200+nEspLarg OF oPanel  PIXEL 
			@ 122+nEspLin, nEspLarg TO 160+nEspLin, 200+nEspLarg OF oPanel  PIXEL 

			nEspLarg := nEspLarg -1

			@ 06+nEspLin, 009+nEspLarg SAY STR0015		SIZE 23, 7 OF oPanel PIXEL  //"N£mero"
			@ 06+nEspLin, 045+nEspLarg SAY STR0016		SIZE 32, 7 OF oPanel PIXEL  //"Vencto de"
			@ 06+nEspLin, 090+nEspLarg SAY STR0017		SIZE 32, 7 OF oPanel PIXEL  //"At‚"
			@ 06+nEspLin, 135+nEspLarg SAY STR0018		SIZE 53, 7 OF oPanel PIXEL  //"Limite Valor"
			@ 40+nEspLin, 009+nEspLarg SAY STR0019		SIZE 23, 7 OF oPanel PIXEL  //"Banco"
			@ 40+nEspLin, 045+nEspLarg SAY STR0020		SIZE 32, 7 OF oPanel PIXEL  //"Agˆncia"
			@ 40+nEspLin, 085+nEspLarg SAY STR0021		SIZE 32, 7 OF oPanel PIXEL  //"Conta"
			@ 40+nEspLin, 151+nEspLarg SAY STR0142 		SIZE 53, 7 OF oPanel PIXEL  //"Sub Conta"
			@ 66+nEspLin, 009+nEspLarg SAY STR0022		SIZE 53, 7 OF oPanel PIXEL  //"Contrato"
			@ 130+nEspLin, 009+nEspLarg SAY STR0023		SIZE 23, 7 OF oPanel PIXEL  //"Moeda"
			@ 130+nEspLin, 063+nEspLarg SAY STR0024		SIZE 22, 7 OF oPanel PIXEL  //"Modelo"
			@ 130+nEspLin, 097+nEspLarg SAY STR0025		SIZE 32, 7 OF oPanel PIXEL  //"Tipo Pagto"
			@ 130+nEspLin, 135+nEspLarg SAY STR0077		SIZE 50, 7 OF oPanel PIXEL  //Data do Bordero


	        IF l241Bor
				lBlqBor:= ExecBlock("F241BOR",.F.,.F.,{lBlqBor})
			Endif

			//Linha 1
			@ 15+nEspLin, 009+nEspLarg MSGET cNumBor        		SIZE 32, 10 OF oPanel PIXEL ;
															Picture "@!" Valid If(!Empty(cNumBor).And.FA240Num(cNumBor, cFilBor),.T.,.F.)when lBlqBor
			@ 15+nEspLin, 045+nEspLarg MSGET dVenIni240     		SIZE 45, 10 OF oPanel PIXEL  HASBUTTON
			@ 15+nEspLin, 090+nEspLarg MSGET dVenFim240     		SIZE 45, 10 OF oPanel PIXEL  HASBUTTON ;
															Valid   If(nOpc<>0,FA240DATA(dVenIni240,dVenFim240),.T.)
			@ 15+nEspLin, 135+nEspLarg MSGET nLimite        		SIZE 60, 10 OF oPanel PIXEL HASBUTTON ;
															Picture "@E 999,999,999,999.99"  Valid If(nOpc<>0,nLimite >= 0,.T.)
			//Linha 2
			@ 49+nEspLin,   9+nEspLarg MSGET oGetBco VAR cPort240       		SIZE 10, 10 OF oPanel PIXEL Picture "@!"  ;
															F3 cF3Bco;
															Valid F240VldBco(@cPort240,@cAgen240,@cConta240,.F.,.F., oGetAge) .And. Iif(lJFilBco, JurVldSA6("1", {cEscrit, cPort240, cAgen240, cConta240}), .T.) HASBUTTON ON CHANGE F241CHKTCB(oTcb, oApi, 1)
			@ 49+nEspLin,  45+nEspLarg MSGET oGetAge VAR cAgen240        		SIZE 26, 10 OF oPanel PIXEL Picture "@!"  ;
															Valid F240VldBco(@cPort240,@cAgen240,@cConta240,.F.,.F., oGetCon) .And. Iif(lJFilBco, JurVldSA6("2", {cEscrit, cPort240, cAgen240, cConta240}), .T.) ON CHANGE F241CHKTCB()
			@ 49+nEspLin,  85+nEspLarg MSGET oGetCon VAR cConta240       		SIZE 62, 10 OF oPanel PIXEL Picture "@!"  ;
															Valid F240VldBco(@cPort240,@cAgen240,@cConta240,.T.,.T., oGetBco) .And. Iif(lJFilBco, JurVldSA6("3", {cEscrit, cPort240, cAgen240, cConta240}), .T.) ON CHANGE F241CHKTCB()
			@ 49+nEspLin, 151+nEspLarg MSGET cSubConta       		SIZE 42, 10 OF oPanel PIXEL Picture "@!" F3 "SEEBOR" Valid Iif(!F241CHKSUBC(cPort240,cAgen240,cConta240,cSubconta),.F.,.T.)
			
			@ 75+nEspLin, 009+nEspLarg MSGET cContrato       		SIZE 42, 10 OF oPanel PIXEL Picture "@S3"

			
			@ 95+nEspLin, 009+nEspLarg CHECKBOX    oTcb VAR lChkTCB PROMPT STR0141 When (.F.) SIZE 140,15 OF oDlg PIXEL  Valid   If(lChkTCB,F241ARQTCB(),.T.)  ON CHANGE F241CHKTCB(oTcb, oApi, 2)// "Transmitir Borderô Através do TOTVS Connect Bank"

			@ 110+nEspLin, 009+nEspLarg CHECKBOX    oApi VAR lChkAPI PROMPT STR0151 When (lLibAPI) SIZE 140,15 OF oDlg PIXEL ON CHANGE F241CHKTCB(oTcb, oApi, 3) //Registro Online de Pagamentos (API)
			
			@ 140+nEspLin, 009+nEspLarg MSCOMBOBOX oCbx VAR cMoeda240 ITEMS aMoedas SIZE 46, 14 OF oPanel PIXEL ;
							 Valid F241VldMd(cPort240,cAgen240,cConta240,Val(cMoeda240))
			
			@ 140+nEspLin, 063+nEspLarg MSGET cModPgto        		SIZE 25, 10 OF oPanel PIXEL Picture "@!"  Valid F240CHKMOD(nOpc, cModPgto) F3 "58" HASBUTTON
			@ 140+nEspLin, 097+nEspLarg MSGET cTipoPag        		SIZE 25, 10 OF oPanel PIXEL Picture "@!"  Valid If(nOpc<>0,ExistCpo("SX5", + "59" + cTipoPag),.T.) F3 "59" HASBUTTON
			@ 140+nEspLin, 135+nEspLarg MSGET dDataBord        		SIZE 60, 10 OF oPanel PIXEL HASBUTTON VALID If(nOpc<>0,dDataBord >= dDataAtu,.T.)

			If lPanelFin  //Chamado pelo Painel Financeiro
				oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])
				ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
				{||cVar:=cMoeda240,nOpc:=1,Iif(F240TudoOk(oDlg),oDlg:End(),nOpc:=0)},;
				{||oDlg:End()})

				cAlias := FinWindow:cAliasFile
				dbSelectArea(cAlias)

		   Else
				DEFINE SBUTTON FROM 169, 142 TYPE 1 ENABLE OF oPanel ACTION (cVar:=cMoeda240,nOpc:=1,;
								Iif(F240TudoOk(oDlg),oDlg:End(),nOpc:=0))
				DEFINE SBUTTON FROM 169, 170 TYPE 2 ENABLE OF oPanel ACTION oDlg:End()

				ACTIVATE MSDIALOG oDlg CENTERED
			Endif
		Else
			AADD(aVars,cNumBor)
			AADD(aVars,dVenIni240)
			AADD(aVars,dVenFim240)
			AADD(aVars,nLimite)
			AADD(aVars,cPort240)
			AADD(aVars,cAgen240)
			AADD(aVars,cConta240)
			AADD(aVars,cContrato)
			AADD(aVars,cMoeda240)
			AADD(aVars,aMoedas)
			AADD(aVars,cModPgto)
			AADD(aVars,cTipoPag)
			AADD(aVars,nOpc)
			AADD(aVars,dDataBord)
			aVarsOld := aClone(aVars)
			aVars := aClone(Execblock("F241GAVE",.F.,.F.,aVars))

			//Valida retorno do PE F241GAVE
			If ValType(aVars) != "A" .Or. Len(aVars) < 13
				aVars := aClone(aVarsOld)
			Endif

			cNumBor   := aVars[1]
			dVenIni240:= aVars[2]
			dVenFim240:= aVars[3]
			nLimite   := aVars[4]
			cPort240  := aVars[5]
			cAgen240  := aVars[6]
			cConta240 := aVars[7]
			cContrato := aVars[8]
			cMoeda240 := aVars[9]
			aMoedas   := aVars[10]
			cModPgto  := aVars[11]
			cTipoPag  := aVars[12]
			nOpc      := aVars[13]
			dDataBord := aVars[14]
			cVar      := cMoeda240
			nMoedaBco := Max(MoedaBco(cPort240, cAgen240, cConta240), 1)
		EndIf

		If lPergDtAg
			dDtAgIni := mv_par11
			dDtAgFim := mv_par12
		EndIf

		fa240Perg()

		// Recupera os valores da conf. apos inicializacao
		If lPergDtAg
			If !Empty(dDtAgFim) .and. Empty(mv_par11)
				mv_par11 := dDtAgIni
				mv_par12 := dDtAgFim
			EndIf
		EndIf

		If nOpc != 1
			Set Filter to
			dbSetOrder(1)
			Exit
		EndIF

		nMoeda := Val(Substr(cVar,1,2))

		// Acerto a database do sistema de acordo com a data do bordero
		dDataBase := dDataBord

		// Ponto de entrada para Filtro complementar
		IF lF240FIL
			cFil240 := ExecBlock("F240FIL",.f.,.f.)
		Else
			cFIl240 := ""
		Endif

		//Gestao - Selecao de filiais
		aSelFil	:= {}
		
		If (lLibTCB .Or. mv_par08 == 2)
			aSelFil := { cFilAnt }
		Else
			aSelFil := AdmGetFil(.F., .T., "SE2")
			
			If Len( aSelFil ) <= 0
				Exit
			EndIf
		EndIf

		//Inicializa o array aRestrict com campos que devem ser apresentados,independente das configuração do dicionário.
		aRestrict := F240Restr(lAutomato,lBorAut)
		lTEMP     := .T.
		cAliasSE2 := "SE2TMP"
		
		//Funcao para montar e processar a query
		cArqNew := f241QryA(.F., @cAliasSE2, aCampos, aRestrict, cIndTemp1, cIndTemp2,aSelFil, aTmpFil, cModPgto)
		
		//Incluindo o botao para atualizar a lista somente para ambientes que utilizam query
		If aScan(aBut240,{|x| x[1] == "PMSRRFSH"}) == 0
			aAdd(aBut240,{"PMSRRFSH",{|| MsAguarde( { || f241QryA(.T.,cAliasSE2, aCampos, aRestrict, cIndTemp1, cIndTemp2, aSelFil, aTmpFil, cModPgto) },;
				STR0041, STR0092, .F.)}, STR0093})		//"Atualizando"###"Aguarde, atualizando a lista"###"Atualizar"
		Endif

		If cArqNew == "NOACESS"  // Caso o usuario não tenha nenhuma permissão aborta o processo do bordero
			Help(" ",1,"RECNO")
			FreeUsedCode() //libera codigos de correlativos reservados pela MayIUseCode()
			Return
		EndIf

		If !Empty( cArqNew )
			dbselectarea(cAliasSE2)
			dbGoTop()
		EndIf

		If Empty( cArqNew ) .Or. (cAliasSE2)->( BOF() ) .and. (cAliasSE2)->( EOF() )
			Help(" ",1,"RECNO")
			FreeUsedCode() //libera codigos de correlativos reservados pela MayIUseCode()
			If !Empty( cArqNew )
				dbSelectArea(cAliasSE2)
				dbCloseArea()
			EndIf

			lTEMP := .F.
		    Exit
		EndIf
		dbGoTop()

		bWhile := { || !Eof() }

		nValor  := 0    // valor total dos titulos,mostrado no rodape do browse
		nQtdTit := 0    // quantidade de titulos,mostrado no rodape do browse
		nOpca   := 0

		SX3->(dbSetOrder(1))

		DEFINE FONT oFnt NAME "Arial" SIZE 12,14 BOLD

		//Realiza ou nao pre-marcacao
		DBEVAL({ |a| FA240DBEVA(nLimite,dVenIni240,dVenFim240,cAliasSE2,,,.T.)},bWhile)

		// Caso a rotina tenha sido chamada através da automação de testes, não apresenta a interface.
		If !lAutomato

			// PONTO DE ENTRADA PARA ALTERAR A ORDEM DOS CAMPOS NA MARKBROWSE
			If lF241MARK
				aAltMark := ExecBlock("F241MARK",.F.,.F.,aCampos)
				nPos := Ascan(aAltMark,{|X|X[1] == "E2_OK"})

				// FORCA O PRIMEIRO CAMPO SER SEMPRE O E2_OK
				If nPos != 1
					aCampos := {}
					aAdd(aCampos,{"E2_OK","","  ",""})
					aEval(aAltMark,{|Z| If(Z[1] <> "E2_OK",aAdd(aCampos,{Z[1],Z[2],Z[3],Z[4]}),NIL)})
				Else
					aCampos := aAltMark
				Endif
			Endif
			dbselectarea(cAliasSE2)
		    dbsetorder(1)
			dbGoTop()

			//Faz o calculo automatico de dimensoes de objetos
			oSize := FwDefSize():New(.T.)

			oSize:lLateral := .F.
			oSize:lProp	:= .T. // Proporcional

			oSize:AddObject( "1STROW" ,  100, 10, .T., .T. ) // Totalmente dimensionavel
			oSize:AddObject( "2NDROW" ,  100, 90, .T., .T. ) // Totalmente dimensionavel

			oSize:aMargins := { 2, 2, 1, 2 } // Espaco ao lado dos objetos 0, entre eles 3

			oSize:Process() // Dispara os calculos

			a1stRow := {oSize:GetDimension("1STROW","LININI"),;
						oSize:GetDimension("1STROW","COLINI"),;
						oSize:GetDimension("1STROW","LINEND"),;
						oSize:GetDimension("1STROW","COLEND")}

			a2ndRow := {oSize:GetDimension("2NDROW","LININI"),;
						oSize:GetDimension("2NDROW","COLINI"),;
						oSize:GetDimension("2NDROW","LINEND"),;
						oSize:GetDimension("2NDROW","COLEND")}

			DEFINE MSDIALOG oDlg1 TITLE STR0005 From oSize:aWindSize[1],oSize:aWindSize[2] to oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL //"Border“ de Pagamentos"
			oDlg1:lMaximized := .T.

			////////
			// Panel
			@ a1stRow[1] + 001, a1stRow[2] + 001 To a1stRow[3],a1stRow[4] PIXEL OF oDlg1
			@ a1stRow[1] + 003, a1stRow[2] + 005 Say STR0015 FONT oDlg1:oFont PIXEL Of oDlg1 // "N£mero"
			@ a1stRow[1] + 003, a1stRow[2] + 060 Say cNumbor Picture "@!" FONT oFnt PIXEL Of oDlg1

			@ a1stRow[1] + 012, a1stRow[2] + 005 Say STR0030  PIXEL Of oDlg1 //"Valor Total:"
			@ a1stRow[1] + 012, a1stRow[2] + 060 Say oValor VAR nValor Picture "@E 999,999,999,999.99" SIZE 50,8  PIXEL Of oDlg1
			@ a1stRow[1] + 012, a1stRow[2] + 150 Say STR0031  PIXEL Of oDlg1 //"Quantidade:"
			@ a1stRow[1] + 012, a1stRow[2] + 200 Say oQtda VAR nQtdTit Picture "@E 99999" SIZE 50,8  PIXEL Of oDlg1
			// Panel
			////////

			/////////////
			// MarkBrowse
			oMark := MsSelect():New(cAliasSE2,"E2_OK","!E2_SALDO",aCampos,@lInverte,@cMarca,{a2ndRow[1],a2ndRow[2],a2ndRow[3],a2ndRow[4]},"Fa241Top(1)","Fa241Top(2)")
			oMark:bMark := {|| FA240Disp(cMarca,lInverte,oValor,oQtda)}
			oMark:bAval	:= {|| Fa240Mark(cMarca,oValor,oQtda,cAliasSE2,(cAliasSE2)->NUM_REG)}
			oMark:oBrowse:lhasMark = .t.
			oMark:oBrowse:lCanAllmark := .t.
			oMark:oBrowse:bAllMark := { || FA240Inverte(cMarca,oValor,oQtda,,cAliasSE2) }
			oMark:oBrowse:nFreeze := 1	// Congela a primeira coluna.
			// MarkBrowse
			/////////////

			bOk1 := {|| If( !GetNewPar("MV_VLTITAD",.F.), lVldAD := .T., Nil ) }
			bOk2 := {|| nOpca := 1,oDlg1:End()}
			bOk3 := {|| MsgInfo(STR0058,STR0055) } //"Antes de confirmar as baixas, execute o botao para validar titulos cujo Fornecedor possua Adiantamento ou Devolucao."

			If lPanelFin //Chamado pelo Painel Financeiro
				ACTIVATE MSDIALOG oDlg1 ON INIT (FaMyBar(oDlg1,{|| ( Eval(bOk1), If(lVldAd,Eval(bOk2),Eval(bOk3)) ) },;
																	{|| nOpca := 2,oDlg1:End()},aBut240), IIf(lF241IND,oMark:oBrowse:Refresh(.T.),.T.) )
		    Else
				ACTIVATE MSDIALOG oDlg1 ON INIT (EnchoiceBar(oDlg1,{|| ( Eval(bOk1), IF(F241Conf(), If(lVldAd,Eval(bOk2),Eval(bOk3)),Nil))},;
																	{|| nOpca := 2,oDlg1:End()},, IIF(lF241BTN, aBut240 := ExecBlock("F241BTN",.F.,.F.,aBut240),aBut240)),IIf(lF241IND,oMark:oBrowse:Refresh(.T.),.T.)) CENTER

			Endif
		Else
			nOpcA := 1
		EndIf

		SetKey(16,bSet16)

		//Limpa a variavel static __oPreparC utilizada pela função FINXVRET()
		FRTDelObj(1)
		
		If nQtdTit == 0 .and. nValor = 0
			Exit
		EndIf
		If nValor <= 0
			Help(" ",1,"FA240VALOR")
			Loop
		EndIf

		// Execblock para validar as informacoes para geracao do bordero
		If nOpca == 1
			IF lF240TDOK
				nOpca := If(ExecBlock("F240TDOK",.f.,.f., { cMarca, cAliasSE2 } ),1,2) //DEM
			Endif
		Endif

		If nOpcA == 2							// Redigita / Abandona
			FreeUsedCode()  //libera codigos de correlativos reservados pela MayIUseCode()
			Exit
		EndIf
	EndIf
	
	If nOpcA == 1	// Confirma
		If lBorAut
			cAliasSE2	:= aBorAut[1]
			cPort240	:= aBorAut[2]
			cAgen240	:= aBorAut[3]
			cConta240	:= aBorAut[4]
			cModPgto	:= aBorAut[5]
			cTipoPag	:= aBorAut[6]
			dDataBase	:= aBorAut[7]

			//controle para que o bordero seja via api
			If len(aBorAut) > 8
				cSubConta	:= aBorAut[8]
				lChkAPI		:= aBorAut[9]
			EndIf		
		EndIf
		
		BEGIN TRANSACTION
			aLstTipos := Strtokarr(MVABATIM, "|")
			nMoeda    := Val(Substr(cVar,1,2))
			DbSelectArea(cAliasSE2)
			
			If !lBorAut
				(cAliasSE2)->(DbGoTop())
			ElseIF lF240FIL
				cFil240 := ExecBlock("F240FIL",.f.,.f.,{lBorAut})
				
				If !Empty(cFil240)
					dbSetOrder(1)
					(cAliasSE2)->(dbsetfilter({||&cFil240},cFil240))
					(cAliasSE2)->(DbGoTop())
				Endif
			Endif
			
			While !(cAliasSE2)->( Eof( ) ) .AND. If(lBorAut, (cAliasSE2)->E2_FORBCO == cPort240, .T. )
				//Se titulo marcado -> gera o bordero com ele.
				If lBorAut .Or. (cAliasSE2)->E2_OK == cMarca
					If (!lBorAut .Or. Empty(cFil240))
						SE2->(MSGOTO((cAliasSE2)->NUM_REG))
					EndIf

					//Verifico os impostos que estão configurados pelo Motor
					//Motor de Retencoes
					If __lMotorRet
						aMotRet := F241ImpCnf("1", SE2->E2_FILORIG, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ)
						lImpMotRet := (Len(aMotRet) > 0)
						If !lImpMotRet
							cChaveTit := xFilial("SE2", SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
							lImpMotRet := Len(aImpFis := FinImpFis(cChaveTit, SE2->E2_FILORIG, "SE2", .T., 0, Nil, SE2->E2_FORNECE, SE2->E2_LOJA) ) > 0
						EndIF
					EndIf
					
					//Verifica se é IRPF pela Baixa para guardar os títulos que devem ter retenção
					If !__lIrfMR .And. __lLocBra .And. Posicione("SA2",1,xfilial("SA2") + SE2->(E2_FORNECE+E2_LOJA),"A2_CALCIRF") == "2"
						lIRPFBaixa :=	(Posicione("SED",1,FWxfilial("SED",SE2->E2_FILIAL) + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S" .Or. (SA2->A2_MINPUB == "1" .and. SA2->A2_MINIRF == "1"))
					EndIf
					
					If !__lIssMR
						lCalcIssBx := GetCalcIss(SE2->E2_FILORIG)
					EndIf
					
					lAplMinP   := SA2->A2_MINPUB == "2"
					
					If __lPCCBaixa .Or. lIRPFBaixa .OR. lCalcIssBx .OR. lImpMotRet // Verifica se é IRPF pela Baixa para guardar os títulos
						//Guardo os titulos que tiveram impostos da 10925 para verificar
						//posteriormente a retencao dos mesmos ou aqueles que devem ter retenção de IRPF
						If (SE2->(E2_PIS+E2_COFINS+E2_CSLL) > 0) .Or. lIRPFBaixa .Or. lCalcIssBx .Or. lPccBaixa .or. lImpMotRet
							aadd(aRetencao, { SE2->(Recno()), SE2->E2_FORNECE, SE2->E2_LOJA, DTOS(SE2->E2_VENCREA), STRZERO(SE2->E2_SALDO * 100,17), 0, lIRPFBaixa .Or. lCalcIssBx .Or. __lPCCBaixa .Or. lPccBaixa, lImpMotRet })
						Endif
					EndIf

					// Guarda o portador anterior para envia-lo ao PE F240TBOR, caso o usuario nao queira que seja alterado o portador
					cOldPort240 := SE2->E2_PORTADO

					//Verifica se tem um registro solto na SEA para evitar que dê chave duplicada quando MV_CANBORP == s
					If lCanBorder .AND. lClearBrd
						FClearBrd(cNumBor)
					Endif

					dbSelectArea("SEA")
					RecLock("SEA",.T. )
					EA_FILIAL	:= xFilial("SEA")
					EA_PORTADO	:= cPort240
					EA_AGEDEP	:= cAgen240
					EA_NUMCON	:= cConta240
					EA_NUMBOR	:= cNumBor
					EA_DATABOR	:= dDataBase
					EA_PREFIXO	:= SE2->E2_PREFIXO
					EA_NUM		:= SE2->E2_NUM
					EA_PARCELA	:= SE2->E2_PARCELA
					EA_TIPO		:= SE2->E2_TIPO
					EA_FORNECE	:= SE2->E2_FORNECE
					EA_LOJA		:= SE2->E2_LOJA
					EA_CART		:= "P"
					EA_MODELO	:= cModPgto
					EA_TIPOPAG	:= cTipoPag
					EA_FILORIG	:= SE2->E2_FILORIG
					EA_ORIGEM	:= "FINA241"
					
					If l241Versao
						EA_VERSAO  := "0001"
					Endif

					If lSubCtaEA
						EA_SUBCTA  := cSubConta
					EndIf

					If FindFunction("F713VldUso") .and. F713VldUso()
						EA_BORAPI := IIF(lChkAPI,'S','N')
					Endif	

					MsUnlock()
					FKCOMMIT()

					RecLock("SE2")
					Replace E2_NUMBOR  With cNumBor //Utilizo esse campo na query para selecionar os valores de inss entao deve ainda estar vazio.
					Replace E2_PORTADO With cPort240
					If __lLocBra
						Replace E2_DTBORDE With dDataBase
					Endif

					//Novo calculo de IRRF na Baixa
					Replace E2_PRETIRF With '6'

					AADD(aChaveTit,SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

					MsUnlock( )
					FKCOMMIT()

					//Envio de e-mail pela rotina de checklist de documentos obrigatorios
					IF lFinVDoc
						CN062ValDocs("06",.F.,.T.)
					EndIf
					
					cFilBck := cFilAnt

					//Seleção de filiais
					If mv_par08 == 1 .And. !Empty( SE2->E2_FILORIG )
						cFilAnt := SE2->E2_FILORIG
					EndIf
					
					nIndiceSE2 := SE2->(IndexOrd())
					SE2->(DbSetOrder(17))
					
					If SE2->(DbSeek(SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
						If oAbatiment == Nil
							cUpdate := "UPDATE ? SET E2_NUMBOR = ?, E2_PORTADO = ? "
							
							If __lLocBra
								cUpdate += ", E2_DTBORDE = ? "
							EndIf
							
							cUpdate += "WHERE E2_FILIAL = ? "
							cUpdate += "AND E2_PREFIXO  = ? "
							cUpdate += "AND E2_NUM = ? "
							cUpdate += "AND E2_PARCELA = ? "
							cUpdate += "AND E2_TIPO IN (?) "
							cUpdate += "AND E2_FORNECE = ? "
							cUpdate += "AND E2_LOJA = ? "
							cUpdate += "AND D_E_L_E_T_ = ' ' "
							oAbatiment := FWPreparedStatement():New(cUpdate)
						EndIf
						
						oAbatiment:SetNumeric(1, RetSqlName("SE2"))
						oAbatiment:SetString(2, cNumBor)
						oAbatiment:SetString(3, cPort240)						
						
						If __lLocBra
							oAbatiment:SetString(4, DTOS(dDataBase))						
						EndIf
						
						oAbatiment:SetString(IIf(__lLocBra, 5, 4), SE2->E2_FILIAL)
						oAbatiment:SetString(IIf(__lLocBra, 6, 5), SE2->E2_PREFIXO)
						oAbatiment:SetString(IIf(__lLocBra, 7, 6), SE2->E2_NUM)
						oAbatiment:SetString(IIf(__lLocBra, 8, 7), (cAliasSE2)->E2_PARCELA)
						oAbatiment:SetIn(IIf(__lLocBra, 9, 8), aLstTipos)
						oAbatiment:SetString(IIf(__lLocBra, 10, 9), (cAliasSE2)->E2_FORNECE)
						oAbatiment:SetString(IIf(__lLocBra, 11, 10), (cAliasSE2)->E2_LOJA)
						cUpdate := oAbatiment:GetFixQuery()
						
						If (nErro := TCSqlExec(cUpdate)) != 0
							Help(Nil, Nil, "F241GERBOR", Nil, STR0147 + ": " + SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA), 1, 0, Nil, Nil, Nil, Nil, Nil, {})
							DisarmTransaction()
							Break
						EndIf
					EndIf
					
					DbSelectArea("SE2")
					SE2->(DbSetOrder(nIndiceSE2))
					SE2->(MsGoTo((cAliasSE2)->NUM_REG))
					cFilAnt := cFilBck
					
					If lF240TBor
						ExecBlock("F240TBOR",.f.,.f.,{cOldPort240,cPort240})  //DEM
					Endif
				Else
					cChave := ""
				Endif

				(cAliasSE2)->(dbskip())

				If lBorAut
					nQtdTit++
				EndIf
			EndDo
			
			FwFreeArray(aLstTipos)
			
			If lBorAut
				Aadd(aBorAut,cNumBor)
				Aadd(aBorAut,nQtdTit)
			EndIf
			
			//Grava o numero do bordero atualizado
			If GetMV("MV_NUMBORP") < cNumbor
				PutMV("MV_NUMBORP",cNumbor)
			Endif
			
			//Chama rotina para geração/transmissão do arquivo de cnab via TCB
			If lChkTCB
				cMvPar07  := mv_par07
				lPergunte := pergunte("AFI420",.F.)
				
				mv_par01 := cNumBor
				mv_par02 := cNumBor
				mv_par03 := "TCBPENV.2PE"
				mv_par04 := "C:\CNAB"
				mv_par05 := cPort240
				mv_par06 := cAgen240
				mv_par07 := cConta240
				mv_par08 := cSubConta
				mv_par09 := 2
				mv_par11 := xFilial("SE2")	 // Filial de     	       
				mv_par12 := mv_par11
				
				nQtdTitLote := 0
				nQtdLinLote := 0
				nSomaVlLote := 0
				nSomaAbLot	:= 0	
				nQtdTotTit	:= 0
				nQtdLnLote  := 0
				Fa420Gera("SE2", lAutomato)
				mv_par07 := cMvPar07
			Endif
			
			//Limpo o filtro do SE2
			dbSelectArea("SE2")
			SE2->(dbClearFil())
			SE2->(DbSetOrder(1))
			
			If Len(aRetencao) > 0
				//x[2] = Fornecedor, x[3] = Loja, x[4] = Vencimento Real, x[5] = Saldo
				aSort(aRetencao,,,{|x,y| Str(x[1])+x[2]+x[3]+x[4]+x[5] <= Str(y[1])+y[2]+y[3]+y[4]+y[5]})
				
				nTotal    := 0
				nHdlPrv   := 0
				lContabil := .T.
				nValTot   := 0
				
				If lF241CTB
					lContabil := ExecBlock("F241CTB",.F.,.F.) //DEM
				EndIf
				
				aValPgto := {0,0}
				
				For nLoop := 1 to Len(aRetencao)
					SE2->(DbGoto(aRetencao[nLoop][1]))

					If !__lIssMR .And. cFilOriAnt <> SE2->E2_FILORIG
						lCalcIssBx := GetCalcIss(SE2->E2_FILORIG)
						cFilOriAnt := SE2->E2_FILORIG
					EndIf	

					lRetIss   := ((SE2->E2_VRETISS > 0) .Or. (SE2->E2_ISS > 0  .And. lCalcIssBx))
					nRetMotor := 0					
					
					//Ajuste para geração dos impostos na filial de origem do titulo.
					If !Empty(cFilFwSE2) .And. cFilAnt <> SE2->E2_FILIAL

						If (nLoop > 1) .and. !Empty(nTotal)
                            cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, If(lBorAut, (aBorAut[8]), (mv_par07 == 1)) /*lDigita*/, .F. /*lAglut*/,;
                                    /*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, __aCTBPrv, /*aDiario*/)
                            aFlagCTB := {}
                            nTotal := 0
                            nHdlPrv := 0
                        EndIf

                        cFilAnt := SE2->E2_FILIAL
					EndIf
					
					SED->(dbSetOrder(1))
					SED->(MSSeek(xFilial("SED")+SE2->E2_NATUREZ))
					SA2->(dbSetOrder(1))
					SA2->(MSSeek(xFilial("SA2",SE2->E2_FILORIG)+SE2->(E2_FORNECE+E2_LOJA)))

					lIRTabProg := ( SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG == "1") ) // Define que será usado a tabela progressiva 
					
					If aRetencao[nLoop,8] //Tem retenção pelo Motor de retenções
						//Grava baixa da retenção do Motor
						nRetMotor := F241GrvIMR(dDataBord,"FINA241", lContabil, @nTotal, @nHdlprv, @cArquivo, lUsaFlag, @aFlagCtb)
					EndIf
					
					If aRetencao[nLoop,7]
						//Caso Natureza calcule IRRF de carreteiro
						If Posicione("SED", 1, xFilial("SED")+SE2->E2_NATUREZ, "ED_IRRFCAR") == "S"
							lCarret := .T.
						EndIf
						
						//Verifica se é IRPF pela Baixa para guardar os títulos que devem ter retenção
						If !__lIrfMR
							//IRRF na Baixa
							lBaseIrrf  := F050BIRPF(2)
							nIndBaseIR := 1
							
							If lBaseIrrf
								nIndBaseIR := If(SED->ED_BASEIRF > 0, (SED->ED_BASEIRF/100),1)
							Endif
							
							lIRPFBaixa :=	IIF(__lLocBra, Posicione("SA2",1,xfilial("SA2") + SE2->(E2_FORNECE+E2_LOJA),"A2_CALCIRF") == "2" .And. ;
											(Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S" .or. ;
											(SA2->A2_MINPUB == "1" .and. SA2->A2_MINIRF == "1")),.F.)
							
							//Caso não seja IRRF na Baixa, desvio de todos os cálculos
							__lIrfMR := If (lIRPFBaixa, __lIrfMR, .F.)
						EndIf
						
						lAplMinP := (SA2->A2_MINPUB == "2")
						
						//Busca base de cálculo para o  IRPF caso não tenha sido calculada
						If lIRPFBaixa .And. !SE2->E2_TIPO $ MVPAGANT
							If !__lIrfMR
								SE2->(DbGoTo(aRetencao[nLoop,1]))
								nAcresc   := SE2->E2_SDACRES
								nDecresc  := SE2->E2_SDDECRE
								nValoIRPF := 0
								
								//Calculo para o  IRRF, o primeiro parametro, neste caso vai zerado pois o calculo eh feito com base no saldo do titulo
								If (dDataBase < dLastPCC .or. (lEmpPub .And. SE2->E2_PRETIRF <> "4")) .Or. (dDatabase >= dLastPCC .and. !lEmpPub .And. SE2->E2_PRETIRF <> "4")
									nValoIRPF :=  FCalcIRBx(0, SA2->A2_TIPO, dDataBord, dDataBord)
									
									If nValoIRPF == 0 //não haverá retenteção, retornando o status para pendente
										RecLock("SE2",.F.)
										SE2->E2_PRETIRF := '1'
										Msunlock()
									EndIf
								EndIf
								
								If nValoIRPF > 0 .and. lAplMinP .And. lEmpPub .And. lIRPFBaixa .and. SE2->E2_PIS+SE2->E2_VRETPIS+SE2->E2_COFINS+SE2->E2_VRETCOF+SE2->E2_CSLL+SE2->E2_VRETCSL+nValoIRPF < nVlMPub
									nValoIRPF	:= 0
								EndIf
								
								//Efetua baixa parcial do título caso o mesmo tenha retenção do IRPF
								F241BxIRPF(nValoIRPF, lContabil, aRetencao[nLoop,1], @nTotal, @nHdlprv, lUsaFlag, @aFlagCTB, ,lIRTabProg, @aRetIRRF)
							ElseIf (dDataBase < dLastPCC .or. (lEmpPub .And. SE2->E2_PRETIRF <> "4")) .Or. (dDatabase >= dLastPCC .and. !lEmpPub .And. SE2->E2_PRETIRF <> "4" )
								RecLock("SE2",.F.)
								SE2->E2_PRETIRF := '1'
								Msunlock()
							Endif
						Endif

						//Efetua baixa parcial do título caso o mesmo tenha retenção do PCC
						If !__lPccMR .and. __lPCCBaixa

                            If nLoop == Len(aRetencao) .and. !Empty(nTotal)
                                cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, If(lBorAut, (aBorAut[8]), (mv_par07 == 1)) /*lDigita*/, .F. /*lAglut*/,;
                                        /*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, __aCTBPrv, /*aDiario*/)
                                aFlagCTB := {}
                                nTotal := 0
                                nHdlPrv := 0
                            EndIf

							F241Impost(lBaseSE2, cModTot, cModRetPis, cNccRet, nVlMinImp, @nTotal, @nHdlPrv, @cArquivo, lContabil, @nValTot, aChaveTit, @aFlagCtb, nLoop == Len(aRetencao), nRetMotor,,, aRetIRRF)
						EndIf
                        
					EndIf
					
					SED->(MSSeek(xFilial("SED")+SE2->E2_NATUREZ))
					aAreaSED := SED->(GetArea())
					
					If !__lIssMR .And. lRetIss .And. GetCalcIss(SE2->E2_FILORIG)
						//Efetua baixa parcial do título caso o mesmo tenha retenção do ISS
						nIss := (SE2->E2_ISS - SE2->E2_VRETISS)
						F241BxISS(nIss, lContabil, aRetencao[nLoop,1], @nTotal, @nHdlprv, lUsaFlag, @aFlagCTB)
					Endif
					
					SED->(RestArea(aAreaSED))
					
					If SA2->A2_TIPO == "J" .And. lIRPFBaixa .And. !__lIrfMR
						If aScan(aTitSE2Bx, {|nRecno| nRecno[1] == aRetencao[nLoop,1]}) == 0
							aAdd(aTitSE2Bx, {aRetencao[nLoop,1]})
						EndIf
					EndIf
				Next

                If !Empty(nTotal)
                    cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, If(lBorAut, (aBorAut[8]), (mv_par07 == 1)) /*lDigita*/, .F. /*lAglut*/,;
                            /*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, __aCTBPrv, /*aDiario*/)
                    aFlagCTB := {}
                    nHdlPrv := 0
                EndIf

			Endif
		END TRANSACTION
	EndIf
	Exit
EndDo

If nOpca == 1 .And. lF240Bord
	ExecBlock("F240BORD",.F.,.F.) //DEM
EndIf

If lContabil .And. nTotal > 0
	VALOR := nValTot
	SE2->(DbGoto(0))
	FK2->(DbGoto(0))
	SE5->(DbGoto(0))
	
	If !Empty(__cFilCtb) .And. AllTrim(__cFilCtb) != AllTrim(cFilAnt)
		cFilAnt := __cFilCtb 	
	EndIf
	
	//Prepara Lancamento Contabil
	nTotal += DetProva(nHdlPrv, "530" /*cPadrao*/, "FINA241" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/,;
						/*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, /*@aFlagCTB*/, /*aTabRecOri*/, __aCTBPrv)
	
	//Efetiva lançamento contábil
	cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, If(lBorAut, (aBorAut[8]), (mv_par07 == 1)) /*lDigita*/, .F. /*lAglut*/,;
			/*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, /*aDiario*/)
	aFlagCTB := {}
EndIf

cFilAnt   := cFilBak
__cFilCtb := ""

If lF241IRAN
	ExecBlock("F241IRAN",.f.,.f.,{cNumBor})
Endif

//Apaga o semáforo
If lF240Semaf
	fclose(nHdlLock)
	Ferase("FINA240.L"+cEmpAnt)
EndIf

//Libera os registros
If lTEMP
	(cAliasSE2)->(dbGoTop())
	
	While (cAliasSE2)->(!EOF())
		SE2->(dbGoto((cAliasSE2)->NUM_REG))
		SE2->(MsUnlock())
		(cAliasSE2)->(MsUnlock())
		(cAliasSE2)->(dbSkip())
	Enddo
	
	If !lBorAut
		If Select(cAliasSE2) > 0
			dbSelectArea(cAliasSE2)
			dbCloseArea()
		Endif
		
		If File(cArqNew+GetdbExtension())
			FErase(cArqNew+GetdbExtension())
		Endif
	Endif
Endif

F240Clean(.T.) //Deleta tabela temporária no banco de dados criada da função F240MTTMP (FINA240.PRW)

// Restaura os indices
dbSelectArea("SE2")
SE2->(DbSetOrder(1))
SE2->(DbGoTop())

//Finaliza a gravacao dos lancamentos do SIGAPCO
PcoFinLan("000023")

dbSelectArea("SE2")
//Restaura o filtro
Set Filter To &cSetFilter.
SE2->(DbSetOrder(1))

If nSavRec > 0
	SE2->(dbGoTo(nSavRec))
Endif

//Restaura a database do sistema
dDataBase := dDataAtu

//Gestao
For nX := 1 TO Len(aTmpFil)
	CtbTmpErase(aTmpFil[nX])
Next

If lPanelFin //Chamado pelo Painel Financeiro
	dbSelectArea(FinWindow:cAliasFile)
	FinVisual(FinWindow:cAliasFile,FinWindow,(FinWindow:cAliasFile)->(Recno()),.T.)
Endif

Return


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} FA241Canc
Cancela os borderos

@author Mauricio Pequim Jr

@since 28/01/05
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function FA241Canc(cAlias As Character,nReg As Numeric,nOpcx As Numeric,aBorAut As Array,lAutomato As Logical)
	Local cFilOriAnt As Character
	Local lPanelFin		:= IsPanelFin()
	Local cChave		:= ""
	Local nSavRec		:= SE2->( Recno() )
	Local lF240Can		:= ExistBlock("F240CAN")
	Local lF240Pcb		:= ExistBlock("F240PCB")
	Local lDeleta		:= .T.
	Local lF240Ok		:= ExistBlock("F240Ok")
	Local cOldPortado	:= ""
	Local aSemRet		:= {}
	Local aRecEAE2		:= {}
	Local lContIRPF		:= .T.
	Local aRetencao		:= {}
	Local cArquivo		:= ""
	Local nTotal		:= 0
	Local nHdlPrv		:= 0
	Local nX            := 0
	Local nY			:= 0
	Local lF241CTB		:= ExistBlock("F241CTB")
	Local lContabil		:= .T.
	Local lDelBord		:= .T.
	Local lRetencao		:= .F.
	Local lF241CBD		:= ExistBlock("F241CBD")
	Local lPergunte		:= .F.
	Local dDataAtu		:= dDatabase
	Local dDataBord		:= dDatabase
	Local aFornecPcc	:= {}
	Local lRecalcPCC	:= GetNewPar("MV_RC10925","2") == "1"
	Local nCount		:= 0
	Local aFlagCTB		:= {}
	Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	Local cFilBak		:= cFilAnt
	Local aArea			:= {}
	Local lIRPFBaixa	:= .F.
	Local lCalcIssBx	:= GetCalcIss(cFilAnt)
	Local lAddRetenc	:= .F.	//Controle para adicao do titulo ao array aRetencao
	Local aAreaSE2		:= SE2->(GetArea())
	Local aAreaSEA		:= {}
	Local aAreaSFQ		:= {}
	Local lF241NBor		:= ExistBlock( "F241NBOR" )
	Local lNoDeleta		:= .T.
	Local cFilCTB		:= cFilAnt
	Local cChaveSE2 	:= ""
	Local cIdFK7 	  	:= ""
	Local lGestao   := FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
	Local cFilFwSE2 := IIF( lGestao , FwFilial("SE2") , xFilial("SE2") )
	Local lRet 		:= .T.
	Local lCpRet	:= .F.
	Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	Local cTabCanc := ""
	Local cNumBorCan := ""
	Local cAliasAux := ""
	Local cFilBord := ""
	Local aImpPCC	 := {{"PIS"},{"COF"},{"CSL"},{"IRF"},{"ISS"}}
	Local cIdDoc	 := ""
	Local aImpRetOut := {}
	Local lF241MPCC 	:= ExistBlock("F241MPCC")
	Local aImpBx2Can := {}
	Local lImpMotRet := .F.
	Local cChaveTit  := ""
	Local lCancel240 := FwIsInCallStack("FA240Canc") 
	Local nAliqIRRF	 := SuperGetMV("MV_ALIQIRF")
	Local lIRTabProg := .F.
	Local dDtGerBor  := CTOD("  /  /  ")
	Local nIndiceSE2 := 0
	Local cUpdate    := ""
	Local aLstTipos  := {}
	Local lTemAbati  := .F.
	Local cE2NUMBOR  := Space(TamSX3("E2_NUMBOR")[1])					
	Local cE2PORTADO := Space(TamSX3("E2_PORTADO")[1])
	Local dE2BAIXA   := CTOD("  /  /  ")	
	Local nErro      := 0
	Local oAbatiment := Nil
	Local lTemAdt	 := .F.
	Local oBuscaBx	 := Nil
	Local dTemBaixa	 := CTOD(" / / ")
	Local lbuscUltBx := FindFunction("buscaUltBx")
	Local lDisarmTran as Logical

	DEFAULT lAutomato := .F.

	cFilOriAnt := ""
	lDisarmTran := .F.

	// Zerar ABATIMENTO para contabilizacao.
	ABATIMENTO := 0

	If Select( "__SE2" ) == 0
		SomaAbat("","","","P")//Necessário para a função Fa050Filho
	EndIf

	f241LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

	// Verifica se data do movimento n„o ‚ menor que data limite de movimentacao no financeiro
	If !DtMovFin(,,"1")
		lRet := .F.
	Endif

	If lRet
		If lCancel240 
			lPergunte := lCancel240
		ElseIf lF241NBor
			cTmpBord := ExecBlock( "F241NBOR", .F., .F. )
			If (lPergunte := ValType("cTmpBord") == "C" .And. !Empty(cTmpBord))
				mv_par01 := cTmpBord
			EndIf		
		Else
			pergunte("AFI240",.F.)
			If lPanelFin
				lPergunte := PergInPanel("AFI240",.T.)
			Else
				lPergunte := pergunte("AFI240",.T.)
			Endif
		EndIf
		//Verifica as perguntas selecionadas
		If !lPergunte
			lRet := .F.
		EndIf
	Endif

	If lRet .and. F241Baixa(cFilial,mv_par01)
		Help(" ",1,"FA241BAIXA",,STR0086,1,1) //"Borderô com baixa (s). Cancele a (s) baixa (s) primeiro para depois cancelar o borderô."
		lRet := .F.
	EndIf

	cFilBord := cFilAnt

	// Verifica se numero do bordero existe.
	If lRet
		dbSelectArea( "SEA" )
		dbSetOrder(2)	//EA_FILIAL+EA_NUMBOR+EA_CART+EA_PREFIXO+EA_NUM+EA_PARCELA+EA_TIPO+EA_FORNECE+EA_LOJA
		If !MsSeek( xFilial("SEA")+mv_par01+"P" )
			cNumBorCan := MV_PAR01
			Pergunte( "F240BR" , .F. )
			If MV_PAR08 == 1 .And. !Empty( xFilial( "SEA" ) )
				cAliasAux := Alias()
				cTabCanc  := GetNextAlias()

				BeginSql Alias cTabCanc
					SELECT SEA.EA_FILIAL
						FROM %Table:SEA% SEA
					WHERE SEA.EA_FILIAL <> %xFilial:SEA%
						AND SEA.EA_FILORIG = %Exp:SE2->E2_FILORIG%
						AND SEA.EA_NUM     = %Exp:SE2->E2_NUM%
						AND SEA.EA_PARCELA = %Exp:SE2->E2_PARCELA%
						AND SEA.EA_TIPO    = %Exp:SE2->E2_TIPO%
						AND SEA.EA_FORNECE = %Exp:SE2->E2_FORNECE%
						AND SEA.EA_LOJA    = %Exp:SE2->E2_LOJA%
						AND SEA.EA_CART    = 'P'
						AND SEA.EA_NUMBOR  = %Exp:cNumBorCan%
						AND SEA.%NotDel%
				EndSql

				If !(cTabCanc)->( Eof() ) .And. SEA->( MsSeek( xFilial("SEA" , (cTabCanc)->EA_FILIAL ) + cNumBorCan + "P" ) )
					cFilBord := (cTabCanc)->EA_FILIAL
				Else
					Help( " " , 1 , "F240NOBORD" )
					lRet := .F.
				EndIf
				If Select( cTabCanc ) > 0
					(cTabCanc)->( dbCloseArea() )
				EndIf
				dbSelectArea( cAliasAux )
			Else
				Help( " " , 1 , "F240NOBORD" )
				lRet := .F.
			EndIf
			Pergunte( "AFI240" , .F. )
			MV_PAR01 := cNumBorCan
		Else
			cFilBord := SEA->EA_FILIAL
		EndIf
	EndIf

	If lRet .And. !lAutomato
		If __lAPICP == NIL
			__lAPICP := FindFunction("F717VldUso") .and. F717VldUso()
		Endif

		If __lAPICP .And. SEA->EA_BORAPI == "S"
			If !MSGYESNO( STR0153 + CRLF + STR0154 + CRLF + STR0155 , STR0156 ) //"Esse borderô foi configurado para registrado online. " # "O cancelamento do borderô através desta rotina não realiza atualização de forma automática no banco, necessária retirada manual. ". # Deseja prosseguir?" # "Registro online de pagamentos"
				lRet := .F.
			Endif
		Endif
	Endif

	If lRet .And.!lCancel240 .And.!F241DtCanc(dDataBase, SEA->EA_NUMBOR, SEA->EA_CART, SEA->EA_FILIAL, @dDtGerBor, @_oBorDtCan, .F.)
			Help(" ",1,"FA241DTCAN",,STR0148 + SEA->EA_NUMBOR + STR0149 + DTOC(dDtGerBor) + STR0150,1,1) //"Não é permitido cancelar o borderô "### " com data anterior à sua geração (" ### ")."
		lRet := .F.
	EndIf

	If lRet .and. lF240Ok
		If !ExecBlock("F240OK",.F.,.F.)
			lRet := .F.
		Endif
	Endif

	//Gestao
	If lRet
		F241PccBx()  // verificar PCC
	Endif

	If lRet
		//Inicializa a gravacao dos lancamentos do SIGAPCO
		PcoIniLan("000023")
		
		BEGIN TRANSACTION
			DbSelectArea("SA2")
			DbSelectArea("SE2")
			DbSelectArea("SEA")
			SEA->(DbSetorder(2))
			
			If( SEA->(DbSeek(FwxFilial("SEA",cFilBord)+mv_par01+"P")) )
				// Efetua verificacao se neste bordero soh existem titulos que
				// nao retiveram retencao. Guardo no array aRecEAE2 os recnos do
				// SEA e SE2 para delecao e gravacao, conforme escolha do usuario.
				While !Eof() .And. FwxFilial("SEA",cFilBord) == SEA->EA_FILIAL .And. SEA->EA_NUMBOR == mv_par01 .And. SEA->EA_CART == "P"
					lNoDeleta	:= .T.

					//Verifica qual a rotina de geração do borderô
					If AllTrim( SEA->EA_ORIGEM ) == "FINA240"
						Help(" ",1,"HELP",,STR0123, 1 , 1 ) //"Borderô gerado por outra rotina, efetuar o cancelamento pela rotina de inclusão"
						SEA->(dbSkip())
						Loop
					EndIf

					cLoja := Iif ( Empty (SEA->EA_LOJA) , "" , SEA->EA_LOJA )
					lAddRetenc := .F.

					// Borderos gerados em versao anterior
					IF Empty(SEA->EA_FILORIG)
						cChave := xFilial("SE2")+SEA->EA_PREFIXO+SEA->EA_NUM+SEA->EA_PARCELA+SEA->EA_TIPO+SEA->EA_FORNECE+cLoja
					Else //Borderos gerados a partir da versao 7.10
						cChave := xFilial("SE2",SEA->EA_FILORIG)+SEA->EA_PREFIXO+SEA->EA_NUM+SEA->EA_PARCELA+SEA->EA_TIPO+SEA->EA_FORNECE+cLoja
					Endif

					aArea := GetArea()
					dbSelectArea("SE2")
					dbSetOrder(1)
					dbSeek(cChave)

					SA2->(dbSetOrder(1))
					SA2->(MSSeek(xFilial("SA2",SE2->E2_FILORIG)+SE2->(E2_FORNECE+E2_LOJA)))

					SED->(dbSetOrder(1))
					SED->(MsSeek(xFilial("SED",SE2->E2_FILORIG)+SE2->E2_NATUREZ))

					// Função que seleciona as baixas a cancelar
					__lPccMR 	:= .F.
					__lIrfMR	:= .F.
					__lIssMR	:= .F.

					//Verifico os impostos que estão configurados pelo Motor
					//Motor de Retencoes
					If __lMotorRet

						aMotRet := F241ImpCnf("1", SE2->E2_FILORIG, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ)
						lImpMotRet := (Len(aMotRet) > 0)
						If !lImpMotRet
							cChaveTit := xFilial("SE2", SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
							lImpMotRet := Len(aImpFis := FinImpFis(cChaveTit, SE2->E2_FILORIG, "SE2", .T., 0, Nil, SE2->E2_FORNECE, SE2->E2_LOJA)) > 0
						EndIF

						If lImpMotRet
							F241VImpMR( aRetencao )
							//Guardo os recnos para posterior delecao do SEA e alteracao do SE2
							aadd(aRecEAE2,{SEA->(Recno()),SE2->(Recno())})
						Endif

					EndIf

					// Verifica se o fornecedor tem a retenção de IRPF gerada no momento da baixa ou bordero de pagamentos e
					// se foi calculada retenção para o título
					lIRPFBaixa := IIF(!__lIrfMR .and. __lLocBra, (SA2->A2_CALCIRF == "2" .and. SED->ED_CALCIRF = "S"),.F.)

					If !lCalcIssBx 
						lCalcIssBx := If (!__lIssMR .and. GetCalcIss(SE2->E2_FILORIG), .T.,.F.)
					EndIf

					lIRTabProg := ( SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG == "1") ) // Define que será usado a tabela progressiva 

					If !__lPccMR
						lCpRet:= SLDRMSG(If(lPCCBaixa,dDatabase,SE2->E2_EMISSAO), SE2->E2_BASEPIS,SE2->E2_NATUREZ,"P",SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_TIPO)

						//Ponto de entrada para não apresentar a mensagem abaixo
						If lF241MPCC
							lCpRet := ExecBlock("F241MPCC",.f.,.f.)
						Endif

						If !lAutomato
							If lCpRet
								If !MSGNoYes(STR0132)//"Essa baixa possui impostos retidos em outra baixa, deseja continuar ?"
									lDisarmTran := .T.
									RollBackDelTran()
								Endif
							Endif
						Endif
					Endif

					// IRRF NA BAIXA
					If !__lIrfMR .and. lIRPFBaixa .And. !((SED->ED_CALCIRF == "S" .And. SED->ED_PERCIRF == 0 .And. nAliqIRRF == 0 .And. !lIRTabProg))

						If ((SE2->E2_IRRF = 0 .And. SE2->E2_PRETIRF == "1") .Or. SE2->E2_VRETIRF > 0)
							aadd(aRetencao,{SE2->(Recno()),SE2->(E2_FORNECE + E2_LOJA),,.T.,{0}} )
							lAddRetenc := .T.
						Else
							aadd(aImpRetOut, SE2->(Recno()) )
						EndIf
						//Guardo os recnos para posterior delecao do SEA e alteracao do SE2
						aadd(aRecEAE2,{SEA->(Recno()),SE2->(Recno())})
					Endif

					SED->(DbSeek(xFilial("SED") + SE2->E2_NATUREZ ))

					//ISS NA BAIXA
					If !__lIssMR .and. lCalcIssBx
						If SE2->E2_VRETISS > 0 .and. !lAddRetenc
							If !Fa241Filho(.T.)
								lNoDeleta	:= .F.
								Help(" ",1,"NODELETA",,STR0090, 4, 0)
								lDelBord:=.F.
							Else
								aadd(aRetencao,{SE2->(Recno()),SE2->(E2_FORNECE + E2_LOJA),,.T.,{0}} )
								lAddRetenc := .T.

								//Guardo os recnos para posterior delecao do SEA e alteracao do SE2
								aadd(aRecEAE2,{SEA->(Recno()),SE2->(Recno())})
							EndIf
						Endif
					Endif

					//PCC NA BAIXA
					If !__lPccMR
						If !Fa590ImpAg()
							If !Fa241Filho(.T.)
								If lNoDeleta
									Help(" ",1,"NODELETA",,STR0090, 4, 0)
									lDelBord := .F.
								EndIf
							Else
								If !Fa241Filho(.F.) .And. __lPCCBaixa .And. (SE2->E2_PRETPIS=='2' .or. SE2->E2_PRETCOF=='2' .or. SE2->E2_PRETCSL=='2')
									aAreaSFQ := IIF(Select("SFQ") > 0, SFQ->(GetArea()), GetArea())
									dbSelectArea("SFQ")
									dbSetOrder(2) //FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
									If dbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA))
										aAreaSEA := SEA->(GetArea())
										SEA->(DbSetOrder(2)) //EA_FILIAL+EA_NUMBOR+EA_CART+EA_PREFIXO+EA_NUM+EA_PARCELA+EA_TIPO+EA_FORNECE+EA_LOJA
										If !SEA->(DbSeek(xFilial("SEA")+MV_PAR01+"P"+SFQ->(FQ_PREFORI + FQ_NUMORI + FQ_PARCORI + FQ_TIPOORI + FQ_CFORI + FQ_LOJAORI)))
											nOpcUsu	:= Aviso( STR0059,;                                //Cancelamento de Bordero
																STR0060 + " ("+AllTrim(MV_PAR01)+") " +; //Alguns titulos deste bordero
																STR0124 +;                                //tiveram retencao dos impostos retidos
																STR0125 + CRLF +;            //em outros titulos.
																STR0065,{"Ok", STR0066})        //Deseja processeguir com o cancelamento do bordero? Ok ### Sair
											If nOpcUsu == 2
												lDelBord := .F.
											EndIf
										Else
											If Len(aAreaSEA) > 0
												RestArea(aAreaSEA)
											EndIf
											aadd(aRecEAE2,{SEA->(Recno()),SE2->(Recno())})
										EndIf
									EndIf
								EndIf

								If ( SE2->E2_SALDO > 0 .Or. (SE2->E2_SALDO == 0 .And.;
									Str(SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL,17,2) == Str(SE2->E2_VALOR,17,2)) )
									lDeleta := .T.

									// Ponto de Entrada F240PCB
									// Para controle de permissÆo da deleção do titulo em bordero.
									If lF240PCB
										lDeleta := ExecBlock("F240PCB",.f.,.f.)
									EndIf

									If lDeleta

										If __lPCCBaixa
											//Guardo os titulos que tiveram impostos da 10925 ou IRPF na Baixa para verificar
											//posteriormente a retencao dos mesmos
											If SE2->(E2_PIS+E2_COFINS+E2_CSLL+E2_ISS+E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0
												If SE2->E2_PRETPIS $ "4#3# " .and. !lAddRetenc
													aadd(aRetencao,{SE2->(Recno()),SE2->(E2_FORNECE + E2_LOJA),,.T.,{0}} )
													lAddRetenc := .T.
												ElseIf SE2->E2_PRETPIS $ "2"
													aadd(aSemRet, {SE2->(Recno()),SE2->(E2_FORNECE + E2_LOJA),.T.} )
													aadd(aImpRetOut, SE2->(Recno()) )
												ElseIf SE2->E2_PRETPIS $ "1"
													aadd(aImpRetOut, SE2->(Recno()) )
												Endif
											Endif
										Endif
									Endif

									//Guardo os recnos para posterior delecao do SEA e alteracao do SE2
									aadd(aRecEAE2,{SEA->(Recno()),SE2->(Recno())})

								Endif
							Endif
						Else
							lDisarmTran := .T.
							RollBackDelTran()
						Endif
					Endif
					RestArea(aArea)

					SEA->(DbSkip())
				Enddo
			EndIf

			If Len(aRetencao) == 0
				lRetencao := .T.
			Else
				For nX:= 1 To Len(aSemRet)
					For nY:= 1 To Len(aRetencao)
						If !aSemRet[nX][2] == aRetencao[nY][2]
							lRetencao := .T.
						Else
							aSemRet[nX][3] := .F.
						Endif
					Next
				Next
			Endif
			
			//Caso nao seja o bordero em que ocorreu a retencao, executa processo de alerta.
			//Isso ocorrera somente se o Array aRetencao estiver vazio (no bordero nao houve retencao).
			If lRetencao .And. Len(aSemRet) > 0
				nOpcUsu	:= Aviso( STR0059,;                                //Cancelamento de Bordero
				STR0060 + " ("+AllTrim(MV_PAR01)+") " +; //Alguns titulos deste bordero
				STR0061 +;                                //tiveram retencao dos impostos da Lei 10925
				STR0062 +;                                //retidos em outros borderos. Execute
				STR0063 +;                                //a impressao do relatorio para Localizar onde esta
				STR0064 + Chr(13) + Chr(10) +;           //ocorrendo a retencao.
				STR0065,{"Ok", STR0066, STR0067})        //Deseja processeguir com o cancelamento do bordero? ### Sair ### Imprimir
				//Conforme selecao do usuário, efetua a impressão do relatorio, sai da rotina sem
				//excluir o bordero, ou consuma a delecao.
				If nOpcUsu == 2
					lDelBord := .F.
				ElseIf nOpcUsu == 3
					//Caso o usuario faca a opcao por imprimir os titulos, dentro da funcao
					//que executa a impressao, chamo novamente a tela de alerta para que o
					//usuario possa a partir daquele ponto decidir de deseja ou nao confirmar a exclusao.
					Fa241Rel(aSemRet,MV_PAR01)
					lDelBord := MsgYesNo(STR0068,STR0069) //Deseja prosseguir com o cancelamento do bordero? ### "Cancelamento de Bordero"
				Endif

				//Ponto de entrada que possibilita nao permitir o cancelamento do bordero com impostos retidos
				//em outro bordero ainda que o usuario confirme este cancelamento
				If lDelBord .and. lF241CBD
					lDelBord := ExecBlock("F241CBD",.f.,.f.)
				Endif

			Endif
			
			//Cancelamento dos impostos gerados pelo bordero
			If (__lPCCBaixa .Or. lContIRPF .or. lCalcIssBx .or. lImpMotRet ) .And. lDelBord

				If Len(aRetencao) > 0

					dbSelectArea("SE2")
					nTotal := 0
					nHdlPrv := 0
					lContabil := .T.
					//Verifico se a database e anterior a da geração do bordero
					//Caso seja, troco a database para a data do bordero para evitar que
					//data de contabilizacao do cancelamento venha antes da contabilização da emissao
					dDataBase := If(dDataBord > dDataBase, dDataBord, dDataBase)
					If lF241CTB
						lContabil := ExecBlock("F241CTB",.F.,.F.)
					EndIf
					For nX := 1 to Len(aRetencao)

						SE2->(dbGoto(aRetencao[nX][1]))

						// Cancelamento do bordero de imposto quando existir titulos de varias filiais
						If !Empty( cFilFwSE2 ) .and. cFilAnt<>SE2->E2_FILIAL

							If !Empty(nHdlPrv) .and. lContabil .and. (nTotal > 0)
								SE2->(dbGoto(aRetencao[nX-1][1]))
								cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, (mv_par07 == 1) /*lDigita*/, .F. /*lAglut*/, /*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, /*aDiario*/ )
								aFlagCTB := {}
								nTotal := 0
								SE2->(dbGoto(aRetencao[nX][1]))
							EndIf

							cFilAnt := SE2->E2_FILORIG
							cFilCTB := SE2->E2_FILORIG

						EndIf

						SA2->(dbSetOrder(1))
						SA2->(MSSeek(xFilial("SA2",SE2->E2_FILORIG)+SE2->(E2_FORNECE+E2_LOJA)))

						SED->(dbSetOrder(1))
						SED->(MsSeek(xFilial("SED",SE2->E2_FILORIG)+SE2->E2_NATUREZ))

						// Verifica se o fornecedor tem a retenção de IRPF gerada no momento da baixa ou bordero de pagamentos e
						// se foi calculada retenção para o título
						lIRPFBaixa := IIF(!__lIrfMR .and. __lLocBra, (SA2->A2_CALCIRF == "2" .and. SED->ED_CALCIRF = "S"),.F.)
						If !__lIssMR .And. cFilOriAnt <> SE2->E2_FILORIG
							lCalcIssBx := GetCalcIss(SE2->E2_FILORIG)
							cFilOriAnt := SE2->E2_FILORIG
						EndIf					

					//Cancelamento impostos
						If lIRPFBaixa //Exclui titulos IR gerados no bordero
							If Len(aRetencao[nX]) > 3 
								F241ExIRPF(@nTotal,@nHdlPrv,@cArquivo,lContabil,lUsaFlag,@aFlagCTB,mv_par01)
								If Len(aImpRetOut) == 0
									cChaveSE2 := xFilial("SE2",SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
									cIdFK7 	  := FINBUSCAFK7( cChaveSE2, "SE2" )
									FINGFK3BOR(3,"FK7",cIdFK7,aImpPCC)
								EndIf
							EndIf

						EndIf

						If !__lIssMR .and. lCalcIssBx
							//Exclui títulos ISS gerados no bordero
							F241DelIS(aRetencao[nX][1],SE2->E2_ISS,@nTotal,@nHdlPrv,@cArquivo,lContabil,lUsaFlag,@aFlagCTB)
						EndIf

						//Exclui titulos PCC gerados no bordero
						If !__lPCCMR .and. __lPCCBaixa
							F241CanImp(@nTotal,@nHdlPrv,@cArquivo,lContabil,lUsaFlag,@aFlagCTB)
						Endif

						If lImpMotRet
							aImpBx2Can := aRetencao[nX,5]
							F241CanIMR(@nTotal,@nHdlPrv,@cArquivo,lContabil,lUsaFlag,@aFlagCTB,MV_PAR01,aImpBx2Can)
						Endif

						// Restaura Filial do título atual
						cFilAnt := cFilCTB

					Next

					If lContabil .and. nTotal > 0
						cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, (mv_par07 == 1) /*lDigita*/, .F. /*lAglut*/, /*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, /*aDiario*/)
						aFlagCTB := {}
					EndIf

					// Ajuste para geração dos impostos na filial de origem do titulo.
					cFilAnt	:= cFilBak

					//Recalculo PCC no cancelamento do bordero
					If lRecalcPCC .and. Len(aFornecPcc) > 0
						//1 - Mês do periodo de verificacao
						//2 - Ano do periodo de verificacao
						//3 - Fornecedor De
						//4 - Fornecedor Até
						//5 - Mostra tela Contabilizacao (NAO, para este caso)
						SaveInter()

						For nCount := 1 to Len(aFornecPcc)
							aPar379 := {}
							aPar379 := {Month(dDatabase),Year(dDatabase),aFornecPcc[nCount],aFornecPcc[nCount],2}
							Fina379()
						Next

						RestInter()
						Pergunte("FIN080",.F.)
					Endif
				Endif
				//Reestruturacao SE5
				//Elimina os registros de calculo de imposto gerados pelo titulo em borderô
				If Len(aImpRetOut) > 0
					For nX := 1 to Len(aImpRetOut)
						SE2->(dbGoTo(aImpRetOut[nX]))
						
						//Deleto os registros FK3 de impostos retidos em outros titulos Dados da tabela auxiliar com o código do título a pagar
						cChaveTit := xFilial("SE2",SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
						cIdDoc    := FINGRVFK7( "SE2", cChaveTit )
						cIdDoc    := FINBUSCAFK7( cChaveTit, "SE2" )
						
						FINGFK3BOR(3,"FK7",cIdDoc,aImpPCC)
					Next
				Endif
				//restauro a database
				dDataBase := dDataAtu
			Endif

			If lDelBord
				nIndiceSE2 := SE2->(IndexOrd())
				aLstTipos  := Strtokarr(MVABATIM, "|")
				aFornecPcc := {}
				SA2->(DbSetOrder(1))
				SE2->(DbSetOrder(17))
				
				//Executa a delecao dos registros do SE2 e SEA que fazem parte do array que foram adicionados no processo acima.
				For nX := 1 To Len(aRecEAE2)
					SEA->(DbGoto(aRecEAE2[nX][1]))
					RecLock("SEA")
					SEA->(DbDelete())
					SEA->(MsUnlock())
					
					SE2->(DbGoto(aRecEAE2[nX][2]))
					SA2->(MsSeek(FwxFilial("SA2", SE2->E2_FILORIG) + SE2->(E2_FORNECE+E2_LOJA)))
					cOldPortado := SE2->E2_PORTADO
					lTemAbati   := SE2->(DbSeek(SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
					SE2->(DbGoto(aRecEAE2[nX][2]))	

					If lbuscUltBx
						cChaveSE2 	 := xFilial("SE2",SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
						cIdFK7 	 	 := FINBUSCAFK7( cChaveSE2, "SE2" )		
						dTemBaixa	 := buscaUltBx(cIdFK7, @oBuscaBx)		
					EndIf
					
					If lTemAbati
						If oAbatiment == Nil
							cUpdate := "UPDATE ? SET E2_NUMBOR = ?, E2_PORTADO = ? "
							
							If __lLocBra
								cUpdate += ", E2_DTBORDE = ? "
							EndIf
							
							cUpdate += "WHERE E2_FILIAL = ? "
							cUpdate += "AND E2_PREFIXO  = ? "
							cUpdate += "AND E2_NUM = ? "
							cUpdate += "AND E2_PARCELA = ? "
							cUpdate += "AND E2_TIPO IN (?) "
							cUpdate += "AND E2_FORNECE = ? "
							cUpdate += "AND E2_LOJA = ? "
							cUpdate += "AND D_E_L_E_T_ = ' ' "
							oAbatiment := FWPreparedStatement():New(cUpdate)
						EndIf
						
						oAbatiment:SetNumeric(1, RetSqlName("SE2"))
						oAbatiment:SetString(2, cE2NUMBOR)
						oAbatiment:SetString(3, cE2PORTADO)						
						
						If __lLocBra
							oAbatiment:SetString(4, " ")						
						EndIf
						
						oAbatiment:SetString(IIf(__lLocBra, 5, 4),   SE2->E2_FILIAL)
						oAbatiment:SetString(IIf(__lLocBra, 6, 5),   SE2->E2_PREFIXO)
						oAbatiment:SetString(IIf(__lLocBra, 7, 6),   SE2->E2_NUM)
						oAbatiment:SetString(IIf(__lLocBra, 8, 7),   SE2->E2_PARCELA)
						oAbatiment:SetIn(IIf(__lLocBra, 9, 8),       aLstTipos)
						oAbatiment:SetString(IIf(__lLocBra, 10, 9),  SE2->E2_FORNECE)
						oAbatiment:SetString(IIf(__lLocBra, 11, 10), SE2->E2_LOJA)
						cUpdate := oAbatiment:GetFixQuery()
						
						If (nErro := TCSqlExec(cUpdate)) != 0
							Help(Nil, Nil, "F241CANBOR", Nil, STR0157 + ": " + SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA), 1, 0, Nil, Nil, Nil, Nil, Nil, {})
							DisarmTransaction()
							Break
						EndIf
					EndIf

					// Verifica se o titulo esta envolvido em uma compensação de compras, caso esteja, o campo de data de baixa
					// E2_BAIXA não poderá ser deixado em branco
					If AllTrim(SE2->E2_ORIGEM) $ "MATA100|MATA103"
						FR3->(DbSetOrder(3))
						If FR3->(DbSeek(xFilial("SE2") + 'P' + SE2->E2_FORNECE + SE2->E2_LOJA + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCELA+SE2->E2_TIPO))
							lTemAdt := .T.
						EndIf
					EndIf
					
					RecLock("SE2")
					SE2->E2_NUMBOR  := cE2NUMBOR
					SE2->E2_PORTADO := cE2PORTADO
					
					If !lTemAdt .And. (AllTrim(SE2->E2_ORIGEM) $ "MATA100|MATA103" .Or. Empty(dTemBaixa))
						SE2->E2_BAIXA   := dE2BAIXA
					EndIf
					
					If __lLocBra
						dDataBord       := SE2->E2_DTBORDE
						SE2->E2_DTBORDE := dE2BAIXA
					Endif										
					
					SE2->(MsUnlock())
					
					AAdd(aFornecPcc, SE2->E2_FORNECE)					
					FKCOMMIT()
					
					If lF240Can
						ExecBlock("F240CAN",.f.,.f.,{cOldPortado})
					EndIf
				Next
				
				If oBuscaBx <> Nil
					FreeObj(oBuscaBx)
				EndIf

				SE2->(DbSetOrder(nIndiceSE2))
				FwFreeArray(aLstTipos)			
			Endif
		END TRANSACTION
		
		If !lDisarmTran
			//Finaliza a gravacao dos lancamentos do SIGAPCO
			PcoFinLan("000023")
		EndIf
	Endif

	If __oPreparB != NIL
		__oPreparB:Destroy()
		__oPreparB := NIL
	Endif

	If _oBorDtCan <> Nil
		_oBorDtCan:Destroy()
		_oBorDtCan:= Nil
	EndIf

	If __lMotorRet .and. FindFunction("FRTDelObj")
		FRTDelObj(2)
	Endif

	RestArea(aAreaSE2)

	dbSelectArea("SE2")
	
	If nSavRec > 0
		dbGoTo( nSavRec )
	Endif
Return


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241Impost
Verifica o total de notas do Fornecedor que vencem no mesmo mes.

@author Mauricio Pequim Jr

@since 28/01/05
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241Impost(lBaseSE2,cModTot,cModRetPis,cNccRet,nVlMinImp,nTotal,nHdlPrv,cArquivo,lContabil,nValTot,aChaveTit,aFlagCtb,lIsLast,nRetMotor,lPCCMR,lIrfMR,aRetIRRF)
Local aAreaSE2  := SE2->( GetArea() )
Local dDataIni  := FirstDay( dDataBase )
Local dDataFim  := LastDay( dDataBase )
Local nValorPg 	:= 0
Local nProp 	:= 1
Local nVlrTit 	:= 0
Local nVlTitSE2 := 0
Local nSavRec 	:= SE2->(RECNO())
Local aDadosRet := Array(5) //Titulos baixados e valores pendentes SE5
Local aTitsSE5  := Array(5)
Local cSequencia:= ""
Local nDiferImp := 0
Local aRecnosSE5:= {}
Local cPrefOri  := SE2->E2_PREFIXO
Local cNumOri   := SE2->E2_NUM
Local cParcOri  := SE2->E2_PARCELA
Local cTipoOri  := SE2->E2_TIPO
Local cCfOri    := SE2->E2_FORNECE
Local cLojaOri  := SE2->E2_LOJA
Local nOldPis 	:= 0
Local nOldCof 	:= 0
Local nOldCsl 	:= 0
Local nLoop   	:= 0
Local nIrrf 	:= 0
Local nIss		:= 0
Local nOldIrf 	:= 0
Local cQuery    := ""
Local lAplVlMin := .T.
Local lCpoVlMin := .T.
Local lTodasFil := ExistBlock("MT103FRT")
Local lConFil	:= SuperGetMV("MV_CONSFIL",.F.,.F.)
Local aFil10925 := {}
Local cFilAtu	:= cFilAnt
Local aArea		:= GetArea()
Local aRecnosSE2:= {}
Local nKco 		:= 1
Local lF241Inc 	:= ExistBlock("F241INC")
Local aDadosImp := Array(6)
Local lF241Inc2 := ExistBlock("F241INC2")
Local lF241Inc5 := ExistBlock("F241INC5")
Local aFor10925	:= {}
Local lVerForLj	:= ExistBlock("F080LOJA")
Local lF241IMP 	:= ExistBlock("F241IMP")
Local lF241Ord	:= ExistBlock("F241Ord")
Local aRetOrd	:= {}
Local aTitBsImp := {}
Local lGravou 	:= .F.
Local nBaseImp 	:= 0
Local nValOutImp:= 0
Local nValTit 	:= 0
Local nTotAbat 	:= 0
Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lCalcIssBx:= GetCalcIss(cFilAnt)
Local lIRPFBaixa :=	IIf(__lLocBra,Posicione("SA2",1,xfilial("SA2") + SE2->(E2_FORNECE+E2_LOJA),"A2_CALCIRF") == "2",.F.) .And. ;//SE2->E2_IRRF == 0 .and. ;
		          			IIf( cPaisLoc != "TRI", Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S",.F.)

//Considero juros multa ou desconto na base do imposto.
// 1 = Considera valores juros multa ou desconto
// 2 = Nao considera valores juros multa ou desconto
Local lJurMulDes := (SuperGetMv("MV_IMPBAIX",.t.,"1") == "1")
Local nTotTitSE2 := 0
Local nBasRetTmp := 0
Local nTotPisSE2 := 0
Local nTotCofSE2 := 0
Local nTotCslSE2 := 0
Local nTotIrfSE2 := 0
Local nCalcPis   := 0
Local nCalcCof   := 0
Local nCalcCsl   := 0
Local nCalcIrf   := 0
Local nRestPis   := 0
Local nRestCof   := 0
Local nRestCsl   := 0
Local nRestIrf   := 0
Local nX 		 := 0
Local nY 		 := 0
Local nTamTit	 := TamSX3("E5_PREFIXO")[1]+TamSX3("E5_NUMERO")[1]+TamSX3("E5_PARCELA")[1]+TamSX3("E5_TIPO")[1]
Local nTamTit2   := TamSX3("E5_PREFIXO")[1]+TamSX3("E5_NUMERO")[1]+TamSX3("E5_PARCELA")[1]+1
Local lAltBxVal  := .F.
Local lAchouPa   := .F.
Local nBaseRet   := 0
Local lImpInFat  := .F.
Local lBordAtu   := .F.
Local nPaBruto   := 0
//Indica se o PA terá o valor dos impostos descontados do seu valor
Local lPaBruto	 := GetNewPar("MV_PABRUTO","2") == "1"
Local cChaveTit	 := " "
Local nImpRetEmi := 0
Local lVerSfq 	 := .F.
Local nTamForn   :=  If(__lLocBra, TAMSX3("E2_FORNPAI")[1],0)
Local lUsaFlag	 := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local nFound 	 := 0
Local nSaldoTit  := 0
Local lValLiq	 := SuperGetMv("MV_BP10925",.T.,"1") == "2" //1- Valor bruto da baixa parcial / 2- Valor da baixa parcial menos os impostos
Local lTeveBxParc:= .F.
//Chamado SDFPWW
Local cAglutPCC := SuperGetMV("MV_PCCAGFR",,"1")
Local cAglutFil := SuperGetMV("MV_PCCAGFL",,"1")
Local aAreaSM0  := {}
Local aAreaSA2  := {}
Local cCGCSM0   := ""
Local cCGCFor   := ""
Local cForTipo  := ""
Local cEmpAtu   := ""
Local lLojaAtu	:= ( GetNewPar( "MV_LJ10925", "1" ) == "1" )
Local lForcaDesc := .F.

//--- Tratamento Gestao Corporativa
Local lGestao   := FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
Local cFilFwSE2 := IIF( lGestao, FwFilial("SE2") , xFilial("SE2") )
Local cFil2		:= ""
Local aStruct   := {}
Local aCampos   := {}
Local cAliasQry := ""
Local cSepNeg   := If("|"$MV_CPNEG,"|",",")
Local cSepProv  := If("|"$MVPROVIS,"|",",")
Local cSepRec   := If("|"$MVPAGANT,"|",",")
Local cSepTxa   := If("|"$MVTXA,"|",",")
Local cSepTx	:= If("|"$MVTAXA,"|",",")

//Reestruturacao SE5
Local oModelMov	:= NIL //Model de Baixas a Pagar
Local oSubFKA	:= Nil	//RELACIONAMENTO
Local oSubFK2	:= Nil //BAIXAS A PAGAR
Local cCamposE5	:= ""
Local cDocKey	:= ""
Local aImpostos	:= {}
Local cIdFK2	:= ""
Local cIdFK3	:= ""
Local cIdFK4	:= ""
Local cOrigem	:= FunName()
Local nRecSE5	:= 0
Local nRecFK2	:= 0
Local nSalTit	:= 0
Local aPcc		:= Array(4)
Local lGeraImp	:= .T.
Local lF241QRY2	:= ExistBlock("F241QRY2")
Local lF241Cmp2	:= ExistBlock("F241CMP2")
Local lF241aRec	:= ExistBlock("F241aRec")
Local lF241Rec1 := ExistBlock("F241Rec1")
Local lF241QRY3	:= ExistBlock("F241QRY3")
Local aAreaE2	:= {}
Local cFilBkp	:= ""
Local lRestaUM 	:= .T.
Local lResta1 	:= ExistBlock("RESTAUM")
Local cDbMs		:= UPPER(TcGetDb())
Local cCli		:= ""
Local lverVrAR	:= .T.
Local nVlInss	:= 0
Local nVlIss	:= 0
Local nVlIrf	:= 0
Local aPubRet	:= Array(6)
Local lAtMinP	:= .F.
Local nVlrCmpCrt := 0
Local lCC10925	:= SuperGetMV( "MV_CC10925" , .F. , 1 ) == 1
Local nPosArray	:= 0
Local lRet		:= .T.
Local nImpMotor := 0
Local cGeraDirf := "2"
Local aTitCalc	:= {}
Local aCodRet	:= {}
Local cNatPis	:= SuperGetMV("MV_PISNAT")
Local cNatCof	:= SuperGetMV("MV_COFINS")
Local cNatCsll	:= SuperGetMV("MV_CSLL")
Local lF590Impost := FwIsInCallStack("F590Impost")
Local lRetMinIR As Logical
Local nMinIrrf  As Numeric
Local nPosIrrf  As Numeric

Private lBxParc		:= .F.
Private lJaReteve	:= .F.
Private dBaixa		:= dDataBase
Private nPis		:= 0
Private nCofins		:= 0
Private nCsll		:= 0
Private lEmpPub		:= IsEmpPub()
Private nVlMPub		:= SuperGetMv("MV_VLMPUB" ,.T.,10)
Private lAplMinP	:= .F.
Private cVencPub	:= SuperGetMV("MV_VENPUB", .F., "M")
PRIVATE nPisBaseR 	:= 0
PRIVATE nCofBaseR	:= 0
PRIVATE nCslBaseR 	:= 0
PRIVATE nPisBaseC 	:= 0
PRIVATE nCofBaseC 	:= 0
PRIVATE nCslBaseC 	:= 0
PRIVATE nPisCalc	:= 0
PRIVATE nCofCalc	:= 0
PRIVATE nCslCalc	:= 0

DEFAULT lContabil	:= .T.
DEFAULT nValTot 	:= 0
DEFAULT aChaveTit 	:= {}
DEFAULT aFlagCTB 	:= {}
DEFAULT lIsLast		:= .T.
DEFAULT nRetMotor	:= 0
Default lPCCMR 		:= __lPCCMR
Default lIrfMR 		:= __lIrfMR
Default nHdlPrv     := 0
Default aRetIRRF    := {}

//Carrego as perguntas para nao gerar problemas quando a funcao
//eh carregada pela rotina de manutencao de bordero
Pergunte("F240BR",.F.)
F241PccBx()

Afill(aPubRet,0)

// Zerar ABATIMENTO para contabilizacao.
ABATIMENTO := 0

If Type("nVlSE2") == "U"
	nVlSE2		:=  0 // usado para verificar se houve
EndIf

//Motor Retenção
__lMotorRet := If(FindFunction("FTemMotor"), FTemMotor(), .F.)

If __lFKCodRet == nil 
	__lFKCodRet:= (__lLocBra .and. FK3->(FieldPos("FK3_CODRET")) > 0 .and. FK4->(FieldPos("FK4_CODRET")) > 0)
EndIf

//Motor de retenções
If lPCCMR .and. lIrfMR
	Return .T.
EndIf

lPccBaixa  := If(lPCCMR, .F., lPccBaixa)
lIRPFBaixa := If(lIrfMR, .F., lIRPFBaixa)
lRetMinIR  := .F.
nMinIrrf   := SuperGetMv("MV_VLRETIR",.t.,10)

If lVerForLj .And. cAglutPCC $ "2|3"
	Help( ,, 'HELP',, STR0088 , 1, 0) //'Parâmetro MV_PCCAGFR deve ser "1=Não Aglutina" para utilizar o ponto de entrada "F080LOJA"'
	Return .T.
EndIf

If lTodasFil .And. cAglutFil $ "2|3"
	Help( ,, 'HELP',, STR0089 , 1, 0) //'Parâmetro MV_PCCAGFL deve ser "1=Não Aglutina" para utilizar o ponto de entrada "MT103FRT"'
	Return .T.
EndIf

//Titulo ja teve retencao na emissao
If !(SE2->E2_PRETPIS $ "1#3#7") .OR. !(SE2->E2_PRETCOF $ "1#3#7") .OR. !(SE2->E2_PRETCSL $ "1#3#7")
	If !lIsLast .Or. Len(aContab) == 0
		Return .T.
	EndIf
	
	lGeraImp := .F.
Endif

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If lCpoVlMin .And. SE2->E2_APLVLMN == "2"
	lAplVlMin := .F.
Endif

SA2->(dbSetOrder(1))
SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))

AFill( aDadosRet, 0 )
AFill( aDadosImp, 0 )
nValComp := 0

aFil10925 := {}
aAreaSA2  := SA2->(GetArea())

aAreaSM0 := SM0->(GetArea())
If !Empty(cCGCFor := SA2->A2_CGC)
	cForTipo := SA2->A2_TIPO
	SA2->(DbSetOrder(3))
	cEmpAtu  := SM0->M0_CODIGO
	cCGCSM0  := SM0->M0_CGC
	SM0->(DbSetOrder(1))
	SM0->(MsSeek(cEmpAnt))
Else
	aFil10925 := { cFilAnt }
EndIf

If FUNNAME() == "FINA590"
	dVenIni240 := dDataIni
	dVenFim240 := dDataFim
EndIf

If lEmpPub .And. lIRPFBaixa .And. lPCCBaixa
	If cVencPub == "D"
		dDataIni := dDataFim := dBaixa
	ElseIf cVencPub == "M"
		dDataIni := FirstDay(dBaixa)
		dDataFim := LastDay(dBaixa)
	EndIF
EndIF

//Se parametro "MV_PCCAGFR" existe com conteudo diferente de 1
If cAglutFil $ "2|3"
	While !SM0->(Eof()) .And. SM0->M0_CODIGO == cEmpAtu
		//Verifica se a filial tem o mesmo CGC/Raiz de CGC
		If (cAglutFil == "2" .And. cCGCSM0 == SM0->M0_CGC) .Or. (cAglutFil == "3" .And. Left(cCGCSM0,8) == Left(SM0->M0_CGC,8))
			//Verifica se na filial existe cliente de mesmo CGC/Raiz de CGC
			If (cAglutPCC != "2" .And. cAglutPCC != "3") .Or. (SA2->(MsSeek(xFilial("SA2",FWGETCODFILIAL)+Left(cCGCFor,Iif(cForTipo != "F" .And. cAglutPCC == "3",8,14)))) .And. cForTipo == SA2->A2_TIPO)
				AAdd(aFil10925, FWGETCODFILIAL)
			EndIf
		EndIf
		SM0->(DbSkip())
	EndDo
ElseIf lTodasFil
	aFil10925 := ExecBlock( "MT103FRT", .F., .F. )
Else
	If FunName() == "FINA590"
		cFil2 := SE2->E2_FILORIG
		aFil10925 :=  { cFil2 }
	Else
	     If !Empty (FwFilial("SE2")) .And. lConfil
	        aFil10925 := FAFIL10925()
	     Else
	        aFil10925 := { cFilAnt }
	     Endif
	EndIf
Endif

SM0->(RestArea(aAreaSM0))
SA2->(RestArea(aAreaSA2))

//Retorna array com os codigos de cliente/loja para verificacao da retencao (Raiz do CGC)
If lVerForLj .And. cAglutPCC != "2" .And. cAglutPCC != "3"
	aFor10925 := ExecBlock("F080LOJA",.F.,.F.)
Endif

//Se Aplica Valor Minimo
If lAplVlMin .And. (dDatabase < dLastPCC .OR. lEmpPub) .And. lGeraImp

	//Verifico retencoes no mes (titulos baixados)
	For nKco := 1 to Len(aFil10925)

		cFilAnt := aFil10925[nKco]

		If !Empty(cCGCFor) .And. (cAglutPCC == "2" .Or. cAglutPCC == "3")
			aAreaSA2 := SA2->(GetArea())
			SA2->(DbSetOrder(3))
			SA2->(MsSeek(xFilial("SA2")+Left(cCGCFor,8)))
			aFor10925 := {}
			While !SA2->(Eof()) .And. xFilial("SA2")+Left(cCGCFor,8) == SA2->A2_FILIAL+Left(SA2->A2_CGC,8)
				//Mesmo tipo de fornecedor e Novo no vetor
				If cForTipo == SA2->A2_TIPO .And. AScan(aFor10925,{|x| x[1]+x[2] == SA2->(A2_COD+A2_LOJA) }) == 0
					//Nao pode ser pessoa fisica e aglutina por Raiz de CNPJ
					If cForTipo != "F" .And. cAglutPCC == "3" .And. Left(SA2->A2_CGC,8) == Left(cCGCFor,8)
						SA2->(AAdd(aFor10925,{A2_COD,A2_LOJA}))
					//Pessoa Fisica ou aglutina por CPF/CNPJ identico
					ElseIf (cForTipo != "F" .Or. cAglutPCC == "2") .And. SA2->A2_CGC == cCGCFor
						SA2->(AAdd(aFor10925,{A2_COD,A2_LOJA}))
					EndIf
				EndIf
				SA2->(DbSkip())
			EndDo
			SA2->(RestArea(aAreaSA2))
		EndIf

		aCampos := { "E5_VALOR","E5_VRETPIS","E5_VRETCOF","E5_VRETCSLL","E5_VLJUROS","E5_VLMULTA","E5_VLDESCO"}

		aStruct := SE5->( dbStruct() )

		SE5->( dbCommit() )

		cAliasQry := GetNextAlias()

		cQuery := "SELECT E5_PREFIXO,E5_NUMERO,E5_PARCELA,E5_TIPO,E5_CLIFOR,E5_LOJA,"
		cQuery += "E5_SEQ,E5_VALOR,E5_VRETPIS,E5_VRETCOF,E5_VRETCSL,E5_DATA,E5_VLJUROS,"
		cQuery += "E5_VLMULTA,E5_VLDESCO,E5_PRETPIS,E5_PRETCOF,E5_PRETCSL,E5_MOTBX,"
		cQuery += "E5_DOCUMEN,E5_FORNADT,E5_LOJAADT,E5_VRETIRF,E5_VRETISS,"

		cQuery += "R_E_C_N_O_ RECNO FROM "
		cQuery += RetSqlName( "SE5" ) + " SE5 "
		cQuery += "WHERE "
		cQuery += "E5_FILIAL='"    + xFilial("SE5")       + "' AND "

		If Len(aFor10925) > 0  //Verificar determinados fornecedores (raiz do CNPJ)
			cQuery += "( "
			For nLoop := 1 to Len(aFor10925)
				cQuery += "(E5_CLIFOR ='"   + aFor10925[nLoop,1]  + "' AND "
				cQuery += "E5_LOJA='"       + aFor10925[nLoop,2]  + "') OR "
			Next
			//Retiro o ultimo OR
			cQuery := Left( cQuery, Len( cQuery ) - 4 )
			cQuery += ") AND "
		Else  //Apenas Fornecedor e Loja atuais
			cQuery += "E5_CLIFOR='"		+ SE2->E2_FORNECE			+ "' AND "

			If lLojaAtu  //Considero apenas a loja atual
				cQuery += "E5_LOJA='"		+ SE2->E2_LOJA	+ "' AND "
			EndIf
			cQuery += "E5_PRETPIS <> '5' AND "
		Endif

	   	If Empty(dDtMinPCC) .OR. DToS( dDataIni ) < DToS( dDtMinPCC )// para casos de baixa parcial do titulo nos meses anteriores, sistema nao as considerava na query.
			cQuery += "E5_DATA>= '"		+ DToS( dDataIni )      + "' AND "
	 	Else
			cQuery += "E5_DATA>= '"		+ DToS( dDtMinPCC )      + "' AND "
	 	Endif

		cQuery += "E5_DATA<= '"		+ DToS( dDataFim )      + "' AND "
		cQuery += "E5_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "
		cQuery += "E5_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)  + " AND "
		cQuery += "E5_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
		cQuery += "E5_RECPAG = 'P' AND "
		cQuery += "E5_MOTBX <> 'FAT' AND "
		cQuery += "E5_SITUACA <> 'C' AND "

		//Apenas titulos que tem retencao de PIS,Cofins e CSLL
		If cModTot == "2"
			cQuery += " ((E5_VRETPIS > 0 OR E5_VRETCOF > 0 OR E5_VRETCSL > 0) OR (E5_MOTBX = 'CMP')) AND "
		Endif

		cQuery += "D_E_L_E_T_=' '"
		cQuery += "AND NOT EXISTS ( "
		cQuery += "SELECT A.E5_NUMERO "
		cQuery += "FROM "+RetSqlName("SE5")+" A "
		cQuery += "WHERE A.E5_FILIAL='"+xFilial("SE5")+"' AND "
		cQuery +=		"A.E5_PREFIXO=SE5.E5_PREFIXO AND "
		cQuery +=		"A.E5_NUMERO=SE5.E5_NUMERO AND "
		cQuery +=		"A.E5_PARCELA=SE5.E5_PARCELA AND "
		cQuery +=		"A.E5_TIPO=SE5.E5_TIPO AND "
		cQuery +=		"A.E5_CLIFOR=SE5.E5_CLIFOR AND "
		cQuery +=		"A.E5_LOJA=SE5.E5_LOJA AND "
		cQuery +=		"A.E5_SEQ=SE5.E5_SEQ AND "
		cQuery +=		"A.E5_TIPODOC='ES' AND "
		cQuery +=		"A.E5_RECPAG<>'P' AND "
		cQuery +=		"A.D_E_L_E_T_=' ')"

		If !lEmpPub
				cQuery +=	" AND ( CASE WHEN E5_MOTBX = 'CMP' AND E5_TIPO = '"+MVPAGANT+"' THEN  "
				cQuery +=	" 				(SELECT COUNT(*) AS REG "
				cQuery +=	" 					FROM "+RetSqlName("SE2")+" MES "
				cQuery +=	" 					WHERE MES.E2_FILIAL = SE5.E5_FILIAL AND MES.E2_PREFIXO = E5_PREFIXO "
				cQuery +=	" 						AND MES.E2_NUM=SE5.E5_NUMERO AND MES.E2_PARCELA=SE5.E5_PARCELA "
				cQuery +=	" 						AND MES.E2_TIPO=SE5.E5_TIPO AND MES.E2_FORNECE=SE5.E5_CLIFOR "
				cQuery +=	" 						AND MES.E2_LOJA=SE5.E5_LOJA AND MES.D_E_L_E_T_ = ' ' "
				cQuery +=	" 						AND MES.E2_TIPO = '"+MVPAGANT+"' "

				If cDbMs == "ORACLE"
					cQuery +=	" 						AND TO_CHAR(E5_DATA,'MM') = TO_CHAR(MES.E2_EMISSAO,'MM') "
					cQuery +=	" 						AND TO_CHAR(E5_DATA,'YYYY') = TO_CHAR(MES.E2_EMISSAO,'YYYY') "
				ElseIf cDbMs == "POSTGRES"
					cQuery +=	" 						AND SUBSTRING(E5_DATA,1,6) = SUBSTRING(MES.E2_EMISSAO,1,6) "
				Else
					cQuery +=	" 						AND MONTH(E5_DATA) = MONTH(MES.E2_EMISSAO) "
					cQuery +=	" 						AND YEAR(E5_DATA) = YEAR(MES.E2_EMISSAO)  "
				EndIf
				cQuery +=	"							 )"
				cQuery +=	" 				WHEN E5_MOTBX = 'CMP' AND E5_TIPO <> '"+MVPAGANT+"' THEN "
				cQuery +=	" 				 (SELECT COUNT(*) AS REG "
				cQuery +=	" 					FROM "+RetSqlName("SE2")+" MES "
				cQuery +=	" 					WHERE MES.E2_FILIAL = SE5.E5_FILIAL "
				cQuery +=	" 						AND MES.D_E_L_E_T_ = ' ' AND "
				cQuery +=	" 						(MES.E2_PREFIXO||MES.E2_NUM||MES.E2_PARCELA||MES.E2_TIPO||MES.E2_FORNECE||MES.E2_LOJA) = E5_DOCUMEN "
				cQuery +=	" 						AND MES.E2_TIPO = '"+MVPAGANT+"' "

				If cDbMs == "ORACLE"
					cQuery +=	" 						AND TO_CHAR(E5_DATA,'MM') = TO_CHAR(MES.E2_EMISSAO,'MM') "
					cQuery +=	" 						AND TO_CHAR(E5_DATA,'YYYY') = TO_CHAR(MES.E2_EMISSAO,'YYYY') "
				ElseIf cDbMs == "POSTGRES"
					cQuery +=	" 						AND SUBSTRING(E5_DATA,1,6) = SUBSTRING(MES.E2_EMISSAO,1,6) "
				Else
					cQuery +=	" 						AND MONTH(E5_DATA) = MONTH(MES.E2_EMISSAO) "
					cQuery +=	" 						AND YEAR(E5_DATA) = YEAR(MES.E2_EMISSAO) "
				EndIf

				cQuery +=	"							) "

				cQuery +=	"			WHEN E5_MOTBX <> 'CMP' THEN 1 "

				cQuery +=	" 	 END )  > 0 "
			EndIf

			If lF241QRY3
				cQuery	:= ExecBlock("F241QRY3",.F.,.F.,{cQuery})
			Endif
		cQuery := ChangeQuery( cQuery )
		dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

		For nLoop := 1 To Len( aStruct )
			If ! Empty( AScan( aCampos, AllTrim( aStruct[nLoop,1] ) ) )
				TcSetField( cAliasQry, aStruct[nLoop,1], aStruct[nLoop,2],aStruct[nLoop,3],aStruct[nLoop,4])
			EndIf
		Next

		While !( cAliasQRY )->( Eof())

			nProp := 1
			nTit	:= 0
			nImpRetEmi	:= 0

			If ( cAliasQRY )->E5_VRETPIS + ( cAliasQRY )->E5_VRETCOF + ( cAliasQRY )->E5_VRETCSL  > 0  .OR. ;
				(cAliasQRY)->E5_MOTBX == "CMP"

				__SE2->(dbSetOrder(1))
				If !(__SE2->(MsSeek(xFilial("SE2")+(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))))
					( cAliasQRY )->(DbSkip())
					Loop
				Endif

				If !Empty(__SE2->E2_NUMBOR).and. __SE2->E2_SALDO <> 0

					If  (cAliasQRY)->E5_PRETPIS == "1" .Or.  (cAliasQRY )->E5_PRETCOF == "1" .Or.  (cAliasQRY )->E5_PRETCSL == "1"
						AAdd( aRecnosSE5, ( cAliasQRY )->RECNO )

					Endif
					If !(__SE2->E2_NUMBOR == cNumBor) //titulo pertencente a um bordero com baixa parcial, deverá ser alterado E5_PRET*,
														// mas não irá compor a cumulatividade aqui, mas sim pela SE2
					   	( cAliasQRY )->(DbSkip())
					   	Loop
					Endif
				Endif

				lCalcIssBx:= GetCalcIss(__SE2->E2_FILORIG)

				//Verificar ou nao o limite de 5000 para Pis cofins Csll
				// 1 = Verifica o valor minimo de retencao
				// 2 = Nao verifica o valor minimo de retencao (estes nao serao considerados na soma dos 5000)
				// Verifica caso seja IRPF pela Baixa (serve de base para o cálculo da base progressiva de IR)
				If lCpoVlMin .and. __SE2->E2_APLVLMN == "2"
					( cAliasQRY )->(DbSkip())
					Loop
				Endif

			 	If StoD((cAliasQry)->E5_DATA) < dDataIni
					If ((cAliasQry)->(E5_VALOR+E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)) == __SE2->E2_VALOR .Or.;
	 				   ((cAliasQry)->(E5_VALOR+E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)) <> __SE2->E2_VALOR .And. __SE2->E2_SALDO == 0
						( cAliasQRY )->(DbSkip())
						Loop
					EndIf
				EndIf

				//Se titulo foi baixado anteriormente e nao esta pendente retencao, ignorar
				If __SE2->(E2_SALDO) == 0 .AND. !(__SE2->E2_PRETPIS == "1" .OR. __SE2->E2_PRETCOF == "1" .OR. __SE2->E2_PRETCSL == "1" )
					//Se for compensacao
					If (cAliasQry)->E5_MOTBX $ "CMP"
						//Se o valor do titulo baixado nao estiver mais retido no SE5
						If	!((cAliasQry)->E5_PRETPIS $ "1#7" .OR. (cAliasQry)->E5_PRETCOF $ "1#7" .OR. (cAliasQry)->E5_PRETCSL $ "1#7")
							(cAliasQRY)->(dbSkip())
							Loop
						Endif
					Endif
				Endif

				cChaveTit	:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)

				//Verifico se as compensacoes foram realizados com PA ou NDF e que nao retem PCC
        	 	If ! F241CmpPcc(cAliasQRY,cChaveTit)
					(cAliasQRY)->(DbSkip())
					Loop
				Endif

				//Reconstituo o valor do titulo somando os outros impostos destacados na emissao
				nVlrTit := __SE2->(E2_VALOR+E2_IRRF+E2_ISS+E2_INSS)

				//SEST
				nVlrTit += __SE2->E2_SEST

				If lIRPFBaixa
					nVlTitSE2 -= __SE2->E2_IRRF
				EndIf

				If lCalcIssBx
					nVlrTit -= __SE2->E2_ISS
				Endif

				nImpRetEmi := nVlrTit - __SE2->E2_VALOR

				//Proporcionalizo a base de retencao, se for o caso
				If lBaseSE2 .And. !Empty(__SE2->E2_BASEPIS)
					nProp := __SE2->E2_BASEPIS / nVlrTit
				Endif

				nTit := (Ascan(aTitBsImp,{|x| x[1] == (cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)}))

				If nTit == 0
					If (cAliasQRY)->E5_MOTBX != "CMP" 
						//Armazeno os valores calculados por titulo.
						If __SE2->E2_PIS > 0 .AND. !(cAliasQRY)->E5_TIPO $ MVPAGANT
							aDadosImp[1] += __SE2->E2_PIS
							lGravou := .T.
						EndIf

						If __SE2->E2_COFINS > 0 .AND. !(cAliasQRY)->E5_TIPO $ MVPAGANT
							aDadosImp[2] += __SE2->E2_COFINS
							lGravou := .T.
						EndIf

						If __SE2->E2_CSLL > 0 .AND. !(cAliasQRY)->E5_TIPO $ MVPAGANT
							aDadosImp[3] += __SE2->E2_CSLL
							lGravou := .T.
						EndIf
					EndIf

					//Somo valores dos impostos de IRRF/ISS/INSS dos titulos que foram compensados
					//por PA que não reteve impostos, para recompor a base de calculo
					If __SE2->(E2_IRRF+E2_ISS+E2_INSS) > 0 .AND. !(cAliasQRY)->E5_TIPO $ MVPAGANT .And.;
						(Ascan(aChaveTit,{|x| x == (cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)})) = 0
						aAreaSE5 := (cAliasQRY)->(GetArea())
						dbSelectArea("SE5")
						dbSetOrder(7)
						If MsSeek(xFilial("SE5")+SUBSTR((cAliasQRY)->E5_DOCUMEN,1,nTamTit)+(cAliasQRY)->E5_FORNADT+;
							(cAliasQRY)->E5_LOJAADT)
							If	SE5->E5_PRETPIS == "1" .Or. SE5->E5_PRETCOF == "1" .Or. SE5->E5_PRETCSL == "1"
								aDadosImp[4] += __SE2->(E2_IRRF+E2_ISS+E2_INSS)
								lGravou := .T.
							EndIf
						EndIf
						RestArea(aAreaSE5)
					EndIf

					//Somo valores dos impostos de IRRF/ISS/INSS dos titulos do tipo PA (Pagto Adiantado)
					//que foram compensados, para recompor a base de calculo(nBaseImp) do PIS/COF/CSL
					If __SE2->(E2_IRRF+E2_ISS+E2_INSS) > 0 .AND. (cAliasQRY)->E5_TIPO $ MVPAGANT .And.;
						(Ascan(aChaveTit,{|x| x == SUBSTR((cAliasQRY)->E5_DOCUMEN,1,nTamTit)+(cAliasQRY)->(E5_FORNADT+E5_LOJAADT)})) > 0
						aAreaSE5 := (cAliasQRY)->(GetArea())
						dbSelectArea("SE5")
						dbSetOrder(7)
						If MsSeek(xFilial("SE5")+(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))
							SFQ->(dbSetOrder(2))
							cChaveSE5 := SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)
							If SFQ->(MsSeek(xFilial("SFQ")+"SE5"+cChaveSE5))
								lAchouPa := .T.
							EndIf
							If	(SE5->E5_PRETPIS $ "1# " .Or. SE5->E5_PRETCOF $ "1# " .Or. SE5->E5_PRETCSL $ "1# ") .And.;
								!lAchouPa
								aDadosImp[5] += __SE2->(E2_IRRF+E2_ISS+E2_INSS)
								lGravou := .T.
							EndIf
						EndIf
						RestArea(aAreaSE5)
					EndIf

					If lGravou
						AADD(aTitBsImp,{(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA),0})
						nTit := Len(aTitBsImp)
						lGravou := .F.
					Endif
				Endif
			Endif

		 	If (cModTot=="1") .AND. StoD((cAliasQry)->E5_DATA) < dDataIni
				If ((cAliasQry)->(E5_VALOR+E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)) == __SE2->E2_VALOR .Or.;
	 				   ((cAliasQry)->(E5_VALOR+E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)) <> __SE2->E2_VALOR .And. __SE2->E2_SALDO == 0
					( cAliasQRY )->(DbSkip())
					Loop
				EndIf
			EndIf
			If !(cAliasQRY)->E5_MOTBX $ "PCC#CEC#DSD" .and. F241CmpPcc(cAliasQRY) .and. !F241EmBord((cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))
				adadosret[1] += ((cAliasQRY)->(E5_VALOR+E5_VLDESCO-E5_VLJUROS-E5_VLMULTA)+nImpRetEmi) * nProp
				If GetCalcIss(__SE2->E2_FILORIG)
					adadosret[1] += (cAliasQRY)->(E5_VRETISS) * nProp
				Endif
			Endif

			//Incrementa a base de calculo para gerar os titulos
			If (cAliasQRY)->E5_MOTBX == "PCC"
				aDadosRet[1] += (nVlrTit*nProp) - (cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
			EndIf

			If Empty( ( cAliasQRY )->E5_PRETPIS ) .Or. ( cAliasQRY )->E5_PRETPIS == '4' .Or. ( cAliasQRY )->E5_PRETPIS == '5'.Or. ( cAliasQRY )->E5_PRETPIS == '7'
				aDadosRet[1] += (cAliasQRY)->E5_VRETPIS
				If nTit > 0
					aTitBsImp[nTit,2]+= (cAliasQRY)->E5_VRETPIS
				Endif

				nProp2 := 1

				//Verifico a compensacao com NDF para descontar do imposto a reter
				If ( cAliasQRY )->(E5_VRETPIS + E5_VRETCOF + E5_VRETCSL) == 0 .And.;
					( cAliasQRY )->E5_MOTBX == "CMP"	.and. SUBSTR(( cAliasQRY )->E5_DOCUMEN,nTamTit2,3) $ MV_CPNEG .and. ;
					!(( cAliasQRY )->E5_TIPO $ MVPAGANT+"/"+MV_CPNEG )

					nProp2 := (( cAliasQRY )->E5_VALOR / nVlrTit)  //Proporcao entre a compensacao e a base do imposto
					aDadosImp[1] -= __SE2->E2_PIS * nProp2

				//Armazeno os valores calculados por titulo,retirando os valores retidos
				ElseIf ( cAliasQRY )->(E5_VRETPIS + E5_VRETCOF + E5_VRETCSL) > 0 .And.;
					!(cAliasQRY)->E5_TIPO $ MVPAGANT
					aDadosImp[1] -= ( cAliasQRY )->E5_VRETPIS
					lVerSFQ := .T.
				Endif
			Endif

			If Empty( ( cAliasQRY )->E5_PRETCOF ) .Or. ( cAliasQRY )->E5_PRETCOF == '4' .Or. ( cAliasQRY )->E5_PRETCOF == '5'.Or. ( cAliasQRY )->E5_PRETCOF == '7'
				aDadosRet[1] += ( cAliasQRY )->E5_VRETCOF
				If nTit > 0
					aTitBsImp[nTit,2]+= (cAliasQRY)->E5_VRETCOF
				Endif

				nProp2 := 1

				//Verifico a compensacao com NDF para descontar do imposto a reter
				If ( cAliasQRY )->(E5_VRETPIS + E5_VRETCOF + E5_VRETCSL) == 0 .And.;
					( cAliasQRY )->E5_MOTBX == "CMP"	.and. SUBSTR(( cAliasQRY )->E5_DOCUMEN,nTamTit2,3) $ MV_CPNEG .and. ;
					!(( cAliasQRY )->E5_TIPO $ MVPAGANT+"/"+MV_CPNEG )

					nProp2 := (( cAliasQRY )->E5_VALOR / nVlrTit)  //Proporcao entre a compensacao e a base do imposto
					aDadosImp[2] -= __SE2->E2_COFINS * nProp2

				//Armazeno os valores calculados por titulo,retirando os valores retidos
				ElseIf ( cAliasQRY )->(E5_VRETPIS + E5_VRETCOF + E5_VRETCSL) > 0 .And.;
					!(cAliasQRY)->E5_TIPO $ MVPAGANT
					aDadosImp[2] -= ( cAliasQRY )->E5_VRETCOF
					lVerSFQ := .T.
				Endif
			Endif

			If Empty( ( cAliasQRY )->E5_PRETCSL ) .Or. ( cAliasQRY )->E5_PRETCSL == '4' .Or. ( cAliasQRY )->E5_PRETCSL == '5'.Or. ( cAliasQRY )->E5_PRETCSL == '7'
				aDadosRet[1] += ( cAliasQRY )->E5_VRETCSL
				If nTit > 0
					aTitBsImp[nTit,2]+= (cAliasQRY)->E5_VRETCSL
				Endif

				nProp2 := 1

				//Verifico a compensacao com NDF para descontar do imposto a reter
				If ( cAliasQRY )->(E5_VRETPIS + E5_VRETCOF + E5_VRETCSL) == 0 .And.;
					( cAliasQRY )->E5_MOTBX == "CMP"	.and. SUBSTR(( cAliasQRY )->E5_DOCUMEN,nTamTit2,3) $ MV_CPNEG .and. ;
					!(( cAliasQRY )->E5_TIPO $ MVPAGANT+"/"+MV_CPNEG )

					nProp2 := (( cAliasQRY )->E5_VALOR / nVlrTit)  //Proporcao entre a compensacao e a base do imposto
					aDadosImp[3] -= __SE2->E2_CSLL * nProp2

				//Armazeno os valores calculados por titulo,retirando os valores retidos
				ElseIf ( cAliasQRY )->(E5_VRETPIS + E5_VRETCOF + E5_VRETCSL) > 0 .And.;
					!(cAliasQRY)->E5_TIPO $ MVPAGANT
					aDadosImp[3] -= ( cAliasQRY )->E5_VRETCSL
					lVerSFQ := .T.
				Endif
			EndIf

			//Verificação de pendencias de PCC
			//Exemplo:
			//Titulo A teve o imposto retido no titulo B em bordero.
			//Ambos foram baixados
			//Ao verificar esta baixa, o valor do imposto calculado era menor que o imposto retido no titulo B
			//Neste caso o imposto do titulo A seria sempre deduzido nos borderos posteriores
			If lVerSfq
				aRecSE2 := FImpExcTit("SE2",( cAliasQRY )->E5_PREFIXO,( cAliasQRY )->E5_NUMERO,( cAliasQRY )->E5_PARCELA,( cAliasQRY )->E5_TIPO,( cAliasQRY )->E5_CLIFOR,( cAliasQRY )->E5_LOJA)
				nRecSE2 := 	__SE2->(RECNO())
				For nX := 1 to Len(aRecSE2)
					__SE2->(MSGoto(aRecSE2[nX]))
					aDadosImp[1] += __SE2->E2_PIS
					aDadosImp[2] += __SE2->E2_COFINS
					aDadosImp[3] += __SE2->E2_CSLL
				Next
				__SE2->(MSGoto(nRecSE2))
				lVerSfq := .F.
			Endif

			If (( cAliasQRY )->E5_PRETPIS == "1" .Or. ( cAliasQry )->E5_PRETCOF == "1" .Or. ( cAliasQry )->E5_PRETCSL == "1" )

				If ( cAliasQRY )->E5_PRETPIS == "1"
					aDadosRet[2] += ( cAliasQRY )->E5_VRETPIS
				EndIf

				If ( cAliasQRY )->E5_PRETCOF == "1"
					aDadosRet[3] += ( cAliasQRY )->E5_VRETCOF
				EndIf

				If ( cAliasQRY )->E5_PRETCSL == "1"
					aDadosRet[4] += ( cAliasQRY )->E5_VRETCSL
				EndIf

				AAdd( aRecnosSE5, ( cAliasQRY )->RECNO )

			EndIf

			( cAliasQRY )->( dbSkip())

		EndDo

		// Fecha a area de trabalho da query
		( cAliasQRY )->( dbCloseArea() )

		//Verifico pendencias de retencao em titulos de bordero
		//que nao foram baixados ainda.
		dbSelectArea("SE2")
		dbGoto(nSavRec)

		aCampos := { "E2_VALOR","E2_IRRF","E2_ISS","E2_INSS","E2_PIS","E2_COFINS","E2_CSLL","E2_VRETPIS",;
					 "E2_VRETCOF","E2_VRETCSL","E2_NUMBOR","E2_ACRESC","E2_DECRESC","E2_SALDO","E2_VENCREA","E2_SEST","E2_FILORIG"}

		If lBaseSe2
			AADD(aCampos, "E2_BASEPIS")
		Endif

		If __lLocBra
			AADD(aCampos, "E2_DTBORDE")
		Endif

		If lCpoVlMin
			AADD(aCampos, "E2_APLVLMN")
		Endif

		aStruct := SE2->( dbStruct() )

		SE2->( dbCommit() )

	  	cAliasQry := GetNextAlias()

		cQuery := "SELECT E2_VALOR,E2_PIS,E2_COFINS,E2_EMISSAO,E2_CSLL,E2_ISS,E2_INSS,E2_IRRF, E2_VRETIRF,E2_VRETPIS,"
		cQuery += "E2_VRETCOF,E2_VRETCSL,E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,E2_NUMBOR,E2_PREFIXO,E2_NUM,"
		cQuery += "E2_PARCELA,E2_TIPO,E2_FORNECE,E2_LOJA,E2_MOEDA,E2_ACRESC,E2_DECRESC,E2_FATURA,E2_SALDO,E2_VENCREA,E2_BASEPIS,"
		cQuery += "E2_SEST,E2_FILORIG,"

		If __lLocBra
			cQuery += "E2_DTBORDE,"
		Endif
		If lCpoVlMin
			cQuery += "E2_APLVLMN,"
		Endif

		If lPABruto
			cQuery += "E2_TITADT,"
		EndIf

		If __lLocBra
			cQuery += "E2_ORIGEM,E2_NUMTIT,E2_FORNPAI,"
		Endif

		If lF241CMP2
			cQuery	+= ExecBlock("F241CMP2",.F.,.F., {cQuery}) + ","
		Endif
		cQuery += "	R_E_C_N_O_ RECNO FROM "
		cQuery += RetSqlName( "SE2" ) + " SE2A "
		cQuery += "WHERE "
		cQuery += "E2_FILIAL='"    + xFilial("SE2")       + "' AND "

		If Len(aFor10925) > 0  //Verificar determinados fornecedores (raiz do CNPJ)
			cQuery += "( "
			For nLoop := 1 to Len(aFor10925)
				cQuery += "(E2_FORNECE ='"   + aFor10925[nLoop,1]  + "' AND "
				cQuery += "E2_LOJA='"       + aFor10925[nLoop,2]  + "') OR "
			Next
			//Retiro o ultimo OR
			cQuery := Left( cQuery, Len( cQuery ) - 4 )
			cQuery += ") AND "
		Else  //Apenas Fornecedor e Loja atuais
			cQuery += "E2_FORNECE ='"     + SE2->E2_FORNECE        + "' AND "
			If lLojaAtu  //Considero apenas a loja atual
				cQuery += "E2_LOJA='"		+ SE2->E2_LOJA	+ "' AND "
			EndIf
		Endif

		//Verifico o parametro e se o campo existe na base
		If mv_par06 <> 1 .And. __lLocBra
			If mv_par06 == 3 //3- Verifica o vencimento real e a data de geracao do bordero
				cQuery += "((E2_VENCREA>= '" + DToS( dDataIni )      + "' AND "
				cQuery += "E2_VENCREA<= '" + DToS( dDataFim )      + "') "
				cQuery += " OR (E2_DTBORDE>= '" + DToS( dDataIni )      + "' AND "
				cQuery += "E2_DTBORDE<= '" + DToS( dDataFim )      + "')) AND "
            //Protejo para nao recalcular os impostos em mes indevido
				cQuery += "(E2_DTBORDE>= '" + DToS( dDataIni )      + "' AND "
				cQuery += "E2_DTBORDE<= '" + DToS( dDataFim )      + "') "
			Else //2- Somente data de geracao do bordero
				cQuery += "(E2_DTBORDE>= '" + DToS( dDataIni ) + "' AND "
				cQuery += "E2_DTBORDE<= '" + DToS( dDataFim )      + "') "
			EndIf
		Else
			//1-Verifica somente o vencimento real dos titulos
			cQuery += "(E2_VENCREA>= '" + DToS( dVenIni240 )   + "' AND "
			cQuery += "E2_VENCREA<= '" + DToS( dVenFim240 )    + "') "
		Endif

		cQuery += "AND E2_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "
		cQuery += "E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)  + " AND "
		cQuery += "E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
		cQuery += "E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)  + " AND "
		cQuery += "(E2_SALDO>0 OR E2_NUMBOR <> '"+SPACE(LEN(E2_NUMBOR))+"') AND "
		cQuery += "E2_NUMBOR <> '"+SPACE(LEN(E2_NUMBOR))+"' AND "

		//Apenas titulos que tem retencao de PIS,Cofins e CSLL
		If cModTot == "2"
			cQuery += " (E2_PIS > 0 OR E2_COFINS > 0 OR E2_CSLL > 0 ) AND "
		Endif

		//Verificar ou nao o limite de 5000 para Pis cofins Csll
		// 1 = Verifica o valor minimo de retencao
		// 2 = Nao verifica o valor minimo de retencao (NAO SERAO CONSIDERADOS PARA A SOMA DOS 5000)
		If lCpoVlMin
			cQuery += " E2_APLVLMN <> '2' AND "
		Endif

		cQuery += "D_E_L_E_T_=' '"

		If lF241QRY2
			cQuery	+= ExecBlock("F241QRY2",.F.,.F., {cQuery})
		Endif

		If __lLocBra
			cQuery += " UNION "

			cQuery += "SELECT E2_VALOR,E2_PIS,E2_COFINS,E2_EMISSAO,E2_CSLL,E2_ISS,E2_INSS,E2_IRRF, E2_VRETIRF, E2_VRETPIS,"
			cQuery += "E2_VRETCOF,E2_VRETCSL,E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,E2_NUMBOR,E2_PREFIXO,E2_NUM,"
			cQuery += "E2_PARCELA,E2_TIPO,E2_FORNECE,E2_LOJA,E2_MOEDA,E2_ACRESC,E2_DECRESC,E2_FATURA,E2_SALDO,E2_VENCREA,E2_BASEPIS,"
			cQuery += "E2_SEST,E2_FILORIG,E2_DTBORDE,"

			If lCpoVlMin
				cQuery += "E2_APLVLMN,"
			Endif

			If lPABruto
				cQuery += "E2_TITADT,"
			EndIf

			cQuery += "E2_ORIGEM,E2_NUMTIT,E2_FORNPAI,"

			If lF241CMP2
				cQuery	+= ExecBlock("F241CMP2",.F.,.F., {cQuery}) + ","
			Endif
			cQuery += "	R_E_C_N_O_ RECNO FROM "
			cQuery += RetSqlName( "SE2" ) + " SE2B "
			cQuery += "WHERE "

			cQuery += "E2_FILIAL='"    + xFilial("SE2")       + "' AND "
			If Len(aFor10925) > 0  //Verificar determinados fornecedores (raiz do CNPJ)
				cQuery += "( "
				For nLoop := 1 to Len(aFor10925)
					cQuery += "(E2_FORNPAI ='"   + PADR(aFor10925[nLoop,1]+ aFor10925[nLoop,2],nTamForn) + "') OR "
				Next
				//Retiro o ultimo OR
				cQuery := Left( cQuery, Len( cQuery ) - 4 )
				cQuery += ") AND "
			Else  //Apenas Fornecedor e Loja atuais
				cQuery += "E2_FORNPAI ='"   + PADR(SE2->(E2_FORNECE+E2_LOJA),nTamForn) + "' AND "
			Endif
			cQuery += " E2_EMISSAO BETWEEN '"+Dtos( dDataIni) +"' AND '"+Dtos( dDataFim) +"' AND "
			cQuery += " E2_ORIGEM LIKE 'FINA374%' AND "
			cQuery += " (E2_TIPO IN " + FormatIn(MVTXA,cSepTxa)  + " OR "
			cQuery += " E2_TIPO IN " + FormatIn(MVTAXA,cSepTx) + ") AND "
			cQuery += " SE2B.D_E_L_E_T_ = ' ' "
		Endif

		If lF241QRY2
			cQuery	+= ExecBlock("F241QRY2",.F.,.F., {cQuery})
		Endif
		cQuery := ChangeQuery( cQuery )

		dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

		For nLoop := 1 To Len( aStruct )
			If !Empty( AScan( aCampos, AllTrim( aStruct[nLoop,1] ) ) )
				TcSetField( cAliasQry, aStruct[nLoop,1], aStruct[nLoop,2],aStruct[nLoop,3],aStruct[nLoop,4])
			EndIf
		Next nLoop

		While !( cAliasQRY )->( Eof())

			//VERIFICA VALORES APURADOS VIA FINA374
			If ( cAliasQRY )->E2_TIPO $ MVTXA .AND. "FINA374" $ ( cAliasQRY )->E2_ORIGEM
				aDadosImp[1]  	+=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='PIS',( cAliasQRY )->E2_VALOR,0)
				aDadosImp[2]  	+=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='COF',( cAliasQRY )->E2_VALOR,0)
				aDadosImp[3]  	+=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='CSL',( cAliasQRY )->E2_VALOR,0)
			ElseIf ( cAliasQRY )->E2_TIPO $ MVTAXA .AND. "FINA374" $ ( cAliasQRY )->E2_ORIGEM
				aDadosImp[1]  	-=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='PIS',( cAliasQRY )->E2_VALOR,0)
				aDadosImp[2]  	-=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='COF',( cAliasQRY )->E2_VALOR,0)
				aDadosImp[3]  	-=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='CSL',( cAliasQRY )->E2_VALOR,0)
			Else
				nVlTitSE2 := ( cAliasQRY )->(E2_VALOR+E2_IRRF+E2_ISS+E2_INSS)

				If lIRPFBaixa
					nVlTitSE2 -= ( cAliasQRY )->E2_IRRF
				EndIf

				nVlTitSE2 += ( cAliasQRY )->E2_SEST

				If lCalcIssBx
					nVlTitSE2 -= ( cAliasQRY )->E2_ISS
				Endif

				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->(E2_VRETPIS + E2_VRETCOF + E2_VRETCSL) > 0 .And.;
					(Empty( ( cAliasQRY )->E2_PRETPIS) .OR. ( cAliasQRY )->E2_PRETPIS == "3" )
					aDadosImp[1] -= ( cAliasQRY )->E2_VRETPIS
				Endif

				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->(E2_VRETPIS + E2_VRETCOF + E2_VRETCSL) > 0 .And.;
					(Empty( ( cAliasQRY )->E2_PRETCOF) .OR. ( cAliasQRY )->E2_PRETCOF == "3" )
					aDadosImp[2] -= ( cAliasQRY )->E2_VRETCOF
				Endif

				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->(E2_VRETPIS + E2_VRETCOF + E2_VRETCSL) > 0 .And.;
					(Empty( ( cAliasQRY )->E2_PRETCSL) .OR. ( cAliasQRY )->E2_PRETCSL == "3" )
					aDadosImp[3] -= ( cAliasQRY )->E2_VRETCSL
				EndIf

								
			// Tratando individualmente cada um dos impostos PCC, pois pode haver retenção de apenas um deles
				// 1 - Se calculou PCC
				// 2 - E Se a retenção está pendente
				// 3-  E Se não reteve PCC  				
				If (( !Empty((cAliasQRY)->E2_PIS)   .AND. (cAliasQRY)->E2_PRETPIS == "1"  .AND.  Empty((cAliasQRY)->E2_VRETPIS)) .OR. ; //PIS
 					( !Empty((cAliasQRY)->E2_COFINS).AND. (cAliasQry)->E2_PRETCOF == "1"  .AND.  Empty((cAliasQry)->E2_VRETCOF)) .OR. ;  //COFINS
				 	( !Empty((cAliasQRY)->E2_CSLL)  .AND. (cAliasQry)->E2_PRETCSL == "1"  .AND.  Empty((cAliasQry)->E2_VRETCSL)))  		//CSLL
	
					If lF241aRec

						aRecnosSE2 := ExecBlock("F241aRec",.F.,.F.,{aRecnosSE2, cAliasQry})

					Else
						AAdd( aRecnosSE2,{ (cAliasQRY)->RECNO,;
											 .F.,;
											 Str((cAliasQRY)->E2_SALDO,17,2),;
											 If(PadR(cNumBor,6) == (cAliasQRY)->E2_NUMBOR,"Z","A"),;
											 If(__lLocBra, DTOS((cAliasQRY)->E2_DTBORDE), DTOS(dDataBase)),;
											 (cAliasQRY)->E2_NUMBOR,;
											 DTOS((cAliasQRY)->E2_VENCREA),;
					STRZERO((cAliasQRY)->RECNO,17),;
					(cAliasQRY)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) } )
					EndIf
				Else
					//Adiciono o valor dos titulos que ja retiveram impostos no bordero
					// 4 - RETIDO EM OUTRO BORDERO
					If ((cAliasQRY)->E2_PRETPIS $ '4' .OR. (cAliasQRY)->E2_PRETCOF $ '4' .OR. (cAliasQRY)->E2_PRETCSL $ '4' ) .And.;
						!Empty((cAliasQRY)->E2_NUMBOR) .And. (cAliasQRY)->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0
						adadosret[1] += nVlTitSE2
					// 2 - RETIDO EM OUTRO TITULO (EMISSAO)
					ElseIf ((cAliasQRY)->E2_PRETPIS $ '2' .OR. (cAliasQRY)->E2_PRETCOF $ '2' .OR. (cAliasQRY)->E2_PRETCSL $ '2' ) .And.;
						!Empty((cAliasQRY)->E2_NUMBOR) .And. (cAliasQRY)->(E2_COFINS+E2_PIS+E2_CSLL) > 0
						adadosret[1] += nVlTitSE2
					// 3 - RETIDO EM UMA BAIXA (SE SALDO > 0, TRATAREI O RESTANTE DO IMPOSTO)
					ElseIf (((cAliasQRY)->E2_PRETPIS $ '1#3#7' .OR. (cAliasQRY)->E2_PRETCOF $ '1#3#7' .OR. (cAliasQRY)->E2_PRETCSL $ '1#3#7' ) .And.;
						!Empty((cAliasQRY)->E2_NUMBOR) .And. (cAliasQRY)->(E2_COFINS+E2_PIS+E2_CSLL) > 0 );
						.OR. SE2->E2_ISS > 0 .And. GetCalcIss((cAliasQRY)->E2_FILORIG)

						If (cAliasQRY)->(E2_SALDO) > 0
							If lF241aRec
								aRecnosSE2 := ExecBlock("F241aRec",.F.,.F.,{aRecnosSE2, cAliasQry})
							Else
								AAdd( aRecnosSE2,{(cAliasQRY)->RECNO,;
													 .F.,;
													 Str((cAliasQRY)->E2_SALDO,17,2),;
													 If(PadR(cNumBor,6) == (cAliasQRY)->E2_NUMBOR,"Z","A"),;
													 If(__lLocBra, DTOS((cAliasQRY)->E2_DTBORDE), DTOS(dDataBase)),;
													 (cAliasQRY)->E2_NUMBOR,;
													 DTOS((cAliasQRY)->E2_VENCREA),;
							STRZERO((cAliasQRY)->RECNO,17),;
							(cAliasQRY)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) } )
							EndIf
						Else
							// Inclui o valor do titulo na base de calculo do PCC
							IF ((cAliasQRY)->E2_BASEPIS>0)
								adadosret[1] +=  (cAliasQRY)->E2_BASEPIS
							ELSE
								adadosret[1] += nVlTitSE2
							ENDIF
						EndIf

					EndIf
				Endif
			EndIf
			If lEmpPub .And. lIrpfBaixa .And. adadosret[1] > 0 .And. (cAliasQRY)->E2_PRETPIS <> "1"
				aPubRet[1] += (cAliasQRY)->E2_PIS
				aPubRet[2] += (cAliasQRY)->E2_COFINS
				aPubRet[3] += (cAliasQRY)->E2_CSLL

				aPubRet[4] += (cAliasQRY)->E2_VRETPIS
				aPubRet[5] += (cAliasQRY)->E2_VRETCOF
				aPubRet[6] += (cAliasQRY)->E2_VRETCSL

			EndIf
			( cAliasQRY )->( dbSkip())

		EndDo
		// Fecha a area de trabalho da query
		( cAliasQRY )->( dbCloseArea() )
		dbSelectArea( "SE2" )
		dbSetOrder(1)

	Next
ElseIf lGeraImp
	AAdd(aRecnosSE2, {SE2->(RECNO()), .F., STR(SE2->E2_SALDO, 17, 2), If(PadR(cNumBor,6) == SE2->E2_NUMBOR, "Z", "A"),;
							 If(__lLocBra, DTOS(SE2->E2_DTBORDE), DTOS(dDataBase)),;
							 SE2->E2_NUMBOR, DTOS(SE2->E2_VENCREA), STRZERO(SE2->( RECNO() ),17) } )
Endif

aTitsSE5 := AClone(aDadosRet)
cFilAnt  := cFilAtu
RestArea(aArea)

If dDatabase >= dLastPCC .and. !lEmpPub
	If lF241aRec
		aContab := ExecBlock("F241aRec",.F.,.F.,{aContab, "SE2"})
	ElseIf lF241Rec1
		aContab := ExecBlock("F241Rec1",.F.,.F.,{aContab, "SE2"})
	ElseIf lGeraImp
		AAdd(aContab, {SE2->(RECNO()), .F., STR(SE2->E2_SALDO, 17, 2), If(PadR(cNumBor,6) == SE2->E2_NUMBOR,"Z","A"),;
						 If(__lLocBra, DTOS(SE2->E2_DTBORDE), DTOS(dDataBase)),;
						 SE2->E2_NUMBOR, DTOS(SE2->E2_VENCREA), STRZERO(SE2->(RECNO()), 17),;
						 SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA), Nil, nRetMotor})
	Endif
	
	If !lIsLast
		Return(.T.)
	EndIf
	
	aRecnosSE2 := aClone(aContab)
EndIf

If !lF241Ord
	If lF241aRec
		aSort(aRecnosSE2,,,{|x,y| x[10]+x[8] < y[10]+y[8]})
	Else
		//Ordeno para que o bordero atual seja o ultimo e por saldo
		aSort(aRecnosSE2,,,{|x,y| x[4]+x[5]+x[8] < y[4]+Y[5]+y[8]})
	EndIf
Else
	aRetOrd    := ExecBlock("F241Ord",.F.,.F.,{aRecnosSE2, "SE2"})
	aRecnosSE2 := aClone(aRetOrd)
EndIf

oModelMov := FWLoadModel("FINM020")
oModelMov:SetOperation(3)
cFilBkp     := cFilAnt
lF590Impost := Iif(lF590Impost, lF590Impost, (mv_par08 == 1))
__cFilCtb   := ""

If !Empty(aRecnosSE2)
    SE2->(dbGoto(aRecnosSE2[1][RECNOSE2]))
    cFilAnt := SE2->E2_FILORIG
EndIf

For nLoop := 1 to Len(aRecnosSE2)
	SE2->(dbGoto(aRecnosSE2[nLoop][RECNOSE2]))
	
	If lF590Impost .And. !Empty(SE2->E2_FILORIG)
		If cFilAnt <> SE2->E2_FILORIG .And. nHdlPrv > 0 .And. lContabil .And. nTotal > 0			
			If (nPosArray := (nLoop - 1)) == 0
				nPosArray := 1
			EndIf
			
			SE2->(DbGoto(aRecnosSE2[nPosArray][RECNOSE2]))			
			cFilAnt := Iif(Empty(SE2->E2_FILORIG), cFilAnt, SE2->E2_FILORIG)
	
			cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, (mv_par07 == 1) /*lDigita*/, .F. /*lAglut*/, /*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, __aCTBPrv/*aDadosProva*/, /*aDiario*/)
			
			aFlagCTB := {}
			nTotal   := 0
            nHdlPrv := 0
			SE2->(DbGoto(aRecnosSE2[nLoop][RECNOSE2]))
			__cFilCtb := SE2->E2_FILORIG
		EndIf
		
		cFilAnt  := SE2->E2_FILORIG
		cFilOrig := SE2->E2_FILORIG
		
		If lContabil
			__cFilCtb := cFilAnt
		EndIf
	EndIf

	If lF241aRec
		If nLoop == 1
			cCli := aRecnosSE2[nLoop][CAMPOUSER]
		ElseIf aRecnosSE2[nLoop][CAMPOUSER] <> cCli
			cCli		:= aRecnosSE2[nLoop][CAMPOUSER]
			nPis		:= 0
			nCofins		:= 0
			nCsll		:= 0
			nIrrf		:= 0
			nTotTitSE2	:= 0
			nTotPisSE2	:= 0
			nTotCofSE2	:= 0
			nTotCslSE2	:= 0
			nTotIrfSE2	:= 0
			nCalcPis	:= 0
			nCalcCof 	:= 0
			nCalcCsl 	:= 0
			nCalcIrf 	:= 0
		EndIf
	EndIf
	
	lIRPFBaixa :=	Iif(__lLocBra, Posicione("SA2",1,xfilial("SA2") + SE2->(E2_FORNECE+E2_LOJA),"A2_CALCIRF") == "2" .And.;
	             		 Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S",.F. )

	lIRPFBaixa := Iif(__lIrfMR, .F.,lIRPFBaixa)
	lAplMinP   := (SA2->A2_MINPUB == "2")
	nVlrCmpCrt := 0
	nImpMotor  := If(Len(aRecnosSE2[nLoop]) >= 11, aRecnosSE2[nLoop][IMPMOTOR], 0)
	
	If lIrpfBaixa .And. SE2->E2_PRETIRF $ " /4/6"
		nSaldoTit := SE2->E2_SALDO + If(!__lIrfMR, SE2->E2_VRETIRF, 0)
	Else
		nSaldoTit := SE2->E2_SALDO
	Endif
	
	//Motor de retenções
	nSaldoTit += nImpMotor
	
	If lTodasFil .And. !Empty(cFilFwSE2)
		cFilAnt := SE2->E2_FILIAL
	EndIf
	
	aRecnosSE2[nLoop][MARCADO] := .T.
	lBordAtu  := (aRecnosSE2[nLoop][BORDERATUAL] == "Z")   //Verifica se o titulo pertence ao bordero atual
	lAltBxVal := STR(SE2->E2_VALOR,17,2) != STR(nSaldoTit,17,2)
	lImpInFat := .F.	
	nTotAbat  := SomaAbat(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, "P", SE2->E2_MOEDA, dDataBase, SE2->E2_FORNECE, SE2->E2_LOJA)
	nAcresc   := SE2->E2_SDACRES
	nDecresc  := SE2->E2_SDDECRE
	
	If 'NOTFAT' $ SE2->E2_FATURA
		//nValOutImp : resultado do F080OutImp : outros impostos derivados da geracao de juros, multa, acrescimo e desconto
		nValOutImp := f080OutImp((SE2->E2_SALDO+nAcresc) - (nDecresc+nTotAbat))
		lImpInFat := .T.
	Else
		nValOutImp := SE2->E2_INSS // Igual a fina080 recompõe os impostos gerados na emissão.
		nValOutImp += SE2->E2_SEST
		
		If !__lIssMR .And. !lCalcIssBx
			nValOutImp += SE2->E2_ISS
		Endif
		
		If !__lIrfMR .And. !lIRPFBaixa
			nValOutImp += SE2->E2_IRRF
		EndIf
	Endif
	
	//Caso o titulo possua o valor de base dos impostos preenchidos, considero
	//esse valor com base para calculo, desprezando o valor do titulo
	If lBaseSe2 .And. SE2->E2_BASEPIS > 0
		nValTit := SE2->E2_BASEPIS
		nBaseImp := SE2->E2_BASEPIS
	Else
		nValTit := SE2->E2_VALOR + nValOutImp
		//Baixa via cnab de bordero onde nao houve a retencao
		If SE2->E2_PRETPIS == '1' .AND. SE2->E2_SALDO == 0 .AND. !(EMPTY(SE2->E2_NUMBOR)) .and. ;
			SE2->(E2_PIS+E2_COFINS+E2_CSLL+E2_ISS) > 0
			nBaseImp := nValTit
		Endif
	Endif
	
	nFound      := aScan(aTitBsImp,{ |x|  x[1] == aRecnosSE2[nLoop][CHAVE]})
    lTeveBxParc := SE2->E2_SALDO != SE2->E2_VALOR
    
	If lTeveBxParc
    	If SE2->E2_VRETCSL > 0 .and. SE2->E2_VRETCOF > 0 .and. SE2->E2_VRETPIS > 0
    		lJaReteve := .T.
    	Endif
    Endif
	
	//Considero juros,multa,desconto,abatimento, acrescimo e decrescimo na base do imposto
	If nFound == 0 .or. aRecnosSe2[nLoop][SALDO] <> Str(0,17,2)  //tem saldo
		If lJurMulDes
			//Valor dos abatimentos/acrescimo/decrescimo de cada titulo selecionado pendente de retenção
			nTotAbat := SomaAbat(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,"P",SE2->E2_MOEDA,,SE2->E2_FORNECE)
			nAcresc  := SE2->E2_SDACRES
			nDecresc := SE2->E2_SDDECRE
			
			//Remonto a base para o calculo dos impostos de PIS/COF/CSL
			If Empty(nBaseImp) .OR. (nSaldoTit != nBaseImp)
				nTit    := (Ascan(aTitBsImp,{|x| x[1] == SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)}))
				aAreaE2	:= GetArea()
				dbSelectArea("SE5")
				
				If SE5->(DbSeek(xFilial("SE5")+"BA"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)) .and. SE5->E5_MOTBX = "CEC"
					nBaseImp := nSaldoTit-nTotAbat+nAcresc-nDecresc+nValOutImp+nValComp+aDadosImp[4]-aDadosImp[5]
					
					If !__lPccMR .And. lPCCBaixa
						nBaseImp -= (SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL)
					EndIf
				Else
					nBaseImp := nSaldoTit-nTotAbat+nAcresc-nDecresc+nValOutImp+nValComp+aDadosImp[4]-aDadosImp[5]+If(nTit==0,0,aTitBsImp[nTit,2])
				EndIf
				
				//Se for pa bruto e tiver baixado o valor dos impostos de um PA do titulo, busco o valor no SE5 para recompor a base.
				If lPABruto
					nBaseImp += PABrtComp()
				EndIf
			EndIf
			
			If !__lPccMR
				If SE2->E2_PIS > 0
					nPis := NoRound(( nBaseImp * SE2->E2_PIS ) / nValTit ,2)
				EndIf
				
				If SE2->E2_COFINS > 0
					nCofins := NoRound(( nBaseImp * SE2->E2_COFINS ) / nValTit ,2)
				EndIf
				
				If SE2->E2_CSLL > 0
					nCsll := NoRound(( nBaseImp * SE2->E2_CSLL ) / nValTit ,2)
				EndIf
			EndIf
			
			If !__lIrfMR .And. SE2->E2_IRRF > 0 .and. lEmpPub .And. lIRPFBaixa
				nIrrf	:= SE2->E2_IRRF
			EndIf
		Else
 			If STR(SE2->E2_VALOR,17,2) == STR(nSaldoTit+If(nFound > 0, aTitBsImp[nFound][2],0),17,2) .or. (!Empty(SE2->E2_NUMBOR) .and. SE2->E2_SALDO == 0)
				nFatorRed := 1 
				nPis      := SE2->E2_PIS
				nCofins   := SE2->E2_COFINS
				nCsll     := SE2->E2_CSLL
				
				If SE2->E2_IRRF > 0 .and. lEmpPub .And. lIRPFBaixa
					nIrrf	:= SE2->E2_IRRF
				EndIf
			Else
				If lPABruto
					nPaBruto := PABrtComp()
				EndIf
				
				//se não teve baixa parcial
				If DToC(SE2->E2_BAIXA) == "  /  /  "
					nFatorRed := ((nSaldoTit+nValOutImp+nPaBruto+If(nFound > 0, aTitBsImp[nFound][2],0) ) / (SE2->E2_VALOR+nValOutImp))
				ElseIF lValLiq
					nFatorRed := ((nSaldoTit+nValOutImp+nPaBruto+SE2->E2_DECRESC+nValComp) / (SE2->E2_VALOR+nValOutImp))
				ElseIf SE2->E2_VRETISS > 0
					nFatorRed := ((nSaldoTit+nValOutImp+SE2->E2_VRETISS+nPaBruto+SE2->E2_DECRESC+If(nFound > 0, aTitBsImp[nFound][2],0) ) / (SE2->E2_VALOR+nValOutImp))
				Else
					nFatorRed := ((nSaldoTit+nValOutImp+nPaBruto+SE2->E2_DECRESC+If(nFound > 0, aTitBsImp[nFound][2],0) ) / (SE2->E2_VALOR+nValOutImp))
				EndIf
				
				If  lValLiq .and. !lJaReteve .and. ( lTeveBxParc .or. lPCCBaixa ) .and. nFatorRed == 1
					nPis    := SE2->E2_PIS
					nCofins := SE2->E2_COFINS
					nCsll   := SE2->E2_CSLL
					lBxParc := .T.
				ElseIf lValLiq .and. lPCCBaixa .and. lJaReteve
					nPis    := SE2->E2_PIS  - SE2->E2_VRETPIS
					nCofins := SE2->E2_COFINS - SE2->E2_VRETCOF
					nCsll   := SE2->E2_CSLL - SE2->E2_VRETCSL
				    lBxParc := .T.
				ElseIf lPCCBaixa .and. !lJaReteve .and. lTeveBxParc
					aAreaE2	:= GetArea()
					dbSelectArea("SE5")
					
					If SE5->(DbSeek(xFilial("SE5")+"BA"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)) .and. SE5->E5_MOTBX = "CEC"
						nPis    := SE2->E2_PIS
						nCofins := SE2->E2_COFINS
						nCsll   := SE2->E2_CSLL
						lBxParc := .T.
						
						If lCC10925
							nVlrCmpCrt := SE5->E5_VALOR
						EndIf
					EndIf
					
					If SE2->E2_VALOR # SE2->E2_SALDO  .And. SE2->E2_SALDO > 0   .And. (nPis+nCofins+nCsll) == 0
						nPis    := SE2->E2_PIS * nFatorRed
				 		nCofins := SE2->E2_COFINS * nFatorRed
				 		nCsll   := SE2->E2_CSLL * nFatorRed
					EndIf
					
					If lEmpPub .And. lIRPFBaixa
						nIrrf    := SE2->E2_IRRF * nFatorRed
					EndIf
					
					RestArea(aAreaE2)
				ElseIf lPCCBaixa .and. lJaReteve .and. lTeveBxParc
					aAreaE2	:= GetArea()
					dbSelectArea("SE5")
					
					If SE5->(DbSeek(xFilial("SE5")+"BA"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)) .and. SE5->E5_MOTBX = "CEC"
						nPis    := SE2->E2_PIS - SE5->E5_VRETPIS
						nCofins := SE2->E2_COFINS - SE5->E5_VRETCOF
						nCsll   := SE2->E2_CSLL - SE5->E5_VRETCSL
						lBxParc := .T.
						
						If lCC10925
							nVlrCmpCrt := SE5->E5_VALOR
						EndIf
					EndIf
					
					RestArea(aAreaE2)
				Else
					nPis    := SE2->E2_PIS * nFatorRed
					nCofins := SE2->E2_COFINS * nFatorRed
					nCsll   := SE2->E2_CSLL * nFatorRed
				Endif
			Endif
		EndIf
	EndIf
	
	// Se for fatura, a base de impostos deve considerar o somatorio dos outros impostos
	// para verificacao do valor acima de 5000.
	// Isto já eh feito normalmente para os titulos nao gerados por fatura
	If lImpInFat
		//Para faturas, substituir o valor a ser considerado, era do saldo e passa a ser pela base dos impostos (PCC), para evitar que o calculo
		//do valor minimo utilize a soma de titulos que compoe a fatura e que nao retem o PCC.
		nBaseRet := nValTit - nTotAbat + nAcresc - nDecresc + nValOutImp + aDadosImp[4] - aDadosImp[5]
	Else
		nBaseret := nValTit 
	Endif
	
	//Guardo Valores calculados para o titulo (utilizados para FK3)
	nPisCalc := 0
	nCofCalc := 0
	nCslCalc := 0
	nIrfCalc := 0
	
	//Nao retem Pis,Cofins,CSLL
	If cModRetPis == "3"  //Nao retem PIS
		nPis 	:= 0
		nCofins := 0
		nCsll 	:= 0
		nIrrf 	:= 0
		nISS	:= 0
	Else
		//Guardo Valores calculados para o titulo (utilizados para FK3)
		nPisCalc := nPis
		nCofCalc := nCofins
		nCslCalc := nCsll
		nIrfCalc := nIrrf
		
		//Calculo do Sistema
		If cModRetPis $ "1|2"
			If dDatabase < dLastPCC .Or. lEmpPub
				nBasRetTmp += nValTit
				If !lEmpPub .And. ((aDadosRet[1] + nTotTitSe2 + nBaseRet <= nVlMinImp .and. lAplVlMin ) .or. SE2->E2_SALDO == 0 .or. !lBordAtu)
					nTotTitSE2 += nValTit
					nTotPisSE2 += nPis
					nTotCofSE2 += nCofins
					nTotCslSE2 += nCsll
					nTotIrfSE2 += nIrrf
					nPis 	:= 0
					nCofins := 0
					nCsll	:= 0
					nIrrf	:= 0
				ElseIf !lBxParc .and. nTotPisSE2 != 0 .and. nTotCofSE2 != 0 .and. nTotCslSE2 != 0
					If lEmpPub .And. lAplMinP .And. lIRPFBaixa .And. nPis+nTotPisSE2+nCoFins+nTotCofSE2+nCsll+nTotCslSE2+nIrrf+nTotIrfSE2 < nVlMPub
						nTotTitSE2 += nValTit
						nTotPisSE2 += nPis
						nTotCofSE2 += nCofins
						nTotCslSE2 += nCsll
						nTotIrfSE2 += nIrrf
						nPis	   := 0
						nCofins	   := 0
						nCsll	   := 0
						nIrrf	   := 0
					Else
						nTotTitSE2  += nValTit
						nPis		+= aDadosRet[2] + nTotPisSE2
						nCofins 	+= aDadosRet[3] + nTotCofSE2
						nCsll 	    += aDadosRet[4] + nTotCslSE2
						nIrrf 	    += aDadosRet[5] + nTotIrfSE2
					EndIf
				ElseIf !lBxParc .and. nTotPisSE2 == 0 .and. nTotCofSE2 == 0 .and. nTotCslSE2 == 0
					nTotTitSE2 += nValTit
					nPis	   := aDadosRet[2] + nPis
					nCofins	   := aDadosRet[3] + nCofins
					nCsll	   := aDadosRet[4] + nCsll
					
					If lEmpPub .And. lAplMinP .And. lIRPFBaixa .And. nOldPis == 0 .and. nPis+nCoFins+nCsll+(nIrrf+aDadosRet[5]) < nVlMPub .and. !(aDadosRet[1]>0 .and. aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5]==0)
						nTotPisSE2 += nPis
						nTotCofSE2 += nCofins
						nTotCslSE2 += nCsll
						nTotIrfSE2 += nIrrf
						nPis	   := 0
						nCofins	   := 0
						nCsll	   := 0
						nIrrf	   := 0
					EndIf
				Endif			
				
				nPisCalc := nPis
				nCofCalc := nCofins
				nCslCalc := nCsll
				nIrfCalc := nIrrf			
			Else
				If __lPCCBaixa
					nSalTit := salRefPag(SE2->(E2_FORNECE+E2_LOJA), __lPccMR, __lIrfMR, .F., __lIssMR, .F., .F., .F.)
					nSalTit	+= F080JuMuDe()
					aTitCalc := {}
					
					If SE2->E2_MOEDA > 1
						nSalTit := xMoeda(nSalTit,SE2->E2_MOEDA,1,dBaixa,3,SE2->E2_TXMOEDA)
					EndIf
					
					//Motor de Retenções
					nSalTit += nImpMotor
					cFil	:= SE2->E2_FILIAL
					cTIPO	:= SE2->E2_TIPO
					cLoja	:= SE2->E2_LOJA
					cCodigo	:= SE2->E2_FORNECE
					nVlInss := SE2->E2_INSS
					
					If !__lIssMR
						If lCalcIssBx
							nVlIss := 	(SE2->E2_ISS - SE2->E2_VRETISS)
						Else
							nVlIss := 	SE2->E2_ISS
						EndIf
					EndIf
					
					If !__lIrfMR
						If (!lIRPFBaixa .Or. SE2->E2_PRETIRF == "2")
							nVlIrf := SE2->E2_IRRF
						ElseIf lIRPFBaixa
						    If SE2->E2_PRETIRF == '4' .and. SE2->E2_VRETIRF > 0
						      nVlIrf := SE2->E2_VRETIRF
						    Else 
								nVlIrf := 	FCalcIRBx(0,SA2->A2_TIPO,dDataBord,dDataBord)
							Endif
							
							If SE2->E2_PRETIRF == '4' 
								nPosIrrf := aScan(aRetIRRF,{ |x,y| x[1] == aRecnosSE2[nLoop,RECNOSE2] } )
								If SA2->A2_MINIRF == "2" .And. nPosIrrf > 0
									lRetMinIR := aRetIRRF[nPosIrrf][2] > 0 .And. aRetIRRF[nPosIrrf][2] < nMinIrrf 
								EndIf
								If SA2->A2_MINIRF == "1" .Or. lRetMinIR
									nSalTit += nVlIrf
								EndIf
							Endif
						EndIf
					EndIf

					//Soma na base de cálculo o valor da baixa entre carteira que não reteve o PCC
					If lCC10925 .And. ( nSalTit + nVlrCmpCrt <= SE2->E2_VALOR + nValOutImp )
						nSalTit += nVlrCmpCrt
					EndIf
					
					aPcc	:= newMinPcc(dDataBase,nSalTit,SE2->E2_NATUREZ,"P",SE2->E2_FORNECE+SE2->E2_LOJA,nVlIss,nVlInss,nVlIrf,Iif(cModRetPis = "2",.F., .T.),.T.)

					nPis 	:= aPCC[2]
					nCofins := aPCC[3]
					nCsll 	:= aPCC[4]

					If len(aPCC) > 4
					   aTitCalc := aPCC[5]
					Endif

					nValTit := nBasRetTmp := nSalTit
				Else
					nPis := 0
					nCofins := 0
					nCsll := 0
				EndIf

				If lIRPFBaixa .And. dDataBase > dLastPCC
					If !__lIrfMR .And. SE2->E2_PRETIRF != "2" 
						nIrrf	:= FCalcIRBx(0,SA2->A2_TIPO,dDatabase,dDataBase)
					EndIf
				ElseIf dDataBase > dLastPCC
					nIrrf	:= 0
				Endif
			EndIf
		EndIf
	Endif
	
	//Zero a base do imposto
	nBaseImp := 0
	nBaseRet := 0

	//Base dos impostos para FK3/FK4
	nBaseImpC := nValTit
	nPisBaseC := If(nPisBaseC > 0, nPisBaseC, nBaseImpC)
	nCofBaseC := If(nCofBaseC > 0, nCofBaseC, nBaseImpC)
	nCslBaseC := If(nCslBaseC > 0, nCslBaseC, nBaseImpC)
	
	nBaseImpR := nBasRetTmp
	nPisBaseR := If(nPisBaseR > 0, nPisBaseR, nBasRetTmp)
	nCofBaseR := If(nCofBaseR > 0, nCofBaseR, nBasRetTmp)
	nCslBaseR := If(nCslBaseR > 0, nCslBaseR, nBasRetTmp)
	
	If lEmpPub
		nIrfBaseR := If(Type("nIrfBaseR") != "N",0,nBasRetTmp )
		nIrfBaseC := If(Type("nIrfBaseC") != "N",0,nValTit)
	EndIf

	If dDatabase < dLastPCC .Or. lEmpPub
		//Somo impostos caso tenha diferença
		If nDiferImp < 0 .And. cNccRet == "2"
			nPis += nRestPis
			nCofins += nRestCof
			nCsll += nRestCsl
			nIrrf += nRestIrf
			nDiferImp := 0
		EndIf

		If cNCCRet == "2" .And. !lAltBxVal .And. nPis+nCofins+nCsll+nIrrf > 0
			If aDadosImp[1] <> aTitsSE5[2] .AND. (aTitsSE5[2] <> 0 ) // SOMENTE SE PENDENTE DE RETENCAO
				nPis += aDadosImp[1]
			EndIf
			If aDadosImp[2] <> aTitsSE5[3] .AND. (aTitsSE5[3] <> 0 )
				nCofins += aDadosImp[2]
			EndIf
			If aDadosImp[3] <> aTitsSE5[4] .AND. (aTitsSE5[4] <> 0 )
				nCsll += aDadosImp[3]
			EndIf
		Endif

		// tratamento que substitui o calculo de PCC quando houve retenção com proporcionalização
		If SE2->E2_VALOR> SE2->E2_SALDO .AND. (!lValLiq .and. !lBxParc) .AND. (SE2->E2_PRETPIS $"3|7" .OR. SE2->E2_PRETCOF $"3|7" .OR. SE2->E2_PRETCSL $"3|7");
				.and. SE2->E2_BASEPIS> nVlMinImp .and. lAltBxVal.and.cNCCRet == "2"
			 nPis:= SE2->E2_PIS + aDadosImp[1]
			 nCofins:= SE2->E2_COFINS + aDadosImp[2]
			 nCsll := SE2->E2_CSLL + aDadosImp[3]

		EndIf
	EndIf
	
	If lEmpPub .And. lAplMinP .And. lIrpfBaixa
		If aDadosRet[1]>0 .And. nLoop == 1
			nPis += aPubRet[1]-aPubRet[4]
			nCofins += aPubRet[2]-aPubRet[5]
			nCsll += aPubRet[3]-aPubRet[6]
		EndIf
		
		If (nPis+nCofins+nCsll+nIrrf) == 0  .And. (nTotPisSE2+nTotCofSE2+nTotCslSE2+nTotIrfSE2) > nVlMPub
			nPis 	:= nTotPisSE2
			nCofins :=  nTotCofSE2
			nCsll := nTotCslSE2
			nIrrf := nTotIrfSE2
		EndIF
		
		If (nPis+nCofins+nCsll+nIrrf) < nVlMPub .And. !(aDadosRet[1]>0 .and. aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5]==0) .And. !lAtMinP
			nPis := nCofins := nCsll := nIrrf := 0
		EndIf
	EndIf
	
	If (nPis+nCofins+nCsll+nIrrf) > 0
		If lEmpPub .And. lAplMinP .And. lIrpfBaixa
			lAtMinP := .T.
		EndIf
		
		nValorPg := SE2->E2_SALDO - nPis - nCofins - nCsll - nIrrf
		
		//Baixa via cnab de bordero onde nao houve a retencao
		If SE2->E2_PRETPIS == '1' .And. SE2->E2_SALDO == 0 .And. !(EMPTY(SE2->E2_NUMBOR)) .And. SE2->(E2_PIS+E2_COFINS+E2_CSLL+E2_ISS) > 0
			nValorPg := nValTit - nPis - nCofins - nCsll - nIrrf
		Endif
		
		lForcaDesc := nValorPg >= 0 .And. !lJurMulDes .And. Iif (SE2->E2_DECRESC > 0, ( nValorPg - SE2->E2_DECRESC ) < 0,.T.)//Força a verificação do desconto criado diretamente no título
		
		If (nValorPg < 0) .Or. lForcaDesc
			If lForcaDesc
				nDecresc := SE2->E2_DECRESC
				nValorPg += ( nPis + nCofins + nCsll + nIrrf ) - nDecresc
			Else
				nValorPg += nPis + nCofins + nCsll + nIrrf
			EndIf
			
			nTotARet := nPis + nCofins + nCsll + nIrrf
			nDiferImp := nValorPg - nTotARet
			
			If nDiferImp < 0
				cFil	:= SE2->E2_FILIAL
				cTIPO	:= SE2->E2_TIPO
				cLoja	:= SE2->E2_LOJA
				cCodigo	:= SE2->E2_FORNECE

				aOutImp := {}
				aAdd(aOutImp, {"PIS", nPis })
				aAdd(aOutImp, {"COF", nCofins })
				aAdd(aOutImp, {"CSL", nCsll })

				If lIrpfBaixa
					aAdd(aOutImp, {"IRF", nIrrf })
				EndIf

				If lCalcIssBx.And. nIss == 0
					aAdd(aOutImp, {"ISS", (SE2->E2_ISS - SE2->E2_VRETISS) })
				EndIf

				aDadosPar := verVrAR(nValorPg, aOutImp )
				nPis	:= aDadosPar[1]
				nCofins := aDadosPar[2]
				nCsll	:= aDadosPar[3]
				lverVrAR := .F.

				//Guardo a diferença para reter no proximo titulo
				nRestPis := nCalcPis - nPis
				nRestCof := nCalcCof - nCofins
				nRestCsl := nCalcCsl - nCsll
				nRestIrf := nCalcIrf - nIrrf
			Endif
		EndIf
	EndIf
	
	//Gero NCC com a diferenca
	If cNccRet == "1" .AND. nDiferImp < 0
		aAreaTit := SE2->(GetArea())
		ADupCredRt(Abs(nDiferImp),"501",SE2->E2_MOEDA,.T.)
		RestArea(aAreaTit)
	Endif
	
	//Ponto de entrada para tratamentos diferenciados dos valores dos impostos
	If lF241IMP
		ExecBlock("F241IMP",.F.,.F.)
	Endif
	
	//Gero o ID do documento - Titulo a Pagar
	cDocSE2   := xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
	cDocKey   := FINGRVFK7("SE2",cDocSE2)
	aImpostos := {} 
	aCodRet   := getCodRet()
	
	aadd(aImpostos, {"PIS", nPisCalc, cNatPis,  "", nPis,    nPisBaseC, nPisBaseR, "", SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[1]})
	aadd(aImpostos, {"COF", nCofCalc, cNatCof,  "", nCofins, nCofBaseC, nCofBaseR, "", SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[2]})
	aadd(aImpostos, {"CSL", nCslCalc, cNatCsll, "", nCsll,   nCslBaseC, nCslBaseR, "", SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[3]})

	nPisBaseC := nCofBaseC := nCslBaseC := 0
	nPisBaseR := nCofBaseR := nCslBaseR := 0
	
	//Houve retencao de PCC neste titulo
	If (nPis+nCofins+nCsll+nIrrf) > 0
		cCamposE5 := ""

		oModelMov:Activate()
		oSubFKA  := oModelMov:GetModel("FKADETAIL")
		oSubFK2  := oModelMov:GetModel("FK2DETAIL")
		oSubFK3  := oModelMov:GetModel("FK3DETAIL")
		oSubFK4  := oModelMov:GetModel("FK4DETAIL")
		oSubFK6  := oModelMov:GetModel("FK6DETAIL")

		//Gero baixa parcial no titulo pai para PCC
		If (nPis+nCofins+nCsll) > 0
			cSequencia := FaNxtSeqBx("SE2")  // Sequencia da baixa do adiantamento + 1
			
			cCamposE5 := " { "
			cCamposE5 += " {'E5_PREFIXO'	, '" + SE2->E2_PREFIXO		+ "'}"
			cCamposE5 += ",{'E5_NUMERO'		, '" + SE2->E2_NUM			+ "'}"
			cCamposE5 += ",{'E5_PARCELA'	, '" + SE2->E2_PARCELA		+ "'}"
			cCamposE5 += ",{'E5_CLIFOR'		, '" + SE2->E2_FORNECE		+ "'}"
			cCamposE5 += ",{'E5_LOJA'		, '" + SE2->E2_LOJA			+ "'}"
			cCamposE5 += ",{'E5_BENEF'		, '" + SE2->E2_NOMFOR		+ "'}"
			cCamposE5 += ",{'E5_FORNECE'	, '" + SE2->E2_FORNECE		+ "'}"
			cCamposE5 += ",{'E5_TIPO'		, '" + SE2->E2_TIPO			+ "'}"
			cCamposE5 += ",{'E5_DTDIGIT'	, STOD('" + DTOS(dDataBase) + "')}"
			cCamposE5 += ",{'E5_DTDISPO'	, STOD('" + DTOS(dDataBase) + "')}"
			cCamposE5 += ",{'E5_DOCUMEN'	, '" + cNumBor				+ "'}"
			cCamposE5 += ",{'E5_BASEIRF'	, "  +cValToChar(nBaseImpR) + "}"
			cCamposE5 += ",{'E5_VRETPIS'	, "  +cValToChar(nPis)		+ "}"
			cCamposE5 += ",{'E5_VRETCOF'	, "  +cValToChar(nCofins)	+ "}"
			cCamposE5 += ",{'E5_VRETCSL'	, "  +cValToChar(nCsll)		+ "}"
			
			If lEmpPub .and. nIrrf > 0
				cCamposE5 += ",{'E5_VRETIRF'	, "  +cValToChar(nIrrf)		+ "}"
			EndIf
			
			cCamposE5 += ",{'E5_PRETPIS'	, '4'}"
			cCamposE5 += ",{'E5_PRETCOF'	, '4'}"
			cCamposE5 += ",{'E5_PRETCSL'	, '4'}"
			
			If lEmpPub .and. nIrrf > 0
				cCamposE5 += ",{'E5_PRETIRF'	, '4'}"
			EndIf
			
			cCamposE5 += "}"

			//Dados do Processo - Define a chave da FK2 no IDORIG
			If !oSubFKA:IsEmpty()
				oSubFKA:AddLine()
			Endif

			cIdFK2 := FWUUIDV4()
			oSubFKA:SetValue( "FKA_IDORIG", cIdFK2 )
			oSubFKA:SetValue( "FKA_TABORI", "FK2" )

			//Informacoes da baixa
			oSubFK2:SetValue( "FK2_IDDOC"	, cDocKey					)
			oSubFK2:SetValue( "FK2_DATA"	, dDataBase 				)
			oSubFK2:SetValue( "FK2_VALOR"	, nPis + nCofins + nCsll	)
			oSubFK2:SetValue( "FK2_VLMOE2"	, nPis + nCofins + nCsll	)
			oSubFK2:SetValue( "FK2_NATURE"	, SE2->E2_NATUREZ	 		)
			oSubFK2:SetValue( "FK2_RECPAG"	, "P" 						)
			oSubFK2:SetValue( "FK2_TPDOC"	, "BA" 						)
			oSubFK2:SetValue( "FK2_ORIGEM"  , cOrigem 					)
			oSubFK2:SetValue( "FK2_HISTOR"	, STR0122 					) //Baixa Ger.Impostos-Bordero
			oSubFK2:SetValue( "FK2_MOTBX"	, "PCC"  					)
			oSubFK2:SetValue( "FK2_SEQ"		, cSequencia  				)
			oSubFK2:SetValue( "FK2_FILORI"	, SE2->E2_FILORIG	 		)
			oSubFK2:SetValue( "FK2_MOEDA"   , StrZero(SE2->E2_MOEDA,2)	)
			oSubFK2:SetValue( "FK2_DOC"     , cNumBor 					)
			
			If (nTotal > 0) .and. !lUsaFlag
				oSubFK2:SetValue( "FK2_LA"	, "S")
			EndIf

			For nX := 1 to Len(aImpostos)

				//Houve calculo de impostos PCC
				If aImpostos[nX,2] > 0
					cIdFk3 := FINFKSID('FK3', 'FK3_IDFK3')

					//Houve retencao de impostos PCC
					If aImpostos[nX][5] > 0
						cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
						aImpostos[nX,4] := cIdFK4
               		Endif

					If !oSubFK3:IsEmpty()
						//Inclui a quantidade de linhas necessárias
						oSubFK3:AddLine()

						//Vai para linha criada
						oSubFK3:GoLine( oSubFK3:Length() )
					Endif

					//---------------------------------------------
					// Grava Imposto Calculado
					//---------------------------------------------
					oSubFK3:SetValue( "FK3_IDFK3" , cIdFK3			)
					oSubFK3:SetValue( "FK3_DATA"  , dDataBase		)
					oSubFK3:SetValue( "FK3_ORIGEM", cOrigem			)
					oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nX][1]	)
					oSubFK3:SetValue( "FK3_RECPAG", "P"				)
					oSubFK3:SetValue( "FK3_MOEDA" , "01"			)
					oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nX][2]	)
					oSubFK3:LoadValue("FK3_NATURE", aImpostos[nX][3]	)
					oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG )
					oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nX][6]	)
					oSubFK3:SetValue( "FK3_IDORIG", cIdFK2			)
					oSubFK3:SetValue( "FK3_TABORI", "FK2"			)
                    oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nX,4]	)

					If __lMotorRet
						oSubFK3:SetValue( "FK3_CODFKM", aImpostos[nX,8] )
						oSubFK3:SetValue( "FK3_CLIFOR", aImpostos[nX,9] )
						oSubFK3:SetValue( "FK3_LOJA"  , aImpostos[nX,10])
						oSubFK3:SetValue( "FK3_CGC"   , aImpostos[nX,11] )
						oSubFK3:SetValue( "FK3_RAICGC", Substr(aImpostos[nX,11], 1, 8) )
					Endif

					If __lFKCodRet 
						oSubFK3:SetValue( "FK3_CODRET" , aImpostos[nx,12] )
					EndIf

					//---------------------------------------------
					// Grava Imposto Retido
					//---------------------------------------------
					If aImpostos[nX][5] > 0   //Houve retencao
						If !oSubFK4:IsEmpty()
							//Inclui a quantidade de linhas necessárias
							oSubFK4:AddLine()

							//Vai para linha criada
							oSubFK4:GoLine( oSubFK4:Length() )
						Endif

						oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nx,4]	)
						oSubFK4:SetValue( "FK4_DATA"  , dDataBase		)
						oSubFK4:SetValue( "FK4_ORIGEM", cOrigem			)
						oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nx,1]	)
						oSubFK4:SetValue( "FK4_RECPAG", "P"				)
						oSubFK4:SetValue( "FK4_MOEDA" , "01"			)
						oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nX,5]	)
						oSubFK4:LoadValue("FK4_NATURE", aImpostos[nX,3]	)
						oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
						oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX][7]	)

						If __lMotorRet
							oSubFK4:SetValue( "FK4_CODFKM", aImpostos[nX,8] )
							oSubFK4:SetValue( "FK4_CLIFOR", aImpostos[nX,9] )
							oSubFK4:SetValue( "FK4_LOJA"  , aImpostos[nX,10] )
							oSubFK4:SetValue( "FK4_CGC"   , aImpostos[nX,11] )
							oSubFK4:SetValue( "FK4_RAICGC", Substr(aImpostos[nX,11], 1, 8) )
						Endif

						If __lFKCodRet
							oSubFK4:SetValue( "FK4_CODRET" , aImpostos[nx,12] )
						EndIf
						nBasRetTmp := 0
					Endif
				Endif
			Next
			
			For nx:= 1 to len(aTitCalc)
				FINGFK3BOR(2,aTitCalc[nx,1],aTitCalc[nx,2],aImpostos,.F.)
			Next
		ElseIf !Empty(SE2->E2_NUMBOR) .and. !__lPccMR //não houve retencao de PCC neste titulo e o mesmo pertence ao bordero em processamento
			FINGFK3BOR(1,"FK7",cDocKey, aImpostos, __lMotorRet, , cDocSE2)
		EndIf
		
		oModelMov:SetValue( "MASTER", "E5_GRV", .T. )   //Informa se vai gravar SE5 ou não
		oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
		oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Informa que a inclusão será feita com um novo número de processo
		
		If oModelMov:VldData()
			oModelMov:CommitData()
			SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
		    nRecSE5 := SE5->(Recno())
			nRecFK2 := FK2->(Recno())
		Else
		    lRet := .F.
		    cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
		    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
			cLog += cValToChar(oModelMov:GetErrorMessage()[6])
	    	Help( ,,"F241MIPCC",,cLog, 1, 0 )
			DisarmTransaction()
		Endif
		
		oModelMov:DeActivate()
		
		If !lRet
			oModelMov:Destroy()
			oModelMov := Nil
			Break
		Endif

		//Ponto de entrada para gravacao de dados complementares no titulo que reteve os impostos - Gesco
		If lF241Inc5
			ExecBlock("F241INC5",.F.,.F.)
		Endif

		If lIRPFBaixa .And. dDataBase > dLastPCC .and. SE2->E2_PRETIRF <> "4"
			F241BxIRPF(nIrrf, lContabil, aRecnosSE2[nLoop,RECNOSE2], @nTotal, @nHdlprv, lUsaFlag, @aFlagCTB)
			nIrrf := 0
			nIrfCalc := 0
		ElseIf lIRPFBaixa .And. dDataBase > dLastPCC .and. SE2->E2_PRETIRF == "4"
			nIrrf := 0
		Endif

		cPrefOri  := SE2->E2_PREFIXO
		cNumOri   := SE2->E2_NUM
		cParcOri  := SE2->E2_PARCELA
		cTipoOri  := SE2->E2_TIPO
		cCfOri    := SE2->E2_FORNECE
		cLojaOri  := SE2->E2_LOJA
		nIss 	  := 0
		
		//Somente gravo SFQ caso retenha impostos de outros titulos SE2
		If nTotPisSE2+nTotCofSE2+nTotCslSE2+nTotIrfSE2 > 0
			//Exclui a Marca de "pendente recolhimento" dos demais registros
			aRecSFQ := aClone( aRecnosSE2 )

			//Emissaos
			For nX := 1 to Len( aRecSFQ )
				If aRecSFQ[ nX ][2]

					SE2->( dbGoto( aRecSFQ[ nX ][1] ) )

					RecLock( "SE2", .F. )

					If SE2->E2_PRETPIS <> "4"
						SE2->E2_PRETPIS := "2"
						SE2->E2_PRETCOF := "2"
						SE2->E2_PRETCSL := "2"
					EndIf

					SE2->( MsUnlock() )

					//Gravacao da SFQ
					If aRecnosSE2[ nLoop ][ RECNOSE2 ] <> aRecSFQ[ nX ][1]

						//Gero o ID do documento - Titulo a Pagar
						cDocSE2 := xFilial("SE2") 	+ "|"
						cDocSE2 += SE2->E2_PREFIXO 	+ "|"
						cDocSE2 += SE2->E2_NUM 		+ "|"
						cDocSE2 += SE2->E2_PARCELA 	+ "|"
						cDocSE2 += SE2->E2_TIPO 	+ "|"
						cDocSE2 += SE2->E2_FORNECE 	+ "|"
						cDocSE2 += SE2->E2_LOJA

						cDocKey := FINGRVFK7("SE2",cDocSE2)

						FINGFK3BOR(2 , "FK7",cDocKey,aImpostos)
						If !lF241aRec .or. (lF241aRec .and. cCli == aRecSFQ[ nX ][10] .and. cCli == aRecnosSE2[ nLoop ][ CAMPOUSER ])
							dbSelectArea("SFQ")
							RecLock("SFQ",.T.)
							SFQ->FQ_FILIAL  := xFilial("SFQ")
							SFQ->FQ_ENTORI  := "SE2"
							SFQ->FQ_PREFORI := cPrefOri
							SFQ->FQ_NUMORI  := cNumOri
							SFQ->FQ_PARCORI := cParcOri
							SFQ->FQ_TIPOORI := cTipoOri
							SFQ->FQ_CFORI   := cCfOri
							SFQ->FQ_LOJAORI := cLojaOri

							SFQ->FQ_ENTDES  := "SE2"
							SFQ->FQ_PREFDES := SE2->E2_PREFIXO
							SFQ->FQ_NUMDES  := SE2->E2_NUM
							SFQ->FQ_PARCDES := SE2->E2_PARCELA
							SFQ->FQ_TIPODES := SE2->E2_TIPO
							SFQ->FQ_CFDES   := SE2->E2_FORNECE
							SFQ->FQ_LOJADES := SE2->E2_LOJA
							SFQ->FQ_FILDES	:= SE2->E2_FILIAL

						EndIf
						MsUnlock()
					Endif
				EndIf
			Next nX

			//Zero os totalizadores de pendencia de retencao quando gravo a retencao
			nTotPisSE2	:= 0
			nTotCofSE2	:= 0
			nTotCslSE2	:= 0
			nTotIrfSE2	:= 0

		EndIf
		
		//Somente gravo SFQ caso retenha impostos de outros titulos SE5
		If aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] > 0
			//Baixas
			For nY := 1 to Len( aRecnosSE5 )

				SE5->( dbGoto( aRecnosSE5[ nY ] ) )
				// Esse trecho devera ser excluido quando o tratamento dos impostos estiaver sendo realizado
				// pelo novos metodos de gravacao de SE5
				RecLock( "SE5", .F. )

					SE5->E5_PRETPIS := "2"
					SE5->E5_PRETCOF := "2"
					SE5->E5_PRETCSL := "2"

				SE5->( MsUnlock() )

				//Gravacao da SFQ
				If aRecnosSE2[ nLoop ][ RECNOSE2 ] <> aRecnosSE5[ nY ]

					FINGFK3BOR(2, SE5->E5_TABORI ,SE5->E5_IDORIG,aImpostos)

					dbSelectArea("SFQ")
					RecLock("SFQ",.T.)
					SFQ->FQ_FILIAL  := xFilial("SFQ")
					SFQ->FQ_ENTORI  := "SE5"
					SFQ->FQ_PREFORI := cPrefOri
					SFQ->FQ_NUMORI  := cNumOri
					SFQ->FQ_PARCORI := cParcOri
					SFQ->FQ_TIPOORI := cTipoOri
					SFQ->FQ_CFORI   := cCfOri
					SFQ->FQ_LOJAORI := cLojaOri

					SFQ->FQ_ENTDES  := "SE5"
					SFQ->FQ_PREFDES := SE5->E5_PREFIXO
					SFQ->FQ_NUMDES  := SE5->E5_NUMERO
					SFQ->FQ_PARCDES := SE5->E5_PARCELA
					SFQ->FQ_TIPODES := SE5->E5_TIPO
					SFQ->FQ_CFDES   := SE5->E5_CLIFOR
					SFQ->FQ_LOJADES := SE5->E5_LOJA
					SFQ->FQ_SEQDES  := SE5->E5_SEQ

					//Grava a filial de destino caso o campo exista
					SFQ->FQ_FILDES := SE5->E5_FILIAL

					MsUnlock()

					aDadosRet[1]:=0
					aDadosRet[2]:=0
					aDadosRet[3]:=0
					aDadosRet[4]:=0
					aDadosRet[5]:=0
				Endif
			Next nY
		EndIf
		
		//Ponto de entrada para gravacao de dados complementares no titulo que reteve os impostos
		If lF241Inc
			ExecBlock("F241INC",.F.,.F.)
		Endif
		
		nOldPis := SE2->E2_PIS
		nOldCof := SE2->E2_COFINS
		nOldCsl := SE2->E2_CSLL
		nOldIrf := SE2->E2_IRRF
		nValImp := nPis + nCofins + nCsll + nIrrf + nIss
		
		If SE2->E2_MOEDA > 1
			nValImp := xMoeda(nValImp,1,SE2->E2_MOEDA,dBaixa,3,1,SE2->E2_TXMOEDA)
		EndIf
		
		If lResta1
			lRestaUM := ExecBlock("RestaUM",.F.,.F.)
		Endif
		
		If lRestaUM .And. (nPis+nCofins+nCsll) > 0 .And. (SE2->E2_SALDO - nValImp) == 0
			If nPis > 0
				nPis -= 0.01
			ElseIf nCofins > 0
				nCofins -= 0.01
			Else
				nCsll -= 0.01
			EndIf
			
			nValImp -= 0.01
		Endif
	  	
		RecLock("SE2")
		Replace E2_SALDO	With E2_SALDO - nValImp
		Replace E2_BAIXA	With dDataBase
		Replace E2_VALLIQ	With nValImp
		Replace E2_VRETPIS	With E2_VRETPIS + nPis
		Replace E2_VRETCOF	With E2_VRETCOF + nCofins
		Replace E2_VRETCSL	With E2_VRETCSL + nCsll
		Replace E2_VRETISS	With E2_VRETISS + nIss

		If SE2->(E2_VRETPIS + E2_VRETCOF + E2_VRETCSL) > 0
			Replace E2_PRETPIS	With "4"
			Replace E2_PRETCOF	With "4"
			Replace E2_PRETCSL	With "4"
		Endif
		
		If E2_VRETIRF > 0
			Replace E2_PRETIRF	With "4"
		EndIf
		
		cGeraDirf := If(Empty(SE2->E2_CODRET), "2", "1")
		
		MsUnlock()
		
		//Ponto de entrada para gravacao de dados complementares no titulo que reteve os impostos - Gesco
		If lF241Inc2
			ExecBlock("F241INC2",.F.,.F.)
		Endif		
		
		//Reposicionar na baixa do titulo
		SE5->(DbGoTo(nRecSE5))
		
		//Contabilizacao da baixa ref valores Impostos
		If lContabil
			nValTot += nPis+nCofins+nCsll
			
			If lIRPFBaixa
       			nValTot	+= nIrrf
			EndIf
			
			If lCalcIssBx
		 		nValTot	+= nIss
			EndIf
			
			//Contabilizacao dos impostos
			If VerPadrao("530") .and. nHdlPrv <= 0
				nHdlPrv := HeadProva(cLote, "FINA241" /*cPrograma*/, Substr(cUsuario, 7, 6), @cArquivo,,__aCTBPrv)
			EndIf
			
			If nHdlPrv > 0
				//Movimento de baixas dos impostos do pcc
				If lUsaFlag .And. nRecSE5 > 0 .And. (nPis+nCofins+nCsll) > 0
					Aadd(aFlagCTB, {"E5_LA" , "S", "SE5", nRecSE5, 0, 0, 0})
					aAdd(aFlagCTB, {"FK2_LA", "S", "FK2", nRecFK2, 0, 0, 0})
				EndIf

				//Prepara Lancamento Contabil
				nTotal += DetProva(nHdlPrv, "530" /*cPadrao*/, "FINA241" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/,;
				         			/*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, __aCTBPrv)
			Endif		
		Endif
		
		If nRecSE5 > 0 .And. (nPis+nCofins+nCsll) > 0 .And. nTotal > 0 .And. !lUsaFlag .And. Empty(SE5->E5_LA)
			//Gero FLAG caso houver baixa parcial no titulo pai para PCC
			SE5->(dbGoto(nRecSE5))
			Reclock("SE5")
			SE5->E5_LA := "S"
			SE5->(MsUnlock())
			
			//Posiciona a FK5 com base no IDORIG da SE5 posicionada
			FK2->(dbGoto(nRecFK2))
			Reclock("FK2", .F.)
			FK2->FK2_LA := 'S'
			FK2->(MsUnlock())
		EndIf

	  	RecLock("SE2")
		Replace E2_PIS		With nOldPis
		Replace E2_COFINS	With nOldCof
		Replace E2_CSLL		With nOldCsl
		Replace E2_IRRF		With nOldIrf
		MsUnlock()

		// Grava lançamento da baixa parcial do titulo original ref. impostos
		// como SE2 e SE5 estao posicionados faz PcoDetLan p/ 2 eventos PCO
    	PCODetLan("000023","02","FINA241")   //referente baixa parcial SE5
    	PCODetLan("000023","01","FINA241")   //referente titulo original

		//Gero titulos a pagar dos impostos
		DbSelectArea("SA2")
		DbSetOrder(1)
		FGrvImpPcc(@nPis,@nCofins,@nCsll,aRecnosSE2[ nLoop ][ RECNOSE2 ],.F.,.T.," ","FINA241",,cGeraDirf,nIrrf,nIss,,,,,,,,,,IIF(__oRatIRF <> Nil,__oRatIRF:aRatIRF,Nil))
		
		DbSelectArea("SA2")
		DbSetOrder(1)
		DbSeek(xFilial("SA2")+(SE2->E2_FORNECE+SE2->E2_LOJA))
	ElseIf !Empty(SE2->E2_NUMBOR) .and. !__lPccMR //NÃO Houve retencao de PCC neste titulo E o mesmo pertence ao bordero em processamento		
		FINGFK3BOR(1,"FK7",cDocKey,aImpostos, __lMotorRet, , cDocSE2)
	EndIf
Next nLoop

cFilAnt := cFilBkp
oModelMov:Destroy()
oModelMov := Nil

If lTodasFil .And. !Empty(cFilFwSE2)
	cFilAnt := cFilAtu
	RestArea(aArea)
EndIf

RestArea(aAreaSE2)
Return .T.


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241CanImp
Cancela os impostos gerados pelo bordero

@author Mauricio Pequim Jr

@since 28/01/05
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241CanImp(nTotal,nHdlPrv,cArquivo,lContabil,lUsaFlag,aFlagCTB,cNumBord)

Local aArea 	:= GetArea()
Local lCancelou	:= .F.
Local aRecSE2	:= {}
Local nValBaix	:= 0
Local nPis		:= 0
Local nCofins	:= 0
Local nCsll		:= 0
Local nOldPis	:= 0
Local nOldCof	:= 0
Local nOldCsl	:= 0
Local nSavRec	:= SE2->(RECNO())
Local cForUniao := ""
Local cLojUniao := ""
Local cChaveImp := ""
Local cNatPis 	:= GetMv("MV_PISNAT",.F.,"PIS")
Local cNatCof	:= GetMv("MV_COFINS",.F.,"COF")
Local cNatCsl	:= GetMv("MV_CSLL",.F.,"CSL")
Local nX		:= 0
Local cNaturs 	:= ""
Local lCtblizou := .T.
Local cItemTaxa := ""
Local lTitPai 	:= .T.
Local cTitPai	:= If(lTitPai,Pad(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),TamSx3("E2_TITPAI")[1]),"")
Local lConFil	:= SuperGetMV("MV_CONSFIL",.F.,.F.)
Local nCont		:= 0
Local cFilAtu	:= FWGETCODFILIAL
Local aFil10925	:= {}
Local cLojaImp	:= PadR( "00", TamSX3( "A2_LOJA" )[1], "0" )
Local cSequen	:= Space(TamSX3( "FQ_SEQORI" )[1])
Local cPret		:= ""
Local cAglutFil := SuperGetMV("MV_PCCAGFL",,"1")
Local aAreaSM0  := {}
Local aAreaSA2  := {}
Local cCGCSM0   := ""
Local cForTipo  := ""
Local cCGCFor   := ""
Local cEmpAtu   := ""
Local lF241Nat 	:= ExistBlock("F241NAT")
Local lTodasFil := ExistBlock("MT103FRT")
Local oModelMov
Local oSubFKA
Local cLog := ""
Local lRet := .T.
Local lExistFJU := FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")
Local cUniao	:= If(! EMPTY(GetMV("MV_UNIAO")),GetMV("MV_UNIAO"),'UNIAO')

DEFAULT lContabil 	:= .T.
DEFAULT nTotal		:= 0
DEFAULT nHdlPrv		:= 0
DEFAULT cArquivo	:= ""
DEFAULT lUsaFlag	:= .F.
DEFAULT aFlagCtb	:= {}
DEFAULT cNumBord	:= mv_par01  //Numero do bordero no cancelamento de borderos da FINA241

// Zerar ABATIMENTO para contabilizacao.
ABATIMENTO := 0

SA2->(dbSeek(xFilial("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA))

If (cAglutFil == "2" .Or. cAglutFil == "3") .And. lTodasFil
	Help( ,, 'HELP',, STR0089 , 1, 0)		//'Parâmetro MV_PCCAGFL deve ser "1=Não Aglutina" para utilizar o ponto de entrada "MT103FRT".'
	Return
EndIf

//Se parametro "MV_PCCAGFR" existe com conteudo diferente de 1
If cAglutFil == "2" .Or. cAglutFil == "3"
	aFil10925 := {}
	aAreaSA2  := SA2->(GetArea())
	If !Empty(cCGCFor := SA2->A2_CGC)
		cForTipo := SA2->A2_TIPO
		SA2->(DbSetOrder(3))
		aAreaSM0 := SM0->(GetArea())
		cEmpAtu  := SM0->M0_CODIGO
		cCGCSM0  := SM0->M0_CGC
		SM0->(DbSetOrder(1))
		SM0->(MsSeek(cEmpAnt))
		Do While !SM0->(Eof()) .And. SM0->M0_CODIGO == cEmpAtu
			//Verifica se a filial tem o mesmo CGC/Raiz de CGC
			If (cAglutFil == "2" .And. cCGCSM0 == SM0->M0_CGC) .Or. (cAglutFil == "3" .And. Left(cCGCSM0,8) == Left(SM0->M0_CGC,8))
				AAdd(aFil10925,FWGETCODFILIAL)
			EndIf
			SM0->(DbSkip())
		EndDo
		SM0->(RestArea(aAreaSM0))
	EndIf
	SA2->(RestArea(aAreaSA2))

//Verifico todas as filiais apenas quando SA2 compartilhado
ElseIf lTodasFil
	aFil10925 := ExecBlock( "MT103FRT", .F., .F. )
Else
  If !Empty (FwFilial("SE2")) .And. lConfil
     aFil10925 := FAFIL10925()
  Else
     aFil10925 := { cFilAnt }
  Endif
Endif

If Len(aFil10925) == 0
	If !Empty (FwFilial("SE2")) .And. lConfil
		aFil10925 := FAFIL10925()
  	Else
    	aFil10925 := { cFilAnt }
    Endif
EndIf

For nCont := 1 to Len(aFil10925)

	cFilAnt   := aFil10925[nCont]
	lCancelou := .F.
	lCtblizou := .T.

	SE5->(dbSetOrder(7))
	If SE5->(dbSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

		While !(SE5->(EOF())) .and. SE5->E5_FILIAL == xFilial("SE5") .and. ;
			SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == ;
			SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)

			//A Baixa gerada por imposto gerado no bordero eh cancelada
			If SE5->E5_MOTBX == "PCC" .and. Alltrim(cNumBord) == Alltrim(SE5->E5_DOCUMEN) .and. ;
					SE5->E5_PRETPIS == "4" .and. SE5->E5_SITUACA != "C"
				nValBaix 	:= SE5->E5_VALOR
				lCtblizou 	:= (SE5->E5_LA = "S")

				oModelMov := FWLoadModel("FINM020") //Recarrega o Model de movimentos para pegar o campo do relacionamento (SE5->E5_IDORIG)
				oModelMov:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
				oModelMov:Activate()
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
				//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
				//E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
				//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
				oModelMov:SetValue( "MASTER", "E5_OPERACAO", 1 )
				oModelMov:SetValue( "MASTER", "HISTMOV"    , STR0127 )	//"Estorno Baixa Ger.Impostos-Bordero"

				//Posiciona a FKA com base no IDORIG da SE5 posicionada
				oSubFKA := oModelMov:GetModel( "FKADETAIL" )
				If oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
					If oModelMov:VldData()
					   	oModelMov:CommitData()
					   	SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
					Else
						lRet := .F.
					    cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					    cLog += cValToChar(oModelMov:GetErrorMessage()[6])

					   	Help( ,,"M030VALID",,cLog, 1, 0 )
					Endif
				Endif

				oModelMov:DeActivate()
				oModelMov:Destroy()
				oModelMov := Nil

				// Exclui lançamento da baixa  parcial do titulo original ref. impostos
	    		PCODetLan("000023","02","FINA241", .T.)   //referente baixa parcial SE5

				lCancelou := .T.
				nPis := SE5->E5_VRETPIS
				nCofins := SE5->E5_VRETCOF
				nCsll := SE5->E5_VRETCSL
				Exit
			Else
				SE5->(dbSkip())
			Endif
		Enddo

	Endif

	//Se a baixa foi cancelada, retorno o saldo para o titulo
	If lCancelou

		//Limpo referencias de apuracao de impostos.
		aRecSE5 := FImpDelTit("SE5",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,cSequen)

		For nX := 1 to Len(aRecSE5)
			SE5->(MSGoto(aRecSE5[nX]))
			SE5->(RecLock("SE5",.F.))
			SE5->E5_PRETPIS := "1"
			SE5->E5_PRETCOF := "1"
			SE5->E5_PRETCSL := "1"
	   	SE5->(MsUnlock())
		Next

		If dDataBase < dLastPCC
			//Exclui os registros de relacionamentos do SFQ
			SE2->(dbGoto(nSavRec))
			FImpDELSFQ("SE5",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,cSequen)

			aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			For nX := 1 to Len(aRecSE2)
				SE2->(MSGoto(aRecSE2[nX]))
				FaAvalSE2(4)
			Next

			//Exclui os registros de relacionamentos do SFQ
			SE2->(dbGoto(nSavRec))
			FImpExcSFQ("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

			SE2->(dbGoto(nSavRec))
		EndIf
		//Volto o saldo para o titulo principal
		nOldPis := SE2->E2_PIS
		nOldCof := SE2->E2_COFINS
		nOldCsl := SE2->E2_CSLL

		SA2->(dbSetOrder(1))
		SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))

		If SE2->E2_MOEDA > 1
			nValBaix := xMoeda(nValBaix,1,SE2->E2_MOEDA,dDataBase,3,1,SE2->E2_TXMOEDA)
		EndIf

		RecLock("SE2")
		SE2->E2_SALDO += nValBaix
		If STR(SE2->E2_SALDO,17,2) == STR(SE2->E2_VALOR,17,2)
			SE2->E2_BAIXA := CTOD("//")
		Endif
		SE2->E2_DESCONT	:= 0
		SE2->E2_MULTA	:= 0
		SE2->E2_JUROS	:= 0
		SE2->E2_CORREC	:= 0
		SE2->E2_VRETPIS -= nPis
		SE2->E2_VRETCOF -= nCofins
		SE2->E2_VRETCSL -= nCsll
		If SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0
			cPret:=FinRtPret(SE5->E5_SEQ)
			SE2->E2_PRETPIS := cPret
			SE2->E2_PRETCOF := cPret
			SE2->E2_PRETCSL := cPret
		Else
			SE2->E2_PRETPIS := "1"
			SE2->E2_PRETCOF := "1"
			SE2->E2_PRETCSL := "1"
		EndIf
		SE2->E2_VALLIQ	:= ( nPis + nCofins + nCsll )
		MsUnlock()

		//Contabilizacao dos impostos
		If lContabil .And. lCtblizou
			If VerPadrao("531") .and. nHdlPrv <= 0
				nHdlPrv := HeadProva( cLote,;
				                      "FINA241" /*cPrograma*/,;
				                      Substr( cUsuario, 7, 6 ),;
				                      @cArquivo )
			Endif
			If nHdlPrv > 0

				If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
					aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
				Endif
				nTotal += DetProva( nHdlPrv,;
				                    "531" /*cPadrao*/,;
				                    "FINA241" /*cPrograma*/,;
				                    cLote,;
				                    /*nLinha*/,;
				                    /*lExecuta*/,;
				                    /*cCriterio*/,;
				                    /*lRateio*/,;
				                    /*cChaveBusca*/,;
				                    /*aCT5*/,;
				                    /*lPosiciona*/,;
				                    @aFlagCTB,;
				                    /*aTabRecOri*/,;
				                    /*aDadosProva*/ )

			Endif
		Endif

	  	RecLock("SE2")
		SE2->E2_VALLIQ	:= 0
		SE2->E2_PARCPIS := Space(Len("E2_PARCPIS"))
		SE2->E2_PARCCOF := Space(Len("E2_PARCCOF"))
		SE2->E2_PARCSLL := Space(Len("E2_PARCSLL"))
		MsUnlock()

		//Verifico o fornecedor UNIAO para o cancelamento dos titulos de impostos
		DbSelectArea("SA2")
		DbSetOrder(1)
		MsSeek(xFilial("SA2")+cUniao+Space(Len(A2_COD)-Len(cUniao))+cLojaImp)
		cForUniao	:= SA2->A2_COD
		cLojUniao	:= SA2->A2_LOJA

		dbSelectArea("SE2")
		dbSetOrder(6)
		dbGoto(nSavRec)
		//Apago os titulos de impostos
		cChaveImp	:= cForUniao+cLojUniao+SE2->(E2_PREFIXO+E2_NUM)

		cNaturs := cNatPis+"/"+cNatCof+"/"+cNatCsl+"/"

		//Ponto de entrada onde serao retornados os codigos de natureza utilizados alternativamente pára os titulos de Pis, Cofins e Csll
		If lF241Nat
			cNaturs += ExecBlock("F241NAT",.F.,.F.)
		Endif

		If MsSeek(xFilial("SE2")+cChaveImp)
			While !Eof() .and. E2_FILIAL == xFilial("SE2") .and. ;
				cChaveImp == SE2->(E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM)
				//Se nao existir E2_TITPAI, valida da forma antiga
				//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
				//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
				If !lTitPai .OR. (lTitPai .AND. If(!Empty(SE2->(E2_TITPAI)),SE2->(E2_TITPAI) == cTitPai,.T.))
					If SE2->E2_TIPO $ MVTAXA .and. ;
						Alltrim(SE2->E2_NATUREZ) $ cNaturs .and. ;
						STR(SE2->E2_SALDO,17,2) == STR(SE2->E2_VALOR,17,2) .and. ;
						"FINA241" $ SE2->E2_ORIGEM
						If lExistFJU
							FinGrvEx("P")
						Endif

						FINDELFKs(SE2->E2_FILIAL+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")

						RecLock("SE2")
						dbDelete()
						MsUnlock()

						// Exclusao lançamento Pco referente aos titulos de impostos
						If Upper(Alltrim(SE2->E2_NATUREZ)) == cNatPis
							cItemTaxa := "03"
						ElseIf Upper(Alltrim(SE2->E2_NATUREZ)) == cNatCof
							cItemTaxa := "04"
						ElseIf Upper(Alltrim(SE2->E2_NATUREZ)) == cNatCsl
							cItemTaxa := "05"
						Else
							cItemTaxa := ""
						EndIf

						If !Empty(cItemTaxa)
							PCODetLan("000023",cItemTaxa,"FINA241", .T.)
						EndIf
					Endif
				EndIf
				dbSkip()
			Enddo
		Endif
		dbGoto(nSavRec)

		// Grava lançamento referente ao titulo original ja atualizado
		// lançamento PCO para acertar valor titulo original (alteracao)
	   	PCODetLan("000023","01","FINA241")   //referente titulo original
	Endif

	//Ajusta os campos de pendência de retenção.
	//Esse ajuste é necessário pois titulos colocados em borderô que possuam IRRF na baixa, mesmo não tendo PCC na baixa ou calculado,
	//recebia o flag de retido em borderô, o que causa problemas numa eventual baixa manual após retirar o titulo do borderô.
	If SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) == 0 .and. (SE2->E2_PRETPIS == '4' .or. SE2->E2_PRETCOF == '4' .or. SE2->E2_PRETCSL == '4')
		SE2->E2_PRETPIS := " "
		SE2->E2_PRETCOF := " "
		SE2->E2_PRETCSL := " "
	EndIF

Next nCont

cFilAnt := cFilAtu

RestArea(aArea)

Return


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} Fa241Rel
Imprime relacao de titulos que nao tiveram retencao versus os titulos que retiveram.

@author Mauricio Pequim Jr

@since 28/01/05
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function Fa241Rel(aSemRet,cBodero,aRetencao, cCart)

Local cDesc1	:= STR0070		//Este relatorio ir  demonstrar os titulos do bordero que tem
Local cDesc2	:= STR0071		//sua retencao realizada em outro titulo em outro bordero.
Local cDesc3	:= ""
Local wNrel
Local Tamanho	:= "M"
Local x			:= 0
Local CbCont	:= 0
Local CbTxt		:= Space(10)
Local cString	:= "SE2"
Local aRegSE2  	:= {}
Local nColPreOri:= 0
Local nColNumOri:= 0
Local nColParOri:= 0
Local nColTipOri:= 0
Local nColForOri:= 0
Local nColLojOri:= 0
Local nColBorOri:= 0
Local nColPreDes:= 0
Local nColNumDes:= 0
Local nColParDes:= 0
Local nColTipDes:= 0
Local nColForDes:= 0
Local nColLojDes:= 0
Local nColBorDes:= 0
Local aSvRecSE21 := {}
Local aSvRecSFQ := SFQ->(GetArea())
Local lConFil	:= SuperGetMV("MV_CONSFIL",.F.,.F.)
Local lTodasFil := ExistBlock("MT103FRT")
Local aFil10925 := {}
Local nKco := 0
Local cFilAtu := cFilAnt
Local lContinua := .T.

Private Li			:= 80
Private M_pag		:= 1
Private Titulo		:= STR0072		//Amarracao de titulos sem retencao x com retencao de impostos da Lei 10925"
Private cabec1		:= ""
Private cabec2		:= ""
Private aReturn		:= {STR0073,1,STR0074, 2, 2, 1, "",1 }		//"Zebrado" ### "Administracao"
Private nomeprog	:= "FINA241"
Private nLastKey	:= 0
Private limite		:= 132

Default cCart := "P"
Default aRetencao := {}

If cCart == "R"
	cString	:= "SE1"
	nomeprog	:="FINA061"
	aSvRecSE21 := SE1->(GetArea())

Else
	aSvRecSE21 := SE2->(GetArea())
EndIf

// Envia controle para a funcao SETPRINT
wnrel := "FR241Rel"
wnrel := SetPrint(cString,wNrel,,titulo,cDesc1,cDesc2,cDesc3,.F.,"",.F.,Tamanho,"",.T.)
If nLastKey == 27
	Return(Nil)
EndIf

SetDefault(aReturn,cString)
If nLastKey == 27
	Return(Nil)
EndIf

// Define o posicionamento das colunas para impressao
nColPreOri	:= 001
nColNumOri	:= 005
nColParOri	:= 015
nColTipOri	:= 018
nColForOri  := 023
nColLojOri  := 032
nColBorOri  := 042
nColPreDes	:= 063
nColNumDes	:= 067
nColParDes	:= 077
nColTipDes	:= 080
nColForDes  := 085
nColLojDes  := 094
nColBorDes  := 104

If lTodasFil
	aFil10925 := ExecBlock( "MT103FRT", .F., .F. )
Else
     If !Empty (FwFilial(If(cCart == "P","SE2","SE1") )) .And. lConfil
        aFil10925 := FAFIL10925()
     Else
        aFil10925 := { cFilAnt }
     Endif
Endif
If SEA->EA_DATABOR >= dLastPCc .or. cCart == "R"

	// Define as linhas do cabec
	Cabec1 := STR0134 //"                    Titulos Sem Retencao                     "
	If cCart == "P"
		Cabec2 := STR0135 //" Prf Numero    Pc Tipo Fornec   Loja      Bordero            "
	Else
		Cabec2 := STR0136 //" Prf Numero    Pc Tipo Cliente  Loja      Bordero            "
	EndIf

	For x := 1 To Len(aSemRet)
		If aSemRet[x][3] == .T.

			If Li >= 58
				Cabec(Titulo,Cabec1,Cabec2,NomeProg,Tamanho,Iif(aReturn[4]==1,15,18))
				Li := Prow()+1
			EndIf
			lContinua := .F.
			If cCart == "P"
				dbSelectArea("SE2")
				SE2->(dbGoto(aSemRet[x][1]))

				//Titulo sem retencao
				@Li,nColPreOri	PSAY SE2->E2_PREFIXO
				@Li,nColNumOri	PSAY SE2->E2_NUM
				@Li,nColParOri	PSAY SE2->E2_PARCELA
				@Li,nColTipOri	PSAY SE2->E2_TIPO
				@Li,nColForOri	PSAY SE2->E2_FORNECE
				@Li,nColLojOri	PSAY SE2->E2_LOJA
				@Li,nColBorOri 	PSAY SE2->E2_NUMBOR
				Li++
			Else
				dbSelectArea("SE1")
				SE1->(dbGoto(aSemRet[x][1]))

				//Titulo sem retencao
				@Li,nColPreOri	PSAY SE1->E1_PREFIXO
				@Li,nColNumOri	PSAY SE1->E1_NUM
				@Li,nColParOri	PSAY SE1->E1_PARCELA
				@Li,nColTipOri	PSAY SE1->E1_TIPO
				@Li,nColForOri	PSAY SE1->E1_CLIENTE
				@Li,nColLojOri	PSAY SE1->E1_LOJA
				@Li,nColBorOri 	PSAY SE1->E1_NUMBOR
				Li++

			EndIf

		EndIf
	Next x

	Cabec1 := STR0137 //"                    Titulos Com Retencao                     "
	Cabec(Titulo,Cabec1,Cabec2,NomeProg,Tamanho,Iif(aReturn[4]==1,15,18))
	Li := Prow()+1
	For x := 1 To Len(aRetencao)
		If cCart == "P"
			dbSelectArea("SE2")
			dbGoto(aRetencao[x][1])
			//Titulo com retencao
			@Li,nColPreOri	PSAY SE2->E2_PREFIXO
			@Li,nColNumOri	PSAY SE2->E2_NUM
			@Li,nColParOri	PSAY SE2->E2_PARCELA
			@Li,nColTipOri	PSAY SE2->E2_TIPO
			@Li,nColForOri	PSAY SE2->E2_FORNECE
			@Li,nColLojOri	PSAY SE2->E2_LOJA
			@Li,nColBorOri	PSAY SE2->E2_NUMBOR
			Li++

		Else
			dbSelectArea("SE1")
			SE1->(dbGoto(aRetencao[x][1]))
			//Titulo com retencao
			@Li,nColPreOri	PSAY SE1->E1_PREFIXO
			@Li,nColNumOri	PSAY SE1->E1_NUM
			@Li,nColParOri	PSAY SE1->E1_PARCELA
			@Li,nColTipOri	PSAY SE1->E1_TIPO
			@Li,nColForOri	PSAY SE1->E1_CLIENTE
			@Li,nColLojOri	PSAY SE1->E1_LOJA
			@Li,nColBorOri	PSAY SE1->E1_NUMBOR
			Li++

		EndIf

	Next x
Else

	// Define as linhas do cabec
	Cabec1 := STR0075		//"                    Titulos Sem Retencao                     |                     Titulo Retentor"
	Cabec2 := STR0076		//" Prf Numero    Pc Tipo Fornec   Loja      Bordero            | Prf Numero    Pc Tipo Fornec   Loja      Bordero            "

	// Inicia processo de leitura do array e impressao
	For x := 1 To Len(aSemRet)
		If aSemRet[x][3] == .T.
			If Li >= 58
				Cabec(Titulo,Cabec1,Cabec2,NomeProg,Tamanho,Iif(aReturn[4]==1,15,18))
				Li := Prow()+1
			EndIf

			dbSelectArea("SE2")
			dbGoto(aSemRet[x][1])

			//Salvo no Array os elementos do SE2, liberando a tabela para reposicionamento.
			aadd(aRegSE2,{SE2->E2_PREFIXO,SE2->E2_NUM,;
								SE2->E2_PARCELA,SE2->E2_TIPO,;
								SE2->E2_FORNECE,SE2->E2_LOJA,;
								SE2->E2_NUMBOR})

			dbSelectArea("SFQ")
			dbSetOrder(2) //FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
			For nKco := 1 to Len(aFil10925)

				cFilAnt := aFil10925[nKco]
				If dbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA))
			      SE2->(DbSetOrder(1))
					If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))

						//Titulo sem retencao
						@Li,nColPreOri	PSAY aRegSE2[1][1]
						@Li,nColNumOri	PSAY aRegSE2[1][2]
						@Li,nColParOri	PSAY aRegSE2[1][3]
						@Li,nColTipOri	PSAY aRegSE2[1][4]
						@Li,nColForOri	PSAY aRegSE2[1][5]
						@Li,nColLojOri	PSAY aRegSE2[1][6]
						@Li,nColBorOri PSAY aRegSE2[1][7]
						@Li,061 PSAY "|"

						//Titulo com retencao
						@Li,nColPreDes	PSAY SE2->E2_PREFIXO
						@Li,nColNumDes	PSAY SE2->E2_NUM
						@Li,nColParDes	PSAY SE2->E2_PARCELA
						@Li,nColTipDes	PSAY SE2->E2_TIPO
						@Li,nColForDes	PSAY SE2->E2_FORNECE
						@Li,nColLojDes	PSAY SE2->E2_LOJA
						@Li,nColBorDes	PSAY SE2->E2_NUMBOR
						Li++

				   Endif
				Endif
			Next nKco
			aRegSE2 := {}
		Endif
	Next
EndIf

cFilAnt :=  cFilAtu
Roda(CbCont,CbTxt,Tamanho)

//Restaura a posicao original do SE2 e SFQ
RestArea(aSvRecSE21)
RestArea(aSvRecSFQ)

If aReturn[5] = 1
	Set Printer To
	DbCommitAll()
	OurSpool(wnrel)
EndIf

MS_FLUSH()

Return

//------------------------------------------------------------------------------------
/*/
{Protheus.doc} GetMoedas
Obter as moedas utilizadas pelo sistema

@author ³Marcel Borges Ferreira

@since 28/09/06
@version 1.0
/*/
//------------------------------------------------------------------------------------
Static Function GetMoedas()
Local aRet		:= {}
Local aArea		:= GetArea()
Local aAreaSx6	:= Sx6->(GetArea())
Local cFilSx6	:= ""

// Inicializa array com as moedas existentes.
GetMv("MV_MOEDA1")
cFilSx6 := SX6->X6_FIL
While Substr(SX6->X6_VAR,1,8) == "MV_MOEDA" .And. ;
		SX6->(!Eof()) .And. SX6->X6_FIL == cFilSx6
	If Substr(SX6->X6_VAR,9,1) != "P" .AND. Substr(SX6->X6_VAR,9,2) != "CM" // Desconsiderar plural e MV_MOEDACM
		Aadd( aRet, StrZero(Val(Substr(SX6->X6_VAR,9,2)),2) + " " + GetMv(SX6->X6_VAR) )
	Endif
	SX6->(DbSkip())
EndDo
ASort(aRet)
SX6->(RestArea(aAreaSx6))
RestArea(aArea)

Return aRet
//-------------------------------------------------------------------
/*{Protheus.doc} MenuDef
Utilizacao de menu Funcional

Parametros do array aRotina
1. Nome a aparecer no cabecalho
2. Nome da Rotina associada
3. Reservado
4. Tipo de Transação a ser efetuada:
	1 - Pesquisa e Posiciona em um Banco de Dados
	2 - Simplesmente Mostra os Campos
	3 - Inclui registros no Bancos de Dados
	4 - Altera o registro corrente
	5 - Remove o registro corrente do Banco de Dados
5. nIvel de acesso
6. Habilita Menu Funcional

@author Ana Paula N. Silva
@version P12
@since   29/11/2006
@return  Array com opcoes da rotina.
*/
//-------------------------------------------------------------------

Static Function MenuDef()
Local aRotina := {	{ STR0001, "AxPesqui"      , 0 , 1},;  //"Pesquisar"
					{ STR0002, "FA241Borde"    , 0 , 3},;  //"Bordero"
					{ STR0003, "FA241Canc"     , 0 , 5},;  //"Cancelar"
					{ STR0083, "FA040Legenda"  , 0 ,7, ,.F.  }}  	//"Legenda"

//Motor de Retenções
If __lMotorRet
	aAdd( aRotina, { STR0139 ,"FINCRET('SE2')"   , 0, 9}) //'Consulta de Retenções'
Endif

Return(aRotina)


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241CMPPCC
Validar compensacoes que nao possuem impostos
 - Compensacao com NDF
 - Compensacao com PA cuja natureza nao calcule impostos PCC

@author Mauricio Pequim Jr

@since 28/01/05
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241CMPPCC(cAlias,cChaveTit)
Local aAreaX	:= GetArea()
Local lRet		:= .T.
Local nTamTit	:= TamSX3("E5_PREFIXO")[1]+TamSX3("E5_NUMERO")[1]+TamSX3("E5_PARCELA")[1]+TamSX3("E5_TIPO")[1]
Local nTamTit2  := TamSX3("E5_PREFIXO")[1]+TamSX3("E5_NUMERO")[1]+TamSX3("E5_PARCELA")[1]+1
Local cAdto		:= Substr((cAlias)->E5_DOCUMEN,1,nTamTit)+(cAlias)->(E5_FORNADT+E5_LOJAADT)
Local nVlMinImp		:= GetNewPar("MV_VL10925",5000)
Local lPCCBaixa		:= SuperGetMv("MV_BX10925",.T.,"2") == "1"

DEFAULT cChaveTit := ""

nValComp := If(Type("nValComp") != "N",0,nValComp)

//Desconsiderar compensacoes com NDF
If ((cAlias)->E5_MOTBX $ "CMP" .and.;
	 ( SUBSTR((cAlias)->E5_DOCUMEN,nTamTit2,3) $ MV_CPNEG) .OR. (cAlias)->E5_TIPO $ MV_CPNEG )
	lRet := .F.

//Desconsiderar compensacoes com PA que nao calculam Pcc na sua emissao
//Posicionado no titulo principal
ElseIf ((cAlias)->E5_MOTBX $ "CMP" .and. SUBSTR((cAlias)->E5_DOCUMEN,nTamTit2,3) $ MVPAGANT)
	__SE2->(dbSetOrder(1))

	//Quando PCC estiver na baixa os valores dos impostos sao gravados mesmo com valores minimos de retenção.
	If __SE2->(MsSeek(xFilial("SE2")+cAdto	)) .And.;
		 ((__SE2->(E2_PIS+E2_COFINS+E2_CSLL) == 0 .And. !lPccBaixa ).Or.;
		  (lPccBaixa .And. __SE2->E2_VALOR <= nVlMinImp )) //nao houve calculo de imposto para o PA

		lRet := .F.

		//Verifico se a natureza do PA e o fornecedor permitem retenção
		SED->(dbSetOrder(1))
		SED->(MsSeek(xFilial("SED")+__SE2->E2_NATUREZ))
		SA2->(dbSetOrder(1))
		SA2->(MsSeek(xFilial("SA2")+__SE2->(E2_FORNECE+E2_LOJA)))
		If	(SED->ED_CALCPIS == "S" .OR. SED->ED_CALCCOF == "S" .OR. SED->ED_CALCCSL == "S" ) .And. ;
			IIF(__lLocBra, (SA2->A2_RECPIS == "2" .OR. SA2->A2_RECCOFI == "2" .OR. SA2->A2_RECCSLL == "2"  ),.F.)

			lRet := .T.

			//Somo valor compensado para recompor a base
			//Compensacao com pa cuja natureza e fornecedor permitam calculo de PCC mas não houve retencao
			If (cAlias)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == cChaveTit
				nValComp += (cAlias)->E5_VALOR
			Endif

		Endif
	Endif
//Posicionado no PA
ElseIf ((cAlias)->E5_MOTBX $ "CMP" .and. (cAlias)->E5_TIPO $ MVPAGANT )
	__SE2->(dbSetOrder(1))

	//Quando PCC estiver na baixa os valores dos impostos sao gravados mesmo com valores minimos de retenção.
	If __SE2->(MsSeek(xFilial("SE2")+(cAlias)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))) .And.;
	 	( (__SE2->(E2_PIS+E2_COFINS+E2_CSLL ) == 0  .And. !lPccBaixa ).Or.; //Nao houve calculo de imposto para o PA
	   (lPccBaixa .And. __SE2->E2_VALOR <= nVlMinImp))
		lRet := .F.
	Endif
Endif

RestArea(aAreaX)

Return lRet


//-----------------------------------------------------------
/*{Protheus.doc} FinA241T
Chamada semi-automatica utilizado pelo gestor financeiro

@author Marcelo Celi Marques
@version P12
@since  31/03/08
@return  nIl
*/
//-------------------------------------------------------------------
Function FinA241T(aParam)
	cRotinaExec := "FINA241"
	ReCreateBrow("SE2",FinWindow)
	FinA241(aParam[1])
	ReCreateBrow("SE2",FinWindow)
	dbSelectArea("SE2")

	INCLUI := .F.
	ALTERA := .F.

Return .T.


//-------------------------------------------------------------------------------------------------------
/*{Protheus.doc} F241BsIRPF
Calcula a base de cálculo através da leitura do período referente ao documento

ExpN1 - Número de registro do documento a ser analisado
ExpC2 - Apelido do arquivo a ser avaliado
ExpN3 - Valor a ser considerado no cálculo da base de cálculo (Valor do pagamento)
ExpL4 - Determina se deverá somar o valor do documento a base de cálculo do IRPF
ExpC5 - Fornecedor a ter a base calculada
ExpC6 - Loja do fornecedor que deverá ter a base calculada
ExpC7 - Numero do borderô de pagamento
ExpD8 - Data do documento
ExpL9 - Define se retorna lista com títulos que compoem a base

@author Marcelo Celi Marques
@version P12
@since  31/03/08
@return  nIl
*/
//-------------------------------------------------------------------------------------------------------
Function F241BsIRPF(nRegiDoct,cAlias,nValPgto,lAgreValo,cFornece,cLoja,cNumBor,dDataDoct,lListTitu,lRecalc,lFina241,lCarret)

	Local aArea		:= (cAlias)->( GetArea() )
	Local lCampDepe	:= .T.
	Local nBaseDepe	:= SuperGetMv("MV_TMSVDEP",.T.,0)
	Local nValoDedu	:= 0
	Local lBaseIRPF	:= .F.
	Local nProp		:= 1
	Local lValLiq	:= SuperGetMv("MV_BP10925",.T.,"1") == "2" //1- Valor bruto da baixa parcial / 2- Valor da baixa parcial menos os impostos
	Local nI		:= 0
	Local cTitulo	:= ""
	Local lPrimCalc	:= .T.
	Local aAreaSE2	:= {}
	Local cFilterSE2:= ""
	Local aImpIss 	:= {}
	Local nLimInss  := SuperGetMv("MV_LIMINSS",.F.,0)
	Local lBaseTot  := .F.
	Local nVrRed	:=	0
	Local lIRPFBaixa := IIf( __lLocBra, SA2->A2_CALCIRF == "2", .F.)

	Local aStruct   := {}
	Local aCampos   := {}
	Local cAliasQry := ""
	Local cSepRec   := If("|"$MVPAGANT,"|",",")
	Local cSepNeg   := If("|"$MV_CPNEG,"|",",")
	Local cSepProv  := If("|"$MVPROVIS,"|",",")

	//Considero juros multa ou desconto na base do imposto.
	// 1 = Considera valores juros multa ou desconto
	// 2 = Nao considera valores juros multa ou desconto
	Local aCalcIRPF := {0,0,{},0}
	Local aRegsIRPF := {}
	Local dDataInic := FirstDay( dDataBase )
	Local dDataFina := LastDay( dDataBase )
	Local lFatBase	:= .F.
	Local lFina590	:= IsInCallStack("FINA590")
	Local lFina050	:= IsInCallStack("FINA050")
	Local nValBrut	:= 0
	Local nPosTit	:= 1
	Local lDedIns	:= SuperGetMv("MV_INSIRF",.F.,"2") == "1"

	Default nValPgto	:= 0
	Default lAgreValo	:= .T.
	Default cFornece	:= SE2->E2_FORNECE
	Default cLoja		:= SE2->E2_LOJA
	Default nRegiDoct	:= 0
	Default cNumBor		:= ""
	Default dDataDoct	:= dDataBase
	Default lListTitu	:= .F.
	Default lRecalc		:= .F.
	Default lFina241	:= IsInCallStack("FINA241")
	Default lCarret     := .F.

	// Utilizado para Deduzir o INSS do IRRF(Carreteiro)
	If Type('nINSSRet')=="U"
		nINSSRet  := 0
	EndIf

	//Encontra valor para dedução com dependentes
	dDataInic := FirstDay( dDataDoct )
	dDataFina := LastDay( dDataDoct )
	If lCampDepe .And. nBaseDepe > 0
		nNumeDepe := Posicione("SA2",1,xfilial("SA2") + cFornece + cLoja,"A2_NUMDEP")
		nValoDedu := nBaseDepe * nNumeDepe
	EndIf

	//Gestao
	F241PccBx()  // verificar PCC

	//Posiciona Natureza para verificação de base de IRRF
	//Se for inclusão de PA, utilizo os campos de memoria
	//para posicionar a Natureza
	If IsInCallStack("FINA050")
		SED->(dbSetOrder(1))
		SED->(MsSeek(xFilial("SED")+M->E2_NATUREZ))
		lBaseIRPF := If (!lCarret ,F050BIRPF(1),.F.)
	Else
		SED->(dbSetOrder(1))
		SED->(MsSeek(xFilial("SED")+SE2->E2_NATUREZ))
		lBaseIRPF := If (!lCarret ,F050BIRPF(2),.F.)
	Endif

	//Eh Base Bruta ou IR com base reduzida
	If lValLiq .Or. lBaseIRPF
		lRecalc := .T.
	Endif

	//Soma valor do título que está sendo avaliado à base de cálculo para IRPF
	If lAgreValo
		//Base reduzida de IRPF
		If IIF(lBaseIrpf, SE2->E2_BASEIRF > 0,.F.) .OR.(lFina050 .AND. SED->ED_BASEIRF>0)
			nVrRed	:= 0
			//Tratamento para geracao do bordero com impostos
			If lFina241
				aCalcIRPF[1] += nValPgto
			ElseIF !lFina050
				//Possui base reduzida de IR e nao se trata da geracao de um bordero CP com impostos
				nValorBase := SE2->E2_BASEIRF - If(lDedIns,SE2->E2_INSS,0)

				//Obtenho o valor bruto do titulo
				nValBrut := SE2->(E2_VALOR + E2_SEST)
				nValBrut += Iif(!lDedIns,SE2->E2_INSS,0)//Verifica se deve somar o INSS para compor a base de cálculo
				nValBrut += Iif(!GetCalcIss(SE2->E2_FILORIG),SE2->E2_ISS,0)//Verifica se deve somar o ISS para compor a base de cálculo
				nValBrut += Iif(!__lPCCBaixa,Iif(SE2->E2_PRETPIS == ' ',SE2->E2_VRETPIS,0)+Iif(SE2->E2_PRETCOF == ' ',SE2->E2_VRETCOF,0)+Iif(SE2->E2_PRETCSL == ' ',SE2->E2_VRETCSL,0),0)//Verifica se deve somar o PCC para compor a base de cálculo
				nValBrut += IIf(!lIRPFBaixa, SE2->E2_IRRF,0)

				nProp := IIf(nValPgto == 0,nValorBase,nValPgto)/nValBrut

				//Se a baixa for total, nao proporcionaliza
				//Exemplo:
				//Titulo de R$ 10.000 com base de IR de R$ 8.000
				//Caso se proporcionalize, teremos:
				//nProp := IIf(nValPgto == 0,8000,10000)/ 8000 = 1.25
				//aCalcIRPF[1] += SE2->E2_BASEIRF * nProp	= 8000 x 1.25 = 10.000
				If nValPgto > 0 .and. STR(nValPgto,17,2) == STR(nValBrut,17,2)
					nProp := 1
					lBaseTot := .T.
				Endif

				nVrRed	:= (SE2->E2_BASEIRF - Iif(!lDedIns,0,SE2->E2_INSS)) * nProp
				If SED->ED_BASEIRF > 0 .AND. SE2->E2_BASEIRF > 0 .AND. SE2->E2_VALOR > nValPgto //Caso seja baixa parcial de base reduzida...
					nVrRed := ((nVrRed * SED->ED_BASEIRF) / 100)
				Endif
				aCalcIRPF[1] += nVrRed
			Elseif M->E2_TIPO == MVPAGANT //Se for PA irá buscar os valores da memória
							//Possui base reduzida de IR e nao se trata da geracao de um bordero CP com impostos
				nValorBase := M->E2_BASEIRF - If(lDedIns,M->E2_INSS,0)

				//Obtenho o valor bruto do titulo
				nValBrut := M->(E2_VALOR + E2_SEST)
				nValBrut += Iif(!lDedIns,M->E2_INSS,0)//Verifica se deve somar o INSS para compor a base de cálculo
				nValBrut += Iif(!GetCalcIss(SE2->E2_FILORIG),M->E2_ISS,0)//Verifica se deve somar o ISS para compor a base de cálculo
				nValBrut += Iif(!__lPCCBaixa,Iif(SE2->E2_PRETPIS == ' ',M->E2_VRETPIS,0)+Iif(M->E2_PRETCOF == ' ',M->E2_VRETCOF,0)+Iif(M->E2_PRETCSL == ' ',M->E2_VRETCSL,0),0)//Verifica se deve somar o PCC para compor a base de cálculo
				nValBrut += IIf(!lIRPFBaixa, M->E2_IRRF,0)

				nProp := IIf(nValPgto == 0,nValorBase,nValPgto)/nValBrut

				//Se a baixa for total, nao proporcionaliza
				//Exemplo:
				//Titulo de R$ 10.000 com base de IR de R$ 8.000
				//Caso se proporcionalize, teremos:
				//nProp := IIf(nValPgto == 0,8000,10000)/ 8000 = 1.25
				//aCalcIRPF[1] += SE2->E2_BASEIRF * nProp	= 8000 x 1.25 = 10.000
				If nValPgto > 0 .and. STR(nValPgto,17,2) == STR(nValBrut,17,2)
					nProp := 1
					lBaseTot := .T.
				Endif

				nVrRed	:= (M->E2_BASEIRF - Iif(!lDedIns,0,M->E2_INSS)) * nProp
				If SED->ED_BASEIRF > 0 .AND. M->E2_BASEIRF > 0 .AND. M->E2_VALOR > nValPgto //Caso seja baixa parcial de base reduzida...
					nVrRed := ((nVrRed * SED->ED_BASEIRF) / 100)
				Endif
				aCalcIRPF[1] += nVrRed
			Endif
		Else
			//Nao possui tratamento de base reduzida
			aCalcIRPF[1] += IIf(nValPgto == 0,SE2->E2_SALDO+Iif(!lDedIns,SE2->E2_INSS,0)+Iif(GetCalcIss(SE2->E2_FILORIG),0,SE2->E2_ISS),nValPgto)
			If SA2->A2_TIPO == "J" .and. lIRPFBaixa .and. nValPgto <> 0  .and. SE2->(E2_SALDO+E2_IRRF) == nValPgto
				aCalcIRPF[1] += Iif(!lDedIns,SE2->E2_INSS,0)//Verifica se deve somar o INSS para compor a base de cálculo
				aCalcIRPF[1] += Iif(!GetCalcIss(SE2->E2_FILORIG),SE2->E2_ISS,0)//Verifica se deve somar o ISS para compor a base de cálculo
				aCalcIRPF[1] += Iif(!__lPCCBaixa,Iif(SE2->E2_PRETPIS == ' ',SE2->E2_VRETPIS,0)+Iif(SE2->E2_PRETCOF == ' ',SE2->E2_VRETCOF,0)+Iif(SE2->E2_PRETCSL == ' ',SE2->E2_VRETCSL,0),0)//Verifica se deve somar o PCC para compor a base de cálculo
			EndIf
		Endif
		nBaseIrpf := aCalcIRPF[1]
		cTitulo   := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)
	EndIf

	//Soma valores relacionados e retenção de IRPF dos títulos com retenção na baixa para determinar
	//a base de cálculo com exceção dos que tem borderô
	aCampos := { "E5_VALOR","E5_VRETIRF","E5_VLJUROS","E5_VLMULTA","E5_VLDESCO"}

	//Base IRPF reduzida
	IF lBaseIrpf
		aCampos := { "E5_BASEIRF"}
	Endif

	aStruct := SE5->( dbStruct() )
	cAliasQry := GetNextAlias()
	SE5->( dbCommit() )

	cQuery := " SELECT"
	cQuery += " SUM(E5_VALOR) BASEBAIX"
	cQuery += ", SUM(E5_VRETIRF) RETEBAIX"
	cQuery += ", SUM(E5_VRETISS) RETEISS"

	// Se tratar-se de titulo de carreteiro, soma valor de INSS, ISS e SEST para recompor base de calculo
	cQuery += ", SUM(E2_INSS) INSS"
	cQuery += ", SUM(E2_ISS) ISS"
	cQuery += ", SUM(E2_SEST) SEST"

	If lListTitu
		cQuery += ", E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA"
	EndIf

	cQuery += " FROM"
	cQuery += " " + RetSqlName( "SE5" ) + " SE5, " + RetSqlName( "SE2" ) + " SE2, " + RetSqlName( "SED" ) + " SED"
	cQuery += " WHERE E5_FILIAL = '" + xFilial("SE5") + "'"
	cQuery += " AND E5_CLIFOR='"	+ cFornece + "'"
	cQuery += " AND E5_LOJA='" + cLoja + "'"
	cQuery += " AND E5_DATA>= '" + DTOS( dDataInic ) + "'"
	cQuery += " AND E5_DATA<= '"	+ DTOS( dDataFina ) + "'"
	cQuery += " AND E5_TIPO NOT IN " + FormatIn(MVABATIM,"|")
	cQuery += " AND E5_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
	cQuery += " AND E5_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)
	cQuery += " AND E5_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)
	cQuery += " AND E5_RECPAG = 'P'"

	//Base IRPF reduzida
	IF lBaseIrpf
		cQuery += " AND E5_BASEIRF = 0 "
	Endif

	cQuery += " AND E5_MOTBX NOT IN ('FAT','CMP','IRF','PCC','LIQ','ISS','IMR')"
	cQuery += " AND E5_SITUACA <> 'C'"
	cQuery += " AND SE5.D_E_L_E_T_=' '"
	cQuery += " AND E2_FILIAL  = '" + xFilial("SE2") + "'"
	cQuery += " AND E2_PREFIXO = E5_PREFIXO AND E2_NUM = E5_NUMERO"
	cQuery += " AND E2_PARCELA = E5_PARCELA AND E2_FORNECE = E5_CLIFOR AND E2_LOJA = E5_LOJA"
	cQuery += " AND E2_TIPO = E5_TIPO"
	cQuery += " AND E2_NUMBOR = '" + Space(TamSX3("E2_NUMBOR")[1]) + "'"
	cQuery += " AND E2_NATUREZ = ED_CODIGO "
	If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
		cQuery += " AND ED_CALCIRF = 'S' "
	EndIf

	// Quando o titulo de IRPJ for gerado na baixa do titulo principal,
	// calcula isoladamente o valor para este titulo sem acumular
	If lIRPFBaixa .AND. SA2->A2_TIPO == "J"
		cQuery += " AND ( E2_IRRF > 0 AND E2_VRETIRF < E2_IRRF )"
	EndIf

	cQuery += " AND SE2.D_E_L_E_T_=' '"
	cQuery += " AND NOT EXISTS ("
	cQuery += 		" SELECT A.E5_NUMERO"
	cQuery += 		" FROM "+RetSqlName("SE5")+" A"
	cQuery += 		" WHERE A.E5_FILIAL='"+xFilial("SE5")+"'"
	cQuery +=		" AND A.E5_PREFIXO=SE5.E5_PREFIXO"
	cQuery +=		" AND A.E5_NUMERO=SE5.E5_NUMERO"
	cQuery +=		" AND A.E5_PARCELA=SE5.E5_PARCELA"
	cQuery +=		" AND A.E5_TIPO=SE5.E5_TIPO"
	cQuery +=		" AND A.E5_CLIFOR=SE5.E5_CLIFOR"
	cQuery +=		" AND A.E5_LOJA=SE5.E5_LOJA"
	cQuery +=		" AND A.E5_SEQ=SE5.E5_SEQ"
	cQuery +=		" AND A.E5_TIPODOC = 'ES'"
	cQuery +=		" AND A.E5_RECPAG <> 'P'"
	cQuery +=		" AND A.D_E_L_E_T_ = ' ')"

	If lListTitu
		cQuery += " GROUP BY E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA "
	EndIf

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

	TCSetField( cAliasQry, "BASEBAIX", "N", 12, 2 )
	TCSetField( cAliasQry, "RETEBAIX", "N", 12, 2 )
	TCSetField( cAliasQry, "RETEISS",  "N", 12, 2 )

	dbSelectArea(cAliasQry)
	dbGoTop()
	While ! (cAliasQry)->(Eof())

		If lListTitu

			aAreaSE2 := SE2->(GetArea())
			cFilterSE2 := SE2->(dbFilter())

			SE2->(dbClearFilter())
			SE2->(dbSetOrder(1))
			SE2->(dbGoTop())

			If SE2->(dbSeek(xfilial("SE2") + (cAliasQry)->(E5_PREFIXO + E5_NUMERO + E5_PARCELA + E5_TIPO + E5_CLIFOR + E5_LOJA)))

				lFatBase	:= SE2->E2_FATURA="NOTFAT"
				If aScan(aRegsIRPF,SE2->(Recno())) == 0
					aAdd(aRegsIRPF,SE2->(Recno()))
				EndIf

				//ISS
				If (!Empty((cAliasQry)->RETEBAIX) .And. cTitulo != SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)) .Or.;
				(cTitulo == SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO) .And. lValLiq)

					aAdd(aImpIss,Iif(GetCalcIss(SE2->E2_FILORIG),FVRetISSBx(),Iif(cTitulo == SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO),0,SE2->E2_ISS)))
					lPrimCalc := .F.

				Endif

			dbSelectArea("SE2")
			SE2->(RestArea(aAreaSE2))
			Set Filter to &cFilterSE2

		EndIf

		EndIf

		If lFatBase .And. lListTitu
			aRet := FinFatAbat((cAliasQry)->E5_PREFIXO,(cAliasQry)->E5_NUMERO,(cAliasQry)->E5_CLIFOR,(cAliasQry)->E5_LOJA)
			nTotIss	:= aRet[1]
			nTotIns	:= aRet[2]
			nTotIrf	:= aRet[3]
			nTotPis := aRet[4]
			nTotCof	:= aRet[5]
			nTotCsl	:= aRet[6]
			nTotSes	:= aRet[7]
			DbSelectArea(cAliasQry)
		Else
			nTotIss	:= (cAliasQry)->RETEISS
			nTotIns	:= (cAliasQry)->INSS
			nTotSes	:= (cAliasQry)->SEST
		Endif

		If GetCalcIss(iif(lListTitu,SE2->E2_FILORIG,cFilAnt)) .And. !IsInCallStack("FA080VALVR")
			aCalcIRPF[1] += (cAliasQry)->BASEBAIX + Iif(lRecalc .And. lPrimCalc .And. !lCarret,0,(cAliasQry)->RETEBAIX) + nTotIss
		Else
			aCalcIRPF[1] += (cAliasQry)->BASEBAIX + Iif(lRecalc .And. lPrimCalc .And. !lCarret,0,(cAliasQry)->RETEBAIX)
		EndIf
		aCalcIRPF[2] += (cAliasQry)->RETEBAIX

		// Se tratar-se de titulo de carreteiro, soma valor de INSS, ISS e SEST para recompor base de calculo
		If lCarret
			aCalcIRPF[1] += nTotIns + nTotIss + nTotSes	//-- Recompoe valor para base de calculo
		EndIf
		nINSSRet += nTotIns //-- Valor de INSS JAH RETIDO

		(cAliasQry)->(dbSkip())

	Enddo

	(cAliasQry)->(dbCloseARea())

	//Refaz a base com os valores de ISS descontados.
	For nI := 1 to Len(aImpIss)
		aCalcIRPF[1] += aImpIss[nI]
	Next nI

	//Base IRPF reduzida
	IF lBaseIrpf

		cQuery := " SELECT"
		cQuery += " SUM(E5_BASEIRF) BASEBAIX"
		cQuery += ", SUM(E5_VRETIRF) RETEBAIX"
		cQuery += ", SUM(E5_VRETISS) RETEISS"
		cQuery += ", E2_INSS "
		cQuery += ", E2_SALDO "

		If lListTitu
			cQuery += ", E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA"
		EndIf

		cQuery += " FROM"
		cQuery += " " + RetSqlName( "SE5" ) + " SE5, " + RetSqlName( "SE2" ) + " SE2"
		cQuery += " WHERE E5_FILIAL = '" + xFilial("SE5") + "'"
		cQuery += " AND E5_CLIFOR='"	+ cFornece + "'"
		cQuery += " AND E5_LOJA='" + cLoja + "'"
		cQuery += " AND E5_DATA>= '" + DTOS( dDataInic ) + "'"
		cQuery += " AND E5_DATA<= '"	+ DTOS( dDataFina ) + "'"
		cQuery += " AND E5_TIPO NOT IN " + FormatIn(MVABATIM,"|")
		cQuery += " AND E5_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
		cQuery += " AND E5_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)
		cQuery += " AND E5_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)
		cQuery += " AND E5_RECPAG = 'P'"
		cQuery += " AND E5_BASEIRF > 0 "

		// Quando o titulo de IRPJ for gerado na baixa do titulo principal,
		// calcula isoladamente o valor para este titulo sem acumular
		If lIRPFBaixa .AND. SA2->A2_TIPO == "J"
			cQuery += " AND ( E2_IRRF > 0 AND E2_VRETIRF < E2_IRRF )"
		EndIf

		cQuery += " AND E5_MOTBX NOT IN ('FAT','CMP','IRF','PCC','LIQ','ISS','IMR')"
		cQuery += " AND E5_SITUACA <> 'C'"
		cQuery += " AND SE5.D_E_L_E_T_=' '"
		cQuery += " AND E2_FILIAL  = '" + xFilial("SE2") + "'"
		cQuery += " AND E2_PREFIXO = E5_PREFIXO AND E2_NUM = E5_NUMERO"
		cQuery += " AND E2_PARCELA = E5_PARCELA AND E2_FORNECE = E5_CLIFOR AND E2_LOJA = E5_LOJA"
		cQuery += " AND E2_TIPO = E5_TIPO"
		If !lFina241 .Or. lFina590
			cQuery += " AND E2_NUMBOR = '" + Space(TamSX3("E2_NUMBOR")[1]) + "'"
		EndIf
		cQuery += " AND SE2.D_E_L_E_T_=' '"
		cQuery += " AND NOT EXISTS ("
		cQuery += 		" SELECT A.E5_NUMERO"
		cQuery += 		" FROM "+RetSqlName("SE5")+" A"
		cQuery += 		" WHERE A.E5_FILIAL='"+xFilial("SE5")+"'"
		cQuery +=		" AND A.E5_PREFIXO=SE5.E5_PREFIXO"
		cQuery +=		" AND A.E5_NUMERO=SE5.E5_NUMERO"
		cQuery +=		" AND A.E5_PARCELA=SE5.E5_PARCELA"
		cQuery +=		" AND A.E5_TIPO=SE5.E5_TIPO"
		cQuery +=		" AND A.E5_CLIFOR=SE5.E5_CLIFOR"
		cQuery +=		" AND A.E5_LOJA=SE5.E5_LOJA"
		cQuery +=		" AND A.E5_SEQ=SE5.E5_SEQ"
		cQuery +=		" AND A.E5_TIPODOC = 'ES'"
		cQuery +=		" AND A.E5_RECPAG <> 'P'"
		cQuery +=		" AND A.D_E_L_E_T_ = ' ')"

		If nRegiDoct > 0
			cQuery += " AND SE2.R_E_C_N_O_ <> " + Str(nRegiDoct)
		EndIf

		If lListTitu
			cQuery += " GROUP BY E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA, E2_SALDO, E2_INSS "
		Else
			cQuery += " GROUP BY E2_SALDO, E2_INSS"
		EndIf

		cQuery := ChangeQuery( cQuery )
		dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

		TCSetField( cAliasQry, "BASEBAIX", "N", 12, 2 )
		TCSetField( cAliasQry, "RETEBAIX", "N", 12, 2 )
		TCSetField( cAliasQry, "RETEISS",  "N", 12, 2 )

		dbSelectArea(cAliasQry)
		dbGoTop()
		While ! Eof()

			If lListTitu

				SE2->(dbSetOrder(1))
				If SE2->(dbSeek(xfilial("SE2") + (cAliasQry)->(E5_PREFIXO + E5_NUMERO + E5_PARCELA + E5_TIPO + E5_CLIFOR + E5_LOJA)))
					If aScan(aRegsIRPF,SE2->(Recno())) == 0
						aAdd(aRegsIRPF,SE2->(Recno()))
					EndIf
				EndIf
			EndIf

			If lIRPFBaixa
				If (cAliasQry)->E2_SALDO > 0 .AND. lDedIns .AND. nValPgto != (cAliasQry)->E2_SALDO .AND. !IsInCallStack("FINA080")
					aCalcIRPF[1] += (cAliasQry)->BASEBAIX - (cAliasQry)->E2_INSS
				Else
					aCalcIRPF[1] += (cAliasQry)->BASEBAIX
				EndIf
			ElseIf !lBaseTot
				If GetCalcIss(iif(lListTitu,SE2->E2_FILORIG,cFilAnt)) .And. !IsInCallStack("FA080VALVR")
					aCalcIRPF[1] += (cAliasQry)->BASEBAIX + (cAliasQry)->RETEISS
				Else
					aCalcIRPF[1] += (cAliasQry)->BASEBAIX
				EndIf
			EndIf
			aCalcIRPF[2] += (cAliasQry)->RETEBAIX

			(cAliasQry)->(dbSkip())

		Enddo

		(cAliasQry)->(dbCloseARea())
	Endif

	// Soma as retenções das baixas parciais do título que está sendo baixado
	If lIRPFBaixa .And. lBaseIrpf .And. SA2->A2_TIPO == "F"
		cQuery := " SELECT"
		cQuery += " SUM(E5_BASEIRF) BASEBAIX"
		cQuery += ",SUM(E5_VRETIRF) RETEBAIX"

		cQuery += " FROM"
		cQuery += " " + RetSqlName( "SE5" ) + " SE5 "
		cQuery += " WHERE E5_FILIAL = '" + xFilial("SE5") + "'"
		cQuery += " AND E5_CLIFOR='"	+ cFornece + "'"
		cQuery += " AND E5_LOJA='" + cLoja + "'"
		cQuery += " AND E5_DATA>= '" + DTOS( dDataInic ) + "'"
		cQuery += " AND E5_DATA<= '"	+ DTOS( dDataFina ) + "'"
		cQuery += " AND E5_RECPAG = 'P'"
		cQuery += " AND E5_BASEIRF > 0 "
		cQuery += " AND E5_MOTBX NOT IN ('FAT','CMP','IRF','PCC','IMR')"
		cQuery += " AND E5_SITUACA <> 'C'"

		cQuery += " AND E5_PREFIXO = '" + SubStr(cTitulo,1,TamSx3("E2_PREFIXO")[1])+ "'"
		nPosTit+= TamSx3("E2_PREFIXO")[1]

		cQuery += " AND E5_NUMERO = '" + SubStr(cTitulo,nPosTit,TamSx3("E2_NUM")[1])+ "'"
		nPosTit+= TamSx3("E2_NUM")[1]

		cQuery += " AND E5_PARCELA = '" + SubStr(cTitulo,nPosTit,TamSx3("E2_PARCELA")[1])+ "'"
		nPosTit+= TamSx3("E2_PARCELA")[1]

		cQuery += " AND E5_TIPO = '" + SubStr(cTitulo,nPosTit,TamSx3("E2_TIPO")[1])+ "'"

		cQuery += " AND E5_DOCUMEN = '" + Space(TamSX3("E5_DOCUMEN")[1]) + "'"

		cQuery += " AND SE5.D_E_L_E_T_=' '"
		cQuery += " AND NOT EXISTS ("
		cQuery += 		" SELECT A.E5_NUMERO"
		cQuery += 		" FROM "+RetSqlName("SE5")+" A"
		cQuery += 		" WHERE A.E5_FILIAL='"+xFilial("SE5")+"'"
		cQuery +=		" AND A.E5_PREFIXO=SE5.E5_PREFIXO"
		cQuery +=		" AND A.E5_NUMERO=SE5.E5_NUMERO"
		cQuery +=		" AND A.E5_PARCELA=SE5.E5_PARCELA"
		cQuery +=		" AND A.E5_TIPO=SE5.E5_TIPO"
		cQuery +=		" AND A.E5_CLIFOR=SE5.E5_CLIFOR"
		cQuery +=		" AND A.E5_LOJA=SE5.E5_LOJA"
		cQuery +=		" AND A.E5_SEQ=SE5.E5_SEQ"
		cQuery +=		" AND A.E5_TIPODOC = 'ES'"
		cQuery +=		" AND A.E5_RECPAG <> 'P'"
		cQuery +=		" AND A.D_E_L_E_T_ = ' ')"

		cQuery += " GROUP BY E5_BASEIRF, E5_VRETIRF "

		cQuery := ChangeQuery( cQuery )
		dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

		TCSetField( cAliasQry, "RETEBAIX", "N", 12, 2 )

		dbSelectArea(cAliasQry)
		dbGoTop()
		While !Eof()
			If lBaseTot
				nBaseIrpf	-= (cAliasQry)->BASEBAIX
			Else
				aCalcIRPF[1]+= (cAliasQry)->BASEBAIX
			EndIf

			aCalcIRPF[2]+= (cAliasQry)->RETEBAIX
			(cAliasQry)->(dbSkip())
		EndDo

		(cAliasQry)->(dbCloseARea())

	EndIf

	// Soma valor da base dos títulos que tiveram borderô emitido
	cAliasQry := GetNextAlias()

	SE2->( dbCommit() )

	cQuery := " SELECT "
	cQuery += " SUM(E2_VALOR) BASEBORD"
	cQuery += ", SUM(E2_IRRF) RETEBORD"

	// Se tratar-se de titulo de carreteiro, soma valor de INSS, ISS e SEST para recompor base de calculo
	If lCarret
		cQuery += ", SUM(E2_INSS) INSS"
		cQuery += ", SUM(E2_ISS) ISS"
		cQuery += ", SUM(E2_SEST) SEST"
	EndIf

	If lListTitu
		cQuery += ", E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, SE2.R_E_C_N_O_, E2_FILORIG"
	EndIf

	cQuery += " FROM"
	cQuery += " " + RetSqlName( "SE2" ) + " SE2"
	cQuery += " WHERE E2_FILIAL = '" + xFilial("SE2") + "'"
	cQuery += " AND E2_FORNECE='"	+ cFornece + "'"
	cQuery += " AND E2_LOJA='" + cLoja + "'"
	cQuery += " AND E2_NUMBOR <> '" + cNumBor + "'"
	cQuery += " AND E2_NUMBOR <> '" + Space(TamSX3("E2_NUMBOR")[1]) + "'"
	cQuery += " AND E2_DTBORDE >= '" + DTOS( dDataInic ) + "'"
	cQuery += " AND E2_DTBORDE <= '"	+ DTOS( dDataFina ) + "'"

	//Base IRPF reduzida
	IF lBaseIrpf
		cQuery += " AND E2_BASEIRF = 0 "
	Endif

	cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")
	cQuery += " AND E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
	cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)
	cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVTAXA,,3)
	cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVTXA,,3)
	cQuery += " AND NOT EXISTS ("
	cQuery += 		" SELECT A.E5_NUMERO"
	cQuery += 		" FROM "+RetSqlName("SE5")+" A"
	cQuery += 		" WHERE A.E5_FILIAL='"+xFilial("SE5")+"'"
	cQuery +=		" AND A.E5_PREFIXO=SE2.E2_PREFIXO"
	cQuery +=		" AND A.E5_NUMERO=SE2.E2_NUM"
	cQuery +=		" AND A.E5_PARCELA=SE2.E2_PARCELA"
	cQuery +=		" AND A.E5_TIPO=SE2.E2_TIPO"
	cQuery +=		" AND A.E5_CLIFOR=SE2.E2_FORNECE"
	cQuery +=		" AND A.E5_LOJA=SE2.E2_LOJA"
	cQuery +=		" AND A.E5_MOTBX IN ('NOR','IRF')"
	cQuery +=		" AND A.E5_RECPAG = 'P' "
	cQuery +=		" AND A.E5_SITUACA != 'C' "
	cQuery +=		" AND A.D_E_L_E_T_ = ' ')"

	If nRegiDoct > 0
		cQuery += " AND SE2.R_E_C_N_O_ <> " + Str(nRegiDoct)
	EndIf

	cQuery += " AND SE2.D_E_L_E_T_= ' '"

	If lListTitu
		cQuery += " GROUP BY E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, SE2.R_E_C_N_O_, E2_FILORIG "
	EndIf

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

	TCSetField( cAliasQry, "BASEBORD", "N", 12, 2 )
	TCSetField( cAliasQry, "RETEBORD", "N", 12, 2 )

	dbSelectArea(cAliasQry)
	dbGoTop()
	While ! Eof()
		If lListTitu
			If aScan(aRegsIRPF,(cAliasQry)->R_E_C_N_O_) == 0
				aAdd(aRegsIRPF,(cAliasQry)->R_E_C_N_O_)
			EndIf
		EndIf

		aCalcIRPF[1] += (cAliasQry)->BASEBORD
		aCalcIRPF[2] += (cAliasQry)->RETEBORD

		// Se tratar-se de titulo de carreteiro, soma valor de INSS, ISS e SEST para recompor base de calculo
		If lCarret
			aCalcIRPF[1] += (cAliasQry)->INSS + (cAliasQry)->ISS + (cAliasQry)->SEST //-- Recompoe valor para base de calculo
			nINSSRet += (cAliasQry)->INSS //-- Valor de INSS a deduzir
		EndIf

		(cAliasQry)->(dbSkip())

	Enddo

	(cAliasQry)->(dbCloseARea())

	//Base IRPF reduzida
	IF lBaseIrpf
		cAliasQry := GetNextAlias()

		SE2->( dbCommit() )

		cQuery := " SELECT "
		cQuery += " SUM(E2_BASEIRF) BASEBORD"
		cQuery += ", SUM(E2_IRRF) RETEBORD"
		cQuery += ", SUM(E2_INSS) RETINSBD"

		If lListTitu
			cQuery += ", E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, SE2.R_E_C_N_O_, E2_FILORIG"
		EndIf

		cQuery += " FROM"
		cQuery += " " + RetSqlName( "SE2" ) + " SE2"
		cQuery += " INNER JOIN " + RetSqlName("SED") + " SED "
		// Traz somente títulos com natureza financeira que calcula impostos de renda
		cQuery += " ON SE2.D_E_L_E_T_ = ' ' AND SE2.E2_NATUREZ = SED.ED_CODIGO AND SED.ED_CALCIRF = 'S' "
		cQuery += " WHERE E2_FILIAL = '" + xFilial("SE2") + "'"
		cQuery += " AND E2_FORNECE='"	+ cFornece + "'"
		cQuery += " AND E2_LOJA='" + cLoja + "'"

		//Para a manutencao de borderos (FINA590) devo considerar tambem os titulos do mesmo bordero
		//Para os demais considera-se apenas os titulos de borderos diferentes do atual.
		If !lFina590
			cQuery += " AND E2_NUMBOR <> '" + cNumBor + "'"
		Endif

		cQuery += " AND E2_NUMBOR <> '" + Space(TamSX3("E2_NUMBOR")[1]) + "'"
		cQuery += " AND ( (E2_DTBORDE >= '" + DTOS( dDataInic ) + "' AND E2_DTBORDE <= '"	+ DTOS( dDataFina ) + "') "
		cQuery += " OR (E2_BAIXA >= '" + DTOS( dDataInic ) + "' AND E2_BAIXA <= '"	+ DTOS( dDataFina ) + "') )"
		cQuery += " AND E2_BASEIRF > 0 "
		cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")
		cQuery += " AND E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
		cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)
		cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVTAXA,,3)
		cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVTXA,,3)
		If nRegiDoct > 0
			cQuery += " AND SE2.R_E_C_N_O_ <> " + Str(nRegiDoct)
		EndIf

		cQuery += " AND SE2.D_E_L_E_T_=' '"
		cQuery += " AND NOT EXISTS ("
		cQuery += 		" SELECT A.E5_NUMERO"
		cQuery += 		" FROM "+RetSqlName("SE5")+" A"
		cQuery += 		" WHERE A.E5_FILIAL='"+xFilial("SE5")+"'"
		cQuery +=		" AND A.E5_PREFIXO=SE2.E2_PREFIXO"
		cQuery +=		" AND A.E5_NUMERO=SE2.E2_NUM"
		cQuery +=		" AND A.E5_PARCELA=SE2.E2_PARCELA"
		cQuery +=		" AND A.E5_TIPO=SE2.E2_TIPO"
		cQuery +=		" AND A.E5_CLIFOR=SE2.E2_FORNECE"
		cQuery +=		" AND A.E5_LOJA=SE2.E2_LOJA"
		cQuery +=		" AND A.E5_MOTBX IN ('IRF','NOR')"
		cQuery +=		" AND A.E5_RECPAG = 'P' "
		cQuery +=		" AND A.E5_SITUACA != 'C' "
		cQuery +=		" AND A.D_E_L_E_T_ = ' ')"

		If lListTitu
			cQuery += " GROUP BY E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, SE2.R_E_C_N_O_, E2_FILORIG"
		EndIf

		cQuery := ChangeQuery( cQuery )
		dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

		TCSetField( cAliasQry, "BASEBORD", "N", 12, 2 )
		TCSetField( cAliasQry, "RETEBORD", "N", 12, 2 )

		dbSelectArea(cAliasQry)
		dbGoTop()
		While ! Eof()
			If lListTitu
				If aScan(aRegsIRPF,(cAliasQry)->R_E_C_N_O_) == 0
					aAdd(aRegsIRPF,(cAliasQry)->R_E_C_N_O_)
				EndIf
			EndIf

			aCalcIRPF[1] += (cAliasQry)->BASEBORD - Iif(!GetCalcIss(iif(lListTitu,(cAliasQry)->E2_FILORIG,cFilAnt)) .AND. SA2->A2_TIPO == "F",(cAliasQry)->RETINSBD,0)
			aCalcIRPF[2] += (cAliasQry)->RETEBORD

			(cAliasQry)->(dbSkip())

		Enddo

		(cAliasQry)->(dbCloseARea())
	Endif


	// Soma valores dos títulos de pagamento antecipado
	cAliasQry := GetNextAlias()

	SE2->( dbCommit() )

	cQuery := "SELECT"
	cQuery += " SUM(E2_VALOR) BASERETE"
	cQuery += ", SUM(E2_IRRF) RETEPGAN "

	If lListTitu
		cQuery += ", E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, SE2.R_E_C_N_O_"
	EndIf

	cQuery += " FROM"
	cQuery += " " + RetSqlName( "SE2" ) + " SE2"
	cQuery += " WHERE E2_FILIAL = '" + xFilial("SE2") + "'"
	cQuery += " AND E2_FORNECE='"	+ cFornece + "'"
	cQuery += " AND E2_LOJA='" + cLoja + "'"
	cQuery += " AND E2_EMISSAO >= '" + DTOS( dDataInic ) + "'"
	cQuery += " AND E2_EMISSAO <= '"	+ DTOS( dDataFina ) + "'"
	cQuery += " AND E2_TIPO IN " + FormatIn(MVPAGANT,"|")
	cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")
	cQuery += " AND E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
	cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)
	cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVTAXA,,3)
	cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVTXA,,3)

	//Base IRPF reduzida
	IF lBaseIrpf
		cQuery += " AND E2_BASEIRF = 0 "
	Endif

	// Quando o titulo de IRPJ for gerado na baixa do titulo principal, calcula isoladamente o valor para este titulo sem acumular
	If lIRPFBaixa .AND. SA2->A2_TIPO == "J"
		cQuery += " AND ( E2_IRRF > 0 AND E2_VRETIRF < E2_IRRF )"
	EndIf

	cQuery += " AND D_E_L_E_T_ = ' '"

	If lListTitu
		cQuery += " GROUP BY E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, SE2.R_E_C_N_O_"
	EndIf

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

	TCSetField( cAliasQry, "BASERETE", "N", 12, 2 )
	TCSetField( cAliasQry, "RETEPGAN", "N", 12, 2 )

	dbSelectArea(cAliasQry)
	dbGoTop()
	While ! Eof()
		If lListTitu
			If aScan(aRegsIRPF,(cAliasQry)->R_E_C_N_O_) == 0
				aAdd(aRegsIRPF,(cAliasQry)->R_E_C_N_O_)
			EndIf
		EndIf

		aCalcIRPF[1] += ((cAliasQry)->BASERETE + (cAliasQry)->RETEPGAN)
		aCalcIRPF[2] += (cAliasQry)->RETEPGAN

		(cAliasQry)->(dbSkip())

	End
	(cAliasQry)->(dbCloseARea())

	//Base IRPF reduzida
	IF lBaseIrpf

		cAliasQry := GetNextAlias()

		SE2->( dbCommit() )

		cQuery := "SELECT"
		cQuery += " SUM(E2_VALOR) BASERETE"
		cQuery += ", SUM(E2_IRRF) RETEPGAN "

		If lListTitu
			cQuery += ", E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, SE2.R_E_C_N_O_"
		EndIf

		cQuery += " FROM"
		cQuery += " " + RetSqlName( "SE2" ) + " SE2"
		cQuery += " WHERE E2_FILIAL = '" + xFilial("SE2") + "'"
		cQuery += " AND E2_FORNECE='"	+ cFornece + "'"
		cQuery += " AND E2_LOJA='" + cLoja + "'"
		cQuery += " AND E2_EMISSAO >= '" + DTOS( dDataInic ) + "'"
		cQuery += " AND E2_EMISSAO <= '"	+ DTOS( dDataFina ) + "'"
		cQuery += " AND E2_TIPO IN " + FormatIn(MVPAGANT,"|")
		cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")
		cQuery += " AND E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
		cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)
		cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVTAXA,,3)
		cQuery += " AND E2_TIPO NOT IN " + FormatIn(MVTXA,,3)
		cQuery += " AND E2_BASEIRF > 0 "
		cQuery += " AND D_E_L_E_T_ = ' '"

		// Quando o titulo de IRPJ for gerado na baixa do titulo principal,
		// calcula isoladamente o valor para este titulo sem acumular
		If lIRPFBaixa .AND. SA2->A2_TIPO == "J"
			cQuery += " AND ( E2_IRRF > 0 AND E2_VRETIRF < E2_IRRF )"
		EndIf


		If lListTitu
			cQuery += " GROUP BY E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, SE2.R_E_C_N_O_"
		EndIf

		cQuery := ChangeQuery( cQuery )
		dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

		TCSetField( cAliasQry, "BASERETE", "N", 12, 2 )
		TCSetField( cAliasQry, "RETEPGAN", "N", 12, 2 )

		dbSelectArea(cAliasQry)
		dbGoTop()
		While ! Eof()
			If lListTitu
				If aScan(aRegsIRPF,(cAliasQry)->R_E_C_N_O_) == 0
					aAdd(aRegsIRPF,(cAliasQry)->R_E_C_N_O_)
				EndIf
			EndIf

			aCalcIRPF[1] += ((cAliasQry)->BASERETE + (cAliasQry)->RETEPGAN)
			aCalcIRPF[2] += (cAliasQry)->RETEPGAN

			(cAliasQry)->(dbSkip())

		Enddo
		(cAliasQry)->(dbCloseARea())

	Endif

	// Soma ou deduz valores apurados a partir da rotina FINA375
	cAliasQry := GetNextAlias()

	SE2->( dbCommit() )

	cQuery := " SELECT "
	cQuery += "	CASE WHEN SE2.E2_TIPO = 'NDF' THEN SUM(E2_VALOR) WHEN SE2.E2_TIPO <> 'NDF' THEN 0 END IRPFNDF "
	cQuery += ", CASE WHEN SE2.E2_TIPO = 'NCF' THEN SUM(E2_VALOR) WHEN SE2.E2_TIPO <> 'NCF' THEN 0 END IRPFNCF "
	cQuery += " FROM"
	cQuery += " " + RetSqlName( "SE2" ) + " SE2"
	cQuery += " WHERE E2_FILIAL = '" + xFilial("SE2") + "'"
	cQuery += " AND E2_FORNECE='"	+ cFornece + "'"
	cQuery += " AND E2_LOJA='" + cLoja + "'"
	cQuery += " AND E2_NUMTIT = 'FINA375'"
	cQuery += " AND E2_EMISSAO >= '" + DTOS( dDataInic ) + "'"
	cQuery += " AND E2_EMISSAO <= '"	+ DTOS( dDataFina ) + "'"
	cQuery += " AND E2_TIPO IN ('NCF','NDF')"
	cQuery += " AND D_E_L_E_T_ = ' '"
	cQuery += " GROUP BY E2_TIPO "

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

	TCSetField( cAliasQry, "IRPFNDF", "N", 12, 2 )
	TCSetField( cAliasQry, "IRPFNCF", "N", 12, 2 )

	dbSelectArea(cAliasQry)
	dbGoTop()
	While ! Eof()

		aCalcIRPF[2] += (cAliasQry)->IRPFNDF
		aCalcIRPF[2] -= (cAliasQry)->IRPFNCF

		(cAliasQry)->(dbSkip())

	Enddo

	(cAliasQry)->(dbCloseARea())

	//Tratamento especifico para titulos de carreteiro
	If lCarret

		SE2->(DbGoto(nRegiDoct))

		// Aplica a reducao de base de calculo (Se houver)
		If SED->ED_BASEIRC > 0
			aCalcIRPF[1] := ((aCalcIRPF[1] * SED->ED_BASEIRC) / 100)
		EndIf

	EndIf
	// Deduz o INSS do IRRF

	//--Caso seja pagamento antecipado e não exista movimentação bancária no mês.
	IF lFina050 .And. M->E2_TIPO $ MVPAGANT .AND. IIf(SED->ED_RINSSPA=="1",M->E2_INSS,M->E2_PRINSS) >=  SUPERGETMV("MV_VLRETIN", .F.) .and. nINSSRet == 0
		nINSSRet := nINSSRet + IIf(SED->ED_RINSSPA=="1",M->E2_INSS,M->E2_PRINSS)
	Endif
	//--Verifica se o valor do INSS ultrapassou o valor limite.
	If nLimInss > 0 .And. nINSSRet > nLimInss
		nINSSRet := nLimInss
	EndIf

	aCalcIRPF[1] := aCalcIRPF[1] - If(lDedIns,nINSSRet,0)

	// Diminui valor com dedução de dependentes da base de
	// cálculo do IRPF
	If !lListTitu
		aCalcIRPF[1] -= IIf(aCalcIRPF[1] > 0,nValoDedu,0)
	Else
		aCalcIRPF[3] := aRegsIRPF
		aCalcIRPF[4] := nValoDedu
	EndIf

	RestArea(aArea)

Return(aCalcIRPF)

//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241BxIRPF
Efetua gravação da baixa parcial do título quando do bordero ou baixa do título

@author Mauricio Pequim Jr

@since 28/01/05
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241BxIRPF(nValoIRPF,lContabil,nRegiOrig,nTotal,nHdlPrv,lUsaFlag,aFlagCTB,cSequencia,lIRTabProg,aRetIRRF)
	Local cCodiRete		:= SE2->E2_CODRET
	Local dVencRea		:= dDataBase
	Local cArquivo		:= ""
	Local lIRPFBaixa	:= IIF(__lLocBra, Posicione("SA2",1,xfilial("SA2") + SE2->E2_FORNECE + SE2->E2_LOJA,"A2_CALCIRF") == "2" .And.;
								Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S", .F.)
	Local lBdVcImp		:= SuperGetMV("MV_BDVCIMP",.T.,.F.)
	Local cGeraDirf		:= "2"
	Local oModelBxP	:= NIL
	Local oSubFKA	:= NIL
	Local oSubFK2	:= NIL
	Local oSubFK4	:= NIL
	Local cLog		:= ""
	Local cChaveTit := ""
	Local cChaveFK7 := ""
	Local cCamposE5 := ""
	Local lRet 		:= .T.
	Local cNaturIRF	:= &(SuperGetMV("MV_IRF"))
	Local cIdFK3 	:= ""
	Local cIdFK4 	:= ""
	Local cOrigem	:= FunName()
	Local cCamposIR := ""
	Local cFilIR 	:= ""
	Local nRecSE5X	:= 0
	Local nRecFK2X	:= 0
	Local nX		:= 0
	Local lSimpIRAlu As Logical
	Local nDedSimpli As Numeric
	Local lEmpPub As Logical

	Default aFlagCTB	:= {}
	Default lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	Default cSequencia	:= ""
	Default lIRTabProg  := .F.
	Default aRetIRRF    := {}

	lSimpIRAlu := .F.
	nDedSimpli := SuperGetMV("MV_FVL1171", .F., 528)
	lEmpPub	:= IsEmpPub()
	
	//Caso não tenha atingido a faixa de retenção sai da função não efetuando os outros procedimentos
	If !lIRPFBaixa .or.  ( nIrfCalc == 0 .And. !lIRTabProg )
		Return
	EndIf

	Pergunte("F240BR",.F.)	
	
	If __lDicSimpl == NIL
		__lDicSimpl := (AliasInDic("DKE") .And. DKE->(FieldPos("DKE_IRSIMP")) > 0) .And. FK4->(FieldPos("FK4_DEDIRS")) > 0
	Endif

	//Reestruturacao SE5
	nIrfBaseR := If(Type("nIrfBaseR") != "N",0,nIrfBaseR)
	nIrfBaseC := If(Type("nIrfBaseC") != "N",0,nIrfBaseC)
	cFilIR    := cFilAnt

	If __lMotorRet == NIL
		//Motor Retenção
		__lMotorRet := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
	Endif

	If lIRPFBaixa .And. nBaseIrpf <> SE2->E2_BASEIRF .And. lEmpPub
		nBaseIrpf := SE2->E2_BASEIRF
	EndIf

	//Seleção de filiais
	If !Empty( SE2->E2_FILORIG ) .And. ( IsInCallStack( "F590Impost" ) .Or. mv_par08 == 1  )
		cFilAnt := SE2->E2_FILORIG
	EndIf

	If __lFKCodRet == nil
		__lFKCodRet:= (__lLocBra .and. FK3->(FieldPos("FK3_CODRET")) > 0 .and. FK4->(FieldPos("FK4_CODRET")) > 0)
	EndIf

	SA2->(DBSETORDER(1))
	SA2->(MSSeek(xFilial("SA2") + SE2->E2_FORNECE + SE2->E2_LOJA))

	//Array para gravacao dos impostos FK3
	aImpostos := {} 
	cCodRet := If(__lFKCodRet, SE2->E2_CODRET, "")

	If __oRatIRF == Nil .OR. Empty(__oRatIRF:aRatIRF)
		AAdd(aImpostos,{"IRF", nIrfCalc, cNaturIRF, "", nValoIRPF, nIrfBaseC, nIrfBaseR, "", SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, cCodRet})
	Else
		For nX := 1 To Len(__oRatIRF:aRatIRF)
			If __oRatIRF:aRatIRF[nX][5] != 0
				lSimpIRAlu := IIf(Len(__oRatIRF:aRatIRF[nX]) > 10, __oRatIRF:aRatIRF[nX][11], .F.)
				AAdd(aImpostos, {"IRF", __oRatIRF:aRatIRF[nX][6], cNaturIRF, "", __oRatIRF:aRatIRF[nX][6], __oRatIRF:aRatIRF[nX][5], __oRatIRF:aRatIRF[nX][5], "", SA2->A2_COD, SA2->A2_LOJA, __oRatIRF:aRatIRF[nX][3], cCodRet, lSimpIRAlu})
			EndIf
		Next nX
	EndIf

	cChaveTit := xFilial("SE2",SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
	cChaveFK7 := FINGRVFK7( "SE2", cChaveTit )

	If nValoIRPF > 0 .AND. lIRPFBaixa

		// Efetua baixa parcial no título com base no valor de retenção de IRPF
		RecLock("SE2")

		Replace E2_SALDO	With E2_SALDO - nValoIRPF
		Replace E2_BAIXA	With dDataBase
		Replace E2_VALLIQ	With nValoIRPF
		Replace E2_VRETIRF	With E2_VRETIRF + nValoIRPF
		Replace E2_PRETIRF	With "4"
		//Pessoa fisica vai acumulando o valor do IR retido tambem no E2_IRRF
		If (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG == "1"))
			SE2->E2_IRRF += nValoIRPF
		Endif

		MsUnlock()

		cGeraDirf := If(Empty(SE2->E2_CODRET), "2", "1")
		cSequencia := FaNxtSeqBx("SE2")  // Sequencia da baixa do adiantamento + 1

		// Gera movimento bancário de baixa parcial do título origem
		cCamposE5 := "{{'E5_DTDIGIT', dDataBase}"
		cCamposE5 += ",{'E5_DTDISPO', dDataBase}"
		cCamposE5 += ",{'E5_PREFIXO', SE2->E2_PREFIXO}"
		cCamposE5 += ",{'E5_NUMERO' , SE2->E2_NUM}"
		cCamposE5 += ",{'E5_PARCELA', SE2->E2_PARCELA}"
		cCamposE5 += ",{'E5_CLIFOR' , SE2->E2_FORNECE}"
		cCamposE5 += ",{'E5_FORNECE', SE2->E2_FORNECE}"
		cCamposE5 += ",{'E5_LOJA'   , SE2->E2_LOJA}"
		cCamposE5 += ",{'E5_BENEF'  , SE2->E2_NOMFOR}"
		cCamposE5 += ",{'E5_TIPO'   , SE2->E2_TIPO}"

		oModelBxP	:= FWLoadModel("FINM020")
		oModelBxP:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
		oModelBxP:Activate()
		oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou não
		oModelBxP:SetValue( "MASTER", "NOVOPROC", .T. ) //Informa que a inclusão será feita com um novo número de processo
		oModelBxP:SetValue( "MASTER", "HISTMOV", STR0126  ) //"Baixa Ger.IRPF-Bordero"

		oSubFK2 := oModelBxP:GetModel("FK2DETAIL")
		oSubFK3 := oModelBxP:GetModel("FK3DETAIL")
		oSubFK4 := oModelBxP:GetModel("FK4DETAIL")
		oSubFKA := oModelBxP:GetModel("FKADETAIL")

		//Dados da tabela auxiliar com o código do título a pagar
		cIdFK2	:= FWUUIDV4()

		//Dados do Processo - Define a chave da FK2 no IDORIG
		oSubFKA:SetValue( "FKA_IDORIG", cIdFK2 )
		oSubFKA:SetValue( "FKA_TABORI", "FK2" )

		//Dados da baixa a pagar
		oSubFK2:SetValue( "FK2_DATA"  , dDataBase )
		oSubFK2:SetValue( "FK2_VALOR" , nValoIRPF )
		oSubFK2:SetValue( "FK2_MOEDA" , StrZero(SE2->E2_MOEDA,2) )
		oSubFK2:SetValue( "FK2_NATURE", SE2->E2_NATUREZ )
		oSubFK2:SetValue( "FK2_RECPAG", "P" )
		oSubFK2:SetValue( "FK2_TPDOC" , "BA" )
		oSubFK2:SetValue( "FK2_VLMOE2", nValoIRPF )
		oSubFK2:SetValue( "FK2_MOTBX" , "IRF" )
		oSubFK2:SetValue( "FK2_ORIGEM", cOrigem )
		oSubFK2:SetValue( "FK2_SEQ"   , cSequencia )
		oSubFK2:SetValue( "FK2_DOC"   , cNumBor )
		oSubFK2:SetValue( "FK2_IDDOC" , cChaveFK7  )
		oSubFK2:SetValue( "FK2_FILORI", SE2->E2_FILORIG )
		oSubFK2:SetValue( "FK2_HISTOR", STR0126 )			//"Baixa Ger.IRPF-Bordero"

		//---------------------------------------------
		// Grava Imposto Calculado
		//---------------------------------------------
		For nX := 1 to Len(aImpostos)

			cIdFK3 := FINFKSID('FK3', 'FK3_IDFK3')
			cIdFK4 := FINFKSID('FK4', 'FK4_IDFK4')

			If !oSubFK3:IsEmpty()
				//Inclui a quantidade de linhas necessárias
				oSubFK3:AddLine()

				//Vai para linha criada
				oSubFK3:GoLine( oSubFK3:Length() )
			Endif

			//---------------------------------------------
			// Grava Imposto calculado
			//---------------------------------------------
			oSubFK3:SetValue( "FK3_IDFK3" , cIdFk3 )
			oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
			oSubFK3:SetValue( "FK3_ORIGEM", cOrigem )
			oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nX][1] )
			oSubFK3:SetValue( "FK3_RECPAG", "P" )
			oSubFK3:SetValue( "FK3_MOEDA" , "01" )
			oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nX][2] )
			oSubFK3:LoadValue( "FK3_NATURE", aImpostos[nX][3] )
			oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG )
			oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nX][6] )
			oSubFK3:SetValue( "FK3_IDORIG", cIdFK2 )
			oSubFK3:SetValue( "FK3_TABORI", "FK2" )
			oSubFK3:SetValue( "FK3_IDRET" , cIdFK4 )

			If __lFKCodRet 
				oSubFK3:SetValue( "FK3_CODRET" , cCodRet )
			EndIf

			If __lMotorRet
				oSubFK3:SetValue( "FK3_CODFKM", aImpostos[nX,8] )
				oSubFK3:SetValue( "FK3_CLIFOR", aImpostos[nX,9] )
				oSubFK3:SetValue( "FK3_LOJA"  , aImpostos[nX,10] )
				oSubFK3:SetValue( "FK3_CGC"   , aImpostos[nX][11] )
				oSubFK3:SetValue( "FK3_RAICGC", Substr(aImpostos[nX][11], 1, 8) )
			Endif
			
			//Grava Imposto Retido
			If aImpostos[nX,5] > 0
				oSubFK4:SetValue( "FK4_IDFK4" , cIdFk4 )
				oSubFK4:SetValue( "FK4_DATA"  , dDataBAse )
				oSubFK4:SetValue( "FK4_ORIGEM", FunName())
				oSubFK4:SetValue( "FK4_IMPOS" , "IRF" )
				oSubFK4:SetValue( "FK4_RECPAG", "P" )
				oSubFK4:SetValue( "FK4_MOEDA" , StrZero(SE2->E2_MOEDA,2))
				oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nX,5] )
				oSubFK4:LoadValue( "FK4_NATURE", aImpostos[nX,3])
				oSubFK4:LoadValue("FK4_NATURE", cNaturIRF )
				oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
				oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX][7] )

				If __oRatIRF != Nil .And. MethIsMemberOf(__oRatIRF, "GetIRCalculado")
					oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX][7] + __oRatIRF:GetIRCalculado(aImpostos[nX][11], cIdFk4, cChaveFK7,cIdFK2))
				EndIf		
				
				If __lFKCodRet
					oSubFK4:SetValue( "FK4_CODRET" , cCodRet )
				EndIf
				
				If __lDicSimpl .And. Len(aImpostos[nX])> 12 .And. aImpostos[nX][13]
					oSubFK4:SetValue("FK4_DEDIRS", nDedSimpli )
				Endif
				
				If __lMotorRet
					oSubFK4:LoadValue( "FK4_CLIFOR", aImpostos[nX][9]     )
					oSubFK4:LoadValue( "FK4_LOJA"  , aImpostos[nX][10]     )
					oSubFK4:SetValue( "FK4_CGC"    , aImpostos[nX][11] )
					oSubFK4:SetValue( "FK4_RAICGC" , Substr(aImpostos[nX][11], 1, 8) )
				Endif
			EndIf
		Next

		//Irrf Baixa
		FGrvSFQIR(nValoIRPF,nBaseIrpf,aDadosIr,cSequencia,@cCamposIR,cIdFk4)
		cCamposE5 += cCamposIR
		cCamposE5 += "}"
		oModelBxP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5

		If oModelBxP:VldData()
			oModelBxP:CommitData()
			nRecSE5X := oModelBxP:GetValue( "MASTER", "E5_RECNO" )
			nRecFK2X := FK2->(Recno())
			aAdd( aRetIRRF, {nRegiOrig, nValoIRPF} )
			SE5->(dbGoto(nRecSE5X))
		Else
			lRet := .F.
			cLog := cValToChar(oModelBxP:GetErrorMessage()[4]) + ' - '
			cLog += cValToChar(oModelBxP:GetErrorMessage()[5]) + ' - '
			cLog += cValToChar(oModelBxP:GetErrorMessage()[6])

			Help( ,,"M020VALID",,cLog, 1, 0)
			DisarmTransaction()
		Endif

		oModelBxP:DeActivate()

		If !lRet
			oModelBxP:Destroy()
			oModelBxP := Nil
			Break
		Endif

		//Contabilizacao da baixa ref valores IRPF
		If lContabil
			//Contabilizacao dos impostos
			If VerPadrao("530") .and. nHdlPrv <= 0
				//Inicializa Lancamento Contabil
				nHdlPrv := HeadProva(cLote, "FINA241" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo,,__aCTBPrv)
			Endif
			
			If nHdlPrv > 0 .And. nRecSE5X > 0 //Renco do movimento de baixa do IRF			

				//Prepara Lancamento Contabil
				nTotal += DetProva(nHdlPrv, "530" /*cPadrao*/, "FINA241" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/,;
									/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, __aCTBPrv)
				
				If nTotal > 0 
					If lUsaFlag //Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E5_LA" , "S", "SE5", nRecSE5X, 0, 0, 0} )
						aAdd( aFlagCTB, {"FK2_LA", "S", "FK2", nRecFK2X, 0, 0, 0} )
					Else
						//Atualiza Flag de contabilização
						SE5->(dbGoto(nRecSE5X))
						Reclock("SE5")
						SE5->E5_LA := 'S'
						MsUnLock()
						
						dbSelectArea( "FK2" )
						FK2->(dbGoto(nRecFK2X))
						RecLock("FK2")
						FK2->FK2_LA := 'S'
						MsUnLock()
					Endif
				EndIf
			Endif
		Endif

		// Grava lançamento da baixa parcial do titulo original ref. impostos
		// como SE2 e SE5 estao posicionados faz PcoDetLan p/ 2 eventos pco
		PCODetLan("000023","02","FINA241")   //referente baixa parcial SE5
		PCODetLan("000023","01","FINA241")   //referente titulo original

		// Calculo do vencimento do imposto
		dVencRea := F050VIMP("IRRF",dDatabase,dDatabase,IF(!lBdVcImp,dDataBase,SE2->E2_VENCREA),cCodiRete,SA2->A2_TIPO,lIRPFBaixa)

		// Grava título do IRRF e informações relacionadas
		FGrvIRRF("FINA241",dVencRea,dDataBase,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_TIPO,nValoIRPF,SE2->E2_MOEDA,SE2->E2_LA,cGeraDirf,cCodiRete,.F.,;
					{},{},nRegiOrig,"SE2",lIRPFBaixa,,If(__oRatIRF != Nil,__oRatIrf:aRatIrf,{}) )

		oModelBxP:Destroy()
		oModelBxP := Nil
		F241LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

	ElseIf !Empty(SE2->E2_NUMBOR) .and. !__lIrfMR //NÃO Houve retencao de PCC neste titulo E o mesmo pertence ao bordero em processamento
		FINGFK3BOR(1,"FK7",cChaveFK7,aImpostos, __lMotorRet, lIRTabProg, cChaveTit)
	Endif

	cFilAnt := cFilIR
Return .T.


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241ExIRPF
Cancela IRPF gerado a partir do bordero

@author João Gonçalves de Oliveira

@since 21/08/08
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241ExIRPF(nTotal,nHdlPrv,cArquivo,lContabil,lUsaFlag,aFlagCTB,cNumBor)

Local aArea		:= GetArea()
Local lCancelou := .F.
Local aRecSE2	:= {}
Local nValBaix	:= 0
Local nSavRec	:= SE2->(Recno())
Local nX		:= 0
Local nIrrf		:= 0
Local cNatIrf	:= &(GetMv("MV_IRF"))
Local lF241Nat	:= ExistBlock("F241NAT")
Local lCtblizou := .T.
Local lIRPFBaixa := IIF(__lLocBra, Posicione("SA2",1,xfilial("SA2") + SE2->E2_FORNECE + SE2->E2_LOJA,"A2_CALCIRF") == "2" .And.;
				              Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S", .F.)

Local cNatureza		:= &(GetMv("MV_IRF"))
Local cCodRetIr 	:= ""
Local cTipoFor 		:= SA2->A2_TIPO
Local dEmissao		:= CTOD("//")
Local dVencto		:= CTOD("//")
Local dVencRea		:= CTOD("//")
Local dEmis1		:= CTOD("//")

//=====================================
//Trecho alterado com o uso dos models:
//=====================================
Local oModelMov
Local oSubFKA
Local cLog := ""
Local lRet := .T.
Local lCalcIssBx	:= GetCalcIss(cFilAnt)
Local lCalcIss := SED->ED_CALCISS == "S" .And. SA2->A2_RECISS == "N"

DEFAULT lContabil	:= .T.
DEFAULT nTotal		:= 0
DEFAULT nHdlPrv		:= 0
DEFAULT cArquivo	:= ""
DEFAULT lUsaFlag	:= .F.
DEFAULT aFlagCtb	:= {}
DEFAULT cNumBor		:= ""

//Procuro a baixa referente a retencao de impostos
SE5->(DBSETORDER(7))
If SE5->(dbSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

	While !(SE5->(EOF())) .and. SE5->E5_FILIAL == xFilial("SE5") .and. ;
		SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == ;
		SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)

		//A Baixa gerada por imposto gerado no bordero eh cancelada
		If SE5->E5_MOTBX == "IRF" .and. Alltrim(cNumBor) == Alltrim(SE5->E5_DOCUMEN) .and. ;
			 SE5->E5_PRETIRF == "4" .and. SE5->E5_SITUACA != "C"

			nValBaix := SE5->E5_VALOR
			lCtblizou := (SE5->E5_LA = "S")
			cSequen	:= SE5->E5_SEQ

			// Rateio IR Progressivo
			f241CRatIR()
			If __oRatIRF <> Nil .AND. !Empty(__oRatIRF:aRatIRF)
				__oRatIRF:GetIRRetido(SE5->E5_IDORIG)
			Endif

			//Reestruturacao SE5
			oModelMov := FWLoadModel("FINM020") //Recarrega o Model de movimentos para pegar o campo do relacionamento (SE5->E5_IDORIG)
			oModelMov:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
			oModelMov:Activate()
			oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
			//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
			//E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
			//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
			oModelMov:SetValue( "MASTER", "E5_OPERACAO", 1 )
			oModelMov:SetValue( "MASTER", "HISTMOV"    , STR0127 )	//"Estorno Baixa Ger.Impostos-Bordero"

			//Posiciona a FKA com base no IDORIG da SE5 posicionada
			oSubFKA := oModelMov:GetModel( "FKADETAIL" )
			If oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
				If oModelMov:VldData()
				   	oModelMov:CommitData()
				   	SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
				   	oModelMov:DeActivate()
				Else
					lRet := .F.
				    cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				    cLog += cValToChar(oModelMov:GetErrorMessage()[6])

				   	Help( ,,"M030VALID",,cLog, 1, 0 )
				Endif
			Endif

			If lRet 
				// Exclui lançamento da baixa  parcial do titulo original ref. impostos
				PCODetLan("000023","02","FINA241", .T.)   //referente baixa parcial SE5

				lCancelou := .T.
				nIrrf := SE5->E5_VRETIRF

				// Atualização dos saldos do fluxo de caixa por natureza financeira
				If __lLocBra
					cCodRetIr := SE2->E2_CODRET
				EndIf
				dEmissao:= SE2->E2_EMISSAO
				dVencto	:= SE2->E2_VENCREA
				dEmis1	:= SE2->E2_EMIS1
				dVencRea:= F050VIMP("IRRF",dEmissao,dEmis1,SE2->E2_VENCREA,cCodRetIr,cTipoFor,lIRPFBaixa)
				// Atualiza o saldo da natureza. O valor jah esth liquido dos abatimentos, desta forma nao precisa atualizar na baixa dos abatimentos
				AtuSldNat(cNatureza, dVencRea, SE2->E2_MOEDA, "2", "P", nIRRF, xMoeda(nIRRF,SE2->E2_MOEDA,1,SE2->E2_VENCREA,,,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)), If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"+","-"),,FunName(),"SE2",SE2->(Recno()),0)
			Endif
			Exit
		Else
			SE5->(dbSkip())
		Endif
	Enddo

Endif

//Se a baixa foi cancelada, retorno o saldo para o titulo
If lCancelou

   	//Limpo referencias de apuracao de impostos.
   	aRecSE5 := FImpDelTit("SE5",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,cSequen)

    //ATENCAO, Mantida a gravação do SE5 de forma "manual"
	//O relacionamento de calculo e retencao já é desfeita no model (fk3/fk4) Esta parte será retirada quando a SE5 deixar de existir.
   	For nX := 1 to Len(aRecSE5)
   		SE5->(MSGoto(aRecSE5[nX]))
   		SE5->(RecLock("SE5",.F.))
   		SE5->E5_PRETIRF := "1"
   	   	SE5->(MsUnlock())
   	Next

   	//Exclui os registros de relacionamentos do SFQ
   	SE2->(dbGoto(nSavRec))
   	FImpDELSFQ("SE5",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,cSequen)

   	aRecSE2 := FImpExcTit("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

   	For nX := 1 to Len(aRecSE2)
   		SE2->(MSGoto(aRecSE2[nX]))
   		FaAvalSE2(4)
   	Next

   	//Exclui os registros de relacionamentos do SFQ
   	SE2->(dbGoto(nSavRec))
   	FImpExcSFQ("SE2",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

   	SE2->(dbGoto(nSavRec))

	//Volto o saldo para o titulo principal
	RecLock("SE2")
	SE2->E2_SALDO += nValBaix

	If STR(SE2->E2_SALDO,17,2) == STR(SE2->E2_VALOR,17,2)
		SE2->E2_BAIXA := CTOD("//")
	Endif

	SE2->E2_DESCONT := 0
	SE2->E2_MULTA   := 0
	SE2->E2_JUROS   := 0
	SE2->E2_CORREC  := 0

	If lCalcIssBx .And. lCalcIss
		SE2->E2_VRETISS -= nValBaix
	Endif

	If SE2->E2_SALDO == SE2->E2_VALOR
		SE2->E2_VRETISS := 0
	EndIF

	SE2->E2_PRETIRF := "1"

	If !lIRPFBaixa .OR. (lIRPFBaixa .AND. (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG == "1")))
		SE2->E2_IRRF -= nIrrf

		If SE2->E2_IRRF < 0
			SE2->E2_IRRF := 0
		EndIf
	EndIf

	SE2->E2_VRETIRF	-= nIrrf
	SE2->E2_PRETIRF	:= "1"
	SE2->E2_VALLIQ	:= nIrrf
	MsUnlock()

	//Contabilizacao dos impostos
	If lContabil .And. lCtblizou
		If VerPadrao("531") .and. nHdlPrv <= 0
			//Inicializa Lancamento Contabil
			nHdlPrv := HeadProva( cLote, "FINA241" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
		Endif

		If nHdlPrv > 0
			//Prepara Lancamento Contabil
			If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
				aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
			Endif

			nTotal += DetProva(nHdlPrv, "531" /*cPadrao*/, "FINA241" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/,;
								/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
		Endif
	Endif

	//Ponto de entrada onde serao retornados os codigos de natureza utilizados
	//alternativamente para os titulos de IRPF
	If lF241Nat
		cNatIRF += ExecBlock("F241NAT",.F.,.F.)
	Endif

	If __oRatIRF <> Nil .AND. !Empty(__oRatIRF:aRatIRF)
		For nX := 1 To Len(__oRatIRF:aRatIRF)
			F241DelTxIR("FINA241",SE2->(Recno()), __oRatIRF:aRatIRF[nX][7])
		Next nX
	Else
		F241DelTxIR("FINA241",SE2->(Recno()), nIRRF )
	EndIf

	SE2->(dbGoto(nSavRec))

	// Grava lançamento referente ao titulo original ja atualizado
	// Lançamento Pco para acertar valor titulo original (alteracao)
	PCODetLan("000023","01","FINA241")   //referente titulo original

Else

	// Título volta a situação de pendente para cálculo de IRPF na baixa
  	RecLock("SE2")
	SE2->E2_PRETIRF := "1"
	MsUnlock()

Endif

f241LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo
RestArea(aArea)

Return


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241DelTxIR
Cancela IRPF gerado a partir do bordero

@author João Gonçalves de Oliveira

@since 21/08/08
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241DelTxIR(cRotPCO,nRegiOrig,nIRRF)
Local aSA2 := SA2->(GetArea())
Local aAreaAt := GetArea()
Local lTitPai	:= .T.
Local cForUniao := ""
Local cLojUniao := ""
Local cChaveImp := ""
Local cNatIrf	:= &(GetMv("MV_IRF"))
Local lF241Nat 	:= ExistBlock("F241NAT")
Local cDirfOrig := ""
Local cLojaImp	:= PadR( "00", TamSX3( "A2_LOJA" )[1], "0" )
Local lIntPFS   := SuperGetMv("MV_JURXFIN", .T., .F.) // Integração SIGAPFS x SIGAFIN

//Verifico o fornecedor UNIAO para o cancelamento dos titulos de impostos
DbSelectArea("SA2")
DbSetOrder(1)
MsSeek(xFilial("SA2")+GetMv("MV_UNIAO")+Space(Len(A2_COD)-Len(GetMv("MV_UNIAO")))+cLojaImp)
cForUniao	:= SA2->A2_COD
cLojUniao	:= SA2->A2_LOJA

//Ponto de entrada onde serao retornados os codigos de natureza utilizados
//alternativamente para os titulos de IRPF
If lF241Nat
	cNatIRF += ExecBlock("F241NAT",.F.,.F.)
Endif

dbSelectArea("SE2")

//Abro o SE2 com outro alias pois pode estar filtrado pela
//Baixa por lote
If Select("__SE2") == 0
   ChkFile("SE2",.F.,"__SE2")
Else
   DbSelectArea("__SE2")
EndIf

dbSetOrder(6)
__SE2->(dbGoTo(nRegiOrig))
//Apago os titulos de impostos
cChaveImp	:= cForUniao+cLojUniao+__SE2->(E2_PREFIXO+E2_NUM)
cTitPai     := If(lTitPai,Pad(__SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),TamSx3("E2_TITPAI")[1]),"")

If __SE2->(MsSeek(xFilial("SE2")+cChaveImp))
	While !Eof() .and. __SE2->E2_FILIAL == xFilial("SE2") .And. ;
		cChaveImp == __SE2->(E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM)
		//Se nao existir E2_TITPAI, valida da forma antiga
		//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
		//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
		If ! lTitPai .OR. (lTitPai .AND. If(!Empty(__SE2->(E2_TITPAI)),__SE2->(E2_TITPAI) == cTitPai,.T.))
			If __SE2->E2_TIPO $ MVTAXA + "/" + MVTXA .And. ;
				Alltrim(__SE2->E2_NATUREZ) $ cNatIRF .And.;
				STR(__SE2->E2_SALDO,17,2) == STR(__SE2->E2_VALOR,17,2).And.;
				STR(__SE2->E2_SALDO,17,2) == STR(nIrrf,17,2)

				cDirfOrig := __SE2->E2_DIRF
				
				// Integração SIGAPFS x SIGAFIN - Deleta os desdobramentos para os titulos filhos, quando estes forem gerados na baixa do titulo Pai.
				Iif(FindFunction("JDelTitCP")  .AND. lIntPFS, JDelTitCP(__SE2->(Recno())), Nil)
				
				FINDELFKs(__SE2->E2_FILIAL+"|"+__SE2->E2_PREFIXO+"|"+__SE2->E2_NUM+"|"+__SE2->E2_PARCELA+"|"+__SE2->E2_TIPO+"|"+__SE2->E2_FORNECE+"|"+__SE2->E2_LOJA,"SE2")

				RecLock("__SE2")
				dbDelete()
				MsUnlock()

				nIRRF -= __SE2->E2_SALDO

				//Atualizacao dos saldos do fluxo de caixa por natureza financeira
				// Atualiza o saldo da natureza. O valor jah esth liquido dos abatimentos, desta forma nao precisa atualizar na baixa dos abatimentos
				AtuSldNat(__SE2->E2_NATUREZ, __SE2->E2_VENCREA, __SE2->E2_MOEDA, "2", "P", nIRRF, xMoeda(nIRRF,__SE2->E2_MOEDA,1,__SE2->E2_VENCREA,,,If(__lLocBra, __SE2->E2_TXMOEDA,0)), If(__SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"+","-"),,FunName(),"SE2",__SE2->(Recno()),0)

				// Exclusao lançamento Pco referente aos titulos de IRPF
				PCODetLan("000023","06",cRotPCO, .T.)

			EndIf
		EndIf
		dbSkip()
	Enddo
Endif

__SE2->(dbGoTo(nRegiOrig))
RecLock("__SE2",.F.)
__SE2->E2_DIRF := cDirfOrig //Restaura o valor do campo E2_DIRF
MsUnLock()

dbSelectArea("SE2")
RestArea(aSA2)
RestArea(aAreaAt)
Return


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} f241QryA
Funcao para consulta e atualizacao da lista de borderos

@author Pablo Gollan Carreras

@since 21/08/08
@version 1.0
/*/
//------------------------------------------------------------------------------------
Static Function f241QryA(lAtua, cAliasSE2, aCampos, aRestrict, cIndTemp1, cIndTemp2, aSelFil, aTmpFil, cModPgto)
Local cQuery	:= ""
Local cFiltro	:= ""
Local aStru 	:= {}
Local lPergDtAg := Type("mv_par11") == "D" .and. Type("mv_par12") == "D" .and. mv_par10 == 1
//--- Tratamento Gestao Corporativa
Local lGestao   := FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
Local cFilFwSE2 := IIF( lGestao , FwFilial("SE2") , xFilial("SE2") )
Local cTmpSE2Fil:= ""
Local lF241IND	:= ExistBlock("F241IND")
Local nF241Ind  := 0
Local nOldInd   := IndexOrd()
Local lBlockEasy := .T.
Local lIntPFS    := SuperGetMv("MV_JURXFIN", .T., .F.) // Integração SIGAPFS x SIGAFIN

aGetMark := {}

// Retorna filiais que o usuario tem acesso ja validando filiais informadas
dbSelectArea("SE2")
aStru := SE2->(DbStruct())
If Empty(mv_par03)
	mv_par03 := Space( TamSX3( "E2_FILIAL" )[1] )
Endif

If lAtua
	If Select(cAliasSE2) # 0
		aGetMark := F240Markdos(cAliasSE2)
		dbSelectArea(cAliasSE2)
		dbCloseArea()
		F240Clean() //Deleta tabela temporária no banco de dados criada da função F240MTTMP
	Endif
Endif

cFiltro := FA240Chec2()

cQuery := "SELECT "
aEval(aRestrict,{|x| cQuery += x + ", "})
cQuery += " E2_OK, SE2.R_E_C_N_O_ NUM_REG "
cQuery += "FROM " + RetSqlName("SE2") + " SE2 "

If lIntPFS .And. FWAliasInDic("OHF") .And. FindFunction("JFilBorPag") .And. SuperGetMv("MV_JURXFIN", .T., .F.) // Integração SIGAPFS x SIGAFIN
	cQuery += JFilBorPag(.T.) //Aqui contém a clausula Where
Else
	cQuery += " WHERE "
EndIf

If lLibTCB
	cQuery += "E2_FILORIG = '" + cFilAnt + "' AND "
ElseIf mv_par08 == 1  // Seleciona Filiais ?
	// Contas a pagar compartilhado deve observar FILORIG para realizar filtro
	If Empty( cFilFwSE2 )
		cQuery += "E2_FILORIG " + GetRngFil( aSelFil, "SE2", .T., @cTmpSE2Fil, , .T. ) + " AND "
	Else
		cQuery += "E2_FILIAL "  + GetRngFil( aSelFil, "SE2", .T., @cTmpSE2Fil ) + " AND "
	EndIf
	aAdd(aTmpFil, cTmpSE2Fil)
Else
	cQuery += "E2_FILIAL = '" + xFilial("SE2") + "' AND "
Endif

If mv_par09 == 1 //Considera Forma de Pgto?
	cQuery += "E2_FORMPAG = '" + cModPgto + "' AND "
Endif

If lPergDtAg .and. mv_par10 == 1 .and. !Empty(mv_par12) // Considera Agendamento
	cQuery += "E2_DATAAGE <> ' ' AND "
	cQuery += "E2_DATAAGE BETWEEN '" + DTOS(mv_par11) + "' AND '" + DTOS(mv_par12) + "' AND "
EndIf

cQuery += "E2_VENCREA BETWEEN '" + DtoS(dVenIni240) + "' AND '" + DtoS(dVenFim240) + "' AND "

If lF240EASY
	lBlockEasy := ExecBlock("F240EASY",.F.,.F.)
Endif

If ValType(lBlockEasy) != "L" .Or. lBlockEasy
	//---------------------------------------------------------------------------------
	// Titulos originados pelos módulos de comércio exterior não devem ser alterados
	//---------------------------------------------------------------------------------
	cQuery += "( E2_ORIGEM NOT IN ('SIGAEEC','SIGAEDC','SIGAECO','SIGAEFF','SIGAESS') ) AND "
EndIf

cQuery += "SE2.D_E_L_E_T_ = ' ' AND "
cQuery += cFiltro + " "
cQuery += "ORDER BY E2_FILIAL, E2_VENCREA"
cQuery := ChangeQuery(cQuery)

cArqNew := F240MTTMP(cQuery,aCampos,aRestrict,@cAliasSE2,.T.)

If lF241IND
	nF241Ind := ExecBlock("F241IND",.f.,.f.)
	If SIX->(DbSeek('SE2'+cvaltochar(nF241Ind)))
		nOldInd := nF241Ind
	Endif
Endif

dbSelectArea(cArqNew)
(cArqNew)->(dbgotop())

If lAtua
	nValor := 0
	nQtdTit := 0
	nTotAbat := 0
	If !(cArqNew)->(Eof())
		dbEval({|x| fa240DbEva(nLimite,dVenIni240,dVenFim240,@cAliasSE2,aGetMark)},{|| !Eof()})
		(cArqNew)->(dbGoTop())
	Endif
	oValor:Refresh()
	oQtda:Refresh()
	oMark:oBrowse:Refresh(.T.)
Endif

// DATA MINIMA DE TODAS AS EMISSOES, PARA CALCULO DE PCC -> F241Impost()
dDtMinPCC := dDataBase

cQueryX := "SELECT MIN(E2_EMISSAO) EMISSAO FROM " + F240GetNam()
cQueryX := ChangeQuery(cQueryX)
dbUseArea( .T., "TOPCONN", TcGenQry(,,cQueryX), "TRBMINX", .F., .T. )

dDtminPcc := Min(dDatabase, STOD(TRBMINX->EMISSAO))
TRBMINX->(dbCloseArea())

dbSelectArea(cArqNew)
(cArqNew)->(DbGoTop())

Return cArqNew

/*/
//--------------------------------------------------
{Protheus.doc} F241EmBord
Verificar se a baixa mencionada trata-se de um título que já está em borderô para que
nao some duas vezes na consistencia do valor mínimo

@author Pablo Gollan Carreras

@since 21/08/08
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241EmBord(cChaveTit)
Local lRet := .F.
Local aAreaSE2 := SE2->( GetArea() )

SE2->(DbSetOrder(1))
SE2->(DbSeek(xFilial("SE2")+cChaveTit))
If AllTrim(SE2->E2_NUMBOR )<> ""
	lRet := .T.
EndIf

RestArea(aAreaSE2)
Return lRet


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241EmBord
Cancela ISS gerado a partir do bordero

@author Marylly A. Silva

@since 09/02/11
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241DelIS(nRegiOrig,nISS,nTotal,nHdlPrv,cArquivo,lContabil,lUsaFlag,aFlagCTB,cNumBor)

Local lTitPai	:= .T.
Local aArea		:= GetArea()
Local aAreaSA2	:= SA2->(GetArea())
Local aAreaSE2	:= SE2->(GetArea())
Local cCodForn	:= GetMv("MV_MUNIC",.T.,"MUNIC")
Local cForMunic	:= ""
Local cLojMunic	:= ""
Local cChaveImp	:= ""
Local cNatIss	:= &(GetMv("MV_ISS",.T.,'"ISS"'))
Local cLojaImp	:= PadR( "00", TamSX3( "A2_LOJA" )[1], "0" )
Local lCancelou	:= .F.
Local nValBaix	:= 0
Local nSavRec	:= SE2->(Recno())
Local lCtblizou	:= .T.
Local cTitPai	:= ""
Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
//=====================================
//Trecho alterado com o uso dos models:
//=====================================
Local oModelMov
Local oSubFKA
Local cLog := ""
Local lRet := .T.
Local lExistFJU := FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")
Local nFrnLjIss := SE2->( E2_FORNISS + E2_LOJAISS )

DEFAULT lContabil	:= .T.
DEFAULT nTotal		:= 0
DEFAULT nHdlPrv		:= 0
DEFAULT cArquivo	:= ""
DEFAULT lUsaFlag	:= .F.
DEFAULT aFlagCtb	:= {}
DEFAULT cNumBor		:= mv_par01

//Verifico o fornecedor UNIAO para o cancelamento dos titulos de impostos
DbSelectArea("SA2")
SA2->(DbSetOrder(1)) // Filial + Codigo do Fornecedor + Loja
SA2->(MsSeek(xFilial("SA2")+cCodForn+Space(Len(A2_COD)-Len(cCodForn))+cLojaImp))

//Fornecedor informado durante a geração da nota fiscal de entrada
If !Empty( nFrnLjIss ) .And. "MATA100" $ SE2->E2_ORIGEM .And. SA2->(MsSeek(xFilial("SA2")+nFrnLjIss))
	cForMunic	:= SA2->A2_COD
	cLojMunic	:= SA2->A2_LOJA
Else
	SA2->(MsSeek(xFilial("SA2")+cCodForn+Space(Len(A2_COD)-Len(cCodForn))+cLojaImp))
	cForMunic	:= SA2->A2_COD
	cLojMunic	:= SA2->A2_LOJA
EndIf

dbSelectArea("SE2")
SE2->(dbSetOrder(6))
SE2->(dbGoTo(nRegiOrig))

If !Empty( SE2->E2_CODISS ) .And. __lLocBra
	DbSelectArea( "FIM" ) //-- Aliquota ISS
	FIM->( DbSetOrder( 1 ) )
	If FIM->( DbSeek( xFilial( "FIM" ) + SE2->E2_CODISS ) )
		cForMunic 	:= FIM->FIM_CODFOR
		cLojMunic	:= FIM->FIM_FORLOJ
	EndIf
EndIf

If !Empty(SE2->E2_FORNISS) .And. !Empty(SE2->E2_LOJAISS)
	cForMunic := SE2->E2_FORNISS
	cLojMunic := SE2->E2_LOJAISS
EndIf

//Apago os titulos de impostos de ISS
cChaveImp	:= cForMunic+cLojMunic+SE2->(E2_PREFIXO+E2_NUM)
cTitPai     := If(lTitPai,Pad(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),TamSx3("E2_TITPAI")[1]),"")

//Cancelamento da baixa E5_TIPODOC = ISS
SE5->(DBSETORDER(7))
If SE5->(dbSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

	While !(SE5->(EOF())) .and. SE5->E5_FILIAL == xFilial("SE5") .and. ;
		SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == ;
		SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)

		//A Baixa gerada por imposto gerado no bordero eh cancelada
		If SE5->E5_MOTBX == "ISS" .and. Alltrim(cNumbor) == Alltrim(SE5->E5_DOCUMEN) .and. ;
		 	SE5->E5_SITUACA != "C"

			lCtblizou := (SE5->E5_LA = "S")

			oModelMov := FWLoadModel("FINM020") //Recarrega o Model de movimentos para pegar o campo do relacionamento (SE5->E5_IDORIG)
			oModelMov:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
			oModelMov:Activate()
			oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
			//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
			//E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
			//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
			oModelMov:SetValue( "MASTER", "E5_OPERACAO", 1 )
			oModelMov:SetValue( "MASTER", "HISTMOV"    , STR0127 )	//"Estorno Baixa Ger.Impostos-Bordero"

			//Posiciona a FKA com base no IDORIG da SE5 posicionada
			oSubFKA := oModelMov:GetModel( "FKADETAIL" )
			If oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
				If oModelMov:VldData()
				   	oModelMov:CommitData()
				   	SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
				   	oModelMov:DeActivate()
				Else
					lRet := .F.
				    cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				    cLog += cValToChar(oModelMov:GetErrorMessage()[6])

				   	Help( ,,"M030VALID",,cLog, 1, 0 )
				Endif
			Endif

			// Exclui lançamento da baixa  parcial do titulo original ref. impostos
    		PCODetLan("000023","02","FINA241", .T.)   //referente baixa parcial SE5

			lCancelou := .T.
			nISS := SE5->E5_VRETISS
			nValBaix := SE5->E5_VALOR

			//Atualizacao dos saldos do fluxo de caixa por natureza financeira
			// Atualiza o saldo da natureza. O valor jah esth liquido dos abatimentos, desta forma nao precisa atualizar na baixa dos abatimentos
			AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", nISS, xMoeda(nISS,SE2->E2_MOEDA,1,SE2->E2_VENCREA,,,If(__lLocBra, SE2->E2_TXMOEDA,0)), If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"+","-"),,FunName(),"SE2",SE2->(Recno()),0)

			Exit
		Else
			SE5->(dbSkip())
		Endif
	Enddo

Endif

//Se a baixa foi cancelada, retorno o saldo para o titulo
If lCancelou

	RecLock("SE2")
	SE2->E2_SALDO += nValBaix
	If STR(SE2->E2_SALDO,17,2) == STR(SE2->E2_VALOR,17,2)
		SE2->E2_BAIXA := CTOD("//")
	Endif
	SE2->E2_DESCONT	:= 0
	SE2->E2_MULTA	:= 0
	SE2->E2_JUROS	:= 0
	SE2->E2_CORREC	:= 0
	If lCalcIssBx
		SE2->E2_VRETISS -= nValBaix
	Endif
	If SE2->E2_SALDO == SE2->E2_VALOR
		SE2->E2_VRETISS := 0
	EndIf
	If SE2->E2_VRETISS < 0
		SE2->E2_VRETISS := 0
	EndIf
	SE2->E2_VALLIQ	:= nValBaix
	MsUnlock()

	//Contabilizacao dos impostos
	If lContabil .And. lCtblizou
		If VerPadrao("531") .and. nHdlPrv <= 0
			nHdlPrv := HeadProva( cLote,;
			                      "FINA241" /*cPrograma*/,;
			                      Substr( cUsuario, 7, 6 ),;
			                      @cArquivo )
		Endif
		If nHdlPrv > 0

			If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
				aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
			Endif
			nTotal += DetProva( nHdlPrv,;
								"531" /*cPadrao*/,;
								"FINA241" /*cPrograma*/,;
								cLote,;
								/*nLinha*/,;
								/*lExecuta*/,;
								/*cCriterio*/,;
								/*lRateio*/,;
								/*cChaveBusca*/,;
								/*aCT5*/,;
								/*lPosiciona*/,;
								@aFlagCTB,;
								/*aTabRecOri*/,;
								/*aDadosProva*/ )

		Endif
	Endif

	SE2->(dbGoto(nSavRec))

	// Grava lançamento referente ao titulo original ja atualizado
	// Lançamento Pco para acertar valor titulo original (alteracao)
	PCODetLan("000023","01","FINA241")   //referente titulo original

Endif

//Deleta o titulo de ISS gerado pelo bordero
If SE2->(MsSeek(xFilial("SE2")+cChaveImp)) .AND. GetCalcIss(SE2->E2_FILORIG)
	While SE2->(!Eof()) .and. SE2->E2_FILIAL == xFilial("SE2") .And. ;
		cChaveImp == SE2->(E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM)
		//Se nao existir E2_TITPAI, valida da forma antiga
		//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
		//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
		If ! lTitPai .OR. (lTitPai .AND. If(!Empty(SE2->(E2_TITPAI)),SE2->(E2_TITPAI) == cTitPai,.T.))
			If SE2->E2_TIPO == "ISS".And. ;
				Alltrim(SE2->E2_NATUREZ) $ cNatIss .And.;
				STR(SE2->E2_SALDO,17,2) == STR(SE2->E2_VALOR,17,2) .And.;
				STR(SE2->E2_SALDO,17,2) == STR(nISS,17,2)
				If lExistFJU
					FinGrvEx("P")
				Endif

				FINDELFKs(SE2->E2_FILIAL+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")

				SE2->(RecLock("SE2"))
				SE2->(dbDelete())
				SE2->(MsUnlock())
			EndIf
		EndIf
		SE2->(dbSkip())
	Enddo
Endif

RestArea(aArea)
RestArea(aAreaSA2)
RestArea(aAreaSE2)

Return Nil


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241Baixa
Verifica se o borderô já sobre alguma baixa

@author Marylly A. Silva

@since 24/04/11
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function  F241Baixa(cBorFil,cNumBor)
Local lRet		:= .F.
Local aAreaSE2	:= SE2->(GetArea())
Local aAreaSE5	:= SE5->(GetArea())

If Empty(cBorFil)
	cBorFil	:= xFilial("SE5")
Endif

cNumBor := PadR(cNumBor,TamSX3("E5_DOCUMEN")[1]," ")
DbSelectArea("SE5")
SE5->(DbSetOrder(10))  // Filial + Documento
SE5->(DbSeek(cBorFil+cNumBor))

While SE5->(!Eof()) .And. SE5->(E5_FILIAL+E5_DOCUMEN) == cBorFil+cNumBor
	If (SE5->E5_MOTBX $ "PCC|IRF|INS|ISS|IMR|   ") .Or. (SE5->E5_SITUACA == "C")
		SE5->(DbSkip())
		Loop
	EndIf
	
	If (SE5->E5_RECPAG == "R" .And. SE5->E5_TIPODOC != 'ES')
		SE5->(DbSkip())
		Loop	
	EndIf

	If !(TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ)))
   		lRet := .T.
   		Exit
   	EndIf
	
	SE5->(DbSkip())
EndDo

RestArea(aAreaSE5)
RestArea(aAreaSE2)
Return lRet


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241VldMd
Valida a combinacao entre a moeda do banco e a moeda dos titulos a serem selecionados
(tela inicial)

@author Mauricio Pequim Jr

@since 24/04/11
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241VldMd(cPort240,cAgen240,cConta240,nMoeda240)

Local lRet := .T.

nMoedaBco := Max(MoedaBco(cPort240,cAgen240,cConta240),1)

// Para o Brasil, apresenta somente os titulos cuja moeda e' a mesma do banco em caso de banco em moeda estrangeira
If FXMultSld() .and. nMoedaBco > 1
	If nMoedaBco != nMoeda240
		Help(" ",1,"F240MOEDA",, STR0094,1,0) //"Para bancos em moeda estrangeira, os borderô somente poderá ter títulos em moeda igual a do banco"
      lRet := .F.
  Endif
Endif

Return lRet


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241BxISS
Valida a combinacao entre a moeda do banco e a moeda dos titulos a serem selecionados
(tela inicial)

@author Mauricio Pequim Jr

@since 13/05/2011
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241BxISS(nIss,lContabil,nRegiOrig,nTotal,nHdlPrv,lUsaFlag,aFlagCTB)

Local cArquivo	 	:= ""
Local cSequencia 	:= ""

//Reestruturacao SE5
Local oModelBxP	:= NIL
Local oSubFKA	:= NIL
Local oSubFK2	:= NIL
Local oSubFK4	:= NIL
Local cLog		:= ""
Local cChaveTit := ""
Local cChaveFK7 := ""
Local cCamposE5 := ""
Local lRet 		:= .T.
Local cNaturISS	:= &(SuperGetMV("MV_ISS"))
Local cIdFK3 	:= ""
Local cIdFK4 	:= ""
Local cOrigem	:= FunName()
Local cFilIss	:= cFilAnt
Local nRecSE5X	:= 0

Default nIss		:= 0
Default aFlagCTB	:= {}
Default lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)

//Seleção de filiais
If mv_par08 == 1 .And. !Empty( SE2->E2_FILORIG )
	cFilAnt := SE2->E2_FILORIG
EndIf

//Efetua baixa parcial no título com base no valor de retenção de IRPF
RecLock("SE2")

If nIss > 0
	Replace E2_SALDO	With E2_SALDO - nIss
	Replace E2_BAIXA	With dDataBase
	Replace E2_VALLIQ	With nIss
	Replace E2_VRETISS	With E2_VRETISS + nIss
EndIf

Replace E2_BAIXA	With dDataBase
MsUnlock()

//Caso não tenha atingido a faixa de retenção sai da função não efetuando os outros procedimentos
If nIss > 0
	cSequencia := FaNxtSeqBx("SE2")  // Sequencia da baixa do adiantamento + 1

	// Gera movimento bancário de baixa parcial do título origem³
	//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
	cCamposE5 := "{{'E5_DTDIGIT' , dDataBase}"
	cCamposE5 += ",{'E5_DTDISPO' , dDataBase}"
	cCamposE5 += ",{'E5_PREFIXO' , SE2->E2_PREFIXO}"
	cCamposE5 += ",{'E5_NUMERO'  , SE2->E2_NUM}"
	cCamposE5 += ",{'E5_PARCELA' , SE2->E2_PARCELA}"
	cCamposE5 += ",{'E5_CLIFOR'  , SE2->E2_FORNECE}"
	cCamposE5 += ",{'E5_FORNECE' , SE2->E2_FORNECE}"
	cCamposE5 += ",{'E5_LOJA'    , SE2->E2_LOJA}"
	cCamposE5 += ",{'E5_BENEF'   , SE2->E2_NOMFOR}"
	cCamposE5 += ",{'E5_VRETISS' , "+cValToChar(nIss)+"}"
	cCamposE5 += ",{'E5_TIPO'    , SE2->E2_TIPO}"
	cCamposE5 += "}"

	oModelBxP	:= FWLoadModel("FINM020")
	oModelBxP:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
	oModelBxP:Activate()
	oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou não
	oModelBxP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
	oModelBxP:SetValue( "MASTER", "NOVOPROC", .T. ) //Informa que a inclusão será feita com um novo número de processo
	oModelBxP:SetValue( "MASTER", "HISTMOV", STR0095  ) //Informa que a inclusão será feita com um novo número de processo

	oSubFK2 := oModelBxP:GetModel("FK2DETAIL")
	oSubFK4 := oModelBxP:GetModel("FK4DETAIL")
	oSubFK3 := oModelBxP:GetModel("FK3DETAIL")
	oSubFKA := oModelBxP:GetModel("FKADETAIL")

	//Dados da tabela auxiliar com o código do título a pagar
	cChaveTit := xFilial("SE2",SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
	cChaveFK7 := FINGRVFK7( "SE2", cChaveTit )
	cIdFK2	:= FWUUIDV4()
	cIdFK3 := FINFKSID('FK3', 'FK3_IDFK3')
	cIdFK4 := FINFKSID('FK4', 'FK4_IDFK4')

	//Dados do Processo - Define a chave da FK2 no IDORIG
	oSubFKA:SetValue( "FKA_IDORIG", cIdFK2 )
	oSubFKA:SetValue( "FKA_TABORI", "FK2" )

	//Dados da baixa a pagar
	oSubFK2:SetValue( "FK2_DATA"	, dDataBase )
	oSubFK2:SetValue( "FK2_VALOR"	, nIss )
	oSubFK2:SetValue( "FK2_MOEDA"	, StrZero(SE2->E2_MOEDA,2) )
	oSubFK2:SetValue( "FK2_NATURE"	, SE2->E2_NATUREZ )
	oSubFK2:SetValue( "FK2_RECPAG"	, "P" )
	oSubFK2:SetValue( "FK2_TPDOC"	, "BA" )
	oSubFK2:SetValue( "FK2_VLMOE2"	, nIss )
	oSubFK2:SetValue( "FK2_MOTBX"	, "ISS" )
	oSubFK2:SetValue( "FK2_ORIGEM"	, FunName() )
	oSubFK2:SetValue( "FK2_SEQ"		, cSequencia )
	oSubFK2:SetValue( "FK2_DOC"		, cNumBor )
	oSubFK2:SetValue( "FK2_IDDOC"	, cChaveFK7 )
	oSubFK2:SetValue( "FK2_FILORI"	, SE2->E2_FILORIG )
	oSubFK2:SetValue( "FK2_HISTOR"	, STR0095 )

	//---------------------------------------------
	// Grava Imposto Calculado
	//---------------------------------------------
	oSubFK3:SetValue( "FK3_IDFK3" , cIdFk3 )
	oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
	oSubFK3:SetValue( "FK3_ORIGEM", cOrigem )
	oSubFK3:SetValue( "FK3_IMPOS" , "ISS" )
	oSubFK3:SetValue( "FK3_RECPAG", "P" )
	oSubFK3:SetValue( "FK3_MOEDA" , "01" )
	oSubFK3:SetValue( "FK3_VALOR" , nIss )
	oSubFK3:LoadValue("FK3_NATURE", cNaturISS )
	oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG )
	oSubFK3:SetValue( "FK3_BASIMP", SE2->E2_BASEISS )
	oSubFK3:SetValue( "FK3_IDORIG", cIdFK2 )
	oSubFK3:SetValue( "FK3_TABORI", "FK2" )
	oSubFK3:SetValue( "FK3_IDRET" , cIdFK4 )

	//---------------------------------------------
	// Grava Imposto Retido
	//---------------------------------------------
	oSubFK4:SetValue( "FK4_IDFK4" , cIdFk4 )
	oSubFK4:SetValue( "FK4_DATA"  , dDataBAse )
	oSubFK4:SetValue( "FK4_ORIGEM", FunName())
	oSubFK4:SetValue( "FK4_IMPOS" , "ISS" )
	oSubFK4:SetValue( "FK4_RECPAG", "P" )
	oSubFK4:SetValue( "FK4_MOEDA" , StrZero(SE2->E2_MOEDA,2))
	oSubFK4:SetValue( "FK4_VALOR" , nIss )
	oSubFK4:LoadValue("FK4_NATURE", cNaturISS )
	oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
	oSubFK4:SetValue( "FK4_BASIMP", SE2->E2_BASEISS )
	If FK4->(FieldPos("FK4_CLIFOR")) > 0
		oSubFK4:SetValue( "FK4_CLIFOR", SE2->E2_FORNECE )
		oSubFK4:SetValue( "FK4_LOJA", SE2->E2_LOJA )
	EndIf

	If oModelBxP:VldData()
		oModelBxP:CommitData()
		nRecSE5X := oModelBxP:GetValue( "MASTER", "E5_RECNO" )
		SE5->(dbGoto(nRecSE5X))
	Else
		lRet := .F.
	    cLog := cValToChar(oModelBxP:GetErrorMessage()[4]) + ' - '
	    cLog += cValToChar(oModelBxP:GetErrorMessage()[5]) + ' - '
	    cLog += cValToChar(oModelBxP:GetErrorMessage()[6])

	    Help( ,,"M020VALID",,cLog, 1, 0 )
	    DisarmTransaction()
	Endif

	oModelBxP:DeActivate()
	oModelBxP:Destroy()
	oModelBxP := Nil

	If !lRet
		Break
	Endif

	//Contabilizacao da baixa ref valores IRPF
	If lContabil
		//Contabilizacao dos impostos
		If VerPadrao("530") .and. nHdlPrv <= 0

			nHdlPrv := HeadProva( cLote,;
				                      "FINA241" /*cPrograma*/,;
				                      Substr( cUsuario, 7, 6 ),;
				                      @cArquivo,,__aCTBPrv)
		Endif
		If nHdlPrv > 0

			If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
				aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
			Endif
			nTotal += DetProva( nHdlPrv,;
								"530" /*cPadrao*/,;
								"FINA241" /*cPrograma*/,;
								cLote,;
								/*nLinha*/,;
								/*lExecuta*/,;
								/*cCriterio*/,;
								/*lRateio*/,;
								/*cChaveBusca*/,;
								/*aCT5*/,;
								/*lPosiciona*/,;
								@aFlagCTB,;
								/*aTabRecOri*/,;
								__aCTBPrv )

			//Atualiza Flag de contabilização
			If (nTotal > 0) .and. !lUsaFlag

				SE5->(dbGoto(nRecSE5X))
				Reclock("SE5")
				SE5->E5_LA := 'S'
				MsUnLock()

				dbSelectArea( "FK2" )	//Baixas a pagar
				FK2->(dbSetOrder(1))	//FK2_FILIAL, FK2_IDFK2, R_E_C_N_O_, D_E_L_E_T_
				If FK2->(MSSEEK(xFilial("FK2")+ SE5->E5_IDORIG))
					RecLock("FK2")
					FK2_LA := 'S'
					MsUnLock()
				Endif

			EndIf
		Endif
	Endif

	// Grava lançamento da baixa parcial do titulo original ref. impostos
	// como SE2 e SE5 estao posicionados faz PcoDetLan p/ 2 eventos PCO
	PCODetLan("000023","02","FINA241")   //referente baixa parcial SE5
	PCODetLan("000023","01","FINA241")   //referente titulo original

	//Gero titulos a pagar dos imposto ISS
	DbSelectArea("SA2")
	DbSetOrder(1)
	FGrvImpPcc(0,0,0,nRegiOrig,.F.,.T.," ","FINA241",,,0,nIss)

	DbSelectArea("SA2")
	DbSetOrder(1)
	DbSeek(xFilial("SA2")+(SE2->E2_FORNECE+SE2->E2_LOJA))
Endif

cFilAnt := cFilIss
Return .T.


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241BxISS
Ponto de Entrada para a confirmacao da criacao do bordero de impostos e permanecer
na tela de selecao de titulos.

@author Leandro Sousa

@since 13/05/2011
@version 1.0
/*/
//------------------------------------------------------------------------------------
Static Function F241Conf()
Local lF241Conf := ExistBlock("F241CONF")
Local lRet  := .T.

If lF241Conf
  lRet := ExecBlock("F241CONF",.F.,.F.)
Endif

Return lRet


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241PccBx
Vericicacoes referentes ao PCC

@author Mauricio Pequim Jr

@since 27/08/13
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241PccBx()

If __lPCCBaixa == NIL
	__lPCCBaixa	:= SuperGetMv( "MV_BX10925" ,.T.,"2") == "1"
Endif

Return


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} Fa241Top
Define Topo da MsSelect()

@author Mauricio Pequim Jr

@since 27/08/13
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function Fa241Top(nTipo) 

Local cRetorno	:= nil
Local cChaveSE2 	:= (cAliasSE2)->(IndexKey())
Local nAt := If( At("+",cChaveSE2) > 0,At("+",cChaveSE2)-1,Len(cChaveSE2))


// mv_par 02 = Considera Filiais Abaixo
// nTipo = 1 -> Verificando o topo da MsSelect
// nTipo = 2 -> Verificando o fim da Msselect
If "_FILIAL" $ Substr(cChaveSE2,1,nAt)
	cRetorno := IIF(mv_par08==1, IIf(nTipo==1, xFilial("SE2",aSelFil[1]), xFilial("SE2",aSelFil[Len(aSelFil)])), xFilial("SE2",aSelFil[1]))
EndIf

Return(cRetorno )



//-----------------------------------------------------------------------------------------
/*/
{Protheus.doc} FINGFK3BOR
Gravação da tabela FK3.

@author pequim

@since 26/09/2014
@version 1.0
/*/
//-----------------------------------------------------------------------------------------
FUNCTION FINGFK3BOR(nOper,cTabOrig,cIdDoc,aImposRet,lMotorRet,lIRTabProg,cChaveTit,cIdFk2)
	Local cIdFK3 	As Character
	Local nX	 	As Numeric
	Local nLenImp	As Numeric
	Local lContinua As Logical
	Local aAuxFKY 	As Array
	Local aImposBx 	As Array
	Local lRatIRPF	As Logical
	Local nBaseTot  As Numeric
	Local aRatFKW	As Array
	Local nY  		As Numeric
	Local nTRatIrf 	As Numeric

	DEFAULT nOper 		:= 0
	DEFAULT cTabOrig	:= "FK2"
	DEFAULT cIdDoc		:= ""
	DEFAULT aImposRet	:= {}
	DEFAULT lMotorRet	:= .F.
	DEFAULT lIRTabProg  := .F.
	DEFAULT cChaveTit 	:= ""
	DEFAULT cIdFK2 		:= ""

	cIdFK3 		:= ""
	nX	 		:= 0
	lContinua 	:= .T.
	nLenImp		:= Len(aImposRet)
	aAuxFKY 	:= {}
	aImposBx 	:= {}
	lRatIRPF	:= .F.
	nBaseTot	:= 0
	aRatFKW		:= {}
	nY	 		:= 0
	nTRatIrf	:= 0
	
	If lIRTabProg .And. __oRatIRF <> Nil 
		nTRatIrf := Len(__oRatIRF:aRatIRF)
		lRatIRPF := nTRatIrf>1
	EndIf
	
	If __lTemFKY == NIL
		__lTemFKY := AliasInDic("FKY") .and. cPaisLoc == "BRA"
	Endif
	
	IF nOper == 1	//Inclusao

		//gravação da FK7 X FK3
		//Para titulos em bordoro, verifico se existe FK3 anterior
		dbSelectArea("FK3")
		dbSetOrder(2)
		If !lMotorRet .AND. MsSeek(xFilial("FK3")+cTabOrig+cIdDoc)
			lContinua := .F.
		Endif

		If __lFKCodRet == nil 
			__lFKCodRet:= (__lLocBra .and. FK3->(FieldPos("FK3_CODRET")) > 0 .and. FK4->(FieldPos("FK4_CODRET")) > 0)
		EndIf

		If lContinua
			For nX := 1 to nLenImp

				//Houve calculo do imposto - Gravo FK3
				If aImposRet[nX][2] > 0 .Or. lIRTabProg

					cIdFk3 := FINFKSID('FK3','FK3_IDFK3')

					//Gravação da FK7 X FK3
					RecLock("FK3",.T.)

						FK3_FILIAL	:= xFilial("FK3")
						FK3_IDFK3	:= cIdFk3
						FK3_DATA	:= dDataBase
						FK3_VALOR	:= aImposRet[nX,2]
						FK3_MOEDA	:= "01"
						FK3_NATURE	:= aImposRet[nX,3]
						FK3_RECPAG	:= "P"
						FK3_IDRET	:= aImposRet[nx,4]
						FK3_IMPOS	:= aImposRet[nX,1]
						FK3_FILORI	:= SE2->E2_FILORIG
						FK3_BASIMP	:= aImposRet[nX,6]
						FK3_ORIGEM	:= FunName()
						FK3_IDORIG	:= cIdDoc
						FK3_TABORI	:= cTabOrig
						FK3_STATUS 	:= '1'

						If lMotorRet
							FK3_CODFKM	:= aImposRet[nX,8]
							FK3_CLIFOR	:= aImposRet[nX,9]
							FK3_LOJA	:= aImposRet[nX,10]
							FK3_CGC		:= aImposRet[nX,11]
							FK3_RAICGC	:= Substr(aImposRet[nX,11], 1, 8)
						Endif
						If __lFKCodRet .and. Len(aImposRet[nX]) >=12
							FK3_CODRET	:= aImposRet[nX,12]
						EndIf
					MsUnlock()				

					If __lTemFKY .And. Empty(FK3->FK3_IDRET) //Se não houve retenção, grava a FKY somente com a base de calculo (REINF)
						If !lRatIRPF
							aAdd( aImposBx, {FK3->FK3_IMPOS, FK3->FK3_IDFK3 , FK3->FK3_BASIMP, 0, 0, "FK3", {}, 0 } )
						Else
							DbSelectArea("FKW")
							FKW->(DbSetOrder(3)) //FKW_FILIAL+FKW_IDDOC+FKW_TPIMP+FKW_CGC
							For nY := 1 to nTRatIrf
								If FKW->(DBSeek(xFilial("FKW", SE2->E2_FILORIG) + cIdDoc + "IRF   "+FK3->FK3_CGC ) ) .And. AllTrim(FK3->FK3_CGC) == __oRatIRF:aRatIRF[nY][3]
									Aadd(aRatFKW,{__oRatIRF:aRatIRF[nY][3],__oRatIRF:aRatIRF[nY][4],__oRatIRF:aRatIRF[nY][6],FK3->FK3_IDFK3,"FK3"})
									nBaseTot += __oRatIRF:aRatIRF[nY][5]
									Exit
								EndIf
							Next nY
						EndIf
					EndIf
				Endif
			Next

			If Len(aRatFKW)>0
				aAdd( aImposBx, {"IRF   ", "", nBaseTot, 0, 0, "", aRatFKW, 0 } )
			EndIf
		
			//Grava a tabela FKY
			If Len(aImposBx) > 0
				GetPropImp( cChaveTit, aImposBx, 0, @aAuxFKY ) 
				If Len(aAuxFKY) > 0
					FINGFKYBOR( aAuxFKY , nOper ) 
				Endif
			Endif

			//Limpa valores da memoria.
			aSize(aAuxFKY, 0) 	

		Endif
	ElseIf nOper == 2		//Alteracao

		// Gravação da FK7 X FK3
		dbSelectArea("FK3")
		dbSetOrder(2)

		For nX := 1 to nLenImp
			If FK3->(MsSeek(xFilial("FK3")+cTabOrig+cIdDoc+aImposRet[nX,1]))
				RecLock("FK3",.F.)
					FK3->FK3_IDRET	:= aImposRet[nx,4]
				MsUnlock()
				FK3->(dbSkip())
			EndIf
		Next
		
		If __lTemFKY
			FINGFKYBOR(  , nOper, cIdDoc, cIdFK2  ) 
		EndIf

	ElseIf nOper == 3		//Exclusao
		// Gravação da FK7 X FK3
		dbSelectArea("FK3")
		FK3->(dbSetOrder(2))
		For nX := 1 to nLenImp
			FK3->(dbgotop())
			While FK3->(!EOF()) .And. FK3->(MsSeek(xFilial("FK3")+cTabOrig+cIdDoc+aImposRet[nX,1]))
				RecLock("FK3",.F.)
					dbDelete()
				MsUnlock()
			Enddo
		Next nX
		If __lTemFKY
			FINGFKYBOR(  , nOper, cIdDoc,cIdFK2 ) 
		EndIf

	Endif
Return .T.

//------------------------------------------------------------------------------------
/*/
{Protheus.doc} GetCalcIss
Trata parametro MV_MRETISS por filial do titulo de origem

@author Renato Campos

@since 14/04/2017
@version 1.0
/*/
//------------------------------------------------------------------------------------
Static Function GetCalcIss( cFilTit )
Local cFilOld	:= cFilAnt
Local lRet		:= .F.

Default cFilTit := cFilAnt
cFilAnt := cFilTit
If lIsIssBx
	lRet := IsIssBx("P")
Else
	lRet := (SuperGetMv("MV_MRETISS",.F.,"1") == "2")
Endif
cFilAnt := cFilOld

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}F241GrvIMR
Função para cálculo e gravação dos impostos retidos via motor

@author Mauricio Pequim Jr

@returo aImpos - Retencoes do Motor

@since  08/11/2017
@version 12
/*/
//-------------------------------------------------------------------
Function F241GrvIMR(dDataRef As Date, cOrigem As Character, lContabil As Logical, nTotal As Numeric, nHdlprv As Numeric, cArquivo As Character, lUsaFlag As Logical, aFlagCTB as Array, ;
					lPCCMR As Logical, lIrfMR As Logical, lIssMR As Logical) as Numeric

	Local lRet as Logical
	Local nTam As Numeric
	Local nZ As Numeric
	Local nX As Numeric
	Local nBaseImp As Numeric
	Local nRetMotor As Numeric
	Local nRetInc As Numeric
	Local nRecSE5 As Numeric
	Local nRecFK2 As Numeric
	Local aImpos As Array
	Local aArea As Array
	Local aAreaSE2 As Array
	Local aRetOut As Array
	Local aImpMRT As Array
	Local cDocSE2 As Character
	Local cDocKey As Character
	Local cFilBkp As Character
	Local cFilAtu As Character
	Local cFilFwSE2 As Character
	Local cCampos As Character
	Local cChaveTit As Character
	Local cIdFK7 As Character
	Local lGestao As Logical
	Local lF590Impos As Logical
	Local cCodRet As Character


	Default dDataRef := CTOD("//")
	Default cOrigem := 'FINA241'
	Default lContabil := .T.
	Default nTotal := 0
	Default nHdlprv	:= 0
	Default cArquivo := ""
	Default lUsaFlag := .F.
	Default aFlagCTB := {}
	Default lPCCMR := __lPCCMR
	Default lIrfMR := __lIrfMR
	Default lIssMR := __lIssMR

	nTam		:= 0
	nZ			:= 0
	nX		 	:= 0
	nBaseImp	:= 0
	nRetMotor	:= 0
	nRetInc 	:= 0
	nRecSE5		:= 0
	nRecFK2		:= 0
	cFilBkp		:= cFilAnt
	aImpos		:= {}
	aRetOut		:= {}
	aImpMRT		:= {}
	aArea		:= GetArea()
	aAreaSE2  	:= SE2->( GetArea() )
	cDocSE2		:= ""
	cDocKey		:= ""
	cFilAtu		:= cFilAnt
	lGestao		:= FWSizeFilial() > 2
	cFilFwSE2	:= IIF( lGestao, FwFilial("SE2") , xFilial("SE2") )
	lF590Impos	:= IsInCallStack( "F590Impost" ) .OR. IsInCallStack( "FA590CANC" )
	cCampos		:= ""
	lRet		:= .T.
	cCodRet		:= ""

	If __lFKCodRet == nil 
		__lFKCodRet:= (__lLocBra .and. FK3->(FieldPos("FK3_CODRET")) > 0 .and. FK4->(FieldPos("FK4_CODRET")) > 0)
	EndIf

	//Recupera Base de Retencao
	aRetInc		:= FinBaseMR(SE2->E2_SALDO, .F., SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, lPCCMR, lIrfMR, .f., lIssMR, .F. /*_lCidMR*/, .F. /*_lSesMR*/ )
	nBaseImp	:= aRetInc[1]

	//busca chave p/ verificar se j?houve reten?o, se conf reten?o na 1?baixa
	cChaveTit := xFilial("SE2",SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
	cIdFK7 := FINGRVFK7("SE2", cChaveTit)

	//Calculo Motor de retencoes.
	aImpos	:= FINCalImp("1", SE2->E2_NATUREZ, SE2->E2_FORNECE, SE2->E2_LOJA, cFilAnt, nBaseImp, dDataRef, .T.,/*aBaseImp*/,SE2->E2_TIPO, cChaveTit, cIdFK7, {} )
	nTam	:= Len(aImpos)

	For nZ := 1 To nTam

		cCampos := ""
		aRetOut := Aclone(aImpos [nZ,7])

		Do Case
			Case aImpos[nZ,8] == "PIS" .And. aImpos[nZ,9] == "2"
				nRetMotor += aImpos[nZ,5]
				cCampos := ",{'E5_VRETPIS'	, "  + cValToChar(aImpos[nZ,5])	+ "}"
				cCampos += ",{'E5_PRETPIS'	, '4'}"

			Case aImpos[nZ,8] == "COF" .And. aImpos[nZ,9] == "2"
				nRetMotor += aImpos[nZ,5]
				cCampos := ",{'E5_VRETCOF'	, "  + cValToChar(aImpos[nZ,5])	+ "}"
				cCampos += ",{'E5_PRETCOF'	, '4'}"

			Case aImpos[nZ,8] == "CSL" .And. aImpos[nZ,9] == "2"
				nRetMotor += aImpos[nZ,5]
				cCampos := ",{'E5_VRETCSL'	, "  + cValToChar(aImpos[nZ,5])	+ "}"
				cCampos += ",{'E5_PRETCSL'	, '4'}"

			Case aImpos[nZ,8] == "IRF" .And. aImpos[nZ,9] == "2"
				nRetMotor += aImpos[nZ,5]
				cCampos := ",{'E5_BASEIRF'	, "  + cValToChar(aImpos[nZ,4])		+ "}"
				cCampos += ",{'E5_VRETIRF'	, "  + cValToChar(aImpos[nZ,5])		+ "}"
				cCampos += ",{'E5_PRETIRF'	, '4'}"

			Case aImpos[nZ,8] == "INSS" .And. aImpos[nZ,9] == "2"
				nRetMotor += aImpos[nZ,5]

			Case aImpos[nZ,8] == "ISS" .And. aImpos[nZ,9] == "2"
				nRetMotor += aImpos[nZ,5]

			Case aImpos[nZ,9] == "2"
				nRetMotor += aImpos[nZ,5]
		End Case

		//Caso tenha retenção, gravo uma baixa por imposto.
		If aImpos[nZ,5] > 0 .And. aImpos[nZ,9] == "2"

			//Seleção de filiais
			If !Empty( SE2->E2_FILORIG ) .And. ( lF590Impos .Or. mv_par08 == 1 )

				If (cFilAnt <> SE2->E2_FILORIG) .and. !Empty(nHdlPrv) .and. lContabil .and. (nTotal > 0)

					nRecSE2 := SE2->(RECNO())

					cA100Incl( cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, (mv_par07 == 1) /*lDigita*/, .F. /*lAglut*/, /*cOnLine*/,;
								/*dData*/, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, /*aDiario*/ )

					aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
					nTotal := 0
					SE2->( dbGoto( nRecSE2 ) )
				EndIf

				cFilAnt  := SE2->E2_FILORIG
				cFilOrig := SE2->E2_FILORIG
			EndIf

			//Grava a baixa dos impostos calculados pelo o motor de retenção.
			oModelMov	:= FWLoadModel("FINM020")
			oModelMov:SetOperation( 3 ) //Inclusao
			//Gero o ID do documento - Titulo a Pagar
			cDocSE2 := xFilial("SE2", SE2->E2_FILORIG) 	+ "|"
			cDocSE2 += SE2->E2_PREFIXO 	+ "|"
			cDocSE2 += SE2->E2_NUM 		+ "|"
			cDocSE2 += SE2->E2_PARCELA 	+ "|"
			cDocSE2 += SE2->E2_TIPO 	+ "|"
			cDocSE2 += SE2->E2_FORNECE 	+ "|"
			cDocSE2 += SE2->E2_LOJA

			cDocKey := FINGRVFK7("SE2",cDocSE2)

			//Array para gravacao dos impostos FK3
			aImpMRT := {aImpos[nZ,8],aImpos[nZ,3] ,aImpos[nZ,10],"", aImpos[nZ,5], aImpos[nZ,2], aImpos[nZ,4] }
			cCamposE5 := ""

			oModelMov:Activate()
			oSubFKA  := oModelMov:GetModel("FKADETAIL")
			oSubFK2  := oModelMov:GetModel("FK2DETAIL")
			oSubFK3  := oModelMov:GetModel("FK3DETAIL")
			oSubFK4  := oModelMov:GetModel("FK4DETAIL")

			cSequencia := FaNxtSeqBx("SE2")  // Sequencia da baixa do adiantamento + 1

			cCamposE5 := " { "
			cCamposE5 += " {'E5_PREFIXO'	, '" + SE2->E2_PREFIXO		+ "'}"
			cCamposE5 += ",{'E5_NUMERO'		, '" + SE2->E2_NUM			+ "'}"
			cCamposE5 += ",{'E5_PARCELA'	, '" + SE2->E2_PARCELA		+ "'}"
			cCamposE5 += ",{'E5_CLIFOR'		, '" + SE2->E2_FORNECE		+ "'}"
			cCamposE5 += ",{'E5_LOJA'		, '" + SE2->E2_LOJA			+ "'}"
			cCamposE5 += ",{'E5_BENEF'		, '" + SE2->E2_NOMFOR		+ "'}"
			cCamposE5 += ",{'E5_FORNECE'	, '" + SE2->E2_FORNECE		+ "'}"
			cCamposE5 += ",{'E5_TIPO'		, '" + SE2->E2_TIPO			+ "'}"
			cCamposE5 += ",{'E5_DTDIGIT'	, STOD('" + DTOS(dDataBase) + "')}"
			cCamposE5 += ",{'E5_DTDISPO'	, STOD('" + DTOS(dDataBase) + "')}"
			cCamposE5 += ",{'E5_DOCUMEN'	, '" + cNumBor				+ "'}"

			If !Empty(cCampos)
				cCamposE5 += cCampos
			Endif

			cCamposE5 += "}"

			//Dados do Processo - Define a chave da FK2 no IDORIG
			If !oSubFKA:IsEmpty()
				oSubFKA:AddLine()
			Endif

			cIdFK2 := FWUUIDV4()
			oSubFKA:SetValue( "FKA_IDORIG", cIdFK2 )
			oSubFKA:SetValue( "FKA_TABORI", "FK2" )

			//Informacoes da baixa
			oSubFK2:SetValue( "FK2_IDDOC"	, cDocKey					)
			oSubFK2:SetValue( "FK2_DATA"	, dDataBase 				)
			oSubFK2:SetValue( "FK2_VALOR"	, aImpos[nZ,5]				)
			oSubFK2:SetValue( "FK2_VLMOE2"	, aImpos[nZ,5]				)
			oSubFK2:LoadValue( "FK2_NATURE"	, SE2->E2_NATUREZ	 		)
			oSubFK2:SetValue( "FK2_RECPAG"	, "P" 						)
			oSubFK2:SetValue( "FK2_TPDOC"	, "BA" 						)
			oSubFK2:SetValue( "FK2_ORIGEM"  , cOrigem 					)
			oSubFK2:SetValue( "FK2_HISTOR"	, STR0122 					) //Baixa Ger.Impostos-Bordero
			oSubFK2:SetValue( "FK2_MOTBX"	, "IMR"  					)
			oSubFK2:SetValue( "FK2_SEQ"		, cSequencia  				)
			oSubFK2:SetValue( "FK2_FILORI"	, SE2->E2_FILORIG	 		)
			oSubFK2:SetValue( "FK2_MOEDA"   , StrZero(SE2->E2_MOEDA,2)	)
			oSubFK2:SetValue( "FK2_DOC"     , cNumBor 					)

			//Houve calculo de impostos PCC
			If aImpMRT[2] > 0
				cIdFk3 := FINFKSID('FK3','FK3_IDFK3')

				//Houve retencao de impostos PCC
				If aImpMRT[5] > 0
					cIdFK4:= FINFKSID('FK4','FK4_IDFK4')
					aImpMRT[4] := cIdFK4
					aImpos[nZ,6] := cIdFK4
				Endif

				If !oSubFK3:IsEmpty()
					//Inclui a quantidade de linhas necessárias
					oSubFK3:AddLine()
					//Vai para linha criada
					oSubFK3:GoLine( oSubFK3:Length() )
				Endif

				//---------------------------------------------
				// Grava Imposto Calculado
				//---------------------------------------------
				oSubFK3:LoadValue( "FK3_IDFK3" , cIdFK3			)
				oSubFK3:LoadValue( "FK3_DATA"  , dDataBase		)
				oSubFK3:LoadValue( "FK3_ORIGEM", cOrigem		)
				oSubFK3:LoadValue( "FK3_IMPOS" , aImpMRT[1]		)
				oSubFK3:LoadValue( "FK3_RECPAG", "P"			)
				oSubFK3:LoadValue( "FK3_MOEDA" , "01"			)
				oSubFK3:LoadValue( "FK3_VALOR" , aImpMRT[2]		)
				oSubFK3:LoadValue( "FK3_NATURE", aImpMRT[3]		)
				oSubFK3:LoadValue( "FK3_FILORI", SE2->E2_FILORIG )
				oSubFK3:LoadValue( "FK3_BASIMP", aImpMRT[6]		)
				oSubFK3:LoadValue( "FK3_IDORIG", cIdFK2			)
				oSubFK3:LoadValue( "FK3_TABORI", "FK2"			)
				oSubFK3:LoadValue( "FK3_IDRET" , aImpMRT[4]		)
				If __lMotorRet
					oSubFK3:LoadValue( "FK3_CODFKM", aImpos[nZ,1] 	)
					oSubFK3:LoadValue( "FK3_CLIFOR", SA2->A2_COD    )
					oSubFK3:LoadValue( "FK3_LOJA"  , SA2->A2_LOJA   )
					oSubFK3:LoadValue( "FK3_CGC"   , SA2->A2_CGC    )
					oSubFK3:LoadValue( "FK3_RAICGC", Substr(SA2->A2_CGC, 1, 8) )
				EndIf
				If __lFKCodRet .and. Len(aImpos[nZ])>=23 
					oSubFK3:SetValue( "FK3_CODRET" , aImpos[nZ,23] )
				EndIf 

				//---------------------------------------------
				// Grava Imposto Retido
				//---------------------------------------------
				If aImpMRT[5] > 0   //Houve retencao
					If !oSubFK4:IsEmpty()
						//Inclui a quantidade de linhas necessárias
						oSubFK4:AddLine()
						//Vai para linha criada
						oSubFK4:GoLine( oSubFK4:Length() )
					Endif

					oSubFK4:LoadValue( "FK4_IDFK4" , aImpMRT[4]	)
					oSubFK4:LoadValue( "FK4_DATA"  , dDataBase		)
					oSubFK4:LoadValue( "FK4_ORIGEM", cOrigem		)
					oSubFK4:LoadValue( "FK4_IMPOS" , aImpMRT[1]	)
					oSubFK4:LoadValue( "FK4_RECPAG", "P"			)
					oSubFK4:LoadValue( "FK4_MOEDA" , "01"			)
					oSubFK4:LoadValue( "FK4_VALOR" , aImpMRT[5]	)
					oSubFK4:LoadValue( "FK4_NATURE", aImpMRT[3]	)
					oSubFK4:LoadValue( "FK4_FILORI", SE2->E2_FILORIG )
					oSubFK4:LoadValue( "FK4_BASIMP", aImpMRT[7]	)
					oSubFK4:LoadValue( "FK4_CODFKM", aImpos[nZ,1] )
					oSubFK4:LoadValue( "FK4_CLIFOR", SA2->A2_COD    )
					oSubFK4:LoadValue( "FK4_LOJA"  , SA2->A2_LOJA   )
					oSubFK4:LoadValue( "FK4_CGC"   , SA2->A2_CGC    )
					oSubFK4:LoadValue( "FK4_RAICGC", Substr(SA2->A2_CGC, 1, 8) )

					If __lFKCodRet .and. Len(aImpos[nZ])>=23
						oSubFK4:SetValue( "FK4_CODRET" , aImpos[nZ,23] )
					EndIf 

					// Atualizacao de retencao da FK3 - Cumulatividade
					nLenRet := Len(aRetOut)
					If nLenRet > 0
						For nX := 1 to nLenRet
							If aRetOut[nX] > 0
								FK3->(DbGoTo(aRetOut[nX]))
								RecLock("FK3")
								FK3->FK3_IDRET := aImpMRT[4]
								FK3->(MsUnlock())
							EndIf
						Next nX
					Endif
				Endif
			Endif

			oModelMov:SetValue( "MASTER", "E5_GRV", .T. )   //Informa se vai gravar SE5 ou não
			oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
			oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Informa que a inclusão será feita com um novo número de processo

			If oModelMov:VldData()
				oModelMov:CommitData()
				SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
				nRecSE5 := SE5->(Recno())
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])

				Help( ,,"F241MIIMR",,cLog, 1, 0 )
				DisarmTransaction()
			Endif

			oModelMov:DeActivate()
			oModelMov:Destroy()
			oModelMov := NIL

			If !lRet
				Break
			Endif

			//Posiciono SE5 e FK2
			SE5->(dbGoTo(nRecSE5))
			FK2->(dbSetOrder(1))
			FK2->(MsSeek(xFilial("FK2")+cIdFK2))
			nRecFK2 := FK2->(RECNO())

			//Contabilizacao da baixa ref valores Impostos
			If lContabil
				//Contabilizacao dos impostos
				If VerPadrao("530") .and. nHdlPrv <= 0
					nHdlPrv := HeadProva( cLote,"FINA241", Substr( cUsuario, 7, 6 ), @cArquivo )
				EndIf

				If nHdlPrv > 0
					// Prepara Lancamento Contabil
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E5_LA" , "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
						aAdd( aFlagCTB, {"FK2_LA", "S", "FK2", FK2->( Recno() ), 0, 0, 0} )
					Endif

					nTotal += DetProva( nHdlPrv, "530" /*cPadrao*/, "FINA241" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/,;
										/*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, 	/*aDadosProva*/ )

					// Grava lançamento da baixa parcial do titulo original ref. impostos
					// como SE2 e SE5 estao posicionados faz PcoDetLan p/ 2 eventos PCO
					PCODetLan("000023","02","FINA241")   //referente baixa parcial SE5
					PCODetLan("000023","01","FINA241")   //referente titulo original
				Endif

			Endif

			IF EMPTY(SE5->E5_LA) .AND. nTotal > 0 .AND. !lUsaFlag
				SE5->(dbGoTo(nRecSE5))
				Reclock("SE5")
				E5_LA := "S"
				MsUnlock()

				FK2->(dbGoTo(nRecFK2))
				Reclock("FK2")
				REPLACE FK2_LA With "S"
				MsUnlock()

			ENDIF

		ElseIf aImpos[nZ,3] > 0 .And. aImpos[nZ,9] == "2"		//teve calculo mas não retenção

			//Gero o ID do documento - Titulo a Pagar
			cDocSE2 := xFilial("SE2",SE2->E2_FILORIG) 	+ "|"
			cDocSE2 += SE2->E2_PREFIXO 	+ "|"
			cDocSE2 += SE2->E2_NUM 		+ "|"
			cDocSE2 += SE2->E2_PARCELA 	+ "|"
			cDocSE2 += SE2->E2_TIPO 	+ "|"
			cDocSE2 += SE2->E2_FORNECE 	+ "|"
			cDocSE2 += SE2->E2_LOJA

			cDocKey := FINGRVFK7("SE2",cDocSE2)

			If __lFKCodRet .and. Len(aImpos[nZ])>=23
				cCodRet := aImpos[nZ,23] 
			EndIf 

			aadd(aImpMRT, {	aImpos[nZ,8],  ;	//[1] = Tipo do Imposto (FOO)
							aImpos[nZ,3],  ;	//[2] = Valor calculado do imposto
							aImpos[nZ,10], ;	//[3] = Natureza do imposto
							aImpos[nZ,6],  ;	//[4] = IDRET FK4
							aImpos[nZ,5],  ;	//[5] = Valor a reter do imposto
							aImpos[nZ,2],  ;	//[6] = Base do imposto
							aImpos[nZ,4],  ;	//[7] = Base de retenção do imposto
							aImpos[nZ,1],  ;	//[8] = Codigo do tipo de imposto (FKM_CODIGO)
							SA2->A2_COD ,  ;	//[9] = Código do Fornecedor
							SA2->A2_LOJA,  ;	//[10] = Loja do Fornecedor
							SA2->A2_CGC,   ;	//[11] = CNPJ do Fornecedor
							cCodRet		    } )	//[12] = Codigo de retenção

			FINGFK3BOR(1 , "FK7", cDocKey, aImpMRT, .T.) 

			aImpMRT := {}
		Endif

	Next nZ

	If nRetMotor > 0

  		RecLock("SE2")

		Replace E2_SALDO	With E2_SALDO - nRetMotor
		Replace E2_BAIXA	With dDataBase
		Replace E2_VALLIQ	With nRetMotor

		MsUnlock()

		//Gero titulos a pagar dos impostos
		DbSelectArea("SA2")
		DbSetOrder(1)

		FinSetAPrc("FK2")
		FinGrvImp("1", SE2->(RecNo()), aImpos, "FINA241", .F., {}, {}, .T., .F., .T., dDataRef, "FK2")
		FinSetAPrc("")

	EndIf

	cFilAnt := cFilAtu

	If __lMT103FRT .And. !Empty( cFilFwSE2 )
		RestArea(aArea)
	EndIf

	RestArea(aAreaSE2)

Return nRetMotor


//----------------------------------------------------------------------------------------------
/*/{Protheus.doc}F241ImpCnf
Função para verificação dos impostos configurados via Motor de Retenção

@author Mauricio Pequim Jr

Parametros
cCart - Carteira (1 = Pagar ou 2 = Receber)
cFilOrig - Filial de origem do titulo
cCliFor - Código do Cliente/Fornecedor
cLoja - Loja do Cliente/Fornecedor
cNatur - Natureza do título (principal)
cTipo - Tipo do Título

@return aImpConf - Retencoes configuradas no Motor para Natureza/Fornecedor

@since  28/12/2017
@version 12
/*/
//----------------------------------------------------------------------------------------------
Function F241ImpCnf(cCart As Character,cFilOrig As Character,cCliFor As Character,cLoja As Character, cNatur As Character, cTipo As Character) As Array

Local aImpConf As Array
Local nZ As Numeric

aImpConf := {}
nZ := 0

__lPccMR 	:= .F.
__lIrfMR	:= .F.
__lIssMR	:= .F.

//Valida quais os impostos configurados pelo motor de retenções
aImpConf := FinImpConf("1", SE2->E2_FILORIG, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ)

For nZ := 1 to Len(aImpConf)
	Do Case
		Case aImpConf[nZ,1] $ "PIS|COF|CSL"
			__lPccMR := .T.

		Case aImpConf[nZ,1] == "IRF"
			__lIrfMR := .T.

		Case aImpConf[nZ,1] == "ISS"
			__lIssMR := .T.
	End Case
Next

Return aImpConf



//----------------------------------------------------------------------------------------------
/*/{Protheus.doc}F241VImpMR
Função para verificação dos impostos configurados via Motor de Retenção

@author Mauricio Pequim Jr

@since  10/01/2018
@version 12
/*/
//----------------------------------------------------------------------------------------------
Function F241VImpMR(aRetencao As Array, lFina590 As Logical, cBor2Can As Character, lIrfMR As Logical )

Local cChaveFK7 As Character
Local cChaveTit As Character
Local cAliasFK2 As Character
Local aAreaSE5 aS Array
Local aImpBx2Can As Array

DEFAULT aRetencao := {}
DEFAULT aImpBx2Can := {}
DEFAULT lFina590 := .F.
DEFAULT cBor2Can := MV_PAR01
DEFAULT lIrfMR := __lIrfMR

//Dados da tabela auxiliar com o código do título a pagar
cChaveTit := xFilial("SE2", SE2->E2_FILORIG) + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM     + "|" + SE2->E2_PARCELA + "|" + ;
	              			SE2->E2_TIPO     + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
cChaveFK7 := FINGRVFK7( "SE2", cChaveTit )

cAliasFK2 := ""
aAreaSE5 := SE5->(GetArea())

If __oPreparB == nil

	cQuery 	:= "SELECT FK2_FILORI, FK2_IDFK2, FK2_SEQ FROM "+ RetSqlName("FK2") +" FK2 "
	cQuery 	+= "WHERE FK2_IDDOC = ? AND"
	cQuery 	+= " FK2_MOTBX = 'IMR' AND"
	cQuery 	+= " FK2_DOC = ? AND"
	cQuery 	+= " FK2_RECPAG = 'P' AND"
	cQuery 	+= " D_E_L_E_T_ = ' ' "

	cQuery	+= " AND NOT EXISTS( "
	cQuery	+= " SELECT FK2EST.FK2_IDDOC FROM " + RetSqlName("FK2") +" FK2EST"
	cQuery	+= " WHERE FK2EST.FK2_IDDOC = ? "
	cQuery 	+= " AND FK2EST.FK2_MOTBX = 'IMR' "
	cQuery 	+= " AND FK2EST.FK2_DOC = ? "
	cQuery	+= " AND FK2EST.FK2_SEQ = FK2.FK2_SEQ "
	cQuery	+= " AND FK2EST.FK2_TPDOC = 'ES' "
	cQuery	+= " AND FK2EST.D_E_L_E_T_ = ' ') "

	cQuery 	:= ChangeQuery(cQuery)
	__oPreparB:=FWPreparedStatement():New(cQuery)
Endif

__oPreparB:SetString(1,cChaveFK7)
__oPreparB:SetString(2,cBor2Can)
__oPreparB:SetString(3,cChaveFK7)
__oPreparB:SetString(4,cBor2Can)

cQuery := __oPreparB:GetFixQuery()

cAliasFK2 := mpsysopenquery(cQuery)

dbSelectArea(cAliasFK2)

If (cAliasFK2)->(!Eof())
	SE5->(dbSetOrder(21))	//E5_FILIAL, E5_IDORIG, E5_TIPODOC
	//Pego os Recnos da SE5 a serem cancelados
	While (cAliasFK2)->(!Eof())
		If SE5->(MsSeek(xFilial("SE5",(cAliasFK2)->FK2_FILORI) + (cAliasFK2)->FK2_IDFK2 ))
			aadd(aImpBx2Can,SE5->(Recno()) )
		Endif
		(cAliasFK2)->(DbSkip())
	EndDo
	If lFina590
		AAdd(aRetencao, {SE2->(Recno()),SE2->E2_FORNECE,SE2->E2_LOJA,DTOS(SE2->E2_VENCREA),lIrfMR,.T.,aImpBx2Can})
	Else
		aadd(aRetencao,{SE2->(Recno()),SE2->(E2_FORNECE + E2_LOJA),,.T.,aImpBx2Can} )
	Endif
Else
	aadd(aImpBx2Can, 0 )
Endif

(cAliasFK2)->(dbCloseArea())

Return

//------------------------------------------------------------------------------------
/*/
{Protheus.doc} F241CanIMR
Cancela os impostos gerados pelo bordero - Motor de Retenções

@author Mauricio Pequim Jr

@since 28/01/05
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function F241CanIMR(nTotal,nHdlPrv,cArquivo,lContabil,lUsaFlag,aFlagCTB,cNumBord,aImpBx2Can)

Local aArea 	:= GetArea()
Local lCancelou	:= .F.
Local nValBaix	:= 0
Local nX		:= 0
Local lCtblizou := .T.
Local cFilAtu	:= FWGETCODFILIAL
Local oModelMov	:= Nil
Local oSubFKA	:= Nil
Local cLog 		:= ""
Local lRet 		:= .T.

DEFAULT lContabil 	:= .T.
DEFAULT nTotal		:= 0
DEFAULT nHdlPrv		:= 0
DEFAULT cArquivo	:= ""
DEFAULT lUsaFlag	:= .F.
DEFAULT aFlagCtb	:= {}
DEFAULT cNumBord	:= mv_par01  //Numero do bordero no cancelamento de borderos da FINA241
DEFAULT aImpBx2Can	:= {}

// Zerar ABATIMENTO para contabilizacao.
ABATIMENTO := 0

SA2->(dbSeek(xFilial("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA))

nLenFK2 := Len(aImpBx2Can)

IF nLenFK2 > 0
	For nX := 1 to nLenFK2

		If aImpBx2Can[nX] == 0
			Loop
		Endif

		dbSelectArea("SE5")
		SE5->(dbGoto(aImpBx2Can[nX]))

		lCancelou := .F.
		lCtblizou := .T.

		nValBaix	:= SE5->E5_VALOR
		lCtblizou	:= (SE5->E5_LA = "S ")
		cFilAnt		:= SE5->E5_FILORIG
		cIdOrig		:= SE5->E5_IDORIG

		//Verifico os registros de impostos de outros titulos que foram retidos nessa baixa
		FMRVOutImp("FK2", cIdOrig, cNumBord)

		//Cancelo a baixa dos impostos com regra no Motor de Retenções
		oModelMov := FWLoadModel("FINM020") //Recarrega o Model de movimentos para pegar o campo do relacionamento (SE5->E5_IDORIG)
		oModelMov:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
		oModelMov:Activate()
		oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
		//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
		//E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
		//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
		oModelMov:SetValue( "MASTER", "E5_OPERACAO", 1 )
		oModelMov:SetValue( "MASTER", "HISTMOV"    , STR0127 )	//"Estorno Baixa Ger.Impostos-Bordero"

		//Posiciona a FKA com base no IDORIG da SE5 posicionada
		oSubFKA := oModelMov:GetModel( "FKADETAIL" )
		If oSubFKA:SeekLine( { {"FKA_IDORIG", cIdOrig } } )
			If oModelMov:VldData()
				oModelMov:CommitData()
				SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])

				Help( ,,"F241MRVLD",,cLog, 1, 0 )
				DisarmTransaction()
			Endif
		Endif

		oModelMov:DeActivate()
		oModelMov:Destroy()
		oModelMov := Nil

		If !lRet
			Break
		Endif

		// Grava lançamento referente ao titulo original ja atualizado
		// lançamento PCO para acertar valor titulo original (alteracao)
	   	PCODetLan("000023","01","FINA241")   //referente titulo original

		//Deleto os titulos de impostos e a FK0 desta baixa
		dbSelectArea("SE2")
		FMRDelImp("FK2", cIdOrig)

		//Se a baixa foi cancelada, retorno o saldo para o titulo
		SA2->(dbSetOrder(1))
		SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))

		If SE2->E2_MOEDA > 1
			nValBaix := xMoeda(nValBaix,1,SE2->E2_MOEDA,dDataBase,3,1,SE2->E2_TXMOEDA)
		EndIf

		RecLock("SE2")
		SE2->E2_SALDO += nValBaix
		If STR(SE2->E2_SALDO,17,2) == STR(SE2->E2_VALOR,17,2)
			SE2->E2_BAIXA := CTOD("//")
		Endif
		SE2->E2_DESCONT := 0
		SE2->E2_MULTA	:= 0
		SE2->E2_JUROS	:= 0
		SE2->E2_CORREC	:= 0
		SE2->E2_VALLIQ	:= nValBaix
		MsUnlock()

		//Contabilizacao dos impostos
		If lContabil .And. lCtblizou
			If VerPadrao("531") .and. nHdlPrv <= 0
				nHdlPrv := HeadProva( cLote,;
				                      "FINA241" /*cPrograma*/,;
				                      Substr( cUsuario, 7, 6 ),;
				                      @cArquivo )
			Endif
			If nHdlPrv > 0

				If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
					aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
					aAdd( aFlagCTB, {"FK2_LA", "S", "FK2", FK2->( Recno() ), 0, 0, 0} )
				Endif
				nTotal += DetProva( nHdlPrv,;
				                    "531" /*cPadrao*/,;
				                    "FINA241" /*cPrograma*/,;
				                    cLote,;
				                    /*nLinha*/,;
				                    /*lExecuta*/,;
				                    /*cCriterio*/,;
				                    /*lRateio*/,;
				                    /*cChaveBusca*/,;
				                    /*aCT5*/,;
				                    /*lPosiciona*/,;
				                    @aFlagCTB,;
				                    /*aTabRecOri*/,;
				                    /*aDadosProva*/ )

			Endif
		Endif

		// Exclui lançamento da baixa  parcial do titulo original ref. impostos
		PCODetLan("000023","02","FINA241", .T.)   //referente baixa parcial SE5
	Next
EndIF

cFilAnt := cFilAtu

RestArea(aArea)

Return


//------------------------------------------------------------------------------------
/*/
{Protheus.doc} Fa241Filho
Verifica se existe titulo filho (titulo de taxa) e se este sofreu baixa.

@author Mauricio Pequim Jr

@since 28/01/05
@version 1.0
/*/
//------------------------------------------------------------------------------------
Function Fa241Filho(lVerBaixa)

Local lRet			:= .T.
Local aTps			:= {}
Local aParc			:= {}
Local nX			:= 0
Local cPrefixo		:= SE2->E2_PREFIXO
Local cNum			:= SE2->E2_NUM
Local aAreaSe2		:= SE2->(GetArea())
Local cTitPai		:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
Local lForLjIss		:= !Empty(SE2->(E2_FORNISS+E2_LOJAISS))
Local lIRPFBaixa	:= If(__lLocBra, SA2->A2_CALCIRF == "2", .F.) .And. !(SE2->E2_TIPO $ MVPAGANT)
Local lPccBaixa		:= GetNewPar("MV_BX10925","2") == "1"
Local lCalcIssBx	:= IsIssBx("P")
Local lCb10925		:= GetNewPar("MV_CB10925","2") == "1"
Local cNatIRF		:= ALLTRIM(GETMV("MV_IRF",,""))
Local cNatISS		:= GETMV("MV_ISS",,"")
Local cNatPCC		:= GETMV("MV_PISNAT",,"") + "|" + GETMV("MV_CSLL",,"") + "|" + GETMV("MV_COFINS",,"")
Local AreaAtu		:= {}
Local lFINA590		:= FwIsInCallStack("FINA590")
Local cTitImp		:= ""

Default lVerBaixa := .F.

aTps  := {"INS","SES"}
aParc := {SE2->E2_PARCINS, SE2->E2_PARCSES}

If lCalcIssBx
	Aadd(aParc, SE2->E2_PARCISS)
	Aadd(aTps , "ISS")
EndIf

If __lLocBra
	Aadd(aTps,"CID")
	Aadd(aParc,SE2->E2_PARCCID)
EndIf

Aadd(aParc, SE2->E2_PARCPIS)
Aadd(aParc, SE2->E2_PARCCOF)
Aadd(aParc, SE2->E2_PARCSLL)
Aadd(aTps , "TX ")
Aadd(aTps , "TX ")
Aadd(aTps , "TX ") // aTps deve ter o mesmo tamanho de aParc

If lIRPFBaixa
	Aadd(aParc, SE2->E2_PARCIR)
	Aadd(aTps , "TX ")
EndIf

SE2->(DbSetOrder(1))

If !lCb10925
	For nX := 1 to Len(aTps)
		// Se encontrou o titulo filho (titulo de tributo) e este sofreu baixa,
		// Nao permite a exclusao do titulo pai (titulo principal).
		If aTps[nX] == 'ISS' .and. lCalcIssBx .and. lForLjIss  .and. !lFINA590
			AreaAtu := GetArea()
			If Select("__SE2") == 0
				ChkFile("SE2",.F.,"__SE2")
			Else
				dbSelectArea("__SE2")
			EndIf
			__SE2->(DbSetOrder(1))
			If !Empty(aParc[nx]) .And. __SE2->(Msseek(xFilial("SE2") + cPrefixo + cNum + aParc[nX] + aTps[nX]))
				
				cTitImp := xFilial("SE2") + cPrefixo + cNum + aParc[nX] + aTps[nX]

				While __SE2->(!Eof()) .And. __SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO) == cTitImp
					//Se nao existir E2_TITPAI, valida da forma antiga
					//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
					//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
					If (If(!Empty(__SE2->(E2_TITPAI)), Alltrim(__SE2->(E2_TITPAI)) == cTitPai,.T.)) .and. ;
						(!lVerBaixa .Or. __SE2->E2_SALDO != __SE2->E2_VALOR)
						lRet := .F.
						Exit
					Endif
					__SE2->(dbSkip())
				Enddo
			Endif
			RestArea(AreaAtu)
			If !lRet
				Exit
			Endif
		ElseIf !Empty(aParc[nx]) .And. SE2->(Msseek(xFilial("SE2")+ cPrefixo + cNum + aParc[nX] + aTps[nX])) .And.;
				( !lVerBaixa .Or. SE2->E2_SALDO != SE2->E2_VALOR ) .And. ;
				( (lIRPFBaixa .AND. ALLTRIM(SE2->E2_NATUREZ) $ cNatIrf ) .OR.;
				(lPccBaixa  .AND. ALLTRIM(SE2->E2_NATUREZ) $ cNatPcc ) .OR.;
				(lCalcIssBx .AND. ALLTRIM(SE2->E2_NATUREZ) $ cNatISS )  ) 
			
			lRet := .F.
			Exit
		Endif

	Next
Endif
SE2->(RestArea(aAreaSe2))

Return lRet

//----------------------------------------
/*/{Protheus.doc} $F241CHKTCB
Valida se o banco, agencia e conta 
estão configurados para transmissão 
do borderô via TCB

@author Robson
@since 10/09/2020
@version 12
/*/
//----------------------------------------
Static Function F241CHKTCB(oCbx, oApi, nOpc)
	Local aArea As Array
	Local oLayout As Object
	Default nOpc := 0 //controle para recarregar a  lChkTCB e lChkAPI
	
	//Inicializa variáveis
	aArea   := GetArea()
	oLayout := JsonObject():new()
	lLibTCB := .F.
	lLibAPI := .F.

	//alterou o banco, então reinicia as variaveis
	If nOpc == 1
		lChkTCB := .F.
		lChkAPI := .F.
	EndIf
	
	dbSelectArea("SA6")
	SA6->(DbSetOrder(1))
	
	If SA6->(FieldPos("A6_TCB")) > 0
		lLibTCB := (SA6->(DbSeek(xFilial("SA6")+cPort240+cAgen240+cConta240)) .And. SA6->A6_TCB == "1")
	EndIf
	
	If SA6->(FieldPos("A6_CFGAPIP")) > 0
		lLibAPI := (SA6->(DbSeek(xFilial("SA6")+cPort240+cAgen240+cConta240)) .And. SA6->A6_CFGAPIP $ "1|3")
		If lLibAPI
			oLayout:FromJson(SA6->A6_CFGBOLP)  
			If oLayout:hasProperty('credentials') .And. oLayout['credentials']:hasProperty('typeCredentials')
				lLibAPI :=  oLayout['credentials']['typeCredentials'] $ "P|A" // Configurado para API pagar ou API Pagar + Extrato
			EndIf
		EndIf
	EndIf

	//Inverte se marcou TCB
	If nOpc == 2 //marcou tcb
		lChkAPI := .F.
		If oCbx <> nil .And. oApi <> nil
			oCbx:Refresh()
			oApi:Refresh()
		EndIf
	ElseIf nOpc == 3 //marcou api
		lChkTCB := .F.
		If oCbx <> nil .And. oApi <> nil
			oCbx:Refresh()
			oApi:Refresh()
		EndIf
	EndIf

	//Atualiza variaveis da consulta padrão SEEBOR
	cPort060	:= cPort240
	cAgen060    := cAgen240
	cConta060   := cConta240

	RestArea(aArea)
	FwFreeArray(aArea)	
Return 

//----------------------------------------
/*/{Protheus.doc} $F241ARQTCB
Valida se os arquivos de envio e retorno do 
CNAB TCB foram gerados na pasta system

@author Robson
@since 10/09/2020
@version 12
@return lRet, Logical, indica se o arquivo
de envio existem na pasta system
/*/
//----------------------------------------
Static Function F241ARQTCB() As Logical
	Local lRet As Logical
	
	//Inicializa variável.
	lRet := .F.
	
	If !(lRet := FILE("\system\tcbpenv.2pe"))
		Help(" ", 1, "HELP", Nil, STR0143, 1 , 1 , NIL, NIL, NIL, NIL, NIL, {STR0144})
	Endif

Return lRet

//----------------------------------------
/*/{Protheus.doc} $F241CHKSUBC
Valida se o banco, agencia, conta e Subconta 
existe na tabela SEE

@author Robson
@since 10/09/2020
@version 12
@Param cPort240, Char, Código do banco
@Param cAgen240, Char, Código da agência
@Param cConta240, Char, Número da conta
@Param cSubconta, Char, Código da Sub Conta
@return lRet, Logical, indica que os parâmetros de 
bancos estão cadastrados
/*/
//----------------------------------------
Static Function F241CHKSUBC(cPort240 As Char, cAgen240 As Char, cConta240 As Char, cSubconta As Char) As Logical
	Local lRet As Logical
	
	//Inicializa variável
	lRet := .T.
	
	Default cPort240  := " "
	Default cAgen240  := " "
	Default cConta240 := " "
	Default cSubconta := " "
	
	If lChkTCB
		dbSelectArea("SEE")
		SEE->(dbSetOrder(1))
		
		If (lRet := SEE->(DbSeek(xFilial("SEE")+cPort240+cAgen240+cConta240+cSubconta)))
			cSubConta := SEE->EE_SUBCTA
		Else
			Help(" ", 1, "PAR240")
		EndIf
	Endif

	If lChkAPI
		lRet := !Empty(cSubConta) 

		If !lRet
			HELP(" ", 1, "APIPAGAR",, STR0152, 2, 0) //"A Sub conta deve ser informada, por favor verifique!"
		Endif

		If lRet 
			lRet := ExistCpo("SEE", cPort240 + cAgen240 + cConta240 + cSubconta)
		Endif
	Endif

Return lRet

//-------------------------------------------------------------------------
/*/{Protheus.doc} F241CRatIR
Função para criar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param 
/*/
//-------------------------------------------------------------------------
Function F241CRatIR() As Object

Local cCdRetIRRt	As Character

cCdRetIRRt    := SuperGetMv("MV_RETIRRT",.T.,"3208")

F241LRatIR(.F.)

If Alltrim(SE2->E2_CODRET) $ cCdRetIRRt
	If FindFunction("FinXRatIR")
		If __oRatIRF == Nil
			__oRatIRF := FinBCRateioIR():New()
		EndIf
		__oRatIRF:SetFilOrig(cFilAnt)
		__oRatIRF:SetForLoja(SE2->E2_FORNECE,SE2->E2_LOJA)
		__oRatIRF:SetIRBaixa(.T.)
	EndIf
EndIf	

Return __oRatIRF

//-------------------------------------------------------------------------
/*/{Protheus.doc} F241LRatIR
Função para limpar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param lExclui, Logical, Define se ira excluir o Objeto da memoria
/*/
//-------------------------------------------------------------------------
Function F241LRatIR(lExclui as Logical)

    Default lExclui := .T.

    If __oRatIRF <> Nil
        __oRatIRF:Clean()
        If lExclui
            FwFreeObj(__oRatIRF)
            __oRatIRF := Nil
        EndIf    
    EndIf

Return

//-------------------------------------------------------------------------
/*/{Protheus.doc} F241SRatIR
Função para setar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param oObj, Object, Objeto que sera atribuido ao oRatIrf
/*/
//-------------------------------------------------------------------------
Function F241SRatIR(obj as Object)
    __oRatIRF := obj
Return 

/*/{Protheus.doc} F241DtCanc
	Verificar se a data de cancelamento do borderô é posterior à data de geração do borderô.

	@type  Function
	@author Simone Mie Sato Kakinoana
	@since 26/08/2022
	@version 1.0	
    @param dDataVld, data, Data a ser validada
	@param cNumbor,    caracter, número do borderô
	@param cCart,    caracter, carteira 
	@param cFilBor,    caracter, filial do borderô
	@param dDtGerBor, data, Data de geração do borderô
	@param oBorDtCan, data, objeto 
	@param lFina590, logical, Indica se a função está sendo chamada pela rotina FINA590

	@return lRet, logico, Retorno se a data de cancelamento do borderô é anterior à sua geração
/*/
Function F241DtCanc(dDataVld As date, cNumBor As Character, cCart As Character, cFilBor As Character, dDtGerBor As Date, oBorDtCan As Object, lFina590 As Logical)

	Local aAreaAtual	As Array
	Local lRet 			As Logical
	Local cQuery 		As Character	
	Local cChave 		As Character
	
    Default dDataVld	:= dDataBase	
	Default cNumBor		:= ""
	Default cCart		:= ""
	Default cFilBor		:= ""
	Default dDtGerBor	:= CTOD("  /  /  ")
	Default oBorDtCan	:= Nil
	Default lFina590 	:= .F.

	lRet 		:= .T.
	cQuery		:= ""
	cTblTmp		:= ""	
	cChave 		:= ""		

	If !lFina590
		If oBorDtCan == Nil
			cQuery 		:= "SELECT MAX(EA_DATABOR) MAXDATA "
			cQuery 		+= "FROM ? "
			cQuery 		+= "WHERE EA_FILIAL = ? "
			cQuery 		+= "AND EA_NUMBOR = ? "
			cQuery 		+= "AND EA_CART = ? "			
			cQuery 		+= "AND D_E_L_E_T_ = ' ' "
			cQuery		:= ChangeQuery(cQuery)
			oBorDtCan	:= FWPreparedStatement():New(cQuery)        
		EndIf		
		oBorDtCan:SetNumeric(1, RetSqlName("SEA"))
		oBorDtCan:SetString(2, cFilBor)
		oBorDtCan:SetString(3, cNumBor)	
		oBorDtCan:SetString(4, cCart)					
		cQuery	  := oBorDtCan:GetFixQuery()
		dDtGerBor := STOD(MpSysExecScalar(cQuery, "MAXDATA"))

	Else	
		aAreaAtual	:= GetArea()		
		If cCart == "R"  
			cChave	:= SE1->E1_FILORIG + cNumBor + cCart + SE1->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO )			
		Else
			cChave	:= SE2->E2_FILORIG + cNumBor + cCart + SE2->(E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA )			
		EndIf
		SEA->(dbSetOrder(4))	//EA_FILORIG+EA_NUMBOR+EA_CART+EA_PREFIXO+EA_NUM+EA_PARCELA+EA_TIPO+EA_FORNECE+EA_LOJA                                                                            				
		If SEA->(MsSeek( cChave, .F. ))
			dDtGerBor := SEA->EA_DATABOR
		EndIf
		
		RestArea(aAreaAtual)
		FwFreeArray(aAreaAtual)
	EndIf

	If dDataVld < dDtGerBor
		lRet := .F.
	EndIf
	
Return lRet
//-------------------------------------------------------------------------
/*/{Protheus.doc} F241RatIr
Retorna array do rateio de IRPF, indicando que houve alteração de valor

@author Pâmela Bernardo
@since  12/01/2022
@version 1
/*/
//-------------------------------------------------------------------------
Function F241RatIr()
	Local aRet As Array

	aRet := {}
	If __oRatIRF <> Nil
		aRet := __oRatIRF:aRatIRF
	EndIf
	
Return aRet

/*/{Protheus.doc} VldLicenca
Verifica se a rotina selecionada está sendo chamada com licença de uso para o módulo de origem 
@type function
@version 12 
@author gabriel.asantos
@since 07/02/2023
@return logical, Se retorno verdadeiro então possui licença, caso contrário não possui licença
/*/
Static Function VldLicenca() As Logical
	Local lRet As Logical

	FwBlkUserFunction(.T.)
	lRet := AmIIn(SIGAFIN)
	FwBlkUserFunction(.F.)
	
Return lRet

//-----------------------------------------------------------------------------------------
/*/
{Protheus.doc} FINGFKYBOR
Gravação da tabela FKY.

@author simone.mie

@since 22/11/2023
@version 1.0
/*/
//-----------------------------------------------------------------------------------------
FUNCTION FINGFKYBOR(aAuxFKY as Array, nOper as Numeric, cIdDOC as Character, cIdFK2 as Character)

	Local aArea 	As Array 	
	Local nX 		As Numeric
	Local nY 		As Numeric
	Local cUpdate	As Character       
	Local cDelete	As Character
	Local nErro 	As Numeric

	Default aAuxFKY := {}
	Default nOper   := 1
	Default cIdDoc	:= ""
	Default cIdFK2	:= ""

	aArea 		:= GetArea()	
	nX 	  		:= 0 
	nY 	  		:= 0 
	nErro 		:= 0
	cUpdate 	:= ""
	cDelete		:= ""
	
	If nOper == 1
		For nX := 1 to Len(aAuxFKY)		
			Reclock("FKY",.T.)
			FKY->FKY_FILIAL	:= aAuxFKY[nX][1]
			FKY->FKY_IDFKY	:= FWUUIDV4()
			FKY->FKY_IDDOC	:= aAuxFKY[nX][2]	
			FKY->FKY_IDORIG	:= aAuxFKY[nX][4]		
			FKY->FKY_TPIMP	:= aAuxFKY[nX][5]	
			FKY->FKY_NATREN	:= aAuxFKY[nX][6]	
			FKY->FKY_BASETR	:= aAuxFKY[nX][7]	
			FKY->FKY_VLIMP	:= aAuxFKY[nX][8]	
			FKY->FKY_BASENR	:= aAuxFKY[nX][9]	
			FKY->FKY_VLIMPN	:= aAuxFKY[nX][10]	
			FKY->FKY_NUMPRO	:= aAuxFKY[nX][11]	
			FKY->FKY_TPPROC	:= aAuxFKY[nX][12]	
			FKY->FKY_CODSUS	:= aAuxFKY[nX][13]				
			FKY->FKY_TABORI	:= "FK3"
			MsUnlock()		
		Next nX
	ElseIf nOper == 2 .And. !Empty(cIdFK2)	
	
		If __oAtuFKY == Nil

			cUpdate := "UPDATE ? SET FKY_IDFK2 = ' ' "
			cUpdate += "WHERE FKY_FILIAL = ? "
			cUpdate += "AND FKY_IDDOC  = ? "
			cUpdate += "AND FKY_TABORI = 'FK3' "			
			cUpdate += "AND FKY_IDFK2 = ? "			
			cUpdate += "AND D_E_L_E_T_ = ' ' "
			__oAtuFKY := FWPreparedStatement():New(cUpdate)
		EndIf
		
		__oAtuFKY:SetNumeric(1, RetSqlName("FKY"))		
		__oAtuFKY:SetString(2, xFilial("FKY"))
		__oAtuFKY:SetString(3, cIdDOC)
		__oAtuFKY:SetString(4, cIdFK2)
		cUpdate := __oAtuFKY:GetFixQuery()
		
		If (nErro := TCSqlExec(cUpdate)) != 0		
			DisarmTransaction()
			Break
		EndIf

	ElseIf nOper == 3	
	
		If __oDelFKY == Nil

			cDelete := "UPDATE ? SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_ "
			cDelete += "WHERE FKY_FILIAL = ? "
			cDelete += "AND FKY_IDDOC  = ? "
			cDelete += "AND FKY_TABORI = 'FK3' "			
			cDelete += "AND FKY_IDFK2 = ? "
			cDelete += "AND D_E_L_E_T_ = ' ' "
			__oDelFKY := FWPreparedStatement():New(cDelete)
		EndIf
		
		__oDelFKY:SetNumeric(1, RetSqlName("FKY"))		
		__oDelFKY:SetString(2, xFilial("FKY"))
		__oDelFKY:SetString(3, cIdDOC)
		__oDelFKY:SetString(4, cIdFK2)
		cDelete := __oDelFKY:GetFixQuery()
		
		If (nErro := TCSqlExec(cDelete)) != 0		
			DisarmTransaction()
			Break		
		EndIf

	EndIf		

	RestArea(aArea)

	Return
