#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "backoffice.sv.atf.analyticalreasonfixedasset.bra.ch"

namespace totvs.protheus.atf.smartviewintegratedprovider
using namespace totvs.protheus.backoffice.control.smartView.integratedProvider
using namespace control.sv.functions.utils

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAATF", tables="SN5,CT1", name="Razão Analitico do Ativo", country="ALL")

//-------------------------------------------------------------------------------
/*{Protheus.doc} backoffice.sv.atf.AnalyticalReasonFixedAsset.bra
Razão Analitico do Ativo Fixo - fixed asset analysis reason 
Fonte/Perg      ATFR130	/ AFR130
@author         Douglas Rodrigues da Silva
@since          07/06/2023
@version        1.0
@Revitalização  Renato July - DEZ/2023
*/
//-------------------------------------------------------------------------------
Class AnalyticalReasonFixedAssetSmartViewBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

    public method new()             as object
    public method getDescription()  as character
    public method getAreas()        as array
    public method getData()         as object
    public method getSchema()       as object

    public method preschema()       as object 
    public method preData()         as object
    public method processData()     as json
    
    private method AtfSAldoAnt()    as array
    private method AtfChkFator()

    protected method getQuery()     as character
    protected method getQuerySN5()  as character
    protected method setData()      as object      

    protected data cAlias           as character
    protected data cAliasSN5        as character
    protected data cTipoBem         as character
    protected data cContaDe         as character
    protected data cContaAte        as character
    protected data cFilDe           as character
    protected data cFilAte          as character
    protected data cMVPAR12         as character
    protected data cMVPAR13         as character
    protected data cMVPAR14         as character
    protected data cCompanyName     as character
    protected data cBranchName      as character
    protected data nMVPAR03         as numeric
    protected data nMVPAR04         as numeric
    protected data cMVPAR07         as numeric
    protected data nMVPAR15         as numeric
    protected data nMoeda           as numeric
    protected data dN5DATADe        as date
    protected data dN5DATAAte       as date
    protected data dN5DATAAnt       as date
    protected data aCamposQry       as array
    protected data aAllFields       as array
    protected data aSelFil          as array
    protected data lConsFil         as logical
    protected data lNatCont         as logical 
    protected data jDados           as json
    protected data oQuery           as object
    protected data oQuerySN5        as object
    protected data oIntegratedProvider as object  

EndClass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
@return object: self
@author         Douglas Rodrigues da Silva
@since          07/06/2023
@version        12.1.2310
*/
//------------------------------------------------------------------- 
method new() as object Class AnalyticalReasonFixedAssetSmartViewBusinessObject
    _Super:new()
    self:setDisplayName(STR0001) // "Razão Analitico do Ativo Fixo" 
    self:setPergunte("AFR130")   // Indica o pergunte que será utilizado no relatório

    ::cTipoBem := ""
    ::lNatCont := GetNewPar("MV_ATFNAT","P") == "C"
return self

//-------------------------------------------------------------------
/*{Protheus.doc} getDescription
Método de instância da classe
@return object: string
@author         Douglas Rodrigues da Silva
@since          07/06/2023
@version        12.1.2310
*/
//------------------------------------------------------------------- 
method getDescription() as character class AnalyticalReasonFixedAssetSmartViewBusinessObject
return STR0002 // "Objeto contendo informações Razão Analitico do Ativo Fixo"

//-------------------------------------------------------------------
/*{Protheus.doc} getAreas
Método de instância da classe
@return object: string
@author         Douglas Rodrigues da Silva
@since          07/06/2023
@version        12.1.2310
*/
//------------------------------------------------------------------- 
method getAreas() as array class AnalyticalReasonFixedAssetSmartViewBusinessObject
return { STR0003 } // "Ativo Fixo" 

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do TReports
@return object: self:oData
@author         Douglas Rodrigues da Silva
@since          07/06/2023
@version        12.1.2310
*/
//------------------------------------------------------------------- 
method getData(nPage as numeric, oFilter as object) as object class AnalyticalReasonFixedAssetSmartViewBusinessObject
    
    local cQuery as character

    //Carrega lista de parametros para a memória
    CTBsetValueMVPAR(oFilter:getParameters(), "AFR130")

    ::oIntegratedProvider := ControlIntegratedProvider():New()

    //Seleção de filiais
    If !self:lConsFil
        ::oIntegratedProvider:lMultSelectBranches := .T.
        ::oIntegratedProvider:lAllowBranchFilter  := .T.
        ::oIntegratedProvider:setBranchPar(oFilter:getParameters())
        ::oIntegratedProvider:loadFilterBranches({"SN5"})

        If Valtype(::oIntegratedProvider:oFilterBranches["SN5"][1]) == "A"
            self:aSelFil := ::oIntegratedProvider:oFilterBranches["SN5"][1]
        Else
            self:aSelFil := ::oIntegratedProvider:oFilterBranches["SN5"]
        EndIf
    EndIf

    //Salva nome empresa e filial logada
    self:cCompanyName := ::oIntegratedProvider:getCompanyName()
    self:cBranchName  := ::oIntegratedProvider:getBranchName()

    //Elimina da memória a instância do objeto informado como parâmetro
    FreeObj(oFilter:getParameters())

    //Definição de parametros
    ::cContaDe   := MV_PAR01 // Da Conta ?
    ::cContaAte  := MV_PAR02 // Ate Conta ?    
    ::nMVPAR03   := MV_PAR03 // Do Mes ?
    ::nMVPAR04   := MV_PAR04 // Ate o mes ?
    ::nMoeda     := iif(Empty(MV_PAR05) .Or. MV_PAR05 == 0, 1, MV_PAR05) // Qual a moeda ?
    ::cMVPAR07   := MV_PAR07 // Quebra Mes a Mes ? 
    ::lConsFil   := iif(MV_PAR11 == 1, .T., .F.) // Cons Filiais Abaixo ?
    ::cFilDe     := MV_PAR12 // Filial De ?
    ::cFilAte    := MV_PAR13 // Filial Até ?
    ::cMVPAR14   := MV_PAR14 // Tipo de Saldo ?
    ::nMVPAR15   := MV_PAR15 // Exibe Informações ?
    
    //Tratamento datas
    ::dN5DATADe  := DToS(FirstDay(CToD("01/"+StrZero(::nMVPAR03, 2)+"/"+StrZero(Year(dDataBase), 4))))    
    ::dN5DATAAte := DToS(LastDay(CToD("01/"+StrZero(::nMVPAR04, 2)+"/"+StrZero(Year(dDataBase), 4))))
    ::dN5DATAAnt := DToS(LastDay(CToD("01/"+StrZero(::nMVPAR04, 2)+"/"+StrZero(Year(dDataBase), 4))))
    
    //Exibe Informações ?
    if ::nMVPAR15 == 1        // Fiscal
        ::cTipoBem := ATFXTpBem(1)
    elseif ::nMVPAR15 == 2    // Gerencial
        ::cTipoBem := ATFXTpBem(2)
    elseif ::nMVPAR15 == 3    // Incentivada
        ::cTipoBem := ATFXTpBem(3)
    endif

    //Se não considera filial, pega a filial logada
    if !self:lConsFil
        ::cFilDe 	:= FwXFilial("SN5")
        ::cFilAte	:= FwXFilial("SN5")   
    endif 

    cQuery := self:getQuery(oFilter)

    self:cAlias := MPSysOpenQuery(cQuery)
    self:setData(oFilter)

    iif(Select(self:cAlias) > 0, (self:cAlias)->(DbCloseArea()), MSErase(self:cAlias))

return self:oData

//-------------------------------------------------------------------------------
/*{Protheus.doc} setData
    Seta os dados filtrados no objeto oData

    @author Controladoria
    @since DEZ/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------------------

method setData(oFilter as object) as object class AnalyticalReasonFixedAssetSmartViewBusinessObject
    
    local lInverte	  := .F. as logical
    local cAtfMoeda   := iif(!Empty(GetNewPar("MV_ATFMOED")), GetNewPar("MV_ATFMOED"), "1") as character
    local cMascara    := iif(!Empty(GetNewPar("MV_MASCARA")), GetNewPar("MV_MASCARA"), "")  as character
    local cSinalMoeda := UPPER(AllTrim(GetNewPar("MV_SIMB"+Str(self:nMoeda+1,1,0))))
    local aMeses      := {OemToAnsi(STR0010),OemToAnsi(STR0011),OemToAnsi(STR0012),OemToAnsi(STR0013),OemToAnsi(STR0014),OemToAnsi(STR0015),;            //"Jan"###"Fev"###"Mar"###"Abr"###"Mai"###"Jun"
                          OemToAnsi(STR0016),OemToAnsi(STR0017),OemToAnsi(STR0018),OemToAnsi(STR0019),OemToAnsi(STR0020),OemToAnsi(STR0021)} as array    //"Jul"###"Ago"###"Set"###"Out"###"Nov"###"Dez"
    local aSaldoAnt   := {}  as array
    local nN5VALOR1   := 0   as numeric
    local nAcExVl0    := 0   as numeric
    local nAcExVl1	  := 0   as numeric
    local nAcExAcr	  := 0   as numeric
    local nAcExDec	  := 0   as numeric
    local nVlAcMoed1  := 0   as numeric
    local nVlAcAcr    := 0   as numeric
    local nVlAcDec    := 0   as numeric
    local nSLDANTER00 := 0   as numeric
    local nSLDANTER01 := 0   as numeric
    local nSaldo      := 0   as numeric
    local nN5TAXA     := 0   as numeric
    local nX                 as numeric
    local dN5DATA            as date

    //Posiciona no registro inicial
    (self:cAlias)->(dbGoTop())

    While !(self:cAlias)->(Eof())
        cConta      := (self:cAlias)->N5_CONTA

        if ::lNatCont
            nN5VALOR1   := (self:cAlias)->N5_VALOR1 * iif((self:cAlias)->N5_TIPO $ "1234679BCFGJKPQTUY",Self:AtfChkFator(lInverte,(self:cAlias)->N5_CONTA,"N5_VALOR1"),(Self:AtfChkFator(lInverte,(self:cAlias)->N5_CONTA)* -1))      //Verifica o saldo para impressao ou nao do bem
            nAcExAcr    := (self:cAlias)->&("N5_VALOR"+Str(self:nMoeda+1,1))  * Self:AtfChkFator(lInverte,(self:cAlias)->N5_CONTA,"ACRESCIMO")
            nAcExDec    := (self:cAlias)->&("N5_VALOR"+Str(self:nMoeda+1,1))  * Self:AtfChkFator(lInverte,(self:cAlias)->N5_CONTA,"DECRESCIMO")
            nSaldo      += (self:cAlias)->&("N5_VALOR"+Str(self:nMoeda+1,1))  * (iif((self:cAlias)->N5_TIPO $"1234679BCFGJKPQTUY",Self:AtfChkFator(lInverte,(self:cAlias)->N5_CONTA),(Self:AtfChkFator(lInverte,(self:cAlias)->N5_CONTA)*-1) ))
        else
            nN5VALOR1   := (self:cAlias)->N5_VALOR1 * iif((lInverte .And. (self:cAlias)->N5_TIPO $ "1234679BCFGJKPQSVY") .Or. !(self:cAlias)->N5_TIPO $ "01234679BCFGJKPQTUY", -1, 1 )
            nAcExAcr    := iif(  (self:cAlias)->N5_TIPO $ "1234679BCFGJKPQTUY",(self:cAlias)->&("N5_VALOR"+Str(self:nMoeda+1,1)),0)
            nAcExDec    := iif( !(self:cAlias)->N5_TIPO $ "1234679BCFGJKPQTUY",(self:cAlias)->&("N5_VALOR"+Str(self:nMoeda+1,1)),0)
            nSaldo      += (self:cAlias)->&("N5_VALOR"+Str(self:nMoeda+1,1)) * (iif((self:cAlias)->N5_TIPO $ "1234679BCFGJKPQTUY",1,-1))
        endif

        dN5DATA     := SToD((self:cAlias)->N5_DATA)
        nN5TAXA     := iif((self:cAlias)->N5_TAXA <> 0 .And. (self:nMoeda+1) == Val(cAtfMoeda), (self:cAlias)->N5_TAXA, (self:cAlias)->N5_VALOR1 / (self:cAlias)->&("N5_VALOR"+Str(self:nMoeda+1,1)) )

        //Campo para a composição do Desing total
        if Empty(dN5DATA)
            aSaldoAnt   := self:AtfSaldoAnt( (self:cAlias)->N5_CONTA, (self:cAlias)->N5_FILIAL )
            nSLDANTER01 := nAcExVl1 := aSaldoAnt[1]
            nSLDANTER00 := nAcExVl0 := aSaldoAnt[self:nMoeda+1]
        endif
        
        ::jDados := JsonObject():new()

        //Popula campos da query
        For nX := 1 To Len(self:aAllFields)
            if self:aAllFields[nX]:getType() == "date"
                ::jDados[self:aAllFields[nX]:getName()] := iif(!empty((self:cAlias)->&(self:aAllFields[nX]:getRealName())), FwTimeStamp(5, StoD((self:cAlias)->&(self:aAllFields[nX]:getRealName())), "00:00:00"), nil)
            else
                ::jDados[self:aAllFields[nX]:getName()] := (self:cAlias)->&(self:aAllFields[nX]:getRealName())
            endif
		Next nX

        //Altera valores de campos da query com tratativas
        ::jDados["N5_FILIAL"  ]	 := AllTrim((self:cAlias)->N5_FILIAL)        
        ::jDados["N5_TAXA"    ]	 := nN5TAXA
        ::jDados["N5_VALOR1"  ]  := nN5VALOR1

        //Popula campos customizados
        ::jDados["NomeEmpresa"]  := self:cCompanyName
        ::jDados["NomeFilial" ]  := self:cBranchName
        ::jDados["CHISTOR"    ]  := UPPER(AFDescSal( (self:cAlias)->N5_TIPO ))
        ::jDados["CONTA_M"    ]  := MascaraCTB( (self:cAlias)->N5_CONTA,cMascara)
        ::jDados["SMOEDAS"    ]  := cSinalMoeda
        ::jDados["SLDANTER99" ]	 := nAcExVl1       
        ::jDados["SLDANTER01" ]	 := iif(Empty(dN5DATA), nSLDANTER01, 0)
        ::jDados["SLDANTER00" ]	 := iif(Empty(dN5DATA), nSLDANTER00, 0)            
        ::jDados["N5_VALOR2"  ]  := iif(!Empty(dN5DATA), (self:cAlias)->N5_VALOR2, 0)
        ::jDados["N5_VALOR3"  ]  := iif(!Empty(dN5DATA), (self:cAlias)->N5_VALOR3, 0)
        ::jDados["N5_VALOR4"  ]  := iif(!Empty(dN5DATA), (self:cAlias)->N5_VALOR4, 0)
        ::jDados["N5_VALOR5"  ]  := iif(!Empty(dN5DATA), (self:cAlias)->N5_VALOR5, 0)        
        ::jDados["REFERENCIA" ]  := iif(!Empty(dN5DATA), aMeses[Month(dN5DATA)]+"/"+Subs(StrZero(Year(dN5DATA),4),3,2), "")
        ::jDados["ACRESCIMO"  ]  := iif(!Empty(dN5DATA), nAcExAcr, 0)
        ::jDados["DECRESCIMO" ]  := iif(!Empty(dN5DATA), nAcExDec, 0)
        ::jDados["SALDO"      ]  := iif(!Empty(dN5DATA), nSALDO + nAcExVl0, 0)
        
        //Se quebra por mês, grava a referencia em novo campo do schema para validação no agrupamento do design 
        if ::cMVPAR07 == 1
            ::jDados["REFERVALID"] := SubStr((self:cAlias)->N5_DATA, 1, 6)
        else
            ::jDados["REFERVALID"] := ""
        endif

        //Adiciona valores acumulados ao schema
        nVlAcMoed1 += nN5VALOR1 + iif(Empty(dN5DATA), nSLDANTER01, 0)
        nVlAcAcr   += iif(!Empty(dN5DATA), nAcExAcr, 0)
        nVlAcDec   += iif(!Empty(dN5DATA), nAcExDec, 0)

        ::jDados["VLACUMMOED1"] := nVlAcMoed1
        ::jDados["VLACUMACRE" ] := nVlAcAcr
        ::jDados["VLACUMADEC" ] := nVlAcDec

        (self:cAlias)->(dbSkip())

        //Se trocou a conta, reseta as variaveis
        if cConta <> (self:cAlias)->N5_CONTA
            nAcExAcr := nAcExDec := nSaldo := nAcExVl1 := nAcExVl0 := nVlAcMoed1 := nVlAcAcr := nVlAcDec := 0
        endif        

        self:processData()
        self:oData:appendData(::jDados)        

    EndDo

return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} getStruct
Prepara a estrutura dos campos
@param aCpos array: Array com os campos do relatório
@return array: Array com a estrutura dos campos
@author         Controladoria
@since          DEZ/2023
@version        12.1.2310
*/
//------------------------------------------------------------------- 
method getSchema() as object class AnalyticalReasonFixedAssetSmartViewBusinessObject

    local aFieldsSN5 as array
    local aFieldsCT1 as array
    local lCanFilter := .F. as logical

    aFieldsSN5 := { "N5_FILIAL", "N5_CONTA", "N5_DATA", "N5_TIPO", "N5_TAXA", "N5_VALOR1", "N5_VALOR2", "N5_VALOR3",;
                    "N5_VALOR4", "N5_VALOR5" }

    aFieldsCT1 := { "CT1_NORMAL", "CT1_DESC01" }

    //Adiciona campos ao schema
    self:oSchema:aliasToSchema("SN5", aFieldsSN5)
    self:oSchema:aliasToSchema("CT1", aFieldsCT1)

    //Popula o atributo aAllFields com os campos acima
    self:aAllFields := self:getStructFields()

    //Adiciona campos customizados ao schema
    self:addProperty( "CHISTOR"    , STR0004 , "string" , STR0004 , "CHISTOR"    ,,,,lCanFilter) //Histórico
    self:addProperty( "CONTA_M"    , STR0005 , "string" , STR0005 , "CONTA_M"    ,,,,lCanFilter) //Mascara da Conta
    self:addProperty( "ACRESCIMO"  , STR0006 , "number" , STR0006 , "ACRESCIMO"  ,,,,lCanFilter) //Acrescimo
    self:addProperty( "DECRESCIMO" , STR0007 , "number" , STR0007 , "DECRESCIMO" ,,,,lCanFilter) //Decrescimo
    self:addProperty( "SALDO"      , STR0008 , "number" , STR0008 , "SALDO"      ,,,,lCanFilter) //Saldo
	self:addProperty( "SMOEDAS"    , STR0009 , "string" , STR0009 , "SMOEDAS"    ,,,,lCanFilter) //Simb. Moeda
	self:addProperty( "REFERENCIA" , STR0022 , "string" , STR0022 , "REFERENCIA" ,,,,lCanFilter) //Referência
	self:addProperty( "SLDANTER01" , STR0023 , "number" , STR0023 , "SLDANTER01" ,,,,lCanFilter) //Saldo Anterior Moeda CTB
	self:addProperty( "SLDANTER00" , STR0024 , "number" , STR0024 , "SLDANTER00" ,,,,lCanFilter) //Saldo Anterior Moeda 
	self:addProperty( "SLDANTER99" , STR0025 , "number" , STR0025 , "SLDANTER99" ,,,,lCanFilter) //Saldo Acum. Ant. Moeda CTB
    self:addProperty( "REFERVALID" , STR0026 , "string" , STR0026 , "REFERVALID" ,,,,lCanFilter) //Valid. Referência
    self:addProperty( "VLACUMMOED1", STR0027 , "number" , STR0027 , "VLACUMMOED1",,,,lCanFilter) //Vl. Acum. Moeda 1
    self:addProperty( "VLACUMACRE" , STR0028 , "number" , STR0028 , "VLACUMACRE" ,,,,lCanFilter) //Vl. Acum. Acrescimo
    self:addProperty( "VLACUMADEC" , STR0029 , "number" , STR0029 , "VLACUMADEC" ,,,,lCanFilter) //Vl. Acum. Decrescimo
    self:addProperty( "NomeEmpresa", STR0030,  "string" , STR0030 , "NomeEmpresa",,,,lCanFilter) //Nome Empresa
    self:addProperty( "NomeFilial" , STR0031,  "string" , STR0031 , "NomeFilial" ,,,,lCanFilter) //Nome Filial

    //Seleciona filiais
    self:oSchema:addParameter("SV_MULTBRANCH", STR0032, "string", .T.) //Filiais
    self:setCustomURL("SV_MULTBRANCH","/api/controladoria/smartview/v1/options/getBranches",2)

return self:oSchema

//-------------------------------------------------------------------
/*/{Protheus.doc} preSchema
Metodo que será consumido pelo M.I.
@author         Controladoria
@since          DEZ/2023
@version        12.1.2310
/*/
//-------------------------------------------------------------------
method preSchema() as object class AnalyticalReasonFixedAssetSmartViewBusinessObject
return self:oSchema

//-------------------------------------------------------------------
/*{Protheus.doc} preData
Método de instância da classe
@return object: self:oData
@author         Controladoria
@since          DEZ/2023
@version        12.1.2310
*/
//-------------------------------------------------------------------
method preData() as object class AnalyticalReasonFixedAssetSmartViewBusinessObject
return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} processData
Método na Chamado no momento do processamento da query
@return object: self:oData
@author         Controladoria
@since          DEZ/2023
@version        12.1.2310
*/
//-------------------------------------------------------------------
method processData() class AnalyticalReasonFixedAssetSmartViewBusinessObject
return ::jDados

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
    Metodo que será consumido pelo M.I.
    Será usado para alterar a Query antes do getData.

    @author Controladoria
    @since  DEZ/2023
    @version 12.1.2310
/*/
//-------------------------------------------------------------------

method getQuery(oFilter as object) as character class AnalyticalReasonFixedAssetSmartViewBusinessObject
    
    local cDelete := space(1) as character
    local cQuery    as character    
    local cFields   as character
    local cFields1  as character
    local cFields2  as character    
    local nIndice := 1 as numeric	

    //Campos que farão parte do select da query
    cFields  := self:getSQLFields(.F., , .F.)
    cFields1 := StrTran(cFields,  "N5_DATA", "''  AS N5_DATA")
    cFields1 := StrTran(cFields1, "N5_TIPO", "''  AS N5_TIPO")
    cFields1 := StrTran(cFields1, "N5_TAXA", "0   AS N5_TAXA")
    cFields1 := StrTran(cFields1, "N5_VALOR1", "0 AS N5_VALOR1")
    cFields1 := StrTran(cFields1, "N5_VALOR2", "0 AS N5_VALOR2")
    cFields1 := StrTran(cFields1, "N5_VALOR3", "0 AS N5_VALOR3")
    cFields1 := StrTran(cFields1, "N5_VALOR4", "0 AS N5_VALOR4")
    cFields1 := StrTran(cFields1, "N5_VALOR5", "0 AS N5_VALOR5")

    //Select
    cQuery := " SELECT "
    cQuery += cFields1
    cQuery += " FROM "+RetSqlName("SN5")+" SN5 "
    cQuery += " LEFT JOIN "+RetSqlName("CT1")+" CT1 ON CT1.D_E_L_E_T_ = ? "
    cQuery += "  AND CT1.CT1_FILIAL = ? "
    cQuery += "  AND CT1.CT1_CONTA = SN5.N5_CONTA "
    
    //Where
    cQuery += " WHERE SN5.D_E_L_E_T_ = ? "

    if self:lConsFil
        cQuery += "   AND SN5.N5_FILIAL BETWEEN ? AND ? "
	else
        if !Empty(self:aSelFil)
            cQuery += "   AND SN5.N5_FILIAL IN ( ? )"
        else
            cQuery += "   AND SN5.N5_FILIAL =  ? "
        endif
	endif
    
    cQuery += "   AND SN5.N5_CONTA BETWEEN ? AND ? "	
    cQuery += "   AND SN5.N5_DATA <= ? "

	if !Empty(::cMVPAR14) .And. ::cMVPAR14 <> '*'
       	cQuery += "   AND SN5.N5_TPSALDO = ? "
	endif

    if ::nMVPAR15 <> 4 .And. !Empty(::cTipoBem)
        cQuery += "   AND SN5.N5_TPBEM IN ? "
    endif

    //Os filtros serão setados na interface do novo TReports     
    cQuery += iif(oFilter:hasFilter(), " AND " + oFilter:getSQLExpression(), "")

    //Group BY
    cQuery += " GROUP BY N5_FILIAL, N5_CONTA, CT1_NORMAL, CT1_DESC01 "

    //Union
    cQuery += " UNION "

    //Campos que farão parte do select da query    
    cFields2 := StrTran(cFields,  "N5_VALOR1", "SUM(N5_VALOR1) AS N5_VALOR1")
    cFields2 := StrTran(cFields2, "N5_VALOR2", "SUM(N5_VALOR2) AS N5_VALOR2")
    cFields2 := StrTran(cFields2, "N5_VALOR3", "SUM(N5_VALOR3) AS N5_VALOR3")
    cFields2 := StrTran(cFields2, "N5_VALOR4", "SUM(N5_VALOR4) AS N5_VALOR4")
    cFields2 := StrTran(cFields2, "N5_VALOR5", "SUM(N5_VALOR5) AS N5_VALOR5")

    //Select
    cQuery += " SELECT "
    cQuery += cFields2
    cQuery += " FROM "+RetSqlName("SN5")+" SN5 "
    cQuery += " LEFT JOIN "+RetSqlName("CT1")+" CT1 ON CT1.D_E_L_E_T_ = ? "
    cQuery += "  AND CT1.CT1_FILIAL = ? "
    cQuery += "  AND CT1.CT1_CONTA = SN5.N5_CONTA "
    
    //Where
    cQuery += " WHERE SN5.D_E_L_E_T_ = ? "

    if self:lConsFil
        cQuery += "   AND SN5.N5_FILIAL BETWEEN ? AND ? "
	else
        if !Empty(self:aSelFil)
            cQuery += "   AND SN5.N5_FILIAL IN ( ? )"
        else
            cQuery += "   AND SN5.N5_FILIAL =  ? "
        endif
	endif

    cQuery += "   AND SN5.N5_CONTA BETWEEN ? AND ? "
    cQuery += "   AND SN5.N5_DATA BETWEEN ? AND ? "

	if !Empty(::cMVPAR14) .And. ::cMVPAR14 <> '*'
       	cQuery += "   AND SN5.N5_TPSALDO = ? "
	endif

    if ::nMVPAR15 <> 4 .And. !Empty(::cTipoBem)
        cQuery += "   AND SN5.N5_TPBEM IN ? "
    endif    

    //Os filtros serão setados na interface do novo TReports     
    cQuery += iif(oFilter:hasFilter(), " AND " + oFilter:getSQLExpression(), "")    

    //Group BY
    cQuery += " GROUP BY N5_FILIAL, N5_CONTA, N5_DATA, N5_TIPO, N5_TAXA, CT1_NORMAL, CT1_DESC01"

    //Order by
    cQuery += " ORDER BY N5_FILIAL, N5_CONTA, N5_DATA, N5_TIPO"
	
	self:oQuery := FWExecStatement():New(ChangeQuery(cQuery))

    //Popula binds da primeira query
    self:oQuery:SetString(nIndice++, cDelete)
    self:oQuery:SetString(nIndice++, FwXFilial("CT1"))
    self:oQuery:SetString(nIndice++, cDelete)

    if self:lConsFil
        self:oQuery:SetString(nIndice++, ::cFilDe)
        self:oQuery:SetString(nIndice++, ::cFilAte) 
	else
        if !Empty(self:aSelFil)
            self:oQuery:SetIn(nIndice++, self:aSelFil)
        else
            self:oQuery:SetString(nIndice++, FWXFilial("SN5")) 
        endif
	endif
    
    self:oQuery:SetString(nIndice++, ::cContaDe)
    self:oQuery:SetString(nIndice++, ::cContaAte)
    self:oQuery:SetString(nIndice++, ::dN5DATAAnt)

    if !Empty(::cMVPAR14) .And. ::cMVPAR14 <> '*'
        self:oQuery:SetString(nIndice++, ::cMVPAR14)
    endif

    if ::nMVPAR15 <> 4 .And. !Empty(::cTipoBem)
        self:oQuery:SetUnsafe(nIndice++, FormatIn(::cTipoBem,"/"))
    endif

    //Popula binds da segunda query
    self:oQuery:SetString(nIndice++, cDelete)
    self:oQuery:SetString(nIndice++, FwXFilial("CT1"))
    self:oQuery:SetString(nIndice++, cDelete)

    if self:lConsFil
        self:oQuery:SetString(nIndice++, ::cFilDe)
        self:oQuery:SetString(nIndice++, ::cFilAte) 
	else
        if !Empty(self:aSelFil)
            self:oQuery:SetIn(nIndice++, self:aSelFil)
        else
            self:oQuery:SetString(nIndice++, FWXFilial("SN5")) 
        endif
	endif

    self:oQuery:SetString(nIndice++, ::cContaDe)
    self:oQuery:SetString(nIndice++, ::cContaAte)
    self:oQuery:SetString(nIndice++, ::dN5DATADe)
    self:oQuery:SetString(nIndice++, ::dN5DATAAte)

    if !Empty(::cMVPAR14) .And. ::cMVPAR14 <> '*'
        self:oQuery:SetString(nIndice++, ::cMVPAR14)
    endif

    if ::nMVPAR15 <> 4 .And. !Empty(::cTipoBem)
        self:oQuery:SetUnsafe(nIndice++, FormatIn(::cTipoBem,"/"))
    endif
	
	cQuery := self:oQuery:GetFixQuery()

return cQuery

//-------------------------------------------------------------------
/*{Protheus.doc} AtfChkFator

@return object: self:oData
@author         Controladoria
@since          DEZ/2023
@version        12.1.2310
*/
//-------------------------------------------------------------------
method AtfChkFator(lInverte as logical, cCONTA as character, cAcrDecr as character, cTipo as character) class AnalyticalReasonFixedAssetSmartViewBusinessObject

    local nAtfChkFator	:= 1

    Default lInverte	:= .F.
    Default cConta		:= (self:cAlias)->N5_CONTA
    Default cAcrDecr	:= ""
    Default cTipo       := (self:cAlias)->N5_TIPO

    nAtfChkFator   := GetFator(cConta)

    if ((cAcrDecr == "ACRESCIMO") .And. (!cTipo $ "1234679ABCFGJKPQTUY" )) .Or. ((cAcrDecr == "DECRESCIMO") .And. (cTipo $ "1234679ABCFGJKPQTUY" ))
        nAtfChkFator   := 0
    endif

return nAtfChkFator

//-------------------------------------------------------------------
/*{Protheus.doc} AtfSAldoAnt
Retorna o saldo anterior de uma conta
@return object: self:oData
@author         Controladoria
@since          DEZ/2023
@version        12.1.2310
*/
//-------------------------------------------------------------------
method AtfSAldoAnt(cConta as character, cFil as character) as array class AnalyticalReasonFixedAssetSmartViewBusinessObject

    local cQuery    as character
    local cGrupoPass := GetNewPar("MV_GRPASS") as character
    local aRet       := { 0,0,0,0,0 } as array    
    local lInverte   := .F. as logical

    Default cConta	 := (self:cAlias)->N5_CONTA
    Default cFil	 := FwXFilial("SN5")

    cQuery := self:getQuerySN5(cConta, cFil)
    self:cAliasSN5 := MPSysOpenQuery(cQuery)

    //Posiciona no registro inicial
    (self:cAliasSN5)->(dbGoTop())

    While (self:cAliasSN5)->(!Eof()) .And. (self:cAliasSN5)->N5_FILIAL == cFil .And. (self:cAliasSN5)->N5_CONTA == cConta

        if (self:cAliasSN5)->N5_TIPO == "0" .Or. Month( STOD((self:cAliasSN5)->N5_DATA) ) < ::nMVPAR03 .Or. Year( STOD((self:cAliasSN5)->N5_DATA )) < Year( dDataBase )
            // lInverte ‚ .T. se conta pertence ao grupo de contas Credoras (cGrupoPass),I1_NORMAL = "D", mas o saldo e devedor.
            lInverte := CT1->CT1_NORMAL=="1" .And. SubStr(cConta,1,1) $ cGrupoPass
            if ::lNatCont
                aRet[1] += (self:cAliasSN5)->N5_VALOR1 * Self:AtfChkFator( lInverte, (self:cAliasSN5)->N5_CONTA )
                aRet[2] += (self:cAliasSN5)->N5_VALOR2 * Self:AtfChkFator( lInverte, (self:cAliasSN5)->N5_CONTA )
                aRet[3] += (self:cAliasSN5)->N5_VALOR3 * Self:AtfChkFator( lInverte, (self:cAliasSN5)->N5_CONTA )
                aRet[4] += (self:cAliasSN5)->N5_VALOR4 * Self:AtfChkFator( lInverte, (self:cAliasSN5)->N5_CONTA )
                aRet[5] += (self:cAliasSN5)->N5_VALOR5 * Self:AtfChkFator( lInverte, (self:cAliasSN5)->N5_CONTA )
            else
                aRet[1] += (self:cAliasSN5)->N5_VALOR1 * if(((self:cAliasSN5)->N5_TIPO $ "1234679BCFGJKPQSVY" .And. lInverte) .Or. ! (self:cAliasSN5)->N5_TIPO $ "01234679BCFGJKPQTUY", (-1), 1)
                aRet[2] += (self:cAliasSN5)->N5_VALOR2 * if(((self:cAliasSN5)->N5_TIPO $ "1234679BCFGJKPQSVY" .And. lInverte) .Or. ! (self:cAliasSN5)->N5_TIPO $ "01234679BCFGJKPQTUY", (-1), 1)
                aRet[3] += (self:cAliasSN5)->N5_VALOR3 * if(((self:cAliasSN5)->N5_TIPO $ "1234679BCFGJKPQSVY" .And. lInverte) .Or. ! (self:cAliasSN5)->N5_TIPO $ "01234679BCFGJKPQTUY", (-1), 1)
                aRet[4] += (self:cAliasSN5)->N5_VALOR4 * if(((self:cAliasSN5)->N5_TIPO $ "1234679BCFGJKPQSVY" .And. lInverte) .Or. ! (self:cAliasSN5)->N5_TIPO $ "01234679BCFGJKPQTUY", (-1), 1)
                aRet[5] += (self:cAliasSN5)->N5_VALOR5 * if(((self:cAliasSN5)->N5_TIPO $ "1234679BCFGJKPQSVY" .And. lInverte) .Or. ! (self:cAliasSN5)->N5_TIPO $ "01234679BCFGJKPQTUY", (-1), 1)
            endif

        endif
        (self:cAliasSN5)->(DbSkip())

    EndDo

    iif(Select(self:cAliasSN5) > 0, (self:cAliasSN5)->(DbCloseArea()), MSErase(self:cAliasSN5))    

return aRet


//-------------------------------------------------------------------
/*/{Protheus.doc} getQuerySN5
    Metodo que será consumido pelo M.I.
    Será usado para alterar a Query.

    @author Controladoria
    @since  DEZ/2023
    @version 12.1.2310
/*/
//-------------------------------------------------------------------

method getQuerySN5(cConta as character, cFil as character) as character class AnalyticalReasonFixedAssetSmartViewBusinessObject
    
    local cDelete := space(1) as character
    local cQuery       as character
    local cWhere       as character
    local cWhereTP     as character    
    local nIndice := 1 as numeric

    //Select
    cQuery := " SELECT  "
    cQuery += " N5_FILIAL, N5_CONTA, N5_TIPO, N5_DATA, N5_VALOR1, N5_VALOR2, N5_VALOR3, N5_VALOR4, N5_VALOR5 "
    cQuery += " FROM "+RetSqlName("SN5")+" SN5 "
    cQuery += " LEFT JOIN "+RetSqlName("CT1")+" CT1 ON CT1.D_E_L_E_T_  = ? "
    cQuery += "  AND CT1.CT1_FILIAL   = ? "
    cQuery += "  AND CT1.CT1_CONTA    = SN5.N5_CONTA "
    cQuery += " WHERE SN5.D_E_L_E_T_  = ? "
    cQuery += "   AND SN5.N5_FILIAL = ? "
    cQuery += "   AND SN5.N5_CONTA = ? "

    //Where
    cWhere := " N5_DATA <= ? "
    
    if !Empty(::cMVPAR14) .And. ::cMVPAR14 <> '*'
       	cWhere += "   AND SN5.N5_TPSALDO  = ?"
	endif

    if ::nMVPAR15 <> 4 .And. !Empty(::cTipoBem)
        cWhere += "   AND SN5.N5_TPBEM IN ? "
        cWhereTP := " AND SN5.N5_TPBEM IN ? "
    endif

    cQuery += "   AND ((SN5.N5_TIPO = ? "
    cQuery += cWhereTP
    cQuery += " ) OR "
    cQuery += cWhere
    cQuery += " ) "
	
	self:oQuerySN5 := FWExecStatement():New(ChangeQuery(cQuery))

    //Popula binds da query
    self:oQuerySN5:SetString(nIndice++, cDelete)
    self:oQuerySN5:SetString(nIndice++, FwXFilial("CT1"))
    self:oQuerySN5:SetString(nIndice++, cDelete)
    self:oQuerySN5:SetString(nIndice++, cFil)
    self:oQuerySN5:SetString(nIndice++, cConta)
    self:oQuerySN5:SetString(nIndice++, "0")

    //cWhereTP
    if ::nMVPAR15 <> 4 .And. !Empty(::cTipoBem)
        self:oQuerySN5:SetUnsafe(nIndice++, FormatIn(::cTipoBem,"/"))
    endif
    
    //cWhere
    self:oQuerySN5:SetString(nIndice++, DToS(FirstDay(Ctod("01/"+StrZero(::nMVPAR03,2)+"/"+StrZero(Year(dDataBase),4)))))
    if !Empty(::cMVPAR14) .And. ::cMVPAR14 <> '*'
        self:oQuerySN5:SetString(nIndice++, ::cMVPAR14)
    endif
    if ::nMVPAR15 <> 4 .And. !Empty(::cTipoBem)
        self:oQuerySN5:SetUnsafe(nIndice++, FormatIn(::cTipoBem,"/"))
    endif
	
	cQuery := self:oQuerySN5:GetFixQuery()

return cQuery
