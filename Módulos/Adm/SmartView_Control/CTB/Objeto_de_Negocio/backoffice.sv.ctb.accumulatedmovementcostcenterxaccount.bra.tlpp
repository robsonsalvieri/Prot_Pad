#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-core.th"
#include "tlpp-rest.th"
#Include "Protheus.ch"   
#include "backoffice.sv.ctb.accumulatedmovementcostcenterxaccount.bra.ch"

namespace totvs.protheus.ctb.smartviewintegratedprovider
using namespace totvs.protheus.backoffice.control.smartView.integratedProvider
using namespace control.sv.functions.utils

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGACTB", tables="CTT,CT1,CQ3", name="Mov. Acumulados C. Custo X Contas", country="ALL")

//-------------------------------------------------------------------------------
/*{Protheus.doc} AccumulatedMovementCostCenterxAccountSmartViewBusinessObject
Classe para criação do Objeto de Negócio de Cadastro Ativos para o SmartView
 
@author Bruno Oliveira
@since 25/10/2023
@version 1.0
*/
//-------------------------------------------------------------------------------

Class AccumulatedMovementCostCenterxAccountSmartViewBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

    public method new() as object
    public method getDescription() as character
    public method getAreas() as array
    public method getData() as object
    public method getSchema() as object

    //usados na internacionalização
    public method preschema()      as object 
    public method preData()        as object
    public method processData()    as json 

    private method CTR280Qry()

    PROTECTED data jDados       as json
    protected data aBinds       as array
    protected data cAlias       as character
    protected data oStatement   as object    
    protected data oIntegratedProvider as object
EndClass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
 
@return object: self
 
@author Bruno Oliveira
@since 25/10/2023
@version 1.0
*/
//------------------------------------------------------------------- 

Method new() as object Class AccumulatedMovementCostCenterxAccountSmartViewBusinessObject
    _Super:new()
    self:setDisplayName(STR0001)//"Mov. Acumulados C. Custo X Contas "
    self:setPergunte("CTR280") //Indica o pergunte que será utilizado no relatório
    
    ::aBinds := {}
    ::cAlias := ""
Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getDescription
Método de instância da classe
 
@return object: string
 
@author Bruno Oliveira
@since 25/10/2023
@version 1.0
*/
//------------------------------------------------------------------- 

Method getDescription() as character class AccumulatedMovementCostCenterxAccountSmartViewBusinessObject
return STR0002 //"Objeto contendo informações do Mov. Acumulados C. Custo X Contas"

//-------------------------------------------------------------------
/*{Protheus.doc} getAreas
Método de instância da classe
 
@return object: string
 
@author Bruno Oliveira
@since 25/10/2023
@version 1.0
*/
//------------------------------------------------------------------- 

Method getAreas() as array class AccumulatedMovementCostCenterxAccountSmartViewBusinessObject
Return {STR0003} //"Contabilidade"

//-------------------------------------------------------------------
/*/{Protheus.doc} preSchema
    Metodo que será consumido pelo M.I.
    @author wilton.santos
    @since 14/11/2023
    @version 12.1.2310
/*/
//-------------------------------------------------------------------
method preSchema() as object class AccumulatedMovementCostCenterxAccountSmartViewBusinessObject

return self:oSchema

//-------------------------------------------------------------------
/*/{Protheus.doc} preData
    Metodo que será consumido pelo M.I.
    AJusta o Json conforme alteração no processData e preSchema
    @author wilton.santos
    @since 14/11/2023
    @version 12.1.2310
/*/
//-------------------------------------------------------------------
method preData() as object class AccumulatedMovementCostCenterxAccountSmartViewBusinessObject
    
return self:oData

//-------------------------------------------------------------------
/*/{Protheus.doc} processData
    Metodo que será consumido pelo M.I.
    Será usado para alterar a Query antes do getData.
    @author wilton.santos
    @since 14/11/2023
    @version 12.1.2310
/*/
//-------------------------------------------------------------------
method processData() as json class AccumulatedMovementCostCenterxAccountSmartViewBusinessObject

return ::jDados

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio
 

 
@return object: self:oData
 
@author Bruno Oliveira
@since 25/10/2023
@version 1.0
*/
//------------------------------------------------------------------- 

method getData(nPage as numeric, oFilter as object) as object class AccumulatedMovementCostCenterxAccountSmartViewBusinessObject
    
    Local aTamConta	    := TAMSX3("CT1_CONTA") as array    
    Local aMeses        := {}    as array    
    Local aPeriodos              as array
    Local aSetOfBook             as array
    Local aSaldos                as array
    Local nX            := 0     as numeric
    Local nMeses        := 0     as numeric
    Local Li            := 0     as numeric
    Local nDigitAte 	:= 0     as numeric
    Local nPos			:= 0     as numeric
    Local nDigitos      := 0     as numeric
    Local nTamConta		:= 0     as numeric
    Local nCont                  as numeric
    Local nCol		             as numeric
    Local nTotais		         as numeric
    Local cMascara               as character    
    Local cSeparador 	:= ""    as character
    Local cSepConta 	:= ""    as character
    Local cSepCus   	:= ""    as character
    Local cString   	:= "CT1" as character
    Local cCodRes       := ""    as character
    Local cCtt_Custo 	:= ""    as character
    Local cCodResCC	    := ""    as character
    Local cPicture 	    := ""    as character
    Local cPict_        := ""    as character
    Local cMascConta             as character
    Local cMascCus               as character
    Local cCompanyName           as character
    Local cBranchName            as character
    Local cPlanoRef	             as character
    Local cVersao		         as character
    Local cCt3_Conta		     as character
    Local lImpCC     	:= .T.   as logical
    Local lImpConta              as logical
    Local lImprime               as logical
    Local lComSaldo              as logical
    Local jParams       := Nil   as json    
 
    jParams := oFilter:getParameters()  //metodo para retorno do json dos parâmetros
    CTBsetValueMVPAR(jParams, "CTR280") //Carrega lista de parametros para a memória

    self:oIntegratedProvider := ControlIntegratedProvider():New()
    cCompanyName := self:oIntegratedProvider:getCompanyName()
    cBranchName  := self:oIntegratedProvider:getBranchName()    

    aSetOfBook := CTBSetOf(mv_par10)

    // Verifica Se existe filtragem Ate o Segmento
    If !Empty(mv_par12)
        nDigitAte := CtbRelDig(mv_par12,cMascCus)
    EndIf

    If !Empty(mv_par13)			//// FILTRA O SEGMENTO Nº
        If Empty(mv_par10)		//// VALIDA SE O CÓDIGO DE CONFIGURAÇÃO DE LIVROS ESTÁ CONFIGURADO
                return self:oData
        Else
            If !Empty(aSetOfBook[5])
                return self:oData
            Endif
        Endif

        dbSelectArea("CTM")
        dbSetOrder(1)
        If MsSeek(xFilial()+aSetOfBook[7])
            While !Eof() .And. CTM->CTM_FILIAL == xFilial() .And. CTM->CTM_CODIGO == aSetOfBook[7]
                nPos += Val(CTM->CTM_DIGITO)
                If CTM->CTM_SEGMEN == STRZERO(val(mv_par13),2)
                    nPos -= Val(CTM->CTM_DIGITO)
                    nPos ++
                    nDigitos := Val(CTM->CTM_DIGITO)
                    Exit
                EndIf
                dbSkip()
            EndDo
        Else
                return self:oData
        EndIf
    EndIf

    If Empty(aSetOfBook[2])
        cMascara	:= GetMv("MV_MASCARA")	
    Else
        cMascara	:= RetMasCtb(aSetOfBook[2],@cSeparador)
    EndIf

    //Tratamento para tamnaho da conta + Mascara
    nTamConta	:= aTamConta[1] + Len(cMascara)
   
    aPeriodos := ctbPeriodos( Iif( Alltrim(mv_par07)=="", "01", mv_par07 ), mv_par01, mv_par02, .T., .F.)
    If Empty(aPeriodos[1][1])
        return self:oData
    EndIf

    For nCont := 1 to len(aPeriodos)
        //Se a Data do periodo eh maior ou igual a data inicial solicitada no relatorio.
        If aPeriodos[nCont][1] >= mv_par01 .And. aPeriodos[nCont][2] <= mv_par02
            AADD(aMeses,{StrZero(nMeses,2),aPeriodos[nCont][1],aPeriodos[nCont][2]})
            nMeses += 1
        Else
            AADD(aMeses,{"  ",ctod("  /  /  "),ctod("  /  /  ")})
        EndIf
    Next

    aSetOfBook := CTBSetOf(mv_par10)
    cPlanoRef	:= aSetOfBook[11]
    cVersao		:= aSetOfBook[12]

    //Se utiliza o plano referencial, desconsidera os filtros das entidades dos relatórios.
    If !Empty(cPlanoRef) .And. !Empty(cVersao)
        //Se o relatório não possuir conta, o plano referencial e a versão serão desconsiderados.
        //Será considerado cód. config. livros em branco.
        cPlanoRef		:= ""
        cVersao			:= ""
        aSetOfBook		:= CTBSetOf("")
    Endif

    nDecimais 	:= DecimalCTB(aSetOfBook,Iif( Alltrim(mv_par07)=="", "01", mv_par07 ))
    nDecim_     := nDecimais

    If Empty(aSetOfBook[2])
        cMascConta := GetMv("MV_MASCARA")
        cMascCus	  := GetMv("MV_MASCCUS")
    Else
        cMascConta := RetMasCtb(aSetOfBook[2],@cSepConta)
        cMascCus   := RetMasCtb(aSetofBook[6],@cSepCus)
    EndIf

    //Tratamento para tamnaho da conta + Mascara
    nTamConta	:= aTamConta[1] + Len(cMascConta)

    cPicture 	:= aSetOfBook[4]
    cPict_      := cPicture

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Localiza centro de custo inicial                             ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
    cAliasCT1 := "CT1"
    cAliasCTT := "CTT"
    self:CTR280Qry(aMeses,Iif( Alltrim(mv_par07)=="", "01", mv_par07 ),Iif( Alltrim(mv_par09)=="", "1", mv_par09 ),mv_par05,mv_par06,mv_par03,mv_par04,aSetOfBook,mv_par11 == 1,cString,/*aReturn[7]*/,.F./*lImpAntLP*/,/*dDataLP*/)
    
    cAliasCT1 := (self:cAlias)
    cAliasCTT := (self:cAlias)

    While (cAliasCTT)->(!Eof()) .And. (cAliasCTT)->CTT_FILIAL == FwxFilial("CTT") .And. (cAliasCTT)->CTT_CUSTO <= mv_par04
        
        // Guarda o centro de custo para ser utilizado na quebra
        cCtt_Custo 	:= (cAliasCTT)->CTT_CUSTO
        cCodResCC	:= (cAliasCTT)->CTT_RES
        lImpCC     	:= .T.

        // ******************** "FILTRAGEM PARA IMPRESSAO" *************************
        //Filtragem ate o Segmento ( antigo nivel do SIGACON)
        If !Empty(mv_par12)
            If Len(Alltrim((cAliasCTT)->CTT_CUSTO)) > nDigitAte
                (cAliasCTT)->(dbSkip())
                Loop
            Endif
        EndIf

        //Caso faca filtragem por segmento de item,verifico se esta dentro
        //da solicitacao feita pelo usuario.
        If !Empty(mv_par13)
            If Empty(mv_par14) .And. Empty(mv_par15) .And. !Empty(mv_par16)
                If  !(Substr((cAliasCTT)->CTT_CUSTO,nPos,nDigitos) $ (mv_par16) )
                    (cAliasCTT)->(dbSkip())
                    Loop
                EndIf
            Else
                If Substr((cAliasCTT)->CTT_CUSTO,nPos,nDigitos) < Alltrim(mv_par14) .Or. Substr((cAliasCTT)->CTT_CUSTO,nPos,nDigitos) > Alltrim(mv_par15)
                    (cAliasCTT)->(dbSkip())
                    Loop
                EndIf
            Endif
        EndIf

        While !Eof() .And. (cAliasCT1)->CT1_FILIAL == FwxFilial("CT1") .And. (cAliasCTT)->CTT_CUSTO == cCtt_Custo .And. (cAliasCT1)->CT1_CONTA <= mv_par06

            ::jDados := JsonObject():new()

            ::jDados["NomeEmpresa"] := cCompanyName 
            ::jDados["NomeFilial" ] := cBranchName  

            cCodRes := (cAliasCT1)->CT1_RES

            If mv_par18 == 1 
                ::jDados["C_CUSTO"]     := EntidadeCtb(cCtt_Custo,li,00,15,.f.,cMascCus,cSepCus,/*cAlias*/,/*nOrder*/,/*lGraf*/,/*oPrint*/,.F./*lSay*/)
            else
                ::jDados["C_CUSTO"]     := EntidadeCtb(cCodResCC,li,00,15,.f.,cMascCus,cSepCus,/*cAlias*/,/*nOrder*/,/*lGraf*/,/*oPrint*/,.F./*lSay*/)
            EndIf

            ::jDados["DESCRICAO_CC"]    := CtbDescMoeda("(cAliasCTT)->CTT_DESC"+Iif( Alltrim(mv_par07)=="", "01", mv_par07 ))   
            
            If mv_par18 == 1
                ::jDados["COD_CONTA"]   := EntidadeCTB(&("(cAliasCT1)->CT1_CONTA"),++li,00,nTamConta,.F.,cMascConta,cSepConta,/*cAlias*/,/*nOrder*/,/*lGraf*/,/*oPrint*/,.F./*lSay*/)
            Else
                ::jDados["COD_CONTA"]   := EntidadeCTB(cCodRes,++li,00,nTamConta,.F.,cMascConta,cSepConta,/*cAlias*/,/*nOrder*/,/*lGraf*/,/*oPrint*/,.F./*lSay*/)
            EndIf

            ::jDados["DESCRICAO_CONTA"] := CtbDescMoeda("(cAliasCT1)->CT1_DESC" + Iif( Alltrim(mv_par07)=="", "01", mv_par07 ))   

            lImpConta 	:= .T.
            lImprime := lImpCC .OR. lImpConta
            cCt3_Conta  := (cAliasCT1)->CT1_CONTA //CT3->CT3_CONTA
            nCol 	  	:= 1
            aSaldos 	:= {}
            nTotais 	:= 0

            For nX := 1 To Len(aPeriodos)
                ::jDados["ATEMES_"+StrZero(nX,2)] := Dtoc(aPeriodos[nX][2])
                 
                If aPeriodos[nX][1] >= mv_par01 .And. aPeriodos[nX][2] <= mv_par02
                    If mv_par19 == 2
                        aAdd(aSaldos,{ &("(cAliasCT1)->COLUNA"+alltrim(str(nX)))+nTotais,0,0,0,0,0} )/// ACUMULA MOVIMENTO
                    Else
                        aAdd(aSaldos,{ &("(cAliasCT1)->COLUNA"+alltrim(str(nX)))        ,0,0,0,0,0} )/// POR PERIODO (SEM ACUMULAR)
                    EndIf
                    nTotais += &("(cAliasCT1)->COLUNA"+alltrim(str(nX)))
                Else
                    Aadd(	aSaldos, {0,0,0,0,0,0})
                Endif
            Next

            lComSaldo	:= .F.

            For nX := 1 To Len(aPeriodos)
                If aSaldos[nX][1]  <> 0
                    lComSaldo	:= .T.
                    Exit
                EndIf
            Next

            If mv_par11 == 1  .And. !lComSaldo
                If CtbExDtFim("CTT")
                    //Se a data de existencia final  da entidade estiver preenchida e a data inicial do
                    //relatorio for maior, nao ira imprimir a entidade.
                    If !Empty((cAliasCTT)->CTTDTEXSF) .And. (dtos(mv_par01) > DTOS((cAliasCTT)->CTTDTEXSF))
                        dbSelectArea(cAliasCT1)
                        (cAliasCT1)->(dbSkip())
                        Loop
                    EndIf
                EndIf

                If CtbExDtFim("CT1")
                    //Se a data de existencia final  da entidade estiver preenchida e a data inicial do
                    //relatorio for maior, nao ira imprimir a entidade.
                    If !Empty((cAliasCT1)->CT1DTEXSF) .And. (dtos(mv_par01) > DTOS((cAliasCT1)->CT1DTEXSF))
                        dbSelectArea(cAliasCT1)
                        (cAliasCT1)->(dbSkip())
                        Loop
                    EndIf
                EndIf
            EndIf

            If mv_par11 == 1 .OR. (mv_par11 == 2 .AND. nTotais != 0)
                For nX := 1 To Len(aSaldos)                   
                    ::jDados["TOTALMES_"+StrZero(nX,2)] := aSaldos[nX][1] 
                    ::jDados["TOTMASCARA_"+StrZero(nX,2)] := ValorCTB(aSaldos[nX][1],li,48+(nCol++*19),17,nDecimais,.T.,cPicture,/*cTipo*/,/*cConta*/,/*lGraf*/,/*oPrint*/,/*cTipoSinal*/,/*cIdentifi*/,/*lPrintZero*/,.F./*lSay*/)
                Next
                self:processData()
                self:oData:appendData(::jDados)
            Endif
            dbSelectArea(cAliasCT1)
            (cAliasCT1)->(DbSkip())
        EndDo
    Enddo
    
    (self:cAlias)->(DBCloseArea())

    self:oStatement:Destroy()
    self:oStatement := nil

    //Elimina da memória a instância do objeto.
    FreeObj(jParams)
    FreeObj(self:oIntegratedProvider)

return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} getStruct
Prepara a estrutura dos campos
 
@param aCamposQry array: Array com os campos do relatório
 
@return array: Array com a estrutura dos campos
 
@author Bruno Oliveira
@since 25/10/2023
@version 1.0
*/
//------------------------------------------------------------------- 

method getSchema() as object class AccumulatedMovementCostCenterxAccountSmartViewBusinessObject

    Local cTypeVar          as character
    Local cNomeVar          as character
    Local nX         := 0   as numeric
    Local aCampos := {}  as array

    aCampos := {;
                    "TOTALMES_01", "TOTALMES_02", "TOTALMES_03", "TOTALMES_04","TOTALMES_05","TOTALMES_06",;
                    "TOTALMES_07", "TOTALMES_08", "TOTALMES_09", "TOTALMES_10","TOTALMES_11","TOTALMES_12",;
                    "TOTALMES_13", "TOTALMES_14", "TOTALMES_15", "TOTALMES_16","TOTALMES_17","TOTALMES_18",;
                    "TOTALMES_19", "TOTALMES_20", "TOTALMES_21", "TOTALMES_22","TOTALMES_23","TOTALMES_24",;
                    "TOTALMES_25", "TOTALMES_26", "TOTALMES_27", "TOTALMES_28","TOTALMES_29","TOTALMES_30",;
                    "TOTALMES_31", "TOTALMES_32", "TOTALMES_33", "TOTALMES_34","TOTALMES_35","TOTALMES_36",;
                    "TOTALMES_37", "TOTALMES_38", "TOTALMES_39", "TOTALMES_40","TOTALMES_41","TOTALMES_42",;
                    "TOTALMES_43", "TOTALMES_44", "TOTALMES_45", "TOTALMES_46","TOTALMES_47","TOTALMES_48",;
                    ;
                    "ATEMES_01", "ATEMES_02", "ATEMES_03", "ATEMES_04","ATEMES_05","ATEMES_06",;
                    "ATEMES_07", "ATEMES_08", "ATEMES_09", "ATEMES_10","ATEMES_11","ATEMES_12",;
                    "ATEMES_13", "ATEMES_14", "ATEMES_15", "ATEMES_16","ATEMES_17","ATEMES_18",;
                    "ATEMES_19", "ATEMES_20", "ATEMES_21", "ATEMES_22","ATEMES_23","ATEMES_24",;
                    "ATEMES_25", "ATEMES_26", "ATEMES_27", "ATEMES_28","ATEMES_29","ATEMES_30",;
                    "ATEMES_31", "ATEMES_32", "ATEMES_33", "ATEMES_34","ATEMES_35","ATEMES_36",;
                    "ATEMES_37", "ATEMES_38", "ATEMES_39", "ATEMES_40","ATEMES_41","ATEMES_42",;
                    "ATEMES_43", "ATEMES_44", "ATEMES_45", "ATEMES_46","ATEMES_47","ATEMES_48",;
                    ;
                    "TOTMASCARA_01", "TOTMASCARA_02", "TOTMASCARA_03", "TOTMASCARA_04","TOTMASCARA_05","TOTMASCARA_06",;
                    "TOTMASCARA_07", "TOTMASCARA_08", "TOTMASCARA_09", "TOTMASCARA_10","TOTMASCARA_11","TOTMASCARA_12",;
                    "TOTMASCARA_13", "TOTMASCARA_14", "TOTMASCARA_15", "TOTMASCARA_16","TOTMASCARA_17","TOTMASCARA_18",;
                    "TOTMASCARA_19", "TOTMASCARA_20", "TOTMASCARA_21", "TOTMASCARA_22","TOTMASCARA_23","TOTMASCARA_24",;
                    "TOTMASCARA_25", "TOTMASCARA_26", "TOTMASCARA_27", "TOTMASCARA_28","TOTMASCARA_29","TOTMASCARA_30",;
                    "TOTMASCARA_31", "TOTMASCARA_32", "TOTMASCARA_33", "TOTMASCARA_34","TOTMASCARA_35","TOTMASCARA_36",;
                    "TOTMASCARA_37", "TOTMASCARA_38", "TOTMASCARA_39", "TOTMASCARA_40","TOTMASCARA_41","TOTMASCARA_42",;
                    "TOTMASCARA_43", "TOTMASCARA_44", "TOTMASCARA_45", "TOTMASCARA_46","TOTMASCARA_47","TOTMASCARA_48"}

    self:oSchema:addProperty( "C_CUSTO"        ,STR0004, "string"  , STR0004, "C_CUSTO"        ,,,,.F. ) // "Centro Custo" 
    self:oSchema:addProperty( "DESCRICAO_CC"   ,STR0005, "string"  , STR0005, "DESCRICAO_CC"   ,,,,.F. ) // "Desc. Centro Custo" 
    self:oSchema:addProperty( "COD_CONTA"      ,STR0006, "string"  , STR0006, "COD_CONTA"      ,,,,.F. ) // "Cod. Conta" 
    self:oSchema:addProperty( "DESCRICAO_CONTA",STR0007, "string"  , STR0007, "DESCRICAO_CONTA",,,,.F. ) // "Descricao Conta"    
    
    For nX := 1 To len(aCampos)
        cTypeVar := Iif(SUBSTR( aCampos[nX], 1, 5) == "TOTAL","number" ,"string")        
        cNomeVar := Iif(SUBSTR( aCampos[nX], 1, 5) == "TOTAL","Total Mês " + cvaltochar(nX)  ,;
                        Iif(SUBSTR( aCampos[nX], 1, 5) == "TOTMA","Tot. Mês Mascara " + cvaltochar(nX-96 )  ,"ATÉ o Mês " + cvaltochar(nX-48 ) ) )
        
        self:oSchema:addProperty( aCampos[nX], cNomeVar, cTypeVar , cNomeVar, aCampos[nX],,,,.F. )      
    Next nX

    self:oSchema:addProperty( "NomeEmpresa"    ,STR0008, "string"  , STR0008, "NomeEmpresa",,,,.F. ) // "Nome Empresa"
    self:oSchema:addProperty( "NomeFilial"     ,STR0009, "string"  , STR0009, "NomeFilial" ,,,,.F. ) // "Nome Filial"
        
return self:oSchema

//-------------------------------------------------------------------
/*{Protheus.doc} getStruct
Cria tabela Temporaria conforme parametros informados.
 
@author Bruno Oliveira
@since 25/10/2023
@version 1.0
*/
//------------------------------------------------------------------- 
method CTR280Qry(aPeriodos,cMoeda,cTpSaldo,cContaIni,cContaFim,cCustoIni,cCustoFim,aSetOfBook,lVlrZerado,cString,cFILUSU,lImpAntLP,dDataLP) class AccumulatedMovementCostCenterxAccountSmartViewBusinessObject
    Local aSaveArea	  := GetArea() as array
    Local aTamVlr	  := TAMSX3("CT2_VALOR") as array
    Local cQuery	  := ""  as character
    Local nColunas	  := 0   as numeric
    Local nParamOrder := 1   as numeric
    Local nX          := 1   as numeric    
    Local l1St 		  := .T. as logical
    Local lAbriu	  := .F. as logical    

    DEFAULT lVlrZerado	:= .F.  
    DEFAULT lImpAntLP   := .F.  
    DEFAULT cFilUSU		:= ""
    DEFAULT cString		:= "CTT"
    DEFAULT aSetOfBook  := {""}

    cQuery := " SELECT CT1_FILIAL CT1_FILIAL, CT1_CONTA CT1_CONTA,CT1_NORMAL CT1_NORMAL, CT1_RES CT1_RES, CT1_DESC01 CT1_DESC01, CT1_DESC"+cMoeda+" CT1_DESC"+cMoeda+", "

    If CtbExDtFim("CT1")
        cQuery += "CT1_DTEXSF CT1DTEXSF, "
    EndIf
    cQuery += " 	CT1_CLASSE CT1_CLASSE, CT1_GRUPO CT1_GRUPO, CT1_CTASUP CT1_CTASUP, "
    cQuery += " 	CTT_FILIAL CTT_FILIAL, CTT_CUSTO CTT_CUSTO, CTT_DESC01 CTT_DESC01, CTT_DESC"+cMoeda+" CTT_DESC"+cMoeda+", CTT_CLASSE CTT_CLASSE, CTT_RES CTT_RES, CTT_CCSUP CTT_CCSUP, "

    If CtbExDtFim("CTT")
        cQuery += "CTT_DTEXSF CTTDTEXSF, "
    EndIf

    ////////////////////////////////////////////////////////////
    //// TRATAMENTO PARA O FILTRO DE USUÁRIO NO RELATORIO
    ////////////////////////////////////////////////////////////
    cCampUSU  := ""										//// DECLARA VARIAVEL COM OS CAMPOS DO FILTRO DE USUÁRIO
  
    cQuery += cCampUSU									//// ADICIONA OS CAMPOS NA QUERY
    ////////////////////////////////////////////////////////////

    For nColunas := 1 to Len(aPeriodos)
        If !Empty(aPeriodos[nColunas][1])
            cQuery += " 	(SELECT SUM(CQ3_CREDIT) - SUM(CQ3_DEBITO) "
            cQuery += "			 	FROM "+RetSqlName("CQ3")+" CQ3 "
            cQuery += " 			WHERE CQ3.CQ3_FILIAL = ? "
            cQuery += " 			AND CQ3_MOEDA = ? "
            cQuery += " 			AND CQ3_TPSALD = ? "
            cQuery += " 			AND CQ3_CONTA	= ARQ.CT1_CONTA "
            cQuery += " 			AND CQ3_CCUSTO	= ARQ2.CTT_CUSTO "

            AADD( self:aBinds, {"string",nParamOrder++, FWxFilial("CQ3")} )
            AADD( self:aBinds, {"string",nParamOrder++, cMoeda} )
            AADD( self:aBinds, {"string",nParamOrder++, cTpSaldo} )

            If l1St .And. mv_par19 == 2	//	Se for o primeiro periodo e Saldo Acumulado
                cQuery += " 			AND CQ3_DATA <= ? "
                l1St := .F.
                AADD( self:aBinds, {"date",nParamOrder++, aPeriodos[nColunas][3]} )
            Else
                cQuery += " 			AND CQ3_DATA BETWEEN ? AND ? "
                AADD( self:aBinds, {"date",nParamOrder++, aPeriodos[nColunas][2]} )
                AADD( self:aBinds, {"date",nParamOrder++, aPeriodos[nColunas][3]} )
            Endif

            cQuery += " 			AND CQ3.D_E_L_E_T_ = ? ) COLUNA"+Str(nColunas,Iif(nColunas>9,2,1))+" "
            AADD( self:aBinds, {"string",nParamOrder++, ' '} )
        Else
            cQuery += " 0 COLUNA"+Str(nColunas,Iif(nColunas>9,2,1))+" "
        Endif

        If nColunas <> Len(aPeriodos)
            cQuery += ", "
        EndIf
    Next

    cQuery += " 	FROM "+RetSqlName("CT1")+" ARQ, "+RetSqlName("CTT")+" ARQ2 "
    cQuery += " 	WHERE ARQ.CT1_FILIAL = ? "
    cQuery += " 	AND ARQ.CT1_CONTA BETWEEN ? AND ? "
    cQuery += " 	AND ARQ.CT1_CLASSE = ? "

    AADD( self:aBinds, {"string",nParamOrder++, FWxFilial("CT1")} )
    AADD( self:aBinds, {"string",nParamOrder++, cContaIni} )
    AADD( self:aBinds, {"string",nParamOrder++, cContaFim} )
    AADD( self:aBinds, {"string",nParamOrder++, "2"} )

    If !Empty(aSetOfBook[1])										//// SE HOUVER CODIGO DE CONFIGURAÇÃO DE LIVROS
        cQuery += " 	AND ARQ.CT1_BOOK LIKE '%?%' "    //// FILTRA SOMENTE CONTAS DO MESMO SETOFBOOKS
        AADD( self:aBinds, {"unsafe",nParamOrder++, aSetOfBook[1]} )
    Endif
    cQuery += " 	AND ARQ.D_E_L_E_T_ = ? "
    AADD( self:aBinds, {"string",nParamOrder++, ' '} )

    cQuery += " 	AND ARQ2.CTT_FILIAL = ? "
    cQuery += " 	AND ARQ2.CTT_CUSTO BETWEEN ? AND ? "
    cQuery += " 	AND ARQ2.CTT_CLASSE = ? "

    AADD( self:aBinds, {"string",nParamOrder++, FWxFilial("CTT")} )
    AADD( self:aBinds, {"string",nParamOrder++, cCustoIni} )
    AADD( self:aBinds, {"string",nParamOrder++, cCustoFim} )
    AADD( self:aBinds, {"string",nParamOrder++, "2"} )

    If !Empty(aSetOfBook[1])										//// SE HOUVER CODIGO DE CONFIGURAÇÃO DE LIVROS
        cQuery += " 	AND ARQ2.CTT_BOOK LIKE '%?%' "    //// FILTRA SOMENTE CONTAS DO MESMO SETOFBOOKS
        AADD( self:aBinds, {"unsafe",nParamOrder++, aSetOfBook[1]} )
    Endif
    cQuery += " 	AND ARQ2.D_E_L_E_T_ = ?  "
    AADD( self:aBinds, {"string",nParamOrder++, ' '} )

    l1St := .T.

    If !lVlrZerado
        For nColunas := 1 to Len(aPeriodos)
            If !Empty(aPeriodos[nColunas][1])
                If ! lAbriu
                    cQuery += " 	AND ( "
                    lAbriu := .T.
                EndIf
                If !l1St
                    cQuery += " 	OR "
                EndIf
                cQuery += "	(SELECT SUM(CQ3_CREDIT) - SUM(CQ3_DEBITO) "
                cQuery += " FROM "+RetSqlName("CQ3")+" CQ3 "
                cQuery += " WHERE CQ3.CQ3_FILIAL	= ? "
                cQuery += " AND CQ3_MOEDA = ? "
                cQuery += " AND CQ3_TPSALD = ? "
                cQuery += " AND CQ3_CONTA	= ARQ.CT1_CONTA "
                cQuery += " AND CQ3_CCUSTO	= ARQ2.CTT_CUSTO "

                AADD( self:aBinds, {"string",nParamOrder++, FWxFilial("CQ3")} )
                AADD( self:aBinds, {"string",nParamOrder++, cMoeda} )
                AADD( self:aBinds, {"string",nParamOrder++, cTpSaldo} )

                If l1St .And. mv_par19 == 2	//	Se for o primeiro periodo e Saldo Acumulado
                    cQuery += " AND CQ3_DATA <= ? "
                    AADD( self:aBinds, {"date",nParamOrder++, aPeriodos[nColunas][3]} )
                Else
                    cQuery += " AND CQ3_DATA BETWEEN ? AND ? "
                    AADD( self:aBinds, {"date",nParamOrder++, aPeriodos[nColunas][2]} )
                    AADD( self:aBinds, {"date",nParamOrder++, aPeriodos[nColunas][3]} )
                Endif
                l1St := .F.

                cQuery += " 	AND CQ3.D_E_L_E_T_ =  ?) <> ? "
                AADD( self:aBinds, {"string",nParamOrder++, ' '} )
                AADD( self:aBinds, {"numeric",nParamOrder++, 0} )
            Endif
            If lAbriu .And. nColunas == Len(aPeriodos)
                cQuery += " ) "
            EndIf
        Next
    Endif

    cQuery += " ORDER BY CTT_CUSTO,CT1_CONTA "

    cQuery := ChangeQuery(cQuery)

    self:oStatement := FWExecStatement():New(cQuery) 

    For nX:=1 to Len(self:aBinds)
        If self:aBinds[nX][1] == "unsafe"
            self:oStatement:SetUnsafe(self:aBinds[nX][2], self:aBinds[nX][3])
        ElseIf  self:aBinds[nX][1] == "date"  
            self:oStatement:SetDate(self:aBinds[nX][2], self:aBinds[nX][3])
        ElseIf self:aBinds[nX][1] == "string"
            self:oStatement:SetString(self:aBinds[nX][2], self:aBinds[nX][3])
        ElseIf self:aBinds[nX][1] == "numeric"
            self:oStatement:SetNumeric(self:aBinds[nX][2], self:aBinds[nX][3])
        EndIf
    Next nX

    self:oStatement:GetFixQuery()
    
    self:cAlias := self:oStatement:OpenAlias()

    For nColunas := 1 to Len(aPeriodos)
        TcSetField((self:cAlias),"COLUNA"+Str(nColunas,Iif(nColunas>9,2,1)),"N",aTamVlr[1],aTamVlr[2])
    Next

    If CtbExDtFim("CTT")
        TCSetField((self:cAlias),"CTTDTEXSF","D",8,0)
    EndIf

    If CtbExDtFim("CT1")
        TCSetField((self:cAlias),"CT1DTEXSF","D",8,0)
    EndIf

    RestArea(aSaveArea)

Return
