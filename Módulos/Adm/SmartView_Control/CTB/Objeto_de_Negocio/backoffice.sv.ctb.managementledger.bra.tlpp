#include "totvs.ch"
#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "backoffice.sv.ctb.managementledger.bra.ch"                   

namespace totvs.protheus.ctb.smartviewintegratedprovider
using namespace control.sv.functions.utils

@totvsFrameworkTReportsIntegratedProvider(active=.T.,team="SIGACTB",tables="CT1, CT2", NAME="Razão Gerencial", country="ALL")

class ManagementLedgerSmartViewBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider
   
    public method new()            as object
    public method getDescription() as character
    public method getAreas()       as array
    public method getData()        as object
    public method getSchema()      as object
    
	protected method SCtbRazGer()   
	protected method SCtbGrvNoMov()   
	protected method SCtbGerRazG()   
	protected method SCtbGrvRAZG()   
	protected method getSaldos()   as json   
	protected method Ctr430Sint()  as array   

	protected data jItens      as Json
	protected data cAlias      as character
	protected data TAM_VALOR   as numeric
	protected data oCTBR430    as object	

    public method processData()             as json
    public method preSchema()               as object
    public method preData()                 as object	

EndClass
//-------------------------------------------------------------------
//https://tdn.totvs.com.br/display/tec/ProtheusDOC
/*{Protheus.doc} backoffice.sv.ctb.managementledger.bra
Método de instância da classe
@author  loex
@since   11/12/2024
@version version
*/
//-------------------------------------------------------------------
method new() as object class ManagementLedgerSmartViewBusinessObject

	_Super:new()
	//Define o nome do Objeto de Negócio
	self:setDisplayName(STR0001) //  "Razão Gerencial"
	self:setPergunte("CTR430") //Indica o pergunte que será utilizado no relatório
	self:cAlias := " "
	self:TAM_VALOR := 18

return self
//-------------------------------------------------------------------
//https://tdn.totvs.com.br/display/tec/ProtheusDOC
/*{Protheus.doc} backoffice.sv.ctb.managementledger.bra
Retorna descrição do objeto da classe
@author  loex
@since   11/12/2024
@version version
*/
//-------------------------------------------------------------------
method getDescription() as character class ManagementLedgerSmartViewBusinessObject
return STR0002 //"Objeto contendo informações sobre o Razão Gerencial"
//-------------------------------------------------------------------
//https://tdn.totvs.com.br/display/tec/ProtheusDOC
/*{Protheus.doc} backoffice.sv.ctb.managementledger.bra
Retorna modulo do objeto
@author  loex
@since   11/12/2024
@version version
*/
//-------------------------------------------------------------------
Method getAreas() as array class ManagementLedgerSmartViewBusinessObject
Return {STR0003} //"Contabilidade" 

//-------------------------------------------------------------------
//https://tdn.totvs.com.br/display/tec/ProtheusDOC
/*{Protheus.doc} backoffice.sv.ctb.managementledger.bra
Retorna os dados do objeto de negócio
@author  loex
@since   11/12/2024
@version version
*/
//-------------------------------------------------------------------

method getData(nPage as numeric, oFilter as object) as object class ManagementLedgerSmartViewBusinessObject
local cArqTmp               as character
Local cMoeda     :=  "01"   as character
Local cSaldo     :=  "1"    as character
Local cEntGerIni            as character
Local cEntGerFim            as character
Local dDataIni              as date
Local dDataFim              as date
Local aSetOfBook            as array
Local lNoMov                as logical
Local lAnalitico            as logical
Local cCodPlGer             as character
Local cSepara               as character
Local nDecimais             as numeric
Local cMascCta              as character
Local cMascCus              as character
Local cMascIte              as character
Local cMascClv              as character

Local cDescConta			as character
Local cDescCusto			as character
Local cDescItem				as character
Local cDescCLVL				as character

Local cResClVl              as character
Local cResCC                as character
Local cResItem              as character

Local lCusto                as logical
Local lItem                 as logical
Local lClVl                 as logical

Local lImpCusto 		    as logical
Local lImpItem  		    as logical
Local lImpCLVL  		    as logical
Local nCount             	as Numeric

//Preenchimento dos MV_PAR's
CTBsetValueMVPAR(oFilter:getParameters(), "CTR430" )

//Elimina da memória a instância do objeto informado como parâmetro.
FreeObj(oFilter:getParameters())  

cCodPlGer   := MV_PAR01
 
If !Empty(cCodPlGer)

	dbSelectArea("CTN")
	dbSetOrder(1)
	If !MsSeek(xFilial("CTN")+cCodPlGer)
		Return self:oData
	Else
		aSetOfBook  := CTBSetOf(cCodPlGer)				//Cod. Config. Livros ?
	EndIf
         
    cEntGerIni  := MV_PAR02         				    //Da Entidade Gerencial ?       
    cEntGerFim  := MV_PAR03       					    //Ate a Entidade Gerencial ?    
    dDataIni    := MV_PAR04       					    //Data Inicial ?                
    dDataFim    := MV_PAR05       					    //Data Final ?                  
    cMoeda      := iif(Empty(MV_PAR06),cMoeda,MV_PAR06) //Moeda ?                       
    cSaldo      := Iif(!Empty(MV_PAR07), PadR(AllTrim(MV_PAR07), TamSX3("CT2_TPSALD")[1]), cSaldo)//Imprime Saldos ?              
    lAnalitico  := Iif(MV_PAR08 == 1,.T.,.F.)     		//Tipo Relatorio ?              
    lNoMov		:= Iif(MV_PAR09 == 1,.T.,.F.)      		//Imprime Ent. Ger. Sem Movim. ?
    lCusto      := Iif(MV_PAR10 == 1,.T.,.F.)			//Imprime C.Custo ?             
    lItem       := Iif(MV_PAR11 == 1,.T.,.F.)			//Imprime Item ?                
    lCLVL       := Iif(MV_PAR12 == 1,.T.,.F.)			//Imprime Classe de Valor ?     
    lImpCusto   := Iif(MV_PAR17 == 1,.T.,.F.)       	//Imprime Cod. C.Custo ?        
    lImpItem    := Iif(MV_PAR18 == 1,.T.,.F.)       	//Imprime Cod. Item ?           
    lImpCLVL    := Iif(MV_PAR19 == 1,.T.,.F.)       	//Imprime Cod. Cl.Valor ?

    nDecimais := DecimalCTB(aSetOfBook,cMoeda) 
    cPicture  := Iif(!Empty(aSetOfBook[4]),"@E 9,999,999,999.99","")
    
    //COLETANDO AS 4 MASCARAS
    cMascCta   := IIF(Empty(aSetOfBook[2]),SuperGetMv("MV_MASCARA"),RetMasCtb(aSetOfBook[2],@cSepara))//Mascara da Conta
    If lCusto
        cMascCus   := IIF(Empty(aSetOfBook[6]),SuperGetMv("MV_MASCCUS"),RetMasCtb(aSetOfBook[6],@cSepara))//Mascara do Centro de Custo
    EndIf
    If lItem
        cMascIte   := IIF(Empty(aSetOfBook[7]),SuperGetMv("MV_MASCCTD"),RetMasCtb(aSetOfBook[7],@cSepara))//Mascara do Item Contabil    
    EndIf
    If lClVl
        cMascClv   := IIF(Empty(aSetOfBook[8]),SuperGetMv("MV_MASCCTH"),RetMasCtb(aSetOfBook[8],@cSepara))//Mascara da Classe Valor
    EndIf
    
	self:SCTBGerRazG(@cArqTmp,cEntGerIni,cEntGerFim,cMoeda,dDataIni,dDataFim,;
	aSetOfBook,lNoMov,cSaldo,lAnalitico,cCodPlGer,lCusto,lItem,lClVl)	

    dbSelectArea("cArqTmp")
    cArqTMP->(dbGoTop())  
  
    nCount := 0 

    Do While cArqTMP->(!EOF())
        
		//Tratamento para mascara
        cConta := EntidadeCTB(cArqTMP->CONTA ,0,0,Nil/*Tamanho*/,.F.,cMascCta,""/*Separador*/,"CT1",,,,.F.)
        cCusto := EntidadeCTB(cArqTMP->CUSTO ,0,0,Nil/*Tamanho*/,.F.,cMascCus,""/*Separador*/,"CTT",,,,.F.)
        cItem  := EntidadeCTB(cArqTMP->ITEM  ,0,0,Nil/*Tamanho*/,.F.,cMascIte,""/*Separador*/,"CTD",,,,.F.)
        cClvl  := EntidadeCTB(cArqTMP->CLVL  ,0,0,Nil/*Tamanho*/,.F.,cMascClv,""/*Separador*/,"CTH",,,,.F.)

		//descrição da conta e conta superior
		aConta     := self:Ctr430Sint(cArqTMP->CONTA,cCodPlGer)
		cDescConta := aConta[1]
		
		If lCusto
			CTT->(dbSetOrder(1))
			CTT->(MsSeek(xFilial("CTT")+cArqTmp->CUSTO))
			cResCC     := CTT->CTT_RES
			cDescCusto := &("CTT->CTT_DESC" + alltrim(cMoeda) )	
		EndIf
		If lItem
			CTD->(dbSetOrder(1))
			CTD->(MsSeek(xFilial("CTD")+cArqTmp->ITEM))
			cResItem   := CTD->CTD_RES
			cDescItem  := &("CTD->CTD_DESC" + alltrim(cMoeda) )
		EndIf
		If lCLVL
			CTH->(dbSetOrder(1))
        	CTH->(dbSeek(xFilial("CTH")+cArqTmp->CLVL))
        	cResClVl   := CTH->CTH_RES				
			cDescCLVL  := &("CTH->CTH_DESC" + alltrim(cMoeda) )
		EndIf

		::jItens := JsonObject():new()
		
		::jItens["CONTA"] 	  	:= cArqTMP->CONTA      
        ::jItens["CONTA_M"]   	:= cConta              
        ::jItens["DESCONTA"]  	:= alltrim(cDescConta)
		::jItens["NORMAL"]    	:= cArqTMP->NORMAL     
        ::jItens["TIPO"] 	  	:= cArqTMP->TIPO       
        ::jItens["LANCDEB"]   	:= cArqTMP->LANCDEB    
        ::jItens["LANCDEB_M"] 	:= ValorCTB(cArqTMP->LANCDEB,,,self:TAM_VALOR-2,nDecimais,.T.,cPicture,cArqTmp->NORMAL,,,,,,.T.,.F.)
        ::jItens["LANCCRD"]   	:= cArqTMP->LANCCRD    
        ::jItens["LANCCRD_M"] 	:= ValorCTB(cArqTMP->LANCCRD,,,self:TAM_VALOR-2,nDecimais,.T.,cPicture,cArqTmp->NORMAL,,,,,,.T.,.F.)
        ::jItens["TPSLD"] 	  	:= cArqTMP->TPSLD      
        ::jItens["HISTORICO"] 	:= cArqTMP->HISTORICO  
        ::jItens["CUSTO"] 	  	:= cArqTMP->CUSTO      
        ::jItens["CUSTO_M"]   	:= cCusto              
        ::jItens["DESCUSTO"]  	:= alltrim(iif(lImpCusto,cDescCusto,cResCC))
		::jItens["ITEM"] 	  	:= cArqTMP->ITEM       
        ::jItens["ITEM_M"] 	  	:= cItem               
        ::jItens["DESITEM"]   	:= alltrim(iif(lImpItem,cDescCusto,cResItem))
		::jItens["CLVL"] 	  	:= cArqTMP->CLVL       
        ::jItens["CLVL_M"]    	:= cClvl               
        ::jItens["DESCLVL"]   	:= alltrim(iif(lImpCLVL,cDescCLVL,cResClVl))
		::jItens["DATAL"]     	:= totvs.framework.treports.date.dateToTimeStamp(cArqTMP->DATAL)  
        ::jItens["LOTE"]      	:= cArqTMP->LOTE       
        ::jItens["SUBLOTE"]   	:= cArqTMP->SUBLOTE    
        ::jItens["DOC"] 	  	:= cArqTMP->DOC        
        ::jItens["LINHA"]     	:= cArqTMP->LINHA      
        ::jItens["SEQLAN"]    	:= cArqTMP->SEQLAN     
        ::jItens["SEQHIST"]   	:= cArqTMP->SEQHIST    
        ::jItens["EMPORI"]    	:= cArqTMP->EMPORI     
        ::jItens["FILORI"]    	:= cArqTMP->FILORI     
        ::jItens["NOMOV"]     	:= cArqTMP->NOMOV      
        ::jItens["FILIAL"]    	:= cArqTMP->FILIAL
		::jItens["CONTASUP"]    := aConta[2]  
		::jItens["CONTASUP_M"]  := EntidadeCTB(aConta[2],0,0,Nil/*Tamanho*/,.F.,cMascCta,""/*Separador*/,"CT1",,,,.F.)  
		::jItens["DESCONTASUP"] := aConta[3]   
		
		self:getSaldos(cCodPlGer,dDataIni,dDataFim,cMoeda,cSaldo,lNoMov)
		self:processData()
		self:oData:appendData(::jItens)

		cDescConta := ""
		cResCC 	   := ""
		cDescCusto := ""	
		cResItem   := ""
		cDescItem  := ""
		cResClVl   := ""				
		cDescCLVL  := ""

		cArqTMP->(DbSkip())
		nCount++

    ENDDO

    cArqTMP->(DBCloseArea())
EndIF

If ::oCTBR430 <> Nil
	::oCTBR430:Delete()
	::oCTBR430 := Nil
Endif

return self:oData
//-------------------------------------------------------------------
//https://tdn.totvs.com.br/display/tec/ProtheusDOC
/*{Protheus.doc} backoffice.sv.ctb.managementledger.bra
Prepara a estrutura dos campos
@author  loex
@since   11/12/2024
@version version
*/
//-------------------------------------------------------------------
method getSchema() as object class ManagementLedgerSmartViewBusinessObject

self:oSchema:addProperty("CONTA"      ,STR0004 ,"string" ,STR0004 ,"CONTA"    )// Codigo da Conta
self:oSchema:addProperty("CONTA_M"    ,STR0005 ,"string" ,STR0005 ,"CONTA_M"    )// Cod Conta Masc
self:oSchema:addProperty("NORMAL"     ,STR0006 ,"string" ,STR0006 ,"NORMAL"   )// Normal
self:oSchema:addProperty("DESCONTA"   ,STR0035 ,"string" ,STR0035 ,"DESCONTA" )// Descr. da Conta
self:oSchema:addProperty("TIPO"       ,STR0007 ,"string" ,STR0007 ,"TIPO"     )// Tipo
self:oSchema:addProperty("LANCDEB"    ,STR0008 ,"number" ,STR0008 ,"LANCDEB"  )// Debito 
self:oSchema:addProperty("LANCDEB_M"  ,STR0009 ,"string" ,STR0009 ,"LANCDEB_M"  )// Debito Masc
self:oSchema:addProperty("LANCCRD"    ,STR0010 ,"number" ,STR0010 ,"LANCCRD"  )// Credito
self:oSchema:addProperty("LANCCRD_M"  ,STR0011 ,"string" ,STR0011 ,"LANCCRD_M"  )// Credito Masc
self:oSchema:addProperty("SALDOSCR"   ,STR0012 ,"number" ,STR0012 ,"SALDOSCR" )// Saldo
self:oSchema:addProperty("SALDOSCR_M" ,STR0013 ,"string" ,STR0013 ,"SALDOSCR_M" )// Saldo Masc
self:oSchema:addProperty("TPSLD"      ,STR0014 ,"string" ,STR0014 ,"TPSLD"    )// Sinal do Saldo 
self:oSchema:addProperty("HISTORICO"  ,STR0015 ,"string" ,STR0015 ,"HISTORICO")// Historico
self:oSchema:addProperty("CUSTO"      ,STR0016 ,"string" ,STR0016 ,"CUSTO"    )// Centro de Custo
self:oSchema:addProperty("CUSTO_M"    ,STR0017 ,"string" ,STR0017 ,"CUSTO_M"    )// Centro de Custo Masc   
self:oSchema:addProperty("DESCUSTO"   ,STR0036 ,"string" ,STR0036 ,"DESCUSTO" )// Descr. Centro de Custo
self:oSchema:addProperty("ITEM"       ,STR0018 ,"string" ,STR0018 ,"ITEM"     )// Item Contabil 
self:oSchema:addProperty("ITEM_M"     ,STR0019 ,"string" ,STR0019 ,"ITEM_M"     )// Item Contabil Masc
self:oSchema:addProperty("DESITEM"    ,STR0037 ,"string" ,STR0037 ,"DESITEM"  )// Descr. Item Contabil 
self:oSchema:addProperty("CLVL"       ,STR0020 ,"string" ,STR0020 ,"CLVL"     )// Classe de Valor
self:oSchema:addProperty("CLVL_M"     ,STR0021 ,"string" ,STR0021 ,"CLVL_M"     )// Classe de Valor Masc
self:oSchema:addProperty("DESCLVL"    ,STR0038 ,"string" ,STR0038 ,"DESCLVL"  )// Descr. Classe de Valor
self:oSchema:addProperty("DATAL"      ,STR0022 ,"date"   ,STR0022 ,"DATAL"    )// Data Lancamento
self:oSchema:addProperty("LOTE"       ,STR0023 ,"string" ,STR0023 ,"LOTE"     )// Lote
self:oSchema:addProperty("SUBLOTE"    ,STR0024 ,"string" ,STR0024 ,"SUBLOTE"  )// Sublote
self:oSchema:addProperty("DOC"        ,STR0025 ,"string" ,STR0025 ,"DOC"      )// Documento
self:oSchema:addProperty("LINHA"      ,STR0026 ,"string" ,STR0026 ,"LINHA"    )// Linha
self:oSchema:addProperty("SEQLAN"     ,STR0027 ,"string" ,STR0027 ,"SEQLAN"   )// Sequencia do Lancamento
self:oSchema:addProperty("SEQHIST"    ,STR0028 ,"string" ,STR0028 ,"SEQHIST"  )// Sequencia do Historico
self:oSchema:addProperty("EMPORI"     ,STR0029 ,"string" ,STR0029 ,"EMPORI"   )// Empresa Origem
self:oSchema:addProperty("FILORI"     ,STR0030 ,"string" ,STR0030 ,"FILORI"   )// Filial Origem
self:oSchema:addProperty("NOMOV"      ,STR0031 ,"boolean",STR0031 ,"NOMOV"    )// Conta Sem Movimento
self:oSchema:addProperty("FILIAL"     ,STR0032 ,"string" ,STR0032 ,"FILIAL"   )// Filial 

self:oSchema:addProperty("SALDOANT"   ,STR0033 ,"number" ,STR0033 ,"SALDOANT" )// Saldo Anterior
self:oSchema:addProperty("SALDOANT_M" ,STR0034 ,"string" ,STR0034 ,"SALDOANT_M" )// Saldo Ant. c/ Masc

//Conta Sintetica
self:oSchema:addProperty("CONTASUP"   ,STR0039 ,"string" ,STR0039 ,"CONTASUP"    )// Codigo da Conta
self:oSchema:addProperty("CONTASUP_M" ,STR0040 ,"string" ,STR0040 ,"CONTASUP_M"    )// Cod Conta Masc
self:oSchema:addProperty("DESCONTASUP",STR0041 ,"string" ,STR0041 ,"DESCONTASUP" )// Descr. da Conta

return self:oSchema
//-------------------------------------------------------------------
/*/{Protheus.doc} SCtbGerRazG
    Metodo que cria a tabela temporaria e a retorna devidamente preenchida.
    @author wilton.santos
    @since 08/01/2024
    @version 12.1.2310
/*/
//-------------------------------------------------------------------
method SCtbGerRazG(cArqTmp,cEntGerIni,cEntGerFim,cMoeda,dDataIni,dDataFim,;
						aSetOfBook,lNoMov,cSaldo,lAnalitico,cCodPlGer,lCusto,lItem,lClVl) class ManagementLedgerSmartViewBusinessObject
Local aSaveArea	:= GetArea()
Local aTamConta	:= TAMSX3("CT1_CONTA")
Local aTamCusto	:= TAMSX3("CT3_CUSTO")
Local aTamVal	:= TAMSX3("CT2_VALOR")
Local aTamLin	:= TAMSX3("CT2_LINHA")
Local aTamSeq	:= TAMSX3("CT2_SEQLAN")
Local aCtbMoeda	:= {}
Local aCampos

Local nTamHist	:= Len(CriaVar("CT2_HIST"))
Local nTamItem	:= Len(CriaVar("CTD_ITEM"))
Local nTamCLVL	:= Len(CriaVar("CTH_CLVL"))
Local nDecimais	:= 0               
Local nTamFilial 	:= FWGETTAMFILIAL

// Retorna Decimais
aCtbMoeda := CTbMoeda(cMoeda)
nDecimais := aCtbMoeda[5]

aCampos :={	{ "CONTA" 		, "C", aTamConta[1] , 0 },;  		// Codigo da Conta
			{ "NORMAL"		, "C", 1            , 0 },;  		// Devedor/Credora
			{ "TIPO"       	, "C", 01			, 0 },;			// Tipo do Registro (Debito/Credito/Continuacao)			
			{ "LANCDEB"		, "N", aTamVal[1]+5 , nDecimais },; // Debito
			{ "LANCCRD"		, "N", aTamVal[1]+5	, nDecimais },; // Credito
			{ "SALDOSCR"	, "N", aTamVal[1]+5 , nDecimais },; // Saldo
			{ "TPSLD"   	, "C", 01           , 0 },; 		// Sinal do Saldo Atual => Consulta Razao
			{ "HISTORICO"	, "C", nTamHist   	, 0 },;			// Historico
			{ "CUSTO" 		, "C", aTamCusto[1] , 0 },;			// Centro de Custo
			{ "ITEM"		, "C", nTamItem		, 0 },;			// Item Contabil
			{ "CLVL"		, "C", nTamCLVL		, 0 },;			// Classe de Valor
			{ "DATAL"		, "D", 08			, 0 },;			// Data do Lancamento
			{ "LOTE" 		, "C", 06			, 0 },;			// Lote
			{ "SUBLOTE" 	, "C", 03			, 0 },;			// Sub-Lote
			{ "DOC" 		, "C", 06			, 0 },;			// Documento
			{ "LINHA"		, "C", aTamLin[1]   , 0 },;			// Linha  03
			{ "SEQLAN"		, "C", aTamSeq[1]   , 0 },;			// Sequencia do Lancamento  03
			{ "SEQHIST"		, "C", 03			, 0 },;			// Seq do Historico
			{ "EMPORI"		, "C", 02			, 0 },;			// Empresa Original
			{ "FILORI"		, "C", nTamFilial	, 0 },;			// Filial Original
			{ "NOMOV"		, "L", 01			, 0 },;			// Conta Sem Movimento
			{ "FILIAL"		, "C", nTamFilial	, 0 }} 			// Filial do sistema

self:oCTBR430 := FWTemporaryTable():New( "cArqTmp" )  
self:oCTBR430:SetFields(aCampos) 
self:oCTBR430:AddIndex("1", {"CONTA","DATAL","LOTE","SUBLOTE","DOC","LINHA","EMPORI","FILORI"})

//------------------
//Criação da tabela temporaria
//------------------
self:oCTBR430:Create()

dbSelectArea("cArqTmp")
dbSetOrder(1)

// Monta Arquivo para gerar o Razao
self:SCtbRazGer(cEntGerIni,cEntGerFim,cMoeda,dDataIni,dDataFim,;  
		aSetOfBook,lNoMov,cSaldo,lAnalitico,cCodPlGer,lCusto,lItem,lClVl)        

RestArea(aSaveArea)

Return cArqTmp
//-------------------------------------------------------------------
/*/{Protheus.doc} SCtbRazGer
    Metodo que filtra os dados conforme parametros informados
    @author wilton.santos
    @since 08/01/2024
    @version 12.1.2310
/*/
//-------------------------------------------------------------------
method SCtbRazGer(cEntGerIni,cEntGerFim,cMoeda,dDataIni,dDataFim,;
				  aSetOfBook,lNoMov,cSaldo,lAnalitico,cCodPlGer,lCusto,lItem,lClVl) class ManagementLedgerSmartViewBusinessObject 
Local aArea     := getArea() as array
Local lNoMovDeb, lNoMovCrd
Local lJaGravou	:= .F.
Local cContaIni	:= "" 
Local cContaFim	:= ""   
Local cContaG	:= ""
Local cOrdemAnt	:= ""
Local cContaAnt	:= ""
Local cNormal	:= ""   
Local tpSaldo   := ""	
Local cFilCT2   := xFilial("CT2")
Local cQuery := "" as character
Local nX := 0 as integer 
Local cEntid05Ini	:= ""
Local cEntid05Fim	:= Repl("Z",20)

Local aBind :={} as array
Local nParamOrder   := 1   as integer 
Local oQuery1,oQuery2 as object
//Local cAlias as character

Local __lCusto	    := CtbMovSaldo("CTT")//Define se utiliza C.Custo
Local __lItem 	    := CtbMovSaldo("CTD")//Define se utiliza Item
Local __lClVl		:= CtbMovSaldo("CTH")//Define se utiliza Cl.Valor 



dbSelectArea("CTS")
dbSetOrder(2)
MsSeek(xFilial("CTS")+cCodPlGer+cEntGerIni,.T.)
While !Eof() .And.  xFilial("CTS") == CTS->CTS_FILIAL .And. cCodPlGer == CTS->CTS_CODPLA ;
		     .And. CTS->CTS_CONTAG >= cEntGerIni .And. CTS->CTS_CONTAG <= cEntGerFim
	
	If CTS->CTS_CLASSE == '1'
		dbSkip()
		Loop
	EndIf    
	
   	If cSaldo == '*'
		tpSaldo := CTS->CTS_TPSALD
	Else
		tpSaldo := cSaldo
	Endif
	
	If CTS->CTS_TPSALD == '*'
		tpSaldo := cSaldo
	Endif
	
 	If tpSaldo <> Nil .And. Alltrim( tpSaldo ) <> '*' .And. Alltrim(tpSaldo) <> ''
		If CTS->CTS_TPSALD <> tpSaldo  .and. CTS->CTS_TPSALD <> '*'
			dbSkip()
			Loop
	 	EndIf
	Endif
	
	lNoMovDeb := .T.
	lNoMovCrd := .T.
	
	cContaIni := CTS->CTS_CT1INI
	cContaFim := CTS->CTS_CT1FIM
	cContaG	  := CTS->CTS_CONTAG
	cNormal	  := CTS->CTS_NORMAL
	
	//adicionado ignorando o trecho abaixo
	cEntid05Ini	:= ""
	cEntid05Fim	:= Repl("Z",20)
	
	If cContaAnt <> cContaG
		lJaGravou := .F.
	EndIf
	
	//Obtendo os debitos
	dbSelectArea("CT2")
		
	cQuery := " SELECT "
	cQuery += "  CT2_FILIAL
	cQuery += " ,CT2_DATA
	cQuery += " ,CT2_DC
	cQuery += " ,CT2_LOTE
	cQuery += " ,CT2_SBLOTE
	cQuery += " ,CT2_DOC
	cQuery += " ,CT2_LINHA
	cQuery += " ,CT2_CCD
	cQuery += " ,CT2_ITEMD
	cQuery += " ,CT2_CLVLDB
	cQuery += " ,CT2_CCC
	cQuery += " ,CT2_ITEMC
	cQuery += " ,CT2_CLVLCR
	cQuery += " ,CT2_HIST
	cQuery += " ,CT2_EMPORI
	cQuery += " ,CT2_FILORI
	cQuery += " ,CT2_SEQHIS
	cQuery += " ,CT2_SEQLAN
	cQuery += " ,CT2_VALOR
	cQuery += " FROM " + RetSqlName("CT2")
	cQuery += "  WHERE CT2_FILIAL = ? "
	cQuery += " AND CT2_DEBITO >= ? "
	cQuery += " AND CT2_DEBITO <= ? "
	cQuery += " AND CT2_MOEDLC = ? "
	cQuery += " AND CT2_DC IN ('1','3') "
	cQuery += " AND CT2_TPSALD = ? "
	cQuery += " AND CT2_VALOR != 0 "
	cQuery += " AND CT2_DATA >=  ? "
	cQuery += " AND CT2_DATA <=  ? "
	
	aAdd(aBind,{nParamOrder++,cFilCT2})
	aAdd(aBind,{nParamOrder++,cContaIni})
	aAdd(aBind,{nParamOrder++,cContaFim})
	aAdd(aBind,{nParamOrder++,cMoeda})
	aAdd(aBind,{nParamOrder++,tpSaldo})
	aAdd(aBind,{nParamOrder++,DTOS(dDataIni)})
	aAdd(aBind,{nParamOrder++,DTOS(dDataFim)})
		
	If __lCusto .And. lCusto
		cQuery += " AND CT2_CCD  >=   ? "
		cQuery += " AND CT2_CCD  <=   ? "
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTTINI})
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTTFIM})
	EndIf
					
	If __lItem .And. lItem 
		cQuery += " AND CT2_ITEMD  >=   ? "
		cQuery += " AND CT2_ITEMD  <=   ? "
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTDINI})
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTDFIM})
	EndIf
					
	If __lClVl .and. lCLVL
		cQuery += " AND CT2_CLVLDB  >=   ? "
		cQuery += " AND CT2_CLVLDB  <=   ? "
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTHINI})
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTHFIM})
	EndIf

	cQuery += " AND D_E_L_E_T_ = ? "
	aAdd(aBind,{nParamOrder++,space(1)})

	cQuery += " ORDER BY CT2_FILIAL, CT2_DEBITO, CT2_DATA "
	
	cQuery := ChangeQuery(cQuery)
		
	oQuery1 := FWExecStatement():New(cQuery)

	//aBind[1] = numero da sequencia do Bind
	//aBind[2] = parametro substituido (todos estão ou devem estar em string)
	For nX:=1 to len(aBind)
		oQuery1:SetString(aBind[nX,1], aBind[nX,2])
	Next nX
	
	self:cAlias := oQuery1:OpenAlias()
	//fecha CT2 para abrir query com mesmo alias CT2

	dbSelectArea(self:cAlias)
	(self:cAlias)->(dbGoTop())
	While (self:cAlias)->( !Eof() )   //laco da query renomeado alias como CT2			
		
		self:SCtbGrvRAZG(cMoeda,tpSaldo,"1",cContaG,cNormal)
		lNoMovDeb := .F.
				
		dbSelectArea(self:cAlias)
		(self:cAlias)->(dbSkip())
		
	EndDo
	(self:cAlias)->(dbCloseArea())
	aBind 		:= {}
	nParamOrder := 1

	// Obtendo os creditos
	cQuery := " SELECT "
	cQuery += "  CT2_FILIAL
	cQuery += " ,CT2_DATA
	cQuery += " ,CT2_DC
	cQuery += " ,CT2_LOTE
	cQuery += " ,CT2_SBLOTE
	cQuery += " ,CT2_DOC
	cQuery += " ,CT2_LINHA
	cQuery += " ,CT2_CCD
	cQuery += " ,CT2_ITEMD
	cQuery += " ,CT2_CLVLDB
	cQuery += " ,CT2_CCC
	cQuery += " ,CT2_ITEMC
	cQuery += " ,CT2_CLVLCR
	cQuery += " ,CT2_HIST
	cQuery += " ,CT2_EMPORI
	cQuery += " ,CT2_FILORI
	cQuery += " ,CT2_SEQHIS
	cQuery += " ,CT2_SEQLAN
	cQuery += " ,CT2_VALOR
	cQuery += " FROM " + RetSqlName("CT2")
	cQuery += " WHERE CT2_FILIAL = ? "
	cQuery += " AND CT2_CREDIT >= ? "
	cQuery += " AND CT2_CREDIT <= ? "
	cQuery += " AND CT2_MOEDLC = ? "
	cQuery += " AND CT2_DC IN ('2','3') "
	cQuery += " AND CT2_TPSALD = ? "
	cQuery += " AND CT2_VALOR != 0 "
	cQuery += " AND CT2_DATA >=   ? "
	cQuery += " AND CT2_DATA <=   ? "
	
	aAdd(aBind,{nParamOrder++,cFilCT2})
	aAdd(aBind,{nParamOrder++,cContaIni})
	aAdd(aBind,{nParamOrder++,cContaFim})
	aAdd(aBind,{nParamOrder++,cMoeda})
	aAdd(aBind,{nParamOrder++,tpSaldo})
	aAdd(aBind,{nParamOrder++,DTOS(dDataIni)})
	aAdd(aBind,{nParamOrder++,DTOS(dDataFim)})
	
	If __lCusto .And. lCusto
		cQuery += " AND CT2_CCC  >=   ? "
		cQuery += " AND CT2_CCC  <=   ? "
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTTINI})
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTTFIM})
	EndIf
				
	If __lItem .And. lItem 
		cQuery += " AND CT2_ITEMC  >=   ? "
		cQuery += " AND CT2_ITEMC  <=   ? "
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTDINI})
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTDFIM})
	EndIf
				
	If __lClVl .and. lCLVL
		cQuery += " AND CT2_CLVLCR  >=   ? "
		cQuery += " AND CT2_CLVLCR  <=   ? "
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTHINI})
		aAdd(aBind,{nParamOrder++,CTS->CTS_CTHFIM})
	EndIf
	cQuery += " AND D_E_L_E_T_ = ? "
	aAdd(aBind,{nParamOrder++,space(1)})
	cQuery += " ORDER BY CT2_FILIAL, CT2_CREDIT, CT2_DATA "
	
	cQuery := ChangeQuery(cQuery)
	
	oQuery2 := FWExecStatement():New(cQuery)
	//aBind[1] = numero da sequencia do Bind
	//aBind[2] = parametro substituido (todos estão ou devem estar em string)
	
	For nX:=1 to len(aBind)
		oQuery2:SetString(aBind[nX,1], aBind[nX,2])
	Next nX
	
	self:cAlias := oQuery2:OpenAlias()
	//fecha CT2 para abrir query com mesmo alias CT2
		
	dbSelectArea((self:cAlias))
	(self:cAlias)->(dbGoTop())
	While (self:cAlias)->( !Eof() )   //laco da query renomeado alias como CT2			
		
		self:SCtbGrvRAZG(cMoeda,tpSaldo,"2",cContaG,cNormal)
		lNoMovCrd := .F.
		
		dbSelectArea((self:cAlias))
		(self:cAlias)->(dbSkip())
	EndDo
	
	(self:cAlias)->(dbCloseArea())  //fecha a query com alias CT2
	aBind 		:= {}
	nParamOrder := 1

	// Conta sem movimento
	If lNoMov
		If lNoMovCrd .And. lNoMovDeb .And. !lJaGravou
			lJaGravou	:= .T.
			self:SCtbGrvNoMov(cContaG,dDataIni,"CONTA")
		EndIf
	EndIf
	
	dbSelectArea("CTS")
	cOrdemAnt	:= CTS->CTS_ORDEM
	cContaAnt	:= CTS->CTS_CONTAG
	dbSkip()
End

If oQuery1 <> nil 
	oQuery1:Destroy()
 	oQuery1 := nil
endIf
If oQuery2 <> nil 
	oQuery2:Destroy()
	oQuery2 := nil 
EndIf

restArea(aArea)
Return  
//-------------------------------------------------------------------
/*/{Protheus.doc} SCtbGrvRAZG
    Metodo que grava na tabela temporaria
    @author wilton.santos
    @since 08/01/2024
    @version 12.1.2310
/*/
//-------------------------------------------------------------------
method SCtbGrvRAZG(cMoeda,cSaldo,cTipo,cContaG,cNormal,cIdent) class ManagementLedgerSmartViewBusinessObject
Local aArea := getArea() as array
Local cConta
Local cCusto
Local cItem
Local cCLVL
Local nValor

Default cIdent := "1"

cConta 	:= cContaG

If cTipo == "1"
	cCusto	:= (self:cAlias)->CT2_CCD
	cItem	:= (self:cAlias)->CT2_ITEMD
	cCLVL	:= (self:cAlias)->CT2_CLVLDB
EndIf	
If cTipo == "2"
	cCusto	:= (self:cAlias)->CT2_CCC
	cItem	:= (self:cAlias)->CT2_ITEMC
	cCLVL	:= (self:cAlias)->CT2_CLVLCR
EndIf		           

dbSelectArea("cArqTmp")
dbSetOrder(1)	
RecLock("cArqTmp",.T.)

Replace FILIAL		With (self:cAlias)->CT2_FILIAL
Replace DATAL		With STOD((self:cAlias)->CT2_DATA)
Replace TIPO		With cTipo
Replace LOTE		With (self:cAlias)->CT2_LOTE
Replace SUBLOTE		With (self:cAlias)->CT2_SBLOTE
Replace DOC			With (self:cAlias)->CT2_DOC
Replace LINHA		With (self:cAlias)->CT2_LINHA
Replace CONTA		With cConta
Replace CUSTO		With cCusto
Replace ITEM		With cItem
Replace CLVL		With cCLVL
Replace HISTORICO	With (self:cAlias)->CT2_HIST
Replace EMPORI		With (self:cAlias)->CT2_EMPORI
Replace FILORI		With (self:cAlias)->CT2_FILORI
Replace SEQHIST		With (self:cAlias)->CT2_SEQHIS
Replace SEQLAN		With (self:cAlias)->CT2_SEQLAN
Replace NORMAL		With cNormal
Replace NOMOV		With .F.							// Conta com movimento
nValor := (self:cAlias)->CT2_VALOR

If cTipo == "1"
	Replace LANCDEB	With LANCDEB + nValor
EndIf	
If cTipo == "2"
	Replace LANCCRD	With LANCCRD + nValor
EndIf	    
If (self:cAlias)->CT2_DC == "3"
	Replace TIPO	With cTipo
Else
	Replace TIPO 	With (self:cAlias)->CT2_DC
EndIf		
MsUnlock()

restArea(aArea)
Return
//-------------------------------------------------------------------
/*/{Protheus.doc} SCtbGrvNoMov
    Metodo que ajusta o historico para períodos sem movimentos
    @author wilton.santos
    @since 08/01/2024
    @version 12.1.2310
/*/
//-------------------------------------------------------------------
method SCtbGrvNoMov(cConteudo,dDataL,cCpoTmp) class ManagementLedgerSmartViewBusinessObject

dbSelectArea("cArqTmp")
dbSetOrder(1)

RecLock("cArqTmp",.T.)
Replace FILIAL      With xFilial( 'CT2' )
Replace &(cCpoTmp)	With cConteudo
If cCpoTmp = "CONTA"
	Replace HISTORICO		With "CONTA SEM MOVIMENTO NO PERIODO"		//"CONTA SEM MOVIMENTO NO PERIODO"
ElseIf cCpoTmp = "CCUSTO"
	Replace HISTORICO		With Upper(AllTrim(CtbSayApro("CTT"))) + " "  + "SEM MOVIMENTO NO PERIODO"	//"SEM MOVIMENTO NO PERIODO"
ElseIf cCpoTmp = "ITEM"
	Replace HISTORICO		With Upper(AllTrim(CtbSayApro("CTD"))) + " "  + "SEM MOVIMENTO NO PERIODO"	//"SEM MOVIMENTO NO PERIODO"
ElseIf cCpoTmp = "CLVL"
	Replace HISTORICO		With Upper(AllTrim(CtbSayApro("CTH"))) + " "  + "SEM MOVIMENTO NO PERIODO"	//"SEM MOVIMENTO NO PERIODO"
Endif
Replace DATAL 			WITH dDataL
// Grava filial do sistema para uso no relatorio
Replace FILORI		With cFilAnt
MsUnlock()

Return
//-------------------------------------------------------------------

//-------------------------------------------------------------------
/*/{Protheus.doc} getSaldos
    Metodo que irá preencher os saldos das contas gerenciais
    Será usado para alterar a Query antes do getData.
    @author wilton.santos
    @since 08/01/2024
    @version 12.1.2310
/*/
//-------------------------------------------------------------------
method getSaldos(cCodPlGer,dDataIni,dDataFim,cMoeda,cSaldo,lNoMov) as json class ManagementLedgerSmartViewBusinessObject

	Local aArea := getArea() as array
	Local nSaldoAtu as numeric
	Local aSaldoAnt as array
	Local nTamHist	:= Len(CriaVar("CT2_HIST")) as integer
	Local nDecimais := 2222
	Local cPicture  := "@E 9,999,999,999.99"
	Local cContaAnt as character
	Local dDataAnt as date

	// Impressao do Saldo Anterior da Conta
	dbSelectArea("CTS")    
	CTS->(dbSetOrder(2))
	If CTS->(MsSeek(xFilial("CTS")+cCodPlGer+cArqTmp->CONTA))
		nSaldoAnt	:= 0 
		
		Do While CTS->(!Eof() .And. xFilial() == CTS->CTS_FILIAL .And. CTS->CTS_CODPLA == cCodPlGer .And. ;
				CTS->CTS_CONTAG == cArqTmp->CONTA)  
				
		    If !Empty(CTS->CTS_CTHINI)
		    	aSaldoAnt := SaldTotCTI(CTS->CTS_CTHINI,CTS->CTS_CTHFIM,CTS->CTS_CTDINI,CTS->CTS_CTDFIM,;
		    							CTS->CTS_CTTINI,CTS->CTS_CTTFIM,CTS->CTS_CT1INI,CTS->CTS_CT1FIM,dDataIni, cMoeda,cSaldo)
				   							
		    ElseIf !Empty(CTS->CTS_CTDINI) 
		       	aSaldoAnt := SaldTotCT4(CTS->CTS_CTDINI,CTS->CTS_CTDFIM, CTS->CTS_CTTINI,CTS->CTS_CTTFIM,;
		       							CTS->CTS_CT1INI,CTS->CTS_CT1FIM,dDataIni, cMoeda,cSaldo)
            
			ElseIf !Empty(CTS->CTS_CTTINI)
				aSaldoAnt	:= SaldtotCT3(CTS->CTS_CTTINI,CTS->CTS_CTTFIM,CTS->CTS_CT1INI,CTS->CTS_CT1FIM,dDataIni, cMoeda,cSaldo)	
		    Else
		    	aSaldoAnt	:= SaldTotCT7(CTS->CTS_CT1INI,CTS->CTS_CT1FIM,dDataIni,cMoeda,cSaldo,.F.)	
 		
	   		Endif
				
			nSaldoAnt	+= aSaldoAnt[6]
			CTS->(dbSkip())
		EndDo
	Endif

	nSaldoAtu:= 0
	
	::jItens["SALDOANT"]   := nSaldoAnt //  cArqTMP->SALDOSCR   
	::jItens["SALDOANT_M"] := ValorCTB(nSaldoAnt,0,0,self:TAM_VALOR-2,nDecimais,.T.,cPicture,cArqTmp->NORMAL,,,,,,.T.,.F.)	          
		
	nSaldoAtu := nSaldoAnt

	cContaAnt:= cArqTmp->CONTA
	dDataAnt	:= CTOD("  /  /  ")
	
	If cArqTmp->CONTA == cContaAnt		
		// Imprime os lancamentos para a conta                          
		If dDataAnt != cArqTmp->DATAL 
			dDataAnt := cArqTmp->DATAL
		EndIf				
		
		nSaldoAtu 	:= nSaldoAtu - cArqTmp->LANCDEB + cArqTmp->LANCCRD
			
		::jItens["SALDOSCR"]   := nSaldoAtu //  cArqTMP->SALDOSCR   
		::jItens["SALDOSCR_M"] := ValorCTB(nSaldoAtu,0,0,self:TAM_VALOR-2,nDecimais,.T.,cPicture,cArqTmp->NORMAL,,,,,,.T.,.F.)	          

		// Procura pelo complemento de historico
		CT2->(dbSetOrder(10))
		If CT2->(MsSeek(xFilial("CT2")+cArqTMP->(DTOS(DATAL)+LOTE+SUBLOTE+DOC+SEQLAN+EMPORI+FILORI),.F.))
			CT2->(dbSkip())
			If CT2->CT2_DC == "4"
				Do While CT2->(!Eof() .And. CT2->CT2_FILIAL == xFilial() 	.And.;
									CT2->CT2_LOTE == cArqTMP->LOTE 			.And.;
									CT2->CT2_SBLOTE == cArqTMP->SUBLOTE 	.And.;
									CT2->CT2_DOC == cArqTmp->DOC 			.And.;
									CT2->CT2_SEQLAN == cArqTmp->SEQLAN 		.And.;
									CT2->CT2_EMPORI == cArqTmp->EMPORI		.And.;
									CT2->CT2_FILORI == cArqTmp->FILORI		.And.;
									CT2->CT2_DC == "4" 						.And.;
									DTOS(CT2->CT2_DATA) == DTOS(cArqTmp->DATAL) )
					
					::jItens["HISTORICO"] += Subs(CT2->CT2_HIST,1,nTamHist)
					
					CT2->(dbSkip())
				EndDo	
			EndIf	
		EndIf	

	EndIf	

	restArea(aArea)

return ::JItens
//-------------------------------------------------------------------
/*/{Protheus.doc} Ctr430Sint
    Metodo que trazer os dados da conta sintetica/superior da conta gerencial
    
	@author wilton.santos
    @since 08/01/2024
    @version 12.1.2310
/*/
//-------------------------------------------------------------------
method Ctr430Sint(cConta,cCodPlGer) as array class ManagementLedgerSmartViewBusinessObject

	Local aSaveArea 	:= GetArea() as array
	Local nPosCTS		as integer			//Guarda a posicao no CT1
	Local cContaPai		:= "" as character
	Local cContaSint    := "" as character
	Local aContaSint	:= {} as array
	Local cDescConta    := "" as character
	Local cDescSint     := "" as character

	dbSelectArea("CTS")
	dbSetOrder(2)
	If MsSeek(xFilial()+cCodPlGer+cConta)
		nPosCTS 	:= Recno()
		cDescConta  := CTS->CTS_DESCCG
		cContaPai	:= CTS->CTS_CTASUP
		If MsSeek(xFilial()+cCodPlGer+cContaPai)
			cContaSint 	:= CTS->CTS_CONTAG
			cDescSint	:= CTS->CTS_DESCCG 
		EndIf	
		dbGoto(nPosCTS)
	EndIf	

	aAdd(aContaSint,cDescConta)
	aAdd(aContaSint,cContaPai)
	aAdd(aContaSint,cDescSint)

	RestArea(aSaveArea)

Return aContaSint

/*/{Protheus.doc} ManagementLedgerSmartViewBusinessObject::preSchema
Metodo que será consumido pelo M.I.
@type method
@version 1.0  
@author loex
@since 11/13/2024
/*/

method preSchema() as object class ManagementLedgerSmartViewBusinessObject 
return self:oSchema

/*/{Protheus.doc} ManagementLedgerSmartViewBusinessObject::preData
Metodo que será consumido pelo M.I.
@type method
@version 1.0  
@author loex
@since 11/13/2024
/*/

method preData() as object class ManagementLedgerSmartViewBusinessObject 
return self:oData

/*/{Protheus.doc} ManagementLedgerSmartViewBusinessObject::processData
Metodo que será consumido pelo M.I.
@type method
@version 1.0  
@author loex
@since 11/13/2024
/*/

method processData() as json class ManagementLedgerSmartViewBusinessObject
return ::jItens
