#include 'tlpp-core.th'
#INCLUDE "FWLIBVERSION.CH"

NAMESPACE totvs.protheus.backoffice.fin.tabledata
USING NAMESPACE totvs.protheus.backoffice.acf.customer
USING NAMESPACE totvs.protheus.backoffice.fin.apiutil

Static __lCacheQry := FwLibVersion() >= "20211116"

/*/{Protheus.doc} responseSA1FIN
	verifica se existe títulos em aberto para cada cliente
	@type  Function
	@author renato.ito
	@since 20/10/2022
	@param jResponse, Json, response gerado pela classe
	@return jResponse, Json, response com items tratados
/*/
Function responseSA1FIN(jResponse as Json) as Json
	Local nItem       		:= 1 								as Numeric
	Local cFilSA1			:= ""								as Character
	Local cCliente    		:= ""     							as Character
	Local cLoja       		:= ""    							as Character
	Local oPendente	   		:= NIL 								as Object
	Local oVencido	   		:= NIL 								as Object
	Local nCountPendente	:= 0     							as Numeric
	Local nCountVencidos	:= 0     							as Numeric
	Local nMvCusto 			:= Val(Alltrim(SuperGetMV("MV_MCUSTO",.F.,"2"))) as Numeric

	If __lCacheQry
		oPendente := FWExecStatement():new()
		oVencido := FWExecStatement():new()
	Else
		oPendente := FWPreparedStatement():New()
		oVencido := FWPreparedStatement():New()
	Endif

	If jResponse:hasProperty('items') .And. ValType(jResponse['items']) == 'A'
		For nItem := 1 To Len(jResponse['items'])
			cFilSA1   := jResponse['items'][nItem]['a1_filial']
			cCliente  := jResponse['items'][nItem]['a1_cod']
			cLoja     := jResponse['items'][nItem]['a1_loja']

			//Ajuste moeda
            If  jResponse['items'][nItem]['a1_moedalc'] == 0
                jResponse['items'][nItem]['a1_moedalc'] := nMvCusto
            EndIf

			//Legenda
			nCountPendente := customerBills("pendente", oPendente, cCliente, cLoja, cFilSA1, " COUNT(SE1.E1_NUM) ")
			nCountVencidos := customerBills("vencido", oVencido, cCliente, cLoja, cFilSA1, " COUNT(SE1.E1_NUM) ")

			If nCountPendente + nCountVencidos  > 0
				If nCountVencidos > 0
					jResponse['items'][nItem]['openlabel'] = '2' //Com títulos em aberto e vencidos (vermelho)
				Else
					jResponse['items'][nItem]['openlabel'] = '1' //Com títulos em aberto (amarelo)
				Endif
			Else
				jResponse['items'][nItem]['openlabel'] = '0' //Sem títulos (verde)
			EndIf

		Next
	EndIf

	oPendente:Destroy()
	oVencido:Destroy()

Return jResponse

/*/{Protheus.doc} responseSE1LEG
	Retorna legenda customizada para os titulos a receber
	@type  Function
	@author Vitor Duca
	@since 02/12/2022
	@param jResponse, Json, response gerado pela classe
	@return jResponse, Json, response com items tratados
/*/
Function responseSE1LEG(jResponse as Json, cIdLeg As Character) as Json
	Local nItem	:= 0 As Numeric
	Local cDateVenc := "" As Character
	Local cDateBase := Dtos(dDatabase) As Character

	If jResponse:hasProperty('items') .And. ValType(jResponse['items']) == 'A'
		For nItem := 1 To Len(jResponse['items'])
			Do Case
				Case AllTrim(Upper(cIdLeg)) == "ACF"
					cDateVenc := totvs.protheus.backoffice.fin.apiutil.jsonStringToIso(jResponse['items'][nItem]['e1_vencrea'])
					//Legenda
					If jResponse['items'][nItem]['e1_saldo'] > 0 .and. cDateVenc >= cDateBase
						jResponse['items'][nItem]['status'] = '1' //Pendente
					Elseif 	jResponse['items'][nItem]['e1_saldo'] > 0 .and. cDateVenc < cDateBase
						jResponse['items'][nItem]['status'] = '2' //Vencido
					Endif
			End Case
		Next
	EndIf

Return jResponse

/*/{Protheus.doc} CV8CT2INCONS
	Retorna legenda customizada para os titulos a receber
	@type  Function
	@author vinicius.prado
	@since 24/07/2023
	@param jResponse, Json, response gerado pela classe
	@return jResponse, Json, response com o tratamento de legenda
/*/
Function responseCV8CT2INCONS(jResponse as Json) as Json
	Local nItem	    := 0 							As Numeric
	Local cUUID     := Space(TamSx3("CV8_PROC")[1]) As Character
	Local cFilCT2   := xFilial("CT2") 				As Character
	Local cQuery    := "" 							As Character

	cQuery := "SELECT COUNT(CT2_INCONS) TOTAL FROM "
	cQuery += RetSqlName('CT2')
	cQuery += " WHERE CT2_PROCES = ? "
	cQuery += " AND CT2_FILIAL = ? "
	cQuery += " AND CT2_INCONS <> '2' "
	cQuery := ChangeQuery(cQuery)

	If jResponse:hasProperty('items') .And. ValType(jResponse['items']) == 'A'
		For nItem := 1 To Len(jResponse['items'])
			If jResponse['items'][nItem]:hasProperty("cv8_proc") .and. !Empty(AllTrim(jResponse['items'][nItem]['cv8_proc']))
				cUUID   := jResponse['items'][nItem]['cv8_proc']
			Endif
			If jResponse['items'][nItem]:hasProperty("ct2_filial") .and. !Empty(AllTrim(jResponse['items'][nItem]['ct2_filial']))
				cFilCT2 := jResponse['items'][nItem]['ct2_filial']
			Endif
			// 1 = Com inconsistência;2 = Sem inconsistência
			If MpSysExecScalar(cQuery, 'TOTAL', {cUUID, cFilCT2}) > 0
				jResponse['items'][nItem]['incons'] := '1'
			Else
				jResponse['items'][nItem]['incons'] := '2'
			EndIf
		Next
	EndIf

Return jResponse

/*/{Protheus.doc} getQueryCV8Incons
	Retorna a query para registro da CV8 e CT2 DETPROVA.
	@type  Function
	@author vinicius.prado
	@since 18/07/2023
	@version 1.0
	@return cQuery, Character, query contendo join CV8 e CT2
/*/
Function getQueryCV8Incons(cFields as Character) as Character
	Local cQuery  := "" as Character
	cQuery :=	" SELECT #QueryFields# "
	cQuery +=	" FROM " + RetSqlName('CT2') + " CT2 "
	cQuery +=	" INNER JOIN " + RetSqlName('CV8') + " CV8 ON " + FWJoinFilial('CV8', 'CT2')
	cQuery +=	" AND CT2.CT2_PROCES = CV8.CV8_PROC "
	cQuery +=	" AND CV8.CV8_INFO = '2' "
	cQuery +=	" AND CV8.CV8_SBPROC = 'FINA716APR' "
	cQuery +=	" AND CV8.D_E_L_E_T_ = ' ' "
	cQuery +=	" WHERE CT2.D_E_L_E_T_ = ' ' "
	cQuery += 	" #QueryWhere# "
	cQuery +=	" GROUP BY " + cFields
Return cQuery


/*/{Protheus.doc} getQueryOcurrencies
	Retorna a query para listagem das ocorrencias que estão relacionadas com boletos
	@type  Function
	@author Vitor Duca
	@since 31/03/2025
	@version 1.0
	@return cQuery, Character, query contendo join SEA, FI2 e SA6
/*/
Function getQueryOcurrencies() as Character
	Local cQuery  := "" as Character

	cQuery := " SELECT #QueryFields# FROM " + RetSqlName("FI2") + " FI2 "
	cQuery += " LEFT JOIN " + RetSqlName("SEA") + " SEA ON "
	cQuery +=  totvs.protheus.backoffice.ngf.util.BranchRelation( {"SEA","EA_FILORIG","SEA"}, {"FI2", "FI2_FILIAL", "FI2"})
	cQuery += " AND SEA.EA_NUMBOR = FI2.FI2_NUMBOR "
	cQuery += " AND SEA.EA_CART = 'R' "
	cQuery += " AND SEA.EA_PREFIXO = FI2.FI2_PREFIX "
	cQuery += " AND SEA.EA_NUM = FI2.FI2_TITULO "
	cQuery += " AND SEA.EA_PARCELA = FI2.FI2_PARCEL "
	cQuery += " AND SEA.EA_TIPO = FI2.FI2_TIPO "
	cQuery += " AND SEA.EA_BORAPI = 'S' "
	cQuery += " AND SEA.EA_TRANSF = 'S' "
	cQuery += " AND SEA.D_E_L_E_T_ = ' ' "
	cQuery += " LEFT JOIN " + RetSqlName("SE1") + " SE1 ON "
	cQuery +=  totvs.protheus.backoffice.ngf.util.BranchRelation( {"SE1","E1_FILORIG","SE1"}, {"FI2", "FI2_FILIAL", "FI2"})
	cQuery += " AND SE1.E1_PREFIXO = FI2.FI2_PREFIX "
	cQuery += " AND SE1.E1_NUM = FI2.FI2_TITULO "
	cQuery += " AND SE1.E1_PARCELA = FI2.FI2_PARCEL "
	cQuery += " AND SE1.E1_TIPO = FI2.FI2_TIPO "
	cQuery += " AND SE1.D_E_L_E_T_ = ' ' "
	cQuery += " LEFT JOIN " + RetSqlName("SA6") + " SA6 ON "
	cQuery +=  totvs.protheus.backoffice.ngf.util.BranchRelation( {"SEA","EA_FILIAL","SEA"}, {"SA6","A6_FILIAL","SA6"} )
	cQuery += " AND SA6.A6_COD = SEA.EA_PORTADO "
	cQuery += " AND SA6.A6_AGENCIA = SEA.EA_AGEDEP "
	cQuery += " AND SA6.A6_NUMCON = SEA.EA_NUMCON "
	cQuery += " AND SA6.D_E_L_E_T_ = ' ' "
	cQuery += " WHERE FI2.D_E_L_E_T_ = ' ' "
	cQuery += " #QueryWhere# "

Return cQuery
