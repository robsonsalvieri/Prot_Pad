#Include 'tlpp-core.th'
#Include 'pc.invoices.service.ch'

namespace portal.cliente.invoices
using namespace gfin.util
using namespace portal.cliente.util

Static __instance	 As Object
Static __oActiveData As Object

Class InvoicesService

	Data limit	As Numeric
	Data page	As Numeric
	Data aHeaderRequest as Array
	Data cUrlResource as Character
	Private Data lMockData  As Logical
	Private Data jMockData 	As Json

	Public Method New()
	Public Method getInvoices()
	Public Method getCustomerInvoiceProducts()
	Public Method getXmlDanfe() as Json
	Public Method configAuthentication()
	Public Method setLimit()
	Public Method setPage()
	Public Method setMockData(jMockApiData as Json)
	Static Method getInstance() As Object
	Static Method getProtheusInstance() As Object
EndClass

Method New() Class InvoicesService
	Self:limit			:= 0
	Self:page 			:= 0
	Self:aHeaderRequest	:= {}
	Self:cUrlResource	:=""
	Self:lMockData 		:= .F.
	Self:jMockData 		:= JsonObject():new()
Return

//-------------------------------------------------------------------
/*/{Protheus.doc }getInstance
retorna a o instância ativa, se não exitir será criada uma nova.

@author Renato Ito
@since 19/08/2020
/*/
//-------------------------------------------------------------------
Method getInstance() Class InvoicesService
	If (__instance == nil)
		__instance := InvoicesService():new()
	EndIf
Return	__instance

//-------------------------------------------------------------------
/*/{Protheus.doc }getProtheusInstance
Retorna a isntancia ativa de acesso aos dados do Protheus

*implementar no futuro a factory se existir mais provedores de dados
@author Renato Ito
@since 19/08/2020
/*/
//-------------------------------------------------------------------
Method getProtheusInstance() Class InvoicesService
	If (__oActiveData == nil)
		__oActiveData := InvoicesDataProtheus():new()
	EndIf
Return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} setLimit
congIfura o limite de registros para retorno

@author Renato Ito
@since 19/08/2020
/*/
//-------------------------------------------------------------------
Method setLimit(value As Numeric) Class InvoicesService
	self:limit := value
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} setPage
congifura a pagina atual para cálculo do registro inicial da query

@author Renato Ito
@since 19/08/2020
/*/
//-------------------------------------------------------------------
Method setPage(value As Numeric) Class InvoicesService
	self:page := value
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} setMockData
	Mocka os dados para testes.

	@author Vinicius do Prado
	@since Fev | 2024
	@version 1.0
	@param jMockData: Json - Json contendo os objetos para teste.
/*/
//-------------------------------------------------------------------
Method setMockData(jMockApiData as Json) Class InvoicesService
	::jMockData := jMockApiData
	::lMockData := .T.
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} getInvoices
Regra de negócio para as notas fiscais.

@param	json com os atributos
		{
			customerId: Character,
			storeId: Character,
			branchId: Array,
			filter: Array [atributo, operador, valor]
		}

@return json com os tributos
		{
			"result" : true ou false
			"response" : json de resposta
			"statusCode": código http de resposta quando necessário
		}
@author Renato Ito
@since 19/08/2020
/*/
//-------------------------------------------------------------------
Method getInvoices(request As Json) Class InvoicesService
	Local dataObj 			As Object
	Local response 			As Json
	Local customers			As Array

	customers := request['customers']

	// avalia se a parametrização obrigatório foi encaminhada
	If (!validCustomers(customers))
		response := answerErrorFormat(412, STR0001, "Parametrização obrigatória não foi encaminhada no body")
	Else
		dataObj := InvoicesService():getProtheusInstance()
		response := dataObj:getDataInvoices(customers, request['filter'], request['order'], self:limit, self:page)
	EndIf
Return response


//-------------------------------------------------------------------
/*/{Protheus.doc} getCustomerInvoiceProducts
Retorna os produtos da nota fiscal.

@param JSON
{
	invoiceBranch: string - filial da nota
	invoiceNumber: string - número da nota
	serie: string - série da nota
	branchId: string - filial da AI3
	customerId: string - A1_COD
	storeId: string - A1_LOJA
}

@return JSON
response["fiscalCode"]: string - D2_CF,
response["response"]: array
[
	{
		productItem: string
		productAmount: string
		productTotal: number
		productUnit: number
		productDescription: string
	}
]

@author richard.lopes
@since 19/08/2020
/*/
//-------------------------------------------------------------------
Method getCustomerInvoiceProducts(request As Json) Class InvoicesService
	Local response 		As Json
	Local dataObj 		As Object
	Local branchId		As Character
	Local invoiceNumber As Character
	Local serie			As Character
	Local customerId 	As Character
	Local storeId		As Character

	invoiceBranch := request['invoiceBranch']
	invoiceNumber := request['invoiceNumber']
	serie		  := request['serie']
	branchId	  := request['branchId']
	customerId 	  := request['customerId']
	storeId	 	  := request['storeId']

	// avalia se a parametrização obrigatório foi encaminhada
	If (Empty(invoiceBranch) .Or. Empty(invoiceNumber) .Or. Empty(serie) .Or. !validCustomers({request}))
		response := answerErrorFormat(400, STR0001, "Parametrização obrigatória não foi encaminhada no body")
	Else
		dataObj := InvoicesService():getProtheusInstance()
		response := dataObj:getDataInvoiceProducts(invoiceBranch, invoiceNumber, serie, customerId, storeId)
	EndIf
Return response

/*/{Protheus.doc} getXmlDanfe
	Retorna o XML + DANFE da nota passar por parametro
	@author Vitor Duca
	@since 21/12/2023
	@version 1.0
	@param cSerie, Character, Numero de serie da nota fiscal
	@param cNumber, Character, Numero da nota fiscal
	@param cModel, Character, Modelo da nota fiscal
	@param cEntity, Character, Entidade fiscal, caso seja informado irá desconsiderar regra
	padrão que é o retorno da função getCfgEntidade()
	@return jResponse, Json, Resposta que será enviada para a API
/*/
Method getXmlDanfe(cSerie As Character, cNumber As Character, cModel As Character, cEntity as Character) as Json Class InvoicesService
	Local jResponse 	:= JsonObject():new() 					as Json
	Local cUrl			:= SuperGetMv("MV_FNPCTSS",.F.,"") 		as Character
	Local jBody			:= JsonObject():new() 					as Json
	Local jFwRest		:= JsonObject():new()					as Json
	Local cEntidade 	:= ""									as Character
	Local cHeaderRet	:= ""									as Character
	Local cResponse		:= ""									as Character
	Local nHttpStatus	:= 0									as Numeric

	DEFAULT cSerie 	:= ""
	DEFAULT cNumber := ""
	DEFAULT cModel 	:= ""
	DEFAULT cEntity := ""

	self:aHeaderRequest	:= {}
	self:cUrlResource := "tssapidoc/v1/nfe/retornadoc/"
	aAdd(self:aHeaderRequest,"Accept-Encoding: UTF-8")
	aAdd(self:aHeaderRequest,"Content-Type: application/json; charset=utf-8")

	If !Empty(cEntity)
		cEntidade := cEntity
	Else
		cEntidade := getCfgEntidade()
	Endif

	jBody["serie"]    := cSerie
	jBody["numero"]   := cNumber
	jBody["modelo"]   := cModel
	jBody["entidade"] := cEntidade

	If !SubStr(cUrl, Len(cUrl), 1 ) $ "/"
		cUrl += "/""
	EndIf

	self:configAuthentication()

	cResponse   := HTTPSPost(cUrl + self:cUrlResource, "", "", "", "", jBody:ToJson(), 30, self:aHeaderRequest, @cHeaderRet)
	nHttpStatus := HTTPGetStatus(@cHeaderRet)

	// Realiza o mock da resposta para testes
	If ::lMockData .and. ::jMockData:hasProperty('api_xml_danfe')
		nHttpStatus := ::jMockData['api_xml_danfe']['status']
		cResponse 	:= ::jMockData['api_xml_danfe']:toJson()
	EndIf

	jFwRest:FromJson(cResponse)

	If nHttpStatus == 200 .and. jFwRest:hasProperty("message") .and. jFwRest:hasProperty("data")
		jResponse := answerFormat(.T., nHttpStatus, jFwRest["message"], "")
		jResponse["response"]["data"] := jFwRest["data"]
	Else
		If !Empty(cResponse) .and. nHttpStatus <> 404
			jResponse := answerFormat(.F., nHttpStatus, STR0009, STR0002 + cSerie + STR0003 + cNumber + STR0008 + cEntidade + STR0004)//"Não foi possivel baixar a Danfe e XML" # "O documento (serie: "....", numero: "..." e entidade: "...") não foi encontrado na base de dados, por favor verifique com o emissor se a transmissão para o SEFAZ ocorreu com sucesso"
		Else
			jResponse := answerFormat(.F., 404, STR0009, STR0005 + ' <br><br> ' + STR0006 + ' <a href="https://tdn.totvs.com/pages/viewpage.action?pageId=718992131" target="_blank">Funcionalidades - Portal do cliente</a> (' + STR0007 + ' - Notas fiscais)') //"Não foi possivel baixar a Danfe e XML" # 'Ambiente desatualizado para essa opção e/ou servidor de notas fiscais eletrônicas indisponível.#"para mais detalhes acesse"#"Tópico 3"
		Endif
	Endif

Return jResponse

//-------------------------------------------------------------------
/*/{Protheus.doc} configAuthentication
	Realiza as configurações de autenticação caso necessário.

	@author Vinicius do Prado
	@since 09/08/2024
/*/
//-------------------------------------------------------------------
Method configAuthentication() Class InvoicesService
	Local cVersionTSS	:= "" 	as Character
	Local cUrlWS		:= "" 	as Character
	Local cToken		:= ""	as Character
	
	// Endereco do webservice onde o TSS esta configurado
	cUrlWS := AllTrim(PadR(GetNewPar("MV_SPEDURL","http://"),250))

	// Prepara a API para uso de autenticacao (v2)
	If findFunction('TssTknAuth') .And. findFunction('getVersaoTSS')
		cVersionTSS := getVersaoTSS(,cUrlWS)
		cVersionTSS := Alltrim(Substr( cVersionTSS , 1, (At("|", cVersionTSS)-1)))

		If cVersionTSS >= "12.1.2410"
			cToken := TssTknAuth()
			If !Empty(cToken)
				self:cUrlResource := "tssapidoc/v2/nfe/retornadoc/"
				aAdd(self:aHeaderRequest,"Authorization: Bearer " + cToken)
			EndIf
		EndIf
	EndIf
Return
