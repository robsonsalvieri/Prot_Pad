#include "PROTHEUS.CH"
#include "fileio.ch"
#include "FINA430.CH"
#include "FWMVCDEF.CH"

Static lFWCodFil  := .T.
Static _oFina430  As Object
Static _lExistTcb As Logical
Static __lVldExtC As Logical
Static __lPar13	 := .F. As Logical
Static __lGesplan As Logical

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FinA430  ³ Autor ³ Pilar Sanchez         ³ Data ³ 26/05/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorno da comunicação banc ria - Pagar                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FinA430(nPosArotina)                                       ³±±
±±³			 ³ nPosArotina - Recebe a posicao do array aRotina para       ³±±
±±³          ³ executar a funcao escolhida                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³  Motivo da Alteracao                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³JBS-Jailton ³26/08/13³ Correcao na gravacao do campo E5_BENEF          ³±±
±±³            ³        ³                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FinA430(nPosAuto,aParam)
	Local lOk		:= .F.
	Local lPergunte  := .T.
	Local cPerg		:= "AFI430"
	Local cDescription := ""
	Local aInfoCustom := {}
	Local nI		:= NIL

	Local aPergunte		As Array
	Local oFwSX1Util    As Object

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define o cabecalho da tela de baixas ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE cCadastro := OemToAnsi( STR0006 )  //"Retorno CNAB Pagar"
	Private aTit
	Private cTipoBx  := ""
	Private nVlrCnab := 0
	Private lMVCNBImpg := GetNewPar("MV_CNBIMPG",.F.)

// Retorno Automatico via Job
// parametro que controla execucao via Job utilizado para pontos de entrada que nao tem como passar o parametro
	Private lExecJob := ExecSchedule()
	Private lSchedule := FWGetRunSchedule( )

	DEFAULT aParam := {}	//Modelo conteudo do array {{'MV_PAR01',Valor},{'MV_PAR02',Valor},{'MV_PARn',ValorN}}

	aPergunte	:= {}

	If !lExecJob .And. GetHlpLGPD({"A2_NOME","A6_COD"})
		Return .F.
	Endif

// Retorno Automatico via Job
	if lExecJob
		nPosAuto := 1 // Envia arquivo
	Endif

	If _lExistTcb == Nil
		_lExistTcb := FindFunction("FINI230O") .and. AliasInDic("FWO") .and. SA6->(FieldPos("A6_TCB")) > 0
	EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica as perguntas selecionadas                 ³
//³                                                    ³
//³ Parametros                                         ³
//³                                                    ³
//³ MV_PAR01: Mostra Lanc. Contab  ? Sim Nao           ³
//³ MV_PAR02: Aglutina Lanc. Contab? Sim Nao           ³
//³ MV_PAR03: Arquivo de Entrada   ?                   ³
//³ MV_PAR04: Arquivo de Config    ?                   ³
//³ MV_PAR05: Banco                ?                   ³
//³ MV_PAR06: Agencia              ?                   ³
//³ MV_PAR07: Conta                ?                   ³
//³ MV_PAR08: SubConta             ?                   ³
//³ MV_PAR09: Contabiliza          ?                   ³
//³ MV_PAR10: Padrao Cnab          ? Modelo1 Modelo 2  ³
//³ MV_PAR11: Processa filiais     ? Modelo1 Modelo 2  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	A460FSA2()	//Aplica Filtro na tabela de Fornecedores (SA2)


	If lExecJob    // Retorno Automatico via Job
		If !EMPTY(aparam)
			For nI := 1 To LEN(aParam)
				If 'MV_PAR' $ UPPER(aParam[nI,1])
					&(aParam[nI,1]) := aParam[nI,2]
				EndIf
			Next nI
		ElseIf !lSchedule
			Pergunte(cPerg,.F.,Nil,Nil,Nil,.F.)  // carrega as perguntas que foram atualizadas pelo FINA435
		EndIf

		lPergunte := .T.
	EndIf


	oFwSX1Util := FwSX1Util():New()
	oFwSX1Util:AddGroup(cPerg)
	oFwSX1Util:SearchGroup()
	aPergunte := oFwSX1Util:GetGroup(cPerg)

	If Len(aPergunte) > 1 .And. Len(aPergunte[2]) >= 13 .And. Upper(AllTrim(aPergunte[2][13]:CX1_VAR01)) == "MV_PAR13"
		__lPar13 := .T.
	EndIf

	If !lExecJob .And. !lSchedule
		Pergunte(cPerg, .F., Nil, Nil, Nil, .F.)
	EndIf

	If lPergunte
		MV_PAR03 := UPPER(MV_PAR03)
		dbSelectArea("SE2")
		dbSetOrder(1)

		If nPosAuto <> Nil
			lOk := .T.
		Else

			cDescription := STR0013 + STR0014

			tNewProcess():New( "FINA430", cCadastro, {|| lOk := .T.}, cDescription, cPerg,;
							  aInfoCustom                       /*aInfoCustom*/  ,;
                              .T.                               /*lPanelAux*/    ,;
                              5                                 /*nSizePanelAux*/,;
                              cDescription    					/*cDescriAux*/   ,;
                              .T.                               /*lViewExecute*/ ,;
                              .F.                               /*lOneMeter*/    ,;
                              .T.                               /*lSchedAuto*/ )

		Endif
		If lOk
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			if lExecJob
				ProcLogAtu("INICIO",STR0016+" - "+STR0017+mv_par03) // "Retorno Bancario Automatico (Pagar)" # "Arquivo:"
			Else
				ProcLogAtu("INICIO")
			Endif

			fa430gera("SE2", aParam)

			//- efetua exclusão do model - FINA080
			If FindFunction("F080ClearM")
				F080ClearM()
			EndIF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lExecJob
				ProcLogAtu("FIM",,STR0016+" - "+STR0017+mv_par03) // "Retorno Bancario Automatico (Pagar)" # "Arquivo:"
			Else
				ProcLogAtu("FIM")
			Endif
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Recupera a Integridade dos dados                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SE2")
		dbSetOrder(1)
	EndIf

Return

/*/
	ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Fun‡…o    ³ fA430Ger ³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡…o ³ Comunicacao Bancaria - Retorno                             ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Sintaxe   ³ fA430Ger(cAlias)                                           ³±±
	±±³          ³ cAlias - Alias corrente para executar a funcao             ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³ Uso      ³ FinA430                                                    ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fa430gera(cAlias, aParamB)
	PRIVATE cLotefin	:= Space(TamSX3("EE_LOTECP")[1])
	PRIVATE nTotAbat	:= 0,cConta := " "
	PRIVATE nHdlBco		:= 0,nHdlConf := 0,nSeq := 0 ,cMotBx := "DEB"
	PRIVATE nValEstrang	:= 0
	PRIVATE cMarca		:= GetMark()
	PRIVATE aAC			:= { STR0004,STR0005 }  //"Abandona"###"Confirma"
	PRIVATE nTotAGer	:= 0
	PRIVATE VALOR		:= 0
	PRIVATE ABATIMENTO	:= 0
	Private nAcresc, nDecresc

	DEFAULT aParamB := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para Tratamento baixa - Citibank³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("F430CIT")
		ExecBlock("F430CIT",.F.,.F.)
	Endif

	Processa({|lEnd| fa430Ger(cAlias, aParamB)})  // Chamada com regua

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Fecha os Arquivos ASCII ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nHdlBco > 0
		FCLOSE(nHdlBco)
	Endif

	If nHdlConf > 0
		FCLOSE(nHdlConf)
	Endif

Return .T.

/*/{Protheus.doc} fA430Ger
	Comunicacao Bancaria - Retorno
	@type function
	@author Wagner Xavier
	@since 26/05/1992
	@param cAlias, character, param_description
	@param aParamB, array, param_description
	@return logical, return_description
/*/
Function fA430Ger(cAlias as Character, aParamB as Array) as Logical

	Local cPosNum       as Character
	Local cPosData      as Character
	Local cPosDesp      as Character
	Local cPosDesc      as Character
	Local cPosAbat      as Character
	Local cPosPrin      as Character
	Local cPosJuro      as Character
	Local cPosMult      as Character
	Local cPosForne     as Character
	Local cPosOcor      as Character
	Local cPosTipo      as Character
	Local cPosCgc       as Character
	Local cRejeicao     as Character
	Local cPosDebito    as Character
	Local cPosRejei     as Character
	Local cChave430     as Character
	Local cNumSe2       as Character
	Local cChaveSe2     as Character
	Local cArqConf      as Character
	Local cArqEnt       as Character
	Local cPosNsNum     as Character
	Local cTabela       as Character
	Local cPadrao       as Character
	Local cLanca        as Character
	Local cFilOrig      as Character
	Local xBuffer       as Variant
	Local lPosNum       as Logical
	Local lPosData      as Logical
	Local lPosDesp      as Logical
	Local lPosDesc      as Logical
	Local lPosAbat      as Logical
	Local lPosPrin      as Logical
	Local lPosJuro      as Logical
	Local lPosMult      as Logical
	Local lPosOcor      as Logical
	Local lPosTipo      as Logical
	Local lMovAdto      as Logical
	Local lPosNsNum     as Logical
	Local lPosForne     as Logical
	Local lPosRejei     as Logical
	Local lPosCgc       as Logical
	Local lPosdebito    as Logical
	Local lDesconto     as Logical
	Local lContabiliza  as Logical
	Local lUmHelp       as Logical
	Local lCabec        as Logical
	Local lPadrao       as Logical
	Local lBaixou       as Logical
	Local lHeader       as Logical
	Local lF430VAR      as Logical
	Local lF430Baixa    as Logical
	Local lF430Rej      as Logical
	Local lFa430Oco     as Logical
	Local lFa430Se2     as Logical
	Local lFa430Pa      as Logical
	Local lFa430Fil     as Logical
	Local lFA430LP      as Logical
	Local lRet          as Logical
	Local nLidos        as Numeric
	Local nLenNum       as Numeric
	Local nLenData      as Numeric
	Local nLenDesp      as Numeric
	Local nLenDesc      as Numeric
	Local nLenAbat      as Numeric
	Local nLenForne     as Numeric
	Local nLenRejei     as Numeric
	Local nLenPrin      as Numeric
	Local nLenJuro      as Numeric
	Local nLenMult      as Numeric
	Local nLenOcor      as Numeric
	Local nLenTipo      as Numeric
	Local nLenCgc       as Numeric
	Local nLenDebito    as Numeric
	Local nLenNsNum     as Numeric
	Local nTotal        as Numeric
	Local nPos          as Numeric
	Local nPosEsp       as Numeric
	Local nBloco        as Numeric
	Local nSavRecno     as Numeric
	Local nTamForn      as Numeric
	Local nTamOcor      as Numeric
	Local nTamEEOcor    as Numeric
	Local aTabela       as Array
	Local aLeitura      as Array
	Local aValores      as Array
	Local aCampos       as Array
	Local dDebito       as Date
	Local nTamPre       as Numeric
	Local nTamNum       as Numeric
	Local nTamPar       as Numeric
	Local nTamTit       as Numeric
	Local lAchouTit     as Logical
	Local nTamBco       as Numeric
	Local nTamAge       as Numeric
	Local nTamCta       as Numeric
	Local lMultNat      as Logical
	Local aColsSEV      as Array
	Local lOk           as Logical
	Local nTotLtEZ      as Numeric
	Local nHdlPrv       as Numeric
	Local aArqConf      as Array // Atributos do arquivo de configuracao
	Local lCtbExcl      as Logical
	Local aFlagCTB      as Array
	Local lUsaFlag      as Logical
	Local lF430PORT     as Logical
	Local lAltPort      as Logical
	Local aDtMvFinOk    as Array //Array para as datas de baixa válidas
	Local aDtMvFinNt    as Array //Array para as datas de baixa inconsistentes com o parâmetro MV_DATAFIN
	Local lTrocaLP      as Logical
	Local lPCCBaixa     as Logical
	Local lIRPFBaixa    as Logical
	Local cPadAux       as Character
	Local aCtBaixa      as Array
	Local nX            as Numeric
	//DDA - Debito Direto Autorizado
	Local lUsaDDA       as Logical
	Local lProcDDA      as Logical
	Local lF430COMP     as Logical
	Local lFA430FIG     as Logical

	//Reestruturacao SE5
	Local oModelMov     as Object //Model de Movimento
	Local oSubFK5       as Object
	Local oSubFKA       as Object
	Local cLog          as Character
	Local cCamposE5     as Character
	Local cChaveTit     as Character
	Local cIDDoc        as Character
	Local lBxCnab       as Logical
	Local lCtMovPa      as Logical
	Local cBcoOfi       as Character
	Local cAgeOfi       as Character
	Local cCtaOfi       as Character
	Local cNatLote      as Character
	Local cLocRec       as Character
	Local aAreaCorr     as Array
	Local lF430GRAFIL   as Logical
	Local cCGCFilHeader as Character
	Local aAreaFK2      as Array
	Local aAreaFK5      as Array
	Local aAreaSE5      as Array
	Local aAreaSM0      as Array
	Local nValImp       as Numeric
	Local nOldValPgto   as Numeric
	Local nMoeda        as Numeric
	Local nTxMoeda      as Numeric
	Local lPagAnt       as Logical
	Local cAliasTmp     as Character
	Local nLinhas       as Numeric
	Local lArqErro      as Logical
	Local cCodForn      as Character
	Local nRecnoSE2     as Numeric
	Local cTpDescSE5    as Character
	Local nEstOrig      as Numeric
	Local nCasDec       as Numeric
	Local aContSX5      as Array
	Local lOkSEB        as Logical
	Local lLanConPro    as Logical
	Local lIntEAI080    as Logical
	Local lF430TXBX     as Logical
	Local nAcreDecre    as Numeric
	Local aSE2          as Array
	Local aTitulo       as Array
	Local cChaveSEA     as Character
	Local nIndice       as Numeric
	Local lTemIndice    as Logical
	Local nTamIdCNAB    as Numeric
	Local nBorderos     as Numeric
	Local aBorderos     as Array
	Local aTCBStatus    as Array
	Local lStatusTCB    as Logical
	Local lAgendado     as Logical
	Local lFValAcess    as Logical
	Local lPosicTit     as Logical
	Local lFA430LRM     as Logical
	Local lFirst        as Logical
	Local lFound        as Logical
	Local lCtbMulNat    as Logical
	Local lLpCanc		as Logical
	Local lPermBx		as Logical
	Local lFA430BX		as Logical

	cPosNum       := ""
	cPosData      := ""
	cPosDesp      := ""
	cPosDesc      := ""
	cPosAbat      := ""
	cPosPrin      := ""
	cPosJuro      := ""
	cPosMult      := ""
	cPosForne     := ""
	cPosOcor      := ""
	cPosTipo      := ""
	cPosCgc       := ""
	cRejeicao     := ""
	cPosDebito    := ""
	cPosRejei     := ""
	cChave430     := ""
	cNumSe2       := ""
	cChaveSe2     := ""
	cArqConf      := ""
	cArqEnt       := ""
	cPosNsNum     := ""
	cTabela       := "17"
	cPadrao       := ""
	cLanca        := ""
	cFilOrig      := cFilAnt // Salva a filial para garantir que nao seja alterada em customizacao
	lPosNum       := .F.
	lPosData      := .F.
	lPosDesp      := .F.
	lPosDesc      := .F.
	lPosAbat      := .F.
	lPosPrin      := .F.
	lPosJuro      := .F.
	lPosMult      := .F.
	lPosOcor      := .F.
	lPosTipo      := .F.
	lMovAdto      := .F.
	lPosNsNum     := .F.
	lPosForne     := .F.
	lPosRejei     := .F.
	lPosCgc       := .F.
	lPosdebito    := .F.
	lDesconto     := .F.
	lContabiliza  := .F.
	lUmHelp       := .F.
	lCabec        := .F.
	lPadrao       := .F.
	lBaixou       := .F.
	lHeader       := .F.
	lPermBx		  := .T.
	lF430VAR      := ExistBlock("F430VAR")
	lF430Baixa    := ExistBlock("F430BXA")
	lFA430BX      := ExistBlock("F430BXB")
	lF430Rej      := ExistBlock("F430REJ")
	lFa430Oco     := ExistBlock("FA430OCO")
	lFa430Se2     := ExistBlock("FA430SE2")
	lFa430Pa      := ExistBlock("FA430PA")
	lFa430Fil     := Existblock("FA430FIL")
	lFA430LP      := Existblock("FA430LP")
	lRet          := .T.
	nLidos        := 0
	nLenNum       := 0
	nLenData      := 0
	nLenDesp      := 0
	nLenDesc      := 0
	nLenAbat      := 0
	nLenForne     := 0
	nLenRejei     := 0
	nLenPrin      := 0
	nLenJuro      := 0
	nLenMult      := 0
	nLenOcor      := 0
	nLenTipo      := 0
	nLenCgc       := 0
	nLenDebito    := 0
	nLenNsNum     := 0
	nTotal        := 0
	nPos          := 0
	nPosEsp       := 0
	nBloco        := 0
	nSavRecno     := Recno()
	nTamForn      := Tamsx3("E2_FORNECE")[1]
	nTamOcor      := TamSx3("EB_REFBAN")[1]
	nTamEEOcor    := 2
	aTabela       := {}
	aLeitura      := {}
	aValores      := {}
	aCampos       := {}
	nTamPre       := TamSX3("E1_PREFIXO")[1]
	nTamNum       := TamSX3("E1_NUM")[1]
	nTamPar       := TamSX3("E1_PARCELA")[1]
	nTamTit       := nTamPre + nTamNum + nTamPar
	lAchouTit     := .F.
	nTamBco       := Tamsx3("A6_COD")[1]
	nTamAge       := TamSx3("A6_AGENCIA")[1]
	nTamCta       := Tamsx3("A6_NUMCON")[1]
	lMultNat      := IIF(mv_par12==1,.T.,.F.)
	aColsSEV      := {}
	lOk           := .F. //Controla se foi confirmada a distribuicao
	nTotLtEZ      := 0 //Totalizador da Bx Lote Mult Nat CC
	nHdlPrv       := 0
	aArqConf      := {} // Atributos do arquivo de configuracao
	lCtbExcl      := !Empty( xFilial("CT2") )
	aFlagCTB      := {}
	lUsaFlag      := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	lF430PORT     := ExistBlock("F430PORT")
	lAltPort      := .F.
	aDtMvFinOk    := {} //Array para as datas de baixa válidas
	aDtMvFinNt    := {} //Array para as datas de baixa inconsistentes com o parâmetro MV_DATAFIN
	lTrocaLP      := .F.
	lPCCBaixa     := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	lIRPFBaixa    := .F.
	cPadAux       := ""
	aCtBaixa      := {}
	nX            := 0
	//DDA - Debito Direto Autorizado
	lUsaDDA       := FDDAInUse()
	lProcDDA      := .F.
	lF430COMP     := ExistBlock( "F430COMP" )
	lFA430FIG     := ExistBlock( "FA430FIG" )
	lLpCanc		  := .F.

	//Reestruturacao SE5
	oModelMov     := Nil //Model de Movimento
	oSubFK5       := Nil
	oSubFKA       := Nil
	cLog          := ""
	cCamposE5     := ""
	cChaveTit     := ""
	cIDDoc        := ""
	lBxCnab       := GetMv("MV_BXCNAB") == "S"
	lCtMovPa      := SuperGetMv("MV_CTMOVPA",.T.,"1") == "2" // Indica se a Contabilizacao do LP513 ocorrer  pelo Título(SE2) ou Mov.Bancario(SE5) do Pagamento Antecipado. 1="SE2" / 2="SE5"
	cBcoOfi       := ""
	cAgeOfi       := ""
	cCtaOfi       := ""
	cNatLote      := FINNATMOV("P")
	cLocRec       := SuperGetMV( "MV_LOCREC" , .F. , .F. )
	aAreaCorr     := {}
	lF430GRAFIL   := ExistBlock("F430GRAFIL")
	cCGCFilHeader := ""
	aAreaFK2      := {}
	aAreaFK5      := {}
	aAreaSE5      := {}
	aAreaSM0      := {}
	nValImp       := 0
	nOldValPgto   := 0
	nMoeda        := 0
	nTxMoeda      := 0
	lPagAnt       := .F.
	cAliasTmp     := GetNextAlias()
	nLinhas       := 0
	lArqErro      := .F.
	cCodForn      := ""
	nRecnoSE2     := 0
	cTpDescSE5    := ""
	nEstOrig      := 0
	nCasDec       := TamSx3("E2_TXMOEDA")[2]
	aContSX5      := {}
	lOkSEB        := .T.
	lLanConPro    := .T.
	lIntEAI080    := .F.
	lF430TXBX     := .F.
	nAcreDecre    := 0
	aSE2          := {}
	aTitulo       := {}
	cChaveSEA     := ""
	nIndice       := 1
	lTemIndice    := .F.
	nTamIdCNAB    := TamSX3("E2_IDCNAB")[1]
	nBorderos     := 0
	aBorderos     := {}
	aTCBStatus    := {}
	lStatusTCB    := .F.
	lAgendado     := .F.
	lFValAcess    := FindFunction("FValAcess")
	lPosicTit     := .F.
	lFA430LRM     := ExistBlock("FA430LRM")
	lFirst        := .T.
	lFound        := .F.
	lCtbMulNat	  := .F.

	Private cBanco        as Character
	Private cAgencia      as Character
	Private cConta        as Character
	Private cHist070      as Character
	Private cArquivo      as Character
	Private lAut          as Logical
	Private nTotAbat      as Numeric
	Private cCheque       as Character
	Private cPortado      as Character
	Private lAdiantamento as Logical
	Private cNumBor       as Character
	Private cForne        as Character
	Private cCgc          as Character
	Private cDebito       as Character
	Private cModSpb       as Character
	Private cAutentica    as Character
	Private cLote         as Character
	Private cBenef        as Character
	Private nMoedaBco     as Numeric
	Private nVA           as Numeric

	lAut          := .F.
	nTotAbat      := 0
	cCheque       := " "
	cPortado      := " "
	lAdiantamento := .F.
	cNumBor       := " "
	cForne        := " "
	cCgc          := ""
	cDebito       := ""
	cModSpb       := "1"
	cAutentica    := Space(25)
	cLote         := Space(TamSX3("EE_LOTECP")[1])
	cBenef        := ""
	nMoedaBco     := 0
	nVA           := 0

	If Type("aMsgSch") == "U"
		Private aMsgSch := {}
	Endif

	//Reestruturacao SE5
	Private nDescCalc 	as Numeric
	Private nJurosCalc  as Numeric
	Private nMultaCalc  as Numeric
	Private nCorrCalc   as Numeric
	Private nDifCamCalc as Numeric
	Private nImpSubCalc as Numeric
	Private nPisCalc    as Numeric
	Private nCofCalc    as Numeric
	Private nCslCalc    as Numeric
	Private nIrfCalc    as Numeric
	Private nIssCalc    as Numeric
	Private nPisBaseR   as Numeric
	Private nCofBaseR   as Numeric
	Private nCslBaseR   as Numeric
	Private nIrfBaseR   as Numeric
	Private nIssBaseR   as Numeric
	Private nPisBaseC   as Numeric
	Private nCofBaseC   as Numeric
	Private nCslBaseC   as Numeric
	Private nIrfBaseC   as Numeric
	Private nIssBaseC   as Numeric
	Private lVlrMaior   as Logical
	Private nVlrMaior   as Numeric
	Private cTpDesc     as Character
	Private cArqCnab    as Character

	nDescCalc   := 0
	nJurosCalc  := 0
	nMultaCalc  := 0
	nCorrCalc   := 0
	nDifCamCalc := 0
	nImpSubCalc := 0
	nPisCalc    := 0
	nCofCalc    := 0
	nCslCalc    := 0
	nIrfCalc    := 0
	nIssCalc    := 0
	nPisBaseR   := 0
	nCofBaseR   := 0
	nCslBaseR   := 0
	nIrfBaseR   := 0
	nIssBaseR   := 0
	nPisBaseC   := 0
	nCofBaseC   := 0
	nCslBaseC   := 0
	nIrfBaseC   := 0
	nIssBaseC   := 0
	cTpDesc     := ""
	cArqCnab	:= Upper(MV_PAR03)

	DEFAULT aParamB := {}

	lChqPre := .F.

	If __lVldExtC == Nil
		__lVldExtC := FindFunction("VldExtCNAB")
	EndIf

	If __lGesplan == Nil
		__lGesplan  := SuperGetMv("MV_FINTGES",.F.,.F.) .And. FindFunction("FUpdStamp")
	EndIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no Banco indicado                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cBanco  := mv_par05
	cAgencia:= mv_par06
	cConta  := mv_par07
	cSubCta := mv_par08

	If lExecJob // Anula parâmetro MV_LOCREC quando vem de schedule
		cLocRec := ""
	Endif

	dbSelectArea("SA6")
	SA6->(DbSetOrder(1))
	If SA6->(dbSeek(xFilial("SA6")+cBanco+cAgencia+cConta))
		nMoedaBco := SA6->A6_MOEDA
	EndIf

	dbSelectArea("SEE")
	SEE->(DbSetOrder(1))
	SEE->(dbSeek(xFilial("SEE")+cBanco+cAgencia+cConta+cSubCta))

	// Buscar a Conta Oficial. Abaixo eu seto os novos valores
	If !Empty(SEE->EE_CTAOFI)
		cBcoOfi	:= SEE->EE_CODOFI
		cAgeOfi	:= SEE->EE_AGEOFI
		cCtaOfi	:= SEE->EE_CTAOFI

		cBanco		:= SEE->EE_CODOFI
		cAgencia	:= SEE->EE_AGEOFI
		cConta		:= SEE->EE_CTAOFI
	endif

	If Empty(SEE->EE_NRBYTES)
		nBloco := If(MV_PAR10 == 1, 402, 242)
	Else
		nBloco := SEE->EE_NRBYTES+2
	EndIf

	If !SEE->(found())
		if !lExecJob
			Help(" ",1,"PAR150")
		Else
			Aadd(aMsgSch, STR0032+cBanco+"  "+STR0033+cAgencia+"  "+STR0034+cConta+"  "+STR0035+cSubCta) // "Parametros de Bancos nao encontrados para o Banco:" # "Agencia:" # "Conta:" # "Sub-Conta:"
		Endif

		//Atualiza o log de processamento com o erro
		ProcLogAtu("ERRO", "PAR150", Ap5GetHelp("PAR150"))
		lRet:= .F.
	Endif

	If lRet .And. lBxCnab // Baixar arquivo recebidos pelo CNAB aglutinando os valores
		If Empty(SEE->EE_LOTECP)
			cLoteFin := StrZero(1, TamSX3("EE_LOTECP")[1])
		Else
			cLoteFin := FinSomaLote(SEE->EE_LOTECP)
		EndIf

		cLoteFin := Iif(CheckLote("P",.F.), cLoteFin, GetNewLote())
	EndIf

	If lRet
		lRet := DtMovFin(dDatabase,,"1")
	EndIf

	IF !lRet
		return(.f.)
	Endif

	//Tratamento para gestão corporativa
	If FWSizeFilial() > 2
		If (FWModeAccess("CT2", 3) == "C") .Or. ( FWModeAccess("CT2", 2) == "C") .Or. ( FWModeAccess("CT2", 1) == "C")
			lCtbExcl := .F.
		EndIf
	EndIf

	If lRet
		cTabela := Iif( Empty(SEE->EE_TABELA), "17" , SEE->EE_TABELA )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se a tabela existe           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aContSX5 := FWGetSX5(cTabela)
		If Empty(aContSX5)
			If ! lExecJob
				Help(" ",1,"PAR430")
			Else
				Aadd(aMsgSch, STR0036) // "Tabela 17 nao localizada no arquivo de tabelas SX5"
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento com o erro  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ProcLogAtu("ERRO","PAR430",Ap5GetHelp("PAR430"))

			lRet := .F.
		Endif
	EndIf

	//Verifica se a contabilidade está em modo exclusivo e se foi solicitado o processamento de todas as filiais
	If lRet .And. mv_par11 == 2 .And. lCtbExcl .And. !lExecJob
		lRet := MsgYesNo(STR0015, STR0010) //Neste caso, o sistema não realiza a contabilização on-line. Confirma mesmo assim?
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se arquivo ja foi processado anteriormente	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet .And. !(Chk430File())
		lRet := .F.
	Endif

	//Retorno Automatico via Job se o arquivo estiverno diretorio vai reprocessar sempre se for JOB
	If lExecJob .and. ! lRet
		ProcLogAtu("ALERTA",STR0017+Alltrim(mv_par03)+STR0018) 	// "Arquivo :" # " processado anteriormente."
		Aadd(aMsgSch, STR0017+Alltrim(mv_par03)+STR0018) 		// "Arquivo :" # " processado anteriormente."
	Endif

	//Altero banco da baixa pelo portador ?
	If lF430PORT
		lAltPort := ExecBlock("F430PORT",.F.,.F.)
	Endif


	For nX := 1 to Len(aContSX5)
		AADD(aTabela,{Alltrim(aContSX5[nX][4]),PadR(AllTrim(aContSX5[nX][3]),3)})
	Next nX
	ASize(aContSX5,0)
	aContSX5 := nil

	If lRet
		//Verifica o numero do Lote
		LoteCont("FIN")

		//Abre arquivo de configuracao
		cArqConf := mv_par04
		If !(File(cArqConf))
			if ! lExecJob
				Help(" ",1,"NOARQPAR")
			Else
				Conout(STR0037+cArqConf+STR0038) // "Arquivo de configuracao " # " nao localizado."
				Aadd(aMsgSch, STR0037+cArqConf+STR0038) // "Arquivo de configuracao " # " nao localizado."
			Endif
			//Atualiza o log de processamento com o erro
			ProcLogAtu("ERRO","NOARQPAR",Ap5GetHelp("NOARQPAR"))

			lRet:= .F.
		ElseIf !__lVldExtC .Or. (lRet :=  VldExtCNAB(SubStr(cArqConf, At(".", cArqConf) + 1), "FINA430"))
			If MV_PAR10 == 1
				nHdlConf := FOpen(cArqConf, 0 + 64)
			EndIf
		EndIf
	EndIf

	If lRet .And. ( MV_PAR10 == 1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Lˆ arquivo de configuracao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nLidos:=0
		FSEEK(nHdlConf,0,0)
		nTamArq:=FSEEK(nHdlConf,0,2)
		FSEEK(nHdlConf,0,0)
		While nLidos <= nTamArq

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica o tipo de qual registro foi lido ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			xBuffer:=Space(85)
			FREAD(nHdlConf,@xBuffer,85)

			IF SubStr(xBuffer,1,1) == CHR(1)
				nLidos+=85
				Loop
			EndIF
			IF SubStr(xBuffer,1,1) == CHR(3)
				Exit
			EndIF
			IF !lPosNum
				cPosNum:=Substr(xBuffer,17,10)
				nLenNum:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosNum:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosData
				cPosData:=Substr(xBuffer,17,10)
				nLenData:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosData:=.t.
				nLidos+=85
				Loop
			End
			IF !lPosDesp
				cPosDesp:=Substr(xBuffer,17,10)
				nLenDesp:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosDesp:=.t.
				nLidos+=85
				Loop
			End
			IF !lPosDesc
				cPosDesc:=Substr(xBuffer,17,10)
				nLenDesc:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosDesc:=.t.
				nLidos+=85
				Loop
			End
			IF !lPosAbat
				cPosAbat:=Substr(xBuffer,17,10)
				nLenAbat:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosAbat:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosPrin
				cPosPrin:=Substr(xBuffer,17,10)
				nLenPrin:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosPrin:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosJuro
				cPosJuro:=Substr(xBuffer,17,10)
				nLenJuro:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosJuro:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosMult
				cPosMult:=Substr(xBuffer,17,10)
				nLenMult:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosMult:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosOcor
				cPosOcor:=Substr(xBuffer,17,10)
				nLenOcor:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosOcor:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosTipo
				cPosTipo:=Substr(xBuffer,17,10)
				nLenTipo:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosTipo:=.t.
				nLidos+=85
				Loop
			EndIF
			IF !lPosNsNum
				cPosNsNum := Substr(xBuffer,17,10)
				nLenNsNum := 1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosNsNum := .t.
				nLidos += 85
				Loop
			EndIF
			IF !lPosRejei
				cPosRejei := Substr(xBuffer,17,10)
				nLenRejei := 1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosRejei := .t.
				nLidos += 85
				Loop
			EndIF
			IF !lPosForne
				cPosForne := Substr(xBuffer,17,10)
				nLenForne := 1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosForne := .t.
				nLidos += 85
				Loop
			EndIF
			IF !lPosCgc
				cPosCgc   := Substr(xBuffer,17,10)
				nLenCgc   := 1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosCgc   := .t.
				nLidos += 85
				Loop
			EndIF
			IF !lPosDebito
				cPosDebito:=Substr(xBuffer,17,10)
				nLenDebito:=1+Int(Val(Substr(xBuffer,20,3)))-Int(Val(Substr(xBuffer,17,3)))
				lPosDebito:=.t.
				nLidos+=85
				Loop
			EndIF
		EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Fecha arquivo de configuracao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Fclose(nHdlConf)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre arquivo enviado pelo banco ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet
		//MV_LOCREC  -Parâmetro onde será gravado o diretório.
		If (lExecJob .Or. (Empty(cLocRec) .And. !lExecJob))
			cArqEnt := mv_par03
		Else
			//Verifica qual barra está o parâmetro , e o que está na ultima posição através do RAT
			If AT("\",alltrim(cLocRec))>0 .and. RAT("\",SUBSTR(alltrim(cLocRec),LEN(alltrim(cLocRec)),1)) = 0
				cArqEnt := cLocRec+"\"+TRIM(mv_par03)
			ElseIf AT("\",alltrim(cLocRec))>0 .and. RAT("\",SUBSTR(alltrim(cLocRec),LEN(alltrim(cLocRec)),1)) > 0
				cArqEnt := cLocRec+TRIM(mv_par03)
			ElseIf AT("/",alltrim(cLocRec))>0 .and. RAT("/",SUBSTR(alltrim(cLocRec),LEN(alltrim(cLocRec)),1)) > 0
				cArqEnt  := SuperGetMV( "MV_LOCREC" , .F. , .F. )+TRIM(mv_par03)
			ElseIf AT("/",alltrim(cLocRec))>0 .and. RAT("/",SUBSTR(alltrim(cLocRec),LEN(alltrim(cLocRec)),1)) = 0
				cArqEnt := cLocRec+"/"+TRIM(mv_par03)
			Endif
		Endif

		//Validar as Inconsistências
		If !Empty(cLocRec) .and. (Empty(mv_par03) .or. AT(":",mv_par03)>0 .or. (AT("/",mv_par03)>0 .or. AT("\",mv_par03)>0))
			Help(" ",1,"F150ARQ",,STR0023,1,0) //"Nome do Arquivo de Saida Inválido
			Return .F.
		Endif

		If !FILE(cArqEnt)
			If !lExecJob
				Help(" ",1,"NOARQENT")
			Else
				Aadd(aMsgSch, STR0039+cArqEnt+STR0040) // "Arquivo de entrada " # " nao localizado."
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento com o erro  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ProcLogAtu("ERRO","NOARQENT",Ap5GetHelp("NOARQENT"))

			lRet:= .F.
		Else
			nHdlBco:=FOPEN(cArqEnt,0+16)
		EndIF
	EndIf

	If lRet
		//Lê arquivo enviado pelo banco
		nLidos:=0
		FSEEK(nHdlBco,0,0)
		nTamArq:=FSEEK(nHdlBco,0,2)
		FSEEK(nHdlBco,0,0)

		// Validação de Integridade do Arquivo de Retorno
		nLinhas := nTamArq/nBloco
		lArqErro := (nLinhas - Int(nLinhas)) <> 0 // Arquivo Corrompido

		If lArqErro
			lRet := .F.

			If !lExecJob
				lRet := MsgYesNo(STR0028+MV_PAR08+CRLF+STR0029, STR0010) // "Arquivo de retorno corrompido! De acordo com o Cadastro de Parametros de Bancos - Sub Conta: "
			EndIf
		EndIf
	EndIf

	If lRet
		lIntEAI080 := FWHasEAI("FINA080", Nil, Nil, .T.)
		lF430TXBX  := ExistBlock("F430TXBX")
		lTemIndice := !Empty(SEA->(IndexKey(4)))
		dbSelectArea("SED")
		dbSelectArea("SEB")

		//Desenha o cursor e o salva para poder moviment -lo
		ProcRegua(nLinhas)

		//Certifico de que o TRB esta fechado
		If (Select("TRB")<>0)
			dbSelectArea("TRB")
			dbCloseArea()
		EndIf

		//Gera arquivo de Trabalho
		AADD(aCampos,{"FILMOV"	,"C",IIf(lFWCodFil, FWGETTAMFILIAL, 2 ), 0})
		AADD(aCampos,{"BANCO"	,"C",TamSx3("A6_COD")[1],0})
		AADD(aCampos,{"AGENCIA"	,"C",TamSx3("A6_AGENCIA")[1],0})
		AADD(aCampos,{"CONTA"	,"C",TamSx3("A6_NUMCON")[1],0})
		AADD(aCampos,{"DATAD"	,"D",08,0})
		AADD(aCampos,{"NATURE"	,"C",TAMSX3("E2_NATUREZ")[1],0})
		AADD(aCampos,{"MOEDA"	,"C",TAMSX3("E2_MOEDA")[1],0})
		AADD(aCampos,{"TOTAL"	,"N",17,2})
		AADD(aCampos,{"FILORI"	,"C",IIf(lFWCodFil, FWGETTAMFILIAL, 2 ), 0})

		If(_oFina430 <> NIL)
			_oFina430:Delete()
			_oFina430 := NIL
		EndIf

		_oFina430 := FwTemporaryTable():New("TRB")
		_oFina430:SetFields(aCampos)
		_oFina430:AddIndex("1",{"FILMOV","BANCO","AGENCIA","CONTA","DATAD"})
		_oFina430:Create()

		//Carrega atributos do arquivo de configuracao
		aArqConf := Directory(mv_par04)

		Begin Transaction
			lContabiliza := mv_par09 == 1
			SEB->(dbSetOrder(1))

			While nLidos <= nTamArq
				IncProc()
				nDespes    :=0
				nDescont   :=0
				nAbatim    :=0
				nValRec    :=0
				nJuros     :=0
				nMulta     :=0
				nValCc     :=0
				nValPgto   :=0
				nMoeda	   :=0
				nTxMoeda   :=0
				nCM        :=0
				nVlrMaior  := 0
				ABATIMENTO := 0
				lPagAnt	   := .F.
				lProcDDA   := .F.
				cFilAnt    := cFilOrig
				lPosSE2    := .F.
				nRecnoSE2  := 0
				nEstOrig   := 0
				nVA        := 0
				lMovAdto   := .F.
				lVlrMaior	:= .F.

				//Tipo qual registro foi lido
				If MV_PAR10 == 1
					xBuffer:=Space(nBloco)
					FREAD(nHdlBco,@xBuffer,nBloco)

					//Considera a primeira linha sempre como um cabe‡alho
					If lFA430FIG .And. (lHeader .And. SubStr(xBuffer,1,1) != "1" .And. Substr(xBuffer, 1, 3) != "001") .Or. (cBanco == "409" .And. SubStr(xBuffer, 1, 1) == "2")
						cCGCFilHeader := Substr(xBuffer, 12,14) // ler o novo cnpj do header
					EndIf

					If !lHeader
						lHeader := .T.
						nLidos	+= nBloco
						cCGCFilHeader := Substr(xBuffer, 12,14)
						Loop
					EndIf

					If SubStr(xBuffer, 1, 1) == "1" .Or. Substr(xBuffer, 1, 3) == "001" .Or. (cBanco == "409" .And. SubStr(xBuffer, 1, 1) == "2")  // Unibanco
						//Ler os valores do arquivo Retorno
						cNumTit := Substr(xBuffer, Int(Val(Substr(cPosNum, 1, 3))), nLenNum )
						cData   := Substr(xBuffer, Int(Val(Substr(cPosData,1, 3))), nLenData)
						cData   := ChangDate(cData, SEE->EE_TIPODAT)
						dBaixa  := Ctod(Substr(cData,1,2)+"/"+Substr(cData,3,2)+"/"+Substr(cData,5),"ddmm"+Replicate("y",Len(Substr(cData,5))))
						dDebito := dBaixa
						cTipo   := Substr(xBuffer,Int(Val(Substr(cPosTipo, 1,3))),nLenTipo )
						cNsNum  := " "

						If !Empty(cPosDesp)
							nDespes:=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosDesp,1,3))),nLenDesp))/100,2)
						EndIf

						If !Empty(cPosDesc)
							nDescont:=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosDesc,1,3))),nLenDesc))/100,2)
						EndIf

						If !Empty(cPosAbat)
							nAbatim:=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosAbat,1,3))),nLenAbat))/100,2)
						EndIf

						If !Empty(cPosPrin)
							nValPgto :=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosPrin,1,3))),nLenPrin))/100,2)
						EndIF

						If !Empty(cPosJuro)
							nJuros  :=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosJuro,1,3))),nLenJuro))/100,2)
						EndIf

						If !Empty(cPosMult)
							nMulta  :=Round(Val(Substr(xBuffer,Int(Val(Substr(cPosMult,1,3))),nLenMult))/100,2)
						EndIf

						If !Empty(cPosNsNum)
							cNsNum  :=Substr(xBuffer,Int(Val(Substr(cPosNsNum,1,3))),nLenNsNum)
						EndIf

						IF !Empty(cPosRejei)
							cRejeicao  :=Substr(xBuffer,Int(Val(Substr(cPosRejei,1,3))),nLenRejei)
						EndIf

						If !Empty(cPosForne)
							cForne  :=Substr(xBuffer,Int(Val(Substr(cPosForne,1,3))),nLenForne)
						EndIf

						nTamEEOcor := IIF(cPaisLoc == "BRA", SEE->EE_TAMOCOR, 2)
						cOcorr     := Substr(xBuffer, Int(Val(Substr(cPosOcor, 1, 3))), nLenOcor)
						cOcorr     := PadR(Left(Alltrim(cOcorr), nTamEEOcor) , nTamOcor)

						If !Empty(cPosCgc)
							cCgc  :=Substr(xBuffer,Int(Val(Substr(cPosCgc,1,3))),nLenCgc)
						Endif

						If !Empty(cPosDebito)
							cDebito :=Substr(xBuffer,Int(Val(Substr(cPosDebito,1,3))),nLenDebito)
							cDebito :=ChangDate(cDebito,SEE->EE_TIPODAT)

							If !Empty(cDebito)
								dDebito :=Ctod(Substr(cDebito,1,2)+"/"+Substr(cDebito,3,2)+"/"+Substr(cDebito,5),"ddmm"+Replicate("y",Len(Substr(cDebito,5))))
							Endif
						Endif

						nCM     := 0
						cRastro	:= Substr(xBuffer, 264, 2) //Operacao de rastreamento = 30 (Fixo)
						cDDA    := Substr(xBuffer, 279, 2) //Operacao de rastreamento = "FS" (Fixo)

						//Rastreamento DDA - Bradesco
						If lUsaDDA .And. cBanco == "237" .And. cRastro == "30" .And. cDDA == "FS"
							cBcoForn := Substr(xBuffer, 096, 3) //01-03 Banco do cedente - Fornecedor
							cCodBar	 := ""						//Codigo de barras completo
							cFatorVc := ""						//Fator de Vencimento
							cMoeda	 := "9"						//Moeda do titulo (9 = Real)
							cDV		 := ""						//Digito verificador do codigo de barras (sera calculado)
							cVencto	 := ""						//Data de vencimento
							cOcorr	 := PadR("FS", nTamOcor)	//Forco Ocorrencia pois a mesma pode voltar vazia em caso de rastreamento DDA
							cVencto  := Substr(xBuffer, 166, 8)
							cVencto  := ChangDate(cVencto, SEE->EE_TIPODAT)
							cVencto  := Substr(cVencto, 1, 2) + "/" + Substr(cVencto, 3, 2) + "/" + Substr(cVencto, 5)

							If ctod(cVencto) < ctod("22/02/25")
								cFatorVc := StrZero(ctod(cVencto) - ctod("07/10/97"), 4) //Fator de Vencimento
							Else 
								cFatorVc := StrZero(ctod(cVencto) - ctod("29/05/22"), 4)//Fator de Vencimento
							EndIf 
							
							cValPgto := Substr(xBuffer, 195, 10)

							//Bando do Cedente = Bradesco
							If cBcoForn == "237"
								//Campo Livre do codigo de barras
								//Agencia + Carteira + Nosso Numero +  Conta corrente + 0
								cCpoLivre := Substr(xBuffer, 100, 4) + Substr(xBuffer, 137, 2) + Substr(xBuffer, 140, 11)+ Substr(xBuffer, 111, 7) + "0"
							Else
								cCpoLivre:= Substr(xBuffer, 374, 25)
							Endif

							//Calculo do digito verificador do codigo de barras
							cDV := DV_BarCode(cBcoForn + cMoeda + cFatorVc + cValPgto + cCpoLivre)

							/*Montagem do código de barras:
							01-03 - Codigo do banco
							04-04 - Codigo da moeda
							05-05 - Digito verificador
							06-09 - Fator vencimento
							10-19 - Valor do documento
							20-44 - Campo Livre
							*/
							cCodBar :=	cBcoForn + cMoeda + cDV + cFatorVc + cValPgto + cCpoLivre
							lProcDDA := !Empty(cCodBar)
						Endif

						If lFa430Fil
							Execblock("FA430FIL", .F., .F., {xBuffer})
						Endif

						If lF430Var
							/*o array aValores permitirá que qualquer exceção ou necessidade seja tratado no ponto de entrada em PARAMIXB

							Estrutura de aValores
							Numero do Título	- 01
							data da Baixa		- 02
							Tipo do Título		- 03
							Nosso Numero		- 04
							Valor da Despesa	- 05
							Valor do Desconto	- 06
							Valor do Abatimento	- 07
							Valor Pagamento   	- 08
							Juros				- 09
							Multa				- 10
							Fornecedor			- 11
							Ocorrencia			- 12
							CGC					- 13
							nCM					- 14
							Rejeicao			- 15
							Linha Inteira		- 16*/
							aValores := ({cNumTit, dBaixa, cTipo, cNsNum, nDespes, nDescont, nAbatim, nValPgto, nJuros, nMulta, cForne, cOcorr, cCGC, nCM, cRejeicao, xBuffer })
							ExecBlock("F430VAR", .F., .F., {aValores})
						EndIf

						If !(Empty(cNumTit))
							If Len(LTrim(cNumTit)) < nTamIdCNAB
								cNumTit := AjstIdCNAB(cNumTit)
							EndIf
							
							If !lProcDDA
								nRecnoSE2 := F430FilTit(cNumTit)
							EndIf
						EndIf

						//Verifica especie do titulo
						cEspecie := "  "

						If (nPos := Ascan(aTabela, {|aVal|aVal[1] == Alltrim(Substr(cTipo, 1, 3))})) != 0
							cEspecie := aTabela[nPos][2]
						EndIf

						If cEspecie $ MVABATIM		// Nao lˆ titulo de abatimento
							nLidos += nBloco
							Loop
						EndIf

						//Ponto de entrada para permitir ou nao a baixa de um determinadotipo de titulo. PA por exemplo.
						If lFa430Pa .And. !(ExecBlock("FA430PA", .F., .F., cEspecie))
							nLidos += nBloco
							Loop
						Endif
					Else
						nLidos += nBloco
						Loop
					EndIf
				Else
					If Valtype(MV_PAR04) == "C"
						cArqConf := MV_PAR04
					Endif

					aLeitura   := ReadCnab2(nHdlBco,cArqConf,nBloco,aArqConf)
					cNumTit    := SubStr(aLeitura[1],1, nTamTit)
					cData      := aLeitura[04]
					cData      := ChangDate(cData,SEE->EE_TIPODAT)
					dBaixa     := Ctod(Substr(cData,1,2)+"/"+Substr(cData,3,2)+"/"+Substr(cData,5),"ddmm"+Replicate("y",Len(Substr(cData,5))))
					cTipo      := aLeitura[02]
					cNsNum     := aLeitura[11]
					nDespes    := aLeitura[06]
					nDescont   := aLeitura[07]
					nAbatim    := aLeitura[08]
					nValPgto   := aLeitura[05]
					nJuros     := aLeitura[09]
					nMulta     := aLeitura[10]
					cNsNum     := aLeitura[11]
					If cPaisLoc == "BRA" .and. SEE->EE_TAMOCOR > 0
						nTamEEOcor := SEE->EE_TAMOCOR
					Else
						nTamEEOcor := 2
					EndIf
					cOcorr     := PadR( Left(Alltrim(aLeitura[03]),nTamEEOcor) , nTamOcor)
					cForne     := aLeitura[16]
					dDebito	   := dBaixa
					xBuffer	   := aLeitura[17]

					//Segmento Z - Autenticacao
					If Len(aLeitura) > 17
						cAutentica := aLeitura[18]
					Endif

					//CGC
					If Len(aLeitura) > 19
						cCgc := aLeitura[20]
					Endif

					//Buscar a Conta Oficial
					If !Empty(cCtaOfi)
						cBanco   := cBcoOfi
						cAgencia := cAgeOfi
						cConta   := cCtaOfi
					ElseIf Len(aLeitura) > 20
						cBanco	 := If(ALLTRIM(mv_par05) $ aLeitura[21],mv_par05, PAD(aLeitura[21], nTamBco))
						cAgencia := If(ALLTRIM(mv_par06) $ aLeitura[22],mv_par06, PAD(aLeitura[22], nTamAge))
						cConta	 := If(ALLTRIM(mv_par07) $ aLeitura[23],mv_par07, PAD(aLeitura[23], nTamCta))
					Else
						cBanco   := mv_par05
						cAgencia := mv_par06
						cConta   := mv_par07
					Endif

					//DDA - Debito Direto Autorizado
					If lUsaDDA
						If Len(aLeitura) > 23
							//Caso o CNPJ do Fornecedor seja retornado no Segmento H, assumo este valor
							If !Empty(aLeitura[24]) .And. Substr(aLeitura[24],1,7) != "0000000"
								cCgc := aLeitura[24]
							Endif

							cCodBar  := aLeitura[25]
							lProcDDA := !Empty(cCodBar)
						Endif
						If Len(aLeitura) > 25
							//Caso o CNPJ da empresa seja retornado no Segmento H, assumo este valor
							If !Empty(aLeitura[26]) .And. Substr(aLeitura[26],1,7) != "0000000"
								cCGCFilHeader := aLeitura[26]
							Endif
						Endif
					Endif

					If Empty(cNumTit) .And. !lProcDDA
						nLidos += nBloco
						Loop
					Endif

					If lF430Var
						/*o array aValores permitirá que qualquer exceção ou necessidade seja tratado no ponto de entrada em PARAMIXB.

						Estrutura de aValores
						Numero do Título	- 01
						Data da Baixa		- 02
						Tipo do Título		- 03
						Nosso Numero		- 04
						Valor da Despesa	- 05
						Valor do Desconto	- 06
						Valor do Abatiment	- 07
						Valor Pagamento   	- 08
						Juros				- 09
						Multa				- 10
						Fornecedor			- 11
						Ocorrencia			- 12
						CGC					- 13
						nCM					- 14
						Rejeicao			- 15
						Linha Inteira		- 16
						Autenticacao 	    - 17
						Banco             	- 18
						Agencia           	- 19
						Conta             	- 20*/
						aValores := ({cNumTit, dBaixa, cTipo, cNsNum, nDespes, nDescont, nAbatim, nValPgto, nJuros, nMulta, cForne, cOcorr, cCGC, nCM, cRejeicao, xBuffer, cAutentica, cBanco, cAgencia, cConta})
						ExecBlock("F430VAR", .F., .F., {aValores})
					Endif

					If !(Empty(cNumTit))
						//Verifica se possui espaço em branco antes do número
						If Len(LTrim(cNumTit)) < nTamIdCNAB
							cNumTit := AjstIdCNAB(cNumTit)
						EndIf
						
						If !lProcDDA
							nRecnoSE2 := F430FilTit(cNumTit)
						EndIf
					EndIf

					//Verifica especie do titulo
					cEspecie	:= "  "

					If (nPos := Ascan(aTabela, {|aVal|aVal[1] == Alltrim(Substr(cTipo,1,3))})) != 0
						cEspecie := aTabela[nPos][2]
					EndIf

					If cEspecie $ MVABATIM			// Nao lˆ titulo de abatimento
						Loop
					EndIf

					//Ponto de entrada para permitir ou nao a baixa de um determinadotipo de titulo. PA por exemplo
					If lFa430Pa .And. !(ExecBlock("FA430PA",.F.,.F.,cEspecie))
						Loop
					Endif
				EndIf
				
				If mv_par11 == 1 .And. SE2->E2_FILIAL <> FwxFilial("SE2")
					lOkSEB := SEB->(DbSeek(xFilial("SEB")+mv_par05+cOcorr+"P"))

					If !lProcDDA .OR. (lProcDDA .And. ((lOkSEB .And. SEB->EB_OCORR <> "02") .OR. !lOkSEB))
						Loop
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se existe o titulo no SE2. Caso este titulo nao seja ³
				//³ localizado, passa-se para a proxima linha do arquivo retorno. ³
				//³ O texto do help sera' mostrado apenas uma vez, tendo em vista ³
				//³ a possibilidade de existirem muitos titulos de outras filiais.³
				//³ OBS: Sera verificado inicialmente se nao existe outra chave   ³
				//³ igual para tipos de titulo diferentes.                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				lHelp     := .F.
				lAchouTit := .F.
				lPosicTit := .f.
				//Verifica a data de baixa do arquivo em relação ao parâmetro MV_DATAFIN
				If AScan(aDtMvFinOk , dBaixa ) == 0
					If AScan(aDtMvFinNt , dBaixa ) == 0
						If !DtMovFin(dBaixa , .F.,"1")
							aAdd(aDtMvFinNt , dBaixa )

							If mv_par10 == 1
								nLidos += nBloco
							EndIf

							ProcLogAtu("ERRO" , "DTMOVFIN" , Ap5GetHelp( "DTMOVFIN" ) + " " + DtoC( dBaixa ) )
							Loop
						Else
							aAdd( aDtMvFinOk , dBaixa )
						EndIf
					Else
						If mv_par10 == 1
							nLidos += nBloco
						EndIf

						Loop
					EndIf
				EndIf

				aValores := ( { cNumTit, dBaixa, cTipo, cNsNum, nDespes, nDescont, nAbatim, nValPgto, nJuros, nMulta, cForne, cOcorr, cCGC, nCM, cRejeicao, xBuffer })

				//Processamento normal - Nao se trata de processamento de arquivo de DDA
				If !lProcDDA
					If lFa430SE2
						lPosicTit := ExecBlock("FA430SE2", .F., .F., {aValores})						
						lAchouTit := IIf(lExecJob .And. Valtype(lPosicTit) == "L", lPosicTit, lAchouTit)
					Else
						//Se processa todas as filiais, tem o novo indice somente por IDCNAB e a filial da SE2 estah preenchida.
						If lCtbExcl .And. mv_par11 == 2 .And. !Empty(xFilial("SE2"))
							mv_par09 		:= 2 //Desligo contabilizacao on-line
							lContabiliza	:= .F.
						Endif

						//Se nao achou, utiliza metodo antigo (titulo)
						If nRecnoSE2 == 0 .And. SE2->(!Found())
							SE2->(dbSetOrder(1))

							//Chave retornada pelo banco
							cChave430 := IIf(!Empty(cForne), Pad(cNumTit, nTamTit) + cEspecie + SubStr(cForne, 1, nTamForn), Pad(cNumTit, nTamTit) + cEspecie)

							While !lAchouTit
								If !SE2->(DbSeek(xFilial() + cChave430))
									nPos := Ascan(aTabela, {|aVal|aVal[1] == AllTrim(Substr(cTipo,1,3))},nPos+1)

									If nPos != 0
										cEspecie := aTabela[nPos][2]
										cChave430 := IIf(!Empty(cForne), Pad(cNumTit, nTamTit) + cEspecie + SubStr(cForne, 1, nTamForn), Pad(cNumTit, nTamTit) + cEspecie)
									Else
										Exit
									Endif
								Else
									lAchouTit := .T.
								Endif
							Enddo

							//Chave retornada pelo banco com a adicao de espacos para tratar chave enviada ao banco com
							//tamanho de nota de 6 posicoes e retornada quando o tamanho da nota e 9 (atual)
							If !lAchouTit
								cNumTit   := SubStr(cNumTit, 1, nTamPre) + Padr(Substr(cNumTit, 4, 6), nTamNum) + SubStr(cNumTit, 10, nTamPar)
								cChave430 := IIf(!Empty(cForne), Pad(cNumTit, nTamTit) + cEspecie + SubStr(cForne, 1, nTamForn), Pad(cNumTit, nTamTit) + cEspecie)
								nPos      := Ascan(aTabela, {|aVal|aVal[1] == Alltrim(Substr(cTipo, 1, 3))})

								While !lAchouTit
									If !dbSeek(xFilial()+cChave430)
										nPos := Ascan(aTabela, {|aVal|aVal[1] == AllTrim(Substr(cTipo,1,3))},nPos+1)

										If nPos != 0
											cEspecie  := aTabela[nPos][2]
											cChave430 := IIf(!Empty(cForne), Pad(cNumTit, nTamTit) + cEspecie + SubStr(cForne, 1, nTamForn), Pad(cNumTit, nTamTit) + cEspecie)
										Else
											Exit
										Endif
									Else
										lAchouTit := .T.
									Endif
								Enddo
							Endif

							//Se achou o titulo, verificar o CGC do fornecedor
							If lAchouTit
								cNumSe2   := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)
								cChaveSe2 := IIf(!Empty(cForne), cNumSe2 + SE2->E2_FORNECE, cNumSe2)
								nPosEsp	  := nPos	// Gravo nPos para volta-lo ao valor inicial, caso encontre o titulo

								While SE2->(!Eof()) .And. SE2->E2_FILIAL + cChaveSe2 == xFilial("SE2") + cChave430
									nPos := nPosEsp

									If Empty(cCgc)
										Exit
									Endif

									SA2->(DbSetOrder(1))

									If (SA2->(DbSeek(xFilial("SA2") + SE2->E2_FORNECE + SE2->E2_LOJA))) .And. (Substr(SA2->A2_CGC, 1, 14) == cCGC .Or. StrZero(Val(SA2->A2_CGC), 14, 0) == StrZero(Val(cCGC), 14, 0))
										Exit
									Endif

									SE2->(DbSkip())
									cNumSe2   := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)
									cChaveSe2 := IIf(!Empty(cForne), cNumSe2 + SE2->E2_FORNECE, cNumSe2)
									nPos 	  := 0
								Enddo
							EndIf
						Else
							nPos := 1
							lAchouTit := If(lAchouTit, lAchouTit, nRecnoSE2 > 0)
						EndIf

						lHelp := nPos == 0
					EndIf

					If !lUmHelp .And. lHelp
						if ! lExecJob
							Help(" ",1,"NOESPECIE",,cNumTit+	" "+cEspecie,5,1)
							lUmHelp := .T.
						Else
							Aadd(aMsgSch, STR0041+cEspecie+STR0042+cNumTit) // "Especie " # " nao localizada para o titulo "
						Endif

						//Atualiza o log de processamento com o erro
						ProcLogAtu("ERRO", "NOESPECIE", Ap5GetHelp("NOESPECIE"))
					Endif
				EndIf

				// Retorno Automatico via Job controla o status para emissao do relatorio de processamento
				If lExecJob .And. !lSchedule
					cStProc := ""
					
					If !lAchouTit .And. !lProcDDA
						cStProc := STR0019 // "Titulo Inexistente"
						Aadd(aFa205R, {cNumTit,"", "", dBaixa,	0, nValPgto, cStProc })
						Aadd(aMsgSch, STR0019 +": "+ cNumTit)
					Elseif lHelp
						cStProc := STR0020 // "Titulo com Erro"
					Endif
				Endif

				If !lHelp .Or. (lExecJob .And. !lUmHelp)
					lFound := .F.
					If lProcDDA
						lFound := SEB->(DbSeek(xFilial("SEB")+mv_par05+cOcorr+"D"))
					EndIf
					If !lProcDDA .Or. !lFound
						lFound := SEB->(DbSeek(xFilial("SEB")+mv_par05+cOcorr+"P"))
					EndIf

					If !lFound
						if !lExecJob
							Help(" ",1,"HPFA430OCORR", Nil, STR0025 + Alltrim(cOcorr) + STR0026 + Alltrim(mv_par05) + STR0027, 3, 1) //"Não existe o código da ocorrência informada: " ## " para o banco: " ## " - Cadastre a ocorrência no SEB."
						Else
							Aadd(aMsgSch, STR0043 + cOcorr + STR0044) // "Ocorrencia " # " nao localizada na tabela SEB."
						Endif

						//Atualiza o log de processamento com o erro
						ProcLogAtu("ERRO","FA430OCORR",Ap5GetHelp("FA430OCORR"))
					Endif

					//Reposicionar o SEB para uma chave diferente, que considere também, campos especificos criados no SEB
					If lFa430Oco
						ExecBlock("FA430OCO", .F., .F., {aValores})
					Endif

					lStatusTCB := _lExistTcb .and. SA6->A6_TCB == "1"
					lAgendado := .T.

					dbSelectArea("SE2")
					If SEB->EB_OCORR $ "01|06|07|08" //Baixa do Titulo
						lLanConPro := .T.
						cPadrao    := "532"

						If lFA430LP
							lTrocaLP:= ExecBlock("FA430LP",.F.,.F.)
						Endif

						If (lPagAnt := (SE2->E2_TIPO $ MVPAGANT))
							cPadrao    := "513"
							lLanConPro := lCtMovPA
						ElseIf !lTrocaLP
							cPadrao := "530"
						EndIf

						If cPadrao != cPadAux
							lPadrao := VerPadrao(cPadrao)
							cPadAux := cPadrao
						EndIf

						//Monta Contabilizacao
						If !lCabec .And. lPadrao .And. lContabiliza
							If nHdlPrv <= 0 
								nHdlPrv := HeadProva(cLote, "FINA430", substr( cUsuario, 7, 6 ), @cArquivo )
							EndIf
							lCabec  := .T.
						EndIf

						lAgendado   := .F.
						nValEstrang := SE2->E2_SALDO
						lDesconto   := .F.
						nTotAbat	:= SumAbatPag(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_FORNECE,SE2->E2_MOEDA,"S",dBaixa,SE2->E2_LOJA)
						ABATIMENTO  := nTotAbat
						lCtbMulNat 	:= lMultNat .And. SE2->E2_MULTNAT == "1"
						
						If lFValAcess
							nVA := FValAcess(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ,;
							.F., "", "P", dDataBase, Nil, SE2->E2_MOEDA, SE2->E2_MOEDA, SE2->E2_TXMOEDA, "", .F.)
						EndIf						
						
						//Ajusta tamanho suportado pelo campo de Autenticacao Bancÿria
						cAutentica	:= PadR(Alltrim(cAutentica), TamSx3("FK2_AUTBCO")[1])

						If !Empty(cCtaOfi) .and. !lAltPort
							cBanco		:= cBcoOfi
							cAgencia	:= cAgeOfi
							cConta		:= cCtaOfi
						ElseIf lAltPort
							SEA->(dbSetOrder(4) )
							SEA->(MsSeek( xFilial("SEA", SE2->E2_FILORIG) + SE2->( E2_NUMBOR+"P"+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA )))
							cBanco   := If(Empty(SEA->EA_PORTADO), cBanco, SEA->EA_PORTADO)
							cAgencia := If(Empty(SEA->EA_AGEDEP), cAgencia, SEA->EA_AGEDEP)
							cConta   := If(Empty(SEA->EA_NUMCON), cConta, SEA->EA_NUMCON)
						ElseIf Empty(cBanco+cAgencia+cConta)
							cBanco      := mv_par05
							cAgencia    := mv_par06
							cConta      := mv_par07
						Endif

						cHist070 := STR0008

						//Verifica se a despesa esta descontada do valor principal
						If SEE->EE_DESPCRD == "S"
							nValPgto += nDespes
						EndIF

						nTotAger += nValPgto
						cLanca   := Iif(lPadrao .And. lContabiliza .And. lLanConPro, "S", "N")
						cBenef   := SE2->E2_NOMFOR
						cTpDesc  := "I"

						//Ponto de Entrada para Tratamento baixa
						If lFA430LRM
							ExecBlock("FA430LRM",.F.,.F.,{xBuffer})
						Endif

						If __lPar13
							cTpDescSE5 := If( mv_par13 == 2 , "C" , "I")
							cTpDesc := cTpDescSE5  //Variável private utilizada na fa080grv()
						EndIf

						If SE2->E2_TIPO $ MVPAGANT+"|"+MVTXA
							DbSelectArea("SE5")
							SE5->(DbSetOrder(7))
							SE5->(DbGoTop())
							lAchouSE5 := SE5->(DbSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

							//Busca movimentação já existente para este PAGAMENTO ANTECIPADO
							If !lAchouSE5 .Or. (lAchouSE5 .And. SE5->E5_TIPODOC == "BA" .And. SE5->E5_MOTBX == "PCC" .And. SE2->(E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF) > 0)

								cCamposE5 := "{"
								cCamposE5 += " {'E5_DTDIGIT', dDataBase  }"
								cCamposE5 += ",{'E5_LOTE'	, '" + cLoteFin	 + "'}"
								cCamposE5 += ",{'E5_TIPO'	, '" + If(lPagAnt, MVPAGANT, MVTXA)	 + "'}"
								cCamposE5 += ",{'E5_BENEF'  , '" + RemoveAsp(Iif(Empty(cBenef), SA2->A2_NOME, cBenef))+"'   }"
								cCamposE5 += ",{'E5_PREFIXO', '" + SE2->E2_PREFIXO	+ "'}"
								cCamposE5 += ",{'E5_NUMERO'	, '" + SE2->E2_NUM		+ "'}"
								cCamposE5 += ",{'E5_PARCELA', '" + SE2->E2_PARCELA	+ "'}"
								cCamposE5 += ",{'E5_CLIFOR'	, '" + SE2->E2_FORNECE	+ "'}"
								cCamposE5 += ",{'E5_FORNECE', '" + SE2->E2_FORNECE	+ "'}"
								cCamposE5 += ",{'E5_LOJA'	, '" + SE2->E2_LOJA		+ "'}"
								
								IF !EMPTY(cTpDescSE5)
									cCamposE5 += ",{'E5_TPDESC'  , '"+ cTpDescSE5 +"'}"
								ENDIF
								
								IF !EMPTY(cAutentica)
									cCamposE5 += ",{'E5_AUTBCO'  , '"+ cAutentica +"'}"
								ENDIF
								
								cCamposE5 += ",{'E5_MOTBX',   'NOR'}"
								cCamposE5 += ",{'E5_ARQCNAB', '" + MV_PAR03 + "'}"
								cCamposE5 += "}"

								oModelMov := FWLoadModel("FINM030")					//Model de Movimento a Receber
								oModelMov:SetOperation( MODEL_OPERATION_INSERT )	//Inclusao
								oModelMov:Activate()
								oModelMov:SetValue( "MASTER", "E5_GRV"		,.T.		)	//Informa se vai gravar SE5 ou não
								oModelMov:SetValue( "MASTER", "NOVOPROC"	,.T.		)	//Informa que a inclusão será feita com um novo número de processo
								oModelMov:SetValue( "MASTER", "E5_CAMPOS"	,cCamposE5 )	//Informa os campos da SE5 que serão gravados indepentes de FK5
								oSubFK5 := oModelMov:GetModel("FK5DETAIL")
								oSubFKA := oModelMov:GetModel("FKADETAIL")
								oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
								oSubFKA:SetValue( "FKA_TABORI", "FK5" )

								cChaveTit := xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
								cIDDoc    := FINGRVFK7("SE2", cChaveTit)

								oSubFK5:SetValue( "FK5_ORIGEM"	, FunName() )
								oSubFK5:SetValue( "FK5_DATA"	, dBaixa )
								oSubFK5:SetValue( "FK5_VALOR"	, SE2->E2_VLCRUZ )
								oSubFK5:SetValue( "FK5_VLMOE2"	, SE2->E2_VALOR )
								oSubFK5:SetValue( "FK5_MOEDA"	, StrZero(SE2->E2_MOEDA,2))
								oSubFK5:SetValue( "FK5_NATURE"	, SE2->E2_NATUREZ	)
								oSubFK5:SetValue( "FK5_RECPAG"	, "P" )
								oSubFK5:SetValue( "FK5_TPDOC"	, If(lPagAnt,"PA","VL"))
								oSubFK5:SetValue( "FK5_HISTOR"	, SE2->E2_HIST )
								oSubFK5:SetValue( "FK5_BANCO"	, cBanco )
								oSubFK5:SetValue( "FK5_AGENCI"	, cAgencia )
								oSubFK5:SetValue( "FK5_CONTA"	, cConta )
								oSubFK5:SetValue( "FK5_DTDISP"	, dBaixa )
								oSubFK5:SetValue( "FK5_FILORI"	, SE2->E2_FILORIG )
								oSubFK5:SetValue( "FK5_IDDOC"   , cIDDoc )
								oSubFK5:SetValue( "FK5_LA"	    , Iif(cLanca == "S" .And. !lUsaFlag, "S", "N"))
								oSubFK5:SetValue( "FK5_CCUSTO"  , SE2->E2_CCUSTO)
								oSubFK5:SetValue( "FK5_DOC"     , SE2->E2_NUMBOR)

								If SpbInUse()
									oSubFK5:SetValue( "FK5_MODSPB"	, SE2->E2_MODSPB )
								Endif

								If SE2->E2_RATEIO == "S"
									oSubFK5:SetValue( "FK5_RATEIO",  "1" )
								Else
									oSubFK5:SetValue( "FK5_RATEIO",  "2" )
								EndIf

								If oModelMov:VldData()
									oModelMov:CommitData()        							
        							
									If __lGesplan// Integração Gesplan - Update somente para atualização do timestamp do titulo										
										FUpdStamp('SE2',SE2->(Recno()))										
									EndIF																		
									SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
								Else
									lRet := .F.
									cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
									cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
									cLog += cValToChar(oModelMov:GetErrorMessage()[6])
									Help( ,,"FA430GerPA",,cLog, 1, 0 )
								Endif

								oModelMov:DeActivate()
								oModelMov:Destroy()
								oModelMov := Nil
								oSubFK5   := Nil
								oSubFKA	:= Nil

								If lPadrao .And. cLanca == "S" .and. !lUsaFlag
									RecLock("SE2",.F.)
									SE2->E2_LA	:= "S"
									MsUnlock()
								EndIf

								If lUsaFlag // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, { "E5_LA", "S", "SE5", SE5->( RecNo() ), 0, 0, 0} )
									aAdd( aFlagCTB, { "E2_LA", "S", "SE2", SE2->( RecNo() ), 0, 0, 0} )
								EndIf

								If SE2->E2_TIPO $ MVTXA
									Reclock("SE2",.F.)
									SE2->E2_OK := 'TA'
									SE2->(MsUnlock())
								EndIf

								AtuSalBco(cBanco, cAgencia, cConta, SE5->E5_DTDISPO, SE5->E5_VALOR, "-")
								lBaixou  := .T.
								lMovAdto := .T.
							EndIf
						Else
							nTxMoeda := SE2->E2_TXMOEDA
							nMoeda   := SE2->E2_MOEDA
							nAcresc  := SE2->E2_SDACRES
							nDecresc := SE2->E2_SDDECRE
							
							If nMoeda != nMoedaBco .And. nMoeda > 0 .And. nMoedaBco > 0
								If lF430TXBX
									aTitulo  := {SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, dBaixa}
									aSE2     := SE2->(GetArea())
									nTxMoeda := ExecBlock("F430TXBX", .F., .F., aTitulo)

									RestArea(aSE2)
									FwFreeArray(aSE2)
									FwFreeArray(aTitulo)
								ElseIf nMoeda > 1 .And. (nTxMoeda <= 0 .Or. !Empty(SE2->E2_DTVARIA))
									nTxMoeda := RecMoeda(Iif(Empty(SE2->E2_DTVARIA), dBaixa, SE2->E2_DTVARIA), nMoeda)
								EndIf
								
								If (nAcresc+nDecresc) > 0
									nAcreDecre := IIf(nAcresc > 0, nAcresc, nDecresc)
									nAcresc := Round(xMoeda(nAcreDecre, nMoeda, nMoedaBco, dBaixa, nCasDec, nTxMoeda), 2)
									
									If nDecresc > 0
										nDecresc := nAcresc
										nAcresc := 0
									EndIf
								EndIf
								
								If nVA != 0
									nVA := xMoeda(nVA, nMoeda, nMoedaBco, dBaixa, nCasDec, nTxMoeda)
								EndIf							
							EndIf
							
							If nDescont > 0 // Valida se o banco retornou desconto no arquivo.
								nDescont := nDescont - nDecresc
							Endif

							If nJuros > 0 // Valida se o banco retornou o juros no arquivo.
								nJuros	:= nJuros - nAcresc
							Endif
							
							If !lMVCNBImpg .And. nMoeda > 1 .And. nMoedaBco > 0 .And. nMoeda != nMoedaBco
								nEstOrig := (nValPgto - (nJuros+nMulta+nAcresc)) + (nDescont+nDecresc) - Round(nVA, 2)
								
								//Converte para a moeda do titulo
								nEstOrig 	:= Round(xMoeda(nEstOrig, nMoedaBco, nMoeda, dBaixa, nCasDec, Nil, nTxMoeda) ,2)
								nValEstrang := Round(xMoeda(nValPgto, nMoedaBco, nMoeda, dBaixa, nCasDec, Nil, nTxMoeda) ,2)
								
								//calcula correção monetaria
								FA080CORR(nEstOrig, nTxMoeda)
							EndIf

							If lFA430BX
								lPermBx	:= Execblock("F430BXB", .F., .F., {cBanco, cAgencia, cConta})
								If !lPermBx
									lBaixou	:= .F.
									RollBackDelTran()									
								EndIf
							EndIf	

							lPermBx := (SE2->E2_SALDO > 0)

							If !lPermBx
								lBaixou := lPermBx
							EndIf

							If cPaisLoc == "BRA" .And. lPermBx
								If lMVCNBImpg 
									SA2->(DbSetOrder(1))
									SED->(DbSetOrder(1))
									SA2->(DbSeek(xFilial("SA2", SE2->E2_FILORIG)+SE2->(E2_FORNECE+E2_LOJA)))
									SED->(DbSeek(xFilial("SED", SE2->E2_FILORIG)+SE2->E2_NATUREZ))

									aTit        := {}
									lMsErroAuto := .F.
									lIRPFBaixa  := SA2->A2_CALCIRF == "2" .And. !SE2->E2_TIPO $ MVPAGANT .And. SED->ED_CALCIRF == "S"
									nOldValPgto	:= nValPgto
									nValPgto    := (nValPgto - (nJuros+nMulta)) + nDescont
									nValImp     := SE2->(E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF+E2_ISS+E2_INSS)
									nVlrCnab    := SE2->E2_VALOR - nTotAbat
									nVlrCnab	:= (nVlrCnab + SE2->E2_JUROS + SE2->E2_MULTA + nAcresc) - nDecresc + Round(nVA, 2)
									
									//IRRF
									If lIRPFBaixa .And. SE2->E2_IRRF > 0
										nVlrCnab -= SE2->E2_IRRF
									EndIf

									//PCC
									If lPCCBaixa .And. SE2->(E2_PIS+E2_COFINS+E2_CSLL) > 0
										nVlrCnab -= SE2->(E2_PIS+E2_COFINS+E2_CSLL)
									EndIf

									If nMoeda > 1 .And. nMoedaBco > 0 .And. nMoeda != nMoedaBco
										nOldValPgto := xMoeda(nOldValPgto, nMoedaBco, nMoeda, dBaixa, nCasDec, Nil, nTxMoeda)
										nValPgto    := xMoeda(nValPgto, nMoedaBco, nMoeda, dBaixa, nCasDec, Nil, nTxMoeda)
									EndIf

									nOldValPgto := Round(nOldValPgto, 2)
									nValPgto    := Round(nValPgto, 2)

									Do Case
										Case nOldValPgto == 0
											lRet := .F.
										Case nOldValPgto == nVlrcnab
											cTipoBx := "Baixa Total por CNAB"
										Case nOldValPgto - nValImp == nVlrcnab 		// Caso o cliente pague o valor bruto do t­tulo ao inv?s do l­quido
											cTipoBx := "Baixa Total por CNAB"
											nOldValPgto -= nValImp
										Case nOldValPgto + nValImp < nVlrcnab
												cTipoBx := "Baixa parcial por CNAB"
										Case nOldValPgto + nValImp > nVlrcnab
											cTipoBx := "Baixa Total a mais por CNAB"
											lVlrMaior	:= .T.
											nVlrMaior	:= nOldValPgto - nVlrcnab
									EndCase

									If lRet
										AADD(aTit, {"E2_FILIAL",    xFilial("SE2"),         Nil})
										AADD(aTit, {"E2_PREFIXO",   SE2->E2_PREFIXO,        Nil})
										AADD(aTit, {"E2_NUM",       SE2->E2_NUM,            Nil})
										AADD(aTit, {"E2_PARCELA",   SE2->E2_PARCELA,        Nil})
										AADD(aTit, {"E2_TIPO",      SE2->E2_TIPO,           Nil})
										AADD(aTit, {"E2_FORNECE",   SE2->E2_FORNECE,        Nil})
										AADD(aTit, {"E2_LOJA",      SE2->E2_LOJA,           Nil})
										AADD(aTit, {"AUTMOTBX",     cMotbx,                 Nil})
										AADD(aTit, {"AUTBANCO",     cBanco,                 Nil})
										AADD(aTit, {"AUTAGENCIA",   cAgencia,               Nil})
										AADD(aTit, {"AUTCONTA",     cConta,                 Nil})
										AADD(aTit, {"AUTDTBAIXA",   dBaixa,                 Nil})
										AADD(aTit, {"AUTDTDEB", 	dDebito,                Nil})
										AADD(aTit, {"AUTHIST",      cTipoBx,                Nil})
										AADD(aTit, {"AUTVLRPG",     (nValPgto - nVlrMaior), Nil})
										AADD(aTit, {"AUTJUROS",     nJuros,                 Nil})
										AADD(aTit, {"AUTDESCONT",   nDescont,               Nil})
										AADD(aTit, {"AUTMULTA",     nMulta,                 Nil})
										AADD(aTit, {"AUTACRESC",    nAcresc,                Nil})
										AADD(aTit, {"AUTDECRESC",   nDecresc,               Nil})
										AADD(aTit, {"AUTTXMOEDA",   nTxMoeda,               Nil})
										AADD(aTit, {"AUTVLRVA",     nVA,                    Nil})
										
										MSExecAuto({|x, y, a, b, c, d, e, f, g| FINA080(x, y, a, b, c, d, e, f, g)}, aTit, 3,,,,,,@aCtBaixa, cLanca)
										lBaixou := .T.

										If lMsErroAuto  
											If !IsBlind()
												MOSTRAERRO()
											EndIf
											lBaixou := .F.
											RollBackDelTran()
										EndIf
										If lExecJob  .and. !EMPTY(aParamB)  // Retorno Automatico via Job
											For nX := 1 To LEN(aParamB)
												If 'MV_PAR' $ UPPER(aParamB[nX,1])
													&(aParamB[nX,1]) := aParamB[nX,2]
												EndIf
											Next nX
										Else
											pergunte("AFI430",.F.)
										Endif
									Endif
								Else
									lBaixou  := fA080Grv(lPadrao, .F., .T., cLanca, mv_par03, nTxMoeda,,,lCtbMulNat,,,@aCtBaixa) // Retorno Automatico via Job
								Endif
							ElseIf lPermBx
								lBaixou  := fA080Grv(lPadrao,.F.,.T.,cLanca, mv_par03,,,,,,,@aCtBaixa) // Retorno Automatico via Job
							EndIf

							If lBaixou .And. lLanConPro .And. !Empty(aCtBaixa) .And. !lUsaFlag
								aAreaFK2 := FK2->(GetArea())
								aAreaFK5 := FK5->(GetArea())
								aAreaSE5 := SE5->(GetArea())

								For nX := 1 To Len(aCtBaixa)
									If aCtBaixa[nX, 1] == "FK2"
										dbSelectArea("FK2")
										FK2->(dbSetOrder(1))

										If FK2->(dbSeek( xFilial("FK2") + aCtBaixa[nX, 2]))
											RecLock("FK2",.F.)
											FK2->FK2_LA := "S"
											MsUnlock()
										EndIf
									ElseIf aCtBaixa[nX, 1] == "FK5"
										dbSelectArea("FK5")

										FK5->(dbSetOrder(1))
										If FK5->(dbSeek( xFilial("FK5") + aCtBaixa[nX, 2]))
											RecLock("FK5",.F.)
											FK5->FK5_LA := "S"
											MsUnlock()
										EndIf
									ElseIf aCtBaixa[nX, 1] == "SE5"
										dbSelectArea("SE5")
										DbGoTo(aCtBaixa[nX, 2])

										If SE5->(!BoF() .And. !EoF())
											RecLock("SE5",.F.)
											SE5->E5_LA := "S"
											MsUnlock()
										EndIf
									EndIf
								Next nX

								aCtBaixa := {}
								RestArea(aAreaFK2)
								RestArea(aAreaFK5)
								RestArea(aAreaSE5)
							EndIf
						EndIf

						// Retorno Automatico via Job armazena os dados do titulo para emissao de relatorio de processamento
						If lExecJob .And. !lSchedule
							If lBaixou
								Aadd(aFa205R, {SE2->E2_NUM,	SE2->E2_FORNECE,SE2->E2_LOJA,dBaixa,SE2->E2_VALOR, nValPgto, "Baixado ok"})
							Else
								Aadd(aFa205R, {SE2->E2_NUM,	SE2->E2_FORNECE,SE2->E2_LOJA,dBaixa,SE2->E2_VALOR, nValPgto, cStProc})
							Endif
						Endif

						If lBaixou .And. !lMovAdto //somente gera pro lote quando nao for PA para nao duplicar no Extrato
							dbSelectArea("TRB")

							If !TRB->(DbSeek(xFilial("SE5")+cBanco+cAgencia+cConta+Dtos(dDebito)))
								Reclock("TRB",.T.)
								TRB->FILMOV  := xFilial("SE5")
								TRB->BANCO   := cBanco
								TRB->AGENCIA := cAgencia
								TRB->CONTA   := cConta
								TRB->DATAD   := dDebito
								TRB->NATURE  := cNatLote
								TRB->MOEDA   := StrZero(nMoedaBco, 2)
								TRB->FILORI  := cFilAnt
							Else
								Reclock("TRB",.F.)
							Endif

							TRB->TOTAL += nValPgto
							TRB->(MsUnlock())
						Endif

						If lUsaFlag .and. lBaixou
							Aadd(aFlagCTB, {"E5_LA", "S", "SE5", SE5->( RecNo() ), 0, 0, 0} )
						EndIf

						If lF430Baixa
							Execblock("F430BXA",.F.,.F.)
						EndIf

						If lBaixou
							If lCtbMulNat
								MultNatB("SE2", .F., "1", @lOk, @aColsSEV, @lMultNat, .T.)

								If lOk
									MultNatC("SE2", @nHdlPrv, @nTotal, @cArquivo, (mv_par09 == 1), .T., "1", @nTotLtEZ, lOk, aColsSEV, lBaixou)
								Endif
							ElseIf lCabec .And. lPadrao .And. lContabiliza .And. lLanConPro
								nTotal += DetProva(nHdlPrv, cPadrao, "FINA430" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/,/*aDadosProva*/)
							Endif
						EndIf
					EndIf

					If SEB->EB_OCORR == "03" //Titulo Rejeitado

						lAgendado := .F.

						dbSelectArea("SE2")
						SE2->(DbSetOrder(11))

						If !SE2->(DbSeek(xFilial("SE2")+Substr(cNumTit, 1, nTamTit)))
							SE2->(DbSetOrder(1))
							SE2->(DbSeek(xFilial()+Pad(cNumTit,nTamTit)+cEspecie))
						Endif

						dbSelectArea("SEA")
						nIndice := 1

						If  lTemIndice .And. mv_par11 == 2 .And. !Empty(SE2->E2_FILORIG)
							nIndice := 4
							cChaveSEA := SE2->(E2_FILORIG+E2_NUMBOR)+"P"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
						Else
							cChaveSEA := xFilial("SEA")+SE2->(E2_NUMBOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
						EndIf

						SEA->(DbSetOrder(nIndice))
						If SEA->(DbSeek(cChaveSEA)) .And. SE2->E2_SALDO != 0
							//PONTO DE ENTRADA F430REJ - Tratamento de dados de titulo rejeitado antes de "zerar" os dados do mesmo
							If lF430Rej
								Execblock("F430REJ",.F.,.F.)
							EndIf

							SaveInter()
							FA590Canc(, , , , , ,@nTotal, @nHdlPrv)// Chamada Função FA590Canc para que o Título seja retirado corretamente do borderô Imp.
							If nTotal > 0  .And. nHdlPrv > 0 .And. !lLpCanc
								lCabec 	:= .T.
								lLpCanc	:= .T.
							EndIf
							RestInter()
						EndIf

					EndIf

					//DDA - Debito Direto Autorizado
					If lUsaDDA .And. lProcDDA .And. SEB->EB_OCORR $ "02" //Entrada de titulo via DDA

						lAgendado := .F.

						SA2->(DbSetOrder(3))

						If !lFA430FIG .Or. (lFA430FIG .And. !Empty(cCGC))
							SA2->(DbSeek(xFilial("SA2")+cCGC))
						EndIf

						If lFA430FIG //Ponto de entrada para permitir alteracoes no CGC antes de posicionar o fornecedor para gravacao de dados na tabela FIG
							cCodForn := SA2->A2_COD

							cQuery := "SELECT SE2.E2_PREFIXO,SE2.E2_NUM,SE2.E2_PARCELA,SE2.E2_FORNECE,SE2.E2_LOJA FROM " + RetSqlName("SE2") + " SE2 "
							cQuery += "WHERE SE2.E2_IDCNAB = '" + cNumTit + "' AND SE2.E2_FORNECE = '" + SA2->A2_COD + "' AND SE2.D_E_L_E_T_ = ' '"
							cQuery := ChangeQuery(cQuery)

							dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasTmp, .F., .T. )
							(cAliasTmp)->(DbGotop())
							cCGC := ExecBlock( "FA430FIG", .F., .F., { cCGC, cCodForn,(cAliasTmp)->E2_PREFIXO,cNumTit,(cAliasTmp)->E2_PARCELA})
							(cAliasTmp)->(DbCloseArea())

							If !Empty(cCGC)
								SA2->(DbSeek(xFilial("SA2")+cCGC))
							EndIf
						EndIf

						//Grava arquivo de conciliação DDA
						RecLock("FIG",.T.)
						FIG->FIG_FILIAL	:= xFilial("FIG")
						FIG->FIG_DATA	:= dDataBase
						FIG->FIG_FORNEC	:= SA2->A2_COD
						FIG->FIG_LOJA	:= SA2->A2_LOJA
						FIG->FIG_NOMFOR	:= SA2->A2_NREDUZ
						FIG->FIG_TITULO	:= cNumTit
						FIG->FIG_TIPO	:= cEspecie
						FIG->FIG_VENCTO	:= dBaixa
						FIG->FIG_VALOR	:= nValPgto
						FIG->FIG_CONCIL	:= "2"
						FIG->FIG_CNPJ	:= cCGC
						FIG->FIG_CODBAR	:= cCodBar
						FIG->(MsUnlock())

						//Ponto de entrada para gravar na tabela fig a filial pertecente ao cnpj da linha header contido do arquivo .ret
						If lF430GRAFIL
							aAreaCorr := GetArea()
							If lFirst 
								aAreaSM0 := SM0->(GetArea())
								lFirst	 := .F.
							EndIf
				
							DbSelectArea("SM0")
							SM0->(DbGoTop())

							While SM0->(!Eof()) .And. !Empty(cCGCFilHeader)
								If (cCGCFilHeader == SM0->M0_CGC)
									Exit
								EndIf
								SM0->( DbSkip() )
							EndDo

							ExecBlock( "F430GRAFIL", .F., .F., SM0->M0_CODFIL)
							RestArea(aAreaSM0)
							RestArea(aAreaCorr)							
						EndIf
					Endif

					If lStatusTCB // Monitoramento TCB
						If !lAgendado
							If Ascan(aBorderos,SE2->E2_NUMBOR) == 0
								Aadd(aBorderos, SE2->E2_NUMBOR)
								Aadd(aTCBStatus, "2")	//Processado
							EndIf
						Else
							//Se algum titulo nao foi processado, nao atualiza status
							nX := Ascan(aBorderos,SE2->E2_NUMBOR)
							If (nX := Ascan(aBorderos,SE2->E2_NUMBOR)) == 0 
								Aadd(aBorderos, SE2->E2_NUMBOR)
								Aadd(aTCBStatus, "0")	//Transmitido
							ElseIf aTCBStatus[nX] == "2"
								aTCBStatus[nX] := "0"
							EndIf
						EndIf
					EndIf

					//Integracao protheus X tin
					If lIntEAI080
						ALTERA := .T.
						INCLUI := .F.
						FwIntegDef( 'FINA080' )
					Endif
				EndIf

				nLidos += nBloco
			EndDo

			// Atualiza status do TCB
			If lBaixou .and. (nBorderos := Len(aBorderos)) > 0 .and. Len(aTCBStatus) == nBorderos
				DbSelectArea("FWO")
				FWO->(DbSetOrder(4))
				For nX := 1 to nBorderos
					If FWO->(DbSeek( xFilial("FWO")+aBorderos[nX] ))
						RecLock("FWO",.F.)
						FWO->FWO_STATUS := aTCBStatus[nX]
						FWO->(MsUnlock())
					EndIf
				Next nX
			EndIf

			cFilAnt := cFilOrig

			If ( lPadrao .Or. lLpCanc) .And. lContabiliza .And. lCabec
				dbSelectArea("SE2")
				SE2->(DbGoTo(0))
				SE5->(DbGoTo(0))
				FK2->(DbGoTo(0))

				VALOR      := nTotAger
				ABATIMENTO := 0
				nTotal     += DetProva( nHdlPrv, cPadrao, "FINA430" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )

				RodaProva(nHdlPrv, nTotal)

				//Envia para Lancamento Contabil
				cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, mv_par01 == 1, mv_par02 == 1, /*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, /*aDiario*/)
				aFlagCTB := {}
			EndIf

			//Ponto de entrada para renomear arquivo de retorno
			IF (ExistBlock("FA430REN"))
				FCLOSE(nHdlBco)
				ExecBlock("FA430REN",.f.,.f.)
			Endif

			// Atualiza os dados da multa pelo SIGAFIN, quando feito retorno pagamento.
			If FindFunction( "NGBAIXASE2" ) .And. GetNewPar( "MV_NGMNTFI","N" ) == 'S' //Se houver integração entre os módulos Manutenção de Ativos e Financeiro
				NGBAIXASE2(1)
			Endif

			//Grava no SEE o n£mero do £ltimo lote recebido e gera movimentacao bancaria
			If !Empty(cLoteFin) .and. lBxCnab
				If TRB->(Reccount()) > 0
					RecLock("SEE",.F.)
					SEE->EE_LOTECP := cLoteFin
					MsUnLock()

					dbSelectArea("TRB")
					dbGotop()

					While TRB->(!Eof())
						cFilAnt   := TRB->FILORI
						cCamposE5 := "{ {'E5_DTDIGIT', STOD('" + DTOS(TRB->DATAD) + "')}"
						cCamposE5 += ",{'E5_LOTE', '" + cLoteFin + "'} }"

						oModelMov := FWLoadModel("FINM030")							//Model de Movimento Bancário
						oModelMov:SetOperation( MODEL_OPERATION_INSERT )			//Inclusao
						oModelMov:Activate()										//Ativa o modelo de dados
						oModelMov:SetValue("MASTER","E5_GRV",   .T.)	//Informa se vai gravar SE5 ou não
						oModelMov:SetValue("MASTER","NOVOPROC", .T.)	//Informa que a inclusão será feita com um novo número de processo
						oModelMov:SetValue("MASTER","E5_CAMPOS", cCamposE5)	//Informa os campos da SE5 que serão gravados indepentes de FK5
						oSubFK5 := oModelMov:GetModel("FK5DETAIL")
						oSubFKA := oModelMov:GetModel("FKADETAIL")
						oSubFKA:SetValue("FKA_IDORIG", FWUUIDV4())
						oSubFKA:SetValue("FKA_TABORI", "FK5")

						//Informacoes do movimento
						oSubFK5:SetValue("FK5_ORIGEM", FunName())
						oSubFK5:SetValue("FK5_DATA",   If(!Empty(TRB->DATAD), TRB->DATAD, dBaixa))
						oSubFK5:SetValue("FK5_VALOR",  TRB->TOTAL)
						oSubFK5:SetValue("FK5_RECPAG", "P")
						oSubFK5:SetValue("FK5_BANCO",  TRB->BANCO)
						oSubFK5:SetValue("FK5_AGENCI", TRB->AGENCIA)
						oSubFK5:SetValue("FK5_CONTA",  TRB->CONTA)
						oSubFK5:SetValue("FK5_DTDISP", TRB->DATAD)
						oSubFK5:SetValue("FK5_HISTOR", STR0009 + " " + cLoteFin )
						oSubFK5:SetValue("FK5_MOEDA",  TRB->MOEDA)
						oSubFK5:SetValue("FK5_NATURE", TRB->NATURE)
						oSubFK5:SetValue("FK5_TPDOC",  "VL")
						oSubFK5:SetValue("FK5_FILORI", TRB->FILORI)
						oSubFK5:SetValue("FK5_LOTE",   cLoteFin)

						If SpbInUse()
							oSubFK5:SetValue( "FK5_MODSPB", "1")
						Endif

						If oModelMov:VldData()
							oModelMov:CommitData()
							SE5->(dbGoto(oModelMov:GetValue("MASTER", "E5_RECNO")))
						Else
							lRet := .F.
							cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
							cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
							cLog += cValToChar(oModelMov:GetErrorMessage()[6])
							Help( ,,"M030_FA430MOV",,cLog, 1, 0 )
						Endif

						oModelMov:DeActivate()
						oModelMov:Destroy()
						oModelMov := Nil
						oSubFK5 := Nil
						oSubFKA := Nil

						//Atualiza saldo bancario
						AtuSalBco(TRB->BANCO, TRB->AGENCIA, TRB->CONTA, SE5->E5_DATA, SE5->E5_VALOR, "-")
						TRB->(dbSkip())
					Enddo
				Endif
			EndIf
		End Transaction

		If(_oFina430 <> NIL)
			_oFina430:Delete()
			_oFina430 := NIL
		EndIf

		VALOR := 0
		dbSelectArea( cAlias )
		dbGoTo(nSavRecno)

		IF lF430COMP
			ExecBlock("F430COMP",.f.,.f.)
		EndIF
	EndIf

	cFilAnt := cFilOrig

Return .F.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fA430Par  ³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Aciona parametros do Programa                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fA430Par()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fA430Par()

Pergunte( "AFI430" )

MV_PAR03 := UPPER(MV_PAR03)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ChangDate ³ Autor ³ Wagner Xavier         ³ Data ³ 23/06/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Converte um string data para o formato ddmmaa de acordo com ³±±
±±³          ³um determionado tipo passado para a função.                 ³±±
±±³          ³Tipo 1 - ddmmaa                                             ³±±
±±³          ³Tipo 2 - mmddaa                                             ³±±
±±³          ³Tipo 3 . aammdd                                             ³±±
±±³          ³Tipo 4 - ddmmaaaa                                           ³±±
±±³          ³Tipo 5 - aaaammdd                                           ³±±
±±³          ³Tipo 6 - mmddaaaa                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ChangDate(__cData,nPosicao)
LOCAL nPosDia:=0,nPosMes:=0,nPosAno:=0
LOCAL aSubs  := {}

// posicao do dia,mes,ano,tamanho do ano;
AADD( aSubs,{ 01,03,05,2 } )
AADD( aSubs,{ 03,01,05,2 } )
AADD( aSubs,{ 05,03,01,2 } )
AADD( aSubs,{ 01,03,05,4 } )
AADD( aSubs,{ 07,05,01,4 } )
AADD( aSubs,{ 03,01,05,4 } )

If nPosicao == 0;nPosicao++;Endif

nPosDia := aSubs[nPosicao][1]
nPosMes := aSubs[nPosicao][2]
nPosAno := aSubs[nPosicao][3]

__cData := Substr(__cData,nPosDia,2)+Substr(__cData,nPosMes,2)+Substr(__cData,nPosAno,aSubs[nPosicao][4])

If Len(__cData) == 8
	__cData := Substr(__cData,1,4)+Substr(__cData,7,2)
Endif

Return(__cData)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³Chk430File³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 24/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Checa se arquivo de TB j  foi processado anteriormente	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³Chk430File()  											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³Fina430													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Chk430File()

	Local cFile 	:= "TB"+cNumEmp+".VRF"
	Local lRet		:= .F.
	Local aFiles	:= {}
	Local cString
	Local nTam
	Local nHdlFile
	Local l430Chkfile := ExistBlock("F430CHK")
	Local cKeyBloq	:= 'FIN430:' + cFile

	IF LOCKBYNAME(cKeyBloq,.T.,.F.)
		If l430ChkFile		// garantir que o arquivo nao seja reenviado
			Return Execblock("F430CHK",.F.,.F.)
		Endif

		If !FILE(cFile)
			nHdlFile := fCreate(cFile)
		ELSE
			// Tenta abrir o arquivo em modo de Leitura/Gravacao
			While ((nHdlFile := fOpen(cFile,FO_READWRITE+FO_EXCLUSIVE))==-1 .AND. ;
					if(ExecSchedule(),.T., MsgYesNo( STR0011+cNumEmp+STR0012, STR0010 )))
				Enddo
			Endif

			If nHdlFile > 0
				nTam := TamSx1("AFI430","03")[1] // Tamanho do parametro
				xBuffer := SPACE(nTam)

				// Le o arquivo e adiciona na matriz
				While fReadLn(nHdlFile,@xBuffer,nTam)
					Aadd(aFiles, Trim(xBuffer))
				Enddo

				If ASCAN(aFiles,Trim(MV_PAR03)) > 0
					If !lExecJob //Se estiver em modo Job nao apresenta a mensagem e sempre reprocessa
						Help(" ",1,"CHK200FILE")       // Arquivo de Trans.Banc. j  processado
						//Questiona o usuário se ele deseja efetuar um reprocessamento do arquivo
						If !MsgYesNo( STR0021, STR0010 )
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Atualiza o log de processamento com o erro  ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							ProcLogAtu("ERRO","CHK200FILE",Ap5GetHelp("CHK200FILE"))
						Else
							lRet := .T.
						EndIf
					Else
						lRet := .T.
					Endif
				Else
					fSeek(nHdlFile,0,2) // Posiciona no final do arquivo
					cString := Alltrim(mv_par03)+Chr(13)+Chr(10)
					fWrite(nHdlFile,cString)	// Grava nome do arquivo a ser processado
					lRet := .T.
				Endif
				fClose (nHdlFile)
			Else
				If ! lExecJob
					Help(" ", 1, "CHK200ERRO") // Erro na leitura do arquivo de entrada
				Else
					Aadd(aMsgSch, STR0045) // Erro na leitura do arquivo de entrada
				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento com o erro  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ProcLogAtu("ERRO","CHK200ERRO",Ap5GetHelp("CHK200ERRO"))
			EndIf

			UnLockByName(cKeyBloq,.T.,.F.)
		ELSE
			Help(" ", 1, "CHK200ERRO") // Erro na leitura do arquivo de entrada
		ENDIF

		Return lRet



/*/
		ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
		±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
		±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
		±±³Fun‡…o    ³ FAVerInd ³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 02/05/07 ³±±
		±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
		±±³Descri‡…o ³ Verifica existencia dos indices 19(SE1) e 13(SE2)          ³±±
		±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
		±±³Uso       ³ Generico                                                   ³±±
		±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
		±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
		ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FAVerInd()

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºRotina    ³Dv_BarCodeºAutor  ³Claudio D. de Souza º Data ³  14/12/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calcula o digito verificador de um codigo de barras padrao  º±±
±±º          ³Febraban.                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ CodBarVl2                                                  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function DV_BarCode( cBarCode )
	Local cDig
	Local nPos
	Local nAux := 0

	For nPos := 1 To 43
		nAux += Val(SubStr(cBarCode,nPos,1)) * If( nPos<= 3, ( 5-nPos),     ;
			If( nPos<=11, (13-nPos),     ;
				If( nPos<=19, (21-nPos),     ;
					If( nPos<=27, (29-nPos),     ;
						If( nPos<=35, (37-nPos),     ;
							(45-nPos) )))))
					Next
					nAux := nAux % 11
					cDig := If( (11-nAux)>9, 1, (11-nAux) )

					Return Str(cDig,1)

/*/
					±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
					±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
					±±³Fun‡…o    ³FinA430T   ³ Autor ³ Marcelo Celi Marques ³ Data ³ 15.05.08 ³±±
					±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
					±±³Descri‡…o ³ Chamada semi-automatica utilizado pelo gestor financeiro   ³±±
					±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
					±±³ Uso      ³ FINA430                                                    ³±±
					±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
					±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
					ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FinA430T(aParam)
	cRotinaExec := "FINA380"
	ReCreateBrow("SE2",FinWindow)
	FinA430()
	ReCreateBrow("SE2",FinWindow)
	dbSelectArea("SE2")

	INCLUI := .F.
	ALTERA := .F.

Return .T.



/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ExecSchedule³ Autor ³ Aldo Barbosa dos Santos      ³21/12/10³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Retorna se o programa esta sendo executado via schedule     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ExecSchedule()
Local lRetorno := .T.

lRetorno := IsBlind()

Return( lRetorno )

/*/
 {Protheus.doc} A460FSA2
 Aplicar Filtro na Tabela de Fornecedores (Campo reservado A2_MSBLQL)

 @author norbertom
 @since 02/02/2016
 @version 1.0
 @param nil
 @return nil
/*/
Static Function A460FSA2()
Local cFilter  := SA2->(dbFilter())
Local cFilBlq  := " !SA2->A2_MSBLQL == '1' "
Local aGetArea := GETAREA()

dbSelectArea("SA2")
If SA2->(FieldPos("A2_MSBLQL")) > 0
	If !'A2_MSBLQL' $ cFilter
		If !Empty(cFilter)
			cFilter += " .AND. "
		EndIf
		cFilter += cFilBlq
		SA2->(dbSetFilter({||&cFilter},cFilter))
	EndIf
EndIf

RESTAREA(aGetArea)
Return nil

//-------------------------------------
/*/{Protheus.doc}F430FilTit
Posiciona na filial de origem do título

@param cIdCnab, Identificador do título de retorno
@return nRecnoSE2, Recno do título a ser processado
@author Sivaldo Oliveira
@since  16/12/2019
@version 12
/*/
//-------------------------------------
Static Function F430FilTit(cIdCnab As Character) As Numeric
	Local nRecnoSE2 As Numeric
	Local lRet      As Logical

	//Inicializa variáveis
	nRecnoSE2 := 0
	lRet      := .F.

	Default cIdCnab := ""

	If !Empty(cIdCnab)
		SE2->(dbSetOrder(13))

		If !(lRet := SE2->(DbSeek(Substr(cIdCnab, 1, 10))) .And. !Empty(SE2->E2_FILORIG))
			SE2->(dbSetOrder(11))
			lRet := SE2->(DbSeek(xFilial("SE2") + Substr(cIdCnab, 1, 10))) .And. !Empty(SE2->E2_FILORIG)
		Endif

		If lRet
			If mv_par11 == 2 .And. !Empty(xFilial("SE2"))
				cFilAnt	  := SE2->E2_FILORIG
			EndIf

			nRecnoSE2 := SE2->(Recno())
		EndIf
	EndIf
Return nRecnoSE2

/*/{Protheus.doc} AjstIdCNAB
Ajusta ID CNAB caso o mesmo não possua zeros a esquerda, apenas 6 caracters.

@type  		Function
@since 		24/09/2021
@param 		cIdCNAB, character, id cnab
@return 	character, novo Id CNAB modificado com 0 a esquerda
/*/
Static Function AjstIdCNAB(cIdCNAB As Character) As Character

	Local cNovIdCNAB	As Character
	Local cSubIdCNAB	As Character
	Local cZero			As Character

	Local nLenIdCNAB	As Numeric
	Local nTamIdCNAB	As Numeric

	Default cIdCNAB		:= ""	

	cNovIdCNAB	:= ""
	cZero		:= ""
	nLenIdCNAB	:= Len(cSubIdCNAB := LTrim(cIdCNAB))
	nTamIdCNAB	:= TamSX3("E2_IDCNAB")[1]

	cZero := Replicate("0", nTamIdCNAB - nLenIdCNAB)

	cNovIdCNAB := cZero + cSubIdCNAB

Return cNovIdCNAB

/*/{Protheus.doc} SchedDef
Utilizado somente se a rotina for executada via Schedule.
Permite usar o botao Parametros da nova rotina de Schedule
para definir os parametros(SX1) que serao passados a rotina agendada.
@author  Fábio Henrique Andrade
@version 12.1.24
@since   09/04/2024
@return  aParam
/*/
Static Function SchedDef(  )
	Local aParam := {}

	aParam := {	"P"	,;	 //Tipo R para relatorio P para processo
	"AFI430",;	 //Nome do grupo de perguntas (SX1)
	Nil,;	 //cAlias (para Relatorio)
	Nil,;	 //aArray (para Relatorio)
	Nil   } //Titulo (para Relatorio)

Return aParam
