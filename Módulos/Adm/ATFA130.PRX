#INCLUDE "ATFA130.CH"
#Include "Protheus.ch"
#Define CONFIRMA 1
#Define REDIGITA 2
#Define ABANDONA 3


// 17/08/2009 - Ajuste para filiais com mais de 2 caracteres.

/*/

Ŀ
Funo     ATFA130     Autor  Vincius Barreira      Data  14/08/95 
Ĵ
Descrio  Alterao de cdigo de ativo                                 
Ĵ
Uso        SIGAATF                                                      
ٱ


*/
Function ATFA130

Private aPos		:= {  8,  4, 11, 74 }
//Ŀ
// Define Array contendo as Rotinas a executar do programa                   
// ----------- Elementos contidos por dimenso ------------                  
// 1. Nome a aparecer no cabealho                                           
// 2. Nome da Rotina associada                                               
// 3. Usado pela rotina                                                      
// 4. Tipo de Transao a ser efetuada                                       
//    1 - Pesquisa e Posiciona em um Banco de Dados                          
//    2 - Simplesmente Mostra os Campos                                      
//    3 - Inclui registros no Bancos de Dados                                
//    4 - Altera o registro corrente                                         
//    5 - Remove o registro corrente do Banco de Dados                       
//
Private aRotina 	:= MenuDef()

//Ŀ
// Define o cabealho da tela de atualizaes                                
//
Private cCadastro 	:= OemToAnsi(STR0004) //"Alterao de Cdigo" 

ATFXKERNEL()

//Ŀ
// Inicializa o log de processamento                            
//
ProcLogIni( {} )

//Ŀ
// Enderea a funo de BROWSE                                               
//
mBrowse( 6, 1,22,75,"SN1") 

Return
/*/

Ŀ
Funo     AF130Cod    Autor  Vincius Barreira      Data  14/08/95 
Ĵ
Descrio  Alterao de cdigos de ativos.                              
Ĵ
 Uso       SIGAATF                                                      
ٱ


*/
Function AF130Cod(cAlias,nReg,nOpc)

//Ŀ
// Define Variveis                                                          
//
Local oDlg
Local nOpt      := 0
Local cBasede   := SN1->N1_CBASE
Local cBasePara := CriaVar( "N1_CBASE" )
Local cItemde   := SN1->N1_ITEM
Local cItemAte  := ""
Local cItemIni  := CriaVar("N1_ITEM")

//Ŀ
// Localiza o ltimo registro e preenche a faixa de itens  
// abrangendo todos os tens daquele Bem.                  
// No foi criada a barra de status porque teoricamente    
// este processo deve ser bem rpido na grande maioria     
// dos casos.                                              
//
dbSelectArea("SN1")
While SN1->N1_FILIAL == xFilial("SN1") .and. SN1->N1_CBASE == cBaseDe .and. !Eof()
	cItemAte  := SN1->N1_ITEM
	dbSkip()
End

dbGoTo(nReg)
While .T.

	nOpt := 0
	DEFINE MSDIALOG oDlg FROM  88,1 TO 270,360 TITLE OemToAnsi(STR0008)  PIXEL // "Alterao dos Cdigos dos Bens"
	@ 03, 06 TO 85, 143 LABEL "" OF oDlg  PIXEL
	@ 13, 15 SAY OemToAnsi(STR0009) SIZE 61,07 OF oDlg PIXEL // "Cdigo Base Origem"
	@ 27, 15 SAY OemToAnsi(STR0010) SIZE 61,07 OF oDlg PIXEL // "Item Inicial"        
	@ 41, 15 SAY OemToAnsi(STR0011) SIZE 61,07 OF oDlg PIXEL // "Item Final"        
	@ 56, 15 SAY OemToAnsi(STR0012) SIZE 61,07 OF oDlg PIXEL //  "Novo Cdigo Base"   
	@ 69, 15 SAY OemToAnsi(STR0010) SIZE 61,07 OF oDlg PIXEL //  "Item Inicial"
	@ 11, 84 MSGET cBaseDe             SIZE 47,10 OF oDlg PIXEL When .F.
	@ 25, 84 MSGET cItemDe             SIZE 47,10 OF oDlg PIXEL When .F.
	@ 39, 84 MSGET cItemAte            SIZE 47,10 OF oDlg PIXEL Picture PesqPict("SN1","N1_ITEM" )  Valid Af130Item(cBaseDe,cItemDe,cItemAte)
	@ 54, 84 MSGET cBasePara           SIZE 47,10 OF oDlg PIXEL Picture PesqPict("SN1","N1_CBASE" ) Valid Af130Base(cBasePara,cBaseDe)
	@ 69, 84 MSGET cItemIni            SIZE 47,10 OF oDlg PIXEL Picture PesqPict("SN1","N1_CBASE" ) Valid !Empty(cItemIni)
	DEFINE SBUTTON FROM 05, 148 TYPE 1 ENABLE OF oDlg Action (nOpt:=1,IIF(AFA130OK(oDlg),oDlg:End(),nOpt:=0))
	DEFINE SBUTTON FROM 19, 148 TYPE 2 ENABLE OF oDlg Action (nOpt:=2,oDlg:End())
	DEFINE SBUTTON FROM 33, 148 TYPE 15 ENABLE OF oDlg Action ProcLogView()

	ACTIVATE MSDIALOG oDlg Centered
	If nOpt == 1
		If !af130base(cBasePara,cBaseDe)
			Loop
		EndIf	 
		//Ŀ
		// Variaveis para o log de processamento   
		//
		mv_par01 := cBaseDe
		mv_par02 := cItemDe 
		mv_par03 := cItemAte
		mv_par04 := cBasePara
		mv_par05 := cItemIni
		Processa({|lEnd| AF130PROC(cBaseDe,cItemDe,cItemAte,cBasePara,cItemIni)} )
	ElseIf nOpt == 0
		Loop
	Endif
	Exit    
EndDo

/*/

Ŀ
Funo     AF130PROC   Autor  Vincius Barreira      Data  05/01/96 
Ĵ
Descrio  Efetua a alterao dos cdigos e ativa gauge                 
Ĵ
 Uso       SIGAATF                                                      
ٱ


*/
   
Function AF130PROC(cBaseDe,cItemDe,cItemAte,cBasePara,cItemIni)
Local nPosAtuSN1 := 0
Local nPosProSN1 := 0
Local nPosAtuSN2 := 0
Local nPosProSN2 := 0
Local nPosAtuSN3 := 0
Local nPosProSN3 := 0
Local nPosAtuSN4 := 0
Local nPosProSN4 := 0
Local lUltSn1    := .F.
Local lUltSn2    := .F.
Local lUltSn3    := .F.
Local lUltSn4    := .F.
Local cChaveAtu  := ""
Local cCodResp	 :=""
Local lAf130Grv  := ExistBlock("AF130GRV")
Local cAliasQry  := GetNextAlias()
Local cQry		 := ""
Local __oQry

//Ŀ
// Configura a gauge    
//
ProcRegua( SN1->(Recc()),24,00 )
                     
//Ŀ
// Atualiza o log de processamento   
//
ProcLogAtu("INICIO")

//Ŀ
// Obter o cd. do Responsvel Ativo 
//

cQry := " SELECT ND.ND_CODRESP
cQry += " FROM ? ND
cQry += " WHERE ND.D_E_L_E_T_!='*' AND
cQry += " ND.ND_FILIAL = ? AND
cQry += " ND.ND_CBASE = ? AND
cQry += " ND.ND_ITEM = ? AND
cQry += " ND.ND_STATUS = '1'

cQry := ChangeQuery(cQry)
__oQry := FWPreparedStatement():New(cQry)

__oQry:SetNumeric(1,RetSqlName("SND"))
__oQry:SetString(2,xFilial('SND'))
__oQry:SetString(3,cBasede)
__oQry:SetString(4,cItemde)

cAliasQry := MPSYSOpenQuery(__oQry:GetFixQuery(),cAliasQry)

DbSelectArea(cAliasQry)

(cAliasQry)->ND_CODRESP
(cAliasQry)->(dbCloseArea())

Begin Transaction
//Ŀ
// Verifica se no existiro cdigos repetidos      
//
dbSelectArea("SN1")
dbSetOrder(1)
dbSeek( xFilial("SN1") + cBaseDe + cItemDe , .T.)
cChaveAtu   := SN1->N1_FILIAL+SN1->N1_CBASE+SN1->N1_ITEM
While SN1->N1_FILIAL == xFilial("SN1") .and. SN1->N1_CBASE == cBaseDe .And. !EOF()
	IncProc(24,00)
	//Ŀ
	// Verifico se e fim de arquivo                     
	//
	If lUltSn1
		Exit
	Endif
	//Ŀ
	// Meu cItemDe passa a ser o proximo N1_ITEM        
	//
	cItemDe := SN1->N1_ITEM

	If SN1->N1_ITEM <= cItemAte

		//Ŀ
		// Guardo o registro atual e o proximo              
		//
		nPosAtuSN1   := SN1->(RECNO())
		SN1->(dbSkip())
		
		If Eof()
			lUltSn1 := .T.
		Else
			//Ŀ
			// Qdo nao e o primeiro registro                    
			//
			If SN1->N1_FILIAL+SN1->N1_CBASE == Subst(cChaveAtu,1,Len( SN1->N1_FILIAL+SN1->N1_CBASE ))
				nPosProSn1  := SN1->(RECNO())
			Else
				lUltSn1 := .t.
			Endif
		Endif

		//Ŀ
		// Alteracao de Codigo no SN1             
		//
		While (dbSeek( xFilial("SN1") + cBasePara + cItemIni ))
			cItemIni := Soma1(cItemIni)
		EndDo
		
		SN1->(dbGoto(nPosAtuSn1))
		RecLock("SN1")
		SN1->N1_CBASE := cBasePara
		SN1->N1_ITEM  := cItemIni
		If lAf130Grv
			ExecBlock("AF130GRV",.F.,.F.,{"SN1"})
		Endif
		msUnlock()                     
		
		//Ŀ
		// Alteracao de Codigo no SND (BemXResp)
		//
		
		dbSelectArea( "SND" )	//Tabela de cadastro de Responsveis pelos bens
		SND->(dbSetOrder(2))
		If SND->( dbSeek( xFilial( "SND" ) + cBasede + cItemde + cCodResp +"1" ) )						
			While ( SND->(!Eof()) ) .And. ( SND->ND_CBASE == cBasede ) .And. ( SND->ND_ITEM  == cItemde ) .And. ( SND->ND_STATUS  == "1" )
				RecLock("SND",.F.)
				SND->ND_CBASE := cBasePara
				SND->ND_ITEM := cItemIni
				MsUnLock("SND")
				SND->(DbSkip())
			End
		EndIf	
				
		
		//Ŀ
		// Alteracao de Codigo no ST9 (Modulo MNT)
		//
		cBemMNT := SN1->N1_CODBEM
		
		If !Empty(cBemMNT)
			If (GetMv('MV_NGMNTAT') $ '1#3')
				dbSelectArea("ST9")
				dbSetOrder(01)
				If dbSeek(xFilial("ST9")+cBemMNT)
					RecLock("ST9",.F.)
					ST9->T9_CODIMOB := cBasePara+cItemIni
					MsUnLock("ST9")
				EndIf
			EndIf
		EndIf

		
		//Ŀ
		// Alteracao de Codigo no SN2             
		//
		dbSelectArea("SN2")
		dbSetOrder(1)
		If dbSeek(xFilial("SN2")+cBaseDe+cItemDe)
			While !Eof() .And. xFilial("SN2") == SN2->N2_FILIAL .And. (SN2->N2_CBASE+SN2->N2_ITEM == cBaseDe+cItemDe)

				If lUltSn2
					Exit
				EndIf

				nPosAtuSn2 := SN2->(Recno())
				SN2->(dbSkip())
				If Eof()
					lUltSn2 := .T.
				Else
					//Ŀ
					// Qdo nao e o primeiro registro                    
					//
					If SN2->N2_FILIAL+SN2->N2_CBASE == Subst(cChaveAtu,1,Len( SN2->N2_FILIAL+SN2->N2_CBASE ))
						nPosProSn2  := SN2->(RECNO())
					Else
						lUltSn2 := .t.
					Endif
				Endif

				SN2->(dbGoto(nPosAtuSn2))
				RecLock("SN2")
				SN2->N2_CBASE := cBasePara
				SN2->N2_ITEM  := cItemIni
				If lAf130Grv
					ExecBlock("AF130GRV",.F.,.F.,{"SN2"})
				Endif
				msUnlock()

				SN2->(dbGoto(nPosProSn2))
			EndDo
			lUltSn2    := .F.
			nPosAtuSn2 := 0
			nPosProSn2 := 0
		EndIf
		
		//Ŀ
		// Alteracao de Codigo no SN3             
		//
		dbSelectArea("SN3")
		dbSetOrder(1)
		If dbSeek(xFilial("SN3")+cBaseDe+cItemDe)
			While !Eof() .And. xFilial("SN3") == SN3->N3_FILIAL .And. (SN3->N3_CBASE+SN3->N3_ITEM == cBaseDe+cItemDe)

		   		If lUltSn3
					Exit
				EndIf

				nPosAtuSn3 := SN3->(Recno())
				SN3->(dbSkip())
				If Eof()
					lUltSn3 := .T.
				Else
					//Ŀ
					// Qdo nao e o primeiro registro                    
					//
					If SN3->N3_FILIAL+SN3->N3_CBASE == Subst(cChaveAtu,1,Len( SN3->N3_FILIAL+SN3->N3_CBASE ))
						nPosProSn3  := SN3->(RECNO())
					Else
						lUltSn3 := .t.
					Endif
				Endif

				SN3->(dbGoto(nPosAtuSn3)) 
				RecLock("SN3")
				SN3->N3_CBASE := cBasePara
				SN3->N3_ITEM  := cItemIni
				If lAf130Grv
					ExecBlock("AF130GRV",.F.,.F.,{"SN3"})
				Endif
				msUnlock()
			
			 	dbGoto(nPosProSn3)
			EndDo
			lUltSn3    := .F.
			nPosAtuSn3 := 0
			nPosProSn3 := 0
		EndIf

		//Ŀ
		// Alteracao de Codigo no SN4             
		//
		dbSelectArea("SN4")
		dbSetOrder(1)
		If dbSeek(xFilial("SN4")+cBaseDe+cItemDe)
			While !Eof() .And. xFilial("SN4") == SN4->N4_FILIAL .And. (SN4->N4_CBASE+SN4->N4_ITEM == cBaseDe+cItemDe)

				If lUltSn4
					Exit
				EndIf

				nPosAtuSn4 := SN4->(Recno())
				SN4->(dbSkip())
				If Eof()
					lUltSn4 := .T.
				Else
					//Ŀ
					// Qdo nao e o primeiro registro                    
					//
					If SN4->N4_FILIAL+SN4->N4_CBASE == Subst(cChaveAtu,1,Len(SN4->N4_FILIAL+SN4->N4_CBASE ))    
						nPosProSn4  := SN4->(RECNO())
					Else
						lUltSn4 := .t.
					Endif
				Endif
				SN4->(dbGoto(nPosAtuSn4))
				RecLock("SN4")
				SN4->N4_CBASE := cBasePara
				SN4->N4_ITEM  := cItemIni
				If lAf130Grv
					ExecBlock("AF130GRV",.F.,.F.,{"SN4"})
				Endif
				msUnlock()

				SN4->(dbGoto(nPosProSn4))
			EndDo
			lUltSn4    := .F.
			nPosAtuSn4 := 0
			nPosProSn4 := 0
		EndIf
		cItemIni := Soma1(cItemIni)
	Else
		Exit
	Endif
	dbSelectArea("SN1")
	SN1->(dbGoto(nPosProSN1))
EndDo

End Transaction

//Ŀ
// Atualiza o log de processamento   
//
ProcLogAtu("FIM")

Return

/*/


Ŀ
Funo    Af130Base  Autor  Vincius Barreira      Data  14/09/95 
Ĵ
Descrio  Verifica se o novo cdigo  vlido                         
Ĵ
Sintaxe    af130Base()                                                
Ĵ
Parametros                                                            
Ĵ
 Uso       SIGAATF                                                    
ٱ


*/
Function Af130Base(cBasePara,cBaseDe)
If Empty( cBasePara )
	HELP(" ",1,"AFA130Vazi")
	Return .F.
ElseIf cBasePara == cBaseDe
	HELP(" ",1,"AFA130Igua")
	Return .F.
Endif
Return .T.

/*/


Ŀ
Funo    Af130Item  Autor  Vincius Barreira      Data  14/09/95 
Ĵ
Descrio  Verifica se a faixa de trabalho existe                     
Ĵ
Sintaxe    af130Item()                                                
Ĵ
Parametros                                                            
Ĵ
 Uso       SIGAATF                                                    
ٱ


*/
Function Af130Item(cBaseDe,cItemDe,cItemAte)
Local cOldArea := Alias()

If Empty( cItemAte  )
	HELP(" ",1,"AFA130Vazi")
	Return .F.
ElseIf cItemAte  < cItemDe
	HELP(" ",1,"AFA130Meno")
	Return .F.
Endif

DbSelectArea("SN1")
dbSetOrder(1)
If !dbSeek(xFilial("SN1") + cBaseDe + cItemAte )
	HELP(" ",1,"AFA130Item")    // Este Item Final nao existe
	dbSelectArea(cOldArea)
	Return .F.
Endif

dbSelectArea(cOldArea)

Return .T.

/*/


Ŀ
Programa  MenuDef    Autor  Ana Paula N. Silva      Data 10/12/06 
Ĵ
Descrio  Utilizacao de menu Funcional                               
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados     
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/
Static Function MenuDef()
Local aRotina := { 	{ OemToAnsi(STR0001), "AxPesqui"  		 , 0 , 1 },; // "Pesquisar"
                     	{ OemToAnsi(STR0002), "VIEWDEF.ATFA012 ", 0 , 2 },; // "Visualizar" 
                     	{ OemToAnsi(STR0003), "AF130Cod"  		 , 0 , 4 } } // "Alt.Codigo"
Return(aRotina)                     	

/*/


Ŀ
Funo     AFA130OK  Autor  Pedro Pereira Lima     Data  04/04/08 
Ĵ
Descrio  verifica todos os valids da oDlg.                          
Ĵ
Sintaxe    AFA130OK()                                                 
Ĵ
ParametrosoDlg                                                        
Ĵ
 Uso       SIGAATF                                                    
ٱ


*/
Function AFA130OK(oDlg)
Local nI
Local lRet := .T.

For nI := 1 To Len(oDlg:aControls)
	If ValType(oDlg:aControls[nI]) == "O" .And. !Empty(oDlg:aControls[nI]:bValid)//Verifico se e tipo valid
		lRet := Eval(oDlg:aControls[nI]:bValid)
		If ValType(lRet) != "L" //Forco a variavel se o retorno nao e tipo logico
			lRet := .T.
		EndIf
		If !lRet
			oDlg:aControls[nI]:SetFocus() //Seto o foco no controle cujo valid igual .F.
			Exit
		EndIf
	EndIf
Next

Return lRet
