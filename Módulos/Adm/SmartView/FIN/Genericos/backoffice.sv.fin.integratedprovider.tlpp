#include "totvs.ch"
#include "msobject.ch"
#include "tlpp-rest.th"
#include "tlpp-core.th"
#include "totvs.framework.treports.integratedprovider.th"
#include 'fwlibversion.ch'
#include 'backoffice.sv.fin.integratedprovider.ch'

namespace totvs.protheus.backoffice.fin.smartView.integratedProvider
//-------------------------------------------------------------------
/*/{Protheus.doc} FinIntegratedProvider
    Classe de Integrated Provider que incorpora as principais soluções do Financeiro. 
    Será a Super classe dos objetos de negócio do módulo.
    @author guilherme.sordi@totvs.com.br
    @since 31/08/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
class FinIntegratedProvider from totvs.framework.treports.integratedprovider.IntegratedProvider
    public method new() as object
    public method isEnvironmentOK() as logical
    public method getData() as object
    public method getSchema() as object

    protected data oStatement as object
    protected data cLifeTime as character
    protected data cTimeout as character
    protected data cAlias as character
    protected data aStruct as array
    protected data jData as json
    protected data oLGPD as object
    protected data cSelectComplement as character
    protected data cWhereComplement as character
    protected data nDecimals as numeric
    protected data nCurrentPage as numeric
    protected data oCurrentFilter as object
    protected data oFilterBranches as object
    protected data lEnableAllTrim as logical
    protected data lEnableCompleteData as logical
    protected data lEmptyMultiBranches as logical 
    private data cFieldsToCompleteData as character
    private data lAllowSmartViewFilter as logical
    private data lAppendInMyAliasToData as logical

    protected data cSX1Group as character
    protected data cMinimumLibLabel as character
    protected data lPergunteOK as logical
    protected data lLibOK as logical

    protected data cSelectCustomFieldsPay as character
    protected data cSelectCustomFieldsRec as character
    protected data cGroupByCustomFieldsPay as character
    protected data cGroupByCustomFieldsRec as character

    protected data lAllowBranchFilter as logical
    protected data lMultSelectBranches as logical
    protected data cFromBranch as character
    protected data cToBranch as character
    protected data aMultiBranches as array
    protected data lShowBranchName as logical
    protected data jBranchNames as json

    protected data cMainTable as character
    protected data cMainBranchField as character
    protected data cMainAlias as character
    protected data aMainTableSelectedBranches as array

    protected method setPergunte() as logical
    protected method setMVPAR()
    protected method setFilter()
    protected method setPage()
    protected method loadDefaultParameters()
    protected method loadParameters()
    protected method finAddProperty()
    protected method mySetSchema()
    protected method setLookups()
    protected method loadStatement()
    protected method getQuery() as character //deprecated - Use LoadStatement

    protected method setErrorInvalidPergunte()
    protected method setErrorInvalidLib()
    protected method validEnvironment() as logical

    protected method handleSchema()
    protected method handleData()

    protected method preOpenQuery()
    protected method preAppendData()
    protected method preWhileMyAliasToData()
    protected method posPositionAlias()

    protected method postCloseQuery()
    protected method postAppendData()
    protected method postWhileMyAliasToData()    

	protected method myAliasToData()
    protected method processAndAppend()
    protected method addToData()
    protected method addBranchNameToData()
    protected method completeData()
    protected method setCompleteData()
    protected method setFieldsToCompleteData()
    protected method getFieldsToCompleteData() as character
    protected method setAllTrim()
    protected method varToTimeStamp() as variant
    protected method getFilterToSQL() as character
    protected method getAllFieldsToSQL() as character
    protected method addFieldsToStruct()
    protected method clearStruct()
    protected method cToA() as array
    private method notAllowSmartViewFilter()
    protected method setAllowSmartViewFilter()
    protected method setAppendInMyAliastoData()
    protected method myProcessData()
    protected method aliasToSimpleArray(cAlias as character, cFieldName as character) as array
    protected method aliasToJsonArray(cAlias as character, aFields as array) as array
    
    protected method addLGPDCalcField()
    protected method loadLGPDFields()

    protected method processCustomFields()
    private method processCustomFieldsDefault()
    protected method getCustomFieldsToSQL() as character
    protected method loadCustomFieldsPayAndRec(cQuery as character)    
    protected method fieldExistsInDefaultSchema() as logical

    protected method getCustomFieldsRecToSelect() as character
    protected method getCustomFieldsPayToSelect() as character
    protected method getCustomFieldsRecToGroupBy() as character
    protected method getCustomFieldsPayToGroupBy() as character
    protected method setValueMVPAR()

    protected method setBranchPar(oJsonMvPar as json)
    protected method setAllowFilterByBranch() //deprecated - Use setBranchFilter
    protected method setBranchFilter(lAllowBranchFilter as logical, lMultSelect as logical)

    protected method loadFilterBranches()
    protected method getAliasBranchFilter() as array
    protected method loadBranchNames()
    protected method removeTrimFromBranchFilter()

    protected method loadMainTableSelectedBranches()
    protected method setMainTable(cTable as character, cMainBranchField as character, cSQLAlias as character) 
    protected method getSQLBranchFilter() as character
    protected method setStatementBranchFilter(nParamOrder as numeric)

    static method transformCGC() as character
    static method commaAtBeginning() as character

endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} new
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method new() as object class FinIntegratedProvider
    _Super:new()

    self:setPageSize(200)

    self:appendArea(STR0001) //"Financeiro"
    self:loadDefaultParameters()

    self:cLifeTime := alltrim(str(superGetMv('MV_FINSVLT', .F., 300)))
    self:cTimeout := "120"
    self:cAlias := ""
    self:aStruct := {}
    self:jData := JSONObject():new()
    self:oLGPD := SmartViewFinLGPD():New()    
    self:cSelectComplement := ""
    self:cWhereComplement := ""
    self:nDecimals := TamSx3("M2_MOEDA2")[2] +1
    self:lEnableAllTrim := .T.
    self:lEnableCompleteData := .F.
    self:cFieldsToCompleteData := ""
    self:nCurrentPage := 1
    self:lAllowSmartViewFilter := .T.
    self:lAppendInMyAliasToData := .T.

    self:cMinimumLibLabel := "20230918"
    self:lLibOK := FwLibVersion() >= self:cMinimumLibLabel

    self:cSelectCustomFieldsPay := ""
    self:cSelectCustomFieldsRec := ""

    self:lMultSelectBranches := .F.
    self:lAllowBranchFilter := .F.
    self:lEmptyMultiBranches := .F.
    self:lShowBranchName    := .F.    
    self:cMainTable := ""
    self:cMainBranchField := ""
    self:cMainAlias := ""
    self:aMainTableSelectedBranches := {}
    
return self

//-------------------------------------------------------------------
/*/{Protheus.doc} setPergunte
    Utiliza polimorfismo para guardar o grupo de perguntas que o 
    objeto de negócio tentou usar, e guardar o resultado do setPergunte original, 
    sendo usado depois na validEnvironment.
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method setPergunte(cPergunte as character) as logical class FinIntegratedProvider
    self:cSX1Group := cPergunte
    self:lPergunteOK := _Super:setPergunte(cPergunte)

return self:lPergunteOK

//-------------------------------------------------------------------
/*/{Protheus.doc} setErrorInvalidPergunte
    Retorna ao usuário uma notificação de erro ao tentar usar o 
    grupo de perguntas, garantindo que não haja erros caso o 
    pacote de dicionário não tenha sido aplicado no ambiente.
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method setErrorInvalidPergunte() class FinIntegratedProvider
    if self:lLibOK
        self:setErrorStatus(400, STR0002, STR0003 + self:cSX1Group ) //"Sem grupo de perguntas", "Grupo de perguntas não encontrado: "
    endIf
    FwLogMsg("WARN",, STR0004,,, , STR0003 + self:cSX1Group , , ,)  //"Smart View"
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setErrorInvalidLib
    Retorna ao usuário uma notificação de erro caso o ambiente não esteja com
    a lib atualizada para a última versão homologada do Smart View no Financeiro.
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method setErrorInvalidLib() class FinIntegratedProvider
    if !self:lLibOK
        self:setErrorStatus(400, STR0005, STR0006 + self:cMinimumLibLabel) //"Versão de Lib inválida", "Necessário Lib Label igual ou superior a "
    endIf
    FwLogMsg("WARN",, STR0005,,, , STR0006 + self:cMinimumLibLabel , , ,)  //"Versão de Lib inválida", "Necessário Lib Label igual ou superior a " 
return

//-------------------------------------------------------------------
/*/{Protheus.doc} validEnvironment
    Valida o ambiente, apresentando a notificação adequada ao usuário
    e dando um retorno ao objeto de négócio, para que não tente prosseguir
    com a execução (normalmente do getData()).
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method validEnvironment() as logical class FinIntegratedProvider
    local lEnvironmentOK := self:lLibOK .and. self:lPergunteOK

    if !self:lLibOK 
        self:setErrorInvalidLib()
    endIf

    if !self:lPergunteOK
        self:setErrorInvalidPergunte()
    endIf

return lEnvironmentOK

//-------------------------------------------------------------------
/*/{Protheus.doc} handleData
    Permite manipular o jData antes do append, criado pelo Financeiro,
    para extensão dos objetos de negócio.
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method handleData() class FinIntegratedProvider

return 

//-------------------------------------------------------------------
/*/{Protheus.doc} handleSchema
    Permite adicionar novas colunas ao esquema, criado pelo Financeiro,
    para extensão dos objetos de negócio.
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method handleSchema() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} setMVPAR
    Atualiza as variáveis públicas MV_PAR de acordo com os parâmetros
    informados pelo usuário na interface do Smart View.
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method setMVPAR(oFilter as object) class FinIntegratedProvider    
    default oFilter := self:oCurrentFilter

    if oFilter == NIL
        return
    endIf

    self:setValueMVPAR(oFilter:getParameters(), self:cPergunte)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} processAndAppend
    Faz o processamento dos dados do JData e o append no objeto oData.
    Chama os métodos responsáveis pelo complemento dos dados no MI,
    no objeto extendido do financeiro, o ofuscamento de dados protegidos/sendiveis
    conforme LGPD e qualquer outro tratamento que deve ser feito nos dados,
    antes de entregar para a classe do Framework montar o JSON que será entregue
    ao Smart View.
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method processAndAppend() class FinIntegratedProvider
    self:handleData() //Manipula jData antes do append, criado pelo Financeiro para extensão do objeto de negócio
    self:processData() //Manipula jData antes do append, criado pelo Framework para uso do MI
    self:processCustomFields() //Manipula jData antes do append, incluindo o conteúdo dos campos personalizados

    self:addBranchNameToData()
    
    if self:lEnableCompleteData
        self:completeData() //Completa o jData com campos do schema que ainda não foram preenchidos no jData
    endIf

    self:jData := self:oLGPD:handleDataWithLGPD(self:jData)
    
    self:preAppendData() //Manipula jData imediatamente antes do append
    self:oData:appendData(self:jData)
    self:postAppendData()
return

//-------------------------------------------------------------------
/*/{Protheus.doc} varToTimeStamp
    Chama a função do frame que faz o tratamento de campos tipo data
    para o formato adequado à API. Campos vazios devem preencher com NULO 
    o JSON do getData().
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method varToTimeStamp(xDate as variant) as variant class FinIntegratedProvider
    if valType(xDate) == "D"
        return totvs.framework.treports.date.dateToTimeStamp( xDate )
    elseIf valType(xDate) == "C"
        return totvs.framework.treports.date.stringToTimeStamp( xDate )
    endIf
return

//-------------------------------------------------------------------
/*/{Protheus.doc} loadLGPDFields
    Usa os campos do esquema para analisar quais campos serão ofuscados
    no objeto de negócio, dependendo do usuário ativo.
    Os campos calculados, adicionados pelo método addLGPDCalcFields também
    serão analisados aqui.
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method loadLGPDFields() class FinIntegratedProvider
    self:oLGPD:loadFields(self:oSchema:getProperties())
return

//-------------------------------------------------------------------
/*/{Protheus.doc} addLGPDCalcField
    Adiciona campos calculados à classe de tratamento LGPD, pois esses
    campos precisam ser vinculados a algum campo do dicionário de dados
    para que o sistema saiba se deve ofuscar ou não.
    @author guilherme.sordi@totvs.com.br
    @since 01/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method addLGPDCalcField(cCalcFieldName as character, cRealName as character) class FinIntegratedProvider
    self:oLGPD:addCalcField(cCalcFieldName, cRealName)
return


/*/{Protheus.doc} transformCGC()
    Para Brasil, aplica máscara de CPF ou CNPJ conforme tamanho do conteúdo. Para outros países segue picture do dicionário de dados.
    @author guilherme.sordi@totvs.com.br
    @since 04/07/2023
    @version 12.1.2210
/*/
method transformCGC(cValue as character, cField as character) as character class FinIntegratedProvider
	Local cMask	:= "" as character
	Local cRet := "" as character
	
	default cField := "A1_CGC"

	if Empty(cValue)
		return cValue
	endIf

	if cPaisLoc == "BRA"
		If Len(Alltrim(cValue)) > 11
			cMask := '@!R NN.NNN.NNN/NNNN-99'
		Else
			cMask := '@R 999.999.999-99'
		Endif
	else 
		cMask := X3Picture(cField)
	endIf
	
	cRet := TransForm(cValue, cMask)

return cRet


/*/{Protheus.doc} setValueMVPAR()
    Seta os valores para os MV_PAR publicas.
    @author Francisco Oliveira
    @since 20/04/2023
    @version 1.0
    @return Nil
/*/
method setValueMVPAR(oJsonMvPar As Json, cPergunte as Character) class FinIntegratedProvider

	Local nY	:= 0  As Numeric
	Local oJson := oJsonMvPar:GetNames() As Json
	Local nJson	:= Len(oJson) As Numeric
	Local cTipoPar := "" as Character

	//Carrega os MV_PAR para a memória
	Pergunte(cPergunte,.F.)

	//Popula com os novos valores
	For nY := 1 To nJson
        if subStr(UPPER(oJson[nY]),1,6) == 'MV_PAR'
            cTipoPar := VALTYPE(&( UPPER( oJson[nY] ) ))

            If cTipoPar == "D" 
                If !Empty(oJsonMvPar[ oJson[nY] ][1])
                    &( UPPER( oJson[nY] ) ) := StoD( SubStr(StrTran(oJsonMvPar[ oJson[nY] ][1],"-",""),1,8) )
                Else
                    &( UPPER( oJson[nY] ) ) := StoD("") 
                EndIf
            ElseIf cTipoPar == "N"
                If VALTYPE(oJsonMvPar[ oJson[nY] ][1]) == "C"
                    &( UPPER( oJson[nY] ) ) := VAL(oJsonMvPar[ oJson[nY] ][1])
                Else
                    &( UPPER( oJson[nY] ) ) := oJsonMvPar[ oJson[nY] ][1]
                EndIf
            ElseIf cTipoPar == "C"
                &( UPPER( oJson[nY] ) ) := oJsonMvPar[ oJson[nY] ][1]
            ElseIf cTipoPar == "L"
                If(oJsonMvPar[ oJson[nY] ][1] == "true")
                    &( UPPER( oJson[nY] ) ) := .T.
                Else
                    &( UPPER( oJson[nY] ) ) := .F.
                EndIf
            EndIf
        endIf
	Next nY

    if self:lAllowBranchFilter
        self:setBranchPar(oJsonMvPar)
    endIf

Return



//-------------------------------------------------------------------
/*/{Protheus.doc} isEnvironmentOK
    Valida o ambiente antes de tentar gerar algum relatório.
    @author guilherme.sordi@totvs.com.br
    @since 04/09/2023
    @version 12.1.2210
*/
//-------------------------------------------------------------------
method isEnvironmentOK() as logical class FinIntegratedProvider
return self:lLibOK .and. self:lPergunteOK


//-------------------------------------------------------------------
/*/{Protheus.doc} processCustomFields
    Complementa o JSON jData com o conteúdo dos campos personalizados.
    @author guilherme.sordi@totvs.com.br
    @since 19/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method processCustomFields() class FinIntegratedProvider
    self:processCustomFieldsDefault()
return

//-------------------------------------------------------------------
/*/{Protheus.doc} getCustomFieldsToSQL
    Retorna string de personalização de campos pronta para ser adicionada à query.
    @author guilherme.sordi@totvs.com.br
    @since 20/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getCustomFieldsToSQL() as character class FinIntegratedProvider
    local cCustomFields := "" as character
    local lContactTableName := .T. as logical
    local aTables := NIL
    local lOnlyCustomFields := .T. as logical

    cCustomFields := self:getSQLFields(lContactTableName, aTables, lOnlyCustomFields)
    if !Empty(cCustomFields)
        cCustomFields := ", " + cCustomFields
    endIf
return cCustomFields

/*/{Protheus.doc} loadCustomFieldsPayAndRec
    Esse método substitui o getCustomFieldsToSQL() em cenários onde a consulta
    é feita tanto no contas a pagar quanto no contas a receber. Em vez de retornar 
    uma string com a lista de campos apra complementar a cláusula Where, esse método
    preenche as propriedades cSelectCustomFieldsPay e cSelectCustomFieldsRec, complementando
    a consulta do contas a pagar e do contas a receber separadamente.
    Esse complementos podem ser usados uma query com Union, porque apresentam os mesmos campos,
    na mesma ordem e sem repetir.

    @author guilherme.sordi@totvs.com.br
    @since 18/10/2023
    @version 12.1.2210
*/
method loadCustomFieldsPayAndRec(cQuery as character) class FinIntegratedProvider    
    local aCustomFields := {} as array
    local nX := 0 as numeric
    local aArea := getArea()

    local cField := "" as character
    local cType := "" as character
    local cTable := "" as character
    local cMirrorTable := "" as character
    local cMirrorField := "" as character
    local lPay := .F. as logical
    local lMirrorFieldExists := .F. as logical

    local cPayTable := "" as character
    local cPayField := "" as character
    local lPayFieldExists := .F. as logical          
    local cRecTable := "" as character
    local cRecField := "" as character
    local lRecFieldExists := .F. as logical

    default cQuery := ""
    
    self:cSelectCustomFieldsPay := ""
    self:cSelectCustomFieldsRec := ""

    jMirrorTable := JsonObject():New()
    jMirrorTable := { "FK1": "FK2", "FK2": "FK1", "SE1": "SE2", "SE2": "SE1", "SA1": "SA2", "SA2": "SA1"}

    aCustomFields := self:getCustomFields()

    for nX := 1 to len(aCustomFields)

        cField := aCustomFields[nX][1]
        cType := aCustomFields[nX][3]
        cTable := aCustomFields[nX][5]

        If !jMirrorTable:hasproperty(cTable)
            jMirrorTable[cTable] := cTable
        EndIf

        cMirrorTable := jMirrorTable[cTable]
        cMirrorField := replace(cField, subStr(cTable, 2, 2), subStr(cMirrorTable, 2, 2))
        lPay := cTable $ "FK2,SE2,SA2"

        dbSelectArea(cMirrorTable)
        lMirrorFieldExists := FieldPos(cMirrorField) > 0
   
        if lPay
            cPayTable := cTable
            cPayField := cField
            lPayFieldExists := .T.
            
            cRecTable := cMirrorTable
            cRecField := cMirrorField
            lRecFieldExists := lMirrorFieldExists
        else
            cPayTable := cMirrorTable
            cPayField := cMirrorField
            lPayFieldExists := lMirrorFieldExists
            
            cRecTable := cTable
            cRecField := cField
            lRecFieldExists := .T.
        endIf     

        if !(cPayField $ self:cSelectCustomFieldsPay) .and. !self:fieldExistsInDefaultSchema(cPayField) .and. !self:fieldExistsInDefaultSchema(cRecField)
            if lPayFieldExists
                if !(cPayField $ cQuery)
                    self:cSelectCustomFieldsPay += cPayTable + "." + cPayField + " " + cField + ", "
                    self:cGroupByCustomFieldsPay += cPayTable + "." + cPayField + ", "
                endIf
            else
                self:cSelectCustomFieldsPay += "NULL " + cField + ", "
            endIf
            
            if lRecFieldExists
                if !(cRecField $ cQuery)
                    self:cSelectCustomFieldsRec += cRecTable + "." + cRecField + " " + cField + ", "
                    self:cGroupByCustomFieldsRec += cRecTable + "." + cRecField + ", "
                endIf
            else
                self:cSelectCustomFieldsRec += "NULL " + cField + ", "
            endIf

        endIf
    next nX

    restArea(aArea)

    FwFreeArray(aArea)
    FwFreeArray(aCustomFields)

return 

//-------------------------------------------------------------------
/*/{Protheus.doc} getCustomFieldsRecToSelect
    Retorna os campos personalizados da carteira Receber para concatenar no Select quando é multi-carteiras
    @author fabioh.andrade@totvs.com.br
    @since 23/01/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getCustomFieldsRecToSelect(lApplyCommaAtBeginning as logical) as character class FinIntegratedProvider
    local cCustomFieldsSQL := self:cSelectCustomFieldsRec as character

    default lApplyCommaAtBeginning := .T.
    
    if lApplyCommaAtBeginning
        cCustomFieldsSQL := self:commaAtBeginning(cCustomFieldsSQL)
    endIf

return cCustomFieldsSQL

//-------------------------------------------------------------------
/*/{Protheus.doc} getCustomFieldsPayToSelect
    Retorna os campos personalizados da carteira Pagar para concatenar no Select quando é multi-carteiras
    @author fabioh.andrade@totvs.com.br
    @since 23/01/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getCustomFieldsPayToSelect(lApplyCommaAtBeginning as logical) as character class FinIntegratedProvider
    local cCustomFieldsSQL := self:cSelectCustomFieldsPay as character

    default lApplyCommaAtBeginning := .T.
    
    if lApplyCommaAtBeginning
        cCustomFieldsSQL := self:commaAtBeginning(cCustomFieldsSQL)
    endIf

return cCustomFieldsSQL

//-------------------------------------------------------------------
/*/{Protheus.doc} getCustomFieldsRecToGroupBy
    Retorna os campos personalizados da carteira Pagar para concatenar no GROUP BY quando é multi-carteiras
    @author fabioh.andrade@totvs.com.br
    @since 23/01/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getCustomFieldsRecToGroupBy(lApplyCommaAtBeginning as logical) as character class FinIntegratedProvider
    local cCustomFieldsSQL := self:cGroupByCustomFieldsRec as character

    default lApplyCommaAtBeginning := .T.
    
    if lApplyCommaAtBeginning
        cCustomFieldsSQL := self:commaAtBeginning(cCustomFieldsSQL)
    endIf

return cCustomFieldsSQL

//-------------------------------------------------------------------
/*/{Protheus.doc} getCustomFieldsPayToGroupBy
    Retorna os campos personalizados da carteira Pagar para concatenar no GROUP BY quando é multi-carteiras
    @author fabioh.andrade@totvs.com.br
    @since 23/01/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getCustomFieldsPayToGroupBy(lApplyCommaAtBeginning as logical) as character class FinIntegratedProvider
    local cCustomFieldsSQL := self:cGroupByCustomFieldsPay as character

    default lApplyCommaAtBeginning := .T.
    
    if lApplyCommaAtBeginning
        cCustomFieldsSQL := self:commaAtBeginning(cCustomFieldsSQL)
    endIf

return cCustomFieldsSQL

//-------------------------------------------------------------------
/*/{Protheus.doc} fieldExistsInDefaultSchema
    Verifica se determinado campo existe no esquema padrão (isto é, desconsiderando os campos customizados)
    @author guilherme.sordi@totvs.com.br
    @since 10/01/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method fieldExistsInDefaultSchema(cFieldName as character) as logical class FinIntegratedProvider
    local aProperties := self:oSchema:getProperties() as array
    local lExists := .F. as logical
    local nX := 1 as numeric
    local oProperty as object

    while (!lExists .and. nX <= len(aProperties))
        oProperty := aProperties[nX]
        lExists := ( oProperty:getName() == cFieldName ) .and. ( oProperty:getCustomField() == .F. )
        nX++
    endDo
return lExists

//-------------------------------------------------------------------
/*/{Protheus.doc} processCustomFields
    Complementa o JSON jData com o conteúdo dos campos personalizados.
    @author guilherme.sordi@totvs.com.br
    @since 19/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method processCustomFieldsDefault() class FinIntegratedProvider
    local aCustomFields := {} as array
    local nX := 0 as numeric
    local cFieldName := "" as character
    local cType := "" as character
    local cPropertyId := "" as character

    aCustomFields := self:getCustomFields()

    for nX := 1 To Len(aCustomFields)
        cPropertyId := cFieldName := aCustomFields[nX][1]
        cType := aCustomFields[nX][3]        

        self:addToData(cPropertyId, cType, cFieldName)
    next nX
return


//-------------------------------------------------------------------
/*/{Protheus.doc} addToData
    Adiciona algum conteúdo no jData
    @author guilherme.sordi@totvs.com.br
    @since 20/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method addToData(cPropertyId as character, cType as character, cFieldName as character) class FinIntegratedProvider
    local cComboContent := "" as character

    if (self:cAlias)->(FieldPos(cFieldName)) == 0
        return
    endIf

    if cType == "date"
        self:jData[cPropertyId] := self:varToTimeStamp((self:cAlias)->&(cFieldName))
    elseif cType == "string" .and. !Empty(cComboContent := x3Combo(cFieldName, (self:cAlias)->&(cFieldName)))
        self:jData[cPropertyId] := cComboContent
    elseif cType == "string" .and. self:lEnableAllTrim
        self:jData[cPropertyId] := allTrim((self:cAlias)->&(cFieldName))
    else
        self:jData[cPropertyId] := (self:cAlias)->&(cFieldName)
    endIf
return

//-------------------------------------------------------------------
/*/{Protheus.doc} addToData
    Adiciona o nome da Filial ao jData
    É obrigatório que a query retorne uma coluna com nome FILIAL_CODE ou se use setMainTable()
    @author fabioh.andrade@totvs.com.br
    @since 18/10/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method addBranchNameToData() class FinIntegratedProvider
    local cBranchCode := "" as character

    if !self:lShowBranchName
        return
    endIf

    cBranchCode := (self:cAlias)->&(self:cMainBranchField)

    if Empty(cBranchCode)
        cBranchCode := "DEFAULT"
        self:jData["FILIAL_NAME"] := allTrim(self:jBranchNames[AllTrim(cBranchCode)])
    else    
        self:jData["FILIAL_NAME"] := cBranchCode + " - " + allTrim(self:jBranchNames[AllTrim(cBranchCode)])
    endIf
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setFilter
    Adiciona algum conteúdo no jData
    @author guilherme.sordi@totvs.com.br
    @since 20/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setFilter(oFilter as object) class FinIntegratedProvider
    self:oCurrentFilter := oFilter
return


//-------------------------------------------------------------------
/*/{Protheus.doc} getData
    Método getData padrão para todos os objetos de negócio.
    Veja a descrição dos métodos getquery() e loadStatement() para entender melhor
    a condição criada dentro do getData().
    @author guilherme.sordi@totvs.com.br
    @since 24/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getData(nPage as numeric, oFilter as object) as object class FinIntegratedProvider    

    if !self:validEnvironment()
        return self:oData
    endIf
    
    self:setPage(nPage)
    self:setFilter(oFilter)
    self:setMVPAR()
    self:loadParameters()
    self:loadMainTableSelectedBranches()
    self:loadBranchNames()
    self:loadLGPDFields()
    
    self:loadStatement()
    self:preOpenQuery() 
    if self:oStatement == NIL
        self:cAlias := MPSysOpenQuery(self:getQuery(), /*cAlias*/, self:aStruct)
    else
        self:oStatement:setFields(self:aStruct)
        self:cAlias := self:oStatement:openAlias(/*cAlias*/, self:cLifeTime, self:cTimeout)
    endIf

    self:myAliasToData()
  
    (self:cAlias)->( DBCloseArea() )
    self:postCloseQuery()
return self:oData


//-------------------------------------------------------------------
/*/{Protheus.doc} myAliasToData
    Método myAliasToData padrão para todos os objetos de negócio. Responsável 
    por preenchar o jData e, consequentemente, o objeto oData com os dados
    que serão retornados pelo objeto de negócio no end-point getData().
    Será implementado no objeto de negócios conforme a necessidade.

    Em alguns casos, a cada iteração do laço da query principal, múltiplos registros
    serão adicionados ao objeto oData. Nesses casos, a chamada do método processAndAppend()
    fica sob responsabilidade do objeto de negócio, podendo ser chamada várias vezes enquanto
    o laço da query principal ainda está no mesmo registro. Por exemplo: a Query principal
    busca registros PAI de um processo, mas a cada PAI encontrado, múltiplos FILHOS são
    adicionados ao oData.
    Nesses casos, desabilitar o append do MyAliasToData invocando 
    setAppendInMyAliastoData(.F.) ao instanciar o objeto de negócio.

    @author guilherme.sordi@totvs.com.br
    @since 24/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method myAliasToData() class FinIntegratedProvider
    local nRecordsToSkip := 0 as numeric
    local nRecordCount := 0 as numeric

    self:setCompleteData(.T.)

    (self:cAlias)->(DBGoTop())

    self:posPositionAlias()

    if (self:cAlias)->(Eof()) 
        return
    endIf

    if self:nCurrentPage > 1
        nRecordsToSkip := ((self:nCurrentPage - 1) * self:getPageSize())       
        (self:cAlias)->(dbSkip(nRecordsToSkip))
    endIf

    self:preWhileMyAliasToData()
    while !(self:cAlias)->(Eof()) .and. ( nRecordCount < self:getPageSize() )
        
        if self:lAppendInMyAliasToData
            self:jData := JSONObject():new()
            self:processAndAppend()
        else
            self:myProcessData()
        endIf
        
        (self:cAlias)->(DbSkip())
        nRecordCount++
    endDo
    self:setHasNext(!(self:cAlias)->(Eof()))
    self:postWhileMyAliasToData()
return

//-------------------------------------------------------------------
/*/{Protheus.doc} myProcessData    
    Responsável por processar o registro posicionado da query principal.
    É chamado quando lAppendInMyAliastoData é falso.
    Dentre outras possibilidades, permite que o objeto de negócio inclua
    múltiplos registros no objeto oData enquanto o cursor do self:cAlias
    está posicionado em um único registro.

    Será implementado no objeto de negócio.
    
    Para mais detalhes veja a descrição do método MyAliasToData.

    @author guilherme.sordi@totvs.com.br
    @since 26/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method myProcessData() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} finAddProperty
    Simplifica a inclusão de campos calculados ao schema.
    @author guilherme.sordi@totvs.com.br
    @since 26/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method finAddProperty(cPropertyName as character, cDescription as character, cType as character, ;
    cRealNameForLGPD as character) class FinIntegratedProvider

    local lCanFilter := .F.

    self:oSchema:addProperty(cPropertyName, cDescription, cType, cDescription, cPropertyName, , , , lCanFilter)
    if cRealNameForLGPD <> NIL
        self:addLGPDCalcField(cPropertyName, cRealNameForLGPD)
    endIf
return

//-------------------------------------------------------------------
/*/{Protheus.doc} loadParameters
    Retorna o schema do objeto de negócios. Na prática, 
    será definido pelo método mySetSchema do objeto de negócio.
    @author guilherme.sordi@totvs.com.br
    @since 26/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getSchema() class FinIntegratedProvider
    self:mySetSchema()
    self:handleSchema()
    self:setLookups()

    if self:lShowBranchName
        self:finAddProperty("FILIAL_NAME", STR0010, "string") //"Nome da filial"
    endIf

    if !self:lAllowSmartViewFilter        
        self:notAllowSmartViewFilter()
    endIf

    if self:lAllowBranchFilter
        if self:lMultSelectBranches
            self:oSchema:addParameter("SV_MULTBRANCH", STR0009, "string", .T.)
            self:setCustomURL("SV_MULTBRANCH","/api/fin/smartview/v1/options/getBranches",2)
        else        
            self:oSchema:addParameter("SV_FROMBRANCH", STR0007, "string", .F.)
            self:oSchema:addParameter("SV_TOBRANCH", STR0008, "string", .F.)

            self:setCustomURL("SV_FROMBRANCH","/api/fin/smartview/v1/options/getBranches",1)
            self:setCustomURL("SV_TOBRANCH","/api/fin/smartview/v1/options/getBranches",1)
        endIf
    endIf

return self:oSchema

//-------------------------------------------------------------------
/*/{Protheus.doc} loadParameters
    Define o schema do objeto de negócio.
    Será implementado no objeto de negócio.
    @author guilherme.sordi@totvs.com.br
    @since 26/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method mySetSchema() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} loadDefaultParameters
    Inicializa as propriedades de parâmetros do objeto de negócio
    para não correr riscos de error.log.
    Será implementado no objeto de negócio.
    @author guilherme.sordi@totvs.com.br
    @since 08/11/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method loadDefaultParameters() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} loadParameters
    Carrega os parâmetros da consulta antes de chamar o getQuery().
    Será implementado no objeto de negócio, de acordo com a necessidade e
    os parâmetros utilizados.
    @author guilherme.sordi@totvs.com.br
    @since 26/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method loadParameters() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} completeData
    Complementa o jData com dados do schema que ainda não foram preenchidos, 
    permitindo que o objeto de negócio manipule apenas campos calculados
    e os demais campos da query sejam preenchidos no jData automaticamente.

    Quando o objeto está configurado para permitir filtro de Smart View, 
    pode-se concluir que os campos que não permitem filtro são campos calculados
    e não devem ser preenchidos automaticamente.
    Quando o objeto está configurado para não permitir filtro de Smart View
    em nenhum campo, todos os campos estarão configurados com lCanFilter = falso, 
    então não temos como saber o campo é calculado ou não. Nesse caso, todos os campos
    calculados já devem estar devidamente preenchidos no jData quando completeData() for 
    invocado, caso contrário o sistema vai apresentar error.log ao tentar preencher no 
    jData uma propriedade que não é um campo retornado pela query.

    @author guilherme.sordi@totvs.com.br
    @since 24/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method completeData() class FinIntegratedProvider
    local aProperties := self:oSchema:getProperties() as array
    local nX := 1 as numeric
    local cPropertyId := "" as character
    local cType := "" as character
    local cRealName := "" as character
    local lCanFilter := .F. as logical
    local lCustomField := .F. as logical
    local lListedField := .F. as logical
    local lCalcField := .F. as logical
    local oProperty as object

    if len(aProperties) == len(self:jData)
        return
    endIf

    for nX := 1 to len(aProperties)
        oProperty := aProperties[nX]
        cPropertyId := oProperty:getName()        
        cType := oProperty:getType()
        cRealName := oProperty:getRealName()
        lCanFilter := oProperty:getCanFilter()
        lCustomField := oProperty:getCustomField()

        lListedField := empty(self:cFieldsToCompleteData) .or. (cRealName $ self:cFieldsToCompleteData)

        if self:lAllowSmartViewFilter
            lCalcField := !lCanFilter
        else
            lCalcField := .F.
        endIf
        
        if !lCalcField .and. !lCustomField .and. !self:jData:hasProperty(cPropertyId) .and. lListedField
            self:addToData(cPropertyId, cType, cRealName)
        endIf
    next nX

return


//-------------------------------------------------------------------
/*/{Protheus.doc} setCompleteData
    @author guilherme.sordi@totvs.com.br
    @since 24/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setCompleteData(lEnable as logical) class FinIntegratedProvider
    self:lEnableCompleteData := lEnable
return


//-------------------------------------------------------------------
/*/{Protheus.doc} setCompleteData    
    @author guilherme.sordi@totvs.com.br
    @since 24/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setAllTrim(lEnable as logical) class FinIntegratedProvider
    self:lEnableAllTrim := lEnable
return

//-------------------------------------------------------------------
/*/{Protheus.doc} getFilterToSQL
    Retorna a instrução SQL para complementar a cláusula WHERE da query
    conforme o filtro realizado no Smart View.
    Por padrão, também complemente com o conteúdo da propriedade
    WhereComplement, criada para internacionalização.
    @author guilherme.sordi@totvs.com.br
    @since 24/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getFilterToSQL(lOnlyFilter as logical) as character class FinIntegratedProvider
    local cFilter := "" as character
    default lOnlyFilter := .F.

    if self:oCurrentFilter <> NIL .and. self:oCurrentFilter:hasFilter()
        cFilter += " AND ( " + self:oCurrentFilter:getSQLExpression() + " ) "
    Endif

    if !lOnlyFilter
        cFilter += self:cWhereComplement
    endIf
return cFilter

//-------------------------------------------------------------------
/*/{Protheus.doc} getAllFieldsToSQL
    Retorna todos os campos usados no objeto de negócio para compor
    a query. Inclui todos os campos do schema padrão, da personalização de campos
    e da internacionalização.
    É bom dar preferência para esse método em vez de montar os campos da query manualmente
    no objeto de negócio porque se houver algum campo na consulta que não existe no schema,
    será permitido ao usuário incluir esse campo no objeto de negócio e ele ficaria duplicado
    na query, correndo um risco alto de gerar erros em tempo de execução.
    @author guilherme.sordi@totvs.com.br
    @since 26/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getAllFieldsToSQL() as character class FinIntegratedProvider
    local cFields := "" as character
    local lContactTableName := .T. as logical

    cFields := self:getSQLFields(lContactTableName) + " "
    cFields += self:getCustomFieldsToSQL() + " "
    cFields += self:cSelectComplement + " "
return cFields

//-------------------------------------------------------------------
/*/{Protheus.doc} getAllFieldsToSQL
    Define os look ups que serão usados no objeto de negócio.
    Setá implementado no objeto de negócio.
    @author guilherme.sordi@totvs.com.br
    @since 26/10/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setLookups() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} preOpenQuery
    Permite fazer alguma ação no objeto de negócio depois que o oCurrentFilter
    já está definido e antes do getQuery. Útil para chamar loadCustomFieldsPayAndRec()
    nos objetos de negócio que lidam com customização de campos nas duas carteiras.
    @author guilherme.sordi@totvs.com.br
    @since 13/11/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method preOpenQuery() class FinIntegratedProvider
    
return

//-------------------------------------------------------------------
/*/{Protheus.doc} preOpenQuery
    Manipula o jData imediatamente antes do append, depois que todos os outros métodos relacionados
    ao jData já foram executados.
    @author guilherme.sordi@totvs.com.br
    @since 21/11/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method preAppendData() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} preWhileMyAliasToData
    Método chamado imediatamente antes de iniciar o While do 
    MyAliasToData(), depois de já estar com a query aberta
    e posicionada no primeiro registro.
    @author guilherme.sordi@totvs.com.br
    @since 21/11/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method preWhileMyAliasToData() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} posPositionAlias
    Método chamado imediatamente antes de iniciar o While do 
    MyAliasToData(), validando se existe registro para movimentos e saldos bancarios
    e posicionada no primeiro registro.
    @author francisco.carmo@totvs.com.br
    @since 07/03/2025
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method posPositionAlias() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} postOpenQuery
    Chamado imediatamente após fechar a query principal do objeto de negócio.
    @author guilherme.sordi@totvs.com.br
    @since 13/11/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method postCloseQuery() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} postAppendData
    Manipula o jData imediatamente após o append.
    @author guilherme.sordi@totvs.com.br
    @since 21/11/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method postAppendData() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} postWhileMyAliasToData
    Método chamado imediatamente após o laço do 
    MyAliasToData(), depois de já estar com a query aberta
    e posicionada no primeiro registro.
    @author guilherme.sordi@totvs.com.br
    @since 21/11/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method postWhileMyAliasToData() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} setFieldsToCompleteData
    Na grande maioria dos casos, deseja-se preencher o JSON do aData com todos os campos
    disponíveis no schema. Mas, há exceções em que nem todos os campos de dicionário 
    incluídos no schema serão preenchidos no JSON no mesmo momento.
    Por exemplo, no schema pode ter SC5_NUM e E1_NUM, mas a consulta de pedidos de venda
    não vai retornar o campo E1_NUM e a consulta de títulos a receber não vai retornar 
    SC5_NUM. Para tratar esse cenário, usaremos a variável cFieldsToCompleteData para saber
    quais campos estão na consulta e serão preenchidos no JSON pelo completeData().
    Preencher essa variável com o mesmo conteúdo do SELECT da consulta aberta em self:cAlias.
    @author guilherme.sordi@totvs.com.br
    @since 18/12/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setFieldsToCompleteData(cFields as character) class FinIntegratedProvider
    self:cFieldsToCompleteData := cFields
    if !empty(cFields)
        self:lEnableCompleteData := .T.
    endIf
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setFieldsToCompleteData
    @author guilherme.sordi@totvs.com.br
    @since 18/12/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getFieldsToCompleteData() class FinIntegratedProvider
return self:cFieldsToCompleteData

//-------------------------------------------------------------------
/*/{Protheus.doc} addFieldToStruct
    Recebe tanto character quanto array de character.
    Adiciona a estrutura de um ou mais campos em aStruct.
    Isso é especialmente útil para que campos do tipo data sejam abertos no alias como data
    e não character.
    @author guilherme.sordi@totvs.com.br
    @since 18/12/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method addFieldsToStruct(xFieldName as variant) class FinIntegratedProvider
    local nX := 1 as numeric
    
    local aFields := self:cToA(xFieldName) as array

    for nX := 1 to len(aFields)
        aAdd( self:aStruct, FWSX3Util():GetFieldStruct( allTrim(aFields[nX]) ) )
    next
return

//-------------------------------------------------------------------
/*/{Protheus.doc} cToA
    Recebe uma variável que pode ser character ou array of character
    e retorna sempre um array.
    Isso permite que diversos métodos do Integrated Provider possa receber
    tanto um campo como character quanto um array de campos.
    @author guilherme.sordi@totvs.com.br
    @since 18/12/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method cToA(xVar as variant) as array class FinIntegratedProvider
    local aReturn := {} as array
    local cValType := "" as character
    
    default xVar := ""

    cValType := valType(xVar)

    if cValType == "C" .and. !empty(xVar)
        aReturn := strTokArr(xVar, ",")
    elseIf cValType == "A"
        aReturn := aClone(xVar)
    endIf
return aReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} clearStruct
    @author guilherme.sordi@totvs.com.br
    @since 18/12/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method clearStruct() class FinIntegratedProvider
    FWFreeArray(self:aStruct)
    self:aStruct := {}
return 

//-------------------------------------------------------------------
/*/{Protheus.doc} loadStatement
    Cria o objeto self:oStatement da classe FWExecStatement com a query principal 
    do objeto de negócio.
    @author guilherme.sordi@totvs.com.br
    @since 22/12/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method loadStatement() class FinIntegratedProvider

return

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
    Depreciado - Antes retornávamos a query principal em texto. Hoje criamos o oStatement
    para a query principal, fazendo uso adequeado de Bind Parameters e CachedQuery e 
    impedindo SQL Inject.
    Use loadStatement().
    @author guilherme.sordi@totvs.com.br
    @since 22/12/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method getQuery() as character class FinIntegratedProvider

return ""

//-------------------------------------------------------------------
/*/{Protheus.doc} setPage
    Define a página atual da requisição.
    @author guilherme.sordi@totvs.com.br
    @since 22/12/2023
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setPage(nPage as numeric) class FinIntegratedProvider
    self:nCurrentPage := nPage
return

//-------------------------------------------------------------------
/*/{Protheus.doc} notAllowSmartViewFilter
    Percorre todas as propriedades do objeto, setando como não filtrável.
    Isso impede a criação de filtros na tela de configuração do objeto de negócio do Smart View.
    Isso foi criado porque a forma como algumas queries são construídas impede que sejam complementadas
    com o filtro do Smart View, da forma como ele é passado hoje.
    @author guilherme.sordi@totvs.com.br
    @since 17/01/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method notAllowSmartViewFilter() class FinIntegratedProvider
    local aProperties := self:oSchema:getProperties() as array
    local oProperty as object
    local nX := 1 as numeric

    for nX := 1 to len(aProperties)
        oProperty := aProperties[nX]
        self:setCanFilter(oProperty:getName(), .F.)
    next nX
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setAllowSmartViewFilter
    @author guilherme.sordi@totvs.com.br
    @since 17/01/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setAllowSmartViewFilter(lCanFilter as logical) class FinIntegratedProvider
    default lCanFilter := .T.
    self:lAllowSmartViewFilter := lCanFilter
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setAppendInMyAliastoData
    @author guilherme.sordi@totvs.com.br
    @since 17/01/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setAppendInMyAliastoData(lShoudAppendInMyAliastoData as logical) class FinIntegratedProvider
    default lShoudAppendInMyAliastoData := .T.
    self:lAppendInMyAliasToData := lShoudAppendInMyAliastoData
return


//-------------------------------------------------------------------
/*/{Protheus.doc} commaAtBeginning
    @author guilherme.sordi@totvs.com.br
    @since 18/01/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method commaAtBeginning(cExpression as character) as character class FinIntegratedProvider
    default cExpression := ""

    cExpression := AllTrim(cExpression)

    if Empty(cExpression)
        return cExpression
    endIf

    if right(cExpression,1) == ","
        cExpression := left(cExpression, len(cExpression)-1)
    endIf

    cExpression := ", " + cExpression + " "
return cExpression

//-------------------------------------------------------------------
/*/{Protheus.doc} setAllowFilterByBranch
    Depreciado - 25/10/2024
    Liga o mecanismo de filtro por filiais.
    
    @author Guilherme de Paula Santos
    @since 17/07/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setAllowFilterByBranch(lMultSelect as logical) class FinIntegratedProvider
    default lMultSelect := .F.
    self:setBranchFilter(.T., lMultSelect)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setAllowFilterByBranch
    Determina se o objeto de negócio terá filtro por filial e se deve permitir multiplas filiais.    
    @author guilherme.sordi@totvs.com.br
    @since 25/10/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method setBranchFilter(lAllowBranchFilter as logical, lMultSelect as logical) class FinIntegratedProvider
    default lAllowBranchFilter := .T.
    default lMultSelect := .T.

    self:lAllowBranchFilter := lAllowBranchFilter
    self:lMultSelectBranches := lMultSelect
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setBranchPar
    Atribui valores para as variáveis de filiais.
    
    @author Guilherme de Paula Santos
    @since 17/07/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setBranchPar(oJsonMvPar as json) class FinIntegratedProvider
    if self:lMultSelectBranches
        self:aMultiBranches := oJsonMvPar:SV_MULTBRANCH
    else
        self:cFromBranch := oJsonMvPar:SV_FROMBRANCH[1]
        self:cToBranch := oJsonMvPar:SV_TOBRANCH[1]
    endIf
    //Após executar o filtro, limpar e enviar novamente, ele considera array com 1 posição vazia
    self:lEmptyMultiBranches := empty( self:aMultiBranches ) .or. empty( self:aMultiBranches[1] )
    
    self:removeTrimFromBranchFilter()
return

//-------------------------------------------------------------------
/*/{Protheus.doc} loadFilterBranches
    @description Método depreciado. Utilizar o novo fluxo com o método setStatementBranchFilter().
    @author fabioh.andrade@totvs.com.br
    @since 21/08/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method loadFilterBranches(aAliasBranches as array) class FinIntegratedProvider
    local nX := 1 as numeric

    self:oFilterBranches := JSONObject():new()
    
    if self:lMultSelectBranches //Se o ON for seleção de múltiplas filiais, seguir esse modelo
        for nX := 1 to Len(aAliasBranches)
            self:oFilterBranches[aAliasBranches[nX]] := {}
            if self:lEmptyMultiBranches
                aAdd( self:oFilterBranches[aAliasBranches[nX]], self:getAliasBranchFilter(aAliasBranches[nX])[1] )
            else
                aAdd( self:oFilterBranches[aAliasBranches[nX]], self:getAliasBranchFilter(aAliasBranches[nX]) )
            endIf
        next nX
    else // Se o ON for Filial De/Até, seguir esse modelo
        if empty(self:cFromBranch) .and. empty(self:cToBranch)
            self:cFromBranch := FWxFilial(aAliasBranches[nX])
            self:cToBranch := FWxFilial(aAliasBranches[nX])
        endIf
    endIf    
return

//-------------------------------------------------------------------
/*/{Protheus.doc} removeTrimFromBranchFilter
    Hoje o Smart View devolve o filtro de filiais removendo espaços em branco no final.
    Isso se torna um problema em algumas comparações. Esse método restaura o nome da filial
    com seu tamanho completo.
    @author guilherme.sordi@totvs.com.br
    @since 08/11/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method removeTrimFromBranchFilter() class FinIntegratedProvider
    local nX as numeric
    if !empty(self:aMultiBranches) .and. len(self:aMultiBranches[1]) != FwSizeFilial()
        for nX := 1 to len(self:aMultiBranches)
            self:aMultiBranches[nX] := padR(self:aMultiBranches[nX], FwSizeFilial())
        next
    endIf
return

//-------------------------------------------------------------------
/*/{Protheus.doc} loadMainTableSelectedBranches
    @author guilherme.sordi@totvs.com.br
    @since 25/10/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method loadMainTableSelectedBranches() class FinIntegratedProvider
    self:aMainTableSelectedBranches := {}
    if empty(self:cMainAlias)
        return
    endIf

    if self:lMultSelectBranches
        self:aMainTableSelectedBranches := self:getAliasBranchFilter(self:cMainTable)
    else
        if empty(self:cFromBranch) .and. empty(self:cToBranch)
            self:cFromBranch := self:cToBranch := FWxFilial(self:cMainTable)
        endIf
    endIf  
return


//-------------------------------------------------------------------
/*/{Protheus.doc} getAliasBranchFilter
    @author fabioh.andrade@totvs.com.br
    @since 21/08/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method getAliasBranchFilter(cAlias as character) as array class FinIntegratedProvider
    local nX        := 0 as numeric
    local aBranches := {} as array
    local cFilAux   := "" as character

    if self:lEmptyMultiBranches
        aBranches := { FwXFilial(cAlias) }
    else
        for nX := 1 to len(self:aMultiBranches)
            cFilAux := FWxFilial(cAlias,self:aMultiBranches[nX])
            if aScan( aBranches, cFilAux ) == 0
                aAdd( aBranches, cFilAux )
            endIf
        next
    endIf

return aBranches


//-------------------------------------------------------------------
/*/{Protheus.doc} loadBranchNames
    Carrega o código e nome das filiais em um jSon
    @author guilhermed.santos@totvs.com.br
    @since 16/09/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method loadBranchNames() class FinIntegratedProvider
    local nX                  := 0                      as numeric
    local cTable              := self:cMainTable        as character
    local cCompanyShare       := FWModeAccess(cTable,1) as character
    local cBusinessUnityShare := FWModeAccess(cTable,2) as character
    local cBranchShare        := FWModeAccess(cTable,3) as character
    local cBranchCode         := ""                     as character
    local aBranchesToLoadName := {}                     as array

    if !self:lShowBranchName
        return
    endIf

    self:jBranchNames := JSONObject():New()

    if !self:lAllowBranchFilter
        aBranchesToLoadName := {cFilAnt}
    else
        if self:lMultSelectBranches
            if self:lEmptyMultiBranches
                aBranchesToLoadName := {cFilAnt}
            else
                aBranchesToLoadName := self:aMultiBranches
            endIf
        // else
            //Carregar as filiais contidas no filtro DE - ATÉ
        endIf
    endIf
    
    for nX := 1 to len(aBranchesToLoadName)
        cBranchCode := AllTrim(FWxFilial(cTable, aBranchesToLoadName[nX]))
        if !self:jBranchNames:hasProperty(cBranchCode)
            if cBranchShare == "E"
                self:jBranchNames[cBranchCode] := FWFilialName(cEmpAnt,cBranchCode,1)
            elseIf cBusinessUnityShare == "E"
                self:jBranchNames[cBranchCode] := FWUnitName(cEmpAnt,cBranchCode,1)
            elseIf cCompanyShare == "E"
                self:jBranchNames[cBranchCode] := FWCompanyName(cEmpAnt,cBranchCode,1)
            else 
                self:jBranchNames["DEFAULT"] := FWGrpName(cEmpAnt)
            endIf
        endIf
    next
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setMainTable
    Define uma tabela como a principal tabela do objeto de negócio. A partir dessa tabela,
    serão feitos os filtros de filial.
    @author guilherme.sordi@totvs.com.br
    @since 25/10/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method setMainTable(cTable as character, cMainBranchField as character, cSQLAlias as character) class FinIntegratedProvider
    cTable := allTrim(cTable)
    default cSQLAlias := cTable

    if cMainBranchField == NIL
        cMainBranchField := cTable + "_FILIAL"
        if left(cTable,1) == "S"
            cMainBranchField := right(cTable, 2) + "_FILIAL"
        else
            cMainBranchField := cTable + "_FILIAL"
        endIf
    endIf
    
    self:cMainTable := cTable
    self:cMainBranchField := cMainBranchField
    self:cMainAlias := cSQLAlias

    self:lShowBranchName := .T.
return

//-------------------------------------------------------------------
/*/{Protheus.doc} getSQLBranchFilter
    Retorna a instrução SQL que deve ser usada para filtrar a filial.
    Será considerada a filial da tabela definida em setMainTable.
    A diferença entre cMainTable e cMainAlias é que o cMainAlias foi criado para
    tratar exceções em que não utilizamos um alias diferenciado na consulta. Por exemplo,
    consultas do caixinha utilizam o alias SETT porque SET é uma palavra reservada do SQL.
    @author guilherme.sordi@totvs.com.br
    @since 25/10/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method getSQLBranchFilter() as character class FinIntegratedProvider
    local cFilter as character
    local cBranch := self:cMainAlias + "." + self:cMainBranchField as character

    if !self:lAllowBranchFilter
        cFilter := cBranch + " = ? "
    else
        if self:lMultSelectBranches
            if self:lEmptyMultiBranches
                cFilter := cBranch + " = ? "
            else
                cFilter := cBranch + " IN (?) "
            endIf
        else
            cFilter := cBranch + " BETWEEN ? AND ? "
        endIf
    endIf
    cFilter := " " + cFilter
return cFilter

//-------------------------------------------------------------------
/*/{Protheus.doc} setStatementBranchFilter
    O método getSQLBranchFilter adiicona o filtro de filial com bind parameters.
    Esse método preenche os bind parameters no objeto self:oStatement.
    Sugestão: Passar o nParamOrder como referência para continuar a numeração dos parãmetros
    da query no método chamador.
    @author guilherme.sordi@totvs.com.br
    @since 25/10/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method setStatementBranchFilter(nParamOrder as numeric) class FinIntegratedProvider
    default nParamOrder := 1

    if !self:lAllowBranchFilter
        self:oStatement:SetString(nParamOrder++, fwXFilial(self:cMainTable))
    else
        if self:lMultSelectBranches
            if self:lEmptyMultiBranches
                self:oStatement:SetString(nParamOrder++, fwXFilial(self:cMainTable))
            else
                self:oStatement:SetIn(nParamOrder++, self:aMainTableSelectedBranches)
            endIf
        else
            self:oStatement:SetString(nParamOrder++, fwXFilial(self:cMainTable, self:cFromBranch))
            self:oStatement:SetString(nParamOrder++, fwXFilial(self:cMainTable, self:cToBranch))
        endIf
    endIf
return

//-------------------------------------------------------------------
/*/{Protheus.doc} aliasToArray
    Retorna um vetor com o conteúdo do campo indormado nos parâmetros em todos os registros do alias.
    @author guilherme.sordi@totvs.com.br
    @since 20/11/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method aliasToSimpleArray(cAlias as character, cFieldName as character) as array class FinIntegratedProvider
    local aList := {} as array
    (cAlias)->(DbGoTop())
    while !(cAlias)->(eof())
        aAdd(aList, (cAlias)->&(cFieldName))
        (cAlias)->(dbSkip())
    endDo
return aList

//-------------------------------------------------------------------
/*/{Protheus.doc} aliasToArray
    Retorna um vetor de JSON com o conteúdo dos campos informados no parâmetro todos os registros do alias.
    @author guilherme.sordi@totvs.com.br
    @since 20/11/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method aliasToJsonArray(cAlias as character, aFields as array) as array class FinIntegratedProvider
    local aList := {} as array
    local jRecord as object
    local nX as numeric

    (cAlias)->(DbGoTop())
    while !(cAlias)->(eof())
        jRecord := JsonObject():new()
        for nX := 1 to len(aFields)
            jRecord[lower(aFields[nX])] := (cAlias)->&(aFields[nX])
        next    
        aAdd(aList, jRecord)
        (cAlias)->(dbSkip())
    endDo
return aList
