#Include "totvs.ch"
#include "tlpp-core.th"
#include "distribution.convergencia.ch"
#include "distribution.convergencia.estoque.movimento.transferencia.classe.ch"

Static nTamProd  := TamSx3('D3_COD')[1]
Static nTamLocal := TamSx3('D3_LOCAL')[1]
Static nTamLote  := TamSx3('D3_LOTECTL')[1]

/*/{Protheus.doc} WMSSaasMovimentoTransferencia
Classe de Movimento transferência Wms Saas
@type class
@author Alexsander Burigo Corrêa
@since 16/09/2024
/*/
Class WMSSaasMovimentoTransferencia From WMSSaasConvergencia implements WMSSaasConvergenciaInterface
    Public Method new(cIdSaas as character, dDataMovimento as date)
    Public Method loadOrNew(cIdSaas as character, dDataMovimento as date)
    Public Method loadByChave(cIdSaas as character) as object
    Public Method canBeUpdated() as logical
    Public Method finaliza(jMovTransferencia as json ) as logical
    Public Method geraMovimentoTransferencia(aItens as array) as logical
    Public Method getNomePessoa() as character
EndClass

/*/{Protheus.doc} loadOrNew
    (long_description)
    @author Alexsander Burigo Corrêa
    @since 16/09/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method loadOrNew(cIdSaas as character, dDataMovimento as date) Class WMSSaasMovimentoTransferencia
local oLoad := self:loadByChave(cIdSaas)
    If !Empty(oLoad:id)
        Return oLoad
    EndIf

Return self:new(cIdSaas, dDataMovimento)

/*/{Protheus.doc} WMSSaasMovimentoTransferencia::New
Carga das propriedades do cabeçalho da classe de convergência
@type method
@author Alexsander Burigo Corrêa
@since 16/09/2024
@param cIdSaas, character, Identificador do documento SAAS
@param dEmissao, date, Data do Movimento
/*/
Method new(cIdSaas, dDataMovimento) Class WMSSaasMovimentoTransferencia
    self:status              := self:getStatusCriado()
    self:tipoTransacao       := self:getTipoTransacaoEstoqueMovimentoTransferencia()
    self:idSaas              := cIdSaas
    self:numeroDocumento     := ""
    self:clienteOuFornecedor := ""
    self:loja                := ""
    self:dataCriacao         := FwTimeStamp(3,dDataBase, Time())
    self:dataEmissao         := dDataMovimento
    self:transportador       := ""
    self:sequenciaIntegracao := ""
    self:mensagemIntegracao  := ""
    self:itensConvergencia   := {}
Return self


/*/{Protheus.doc} loadByChave
    Faz o load da classe de estoque e convergencia pela chave
    Esse metodo deve retornar apenas um registro da DBZ sempre, pois cada identificador de movimento transferência só pode ter uma DBZ. Os registros de movimento transferência não possuem DBY.
    @author Alexsander Burigo Corrêa
    @since 26/04/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method loadByChave(cIdSaas) Class WMSSaasMovimentoTransferencia
Local cAliasDBZ := GetNextAlias()
    BeginSql Alias cAliasDBZ
		SELECT DBZ.DBZ_ID IDCONVERGENCIA
		  FROM %Table:DBZ% DBZ
		 WHERE DBZ.DBZ_FILIAL = %Exp:xFilial("DBZ")%
		   AND DBZ.DBZ_TIPOTR = %Exp:self:getTipoTransacaoEstoqueMovimentoTransferencia()%
		   AND DBZ.DBZ_IDSAAS = %Exp:cIdSaas%
		   AND DBZ.%NotDel%
	EndSql

    If (cAliasDBZ)->(!Eof())
        self:loadById((cAliasDBZ)->IDCONVERGENCIA)        
    EndIf
    (cAliasDBZ)->(DbCloseArea())
Return self

/*/{Protheus.doc} canBeUpdated
    Retorna status nos quais os registros de estoque podem ser alterados. No movimento transferência, só permite o reprocessamento quando status de erro```
    @author Alexsander Burigo Corrêa
    @since 26/04/2024
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method canBeUpdated() as logical Class WMSSaasMovimentoTransferencia
Return self:isErroIntegracao()

/*/{Protheus.doc} finaliza
    Metodo de finalizacao do movimento transferência
    @author Alexsander Burigo Corrêa
    @since 26/04/2024
    @version version
    @param jMovTransferencia, array, array de json com item movimentado

    {;
        "idSaas"              : "2a8a81da-ab92-4ed6-a56a-b3caf3c32476",;
        "produto"             : "MAGICMOUSE",;
        "tipoEstoqueOrigem"   : "01",;
        "loteOrigem"          : "LOTE1",
        "dataValidadeOrigem"  : "2025-10-03",;
        "tipoEstoqueDestino"  : "02",;
        "loteDestino"         : "LOTE1",;
        "dataValidadeDestino" : "2025-10-03",;
        "quantidade"          : 1,;
        "dataMovimento"       : "2024-09-25";
    }
    @return return_var, return_type, return_description
/*/
Method finaliza(jMovTransferencia) Class WMSSaasMovimentoTransferencia as logical
Local cProduto             := Padr(jMovTransferencia['produto'],nTamProd)
Local lRastro              := Rastro(cProduto,"L")
Local cTipEstoqueOrigem    := Padr(jMovTransferencia['tipoEstoqueOrigem'],nTamLocal)
Local cLoteOrigem          := If(lRastro .And. !(jMovTransferencia['loteOrigem']==NIL),Padr(jMovTransferencia['loteOrigem'],nTamLote),Space(nTamLote))
Local dDataValidadeOrigem  := If(lRastro,jMovTransferencia['dataValidadeOrigem'],CtoD('  /  /  '))
Local cTipEstoqueDestino   := Padr(jMovTransferencia['tipoEstoqueDestino'],nTamLocal)
Local cLoteDestino         := If(lRastro .And. !(jMovTransferencia['loteDestino']==NIL),Padr(jMovTransferencia['loteDestino'],nTamLote),Space(nTamLote))
Local dDataValidadeDestino := If(lRastro,jMovTransferencia['dataValidadeDestino'],CtoD('  /  /  '))
Local nQuantidade          := jMovTransferencia['quantidade']
Local dDataMovimento       := jMovTransferencia['dataMovimento']
Local cNumSeq              := ""
Local cUM                  := ""
Local cDescricao           := ""
Local aTransf              := {}
Local aWmsCMov             := {}
Local lRetPe               := .F.

    If ExistBlock("WMSSVLCQ")
        /*Ponto de entrada para atender a um especifico do cliente Magno
        O cliente possui um processo de qualidade customizado que nao passa pelo Protheus,
        no WMS SAAS ocorre a separacao que é enviada ao Protheus com um evento de finalizacao,
        com isso o Protheus responde com o erro A260LOCCQ que impedi a transferencia de produtos de um armazem de qualidade 
        e então a separacao no SAAS fica com erro tecnico. Para atender a este processo foi gerado o PE abaixo, 
        que permitira ao cliente informar se para um determinado armazem de qualidade retornaremos uma mensagem de sucesso ao 
        receber o evento de finalizacao, já que a parte Protheus ja ocorreu via customizado,
        assim permitindo que o SAAS possa concluir o processo sem apresentar erro*/

        lRetPe := ExecBlock('WMSSVLCQ',.F.,.F.,{cProduto,cTipEstoqueOrigem,cTipEstoqueDestino})
        If (ValType(lRetPe)) == "L"
            //Em caso de retorno falso a integracao é interrompida com a mensagem de sucesso, 
            //indicando que para este armazem nao ocorrera o processo de transferencia no Protheus
            If !lRetPe
                self:setFinalizado()
                self:setMensagemIntegracao(STR0005) // Movimento transferencia do tipo de estoque gerado com sucesso
                Return .T.
            EndIf
        EndIf
    EndIf

    DbSelectArea("SD3")
    SD3->(DbSetOrder(1))
    
    DBSelectArea("SB1")
    SB1->(DbSetOrder(1))

    DBSelectArea("SB2")
    SB2->(DbSetOrder(1))

    DBSelectArea("NNR")
    NNR->(DbSetOrder(1))

    If cTipEstoqueOrigem == cTipEstoqueDestino //.And. cLoteOrigem == cLoteDestino .And. dDataValidadeOrigem <> dDataValidadeDestino
        self:setMensagemIntegracao(STR0001) // "Não permite alteração do mesmo tipo de estoque (origem e destino)"
        Return .F.
    EndIf

    If !SB1->(MsSeek(xFilial("SB1") + cProduto))
        self:setMensagemIntegracao(STR0002 + " "+ AllTrim(cProduto) + " "+ STR0003) // Produto XXX não encontrado na filial.
        Return .F.
    EndIf

    If !NNR->(MsSeek(xFilial("NNR") + cTipEstoqueOrigem))
        self:setMensagemIntegracao(STR0004 + " " + AllTrim(cTipEstoqueOrigem) + " " + STR0003) // Armazem XXX não encontrado na filial.
        Return .F.
    EndIf

    If !NNR->(MsSeek(xFilial("NNR") + cTipEstoqueDestino))
        self:setMensagemIntegracao(STR0004 + " " + AllTrim(cTipEstoqueDestino) + " " + STR0003) // Armazem XXX não encontrado na filial.
        Return .F.
    EndIf

    If !WMSSaasInt(cProduto, cTipEstoqueOrigem)
        self:setMensagemIntegracao(STR0006 + AllTrim(cTipEstoqueOrigem) + STR0008)//"Local de estoque origem "" nao controla WMS SaaS."
        Return .F.
    EndIf

    If !WMSSaasInt(cProduto, cTipEstoqueDestino)
        self:setMensagemIntegracao(STR0007 + AllTrim(cTipEstoqueDestino) + STR0008)//"Local de estoque destino "" nao controla WMS SaaS."
        Return .F.
    EndIf
    
    cDescricao := SB1->B1_DESC
    cUM        := SB1->B1_UM

    // Valida se produto esta cadastrado no armazem origem
    If !SB2->(DbSeek(xFilial("SB2") + cProduto + cTipEstoqueOrigem))
        CriaSB2(cProduto, cTipEstoqueOrigem, xFilial("SB2"))
    EndIf

    // Valida se produto esta cadastrado no armazem destino
    If !SB2->(DbSeek(xFilial("SB2") + cProduto + cTipEstoqueDestino))
        CriaSB2(cProduto, cTipEstoqueDestino, xFilial("SB2"))
    EndIf

    cNumSeq := SD3->(ProxNum())

    aAdd(aTransf, {cNumSeq, dDataMovimento})
    aAdd(aTransf,{})
    aAdd(aTransf[02],{"D3_COD"    , cProduto                           , Nil}) // [01] Produto origem
    aAdd(aTransf[02],{"D3_DESCRI" , cDescricao                         , Nil}) // [02] Descrição origem 
    aAdd(aTransf[02],{"D3_UM"     , cUM                                , Nil}) // [03] Unidade de medica origem
    aAdd(aTransf[02],{"D3_LOCAL"  , cTipEstoqueOrigem                  , Nil}) // [04] Armazém origem
    aAdd(aTransf[02],{"D3_LOCALIZ", CriaVar("D3_LOCALIZ")              , Nil}) // [05] Endereço origem
    aAdd(aTransf[02],{"D3_COD"    , cProduto                           , Nil}) // [06] Produto destino
    aAdd(aTransf[02],{"D3_DESCRI" , cDescricao                         , Nil}) // [07] Descrição origem
    aAdd(aTransf[02],{"D3_UM"     , cUM                                , Nil}) // [08] Unidade de medida destino
    aAdd(aTransf[02],{"D3_LOCAL"  , cTipEstoqueDestino                 , Nil}) // [09] Armazém destino
    aAdd(aTransf[02],{"D3_LOCALIZ", CriaVar("D3_LOCALIZ")              , Nil}) // [10] Endereço destino DH1->DH1_LOCALI
    aAdd(aTransf[02],{"D3_NUMSERI", CriaVar("D3_NUMSERI")              , Nil}) // [11] Numero de série
    aAdd(aTransf[02],{"D3_LOTECTL", cLoteOrigem                        , Nil}) // [12] Lote
    aAdd(aTransf[02],{"D3_NUMLOTE", CriaVar("D3_NUMLOTE")              , Nil}) // [13] Sub-Lote
    aAdd(aTransf[02],{"D3_DTVALID", dDataValidadeOrigem                , Nil}) // [14] Data de validade
    aAdd(aTransf[02],{"D3_POTENCI", CriaVar("D3_POTENCI")              , Nil}) // [15] Potencia
    aAdd(aTransf[02],{"D3_QUANT"  , nQuantidade                        , Nil}) // [16] Quantidade
    aAdd(aTransf[02],{"D3_QTSEGUM", ConvUm(cProduto, nQuantidade, 0, 2), Nil}) // [17] Quantidade segunda unidade
    aAdd(aTransf[02],{"D3_ESTORNO", .F.                                , Nil}) // [18] Estorno
    aAdd(aTransf[02],{"D3_NUMSEQ" , CriaVar("D3_NUMSEQ")               , Nil}) // [19] Numero sequencial
    aAdd(aTransf[02],{"D3_LOTECTL", cLoteDestino                       , Nil}) // [20] Lote destino
    aAdd(aTransf[02],{"D3_DTVALID", dDataValidadeDestino               , Nil}) // [21] Data de validade destino
    aAdd(aTransf[02],{"D3_SERVIC" , CriaVar("D3_SERVIC")               , Nil}) // [22] Servico
    aAdd(aTransf[02],{"D3_ITEMGRD", CriaVar("D3_ITEMGRD")              , Nil}) // [23]

    aAdd(aWmsCMov, {"CPROGRAMA", "WMSSAAS"}) 

    If !self:geraMovimentoTransferencia(aTransf, aWmsCMov)
        Return .F.
    EndIf
    // Atribui no convergência o número do documento gerado no SD3 para ligação o identificador SAAS
    self:numeroDocumento := cNumSeq
    self:save()
    self:setFinalizado()
    self:setMensagemIntegracao(STR0005) // Movimento transferência do tipo de estoque gerado com sucesso
Return .T.

/*/{Protheus.doc} getNomePessoa
    (long_description)
    @author user
    @since 24/05/2024
    @version version
    @return cRet, caracter, Retorna vazio por não se tratar de um método obrigatório
    /*/
Method getNomePessoa() Class WMSSaasMovimentoTransferencia as character
Return ""

/*/{Protheus.doc} geraMovimenotransferência
(aCab, aItens)
    @author user
    @since 23/09/2024
    @version version
    @param aCab, array, Cabeçalho da movimentação
    @param aItens, array, Itens para movimentação
    @return lRet, logical, Indica se movimentação foi realizada com sucesso
    /*/
Method geraMovimentoTransferencia(aTransf, aWmsCMov) Class WMSSaasMovimentoTransferencia as logical
Local cPath     := GetSrvProfString("StartPath","")
Local cFile     := NomeAutoLog()
Local cMsgErro  := ""

Private lMsHelpAuto  := .F.
Private lMsErroAuto  := .F.
Private lMsFinalAuto := .F.

    MSExecAuto({|x,y,z| MATA261(x,y,z)}, aTransf, 3, aWmsCMov)

    If lMsErroAuto
        cMsgErro := MostraErro(cPath,cFile)
        self:setErroIntegracao(cMsgErro)
        Return .F.        
    EndIf
Return .T.
