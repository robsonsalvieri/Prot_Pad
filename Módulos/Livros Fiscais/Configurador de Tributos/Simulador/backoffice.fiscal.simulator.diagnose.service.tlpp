#INCLUDE "TLPP-CORE.TH"
#INCLUDE "tlpp-rest.th"
#Include "PROTHEUS.CH" 
#Include "BACKOFFICE.FISCAL.SIMULATOR.DIAGNOSE.SERVICE.CH"

namespace totvs.protheus.backoffice.fiscal.simulator.diagnose.service

/*/{Protheus.doc} DiagnoseService
    Classe responsavel por fornecer os dados de resposta do diagnostico do
    Simulador de Tributos.
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2410
/*/
class DiagnoseService

    Private Data jData as json // json com os dados do cabeçalho e dados dos itens para o calculo
    Private Data cPerfilPart as character
    Private Data cPerfilProd as character
    Private Data cPerfilOD   as character
    Private Data cPerfilCfop as character
    Private Data cRegraCalc  as character
    Private Data cFil        as character
    Private Data cUfFil      as character
    Private Data cUfPart     as character
    Private Data dVigIni     as Date
    Private Data dVigFim     as Date
    Private Data cDiagnose   as character

    Private Data lHasStatus  as logical
    Private Data cStatus     as character

    // métodos construtor 
    Public Method new(jData) Constructor // instancia o objeto inicializando o jData

    // -------------------------métodos abertos para uso-----------------------------------------------

    Public Method runDiagnosisEngine() 
    Public Method setCodPerfis()

    // -------------------------métodos internos-----------------------------------------------
    Private Method consultaDadosF2b(cFil)
    Private Method setCodRegra()
    Private Method setFilial()
    Private Method setUfFil()
    Private Method setUfPart(cCodPart, cLoja, cTipoMov)
    Private Method getParticipantDiagnosis(cCodPart, cLoja, cTipo) as logical
    Private Method getProdDiagnosis(cProduto) as logical
    Private Method getOriProdDiagnosis(cOrig) as logical
    Private Method getCfopDiagnosis(cCf) as logical
    Private Method getOrigDestDiagnosis(cCodPart, cLoja, cTipoMov) as logical

    Private method hasStatus() as logical

endclass


/*/{Protheus.doc} new
    Método construtor da classe.
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2410
    @param jData, json, objeto json contendo o cabeçalho e os itens para calculo.
    @return self, object, instância da classe.
/*/
Method new(jData) class DiagnoseService

    self:jData := jData
    self:cPerfilPart := ""
    self:cPerfilProd := ""
    self:cPerfilOD   := ""
    self:cPerfilCfop := ""
    self:cRegraCalc  := ""
    self:cFil        := ""
    self:cUfFil      := ""
    self:cUfPart     := ""
    self:dVigIni     := ctoD("//")
    self:dVigFim     := ctoD("//")
    self:cDiagnose   := ""

    self:lHasStatus  := self:hasStatus()

return self

/*/{Protheus.doc} runDiagnosisEngine
    Método que executa a busca dos dados para o diagnostico.
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2410
    @return Nil, Nil, sem retorno.
/*/

Method runDiagnosisEngine() class DiagnoseService

Local aItems        := {}  as array
Local jCabec        := Nil as json
Local jItens        := Nil as json
Local jResultQry    := Nil as json
Local jResponse     := Nil as json
Local cPart         := ""  as character
Local cLojaPart     := ""  as character
Local cTipoPart     := ""  as character
Local cTpMov        := ""  as character
Local cProd         := ""  as character
Local cCfop         := ""  as character
Local cOrigem       := ""  as character
Local cItem         := ""  as character
Local dDtOper       := ctod("//") as Date
Local nI  as numeric

//variaveis dos retornos de consulta via ExecScalar

Local lParticip := .T. as logical
Local lProduto  := .T. as logical
Local lCfop     := .T. as logical
Local lOrigProd := .T. as logical
Local lOrigDest := .T. as logical

jCabec := self:jData["cabecalho"]

//Atribuição das variaveis x cabecalho body

cPart     := jCabec["codParticipante"]
cLojaPart := jCabec["lojaParticipante"]
cTipoPart := jCabec["tipoParticipante"]
cTpMov    := jCabec["tipoMovimento"]
dDtOper   := ctoD(jCabec["data"])

self:setCodRegra()
self:setFilial()
self:setCodPerfis()
self:setUfFil()
self:setUfPart(cPart, cLojaPart, cTpMov)

jResponse := JSONObject():New()

//Diagnostico de status da regra
if self:lHasStatus .and. jCabec["regrateste"] <> "T" .and. self:cStatus == "1"
    jResultQry  := JSONObject():New()
    jResultQry["item"]  := " "
    jResultQry["naoconformidade"]   := "Regra de cálculo em fase de teste e opção 'Regras em teste?' da Simulação definido como 'NÃO'"
    jResultQry["regrasdocadastro"]  := "Status da regra com opção '1 - Em teste'"
    jResultQry["dadosdaoperacao"]   := "Opção 'Regras em teste?' da Simulação definido como 'NÃO'"
    jResultQry["sugestaodevalidacao"]  := "Altere a opção 'Regras em teste?' da Simulação para 'SIM'"
    jResultQry["codigodoperfil"]    := "Não se aplica"
    Aadd(aItems, jResultQry)
endif


//Diagnostico de Vigencia da Regra

If !((Empty(self:dVigIni) .Or. self:dVigIni <= dDtOper) .And. (Empty(self:dVigFim) .Or. self:dVigFim >= dDtOper))

    jResultQry  := JSONObject():New()
    jResultQry["item"]  := " "
    jResultQry["naoconformidade"] := STR0001 //"Regra de Cálculo fora da Data de Vigência"
    jResultQry["regrasdocadastro"]  := STR0002//"Data de Vigência da Regra de Cálculo expirada"
    jResultQry["dadosdaoperacao"] := STR0003+DtoC(dDtOper)+STR0004+dtoC(self:dVigIni)+STR0005+dtoC(self:dVigfim)
    //"Data da Operação- "+DtoC(dDtOper)+" Vigência Inicial- "+dtoC(self:dVigIni)+" Vigência Final- "+dtoC(self:dVigfim)
    jResultQry["sugestaodevalidacao"]  := STR0006 //"Atualizar as datas de Vigência da Regra de Cálculo selecionada no diagnóstico"
    jResultQry["codigodoperfil"] := self:cRegraCalc

    Aadd(aItems, jResultQry)

Endif


//Diagnostico de Origem/ Destino da Operação

lOrigDest:= self:getOrigDestDiagnosis(cPart, cLojaPart, cTpMov)

If !lOrigDest

    jResultQry  := JSONObject():New()
    jResultQry["item"]  := " "
    jResultQry["naoconformidade"] := STR0007 //"Origem/Destino da Operação não consta no Perfil da Regra de Cálculo"
    jResultQry["regrasdocadastro"]  := STR0008 //"Origem/Destino precisa estar cadastrado e vinculado ao perfil de Origem/Destino da regra"
    If cTpMov = 'E'
        jResultQry["dadosdaoperacao"] := STR0009+self:cUfPart+STR0010+self:cUfFil //Origem e Destino
    Else
        jResultQry["dadosdaoperacao"] := STR0009+self:cUfFil+STR0010+self:cUfPart //Origem e Destino
    Endif
    jResultQry["sugestaodevalidacao"]  := STR0011+ ;  //"1. Verificar se a Origem/Destino está cadastrado corretamente;"
                                          STR0012+ self:cPerfilOD +STR0013 + self:cRegraCalc //" 2. Incluir a Origem/Destino ao perfil " + self:cPerfilOD + vinculado ao tributo + self:cRegraCalc"
    jResultQry["codigodoperfil"] := self:cPerfilOD

    Aadd(aItems, jResultQry)

Endif

// Diagnostico de Participante
lParticip := self:getParticipantDiagnosis(cPart, cLojaPart, cTipoPart)

If !lParticip

    jResultQry  := JSONObject():New()
    jResultQry["item"]  := " "
    jResultQry["naoconformidade"] := STR0014 //"Participante não está vinculado ao perfil configurado na regra de cálculo"
    jResultQry["regrasdocadastro"]  := STR0015 //"O participante precisa estar cadastrado e vinculado ao perfil de participante da regra"
    jResultQry["dadosdaoperacao"] := STR0016 + cPart + STR0017 + cLojaPart + STR0018 + cTipoPart
                                    //"Participante: " + cPart + " | Loja: " + cLojaPart + " | Tipo: " + cTipoPart
    jResultQry["sugestaodevalidacao"]  := STR0019 + ; //"1. Verificar se o participante está cadastrado corretamente;"
                                          STR0020 + self:cPerfilPart + STR0013 + self:cRegraCalc//" 2. Incluir o participante ao perfil " + self:cPerfilPart + vinculado ao tributo + self:cRegraCalc"
    jResultQry["codigodoperfil"] := self:cPerfilPart


    Aadd(aItems, jResultQry)

Endif

//Diagnostico de Itens

for nI := 1 to len(self:jData["itens"])

        jItens := self:jData["itens"][nI]

        cProd         := jItens["codigo"]
        cCfop         := jItens["cfop"]
        cOrigem       := jItens["origemProduto"]
        cItem         := jItens["item"]

    lProduto := self:getProdDiagnosis(cProd)

    If !lProduto

        jResultQry  := JSONObject():New()
        jResultQry["item"]  := cItem
        jResultQry["naoconformidade"] := STR0021//"Produto não está vinculado ao perfil configurado na regra de cálculo"
        jResultQry["regrasdocadastro"]  := STR0022//"O produto precisa estar cadastrado e vinculado ao perfil de produto da regra"
        jResultQry["dadosdaoperacao"] := STR0023 + cProd + STR0024 + cItem //"Produto: " + cProd + " | Item: " + cItem
        jResultQry["sugestaodevalidacao"]  := STR0025 + ; //"1. Verificar se o produto está cadastrado corretamente;"
                                              STR0026 + self:cPerfilProd + STR0013 + self:cRegraCalc//" 2. Incluir o produto ao perfil " + self:cPerfilProd + " vinculado ao tributo + self:cRegraCalc"
        jResultQry["codigodoperfil"] := self:cPerfilProd

        Aadd(aItems, jResultQry)

    Endif

    lOrigProd:= self:getOriProdDiagnosis(cOrigem)

    If !lOrigProd

        jResultQry  := JSONObject():New()
        jResultQry["item"]  := cItem
        jResultQry["naoconformidade"] := STR0027//"Origem do produto não está configurada no perfil da regra de cálculo"
        jResultQry["regrasdocadastro"]  := STR0028//"A origem do produto deve estar vinculada ao perfil de produto"
        jResultQry["dadosdaoperacao"] := STR0029 + cOrigem + STR0030 + cProd + STR0031 + cItem //"Origem: " + cOrigem + " | Produto: " + cProd + " | Item: " + cItem
        jResultQry["sugestaodevalidacao"]  := STR0032 + ; //"1. Verificar se a origem está correta para o produto;"
                                              STR0033 + cOrigem + STR0034 + self:cPerfilProd + STR0013 + self:cRegraCalc //" 2. Cadastrar a origem " + cOrigem + " no perfil " + self:cPerfilProd + vinculado ao tributo + self:cRegraCalc"
        jResultQry["codigodoperfil"] := self:cPerfilProd

        Aadd(aItems, jResultQry)

    Endif

    lCfop:= self:getCfopDiagnosis(cCfop)

    If !lCfop

        jResultQry  := JSONObject():New()
        jResultQry["item"]  := cItem
        jResultQry["naoconformidade"] := STR0035//"CFOP não está configurado no perfil da regra de cálculo"
        jResultQry["regrasdocadastro"]  := STR0036//"O CFOP deve estar vinculado ao perfil de operação da regra"
        jResultQry["dadosdaoperacao"] := STR0037 + cCfop + STR0038 + cItem //"CFOP: " + cCfop + " | Item: " + cItem
        jResultQry["sugestaodevalidacao"]  := STR0039 + ; //"1. Verificar se o CFOP está correto para a operação;"
                                              STR0040 + cCfop + STR0041 + self:cPerfilCfop + STR0013 + self:cRegraCalc//" 2. Cadastrar o CFOP " + cCfop + " no perfil " + self:cPerfilCfop + vinculado ao tributo + self:cRegraCalc"
        jResultQry["codigodoperfil"] := self:cPerfilCfop

        Aadd(aItems , jResultQry)

    Endif


next nI

//Caso o usuario queira diagnosticar algo que esteja totalmente no perfil
If len(aItems ) = 0

        jResultQry  := JSONObject():New()
        jResultQry["item"]  := cItem
        jResultQry["naoconformidade"] := STR0042 //"Cenário válido"
        jResultQry["regrasdocadastro"]  := STR0043 //"Todos os elementos estão corretamente enquadrados nos perfis"
        jResultQry["dadosdaoperacao"] := STR0044 + self:cRegraCalc + STR0045 + self:cFil //"Regra de cálculo: " + self:cRegraCalc + " | Filial: " + self:cFil
        jResultQry["sugestaodevalidacao"]  := STR0046 //"Nenhuma ação necessária - configuração correta"
        jResultQry["codigodoperfil"] := STR0047 //"OK"

        Aadd(aItems, jResultQry)

Endif

jResponse["items"] := aItems
self:cDiagnose := jResponse:toJson()

aSize(aItems,0)
FwFreeArray(aItems)
FreeObj(jResponse)


Return self:cDiagnose

/*/{Protheus.doc} setCodPerfis
    Faz atribuição nas variaveis da classe referente aos codigos de perfil encontrados na consulta
    da tabela F2B e havendo o mecanismo de aprovação no ambiente, define o status da regra
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2510
    @return Nil, Nil, sem retorno.
/*/
Method setCodPerfis() class DiagnoseService
Local cAlsPerfis := '' as character

cAlsPerfis := self:consultaDadosF2b()

If !Empty(cAlsPerfis)
    While !(cAlsPerfis)->(EOF())

     self:cPerfilPart  := (cAlsPerfis)->F2B_PERFPA
     self:cPerfilProd  := (cAlsPerfis)->F2B_PERFPR
     self:cPerfilOD    := (cAlsPerfis)->F2B_PEROD
     self:cPerfilCfop  := (cAlsPerfis)->F2B_PERFOP
     self:dVigIni      := StoD((cAlsPerfis)->F2B_VIGINI)
     self:dVigFim      := StoD((cAlsPerfis)->F2B_VIGFIM)
     if self:lHasStatus
        self:cStatus   := (cAlsPerfis)->F2B_STATUS
     endif

    (cAlsPerfis)->(DbSkip())
    EndDo
Endif

(cAlsPerfis)->(DbCloseArea())

Return

/*/{Protheus.doc} setCodRegra
    Faz o set do atributo cRegraCalc com o conteudo do json enviado
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2510
    @return Nil, Nil, sem retorno.
/*/
Method setCodRegra() class DiagnoseService
Return self:cRegraCalc := self:jData['cabecalho']['codRegra']

/*/{Protheus.doc} setFilial
    Faz o set do atributo cFil com o conteudo do json enviado
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2510
    @return Nil, Nil, sem retorno.
/*/
Method setFilial() class DiagnoseService
Return  self:cFil := self:jData['cabecalho']['filial']

/*/{Protheus.doc} setUfFil
    Faz o set do atributo cUfFil com o conteudo da tabela SM0
    @author alexandre.esteves
    @since 30/10/2024
    @version 12.1.2510
    @return Nil, Nil, sem retorno.
/*/
Method setUfFil() class DiagnoseService
   self:cUfFil := SM0->M0_ESTENT
Return 

/*/{Protheus.doc} consultaDadosF2b
    Metodo que faz a query que consulta os codigos de perfil de acordo com o
    codigo da regra de calculo
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2510
    @return lRet - Retorna de forma logica se a consulta trouxe algum registro
/*/
Method consultaDadosF2b() class DiagnoseService

Local cAliasF2B := ""   as character
Local cQuery    := ""   as character
Local oQuery    := Nil  as object

cQuery:= " SELECT F2B.F2B_PEROD, F2B.F2B_PERFPA, F2B.F2B_PERFOP, F2B.F2B_PERFPR, F2B.F2B_VIGINI , F2B.F2B_VIGFIM "
if self:lHasStatus
    cQuery += ",F2B_STATUS"
endif
cQuery+= " FROM " + RetSQLName("F2B") + " F2B "
cQuery+= " WHERE F2B_FILIAL = ? "
cQuery+= " AND F2B_REGRA = ? "
cQuery+= " AND F2B.D_E_L_E_T_ = ? "

oQuery:= FwExecStatement():New(cQuery)
oQuery:SetString(1, self:cFil)
oQuery:SetString(2, self:cRegraCalc)
oQuery:SetString(3, " ")


cAliasF2B := oQuery:OpenAlias()


oQuery:Destroy()
oQuery:= Nil
     
Return cAliasF2B

/*/{Protheus.doc} getParticipantDiagnosis

   Metodo que faz a query que consulta do participante de acordo com o Perfil que foi 
   carregado no atributo cPerfilpart
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2410
    @return lRet - Retorna de forma logica se a consulta trouxe algum registro
/*/
Method getParticipantDiagnosis(cCodPart as character, cLoja as character, cTipo as character) as logical class DiagnoseService
    
Local cQuery     := ""   as character
Local cTpPart    := ""   as character
Local cDelet     := " "  as character
Local lRet       := .F.  as logical
Local aBind      := {}   as array
Local cTodosPart := PadR("TODOS", fisTamSX3("F22","F22_CLIFOR")[1]) as character
Local cTodosLoj  := Replicate("Z", fisTamSx3("F22","F22_LOJA")[1])  as character

If cTipo = "F"
    cTpPart := "1"
Else
    cTpPart := "2"
Endif

cQuery:= " SELECT COUNT(F22.F22_CLIFOR) AS CONTADOR "
cQuery+= " FROM " + RetSQLName("F22") + " F22 "
cQuery+= " WHERE F22_FILIAL = ? "
cQuery+= " AND F22_CODIGO = ? "
cQuery+= " AND F22_TPPART = ? "
cQuery+= " AND ((F22.F22_CLIFOR = ? AND F22.F22_LOJA = ?) OR (F22.F22_CLIFOR = ? AND F22.F22_LOJA = ?))"
cQuery+= " AND F22.D_E_L_E_T_ = ? "

aBind := {self:cFil,self:cPerfilPart,cTpPart,cCodPart,cLoja,cTodosPart,cTodosLoj,cDelet}

lRet := !Empty(MpSysExecScalar(changeQuery(cQuery),"CONTADOR",aBind))

aSize(aBind,0)
aBind := nil

Return lRet

/*/{Protheus.doc} getProdDiagnosis

   Metodo que faz a query que consulta do Produto de acordo com o Perfil que foi 
   carregado no atributo cPerfilProd
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2410
    @return lRet - Retorna de forma logica se a consulta trouxe algum registro
/*/
Method getProdDiagnosis(cProduto as character) as logical class DiagnoseService
    
Local cQuery    := ""   as character
Local cDelet    := " "  as character
Local lRet      := .F.  as logical
Local aBind     := {}   as array
Local cTodosPart:= PadR("TODOS", fisTamSX3("F22","F22_CLIFOR")[1]) as character

cQuery:= " SELECT COUNT(F24.F24_CDPROD) AS CONTADOR "
cQuery+= " FROM " + RetSQLName("F24") + " F24 "
cQuery+= " WHERE F24_FILIAL = ? "
cQuery+= " AND F24_CODIGO = ? "
cQuery+= " AND ((F24.F24_CDPROD = ?) OR (F24.F24_CDPROD = ?))
cQuery+= " AND F24.D_E_L_E_T_ = ? "

aBind := {self:cFil,self:cPerfilProd,cProduto,cTodosPart,cDelet}

lRet := !Empty(MpSysExecScalar(changeQuery(cQuery),"CONTADOR",aBind))

aSize(aBind,0)
aBind := nil

Return lRet

/*/{Protheus.doc} getOriProdDiagnosis

   Metodo que faz a query que consulta da Origem do Produto de acordo com o Perfil que foi 
   carregado no atributo cPerfilProd
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2410
    @return lRet - Retorna de forma logica se a consulta trouxe algum registro
/*/
Method getOriProdDiagnosis(cOrig as character) as logical class DiagnoseService
    
Local cQuery    := ""   as character
Local cDelet    := " "  as character
Local lRet      := .F.  as logical
Local aBind     := {}   as array

cQuery:= " SELECT COUNT(F25.F25_ORIGEM) AS CONTADOR "
cQuery+= " FROM " + RetSQLName("F25") + " F25 "
cQuery+= " WHERE F25_FILIAL = ? "
cQuery+= " AND F25_CODIGO = ? "
cQuery+= " AND F25_ORIGEM = ? "
cQuery+= " AND F25.D_E_L_E_T_ = ? "

aBind := {self:cFil,self:cPerfilProd,cOrig,cDelet}

lRet := !Empty(MpSysExecScalar(changeQuery(cQuery),"CONTADOR",aBind))

aSize(aBind,0)
aBind := nil

Return lRet

/*/{Protheus.doc} getCfopDiagnosis

   Metodo que faz a query que consulta do CFOP da operação de acordo com o Perfil que foi 
   carregado no atributo cPerfilCfop
    @author alexandre.esteves
    @since 23/10/2024
    @version 12.1.2410
    @return lRet - Retorna de forma logica se a consulta trouxe algum registro
/*/
Method getCfopDiagnosis(cCf as character ) as logical class DiagnoseService
    
Local cQuery    := ""   as character
Local cDelet    := " "  as character
Local lRet      := .F.  as logical
Local aBind     := {}   as array

cQuery:= " SELECT COUNT(F23.F23_CFOP) AS CONTADOR "
cQuery+= " FROM " + RetSQLName("F23") + " F23 "
cQuery+= " WHERE F23_FILIAL = ? "
cQuery+= " AND F23_CODIGO = ? "
cQuery+= " AND F23_CFOP = ? "
cQuery+= " AND F23.D_E_L_E_T_ = ? "

aBind := {self:cFil,self:cPerfilCfop,cCf,cDelet}

lRet := !Empty(MpSysExecScalar(changeQuery(cQuery),"CONTADOR",aBind))

aSize(aBind,0)
aBind := nil

Return lRet

/*/{Protheus.doc} getOrigDestDiagnosis

   Metodo que faz a query que consulta da origem/Destino de acordo com o Perfil que foi 
   carregado no atributo cPerfilOD e também de acordo com o tipo de movimento
    @author alexandre.esteves
    @since 30/10/2024
    @version 12.1.2410
    @return lRet - Retorna de forma logica se a consulta trouxe algum registro
/*/
Method getOrigDestDiagnosis(cCodPart as character, cLoja as character, cTipoMov as character)  as logical class DiagnoseService
    
Local cQuery    := ""   as character
Local cDelet    := " "  as character
Local lRet      := .F.  as logical
Local aBind     := {}   as array

cQuery:= " SELECT COUNT(F21.F21_CODIGO) AS CONTADOR "
cQuery+= " FROM " + RetSQLName("F21") + " F21 "
cQuery+= " WHERE F21_FILIAL = ? "
cQuery+= " AND F21_CODIGO = ? "
cQuery+= " AND F21_UFORI = ? "
cQuery+= " AND F21_UFDEST = ? "
cQuery+= " AND F21.D_E_L_E_T_ = ? "

If cTipoMov = 'E'
    aBind := {self:cFil,self:cPerfilOD,self:cUfPart,self:cUfFil,cDelet}
Else
    aBind := {self:cFil,self:cPerfilOD,self:cUfFil,self:cUfPart,cDelet}
Endif

lRet := !Empty(MpSysExecScalar(changeQuery(cQuery),"CONTADOR",aBind))

aSize(aBind,0)
aBind := nil

Return lRet

/*/{Protheus.doc} setUfPart

   Metodo que faz consulta da UF do participante
    @author alexandre.esteves
    @since 30/10/2024
    @version 12.1.2410
    @return cAlias - Resultado da consulta
/*/
Method setUfPart(cCodPart as character, cLoja as character, cTipoMov as character) class DiagnoseService
    
Local cAliasUF  := ""   as character
Local cQuery    := ""   as character
Local oQuery    := Nil  as object

IF cTipoMov = 'E'

    cQuery:= " SELECT SA2.A2_EST AS UF "
    cQuery+= " FROM " + RetSQLName("SA2") + " SA2 "
    cQuery+= " WHERE SA2.A2_FILIAL = ? "
    cQuery+= " AND SA2.A2_COD = ? "
    cQuery+= " AND SA2.A2_LOJA = ? "
    cQuery+= " AND SA2.D_E_L_E_T_ = ? "

Else
    cQuery:= " SELECT SA1.A1_EST AS UF "
    cQuery+= " FROM " + RetSQLName("SA1") + " SA1 "
    cQuery+= " WHERE SA1.A1_FILIAL = ? "
    cQuery+= " AND SA1.A1_COD = ? "
    cQuery+= " AND SA1.A1_LOJA = ? "
    cQuery+= " AND SA1.D_E_L_E_T_ = ? "

Endif

oQuery:= FwExecStatement():New(cQuery)


If cTipoMov= 'E'
    oQuery:SetString(1, xFilial("SA2", self:cFil))
Else
    oQuery:SetString(1, xFilial("SA1", self:cFil))
Endif
oQuery:SetString(2, cCodPart)
oQuery:SetString(3, cLoja)
oQuery:SetString(4, " ")

cAliasUF := oQuery:OpenAlias()


If !Empty(cAliasUF)
    While !(cAliasUF)->(EOF()) 
    
            self:cUfPart := (cAliasUf)->UF
        
        (cAliasUF)->(DbSkip())
    EndDo
EndIf

oQuery:Destroy()
oQuery:= Nil
(cAliasUF)->(DbCloseArea())

Return 

/*/{Protheus.doc} hasStatus
    Verifica se há a propriedade "regrateste".
    @author anedino.santos
    @since 16/05/2025
    @version 12.1.2510
    @return lRet, logical, flag que identifica se no json enviado tem a chave "regrateste"
/*/
Method hasStatus() as logical class DiagnoseService
Return F2B->(FieldPos("F2B_STATUS")) > 0 .and. self:jData["cabecalho"]:hasProperty("regrateste")

