/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

#INCLUDE "FISXAPUR.CH"
#INCLUDE "FWCOMMAND.CH"
#Include "Protheus.ch"
#Include "RwMake.ch"
#Include "FwBrowse.ch"
#Include "FwMvcDef.ch"
#Include "MATA95xDef.ch"

#DEFINE PULALINHA Chr(13) + Chr(10)

STATIC aApurSX2		:=	LoadX2Apur()
STATIC aApurSX3		:=	LoadX3Apur()
STATIC aExistBloc	:=	LoadPEApur()
STATIC aFindFunc	:=  LoadXFFApur()	

STATIC aDadSF6 :={}
STATIC aChaveCDA := {}
STATIC dDtEmiIPI := cTod("  /  /    ")// Data de emissão do titulo referente a IPI
STATIC lRefazApur:= .F.
STATIC lExistF2B := aApurSX2[AI_F2B]
STATIC lExistCJ4 := aApurSX2[AI_CJ4]
STATIC __aPrepared := {}
Static cStart    := Time()



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ResumeF3 ³ Autor ³ Juan Jose Pereira     ³ Data ³ 29/03/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Le SF3 gerando array com apuracao de imposto para periodo  ³±±
±±³          ³ escolhido                                                  ³±± 
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION ResumeF3(cImp		,; 	// 1 - Imposto <"IC"MS|"IP"I|"IS"S>
		  dDtIni	,; 	// 2 - Dt Inicio da Apuracao
	 	  dDtFim	,; 	// 3 - Dt Final da Apuracao
		  cNrLivro	,;	// 4 - Numero do Livro
	 	  lQbAliq	,;	// 5 - Quebra por Aliquota
		  lQbCFO	,;	// 6 - Quebra por CFO
		  nRegua	,;	// 7 - 0=Nao Exibe 1=Processamento 2=Relatorio
		  lEnd		,;	// 8 - Flag de Interrup‡„o
		  nConsFil	,;	// 9 - Considera filial
		  cFilDe	,;	// 10 - Filial De
		  cFilAte	,;	// 11 - Filial ate
		  aEntr		,;	// 12 - array com o resumo de ICMS Retido para entrada	 
		  aSaid		,;  // 13 - array com o resumo de ICMS Retido para saida
		  cFilUsr	,;	// 14 - 
		  lGeraArq	,;	// 15 - Gera Arquivo de Trabalho
		  cAliasTRB ,;	// 16 - 
		  lQbUF		,; 	// 17 - Quebra por UF	
		  lQbPais	,;	// 18 - Quebra por Código do Pais	
		  lQbCfopUf	,;	// 19 - Quebra por CFOP+UF e por "Aliquota" caso necessite, mas somente se "lQbUF" e "lQbPais" forem .F.
		  lImpCrdSt ,;	// 20 - 
		  lMv_UFSt  ,;	// 21 - 
		  lCrdEst   ,;	// 22 - 
		  aEstimulo ,;	// 23 - 
  		  lQbUfCfop ,;	// 24 - Quebra por UF+CFOP
  		  lConsUF	,;	// 25 - Indica se, quando a apuracao for consolidada, apenas as filiais estabelecidas no mesmo estado do consolidador sejam processadas
  		  aApurCDA	,;	// 26 - Array para armazenar lancamentos da apuracao ICMS gravados no CDA
  		  aApurF3	,;	// 27 - Array para armazenar lancamentos da apuracao ICMS gravados no SF3
  		  aCDAIC	,;	// 28 - Array para armazenar lancamentos de ajustes da apuracao ICMS gravados no CDA
  		  aCDAST	,;	// 29 - Array para armazenar lancamentos de ajustes da apuracao ICMS-ST gravados no CDA
  		  cChamOrig ,; 	// 30 - Funcao que esta chamando
  		  nParPerg	,;	// 31 - Parametro da pergunta
  		  aFilsCalc	,;	// 32 - Array das Filiais Selecionadas
  		  aApurMun  ,;	// 33 - Array com os valores de ISS por municipio
		  lICMDes   ,;	// 34 - Indica se havera calculo Credito ICMS Relat. Art.271 RICMS/SP		   
		  aIcmPago  ,;	// 35 - Array para armazenar valores de GNRE ja pagos na emissao do documento
		  lICMGar,;   	// 36 - Indica se havera calculo Credito ICMS Garantido Relat. Art.435-N RICMS/MT
		  aCDADE,;		// 37 - Array contendo os lancamentos de debitos especiais
		  aRetEsp,;		// 38 - Array que me retorna o lancamento de documento fiscal que corresponde ao valor do ST-Debitado na entrada (_CREDST=3)
		  lGiaRs,;		// 39 - Identifica se o arquivo de geracao eh o GIARS
		  nCredMT,;    	// 40 - Indica se calculo Credito Presumido MT
		  nOpcApur,;	// 41 - Flag de tratamento na geracao do TEMPDB da Apuracao. 1=Refaz Movimento Tabela, 2=Apaga Tabela, 3=Leitura da Tabela
		  lMultThr,;	// 42 - Indica se a apuracao deve ser reprocessada quando um arquivo magnetico necessita que a apuracao tenha uma quebra diferente
		  aConv139,; 	// 43 - Array vom valores e informações do Convênio 139/06
		  aRecStDif,;   // 44 -
		  aMensIPI,;    // 45 - Array com mensagens de IPI da Apuração
		  aDifal,;      //46 - Array com informações da apuração do DIFAL
		  aCDADifal,;	//47 - Array com lançamentos da CDA do DIFAL	
		  lAutomato,;	//48 - Script de teste
		  aCDAExtra,;	//49 - LAnçamentos de Extra apuração
		  aApurExtra,;	//50 - Extra Apuração
		  aApurCDV,;    //51 - Array com lançamentos da CDV dos valores declaratórios
		  aCDAIPI,;		//52 - Codigo de ajuste para Apuração de IPI
		  aNWCredAcu,;	//53 - Credito acumulado
		  lProcRefer,;  //54 - Utiliza Processo Referenciado
		  cTempDeb,; 	//55
		  cTempCrd,; 	//56
		  cTempSTd,; 	//57
		  cTempSTe,; 	//58
		  cTempIPIs,;   //59
		  cTempIPIe)   //60
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ„¿
//³O parametro lMultThr, permite reprocessar a apuracao sem multi thread, ele foi criado para atender a seguinte situacao: ³
//³Existem alguns arquivos magneticos que necessitam que a apuracao seja agrupada de uma forma diferente.                  ³
//³Por exemplo, a quebra deve ser realizada por Pais e nao por CFOP.                                                       ³
//³Desta forma, seria necessario reprocessar a apuracao, porem sem gravar a tabela temporaria.                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ„Ù

Local	lMVRF3THRE	:=	.F.
Local	lViewAp		:=	.F.
Local	bRunResF3


DEFAULT	nCredMT		:=	Nil						  
DEFAULT	nOpcApur	:=	1
DEFAULT lMultThr	:= GetNewPar( 'MV_RF3THRE' , .F. ) 
DEFAULT	aConv139	:= {}
DEFAULT	aRecStDif	:= {}
DEFAULT aMensIPI	:= {}
DEFAULT aDifal		:= {}
DEFAULt aCDADifal	:= {}
Default aCDAExtra	:= {}
Default aApurExtra	:= {}
DEFAULT aApurCDV	:= {}
DEFAULT aCDAIPI		:= {}
DEFAULT aNWCredAcu	:=	{}
DEFAULT lAutomato 	:= .F.
DEFAULT lProcRefer	:= .F.
DEFAULT cTempDeb	:= "ICMSDEBITO"+AllTrim(Str(ThreadID()))
DEFAULT cTempCrd	:= "ICMSCREDITO"+AllTrim(Str(ThreadID()))
DEFAULT cTempSTd	:= "STDEBITO"+AllTrim(Str(ThreadID()))
DEFAULT cTempSTe	:= "STCREDITO"+AllTrim(Str(ThreadID()))
DEFAULT cTempIPIs	:= "IPIDEBITO"+AllTrim(Str(ThreadID()))
DEFAULT cTempIPIe	:= "IPICREDITO"+AllTrim(Str(ThreadID()))

bRunResF3	:=	{|| XApurRF3(cImp,; 	// 1 - Imposto <"IC"MS|"IP"I|"IS"S>
						  dDtIni	,; 	// 2 - Dt Inicio da Apuracao
					 	  dDtFim	,; 	// 3 - Dt Final da Apuracao
						  cNrLivro	,;	// 4 - Numero do Livro
					 	  lQbAliq	,;	// 5 - Quebra por Aliquota
						  lQbCFO	,;	// 6 - Quebra por CFO
						  nRegua	,;	// 7 - 0=Nao Exibe 1=Processamento 2=Relatorio
						  lEnd		,;	// 8 - Flag de Interrup‡„o
						  nConsFil	,;	// 9 - Considera filial
						  cFilDe	,;	// 10 - Filial De
						  cFilAte	,;	// 11 - Filial ate
						  aEntr		,;	// 12 - array com o resumo de ICMS Retido para entrada	 
						  aSaid		,;  // 13 - array com o resumo de ICMS Retido para saida
						  cFilUsr	,;	// 14 - 
						  lGeraArq	,;	// 15 - Gera Arquivo de Trabalho
						  cAliasTRB ,;	// 16 - 
						  lQbUF		,; 	// 17 - Quebra por UF	
						  lQbPais	,;	// 18 - Quebra por Código do Pais	
						  lQbCfopUf	,;	// 19 - Quebra por CFOP+UF e por "Aliquota" caso necessite, mas somente se "lQbUF" e "lQbPais" forem .F.
						  lImpCrdSt ,;	// 20 - 
						  lMv_UFSt  ,;	// 21 - 
						  lCrdEst   ,;	// 22 - 
						  aEstimulo ,;	// 23 - 
				  		  lQbUfCfop ,;	// 24 - Quebra por UF+CFOP
				  		  lConsUF	,;	// 25 - Indica se, quando a apuracao for consolidada, apenas as filiais estabelecidas no mesmo estado do consolidador sejam processadas
				  		  aApurCDA	,;	// 26 - Array para armazenar lancamentos da apuracao ICMS gravados no CDA
				  		  aApurF3	,;	// 27 - Array para armazenar lancamentos da apuracao ICMS gravados no SF3
				  		  aCDAIC	,;	// 28 - Array para armazenar lancamentos de ajustes da apuracao ICMS gravados no CDA
				  		  aCDAST	,;	// 29 - Array para armazenar lancamentos de ajustes da apuracao ICMS-ST gravados no CDA
				  		  cChamOrig ,; 	// 30 - Funcao que esta chamando
				  		  nParPerg	,;	// 31 - Parametro da pergunta
				  		  aFilsCalc	,;	// 32 - Array das Filiais Selecionadas
				  		  aApurMun  ,;	// 33 - Array com os valores de ISS por municipio
						  lICMDes   ,;	// 34 - Indica se havera calculo Credito ICMS Relat. Art.271 RICMS/SP		   
						  aIcmPago  ,;	// 35 - Array para armazenar valores de GNRE ja pagos na emissao do documento
						  lICMGar,;   	// 36 - Indica se havera calculo Credito ICMS Garantido Relat. Art.435-N RICMS/MT
						  aCDADE,;		// 37 - Array contendo os lancamentos de debitos especiais
						  aRetEsp,;		// 38 - Array que me retorna o lancamento de documento fiscal que corresponde ao valor do ST-Debitado na entrada (_CREDST=3)
						  lGiaRs,;		// 39 - Identifica se o arquivo de geracao eh o GIARS
						  nCredMT,;		// 40 - Indica se calculo Credito Presumido MT
						  @aConv139,; 	// 41 - Array com informações e valores do convenio 139/06
						  @aRecStDif,;  // 42 - Array com informações e valores do produtos enquadrados no Decreto nº 59.967						   
						  @aMensIPI,; 
						  @aDifal,;
						  @aCDADifal,;						  
						  @aCDAExtra,;
						  @aApurExtra,;
						  @aApurCDV,;
						  @aCDAIPI,;	//49 - Array Codigo ajuste para Apuração de IPI
						  @aNWCredAcu,; //50 - credito acumulado
						  lProcRefer,; //51 - Utiliza Processos Referenciados
						  cTempDeb,; //52
						  cTempCrd,; //53
						  cTempSTd,; //54
						  cTempSTe,; //55
						  cTempIPIs,; //56
						  cTempIPIe)} //57

lMVRF3THRE := Iif (lMultThr == .T. .And. GetNewPar( 'MV_RF3THRE' , .F. ) == .F., .F.,lMultThr)

/*
Na impressao do relatorio de apuracao de IPI (MATR943) caso o usuario configure um
filtro personalizado a flag lMVRF3THRE deverá ser .F. pois nao posso ler as tabelas
gravadas pelo MT, uma vez que o filtro não se aplica às temporárias. Assim, seto
a flag como .F. para que a chamada de ResumeF3 seja feita com o MT desligado, aplicando
o filtro no laco de SF3 na funcao XApurRF3.
*/
If cImp == "IP" .And. lMVRF3THRE .And. IsInCallStack('MATR943') .And. !Empty(cFilUsr)
	lMVRF3THRE := .F.
ElseIf IsInCallStack('U_MATRAPR')
	lMVRF3THRE := .T.
EndIf   

nCredMT		:=	Iif( ValType( nCredMT ) <> "N" , Nil , nCredMT )
aChaveCDA   := {}
 
#IFDEF TOP
    If TcSrvType()<>"AS/400" .And. lMVRF3THRE
		//MATA950
		// srf0313e.ini, srf0313f.ini, srf042.ini, srf325b.ini, diap.ini, dmspdf.ini, gimdf.ini, dpigo.ini, srf194b.ini, giams.ini
		// diefpa.ini, gimpb03.ini, gimpb04.ini, gimpb05.ini, gimpb06.ini, giarj.ini, gimm.ini, giamro.ini, giars.ini, gisrs.ini
		// gisrs03.ini, gmb2004.ini, diefsc.ini, giasc.ini
		
		//OUTROS
		// Funcao: sfRetCfop --- Fonte: diads.prw
		// Funcao: sfRetCfop --- Fonte:  diefes.prw
		// Funcao: ValDIEF ----- Fonte: diefsc.prw
		// Funcao: DIMESC ------ Fonte: dimesc.prw
		// Funcao: AglutUFS ---- Fonte: dpigo.prw
		// Funcao: FISP010 ----- Fonte: fisp010.prw
		// Funcao: FISPGDW ----- Fonte: FISPGDW.prw  
		// Funcao: GerarApur --- Fonte: giamt.prw
		// Funcao: ProcRegB ---- Fonte: giamto.prw
		// Funcao: a953Apura --- Fonte: mata953.prx
		// Funcao: a954Apura --- Fonte: mata954.prx
		// Funcao: Matr915 ----- Fonte: Matr915.prw
		// Funcao: MATR941 ----- Fonte: MATR941.prx
		// Funcao: MATR943 ----- Fonte: MATR943.prx
		// Funcao: R944Imp ----- Fonte: matr944.prx
		// Funcao: FsGmb2004 --- Fonte: matxmag.prx
		// Funcao: SRF396B ----- Fonte: SRF396.prw
		// Funcao: ReportPrint - Fonte: matrapr.prx
		// Funcao: RptDetail --- Fonte: modp8.prx
		// Funcao: RptDetail --- Fonte: modp9.prx
		lViewAp		:=	TcCanOpen( XApNmTDBR3( cImp , dDtIni , dDtFim ) ) .And.;	//Se a tabela existir e for de uma das rotinas previstas, a opcao deverah ser de visualizacao sempre 
						( IsInCallStack('DIADS') .Or. ;	
						IsInCallStack('DIEFES') .Or. ;
						IsInCallStack('DIEFSC') .Or. ;
						IsInCallStack('DIMESC') .Or. ;
						IsInCallStack('DPIGO') .Or. ;
						IsInCallStack('FISP010') .Or. ;
						IsInCallStack('FISPGDW') .Or. ;
						IsInCallStack('GIAMT') .Or. ;
						IsInCallStack('GIAMTO') .Or. ;
						IsInCallStack('MATR915') .Or. ;
						(IsInCallStack('MATR941') .And. !(lQbAliq .And. lMVRF3THRE)) .Or. ; //Quando quebrar por aliquota com multi-thread, reprocessar apuração.
						IsInCallStack('MATR943') .Or. ;
						IsInCallStack('MATR944') .Or. ;
						IsInCallStack('MATXMAG') .Or. ;
						IsInCallStack('SRF396') .Or. ;
						IsInCallStack('MATA950') .Or. ;
						IsInCallStack('MATRAPR') .Or. ;
						IsInCallStack('MODP8') .Or. ;
						IsInCallStack('MODP9').Or. ;
						IsInCallStack('MATA940') )
    
	    nOpcApur	:=	Iif( lViewAp , 3 , nOpcApur )	//Tratamento para que quando for das rotinas que necessitam somente apresentar o que foi calculado,
														// ganhe performance somente visualizando as informacoes.

    	//Nova rotina, novo fonte, FISXAPURA.PRW
		bRunResF3	:=	{|| XApurRF3Nw(cImp,; 	// 1 - Imposto <"IC"MS|"IP"I|"IS"S>
							  dDtIni	,; 	// 2 - Dt Inicio da Apuracao
						 	  dDtFim	,; 	// 3 - Dt Final da Apuracao
							  cNrLivro	,;	// 4 - Numero do Livro
						 	  lQbAliq	,;	// 5 - Quebra por Aliquota
							  lQbCFO	,;	// 6 - Quebra por CFO
							  nRegua	,;	// 7 - 0=Nao Exibe 1=Processamento 2=Relatorio
							  lEnd		,;	// 8 - Flag de Interrup‡„o
							  nConsFil	,;	// 9 - Considera filial
							  cFilDe	,;	// 10 - Filial De
							  cFilAte	,;	// 11 - Filial ate
							  aEntr		,;	// 12 - array com o resumo de ICMS Retido para entrada	 
							  aSaid		,;  // 13 - array com o resumo de ICMS Retido para saida
							  cFilUsr	,;	// 14 - 
							  lGeraArq	,;	// 15 - Gera Arquivo de Trabalho
							  cAliasTRB ,;	// 16 - 
							  lQbUF		,; 	// 17 - Quebra por UF	
							  lQbPais	,;	// 18 - Quebra por Código do Pais	
							  lQbCfopUf	,;	// 19 - Quebra por CFOP+UF e por "Aliquota" caso necessite, mas somente se "lQbUF" e "lQbPais" forem .F.
							  lImpCrdSt ,;	// 20 - 
							  lMv_UFSt  ,;	// 21 - 
							  lCrdEst   ,;	// 22 - 
							  aEstimulo ,;	// 23 - 
					  		  lQbUfCfop ,;	// 24 - Quebra por UF+CFOP
					  		  lConsUF	,;	// 25 - Indica se, quando a apuracao for consolidada, apenas as filiais estabelecidas no mesmo estado do consolidador sejam processadas
					  		  aApurCDA	,;	// 26 - Array para armazenar lancamentos da apuracao ICMS gravados no CDA
					  		  aApurF3	,;	// 27 - Array para armazenar lancamentos da apuracao ICMS gravados no SF3
					  		  aCDAIC	,;	// 28 - Array para armazenar lancamentos de ajustes da apuracao ICMS gravados no CDA
					  		  aCDAST	,;	// 29 - Array para armazenar lancamentos de ajustes da apuracao ICMS-ST gravados no CDA
					  		  cChamOrig ,; 	// 30 - Funcao que esta chamando
					  		  nParPerg	,;	// 31 - Parametro da pergunta
					  		  aFilsCalc	,;	// 32 - Array das Filiais Selecionadas
					  		  aApurMun  ,;	// 33 - Array com os valores de ISS por municipio
							  lICMDes   ,;	// 34 - Indica se havera calculo Credito ICMS Relat. Art.271 RICMS/SP		   
							  aIcmPago  ,;	// 35 - Array para armazenar valores de GNRE ja pagos na emissao do documento
							  lICMGar,;   	// 36 - Indica se havera calculo Credito ICMS Garantido Relat. Art.435-N RICMS/MT
							  aCDADE,;		// 37 - Array contendo os lancamentos de debitos especiais
							  aRetEsp,;		// 38 - Array que me retorna o lancamento de documento fiscal que corresponde ao valor do ST-Debitado na entrada (_CREDST=3)
							  lGiaRs,;		// 39 - Identifica se o arquivo de geracao eh o GIARS
	  						  nCredMT,;    	// 40 - Indica se calculo Credito Presumido MT
							  nOpcApur,;	// 41 - Flag de tratamento na geracao do TEMPDB da Apuracao. 1=Refaz Movimento Tabela, 2=Apaga Tabela, 3=Leitura da Tabela
							  @aConv139,;	// 42 - Array com informações e valores do convenio 139/06
						  	  @aRecStDif,;  // 43 - Array com informações e valores do produtos enquadrados no Decreto nº 59.967						  	  
						  	  @aMensIPI,;
						  	  @aDifal,;
						  	  @aCDADifal,;
						  	  lAutomato,;
						  	  @aCDAExtra,;
						  	  @aApurExtra,;
						  	  @aApurCDV ,;
							  @aCDAIPI,;
							  @aNWCredAcu,;//52 - Credito acumulado
							  lProcRefer,; //53 - Utiliza processos referenciados
							  cTempDeb,; //54
							  cTempCrd,; //55
							  cTempSTd,; //56
							  cTempSTe,; //57
							  cTempIPIs,; //58
							  cTempIPIe)} //59
    EndIf
#ENDIF

Return Eval( bRunResF3 )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM DA FUNCAO                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ aGetApur ³ Autor ³ Juan Jose Pereira     ³ Data ³ 02/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria Array para digitacao de dados para apuracao           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function aGetApur(cImp,dDtIni,dDtFim,aMensIPI)
Local nX            := 0
Local lEstCred := GetNewPar("MV_ESCRIPI",.F.)
Local nY       :=0
Local lUsaSped := SuperGetMv("MV_USASPED",,.T.) .And. aApurSX2[AI_CDP]  .And. aApurSX2[AI_CCK] 
Local aRetIPI  := {}
Local lDesIpiAtacad	:= GetNewPar( "MV_IPIATAC",.F.) //Indica se deve desabilitar o tratamento automátivo do valor de IPI atacadista na linha 005 da apuração de IPI
Local lMGETAPUR:= aExistBloc[PE_MGETAPUR]
Local nTamDesc := TamSx3("CDP_DESC")[1]

Default aMensIPI := {}
Default dDtIni := Ctod("//")
Default dDtFim := Ctod("//")
/*/
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³TD - Totalizadores                   ³
//³SG - Permite a edição dos valores    ³
//³NG - Não permite a edição dos valores³ 
//³FL - Descrição Título                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/

Do Case
	Case cImp=="IC"
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"   ",STR0002,0,"FL"}) //"            D‚bito do Imposto                 "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"001",STR0003,0,"SG"}) //"Por sa¡das/presta‡”es com d‚bito do imposto   "
		AADD(aGetApur,{"002",STR0004,0,"TD"}) //"Outros d‚bitos                                "
		AADD(aGetApur,{"003",STR0005,0,"TD"}) //"Estornos de cr‚ditos                          "
		AADD(aGetApur,{"004",STR0006,0,"NG"}) //"Total                                         "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"   ",STR0007,0,"FL"}) //"            Cr‚dito do Imposto                "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"005",STR0008,0,"SG"}) //"Por entradas/aquisi‡”es com cr‚dito do imposto"
		AADD(aGetApur,{"006",STR0009,0,"TD"}) //"Outros cr‚ditos                               "
		AADD(aGetApur,{"007",STR0010,0,"TD"}) //"Estornos de d‚bitos                           "
		AADD(aGetApur,{"008",STR0011,0,"NG"}) //"Subtotal                                      "
		AADD(aGetApur,{"009",STR0012,0,"SG"}) //"Saldo credor do per¡odo anterior              "
		AADD(aGetApur,{"010",STR0006,0,"NG"}) //"Total                                         "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"   ",STR0013,0,"FL"}) //"            Apura‡„o do Saldo                 "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"011",STR0014,0,"NG"}) //"Saldo devedor (D‚bito-Cr‚dito)                "
		AADD(aGetApur,{"012",STR0015,0,"TD"}) //"Dedu‡”es                                      "
		AADD(aGetApur,{"013",STR0016,0,"NG"}) //"Imposto a recolher                            "
		AADD(aGetApur,{"014",STR0017,0,"NG"}) //"Saldo credor (Cr‚dito-D‚bito)                 "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"   ",STR0018,0,"FL"}) //"         Informa‡”es Complementares           "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"015",STR0019,0,"NG"}) //"ICMS Retido (Sa¡das-Devolucoes)               "
		AADD(aGetApur,{"016",STR0020,0,"NG"}) //"ICMS Complementar (Diferencial de Aliquotas)  "
		AADD(aGetApur,{"017",STR0021,0,"NG"}) //"ICMS Retido (Devolucoes de Vendas)            "
		AADD(aGetApur,{"018",STR0068,0,"NG"}) //"ICMS Diferido"		
		AADD(aGetApur,{"019",STR0066,0,"NG"}) //"ICMS Complementar (Ativo Imobilizado)         " 
		AADD(aGetApur,{"020",STR0067,0,"NG"}) //"ICMS Complementar (Mat. Uso ou Consumo)       "
		AADD(aGetApur,{"021",STR0064,0,"NG"}) //"Transf. de Credito				               "
		AADD(aGetApur,{"022",STR0065,0,"NG"}) //"Transf. de Debito							   "
	Case cImp=="IP"
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"   ",STR0022,0,"FL"}) //"       Demonstrativo de Cr‚ditos              "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"001",STR0023,0,"SG"}) //"Por entradas do mercado nacional              "
		AADD(aGetApur,{"002",STR0024,0,"SG"}) //"Por entradas do mercado externo               "
		AADD(aGetApur,{"003",STR0025,0,"SG"}) //"Por sa¡das para o mercado externo             "
		AADD(aGetApur,{"004",STR0010,0,"TD"}) //"Estornos de d‚bitos                           "
		For nX:=1 to Len(aDadIC) 
			If aDadIC[nX][1]=="004"
				AADD(aGetApur,{"004",alltrim(PADR(aDadIC[nX][2],nTamDesc)),0,"DD"})
			Endif
		Next nX
		If lMGETAPUR
			aGetApur := ExecBlock("MGETAPUR",.F.,.F.,{"004",aGetApur})
		EndIf
		AADD(aGetApur,{"005",STR0009,0,"TD"}) //"Outros cr‚ditos                               "		
		
		
		
		// Adiciona ajuste da apuração anterior.		
		For nX:=1 to Len(aDadIC) 
			If aDadIC[nX][1]=="005"
				AADD(aGetApur,{"005",alltrim(PADR(aDadIC[nX][2],nTamDesc)),0,"DD"})
			Endif
		Next nX
		
		IF !lDesIpiAtacad   //VErifica se este tratamento legado foi desabilitado pelo usuário
			nPos:=Ascan(aGetApur,{|x|x[1]=="005".and. STR0133$x[2]})
			If nPos == 0
				AADD(aGetApur,{"005",STR0133,0,"DD"}) //"Comerciante não Atacadista                    "
			Endif
		
		EndIF
		
		// Tratamento de Mensagens da Apuração de IPI a partir da TES
		For nX:=1 To Len(aMensIPI)
			If SX5->(MsSeek(xFilial('SX5')+'87'+aMensIPI[nX,2]))
				nPos:=Ascan(aGetApur,{|x|x[1]=="005".and. SX5->X5_DESCRI$x[2]})
				If nPos == 0
					AADD(aGetApur,{"005",SX5->X5_DESCRI,0,"DD"})
				Endif
			Endif
		Next nX
		If lMGETAPUR
			aGetApur := ExecBlock("MGETAPUR",.F.,.F.,{"005",aGetApur})
		EndIf
		AADD(aGetApur,{"006",STR0011,0,"NG"}) //"Subtotal                                      "
		AADD(aGetApur,{"007",STR0012,0,"SG"}) //"Saldo credor do per¡odo anterior              "
		AADD(aGetApur,{"008",STR0006,0,"NG"}) //"Total                                         "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"   ",STR0026,0,"FL"}) //"       Demonstrativo de D‚bitos               "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"009",STR0027,0,"SG"}) //"Por sa¡das para o mercado nacional            "
		AADD(aGetApur,{"010",STR0005,0,"TD"}) //"Estornos de cr‚ditos                          "
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Calculo do Valor de Estorno de Credito de IPI  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aDadIC) == 0 .And. lEstCred
			aRetIPI := EstCredIPI(dDtIni,dDtFim)
			For nX := 1 to Len(aRetIPI)
				AADD(aGetApur,{"010",aRetIPI[nX,1],aRetIPI[nX,2],"DD"})
			Next nX
		EndIf
		For nX := 1 to Len(aDadIC)
			If aDadIC[nX][1]=="010"
				AADD(aGetApur,{"010",Alltrim(PADR(aDadIC[nX][2],nTamDesc)),0,"DD"})
			Endif
		Next nX
		If lMGETAPUR
			aGetApur := ExecBlock("MGETAPUR",.F.,.F.,{"010",aGetApur})
		EndIf
		AADD(aGetApur,{"011",STR0028,0,"TD"}) //"Ressarcimento de cr‚ditos                     "
		For nX:= 1 to Len(aDadIC) 
			If aDadIC[nX][1]=="011"
				AADD(aGetApur,{"011",alltrim(PADR(aDadIC[nX][2],nTamDesc)),0,"DD"})
			Endif
		Next nX
		AADD(aGetApur,{"012",STR0004,0,"TD"}) //"Outros debitos                                "
		For nX := 1 to Len(aDadIC)
			If aDadIC[nX][1]=="012"
				AADD(aGetApur,{"012",Alltrim(PADR(aDadIC[nX][2],nTamDesc)),0,"DD"})
			Endif
		Next nX
		If lMGETAPUR
			aGetApur := ExecBlock("MGETAPUR",.F.,.F.,{"012",aGetApur})
		EndIf
		AADD(aGetApur,{"013",STR0006,0,"NG"}) //"Total                                         "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"   ",STR0029,0,"FL"}) //"          Apura‡„o do Saldo                   "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"014",STR0030,0,"NG"}) //"D‚bito total (=item 013)                      "
		AADD(aGetApur,{"015",STR0031,0,"NG"}) //"Cr‚dito total (=item 008)                     "
		AADD(aGetApur,{"016",STR0032,0,"NG"}) //"Saldo devedor (=item 014-item 015)            "
		AADD(aGetApur,{"017",STR0033,0,"NG"}) //"Saldo credor  (=item 015-item 014)            "
		
		//Adiciona 3 elementos para gravar o CODAJU, INDDOC e NUMDOC
		If lUsaSped
			aColAnt	 := aClone(aGetApur)
			aGetApur := {}
			For nX := 1 to Len(aColAnt)
				If len(aColAnt[nX]) == 4
					AADD(aGetApur,Array(8))
					For nY := 1 to 4
						aGetApur[nX][nY] := aColAnt[nX][nY]
					Next
					aGetApur[nX][5] := "   "
					aGetApur[nX][6] := ""
					aGetApur[nX][7] := Space(TamSx3("CDP_NUMDOC")[1])
					aGetApur[nX][8] := ""
				Else
					AADD(aGetApur,aColAnt[nX])
				EndIf
			Next
		EndIf
		
	Case cImp=="IS"
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"   ",STR0026,0,"FL"}) //"       Demonstrativo de D‚bitos               "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"001",STR0027,0,"SG"}) //"Por sa¡das para o mercado nacional            "
		AADD(aGetApur,{"002",STR0069,0,"TD"}) //"Serv. executados por Terc. c/ret. de Imposto  "
		AADD(aGetApur,{"003",STR0004,0,"TD"}) //"Outros d‚bitos                                "
		AADD(aGetApur,{"004",STR0011,0,"NG"}) //"Subtotal                                      "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"   ",STR0022,0,"FL"}) //"       Demonstrativo de Cr‚ditos              "
		AADD(aGetApur,{"005",STR0010,0,"TD"}) //"Estornos de d‚bitos                           "
		AADD(aGetApur,{"006",STR0009,0,"TD"}) //"Outros cr‚ditos                               "
		AADD(aGetApur,{"007",STR0011,0,"NG"}) //"Subtotal                                      "
		AADD(aGetApur,{"008",STR0012,0,"SG"}) //"Saldo credor do per¡odo anterior              "
		AADD(aGetApur,{"009",STR0006,0,"NG"}) //"Total                                         "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"   ",STR0029,0,"FL"}) //"          Apura‡„o do Saldo                   "
		AADD(aGetApur,{"   ","                                              ",0,"FL"})
		AADD(aGetApur,{"010",STR0014,0,"NG"}) //"Saldo devedor (D‚bito-Cr‚dito)                "
		AADD(aGetApur,{"011",STR0015,0,"TD"}) //"Dedu‡”es                                      "
		AADD(aGetApur,{"012",STR0016,0,"NG"}) //"Imposto a recolher                            "
		AADD(aGetApur,{"013",STR0017,0,"NG"}) //"Saldo credor (Cr‚dito-D‚bito)                 "

	Case cImp=="SI"  .Or. cImp=="SN"  // Simples Federal e Nacional
		AADD(aGetApur,{"001",STR0077,0,"NG"}) //"Receita Bruta Acumulada:                      "
		AADD(aGetApur,{"002",STR0078,0,"NG"}) //"Receita Bruta Mensal:                         "
		AADD(aGetApur,{"003",STR0089,0,"NG"}) //"Receita Bruta Mensal Servicos:                "
		AADD(aGetApur,{"004",STR0095,0,"NG"}) //"Receita Bruta Mensal ST:                      " 
		AADD(aGetApur,{"005",STR0096,0,"NG"}) //"Receita Bruta Mensal Locacao:                 " 		
		AADD(aGetApur,{"006",STR0079,0,"NG"}) //"Valor Devido:                                 "
EndCase

RETURN (NIL)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM DA FUNCAO                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³TotDDApur ³ Autor ³ Juan Jose Pereira     ³ Data ³ 02/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Totaliza linhas de detalhe do array aGetApur                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION TotDDApur()

LOCAL nI	:= 0
LOCAL nPos 	:= 0

Aeval(aGetApur,{|x|IIf(x[4]=="TD",x[3]:=0,)})

For nI	:=	1 to Len(aGetApur)
	If aGetApur[nI,4]=="DD"
		nPos	:=	Ascan(aGetApur,{|x|x[1]==aGetApur[nI,1].and.x[4]=="TD"})
		If nPos>0
			aGetApur[nPos,3]	+=	aGetApur[nI,3]
		Endif
	EndIf
Next nI

RETURN (NIL)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM DA FUNCAO                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ InsElem  ³ Autor ³ Juan Jose Pereira     ³ Data ³ 02/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Insere linha de detalhe no array aGetApur                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION InsElem(nOpc)

Local aSvApur	:=	{}
Local nI		:= 	0 
Local nOpcNew	:=	0

If aGetApur[nOpc,4]=="TD"
	For nI	:=	1 to Len(aGetApur)
		AADD(aSvApur,AClone(aGetApur[nI]))
		If nI	==	nOpc
			AADD(aSvApur,AClone(aGetApur[nI]))
			aSvApur[nI+1,2]	:=	Space(Len(aSvApur[nI,2]))
			aSvApur[nI+1,3]	:=	0
			aSvApur[nI+1,4]	:=	"DD"
			nOpcNew	:=	nI+1
		Endif
	Next
	aGetApur	:=	Aclone(aSvApur)
Endif

RETURN (nOpcNew)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM DA FUNCAO                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ DelElem  ³ Autor ³ Juan Jose Pereira     ³ Data ³ 02/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Deleta linha de detalhe no array aGetApur                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION DelElem(nOpc)

LOCAL aSvApur	:= {}
LOCAL nI		:= 0

If aGetApur[nOpc,4]=="DD"
	For nI	:=	1 to Len(aGetApur)
		If nI!=nOpc
			AADD(aSvApur,Aclone(aGetApur[nI]))
		Endif
	Next nI
	aGetApur	:=	Aclone(aSvApur)
	TotDDApur()
Endif

RETURN (NIL)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM DA FUNCAO                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ LoadAnt     ³ Autor ³ Juan Jose Pereira  ³ Data ³ 02/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega Apuracao de Periodo Anterior                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION LoadAnt(cArqApur,cLinApur,cApurBa,cImp)

LOCAL nValor	:=	0
LOCAL i         := 0
LOCAL cLinha    := ""
Local nVlrMoeda := 1
Local nTamDesc := TamSx3("CDP_DESC")[1]
Default cImp := "" 

Default cApurBa := ""
If File(cArqApur)
	cContArq	:=	MemoRead(cArqApur)
	For i	:=	1 to MlCount(cContArq,100)
		cLinha	:=	MemoLine(cContArq,100,i)
		If cApurBa == "EXP"
			If Substr(cLinha,1,3)=="EXP" .And. Substr(cLinha,5,3)==cLinApur
				nValor	:=	Val(Substr(cLinha,71,14))
			EndIf
		Elseif cApurBa == "OUT"
			If Substr(cLinha,1,3)=="OUT" .And. Substr(cLinha,5,3)==cLinApur
				nValor	:=	Val(Substr(cLinha,71,14))
			EndIf
		Else
			If Substr(cLinha,1,3)==cLinApur
				If cImp =="IP"
					nValor	:=	Val(Substr(cLinha,71+(nTamDesc-46),14))
				Else
					nValor	:=	Val(Substr(cLinha,71,14))
				Endif				
			EndIf
		EndIf
		If SubStr(cLinha,1,3)=="IND"
			nVlrMoeda := Val(SubStr(cLinha,4))
		EndIf
	Next i
	nValor /= nVlrMoeda
EndIf

RETURN (nValor)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ WriteApur   ³ Autor ³ Juan Jose Pereira  ³ Data ³ 02/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Arquivo de Apuracao em arquivo texto (Linha a Linha) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION WriteApur(cArqApur,cLinha)

LOCAL nHandle
LOCAL lRet	:=	.t.

If !File(cArqApur)
	nHandle	:=	MSFCREATE(cArqApur)
Else
	nHandle	:=	FOpen(cArqApur,2)
Endif
If nHandle<0
	Help(" ",1,"NAOHANDLE")
	lRet	:=	.f.
Else
	cLinha	+=	Chr(13)+Chr(10)
	FSeek(nHandle,0,2)
	FWrite(nHandle,cLinha,Len(cLinha))
	FClose(nHandle)
Endif

RETURN (lRet)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM DA FUNCAO                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NmArqApur   ³ Autor ³ Juan Jose Pereira  ³ Data ³ 02/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Define nome do arquivo texto que contera a apuracao        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION NmArqApur(cImp,nAno,nMes,nApuracao,nPeriodo,cNrLivro,lNCM,cMaFisFil)

LOCAL cMes		:= ""
LOCAL cPeriodo	:= ""
LOCAL cLivro	:= ""
LOCAL cNomeArq	:= ""
LOCAL cExt      := ""
LOCAL cEmp		:= FWGrpCompany()
LOCAL cFil		:= FWCodFil() //xFilial() //Retornado para função FWCodFil() devido a problema no nome do arquivo quando utilizado gestão corporativa// foi realizado teste com REINF e não ocorre problema.
DEFAULT lNCM    := .F.
DEFAULT cMaFisFil := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define identificador do mes                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nApuracao<4
	cMes	:=	Substr("ABCDEFGHIJKL",nMes,1)
Else
	cMes	:=	If(nApuracao==4,"S","X")
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define identificador do periodo                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Do Case
	Case nApuracao==1
		cPeriodo	:=	Str(nPeriodo,1)
	Case nApuracao==2
		cPeriodo	:=	If(nPeriodo<3,Str(nPeriodo,1),"2")
	Case nApuracao==3.or.nApuracao==5
		cPeriodo	:=	"0"
	Case nApuracao==4
		cPeriodo	:=	If(nPeriodo==1,"1","2")
EndCase
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define identificador do livro em uso                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cNrLivro=="*"
	cLivro	:=	"A"
Else
	cLivro	:=	If(cNrLivro==" ","_",cNrLivro)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ cMaFisFil sera alimentada na geracao do P9, quando a pergunta³
//³ "seleciona filiais" for respondida como "sim".               ³
//³ Esta variavel é utilizada para que todos os arquivos .IC0 das³
//³ filiais selecionadas sejam processados e componham o resumo  ³
//³ da apuracao.                                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cMaFisFil)
	cFil := cMaFisFil
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta nome do arquivo de apuracao                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lNCM 
	cExt := IIF(nApuracao==1,"ID",IIF(nApuracao==2,"IQ",IIF(nApuracao==3,"IM",cImp)))
	cNomeArq	:=	cLivro+cMes+Substr(StrZero(nAno,4),3,2)+cEmp+cFil+"."+cExt+cPeriodo
Else
	cNomeArq	:=	cLivro+cMes+Substr(StrZero(nAno,4),3,2)+cEmp+cFil+"."+cImp+cPeriodo
Endif	

Return(cNomeArq)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ RWaGetApur  ³ Autor ³ Juan Jose Pereira  ³ Data ³ 02/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza/Le valores do array aGetApur (somente totais)     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
STATIC FUNCTION RWaGetApur(cLinha,nValor,lSoma,cDescricao,cCodAju,cIndDoc,cNumDoc,cTipoAj)

LOCAL uRet
LOCAL nPos

Default cCodAju := ""
Default cIndDoc := ""
Default cNumDoc := ""
Default cTipoAj := ""

If Empty(cDescricao)
	lSoma	:=	IIf(lSoma==NIL,.f.,lSoma)
	nPos	:=	Ascan(aGetApur,{|x|x[1]==cLinha .and. x[4]!="DD"})
	If nValor==NIL
		uRet	:=	aGetApur[nPos,3]
	Else
		aGetApur[nPos,3]	:=	IIf(lSoma,aGetApur[nPos,3],0)+nValor
		uRet	:=	AClone(aGetApur)
	Endif
Else
	nPos	:=	Ascan(aGetApur,{|x|x[1]==cLinha})
	If nValor==NIL
		uRet	:=	aGetApur[nPos,3]
	Else
		If aGetAPur[nPos,4]=="TD"
			nPosLinha	:=	Ascan(aGetApur,{|x|x[1]==cLinha .And. AllTrim(x[5])==AllTrim(cCodAju) .and. Alltrim(x[8])==Alltrim(cTipoAj)})
			if cDescricao == PadR(STR0034,46) .or. cDescricao== PadR(STR0035,46)  .or. cDescricao==PadR (STR0071,46) .or. (nPosLinha > 0 )
				nPos	:=	Ascan(aGetApur,{|x|x[2]==cDescricao})
				if npos == 0
					nPos	:=	InsElem(Ascan(aGetApur,{|x|x[1]==cLinha}))
					aGetApur[nPos,1]	:=	cLinha
					aGetApur[nPos,2]	:=	cDescricao
					aGetApur[nPos,3]	:=	nValor
					aGetApur[nPos,4]	:=	"DD"
					If !Empty(cCodAju)
						aGetApur[nPos,5]	:=	SUBSTR(cCodAju,1,3)
						aGetApur[nPos,6]	:=	cIndDoc
						aGetApur[nPos,7]	:=	cNumDoc
						aGetApur[nPos,8]	:=	cTipoAj
					Endif
				else
					aGetApur[nPos,3]+=nValor
				endif
			else
				nPos	:=	InsElem(nPos)
				aGetApur[nPos,1]	:=	cLinha
				aGetApur[nPos,2]	:=	cDescricao
				aGetApur[nPos,3]	:=	nValor
				aGetApur[nPos,4]	:=	"DD"
				If !Empty(cCodAju)
					aGetApur[nPos,5]	:=	SUBSTR(cCodAju,1,3)
					aGetApur[nPos,6]	:=	cIndDoc
					aGetApur[nPos,7]	:=	cNumDoc
					aGetApur[nPos,8]	:=	cTipoAj
				Endif
			Endif
		Else
			aGetApur[nPos,2]	:=	Alltrim(cDescricao)
			aGetApur[nPos,3]	:=	nValor
		Endif
	Endif
Endif

RETURN (uRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ LoadApur    ³ Autor ³ Juan Jose Pereira  ³ Data ³ 02/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega valores no array aGetApur                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION LoadApur(cArqApur,cImp,dDtIni,dDtFim,cNrLivro,aMensIPI,aCDAIPI)

LOCAL i          := 1
LOCAL cCfo       := ""
LOCAL nImposto   := 0
LOCAL cLinha     := ""
LOCAL cDescricao := ""
Local nEstCiap   := 0
LOCAL cMV_Estado:=	SuperGetMV("MV_ESTADO")	// Def. estado empresa
LOCAL lApurDev   := aExistBloc[PE_APURDEV]
Local lApuricm   := aExistBloc[PE_APURICM]
Local nCredCiap  := 0
Local nDH0       := 0
Local nX         := 0
Local nStart     := 0
Local lUsaSped	 := SuperGetMv("MV_USASPED",,.T.) .And. aApurSX2[AI_CDP]  .And. aApurSX2[AI_CCK]  
Local lCmpPcLanc := aApurSX3[FP_CDP_TPLANC]
local nMV_ICMPAD := SuperGetMv("MV_ICMPAD")
Local cTipoAju   := ""

DEFAULT aMensIPI := {}
DEFAULT aCDAIPI	:= {}


aGetApur(cImp,dDtIni,dDtFim,@aMensIPI)
If ( cImp == "IC" )
	dbSelectARea("SFA")
	dbSetOrder(2)
	dbSeek(xFilial("SFA")+Dtos(ddtini),.t.)
	While ( !Eof() .And. xFilial("SFA")==SFA->FA_FILIAL .And. SFA->FA_DATA<=dDtFim )
		If ( SFA->FA_TIPO=="2" ) .and. SFA->FA_CREDIT<>"1"
			nEstCiap += SFA->FA_VALOR
			If aApurSX3[FP_FA_VALICCO] .And. SFA->FA_VALICCO > 0
				nEstCiap	+= SFA->FA_VALICCO
			EndIf	
		EndIf                     
      IF (SFA->FA_TIPO == "1" ) .and. (SFA->FA_CREDIT=="1")
			nCredCiap	+= SFA->FA_VALOR
			If aApurSX3[FP_FA_VALICCO] .And. SFA->FA_VALICCO > 0
				nCredCiap	+= SFA->FA_VALICCO
			EndIf	      
		EndIf
		dbSelectArea("SFA")
		dbSkip()
	EndDo
	If ( nEstCiap != 0 )
		RWaGetApur("003",nEstCiap,.t.,PadR(STR0036,46)) //"Estorno CIAP"
	EndIf            
	If ( nCredCiap != 0 )
		RWaGetApur("006",nCredCiap,.t.,PadR(STR0037,46)) //"Relativo a entrada de bem do Ativo Permanente"
	EndIf

EndIf



For i:=1 to Len(aApuracao)
	cDescricao 	:= Nil
    cCfo            :=  Substr(aApuracao[i,1],1,Len(SF3->F3_CFO)-1)
	nImposto		:=	0
	If lApurICM
		cCfo := ExecBlock("APURICM",.F.,.F.,{cCfo})
	EndIf
	Do Case
		Case cImp=="IC"
			nImposto	:=	aApuracao[i,4]
			Do Case
                Case (cMV_Estado=="SP".And.cCfo$"291#297".And.aApuracao[i,10]>0 )
					// Artigo 117 Inciso II do RICMS - Valido p/estado de SP.
					cLinha := "006"
					if aApuracao[i,4]==0  // coluna isenta ou outras
						nImposto := (aApuracao[i,11]*nMV_ICMPAD/100)-aApuracao[i,10]
					endif
					RWaGetApur(cLinha,nImposto,.t.,PadR("Inciso I do Artigo 117 do RICMS",46))
					cLinha := "002"
					if aApuracao[i,4]==0	// coluna isenta ou outras
						nImposto := aApuracao[i,11]*nMV_ICMPAD/100
					else
						nImposto := aApuracao[i,10]+aApuracao[i,4]
					Endif
					cDescricao := PadR("Inciso II do Artigo 117 do RICMS",46)
				Case  Val(substr(cCfo,1,1))>=5 
					cLinha	:=	"001" // Debito
				OTherwise 		
					cLinha	:=	"005" // Credito
			EndCase
			RWaGetApur(cLinha,nImposto,.t.,cDescricao)
		Case cImp=="IP"
			If Substr(cCfo,1,1)=="7" .And. aApuracao[i,74]  == "D"
				nImposto:=0
			Else
				nImposto:=aApuracao[i,4]				
			EndIf
			Do Case
				// Creditos
				Case Substr(cCfo,1,1)$"12"
					cLinha	:=	"001"
				Case Substr(cCfo,1,1)=="3"
					cLinha	:=	"002"
				Case Substr(cCfo,1,1)=="7" 
					cLinha	:=	"003"
				// Debitos
				Case Substr(cCfo,1,1)$"56" 
					cLinha	:=	"009"			
				Otherwise
					If Val(substr(cCfo,1,1))<5
						cLinha	:=	"001"
					Else
						cLinha	:=	"009"
					Endif
			EndCase
			
			RWaGetApur(cLinha,nImposto,.t.,cDescricao)
			
			// Quando for credito de comerciante nao atacadista o valor deve ser demonstrado
			// Sempre na linha 005. Por esta razao a verificacao desta condicao eh feita após as demais.
			If Substr(cCfo,1,1)< "5" .And. Len(aApuracao[i]) >= 136 .And. aApuracao[i,136] > 0 
				nImposto := aApuracao[i,136]
				cLinha	:=	"005" 
				nPos := Ascan(aGetApur,{|x|x[1]=="005" .and. STR0133$x[2]})
				If nPos > 0
					aGetApur[nPos,3]+=aApuracao[i,136]
				EndIf  							
				RWaGetApur(cLinha,nImposto,.t.,cDescricao)				
			EndIf
					
		Case cImp=="IS" // Pendente
	EndCase
Next i

cLinha	:=	"005" 
For nX:= 1 To Len(aMensIPI)	

	If SX5->(MsSeek(xFilial('SX5')+'87'+Alltrim(aMensIPI[nX,2])))
		nPos:=Ascan(aGetApur,{|x|x[1]=="005".and. SX5->X5_DESCRI$x[2]})
		IF (aMensIPI[nX,3] >0) .And. nPos > 0
			aGetApur[nPos,3]+= aMensIPI[nX,3]
			RWaGetApur(cLinha,aMensIPI[nX,3],.t.,cDescricao)				
		Endif
	Endif
	
Next nX

// Tratamento p/ deletar as linhas sem valor do resumo.
// Nao fazer dentro do laco pois trata-se de um laco por CFOP
// e outras quebras (aApuracao), portanto nao temos os valores 
// "totais" antes do final.

Do Case

	Case cImp=="IP"
		nPos:=Ascan(aGetApur,{|x|x[1]=="005".and. STR0133$x[2]})
		If nPos > 0 .And. aGetApur[nPos,3] == 0 
      		aDel(aGetApur, nPos)
			aSize(aGetApur,Len(aGetApur)-1)
		EndIf
                        
EndCase

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Le Saldo do Periodo Anterior ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Do Case
	Case cImp=="IC" 
		cLinha	:=	"009" 
		cLinApur	:=	"014"
	Case cImp=="IP" 
		cLinha	:=	"007" 
		cLinApur	:=	"017"
EndCase
nImposto	:=	LoadAnt(cArqApur,cLinApur,,cImp)
RWaGetApur(cLinha,nImposto,.t.)
//
// Saldo devedor do periodo anterior.
nImposto	:=	LoadAnt (cArqApur, "016",,cImp)
If (GeraLinhaApur (nImposto))
	RWaGetApur ("012", nImposto, .T., Padr (STR0071, 46))
EndIf

If cImp=="IP"
	If lApurDev
		aDevolucoes := Execblock("APURDEV",.F.,.F.)
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Apura devolucoes             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aDevolucoes	:=	ApurValDev(cImp,dDtIni,dDtFim,cNrLivro)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava Devolucoes             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aDevolucoes[3]+aDevolucoes[4]>0
			cDev	:=	"Devolucoes de Compras Art 254, inc VI RIPI/10"
			RWaGetApur("010",aDevolucoes[3]+aDevolucoes[4],.F.,cDev)
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Desconta as devolucoes       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RWaGetApur("009",-1*( ( aDevolucoes[3]+aDevolucoes[4] ) - aDevolucoes[5] ),.t.)
		If aDevolucoes[1]>0
            cDev    :=  "Estorno de debitos                            "
			RWaGetApur("004",aDevolucoes[1],.F.,cDev)
		Endif		
	Endif
	If aFindFunc[FF_GETSUMDH0] .And. aApurSX2[AI_DH0]
		nDH0:= GetSumDH0(DTos(dDtIni),DTos(dDtFim),"IPI")
		If nDH0 > 0
			RWaGetApur("010",nDH0,.T.,"Estorno de Credito CIAP")
		EndIf
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega valores digitado pelo usuario  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nStart := 1
	For nX := 1 To Len(aDadIc)
		nPos :=	Ascan(aGetApur,{|x|x[1]==aDadIC[nX][1] .And. x[4]$"DD,SG" /*.And. x[2]!= STR0133*/},nStart)
		If nPos > 0 
			aGetApur[nPos,3] :=	 aDadIC[nX][3]
			If lUsaSped
				aGetApur[nPos,5] :=	 aDadIC[nX][6]
				aGetApur[nPos,6] :=	 aDadIC[nX][5]
				aGetApur[nPos,7] :=	 aDadIC[nX][4]
			EndIf
	        nStart := nPos+1
	    Endif
	Next
	
	//Inclui Ajustes da apuração carregados da CDA
	If lUsaSped .And. lCmpPcLanc
		For nX := 1 to len(aCDAIPI)

			If SUBSTR(aCDAIPI[nX][6],1,6) == "CONFIG"  //len(aCDAIPI[nX][6]) > 3
				cTipoAju := "3" //'3- CONFIG'
			else	
				cTipoAju := "1" //'1-AUTOMATICO','2-MANUAL'
			Endif 

			RWaGetApur(aCDAIPI[nX][2],aCDAIPI[nX][4],.T.,aCDAIPI[nX][3],aCDAIPI[nX][5],'3',"",cTipoAju)

		Next nX
	Endif
    
	TotDDApur()
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Faz apuracao                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Apuracao(.T.,cImp)

RETURN (NIL)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM DA FUNCAO                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Apuracao    ³ Autor ³ Juan Jose Pereira  ³ Data ³ 09/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula valores da apuracao                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
STATIC FUNCTION Apuracao(lTotDet,cImp)

LOCAL nCredito 	:= 0
LOCAL nDebito 	:= 0
LOCAL nSldAnt 	:= 0
LOCAL nApurado 	:= 0
LOCAL nDeducoes := 0
LOCAL nIcmsRet 	:= 0
LOCAL nIcmsRetDV:= 0
LOCAL nIcmsCom 	:= 0
Local nApurFin := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Totaliza Linhas de Detalhe   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lTotDet!=NIL .and. lTotDet
	TotDDApur()
Endif

Do Case
	Case cImp=="IC"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Levantamento de valores      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nCredito	:=	RWaGetApur("005")
		nCredito	+=	RWaGetApur("006")
		nCredito	+=	RWaGetApur("007")
		nSldAnt	:=	RWaGetApur("009")
		nDebito	:=	RWaGetApur("001")
		nDebito	+=	RWaGetApur("002")
		nDebito	+=	RWaGetApur("003")
		nDeducoes:=	RWaGetApur("012")
		nApurado	:=	nDebito-(nCredito+nSldAnt)
		nApurFin	:=	nDebito-(nCredito+nSldAnt+nDeducoes)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Armazena sub-totais          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RWaGetApur("004",nDebito)			// <= Total dos Debitos
		RWaGetApur("008",nCredito)			// <= Sub-Total dos Creditos
		RWaGetApur("010",nCredito+nSldAnt)	// <= Total dos Creditos
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Armazena apurado             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nApurado<=0
			nVlrTitulo	:=	0
			RWaGetApur("014",Abs(nApurado))	// <= Total Credor
			RWaGetApur("011",0)					// <= Total Devedor
			RWaGetApur("013",0)					// <= Total a Recolher
		Else
			nVlrTitulo	:=	nApurFin
			RWaGetApur("014",0)					// <= Total Credor
			RWaGetApur("011",nApurado)			// <= Total Devedor
			RWaGetApur("013",nApurFin)      	// <= Total a Recolher
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Armazena Informacoes Complementares ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ ICMS Retido Vendas                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nIcmsRet	:=	0
		Aeval(aApuracao,{|x|IIf(Val(Substr(x[1],1,1))>=5,nIcmsRet+=x[8],)})
		Aeval(aApuracao,{|x|IIf(Val(Substr(x[1],1,1))<5,nIcmsRet-=x[8],)})

        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ ICMS Retido Vendas (Devolucoes)     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        nIcmsRetDV:=0
        Aeval(aApuracao,{|x|IIf(Val(Substr(x[1],1,1))<5,nIcmsRetDV+=x[8],)})

        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ ICMS Diferencial de Aliquota        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nIcmsCom	:=	0
		Aeval(aApuracao,{|x|IIf(Val(Substr(x[1],1,1))<5,nIcmsCom+=x[10],nIcmsCom-=x[10])})
		RWaGetApur("015",nIcmsRet)			// <= Total ICMS Retido
		RWaGetApur("016",nIcmsCom)			// <= Total ICMS Complementar
        RWaGetApur("017",nIcmsRetDV)        // <= Total ICMS Retido (Devolucoes de Vendas)
        
	Case cImp=="IP"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Levantamento de valores      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nCredito	:=	RWaGetApur("001")
		nCredito	+=	RWaGetApur("002")
		nCredito	+=	RWaGetApur("003")
		nCredito	+=	RWaGetApur("004")
		nCredito	+=	RWaGetApur("005")
		nSldAnt	:=	RWaGetApur("007")
		nDebito	:=	RWaGetApur("009")
		nDebito	+=	RWaGetApur("010")
		nDebito	+=	RWaGetApur("011")
		nDebito	+=	RWaGetApur("012")
		
		nApurado	:=	nDebito-(nCredito+nSldAnt)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Armazena sub-totais          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RWaGetApur("013",nDebito)			// <= Total dos Debitos
		RWaGetApur("006",nCredito)			// <= Sub-Total dos Creditos
		RWaGetApur("008",nCredito+nSldAnt)	// <= Total dos Creditos
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Armazena apurado             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RWaGetApur("014",nDebito)			// <= Total dos Debitos
		RWaGetApur("015",nCredito+nSldAnt)	// <= Total dos Creditos
		If nApurado<=0
			nVlrTitulo	:=	0
			RWaGetApur("016",0)				// <= Total Devedor
			RWaGetApur("017",Abs(nApurado))	// <= Total Credor
		Else
			nVlrTitulo	:=	nApurado
			RWaGetApur("016",nApurado)		// <= Total Devedor
			RWaGetApur("017",0)				// <= Total Credor
		Endif
EndCase

RETURN (NIL)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ DetDatas    ³ Autor ³ Juan Jose Pereira  ³ Data ³ 09/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Determina datas inicial e final da apuracao                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950 E MATA955                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION DetDatas(nMes,nAno,nApuracao,nPeriodo)

LOCAL aDatas		:=	Array(2)

Do Case
	Case nApuracao==1
		Do Case
			Case nPeriodo==1
				aDatas[1]:= StoD(StrZero(nAno,4) + StrZero(nMes,2) + '01'  )
				aDatas[2]:=aDatas[1]+9
			Case nPeriodo==2
				aDatas[1]:= StoD(StrZero(nAno,4) + StrZero(nMes,2) + '11'  )
				aDatas[2]:=aDatas[1]+9
			Case nPeriodo==3
				aDatas[1]:= StoD(StrZero(nAno,4) + StrZero(nMes,2) + '21'  )
				aDatas[2]:=UltimoDia(aDatas[1])
			Case nPeriodo==4
				aDatas[1]:= StoD(StrZero(nAno,4) + StrZero(nMes,2) + '01'  )
				aDatas[2]:= StoD(StrZero(nAno,4) + StrZero(nMes,2) + '20'  )
		EndCase
	Case nApuracao==2
		If nPeriodo==1
			aDatas[1]:= StoD(StrZero(nAno,4) + StrZero(nMes,2) + '01'  )
			aDatas[2]:=aDatas[1]+14
		Else
			aDatas[1]:= StoD(StrZero(nAno,4) + StrZero(nMes,2) + '16'  )
			aDatas[2]:=UltimoDia(aDatas[1])
		Endif
	Case nApuracao==3
		aDatas[1]:= StoD(StrZero(nAno,4) + StrZero(nMes,2) + '01'  )
		aDatas[2]:=UltimoDia(aDatas[1])
	Case nApuracao==4
		aDatas[1]:= StoD(StrZero(nAno,4) + If(nPeriodo==1,"01","07") + '01'  )
		aDatas[2]:= StoD(StrZero(nAno,4) + If(nPeriodo==1,"0630","1231") )
	Case nApuracao==5
		aDatas[1]:= StoD(StrZero(nAno,4) + '0101' )
		aDatas[2]:= StoD(StrZero(nAno,4) + '1231' )
EndCase

RETURN (aDatas)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CheckApur  ³ Autor ³ Juan Jose Pereira   ³ Data ³ 09/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se ja foi efetuada apuracao                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA950,MATA955                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/				
FUNCTION CheckApur(cImp,nAno,nMes,nApuracao,nPeriodo,cNrLivro,cImposto,aDadIC,;
					nMoedTit,cLcPadExt,cArqApur,aDadST,cProgram,aUsrdem,lTitulo,aFoment,aApurExp,aApurOut,nOpc,lAutomato)

LOCAL lRet       := .t.
LOCAL oDlgCheck
LOCAL cTitulo    := ""
LOCAL cText1     := ""
LOCAL cText2     := ""
LOCAL cNrTit     := ""
Local aNrTitDif  := {} //Títulos DIFAL
LOCAL cLinha     := ""
LOCAL cPrefixo   := ""
Local nValorant  := 0
Local ctext      := ""
Local lRefApur	:= SuperGetMv("MV_REFAPUR")	//Permite Refazer a Apuracao mesmo com o Titulo ja Baixado
Local aNrTit     := {}
Local aNrGnr     := {}
Local nX         := 0
Local nY         := 0
Local aDetData   := DetDatas(nMes,nAno,nApuracao,nPeriodo) //Retorna data de inicio e fim do periodo da apuração
Local cTempDB    := XApNmTDBR3( cImp , aDetData[1] , aDetData[2] , 'A' ) //Retorna o nome do TEMPDB a ser criado no RDBMS
Local cTempDBRes := XApNmTDBR3( cImp , aDetData[1] , aDetData[2] , 'B' ) //Retorna o nome do TEMPDB a ser criado no RDBMS
Local lContinua  := .T.
Local cChaveSF6  := ""
Local lIdxSF6    := SIX->(MsSeek("SF6"+"4"))
Local cPeriodo   := Str(nAno,4)+StrZero(nMes,2)
Local lProcApur  := aExistBloc[PE_PROCAPUR]
Local lProcApRet := .F.
Local cMV_PFAPIS := SuperGetMV( "MV_PFAPUIS" )
Local cMV_PFAPUIC	:= GetNewPar("MV_PFAPUIC","")
Local cMV_PFAPIP	:= GetNewPar("MV_PFAPUIP","")
Local cMV_PFAPSF	:= GetNewPar("MV_PFAPUSF","")
Local cMV_PFAPFD	:= GetNewPar("MV_PFAPUFD","")
Local cMV_PFSENAR	:= GetNewPar("MV_PFSENAR","")
Local cMV_PFAPUSN	:= GetNewPar("MV_PFAPUSN","")

Default lTitulo := .T.
Default aFoment	:= {}
Default aApurExp:= {}
Default aApurOut:= {}
Default nOpc		:= 2
Default lAutomato := .F.
aUsrdem :=If(aUsrdem==NIL,	aUsrdem:={},aUsrdem)

If File(cArqApur)
	If !lAutomato
		cTitulo	:=	STR0038 //"Aten‡„o"
		cText1	:=	STR0039+cImposto+STR0040 //"Arquivo de Apura‡„o de "###" j  existe:"
		cText2	:=	cArqApur
		DEFINE MSDIALOG oDlgCheck TITLE OemtoAnsi(cTitulo) FROM  185,155 TO 295,465 PIXEL OF oMainWnd
		@ 03, 10 TO 33, 125 LABEL "" OF oDlgCheck  PIXEL
		@ 10, 15 SAY OemToAnsi(cText1) SIZE 110, 8 OF oDlgCheck PIXEL
		@ 20, 15 SAY OemToAnsi(cText2) SIZE 110, 8 OF oDlgCheck PIXEL
		DEFINE SBUTTON FROM 40, 052 TYPE 2 ACTION (nOpc:=1,oDlgCheck:End()) ENABLE OF oDlgCheck
		@ 40,083 BUTTON STR0041 SIZE 30,12 FONT oDlgCheck:oFont ACTION (nOpc:=2,oDlgCheck:End()) OF oDlgCheck PIXEL //"Refazer"
		@ 40,115 BUTTON STR0042 SIZE 30,12 FONT oDlgCheck:oFont ACTION (nOpc:=3,oDlgCheck:End()) OF oDlgCheck PIXEL //"Excluir"
		ACTIVATE MSDIALOG oDlgCheck
	EndIf
	If nOpc == 3
		If File(cArqApur)
			FT_FUse(cArqApur)
		   	FT_FGotop()
		   	While ( !FT_FEof() )
		    	cLinha  := FT_FREADLN()
	           	If Substr(cLinha,1,3)=="TIT"
		    		Aadd(aNrTit,Substr(cLinha,5,TamSX3("F2_DOC")[1]))
				Endif
			   	FT_FSkip()
		   	EndDo
		   	FT_FUse()					
	   	EndIf
	   	
	   	//Buscar os títulos aqui F0J
	   	If aApurSX2[AI_F0J] .And. cImp == "IC"
		   	dbSelectArea("F0J")
			F0J->(DbSetOrder (3))			
			//F0J_FILIAL+DTOS(F0J_PER)+F0J_LIVRO
			IF F0J->(DbSeek (xFilial("F0J")+dTos(aDetData[1])+cNrLivro)) //Busca títulos do Difal gerados
				While !F0J->(EOF()) .AND. F0J->F0J_FILIAL+dtos(F0J->F0J_PER)+F0J->F0J_LIVRO == xFilial ("F0J")+dTos(aDetData[1])+cNrLivro
											  
					If F0J->F0J_TIPO $'1/2/3'
						AADD(aNrGnr,    {F0J->F0J_GNRE,CTOD(""),F0J->F0J_VALOR,'',F0J->F0J_UF,"",'',F0J->F0J_TIPO})
					ElseIf F0J->F0J_TIPO $'4/5/6'
						//Adiciona título						
						AADD(aNrTitDif,{F0J->F0J_PRFTIT,F0J->F0J_NUMTIT})
					EndIF
					
				 	F0J->(dbSkip())
				EndDo 
			EndIF	
		EndIf	   	
	   	
	   	If Len(aNrTit) > 0
			Aviso(STR0073,STR0074,{"OK"})	 //"Atencao"###'A apuracao nao podera ser excluida, pois existe um titulo gerado. Favor refazer a apuracao, utilizando a opcao de gerar titulo com "Nao"'
	   	Else
	    	FT_FUse()
	       	If File(cArqApur)
	        	Ferase(cArqApur)
	           	cArqST := substr(cArqApur,1,Len(cArqApur)-3)+"ST"+substr(cArqApur,Len(cArqApur),1)
		       	If File(cArqST)
		        	Ferase(cArqST)
		       	Endif
	       	Endif	                                          
	       	
	       	//exclui dados de tabela temporaria		
			If XApDelTempDB( cTempDB , .F. )			
				XApDelTempDB( cTempDBRes , .F. )			
			EndIf

			//Apagar aqui as informações das tabela do DIFAL.
	       If aApurSX2[AI_F0I]
		       dbSelectArea("F0I")
				F0I->(DbSetOrder (2))
				IF F0I->(MsSeek (xFilial ("F0I")+dTos(aDetData[1])+cNrLivro))
					Do While F0I->(!EOF()) .AND. F0I->(F0I_FILIAL+DTOS(aDetData[1])+F0I_LIVRO)== xFilial ("F0I")+dTos(aDetData[1])+cNrLivro
						RecLock("F0I",.F.)
						dbDelete()
						MsUnlock()			
						F0I->(DbSkip())
					EndDo			
				
				EndIF
			EndIF

			If aApurSX2[AI_F0J]
				dbSelectArea("F0J")
				F0J->(DbSetOrder (2))
				//F0J_FILIAL+DTOS(F0J_PER)+F0J_LIVRO+F0J_UF+F0J_GNRE				
				IF F0J->(DbSeek (xFilial ("F0J")+dTos(aDetData[1])+cNrLivro))
					Do While F0J->(!EOF()) .AND. F0J->(F0J_FILIAL+DTOS(aDetData[1])+F0J_LIVRO)== xFilial ("F0J")+dTos(aDetData[1])+cNrLivro
						RecLock("F0J",.F.)
						dbDelete()
						MsUnlock()			
						F0J->(DbSkip())
					EndDo			
				EndIF
			EndIF
			
			If aApurSX2[AI_CDV] .and. aApurSX3[FP_CDV_AUTO]
				dbSelectArea("CDV")
				CDV->(DbSetOrder(2))									
				If CDV->(dbSeek(xFilial("CDV")+cPeriodo+cNrLivro))					
					Do While CDV->(!EOF()) .And. CDV->(CDV_FILIAL+CDV_PERIOD+CDV_LIVRO)== xFilial("CDV")+cPeriodo+cNrLivro
					
						If CDV->CDV_AUTO	==	"S"						
							RecLock("CDV",.F.)
							dbDelete()
							MsUnlock()					
						EndIF		
				
						CDV->(DbSkip())				
					EndDo											
				EndIF
			EndIF
							       	
	   	Endif
	   	lRet :=	.f.
	
	ElseIf nOpc==2 

		//Ponto de entrada que recebe o retorno se deve bloquear o reprocessamento.
		If lProcApur
			lProcApRet :=  ExecBlock("PROCAPUR", .F., .F.,{nAno,nMes})

			If lProcApRet //Retornando True o reprocessamento deverá ser bloqueado.
				Return  .F.				
			EndIf
		EndIf	

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Carrega numero do Titulo gerado  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		FT_FUse(cArqApur)
		FT_FGotop()
		While ( !FT_FEof() )
			cLinha  := FT_FREADLN()
			ctext     :=  LTrim(Substr(cLinha,4,If(Substr(cLinha,1,3)=="OBS" .Or. Substr(cLinha,1,3)=="FOM" , Len(cLinha)-3,50)))
		    nValorant :=  xMoeda(Val(Substr(cLinha,71,14)),1,nMoedTit,dDataBase)
		    If cImp$"IC"

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Alimenta as variaveis VALOR utilizada para realizar o LP 713 de estorno contabil ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Substr(cLinha,1,3)=="004"
                   VALOR := nValorant
                EndIf

				If Substr(cLinha,1,3)=="010"
                   VALOR2 := nValorant
                EndIf
                   
			    IF Substr(cLinha,1,3)=="002" .and. !Upper(alltrim(ctext))$Upper(STR0004+"###"+STR0035) // "Outros debitos"###"Inciso II do Artigo 117 do RICMS"
	                AADD(aDadIC,{"002",ctext,nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))})
	            ElseIf Substr(cLinha,1,3)=="003" .and. Upper(alltrim(ctext))<>Upper(Alltrim(STR0005)) // "Estorno de creditos"
			        AADD(aDadIC,{"003",ctext,nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))}) 
				ElseIf Substr(cLinha,1,3)=="006" .and. !Upper(alltrim(ctext))$Upper(STR0009+"###"+STR0037+"###"+STR0034) // "Outros creditos"###"Relativo a entrada de bem do Ativo Permanente"###"Inciso I do Artigo 117 do RICMS"
			        AADD(aDadIC,{"006",ctext,nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))}) 
			    ElseIf Substr(cLinha,1,3)=="007" .and. Upper(alltrim(ctext))<>Upper(Alltrim(STR0010)) // "Estorno de debitos"
			        AADD(aDadIC,{"007",ctext,nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))})     			        
   			    ElseIf Substr(cLinha,1,3)=="012" .and. Upper(alltrim(ctext))<>Upper(Alltrim(STR0015)) // "Deducoes"
			        AADD(aDadIC,{"012",ctext,nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))})     			        
   			    ElseIf Substr(cLinha,1,3)=="OBS" 
			        AADD(aDadIC,{"OBS",ctext})     			        
   			    ElseIf Substr(cLinha,1,3)=="FOM" //Fomentar - GO  
		    		AADD(aFoment,{"FOM",ctext})
	  		    ElseIf Substr(cLinha,1,3)=="EXP" //Credito Acumulado BA - Exportacoes
				    Do Case
				    	Case Substr(cLinha,5,3)=="002" .and. !Upper(alltrim(Substr(ctext,5,Len(ctext)-4)))$Upper(STR0004+"###"+STR0035) // "Outros debitos"###"Inciso II do Artigo 117 do RICMS"
			                AADD(aApurExp,{"002",Substr(ctext,5,Len(ctext)-4),nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))})
			            Case Substr(cLinha,5,3)=="003" .and. Upper(alltrim(Substr(ctext,5,Len(ctext)-4)))<>Upper(Alltrim(STR0005)) // "Estorno de creditos"
					        AADD(aApurExp,{"003",Substr(ctext,5,Len(ctext)-4),nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))}) 
						Case Substr(cLinha,5,3)=="006" .and. !Upper(alltrim(Substr(ctext,5,Len(ctext)-4)))$Upper(STR0009+"###"+STR0037+"###"+STR0034) // "Outros creditos"###"Relativo a entrada de bem do Ativo Permanente"###"Inciso I do Artigo 117 do RICMS"
					        AADD(aApurExp,{"006",Substr(ctext,5,Len(ctext)-4),nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))}) 
					    Case Substr(cLinha,5,3)=="007" .and. Upper(alltrim(Substr(ctext,5,Len(ctext)-4)))<>Upper(Alltrim(STR0010)) // "Estorno de debitos"
					        AADD(aApurExp,{"007",Substr(ctext,5,Len(ctext)-4),nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))})     			        
	   			    	Case Substr(cLinha,5,3)=="012" .and. Upper(alltrim(Substr(ctext,5,Len(ctext)-4)))<>Upper(Alltrim(STR0015)) // "Deducoes"
					        AADD(aApurExp,{"012",Substr(ctext,5,Len(ctext)-4),nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))})     			        
				    EndCase
 			    ElseIf Substr(cLinha,1,3)=="OUT" //Credito Acumulado BA - Outras hipoteses
				    Do Case
				    	Case Substr(cLinha,5,3)=="002" .and. !Upper(alltrim(Substr(ctext,5,Len(ctext)-4)))$Upper(STR0004+"###"+STR0035) // "Outros debitos"###"Inciso II do Artigo 117 do RICMS"
			                AADD(aApurOut,{"002",Substr(ctext,5,Len(ctext)-4),nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))})
			            Case Substr(cLinha,5,3)=="003" .and. Upper(alltrim(Substr(ctext,5,Len(ctext)-4)))<>Upper(Alltrim(STR0005)) // "Estorno de creditos"
					        AADD(aApurOut,{"003",Substr(ctext,5,Len(ctext)-4),nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))}) 
						Case Substr(cLinha,5,3)=="006" .and. !Upper(alltrim(Substr(ctext,5,Len(ctext)-4)))$Upper(STR0009+"###"+STR0037+"###"+STR0034) // "Outros creditos"###"Relativo a entrada de bem do Ativo Permanente"###"Inciso I do Artigo 117 do RICMS"
					        AADD(aApurOut,{"006",Substr(ctext,5,Len(ctext)-4),nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))}) 
					    Case Substr(cLinha,5,3)=="007" .and. Upper(alltrim(Substr(ctext,5,Len(ctext)-4)))<>Upper(Alltrim(STR0010)) // "Estorno de debitos"
					        AADD(aApurOut,{"007",Substr(ctext,5,Len(ctext)-4),nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))})     			        
	   			    	Case Substr(cLinha,5,3)=="012" .and. Upper(alltrim(Substr(ctext,5,Len(ctext)-4)))<>Upper(Alltrim(STR0015)) // "Deducoes"
					        AADD(aApurOut,{"012",Substr(ctext,5,Len(ctext)-4),nValorant,alltrim(Substr(cLinha,86,6)),Substr(cLinha,93,14),alltrim(Substr(cLinha,108,06))})     			        
				    EndCase
				Endif   
			ElseIf cImp$"IP"			                                
				If Substr(cLinha,1,3)=="004" .and. Upper(alltrim(ctext))<>Upper(alltrim(STR0010))  // "Estorno de debitos"
			        AADD(aDadIC,{"004",ctext,nValorant,alltrim(Substr(cLinha,86,6))})     			
			    ElseIf Substr(cLinha,1,3)=="005" .and. Upper(alltrim(ctext))<>Upper(alltrim(STR0009)) .And. Upper(alltrim(ctext))<>Upper(alltrim(STR0133))  // "Outros creditos"
			        AADD(aDadIC,{"005",ctext,nValorant,alltrim(Substr(cLinha,86,6))})     			     
				ElseIf Substr(cLinha,1,3)=="010" .and. Upper(alltrim(ctext))<>Upper(alltrim(STR0005))  // "Estorno de creditos"
			        AADD(aDadIC,{"010",ctext,nValorant,alltrim(Substr(cLinha,86,6))})     			    			       
			    ElseIf Substr(cLinha,1,3)=="011" .and. Upper(alltrim(ctext))<>Upper(alltrim(STR0028))  // "Ressarcimento de créditos"
			        AADD(aDadIC,{"011",ctext,nValorant,alltrim(Substr(cLinha,86,6))})
			    ElseIf Substr(cLinha,1,3)=="012" .and. Upper(alltrim(ctext))<>Upper(alltrim(STR0004))  // "Outros debitos"
			        AADD(aDadIC,{"012",ctext,nValorant,alltrim(Substr(cLinha,86,6))})     			    			             
			    EndIf    
			ElseIf cImp=="IS" 
				IF Substr(cLinha,1,3)=="002"     .and. Upper(alltrim(ctext)) <> Upper(alltrim(STR0069)) // "Serv. executados por Terc. c/ret. de Imposto"
	                AADD(aDadIC,{"002",ctext,nValorant,alltrim(Substr(cLinha,86,6))})
            ElseIf Substr(cLinha,1,3)=="003" .and. Upper(alltrim(ctext)) <> Upper(alltrim(STR0004))  // "Outros debitos"
			        AADD(aDadIC,{"003",ctext,nValorant,alltrim(Substr(cLinha,86,6))}) 
				ElseIf Substr(cLinha,1,3)=="005" .and. Upper(alltrim(ctext)) <> Upper(alltrim(STR0010)) // "Estorno de debitos"
			        AADD(aDadIC,{"005",ctext,nValorant,alltrim(Substr(cLinha,86,6))})
				ElseIf Substr(cLinha,1,3)=="006" .and. Upper(alltrim(ctext)) <> Upper(alltrim(STR0009)) // "Outros creditos"
			        AADD(aDadIC,{"006",ctext,nValorant,alltrim(Substr(cLinha,86,6))})			        			        
				ElseIf Substr(cLinha,1,3)=="011" .and. Upper(alltrim(ctext)) <> Upper(alltrim(STR0015)) // "Deducoes"
			        AADD(aDadIC,{"011",ctext,nValorant,alltrim(Substr(cLinha,86,6))})			        			        
				ElseIf Substr(cLinha,1,3)=="000" .and. Upper(alltrim(ctext)) <> Upper(alltrim(STR0090)) // "Itens"
			        AADD(aUsrdem,{"000",ctext,nValorant,alltrim(Substr(cLinha,86,6))})
				ElseIf Substr(cLinha,1,3)=="500" //Linhas ref. as informacoes de compensacao de ISS
				    ctext := alltrim(Substr(cLinha,5,10))
				    If Substr(cLinha,5,3)$"TIP"
				        AADD(aDadIC,{"500",ctext,Substr(cLinha,16,1)}) 
				    ElseIf Substr(cLinha,5,3)$"PER"
				        AADD(aDadIC,{"500",ctext,Alltrim(Substr(cLinha,16,6))}) 
				    ElseIf Substr(cLinha,5,3)$"OBS"
				        AADD(aDadIC,{"500",ctext,Alltrim(Substr(cLinha,16,200))}) 
				    Else
						nValorant :=  xMoeda(Val(Substr(cLinha,16,18)),1,nMoedTit,dDataBase)
				        AADD(aDadIC,{"500",ctext,nValorant}) 
				    Endif				
				Endif           
			EndIf
			
			If Substr(cLinha,1,3)=="TIT" .Or. Substr(cLinha,1,3)=="GNR"
				Do While Substr(cLinha,1,3)=="TIT" .Or. Substr(cLinha,1,3)=="GNR"
					cLinha  := FT_FREADLN() 
					If Substr(cLinha,1,3)=="TIT"
						Aadd(aNrTit,Substr(cLinha,5,TamSX3("F2_DOC")[1]))
					ElseIf Substr(cLinha,1,3)=="GNR"
						Aadd(aNrGnr,{Substr(cLinha,5,TamSx3("F6_NUMERO")[1]), AllTrim(SubStr(cLinha, 5 + TamSx3("F6_NUMERO")[1], 2))})	
					Endif
					FT_FSkip()
				Enddo
			Endif
					
			FT_FSkip()
		EndDo
		
		FT_FUse()

		//Buscar os títulos e genre gravados
		If aApurSX2[AI_F0J] .And. cImp == "IC"
			dbSelectArea("F0J")
			F0J->(DbSetOrder (3))			
			//F0J_FILIAL+DTOS(F0J_PER)+F0J_LIVRO
			IF F0J->(DbSeek (xFilial("F0J")+dTos(aDetData[1])+cNrLivro)) //Busca títulos do Difal gerados
				While !F0J->(EOF()) .AND. F0J->F0J_FILIAL+dtos(F0J->F0J_PER)+F0J->F0J_LIVRO == xFilial ("F0J")+dTos(aDetData[1])+cNrLivro
											  
					If F0J->F0J_TIPO $'1/2/3'
						AADD(aNrGnr,    {F0J->F0J_GNRE,CTOD(""),F0J->F0J_VALOR,'',F0J->F0J_UF,"",'',F0J->F0J_TIPO})
					ElseIf F0J->F0J_TIPO $'4/5/6'
						//Adiciona título						
						AADD(aNrTitDif,{F0J->F0J_PRFTIT,F0J->F0J_NUMTIT})
					EndIF 
					  
				 	F0J->(dbSkip())
				EndDo 
			EndIF
		EndIF
		
		If cImp == "IC"
			cArqApur := NmArqApur("ST",nAno,nMes,nApuracao,nPeriodo,cNrLivro)    
			If File(cArqApur)
				FT_FUse(cArqApur)
				FT_FGotop()
				While ( !FT_FEof() )
					cLinha  := FT_FREADLN()
					ctext     :=  LTrim(Substr(cLinha,4,50))
		            nValorant :=  xMoeda(Val(Substr(cLinha,71,14)),1,nMoedTit,dDataBase)
				    IF Substr(cLinha,1,3)=="002" .and. !Upper(alltrim(ctext))$Upper(alltrim(STR0004)) // "Outros debitos"
		                AADD(aDadST,{"002",ctext,nValorant,alltrim(Substr(cLinha,86,6)),""})
		            ElseIf Substr(cLinha,1,3)=="003" .and. Upper(alltrim(ctext))<>Upper(alltrim(STR0005)) // "Estorno de creditos"
				        AADD(aDadST,{"003",ctext,nValorant,alltrim(Substr(cLinha,86,6)),""}) 
				    ElseIf Substr(cLinha,1,3)=="007" .and. Upper(alltrim(ctext))<>Upper(alltrim(STR0009)) // "Outros creditos"
				        AADD(aDadST,{"007",ctext,nValorant,alltrim(Substr(cLinha,86,6)),alltrim(Substr(cLinha,93,14)),alltrim(Substr(cLinha,108,06))})     			        
	   			    ElseIf Substr(cLinha,1,3)=="008" .and. Upper(alltrim(ctext))<>Upper(alltrim(STR0010)) // "Estorno de debitos"
				        AADD(aDadST,{"008",ctext,nValorant,alltrim(Substr(cLinha,86,6)),""})     			        
					ElseIf Substr(cLinha,1,3)=="014" .and. Upper(alltrim(ctext))<>Upper(alltrim(STR0015)) // "Deducoes"
				        AADD(aDadST,{"014",ctext,nValorant,alltrim(Substr(cLinha,86,6)),""})     			        
					Endif   
					FT_FSkip()
				EndDo
				FT_FUse()					
			EndIf
		EndIf

		If aApurSX2[AI_CDV] .and. aApurSX3[FP_CDV_AUTO]
			dbSelectArea("CDV")
			CDV->(DbSetOrder(2))									
			If CDV->(dbSeek(xFilial("CDV")+cPeriodo+cNrLivro))				
				Do While CDV->(!EOF()) .And. CDV->(CDV_FILIAL+CDV_PERIOD+CDV_LIVRO)== xFilial("CDV")+cPeriodo+cNrLivro
				
					If CDV->CDV_AUTO	==	"S"
						RecLock("CDV",.F.)
						dbDelete()
						MsUnlock()					
					EndIF		
					
					CDV->(DbSkip())				
				EndDo				
			EndIF
		EndIF

		Begin Transaction
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Estorna lancamento contabil LP 713 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LancCont("713","MATA953")
		
		
		End Transaction
		
		
		If Len(aNrTit) > 0 .Or. Len(aNrGnr) > 0
				
			dbSelectArea("SE2")   

			/* 
			 Tratamento diferenciado para apuracao de ISS. Primeiro verifico se TODOS os titulos gerados podem
			 ser baixados. Se algum não puder, não excluo nenhum dos outros. Se todos estiverem OK, seguir com a exclusao
			 dos titulos e guias. Tratamento implementado para evitar a deleção "parcial" dos titulos.
			*/
			
			If cImp == "IS"
							
				If Empty( cPrefixo := &( cMV_PFAPIS ) ) // Busca na SE2 o titulo contido no arquivo com prefixo ISS
					cPrefixo :=	"ISS"
				EndIf
				
				For nX := 1 to Len(aNrTit)
				
					cNrTit := aNrTit[nX]
					
					// Se nao encontrar o titulo correto, nao tentar excluir.
					// O objetivo é posicionar a SE2 exatamente no titulo gerado pela apuracao. 
					// Caso isso nao aconteca nao posso fazer as validacoes abaixo p/ qualquer titulo pois pode acontecer
					// de existir na base OUTRO titulo, gerado por outra rotina, com o mesmo nro do titulo gerado pela apuracao.		
					
					If SE2->(DbSeek(xFilial("SE2")+cPrefixo+cNrTit))
						
						If !FaCanDelCP("SE2", cProgram, .F.)
							lContinua := .F.
							lRet := .F.
							Exit													
						EndIf
						
					EndIf
												
				Next nX
											
			EndIf
			
			If lContinua
				
				// Excluindo GNRE's geradas pela apuração.
				If cImp == "IS" .And. Len(aNrGnr) > 0
				
					DbSelectArea("SF6")
					SF6->(dbSetOrder(1))	
												
					For nX := 1 to Len(aNrGnr)
						cChaveSF6 := aNrGnr[nX, 2] + aNrGnr[nX, 1] // F6_EST + F6_NUMERO
						
						If SF6->(DbSeek(xFilial("SF6")+cChaveSF6))
							RecLock("SF6",.F.)
							dbDelete()
							MsUnlock()
						EndIf
					Next nX
					
					SF6->(dbCloseArea())
					
				EndIf
				
			dbSelectArea("SE2")   

			For nX	:=1 to Len(aNrTitDif)
				cPrefixo	:= aNrTitDif[nX][1]
				cNrTit		:= aNrTitDif[nX][2]

				If dbSeek(xFilial()+cPrefixo+cNrTit,.F.)
				
					If !FaCanDelCP("SE2", cProgram)
						lRet := .F.
					EndIf
					
					If lRet
																																
						PcoIniLan('000250')
						Begin Transaction
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Estorna lancamento contabil      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						LancCont(cLcPadExt,cProgram)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Estorna lancamento PCO           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						PcoDetLan('000250',"01","MATA953",.T.)
						PcoDetLan('000250',"02","MATA953",.T.)
						PcoDetLan('000250',"03","MATA953",.T.)
						PcoDetLan('000250',"04","MATA953",.T.)

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Excluir titulo gerado            ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						FaAvalSE2(2)
						FaAvalSE2(3)
						dbSelectArea("SE2")
						If aFindFunc[FF_FINGRVEX]
							FinGrvEx("P") // Gravar o histórico.
						EndIf
						RecLock("SE2",.f.,.t.)
						dbDelete()
						End Transaction
						PcoFinLan('000250')
					EndIf
					
				EndIf
			
			Next nX
			

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Pode existir mais de um titulo lancado - Substituicao Tributaria³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nX := 1 to Len(aNrTit) 
				
				cNrTit := aNrTit[nX]

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³A rotina  e utilizada pelas apurações de ICMS, IPI e ISS onde a variavel cImp é igual a IC, IP ou IS,     ³
				//³com isso é possivel encontrar o prefixo para excluir os titulos do SE2, ja para os demais casos como      ³
				//³os titulos de SPF, FDS, SEN, SPN e Prefixo (VAZIO) o SE2 deve ser verificado, pois na variavel aNrTit     ³
				//³não ha o prefixo do titulo gerado na apuracao, apenas o numero e como pode haver mais de um titulo na     ³
				//³apuracao com prefixos diferentes e preciso varrer o SE2 para excluir todos os tipos gerados pela apuracao.³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					
				For nY := 1 To 6
					If nY == 1
						If cImp=="IC"
							If Empty( cPrefixo := &( cMV_PFAPUIC ) ) // Busca na SE2 o titulo contido no arquivo com prefixo ICM
								cPrefixo :=	"ICM"					
							EndIf 	
						ElseIf cImp=="IP"
							If Empty( cPrefixo := &( cMV_PFAPIP ) ) // Busca na SE2 o titulo contido no arquivo com prefixo IPI
								cPrefixo :=	"IPI"						
							EndIf 	
						ElseIf cImp=="IS"          
							If Empty( cPrefixo := &( cMV_PFAPIS ) ) // Busca na SE2 o titulo contido no arquivo com prefixo ISS
								cPrefixo :=	"ISS"				
							EndIf 			
						EndIf						
					ElseIf nY == 2
						If Empty( cPrefixo := &( cMV_PFAPSF ) ) // Busca na SE2 o titulo contido no arquivo com prefixo SPF
							cPrefixo :=	"SPF"
						Endif
					ElseIf nY == 3
						If Empty( cPrefixo := &( cMV_PFAPFD ) ) // Busca na SE2 o titulo contido no arquivo com prefixo FDS
							cPrefixo :=	"FDS"
						EndIf
					ElseIf nY == 4
						If Empty( cPrefixo := &( cMV_PFSENAR ) ) // Busca na SE2 o titulo contido no arquivo com prefixo SEN
							cPrefixo :=	"SEN"
						EndIf
					ElseIf nY == 5
						If Empty( cPrefixo := &( cMV_PFAPUSN ) ) // Busca na SE2 o titulo contido no arquivo com prefixo SPN 
							cPrefixo :=	"SPN"
						EndIf
						ElseIf nY == 6 .And. cImp <> "IS" // VERIFICAR AQUI - prefixo em branco pode posicionar em outro titulo incorretamente. Verificar p/ todas as apuracoes.
						cPrefixo :=	Space(TamSx3("E2_PREFIXO")[1]) //Busca na SE2 o titulo contido no arquivo com prefixo em branco
					EndIf

					If dbSeek(xFilial()+cPrefixo+cNrTit,.F.) .And. Upper(AllTrim(SE2->E2_ORIGEM)) $ cProgram
						If !FaCanDelCP("SE2", cProgram)
							lRet := .F.
						EndIf
						If lRet
							
							If cImp == "IS" .And. lIdxSF6							
								DbSelectArea("SF6")
								DbSetOrder(4)
								// Verifica se existem guias de recolhimento desse titulo 
								If SF6->(DbSeek(xFilial("SF6")+SE2->E2_NUM))
									RecLock("SF6",.F.)
									dbDelete()
									MsUnlock()
								EndIf
							EndIf
							
							PcoIniLan('000250')
							Begin Transaction
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Estorna lancamento contabil      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							LancCont(cLcPadExt,cProgram)
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Estorna lancamento PCO           ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							PcoDetLan('000250',"01","MATA953",.T.)
							PcoDetLan('000250',"02","MATA953",.T.)
							PcoDetLan('000250',"03","MATA953",.T.)
							PcoDetLan('000250',"04","MATA953",.T.)
	
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Excluir titulo gerado            ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							FaAvalSE2(2)
							FaAvalSE2(3)
							dbSelectArea("SE2")
							If aFindFunc[FF_FINGRVEX]
								FinGrvEx("P") // Gravar o histórico.
							EndIf
							RecLock("SE2",.f.,.t.)
							dbDelete()
							End Transaction
							PcoFinLan('000250')
						Endif
					Endif
					
				Next nY

			Next nX
				
			EndIf //lContinua
			
			If !lRet
				If !lTitulo .And. lRefApur //Permite refazer a apuracao mesmo com o titulo baixado

					lRet := .T.		
				Else
					DEFINE MSDIALOG oDlgTit TITLE OemtoAnsi(STR0038) FROM  180,155 TO 310,480 PIXEL OF oMainWnd //"Aten‡„o"
					@ 03, 15 TO 39, 150 LABEL "" OF oDlgTit  PIXEL
	                @ 10, 20 SAY OemToAnsi(STR0043+SE2->E2_NUM+"-"+SE2->E2_PREFIXO+STR0044) SIZE 128, 8 OF oDlgTit PIXEL //"T¡tulo "###" j  foi baixado ou existe cheque(s)"
	                @ 20, 20 SAY OemToAnsi(STR0045)                   SIZE 128, 8 OF oDlgTit PIXEL //"gerado(s), para refazer a apura‡„o, a baixa deste"
	                @ 30, 20 SAY OemToAnsi(STR0046)                       SIZE 128, 8 OF oDlgTit PIXEL //"t¡tulo e/ou cheque(s) dever„o ser cancelados."
	                @ 46, 60 BUTTON STR0047 SIZE 40,12 FONT oDlgTit:oFont ACTION (nOpc:=1,oDlgTit:End()) OF oDlgTit PIXEL //"Abandona"
					ACTIVATE MSDIALOG oDlgTit
				Endif
			Endif
		Endif
		
		If nOpc == 2 .And. lRet 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Apaga arquivo de apuracao        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cImp<>"IS" 
				Ferase(cArqApur)
				//Apagar aqui as informações das tabela do DIFAL.
				If cImp == "IC"		      
			       If aApurSX2[AI_F0I]
				       dbSelectArea("F0I")
						F0I->(DbSetOrder (2))
						IF F0I->(MsSeek (xFilial ("F0I")+dTos(aDetData[1])+cNrLivro))
							Do While F0I->(!EOF()) .AND. F0I->(F0I_FILIAL+DTOS(aDetData[1])+F0I_LIVRO)== xFilial ("F0I")+dTos(aDetData[1])+cNrLivro
								RecLock("F0I",.F.)
								dbDelete()
								MsUnlock()			
								F0I->(DbSkip())
							EndDo			
						
						EndIF
					EndIF
	
					If aApurSX2[AI_F0J]	
						dbSelectArea("F0J")
						F0J->(DbSetOrder (2))
						//F0J_FILIAL+DTOS(F0J_PER)+F0J_LIVRO+F0J_UF+F0J_GNRE				
						IF F0J->(DbSeek (xFilial ("F0J")+dTos(aDetData[1])+cNrLivro))
							Do While F0J->(!EOF()) .AND. F0J->(F0J_FILIAL+DTOS(aDetData[1])+F0J_LIVRO)== xFilial ("F0J")+dTos(aDetData[1])+cNrLivro
								RecLock("F0J",.F.)
								dbDelete()
								MsUnlock()			
								F0J->(DbSkip())
							EndDo			
						EndIF
					EndIF
				EndIF
				
			Endif	
		Else
			lRet	:=	.f.
		Endif
		
	Else
		lRet	:=	.f.
	Endif
Endif

Return (lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ShowApur    ³ Autor ³ Juan Jose Pereira  ³ Data ³ 09/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Exibe resumo do SF3 referente ao imposto em apuracao       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA951,MATA952                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±³20/08/2013³WAGNER MONTENEGRO - Adicionado parametro lFilAgl para tra-  ³±±
±±³          ³tamento de Consolidação de Apuração por CNPJ-IE (THPUOH)    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION ShowApur(nConsFil,cFilDe,cFilAte,cImposto,cImp,dDtIni,dDtFim,cNrLivro,lNCM,nApuracao,nPerCrd,lConsUf,aLisFil,lFilAgl,aMensIPI,lAutomato,aCDAIPI)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define variaveis                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL oDlg2
LOCAL oListEnt
LOCAL oListSai
LOCAL nOpc		:= 1
LOCAL cTitulo	:=	STR0048+cImposto //"Valores Apurados de "
LOCAL aExibe	:=	{}
LOCAL aEntradas := {}
LOCAL aSaidas	:= {}
LOCAL aTotais	:= {0,0,0,0}
LOCAL i			:= 1
LOCAL nTam		:= 0	
LOCAL aHdList	:= {}
LOCAL cMsgAdv	:= ""
LOCAL axNcm     := {}
LOCAL _x        := 0
LOCAL cLinha := ""

LOCAL aNcm      := {{"22011000","22090000"},;
					{"24021000","24022000"},;
                    {"84291110","84295900"},;
                    {"84321000","84339090"},;
                    {"87011000","87060090"},;
                    {"87111000","87119000"}}
                    
Local aResCFOP    := {}
Local lConfApur   := SuperGetMV("MV_CONFAPU",.F.,.F.)
Local cAlsIPIs    := "IPIDEB"
Local cTempIPIs   := "IPIDEBITO"+AllTrim(Str(ThreadID()))
Local cAlsIPIe    := "IPICRD"
Local cTempIPIe   := "IPICREDITO"+AllTrim(Str(ThreadID()))

DEFAULT lNCM      := .F.
DEFAULT nPerCrd   := 0
DEFAULT lConsUf   := .F.
DEFAULT aLisFil   := {}
DEFAULT aMensIPI  := {}
DEFAULT lFilAgl   := .F.
DEFAULT lAutomato := .F.
DEFAULT aCDAIPI   := {}

//conout(Alltrim(Str(ThreadID()))+  " ShowApur do Processamento MATA952 Alterado :  " + ElapTime(cStart, Time()))
	
if lConfApur
	DelTempIPI()

	CrTempApu ("IP", cAlsIPIs, cTempIPIs)
	CrTempApu ("IP", cAlsIPIe, cTempIPIe)
Endif

// Se não passou nenhuma filial para processar
If Len(aLisFil) == 0
	aAdd( aLisFil,{.T.,SM0->M0_CODFIL,SM0->M0_FILIAL,SM0->M0_CGC,SM0->M0_INSC,SM0->M0_INSCM})
EndIf

nConsFil:=Iif(nConsFil==Nil,2,nConsFil)
If nConsFil==2
	cFilDe := cFilAte := cFilAnt

#IFDEF TOP
Elseif empty(cFilAte)
	cFilDe := Space(Len(cFilAnt))
	cFilAte:= Replicate('Z',Len(cFilAnt))
#ENDIF

EndIf
If lNCM
	IF aExistBloc[PE_JOINCM]	// ponto de entrada que permite inserções de NCMs fora da faixa e especificas para determinados segmentos
		aXNcm := ExecBlock("JOINCM",.f.,.f.)
	
		If !Empty(Len(aXNcm))
			FOR _x:=1 to Len(aXNcm)
				aadd(aNcm,{aXNcm[_x][1],aXNcm[_x][2]})
			NEXT _x	
		EndIF	
	EndIF
	
	If lAutomato
		aApuracao:=ResumeIP(dDtIni,dDtFim,cNrLivro,1,.F.,nConsFil,cFilDe,cFilAte,aNcm,nApuracao,,nPerCrd,,lConsUf,,,,aLisFil)
	Else
		Processa({||aApuracao:=ResumeIP(dDtIni,dDtFim,cNrLivro,1,.F.,nConsFil,cFilDe,cFilAte,aNcm,nApuracao,,nPerCrd,,lConsUf,,,,aLisFil)})
	EndIf

Else
	
	If lAutomato
		aApuracao:=ResumeF3(cImp,dDtIni,dDtFim,cNrLivro,.f.,.t.,1,.F.,nConsFil,cFilDe,cFilAte,,,,,,,,,,,,,,lConsUf,,,,,,,aLisFil,,,,,,,,,,,,,@aMensIPI,,,lAutomato,,,,aCDAIPI,/*aNWCredAcu*/,/*lProcRefer*/,/*cTempDeb*/,/*cTempCrd*/,/*cTempSTd*/,/*cTempSTe*/,cTempIPIs,cTempIPIe)
	Else
		Processa({||aApuracao:=ResumeF3(cImp,dDtIni,dDtFim,cNrLivro,.f.,.t.,1,.F.,nConsFil,cFilDe,cFilAte,,,,,,,,,,,,,,lConsUf,,,,,,,aLisFil,,,,,,,,,,,,,@aMensIPI,,,,,,,aCDAIPI,/*aNWCredAcu*/,/*lProcRefer*/,/*cTempDeb*/,/*cTempCrd*/,/*cTempSTd*/,/*cTempSTe*/,cTempIPIs,cTempIPIe)})
	EndIF	
	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Resumo da apuracao por CFOP a partir do array aApuracao.     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aResCFOP := ResIpiCFOP(aApuracao,,,, aMensIPI)

aEntradas := aResCFOP[1]
aSaidas := aResCFOP[2]
aTotais := aResCFOP[3]

// Verificando se existe algum CFOP apurado que não esteja na tabela 13.
If aScan(aEntradas, {|x| AllTrim(x[1]) == "*"}) > 0 .Or. aScan(aSaidas, {|x| AllTrim(x[1]) == "*"}) > 0
	cMsgAdv	:=	'(*) CFO n„o cadastrado na Tabela "13"'
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Montando valores para exibição.                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nTam := IIF(Len(aEntradas)>Len(aSaidas),Len(aEntradas),Len(aSaidas))

For i	:=	1 to nTam
	
	cLinha := ""

	If i > Len(aEntradas)
		cLinha  +=  Space(5)+Space(1)+Space(18)+Space(1)+Space(13)+Space(1)
	Else
		cLinha	+=	aEntradas[i][1] + Space(2) + Transform(aEntradas[i,3],"@E 999,999,999,999.99") + Space(1) + Transform(aEntradas[i,4],"@E 99,999,999.99") + Space(1) 
	Endif
	
	If i > Len(aSaidas)
		cLinha  +=  Space(5)+Space(1)+Space(18)+Space(1)+Space(13)+Space(1)
	Else
		cLinha	+=	aSaidas[i][1] + Space(2) + Transform(aSaidas[i,3],"@E 999,999,999,999.99") + Space(1) + Transform(aSaidas[i,4],"@E 99,999,999.99") + Space(1)
	Endif
	
	cLinha	:=	OemToAnsi(cLinha)	
	AADD(aExibe,cLinha)
Next i

// Linha Totalizadora - Crédito
cLinha	:=	"TOTAL"+space(01)
cLinha	+=	Transform(aTotais[1][3],"@E 999,999,999,999.99") + " "
cLinha	+=	Transform(aTotais[1][4],"@E 99,999,999.99") + " "

// Linha Totalizadora - Debito
cLinha	+=	"TOTAL"+space(01)
cLinha	+=	Transform(aTotais[2][3],"@E 999,999,999,999.99")+ " "
cLinha	+=	Transform(aTotais[2][4],"@E 99,999,999.99")

cLinha	:=	OemToAnsi(cLinha)

AADD(aExibe,cLinha)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Exibe dados                                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lAutomato
	AADD(aHdList,STR0049) //"CFO "
	AADD(aHdList,OemtoAnsi(STR0050)) //"Base de C lculo"
	AADD(aHdList,STR0051) //"Imp.Creditado"
    AADD(aHdList,"CFO   ")
	AADD(aHdList,OemtoAnsi("Base de C lculo"))
	AADD(aHdList,STR0052) //"Imp.Debitado"
	DEFINE MSDIALOG oDlg2 TITLE OemtoAnsi(cTitulo) FROM  140,040 TO 420,600 PIXEL OF oMainWnd
	@ 003,007 TO 115, 275 LABEL "" OF oDlg2  PIXEL
	@ 008,010 TO 110, 140 LABEL "" OF oDlg2  PIXEL
	@ 008,142 TO 110, 272 LABEL "" OF oDlg2  PIXEL
	@ 013,060 SAY OemtoAnsi(STR0053) SIZE 50,07 OF oDlg2 PIXEL //"ENTRADAS"
	@ 013,197 SAY OemtoAnsi(STR0054) SIZE 50,07 OF oDlg2 PIXEL //"SAIDAS"
	@ 120,008 SAY OemtoAnsi(cMsgAdv) SIZE 150,07 OF oDlg2 PIXEL
	@ 020,010 LISTBOX oListEnt VAR cVar FIELDS HEADER aHdList[1],aHdList[2],aHdList[3] SIZE 130,90 PIXEL OF oDlg2
	oListEnt:SetArray(aExibe)
	oListEnt:bLine := { ||{Substr(aExibe[oListEnt:nAt],1,7),;
	xPadl(lTrim(Substr(aExibe[oListEnt:nAt],8,18)),100),;
	xPadl(lTrim(Substr(aExibe[oListEnt:nAt],27,13)),100)}}
	@ 020,142 LISTBOX oListSai VAR cVar FIELDS HEADER aHdList[4],aHdList[5],aHdList[6] SIZE 130,90 PIXEL OF oDlg2
	oListSai:SetArray(aExibe)
	oListSai:bLine := { ||{Substr(aExibe[oListSai:nAt],39,7),;
	xPadl(lTrim(Substr(aExibe[oListSai:nAt],46,18)),100),;
	xPadl(lTrim(Substr(aExibe[oListSai:nAt],65,13)),100)}}
	DEFINE SBUTTON FROM 120, 215 TYPE 1 ACTION oDlg2:End() ENABLE OF oDlg2
	DEFINE SBUTTON FROM 120, 244 TYPE 2 ACTION (nOpc:=2,oDlg2:End()) ENABLE OF oDlg2
	@ 120,10 BUTTON "Conferir Apuração" 	SIZE 045,012 ACTION FWMsgRun(, {|| ConfApIPI() }, "Processando", "") OF oDlg2 PIXEL
	ACTIVATE MSDIALOG oDlg2
EndIf

RETURN (nOpc==1)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ViewResumo  ³ Autor ³ Juan Jose Pereira  ³ Data ³ 09/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Exibe resumo apurado para entrada e ajuste de valores      ³±±
±±³          ³ pelo usuario                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA951,MATA952                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION ViewResumo(cImposto,cArqAnt,cImp,dDtIni,dDtFim,cNrLivro,aMensIPI,lAutomato,aCDAIPI)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define variaveis                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL	nOpc		:=	2
LOCAL	oDlg3
LOCAL	oList
LOCAL	cVar		:= ""
LOCAL	cTitulo		:=	STR0055+cImposto //"Resumo da Apura‡„o de "
LOCAL	bSetList
LOCAL	bLineList
LOCAL	bRefresh
Local	lUsaSped	:= SuperGetMv("MV_USASPED",,.T.) .And. aApurSX2[AI_CDP]  .And. aApurSX2[AI_CCK] 
Local	lMVRF3THRE	:=	GetNewPar( 'MV_RF3THRE' , .F. )
PRIVATE nPosOpc		:=1

DEFAULT aMensIPI := {}
DEFAULT lAutomato := .F.
DEFAULT aCDAIPI := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta array do resumo (aGetApur)                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LoadApur(cArqAnt,cImp,dDtIni,dDtFim,cNrLivro,@aMensIPI,@aCDAIPI)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Entrada de Dados                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If lUsaSped
	bSetList	:=	{||oList:SetArray(aGetApur)}
	bLineList:=	{||oList:bLine := { ||{	aGetApur[oList:nAt,1],;
					OemtoAnsi(aGetApur[oList:nAt,2]),;
					xPadl( IIf(aGetApur[oList:nAt,4]!="FL", Transform(aGetAPur[oList:nAt,3],"@E 999,999,999,999.99") , "" ) ,100),	OemtoAnsi(aGetApur[oList:nAt,5]),OemtoAnsi(Iif(aGetApur[oList:nAt,8]=="1","automático",Iif(aGetApur[oList:nAt,8]=="3","Config","")))}}}
	
	bRefresh	:=	{||Eval(bSetList),Eval(bLineList),oList:Refresh()}
	If !lAutomato	
		DEFINE MSDIALOG oDlg3 TITLE OemtoAnsi(cTitulo) FROM  130,052 TO 598,845 PIXEL OF oMainWnd
		@ 03,07 TO 227, 393 LABEL "" OF oDlg3  PIXEL
		@ 09,10 LISTBOX oList VAR cVar FIELDS HEADER OemtoAnsi("Campo"),OemtoAnsi("Descri‡„o"),OemtoAnsi("Valor"),OemtoAnsi("Cod. Ajuste"),OemtoAnsi("Tipo Ajuste"), ON DBLCLICK (IIf(AltGetApur(oList:nAt,cImp),Eval(bRefresh),)) SIZE 374,186 PIXEL OF oDlg3
		Eval(bSetList)
		Eval(bLineList)
		If lMVRF3THRE
			DEFINE SBUTTON FROM 208, 20 TYPE 5 ACTION ProcLogView() ENABLE OF oDlg3 ONSTOP 'Vizualização do LOG de processamento multi-thread'
		EndIf
		DEFINE SBUTTON FROM 208, 292 TYPE 1 ACTION (nOpc:=1,Iif(ValidCodIPI(aGetApur),oDlg3:End(),.F.)) ENABLE OF oDlg3
		DEFINE SBUTTON FROM 208, 330 TYPE 2 ACTION (nOpc:=2,oDlg3:End()) ENABLE OF oDlg3
		ACTIVATE MSDIALOG oDlg3
	Else
		nOpc := 1
	EndIF
Else
	bSetList	:=	{||oList:SetArray(aGetApur)}
	bLineList:=	{||oList:bLine := { ||{	aGetApur[oList:nAt,1],;
					OemtoAnsi(aGetApur[oList:nAt,2]),;
					xPadl( IIf(aGetApur[oList:nAt,4]!="FL", Transform(aGetAPur[oList:nAt,3],"@E 999,999,999,999.99") , "" ) ,100)}}}
	
	bRefresh	:=	{||Eval(bSetList),Eval(bLineList),oList:Refresh()}
	If !lAutomato	
		DEFINE MSDIALOG oDlg3 TITLE OemtoAnsi(cTitulo) FROM  100,040 TO 460,650 PIXEL OF oMainWnd
		@ 03,07 TO 175, 302 LABEL "" OF oDlg3  PIXEL
		@ 09,10 LISTBOX oList VAR cVar FIELDS HEADER OemtoAnsi("Campo"),OemtoAnsi("Descri‡„o"),OemtoAnsi("Valor"), ON DBLCLICK (IIf(AltGetApur(oList:nAt,cImp),Eval(bRefresh),)) SIZE 288,143 PIXEL OF oDlg3
		Eval(bSetList)
		Eval(bLineList)
		If lMVRF3THRE
			DEFINE SBUTTON FROM 160, 20 TYPE 5 ACTION ProcLogView() ENABLE OF oDlg3 ONSTOP 'Vizualização do LOG de processamento multi-thread'
		EndIf
		DEFINE SBUTTON FROM 160, 225 TYPE 1 ACTION (nOpc:=1,oDlg3:End()) ENABLE OF oDlg3
		DEFINE SBUTTON FROM 160, 254 TYPE 2 ACTION (nOpc:=2,oDlg3:End()) ENABLE OF oDlg3
		ACTIVATE MSDIALOG oDlg3
	Else
		nOpc := 1
	EndIf
EndIf

RETURN (nOpc==1)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CtAcho      ³ Autor ³ Juan Jose Pereira  ³ Data ³ 09/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao de controle de teclado do Achoice na ViewResumo     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION CtAcho(nModo,nElem,nPos)
LOCAL nRet	:=	3
LOCAL	nTecla:=	LastKey()

nPosOpc	:=	nPos
If nModo==3
	Do Case
		Case nTecla==27 
			nRet	:=	0
		Case nTecla==13 
			nRet	:=	1
	EndCase
Else
	nRet	:=	2
Endif
RETURN (nRet)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ AltGetApur  ³ Autor ³ Juan Jose Pereira  ³ Data ³ 09/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Exibe get para alteracao dos valores do array aGetApur     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
STATIC FUNCTION AltGetApur(nOpc,cImp)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define variaveis                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL	oDlg4
LOCAL	cCampo
LOCAL	cAltGetAp
LOCAL   cCodAju
LOCAL	cNumDoc
LOCAL	cIndDoc
LOCAL	cTpLanc
LOCAL   oIndDoc
LOCAL	nAltGetAp
LOCAL	nOpcGet	:=	2
LOCAL	cTitulo	:=	STR0056 //"Digite o valor do campo"
LOCAL	lRet	:=	.f.
Local	lUsaSped := SuperGetMv("MV_USASPED",,.T.) .And. aApurSX2[AI_CDP]  .And. aApurSX2[AI_CCK] 
Local 	aIndDoc  := CTBCBOX("CDP_INDDOC")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Controla campos que podem ser editados                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpc==0.or.!(aGetApur[nOpc,4]$"DD/TD/SG")
	RETURN (lRet)
EndIf

cCampo	:=	aGetApur[nOpc,1]
lWhen	:=	IIf(aGetApur[nOpc,4]=="SG",.T.,.T.)

If lUsaSped
	Do Case
		Case aGetApur[nOpc,4]$"DD/SG"
			nAltGetAp	:=	aGetApur[nOpc,3]
			cAltGetAp		:=	PadR(OemToAnsi(aGetApur[nOpc,2]),TamSx3("CDP_DESC")[1]) 
			cCodAju		:=  aGetApur[nOpc,5]
			cIndDoc		:=  aGetApur[nOpc,6]
			cNumDoc		:=  OemToAnsi(aGetApur[nOpc,7])
			cTpLanc		:=  aGetApur[nOpc,8]
		Case aGetApur[nOpc,4]=="TD"
			nAltGetAp	:=	0
			cAltGetAp		:=	Space(TamSx3("CDP_DESC")[1]) //Space(Len(aGetApur[nOpc,2]))
			cCodAju		:=  aGetApur[nOpc,5]
			cIndDoc		:=  aGetApur[nOpc,6]
			cNumDoc		:=  Space(Len(aGetApur[nOpc,7]))
			cTpLanc		:=  aGetApur[nOpc,8]
	EndCase
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre janela para edicao dos campos                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DEFINE MSDIALOG oDlg4 TITLE OemtoAnsi(cTitulo) FROM  260,104 TO 400,728 PIXEL OF oMainWnd
	@ 01, 003 TO 68, 310 LABEL "" OF oDlg4  PIXEL
	@ 05, 005	SAY OemToAnsi(STR0057) 		SIZE 020,08 OF oDlg4 PIXEL //"Campo"
	@ 05, 027 	SAY OemToAnsi(STR0058) 		SIZE 150,08 OF oDlg4 PIXEL //"Descricao"
	@ 05, 179 	SAY OemToAnsi(STR0059) 		SIZE 050,08 OF oDlg4 PIXEL //"Valor"
    If !(cCampo) == "007" 
	@ 05, 232   SAY OemToAnsi(STR0092) 		SIZE 050,08 OF oDlg4 PIXEL //"Cod. Ajuste"
	EndIf
	@ 15, 005 	SAY OemToAnsi(cCampo) 		SIZE 015,08 OF oDlg4 PIXEL //"Numero da Linha
	@ 30, 005	SAY OemToAnsi(STR0093) 		SIZE 100,08 OF oDlg4 PIXEL //"Origem Documento"
	@ 30, 107 	SAY OemToAnsi(STR0094) 		SIZE 050,08 OF oDlg4 PIXEL //"Numero Documento"
	@ 15, 027 	MSGET cAltGetAp WHEN lWhen VALID NaoVazio(cAltGetAp) SIZE 150,08 OF oDlg4 PIXEL
	@ 15, 179 	MSGET nAltGetAp PICTURE "@E 999,999,999,999.99" VALID NaoVazio(nAltGetAp) SIZE 050,08 OF oDlg4 PIXEL
  	If !(cCampo) == "007"   
		@ 15, 232 	MSGET cCodAju F3 "AJCCK" WHEN lWhen VALID ExistCpo("CCK",cCodAju) .And. NaoVazio(cCodAju) .and. VldNatCdAj(cCodAju,cCampo) SIZE 050,08 OF oDlg4 PIXEL
	EndIf
	@ 40, 005 	MSCOMBOBOX oIndDoc VAR cIndDoc ITEMS aIndDoc WHEN lWhen SIZE 100,08 OF oDlg4 PIXEL
	@ 40, 107 	MSGET cNumDoc WHEN lWhen SIZE 150,08 OF oDlg4 PIXEL //tamanho do numenro do documento
    If !(cCampo) == "007"
		DEFINE SBUTTON FROM 55, 228 TYPE 1 ACTION (nOpcGet:=1,If(lWhen,If (NaoVazio(cCodAju),oDlg4:End(),nOpcGet:=0),oDlg4:End())) ENABLE OF oDlg4
    Else 
    	DEFINE SBUTTON FROM 55, 228 TYPE 1 ACTION (nOpcGet:=1,oDlg4:End()) ENABLE OF oDlg4
    EndIf
    DEFINE SBUTTON FROM 55, 265 TYPE 2 ACTION (nOpcGet:=2,oDlg4:End()) ENABLE OF oDlg4
	DEFINE SBUTTON FROM 55, 190 TYPE 3 ACTION (nOpcGet:=4,oDlg4:End()) ENABLE OF oDlg4
	ACTIVATE MSDIALOG oDlg4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava ou cria campo novo                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	If nOpcGet==1
		If aGetApur[nOpc,4]$"DD/SG"
			aGetApur[nOpc,2]	:=	cAltGetAp
			aGetApur[nOpc,3]	:=	nAltGetAp
			aGetApur[nOpc,5]	:=	cCodAju
			aGetApur[nOpc,6]	:=	cIndDoc
			aGetApur[nOpc,7]	:=	cNumDoc
			aGetApur[nOpc,8]	:=	cTpLanc //'1-AUTOMATICO','2-MANUAL'
		Else
			nOpc   				:=	InsElem(nOpc)
			aGetApur[nOpc,2]	:=	cAltGetAp
			aGetApur[nOpc,3]	:=	nAltGetAp
			aGetApur[nOpc,5]	:=	cCodAju
			aGetApur[nOpc,6]	:=	cIndDoc
			aGetApur[nOpc,7]	:=	cNumDoc
			aGetApur[nOpc,8]	:=	cTpLanc
		Endif
	Endif
Else
   
	Do Case
		Case aGetApur[nOpc,4]$"DD/SG"
			nAltGetAp	:=	aGetApur[nOpc,3]
			cAltGetAp	:=	PadR(OemToAnsi(aGetApur[nOpc,2]),TamSx3("CDP_DESC")[1]) 
		Case aGetApur[nOpc,4]=="TD"
			nAltGetAp	:=	0
			cAltGetAp	:=	Space(TamSx3("CDP_DESC")[1])  //Space(Len(aGetApur[nOpc,2]))
	EndCase
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre janela para edicao dos campos                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DEFINE MSDIALOG oDlg4 TITLE OemtoAnsi(cTitulo) FROM  200,80 TO 300,560 PIXEL OF oMainWnd
	@ 01, 003 TO 25, 231 LABEL "" OF oDlg4  PIXEL
	@ 05, 005	SAY OemToAnsi(STR0057) 		SIZE 020,08 OF oDlg4 PIXEL //"Campo"
	@ 05, 027 	SAY OemToAnsi(STR0058) 	SIZE 150,08 OF oDlg4 PIXEL //"Descricao"
	@ 05, 179 	SAY OemToAnsi(STR0059) 		SIZE 050,08 OF oDlg4 PIXEL //"Valor"
	@ 15, 005 	SAY OemToAnsi(cCampo) 		SIZE 015,08 OF oDlg4 PIXEL
	@ 15, 027 	MSGET cAltGetAp WHEN lWhen VALID NaoVazio(cAltGetAp) SIZE 150,08 OF oDlg4 PIXEL
	@ 15, 179 	MSGET nAltGetAp PICTURE "@E 999,999,999,999.99" VALID lWhen .or. NaoVazio(nAltGetAp) SIZE 050,08 OF oDlg4 PIXEL
	DEFINE SBUTTON FROM 30, 175 TYPE 1 ACTION (nOpcGet:=1,oDlg4:End()) ENABLE OF oDlg4
	DEFINE SBUTTON FROM 30, 204 TYPE 2 ACTION (nOpcGet:=2,oDlg4:End()) ENABLE OF oDlg4
	DEFINE SBUTTON FROM 30, 146 TYPE 3 ACTION (nOpcGet:=4,oDlg4:End()) ENABLE OF oDlg4
	ACTIVATE MSDIALOG oDlg4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava ou cria campo novo                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nOpcGet==1
		If aGetApur[nOpc,4]$"DD/SG"
			aGetApur[nOpc,2]	:=	cAltGetAp
			aGetApur[nOpc,3]	:=	nAltGetAp
		Else
			nOpc	:=	InsElem(nOpc)
			aGetApur[nOpc,2]	:=	cAltGetAp
			aGetApur[nOpc,3]	:=	nAltGetAp
		Endif
	Endif
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Exclusao de campo                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpcGet==4
	DelElem(nOpc)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Refaz totais do array aGetApur                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpcGet==1.or.nOpcGet==4
	Apuracao(.t.,cImp)
	lRet	:=	.t.
Endif

RETURN (lRet)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ApurObserv  ³ Autor ³ Juan Jose Pereira  ³ Data ³ 09/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Entrada de observacoes e vencimento do pagamento do imposto³±±
±±³          ³ apurado                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA951                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION ApurObserv(cImposto,dDtFim,dDtVenc,lAutomato)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define variaveis                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL oDlg5
LOCAL lRet		:= .T.
LOCAL nOpc		:= 2
LOCAL cObserv	:= ""                                               		
LOCAL cOrgArrec := Space(30)
LOCAL cTitulo	:=	STR0060+cImposto //"Informa‡”es Complementares da Apura‡„o de "
Local i	:=0

DEFAULT lAutomato := .F.
Afill(aObserv,Space(46))                                            
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Abre janela para edicao                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lAutomato
	DEFINE MSDIALOG oDlg5 TITLE OemtoAnsi(cTitulo) FROM  150,80 TO 390,560 PIXEL OF oMainWnd
	@ 01, 012 TO 100, 228 LABEL "" OF oDlg5  PIXEL
	@ 07, 020 SAY OemToAnsi(STR0061) SIZE 80,08 OF oDlg5 PIXEL //"Data de Vencimento do Imposto:"
	@ 19, 020 SAY OemToAnsi(STR0145) SIZE 80,08 OF oDlg5 PIXEL //"Data de Emissão:"
	@ 31, 020 SAY OemToAnsi(STR0062) SIZE 60,08 OF oDlg5 PIXEL //"Org„o Arrecadador:"
	@ 45, 020 SAY OemToAnsi(STR0063) SIZE 80,08 OF oDlg5 PIXEL //"Observa‡”es:"
	@ 07, 101 MSGET dDtVenc VALID (dDtVenc>=dDtFim) WHEN (nVlrTitulo>0) SIZE 42,08 OF oDlg5 PIXEL  
	@ 19, 101 MSGET dDtEmiIPI /*VALID (dDtVenc>=dDtFim)*/ WHEN (nVlrTitulo>0) SIZE 42,08 OF oDlg5 PIXEL   
	@ 31, 071 MSGET cOrgArrec WHEN (nVlrTitulo>0) PICTURE "@!" SIZE 110,08 OF oDlg5 PIXEL
	@ 45, 060 GET cObserv SIZE 160,42 MEMO OF oDlg5 PIXEL
	DEFINE SBUTTON FROM 100, 172 TYPE 1 ACTION (nOpc:=1,oDlg5:End()) ENABLE OF oDlg5
	DEFINE SBUTTON FROM 100, 201 TYPE 2 ACTION (nOpc:=2,oDlg5:End()) ENABLE OF oDlg5
	ACTIVATE MSDIALOG oDlg5
Else
	nOpc := 1
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Acrescenta as informacoes complementares ao array aGetApur   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpc==1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Armazena vencimento e orgao arrecadador do imposto           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lTitulo .And. nVlrTitulo>0
		AADD(aGetApur,{"TIT",Space(12)+Dtoc(dDtVenc)+" "+TransForm(nVlrTitulo,"@E 999,999,999,999.99")+SPACE(8)+cOrgArrec,0})
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Armazena linhas de observacao                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For i:=1 to MLCount(cObserv)
		If Len(Alltrim(MemoTran(MemoLine(cObserv,,i),"")))>0
			AADD(aGetApur,{"OBS",MemoTran(MemoLine(cObserv,,i),""),})
		Endif
	Next
Endif
If nOpc==2
	lRet:=.f.
Endif

RETURN (lRet)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GravaTit    ³ Autor ³ Juan Jose Pereira  ³ Data ³ 25/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera Titulo a pagar de imposto apurado e efetua lancamento ³±±
±±³          ³ contabil                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA951                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/    

//TODO NOVO PARAMETRO CRIADO DEVE SER TRATADO NA FUNCAO FGvFluigWF PARA SE EVITAR
//ERROS QUANDO CLIENTE UTILIZA INTEGRACAO COM O FLUIG
Function GravaTit(lTitulo,;
				nVlrTitulo,;
				cImposto,;
				cImp,;
				cLcPadTit,;		//5
				dDtIni,;
				dDtFim,;
				dDtVenc,;
				nMoedTit,;
				lGuiaRec,;      //10
				nMes,;
				nAno,;
				nTitICMS,;
				nTitST,;
				cOrigem,;		//15
				lContab,;
				cNumero,;
				aGnre,;
				cClasse,;
				aGNREST,;		//20
				cUF,;
				cCodRetIPI,;
				lFECP,;
				lDifAlq,;
				cNumGnre,;		//25
				aRecTit,;
				lConfTit,;
				nTitFun,;
				aDadSf2,;
				lArt65,; 		//30
				cOriGNRE,;
				aApIncent,;
				cCodGnre,;
				nGuiaSN,;
				nConv139,;	 // 35
				lGTitFluig,; //Parametros utilizados para a experiencia 3 ( WorkFlow - Fiscal )
				cNrLivro,;   //Parametros utilizados para a experiencia 3 ( WorkFlow - Fiscal )
				nApuracao,;  //Parametros utilizados para a experiencia 3 ( WorkFlow - Fiscal )
				nPeriodo,;   //Parametros utilizados para a experiencia 3 ( WorkFlow - Fiscal )
				nNumSolFlg,; //Parametros utilizados para a experiencia 3 ( WorkFlow - Fiscal ) //40
				cForIss,;
				cLojISS,; // 42
				lDifal,;
				lAntParcBA,;
				cNumConv,; // 45
				lAutomato,;
				aRetAuto,;
				cCodMunRec,; // 48
				cTpImp,;
				cNatureza,; //50
				cObserv,;
				cItemNF,; //Parâmetro criado para controlar a geração de GNRE por produto, quando parte da nota efetuar a geração via legado e parte efetuar a geração da guia via configurador //52
				nValFund,; //53    Parâmetro que armazena o valor do fundo que é gravado junto com o ICMS (Próprio, Difal ou ST) quando a guia e gerada agrupada
				lWhenGet) //54 Parâmetro que indica se a rotina automatica for configurada para exibicao de tela
LOCAL cTipo     := ""
LOCAL cGetMv1   := ""
LOCAL cGetMv2   := ""
LOCAL cPrefixo  := ""
Local cPrefPar  := ""
LOCAL dVencReal := ""
LOCAL cHistorico:= ""
Local nX        := 0
Local nY        := 0
Local nJ		  := 0
Local cFornece	:= ""
Local cInsc		:= ""
Local lGerTit	:= .T.
Local cMVESTADO := SuperGetMV("MV_ESTADO")
Local cApICMP	:= SuperGetMv("MV_APICMP") //Natureza do Titulo de ICMS Complementar.
Local cApFECP	:= SuperGetMv("MV_APFECP") //Natureza do Titulo de FECP.
Local cApFunder	:= GetNewPar ("MV_APFUNDS","")	//Natureza do Titulo do Fundersul
Local cApSenar  := GetNewPar ("MV_APSENAR","")	//Natureza do Titulo do Senar
Local cApSNac	:= GetNewPar ("MV_APSINAC","")	//Natureza do Titulo do Simples Nacional
Local cMunic	:= GetNewPar ("MV_MUNIC","")	//Fornecedor dos titulos de ISS
Local cApICMST	:= GetNewPar ("MV_APICMST","")	//Natureza do Titulo do Simples Nacional
Local lFumacop	:= cMVESTADO == "MA" .And. SB1->B1_ALFUMAC <> 0 //FUMACOP
Local cGNRInfC	:= ""
Local cFornST	:= ""
Local cLojaST	:= ""
Local nTamForn	:= TamSX3("A2_COD")[1]
Local nTamLoja	:= TamSX3("A2_LOJA")[1]
Local nTamNF 	:= TamSX3("F2_DOC")[1]
Local aSvRot	:= Nil
Local lGravaSF6 := .F.
Local aCamps		:= {}
Local aCampAt		:= {}
Local lMVLEGM953	:= GetNewPar ("MV_LEGM953",.F.)
Local lNgnreNf		:= GetNewPar("MV_GNRENF",.F.)
Local nVFecpST 		:= 0
Local nVlrConv 		:= 0
Local nMVDATPAG 	:= GetNewPar("MV_DATAPAG",0)
Local cApProtege	:= GetNewPar ("MV_PROTEGE","")//Natureza do Titulo de PROTEGE - GO.
Local nPos := 0
Local nPosGNRE 		:= 0
Local cTipoDoc		:= "  "
Local aAreaSA2		:= SA2->(GetArea())
Local aAreaSED		:= SED->(GetArea())
Local aAreaSE2		:= SE2->(GetArea())
Local aAreaSF2		:= SF2->(GetArea())
Local cFilSF1	    := ""
Local nTamASF6		:= 0
Local aCposAut		:= {}
Local aInfoFluig     := {}
Local lGerSolFlg     := .T.
Local aFornGNRE := {}
Local cGNRImp 		:= ""
Local cMVDATAVNC 	:= GetNewPar("MV_DATAVNC","")
Local nMVDATAVNC	:= Iif(!Empty(cMVDATAVNC),VAL(cMVDATAVNC),-1)
Local dVenParBA := cToD("//")
Local lBlqEdtNr := .F.
Local aCmpAlt := {}
Local aAuto 		:= {}
Local cCNPJ := ""
Local aAreaSA1   := SA1->( GetArea () )
Local cApFEEF    := GetNewPar ("MV_FEEFRJ","")//Natureza do Titulo de FEEF-RJ
Local cMensagem  := ""
Local cTpApurCDA := ""
Local cFilSx5    := xFilial("SX5")
Local lCPAPUICMS := aExistBloc[PE_CPAPUICMS]
Local lTITICMST  := aExistBloc[PE_TITICMST]	
Local lINFOGNRE  := aExistBloc[PE_INFOGNRE]	
Local lAlcAprov  := SuperGetMV( "MV_FINCTAL", .T., "1" ) == "2"
Local lTribGen   := .F.
Local cMV_STNIEUF := SUPERGETMV("MV_STNIEUF",.F.,"")
Local cMV_ICMS 	:= SuperGetMv("MV_ICMS",.F.,"ICMS")
Local cMV_RECEST 	:= SuperGetMV("MV_RECEST")
Local cMV_IPI 	:=	SuperGetMv("MV_IPI")
Local cMV_UNIAO := 	SuperGetMv("MV_UNIAO")
Local cMV_APURISS := SuperGetMv("MV_APURISS")
Local cMV_ISS	  := SuperGetMv("MV_ISS")
Local cMV_MUNIC := SuperGetMv("MV_MUNIC")
Local cMV_PFAPUIC	:= GetNewPar("MV_PFAPUIC","")
Local cMV_PFAPIP	:= GetNewPar("MV_PFAPUIP","")
Local cMV_PFAPIS	:= GetNewPar("MV_PFAPUIS","")
Local cMV_PFAPSF	:= GetNewPar("MV_PFAPUSF","")
Local cMV_PFAPFD	:= GetNewPar("MV_PFAPUFD","")
Local cMV_PFSENAR	:= GetNewPar("MV_PFSENAR","")
Local cMV_PFAPUSN	:= GetNewPar("MV_PFAPUSN","")
Local nOpc 			:= 0
Local aDadoSX5      := {}

DEFAULT dDtIni     := cToD("//")
DEFAULT dDtFim     := cToD("//")
DEFAULT cCodGnre   := ""
DEFAULT cClasse    := space(06)
DEFAULT aGNREST    := {}
DEFAULT cUF        := SuperGetMV("MV_ESTADO")
DEFAULT cCodRetIPI := ""
DEFAULT lFECP      := .F.
DEFAULT lDifAlq    := .F.
DEFAULT cNumGnre   := Space (TamSx3("F6_NUMERO")[1])
DEFAULT aRecTit    := {}
DEFAULT aDadSf2    := {}
DEFAULT lConfTit   := .F.
DEFAULT lContab    := .F.
DEFAULT nTitFun    := 0
DEFAULT lArt65     := .F.
DEFAULT cOriGNRE   := "RECSALDO"
DEFAULT aApIncent  := {}
DEFAULT nGuiaSN    := 0
DEFAULT nConv139   := 0
DEFAULT lGTitFluig := .F.
DEFAULT cForIss    := ""
DEFAULT cLojISS    := ""
DEFAULT lDifal     := .F.
DEFAULT lAntParcBA := .F.
DEFAULT cNumConv   := Space (TamSx3("F6_NUMCONV")[1])
DEFAULT lAutomato  := .F.
DEFAULT aRetAuto   := {}
DEFAULT cCodMunRec := ""
DEFAULT cTpImp     := ""
DEFAULT cNatureza  := ""
DEFAULT cObserv    := ""
DEFAULT cItemNF    := ""
DEFAULT nValFund   := 0
DEFAULT lWhenGet   := .F.

PRIVATE cCadastro := OemtoAnsi(STR0070) //Guia de Recolhimento
PRIVATE lRefresh  := .T.
PRIVATE Inclui    := .T.

/* 
	Verifico se a guia está sendo gerada para um tributo que consta na lista do Configurador de Tributos. 
 	Caso isso ocorra, a geração da guia será abortada, pois deverá prevalecer a regra do configurador.
*/
If cPaisLoc=="BRA" .And. lExistF2B .And. lExistCJ4 .And. lGuiaRec .And. (cOrigem == "MATA103" .Or. cOrigem == "MATA460A") .And. Len(aDadSf2) > 0
	lTribGen := ChkCfgTrib(cOrigem, cImp, @nTitICMS, @nTitST, lFECP,lDifAlq,cItemNF)
EndIf

If !lTribGen

	//Abertura de tabelas (set do indice utilizado na funcao)
	DbSelectArea("SA2")
	SA2->(DbSetOrder(1))
	DbSelectArea("SED")
	SED->(DbSetOrder(1))
	DbSelectArea("SE2")
	SE2->(DbSetOrder(1))
	DbSelectArea("SX5")
	SX5->(DbSetOrder(1))
	DbSelectArea("CE1")
	CE1->(DbSetOrder(1))
	DbSelectArea("SC5")
	SC5->(DbSetOrder(1))
	DbSelectArea("SA1")
	SA1->(DbSetOrder(1))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Nao gero titulo para quando apuracao de IPI tiver um valor de debito inferior ao informado no parametro.³
	//³Neste momento o valor minimo de he R$ 10,00 para o estado de Sao Paulo - Lei 9.430/96, art 68.          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lTitulo .And. !(GeraLinhaApur (nVlrTitulo, cOrigem))
		nVlrTitulo := 0
	EndIf

	//Tratamento para notas Emitidas pelo faturamento considerar parametro MV_DATAVNC para determinar
	//quantidade de dias uteis para data de vencimento do titulo e GNRE de Difal e ICMS ST
	IF cOrigem == "MATA460A" .And. nMVDATAVNC >= 0 .And. (lDifal .Or. nTitST > 0)
		dDtVenc := SomaData(nMVDATAVNC,dDatabase)
	Endif

	//Tratamento para título e guia de recolhimento de Antecipacao Parcial - BA.
	//O recolhimento poderá ser efetuado até o dia 25 do mês subsequente ao da entrada da mercadoria.
	If cOrigem == "MATA103" .And. lAntParcBA .And. nTitST > 0
		dVenParBA := cToD("25" + "/" + cValtoChar(Month(dDtvenc)) + "/" + cValtoChar(Year(dDtvenc)))
		dDtvenc := DataValida(dVenParBA, .T.)
	EndIf

	//Em situacoes de geracao de titulo/GNRE de ICMS-ST sera verificado se o contribuinte tem IE
	//na UF do recolhimento. Essa verificacao sera feita pelo MV_SUBTRIB.
	If cOrigem == "MATA953"
		If nTitST > 0
			nVlrTitulo := nTitST

			//Tratamento para permitir que indepdendente do SUBTRIB, as operacoes internas com ST gerem a GNRE
			//normalmente; mesmo que não tenha a inscricao no subtrib mais tenha a IE no SIGAMAT.
			//Este tratamento é para manter o legado que nao obrigava o contribuinte a informar a IE do estado domiciliado no SUBTRIB
			If lMVLEGM953 .And. cUF==cMVESTADO .And. !Empty(SM0->M0_INSC)
				cInsc := SM0->M0_INSC
			Else
				IF cUF==cMVESTADO //Gera guia ede ICMS proprio com inscricao do contribuinte no SIGAMAT
					cInsc := SM0->M0_INSC
				Else
					cInsc := IESubTrib(cUf,lDifal)
				endif
			Endif

			If Empty(cInsc)
				//Tratamento para acordo entre os estados preenchidos no parametro MV_STNIEUF, quando em
				//um movimento com ICMS-ST nao e' necessario ter incscricao estadual, assim esse tratamento
				//retorna a incricao " " para gerar a guia de recolhimento para o estado destino
				//Este tratamento foi feit a partir da necessidade das UF de MG p/ PR,onde existe esse acordo
				//PROTOCOLO ICMS CONSELHO NACIONAL DE POLÍTICA FAZENDÁRIA - CONFAZ Nº 191 DE 11.12.2009
				If !(AllTrim(cMVESTADO+cUF)$AllTrim(cMV_STNIEUF))
					Return .F.
				EndIf
			EndIf
		Else
			//Gera guia ede ICMS proprio com inscricao do contribuinte no SIGAMAT
			cInsc := SM0->M0_INSC
		EndIf
	EndIf

	//ByPass quando nao deve gerar titulo
	If lTitulo .and. nVlrTitulo > 0

		//Dados do Titulo
		Do Case
			Case cImp=="IC"
				cPrefixo:= "ICM"
				cGetMv1 := cMV_ICMS
				cGetMv2 := cMV_RECEST

				//Verifica se existe o parametro para o fornecedor padrao por estado - ST
				cFornST := ""
				cLojaST := ""
				aFornGNRE := StrToKarr(cGetMv2, ";") 
				If Len(aFornGNRE) >= 2
					cFornST := PadR(aFornGNRE[1], nTamForn)
					cLojaST := PadR(aFornGNRE[2], nTamLoja)
					//	Ajusto a variavel para que seja usada no seek logo abaixo
					cGetMv2 := cFornSt + cLojaSt
				EndIf
				If cMVESTADO <> cUF
					cGetMv2 := '"MV_RECST' + cUF + '"'
					cGetMv2 := SuperGetMv(&cGetMv2)

					aFornGNRE := StrToKarr(cGetMv2, ";")

					If Len(aFornGNRE) >= 2
						cFornST := PadR(aFornGNRE[1], nTamForn)
						cLojaST := PadR(aFornGNRE[2], nTamLoja)
					EndIf

					//	Ajusto a variavel para que seja usada no seek logo abaixo
					cGetMv2 := cFornSt + cLojaSt
				EndIf
				//Natureza do Titulo de ICMS ST
				If nTitST <> 0 .And. !Empty (cApICMST)
					cGetMv1 := cApICMST
				Endif

				//Natureza do Titulo de FECP.
				If (lFECP) .And. !Empty (cApFECP)
					cGetMv1 := cApFECP

				//Natureza do Titulo de ICMS Complementar.
				ElseIf (lDifAlq) .And. !Empty (cApICMP)
					cGetMv1 := cApICMP
				EndIf

				If Len(aApIncent) > 0
					cPrefixo:= Iif ( aApIncent[6] <> Nil, aApIncent[6], cPrefixo )
					cGetMv1 := Iif ( aApIncent[7] <> Nil, aApIncent[7], cGetMv1 )
					cGetMv2 := cMV_RECEST
				Endif

			Case cImp=="IP" .Or. cImp=="SI"
				cPrefixo:= "IPI"
				cGetMv1 := cMV_IPI
				cGetMv2 := cMV_UNIAO
			Case cImp=="IS"
				cPrefixo := "ISS"

				// Atribui fornecedor do titulo com base na apuração de ISS
				If !(Empty(cForIss))
					cMunic := cForIss
				EndIf

				// Atribui loja do titulo com base na apuração de ISS
				If !(Empty(cLojISS))
					cMunic += cLojISS
				EndIf

				// Natureza alternativa para o titulo a pagar de ISS
				If cMV_APURISS == ""
					cGetMv1 := &(cMV_ISS)
				Else
					cGetMv1 := cMV_APURISS
				Endif
				If Empty(cMunic)
					cGetMv2 := SUBS("MUNICIPIO",1,TAMSX3("A2_COD")[1])
				Else
					cGetMv2 := cMunic
				Endif
			Case cImp=="FD"
				cGetMv1		:=	Iif(!Empty(cApFunder),cApFunder,cMV_ICMS) 
				cGetMv2		:=	cMV_RECEST
				cPrefixo	:=	"FDS"
			Case cImp=="SE"
				cGetMv1		:=	Iif(!Empty(cApSenar),cApSenar,cMV_ICMS) 
				cGetMv2		:=	cMV_UNIAO
				cPrefixo	:=	"SEN"
			Case cImp=="SN"
				cGetMv1		:=	Iif(!Empty(cApSNac),cApSNac,cMV_ICMS) 
				cGetMv2		:=	cMV_RECEST
				cPrefixo	:=	"SPN"
			Case cImp=="PR"
				cGetMv1		:=	Iif(!Empty(cApProtege),cApProtege,cMV_ICMS) 
				cGetMv2		:=	cMV_RECEST
				cPrefixo	:=	"PTG"
			Case cImp=="FEEF"
				cGetMv1		:=	Iif(!Empty(cApFEEF),cApFEEF,cMV_ICMS) 
				cGetMv2		:=	cMV_RECEST
				cPrefixo	:=	"FEE"
		EndCase

		cTipo := "TX"+Space(TamSx3("E2_TIPO")[1]-2)

		If Empty(cNatureza)
			cNatureza := cGetMv1
		EndIf

		If Empty(cFornST)
			cFornece  := cGetMv2
		Else
			cFornece  := cFornST
		Endif

		cFornece  := Padr(cFornece,Len(SE2->E2_FORNECE))
		dVencReal := dDtVenc

		If (cOrigem == "MATA953" .Or. cOrigem == "MATA952") .AND. Empty(cObserv)
			cHistorico := cImposto+": "+DtoC(dDtIni)+" A "+Dtoc(dDtFim)
		Else
			cHistorico := cObserv
		Endif

		//Determina lancamento automatico
		cLA := IIf(VerPadrao(cLcPadTit),"S","N")

		//Nao gera o titulo de ST de outros estados se nao existir o parametro/fornecedor³
		If cImp == "IC" .And. cMVESTADO <> cUF .And. (Empty(cGetMv2) .Or. SA2->(!dbSeek(xFilial("SA2")+cGetMv2)))
			If Empty(cGetMv2)
				Alert(STR0097+cUF+STR0098+Chr(13)+Chr(10)+STR0143)
			ElseIf SA2->(!dbSeek(xFilial()+cGetMv2))
				Alert(STR0099+cUF+STR0100)
			EndIf
			lGerTit := .F.
		Endif

		//senar
		If (aApurSX3[FP_F6_TIPOIMP] .and. nTitFun > 0 .and. cOrigem == "MATA953") .and.  cImp == "SE" 
			// Uso o numero gravado da tabela.
			If Empty(cNumGnre)
				SX5->(dbSeek(cFilSx5+"53"+cImposto))
				cNumGnre := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
			EndIf
			AADD(aDadSF6,{nTitFun,dDataBase,nMes,nAno,dDtVenc,"9",cClasse,cMVESTADO,cNumGnre})//imposto a recolher
			cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo+" / Senar" //"Guia de Recolhimento do Senar"

			If lAutomato

				AADD(aAuto,{"F6_NUMERO",cNumGnre,Nil})
				AADD(aAuto,{"F6_EST",cMVESTADO,Nil})
				AADD(aAuto,{"F6_TIPOIMP","9",Nil})
				AADD(aAuto,{"F6_VALOR",nTitFun,Nil})
				AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
				AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
				AADD(aAuto,{"F6_MESREF",nMes,Nil})
				AADD(aAuto,{"F6_ANOREF",nAno,Nil})

				For nJ := 1 to Len(aRetAuto)
					If aRetAuto[nJ][1] == cMVESTADO .And. aRetAuto[nJ][2] == "9"
						AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
					EndIf
				Next nJ

			EndIf

			If xApIncSF6("SF6",1,3,"FisIcmF6",,"SF6TudoOk()",If(lAutomato,aAuto,Nil)) == 1 
				AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE})
			Else
				FWAlertInfo("Ao efetuar o cancelamento da Guia do SENAR, o título do SENAR não será gerado.", "ATENÇÃO")
				lGerTit := .F.	
			EndIf
		Endif

		//FETAHB
		If (aApurSX3[FP_F6_TIPOIMP] .and. nTitFun > 0 .and. cOrigem == "MATA953") .and.  cImp == "FET" 
			// Uso o numero gravado da tabela.
			If Empty(cNumGnre)
				aDadoSX5:= FWGetSX5('53','FDS')
				cNumGnre := Soma1(Substr(aDadoSX5[1][4],1,nTamNF),nTamNF)
				asize(aDadoSX5, 0)
			EndIf
			AADD(aDadSF6,{nTitFun,dDataBase,nMes,nAno,dDtVenc,"E",cClasse,cMVESTADO,cNumGnre,"","","","","","",cInsc,cTipoDoc})//imposto a recolher
			cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo+" / FETHAB" //"Guia de Recolhimento do fethab"

			If lAutomato
				AADD(aAuto,{"F6_NUMERO",cNumGnre,Nil})
				AADD(aAuto,{"F6_EST",cMVESTADO,Nil})
				AADD(aAuto,{"F6_TIPOIMP","E",Nil})
				AADD(aAuto,{"F6_VALOR",nTitFun,Nil})
				AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
				AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
				AADD(aAuto,{"F6_MESREF",nMes,Nil})
				AADD(aAuto,{"F6_ANOREF",nAno,Nil})

				For nJ := 1 to Len(aRetAuto)
					If aRetAuto[nJ][1] == cMVESTADO .And. aRetAuto[nJ][2] == "9"
						AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
					EndIf
				Next nJ
			EndIf

			nOpc := xApIncSF6("SF6",1,3,"FisIcmF6",,"SF6TudoOk()",If(lAutomato,aAuto,Nil))

			If nOpc == 1
				AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE})
			ElseIf nOpc == 3
				//Preencho o array para chamar a funcao que grava a SF6 sem usar a tela assim mesmo se clicar em cancelar gravo a SF6 para gerar o E116
				AADD(aDadSF2, {SD2->D2_DOC, SD2->D2_SERIE,SD2->D2_CLIENTE,SD2->D2_LOJA,"","2"})
				xApGrvSF6(aDadSF2, aDadSF6, cPrefixo + cNumero, cCodGnre)
				AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE})

				FWAlertInfo("Ao efetuar o cancelamento da Guia do FETHAB, o título do FETHAB não será gerado.", "ATENÇÃO")
				lGerTit := .F.	
			EndIf
		Endif
		
		If lGerTit

			//Grava a informação de que o estado gerou o titulo
			If cMVESTADO <> cUF .And. cOrigem == "MATA953"
				nX := aScan(aGNREST,{|x| x[1]==cUF})
				IF nX > 0 .And. !lGTitFluig
					aGNREST[nX][03] := .T.
				EndiF
			Endif

			Begin Transaction

				//Numero do Titulo a ser gerado
				If SX5->(dbSeek(cFilSx5+"53"+cImposto))
					//DSERFISE-5232: Por conta da geração da GNRE do SENAR estar ocorrendo antes da geração do título, não deve ser obtida nova numeração.
					//QUando a geração das guias dos demais tributos foram migra
					If !(Empty(cNumGnre) .And. Upper(Alltrim(cImposto)) == "SENAR") 
						cNumero := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
					EndIf

					//Cria o fornecedor, caso nao exista
					IF (cGetMv2 == cMV_MUNIC)
						cGetMv2 := cMV_MUNIC
					ENDIF
					If SA2->(!dbSeek(xFilial()+cGetMv2))
						Reclock("SA2",.T.)
						SA2->A2_FILIAL := xFilial("SA2")
						If Empty(cFornST)
							SA2->A2_COD  := cGetMv2
						Else
							SA2->A2_COD  := cFornST
						Endif
						If Empty(cLojaST)
							SA2->A2_LOJA := "00"
						Else
							SA2->A2_LOJA := cLojaST
						Endif
						SA2->A2_BAIRRO := "."
						SA2->A2_MUN    := "."
						SA2->A2_EST    := cMVESTADO
						SA2->A2_END    := "."
						Do Case
							Case cImp=="IC" .Or. cImp=="FD"
								SA2->A2_NOME 	:= "RECEITA ESTADUAL"
								SA2->A2_NREDUZ	:= "ESTADO"
							Case cImp=="IP" .Or. cImp=="SI" .Or. cImp=="SN"
								SA2->A2_NOME 	:= "UNIAO"
								SA2->A2_NREDUZ	:= "UNIAO"
							Case cImp=="IS"
								SA2->A2_NOME	:= "MUNICIPIO"
								SA2->A2_NREDUZ	:= "MUNICIPIO"
						EndCase
						MsUnlock()
						SA2->(FKCommit())
					EndIF

					//Cria a natureza ICMS caso nao exista
					If SED->(!dbSeek(xFilial("SED")+cGetMv1))
						RecLock("SED",.T.)
						SED->ED_FILIAL  := xFilial()
						SED->ED_CODIGO  := cGetMv1
						SED->ED_CALCIRF := "N"
						SED->ED_CALCISS := "N"
						SED->ED_DESCRIC := cImposto
						MsUnlock()
						SED->(FKCommit())
					EndIf

					//Converte valor do Titulo
					nVlrConv := xMoeda(nVlrTitulo,1,nMoedTit,dDataBase)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Verifica se existem parametros para definicao do prefixo ³
					//³ Apenas para títulos gerados via apuração.                ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If cOrigem == "MATA953" .Or. cOrigem == "MATA952" .or. cOrigem == "MATA954"
						Do Case
						Case cImp=="IC"
							If !Empty( cPrefPar := &( cMV_PFAPUIC ) )
								cPrefPar := Iif(substr(cPrefPar,1,1)=='"',&(cPrefPar),cPrefPar)
								cPrefixo := cPrefPar
							EndIf
						Case cImp=="IP"
							If !Empty( cPrefPar := &( cMV_PFAPIP ) )
								cPrefixo := cPrefPar
							EndIf
						Case cImp=="IS"
							If !Empty( cPrefPar := &( cMV_PFAPIS ) )
								cPrefixo := cPrefPar
							EndIf
						Case cImp=="SI"
							If !Empty( cPrefPar := &( cMV_PFAPSF ) )
								cPrefixo := cPrefPar
							EndIf
						Case cImp=="FD"
							If !Empty( cPrefPar := &( cMV_PFAPFD ) )
								cPrefixo := cPrefPar
							EndIf
						Case cImp=="SE"
							If !Empty( cPrefPar := &( cMV_PFSENAR ) )
								cPrefixo := cPrefPar
							EndIf
						Case cImp=="SN"
							If !Empty( cPrefPar := &( cMV_PFAPUSN ) )
								cPrefixo := cPrefPar
							EndIf
						EndCase
					EndIf

					If SE2->(!dbSeek(xFilial("SE2")+cPrefixo+Iif(cOrigem == "MATA103", aDadSf2[1][1] ,cNumero)+Space(Len(SE2->E2_PARCELA))+cTipo+cFornece+SA2->A2_LOJA))

						//Caso utilize o Fluig nao sera gerado o titulo neste momento, apenas serao
						//gravadas as informacoes na tabela CH3 e apos a confirmacao da solicitacao no FLUIG
						//o titulo sera gerado
						If lGTitFluig

							//Funcao para gravar as informacoes para posterior processamento da apuracao
							Aadd( aInfoFluig, { cNumero,;
												cPrefixo,;
												cTipo,;
												cNatureza,;
												cFornece,;
												SA2->A2_LOJA,;
												SA2->A2_NREDUZ,;
												nMoedTit,;
												nVlrConv,;
												cHistorico,;
												cLA,;
												dDataBase,;
												dVencReal,;
												cOrigem,;
												cFilAnt,;
												Iif( cImp == "IP" .and. len(cCodRetIPI) == 4, cCodRetIPI, "" ),;
												lContab } )
						Else
							RecLock("SE2",.T.)
							SE2->E2_FILIAL     := xFilial("SE2")
							SE2->E2_NUM        := Iif(cOrigem == "MATA103", aDadSf2[1][1] ,cNumero)
							SE2->E2_PREFIXO    := cPrefixo
							SE2->E2_TIPO       := cTipo
							SE2->E2_NATUREZ    := cNatureza
							SE2->E2_FORNECE    := cFornece
							SE2->E2_LOJA       := SA2->A2_LOJA
							SE2->E2_NOMFOR     := SA2->A2_NREDUZ
							SE2->E2_MOEDA      := nMoedTit
							SE2->E2_VALOR      := nVlrConv
							SE2->E2_SALDO      := nVlrConv
							SE2->E2_VLCRUZ     := nVlrConv
							SE2->E2_HIST       := cHistorico
							SE2->E2_LA         := cLA
							SE2->E2_EMISSAO    := iif(Empty(dDtEmiIPI),dDataBase,dDtEmiIPI)
							SE2->E2_VENCTO     := dVencReal
							SE2->E2_VENCREA    := DataValida(dVencReal,.T.)
							SE2->E2_VENCORI    := dVencReal
							SE2->E2_EMIS1      := dDataBase
							SE2->E2_ORIGEM     := cOrigem
							SE2->E2_FILORIG    := cFilAnt
							If lAlcAprov
								SE2->E2_CODAPRO:= FA050Aprov(nMoedTit)
							EndIf

							If cImp == "IP" .and. len(cCodRetIPI) == 4
								SE2->E2_CODRET := cCodRetIPI
							EndIf

							If cOrigem == "MATA103" .And. Alltrim(cTipo) == Alltrim(MVTAXA) .And. !lGTitFluig
								dbSelectArea("SF1")
								SF1->(dbSetOrder(1))
								cFilSF1	:= xFilial("SF1")
								If SF1->(MsSeek(cFilSF1+aDadSf2[1][1]+aDadSf2[1][2]+aDadSf2[1][3]+aDadSf2[1][4]))
									RecLock("SF1",.F.)
									SF1->F1_NUMTRIB := aDadSf2[1][1]
								EndIf
							EndIf
						EndIf
					Else
						//Realiza a busca de um Numero de Titulo ainda nao usado
						While SE2->(dbSeek(xFilial("SE2")+cPrefixo+cNumero+Space(Len(SE2->E2_PARCELA))+cTipo+cFornece+SA2->A2_LOJA))
							cNumero := Soma1(cNumero)
						EndDo

						//Caso utilize o Fluig nao sera gerado o titulo neste momento, apenas serao
						//gravadas as informacoes na tabela CH3 e apos a confirmacao da solicitacao no FLUIG
						//o titulo sera gerado
						If lGTitFluig

							//Funcao para gravar as informacoes para posterior processamento da apuracao
							Aadd( aInfoFluig, { cNumero,;
												cPrefixo,;
												cTipo,;
												cNatureza,;
												cFornece,;
												SA2->A2_LOJA,;
												SA2->A2_NREDUZ,;
												nMoedTit,;
												nVlrConv,;
												cHistorico,;
												cLA,;
												dDataBase,;
												dVencReal,;
												cOrigem,;
												cFilAnt,;
												Iif( cImp == "IP" .and. len(cCodRetIPI) == 4, cCodRetIPI, "" ),;
												lContab } )

						Else

							RecLock("SE2",.T.)
							SE2->E2_FILIAL     := xFilial("SE2")
							SE2->E2_NUM        := cNumero
							SE2->E2_PREFIXO    := cPrefixo
							SE2->E2_TIPO       := cTipo
							SE2->E2_NATUREZ    := cNatureza
							SE2->E2_FORNECE    := cFornece
							SE2->E2_LOJA       := SA2->A2_LOJA
							SE2->E2_NOMFOR     := SA2->A2_NREDUZ
							SE2->E2_MOEDA      := nMoedTit
							SE2->E2_VALOR      := nVlrConv
							SE2->E2_SALDO      := nVlrConv
							SE2->E2_VLCRUZ     := nVlrConv
							SE2->E2_HIST       := cHistorico
							SE2->E2_LA         := cLA
							SE2->E2_EMISSAO    := dDataBase
							SE2->E2_VENCTO     := dVencReal
							SE2->E2_VENCREA    := DataValida(dVencReal,.T.)
							SE2->E2_VENCORI    := dVencReal
							SE2->E2_EMIS1      := dDataBase
							SE2->E2_ORIGEM     := cOrigem
							SE2->E2_FILORIG    := cFilAnt
							If lAlcAprov
								SE2->E2_CODAPRO:= FA050Aprov(nMoedTit)
							EndIf
							If cImp == "IP" .and. len(cCodRetIPI) == 4
								SE2->E2_CODRET := cCodRetIPI
							EndIf

							//Se for um titulo de TX, o cliente deve ter executado UPDFIS para
							//criacao do campo F1_NUMTRIB
							If cOrigem == "MATA103" .And. Alltrim(cTipo) == Alltrim(MVTAXA) .And. !lGTitFluig
								dbSelectArea("SF1")
								SF1->(dbSetOrder(1))
								cFilSF1	:= xFilial("SF1")
								If SF1->(MsSeek(cFilSF1+aDadSf2[1][1]+aDadSf2[1][2]+aDadSf2[1][3]+aDadSf2[1][4]))
									RecLock("SF1",.F.)
									SF1->F1_NUMTRIB := cNumero
								EndIf
							EndIf
						Endif
					EndIf

					If !lGTitFluig
						If lTITICMST
							//-- As regras abaixo devem ser alteradas conforme da guia de recolhimento (SF6)
							cTipoImp := "1"
							If nTitICMS > 0 .And. (cOrigem == "MATA953" .Or. cOrigem == "MATA460A" .Or. cOrigem == "MATA913")
								cTipoImp  := "1"
							ElseIf nTitICMS > 0 .And. cOrigem == "MATA954"
								cTipoImp  := "2"
							ElseIf nTitFun > 0 .And. cOrigem == "MATA953" .And. cImp == "FD"
								cTipoImp  := "6"
							ElseIf nTitFun > 0 .And. cOrigem == "MATA953" .And. cImp == "SE"
								cTipoImp  := "9"
							ElseIf nTitFun > 0 .And. cOrigem == "MATA953" .And. cImp == "FU"
								cTipoImp  := "A"
							ElseIf nConv139 > 0 .And. cOrigem == "MATA953" .And. Substr(cImp,1,3) == "IC"
								cTipoImp  := "1"
							ElseIf nTitFun  > 0 .And. cOrigem == "MATA953" .And. Substr(cImp,1,3) == "IC" .And. Len(aApIncent) > 0
								cTipoImp  := "1"
							ElseIf nTitICMS > 0 .And. cOrigem == "MATA924"
								cTipoImp  := "7"
							ElseIf nGuiaSN > 0 .And. cOrigem == "MATA924"
								cTipoImp  := "7"
							ElseIf nTitST > 0 .And. (cOrigem == "MATA953" .Or. cOrigem == "MATA460A" .Or. cOrigem == "MATA103")
								If cOrigem $ "MATA460A/MATA953" .And. lDifal .And. (lFECP .Or. lDifAlq)
									If lFECP .And. lFumacop
										cTipoImp :='A' //FUMACOP
									Else
										cTipoImp := "B"
									EndIf
								Else
									If lAntParcBA
										cTipoImp := "0"
									Else
										cTipoImp := "3"
									EndIf
								EndIf
							EndIf
							aTITICMST := ExecBlock("TITICMST", .F., .F., {cOrigem,cTipoImp, lDifal})
							If aTITICMST<>Nil .And. ValType(aTITICMST)=="A"
								cNumero := Iif(Len(aTITICMST)>=1,aTITICMST[1],cNumero)
								dDtVenc := Iif(Len(aTITICMST)>=2,aTITICMST[2],dDtVenc)
							EndIf
						EndIf

						// PE para gravar campos no Contas a Pagar não gravados na apuração (Centro Custo, Item Contábil)
						If lCPAPUICMS
							ExecBlock("CPAPUICMS",.F.,.F.,{"SE2"})
						Endif

						MsUnlock()

						// O registro sera utilizado para exibir o titulo gerado no SE2 pelo Mata953
						Aadd(aRecTit,{SE2->(RecNo()),""})

						// Indica que todas as condicoes para geracao do titulo foram atendidas e o SE2 foi gerado
						lConfTit := .T.
					EndIf

					//Gravacao do Numero do Titulo no SX5
					FwPutSX5( , '53', cImposto, cNumero, cNumero, cNumero)

					If !lGTitFluig
						//Efetua Lancamento Contabil
						If lContab
							LancCont(cLcPadTit,cOrigem,lContab)
						Endif
					EndIf

				Endif

			End Transaction

			//Armazena numero e valor do titulo para ser gravado em arquivo texto
			If cOrigem$"MATA951#MATA952#MATA913" .And. !lGTitFluig
				nPos := Ascan(aGetApur,{|x|x[1]="TIT"})
				If nPos > 0
					aGetApur[nPos,2] := Stuff(aGetApur[nPos,2],1,Len(ALLTRIM(cNumero)),ALLTRIM(cNumero))
					aGetApur[nPos,3] := nVlrTitulo
				Endif
			EndIf
		Endif
	EndIf

	If lGuiaRec
		nPos:= Len(aDadSf2)

		//-- Guarda variavel Private aRotina. uso AxInclui
		If Type("aRotina") == "A"
			aSvRot := aClone(aRotina)
			Private aRotina := 	{ { " "," ",0,1 } ,{ " "," ",0,2 },{ " "," ",0,3 } }
		EndIf

		dbSelectArea("SF6")

		If cOrigem $ "MATA460A/MATA103"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Tratamento para que a numeração da GNRE seja obtida da SX5     ³
			//³mesmo se não for configurada geração de título. Quando houve   ³
			//³geracao do titulo o prefixo e o numero já vem preenchidos e    ³
			//³nao poderao ser alterados para nao perdermos a rastreabilidade.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cImp == "IC" .And. (!lTitulo .Or. nVlrTitulo <= 0)	
				If SX5->(dbSeek(cFilSx5+"53"+cImposto))
					cPrefixo:= "ICM"
					cNumero := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
					// Nesta situacao ja preciso atualizar o SX5 pois a sequencia
					// obtida acima ainda nao foi gravada, visto que nao foi gerado
					// titulo. Entao vou "reservar" esta numeracao para garantir
					// que nao seja sugerido o mesmo numero para outra GNRE caso
					// haja mais guias sendo geradas simultaneamente.
					FwPutSX5( , '53', cImposto, cNumero, cNumero, cNumero)
				Endif
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Tratamento para que nao seja permitida a alteracao do numero ³
			//³das GNRE's geradas no faturamento apos 15/06/2016.           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lBlqEdtNr := dDataBase >= cToD("15/06/2016")
		EndIf

		If lBlqEdtNr
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Selecao dos campos da tabela SF6 a serem alterados ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SX3->(dbSetOrder(1))
			SX3->(dbSeek("SF6"))
			While SX3->(!Eof()) .And. SX3->X3_ARQUIVO == 'SF6'
				If X3USO(SX3->X3_USADO) 
					If AllTrim(SX3->X3_CAMPO) <> "F6_NUMERO"
						Aadd(aCmpAlt, SX3->X3_CAMPO)
					EndIf
				Endif
				SX3->(dbSkip())
			Enddo
		EndIf

		If	nTitICMS > 0 .And. (cOrigem == "MATA953" .Or. cOrigem == "MATA460A" .Or. cOrigem == "MATA913" .Or. cOrigem == "MATA103")
			If !Empty (cNumGnre)
				SF6->(DbSetOrder (1))
				If SF6->(DbSeek (xFilial ("SF6")+cMVESTADO+cNumGnre)) .And. nTitICMS==SF6->F6_VALOR

					cNumGnre  := PadR(cNumGnre,TamSx3("F6_NUMERO")[1])
					cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo //Guia de Recolhimento do ICMS
					aCamps    := {}
					aCampAt   := {}

					//Selecao dos campos da tabela SF6 a serem exibidos e os habilitados para alteracao
					SX3->(dbSetOrder(1))
					SX3->(dbSeek("SF6"))
					While SX3->(!Eof()) .And. SX3->X3_ARQUIVO=='SF6'
						If X3USO(SX3->X3_USADO) 
							If AllTrim(SX3->X3_CAMPO)$"F6_NUMERO/F6_EST"
								Aadd(aCamps,  SX3->X3_CAMPO)
							Else
								Aadd(aCamps,  SX3->X3_CAMPO)
								Aadd(aCampAt, SX3->X3_CAMPO)
							EndIf
						Endif
						SX3->(dbSkip())
					EndDo

					//Montando tela de alteração da GNRE

					If lAutomato
						AADD(aAuto,{"F6_NUMERO" ,SF6->F6_NUMERO,Nil})
						AADD(aAuto,{"F6_EST"    ,SF6->F6_EST,Nil})
						AADD(aAuto,{"F6_TIPOIMP",SF6->F6_TIPOIMP,Nil})
						AADD(aAuto,{"F6_VALOR"  ,SF6->F6_VALOR,Nil})
						AADD(aAuto,{"F6_DTARREC",SF6->F6_DTARREC,Nil})
						AADD(aAuto,{"F6_DTVENC" ,SF6->F6_DTVENC,Nil})
						AADD(aAuto,{"F6_MESREF" ,SF6->F6_MESREF,Nil})
						AADD(aAuto,{"F6_ANOREF" ,SF6->F6_ANOREF,Nil})

						For nJ := 1 to Len(aRetAuto)
							If aRetAuto[nJ][1] == SF6->F6_EST .And. aRetAuto[nJ][2] == SF6->F6_TIPOIMP
								AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
							EndIf
						Next nJ
					EndIf

					AxAltera("SF6",SF6->(Recno()),3,aCamps,aCampAt,,,"SF6TudoOk()",,,,,If(lAutomato,aAuto,Nil))

					If lRefaz
						AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE}) //RECSALDO - Guia de Saldo apurado
					Else
						AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC","RECAPURA"}) //RECAPURA - Recolhido via Apuracao de ICMS
					EndIf

				Else
					//No caso do valor de GNRE diferente, devo excluir a anterior e gerar uma nova
					If !SF6->(Eof()) .And.;
						SF6->(F6_FILIAL+F6_EST+F6_NUMERO)==xFilial("SF6")+cMVESTADO+cNumGnre .And.;
						nTitICMS<>SF6->F6_VALOR
						RecLock("SF6",.F.)
							SF6->(DbDelete())
						MsUnlock()
					EndIf

					//GERADA GUIA MANUAL, GRAVAR ESTA GUIA
					AADD(aDadSF6,{IIf(nVlrConv>0,nVlrConv,nTitICMS),dDataBase,nMes,nAno,dDtVenc,'1',cClasse,cMVESTADO,cNumGnre,"","","","","","",cInsc,cTipoDoc})//imposto a recolher

					cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo //Guia de Recolhimento do ICMS

					If lAutomato

						If Empty(cNumGnre)
							SX5->(dbSeek(cFilSx5+"53"+cImposto))
							cNumGnre := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
						EndIf

						AADD(aAuto,{"F6_NUMERO",cNumGnre,Nil})
						AADD(aAuto,{"F6_EST",cMVESTADO,Nil})
						AADD(aAuto,{"F6_TIPOIMP","1",Nil})
						AADD(aAuto,{"F6_VALOR",IIf(nVlrConv>0,nVlrConv,nTitICMS),Nil})
						AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
						AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
						AADD(aAuto,{"F6_MESREF",nMes,Nil})
						AADD(aAuto,{"F6_ANOREF",nAno,Nil})

						For nJ := 1 to Len(aRetAuto)
							If aRetAuto[nJ][1] == cMVESTADO .And. aRetAuto[nJ][2] == "1"
								AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
							EndIf
						Next nJ

					EndIf

					If xApIncSF6("SF6",1,3,"FisIcmF6",,"SF6TudoOk()",If(lAutomato,aAuto,Nil)) == 1
						If lRefaz
							AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE}) //RECSALDO - Guia de Saldo apurado
						Else
							AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC","RECAPURA"}) //RECAPURA - Recolhido via Apuracao de ICMS
						EndIf
					Endif
				EndIf
			Else

				aDadSF6 := {}

				//GUIA EM BRANCO, GRAVAR SALDO
				If cOrigem == "MATA460A" 
					cInsc := SM0->M0_INSC
				EndIf
				
				If Empty(cTpImp)
					If cImp == "PR"
						cTpImp := 'C'
						cGNRImp := "PROTEGE-GO"
					Else
						cTpImp := '1'
						cGNRImp := "IC"
					EndIf
				EndIf
				//Issue https://jiraproducao.totvs.com.br/browse/DSERFIS1-16304
				//Para fins de escrituração da prestação do serviço de transporte, se deve considerar o local de início da prestação de serviços, ou seja, o local de coleta da mercadoria, pois é neste momento que se considera ocorrido o fato gerador do imposto.
				If nModulo == 43 .and. Alltrim(aDadSF2[nPos,8]) $ "CTR/CTE/CTA/CA/CTF"
					cUFOrigem := MaFisRet(,"NF_UFORIGEM")
					If cUFOrigem <> cMVESTADO .OR. aDadSF2[nPos,7] <> cMVESTADO
						If cUFOrigem == cMVESTADO
							cCltOrig	:= cUFOrigem 
						ElseIf cUFOrigem <> cMVESTADO .AND. aDadSF2[nPos,7] <> cMVESTADO
							cCltOrig	:= cUFOrigem
						ElseIf cUFOrigem <> cMVESTADO .AND. aDadSF2[nPos,7] == cMVESTADO
							cCltOrig := cUFOrigem
						EndIF
					Else
						cCltOrig := cMVESTADO
					EndIf
				Else
					cCltOrig := cMVESTADO
				Endif
				
				If cOrigem $ "MATA460A/MATA103" .And. Len(aDadSF2[nPos]) >= 6
					AADD(aDadSF6,{nTitICMS,dDataBase,nMes,nAno,dDtVenc,cTpImp,cClasse,cCltOrig,cPrefixo+cNumero,aDadSF2[nPos,1],aDadSF2[nPos,2],aDadSF2[nPos,3],;
								aDadSF2[nPos,4],aDadSF2[nPos,5],aDadSF2[nPos,6],cInsc,cTipoDoc,"",Iif(Len(aDadSF2[nPos]) >= 8, aDadSF2[nPos,8], ""),.F.,"",cObserv,If(Len(aDadSF2[nPos]) >= 9,aDadSF2[nPos,9],.F.)})//imposto a recolher , adicionado validação da posição 23 para identificar se é uma antecipação
				Else
					AADD(aDadSF6,{nTitICMS,dDataBase,nMes,nAno,dDtVenc,cTpImp,cClasse,cMVESTADO,cPrefixo+cNumero,"","","","","","",cInsc,cTipoDoc,,,,,cObserv})//imposto a recolher
				EndIf

				cCadastro := OemtoAnsi(STR0070) + " " + cPrefixo + " " + cGNRImp //"Guia de Recolhimento do ICMS"    

				If lAutomato
					If Empty(cPrefixo+cNumero)
						SX5->(dbSeek(cFilSx5+"53"+cImposto))
						AADD(aAuto,{"F6_NUMERO",Soma1(Substr(X5Descri(),1,nTamNF),nTamNF),Nil})
					Else
						AADD(aAuto,{"F6_NUMERO",cPrefixo+cNumero,Nil})
					EndIf
					AADD(aAuto,{"F6_EST",cMVESTADO,Nil})
					AADD(aAuto,{"F6_TIPOIMP","1",Nil})
					AADD(aAuto,{"F6_VALOR",nTitICMS,Nil})
					AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
					AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
					AADD(aAuto,{"F6_MESREF",nMes,Nil})
					AADD(aAuto,{"F6_ANOREF",nAno,Nil})

					For nJ := 1 to Len(aRetAuto)
						If aRetAuto[nJ][1] == cMVESTADO .And. aRetAuto[nJ][2] == "1"
							AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
						EndIf
					Next nJ

				EndIf

				// Tratamento p/ geracao da GNRE de ICMS Proprio sem interface (AxInclui).
				If cOrigem $ "MATA460A/MATA103" .And. (lNgnreNf .Or. IsBlind())
					xApGrvSF6(aDadSF2, aDadSF6, cPrefixo + cNumero, cCodGnre)
					AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE}) //RECSALDO - Guia de Saldo apurado
				ElseIf xApIncSF6("SF6",1,3,"FisIcmF6",Iif(lBlqEdtNr,aCmpAlt,NIL),"SF6TudoOk('"+cOrigem+"','"+cPrefixo+"','"+cNumero+"')",If(lAutomato,aAuto,Nil)) == 1
					AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE}) //RECSALDO - Guia de Saldo apurado
				Endif
			EndIf
		EndIf
		If	nTitST > 0 .And. (cOrigem == "MATA953" .Or. cOrigem == "MATA460A" .Or. cOrigem == "MATA103")

			If cOrigem == "MATA460A"
				If cModulo == "ACD"
					If !Empty(SM0->M0_INSC)
						cInsc := SM0->M0_INSC
					Else
						cInsc := IESubTrib(cUf,lDifal)
					EndIf
				Else
					If (nPos := Len(aDadSf2)) > 0
						If aDadSF2[nPos,5] == "B"
							If SA2->(MsSeek(xFilial("SA2")+aDadSF2[nPos,3]+aDadSF2[nPos,4]))
								cInsc := SA2->A2_INSCR
								cCNPJ := SA2->A2_CGC
							EndIf
						Else
						If SA1->(MsSeek(xFilial("SA1")+aDadSF2[nPos,3]+aDadSF2[nPos,4]))
								cInsc := SA1->A1_INSCR
								cCNPJ := SA1->A1_CGC
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf

			aDadSF6 := {}

			If Empty(cTpImp)

				IF cOrigem $ "MATA460A/MATA953/MATA103" .And. lDifal .And. (lFECP .Or. lDifAlq) 
					If lFECP .And. lFumacop
						cTpImp :='A' //FUMACOP
						cGNRImp := "FUMACOP"
					Else
						cTpImp :='B'
						cGNRImp := 'DIFAL'//Iif(lFECP,"FECP E.C. 87/15", "DIFAL E.C. 87/15")
					EndIf
				Else
					If lAntParcBA
						cTpImp :='0'
						cGNRImp :="Antecipação Parcial"
					Else
						cTpImp :='3'
						cGNRImp :="ST"
					EndIf
				Endif

			EndIf				

			If Len(aDadSf2)>0
				nPos:=Len(aDadSf2)
				AADD(aDadSF6,{nTitST,dDataBase,nMes,nAno,dDtVenc,cTpImp,cClasse,aDadSF2[nPos,7],cPrefixo+cNumero,aDadSF2[nPos,1],aDadSF2[nPos,2],aDadSF2[nPos,3],;
				aDadSF2[nPos,4],aDadSF2[nPos,5],aDadSF2[nPos,6],cInsc,cTipoDoc,cNumConv,Iif(Len(aDadSF2[nPos]) >= 8, aDadSF2[nPos,8], ""),lFecp,cCNPJ,cObserv,;
				If(Len(aDadSF2[nPos]) >= 9,aDadSF2[nPos,9],.F.),nValFund}) 

				If IsBlind() .And. cOrigem == "MATA103"  .Or. (cOrigem == "MATA460A" .And. cModulo == "ACD") .And. !lGTitFluig
					// Preenchimento do array de rotina automatica para geracao de guia de antecipacao de ICMS 
					nTamASF6 := Len(aDadSF6)
					aadd(aCposAut,{"F6_NUMERO"	,aDadSF6[nTamASF6,9]	,Nil})
					aadd(aCposAut,{"F6_EST"		,PadR(aDadSF6[nTamASF6,8],TamSX3("F6_EST")[1]),Nil})
					aadd(aCposAut,{"F6_TIPOIMP"	,aDadSF6[nTamASF6,6]	,Nil})
					aadd(aCposAut,{"F6_VALOR"	,aDadSF6[nTamASF6,1]	,Nil})
					aadd(aCposAut,{"F6_INSC"	,PadR(aDadSF6[nTamASF6,16],TamSX3("F6_INSC")[1]),Nil})
					aadd(aCposAut,{"F6_DTARREC"	,aDadSF6[nTamASF6,2]	,Nil})
					aadd(aCposAut,{"F6_DTVENC"	,aDadSF6[nTamASF6,5]	,Nil})
					aadd(aCposAut,{"F6_MESREF"	,aDadSF6[nTamASF6,3]	,Nil})
					aadd(aCposAut,{"F6_ANOREF"	,aDadSF6[nTamASF6,4]	,Nil})
					aadd(aCposAut,{"F6_CLAVENC"	,aDadSF6[nTamASF6,7]	,Nil})
					aadd(aCposAut,{"F6_DOC"		,aDadSF6[nTamASF6,10]	,Nil})
					aadd(aCposAut,{"F6_SERIE"	,aDadSF6[nTamASF6,11]	,Nil})
					aadd(aCposAut,{"F6_CLIFOR"	,aDadSF6[nTamASF6,12]	,Nil})
					aadd(aCposAut,{"F6_LOJA"	,aDadSF6[nTamASF6,13]	,Nil})
					aadd(aCposAut,{"F6_OPERNF"	,aDadSF6[nTamASF6,15]	,Nil})
					aadd(aCposAut,{"F6_TIPODOC"	,aDadSF6[nTamASF6,14]	,Nil})

					If SerieNfId("SF6",3,"F6_SERIE") == "F6_SDOC"
						aadd(aCposAut,{"F6_SDOC"	,SubStr(aDadSF6[nTamASF6,11],1,3)	,Nil})
					EndIf
					If	aApurSX3[FP_F6_FECP] 
						If Len(aDadSF6[nTamASF6])>=20 .And. aDadSF6[nTamASF6,20]
							aadd(aCposAut,{"F6_FECP"	,"1"	,Nil})
						Else
							aadd(aCposAut,{"F6_FECP"	,"2"	,Nil})
						EndIf
					EndIf

				EndIf

				cGNRInfC := xApInfC(lAutomato)

			Else
				AADD(aDadSF6,{nTitST,dDataBase,nMes,nAno,dDtVenc,cTpImp,cClasse,cUF,Iif(((cTpImp == 'B' .And. (lFECP .Or. lDifAlq)) .Or. Empty(cNumGnre)),cPrefixo+cNumero,cNumGnre),"","","","","","",cInsc,cTipoDoc,"","",lFecp,"",cObserv,,nValFund}) //imposto a recolher Substituicao Tributaria
				If lAutomato .And. Empty(aCposAut)

					If Empty(cPrefixo+cNumero)
						SX5->(dbSeek(cFilSx5+"53"+cImposto))
						AADD(aCposAut,{"F6_NUMERO",Soma1(Substr(X5Descri(),1,nTamNF),nTamNF),Nil})
					Else
						AADD(aCposAut,{"F6_NUMERO",cPrefixo+cNumero,Nil})
					EndIf

					AADD(aCposAut,{"F6_EST",cUF ,Nil})
					AADD(aCposAut,{"F6_TIPOIMP",cTpImp,Nil})
					AADD(aCposAut,{"F6_VALOR",nTitST,Nil})
					AADD(aCposAut,{"F6_DTARREC",dDataBase,Nil})
					AADD(aCposAut,{"F6_DTVENC",dDtVenc,Nil})
					AADD(aCposAut,{"F6_MESREF",nMes,Nil})
					AADD(aCposAut,{"F6_ANOREF",nAno,Nil})

					For nJ := 1 to Len(aRetAuto)
						If aRetAuto[nJ][1] == cUF .And. aRetAuto[nJ][2] == cTpImp
							AADD(aCposAut,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
						EndIf
					Next nJ

				EndIf
			Endif

			cCadastro := cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo

			If cTpImp =='B' .AND. ( lFECP .Or. lDifAlq )

				If cOriGNRE == 'DEBITO ESPECIAL'
					cCadastro += ' - EC 87/15 - DEBITO ESPECIAL - '
				ElseIf cOriGNRE == 'DEBITO ESPECIAL FECP'
					cCadastro += ' - EC 87/15 - DEBITO ESPECIAL FECP - '
				Elseif lDifAlq
					cCadastro += ' - EC 87/15  - '
				Elseif lFECP
					cCadastro += ' - EC 87/15 - FECP - '
				EndIF

			EndIF

			cCadastro += "/"+cGNRImp //"Guia de Recolhimento do ICMS"
			If lINFOGNRE
				lGravaSF6 := ExecBlock("INFOGNRE", .F., .F.)
				If lGravaSF6
					AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,cGNRImp,cOriGNRE})
					nPosGNRE := Len(aGnre)
					If Len(aDadSf2)>0 
						DbSelectArea("CDC")
						CDC->(DbSetOrder(1))//CDC_FILIAL+CDC_TPMOV+CDC_DOC+CDC_SERIE+CDC_CLIFOR+CDC_LOJA+CDC_GUIA+CDC_UF						
						If !DbSeek(xFilial("CDC")+IIF(aDadSF2[nPos,6]=="1","E","S")+aDadSF2[nPos,1]+aDadSF2[nPos,2]+aDadSF2[nPos,3]+aDadSF2[nPos,4]+AVKEY(IIf(aGnre[nPosGNRE][1]<>cPrefixo+cNumero,aGnre[nPosGNRE][1],cPrefixo+cNumero),"CDC_GUIA")+aDadSF2[nPos,7])
							RecLock("CDC",.T.)
							CDC_FILIAL :=xFilial("CDC")
							CDC_TPMOV  :=IIF(aDadSF2[nPos,6]=="1","E","S")
							CDC_DOC    :=aDadSF2[nPos,1]
							SerieNfId("CDC",1,"CDC_SERIE",,,,aDadSF2[nPos,2])
							CDC_CLIFOR :=aDadSF2[nPos,3]
							CDC_LOJA   :=aDadSF2[nPos,4]
							CDC_GUIA   :=IIf(aGnre[nPosGNRE][1]<>cPrefixo+cNumero,aGnre[nPosGNRE][1],cPrefixo+cNumero)
							CDC_UF     :=aDadSF2[nPos,7]
							CDC_IFCOMP :=cGNRInfC
							CDC->(MsUnlock())
						Endif
					Endif
				EndIf
			Else
				If !Empty(cNumGnre)
					SF6->(DbSetOrder(1))
					If SF6->(DbSeek(xFilial("SF6")+cUF+cNumGnre)) .And. nTitST==SF6->F6_VALOR
						cNumGnre := PadR(cNumGnre,TamSx3("F6_NUMERO")[1])
						aCamps   := {}
						aCampAt  := {}

						//Selecao dos campos da tabela SF6 a serem exibidos e os habilitados para alteracao
						SX3->(dbSetOrder(1))
						SX3->(dbSeek("SF6"))
						While SX3->(!Eof()) .And. SX3->X3_ARQUIVO=='SF6'
							If X3USO(SX3->X3_USADO) 
								If AllTrim(SX3->X3_CAMPO)$"F6_NUMERO/F6_EST"
									Aadd(aCamps,  SX3->X3_CAMPO)
								Else
									Aadd(aCamps,  SX3->X3_CAMPO)
									Aadd(aCampAt, SX3->X3_CAMPO)
								EndIf
							Endif
							SX3->(dbSkip())
						EndDo

						//Montando tela de alteração da GNRE
						If lAutomato
							AADD(aAuto,{"F6_NUMERO" ,SF6->F6_NUMERO,Nil})
							AADD(aAuto,{"F6_EST"    ,SF6->F6_EST,Nil})
							AADD(aAuto,{"F6_TIPOIMP",SF6->F6_TIPOIMP,Nil})
							AADD(aAuto,{"F6_VALOR"  ,SF6->F6_VALOR,Nil})
							AADD(aAuto,{"F6_DTARREC",SF6->F6_DTARREC,Nil})
							AADD(aAuto,{"F6_DTVENC" ,SF6->F6_DTVENC,Nil})
							AADD(aAuto,{"F6_MESREF" ,SF6->F6_MESREF,Nil})
							AADD(aAuto,{"F6_ANOREF" ,SF6->F6_ANOREF,Nil})

							For nJ := 1 to Len(aRetAuto)
								If aRetAuto[nJ][1] == SF6->F6_EST .And. aRetAuto[nJ][2] == SF6->F6_TIPOIMP
									AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
								EndIf
							Next nJ

						EndIf

						AxAltera("SF6",SF6->(Recno()),3,aCamps,aCampAt,,,"SF6TudoOk()",,,,,If(lAutomato,aAuto,Nil))
						AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,cGNRImp,cOriGNRE})
					Else
						//No caso do valor de GNRE diferente, devo excluir a anterior e gerar uma nova
						If !SF6->(Eof()) .And.;
							SF6->(F6_FILIAL+F6_EST+F6_NUMERO)==xFilial("SF6")+cUF+cNumGnre .And.;
							nTitST<>SF6->F6_VALOR
							RecLock("SF6",.F.)
							SF6->(DbDelete())
							MsUnlock()
						EndIf
					EndIf
				EndIf

				If aScan(aGNRE,{|aX| aX[1] == cNumGnre .And. aX[6] == cGNRImp}) == 0

					// Tratamento p/ geracao da GNRE de ICMS-ST sem interface (AxInclui).
					If cOrigem $ "MATA460A/MATA103" .And. (lNgnreNf .Or. IsBlind()) .And. !lGTitFluig .And. !lWhenGet

						xApGrvSF6(aDadSF2, aDadSF6, cPrefixo + cNumero, cCodGnre)

						AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,cGNRImp,cOriGNRE})
						nPosGNRE := Len(aGnre)
						If Len(aDadSf2)>0
							DbSelectArea("CDC")
							CDC->(DbSetOrder(1))//CDC_FILIAL+CDC_TPMOV+CDC_DOC+CDC_SERIE+CDC_CLIFOR+CDC_LOJA+CDC_GUIA+CDC_UF						    
							If !DbSeek(xFilial("CDC")+IIF(aDadSF2[nPos,6]=="1","E","S")+aDadSf2[nPos,1]+aDadSF2[nPos,2]+aDadSF2[nPos,3]+aDadSF2[nPos,4]+AVKEY(IIf(aGnre[nPosGNRE][1]<>cPrefixo+cNumero,aGnre[nPosGNRE][1],cPrefixo+cNumero),"CDC_GUIA")+aDadSF2[nPos,7])
								RecLock("CDC",.T.)
								CDC_FILIAL :=xFilial("CDC")
								CDC_TPMOV  :=IIF(aDadSF2[nPos,6]=="1","E","S")
								CDC_DOC    :=aDadSf2[nPos,1]
								SerieNfId("CDC",1,"CDC_SERIE",,,,aDadSF2[nPos,2])
								CDC_CLIFOR :=aDadSF2[nPos,3]
								CDC_LOJA   :=aDadSF2[nPos,4]
								CDC_GUIA   :=IIf(aGnre[nPosGNRE][1]<>cPrefixo+cNumero,aGnre[nPosGNRE][1],cPrefixo+cNumero)
								CDC_UF     :=aDadSF2[nPos,7]
								CDC_IFCOMP :=cGNRInfC
								CDC->(MsUnlock())
							Endif
						Endif

					ElseIf xApIncSF6("SF6",1,3,"FisSTF6",Iif(lBlqEdtNr,aCmpAlt,NIL),"SF6TudoOk('"+cOrigem+"','"+cPrefixo+"','"+cNumero+"')",lShowScreenAuto(aCposAut,lWhenGet,lNgnreNf)) == 1

						AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,cGNRImp,cOriGNRE})
						nPosGNRE := Len(aGnre)

						If Len(aDadSf2)>0
							DbSelectArea("CDC")
							CDC->(DbSetOrder(1))//CDC_FILIAL+CDC_TPMOV+CDC_DOC+CDC_SERIE+CDC_CLIFOR+CDC_LOJA+CDC_GUIA+CDC_UF						    
							If !DbSeek(xFilial("CDC")+IIF(aDadSF2[nPos,6]=="1","E","S")+aDadSF2[nPos,1]+aDadSF2[nPos,2]+aDadSF2[nPos,3]+aDadSF2[nPos,4]+AVKEY(IIf(aGnre[nPosGNRE][1]<>cPrefixo+cNumero,aGnre[nPosGNRE][1],cPrefixo+cNumero),"CDC_GUIA")+aDadSF2[nPos,7])
								RecLock("CDC",.T.)
								CDC_FILIAL :=xFilial("CDC")
								CDC_TPMOV  :=IIF(aDadSF2[nPos,6]=="1","E","S")
								CDC_DOC    :=aDadSF2[nPos,1]
								SerieNfId("CDC",1,"CDC_SERIE",,,,aDadSF2[nPos,2])
								CDC_CLIFOR :=aDadSF2[nPos,3]
								CDC_LOJA   :=aDadSF2[nPos,4]
								CDC_GUIA   :=IIf(aGnre[nPosGNRE][1]<>cPrefixo+cNumero,aGnre[nPosGNRE][1],cPrefixo+cNumero)
								CDC_UF     :=aDadSF2[nPos,7]
								CDC_IFCOMP :=cGNRInfC
								CDC->(MsUnlock())
							Endif
						Endif
					Endif
				EndIf
			EndIf
		Endif
		If	nTitICMS > 0 .and. cOrigem == "MATA954"
			AADD(aDadSF6,{nVlrTitulo,dDataBase,nMes,nAno,dDtVenc,"2",cClasse,cUf,cNumGnre,"","","","","","","","",SE2->E2_NUM,cCodMunRec})//imposto a recolher
			cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo //"Guia de Recolhimento"

			If lAutomato

				If Empty(cNumGnre)
					SX5->(dbSeek(cFilSx5+"53"+cImposto))
					cNumGnre := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
				EndIf

				AADD(aAuto,{"F6_NUMERO",cNumGnre,Nil})
				AADD(aAuto,{"F6_EST",cUf,Nil})
				AADD(aAuto,{"F6_TIPOIMP","2",Nil})
				AADD(aAuto,{"F6_VALOR",nVlrTitulo,Nil})
				AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
				AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
				AADD(aAuto,{"F6_MESREF",nMes,Nil})
				AADD(aAuto,{"F6_ANOREF",nAno,Nil})
				AADD(aAuto,{"F6_CODMUN",cCodMunRec,Nil})

				For nJ := 1 to Len(aRetAuto)
					If aRetAuto[nJ][1] == cUf .And. aRetAuto[nJ][2] == "2"
						AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
					EndIf
				Next nJ

			EndIf

			If xApIncSF6("SF6",1,3,"FisIcmF6",,"SF6TudoOk()",If(lAutomato,aAuto,Nil)) == 1
				AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IS",cOriGNRE})
			EndIf
		Endif
		If	aApurSX3[FP_F6_TIPOIMP] .and. nTitFun > 0 .and. cOrigem == "MATA953" .and. cImp == "FD"
			AADD(aDadSF6,{nTitFun,dDataBase,nMes,nAno,dDtVenc,"6",cClasse,cMVESTADO,cNumGnre,"","","","","","",cInsc,cTipoDoc})//imposto a recolher
			cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo+" / Fundersul" //"Guia de Recolhimento do ICMS"

			If lAutomato

				If Empty(cNumGnre)
					SX5->(dbSeek(cFilSx5+"53"+cImposto))
					cNumGnre := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
				EndIf

				AADD(aAuto,{"F6_NUMERO",cNumGnre,Nil})
				AADD(aAuto,{"F6_EST",cMVESTADO,Nil})
				AADD(aAuto,{"F6_TIPOIMP","6",Nil})
				AADD(aAuto,{"F6_VALOR",nTitFun,Nil})
				AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
				AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
				AADD(aAuto,{"F6_MESREF",nMes,Nil})
				AADD(aAuto,{"F6_ANOREF",nAno,Nil})
				AADD(aAuto,{"F6_INSC",cInsc,Nil})
				AADD(aAuto,{"F6_TIPODOC",cTipoDoc,Nil})

				For nJ := 1 to Len(aRetAuto)
					If aRetAuto[nJ][1] == cMVESTADO .And. aRetAuto[nJ][2] == "6"
						AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
					EndIf
				Next nJ

			EndIf

			If xApIncSF6("SF6",1,3,"FisIcmF6",,"SF6TudoOk()",If(lAutomato,aAuto,Nil)) == 1
				AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE})
			EndIf
		Endif

		//Fumacop
		If (aApurSX3[FP_F6_TIPOIMP] .and. nTitFun > 0 .and. cOrigem == "MATA953") .and. cImp == "FU"
			AADD(aDadSF6,{nTitFun,dDataBase,nMes,nAno,dDtVenc,"A",cClasse,cMVESTADO,cNumGnre})//imposto a recolher
			cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo+" / Fumacop" //"Guia de Recolhimento do Fumacop"

			If lAutomato

				If Empty(cNumGnre)
					SX5->(dbSeek(cFilSx5+"53"+cImposto))
					cNumGnre := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
				EndIf

				AADD(aAuto,{"F6_NUMERO",cNumGnre,Nil})
				AADD(aAuto,{"F6_EST",cMVESTADO,Nil})
				AADD(aAuto,{"F6_TIPOIMP","A",Nil})
				AADD(aAuto,{"F6_VALOR",nTitFun,Nil})
				AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
				AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
				AADD(aAuto,{"F6_MESREF",nMes,Nil})
				AADD(aAuto,{"F6_ANOREF",nAno,Nil})

				For nJ := 1 to Len(aRetAuto)
					If aRetAuto[nJ][1] == cMVESTADO .And. aRetAuto[nJ][2] == "A"
						AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
					EndIf
				Next nJ

			EndIf

			If xApIncSF6("SF6",1,3,"FisIcmF6",,"SF6TudoOk()",If(lAutomato,aAuto,Nil)) == 1
				AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE})
			EndIf
		Endif

		If (aApurSX3[FP_F6_TIPOIMP] .and. nConv139 > 0 .and. cOrigem == "MATA953") .and. Substr(cImp,1,3) == "IC"

			AADD(aDadSF6,{nConv139,dDataBase,nMes,nAno,dDtVenc,'1',cClasse,cUF,cNumGnre,"","","","","","",cInsc,cTipoDoc})//imposto a recolher
			cCadastro := "Guia Recolhimento COnvenio 139/06" //OemtoAnsi(STR0070) +" "+ cPrefixo+" / "+ aApIncent[Len(aApIncent)] //"Guia de Recolhimento / 'Incentivo' "

			/*
			Aqui verifico se a GNRE já foi gravada, para então abrir a tela em mode de edição.
			Como para Convênio 139/06 trata diversas UFs, fiz separado a parte de validação das GNREs
			*/
			dbSelectArea("SF6")
			SF6->(DbSetOrder (1))
			If nConv139 > 0 .AND.!Empty (cNumGnre) .AND. SF6->(DbSeek (xFilial ("SF6")+cUF+cNumGnre)) .And. nConv139==SF6->F6_VALOR

				cNumGnre  := PadR(cNumGnre,TamSx3("F6_NUMERO")[1])
				cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo //"Guia de Recolhimento do ICMS"
				aCamps    := {}
				aCampAt   := {}
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Selecao dos campos da tabela SF6 a serem exibidos e os habilitados para alteracao³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SX3->(dbSetOrder(1))
				SX3->(dbSeek("SF6"))
				While SX3->(!Eof()) .And. SX3->X3_ARQUIVO=='SF6'
					If X3USO(SX3->X3_USADO) 
						If AllTrim(SX3->X3_CAMPO)$"F6_NUMERO/F6_EST"
							Aadd(aCamps,  SX3->X3_CAMPO)
						Else
							Aadd(aCamps,  SX3->X3_CAMPO)
							Aadd(aCampAt, SX3->X3_CAMPO)
						EndIf
					Endif
					SX3->(dbSkip())
				Enddo
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Montando tela de alteração da GNRE³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				AxAltera("SF6",SF6->(Recno()),3,aCamps,aCampAt,,,"SF6TudoOk()")
				If lRefaz
					AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE}) //RECSALDO - Guia de Saldo apurado
				Else
					AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC","RECAPURA"}) //RECAPURA - Recolhido via Apuracao de ICMS
				EndIf

			Else		
				If lAutomato

					If Empty(cNumGnre)
						SX5->(dbSeek(cFilSx5+"53"+cImposto))
						cNumGnre := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
					EndIf

					AADD(aAuto,{"F6_NUMERO",cNumGnre,Nil})
					AADD(aAuto,{"F6_EST",cUf,Nil})
					AADD(aAuto,{"F6_TIPOIMP","1",Nil})
					AADD(aAuto,{"F6_VALOR",nConv139,Nil})
					AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
					AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
					AADD(aAuto,{"F6_MESREF",nMes,Nil})
					AADD(aAuto,{"F6_ANOREF",nAno,Nil})

					For nJ := 1 to Len(aRetAuto)
						If aRetAuto[nJ][1] == cUf .And. aRetAuto[nJ][2] == "1"
							AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
						EndIf
					Next nJ	

				EndIf

				If xApIncSF6("SF6",1,3,"FisIcmF6",,"SF6TudoOk()",If(lAutomato,aAuto,Nil)) == 1
					AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE})
				EndIf
			Endif
		EndIf
		//Incentivos Fiscais
		If (aApurSX3[FP_F6_TIPOIMP] .and. nTitFun > 0 .and. cOrigem == "MATA953") .and.  Substr(cImp,1,3) == "IC" .And. Len(aApIncent) > 0

			AADD(aDadSF6,{nTitFun,dDataBase,nMes,nAno,dDtVenc,'1',cClasse,cMVESTADO,cNumGnre,"","","","","","",cInsc,cTipoDoc})//imposto a recolher
			cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo+" / "+ aApIncent[Len(aApIncent)] //"Guia de Recolhimento / 'Incentivo' "

			If lAutomato

				If Empty(cNumGnre)
					SX5->(dbSeek(cFilSx5+"53"+cImposto))
					cNumGnre := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
				EndIf

				AADD(aAuto,{"F6_NUMERO",cNumGnre,Nil})
				AADD(aAuto,{"F6_EST",cMVESTADO,Nil})
				AADD(aAuto,{"F6_TIPOIMP","1",Nil})
				AADD(aAuto,{"F6_VALOR",nTitFun,Nil})
				AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
				AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
				AADD(aAuto,{"F6_MESREF",nMes,Nil})
				AADD(aAuto,{"F6_ANOREF",nAno,Nil})

				For nJ := 1 to Len(aRetAuto)
					If aRetAuto[nJ][1] == cMVESTADO .And. aRetAuto[nJ][2] == "1"
						AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
					EndIf
				Next nJ

			EndIf

			If xApIncSF6("SF6",1,3,"FisIcmF6",,"SF6TudoOk()",If(lAutomato,aAuto,Nil)) == 1
				AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE})
			EndIf
		Endif

		If (nTitICMS > 0 .and. cOrigem == "MATA924")
			AADD(aDadSF6,{nTitICMS,dDataBase,nMes,nAno,dDtVenc,"7",cClasse,cMVESTADO,cNumGnre})//imposto a recolher
			cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo+" / Simples Nacional" //"Guia de Recolhimento do Simples Nacional"

			If lAutomato

				If Empty(cNumGnre)
					SX5->(dbSeek(cFilSx5+"53"+cImposto))
					cNumGnre := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
				EndIf

				AADD(aAuto,{"F6_NUMERO",cNumGnre,Nil})
				AADD(aAuto,{"F6_EST",cMVESTADO,Nil})
				AADD(aAuto,{"F6_TIPOIMP","7",Nil})
				AADD(aAuto,{"F6_VALOR",nTitFun,Nil})
				AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
				AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
				AADD(aAuto,{"F6_MESREF",nMes,Nil})
				AADD(aAuto,{"F6_ANOREF",nAno,Nil})

				For nJ := 1 to Len(aRetAuto)
					If aRetAuto[nJ][1] == cMVESTADO .And. aRetAuto[nJ][2] == "7"
						AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
					EndIf
				Next nJ

			EndIf
			AADD(aDadSF6,{nTitICMS,dDataBase,nMes,nAno,dDtVenc,"7",cClasse,cMVESTADO,cNumGnre})//imposto a recolher
			cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo+" / Simples Nacional" //"Guia de Recolhimento do Simples Nacional"
			If xApIncSF6("SF6",1,3,"FisIcmF6",,"SF6TudoOk()",If(lAutomato,aAuto,Nil)) == 1
				AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE})
			EndIf
		Endif
		
		If (nGuiaSN > 0 .and. cOrigem == "MATA924")
			AADD(aDadSF6,{nGuiaSN,dDataBase,nMes,nAno,dDtVenc,"7",cClasse,cMVESTADO,cNumGnre})//imposto a recolher
			cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo+" / Simples Nacional" //"Guia de Recolhimento do Simples Nacional Resolução CGSN nº 51/2008"

			If lAutomato

				If Empty(cNumGnre)
					SX5->(dbSeek(cFilSx5+"53"+cImposto))
					cNumGnre := Soma1(Substr(X5Descri(),1,nTamNF),nTamNF)
				EndIf

				AADD(aAuto,{"F6_NUMERO",cNumGnre,Nil})
				AADD(aAuto,{"F6_EST",cMVESTADO,Nil})
				AADD(aAuto,{"F6_TIPOIMP","7",Nil})
				AADD(aAuto,{"F6_VALOR",nTitFun,Nil})
				AADD(aAuto,{"F6_DTARREC",dDataBase,Nil})
				AADD(aAuto,{"F6_DTVENC",dDtVenc,Nil})
				AADD(aAuto,{"F6_MESREF",nMes,Nil})
				AADD(aAuto,{"F6_ANOREF",nAno,Nil})

				For nJ := 1 to Len(aRetAuto)
					If aRetAuto[nJ][1] == cMVESTADO .And. aRetAuto[nJ][2] == "7"
						AADD(aAuto,{aRetAuto[nJ][3],aRetAuto[nJ][4],aRetAuto[nJ][5]})
					EndIf
				Next nJ

			EndIf

			If xApIncSF6("SF6",1,3,"FisIcmF6",,"SF6TudoOk()") == 1
				AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC",cOriGNRE})
			EndIf
		Endif
		If (nTitICMS > 0 .and. cOrigem == "MATA460A" .and. lArt65) .And. !lGTitFluig
			If Len(aDadSf2)>0
				cInsc := SM0->M0_INSC
				nPos:=Len(aDadSf2)
				AADD(aDadSF6,{nTitICMS,dDataBase,nMes,nAno,dDtVenc,"1",cClasse,aDadSF2[nPos,7],cPrefixo+cNumero,aDadSF2[nPos,1],aDadSF2[nPos,2],aDadSF2[nPos,3],aDadSF2[nPos,4],aDadSF2[nPos,5],aDadSF2[nPos,6],cInsc,cTipoDoc})//imposto a recolher
				cGNRInfC := xApInfC(lAutomato)
			Endif
			cCadastro := OemtoAnsi(STR0070) +" "+ cPrefixo+" / ART 65 RICMS PR" //"Guia de Recolhimento de ICMS ART 65 DO RICMS PR "
			If xApIncSF6("SF6",1,3,"FisSTF6",,"SF6TudoOk()") == 1

				AADD(aGnre,{SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_VALOR,SF6->F6_CLAVENC,SF6->F6_EST,"IC"})
				nPosGNRE := Len(aGnre)
				If Len(aDadSf2)>0 
					DbSelectArea("CDC")
					CDC->(DbSetOrder(1))//CDC_FILIAL+CDC_TPMOV+CDC_DOC+CDC_SERIE+CDC_CLIFOR+CDC_LOJA+CDC_GUIA+CDC_UF				           
					If !DbSeek(xFilial("CDC")+IIF(aDadSF2[nPos,6]=="1","E","S")+aDadSF2[nPos,1]+aDadSF2[nPos,2]+aDadSF2[nPos,3]+aDadSF2[nPos,4]+AVKEY(IIf(aGnre[nPosGNRE][1]<>cPrefixo+cNumero,aGnre[nPosGNRE][1],cPrefixo+cNumero),"CDC_GUIA")+aDadSF2[nPos,7])
						RecLock("CDC",.T.)
						CDC_FILIAL :=xFilial("CDC")
						CDC_TPMOV  :=IIF(aDadSF2[nPos,6]=="1","E","S")
						CDC_DOC    :=aDadSF2[nPos,1]
						SerieNfId("CDC",1,"CDC_SERIE",,,,aDadSF2[nPos,2])
						CDC_CLIFOR :=aDadSF2[nPos,3]
						CDC_LOJA   :=aDadSF2[nPos,4]
						CDC_GUIA   :=IIf(aGnre[nPosGNRE][1]<>cPrefixo+cNumero,aGnre[nPosGNRE][1],cPrefixo+cNumero)
						CDC_UF     :=aDadSF2[nPos,7]
						CDC_IFCOMP :=cGNRInfC
						CDC->(MsUnlock())
					Endif
				Endif
			EndIf
		Endif
	EndIf

	//Dados referentes a Guia de recolhimento gerado no Contas a Pagar
	If cPaisLoc=="BRA" .And. cOrigem=="MATA460A" .And. lConfTit .And. !lGTitFluig
		nPos:= Len(aDadSf2)
		If nPos>0
			If SF2->(DBSEEK(xFilial("SF2")+aDadSf2[nPos][1]+aDadSf2[nPos][2]+aDadSf2[nPos][3]+aDadSf2[nPos][4])) .And. !lFECP
				If aApurSX3[FP_F2_GNRDIF] .And. lDifal
					RecLock("SF2",.F.)
					IF EMPTY(ALLTRIM(SF2->F2_GNRDIF))
						If lGuiaRec .And. Len(aGnre) >= nPos .And. aGnre[nPos][1] <> cPrefixo+cNumero
							SF2->F2_GNRDIF := aGnre[nPos][1]
						Else
							SF2->F2_GNRDIF := cPrefixo+cNumero
						EndIf
					ENDIF
					SF2->(MsUnlock())
				ElseIf aApurSX3[FP_F2_NFICMST] .And. nTitST > 0
					RecLock("SF2",.F.)
					// Se gerar GNRE e a numeração for alterada utilizar o nro. digitado p/ gravar na SF2 (F2_NFICMST)
					// pois a grvação da tabela CDC possui este mesmo tratamento.
					IF EMPTY(ALLTRIM(SF2->F2_NFICMST))
						If lGuiaRec .And. Len(aGnre) >= nPos .And. aGnre[nPos][1] <> cPrefixo+cNumero
							SF2->F2_NFICMST := aGnre[nPos][1]
						Else
							SF2->F2_NFICMST := cPrefixo+cNumero
						EndIf
					ENDIF
					SF2->(MsUnlock())
				Endif
			Endif
			If SF2->(DBSEEK(xFilial("SF2")+aDadSf2[nPos][1]+aDadSf2[nPos][2]+aDadSf2[nPos][3]+aDadSf2[nPos][4])) .And. lFECP
				If cMVESTADO=="RN" .And. aApurSX3[FP_F3_VFESTRN] .And. !lDifal
					nVFecpST  := IIf(SF3->F3_VFECPST > 0, SF3->F3_VFECPST, SF3->F3_VFESTRN)
					If nVFecpST > 0 .And. aApurSX3[FP_F2_NTFECP]
						RecLock("SF2",.F.)
						SF2->F2_NTFECP:=cPrefixo+cNumero
						SF2->(MsUnlock())
					Endif
				ElseIf cMVESTADO=="MG" .And. aApurSX3[FP_F3_VFESTMG] .And. !lDifal
					nVFecpST  := IIf(SF3->F3_VFECPST > 0, SF3->F3_VFECPST, SF3->F3_VFESTMG)
					If nVFecpST > 0 .And. aApurSX3[FP_F2_NTFECP]
						RecLock("SF2",.F.)
						SF2->F2_NTFECP:=cPrefixo+cNumero
						SF2->(MsUnlock())
					Endif
				ElseIf cMVESTADO=="MT" .And. aApurSX3[FP_F3_VFESTMT] .And. !lDifal
					nVFecpST  := IIf(SF3->F3_VFECPST > 0, SF3->F3_VFECPST, SF3->F3_VFESTMT)
					If nVFecpST > 0 .And. aApurSX3[FP_F2_NTFECP]
						RecLock("SF2",.F.)
						SF2->F2_NTFECP:=cPrefixo+cNumero
						SF2->(MsUnlock())
					Endif
				Elseif lDifal
					If aApurSX3[FP_F2_GNRFECP] .And. aApurSX3[FP_F3_VFCPDIF]
						If lFecp
							RecLock("SF2",.F.)
							SF2->F2_GNRFECP:=cPrefixo+cNumero
							SF2->(MsUnlock())
						Endif
					Endif
				Else
					nVFecpST  := SF3->F3_VFECPST
					If nVFecpST > 0 .And. aApurSX3[FP_F2_NTFECP]
						RecLock("SF2",.F.)
						SF2->F2_NTFECP:=cPrefixo+cNumero
						SF2->(MsUnlock())
					Endif
				Endif
			Endif
		Endif
	Endif

	//Verifica se o cliente utiliza o Fluig
	If lGTitFluig

		//Para casos de Re-apuração de ICMS
		//Verifico se existe proceso em aberto para o periodo da solicitacao no Fluig,
		//caso exista realizo o cancelamento da solicitacao corrente e inicio a nova
		DbSelectArea( "CH4" )
		CH4->( DbSetOrder(2) )
		If CH4->( MsSeek( xFilial( "CH4" ) + Alltrim( Str( nApuracao ) ) + Alltrim( Str( nPeriodo ) ) + dToS( dDtIni ) + dToS( dDtFim ) + cNrLivro ) )

			Begin Transaction

				//Como podem existir varias linhas da tabela CH4 para o mesmo periodo realizo um laco
				//para excluir todas as ocorrecias
				While CH4->( !Eof() ) .And. ( xFilial("CH4") + Alltrim( Str( nApuracao ) ) + Alltrim( Str( nPeriodo ) ) + dToS( dDtIni ) + dToS( dDtFim ) + cNrLivro ) == ;
											( CH4_FILIAL + CH4_TIPOPR + CH4_PERIOD + Dtos( CH4_DTINI ) + Dtos( CH4_DTFIN ) + CH4_LIVRO )


					//Cancelando a solicitacao no Fluig
					If FWECMCancelProcess( Val( CH4->CH4_PROCES ), FWWFColleagueId( RetCodUsr() ) , STR0134 ) //"Solicitação Cancelada pela apuração de ICMS" 

						//Excluo o registro da CH4 ( Espelho da CDH )
						RecLock( "CH4", .F. )
							CH4->( DbDelete() )
						CH4->( MsUnlock() )

						//Excluo o registro da CH3 ( Espelho da SE2 )
						DbSelectArea("CH3")
						CH3->( DbSetOrder( 1 ) )
						If MsSeek( xFilial( "CH3" ) + CH4->CH4_PROCES )

							//Caso o campo referente a aprovacao nao esteja vazio significa
							//que a solicitacao anterior ja foi finalizada no Fluig, sendo assim
							//nao posso apaga-la, apenas gero a nova solicitacao
							If !Empty( CH3->CH3_APRTIT )
								DisarmTransaction()
								Exit
							EndIf

							RecLock( "CH3", .F. )
								CH3->( DbDelete() )
							CH3->( MsUnlock() )
						EndIf

					//Caso por qualquer motivo nao consiga cancelar a solicitacao alerto o usuario
					//e seto a variavel lGerSolFlg como .F., desta forma as novas solicitacoes
					//NAO serao geradas no Fluig.
					Else
						Help(" ",1,"EXCAPUFLG")
						DisarmTransaction()
						lGerSolFlg := .F.
						Exit
					EndIf

					CH4->( DbSkip() )
				End

			End Transaction
		EndIf

		//Caso nao tenha ocorrido problemas com o cancelamento da solicitacao ou
		//seja uma nova solicitacao
		If lGerSolFlg

			//Caso tenha sido gerado um titulo
			If Len( aInfoFluig ) > 0

				//Busco o numero da solicitacao que foi gerada
				nNumSolFlg := StartProc( aInfoFluig )

				//Caso ocorra algum problema para iniciar a solicitacao no Fluig
				If nNumSolFlg <= 0
					Help(" ",1,"EXCAPUFLG")
				EndIf
			EndIf
		EndIf
	EndIf


	//Restaura variavel Private aRotina. uso AxInclui
	If aSvRot <> Nil
		aRotina := aClone(aSvRot)
	EndIf

EndIf

//Restaura area
dbSelectArea("SF3")
SF3->(dbSetOrder(1))
RestArea(aAreaSA2)
RestArea(aAreaSED)
RestArea(aAreaSE2)
RestArea(aAreaSF2)
RestArea(aAreaSA1)

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ LancCont    ³ Autor ³ Juan Jose Pereira  ³ Data ³ 25/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua lancamento contabil de titulo gerado para pagamento ³±±
±±³          ³ do imposto ou extorno do titulo                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA951                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION LancCont(cLancPadrao,cProgram,lContab)

Local nHdlPrv	:=	0
Local cLA		:=	IIf(VerPadrao(cLancPadrao),"S","N")

DEFAULT lContab := .T.

IF cLA=="S"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona numero do Lote para Lancamentos do Titulo          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SX5")
	dbSeek(xFilial()+"09"+"FIS")
	
	cLoteFis	:=	IIF(Found(),Trim(X5_DESCRI),"FIS ")
	cArquivo	:=	""
	nHdlPrv		:=	HeadProva(cLoteFis,cProgram,cUserName,@cArquivo)
	
	If nHdlPrv <= 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Nao foi possivel criar o arquivo contra prova para esta nota,³
		//³ para tal devera' ser utilizada a rotina de Lancto Off-Line.  ³ 	
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		HELP(" ",1,"A100NOPRV")
	Endif
	nLinha	:=	0
	nTotal	:=	0
	nTotal	+=	DetProva(nHdlPrv,cLancPadrao,cProgram,cLoteFis,@nLinha)
Endif

If nHdlPrv>0 .and. cLA=="S"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Envia para Lancamento Contabil, se gerado arquivo   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RodaProva(nHdlPrv,nTotal)
	If cProgram<>"MATA460A"//Tratamento para quando for efetuado pelo MATA460A nao substituir o valor da aRotina. Caso contrario
	//sera executado o pergunte MT460A novamente
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Envia para Lancamento Contabil, se gerado arquivo   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRotina := { 	{ "Pesquisar", "AxPesqui"  , 0 , 1},;
						{ "Visualizar","AxVisual"  , 0 , 2},;
						{ "Incluir",   "AxInclui"  , 0 , 3},;
						{ "Alterar",   "AxAltera"  , 0 , 4}}
	Endif						
	cA100Incl(cArquivo,nHdlPrv,3,cLoteFis,lContab,.F.)
Endif

RETURN (NIL)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GravaApu    ³ Autor ³ Juan Jose Pereira  ³ Data ³ 09/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava arquivo tipo texto com apuracao gerada para uso em   ³±±
±±³          ³ rdmake de impressao de guia de pagamento ou para passagem  ³±±
±±³          ³ de saldo para proximo periodo                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA951,MATA952                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION GravaApu(cImp,nAno,nMes,nApuracao,nPeriodo,cNrLivro,dDtIni,dDtFim,nMoedTit,lNCM,cArqApur,nOpcao)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define variaveis                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL	lRet		:= .t.
LOCAL	cLinha      := ""
LOCAL	i           := 0

DEFAULT lNCM        := .F.
DEFAULT nOpcao		:= 2
DEFAULT cArqApur := ""

IF empty(cArqApur)
	cArqApur	:=	NmArqApur(cImp,nAno,nMes,nApuracao,nPeriodo,cNrLivro,lNCM)
EndIF	

If cImp="IP"
	IF File(cArqApur)
    	Ferase(cArqApur)
  	Endif
EndIf  	
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava header do arquivo                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpcao <> 3
cLinha := SM0->M0_CODIGO+' '+SM0->M0_CODFIL+' '+StrZero(nApuracao,1)+' '+dToc(dDtIni)+' '+dToc(dDtFim)
WriteApur(cArqApur,cLinha)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava dados da Apuracao                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
// ATENCAO: QUALQUER ALTERACAO NO TAMANHO OU POSICAO DOS ELEMENTOS NA LINHA IRA REFLETIR NO RELATORIO P8 (MATR943).
// Se for necessario alterar revisar tambem o relatorio.
For i:=1 to Len(aGetApur)
	If !(aGetApur[i,1]$"   /OBS/TIT")
		cLinha	:=	aGetApur[i,1]+" "+PADR(Alltrim(aGetApur[i,2]),TamSX3("CDP_DESC")[1],' ')+" "
		cLinha	+= Transform(aGetApur[i,3],"@E 999,999,999,999.99")+" "
      cLinha += Transform(NoRound(xMoeda(aGetApur[i,3],1,nMoedTit,dDataBase),3),"99999999999.99")
		WriteApur(cArqApur,cLinha)
	EndIf
Next
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava indice de conversao                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cLinha	:=	"IND "+Transform(xMoeda(1,nMoedTit,1,dDataBase),"9.999")
WriteApur(cArqApur,cLinha)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava Titulo                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For i:=1 to Len(aGetApur)
	If aGetApur[i,1]=="TIT"
		cLinha	:=	"TIT "+aGetApur[i,2]
 		WriteApur(cArqApur,cLinha)
	Endif
Next
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava Observacoes                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For i:=1 to Len(aGetApur)
	If aGetApur[i,1]=="OBS"
		cLinha	:=	"OBS "+aGetApur[i,2]
		WriteApur(cArqApur,cLinha)
	Endif
Next
Endif

RETURN (lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ApurValDev  ³ Autor ³ Juan Jose Pereira  ³ Data ³ 15/01/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Apura valor do ICMS e IPI nas devolucoes                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA951,MATA952                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
STATIC FUNCTION ApurValDev(cImp,dDtIni,dDtFim,cNrLivro)

Local aDev:={0,0,0,0,0}, aSave:={Alias(),IndexOrd(),Recno()}

dbSelectArea("SF3")
dbSetOrder(1)
dbSeek(xFilial()+DTOS(dDtIni),.T.)
While SF3->F3_FILIAL==xFilial().and.SF3->F3_ENTRADA>=dDtIni.and.SF3->F3_ENTRADA<=dDtFim
	If (cNrLivro!="*" .and. SF3->F3_NRLIVRO!=cNrLivro) .or. ;
		IIf(cImp$"IC/IP",(SF3->F3_TIPO=="S"),(SF3->F3_TIPO!="S".or.Val(substr(SF3->F3_CFO,1,1))<5))
		dbSkip()
		Loop
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Filtra notas que nao sao devolucao e notas canceladas        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(SF3->F3_TIPO=="D") .or. !empty(SF3->F3_DTCANC)
		dbSkip()
		Loop
	Endif
	If Val(substr(SF3->F3_CFO,1,1))<5
		If Substr(SF3->F3_CFO,1,1)$"12"
		    //Nota de entrada (devolucao) nao possui estorno de debito de IPI, estava considerando IPI Outros
		    If cImp=="IC"
				aDev[1]	+=	SF3->F3_VALICM // Mercado Nacional
			EndIf
		Else
		    If cImp=="IC"
				aDev[2]	+=	SF3->F3_VALICM // Mercado Externo
			EndIf	
		EndIf
	Else
		If Substr(SF3->F3_CFO,1,1)$"56"
                                           	
			SFT->(dbSetOrder(3))
			SFT->(dbSeek(xFilial("SF3")+"S"+SF3->F3_CLIEFOR+SF3->F3_LOJA+SF3->F3_SERIE+SF3->F3_NFISCAL+SF3->F3_IDENTFT))
	  		SD2->(dbSetOrder(3))
			SD2->(dbSeek(xFilial("SD2")+SFT->FT_NFISCAL+SFT->FT_SERIE+SFT->FT_CLIEFOR+SFT->FT_LOJA+SFT->FT_PRODUTO+SFT->FT_ITEM))
        	SF4->(DbSetOrder(1))
    		SF4->(DbSeek(xFilial("SF4")+SD2->D2_TES))

            If SF4->F4_CREDIPI == "S" .And. (SF4->F4_LFIPI$"O")  
				aDev[3]	+=	If(cImp=="IC",SF3->F3_VALICM,SF3->F3_IPIOBS) // Mercado Nacional
	            aDev[5] +=  If( SF3->F3_VALIPI == 0 , SF3->F3_IPIOBS , 0  )
            EndIf

		Else
			aDev[4]	+=	If(cImp=="IC",SF3->F3_VALICM,SF3->F3_IPIOBS) // Mercado Externo
	  		aDev[5] +=  If( SF3->F3_VALIPI == 0 , SF3->F3_IPIOBS , 0  )
		Endif
	Endif
	dbSkip()
End

dbSelectArea(aSave[1])
dbSetOrder(aSave[2])
dbGoto(aSave[3])

Return (aDev)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FisApur  ³ Autor ³ Eduardo Jose Zanardo ³ Data ³ 02/10/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Lê e Grava as apurações dos Impostos	                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±± 
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Expc1	-	cImp	 	- Tipo do Imposto(IC,IS,IP)			   ±±	
±±			  Expn2	-	nAno 		- Ano								   ±±
±±			  Expn3	-	nMes 		- Mes								   ±±
±±			  Expn4	-	nApuracao	- Codigo do Tipo da Apuracao(Decendial/±±			                          
±±										Mensal/Quinzenal/Semestral/Anual)  ±±
±±			  Expn5	-	nPeriodo	- Cod. do Tipo do Periodo (1o./2o./3o.)±±
±±			  Expc6	-	cNrLivro	- Número do Livro					   ±±
±±			  Expl7 -	lGrava		- Grava(.F.) Leitura (.T.)			   ±± 
±±			  Expa8 -	aDados		- Array contendo os dados que serão    ±± 
±±			                        - gravados                             ±± 
±±			  Expn9 -	nMoedTit	- Codigo da Moeda       			   ±± 
±±			  Expl10 -	lRetDbf		- Retorna um DBF ou Array		       ±± 
±±			  Expc11 -	cAliasTRB	- Alias do DBF a ser gerado na Leitura ±± 
±±			                        - do Arquivo IC*				       ±± 
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±³ Uso      ³ SigaFis 			                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FisApur(cImp,nAno,nMes,nApuracao,nPeriodo,cNrLivro,lGrava,aDados,nMoedTit,lRetDbf,cAliasTRB,nTamDescr,lNCM)

Local cArqApur 	:= NmArqApur(cImp,nAno,nMes,nApuracao,nPeriodo,cNrLivro,lNCM)
Local cLinha 	:= ""
Local cValor 	:= ""
Local cDescr	:= ""
Local aRet	    := {}
Local lRet		:= .F.
Local aDatas	:= DetDatas(nMes,nAno,nApuracao,nPeriodo)
Local nI		:= 0
Local aCampos	:= {}
Local cArqTRB 	:= ""
Local nTamSubCd	:=	Iif( IsInCallStack("A972MontTrab") .And. cImp=="IC" , 7 , 6 )

DEFAULT lRetDbf   := .F.            
DEFAULT cAliasTRB := ""
DEFAULT nTamDescr := 0
DEFAULT lNCM	  := .F.

If lRetDbf .and. !Empty(cAliasTRB) .and. Select(cAliasTRB) == 0
	aCampos	:= {}    
	AADD(aCampos,{"CODIGO"	,"C",3,0})
	AADD(aCampos,{"SUBCOD"	,"C",10,0})                         
	AADD(aCampos,{"DESCR"	,"C",45,0})                         
	AADD(aCampos,{"VALOR"   ,"N",13,2})                         
	AADD(aCampos,{"GNRE"	,"C",14,0})                         
	cArqTRB :=	CriaTrab(aCampos)
	dbUseArea(.T.,__LocalDriver,cArqTRB,cAliasTRB,.T.,.F.)
	IndRegua(cAliasTRB,cArqTRB,"CODIGO",,,"Indexando registros...")
	DbSelectArea(cAliasTRB)
	DbClearIndex()
	DbSetIndex(cArqTRB+OrdBagExt())
EndIf               

If lGrava
	fClose(cArqApur)
	fErase(cArqApur)                   
	cLinha := SM0->M0_CODIGO+' '+SM0->M0_CODFIL+' '+StrZero(nApuracao,1)+' '+dToc(aDatas[1])+' '+dToc(aDatas[2])
	WriteApur(cArqApur,cLinha)
	For nI:=1 to Len(aDados)
		If !empty(aDados[nI,1]) .and. !aDados[nI][len(aDados[nI])]
			If aDados[nI,1]=="TIT" .or. aDados[nI,1]=="GNR"
				cLinha	:=	aDados[nI,1]+" "+(aDados[nI,3])
			ElseIf aDados[nI,1]=="FOM"                         
				cLinha	:=	aDados[nI,1]+" "+PadR((aDados[nI,3]), 110, " ")+space(5)+Transform(aDados[nI,4],"99999999999.99")
			ElseIf aDados[nI,1]=="OBS"
				cLinha	:=	aDados[nI,1]+" "+alltrim(aDados[nI,3])+space(nTamDescr-len(alltrim(aDados[nI,3])))
			ElseIf aDados[nI,1]=="500" 
				cLinha	:=	aDados[nI,1]+" "
			else
				cDescr	:=	alltrim(aDados[nI,3])+space(nTamDescr-len(alltrim(aDados[nI,3])))
				cLinha	:=	aDados[nI,1]+" "+Substr(cDescr,1,47)
			endif
			
			If aDados[nI,1] <> "500" .And. aDados[nI,1] <> "OBS" .And. aDados[nI,1] <> "IND" .And. aDados[nI,1] <> "FOM" .And. aDados[nI,1] <> "EXP" .And. aDados[nI,1] <> "OUT" .and. !aDados[nI,1]$"111/112/113" .And. aDados[nI,1] <> "CAC"
				cLinha	+=	Transform(aDados[nI,4],"@E 999,999,999,999.99")+" "
    	   		cLinha  +=	Transform(NoRound(xMoeda(aDados[nI,4],1,nMoedTit,dDataBase),3),"99999999999.99")
       		 	cLinha  +=	" "+If(Empty(aDados[nI,2]),space(10),alltrim(aDados[nI,2])+space(06-len(alltrim(aDados[nI,2]))))
				If cImp $ "IC#ST"
					If (Len (aDados[nI,5])<>0)
						cLinha  +=	" "+PadR (aDados[nI,5], 14)
					Else
						cLinha  +=	" "+Space (14)
					EndIf
					//
					If (Len (aDados[nI,6])<>0)
						cLinha  +=	" "+PadR (aDados[nI,6],  6)
					Else
						cLinha  +=	" "+Space (6)
					EndIf
					
					If Type( "aExclApur" )<>"U" .And. ValType( aExclApur )=="A"	//Private MATA953
						If aScan( aExclApur, { |aX| AllTrim( aX[2] ) $ AllTrim( aDados[ nI,2 ] ) } )>0
							cLinha	+= " T"
						Else
							cLinha	+= "  "
						EndIf
					Else
						cLinha	+= "  "
					EndIf
				Endif	                                                              
			Elseif ((aDados[nI,1]=="EXP" .And. ValType(aDados[nI,4])=="N") .Or. (aDados[nI,1]=="OUT" .And. ValType(aDados[nI,4])=="N") .Or.  (aDados[nI,1]=="CAC" .And. ValType(aDados[nI,4])=="N") ) .and. !aDados[nI,1]$"111/112/113"//#TODO ajuste no OR e AND errados 
				cLinha	+=	Transform(aDados[nI,4],"@E 999,999,999,999.99")+" "
    	   		cLinha  +=	Transform(NoRound(xMoeda(aDados[nI,4],1,nMoedTit,dDataBase),3),"99999999999.99")
       		 	cLinha  +=	" "+If(Empty(aDados[nI,2]),space(10),alltrim(aDados[nI,2])+space(06-len(alltrim(aDados[nI,2]))))
			 	If cImp $ "IC#ST"
					If (Len (aDados[nI,5])<>0)
						cLinha  +=	" "+PadR (aDados[nI,5], 14)
					Else
						cLinha  +=	" "+Space (14)
					EndIf
					//
					If (Len (aDados[nI,6])<>0)
						cLinha  +=	" "+PadR (aDados[nI,6],  6)
					Else
						cLinha  +=	" "+Space (6)
					EndIf
					
					If Type( "aExclApur" )<>"U" .And. ValType( aExclApur )=="A"	//Private MATA953
						If aScan( aExclApur, { |aX| AllTrim( aX[2] ) $ AllTrim( aDados[ nI,2 ] ) } )>0
							cLinha	+= " T"
						Else
							cLinha	+= "  "
						EndIf
					Else
						cLinha	+= "  "
					EndIf
				Endif	                                                              
			Elseif (aDados[nI,1]$"111/112/113")
				Do case
					Case aDados[nI,1]=="111"
			  			cLinha	+=	Transform(aDados[nI,9],"@E 999,999,999,999.99")+" "
    	   				cLinha	+=	Transform(NoRound(xMoeda(aDados[nI,9],1,nMoedTit,dDataBase),3),"99999999999.99")
       		 	 		cLinha	+=	" "+If(Empty(aDados[nI,2]),space(10),alltrim(aDados[nI,2])+space(06-len(alltrim(aDados[nI,2]))))    			
		   				cLinha  +=	" "+(aDados[nI,4])+" "+(aDados[nI,5])+" "+(aDados[nI,6])+" "+(aDados[nI,7])+" "+(aDados[nI,8])
		   			Case aDados[nI,1]$"112/113"
		   				cLinha	+=	Transform(aDados[nI,9],"@E 999,999,999,999.99")+" "
    	   				cLinha	+=	Transform(NoRound(xMoeda(aDados[nI,9],1,nMoedTit,dDataBase),3),"99999999999.99")
       		 	 		cLinha	+=	" "+If(Empty(aDados[nI,2]),space(10),alltrim(aDados[nI,2])+space(06-len(alltrim(aDados[nI,2])))) 
		   	   	EndCase
			ElseIf aDados[nI,1]=="500"			
		  			cLinha	+=	aDados[nI,2] +	" " + aDados[nI,3]
			Endif	
			WriteApur(cArqApur,cLinha)
		EndIf
	Next nI
	lRet := .T.
Else  
	If ( File(cArqApur) )
		FT_FUse(cArqApur)
		FT_FGotop()
		While ( !FT_FEof() )
			cLinha  := FT_FREADLN()
			cValor	:=	Alltrim(Substr(cLinha,52,23))
			cValor	:=	StrTran(cValor,".")
			cValor	:=	StrTran(cValor,",",".")
			If !lRetDbf .or. Empty(cAliasTRB)      
				If 	Alltrim(Substr(cLinha,1,3)) <> "GNR"
					AADD(aRet,{Alltrim(Substr(cLinha,1,3)),Alltrim(Substr(cLinha,5,45)),val(cValor),Alltrim(Substr(cLinha,86,nTamSubCd)),Alltrim(Substr(cLinha,93,29)),""})
				Else
					cValor	:=	Alltrim(Substr(cLinha,52,23))
					cValor	:=	StrTran(cValor,".")
					cValor	:=	StrTran(cValor,",",".")
					AADD(aRet,{Alltrim(Substr(cLinha,1,3)),Alltrim(Substr(cLinha,5,45)),val(cValor),Alltrim(Substr(cLinha,79,12)),Alltrim(Substr(cLinha,93,29)),""})
				EndIf				
			ElseIf lRetDbf .and. !Empty(cAliasTRB)
				dbSelectArea(cAliasTRB)
				Reclock(cAliasTRB,.T.)                 
				CODIGO	:= Alltrim(Substr(cLinha,1,3))
				SUBCOD	:= Alltrim(Substr(cLinha,86,nTamSubCd))
				DESCR	:= Alltrim(Substr(cLinha,5,45))
				VALOR	:= val(cValor)
				GNRE	:= Alltrim(Substr(cLinha,93,14))
				CODLAN	:= ""
				MsUnlock()
			EndIf	
			FT_FSkip()
		EndDo
		FT_FUse()
	EndIf	
EndIf
  	
Do Case
	Case lGrava
		Return (lRet)		
	Case lRetDbf .and. !Empty(cAliasTRB)
		Return (cArqTRB)			
	OtherWise
		Return (aRet)		
EndCase

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FisIcmF6 ³ Autor ³ Zanardo               ³ Data ³ 10.10.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza as variaveis de memoria para Inclusao no SF6.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA953                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FisIcmF6()
Local cSavAlias  := Alias()
Local nPos 		 := Len(aDadSF6)
Local cOrigem    := "MATA954"
Local lGrValFund := aApurSX3[FP_F6_VALFUND]
Local nMVDATPAG  := GetNewPar("MV_DATAPAG",0)

If aExistBloc[PE_DADOSTIT]
	aDadosTit := ExecBlock("DADOSTIT", .F., .F., {cOrigem})
	If aDadosTit<>Nil .And. ValType(aDadosTit)=="A"
		aDadSF6[nPos,9] := Iif(Len(aDadosTit)>=1,aDadosTit[1],aDadSF6[nPos,9])
		aDadSF6[nPos,5] := Iif(Len(aDadosTit)>=2,aDadosTit[2],aDadSF6[nPos,5])
	EndIf
EndIf

DbselectArea("SF6")
M->F6_DTARREC := aDadSF6[nPos,2]
M->F6_VALOR   := aDadSF6[nPos,1]
M->F6_MESREF  := aDadSF6[nPos,3]
M->F6_ANOREF  := aDadSF6[nPos,4]
M->F6_DTVENC  := aDadSF6[nPos,5]
M->F6_DTPAGTO := Iif((SomaData(nMVDATPAG,dDatabase)>aDadSF6[nPos][5]),aDadSF6[nPos][5],SomaData(nMVDATPAG,dDatabase))
M->F6_EST     := aDadSF6[nPos,8]
M->F6_TIPOIMP := aDadSF6[nPos,6]
M->F6_CLAVENC := aDadSF6[nPos,7]
M->F6_NUMERO  := aDadSF6[nPos,9]

M->F6_LOJA    := PAdr('',TamSX3("F6_LOJA")[1])
M->F6_TIPODOC := PAdr('',TamSX3("F6_TIPODOC")[1])

If Len(aDadSF6[nPos]) >= 10 .AND. !Empty(aDadSF6[nPos,10])
	M->F6_DOC := aDadSF6[nPos,10]
EndIf
If Len(aDadSF6[nPos]) >= 11 .AND. !Empty(aDadSF6[nPos,11])
	M->F6_SERIE	:= aDadSF6[nPos,11]
	If SerieNfId("SF6",3,"F6_SERIE") == "F6_SDOC"
		M->F6_SDOC := SubStr(aDadSF6[nPos,11],1,3)
	EndIf
EndIf
If Len(aDadSF6[nPos]) >= 12 .AND. !Empty(aDadSF6[nPos,12])
	M->F6_CLIFOR := aDadSF6[nPos,12]
EndIf
If Len(aDadSF6[nPos]) >= 13 .AND. !Empty(aDadSF6[nPos,13])
	M->F6_LOJA := PadR(aDadSF6[nPos,13],TamSX3("F6_LOJA")[1])
EndIf
If Len(aDadSF6[nPos]) >= 14 .AND. !Empty(aDadSF6[nPos,14])
	M->F6_TIPODOC := Padr(aDadSF6[nPos,14], TamSX3("F6_TIPODOC")[1])
EndIf
If Len(aDadSF6[nPos]) >= 15 .AND. !Empty(aDadSF6[nPos,15])
	M->F6_OPERNF := aDadSF6[nPos,15]
EndIf
If Len(aDadSF6[nPos])>=16 .AND. !Empty(aDadSF6[nPos,16])
	M->F6_INSC := aDadSF6[nPos,16]
EndIf 
If Len(aDadSF6[nPos]) >= 17 .AND. !Empty(aDadSF6[nPos,17])
	M->F6_TIPODOC := Padr(aDadSF6[nPos,17], TamSX3("F6_TIPODOC")[1])
EndIf
If Len(aDadSF6[nPos])>=18 .AND. !Empty(aDadSF6[nPos,18])
	M->F6_NUMCONV := aDadSF6[nPos,18]
EndIf
If Len(aDadSF6[nPos])>=19 .AND. !Empty(aDadSF6[nPos,19]) .And. IsInCallStack('MATA954')
	M->F6_CODMUN := aDadSF6[nPos,19]
EndIf
If lGrValFund .And.Len(aDadSF6[nPos]) >= 24 .And. !Empty(aDadSF6[nPos,24])
	M->F6_VALFUND := aDadSF6[nPos,24]
EndIf
dbSelectArea(cSavAlias)
Return


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FisSTF6  ³ Autor ³ Zanardo               ³ Data ³ 10.10.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza as variaveis de memoria para Inclusao no SF6.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA953                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FisSTF6()
Local cSavAlias    := Alias()
Local nPos         := Len(aDadSF6)
Local cOrigem      := "MATA954"
Local nMVDATPAG    := GetNewPar("MV_DATAPAG",0)
Local aRet         := {}
Local cCodRec	   := ''
Local lGrValFund   := aApurSX3[FP_F6_VALFUND]

If aExistBloc[PE_DADOSTIT]
	aDadosTit := ExecBlock("DADOSTIT", .F., .F., {cOrigem})
	If aDadosTit<>Nil .And. ValType(aDadosTit)=="A"
		aDadSF6[nPos,9] := Iif(Len(aDadosTit)>=1,aDadosTit[1],aDadSF6[nPos,9])
		aDadSF6[nPos,5] := Iif(Len(aDadosTit)>=2,aDadosTit[2],aDadSF6[nPos,5])
	EndIf
EndIf

M->F6_DTARREC := aDadSF6[nPos,2]
M->F6_VALOR   := aDadSF6[nPos,1]
M->F6_MESREF  := aDadSF6[nPos,3]
M->F6_ANOREF  := aDadSF6[nPos,4]
M->F6_DTVENC  := aDadSF6[nPos,5]
M->F6_DTPAGTO := Iif((SomaData(nMVDATPAG,dDatabase)>aDadSF6[1][5]),aDadSF6[1][5],SomaData(nMVDATPAG,dDatabase))
M->F6_TIPOIMP := aDadSF6[nPos,6]
M->F6_CLAVENC := aDadSF6[nPos,7]
M->F6_EST     := PadR(aDadSF6[nPos,8],TamSX3("F6_EST")[1])

If Len(aDadSF6[nPos]) >= 10
	M->F6_NUMERO := aDadSF6[nPos,9]
	M->F6_DOC    := aDadSF6[nPos,10]
	M->F6_SERIE  := aDadSF6[nPos,11]
	If SerieNfId("SF6",3,"F6_SERIE") == "F6_SDOC"
		M->F6_SDOC := SubStr(aDadSF6[nPos,11],1,3)
	EndIf
	M->F6_CLIFOR := aDadSF6[nPos,12]
	M->F6_LOJA   := aDadSF6[nPos,13]
	M->F6_TIPODOC:= aDadSF6[nPos,14]
	M->F6_OPERNF := aDadSF6[nPos,15]
	If Len(aDadSF6[nPos]) >= 16
		M->F6_INSC   := PadR(aDadSF6[nPos,16],TamSX3("F6_INSC")[1])
	EndIf
	If Len(aDadSF6[nPos]) >= 17 .AND. !Empty(aDadSF6[nPos,17])
		M->F6_TIPODOC   := aDadSF6[nPos,17]
	EndIf
	If Len(aDadSF6[nPos]) >= 18 .And. !Empty(aDadSF6[nPos,18])
		M->F6_NUMCONV   := aDadSF6[nPos,18]
	EndIf
	If aApurSX3[FP_F6_FECP]
		If Len(aDadSF6[nPos])>=20 .And. aDadSF6[nPos,20]
			M->F6_FECP := "1"
		Else
			M->F6_FECP := "2"
		EndIf
	Endif
	If Len(aDadSF6[nPos]) >= 21 .And. !Empty(aDadSF6[nPos,21])
		M->F6_CNPJ := aDadSF6[nPos,21]
	EndIf

	M->F6_CODREC := cCodRec := xApCodRec(aDadSF6)
	If Len(aDadSF6[nPos]) >= 22 .And. !Empty(aDadSF6[nPos,22])
		M->F6_OBSERV := aDadSF6[nPos,22]
	EndIf

	If !Empty(cCodRec) .And. aApurSX3[FP_F6_CODAREA]
		M->F6_CODAREA := xApCodArea(cCodRec)
	EndIf

	If lGrValFund .And.Len(aDadSF6[nPos]) >= 24 .And. !Empty(aDadSF6[nPos,24])
		M->F6_VALFUND := aDadSF6[nPos,24]
	EndIf	

Endif

If aApurSX3[FP_F6_TIPOGNU] .And. aFindFunc[FF_RETCMPSSF6]

	aRet := RetCmpsSF6(M->F6_CODREC, M->F6_EST)

	M->F6_TIPOGNU := aRet[1]
	M->F6_DOCORIG := aRet[2]
	M->F6_DETRECE := aRet[3]
	M->F6_CODPROD := aRet[4]

	If Len(aRet) > 4 .And. aApurSX3[FP_F6_CODAREA]
		M->F6_CODAREA := aRet[5]
	EndIf

EndIf

dbSelectArea(cSavAlias)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³LoadDtVenc³ Autor ³Thiago Galvao Silveira ³ Data ³08.05.2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega a Data do Vencimento do Imposto gerado na Apuracao ³±±                  
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
/*/

FUNCTION LoadDtVenc(cArqApur)

LOCAL dDtVenc 	:= 0
LOCAL i         := 0
LOCAL cLinha    := ""


If File(cArqApur)
	cContArq	:=	MemoRead(cArqApur)
	For i	:=	1 to MlCount(cContArq,100)
		cLinha	:=	MemoLine(cContArq,100,i)
		If Substr(cLinha,1,3)=="TIT"
			dDtVenc	:= STOD(substr(cLinha,18,2) + substr(cLinha,14,4) + substr(cLinha,12,2))  // DD/MM/AA
		EndIf
	Next i

EndIf              

RETURN (dDtVenc)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ResumeIP ³ Autor ³ Nereu Humberto Junior ³ Data ³ 10/02/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Le SF3 gerando array com apuracao de imposto para periodo  ³±±
±±³          ³ escolhido de acordo com os codigos NCM passados.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION ResumeIP( dDtIni	,; 	// Dt Inicio da Apuracao
	 	           dDtFim	,; 	// Dt Final da Apuracao
		           cNrLivro	,;	// Numero do Livro
		           nRegua	,;	// 0=Nao Exibe 1=Processamento 2=Relatorio
		           lEnd		,;	// Flag de Interrup‡„o
		           nConsFil	,;	// Considera filial
		           cFilDe	,;	// Filial De
		           cFilAte	,; // Filial ate
		           aNCM	    ,; // Array com codigos NCM
		           nApuracao,; //Tipo da Apuracao
		           cFilUsr  ,; //  Filtro do Usuario
		           nPerCrd  ,; //Percentual do Credito Presumido na Aquisicao de Insumos
		           nTipo    ,; //1=Apuracao e 2=Relatorio
		           lConsUf  ,; // Indica se, quando a apuracao for consolidada, apenas as filiais estabelecidas no mesmo estado do consolidador sejam processadas
		           lQbrUF   ,; // Quebra também por estado
		           cChamOrig,; // Funcao que esta chamando
		           nParPerg ,; // Parametro da pergunta
		           aFilsCalc)  //Array das Filiais Selecionadas
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define variaveis                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL aApuracao	:=	{}
LOCAL aArea     := GetArea() 
LOCAL nPos		:= 0
LOCAL nPosSF3   := 0
LOCAL nPosTot   := 0
LOCAL cCFO      := ""
LOCAL dDtAnt
LOCAL cMsg      := ""
LOCAL nRegEmp 	:= SM0->(RecNo())
LOCAL lQuery 	:= .F.
LOCAL cAliasSF3 := "SF3"
Local cIndSF3	:= ""
Local cChave	:= ""
Local cChaveSF3 := ""
Local aArrayF3  := {}
Local aArrayNCM := {}
Local aArrayTOT := {}
Local cFiltro	:= ""
Local nX		:= 0
Local nBase     := 0
Local nValor    := 0
Local nValCont  := 0
Local nStart    := 1
Local lFlag		:=	.F.
Local aImpRel	:=	{}
Local nItem		:=	0
Local cCgc      := Space (8)                     
Local cMvEstado	:= SuperGetMv("MV_ESTADO")
Local lF3CODRSEF :=	aApurSX3[FP_F3_CODRSEF]
Local cMvCODRSEF := SuperGetMv("MV_CODRSEF", .F., "'','100'")


Local lMapResumo	:= .F.
Local aMapaResumo	:= 	{}
Local aGravaMapRes	:= 	{}
Local cArqBkpQry	:= 	""
#IFDEF TOP 
	Local cDtCanc	:= ""
	Local cQuery	:= ""
#ENDIF

DEFAULT cFilUsr := ""
DEFAULT nPerCrd := 0
DEFAULT nTipo	 := 1
DEFAULT lQbrUF	:= .F.
DEFAULT lConsUf	:= .F.
DEFAULT cChamOrig := ""
DEFAULT nParPerg	:= 0
DEFAULT aFilsCalc   := {}

If SuperGetMV("MV_LJLVFIS",,1) == 2
	If aFindFunc[FF_MAXRVERFUNC]
		If MaxRVerFunc(cChamOrig)
			If nParPerg == 1
				lMapResumo := .T.
			EndIf
		EndIf	
	Endif
EndIf

cMvCODRSEF		:= IIF(Empty(cMvCODRSEF), "'','100'", cMvCODRSEF)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Trata filiais                                                ³
//³ Caso haja algum parametro sem ser passado ou se nao considera³
//³ filiais, a filiais de/ate serao a corrente                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//
nConsFil := Iif(nConsFil==Nil,2,nConsFil)
If (cFilDe == Nil .or. cFilAte == Nil .or. nConsFil == 2)	
	cFilDe := cFilAnt
	cFilAte:= cFilAnt
Endif

If nConsFil == 1 .and. Len( aFilsCalc ) > 0	
	cFilDe := Space(Len( cFilAnt ) ) 
	cFilAte := Replicate('Z',Len( cFilAnt ) ) 
EndIf

IF Empty(cFilDe) .AND. Empty(cFilAte)
	cFilDe	:= Iif(Empty(cFilDe),cFilAnt,cFilDe)
	cFilAte	:= Iif(Empty(cFilAte),cFilAnt,cFilAte)
EndIF

//

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define valores default                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lEnd	 :=	IIf(lEnd==NIL,.f.,lEnd)
nRegua	 :=	IIf(nRegua==NIL,0,nRegua)
cNrLivro :=	IIf(cNrLivro==NIL	,"*",cNrLivro)

dbSelectArea("SM0")
dbSeek(cEmpAnt+cFilDe,.T.)

cCgc	:=	SubStr (SM0->M0_CGC, 1, 8)

While !SM0->(Eof()) .and. FWGrpCompany()+FWCodFil() <= cEmpAnt+cFilAte 
	cFilAnt := FWGETCODFILIAL		// Mudar filial atual temporariamente

	If  !(cCgc==SubStr (SM0->M0_CGC, 1, 8)) .and. (SuperGetMv("MV_CONSCGC"))
		SM0->(DbSkip ())
		Loop
	EndIf
#IFDEF TOP
	//-- Tratamento para utilizacao da MatFilCalc - gestão corporativa somente para TOP
	If nConsFil == 1  .And. Len(aFilsCalc)>0
		If ( nPos := aScan( aFilsCalc, {|x| Alltrim(x[2]) == Alltrim(cFilAnt)} ) ) == 0 .or. !aFilsCalc[nPos, 1]		// Se filial não selecionada ou não marcada
			SM0->( dbSkip() ) 
			Loop
		EndIf
	EndIf
#ENDIF
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atendimento ao Art. 121 do ANEXO 5 do RICMS/SC. O mesmo determina que todo prestador de                    ³
	//³  serviço de transporte deve apresentar as obrigações acessórias de forma consolidada pelo estabelecimento ³
	//³  matriz, e esta consolidação deverá abranger somente as empresas que estiverem domiciliadas no mesmo      ³
	//³  estado do estabelecimento consolidador.                                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lConsUF .And. (SM0->M0_ESTENT <> cMvEstado)
		SM0->(DbSkip ())
		Loop
	EndIf

	dbSelectArea("SF3")
	SF3->(dbSetOrder(1))
	If nRegua>0
		If nRegua	==	1
			ProcRegua(dDtFim-dDtIni)
		Else
			SetRegua(dDtFim-dDtIni)
		Endif
		dDtAnt	:=	SF3->F3_ENTRADA
	Endif  

	
	
	#IFDEF TOP
	
	    If TcSrvType()<>"AS/400"
	
			lQuery 		:= .T.
			cAliasSF3	:= GetNextAlias()   
			cQuery		:= ""
			
			If cNrLivro <> "*"
				cQuery := "F3_NRLIVRO = '" + cNrLivro + "' AND "
			Endif

			If lF3CODRSEF
				cQuery += "((SF3.F3_ESPECIE IN ('SPED','CTE','NFCE') AND SF3.F3_CODRSEF IN(" + cMvCODRSEF + ")) OR SF3.F3_ESPECIE NOT IN ('SPED','CTE','NFCE')) AND "	
			Endif
				
			cQuery := "%" + cQuery + "%"
			
			cDtCanc := Space(TamSx3("F3_DTCANC")[01])		

			BeginSql Alias cAliasSF3
				COLUMN F3_ENTRADA 	AS DATE
				COLUMN F3_EMISSAO 	AS DATE
				COLUMN F3_DTLANC 	AS DATE
				COLUMN F3_DTCANC 	AS DATE
				COLUMN F3_EMINFE 	AS DATE
				SELECT *
				
				FROM %table:SF3% SF3
					
				WHERE SF3.F3_FILIAL = %xFilial:SF3% AND 
					SF3.F3_ENTRADA >= %Exp:dDtIni% AND 
					SF3.F3_ENTRADA <= %Exp:dDtFim% AND 
					SF3.F3_DTCANC = %Exp:cDtCanc% AND
					SF3.F3_TIPO <> 'S' AND
					%Exp:cQuery%
					SF3.%NotDel%
						
				ORDER BY %Order:SF3%
			EndSql
		
			dbSelectArea(cAliasSF3)
	
		Else
		                  
	#ENDIF
		dbSelectArea(cAliasSF3)    
		cIndSF3	:=	CriaTrab(NIL,.F.)
		cChave	:=	IndexKey()
		cFiltro	:=	"SF3->F3_FILIAL=='"+xFilial("SF3")+"' .And. DTOS(SF3->F3_ENTRADA)>='"+Dtos(dDtIni)+"' .AND. DTOS(SF3->F3_ENTRADA)<='"+Dtos(dDtFim)+"'"						
		cFiltro	+=  " .And. DTOS(SF3->F3_DTCANC)=='"+Dtos(Ctod(""))+"'"		
		cFiltro	+=  " .And. F3_TIPO <> 'S' "
		If lF3CODRSEF
			cFiltro += " .And. ((SF3->F3_ESPECIE$'SPED,CTE,NFCE') .And. SF3->F3_CODRSEF$" + StrTran(cMvCODRSEF,",","/") + ") .Or. (!SF3->F3_ESPECIE$'SPED,CTE,NFCE')" 
		Endif
		If cNrLivro <> "*"
			cFiltro	+= " .And. SF3->F3_NRLIVRO=='"+ cNrLivro +"'"
		Endif

		IndRegua(cAliasSF3,cIndSF3,cChave,,cFiltro)
		(cAliasSF3)->(DbgoTop()) 
	#IFDEF TOP
		Endif    
	#ENDIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Apresenta informacoes do Mapa Resumo de acordo com arquivo temporario³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lMapResumo
	
		cChave			:=	IndexKey()
		cArqBkpQry 		:= 	cAliasSf3
	
		aMapaResumo		:= 	MaxRMapRes(dDtIni,dDtfIM)
		aGravaMapRes	:= 	MaXRAgrupF3(cFilAnt,aMapaResumo,cChamOrig)
		cArqTmpMP		:= 	MaXRExecArq(1)
		cAliasSf3		:=	MaXRAddArq(	1			,	cArqTmpMP	,	cAliasSf3	,/*aCposTemp*/	,;
										aGravaMapRes,	cChave		)
	
	EndIf
	
	While (cAliasSF3)->(!Eof()) .and. (cAliasSF3)->F3_FILIAL	==	xFilial("SF3") .and. (cAliasSF3)->F3_ENTRADA<=dDtFim .and. !lEnd

		If !Empty(cFilUsr) .And. !((cAliasSF3)->(&cFilUsr.))
			DbSkip()
			Loop	
		Endif
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Movimenta regua                                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nRegua>0
			cMsg	:=	OemToAnsi(STR0001) //"Executando apura‡„o..."
			If dDtAnt	!=	(cAliasSF3)->F3_ENTRADA
				If nRegua	==	1
					IncProc(cMsg)
				Else
					IncRegua()
				Endif
				dDtAnt	:=	(cAliasSF3)->F3_ENTRADA
			EndIf
		Endif
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica interrupcao                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Interrupcao(@lEnd)
			aApuracao := {}
			Loop
		Endif
		
		dbSelectArea(cAliasSF3)
		cChaveSF3 := (cAliasSF3)->F3_NFISCAL+(cAliasSF3)->F3_SERIE+(cAliasSF3)->F3_CLIEFOR+(cAliasSF3)->F3_LOJA
		
		Aadd(aArrayF3, {(cAliasSF3)->F3_NFISCAL,;  //01
						 (cAliasSF3)->F3_SERIE,;   //02
						 (cAliasSF3)->F3_CLIEFOR,; //03
						 (cAliasSF3)->F3_LOJA,;    //04
						 (cAliasSF3)->F3_CFO,;     //05
						 (cAliasSF3)->F3_VALCONT,; //06
						 (cAliasSF3)->F3_BASEIPI,; //07
						 (cAliasSF3)->F3_VALIPI,;  //08
						 (cAliasSF3)->F3_ISENIPI,; //09
						 (cAliasSF3)->F3_OUTRIPI,; //10
						 (cAliasSF3)->F3_ESTADO}) //11	   
		
		(cAliasSF3)->(dbSkip())
		
		If cChaveSF3 <> (cAliasSF3)->F3_NFISCAL+(cAliasSF3)->F3_SERIE+(cAliasSF3)->F3_CLIEFOR+(cAliasSF3)->F3_LOJA
		
			If Val(Substr(aArrayF3[1][5],1,1))<5
   				DbSelectArea ("SF1")
					SF1->(DbSetOrder (1))
				SF1->(DbSeek (xFilial ("SF1")+aArrayF3[1][1]+aArrayF3[1][2]+aArrayF3[1][3]+aArrayF3[1][4]))
				//
				dbSelectArea("SD1")
				dbSetOrder(1)
				If MsSeek(xFilial("SD1")+aArrayF3[1][1]+aArrayF3[1][2]+aArrayF3[1][3]+aArrayF3[1][4])
					//
					nItem	:=	0
					//
		            While !Eof() .And. xFilial("SD1")+aArrayF3[1][1]+aArrayF3[1][2]+aArrayF3[1][3]+aArrayF3[1][4] == ;
		                          SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA
		                nItem++		                
		                SB1->(MsSeek(xFilial("SB1")+SD1->D1_COD))
		                SB5->(MsSeek(xFilial("SB5")+SD1->D1_COD))
		                
		                If SF4->(MsSeek(xFilial("SF4")+SD1->D1_TES))
		                	//
		                	lFlag	:=	.F.
		                	//
							If (SF4->F4_LFIPI == "T" .Or. (SF4->F4_LFIPI $ "IO" .And. SF4->F4_BASEIPI <> 0))
		                		//
		                		lFlag	:=	.T.
		                		//
		                		nValCont := SD1->D1_TOTAL+SD1->D1_VALIPI+SD1->D1_ICMSRET+SD1->D1_SEGURO+SD1->D1_DESPESA+SD1->D1_VALFRE
		                		If !lQbrUF
			                		nPos := Ascan(aArrayTOT,{|x|x[1]==SD1->D1_CF})
			                	Else                                               
			                		nPos := Ascan(aArrayTOT,{|x|x[1]==SD1->D1_CF .And. x[5]==aArrayF3[1][11]})
			                	Endif
	                			If nPos==0
									Aadd(aArrayTOT,{SD1->D1_CF,SD1->D1_BASEIPI,SD1->D1_VALIPI,nValCont,aArrayF3[1][11]})	
			                	Else
				                	aArrayTOT[nPos,2] += IIF(SF4->F4_IPI <> "R",SD1->D1_BASEIPI,0)
			    	            	aArrayTOT[nPos,3] += IIF(SF4->F4_IPI <> "R",SD1->D1_VALIPI,0)
			    	            	aArrayTOT[nPos,4] += nValCont
		            	    	Endif                                                          
		            	    	
			                	//Verifica se o NCM esta contido no array passado por parametro
								If aApurSX3[FP_B5_TPAPUR]
				                   nPos := 0
			                	   If nPerCrd > 0 .Or. (SB5->B5_TPAPUR=="2" .Or. (nPos == 0 .And. nApuracao == 2 .And. DToS (dDtIni)<"20041001")) .Or. (SB5->B5_TPAPUR=="1" .Or. (nPos > 0 .And. nApuracao == 1)) .Or. (SB5->B5_TPAPUR=="3" .Or. (nPos==0 .and. nApuracao==3 .And. DToS (dDtIni)>="20041001"))
			                		  nValCont := SD1->D1_TOTAL+SD1->D1_VALIPI+SD1->D1_ICMSRET+SD1->D1_SEGURO+SD1->D1_DESPESA+SD1->D1_VALFRE
			                		  If !lQbrUF 
				                		  nPos := Ascan(aArrayNCM,{|x|x[1]==SD1->D1_CF})
				                      Else                                               
				                          nPos := Ascan(aArrayNCM,{|x|x[1]==SD1->D1_CF .And. x[5]==aArrayF3[1][11]})
				                      Endif
	                				  If nPos==0
										 Aadd(aArrayNCM,{SD1->D1_CF,SD1->D1_BASEIPI,SD1->D1_VALIPI,nValCont,aArrayF3[1][11]})	
				                	  Else
					                	 aArrayNCM[nPos,2] += IIF(SF4->F4_IPI <> "R",SD1->D1_BASEIPI,0)
				    	            	 aArrayNCM[nPos,3] += IIF(SF4->F4_IPI <> "R",SD1->D1_VALIPI,0)
				    	            	 aArrayNCM[nPos,4] += nValCont
		    	        	    	  Endif
		    	        	       Endif  
								Else
				                   nPos := Ascan(aNCM,{|x|AllTrim(SB1->B1_POSIPI)>=x[1] .And. AllTrim(SB1->B1_POSIPI)<=x[2]})
			                	   If nPerCrd > 0 .Or. (nPos == 0 .And. nApuracao == 2 .And. DToS (dDtIni)<"20041001") .Or. (nPos > 0 .And. nApuracao == 1) .Or. (nPos==0 .and. nApuracao==3 .And. DToS (dDtIni)>="20041001")
			                		  nValCont := SD1->D1_TOTAL+SD1->D1_VALIPI+SD1->D1_ICMSRET+SD1->D1_SEGURO+SD1->D1_DESPESA+SD1->D1_VALFRE
			                		  If !lQbrUF 
				                		  nPos := Ascan(aArrayNCM,{|x|x[1]==SD1->D1_CF})
				                      Else                                               
				                          nPos := Ascan(aArrayNCM,{|x|x[1]==SD1->D1_CF .And. x[5]==aArrayF3[1][11]})
				                      Endif
	                				  If nPos==0
										 Aadd(aArrayNCM,{SD1->D1_CF,SD1->D1_BASEIPI,SD1->D1_VALIPI,nValCont,aArrayF3[1][11]})	
				                	  Else
					                	 aArrayNCM[nPos,2] += SD1->D1_BASEIPI
				    	            	 aArrayNCM[nPos,3] += SD1->D1_VALIPI
				    	            	 aArrayNCM[nPos,4] += nValCont
		    	        	    	  Endif
		    	        	       Endif  
			                	Endif	
		                	Endif
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Este array relaciona-se as notas Isentas e/ou Outras que nao possuem base de reducao. Este array he utilizado somente para exibicao no relatorio.³
							//³Esta exibicao somente deve ser efetuada no relatorio e nao na apuracao, porque pode atrapalhar no rateio. Este he o porque deste if separado.    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		                	If (nTipo==2) .And. !(lFlag) .and. (SF4->F4_LFIPI$"IO")
     		                	

								If aApurSX3[FP_B5_TPAPUR]
     		                	   nPos :=0
			                	   If (SB5->B5_TPAPUR=="2" .Or. (nPos == 0 .And. nApuracao == 2 .And. DToS (dDtIni)<"20041001")) .Or. (SB5->B5_TPAPUR=="1" .Or. (nPos > 0 .And. nApuracao == 1)) .Or. (SB5->B5_TPAPUR=="3" .Or. (nPos==0 .and. nApuracao==3 .And. DToS (dDtIni)>="20041001"))		                		
			                		  nValCont := SD1->D1_TOTAL+SD1->D1_VALIPI+SD1->D1_ICMSRET+SD1->D1_SEGURO+SD1->D1_DESPESA+SD1->D1_VALFRE
			                		  If  !lQbrUF 
			                		      nPos := Ascan (aImpRel, {|x|x[1]==SD1->D1_CF})
			                		  Else                                               
			                		      nPos := Ascan (aImpRel, {|x|x[1]==SD1->D1_CF .And. x[7]==aArrayF3[1][11]})
			                		  Endif
			                		  //
		                			  If (nPos==0)
										 aAdd (aImpRel, {SD1->D1_CF, IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD1->D1_BASEIPI,0), IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD1->D1_VALIPI,0) , nValCont, xMagValFis (1, 0,"SF1", nItem, "LF_ISENIPI"), xMagValFis (1, 0,"SF1", nItem, "LF_OUTRIPI"),aArrayF3[1][11]})	
				                	  Else
					                	 aImpRel[nPos,2] += IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD1->D1_BASEIPI,0)
				    	             	 aImpRel[nPos,3] += IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD1->D1_VALIPI,0)
				    	            	 aImpRel[nPos,4] += nValCont
				    	            	 aImpRel[nPos,5] += xMagValFis (1, 0,"SF1", nItem, "LF_ISENIPI")
				    	            	 aImpRel[nPos,6] += IIF(SF4->F4_IPI == 'R',xMagValFis (1, 0,"SF1", nItem, "LF_OUTRIPI")+SD1->D1_BASEIPI,xMagValFis (1, 0,"SF1", nItem, "LF_OUTRIPI"))				    	            	
			            	    	  Endif		                			            	    	
		            	    	   Endif
                                Else
     		                	   nPos := Ascan(aNCM,{|x|AllTrim(SB1->B1_POSIPI)>=x[1] .And. AllTrim(SB1->B1_POSIPI)<=x[2]})
			                	   If (nPos == 0 .And. nApuracao == 2 .And. DToS (dDtIni)<"20041001") .Or. (nPos > 0 .And. nApuracao == 1) .Or. (nPos==0 .and. nApuracao==3 .And. DToS (dDtIni)>="20041001")
		                		
			                		  nValCont := SD1->D1_TOTAL+SD1->D1_VALIPI+SD1->D1_ICMSRET+SD1->D1_SEGURO+SD1->D1_DESPESA+SD1->D1_VALFRE
		                              If  !lQbrUF 
			                		      nPos := Ascan (aImpRel, {|x|x[1]==SD1->D1_CF})
			                		  Else                                               
			                		      nPos := Ascan (aImpRel, {|x|x[1]==SD1->D1_CF .And. x[7]==aArrayF3[1][11]})
			                		  Endif

			                		  //
		                			  If (nPos==0)
										 aAdd (aImpRel, {SD1->D1_CF, IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD1->D1_BASEIPI,0), IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD1->D1_VALIPI,0) , nValCont, xMagValFis (1, 0,"SF1", nItem, "LF_ISENIPI"), xMagValFis (1, 0,"SF1", nItem, "LF_OUTRIPI"),aArrayF3[1][11]})	
				                	  Else
					                	 aImpRel[nPos,2] += IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD1->D1_BASEIPI,0)
				    	             	 aImpRel[nPos,3] += IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD1->D1_VALIPI,0)
				    	            	 aImpRel[nPos,4] += nValCont
				    	            	 aImpRel[nPos,5] += xMagValFis (1, 0,"SF1", nItem, "LF_ISENIPI")
				    	            	 aImpRel[nPos,6] += IIF(SF4->F4_IPI == 'R',xMagValFis (1, 0,"SF1", nItem, "LF_OUTRIPI")+SD1->D1_BASEIPI,xMagValFis (1, 0,"SF1", nItem, "LF_OUTRIPI"))			    	            	
			            	    	  Endif		                			            	    	
		            	    	   Endif
		            	    	Endif   
		                	EndIf
		                Endif
		                          
		            	SD1->(dbSkip())
		            EndDo
		        Endif
		    Else
   				DbSelectArea ("SF2")
					SF2->(DbSetOrder (1))
				SF2->(DbSeek (xFilial ("SF2")+aArrayF3[1][1]+aArrayF3[1][2]+aArrayF3[1][3]+aArrayF3[1][4]))
				//
		   		dbSelectArea("SD2")
				dbSetOrder(3)
				If MsSeek(xFilial("SD2")+aArrayF3[1][1]+aArrayF3[1][2]+aArrayF3[1][3]+aArrayF3[1][4])
					//
					nItem	:=	0
					//
		            While !Eof() .And. xFilial("SD2")+aArrayF3[1][1]+aArrayF3[1][2]+aArrayF3[1][3]+aArrayF3[1][4] == ;
		                          SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA
		                
		                nItem++
		                SB1->(MsSeek(xFilial("SB1")+SD2->D2_COD))
		                SB5->(MsSeek(xFilial("SB5")+SD2->D2_COD))
		                
		                If SF4->(MsSeek(xFilial("SF4")+SD2->D2_TES))
		                	//
		                	lFlag	:=	.F.
		                	//
		                	If SF4->F4_LFIPI == "T" .Or. (SF4->F4_LFIPI $ "IO" .And. SF4->F4_BASEIPI <> 0)
		                		//
		                		lFlag	:=	.T.
		                		//
		                		nValCont := SD2->D2_TOTAL+SD2->D2_VALIPI+SD2->D2_ICMSRET+SD2->D2_SEGURO+SD2->D2_DESPESA+SD2->D2_VALFRE
                                If  !lQbrUF 
			                	     nPos := Ascan(aArrayTOT,{|x|x[1]==SD2->D2_CF})
			                	Else                                               
			                	     nPos := Ascan(aArrayTOT,{|x|x[1]==SD2->D2_CF .And. x[5]==aArrayF3[1][11]})
			                	Endif
		                		nPos := Ascan(aArrayTOT,{|x|x[1]==SD2->D2_CF})
	                			If nPos==0
									Aadd(aArrayTOT,{SD2->D2_CF,SD2->D2_BASEIPI,SD2->D2_VALIPI,nValCont})	
			                	Else
				                	aArrayTOT[nPos,2] += SD2->D2_BASEIPI
			    	            	aArrayTOT[nPos,3] += SD2->D2_VALIPI
			    	            	aArrayTOT[nPos,4] += nValCont
		            	    	Endif

			                	//Verifica se o NCM esta contido no array passado por parametro
								If aApurSX3[FP_B5_TPAPUR]
			                	   nPos := 0
			                	   If (SB5->B5_TPAPUR=="2" .Or. (nPos == 0 .And. nApuracao == 2 .And. DToS (dDtIni)<"20041001")) .Or. (SB5->B5_TPAPUR=="1" .Or. (nPos > 0 .And. nApuracao == 1)) .Or. (SB5->B5_TPAPUR=="3" .Or. (nPos==0 .and. nApuracao==3 .And. DToS (dDtIni)>="20041001"))
			                		  nValCont := SD2->D2_TOTAL+SD2->D2_VALIPI+SD2->D2_ICMSRET+SD2->D2_SEGURO+SD2->D2_DESPESA+SD2->D2_VALFRE
    		                          If  !lQbrUF 
				                	      nPos := Ascan(aArrayNCM,{|x|x[1]==SD2->D2_CF})
			    	            	  Else                                               
			        	        	      nPos := Ascan(aArrayNCM,{|x|x[1]==SD2->D2_CF .And. x[5]==aArrayF3[1][11]})
			            	    	  Endif
	                				  If nPos==0
										 Aadd(aArrayNCM,{SD2->D2_CF,SD2->D2_BASEIPI,SD2->D2_VALIPI,nValCont,aArrayF3[1][11]})	
				                	  Else
					                	 aArrayNCM[nPos,2] += SD2->D2_BASEIPI
				    	            	 aArrayNCM[nPos,3] += SD2->D2_VALIPI
				    	            	 aArrayNCM[nPos,4] += nValCont
		    	        	    	  Endif
			                	   Endif	
								Else
			                	   nPos := Ascan(aNCM,{|x|AllTrim(SB1->B1_POSIPI)>=x[1] .And. AllTrim(SB1->B1_POSIPI)<=x[2]})
			                	   If (nPos == 0 .And. nApuracao == 2 .And. DToS (dDtIni)<"20041001") .Or. (nPos > 0 .And. nApuracao == 1) .Or. (nPos==0 .and. nApuracao==3 .And. DToS (dDtIni)>="20041001")
    		                          If  !lQbrUF 
				                	      nPos := Ascan(aArrayNCM,{|x|x[1]==SD2->D2_CF})
			    	            	  Else                                               
			        	        	      nPos := Ascan(aArrayNCM,{|x|x[1]==SD2->D2_CF .And. x[5]==aArrayF3[1][11]})
			            	    	  Endif
			                		  nValCont := SD2->D2_TOTAL+SD2->D2_VALIPI+SD2->D2_ICMSRET+SD2->D2_SEGURO+SD2->D2_DESPESA+SD2->D2_VALFRE
	                				  If nPos==0
										 Aadd(aArrayNCM,{SD2->D2_CF,SD2->D2_BASEIPI,SD2->D2_VALIPI,nValCont,aArrayF3[1][11]})	
				                	  Else
					                	 aArrayNCM[nPos,2] += SD2->D2_BASEIPI
				    	            	 aArrayNCM[nPos,3] += SD2->D2_VALIPI
				    	            	 aArrayNCM[nPos,4] += nValCont
		    	        	    	  Endif
			                	   Endif	
			                	Endif   
		                	Endif
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Este array relaciona-se as notas Isentas e/ou Outras que nao possuem base de reducao. Este array he utilizado somente para exibicao no relatorio.³
							//³Esta exibicao somente deve ser efetuada no relatorio e nao na apuracao, porque pode atrapalhar no rateio. Este he o porque deste if separado.    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		                	If (nTipo==2) .And. !(lFlag) .and. (SF4->F4_LFIPI$"IO")
								If aApurSX3[FP_B5_TPAPUR]
     		                	   nPos :=0
			                	   If (SB5->B5_TPAPUR=="2" .Or. (nPos == 0 .And. nApuracao == 2 .And. DToS (dDtIni)<"20041001")) .Or. (SB5->B5_TPAPUR=="1" .Or. (nPos > 0 .And. nApuracao == 1)) .Or. (SB5->B5_TPAPUR=="3" .Or. (nPos==0 .and. nApuracao==3 .And. DToS (dDtIni)>="20041001"))		                					                	
			                		  nValCont := SD2->D2_TOTAL+SD2->D2_VALIPI+SD2->D2_ICMSRET+SD2->D2_SEGURO+SD2->D2_DESPESA+SD2->D2_VALFRE
    		                          If  !lQbrUF 
				                	      nPos := Ascan(aImpRel,{|x|x[1]==SD2->D2_CF})
			    	            	  Else                                               
			        	        	      nPos := Ascan(aImpRel,{|x|x[1]==SD2->D2_CF .And. x[7]==aArrayF3[1][11]})
			            	    	  Endif

			                		  nPos := Ascan (aImpRel, {|x|x[1]==SD2->D2_CF})
			                		  //
		                			  If nPos==0
										 aAdd (aImpRel, {SD2->D2_CF, IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD2->D2_BASEIPI,0), IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD2->D2_VALIPI,0), nValCont, xMagValFis (2, 0,"SF2", nItem, "LF_ISENIPI"),xMagValFis (2, 0,"SF2", nItem, "LF_OUTRIPI"),aArrayF3[1][11]})
				                	  Else
					                	 aImpRel[nPos,2] += IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD2->D2_BASEIPI,0)
				    	            	 aImpRel[nPos,3] += IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD2->D2_VALIPI,0)
				    	            	 aImpRel[nPos,4] += nValCont
				    	            	 aImpRel[nPos,5] += xMagValFis (2, 0,"SF2", nItem, "LF_ISENIPI")
				    	            	 aImpRel[nPos,6] += xMagValFis (2, 0,"SF2", nItem, "LF_OUTRIPI")
			            	    	  Endif
		            	    	   Endif
		                		Else			                	
			                	   //Verifica se o NCM esta contido no array passado por parametro
			                	   nPos := Ascan(aNCM,{|x|AllTrim(SB1->B1_POSIPI)>=x[1] .And. AllTrim(SB1->B1_POSIPI)<=x[2]})
			                	   If (nPos == 0 .And. nApuracao == 2 .And. DToS (dDtIni)<"20041001") .Or. (nPos > 0 .And. nApuracao == 1) .Or. (nPos==0 .and. nApuracao==3 .And. DToS (dDtIni)>="20041001")
			                	
			                		  nValCont := SD2->D2_TOTAL+SD2->D2_VALIPI+SD2->D2_ICMSRET+SD2->D2_SEGURO+SD2->D2_DESPESA+SD2->D2_VALFRE
    		                          If  !lQbrUF 
				                	      nPos := Ascan(aImpRel,{|x|x[1]==SD2->D2_CF})
			    	            	  Else                                               
			        	        	      nPos := Ascan(aImpRel,{|x|x[1]==SD2->D2_CF .And. x[7]==aArrayF3[1][11]})
			            	    	  Endif

			                		  //
		                			  If nPos==0
										 aAdd (aImpRel, {SD2->D2_CF, IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD2->D2_BASEIPI,0), IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD2->D2_VALIPI,0), nValCont, xMagValFis (2, 0,"SF2", nItem, "LF_ISENIPI"),xMagValFis (2, 0,"SF2", nItem, "LF_OUTRIPI"),aArrayF3[1][11]})
				                	  Else
					                	 aImpRel[nPos,2] += IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD2->D2_BASEIPI,0)
				    	            	 aImpRel[nPos,3] += IIF(SF4->F4_BASEIPI > 0 .And. SF4->F4_CONSUMO <> "S",SD2->D2_VALIPI,0)
				    	            	 aImpRel[nPos,4] += nValCont
				    	            	 aImpRel[nPos,5] += xMagValFis (2, 0,"SF2", nItem, "LF_ISENIPI")
				    	            	 aImpRel[nPos,6] += xMagValFis (2, 0,"SF2", nItem, "LF_OUTRIPI")
			            	    	  Endif
		            	    	   Endif
		            	    	Endif
		                	EndIf
		                Endif
		                          
		            	SD2->(dbSkip())
		            EndDo
		        Endif
		    Endif    
			nValCont := 0
			If Len(aArrayNCM) > 0
				If !lQbrUF 
					aArrayF3 := aSort(aArrayF3,,,{|x,y| x[5] < y[5] })
					aArrayTOT:= aSort(aArrayTOT,,,{|x,y| x[1] < y[1] })
				Else
					aArrayF3 := aSort(aArrayF3,,,{|x,y| x[5] + x[11] < y[5] + y[11] })
					aArrayTOT:= aSort(aArrayTOT,,,{|x,y| x[1] + x[5] < y[1] + y[5] })
				Endif
				For nX := 1 To Len(aArrayNCM)
					nStart := 1
					nBase  := 0
					nValor := 0
					nValCont := 0
					Do While (nPosSF3 := Ascan(aArrayF3,{|x|x[5]==aArrayNCM[nX][1]},nStart)) > 0
					    nPosTot := Ascan(aArrayTOT,{|x|x[1]==aArrayNCM[nX][1]})
						If nPosSF3 <> 0 .And. nPosTot <> 0
							nBase    += aArrayF3[nPosSF3][7] * (aArrayNCM[nX][2] / aArrayTOT[nPosTot][2])
							nValor   += aArrayF3[nPosSF3][8] * (aArrayNCM[nX][3] / aArrayTOT[nPosTot][3])
							nValCont += aArrayF3[nPosSF3][6] * (aArrayNCM[nX][4] / aArrayTOT[nPosTot][4])
						Else
							nBase    := 0
							nValor   := 0
							nValCont := 0
						Endif	
			            If (nStart := ++nPosSF3) > Len(aArrayF3)
			                Exit
			            Endif
					EndDo
					cCFO	:=	VerCFO(aArrayNCM[nX][1])
					cUF		:=  aArrayNCM[nX][5]
					If !lQbrUF  
						nPos := Ascan(aApuracao,{|x|x[1]==cCFO})
					Else                                         
						nPos := Ascan(aApuracao,{|x|x[1]==cCFO .And. x[19]==cUF})
					Endif
					
					If nPos==0
						AADD(aApuracao,Array(24))
						nPos	:=	Len(aApuracao)
						aApuracao[nPos,01]	:=	cCFO
						Aeval(aApuracao[nPos],{|x,i|aApuracao[nPos,i]:=0},3)
						aApuracao[nPos,19]	:=	cUF
					Endif
					aApuracao[nPos,03]	+=	nBase
					aApuracao[nPos,04]	+=	IIF(nPerCrd > 0 .And. cCFO < "5" ,(nValor*nPerCrd)/100,nValor)
					aApuracao[nPos,11]	+=	nValCont
				Next	
			Endif
	        aArrayNCM := {}
			aArrayTOT := {}
	        aArrayF3  := {}
	        dbSelectArea(cAliasSF3)	
        Endif
	EndDo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Exclui arquivo temporario³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lMapResumo
		MaXRExecArq(2,cArqTmpMP)
		cAliasSf3 := cArqBkpQry
		DbSelectArea(cAliasSF3)
	EndIf		

   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   //³ Fecha a area de trabalho da query                            ³
   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	#IFDEF TOP
		dbSelectArea(cAliasSF3)
		dbCloseArea()
	#ENDIF 
	
	If FWModeAccess("SF3",3)=="C"
		Exit
	Endif
	
	dbSelectArea("SM0")
	SM0->( dbSkip())
EndDo

If lQuery
    If Select(cAliasSF3)>0
	   dbSelectArea(cAliasSF3)
	   RetIndex()
	   Ferase(cAliasSF3)
	Endif   
Else
	RetIndex("SF3")
	dbClearFilter()
	Ferase(cIndSF3+OrdBagExt()) 
EndIf

SM0->(dbGoTo(nRegEmp))
cFilAnt := SM0->M0_CODFIL


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄP¿
//³Quando a funcao for chamada de um relatorio, devo adicionar o array  criado para outras/isentas no array de apuracao para exibicao das informacoes no relatorio.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPÙ
If nTipo==2
	For nX := 1 To Len (aImpRel)
		cCFO	:=	VerCFO(aImpRel[nX][1])
		nPos := aScan (aApuracao,{|x|x[1]==cCFO})
		//
		If nPos==0
			aAdd (aApuracao, Array (24))
			nPos	:=	Len (aApuracao)
			aApuracao[nPos,01]	:=	cCFO
			Aeval(aApuracao[nPos], {|x,i|aApuracao[nPos,i]:=0},3)
		Endif
		aApuracao[nPos,03]	+=	aImpRel[nX,2]
		aApuracao[nPos,04]	+=	aImpRel[nX,3]
		aApuracao[nPos,11]	+=	aImpRel[nX,4]
		aApuracao[nPos,05]	+=	aImpRel[nX,5]
		aApuracao[nPos,06]	+=	aImpRel[nX,6]
	Next (nX)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Sorteia a apuracao                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aApuracao	:=	Asort(aApuracao,,,{|x,y|x[1]+StrZero(100000000000000-x[11],15)<y[1]+StrZero(100000000000000-y[11],15)})

RestArea(aArea)

RETURN (aApuracao)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ FIM DA FUNCAO                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GeraLinha ³ Autor ³ Gustavo G. Rueda      ³ Data ³ 31/04/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se deve gerar linha referente Lei 9.43/96 que     ³±±
±±³          ³ define um valor minimo para geracao de titulos referente   ³±±
±±³          ³ o saldo devedor da apuracao de IPI.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GeraLinhaApur (nValor, cOrigem)
	Local	lRet	:=	.T.
	//
	If !(cOrigem==Nil)
		If ("MATA952"$cOrigem) .And. (nValor>0) .And. (nValor<SuperGetMv ("MV_MINIPI"))
	 		If !MsgYesNo (OemToAnsi (STR0072), OemToAnsi (STR0073))
				lRet	:=	.F.
			EndIf
		EndIf
	Else
		If (nValor>0) .And. (nValor<SuperGetMv ("MV_MINIPI"))
			lRet	:=	.T.
		Else
			lRet	:=	.F.	
		EndIf
	EndIf
Return (lRet)

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CkApurCDH ³ Autor ³ Liber De Esteban      ³ Data ³ 18-12-07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se encontrou apuracao no CDH                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CkApurCDH(nApuracao,nPeriodo,cNrLivro,aDadIC,cLcPadExt,dDtIni,cArqApur,aDadST,cProgram,lTitulo,aGnre,dDtFim,nOpc,aFoment, lGuiaRec, lDelGNR,aGDGErada,aCDADifal,lAutomato,aEApCe6Ce5, lProcRefer)

Local oDlgCheck
Local oDlgTit

Local aNrTit		:= {}
Local aValidGuia	:= {}

Local cChave	:= STR(nApuracao,1)+STR(nPeriodo,1)+DTOS(dDtIni)+cNrLivro
Local cChaveIc	:= ""
Local cChaveST	:= ""
Local cTitulo	:= ""
Local cText1	:= ""
Local cSomaSeq	:= ""
Local cSequen	:= ""
Local nX		:= 0
Local lRet		:= .T.
Local lFindSE2  := .F.
Local lRefApur	:= SuperGetMv("MV_REFAPUR")	//Permite Refazer a Apuracao mesmo com o Titulo ja Baixado
Local cNrTitBx  := ""
Local cReflex	:= ''
Local cPeriodo	:=	SubStr(DToS(dDtIni),1,6)
Local lCdoAgrupa:= aApurSX3[FP_CDO_AGRUPA] .AND. aApurSX3[FP_CC6_AGRUPA] 
Local lCdhTPLANC:= aApurSX3[FP_CDH_TPLANC] 
Local cDesTpLanc:= ''
Local lLoadCDH	:= .T.
Local lCdoInd	:= .F.
Local lProcApur := aExistBloc[PE_PROCAPUR]
Local lProcApRet:= .F.
Local nMes		:= MV_PAR01
Local nAno		:= MV_PAR02
Local cChvDIFAL	:= ''
Local nValIN4123:= 0 
Local aLanc4123 := {}

Default lTitulo := .T.
Default aGnre   := {}
Default nOpc	:= 2
Default aFoment	:= {}
Default lGuiaRec:= .T.
Default lDelGNR		:= .F.
Default aGDGErada	:= {}
Default aCDADifal	:= {}
Default lAutomato := .F.
Default aEApCe6Ce5 := {}
Default lProcRefer := .F.

Static lRefaz := .F.

If File(cArqApur)
	dbSelectArea("CC6")
	dbSetOrder(01)
	dbSelectArea("CDH")
	dbSetOrder(01)
	If dbSeek(xFilial("CDH")+"IC"+cChave)
		cSomaSeq  := CDH->CDH_SEQUEN
		While dbSeek(xFilial("CDH")+"IC"+cChave+cSomaSeq) // Posiciona na ultima sequencia
			cSequen  := CDH->CDH_SEQUEN
			cSomaSeq := Soma1(cSequen)
		EndDo
		cChave   += cSequen
		cChaveIc := xFilial("CDH")+"IC"+cChave
		cChaveSt := xFilial("CDH")+"ST"+cChave
		cTitulo	:=	STR0038 //"Aten‡„o"
		cText1	:=	STR0084 //"Ja existe apuração para os parâmetros informados"
		cText2	:=	STR0085 //"Deseja refazer considerando a apuração anterior ?"
		If !lAutomato
			DEFINE MSDIALOG oDlgCheck TITLE OemtoAnsi(cTitulo) STYLE DS_MODALFRAME FROM  185,152 TO 295,465 PIXEL OF oMainWnd
			@ 05, 10 TO 33, 150 LABEL "" OF oDlgCheck  PIXEL
			@ 10, 15 SAY OemToAnsi(cText1) SIZE 125, 8 OF oDlgCheck PIXEL
			@ 20, 15 SAY OemToAnsi(cText2) SIZE 125, 8 OF oDlgCheck PIXEL
			DEFINE SBUTTON FROM 40, 052 TYPE 2 ACTION (nOpc:=1,oDlgCheck:End()) ENABLE OF oDlgCheck
			@ 40,083 BUTTON STR0041 SIZE 30,12 FONT oDlgCheck:oFont ACTION (nOpc:=2,oDlgCheck:End()) OF oDlgCheck PIXEL //"Refazer"
			@ 40,115 BUTTON STR0042 SIZE 30,12 FONT oDlgCheck:oFont ACTION (nOpc:=3,oDlgCheck:End()) OF oDlgCheck PIXEL //"Excluir"
			ACTIVATE MSDIALOG oDlgCheck
		EndIf

		If nOpc == 3 // Refazer sem considerar apuracao anterior

			//Ponto de entrada que recebe o retorno se deve bloquear a exclusão a apuração quando utilizar o PE- PROCAPUR
			If lProcApur
				lProcApRet :=  ExecBlock("PROCAPUR", .F., .F.,{nAno,nMes})

				If lProcApRet //Retornando True o reprocessamento deverá ser bloqueado.
					Return .F.
				EndIf
			EndIf

			dbSeek(cChaveIc)
			While !CDH->(EOF()) .And. CDH->CDH_FILIAL+CDH->CDH_TIPOIP+CDH->CDH_TIPOPR+CDH->CDH_PERIOD+DTOS(CDH->CDH_DTINI)+CDH->CDH_LIVRO+CDH->CDH_SEQUEN == cChaveIc
				If !Empty(CDH->CDH_NUMTIT)
		    		Aadd(aNrTit,CDH->CDH_NUMTIT)
				Elseif !Empty(CDH->CDH_GNRE)
		    		Aadd(aValidGuia,CDH->CDH_GNRE)
				Endif
				If CDH->CDH_LINHA == "GNR"
					AADD(aGnre,{CDH->CDH_GNRE,CTOD(""),CDH->CDH_VALOR,CDH->CDH_CLVENC,CDH->CDH_ESTGNR,"IC",IIF(aApurSX3[FP_CDH_GNREF3],CDH->CDH_GNREF3,"RECXXXXX"),CDH->CDH_DESC})
				EndIf
				CDH->(dbSkip())
			EndDo
			dbSeek(cChaveSt)
			While !CDH->(EOF()) .And. CDH->CDH_FILIAL+CDH->CDH_TIPOIP+CDH->CDH_TIPOPR+CDH->CDH_PERIOD+DTOS(CDH->CDH_DTINI)+CDH->CDH_LIVRO+CDH->CDH_SEQUEN == cChaveSt
				If !Empty(CDH->CDH_NUMTIT)
		    		Aadd(aNrTit,CDH->CDH_NUMTIT)
				Elseif !Empty(CDH->CDH_GNRE)
		    		Aadd(aValidGuia,CDH->CDH_GNRE)
				Endif
				If CDH->CDH_LINHA == "GNR"
					AADD(aGnre,{CDH->CDH_GNRE,CTOD(""),CDH->CDH_VALOR,CDH->CDH_CLVENC,CDH->CDH_ESTGNR,"IC",IIF(aApurSX3[FP_CDH_GNREF3],CDH->CDH_GNREF3,"RECXXXXX"),CDH->CDH_DESC})
				EndIf
				CDH->(dbSkip())
			EndDo

			If aApurSX2[AI_F0J]
				dbSelectArea("F0J")
				F0J->(DbSetOrder (3))			
				//F0J_FILIAL+DTOS(F0J_PER)+F0J_LIVRO
				IF F0J->(DbSeek (xFilial ("F0J")+dTos(dDtIni)+cNrLivro)) //Busca títulos do Difal gerados
					While !F0J->(EOF()) .AND. F0J->F0J_FILIAL+dtos(F0J->F0J_PER)+F0J->F0J_LIVRO == xFilial ("F0J")+dTos(dDtIni)+cNrLivro

						If F0J->F0J_TIPO $'1/2/3'
							AADD(aGnre,    {F0J->F0J_GNRE,CTOD(""),F0J->F0J_VALOR,'',F0J->F0J_UF,"",'',F0J->F0J_TIPO})
						ElseIf F0J->F0J_TIPO $'4/5/6'
							//Adiciona título						
							AADD(aNrTit,{F0J->F0J_PRFTIT,F0J->F0J_NUMTIT})
						EndIF
						
						F0J->(dbSkip())
					EndDo 
				EndIF
			EndIf

			If Len(aNrTit) > 0
				Aviso(STR0073,STR0074,{"OK"})	 //"Atencao"###'A apuracao nao podera ser excluida, pois existe um titulo gerado. Favor refazer a apuracao, utilizando a opcao de gerar titulo com "Nao"'
				lRet 	:= .f.
			ElseIf Len(aValidGuia) > 0  .And. !lDelGNR 
				Aviso(STR0073,'A apuracao nao podera ser excluida, pois existe uma GNRE gerada. Favor refazer a apuracao, utilizando a opcao de gerar GNRE com "Nao"',{"OK"})	 //"Atencao"###'A apuracao nao podera ser excluida, pois existe uma GNRE gerada. Favor refazer a apuracao, utilizando a opcao de gerar GNRE com "Nao"'
				lRet 	:= .f.						
			Else
				// apagar as Guias geradas anteriormente ao refazer a apuração de ICMS
				If lDelGNR .And. Len(aGnre)>0
					dbSelectArea("SF6")
					SF6->( DbSetOrder(1) )
					For nX := 1 to Len(aGnre)
						If SF6->(MsSeek( xFilial("SF6")+aGnre[nX][5]+aGnre[nX][1] ))
							RecLock("SF6",.F.)
							SF6->( DbDelete() )
							SF6->( MsUnlock() )
					    EndIf
					Next nX
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Apaga arquivo de apuracao        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				FT_FUse()
				If File(cArqApur)
					Ferase(cArqApur)
				EndIf
				cArqST := substr(cArqApur,1,Len(cArqApur)-3)+"ST"+substr(cArqApur,Len(cArqApur),1)
				If File(cArqST)
		        	Ferase(cArqST)
		        	lRet := .f.
		        Else
					lRet := .t. // Retorna T para fazer a apuracao sem considerar a anterior
				Endif

				//Apagar aqui as informações das tabela do DIFAL.
				If aApurSX2[AI_F0I]
					dbSelectArea("F0I")
					F0I->(DbSetOrder (2))
					IF F0I->(MsSeek (xFilial ("F0I")+dTos(dDtIni)+cNrLivro))
						Do While F0I->(!EOF()) .AND. F0I->(F0I_FILIAL+DTOS(F0I_PER)+F0I_LIVRO)== xFilial ("F0I")+dTos(dDtIni)+cNrLivro
							RecLock("F0I",.F.)
							dbDelete()
							MsUnlock()			
							F0I->(DbSkip())
						EndDo			
					
					EndIF
				EndIF

				If aApurSX2[AI_F0J]
					dbSelectArea("F0J")
					F0J->(DbSetOrder (2))
					//F0J_FILIAL+DTOS(F0J_PER)+F0J_LIVRO+F0J_UF+F0J_GNRE				
					IF F0J->(DbSeek (xFilial ("F0J")+dTos(dDtIni)+cNrLivro))
						Do While F0J->(!EOF()) .AND. F0J->(F0J_FILIAL+DTOS(F0J_PER)+F0J_LIVRO)== xFilial ("F0J")+dTos(dDtIni)+cNrLivro
							RecLock("F0J",.F.)
							dbDelete()
							MsUnlock()			
							F0J->(DbSkip())
						EndDo			
					EndIF
				EndIF
				
				If aApurSX2[AI_F0K]
					dbSelectArea("F0K")
					F0K->(DbSetOrder (1))
									
					IF F0K->(DbSeek (xFilial ("F0K")+dTos(dDtIni)+cNrLivro))
						Do While F0K->(!EOF()) .AND. F0K->(F0K_FILIAL+dTos(dDtIni)+F0K_LIVRO)== xFilial ("F0K")+dTos(dDtIni)+cNrLivro
							RecLock("F0K",.F.)
							dbDelete()
							MsUnlock()			
							F0K->(DbSkip())
						EndDo			
					EndIF
				EndIF
				
				If aApurSX2[AI_CDV]	.and. aApurSX3[FP_CDV_AUTO]
					dbSelectArea("CDV")
					CDV->(DbSetOrder(2))									
					If CDV->(dbSeek(xFilial("CDV")+cPeriodo+cNrLivro))						
						Do While CDV->(!EOF()) .AND. CDV->(CDV_FILIAL+CDV_PERIOD+CDV_LIVRO)== xFilial("CDV")+cPeriodo+cNrLivro
							If CDV->CDV_AUTO == "S"
								RecLock("CDV",.F.)
								dbDelete()
								MsUnlock()
							Endif			
						
							CDV->(DbSkip())
						EndDo									
					EndIf
				EndIf
				
				If aApurSX2[AI_F2R]	
					// Função para deletar a tabela F2R de crédito acumulado
					a953DelF2R(cPeriodo,cNrLivro)
				EndIf
			EndIf

		GerGuiTit(nOpc)	
		
		ElseIf nOpc==2 // Refazer considerando apuracao anterior
			lRefazApur := .T. //Ajusta variável estática indicadora de refaz processamento
			//Ponto de entrada que recebe o retorno se deve bloquear o reprocessamento.
			If lProcApur
				lProcApRet :=  ExecBlock("PROCAPUR", .F., .F.,{nAno,nMes})

				If lProcApRet //Retornando True o reprocessamento deverá ser bloqueado.
					Return .F.
				EndIf
			EndIf
			
			lRet := .t.
			lRefaz := .T.

			aLanc4123 := GetIn4123()
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega ajustes na apuracao ICMS ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
			dbSeek(cChaveIc)
			While !CDH->(EOF()) .And. CDH->CDH_FILIAL+CDH->CDH_TIPOIP+CDH->CDH_TIPOPR+CDH->CDH_PERIOD+DTOS(CDH->CDH_DTINI)+CDH->CDH_LIVRO+CDH->CDH_SEQUEN == cChaveIC
				
				cDesTpLanc	:= ''
				lLoadCDH	:= .T.
				lCdoInd		:= .F.
				IF lCdhTPLANC
					cDesTpLanc	:= CDH->CDH_TPLANC
				EndIF
				
				IF !Empty(CDH->CDH_CODLAN) .AND. lCdhTPLANC .AND. lCdoAgrupa
					lCdoInd	:= ChkGnreInd( Alltrim( CDH->CDH_CODLAN ) )
					
					If !lCdoInd .AND. Substring(CDH->CDH_TPLANC,1,2) == 'AI' 
						//Gravado individualizado na CDH, porém o cadastro está agrupado
						cDesTpLanc	:= ''
						lLoadCDH	:= .F. 
					ElseIF lCdoInd .AND. Substring(CDH->CDH_TPLANC,1,2) == 'A '
						//Gravado agrupado na CDH, porém no cadastro está individualizado
						cDesTpLanc	:= ''
						lLoadCDH	:= .F.
					ElseIF Substring(CDH->CDH_TPLANC,1,2) == 'AI'
						lLoadCDH	:= .F.
						//Pode carregar pois tanto na CDH quanto no cadastro estão individualizados ainda
						cDesTpLanc	:= a953TpLanc("A") + Substring(CDH->CDH_TPLANC,3,Len(CDH->CDH_TPLANC))
					ElseIF Substring(CDH->CDH_TPLANC,1,2) == 'A '
						lLoadCDH	:= .F.
						//Pode carregar pois tanto na CDH quanto no cadastro estão agrupados ainda
						cDesTpLanc	:= a953TpLanc("AG") + Substring(CDH->CDH_TPLANC,3,Len(CDH->CDH_TPLANC))
					ElseIF Substring(CDH->CDH_TPLANC,1,2) == 'CF'
						lLoadCDH	:= .F.
						//Pode carregar pois tanto na CDH quanto no cadastro estão agrupados ainda
						cDesTpLanc	:= a953TpLanc("CF") + Substring(CDH->CDH_TPLANC,3,Len(CDH->CDH_TPLANC))
					EndIF					
					
				EndIF
				                    
				If CDH->CDH_LINHA == "GNR"
					AADD(aGnre,{CDH->CDH_GNRE,CTOD(""),CDH->CDH_VALOR,CDH->CDH_CLVENC,CDH->CDH_ESTGNR,"IC",IIF(aApurSX3[FP_CDH_GNREF3],CDH->CDH_GNREF3,"RECXXXXX"),CDH->CDH_DESC})					
				ElseIf CDH->CDH_LINHA == "OBS"
					AADD(aDadIC,{"OBS",Alltrim(CDH->CDH_DESC)})
				ElseIf CDH->CDH_LINHA == "TIT" .And. !Empty(CDH->CDH_NUMTIT)
					Aadd(aNrTit,{CDH->CDH_PRETIT,CDH->CDH_NUMTIT,CDH->CDH_PARTIT,CDH->CDH_TPTIT,CDH->CDH_FORTIT,CDH->CDH_LOJTIT})
				ElseIf !Empty(CDH->CDH_CODLAN) .AND. lLoadCDH

					If (aApurSX2[AI_CDO] .And. CDO->(dbSeek(xFilial("CDO")+CDH->CDH_CODLAN))) .Or.;
						(aApurSX2[AI_CC6] .And. CC6->(dbSeek(xFilial("CC6")+CDH->CDH_CODLAN)))
											
						If lProcRefer					
							AADD(aDadIC,{CDH->CDH_LINHA,Alltrim(CDH->CDH_DESC),CDH->CDH_VALOR,CDH->CDH_SUBITE,CDH->CDH_GNRE,CDH->CDH_CLVENC,CDH->CDH_CODLAN,cDesTpLanc,CDH->CDH_PROCES,CDH->CDH_PROCTP,CDH->CDH_PROIND,CDH->CDH_ITPROC})
						Else
							AADD(aDadIC,{CDH->CDH_LINHA,Alltrim(CDH->CDH_DESC),CDH->CDH_VALOR,CDH->CDH_SUBITE,CDH->CDH_GNRE,CDH->CDH_CLVENC,CDH->CDH_CODLAN,cDesTpLanc})
						Endif
						
					EndIF
					
				EndIf
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Alimenta as variaveis VALOR utilizadas para realizar o LP 713 de estorno contabil ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	            If CDH->CDH_LINHA == "004" .And. CDH->CDH_TIPOIP == "IC"
	            	VALOR := CDH_VALOR
	            EndIf
	            
	            If CDH->CDH_LINHA == "010" .And. CDH->CDH_TIPOIP == "IC"
	            	VALOR2 := CDH_VALOR
	            EndIf

				If CDH->CDH_LINHA == "006" .And. CDH->CDH_TIPOIP == "IC" .And. aScan(aLanc4123, AllTrim(CDH->CDH_CODLAN)) > 0
	            	nValIN4123 += CDH->CDH_VALOR
	            EndIf
	            
				dbSkip()
			EndDo
	
			Begin Transaction
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Estorna lancamento contabil LP 713 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				LancCont("713","MATA953")

				VALOR      := nValIN4123
				nValIN4123 := 0
				LancCont("715","MATA953")
			End Transaction
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega ajustes na apuracao ICMS/ST ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		    dbSeek(cChaveSt)
		    While !CDH->(EOF()) .And. CDH->CDH_FILIAL+CDH->CDH_TIPOIP+CDH->CDH_TIPOPR+CDH->CDH_PERIOD+DTOS(CDH->CDH_DTINI)+CDH->CDH_LIVRO+CDH->CDH_SEQUEN == cChaveST
								
				cDesTpLanc	:= ''
				lLoadCDH	:= .T.
				lCdoInd		:= .F.
				IF lCdhTPLANC
					cDesTpLanc	:= CDH->CDH_TPLANC
				EndIF
				
				IF !Empty(CDH->CDH_CODLAN) .AND. lCdhTPLANC .AND. lCdoAgrupa
					lCdoInd	:= ChkGnreInd( Alltrim( CDH->CDH_CODLAN ) )
					
					If !lCdoInd .AND. Substring(CDH->CDH_TPLANC,1,2) == 'AI' 
						//Gravado individualizado na CDH, porém o cadastro está agrupado
						cDesTpLanc	:= ''
						lLoadCDH	:= .F. 
					ElseIF lCdoInd .AND. Substring(CDH->CDH_TPLANC,1,2) == 'A '
						//Gravado agrupado na CDH, porém no cadastro está individualizado
						cDesTpLanc	:= ''
						lLoadCDH	:= .F.
					ElseIF Substring(CDH->CDH_TPLANC,1,2) == 'AI'
						lLoadCDH	:= .F.
						//Pode carregar pois tanto na CDH quanto no cadastro estão individualizados ainda
						cDesTpLanc	:= a953TpLanc("A") + Substring(CDH->CDH_TPLANC,3,Len(CDH->CDH_TPLANC))
					ElseIF Substring(CDH->CDH_TPLANC,1,2) == 'A '
						lLoadCDH	:= .F.
						//Pode carregar pois tanto na CDH quanto no cadastro estão agrupados ainda
						cDesTpLanc	:= a953TpLanc("AG") + Substring(CDH->CDH_TPLANC,3,Len(CDH->CDH_TPLANC))
					ElseIF Substring(CDH->CDH_TPLANC,1,2) == 'CF'
						lLoadCDH	:= .F.
						//Pode carregar pois tanto na CDH quanto no cadastro estão agrupados ainda
						cDesTpLanc	:= a953TpLanc("CF") + Substring(CDH->CDH_TPLANC,3,Len(CDH->CDH_TPLANC))
					EndIF	
				EndIF
				
				If CDH->CDH_LINHA == "GNR"
					AADD(aGnre,{CDH->CDH_GNRE,CTOD(""),CDH->CDH_VALOR,CDH->CDH_CLVENC,CDH->CDH_ESTGNR,"IC",IIF(aApurSX3[FP_CDH_GNREF3],CDH->CDH_GNREF3,"RECXXXXX"),CDH->CDH_DESC})
				ElseIf !Empty(CDH->CDH_CODLAN)	.AND. lLoadCDH				 
					If (aApurSX2[AI_CDO] .And. CDO->(dbSeek(xFilial("CDO")+CDH->CDH_CODLAN))) .Or.;
						(aApurSX2[AI_CC6] .And. CC6->(dbSeek(xFilial("CC6")+CDH->CDH_CODLAN)))						
					
						If lProcRefer
							AADD(aDadST,{CDH->CDH_LINHA,Alltrim(CDH->CDH_DESC),CDH->CDH_VALOR,CDH->CDH_SUBITE,CDH->CDH_GNRE,CDH->CDH_CLVENC,CDH->CDH_CODLAN,cDesTpLanc,CDH->CDH_PROCES,CDH->CDH_PROCTP,CDH->CDH_PROIND,CDH->CDH_ITPROC})
						Else
							AADD(aDadST,{CDH->CDH_LINHA,Alltrim(CDH->CDH_DESC),CDH->CDH_VALOR,CDH->CDH_SUBITE,CDH->CDH_GNRE,CDH->CDH_CLVENC,CDH->CDH_CODLAN,cDesTpLanc})
						EndIf						
					Endif	
								    
				ElseIf !Empty(CDH->CDH_NUMTIT)
					Aadd(aNrTit,{CDH->CDH_PRETIT,CDH->CDH_NUMTIT,CDH->CDH_PARTIT,CDH->CDH_TPTIT,CDH->CDH_FORTIT,CDH->CDH_LOJTIT})
				EndIf
				dbSkip()
		    EndDo

			// Busca a extra apuração
			fGExtrApur(cPeriodo,@aEApCe6Ce5)

			// Deleta a extra apuração
			a953DelEAp(dDtIni)

			// Busca o Crédito gerado no mês
			a953CrdApP(.T.,cPeriodo,cNrLivro,@aCoCredAcu)

			//Delete Credito acumulado
			a953DelF2R(cPeriodo,cNrLivro)

		    //-------------------------------------------------
		    //CARREGA GNRE GERADA PARA O DIFAL E PARA O FECP
		    //-------------------------------------------------
			If aApurSX2[AI_F0J]
				dbSelectArea("F0J")
				F0J->(DbSetOrder (3))			
				//F0J_FILIAL+DTOS(F0J_PER)+F0J_LIVRO
				IF F0J->(DbSeek (xFilial ("F0J")+dTos(dDtIni)+cNrLivro)) //Busca títulos do Difal gerados
					While !F0J->(EOF()) .AND. F0J->F0J_FILIAL+dtos(F0J->F0J_PER)+F0J->F0J_LIVRO == xFilial ("F0J")+dTos(dDtIni)+cNrLivro

						If F0J->F0J_TIPO $'1/2/3'
							AADD(aGnre,    {F0J->F0J_GNRE,CTOD(""),F0J->F0J_VALOR,'',F0J->F0J_UF,"",'',F0J->F0J_TIPO})
						ElseIf F0J->F0J_TIPO $'4/5/6'
							//Adiciona título						
							AADD(aNrTit,{F0J->F0J_PRFTIT,F0J->F0J_NUMTIT,F0J->F0J_PARC,F0J->F0J_TPTIT,F0J->F0J_FORN,F0J->F0J_LOJA})
						EndIF
						
						F0J->(dbSkip())
					EndDo 
				EndIF
			EndIF

		    //-------------------------------------------------
		    //CARREGA AJUSTES DE APURAÇÃO LANÇADOS MANUALMENTE
		    //-------------------------------------------------
			If aApurSX2[AI_F0K]
				dbSelectArea("F0K")
				F0K->(DbSetOrder (1))			
				//F0K_FILIAL+DTOS(F0K_PER)+F0K_LIVRO+F0K_UF+F0K_CODAPU+F0K_DESCR
				IF F0K->(DbSeek (xFilial ("F0K")+dTos(dDtIni)+cNrLivro)) //Busca títulos do Difal gerados
					While !F0K->(EOF()) .AND. F0K->F0K_FILIAL+dtos(F0K->F0K_PER)+F0K->F0K_LIVRO == xFilial ("F0K")+dTos(dDtIni)+cNrLivro
						//F0K_FILIAL+DTOS(F0K_PER)+F0K_LIVRO+F0K_UF+F0K_CODAPU+F0K_TPLANC+F0K_DESCR
						//Somente carrega ajustes manuais
						IF SubStr(F0K->F0K_TPLANC,1,1) == '2'
							IF SubStr(F0K->F0K_CODAPU,3,1) == "3"
								Do Case
									Case SubStr(F0K->F0K_CODAPU,4,1) == "0";cReflex := "014"
									Case SubStr(F0K->F0K_CODAPU,4,1) == "1";cReflex := "015"
									Case SubStr(F0K->F0K_CODAPU,4,1) == "2";cReflex := "018"
									Case SubStr(F0K->F0K_CODAPU,4,1) == "3";cReflex := "019"
									Case SubStr(F0K->F0K_CODAPU,4,1) == "4";cReflex := "021"
									Case SubStr(F0K->F0K_CODAPU,4,1) == "5";cReflex := "024"
								EndCase
							Else
								Do Case
									Case SubStr(F0K->F0K_CODAPU,4,1) == "0";cReflex := "002"
									Case SubStr(F0K->F0K_CODAPU,4,1) == "1";cReflex := "003"
									Case SubStr(F0K->F0K_CODAPU,4,1) == "2";cReflex := "006"
									Case SubStr(F0K->F0K_CODAPU,4,1) == "3";cReflex := "007"
									Case SubStr(F0K->F0K_CODAPU,4,1) == "4";cReflex := "009"
									Case SubStr(F0K->F0K_CODAPU,4,1) == "5";cReflex := "012"
								EndCase
							Endif
						
							If lProcRefer					
								AADD(aCDADifal,{cReflex,F0K->F0K_DESCR,F0K->F0K_VALOR,F0K->F0K_CODAPU,F0K->F0K_GNRE,F0K->F0K_UF,F0K->F0K_TPLANC,F0K->F0K_SUBITE, .F., '','','', F0K->F0K_PROCES,F0K->F0K_PROCTP,F0K->F0K_PROIND,F0K->F0K_ITPROC}) //Adicionado posicao 8 de aCDAIC para flag de ajuste manual					
							Else
								AADD(aCDADifal,{cReflex,F0K->F0K_DESCR,F0K->F0K_VALOR,F0K->F0K_CODAPU,F0K->F0K_GNRE,F0K->F0K_UF,F0K->F0K_TPLANC,F0K->F0K_SUBITE, .F., '','',''}) //Adicionado posicao 8 de aCDAIC para flag de ajuste manual					
							Endif
						EndIf

						F0K->(dbSkip())
					EndDo 
				EndIF
				aCDADifal := Asort(aCDADifal,,,{|x,y|x[6]+x[4]+x[7]<y[6]+y[4]+y[7]})
			EndIF
		    
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Funcao que verifica se existem titulos gerados pela apuracao de ICMS   ³
			//³com prefixo vazio, neste caso alimenta o array aNrTit para que os      ³
			//³mesmos sejam excluidos!                                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			FTitPreVaz(@aNrTit,dDtIni,dDtFim,nApuracao,nPeriodo)
			
			If Len(aNrTit) > 0

				dbSelectArea("SE2")
				dbSetOrder(01)	

				For nX := 1 to Len(aNrTit)  
				
						
						lFindSE2 := .F.

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Titulo gerados pela funcao FTitPreVaz() ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If Len(aNrTit[nX]) > 2
							If dbSeek(xFilial()+aNrTit[nX][1]+aNrTit[nX][2]+aNrTit[nX][3]+aNrTit[nX][4]+aNrTit[nX][5]+aNrTit[nX][6],.F.)
								lFindSE2 := .T.
							EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Titulos gerado conforme While na tabela CDH³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ				
						Else
							If dbSeek(xFilial()+aNrTit[nX][1]+aNrTit[nX][2],.F.)
								lFindSE2 := .T.
							EndIf
						EndIf 
						If !FaCanDelCP("SE2", cProgram)
							lRet 	 := .F.
							cNrTitBx += " " + E2_NUM+"-"+E2_PREFIXO
						EndIf
				Next	
	
				For nX := 1 to Len(aNrTit) 
					lFindSE2 := .F.
					
					If Len(aNrTit[nX]) > 2
						If dbSeek(xFilial()+aNrTit[nX][1]+aNrTit[nX][2]+aNrTit[nX][3]+aNrTit[nX][4]+aNrTit[nX][5]+aNrTit[nX][6],.F.)
									lFindSE2 := .T.
						EndIf			
					Else
						If dbSeek(xFilial()+aNrTit[nX][1]+aNrTit[nX][2],.F.)
							lFindSE2 := .T.
						EndIf
					EndIf 
					If lRet .and. lFindSE2 
						PcoIniLan('000250')
						Begin Transaction
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Estorna lancamento contabil      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						LancCont(cLcPadExt,cProgram)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Estorna lancamento PCO           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						PcoDetLan('000250',"01","MATA953",.T.)
						PcoDetLan('000250',"02","MATA953",.T.)
						PcoDetLan('000250',"03","MATA953",.T.)
						PcoDetLan('000250',"04","MATA953",.T.)
	
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Excluir titulo gerado            ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						FaAvalSE2(2)
						FaAvalSE2(3)
						dbSelectArea("SE2")
						If aFindFunc[FF_FINGRVEX]
							FinGrvEx("P") // Gravar o histórico.
						EndIf			
						RecLock("SE2",.f.,.t.)
						dbDelete()
						End Transaction
						PcoFinLan('000250')
					Endif		
				Next
										
				If !lRet		
					If !lTitulo .And. lRefApur //Permite refazer a apuracao mesmo com o titulo baixado
						
						lRet 	:= .T.
					Else
						If !lAutomato						
							DEFINE MSDIALOG oDlgTit TITLE OemtoAnsi(STR0038) FROM  180,155 TO 310,480 PIXEL OF oMainWnd //"Aten‡„o"
							@ 03, 15 TO 39, 150 LABEL "" OF oDlgTit  PIXEL
		                	@ 10, 20 SAY OemToAnsi(STR0043+cNrTitBx+STR0044)  SIZE 128, 8 OF oDlgTit PIXEL //"T¡tulo "###" j  foi baixado ou existe cheque(s)"
		                	@ 20, 20 SAY OemToAnsi(STR0045)                   SIZE 128, 8 OF oDlgTit PIXEL //"gerado(s), para refazer a apura‡„o, a baixa deste"
		                	@ 30, 20 SAY OemToAnsi(STR0046)                       SIZE 128, 8 OF oDlgTit PIXEL //"t¡tulo e/ou cheque(s) dever„o ser cancelados."
		                	@ 46, 60 BUTTON STR0047 SIZE 40,12 FONT oDlgTit:oFont ACTION (nOpc:=1,oDlgTit:End()) OF oDlgTit PIXEL //"Abandona"
							ACTIVATE MSDIALOG oDlgTit
						Else
							nOpc := 1	
						EndIF
					Endif
				Endif
			EndIf
			If File(cArqApur)
				FT_FUse(cArqApur)
				FT_FGotop()
				While ( !FT_FEof() )
					cLinha  := FT_FREADLN()
					ctext     :=  LTrim(Substr(cLinha,4,If(Substr(cLinha,1,3)=="OBS" .Or. Substr(cLinha,1,3)=="FOM" , Len(cLinha)-3,50)))
		
					If Substr(cLinha,1,3)=="FOM" //Fomentar - GO  
						AADD(aFoment,{"FOM",ctext}) 
					EndIf
					FT_FSkip()
				EndDo
				FT_FUse() 
			Endif  		
			If nOpc==2 .And. lRet
				// apagar as Guias geradas anteriormente ao refazer a apuração de ICMS
				If lDelGNR .And. Len(aGnre)>0
					dbSelectArea("SF6")
					SF6->( DbSetOrder(1) )
					For nX := 1 to Len(aGnre)
						If SF6->(MsSeek( xFilial("SF6")+aGnre[nX][5]+aGnre[nX][1] ))
							RecLock("SF6",.F.)
								SF6->(DbDelete())
							SF6->(MsUnlock())
					    EndIf
					Next nX
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Apaga arquivo de apuracao        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If File(cArqApur)
					Ferase(cArqApur)
				EndIf
				cArqST := substr(cArqApur,1,Len(cArqApur)-3)+"ST"+substr(cArqApur,Len(cArqApur),1)
				If File(cArqST)
		        	Ferase(cArqST)
				Endif

				//Apagar aqui as informações das tabela do DIFAL.
				If aApurSX2[AI_F0I]
					dbSelectArea("F0I")
					F0I->(DbSetOrder (2))
					IF F0I->(DbSeek (xFilial ("F0I")+dTos(dDtIni)+cNrLivro))
						Do While F0I->(!EOF()) .AND. F0I->(F0I_FILIAL+DTOS(F0I_PER)+F0I_LIVRO)== xFilial ("F0I")+dTos(dDtIni)+cNrLivro
							RecLock("F0I",.F.)
								F0I->(dbDelete())
							F0I->(MsUnlock())	
							F0I->(DbSkip())
						EndDo			
					
					EndIF
				EndIF

				If aApurSX2[AI_F0J]
					dbSelectArea("F0J")
					F0J->(DbSetOrder (2))
					//F0J_FILIAL+DTOS(F0J_PER)+F0J_LIVRO+F0J_UF+F0J_GNRE				
					IF F0J->(DbSeek (xFilial ("F0J")+dTos(dDtIni)+cNrLivro))
						Do While F0J->(!EOF()) .AND. F0J->(F0J_FILIAL+DTOS(F0J_PER)+F0J_LIVRO)== xFilial ("F0J")+dTos(dDtIni)+cNrLivro
							RecLock("F0J",.F.)
								F0J->(dbDelete())
							F0J->(MsUnlock())
							F0J->(DbSkip())
						EndDo			
					EndIF
				EndIF

				If aApurSX2[AI_F0K]
					dbSelectArea("F0K")
					F0K->(DbSetOrder (1))
									
					IF F0K->(DbSeek (xFilial ("F0K")+dTos(dDtIni)+cNrLivro))
						Do While F0K->(!EOF()) .AND. F0K->(F0K_FILIAL+dTos(dDtIni)+F0K_LIVRO)== xFilial ("F0K")+dTos(dDtIni)+cNrLivro
							RecLock("F0K",.F.)
							cChvDIFAL	:=	F0K->F0K_FILIAL		+	;
											DTOS(F0K->F0K_PER)	+	;
											F0K->F0K_LIVRO		+	;
											F0K->F0K_UF			+	;
											F0K->F0K_CODAPU		+	;
											F0K->F0K_TPLANC		+	;
											F0K->F0K_DESCR
							If ASCAN(aDIFALDel, {|aVal| aVal[01] == cChvDIFAL}) == 0
								AADD(aDIFALDel , {cChvDIFAL, 	F0K->F0K_PROCES	,	;
																F0K->F0K_PROCTP	,	;
																F0K->F0K_PROIND	,	;
																F0K->F0K_ITPROC})
							EndIf
							cChvDIFAL := ''
								F0K->(dbDelete())
							F0K->(MsUnlock())
							F0K->(DbSkip())
						EndDo			
					EndIF
				EndIF
				
				If aApurSX2[AI_CDV] .and. aApurSX3[FP_CDV_AUTO]
					dbSelectArea("CDV")
					CDV->(DbSetOrder(2))									
					If CDV->(dbSeek(xFilial("CDV")+cPeriodo+cNrLivro))						
						Do While CDV->(!EOF()) .AND. CDV->(CDV_FILIAL+CDV_PERIOD+CDV_LIVRO)== xFilial("CDV")+cPeriodo+cNrLivro						
							If	CDV->CDV_AUTO	==	"S"
								RecLock("CDV",.F.)
									CDV->(dbDelete())
								CDV->(MsUnlock())
							Endif							
							CDV->(DbSkip())
						EndDo						
					EndIF
				EndIF
			Else
				lRet := .f.
			Endif
		Else
			lRet 	:= .f.
		Endif
	EndIf
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³AntIcms   ³ Autor ³Andressa Fagundes      ³ Data ³25.04.2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o valor da Antecipacao de ICMS no mes subsequente   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpD1: Data Inicial                                         ³±±
±±³          ³ExpD2: Data Final                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function AntIcms(dDtIni,dDtFim)

Local aArea		:= GetArea()
Local cAliasSF3 :=	"SF3"
Local cIndSF3   :=	""

#IFDEF TOP
	Local aStruSF3	:=	{}
	Local cQuery	:=	""
	Local nX		:=	0
#ELSE
	Local cIndex    :=	""
	Local cFiltro 	:=	""
#ENDIF

Local nValAnti := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processo o mes anterior da apuracao 			 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dDtFim := dDtIni-1
dDtIni := FirstDay(dDtFim)

dbSelectArea("SF3")
SF3->(dbsetorder(1))

	#IFDEF TOP  
		If TcSrvType()<>"AS/400"
		    cAliasSF3 	:= "AliasSF3"
			aStruSF3  	:= SF3->(dbStruct())
			cQuery 	:= "SELECT SUM(F3_VALANTI) F3_VALANTI "
			cQuery 	+= "FROM " + RetSqlName("SF3") + " "
			cQuery 	+= "WHERE F3_FILIAL = '" + xFilial("SF3") + "' AND "
			cQuery 	+= "F3_ENTRADA >= '" + Dtos(dDtIni) + "' AND "
			cQuery 	+= "F3_ENTRADA <= '" + Dtos(dDtFim) + "' AND "                   
			cQuery 	+= "F3_VALANTI > 0 AND "
			cQuery	+= "F3_DTCANC = '" + Dtos(Ctod("")) + "' AND "
			cQuery 	+= "D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSF3,.T.,.T.)
			
			For nX := 1 To len(aStruSF3)
				If aStruSF3[nX][2] <> "C"  .And. FieldPos(aStruSF3[nX][1])<>0
					TcSetField(cAliasSF3,aStruSF3[nX][1],aStruSF3[nX][2],aStruSF3[nX][3],aStruSF3[nX][4])
				EndIf
			Next nX     

			dbSelectArea(cAliasSF3)	
		Else	
	#ENDIF
			cIndex  := CriaTrab(NIL,.F.)
			cFiltro	:=	"SF3->F3_FILIAL == '" + xFilial("SF3") + "' .And. DTOS(SF3->F3_ENTRADA) >= '" + Dtos(dDtIni) + "' .AND. DTOS(SF3->F3_ENTRADA) <= '" + Dtos(dDtFim) + "'"
			cFiltro	+=  " .And. SF3->F3_VALANTI > 0 .And. DTOS(SF3->F3_DTCANC) == '" + Dtos(Ctod("")) + "'"
			IndRegua(cAliasSF3,cIndex,SF3->(IndexKey()),,cFiltro)
			dbSelectArea(cAliasSF3)
			dbGoTop()
	#IFDEF TOP
		Endif
	#ENDIF

	cIndSF3	:=	CriaTrab(NIL,.F.)
		
	While !(cAliasSF3)->(Eof())
	
		nValAnti	+= (cAliasSF3)->F3_VALANTI

        (cAliasSF3)->(dbSkip())
	Enddo

	#IFDEF TOP
		dbSelectArea(cAliasSF3)
		dbCloseArea()
	#ELSE
		dbSelectArea(cAliasSF3)
		RetIndex(cAliasSF3)
		Ferase(cIndSF3+OrdBagExt())
	#ENDIF

	RestArea(aArea)
	
Return nValAnti    

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ValMedProd³ Autor ³Andressa Fagundes      ³ Data ³09.03.2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o Valor Medio da Materia Prima Adquirida            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cProd:Codigo do Produto                                     ³±±
±±³          ³dDtIni:Data Inicial da Apuracao                             ³±±
±±³          ³dDtFim:Data Final da Apuracao                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValMedProd(cProd,dDtIni,dDtFim)

Local aArea		:= GetArea()
Local cAliasSd1 :=	"SD1"
Local cIndSD1   :=	""
Local nMesMed   := GetNewPar("MV_DIAMED",1) //Identifica a quantidade de dias para calculo do preco medio do produto.
Local nVlTot    := 0
Local nQtde		:= 0
Local nValMed   := 0
Local lQuery	:= .F.

#IFDEF TOP
	Local aStruSD1	:=	{}
	Local cQuery	:=	""
	Local nX		:=	0
#ELSE
	Local cIndex    :=	""
	Local cFiltro 	:=	""
#ENDIF

dDtIni := dDtFim-nMesMed

//Selecionando as materias primas adquiridas conforme periodo informado no parametro
dbSelectArea("SD1") 
SD1->(dbsetorder(1))

	#IFDEF TOP

		lQuery	:= .F.	
		
		If TcSrvType()<>"AS/400"
		    cAliasSD1 	:= "AliasSD1"
			aStruSD1  	:= SD1->(dbStruct())
			cQuery 	:= "SELECT SD1.D1_TOTAL, SD1.D1_VALFRE, SD1.D1_SEGURO, SD1.D1_DESPESA, SD1.D1_VALDESC, "
			cQuery 	+= "SD1.D1_QUANT, SD1.D1_COD, SD1.D1_TES, "
			cQuery 	+= "SB1.B1_COD "
		    cQuery  += "FROM "+RetSqlName("SD1")+" SD1, "
	    	cQuery  += RetSqlName("SB1")+" SB1 "
			cQuery 	+= "WHERE SD1.D1_FILIAL = '" + xFilial("SD1") + "' AND "
		    cQuery  += "SD1.D1_COD=SB1.B1_COD AND "
			cQuery 	+= "SD1.D1_EMISSAO >= '" + Dtos(dDtIni) + "' AND "
			cQuery 	+= "SD1.D1_EMISSAO <= '" + Dtos(dDtFim) + "' AND " 
			cQuery 	+= "SD1.D1_COD = '" + (cProd) + "' AND "
			cQuery 	+= "SB1.B1_ESCRIPI='1' AND "
			cQuery 	+= "SB1.D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD1,.T.,.T.)
			
			For nX := 1 To len(aStruSD1)
				If aStruSD1[nX][2] <> "C" .And. FieldPos(aStruSD1[nX][1])<>0
					TcSetField(cAliasSD1,aStruSD1[nX][1],aStruSD1[nX][2],aStruSD1[nX][3],aStruSD1[nX][4])
				EndIf
			Next nX

			dbSelectArea(cAliasSD1)	
		Else	
	#ENDIF
			cIndex  := CriaTrab(NIL,.F.)
			cFiltro	:=	"SD1->D1_FILIAL == '" + xFilial("SD1") + "' .And. DTOS(SD1->D1_EMISSAO) >= '" + Dtos(dDtIni) + "' .AND. DTOS(SD1->D1_EMISSAO) <= '" + Dtos(dDtFim) + "' .And. SD1->D1_COD=='" + (cProd) + "'"
			IndRegua(cAliasSD1,cIndex,SD1->(IndexKey()),,cFiltro)
			dbSelectArea(cAliasSD1)
			dbGoTop()
	#IFDEF TOP
		Endif
	#ENDIF

	cIndSD1	:=	CriaTrab(NIL,.F.)
		
	While !(cAliasSD1)->(Eof()) //Tem que ser feito por produto --> por materia prima
		If !lQuery
			SB1->(dbSetOrder(1))
			If !(SB1->(DbSeek(xFilial("SB1")+(cAliasSD1)->D1_COD)))
				(cAliasSD1)->(DbSkip())
				Loop                                          
			Endif
			// Materia-Prima
			If SB1->B1_ESCRIPI <> "1"
				(cAliasSD1)->(DbSkip())
				Loop
			EndIf              
		Endif	
	
		dbSelectArea("SF4")
		dbSetOrder(1)
		If DbSeek(xFilial("SF4")+(cAliasSD1)->D1_TES)
           	If SF4->F4_LFIPI =="T" //Entradas tributadas
				nVlTot	+= ((cAliasSD1)->D1_TOTAL+(cAliasSD1)->D1_VALFRE+(cAliasSD1)->D1_SEGURO+(cAliasSD1)->D1_DESPESA)-(cAliasSD1)->D1_VALDESC
				nQtde	+= (cAliasSD1)->D1_QUANT
			Endif	
		Endif
		
        (cAliasSD1)->(dbSkip())

		nValMed := Round(nVlTot/nQtde,2)
        
	Enddo

	#IFDEF TOP
		dbSelectArea(cAliasSD1)
		dbCloseArea()
	#ELSE
		dbSelectArea(cAliasSD1)
		RetIndex(cAliasSD1)
		Ferase(cIndSD1+OrdBagExt())
	#ENDIF

	RestArea(aArea)

Return(nValMed)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³QtdProdVen³ Autor ³Andressa Fagundes      ³ Data ³09.03.2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a quantidade de produtos devolvidos no mes da      ³±±
±±³          ³ apuracao do IPI. - Produto Acabado                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cProd:Codigo do Produto                                     ³±±
±±³          ³dDtIni:Data Inicial da Apuracao                             ³±±
±±³          ³dDtFim:Data Final da Apuracao                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/ 
Function QtdProDev(cProd,dDtIni,dDtFim)

Local aArqF1		:= {"SF1",""}
Local cDbfF1		:= ""
Local cTopF1		:= ""
Local nQtdDevol		:= 0


//Seleciona as devolucoes dos produtos acabados
cDbfF1	:= "F1_FILIAL=='"+xFilial("SF1")+"' .AND. DTOS(F1_DTDIGIT)>='"+Dtos(dDtIni)+"' .AND. DTOS(F1_DTDIGIT)<='"+Dtos(dDtFim)+"' .AND. F1_TIPO=='D'"
cTopF1	:= "F1_FILIAL='"+xFilial("SF1")+"' AND F1_DTDIGIT>='"+Dtos(dDtIni)+"' AND F1_DTDIGIT<='"+Dtos(dDtFim)+"' AND F1_TIPO='D'"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Processa Notas Fiscais de Saida - Devolvidas      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SF1")
dbSetOrder(1)
FsQuery(aArqF1,1,cTopF1,cDbfF1,SF1->(IndexKey()))
dbGoTop()

While SF1->(!Eof())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Quantidade de Produto(P.A) Devolvidos  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SD1->(dbSetOrder(1))
	If !SD1->(dbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
		SF1->(dbSkip())
		Loop
	Endif

	Do While !SD1->(Eof()) .And. ;
  		xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA	== ;
   		SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA .And. ;
   		SD1->D1_COD = cProd
   		
   		//Posicionar no TES cujo livro de IPI tem quer ser isento ou outros pois trata-se de uma devolucao
		dbSelectArea("SF4")
		dbSetOrder(1)
		If dbSeek(xFilial("SF4")+SD1->D1_TES)
           	If SF4->F4_LFIPI$"IO" //Entradas Isento ou Outros - Devolucao
			   	nQtdDevol 	+= SD1->D1_QUANT
       		Endif
        Endif
        
   		SD1->(dbSkip()) 
	Enddo

	SF1->(dbSkip())
Enddo
	
FsQuery(aArqF1,2)

Return(nQtdDevol)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³EstCredIPI³ Autor ³Andressa Fagundes      ³ Data ³05.03.2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o valor que devera ser estornado referente o credito³±±
±±³          ³ de IPI.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³dDtIni:Data Inicial da Apuracao                             ³±±
±±³          ³dDtFim:Data Final da Apuracao                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function EstCredIPI(dDtIni,dDtFim)

Local aArea		:= GetArea()
Local cAliasSD1 := "SD1"
Local cAliasSD2 := "SD2"
Local cAliasSB1 := "SB1"
Local cChaveAnt := ""
Local nQtdDevol := 0
Local nQtdVend  := 0
Local nMatPrima := 0
Local nCalcMed  := 0
Local nEsCrIPI  := 0
Local nDvCrIPI  := 0
Local nAliqMp   := 0
Local nQB       := 0
Local nCalc     := 0
Local lQuery    := .F.
Local aRetIPI   := {}

#IFDEF TOP
	Local aStruSD2  := {}
	Local aStruSF4  := {}
	Local aStruSB1  := {}
	Local cQuery    := ""
	Local nX        := 0
#ELSE
	Local cIndSD2   := ""
	Local cFiltro   := ""
#ENDIF

dbSelectArea("SD2")
SD2->(dbsetorder(1))

//Posicionar no SG1
dbSelectArea("SG1")
dbSetOrder(1)

#IFDEF TOP

	If TcSrvType()<>"AS/400"
		lQuery    := .T.
		cAliasSD2 := "AliasSD2"
		cAliasSB1 := "AliasSD2"
		aStruSD2  := SD2->(dbStruct())
		aStruSF4  := SF4->(dbStruct())
		aStruSB1  := SB1->(dbStruct())
		cQuery := "SELECT SUM(D2_QUANT) D2_QUANT, SUM(D2_TOTAL) D2_TOTAL, D2_TES, "
		cQuery += "D2_DOC, D2_SERIE, D2_EMISSAO, D2_NFORI, D2_SERIORI, "
		cQuery += "B1_COD, B1_QB, B1_IPI, B1_ESCRIPI, F4_IPI  "
		cQuery += "FROM "+RetSqlName("SD2")+" SD2, "
		cQuery += RetSqlName("SF4")+" SF4, "	
		cQuery += RetSqlName("SB1")+" SB1 "
		cQuery += "WHERE D2_FILIAL = '" + xFilial("SD2") + "' AND "
		cQuery += "SD2.D2_EMISSAO >= '" + Dtos(dDtIni) + "' AND " // Data da apuracao do IPI
		cQuery += "SD2.D2_EMISSAO <= '" + Dtos(dDtFim) + "' AND "   
		cQuery += "SD2.D_E_L_E_T_ = ' ' AND "
		cQuery += "F4_FILIAL = '"+xFilial("SF4")+"' AND "
		cQuery += "F4_LFIPI IN ('O','I') AND " // Somente livro IPI Isento ou Outros
		cQuery += "SF4.F4_CODIGO = SD2.D2_TES AND "
		cQuery += "SF4.D_E_L_E_T_ = ' ' AND "
		cQuery += "B1_FILIAL = '"+xFilial("SB1")+"' AND "
		cQuery += "B1_COD = D2_COD AND "
		cQuery += "SB1.B1_ESCRIPI IN ('1','2') AND " // 1=Materia-Prima / 2=Produto Acabado
		cQuery += "SB1.D_E_L_E_T_ = ' ' "
		cQuery += "GROUP BY B1_COD, B1_QB, B1_IPI, B1_ESCRIPI, D2_TES, D2_DOC, D2_SERIE, D2_EMISSAO, D2_NFORI, D2_SERIORI, F4_IPI "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD2,.T.,.T.)
		For nX := 1 To len(aStruSD2)
			If aStruSD2[nX][2] <> "C" .And. FieldPos(aStruSD2[nX][1])<>0
				TcSetField(cAliasSD2,aStruSD2[nX][1],aStruSD2[nX][2],aStruSD2[nX][3],aStruSD2[nX][4])
			EndIf
		Next nX
		dbSelectArea(cAliasSD2)	
	Else	
#ENDIF
		cIndSD2 := CriaTrab(NIL,.F.)
		cFiltro := "SD2->D2_FILIAL == '" + xFilial("SD2") + "' .And. DTOS(SD2->D2_EMISSAO) >= '" + Dtos(dDtIni) + "' .AND. DTOS(SD2->D2_EMISSAO) <= '" + Dtos(dDtFim) + "'"
		IndRegua(cAliasSD2,cIndSD2,SD2->(IndexKey()),,cFiltro)
		dbSelectArea(cAliasSD2)
		dbGoTop()
#IFDEF TOP
	Endif
#ENDIF
	While (cAliasSD2)->(!Eof())
	If !lQuery
		//Produto
		SB1->(dbSetOrder(1))
		If !(SB1->(DbSeek(xFilial("SB1")+(cAliasSD2)->D2_COD)))
			(cAliasSD2)->(DbSkip())
			Loop
		Endif
		If !SB1->B1_ESCRIPI $ "12" // 1=Materia-Prima / 2=Produto Acabado
			(cAliasSD1)->(DbSkip())
			Loop
		EndIf
		//Tes
		SF4->(dbSetOrder(1))
		If !(SF4->(DbSeek(xFilial("SF4")+(cAliasSD2)->D2_TES)))
			(cAliasSD2)->(DbSkip())
			Loop
		Endif
		If !(SF4->F4_LFIPI $"OI") // Somente Livro IPI Isento ou Outros
			(cAliasSD1)->(DbSkip())
			Loop
		EndIf
	EndIf
	If (cAliasSB1)->B1_ESCRIPI == "1" // Materia-Prima
		If (cAliasSD2)->F4_IPI == "R" //TES = Calcula IPI = R-Com.Nao Atac
			nDvCrIPI += Round((((cAliasSD2)->D2_TOTAL)/2*(cAliasSB1)->B1_IPI/100),2)//Aliquota IPI da Materia-Prima 50%
		EndIf
	ElseIf (cAliasSB1)->B1_ESCRIPI == "2" // Produto Acabado
		//Retorna a quantidade de Produto Acabado vendido (vendido-devolvido)
		nQtdDevol:= QtdProDev((cAliasSB1)->B1_COD,dDtIni,dDtFim)
		nQtdVend := (cAliasSD2)->D2_QUANT - nQtdDevol
		//Localizar as materias primas

		SG1->(DbSeek(xFilial()+(cAliasSB1)->B1_COD)) // Localizo o Produto Acabado
		cChaveAnt := xFilial("SG1")+(cAliasSB1)->B1_COD 
		nQB := Iif((cAliasSB1)->B1_QB > 0,(cAliasSB1)->B1_QB, 1 )
		While SG1->(!Eof()) .And. SG1->G1_FILIAL+SG1->G1_COD == cChaveAnt // Localizei a Materia-Prima
			SB1->(DbSeek(xFilial("SB1")+SG1->G1_COMP))
			If SB1->B1_ESCRIPI =="1" //Verifico se a Materia-Prima se enquadra no Estorno de Credito de IPI
				nAliqMp := SB1->B1_IPI
				//Calculo da Materia Prima
				nMatPrima := Round(SG1->G1_QUANT/nQB,2) //Qtd. necessaria de MP para fabricacao do PA
				nCalcMed  := ValMedProd(SB1->B1_COD,dDtIni,dDtFim) //Calculo Media de Compra da MP
				//Calculo do Sistema para Estorno do Credito de IPI:
				nCalc    := Round(nQtdVend * nMatPrima,2)
				nEsCrIPI += Round(((nCalcMed *nCalc)*nAliqMp/100),2) //Aliquota IPI da Materia-Prima
			EndIf
			SG1->(dbSkip())
		Enddo
	EndIf
	(cAliasSD2)->(dbSkip())
Enddo

If nDvCrIPI > 0
	aAdd(aRetIPI,{STR0144,nDvCrIPI}) //"Dev MP Decreto 7.212 - Art.254 Inc. V"
EndIf

If nEsCrIPI > 0
	aAdd(aRetIPI,{STR0091,nEsCrIPI}) //"Estorno de Credito-Art.193, Inc.I do RIPI"
EndIf

#IFDEF TOP
	dbSelectArea(cAliasSD2)
	dbCloseArea()
#ELSE
	dbSelectArea(cAliasSD2)
	RetIndex(cAliasSD2)
	Ferase(cIndSD2+OrdBagExt())
#ENDIF

RestArea(aArea)
Return(aRetIPI)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³  TOTCDM  ºAutor  ³Angelica N. Rabelo  º Data ³  06/03/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao que vai percorrer a tabela CDM a fim de totalizar   º±±
±±º          ³ CDM_ICMENT que eh o campo onde estara calculado(MATA959) o º±±
±±º          ³ Valor do Credito ICMS Nao Destacado (art.271 do RICMS)     º±±
±±º          ³ baseado nas movimentacoes do periodo                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Livros Fiscais                                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro | dDtIni,dDtFim : periodo da Apuracao a ser considerado      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function totCDM(dDtIni,dDtFim)
Local aArea   := GetArea()
Local nTotICM := 0
Local cAlias  := "CDM"
Local lQuery  := .F.

#IFDEF TOP

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Seleciona registros de CDM para totalizacao de CDM_ICMENT do periodo da apuracao em questao.|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If TcSrvType()<>"AS/400"
		lQuery := .T.
		cAlias := GetNextAlias()
		BeginSql Alias cAlias
			SELECT
				SUM(CDM.CDM_ICMENT) CDM_ICMENT
			FROM
				%table:CDM% CDM
			WHERE
				CDM.CDM_FILIAL = %xFilial:CDM% AND
				CDM.CDM_DTSAI >= %Exp:dDtIni% AND
				CDM.CDM_DTSAI <= %Exp:dDtFim% AND
				CDM.CDM_ICMENT <> 0 AND
				CDM.CDM_TIPO IN ('M','L','E') AND
				CDM.%NotDel%
		EndSql
	Else
#ENDIF
		cAliasCDM := CriaTrab(Nil,.F.)
		cChave    := CDM->(IndexKey())
		cCondicao := "CDM_FILIAL == '" + xFilial("CDM") + "' .AND. "
		cCondicao += "dtos(CDM_DTSAI) >= '"+DToS (dDtIni)+"' .AND. "
		cCondicao += "dtos(CDM_DTSAI) <= '"+DToS (dDtFim)+"' .AND. "
		cCondicao += "CDM_ICMENT <> 0 .AND. "
		cCondicao += "CDM_TIPO $ 'MLE'"
		IndRegua(cAlias,cAliasCDM,cChave,,cCondicao,STR0002) //"Selecionado registros"
		#IFNDEF TOP
			DbSetIndex(cAliasCDM+OrdBagExt())
		#ENDIF
		dbselectarea(cAlias)
		(cAlias)->(dbGotop())
#IFDEF TOP
	EndIf
#ENDIF
While (cAlias)->(!Eof())
	nTotICM := (nTotICM + (cAlias)->CDM_ICMENT)
	(cAlias)->(dbSkip())	
EndDo
If lQuery
	(cAlias)->(dbCloseArea())
EndIf

RestArea(aArea)
Return(nTotICM)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³  TOTEST  ºAutor  ³Angelica N. Rabelo  º Data ³  21/03/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao que vai percorrer a tabela CDM a fim de totalizar   º±±
±±º          ³ CDM_ESTORN que eh o campo onde estara calculado(MATA959) o º±±
±±º          ³ Valor do Credito ICMS Nao Destacado (art.271 do RICMS)     º±±
±±º          ³ a estornar baseado nas Devol.Vendas do periodo             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Livros Fiscais                                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro | dDtIni,dDtFim : periodo da Apuracao a ser considerado      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function totEST(dDtIni,dDtFim)
Local aArea   := GetArea()
Local nTotEst := 0
Local cAlias  := "CDM"
Local lQuery  := .F.

#IFDEF TOP
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Seleciona registros da CDM para totalizacao de CDM_ESTORN do periodo da apuracao em questao |
//³ CDM_ESTORN contem o valor a estornar do Crédito proveniente de Devol. Vendas no periodo     |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If TcSrvType()<>"AS/400"
		lQuery := .T.
		cAlias := GetNextAlias()
		BeginSql Alias cAlias
			SELECT
				SUM(CDM.CDM_ESTORN) CDM_ESTORN
			FROM
				%table:CDM% CDM
			WHERE
				CDM.CDM_FILIAL = %xFilial:CDM% AND
				CDM.CDM_DTDGEN >= %Exp:dDtIni% AND
				CDM.CDM_DTDGEN <= %Exp:dDtFim% AND
				CDM.CDM_TIPODB = 'D' AND
				CDM.CDM_ESTORN <> 0 AND
				CDM.%NotDel%
		EndSql
	Else
#ENDIF
		cAliasCDM := CriaTrab(Nil,.F.)
		cChave	  := CDM->(IndexKey())
		cCondicao := "CDM_FILIAL == '" + xFilial("CDM") + "' .AND. "
		cCondicao += "dtos(CDM_DTDGEN) >= '"+DToS (dDtIni)+"' .AND. "
		cCondicao += "dtos(CDM_DTDGEN) <= '"+DToS (dDtFim)+"' .AND. "
		cCondicao += "CDM_TIPODB == 'D' .AND. "
		cCondicao += "CDM_ESTORN <> 0"
		IndRegua(cAlias,cAliasCDM,cChave,,cCondicao,STR0002) //"Selecionado registros"
		#IFNDEF TOP
			DbSetIndex(cAliasCDM+OrdBagExt())
		#ENDIF
		dbselectarea(cAlias)
		(cAlias)->(dbGotop())
#IFDEF TOP
	EndIf
#ENDIF
While (cAlias)->(!Eof())
	nTotEst := nTotEst + (cAlias)->CDM_ESTORN
	(cAlias)->(dbSkip())
EndDo
If lQuery
	(cAlias)->(dbCloseArea())
EndIf

RestArea(aArea)
Return(nTotEst)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³CredAcum  ³ Autor ³Andressa Fagundes      ³ Data ³25.03.2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o valor do credito acumulado para o Estado da BA.  ³±±
±±³          ³ - Exportacoes                                              ³±±
±±³          ³ - Outras hipoteses                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ dDtIni: Data Inicial da Apuracao                           ³±±
±±³          ³ dDtFim: Data Final da Apuracao                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CredAcum(dDtIni,dDtFim)

Local aArea		:= GetArea()
Local cAliasSF3 := "SF3"
Local cIndSF3   := ""
Local cTesSaid	:= ""
Local lCredAcu	:= aApurSX3[FP_F3_CREDACU]
Local lPCreAcu	:= aApurSX3[FP_F4_PCREDAC]
Local aLote		:= {}
Local aLote1	:= {}
Local nY		:= 0
Local nCrAcuExp	:= 0
Local nCrAcuOut := 0
Local nVlUnICM	:= 0
Local nVlrCred	:= 0
Local nPCredAcu := 0
Local nQtdVend  := 0   
Local nQtdUtil	:= 0       
Local nVlICMS	:= 0      
Local nQtde		:= 0

#IFDEF TOP
	Local aStruSF3	:=	{}
	Local cQuery	:=	""
	Local nX		:=	0
#ELSE
	Local cIndex    :=	""
	Local cFiltro 	:=	""
#ENDIF

If lCredAcu .And. lPCreAcu

SD2->(dbSetOrder(3))
SD1->(dbSetOrder(1))
SF4->(dbSetOrder(1))
    	   		
dbSelectArea("SF3")
SF3->(dbsetorder(1))
//Selecao das Notas fiscais de Saida com Direito a Credito Acumulado de ICMS
#IFDEF TOP  
	If TcSrvType()<>"AS/400"
	    cAliasSF3 	:= "AliasSF3"
		aStruSF3  	:= SF3->(dbStruct())
		cQuery 	:= "SELECT DISTINCT F3_NFISCAL, F3_SERIE, F3_CLIEFOR, F3_LOJA, F3_CREDACU "
		cQuery 	+= "FROM " + RetSqlName("SF3") + " "
		cQuery 	+= "WHERE F3_FILIAL = '" + xFilial("SF3") + "' AND "
		cQuery 	+= "F3_ENTRADA >= '" + Dtos(dDtIni) + "' AND "
		cQuery 	+= "F3_ENTRADA <= '" + Dtos(dDtFim) + "' AND "                   
		cQuery 	+= "F3_CREDACU IN ('1','2') AND "
		cQuery  += "F3_CFO >= '501' AND "
		cQuery	+= "F3_DTCANC = '" + Dtos(Ctod("")) + "' AND "
		cQuery 	+= "D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSF3,.T.,.T.)
		
		For nX := 1 To len(aStruSF3)
			If aStruSF3[nX][2] <> "C"
				TcSetField(cAliasSF3,aStruSF3[nX][1],aStruSF3[nX][2],aStruSF3[nX][3],aStruSF3[nX][4])
			EndIf
		Next nX     

		dbSelectArea(cAliasSF3)	
	Else	
#ENDIF
		cIndex  := CriaTrab(NIL,.F.)
		cFiltro	:=	"SF3->F3_FILIAL == '" + xFilial("SF3") + "' .And. DTOS(SF3->F3_ENTRADA) >= '" + Dtos(dDtIni) + "' .AND. DTOS(SF3->F3_ENTRADA) <= '" + Dtos(dDtFim) + "'"
		cFiltro	+=  " .And. SF3->F3_CREDACU $'12' .And. DTOS(SF3->F3_DTCANC) == '" + Dtos(Ctod("")) + "'"
		IndRegua(cAliasSF3,cIndex,SF3->(IndexKey()),,cFiltro)
		dbSelectArea(cAliasSF3)
		dbGoTop()
#IFDEF TOP
	Endif
#ENDIF

cIndSF3	:=	CriaTrab(NIL,.F.)
	
While !(cAliasSF3)->(Eof())
            //Pesquisa as notas fiscais de entrada atraves da funcao RastroNFOr --> FisxFun
	    aLote:=RastroNFOr((cAliasSF3)->F3_NFISCAL,(cAliasSF3)->F3_SERIE,(cAliasSF3)->F3_CLIEFOR,(cAliasSF3)->F3_LOJA)
            //REVENDA
            //Somente Compra e Vende o mesmo produto. Compra Produto Acabado e Vende Produto Acabado.
		If Len(aLote) > 0 
			For nY := 1 to Len(aLote)

				//Valor Unitario do ICMS na Entrada--> D1_VALICM / D1_QUANT
				nVlUnICM:= Round(aLote[nY][13]/aLote[nY][6],2)
			
				//Quantidade Vendida na Saida x Valor do ICMS Unitario da Entrada = Valor do Credito Acumulado
				nVlrCred := Round(aLote[nY][4]* nVlUnICM,2)
			
                //TES para locaizacao do campo do % do Credito Acumulado
				If SF4->(MsSeek(xFilial("SF4")+aLote[nY][30]))
					nPCredAcu:= (nVlrCred*SF4->F4_PCREDAC)/100
					If (cAliasSF3)->F3_CREDACU == "1" // Exportacoes
						nCrAcuExp += nPCredAcu
					Elseif (cAliasSF3)->F3_CREDACU == "2" // Outras hipoteses
						nCrAcuOut += nPCredAcu
					Endif	
				Endif
			Next
		Else
			//INDUSTRIALIZACAO
			//Compra Materia-Prima e Vende Produto Acabado.
    	   		SD2->(MsSeek(xFilial("SD2")+(cAliasSF3)->F3_NFISCAL+(cAliasSF3)->F3_SERIE+(cAliasSF3)->F3_CLIEFOR+(cAliasSF3)->F3_LOJA))
			//Procuro o lote e o sublote do produto acabado vendido
    		   	Do While ! SD2->(Eof()) .And. xFilial("SD2")==xFilial("SF3") .And. SD2->D2_DOC==(cAliasSF3)->F3_NFISCAL .And.;
    	   			SD2->D2_SERIE==(cAliasSF3)->F3_SERIE .And. SD2->D2_CLIENTE	==(cAliasSF3)->F3_CLIEFOR .And. SD2->D2_LOJA==(cAliasSF3)->F3_LOJA;
    	   			.And. !Empty(SD2->D2_LOTECTL) .And. !Empty(SD2->D2_NUMLOTE)

                    //Localizo a nota fiscal original(entrada) atraves da nota fiscal de saida.
				nQtdVend:=SD2->D2_QUANT
				cTesSaid:=SD2->D2_TES
				aLote1  :=RetDocOrig(SD2->D2_COD,SD2->D2_LOCAL,SD2->D2_LOTECTL,SD2->D2_NUMLOTE,SD2->D2_QUANT)

				For nY := 1 to Len(aLote1)
                        //Nota Fiscal de Entrada para obter o valor do ICMS da Materia-Prima
		    	   	SD1->(MsSeek(xFilial("SD1")+aLote1[nY][1][1]+aLote1[nY][1][2]+aLote1[nY][1][3]+aLote1[nY][1][4]))
		    	   	Do While ! SD1->(Eof());
		    	   		.And. SD1->D1_DOC == aLote1[nY][1][1] .And. SD1->D1_SERIE == aLote1[nY][1][2];
			    	   	.And. SD1->D1_FORNECE == aLote1[nY][1][3] .And. SD1->D1_LOJA == aLote1[nY][1][4];
			    	   	.And. SD1->D1_NUMSEQ == aLote1[nY][1][5]

						//Valor Unitario do ICMS na Entrada --> D1_VALICM / D1_QUANT
						nVlICMS += SD1->D1_VALICM
						nQtde	+= SD1->D1_QUANT

						//Proporcao da Quantidade de Materia-Prima na Entrada pela Quantidade de P.A vendido
                        nQtdUtil := aLote1[nY][1][6] /nQtdVend

						SD1->(dbSkip())
                        Enddo
                    Next
				//Valor Unitario do ICMS na Entrada --> D1_VALICM / D1_QUANT
				nVlUnICM:= nVlICMS / nQtde
				
				//Valor do ICMS Unit. da Entrada * nQtdUtil * Qtde. Vendida = Valor do Credito Acumulado
				nVlrCred := nVlUnICM * (nQtdUtil*nQtdVend)
							
                //TES para localizacao do campo do % do Credito Acumulado - Saidas
				If SF4->(MsSeek(xFilial("SF4")+cTesSaid))
					nPCredAcu:= (nVlrCred*SF4->F4_PCREDAC)/100
					If (cAliasSF3)->F3_CREDACU == "1" // Exportacoes
						nCrAcuExp += nPCredAcu
					Elseif (cAliasSF3)->F3_CREDACU == "2" // Outras hipoteses
						nCrAcuOut += nPCredAcu
					Endif	
				Endif
				SD2->(dbSkip())
			Enddo
		Endif
        (cAliasSF3)->(dbSkip())
Enddo

#IFDEF TOP
	dbSelectArea(cAliasSF3)
	dbCloseArea()
#ELSE
	dbSelectArea(cAliasSF3)
	RetIndex(cAliasSF3)
	Ferase(cIndSF3+OrdBagExt())
#ENDIF

RestArea(aArea)

Endif



Return ({nCrAcuExp,nCrAcuOut})
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GrvApurCDP  ³ Autor ³ Cleber Stenio      ³ Data ³ 22/06/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Apuraçao IPI na tabela CDP 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA952                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION GrvApurCDP(nApuracao,nPeriodo,cNrLivro,dDtIni,dDtFim,nMoedTit,lNCM,cFiliais,cFilDe,cFilAte)
Local cChave	:= STR(nApuracao,1)+STR(nPeriodo,1)+DTOS(dDtIni)+cNrLivro
Local cSequen	:= "001"
Local nI 		:= 0
Local cTipo 	:= "TX"+Space(TamSx3("E2_TIPO")[1]-2)
Local cPrefixo	:= SuperGetMV("MV_PFAPUIP",,"IPI")
LOCAL lRet		:= .t.
Local nContLin  := "001"
Local lCmpPcLanc := aApurSX3[FP_CDP_TPLANC]

If Empty( cPrefixo := &( SuperGetMV( "MV_PFAPUIP" ) ) )
	cPrefixo	:=	"IPI"					
Endif  

dbSelectArea("CDP")
dbSetOrder(01)
If dbSeek(xFilial("CDP")+"IP"+cChave)
	While !EOF() .AND. CDP->CDP_FILIAL+CDP->CDP_TIPOIP+CDP->CDP_TIPOPR+CDP->CDP_PERIOD+DTOS(CDP->CDP_DTINI)+CDP->CDP_LIVRO == xFilial("CDP")+"IP"+cChave
		cSequen	 := CDP->CDP_SEQUEN
		dbSkip()
	EndDo
	cSequen	 := Soma1(cSequen)
EndIf

For nI:=1 to Len(aGetApur)
	
	If !(aGetApur[nI,1]$"   /OBS/TIT")
	    //Se Existe já um lançamento para essa linha incremento a sequencia de linha para não dar duplicidade de chave
		If dbSeek(xFilial("CDP")+"IP"+cChave+cSequen+aGetApur[nI][1]+nContLin)
			nContLin	 := Soma1(nContLin)
		Else
			nContLin	 := "001"
		EndIf
		
		RecLock("CDP",.T.)
		CDP->CDP_FILIAL	:=	xFilial("CDP")
		CDP->CDP_TIPOIP	:=	"IP"
		CDP->CDP_TIPOPR	:=	STR(nApuracao,1)
		CDP->CDP_PERIOD	:=	STR(nPeriodo,1)
		CDP->CDP_LIVRO	:=	cNrLivro
		CDP->CDP_SEQUEN	:=	cSequen
		CDP->CDP_CONSF  :=  cFiliais
		CDP->CDP_DTINI	:=	dDtIni
		CDP->CDP_DTFIM	:=	dDtFim
		CDP->CDP_FILDE	:=	cFilDe
		CDP->CDP_FILATE	:=	cFilAte
		CDP->CDP_SEQLIN :=  nContLin
		CDP->CDP_LINHA	:=	aGetApur[nI][1]
		CDP->CDP_DESC	:=	Padr(aGetApur[nI][2],TamSX3("CDP_DESC")[1])
		CDP->CDP_VALOR	:=	Iif(Valtype(aGetApur[nI][3]) == "N",aGetApur[nI][3],0)
		CDP->CDP_CODLAN :=  aGetApur[nI][5]
		CDP->CDP_INDDOC :=  aGetApur[nI][6]
		CDP->CDP_NUMDOC	:=  aGetApur[nI][7]
		If lCmpPcLanc
			CDP->CDP_TPLANC :=  aGetApur[nI][8]
		Endif

		MsUnlock()
		CDP->(FKCommit())
    EndIf
Next


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava indice de conversao                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RecLock("CDP",.T.)
nContLin:="001"
CDP->CDP_FILIAL	:=	xFilial("CDP")
CDP->CDP_TIPOIP	:=	"IP"
CDP->CDP_TIPOPR	:=	STR(nApuracao,1)
CDP->CDP_PERIOD	:=	STR(nPeriodo,1)
CDP->CDP_LIVRO	:=	cNrLivro
CDP->CDP_SEQUEN	:=	cSequen
CDP->CDP_CONSF  :=  cFiliais
CDP->CDP_DTINI	:=	dDtIni
CDP->CDP_DTFIM	:=	dDtFim
CDP->CDP_FILDE	:=	cFilDe
CDP->CDP_FILATE	:=	cFilAte
CDP->CDP_LINHA	:=	"IND"
CDP->CDP_SEQLIN :=  nContLin
CDP->CDP_DESC	:=	"Indice de Conversão"
CDP->CDP_VALOR	:=	Val(Transform(xMoeda(1,nMoedTit,1,dDataBase),"9.999"))
MsUnlock()
CDP->(FKCommit())


For nI:=1 to Len(aGetApur)
	
	If (aGetApur[nI,1]$"OBS/TIT")
		//Se Existe já um lançamento para essa linha incremento a sequencia de linha para não dar duplicidade de chave
		If dbSeek(xFilial("CDP")+"IP"+cChave+cSequen+aGetApur[nI][1]+nContLin)
			nContLin	 := Soma1(nContLin)
		Else
			nContLin	 := "001"
		EndIf
		RecLock("CDP",.T.)
		CDP->CDP_FILIAL	:=	xFilial("CDP")
		CDP->CDP_TIPOIP	:=	"IP"
		CDP->CDP_TIPOPR	:=	STR(nApuracao,1)
		CDP->CDP_PERIOD	:=	STR(nPeriodo,1)
		CDP->CDP_LIVRO	:=	cNrLivro
		CDP->CDP_SEQUEN	:=	cSequen
		CDP->CDP_CONSF  :=  cFiliais
		CDP->CDP_DTINI	:=	dDtIni
		CDP->CDP_DTFIM	:=	dDtFim
		CDP->CDP_FILDE	:=	cFilDe
		CDP->CDP_FILATE	:=	cFilAte
		If aGetApur[nI,1]=="TIT" // Titulos
			CDP->CDP_PRETIT	:=	cPrefixo
			CDP->CDP_NUMTIT	:=	aGetApur[nI][2]
			CDP->CDP_PARTIT	:=	""
			CDP->CDP_TPTIT	:=	cTipo
			CDP->CDP_VALOR	:=	Iif(Valtype(aGetApur[nI][3]) == "N",aGetApur[nI][3],0)
			CDP->CDP_LINHA	:=	"TIT"
			CDP->CDP_SEQLIN :=  nContLin
		ElseIf aGetApur[nI,1]=="OBS" // Observacoes
			CDP->CDP_LINHA	:=	"OBS"
			CDP->CDP_SEQLIN :=  nContLin
			CDP->CDP_DESC	:=	aGetApur[nI][2]
		EndIf
		MsUnlock()
		CDP->(FKCommit())
    EndIf
Next

RETURN (lRet)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CkApurCDP  ³ Autor ³ Cleber Stenio       ³ Data ³ 22/06/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se ja foi efetuada apuracao IPI                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA952                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/				
FUNCTION CkApurCDP(cImp,nAno,nMes,nApuracao,nPeriodo,cNrLivro,cImposto,aDadIC,;
					nMoedTit,cLcPadExt,cArqApur,aDadST,cProgram,aUsrdem,lTitulo,dDtIni,nOpc,lAutomato)
					

LOCAL lRet		:= .t.
LOCAL oDlgCheck                                      		
LOCAL cTitulo	:= ""
LOCAL cText1	:= ""
LOCAL cText2	:= ""
Local lRefApur	:= GetNewPar("MV_REFAPUR",.F.)	//Permite Refazer a Apuracao mesmo com o Titulo ja Baixado
Local aNrTit	:= {}
Local nX		:= 0
Local cChave	:= STR(nApuracao,1)+STR(nPeriodo,1)+DTOS(dDtIni)+cNrLivro
Local lCmpPcLanc := aApurSX3[FP_CDP_TPLANC]

Default nOpc		 := 2
Default lTitulo 	 := .T.
Default lAutomato	 := .F.

aUsrdem :=If(aUsrdem==NIL,	aUsrdem:={},aUsrdem)

If File(cArqApur)
	dbSelectArea("CDP")
	dbSetOrder(01)
	If dbSeek(xFilial("CDP")+"IP"+cChave)
		cSomaSeq  := CDP->CDP_SEQUEN
		While dbSeek(xFilial("CDP")+"IP"+cChave+cSomaSeq) // Posiciona na ultima sequencia
			cSequen  := CDP->CDP_SEQUEN
			cSomaSeq := Soma1(cSequen)
		EndDo
		cChave   += cSequen
		cChave  := xFilial("CDP")+"IP"+cChave
		cTitulo	:=	STR0038 //"Aten‡„o"
		cText1	:=	STR0039+cImposto+STR0040 //"Arquivo de Apura‡„o de "###" j  existe:"
		cText2	:=	STR0087 //"Deseja refazer considerando a apuração anterior ?"
		If !lAutomato		
			DEFINE MSDIALOG oDlgCheck TITLE OemtoAnsi(cTitulo) FROM  185,152 TO 295,465 PIXEL OF oMainWnd
			@ 05, 10 TO 33, 150 LABEL "" OF oDlgCheck  PIXEL
			@ 10, 15 SAY OemToAnsi(cText1) SIZE 125, 8 OF oDlgCheck PIXEL
			@ 20, 15 SAY OemToAnsi(cText2) SIZE 125, 8 OF oDlgCheck PIXEL
			DEFINE SBUTTON FROM 40, 052 TYPE 2 ACTION (nOpc:=1,oDlgCheck:End()) ENABLE OF oDlgCheck
			@ 40,083 BUTTON STR0041 SIZE 30,12 FONT oDlgCheck:oFont ACTION (nOpc:=2,oDlgCheck:End()) OF oDlgCheck PIXEL //"Refazer"
			@ 40,115 BUTTON STR0042 SIZE 30,12 FONT oDlgCheck:oFont ACTION (nOpc:=3,oDlgCheck:End()) OF oDlgCheck PIXEL //"Excluir"
			ACTIVATE MSDIALOG oDlgCheck
		EndIf

		If nOpc == 1 // Refazer sem considerar apuracao anterior
			dbSeek(cChave)
			While !CDP->(EOF()) .And. CDP->CDP_FILIAL+CDP->CDP_TIPOIP+CDP->CDP_TIPOPR+CDP->CDP_PERIOD+DTOS(CDP->CDP_DTINI)+CDP->CDP_LIVRO+CDP->CDP_SEQUEN == cChave
	           	If !Empty(CDP->CDP_NUMTIT)
		    		Aadd(aNrTit,CDP->CDP_NUMTIT)
				Endif
			   	CDP->(dbSkip())
		   	EndDo
			
			If Len(aNrTit) > 0
				Aviso(STR0073,STR0074,{"OK"})	 //"Atencao"###'A apuracao nao podera ser excluida, pois existe um titulo gerado. Favor refazer a apuracao, utilizando a opcao de gerar titulo com "Nao"'
				lRet 	:= .f.
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Apaga arquivo de apuracao        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If File(cArqApur)
					Ferase(cArqApur)
				EndIf
			   	lRet := .t. // Retorna T para fazer a apuracao sem considerar a anterior
		   	Endif		
		ElseIf nOpc==2 // Refazer considerando apuracao anterior
			
			lRet := .t.
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Carrega ajustes na apuracao ICMS ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
			dbSeek(cChave)
			While !CDP->(EOF()) .And. CDP->CDP_FILIAL+CDP->CDP_TIPOIP+CDP->CDP_TIPOPR+CDP->CDP_PERIOD+DTOS(CDP->CDP_DTINI)+CDP->CDP_LIVRO+CDP->CDP_SEQUEN == cChave
				If CDP->CDP_LINHA == "TIT" .And. !Empty(CDP->CDP_NUMTIT)
					Aadd(aNrTit,{CDP->CDP_PRETIT,CDP->CDP_NUMTIT})
				ElseIf !Empty(CDP->CDP_CODLAN)
					If (lCmpPcLanc .And. (Alltrim(CDP->CDP_TPLANC)) == "") .Or. !lCmpPcLanc //'1-AUTOMATICO','2-MANUAL'
						If aApurSX2[AI_CCK] .And. CCK->(dbSeek(xFilial("CCK")+CDP->CDP_CODLAN))
							AADD(aDadIC,{CDP->CDP_LINHA,CDP->CDP_DESC,CDP->CDP_VALOR,CDP_NUMDOC,CDP_INDDOC,CDP->CDP_CODLAN})
						EndIf
					Endif
				EndIf
				dbSkip()
			EndDo
	
		    If Len(aNrTit) > 0
				
				dbSelectArea("SE2")
				dbSetOrder(01)
				For nX := 1 to Len(aNrTit) 
					
					If dbSeek(xFilial()+aNrTit[nX][1]+aNrTit[nX][2],.F.)
						If !FaCanDelCP("SE2", cProgram)
							lRet 	:= .F.
						EndIf
						If lRet
							PcoIniLan('000250')
							Begin Transaction
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Estorna lancamento contabil      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							LancCont(cLcPadExt,cProgram)
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Estorna lancamento PCO           ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							PcoDetLan('000250',"01","MATA953",.T.)
							PcoDetLan('000250',"02","MATA953",.T.)
							PcoDetLan('000250',"03","MATA953",.T.)
							PcoDetLan('000250',"04","MATA953",.T.)
	
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Excluir titulo gerado            ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							FaAvalSE2(2)
							FaAvalSE2(3)
							dbSelectArea("SE2")
							If aFindFunc[FF_FINGRVEX]
								FinGrvEx("P") // Gravar o histórico.
							EndIf
							RecLock("SE2",.f.,.t.)
							dbDelete()
							End Transaction
							PcoFinLan('000250')
						Endif
					Endif
				Next					
				If !lRet
					If !lTitulo .And. lRefApur	//Permite refazer a apuracao mesmo com o titulo baixado
						lRet 	:= .T.
					Else
						If !lAutomato						
							DEFINE MSDIALOG oDlgTit TITLE OemtoAnsi(STR0038) FROM  180,155 TO 310,480 PIXEL OF oMainWnd //"Aten‡„o"
							@ 03, 15 TO 39, 150 LABEL "" OF oDlgTit  PIXEL
		                	@ 10, 20 SAY OemToAnsi(STR0043+E2_NUM+"-"+E2_PREFIXO+STR0044) SIZE 128, 8 OF oDlgTit PIXEL //"T¡tulo "###" j  foi baixado ou existe cheque(s)"
		                	@ 20, 20 SAY OemToAnsi(STR0045)                   SIZE 128, 8 OF oDlgTit PIXEL //"gerado(s), para refazer a apura‡„o, a baixa deste"
		                	@ 30, 20 SAY OemToAnsi(STR0046)                       SIZE 128, 8 OF oDlgTit PIXEL //"t¡tulo e/ou cheque(s) dever„o ser cancelados."
		                	@ 46, 60 BUTTON STR0047 SIZE 40,12 FONT oDlgTit:oFont ACTION (nOpc:=1,oDlgTit:End()) OF oDlgTit PIXEL //"Abandona"
							ACTIVATE MSDIALOG oDlgTit
						EndIf	
					Endif
				Endif
			Endif			
		ElseIf nOpc==3 .And. lRet
		   		////////////////////
		   		lRet := .t.
		   		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carrega ajustes na apuracao ICMS ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
				dbSeek(cChave)
				While !CDP->(EOF()) .And. CDP->CDP_FILIAL+CDP->CDP_TIPOIP+CDP->CDP_TIPOPR+CDP->CDP_PERIOD+DTOS(CDP->CDP_DTINI)+CDP->CDP_LIVRO+CDP->CDP_SEQUEN == cChave
					If CDP->CDP_LINHA == "TIT" .And. !Empty(CDP->CDP_NUMTIT)
						Aadd(aNrTit,{CDP->CDP_PRETIT,CDP->CDP_NUMTIT})
					ElseIf !Empty(CDP->CDP_CODLAN)
							If aApurSX2[AI_CCK] .And. CCK->(dbSeek(xFilial("CCK")+CDP->CDP_CODLAN))
								AADD(aDadIC,{CDP->CDP_LINHA,CDP->CDP_DESC,CDP->CDP_VALOR,CDP_NUMDOC,CDP_INDDOC,CDP->CDP_CODLAN})
							EndIf
					EndIf
					dbSkip()
				EndDo
	
	    		If Len(aNrTit) > 0
					dbSelectArea("SE2")
					dbSetOrder(01)
					For nX := 1 to Len(aNrTit) 
					
				  		If dbSeek(xFilial()+aNrTit[nX][1]+aNrTit[nX][2],.F.)
				  			If !FaCanDelCP("SE2", cProgram)
				  				lRet 	:= .F.
				  			EndIf
				  			If lRet
				  				PcoIniLan('000250')
				  				Begin Transaction
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Estorna lancamento contabil      ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								LancCont(cLcPadExt,cProgram)
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Estorna lancamento PCO           ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								PcoDetLan('000250',"01","MATA953",.T.)
								PcoDetLan('000250',"02","MATA953",.T.)
								PcoDetLan('000250',"03","MATA953",.T.)
								PcoDetLan('000250',"04","MATA953",.T.)
	            	
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Excluir titulo gerado            ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								FaAvalSE2(2)
								FaAvalSE2(3)
								dbSelectArea("SE2")
								If aFindFunc[FF_FINGRVEX]
									FinGrvEx("P") // Gravar o histórico.
								EndIf
								RecLock("SE2",.f.,.t.)
								dbDelete()
								End Transaction
								PcoFinLan('000250')
							Endif
						Endif
					Next
				Endif
        	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Apaga arquivo de apuracao        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
				if File(cArqApur) .and. lret
					Ferase(cArqApur)
					lRet := .f.
				Else
					lRet := .f.
				Endif
		Else
			lRet 	:= .f.
		Endif
	EndIf	
EndIf

Return (lRet)

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³VerGNRENF ³ Autor ³ Liber De Esteban             ³ Data ³ 28/08/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se existem guias para o documento, indicando que o ICMS  ³±±
±±³          ³ ja foi pago                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function VerGNRENF(cAliasSF3,aIcmPago)

Local cOperNF   := IIf( Val(Substr((cAliasSF3)->F3_CFO,1,1))<5 ,"E" , "S" )

If CDC->(DbSeek (xFilial ("CDC")+cOperNF+(cAliasSF3)->F3_NFISCAL+(cAliasSF3)->F3_SERIE+(cAliasSF3)->F3_CLIEFOR+(cAliasSF3)->F3_LOJA))

	While CDC->(!EOF()) .And. CDC->CDC_FILIAL == xFilial("CDC") .And. CDC->CDC_TPMOV == cOperNF .And. CDC->CDC_DOC == (cAliasSF3)->F3_NFISCAL .And.;
	      CDC->CDC_SERIE == (cAliasSF3)->F3_SERIE .And. CDC->CDC_CLIFOR == (cAliasSF3)->F3_CLIEFOR .And. CDC->CDC_LOJA == (cAliasSF3)->F3_LOJA
		
		If SF6->(dbSeek(xFilial("SF6")+CDC->CDC_UF+CDC->CDC_GUIA)) .And.;
		   (Ascan(aIcmPago,{|x| x[1]==SF6->F6_EST .And. x[3]==SF6->F6_NUMERO .And. x[4]==SF6->F6_DTVENC})) == 0
			
			AADD(aIcmPago,{SF6->F6_EST,SF6->F6_VALOR,SF6->F6_NUMERO,SF6->F6_DTVENC,SF6->F6_CODREC,SF6->F6_OBSERV,SF6->F6_MESREF,SF6->F6_ANOREF })
			
		EndIf
		
		CDC->(dbSkip())
	EndDo
EndIf

Return NIL

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SF6TudoOk³ Autor ³Alexandre Inacio Lemes ³ Data ³ 07/07/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida a inclusao da Guia de Recolhimento SF6               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³SF60TudoOk()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. = Tudo OK Valido .F. = Nao OK Invalido                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FISXAPUR                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SF6TudoOk(cOrigem, cPrefAnt, cNumAnt)

Local aArea     := GetArea()
Local lValido   := .T.
Local lApurF6Ok := .T.

DEFAULT cPrefAnt := ""
DEFAULT cNumAnt  := ""
DEFAULT cOrigem  := ""

If aExistBloc[PE_APURF6OK]
	lApurF6Ok := Execblock("APURF6OK",.F.,.F.)
	If ValType(lApurF6Ok) == "L"
		lValido := lApurF6Ok
	EndIf
Else
	If cOrigem == "MATA460A"
		SF6->(dbSetOrder(1))

		If SF6->(DbSeek(xFilial("SF6")+M->F6_EST+M->F6_NUMERO))
			Alert("GNRE " + M->F6_NUMERO + " - " + M->F6_EST + " Já foi cadastrada." + Chr(13) + Chr(10) + "Insira outro numero de GNRE.")	
			lValido := .F.
		EndIf

		// Data de corte p/ alteracao manual do nro. da GNRE.
		// Após esta data a alteracao sera bloqueada, portanto a validacao nao sera necessaria.
		// Por este motivo nao foram criados STR's. Este trecho poderá ser removido após a data corte.
		If dDataBase < cToD("15/06/2016")
			If !Empty(cPrefAnt) .And. !Empty(cNumAnt)
				If AllTrim(M->F6_NUMERO) <> AllTrim(cPrefAnt + cNumAnt)
					If MSGYESNO( "Atenção!" + PULALINHA + PULALINHA +;
									"O número da GNRE foi alterado manualmente." + PULALINHA +;
					            "É altamente recomendável utilizar a numeração sugerida pelo sistema." + PULALINHA +;
					            "Ao clicar em <Sim> e efetivar esta alteração a rastreabilidade das GNRE's e títulos será comprometida, podendo " + ; 
					            "ocasionar perda de integridade e falhas em eventuais exclusões deste documento." + PULALINHA +;
					            "Clicando em <Não> o número digitado será substituído pelo número sugerido anteriormente." + PULALINHA + PULALINHA +;
					            "Após o dia 15/06/2016 a alteração da numeração da GNRE será bloqueada." + PULALINHA + PULALINHA +;
					            "Deseja continuar e efetivar a alteração?","Atenção")
						lValido := .T.
					Else
						lValido := .F.
						M->F6_NUMERO := AllTrim(cPrefAnt + cNumAnt) // retorno o numero sugerido previamente.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return(lValido)

//-------------------------------------------------------------------
/*/{Protheus.doc} xApIncSF6

Funcao centralizadora da gravacao das GNRES geradas na emissao ou
recebimento dos documentos.

@param cAlias  - Alias do Arquivo
@param nReg    - Numero do Registro
@param nOpc    - 3-Incluir
@param cFunc   - Funcao que Atualiza as variaveis de memoria para inclusao
@param aCmpAlt - Array com o nome dos campos que poderão ser editados
@param cTdOk   - Funcao que valida as informacoes confirmadas
@param aAuto   - Array que indica que a inclusao sera realizada de forma automatica

@author flavio.luiz
@since 21/05/2018
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function xApIncSF6(cAlias,nReg,nOpc,cFunc,aCmpAlt,cTdOk,aAuto)
Local lAPURF6CAN := aExistBloc[PE_APURF6CAN]
Local nOpca := 0

While .T.
	nOpcA := 0
	Begin Transaction
		nOpcA := AxInclui(cAlias,nReg,nOpc,,cFunc,aCmpAlt,cTdOk,,,,,aAuto)
	End Transaction
	If nOpcA <> 1 .And. lAPURF6CAN
		If ExecBlock("APURF6CAN",.F.,.F.)
			Exit
		EndIf
	Else
		Exit
	EndIf
EndDo
dbSelectArea(cAlias)

Return nOpca

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ VlCredAnt³ Autor ³Mauro A. Gonçalves     ³ Data ³ 08/08/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o Valor de Credito de ICMS por UF                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³VlCredAnt(nMes,nAno,cUF)                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nMes = Mes Apuracao  nAno = Ano Apuracao UF = UF Cliente   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Valor do Credito                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA953/SPEDFISCAL                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function VlCredAnt(nMes,nAno,cUF)
Local aArea     	:= GetArea()
Local	cAliasSFT 	:= "AliasSFT"
Local nValor    	:= 0
Local cMVSubTr		:= IIf(aFindFunc[FF_GETSUBTRIB], GetSubTrib(), SuperGetMv("MV_SUBTRIB"))
Local dDtIni    
Local dDtFim    

If nMes == 1
	nAno := nAno - 1
	nMes := 12
Else 
	nMes := nMes - 1
Endif

dDtIni := Ctod('01/'+strzero(nMes)+'/'+strzero(nAno))
dDtFim := LastDay(Ctod('01/'+strzero(nMes)+'/'+strzero(nAno)))

dbSelectArea("SFT")
	#IFDEF TOP  
		If TcSrvType()<>"AS/400"
/*		
			cQuery		:= "SELECT A2_INSCR, SUM(FT_ICMSRET) VLICMSRET "
			cQuery		+= "FROM " + RetSqlName("SFT") + ", " + RetSqlName("SA2") + " "
			cQuery		+= "WHERE FT_FILIAL = '" + xFilial("SFT") + "' AND "
			cQuery		+= "FT_ENTRADA >= '" + Dtos(dDtIni) + "' AND "
			cQuery		+= "FT_ENTRADA <= '" + Dtos(dDtFim) + "' AND "                   
			cQuery		+= "FT_ICMSRET > 0 AND "
			cQuery		+= "FT_ESTADO = '" + cUF + "' AND "
			cQuery		+= "FT_DTCANC = '" + Dtos(Ctod("")) + "' AND "
			cQuery		+= RetSqlName("SFT") + ".D_E_L_E_T_ = ' ' AND "
			cQuery		+= "A2_FILIAL = '" + xFilial("SA2") + "' AND "
			cQuery		+= "A2_COD = FT_CLIEFOR AND A2_LOJA = FT_LOJA AND "
			cQuery		+= RetSqlName("SA2") + ".D_E_L_E_T_ = ' ' "
			cQuery		+= "GROUP BY A2_INSCR"						
*/
			cQuery		:= "SELECT SUM(FT_ICMSRET) VLICMSRET "
			cQuery		+= "FROM " + RetSqlName("SFT") + " "
			cQuery		+= "WHERE FT_FILIAL = '" + xFilial("SFT") + "' AND "
			cQuery		+= "FT_ENTRADA >= '" + Dtos(dDtIni) + "' AND "
			cQuery		+= "FT_ENTRADA <= '" + Dtos(dDtFim) + "' AND "                   
			cQuery		+= "FT_ICMSRET > 0 AND "
			cQuery		+= "FT_ESTADO = '" + cUF + "' AND "
			cQuery		+= "FT_DTCANC = '" + Dtos(Ctod("")) + "' AND "
			cQuery		+= "D_E_L_E_T_ = ' '"		
			
			cQuery      := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSFT,.T.,.T.)		
		Else	
	#ENDIF
			cIndex	:= CriaTrab(NIL,.F.)
			cFiltro	:=  "SFT->FT_FILIAL == '" + xFilial("SFT") + "' .And. DTOS(SFT->FT_ENTRADA) >= '" + Dtos(dDtIni) + "' .AND. DTOS(SFT->FT_ENTRADA) <= '" + Dtos(dDtFim) + "'"
			cFiltro	+=  " .And. SFT->FT_ICMSRET > 0 .And. DTOS(SFT->FT_DTCANC) == '" + Dtos(Ctod("")) + "'"
			IndRegua(cAliasSFT,cIndex,SFT->(IndexKey()),,cFiltro)
			dbSelectArea(cAliasSFT)
			dbGoTop()
	#IFDEF TOP
		Endif
	#ENDIF

	cIndSFT	:=	CriaTrab(NIL,.F.)
		
	While !(cAliasSFT)->(Eof())	
		If cUF $ cMVSubTr
			nValor += (cAliasSFT)->VLICMSRET
		Endif		
      (cAliasSFT)->(dbSkip())
	Enddo

	#IFDEF TOP
		dbSelectArea(cAliasSFT)
		dbCloseArea()
	#ELSE
		dbSelectArea(cAliasSFT)
		RetIndex(cAliasSFT)
		Ferase(cIndSFT+OrdBagExt())
	#ENDIF

	RestArea(aArea)
	
Return nValor
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GIARSVAB  ºAutor  ³Rodrigo Aguilar     º Data ³  09/08/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Realiza a geracao da tabela VAB responsavel por alimentar  º±±
±±º          ³ os anexos V.A e V.B da GIARS                               º±±
±±º          ³ 								                              º±±
±±º          ³ Na Funcao RESUMEF3 eh criada a tabela (cAliasNotas) que    º±±
±±º          ³ contem todas as Notas Fiscais consideradas no periodo em   º±±
±±º          ³ que a GIA esta sendo emitida, esta funcao busca no cadastroº±±
±±º          ³ de TES a tabela da GIA de Isencao/Outros para cada item de º±±
±±º          ³ cada nota fiscal (Campos F4_TABGIAI e F4_TABGIAO) e gera-osº±±
±±º          ³ nos anexos V.A e V.B                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FISXAPUR                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GIARSVAB()
                   
Local cArqTRB       := ""    
// Arquivo do anexo III
Local cArqTRB3      := ""    
Local cTipoMov      := "" 
Local cItem         := ""
Local cTabela       := ""    

Local cAlias        := "VAB" 
Local cAliasNotas   := "NFSF3"
// Alias do anexo III
Local cAlias3        := "CRP"

Local aCampos    := {}
Local aTam       := {}      

Local lAnexoIII	:= .F.
Local lAnexoVAB	:= .F.

Local lTABGIARS := aExistBloc[PE_TABGIARS]

If !aApurSX3[FP_F4_TABGIAI] .Or. !aApurSX3[FP_F4_TABGIAO] .Or. !aApurSX3[FP_F4_TABGIAC] 
//	Criar campos onde serão informadas as tabelas de Isenção/Outros ou Crédito Presumido da GIA para geracao dos Anexos III, V.a e V.b "
	Return ({ cArqTRB, cArqTRB3 })
EndIf

                                               
DbSelectArea("SF4")
SF4->(DbSetOrder(1))

DbSelectArea("SFT")
SFT->(DbSetOrder(1))

DbSelectArea("SD2")
SD2->(DbSetOrder(3))

DbSelectArea("SD1")
SD1->(DbSetOrder(1))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Realiza a criacao da tabela temporaria "VAB" onde serao gravados os CFOP(s) para os Anexos V.a e V.b  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

aTam  	:= TAMSX3("F3_CFO")                               
AADD(aCampos,{"CFOP","C",aTam[1],aTam[2]})     			
    
    aTam    := TAMSX3("F4_TABGIAI")                               
AADD(aCampos,{"TABELA","C",aTam[1],aTam[2]})     					   					
		
aTam  	:= TAMSX3("F3_ISENICM")                                                                  			
AADD(aCampos,{"ISENICM"	,"N",aTam[1],aTam[2]})                         

aTam  	:= TAMSX3("F3_OUTRICM")                               
AADD(aCampos,{"OUTRICM"	,"N",aTam[1],aTam[2]}) 	                  
					
cArqTRB :=	CriaTrab(aCampos)
DbUseArea(.T.,__LocalDriver,cArqTRB,cAlias,.T.,.F.)

IndRegua(cAlias,cArqTRB,"CFOP+TABELA")      		 		 
 	
aCampos    := {}
aTam       := {}
 	
aTam    := TAMSX3("F4_TABGIAC")                               
AADD(aCampos,{"TABELA","C",aTam[1],aTam[2]})     					   					
   	
aTam  	:= TAMSX3("F3_CRDPRES")                               
AADD(aCampos,{"CRDPRES"	,"N",aTam[1],aTam[2]}) 	                    

cArqTRB3 :=	CriaTrab(aCampos)
DbUseArea(.T.,__LocalDriver,cArqTRB3,cAlias3,.T.,.F.)

IndRegua(cAlias3,cArqTRB3,"TABELA")  
                 
(cAliasNotas)->(DbGoTop())
While (cAliasNotas)->(!Eof())    	    			
        
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Conforme validacao contida no arquivo GIARS.INI devem ser consideradas apenas as notas fiscais de saida ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ            	

		cTipoMov 	:= Iif((cAliasNotas)->CFOP >="5","S","E")				
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona na tabela SFT de onde os valores de ICM Isento/Outros serao considerados³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			    
    	cChaveSFT := xFilial("SFT")+cTipoMov+Padr(AllTrim((cAliasNotas)->SERIE),TamSx3("FT_SERIE")[1])+;
    	             Padr(AllTrim((cAliasNotas)->NFISCAL),TamSx3("FT_NFISCAL")[1])+Padr(AllTrim((cAliasNotas)->CLIEFOR),TamSx3("FT_CLIEFOR")[1])+;
    	             Padr(AllTrim((cAliasNotas)->LOJA),TamSx3("FT_LOJA")[1]) 

		If SFT->(DbSeek(cChaveSFT))
			While SFT->(!Eof()) .And. SFT->FT_FILIAL == xFilial("SFT") .And. AllTrim(SFT->FT_TIPOMOV) == cTipoMov .And. ;
			     	 Padr(AllTrim((cAliasNotas)->SERIE),TamSx3("FT_SERIE")[1]) == SFT->FT_SERIE .And. ;
    	             Padr(AllTrim((cAliasNotas)->NFISCAL),TamSx3("FT_NFISCAL")[1]) == SFT->FT_NFISCAL .And. ;
    	             Padr(AllTrim((cAliasNotas)->CLIEFOR),TamSx3("FT_CLIEFOR")[1]) == SFT->FT_CLIEFOR .And. ;
    	             Padr(AllTrim((cAliasNotas)->LOJA),TamSx3("FT_LOJA")[1]) == SFT->FT_LOJA

    	       // Anexo V.a e V.b
				lAnexoVAB := cTipoMov == "S" .And. SFT->(FT_ISENICM+FT_OUTRICM) > 0
    	       // Anexo III
    	       If (SFT->FT_CRDPRES > 0)
    	        	lAnexoIII := .T.
   	           EndIf
   	           
				If lAnexoVAB .Or. lAnexoIII
					cTes	:= ""
					cItem	:= SFT->FT_ITEM
					If cTipoMov == "S" 
    		           cChaveSD2 := xFilial("SD2")+Padr(AllTrim((cAliasNotas)->NFISCAL),TamSx3("D2_DOC")[1])+Padr(AllTrim((cAliasNotas)->SERIE),TamSx3("D2_SERIE")[1])+;
				    				 	Padr(AllTrim((cAliasNotas)->CLIEFOR),TamSx3("D2_CLIENTE")[1])+Padr(AllTrim((cAliasNotas)->LOJA),TamSx3("D2_LOJA")[1])+;
			    					 	Padr(AllTrim(SFT->FT_PRODUTO),TamSx3("D2_COD")[1])+cItem
	    	           If SD2->(DbSeek(cChaveSD2))
    		             	cTes := SD2->D2_TES	    	             	
    		           EndIf 
    	        	Else
                		cChaveSD1	:= xFilial("SD1")+Padr(AllTrim((cAliasNotas)->NFISCAL),TamSx3("D1_DOC")[1])+Padr(AllTrim((cAliasNotas)->SERIE),TamSx3("D1_SERIE")[1])+;
										Padr(AllTrim((cAliasNotas)->CLIEFOR),TamSx3("D1_FORNECE")[1])+Padr(AllTrim((cAliasNotas)->LOJA),TamSx3("D1_LOJA")[1])+;
			    				 		Padr(AllTrim(SFT->FT_PRODUTO),TamSx3("D1_COD")[1])+cItem   
						If SD1->(DbSeek(cChaveSD1))
	    	             	cTes := SD1->D1_TES	    	             	
    		           EndIf 
					EndIf
					//Verifica tes
					If SF4->(DbSeek(xFilial("SF4")+Padr(cTes,TamSx3("F4_CODIGO")[1])))
						cTabela := ""
						If lAnexoVAB
							If SFT->FT_ISENICM > 0
								cTabela := StrZero(Val(SF4->F4_TABGIAI),TamSx3("F4_TABGIAI")[1]) 	 
							Else
								cTabela := StrZero(Val(SF4->F4_TABGIAO),TamSx3("F4_TABGIAO")[1])
							EndIf
							//Verifica se existe ponto de entrada
							If lTABGIARS
								cTabela := ExecBlock("TABGIARS",.F.,.F.,{"SFT","SF4"})
							EndIf
							//Gravo os valores de CFOP na tabela temporaria, agrupando por CFOP + TABELA, pois um CFOP pode
							//ter mais de uma tabela de acordo com o cadastro de TES
						If (cAlias)->(DbSeek(SD2->D2_CF+AllTrim(cTabela)))
							RecLock(cAlias,.F.)
						Else
						    RecLock(cAlias,.T.)
							(cAlias)->CFOP      := SD2->D2_CF
							(cAlias)->TABELA    := AllTrim(cTabela)  						    
	    				EndIf
						(cAlias)->ISENICM   += SFT->FT_ISENICM
						(cAlias)->OUTRICM	 += SFT->FT_OUTRICM							
						(cAlias)->(MsUnlock())
					
					EndIf

					If lAnexoIII

				      	cTabela := StrZero(Val(SF4->F4_TABGIAC),TamSx3("F4_TABGIAC")[1]) 
						
						If (cAlias3)->(DbSeek(AllTrim(cTabela)))
							RecLock(cAlias3,.F.)
						Else
						    RecLock(cAlias3,.T.)
							(cAlias3)->TABELA    := AllTrim(cTabela)		 						    
	    				EndIf
	    				
						(cAlias3)->CRDPRES   += SFT->FT_CRDPRES						
						(cAlias3)->(MsUnlock())
						EndIf
					EndIf
				EndIf								    	             	  								    	      	    	                	           
    			SFT->(DbSkip())         
			EndDo    	     
		EndIf		                  	    							
	(cAliasNotas)->(DbSkip())
EndDo	        				  				  
                  
Return ({cArqTRB, cArqTRB3})
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GIARSIII  ºAutor  ³Natalia Antonucci   º Data ³  02/10/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Realiza a geracao da tabela CRP responsavel por alimentar  º±±
±±º          ³ o anexos III da GIARS                                      º±±
±±º          ³ 								                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FISXAPUR                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GIARSIII()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ&¿
//³DESCONTINUADA - NÃO USAR³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ&Ù

Local cArqTRB       := ""    
/*
Local cTipoMov      := "" 
Local cItem         := ""
Local cTes 			:= ""
Local cTabela       := ""    

Local cAlias        := "CRP" 
Local cAliasNotas   := "NFSF3"

Local aCampos    := {}
Local aTam       := {}      
                        
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Realiza a criacao da tabela temporaria "CRP"   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(cAliasNotas)->(DbGoTop())
If (cAliasNotas)->(!Eof())
    
    aTam  	:= TAMSX3("F3_CFO")                               
	AADD(aCampos,{"CFOP","C",aTam[1],aTam[2]})     			
    
   	If SF4->(FieldPos("F4_TABGIAC")) <= 0
   		Aviso("UPDFIS"," Antes de executar a rotina é necessário rodar o UPDFIS para criação do campo onde serão informados "+;
	    " os Codigos da GIARS para geracÃo do Anexos III - Crédito Presumido ",{"Retorna"},3)	    
	Else                
	    aTam    := TAMSX3("F4_TABGIAC")                               
		AADD(aCampos,{"TABELA","C",aTam[1],aTam[2]})     					   					
   	Endif			
	aTam  	:= TAMSX3("F3_CRDPRES")                               
	AADD(aCampos,{"CRDPRES"	,"N",aTam[1],aTam[2]}) 	                    
	
	cArqTRB :=	CriaTrab(aCampos)
	DbUseArea(.T.,__LocalDriver,cArqTRB,cAlias,.T.,.F.)
	
	If SF4->(FieldPos("F4_TABGIAC")) <= 0
   		IndRegua(cAlias,cArqTRB,"CRDPRES") 
   	Else
   		IndRegua(cAlias,cArqTRB,"TABELA")  
   	Endif		     		 		 
EndIf
                 
(cAliasNotas)->(DbGoTop())
While (cAliasNotas)->(!Eof())    	    			                     
			            
   		cTipoMov 	:= Iif((cAliasNotas)->CFOP >="5","S","E")
	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona na tabela SFT         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   
		
		DbSelectArea("SFT")                    
		SFT->(DbSetOrder(1))
			    
    	cChaveSFT := xFilial("SFT")+cTipoMov+Padr(AllTrim((cAliasNotas)->SERIE),TamSx3("FT_SERIE")[1])+;
    	             Padr(AllTrim((cAliasNotas)->NFISCAL),TamSx3("FT_NFISCAL")[1])+Padr(AllTrim((cAliasNotas)->CLIEFOR),TamSx3("FT_CLIEFOR")[1])+;
    	             Padr(AllTrim((cAliasNotas)->LOJA),TamSx3("FT_LOJA")[1]) 
    	             
		
		If SFT->(DbSeek(cChaveSFT))
			While SFT->(!Eof()) .And. SFT->FT_FILIAL == xFilial("SFT") .And. AllTrim(SFT->FT_TIPOMOV) == cTipoMov .And. ;
			     	 Padr(AllTrim((cAliasNotas)->SERIE),TamSx3("FT_SERIE")[1]) == SFT->FT_SERIE .And. ;
    	             Padr(AllTrim((cAliasNotas)->NFISCAL),TamSx3("FT_NFISCAL")[1]) == SFT->FT_NFISCAL .And. ;
    	             Padr(AllTrim((cAliasNotas)->CLIEFOR),TamSx3("FT_CLIEFOR")[1]) == SFT->FT_CLIEFOR .And. ;
    	             Padr(AllTrim((cAliasNotas)->LOJA),TamSx3("FT_LOJA")[1]) == SFT->FT_LOJA
    	                   
    	         
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Considera apenas registros que possuam valores de Credito Presumido               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    	                   
				If SFT->FT_CRDPRES <= 0 
					SFT->(DbSkip())
					Loop
				EndIf    	                          
			    cItem := ""  
			               
    			If cTipoMov == "S" 
	    	    	cItem := StrZero(Val(AllTrim(SFT->FT_ITEM)),TamSx3("D2_ITEM")[1])
                ELSE
                    cItem := StrZero(Val(AllTrim(SFT->FT_ITEM)),TamSx3("D1_ITEM")[1])
                EndIf
                
            	cTes := ""
                 	                                      
				If cTipoMov == "S" 
			    	cChaveSD2 := xFilial("SD2")+Padr(AllTrim((cAliasNotas)->NFISCAL),TamSx3("D2_DOC")[1])+Padr(AllTrim((cAliasNotas)->SERIE),TamSx3("D2_SERIE")[1])+;
			    				 Padr(AllTrim((cAliasNotas)->CLIEFOR),TamSx3("D2_CLIENTE")[1])+Padr(AllTrim((cAliasNotas)->LOJA),TamSx3("D2_LOJA")[1])+;
			    				 Padr(AllTrim(SFT->FT_PRODUTO),TamSx3("D2_COD")[1])+cItem
    	                 	             
    	             DbSelectArea("SD2")
    	             SD2->(DbSetOrder(3))
    	             If SD2->(DbSeek(cChaveSD2))
    	             	cTes := SD2->D2_TES	    	             	
    	             EndIf                           	    	       
    	        Else
    	        	cChaveSD1 := xFilial("SD1")+Padr(AllTrim((cAliasNotas)->NFISCAL),TamSx3("D1_DOC")[1])+Padr(AllTrim((cAliasNotas)->SERIE),TamSx3("D1_SERIE")[1])+;
			    				 Padr(AllTrim((cAliasNotas)->CLIEFOR),TamSx3("D1_FORNECE")[1])+Padr(AllTrim((cAliasNotas)->LOJA),TamSx3("D1_LOJA")[1])+;
			    				 Padr(AllTrim(SFT->FT_PRODUTO),TamSx3("D1_COD")[1])+cItem   
			    				                                                                                                                                                                                                        
    	                 	             
    	             DbSelectArea("SD1")
    	             SD1->(DbSetOrder(1))
    	             If SD1->(DbSeek(cChaveSD1))
    	             	cTes := SD1->D1_TES	    	             	
    	             EndIf 
    	        EndIf
                
		   	        
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Posiciona na SF4 para buscar os codigos  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    	                                          	       
				DbSelectArea("SF4")
				SF4->(DbSetOrder(1))
				If SF4->(DbSeek(xFilial("SF4")+Padr(cTes,TamSx3("F4_CODIGO")[1]))) .and. SF4->(FieldPos("F4_TABGIAC")) > 0
					cTabela := ""                                         	       					
				    
					If SFT->FT_CRDPRES > 0  .and. SF4->(FieldPos("F4_TABGIAC")) > 0
			   			cTabela := StrZero(Val(SF4->F4_TABGIAC),TamSx3("F4_TABGIAC")[1]) 
					EndIf
									
					If cTipoMov == "S" 
						If (cAlias)->(DbSeek(cTabela))
							RecLock(cAlias,.F.)
						Else
						    RecLock(cAlias,.T.)
							(cAlias)->TABELA    := AllTrim(cTabela)		    
	    				EndIf
						(cAlias)->CRDPRES   += SFT->FT_CRDPRES						
						(cAlias)->(MsUnlock())
					Else
						If (cAlias)->(DbSeek(cTabela))
							RecLock(cAlias,.F.)
						Else
						    RecLock(cAlias,.T.)
							(cAlias)->TABELA    := AllTrim(cTabela)		 						    
	    				EndIf
						(cAlias)->CRDPRES   += SFT->FT_CRDPRES						
						(cAlias)->(MsUnlock())	
				 	Endif	
				EndIf								    	             	  								    	      	    	                	           
    			SFT->(DbSkip())         
			EndDo    	     
		EndIf		                  	    							
	(cAliasNotas)->(DbSkip())
EndDo	        				  				  
                  */
Return (cArqTRB)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FTitPreVazºAutor  ³Rodrigo Aguilar     º Data ³  17/04/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao que busca todos os titulos gerados pela rotina de   º±±
±±º          ³ apuracao de ICMS (MATA953) com o prefixo igual a vazio,    º±±
±±º          ³ nestes casos quando o cliente refaz a apuracao o sistema   º±±
±±º          ³ gera um novo titulo com prefixo ICM (Nova regra) e nao     º±±
±±º          ³ apaga o titulo gerado anteriormente.                       º±±
±±º          ³                                                            º±±
±±º          ³ Parametros:                                                º±±
±±º          ³                                                            º±±
±±º          ³ aNrTit -> Array que devera ser alimentado com todos os     º±±
±±º          ³           titulos que serao deletados da tabela SE2        º±±
±±º          ³                                                            º±±
±±º          ³ dDtIni -> Data de Inicio da Apuracao                       º±±
±±º          ³                                                            º±±
±±º          ³ dDtFim -> Data Final da Apuracao                           º±±
±±º          ³                                                            º±±
±±º          ³ nApuracao -> Tipo de Apuracao                              º±±
±±º          ³                                                            º±±
±±º          ³ nPeriodo -> Periodo de Apuracao                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ TOTVS                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FTitPreVaz(aNrTit,dDtIni,dDtFim,nApuracao,nPeriodo)

Local cAliasCDH := "CDH"  
Local cAliasSE2 := "SE2"

Local cChaveCDH := ""
Local cChaveSE2 := ""
Local cTipImp   := ""   
Local cTipoPr   := ""
Local cPeriodo  := ""  
Local cAuxPref  := Space(TamSx3("E2_PREFIXO")[1])

Local aArea    := GetArea()
Local aAreaCDH := GetArea("CDH")
Local aAreaSE2 := GetArea("SE2")

Default dDtIni    := CtoD("  /  /    ") 
Default dDtFim    := CtoD("  /  /    ")

Default aNrTit    := {}

Default nApuracao := 0
Default nPeriodo  := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona nas tabelas CDH e SE2 para verificar os titulos que foram gerados pela rotina³
//³de apuracao de ICMS(MATA953) e com o prefixo vazio                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea(cAliasCDH)
(cAliasCDH)->(DbSetOrder(1))

DbSelectArea(cAliasSE2)
(cAliasSE2)->(DbSetOrder(1))
		
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Variaveis utilizadas para busca do periodo apurado na tabela CDH³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cTipImp   := Padr("IC",TamSx3("CDH_TIPOIP")[1])	
cTipoPr   := Padr(Str(nApuracao,1),Tamsx3("CDH_TIPOPR")[1])	  
cPeriodo  := Padr(Str(nPeriodo,1),TamSx3("CDH_PERIOD")[1])               

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definindo chave de busca na tabela CDH³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cChaveCDH := xFilial(cAliasCDH)+cTipImp+cTipoPr+cPeriodo+DToS(dDtIni) 
	     
If (cAliasCDH)->(DbSeek(cChaveCDH))		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Busco dentro da tabela CDH (Apuracao de ICMS) o titulo que foi gerado para o periodo ICMS - PROPRIO³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	While (cAliasCDH)->(!Eof()) .And. ;
	      (cAliasCDH)->CDH_FILIAL+(cAliasCDH)->CDH_TIPOIP+(cAliasCDH)->CDH_TIPOPR+(cAliasCDH)->CDH_PERIOD+DToS((cAliasCDH)->CDH_DTINI) == cChaveCDH	        		  						  
		  		  
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Filtro para verificar se o registro atual esta dentro do periodo de apuracao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		  If (cAliasCDH)->CDH_DTFIM > dDtFim
			   (cAliasCDH)->(DbSkip())
		  		Loop
		  EndIf
		  		  
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Procuro dentro da tabela CDH a linha "TIT" que se refere ao titulo gerado para³
		//³o periodo de apuracao                                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		  If (cAliasCDH)->CDH_LINHA == Padr("TIT",TamSx3("CDH_LINHA")[1]) 
		        		        
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Define chave de busca na tabela SE2 utilizando o prefixo vazio e o numero³
				//³do titulo contido na tabela CDH                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		        cChaveSE2 := xFilial(cAliasSE2)+cAuxPref+(cAliasCDH)->CDH_NUMTIT
		        If (cAliasSE2)->(DbSeek(cChaveSE2))			  		
			  					  		
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Busco dentro da tabela SE2 todos os titulos com o mesmo prefixo e numero³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			  		While(cAliasSE2)->(!Eof()) .And.(cAliasSE2)->E2_FILIAL+(cAliasSE2)->E2_PREFIXO+E2_NUM == cChaveSE2				  		
				  		
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Verifico se o titulo foi gerado pela rotina de apuracao de ICMS, neste caso³
						//³incluo o mesmo no array para posterior exclusao na tabela SE2              ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				  		If Alltrim((cAliasSE2)->E2_ORIGEM) == "MATA953" 
					  		Aadd(aNrTit,{(cAliasSE2)->E2_PREFIXO,;
					  		                 (cAliasSE2)->E2_NUM,;
					  		                 (cAliasSE2)->E2_PARCELA,;
					  		                 (cAliasSE2)->E2_TIPO,;
					  		                 (cAliasSE2)->E2_FORNECE,;
					  		                 (cAliasSE2)->E2_LOJA})
					  	EndIf					  	
					  	(cAliasSE2)->(DbSkip())
					EndDo
			 	EndIf
		  EndIf	
		(cAliasCDH)->(DbSkip())	  
	EndDo                                         
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definindo chave de busca na tabela CDH³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cTipImp   := Padr("ST",TamSx3("CDH_TIPOIP")[1])
cChaveCDH := xFilial(cAliasCDH)+cTipImp+cTipoPr+cPeriodo+DToS(dDtIni) 

If (cAliasCDH)->(DbSeek(cChaveCDH))		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Busco dentro da tabela CDH (Apuracao de ICMS) o titulo que foi gerado para o periodo ICMS-ST³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	While (cAliasCDH)->(!Eof()) .And. ;
	      (cAliasCDH)->CDH_FILIAL+(cAliasCDH)->CDH_TIPOIP+(cAliasCDH)->CDH_TIPOPR+(cAliasCDH)->CDH_PERIOD+DToS((cAliasCDH)->CDH_DTINI) == cChaveCDH	        		  						  
		  		  
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Filtro para verificar se o registro atual esta dentro do periodo de apuracao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		  If (cAliasCDH)->CDH_DTFIM > dDtFim
			   (cAliasCDH)->(DbSkip())
		  		Loop
		  EndIf
		  		  
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Procuro dentro da tabela CDH a linha "TIT" que se refere ao titulo gerado para³
		//³o periodo de apuracao                                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		  If (cAliasCDH)->CDH_LINHA == Padr("TIT",TamSx3("CDH_LINHA")[1]) 
		        		        
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Define chave de busca na tabela SE2 utilizando o prefixo vazio e o numero³
				//³do titulo contido na tabela CDH                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		        cChaveSE2 := xFilial(cAliasSE2)+cAuxPref+(cAliasCDH)->CDH_NUMTIT
		        If (cAliasSE2)->(DbSeek(cChaveSE2))			  		
			  					  		
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Busco dentro da tabela SE2 todos os titulos com o mesmo prefixo e numero³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			  		While(cAliasSE2)->(!Eof()) .And.(cAliasSE2)->E2_FILIAL+(cAliasSE2)->E2_PREFIXO+E2_NUM == cChaveSE2				  		
				  		
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Verifico se o titulo foi gerado pela rotina de apuracao de ICMS, neste caso³
						//³incluo o mesmo no array para posterior exclusao na tabela SE2              ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				  		If Alltrim((cAliasSE2)->E2_ORIGEM) == "MATA953" 
					  		Aadd(aNrTit,{(cAliasSE2)->E2_PREFIXO,;
					  		                 (cAliasSE2)->E2_NUM,;
					  		                 (cAliasSE2)->E2_PARCELA,;
					  		                 (cAliasSE2)->E2_TIPO,;
					  		                 (cAliasSE2)->E2_FORNECE,;
					  		                 (cAliasSE2)->E2_LOJA})
					  	EndIf					  	
					  	(cAliasSE2)->(DbSkip())
					EndDo
			 	EndIf
		  EndIf	
		(cAliasCDH)->(DbSkip())	  
	EndDo	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restauro a area do sistema ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaCDH) 
RestArea(aAreaSE2)
RestArea(aArea)

Return (Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FCrPreMt  ºAutor  ³Rodrigo Aguilar     º Data ³  12/07/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Decreto 1.006/2012 -  artigo 8-A do Anexo IX Estado MT     º±±
±±º          ³                                                            º±±
±±º          ³ Realiza o calculo do credito presumido para produtos do    º±±
±±º          ³ tipo algodao para o Estado do MT                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Credito Presumido MT                                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FCrPreMt(cAliasSF3,aNfDupl) 

Local nVlCred   := 0 
Local nI        := 0
   
Local cNumNf      := (cAliasSF3)->F3_NFISCAL
Local cSerNf      := (cAliasSF3)->F3_SERIE
Local cCliente    := (cAliasSF3)->F3_CLIEFOR
Local cLoja       := (cAliasSF3)->F3_LOJA   
Local cMVCCPB1MT  := GetNewPar("MV_CCPB1MT"," ") 

Local cAlSA2 := "SA2"
Local cAlSB1 := "SB1"

Local aNfEntOr  := {}
                                            
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Guardando areas das tabelas antes da execucao³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local cAreaSA2  := (cAlSA2)->(GetArea())
Local cAreaSB1  := (cAlSB1)->(GetArea())

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Preparando tabelas para busca de registros³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea(cAlSA2)
(cAlSA2)->(DbSetOrder(1))

DbSelectArea(cAlSB1)
(cAlSB1)->(DbSetOrder(1))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para caso exista a quebra da mesma NF para o mesmo CFOP ³
//³e Aliquota nao processar em duplicidade                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aScan(aNfDupl,{|x| x[1] ==  (cAliasSF3)->F3_NFISCAL .And. ;
                      x[2] ==  (cAliasSF3)->F3_SERIE .And. ;
                      x[3] ==  (cAliasSF3)->F3_CLIEFOR .And. ;
                      x[4] ==  (cAliasSF3)->F3_LOJA}) <= 0
                         	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Busca a NF de origem do produto que foi vendido, verifica pelo Lote/SubLote  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aNfEntOr := RastroNFOr(cNumNf,cSerNf,cCliente,cLoja)                                                              	
	
	If !Empty(cMVCCPB1MT) .And. SB1->(FieldPos(cMVCCPB1MT)) > 0  
		For nI:=1 To Len(aNfEntOr)		 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Busco Produto na tabela SB1³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If  (cAlSB1)->(DbSeek(xFilial("SB1")+aNfEntOr[nI][3])) 
				If !Empty(SB1->(&(cMVCCPB1MT)))
					If Alltrim(SB1->(&(cMVCCPB1MT))) == "1"
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Busco Fornecedor da NF de Origem no cadastro SA2³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If (cAlSA2)->(DbSeek(xFilial(cAlSA2)+aNfEntOr[nI][8]+aNfEntOr[nI][9]))			
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Verifico se o Fornecedor eh Produtor Rural e se esta localizado no³
							//³Estado do MT                                                      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If !Empty((cAlSA2)->A2_TIPORUR) .And. (cAlSA2)->A2_EST == "MT"				
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Se o item de Entrada gerou credito de ICMS cliente nao         ³
								//³tem direito ao credito presumido                               ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ				
								If aNfEntOr[nI][13] == 0 .And. Alltrim(aNfEntOr[nI][31]) == "1101"
					 				nVlCred := aNfEntOr[nI][43] - ((aNfEntOr[nI][39]+aNfEntOr[nI][40]+aNfEntOr[nI][41]+aNfEntOr[nI][42])*0.03)
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		Next                                                        
	EndIf
EndIf
	                     	                                        	
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validacao para verificar se o valor do credito esta negativo, caso esteja³
//³zero o valor da variavel                                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nVlCred <= 0
	nVlCred := 0
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Volta a Area Original Antes do Processamento ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(cAreaSA2)	
RestArea(cAreaSB1)	

Return nVlCred
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³DetReceitaºAutor  ³Natalia Antonucci    º Data ³  27/06/2012º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao que busca o Detalhamento da Receita em casa Estado  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ TOTVS                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function DetReceita(cPar,cUf,cCodRec)
	
Local cMVGNREDET	:= ""
Local aMVGNREDET	:= {}
Local cDetRec		:= ""
Local nPosI			:= 0
Local nPosF			:= 0
Local aAreaSX6		:= SX6->(GetArea())

Default	cPar	:= ""
Default cUf		:= ""
Default cCodRec := ""

cPar	:=	AllTrim(cPar)

DbSelectArea ("SX6") 
SX6->(DbSetOrder (1))

If SX6->(DbSeek (cFilAnt+cPar))
	
	Do While !SX6->(Eof ()) .And. (cPar$SX6->X6_VAR) .And. (cFilAnt==SX6->X6_FIL) 
		If SubStr(SX6->X6_CONTEUD,1,1) <> "{"
			If !Empty(SX6->X6_CONTEUD)
				cMVGNREDET += "/"+AllTrim (SX6->X6_CONTEUD)
			EndIf
		Else
			If !Empty(SX6->X6_CONTEUD)
				aMVGNREDET := &(AllTrim(SX6->X6_CONTEUD))
			EndIf
		EndIf
		SX6->(DbSkip ())
	EndDo   
	If !Empty(cMVGNREDET)
		If At (cUf,cMVGNREDET) > 0
			nPosI	:=	At (cUf,cMVGNREDET)+2
			nPosF	:=	At ("/", SubStr (cMVGNREDET, nPosI))-1
			nPosF	:=	IIf(nPosF<=0,len(cMVGNREDET),nPosF)
			cDetRec	:=	SubStr(cMVGNREDET,nPosI,nPosF)
		EndIf
	ElseIf Len(aMVGNREDET) > 0 	
		nPosDet := aScan( aMVGNREDET, { |x| AllTrim(x[2]) == AllTrim(cCodRec) .And. SubStr(X[1],1,2) == AllTrim(cUf)  } )
		cDetRec := Iif( nPosDet > 0,AllTrim(SubStr(aMVGNREDET[nPosDet][1],3,25)),"")
	EndIf
EndIf	

If SX6->(DbSeek (PadR("",FWGETTAMFILIAL)+cPar))

	Do While !SX6->(Eof ()) .And. (cPar$SX6->X6_VAR) .And. Empty(SX6->X6_FIL)
		If SubStr(SX6->X6_CONTEUD,1,1) <> "{"
			If !Empty(SX6->X6_CONTEUD)
				cMVGNREDET += "/"+AllTrim (SX6->X6_CONTEUD)
			EndIf
		Else
			If !Empty(SX6->X6_CONTEUD)
				aMVGNREDET := &(AllTrim(SX6->X6_CONTEUD))
			EndIf
		EndIf
		SX6->(DbSkip ())
	EndDo     
	If !Empty(cMVGNREDET)
		If At (cUf,cMVGNREDET) > 0
			nPosI	:=	At (cUf,cMVGNREDET)+2
			nPosF	:=	At ("/", SubStr (cMVGNREDET, nPosI))-1
			nPosF	:=	IIf(nPosF<=0,len(cMVGNREDET),nPosF)
			cDetRec	:=	SubStr(cMVGNREDET,nPosI,nPosF)
		EndIf
	ElseIf Len(aMVGNREDET) > 0 	
		nPosDet := aScan( aMVGNREDET, { |x| AllTrim(x[2]) == AllTrim(cCodRec) .And. SubStr(X[1],1,2) == AllTrim(cUf)  } )
		cDetRec := Iif( nPosDet > 0,AllTrim(SubStr(aMVGNREDET[nPosDet][1],3,25)),"")
	EndIf
EndIf	

RestArea(aAreaSX6)

Return cDetRec  

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³SomaData ºAutor  ³Natalia Antonucci    º Data ³  27/06/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao que busca a Data Valida considerando os dias uteis  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ TOTVS                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function SomaData(nMVDATPAG,dDataRef) 

Local nX := 1

While nX <= nMVDATPAG +1
  If DataValida(dDataRef,.T.) == dDataRef
    If nX <= nMVDATPAG
      dDataRef += 1
    EndIf
    nX +=1
  Else
    dDataRef += 1
  Endif
EndDo 
    
Return DataValida(dDataRef,.T.)  

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ProdGnre  ºAutor  ³Natalia Antonucci   º Data ³  27/06/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao que busca o Codigo do Produto atraves do parametro  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ TOTVS                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function ProdGnre(cUf)

Local cMVCODPROD	:= ""
Local cProduto		:= ""
Local nPosI			:= 0
Local nPosF			:= 0
Local cCodMV		:= ""

cCodMV := SuperGetMV("MV_GNREPRO",,,cFilAnt)

If !Empty(cCodMV)
	cMVCODPROD += "/"+AllTrim (cCodMV)
	If At (cUf,cMVCODPROD) > 0
		nPosI	:=	At (cUf,cMVCODPROD)+2
		nPosF	:=	At ("/", SubStr (cMVCODPROD, nPosI))-1
		nPosF	:=	IIf(nPosF<=0,len(cMVCODPROD),nPosF)
		cProduto	:=	SubStr(cMVCODPROD,nPosI,nPosF)
	EndIf	
EndIf

Return LEFT(cProduto,TamSx3("F6_CODPROD")[1])  

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RefGnre   ºAutor  ³Natalia Antonucci   º Data ³  27/06/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao que busca a referencia atraves do parametro         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ TOTVS                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function RefGnre(cUf)
	
Local cMVREFEREN	:= ""
Local cReferen		:= ""
Local nPosI			:= 0
Local nPosF			:= 0
Local aAreaSX6		:= SX6->(GetArea())

DbSelectArea("SX6")
SX6->(DbSetOrder(1))

If SX6->(DbSeek(cFilAnt+"MV_GNREREF"))
	
	Do While !SX6->(Eof ()) .And. ("MV_GNREREF"$SX6->X6_VAR) .And. (cFilAnt==SX6->X6_FIL)
		If !Empty(SX6->X6_CONTEUD)
			cMVREFEREN += "/"+AllTrim (SX6->X6_CONTEUD)
		EndIf
		SX6->(DbSkip ())
	EndDo   
	If At (cUf,cMVREFEREN) > 0
		nPosI	:=	At (cUf,cMVREFEREN)+2
		nPosF	:=	At ("/", SubStr (cMVREFEREN, nPosI))-1
		nPosF	:=	IIf(nPosF<=0,len(cMVREFEREN),nPosF)
		cReferen:=	SubStr(cMVREFEREN,nPosI,nPosF)
	EndIf
EndIf	

If SX6->(DbSeek (PadR("",FWGETTAMFILIAL)+"MV_GNREREF"))

	Do While !SX6->(Eof ()) .And. ("MV_GNREREF"$SX6->X6_VAR) .And. Empty(SX6->X6_FIL)
		If !Empty(SX6->X6_CONTEUD)
			cMVREFEREN += "/"+AllTrim (SX6->X6_CONTEUD)
		EndIf
		SX6->(DbSkip ())
	EndDo     
	If At(cUf,cMVREFEREN) > 0
		nPosI	:=	At (cUf,cMVREFEREN)+2
		nPosF	:=	At ("/", SubStr (cMVREFEREN, nPosI))-1
		nPosF	:=	IIf(nPosF<=0,len(cMVREFEREN),nPosF)
		cReferen:=	SubStr(cMVREFEREN,nPosI,nPosF)
	EndIf	
EndIf	


RestArea(aAreaSX6)
Return cReferen

//-------------------------------------------------------------------
/*/{Protheus.doc} xApGetIncent
Funcao responsavel por fazer calculo de incentivos fiscais
	
@param	cIncent		-> Incentivo Fiscal que sera processado
		cAlias		-> Alias da tabela que esta sendo processada
		lMThread	-> Indica se esta sendo chamada a partir de um processo
					   de Multi-Thread
		aPar		-> Parametros especificos do Incentivo Fiscal
		
@return aRet		-> Array com dados especificos do Incentivo Fiscal
		

@author Luccas Curcio
@since 14/05/2013
@version 1.0
/*/
//-------------------------------------------------------------------
Function xApGetIncent( cIncent , cAlias , lMThread , aPar )
Local	aCfop		:=	xApCfopDef( cIncent )
Local	cPrfxLivro	:=	""
Local	aRet		:=	Nil
Local	nPos		:=	0
Local	nPos2		:=	0
Local	nX			:=	0
Default	lMThread	:=	.F.

cPrfxLivro	:=	Iif(lMThread,"FT_","F3_")

		/*------------------------------------------------------------------------------------------------------
		
						DESENVOLVE - BA												PRODEC - SC
		
		 ------------------------------------------------------------------------------------------------------
		
			Programa de Desenvolvimento Industrial e 					Programa de Desenvolvimento da Empresa
			de Integracao Economica do Estado da Bahia								Catarinense
		
		 ------------------------------------------------------------------------------------------------------
		
			Embasamento legal:
		
			Resolucao  No 123/2009 (regime especial),					LEI Nº 13.342, de 10 de março de 2005, 
			Lei no 7.980/2001 e Decreto no 8.205/2002				regime especial concedido ao cliente pela SEFAZ/SC
		
		 ------------------------------------------------------------------------------------------------------*/
		 
If cIncent $ "DES | PDC"

	/*---------------------------------------------------------------------------------------
	
		aPar - Parametro 4 da funcao
	
	  ---------------------------------------------------------------------------------------
		Array com as opcoes de processamento, passada como parametro na chamada da funcao
	  ---------------------------------------------------------------------------------------
	
		[01] - Tipo do Processamento
			1 - Validacao e calculo das operacoes
			2 - Valores calculados sobre a formula
				do Incentivo
		[02] - Periodo de Apuracao
		[03] - FieldPos de campo especifico
		[04] - Codigo do produto
		[05] - Conteudo do Parametro MV_X
			->	[05,01] - Prazo de Fruicao do
				Incentivo
			->	[05,02] - Percentual do Incentivo
			->	[05,03] - Percentual do Incentivo
						  Auxiliar				
			->	[05,04] - Quantidade de Meses ate
						  o vencimento da GNRE
			->	[05,05] - Quantidade de Meses ate
						  o vencimento da GNRE	
						  Auxiliar				
			->	[05,06] - Dia do Vencimento da GNRE
			->	[05,07] - Dia do Vencimento da GNRE
						  Auxiliar				
			->	[05,08] - Codigo do Incentivo nas	
						  Linhas de Deducoes (Apuracao)
			->	[05,09] - Prefixo do Titulo Financeiro
			->	[05,10] - Codigo da Natureza Financeira
			->	[05,11] - Prefixo do Titulo Financeiro
						  Auxiliar
			->	[05,12] - Codigo da Natureza Financeira
						  Auxiliar
							
	  --------------------------------------------------------------------------------------- */
	
	//-------------------------------------------------------------------------------------------
	//Verifica se a operacao se enquadra na lista de CFOP's e retorna valor do imposto
	//-------------------------------------------------------------------------------------------
	If aPar[1] == 1
		
		If Len(aPar[5]) >= 10 .And. aPar[2] <= CToD(aPar[5,1])
			If ( cIncent $ "DES" )
				
				If GetNewPar( 'MV_ARQPROD' , '' ) == "SBZ" .And. SBZ->(MsSeek(xFilial("SBZ")+aPar[4]))
					If aApurSX3[FP_BZ_PROJDES]
						If SBZ->BZ_PROJDES <> "1"
							aRet	:=	{ ( cAlias )->FT_VALICM , 0 }
						Elseif SBZ->BZ_PROJDES == "1" .And. allTrim(( cAlias )->FT_CFOP)$"5910|5911|5912|6910|6911|6912|1910|1911|1912|2910|2911|2912"
							aRet	:=	{ ( cAlias )->FT_VALICM , ( cAlias )->FT_VALICM }
						Endif
					Endif
				Elseif SB5->(MsSeek(xFilial("SB5")+aPar[4]))
					If aPar[3] //FieldPos -> B5_PROJDES
						If SB5->B5_PROJDES <> "1"
							aRet	:=	{ ( cAlias )->FT_VALICM , 0 }
						Elseif SB5->B5_PROJDES == "1" .And. allTrim(( cAlias )->FT_CFOP)$"5910|5911|5912|6910|6911|6912|1910|1911|1912|2910|2911|2912"
							aRet	:=	{ ( cAlias )->FT_VALICM , ( cAlias )->FT_VALICM }
						Endif
					Endif
				Else
					aRet	:=	{ ( cAlias )->FT_VALICM , 0 }
				Endif
			
			Elseif ( cIncent $ "PDC" .And. Alltrim(( cAlias )->F3_CFO)$aCfop[1] .And. !Alltrim(( cAlias )->F3_CFO)$aCfop[2] )
				aRet	:=	{ ( cAlias )->(&(cPrfxLivro+"VALICM")) , 0 }
			Endif
		Endif
			
	//-------------------------------------------------------------------------------------------
	//Valores calculados sobre a formula do Incentivo, retornando imposto para geracao das guias
	//-------------------------------------------------------------------------------------------
   Elseif aPar[1] == 2
	    
		aPar[5]	:=	Iif(aPar[5] == Nil ,;
							Iif( cIncent == "DES" , &(GetNewPar("MV_DESENV","{}") ) , &(GetNewPar("MV_FISPRDC","{}") ) ) ,;
							aPar[5] )
	
		IF Len(aPar[5]) > 0
			If aCols5 <> Nil
				    
			    /*-------------------------------------------------------
				
					aRet - Array de retorno da rotina
				
				 -------------------------------------------------------
				
				[01] -		Saldo Devedor / Valor total do Incentivo a ser gerado em Deducoes
				[02] - 	Valor da GNRE - Antecipação do imposto ( incentivo fiscal )
				[03] - 	Valor da GNRE Auxiliar
				[04] - 	Data de Vencimento - Antecipação do imposto ( incentivo fiscal )
				[05] - 	Data de Vencimento do Incentivo - Auxiliar
				[06] - 	Prefixo do Titulo Financeiro - Antecipação do imposto ( incentivo fiscal )
				[07] - 	Codigo da Natureza Financeira - Antecipação do imposto ( incentivo fiscal )
				[08] - 	Prefixo do Titulo Financeiro Auxiliar
				[09] - 	Codigo da Natureza Financeira Auxiliar
				 ------------------------------------------------------- */
				aRet	:=	{}
				
				aAdd(aRet,0)
				aAdd(aRet,0)
				aAdd(aRet,0)
				aAdd(aRet,cToD("//"))
				aAdd(aRet,cToD("//"))
				aAdd(aRet,"")
				aAdd(aRet,"")
				aAdd(aRet,"")
				aAdd(aRet,"")
			
				// -----------------------------------------------------------------------------
				// Definicao da sub-lnha que sera utilizada em Deducoes (012) para demonstracao
				//  dos valores do Incentivo Fiscal
				// -----------------------------------------------------------------------------
				
				//necessita pelo menos das 8 primeiras posicoes do parametro MV_DESENV
				If len( aPar[ 5 ] ) >= 8
				
					// Default: Utiliza a linha 012.12
					If aPar[5,8] == Nil
						aPar[5,8]	:=	"012.02"
					Endif
				    
					// Pesquisa a posicao de deducoes no aCols5 (Apuracao-ICMS)
					If (nPos	:=	aScan( aCols5, { |x| Alltrim(x[2]) == aPar[5,8]}) ) > 0
					    
						// Linha de Saldo Devedor
						nPos2	:=	aScan( aCols5, { |x| x[1] == "011"})
						
						// --------------------------------------------------------------
						// Prodec/SC -> Atribuo valor do Incentivo neste momento apenas
						If cIncent == "PDC"
							aCols5[nPos][4]	:=	( aCols5[nPos2][4] * aPar[5,2] ) / 100
						Elseif cIncent == "DES"
							nAuxIncent	:=	aCols5[nPos][4]
							//aCols5[nPos][4]	:=	( ( aCols5[nPos2][4] - aCols5[nPos][4] )  * aPar[5,2] ) / 100
							//aCols5[nPos][4]	:=	( ( aCols5[nPos][4] + aCols5[nPos2][4] ) * aPar[5,2] ) / 100
							aCols5[nPos][4]	:=	( aCols5[nPos][4] * aPar[5,2] ) / 100
						Endif
						// --------------------------------------------------------------
						
						// Verifica saldo apos aplicacao do Incentivo Fiscal
						If aCols5[nPos2][4] - ( ( aCols5[nPos][4] * aPar[5,2] ) / 100 )  > 0
						
							//aRet[1]	:=	aCols5[nPos2][4] - ( ( aCols5[nPos][4] * aPar[5,2] ) / 100 )
							aRet[1]	:=	aCols5[nPos][4]
							
							// ----------------------------------------------------------------------------------------
							// Valor da GNRE
							
							//   Tratamento especifico por Incentivo:
							
							// Desenvolve: Aplica percentual sobre o Saldo Devedor 
							If cIncent == "DES"
								//primeiro eu encontro o valor de 100% do incentivo e depois multiplico pelo % de antecipação
								//pois o retorno [2] representa o valor da guia de antecipação
								aRet[2]	:=	( aCols5[nPos][4] * 100 / aPar[5,2] ) * aPar[5,3] / 100 
			
							// Prodec: Valor da GNRE eh o valor gerado em Deducoes (abaixo deduz valor do Famdes)
							Elseif cIncent == "PDC"
								aRet[2]	:=	aCols5[nPos][4]
							Endif
							// ----------------------------------------------------------------------------------------		
							
							
							// ----------------------------------------------------------------------------------------
							// Valor da GNRE Auxiliar
							
							//   Tratamento especifico por Incentivo:
							
							// Desenvolve (Parcela Antecipada): Aplica percentual sobre o Saldo Devedor 
							If cIncent == "DES"
								//aRet[3]	:=	(aRet[1] * aPar[5,3]) / 100
								aRet[3]	:=	aRet[1]
							
							// Prodec (Famdes): Aplica percentual sobre o valor do Prodec e desconta da GNRE principal
							Elseif cIncent == "PDC"
								aRet[3]	:=	(aRet[2] * aPar[5,3]) / 100
								aRet[2]	:=	aRet[2] - aRet[3]
							Endif
							// ----------------------------------------------------------------------------------------
							
							// Desenvolve: Atribuo o valor de Deducao Calculado acima
							If cIncent == "DES"
								aCols5[nPos][4]	:=	aRet[1]
							Endif
							
							// Vencimentos ( GNRE / Titulo )
							aRet[4]	:=	xApGetDate( aPar[2] , 2 , aPar[5,4] , aPar[5,6] )
							aRet[5]	:=	xApGetDate( aPar[2] , 2 , aPar[5,5] , aPar[5,7] )
							
							// Informacoes Financeiras ( Posicoes 9 a 12 da dimensao 5 do array aPar )
							If Len( aPar[5] ) > 8
								If aPar[5,9] <> Nil
									aRet[6]	:=	AllTrim(aPar[5,9])
								Endif
								If Len( aPar[5] ) > 9 .And. aPar[5,10] <> Nil
									aRet[7]	:=	AllTrim(aPar[5,10])
								Endif
								If Len( aPar[5] ) > 10 .And. aPar[5,11] <> Nil
									aRet[8]	:=	AllTrim(aPar[5,11])
								Endif
								If Len( aPar[5] ) > 11 .And. aPar[5,12] <> Nil
									aRet[9]	:=	AllTrim(aPar[5,12])
								Endif
							Endif
							
						Endif
					Endif
				Endif
			Endif
		EndIF
	Endif
		
		/*------------------------------------------------------------------------------------------------------
		
														INVEST - ES
		
		 ------------------------------------------------------------------------------------------------------
		
			Embasamento legal:
		
			alineas a, b, c,d,e do inciso I e incisos II, III e IV do artigo 3º do Decreto nº 1.951-R de 25/10/2007
		
		 ------------------------------------------------------------------------------------------------------*/
Elseif cIncent = "INV"
    
    // -------------------------------------------------------
	// 1.Credito Presumido
	// -------------------------------------------------------
	If aPar[1] == 1

		nPos	:= aScan( aCols5, { |x| x[1] == "013" } )
		nPos2	:= aScan( aCols6, { |x| x[1] == "015" } )
		nPos3	:= aScan( aCols5, { |x| Alltrim(x[2]) == "006.01" } )
		
		
		If aCols5[nPos,4] > 0 .And. !Empty(aPar[3,2]) .And. nPos3 > 0
		
			aCols5[ nPos3 , 4 ] := Iif(  ( aCols5[ nPos , 4 ] * aPar[3,2] ) / 100 > aCols6[ nPos2 , 4 ],;
										aCols6[ nPos2 , 4 ],;
										( aCols5[ nPos , 4 ] * aPar[3,2] ) / 100 )
										
		Endif
	
	// -------------------------------------------------------
	// 2.Estorno de Debito
	// -------------------------------------------------------	
	Elseif aPar[1] == 2
	
		nPos	:= aScan( aCols5, { |x| x[1] == "013" } )
		nPos2	:= aScan( aCols5, { |x| Alltrim(x[2]) == "007.01" } )

		If !Empty(nPos) .And. !Empty(nPos2)	.And. !Empty(aPar[3,3])
			aCols5[ nPos2 , 4 ] := ( aCols5[ nPos , 4 ] * aPar[3,3] ) / 100
		EndIf
	
	// -------------------------------------------------------
	// 3.Estorno de Credito
	// -------------------------------------------------------	
	Elseif aPar[1] == 3
	
		aRet	:=	{}
		For nX := 1 To 8
			aAdd( aRet , Nil )
		Next nX
		
		If Len( aRet[8] := &(GetNewPar("MV_INVETES","{}") ) ) > 0
	    	
	    	// -------------------------------------------------------
			//aRet[1] -> Somatorio de Debito de ICMS interno
			aRet[1] := 0
			For nX := 1 To Len ( aCols2 )
				If Substr( aCols2[nX][1] , 1 , 1 ) == "5" .And. aCols2[nX][1] <> "5949"
					aRet[1]	+=	aCols2[nX][4]
				Endif
			Next nX
			
			// -------------------------------------------------------
			//aRet[2] -> Total de Saidas
			// -------------------------------------------------------
			nPos	:=	aScan( aCols5, { |x| x[1] == "001" } )
			aRet[2]	:=	aCols5[nPos][4]
			
			// -------------------------------------------------------
			//aRet[3] -> Percentual do ICMS Interno
			// -------------------------------------------------------
			aRet[3]	:=	( aRet[1] / aRet[2] ) * 100
			
			// -------------------------------------------------------
			//aRet[4] -> Proporcao de Reducao de Base de Calculo
				
			//	Chamada recursiva de xApGetIncent, utilizando a
			//	opcao 4 - Proporcao de Reducao de Base de Calculo
			// -------------------------------------------------------
			aRet[4]	:=	xApGetIncent( "INV" , , , {4,aRet[8],.F.} )[3]
			
			// -------------------------------------------------------
			//aRet[5] -> Total de Creditos
			// -------------------------------------------------------
			nPos	:=	aScan( aCols5, { |x| x[1] == "005" } )
			aRet[5]	:=	aCols5[nPos][4]
			
			// -------------------------------------------------------
			//aRet[6] -> Total de Creditos pelo percentual de Saidas internas
			// -------------------------------------------------------
			aRet[6]	:=	Round( ( aRet[5] * aRet[3] ) / 100 , 2 )
			
			// -------------------------------------------------------
			//aRet[7] -> Credito ja aplicado percentual das saidas, pela Reducao Proporcional
			// -------------------------------------------------------
			aRet[7]	:=	Round( ( aRet[6] * aRet[4] ) / 100 , 2 )
						
			// -------------------------------------------------------
			// Preencho linha da apuracao com o valor calculado
			// -------------------------------------------------------
			If aRet[7] > 1
				nPos2	:= aScan( aCols5, { |x| Alltrim(x[2]) == "003.01" } )
				aCols5[ nPos2 , 4 ] := Iif( aRet[7] > 1 , aRet[7] , 0 )
			Endif
		
		Endif
		
	// -------------------------------------------------------
	// 4.Proporcao de Reducao de Base de Calculo
	// -------------------------------------------------------	
	Elseif aPar[1] == 4
	    
	    // -------------------------------------------------------
		// Chamada desta opcao a partir da Apuracao de ICMS
		// -------------------------------------------------------
		If !aPar[3]
	
			aRet	:=	{}
			For nX := 1 To 3
				aAdd( aRet , 0 )
			Next nX
			
			For nX := 1 To Len( aPar[2] )
				If SF4->( MsSeek ( xFilial("SF4")+aPar[2][nX] ) )
					aRet[1]	+=	1
					aRet[2]	+=	SF4->F4_BASEICM
				Endif
			Next nX
			
			//Proporcao de Reducao de Base de Calculo
			aRet[3]	:=	Round( aRet[2] / aRet[1] , 2 )
		
		// -------------------------------------------------------
		// Chamada desta opcao a partir do relatorio de conferencia
		// Retorna String com os codigos de TES
		// -------------------------------------------------------
		Else
		
			aRet	:=	{}
			aAdd( aRet , "" )

			For nX := 1 To Len( aPar[2] )
				If SF4->( MsSeek ( xFilial("SF4")+aPar[2][nX] ) )
					aRet[1]	+=	SF4->F4_CODIGO + ", "
				Endif
			Next nX
			
			For nX := 1 To Len(aRet)
				//Exclui a virgula desnecessaria da string
				If !Empty(aRet[nX])
					aRet[nX]	:=	Substr(aRet[nX],1,Len(aRet[nX])-2)
				Endif
			Next nX
			
		Endif
	
	Endif
	
Endif

//Caso o retorno seja nulo, devo retornar conforme tratamento do incentivo
If aRet == Nil
	If cIncent == "DES"
		aRet	:=	Iif(aPar[1] == 1,{0,0},{})
	Endif
Endif

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} xApGetDate
Funcao responsavel por retornar data prevista
	
@param	dData	-> Data atual
		nTpData	-> Qual elemento da data deseja calcular
		nQuant	-> Quantidade futura prevista (exemplo: 70 meses apos
				   a data atual )
		nNewDay	-> Dia previsto da data a ser retornada
		
@return dNewDate-> Nova data (previsao)
		

@author Luccas Curcio
@since 14/05/2013
@version 1.0
/*/
//-------------------------------------------------------------------
Function xApGetDate( dData , nTpData , nQuant , nNewDay )
Local	dNewDate	:=	CToD("//")
Local	nX			:=	0
Local	nDay		:=	0
Local	nMonth		:=	0
Local	nYear		:=	0

//Contagem de mes
If nTpData == 2

	nDay	:=	Day(dData)
	nMonth	:=	Month(dData)
	nYear	:=	Year(dData)

	For nX := 1 To nQuant
	
		nMonth	+=	1
		
		If nMonth == 13
			nMonth	:= 1
			nYear	+= 1
		Endif
		
	Next nX
Endif

If nNewday <> Nil
	nDay	:=	nNewDay
Endif

dNewDate	:=	CToD(Str(nDay)+"/"+Str(nMonth)+"/"+Str(nYear))

Return dNewDate

//-------------------------------------------------------------------
/*/{Protheus.doc} xApCfopDef
Funcao responsavel por retornar CFOP's que deverao ser considerados
para determinado processamento
	
@param	cLegis	-> Legislacao que deseja verificar
		lQuery	-> Indica se retorna string a ser comparada em query
		
@return aRet-> Array bi-dimensional com codigos que devem e que nao devem
			   ser considerados no processamento
		

@author Luccas Curcio
@since 14/05/2013
@version 1.0
/*/
//-------------------------------------------------------------------
Function xApCfopDef( cLegis , lQuery )
Local	aRet		:=	{"",""}
Local	nX			:=	0
Local	cAliasQry	:=	""
Local	cAux		:=	""
Default	lQuery		:=	.F.

//--------------------------
//		DESENVOLVE - BA		
//--------------------------
If cLegis == "DES"
   	
   	//-------------------------------------------------------------------------------------
	//CFOP's de Credito (CNVP)
	cAux	:=	Alltrim( GetNewPar("MV_DSVIC","") )
	/*aRet[1]	:=	"'1102','2102','3102','1113','2113','1117','2117','1118','2118','1121','2121','1124','2124','1125',"
	aRet[1]	+=	"'2125','1126','2126','1152','2152','1153','2153','1154','2154','1350','2350','1400','2400','1500',"
	aRet[1]	+=	"'2500','1550','2550','1600','2600','1650','2650',"*/
	aRet[1]	:=	"'1900','2900','1901','2901','1902','2902','1903','2903','1904','2904','1905','2905','1906','2906'"
	aRet[1]	+=	"'1907','2907','1908','2908','1909','2909','1910','2910','1911','2911','1912','2912','1913','2913'"
	aRet[1]	+=	"'1914','2914','1915','2915','1916','2916','1917','2917','1918','2918','1919','2919','1920','2920'"
	aRet[1]	+=	"'1921','2921','1922','2922','1923','2923','1924','2925','1926','2926','1927','2927','1928','2928'"
	aRet[1]	+=	"'1929','2929','1931','2931','1932','2932','1933','2933','1949','2949',"
	aRet[1]	+=	Iif( !Empty(cAux) , cAux + ", " , " " )
	//-------------------------------------------------------------------------------------
	
	//-------------------------------------------------------------------------------------
	//CFOP's de Debito (DNVP)
	cAux	:=	Alltrim( GetNewPar("MV_DSVEC","") )
	/*aRet[2]	:=	"'5102','6102','5104','6104','5106','6106','5108','6108','5110','6110','5112','6112','5115','6115',"
	aRet[2]	+=	"'5117','6117','5119','6119','5120','6120','5123','6123','5152','6152','5156','6156','5250','6250',"
	aRet[2]	+=	"'5300','6300','5350','6350','5400','6400','5450','5550','6550','5600','6600','5655','5656','6655','6656'"*/
	aRet[2]	:=	"'5900','6900','5901','6901','5902','6902','5903','6903','5904','6904','5905','6905','5906','6906'"
	aRet[2]	+=	"'5907','6907','5908','6908','5909','6909','5910','6910','5911','6911','5912','6912','5913','6913'"
	aRet[2]	+=	"'5914','6914','5915','6915','5916','6916','5917','6917','5918','6918','5919','6919','5920','6920'"
	aRet[2]	+=	"'5921','6921','5922','6922','5923','6923','5924','6925','5926','6926','5927','6927','5928','6928'"
	aRet[2]	+=	"'5929','6929','5931','6931','5932','6932','5933','6933','5949','6949',"
	aRet[2]	+= Iif( !Empty(cAux) , cAux + ", " , " " )
	//-------------------------------------------------------------------------------------

// ----------------------------------
//		Saidas Interestaduais	
// ----------------------------------
Elseif cLegis == "SAI_IE"
    
	// -------------------------------------------------------------------------------------
	// Query com laco na tabela SX5, retornando todos os CFOP's de Saida Interestaduais, ou
	// seja, CFOP's iniciados por '6'
	// -------------------------------------------------------------------------------------
	cAliasQry	:=	GetNextAlias()
	BeginSql Alias cAliasQry
	                
	    SELECT
			SX5.X5_CHAVE
	    FROM 
	        %Table:SX5% SX5
		WHERE
			SX5.X5_FILIAL = %xFilial:SX5% AND
			SX5.X5_TABELA = '13'
	EndSql
	
	DbSelectArea(cAliasQry)
	(cAliasQry)->(DbGoTop())
	
	While !(cAliasQry)->(Eof())
		If Substr( (cAliasQry)->X5_CHAVE , 1 , 1 ) == "6"
			aRet[1]	+=	"'" + Alltrim( (cAliasQry)->X5_CHAVE ) + "', "
		Endif
		(cAliasQry)->(dbSkip())
	End
    
	(cAliasQry)->(DbCloseArea())

Endif

// ------------------------------------------------
// Tratamento para o retorno da string requisitada
// ------------------------------------------------
For nX := 1 To Len(aRet)

	//Exclui a virgula desnecessaria da string
	If !Empty(aRet[nX])
		aRet[nX]	:=	Substr(aRet[nX],1,Len(aRet[nX])-2)
	Endif

	If !lQuery
    	//Retira as aspas nao necessarias para comparacoes feitas em ADVPL
		aRet[nX]	:=	StrTran( aRet[nX] , "'" , Space(1) )
	Else
    	//Mantem as aspas e adiciona parenteses no comeco/fim para comparacoes SQL
    	If Empty(aRet[nX])
    		aRet[nX] := "''"
    	Endif    	
		aRet[nX]	:=	"( " + aRet[nX] + " )"
	Endif
Next nX

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} StartProc
Funcao responsavel por iniciar a solicitacao de aprovacao de titulos no
Fluig
	
@Param
aInfoFluig -> Informacoes do titulo a ser enviado a solicitacao no Fluig
		
@Return 
( nSolic ) -> Numero da solicitacao criada no Fluig
		
@author Rodrigo Aguilar
@since 24/04/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function StartProc( aInfoFluig )

Local cProcess := "MATA953"

Local nSolic   := 0

Local aDados   := {}

Local oModel   := Nil
Local oView    := NIl 

DbSelectArea( "CPF" )
DbSetOrder( 1 )

DbSelectArea( "CPG" )
DbSetOrder( 1 )

DbSelectArea( "CH3" )

//Posiciona no processo de Aprovacao de Titulos 
If CPF->( MsSeek( xFilial( 'CPF' ) + cProcess ) )              

	//Posiciona no processo de Aprovacao de Titulos	
	If CPG->( MsSeek( xFilial( 'CPG' ) + Padr( cProcess, TamSx3("CPG_CODPRC")[1] ) + "001" ) )
       
       oModel := FWLoadModel( CPF->CPF_MODEL )
       oView  := FWLoadView( CPF->CPF_VIEW )  
       oModel:SetOperation( 4 ) 
      
       If oModel:Activate() 
      		
      		//Subo as informacoes para o formulario do Fluig
      	   oModel:LoadValue( 'MODEL_CH3', 'CH3_PROCES', cProcess         )          
          oModel:LoadValue( 'MODEL_CH3', 'CH3_FILSE2', xFilial("SE2")   )
          oModel:LoadValue( 'MODEL_CH4', 'CH4_FILCDH', xFilial("CDH")   )
          oModel:LoadValue( 'MODEL_CH3', 'CH3_PREFIX', aInfoFluig[1,2]  )                    
          oModel:LoadValue( 'MODEL_CH3', 'CH3_NUM',    aInfoFluig[1,1]  )
          oModel:LoadValue( 'MODEL_CH3', 'CH3_VALOR',  aInfoFluig[1,9]  )                    
          oModel:LoadValue( 'MODEL_CH3', 'CH3_HISTOR', aInfoFluig[1,10] )
          oModel:LoadValue( 'MODEL_CH3', 'CH3_EMISSA', aInfoFluig[1,12] )
          oModel:LoadValue( 'MODEL_CH3', 'CH3_VENCTO', aInfoFluig[1,13] )      
          oModel:LoadValue( 'MODEL_CH3', 'CH3_RESPON', cUserName        )      
          
          oView:SetModel( oModel )      
               
          aDados := FWViewCardData( oView ) 
          
          //Inicio a Solicitacao no Fluig, ao enviar a 7 posicao como {} a  rotina
          //assume oque foi incluido no cadastro de etapas ( Tabela CPG )          
          nSolic:= FWECMStartProcess( cProcess,;   					  						      //cProcessId Código do processo no ECM
	                                   0,;          					  						      //nNextTask Número da atividade no ECM. Se informado 0 a solicitação inicia na primeira atividade
	                                   STR0135,;  													//cComments Comentários da tarefa - 'Aprovação de títulos gerados via apuração de ICMS' 
	                                   aDados ,;    												   //cXMLData XML com os dados do formulário. Para usar certifique-se que o fluxo possua um fichário.
	                                   {},;        													//aAttach Documentos anexos da solicitação
	                                   FWWFColleagueId( RetCodUsr() ),; 								//cUserId Matricula do colaborador que irá iniciar a solicitação. Ver documentação do ECM sobre mecanismo de atribuição.
	                                   {},;															//aColleagueIds Lista de colaboradores que receberão a tarefa. Ver documentação do ECM sobre mecanismo de atribuição.  
	                                   .F. )   														//lComplete Indica se deve ou completar a tarefa. Se a tarefa não for completa o fluxo não muda de atividade no ECM.
          
          //Caso NÃO ocorra erro na criacao da solicitacao  
          If !FWWFIsError()
                                     
          		//Gravo as informacoes do Titulo na tabela espelho
 			   FGvFluigWF( "TIT", , nSolic, aInfoFluig )            
              MsgInfo( STR0136 + AllTrim(Str(nSolic)) + STR0137 ) //"Processo "##" iniciado com sucesso"
          EndIf
      	EndIf 
    EndIf
EndIf

Return ( nSolic )

//-------------------------------------------------------------------
/*/{Protheus.doc} FGvFluigWF
Funcao responsavel por gravar a tabela de aprovacao de titulos gerados
pela apuracao de ICMS ( Integracao Protheus x Fluig )
	
@Param
cTipo       -> Indica se sera gerada a SE2 ou a CDH
nTpEst      -> Indica qual estrutura sera gerada nas tabelas SE2/CDH
nSolFluig  -> Numero da solicitacao gerada no Fluig
aInfoFluig -> Informacoes do titulo para gravacao da tabela
		
@Return 
( Nil )
		
@author Rodrigo Aguilar
@since 24/04/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Function FGvFluigWF( cTipo, cTpEst, nSolFluig, aInfoFluig )

Default cTpEst := "1"

//Geracao de Titulo
If cTipo == "TIT"
	
	Reclock( "CH3", .T. )          
		CH3->CH3_FILIAL  := xFilial("CH3")
		CH3->CH3_FILSE2  := xFilial("SE2")  
		CH3->CH3_PROCES  := Alltrim( Str( nSolFluig ) )
		CH3->CH3_NUM     := aInfoFluig[1][1]
		CH3->CH3_PREFIX  := aInfoFluig[1][2]
		CH3->CH3_TIPO    := aInfoFluig[1][3]
		CH3->CH3_NATURE  := aInfoFluig[1][4]
		CH3->CH3_FORNEC  := aInfoFluig[1][5]
		CH3->CH3_LOJA    := aInfoFluig[1][6]
		CH3->CH3_NOMFOR  := aInfoFluig[1][7]
		CH3->CH3_MOEDA   := aInfoFluig[1][8]
		CH3->CH3_VALOR   := aInfoFluig[1][9]
		CH3->CH3_HISTOR  := aInfoFluig[1][10]
		CH3->CH3_IDLANC  := aInfoFluig[1][11]
		CH3->CH3_EMISSA  := aInfoFluig[1][12]
		CH3->CH3_VENCTO  := aInfoFluig[1][13]
		CH3->CH3_ORIGEM  := aInfoFluig[1][14]
		CH3->CH3_FILORI  := aInfoFluig[1][15]
		CH3->CH3_CODRET  := aInfoFluig[1][16]
		CH3->CH3_LANCON  := Iif( aInfoFluig[1][17], "1", "2" )		  	
		CH3->CH3_RESPON  := cUserName
	CH3->( MsUnlock() )						 

//Geracao da apuracao de ICMS
ElseIf cTipo == "APUR"          
	
	//Geracao da linha "TIT" na CDH
	If cTpEst == "2"	         
		Reclock( "CH4", .T. )          
			CH4->CH4_FILIAL := xFilial("CH4")
			CH4->CH4_FILCDH := xFilial("CDH")
			CH4->CH4_PROCES := Alltrim( Str( nSolFluig ) )
			CH4->CH4_TPAPUR := cTpEst
			CH4->CH4_TIPOIP := aInfoFluig[1][1]
			CH4->CH4_TIPOPR := aInfoFluig[1][2]
			CH4->CH4_PERIOD := aInfoFluig[1][3]
			CH4->CH4_LIVRO  := aInfoFluig[1][4]
			CH4->CH4_SEQUEN := aInfoFluig[1][5]
			CH4->CH4_DTINI  := aInfoFluig[1][6]
			CH4->CH4_DTFIN  := aInfoFluig[1][7]
			CH4->CH4_CONSO  := aInfoFluig[1][8]
			CH4->CH4_FILDE  := aInfoFluig[1][9]
			CH4->CH4_FILATE := aInfoFluig[1][10]
			CH4->CH4_LINHA  := aInfoFluig[1][11]
			CH4->CH4_SUBLIN := aInfoFluig[1][12]
			CH4->CH4_DESC   := aInfoFluig[1][13]
		CH4->( MsUnlock() )
	
	//Complemento da CDH com informacoes do Titulo
	ElseIf nTpEst == "1"
		Reclock( "CH4", .T. )
			CH4->CH4_FILIAL  := xFilial("CH4")
			CH4->CH4_FILCDH  := xFilial("CDH")
			CH4->CH4_PROCES  := Alltrim( Str( nSolFluig ) )
			CH4->CH4_TPAPUR  := cTpEst
			CH4->CH4_RECAPU  := aInfoFluig[1][1]
			CH4->CH4_PREFIX  := aInfoFluig[1][2]			
			CH4->CH4_NUM     := aInfoFluig[1][3]
			CH4->CH4_TIPO    := aInfoFluig[1][4]	
			CH4->CH4_VALOR   := aInfoFluig[1][5]
			CH4->CH4_LINHA   := aInfoFluig[1][6]
			CH4->CH4_SUBLIN  := aInfoFluig[1][7]							
		CH4->( MsUnlock() )						
	EndIf
							 		
EndIf								
							
Return ( Nil )

//-------------------------------------------------------------------
/*/{Protheus.doc} ResIPICFOP
Funcao responsavel por montar o resumo da apuracao de IPI por CFOP.
Utilizada na exibicao da apuracao(ShowApur) e na impressao do relatorio P8.
	
@param	aApuracao -> Array contendo os dados apurados de IPI.
		
@return aRet-> 

[1] - Array com as entradas agrupadas por CFOP.
[2] - Array com as saidas agrupadas por CFOP.
[3] - Array com os totais de créditos e debitos.
	[3][1] - Totalizadores de credito.
	[3][2] - Totalizadores de debito.
	[3][3] - Totalizador Geral.
		
@author Joao Pellegrini
@since 13/06/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Function ResIpiCFOP(aApuracao, lOrdena, lGeraTRB, cAliasTRB, aMensIPI)

Local aRet := { {}, {}, {{}, {}, {}} }
Local i := 0
Local j := 0
Local nCont 		:= 0
Local nMensIPI		:= 0
Local nTotMensIPI	:= 0

// IMPORTANTE: Atualizar esta variavel sempre que for necessario adicionar um elemento aos arrays 
//             aRet[1], aRet[2] ou aRet[3] para que todos sempre tenham o mesmo tamanho/estrutura.
Local nTamArray := 11 

DEFAULT lOrdena := .F.
DEFAULT lGeraTRB := .F.
DEFAULT cAliasTRB := ""
Default aMensIPI	:= {}

If lGeraTRB
	aCampos	:= {}        
	
	aTam  	:= TAMSX3("F3_CFO")
	AADD(aCampos,{"CFOP"	,"C",aTam[1],aTam[2]})
	aTam  	:= TAMSX3("F3_VALCONT")                               
	AADD(aCampos,{"VALCONT"	,"N",aTam[1],aTam[2]})                         
	aTam  	:= TAMSX3("F3_BASEIPI")                               
	AADD(aCampos,{"BASEIPI"	,"N",aTam[1],aTam[2]})                         
	aTam  	:= TAMSX3("F3_VALIPI")                               
	AADD(aCampos,{"VALIPI"	,"N",aTam[1],aTam[2]})                         
	aTam  	:= TAMSX3("F3_ISENIPI")                               
	AADD(aCampos,{"ISENIPI"	,"N",aTam[1],aTam[2]})                         
	aTam  	:= TAMSX3("F3_OUTRIPI")                               
	AADD(aCampos,{"OUTRIPI"	,"N",aTam[1],aTam[2]})                         

	cArqTRB :=	CriaTrab(aCampos)
	dbUseArea(.T.,__LocalDriver,cArqTRB,cAliasTRB,.T.,.F.)

	IndRegua(cAliasTRB,cArqTRB,"CFOP")
	
	DbSelectArea(cAliasTRB)
	DbClearIndex()
	DbSetIndex(cArqTRB+OrdBagExt())
EndIf

// Inicializando Totalizador de CREDITO.
aSize(aRet[3][1], nTamArray)
aRet[3][1][1] := "TOTAL"
aFill(aRet[3][1], 0, 2)

// Inicializando Totalizador de DEBITO.
aSize(aRet[3][2], nTamArray)
aRet[3][2][1] := "TOTAL"
aFill(aRet[3][2], 0, 2)

// Inicializando Totalizador GERAL.
aSize(aRet[3][3], nTamArray)
aRet[3][2][1] := "TOTAL"
aFill(aRet[3][3], 0, 2)

//Ordena array aMensIPI pelo CFOP
aMensIPI := aSort(aMensIPI,,,{|x,y| x[4] < y[4] })

For i := 1 to Len(aApuracao)
	If Val(Substr(aApuracao[i,1],1,3)) < 500
		If (nPosEnt := aScan(aRet[1], {|x| AllTrim(x[1]) == AllTrim(aApuracao[i,1])})) == 0

			nTotMensIPI	:= 0
			
			//Totaliza todos os valores de CFOP do array aMensIPI para considerar em total dos créditos.
			nCont := aScan( aMensIPI, {|x| x[4] == AllTrim(aApuracao[i,1] ) } )
			
			If nCont > 0
			
				//Existe ao menos uma linha com o CFOP do aApuracao
				For nMensIPI := nCont to Len( aMensIPI )

					If aMensIPI[ nMensIPI ][4] == AllTrim(aApuracao[i,1])
						//Totaliza o valor do CFOP
						nTotMensIPI += aMensIPI[ nMensIPI ][ 3 ]
					Else
						//Se for CFOP diferente eu saio do for do aMensIPI
						Exit
					EndIf

				Next nMensIPI

			EndIF

			aAdd(aRet[1], {})
			nPosEnt := Len(aRet[1])
			
			aAdd(aRet[1][nPosEnt], AllTrim(aApuracao[i,1])) //CFOP
			aAdd(aRet[1][nPosEnt], 0)
			aAdd(aRet[1][nPosEnt], aApuracao[i,3]) // BASE DE CALCULO
			aAdd(aRet[1][nPosEnt], aApuracao[i,4] + nTotMensIPI ) // VALOR DO CREDITO - Não soma valor IPI para F4_IPI=R - Comercio não atacadista
			aAdd(aRet[1][nPosEnt], aApuracao[i,5]) // ISENTO
			aAdd(aRet[1][nPosEnt], aApuracao[i,6]) // OUTROS
			aAdd(aRet[1][nPosEnt], 0)
			aAdd(aRet[1][nPosEnt], 0)
			aAdd(aRet[1][nPosEnt], 0)
			aAdd(aRet[1][nPosEnt], 0)
			aAdd(aRet[1][nPosEnt], aApuracao[i,11]) // VALOR CONTABIL.			
		Else
			aRet[1][nPosEnt][3] += aApuracao[i,3] 
			aRet[1][nPosEnt][4] += aApuracao[i,4]
			aRet[1][nPosEnt][5] += aApuracao[i,5] 
			aRet[1][nPosEnt][6] += aApuracao[i,6]
			aRet[1][nPosEnt][11] += aApuracao[i,11]
		EndIf
		
		// Totalizando valores de credito.
		aRet[3][1][2] += 0
		aRet[3][1][3] += aApuracao[i,3] // TOTAL - BASE DE CALCULO DO CREDITO
		aRet[3][1][4] += aApuracao[i,4]  + nTotMensIPI // TOTAL - VALOR DO CREDITO  VALOR DO CREDITO - Não soma valor IPI para F4_IPI=R - Comercio não atacadista
		aRet[3][1][5] += aApuracao[i,5] // TOTAL - ISENTO
		aRet[3][1][6] += aApuracao[i,6] // TOTAL - OUTROS
		aRet[3][1][7] += 0
		aRet[3][1][8] += 0
		aRet[3][1][9] += 0
		aRet[3][1][10] += 0
		aRet[3][1][11] += aApuracao[i,11] // TOTAL - VALOR CONTABIL
		
	Else
		If (nPosSai := aScan(aRet[2], {|x| AllTrim(x[1]) == AllTrim(aApuracao[i,1])})) == 0
		
			aAdd(aRet[2], {})
			nPosSai := Len(aRet[2])
			
			aAdd(aRet[2][nPosSai], AllTrim(aApuracao[i,1])) // CFOP
			aAdd(aRet[2][nPosSai], 0) 
			aAdd(aRet[2][nPosSai], aApuracao[i,3]) // BASE DE CALCULO
			aAdd(aRet[2][nPosSai], aApuracao[i,4]) // VALOR DO DEBITO
			aAdd(aRet[2][nPosSai], aApuracao[i,5]) // ISENTO
			aAdd(aRet[2][nPosSai], aApuracao[i,6]) // OUTROS
			aAdd(aRet[2][nPosSai], 0)
			aAdd(aRet[2][nPosSai], 0)
			aAdd(aRet[2][nPosSai], 0)
			aAdd(aRet[2][nPosSai], 0)
			aAdd(aRet[2][nPosSai], aApuracao[i,11]) // VALOR CONTABIL
		Else
			aRet[2][nPosSai][3] += aApuracao[i,3]
			aRet[2][nPosSai][4] += aApuracao[i,4]
			aRet[2][nPosSai][5] += aApuracao[i,5]
			aRet[2][nPosSai][6] += aApuracao[i,6]
			aRet[2][nPosSai][11] += aApuracao[i,11]
		EndIf
		
		// Totalizando valores de débito.
		aRet[3][2][2] += 0
		aRet[3][2][3] += aApuracao[i,3] // TOTAL - BASE DE CALCULO DO DEBITO
		aRet[3][2][4] += aApuracao[i,4] // TOTAL - VALOR DO DEBITO
		aRet[3][2][5] += aApuracao[i,5] // TOTAL - ISENTO
		aRet[3][2][6] += aApuracao[i,6] // TOTAL - OUTROS
		aRet[3][2][7] += 0
		aRet[3][2][8] += 0
		aRet[3][2][9] += 0
		aRet[3][2][10] += 0
		aRet[3][2][11] += aApuracao[i,11] // TOTAL - VALOR CONTABIL
	Endif 
	
	// Totalizador geral.
	aRet[3][3][2] += 0
	aRet[3][3][3] += aApuracao[i,3] // TOTAL - BASE DE CALCULO DO DEBITO
	aRet[3][3][4] += aApuracao[i,4] // TOTAL - VALOR DO DEBITO
	aRet[3][3][5] += aApuracao[i,5] // TOTAL - ISENTO
	aRet[3][3][6] += aApuracao[i,6] // TOTAL - OUTROS
	aRet[3][3][7] += 0
	aRet[3][3][8] += 0
	aRet[3][3][9] += 0
	aRet[3][3][10] += 0
	aRet[3][3][11] += aApuracao[i,11] // TOTAL - VALOR CONTABIL	
Next i

If lOrdena
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Coloca entradas e saidas em ordem crescente de CFOP             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRet[1] := Asort(aRet[1],,,{|x,y|x[1]<y[1]})
	aRet[2] := Asort(aRet[2],,,{|x,y|x[1]<y[1]})
EndIf

// Se gerar TRB, alimentar o alias passado com os dados de aRet[1] e aRet[2].
If lGeraTRB
	
	For j := 1 to 2
	
		For i := 1 to Len(aRet[j])
			RecLock(cAliasTRB, .T.)
				(cAliasTRB)->CFOP := aRet[j][i][1]
				(cAliasTRB)->VALCONT := aRet[j][i][11]
				(cAliasTRB)->BASEIPI := aRet[j][i][3]
				(cAliasTRB)->VALIPI := aRet[j][i][4]
				(cAliasTRB)->ISENIPI := aRet[j][i][5]
				(cAliasTRB)->OUTRIPI := aRet[j][i][6]
			MsUnlock()	
		Next i
	
	Next j
	
EndIf

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} getFatorDesenvolveBA
	
@param	
		
@return 
		
@author Luccas Curcio
@since 17/07/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Function getFatorDesenvolveBA( nMes , nAno , lReport )

Local	cMes	:=	strZero( nMes , 2 )
Local	cAno	:=	strZero( nAno , 4 )
Local	cSelect	:=	""
Local	cFrom	:=	""
Local	cWhere	:=	""
Local	cGroup	:=	""
Local	cAliasQ	:=	""
Local	cDsvInd	:=	GetNewPar( "MV_DSVIND" , "''" )
Local	nFator	:=	0
Local	nRetAux	:=	0
Local	aRet	:=	{}

Default lReport := .F.
cDsvInd	:=	iif( empty( cDsvInd ) , "''" , cDsvInd )

// ==================================================
// VALOR CONTABIl / VALOR ICMS

cSelect	:=	"SUM( SFT.FT_TOTAL ) CONTABIL , SUM( SFT.FT_VALICM ) ICMS"
cFrom	:=	retSQLName( "SFT" ) + " SFT "
cFrom	+=	"JOIN " + retSQLName( "SB5" ) + " SB5 ON SB5.B5_FILIAL = '" + xFilial( "SB5" ) + "' AND SB5.B5_COD = SFT.FT_PRODUTO AND SB5.D_E_L_E_T_ = '' AND SB5.B5_PROJDES = '1' "
cWhere	:=	"SFT.FT_FILIAL = '" + xFilial( "SFT" ) + "' AND "
cWhere	+=	"SFT.FT_ENTRADA >= '" + cAno+cMes + "01' AND "
cWhere	+=	"SFT.FT_ENTRADA <= '" + cAno+cMes + "31' AND "
cWhere	+=	"SFT.FT_TIPOMOV = 'S' AND "
cWhere	+=	"SFT.FT_TIPO <> 'S' AND "
cWhere	+=	"SFT.FT_DTCANC = '' AND "
cWhere	+=	"SFT.D_E_L_E_T_ = '' "
cSelect	:=	'%' + cSelect	+ '%' 
cFrom	:=	'%' + cFrom		+ '%' 
cWhere	:=	'%' + cWhere	+ '%' 

cAliasQ	:=	getNextAlias()

BeginSql Alias cAliasQ
	
	SELECT
		%Exp:cSelect%

	FROM
		%Exp:cFrom%
	
	WHERE 
		%Exp:cWhere%

EndSql

nFator	:=	( ( cAliasQ )->ICMS / ( cAliasQ )->CONTABIL ) * 100

( cAliasQ )->( dbCloseArea() )

// ==================================================
// VALOR INDUSTRIALIZAÇÃO EFETUADA POR TERCEIRO

cSelect	:=	"SUM( SFT.FT_TOTAL ) INDCONTABIL , SUM( SFT.FT_VALICM ) INDICMS "
cFrom	:=	RetSQLName( "SFT" ) + " SFT "
cWhere	:=	"SFT.FT_FILIAL = '" + xFilial( "SFT" ) + "' AND "
cWhere	+=	"SFT.FT_ENTRADA >= '" + cAno+cMes + "01' AND "
cWhere	+=	"SFT.FT_ENTRADA <= '" + cAno+cMes + "31' AND "
cWhere	+=	"SFT.FT_CFOP IN ( " + cDsvInd + " ) AND "
cWhere	+=	"SFT.FT_DTCANC = '' AND "
cWhere	+=	"SFT.D_E_L_E_T_ = '' "
// Quando a chamada eh do relatorio de conferencia, devo quebrar o select por cfop para listar essas informacoes
If lReport
	cSelect	+=	", SFT.FT_CFOP CFOP, SX5.X5_DESCRI CFDESC "
	cFrom	+=	"JOIN " + RetSqlName( "SX5" ) + " SX5 ON "
	cFrom	+=	"	SX5.X5_TABELA = '13' AND "
	cFrom	+=	"	SX5.X5_CHAVE = SFT.FT_CFOP "
	cGroup	:=	"GROUP BY SFT.FT_CFOP, SX5.X5_DESCRI "
Endif

cSelect	:=	'%' + cSelect	+ '%' 
cFrom	:=	'%' + cFrom		+ '%' 
cWhere	:=	'%' + cWhere+cGroup	+ '%' 

cAliasQ	:=	getNextAlias()

BeginSql Alias cAliasQ
	
	SELECT
		%Exp:cSelect%

	FROM
		%Exp:cFrom%
	
	WHERE 
		%Exp:cWhere%

EndSql

// Quando a chamada eh do relatorio de conferencia, devo quebrar o select por cfop para listar essas informacoes
If lReport
	
	do while ( cAliasQ )->( !eof() )
	
		nRetAux	:=	( ( cAliasQ )->INDCONTABIL * nFator ) / 100
		
		// aRet[x,1] -> Deve ser deduzido
		// aRet[x,2] -> Deve ser somado
		aAdd( aRet , { nRetAux , ( cAliasQ )->INDICMS , nFator , ( cAliasQ )->CFOP , ( cAliasQ )->CFDESC } )
		
		( cAliasQ )->( dbSkip() )
		
	enddo
		
Else
	nRetAux	:=	( ( cAliasQ )->INDCONTABIL * nFator ) / 100
	
	// aRet[1] -> Deve ser deduzido
	// aRet[2] -> Deve ser somado
	aRet	:=	{ nRetAux , ( cAliasQ )->INDICMS , nFator }
Endif

( cAliasQ )->( dbCloseArea() )

return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} xApCodRec

Funcao centralizadora das regras para gravacao do campo F6_CODREC.
	
@param aDadSF6 - Array com os dados da GNRE	
		
@return cRet - Conteudo a ser gravado no campo F6_CODREC 
		
@author joao.pellegrini
@since 17/08/2016
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function xApCodRec(aDadSF6)

Local cRet 		:= ""
Local nPos 		:= Len(aDadSF6)
Local cGnrCom	:= GetNewPar("MV_GNRCOM" ,"")  //GNREON 100013 Telecomunicação
Local cGnrEle	:= GetNewPar("MV_GNRELE" ,"")  //GNREON 100021 Energia Eletrica
Local cGnrTrans	:= GetNewPar("MV_GNRTRAN","") //GNREON 100030 Transporte
Local cGNRDIFAL	:= GetNewPar("MV_GNDIFAL","")	//Codigo receita Difal
Local cCdDifal	:= GetNewPar("MV_GNDIFUF","")	//Codigo receita Difal por estado
Local cGNFPDIF	:= GetNewPar("MV_GNFPDIF","")	//Codigo receita FECP Difal
Local cCdFecp	:= GetNewPar("MV_GNFPDUF","")	//Codigo receita FECP por estado
Local cGNFECP	:= GetNewPar("MV_GNFECP" ,"")	//Codigo receita FECP
Local cRECICANT := GetNewPar("MV_RECANTE","") // Codigo de Antecipação do ICMS ST
Local nPosIni	:= 0
Local nPosFim	:= 0

If Len(aDadSF6[nPos]) >= 19
	If	AModNot(Alltrim(aDadSF6[nPos,19]))$"55/57"
		If aDadSF6[nPos,23] == .T.  .and. aDadSF6[nPos,15] == '1'    // nesse caso não é antecipação do ICMS, a posição 23 o aDadSF2 temos uma validação para 
			cRet := cRECICANT
		Else			
			cRet := Iif(AModNot(Alltrim(aDadSF6[nPos,19]))$"55",codReceinf(GetNewPar("MV_RECEINF",""), aDadSF6, nPos),cGnrTrans)
		Endif
		If Len(aDadSF6[nPos]) >= 20 .And. aDadSF6[nPos,6] $ "B"
			IF aDadSF6[nPos,20]
				IF AT(aDadSF6[nPos][8], cCdFecp) > 0
					nPosIni := AT(aDadSF6[nPos][8], cCdFecp) + 2
					If (nPosFim := AT("\", SubStr(cCdFecp, nPosIni)) - 1 ) > 0
						cRet := SubStr(cCdFecp, nPosIni, nPosFim)
					Else	
						cRet := SubStr(cCdFecp, nPosIni)
					EndIf
				Else
					cRet := cGNFPDIF
				Endif
			Else
				IF AT(aDadSF6[nPos][8], cCdDifal) > 0
					nPosIni := AT(aDadSF6[nPos][8], cCdDifal) + 2
					If (nPosFim := AT("\", SubStr(cCdDifal, nPosIni)) - 1 ) > 0
						cRet := SubStr(cCdDifal, nPosIni, nPosFim)
					Else	
						cRet := SubStr(cCdDifal, nPosIni)
					EndIf
				Else
					cRet := cGNRDIFAL
				Endif
			Endif
		ElseIf Len(aDadSF6[nPos]) >= 20 .And. aDadSF6[nPos,20]
			nPosIni := AT(aDadSF6[nPos][8], cGNFECP) + 2
			If (nPosFim := AT("\", SubStr(cGNFECP, nPosIni)) -1 ) > 0
				cRet := SubStr(cGNFECP, nPosIni, nPosFim)
			Else	
				cRet := SubStr(cGNFECP, nPosIni)
			EndIf
		Endif
	Elseif AModNot(Alltrim(aDadSF6[nPos,19]))$"21/22"
		cRet := cGnrCom
	Elseif AModNot(Alltrim(aDadSF6[nPos,19]))$"06"
		cRet := cGnrEle
	Elseif AModNot(Alltrim(aDadSF6[nPos,19]))$"09/11/08/07/26"
		cRet := cGnrTrans
	//Elseif AModNot(Alltrim(aDadSF6[nPos,19]))$"55/57" .and. cRECICANT ='100080' // gravar 100080 para notas de entrada de antecipação do icms
	//	cRet := cRECICANT
	EndIf
EndIf

cRet := Padr(cRet,TamSx3("F6_CODREC")[1])

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} xApInfC

Funcao centralizadora das regras para gravacao do campo CDC_IFCOMP.
	
@param lAutomato - Flag p/ indicar a execucao do teste automatizado.	
		
@return cRet - Conteudo a ser gravado no campo CDC_IFCOMP 
		
@author joao.pellegrini
@since 18/07/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function xApInfC(lAutomato)

Local cRet := ""
Local cMensagem := ""

If ChkFile("CCE")
	
	//Se nao encontrar o parametro o sistema ira emitir uma msg, caso contrario o sistema ira pegar o conteudo para ser utilizado no complemento da nota
	If SuperGetMV("MV_GNRINFC",.F.,"NAOEXISTE")=="NAOEXISTE"	//Codigo padrao da Informacao Complementar relacionando a Guia de Recolhimento com a Nota Fiscal
		cMensagem:=" O parâmetro MV_GNRINFC não existe na base de dados."
		cMensagem+="Será considerado um código genérico padrão como a "
		cMensagem+="informação complementar da amarração da Guia de Re"
		cMensagem+="colhimento com a Nota Fiscal."
	Else
		cRet := SuperGetMV("MV_GNRINFC")
		If !Empty(cRet) 
			cMensagem:=" O código informado no parâmetro não existe na "
			cMensagem+="base de dados. Será considerado um código genérico "
			cMensagem+="padrão como a informação complementar da amarração "
			cMensagem+="da Guia de Recolhimento com a Nota Fiscal."
		Else
			cMensagem:=" Não foi informado no parâmetro o código padrão "
			cMensagem+="da informação complementar."
			cMensagem+="Será considerado um código genérico "
			cMensagem+="para a informação complementar da amarração "
			cMensagem+="da Guia de Recolhimento com a Nota Fiscal."
		Endif
	Endif
	
	DbSelectArea("CCE")
	CCE->(DbSetOrder(1))
	CCE->(DbGoTop())    
	
	//Se nao encontrar a variavel for vazia ou nao encontrar o codigo contido na variavel, o sistema ira verificar se existe um codigo generico
	//para ser utilizado e caso nao exista ira gera um novo.
	If Empty(cRet) .Or. CCE->(!DbSeek(xFilial("CCE")+cRet))        
	
		//Se nao encontrar o parametro, ou estiver vazio o parametro ou o codigo nao existe na base de dados o sistema ira emitir 
		//o help informando o motivo
		If !lAutomato 
			Help(" ",1,"MV_GNRINFC","MV_GNRINFC",cMensagem,1,0)
		EndIf
		
		cRet:=""//Atribuir vazio para que possa gerar um novo codigo
		
		If CCE->(DbSeek(xFilial("CCE")))
			Do While CCE->(!EOF())
				//Verifica se existe um codigo generico por meio da descricao
				If UPPER(ALLTRIM(CCE->CCE_DESCR))=="AMARRACAO DE GUIA COM A NOTA FISCAL(GENERICO)"
					cRet :=CCE->CCE_COD
					Exit
				Endif
				CCE->(DbSkip())
			End
			DbSelectArea("CCE")
			CCE->(DbSetOrder(1))
			CCE->(DbGoTop())
		Endif  
		
		//Se nao encontrar um codigo generico sera gerado um novo
		If Empty(cRet)
			cRet := GetSx8Num("CCE","CCE_COD")//Codigo generico Amarracao de Guia com a Nota Fiscal					
			ConfirmSX8()
		Endif
		
		If !DbSeek(xFilial("CCE")+cRet)
			RecLock("CCE",.T.)
			CCE_FILIAL:=xFilial("CCE")
			CCE_COD   := cRet
			CCE_DESCR := "AMARRACAO DE GUIA COM A NOTA FISCAL(GENERICO)"
			CCE->(MsUnlock())
		Endif
	Endif    
	
	//Grava o codigo existente ou o gerado no parametro
	If FWSX6Util():ExistsParam( "MV_GNRINFC" )
		PUTMV("MV_GNRINFC", cRet)	
	Endif

EndIf

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FisTitCDA

Componente para geracao de GNRE's e titulos atraves dos lancamentos
gravados na tabela CDA.
	
@param cRotina - Rotina que acionou o componente.	
@param cTpMov - Tipo de documento (Entrada/Saida).
@param nRecnoNF - RecNo da tabela SF1 ou SF2. 
		
@return aRet - Array indicando quais GNRE's foram geradas.
		 aRet[1] := Foi gerada GNRE de ICMS Proprio.
		 aRet[2] := Foi gerada GNRE de ICMS - ST.
         aRet[3] := Foi gerada GNRE de DIFAL.
		 aRet[4] := Foi gerada GNRE de FECP-DIFAL.	  
		 
		
@author joao.pellegrini
@since 31/08/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Function FisTitCDA(cRotina, cTpMov, nRecnoNF)

Local aLancCDA := {}
Local nPosCDA := 0
Local cChvCDA := ""
Local nX := 0
Local cNatureza := ""
Local cTpImp := ""
Local cTpApurCDA := ""
Local cMvEstado := SuperGetMV("MV_ESTADO")
Local dDtVenc := ""
Local aDatas := {}
Local nMes := 0
Local nAno := 0
Local aDadosNF := {}
Local cNumero := ""
Local aGNRE := {}
Local aRecTit := {}
Local nY := 0
Local aRet := {.F., .F., .F., .F.}
Local lCpoOk := aApurSX3[FP_CDA_GUIA]  .And. aApurSX3[FP_CDA_UFGNRE] .And.;
               aApurSX3[FP_CDO_NATURE] .And. aApurSX3[FP_CDO_TPIMP]	 .And.;
               aApurSX3[FP_CC6_NATURE]	.And. aApurSX3[FP_CC6_TPIMP]	
Local cObserv := ""   

Local lCdaVlou := aApurSX3[FP_CDA_VLOUTR]

dbSelectArea("CDA")
CDA->(dbSetOrder(1))

dbSelectArea("CDO")
CDO->(dbSetOrder(1))

dbSelectArea("CC6")
CC6->(dbSetOrder(1))

If lCpoOk

	If cTpMov == "E"
		SF1->(dbGoTo(nRecnoNF))
		cChvCDA := xFilial("CDA") + SF1->("E"+F1_ESPECIE+F1_FORMUL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA)		
		nMes := Month(SF1->F1_DTDIGIT)
		nAno := Year(SF1->F1_DTDIGIT)
		aAdd(aDadosNF,{SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_TIPO,"1",cMvEstado,SF1->F1_ESPECIE})
	ElseIF cTpMov == "S"
		SF2->(dbGoTo(nRecnoNF))
		cChvCDA := xFilial("CDA") + SF2->("S"+F2_ESPECIE+"S"+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA)
		nMes := Month(SF2->F2_EMISSAO)
		nAno := Year(SF2->F2_EMISSAO)
		aAdd(aDadosNF,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
	EndIf
	
	// Totalizando o valor por codigo de lancamento.
	If CDA->(MsSeek(cChvCDA))
		While !CDA->(Eof()) .And. cChvCDA == CDA->(CDA_FILIAL+CDA_TPMOVI+CDA_ESPECI+CDA_FORMUL+CDA_NUMERO+CDA_SERIE+CDA_CLIFOR+CDA_LOJA) 
			If CDA->CDA_GUIA == "1"
				If (nPosCDA := aScan(aLancCDA, {|x| x[1] == CDA->CDA_CODLAN})) == 0 
					If lCdaVlou
						aAdd(aLancCDA, {CDA->CDA_CODLAN, CDA->CDA_VALOR + CDA->CDA_VLOUTR, {CDA->(RecNo())}})
					Else
						aAdd(aLancCDA, {CDA->CDA_CODLAN, CDA->CDA_VALOR, {CDA->(RecNo())}})
					Endif
				Else
					aLancCDA[nPosCDA, 2] += (CDA->CDA_VALOR + Iif(lCdaVlou,CDA->CDA_VLOUTR,0))
					aAdd(aLancCDA[nPosCDA, 3], CDA->(RecNo()))
				EndIf
			EndIf
			CDA->(dbSkip())
		EndDo
	EndIf
	
	// Calculando data de vencimento.
	aDatas := DetDatas(nMes, nAno, 3, 1)
	dDtVenc := DataValida(aDatas[2] + 1, .T.)
	
	// Geracao dos titulos conforme a configuracao do codigo de lancamento.
	For nX := 1 to Len(aLancCDA)
		
		// Definicoes conforme codigo de lancamento.
		
		If Len(AllTrim(aLancCDA[nX, 1])) == 8
			If CDO->(MsSeek(xFilial("CDO") + aLancCDA[nX, 1]))
				// Natureza do titulo.
				cNatureza := CDO->CDO_NATURE
				// Tipo de GNRE (F6_TIPOIMP). 
				cTpImp := CDO->CDO_TPIMP
				// Tipo de imposto (ICMS, ICMS-ST, DIFAL, FCP...) 
				cTpApurCDA := SubStr(aLancCDA[nX, 1], 3, 1)
			EndIf	
		ElseIf Len(AllTrim(aLancCDA[nX, 1])) == 10
			If CC6->(MsSeek(xFilial("CC6") + aLancCDA[nX, 1]))
				// Natureza do titulo.
				cNatureza := CC6->CC6_NATURE
				// Tipo de GNRE (F6_TIPOIMP).
				cTpImp := CC6->CC6_TPIMP
				// Tipo de imposto (ICMS, ICMS-ST, DIFAL, FCP...)
				cTpApurCDA := SubStr(aLancCDA[nX, 1], 4, 1)
			EndIf
		EndIf
		
		// Observacao p/ a GNRE e o Titulo a Pagar.
		cObserv := "REF. COD. AJ. " + AllTrim(aLancCDA[nX, 1])
	
		Do Case
			
			Case cTpApurCDA == "0" // ICMS Proprio	
				GravaTit(.T.,aLancCDA[nX,2],"ICMS","IC","",,,dDtVenc,1,.T.,nMes,nAno,aLancCDA[nX,2],0,cRotina,,@cNumero,@aGNRE,,,,,,,,@aRecTit,,,aDadosNF,,,,,,,,,,,,,,,,,,,,cTpImp,cNatureza,cObserv)		
			Case cTpApurCDA == "1" // ICMS ST
				GravaTit(.T.,aLancCDA[nX,2],"ICMS","IC","",,,dDtVenc,1,.T.,nMes,nAno,0,aLancCDA[nX,2],cRotina,,@cNumero,@aGNRE,,,aDadosNF[1,7],,,,,@aRecTit,,,aDadosNF,,,,,,,,,,,,,,,,,,,,cTpImp,cNatureza,cObserv)			
			Case cTpApurCDA == "2" // DIFAL
				GravaTit(.T.,aLancCDA[nX,2],"ICMS","IC","",,,dDtVenc,1,.T.,nMes,nAno,0,aLancCDA[nX,2],cRotina,,@cNumero,@aGNRE,,,aDadosNF[1,7],,,,,@aRecTit,,,aDadosNF,,,,,,,,,,,,,,.T.,,,,,,cTpImp,cNatureza,cObserv)
			Case cTpApurCDA == "3" // FECP - DIFAL
				GravaTit(.T.,aLancCDA[nX,2],"ICMS","IC","",,,dDtVenc,1,.T.,nMes,nAno,0,aLancCDA[nX,2],cRotina,,@cNumero,@aGNRE,,,aDadosNF[1,7],,.T.,,,@aRecTit,,,aDadosNF,,,,,,,,,,,,,,.T.,,,,,,cTpImp,cNatureza,cObserv)
			
		Otherwise // Os demais gero como ICMS Proprio.			
		
			GravaTit(.T.,aLancCDA[nX, 2],"ICMS","IC","",,,dDtVenc,1,.T.,nMes,nAno,aLancCDA[nX, 2],0,cRotina,,@cNumero,@aGNRE,,,aDadosNF[1,7],,,,,@aRecTit,,,aDadosNF,,,,,,,,,,,,,,,,,,,,cTpImp,cNatureza,cObserv)
		
		EndCase
		
		// Atualizo as linhas da tabela CDA com as informacoes da GNRE.
		If !Empty(aGNRE)				
			For nY := 1 to Len(aLancCDA[nX, 3])
				CDA->(dbGoTo(aLancCDA[nX, 3][nY]))
				RecLock("CDA",.F.)
				CDA->CDA_GNRE := aGnre[1,1]
				CDA->CDA_UFGNRE := aGnre[1,5] 				
				MsUnLock()			
			Next nY
			
			Do Case
				
				// Retorno da funcao eh um array para indicar se foram gerados
				// titulos/guias de ICMS Proprio, ST, DIFAL ou FECP-DIFAL.
				// Este retorno servira p/ anular a geracao legada do MATA461.
				
				Case cTpApurCDA == "0"
					aRet[1] := .T.
				Case cTpApurCDA == "1"
					aRet[2] := .T.
				Case cTpApurCDA == "2"
					aRet[3] := .T.
				Case cTpApurCDA == "3"
					aRet[4] := .T.			
				
			EndCase
			
		EndIf
		
		aGNRE := {}
		aRecTit := {}
		
	Next nX

EndIf

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} xApGrvSF6

Funcao centralizadora da gravacao das GNRES geradas na emissao ou
recebimento dos documentos.

@param aDadSF2 - Array com os dados do documento fiscal.
@param aDadSF6 - Array com os dados da GNRE.
@param cNumGNRE - Numero da GNRE.
@param cCodGnre - Numero 

@author joao.pellegrini
@since 31/08/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function xApGrvSF6(aDadSF2, aDadSF6, cNumGNRE, cCodGnre)

Local nMVDATPAG := GetNewPar("MV_DATAPAG", 0)
Local nPosF2    := Len(aDadSF2)
Local nPosF6    := Len(aDadSF6)
Local nCodGnre  := 0
Local lSPCOBREC := aExistBloc[PE_SPCOBREC]
Local aRet 		:= {}
Local cCodRec	:= ''
Local lGrValFund  := aApurSX3[FP_F6_VALFUND]

Default cCodGnre := ""

DbSelectArea("SF6")
RecLock("SF6",.T.)

SF6->F6_FILIAL  := xFilial("SF6")
SF6->F6_OPERNF  := IIF(aDadSF2[nPosF2,6]=="1","1","2")
SF6->F6_DOC     := aDadSF2[nPosF2,1]
SerieNfId("SF6",1,"F6_SERIE",,,,aDadSF2[nPosF2,2])
SF6->F6_CLIFOR  := aDadSF2[nPosF2,3]
SF6->F6_LOJA    := aDadSF2[nPosF2,4]
SF6->F6_VALOR   := aDadSF6[nPosF6][1]
SF6->F6_DTARREC := aDadSF6[nPosF6][2]
SF6->F6_MESREF  := aDadSF6[nPosF6][3]
SF6->F6_ANOREF  := aDadSF6[nPosF6][4]
SF6->F6_DTVENC  := aDadSF6[nPosF6][5]
SF6->F6_DTPAGTO := Iif((SomaData(nMVDATPAG,dDatabase)>aDadSF6[nPosF6][5]),aDadSF6[nPosF6][5],SomaData(nMVDATPAG,dDatabase))
SF6->F6_TIPOIMP := aDadSF6[nPosF6][6]
SF6->F6_EST     := aDadSF6[nPosF6][8]
SF6->F6_NUMERO  := cNumGNRE
SF6->F6_TIPODOC := aDadSF6[nPosF6][14]
SF6->F6_INSC    := aDadSF6[nPosF6][16]

If aDadSF6[nPosF6][6] $ "1|3|A|B"
	SF6->F6_CODREC  := cCodRec := xApCodRec(aDadSF6)
EndIF

If !Empty(cCodRec) .And. aApurSX3[FP_F6_CODAREA]
	SF6->F6_CODAREA := xApCodArea(cCodRec)
EndIf

If Len(aDadSF6[nPosF6]) >= 18 .And. !Empty(aDadSF6[nPosF6,18])
	SF6->F6_NUMCONV := aDadSF6[nPosF6,18]
EndIf

If Len(aDadSF6[nPosF6]) >= 22 .And. !Empty(aDadSF6[nPosF6,22])
	SF6->F6_OBSERV := aDadSF6[nPosF6,22]
EndIf

// Campos que soh eram gravados nas GNRE's de ST/DIFAL/FECP.
If aDadSF6[nPosF6][6] $ "3|A|B"
	If !Empty(cCodGnre)
		SB5->(dbSetOrder(1))
		If SB5->(msSeek(xFilial("SB5")+cCodGnre) .And. B5_CODGNRE > 0)
			nCodGnre := SB5->B5_CODGNRE
		EndIf
	EndIf
	If aApurSX3[FP_F6_FECP]
		If	Len(aDadSF6[nPosF6])>=20 .And. (aDadSF6[nPosF6][20])
			SF6->F6_FECP := "1"
		Else
			SF6->F6_FECP := "2"
		EndIf
	EndIf
	SF6->F6_CNPJ    := aDadSF6[nPosF6][21]
	SF6->F6_DETRECE := DetReceita("MV_DETGNR",SF6->F6_EST,SF6->F6_CODREC)
	SF6->F6_CODPROD := Iif(nCodGnre>0,nCodGnre,VAL(ProdGnre(SF6->F6_EST)))
	SF6->F6_REF     := RefGnre(SF6->F6_EST)
	If lSPCOBREC
		SF6->F6_COBREC := ExecBlock("SPCOBREC",.F.,.F.,{SF6->F6_TIPOIMP,SF6->F6_EST})
	Endif
EndIf

If aApurSX3[FP_F6_TIPOGNU] .And. aFindFunc[FF_RETCMPSSF6]
	aRet := RetCmpsSF6(SF6->F6_CODREC, SF6->F6_EST)

	SF6->F6_TIPOGNU := aRet[1]
	SF6->F6_DOCORIG := aRet[2]
	SF6->F6_DETRECE := aRet[3]
	SF6->F6_CODPROD := aRet[4]

	If Len(aRet) > 4 .And. aApurSX3[FP_F6_CODAREA]
		SF6->F6_CODAREA := aRet[5]
	EndIf

EndIf

If lGrValFund .And.Len(aDadSF6[nPosF6]) >= 24 .And. !Empty(aDadSF6[nPosF6,24])
	SF6->F6_VALFUND := aDadSF6[nPosF6,24]
EndIf

SF6->(MsUnlock())

Return NIL

/*/{Protheus.doc} AjustIPI
Função verifica se encontrou ajuste de IPI na CDA 
@author Rafael.soliveira
@since 22/11/2017
/*/

Function AjustIPI(cAliasSF3,aCDAIPI,cNrLivro)

Local cTpMov	:= Iif(Substr((cAliasSF3)->F3_CFO,1,1) >= "5","S","E")
Local cFormul	:= Iif(Empty((cAliasSF3)->F3_FORMUL),Iif(cTpMov == "S","S"," "),(cAliasSF3)->F3_FORMUL)
Local cChave	:= xFilial("CDA")+cTpMov+(cAliasSF3)->F3_ESPECIE+cFormul+(cAliasSF3)->F3_NFISCAL+(cAliasSF3)->F3_SERIE+(cAliasSF3)->F3_CLIEFOR+(cAliasSF3)->F3_LOJA
Local cItem		:= ""
Local cReflex	:= ""
Local cSPCFGLEG := "" // Chave para Separar Ajuste do Legado X Configurador de Tributos
Local nX		:= 0
Local nPos		:= 0
Local aLanc		:= {}
Local cEstDeb	:= "001"
Local cOutCred	:= "002/010/011/012/013/019/098/099"
Local cEstCred	:= "101/102"
Local cResCred	:= "103"
Local cOutDeb	:= "199"

dbSelectArea("CCK")

dbSelectArea("CDA")


If ASCAN(aChaveCDA,cChave) == 0 .And. MsSeek(cChave)	
	
	AADD(aChaveCDA,cChave)		
	
	While !CDA->(EOF()) .And. CDA_FILIAL+CDA_TPMOVI+CDA_ESPECI+CDA_FORMUL+CDA_NUMERO+CDA_SERIE+CDA_CLIFOR+CDA_LOJA == cChave
		
		cItem 		:= CDA->CDA_NUMITE		
		aLanc		:= {}		
		
		While !CDA->(EOF()) .And. CDA_FILIAL+CDA_TPMOVI+CDA_ESPECI+CDA_FORMUL+CDA_NUMERO+CDA_SERIE+CDA_CLIFOR+CDA_LOJA+CDA->CDA_NUMITE == cChave+cItem

			IF CDA->CDA_ORIGEM == "3" .And. CDA->CDA_VALOR > 0
				/*
				1-CC7_CODLAN
				2-CC7_CLANAP
				3-CC7_CODIPI
				*/

				//Desconsidera lancamentos marcados como 'Nao Ativos'
				If aApurSX3[FP_CDA_TPREG] .And. CDA->CDA_TPREG == "NA"
					CDA->(dbSkip())
					Loop
				EndIf
				
				If CCK->(dbSeek(xFilial("CCK")+CDA->CDA_CODLAN))

					Do Case
						Case CCK->CCK_CODAJU $ cEstDeb  ;cReflex := "004" //Estorno de Débito
						Case CCK->CCK_CODAJU $ cOutCred ;cReflex := "005" //Outros Créditos
						Case CCK->CCK_CODAJU $ cEstCred ;cReflex := "010" //Estorno Crédito
						Case CCK->CCK_CODAJU $ cResCred ;cReflex := "011" //Ressarcimento Crédito
						Case CCK->CCK_CODAJU $ cOutDeb  ;cReflex := "012" //Outros Débito
					EndCase				

					If !Empty(cReflex)
						cSPCFGLEG := ""
						IF Alltrim(CDA->CDA_IFCOMP) == 'CONFIG'
						   cSPCFGLEG := "CONFIG"
						EndIf
						AADD(aLanc,{cChave+cItem,cReflex,CCK->CCK_DESCR,CDA->CDA_VALOR,CDA->CDA_CODLAN,cSPCFGLEG})
					Endif
				EndIf
			Endif
			CDA->(dbSkip())
			
		EndDo
				
		For nX := 1 to len(aLanc)

			nPos  := aScan ( aCDAIPI, {|x| x[5]==aLanc[nX][5] .And. x[6]==aLanc[nX][6]} ) 

			IF nPos == 0 
				AADD(aCDAIPI,{aLanc[nX][1],aLanc[nX][2],aLanc[nX][3],aLanc[nX][4],aLanc[nX][5],aLanc[nX][6]})
			Else
				// Austes acumula valor
				aCDAIPI[nPos][4] += aLanc[nX][4]
			EndIF			
		Next
	EndDo	
Endif

Return

/*/{Protheus.doc} fGExtrApur
	(Função para excluir o credito acumulado)

	@type Function
	@author Vitor Ribeiro
	@since 18/07/2018

	@param cPeriodo, caracter, contém o periodo da apuração
	@param aEApCe6Ce5, array, dados da extra apuração

	@return Nil, nulo, não tem retorno

	@obs #vitor01
	/*/
Static Function fGExtrApur(cPeriodo,aEApCe6Ce5)

	Local nPosicao1 := 0
	Local nPosicao2 := 0	

	Local cAlsCe6Ce5 := ""
	Local cCampoCE5 := ""

	Local lCE5DESCRI := .F.
	Local lSDOC		 := aApurSX3[FP_CE5_SDOC]

	Default cPeriodo := ""

	Default aEApCe6Ce5 := {}

	lCE5DESCRI := aApurSX3[FP_CE5_DESCRI]

	If lCE5DESCRI
		cCampoCE5 := ",CE5.CE5_DESCRI"
	EndIf
	
	If lSDOC
		cCampoCE5 += ",CE5.CE5_SDOC"
	Endif	

	cCampoCE5 := "%" + cCampoCE5 + "%"

	#IFDEF TOP
	
	    If TcSrvType()<>"AS/400"
			// Pega o proximo alias
			cAlsCe6Ce5 := GetNextAlias()
	
			BeginSql Alias cAlsCe6Ce5
				Column CE6_TOTCRE As Numeric(16,2)
				Column CE6_TOTUTI As Numeric(16,2)
				Column CE6_TOTTRA As Numeric(16,2)
				Column CE6_SALDO As Numeric(16,2)
				COLUMN CE5_VALOR As Numeric(16,2)
				
				SELECT
					CE6.CE6_PERIOD, CE6.CE6_CODLAN, CE6.CE6_TOTCRE,
					CE6.CE6_TOTTRA, CE6.CE6_TOTUTI, CE6.CE6_SALDO,
					CE5.CE5_CODUTI, CE5.CE5_VALOR, CE5.CE5_NUMDOC,
					CE5.CE5_CHVNFE, CE5.CE5_CODCDH, CE5.CE5_TPLANC,
					CE5.CE5_TPMOV, CE5.CE5_TRANSF, CE5.CE5_SERIE,
					CE5.CE5_CLIFOR, CE5.CE5_LOJACF
					%Exp:cCampoCE5%
				FROM %Table:CE6% CE6

				INNER JOIN %Table:CE5% CE5 ON
					CE5.CE5_FILIAL = %xFilial:CE5%
					AND CE5.CE5_PERIOD = CE6.CE6_PERIOD
					AND CE5.CE5_CODLAN = CE6.CE6_CODLAN
					AND CE5.%NotDel%

				WHERE
					CE6.CE6_FILIAL = %xFilial:CE6%
					AND CE6.CE6_PERIOD = %Exp:cPeriodo%
					AND CE6.%NotDel%

				ORDER BY
					CE6.CE6_CODLAN
			EndSql

			// Seleciona a area
			DbSelectArea(cAlsCe6Ce5)

			// Enquanto não for final de arquivo
			While (cAlsCe6Ce5)->(!Eof())
				// Se for manual ou credito acumulado
				If AllTrim(SubStr((cAlsCe6Ce5)->CE5_TPLANC,1,1)) == "M" .Or. AllTrim(SubStr((cAlsCe6Ce5)->CE5_TPLANC,1,2)) == "CA"
					// Verifica se o codigo já existe no array
					nPosicao1 := Ascan(aEApCe6Ce5,{|x| x[2] == (cAlsCe6Ce5)->CE6_CODLAN })

					// Se não encontrou
					If Empty(nPosicao1)
						Aadd(aEApCe6Ce5,{})
						nPosicao1 := Len(aEApCe6Ce5)

						Aadd(aEApCe6Ce5[nPosicao1],(cAlsCe6Ce5)->CE6_PERIOD)	// 01 - CE6_PERIOD
						Aadd(aEApCe6Ce5[nPosicao1],(cAlsCe6Ce5)->CE6_CODLAN)	// 02 - CE6_CODLAN
						Aadd(aEApCe6Ce5[nPosicao1],(cAlsCe6Ce5)->CE6_TOTCRE)	// 03 - CE6_TOTCRE
						Aadd(aEApCe6Ce5[nPosicao1],(cAlsCe6Ce5)->CE6_TOTTRA)	// 04 - CE6_TOTTRA
						Aadd(aEApCe6Ce5[nPosicao1],(cAlsCe6Ce5)->CE6_TOTUTI)	// 05 - CE6_TOTUTI
						Aadd(aEApCe6Ce5[nPosicao1],(cAlsCe6Ce5)->CE6_SALDO)		// 06 - CE6_SALDO
						Aadd(aEApCe6Ce5[nPosicao1],{})							// 07 - Dados da CE5
					EndIf

					Aadd(aEApCe6Ce5[nPosicao1][7],{})
					nPosicao2 := Len(aEApCe6Ce5[nPosicao1][7])

					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_CODUTI)	// 01 - CE5_CODUTI
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_VALOR)	// 02 - CE5_VALOR
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_NUMDOC)	// 03 - CE5_NUMDOC
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_CHVNFE)	// 04 - CE5_CHVNFE
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_CODCDH)	// 05 - CE5_CODCDH
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_TPLANC)	// 06 - CE5_TPLANC
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_TPMOV)	// 07 - CE5_TPMOV
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_TRANSF)	// 08 - CE5_TRANSF
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_SERIE)	// 09 - CE5_SERIE
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_CLIFOR)	// 10 - CE5_CLIFOR
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_LOJACF)	// 11 - CE5_LOJACF			
					
					If lSDOC
						Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],(cAlsCe6Ce5)->CE5_SDOC)	// 12 - CE5_SDOC
					Else
						Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],"")						// 12 - CE5_SDOC					
					Endif
					
					Aadd(aEApCe6Ce5[nPosicao1][7][nPosicao2],"")						// 13 - CE5_DESCRI

					If lCE5DESCRI
						aEApCe6Ce5[nPosicao1][7][nPosicao2][13] := AllTrim((cAlsCe6Ce5)->CE5_DESCRI)
					EndIf
				EndIf

				(cAlsCe6Ce5)->(DbSkip())
			EndDo
		EndIf

	#ENDIF

Return Nil

//valida se Códigos de Apuração foram preenchidos para linhas Adicionais
Static Function ValidCodIPI(aGetApur)
Local nX 	:= 0

For nX := 1 To Len(aGetApur)
	IF aGetApur[nX][4] == "DD" .And. Empty(aGetApur[nX][5])		
		Alert("Deve ser informado Código de Ajuste de IPI para o Campo: "+ aGetApur[nX][1])
		Return .F.		
	Endif	
Next

Return .T.

/*/{Protheus.doc} FVERREF
	(Função para ajustar variável estática lRefazApur)

	@type Function
	@author Paulo Krüger
	@since 10/10/2018
	@return lRefazApur
/*/

Function FVERREF()

Return(lRefazApur) 




/*/{Protheus.doc} DevDebEsp
	 Função responsavel por identificador se ocorreu devolução para ajustes de debitos especial

	@type Function
	@author Rafael Oliveira
	@since 19/03/2020
	@return Quantidade devolvida
/*/
Function DevLanc(cNumero, cSerie, cItem, cClieFor, cLoja, dData, cTipoMov)
Local aArea		:= GetArea()
Local dDatade	:= FirstDay(dData)
Local dDataAte	:= LastDay(dData)
Local cAlsDev	:= GetNextAlias()
Local nQuant	:= 0

BeginSql Alias cAlsDev

	SELECT FT_QUANT AS QTDDEV
	
	FROM %Table:SFT% SFT
	
	WHERE 		
		SFT.FT_NFORI   = %Exp:cNumero% 
	AND	SFT.FT_SERORI  = %Exp:cSerie% 
	AND	SFT.FT_ITEMORI = %Exp:cItem%
	AND	SFT.FT_CLIEFOR = %Exp:cClieFor%
	AND	SFT.FT_LOJA    = %Exp:cLoja%		
	AND	SFT.FT_ENTRADA BETWEEN %Exp:dDatade% AND %Exp:dDataAte%
	AND	(SFT.FT_DTCANC  = ' ' OR SFT.FT_DTCANC NOT BETWEEN %Exp:dDatade% AND %Exp:dDataAte%)
	AND SFT.FT_TIPOMOV  = %Exp:cTipoMov% 
	AND SFT.FT_TIPO     = 'D'	
	AND	SFT.%NotDel%
			
EndSql

nQuant :=  (cAlsDev)->QTDDEV
(cAlsDev)->(dbCloseArea())
RestArea(aArea)

Return nQuant

Static Function xApCodArea(cCodRec)

Local nX         	:= 0
Local aContentX5 	:= {}
Local cCodArea		:= ""

	aContentX5 := FWGetSX5( "WH" )
	For nX := 1 To Len( aContentX5 )
		If Alltrim(cCodRec) $ Alltrim(aContentX5[nX][4])        
			cCodArea := Alltrim(aContentX5[nX][3])
			Exit
		EndIf		        
	Next nX

Return cCodArea



//-------------------------------------------------------------------
/*/{Protheus.doc} LoadX3Apur
Funcao responsavel por realizar o cache dos parametros (SX6)

@return aRet - Array com o cache do SX6.

@author Rafael Oliveira
/*/
//-------------------------------------------------------------------
Function LoadX3Apur()

Local nX := 0
Local nPos := 0
Local aAlias := {}
Local aRet := {}
Local bError
Local lErro	:= .F.
Local aFPCpo :={{"CDP", "CDP_TPLANC"},;      //01
                {"CC6", "CC6_AGRUPA"},;      //02
                {"CC6", "CC6_GNRESE"},;      //03
                {"CC6", "CC6_NATURE"},;      //04
                {"CC6", "CC6_SUBAP"},;       //05
                {"CC6", "CC6_TIPOAJ"},;      //06
                {"CC6", "CC6_TPIMP"},;       //07
                {"CC6", "CC6_TPMOV"},;       //08
                {"CCF", "CCF_IDITEM"},;      //09
                {"CDA", "CDA_GNRE"},;        //10
                {"CDA", "CDA_GUIA"},;        //11
                {"CDA", "CDA_ORIGEM"},;      //12
                {"CDA", "CDA_TPREG"},;       //13
                {"CDA", "CDA_UFGNRE"},;      //14
                {"CDH", "CDH_GNREF3"},;      //15
                {"CDH", "CDH_ITPROC"},;      //16
                {"CDH", "CDH_PROCES"},;      //17
                {"CDH", "CDH_PROCTP"},;      //18
                {"CDH", "CDH_PROIND"},;      //19
                {"CDH", "CDH_TPLANC"},;      //20
                {"CDO", "CDO_AGRUPA"},;      //21
                {"CDO", "CDO_GNRESE"},;      //22
                {"CDO", "CDO_MSBLQL"},;      //23
                {"CDO", "CDO_NATURE"},;      //24
                {"CDO", "CDO_SUBAP"},;       //25
                {"CDO", "CDO_TPIMP"},;       //26
                {"CDO", "CDO_TPMOV"},;       //27
                {"CDV", "CDV_AUTO"},;        //28
                {"CDV", "CDV_ID"},;          //29
                {"CE5", "CE5_DESCRI"},;      //30
                {"CE5", "CE5_SDOC"},;        //31
                {"CE5", "CE5_TPLANC"},;      //32
                {"F0I", "F0I_DBESPF"},;      //33
                {"F0I", "F0I_DEDFCP"},;      //34
                {"F0I", "F0I_DEVFCP"},;      //35
                {"F0I", "F0I_ESTCRF"},;      //36
                {"F0I", "F0I_ESTDBF"},;      //37
                {"F0I", "F0I_OUTCRF"},;      //38
                {"F0I", "F0I_OUTDBF"},;      //39
                {"F0K", "F0K_ITPROC"},;      //40
                {"F0K", "F0K_PROCES"},;      //41
                {"F0K", "F0K_PROCTP"},;      //42
                {"F0K", "F0K_PROIND"},;      //43
                {"F3K", "CDY_DTFIM"},;       //44
                {"F3K", "CDY_DTINI"},;       //45
                {"F3K", "F3K_CST"},;         //46
                {"SA1", "A1_CRDMA"},;        //47
                {"SA1", "A1_REGPB"},;        //48
                {"SA2", "A2_SIMPNAC"},;      //49
                {"SB1", "B1_ALFECOP"},;      //50
                {"SB1", "B1_ALFECST"},;      //51
                {"SB1", "B1_FECOP"},;        //52
                {"SB1", "B1_POSIPI"},;       //53
                {"SB1", "B1_PRODREC"},;      //54
                {"SB1", "B1_RICM65"},;       //55
                {"SB5", "B5_PROJDES"},;      //56
                {"SB5", "B5_TPAPUR"},;       //57
                {"SBZ", "BZ_PROJDES"},;      //58
                {"SF2", "F2_GNRDIF"},;       //59
                {"SF2", "F2_GNRFECP"},;      //60
                {"SF2", "F2_NFICMST"},;      //61
                {"SF2", "F2_NTFECP"},;       //62
                {"SF3", "F3_BASEDES"},;      //63
                {"SF3", "F3_BSICMOR"},;      //64
                {"SF3", "F3_CNAE"},;         //65
                {"SF3", "F3_CRDPCTR"},;      //66
                {"SF3", "F3_CREDACU"},;      //67
                {"SF3", "F3_CREDPRE"},;      //68
                {"SF3", "F3_DIFAL"},;        //69
                {"SF3", "F3_ESTCRED"},;      //70
                {"SF3", "F3_VALANTI"},;      //71
                {"SF3", "F3_VALFECP"},;      //72
                {"SF3", "F3_VFCPDIF"},;      //73
                {"SF3", "F3_VFECPMG"},;      //74
                {"SF3", "F3_VFECPMT"},;      //75
                {"SF3", "F3_VFECPRN"},;      //76
                {"SF3", "F3_VFECPST"},;      //77
                {"SF3", "F3_VFESTMG"},;      //78
                {"SF3", "F3_VFESTMT"},;      //79
                {"SF3", "F3_VFESTRN"},;      //80
                {"SF3", "F3_VLINCMG"},;      //81
                {"SF3", "F3_VLSENAR"},;      //82
                {"SF4", "F4_CRDEST"},;       //83
                {"SF4", "F4_CRLEIT"},;       //84
                {"SF4", "F4_ESCRDPR"},;      //85
                {"SF4", "F4_FTATUSC"},;      //86
                {"SF4", "F4_IPI"},;          //87
                {"SF4", "F4_IPIPECR"},;      //88
                {"SF4", "F4_MKPCMP"},;       //89
                {"SF4", "F4_PCREDAC"},;      //90				
                {"SF4", "F4_PRZESP"},;       //91
                {"SF4", "F4_TABGIAC"},;      //92
                {"SF4", "F4_TABGIAI"},;      //93
                {"SF4", "F4_TABGIAO"},;      //94
                {"SF4", "F4_TXAPIPI"},;      //95
                {"SF4", "F4_VARATAC"},;      //96
                {"SF6", "F3_CODRSEF"},;      //97
                {"SF6", "F6_CODAREA"},;      //98
                {"SF6", "F6_FECP"},;         //99
                {"SF6", "F6_TIPOGNU"},;      //100
                {"SF6", "F6_TIPOIMP"},;      //101
                {"SFA", "FA_VALICCO"},;      //102
                {"SFA", "FA_VLDBATV"},;      //103
                {"SFT", "FT_ALFCCMP"},;      //104
                {"SFT", "FT_BSICMOR"},;      //105
                {"SFT", "FT_CPPRODE"},;      //106
                {"SFT", "FT_CPRESPR"},;      //107
                {"SFT", "FT_CRDPCTR"},;      //108
                {"SFT", "FT_CREDPRE"},;      //109
                {"SFT", "FT_CREDST"},;       //110
                {"SFT", "FT_CROUTGO"},;      //111
                {"SFT", "FT_CROUTSP"},;      //112
                {"SFT", "FT_CRPRELE"},;      //113
                {"SFT", "FT_CRPREPE"},;      //114
                {"SFT", "FT_CRPREPR"},;      //115
                {"SFT", "FT_CRPRERO"},;      //116
                {"SFT", "FT_CRPRESP"},;      //117
                {"SFT", "FT_CRPRSIM"},;      //118
                {"SFT", "FT_CRPRST"},;       //119
                {"SFT", "FT_CV139"},;        //120
                {"SFT", "FT_DIFAL"},;        //121
                {"SFT", "FT_DS43080"},;      //122
                {"SFT", "FT_ESTCRED"},;      //123
                {"SFT", "FT_PDDES"},;        //124
                {"SFT", "FT_PR43080"},;      //125
                {"SFT", "FT_SOLTRIB"},;      //126
                {"SFT", "FT_TES"},;          //127
                {"SFT", "FT_TPPRODE"},;      //128
                {"SFT", "FT_VALANTI"},;      //129
                {"SFT", "FT_VALFDS"},;       //130
                {"SFT", "FT_VALFECP"},;      //131
                {"SFT", "FT_VALFEEF"},;      //132
                {"SFT", "FT_VALFUM"},;       //133
                {"SFT", "FT_VALPRO"},;       //134
                {"SFT", "FT_VALTST"},;       //135
                {"SFT", "FT_VFCPDIF"},;      //136
                {"SFT", "FT_VFECPMG"},;      //137
                {"SFT", "FT_VFECPMT"},;      //138
                {"SFT", "FT_VFECPRN"},;      //139
                {"SFT", "FT_VFECPST"},;      //140
                {"SFT", "FT_VFESTMG"},;      //141
                {"SFT", "FT_VFESTMT"},;      //142
                {"SFT", "FT_VFESTRN"},;      //143
                {"SFT", "FT_VLSENAR"},;      //144				
				{"SF3", "F3_CROUTSP"},;      //145
				{"SF3", "F3_CROUTGO"},;      //146
				{"SF3", "F3_VALFUM"},;       //147
				{"SF3", "F3_CRPREPR"},;      //148
				{"SF3", "F3_CPRESPR"},;      //149
				{"SF3", "F3_CRPRERO"},;      //150
				{"SF3", "F3_CRPREPE"},;      //151
				{"SF3", "F3_CPPRODE"},;      //152
				{"SF3", "F3_TPPRODE"},;      //153
				{"SF3", "F3_CRPRESP"},;      //154
				{"SF3", "F3_VALTST"} ,;      //155
				{"SF3", "F3_CRPRELE"},;      //156
				{"SF3", "F3_VALFDS"},;       //157
				{"SF3", "F3_CRPRSIM"},;      //158
				{"SF6", "F6_VALFUND"},;      //159
				{"CDA", "CDA_VLOUTR"},;      //160
				{"CDA", "CDA_REGCAL"},;      //161
				{"CJA","CJA_FILIAL"},;		 //162
				{"CJA","CJA_ID"}    ,;		 //163
				{"CJA","CJA_CODREG"},;	     //164	
				{"CJA","CJA_ID_CAB"},;	     //165
				{"CJA","CJA_REGCAL"},;	     //166
				{"CJA","CJA_CODTAB"},;	     //167
				{"CJA","CJA_CODLAN"},;	     //168
				{"CJA","CJA_VIGINI"},;	     //169
				{"CJA","CJA_VIGFIM"},;	     //170
				{"CJA","CJA_NFBASE"},;	     //171
				{"CJA","CJA_NFALIQ"},;	     //172
				{"CJA","CJA_VALOR"} ,;	     //173
				{"CJA","CJA_VLOUTR"},;	     //174
				{"CJA","CJA_GRGUIA"},;	     //175
				{"CJA","CJA_GUIA"}  ,;	     //176
				{"CJA","CJA_TITULO"},;	     //177
				{"CJA","CJA_TITGUI"}}        //178

bError := ErrorBlock( {|| lErro := .T. } )

BEGIN SEQUENCE
	//Tentar executar alias indic
	FWAliasIndic("SA1")
END SEQUENCE

ErrorBlock( bError )

If !lErro
	For nX := 1 to Len(aFPCpo)
		nPos := aScan( aAlias , {|x| x[1] == aFPCpo[nX,01] } )
		If nPos == 0
			aAdd( aAlias , { aFPCpo[nX,01] , FWAliasIndic(aFPCpo[nX,01]) } )
			nPos := Len(aAlias)
		EndIf
		aAdd(aRet , IIf( aAlias[nPos,02] .And. (aFPCpo[nX,01])->(FieldPos(aFPCpo[nX,02])) > 0 , .T. , .F. ) )
	Next nX
EndIf

Return aRet


//-------------------------------------------------------------------
/*/{Protheus.doc} LoadX2Apur
Funcao responsavel por realizar o cache dos FWAliasInDic utilizados nas apurações de ICMS, IPI e ISS

@return aRet - Array com o cache do SX2.

@author Rafael Oliveira
/*/
//-------------------------------------------------------------------
Function LoadX2Apur()

Local nX := 0
Local aRet := {}
Local bError
Local lErro	:= .F.

Local aDic := {	"F2B",; //01
				"CC6",; //02
				"CCK",; //03
				"CDA",; //04
				"CDH",; //05
				"CDM",; //06			
				"CDO",; //07
				"CDP",; //08
				"CDV",; //09
				"CDV",; //10
				"CDY",; //11					
				"CJ4",; //12					
				"DH0",; //13
				"F0I",; //14
				"F0J",; //15
				"F0K",; //16
				"F2P",; //17
				"F2R",; //18
				"F3K",; //19
				"CJA",; //20
				"CJV",; //21
				"CJW"}  //22



bError := ErrorBlock( {|| lErro := .T. } )

BEGIN SEQUENCE
	//Tentar executar alias indic
	FWAliasInDic("SFT")
END SEQUENCE

ErrorBlock( bError )

If !lErro
	//O Ambiente está inicializado
	For nX:=1 to Len(aDic)
		aAdd(aRet, FWAliasIndic(aDic[nX]) )
	Next nX
EndIf

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} LoadPEApur
Funcao responsavel por realizar o cache dos ExistBloc utilizados nas apurações de ICMS, IPI e ISS

@return aRet - Array com o cache dos pontos de entrada.

@author Rafael Oliveira
/*/
//-------------------------------------------------------------------
Function LoadPEApur()

Local  aExistBloc	:= {ExistBlock("MGETAPUR")	,;
						ExistBlock("APURDEV")	,;
						ExistBlock("APURICM")	,;
						ExistBlock("PROCAPUR")	,;
						ExistBlock("JOINCM")	,;						
						ExistBlock("CPAPUICMS")	,;
						ExistBlock("TITICMST")	,;
						ExistBlock("INFOGNRE")	,;
						ExistBlock("DADOSTIT")	,;
						ExistBlock("APURF6OK")	,;
						ExistBlock("APURF6CAN")	,;
						ExistBlock("TABGIARS")	,;
						ExistBlock("SPCOBREC")	,;
						ExistBlock("GDEBESP")	,;
						ExistBlock("A953CONT")	,;
						ExistBlock("MT953TIT")	,;
						ExistBlock("GIASCDEB")	,;
						ExistBlock("A952CONT")}
Return aExistBloc


/*/{Protheus.doc} GFFMxFis
	Retorna FindFunction das funções no repositorio.

	Esta funcao foi criada apenas para NAO chamar a funcao
	FindFunction() a todo momento. 

	@author Rafael.soliveira
	@since 24/07/2021
	@version 12.1.27
	@return xRet, array, Retorna array contendo resultado de cada função consultada.
	/*/

Function LoadXFFApur()
	Local nX := 0
	Local xRet  := {}
	LOCAL aFF_  := {"GETSUMDH0"	   ,;	//01
					"FINGRVEX"	   ,;	//02
					"RETCMPSSF6"   ,;	//03
					"MAXRVERFUNC"  ,;	//04
					"GETSUBTRIB"   ,;	//05					
					"VLDMTR928"    ,;	//06
					"XAPGETINCENT" ,;	//07
					"SELRELR017"   ,;	//08
					"MATA952A"     ,;	//09
					"GETPARAUTO"   ,;	//10
					"GETDESCCDY"   ,;	//11
					"MATA953A"     ,;	//12
					"FISR4123"     }	//13

	/*  IMPORTANTE: TODA VEZ QUE CHAMAR O FindFunction() DE UMA NOVA FUNÇÂO, DEVERA SER CRIADA A REFERENCIA NA
	MATXDEF E ADD A FUNÇÂO ARRAY aFF_ DESTA FUNCAO OBRIGATORIAMENTE NA MESMA POSICAO(NUMERO) DO XDEF.CH*/

	For nX:=1 to Len(aFF_)
		aAdd(xRet, FindFunction(aFF_[nX]) )
	Next nX	

Return xRet

/*/{Protheus.doc} VldNatCdAj
	Retorna Validação do campo de codigo de ajuste do IPI.

	@author Alexandre Esteves 
	@since 13/12/2021
	@version 12.1.33
/*/

Static Function VldNatCdAj(cCodAju,cCampo)

Local lRet := .T.
Default cCodAju := ""
Default cCampo 	:= ""

If cCampo <= "005"

	If cCodAju >= "100"
		MsgAlert(STR0149,STR0148) 	//STR0148 - "Código de Ajuste Inválido"
		//STR0149 - "Codigo de Ajuste com Natureza de Débito para Linha de Ajuste de Crédito. Utilizar código menor que 100"
		lRet := .F.
	Endif
Else

	If cCodAju <= "100"
		MsgAlert(STR0150,STR0148) 	//STR0148 - "Código de Ajuste Inválido"
		//STR0150 - "Codigo de Ajuste com Natureza de Crédito para Linha de Ajuste de Débito. Utilizar código maior que 100"
		lRet := .F.
	Endif
Endif

Return lRet

 /*/{Protheus.doc} codReceinf
	Função responável por retornar codigo específico por estado, se houver.
	@Rhuan Carvalho
	@since 09/10/2023
	@Parametros: Conteúdo do parametro, array dados SF6
	@Retorno: Código específico para o Estado, se houver.
	/*/
Static Function codReceinf(cCODRECNF, aDadSF6, nPos)
	Local cCodUF    := ""
	Local cCodReinf := ""
	Local cEstadRec := aDadSF6[nPos][8]
	Local aDados    := {}
	Local aCodUf    := {}
	Local nx        := 0
	Local nSinal    := At("=", cCODRECNF)


	If nSinal <> 0

		aDados := Separa(cCODRECNF, ";", .F.)

		For nx := 1 to Len(aDados)	
			If At("=",aDados[nx]) <> 0
				cCodUF := Substr(aDados[nx], At("=",aDados[nx])-2,2)
				If cCodUf == cEstadRec
					aCodUf := Separa(aDados[nx], "=", .F.)
					cCodReinf := aCodUf[2]
					Return cCodReinf
				EndIF
			else
				cCodReinf := aDados[nx]
			EndIf
		NEXT

	else
		cCodReinf := cCODRECNF
		Return cCodReinf
	EndIf

Return cCodReinf

 /*/{Protheus.doc} lancCDAApu
	Função responável por retornar os arrays de dados dos codigos de lançamentoe de ajustes da apuração
	@Erich Buttner
	@since 26/02/2024
	@Parametros: 
	aApurCDA - Acumulador de valores da apuração de CDA
	aCDAIC - Array responsavel por acumular os valores e codigo de lançàmentos/apuração de ICMS
	aCDAST - Array responsavel por acumular os valores e codigo de lançàmentos/apuração de ICMS-ST
	aCDADE - Array responsavel por acumular os valores e codigo de lançàmentos/apuração de Debitos Especiais
	aDbEsp - Array de debitos especiais contendo codigos de lançamento e valores
	cNrLivro - Numero do livro fiscal selecionado
	aCdaDifal - Array responsavel por acumular os valores e codigo de lançàmentos/apuração de Difal
	aCDAExtra - Array responsavel por acumular os valores e codigo de lançàmentos/apuração de Extra apuração
	aApurExtra - Array responsavel por acumular os codigos de ajuste de credito da apuração extra
	aSubAp - Array responsavel por acumular os valores e codigo de lançàmentos/apuração de sub apuração
	dDtIni - Data de inicio do periodo apurado
	dDtFim - Data final do periodo apurado
	nDiasAcreDt - Dias acrescidos a data final
	lF3CODRSEF - Flag para indicar se a apuração é referente a RSEF
	cMvCODRSEF - Codigo de RSEF
	cMv_Estado - Estado do movimento
	lF3Cnae - Flag para indicar se a apuração é referente a CNAE
	cDtCanc - Data de cancelamento
	lConjugada - Flag para indicar se a apuração é conjugada
	lRefazApur - Flag para indicar se a apuração deve ser refeita


	@Retorno: retorna os arrays aApurCDA, aCDAIC, aCDAST, aCDADE, aDbEsp, aCdaDifal, aCDAExtra, aApurExtra
	/*/
Function lancCDAApu(aApurCDA, aCDAIC, aCDAST, aCDADE, aDbEsp, cNrLivro, aCdaDifal, aCDAExtra, aApurExtra, aSubAp, dDtIni, dDtFim,;
				    nDiasAcreDt, lProcRefer, lF3CODRSEF, cMvCODRSEF, cMv_Estado, lF3Cnae, cDtCanc, lConjugada, lRefazApur)

Local cQry 			:= ""
Local cMD5 			:= ""
Local nPosPrepared 	:= 0
Local cAliasCDA 	:= ""
Local cApurSep		:= Alltrim(SuperGetMV("MV_APUSEP",,""))
Local lCdaVlou		:= aApurSX3[FP_CDA_VLOUTR] .And. aApurSX3[FP_CDA_REGCAL]
Local cChaveNF		:= ""
Local cChaveNfe		:= ""
Local nX 			:= 0
Local lOldLan		:= aApurSX2[AI_CC6] .And. aApurSX3[FP_CC6_TIPOAJ]
Local aLanc			:= {}
Local lCDOTPMOV		:= aApurSX3[FP_CDO_TPMOV] 
Local lCC6TPMOV		:= aApurSX3[FP_CC6_TPMOV]
Local cAdlinha		:= "002/003/006/007/012/007/008/014"
Local cAdDebEsp 	:= "/900/901/"
Local lIndivid		:= .F.
Local cCDAGNRE		:= ""
Local lSkpSubAp		:= .F.
Local nPosDlDIFA	:= 0
Local lCDAGNRE		:= aApurSX3[FP_CDA_GNRE]
Local cAj_REFLEX	:= ""
Local nCDAValor		:= 0
Local cChave		:= ""
Local cItem			:= ""
Local cReflex		:= ""
Local aParam		:= {}
Local lEntrada		:= .T.
Local nE			:= 0
Local nY			:= 0
Local nPosCDADIFAL	:= 0
Local nPosCDAIC		:= 0
Local nPosCDAST		:= 0
Local nPosCDADE		:= 0
Local nPosCDAExtra	:= 0
Local nPosApuExtra	:= 0
Local cChvCDAExtra	:= ""
Local cChvApuExtra	:= ""
Local cChvCDAIC		:= ""
Local cChvCDAST		:= ""
Local cChvCDADE		:= ""
Local cChvCdaDifal	:= ""
Local cChvDIFAL		:= ""
Local jCDAExtra		:= JsonObject():New()
Local jApuExtra		:= JsonObject():New()
Local jCDAIC		:= JsonObject():New()
Local jCDAST		:= JsonObject():New()
Local jCDADE		:= JsonObject():New()
Local jCdaDifal		:= JsonObject():New()
Local jDeldifal		:= JsonObject():New()
Local cNfLivro		:= ""
Local lProcIndiv	:= .F.

Default	aCDADE		:= {}
Default	aDbEsp		:= {}
Default cNrLivro	:= ""
Default aCDADifal	:= {}
Default aCDAExtra	:= {}
Default aApurExtra	:= {}
Default lProcRefer	:= .F.
Default cMV_ESTADO	:= SuperGetMV("MV_ESTADO", .F., "SP")
Default nDiasAcreDt	:= IIf( cMv_Estado == "SP" , 15 , IIf( cMv_Estado == "PR" , 5 , 0 ) )
Default lF3CODRSEF 	:= aApurSX3[FP_F3_CODRSEF]
Default cMvCODRSEF 	:= SuperGetMv("MV_CODRSEF", .F., "'','100'")
Default dDtIni		:= CtoD("")
Default dDtFim		:= CtoD("")
Default aSubAp		:= {}

For nY := 1 to 2 //1 = Agrupado 2 = Individual
	If nY == 1
		lProcIndiv := .F.
	Else
		lProcIndiv := .T.
	EndIf

	//Select para notas fiscais de entrada
	lEntrada := .T.	
	cQry := ConsultCDA(dDtIni, dDtFim, nDiasAcreDt, cDtCanc, lF3Cnae, lF3CODRSEF, cMvCODRSEF, cNrLivro,lEntrada, cMV_ESTADO,lConjugada, lProcIndiv, @aParam)

	cQry += " UNION "

	lEntrada := .F.	
	//where para otas fiscais de Saida
	cQry += ConsultCDA(dDtIni, dDtFim, nDiasAcreDt, cDtCanc, lF3Cnae, lF3CODRSEF, cMvCODRSEF, cNrLivro,lEntrada, cMV_ESTADO,lConjugada, lProcIndiv, @aParam)

	cMD5 := MD5(cQry)
	If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0 
		Aadd(__aPrepared,{FWExecStatement():New(),cMD5})
		nPosPrepared := Len(__aPrepared)
		__aPrepared[nPosPrepared][1]:SetQuery(ChangeQuery(cQry))
	EndIf 

	For nE := 1 to Len(aParam)
		If aParam[nE][1] == 'C'
			__aPrepared[nPosPrepared][1]:SetString(nE, aParam[nE][2])
		Elseif aParam[nE][1] == 'D'
			__aPrepared[nPosPrepared][1]:SetDate(nE, aParam[nE][2])
		Elseif aParam[nE][1] == 'U'
			__aPrepared[nPosPrepared][1]:SetUnsafe(nE, aParam[nE][2])
		Elseif aParam[nE][1] == 'A'	
			__aPrepared[nPosPrepared][1]:SetIn(nE, aParam[nE][2])
		EndIf
	Next nE

	aSize(aParam, 0)
	aParam := {}

	cQry := __aPrepared[nPosPrepared][1]:getFixQuery()

	cAliasCDA := __aPrepared[nPosPrepared][1]:OpenAlias()

	While (cAliasCDA)->(!EOF())

		cChave   := ""
		cChaveNF := ""
		cChaveNfe:= ""
		cItem	 := ""

		cNfLivro	:= (cAliasCDA)->F3_NRLIVRO
		lSkpSubAp	:= .F.

		If lProcIndiv
			//definição de chave  CDA_FILIAL+CDA_TPMOVI+CDA_ESPECI+CDA_FORMUL+CDA_NUMERO+CDA_SERIE+CDA_CLIFOR+CDA_LOJA+CDA_NUMITE+CDA_SEQ+CDA_CODLAN+CDA_CALPRO
			cChave		:= AllTrim(xFilial('CDA')+(cAliasCDA)->CDA_TPMOVI+(cAliasCDA)->CDA_ESPECI+(cAliasCDA)->CDA_FORMUL+(cAliasCDA)->CDA_NUMERO+(cAliasCDA)->CDA_SERIE+(cAliasCDA)->CDA_CLIFOR+(cAliasCDA)->CDA_LOJA)
			cChaveNF 	:= (cAliasCDA)->(CDA_TPMOVI + CDA_SERIE + CDA_NUMERO + CDA_CLIFOR + CDA_LOJA)
			cChaveNfe 	:= (cAliasCDA)-> FT_CHVNFE
			cItem 		:= (cAliasCDA)-> CDA_NUMITE
		EndIf

		If Len(AllTrim((cAliasCDA)->CDA_CODLAN)) == 10
			//Verifica se no cadastro está para apurar individualmente as valores do código de lançamento
			cCDAGNRE	:= ''

			lIndivid	:= lProcIndiv

			IF lCDAGNRE
				cCDAGNRE	:= (cAliasCDA)->CDA_GNRE
			EndIF

			If aSubAp[2] .And. !Empty((cAliasCDA)->CC6_SUBAP)
				If cNrLivro == '*' 
					If (cAliasCDA)->CC6_SUBAP == "1"
						lSkpSubAp := .T.
					EndIf
				Endif
				If (cNrLivro <> '*' .And. cNrLivro <> cNfLivro) .Or. (cNrLivro <> '*' .And. (cAliasCDA)->CC6_SUBAP = "3" ) 
					lSkpSubAp := .T.
				EndIf	
								
			Else
			// Abaixo a condição para ignorar o lançamento no caso de Subapuração.
			// A SubApuração é tratada pelo nr.Livro. Quando o cliente informa um livro no parâmetro MV_APUSEP ele passa a 
			// considerar como uma subapuração. Neste caso primeiramente o cliente realiza a apuração completa, informando "*" na apuração. Nete
			// e depois ele apura somente o livro da Subapuração.
			lSkpSubAp := (!lOldLan .And. !Empty(cNrLivro) .And. !Empty(cApurSep) .And.;
						( (cNrLivro$cApurSep .And. SubStr((cAliasCDA)->CDA_CODLAN,4,1)$"3/4/5/6" .And. !(cAliasCDA)->CC6_REFLEX == "7") .Or.; //Quando for sub-apuração e debito especial deve ser apresentado na sub-apuração do proprio livro // registro 1900 Campo 13 (DEB_ESP_OA) 
						(  !(cNrLivro$cApurSep) .And. cNfLivro$cApurSep .And. (!(SubStr((cAliasCDA)->CDA_CODLAN,4,1)$"3/4/5/6") .OR. (cAliasCDA)->CC6_REFLEX == "7")) ) )
			EndIf	

			If "1"$(cAliasCDA)->CC6_TPAPUR
				lLancST := .T.
			Else
				lLancST := .F.
				If (lOldLan .And. (cAliasCDA)->CC6_TPAPUR <> "000") .Or.;
				(!lOldLan .And. (cAliasCDA)->CC6_TPAPUR $ "1/2/9") .Or.;
				lSkpSubAp
					//Se o lancamento nao for tipo 0 ou  nao deve considerar na apuracao
					(cAliasCDA)->(dbSkip())
					Loop
				EndIf
			EndIf
						
			If lOldLan
				cReflex := (cAliasCDA)->CC6_REFLEX
			Else		

				cAj_REFLEX := (cAliasCDA)->CC6_REFLEX

				If lLancST
					Do Case
						Case cAj_REFLEX == "0";cReflex := "006"
						Case cAj_REFLEX == "1";cReflex := "007"
						Case cAj_REFLEX == "2";cReflex := "008"
						Case cAj_REFLEX == "3";cReflex := "001"
						Case cAj_REFLEX == "4";cReflex := "002"
						Case cAj_REFLEX == "5";cReflex := "003"
						Case cAj_REFLEX == "6";cReflex := "014"
						Case cAj_REFLEX == "7";cReflex := "901"
					EndCase
				Else
					Do Case 
					// Para os códigos de lançamento iniciados por "0" foi efetuado o tratamento abaixo,
					// onde o mesmo  dever se levado na linha 006 da apuração, considerendo a Norma Técnica num. 003/2013
					// segundo a solicitação do Chamado: THL605 
					// Realizado tratamento para que o codigo PA00000999 seja considerado cna linha 006 da apuração. 
					// Isso foi realizado pois, para codigos iniciados com ZERO já é considerado automaticamente na linha 005, e este
					// codigo precisa ser considerado como Outros Débitos. Chamado THWNEH   
						Case cAj_REFLEX $ "1|0";cReflex := "006"
						Case cAj_REFLEX == "2";cReflex := "007"
						Case cAj_REFLEX $ "4|3";cReflex := "002"
						Case cAj_REFLEX == "5";cReflex := "003"
						Case cAj_REFLEX == "6";cReflex := "012"
						Case cAj_REFLEX == "7";cReflex := "900"
					EndCase
				EndIf
			EndIf
			
			lRet := .T. // Retorno T para desconsiderar o valor do SF3
			nCDAValor	:= ((cAliasCDA)->CDA_VALOR + Iif(lCdaVlou, (cAliasCDA)->CDA_VLOUTR,0) )

			AADD(aLanc,{cChave+cItem,(cAliasCDA)->CDA_CALPRO,(cAliasCDA)->CC6_TPAPUR,cReflex,(cAliasCDA)->CC6_DESCR + SPACE( 47-len(Alltrim((cAliasCDA)->CC6_DESCR)) ),nCDAValor,(cAliasCDA)->CDA_CODLAN,lIndivid,cCDAGNRE,cChaveNF,Iif(lCdaVlou,(cAliasCDA)->CDA_REGCAL,"")})
			
			IF lCC6TPMOV .AND. !EmptY((cAliasCDA)->CC6_TPMOV) .AND. Iif( (cAliasCDA)->CC6_TPMOV == 'U',!Empty((cAliasCDA)->CC6_CODUTI) , .T. )  .AND. !Empty((cAliasCDA)->CC6_CODCRE)									                                                                                  
				
				//Adiciona no array o valor gravado na CDA que irá refletir na aba extra apuração
				cChvCDAExtra := (cAliasCDA)->CC6_CODCRE+(cAliasCDA)->CC6_TPMOV+(cAliasCDA)->CC6_CODUTI+Iif(lIndivid, (cAliasCDA)->CDA_NUMERO+cChaveNF,"")
				
				IF !PesqjSon(jCDAExtra,cChvCDAExtra,@nPosCDAExtra)
					AADD(aCDAExtra,{(cAliasCDA)->CC6_CODCRE,(cAliasCDA)->CC6_TPMOV,(cAliasCDA)->CC6_CODUTI,(cAliasCDA)->CDA_CODLAN,nCDAValor, Iif(lIndivid,(cAliasCDA)->CDA_NUMERO  , "" ),cChaveNfe,Iif(lIndivid ,cChaveNF ,""),lIndivid,(cAliasCDA)->CDA_CODLAN})
					jCDAExtra[cChvCDAExtra] := Len(aCDAExtra)
				Else
					aCDAExtra[nPosCDAExtra][5] += nCDAValor
				EndIF

				cChvApuExtra := (cAliasCDA)->CC6_CODCRE
				
				IF !PesqjSon(jApuExtra,cChvApuExtra,@nPosApuExtra)
					AADD(aApurExtra,{(cAliasCDA)->CC6_CODCRE, '',0,0,0,0,0,{}})
					jApuExtra[cChvApuExtra] := Len(aApurExtra)
				EndIF 
				
			EndIF
			
		ElseIf Len(AllTrim((cAliasCDA)->CDA_CODLAN)) == 8
			//Verifica se no cadastro está para apurar individualmente as valores do código de lançamento
			lIndivid	:= .F.
			cCDAGNRE	:= ''
			
			lIndivid	:= lProcIndiv
			
			IF lCDAGNRE
				cCDAGNRE	:= (cAliasCDA)->CDA_GNRE
			EndIF

			If aSubAp[1] .And. !Empty((cAliasCDA)->CDO_SUBAP)
				If cNrLivro == '*' 
					If (cAliasCDA)->CDO_SUBAP == "1"
						lSkpSubAp := .T.
					EndIf
				Endif
				If ( cNrLivro <> '*' .And. cNrLivro <> cNfLivro ) .Or. (cNrLivro <> '*' .And. (cAliasCDA)->CDO_SUBAP = "3" )
					lSkpSubAp := .T.
				EndIf
			Else
				lSkpSubAp :=  !lOldLan .And. /*!Empty(cNrLivro) .And. */ !Empty(cApurSep) .And. cNfLivro$cApurSep .And. cNrLivro<>cNfLivro
			EndIf

			If "1"$(cAliasCDA)->CDO_TPAPUR
				lLancST := .T.
			Else
				lLancST := .F.
				If ! AllTrim((cAliasCDA)->CDO_TPAPUR) $ "0/2/3" .Or. lSkpSubAp
					(cAliasCDA)->(dbSkip())
					Loop
				EndIf
			EndIf

			cAj_REFLEX := (cAliasCDA)->CDO_UTILI
			If lLancST
				Do Case
					Case cAj_REFLEX == "0";cReflex := "002"
					Case cAj_REFLEX == "1";cReflex := "003"
					Case cAj_REFLEX == "2";cReflex := "007"
					Case cAj_REFLEX == "3";cReflex := "008"
					Case cAj_REFLEX == "4";cReflex := "014"
					Case cAj_REFLEX == "5";cReflex := "901"
				EndCase
			Else
				Do Case
					Case cAj_REFLEX == "0";cReflex := "002"
					Case cAj_REFLEX == "1";cReflex := "003"
					Case cAj_REFLEX == "2";cReflex := "006"
					Case cAj_REFLEX == "3";cReflex := "007"
					Case cAj_REFLEX == "4";cReflex := "012"
					Case cAj_REFLEX == "5";cReflex := "900"
				EndCase
			EndIf
		
			lLancDifal	:= "2"$(cAliasCDA)->CDO_TPAPUR
			
			If lLancDifal
				Do Case
					Case cAj_REFLEX == "0";cReflex := "002"
					Case cAj_REFLEX == "1";cReflex := "003"
					Case cAj_REFLEX == "2";cReflex := "006"
					Case cAj_REFLEX == "3";cReflex := "007"
					Case cAj_REFLEX == "4";cReflex := "009"
					Case cAj_REFLEX == "5";cReflex := "012"
				EndCase
			EndIF

			lLancFECP	:= "3"$(cAliasCDA)->CDO_TPAPUR
			
			If lLancFECP
				Do Case
					Case cAj_REFLEX == "0";cReflex := "014"
					Case cAj_REFLEX == "1";cReflex := "015"
					Case cAj_REFLEX == "2";cReflex := "018"
					Case cAj_REFLEX == "3";cReflex := "019"
					Case cAj_REFLEX == "4";cReflex := "021"
					Case cAj_REFLEX == "5";cReflex := "024"
				EndCase
			EndIF			
		
			lRet := .T. // Retorno T para desconsiderar o valor do SF3

				//Verifica se existem devoluções para debito especial
			If lProcIndiv .and. cReflex $ cAdDebEsp
				nDevDebEsp := DevLanc((cAliasCDA)->CDA_NUMERO,(cAliasCDA)->CDA_SERIE,(cAliasCDA)->CDA_NUMITE,(cAliasCDA)->CDA_CLIFOR,(cAliasCDA)->CDA_LOJA,StoD((cAliasCDA)->F3_ENTRADA),'E')

				//Como não é possivel ter certeza do calculo  realizado no reflexo então proporcionalizo valor pelos itens 
				IF nDevDebEsp > 0
					nOriItem := nCDAValor / (cAliasCDA)->FT_QUANT // Valor Item origem
					NdevItem := nOriItem * nDevDebEsp   // Valor Item Devolução					
					nCDAValor := MAX(nCDAValor - NdevItem,0)									
				Endif				
			EndIf

			nCDAValor	:= ((cAliasCDA)->CDA_VALOR + Iif(lCdaVlou, (cAliasCDA)->CDA_VLOUTR,0) )

			If nCDAValor > 0
				AADD(aLanc,{cChave+cItem,(cAliasCDA)->CDA_CALPRO,(cAliasCDA)->CDO_TPAPUR,cReflex,(cAliasCDA)->CDO_DESCR + SPACE( 47-len(Alltrim((cAliasCDA)->CDO_DESCR)) ),nCDAValor,(cAliasCDA)->CDA_CODLAN,lIndivid,cCDAGNRE,cChaveNF,Iif(lCdaVlou,(cAliasCDA)->CDA_REGCAL,"")})
			Endif

			IF lCDOTPMOV .AND. !EmptY((cAliasCDA)->CDO_TPMOV) .AND.  Iif( (cAliasCDA)->CDO_TPMOV == 'U',!Empty((cAliasCDA)->CDO_CODUTI) , .T. )   .AND. !Empty((cAliasCDA)->CDO_CODCRE)

				//Adiciona no array o valor gravado na CDA que irá refletir na aba extra apuração
				cChvCDAExtra := (cAliasCDA)->CDO_CODCRE+(cAliasCDA)->CDO_TPMOV+(cAliasCDA)->CDO_CODUTI+Iif(lIndivid, (cAliasCDA)->CDA_NUMERO+cChaveNF,"")
				
				IF !PesqjSon(jCDAExtra,cChvCDAExtra,@nPosCDAExtra)
					AADD(aCDAExtra,{(cAliasCDA)->CDO_CODCRE,(cAliasCDA)->CDO_TPMOV,(cAliasCDA)->CDO_CODUTI,(cAliasCDA)->CDA_CODLAN,nCDAValor,Iif(lIndivid ,(cAliasCDA)->CDA_NUMERO  , "" ) ,cChaveNfe,Iif(lIndivid  ,cChaveNF ,"" ),lIndivid,(cAliasCDA)->CDA_CODLAN})
					jCDAExtra[cChvCDAExtra] := Len(aCDAExtra)
				Else
					aCDAExtra[nPosCDAExtra][5] += nCDAValor
				EndIF

				cChvApuExtra := (cAliasCDA)->CDO_CODCRE
				
				IF !PesqjSon(jApuExtra,cChvApuExtra,@nPosApuExtra)
					AADD(aApurExtra,{(cAliasCDA)->CDO_CODCRE,'',0,0,0,0,0,{}})
					jApuExtra[cChvApuExtra] := Len(aApurExtra)
				EndIF 
				
			EndIF
							
		EndIf
		
		For nX := 1 to len(aLanc)
			
			lLancST := ("1"$aLanc[nX][3])
			lLancDifal	:= ("2"$aLanc[nX][3]) .and. Len(ALLTRIM(aLanc[nX][7])) == 8 // Tratamento para situações de codigos de lançamento de subapuração de ICMS
			lLancFECP   := ("3"$aLanc[nX][3]) .and. Len(ALLTRIM(aLanc[nX][7])) == 8 // que possuem CC6_TPAPUR 2 e 3
			
			If lLancDifal .Or. lLancFECP
				
				IF aLanc[nX][8]
					cChvCDADifal := aLanc[nX][7]+aLanc[nX][10]
				Else
					cChvCDADifal := aLanc[nX][7]+aLanc[nX][11]
				EndIF
				
				IF !PesqjSon(jCdaDifal,cChvCDADifal,@nPosCDADifal)
					If lProcRefer
						If lRefazApur //Verifica se a chamada dessa funcionalidade teve origem em "Refazer apuração"
							aDatas := DetDatas(mv_par01, mv_par02, mv_par04, mv_par05)
							
							cChvDIFAL	:=	xFilial('F0K')			+	;
											DTOS(aDatas[01])		+	;
											mv_par03				+	;
											SubStr(aLanc[nX][7],1,2)+	;
											AllTrim(aLanc[nX][7])	+	;
											Iif(Alltrim(aLanc[nX][11])="",'1-AUTOMATICO','3-CONFIG')+	;
											Space(TAMSX3('F0K_TPLANC')[01] - Iif(Alltrim(aLanc[nX][11])="",Len('1-AUTOMATICO'),Len('3-CONFIG'))) +	;
											SubStr(aLanc[nX][5],01,TAMSX3('F0K_DESCR')[01])
							
							PesqjSon(jDeldifal,cChvDIFAL,@nPosDlDIFA)
							jDeldifal[cChvDIFAL] := Len(aDIFALDel)

						EndIf
						If nPosDlDIFA > 0
							If Alltrim(aLanc[nX][11])=""
								AADD(aCDADifal,{aLanc[nX][4],aLanc[nX][5],aLanc[nX][6],aLanc[nX][7],"",SubStr(aLanc[nX][7],1,2),'1','          ',aLanc[nX][8],Iif(aLanc[nX][8] ,cChave ,'' ) ,cChaveNF,aLanc[nX][9],aDIFALDel[nPosDlDIFA][02],aDIFALDel[nPosDlDIFA][03],aDIFALDel[nPosDlDIFA][04],aDIFALDel[nPosDlDIFA][05],aLanc[nx][11]})
							Else
								AADD(aCDADifal,{aLanc[nX][4],aLanc[nX][5],aLanc[nX][6],aLanc[nX][7],"",SubStr(aLanc[nX][7],1,2),'3','          ',aLanc[nX][8],Iif(aLanc[nX][8] ,cChave ,'' ) ,cChaveNF,aLanc[nX][9],aDIFALDel[nPosDlDIFA][02],aDIFALDel[nPosDlDIFA][03],aDIFALDel[nPosDlDIFA][04],aDIFALDel[nPosDlDIFA][05],aLanc[nx][11]})
								//Configurador de tributos -> a Posicão 11 do array aLanc traz a informação da CDA_REGCAL, caso seja diferente de branco, vai mudar o tipo de lançamento para 3 para poder identificar que é do configurador na apuração
							Endif
						Else
							If Alltrim(aLanc[nX][11])=""
								AADD(aCDADifal,{aLanc[nX][4],aLanc[nX][5],aLanc[nX][6],aLanc[nX][7],"",SubStr(aLanc[nX][7],1,2),'1','          ',aLanc[nX][8],Iif(aLanc[nX][8] ,cChave ,'' ) ,cChaveNF,aLanc[nX][9],Space(TamSx3("CCF_NUMERO")[1]),Space(TamSx3("CCF_TIPO")[1]),Space(TamSx3("CCF_INDAUT")[1]),Space(TamSx3("CCF_IDITEM")[1]),aLanc[nx][11]})
							Else
								AADD(aCDADifal,{aLanc[nX][4],aLanc[nX][5],aLanc[nX][6],aLanc[nX][7],"",SubStr(aLanc[nX][7],1,2),'3','          ',aLanc[nX][8],Iif(aLanc[nX][8] ,cChave ,'' ) ,cChaveNF,aLanc[nX][9],Space(TamSx3("CCF_NUMERO")[1]),Space(TamSx3("CCF_TIPO")[1]),Space(TamSx3("CCF_INDAUT")[1]),Space(TamSx3("CCF_IDITEM")[1]),aLanc[nx][11]})
								//Configurador de tributos -> a Posicão 11 do array aLanc traz a informação da CDA_REGCAL, caso seja diferente de branco, vai mudar o tipo de lançamento para 3 para poder identificar que é do configurador na apuração
							Endif
							jDeldifal[cChvDIFAL] := Len(aCDADifal)
						EndIf	
					Else
						AADD(aCDADifal,{aLanc[nX][4],aLanc[nX][5],aLanc[nX][6],aLanc[nX][7],"",SubStr(aLanc[nX][7],1,2),'3','          ',aLanc[nX][8],Iif(aLanc[nX][8] ,cChave ,'' ) ,cChaveNF,aLanc[nX][9],Space(TamSx3("CCF_NUMERO")[1]),Space(TamSx3("CCF_TIPO")[1]),Space(TamSx3("CCF_INDAUT")[1]),Space(TamSx3("CCF_IDITEM")[1]),aLanc[nx][11]}) //Adicionado posicao 8 de aCDAIC para flag de ajuste manual					
					EndIf
					
					jCdaDifal[cChvCDADifal] := 	Len(aCDADifal)
				
				Else
					aCDADifal[nPosCDADifal][3] += aLanc[nX][6]
				EndIF
			
			ElseIf aLanc[nX][4] $ cAdlinha // Austes (Adiciona Linha)

				If lLancST

					IF aLanc[nX][8]
						cChvCDAST := aLanc[nX][7]+cChave						
					Else
						cChvCDAST := aLanc[nX][7]+aLanc[nx][11]
					EndIF

					IF !PesqjSon(jCDAST,cChvCDAST,@nPosCDAST)
						AADD(aCDAST,{aLanc[nX][4],PadR("", 10),aLanc[nX][5],aLanc[nX][6],aLanc[nX][9],"",aLanc[nX][7],cChaveNF,.F.,aLanc[nX][8],Iif(aLanc[nX][8],cChave ,"" ),aLanc[nX][11]})
						jCDAST[cChvCDAST] := Len(aCDAST)
					Else
						aCDAST[nPosCDAST][4] += aLanc[nX][6]
					EndIF
					
				Else
					//Individualizado sempre irá adicionar nova linha no aCDAIC
					IF aLanc[nX][8]						
						//Individualizado
						cChvCDAIC := aLanc[nX][7]+cChave
					Else
						//Agrupado
						cChvCDAIC := aLanc[nX][7]+aLanc[nx][11]
					EndIF

					If !PesqjSon(jCDAIC,cChvCDAIC,@nPosCDAIC)
						AADD(aCDAIC,{aLanc[nX][4],PadR("", 10),aLanc[nX][5],aLanc[nX][6], Iif(aLanc[nX][8],aLanc[nX][9],""),"",aLanc[nX][7],cChaveNF,.F.,aLanc[nX][8],Iif(aLanc[nX][8],cChave,""),aLanc[nX][11]}) //Adicionado posicao 8 de aCDAIC para flag de ajuste manual
						jCDAIC[cChvCDAIC] := Len(aCDAIC)
					Else
						aCDAIC[nPosCDAIC][4] += aLanc[nX][6]
					EndIf					
									
				EndIf
			ElseIf aLanc[nX][4] $ cAdDebEsp // Austes (Adiciona Linha)

				IF aLanc[nX][8]						
					cChvCDADE := aLanc[nX][7]+cChave
				Else
					cChvCDADE := aLanc[nX][7]+aLanc[nx][11]
				EndIF

				If !PesqjSon(jCDADE,cChvCDADE,@nPosCDADe)
					AADD(aCDADE,{aLanc[nX][4],PadR("", 10),aLanc[nX][5],aLanc[nX][6],Iif(aLanc[nX][8],aLanc[nX][9],""),"",aLanc[nX][7],.F.,aLanc[nX][8],Iif(aLanc[nX][8],cChave,""),cChaveNF,aLanc[nX][11]})
					jCDADE[cChvCDADE] := Len(aCDADE)
				Else
					aCDADE[nPosCDADe][4] += aLanc[nX][6]
				EndIF				

				aDbEsp	:=	{aLanc[nX][7],aLanc[nX][6]}
			Else // Austes acumula valor
				If lProcRefer
					AADD(aApurCDA,{aLanc[nX][4],"","",aLanc[nX][6],"","",aLanc[nX][7],aLanc[nX][3],'','','',''})
				Else
					AADD(aApurCDA,{aLanc[nX][4],"","",aLanc[nX][6],"","",aLanc[nX][7],aLanc[nX][3]})
				EndIf
			EndIf
		Next

		(cAliasCDA)->(DbSkip())
		aSize(aLanc,0)
		nPosCDADIFAL	:= 0
		nPosCDAIC		:= 0
		nPosCDAST		:= 0
		nPosCDADE		:= 0
		nPosCDAExtra	:= 0
		nPosApuExtra	:= 0
		cReflex 		:= ""

	EndDo

	If Select(cAliasCDA)<>0
		(cAliasCDA)->(DbCloseArea())
	EndIf
Next

FreeObj(jCDAExtra)
FreeObj(jApuExtra)
FreeObj(jCDAIC)
FreeObj(jCDAST)
FreeObj(jCDADE)
FreeObj(jCdaDifal)
FreeObj(jDeldifal)


Return 


/*/{Protheus.doc} xGetSelCDA
	Função que retorna a select da query para a apuração da CDA
	@type  Static Function
	@author Erich Buttner
	@since 04/03/2024
	@version 12.1.2210, 12.1.2310
	@param 
	@return cQry - Query para apuração da CDA
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function xGetSelCDA(lEntrada, lIndividual, aParam)

	Local cQry := ""
	Local cTpMovCDA := ""
	Local cTpMovSFT := ""

	If lEntrada
		cTpMovCDA := "AND CDA.CDA_TPMOVI = 'E' "
		cTpMovSFT := "AND SFT.FT_TIPOMOV = 'E' "
	Else
		cTpMovCDA := "AND CDA.CDA_TPMOVI = 'S' "
		cTpMovSFT := "AND SFT.FT_TIPOMOV = 'S' "
	EndIf

	If lIndividual

        cQry := " SELECT CDA.CDA_CODLAN, CDA.CDA_VALOR, CDA.CDA_BASE , CDA.CDA_NUMERO , CDA.CDA_SERIE, CDA.CDA_NUMITE , CDA.CDA_CLIFOR, CDA.CDA_LOJA, SF3.F3_ENTRADA, SFT.FT_QUANT, CDA.CDA_FORMUL, CDA.CDA_TPMOVI, CDA.CDA_ESPECI, SFT.FT_CHVNFE, "
		
		If aApurSX3[FP_CDA_VLOUTR]
			cQry+= " CDA.CDA_VLOUTR, "
		EndIf
		
	Else // Agrupado
		
		cQry := " SELECT CDA.CDA_CODLAN, SUM(CDA.CDA_VALOR) CDA_VALOR, SUM(CDA.CDA_BASE) CDA_BASE, " 
		
		If aApurSX3[FP_CDA_VLOUTR]
			cQry+= " SUM(CDA.CDA_VLOUTR) CDA_VLOUTR, "
		EndIf		

	Endif
	cQry += " CC6.CC6_SUBAP, CC6.CC6_REFLEX, CC6.CC6_TPAPUR, CC6.CC6_DESCR, CC6.CC6_TPMOV, CC6.CC6_CODUTI, CC6.CC6_CODCRE , CC6.CC6_AGRUPA, "
	cQry += " CDO.CDO_CODAJU, CDO.CDO_SUBAP, CDO.CDO_TPAPUR, CDO.CDO_UTILI, CDO.CDO_DESCR , CDO.CDO_TPMOV, CDO.CDO_CODUTI, CDO.CDO_CODCRE, "
	cQry += " CDO.CDO_AGRUPA, CDA.CDA_GNRE, CDA.CDA_CALPRO, SF3.F3_NRLIVRO "
	
	If aApurSX3[FP_CDA_REGCAL]
		cQry += " , (CASE WHEN CDA.CDA_REGCAL > ' ' THEN 'CONFIG' ELSE '' END) CDA_REGCAL "
	EndIf

	cQry += " FROM ? SF3 " 
	aAdd( aParam , {'U', RetSqlName("SF3")})
	
	cQry += " INNER JOIN ? SFT ON SFT.FT_FILIAL = ? AND SFT.FT_CLIEFOR = SF3.F3_CLIEFOR AND SFT.FT_LOJA = SF3.F3_LOJA AND "
	cQry += " SFT.FT_SERIE = SF3.F3_SERIE AND SFT.FT_NFISCAL = SF3.F3_NFISCAL AND SFT.FT_IDENTF3 = SF3.F3_IDENTFT AND SFT.D_E_L_E_T_ = ' ' "	
	cQry += cTpMovSFT	
	aAdd( aParam , {'U', RetSqlName("SFT")})
	aAdd( aParam , {'C', xFilial('SFT')})

	cQry += " INNER JOIN ? CDA ON CDA.CDA_FILIAL= ? AND SFT.FT_CLIEFOR = CDA.CDA_CLIFOR AND SFT.FT_LOJA = CDA.CDA_LOJA AND CDA.CDA_TPMOVI = SFT.FT_TIPOMOV AND CDA.CDA_ESPECI = SFT.FT_ESPECIE AND "
	cQry += " SFT.FT_SERIE = CDA.CDA_SERIE AND SFT.FT_NFISCAL = CDA.CDA_NUMERO AND SFT.FT_ITEM = CDA.CDA_NUMITE AND CDA.D_E_L_E_T_ =' ' "
	cQry += cTpMovCDA
	aAdd( aParam , {'U', RetSqlName("CDA")})
	aAdd( aParam , {'C', xFilial('CDA')})

	cQry += " LEFT OUTER JOIN ? CC6 ON CC6.CC6_FILIAL= ? AND CDA.CDA_CODLAN=CC6.CC6_CODLAN AND CC6.D_E_L_E_T_ = ' ' "
	aAdd( aParam , {'U', RetSqlName("CC6")})
	aAdd( aParam , {'C', xFilial('CC6')})

	cQry += " LEFT OUTER JOIN ? CDO ON CDO.CDO_FILIAL= ? AND CDA.CDA_CODLAN=CDO.CDO_CODAJU AND CDO.D_E_L_E_T_ = ' '  "
	aAdd( aParam , {'U', RetSqlName("CDO")})
	aAdd( aParam , {'C', xFilial('CDO')})
	
Return cQry


/*/{Protheus.doc} xGetGroup
	Função que retorna o group by da query para a apuração da CDA
	@type  Static Function
	@author Erich Buttner
	@since 04/03/2024
	@version 12.1.2210, 12.1.2310
	@param 
	@return cQry - Query para apuração da CDA
	/*/
Static Function xGetGroup()

Local cQry := ""

cQry += " GROUP BY "
cQry += " CDA.CDA_CODLAN, CC6.CC6_SUBAP, CC6.CC6_REFLEX, CC6.CC6_TPAPUR, CC6.CC6_DESCR , CC6.CC6_TPMOV, CC6.CC6_CODUTI,  "
cQry += " CC6.CC6_CODCRE, CC6.CC6_AGRUPA, CDO.CDO_CODAJU, CDO.CDO_SUBAP, CDO.CDO_TPAPUR, CDO.CDO_UTILI, CDO.CDO_DESCR, CDO.CDO_TPMOV, "
cQry += " CDO.CDO_CODUTI, CDO.CDO_CODCRE, CDO.CDO_AGRUPA, CDA.CDA_GNRE, CDA_CALPRO, SF3.F3_NRLIVRO "

If aApurSX3[FP_CDA_REGCAL]
	cQry += ", CDA.CDA_REGCAL "
EndIf

Return cQry

/*/{Protheus.doc} PesqJson
	Retorna valor da chave corresponte
	@type  Static Function
	@author Erich Buttner
	@since 04/03/2024
	@version version
	@param json, json, objeto json a ser pesquisado
	@param cChave, character, chave a ser pesquisada
	@param xValor, variable, Retorna valor encontrado na chave json
	@return XRet, numeric, Retorna verdadeico caso encontre a chave		
/*/
Static Function PesqjSon(oJson, cChave, xValor)
Local lRet	 := .F.
Local xRet	 := Nil
	
	xRet := oJson[cChave]
	IF xRet <> Nil //oJson:hasProperty(cChave)
		xValor := xRet
		lRet := .T.
	Endif
Return lRet


Static Function ConsultCDA(dDtIni, dDtFim, nDiasAcreDt, cDtCanc, lF3Cnae, lF3CODRSEF, cMvCODRSEF, cNrLivro,lEntrada, cMV_ESTADO,lConjugada, lIndividual, aParam)

	Local  cQry	:= ""	

	//select para notas fiscais de entrada
	cQry += xGetSelCDA(lEntrada, lIndividual, @aParam)

	//where para otas fiscais de entrada
	cQry += xGetWhere(dDtIni, dDtFim, nDiasAcreDt, cDtCanc, lF3Cnae, lF3CODRSEF, cMvCODRSEF, cNrLivro,lEntrada, cMV_ESTADO,lConjugada, , @aParam)

	cQry += " AND (CDA.CDA_ORIGEM <> '3' AND CDA.CDA_ORIGEM <> '6')  "

	If cNrLivro != '*' 
		cQry += " AND SFT.FT_NRLIVRO = ? "
		aAdd(aParam, {'C', cNrLivro})
	EndIf

	cQry += " AND (CC6.CC6_CODLAN = CDA.CDA_CODLAN OR CDO.CDO_CODAJU = CDA.CDA_CODLAN)"

	If !lIndividual
		cQry += " AND (CC6.CC6_AGRUPA <> '2' OR CDO.CDO_AGRUPA <> '2')" 
		cQry += xGetGroup()		
	Else
		cQry += " AND (CC6.CC6_AGRUPA = '2' OR CDO.CDO_AGRUPA = '2')" 
	Endif

Return cQry

/*/{Protheus.doc} lShowScreenAuto
	Função que decide se deve exibir a tela de parâmetros automáticos
	com base nos campos informados e nas flags de validação.

	@type  Static Function
	@author Edinei.pereira
	@since 24/02/2025
	@version version 1.0
	@param aCposAut, array, Array com os campos de filtragem automática.
	@param lWhenGet, lógico, Flag que indica se deve validar os campos ao serem digitados.
	@param lNgnreNf, lógico, Flag que indica se é GNRE de NFe, obrigando a exibição da tela.
	@return variavel, Retorna o array de campos (aCposAut) ou Nil, se a tela não deve ser exibida.
/*/
Static Function lShowScreenAuto(aCposAut, lWhenGet, lNgnreNf)
    // Se o array de campos está vazio, não há parâmetros para exibir.
    If Empty(aCposAut)
        Return Nil
    EndIf

    // Se estiver no modo de validação via digitação e não for GNRE de NFe, não exibe a tela.
    If lWhenGet .And. !lNgnreNf
        Return Nil
    EndIf

Return aCposAut
