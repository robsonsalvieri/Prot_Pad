#INCLUDE "tlpp-core.th"
#INCLUDE "MATXDEF.CH"

namespace totvs.protheus.backoffice.fiscal.tciclass
using namespace totvs.protheus.backoffice.fiscal.additionalData

Static oPrepared    as Object


/*/{Protheus.doc} TCIProcessing
    Classe responsável por processar a e retornar dados do Configurador de tributos no em tempo de execução na MatxFis.
    @author Rhuan Carvalho
    @since 29/02/2024
    @version 12.1.2410
    /*/
Class TCIProcessing 

    Private Data nItem                            as numeric
    Private Data cRequestResponse                 as character
    Private Data cSpecifcResponse                 as character
    Private Data cDateReferenceTaxesToWithholding as character
    Private Data cAgregTypes                      as character
    Private Data aData                            as array
    Private Data aNItem                           as array
    Private Data aAgregTypes                      as array
    Private Data jRequestResponse                 as json
    Private Data jContentHeaderData               as json
    Private Data jContentSpreadsheetData          as json
    Private Data jContentTaxesSujectTowithholding as json
    Private Data jContentTaxesSujectToPayment     as json
    Private Data jRequestError                    as json
    Private Data jTaxAdjustments                  as json
    Private Data jRequestAgregResponse            as json   
    Private Data lContentDataItems                as logical
    Private Data lBaseRules                       as logical
    Private Data lTaxRateRules                    as logical
    Private Data lBookDetail                      as logical
    Private Data lBookKeeping                     as logical
    Private Data lRequestError                    as logical

    Public Method new(Value) CONSTRUCTOR // Método construtor da classe TCIProcessing
    Public Method setItems(Value)                   as array
    Public Method setDataItems()                    as array     // Método para inserir "regras_base", "regras_aliquota", "detalhe_livro", "regras_escrituracao" no processamento de dados_itens
    Public Method getAllData()                      as character // método para obter todos os dados contidos na operação realizada
    Public Method getDataItems()                    as character // Método para obter dados de dados_itens
    Public Method getHeaderData()                   as character // Método para obter dados de dados_cabecalho
    Public Method getSpreadsheetData()              as character // Método para obter dados de planilha_financeira
    Public Method getTaxesSubjectToWithholding()    as character // Método para obter dados da propriedade tributos_passiveis_retencao
    Public Method getTaxesSubjectToPayment()        as character // Método para obter dados da propriedade tributos_passiveis_recolhimento
    Public Method setDateTaxesToWithholding(cValue) as character // Método para obter a data de referencia para compor impostos retidos    
    Public Method getTaxAdjustments()               as character // Método para obter os códigos de ajustes e valores declaratórios
    Public Method getAgregTypeByTax()               as character // Método para buscar o tipo de incidencia no total da nf (regra_escrituração)
    Public Method getAdditionalData()               as character // Método para buscar os dados adicionais do configurador de tributos
    Public Method destroy() //método para limpar os dados da classe
    
    Private Method processItemData() // Método para realizar o processamento de dados_itens
    Private Method hasRequestError()                    as logical // Retorna se há erros de requisição

    Private Method getJsonData()                        as Json // Retorna o a requisição em formato Json 
    Private Method getItemNumbers()                     as array // Retorna array contendo o número dos itens
    Private Method getContentError()                    as character // Retorna mensagem de erro de conteúdo da propriedade
    PRivate Method getDateRegerenceTaxesToWithholding() as character // Retorna a data de referencia para impostos passivies de rentencao

    Private Method dataItems()                          as character // Método para compor os dados de dados_itens
    Private Method setBaseRules()                       as character // Método para compor os dados de regras_base
    Private Method setTaxRateRules()                    as character // Método para compor os dados de regras_aliquota
    Private Method setBookDetail()                      as character // Método para compor os dados de detalhe_livro
    Private Method setBookKeeping()                     as character // Método para compor os dados de regras_escrituracao
    Private Method setHeaderData()                      as Json // Método para compor os dados de dados_cabecalho
    Private Method setSpreadsheetData()                 as json // Método para compor os dados de planilha_financeira
    Private Method setTaxesSujectToWithHolding()        as character // Método para compor os dados de tributos_passiveis_retencao
    Private Method setTaxesSubjectToPayment()           as character // Método para compor os dados de tributos_passiveis_recolhimento
    Private Method setRequestError() // Compõe mensagem de erro para requisições
    Private Method setTaxAdjustments()                  as character // Método para compor os dados de ajustes de tributos
    Private Method validAgregParams()                   as character // Método para validar parametros do getAgregTypeByTax() 
    Private Method searchAgregInJSON()                               // Método para procurar no objeto a incidencia/id totvs passados por parametro no getAgregTypeByTax()
    Private Method addAgregTypeJSON()                                // Método para adicionar no objeto de resposta do getAgregTypeByTax() o item encontrado    
    Private Method setAgregTypes()                                   // Método para deixar em cache quais as opções válidas de incidencia no total da nf (CJ2_STONF)
    Private Method searchIncidences()                   as character // Método para buscar se existe uma incidencia de total de nf válida no JSON 
    Private Method hasBook(jData)                       as logical   // Método que verifica se existe dados de escrituracao para determinado tributo 
    Private Method hasTaxToSearch( lHasTaxToSearch, cIdTotvsToSearch, cIdTotvs ) as logical   // Método que verifica se existe busca por Id TOtvs e se o Id totvs é válido
    Private Method hasIncidenceToSearch( lHasAgregTypeToSearch, cAgregTypesToSearch , cTypeAgreg ) as logical   // Método que verifica se existe busca por Incidencia e se a Incidencia é válida

EndClass

/*/{Protheus.doc} new
    
    Método construtor da classe TCIProcessing

    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return Objeto da classe TCIProcessing    
    /*/
Method new(aValue) CLASS TCIProcessing
    self:cRequestResponse                 := ''
    self:cSpecifcResponse                 := ''
    self:cDateReferenceTaxesToWithholding := ''
    self:cAgregTypes                      := ''
    Self:aData                            := {}
    self:aNitem                           := {}
    self:aAgregTypes                      := {}  
    self:jRequestResponse                 := JsonObject():New()
    self:jContentHeaderData               := JsonObject():New()
    self:jContentSpreadsheetData          := JsonObject():New()
    self:jContentTaxesSujectTowithholding := JsonObject():New()
    self:jContentTaxesSujectToPayment     := JsonObject():New() 
    self:jRequestError                    := JsonObject():New()
    self:jTaxAdjustments                  := JsonObject():New()
    self:jRequestAgregResponse            := JsonObject():New()  
    self:lContentDataItems                := .F.
    self:lBaseRules                       := .F.
    self:lTaxRateRules                    := .F.
    self:lBookDetail                      := .F.
    self:lBookKeeping                     := .F.
    self:lRequestError                    := .T. 

    IF ValType(aValue) == 'A'
        self:setItems(aValue)
    EndIf

return

/*/{Protheus.doc} setItems
    
    Método para receber dado array contendo o número do item da operação

    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return Objeto da classe TCIProcessing    
    /*/
Method setItems(aValue as array) as array CLASS TCIProcessing
    Self:aData        := aValue
Return self

/*/{Protheus.doc} setRequestError
    
    Método compor json com mensagem de erro de requisição

    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return Objeto da classe TCIProcessing    
/*/
Method setRequestError() Class TCIProcessing
	self:lRequestError := .F.
return self

/*/{Protheus.doc} getContentError
    
    Retorna mensagem de erro de conteúdo da propriendade

    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return Objeto da classe TCIProcessing    
/*/
Method getContentError() as character Class TCIProcessing
    local cMessage := "erro - Valor da propriedade incorreto"
return cMessage

/*/{Protheus.doc} getAllData
    
    Método para retornar o um dado carácter conténdo os dados processados
    do configurador de tributos
    
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return cRequestResponse, character, conteúdo em formato json   
    /*/

Method getAllData() as character Class TCIProcessing
	self:processItemData()
	self:setHeaderData()
	self:setSpreadsheetData()    
	If self:hasRequestError()
		self:jRequestResponse['tributos_passiveis_retencao'] := "erro - Necessário declarar data em setDateTaxesToWithholding"
	Else
		self:setTaxesSujectToWithHolding()
	EndIf
	self:setTaxesSubjectToPayment()
    self:setTaxAdjustments()
	self:cRequestResponse := self:jRequestResponse:ToJson()
return self:cRequestResponse

/*/{Protheus.doc} setDataItems
    
    Método para identificar requisição da propriedade dados_itens    
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
    /*/

Method setDataItems(aContent) as array Class TCIProcessing
    Local nX := 0 as numeric

    If Valtype(aContent) == 'A'
        For nX                 := 1 To len(aContent)
            Do case
                Case aContent[nX] == "regras_base"
                    self:lBaseRules        := .T.
                Case aContent[nX] == "regras_aliquota"
                    self:lTaxRateRules     := .T.
                Case aContent[nX] == "detalhe_livro"
                    self:lBookDetail       := .T.
                Case aContent[nX] == "regras_escrituracao"
                    self:lBookKeeping      := .T.
            EndCase
        Next nX
        self:lContentDataItems := .T.
    Else
        self:jRequestResponse["dados_itens"] := self:getContentError()
    EndIf
return self

/*/{Protheus.doc} setDateTaxesToWithholding
    
    Método público para receber a data de referencia para ser utilizada em tributos_passiveis_retencao    
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method setDateTaxesToWithholding(cValue as character) as character Class TCIProcessing
    If !cValue == nil
        self:cDateReferenceTaxesToWithholding := cValue
        self:setRequestError()
    EndIf
return
/*/{Protheus.doc} getItemNumbers
    
    Método para retornar a propriedade conténdo o número do item    
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method getItemNumbers() as array Class TCIProcessing
return self:aData
/*/{Protheus.doc} getDateRegerenceTaxesToWithholding
    
    Método para retornar a data de referencia para impostos retidos    
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method getDateRegerenceTaxesToWithholding() as character Class TCIProcessing
return self:cDateReferenceTaxesToWithholding 
/*/{Protheus.doc} hasRequestError
    
    Método para retornar se há erros de requisição
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method hasRequestError() as logical Class TCIProcessing
return self:lRequestError
/*/{Protheus.doc} DataItems
    
    Método Público para retornar dado carácter em formato Json apenas de dados_itens   
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method getDataItems() as character Class TCIProcessing
    Local jEspecific as Json
    
    self:processItemData()
    jEspecific := JsonObject():New()
    jEspecific['dados_itens'] := self:jRequestResponse["dados_itens"]
    self:cSpecifcResponse := jEspecific:toJson()
    FreeObj(jEspecific)

return self:cSpecifcResponse

/*/{Protheus.doc} HeaderData
    
    Método Público para retornar dado carácter em formato Json apenas de dados_cabecalho   
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method getHeaderData() as character Class TCIProcessing
    self:setHeaderData()
    self:jContentHeaderData['dados_cabecalho'] := self:jRequestResponse:GetJsonObject('dados_cabecalho')
	self:cSpecifcResponse := self:jContentHeaderData:toJson()
return self:cSpecifcResponse
/*/{Protheus.doc} SpreadsheetData
    
    Método Público para retornar dado carácter em formato Json apenas de planilha_financeira   
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method getSpreadsheetData() as character Class TCIProcessing
    self:setSpreadsheetData()
    self:jContentSpreadsheetData['planilha_financeira'] := self:jRequestResponse:GetJsonObject('planilha_financeira')
	self:cSpecifcResponse := self:jContentSpreadsheetData:toJson()
return self:cSpecifcResponse
/*/{Protheus.doc} getTaxesSubjectToWithholding
    
    Método Público para retornar dado carácter em formato Json apenas de tributos_passiveis_retencao   
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method getTaxesSubjectToWithholding() as character Class TCIProcessing
	If self:hasRequestError()
		self:jContentTaxesSujectTowithholding['tributos_passiveis_retencao'] := "erro - Necessário declarar data em setDateTaxesToWithholding"
	Else
		self:setTaxesSujectTowithholding()
		self:jContentTaxesSujectTowithholding['tributos_passiveis_retencao'] := self:jRequestResponse:GetJsonObject('tributos_passiveis_retencao')
	EndIf
	self:cSpecifcResponse := self:jContentTaxesSujectTowithholding:ToJson()
return self:cSpecifcResponse
/*/{Protheus.doc} getTaxesSubjectToPayment
    
    Método Público para retornar dado carácter em formato Json apenas de tributos_passiveis_recolhiemento   
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method getTaxesSubjectToPayment() as character Class TCIProcessing
    self:setTaxesSubjectToPayment()
    self:jContentTaxesSujectToPayment['tributos_passiveis_recolhimento'] := self:jRequestResponse:GetJsonObject('tributos_passiveis_recolhimento')
	self:cSpecifcResponse := self:jContentTaxesSujectToPayment:toJson()
return self:cSpecifcResponse


/*/{Protheus.doc} getTaxAdjustments
    
    Método Público para retornar dado carácter em formato Json apenas de ajustes de tributos   
    
    @author Rafael Oliveira
    @since 08/10/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method getTaxAdjustments() as character Class TCIProcessing
    self:setTaxAdjustments()
    self:jTaxAdjustments['ajustes_tributos'] := self:jRequestResponse:GetJsonObject('ajustes_tributos')
    self:cSpecifcResponse := self:jTaxAdjustments:toJson()
return self:cSpecifcResponse

/*/{Protheus.doc} getAgregTypeByTax
    
    Método para buscar o tipo de incidencia no total da nf (regra_escrituração)   

    Param @aAgregTypesToSeach (Opcional) : array com seguintes opções: 
    1=Sem Ação
    2=Subtrai somente do total da nota
    3=Subtrai do total da nota e da duplicata
    4=Subtrai somente do total da duplicata
    5=Soma somente no total da nota
    6=Soma no total da nota e da duplicata
    7=Soma somente no total da duplicata
    8=Gross up no total da duplicata
    
    Param @aTaxesToSearch (Opcional) : array com quais tributos (Id TOTVS) se deve buscar ...

    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2510
    @return atributo classe TCIProcessing
/*/
Method getAgregTypeByTax( cAgregTypesToSearch as character , cIdTotvsToSearch as character ) as character Class TCIProcessing
    Local jTaxesData  as json
    Local cErrorMsg as character 
    Local jTemp as json
    Default cAgregTypesToSearch := ''
    Default cIdTotvsToSearch := ''

    If !Empty( cAgregTypesToSearch ) // Validacao caso tenha sido informado um tipo de incidencia, verifica se esse tipo é válido ...
        
        If Empty( self:aAgregTypes )
            self:setAgregTypes() 
        EndIf
        
        cErrorMsg := self:validAgregParams( cAgregTypesToSearch )
        
        if( !empty(cErrorMsg) )
            self:jRequestError['erro'] := "erro - " + cErrorMsg
            return self:jRequestError:toJson()
        endif

    Endif
    
    If self:jRequestResponse:hasProperty('dados_itens') .and. !Empty( self:jRequestResponse["dados_itens"]:GetNames() ) // Valida se existe os dados necessarios para realizar a busca ...
        jTaxesData := self:jRequestResponse["dados_itens"]       
    Else // Força o GetDataItems() para ter os dados necessarios ...
        jTemp := JsonObject():New()
        
        jTemp:FromJson( self:GetDataItems() )

        If !jTemp:hasProperty('dados_itens') .or. ( jTemp:hasProperty('dados_itens') .and. Empty( self:jRequestResponse["dados_itens"]:GetNames() ) )
            cErrorMsg := "Não encontrado dados de nenhum tributo (atributo 'dados_itens' não encontrado ou vazio)"
            self:jRequestError['erro'] := "erro - " + cErrorMsg
            FWFreeObj(jTemp)
            return self:jRequestError:toJson()
        else
            jTaxesData := jTemp['dados_itens']
        EndIf

    EndIf

    self:searchAgregInJSON(jTaxesData , cAgregTypesToSearch , cIdTotvsToSearch ) 

    If !self:jRequestAgregResponse:hasProperty("data") 
        self:jRequestError['erro'] := "erro - Nenhum registro encontrado com base nos parâmetros informados na getAgregTypeByTax()"
        return self:jRequestError:toJson()
    Endif

return self:jRequestAgregResponse:toJson()

/*/{Protheus.doc} validAgregParams
    
    Método para validar parametro(s) da getAgregTypeByTax()
    
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method validAgregParams( cAgregTypeToSearch as character ) as character Class TCIProcessing
    Local cRet as character
    Local cToSearch as character

    cToSearch := (cAgregTypeToSearch + "=")

    If Ascan( self:aAgregTypes ,{|x| cToSearch $ x }) == 0
        cRet := "Necessário informar um tipo de 'incidencia no total da nf' válido como parâmetro no método getAgregTypeByTax(). " + self:cAgregTypes    
    endif 

return cRet

/*/{Protheus.doc} SearchAgregInJSON
    
    Método para procurar no objeto a incidencia/id totvs passados por parametro no getAgregTypeByTax()
    
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method searchAgregInJSON( jTaxesData as json, cAgregTypesToSearch as character , cIdTotvsToSearch as character ) Class TCIProcessing
    Local nX as numeric    
    Local nZ as numeric
    Local aTaxesInReg := {} as array
    Local aItensInDoc := {} as array
    Local cIdTotvs as character    
    Local cTypeAgreg as character
    Local jItem as json
    Local jTax as json
    Local lHasAgregTypeToSearch as logical
    Local lHasTaxToSearch as logical

    lHasAgregTypeToSearch := !Empty( cAgregTypesToSearch )    
    lHasTaxToSearch       := !Empty( cIdTotvsToSearch )
    aItensInDoc := jTaxesData:GetNames()
        
    For nZ := 1 to len(aItensInDoc)

        jItem := jTaxesData:GetJsonObject(aItensInDoc[nZ])
        aTaxesInReg := jItem:GetNames() 
        
        For nX := 1 to len(aTaxesInReg)

            If aTaxesInReg[nX] == "Aviso" // Informado um ITEM que não é calculado pelo configurador de tributos ...
                Loop
            EndIf

            jTax := jItem:GetJsonObject(aTaxesInReg[nX])
            cIdTotvs := jTax:GetJsonText('ident_trib')
            
            If self:hasBook( jTax ) .and. self:hasTaxToSearch( lHasTaxToSearch , cIdTotvsToSearch , cIdTotvs )

                cTypeAgreg := self:searchIncidences( jTax:GetJsonObject('regras_escrituracao') )

                If self:hasIncidenceToSearch( lHasAgregTypeToSearch , cAgregTypesToSearch , cTypeAgreg )
                    self:addAgregTypeJSON( cIdTotvs , aItensInDoc[nZ] , cTypeAgreg , aTaxesInReg[nX] ) 
                endif
                
            Endif

        Next nX
    Next nZ

    aSize(aItensInDoc, 0)
    aItensInDoc  := nil
    aSize(aTaxesInReg, 0)
    aTaxesInReg  := nil

Return

/*/{Protheus.doc} haveBook
    Método para determinar se tributo possui regra de escrituracao 
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method hasBook( jTaxData as json ) as logical Class TCIProcessing
Return jTaxData:hasProperty('regras_escrituracao')

/*/{Protheus.doc} hasTaxToSearch
    Método para determinar se tributo possui busca por IdTotvs, e se o Id Totvs é o procurado 
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method hasTaxToSearch( lHasTaxToSearch as logical , cIdTotvsToSearch as character , cIdTotvs as character ) as logical Class TCIProcessing
Return ( !lHasTaxToSearch .or. ( lHasTaxToSearch .and. cIdTotvsToSearch  == cIdTotvs ) )

/*/{Protheus.doc} hasIncidenceToSearch
    Método para determinar se tributo possui busca por Incidencia, e se a Incidencia é a procurada
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method hasIncidenceToSearch( lHasAgregTypeToSearch as logical , cAgregTypesToSearch as character , cTypeAgreg as character ) as logical Class TCIProcessing
Return ( (!lHasAgregTypeToSearch) .or. ( lHasAgregTypeToSearch .and. cAgregTypesToSearch == cTypeAgreg ) )

/*/{Protheus.doc} searchIncidences
    
    Método para buscar/retornar a incidencia no total da NF em determinado JSON

    @jTaxData : json - Contem os dados da regra de escrituracao de determinado tributo ...
    
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method searchIncidences( jTaxData as json ) as character Class TCIProcessing
    Local cType as character 
    
    If jTaxData:hasProperty('acao_tot_nf')
        cType := jTaxData:GetJsonText('acao_tot_nf')
    endif

Return cType

/*/{Protheus.doc} addAgregTypeJSON
    
    Método para alimentar objeto de resposta do getAgregTypeByTax()
    
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method addAgregTypeJSON( cIdTotvs as character , cNumItem as character , cTypeAgreg as character , cTax as character  ) Class TCIProcessing
Local cAtrib := 'data' as character

    If !self:jRequestAgregResponse:hasProperty(cAtrib)                        
        self:jRequestAgregResponse[ cAtrib ] := JsonObject():New()
    EndIf

    If ! self:jRequestAgregResponse[ cAtrib ]:hasProperty(cNumItem)                        
        self:jRequestAgregResponse[ cAtrib ][ cNumItem ] := JsonObject():New()        
    EndIf

    self:jRequestAgregResponse[ cAtrib ][ cNumItem ][ cTax ] := JsonObject():New()
    self:jRequestAgregResponse[ cAtrib ][ cNumItem ][ cTax ][ 'acao_tot_nf' ] := cTypeAgreg
    self:jRequestAgregResponse[ cAtrib ][ cNumItem ][ cTax ][ 'id_totvs' ] := cIdTotvs
Return

/*/{Protheus.doc} setAgregTypes
    
    Método para setar quais os tipos válidos de "incidencia no total da NF" (CJ2_STONF)
    
    @author Douglas Dourado
    @since 25/02/2025
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method setAgregTypes() Class TCIProcessing    

    self:cAgregTypes := x160JTotDp() // Armazenado para utilizar em possivel mensagem de erro caso tipo seja inválido ...
    self:aAgregTypes := StrTokArr(self:cAgregTypes , ";")        

Return

/*/{Protheus.doc} processItemData
    
    Método para processar requisição dados_itens baseado na requisição Itens   
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method processItemData() Class TCIProcessing
    Local nItens   := 1                     as numeric
    Local nX       := 0                     as numeric
    Local jItemTax := JsonObject():New()    as json
    Local aNItem   := self:getItemNumbers() as array

    If Len(aNitem) > 0
        For nX := 1 to len(aNItem)
            nItens := aNItem[nX]
            If Valtype(nItens) == "N"
                jItemTax[cValToChar(nItens)]         := JsonObject():New()
                jItemTax[cValToChar(nItens)]:FromJson(self:dataItems(nItens))
                self:jRequestResponse["dados_itens"]:= jItemTax
            Else
                self:jRequestResponse["Itens"]       := self:getContentError()
                self:jRequestResponse["dados_itens"] := self:getContentError()
                Exit
            EndIf
        Next nX
        
    Else
        While MafisFound("IT", nItens)
            jItemTax[cValToChar(nItens)] := JsonObject():New()
            jItemTax[cValToChar(nItens)]:FromJson(self:dataItems(nItens))
            nItens += 1
        EndDo
        self:jRequestResponse["dados_itens"]:= jItemTax
    EndIf

    FreeObj(jItemTax)
    jItemTax := nil

return self

/*/{Protheus.doc} setHeaderData
    
    Método para preencher as propriedades de dados_cabecalho   
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return atributo classe TCIProcessing
/*/
Method setHeaderData() as Json Class TCIProcessing
    Local aNfTribGen := MafisRet(, 'NF_TRIBGEN' ) as array
    Local nX         := 0
    Local jRefNfTrib                              as Json
    Local jTax       := JsonObject():New()        as Json
    
    For nX                      := 1 to Len(aNfTribGen)
        
        jRefNfTrib                  := JsonObject():New()
        jRefNfTrib["cod_regra"]     := AllTrim(aNfTribGen[nX][TG_NF_SIGLA]) //01
        jRefNfTrib["base_trib"]     := aNfTribGen[nX][TG_NF_BASE] //02
        jRefNfTrib["val_trib"]      := aNfTribGen[nX][TG_NF_VALOR] //03
        jRefNfTrib["regr_financ"]   := AllTrim(aNfTribGen[nX][TG_NF_REGRA_FIN]) //04
        jRefNfTrib["id_cadastro"]   := AllTrim(aNfTribGen[nX][TG_NF_ID_REGRA]) //05
        jRefNfTrib["cod_urf"]       := AllTrim(aNfTribGen[nX][TG_NF_ALQ_CODURF]) //06
        jRefNfTrib["perc_urf"]      := aNfTribGen[nX][TG_NF_ALQ_PERURF] //07
        jRefNfTrib["val_dep"]       := aNfTribGen[nX][TG_NF_DED_DEP] //08
        jRefNfTrib["cod_regr_guia"] := AllTrim(aNfTribGen[nX][TG_NF_REGRA_GUIA]) //09
        jRefNfTrib["val_majorado"]  := aNfTribGen[nX][TG_NF_VAL_MAJ] //10
        jRefNfTrib["id_trib"]       := AllTrim(aNfTribGen[nX][TG_NF_IDTRIB]) //11

        jTax[AllTrim(aNfTribGen[nX][TG_NF_SIGLA])]:=jRefNfTrib
    Next nX

    self:jRequestResponse[ 'dados_cabecalho' ] := jTax
    
    aSize(aNfTribGen, 0)
    FreeObj(jRefNfTrib)
    jRefNfTrib := nil
    FreeObj(jTax)
    jTax := Nil

return self

/*/{Protheus.doc} dataItems
    
    Método para preencher as propriedades de dados_itens 
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return jItemData, Json
/*/
Method dataItems(numberItens) as character Class TCIProcessing
    Local aItTribGen                                          as array
    Local aRefTribGen := MafisRet(numberItens, 'IT_TRIBGEN' ) as array
    Local nPosRef     := Len(aRefTribGen)                     as numeric
    Local nX          := 0                                    as numeric
    Local jGenericRef                                         as json
    Local jTax        := JsonObject():New()                   as json
    Local cTax                                                as character

    If nPosRef > 0
        For nX := 1 to nPosRef
            aItTribGen := MafisRet(numberItens, "IT_TRIBGEN", {aRefTribGen[Nx][1]})

            jGenericRef                          := JsonObject():New()
            jGenericRef["cod_regra"]             := Alltrim(aItTribGen[TG_IT_SIGLA]) //1
            jGenericRef["desc_regra"]            := Alltrim(aItTribGen[TG_IT_DESCRICAO]) //2
            jGenericRef["base_trib" ]            := aItTribGen[TG_IT_BASE] //3
            jGenericRef["aliq_trib"]             := aItTribGen[TG_IT_ALIQUOTA] //4
            jGenericRef["val_trib"]              := aItTribGen[TG_IT_VALOR] //5
            jGenericRef["regr_financ"]           := Alltrim(aItTribGen[TG_IT_REGRA_FIN]) //8 
            jGenericRef["id_cadastro"]           := Alltrim(aItTribGen[TG_IT_ID_REGRA]) //9
            jGenericRef["config_arred"]          := aItTribGen[TG_IT_RND] //10
            jGenericRef["ident_trib"]            := Alltrim(aItTribGen[TG_IT_IDTRIB]) //12
            jGenericRef["desc_trib"]             := Alltrim(aItTribGen[TG_IT_DESC_IDTRIB]) //41
            jGenericRef["formula_npi"]           := Alltrim(aItTribGen[TG_IT_FOR_NPI]) //13
            jGenericRef["formula_calculo"]       := Alltrim(aItTribGen[TG_IT_FORMULA_VAL]) //42
            jGenericRef["id_npi"]                := Alltrim(aItTribGen[TG_IT_ID_NPI]) //14
            jGenericRef["cod_cabec_npi"]         := Alltrim(aItTribGen[TG_IT_COD_FOR]) //15
            jGenericRef["margem_mva"]            := aItTribGen[TG_IT_MVA] //16
            jGenericRef["mva"]                   := Empty(aItTribGen[TG_IT_MVA])
            jGenericRef["mva_aux"]               := aItTribGen[TG_IT_AUX_MVA] //17
            jGenericRef["val_pauta"]             := aItTribGen[TG_IT_PAUTA] //18
            jGenericRef["pauta"]                 := Empty(aItTribGen[TG_IT_PAUTA])
            jGenericRef["perc_majora"]           := aItTribGen[TG_IT_MAJ] //19
            jGenericRef["majorado"]              := Empty(aItTribGen[TG_IT_MAJ])
            jGenericRef["ind_aux_majora"]        := aItTribGen[TG_IT_AUX_MAJ] //20
            jGenericRef["cod_trib_majora"]       := Alltrim(aItTribGen[TG_IT_TRB_MAJ]) //21
            jGenericRef["ded_dependentes"]       := aItTribGen[TG_IT_DED_DEP] //22
            jGenericRef["cod_regr_tab_progre"]   := Alltrim(aItTribGen[TG_IT_TAB_PROG]) //23
            jGenericRef["cod_regr_ded_depen"]    := Alltrim(aItTribGen[TG_IT_REGRA_DED_DEP]) //24
            jGenericRef["aliq_servico"]          := aItTribGen[TG_IT_ALQ_SERV] //25
            jGenericRef["aliq_servico_lei_comp"] := aItTribGen[TG_IT_ALQ_SERV_LEI_COMPL] //26
            jGenericRef["formula_calc_isento"]   := Alltrim(aItTribGen[TG_IT_FOR_ISE_NPI]) //30
            jGenericRef["formula_calc_outros"]   := Alltrim(aItTribGen[TG_IT_FOR_OUT_NPI]) //31
            jGenericRef["cod_regra_guia"]        := Alltrim(aItTribGen[TG_IT_REGRA_GUIA]) //32
            jGenericRef["val_zero"]              := aItTribGen[TG_IT_VL_ZERO ] //33
            jGenericRef["val_maximo"]            := aItTribGen[TG_IT_VL_MAX] //34
            jGenericRef["val_minimo"]            := aItTribGen[TG_IT_VL_MIN] //35
            jGenericRef["operador_maximo"]       := Alltrim(aItTribGen[TG_IT_OPR_MAX]) //36
            jGenericRef["operador_minimo"]       := Alltrim(aItTribGen[TG_IT_OPR_MIN]) //37
            //jGenericRef["ultima_aquisição"]      := aItTribGen[TG_IT_ULT_AQUI] //38 verficar depois
            //jGenericRef["estrut_ult_aquisicao"]  := aItTribGen[TG_IT_ESTR_ULT_AQUI] //39 verificar depois
            if fisExtCmp('12.1.2410', .T.,'F2B','F2B_STATUS')
                jGenericRef["status"]       := Alltrim(aItTribGen[TG_IT_STATUS])
            else
                jGenericRef["status"] := ""
            endif

            If self:lBaseRules
                jGenericRef["regras_base"] := JsonObject():New()
                jGenericRef["regras_base"]:FromJson(self:setBaseRules(aItTribGen[TG_IT_REGRA_BAS])) //6
            EndIF
            If self:lTaxRateRules
                jGenericRef["regras_aliquota"] := JsonObject():New()
                jGenericRef["regras_aliquota"]:FromJson(self:setTaxRateRules(aItTribGen[TG_IT_REGRA_ALQ])) //7
            EndIf
            If self:lBookDetail
                jGenericRef["detalhe_livro"] := JsonObject():New()
                jGenericRef["detalhe_livro"]:FromJson(self:setBookDetail(aItTribGen[TG_IT_LF])) //27
            EndIf
            If self:lBookKeeping
                jGenericRef["regras_escrituracao"] := JsonObject():New()
                jGenericRef["regras_escrituracao"]:FromJson(self:setBookKeeping(aItTribGen[TG_IT_REGRA_ESCR])) //28
            EndIf
            
            jTax[Alltrim(aItTribGen[TG_IT_SIGLA])]:= jGenericRef           
        Next nX
        aSize(aItTribGen, 0)
        aSize(aRefTribGen, 0)
    Else
        jTax["Aviso"] := "Não há tributos calculados pelo configurador de tributos"
    EndIf

    cTax := jTax:toJson()

    FreeObj(jGenericRef)
    jGenericRef := nil
    FreeObj(jTax)
    jTax := nil
    


return cTax

/*/{Protheus.doc} setSpreadsheetData
    
    Método para preencher as propriedades de planilha_financeira 
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return
/*/
Method setSpreadsheetData() as json Class TCIProcessing
    Local aSpreadSheat := MaFisRodaPe(1,Nil,,,Nil,.T.,,,,,,,,,,,,,,,.T.) as array
    Local jRefSSData                                                     as Json
    Local nX           := 0                                              as numeric
    Local jTax         := JsonObject():New()                             as Json
    
    For nX := 1 to len(aSpreadSheat)
        If AllTrim(aSpreadSheat[nX][IMP_NOME]) == "TG"

            jRefSSData              := JsonObject():New()
            jRefSSData["codigo"]    := AllTrim(aSpreadSheat[nX][IMP_COD]) //01
            jRefSSData["descricao"] := AllTrim(aSpreadSheat[nX][IMP_DESC]) //02
            jRefSSData["base"]      := aSpreadSheat[nX][IMP_BASE] //03
            jRefSSData["aliquota"]  := aSpreadSheat[nX][IMP_ALIQ] //04
            jRefSSData["valor"]     := aSpreadSheat[nX][IMP_VAL] //05
            jRefSSData["nome"]      := AllTrim(aSpreadSheat[nX][IMP_NOME]) //06
        
            jTax[AllTrim(aSpreadSheat[nX][IMP_COD])] := jRefSSData
            
        EndIf 
    Next nX 

    self:jRequestResponse['planilha_financeira'] := jTax

    aSize(aSpreadSheat, 0)
    FreeObj(jRefSSData)
    jRefSSData := nil
    FreeObj(jTax)
    jTax := nil

return

/*/{Protheus.doc} setBaseRules
    
    Método para preencher as propriedades de regras_base 
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return cRefBase, character, dados tipo caracter com estrutura Json
/*/
Method setBaseRules(aReference as array) as character Class TCIProcessing
    Local jRefBase as Json
    Local cRefBase as character

    jRefBase                    := JsonObject():New()
    jRefBase["cod_regr_base"]   := Alltrim(aReference[TG_BAS_COD]) //01
    jRefBase["origem_valor"]    := Alltrim(aReference[TG_BAS_VLORI]) //02
    jRefBase["acao_desconto"]   := Alltrim(aReference[TG_BAS_DESCON]) //03
    jRefBase["acao_frete"]      := Alltrim(aReference[TG_BAS_FRETE]) //04
    jRefBase["acao_seguro"]     := Alltrim(aReference[TG_BAS_SEGURO]) //05
    jRefBase["acao_despesa"]    := Alltrim(aReference[TG_BAS_DESP]) //06
    jRefBase["acao_icms_deson"] := Alltrim(aReference[TG_BAS_ICMSDES]) //07
    jRefBase["acao_icms_ret"]   := Alltrim(aReference[TG_BAS_ICMSST]) //08
    jRefBase["perc_reducao"]    := aReference[TG_BAS_REDUCAO] //09
    jRefBase["tipo_reducao"]    := Alltrim(aReference[TG_BAS_TPRED]) //010
    jRefBase["um_base"]         := Alltrim(aReference[TG_BAS_UM]) //11
    jRefBase["id_cadastro"]     := Alltrim(aReference[TG_BAS_ID]) //12
    jRefBase["formula_npi"]     := Alltrim(aReference[TG_BAS_FOR_NPI]) //13
    jRefBase["id_formula"]      := Alltrim(aReference[TG_BAS_ID_NPI]) //14
    jRefBase["cod_formula"]     := Alltrim(aReference[TG_BAS_COD_FOR]) //15
    jRefBase["formula_base"]    := Alltrim(aReference[TG_BAS_FORMULA]) //16
    
    aSize(aReference, 0)
    cRefBase := jRefBase:toJson()
    FreeObj(jRefBase)


return cRefBase

/*/{Protheus.doc} setTaxRateRules
    
    Método para preencher as propriedades de regras_alíquota 
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return cRefTxRat, character, dados tipo caracter com estrutura Json
/*/
Method setTaxRateRules(aReference as array) as character Class TCIProcessing
    Local jRefTxRat as Json
    Local cRefTxRat as character

    jRefTxRat                      := JsonObject():New()
    jRefTxRat["cod_regr_aliquota"] := Alltrim(aReference[TG_ALQ_COD]) //01
    jRefTxRat["origem_aliquota"]   := Alltrim(aReference[TG_ALQ_VLORI]) //02
    jRefTxRat["tipo_aliquota"]     := Alltrim(aReference[TG_ALQ_TPALIQ]) //03
    jRefTxRat["aliquota"]          := aReference[TG_ALQ_ALIQ] //04
    jRefTxRat["cod_urf"]           := Alltrim(aReference[TG_ALQ_CODURF]) //05
    jRefTxRat["perc_urf"]          := aReference[TG_ALQ_PERURF] //06
    jRefTxRat["valor_urf"]         := aReference[TG_ALQ_VALURF] //07
    jRefTxRat["id_cadastro"]       := Alltrim(aReference[TG_ALQ_ID]) //08
    jRefTxRat["id_cadastro"]       := Alltrim(aReference[TG_ALQ_FOR_NPI]) //09
    jRefTxRat["id_aliquota"]       := Alltrim(aReference[TG_ALQ_ID_NPI]) //10
    jRefTxRat["cod_formula"]       := Alltrim(aReference[TG_ALQ_COD_FOR]) //11
    jRefTxRat["formula_aliquota"]  := Alltrim(aReference[TG_ALQ_FORMULA]) //12
    jRefTxRat["perc_red_aliquota"] := aReference[TG_ALQ_REDUCAO] //13

    aSize(aReference, 0)
    cRefTxRat := jRefTxRat:toJson()
    FreeObj(jRefTxRat)

return cRefTxRat

/*/{Protheus.doc} setBookDetail
    
    Método para preencher as propriedades de detalhe_livro 
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return return cBookDt, character, dados tipo caracter com estrutura Json
/*/
Method setBookDetail(aReference as array) as character Class TCIProcessing
    Local jBookDt as Json
    Local cBookDt as character

    jBookDt                      := JsonObject():New()
    jBookDt["cst"]               := Alltrim(aReference[TG_LF_CST]) //01
    jBookDt["valor_tributado"]   := aReference[TG_LF_VALTRIB] //02
    jBookDt["valor_isento"]      := aReference[TG_LF_ISENTO] //03
    jBookDt["valor_outros"]      := aReference[TG_LF_OUTROS] //04
    jBookDt["valor_nao_tribut"]  := aReference[TG_LF_NAO_TRIBUTADO] //05
    jBookDt["valor_diferido"]    := aReference[TG_LF_DIFERIDO] //06
    jBookDt["valor_majorado"]    := aReference[TG_LF_MAJORADO] //07
    jBookDt["perc_majorado"]     := aReference[TG_LF_PERC_MAJORACAO] //08
    jBookDt["perc_diferido"]     := aReference[TG_LF_PERC_DIFERIDO] //09
    jBookDt["perc_reducao"]      := aReference[TG_LF_PERC_REDUCAO] //10
    jBookDt["valor_pauta"]       := aReference[TG_LF_PAUTA] //11
    jBookDt["mva"]               := aReference[TG_LF_MVA] //12
    jBookDt["ind_aux_mva"]       := aReference[TG_LF_AUX_MVA] //13
    jBookDt["ind_aux_majora"]    := aReference[TG_LF_AUX_MAJORACAO] //14
    jBookDt["cod_tab_cst"]       := Alltrim(aReference[TG_LF_CSTCAB]) //15
    jBookDt["val_base_original"] := aReference[TG_LF_BASE_ORI] //16
    jBookDt["perc_red_aliquota"] := aReference[TG_LF_ALQ_REDALI] //18
    jBookDt["perc_aliquota_original"] := aReference[TG_LF_ALQ_ORI] //19
    jBookDt["cct"]               := aReference[TG_LF_CCT] //20
    jBookDt["cclasstrib"]        := ""

    if !empty(jBookDt["cct"])
        jBookDt["cclasstrib"]    := Alltrim(aReference[TG_LF_CST]) + Alltrim(aReference[TG_LF_CCT])
    endIf

    aSize(aReference, 0)
    cBookDt := jBookDt:ToJson()
    FreeObj(jBookDt)

return cBookDt

Method setTaxesSujectToWithHolding() as character Class TCIProcessing
	Local aTGCalcRet := {}                 as array
    Local dData                            as date
    Local nX         := 0                  as numeric
    Local jContent                         as Json
    Local jTaxContent      := JsonObject():New() as Json
    Local cTaxesSTH                        as character

    dData := Stod(self:getDateRegerenceTaxesToWithholding())
    FisRetGen({},{},.t.,@aTGCalcRet,{}, dData)
    If Len(aTGCalcRet) > 0
        For nX := 1 to Len(aTGCalcRet)
            jContent                                := JsonObject():New()
            jContent[ 'sigla_tributo' ]             := Alltrim(aTGCalcRet[nX][1])
            jContent[ 'base_tributo' ]              := aTGCalcRet[nX][2]
            jContent[ 'valor_tributo' ]             := aTGCalcRet[nX][3]
            jContent[ 'codigo_regra' ]              := alltrim(aTGCalcRet[nX][4])
            jContent[ 'retem_integr_prim_parcela' ] := aTGCalcRet[nX][5]
            jContent[ 'saldo_valor_tributo' ]       := aTGCalcRet[nX][6]
            jContent[ 'codigo_base_tributos' ]      := aTGCalcRet[nX][7]
            jContent[ 'id_regra' ]                  := aTGCalcRet[nX][8]
            jContent[ 'codigo_urf' ]                := alltrim(aTGCalcRet[nX][9])
            jContent[ 'percentual_urf' ]            := aTGCalcRet[nX][10]
            jTaxContent[Alltrim(aTGCalcRet[nX][1])]           := jContent
        Next nX
        self:jRequestResponse['tributos_passiveis_retencao'] := jTaxContent
        cTaxesSTH := self:jRequestResponse:toJson()
    Else
        self:jRequestResponse['tributos_passiveis_retencao'] := "Aviso - Não foram identificados tributos"
    EndIf
    FreeObj(jContent)
    FreeObj(jTaxContent)
    aSize(aTGCalcRet, 0)

Return cTaxesSTH

Method setTaxesSubjectToPayment() as character Class TCIProcessing
    Local aTGCalcRec := {} as array
    Local nX := 0 as numeric
    Local jContent as json
    Local jTaxContent := JsonObject():New()
    Local cTaxSubPay as character

    FisRetGen({},{},.t.,{},@aTGCalcRec, '')

    If Len(aTGCalcRec) > 0
        For nX := 1 To Len(aTGCalcRec)
            
            jContent := JsonObject():New()
            jContent['codigo_regra'] := Alltrim(aTGCalcRec[nX][1])
            jContent['valor_tributo'] := aTGCalcRec[nX][2]
            jCOntent['numero_titulo'] := Alltrim(aTGCalcRec[nX][3])
            jContent['id_regra_fiscal'] := aTGCalcRec[nX][5]
            jContent['histórico_titulo'] := Alltrim(aTGCalcRec[nX][6])
            jContent['sigla_tributo'] := Alltrim(aTGCalcRec[nX][7])

            jTaxContent[Alltrim(aTGCalcRec[nX][7])] := jCOntent
        Next nX
		self:jRequestResponse['tributos_passiveis_recolhimento'] := jTaxContent
    	cTaxSubPay := self:jRequestResponse:ToJson()
	Else
		self:jRequestResponse['tributos_passiveis_recolhimento'] := "Aviso - Não foram identificados tributos"
    EndIf


    FreeObj(jCOntent)
    FreeObj(jTaxContent)
    aSize(aTGCalcRec, 0)
        
Return cTaxSubPay

/*/{Protheus.doc} setBookKeeping
    
    Método para preencher as propriedades de regras_escrituração 
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return cBooKKep, character, dados tipo caracter com estrutura Json 
/*/
Method setBookKeeping(aReference as array) as character Class TCIProcessing
    Local jBookKep as json
    Local cBooKKep as character
    
    jBookKep := JsonObject():New()
    jBookKep["id_cadastro"]      := Alltrim(aReference[RE_ID]) //01
    jBookKep["incidencia"]       := Alltrim(aReference[RE_INCIDE]) //02
    jBookKep["acao_tot_nf"]      := Alltrim(aReference[RE_TOTNF]) //03
    jBookKep["perc_diferimento"] := aReference[RE_PERCDIF] //04
    jBookKep["cst"]              := Alltrim(aReference[RE_CST]) //05
    jBookKep["cod_tab_cst"]      := Alltrim(aReference[RE_CSTCAB]) //06
    jBookKep["inc_parc_redu"]    := Alltrim(aReference[RE_INC_PARC_RED]) //07
    jBookKep["cct"]              := Alltrim(aReference[RE_CCT]) //08
    jBookKep["cclasstrib"]       := ""

    if !empty(jBookKep["cct"])
        jBookKep["cclasstrib"] := Alltrim(aReference[RE_CST]) + Alltrim(aReference[RE_CCT])
    endIf
    
    aSize(aReference, 0)
    cBooKKep := jBookKep:ToJson()
    FreeObj(jBookKep)

return cBooKKep


/*/{Protheus.doc} setTaxAdjustments
    Pega os valores de códigos de ajustes e valores declaratórios.
    @author anedino.santos
    @since 27/09/2024
    @version 12.1.2510    
    @return self:jRequestResponse["ajustes_tributos"] := jRet
/*/
Method setTaxAdjustments() class TCIProcessing
    local aAjustes       := {}  as array // lista de ajustes
    local aDeclaratorios := {}  as array // lista de valores declaratórios
    Local aItens         := {}  as array // lista de itens
    local aLanc                 as array // lista com os dados dos lançamentos
    local jDetLanc              as json // json com os detalhes do lançamento
    local jRet                  as json // objeto json principal para retorno
    local jRetAux               as json // obejto json para conter as chaves ajustes e declaratórios    
    Local lContinue      := .T. as logical // indica se deve continuar o processamento
    Local lValidItens    := .F. as logical // indica se valida os itens passados
    local nI                    as numeric // contador
    Local nItem          := 1   as numeric // item inicial    
    local nLen                  as numeric // tamanho do array de lancamentos
    Local nProcessType   := 2   as numeric // tipo de processamento
    
    aItens := self:getItemNumbers()

    If Len(aItens) > 0
        nItem := aItens[1]
        If ValType(nItem) == "N"
            lValidItens := Len(aItens) > 1

            If !lValidItens // se foi passado apenas um item, processa apenas ele
                nProcessType := 1
            EndIf
        Else
            self:jRequestResponse["ajustes_tributos"] := self:getContentError()
            lContinue := .F.
        EndIf    
    EndIf

    If lContinue
        aLanc := MaFisAjIt(nItem, nProcessType)

        jRet := JsonObject():New()

        if (nLen := len(aLanc)) > 0
            for nI := 1 to nLen
                
                If aLanc[nI][8] == "CONFIG" // Se for um lançamento de ajuste ou declaratório do configurador
                    
                    //Valida se o item retornado pertence ao item que está sendo solicitado
                    If  !lValidItens .or. (aScan(aItens, Val(aLanc[nI][1])) > 0)
                        jDetLanc                   := JsonObject():New()
                        jDetLanc["item"]           := aLanc[nI][1]
                        jDetLanc["sequencia"]      := aLanc[nI][7]
                        jDetLanc["codigo"]         := aLanc[nI][2]
                        jDetLanc["base_calculo"]   := aLanc[nI][4]
                        jDetLanc["aliquota"]       := aLanc[nI][5]
                        jDetLanc["valor"]          := aLanc[nI][6]
                        jDetLanc["sistema"]        := aLanc[nI][3]
                        jDetLanc["outros_valores"] := aLanc[nI][21]
                        jDetLanc["observacao"]     := AllTrim(aLanc[nI][17])
                        jDetLanc["cod_regra"]      := AllTrim(aLanc[nI][22])

                        if aLanc[nI][14] == "4"
                            aadd(aDeclaratorios, jDetLanc)
                        else
                            aadd(aAjustes, jDetLanc)
                        endif
                    Endif
                EndIf
            next nI

            if len(aAjustes) > 0 .Or. len(aDeclaratorios) > 0
                jRetAux := JsonObject():New()

                jRetAux["ajustes"] := aAjustes

                jRetAux["declaratorios"] := aDeclaratorios

                jRet["lancamentos"] := jRetAux
            else
                jRet["Aviso"] := "Não houve lançamentos."
            endif

            self:jRequestResponse["ajustes_tributos"] := jRet
        else
            jRet["Aviso"] := "Não houve lançamentos."

            self:jRequestResponse["ajustes_tributos"] := jRet
        endif

        FwFreeArray(aLanc)
    EndIf

Return 

/*/{Protheus.doc} getAdditionalData()
    Método para retornar os dados adicionais do configurador de tributos
    @author Rhuan Carvalho
    @since 23/05/2025
    @version 12.1.2510

    /*/
Method getAdditionalData() class TCIProcessing
    Local oAddData := TCAdditionalData():New()
    Local cReturn as character
    
    oAddData:setDataMode("Processing")
    
    cReturn := oAddData:getAdditionalData()

    oAddData:destroy()
    
Return cReturn

/*/{Protheus.doc} clear
    
    Método para limpar os dados da classe TCIProcessing
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410

/*/

Method destroy() Class TCIProcessing

    aSize(self:aNitem, 0)
    self:aNItem := nil
    
    aSize(self:aData, 0)
    self:aData  := nil
    
    aSize(self:aAgregTypes, 0)
    self:aAgregTypes  := nil

    FreeObj(self:jRequestError)
    self:jRequestError := nil

    FreeObj(self:jRequestResponse)
    self:jRequestResponse := nil

    FreeObj(self:jContentHeaderData)
    self:jContentHeaderData := nil

    FreeObj(self:jContentSpreadsheetData)
    self:jContentSpreadsheetData := nil

    FreeObj(self:jContentTaxesSujectTowithholding)
    self:jContentTaxesSujectTowithholding := nil

    FreeObj(self:jContentTaxesSujectToPayment)
    self:jContentTaxesSujectToPayment := nil

    FreeObj(self:jRequestAgregResponse)
    self:jRequestAgregResponse := nil

Return
/*/{Protheus.doc} TCIWritten
    
    Classe responsável por processar a e retornar os dados gravados nas tabelas
	do Configurador de tributos , a partir de requisições com tipo de dado caráctere estururado
    como Json

    @author Rhuan Carvalho
    @since 27/03/2024
    @version 12.1.2410
    /*/
Class TCIWritten
	Private Data aIdRequest                    as array
	Private Data aSearchList                   as array
	Private Data jRequestResponse              as json
    Private Data jCache                        as json
    Private Data jCacheSX3                     as json
	Private Data cMessage                      as character
	Private Data cResponse                     as character
    Private Data lBaseRules                    as logical
    Private Data lTaxRateRules                 as logical
    Private Data lBookKeeping                  as logical
	Private Data lError                        as logical
    Private Data lRegra                        as logical
    Private Data aRegra                        as array
    Private Data aErrorItens                   as array
    Private Data cGetDataTypeReturn            as character
    Private Data aIdTotvsFilterList            as array
    Private Data aTaxRuleFilterList            as array
    Private Data aAdditionalFieldsToReturn     as array
    Private Data jResponseResume               as json
    Private Data jRequestAgregResponse         as json   
    Private Data cAgregTypes                   as character
    Private Data aAgregTypes                   as array

	Public Method new(value) CONSTRUCTOR
	Public Method setId(aData)                  as array // Método público para passar os Ids que serão pesquisados
    Public Method setDataItems()                as array // Método para inserir "regras_base", "regras_aliquota", "regras_escrituracao" 
	Public Method getDataId()                   as character // Método público que processa e retorna um dado carácter em estrutura Json
	Public Method destroy() //Método para limpar os dados da classe
    Public Method setReturnByTaxRule()          as character // Método que insere o tipo que retorno que será utilizado no getDataId() será por TaxRule
    Public Method setReturnByIdTotvs()          as character // Método que insere o tipo que retorno que será utilizado no getDataId() será por IdTotvs
    Public Method setIdTotvsFilterList()        as array // Método que insere os tributos (por Id Totvs) que se deseja no retorno do método getDataId()
    Public Method setTaxRuleFilterList()        as array // Método que insere os tributos (por Código de Regra de Cálculo(F2B_REGRA) ) que se deseja no retorno do método getDataId()
    Public Method setAdditionalFieldsToReturn() as array // Método que insere dados de atributos adicionais que deseja receber nos retornos por TaxRule e TotvsId
    Public Method getAgregTypeByTax()           as character // Método para buscar o tipo de incidencia no total da nf (regra_escrituração)
    Public Method getAdditionalData()           as character // Método para buscar os dados adicionais do configurador de tributos

    Private Method setBaseRules()              as json // Método para compor os dados de regras_base
    Private Method setTaxRateRules()           as json // Método para compor os dados de regras_aliquota
    Private Method setBookKeeping()            as json // Método para compor os dados de regras_escrituracao
	Private Method validadeId()                as array     // Método para avaliar se o ID recebido é válido
	Private Method processResponseSearchList() as json      // Método que realiza o processamento da lista de pesquisa, retornando um Json
	Private Method setMessageError()           as character // Método para inserir notificação de erro
	Private Method setError()                  as logical   // Método para definir se há erro
	Private Method setIdData()                              // Método que realiza as queries
    Private Method setCache()                  as json      // Insere registros  em um Json cache
	Private Method getMessageError()           as character // Método para retornar mensagem de erro
	Private Method hasRequestError()           as logical   // Método para retornar se há erro de requisicao
    Private Method hasInCache()                as Json      // Método para verificar se o ID já foi pesquisado anteriormente
    Private Method validRulesJson()            as Json      // Método que valida se o ID atende a regra, caso positivo compoe Json
    Private Method checkRules()                as array     // Método que verifica se o ID que está no cache,contém as regras. Caso não tenha, adiciona para processamento.
    Private Method updateCache()               as array     // Método que verifica e atualiza se o ID a ser pesquisado não está no cache.
    Private Method validSearch()               as logical   // Método que verifica se o ID pesquisado contem erro.
    Private Method setItensError()             as json      // Método que verifica se o Itens pesquisado contem erro.
    Private Method setRulesMsg()               as json      // Método que retorna mensagem quando a regra nao está vinculada 
    Private Method ReturnByTaxRule()           as Json      // Método para retornar o atributo "dados_por_tributo" no JSON de resposta
    Private Method ReturnByIdTotvs()           as Json      // Método para retornar o atributo "dados_por_idtotvs" no JSON de resposta
    Private Method CreateJSONByTaxRule()                      // Método para adicionar os dados no JSON de resposta no atributo "dados_por_idtotvs"
    Private Method CreateJsonbyIdTotvs()                    // Método para adicionar os dados no JSON de resposta no atributo "dados_por_tributos"
    Private Method validAgregParams()          as character // Método para validar parametros do getAgregTypeByTax() 
    Private Method searchAgregInJSON()                      // Método para procurar no objeto a incidencia/id totvs passados por parametro no getAgregTypeByTax()
    Private Method addAgregTypeJSON()                       // Método para adicionar no objeto de resposta do getAgregTypeByTax() o item encontrado    
    Private Method setAgregTypes()                                   // Método para deixar em cache quais as opções válidas de incidencia no total da nf (CJ2_STONF)
    Private Method searchIncidences()                   as character // Método para buscar se existe uma incidencia de total de nf válida no JSON 
    Private Method hasBook(jData)                      as logical   // Método que verifica se existe dados de escrituracao para determinado tributo 
    Private Method hasTaxToSearch( lHasTaxToSearch, cIdTotvsToSearch, cIdTotvs ) as logical   // Método que verifica se existe busca por Id TOtvs e se o Id totvs é válido
    Private Method hasIncidenceToSearch( lHasAgregTypeToSearch, cAgregTypesToSearch , cTypeAgreg ) as logical   // Método que verifica se existe busca por Incidencia e se a Incidencia é válida
    Private Method setErrorOnAgreg( cErrorMsg ) as character // Método que seta todas as variaveis de erro necessarias e retorna o json com a mensagem
    Private Method validateSX3Exists() as json // Método que valida se os campos existem na base
                      

EndClass
/*/{Protheus.doc} new
    
    Método construtor da classe TCIWritten

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
    /*/
Method new(value) Class TCIWritten
	self:aIdRequest       := {}
	self:aSearchList      := {}
	self:jRequestResponse := JsonObject():New()
    self:jCache           := JsonObject():New()
    self:jResponseResume  := JsonObject():New()
    self:jRequestAgregResponse := JsonObject():New()
	self:cMessage         := ""
	self:cResponse        := ""
    self:cAgregTypes      := ""
	self:lError           := .F.
    self:lBaseRules       := .F.
	self:lTaxRateRules    := .F.
	self:lBookKeeping     := .F.
    self:lRegra           := .F.
    self:aRegra           := {}
    self:aErrorItens      := {}    
    self:cGetDataTypeReturn   := ""
    self:aIdTotvsFilterList   := {}
    self:aTaxRuleFilterList   := {}
    self:aAdditionalFieldsToReturn := {}
    self:aAgregTypes               := {}
return self
/*/{Protheus.doc} setId
    
    Método público para receber array contendo ids que serão processados

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method setId(aData as Array) as array Class TCIWritten
	If Valtype(aData) == 'A'
		If !Empty(aData)
			self:aIdRequest   := aData
            aSize(self:aSearchList,0)  
			self:validadeId()
		Else
			self:setMessageError("erro - Necessita informar Id")
            self:setError()
		EndIf
	Else
		self:setMessageError("erro - Necessita array contendo ID")
        self:setError()
	EndIf
return self
/*/{Protheus.doc} setMessageError
    
    Método para receber a mensagem de erro e disparar definicao de erro

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method setMessageError(cMessage as character) as character Class TCIWritten
	self:cMessage := cMessage
return self
/*/{Protheus.doc} setError
    
    Método definir erro

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method setError() as logical Class TCIWritten
	self:lError := .T. 
return self
/*/{Protheus.doc} hasRequestError
    
    Método que retorna se há erro de requisição

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method hasRequestError() as logical class TCIWritten
return self:lError

/*/{Protheus.doc} setCache
    (Método para inserir ID pesquisados no Json Cache)
    @author Rhuan EA Carvalho
    @since 10/04/2024
    @version 12.1.2410
    @param cData, character, Caractere contendo estrutura Json com Ids já processados
    @return self, self, atributo da classe TCIWritten
    /*/
Method setCache(cData, jObject) as json class TCIWritten
    self:jCache[cData] := jObject
Return self

/*/{Protheus.doc} hasInCache
    (retorna Json com Cache de IDs pesquisados)
    @author Rhuan EA  Carvalho
    @since 10/04/2024
    @version version
    @param 
    @return self:jCache, Json, Json contendo IDs já pesquisados
    /*/
Method hasInCache() as json class TCIWritten
Return self:jCache
/*/{Protheus.doc} getMessageError
    
    Método que retorna mensagem de erro

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method getMessageError() as character class TCIWritten
return self:cMessage
/*/{Protheus.doc} validadeId
    
    Método que verifica se os Ids informados são válidos para pesquisa

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method validadeId() as array class TCIWritten
	Local nX := 0      as numeric

	For nX := 1 to len(self:aIdRequest)
		If len(self:aIdRequest[nX]) == 36
			aAdd(self:aSearchList, self:aIdRequest[nX])
		Else
			aSize(self:aSearchList, len(self:aSearchList) + 1)
			aIns(self:aSearchList, nX)
			Self:aSearchList[nX] := "erro"
		EndIf
	Next nX
return

/*/{Protheus.doc} setReturnByTaxRule
    
    Método para informar que o tipo de retorno que será utilizado no método GetDataId() sera por TaxRule

    @author Douglas Dourado
    @since 10/01/2025
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method setReturnByTaxRule() as character Class TCIWritten
    self:cGetDataTypeReturn := 'ByTaxRule'
return self

/*/{Protheus.doc} setReturnByIdTotvs
    
    Método para informar que o tipo de retorno que será utilizado no método GetDataId() sera por TaxRule

    @author Douglas Dourado
    @since 10/01/2025
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method setReturnByIdTotvs() as character Class TCIWritten
    self:cGetDataTypeReturn := 'ByIdTotvs'
return self

/*/{Protheus.doc} setIdTotvsFilterList
    
    Método para inserir o filtro de tributos com IdTotvs no Retorno por IdTOTVS

    @author Douglas Dourado
    @since 10/01/2025
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method setIdTotvsFilterList(aIdTotvsList as array) as array Class TCIWritten
	
    If !empty(aIdTotvsList)
        self:aIdTotvsFilterList := aIdTotvsList
    Else
        self:setMessageError("erro - obrigatorio passar um array com no mínimo um Totvs ID valido! (F2C_CODIGO) ")
        self:setError()
    Endif

return self

/*/{Protheus.doc} setTaxRuleFilterList
    
    Método para inserir o filtro de códigos de regra de calculo no Retorno por regra de calculo

    @author Douglas Dourado
    @since 10/01/2025
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method setTaxRuleFilterList(aTaxRuleList as array) as array Class TCIWritten
	
    If !empty(aTaxRuleList)
        self:aTaxRuleFilterList := aTaxRuleList
    Else
        self:setMessageError("erro - obrigatorio passar um array com no mínimo um código de regra de cálculo válido! (F2B_REGRA) ")
        self:setError()
    Endif

return self

/*/{Protheus.doc} setAdditionalFieldsToReturn
    
    Método para inserir campos adicionais que se deseja receber nos retornos por IdTotvs ou Regra de Calculo

    @author Douglas Dourado
    @since 10/01/2025
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method setAdditionalFieldsToReturn(aFieldsToReturn as array) as array Class TCIWritten
	
    If !empty(aFieldsToReturn)
        self:aAdditionalFieldsToReturn := aFieldsToReturn
    Else
        self:setMessageError("erro - obrigatorio passar um array com no mínimo um atributo válido! ")
        self:setError()
    Endif

return self

/*/{Protheus.doc} setDataItems
    
    Método para identificar requisição da propriedade dados_itens
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return cRefBase, character, dados tipo caracter com estrutura Json
/*/
Method setDataItems(aContent) as array Class TCIWritten
    
    Local nX        := 0 as numeric
    
    //Restaurando as váriaveis em caso do metodo ser executado mais de uma vez
    self:lBaseRules         := .F.
	self:lTaxRateRules      := .F.
    self:lBookKeeping       := .F.
    self:aErrorItens        := {}
    self:aRegra             := {}
           
    If Valtype(aContent) == 'A' 
        For nX := 1 To len(aContent)
            Do case
                Case aContent[nX] == "regras_base"
                    self:lBaseRules        := .T.
                    aAdd(self:aRegra,"regras_base")
                Case aContent[nX] == "regras_aliquota"
                    self:lTaxRateRules     := .T.
                    aAdd(self:aRegra,"regras_aliquota")
                Case aContent[nX] == "regras_escrituracao"
                    self:lBookKeeping      := .T.
                    aAdd(self:aRegra,"regras_escrituracao")
                Otherwise
                    aAdd(self:aErrorItens, aContent[nX])
            EndCase
        Next nX
    EndIf

return self

/*/{Protheus.doc} getDataId
    
    Método público que processa e retorna um dado carácter em estrutura Json

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method getDataId() as character Class TCIWritten
    Local cIndexToReturn := '' as character

	if self:hasRequestError()
        self:cResponse := self:getMessageError()
	Else
		self:processResponseSearchList()
		self:jRequestResponse["dados_Id"] := self:hasInCache()
        
        if( !Empty( self:cGetDataTypeReturn ) )
            if( self:cGetDataTypeReturn == 'ByTaxRule' )
                cIndexToReturn := 'dados_por_regratrib'
                self:jRequestResponse[cIndexToReturn] := self:ReturnByTaxRule()                
            elseif( self:cGetDataTypeReturn == 'ByIdTotvs' )
                cIndexToReturn := 'dados_por_totvsid'
                self:jRequestResponse[cIndexToReturn]  := self:ReturnByIdTotvs()    
            endif
        endif

        if self:hasRequestError()
            self:cResponse := self:getMessageError()
        Else
            if( Empty( self:cGetDataTypeReturn ) )
                self:cResponse := self:jRequestResponse:toJson()
            else
                self:cResponse := self:jRequestResponse[cIndexToReturn]:toJson()
            endif
        EndIf

	EndIf
    
return self:cResponse

/*/{Protheus.doc} CreateJSONByTaxRule()
 
    Método que utiliza os dados que estão prontos no self:jRequestResponse["dados_Id"], "filtra" se necessario, e monta um objeto por tributos e itens que contem esse tributo ...

    @author Douglas Dourado
    @since 08/01/2025
    @version 12.1.2410
    @return nil    
/*/
Method ReturnByTaxRule() as json Class TCIWritten
    
    Local nX := 0 as numeric
    Local nZ := 0 as numeric
    Local jRulesCache   := self:hasInCache() as json
    Local aTaxesInReg as array
    Local aIdsRel     := jRulesCache:GetNames() as array        

    self:jResponseResume := JsonObject():New()

    For nZ := 1 to len(aIdsRel)
        
        aTaxesInReg := jRulesCache:GetJsonObject(aIdsRel[nZ]):GetNames()
        For nX := 1 to len(aTaxesInReg)
            If Empty(self:aTaxRuleFilterList) .or. ( !Empty(self:aTaxRuleFilterList) .and.  Ascan( self:aTaxRuleFilterList ,{|x| x == aTaxesInReg[nX] }) > 0 )
                self:CreateJSONByTaxRule( aIdsRel[nZ] , aTaxesInReg[nX] , self:aAdditionalFieldsToReturn , jRulesCache )                   
            Endif
        Next nX
    Next nZ

    FWFreeObj(jRulesCache)

return self:jResponseResume

/*/{Protheus.doc} CreateJSONByTaxRule()
 
    Método que realiza a montagem no JSON de retorno para o método ReturnByTaxRule()

    @author Douglas Dourado
    @since 08/01/2025
    @version 12.1.2410
    @return nil    
/*/
Method CreateJSONByTaxRule( cIdRel as character , cTax as character , aFieldsNeeded as array , jRulesCache as json) Class TCIWritten

    Local nY := 0 as numeric
    Local nW := 0 as numeric
    Local aAtribDefault := {'filial','codigo_tributo_relacionado','tributo','descricao_tributo_relacionado','base_tributo','aliquota_tributo','valor_tributo'} as array

    If !self:jResponseResume:hasProperty(cTax)                        
        self:jResponseResume[ cTax ] := JsonObject():New()
        self:jResponseResume[ cTax ]['items'] := JsonObject():New()            
    EndIf

    self:jResponseResume[ cTax ]['items'][ cIdRel ] := JsonObject():New()
    self:jResponseResume[ cTax ]['items'][ cIdRel ][ 'regra_trib' ] := cTax

    // Atributos Padrões, que sempre vão ser retornados no JSON ...
    if( !empty(aAtribDefault) )
        for nW := 1 to len(aAtribDefault)
            If jRulesCache:GetJsonObject(cIdRel):GetJsonObject(cTax):hasProperty(aAtribDefault[nW])
                self:jResponseResume[ cTax ]['items'][ cIdRel ][ aAtribDefault[nW] ] := jRulesCache:GetJsonObject(cIdRel):GetJsonObject(cTax):GetJsonObject(aAtribDefault[nW])
            Endif
        next nW
    Endif

    // Adiciona no objeto mais atributos conforme solicitado no parametro aFieldsNeeded ...
    if( !empty(aFieldsNeeded) )
        for nY := 1 to len(aFieldsNeeded)
            If jRulesCache:GetJsonObject(cIdRel):GetJsonObject(cTax):hasProperty(aFieldsNeeded[nY])
                self:jResponseResume[ cTax ]['items'][ cIdRel ][ aFieldsNeeded[nY] ] := jRulesCache:GetJsonObject(cIdRel):GetJsonObject(cTax):GetJsonObject(aFieldsNeeded[nY])
            Else
                self:setMessageError("erro - o atributo " + aFieldsNeeded[nY] + " não foi encontrado!")
                self:setError() 
            Endif
        next nY
    Endif

Return


// 
/*/{Protheus.doc} ReturnByIdTotvs()
    
    Método que utiliza os dados que estão prontos no self:jRequestResponse["dados_Id"], "filtra" se necessario, 
    e monta um novo objeto com idTOTVS de indice, que dentro contem os itens com esse ID TOTVS ...

    @author Douglas Dourado
    @since 08/01/2025
    @version 12.1.2410
    @return nil    
/*/
Method ReturnByIdTotvs() as json Class TCIWritten
    
    Local nX := 0 as numeric
    
    Local nZ := 0 as numeric
    Local jRulesCache   := self:hasInCache() as json
    Local aTaxesInReg as array
    Local aIdsRel     := jRulesCache:GetNames() as array    
    Local cIdTotvs as character    

    self:jResponseResume := JsonObject():New()

    For nZ := 1 to len(aIdsRel)
        
        aTaxesInReg := jRulesCache:GetJsonObject(aIdsRel[nZ]):GetNames()
        For nX := 1 to len(aTaxesInReg)

            If jRulesCache:GetJsonObject(aIdsRel[nZ]):GetJsonObject(aTaxesInReg[nX]):hasProperty('codigo_tributo_relacionado')
                
                cIdTotvs := jRulesCache:GetJsonObject(aIdsRel[nZ]):GetJsonObject(aTaxesInReg[nX]):GetJsonText('codigo_tributo_relacionado')
                
                If !empty(cIdTotvs) .and. ( Empty(self:aIdTotvsFilterList) .or. (!Empty(self:aIdTotvsFilterList) .and. Ascan( self:aIdTotvsFilterList ,{|x| x == cIdTotvs }) > 0) )
                    self:CreateJsonbyIdTotvs( cIdTotvs , aIdsRel[nZ] , aTaxesInReg[nX] , self:aAdditionalFieldsToReturn , jRulesCache )                   
                Endif
            Endif

        Next nX
    Next nZ

    FWFreeObj(jRulesCache)

return self:jResponseResume

/*/{Protheus.doc} CreateJsonbyIdTotvs()
 
    Método que realiza a montagem no JSON de retorno para o método ReturnByIdTotvs()

    @author Douglas Dourado
    @since 08/01/2025
    @version 12.1.2410
    @return nil    
/*/
Method CreateJsonbyIdTotvs( cIdTotvs as character , cIdRel as character , cTax as character , aFieldsNeeded as array , jRulesCache as json) Class TCIWritten

    Local nY := 0 as numeric
    Local nW := 0 as numeric
    Local aAtribDefault := {'filial','codigo_tributo_relacionado','tributo','descricao_tributo_relacionado','base_tributo','aliquota_tributo','valor_tributo'} as array

    If !self:jResponseResume:hasProperty(cIdTotvs)                        
        self:jResponseResume[ cIdTotvs ] := JsonObject():New()
        self:jResponseResume[ cIdTotvs ]['items'] := JsonObject():New()            
    EndIf

    self:jResponseResume[ cIdTotvs ]['items'][ cIdRel ] := JsonObject():New()
    self:jResponseResume[ cIdTotvs ]['items'][ cIdRel ][ 'regra_trib' ] := cTax

    // Atributos Padrões, que sempre vão ser retornados no JSON ...
    if( !empty(aAtribDefault) )
        for nW := 1 to len(aAtribDefault)
            If jRulesCache:GetJsonObject(cIdRel):GetJsonObject(cTax):hasProperty(aAtribDefault[nW])
                self:jResponseResume[ cIdTotvs ]['items'][ cIdRel ][ aAtribDefault[nW] ] := jRulesCache:GetJsonObject(cIdRel):GetJsonObject(cTax):GetJsonObject(aAtribDefault[nW])
            Endif
        next nW
    Endif

    // Adiciona no objeto mais atributos conforme solicitado no parametro aFieldsNeeded ...
    if( !empty(aFieldsNeeded) )
        for nY := 1 to len(aFieldsNeeded)
            If jRulesCache:GetJsonObject(cIdRel):GetJsonObject(cTax):hasProperty(aFieldsNeeded[nY])
                self:jResponseResume[ cIdTotvs ]['items'][ cIdRel ][ aFieldsNeeded[nY] ] := jRulesCache:GetJsonObject(cIdRel):GetJsonObject(cTax):GetJsonObject(aFieldsNeeded[nY])
            Else
                self:setMessageError("erro - o atributo " + aFieldsNeeded[nY] + " não foi encontrado!")
                self:setError() 
            Endif
        next nY
    Endif

Return

/*/{Protheus.doc} processResponseSearchList()
    
    Método que realiza o processamento da lista de pesquisa, retornando um Json

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method processResponseSearchList() as json Class TCIWritten
    Local aProcess    := {}                 as array
	Local aSearchList := self:aSearchList   as array
	Local jIdProcess  := JsonObject():New() as json
	Local nX          := 0                  as numeric

	For nX := 1 To len(aSearchList)
        If !self:hasInCache():hasProperty(self:aIdRequest[nX])
            If !self:validSearch(nX,aSearchList)             
                aAdd(aProcess, aSearchList[nX])	
                Loop
            EndIf
        Else
            aProcess := self:checkRules(nX, aProcess)
        EndIf
	Next nX

    If Len(aProcess) > 0
        jIdProcess:FromJson(self:setIdData(aProcess))
    EndIf
    
    FreeObj(jIdProcess)
return

/*/{Protheus.doc} ValidSearch()

    Método que verifica se o ID pesquisado contem erro.

    @author Jaylson B. Teixeira 
    @since 17/12/2024
    @version 12.1.2410
    @return lControle, logical     
/*/
Method validSearch(nX,aSearchList) as logical class TCIWritten

    Local jIdError    := JsonObject():New() as json
    Local lControle   as logical

    If aSearchList[nX] == "erro"
        self:setMessageError("erro - id incorreto")
        jIdError          := JsonObject():New()
        jIdError["error"] := self:getMessageError()
        self:setCache(self:aIdRequest[nX], jIdError)
        lControle := .T.
    EndIf

    FreeObj(jIdError)
Return lControle

/*/{Protheus.doc} checkRules() 
    
    Método que verifica se o ID que está no cache,contém as regras.
    Caso não tenha adiciona para processamento.

    @author Jaylson B. Teixeira 
    @since 17/12/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method checkRules(nX,aProcess) as array class TCIWritten

    Local aTributos     := self:hasInCache():GetJsonObject(self:aIdRequest[nX]):GetNames(self:aIdRequest[nX])
    Local jRulesCache   := self:hasInCache():GetJsonObject(self:aIdRequest[nX])
    Local nZ            as numeric
    Local nPos          as numeric
    
    //Verifica se aTributos tem tributos válidos:
    For nZ := 1 to len(aTributos)
        
        Do Case 
            Case aTributos[nZ] == "Aviso"
                Loop
            Case aTributos[nZ] == "erro_propriedade"
                Loop
            Case aTributos[nZ] == "error"
                Loop
            Otherwise
                nPos := 1
                exit
        EndCase
        
    Next nZ
   
    For nZ := 1 to len(self:aRegra) 
        If nPos > 0
            If !jRulesCache:GetJsonObject(aTributos[nPos]):hasProperty(self:aRegra[nZ]) .and. Ascan(aProcess,{|x| x == self:aIdRequest[nX]}) = 0
                Aadd(aProcess, self:aIdRequest[nX])
            EndIf
        EndIf
    Next    

    FreeObj(jRulesCache)
Return aProcess

/*/{Protheus.doc} setIdData()
    
    Método que realiza querie e compõe o json

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method setIdData(aProcess) class TCIWritten
	Local cAlias            := "" as character
    Local cIdRel                  as character
	Local cQuery            := "" as character
    Local cID               := "" as character
	Local jTax                  as json
	Local jTaxRefCalc           as json
	Local jTaxRefWritten        as json
    Local aRegistrosAtivos  := {'2'} as array
    Local cDelet            := ' '
    Local cBD               := TCGetDB()    as character
    Local nControle         := 1 as integer

    self:jCacheSX3 := self:validateSX3Exists()

    cQuery := " SELECT F2D.F2D_VALURF F2DVALURF "
    cQuery += " ,F2B.F2B_TRIB F2BTRIB, F2D.F2D_IDCAD F2DIDCAD, F2D.F2D_FILIAL F2DFILIAL, F2D.F2D_IDREL F2DIDR, F2D.F2D_TRIB F2DTRIBUTO, F2D.F2D_BASE F2DBASE, F2D.F2D_ALIQ F2DALIQ" 
    cQuery += " ,F2D.F2D_VALOR F2DVALOR, F2D.F2D_MVA F2DMVA, F2D.F2D_PAUTA F2DPAUTA"
    cQuery += " ,F2D.F2D_MAJORA F2DMAJORA, F2D.F2D_AUXMAJ F2DAUXMAJ, F2D.F2D_TRBMAJ F2DTRBMAJ, F2D.F2D_VALMAJ F2DVALMAJ"
    cQuery += " ,F2D.F2D_ALQMAJ F2DALQMAJ, F2D.F2D_DEDDEP F2DDEDDEP, F2D.F2D_BASQTD F2DBASQTD"
    cQuery += " ,F2C.F2C_CODIGO F2CCODIGO,F2C.F2C_DESC F2CDESC "     
    
    // CAMPOS DE DADOS ESCRITURADOS
    cQuery += " ,CJ3.CJ3_FILIAL CJ3FILIAL, CJ3.CJ3_VLTRIB CJ3VALTRIB, CJ3.CJ3_CST CJ3CST, CJ3.CJ3_VLISEN CJ3VLISEN, CJ3.CJ3_VLOUTR CJ3VLOUTR "
    cQuery += " ,CJ3.CJ3_VLNTRI CJ3VLNTRI, CJ3.CJ3_VLDIFE CJ3VLDIFE, CJ3.CJ3_VLMAJO CJ3VLMAJO " 
    cQuery += " ,CJ3.CJ3_PEMAJO CJ3PEMAJO, CJ3.CJ3_PEDIFE CJ3PEDIFE, CJ3.CJ3_PEREDU CJ3PEREDU "
    cQuery += " ,CJ3.CJ3_PAUTA CJ3PAUTA, CJ3.CJ3_MVA CJ3MVA, CJ3.CJ3_AUXMVA CJ3AUXMVA "
    cQuery += " ,CJ3.CJ3_AUXMAJ CJ3AUXMAJ, CJ3.CJ3_CSTCAB CJ3CSTCAB, CJ3.CJ3_BASORI CJ3BASORI, CJ3.CJ3_TRIB CJ3TRIB "

    if self:jCacheSX3["CJ3_CCT"]
        cQuery += " , CJ3.CJ3_CCT CJ3CCT "
    endIf

    if self:jCacheSX3["CJ3_PREDAL"] .And. self:jCacheSX3["CJ3_ALIQOR"]
        cQuery += " , CJ3.CJ3_PREDAL CJ3PREDAL, CJ3_ALIQOR CJ3ALIQO "
    endIf
                    
    // CAMPOS REGRAS DE BASE
    If self:lBaseRules
        cQuery += " ,F27.F27_CODIGO F27CODIGO ,F27_DESC F27DESC ,F27.F27_VALORI F27VALORI, F27.F27_DESCON	F27DESCON "
        cQuery += " ,F27.F27_FRETE F27FRETE, F27.F27_SEGURO F27SEGURO, F27.F27_DESPE	F27DESPE "
        cQuery += " ,F27.F27_ICMDES	F27ICMDES,F27.F27_ICMRET F27ICMRET, F27.F27_REDBAS F27REDBAS "
        cQuery += " ,F27.F27_TPRED F27TPRED, F27.F27_UM F27UM "
        cQuery += " ,BASE.CIN_ID	BASEFID,BASE.CIN_CODIGO BASEFCOD "
    Endif

    If "ORACLE" $ cBD
        If self:lBaseRules
            cQuery +=   " , UTL_RAW.CAST_TO_VARCHAR2(DBMS_LOB.SUBSTR(BASE.CIN_FORMUL, 4000, 1)) BASEFOR  "   // CAMPO DE BASE
        EndIf
        If self:lTaxRateRules
            cQuery +=   " , UTL_RAW.CAST_TO_VARCHAR2(DBMS_LOB.SUBSTR(ALQ.CIN_FORMUL , 4000, 1)) ALQFORM  "   // CAMPO DE ALIQUOTA
        End
    ElseIf "POSTGRES" $ cBD
        If self:lBaseRules
            cQuery +=   " , encode(BASE.CIN_FORMUL, 'escape') BASEFOR  " // CAMPO DE BASE
        EndIf
        If self:lTaxRateRules
            cQuery +=   " , encode(ALQ.CIN_FORMUL	, 'escape') ALQFORM  " // CAMPO DE ALIQUOTA
        EndIf
    Else
        If self:lBaseRules
            cQuery +=   " , COALESCE(CAST(CAST(BASE.CIN_FORMUL AS VARBINARY(8000)) AS VARCHAR(8000)),' ') BASEFOR  "   // CAMPO DE BASE
        EndIf
        If self:lTaxRateRules
            cQuery +=   " , COALESCE(CAST(CAST(ALQ.CIN_FORMUL	   AS VARBINARY(8000)) AS VARCHAR(8000)),' ') ALQFORM  " // CAMPO DE ALIQUOTA
        EndIf
    EndIf
    
    // CAMPOS REGRAS ALIQUOTA
    if self:lTaxRateRules
        cQuery += " ,F28.F28_CODIGO F28CODIGO, F28_DESC F28DESC,F28.F28_VALORI F28VALORI,F28.F28_TPALIQ F28TPALIQ "
        cQuery += " ,F28.F28_ALIQ F28ALIQ,F28.F28_URF F28URF, F28.F28_UFRPER F28UFRPER "
        cQuery += " ,ALQ.CIN_ID ALQFID,ALQ.CIN_CODIGO ALQCOD "

        if self:jCacheSX3["F28_REDALI"]
            cQuery += " , F28.F28_REDALI ALQREDALI "
        endIf
    Endif

    // CAMPOS REGRAS ESCRITURACAO
    if self:lBookKeeping 
        cQuery += " ,CJ2.CJ2_CODIGO CJ2CODIGO, CJ2.CJ2_DESCR CJ2DESCR ,CJ2.CJ2_INCIDE	CJ2INCIDE,CJ2.CJ2_STOTNF CJ2STOTNF, CJ2.CJ2_PERDIF CJ2PERDIF  "
        cQuery += " ,CJ2.CJ2_IREDBS CJ2IREDBS, CJ2.CJ2_CST	CJ2CST,CJ2.CJ2_CSTCAB CJ2CSTCAB, CJ2.CJ2_CSTDEV CJ2CSTDEV  "

        if self:jCacheSX3["CJ2_CSTCCT"] .and. self:jCacheSX3["CJ2_CCT"]
            cQuery += " , CJ2.CJ2_CCT CJ2CCT , CJ2.CJ2_CSTCCT CJ2CSTCCT "
        endIf
    EndIf

    cQuery += " FROM ? F2D "
    cQuery += " LEFT JOIN ? CJ3 ON CJ3.CJ3_FILIAL = ? AND CJ3.CJ3_IDF2D = F2D.F2D_ID AND CJ3.CJ3_IDTGEN = F2D.F2D_IDREL AND CJ3.D_E_L_E_T_ = ? "
    cQuery += " JOIN ? F2B ON F2B.F2B_FILIAL = ? AND F2B.F2B_ID = F2D.F2D_IDCAD  AND F2B.D_E_L_E_T_ = ? "
    cQuery += " JOIN ? F2E ON F2E.F2E_FILIAL = ? AND F2E.F2E_TRIB = F2B.F2B_TRIB AND F2E.D_E_L_E_T_ = ? "
    cQuery += " LEFT JOIN ? F2C ON F2C.F2C_FILIAL = ? AND F2C.F2C_CODIGO = F2E.F2E_IDTRIB AND F2C.D_E_L_E_T_ = ? " 
    
    If self:lBaseRules
        cQuery += " JOIN ? F27 ON F27.F27_FILIAL = ?  AND F27.F27_CODIGO = F2B.F2B_RBASE AND F27_ALTERA IN (?) AND F27.D_E_L_E_T_ = ? "
        cQuery += " JOIN ? BASE ON BASE.CIN_FILIAL = ?  AND BASE.CIN_IREGRA = F27.F27_ID AND BASE.D_E_L_E_T_ = ? "
    EndIf
    If self:lTaxRateRules
        cQuery += " JOIN ? F28 ON F28.F28_FILIAL = ?  AND F28.F28_CODIGO = F2B.F2B_RALIQ AND F28_ALTERA IN (?) AND F28.D_E_L_E_T_ = ? "
        cQuery += " JOIN ? ALQ ON ALQ.CIN_FILIAL = ?  AND ALQ.CIN_IREGRA = F28.F28_ID  AND ALQ.D_E_L_E_T_ =  ? "
    EndIf
    If self:lBookKeeping 
        cQuery += " LEFT JOIN ? CJ2 ON CJ2.CJ2_FILIAL = ?  AND CJ2.CJ2_CODIGO = F2B.F2B_CODESC AND CJ2.CJ2_DTALT = ? AND CJ2.D_E_L_E_T_ = ? "
        cQuery += " LEFT JOIN ? ESCRIT ON ESCRIT.CIN_FILIAL = ?  AND ESCRIT.CIN_IREGRA = CJ2.CJ2_ID  AND ESCRIT.D_E_L_E_T_ = ? "
    EndIf
    cQuery += " WHERE F2D.F2D_IDREL IN (?) "
    cQuery += " AND F2D_DTEXCL = ? "
    cQuery += " AND F2D.D_E_L_E_T_ = ? " 

    oPrepared := FWExecStatement():New()
    oPrepared:SetQuery(ChangeQuery(cQuery))

    oPrepared:setUnSafe(nControle++, RetSQLName("F2D"))
    oPrepared:setUnSafe(nControle++, RetSqlName("CJ3"))
    oPrepared:setString(nControle++,    xFilial("CJ3"))
    oPrepared:setString(nControle++,   cDelet)
    oPrepared:setUnSafe(nControle++, RetSqlName("F2B"))
    oPrepared:setString(nControle++,    xFilial("F2B"))
    oPrepared:setString(nControle++,   cDelet)
    oPrepared:setUnSafe(nControle++, RetSqlName("F2E"))
    oPrepared:setString(nControle++,    xFilial("F2E"))
    oPrepared:setString(nControle++,   cDelet)
    oPrepared:setUnSafe(nControle++, RetSqlName("F2C"))
    oPrepared:setString(nControle++,    xFilial("F2C"))
    oPrepared:setString(nControle++,   cDelet)

    If self:lBaseRules
        oPrepared:setUnSafe(nControle++, RetSqlName("F27"))
        oPrepared:setString(nControle++,    xFilial("F27"))
        oPrepared:setIn(nControle++, aRegistrosAtivos)
        oPrepared:setString(nControle++,   cDelet)
        oPrepared:setUnSafe(nControle++, RetSqlName("CIN"))
        oPrepared:setString(nControle++,    xFilial("CIN"))
        oPrepared:setString(nControle++,   cDelet)
    EndIf

    If self:lTaxRateRules
        oPrepared:setUnSafe(nControle++, RetSqlName("F28"))
        oPrepared:setString(nControle++,    xFilial("F28"))
        oPrepared:setIn(nControle++, aRegistrosAtivos)
        oPrepared:setString(nControle++,   cDelet)
        oPrepared:setUnSafe(nControle++, RetSqlName("CIN"))
        oPrepared:setString(nControle++,    xFilial("CIN"))
        oPrepared:setString(nControle++,   cDelet)
    EndIf

    If self:lBookKeeping 
        oPrepared:setUnSafe(nControle++, RetSqlName("CJ2"))
        oPrepared:setString(nControle++,    xFilial("CJ2"))
        oPrepared:setString(nControle++,   ' ')
        oPrepared:setString(nControle++,   cDelet)
        oPrepared:setUnSafe(nControle++, RetSqlName("CIN"))
        oPrepared:setString(nControle++,    xFilial("CIN"))
        oPrepared:setString(nControle++,   cDelet)
    EndIf

    oPrepared:setIn(nControle++, aProcess)
    oPrepared:setString(nControle++,   ' ')
    oPrepared:setString(nControle++,   cDelet)

    cAlias := oPrepared:OpenAlias()  

    self:updateCache(aProcess)

    While (cAlias)->(!Eof())

        IF cID <> AllTrim((cAlias)->F2DIDR)
            cID     := AllTrim((cAlias)->F2DIDR)
            nControle := 0
            If !self:jCache:GetJsonObject((cAlias)->F2DIDR):hasProperty((cAlias)->F2DTRIBUTO)
                jTax   := JsonObject():New()
            Else
                jTax   := self:jCache:GetJsonObject((cAlias)->F2DIDR)
            EndIf
        EndIf

        If !self:jCache:GetJsonObject((cAlias)->F2DIDR):hasProperty((cAlias)->CJ3TRIB)
            jTaxRefCalc                                  := JsonObject():New()
            jTaxRefCalc["filial"]                        := AllTrim((cAlias)->F2DFILIAL)
            jTaxRefCalc["tributo"]                       := AllTrim((cAlias)->F2BTRIB)
            jTaxRefCalc["codigo_tributo_relacionado"]    := AllTrim((cAlias)->F2CCODIGO)
            jTaxRefCalc["descricao_tributo_relacionado"] := AllTrim((cAlias)->F2CDESC)
            jTaxRefCalc["base_quantidade_tributo"]       := (cAlias)->F2DBASQTD
            jTaxRefCalc["base_tributo"]                  := (cAlias)->F2DBASE
            jTaxRefCalc["aliquota_tributo"]              := (cAlias)->F2DALIQ
            jTaxRefCalc["valor_tributo"]                 := (cAlias)->F2DVALOR
            jTaxRefCalc["valor_urf"]                     := (cAlias)->F2DVALURF
            jTaxRefCalc["mva"]                           := (cAlias)->F2DMVA
            jTaxRefCalc["valor_pauta"]                   := (cAlias)->F2DPAUTA
            jTaxRefCalc["percentual_majora"]             := (cAlias)->F2DMAJORA
            jTaxRefCalc["indice_aux_majora"]             := (cAlias)->F2DAUXMAJ
            jTaxRefCalc["tributo_majora"]                := AllTrim((cAlias)->F2DTRBMAJ)
            jTaxRefCalc["aliquota_majora"]               := (cAlias)->F2DALQMAJ
            jTaxRefCalc["valor_majora"]                  := (cAlias)->F2DVALMAJ
            jTaxRefCalc["ded_dependentes"]               := (cAlias)->F2DDEDDEP
            jTaxRefCalc["id_cadastro_regra_tributo"]     := AllTrim((cAlias)->F2DIDCAD)
            jTaxRefWritten                               := JsonObject():New()
            jTaxRefWritten["filial"]                     := AllTrim((cAlias)->CJ3FILIAL)
            jTaxRefWritten["codigo_tributo"]             := AllTrim((cAlias)->CJ3TRIB)
            jTaxRefWritten["valor_tributado"]            := (cAlias)->CJ3VALTRIB
            jTaxRefWritten["cst"]                        := AllTrim((cAlias)->CJ3CST)
            jTaxRefWritten["valor_isento"]               := (cAlias)->CJ3VLISEN
            jTaxRefWritten["valor_outros"]               := (cAlias)->CJ3VLOUTR
            jTaxRefWritten["valor_nao_tributado"]        := (cAlias)->CJ3VLNTRI
            jTaxRefWritten["valor_diferido"]             := (cAlias)->CJ3VLDIFE
            jTaxRefWritten["valor_majorado"]             := (cAlias)->CJ3VLMAJO
            jTaxRefWritten["perc_majorado"]              := (cAlias)->CJ3PEMAJO
            jTaxRefWritten["perc_diferido"]              := (cAlias)->CJ3PEDIFE
            jTaxRefWritten["perc_reducao"]               := (cAlias)->CJ3PEREDU
            jTaxRefWritten["valor_pauta"]                := (cAlias)->CJ3PAUTA
            jTaxRefWritten["mva"]                        := (cAlias)->CJ3MVA
            jTaxRefWritten["ind_aux_mva"]                := (cAlias)->CJ3AUXMVA
            jTaxRefWritten["Ind_aux_majora"]             := (cAlias)->CJ3AUXMAJ
            jTaxRefWritten["codigo_tab_cst"]             := AllTrim((cAlias)->CJ3CSTCAB)
            jTaxRefWritten["valor_base_original"]        := (cAlias)->CJ3BASORI

            if self:jCacheSX3["CJ3_PREDAL"] .And. self:jCacheSX3["CJ3_ALIQOR"]
                jTaxRefWritten["perc_red_aliquota"]          := (cAlias)->CJ3PREDAL
                jTaxRefWritten["perc_aliquota_original"]     := (cAlias)->CJ3ALIQO
            endIf
            
            if self:jCacheSX3["CJ3_CCT"]
                jTaxRefWritten["cct"]                        := AllTrim((cAlias)->CJ3CCT)
                jTaxRefWritten["cclasstrib"]                 := ""

                if !empty(jTaxRefWritten["cct"])
                    jTaxRefWritten["cclasstrib"]             := AllTrim((cAlias)->CJ3CST) + AllTrim((cAlias)->CJ3CCT)
                endIf
            endIf 

            jTaxRefCalc["dados_escriturados"]            := jTaxRefWritten            
        
        Else 
            jTaxRefCalc                             := self:jCache:GetJsonObject((cAlias)->F2DIDR):GetJsonObject((cAlias)->F2DTRIBUTO)
            jTaxRefCalc["dados_escriturados"]       := self:jCache:GetJsonObject((cAlias)->F2DIDR):GetJsonObject((cAlias)->F2DTRIBUTO):GetJsonObject("dados_escriturados")
        EndIf

        jTaxRefCalc := self:validRulesJson(jTaxRefCalc,cAlias,jTax,nControle )

        jTax[AllTrim((cAlias)->F2DTRIBUTO)]   := jTaxRefCalc         

        cIdRel  := AllTrim((cAlias)->F2DIDR)

        If !Empty(cIdRel)            
            self:setCache(cIdRel, jTax)
            nControle := 1
        EndIf

        (cAlias)->(DbSKip())
    EndDo

	dbSelectArea(cAlias)
	(cAlias)->(DbCloseArea())

return

/*/{Protheus.doc} updateCache()
    
    Método que verifica e atualiza se o ID a ser pesquisado não está no cache.
   
    @author Jaylson B. Teixeira 
    @since 17/12/2024
    @version 12.1.2410
      
/*/
Method updateCache(aProcess) class TCIWritten

    Local nX as numeric
    Local jErrorItens := JsonObject():New()    

    For nX := 1 To Len(aProcess)
        If !self:jCache:hasProperty(aProcess[nX])
            jErrorItens['Aviso'] := "Id não calculado pelo configurador de tributos"
            self:setCache(aProcess[nX], jErrorItens )
            If len(self:aErrorItens) > 0
                jErrorItens['erro_propriedade'] := self:SetItensError()
                self:setCache(aProcess[nX], jErrorItens)
            EndIf
        EndIf
    Next nX

    FreeObj(jErrorItens)
Return 

/*/{Protheus.doc} validRulesJson()
    
    Método que valida se o ID atende a regra.
    Caso positivo compoe Json

    @author Jaylson B. Teixeira 
    @since 17/12/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method validRulesJson( jTaxRefCalc, cAlias,jTax,nControle ) as json class TCIWritten

    Local nX as numeric

    For nX := 1 to Len(self:aRegra)

        If !self:jCache:GetJsonObject((cAlias)->F2DIDR):hasProperty((cAlias)->F2DTRIBUTO) .or. !self:jCache:GetJsonObject((cAlias)->F2DIDR):GetJsonObject((cAlias)->F2DTRIBUTO):hasproperty(self:aRegra[nX])  
            Do case
                Case self:aRegra[nX] == "regras_base"
                  jTaxRefCalc[self:aRegra[nX]]          := self:setBaseRules(cAlias)
                Case self:aRegra[nX] == "regras_aliquota"
                   jTaxRefCalc[self:aRegra[nX]]          := self:setTaxRateRules(cAlias)
                Case self:aRegra[nX] == "regras_escrituracao"
                    jTaxRefCalc[self:aRegra[nX]]          := self:setBookKeeping(cAlias)
            End Case
        Else
            jTaxRefCalc[self:aRegra[nX]]          := self:jCache:GetJsonObject((cAlias)->F2DIDR):GetJsonObject((cAlias)->F2DTRIBUTO):GetJsonObject(self:aRegra[nX])
        EndIf
       
    Next nX 

    If nControle = 0
        if self:jCache:GetJsonObject((cAlias)->F2DIDR):hasProperty("erro_propriedade")
            jTax["erro_propriedade"] :=   self:jCache:GetJsonObject((cAlias)->F2DIDR):GetJsonObject("erro_propriedade")
        ElseIf Len(self:aErrorItens) > 0
            jTax["erro_propriedade"] := self:SetItensError()
        EndIf
        
    Endif

Return jTaxRefCalc
/*/{Protheus.doc} setBaseRules
    
    Método para preencher as propriedades de regras_base 
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten  
/*/
Method setBaseRules(cAlias) as json class TCIWritten

    Local jTaxRefBase as json

    jTaxRefBase                                     := JsonObject():New()
    jTaxRefBase['codigo_regra']                     := AllTrim((cAlias)->F27CODIGO)
    jTaxRefBase['descricao']                        := AllTrim((cAlias)->F27DESC)
    jTaxRefBase['acao_origem']                      := (cAlias)->F27VALORI
    jTaxRefBase['acao_desconto']                    := (cAlias)->F27DESCON
    jTaxRefBase['acao_frete']                       := (cAlias)->F27FRETE
    jTaxRefBase['acao_seguro']                      := (cAlias)->F27SEGURO
    jTaxRefBase['acao_despesa']                     := (cAlias)->F27DESPE
    jTaxRefBase['acao_icms_desonerado']             := (cAlias)->F27ICMDES
    jTaxRefBase['acao_icms_retido']                 := (cAlias)->F27ICMRET
    jTaxRefBase['perc_reducao']                     := (cAlias)->F27REDBAS
    jTaxRefBase['tipo_reducao']                     := AllTrim((cAlias)->F27TPRED)
    jTaxRefBase['unidade_medida']                   := Alltrim((cAlias)->F27UM)
    jTaxRefBase['formula_base']                     := AllTrim((cAlias)->BASEFOR)
    jTaxRefBase['id_formula']                       := Alltrim((cAlias)->BASEFID)
    jTaxRefBase['codigo_formula']                   := AllTrim((cAlias)->BASEFCOD)
    

return jTaxRefBase

/*/{Protheus.doc} setTaxRateRules
    
    Método para preencher as propriedades de regras_alíquota
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten  
/*/
Method setTaxRateRules(cAlias) as json Class TCIWritten

    Local jTaxRefAliquota as json

    jTaxRefAliquota                                 := JsonObject():New()
    jTaxRefAliquota['codigo_regra']                 := AllTrim((cAlias)->F28CODIGO)
    jTaxRefAliquota['descricao']                    := Alltrim((cAlias)->F28DESC)
    jTaxRefAliquota['acao_origem']                  := (cAlias)->F28VALORI
    jTaxRefAliquota['acao_tipo']                    := (cAlias)->F28TPALIQ
    jTaxRefAliquota['perc_aliquota']                := (cAlias)->F28ALIQ
    jTaxRefAliquota['codigo_urf']                   := AllTrim((cAlias)->F28URF)
    jTaxRefAliquota['perc_urf']                     := (cAlias)->F28UFRPER
    jTaxRefAliquota['formula_aliquota']             := Alltrim((cAlias)->ALQFORM)
    jTaxRefAliquota['id_formula']                   := AllTrim((cAlias)->ALQFID)
    jTaxRefAliquota['codigo_fomula']                := AllTrim((cAlias)->ALQCOD)

    if self:jCacheSX3["F28_REDALI"]
        jTaxRefAliquota['perc_red_aliquota']        := (cAlias)->ALQREDALI
    endIf

Return jTaxRefAliquota

/*/{Protheus.doc} setBookKeeping
    
    Método para preencher as propriedades de regras_escrituracao 
    
    @author Rhuan E.A. Carvalho
    @since 29/02/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten   
/*/
Method setBookKeeping(cAlias) as json class TCIWritten

    Local jTaxRefEscrituracao as json

    If !Empty((cAlias)->CJ2CODIGO)
        jTaxRefEscrituracao                             := JsonObject():New()
        jTaxRefEscrituracao['codigo_regra']             := AllTrim((cAlias)->CJ2CODIGO)
        jTaxRefEscrituracao['descricao']                := AllTrim((cAlias)->CJ2DESCR)
        jTaxRefEscrituracao['acao_incidencia']          := (cAlias)->CJ2INCIDE
        jTaxRefEscrituracao['acao_total_nf']            := (cAlias)->CJ2STOTNF
        jTaxRefEscrituracao['perc_diferimento']         := (cAlias)->CJ2PERDIF
        jTaxRefEscrituracao['incidencia_parc_red']      := (cAlias)->CJ2IREDBS
        jTaxRefEscrituracao['tabela_cst']               := alltrim((cAlias)->CJ2CSTCAB)
        jTaxRefEscrituracao['cst']                      := AllTrim((cAlias)->CJ2CST)
        jTaxRefEscrituracao['cst_devolucao']            := AllTrim((cAlias)->CJ2CSTDEV)

        if self:jCacheSX3["CJ2_CSTCCT"] .and. self:jCacheSX3["CJ2_CCT"]
            jTaxRefEscrituracao['cct']                  := AllTrim((cAlias)->CJ2CCT)
            jTaxRefEscrituracao['cclasstrib']           := AllTrim((cAlias)->CJ2CSTCCT)
        endIf
    Else
        jTaxRefEscrituracao := self:setRulesMsg()
    Endif



 Return jTaxRefEscrituracao


 /*/{Protheus.doc} SetItensError
    
    Método para preencher as propriedades error_itens 
    
    @author Jaylson B. Teixeira
    @since 29/02/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten   
/*/
Method SetItensError() as json class TCIWritten

    Local jLocal            := JsonObject():New()  as json
    Local nX as numeric

    For nX := 1 to len(self:aErrorItens)
        jLocal['propriedade_'+AllTrim(STR(nX))]   := self:aErrorItens[Nx]
    Next nX
    
return jLocal

 /*/{Protheus.doc} setRulesMsg
    
    Método que retorna mensagem quando a regra nao está vinculada 
    
    @author Jaylson B. Teixeira
    @since 29/02/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten  
/*/
Method setRulesMsg() as json class TCIWritten

    Local jMensagem := JsonObject():New()

    jMensagem := "regra nao vinculada"
    
return jMensagem

/*/{Protheus.doc} getAgregTypeByTax
    
    Método para buscar o tipo de incidencia no total da nf (regra_escrituração)   

    Param @aAgregTypesToSeach (Opcional) : string com uma das seguintes opções: 
    1=Sem Ação
    2=Subtrai somente do total da nota
    3=Subtrai do total da nota e da duplicata
    4=Subtrai somente do total da duplicata
    5=Soma somente no total da nota
    6=Soma no total da nota e da duplicata
    7=Soma somente no total da duplicata
    8=Gross up no total da duplicata
    
    Param @aTaxesToSearch (Opcional) : string com qual tributo (Id TOTVS) se deve buscar ...

    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2510
    @return atributo classe TCIWritten
/*/
Method getAgregTypeByTax( cAgregTypesToSearch as character , cIdTotvsToSearch as character ) as character Class TCIWritten
    
    Local jTaxesData as json
    Local cErrorMsg as character 
    Local jTemp as json
    Default cAgregTypesToSearch := ''
    Default cIdTotvsToSearch := ''

    If !Empty( cAgregTypesToSearch ) // Validacao caso tenha sido informado um tipo de incidencia, verifica se esse tipo é válido ...
        
        If Empty( self:aAgregTypes )
            self:setAgregTypes() 
        EndIf
        
        cErrorMsg := self:validAgregParams( cAgregTypesToSearch )

        if( !empty(cErrorMsg) )            
            return self:setErrorOnAgreg(cErrorMsg)
        endif

    Endif

    If self:jRequestResponse:hasProperty('dados_Id') .and. !Empty( self:jRequestResponse["dados_Id"]:GetNames() ) // Valida se existe os dados necessarios para realizar a busca ...
       jTaxesData := self:jRequestResponse["dados_Id"]       
    Else // Forcar o GetDataId para ter os dados necessarios ...
        jTemp := JsonObject():New()
        jTemp:FromJson( self:GetDataId() )
        
        If !jTemp:hasProperty('dados_Id') .or. ( jTemp:hasProperty('dados_Id') .and. Empty( self:jRequestResponse["dados_Id"]:GetNames() ) )
            FreeObj(jTemp)
            return self:setErrorOnAgreg("Não encontrado dados de nenhum tributo (atributo 'dados_Id' não encontrado ou está vazio)")
        else
            jTaxesData := jTemp['dados_Id']
        EndIf

    EndIf

    self:searchAgregInJSON( jTaxesData , cAgregTypesToSearch , cIdTotvsToSearch )

    If !self:jRequestAgregResponse:hasProperty("data") 
        return self:setErrorOnAgreg("Nenhum registro encontrado com base nos parâmetros informados na getAgregTypeByTax()")
    Endif

return self:jRequestAgregResponse:toJson()

/*/{Protheus.doc} setErrorOnAgreg()
    
    Método para validar parametro(s) da getAgregTypeByTax()
    
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIWritten
/*/
Method setErrorOnAgreg( cErrorMsg as character ) as character Class TCIWritten
    self:setError()
    self:setMessageError( "erro - " + cErrorMsg )
    self:jRequestAgregResponse['erro'] := self:getMessageError()        
Return self:jRequestAgregResponse:ToJson()

/*/{Protheus.doc} validAgregParams
    
    Método para validar parametro(s) da getAgregTypeByTax()
    
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIWritten
/*/
Method validAgregParams( cAgregTypeToSearch as character ) as character Class TCIWritten
    Local cRet as character
    Local cToSearch as character

    cToSearch := (cAgregTypeToSearch + "=")

    If Ascan( self:aAgregTypes ,{|x| cToSearch $ x }) == 0
        cRet := "Necessário informar um tipo de 'incidencia no total da nf' válido como parâmetro no método getAgregTypeByTax(). " + self:cAgregTypes    
    endif 

return cRet

/*/{Protheus.doc} SearchAgregInJSON
    
    Método para procurar no objeto a incidencia/id totvs passados por parametro no getAgregTypeByTax()
    
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIWritten
/*/
Method searchAgregInJSON(jTaxesData as json, cAgregTypesToSearch as character , cIdTotvsToSearch as character ) Class TCIWritten
    Local nX as numeric    
    Local nZ as numeric
    Local aTaxesInReg as array
    Local aDocuments as array
    Local cIdTotvs as character    
    Local cTypeAgreg as character
    Local jItem as json
    Local jTax as json
    Local lHasAgregTypeToSearch as logical
    Local lHasTaxToSearch as logical

    lHasAgregTypeToSearch := !Empty( cAgregTypesToSearch )    
    lHasTaxToSearch       := !Empty( cIdTotvsToSearch )
    aDocuments := jTaxesData:GetNames()
        
    For nZ := 1 to len(aDocuments) 
        
        jItem := jTaxesData:GetJsonObject(aDocuments[nZ])
        aTaxesInReg := jItem:GetNames() 
        
        For nX := 1 to len(aTaxesInReg) 

            If aTaxesInReg[nX] == "Aviso" // Informado um id que não é calculado pelo configurador de tributos ...
                Loop
            EndIf

            jTax := jItem:GetJsonObject(aTaxesInReg[nX])
            cIdTotvs := jTax:GetJsonText('codigo_tributo_relacionado')

            If self:hasBook( jTax ) .and. self:hasTaxToSearch( lHasTaxToSearch , cIdTotvsToSearch , cIdTotvs )

                cTypeAgreg := self:searchIncidences( jTax )
                
                If self:hasIncidenceToSearch( lHasAgregTypeToSearch , cAgregTypesToSearch , cTypeAgreg )
                    self:AddAgregTypeJSON( cIdTotvs , aDocuments[nZ] , cTypeAgreg , aTaxesInReg[nX] )
                endif
                
            Endif
        Next nX
    Next nZ

    aSize(aDocuments, 0)
    aDocuments  := nil
    aSize(aTaxesInReg, 0)
    aTaxesInReg  := nil

Return

/*/{Protheus.doc} haveBook
    Método para determinar se tributo possui regra de escrituracao 
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIWritten
/*/
Method hasBook( jTaxData as json ) as logical Class TCIWritten
Return jTaxData:hasProperty('regras_escrituracao')

/*/{Protheus.doc} hasTaxToSearch
    Método para determinar se tributo possui busca por IdTotvs, e se o Id Totvs é o procurado 
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIWritten
/*/
Method hasTaxToSearch( lHasTaxToSearch as logical , cIdTotvsToSearch as character , cIdTotvs as character ) as logical Class TCIWritten
Return ( !lHasTaxToSearch .or. ( lHasTaxToSearch .and. cIdTotvsToSearch  == cIdTotvs ) )

/*/{Protheus.doc} hasIncidenceToSearch
    Método para determinar se tributo possui busca por Incidencia, e se a Incidencia é a procurada
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIWritten
/*/
Method hasIncidenceToSearch( lHasAgregTypeToSearch as logical , cAgregTypesToSearch as character , cTypeAgreg as character ) as logical Class TCIWritten
Return ( (!lHasAgregTypeToSearch) .or. ( lHasAgregTypeToSearch .and. cAgregTypesToSearch == cTypeAgreg ) )

/*/{Protheus.doc} searchIncidences
    
    Método para buscar/retornar a incidencia no total da NF em determinado JSON

    @jTaxData : json - Contem os dados da regra de escrituracao de determinado tributo ...
    
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIWritten
/*/
Method searchIncidences( jTaxData as json ) as character Class TCIWritten
    Local cType as character 

    // Na TCIWritten, caso não tenha regra de escrituracao de determinado tributo, o atributo regras_escrituracao vem como string, contendo "Nao encontrado regra de escrituracao"    
    If (valtype( jTaxData['regras_escrituracao'] ) == 'J') .and. jTaxData['regras_escrituracao']:hasProperty('acao_total_nf')
        cType := jTaxData['regras_escrituracao']:GetJsonText('acao_total_nf')
    endif

Return cType

/*/{Protheus.doc} AddAgregTypeJSON
    
    Método para alimentar objeto de resposta do getAgregTypeByTax()
    
    @author Douglas Dourado
    @since 19/02/2025
    @version 12.1.2410
    @return atributo classe TCIWritten
/*/
Method addAgregTypeJSON( cIdTotvs as character , cNumItem as character , cTypeAgreg as character , cTax as character  ) Class TCIWritten
Local cAtrib := "data"

    If !self:jRequestAgregResponse:hasProperty(cAtrib)                        
        self:jRequestAgregResponse[ cAtrib ] := JsonObject():New()
    EndIf

    If ! self:jRequestAgregResponse[ cAtrib ]:hasProperty(cNumItem)                        
        self:jRequestAgregResponse[ cAtrib ][ cNumItem ] := JsonObject():New()        
    EndIf

    self:jRequestAgregResponse[ cAtrib ][ cNumItem ][ cTax ] := JsonObject():New()
    self:jRequestAgregResponse[ cAtrib ][ cNumItem ][ cTax ][ 'acao_tot_nf' ] := cTypeAgreg
    self:jRequestAgregResponse[ cAtrib ][ cNumItem ][ cTax ][ 'id_totvs' ] := cIdTotvs
Return

/*/{Protheus.doc} setAgregTypes
    
    Método para setar quais os tipos válidos de "incidencia no total da NF" (CJ2_STONF), dados seram utilizados na validAgregParams()
    
    @author Douglas Dourado
    @since 25/02/2025
    @version 12.1.2410
    @return atributo classe TCIWritten
/*/
Method setAgregTypes() Class TCIWritten    

    self:cAgregTypes := x160JTotDp() // Armazenado para utilizar em possivel mensagem de erro caso tipo seja inválido ...
    self:aAgregTypes := StrTokArr(self:cAgregTypes , ";")        

Return

/*/{Protheus.doc} getAdditionalData()
    Método para retornar os dados adicionais do configurador de tributos
    @author Rhuan Carvalho
    @since 23/05/2025
    @version 12.1.2510

    /*/
Method getAdditionalData() class TCIWritten
    Local oAddData := TCAdditionalData():New()
    Local cReturn as character
    
    oAddData:setDataMode("Written")
    oAddData:setId(self:aIdRequest)
    cReturn := oAddData:getAdditionalData()

    oAddData:destroy()
    
Return cReturn



/*/{Protheus.doc} validateSX3Exists
    
    Metodo para fazer validacao e fazer cache de campos existente da base
    
    @param nil, nil, nao ha
    @return jCacheSX3, json, cache com os json
    @type Method
    @author Matheus Bispo
    @since 02/07/2025
    @version 12.1.2410
/*/
Method validateSX3Exists() Class TCIWritten
    Local jCacheSX3 := self:jCacheSX3 as json
    Local aCampos := {} as array
    Local nTamCampos := 0 as numeric
    Local nI := 0 as numeric

    if jCacheSX3 == nil
        jCacheSX3 := JsonObject():New()

        aCampos := { {"12.1.2510", "F28", "F28_REDALI"} ,;
                     {"12.1.2510", "CJ2", "CJ2_CCT"}    ,;
                     {"12.1.2510", "CJ2", "CJ2_CSTCCT"} ,;
                     {"12.1.2510", "CJ3", "CJ3_PREDAL"} ,;
                     {"12.1.2510", "CJ3", "CJ3_ALIQOR"} ,;
                     {"12.1.2510", "CJ3", "CJ3_CCT"}     ;
                    }

        nTamCampos := len(aCampos)

        for nI := 1 to nTamCampos
            jCacheSX3[aCampos[nI][3]] := fisExtCmp(aCampos[nI][1], .T., aCampos[nI][2], aCampos[nI][3])
        next

        fwFreeArray(aCampos)
    endIf

Return jCacheSX3

/*/{Protheus.doc} destroy()
    
    Método que limpa os dados da classe

    @author Rhuan E.A. Carvalho
    @since 27/03/2024
    @version 12.1.2410
    @return Objeto da classe TCIWritten    
/*/
Method destroy() class TCIWritten
	
    aSize(self:aIdRequest, 0)    
    self:aIdRequest := nil

	aSize(self:aSearchList, 0)
    self:aSearchList := nil

	aSize(self:aRegra, 0)
    self:aRegra := nil

	aSize(self:aErrorItens, 0)
    self:aErrorItens := nil

    aSize(self:aIdTotvsFilterList, 0)
    self:aIdTotvsFilterList := nil

    aSize(self:aTaxRuleFilterList, 0)
    self:aTaxRuleFilterList := nil

    aSize(self:aAdditionalFieldsToReturn, 0)    
    self:aAdditionalFieldsToReturn := nil

    aSize(self:aAgregTypes, 0)
    self:aAgregTypes  := nil
    
    FreeObj(self:jRequestResponse)
    self:jRequestResponse   := nil

    FreeObj(self:jCache)
    self:jCache             := nil

    FreeObj(self:jRequestAgregResponse)
    self:jRequestAgregResponse := nil

    FreeObj(self:jResponseResume)
    self:jResponseResume := nil
return
