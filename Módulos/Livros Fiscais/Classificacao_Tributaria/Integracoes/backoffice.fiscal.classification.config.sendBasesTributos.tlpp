#Include "FwMvcDef.ch"
#include 'tlpp-core.th'
#include 'tlpp-rest.th'
#include 'classificadorfiscal.ch'

static jBasesCache := JsonObject():New()
Static jFormulasCache := JsonObject():New()

Namespace totvs.protheus.backoffice.fiscal.Classifier
using Namespace totvs.protheus.backoffice.fiscal.lib

//-------------------------------------------------------------------
/*/{Protheus.doc} FISGravaBase
Classe que contém as operações para gravar a base de calculo vinda 
da regra da Systax
@author  Erich buttner
@since   09.06.2022
@version 1.0
/*/
//-------------------------------------------------------------------
CLASS FISGravaBase

    data setcod as character
    data username as character
    data senha as character
    data url as character

    data rest_client as object
    data rToken as character
    data error as numeric
    data error_description as character
    data JSONResult as json
    data cIdCenario as character
    data cCodProd as character
    data nOriProd as numeric
    data cPontAtu as character
    data nBaseComp as numeric
    data jRet as json
    data oJsonRetor as object
    data cCJECod as character
    data oStatementBase as object

    public data aBases as array
 
    Public METHOD New() CONSTRUCTOR
    Public METHOD FisDeParaFormula()
    Public METHOD FISGetDados(oJsonBase,lIPI,cTribIpi,aRegrAliq,cMockServer)
    Public METHOD FISGetFormulaBase(nBaseComp)
    Public METHOD FISGravaBase(cCodBase,cDesc,cVlOrig,nPcRed,cFormula)
    Public METHOD gravaDadosjson(cJsonBase)
    Public METHOD descricaoBase(cBaseCalc)
    Public METHOD aJustaFormulaIPI(lExistIPI, cCodeTaxIPI, cDescricao, cFormula)
    Public METHOD aJustaFormulaReducao(cDescricao, cFormula, nPcRed, jTaxSystax)
    Public METHOD ExcluiRegraDeBase() as logical
    Public method GetJsonFieldsForQuery() as character

    METHOD AtuCJE(cCJECod)
    Method atuCodigoCJE(regra, nOpc, cCod) 
    METHOD FISGravaIPI(cJsonBase)
    METHOD setcod(setcod)
    METHOD setSenha(senha)
    METHOD setUrl(url)
    METHOD setUserName(username)


END CLASS

//-------------------------------------------------------------------
/*/{Protheus.doc} New()
Método construtor da classe
@author  Erich Buttner
@since   09.06.2022
@version 1.0
/*/
//-------------------------------------------------------------------
METHOD New() CLASS FISGravaBase

Local aParam := {"CODREGBASE","URLPRINCIPAL","USERNAMEDEFAULT","SENHADEFAULT"}
Local cParametro := GetConfigClassif(aParam)
Local oParametro := JsonObject():New()

If oParametro:FromJson(cParametro) == Nil

    ::setcod(oParametro:CODREGBASE)
    ::seturl(oParametro:URLPRINCIPAL)
    ::setSenha(oParametro:SENHADEFAULT)
    ::setUserName(oParametro:USERNAMEDEFAULT)

    FreeObj(oParametro)

    FWFreeArray(aParam)

EndIf

self:aBases := {}

Return

//-----------------------------------------------------------------
 /*/{Protheus.doc} FISGetDados()
Método para obter os dados dos impostos no Json
@author 	Erich Buttner
@since 		09.06.2022
@version 	1.0
/*/
//-----------------------------------------------------------------
METHOD FISGetDados(oJsonBase,lIPI,cTribIpi,aRegrAliq,cMockServer) CLASS FISGravaBase

    Local nE            as integer
    Local nEB           as integer
    Local nEC           as integer
    Local cDesc         as character
    Local cVlOrig       as character
    Local cDescricao    as character
    Local aJson         := {}
    Local aBsRet        := {}
    Local cStrJson      as character
    Local cCodBase      as character
    Local oFormula      as object
    Local nPcRed        := 0
    Local aJsonRet      := {}
    Local lIpi          as logical
    Local nBaseComp     as integer
    Local cFormula      as character
    Local cTributo      as character
    Local jTaxSystax    as json
    Local cVldUnTrib    as character

    Default lIPI        := .F.
    Default cTribIpi    := ""
    Default aRegrAliq   := {}
    Default cMockServer := ""

    BEGIN TRANSACTION

    For nEB := 1 to Len(oJsonBase["cenario"])

        For nEC := 1 to Len(oJsonBase["cenario"][nEB]["retorno"])

            aJson := oJsonBase["cenario"][nEB]["retorno"][nEC]:GetNames()

            For nE := 1 to Len(aJson)                

                cStrJson := aJson[nE]

                If lIPI
                    If ( cStrJson != "ipi" )
                        loop
                    EndIf
                EndIf

                If ValType(oJsonBase["cenario"][nEB]["retorno"][nEC][cStrJson]) == "J"

                    If oJsonBase["cenario"][nEB]["retorno"][nEC][cStrJson]:hasProperty("bc_composicao")

                        //cDesc       := upper(cStrJson) + " - " + ALLTRIM(str(val(oJsonBase["cenario"][nEB]["retorno"][nEC][cStrJson]["aliquota"]),5,2)+"%")

                        nBaseComp   := oJsonBase["cenario"][nEB]["retorno"][nEC][cStrJson]["bc_composicao"]
                        //cDesc := 'Base de calculo Systax: ' + cValtochar(nBaseComp)
                        cTributo    := cStrJson

                        if ( nBaseComp > 0 )
                            oFormula := ::FISGetFormulaBase(nBaseComp,cTributo,cMockServer)

                            If ValType(oFormula) == "J"

                                If ValType(oFormula["bcComposicao"]) <> "U"

                                    cDescricao := DECODEUTF8(oFormula["bcComposicao"][1]["descricao"], "CP1252")
                                    
                                    If ("Pauta IPI" $ oFormula["bcComposicao"][1]["descricao"]) .OR. ("IMPORTACAO" $ UPPER(NoAcento(cDescricao)))
                                        cFormula := oFormula["bcComposicao"][1]["formulaTributo"]
                                        If oFormula["bcComposicao"][1]["indicador"] == "42" .AND. oJsonBase["cenario"][nEB]["retorno"][nEC][cStrJson]:hasProperty("valor_unid_trib")
                                            cVldUnTrib := oJsonBase["cenario"][nEB]["retorno"][nEC][cStrJson]["valor_unid_trib"]
                                        EndIf
                                    Else
                                        cFormula := oFormula["bcComposicao"][1]["formulaBC"]
                                    EndIf
                                
                                ElseIf ValType(oFormula["indicadorCredito"]) <> "U"

                                    cFormula := oFormula["indicadorCredito"][1]["formulaBC"]
                                
                                EndIf

                                cFormula := ::FisDeParaFormula(cFormula,nBaseComp,cVldUnTrib)

                                FreeObj(oFormula)

                            EndIf                            
                        else
                            cFormula := 'O:ZERO'
                        endif

                        If !Empty(cFormula)
                            jTaxSystax := oJsonBase["cenario"][nEB]["retorno"][nEC][cStrJson]
                            cVlOrig := "11"
                            cDesc    := Self:descricaoBase(cValtochar(nBaseComp))
                            cFormula := Self:aJustaFormulaIPI(!lIPI, cTribIpi, @cDesc, cFormula )
                            cFormula := self:aJustaFormulaReducao(@cDesc, cFormula, @nPcRed, jTaxSystax)
                            
                            cCodBase := "BAS"+AllTrim(::setcod)                                                                                                
                            aBsRet := ::FISGravaBase(@cCodBase,cDesc,cVlOrig,nPcRed,cFormula)

                            If aBsRet[1]
                                        
                                aadd(aJsonRet,{cStrJson,upper(cCodBase)})

                                If aBsRet[2]
                                    ::setcod := ::AtuCJE(AllTrim(::setcod))
                                EndIF
                    
                            EndIf

                            FWFreeArray(aBsRet)
                        
                        EndIf
                    
                    EndIf

                EndIF
                
            Next nE

            FWFreeArray(aJson)

        Next nEC

    Next nEB

    END TRANSACTION

Return aJsonRet

/*/{Protheus.doc} aJustaFormula
    
    Ajusta a formula da base de calculo para que seja possível gravar no configurador de tributos
    Ajusta a descrição da base de calculo para evitar duplicidade de regras com descrições diferentes

    @author Rafael Oliveira
    @since 22/12/2023
    @version 12.1.2310
    @param lExistIPI, logical, Indica se existe tributo IPI
    @param cCodeTaxIPI, character, Código do tributo IPI
    @param cDescricao, character, Descrição da base de calculo
    @param cFormula, character, Formula da base de calculo        
    @return cFormula, character, Formula da base de calculo ajustada    
    /*/
Method aJustaFormulaIPI(lExistIPI, cCodeTaxIPI, cDescricao, cFormula) CLASS FISGravaBase

    If lExistIPI .and. !Empty(cCodeTaxIPI)

        cCodeTaxIPI := AllTrim(upper(cCodeTaxIPI))
        
        //If AT("- TRIBIPI",cFormula) > 0
        //    cDescricao := cDescricao + " com subtracao de IPI (" + cCodeTaxIPI + ")"
        //Else
        if AT("+ TRIBIPI",cFormula) > 0
            cDescricao := cDescricao + " com adicao de IPI (" + cCodeTaxIPI + ")"
        Endif
        
        cFormula := STRTRAN(cFormula,"TRIBIPI","VAL:"+cCodeTaxIPI)        
    Else
        //Caso não exista tributo IPI, será necessário remover o tributo IPI da fórmula
        cFormula := STRTRAN(cFormula,"+ TRIBIPI","")
        cFormula := STRTRAN(cFormula,"- TRIBIPI","")
        
    Endif
    
    
Return cFormula

/*/{Protheus.doc} aJustaFormulaReducao
    
     Ajusta a formula da base de calculo para que seja possível gravar no configurador de tributos
    Ajusta a descrição da base de calculo para evitar duplicidade de regras com descrições diferentes

    @author Rafael Oliveira
    @since 22/12/2023
    @version 12.1.2310
    @param cDescricao, character, Descrição da base de calculo
    @param cFormula, character, Formula da base de calculo
    @param nPcRed, numeric, Percentual de redução da base de calculo
    @param jTaxSystax, json, Json com os dados da base de calculo
    @return cFormula, character, Formula da base de calculo ajustada
    /*/
Method aJustaFormulaReducao(cDescricao, cFormula, nPcRed, jTaxSystax) CLASS FISGravaBase
    Local cPerred as character
    Local nPerred as numeric

    If jTaxSystax:hasproperty('p_red_bc')
        cPerred := jTaxSystax["p_red_bc"]
    Elseif  jTaxSystax:hasproperty('p_red_bc_st')
        cPerred := jTaxSystax["p_red_bc_st"]
    Endif

    nPerred := Val(cPerred)

    If nPerred > 0
        //cDesc   := upper(cStrJson) + " - " + ALLTRIM(str(val(oJsonBase["cenario"][nEB]["retorno"][nEC][cStrJson]["aliquota"]),5,2)+"%") + " - " + ALLTRIM(str(Val(oJsonBase["cenario"][nEB]["retorno"][nEC][cStrJson]["p_red_bc"]),5,2)+"%") + " REDUCAO"
        cDescricao   := cDescricao + ' - ' + ALLTRIM(str(nPerred,6,2)+"%") + " de reducao de base de calculo"
        nPcRed  := nPerred
    Else
        nPcRed   := 0
        cFormula := STRTRAN(cFormula," * (1 - (I:PERC_REDUCAO_BASE / 100))","")
        cFormula := STRTRAN(cFormula," * (1 - (pRedIPI / 100))","")
        cFormula := STRTRAN(cFormula," * (I:PERC_REDUCAO_BASE)","")
    EndIf

Return cFormula

/*/{Protheus.doc} descricaoBase
    
    Ajusta a descrição da base de calculo para evitar duplicidade de regras com descrições diferentes

    @author Rafael
    @since 22/12/2023
    @version 12.1.2310
    @param cBaseCalc, character, identificador da base de calculo systax
    @param cDescricao, character, Descrição da base de calculo atualizada
    /*/
Method descricaoBase(cBaseCalc) CLASS FISGravaBase
    cDescricao := 'Base de calculo Systax: ' + cBaseCalc
Return cDescricao

//-----------------------------------------------------------------
 /*/{Protheus.doc} FISGravaBase()
Método para gravar a base de calculo no configurador de tributos
@author 	Erich Buttner
@since 		09.06.2022
@version 	1.0
/*/
//-----------------------------------------------------------------
METHOD FISGravaBase(cCodBase,cDesc,cVlOrig,nPcRed,cFormula) CLASS FISGravaBase

Local oModel	            as object
Local lExist                as Logical
Local aBsRet                := {}
Local cTpRed                := '1'
Local cChaveMD5             as character
Local oMd5Classification    as object
Local jMd5Find              as json
Local jChave                as json
Local aErro                 := {} as array
Local jBase                 as json

Default cDesc       := '' 
Default cVlOrig     := '04'
Default nPcRed      := 0
Default cFormula    := ""

oModel := FWLoadModel('FISA161')
oModel:SetOperation(MODEL_OPERATION_INSERT)
oModel:Activate()

oModel:SetValue('FISA161','F27_CODIGO', cCodBase)
oModel:SetValue('FISA161','F27_DESC'  , cDesc)
oModel:SetValue('FISA161','F27_VALORI', cVlOrig)

if !( nPcRed > 0 .and. cVlOrig != "11" )
    cTpRed := ''
endif    

If nPcRed > 0
    oModel:SetValue('FISA161','F27_REDBAS', nPcRed)   
    oModel:SetValue('FISA161','F27_TPRED' , cTpRed)   
Endif

//Realizado Preenchimento da formula
if cVlOrig == "11" .and. !Empty(cFormula)
    If nPcRed > 0
        oModel:SetValue('FISA161','F27_REDBAS', nPcRed)
    Endif
    Fsa161Form(cFormula)
Endif

jChave := JsonObject():New()
jChave['CIN_FNPI'] := xFisSYard(oModel:GetValue('FORMULBAS', 'CIN_FORMUL'))

jMd5Find := JsonObject():New()
jMd5Find['cache'] := jBasesCache
jMd5Find['table'] := 'F27'
jMd5Find['index'] := 6
jMd5Find['codeField'] := 'F27_CODIGO'
jMd5Find['key'] := jChave
jMd5Find['ruleTypes'] := '1'

oMd5Classification := Md5Classification():New()
oMd5Classification:Find(jMd5Find)
lExist := oMd5Classification:GetFound()
cChaveMD5 := oMd5Classification:GetMd5Key()

if ( lExist )
    cCodBase := oMd5Classification:GetCode()
endif

aBsRet := { lExist, .F., {} }

if ( !lExist )
    If oModel:Activate()
        If oModel:VldData()
            oModel:CommitData()
            oModel:DeActivate()
            aBsRet[1] := .T.
            aBsRet[2] := .T.
            aBsRet[3] := {}
        Else
            aErro := oModel:GetErrorMessage()

            aBsRet[1] := .F.
            aBsRet[2] := .F.
            aBsRet[3] := {}
            aadd(aBsRet[3],oModel:aErrorMessage[1]+"-"+oModel:aErrorMessage[2]+"-"+oModel:aErrorMessage[3]+"-"+oModel:aErrorMessage[4]+"-"+oModel:aErrorMessage[5]+"-"+oModel:aErrorMessage[6])
        EndIf
    EndIf
else
    AADD(aBsRet[3],cCodBase)
endif

oModel:DeActivate()
oModel:Destroy()		
FwFreevar( oModel )

oMd5Classification:Destroy()
FwFreevar(oMd5Classification)
FwFreevar(jMd5Find)
FwFreevar(jChave)

if ( aBsRet[1] )
    jBasesCache[cChaveMD5] := cCodBase
endif

jBase := JsonObject():New()
jBase['codigo'] := cCodBase
jBase['incluido'] := aBsRet[2]
jBase['md5'] := cChaveMD5

if ( Len(aErro) > 0 )
    jBase['erro'] := JsonObject():New()
    jBase['erro']['formularioDeOrigem'] := AllToChar(aErro[1]) 
    jBase['erro']['campoDeOrigem'] := AllToChar(aErro[2])
    jBase['erro']['formularioDeErro'] := AllToChar(aErro[3])
    jBase['erro']['campoDeErro'] := AllToChar(aErro[4])
    jBase['erro']['erro'] := AllToChar(aErro[5])
    jBase['erro']['mensagemDoErro'] := AllToChar(aErro[6])
    jBase['erro']['mensagemDaSolucao'] := AllToChar(aErro[7])
    jBase['erro']['valorAtribuido'] := AllToChar(aErro[8])
    jBase['erro']['valorAnterior'] := AllToChar(aErro[9])
endif

Aadd(self:aBases, jBase)

ASize(aErro, 0)

Return aBsRet

//-----------------------------------------------------------------
 /*/{Protheus.doc} FISGetFormulaBase
Método para buscar a formula da base de calculo
@author 	Erich Buttner
@since 		09.06.2022
@version 	1.0
/*/
//-----------------------------------------------------------------
METHOD FISGetFormulaBase(nBaseComp, cTributo, cMockServer, cPathAliqZero) CLASS FISGravaBase

    Local oFormula      as object
    Local aHeaderForm   := {} as array
    Local oResult       as object
    Local jBodyForm     as object
    Local cResult       as character
    Local lRet          as logical
    local oQuery        as object
    local cQuery        as character
    Local cAlsQry       as character
    Local cJsonFields   as character
    Local cDB           as character
    Local lExistCJJ     as logical
    Local aBind         := {} as array
    Local lAPI          := .T. as logical
    local nMaxLen       := 8000

    Default cMockServer     := ""
    Default cPathAliqZero   := ""

    cDB     := Upper(TCGetDB())
    cChave  := (cTributo + "_" + cValToChar(nBaseComp))
    lExistCJJ  := AliasIndic("CJJ")

    //Se a formula já foi consultada, retorna o valor do cache
    If !jFormulasCache:hasProperty(cChave)	

        If Empty(cMockServer)
            ::rest_client := FwRest():New(::url)
            ::rest_client:setPath("/api/formulas")
        Else
            ::rest_client := FwRest():New(cMockServer)

            If ( !Empty(cPathAliqZero) )
                ::rest_client:setPath(cPathAliqZero)
            Else
                ::rest_client:setPath("/GetFormulBase")
            EndIf
        EndIf
        
        //Verifica se a formula já foi consultada anteriormente e armazenada no DB
        if ( lExistCJJ )
            DbSelectArea("CJJ")
            //Instanciamento da classe de query
            oQuery := FisQuery():New()
            
            cQuery := "SELECT CJJ_FTRIBU, CJJ_FBASEC, "
            cJsonFields := self:GetJsonFieldsForQuery(cDB)
            cQuery += ' ? '
            cQuery += " FROM " + RetSQLName("CJJ") + " CJJ"
            cQuery += " WHERE  CJJ_FILIAL = ? "
            cQuery += " AND CJJ_FTRIBU = ? "
            cQuery += " AND CJJ_FBASEC = ? "
            cQuery += " AND CJJ.D_E_L_E_T_ = ? "

            aBind := {}
            aAdd(aBind, {"U", cJsonFields})
            aAdd(aBind, {"C", FWxFilial("CJJ")}) //CJJ_FILIAL
            aAdd(aBind, {"C", cTributo}) //CJJ_FTRIBU
            aAdd(aBind, {"C", cValToChar(nBaseComp)}) //CJJ_FBASEC
            aAdd(aBind, {"C", " "}) //D_E_L_E_T_

            oQuery:SetQuery(cQuery)
            oQuery:SetBind(aBind)

            cAlsQry := oQuery:executeQuery()

            if ( !(cAlsQry)->(Eof()) )
                cResult := AllTrim((cAlsQry)->CJJ_JFORMU)
                jFormulasCache[cChave] := cResult

                oResult := JsonObject():New()
                If oResult:FromJson(cResult)  == Nil
                    oFormula := oResult:GetJsonObject("formulas")
                EndIf
                
                FwFreevar(oResult)
                lAPI    := .F.
            EndIf
            CJJ->(DbCloseArea())
        EndIf
        
        If lAPI
            //Dispara verificacao atraves de API
            ::rToken := AllTrim(ConsultTok(cUserName,cMockServer))
            If ValType(::rToken) <> 'U'

                jBodyForm := JsonObject():New()
                
                jBodyForm["idCliente"] := ""

                jBodyForm["tributo"] := cTributo

                jBodyForm["FormulaEspecifica"] := JsonObject():New()
                jBodyForm["FormulaEspecifica"]["bcComposicao"]      :=  cValToChar(nBaseComp)
                jBodyForm["FormulaEspecifica"]["indicadorCredito"]  := 0
                jBodyForm["FormulaEspecifica"]["tipoAntecipacao"]   := ""
                jBodyForm["FormulaEspecifica"]["bcComposicaoFCPAntecipacao"] := ""
                
                AAdd(aHeaderForm, "Content-Type: application/json; charset=UTF-8") 
                AAdd(aHeaderForm, "Content-Length: <calculated when request is sent>") 
                AAdd(aHeaderForm, "Accept: */*") 
                AAdd(aHeaderForm, "User-Agent: Chrome/65.0 (compatible; Protheus " + GetBuild() + ")") 
                Aadd(aHeaderForm, "Authorization: Bearer " + ::rToken)

                ::rest_client:SetPostParams(jBodyForm:toJson())

                lRet := ::rest_client:Post( aHeaderForm )

                //Adiciona a formula encontrada ao cache
                If lRet

                    cResult := ::rest_client:GetResult()

                    cResult := DecodeUTF8(substr(cResult,2,Len(cresult)-2), 'cp1252')

                    oResult := JsonObject():New()

                    If oResult:FromJson(cResult)  == Nil
                        
                        jFormulasCache[cChave] := cResult
                        oFormula := oResult:GetJsonObject("formulas")

                        If Len(cResult) <= nMaxLen
                            //Gravo o registro na tabela CJJ se tiver menos do que 8 mil caracteres
                            If lExistCJJ .AND. !CJJ->( MsSeek( FWxFilial("CJJ") + cTributo + cValToChar(nBaseComp) ) ) //CJJ_FILIAL+CJJ_FTRIBU+CJJ_FBASEC
                                RecLock( "CJJ", .T. )

                                CJJ->CJJ_FILIAL := FWxFilial("CJJ")
                                CJJ->CJJ_FTRIBU := cTributo
                                CJJ->CJJ_FBASEC := cValToChar(nBaseComp)
                                CJJ->CJJ_JFORMU := cResult

                                CJJ->( MsUnLock() )
                            EndIf
                        EndIf
                    EndIf
                FreeObj(jBodyForm)
                FWFreeArray(aHeaderForm)
                EndIf
            EndIf
            FreeObj(oResult)
        EndIf
    Else
        oResult := JsonObject():New()
        cResult := jFormulasCache[cChave]

        If oResult:FromJson(cResult)  == Nil            

            oFormula := oResult:GetJsonObject("formulas")

            FwFreevar(oResult)

        EndIf

    EndIf

Return oFormula


/*/{Protheus.doc} GetJsonFieldsForQuery
Método responsável por obter os campos json convertidos para utilização na query
@author Thiago Moreira
@since 10/05/2025
@version 12.1.2510
@param cDbType, character, Tipo do banco de dados em que o sistema está sendo executado
@return cQry, character, Campos json convertidos para utilização na query
/*/
method GetJsonFieldsForQuery(cDbType as character) as character class FISGravaBase

    local cQry as character 

    if ( "ORACLE" $ cDbType )
        cQry += " UTL_RAW.CAST_TO_VARCHAR2(DBMS_LOB.SUBSTR(CJJ_JFORMU, 4000,1)) CJJ_JFORMU "  
    elseif ( "POSTGRES" $ cDbType )
        cQry += " encode(CJJ_JFORMU,'escape') CJJ_JFORMU "
    else
        cQry += " ISNULL(CAST(CAST(CJJ_JFORMU AS VARBINARY(8000)) AS VARCHAR(8000)),'') AS [CJJ_JFORMU] "   
    endif 

return cQry

//-------------------------------------------------------------------
/*/{Protheus.doc} setUserName
Método para passar o nome do usuário que irá utilizar a api.
@author  Erich Buttner
@since   16.03.2022
@version 1.0
/*/
//-------------------------------------------------------------------
Method setUserName(username) Class FISGravaBase

    Self:username := username

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} setSenha
Método para passar a senha do usuário que irá utilizar a api.
@author  Erich Buttner
@since   16.03.2022
@version 1.0
/*/
//-------------------------------------------------------------------
Method setSenha(senha) Class FISGravaBase

    Self:senha := senha

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} setUrl
Método para passar a senha do usuário que irá utilizar a api.
@author  Erich Buttner
@since   16.03.2022
@version 1.0
/*/
//-------------------------------------------------------------------
Method setUrl(Url) Class FISGravaBase

    Self:Url := Url

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} setcod
Método para passar o código da regra de base do configurador.
@author  Erich Buttner
@since   22.06.2022
@version 1.0
/*/
//-------------------------------------------------------------------
Method setcod(setcod) Class FISGravaBase

    Self:setcod := setcod

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} FisDeParaFormula
Método para efetuar o De/Para da formula da base de calculo
@author  Erich Buttner
@since   11.06.2022
@version 1.0
@param cFormula, character, Formula que será convertida
@param nBaseComp, character, Base de cálculo que será utilizada na conversão
@param cVldUnTrib, character, Valor unitário do tributo que será utilizado na conversão
@return cQry, character, Campos json convertidos para utilização na query
/*/
//-------------------------------------------------------------------
Method FisDeParaFormula(cFormula, nBaseComp, cVldUnTrib) Class FISGravaBase

Local oConvert as object

Default nBaseComp   := 0
Default cVldUnTrib  := ""
Default cFormula    := ""

//VBC -> Base de cálculo de qualquer tributo
//VBCST -> ICMS-ST
//VIPI -> IPI Pauta

cFormula := DECODEUTF8(cFormula, "CP1252")
cFormula := Upper(cFormula)

DO CASE
    Case nBaseComp == 42
        cFormula := StrTran(cFormula,"QUNID","QUNID" + " * " + cVldUnTrib) 
ENDCASE

If "VBC =" $ cFormula .or. "VBCST =" $ cFormula .or. "VIPI =" $ cFormula .or. "VBC=" $ cFormula

    cFormula := StrTran(cFormula,"VBC = ","")
    cFormula := StrTran(cFormula,"VBC=","")
    cFormula := StrTran(cFormula,"VBCST =","")
    cFormula := StrTran(cFormula,"TRIBIPI = ","")

    oConvert := ConvertFormula():new()
    cFormula := oConvert:convert(cFormula)
    
    oConvert:destroy()
    FwFreevar("oConvert")

    /*cQry += "SELECT CJE_PARAM, CJE_CONTEU FROM "+ RetSqlName("CJE") +" CJE "
    cQry += "WHERE CJE.CJE_FILIAL = ? "
    cQry += "AND CJE.CJE_TIPO = ? "
    cQry += "AND CJE.D_E_L_E_T_ = ' ' "

    oStatement := FwExecStatement():New( ChangeQuery(cQry) )

    oStatement:SetString(1, xFilial("CJE"))
    oStatement:SetString(2, '2')

    cAliasFormul := oStatement:OpenAlias(GetNextAlias())

    While !(cAliasFormul)->(Eof())

        cParam := AllTrim((cAliasFormul)->CJE_PARAM)
        cConteu := AllTrim((cAliasFormul)->CJE_CONTEU)

        if ( cParam == 'PREDBC' )
            cFormula := StrTran(cFormula,'1 - (PREDBC / 100)',cConteu)
        elseif ( cParam == 'PREDBCST' )
            cFormula := StrTran(cFormula,'1 - (PREDBCST / 100)',cConteu)
        elseif ( cParam == 'PMVAST' )
            cFormula := StrTran(cFormula,'1 + (PMVAST / 100)',cConteu)
        else
            cFormula := StrTran(cFormula,cParam,cConteu)
        endif

        lExist  := .T.
        
        (cAliasFormul)->(DbSkip())

    EndDo

    cFormula := StrTran(cFormula,"VBC = ","")
    cFormula := StrTran(cFormula,"VBCST =","")
    cFormula := StrTran(cFormula,"TRIBIPI = ","")

    (cAliasFormul)->(DbCloseArea())

    FreeObj(oStatement)*/



Else
    cFormula := ""
EndIf

Return cFormula

//-------------------------------------------------------------------
/*/{Protheus.doc} AtuCJE
Método para passar o código da regra de alíquota no Configurador.
@author  Erich Buttner
@since   11.06.2022
@version 1.0
/*/
//-------------------------------------------------------------------
Method AtuCJE(cCJECod) Class FISGravaBase

DbSelectArea("CJE")
CJE->(DbSetOrder(1))

If CJE->(MsSeek(xFilial("CJE")+"CODREGBASE"))
    RecLock("CJE", .F.)
        CJE->CJE_CONTEU := AllTrim(Padl(cValToChar(Val(cCJECod)+1),3,"0"))
        ::setcod := Padl(cValToChar(Val(cCJECod)+1),3,"0")
    CJE->(MsUnlock())
EndIF

CJE->(DbCloseArea())

Return ::setcod


/*/{Protheus.doc} gravaDadosjson
    (long_description)
    @author user
    @since 21/12/2023
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method gravaDadosjson(cBaseCalc as character) Class FISGravaBase

    Local aBaseCalc         as array
    Local aBases            as array
    Local aRet              as array
    Local aTaxes            as array
    Local aRegisterBase     as array
    Local cDesc             as character
    Local cFormula          as character
    Local cTaxIPI           as character
    Local cVlOrig           as character
    Local jBaseCalc         as json
    Local jCadastraBaseCalc as json
    Local jTaxes            as json
    Local lExisteIPI        as logical
    Local nPcRed            as numeric
    Local nX, nY, nR        as numeric
    Local cTax              as character

    aBaseCalc     := {}
    aBases        := {}
    aRet          := {}
    aTaxes        := {}
    aRegisterBase := {}
    jTaxes := JsonObject():New()

    If jTaxes:FromJson(cBaseCalc) == Nil

        aBaseCalc := jTaxes['ncm']:getnames()

        For nX := 1 to len(aBaseCalc) 

            aTaxes := jTaxes['ncm'][aBaseCalc[nx]]:getnames()
            
            For nY := 1 to len(aTaxes)

                jBaseCalc := jTaxes['ncm'][aBaseCalc[nx]][aTaxes[nY]]

                If valType(jBaseCalc) == 'J' .and. jBaseCalc:hasProperty('baseCalc')

                    aBases := jBaseCalc['baseCalc']:getnames()

                    For nR := 1 to len(aBases)

                        jCadastraBaseCalc := jBaseCalc['baseCalc'][aBases[nR]]

                        cDesc           := jCadastraBaseCalc['description']                        
                        cVlOrig         := jCadastraBaseCalc['value_origin']                        
                        lExisteIPI      := jCadastraBaseCalc['exist_ipi']

                        If jCadastraBaseCalc:hasproperty('formula')
                            cFormula      := jCadastraBaseCalc['formula']
                        Endif

                        If jCadastraBaseCalc:hasproperty('reduction_base')
                            nPcRed   := jCadastraBaseCalc['reduction_base']
                        Endif

                        If jCadastraBaseCalc:hasproperty('taxipi')
                            cTaxIPI   := jCadastraBaseCalc['taxipi']
                        Endif
                        
                        cTax := aTaxes[nY]

                        cCodBase := "BAS"+AllTrim(::setcod)

                        aRet := Self:FISGravaBase(@cCodBase,cDesc,cVlOrig,nPcRed,cFormula)


                        If aRet[1]
                            aadd(aRegisterBase,{cTax,upper(cCodBase), aBaseCalc[nX]})
                            If aRet[2]
                                ::setcod := ::AtuCJE(AllTrim(::setcod))
                            Endif
                        EndIf
                    
                    Next nR
                Endif                
            Next nY
        Next nX

        aSize( aTaxes, 0 )
        aSize( aBases, 0 )
        aSize( aBaseCalc, 0 )
        aSize( aRet, 0 )
        FWFreeVar( jCadastraBaseCalc )
        FWFreeVar( jBaseCalc )        
        FWFreeVar( jTaxes )
        
    Endif
    
Return aRegisterBase

/*/{Protheus.doc} ExcluiRegraDeBase

Método responsável por excluir uma Regra de Base

@author Juliano Fernandes
@since 18/06/2024
@version 12.1.2310
/*/
method ExcluiRegraDeBase(jRegraDeBase as json, jRegra as json) as logical class FISGravaBase
 
	local lOk as logical
	local oModel as object
	local aErro as array

    lOk := .T.

    DbSelectArea('F27')
    F27->(DbSetOrder(1)) // F27_FILIAL+F27_CODIGO+F27_ALTERA+F27_ID
    if ( !F27->( DbSeek( FWxFilial('F27') + jRegraDeBase['codigo'] + '2' ) ) )
        lOk := .F.

        jRegra['mensagemDoErro'] := STR0252 //'Regra de Base não pode ser excluída'
        jRegra['codigoDoRegistro'] := jRegraDeBase['codigo']
        jRegra['detalheDoErro'] := STR0237 //'Registro não encontrado'
    endif

    if ( lOk )
        oModel := FWLoadModel('FISA161')
        oModel:SetOperation(MODEL_OPERATION_DELETE)
        oModel:Activate()

        if ( oModel:VldData() )
            jBasesCache:DelName(F27->F27_CHVMD5)
            oModel:CommitData()
        else
            lOk := .F.

            aErro := oModel:GetErrorMessage()

            jRegra['mensagemDoErro'] := STR0252 //'Regra de Base não pode ser excluída'     
            jRegra['codigoDoRegistro'] := jRegraDeBase['codigo']
            jRegra['detalheDoErro'] := AllToChar(aErro[6])

            ASize(aErro, 0)
        endif

        oModel:Deactivate()

        oModel:Destroy()

        FreeObj(oModel) 
    endif

    F27->(DbCloseArea())

return lOk
