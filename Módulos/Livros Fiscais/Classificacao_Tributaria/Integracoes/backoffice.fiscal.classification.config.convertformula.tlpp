#include 'tlpp-core.th'

Namespace totvs.protheus.backoffice.fiscal.Classifier

/*/{Protheus.doc} ConvertFormula()

    Classe para converter fórmulas de cálculo da Systax para a nova estrutura de cálculo do TOTVS configurador de tributos
    
    @author Rafael Oliveira
    @since 18/06/2024
    @version 12.1.2310
/*/
Class ConvertFormula

    Data aTokenMappingUnitary   as array // Armazenar o mapeamento das fórmulas unitárias
    Data aTokenMappingComposite as array // Armazenar o mapeamento das fórmulas compostas
    Data oHashUnitary           as object // Armazenar o mapeamento das fórmulas unitárias
    Data oHashComposite         as object // Armazenar o mapeamento das fórmulas compostas
    Data aTokensInvalids         as array // Armazenar os tokens inválidos    
    Data cNewFormula            as character // Armazenar a fórmula a ser convertida

    Public Method new() CONSTRUCTOR //método construtor da classe
    Public Method convert(cFormula) //método para converter a fórmula    

    Public Method GetInValidTokens() //método retornar os tokens inválidos

    Private Method ConvertTokens(cFormula, aMapping) //método para converter os tokens da fórmula
    Private Method ValidTokens(cFormula, aMapping) //método para verificar se a fórmula possui tokens inválidos    

    Public Method destroy() //método para destruir a classe    

EndClass


/*/{Protheus.doc} new()
    
    Método construtor da classe ConvertFormula

    @author Rafael Oliveira
    @since 18/06/2024
    @version 12.1.2310
/*/

Method new() CLASS ConvertFormula

    // Inicializa as variáveis

    Self:aTokensInvalids         := {}
    Self:aTokenMappingComposite := {}
    Self:aTokenMappingUnitary   := {}    

    // mapeamento das fórmulas|   
    
    //Systax: {{"token antigo", "token novo"}}  
    //Sempre adicionar o token mais completo primeiro, para evitar que tokens menores sejam convertidos erroneamente
    //Exemplo: VOUTROS deve ser adicionado antes de VOUTRO, para que o token VOUTRO não seja convertido erroneamente


    self:aTokenMappingUnitary := {;
                {"P_RED_BC"     , "I:PERC_REDUCAO_BASE"},;
                {"PREDBCST"     , "I:PERC_REDUCAO_BASE"},;    //{"PREDBCST"   , "I:PERC_REDUCAO_BASE"},;
                {"PREDBC"       , "I:PERC_REDUCAO_BASE"},;    //{"PREDBC"     , "I:PERC_REDUCAO_BASE"},;
                {"PMVAST"       , "I:MVA"},;                  //{"PMVAST"     , "I:MVA"},;  
                {"PICMS"        , "ALIQICMS"},;
                {"PALIQ_INTERNA", "ALIQICMS"},;
                {"PALÍQ_INTERNA", "ALIQICMS"},;
                {"QBCPROD"      , "O:QUANTIDADE"},;
                {"QTRIB"        , "O:QUANTIDADE"},;
                {"QUNID"        , "O:QUANTIDADE"},;
                {"VALIQPROD"    , "ALIQTRIB"},;
                {"VALOR_PAUTA"  , "I:PAUTA"},;
                {"VPAUTA"       , "I:PAUTA"},;
                {"VCOFINS"      , "TRIBCOFINS"},;
                {"VDESC"        , "O:DESCONTO"},;
                {"VFRETE"       , "O:FRETE"},;
                {"VIPI"         , "TRIBIPI"},;
                {"VOUTROS"      , "O:DESPESAS"},;
                {"VOUTRO"       , "O:DESPESAS"},;
                {"VPIS"         , "TRIBPIS"},;
                {"VSEG"         , "O:SEGURO"};
                }
    
    Self:aTokenMappingComposite := {;                
                {"1 - (PREDBCST / 100)"     , "PREDBCST"},;                
                {"1 - (PREDBCST/100)"       , "PREDBCST"},;
                {"1-(PREDBC_ST/100"         , "PREDBCST"},;
                {"1 - (P_RED_BC / 100)"     , "PREDBC"},;
                {"1 - (PREDBC / 100 )"      , "PREDBC"},;
                {"1 - (PREDBC / 100)"       , "PREDBC"},;
                {"1 - (PREDBC/100)"         , "PREDBC"},;
                {"1 + (PREDBC / 100)"       , "PREDBC"},;
                {"1 + (PMVAST / 100)"       , "PMVAST"},;
                {"1 + (PMVAST/100)"         , "PMVAST"},;
                {"PMVAST/100"               , "PMVAST"},;
                {"MVA/100"                  , "PMVAST"},;                
                {"PALIQ_INTERNA/100"        , "ALIQICMS"},;
                {"PALIQ_INTERESTADUAL/100"  , "ALIQICMS"},;
                {"(QTRIB * VUNTRIB)"        , "(O:VAL_MERCADORIA)"},;
                {"(QTRIB VUNTRIB)"          , "(O:VAL_MERCADORIA)"},;
                {"(QTRIB*VUNTRIB)"          , "(O:VAL_MERCADORIA)"},; 
                {"(QTRIB X VUNTRIB)"        , "(O:VAL_MERCADORIA)"},;
                {"QTRIB*VPRODUNI"           , "O:VAL_MERCADORIA"};
                }

                ////{"(1 - (PICMS / 100))" , "ALIQICMS"} removido, pois legado atualizava primeiro PICMS
    
    //Cria Hash para armazenar os tokens
    Self:oHashUnitary    := AToHM(Self:aTokenMappingUnitary, 2)
    Self:oHashComposite  := AToHM(Self:aTokenMappingComposite, 2)

Return self

/*/{Protheus.doc} GetInValidTokens

    Metodo para verificar se a fórmula possui tokens inválidos

    @author Rafael Oliveira
    @since 23/06/2024
    @version 12.1.2310
    @return aTokensInvalids, array, array com tokens inválidos da fórmula
/*/
Method GetInValidTokens() CLASS ConvertFormula
    // Verifica se a fórmula possui tokens inválidos
    self:ValidTokens()
Return self:aTokensInvalids

/*/{Protheus.doc} convert()
    
    Método para converter a fórmula de cálculo da Systax para a nova estrutura de cálculo do TOTVS configurador de tributos

    @param cFormula - fórmula a ser convertida
    @return cNewFormula, character, fórmula convertida
    @author Rafael Oliveira
    @since 18/06/2024
    @version 12.1.2310
/*/

Method convert(cFormula) CLASS ConvertFormula

    aSize(self:aTokensInvalids, 0)
    Self:cNewFormula := ""

    If !Empty(cFormula)

        cFormula := alltrim((upper(cFormula)))
        
        // Converte os tokens da fórmula
        // Primeiro convete os tokens compostos
        self:cNewFormula := Self:ConvertTokens(cFormula, self:aTokenMappingComposite) // converte os tokens compostos

        // Depois converte os tokens unitários
        self:cNewFormula := Self:ConvertTokens(self:cNewFormula, self:aTokenMappingUnitary) // converte os tokens unitários

    Endif

Return self:cNewFormula

/*/{Protheus.doc} ConvertTokens()

    Método para converter os tokens da fórmula

    @param cFormula - fórmula a ser convertida
    @param aMapping - mapeamento dos tokens
    @return cNewFormula, character, fórmula convertida

    @author Rafael Oliveira
    @since 18/06/2024
    @version 12.1.2310
/*/

Method ConvertTokens(cFormula, aMapping) CLASS ConvertFormula

    Local cNewFormula := cFormula // inicializa a variável com a fórmula original
    Local cOldToken := "" // inicializa a variável com o token antigo
    Local cNewToken := "" // inicializa a variável com o token novo
    Local nI := 0 // inicializa a variável de controle    

    // Percorre o array de mapeamento
    For nI := 1 to len(aMapping)
        cOldToken := aMapping[nI][1] // obtém o token antigo
        cNewToken := aMapping[nI][2] // obtém o token novo

        // Verifica se o token antigo foi convertido        
        cNewFormula := strtran(cNewFormula, cOldToken, cNewToken) // substitui o token antigo pelo novo        
    Next

Return cNewFormula

/*/{Protheus.doc} ValidTokens()

    Método para verificar se a fórmula possui tokens inválidos

    @return aTokensInvalids, array, array com tokens inválidos da fórmula
    
    @author Rafael Oliveira
    @since 18/06/2024
    @version 12.1.2310

/*/

Method ValidTokens() CLASS ConvertFormula

    Local aTokens  as array
    Local aRet     as array
    Local nI       as numeric
    Local cToken   as character

    If !Empty(self:cNewFormula)
        // Inicializa o array de tokens conforme a fórmula
        aTokens := StrTokArr(self:cNewFormula, " =+-*/()[]")

        // Percorre o array de tokens
        For nI := 1 to len(aTokens)

            //Verifica se o token não é um número
            If !IsDigit(aTokens[nI])
                cToken := alltrim(aTokens[nI]) // remove espaços em branco
                // Verifica se o token não está no mapeamento
                If !HMGet( self:oHashUnitary, cToken, @aRet ) .and. !HMGet( self:oHashComposite, cToken, @aRet )
                    aAdd(self:aTokensInvalids, aTokens[nI]) // adiciona o token inválido no array
                Endif
            Endif
        Next

        aSize(aTokens, 0) // libera a memória
    Endif

Return self:aTokensInvalids


/*/{Protheus.doc} destroy()

    Método para destruir a classe

    @return self - classe destruída
    @author Rafael Oliveira
    @since 18/06/2024
    @version 12.1.2310
/*/
Method destroy() CLASS ConvertFormula

    // Redimensiona os arrays para liberar a memória
    aSize(self:aTokensInvalids, 0)
    self:aTokensInvalids := nil
    
    aSize(self:aTokenMappingComposite, 0)
    self:aTokenMappingComposite := nil
    
    aSize(self:aTokenMappingUnitary, 0)
    self:aTokenMappingUnitary := nil

    FwFreevar(self:oHashComposite)
    FwFreevar(self:oHashUnitary)

Return self
