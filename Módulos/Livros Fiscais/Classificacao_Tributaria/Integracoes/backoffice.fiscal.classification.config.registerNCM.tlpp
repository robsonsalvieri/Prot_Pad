#include 'tlpp-core.th'
#INCLUDE "FWMVCDEF.CH"
#include 'classificadorfiscal.ch'

Namespace totvs.protheus.backoffice.fiscal.Classifier


/*/{Protheus.doc} recordTaxesNCM

    Classe para gravar os dados processados e organizados no Protheus
    Cadastro de NCM
    
    @author Rafael Oliveira
    @since 12/12/2023
    @version 12.1.2310
    /*/
Class RecordTaxesNCM

    Private Data cCodeNcm       as character
    Private Data cData          as character
    Private Data jTaxes         as json
    Private Data cError         as character
    Private Data lReady         as logical
    Private Data oModel         as object        
    Private Data nOperation     as numeric
    Private Data sizeCITTrib    as numeric
    Private Data sizeCest       as numeric
    Private Data sizeOriginProd as numeric
    Private Data sizeUnidade    as numeric

    public data aNCMs           as array

    Public METHOD new() CONSTRUCTOR
    Public METHOD recordTaxes() as logical
    Public METHOD destroy()

    Public METHOD setData()
    Public METHOD getData()
    Public METHOD getJson()     as json
    Public Method getNcm()      as character
    
    Public Method getError()    as character

    Public Method Delete()      as logical
    
    Private METHOD setJson()
    Private Method setNcm(value)
    Private METHOD existNCM()   as logical
    Private Method setError(value)
    Private Method recordRules(jRules)
    Private Method startModel()
    Private Method endModel()
    Private Method ProcessMajoracao(jMajoracao)
    Private Method ProcessMva(jMva)
    Private Method ProcessPauta(jPauta)
    Private Method nextItem() as numeric
    Private Method ProcessRules(jRule)    

EndClass

/*/{Protheus.doc} new

    método construtor da classe recordTaxesNCM

    @return objeto da classe recordTaxesNCM
/*/
Method new(cValue) CLASS recordTaxesNCM
    self:jTaxes         := JsonObject():New()
    self:cError         := ""
    self:cData          := ""
    self:lReady         := .F.
    Self:oModel         := nil
    self:nOperation     := 0
    self:sizeCITTrib    := MemoryCache( 'TAM_CIT_TRIB' ,,{||TAMSX3( 'CIT_TRIB' )[1]},.T.)
    self:sizeCest       := MemoryCache( 'TAM_CEST' ,,{||TAMSX3( 'CIU_CEST' )[1]},.T.)
    self:sizeOriginProd := MemoryCache( 'TAM_ORIGEM_PRODUTO' ,,{||TAMSX3( 'CIU_ORIGEM' )[1]},.T.)
    self:sizeUnidade    := MemoryCache( 'TAM_UNIDADE' ,,{||TAMSX3( 'CIU_UM' )[1]},.T.)

    // Se for passado um valor para o parâmetro value executa o método organizador de dados
    IF !empty(cValue)
        self:setData(cValue)        
    EndIf

    self:aNCMs := {}
Return self

/*/{Protheus.doc} setNcm

    método para receber um dado carácter com o ncm
    
    @param cValue, character, conteúdo em formato json
    @return objeto da classe recordTaxesNCM
/*/
Method setNcm(value) CLASS recordTaxesNCM
    self:cCodeNcm := value
Return self

/*/{Protheus.doc} getNcm

    método para retornar o ncm
    
    @return cData, character, conteúdo em formato json
/*/
Method getNcm() as character CLASS recordTaxesNCM
Return self:cCodeNcm


// métodos para receber e retornar os dados

/*/{Protheus.doc} setData

    método para receber um dado carácter com conteúdo json
    
    @param cValue, character, conteúdo em formato json
    @return objeto da classe recordTaxesNCM
/*/
Method setData(cValue as character) CLASS recordTaxesNCM

    self:cData := cValue
    
    self:setJson(self:cData)

Return self

/*/{Protheus.doc} getData

    método para dado carácter com conteúdo json recebido
    
    @return cData, character, conteúdo em formato json

/*/

Method getData() CLASS recordTaxesNCM
Return self:cData

/*/{Protheus.doc} setJson

    método para converter os dados recebidos em json para o formato do Protheus legado (tson)
    
    @return objeto da classe recordTaxesNCM
/*/

Method setJson(jvalue) CLASS recordTaxesNCM
    Local cError as character

    cError := self:jTaxes:FromJson(self:getData())

    //Valida se a conversão foi realizada com sucesso
    IF !empty(cError) .or. .not. self:jTaxes:hasproperty('ncm')

        self:setError("Erro ao converter o conteúdo recebido em json ou o conteúdo recebido não é um json válido. " + AllToChar(cError))
        self:lReady := .F.

    else
        self:lReady := .T.
    Endif

Return self

/*/{Protheus.doc} GetJson

    método para retornar o objeto json
/*/
Method getJson() as json CLASS recordTaxesNCM
Return self:jTaxes


/*/{Protheus.doc} setError

    método para receber um dado carácter com o erro ocorrido
    
    @param cValue, character, erro ocorrido
    @return objeto da classe IntegrativeClassifierSystax

/*/

Method setError(cValue as character) CLASS recordTaxesNCM
    self:cError := cValue
Return self

/*/{Protheus.doc} getError

    método para retornar o erro ocorrido
    
    @return cError, character, erro ocorrido

/*/

Method getError() as character CLASS recordTaxesNCM
Return self:cError

/*/{Protheus.doc} existNCM
    (long_description)
    @author user
    @since 12/12/2023
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method existNCM() as logical CLASS recordTaxesNCM
    Local lReturn as logical

    dbSelectArea("CIS")
    CIS->(dbSetOrder(1))

    lReturn := CIS->(MsSeek(xFilial("CIS") + Self:cCodeNCM))    
    
Return lReturn

/*/{Protheus.doc} recordTaxes
    
    método para gravar os dados processados e organizados no Protheus

    @author Rafael Oliveira
    @since 12/12/2023
    @version 12.1.2310    
    @return lReady, logical, se os dados foram gravados com sucesso
    /*/
Method recordTaxes() as  logical CLASS recordTaxesNCM

    Local jTaxes as json
    Local jNCM   as json
    Local nX, nY as numeric
    Local aNCM   as array
    Local aTaxes as array

    aNCM  := {}
    aTaxes := {}

    If self:lReady
        jTaxes := self:getJson()

        aNCM := jTaxes['ncm']:getnames()

        For nX := 1 to len(aNCM)

            self:setNcm(jTaxes['ncm']:getnames()[nX])

            aTaxes := jTaxes['ncm'][self:getNcm()]:getnames()
            
            For nY := 1 to len(aTaxes)

                jNCM := jTaxes['ncm'][self:getNcm()][aTaxes[nY]]

                If valType( jNCM) == 'J' .and. jNCM:hasProperty('ncm')

                    self:startModel()
                    self:recordRules(jNCM, aTaxes[nY])

                Endif
                
            Next nY
            
            self:endModel()
        Next nX

       

        aSize( aTaxes, 0 )
        aSize( aNCM, 0 )
    Endif

Return self:lReady

/*/{Protheus.doc} recordRules
    
    método para gravar os dados processados 

    @author Rafael Oliveira
    @since 12/12/2023
    @version 12.1.2310
    @param jRule, json, regra a ser gravada
    @param cTax, character, tipo de imposto    
    
    /*/
Method recordRules(jRule as json, cTax as character) CLASS recordTaxesNCM 

    Local oModelTax       as object    
    Local lAchou          as logical    

    oModelTax := self:oModel:GetModel( 'FISA160BTRIB' )
    
    lAchou := (oModelTax:SeekLine( { {"CIT_TRIB", PADR( UPPER(ALLTRIM(cTax)), Self:sizeCITTrib ) }}, .F. , .T. ))
    

    If .not. lAchou
        If oModelTax:Length() >= 1 .and.  !oModelTax:IsEmpty()//!EMPTY(oModelTax:GetValue("CIT_TRIB")) // Se já existir um registro ou ja tiver sido adicionado um registro neste processamento
            oModelTax:AddLine()
        Endif
        oModelTax:SetValue('CIT_TRIB', PADR( UPPER(ALLTRIM(cTax)), Self:sizeCITTrib ) )
    Endif

    Self:ProcessRules(jRule, cTax)

Return 

/*/{Protheus.doc} ProcessRules
    
    método para gravar os dados processados de regras

    @author Rafael Oliveira
    @since 18/12/2023
    @version 12.1.2310
    @param jRule, json, regra a ser gravada
    @param cTax, character, tipo de imposto
    
    /*/
Method ProcessRules(jRule as json, cTax as character) CLASS recordTaxesNCM
    
    Local aRules as array
    Local nx as numeric

    aRules := jRule['ncm']:getnames()

    For nX := 1 to len(aRules)

        If  upper('majoracao') $ upper(aRules[nX])
            Self:ProcessMajoracao(jRule['ncm'][aRules[nx]], cTax)
        Endif

        If upper('mva') $ upper(aRules[nX])
            Self:ProcessMva(jRule['ncm'][aRules[nx]], cTax)    
        Endif

        If upper('pauta') $ upper(aRules[nX])
            Self:ProcessPauta(jRule['ncm'][aRules[nx]], cTax)    
        Endif
    Next nX

    ASIZE( aRules, 0 )
Return 

/*/{Protheus.doc} ProcessMajoracao
    
    método para gravar os dados processados de majoração

    @param jMajoracao, json, regra a ser gravada
    @return oModelmajoracao, object, modelo de dados
/*/

Method ProcessMajoracao(jMajoracao as json, cTax as character) CLASS recordTaxesNCM

    Local nItem  as numeric
    Local oModelMajoracao as object    
    Local aKey   as array
    Local lExist as logical

    aKey := {}
    oModelMajoracao := self:oModel:GetModel( 'FISA160BCFGMAJOR' )
    
    
    aKey := { {"CIU_UFORI"  , jMajoracao[ 'uf_origem' ] },;
            { "CIU_UFDEST"  , jMajoracao[ 'uf_destino' ] },;
            { "CIU_VIGINI"  , cToD(jMajoracao[ 'vigencia_de' ] ) },;
            { "CIU_VIGFIM"  , cToD(jMajoracao[ 'vigencia_ate' ] ) },;
            { "CIU_CEST"    , PADR(jMajoracao[ 'codigo_cest' ], Self:sizeCest ) },;
            { "CIU_ORIGEM"  , jMajoracao[ 'origem_produto' ] }}
    

    nItem := Self:nextItem(oModelMajoracao, cTax, aKey, @lExist)   

    If .Not.lExist
        oModelMajoracao:SetValue( 'CIU_ITEM' , strZero(nItem, 4))
        oModelMajoracao:SetValue( 'CIU_UFORI' , jMajoracao[ 'uf_origem' ])
        oModelMajoracao:SetValue( 'CIU_UFDEST' , jMajoracao[ 'uf_destino' ])
        oModelMajoracao:SetValue( 'CIU_VIGINI' , cToD(jMajoracao[ 'vigencia_de' ]))
        oModelMajoracao:SetValue( 'CIU_VIGFIM' , cToD(jMajoracao[ 'vigencia_ate' ]))
        oModelMajoracao:SetValue( 'CIU_MAJORA' , jMajoracao[ 'percentual_majoracao' ])
        oModelMajoracao:SetValue( 'CIU_MJAUX' , jMajoracao[ 'indice_auxiliar_majoracao' ])
        oModelMajoracao:SetValue( 'CIU_CEST' , jMajoracao[ 'codigo_cest' ])
        oModelMajoracao:SetValue( 'CIU_ORIGEM' , jMajoracao[ 'origem_produto' ])   
    Endif

    aSize( aKey, 0 )
Return 

/*/{Protheus.doc} ProcessMva
    
    método para gravar os dados processados de mva

    @param jMva, json, regra a ser gravada
    @return oModelmva, object, modelo de dados
/*/

Method ProcessMva(jMva as json, cTax as character) CLASS recordTaxesNCM

    Local oModelMva as object
    Local nItem  as numeric    
    Local aKey   as array
    Local lExist as logical

    aKey :={}
    oModelMva := self:oModel:GetModel( 'FISA160BCFGMVA' )    

    
    aKey := { {"CIU_UFORI", jMva[ 'uf_origem' ] },;
            { "CIU_UFDEST", jMva[ 'uf_destino' ] },;
            { "CIU_VIGINI", cToD(jMva[ 'vigencia_de' ] ) },;
            { "CIU_VIGFIM", cToD(jMva[ 'vigencia_ate' ] ) },;
            { "CIU_CEST", PADR(jMva[ 'codigo_cest' ], Self:sizeCest ) },;
            { "CIU_ORIGEM", PADR(jMva[ 'origem_produto' ], Self:sizeOriginProd) } }
    

    nItem := Self:nextItem(oModelMva, cTax, aKey, @lExist) 

    If .Not.lExist

        oModelMva:SetValue( 'CIU_ITEM'   , strZero(nItem, 4))
        oModelMva:SetValue( 'CIU_UFORI'  , jMva[ 'uf_origem' ])
        oModelMva:SetValue( 'CIU_UFDEST' , jMva[ 'uf_destino' ])
        oModelMva:SetValue( 'CIU_VIGINI' , cToD(jMva[ 'vigencia_de' ]))
        oModelMva:SetValue( 'CIU_VIGFIM' , cToD(jMva[ 'vigencia_ate' ]))
        oModelMva:SetValue( 'CIU_ORIGEM' , jMva[ 'origem_produto' ])
        oModelMva:SetValue( 'CIU_MARGEM' , jMva[ 'mva' ])
        oModelMva:SetValue( 'CIU_MVAAUX' , jMva[ 'indice_auxiliar_mva' ])
        oModelMva:SetValue( 'CIU_CEST'   , jMva[ 'codigo_cest' ])
    Endif

    aSize( aKey, 0 )

Return

/*/{Protheus.doc} ProcessPauta
    
    método para gravar os dados processados de pauta

    @param jPauta, json, regra a ser gravada
    @return oModelpauta, object, modelo de dados
/*/

Method ProcessPauta(jPauta as json, cTax as character) CLASS recordTaxesNCM

    Local oModelPauta as object
    Local nItem  as numeric    
    Local aKey   as array
    Local lExist as logical

    aKey := {}
    oModelPauta     := self:oModel:GetModel( 'FISA160BCFGPAUTA' )

    
    aKey := { {"CIU_UFORI"  , jPauta[ 'uf_origem' ] },;
            { "CIU_UFDEST"  , jPauta[ 'uf_destino' ] },;
            { "CIU_VIGINI"  , cToD(jPauta[ 'vigencia_de' ] ) },;
            { "CIU_VIGFIM"  , cToD(jPauta[ 'vigencia_ate' ] ) },;
            { "CIU_CEST"    , PADR(jPauta[ 'codigo_cest' ], Self:sizeCest ) },;
            { "CIU_UM"      , PADR(jPauta[ 'unidade_medida' ], Self:sizeUnidade) },;
            { "CIU_ORIGEM"  , jPauta[ 'origem_produto' ] } }
    

    nItem := Self:nextItem(oModelPauta, cTax, aKey, @lExist)

    If .Not.lExist

        oModelPauta:SetValue( 'CIU_ITEM'    , strZero(nItem, 4))
        oModelPauta:SetValue( 'CIU_UFORI'   , jPauta[ 'uf_origem' ])
        oModelPauta:SetValue( 'CIU_UFDEST'  , jPauta[ 'uf_destino' ])
        oModelPauta:SetValue( 'CIU_VIGINI'  , cToD(jPauta[ 'vigencia_de' ]))
        oModelPauta:SetValue( 'CIU_VIGFIM'  , cToD(jPauta[ 'vigencia_ate' ]))
        oModelPauta:SetValue( 'CIU_UM'      , jPauta[ 'unidade_medida' ])
        oModelPauta:SetValue( 'CIU_VLPAUT'  , jPauta[ 'valor_pauta' ])
        oModelPauta:SetValue( 'CIU_CEST'    , jPauta[ 'codigo_cest' ])
        oModelPauta:SetValue( 'CIU_ORIGEM'  , jPauta[ 'origem_produto' ])
    Endif

    aSize( aKey, 0 )

Return

/*/{Protheus.doc} NextItem
    
    método para retornar o próximo item do grid

    @author Rafael Oliveira
    @since 15/12/2023
    @version 12.1.2310
    @param oModel, object, modelo de dados    
    @param cTax, character, tipo de imposto
    @param lSearch, logical, se deve procurar o registro
    @param aKey, array, chave de busca
    @param lExist, logical, se o registro existe
    @return nItem, numeric, próximo item do grid
    /*/
Method nextItem(oModel, cTax, aKey, lExist) as  numeric CLASS recordTaxesNCM

    Local nItem as numeric    
    
    Default aKey    := {}
    
    If Len(aKey) > 0 
        lExist := (oModel:SeekLine( aKey, .F. , .T. ))
    Endif

    //Se achar o registro, atualiza o mesmo, senão adiciona uma nova linha
    IF lExist
        nItem := val(oModel:GetValue("CIU_ITEM"))
    Else
        nItem := oModel:Length()
        If nItem >= 1 .and.  !oModel:IsEmpty()//!EMPTY(oModel:GetValue("CIU_UFORI")) // Se já existir um registro ou ja tiver sido adicionado um registro neste processamento
            nItem := oModel:AddLine()        
        Endif    
    endif
    
Return nItem

/*/{Protheus.doc} startModel
    
    método para iniciar o modelo de dados

    @param oModel, object, modelo de dados
    @return oModel, object, modelo de dados
    /*/

Method startModel() CLASS recordTaxesNCM

    IF !valType(self:oModel) == 'O'
            
        If self:existNCM()
            Self:nOperation := MODEL_OPERATION_UPDATE
        else
            Self:nOperation := MODEL_OPERATION_INSERT
        Endif    
        
        self:oModel := FwLoadModel("FISA160B")    
        self:oModel:SetOperation(Self:nOperation)
        self:oModel:Activate()

        self:oModel:GetModel( 'FISA160B' )       

        If Self:nOperation == MODEL_OPERATION_INSERT        
            self:oModel:GetModel( 'FISA160B' ):SetValue('CIS_CODNCM', self:getNcm() )
        Endif
    Endif

Return self:oModel

/*/{Protheus.doc} endModel
    
    método para finalizar o modelo de dados

    @param oModel, object, modelo de dados
    @return oModel, object, modelo de dados
    /*/

Method endModel() CLASS recordTaxesNCM
    Local aErro := {} as array
    Local aMsg  as array
    Local jNCM  as json

    If Valtype(self:oModel) == 'O'

        Self:lReady := self:oModel:VldData()

        If Self:lReady
            self:oModel:CommitData() 
        Else 
            aErro := self:oModel:GetErrorMessage()

            // A estrutura do vetor com erro é:
            // [1] identificador (ID) do formulário de origem
            // [2] identificador (ID) do campo de origem
            // [3] identificador (ID) do formulário de erro
            // [4] identificador (ID) do campo de erro
            // [5] identificador (ID) do erro
            // [6] mensagem do erro
            // [7] mensagem da solução
            // [8] Valor atribuído
            // [9] Valor anterior

            self:setError( 'formulário de origem: ' + AllToChar(aErro[1]) + ', campo de origem: ' + AllToChar(aErro[2]);
                        + ', formulário de erro: ' + AllToChar(aErro[3]) + ', campo de erro: ' + AllToChar(aErro[4]);
                        + ', erro: ' + AllToChar(aErro[5]) + ', mensagem do erro: ' + AllToChar(aErro[6]);
                        + ', mensagem da solução: ' + AllToChar(aErro[7]) + ', valor atribuído: ' + AllToChar(aErro[8]);
                        + ', valor anterior: ' + AllToChar(aErro[9]))

            //array com mensagem de erro chave e valor
            aMsg := { { 'formulário de origem:', AllToChar(aErro[1]) } , { 'campo de origem:', AllToChar(aErro[2]) } , { 'formulário de erro:', AllToChar(aErro[3]) } , { 'campo de erro:', AllToChar(aErro[4]) } , { 'erro:', AllToChar(aErro[5]) } , { 'mensagem do erro:', AllToChar(aErro[6]) } , { 'mensagem da solução:', AllToChar(aErro[7]) } , { 'valor atribuído:', AllToChar(aErro[8]) } , { 'valor anterior:', AllToChar(aErro[9]) } }
            
            //CONOUT( 'formulário de origem:', AllToChar(aErro[1]) , 'campo de origem:', AllToChar(aErro[2]) , 'formulário de erro:', AllToChar(aErro[3]) , 'campo de erro:', AllToChar(aErro[4]) , 'erro:', AllToChar(aErro[5]) , 'mensagem do erro:', AllToChar(aErro[6]) , 'mensagem da solução:', AllToChar(aErro[7]) , 'valor atribuído:', AllToChar(aErro[8]) , 'valor anterior:', AllToChar(aErro[9]), 'RECNO',CJB->(Recno()) )

            FWLogMsg( 'WARN',  /*[ cTransactionId ]*/ , 'RegisterNCM' , /*[ cCategory ]*/ , /*[ cStep ]*/ , /*[ cMsgId ]*/ , self:getError() /*[ cMessage */ , /*[ nMensure ]*/ , /*[ nElapseTime ]*/ , aMsg/*[ aMessage ]*/ )

            aSize(aMsg, 0 )          
        Endif        

        jNCM := JsonObject():New()
        jNCM['codigo'] := self:oModel:GetValue('FISA160B', 'CIS_CODNCM')
        jNCM['incluido'] := self:oModel:GetOperation() == MODEL_OPERATION_INSERT

        if ( Len(aErro) > 0 )
            jNCM['erro'] := JsonObject():New()
            jNCM['erro']['formularioDeOrigem'] := AllToChar(aErro[1]) 
            jNCM['erro']['campoDeOrigem'] := AllToChar(aErro[2])
            jNCM['erro']['formularioDeErro'] := AllToChar(aErro[3])
            jNCM['erro']['campoDeErro'] := AllToChar(aErro[4])
            jNCM['erro']['erro'] := AllToChar(aErro[5])
            jNCM['erro']['mensagemDoErro'] := AllToChar(aErro[6])
            jNCM['erro']['mensagemDaSolucao'] := AllToChar(aErro[7])
            jNCM['erro']['valorAtribuido'] := AllToChar(aErro[8])
            jNCM['erro']['valorAnterior'] := AllToChar(aErro[9])
        endif

        Aadd(self:aNCMs, jNCM)

        ASize(aErro, 0)

        self:oModel:DeActivate()
		self:oModel:Destroy()		
        FwFreevar( self:oModel )
        
    Endif

    If select('CIS') > 0
        CIS->(dbCloseArea())
    Endif
        

Return 

/*/{Protheus.doc} Delete

Método responsável por deletar uma Regra por NCM

@author Juliano Fernandes
@since 18/06/2024
@version 12.1.2310
/*/
method Delete(jNCMRules as json, jRule as json) as logical class recordTaxesNCM

	local lOk as logical
	local oModel as object
	// local aError as array

    lOk := .T.

    DbSelectArea('CIS')
    CIS->(DbSetOrder(1)) // CIS_FILIAL+CIS_CODNCM+CIS_ID

    if ( !CIS->( DbSeek( FWxFilial('CIS') + jNCMRules['codigo'] ) ) )
        lOk := .F.

        jRule['mensagemDoErro'] := STR0239 //'Regra por NCM não pode ser excluída'
        jRule['codigoDoRegistro'] := jNCMRules['codigo']
        jRule['detalheDoErro'] := STR0237 //'Registro não encontrado'	
    endif

    if ( lOk )
        oModel := FWLoadModel('FISA160B')
        oModel:SetOperation(MODEL_OPERATION_DELETE)
        oModel:Activate()

        if ( oModel:VldData() )
            oModel:CommitData()
        // else
        //     lOk := .F.

        //     aError := oModel:GetErrorMessage()

        //     jRule['mensagemDoErro'] := STR0239 //'Regra por NCM não pode ser excluída'
        //     jRule['codigoDoRegistro'] := jNCMRules['codigo']
        //     jRule['detalheDoErro'] := AllToChar(aError[6])

        //     ASize(aError, 0)
        endif

        oModel:Deactivate()

        oModel:Destroy()

        FreeObj(oModel) 
    endif

    CIS->(DbCloseArea())    

return lOk

/*/{Protheus.doc} destroy
    (long_description)
    @author user
    @since 15/12/2023
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method destroy() CLASS recordTaxesNCM

    Self:cData := ''
    Self:jTaxes := Nil
    Self:oModel := Nil

    FREEOBJ( Self:jTaxes )
    FREEOBJ( Self:oModel )    
    
Return 


