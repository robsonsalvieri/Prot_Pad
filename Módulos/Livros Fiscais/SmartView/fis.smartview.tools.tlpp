#include "msobject.ch"
#INCLUDE "TOTVS.CH"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "fis.smartview.tools.ch"

namespace totvs.protheus.fiscal.fis.treportsintegratedprovider

//-------------------------------------------------------------------
/*{Protheus.doc}  fisSmartviewTools
    Classe de funções genéricas usadas pela Squad Fiscal no Smartview - Projeto Júpiter
    @author Raphael Ventura
    @since 25/10/2023
*/
//-------------------------------------------------------------------  
class fisSmartviewTools 
    public method new() constructor
    public method validPerg(lValid)
    public method Paginacao(nPages)
    public method montaFilial(cFilDe,cFilAte)
    private method existFil(cFilSis,nPos)
    public method validFil(lValid)
    private method checkFil()
    private method mountFilter()
    public method montFilial(cFilDe, cFilAte, nPosDe, nPosAte, aSM0Data)
    public method FilterFil(nPosDe, nPosAte, aSM0Data, aFiliais, cTable)
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} New()
    Método construtor da classe
    @author Raphael Ventura
    @since 25.10.2023
/*/
//-------------------------------------------------------------------
method new() class fisSmartviewTools
return self

/*/{Protheus.doc} validPerg
    Mensagem de erro caso o SX1 não seja encontrado (Smartview)
    @author Raphael Ventura
    @since 25/10/2023
    @param lExistPerg, indica se a pergunta foi posicionada corretamente
/*/

Method validPerg(lExistPerg) CLASS fisSmartviewTools

    Local laux as logical

    if GetGlbVars("lValSX1", laux) .OR. !lExistPerg  
        FwLogMsg(STR0001,, STR0002,,, , STR0003, , ,)
    endif

Return 

/*/{Protheus.doc} Paginacao
    Passa a quantidade de linhas que serão utilizadas para a paginação do objeto (Smartview)
    @author Raphael Ventura
    @since 26/10/2023
    @since 25/10/2023
    @param nPages (quantidade de linhas atualmente utilizadas para a paginação do objeto)
    @return nPages (nova quantidade de linhas que serão utilizadas para a paginação do objeto)
    /*/
Method Paginacao(nPages) Class fisSmartviewTools
    Local nAutPages as numeric

    if GetGlbVars("nPages",nAutPages)
        nPages := nAutPages
    endif
Return nPages

/*/{Protheus.doc} montaFilial
    Validação das filiais informadas pelo usuário nos parâmetros do objeto de negócios
    @author Raphael Ventura
    @since 26/10/2023
    @version 1
    @param cFilDe, cFilAte, range de filiais De/Ate informado nos parâmetros
    @return cReturn, retorna todas as filiais que serão usadas na query do objeto de negócios. Também retorna erro.
    /*/
Method montaFilial(cFilDe,cFilAte, aFiliais as array) Class fisSmartviewTools
    Local cReturn as Character
    Local aSM0Data := FWLoadSM0()
    Local nPosDe as numeric
    Local nPosAte as numeric
    
    Default aFiliais := {} 

    cFilDe := padr(cFilDe,len(aSM0Data[1][2]))
    cFilAte:= padr(cFilAte,len(aSM0Data[1][2]))
    aSort(aSM0Data,,,{|x,y| x[1]+x[2] < y[1]+y[2]})


    if self:checkFil(@cFilDe, @cFilAte, @nPosDe, @nPosAte, aSM0Data)
       cReturn := self:mountFilter(cFilDe, cFilAte, nPosDe, nPosAte, aSM0Data, @aFiliais)
    else
        cReturn := 'Erro'
    endif

Return cReturn

/*/{Protheus.doc} validFil
    Mensagem de erro caso o SX1 seja preenchido de forma errada pelo usuário (Smartview)
    @author Raphael Ventura
    @since 25/10/2023
    @param lValid, retorna msg de erro caso o método montaFilial retorne erro
/*/
Method validFil(lValid) CLASS fisSmartviewTools
	if !lValid      //zzz a branco cai aqui
        FwLogMsg(STR0001,, STR0002,,, , STR0004, , ,)
        lRet := .f.
    endif
Return

/*/{Protheus.doc} existFil
    Valida se a filial De existe
    @author Julia Mota
    @since 22/01/2024
    @param 
/*/

Method existFil(cFilSis, nPos, aSM0Data) CLASS fisSmartviewTools

Local lOk as logical

lOk := .T.

//valida filial de
    nPos := AScan(aSM0Data, {|x| x[1]==cempant .and. AllTrim(x[2])==AllTrim(cFilSis)})
    if nPos == 0
        lOk := .F. 
    endif

Return lOk

/*/{Protheus.doc} checkFil
    Valida se a filial De e Até é uma filial valida
    @author Julia Mota
    @since 22/01/2024
    @param 
/*/

Method checkFil(cFilDe, cFilAte, nPosDe, nPosAte, aSM0Data) CLASS fisSmartviewTools

Local lOk := .T. as logical
    
if !Empty(cFilDe)
    lOK := self:existFil(cFilDe, @nPosDe, aSM0Data)
endIf

//valida filial até
    if lOk .and. !EMPTY(cFilAte)
        if 'ZZZ' $ UPPER(cFilAte)
            nPosAte := len(aSM0Data)
        else
            lOk :=  self:existFil(cFilAte, @nPosAte, aSM0Data)
        endif
    else
        lOk := .F. 
    endif

    if lOk .and. nPosDe > nPosAte
        lOk := .F.        
    endif

Return lOk

/*/{Protheus.doc} mountFilter
    Monta a string com as filiais selecionadas (caso existam)
    @author Julia Mota
    @since 22/01/2024
    @param
/*/

Method mountFilter(cFilDe, cFilAte, nPosDe, nPosAte, aSM0Data, aFiliais) CLASS fisSmartviewTools
    
Local lFirst := .t. as logical
Local n as numeric
Local cReturn as character

    if nPosDe == 0
        nPosDe := 1
    endif

    for n := nPosDe to len(aSM0Data)
        if lFirst .and. aSM0Data[n][1] == cempant .and. aSM0Data[n][2] <> cFilAte 
            cReturn += "'" + aSM0Data[n][2] + "'"
            lFirst := .f.
            Aadd(aFiliais,aSM0Data[n][2])
        elseif !lFirst .and. aSM0Data[n][1] == cempant .and. aSM0Data[n][2] <> cFilAte 
            cReturn += ",'" + aSM0Data[n][2] + "'"
            Aadd(aFiliais,aSM0Data[n][2])
        endif
        if lFirst .and. aSM0Data[n][1] == cempant .and. aSM0Data[n][2] == cFilAte 
            cReturn += "'" + aSM0Data[n][2] + "'"
            Aadd(aFiliais,aSM0Data[n][2])
            exit
        elseif !lFirst .and. aSM0Data[n][1] == cempant .and. aSM0Data[n][2] == cFilAte
            cReturn += ",'" + aSM0Data[n][2] + "'"
            Aadd(aFiliais,aSM0Data[n][2])
            exit
        endif
    next

Return cReturn

/*/{Protheus.doc} montFilial
    Busca todas as filiais da SM0, valida se a filial seleciona existe 
    busca posição da filial selecionada dentro do array da SM0
    @author Adilson Roberto
    @since 24/09/2025
    @version 1
    @param cFilDe, cFilAte, range de filiais De/Ate informado nos parâmetros
    nPosDe e nPosAte posição da filial selecionada dentro do array da SM0
    aSM0Data array com as filiais da SM0
    @return lReturn, retorna .T. se as filiais selecionadas existe ou .F. se não existe
    /*/
Method montFilial(cFilDe as character,cFilAte as character, nPosDe as numeric, nPosAte as numeric, aSM0Data as array) Class fisSmartviewTools
    Local lReturn := .F. as logical
    Local nNPosi  := 0   as numeric
    
    aSM0Data := FWLoadSM0()
    nNPosi   := len(aSM0Data[1][2])
    cFilDe   := padr(cFilDe,nNPosi)
    cFilAte  := padr(cFilAte,nNPosi)
    aSort(aSM0Data,,,{|x,y| x[1]+x[2] < y[1]+y[2]})

    lReturn:= self:checkFil(@cFilDe, @cFilAte, @nPosDe, @nPosAte, aSM0Data)

Return lReturn


/*/{Protheus.doc} FilterFil
    Monta um array com as filiais selecionadas , 
    já filtrando por nivel de compartilhamento de tabela e 
    já efetuando um cash de filiais por nivel de compartilhamento
    @author Adilson Roberto
    @since 24/09/2025
    @param nPosDe e nPosAte range de busca de filial, aSM0Data array com filiais da SM0
    aFiliais array com filiais filtradas, cTable tabela a ser filtrada, oFilAcum cash de filiais
/*/

Method FilterFil(nPosDe as numeric, nPosAte as numeric, aSM0Data as array, aFiliais as array, cTable as character, oFilAcum as json) CLASS fisSmartviewTools
/*
nPosDe  := Filial de, Fil Ate, Fil SM0 ,  
nPosAte := Filial Ate
aSM0Data:= Filiais da SM0
aFiliais:= Retorna filial Já filtrada pelo xFilial
cTable  := Tabela para filtar o xFilial  
oFilAcum:= Json com o cache de filiais por nivel de compartilhamento das tabelas
*/    
Local nLoop    := 0   as numeric
Local cTipComp := ""  as character

    /*
    Caso no objeto de negocio tenhamos 02 tabelas com o mesmo nivel de compartilhamento
    Exemplo(SFT e SF3) a função passará à primeira vez no for executando o xFilial da tabela
    e logo após adicionará o array aFiliais dentro do json oFilAcum com a chave pelo nivel de compartilhamento
    da tabela processada Exemplo(EEE). Quando for processar a segunda tabela será valido o nivel de compartilhamento
    da segunda tabela, logo após será efetuado uma busca no Json oFilAcum pelo nivel de compartilhamento da tabela 
    caso encontre será atribuido ao array aFiliais o conteúdo já armazenado dentro do Json oFilAcum
    */
    If nPosDe == 0
        nPosDe := 1
    Endif

    //Verifica o nivel de compartilhamento das tabelas 
    cTipComp := Upper( AllTrim( FWModeAccess( cTable, 1 ) + FWModeAccess( cTable, 2) + FWModeAccess( cTable, 3 ) ) )

    //Verifica se já foi processado alguma tabela com o mesmo nivel de compartilhamento
    // da tabela a ser processada. Caso encontre atribui ao array aFiliais o conteudo 
    //já processado não precisando passar novamente no FOR para adicionar os xFilial
    If ValType(oFilAcum[cTipComp]) == "A"
        //Adiciona ao array o conteúdo armazenado no Json
        aFiliais := oFilAcum[cTipComp]
    Else
        //Efetua o loop de filial 
        for nLoop := nPosDe to nPosAte
            If aSM0Data[nLoop][1] == cempant
                //Adiciona a filial filtrada pelo xFilial
                Aadd(aFiliais,xFilial(cTable,aSM0Data[nLoop][2]))
            Endif
        next
        // Adiona o array já filtrado no Json
        oFilAcum[cTipComp] := aFiliais
    Endif

Return

