//#Include "RUSRESTFWV2.ch"
//#INCLUDE "RESTFUL.CH"
#include 'protheus.ch'
#include 'tlpp-core.th'
#include 'tlpp-rest.th'

#INCLUDE "FWMVCDEF.CH"
NameSpace np.framework.restlibrary

// @Put(endpoint="/api/rusrestfw/v2/validateModel/:model/:operation",description="[np.framework.eairest.RU99W20028_ScheduleStatusDOC]")
@Put(endpoint="/api/rusrestfw/v2/validateModel/:model/:operation",description="ValidatesJsonModel")
/*/
{Protheus.doc} RUSRESTFWV2_ValidateModel
description Validates MVC model
@type function
@author bsobieski
@since 30/01/2025
@return variant, Validation result
/*/
Function RUSRESTFWV2_ValidateModel()

	Local oJson  := jsonObject():New() as Json
	Local oJsonRet  := jsonObject():New() as Json
   Local jPath  := jsonObject():New() as Json
   Local oModel := Nil //FWLoadModel(jPath['model'])
	Local cData  := "" //oRest:getBodyRequest() as Character
   //sLocal jQuery := oRest:GetQueryRequest()
	Local aErrors:= {}
   Local nOperation := 0
   Local lRet := .T.
   Local nX
   Local nY
   Local nZ
   Local nPos 
   Local cError := ""
   Local aChangedFields := {}
   Local xValue
   Local xCurrValue
   Local aFields := {}
   jPath  := oRest:getPathParamsRequest()
   oModel := FWLoadModel(jPath['model'])
   cData  := oRest:getBodyRequest() 


   //TODO: Implement (check) for complex MVC Structures (more than one model)
   Do Case 
      Case jPath['operation'] == "INSERT"
         nOperation := MODEL_OPERATION_INSERT
      Case jPath['operation'] == "UPDATE"
         nOperation := MODEL_OPERATION_UPDATE
   EndCase

   If nOperation == 0
      //Set Error
   Else
      If oModel == Nil
         AAdd(oJsonRet['status'],i18n("Model #1 does not exist", {jPath['model']}))
         oJsonRet['ok']    := .F.
      Else
         oModel:SetOperation(nOperation)
         //TODO: Check format XML or JSON
         If .F. // oObj:lXml
            //lRet := oModel:LoadXMLData(cData,.F.)
         Else
            oJson:FromJson(cData)
            If nOperation == MODEL_OPERATION_UPDATE
               cPk := oJson['pk']
               //cPk := Decode64(cPk)
               cError := PositionModelRecord(oModel,cPK)
               If !Empty(cError)
                  lRet := .F.
                  oJsonRet['status'] := {}
                  AAdd(oJsonRet['status'],cError)
                  oJsonRet['ok']    := .F.
               Endif
            Endif
         EndIf
         If lRet
            oModel:Activate()
            //loads current record values
            If oJson['current'] <> Nil 
               For nX:= 1 To Len(oJson['current'])
                  If oJson['current'][nX]['line'] <> nil
                     oModel:GetModel(oJson['current'][nX]['model']):GoLine(  oJson['current'][nX]['line'] ) //Position on line
                  Endif
                  xCurrValue := oModel:GetValue( oJson['current'][nX]['model'],oJson['current'][nX]['field'] )
                  If ValType(xCurrValue) == "D"
                     xValue := Stod(oJson['current'][nX]['value'])
                  ElseIf ValType(xCurrValue) == "N" .And. ValType(oJson['current'][nX]['value']) == "C"
                     xValue := Val(oJson['current'][nX]['value'])
                  Else
                     xValue := (oJson['current'][nX]['value'])
                  Endif

                  If !oModel:LoadValue(oJson['current'][nX]['model'],oJson['current'][nX]['field'], xValue)
                     aadd(aErrors,oModel:GetErrorMessage())
                     lRet := .F.
                  Endif
               Next 
            Endif

            If lRet .And. oJson['changes'] <> Nil
               //Sets changes
               For nX:= 1 To Len(oJson['changes'])
                  If oJson['changes'][nX]['line'] <> nil
                     oModel:GetModel(oJson['changes'][nX]['model']):GoLine( oJson['changes'][nX]['line'] ) //Position on line
                  Endif
                  If oModel:CanSetValue(oJson['changes'][nX]['model'],oJson['changes'][nX]['field'] )
                     xCurrValue := oModel:GetValue( oJson['changes'][nX]['model'],oJson['changes'][nX]['field'] )
                     If ValType(xCurrValue) == "D"
                        xValue := Stod(oJson['changes'][nX]['value'])
                     ElseIf ValType(xCurrValue) == "N".And. ValType(oJson['changes'][nX]['value']) == "C"
                        xValue := Val(oJson['changes'][nX]['value'])
                     Else
                        xValue := (oJson['changes'][nX]['value'])
                     Endif
                     If !oModel:SetValue(oJson['changes'][nX]['model'],oJson['changes'][nX]['field'], xValue)
                        aadd(aErrors,oModel:GetErrorMessage())
                        lRet := .F.
                     Else
                        For nZ:=1 To Len(oModel:aAllSubmodels)
                           For nY:=1 To Len(oModel:aAllSubmodels[nZ]:aChangeValue)
                              nPos := Ascan(aChangedFields,{ |x| x['model'] == oModel:aAllSubmodels[nZ]:cID .And. x['field'] == oModel:aAllSubmodels[nZ]:aChangeValue[nY][1]})
                              If nPos > 0 
                                 aChangedFields[nPos]['value'] := oModel:GetValue(oModel:aAllSubmodels[nZ]:cID,oModel:aAllSubmodels[nZ]:aChangeValue[nY][1])
                              Else
                                 Aadd(aChangedFields, {"model" : oModel:aAllSubmodels[nZ]:cID, "field": oModel:aAllSubmodels[nZ]:aChangeValue[nY][1], "value": oModel:GetValue(oModel:aAllSubmodels[nZ]:cID,oModel:aAllSubmodels[nZ]:aChangeValue[nY][1]) } )
                                 nPos := Len(aChangedFields)
                              Endif
                              If ValType(aChangedFields[nPos]['value']) == "C"
                                 aChangedFields[nPos]['value'] := Alltrim(aChangedFields[nPos]['value'])
                              Endif
                           Next nY
                        Next nZ
                     Endif
                  EndIf
               Next nX
            Endif
            If !lRet
               oJsonRet['status'] := {}
               For nX:=1 To Len(aErrors)
                  AAdd(oJsonRet['status'], ErrorMessage(aErrors[nX]))
               Next
               oJsonRet['ok']    := .F.
            Else
               //oModel:GetJsonData(oFMModel:cFieldDetail == "1"/* lFieldDetail*/,          , oFMModel:cFieldVirtual == "1"/* lFieldVirtual */,, oFMModel:cFieldEmpty == "1" /* lFieldEmpty */, .T./*lPK*/, .T./*lPKEncoded*/, oFMModel:aFields, oFMModel:cFirstLevel == "1" /* lFirstLevel */, oFMModel:cInternalId == "1"/* lInternalID */)
               aFields := {}
               For nX:=1 To Len(aChangedFields)
                  aadd(aFields,aChangedFields[nX]['field'])
               Next nX
               cRet :=  oModel:GetJSONData(.F./* lFieldDetail*/,nOperation,.T./* lFieldVirtual */,,/* lFieldEmpty */.F., .F./*lPK*/, .F./*lPKEncoded*/,/*aField*/ aFields)
               oJsonRet['data']:=JsonObject():New()
               oJsonRet['data']['model']:=JsonObject():New()
               oJsonRet['data']['model']:FromJson(cRet)
               oJsonRet['data']['changedFields'] := aChangedFields
               oJsonRet['ok']    := .T.
            Endif
            oModel:DeActivate()
            oRest:SetKeyHeaderResponse('Content-Type', 'application/json')
            oRest:setResponse(oJsonRet)                  
         Endif
      Endif
   Endif
Return .T.

/*/{Protheus.doc} ErrorMessage
Funcao responsavel por retonar o erro do modelo.
@param aErroMsg Array de erro do modelo de dados
@return cRet Formato texto do array de erro do modelo de dados
@author Felipe Bonvicini Conti
@since 05/04/2016
@version P11, P12
/*/
//-------------------------------------------------------------------
Static Function ErrorMessage(aErroMsg)
Local oRet := JsonObject():New()
if !Empty(aErroMsg[1])
	oRet['idSubmodelOrigin']:= aErroMsg[1]
Endif
if !Empty(aErroMsg[2])
	oRet['idFieldOrigin'] 	:= aErroMsg[2]
Endif
if !Empty(aErroMsg[3])
	oRet['idSubmodelError'] := aErroMsg[3]
Endif
if !Empty(aErroMsg[4])
	oRet['idFieldError'] 	:= aErroMsg[4]
Endif
if !Empty(aErroMsg[5])
	oRet['idError'] 		:= aErroMsg[5]
Endif
if !Empty(StrTran(aErroMsg[6],chr(13)+chr(10),""))
	oRet['errorMessage'] 	:= aErroMsg[6]
Endif
if !Empty(StrTran(aErroMsg[7],chr(13)+chr(10),""))
	oRet['solutionMessage'] := aErroMsg[7]
Endif
oRet['assignedValue'] := aErroMsg[8]
oRet['previousValue'] := aErroMsg[9]
Return oRet

Static Function PositionModelRecord(oModel,cPk)
Local aKeys := oModel:GetPrimaryKey()
Local cFilField := ""
Local cPkFilter := FWAToS(aKeys,"||") + " = ? "
Local cMainArea
//Local cFilField := ""
Local cQuery := ""
Local oStatement
Local cError := ""
Local cTMPAlias := GetNextAlias()
If Len(aKeys)>0
   If Substr(aKeys[1],3,1) == "_"
      cMainArea := "S"+Substr(aKeys[1],1,2)
   Else
      cMainArea := Substr(aKeys[1],1,3)
   Endif
   cFilField := PrefixoCpo(cMainArea)+"_FILIAL" 
Endif
If (cMainArea)->(FieldPos(cFilField)) > 0 
   cPkFilter := PrefixoCpo(cMainArea)+"_FILIAL||" + cPkFilter
EndIf
cQuery := "SELECT "
cQuery += " R_E_C_N_O_ as REC "
cQuery += " FROM "+RetSqlname(cMainArea) 
cQuery += " WHERE "+cPkFilter
cQuery += " AND D_E_L_E_T_ = '' " 
oStatement := FwExecStatement():New(cQuery)
oStatement:SetString(1,Decode64(cPK))
cTMPAlias := oStatement:OpenAlias()
If (cTMPAlias)->(EOF())
      cError := i18n("Record not found [Alias:#1,Index #2, key requested #3]",; // 
      {cMainArea,FWAToS(oModel:GetPrimaryKey(),","),;
      Decode64(cPK)})
Else
      (cMainArea)->(DbGoto((cTMPAlias)->REC))
Endif
DbSelectArea(cTMPAlias)
DbCloseArea()

Return cError
                   
//Merge Russia R14 
                   
