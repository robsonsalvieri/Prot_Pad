#include "FINA410.CH"
#Include "PROTHEUS.CH"
#Include "FWEVENTVIEWCONSTS.CH"
#Include 'FWLIBVERSION.CH'

Static lFWCodFil := FindFunction("FWCodFil")
Static l410FT    := Nil
static __cTRRName := ""
Static __lRskActv   := Nil	// MAIS NEGÓCIOS ATIVO NO AMBIENTE = .T.
Static __cRskCPay   := Nil	// CONTEÚDO DO PARÂMETRO MV_RSKCPAY
Static __cRskFPay   := Nil  // CONTEÚDO DO PARÂMETRO MV_RSKFPAY

/*/{Protheus.doc} Fina410
	@description Refaz acumulados de Clientes/Fornecedores   
	@author Pilar S. Albaladejo
	@parameters lDireto
	@since 02/05/1996
/*/
Function Fina410(lDireto as Logical) as Variant

	Local nOpca			as Numeric
	Local aSays			as Array
	Local aButtons 		as Array
	Local cDescription	:= STR0004 + STR0005
	Local cPerg			:= "AFI410"
	Local oProcess
	Local aInfoCustom 	:= {}
	Local cLibLabel 	:= "20240520"
    Local lLibSchedule	:= FwLibVersion() >= cLibLabel

	Default lDireto := IsBlind()

	nOpca     			:= 0
	aSays				:= {}
	aButtons			:= {}
	
	Private cCadastro := OemToAnsi(STR0003)  //"Refaz Dados Clientes/Fornecedores"

	If !lLibSchedule
		If lDireto
			BatchProcess( cCadastro, STR0004 + Chr(13) + Chr(10) +;
				STR0005, cPerg,;
				{ || fa410Processa(.T.) }, { || .F. } )
			Return .T.
		Endif
	EndIf

	oProcess := tNewProcess():New( "FINA410", cCadastro, {|oSelf| fa410Processa(lDireto,oSelf)}, cDescription, cPerg,;
							  aInfoCustom                       /*aInfoCustom*/  ,;
                              .T.                               /*lPanelAux*/    ,;
                              5                                 /*nSizePanelAux*/,;
                              cDescription    					/*cDescriAux*/   ,;
                              .T.                               /*lViewExecute*/ ,;
                              .F.                               /*lOneMeter*/    ,;
                              .T.                               /*lSchedAuto*/ ) 

Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fa410Process³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 02.05.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Reprocessamento arquivos de cliente/fornecedor                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fa410Processa()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nao ha'                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIN                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ PROGRAMADOR  ³ DATA   ³ BOPS ³	MOTIVO DA ALTERACAO	  					³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Geronimo     ³16/02/06³093518³correção consiste em que nas vendas efe   ³±±
±±³              ³        ³      ³tuadas pelo Sigaloja, nas formas de pgto  ³±±
±±³ 	         ³        ³      ³CC ou CD” atualizo os dados do cliente e  ³±±
±±³          	 ³        ³      ³não da administradora como anteriormente 	³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa410Processa(lBat as Logical, oProcess as Object) as Variant

	Local nValForte		as Numeric
	Local nSaldoTit		as Numeric
	Local nMoeda  		as Numeric
	Local nMoedaF 		as Numeric
	Local cFilBusca 	as Character
	Local nTaxaM		as Numeric
	Local lRet      	as Logical
	Local aBaixas		as Array
	Local nMCusto		as Numeric
	Local lE1MsFil 		as Logical
	Local cFilSF2  		as Character

	Local nMaiorVDA		as Numeric
	Local nMaiorVDAaux	as Numeric
	Local nMSaldo		as Numeric
	Local cCliente   	as Character
	Local cNumPedVen 	as Character
	Local cCliPad  		as Character
	Local cLojaPad  	as Character
	Local lGestao		as Logical
	Local lFilExc		as Logical
	Local lRastro		as Logical
	Local lFilSA1C		as Logical
	Local lFilSA2C		as Logical
	Local nRiscod		as Numeric
	Local nCtnumpag		as Numeric
	Local nMetr			as Numeric
	Local cFornP		as Character
	Local l410SCFT      as Logical
	Local nValLiq 		as Numeric
	Local nValSld 		as Numeric

	Local cProcNam 		as Character
	Local cCliDe 		as Character
	Local cCliAte 		as Character
	Local cForDe 		as Character
	Local cForAte 		as Character
	Local cCRNEG  		as Character
	Local cCRNEG1 		as Character
	Local cCPNEG  		as Character
	Local cTipoLC 		as Character
	Local nI			as Numeric
	Local cLibLabel 	as Character
    Local lLibSchedule	as Logical 
	Local nRecCount     as Numeric

	nValForte 			:= 0
	nSaldoTit			:= 0
	nMoeda  			:= Int(Val(GetMv("MV_MCUSTO")))
	nMoedaF 			:= 0
	cFilBusca 			:= "  "
	nTaxaM				:= 0
	lRet      			:= .T.
	aBaixas				:= {}
	nMCusto				:= Val(GetMV("MV_MCUSTO"))
	lE1MsFil 			:= SE1->(FieldPos("E1_MSFIL") > 0)
	cFilSF2  			:= xFilial("SF2")

	nMaiorVDA			:= 0
	nMaiorVDAaux		:= 0
	nMSaldo				:= 0
	cCliente   			:= " "
	cNumPedVen 			:= ""
	cCliPad  			:= SuperGetMv("MV_CLIPAD",,"")		// Cliente Padrao
	cLojaPad  			:= SuperGetMv("MV_LOJAPAD",,"")		// Loja Padrao
	lGestao				:= Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
	lFilExc				:= .T.
	lRastro				:= If(FindFunction("FVerRstFin"),FVerRstFin(),.F.)
	lFilSA1C			:= If( lGestao, FWModeAccess("SA1",3) == "C", FWModeAccess("SA1",1) == "C" )
	lFilSA2C			:= If( lGestao, FWModeAccess("SA2",3) == "C", FWModeAccess("SA2",1) == "C" )
	nRiscod				:= GetMV("MV_RISCOD")
	nCtnumpag			:= 0
	nMetr				:= 0
	cFornP				:= ""
	l410SCFT      		:= .F.
	nValLiq 			:= 0
	nValSld 			:= 0

	cProcNam 			:= IIF(FindFunction("GetSPName"), GetSPName("FIN003","09"), "FIN003")
	cCliDe				:= ""
	cCliAte				:= ""
	cForDe				:= ""
	cForAte				:= ""
	cCRNEG  			:= "/"+MVRECANT+"/"+MV_CRNEG+"/"+MVABATIM+"/"+MVIRABT+"/"+MVFUABT+"/"+MVINABT+"/"+MVISABT+"/"+MVPIABT+"/"+MVCFABT
	cCRNEG1 			:= "/"+MVRECANT+"/"+MV_CRNEG
	cCPNEG  			:= "/"+MVPAGANT+"/"+MV_CPNEG+"/"+MVABATIM
	cTipoLC 			:= "/"+MVPROVIS
	nI					:= 0
	cLibLabel 			:= "20240520"
    lLibSchedule		:= FwLibVersion() >= cLibLabel
	nRecCount			:= 0

	DEFAULT lBat		:= .F.
	oProcess := if( ValType( oProcess ) <> 'O', nil, oProcess )

	//Verifica parametros informados
	l410FT := ExistBlock("FIN410FT")
	l410SCFT := ExistBlock("F410SCFT") // Filtro de procedure.

	If __lRskActv == NIL // VERIFICA SE O MAIS NEGÓCIOS ESTÁ ATIVO NO AMBIENTE
		__lRskActv := .F.
		If FindFunction("RskIsActive")
			__lRskActv := RskIsActive()
		EndIf
	EndIf

	If __lRskActv
		If __cRskFPay == NIL
			__cRskFPay := SuperGetMV("MV_RSKFPAY",, "SUPPLI|01") // VERIFICA O CONTEÚDO DO PARÂMETRO COM O CÓDIGO DO FORNECEDOR NA SA2 PARA A SUPPLIER
			__cRskFPay := REPLACE(__cRskFPay, "|")
		EndIf

		If __cRskCPay == NIL
			__cRskCPay := SuperGetMV("MV_RSKCPAY",, "SUPPLI|01") // VERIFICA O CONTEÚDO DO PARÂMETRO COM O CÓDIGO DO CLIENTE NA SA1 PARA A SUPPLIER
			__cRskCPay := REPLACE(__cRskCPay, "|")
		EndIf
	Else
		__cRskCPay  := ""
		__cRskFPay  := ""		
	EndIf

	newTR()

	If ExistProc( cProcNam, VerIDProc()) .and. ( TcSrvType() <> "AS/400" )
		cCRNEG     := Iif(Empty(cCRNEG),  ' ', cCRNEG)
		cCRNEG1    := Iif(Empty(cCRNEG1), ' ', cCRNEG1)
		cCPNEG     := Iif(Empty(cCPNEG),  ' ', cCPNEG)
		cTipoLC   := cTipoLC+"/"+GetSESTipos({ || ES_SALDUP == "2"},"1")
		cTipoLC   := Iif(Empty(cTipoLC)," ", cTipoLC)
		cCliDe    := Iif(Empty(mv_par03), ' ', Rtrim(mv_par03))
		cCliAte   := Rtrim(mv_par04)
		cForDe    := Iif(Empty(mv_par05), ' ', Rtrim(mv_par05))
		cForAte   := Rtrim(mv_par06)

		loadTRRFil()

		If l410SCFT
			/* Avalia se as procedures estão compiladas */
			/* para manter ou não a execução dos pontos */
			l410SCFT := ExistProc( IIF(FindFunction("GetSPName"), GetSPName("F410SCFT_A1","09"), "F410SCFT_A1") , VerIDProc()) .and. ( TcSrvType() <> "AS/400" ) .and. ;
				ExistProc( IIF(FindFunction("GetSPName"), GetSPName("F410SCFT_A2","09"), "F410SCFT_A2") , VerIDProc()) .and. ( TcSrvType() <> "AS/400" ) .and. ;
				ExistProc( IIF(FindFunction("GetSPName"), GetSPName("F410SCFT_E1","09"), "F410SCFT_E1") , VerIDProc()) .and. ( TcSrvType() <> "AS/400" ) .and. ;
				ExistProc( IIF(FindFunction("GetSPName"), GetSPName("F410SCFT_E2","09"), "F410SCFT_E2") , VerIDProc()) .and. ( TcSrvType() <> "AS/400" )

		EndIf

		aResult := TCSPExec( xProcedures(cProcNam), ; 
		StrZero(mv_par01,1), StrZero(mv_par02,1),;
			GetMv("MV_MCUSTO"),  dtos(dDatabase),;
			cCRNEG,              cCRNEG1,;
			cCPNEG,              cTipoLC,;
			cCliDe,              cCliAte,;
			cForDe,              cForAte,;
			FWSizeFilial(), nModulo, Rtrim(cCliPad), Rtrim(cLojaPad),;
			if(__lRskActv, 'S','N'),;
			__cRskFPay ,;
			__cRskCPay ,;
			If(l410SCFT,'2','1'))

			If Empty(aResult)
				MsgAlert(OemToAnsi(STR0008))  //"Erro na chamada do processo"
			Elseif aResult[1] == "01" .or. aResult[1] == "1"
				MsgAlert(OemToAnsi(STR0009))  //"Atualizacao OK"
			Else
				MsgAlert(OemToAnsi(STR0010))  //"Atualizacao com Erro"
			Endif

	Else

		If !lBat
			If oProcess <> nil
				oProcess:Savelog("INICIO")
				If mv_par01 == 1
					nRecCount := SA1->(RecCount())+SA2->(RecCount())+SE1->(RecCount())+SE2->(RecCount())
				Elseif mv_par01 == 2
					nRecCount := SA1->(RecCount())+SE1->(RecCount())
				ElseIf mv_par01 == 3
					nRecCount := SA2->(RecCount())+SE2->(RecCount())
				EndIf
				oProcess:SetRegua1(nRecCount)
				oProcess:SetRegua2(nRecCount)
			EndIf
		ElseIf lBat .And. lLibSchedule
			If oProcess <> nil
				oProcess:Savelog("INICIO")
				If mv_par01 == 1
					oProcess:SetRegua1(4)
				Elseif mv_par01 == 2 .Or. mv_par01 == 3
					oProcess:SetRegua1(2)
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cadastro de Clientes                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If mv_par01 != 3
			DbSelectArea("SA1")
			aFiliais := FWAllFilial(, , cEmpAnt, .F.)
			For nI := 1 to len(aFiliais)
				If Empty(mv_par03)
					dbGotop()
				Else
					dbSetOrder(1)
					MsSeek(xFilial("SA1", aFiliais[nI])+mv_par03,.T.)
				EndIf
				While !Eof() .And. (SA1->A1_COD >= mv_par03 .And. SA1->A1_COD <= mv_par04) .And. xFilial("SA1", aFiliais[nI]) == SA1->A1_FILIAL
					If !lBat
						If oProcess <> Nil
							oProcess:IncRegua1("Selecionando Registros...")
							oProcess:IncRegua2()
						EndIf
					EndIf

					If SA1->A1_COD >= mv_par03 .And. SA1->A1_COD <= mv_par04
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Ponto de entrada para filtro dos registros                      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If l410FT
							lRet := ExecBlock("FIN410FT",.F.,.F.,{mv_par01,"1"})
							If !lRet
								dbSkip()
								Loop
							EndIf
						Endif
						Reclock( "SA1" )
						SA1->A1_SALDUP := 0
						SA1->A1_SALDUPM:= 0
						SA1->A1_SALFIN := 0
						SA1->A1_SALFINM:= 0
						SA1->A1_VACUM  := 0
						If mv_par02 == 1 // Refaz dados historicos
							SA1->A1_METR   := 0
							SA1->A1_MATR   := 0
							SA1->A1_MAIDUPL:= 0
							SA1->A1_ATR    := 0
							SA1->A1_PAGATR := 0
							SA1->A1_NROPAG := 0
							SA1->A1_ULTCOM :=	CTOD("//")
							SA1->A1_MCOMPRA:= 0
							SA1->A1_NROCOM := 0
						Endif
						MsUnlock()
					Endif
					dbSkip()
				Enddo
			Next nI

			If lBat .And. lLibSchedule
				If oProcess <> Nil
					oProcess:IncRegua1()
				EndIf
			EndIf

		EndIf

		If mv_par01 != 2
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cadastro de Fornecedores                                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea( "SA2" )

			aFiliais := FWAllFilial(, , cEmpAnt, .F.)

			For nI := 1 to len(aFiliais)
				If Empty(mv_par05)
					dbGotop()
				Else
					dbSetOrder(1)
					MsSeek(xFilial("SA2", aFiliais[nI])+mv_par05,.T.)
				EndIf

				While !Eof() .And. (SA2->A2_COD >= mv_par05 .And. SA2->A2_COD <= mv_par06) .And. xFilial("SA2", aFiliais[nI]) == SA2->A2_FILIAL
					If !lBat
						If oProcess <> Nil
							oProcess:IncRegua1("Selecionando Registros...")
							oProcess:IncRegua2()
						EndIf
					EndIf

					If SA2->A2_COD >= mv_par05 .And. SA2->A2_COD <= mv_par06
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Ponto de entrada para filtro dos registros                      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If l410FT
							lRet := ExecBlock("FIN410FT",.F.,.F.,{mv_par01,"2"})
							If !lRet
								dbSkip()
								Loop
							EndIf
						Endif
						Reclock( "SA2" )
						SA2->A2_SALDUP  := 0
						SA2->A2_SALDUPM := 0
						SA2->A2_MCOMPRA := 0
						If FieldPos("A2_MNOTA") <> 0
							SA2->A2_MNOTA   := 0
						EndIf
						If mv_par02 == 1
							SA2->A2_NROCOM := 0
						EndIf
						MsUnlock()
					Endif
					dbSkip( )
				Enddo
			Next nI

			If lBat .And. lLibSchedule
				If oProcess <> Nil
					oProcess:IncRegua1()
				EndIf
			EndIf

		EndIf

		// Busca primeira filial do SIGAMAT
		DbSelectArea("SM0")
		DbGoTOp()
		DbSeek(cEmpAnt)
		cFirstFIL := Iif( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Titulos a Receber - Atualiza saldos clientes                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If mv_par01 != 3
			dbSelectArea( "SE1" )
			dbSetOrder(2) // E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
			If Empty(mv_par03)
				dbGotop()
			Else
				If lFilSA1C  // Se filial SA1 for totalmente compartilhada, varrer todas filiais da SE1
					MsSeek(FWxFilial("SE1",cFirstFIL) + mv_par03,.T.)
				Else
					MsSeek(FWxFilial("SE1")+mv_par03,.T.)
				EndiF					
			EndIf

			nMaiorVDA := 0

			While !Eof() .And. ((SE1->E1_CLIENTE >= mv_par03 .And. SE1->E1_CLIENTE <= mv_par04) .OR. lFilSA1C)
				If !lBat
					If oProcess <> Nil
						oProcess:IncRegua1("Selecionando Registros...")
						oProcess:IncRegua2()
					EndIf
				EndIf

				If SE1->E1_CLIENTE >= mv_par03 .And. SE1->E1_CLIENTE <= mv_par04
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ No caso dos modulos Sigaloja e Front Loja nao atualiza³
					//³ os saldos de duplicatas para o cliente padrao	 	  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If (nModulo == 12 ) .OR. ( nModulo == 72)
						If cCliPad + cLojaPad == SE1->E1_ClIENTE + SE1->E1_LOJA
							SE1->(DbSkip())
							Loop
						EndIf
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Ponto de entrada para filtro dos registros                      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If l410FT
						lRet := ExecBlock("FIN410FT",.F.,.F.,{mv_par01,"3"})
						If !lRet
							dbSkip()
							Loop
						EndIf
					Endif
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza Saldo do Cliente                                             ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					dbSelectArea( "SA1" )

					If lGestao
						lFilExc := ( !Empty( FWFilial("SA1") ) .and. !Empty( FWFilial("SE1") ) )
					Else
						lFilExc := !Empty( xFilial( "SA1" ) ) .and. !Empty( xFilial( "SE1" ) )
					EndIf

					If lFilExc
						cFilBusca := SE1->E1_FILIAL		// Ambos exclusivos, neste caso
						// a filial serah 1 para 1
					Else
						cFilBusca := xFilial("SA1",SE1->E1_FILORIG)		// filial do cliente (SA1)
					Endif

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Monta a chave de busca para o SA1    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cChaveSe1 := cFilBusca + SE1->E1_CLIENTE+ SE1->E1_LOJA

					dbSelectArea( "SA1" )
					If (dbSeek( cChaveSe1 ) )
						If !(SA1->(A1_FILIAL+A1_COD+A1_LOJA) ==  cCliente)
							cCliente     := SA1->(A1_FILIAL+A1_COD+A1_LOJA)
							nMaiorVDA    := 0
							nMaiorVDAaux := 0
							nMSaldo      := 0
						EndIf

						nMoedaF	  := If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC,nMoeda)
						nTaxaM	  := Round(SE1->E1_VLCRUZ/SE1->E1_VALOR,3)
						nValLiq   := xMoeda(SE1->E1_VALLIQ,SE1->E1_MOEDA,nMoedaF,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
						nValSld   := xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,nMoedaF,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)

						If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVABATIM+"/"+MVIRABT+"/"+MVFUABT+"/"+MVINABT+"/"+MVISABT+"/"+MVPIABT+"/"+MVCFABT
							AtuSalDup("-",SE1->E1_SALDO,SE1->E1_MOEDA,SE1->E1_TIPO,Iif(nTaxaM==1,Nil,nTaxaM),SE1->E1_EMISSAO)
						Else
							nSaldoTit := SE1->E1_SALDO
							nSaldoTit := Iif(nSaldoTit < 0, 0, nSaldoTit)
							IF !(SE1->E1_TIPO $ MVPROVIS)
								AtuSalDup("+",nSaldoTit,SE1->E1_MOEDA,SE1->E1_TIPO,Iif(nTaxaM==1,Nil,nTaxaM),SE1->E1_EMISSAO)
							Endif
							Reclock( "SA1" )
							If (!__lRskActv .or. !(AllTrim(SA1->A1_COD) + AllTrim(SA1->A1_LOJA) == AllTrim(__cRskCPay)))
								SA1->A1_PRICOM  := Iif(SE1->E1_EMISSAO<A1_PRICOM.or.Empty(A1_PRICOM),SE1->E1_EMISSAO,A1_PRICOM)
								If mv_par02 == 1  //Refaz dados Historicos
									SA1->A1_ULTCOM  := Iif(A1_ULTCOM<SE1->E1_EMISSAO,SE1->E1_EMISSAO,A1_ULTCOM)
								Endif
							Endif

							If Year(SE1->E1_EMISSAO) == Year(dDataBase) .And. !("FINA280" $ AllTrim(Upper(SE1->E1_ORIGEM))) .AND. (!__lRskActv .or. !(AllTrim(SA1->A1_COD) + AllTrim(SA1->A1_LOJA) == AllTrim(__cRskCPay)))
								If lRastro
									// Se for desdobramento por rastreamento (FI7/FI8), verifica se nao eh baixa por desdobramento
									FI7->( dbSetOrder( 1 ) )
									If !FI7->( MsSeek( xFilial("FI7") + SE1->( E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA ) ) )
										SA1->A1_VACUM += xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,nMoedaF,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
									EndIf
								Else
									SA1->A1_VACUM += xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,nMoedaF,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
								EndIf
							Endif

							IF !(SE1->E1_TIPO $ MVPROVIS)

								If AllTrim(Upper(SE1->E1_ORIGEM)) == "MATA460"
									SF2->(dbSetOrder(2))
									cFilSF2 := If ( lE1Msfil .and. !Empty(xFilial("SF2")) .AND. !EMPTY(SE1->E1_MSFIL) , SE1->E1_MSFIL , xFilial("SF2"))
									If !SF2->( MsSeek(cFilSF2+SE1->(E1_CLIENTE+E1_LOJA+E1_NUM+E1_PREFIXO)))
										// Se nao encontrou a nota, procura pela serie da nota ao inves do prefixo (MV_1DUPREF customizado)
										SF2->( MsSeek(cFilSF2+SE1->(E1_CLIENTE+E1_LOJA+E1_NUM+E1_SERIE)))
									Endif
									If SF2->(!EoF())
										nMaiorVDAaux := xMoeda(SF2->F2_VALFAT,SE1->E1_MOEDA,nMoedaF,SE1->E1_EMISSAO)
										If nMaiorVDA < nMaiorVDAaux
											nMaiorVDA := nMaiorVDAaux
										Endif
									Endif
								Else
									nMaiorVDA := xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,nMoedaF,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
								Endif

								nValForte := xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,nMoedaF,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
								If nValForte > SA1->A1_MAIDUPL .and. mv_par02 == 1  .AND. (!__lRskActv .or. !(AllTrim(SA1->A1_COD) + AllTrim(SA1->A1_LOJA) == AllTrim(__cRskCPay))) //refaz dados historicos
									If lRastro
										// Se for desdobramento por rastreamento (FI7/FI8), verifica se nao eh baixa por desdobramento
										FI7->( dbSetOrder( 1 ) )
										If !FI7->( MsSeek( xFilial("FI7")+SE1->( E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA ) ) )
											SA1->A1_MAIDUPL := nValForte
										EndIf
									Else
										SA1->A1_MAIDUPL := nValForte
									EndIf
								EndIF

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza Atrasos/Pagamentos em Atraso do Cliente  - 07/12/95     ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								aBaixas:=Baixas(SE1->E1_NATUREZ,SE1->E1_PREFIXO,SE1->E1_NUM,;
									SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_MOEDA,"R",SE1->E1_CLIENTE,;
									dDataBase,SE1->E1_LOJA,SE1->E1_FILIAL)
								If mv_par02 == 1 .and. (Empty(SE1->E1_FATURA) .Or. Substr(SE1->E1_FATURA,1,6) = "NOTFAT") .And.;
										STR(SE1->E1_SALDO,17,2) != STR(SE1->E1_VALOR,17,2) .and.;
										(!__lRskActv .or. !(AllTrim(SA1->A1_COD) + AllTrim(SA1->A1_LOJA) == AllTrim(__cRskCPay)))
									If lRastro
										// Se for desdobramento por rastreamento (FI7/FI8), verifica se nao eh baixa por desdobramento
										FI7->( dbSetOrder( 1 ) )
										If !FI7->( MsSeek( xFilial("FI7")+SE1->( E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA ) ) )
											SA1->A1_NROPAG += aBaixas[11]
										EndIf
									Else
										SA1->A1_NROPAG += aBaixas[11]
									EndIf
								Endif
								If SE1->E1_SALDO == 0
									If (Empty(SE1->E1_FATURA) .Or. Substr(SE1->E1_FATURA,1,6) = "NOTFAT")
										If (SE1->E1_BAIXA - SE1->E1_VENCREA) > 0 .and. mv_par02 == 1
											SA1->A1_PAGATR += nValLiq
										Endif
									Endif
								Else
									If SE1->E1_VENCREA < dDatabase .and. mv_par02 == 1 .and. (!__lRskActv .or. !(AllTrim(SA1->A1_COD) + AllTrim(SA1->A1_LOJA) == AllTrim(__cRskCPay)))
										If SA1->A1_RISCO = "D"
											If dDatabase - SE1->E1_VENCREA > nRiscod
												SA1->A1_ATR += nValSld
											EndIf
										Else
											SA1->A1_ATR += nValSld
										EndIF
									Endif
								Endif

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza Dados Historicos                                        ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If mv_par02 == 1 .AND. (!__lRskActv .or. !(AllTrim(SA1->A1_COD) + AllTrim(SA1->A1_LOJA) == AllTrim(__cRskCPay)))

									//A1_MSALDO - Maior saldo de duplicatas do Cliente
									//A1_METR - Media de atrasos do Cliente
									//A1_MATR - Maior atraso do Cliente

									If nMaiorVDA > SA1->A1_MCOMPRA 
										SA1->A1_MCOMPRA := nMaiorVDA
									Endif

									// Nao incrementa faturas a receber (FINA280)
									If !("FINA280" $ AllTrim(Upper(SE1->E1_ORIGEM))) 
										If !Empty(SE1->E1_PEDIDO)
											// Se existe pedido de vendas, somente incrementa se for um pedido diferente do titulo anterior
											If cNumPedVen != SE1->E1_PEDIDO 
												SA1->A1_NROCOM  += 1
											EndIf
										Else
											If lRastro
												// Se for desdobramento por rastreamento (FI7/FI8), verifica se nao eh baixa por desdobramento
												FI7->( dbSetOrder( 1 ) )
												If !FI7->( MsSeek( xFilial("FI7")+SE1->( E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA ) ) ) 
													SA1->A1_NROCOM  += 1
												EndIf
											Else
												// Se nao existe pedido, entao incrementa como titulo normal do Financeiro
													SA1->A1_NROCOM  += 1
											EndIf
										EndIf
									EndIf

									If SE1->E1_SALDO > 0
										nMSaldo += xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,nMoedaF,SE1->E1_EMISSAO)
									EndIf

									If SA1->A1_SALDUPM > SA1->A1_MSALDO 
										SA1->A1_MSALDO := SA1->A1_SALDUPM
									Else
										If nMSaldo > SA1->A1_MSALDO
											SA1->A1_MSALDO := nMSaldo
										EndIf
									EndIf

									IF Empty(SE1->E1_FATURA) .Or. Substr(SE1->E1_FATURA,1,6) = "NOTFAT"
										If (SE1->E1_BAIXA - SE1->E1_VENCREA) > SA1->A1_MATR
											If lRastro
												If !FI7->( MsSeek( xFilial("FI7")+SE1->( E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA ) ) )
													SA1->A1_MATR := SE1->E1_BAIXA - SE1->E1_VENCREA
												EndIf
											Else
												SA1->A1_MATR := SE1->E1_BAIXA - SE1->E1_VENCREA
											EndIf
										EndIf
										If !Empty(SE1->E1_BAIXA) 
											SA1->A1_METR := (SA1->A1_METR * (SA1->A1_NROPAG-1) + (SE1->E1_BAIXA - SE1->E1_VENCREA))/ SA1->A1_NROPAG
										Endif
									Endif
								Endif
								MsUnlock( )
							Endif
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Funcao para ajustar os campos do SA1 para vendas³
							//³que possuem Administradora Financeira e         ³
							//³apenas para o modulo SIGALOJA                   ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							F410AjusLj(nMaiorVDA,cNumPedVen,nMoedaF)
						Endif
					Endif
				Endif
				cNumPedVen := SE1->E1_PEDIDO
				dbSelectArea( "SE1" )
				dbSkip()
			Enddo
			
			If lBat .And. lLibSchedule
				If oProcess <> Nil
					oProcess:IncRegua1()
				EndIf
			EndIf

		EndIf
		If mv_par01 != 2
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Titulos a Pagar - atualiza saldos fornecedores                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea( "SE2" )
			dbSetOrder(6)
			If Empty(mv_par05)
				dbGotop()
			Else
				If lFilSA2C  // Se filial SA2 for totalmente compartilhada, varrer todas filiais da SE2
					MsSeek(FWxFilial("SE2",cFirstFIL)+mv_par05,.T.)
				Else
					MsSeek(FWxFilial("SE2")+mv_par05,.T.)
				EndiF
				nCtnumpag:= 1
				nMetr := 0
			EndIf

			While !Eof() .And.((SE2->E2_FORNECE >= mv_par05 .And. SE2->E2_FORNECE<= mv_par06) .OR. lFilSA2C)
				If !lBat
					If oProcess <> Nil
						oProcess:IncRegua1("Selecionando Registros...")
						oProcess:IncRegua2()
					EndIf
				EndIf

				IF cFornP != Alltrim (SE2->E2_FORNECE)
					nCtnumpag:= 1
					nMetr := 0
				ENDIF


				If SE2->E2_FORNECE >= mv_par05 .And. SE2->E2_FORNECE<= mv_par06
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Ponto de entrada para filtro dos registros                      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If l410FT
						lRet := ExecBlock("FIN410FT",.F.,.F.,{mv_par01,"4"})
						If !lRet
							dbSkip()
							Loop
						EndIf
					Endif
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza Saldo do Fornecedor                                          ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					dbSelectArea( "SA2" )

					If lGestao
						lFilExc := ( !Empty( FWFilial("SA2") ) .and. !Empty( FWFilial("SE2") ) )
					Else
						lFilExc := ( !Empty( xFilial("SA2") ) .and. !Empty( xFilial("SE2") ) )
					EndIf

					If lFilExc
						cFilBusca := SE2->E2_FILIAL		// Ambos exclusivos, neste caso
						// a filial serah 1 para 1
					Else
						cFilBusca := xFilial("SA2",SE2->E2_FILORIG)		// filial do fornecedor (SA2)
					Endif

					If (dbSeek( cFilBusca+SE2->E2_FORNECE+SE2->E2_LOJA ) )
						Reclock( "SA2" )
						If  SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG+"/"+MVABATIM
							SA2->A2_SALDUP  -= xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,SE2->E2_EMISSAO)
							SA2->A2_SALDUPM -= xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO)
							SA2->A2_MCOMPRA := Max(SA2->A2_MCOMPRA,Round(NoRound(xMoeda(SE2->E2_VALOR,1,nMCusto,SE2->E2_EMISSAO,3),3),2) )
						Else
							SA2->A2_SALDUP  += xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,SE2->E2_EMISSAO)
							SA2->A2_SALDUPM += xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoeda,SE2->E2_EMISSAO)
							SA2->A2_PRICOM  := Iif(SE2->E2_EMISSAO<A2_PRICOM .or. empty(A2_PRICOM),SE2->E2_EMISSAO,A2_PRICOM)
							SA2->A2_ULTCOM  := Iif(A2_ULTCOM<SE2->E2_EMISSAO,SE2->E2_EMISSAO,A2_ULTCOM)
							SA2->A2_MCOMPRA := Max(SA2->A2_MCOMPRA,Round(NoRound(xMoeda(SE2->E2_VALOR,1,nMCusto,SE2->E2_EMISSAO,3),3),2) )
							IF ! EMPTY (SE2->E2_BAIXA)
								nMetr += SE2->E2_BAIXA - SE2->E2_VENCREA
								SA2->A2_METR := nMetr / nCtnumpag
								nCtnumpag += 1
								cFornP := Alltrim (SE2->E2_FORNECE)
							endif

							If mv_par02 == 1
								If !("FINA290" $ AllTrim(Upper(SE2->E2_ORIGEM))) .AND. (!__lRskActv .or. !(AllTrim(SA2->A2_COD) +  AllTrim(SA2->A2_LOJA) == AllTrim(__cRskFPay)))
									SA2->A2_NROCOM += 1
								EndIf
								If SA2->A2_SALDUPM > SA2->A2_MSALDO
									SA2->A2_MSALDO := A2_SALDUPM
								EndIf
							EndIf
						EndIf
						If FieldPos("A2_MNOTA") <> 0
							If SubStr(SE2->E2_ORIGEM,1,3) == "FIN"
								SA2->A2_MNOTA   := Max(SA2->A2_MNOTA,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2) )
							Else
								DbSelectArea("SF1")
								DbSetOrder(1)
								DBSeek(xFilial("SF1")+SE2->E2_NUM+SE2->E2_PREFIXO+SE2->E2_FORNECE+SE2->E2_LOJA)
								SA2->A2_MNOTA   := Max(SA2->A2_MNOTA,Round(NoRound(xMoeda(SF1->F1_VALBRUT,SF1->F1_MOEDA,nMCusto,SF1->F1_EMISSAO,3),3),2) )
							EndIf
						EndIf
						MsUnlock()
					EndIf
				Endif
				dbSelectArea("SE2")
				SE2->( dbSkip())
			Enddo

			If lBat .And. lLibSchedule
				If oProcess <> Nil
					oProcess:IncRegua1()
				EndIf
			EndIf

		EndIf
		dbSelectArea( "SE1" )
		dbSetOrder(1)
		MsUnlockAll()

	Endif

	if !lBat
		EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, "044", FW_EV_LEVEL_INFO, "", STR0013, STR0014, .T. )
	endIf

Return


/*/{Protheus.doc}  VerIDProc
	Identifica a sequencia de controle do fonte ADVPL com a	stored procedure, qualquer
	alteracao que envolva diretamente a stored procedure a variavel sera incrementada.
	Procedure FIN003
	Processo 09 - REFAZ SALDOS DE CLIENTES / FORNECEDORES
	@type  Static Function
	@author Marcelo Pimentel
	@since 24/07/2007
	@version 
	@param 
	@return character, Retorna a assinatura da rotina
/*/      
Static Function VerIDProc()
Return '013'

/*/
	ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
	±±³Funcao    ³F410AjusLj    ³ Autor ³ Vendas e CRM		    ³ Data ³22.09.2008³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Descri‡…o ³Faz algumas alteracoes para que os campos referentes ao         ³±±
	±±³          ³titulo/duplicata  que foram gravados no regostrp da             ³±±
	±±³          ³administradora financeira sejam gravados no registro do         ³±±
	±±³          ³cliente da venda                                                ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±³Parametros³ ExpN1 - Maior Venda      					                  ³±±
	±±³			 ³ ExpC2 - Numero do Pedido                                       ³±±
	±±³			 ³ ExpN3 - Moeda Forte                                            ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³Retorno   ³ Nil                                                            ³±±
	±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³ Uso      ³ SigaLoja                                                       ³±±
	±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
	±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/         
Static Function F410AjusLj(nMaiorVDA,cNumPedVe,nMoedaF)

	Local lE1MsFil  As Logical
	Local cFilSF2   As Character
	Local cFilBusca As Character

	DEFAULT nMaiorVDA   := 0
	DEFAULT cNumPedVe   := ""
	DEFAULT nMoedaF		:= Int(Val(SuperGetMv("MV_MCUSTO",,"") ))

	lE1MsFil 	:= SE1->(FieldPos("E1_MSFIL") > 0)	// Verifica se existe o campo E1_MSFIL
	cFilSF2  	:= xFilial("SF2") 					// Filial do SF2
	cFilBusca	:= "  "								// Filial de busca a ser preenchida de acordo  com a condicao

	
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso pertenca a um dos tipos abaixo grava algumas informacoes         ³
//³no registro do cliente que efetuou a compra.                          ³
//³Cartao Credito, Vales, Convenio,Cartao de Debito,Financiamento Proprio³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Upper(subs(SE1->E1_ORIGEM,1,3)) == "LOJ" .AND. ALLTRIM( SE1->E1_TIPO)  $ "CC;VA;CO;CD;FI"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Primeiramente busca se este titulo foi³
		//³gerado a partir de uma venda ( SF2 )  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SF2")
		DbSetOrder(1)
		cFilSF2 := IIf(lE1Msfil .AND. !Empty(xFilial("SF2")),SE1->E1_MSFIL,xFilial("SF2"))
		If DbSeek(cFilSF2+SE1->E1_NUM +SE1->E1_PREFIXO)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Caso o cliente do titulo seja diferente da venda siginifica ³
			//³que eh uma administradora e nao eh financiamento prorpio    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (SF2->F2_CLIENTE + SF2->F2_LOJA) <> (SE1->E1_CLIENTE + SE1->E1_LOJA)
				DbSelectArea("SA1")
				DbSetOrder(1)
				If !Empty(xFilial("SA1")) .AND. !Empty(xFilial("SE1"))
					cFilBusca := SE1->E1_FILIAL			// Ambos exclusivos, neste caso a filial serah 1 para 1
				Else
					cFilBusca := xFilial("SA1")			// filial do cliente (SA1)
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Posiciona o cliente da venda e faz a gravacao dos campos referentes a venda ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If DbSeek(cFilBusca + SF2->F2_CLIENTE+ SF2->F2_LOJA) .AND. (!__lRskActv .or. !(AllTrim(SA1->A1_COD) + AllTrim(SA1->A1_LOJA) == AllTrim(__cRskCPay)))
					RecLock("SA1",.F.)
					If( SE1->E1_EMISSAO < SA1->A1_PRICOM .OR. Empty(SA1->A1_PRICOM) )
						REPLACE SA1->A1_PRICOM  WITH SE1->E1_EMISSAO
					EndIf
					If MV_PAR02 == 1  					//Refaz dados Historicos
						If(SA1->A1_ULTCOM < SE1->E1_EMISSAO)
							REPLACE SA1->A1_ULTCOM  WITH SE1->E1_EMISSAO
						EndIf
						If nMaiorVDA > SA1->A1_MCOMPRA
							REPLACE SA1->A1_MCOMPRA WITH nMaiorVDA
						EndIf
					Endif
					If Year(SE1->E1_EMISSAO) == Year(dDataBase) .AND. !("FINA280" $ AllTrim(Upper(SE1->E1_ORIGEM)))
						REPLACE SA1->A1_VACUM WITH SA1->A1_VACUM += xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,nMoedaF,SE1->E1_EMISSAO)
					Endif
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Numero de compras efetuadas pelo cliente na empresa.     ³
					//³ O sistema soma autonáticamente um a cada pedido de venda.³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

					If !("FINA280" $ AllTrim(Upper(SE1->E1_ORIGEM)))
						If !Empty(SE1->E1_PEDIDO)
							If cNumPedVe <> SE1->E1_PEDIDO
								REPLACE SA1->A1_NROCOM WITH SA1->A1_NROCOM += 1
							EndIf
						Else
							REPLACE SA1->A1_NROCOM WITH SA1->A1_NROCOM += 1
						EndIf
						MsUnlock()
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

Return(Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Estornos  ºAutor  ³ Rodrigo Oliveira  º Data ³  13/04/16   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Calcula a quantidade de estornos de um título na SE5 -     º±±
±±º          ³ Tabela de Mov. Bancário.                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA410                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function ESTORNE5(cNatureza,cPrefixo,cNumero,cParcela,cTipo,nMoeda,cModo,cFornec,dData,cLoja,cFilTit,dDtIni,dDtFin,lConsDtBas)

	Local cArea   		:= Alias()
	Local aArea			:= getArea()
	Local nOrdem  		:= 0
	Local lDataNil 		:= ( dData == Nil )
	Local cQuery		:= ""
	Local cAliasSE5		:= getNextAlias()
	Local nRetorno		:= 0

	Default cFilTit		:= xFilial("SE5")
	Default lConsDtBas 	:= .T.

// Quando eh chamada do Excel, estas variaveis estao em branco
	IF Empty(MVABATIM) .Or.;
			Empty(MV_CRNEG) .Or.;
			Empty(MVRECANT) .Or.;
			Empty(MV_CPNEG) .Or.;
			Empty(MVPAGANT) .Or.;
			Empty(MVPROVIS)
		CriaTipos()
	Endif

	cFornec	:= IIF( cFornec == NIL , "", cFornec )
	cLoja 	:= IIF( cLoja == NIL , "" , cLoja )
	nMoeda	:= IIf( nMoeda == NIL , 1 , nMoeda )

	dData	:= IIf( lDataNil , dDataBase , dData )
	dDtIni	:= IIf( dDtIni == NIL ,CTOD("//") , dDtIni )
	dDtFin	:= IIf( dDtFin == NIL ,CTOD("//") , dDtFin )

	#ifdef TOP
		If ( TcSrvType()!="AS/400" )
			cQuery := " SELECT COUNT(E5_NUMERO) TOT "
			cQuery += " FROM "+RetSqlName("SE5")
			cQuery += Iif(FunName() $ "FINR350" .And. !Empty(cFilTit), " WHERE (E5_FILIAL = '"+cFilTit+"' OR E5_FILORIG = '"+cFilTit+"') ", " WHERE E5_FILIAL = '"+cFilTit+"' ")
			cQuery += " AND E5_PREFIXO = '"+cPrefixo+"' "
			cQuery += " AND E5_NUMERO = '"+cNumero+"' "
			cQuery += " AND E5_PARCELA = '"+cParcela+"' "
			cQuery += " AND E5_TIPO = '"+cTipo+"' "
			cQuery += " AND E5_CLIFOR = '"+cFornec+"' "
			cQuery += " AND E5_LOJA = '"+cLoja+"' "
			cQuery += " AND ( E5_SITUACA = 'C' "
			cQuery += " OR E5_TIPODOC = 'ES' ) "
			IF lConsDtBas
				If lDataNil
					cQuery += " AND ( E5_DATA <= '" + DtoS(dDataBase) + "' "
				Else
					cQuery += " AND ( E5_DATA <= '" + Dtos(Min( dData , dDataBase) ) + "' "
				Endif
				cQuery += " ) "
			Endif
			If !Empty(dDtIni)
				cQuery += " AND ( E5_DATA BETWEEN '"+DtoS(dDtIni)+"' AND '"+DtoS(dDtFin)+"' ) "
			Endif

			cQuery += " AND D_E_L_E_T_ = ' ' "

			dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasSE5 , .F., .T.)

			If (cAliasSE5)->( !EOF() )
				nRetorno := (cAliasSE5)->TOT
			EndIf

			(cAliasSE5)->( dbCloseArea() )
		Else
		#ENDIF
		dbSelectArea("SE5")
		nOrdem:=IndexOrd()
		dbSetOrder(7)
		If MsSeek(cFilTit+cPrefixo+cNumero+cParcela+cTipo)

			While cFilTit+cPrefixo+cNumero+cParcela+cTipo==SE5->E5_FILIAL+;
					SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO

				If SE5->E5_SITUACA = "C" .or. ;
						SE5->E5_TIPODOC = "ES"
					nRetorno += 1
				EndIf
				dbSkip()
			Enddo
		Endif
		dbSetOrder(nOrdem)
		dbSelectArea(cArea)
		#IFDEF TOP
		EndIf
	#Endif

	RestArea(aArea)

Return(nRetorno)

/*/{Protheus.doc} SchedDef
Utilizado somente se a rotina for executada via Schedule.
Permite usar o botao Parametros da nova rotina de Schedule
para definir os parametros(SX1) que serao passados a rotina agendada.
@author  TOTVS
@version 12.1.17
@since   05/06/2017
@return  aParam
/*/
Static Function SchedDef(  )
	Local aParam := {}

	aParam := {	"P"	,;	 //Tipo R para relatorio P para processo
	"AFI410",;	 //Nome do grupo de perguntas (SX1)
	Nil,;	 //cAlias (para Relatorio)
	Nil,;	 //aArray (para Relatorio)
	Nil   } //Titulo (para Relatorio)


Return aParam


//-----------------------------------------------------------------------
/*/{Protheus.doc} EngSPS09Signature
Função para retornar assinatura da rotina - Processo 09 - REFAZ SALDOS DE CLIENTES / FORNECEDORES
@author  Norberto M de Melo
@since   20/12/2021
@version 1.0
/*/
//-----------------------------------------------------------------------
Function EngSPS09Signature(cProcess as character) as character
	Local cAssinatura as character

	cAssinatura := VerIDProc()

Return cAssinatura
//-----------------------------------------------------------------------


/*/{Protheus.doc}  newTR
	Cria no banco de dados as tabelas de classe TR
	@type  Static Function
	@author guilherme.sordi
	@since 22/06/2022
	@version 12.1.33
	@param cEmpresa, character, Opcional - Código do grupo de empresa que está sendo processado
	@return logical, Retorna true se o processo foi concluído com sucesso
/*/
static function newTR(cEmpresa as character) as logical
	local lRet as logical
	local cTRRName as character
	local aTRRStru as array

	default cEmpresa := cEmpAnt

	lRet := .F.
	cTRRName := "TRR" + cEmpresa + "SP09"
	aTRRStru := getTRRStru()

	if TCCanOpen(cTRRName)
		TcDelFile(cTRRName)
	endIf

	EngSPSWorkTable("", cTRRName, aTRRStru, .T.)

	if TCCanOpen(cTRRName)
		__cTRRName := cTRRName
		lRet := .T.
	endIf

return lRet


/*/{Protheus.doc}  dropTR
	Exclui do banco de dados as tabelas de classe TR
	@type  Static Function
	@author guilherme.sordi
	@since 22/06/2022
	@version 12.1.33
	@param cEmpresa, character, Opcional - Código do grupo de empresa que está sendo processado
	@return logical, Retorna true se o processo foi concluído com sucesso
/*/
static function dropTR(cEmpresa as character) as Logical

	local cTRRName as character

	default cEmpresa := cEmpAnt

	cTRRName := "TRR" + cEmpresa + "SP09"

	if TCCanOpen(cTRRName)
		TcDelFile(cTRRName)
	endIf

return .T.


/*/{Protheus.doc} getTRRStru
	Retorna a estrutura que será usada na tabela TRR
	@type  Static Function
	@author guilherme.sordi
	@since 22/06/2022
	@version 12.1.33
	@param cEmpresa, character, Opcional - Código do grupo de empresa que está sendo processado
	@return logical, Retorna true se o processo foi concluído com sucesso
/*/
static function getTRRStru() as Array
	local aRet as array

	aRet := {}

	aAdd(aRet,{ "TRR_ID", "N", 15, 0 } )
	AADD(aRet,{ "TRR_FILIAL", "C", FWSizeFilial(), 0 } )

return aRet


/*/{Protheus.doc} loadTRRFil
	Alimenta a tabela TRR com as filiais que serão processadas na SP 
	@type  Static Function
	@author guilherme.sordi
	@since 22/06/2022
	@version 12.1.33
	@param cEmpresa, character, Opcional - Código do grupo de empresa que está sendo processado
	@return logical, Retorna true se o processo foi concluído com sucesso
/*/
static function loadTRRFil() as Variant
	local aFiliais as array
	local nX as numeric
	local cQuery as character

	aFiliais := FWAllFilial(, , cEmpAnt, .F.)
	nX := 1
	cQuery := ""

	cQuery := "DELETE FROM "+ __cTRRName
	TcSqlExec(cQuery)

	for nX := 1 to len(aFiliais)
		cQuery := "INSERT INTO "+ __cTRRName +" (TRR_ID, TRR_FILIAL) VALUES (" + CValToChar(nX) + ", '"+ aFiliais[nX] +"')"
		TcSqlExec(cQuery)
	next nX
return NIL


/*/{Protheus.doc} EngPre09Compile
 	Será executado antes da compilação das procedures
	@type function
	@version 1.0
	@author guilherme.sordi
	@since 23/06/2022
	@param cProcesso, character, Codigo do processo
	@param cEmpresa, character, Codigo da empresa
	@param cError, character, Passada por referencia, deve conter a mensagem de erro caso ocorra
	@return logical, Retorna true se o processo foi concluído com sucesso
/*/
Function EngPre09Compile(cProcesso as character, cEmpresa as character, cError as character) as Logical

	newTR(cEmpresa)

Return .T.

/*/{Protheus.doc} EngOn09Compile
	Será executado durante a compilação das procedures
	@type function
	@version 1.0
	@author guilherme.sordi
	@since 23/06/2022
	@param cProcesso, character, Codigo do processo
	@param cEmpresa, character, Codigo da empresa
	@param cProcName, character, Nome da stored procedure
	@param cBuffer, character, Codigo original da procedure (corpo da procedure)
	@param cError, character, Passada por referencia, deve conter a mensagem de erro caso ocorra
	@return logical, Retorna true se o processo foi concluído com sucesso
/*/
Function EngOn09Compile(cProcesso as character, cEmpresa as character, cProcName as character, cBuffer as character, cError as character) as Logical

	// Faz a troca das tags "###" nos nomes de tabelas especificas do processo
	cBuffer := StrTran( cBuffer, "TRR###", "TRR" + cEmpresa + "SP09" )

Return .T.

/*/{Protheus.doc} EngSPS19Delete
	Será executado após compilação das procedures
	@type function
	@version 1.0
	@author guilherme.sordi
	@since 23/06/2022
	@param cProcesso, character, Codigo do processo
	@param cEmpresa, character, Codigo da empresa
	@param cError, character, Passada por referencia, deve conter a mensagem de erro caso ocorra
	@return logical, Retorna true se o processo foi concluído com sucesso
/*/
Function EngSPS09Delete(cProcesso as character, cEmpresa as character, cError as character) as Logical

	dropTR(cEmpresa)

Return .T.
