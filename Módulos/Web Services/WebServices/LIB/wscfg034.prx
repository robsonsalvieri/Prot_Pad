#INCLUDE "wscfg034.ch"
#INCLUDE "APWEBSRV.CH"
#INCLUDE "PROTHEUS.CH"

#DEFINE ROWS_PER_PAGE 19

Static cEmpSelec := ""

/*******************/
FUNCTION WSCFG034()
RETURN
/*******************/


/*/


Ŀ
Funo     WSCFG034   Autor Eduardo Riera           Data 15.09.2003 
Ĵ
Descrio   Web Service responsavel pelo dicionario do sistema          
                                                                        
Ĵ
Sintaxe                                                                 
Ĵ
Parametros                                                              
Ĵ
Uso                                                                     
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data   Chamado  Motivo da Alteracao                    
Ĵ
 Allyson M    22/10/14 TQUQESCriacao do metodo GetAccessMode p/ ver se
                             a tabela e' compartilhada e alteracao do 
                             GetParam p/ passar a filial.             
 Gabriel A.   22/10/14 TRIDGRCriao de funo para verificar se      
                             possui uma expresso no filtro           
 Matheus M.   22/10/14 TTQAXTMonta consulta padro dinmica eSocial   
                             Portal (CC2RES).                         
ٱ


/*/
WSSTRUCT X1DataView
	WSDATA X1Order				As String
	WSDATA X1Question				As String
	WSDATA X1Type					As String
	WSDATA X1Size					As Integer
	WSDATA X1GetOrCombo			As String
	WSDATA X1ComboSel				As Integer
	WSDATA ListOfX1Def			As Array Of X1DefView
ENDWSSTRUCT

WSSTRUCT X1DefView
	WSDATA X1DefDescription		As String
	WSDATA X1DefContent			As String
ENDWSSTRUCT

WSSTRUCT X1PutDataView
	WSDATA ListOfX1PutData	As Array Of X1Data
ENDWSSTRUCT

WSSTRUCT X1Data
	WSDATA X1Order				As String
	WSDATA X1GetOrCombo			As String
	WSDATA X1Type					As String
	WSDATA X1Content				As String
ENDWSSTRUCT

WSSTRUCT XBDataView
	WSDATA Alias					AS String

	WSDATA ListOfIndex			AS Array Of XBDataIndexView
	WSDATA ListOfColumn			AS Array Of XBDataColumnView
	WSDATA ListOfResult			AS Array Of XBDataResultView
	WSDATA PageCount				AS Integer
	WSDATA Title					AS String
ENDWSSTRUCT

WSSTRUCT XBDataIndexView
	WSDATA Sequence				AS String
	WSDATA Order					AS String
	WSDATA Description			AS String
ENDWSSTRUCT

WSSTRUCT XBDataColumnView
	WSDATA Sequence				AS String

	WSDATA ListOfField			AS Array Of XBDataFieldView
ENDWSSTRUCT

WSSTRUCT XBDataFieldView
	WSDATA Column					AS String
	WSDATA Description			AS String
	WSDATA Field					AS String
ENDWSSTRUCT

WSSTRUCT XBDataResultView
	WSDATA Sequence				AS String
	WSDATA Field					AS String
ENDWSSTRUCT

WSSTRUCT XBResultView
	WSDATA Sequence				AS String
	WSDATA Field					AS String
	WSDATA Value					AS String
ENDWSSTRUCT

WSSTRUCT XBDataDbView
	WSDATA ListOfField			AS Array Of XBDbFieldView
ENDWSSTRUCT

WSSTRUCT XBDbFieldView
	WSDATA Field					AS String
	WSDATA Description			AS String
	
	WSDATA ListOfValue			AS Array Of XBDbValueView OPTIONAL
ENDWSSTRUCT

WSSTRUCT XBDbValueView
	WSDATA Value					AS String OPTIONAL
	WSDATA Recno					AS Integer OPTIONAL
ENDWSSTRUCT

//Ŀ
//Definicao do Web Service                                                
//
WSSERVICE CFGDictionary DESCRIPTION STR0001 NAMESPACE "http://webservices.microsiga.com.br/cfgdictionary.apw" //"Servio de consulta ao dicionrio ( SXs ) do sistema"
	WSDATA Header          	AS Array Of BrwHeader
	WSDATA UserCode         	AS String
	WSDATA Table            	AS String
	WSDATA MvParam          	AS String
	WSDATA Branch          		AS String OPTIONAL
	WSDATA MvContent         	AS String
	WSDATA Indexes          	AS Array Of GenericStruct
	WSDATA Alias						AS String
	WSDATA X3Tamanho					AS Integer
	WSDATA UserField					AS Array Of UserField
	WSDATA XBAlias						AS String
	WSDATA XBData						AS XBDataView
	WSDATA Sequence					AS String
	WSDATA XBDataDb					AS XBDataDbView
	WSDATA Search						AS String OPTIONAL
	WSDATA Filtro						AS String OPTIONAL
	WSDATA RecNo						AS Integer
	WSDATA Field						AS String
	WSDATA Result						AS String
	WSDATA ListOfX1Data				As Array Of X1DataView
	WSDATA X1Group						As String
	WSDATA X1PutData					As X1PutDataView
	WSDATA WsNull						AS String
	WSDATA XBResult 					AS Array Of XBResultView
	WSDATA VerRPO						AS String
    WSDATA Confirm  	  	  	        AS Boolean
	WSDATA Page							AS Integer OPTIONAL
	WSDATA FileLog                      AS String OPTIONAL
	WSDATA MsgLog                       AS String OPTIONAL
	
	WSMETHOD GetHeader 				DESCRIPTION STR0002 //"Mtodo que descreve as estruturas de retorno do servio"
	WSMETHOD GetIndex  			DESCRIPTION STR0003 //"Mtodo de consulta aos indices do dicionrio do sistema"
	WSMETHOD GetParam  			DESCRIPTION STR0004 //"Mtodo de consulta aos parametros internos do sistema"
	WSMETHOD GetUserField
	WSMETHOD GetSXBData
	WSMETHOD GetSXBDataPage 
	WSMETHOD GetSXBResult
	WSMETHOD GetSXBDbData
	WSMETHOD GetSXBDbResult
	WSMETHOD GetSX1Param			DESCRIPTION STR0007 //"Mtodo de consulta o grupo de pergunta (SX1)"
	WSMETHOD PutSX1Param			DESCRIPTION STR0008 //"Mtodo que altera o grupo de pergunta do sistema (SX1)"
	WSMETHOD GetSX3FieldSize	DESCRIPTION "Mtodo que retorna o tamanho do campo no dicionario de dados (SX3)"
	WSMETHOD GetVerRelease		DESCRIPTION STR0009 //"Mtodo que confirma a release atual do produto"	
	WSMETHOD GetAccessMode
	WSMETHOD PutPLSLogFil	            DESCRIPTION "Mtodo que permite gerao de logs do PLS"
ENDWSSERVICE

/*/

Ŀ
Funo    GetHeader Autor   Eduardo Riera          Data 12.09.2003 
Ĵ
          Rotina de recuperacao do header do dicionario do sistema     
                                                                       
Ĵ
ParametrosNenhum                                                       
Ĵ
Retorno   ExpL1: Indica que o Mtodo foi avaliado com sucesso          
                                                                       
Ĵ
Descrio Este Mtodo devolve o header de uma estrutura                
                                                                       
                                                                       
Ĵ
Uso        CRM/Materiais/Portais                                       
ٱ


/*/
WSMETHOD GetHeader WSRECEIVE NULLPARAM WSSEND Header WSSERVICE CFGDictionary

Local nX    := 0

::HEADER := {}
aadd(::HEADER,WSClassNew("BrwHeader"))
nX++
::HEADER[nX]:HeaderTitle   := STR0005 //"Ordem"
::HEADER[nX]:HeaderField   := "CODE"
::HEADER[nX]:HeaderPicture := "@!"
::HEADER[nX]:HeaderSize    := 6
::HEADER[nX]:HeaderDec     := 0
::HEADER[nX]:HeaderType    := "C"
::HEADER[nX]:HeaderComboBox:= ""
::HEADER[nX]:HeaderOblig   := .F.

aadd(::HEADER,WSClassNew("BrwHeader"))
nX++
::HEADER[nX]:HeaderTitle   := STR0006 //"Chave"
::HEADER[nX]:HeaderField   := "DESCRIPTION"
::HEADER[nX]:HeaderPicture := "@!"
::HEADER[nX]:HeaderSize    := 30
::HEADER[nX]:HeaderDec     := 0
::HEADER[nX]:HeaderType    := "C"
::HEADER[nX]:HeaderComboBox:= ""         
::HEADER[nX]:HeaderOblig   := .F.

Return(.T.)
/*/

Ŀ
Funo    GetIndex  Autor   Eduardo Riera          Data 12.09.2003 
Ĵ
          Rotina de recuperacao dos indices do sistema                 
                                                                       
Ĵ
ParametrosExpC1: Codigo do usuario                                     
Ĵ
Retorno   ExpL1: Indica que o Mtodo foi avaliado com sucesso          
                                                                       
Ĵ
Descrio Este Mtodo devolve as tabelas padroes do sistema            
                                                                       
                                                                       
Ĵ
Uso        CRM/Materiais/Portais                                       
ٱ


/*/
WSMETHOD GetIndex WSRECEIVE UserCode,Table WSSEND Indexes WSSERVICE CFGDictionary

Local aArea    := GetArea()
Local lRetorno := .T.
Local nX       := 0

If PrtChkUser(::UserCode,"CFGDictionary","GetIndex")
	dbSelectArea("SIX")
	dbSetOrder(1)
	MsSeek(::Table)
	::Indexes := {}
	nX := 0
	While !Eof() .And. ::Table == SIX->INDICE
		nX++							
		aadd(::Indexes,WSClassNew("GenericStruct"))

		::Indexes[nX]:Code         := SixDescricao()
		::Indexes[nX]:Description  := SIX->CHAVE

		dbSelectArea("SIX")
		dbSkip()
	EndDo
Else
	lRetorno := .F.
EndIf
RestArea(aArea)
Return(lRetorno)

/*/

Ŀ
Funo    GetParam  Autor   Eduardo Riera          Data 12.09.2003 
Ĵ
          Rotina de recuperacao dos parametros do sistema              
                                                                       
Ĵ
ParametrosExpC1: Codigo do usuario                                     
Ĵ
Retorno   ExpL1: Indica que o Mtodo foi avaliado com sucesso          
                                                                       
Ĵ
Descrio Este Mtodo devolve um parametro do sistema                  
                                                                       
                                                                       
Ĵ
Uso        CRM/Materiais/Portais                                       
ٱ


/*/
WSMETHOD GetParam WSRECEIVE UserCode,MvParam,Branch WSSEND MvContent WSSERVICE CFGDictionary

Local aArea    := GetArea()
Local lRetorno := .T.

If PrtChkUser(::UserCode,"CFGDictionary","GetParam")
	
	::MvContent := AllToChar(SuperGetMV(::MvParam, .F., Nil, Branch))
	
Else

	lRetorno := .F.
EndIf

RestArea(aArea)
Return(lRetorno)

/*/

Ŀ
Funo    GetUserFieAutor   Luiz Couto             Data 10.01.2005 
Ĵ
          Rotina de recuperacao dos userfields do sistema              
Ĵ
ParametrosExpC1: Codigo do usuario                                     
          ExpC2: Alias                                                 
Ĵ
Retorno   ExpL1: Indica que o Mtodo foi avaliado com sucesso          
Ĵ
Descrio Este Mtodo devolve os userfields do sistema                 
Ĵ
Uso        CRM/Materiais/Portais                                       
ٱ


/*/
WSMETHOD GetUserField WSRECEIVE UserCode, Alias WSSEND UserField WSSERVICE CFGDictionary

Local lRetorno	:= .T.
Local aArea    	:= GetArea()
Local aAreaSX3 	:= SX3->( GetArea() )
Local aUserStru	:= {}
Local nX		:= 0
Local nY       	:= 0
Local lUserStru	:= .F.
Local cMsgRet	:= ""

If PrtChkUser( ::UserCode, "CFGDICTIONARY", "GETUSERFIELD" )
	//Ŀ
	//Definicao dos campos de usuario configurados                            
	//
	If ExistBlock( "WSUSRFIELD" )
		aUserStru 	:= ExecBlock( "WSUSRFIELD", .F., .F., { ::Alias } )
		lUserStru	:= .T.
	EndIf
	
	If !Empty( aUserStru )
		For nX := 1 To Len( aUserStru )
			DbSelectArea( "SX3" )
			DbSetOrder( 2 )
		
			If MsSeek( aUserStru[nX] )
				nY++
		
				If nY == 1
					::UserField := {}
				EndIf
		
				aadd( ::UserField, WSClassNew( "UserField" ) )
				
				::UserField[nY]:UserTitle   	:= X3Titulo()
				::UserField[nY]:UserName    	:= SX3->X3_CAMPO
				::UserField[nY]:UserType    	:= SX3->X3_TIPO
				::UserField[nY]:UserSize    	:= SX3->X3_TAMANHO
				::UserField[nY]:UserDec     	:= SX3->X3_DECIMAL
				::UserField[nY]:UserOblig   	:= SX3->X3_OBRIGAT == Chr( 128 )
				::UserField[nY]:UserPicture 	:= SX3->X3_PICTURE
				::UserField[nY]:UserF3      	:= SX3->X3_F3
				::UserField[nY]:UserTag 		:= ""
				::UserField[nY]:UserComboBox	:= X3CBox()
			EndIf
		Next nX
	Else
		If GetMv( "MV_WSUSRFI" , .T. , .T. )
			lRetorno := .F.
			If lUserStru .and. !empty(::Alias)
				cMsgRet := "Estrutura de campos de usurio vazia (WSUSRFIELD existente). Alias: " + ::Alias
			ElseIf lUserStru .and. empty(::Alias)
				cMsgRet := "Estrutura de campos de usurio vazia (WSUSRFIELD existente). Alias no informado."
			ElseIf !lUserStru .and. !empty(::Alias)
				cMsgRet := "Estrutura de campos de usurio vazia (WSUSRFIELD no existente). Alias: " + ::Alias
			ElseIf !lUserStru .and. empty(::Alias)
				cMsgRet := "Estrutura de campos de usurio vazia (WSUSRFIELD no existente). Alias no informado."
			Else
				cMsgRet := "Error WSUSRFIELD. Params: UserCode: " + UserCode + ", Alias:" + Alias
			EndIf
			SetSoapFault( "GETUSERFIELD", cMsgRet )
			
		EndIf
	EndIf	
EndIf

RestArea( aAreaSX3 )
RestArea( aArea )

Return( lRetorno )




/*


ͻ
Programa  WSCFG034  Autor  Microsiga            Data   04/13/05   
͹
Desc.                                                                 
                                                                      
͹
Uso        AP                                                         
ͼ

*/
WSMETHOD GetSXBData WSRECEIVE XBAlias, Filtro WSSEND XBData WSSERVICE CFGDictionary
	Local aArea		:= GetArea()
	Local lRetorno 	:= .T.
	Local cSeqCol	:= ""
	Local cSeqRes	:= ""
	Local nLenIndex	:= 0
	Local nLenCol	:= 0
	Local nLenField	:= 0
	Local nLenRes	:= 0
	Local nPageCount:= 0
	Local cSeek
	Local nOrder	:= 0  
	Local cFiltro	:= ""
	Local nRegCount	:= 0
	Local nTamFil	:= FwGetTamFilial
	Local cFiltroFil	:= substr(upper(::Filtro),3,nTamFil)
	Local cFiltroEmp	:= substr(upper(::Filtro),0,2)
		
	DEFAULT ::Filtro := ""
			
	::XBData := WsClassNew( "XBDataView" )		
	::XBData:Alias := ::XBAlias		
	::XBData:ListOfIndex	:= {}
	::XBData:ListOfColumn	:= {}
	::XBData:ListOfResult	:= {}
	::XBData:Title := ""

	
	//1 - XB_ALIAS + XB_TIPO + XB_SEQ + XB_COLUNA
	DBSelectArea("SXB")
	DbSetOrder( 1 )
	
	If SXB->( MsSeek( PadR( ::XBAlias, 6 ) ) )

		While !SXB->( EOF() ) .AND. SXB->XB_ALIAS == PadR( ::XBAlias, 6 )
			Do Case
				Case SXB->XB_TIPO == "1"
					cTable:= AllTrim(SXB->XB_CONTEM)
					
					#IFDEF SPANISH
						::XBData:Title := AllTrim(SXB->XB_DESCSPA)
					#ELSE
						#IFDEF ENGLISH
							::XBData:Title := AllTrim(SXB->XB_DESCENG)
						#ELSE
							::XBData:Title := AllTrim(SXB->XB_DESCRI)
						#ENDIF
					#ENDIF
				Case SXB->XB_TIPO == "2"
					aAdd( ::XBData:ListOfIndex, WsClassNew( "XBDataIndexView" ) )
					nLenIndex := Len( ::XBData:ListOfIndex )
					
					::XBData:ListOfIndex[nLenIndex]:Sequence		:= SXB->XB_SEQ
					::XBData:ListOfIndex[nLenIndex]:Order			:= SXB->XB_COLUNA
					::XBData:ListOfIndex[nLenIndex]:Description		:= SXB->XB_DESCRI
					
					If (nOrder == 0)
						nOrder := Val(AllTrim(SXB->XB_COLUNA))
					EndIf	
				Case SXB->XB_TIPO == "4"
					If cSeqCol <> SXB->XB_SEQ
						cSeqCol := SXB->XB_SEQ
	
						aAdd( ::XBData:ListOfColumn, WsClassNew( "XBDataColumnView" ) )
						
						nLenCol := Len( ::XBData:ListOfColumn )
						
						::XBData:ListOfColumn[nLenCol]:Sequence		:= SXB->XB_SEQ
						::XBData:ListOfColumn[nLenCol]:ListOfField	:= {}
					EndIf
					
					aAdd( ::XBData:ListOfColumn[nLenCol]:ListOfField, WsClassNew( "XBDataFieldView" ) )
					nLenField := Len( ::XBData:ListOfColumn[nLenCol]:ListOfField )
					
					::XBData:ListOfColumn[nLenCol]:ListOfField[nLenField]:Column		:= SXB->XB_COLUNA
					::XBData:ListOfColumn[nLenCol]:ListOfField[nLenField]:Description	:= SXB->XB_DESCRI
					::XBData:ListOfColumn[nLenCol]:ListOfField[nLenField]:Field		:= SXB->XB_CONTEM
	
				Case SXB->XB_TIPO == "5"
					If cSeqRes <> SXB->XB_SEQ
						cSeqRes := SXB->XB_SEQ
	
						aAdd( ::XBData:ListOfResult, WsClassNew( "XBDataResultView" ) )
						nLenRes := Len( ::XBData:ListOfResult )
					EndIf
					
					::XBData:ListOfResult[nLenRes]:Sequence		:= SXB->XB_SEQ
					::XBData:ListOfResult[nLenRes]:Field		:= SXB->XB_CONTEM
				Case SXB->XB_TIPO == "6"
					cFiltro := SXB->XB_CONTEM
			EndCase
			
			SXB->( DbSkip() )
		EndDo
		
		DbSelectArea(cTable)
		DbSetOrder(nOrder)
					
		If ::XBData:Alias  $ "CTT002|SQB_01|RCJ1"		
			cSeek:= xFilial(cTable,cFiltroFil)
		Else
			cSeek:= xFilial(cTable)
		EndIf           
		If ::XBData:Alias  $ "SM0*YM0"
			If ::XBData:Alias == "YM0"
				aGrpComp := FwAllGrpCompany()
				nRegCount := Len(aGrpComp)
			Else
				aFiliais := FwAllFilial(,,::Filtro)
				nRegCount := Len(aFiliais)
			EndIf
			nPageCount := If( (nRegCount % ROWS_PER_PAGE) <> 0 ,Int(nRegCount/ROWS_PER_PAGE) + 1, nRegCount/ROWS_PER_PAGE )
		ElseIf DBSeek(cSeek)
			If !Empty(::Filtro) .And. fExpressao(::Filtro)
				If Empty(cFiltro)
					cFiltro := ::Filtro
				Else
					cFiltro += " .AND. " + ::Filtro
				EndIf
			EndIf
			While !EOF() .AND.;
				Alltrim(&(cTable + "->" + PrefixoCpo(cTable) + "_FILIAL")) == Alltrim(cSeek)
				If !Empty(cFiltro)
					If &(cFiltro)
						nPageCount += 1
						DBSkip(ROWS_PER_PAGE)   
					Else
						DBSkip()
					EndIf
				Else
					nPageCount += 1
					DBSkip(ROWS_PER_PAGE)   
				EndIf
		    EndDo	    
		EndIf
	Else
		DbSelectArea("SX5")
		DbSetOrder(1)
		
		If SX5->( MsSeek(xFilial("SX5") + "00" + PadR( AllTrim(::XBAlias), 2) ) )
			#IFDEF SPANISH			
				::XBData:Title := AllTrim(SX5->X5_DESCSPA)
			#ELSE
				#IFDEF ENGLISH
					::XBData:Title := AllTrim(SX5->X5_DESCENG)
				#ELSE
					::XBData:Title := AllTrim(SX5->X5_DESCRI)
				#ENDIF
			#ENDIF
			
			aAdd(::XBData:ListOfIndex, WsClassNew( "XBDataIndexView" ) )			
			::XBData:ListOfIndex[1]:Sequence		:= "01"
			::XBData:ListOfIndex[1]:Order			:= "01"
			::XBData:ListOfIndex[1]:Description		:= "Codigo"
			
			aAdd(::XBData:ListOfColumn, WsClassNew( "XBDataColumnView" ) )
			::XBData:ListOfColumn[1]:Sequence		:= SXB->XB_SEQ
			::XBData:ListOfColumn[1]:ListOfField	:= {}			

			aAdd(::XBData:ListOfColumn[1]:ListOfField, WsClassNew( "XBDataFieldView" ) )
			aAdd(::XBData:ListOfColumn[1]:ListOfField, WsClassNew( "XBDataFieldView" ) )
						
			::XBData:ListOfColumn[1]:ListOfField[1]:Column			:= "01"
			::XBData:ListOfColumn[1]:ListOfField[2]:Column			:= "02"
						
			::XBData:ListOfColumn[1]:ListOfField[1]:Field			:= "SX5->X5_CHAVE"

			#IFDEF SPANISH			
				::XBData:ListOfColumn[1]:ListOfField[2]:Field			:= "SX5->X5_DESCSPA"
				
				::XBData:ListOfColumn[1]:ListOfField[1]:Description	:= "Clave"				
				::XBData:ListOfColumn[1]:ListOfField[2]:Description	:= "Descripcion"
			#ELSE
				#IFDEF ENGLISH
					::XBData:ListOfColumn[1]:ListOfField[1]:Field			:= "SX5->X5_DESCENG"
					
					::XBData:ListOfColumn[1]:ListOfField[1]:Description	:= "Key"
					::XBData:ListOfColumn[1]:ListOfField[2]:Description	:= "Description"
				#ELSE
					::XBData:ListOfColumn[1]:ListOfField[2]:Field			:= "SX5->X5_DESCRI"
					
					::XBData:ListOfColumn[1]:ListOfField[1]:Description	:= "Chave"
					::XBData:ListOfColumn[1]:ListOfField[2]:Description	:= "Descricao"
				#ENDIF
			#ENDIF

			aAdd(::XBData:ListOfResult, WsClassNew( "XBDataResultView" ) )
			
			::XBData:ListOfResult[1]:Sequence	:= "01"
			::XBData:ListOfResult[1]:Field		:= "SX5->X5_CHAVE"			
			
			DbSelectArea("SX5")
			DbSetOrder(1)
			
			cSeek:= xFilial("SX5")+ ::XBAlias
	
			If DBSeek(cSeek)
				While !EOF() .AND.;
						SX5->(X5_FILIAL+X5_TABELA) == cSeek
					nPageCount += 1
					DBSkip(ROWS_PER_PAGE)
			    EndDo	    
			EndIf
		Else		
			lRetorno := .F.
			SetSoapFault( "GETSXB", "Alias no encontrado." )
		EndIf
	EndIf
	
	::XBData:PageCount:= nPageCount
		
	RestArea( aArea )
Return lRetorno


/*


ͻ
Programa  WSCFG034  Autor  Microsiga            Data   04/13/05   
͹
Desc.                                                                 
                                                                      
͹
Uso        AP                                                        
ͼ


*/
WSMETHOD GetSXBDbData WSRECEIVE Sequence, XBData, Search WSSEND XBDataDb WSSERVICE CFGDictionary
	Local aArea			:= GetArea()
	Local lRetorno		:= .T.
	Local nI			:= 0
	
	DEFAULT ::Search	:= ""
	
	nPosSeqInd := aScan( ::XBData:ListOfIndex, { |x| x:Sequence == ::Sequence } )
	nPosSeqCol := aScan( ::XBData:ListOfColumn, { |x| x:Sequence == ::Sequence } )
	
	If nPosSeqInd > 0 .AND. nPosSeqCol > 0
		::XBDataDb 				:= WsClassNew( "XBDataDbView" )
		::XBDataDb:ListOfField 	:= {}
		
		For nI := 1 To Len( ::XBData:ListOfColumn[nPosSeqCol]:ListOfField )
			aAdd( ::XBDataDb:ListOfField, WsClassNew( "XBDbFieldView" ) )
			nTamField := Len( ::XBDataDb:ListOfField )
			
			::XBDataDb:ListOfField[nTamField]:Field 		:= ::XBData:ListOfColumn[nPosSeqCol]:ListOfField[nI]:Field
			::XBDataDb:ListOfField[nTamField]:Description	:= ::XBData:ListOfColumn[nPosSeqCol]:ListOfField[nI]:Description
			::XBDataDb:ListOfField[nTamField]:ListOfValue 	:= {}
		Next nI
		
		DbSelectArea( ::XBData:Alias )
		DbSetOrder( Val( ::XBData:ListOfIndex[nPosSeqInd]:Order ) )
		
		If MsSeek( xFilial( ::XBData:Alias ) + ::Search )
			While !EOF()
				For nI := 1 To Len( ::XBDataDb:ListOfField )
					aAdd( ::XBDataDb:ListOfField[nI]:ListOfValue, WsClassNew( "XBDbValueView" ) )
					nTamVal := Len( ::XBDataDb:ListOfField[nI]:ListOfValue )
					
					::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Recno := Recno()
					
					Do Case
						Case ValType( &( ::XBDataDb:ListOfField[nI]:Field ) ) == "N"
							::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Value 	:= AllTrim( Str( &( ::XBDataDb:ListOfField[nI]:Field ) ) )
	
						Case ValType( &( ::XBDataDb:ListOfField[nI]:Field ) ) == "D"
							::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Value 	:= DToC( &( ::XBDataDb:ListOfField[nI]:Field ) )
	
						Otherwise
							::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Value 	:= &( ::XBDataDb:ListOfField[nI]:Field )
					EndCase
				Next nI
				
				DbSkip()
			EndDo
		EndIf
	EndIf
	
	RestArea( aArea )	
Return lRetorno
               


/*


ͻ
Programa  WSCFG034  Autor  Microsiga            Data   04/13/05   
͹
Desc.                                                                 
                                                                      
͹
Uso        AP                                                        
ͼ

*/             
WSMETHOD GetSXBResult WSRECEIVE Alias, RecNo WSSEND XBResult WSSERVICE CFGDictionary               
	Local lRet:= .T.
	Local lSX5:= .F.
	Local cAliasXB := PadR(AllTrim(::Alias), 6)
	Local cAlias
	Local oResult
	
	::XBResult:= {}
	             
	Begin Sequence       
		DbSelectArea("SXB")
		DbSetOrder(1)	
	
		If SXB->( MSSeek(cAliasXB + "101DB") )
			cAlias:= AllTrim(SXB->XB_CONTEM) 
			DbSelectArea(cAlias)
			(cAlias)->(DBGoTo(::RecNo))
		Else
			lSX5:= .T.
			cAliasXB := PadR(AllTrim(::Alias), 2)
			DbSelectArea("SX5")
			DbSetOrder(1)	
			
			If MSSeek(xFilial("SX5") + "00" + cAliasXB)
				DBGoTo(::RecNo)
			Else
				lRet:= .F.
				Break
			EndIf
		EndIf
		
		If !lSX5		
			If SXB->( MSSeek(cAliasXB + "5") )
				While !SXB->(EOF()) .AND.;
						SXB->XB_ALIAS == cAliasXB .AND.; 
						SXB->XB_TIPO == "5"
					oResult:= WsClassNew( "XBResultView")
						
					oResult:Sequence	:=	AllTrim(SXB->XB_SEQ)
					oResult:Field		:=	AllTrim(SXB->XB_CONTEM)
					oResult:Value		:=	AllTrim(ToString(&(SXB->XB_CONTEM)))
					If substr(upper(Alias),1,3) $ "YM0"
						cEmpSelec := oResult:Value
					EndIf
					
					AAdd(::XBResult, oResult)
					SXB->(DBSkip())
				EndDo
			Else
				lRet:= .F.
				Break
			EndIf
		Else
			oResult:= WsClassNew( "XBResultView" )
				
			oResult:Sequence	:=	"01"
			oResult:Field		:=	"X5_CHAVE"
			oResult:Value		:=	SX5->X5_CHAVE
			
			AAdd(::XBResult, oResult)	
		EndIf
	End Sequence	

Return lRet







/*


ͻ
Programa  WSCFG034  Autor  Microsiga            Data   04/13/05   
͹
Desc.                                                                 
                                                                      
͹
Uso        AP                                                        
ͼ

*/
WSMETHOD GetSXBDataPage WSRECEIVE Alias, Sequence, Page, Search, Filtro WSSEND XBDataDb WSSERVICE CFGDictionary
	Local aArea			:= GetArea()
	Local lRetorno		:= .T.
	Local lAchou		:= .F.
	Local nI			:= 0
	Local nCount		:= 0
	Local cAlias
	Local nIndex		:= 1
	Local cSeek
	Local cEval               
	Local cFiltro		:= ""
	Local nTamFil		:= FwGetTamFilial
	Local cFiltroFil	:= substr(upper(::Filtro),3,nTamFil)
	Local cFiltroEmp	:= substr(upper(::Filtro),0,2)
	
	DEFAULT ::Search	:= ""
	DEFAULT ::Page		:= 1
	DEFAULT ::Filtro	:= ""
	             
	::XBDataDb 				:= WsClassNew( "XBDataDbView" )
	::XBDataDb:ListOfField 	:= {}
	
	//XB_ALIAS	XB_TIPO	XB_SEQ	XB_COLUNA	XB_DESCRI	XB_DESCSPA	XB_DESCENG	XB_CONTEM	XB_WCONTEM
	DbSelectArea("SXB")
	DbSetOrder(1)
	
	If SXB->( MSSeek( PadR(::Alias, 6) + "101DB") )
		cAlias	:= AllTrim(SXB->XB_CONTEM)
		cSeek	:= xFilial(cAlias)
		cEval	:= cAlias + "->" + PrefixoCpo(cAlias) + "_FILIAL"
				
		If Alltrim(SXB->XB_ALIAS) $ "SRJ_01|SQ3_01|XP6" 
			::Filtro 	:= PadR( ::Filtro, nTamFil, " " )
			cSeek 		:= If( !Empty(::Filtro) , xFilial(cAlias, ::Filtro) , xFilial(cAlias) )			
		ElseIf Alltrim(SXB->XB_ALIAS) $ "CTT002|SQB_01|RCJ1"	
			::Filtro 	:= PadR( cFiltroFil, nTamFil, " " )	
			cSeek 		:= If( !Empty(::Filtro) , xFilial(cAlias, ::Filtro) , xFilial(cAlias) )
		EndIf		
		
		If SXB->( MSSeek( PadR(::Alias, 6) + "2" + StrZero(Val(::Sequence), 2)  ) )
			nIndex:= Val(SXB->XB_COLUNA)
		EndIf
		
		If SXB->( MSSeek( PadR(::Alias, 6) + "4" + StrZero(Val(::Sequence), 2)  ) )	
			While !SXB->(EOF()) .AND. ;
				SXB->XB_ALIAS == PadR(::Alias, 6) .AND. ;
				SXB->XB_TIPO == "4" .AND. ;
				SXB->XB_SEQ	== StrZero(Val(::Sequence), 2)
				
				aAdd( ::XBDataDb:ListOfField, WsClassNew( "XBDbFieldView" ) )
				nTamField := Len( ::XBDataDb:ListOfField )
				
				::XBDataDb:ListOfField[nTamField]:Field := SXB->XB_CONTEM
	
				#IFDEF SPANISH
					::XBDataDb:ListOfField[nTamField]:Description := AllTrim(SXB->XB_DESCSPA)
				#ELSE
					#IFDEF ENGLISH
						::XBDataDb:ListOfField[nTamField]:Description := AllTrim(SXB->XB_DESCENG)
					#ELSE
						::XBDataDb:ListOfField[nTamField]:Description := AllTrim(SXB->XB_DESCRI)
					#ENDIF
				#ENDIF
				
				::XBDataDb:ListOfField[nTamField]:ListOfValue 	:= {}
	
				SXB->(DBSkip())
			EndDo
		Else
			lRetorno:= .F.
		EndIf
		
		If SXB->( MSSeek( PadR(::Alias, 6) + "6"))
			cFiltro := SXB->XB_CONTEM
		EndIf             
	Else	
		DbSelectArea("SX5")
		DbSetOrder(1)	//X5_FILIAL+X5_TABELA+X5_CHAVE
		
		If SX5->(MSSeek(xFilial("SX5") + "00" + AllTrim(::Alias)) )
			aAdd( ::XBDataDb:ListOfField, WsClassNew( "XBDbFieldView" ) )
			aAdd( ::XBDataDb:ListOfField, WsClassNew( "XBDbFieldView" ) )			
						
			::XBDataDb:ListOfField[1]:Field 		:= "X5_CHAVE"
				
			#IFDEF SPANISH
				::XBDataDb:ListOfField[2]:Field 		:= "X5_DESCSPA"

				::XBDataDb:ListOfField[1]:Description	:= "Clave"
				::XBDataDb:ListOfField[2]:Description	:= "Descripcion"
			#ELSE
				#IFDEF ENGLISH
					::XBDataDb:ListOfField[2]:Field 		:= "X5_DESCENG"

					::XBDataDb:ListOfField[1]:Description	:= "Key"
					::XBDataDb:ListOfField[2]:Description	:= "Description"
				#ELSE
					::XBDataDb:ListOfField[2]:Field 		:= "X5_DESCRI"

					::XBDataDb:ListOfField[1]:Description	:= "Chave"
					::XBDataDb:ListOfField[2]:Description	:= "Descrio"
				#ENDIF
			#ENDIF	
			
			::XBDataDb:ListOfField[1]:ListOfValue 	:= {}
			::XBDataDb:ListOfField[2]:ListOfValue 	:= {}
		Else
			lRetorno:= .F.
			SetSoapFault( "GetSXBDataPage", "tabela no encontrada" )
		EndIf
		
		cAlias	:= "SX5"
		nIndex	:= 1
		cSeek	:= xFilial("SX5") + PadR(AllTrim(::Alias), 2)
		cEval	:= "SX5->(X5_FILIAL+X5_TABELA)"
	EndIf
               
	If lRetorno
		DbSelectArea(cAlias)
		DbSetOrder(nIndex)
		
		If substr(upper(Alias),1,3) $ "SM0*YM0"
			//Busca no SM0
			dbSelectArea('SM0')
			SM0->(dbGoTop())
			
			If "SM0EMP" == alltrim(upper(Alias))
				::Search := cSeek
				cSeek := cEmpAnt
			Else
				cSeek := Iif(Empty(cEmpSelec),SM0->M0_CODIGO,cEmpSelec)
			EndIf
			If MsSeek(Iif(substr(upper(Alias),1,3) $ "SM0",cSeek,"") + ::Search )
				If substr(upper(Alias),1,3) == "SM0" .and. !Empty(::Filtro)
					cFiltro := "SM0->M0_CODIGO == '"+ ::Filtro +"'"
				ElseIF (substr(upper(Alias),1,3) == "CC2RES" .or. substr(upper(Alias),1,3) == "CC2ESC") .AND. !Empty(::Filtro)
					cFiltro := "CC2->CC2_EST == '" + ::Filtro + "'"
				ElseIf Empty(cFiltro)
					cFiltro := ".T."
				EndIf
				While !EOF() 				
					If &(Alltrim(cFiltro)) .And. ((nCount++) < ROWS_PER_PAGE) 
						If nCount== 1
							DBSkip(((::Page - 1) * ROWS_PER_PAGE))
						EndIf
						For nI := 1 To Len( ::XBDataDb:ListOfField )
							aAdd( ::XBDataDb:ListOfField[nI]:ListOfValue, WsClassNew( "XBDbValueView" ) )
							nTamVal := Len( ::XBDataDb:ListOfField[nI]:ListOfValue )
							
							::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Recno := Recno()
							
							Do Case
								Case ValType( &( ::XBDataDb:ListOfField[nI]:Field ) ) == "N"
									::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Value 	:= AllTrim( Str( &(::XBDataDb:ListOfField[nI]:Field ) ) )
			
								Case ValType( &( ::XBDataDb:ListOfField[nI]:Field ) ) == "D"
									::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Value 	:= DToC( &( ::XBDataDb:ListOfField[nI]:Field ) )
			
								Otherwise
									::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Value 	:= AllTrim(&( ::XBDataDb:ListOfField[nI]:Field ))
							EndCase
						Next nI
					EndIf
					DbSkip()
				EndDo
			EndIf			
			
		Else				
		//TRATAMENTO PARA INDEXAR CORRETAMENTE QUANDO A CONSULTA PADRO SQB_01 FOR USADA, 
		//POIS SEU INDICE DE BUSCA DEVE SER 2 E NO UTILIZAR O A LGICA ACIMA DE INDEXAO BASEADA NA SEQUENCIA DO SXB
						
			If upper(::Alias) == "SQB_01" 
				If !Empty(::Filtro)
					SQB->(DBCloseArea())			
					EmpOpenFile("SQB", "SQB", 1, .T., cFiltroEmp, "C") 
					dbSelectArea("SQB")	
				EndIf			
						
			 	SQB->(DBSETORDER(2))
			 	lAchou :=  SQB->(MsSeek(cSeek + ::Search))
			ElseIf upper(::Alias) == "CTT002"
				If !Empty(::Filtro)
					CTT->(DBCloseArea())			
					EmpOpenFile("CTT", "CTT", 1, .T., cFiltroEmp, "C") 
					dbSelectArea("CTT")	
				EndIf			
						
			 	CTT->(DBSETORDER(nIndex))
			 	lAchou :=  CTT->(MsSeek(cSeek + ::Search ))
			ElseIf upper(::Alias) == "RCJ1" 
				If !Empty(::Filtro)
					RCJ->(DBCloseArea())			
					EmpOpenFile("RCJ", "RCJ", 1, .T., cFiltroEmp, "C") 
					dbSelectArea("RCJ")	
				EndIf				
						
			 	RCJ->(DBSETORDER(1))
			 	lAchou :=  RCJ->(MsSeek(cSeek + ::Search))
			Else
				If !(lAchou := MsSeek(cSeek + ::Search ))
					If !(lAchou := MsSeek(cSeek + UPPER(::Search)))
						lAchou := MsSeek(cSeek + LOWER(::Search))
					EndIf
				EndIf
			EndIf			
			If lAchou
				If upper(::Alias) == "SQB_01" .and. !Empty(::Filtro)					
					cFiltro := " SQB->QB_FILIAL == '" + xFilial("SQB",::Filtro) + "'"
				ElseIF (upper(::Alias) == "CC2RES" .or. upper(::Alias) == "CC2ESC") .AND. !Empty(::Filtro)
					cFiltro := "CC2->CC2_EST == '" + ::Filtro + "'"
				ElseIf upper(::Alias) == "RCJ1" .and. !Empty(::Filtro)					
					cFiltro := "Alltrim(RCJ->RCJ_FILIAL) == '" + Alltrim(xFilial("RCJ",cFiltroFil)) + "'"							
				ElseIf upper(::Alias) == "SQ3_01" .and. !Empty(::Filtro)
					cFiltro := "Alltrim(SQ3->Q3_FILIAL) == '" + Alltrim(xFilial("SQ3",::Filtro)) + "'"		
				ElseIf upper(::Alias) == "CTT002"
					If Columnpos("CTT_MSBLQL") > 0 
						cFiltro := " CTT->CTT_MSBLQL <> '1' .AND. "
					EndIf
					cFiltro += " CTT->CTT_BLOQ <> '1' "
					If !Empty(::Filtro)						
						cFiltro += " .AND. CTT->CTT_FILIAL == '" + xFilial("CTT",::Filtro) + "'"
					ENdIf
				Else
					If Empty(cFiltro)
						cFiltro := ".T."
					EndIf
					If !Empty(::Filtro) .and. ValType(::Filtro) == "L"
						cFiltro += " .AND. " + ::Filtro
					EndIf				
				EndIf
				While !EOF() .AND. ;
					cSeek == &(cEval)
					If upper(::Alias) == "SQB_01" .And. !Empty(::Search) //TRATAMENTO PARA RETORNO DE BUSCAS EXATAS E SEMELHANTES
					 	If !(ALLTRIM(UPPER(::Search)) $ UPPER(QB_DESCRIC))
					 			SQB->(dbSkip())
					 			loop
					 	EndIf
					EndIf
					If &(Alltrim(cFiltro)) .And. ((nCount++) < ROWS_PER_PAGE) 
						If nCount == 1 
							DBSkip(((::Page - 1) * ROWS_PER_PAGE))
						EndIf
						For nI := 1 To Len( ::XBDataDb:ListOfField )
							aAdd( ::XBDataDb:ListOfField[nI]:ListOfValue, WsClassNew( "XBDbValueView" ) )
							nTamVal := Len( ::XBDataDb:ListOfField[nI]:ListOfValue )
							
							::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Recno := Recno()
							
							Do Case
								Case ValType( &( ::XBDataDb:ListOfField[nI]:Field ) ) == "N"
									::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Value 	:= AllTrim( Str( &(::XBDataDb:ListOfField[nI]:Field ) ) )
			
								Case ValType( &( ::XBDataDb:ListOfField[nI]:Field ) ) == "D"
									::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Value 	:= DToC( &( ::XBDataDb:ListOfField[nI]:Field ) )
			
								Otherwise
									::XBDataDb:ListOfField[nI]:ListOfValue[nTamVal]:Value 	:= AllTrim(&( ::XBDataDb:ListOfField[nI]:Field ))
							EndCase
						Next nI
					EndIf
					DbSkip()
				EndDo
			EndIf
		EndIf
	EndIf
	
	RestArea( aArea )	

Return lRetorno
/*


ͻ
Programa  WSCFG034  Autor  Microsiga            Data   04/13/05   
͹
Desc.                                                                 
                                                                      
͹
Uso        AP                                                        
ͼ

*/
WSMETHOD GetSXBDbResult WSRECEIVE Alias, RecNo, Field WSSEND Result WSSERVICE CFGDictionary
	Local aArea			:= GetArea()
	Local lRetorno		:= .T.
	
	DbSelectArea( ::Alias )
	DbGoTo( ::Recno )
	
	Do Case
		Case ValType( &( ::Field ) ) == "N"
			::Result := IntToStr( &( ::Field ) )
		
		Case ValType( &( ::Field ) ) == "D"
			::Result := DToC( &( ::Field ) )
		
		Otherwise
			::Result := &( ::Field )	
	EndCase
	
	RestArea( aArea )	
Return lRetorno


/*/

Ŀ
Funo    GetSX1ParaAutor   Luiz Couto             Data 24.09.2004 
Ĵ
          Rotina de recuperacao do SX1 do sistema                      
Ĵ
ParametrosExpC1: Codigo do usuario                                     
Ĵ
Retorno   ExpL1: Indica que o metodo foi avaliado com sucesso          
Ĵ
Descrio Este metodo devolve um grupo do SX1 do sistema               
Ĵ
Uso        CRM/Materiais/Portais                                       
ٱ


/*/
WSMETHOD GetSX1Param WSRECEIVE UserCode, X1Group WSSEND ListOfX1Data WSSERVICE CFGDictionary

Local lRetorno 	:= .T.
Local nI		:= 0
Local nJ		:= 0

Private cAlias	:= "SX1"

If PrtChkUser( ::UserCode, "CFGDictionary", "GETSX1PARAM" )
	( cAlias )->( DbSetOrder( 1 ) )
	
	If ( cAlias )->( MsSeek( ::X1Group ) )
		::ListOfX1Data := {}

		nI := 0
		
		While !( cAlias )->( Eof() ) .AND. AllTrim( ( cAlias )->X1_GRUPO ) == AllTrim( ::X1Group )
			aAdd( ::ListOfX1Data, WsClassNew( "X1DataView" ) )
			nI++
			::ListOfX1Data[nI]:X1Order 		:= ( cAlias )->X1_ORDEM
			::ListOfX1Data[nI]:X1Question	:= ( cAlias )->X1_PERGUNT
			::ListOfX1Data[nI]:X1Type 		:= ( cAlias )->X1_TIPO
			::ListOfX1Data[nI]:X1Size 		:= ( cAlias )->X1_TAMANHO
			::ListOfX1Data[nI]:X1GetOrCombo	:= ( cAlias )->X1_GSC
			::ListOfX1Data[nI]:X1ComboSel	:= ( cAlias )->X1_PRESEL
			::ListOfX1Data[nI]:ListOfX1Def 	:= {}
			
			For nJ := 1 To 5
				aAdd( ::ListOfX1Data[nI]:ListOfX1Def, WsClassNew( "X1DefView" ) )
				::ListOfX1Data[nI]:ListOfX1Def[nJ]:X1DefDescription 	:= &( "( cAlias )->X1_DEF" + AllTrim( StrZero( nJ, 2 ) ) )
				
				If ::ListOfX1Data[nI]:X1Type == "D"
					::ListOfX1Data[nI]:ListOfX1Def[nJ]:X1DefContent := StrTran( &( "( cAlias )->X1_CNT" + AllTrim( StrZero( nJ, 2 ) ) ), "'", "" )
				Else
					::ListOfX1Data[nI]:ListOfX1Def[nJ]:X1DefContent := &( "( cAlias )->X1_CNT" + AllTrim( StrZero( nJ, 2 ) ) )
				EndIf
			Next nJ
			
			( cAlias )->( DbSkip() )
		EndDo
	Else
		lRetorno := .F.
		SetSoapFault( "GETSX1PARAM", "Grupo nao encontrado" )
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "GETSX1PARAM", "Usuario nao autorizado" )
EndIf

Return lRetorno

/*/

Ŀ
Funo    PutSX1ParaAutor   Luiz Couto             Data 27.09.2004 
Ĵ
          Rotina de alteracao do SX1 do sistema                        
Ĵ
ParametrosExpC1: Codigo do usuario                                     
Ĵ
Retorno   ExpL1: Indica que o metodo foi avaliado com sucesso          
Ĵ
Descrio Este metodo altera um grupo do SX1 do sistema                
Ĵ
Uso        CRM/Materiais/Portais                                       
ٱ


/*/
WSMETHOD PutSX1Param WSRECEIVE UserCode, X1Group, X1PutData WSSEND WSNULL WSSERVICE CFGDictionary

Local lRetorno 	:= .T.
Local cAlias 	:= "SX1"
Local nI		:= 0

If PrtChkUser( ::UserCode, "CFGDictionary", "PUTSX1PARAM" )
	( cAlias )->( DbSetOrder( 1 ) )
	
	For nI := 1 To Len( ::X1PutData:ListOfX1PutData )
		If ( cAlias )->( MsSeek( ::X1Group + ::X1PutData:ListOfX1PutData[nI]:X1Order ) )
			If RecLock( cAlias, .F. )
				If ::X1PutData:ListOfX1PutData[nI]:X1GetOrCombo == "G"
					If ::X1PutData:ListOfX1PutData[nI]:X1Type == "D"
						( cAlias )->X1_CNT01 := "'" + ::X1PutData:ListOfX1PutData[nI]:X1Content + "'"
					Else
						( cAlias )->X1_CNT01 := ::X1PutData:ListOfX1PutData[nI]:X1Content
					EndIf
				Else
					( cAlias )->X1_PRESEL := Val( ::X1PutData:ListOfX1PutData[nI]:X1Content )
				EndIf

				MsUnLock()
			EndIf
		Else
			lRetorno := .F.
			SetSoapFault( "PUTSX1PARAM", "Grupo nao encontrado" )
		EndIf
	Next nI
Else
	lRetorno := .F.
	SetSoapFault( "PUTSX1PARAM", "Usuario nao autorizado" )
EndIf

::WSNULL := ""

Return lRetorno

Static Function ToString(xValue)
	Local cReturn
	
	Do Case
		Case ValType(xValue) == "N"
			cReturn := IntToStr(xValue)
		Case ValType(xValue) == "D"
			cReturn := DToC(xValue)
		Otherwise
			cReturn := xValue
	EndCase
Return cReturn

/*/

Ŀ
Funo    GetVerRelease  Marcelo Faria 	Data 20.06.2012 						 
Ĵ
ParametrosExpC1: Release para verificar		                             
Ĵ
Retorno   ExpL1: Indica que o metodo foi avaliado com sucesso          
Ĵ
Descrio Metodo que confirma a release atual    						           
Ĵ
Uso       Portais       							                                 
ٱ


/*/
WSMETHOD GetVerRelease WSRECEIVE VerRPO WSSEND Confirm WSSERVICE CFGDictionary
Local lRetorno	:= .T. 
::Confirm	:= GetRpoRelease() >= ::VerRPO
Return lRetorno

/*/

Ŀ
Funo    GetSX3FieldSize    Autor   Totvs				 Data 08.02.2012 
Ĵ
          Retorna tamanho do campo no sx3														   
ٱ


/*/
WSMETHOD GetSX3FieldSize WSRECEIVE Field WSSEND X3Tamanho WSSERVICE CFGDictionary
LOCAL aArea    := GetArea()
LOCAL lRetorno := .T.

::X3Tamanho := TamSx3(::Field)[1]

RestArea(aArea)
//
// Fim do Metodo
//
Return lRetorno

/*/

Ŀ
Funo    GetAccessMode  Allyson M 	Data 22.10.2014 			   
Ĵ
ParametrosExpC1: Tabela para verificar		                           
Ĵ
Retorno   ExpL1: Indica que o metodo foi avaliado com sucesso          
Ĵ
Descrio Metodo que verifica se modo de acesso e' compartilhado       
Ĵ
Uso       Portais       							                   
ٱ


/*/
WSMETHOD GetAccessMode WSRECEIVE Alias WSSEND Confirm WSSERVICE CFGDictionary
Local lRetorno	:= .T. 

::Confirm	:= Empty( xFilial(::Alias) )

Return lRetorno

Static Function fExpressao(cString)
	Local lRet := (("=" $ cString) .OR. ("<" $ cString) .OR. (">" $ cString) .OR. ("!" $ cString) .OR. ("$" $ cString))
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} PutPLSLogFil
Mtodo que permite gerao de logs do PLS

@author Rodrigo Morgon
@since 18/10/2017
@version P12
@param MsgLog, string, mensagem que ser gravada no log
@param FileLog, string, nome do arquivo onde ser armazenado o log
/*/
//-------------------------------------------------------------------
WSMETHOD PutPLSLogFil WSRECEIVE MsgLog, FileLog WSSEND WSNULL WSSERVICE CFGDictionary
Local lRetorno  := .T.
    
    if !empty(::MsgLog) .and. !empty(::FileLog)
        PlsLogFil(::MsgLog,::FileLog)
    endif
    
    ::WSNULL   := ""
    
Return lRetorno
