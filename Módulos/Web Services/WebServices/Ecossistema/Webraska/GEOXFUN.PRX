#INCLUDE "PROTHEUS.CH"
#INCLUDE "GEOXFUN.CH"
#INCLUDE "APWIZARD.CH"       

/*/

Ŀ
Funo    CodGeoPrc  Autor  Henry Fila             Data 15.09.2003 
Ĵ
          Rotina Geoprocessamento de endereco                          
                                                                       
Ĵ
ParametrosExpC1: Endereco                                              
          ExpC2: Cidade                                                
          ExpC3: Estado                                                
          ExpC4: Cep                                                   
          ExpL5: Informe se ha interface                               
Ĵ
Retorno   Nenhum                                                       
                                                                       
Ĵ
Descrio Esta rotina tem como objetivo geoprocessar um endereco retor 
          nando sua latitude e longiture para utilizacao em um cadastro
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function CodGeoPrc(cEndereco,cCidade,cEstado,cCep,lInter)

Local aArray    := {}
Local aEnd      := {}
Local cLogin    := ""
Local cSenha    := ""
Local nX        := 0
Local lRetorno  := .T.
Local oWsGeo

DEFAULT lInter     := .T.

//Ŀ
// Realiza o HandShake                                               
//

MsgRun(STR0001+" ( HandShake )",,{|| lRetorno := EcoHandShake("WEBRASKA","GEO",@cLogin,@cSenha) }) 

//Ŀ
// Verifica o login e senha                                          
//
If Empty(cLogin) .Or. !lRetorno
	If lRetorno
		ShowEco("WEBRASKA","GEO")
	EndIf
	lRetorno := .F.	
EndIf
//Ŀ
// Executa o Web Services com o Parceiro                             
//
If lRetorno 
	aEnd      := FisGetEnd(cEndereco)
	
	cEndereco := Alltrim(aEnd[1])
	cNumero   := Alltrim(Str(aEnd[2]))

	oWsGeo    := WSWEBRASKAGEOPROCESSING():New()
	GetURLSoap( @oWsGeo, "WEBRASKAGEOPROCESSING.APW", "WEBRASKA" )
	oWsGeo:cUSERCODE := cLogin
	oWsGeo:cPASSWORD := cSenha
	oWsGeo:cGEOLANGUAGE := Nil
	oWSGeo:oWSADDRESS := WEBRASKAGEOPROCESSING_ADDRESSVIEW():New()
	oWsGEo:oWSADDRESS:cADDRESS        := cEndereco
	oWsGEo:oWSADDRESS:cADDRESSNUMBER  := cNumero
	oWsGEo:oWSADDRESS:cDISTRICT       := cCidade
	oWsGEo:oWSADDRESS:cSTATE          := cEstado
	oWsGEo:oWSADDRESS:cTYPEOFADDRESS  := "1"
	oWsGEo:oWSADDRESS:cZIPCODE        := cCep
	oWsGEo:oWSADDRESS:cZONE           := ""

	If lInter
		MsgRun(STR0001+"  ( GeoCoding )",,{|| lRetorno := oWsGeo:GeoCoding() }) //"Geoprocessamento..."
	Else
		lRetorno := oWsGeo:GeoCoding()
	EndIf
	DEFAULT lRetorno := .F.
	If lRetorno
		For nX := 1	To Len(oWSGeo:oWSGEOCODINGRESULT:oWSNAVADDRESSVIEW)
			aadd(aArray,{oWSGeo:oWSGEOCODINGRESULT:oWSNAVADDRESSVIEW[nX]:oWSADDRESS:cAddress,;
						oWSGeo:oWSGEOCODINGRESULT:oWSNAVADDRESSVIEW[nX]:oWSADDRESS:cZone,;
						oWSGeo:oWSGEOCODINGRESULT:oWSNAVADDRESSVIEW[nX]:oWSADDRESS:cZipCode,;
						oWSGeo:oWSGEOCODINGRESULT:oWSNAVADDRESSVIEW[nX]:oWSADDRESS:cDistrict,;
						oWSGeo:oWSGEOCODINGRESULT:oWSNAVADDRESSVIEW[nX]:oWSADDRESS:cState,;
						oWSGeo:oWSGEOCODINGRESULT:oWSNAVADDRESSVIEW[nX]:cLatitude,;
						oWSGeo:oWSGEOCODINGRESULT:oWSNAVADDRESSVIEW[nX]:cLongitude})
		Next nX
		
		If Empty(aArray) .And. lInter
			GeoError()
		EndIf
	Else
		If lInter
			GeoError()
		EndIf		
	EndIf
EndIf		
Return(aArray)

/*/

Ŀ
Funo    CodGeoRev  Autor  Eduardo Riera          Data 25.02.2004 
Ĵ
          Rotina de geoprocessamento reverso                           
                                                                       
Ĵ
ParametrosExpA1: Coordenadas latitude e Longitude                      
          ExpL2: Informe se ha interface                               
Ĵ
Retorno   ExpA1: [1] Endereco                                          
                 [2] Numero                                            
                 [3] Bairro                                            
                 [4] Cidade                                            
                 [5] Estado                                            
                 [6] Cep                                               
Ĵ
Descrio Esta rotina tem como objetivo geoprocessar um endereco retor 
          nando sua latitude e longiture para utilizacao em um cadastro
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function CodGeoRev(aCoord,lInter,lRetorno)

Local aArray    := {"","","","","","","",""}
Local aEnd      := {}
Local cLogin    := ""
Local cSenha    := ""
Local nX        := 0
Local oWsGeo

DEFAULT lInter     := .T.               
DEFAULT lRetorno   := .T. 
//Ŀ
// Realiza o HandShake                                               
//

MsgRun(STR0001+" ( HandShake )",,{|| lRetorno := EcoHandShake("WEBRASKA","REVGEO",@cLogin,@cSenha) }) 

//Ŀ
// Verifica o login e senha                                          
//
If Empty(cLogin) .Or. !lRetorno
	If lRetorno
		ShowEco("WEBRASKA","REVGEO")
	EndIf
	lRetorno := .F.
EndIf
//Ŀ
// Executa o Web Services com o Parceiro                             
//
If lRetorno 
	oWsGeo    := WSWEBRASKAGEOPROCESSING():New()
	GetURLSoap( @oWsGeo, "WEBRASKAGEOPROCESSING.APW", "WEBRASKA" )
	oWsGeo:cUSERCODE := cLogin
	oWsGeo:cPASSWORD := cSenha
	oWsGeo:cGEOLANGUAGE := Nil
	oWSGeo:oWSNavID:cLatitude := aCoord[1]
	oWSGeo:oWSNavID:cLongitude:= aCoord[2]

	If lInter
		MsgRun(STR0001+"  ( ReverseGeoCoding )",,{|| lRetorno := oWsGeo:ReverseGeoCoding() }) //"Geoprocessamento..."
	Else
		lRetorno := oWsGeo:ReverseGeoCoding()
	EndIf
	DEFAULT lRetorno := .F.
	If lRetorno
		aArray := {oWSGeo:oWSREVERSEGEOCODINGRESULT:oWSADDRESS:cAddress,;
					oWSGeo:oWSREVERSEGEOCODINGRESULT:oWSADDRESS:cAddressNumber,;
					oWSGeo:oWSREVERSEGEOCODINGRESULT:oWSADDRESS:cZone,;
					oWSGeo:oWSREVERSEGEOCODINGRESULT:oWSADDRESS:cDistrict,;
					oWSGeo:oWSREVERSEGEOCODINGRESULT:oWSADDRESS:cState,;
					oWSGeo:oWSREVERSEGEOCODINGRESULT:oWSADDRESS:cZipCode,;
					oWSGeo:oWSREVERSEGEOCODINGRESULT:cLatitude,;
					oWSGeo:oWSREVERSEGEOCODINGRESULT:cLongitude}
	
		If Empty(aArray) .And. lInter
			GeoError()
		EndIf
	Else
		If lInter
			GeoError()
		EndIf
	EndIf
EndIf
Return(aArray)

/*/

Ŀ
Funo    GeoMap        Autor  Henry Fila          Data 15.09.2003 
Ĵ
          Rotina mapeamento de coordenadas                             
Ĵ
ParametrosExpA1: Array com os dados dos pontos a serem plotados        
                 [1] Latitude                                          
                 [2] Longitude                                         
                 [3] Icone (deve ser em letra minuscula)               
                    "admin.gif"                                        
                    "aero.gif"                                         
                    "bus.gif"                                          
                    "car.gif"                                          
                    "casino.gif"                                       
                    "castle.gif"                                       
                    "cinema.gif"                                       
                    "computer.gif"                                     
                    "education.gif"                                    
                    "ferry.gif"                                        
                    "gasoline.gif"                                     
                    "golf.gif"                                         
                    "hospital.gif"                                     
                    "hotel.gif"                                        
                    "information.gif"                                  
                    "marina.gif"                                       
                    "park.gif"                                         
                    "parking.gif"                                      
                    "picnic.gif"                                       
                    "restaurant.gif"                                   
                    "shopping.gif"                                     
                    "skating.gif"                                      
                    "ski.gif"                                          
                    "stadium.gif"                                      
                    "subway.gif"                                       
                    "tennis.gif"                                       
                    "train.gif"                                        
                    "wine.gif"                                         
                    "circle.gif"                                       
                    "square.gif"                                       
                    "triangle.gif"                                     
                    "star.gif"                                         
                    "man.gif"                                          
                    "flag2.gif"                                        
          ExpN2: Altura do mapa                                        
          ExpN3: Largura do mapa                                       
          ExpN4: Raio                                                  
          ExpC5: Nome do arquivo gerado passado por referencia         
          ExpL6: Indica se o mapa deve ser exibido                     
Ĵ
Retorno   Nenhum                                                       
Ĵ
Descrio Esta rotina tem como mostrar o mapa de uma coordenada        
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function GeoMap(aCdMap,nHeight,nWidth,nRadius,cMap,lMostra)

Local aSize      := {}
Local aObjects   := {}
Local aPosObj    := {}
Local aExclui    := {}
Local aUsButtons := NIL 

Local cLogin     := ""
Local cSenha     := ""
Local cTmp       := ""
Local cImagem    := ""

Local lRetorno   := .T.
Local lApaga     := .T.

Local nHDL       := 0
Local nOriRadius := 0 
Local nX         := 0
Local nLoop      := 0 

Local oWsGeo
Local oDlg 
Local oBitmap
Local oGet
Local oScroll
Local oMenu                                                          

Local	cLatStart  := ""
Local	cLongStart := ""
Local	cLatEnd    := ""
Local	cLongEnd   := ""

DEFAULT cMap     := ""
DEFAULT lMostra  := .T.
DEFAULT nRadius  := 1000                                             

If lMostra                   

	PRIVATE aGeoUsrInf := {} 

	aSize    := MsAdvSize(.F.)
	If Empty(nHeight)
		Do Case
			Case aSize[6] >= 900
				nHeight := 768
				nWidth  := 1024
			Case aSize[6] >= 700
				nHeight := 600
				nWidth  := 800
			OtherWise
				nHeight := 480
				nWidth  := 640
		EndCase
	EndIf	
EndIf
//Ŀ
// Realiza o HandShake                                               
//

MsgRun(STR0001+" ( HandShake )",,{|| lRetorno := EcoHandShake("WEBRASKA","MAP",@cLogin,@cSenha) }) 

//Ŀ
// Verifica o login e senha                                          
//
If Empty(cLogin) .Or. !lRetorno
	If lRetorno
		ShowEco("WEBRASKA","MAP")
	EndIf
	lRetorno := .F.	
EndIf
//Ŀ
// Executa o Web Services com o Parceiro                             
//
If lRetorno
	oWsGeo    := WSWEBRASKAGEOPROCESSING():New()
	GetURLSoap( @oWsGeo, "WEBRASKAGEOPROCESSING.APW", "WEBRASKA" )
	oWsGeo:cUSERCODE    := cLogin
	oWsGeo:cPASSWORD    := cSenha
	oWsGeo:cGEOLANGUAGE := Nil
	oWsGeo:oWSNAVPOINTS := WEBRASKAGEOPROCESSING_NAVPOINTVIEW():New()
	oWsGeo:oWSNAVPOINTS:oWSPOINTS :=WEBRASKAGEOPROCESSING_ARRAYOFNAVIDVIEW():New()	
	For nX := 1 To Len(aCdMap)
		aadd(oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW,WEBRASKAGEOPROCESSING_NAVIDVIEW():New())
		oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX]:cICON      := AllTrim(If(Empty(aCdMap[nX][3]),"",aCdMap[nX][3]))
		oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX]:cLATITUDE  := AllTrim(aCdMap[nX][1])
		oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX]:cLONGITUDE := AllTrim(aCdMap[nX][2])
	Next nX	
	oWsGeo:nRADIUS      := nRadius	
	oWsGeo:nWIDTH       := nWidth
	oWsGeo:nHEIGHT      := nHeight

	MsgRun(STR0001+"  ( Mapping )",,{|| lRetorno := oWSGeo:Mapping() }) //"Geoprocessamento..."
	DEFAULT lRetorno := .F.
	
	If lRetorno
		
		cImagem  := oWSGeo:oWSMAPPINGRESULT:cImage   
		cLatStart  := oWSGeo:oWSMAPPINGRESULT:oWsUpperCorner:cLatitude
		cLongStart := oWSGeo:oWSMAPPINGRESULT:oWsUpperCorner:cLongitude
		cLatEnd    := oWSGeo:oWSMAPPINGRESULT:oWsLowerCorner:cLatitude
		cLongEnd   := oWSGeo:oWSMAPPINGRESULT:oWsLowerCorner:cLongitude
		//Ŀ
		// Abre a tela com o mapa                               
		// 
		If !Empty(cImagem)
			cTmp := CriaTrab(,.F.)+".gif"
			nHdl := FCreate(cTmp,0)
			FWrite(nHdl,cImagem,Len(cImagem))
			FClose(nHdl)
			If !Empty(cMap)
				FErase(cMap)
				lApaga := .F.
			EndIf
			cMap   := cTmp	
	
		Else
			lRetorno := .F.		
			GeoError()
		EndIf
	Else
		GeoError()
	EndIf  
EndIf

//Ŀ
// Atualiza as informacoes de usuario                              
// 
If ExistBlock( "GEOMPBUT" ) 
 	aGeoUsrInf := { { "LATITUDE", aCdMap[1,1] }, { "LONGITUDE", aCdMap[1,2] }, { "RADIUS", nRadius } }
EndIf 

If lRetorno .And. lMostra

	//Ŀ
	// Ponto de entrada para a criacao de botoes de usuario                
	//
	If ExistBlock( "GEOMPBUT" ) 
		aUsButtons := AClone( ExecBlock( "GEOMPBUT", .F., .F. ) ) 
	EndIf 

	nOriRadius := nRadius 

	Do Case
		Case aSize[6] >= 900
			nHeight := 768
			nWidth  := 1024
			
			aSize[ 3 ] -= 25
			aSize[ 4 ] -= 25 	
			
			aSize[ 5 ] -= 50
			aSize[ 6 ] -= 50                                       
			
		Case aSize[6] >= 700
			nHeight := 600
			nWidth  := 800
			
			aSize[ 3 ] -= 25
			aSize[ 4 ] -= 25 	
			
			aSize[ 5 ] -= 50
			aSize[ 6 ] -= 50                                       

		Case aSize[6] >= 500
			nHeight := 480
			nWidth  := 640
			
			aSize[ 3 ] -= 80
			aSize[ 4 ] -= 20 	
			
			aSize[ 5 ] -= 160
			aSize[ 6 ] -= 40                                       
			
		OtherWise
			nHeight := 480
			nWidth  := 640
 
			aSize[ 3 ] -= 3
			aSize[ 4 ] -= 5 	
			
			aSize[ 5 ] -= 6
			aSize[ 6 ] -= 10  				
			
	EndCase
	
	aadd(aObjects,{100,100,.T.,.T.,.T.})
	aadd(aObjects,{050,100,.F.,.T.})
	aPosObj := MsObjSize({aSize[1],aSize[2],aSize[3],aSize[4],3,3},aObjects,nil,.T.)
	
	DEFINE MSDIALOG oDlg TITLE STR0044 FROM aSize[7],000 TO aSize[6],aSize[5] OF oMainWnd PIXEL //"Mapa"
	
	MENU oMenu POPUP OF oDlg                   

		MENUITEM STR0058   ACTION (nRadius/=2,nRadius:=Max(62.5,nRadius),GeoMap(aCdMap,nHeight,nWidth,nRadius,@cMap,.F.),oBitMap:Load(,cMap),oGet:Refresh()) RESOURCE "PMSZOOMIN"	
		MENUITEM STR0059   ACTION (nRadius*=2,GeoMap(aCdMap,nHeight,nWidth,nRadius,@cMap,.F.),oBitMap:Load(,cMap),oGet:Refresh()) RESOURCE "PMSZOOMOUT"
		MENUITEM STR0064   ACTION (nRadius := nOriRadius,GeoMap(aCdMap,nHeight,nWidth,nRadius,@cMap,.F.),oBitMap:Load(,cMap),oGet:Refresh()) RESOURCE "PMSUPDOWN"
		MENUITEM STR0065   ACTION MsDocView(cMap,@aExclui,NIL, "\" + Curdir() ) RESOURCE "PMSPESQ"
		
	ENDMENU
	
	oDlg:bRClicked   := { |oObject,nx,ny| oMenu:Activate( nX, nY, oObject ) }
	
	@ aPosObj[1][1],aPosObj[1][2]+000 SCROLLBOX oScroll SIZE aPosObj[1][4],aPosObj[1][3] OF oDlg PIXEL
	@ 000,000 BITMAP oBitMap SIZE (nWidth+5)/2,(nHeight+5)/2 FILE cMap PIXEL OF oScroll NOBORDER
	
	@ aPosObj[2,1] +  0, aPosObj[2,2] + 6 BUTTON STR0058 SIZE 040,010 ACTION (nRadius/=2,nRadius:=Max(62.5,nRadius),GeoMap(aCdMap,nHeight,nWidth,nRadius,@cMap,.F.),oBitMap:Load(,cMap)) OF oDlg PIXEL	
	@ aPosObj[2,1] + 15, aPosObj[2,2] + 6 BUTTON STR0059 SIZE 040,010 ACTION (nRadius*=2,GeoMap(aCdMap,nHeight,nWidth,nRadius,@cMap,.F.),oBitMap:Load(,cMap)) OF oDlg PIXEL

	@ aPosObj[2,1] + 30, aPosObj[2,2] + 6 SAY STR0070 SIZE 020,010 OF oDlg PIXEL	//"Raio (m)"
	@ aPosObj[2,1] + 40, aPosObj[2,2] + 6 MSGET oGet VAR nRadius SIZE 040,010 OF oDlg PIXEL VALID (nRadius:=Max(62.5,nRadius),GeoMap(aCdMap,nHeight,nWidth,nRadius,@cMap,.F.),oBitMap:Load(,cMap),.T.) PICTURE "@E 999,999,999.9"
                   
	@ aPosObj[2,1]  + 80,aPosObj[2,2] + 6 BUTTON STR0065   SIZE 040,010 ACTION MsDocView(cMap,@aExclui,NIL, "\" + Curdir() ) OF oDlg PIXEL // STR0065 
	
	@ aPosObj[2,3]  - 10,aPosObj[2,2] + 6 BUTTON STR0045   SIZE 040,010 ACTION oDlg:End() OF oDlg PIXEL //"Sair"
	@ aPosObj[2,3]  - 25,aPosObj[2,2] + 6 BUTTON STR0078   SIZE 040,010 ACTION (GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,,,nRadius,,@cMap,.T.,.T.,aCdMap,.F.,.F.),oDlg:End()) OF oDlg PIXEL //"Sair"
	           
	
	//Ŀ
	// Efetua a criacao dos botoes de usuario                              
	//
	If ValType( aUsButtons ) == "A"
		If !Empty( aUsButtons ) 
			For nLoop := 1 To Len( aUsButtons ) 
				TButton():New( aPosObj[2,1] + 80 + nLoop * 15, aPosObj[2,2] + 6  ,OemToAnsi(AllTrim(aUsButtons[nLoop,1])), oDlg ,aUsButtons[ nLoop, 2],40,10,,oDlg:oFont,.F.,.T.,.F.,,.F.,,,.F.)
			Next nLoop 
		EndIf	
	EndIf
	
	ACTIVATE DIALOG oDlg CENTERED
EndIf
If lApaga
	FErase(cMap)
EndIf        

//Ŀ
// Exclui o documento do diretorio temporario do Sist. operacional 
// 
MsDocExclui( aExclui, .F. ) 

Return

/*/

Ŀ
Funo    GeoMapRoute   Autor  Henry Fila          Data 15.09.2003 
Ĵ
          Rotina mapeamento de rotas                                   
Ĵ
ParametrosExpC1 : Latitude Inicial                                     
          ExpC2 : Longitude Inicial                                    
          ExpC3 : Latitude Final                                       
          ExpC4 : Longitude Final                                      
          ExpN5 : Altura do mapa                                       
          ExpN6 : Largura do mapa                                      
          ExpN7 : Raio                                                 
          ExpC8 : Sessao com o trecho                                  
          ExpC9 : Nome do arquivo gerado passado por referencia        
          ExpL10: Indica se exibe a dialog                                
          ExpL11: Indica se trabalha com bouding ou session               
          ExpL12: Pontos de Referencia                                    
          ExpL13: Indica se exibe legenda dos pontos de interesse         
          ExpL14: Indica se exibe botao de pontos                         
Ĵ
Retorno   Nenhum                                                       
Ĵ
Descrio Esta rotina tem como mostrar o mapa de uma coordenada        
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function GeoMapRoute(cLatStart,;
							cLongStart,;
							cLatEnd,;
							cLongEnd,;
							nHeight,;
							nWidth,;
							nRadius,;
							cSession,;
							cMap,;
							lMostra,;
							lBounding,;
							aCdMap,;
							lMostraLeg,;
							lPontoBt)

Local aSize      := MsAdvSize(.F.)
Local aObjects   := {}
Local aPosObj    := {}
Local aExclui    := {}
Local aUsButtons := NIL
Local aSay       := {} 

Local bMapText   := { || .t. } 

Local cSenha     := ""
Local cLogin     := ""
Local cTmp       := ""
Local cImagem    := ""
Local cOriLatSta := "" 
Local cOriLonSta := "" 
Local cOriLatEnd := "" 
Local cOriLonEnd := "" 

Local lRetorno   := .T.

Local nHDL       := 0
Local nLoop      := 0 
Local nX         := 0 

Local oWsGeo
Local oDlg 
Local oBitmap     
Local oScroll 
Local oMenu        
Local oBmp1
Local oBmp2
Local oBmp3
Local oBmp4
Local oPanel 

If lMostra
	PRIVATE aGeoUsrInf := {} 
EndIf 

DEFAULT cMap       := ""
DEFAULT nRadius    := 500
DEFAULT lMostra    := .T. 
DEFAULT lBounding  := .F.        
DEFAULT lMostraLeg := .T.   
DEFAULT lPontoBt   := .T.   
//Ŀ
// Realiza o HandShake                                               
//       

MsgRun(STR0001+" ( HandShake )",,{|| lRetorno := EcoHandShake("WEBRASKA","MAP",@cLogin,@cSenha) }) 

//Ŀ
// Verifica o login e senha                                          
//
If Empty(cLogin) .Or. !lRetorno
	If lRetorno
		ShowEco("WEBRASKA","MAP")
	EndIf
	lRetorno := .F.	
EndIf
If lRetorno
   
	If Empty(nHeight) .And. lMostra 
	
		Do Case
			Case aSize[6] >= 900
				nHeight := 768
				nWidth  := 1024
				
				aSize[ 3 ] -= 25
				aSize[ 4 ] -= 25 	
				
				aSize[ 5 ] -= 50
				aSize[ 6 ] -= 50                                       
				
			Case aSize[6] >= 700
				nHeight := 600
				nWidth  := 800
				
				aSize[ 3 ] -= 25
				aSize[ 5 ] -= 50
	
			Case aSize[6] >= 500
				nHeight := 480
				nWidth  := 640
				
				aSize[ 3 ] -= 80
				aSize[ 4 ] -= 20 	
				
				aSize[ 5 ] -= 160
				aSize[ 6 ] -= 40                                       
				
			OtherWise
				nHeight := 480
				nWidth  := 640
	 
				aSize[ 3 ] -= 3
				aSize[ 4 ] -= 5 	
				
				aSize[ 5 ] -= 6
				aSize[ 6 ] -= 10  				
				
		EndCase
	EndIf		

	oWsGeo    := WSWEBRASKAGEOPROCESSING():New()
	GetURLSoap( @oWsGeo, "WEBRASKAGEOPROCESSING.APW", "WEBRASKA" )
	oWsGeo:cUSERCODE    := cLogin
	oWsGeo:cPASSWORD    := cSenha
	oWsGeo:cGEOLANGUAGE := Nil
	oWsGeo:oWSNAVPOINTS := WEBRASKAGEOPROCESSING_NAVPOINTVIEW():New()
	oWsGeo:oWSNAVPOINTS:oWSPOINTS :=WEBRASKAGEOPROCESSING_ARRAYOFNAVIDVIEW():New()
	aadd(oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW,WEBRASKAGEOPROCESSING_NAVIDVIEW():New())
	aadd(oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW,WEBRASKAGEOPROCESSING_NAVIDVIEW():New())
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[1]:cICON      := Nil
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[1]:cLATITUDE  := AllTrim(cLatStart)
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[1]:cLONGITUDE := AllTrim(cLongStart)	
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[2]:cICON      := Nil
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[2]:cLATITUDE  := AllTrim(cLatEnd)
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[2]:cLONGITUDE := AllTrim(cLongEnd)
	
	If aCdMap <> NIL
		
	   nX := 2
	   
		For nLoop := 1 To Len(aCdMap)
		
			aadd(oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW,WEBRASKAGEOPROCESSING_NAVIDVIEW():New())
			nX++ 
			
			oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX]:cICON      := AllTrim(If(Empty(aCdMap[nLoop][3]),"",aCdMap[nLoop][3]))
			oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX]:cLATITUDE  := AllTrim(aCdMap[nLoop][1])
			oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX]:cLONGITUDE := AllTrim(aCdMap[nLoop][2])
		Next nLoop	
	
	EndIf 	
	
	oWsGeo:nRADIUS      := nRadius
	oWsGeo:nWIDTH       := nWidth
	oWsGeo:nHEIGHT      := nHeight
	
	If lBounding
		oWsGeo:cSession := "MS_BOUNDING_BOX"
	Else
		oWsGeo:cSession := cSession
	EndIf 	

	MsgRun(STR0001+"  ( Mapping )",,{|| lRetorno := oWSGeo:Mapping() }) //"Geoprocessamento..."
	DEFAULT lRetorno := .F.	
	If lRetorno
		//Ŀ
		// Obtem o boungind box ajustado ( retorno )            
		// 	
		cImagem  := oWSGeo:oWSMAPPINGRESULT:cImage   
		cLatStart  := oWSGeo:oWSMAPPINGRESULT:oWsUpperCorner:cLatitude
		cLongStart := oWSGeo:oWSMAPPINGRESULT:oWsUpperCorner:cLongitude
		cLatEnd    := oWSGeo:oWSMAPPINGRESULT:oWsLowerCorner:cLatitude
		cLongEnd   := oWSGeo:oWSMAPPINGRESULT:oWsLowerCorner:cLongitude
				
		//Ŀ
		// Abre a tela com o mapa                               
		// 	
		If !Empty(cImagem)
			cTmp := CriaTrab(,.F.)+".gif"
			nHdl := FCreate(cTmp,0)
			FWrite(nHdl,cImagem,Len(cImagem))
			FClose(nHdl)
			If !Empty(cMap)
				FErase(cMap)
				lApaga := .F.
			EndIf
			cMap   := cTmp			
		Else
			lRetorno := .F.		
			GeoError()
		EndIf		
	Else	              
		GeoError()
	EndIf
EndIf         

//Ŀ
// Atualiza as informacoes de usuario                              
// 
If ExistBlock( "GEOMRBUT" ) 
	aGeoUsrInf := { { "LAT_START", cLatStart }, { "LON_START", cLongStart }, { "LAT_END", cLatEnd }, { "LON_END", cLongEnd } }
EndIf 

If lRetorno .And. lMostra  

	cOriLatSta := cLatStart
	cOriLonSta := cLongStart 
	cOriLatEnd := cLatEnd 
	cOriLonEnd := cLongEnd
	                             
	//Ŀ
	// Ponto de entrada para a criacao de botoes de usuario                
	//
	If ExistBlock( "GEOMRBUT" ) 
		aUsButtons := AClone( ExecBlock( "GEOMRBUT", .F., .F. ) ) 
	EndIf 
	
	AAdd(aObjects,{100,100,.T.,.T.,.T.})
	AAdd(aObjects,{50, 100,.f.,.t.})
	
	aPosObj := MsObjSize({aSize[1],aSize[2],aSize[3],aSize[4],3,3},aObjects,nil,.t. )
	DEFINE MSDIALOG oDlg TITLE STR0044 FROM aSize[7],000 TO aSize[6],aSize[5] OF oMainWnd PIXEL //"Mapa"
	
	@ aPosObj[1][1],aPosObj[1][2]+000 SCROLLBOX oScroll SIZE aPosObj[1][4],aPosObj[1][3] OF oDlg PIXEL
	
	@ 000,000 BITMAP oBitMap SIZE nWidth / 2, nHeight / 2 FILE cMap PIXEL OF oScroll NOBORDER 
	
	//Ŀ
	// Cria os objetos SAY para exibicao dos nomes dos placemarks          
	//

	If aCdMap <> NIL .and. lMostraLeg
	
		aSay := Array( Len( aCdMap ) ) 
		For nLoop := 1 to Len( aCdMap ) 
			aSay[ nLoop ] := TSAY():New( 0, 0, { || "" }, oBitMap, NIL,NIL,NIL,NIL,NIL,.T.,NIL,NIL,40,20 ) 	
			aSay[ nLoop ]:bRClicked   := { |oObject,nx,ny| oMenu:Activate( nX, nY, oObject ) }
		Next nLoop 
		
		bMapText := { || fGeoMapText( cLatStart,cLongStart,cLatEnd,cLongEnd, aCdMap, nWidth , nHeight, aSay, oBitMap ) }
		
		Eval( bMapText ) 
		
	Else
	
		bMapText := { || .t. } 
		
	EndIf 	
	
	@ aPosObj[2,1]    ,aPosObj[2,2]+6 BUTTON STR0058 SIZE 040,010 ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"C_ZOOMIN"),GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap), Eval( bMapText ) ) OF oDlg PIXEL
	@ aPosObj[2,1]+15 ,aPosObj[2,2]+6 BUTTON STR0059 SIZE 040,010 ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"C_ZOOMOUT"),GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText ) ) OF oDlg PIXEL
	
	@ aPosObj[2,1]+37, aPosObj[2,2]+6 MSPANEL oPanel PROMPT "" SIZE aPosObj[2,4]-aPosObj[2,2]-10,40 OF oDlg CENTERED LOWERED
	
	@ 11, 31 BTNBMP oBmp1 RESOURCE "PMSSETAUP"   ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"PAN_NORTH"),GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )) SIZE 20, 20 OF oPanel PIXEL ADJUST MESSAGE STR0060
	@ 31, 11 BTNBMP oBmp2 RESOURCE "PMSSETAESQ"  ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"PAN_WEST") ,GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )) SIZE 20, 20 OF oPanel PIXEL ADJUST MESSAGE STR0062
	@ 31, 51 BTNBMP oBmp3 RESOURCE "PMSSETADIR"  ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"PAN_EAST") ,GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )) SIZE 20, 20 OF oPanel PIXEL ADJUST MESSAGE STR0063
	@ 51, 31 BTNBMP oBmp4 RESOURCE "PMSSETADOWN" ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"PAN_SOUTH"),GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )) SIZE 20, 20 OF oPanel PIXEL ADJUST MESSAGE STR0061	
	
	@ aPosObj[2,1] +90,aPosObj[2,2]+6 BUTTON STR0064  SIZE 040,010 ACTION (cLatStart:=cOriLatSta,cLatEnd:=cOriLatEnd,cLongStart:=cOriLonSta,cLongEnd:=cOriLonEnd,GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )) OF oDlg PIXEL // "Restaurar"
	
	@ aPosObj[2,1]+105,aPosObj[2,2]+6 BUTTON STR0065   SIZE 040,010 ACTION MsDocView(cMap,@aExclui,NIL, "\" + Curdir() ) OF oDlg PIXEL // "Abrir" 	
	
	If !Empty( aCdMap ) .and. lPontoBt 
		@ aPosObj[2,1]+120,aPosObj[2,2]+6 BUTTON STR0074 SIZE 040,010 ACTION ( lRedraw := .F., fGeoPontos(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,aCdMap,@lRedraw),If( lRedraw, ( GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )), )) OF oDlg PIXEL // "Pontos"
	EndIf 			
	
	//Ŀ
	// Efetua a criacao dos botoes de usuario                              
	//
	If ValType( aUsButtons ) == "A"
		If !Empty( aUsButtons ) 
			For nLoop := 1 To Len( aUsButtons ) 
				TButton():New( aPosObj[2,1] + 120 + nLoop * 15,aPosObj[2,2]+6,OemToAnsi(AllTrim(aUsButtons[nLoop,1])), oDlg ,aUsButtons[ nLoop, 2],40,10,,oDlg:oFont,.F.,.T.,.F.,,.F.,,,.F.)
			Next nLoop 
		EndIf	
	EndIf
	                                           
	MENU oMenu POPUP OF oDlg                   
	
		MENUITEM STR0058 ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"C_ZOOMIN"),GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText ))  RESOURCE "PMSZOOMIN"
		MENUITEM STR0059 ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"C_ZOOMOUT"),GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )) RESOURCE "PMSZOOMOUT"
		MENUITEM STR0060 ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"PAN_NORTH"),GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )) RESOURCE "PMSSETAUP"
		MENUITEM STR0061 ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"PAN_SOUTH"),GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )) RESOURCE "PMSSETADOWN" 
		MENUITEM STR0062 ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"PAN_WEST"),GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText ))  RESOURCE "PMSSETAESQ" 
		MENUITEM STR0063 ACTION (fGeoMove(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,"PAN_EAST"),GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText ))  RESOURCE "PMSSETADIR"
		MENUITEM STR0064 ACTION (cLatStart:=cOriLatSta,cLatEnd:=cOriLatEnd,cLongStart:=cOriLonSta,cLongEnd:=cOriLonEnd,GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )) RESOURCE "PMSUPDOWN"
		MENUITEM STR0065 ACTION MsDocView(cMap,@aExclui,NIL, "\" + Curdir() ) RESOURCE "PMSPESQ"
		
		If !Empty( aCdMap )                                                                    
			MENUITEM STR0074 ACTION ( lRedraw := .F., fGeoPontos(@cLatStart,@cLongStart,@cLatEnd,@cLongEnd,aCdMap,@lRedraw),If( lRedraw, ( GeoMapRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nHeight,nWidth,nRadius,cSession,@cMap,.F.,lBounding,aCdMap),oBitMap:Load(,cMap),Eval( bMapText )), )) RESOURCE "PIN" // "Pontos"
		EndIf 			
		
	ENDMENU
	
	oDlg:bRClicked   := { |oObject,nx,ny| oMenu:Activate( nX, nY, oObject ) }
	
	@ aPosObj[2,3]-12 ,aPosObj[2,2]+6 BUTTON STR0045   SIZE 040,010 ACTION oDlg:End() OF oDlg PIXEL //"Sair"

	
	ACTIVATE DIALOG oDlg CENTERED  
	
	FErase(cMap)         
	
EndIf

//Ŀ
// Exclui o documento do diretorio temporario do Sist. operacional 
// 
 MsDocExclui( aExclui, .F. ) 

Return

/*/

Ŀ
Funo    GeoRoute      Autor  Henry Fila          Data 15.09.2003 
Ĵ
          Rotina roterizacao entre dois pontos                         
Ĵ
ParametrosExpC1: Latitude Inicial                                      
          ExpC2: Longitude Inicial                                     
          ExpC3: Latitude Final                                        
          ExpC4: Longitude Final                                       
          ExpN5: Tipo de transporte (opcional)                         
               1 - Mais rapido de carro (DEFAULT)                      
               2 - Mais simples de carro                               
               3 - Mais curto a pe                                     
               4 - Mais por transporte publico                         
               5 - Mais simples por transporte publico                 
          ExpL6 - Indica se eh processamento batch                     
Ĵ
Retorno   aArray com a seguinte estrutura                              
                 [1][1] -Codigo da Sessao de retorno                   
                 [1][2] -Canto superior do Mapa ( Latitude )           
                 [1][3] -Canto superior do Mapa ( Longitude )          
                 [1][4] -Canto inferior do Mapa ( Latitude )           
                 [1][5] -Canto inferior do Mapa ( Longitude )          
                 [1][6] -Tamanho total do trecho                       
                 [1][7] -Tempo total do trecho                         
                 [1][8] -Nome da Rua de origem                         
                 [1][9] -Nome da Rua de destino                        
                 [1][10][x][1]  -Texto com a descricao do trecho       
                 [1][10][x][2]  -BitMap do trajeto                     
                 [1][10][x][y,1]-Latitude superior do trecho           
                 [1][10][x][y,2]-Longitude superior do trecho          
                 [1][10][x][y,3]-Latitude inferior do trecho           
                 [1][10][x][y,4]-Longitude superior do trecho          
Ĵ
Descrio Esta rotina tem objetivo realizar a roterizacao entre dois   
          pontos.                                                      
Ĵ
Uso        Generico                                                    
ٱ


/*/
Static Function GeoRoute(cLatStart,cLongStart,cLatEnd,cLongEnd,nTipoTrans,lInter)

Local aRetorno   := {}
Local cLogin     := ""
Local cSenha     := ""
Local lRetorno   := .T.
Local nX         := 0
Local oWSGeo

DEFAULT lInter     := .T.
DEFAULT nTipoTrans := 1
//Ŀ
// Realiza o HandShake                                               
//

MsgRun(STR0001+" ( HandShake )",,{|| lRetorno := EcoHandShake("WEBRASKA","RANK",@cLogin,@cSenha) }) 

//Ŀ
// Verifica o login e senha                                          
//
If Empty(cLogin) .Or. !lRetorno
	If lRetorno
		ShowEco("WEBRASKA","RANK")
	EndIf
	lRetorno := .F.	
EndIf
If lRetorno
	//Ŀ
	// Executa o Web Services com o Parceiro                             
	//
	oWsGeo    := WSWEBRASKAGEOPROCESSING():New()
	GetURLSoap( @oWsGeo, "WEBRASKAGEOPROCESSING.APW", "WEBRASKA" )
	oWsGeo:cUSERCODE := cLogin
	oWsGeo:cPASSWORD := cSenha
	oWsGeo:cGEOLANGUAGE := Nil
	oWsGeo:cTRANSPORTMODE := StrZero(nTipoTrans,1)
	oWsGeo:oWSNAVPOINTS:oWSPOINTS :=WEBRASKAGEOPROCESSING_ARRAYOFNAVIDVIEW():New()
	aadd(oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW,WEBRASKAGEOPROCESSING_NAVIDVIEW():New())
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[1]:cICON      := Nil
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[1]:cLATITUDE  := AllTrim(cLatStart)
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[1]:cLONGITUDE := AllTrim(cLongStart)
	aadd(oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW,WEBRASKAGEOPROCESSING_NAVIDVIEW():New())
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[2]:cICON      := Nil
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[2]:cLATITUDE  := AllTrim(cLatEnd)
	oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[2]:cLONGITUDE := AllTrim(cLongEnd)

	If lInter
		MsgRun(STR0001+"  ( Routing )",,{|| lRetorno := oWsGeo:Routing() }) //"Geoprocessamento..."
	Else
		lRetorno := oWsGeo:Routing()
	EndIf
	DEFAULT lRetorno := .F.

	If lRetorno

		Aadd(aRetorno,{oWSGeo:oWSROUTINGRESULT:cSESSION,;
						oWSGeo:oWSROUTINGRESULT:oWSUPPERCORNER:cLATITUDE,;
						oWSGeo:oWSROUTINGRESULT:oWSUPPERCORNER:cLONGITUDE,;
						oWSGeo:oWSROUTINGRESULT:oWSLOWERCORNER:cLATITUDE,;
						oWSGeo:oWSROUTINGRESULT:oWSLOWERCORNER:cLONGITUDE,;
						oWSGeo:oWSROUTINGRESULT:cLENGTH,;
						oWSGeo:oWSROUTINGRESULT:cREALTIME,;
						Nil,;
						Nil,;
						{}})
	
		For nX := 1 To Len(oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW)
			If nX == 1
				cBitMap := "bstart"
				aRetorno[1][8] := oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSSECTION:cName
			ElseIf nX == Len(oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW)
				cBitMap := "bend"
				aRetorno[1][9] := oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSSECTION:cName
			Else
				Do case
					Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cDIRECTIONCODE == "0"
						cBitMap := "bahead"
					Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cDIRECTIONCODE == "1"
						Do Case
							Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cINTENSITY == "2"
								cBitMap := "bkeepleft"
							Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cINTENSITY == "3"
								cBitMap := "bbearleft"
							Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cINTENSITY == "4"
								cBitMap := "bleft"
							Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cINTENSITY == "5"
								cBitMap := "bturnsharpleft"
	 					EndCase
					Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cDIRECTIONCODE == "2"
						Do Case
							Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cINTENSITY == "2"
								cBitMap := "bkeepright"
							Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cINTENSITY == "3"
								cBitMap := "bbearright"
							Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cINTENSITY == "4"
								cBitMap := "bright"
							Case oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cINTENSITY == "5"
								cBitMap := "bturnsharpright"
	 					EndCase
				EndCase
			EndIf
			aadd(aRetorno[1][10],{oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSINTERSECTION:cDIRECTION,;
								cBitMap,;
								{oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSSECTION:oWSUPPERCORNER:cLatitude,;
								oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSSECTION:oWSUPPERCORNER:cLongitude,;
								oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSSECTION:oWSLOWERCORNER:cLatitude,;
								oWSGeo:oWSROUTINGRESULT:oWSROADMAP:oWSROADMAPVIEW[nX]:oWSSECTION:oWSLOWERCORNER:cLongitude}})
		Next nX
	Else                       
		If lInter
			GeoError()
		EndIf
	EndIf
EndIf
Return(aRetorno)

/*/

Ŀ
Funo    GeoRanking    Autor  Henry Fila          Data 15.09.2003 
Ĵ
          Rotina ranking de determinados enderecos                     
Ĵ
ParametrosExpA1: Array com os dados de origem                          
               [1] Latitude Inicial                                    
               [2] Longitude Inicial                                   
          ExpA2: Array com as coordenadas a serem rankeadas            
               [1] Latitude                                            
               [2] Longitude                                           
          ExpN3: Tipo de transporte (opcional)                         
               1 - Mais rapido de carro (DEFAULT)                      
               2 - Mais simples de carro                               
               3 - Mais curto a pe                                     
               4 - Mais por transporte publico                         
               5 - Mais simples por transporte publico                 
          ExpL4 - Indica se eh processamento batch                     
Ĵ
Retorno   Nenhum                                                       
Ĵ
Descrio Esta rotina tem objetivo rankear coordenadas                 
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function GeoRanking(aOrigem,aDestinos,nTipoTrans,lInter)

Local aRetorno   := {}
Local cLogin     := ""
Local cSenha     := ""
Local lRetorno   := .T.
Local nX         := 0
Local oWsGeo

DEFAULT nTipoTrans := 1
DEFAULT lInter     := .T.
//Ŀ
// Realiza o HandShake                                               
//

MsgRun(STR0001+" ( HandShake )",,{|| lRetorno := EcoHandShake("WEBRASKA","RANK",@cLogin,@cSenha) }) 

//Ŀ
// Verifica o login e senha                                          
//
If Empty(cLogin) .Or. !lRetorno
	If lRetorno
		ShowEco("WEBRASKA","RANK")
	EndIf
	lRetorno := .F.	
EndIf
If lRetorno
	//Ŀ
	//Verifica se os parametros obrigatorios foram passados 
	//  
	If Len(aOrigem) > 0 .And. Len(aDestinos) > 0	
		//Ŀ
		// Executa o Web Services com o Parceiro                             
		//
		oWsGeo    := WSWEBRASKAGEOPROCESSING():New()
		GetURLSoap( @oWsGeo, "WEBRASKAGEOPROCESSING.APW", "WEBRASKA" )
		oWsGeo:cUSERCODE := cLogin
		oWsGeo:cPASSWORD := cSenha
		oWsGeo:cGEOLANGUAGE := Nil
		oWsGeo:cTRANSPORTMODE := StrZero(nTipoTrans,1)
		oWsGeo:oWSNAVPOINTS:oWSPOINTS :=WEBRASKAGEOPROCESSING_ARRAYOFNAVIDVIEW():New()
		aadd(oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW,WEBRASKAGEOPROCESSING_NAVIDVIEW():New())
		oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[1]:cICON      := Nil
		oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[1]:cLATITUDE  := AllTrim(aOrigem[1])
		oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[1]:cLONGITUDE := AllTrim(aOrigem[2])
		For nX := 1 To Len(aDestinos)
			aadd(oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW,WEBRASKAGEOPROCESSING_NAVIDVIEW():New())
			oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX+1]:cICON      := Nil
			oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX+1]:cLATITUDE  := Alltrim(aDestinos[nX][1])
			oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX+1]:cLONGITUDE := Alltrim(aDestinos[nX][2])
		Next nX
		
		If lInter		
			MsgRun(STR0001+"  ( Ranking )",,{|| lRetorno := oWsGeo:Ranking() })			 //"Geoprocessamento..."
		Else
			lRetorno := oWsGeo:Ranking()
		EndIf
		DEFAULT lRetorno := .F.
		
		If lRetorno
			For nX :=1 To Len(oWsGeo:oWSRANKINGRESULT:oWSROADMAPRANKINGVIEW)								
				Aadd(aRetorno,{oWsGeo:oWSRANKINGRESULT:oWSROADMAPRANKINGVIEW[nX]:oWSNAVID:cLatitude,;
								oWsGeo:oWSRANKINGRESULT:oWSROADMAPRANKINGVIEW[nX]:oWSNAVID:cLongitude,;
								oWsGeo:oWSRANKINGRESULT:oWSROADMAPRANKINGVIEW[nX]:cRank,;
								oWsGeo:oWSRANKINGRESULT:oWSROADMAPRANKINGVIEW[nX]:cTravelTime})
			Next nX
			//Ŀ
			// Ordena por distancia da origem                       
			//  
			aRetorno := aSort(aRetorno,,,{|x,y| x[3] < y[3]})				
			If Empty(aRetorno) .And. lInter
				GeoError()
			EndIf				
		Else                       
			If lInter
				GeoError()
			EndIf
		EndIf			
	EndIf
EndIf	
Return(aRetorno)


/*/

Ŀ
Funo    GeoMulti      Autor  Henry Fila          Data 15.09.2003 
Ĵ
          Rotina multi-stop routing                                    
Ĵ
ParametrosExpA1: Array com os dados de origem                          
               [1] Latitude Inicial                                    
               [2] Longitude Inicial                                   
          ExpA2: Array com os dados de final da rota                   
               [1] Latitude final                                      
               [2] Longitude final                                     
          ExpA2: Array com as coordenadas a serem roteadas             
               [1] Latitude                                            
               [2] Longitude                                           
          ExpN3: Tipo de transporte (opcional)                         
               1 - Mais rapido de carro (DEFAULT)                      
               2 - Mais simples de carro                               
               3 - Mais curto a pe                                     
               4 - Mais por transporte publico                         
               5 - Mais simples por transporte publico                 
          ExpL4 - Indica se eh processamento batch                     
Ĵ
Retorno   aArray com a seguinte estrutura                              
                 [1][1] -Distancia em metros total da rota             
                 [1][2] -Tempo total da rota em segundos               
                 [1][3] -Quantidade de pontos                          
                 [1][4] -Sub Array com os dados da rota                
                 [1][4][n][1] -Latitude do ponto de origem             
                 [1][4][n][2] -Longitude do ponto de origem            
                 [1][4][n][3] -Latitude do ponto de destino            
                 [1][4][n][4] -Longitude do ponto de destino           
                 [1][4][n][5] -Distancia entre os pontos               
                 [1][4][n][6] -Tempo de viagem entre os pontos         
Ĵ
Descrio Esta rotina tem objetivo realizar a rota multi ponto         
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function GeoMulti(aFrom,aTo,aPoints,nTipoTrans,lInter)

Local aRetorno   := {}
Local aRota      := {}
Local cLogin     := ""
Local cSenha     := ""
Local lRetorno   := .T.
Local nX         := 0
Local oWsGeo

DEFAULT nTipoTrans := 1
DEFAULT lInter     := .T.
//Ŀ
// Realiza o HandShake                                               
//

MsgRun(STR0001+" ( HandShake )",,{|| lRetorno := EcoHandShake("WEBRASKA","RANK",@cLogin,@cSenha) }) 

//Ŀ
// Verifica o login e senha                                          
//
If Empty(cLogin) .Or. !lRetorno
	If lRetorno
		ShowEco("WEBRASKA","RANK")
	EndIf
	lRetorno := .F.	
EndIf
If lRetorno
	//Ŀ
	//Verifica se os parametros obrigatorios foram passados 
	//  
	If Len(aFrom) > 0 .And. Len(aTo) > 0 .And. Len(aPoints) > 0
		//Ŀ
		// Executa o Web Services com o Parceiro                             
		//	
		oWsGeo    := WSWEBRASKAGEOPROCESSING():New()
		GetURLSoap( @oWsGeo, "WEBRASKAGEOPROCESSING.APW", "WEBRASKA" )
		oWsGeo:cUSERCODE := cLogin
		oWsGeo:cPASSWORD := cSenha
		oWsGeo:cGEOLANGUAGE := Nil
		oWsGeo:cTRANSPORTMODE := StrZero(nTipoTrans,1)		
		oWsGeo:oWSnavPointStart:cLatitude  := AllTrim(aFrom[1])
		oWsGeo:oWSnavPointStart:cLongitude := AllTrim(aFrom[2])
		oWsGeo:oWSnavPointEnd:cLatitude    := AllTrim(aTo[1])
		oWsGeo:oWSnavPointEnd:cLongitude   := AllTrim(aTo[2])
		oWsGeo:oWSNAVPOINTS := WEBRASKAGEOPROCESSING_NAVPOINTVIEW():New()
		oWsGeo:oWSNAVPOINTS:oWSPOINTS :=WEBRASKAGEOPROCESSING_ARRAYOFNAVIDVIEW():New()	
		For nX := 1 To Len(aPoints)
			aadd(oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW,WEBRASKAGEOPROCESSING_NAVIDVIEW():New())
			oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX]:cLATITUDE  := AllTrim(aPoints[nX][1])
			oWsGeo:oWSNAVPOINTS:oWSPOINTS:oWSNAVIDVIEW[nX]:cLONGITUDE := AllTrim(aPoints[nX][2])
		Next nX					

		If lInter		
			MsgRun(STR0001+"  ( MultiStopRouting )",,{|| lRetorno := oWsGeo:MultiStopRouting() })			 //"Geoprocessamento..."
		Else
			lRetorno := oWsGeo:MultiStopRouting()
		EndIf
		DEFAULT lRetorno := .F.
		
		If lRetorno
			Aadd(aRetorno,{oWsGeo:oWSMULTISTOPROUTINGRESULT:oWSROADMAPRANKINGVIEW[1]:cLength,;
							Len(oWsGeo:oWSMULTISTOPROUTINGRESULT:oWSROADMAPRANKINGVIEW),;  
							oWsGeo:oWSMULTISTOPROUTINGRESULT:oWSROADMAPRANKINGVIEW[1]:cTravelTime,{}})
		
			For nX := 2 To Len(oWsGeo:oWSMULTISTOPROUTINGRESULT:oWSROADMAPRANKINGVIEW)
				Aadd(aRota,{oWsGeo:oWSMULTISTOPROUTINGRESULT:oWSROADMAPRANKINGVIEW[nX-1]:oWsNavId:cLatitude,;
							oWsGeo:oWSMULTISTOPROUTINGRESULT:oWSROADMAPRANKINGVIEW[nX-1]:oWsNavId:cLongitude,;
							oWsGeo:oWSMULTISTOPROUTINGRESULT:oWSROADMAPRANKINGVIEW[nX]:oWsNavId:cLatitude,;
							oWsGeo:oWSMULTISTOPROUTINGRESULT:oWSROADMAPRANKINGVIEW[nX]:oWsNavId:cLongitude,;
							oWsGeo:oWSMULTISTOPROUTINGRESULT:oWSROADMAPRANKINGVIEW[nX]:cLength,;
							oWsGeo:oWSMULTISTOPROUTINGRESULT:oWSROADMAPRANKINGVIEW[nX]:cTravelTime})
			Next nX
	
			aRetorno[1][4] := aClone(aRota)
				
			If lInter .And. Empty(aRetorno)
				GeoError()	
			EndIf	
			
		Else                       
			If lInter
				GeoError()
			EndIf	
		EndIf
	EndIf
EndIf
Return(aRetorno)

/*/

Ŀ
Funo    GeoPrcScr  Autor  Henry Fila             Data 15.09.2003 
Ĵ
          Rotina multipla escolha de geoprocessamento                  
Ĵ
ParametrosExpA1: Array com os dados do retorno do geoprocessamento     
                [1]-Rua                                                
                [2]-Bairro                                             
                [3]-Cep                                                
                [4]-Cidade                                             
                [5]-Estado                                             
                [6]-Latitude                                           
                [7]-Longitude                                          
                Este array eh obtido atraves da chamada da funcao      
                CodGeoPrc()                                            
Ĵ
Retorno   ExpA1 : Latitude e Longitude                                 
Ĵ
Descrio Esta rotina tem como objetivo mostrar os pontos de retorno do
          geoprocessamento                                             
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function GeoPrcScr(aArray)

Local aRetorno := {}

Local cBitmap  := ""
Local cGeo     := ""

Local oFont
Local oDlg
Local oBmp
Local oGeo

If Len(aArray) > 0

	DEFINE FONT oFont NAME "Arial" SIZE 0, -11
		
	cBitmap := "PROJETOAP"
		
	DEFINE MSDIALOG oDlg TITLE STR0002 FROM 280,320 TO 580,850 OF oMainWnd PIXEL  //"Geocodificacao"
	@ 0 , 0 BITMAP oBmp RESNAME cBitMap oF oDlg SIZE 48,488 NOBORDER WHEN .F. PIXEL
	
	@ 013,050 SAY STR0003 SIZE 223, 7 OF oDlg PIXEL //"Pedido"
	
	@ 23,50 LISTBOX oGeo Var cGeo FIELDS HEADER STR0004,; //"Endereco"
		STR0005,; //"Bairro"
		STR0006,; //"Cep"
		STR0007,; //"Cidade"
		STR0008 SIZE 210,100  OF oDlg PIXEL  //"Estado"
		    	
		oGeo:SetArray(aArray)
		oGeo:bLine:={ ||{aArray[oGeo:nAT,1],;
		aArray[oGeo:nAT,2],;	
		aArray[oGeo:nAT,3],;	
		aArray[oGeo:nAT,4],;			
		aArray[oGeo:nAT,5]}}
		DEFINE SBUTTON oBut2 FROM 130, 204 TYPE 1 ENABLE OF oDlg PIXEL ACTION (nOpca := 1,	aRetorno := {{aArray[oGeo:nAT,1],;
																										aArray[oGeo:nAT,2],;
																										aArray[oGeo:nAT,3],;
																										aArray[oGeo:nAT,4],;
																										aArray[oGeo:nAT,5],;
																										aArray[oGeo:nAT,6],;
																										aArray[oGeo:nAT,7]}},oDlg:End())
		DEFINE SBUTTON oBut2 FROM 130, 234 TYPE 2 ENABLE OF oDlg PIXEL ACTION (nOpca := 0, oDlg:End())
		
	ACTIVATE MSDIALOG oDlg CENTERED

EndIf
	
Return(aRetorno)

/*/

Ŀ
Funo    GeoSavCoor    Autor  Henry Fila          Data 15.09.2003 
Ĵ
          Rotina gravacao da tabela de entidade x coordenada           
Ĵ
ParametrosExpC1: Filial da entidade                                    
          ExpC2: Alias da entidade                                     
          ExpC3: Codigo da entidade                                    
          ExpC4: Latitude                                              
          ExpC5: Longitude                                             
Ĵ
Retorno   Nenhum                                                       
Ĵ
Descrio Esta rotina tem objetivo realizar a rota multi ponto         
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function GeoSavCoor(cFilEnt,cEntidade,cCodEnt,cLatitude,cLongitude,lAsk,lDeleta)

Local lGrava  := .T.                                                       
Local lTravou := .F.

DEFAULT cFilEnt   := ""
DEFAULT cEntidade := ""
DEFAULT cCodEnt   := ""
DEFAULT cLatitude := ""
DEFAULT cLongitude:= ""
DEFAULT lAsk      := .T.
DEFAULT lDeleta   := .F.

If Empty(cEntidade) .Or. Empty(cCodEnt) .Or. ((Empty(cLatitude) .Or. Empty(cLongitude)).And.!lDeleta)
	lGrava := .F. 
EndIf

If lGrava	

	If !lAsk .Or. (lAsk .And. MsgYesNo(OemtoAnsi(STR0009))) //"Confirma atualizao das coordenadas da entidade ?"
		DAR->(dbSetOrder(1))
		If DAR->(MsSeek(xFilial("DAR")+cFilEnt+cEntidade+Alltrim(cCodEnt)))
			RecLock("DAR")
			lTravou := .T.
		Else
			If !lDeleta
				RecLock("DAR",.T.)
			EndIf
		EndIf		
		If !lDeleta
			DAR->DAR_FILIAL := xFilial("DAR")
			DAR->DAR_FILENT := cFilEnt
			DAR->DAR_ENTIDA := cEntidade
			DAR->DAR_CODENT := cCodEnt
			DAR->DAR_LATITU := cLatitude
			DAR->DAR_LONGIT := cLongitude
		Else
			If lTravou
				DAR->(dbDelete())
			EndIf
		EndIf	
		MsUnlock()
	EndIf	    
EndIf
	
Return(lGrava)

/*/

Ŀ
Funo    GeoExtEnt     Autor  Henry Fila          Data 15.09.2003 
Ĵ
          Verifica se a entidade ja foi geoprocessada                  
Ĵ
ParametrosExpC1: Filial da entidade                                    
          ExpC2: Alias da entidade                                     
          ExpC3: Codigo da entidade                                    
          ExpA3: Array por referencia para trazer as coordenadas       
Ĵ
Retorno   Nenhum                                                       
Ĵ
Descrio Esta rotina tem objetivo realizar a rota multi ponto         
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function GeoExtEnt(cFilEnt,cEntidade,cCodEnt,aCoor)

Local aArea     := GetArea()
Local aAreaDAR  := DAR->(GetArea())
Local lRet      := .T.


DAR->(dbSetOrder(1))
If !DAR->(MsSeek(xFilial("DAR")+cFilEnt+cEntidade+Alltrim(cCodEnt)))
	lRet := .F.
Else
	Aadd(aCoor,DAR->DAR_LATITU)
	Aadd(aCoor,DAR->DAR_LONGIT)	
	
	dbSelectArea(DAR->DAR_ENTIDA)
	
EndIf		

RestArea(aAreaDAR)
RestArea(aArea)
	
Return(lRet)

/*/

Ŀ
Funo    GeoScrRoute  Autor  Henry Fila           Data 12.04.2002 
Ĵ
          Geoprocessamento                                             
                                                                       
Ĵ
ParametrosNenhum                                                       
Ĵ
Retorno   ExpL1 - .T.                                                  
Ĵ
Descrio Esta rotina tem como objetivo mostrar os dados da rota       
Ĵ
Uso        Field Service                                               
ٱ


/*/
Function GeoScrRoute( aRoute )

Local aRetorno := aClone(aRoute[1][10])
Local aBitMaps := {}
Local aObjects := {}
Local aInfo    := {}
Local aSize    := MsAdvSize() 							
Local aButtons := {{"GEOTRECHO",{||GeoMapRoute(aRetorno[oList:nAT,3,1],;
												aRetorno[oList:nAT,3,2],;
												aRetorno[oList:nAT,3,3],;
												aRetorno[oList:nAT,3,4],Nil,Nil,Nil,aRoute[1][1]) },STR0010},; //"Trecho"
					{"GEOROTA",{||GeoMapRoute(aRoute[1][2],;
											aRoute[1][3],;
											aRoute[1][4],;
											aRoute[1][5],Nil,Nil,Nil,aRoute[1][1]) },STR0011 },; //"Rota"
					{"GEOEMAIL",{||GeoEmail(aRoute) },"Email"},;
					{"PMSPRINT",{||Geor010(aRoute)},STR0012,STR0013} } //"Imprime o trajeto"###"Imprime"
Local nLoop    := 0    
Local nOpca    := 0
Local oDlg
Local oFont

DEFINE FONT oFont NAME "Arial" SIZE 0, -11 BOLD

If Len(aRoute) > 0

	For nLoop := 1 to Len( aRetorno ) 
		If Empty( Ascan( aBitMaps, { |x| x[1] == aRetorno[nLoop,2 ] } ) ) 
		    AAdd( aBitMaps, { aRetorno[nLoop,2], LoadBitmap( GetResources(), aRetorno[nLoop,2] ) } ) 
		EndIf 			
	Next nLoop 
	
	aObjects := {} 
	AAdd( aObjects, { 100, 100, .t., .t.,.t. } )
	
	aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 } 
	
	aPosObj := MsObjSize( aInfo, aObjects ) 
	
	DEFINE MSDIALOG oDlg TITLE STR0014 From aSize[ 7 ], 0 to aSize[ 6 ], aSize[ 5 ] PIXEL //"Trajeto"

	@ aPosObj[1][1],aPosObj[1][2]+30 SAY STR0015 + aRoute[1][8] FONT oFont Of oDlg PIXEL //"Origem: "
	@ aPosObj[1][1]+10,aPosObj[1][2]+30 SAY STR0016 + aRoute[1][9] FONT oFont Of oDlg PIXEL //"Destino : " //"Destino: "
	@ aPosObj[1][1]+20,aPosObj[1][2]+30 SAY STR0017 + GeoTime(Val(aRoute[1][7])) FONT oFont Of oDlg PIXEL //"Tempo total do trajeto: "
	@ aPosObj[1][1]+20,aPosObj[1][2]+150 SAY STR0018 + aRoute[1][6] + "m" FONT oFont Of oDlg PIXEL //"Distancia mdia percorrida: "
	@  0,-25 BITMAP oBmp RESNAME "PROJETOAP" oF oDlg SIZE 55, 1000 NOBORDER WHEN .F. PIXEL
  	@  aPosObj[1][1]+35, aPosObj[1][2]+30 LISTBOX oList VAR cVar Fields HEADER "",STR0019 SIZE aPosObj[1][3]-30, aPosObj[1][4]-40 Of oDlg PIXEL //"Coordenadas de direo"
	oList:SetArray( aRetorno )
	oList:bLine := { || { aBitMaps[ AScan( aBitMaps, {|x| x[1] == aRetorno[oList:nAT,2 ] }),2],"   "+aRetorno[oList:nAT,1] } }
		
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpcA:=1,oDlg:End()},{||oDlg:End()},,aButtons)CENTERED 
					
EndIf

Return(.T.)

/*/

Ŀ
Funo    GeoPersona Autor  Henry Fila             Data 12.04.2002 
Ĵ
          Funcao que traca rota do SM0 ou de endereco personalizado    
                                                                       
Ĵ
ParametrosEXPC1: Latitude destino                                      
          EXPC2: Longitude destino                                     
          EXPA3: Endereco                                              
                 [1] Endereco                                          
                 [2] Cidade                                            
                 [3] Estado                                            
                 [4] CEP                                               
Ĵ
Retorno   ExpC1 - 01h10m30s                                            
Ĵ
Descrio Esta rotina tem como trazer uma string de hora               
Ĵ
Uso        Geoprocessamento                                            
ٱ


/*/

Function GeoPersonal(cLatDest,cLongDest,aEnd2)

Local aEnd1     := {} 
Local cBitmap   := "PROJETOAP"
Local lRet      := .F.

Local nRadio1 := 1
Local nRadio2 := 1
Local nRadio3 := 1
Local nRadio4 := 1

Local oRadio1
Local oRadio2
Local oWizard   
Local oEndereco 
Local oCidade
Local oEstado
Local oCep

Local oEndereco2 
Local oCidade2
Local oEstado2
Local oCep2

Local oPanel      
Local oPanel2

// Verifica a existencia 

If Empty( SM0->M0_ENDENT ) .And. Empty( SM0->M0_CEPENT ) 
	aEnd1 := {SM0->M0_ENDCOB,SM0->M0_CIDCOB,SM0->M0_ESTCOB,SM0->M0_CEPCOB }
Else 
	aEnd1 := {SM0->M0_ENDENT,SM0->M0_CIDENT,SM0->M0_ESTENT,SM0->M0_CEPENT }
EndIf 	

DEFAULT aEnd2 := {CriaVar("A1_END",.F.),CriaVar("A1_MUN",.F.),CriaVar("A1_EST",.F.),CriaVar("A1_CEP",.F.)}
If Empty(cLatDest) .Or. Empty(cLongDest)
	nRadio2 := 2
EndIf

DEFINE WIZARD oWizard TITLE STR0014 HEADER STR0020 ;  //"Trajeto"###"Dados genricos"
		MESSAGE STR0021 TEXT " "; //"Informe os dados necessrios para o trajeto"
		NEXT {|| .T.} ;
		FINISH {||.T.} PANEL NOFIRSTPANEL 

	// @ 00,00 MSPANEL oPanel PROMPT "" SIZE __DlgWidth(oWizard:GetPanel(1))-05,__DlgHeight(oWizard:GetPanel(1))-30 OF oWizard:GetPanel(1) 
	
	@ 05,12 RADIO oRadio1 VAR nRadio1 3D ;
		SIZE 140,10 ;
		ITEMS STR0022,STR0023 ; //"Endereo atual da empresa"###"Outro endereo"
		OF oWizard:GetPanel(1)
		
	oRadio1:bChange := { || oEndereco:SetEnable( nRadio1 == 2 ),;
								oCidade:SetEnable( nRadio1 == 2 ),;
								oEstado:SetEnable( nRadio1 == 2 ),;
								oCep:SetEnable( nRadio1 == 2 ) }		   
								
	@ 05,180 RADIO oRadio2 VAR nRadio2 3D ;
			SIZE 95,10 ;
			ITEMS STR0024,; //"Endereco informado como origem"
			STR0025 ; //"Endereco informado como destino"
			OF oWizard:GetPanel(1) ;
			ON CLICK { ||  .T.}              								
				
	@ 035,012 Say STR0026 OF oWizard:GetPanel(1) PIXEL SIZE 25,9  //"Endereo"
	@ 045,012 MSGET oEndereco VAR aEnd1[1] PICTURE "@!" OF oWizard:GetPanel(1) PIXEL SIZE 250,9

	@ 065,012 Say STR0007 Of oWizard:GetPanel(1) PIXEL SIZE 25,9  //"Cidade"
	@ 075,012 MSGET oCidade VAR aEnd1[2] PICTURE "@!"   OF oWizard:GetPanel(1) PIXEL SIZE 160,9

	@ 065,237 Say STR0008 Of oWizard:GetPanel(1) PIXEL SIZE 25,9  //"Estado"
	@ 075,237 MSGET oEstado VAR aEnd1[3] PICTURE "@!"   F3 "12" OF oWizard:GetPanel(1) PIXEL SIZE 25,9

	@ 095,012 Say STR0006 Of oWizard:GetPanel(1) PIXEL SIZE 25,9  //"Cep"
	@ 105,012 MSGET oCep VAR aEnd1[4] PICTURE "@R 99999-999"   PICTURE "99999-999" OF oWizard:GetPanel(1) PIXEL SIZE 50,9
	
	Eval( oRadio1:bChange ) 
                                                         
	CREATE PANEL oWizard  HEADER STR0020 MESSAGE STR0021; //"Dados genricos"###"Informe os dados necessrios para o trajeto"
	 BACK {||.T.} FINISH {|| lRet := .T.} PANEL
	 
	// @ 00,00 MSPANEL oPanel2 PROMPT "" SIZE __DlgWidth(oWizard:GetPanel(2))-05,__DlgHeight(oWizard:GetPanel(2))-30 OF oWizard:GetPanel(2) 	 

	@ 05,12 RADIO oRadio4 VAR nRadio4 3D ;
			SIZE 140,10 ;
			ITEMS STR0051,;//"Endereo atual"
			STR0023 ; //"Outro endereo"
			OF oWizard:GetPanel(2)           
			
	oRadio4:bChange := { || oEndereco2:SetEnable( nRadio4 == 2 ),;
								oCidade2:SetEnable( nRadio4 == 2 ),;
								oEstado2:SetEnable( nRadio4 == 2 ),;
								oCep2:SetEnable( nRadio4 == 2 ) }		
				
	@ 035,012 Say STR0026 OF oWizard:GetPanel(2) PIXEL SIZE 25,9  //"Endereo"
	@ 045,012 MSGET oEndereco2 VAR aEnd2[1] PICTURE "@!" OF oWizard:GetPanel(2) PIXEL SIZE 250,9

	@ 065,012 Say STR0007 Of oWizard:GetPanel(2) PIXEL SIZE 25,9  //"Cidade"
	@ 075,012 MSGET oCidade2 VAR  aEnd2[2] PICTURE "@!"  OF oWizard:GetPanel(2) PIXEL SIZE 160,9

	@ 065,237 Say STR0008 Of oWizard:GetPanel(2) PIXEL SIZE 25,9  //"Estado"
	@ 075,237 MSGET oEstado2 VAR  aEnd2[3] PICTURE "@!"  F3 "12" OF oWizard:GetPanel(2) PIXEL SIZE 25,9

	@ 095,012 Say STR0006 Of oWizard:GetPanel(2) PIXEL SIZE 25,9  //"Cep"
	@ 105,012 MSGET oCep2 VAR  aEnd2[4] PICTURE "@R 99999-999" PICTURE "99999-999" OF oWizard:GetPanel(2) PIXEL SIZE 50,9
	
	Eval( oRadio4:bChange ) 

	CREATE PANEL oWizard  HEADER STR0027 MESSAGE STR0028 ; //"Parmetros do trajeto"###"Informe o tipo de transporte a ser realizado o trajeto."
	 BACK {||.T.} FINISH {|| lRet := .T.} PANEL

	@ 0 , 0 BITMAP oBmp RESNAME cBitMap oF oWizard:GetPanel(3) SIZE 48,488 NOBORDER WHEN .F. PIXEL

	@ 15,55  RADIO oRadio3 VAR nRadio3 3D ;
				SIZE 110,10 ;
				ITEMS STR0029,; //"Mais rpido de veculo"
					 STR0030,;  //"Mais simples de veculo"
					 STR0031,; //"Mais curto a p"
					 STR0032,; //"Mais rpido por transporte pblico"
					 STR0033 ; //"Mais simples por transporte pblico"
				OF oWizard:GetPanel(3) ;
				ON CLICK { ||  .T.}              
	
ACTIVATE WIZARD oWizard CENTERED  WHEN {||.T.}

If lRet
	GeoPerProc(cLatDest,cLongDest,nRadio1,nRadio2,nRadio3,nRadio4,aEnd1,aEnd2)
EndIf	

Return

/*/

Ŀ
Funo    GeoPerProc Autor  Henry Fila             Data 12.04.2002 
Ĵ
          Funcao que faz o trajeto dos dados informado na GeoPersonal  
                                                                       
Ĵ
ParametrosExpC1: Latitude destino                                      
          ExpC2: Longitude destino                                     
          ExpN3: Indica qual o endereco 1                              
          ExpN4: Indica se a coordenada informada e origem ou destino  
          ExpN5: Tipo do trajeto a ser realizado                       
          ExpN6: Indica qual o endereco 2                              
          ExpA7: Endereco 1                                            
          ExpA8: Endereco 2                                            
Ĵ
Retorno   Nenhum                                                       
Ĵ
Descrio Funcao auxiliar da GeoPersonal                               
Ĵ
Uso        Geoprocessamento                                            
ٱ


/*/
Static Function GeoPerProc(cLatDest,cLongDest,nRadio,nRadio2,nRadio3,nRadio4,aEnd1,aEnd2)

Local aCoorSM0 := {}
Local aArray   := {}
Local aArrayScr:= {}
Local aRet     := {}
Local cLatOri  := ""
Local cLongOri := ""

If nRadio == 1         
	//Ŀ
	// Mantem o endereco cadastrado para a empresa                       
	//
	If !GeoExtEnt(Space(Len(SM0->M0_CODFIL)),"SM0",cEmpAnt+cFilAnt,@aCoorSM0)
		Geoa010()
		GeoExtEnt(Space(Len(SM0->M0_CODFIL)),"SM0",cEmpAnt+cFilAnt,@aCoorSM0)
	EndIf
	If Len(aCoorSM0) > 0
		cLatOri  := aCoorSM0[1]
		cLongOri := aCoorSM0[2]
	EndIf
Else

	//Ŀ
	// Novo endereco                                                     
	//
	aArray := CodGeoPrc(aEnd1[1],aEnd1[2],aEnd1[3],aEnd1[4],.T.) 
	If Len(aArray) > 0
		aArrayScr := GeoPrcScr(aArray)
		If Len(aArrayScr) > 0
			cLatOri  := aArrayScr[1][6]
			cLongOri := aArrayScr[1][7]
		EndIf	
	EndIf               
EndIf
If nRadio4 == 2
	aArray := CodGeoPrc(aEnd2[1],aEnd2[2],aEnd2[3],aEnd2[4],.T.) 
	If Len(aArray) > 0
		aArrayScr := GeoPrcScr(aArray)
		If Len(aArrayScr) > 0
			cLatDest  := aArrayScr[1][6]
			cLongDest := aArrayScr[1][7]
		EndIf	
	EndIf       
EndIf

If !Empty( cLatori ) .And. !Empty( cLongOri ) 

	If nRadio2 == 1
		aRet := GeoRoute(cLatOri,cLongOri,cLatDest,cLongDest,nRadio3)
	Else
		aRet := GeoRoute(cLatDest,cLongDest,cLatOri,cLongOri,nRadio3)
	EndIf
	
	If Len(aRet) > 0
		GeoScrRoute(aRet)		
	EndIf
	
EndIf 	
	
Return (.T.)

/*/

Ŀ
Funo    GeoEmail   Autor  Henry Fila             Data 12.04.2002 
Ĵ
          Funcao que envia o email do trajeto                          
                                                                       
Ĵ
ParametrosEXPA1: Array contendo os dados da GeoRoute()                 
Ĵ
Retorno   Nenhum                                                       
Ĵ
Descrio Esta rotina tem como objetivo enviar trajetos por email      
Ĵ
Uso        Geoprocessamento                                            
ٱ


/*/
Static Function GeoEmail(aRoute)

Local cMensagem := ""

Local cBitMap   := "LOGIN"
Local cEmail    := Space(100)
Local cSubject  := Padr(STR0034,100) //"Destino a seguir"

Local lOk       := .F.
Local nX        := 0
Local nOpca     := 0
Local aWay      := aRoute[1][10]                                


DEFINE MSDIALOG oDlg Title STR0035 From 200,001 to 500,600 Pixel //"Envio de trajeto por email"

	@ 10 , 0 BITMAP oBmp RESNAME cBitMap oF oDlg SIZE 48,488 NOBORDER WHEN .F. PIXEL

	@ 017,060 Say STR0036 Size 30,7 Of oDlg Pixel //"Para: "
	@ 017,090 MsGet cEmail  When .T. Size 200,10 Of oDlg Pixel

	@ 035,060 Say STR0037 Size 30,7 Of oDlg Pixel //"Assunto: "
	@ 035,090 MsGet cSubject When .T. Size 200,10 Of oDlg Pixel

ACTIVATE DIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg, { || nOpca := 1,oDlg:End() }, {||nopca := 0,oDlg:End()})		

If nOpca == 1  

	cEmail := Alltrim(cEmail)

	cMensagem+= "<html>"
	
	cMensagem:='<head>'
	cMensagem+='<title>' + 'Titulo' + '</title>'
	cMensagem+='</head>'
	cMensagem+='<body>
	
	cMensagem+= "<div>"
	
	cMensagem+="<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><u><span style='font-family:Arial;mso-ansi-language:PT-BR'>"+STR0038+"<o:p></o:p></span></u></b></p>" //"Trajeto Roteirizado por Geoprocessamento MP8 Protheus"
	
	cMensagem+="<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span style='font-family:Arial;mso-ansi-language:PT-BR'>"+STR0039+"</span></b><span" //"Endereco Partida : "
	cMensagem+="style='font-family:Arial;mso-ansi-language:PT-BR'>"+aRoute[1][8]+"<o:p></o:p></span></p>"
	
	cMensagem+="<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span style='font-family:Arial;mso-ansi-language:PT-BR'>"+"Endereco Destino : "+"</span></b><span"
	cMensagem+="style='font-family:Arial;mso-ansi-language:PT-BR'>"+aRoute[1][9]+"<o:p></o:p></span></p>"
	
	cMensagem+="<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span style='font-family:Arial;mso-ansi-language:PT-BR'>"+STR0040+"</span></b><span" //"Tempo mdio do trajeto: "
	cMensagem+=" style='font-family:Arial;mso-ansi-language:PT-BR'>"+GeoTime(Val(aRoute[1][7]))+"<o:p></o:p></span></p>"
	
	cMensagem+="<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span style='font-family:Arial;mso-ansi-language:PT-BR'>"+STR0041+"</span></b><span" //"Distncia mdia do trajeto em metros: "
	cMensagem+=" style='font-family:Arial;mso-ansi-language:PT-BR'>"+aRoute[1][6]+"<o:p></o:p></span></p>"
	
	cMensagem+="<p class=MsoNormal><span style='font-family:Arial;mso-ansi-language:PT-BR'><o:p>&nbsp;</o:p></span></p>"
	
	cMensagem+="<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><i style='mso-bidi-font-style:"
	cMensagem+="normal'><u><span style='font-family:Arial;mso-ansi-language:PT-BR'>"+STR0034+"</o:p></span></u></i></b></p>" //"Destino a seguir"
	
	For nX := 1 to Len(aWay)
		cMensagem+= "<p class=MsoNormal><span style='font-family:Arial;mso-ansi-language:PT-BR'>"+aWay[nX][1]+"<o:p></o:p></span></p>
	Next
	
	cMensagem+= "</div>"
	
	cMensagem+= "</body>"
	
	cMensagem+= "</html>"
	
	MConnect(cMensagem,{{"",cEmail}},cSubject,.T.,@lOk)
	
	If lOk
		MDisconnect()
	EndIf	
	
EndIf
	
Return

/*/

Ŀ
Funo    GeoError      Autor  Henry Fila          Data 15.09.2003 
Ĵ
          Rotina de descricao dos erros                                
Ĵ
ParametrosExpC1: Codigo do erro                                        
Ĵ
Retorno   Nenhum                                                       
Ĵ
Descrio Esta rotina tem como objetivo geoprocessar varios clietnes   
Ĵ
Uso        Generico                                                    
ٱ


/*/
Static Function GeoError()

MsgAlert(STR0042+GetWscError()) //"Erro de geocodificao: "

Return

/*/

Ŀ
Funo    fGeoMap    Autor  Eduardo Riera          Data 25.02.2004 
Ĵ
          Rotina de atualizacao do Geoprocessamento para rotinas das   
          cadastros                                                    
Ĵ
ParametrosExpC1: Alias da tabela                                       
          ExpC2: Chave de pesquisa                                     
          ExpA4: Array de endereco na seguinte estrutura:              
                 [1] Endereco                                          
                 [2] Cidade                                            
                 [3] Estado                                            
                 [4] Cep                                               
                 [5] Bairro                                            
Ĵ
Retorno   Nenhum                                                       
                                                                       
Ĵ
Descrio Esta rotina tem como objetivo geoprocessar um endereco e atu-
          alizar as rotinas de cadastro.                               
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function fGeoMap(cAlias,cChave,aEndereco,bCompare)
  
Local aCoor     := {}
Local aArray    := {}
Local aArrayScr := {}
Local aMap      := {}
Local aEnd      := {}
Local cLat      := ""
Local cLong     := "" 
Local lContinua := .T. 
     
//Ŀ
// Verifica a primeira condicao                                      
//
lCond1 := ( !GeoExtEnt(xFilial(cAlias),cAlias,cChave,aCoor) ) 

//Ŀ
// Se for .F., avalia a segunda condicao e a disponibilidade do servico ( lcontinua ) 
//
If !lCond1 
	lCond2 := Eval( bCompare, @lContinua )
EndIf 	

If lContinua 
	
	If lCond1 .Or. lCond2 
	
		aArray := CodGeoPrc(&(aEndereco[1]),&(aEndereco[2]),&(aEndereco[3]),&(aEndereco[4]))
	
		If Len(aArray) > 0
		
			aArrayScr := GeoPrcScr(aArray)
	
			If Len(aArrayScr) > 0
				cLat  := aArrayScr[1][6]
				cLong := aArrayScr[1][7]
	
				GeoSavCoor(xFilial(cAlias),cAlias,cChave,aArrayScr[1][6],aArrayScr[1][7],.T.)
	
				aEnd := FisGetEnd(&(aEndereco[1]))
				aEnd[1] := aArray[1][1]
				If SubStr( aEndereco[1], 1, 3 ) == "M->"
				
					//Ŀ
					// Atualiza os enderecos das variaveis de memoria ( tela )           
					// 
					&(aEndereco[1]) := PadR( aEnd[1]+", "+aEnd[3], Len( &(aEndereco[1]) ) )
					If Empty(&(aEndereco[2]))
						&(aEndereco[2]) := PadR( aArray[1][4], Len( &(aEndereco[2]) ) ) 
					EndIf
					If Len(aEndereco)>=5 .And. Empty(&(aEndereco[5]))
						&(aEndereco[5]) := PadR( aArray[1][2], Len( &(aEndereco[5]) ) )
					EndIf
					If Empty(&(aEndereco[4]))
						&(aEndereco[4]) := PadR( aArray[1][3], Len( &(aEndereco[4]) ) ) 
					EndIf                  
					
				Else
				
					//Ŀ
					// Atualiza o enderecos na base de dados                             
					// 
					If RecLock( cAlias, .F. )
						&(aEndereco[1]) := aEnd[1]+", "+aEnd[3]
						If Empty(&(aEndereco[2]))
							&(aEndereco[2]) := aArray[1][4]
						EndIf
						If Len(aEndereco)>=5 .And. Empty(&(aEndereco[5]))
							&(aEndereco[5]) := aArray[1][2]
						EndIf
						If Empty(&(aEndereco[4]))
							&(aEndereco[4]) := aArray[1][3]
						EndIf
						
						MsUnlock()
					EndIf
				EndIf
	
				Aadd(aMap,{aArrayScr[1][6],aArrayScr[1][7],""})
				GeoMap(aMap)
			Endif	
		Endif
	Else 
	
		Aadd(aMap,{aCoor[1],aCoor[2],""})
	
		GeoMap(aMap)
	
	Endif
	
EndIf 	
	
Return
/*/

Ŀ
Funo    fGeoTrajet Autor  Eduardo Riera          Data 25.02.2004 
Ĵ
          Rotina de visualizacao do trajeto a ser percorrido           
                                                                       
Ĵ
ParametrosExpC1: Alias da tabela                                       
          ExpC2: Chave de pesquisa                                     
          ExpA4: Array de endereco na seguinte estrutura:              
                 [1] Endereco                                          
                 [2] Cidade                                            
                 [3] Estado                                            
                 [4] Cep                                               
                 [5] Bairro                                            
Ĵ
Retorno   Nenhum                                                       
                                                                       
Ĵ
Descrio Esta rotina demostrar um trajeto a ser percorrido            
                                                                       
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function fGeoTrajeto(cAlias,cChave,aEndereco,bCompare)

Local aCoor     := {}
Local aArray    := {}
Local aArrayScr := {}
Local aMap      := {}

Local lContinua := .T. 
     
//Ŀ
// Verifica a primeira condicao                                      
//
lCond1 := ( !GeoExtEnt(xFilial(cAlias),cAlias,cChave,aCoor) ) 

//Ŀ
// Se for .F., avalia a segunda condicao e a disponibilidade do servico ( lcontinua ) 
//
If !lCond1 
	lCond2 := Eval( bCompare, @lContinua )
EndIf 	

If lContinua                  
	
	If lCond1 .Or. lCond2 
	
		aArray := CodGeoPrc(&(aEndereco[1]),&(aEndereco[2]),&(aEndereco[3]),&(aEndereco[4]) )
	
		If Len(aArray) > 0
		
			aArrayScr := GeoPrcScr(aArray)
			
			If Len(aArrayScr) > 0	  
				if Len(aCoor) = 0//Inclui coordenadas se no houver nenhuma cadastrada
					Aadd(aCoor,aArrayScr[1][6])
					Aadd(aCoor,aArrayScr[1][7])                                                
				Else
					aCoor[1] := aArrayScr[1][6]
					aCoor[2] := aArrayScr[1][7]  
				Endif
	
				GeoSavCoor(xFilial(cAlias),cAlias,cChave,aArrayScr[1][6],aArrayScr[1][7],.T.)
			Endif	
			
		Endif
	Else 
		Aadd(aMap,{aCoor[1],aCoor[2],""})
	EndIf
	
	If GeoExtEnt(xFilial(cAlias),cAlias,cChave,aCoor)
		GeoPersonal(aCoor[1],aCoor[2],{&(aEndereco[1]),&(aEndereco[2]),&(aEndereco[3]),&(aEndereco[4])})
	Endif	
	
EndIf 	
	
Return

/*/

Ŀ
Funo    fGeoWizard Autor  Eduardo Riera          Data 26.03.2004 
Ĵ
          Rotina de Interface para a Webraska                          
                                                                       
Ĵ
ParametrosExpC1: Alias da tabela                                       
          ExpC2: Chave de pesquisa                                     
          ExpA4: Array de endereco na seguinte estrutura:              
                 [1] Endereco                                          
                 [2] Cidade                                            
                 [3] Estado                                            
                 [4] Cep                                               
                 [5] Bairro                                            
Ĵ
Retorno   Nenhum                                                       
                                                                       
Ĵ
Descrio Esta rotina demostrar as interfaces com a Webraska           
                                                                       
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function fGeoWizard(cAlias,cChave,aEndereco,bCompare)

Local aArray    := {}
Local aArrayScr := {}
Local aEnd      := {}
Local aRadio    := {STR0048,STR0049,STR0050}
Local aCodCli   := {}
Local aCodVen   := {}
Local aCoor     := {}
Local aNaoRot   := {}
Local aDestinos := {}
Local cLat      := ""
Local cLong     := ""
Local nRadio    := 0
Local nOpcA     := 0
Local cQuery    := ""
Local cArquivo  := ""
Local cCursor   := ""
Local oWizard
Local oBmp
Local oRadio

//Ŀ
// Realiza o HandShake para Parceiro nao cadastrado no Ecossistema   
//

EcoHandShake("MICROSIGA","SHOWECO")                               

//Ŀ
// Verifica o alias que foi chamado                                  
//
Do Case
	Case cAlias == "SA3"
		aadd(aRadio,STR0052+" - "+RetTitle("C5_CLIENTE"))//"Onde est?" 
		aadd(aRadio,STR0052+" - "+RetTitle("AD1_PROSPE"))//"Onde est?"
	Case cAlias == "SA1"
		aadd(aRadio,STR0044+" - "+RetTitle("A1_VEND"))
		aadd(aRadio,"Ranking"+" - "+RetTitle("A1_VEND"))
	Case cAlias == "AA1"
		aadd(aRadio,"Ranking"+" - "+RetTitle("AB9_CODTEC"))
EndCase

//Ŀ
// Montagem da interface                                             
//
DEFINE WIZARD oWizard ;
	TITLE STR0046 ;
	HEADER "Webraska" ;
	MESSAGE STR0047 ;
	TEXT STR0054 + STR0055 + STR0056 + STR0057 ;
	NEXT {|| .T.} ;
	FINISH {|| .T.} PANEL
		
CREATE PANEL oWizard ;
	HEADER STR0043 ;
	MESSAGE "" ; 
	BACK {|| .T. } ;
	FINISH {|| nOpcA := 1,.T. } PANEL

oRadio := TRadMenu():New(__DlgHeight(oWizard:GetPanel(2))/4,(__DlgWidth(oWizard:GetPanel(2))/2),aRadio,;
     bSETGET(nRadio),oWizard:GetPanel(2),/*[{<nHelpId>}]*/,/*<{uChange}>*/,/*<nClrFore>*/,/*<nClrBack>*/,/*<cMsg>*/,/*<.update.>*/,/*<{uWhen}>*/,;
     100,015,/*<{uValid}>*/,/*<.lDesign.>*/,/*<.lLook3d.>*/,.T. ) //"Geocodificar"###"Veja a regio"###"Trace uma rota"

@ __DlgHeight(oWizard:GetPanel(2))/3,005 BITMAP oBmp RESNAME "Webraska" OF oWizard:GetPanel(2) SIZE 135,045 PIXEL NOBORDER

ACTIVATE WIZARD oWizard CENTERED
//Ŀ
// Verifica a opcao selecionada                                      
// 

If nOpcA == 1

	Do Case
		Case nRadio == 1
			aArray := CodGeoPrc(&(aEndereco[1]),&(aEndereco[2]),&(aEndereco[3]),&(aEndereco[4]))
			If Len(aArray) > 0
				aArrayScr := GeoPrcScr(aArray)
				If Len(aArrayScr) > 0
					cLat  := aArrayScr[1][6]
					cLong := aArrayScr[1][7]
					GeoSavCoor(xFilial(cAlias),cAlias,cChave,aArrayScr[1][6],aArrayScr[1][7],.T.)
					aEnd := FisGetEnd(&(aEndereco[1]))
					aEnd[1] := aArray[1][1]

					If SubStr( aEndereco[1], 1, 3 ) == "M->" 
					
						//Ŀ
						// Atualiza os enderecos das variaveis de memoria ( tela )           
						// 
						&(aEndereco[1]) := PadR( aEnd[1]+", "+aEnd[3], Len( &(aEndereco[1]) ) )
						If Empty(&(aEndereco[2]))
							&(aEndereco[2]) := PadR( aArray[1][4], Len( &(aEndereco[2]) ) ) 
						EndIf
						If Len(aEndereco)>=5 .And. Empty(&(aEndereco[5]))
							&(aEndereco[5]) := PadR( aArray[1][2], Len( &(aEndereco[5]) ) )
						EndIf
						If Empty(&(aEndereco[4]))
							&(aEndereco[4]) := PadR( aArray[1][3], Len( &(aEndereco[4]) ) ) 
						EndIf                  
						
					Else     
						
						If RecLock( cAlias, .F. )

							&(aEndereco[1]) := aEnd[1]+", "+aEnd[3]
							If Empty(&(aEndereco[2]))
								&(aEndereco[2]) := aArray[1][4]
							EndIf
							If Len(aEndereco)>=5 .And. Empty(&(aEndereco[5]))
								&(aEndereco[5]) := aArray[1][2]
							EndIf
							If Empty(&(aEndereco[4]))
								&(aEndereco[4]) := aArray[1][3]
							EndIf

							MsUnlock()
						EndIf
					EndIf
				EndIf
			EndIf
		Case nRadio == 2
			fGeoMap(cAlias,cChave,aEndereco,bCompare)
		Case nRadio == 3
			fGeoTrajeto(cAlias,cChave,aEndereco,bCompare)
		Case nRadio == 4 .And. cAlias == "SA3"
			cCursor := "SA1"
			#IFDEF TOP
			    cCursor := GetNextAlias()
			    cQuery  := "SELECT A1_FILIAL,A1_COD,A1_LOJA "
			    cQuery  += "FROM "+RetSqlName("SA1")+" SA1 "
			    cQuery  += "WHERE SA1.A1_FILIAL='"+xFilial("SA1")+"' AND "
			    cQuery  += "SA1.A1_VEND = '"+SA3->A3_COD+"' AND "
			    cQuery  += "SA1.D_E_L_E_T_= ' ' "
			    cQuery  += "ORDER BY "+SqlOrder("A1_FILIAL+A1_VEND")
			    
			    cQuery := ChangeQuery(cQuery)
			    
			    dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor)
			    
			#ELSE
				dbSelectArea(cCursor)
				cArquivo := CriaTrab(,.F.)
				cQuery   := "A1_FILIAL=='"+xFilial("SA1")+"' .AND. A1_VEND == '"+SA3->A3_COD+"' "
				IndRegua(cCursor,cArquivo,"A1_FILIAL+A1_VEND",,cQuery)
				dbGotop()
			#ENDIF
			While !Eof()
				
				aadd(aCodCli,{(cCursor)->A1_COD,(cCursor)->A1_LOJA})
				
				dbSelectArea(cCursor)
				dbSkip()
			EndDo
			#IFDEF TOP
				dbSelectArea(cCursor)
				dbCloseArea()
			#ELSE
				RetIndex(cCursor)
				FErase(cArquivo+OrdBagExt())
			#ENDIF
			dbSelectArea("SA1")
			fGeoMapCli(aCodCli)
			
		Case nRadio == 5 .And. cAlias == "SA3"
			cCursor := "SUS"
			#IFDEF TOP
			    cCursor := GetNextAlias()
			    cQuery  := "SELECT US_FILIAL,US_COD,US_LOJA "
			    cQuery  += "FROM "+RetSqlName("SUS")+" SUS "
			    cQuery  += "WHERE SUS.US_FILIAL='"+xFilial("SUS")+"' AND "
			    cQuery  += "SUS.US_VEND = '"+SA3->A3_COD+"' AND "
			    cQuery  += "SUS.D_E_L_E_T_= ' ' "
			    cQuery  += "ORDER BY "+SqlOrder("US_FILIAL+US_VEND")
			    
			    cQuery := ChangeQuery(cQuery)
			    
			    dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor)
			    
			#ELSE
				dbSelectArea(cCursor)
				cArquivo := CriaTrab(,.F.)
				cQuery   := "US_FILIAL=='"+xFilial("SUS")+"' .AND. US_VEND == '"+SA3->A3_COD+"' "
				IndRegua(cCursor,cArquivo,"US_FILIAL+US_VEND",,cQuery)
				dbGotop()
			#ENDIF
			While !Eof()
				
				aadd(aCodCli,{(cCursor)->US_COD,(cCursor)->US_LOJA})
				
				dbSelectArea(cCursor)
				dbSkip()
			EndDo
			#IFDEF TOP
				dbSelectArea(cCursor)
				dbCloseArea()
			#ELSE
				RetIndex(cCursor)
				FErase(cArquivo+OrdBagExt())
			#ENDIF
			dbSelectArea("SUS")
			fGeoMapCli(aCodCli,"P")
			
		Case cAlias == "SA1"
			dbSelectArea("SA3")
			dbSetOrder(1)
			MsSeek(xFilial("SA3"))
			While !Eof() .And. xFilial("SA3") == SA3->A3_FILIAL
				aadd(aCodVen,SA3->A3_COD)
				dbSelectArea("SA3")
				dbSkip()			
			EndDo
			dbSelectArea("SA3")
			If nRadio == 4
				fGeoVend(aCodVen,{SA1->A1_COD,SA1->A1_LOJA},1)
			ElseIf nRadio == 5
				fGeoVend(aCodVen,{SA1->A1_COD,SA1->A1_LOJA},2)			
			EndIf
	EndCase
		
EndIf
Return(.T.)

/*/

Ŀ
Funo    fGeoMapCli Autor  Eduardo Riera          Data 26.02.2004 
Ĵ
          Rotina plotagem no mapa de clientes para analise             
                                                                       
Ĵ
ParametrosExpA1: Array com os cdigos de clients                       
                                                                       
Ĵ
Retorno   Nenhum                                                       
                                                                       
Ĵ
Descrio Esta rotina tem como objetivo demonstrar no mapa, a posicao  
          geografica dos clientes.                                     
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function fGeoMapCli(aCodCli,cTipo)

Local aArea      := GetArea()
Local aHeadNao   := {} 
Local aNavID     := {}
Local aCoor      := {}
Local aNaoRot    := {}

Local cMessCod   := ""

Local lContinua  := .T.   

Local nX         := 0

DEFAULT cTipo    := "C"

For nX := 1 To Len(aCodCli)

	If cTipo == "C"

		dbSelectArea("SA1")
		dbSetOrder(1)
		If MsSeek(xFilial("SA1")+aCodCli[nX][1]+aCodCli[nX][2])
		
			cMessCod := STR0071 // "Relaao de clientes sem geocodificao"
		
			aCoor := {}
			If !GeoExtEnt(xFilial("SA1"),"SA1",aCodCli[nX][1]+aCodCli[nX][2],@aCoor)
				If Empty(aNaoRot)
					aHeadNao := {RetTitle("A1_COD"),RetTitle("A1_LOJA"),RetTitle("A1_NOME")} 
				EndIf
				AADD(aNaoRot,{SA1->A1_COD,SA1->A1_LOJA,SA1->A1_NOME})
			Else
				aadd(aNavId,{aCoor[1],aCoor[2],"",SA1->A1_NREDUZ, "SA1", SA1->A1_COD + SA1->A1_LOJA })
			EndIf
		EndIf          
		
	ElseIf cTipo == "P" 
	
		SUS->( dbSetOrder( 1 ) ) 	
	
		If SUS->( MsSeek(xFilial("SUS")+aCodCli[nX][1]+aCodCli[nX][2]) )    
		
			cMessCod := STR0072 // "Relaao de prospects sem geocodificao"
		
			aCoor := {}
			If !GeoExtEnt(xFilial("SUS"),"SUS",aCodCli[nX][1]+aCodCli[nX][2],@aCoor)
				If Empty(aNaoRot)
					aHeadNao := {RetTitle("US_COD"),RetTitle("US_LOJA"),RetTitle("US_NOME")} 
				EndIf
				AADD(aNaoRot,{SUS->US_COD,SUS->US_LOJA,SUS->US_NOME})
			Else
				aadd(aNavId,{aCoor[1],aCoor[2],"",If( Empty( SUS->US_NREDUZ ), SUS->US_NOME, SUS->US_NREDUZ ),"SUS", SUS->US_COD + SUS->US_LOJA })
			EndIf
		EndIf          

	ElseIf cTipo == "S" 
	
		ACH->( dbSetOrder( 1 ) ) 	
	
		If ACH->( MsSeek(xFilial("ACH")+aCodCli[nX][1]+aCodCli[nX][2]) ) 
			aCoor := {}                                           
			
			cMessCod := STR0073 //"Relaao de suspects sem geocodificao"
			
			If !GeoExtEnt(xFilial("ACH"),"ACH",aCodCli[nX][1]+aCodCli[nX][2],@aCoor)
				If Empty(aNaoRot)
					aHeadNao := {RetTitle("ACH_CODIGO"),RetTitle("ACH_LOJA"),RetTitle("ACH_RAZAO")} 
				EndIf
				AADD(aNaoRot,{ACH->ACH_CODIGO,ACH->ACH_LOJA,ACH->ACH_RAZAO})
			Else
				aadd(aNavId,{aCoor[1],aCoor[2],"",ACH->ACH_NFANT, "ACH", ACH->ACH_CODIGO + ACH->ACH_LOJA })
			EndIf
		EndIf          
		
	EndIf 		
		
Next nX

If !Empty(aNaoRot)
	lContinua := GeoDispBox(aHeadNao,aNaoRot,cMessCod) //"Relaao de clientes sem geocodificao"
EndIf
     
If lContinua 
	If !Empty(aNavId)
		//Ŀ
		// Exibe os pontos de interesse                                      
		//
		FGeoPlot( aNavID ) 
	Else
		Help(" ",1,"OMSGEOMAP")
	EndIf
EndIf 	
RestArea(aArea)
Return(.T.)


/*/

Ŀ
Funo    fGeoVend   Autor  Eduardo Riera          Data 01.04.2004 
Ĵ
          Rotina de geoprocessmanto para representantes comerciais     
                                                                       
Ĵ
ParametrosExpA1: Array com os cdigos de vendedores                    
          ExpA2: Codigo do cliente                                     
          ExpN3: Tipo de consulta                                      
                 [1] Mapa                                              
                 [2] Ranking                                           
Ĵ
Retorno   Nenhum                                                       
                                                                       
Ĵ
Descrio Esta rotina tem como objetivo demonstrar no mapa, a posicao  
          geografica dos clientes.                                     
Ĵ
Uso        Generico                                                    
ٱ


/*/
Static Function fGeoVend(aCodVen,aCodCli,nTipo)

Local aArea      := GetArea()

Local aNavID     := {}
Local aCoor      := {}

Local aNaoRot    := {}
Local aOrigem    := {}
Local aDestinos  := {}

Local lContinua  := .T. 

Local nX         := 0     


dbSelectArea("SA1")
dbSetOrder(1)
MsSeek(xFilial("SA1")+aCodCli[1]+aCodCli[2])
If GeoExtEnt(xFilial("SA1"),"SA1",aCodCli[1]+aCodCli[2],@aCoor)
	
	aOrigem := {{SA1->A1_COD+"/"+SA1->A1_LOJA,SA1->A1_NOME,SA1->A1_END,SA1->A1_BAIRRO,SA1->A1_MUN},{aCoor[1],aCoor[2]}}
	aadd(aNavID,{aCoor[1],aCoor[2],"star.gif", SA1->A1_NREDUZ, "SA1", SA1->A1_COD + SA1->A1_LOJA })

	//Ŀ
	// Percorre os vendedores                                            
	//
	For nX := 1 To Len(aCodVen)
		dbSelectArea("SA3")
		dbSetOrder(1)
		If MsSeek(xFilial("SA3")+aCodVen[nX])
			aCoor := {}
			
			//Ŀ
			// Verifica os vendedores ja geocodificados                          
			//
   		If GeoExtEnt(xFilial("SA3"),"SA3",aCodVen[nX],@aCoor)
				aadd(aNavId,{aCoor[1],aCoor[2],"", If( Empty( SA3->A3_NREDUZ ),SA3->A3_NOME,SA3->A3_NREDUZ ), "SA3",SA3->A3_COD })
				aadd(aDestinos,{{SA3->A3_COD,SA3->A3_NOME,SA3->A3_END,SA3->A3_BAIRRO,SA3->A3_MUN},{aCoor[1],aCoor[2]}})
			Else    		
   			If Empty(aNaoRot)
   				aHeadNao := {RetTitle("A3_COD"),RetTitle("A3_NOME")}
   			EndIf
				AADD(aNaoRot,{SA3->A3_COD,SA3->A3_NOME})
	   	EndIf
		EndIf			
	Next nX
	
	If !Empty(aNaoRot)
		lContinua := GeoDispBox(aHeadNao,aNaoRot,"Relaao de vendedores sem geocodificao") //"Relaao de vendedores sem geocodificao"
	EndIf
	
	If lContinua 
	
		If nTipo == 1
		
			If !Empty(aNavId)    
				//Ŀ
				// Exibe os pontos de interesse                                      
				//
				fGeoPlot( aNavID ) 
			Else
				Help(" ",1,"OMSGEOMAP")
			EndIf
		Else
			If !Empty(aDestinos)
				fGeoRank(aOrigem,aDestinos)
			Else
				Help(" ",1,"OMSGEOMAP")
			EndIf		
		EndIf
		
	EndIf 		
		
EndIf
RestArea(aArea)
Return(.T.)

/*/

Ŀ
Funo    fGeoRank   Autor  Eduardo Riera          Data 30.03.2004 
Ĵ
          Interface para demonstracao do ranking                       
                                                                       
Ĵ
ParametrosExpA1: Array de origem                                       
                 [1,1] Codigo                                          
                 [1,2] Nome                                            
                 [1,3] Endereco                                        
                 [1,4] Bairro                                          
                 [1,5] Cidade                                          
                 [2,1] Latitude                                        
                 [2,2] Longitude                                       
          ExpA2: Array com os destinos                                 
                 [n,1] Codigo                                          
                 [n,2] Nome                                            
                 [n,3] Endereco                                        
                 [n,4] Bairro                                          
                 [n,5] Cidade                                          
                 [n,2,1] Latitude                                      
                 [n,2,2] Longitude                                     
Ĵ
Retorno   Nenhum                                                       
                                                                       
Ĵ
Descrio Esta rotina tem como objetivo demonstrar o ranking das posi- 
          coes informadas.                                             
Ĵ
Uso        Generico                                                    
ٱ


/*/
Static Function fGeoRank(aOrigem,aDestinos)

Local aRanking := {}
Local aCoord1  := {}
Local aCoord2  := {}
Local aSize    := {}
Local aObjects := {}
Local aPosObj  := {}
Local aCols    := {}
Local aHeader  := {}
Local nX       := 0
Local nY       := 0
Local oDlg
Local oGetdad

aCoord1 := aOrigem[2]

For nX := 1 To Len(aDestinos)
	aadd(aCoord2,aDestinos[nX][2])
Next nX

aRanking := GeoRanking(aCoord1,aCoord2,1,.T.)

aadd(aHeader,{""                   ,"COL1",	"@!",03,0,".T.","","C","","V" } )
aadd(aHeader,{RetTitle("A1_COD")   ,"COL2",	"@!",TamSX3("A1_COD")[1]   ,TamSX3("A1_COD")[2]   ,".T.","","C","","V" } )
aadd(aHeader,{RetTitle("A1_NOME")  ,"COL3",	"@!",TamSX3("A1_NOME")[1]  ,TamSX3("A1_NOME")[2]  ,".T.","","C","","V" } )
aadd(aHeader,{RetTitle("A1_END")   ,"COL4",	"@!",TamSX3("A1_END")[1]   ,TamSX3("A1_END")[2]   ,".T.","","C","","V" } )
aadd(aHeader,{RetTitle("A1_BAIRRO"),"COL5",	"@!",TamSX3("A1_BAIRRO")[1],TamSX3("A1_BAIRRO")[2],".T.","","C","","V" } )
aadd(aHeader,{RetTitle("A1_MUN")   ,"COL6",	"@!",TamSX3("A1_MUN")[1]   ,TamSX3("A1_MUN")[2]   ,".T.","","C","","V" } )

For nX := 1 To Len(aRanking)
	nY := aScan(aDestinos,{|x| AllTrim(x[2][1]) == AllTrim(aRanking[nX][1]) .And. AllTrim(x[2][2]) == AllTrim(aRanking[nX][2])})
	If nY <> 0
		aadd(aCols,{StrZero(nX,3),aDestinos[nY][1][1],aDestinos[nY][1][2],aDestinos[nY][1][3],aDestinos[nY][1][4],aDestinos[nY][1][5],.F.})
	EndIf
Next nX

aSize    := MsAdvSize(.F.)
aSize [ 3 ] -= 25
aSize [ 4 ] -= 25	
aSize [ 5 ] -= 50
aSize [ 6 ] -= 50
aadd(aObjects,{010,015,.T.,.F.,.T.})
aadd(aObjects,{100,100,.T.,.T.})
aadd(aObjects,{010,015,.T.,.F.})
aPosObj := MsObjSize({aSize[1],aSize[2],aSize[3],aSize[4],3,3},aObjects)
DEFINE MSDIALOG oDlg TITLE "Ranking" FROM aSize[7],000 TO aSize[6],aSize[5] OF oMainWnd PIXEL
@ aPosObj[1][1],aPosObj[1][2] SAY AllTrim(RetTitle("A1_COD"))+": "+aOrigem[1][1]+" "+AllTrim(RetTitle("A1_NOME"))+": "+aOrigem[1][2]+AllTrim(RetTitle("A1_END"))+": "+aOrigem[1][3]+AllTrim(RetTitle("A1_BAIRRO"))+": "+aOrigem[1][4]+AllTrim(RetTitle("A1_MUN"))+": "+aOrigem[1][5] PIXEL
oGetDad  := MsNewGetDados():New(aPosObj[2][1],aPosObj[2][2],aPosObj[2][3],aPosObj[2][4],0,"","",/*inicpos*/,/*aCpoHead*/,/*freeze*/,Nil,/*fieldok*/,/*superdel*/,/*delok*/,oDlg,aHeader,aCols)
@ aPosObj[3,1]+3,__dlgWidth(oDlg)-048 BUTTON STR0045   SIZE 040,010 ACTION oDlg:End() OF oDlg PIXEL //"Sair"
ACTIVATE DIALOG oDlg CENTERED

Return(.T.)   


/*


Ŀ
Funcao    GeoDispBox Autor Sergio Silveira         Data 27.08.2005
Ĵ
Descrio Exibe lista generica                                        
Ĵ
Retorno   ExpL1 -> Indica se confirmou a janela                       
Ĵ
Parametros                                                            
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function GeoDispBox(aHead,aLista,cCaption,nChosen)

Local aListBox    := {}

Local cResultado  := "" 
Local cLine       := ""

Local lRet        := .F.  

Local nLoop := 0 

Local oDlg
Local oBrowse
Local oBut1
Local oBut2
Local oBold               

If ValType( aLista[1] ) == "A"                          
	AEval( aLista, { |x,y| aLista[y,2] := Capital( x[2] ) } ) 	           
EndIf 	

//Ŀ
// Constroi dinamicamente o code-block                               
//
cLine := "{ || { " 

For nLoop := 1 to Len(aHead )
	cLine += "aLista[oBrowse:nAT," + AllTrim( Str( nLoop ) ) +  "]," 
Next nLoop 
                                                                     
cLine := Left( cLine, Len( cLine ) - 1 ) 

cLine += " } }"

DEFINE MSDIALOG oDlg TITLE cCaption FROM 0,0 TO 264,478 OF oMainWnd	PIXEL

DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD

@  0, -25 BITMAP oBmp RESNAME "PROJETOAP" oF oDlg SIZE 55, 1000 NOBORDER WHEN .F. PIXEL

@ 03, 40 SAY cCaption FONT oBold PIXEL 

@ 14, 30 TO 16 ,400 LABEL '' OF oDlg PIXEL

oBrowse := TWBrowse():New( 26, 38,194, 80,,aHead,,oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,)  

oBrowse:SetArray(aLista)
oBrowse:bLine := &cLine 

DEFINE SBUTTON oBut1 FROM 113, 169 TYPE 1 ACTION ( lRet := .T., nChosen := oBrowse:nAt,oDlg:End() )  ENABLE of oDlg
DEFINE SBUTTON oBut2 FROM 113, 202 TYPE 2 ACTION ( lRet := .F., nChosen := oBrowse:nAt,oDlg:End() )  ENABLE of oDlg

ACTIVATE MSDIALOG oDlg CENTERED

Return( lRet ) 

/*


Ŀ
Funcao    fGeoMove   Autor Sergio Silveira         Data 18/08/2005
Ĵ
Descrio Efetua movimentacao / Zoom baseado em duas coordenadas      
Ĵ
Sintaxe   fGeoMove( @ExpC1, @ExpC2, @ExpC3, @ExpC4, ExpC5 )           
Ĵ
Retorno   .T.                                                         
Ĵ
Parametros ExpC1 -> Latitude 1                                        
           ExpC2 -> Longitude 1                                       
           ExpC3 -> Latitude 2                                        
           ExpC4 -> Longitude 2                                       
           ExpC5 -> Operacao                                          
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function fGeoMove( cLat1, cLong1, cLat2, cLong2, cOper ) 

Local nDeltaLat  := 0
Local nDeltaLong := 0
Local nLat1       := Val( cLat1 ) 
Local nLat2       := Val( cLat2 ) 
Local nLong1      := Val( cLong1 ) 
Local nLong2      := Val( cLong2 )   
Local nFactor     := 0.5
Local nHeight     := 480
Local nWidth      := 640 
Local nLatCenter  := 0
Local nLongCenter := 0
Local nNewLat1    := 0
Local nNewLat2    := 0
Local nNewLong1   := 0 
Local nNewLong2   := 0

DEFAULT cOper := "C_ZOOMIN"

nDeltaLat   := abs(nLat1  - nLat2)
nDeltaLong  := abs(nLong1 - nLong2)       

Do Case 

Case cOper == "C_ZOOMIN" .Or. cOper == "C_ZOOMOUT" 

	If cOper == "C_ZOOMOUT" 
		nFactor := 2
	EndIf 	
	
	nLatCenter  := nLat2  - (nheight/2)*(nDeltaLat/nheight)
	nLongCenter := nLong1 + (nwidth/2)*(nDeltaLong/nwidth)
	
	nNewLat1    := nLatCenter - (nDeltaLat/2)*nFactor
	nNewLat2    := nLatCenter + (nDeltaLat/2)*nFactor            
	
	nNewLong1   := nLongCenter - (nDeltaLong/2)*nFactor
	nNewLong2   := nLongCenter + (nDeltaLong/2)*nFactor    

Case cOper == "PAN_NORTH" 
 
	nNewLat1  := nLat1 + ndeltaLat/2
	nNewLat2  := nLat2 + nDeltaLat/2
	nNewLong1 := nLong1
	nNewLong2 := nLong2

Case cOper == "PAN_SOUTH" 
 
	nNewLat1  := nLat1 - ndeltaLat/2
	nNewLat2  := nLat2 - nDeltaLat/2
	nNewLong1 := nLong1
	nNewLong2 := nLong2
	
Case cOper == "PAN_EAST" 
 
	nNewLat1  := nLat1 
	nNewLat2  := nLat2 
	nNewLong1 := nLong1 + ndeltaLat/2
	nNewLong2 := nLong2 + nDeltaLat/2

Case cOper == "PAN_WEST" 
 
	nNewLat1  := nLat1 
	nNewLat2  := nLat2 
	nNewLong1 := nLong1 - ndeltaLat/2
	nNewLong2 := nLong2 - nDeltaLat/2
	
EndCase 

cLat1  := AllTrim( Str( nNewLat1  ) ) 
cLong1 := AllTrim( Str( nNewLong1 ) ) 
cLat2  := AllTrim( Str( nNewLat2  ) ) 
cLong2 := AllTrim( Str( nNewLong2 ) ) 

Return( .T. )

/*


Ŀ
Funcao    fGeoMapText Autor Sergio Silveira        Data 29/08/2005
Ĵ
Descrio Atualizacao dos textos dos placemarks em um bitmap          
Ĵ
Sintaxe   fGeoMapText( ExpC1, ExpC2, ExpC3, ExpC4, ExpA5, ExpN6, ExpN7
           , ExpA8, ExpO9 )                                           
Ĵ
Retorno   .T.                                                         
Ĵ
Parametros ExpC1 -> Latitude canto superior                           
           ExpC2 -> Longitude canto superior                          
           ExpC3 -> Latitude canto inferior                           
           ExpC4 -> Longitude canto inferior                          
           ExpA5 -> Array com os pontos de interesse                  
           ExpN6 -> Tamanho do bitmap eixo X                          
           ExpN7 -> Tamanho do bitmap eixo Y                          
           ExpA8 -> Array contendo os objetos de texto                
           ExpO9 -> Objeto bitmap                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function fGeoMapText( cLat1, cLong1, cLat2, cLong2, aCdMap, nResX, nResY, aSay, oBitMap ) 

Local aCoors    :={} 
Local cLatMark  := ""
Local cLongMark := ""

Local nLoop     := 1 

For nLoop := 1 to Len( aCdMap ) 

	cLatMark  := aCdMap[nLoop,1]
	cLongMark := aCdMap[nLoop,2]
	
	//Ŀ
	// Efetua a interpolacao das coordenadas                             
	//
	aCoors := fGeoInterp( cLat1, cLong1, cLat2, cLong2, cLatMark, cLongMark, nResX, nResY ) 
	
	aCoors[1] += 12 
	
	//Ŀ
	// Atualiza os objetos de texto                                      
	//
	aSay[ nLoop ]:SetText( aCdMap[ nLoop, 4 ] )
	aSay[ nLoop ]:nTop  := aCoors[2]  
	aSay[ nLoop ]:nLeft := aCoors[1]

Next nLoop	
                                            
Return( .T. ) 

/*


Ŀ
Funcao    fGeoInterp Autor Sergio Silveira         Data 29/08/2005
Ĵ
Descrio Interpolacao das coordenadas de latitude / longitude        
          com coordenadas de tela ( bitmap )                          
Ĵ
Sintaxe   ExpA1:=fGeoInterp(ExpC1,ExpC2,ExpC3,ExpC4,ExpC5,ExpC6,ExpN7,
          ExpN8)                                                      
Ĵ
Retorno   ExpA1 -> Array de coordenadas. 1-Coord X, 2-Coord Y         
Ĵ
Parametros ExpC1 -> Latitude canto superior                           
           ExpC2 -> Longitude canto superior                          
           ExpC3 -> Latitude canto inferior                           
           ExpC4 -> Longitude canto inferior                          
           ExpC5 -> Latitude do placemark                             
           ExpC6 -> Longitude do placemark                            
           ExpN7 -> Tamanho do bitmap eixo X                          
           ExpN8 -> Tamanho do bitmap eixo Y                          
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function fGeoInterp( cLat1, cLong1, cLat2, cLong2, cLatMark, cLongMark, nResX, nResY ) 

Local nLat1     := Val( cLat1 ) 
Local nLong1    := Val( cLong1 ) 
Local nLat2     := Val( cLat2 ) 
Local nLong2    := Val( cLong2 )  
Local nLatMark  := Val( cLatMark )  
Local nLongMark := Val( cLongMark )
Local nFatorLat := 0 
Local nFatorLon := 0 
Local nCoordX   := 0 
Local nCoordY   := 0 

//Ŀ
// Calcula o fatores por pixel                                       
//

nFatorLat := nResY / ( nLat2 - nLat1 )    
nFatorLon := nResX / ( nLong2 - nLong1 )

//Ŀ
// Aplica os fatores                                                 
//

nCoordY   := nResY - ( nLatMark  - nLat1 ) * nFatorLat 
nCoordX   := ( nLongMark - nLong1 ) * nFatorLon  

Return( { nCoordX, nCoordY } )


/*


Ŀ
Funcao    fGeoPlot   Autor Sergio Silveira         Data 08/09/2005
Ĵ
Descrio Exibe um mapa com pontos de interesse ( placemarks )        
           a partir de um array de coordenadas                        
Ĵ
Sintaxe   fGeoPlot(ExpA1)                                             
Ĵ
Retorno   .T.                                                         
Ĵ
Parametros ExpA1 -> Array de pontos de interesse ( placemarks )       
               Dimensoes                                              
               1 -> Latitude                                          
               2 -> Longitude                                         
               3 -> Bitmap do placemark                               
               4 -> Descricao                                         
               5 -> Alias da entidade                                 
               6 -> Chave da entidade                                 
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function fGeoPlot( aNavID ) 

Local cLatStart  := ""
Local cLonStart  := ""
Local cLatEnd    := ""
Local cLonEnd    := ""

Local nLoop      := 0 
Local nMaiorLat  := 0 
Local nMaiorLon  := 0
Local nMenorLat  := 0
Local nMenorLon  := 0
Local nMargLat   := 0
Local nMargLon   := 0
Local nLat       := 0 
Local nLon       := 0            

If Len( aNavID ) == 1                           
	//Ŀ
	// Se houver apenas 1 cliente, chama a visualizacao central          
	//
	GeoMap(aNavID,/*nHeight*/,/*nWidth*/, 1000 )

Else

	//Ŀ
	// Se houver mais de 1 cliente, chama a visualizacao multiponto      
	//
	nMaiorLat := -1000000
	nMaiorLon := -1000000                

	nMenorLat := 1000000 
	nMenorLon := 1000000                
	
	//Ŀ
	// Obtem as maiores e menores latitudes / longitudes                 
	//
	For nLoop := 1 to Len( aNavID ) 
	
		nLat := Val( aNavID[ nLoop, 1 ] ) 
		nLon := Val( aNavID[ nLoop, 2 ] ) 
		
		If nLat > nMaiorLat
			nMaiorLat := nLat 
		EndIf 
		
		If nLon > nMaiorLon
			nMaiorLon := nLon 
		EndIf 

		If nLat < nMenorLat
			nMenorLat := nLat
		EndIf 
		
		If nLon < nMenorLon 
			nMenorLon := nLon
		EndIf 
		
	Next nLoop 		
	
	//Ŀ
	// Calcula uma margem de 10% nas laterais                            
	//
	nMargLat := ( nMaiorLat - nMenorLat ) / 10
	nMargLon := ( nMaiorLon - nMenorLon ) / 10		  
	
	nMenorLat -= nMargLat
	nMenorLon -= nMargLon
	
	nMaiorLat += nMargLat
	nMaiorLon += nMargLon
	
	cLatStart := AllTrim( Str( nMenorLat ) ) 
	cLonStart := AllTrim( Str( nMenorLon ) ) 		

	cLatEnd   := AllTrim( Str( nMaiorLat ) ) 
	cLonEnd   := AllTrim( Str( nMaiorLon ) ) 		
	
	GeoMapRoute(cLatStart,cLonStart,cLatEnd,cLonEnd,/*nHeight*/,/*nWidth*/,NIL,NIL,NIL,NIL,.T.,aNavID)

EndIf 	

Return( .T. )   


/*


Ŀ
Funcao    fGeoPontos Autor Sergio Silveira         Data 09/09/2005
Ĵ
Descrio Exibe uma lista com os pontos de interesse do mapa          
Ĵ
Sintaxe   fGeoPontos(@ExpC1,@ExpC2,@ExpC3,@ExpC4,ExpA5,ExpL6)         
Ĵ
Retorno   .T.                                                         
Ĵ
Parametros ExpC1 -> Latitude canto superior ( por referencia )        
           ExpC2 -> Longitude canto superior ( por referencia )       
           ExpC3 -> Latitude canto inferior ( por referencia )        
           ExpC4 -> Longitude canto inferior ( por referencia )       
           ExpA5 -> Array de pontos                                   
           ExpL6 -> Indica se as coordenadas foram alteradas          
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function fGeoPontos( cLat1, cLong1, cLat2, cLong2, aCdMap, lRedraw )  
 
Local aLista    := {} 
Local aHead     := {STR0075}  //"Descricao"
                 
Local cLatMark  := ""
Local cLongMark := ""
Local cCaption  := STR0076 // "Pontos do Mapa"

Local nPonto    := 1    

Local oDlg
Local oBrowse      
Local oBold 
Local oBmp1
Local oBmp2
Local oBut1

AEval( aCdMap, { |x,y| AAdd( aLista, { x[4], y } ) } ) 

//Ŀ
// Poe em ordem alfabetica                                           
//
ASort( aLista,,, { |x,y| y[1] > x[1] } ) 

DEFINE MSDIALOG oDlg TITLE cCaption FROM 0,0 TO 364,478 OF oMainWnd	PIXEL

DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD

@  0, -25 BITMAP oBmp1 RESNAME "PROJETOAP" oF oDlg SIZE 55, 1000 NOBORDER WHEN .F. PIXEL    

@ 03, 40 BITMAP oBmp2 RESNAME "PIN" oF oDlg SIZE 16, 16 NOBORDER WHEN .F. PIXEL
@ 03, 50 SAY cCaption FONT oBold PIXEL 

@ 14, 30 TO 16 ,400 LABEL '' OF oDlg PIXEL

oBrowse := TWBrowse():New( 26, 39,156, 148,,aHead,,oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,)  

oBrowse:SetArray(aLista)
oBrowse:bLine := { ||{aLista[oBrowse:nAT,1] } }

DEFINE SBUTTON oBut1 FROM 161, 204 TYPE 1 ACTION ( nPonto := oBrowse:nAt,oDlg:End() ) ENABLE of oDlg

@ 26, 204 BUTTON STR0077 SIZE 030,013 ACTION ( lRedraw := .T., nPonto := oBrowse:nAt,oDlg:End() ) OF oDlg PIXEL // "Vai para" 	

ACTIVATE MSDIALOG oDlg CENTERED

If lRedraw  

	nPonto := aLista[ nPonto, 2 ]  

	cLatMark  := aCdMap[ nPonto, 1 ] 
	cLongMark := aCdMap[ nPonto, 2 ] 	
	
	//Ŀ
	// Obtem um novo boundingBox a partir do ponto de interesse          
	//
	fGeoNewBox( @cLat1, @cLong1, @cLat2, @cLong2, cLatMark, cLongMark ) 
	
EndIf	

Return( .T. ) 


/*


Ŀ
Funcao    fGeoNewBox Autor Sergio Silveira         Data 09/09/2005
Ĵ
Descrio Calcula novas coordenadas de bounding box ( limites ) a     
           partir de um box existente e de um ponto ( placemark )       
           mantendo o placemark no centro do mapa                     
Ĵ
Sintaxe   fGeoNewBox(@ExpC1,@ExpC2,@ExpC3,@ExpC4,ExpC5,ExpC6)         
Ĵ
Retorno   .T.                                                         
Ĵ
Parametros ExpC1 -> Latitude canto superior ( por referencia )        
           ExpC2 -> Longitude canto superior ( por referencia )       
           ExpC3 -> Latitude canto inferior ( por referencia )        
           ExpC4 -> Longitude canto inferior ( por referencia )       
           ExpC5 -> Latitude do placemark                             
           ExpC6 -> Longitude do placemark                            
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function fGeoNewBox( cLat1, cLong1, cLat2, cLong2, cLatMark, cLongMark ) 

Local nLat1     := Val( cLat1 ) 
Local nLong1    := Val( cLong1 ) 
Local nLat2     := Val( cLat2 ) 
Local nLong2    := Val( cLong2 )  
Local nLatMark  := Val( cLatMark )  
Local nLongMark := Val( cLongMark )    
Local nTamLat   := ( nLat2 - nLat1 ) / 2 
Local nTamLong  := ( nLong2 - nLong1 ) / 2 

nLat1 := nLatMark - nTamLat
nLat2 := nLatMark + nTamLat

nLong1 := nLongMark - nTamLong
nLong2 := nLongMark + nTamLong

cLat1  := AllTrim( Str( nLat1  ) ) 
cLong1 := AllTrim( Str( nLong1 ) ) 
cLat2  := AllTrim( Str( nLat2  ) ) 
cLong2 := AllTrim( Str( nLong2 ) ) 

Return( .T. ) 
