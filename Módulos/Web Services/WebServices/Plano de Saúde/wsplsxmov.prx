#INCLUDE "APWEBSRV.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "fwlibversion.ch" 

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³PLSXMOV   ³ Autor ³Alexander Santos       ³ Data ³07.03.2006  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Web Service das funcionalidades do Plano de Saude            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas  cabecalho..
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

WSSTRUCT AutHeaderView
	WSDATA GuiPri		 			AS String OPTIONAL 				//Guia Principal
	WSDATA ReleaseNumber			AS String OPTIONAL 				//Numero de Liberacao
	WSDATA NumPeg				   	AS String OPTIONAL				//Numero da Guia Chave do BD6
	WSDATA ProcedureDate			AS Date 						//Data do Procedimento
	WSDATA RegistrationNumber		AS String 						//Matricula
	WSDATA SpecialityCode			AS String OPTIONAL 				//Codigo da Especialidade
	WSDATA Cbo						AS String OPTIONAL 				//Codigo da CBO
	WSDATA CidPri					AS String OPTIONAL 				//CID Principal
	WSDATA Cid2						AS String OPTIONAL 				//CID 2
	WSDATA Cid3						AS String OPTIONAL 				//CID 3
	WSDATA Cid4						AS String OPTIONAL 				//CID 4
	WSDATA Cid5						AS String OPTIONAL 				//CID 5
	WSDATA FormNumber				AS String OPTIONAL 				//Numero Impresso
	WSDATA Message1					AS String OPTIONAL 				//Mensagem 1
	WSDATA Message2					AS String OPTIONAL 				//Mensagem 2
	WSDATA Message3					AS String OPTIONAL 				//Mensagem 3
	WSDATA OperCompAutNumber		AS String OPTIONAL 				//Numero Autorizacao Operadora
	WSDATA CompAutNumber			AS String OPTIONAL 				//Numero Autorizacao Empresa
	WSDATA Protoc					AS String OPTIONAL 				//Numero do Protocolo de Atendimento
	WSDATA GuiPre		 			AS String OPTIONAL 				//Numero Guia Prestador via Guia de Consulta do Portal
	WSDATA TokEdi					AS String OPTIONAL 				//Token PTU Online
	WSDATA CobEspNwS				AS String OPTIONAL				//Cobertura Especial r7
	WSDATA RegAtdNwS				AS String OPTIONAL				//Regime de Atendimento
	WSDATA SaudOcNwS				AS String OPTIONAL				//Saúde Ocupacional

	//CAMPOS DOS ANEXOS DE QUIMIOTERAPIA/RADIOTERAPIA E OPME
	WSDATA RegAns					AS String OPTIONAL
	WSDATA DatDia					AS Date OPTIONAL
	WSDATA DiaImg					AS String OPTIONAL
	WSDATA Estadi					AS String OPTIONAL
	WSDATA Ecog						AS String OPTIONAL
	WSDATA FinAtd					AS String OPTIONAL
	WSDATA DiaGch					AS String OPTIONAL
	WSDATA GuiRef		 			AS String OPTIONAL
	WSDATA InfRel					AS String OPTIONAL
	WSDATA Cirurg					AS String OPTIONAL
	WSDATA Quimio 					AS String OPTIONAL
	WSDATA DatCir					AS Date OPTIONAL
	WSDATA DatIrr	 				AS Date OPTIONAL
	WSDATA Datqui					AS Date OPTIONAL
	WSDATA EmafSol					AS String OPTIONAL
	WSDATA TelfSol					AS String OPTIONAL
	WSDATA NroCam					AS float OPTIONAL
	WSDATA DosDia					AS float OPTIONAL
	WSDATA DosTot					AS float OPTIONAL
	WSDATA NroDia					AS float OPTIONAL
	WSDATA DatPre					AS date OPTIONAL
	WSDATA Plater					AS String OPTIONAL
	WSDATA TipQui					AS String OPTIONAL
	WSDATA SupCor					AS float OPTIONAL
	WSDATA Altura					AS float OPTIONAL
	WSDATA Peso						AS float OPTIONAL
	WSDATA EspMat					AS String OPTIONAL
	WSDATA Observ					AS String OPTIONAL
	WSDATA JustTe					AS String OPTIONAL
	WSDATA AreaIr					AS String OPTIONAL
	WSDATA NroCic					AS float OPTIONAL
	WSDATA CicAtu					AS float OPTIONAL
	WSDATA IntCic					AS float OPTIONAL
	WSDATA Idade					AS float OPTIONAL
	WSDATA Sexo						AS String OPTIONAL
	WSDATA PrvQui 					AS String OPTIONAL
	WSDATA PrvOpm 					AS String OPTIONAL

	WSDATA CodOpeSol				AS String OPTIONAL 				//Operadora Solicitante
	WSDATA ProfSol					AS String OPTIONAL				//Codigo do Solicitante
	WSDATA NomfSol					AS String OPTIONAL 				//Nome do Profisional Solicitante
	WSDATA EspSol						AS String OPTIONAL			//Codigo especialidade solicitante
	WSDATA RdaCon					AS String OPTIONAL				//Codigo da RDA contratada solicitante

	WSDATA CodOpeExe				AS String OPTIONAL 				//Operadora Executante
	WSDATA ProfExe					AS String OPTIONAL 				//Codigo do Profisional Executante
	WSDATA NomfExe					AS String OPTIONAL 				//Nome do Profisional Executante
	WSDATA CpfExe					AS String OPTIONAL 				//Cpf do Executante
	WSDATA CnesExe					AS String OPTIONAL 				//Cnes do Executante
	WSDATA EspExe						AS String OPTIONAL			//Codigo especialidade executante

	WSDATA CardName					AS String OPTIONAL				//Nome contido no cartao
	WSDATA CardEdition				AS String OPTIONAL				//Via do Cartao
	WSDATA CardValidDate			AS String OPTIONAL				//Data de Validade do Cartao
	WSDATA CardEnCloses				AS String OPTIONAL				//Abrangencia
	WSDATA CardNatJust			    AS String OPTIONAL				//Naturera juridica
	WSDATA TipCon			    	AS String OPTIONAL				//Tipo de Consulta
	WSDATA TipSai			    	AS String OPTIONAL				//Tipo de Saida
	WSDATA TipAte			    	AS String OPTIONAL				//Tipo de Atendimento
	WSDATA TipAto			    	AS String OPTIONAL				//Tipo de Atendimento Odontologico
	WSDATA TipFat			    	AS String OPTIONAL				//Tipo de Faturamento
	WSDATA QtdDSol			    	AS String OPTIONAL				//Quantidade de Diaria Solicitada

	WSDATA Tumor			    	AS String OPTIONAL				//Tumor
	WSDATA Nodulo			    	AS String OPTIONAL				//Nodulo
	WSDATA Metast			    	AS String OPTIONAL				//Metastase
	WSDATA DCicAtu			    	AS float OPTIONAL				//Dias Ciclo Atual

	WSDATA Obs				    	AS String OPTIONAL				//Observacao
	WSDATA TipDoe				   	AS String OPTIONAL				//Tipo de Doenca
	WSDATA TmpDoe				   	AS Integer OPTIONAL				//Tempo da Doenca
	WSDATA UndDoe				   	AS String OPTIONAL				//Unidade da Doenca
	WSDATA IndAcid				   	AS String OPTIONAL				//Indicacao de Acidente
	WSDATA ChkReg				   	AS Boolean OPTIONAL				//Se checa regras sim ou nao
	WSDATA DatSol                 	AS date OPTIONAL				//Data Solicitação
	WSDATA CarSol				   	AS String OPTIONAL				//Carater da Solicitacao
	WSDATA IndCli				   	AS String OPTIONAL				//Indicacao Clinica
	WSDATA EndCon				   	AS String OPTIONAL				//Endereco do Contratado
	WSDATA TpIntern				   	AS String OPTIONAL				//Tipo de Internacao
	WSDATA RegInter				   	AS String OPTIONAL				//Regime da Internacao
	WSDATA TpAcom				   	AS String OPTIONAL				//Tipo de Acomodacao
	WSDATA TpAcomPro				AS String OPTIONAL				//Tipo de Acomodacao Autorizada
	WSDATA PadCon				   	AS String OPTIONAL				//Padrao de Conforto
	WSDATA AtenRN				   	AS String OPTIONAL				//Atendimento RN
	WSDATA CnpjSolT					AS String OPTIONAL				//CGC da Rda Solicitada
	WSDATA ValTot				   	AS Float OPTIONAL				//Valor Total

	WSDATA NomeRda					AS String OPTIONAL				//Nome da Rda Executante
	WSDATA GrPar					AS String OPTIONAL				//Grau de Participacao
	WSDATA CodSig					AS String OPTIONAL				//Sipla
	WSDATA NumCr					AS String OPTIONAL				//Numero CRM
	WSDATA Estado					AS String OPTIONAL				//Estado

	WSDATA Inter				   	AS Boolean OPTIONAL				//Internacao
	WSDATA Evolu				   	AS Boolean OPTIONAL				//Prorrogacao
	WSDATA Honor				   	AS Boolean OPTIONAL				//Honorario
	WSDATA ResInt				   	AS Boolean OPTIONAL				//Resumo de internacao

	WSDATA UserFields               AS Array Of UserField OPTIONAL
	WSDATA TissVer				   	AS String OPTIONAL				//Versão TISS

	WSDATA IniFat					AS date OPTIONAL
	WSDATA FimFat					AS date OPTIONAL

	WSDATA   DtRlz                    AS date OPTIONAL
	WSDATA   DtRlz2                   AS date OPTIONAL
	WSDATA   DtRlz3                   AS date OPTIONAL
	WSDATA   DtRlz4                   AS date OPTIONAL
	WSDATA   DtRlz5                   AS date OPTIONAL
	WSDATA   DtRlz6                   AS date OPTIONAL
	WSDATA   DtRlz7                   AS date OPTIONAL
	WSDATA   DtRlz8                   AS date OPTIONAL
	WSDATA   DtRlz9                   AS date OPTIONAL
	WSDATA   DtRlz1                   AS date OPTIONAL
	WSDATA   TipoConfirm              AS String OPTIONAL

	WSDATA   NumDecVivo					AS String OPTIONAL
	WSDATA	 NumDecObt					AS String OPTIONAL
	WSDATA   IndicRN						AS String OPTIONAL
	WSDATA   HorIniFat					AS STRING OPTIONAL
	WSDATA   HorFimFat					AS String OPTIONAL
	WSDATA   AddedExec					AS String OPTIONAL
	WSDATA   AdadB7B					AS String OPTIONAL
ENDWSSTRUCT


WSSTRUCT AutHeaderCustomFields
	WSDATA Alias					AS String OPTIONAL				//Sequencia
	WSDATA AliasFieldName			AS String OPTIONAL				//Codigo
	WSDATA FieldContent				AS String OPTIONAL				//Descricao
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas do co-participacao							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatVlrCo
	WSDATA ExibeCo	 		AS String  OPTIONAL //Se exibe a co-participacao
	WSDATA ExibeBa	 		AS String  OPTIONAL //Se exibe a Base da co-participacao
	WSDATA GuiAco	 		AS String  OPTIONAL //Guia Comprada
	WSDATA PagRDA			AS String  OPTIONAL //Pagamento da Rda
	WSDATA VlrPF	 			AS Float   OPTIONAL //Valor PF
	WSDATA VlrBPF			AS Float   OPTIONAL //Valor Base PF
	WSDATA PercPF	 		AS Float   OPTIONAL //Valor Percentual PF
	WSDATA VlrTPF	 		AS Float   OPTIONAL //Valor Total PF
	WSDATA VlrTAD	 		AS Float   OPTIONAL //Valor Taxa
	WSDATA Msg001	 		AS String  OPTIONAL //"Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	WSDATA Msg002	 		AS String  OPTIONAL //"Valor a ser pago direto a rede de atendimento&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
	WSDATA Msg003	 		AS String  OPTIONAL //"Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
	WSDATA Msg004	 		AS String  OPTIONAL //"Valor da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
	WSDATA Msg005	 		AS String  OPTIONAL //"Valor da Taxa Administracao&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
	WSDATA Msg006	 		AS String  OPTIONAL //"Valor Total da Co-Participacao&nbsp;R$:&nbsp;")
	WSDATA Msg007	 		AS String  OPTIONAL //"Valor total a ser pago direto a rede de atendimento&nbsp;R$:&nbsp;")
	WSDATA Msg008	 		AS String  OPTIONAL //"Valor Total da Co-Participacao&nbsp;R$:&nbsp;")
	WSDATA Msg009	 		AS String  OPTIONAL //"Valor Total da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
	WSDATA Msg010	 		AS String  OPTIONAL //"(*) Nao inclui valores de materiais e medicamentos.&nbsp;")
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas  item		                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT AutItemView
	WSDATA Sequence					AS String OPTIONAL				//Sequencia
	WSDATA CodPad					AS String OPTIONAL				//Codigo da tabela
	WSDATA ProcedureCode			AS String OPTIONAL				//Codigo do Procedimento
	WSDATA ProcedureDescription		AS String OPTIONAL				//Descricao do Procedimento
	WSDATA ProcedureQuantity		AS Float OPTIONAL				//Quantidade do Procedimento
	WSDATA QtdAut					AS Float OPTIONAL				//Quantidade de Procedimentos Autorizados
	WSDATA VlrApr					AS Float OPTIONAL				//Valor Apresentado
	WSDATA Medico					AS String OPTIONAL				//Executante Medico
	WSDATA Anestesista				AS String OPTIONAL				//Executante Anastesista
	WSDATA Auxiliar1				AS String OPTIONAL				//Executante Auxiliar1
	WSDATA Auxiliar2				AS String OPTIONAL				//Executante Auxiliar2
	WSDATA Cirurgiao				AS String OPTIONAL				//Cirurgiao
	WSDATA Dente				   	AS String OPTIONAL				//Dente
	WSDATA Face					   	AS String OPTIONAL				//Face
	WSDATA ResAut					AS String OPTIONAL				//Resp. pela Autorizacao
	WSDATA IndCliEvo				AS String OPTIONAL				//Indicacao Clinica Evolucao
	WSDATA HorIni					AS String OPTIONAL				//Hora Inicio
	WSDATA HorFim					AS String OPTIONAL				//Hora Fim
	WSDATA ViaAc					AS String OPTIONAL				//Via Ac
	WSDATA TecUt					AS String OPTIONAL              //TecUt
	WSDATA RedAcre					AS Float  OPTIONAL              //RedAcre
	WSDATA StProc					AS String OPTIONAL              //Status do Procedimento
	WSDATA UserFields               AS Array Of UserField OPTIONAL
	WSDATA GrpParExe					AS Array Of GrpParExe OPTIONAL				//Status do Procedimento

	WSDATA DatPro					AS Date OPTIONAL
	WSDATA ViaAdm					AS String OPTIONAL
	WSDATA Freque					AS float OPTIONAL
	WSDATA RegAnv					AS String OPTIONAL
	WSDATA RefMat					AS String OPTIONAL
	WSDATA AutFun					AS String OPTIONAL
	WSDATA VlrUnt					AS Float  OPTIONAL
	WSDATA QtdSol					AS Float  OPTIONAL
	WSDATA VlrTot					AS Float  OPTIONAL
	WSDATA Opcao					AS String OPTIONAL
	WSDATA DiagPro					AS String OPTIONAL
	WSDATA UniMedC					AS String OPTIONAL   //Unidade de medida da Guia de Anexos Clínicos - Quimio

ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas cabecalho e item                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT AuthorizationView
	WSDATA AutHeader	AS AutHeaderView					//Cabecalho da Autorizacao
	WSDATA AutItem		AS Array Of AutItemView OPTIONAL	//Item da Autorizacao
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas resposta da autorizacao              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT AutResponseView
	WSDATA Number  					AS String OPTIONAL					//Numero da Autorizacao
	WSDATA Password					AS String OPTIONAL					//Senha da Autorizacao
	WSDATA Error					AS Array Of AutErrorView OPTIONAL	//Array de Erros
	WSDATA Authorized				AS Array Of AuthorizedView OPTIONAL	//Array de Procedimentos Autorizados
	WSDATA NotAuthorized			AS Array Of AuthorizedView OPTIONAL	//Array de Procedimentos Nao Autorizados
	WSDATA VlrTotal					AS Float OPTIONAL					//Total de todas as Cobrancas
	WSDATA ato						AS Boolean OPTIONAL					//Pagamento no ato
	WSDATA MsgClient  				AS String OPTIONAL					//Mensagem ao Cliente (OBS)
	WSDATA DPrAH  					AS Date OPTIONAL					//Data prov Internacao AUT.
	WSDATA QtdDAut					AS String OPTIONAL					//Diarias Autorizadas
	WSDATA DtValSen					AS Date OPTIONAL					//Data prov Internacao AUT.
	WSDATA StatAut					AS String OPTIONAL					//Descricao do Status da autorizacao (BEA_STATUS)
	WSDATA ProcRadio					AS Boolean OPTIONAL					//Indica que há procedimento de radioterapia na guia
	WSDATA Audi						AS Boolean OPTIONAL					//Indica é Procedimento de auditoria
	WSDATA RetCoPar					AS SMatVlrCo OPTIONAL				//Valores referentes a co-participacao
	WSDATA Alerta					AS Array Of AutErrorView OPTIONAL	//Array de Alertas
	WSDATA MudFasOff					AS Boolean OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas criticas				               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT AutErrorView
	WSDATA Sequence					AS String OPTIONAL				//Sequencia
	WSDATA Code						AS String OPTIONAL				//Codigo
	WSDATA Description				AS String OPTIONAL				//Descricao
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas procedimento autorizados             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT AuthorizedView
	WSDATA Sequence					AS String OPTIONAL				//Sequencia
	WSDATA TableCode				AS String OPTIONAL				//Codigo da Tabela
	WSDATA ProcedureCode			AS String OPTIONAL				//Codigo do Procedimento
	WSDATA Description				AS String OPTIONAL				//Descricao
	WSDATA Dente					AS String OPTIONAL				//Dente
	WSDATA Face						AS String OPTIONAL				//Face
	WSDATA QtdTotal					AS Integer OPTIONAL				//Qtd Total
	WSDATA VlrTotal					AS Float OPTIONAL				//Total da Cobrancas
	WSDATA TotalUs					AS Float OPTIONAL				//Total de US
	WSDATA Senha					AS String OPTIONAL				//Senha
	WSDATA StProc					AS String OPTIONAL				//Status do Procedimento
	WSDATA ImpProc					AS String OPTIONAL				//Imprime Procedimento Não autorizado
ENDWSSTRUCT

WSSTRUCT GrpParExe
	WSDATA ProfExe				AS String OPTIONAL 				//Codigo do Profisional Executante
	WSDATA NomProf				AS String OPTIONAL 				//Nome do Profisional Executante
	WSDATA CpfExe					AS String OPTIONAL 				//Cpf do Executante
	WSDATA GrPar					AS String OPTIONAL				//Grau de Participacao
	WSDATA CodSig					AS String OPTIONAL				//Sipla
	WSDATA NumCr					AS String OPTIONAL				//Numero CRM
	WSDATA Estado					AS String OPTIONAL				//Estado
	WSDATA SeqPro					AS String OPTIONAL				//Seq. Procedimento
	WSDATA Cbos					AS String OPTIONAL				//CBOS
	WSDATA EspExe					AS String OPTIONAL				//Especialidade
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao do Web Service
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSERVICE PLSXMOV					DESCRIPTION "Autorizacao de Procedimento"
	WSDATA UserCode					AS String
	WSDATA CompanyCode				AS String OPTIONAL
	WSDATA RDACode					AS String
	WSDATA LOCALCode				AS String
	WSDATA Authorization			As AuthorizationView
	WSDATA AutResponse				As AutResponseView
	WSDATA AutType					AS Integer OPTIONAL
	WSDATA Origem					AS String OPTIONAL
	WSDATA NumAut					AS String OPTIONAL
	WSDATA TransactionNumber		AS String OPTIONAL
	WSDATA DigitacaoGuia			AS String OPTIONAL
	WSDATA WSNULL					AS String
	WSDATA RetCoPar					AS SMatVlrCo OPTIONAL

	WSMETHOD PutAuthorization		DESCRIPTION "Execucao de uma autorizacao (Consulta/Exame)"
	WSMETHOD GravaAnexo				DESCRIPTION "Grava os Anexos"
	WSMETHOD BackDigitacaoGuia		DESCRIPTION "Retorna guias selecionadas para a fase de digitação"
	WSMETHOD GetVlrCo					DESCRIPTION "Retorna o valor da co-participacao"

	//WSMETHOD DelGuia				DESCRIPTION "Exclusão de Guias"	Transformar na rotina de cancelamento de guias

ENDWSSERVICE
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PutAuthori³Autor  ³ Luiz Couto            ³ Data ³07.07.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de inclusao Autorizacao                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: [1] Codigo WS                                         ³±±
±±³          ³ExpC2: [2] Codigo Operadora                                  ³±±
±±³          ³ExpC3: [3] Codigo Rede de Atendimento                        ³±±
±±³          ³ExpC4: [4] Codigo LOCAL de Atendimento                       ³±±
±±³          ³ExpO1: [5] Objeto Autorizacao                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo inclui a autorizacao                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ WEB SERVICES                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PutAuthorization WSRECEIVE UserCode, CompanyCode, RDACode, LOCALCode, AutType, Authorization, Origem, NumAut, DigitacaoGuia WSSEND AutResponse WSSERVICE PLSXMOV
	LOCAL nI 			:= 0
	LOCAL nVlrTotal		:= 0
	LOCAL nCont			:= 0
	LOCAL nJ			:= 0
	LOCAL lRetorno 		:= .T.
	LOCAL lOk			:= .T.
	LOCAL lInter    	:= .F.
	LOCAL lEvolu    	:= .F.
	LOCAL lHonor    	:= .F.
	LOCAL lResInt   	:= .F.
	LOCAL aArea 		:= GetArea()
	LOCAL aUnMed		:= {}
	LOCAL aRet			:= {}
	LOCAL aDados 		:= {}
	LOCAL aItens 		:= {}
	LOCAL aRetorno		:= {}
	LOCAL aCriticas		:= {}
	LOCAL aCritMDF		:= {}
	LOCAL aAut			:= {}
	LOCAL aNaoAut		:= {}
	LOCAL aTpPRec		:= {}
	LOCAL aRslTOFF		:= {}
	LOCAL nTamObs   	:= (TamSX3("BEA_MSG01")[1])
	LOCAL cMatric   	:= ""
	LOCAL cRdaProf		:= ""
	LOCAL cCodLocPro	:= ""
	LOCAL cSenhaAut		:= ""
	LOCAL cEspSol 		:= ""
	LOCAL cCodEsp 		:= ""
	LOCAL cPrvQui		:= ""
	LOCAL cPrvOpm		:= ""
	LOCAL cMvPPM		:= GetNewPar("MV_PPMSEN","1")
	LOCAL cTissVer		:= ""
	LOCAL cCpfExe		:= ""
	LOCAL cTpIntern		:= ""
	LOCAL cDente		:= ""
	LOCAL cFace			:= ""
	LOCAL cDecode   	:= nil
	LOCAL aAlerta   	:= {}
	LOCAL cMvPlCdPro	:= GetNewPar("MV_PLCDPRO","")
	Local cCodProComp 	:= ""
	Local cCodPadComp 	:= ""
	Local Inclui 		:= .T. //Utilizado no inicializador padrao BD5_TIPADM
	Local cTipAdm 		:= ""
	Local nFor			:= 0
	Local nFor2			:= 0
	Local cCbos 		:= ""
	Local cEspExe 		:= ""
	Local lAud			:= .F.
	Local lASort 		:= .T. //Utilizado para efetuar ASort na data do procedimento.
	Local nForSort		:= 0
	Local aCpoTermo 	:= {	{ "TIPSAI", "39", "BEA"},; //Tipo de Saida
		{ "TIPATE", "50", ""   },; //Tipo de atendimento
		{ "TIPFAT", "55", ""   },; //Tipo de faturamento
		{ "INDACI", "36", "BEA"},; //Indicador de acidente
		{ "CARSOL", "23", "BDR"   },; //Carater da solicitaçao//
		{ "TIPCON", "52", ""   },; //Tipo de consulta
		{ "AUNMED", "60", ""   },; //Unidade de medida
		{ "CODESP", "24", "BAQ"}}  //Tecnica utilizada
	Local nhEX			:= 0
	Local lEX			:= .F.
	Local lMudFasO		:= .F.
	Local dDatProOrd	:= NIL
	Local aProcOrder 	:= {}
	Local nVlrApCar	:= 0
	Local cCaraterSol := ""
	Local lPortalMetric := .T.
	Local aValidEsp := { {.T., .F.}, {.F., .T.}, {.F., .F.} }
	Local nxValEsp := 0
	Local cSql2 := ""
	
	PRIVATE aTabDup 	:= PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
	PRIVATE aErrVarVin 	:= {.F., "", "", ""}
	PRIVATE lDigiGuia 	:= !Empty(::DigitacaoGuia)

	DEFAULT ::NumAut 	:= ""
	DEFAULT ::RetCoPar 	:= {}

	//Verifica se pode executar
	If PrtChkUser( ::UserCode, "PLSXMOV", "PUTAUTHORIZATION" )

		//bloco pra evitar que o cara confirme uma execução simultânea, se o lEX der .T., tem um
		//PLSFECHASEM lá no final dessa função
		If FindFunction("PLWebSaldo") .AND. !(EmpTy(::Authorization:AUTHEADER:ReleaseNumber)) .And. (::AutType <> 5) //Guia de honorário não altera liberação, gerando erro 'Execução desta guia já foi feita

			nhEX := PLSABRESEM("EX_" + AllTrim(::Authorization:AUTHEADER:ReleaseNumber) + ".SMF")

			if nhEX > 0

				lEX := PLWebSaldo( AllTrim(::Authorization:AUTHEADER:ReleaseNumber), lDigiGuia)

				If !(lEX)
					PLSFECHASEM(nhEX, "EX_" + AllTrim(::Authorization:AUTHEADER:ReleaseNumber) + ".SMF")
					SetSoapFault( "", "Problema na transação, a execução desta guia já foi feita " )
					Return .F.
				EndIf
			else
				SetSoapFault( "", "Problema na transação, a execução desta guia está sendo confirmada " )
				Return .F.
			EndIf

		EndIf

		//Recupera a Versão da TISS
		aClasse := ClassDataArr(::Authorization:AUTHEADER)

		If aScan(aClasse,{|x| AllTrim(x[1]) == "TISSVER"  }) > 0
			cTissVer := ::Authorization:AUTHEADER:TissVer
		Else
			cTissVer := ""
		EndIf

		If aScan(aClasse,{|x| AllTrim(x[1]) == "PRVOPM"  }) > 0
			cPrvOpm := ::Authorization:AUTHEADER:PrvOpm
		Else
			cPrvOpm := ""
		EndIf

		If aScan(aClasse,{|x| AllTrim(x[1]) == "PRVQUI"  }) > 0
			cPrvQui := ::Authorization:AUTHEADER:PrvQui
		Else
			cPrvQui := ""
		EndIf

		//Controle das guias complementares
		lInter := ::Authorization:AutHeader:Inter
		lEvolu := ::Authorization:AutHeader:Evolu
		lHonor := ::Authorization:AutHeader:Honor
		lResInt:= ::Authorization:AutHeader:ResInt

		//Verifica se e usuario de intercambio e pega a matricula original
		cMatric := PPLTROMAT( Authorization:AutHeader:RegistrationNumber )

		//Verifica matricula antiga ou atual
		If ! Empty(cMatric)

			//Posiciona na familia
			BA3->( DbSetOrder(01) ) //BA3_FILIAL + BA3_CODINT + BA3_CODEMP + BA3_MATRIC + BA3_CONEMP + BA3_VERCON + BA3_SUBCON + BA3_VERSUB
			If !BA3->( MsSeek( xFilial("BA3")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC) ) )
				SetSoapFault( "", "Problema na transação familia não encontrada!" )
				Return .F.
			EndIf

			//Via do cartao
			If Empty(Authorization:AutHeader:CardEdition)
				Authorization:AutHeader:CardEdition := AllTrim( Str(BA1->BA1_VIACAR) )
			EndIf

		Else
			SetSoapFault( "", "Problema na transação matricula não encontrada!" )
			Return .F.
		EndIf

		//Pegar o RDA do profissional
		If ::Origem == '1' //Execucao
			cRdaProf := ::Authorization:AutHeader:ProfExe
		Else
			cRdaProf := ::Authorization:AutHeader:ProfSol
		EndIf

		If (::AutType == 5 .or. ::AutType == 6) .and. cTissVer >= "3"
			BAU->( dbSetOrder(1) )//BAU_FILIAL + BAU_CODIGO
		Else
			BAU->( dbSetOrder(5) )//BAU_FILIAL + BAU_CODBB0
		EndIf

		if ! empty(cRdaProf)

			if BAU->( MsSeek( xFilial("BAU") + cRdaProf ) )
				cRdaProf := BAU->BAU_CODIGO
			else
				cRdaProf := ""
			endIf

		endIf

		//Procura o LOCAL	no profissional
		If ! empty(cRdaProf) .and. ! empty(::Authorization:AutHeader:EndCon) .And. ::RDACode <> cRdaProf

			BB8->( DbSetOrder(5) ) //BB8_FILIAL + BB8_TIPLOG + BB8_CEP + BB8_NR_END + BB8_EST + BB8_CODIGO + BB8_CODINT
			If BB8->( MsSeek( xFilial("BB8") + ::Authorization:AutHeader:EndCon + cRdaProf + PLSINTPAD() ) )
				cCodLocPro := BB8->BB8_CODLOC
			Else
				FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01',"RDA Prof. "+cRdaProf+" - "+"LOCAL de Atendimento não encontrado com base no Endereço -> ( "+::Authorization:AutHeader:EndCon+"-"+cRdaProf+" )" , 0, 0, {})
			EndIf

		EndIf

		//Especialidade do Profissional de Saude SOLICITANTE
		If Empty(::Authorization:AutHeader:ReleaseNumber) .and. ! Empty(::Authorization:AutHeader:ProfSol)

			If BQ1->( MsSeek( xFilial("BQ1")+::Authorization:AutHeader:ProfSol+::Authorization:AutHeader:EspSol ) )
				cEspSol := ::Authorization:AutHeader:EspSol
			Else

				BAQ->(DbSetOrder(1))
				If BAQ->(MsSeek(xFilial("BAQ")+PlsIntPad()+::Authorization:AutHeader:EspSol))

					BQ1->(RecLock("BQ1", .T.))
					BQ1->BQ1_FILIAL := xFilial("BQ1")
					BQ1->BQ1_CODINT := PlsIntPad()
					BQ1->BQ1_CODIGO := (::Authorization:AutHeader:ProfSol)
					BQ1->BQ1_CODESP := (::Authorization:AutHeader:EspSol)
					BQ1->BQ1_DESCRI := BAQ->BAQ_DESCRI
					BQ1->(MsUnlock())

				EndIf
				cEspSol := ::Authorization:AutHeader:EspSol

			EndIf

		EndIf

		If Empty(::Authorization:AutHeader:ReleaseNumber)
			cEspSol := ::Authorization:AutHeader:EspSol
		EndIf

		//a especialidade que vem em ::Authorization:AutHeader:SpecialityCode que alimenta o bd5_codesp
		//mas se ela veio com base no solicitante esta especialidade pode nao existir no BAX então eu pego a principal da RDA
		BAX->(DbSetOrder(1))
		If !BAX->(DbSeek(xFilial("BAX")+::RDACode+PlsIntPad()+::LOCALCode+::Authorization:AutHeader:SpecialityCode))

			For nxValEsp := 1 To Len(aValidEsp)
				If validaEspBaq(aValidEsp[nxValEsp][1], aValidEsp[nxValEsp][2], ::RDACode, ::LOCALCode, @cCodEsp)
					Exit 
				EndIf
			Next

			If !Empty(cCodEsp)
				::Authorization:AutHeader:SpecialityCode := cCodEsp
			Endif
		else 
			cSql2 := " SELECT BAX.BAX_CODESP"
			cSql2 += " FROM " + RetSqlName("BAX") + " BAX"
			cSql2 += " JOIN " + RetSqlName("BAQ") + " BAQ"
			cSql2 += " ON BAQ.BAQ_FILIAL = '" + xFilial('BAQ') + "'"
			cSql2 += " AND BAQ.BAQ_CODESP = BAX.BAX_CODESP"
			cSql2 += " WHERE BAX.BAX_FILIAL = '" + xFilial('BAX') + "'"
			cSql2 += " AND BAX.BAX_CODIGO = '" + ::RDACode + "'"
			cSql2 += " AND BAX.BAX_CODINT = '" + PlsIntPad() + "'"
			cSql2 += " AND BAX.BAX_CODLOC = '" + ::LOCALCode + "'"
			cSql2 += " AND ( BAX.BAX_DATBLO > '" + dtos(dDataBase) + "' OR BAX.BAX_DATBLO = ' ' )"
			cSql2 += " AND BAX.D_E_L_E_T_ = ' '"
			cSql2 += " AND BAQ.BAQ_CBOS = ("
			cSql2 += "    SELECT BAQ.BAQ_CBOS"
			cSql2 += "    FROM " + RetSQLName("BAQ") + " BAQ"
			cSql2 += "    WHERE BAQ.BAQ_FILIAL = '" + xFilial('BAQ') + "'"
			cSql2 += "    AND BAQ.BAQ_CODINT = '" + PlsIntPad() + "'"
			cSql2 += "    AND BAQ.BAQ_CODESP = '" + BAX->BAX_CODESP + "'"
			cSql2 += "    AND BAQ.D_E_L_E_T_ = ' '"
			cSql2 += " )"

			dbUseArea(.t.,"TOPCONN",tcGenQry(,,changeQuery(cSql2)),"Trb",.f.,.t.)

			if ( !(Trb->(EoF())) )
 				cCodEsp := Trb->(BAX_CODESP)
				If !Empty(cCodEsp)
					::Authorization:AutHeader:SpecialityCode := cCodEsp
				Endif
 			else 
				SetSoapFault( "", "Especialidade "+ BAX->BAX_CODESP +" do profissional bloqueada para essa RDA")
				Return .F.
			endif

			Trb->(DbCloseArea()) 

		EndIf

		//Honorario Individual
		If ::AutType == 5

			//Participacao
			AaDd( aTpPRec,{ ::Authorization:AutHeader:GrPar,;
				::RDACode,;
				::Authorization:AutHeader:NomeRda,;
				::Authorization:AutHeader:NumCr,;
				::Authorization:AutHeader:CodSig,;
				::Authorization:AutHeader:Estado,;
				::Authorization:AutHeader:NomfExe,.T. } )
		EndIf

		//Unidades
		aUnMed := PLSXBKC()

		If ValType(cTissVer) <> 'U' .And. cTissVer >= '3'

			cIndAcid   := alltrim(PLSVARVINC('36', nil, ::Authorization:AutHeader:IndAcid))
			cTipCon    := alltrim(PLSVARVINC('52', nil, ::Authorization:AutHeader:TipCon) )

			if ! empty(::Authorization:AutHeader:CarSol)
				cCarSol := alltrim(PLSVARVINC('23', 'BDR', ::Authorization:AutHeader:CarSol) )
			endIf

			cGrpInt    := alltrim(PLSVARVINC('57', nil, ::Authorization:AutHeader:TpIntern))

			If ::AutType == 2 .and. ! empty(::Authorization:AutHeader:TipSai)
				cTipSai	 := alltrim(PLSVARVINC('39','BEA', ::Authorization:AutHeader:TipSai))
			EndIf

			cTpIntern  := ""

			cSql := " SELECT BQR_TIPINT TIPINT FROM " + RetSqlName("BQR")
			cSql += "  WHERE BQR_FILIAL = '" + xFilial('BQR')   + "'"
			cSql += "    AND BQR_GRPINT = '" + allTrim(cGrpInt) + "'"
			cSql += "    AND D_E_L_E_T_ = ' ' "

			dbUseArea(.t.,"TOPCONN",tcGenQry(,,changeQuery(cSql)),"TrbBQR",.f.,.t.)

			If !TrbBQR->(Eof())
				cTpIntern := TrbBQR->TIPINT //pego o primeiro pois o cara pode ter varios la e nao existe de-para para isso
			Endif
			TrbBQR->(DbCloseArea())

			cRegInt    := alltrim(PLSVARVINC('41', nil, ::Authorization:AutHeader:RegInter))
		Else
			cIndAcid   := ::Authorization:AutHeader:IndAcid
			cTipCon    := ::Authorization:AutHeader:TipCon

			if ! empty(::Authorization:AutHeader:CarSol)
				cCarSol := ::Authorization:AutHeader:CarSol
			endIf

			cGrpInt    := getNewPar("MV_GRPINT",'1')
			cTpIntern  := ::Authorization:AutHeader:TpIntern
			cRegInt    := ::Authorization:AutHeader:RegInter
		Endif

		//QUANDO FOR UMA GUIA DE CONSULTA RECUPERA O INICIALIZADOR PADRAO DE TIPATE E TIPADM
		if (::AutType == 1)

			SX3->(DbSetOrder(2))
			IF (SX3->(DbSeek("BD5_TIPADM")) .And. !Empty(SX3->X3_RELACAO))
				cTipAdm := &(SX3->X3_RELACAO)
			ENDIF

			IF (SX3->(DbSeek("BD5_TIPATE")) .And. !Empty(SX3->X3_RELACAO))
				::Authorization:AutHeader:TipAte := &(SX3->X3_RELACAO)
			ENDIF

		endif

		//Recupera a data dos procedimentos ordenando pelo menor (mais antigo). Apenas para SADT
		if (::AutType==2) .and. len(::Authorization:AutItem) > 0

			if len(::Authorization:AutItem) > 1

				aProcOrder := ACLONE(::Authorization:AutItem)

				For nForSort := 1 To Len(aProcOrder)

					If aProcOrder[nForSort]:DatPro == NIL
						lASort := .F.
						EXIT
					Endif

				Next

				If(lASort)
					aSort(aProcOrder,,, {|x,y| x:DatPro < y:DatPro} )
				EndIf

				dDatProOrd := aProcOrder[1]:DatPro
			else
				dDatProOrd := ::Authorization:AutItem[1]:DatPro
			endif

			// Esse item se faz necessarios devido que as Guias SADT não são obrigatorias a sua informação, assim tenho que preencher os campos abaixo com a especialdiade da RDA
			// sera utlizado na validação da função PLSTratExe onde é criado o array aBD7 e para essa temso que prrencher
			If Empty(::Authorization:AutHeader:EspExe) .and. (::Origem == '1')
				::Authorization:AutHeader:EspExe := ::Authorization:AutHeader:SpecialityCode
				::Authorization:AutHeader:ProfExe:= ::Authorization:AutHeader:SpecialityCode
			Endif

		endif
		BEA->(DbSetOrder(1))
		If (::Origem == '1') .And. (::AutType == 2) .And.;
				Empty(Authorization:AutHeader:OperCompAutNumber) .And. !Empty(Authorization:AutHeader:ReleaseNumber) .And.;
				BEA->(DbSeek(xFilial("BEA")+Authorization:AutHeader:ReleaseNumber)) .And. !Empty(BEA->BEA_NRAOPE)
			::Authorization:AutHeader:OperCompAutNumber := BEA->BEA_NRAOPE
		EndIf

		//Cabecalho da guia
		aDados := 	{   { "TP_CLIENTE"	, "WEB" },;											//Tipo de Cliente
			{ "TPGRV"		, "2" },;											//Tipo de Gravacao
			{ "TIPOMAT"   	, "1" },;											//Matricula Siga
			{ "GERSEN"		, Iif(lInter,.f.,GetNewPAr("MV_PLGSENW",.T.)) },;				//Gera senha de autorização
			{ "CODLDP"		, IIF(RetDigGuia(),PLSRETLDP(4),IIF(PLSOBRPRDA(::RDACode),PLSRETLDP(9),GetNewPar("MV_PLSWEDI", PLSRETLDP(5))))  },;//LOCAL de Digitacao
			{ "CODRDA"		, ::RDACode },;										//Rda
			{ "CODLOC"		, ::LOCALCode },;									//LOCAL de atendimento
			{ "LOCPRO"		, cCodLocPro },;									//LOCAL de atendimento da Rda do profissional
			{ "RDAPRO"		, cRdaProf },;										//Rda do Profissional de Saude
			{ "RDACONS"		, ::Authorization:AutHeader:CodSig },;	  		    //Conselho Profissional de Saude
			{ "RDANUMC"		, ::Authorization:AutHeader:NumCr  },;				//Numero Conselho Profissional de Saude
			{ "RDAUFCO"		, ::Authorization:AutHeader:Estado },;				//Estado Conselho Profissional de Saude
			{ "OPEMOV"		, PLSINTPAD() },;									//Operadora de movimento
			{ "OPEINT"		, Iif(lInter,PLSINTPAD(),'') },;					//Operadora de movimento Internacao
			{ "USUARIO"		, cMatric },;										//Matricula
			{ "ORIGEM"    	, ::Origem },;										//Origem 1=Autorizacao ou 2=Liberacao
			{ "NUMAUT"    	, ::NumAut },; 										//Numero da Autorizacao
			{ "LVALOR"		, .T. },; 											//indica que o evento sera valorizado
			{ "LRETVPF"		, .T. },; 											//indica que devera ser retornado o valor da participacao financeira
			{ "LREGPAGATO"	, .T. },; 											//indica se ira checar regra de "pagar o evento no ato"
			{ "INCAUTIE"  	, .T. },;											//Se o usuario for de intercambio e nao existir ele inclui
			{ "AUDEMP"  	, .F. },;											//Critica da operadora se manda para auditoria
			{ "RPC"  		, .T. },;											//.F. vem do remote .T web, pos
			{ "HORAPRO"		, SubStr( StrTran( Time(), ":", "" ), 1, 4 ) },;  //Hora do Procedimento
			{ "DATPRO"		, IIF(ValType(dDatProOrd)=="U",::Authorization:AutHeader:ProcedureDate,dDatProOrd) },; //Data do Procedimento
			{ "NUMLIB"		, ::Authorization:AutHeader:ReleaseNumber },;		//Numero da liberacao
			{ "CODCBO"		, ::Authorization:AutHeader:Cbo },;				//Cbos
			{ "CODESP"		, ::Authorization:AutHeader:SpecialityCode },;		//Especialidade
			{ "CIDPRI"		, ::Authorization:AutHeader:CidPri },;             //Cid Principal
			{ "CID2"		, ::Authorization:AutHeader:Cid2 },;				//Cid 2
			{ "CID3"		, ::Authorization:AutHeader:Cid3 },;				//Cid 3
			{ "CID4"		, ::Authorization:AutHeader:Cid4 },;				//Cid 4
			{ "CID5"		, ::Authorization:AutHeader:Cid5 },;				//Cid 5
			{ "OPESOL"		, ::Authorization:AutHeader:CodOpeSol },;			//Operadora Solicitante
			{ "CDPFSO"		, ::Authorization:AutHeader:ProfSol },;			//Profissional Solicitante
			{ "CDOPEX"		, ::Authorization:AutHeader:CodOpeExe },;			//Operadora Executante
			{ "CDPFEX"		, ::Authorization:AutHeader:ProfExe },;            //Profissional Executante
			{ "CPFEXE"		, ::Authorization:AutHeader:CpfExe },;             //Cpf Executante
			{ "CNESEXE"		, ::Authorization:AutHeader:CnesExe },;            //Cnes Executante
			{ "NOMEXEC"		, ::Authorization:AutHeader:NomeRda },;            //Nome Executante
			{ "NUMIMP"		, ::Authorization:AutHeader:FormNumber },;			//Atendimento Laboratorial
			{ "MSG01"    	, SubStr(AllTrim(::Authorization:AutHeader:Obs),1,nTamObs) },; //Observacao
			{ "MSG02"    	, SubStr(AllTrim(::Authorization:AutHeader:Obs),nTamObs+1,Len( AllTrim(::Authorization:AutHeader:Obs) ) ) },;//Observacao
			{ "MSG03"    	, "" },;											//Mensagem
			{ "NRAOPE"		, ::Authorization:AutHeader:OperCompAutNumber },;	//Numero autorizacao operadora
			{ "NRAEMP"		, ::Authorization:AutHeader:CompAutNumber },;      //Numero autorizacao empresa
			{ "VIACAR"    	, ::Authorization:AutHeader:CardEdition },; 		//Via do Cartao
			{ "DTVALID"   	, ::Authorization:AutHeader:CardValidDate },;     	//Data de Validade
			{ "AREAABR"    	, ::Authorization:AutHeader:CardEnCloses },; 		//Abrangencia
			{ "NATJURI"    	, ::Authorization:AutHeader:CardNatJust },;		//Natureza juridica
			{ "TIPO"      	, allTrim(Str(::AutType)) },;						//Tipo de Guia
			{ "NOMUSR"    	, ::Authorization:AutHeader:CardName },; 			//Nome Contido na carteirinha
			{ "TIPSAI"    	, ::Authorization:AutHeader:TipSai },; 			//Tipo de Saida
			{ "TIPATE"    	, ::Authorization:AutHeader:TipAte },; 			//Tipo de Atendimento
			{ "TIPATO"    	, ::Authorization:AutHeader:TipAto },; 			//Tipo de Atendimento Odontologico
			{ "TIPFAT"    	, ::Authorization:AutHeader:TipFat },; 			//Tipo de Faturamento
			{ "TIPDOE"    	, ::Authorization:AutHeader:TipDoe },; 			//Tipo de Doenca
			{ "TMPDOE"    	, ::Authorization:AutHeader:TmpDoe },; 			//Tempo da Doenca
			{ "UNDDOE"    	, ::Authorization:AutHeader:UndDoe },; 			//Unidade da Doenca
			{ "INDACI"    	, cIndAcid },; 			//Indicacao de Acidente
			{ "TPEVEN"		, cGrpInt },; 					//Grupo de internacao
			{ "TIPINT"    	, cTpIntern },;			//Tipo de Internacao
			{ "REGINT"   	, cRegInt },;			//Regime da Internacao
			{ "PADINT"   	, ::Authorization:AutHeader:TpAcom },;				//Tipo de Acomodacao
			{ "PADCON"   	, ::Authorization:AutHeader:PadCon },;				//Padrao de Conforto
			{ "CHKREG"    	, ::Authorization:AutHeader:ChkReg },; 			//Se vai checar regras ou nao
			{ "DATSOL"    	, ::Authorization:AutHeader:DatSol },; 			//Carater da solicitacao
			{ "CARSOL"    	, if(::AutType==4, GETNEWPAR("MV_PLSTPAD","1"),if(::AutType==1, cTipAdm, ::Authorization:AutHeader:CarSol))},; //Carater da solicitacao
			{ "INDCLI"    	, ::Authorization:AutHeader:IndCli },; 			//Indicacao de Clinica
			{ "TIPCON"    	, cTipCon },;				//Nome Contido na carteirinha
			{ "GUIPR"    		, ::Authorization:AutHeader:GuiPri },;				//Guia Principal
			{ "GUIPRI"    	, ::Authorization:AutHeader:GuiPri },;				//Guia Principal
			{ "VALTOT"    	, ::Authorization:AutHeader:ValTot },;				//Valor total da Guia honorario
			{ "INTERN"    	, lInter },; 										//Internacao
			{ "EVOLU"    	, lEvolu },; 										//Evolucao (prorrogacao de internacao)
			{ "QDISOL"    	, Val(::Authorization:AutHeader:QtdDSol) },;		//Quantidade de Diarias Solicitada
			{ "HORIND"    	, lHonor } ,;										//Honorario individual
			{ "CGCSOLT"    	, ::Authorization:AutHeader:CnpjSolT } ,;			//Cgc Rda Solicitada
			{ "NUMPEG"    	, ::Authorization:AutHeader:NumPeg } ,;			//Chave do BD6 - Numero da PEG
			{ "AUNMED" 		, aUnMed } ,;										//Unidade / Participacao
			{ "FORBLO"		, Iif(::AutType==4 .And. BR8->(FieldPos("BR8_TIPRAX")) > 0 .And. !Empty(BR8->BR8_TIPRAX) .And. BR8->BR8_TIPRAX <> '0',.T.,.F.)},;//Bloqueio
			{ "RESINT"    	, lResInt },;
			{ "TIPGUI"    	, If(::AutType==1,'01',If(::AutType==2,'02',If(::AutType==3,'03',If(::AutType==4,'13',If(::AutType==5 .or. ::AutType==6,'06',if(::AutType==11,'11', '')))))) },;
			{ "ESPSOL"		, cEspSol} ,;										//Resumo de internacao
			{ "ATENRN"		, ::Authorization:AutHeader:AtenRN},; //Atendimento RN
			{ "INIFAT"		,::Authorization:AutHeader:IniFat},;
			{ "PRVQUI"		,cPrvQui},;
			{ "PRVOPM"		,cPrvOpm},;
			{ "FIMFAT"		,::Authorization:AutHeader:FimFat},;
			{ "DTRLZ"		,::Authorization:AutHeader:DtRlz},;
			{ "DTRLZ2"		,::Authorization:AutHeader:DtRlz2},;
			{ "DTRLZ3"		,::Authorization:AutHeader:DtRlz3},;
			{ "DTRLZ4"		,::Authorization:AutHeader:DtRlz4},;
			{ "DTRLZ5"		,::Authorization:AutHeader:DtRlz5},;
			{ "DTRLZ6"		,::Authorization:AutHeader:DtRlz6},;
			{ "DTRLZ7"		,::Authorization:AutHeader:DtRlz7},;
			{ "DTRLZ8"		,::Authorization:AutHeader:DtRlz8},;
			{ "DTRLZ9"		,::Authorization:AutHeader:DtRlz9},;
			{ "DTRLZ1"		,::Authorization:AutHeader:DtRlz1},;
			{ "LODONTO"   ,::AutType==4 },;
			{ "TIPOCONFIRM",::Authorization:AutHeader:TipoConfirm},;
			{ "OBSGUI"		,::Authorization:AutHeader:Obs},;
			{ "ESPEXE"		,::Authorization:AutHeader:EspExe},;
			{ "PROTOC"		,::Authorization:AutHeader:Protoc},;
			{ "TIPADM"		,cTipAdm},;
			{ "GUIPRE"		,IIF (ValType(::Authorization:AutHeader:GuiPre) == "C", ::Authorization:AutHeader:GuiPre, "") },;  //// Numero 2-Guia Prestador na guia de Consulta via Portal do Prestador.
			{ "NUMDECIV"		,::Authorization:AutHeader:NumDecVivo},;
			{ "NUMDECOBT"		,::Authorization:AutHeader:NumDecObt},;
			{ "INDICRNV"		,::Authorization:AutHeader:IndicRN},;
			{ "HORINIFAT"		,::Authorization:AutHeader:HorIniFat},;
			{ "HORFIMFAT"		,::Authorization:AutHeader:HorFimFat} ,;
			{ "GUIPRE"		,IIF (ValType(::Authorization:AutHeader:GuiPre) == "C", ::Authorization:AutHeader:GuiPre, "") },;	 // Numero 2-Guia Prestador na guia de Consulta via Portal do Prestador.
			{ "RDACON"		,::Authorization:AutHeader:RdaCon },;  	//Rda solicitada contratante
			{ "DATPRVINT"   ,::Authorization:AutHeader:DatPre },;   //Data prevista de internação
			{ "TOKEDI"		,::Authorization:AutHeader:TokEdi },; 	//Token PTU Online
			{ "ADADB7B"     ,::Authorization:AutHeader:ADadB7B },; 	// Retorno do Ponto de Entrada PLB7BGRV
			{ "COBESPW"     ,::Authorization:AutHeader:CobEspNwS },; // Cobertura Especial r7
			{ "REGATDW"     ,::Authorization:AutHeader:RegAtdNwS },; // Regime de Atendimento
			{ "SADOCUW"     ,::Authorization:AutHeader:SaudOcNwS }}  //Saúde Ocupacional

		aadd(aDados, { "TIPACA"      , Alltrim(PLSVARVINC("49",, AllTrim(::Authorization:AutHeader:TpAcomPro))) })
		
		aDados := WsAutoOpc( aDados )

		//Itens da Guia
		BR8->( DbSetOrder(3) ) //BR8_FILIAL + BR8_CODPSA + BR8_CODPAD
		If ((::AutType == 5 .or. ::AutType == 6) .and. cTissVer >= "3")
			aTpPRec := {}
		EndIf

		For nI := 1 To Len( ::Authorization:AutItem )

			If ValType(cTissVer) <> 'U' .And. cTissVer >= '3'

				if ::Authorization:AutItem[nI]:ProcedureCode = "-1"

					if alltrim(cMvPlCdPro) = ""
						SetSoapFault( "", "Parâmetro MV_PLCDPRO não configurado. Entre em contato com a operadora.")
						Return .F.
					else
						::Authorization:AutItem[nI]:CodPad := SubStr(alltrim(cMvPlCdPro), 1, 2)
						::Authorization:AutItem[nI]:ProcedureCode := SubStr(alltrim(cMvPlCdPro), 3 )
					endif

				endif

				cCodPad := AllTrim(PLSVARVINC('87','BR4', ::Authorization:AutItem[nI]:CodPad))
				cCodPro := AllTrim(PLSVARVINC(::Authorization:AutItem[nI]:CodPad,'BR8',::Authorization:AutItem[nI]:ProcedureCode ,cCodPad+::Authorization:AutItem[nI]:ProcedureCode,,aTabDup,@CCODPAD))

				If 	!PChkTabDup(@cCodPad,cCodPro,::Authorization:AutItem[nI]:CodPad) .or. aErrVarVin[1] == .T.
					SetSoapFault( "", "De/Para não realizado para -> ("+cCodPad+") "+cCodPro )
					Return .F.
				EndIf

				BR8->(DbSetOrder(3))
				If !BR8->( MsSeek(xFilial("BR8")+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+cCodPad ))
					SetSoapFault( "", "Procedimento não encontrado na tabela padrao -> ("+cCodPad+") "+cCodPro )
					Return .F.
				EndIf

			Else
				cCodPad := ::Authorization:AutItem[nI]:CodPad
				cCodPro := ::Authorization:AutItem[nI]:ProcedureCode

				//Se entrou aqui, não fez o de-para, dái adicionamos no aCpoTermo pro
				AADD(aCpoTermo,{ "CODPAD", "87", "BR4"})
				AADD(aCpoTermo,{ "CODPRO", "",   "BR8"})

				If ValType(cTissVer) <> 'U'
					If !BR8->( MsSeek(xFilial("BR8")+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+cCodPad ))
						SetSoapFault( "", "Procedimento não encontrado na tabela padrao -> ("+cCodPad+") "+cCodPro )
						Return .F.
					EndIf
				EndIf

			Endif

			//Grau de Participação
			If ::AutType == 2 .OR. ((::AutType == 5 .OR. ::AutType == 6) .AND. cTissVer >= "3")

				If ::Origem == '1' .OR. (ValType(::DigitacaoGuia) == "C" .AND. ::DigitacaoGuia == "digitacao")

					aTpPRec := {}

					nLen := len(::Authorization:AutItem[nI]:GRPPAREXE)

					For nJ := 1 to nLen

						If (::AutType==5 .or. ::AutType==6) .and. cTissVer >= "3"

							cGrPar 	:= AllTrim(PLSVARVINC('35','BWT', ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:GrPar))
							cCbos 	:= AllTrim(PLSVARVINC('24','B0X', ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:Cbos))
							cSequen := ::Authorization:AutItem[nI]:Sequence
							cProfBB0:= ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:ProfExe

							BAU->( DbSetOrder(5) )//BAU_FILIAL + BAU_CODBB0
							If BAU->( MsSeek( xFilial("BAU")+cProfBB0 ) )

								cCpfExe := BAU->BAU_CPFCGC
								cNomProf:= BAU->BAU_NOME
								cNumCr 	:= BAU->BAU_CONREG
								cCodSig := BAU->BAU_SIGLCR
								cEstado := BAU->BAU_ESTCR
								cProfExe:= BAU->BAU_CODIGO

							Else

								//Não pode sobrescrever esses campos pois antes de gravar deve ser realizado o de-para.
								cCpfExe := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:CpfExe
								cNomProf:= ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:NomProf
								cNumCr 	:= ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:NumCr
								cCodSig := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:CodSig
								cEstado := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:Estado
								cNomProf:= ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:NomProf
								cProfExe:= ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:ProfExe
								cSequen := ::Authorization:AutItem[nI]:Sequence
							EndIf

						Else

							cGrPar 	 := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:GrPar
							cCbos  	 := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:Cbos
							cEspExe  := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:EspExe
							cCpfExe	 := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:CpfExe
							cNomProf := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:NomProf
							cNumCr 	 := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:NumCr
							cCodSig  := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:CodSig
							cEstado  := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:Estado
							cNomProf := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:NomProf
							cProfExe := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:ProfExe
							cProfBB0 := ::Authorization:AutItem[nI]:GRPPAREXE[nJ]:ProfExe
							cSequen  := ::Authorization:AutItem[nI]:Sequence
						EndIf

						AaDd( aTpPRec,{ cGrPar,;
							cCpfExe,;
							cNomProf,;
							cNumCr,;
							cCodSig,;
							cEstado,;
							cProfBB0,;
							.T.,;
							cProfExe,;
							cSequen,;
							cCbos,;
							cEspExe,;
							PlRetUnp( cGrPar)})

					Next nJ
				EndIf
			EndIf

			//Faz os de-para das terminologias
			If ValType(cTissVer) <> 'U' .And. cTissVer >= '3'

				cSlvPad := ::Authorization:AutItem[nI]:CodPad
				cSlvPro := ::Authorization:AutItem[nI]:ProcedureCode

				If ! Empty(::Authorization:AutItem[nI]:Dente)

					cDente := PLSVARVINC('42','B04',Alltrim(::Authorization:AutItem[nI]:Dente))

					If AllTrim(cDente) == AllTrim(::Authorization:AutItem[nI]:Dente)
						cDente := PLSVARVINC('28','B04',Alltrim(::Authorization:AutItem[nI]:Dente))
					EndIf

					cFace := PLSVARVINC('32','B09',::Authorization:AutItem[nI]:Face)

				EndIf

			Else
				cSlvPad     := ::Authorization:AutItem[nI]:CodPad
				cSlvPro     := ::Authorization:AutItem[nI]:ProcedureCode
				cCodPad		:= ::Authorization:AutItem[nI]:CodPad
				cCodPro		:= ::Authorization:AutItem[nI]:ProcedureCode
			Endif

			If Empty(cDente)
				cDente 	:= ::Authorization:AutItem[nI]:Dente
				cFace	:= ::Authorization:AutItem[nI]:Face
			EndIf

			//Atenção: Para cálculo correto dos valores provenientes do Portal, devemos considerar valor unitário e redução/acréscimo (Atendimento/Digitação off)
			if (::Authorization:AutItem[nI]:RedAcre > 0)
				nVlrApCar := ((::Authorization:AutItem[nI]:VlrApr) * (::Authorization:AutItem[nI]:RedAcre))
			else
				nVlrApCar := ::Authorization:AutItem[nI]:VlrApr
			endif

			If !(EmpTy(cCodPro))
				AaDd( aItens, { { "SEQMOV", ::Authorization:AutItem[nI]:Sequence },;
					{ "CODPRO", cCodPro },;
					{ "CODPAD", cCodPad },;
					{ "QTD"	  , ::Authorization:AutItem[nI]:ProcedureQuantity },;
					{ "QTDAUT", ::Authorization:AutItem[nI]:QtdAut },;
					{ "VLRAPR", nVlrApCar },;
					{ "RESAUT", ::Authorization:AutItem[nI]:ResAut },;
					{ "INDCLIEVO",::Authorization:AutItem[nI]:IndCliEvo },;
					{ "DENTE" , cDente },;
					{ "FACE"  , cFace },;
					{ "HORINI", ::Authorization:AutItem[nI]:HorIni },;
					{ "HORFIM", ::Authorization:AutItem[nI]:HorFim },;
					{ "VIAAC",  ::Authorization:AutItem[nI]:ViaAc },;
					{ "PERVIA",  plRtPerV(::Authorization:AutItem[nI]:ViaAc) },;
					{ "TECUT",  ::Authorization:AutItem[nI]:TecUt },;
					{ "REDAC",  ::Authorization:AutItem[nI]:RedAcre },;
					{ "ATPPAR", aTpPRec },;
					{ "STPROC", ::Authorization:AutItem[nI]:StProc } ,;
					{ "SLVPRO", cSlvPro } ,;
					{ "SLVPAD", cSlvPad } ,;
					{ "STPROC", ::Authorization:AutItem[nI]:StProc } ,;
					{ "DIAGNO", ::Authorization:AutItem[nI]:DiagPro },;
					{ "DATPRO", ::Authorization:AutItem[nI]:DatPro } } )

				aItens[nI] := WsAutoOpc( aItens[nI] )
			endIf

			cDente     := ""

		Next nI

		If ValType(cTissVer) <> 'U'
			PXMOVTISS(@aDados, @aItens, aCpoTermo)
		Else
			lRetorno := .F.
			SetSoapFault( "", "Usuário não autorizado" )
		EndIf

		if ! lDigiGuia

			cCaraterSol := self:Authorization:AutHeader:CarSol
			aRetorno := PLSXAUTP(aDados,aItens,cCaraterSol,,,lPortalMetric)

			//Chama novo processo de Inserção Utilizando MVC - Guias Offline
		else

			aRslTOFF	:= PLSXDIGO(aDados,aItens)
			aRetorno 	:= aRslTOFF[1] //aResultado esperado
			aCritMDF	:= aRslTOFF[2]
			lMudFasO	:= aRslTOFF[3]

			delClassIntF()

		endif

		lOk 		:= aRetorno[1]
		cNumAut 	:= aRetorno[2]

		if GetNewPar("MV_PLATURG",.F.)  .AND. self:Authorization:AutHeader:CarSol == '2'
			if( Len(aRetorno) >= 17)
				aRetorno[17] := .F.
			else
				lAud := .F.
			endif
		endIf

		lAud		:= Iif( Len(aRetorno) >= 17,aRetorno[17],.F.)

		//Controle para exibir a senha ou nao ou exibir somente na autorizacao ou liberacao ³
		If cMvPPM == "1"
			cSenhaAut 	:= AllTrim(aRetorno[3])
		ElseIf cMvPPM == "2" .And. ::Origem == '2'
			cSenhaAut 	:= AllTrim(aRetorno[3])
		ElseIf cMvPPM == "3" .And. ::Origem == '1'
			cSenhaAut 	:= AllTrim(aRetorno[3])
		EndIf

		If ! empty(aNaoAut)

			//Verificamos se é guia de consulta e se possui críticas da digitação off-line
			if allTrim( str(::AutType) ) == "1" .and. ( len(aCritMDF) > 0 .and. aCritMDF[1] .and. len(aCritMDF[3]) > 0 )

				PLSALERTA(aCriticas,aRetorno,aAlerta,aAut,aNaoAut,.T.,aCritMDF[3])

			else

				PLSALERTA(aCriticas,aRetorno,aAlerta,aAut,aNaoAut,(allTrim( str(::AutType) ) $ "1,2,3,11"))

			endIf

		else
			aCriticas   := aRetorno[4] //Critica
			aAut		:= aRetorno[5] //Eventos autorizados
			aNaoAut		:= aRetorno[6] //Eventos nao autorizados
		endIf

		if ::AutType == 11 .or. ::AutType == 3  //Se for prorrogação ou internação, verifica se não tem Procedimento negado com código igual (Critica 585)

			if len(aNaoAut) > 1

				For nFor:=1 To Len(aNaoAut)

					if len(aNaoAut) > 1 .and. len(aNaoAut) >= nFor

						cCodProComp := alltrim(aNaoAut[nFor][3])
						cCodPadComp := alltrim(aNaoAut[nFor][2])


						For nFor2 := (nFor + 1) To Len(aNaoAut)
							if len(aNaoAut) >= nFor2 .AND. alltrim(aNaoAut[nFor2][2]) = cCodPadComp .and. alltrim(aNaoAut[nFor2][3]) = cCodProComp
								ADel( aNaoAut, nFor2 )
								ASize( aNaoAut, Len(aNaoAut) - 1 )
							endif
						next

					endif

				next

			endif
		endif

		nVlrTotal	:= aRetorno[7] //Valor total da participacao

		::AutResponse 			:= WsClassNew( "AutResponseView" )
		::AutResponse:Number 	:= cNumAut
		::AutResponse:Password	:= cSenhaAut
		::AutResponse:VlrTotal 	:= nVlrTotal
		::AutResponse:MsgClient	:= aRetorno[9]  									  //Mensagem ao cliente (OBS)
		::AutResponse:Ato 		:= aRetorno[11]										  //Pagamento no Ato
		::AutResponse:DPrAH		:= Iif( Len(aRetorno) >= 12,aRetorno[12],CtoD("") ) //Data Prev. Inter. Aut
		::AutResponse:QtdDAut	:= Iif( Len(aRetorno) >= 13,aRetorno[13],'0' )		  //Diarias Autorizadas
		::AutResponse:DtValSen	:= Iif( Len(aRetorno) >= 14,aRetorno[14],CtoD("") ) //Validade da Senha
		::AutResponse:ProcRadio	:= Iif( Len(aRetorno) >= 16,aRetorno[16],.F.) 		//Descricao status da autorizacao BEA_STATUS
		::AutResponse:Audi		:= Iif( Len(aRetorno) >= 17,aRetorno[17],lAud) 		// Quando for menor do que 17 deve pegar o lAud
		::AutResponse:MudFasOff	:= lMudFasO

		//Criticas dos Procedimentos
		::AutResponse:Error := {}

		If ! Empty( aCriticas )

			For nI := 1 To Len( aCriticas )

				//Retira a informacao de nivel das criticas
				If At('nível',Lower(aCriticas[nI,3])) > 0
					Loop
				EndIf

				nCont++
				aAdd( ::AutResponse:Error, WsClassNew( "AutErrorView" ) )
				::AutResponse:Error[nCont]:Sequence := AllTrim( aCriticas[nI,1] )

				If !Empty( AllTrim(aCriticas[nI,2]) )
					aRet := PLSRETCRI( AllTrim( aCriticas[nI,2] ) )

					If EMPTY(aRet[1][2])
						aRet[1][1] := aCriticas[nI][2]
						aRet[1][2] := aCriticas[nI][3]
					EndIf
				Else
					aRet := {}
					AaDd( aRet, {"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" , AllTrim( aCriticas[nI,3] ) })
				EndIf

				::AutResponse:Error[nCont]:Code 			:= AllTrim( aRet[1,1] )
				::AutResponse:Error[nCont]:Description 		:= PadR( AllTrim(aRet[1,2]),75 )

			Next nI
		EndIf

		//Alertas do procedimento
		::AutResponse:Alerta := {}

		If ! Empty( aAlerta )

			nCont := 1

			AaDd( ::AutResponse:Alerta, WsClassNew( "AutErrorView" ) )

			::AutResponse:Alerta[nCont]:Sequence 	:= "Alerta"
			::AutResponse:Alerta[nCont]:Code		:= "<hr size='40' width='99%' align='center' noshade><br>" +;
				"<b>Alertas do Procedimento</b>"
			::AutResponse:Alerta[nCont]:Description := "<br>"

			For nI := 1 To Len( aAlerta )

				//Índices na digitação off-line de guia de consulta são diferentes
				if lDigiGuia .and. ALLTRIM(STR(::AutType)) == "1"

					//Retira a informacao de nivel das criticas
					If At('nível',Lower(aAlerta[nI,2])) > 0 .and. Empty(aAlerta[nI,1])
						Loop
					EndIf

					nCont++
					aAdd( ::AutResponse:Alerta, WsClassNew( "AutErrorView" ) )
					::AutResponse:Alerta[nCont]:Sequence := AllTrim( aAlerta[nI,1] )

					If !Empty( AllTrim(aAlerta[nI,1]) )
						aRet := PLSRETCRI( AllTrim( aAlerta[nI,1] ) )
					Else
						aRet := {}
						AaDd( aRet, {"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" , AllTrim( aAlerta[nI,3] ) })
					EndIf

					::AutResponse:Alerta[nCont]:Code 		:= AllTrim( aRet[1,1] )
					::AutResponse:Alerta[nCont]:Description := PadR( AllTrim(aRet[1,2]),75 )

				else

					//Guias de atendimento
					//Retira a informacao de nivel das criticas
					If At('nível',Lower(aAlerta[nI,3])) > 0
						Loop
					EndIf

					nCont++
					aAdd( ::AutResponse:Alerta, WsClassNew( "AutErrorView" ) )
					::AutResponse:Alerta[nCont]:Sequence := AllTrim( aAlerta[nI,1] )

					If !Empty( AllTrim(aAlerta[nI,2]) )
						aRet := PLSRETCRI( AllTrim( aAlerta[nI,2] ) )
					Else
						aRet := {}
						AaDd( aRet, {"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" , AllTrim( aAlerta[nI,3] ) })
					EndIf

					::AutResponse:Alerta[nCont]:Code 			:= AllTrim( aRet[1,1] )
					::AutResponse:Alerta[nCont]:Description 	:= PadR( AllTrim(aRet[1,2]),75 )
				endif
			Next nI
		EndIf

		//Críticas Off-Line aCritMDF
		if lDigiGuia .and. ! empty(aCritMDF) .and. len(aCritMDF[3]) > 0

			//Só irá tratar se tiver com primeiro elemento .F., isso significa que irá para conferência.
			if ! aCritMDF[1]

				//o Array com críticas começa no 3
				for nI := 3 to len(aCritMDF)

					aCrit := aCritMDF[nI]

					for nJ := 1 to len(aCrit)

						if ! empty(aCrit[nJ,1])

							nCont++

							aAdd( ::AutResponse:Error, WsClassNew( "AutErrorView" ) )

							::AutResponse:Error[nCont]:Sequence := AllTrim( aCrit[nJ,7] ) //Còdigo do Procedimento

							If (aCritMDF[nI,1,1] <> "")

							aRet := PLSRETCRI( allTrim( aCrit[nJ,1]),cTissVer )

							if empty(aRet[1][2])
								aRet[1][1] := aCrit[nJ][2]
								aRet[1][2] := "De-para não realizado"
							endIf

						endIf

						::AutResponse:Error[nCont]:Code 			:= AllTrim( aRet[1,1] )
						::AutResponse:Error[nCont]:Description 		:= PadR( AllTrim(aRet[1,2]),75 )
					endIf

				next

				next

			endIf

		endIf

		//Procedimentos Autorizados³
		::AutResponse:Authorized := {}

		If ! Empty( aAut )

			For nI := 1 To Len( aAut )

				aAdd( ::AutResponse:Authorized, WsClassNew( "AuthorizedView" ) )

				::AutResponse:Authorized[nI]:Sequence 		:= AllTrim( aAut[nI][1] )
				::AutResponse:Authorized[nI]:TableCode 		:= AllTrim( aAut[nI][2] )
				::AutResponse:Authorized[nI]:ProcedureCode	:= AllTrim( aAut[nI][3] )
			
				cDecode := PlDcCrcPrt(alltrim(aAut[nI][5]))
				::AutResponse:Authorized[nI]:Description	:= substr(UPPER(cDecode),1,40)

				::AutResponse:Authorized[nI]:Dente			:= AllTrim( aAut[nI][7] )
				::AutResponse:Authorized[nI]:Face			:= AllTrim( aAut[nI][8] )
				::AutResponse:Authorized[nI]:QtdTotal 		:= aAut[nI][4]
				::AutResponse:Authorized[nI]:Senha			:= aAut[nI][9]
				nTotUs := 0

				If  AllTrim( Str( ::AutType ) ) == '4'
					nTotUs := PLSRtQtdCH('',AllTrim(aAut[nI][2]),AllTrim(aAut[nI][3]),PLSINTPAD(),::Authorization:AutHeader:ProcedureDate)[1]
				Endif

				::AutResponse:Authorized[nI]:TotalUs       := nTotUs

			Next nI

		EndIf

		//Procedimentos Nao Autorizados³
		::AutResponse:NotAuthorized := {}

		If !Empty( aNaoAut )

			For nI := 1 To Len( aNaoAut )

				aAdd( ::AutResponse:NotAuthorized, WsClassNew( "AuthorizedView" ) )

				::AutResponse:NotAuthorized[nI]:Sequence 		:= AllTrim( aNaoAut[nI][1] )
				::AutResponse:NotAuthorized[nI]:TableCode		:= AllTrim( aNaoAut[nI][2] )
				::AutResponse:NotAuthorized[nI]:ProcedureCode 	:= AllTrim( aNaoAut[nI][3] )

				cDecode := PlDcCrcPrt(alltrim(aNaoAut[nI][5]))
				::AutResponse:NotAuthorized[nI]:Description		:= substr(UPPER(cDecode), 1,40)

				::AutResponse:NotAuthorized[nI]:Dente			:= AllTrim( aNaoAut[nI][7] )
				::AutResponse:NotAuthorized[nI]:Face			:= AllTrim( aNaoAut[nI][8] )
				::AutResponse:NotAuthorized[nI]:QtdTotal 		:= aNaoAut[nI][4]
				nTotUs := 0

				If  AllTrim( Str( ::AutType ) ) == '4'
					nTotUs := PLSRtQtdCH('',AllTrim(aNaoAut[nI][2]),AllTrim(aNaoAut[nI][3]),PLSINTPAD(),::Authorization:AutHeader:ProcedureDate)[1]
				Endif

				::AutResponse:NotAuthorized[nI]:TotalUs := nTotUs
			Next nI

			aAdd( ::AutResponse:NotAuthorized, WsClassNew( "AuthorizedView" ) )

			::AutResponse:NotAuthorized[Len( aNaoAut )+1]:ImpProc := cValToChar(GetNewPar("MV_PLNAUT",0))

		EndIf

		If nhEX > 0 .and. lEX
			PLSFECHASEM(nhEX, "EX_" + AllTrim(::Authorization:AUTHEADER:ReleaseNumber) + ".SMF")
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Usuário não autorizado" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DelGuia   ³Autor  ³ Alexander				³ Data ³20.05.2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de exclusao de guias								   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: [1] Codigo WS                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este retorna true ou falso                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ WEB SERVICES                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
/*
WSMETHOD DelGuia WSRECEIVE UserCode, NumAut WSSEND WSNULL WSSERVICE PLSXMOV

LOCAL lRetorno 	:= .T.
LOCAL aArea 	:= GetArea()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Valida																		³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXMOV", "DelGuia" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Matriz com as guias															³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lRetorno := PLSXEXCA(::NumAut)
	If !lRetorno
		SetSoapFault( "DelGuia", "Impossivel excluir guia" )
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "DelGuia", "Usuário não autorizado" )
EndIf

RestArea( aArea )

Return lRetorno
*/
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Para aparecer na lista na hora de gerar o pat								³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Function PLSMOVX
Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetVlrCo  ³Autor  ³ Alexander Santos      ³ Data ³02.02.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o valor da co-participacao						   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetVlrCo WSRECEIVE UserCode,NumAut WSSEND RetCoPar WSSERVICE PLSXMOV
	LOCAL lRet     	:= .T.
	LOCAL aArea	   	:= GetArea()
	LOCAL cExibeCo 	:= ""
	LOCAL cExibeBa 	:= ""
	LOCAL aVlrPF   	:= {}
	LOCAL aRet		:= {}
	LOCAL cMsg001	:= "Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg002	:= "Valor a ser pago direto a rede de atendimento&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg003	:= "Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg004	:= "Valor da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg005	:= "Valor da Taxa Administracao&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg006	:= "Valor Total da Co-Participacao&nbsp;R$:&nbsp;"
	LOCAL cMsg007	:= "Valor total a ser pago direto a rede de atendimento&nbsp;R$:&nbsp;"
	LOCAL cMsg008	:= "Valor Total da Co-Participacao&nbsp;R$:&nbsp;"
	LOCAL cMsg009	:= "Valor Total da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
	LOCAL cMsg010	:= "(*) Nao inclui valores de materiais e medicamentos.&nbsp;"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Checa rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXMOV", "GetVlrCo" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Tipo de pre atendimento				   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cExibeCo := GetNewPar("MV_PLSEXPF","1")
		cExibeBa := GetNewPar("MV_PLSEXBT","1")
		If cExibeCo == "1"
			BEA->( DbSetOrder(1) )//BEA_FILIAL + BEA_OPEMOV + BEA_ANOAUT + BEA_MESAUT + BEA_NUMAUT + DTOS(BEA_DATPRO) + BEA_HORPRO
			If BEA->( MsSeek( xFilial("BEA")+::NumAut ) )
				BD5->( DbSetOrder(1) )//BD5_FILIAL + BD5_CODOPE + BD5_CODLDP + BD5_CODPEG + BD5_NUMERO + BD5_SITUAC + BD5_FASE + dtos(BD5_DATPRO) + BD5_OPERDA + BD5_CODRDA
				If BD5->(MsSeek(xFilial("BD5")+BEA->(BEA_OPEMOV+BEA_CODLDP+BEA_CODPEG+BEA_NUMGUI)))
					aVlrPF := PLSVALCOPA()
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len(aVlrPF) > 0 .AND. aVlrPF[1] > 0
				::RetCoPar		  := WsClassNew( "SMatVlrCo" )
				::RetCoPar:ExibeCo := cExibeCo
				::RetCoPar:ExibeBa := cExibeBa
				::RetCoPar:GuiAco  := BEA->BEA_GUIACO
				::RetCoPar:VlrPF   := aVlrPF[1]
				::RetCoPar:VlrBPF  := aVlrPF[2]
				::RetCoPar:PercPF  := aVlrPF[3]
				::RetCoPar:VlrTPF  := aVlrPF[4]
				::RetCoPar:VlrTAD  := aVlrPF[5]
				::RetCoPar:PagRDA  := aVlrPF[6]
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Personalizacao das mensagens de co-participacao no portal pls		   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ExistBlock("PLSCOPGUI")
					aRet := ExecBlock("PLSCOPGUI")
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Mensagem customisada													  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Len(aRet) == 0
					aRet :=  {{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""}}
				EndIf
				::RetCoPar:Msg001 := Iif( aRet[1,1], Iif( Empty(aRet[1,2]) ,cMsg001,aRet[1,2] ), "" )
				::RetCoPar:Msg002 := Iif( aRet[2,1], Iif( Empty(aRet[2,2]) ,cMsg002,aRet[2,2] ), "" )
				::RetCoPar:Msg003 := Iif( aRet[3,1], Iif( Empty(aRet[3,2]) ,cMsg003,aRet[3,2] ), "" )
				::RetCoPar:Msg004 := Iif( aRet[4,1], Iif( Empty(aRet[4,2]) ,cMsg004,aRet[4,2] ), "" )
				::RetCoPar:Msg005 := Iif( aRet[5,1], Iif( Empty(aRet[5,2]) ,cMsg005,aRet[5,2] ), "" )
				::RetCoPar:Msg006 := Iif( aRet[6,1], Iif( Empty(aRet[6,2]) ,cMsg006,aRet[6,2] ), "" )
				::RetCoPar:Msg007 := Iif( aRet[7,1], Iif( Empty(aRet[7,2]) ,cMsg007,aRet[7,2] ), "" )
				::RetCoPar:Msg008 := Iif( aRet[8,1], Iif( Empty(aRet[8,2]) ,cMsg008,aRet[8,2] ), "" )
				::RetCoPar:Msg009 := Iif( aRet[9,1], Iif( Empty(aRet[9,2]) ,cMsg009,aRet[9,2] ), "" )
				::RetCoPar:Msg010 := Iif( aRet[10,1], Iif( Empty(aRet[10,2]) ,cMsg010,aRet[10,2] ), "" )
			Elseif Len(aVlrPF) > 0 .AND. aVlrPF[1] == 0
				::RetCoPar:VlrPF   := aVlrPF[1]
			EndIf
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	If Len(aVlrPF) > 0 .AND. aVlrPF[1] < 0
		lRet := .F.
		SetSoapFault( "", "Valor de Co-participação inválido" )
	EndIf

	RestArea( aArea )

Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    GravaAnexo  ³ Daher		           ³ Data ³27.02.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de inclusao Autorizacao                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: [1] Codigo WS                                         ³±±
±±³          ³ExpC2: [2] Codigo Operadora                                  ³±±
±±³          ³ExpC3: [3] Codigo Rede de Atendimento                        ³±±
±±³          ³ExpC4: [4] Codigo LOCAL de Atendimento                       ³±±
±±³          ³ExpO1: [5] Objeto Autorizacao                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o metodo foi avaliado com sucesso          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Este metodo inclui a autorizacao                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ WEB SERVICES                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GravaAnexo WSRECEIVE UserCode, CompanyCode, AutType, Authorization, Origem WSSEND AutResponse WSSERVICE PLSXMOV
	LOCAL aArea      := GetArea()
	LOCAL aDadB4A    := {}
	LOCAL aChaveGen  := {}
	LOCAL aCriticas	 := {}
	LOCAL aEventosNeg:= {}
	LOCAL aEventosAut:= {}
	LOCAL cConteudo  := ""
	LOCAL cDado		 := ""
	LOCAL lRet		 := .F.
	LOCAL cCodGloAud := '025'
	LOCAL lAuditoria := .F.
	LOCAL nI		 := 1
	LOCAL nCont		 := 0
	LOCAL nFor 		 := 1
	LOCAL cDecode 	 := NIL
	LOCAL aCabProc 	 := {}
	LOCAL aDadProc 	 := {}
	LOCAL cStatus    := ""
	LOCAL aRetAux	 := {}
	LOCAL lPortalMetric := .T.

	PRIVATE aAutForAnx := {}
	PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
	PRIVATE aErrVarVin := {.F., "", "", ""}

	If PrtChkUser( ::UserCode, "PLSXMOV", "PUTAUTHORIZATION" )

		cMatric := PPLTROMAT( Authorization:AutHeader:RegistrationNumber )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica matricula antiga ou atual										 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(cMatric)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona na familia													 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			BA3->( DbSetOrder(01) ) //BA3_FILIAL + BA3_CODINT + BA3_CODEMP + BA3_MATRIC + BA3_CONEMP + BA3_VERCON + BA3_SUBCON + BA3_VERSUB
			If !BA3->( MsSeek( xFilial("BA3")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC) ) )
				SetSoapFault( "", "Problema na transação familia não encontrada!" )
				Return .F.
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Via do cartao															 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Empty(Authorization:AutHeader:CardEdition)
				Authorization:AutHeader:CardEdition := AllTrim( Str(BA1->BA1_VIACAR) )
			EndIf
		Else
			SetSoapFault( "", "Problema na transação matricula não encontrada!" )
			Return .F.
		EndIf

		aRetAux := PLSXVLDCAL(dDataBase,PLSINTPAD(),.f.,"","")
		If !aRetAux[1]
			SetSoapFault( "", "Calendário de pagamento não encontrado!" )
			Return .F.
		Endif
		cDado := Authorization:AutHeader:GuiRef

		//aqui primeiro procuro nas guias de internacao
		BE4->(DbSetORder(2))//BE4_FILIAL+BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT
		If BE4->(dbSeek(xFilial("BE4")+padr(cDado,18)))
			cConteudo := BE4->BE4_CODOPE+BE4->BE4_CODLDP+BE4->BE4_CODPEG+BE4->BE4_NUMERO
			dDatAut := BE4->BE4_DTDIGI //PEGO A DATA DE DIGITACAO POIS O BE4_DATPRO 'E A DATA QUE O PACIENTE FOI INTERNADO
			cUsuari := BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC+BE4_TIPREG+BE4_DIGITO)
			lRet    := .T.
			cStatus := BE4->BE4_STATUS

			B4Q->( DbSetOrder(4)) //GUIREF
			IF (B4Q->(MsSeek(xFilial("B4Q") + BE4->BE4_CODOPE+BE4->BE4_ANOINT+BE4->BE4_MESINT+BE4->BE4_NUMINT)) )
				While !B4Q->(EOF())
					if B4Q->B4Q_GUIREF == BE4->BE4_CODOPE+BE4->BE4_ANOINT+BE4->BE4_MESINT+BE4->BE4_NUMINT
						cStatus := B4Q->B4Q_STATUS
					endif
					B4Q->(DbSkip())
				ENDDO
			EndIf

		Endif

		//aqui primeiro procuro nas guias de sadt
		BEA->(DbSetORder(1))//BEA_FILIAL+BEA_OPEMOV+BEA_ANOAUT+BEA_MESAUT+BEA_NUMAUT
		If !lRet .and. BEA->(dbSeek(xFilial("BEA")+padr(cDado,18)))
			cConteudo := BEA->BEA_OPEMOV+BEA->BEA_CODLDP+BEA->BEA_CODPEG+BEA->BEA_NUMGUI
			dDatAut := BEA->BEA_DATPRO
			cUsuari := BEA->(BEA_OPEMOV+BEA_CODEMP+BEA_MATRIC+BEA_TIPREG+BEA_DIGITO)
			lRet    := .T.
			cStatus := BEA->BEA_STATUS
		Endif

		// Busca por Senha. internacao
		BE4->( DbSetOrder(7) )//BE4_FILIAL+BE4_SENHA
		If !lRet .and. BE4->(dbSeek(xFilial("BE4")+padr(cDado,9)))
			cConteudo 		:= BE4->BE4_CODOPE+BE4->BE4_CODLDP+BE4->BE4_CODPEG+BE4->BE4_NUMERO
			dDatAut := BE4->BE4_DTDIGI //PEGO A DATA DE DIGITACAO POIS O BE4_DATPRO 'E A DATA QUE O PACIENTE FOI INTERNADO
			cUsuari := BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC+BE4_TIPREG+BE4_DIGITO)
			lRet    := .T.
			cStatus := BE4->BE4_STATUS
		Endif
		// Busca por Senha. sadt
		BEA->( DbSetOrder(14) )//BEA_FILIAL+BEA_SENHA
		If !lRet .and. BEA->(dbSeek(xFilial("BEA")+padr(cDado,9)))
			cConteudo := BEA->BEA_OPEMOV+BEA->BEA_CODLDP+BEA->BEA_CODPEG+BEA->BEA_NUMGUI
			dDatAut := BEA->BEA_DATPRO
			cUsuari := BEA->(BEA_OPEMOV+BEA_CODEMP+BEA_MATRIC+BEA_TIPREG+BEA_DIGITO)
			lRet    := .T.
			cStatus := BEA->BEA_STATUS
		Endif


		If Empty(cConteudo)
			SetSoapFault( "", "Guia referenciada infornmada nao encontrada!" )
			Return .F.
		Endif

		aDadUsr := PLSDADUSR(cMatric,"1",.F.,dDataBase,nil,nil,NIL)

		If ! aDadUsr[1]
			SetSoapFault( "", "Matricula informada nao permitida!" )
			Return .F.
		Endif

		aadd(aDadB4A,{"B4A_OPEMOV",PlsIntPad() })
		aadd(aDadB4A,{"B4A_REGANS",Authorization:AutHeader:REGANS })
		aadd(aDadB4A,{"B4A_GUIREF",Authorization:AutHeader:GUIREF })
		aadd(aDadB4A,{"B4A_DATPRO",dDatAut })
		aadd(aDadB4A,{"B4A_DATSOL",Authorization:AutHeader:ProcedureDate })
		aadd(aDadB4A,{"B4A_GUIOPE",'' })
		aadd(aDadB4A,{"B4A_MATANT",BA1->BA1_MATANT })
		aadd(aDadB4A,{"B4A_OPEUSR",BA1->BA1_CODINT })
		aadd(aDadB4A,{"B4A_CODEMP",BA1->BA1_CODEMP })
		aadd(aDadB4A,{"B4A_CONEMP",BA1->BA1_CONEMP })
		aadd(aDadB4A,{"B4A_SUBCON",BA1->BA1_SUBCON })
		aadd(aDadB4A,{"B4A_VERCON",BA1->BA1_VERCON })
		aadd(aDadB4A,{"B4A_VERSUB",BA1->BA1_VERSUB })
		aadd(aDadB4A,{"B4A_MATRIC",BA1->BA1_MATRIC })
		aadd(aDadB4A,{"B4A_TIPREG",BA1->BA1_TIPREG })
		aadd(aDadB4A,{"B4A_DIGITO",BA1->BA1_DIGITO })
		aadd(aDadB4A,{"B4A_NOMUSR",BA1->BA1_NOMUSR })
		aadd(aDadB4A,{"B4A_CANCEL",'0' })
		aadd(aDadB4A,{"B4A_PESO"  ,Authorization:AutHeader:PESO })
		aadd(aDadB4A,{"B4A_ALTURA",Authorization:AutHeader:ALTURA })
		aadd(aDadB4A,{"B4A_SUPCOR",Authorization:AutHeader:SUPCOR })
		aadd(aDadB4A,{"B4A_IDADE" ,Authorization:AutHeader:IDADE })
		aadd(aDadB4A,{"B4A_SEXO"  ,Authorization:AutHeader:SEXO })
		aadd(aDadB4A,{"B4A_NOMSOL",Authorization:AutHeader:NOMFSOL })
		aadd(aDadB4A,{"B4A_TELSOL",Authorization:AutHeader:TELFSOL })
		aadd(aDadB4A,{"B4A_EMASOL",Authorization:AutHeader:EMAFSOL })
		aadd(aDadB4A,{"B4A_TIPANE",If(::AutType==7,'2',If(::AutType==8,'1','3'))})
		aadd(aDadB4A,{"B4A_TIPGUI",strzero(::AutType,2)})
		aadd(aDadB4A,{"B4A_DATDIA",Authorization:AutHeader:DATDIA })
		aadd(aDadB4A,{"B4A_CIDPRI",Authorization:AutHeader:CIDPRI })
		aadd(aDadB4A,{"B4A_CIDSEC",Authorization:AutHeader:CID2 })
		aadd(aDadB4A,{"B4A_CIDTER",Authorization:AutHeader:CID3 })
		aadd(aDadB4A,{"B4A_CIDQUA",Authorization:AutHeader:CID4 })
		aadd(aDadB4A,{"B4A_DIAIMG",Authorization:AutHeader:DIAIMG })
		aadd(aDadB4A,{"B4A_ESTADI",Authorization:AutHeader:ESTADI })
		aadd(aDadB4A,{"B4A_TIPQUI",Authorization:AutHeader:TIPQUI })
		aadd(aDadB4A,{"B4A_ECOG"  ,Authorization:AutHeader:ECOG })
		aadd(aDadB4A,{"B4A_FINALI",Authorization:AutHeader:FINATD })
		aadd(aDadB4A,{"B4A_PLATER",Authorization:AutHeader:PLATER })
		aadd(aDadB4A,{"B4A_DIAGCH",Authorization:AutHeader:DIAGCH })
		aadd(aDadB4A,{"B4A_INFREL",Authorization:AutHeader:INFREL })
		aadd(aDadB4A,{"B4A_CIRURG",Authorization:AutHeader:CIRURG })
		aadd(aDadB4A,{"B4A_DATCIR",Authorization:AutHeader:DATCIR })
		aadd(aDadB4A,{"B4A_DATIRR",Authorization:AutHeader:DATIRR })
		aadd(aDadB4A,{"B4A_QUIMIO",Authorization:AutHeader:QUIMIO })
		aadd(aDadB4A,{"B4A_DATQUI",Authorization:AutHeader:DATQUI })
		aadd(aDadB4A,{"B4A_ANOPAG",aRetAux[4] })
		aadd(aDadB4A,{"B4A_MESPAG",aRetAux[5] })
		aadd(aDadB4A,{"B4A_JUSTTE",Authorization:AutHeader:JUSTTE })
		aadd(aDadB4A,{"B4A_OBSERV",Authorization:AutHeader:OBSERV })
		aadd(aDadB4A,{"B4A_NROCAM",Authorization:AutHeader:NROCAM })
		aadd(aDadB4A,{"B4A_DOSDIA",Authorization:AutHeader:DOSDIA })
		aadd(aDadB4A,{"B4A_DOSTOT",Authorization:AutHeader:DOSTOT })
		aadd(aDadB4A,{"B4A_NRODIA",Authorization:AutHeader:NRODIA })
		aadd(aDadB4A,{"B4A_ESPMAT",Authorization:AutHeader:ESPMAT })
		aadd(aDadB4A,{"B4A_NROCIC",Authorization:AutHeader:NROCIC })
		aadd(aDadB4A,{"B4A_CICATU",Authorization:AutHeader:CICATU })
		aadd(aDadB4A,{"B4A_INTCIC",Authorization:AutHeader:INTCIC })
		aadd(aDadB4A,{"B4A_AREA",Authorization:AutHeader:AREAIR })
		aadd(aDadB4A,{"B4A_DATPRE",Authorization:AutHeader:DATPRE })

		aadd(aDadB4A,{"B4A_TUMOR",Authorization:AutHeader:TUMOR })
		aadd(aDadB4A,{"B4A_NODULO",Authorization:AutHeader:NODULO })
		aadd(aDadB4A,{"B4A_METAST",Authorization:AutHeader:METAST })
		aadd(aDadB4A,{"B4A_DCICAT",Authorization:AutHeader:DCicAtu })
		aadd(aDadB4A,{"B4A_NOMSOC", BA1->BA1_NOMSOC })

		//se for radioterapia não tem itens, portanto não cria a estrutura cabeçalho e nem dos dados do procedimento
		If Len( Authorization:AutItem ) > 0
			aCabProc := PLSA09AHea(strzero(::AutType,2),'1')
			aDadProc := PLSA09AClB(aCabProc)
		EndIf

		aVetProc := {0}
		cAliasPro:= "B4C"

		aCabCri  := PLSA09HCHe()
		aDadCri  := PLSA09HClB(aCabCri)
		aVetCri  := {0}
		cAliasCri:= "BEG"

		aQtdBrw := {}
		For nI := 1 To Len( Authorization:AutItem )
			AaDd( aQtdBrw, { 	PADR(Authorization:AutItem[nI]:CODPAD,Len(BR8->BR8_CODPAD)),;
				PADR(Authorization:AutItem[nI]:PROCEDURECODE ,Len(BR8->BR8_CODPSA)),;
				Authorization:AutItem[nI]:PROCEDUREQUANTITY,;
				If(!Empty(Authorization:AutItem[nI]:DatPro),Authorization:AutItem[nI]:DatPro,Authorization:AutHeader:ProcedureDate),;
				'',;
				PADR('',Len(B04->B04_CODIGO)),;
				PADR('',Len(B09->B09_FADENT)),;
				strzero(val(Authorization:AutItem[nI]:SEQUENCE)+1,3) } )
		Next

		aDadCri := {}
		For nI:=1 to Len(Authorization:AutItem)
			cSequen := strzero(val(Authorization:AutItem[nI]:SEQUENCE)+1,3)

			cCodPad := AllTrim(PLSVARVINC('87','BR4', ::Authorization:AutItem[nI]:CodPad))
			cCodPro := AllTrim(PLSVARVINC(::Authorization:AutItem[nI]:CodPad,'BR8',::Authorization:AutItem[nI]:ProcedureCode ,cCodPad+::Authorization:AutItem[nI]:ProcedureCode,,aTabDup,@CCODPAD))


			If 	!PChkTabDup(@cCodPad,cCodPro,::Authorization:AutItem[nI]:CodPad) .or. aErrVarVin[1] == .T.
				SetSoapFault( "", "De/Para não realizado para -> ("+cCodPad+") "+cCodPro )
				Return .F.
			EndIf
			BR8->(DbSetOrder(3))
			If !BR8->( MsSeek(xFilial("BR8")+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+cCodPad ))
				SetSoapFault( "", "Procedimento não encontrado na tabela padrao -> ("+cCodPad+") "+cCodPro )
				Return .F.
			EndIf

			nQtdPro := Authorization:AutItem[nI]:PROCEDUREQUANTITY
			dDatPro := Authorization:AutHeader:ProcedureDate


			aRetFun := PLSAUTP(	dDatPro,'',cCodPad,cCodPro,nQtdPro,aDadUsr,0,{},"1",.F.,Authorization:AutHeader:CIDPRI,;
				.T.,"1",.F.,nil,nil,aRetAux[4],aRetAux[5],nil,nil,nil,.T.,;
				nil,nil,nil,nil,nil,nil,nil,nil,cSequen,nil,nil,"1",nil,.F.,NIL,NIL,NIL,nil,NIL,NIL,NIL,nil,nil,nil,nil,nil,;
				.F.,.T.,'S',NIL,aQtdBrw,nil,NIL,nil,nil,nil,.f.,'B4A',;
				nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,strzero(::AutType,2),nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,;
				nil,nil,nil,nil,cDado)

			aRet := aClone(aRetFun)
			lRet := aRet[1]
			lAuditoria := .F. //não é legal tira isso daqui..
			// Pega as criticas
			If ! lRet
				aHisCri 	:= aClone( aRet[2] )
				lAuditoria	:= Ascan( aHisCri,{|x| x[1] == cCodGloAud } ) > 0
				// Verifico se a critica deve colocar o procedimento em auditoria
				If !lAuditoria .And. Len(aHisCri) > 0
					If BCT->( FieldPos("BCT_AUDITO") ) > 0
						BCT->( DbSetOrder(1) )
						If BCT->( MsSeek( xFilial("BCT")+PlsIntPad()+aHisCri[1,1] ) )
							lAuditoria := Iif(BCT->BCT_AUDITO == "1",.T.,.F.)
						EndIf
					EndIf
				EndIf

				For nFor := 1 To Len(aHisCri)
					cCodGlo := aHisCri[nFor,1]
					cDesGlo := aHisCri[nFor,2]
					cCodMot := Iif(Len(aHisCri[nFor]) >= 9, aHisCri[nFor,9],"")
					cObsMot := Iif(Len(aHisCri[nFor]) >= 10, aHisCri[nFor,10],"")
					cPartci := Iif(Len(aHisCri[nFor]) >= 11, aHisCri[nFor,11],"")
					cUniMed := Iif(Len(aHisCri[nFor]) >= 12, aHisCri[nFor,12],"")

					If nI==1 .OR. Len(aDadCri) == 0 // se não colocar esse Len aqui vem posição 2 no nI ai da erro de array out of bounds no aDadCri
						P09ABlank(aDadCri,aCabCri,aVetCri)
					Endif
					aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_SEQUEN",aCabCri)] := cSequen
					aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_CODGLO",aCabCri)] := cCodGlo
					aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_DESGLO",aCabCri)] := cDesGlo
					aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_CODMOT",aCabCri)] := cCodMot
					aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_OBSMOT",aCabCri)] := cObsMot
					aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_PARTIC",aCabCri)] := cPartci
					aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_UNIMED",aCabCri)] := cUniMed

					AaDd( aCriticas,{cSequen,cCodGlo,cDesGlo,cCodPad,cCodPro,'',''} )

					If &(cAliasCri)->( FieldPos(cAliasCri+"_SEQCRI") ) > 0
						aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_SEQCRI",aCabCri)] := P09ASEQCRI(1)
					Endif

					nFor ++
					While nFor <= Len(aHisCri) .And. Empty(aHisCri[nFor,1])
						P09ABlank(aDadCri,aCabCri,aVetCri)
						aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_SEQUEN",aCabCri)] := cSequen
						aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_CODGLO",aCabCri)] := ""
						aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_DESGLO",aCabCri)] := aHisCri[nFor,2]
						aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_INFGLO",aCabCri)] := aHisCri[nFor,3]

						If &(cAliasCri)->( FieldPos(cAliasCri+"_SEQCRI") ) > 0
							aDadCri[Len(aDadCri)][PLRETPOS(cAliasCri+"_SEQCRI",aCabCri)] := P09ASEQCRI(1)
						Endif

						nFor ++
					Enddo
					nFor --
				Next
			Else
				//Não faz nada
			Endif

			If nI <> 1
				P09ABlank(aDadProc,aCabProc,aVetProc)
			Endif
			BR8->(DbSetOrder(1))
			BR8->(MsSeek(xFilial("BR8")+cCodPad+cCodPro))

			If !lRet
				aadd(aEventosNeg,{cSequen,cCodPad,cCodPro,nQtdPro,BR8->BR8_DESCRI,nQtdPro,'','',''})
			Else
				aadd(aEventosAut,{cSequen,cCodPad,cCodPro,nQtdPro,BR8->BR8_DESCRI,nQtdPro,'','',''})
			Endif
			aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_SEQUEN",aCabProc)] := cSequen
			aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_CODPAD",aCabProc)] := cCodPad
			aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_CODPRO",aCabProc)] := cCodPro
			aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_DESPRO",aCabProc)] := BR8->BR8_DESCRI

			If(PLRETPOS(cAliasPro+"_OPCAO",aCabProc )>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_OPCAO",aCabProc)]  := Authorization:AutItem[nI]:Opcao,nil)
			If(PLRETPOS(cAliasPro+"_QTDSOL",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_QTDSOL",aCabProc)] := Authorization:AutItem[nI]:PROCEDUREQUANTITY,nil)
			If(PLRETPOS(cAliasPro+"_VLRUNT",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_VLRUNT",aCabProc)] := Authorization:AutItem[nI]:VlrUnt,nil)
			If(PLRETPOS(cAliasPro+"_QTDPRO",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_QTDPRO",aCabProc)] := Authorization:AutItem[nI]:PROCEDUREQUANTITY,nil)
			If(PLRETPOS(cAliasPro+"_VLRUNA",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_VLRUNA",aCabProc)] := Authorization:AutItem[nI]:VlrUnt,nil)
			If(PLRETPOS(cAliasPro+"_REGANV",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_REGANV",aCabProc)] := Authorization:AutItem[nI]:RegAnv,nil)
			If(PLRETPOS(cAliasPro+"_REFMAF",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_REFMAF",aCabProc)] := Authorization:AutItem[nI]:RefMat,nil)
			If(PLRETPOS(cAliasPro+"_AUTFUN",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_AUTFUN",aCabProc)] := Authorization:AutItem[nI]:AutFun,nil)
			If(PLRETPOS(cAliasPro+"_VIAADM",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_VIAADM",aCabProc)] := Authorization:AutItem[nI]:ViaAdm,nil)
			If(PLRETPOS(cAliasPro+"_FREQUE",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_FREQUE",aCabProc)] := Authorization:AutItem[nI]:Freque,nil)
			If(PLRETPOS(cAliasPro+"_DATPRO",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_DATPRO",aCabProc)] := Authorization:AutItem[nI]:DatPro,nil)
			If(PLRETPOS(cAliasPro+"_IMGSTA",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_IMGSTA",aCabProc)] := If(lRet,"ENABLE","DISABLE"),nil)
			If(PLRETPOS(cAliasPro+"_STATUS",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_STATUS",aCabProc)] :=  If(lRet,"1","0"),nil)
			If(PLRETPOS(cAliasPro+"_AUDITO",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_AUDITO",aCabProc)] := If(lAuditoria,'1','0'),nil)
			If(PLRETPOS(cAliasPro+"_SALDO",aCabProc )>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_SALDO",aCabProc)]  := Authorization:AutItem[nI]:PROCEDUREQUANTITY,nil)
			If(PLRETPOS(cAliasPro+"_NIVEL",aCabProc )>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_NIVEL",aCabProc)]  := BR8->BR8_NIVEL,nil)
			If(PLRETPOS(cAliasPro+"_NIVAUT",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_NIVAUT",aCabProc)] := If(lRet,aRet[3],Space(03)),nil)
			If(PLRETPOS(cAliasPro+"_NIVCRI",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_NIVCRI",aCabProc)] := If(!lRet,aRet[3],Space(03)),nil)
			If(PLRETPOS(cAliasPro+"_CHVNIV",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_CHVNIV",aCabProc)] := If(Len(aRet)>=4 .And. ValType(aRet[4]) == "C",aRet[4],Space(60)),nil)
			If(PLRETPOS(cAliasPro+"_UNMED",aCabProc)>0,aDadProc[Len(aDadProc)][PLRETPOS(cAliasPro+"_UNMED",aCabProc)]   := Authorization:AutItem[nI]:UniMedC,nil)

		Next


		aRetorno := PLSA09AGRV(3,PlsIntPad(),'B4C','B4A','BEG',aDadB4A,aCabProc,aDadProc,aVetProc,aCabCri,aDadCri,aVetCri,;
			strzero(::AutType,2),dDataBase,aRetAux[4],aRetAux[5],aChaveGen,,,lPortalMetric)

		lOk 		:= aRetorno[1]
		cNumAut 	:= aRetorno[2]+aRetorno[3]+aRetorno[4]+aRetorno[5]
		cSenhaAut 	:= AllTrim(aRetorno[12])
		aAut		:= aEventosAut //Eventos autorizados
		aNaoAut		:= aEventosNeg //Eventos nao autorizados

		//Obj de Resposta
		::AutResponse 			:= WsClassNew( "AutResponseView" )
		::AutResponse:Number 	:= cNumAut
		::AutResponse:Password	:= cSenhaAut
		::AutResponse:VlrTotal 	:= 0
		::AutResponse:MsgClient	:= ''  		 //Mensagem ao cliente (OBS)
		::AutResponse:Ato 		:= .F.		 //Pagamento no Ato
		::AutResponse:DPrAH		:= CtoD("")  //Data Prev. Inter. Aut
		::AutResponse:QtdDAut	:= '0'		 //Diarias Autorizadas
		::AutResponse:DtValSen	:= CtoD("")  //Validade da Senha
		::AutResponse:Audi		:= Iif( Len(aRetorno) >= 9,aRetorno[9],.F.) 		//Auditoria
		If !(Len( Authorization:AutItem ) > 0)
			::AutResponse:StatAut	:= cStatus
			::AutResponse:Audi      := IIF(aChaveGen[4][2] == "1",.T.,.F.)
		endIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Criticas dos Procedimentos³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::AutResponse:Error := {}
		If !Empty( aCriticas )
			For nI := 1 To Len( aCriticas )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³Retira a informacao de nivel das criticas
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				If At('nível',Lower(aCriticas[nI,3])) > 0
					Loop
				EndIf

				nCont++
				aAdd( ::AutResponse:Error, WsClassNew( "AutErrorView" ) )
				::AutResponse:Error[nCont]:Sequence := AllTrim( aCriticas[nI,1] )

				If !Empty( AllTrim(aCriticas[nI,2]) )
					aRet := PLSRETCRI( AllTrim( aCriticas[nI,2] ) )
				Else
					aRet := {}
					AaDd( aRet, {"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" , AllTrim( aCriticas[nI,3] ) })
				EndIf

				::AutResponse:Error[nCont]:Code 			:= AllTrim( aRet[1,1] )
				::AutResponse:Error[nCont]:Description 		:= PadR( AllTrim(aRet[1,2]),75 )

			Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Procedimentos Autorizados³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::AutResponse:Authorized := {}
		If !Empty( aAut )
			For nI := 1 To Len( aAut )
				aAdd( ::AutResponse:Authorized, WsClassNew( "AuthorizedView" ) )
				::AutResponse:Authorized[nI]:Sequence 		:= AllTrim( aAut[nI][1] )
				::AutResponse:Authorized[nI]:TableCode 		:= AllTrim( aAut[nI][2] )
				::AutResponse:Authorized[nI]:ProcedureCode	:= AllTrim( aAut[nI][3] )

				cDecode := PlDcCrcPrt(alltrim(aAut[nI][5]))
				::AutResponse:Authorized[nI]:Description	:= substr(UPPER(cDecode), 1,40)

				::AutResponse:Authorized[nI]:Dente			:= AllTrim( aAut[nI][7] )
				::AutResponse:Authorized[nI]:Face			:= AllTrim( aAut[nI][8] )
				::AutResponse:Authorized[nI]:QtdTotal 		:= aAut[nI][4]
				::AutResponse:Authorized[nI]:Senha			:= aAut[nI][9]
				nTotUs := 0

				If  AllTrim( Str( ::AutType ) ) == '4'
					nTotUs := PLSRtQtdCH('',AllTrim(aAut[nI][2]),AllTrim(aAut[nI][3]),PLSINTPAD(),::Authorization:AutHeader:ProcedureDate)[1]
				Endif

				::AutResponse:Authorized[nI]:TotalUs       := nTotUs

			Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Procedimentos Nao Autorizados³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::AutResponse:NotAuthorized := {}
		If !Empty( aNaoAut )
			For nI := 1 To Len( aNaoAut )
				aAdd( ::AutResponse:NotAuthorized, WsClassNew( "AuthorizedView" ) )
				::AutResponse:NotAuthorized[nI]:Sequence 		:= AllTrim( aNaoAut[nI][1] )
				::AutResponse:NotAuthorized[nI]:TableCode		:= AllTrim( aNaoAut[nI][2] )
				::AutResponse:NotAuthorized[nI]:ProcedureCode 	:= AllTrim( aNaoAut[nI][3] )

				cDecode :=PlDcCrcPrt(alltrim(aNaoAut[nI][5]))
				::AutResponse:NotAuthorized[nI]:Description := substr(UPPER(cDecode), 1,40)

				::AutResponse:NotAuthorized[nI]:Dente			:= AllTrim( aNaoAut[nI][7] )
				::AutResponse:NotAuthorized[nI]:Face			:= AllTrim( aNaoAut[nI][8] )
				::AutResponse:NotAuthorized[nI]:QtdTotal 		:= aNaoAut[nI][4]
				nTotUs := 0

				If  AllTrim( Str( ::AutType ) ) == '4'
					nTotUs := PLSRtQtdCH('',AllTrim(aNaoAut[nI][2]),AllTrim(aNaoAut[nI][3]),PLSINTPAD(),::Authorization:AutHeader:ProcedureDate)[1]
				Endif

				::AutResponse:NotAuthorized[nI]:TotalUs := nTotUs
			Next nI
		EndIf
		lRetorno := .T.
	Else
		lRetorno := .F.
		SetSoapFault( "", "Usuário não autorizado" )
	Endif

	RestArea( aArea )

Return lRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} BackDigitacaoGuia

Retorna guia para fase de digitação

@author Rodrigo Morgon
@since 24/11/2015
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD BackDigitacaoGuia WSRECEIVE UserCode, NumAut, AutType WSSEND WSNULL WSSERVICE PLSXMOV

	LOCAL lRetorno 	:= .T.
	DEFAULT ::WSNULL 	:= ""

	If PrtChkUser( ::UserCode, "PLSXMOV", "BackDigitacaoGuia" )
		//Envia como parâmetro os recnos e o tipo das guias
		If PLSBACKGUI(::NumAut,::AutType)
			::WSNULL := "true|Guia foi retornada para fase de Digitação com sucesso!"
		Else
			::WSNULL := "false|Ocorreu um erro ao alterar a fase da(s) guia(s) para digitação!"
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Usuário não autorizado" )
	EndIf

Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} validaEspBaq
procura especialidade valida 

@author Daniel Silva Dia
@since 25/03/2025
@version P12
/*/
//-------------------------------------------------------------------

Function validaEspBaq(lvldEspPri,lVldDtBlo,cCodRda,cCodLoc,cCodEsp)

	local cSql := ""
	local lRet := .f.

	cSql := " SELECT BAX_CODESP FROM " + RetSqlName("BAX")
	cSql += "  WHERE BAX_FILIAL = '" + xFilial('BAX') + "'"
	cSql += "  AND BAX_CODIGO = '" + cCodRda + "'"
	cSql += "  AND BAX_CODINT = '" + PlsIntPad() + "'"
	cSql += "  AND BAX_CODLOC = '" + cCodLoc + "'"
	cSql += "  AND D_E_L_E_T_ = ' ' "

	if(lvldEspPri)
		cSql += " AND BAX_ESPPRI = '1'"
	elseif(lVldDtBlo)
		cSql += " AND ( BAX_DATBLO > '" + dtos(dDataBase) + "' OR  BAX_DATBLO = ' ' ) "
	endif 

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cSql)),"Trb",.T.,.F.)

	if ( !(Trb->(EoF())) )
		cCodEsp := Trb->(BAX_CODESP)
		lRet := .t.
	else 
		lRet := .f.
	endif

	Trb->(DbCloseArea()) 

return lRet



