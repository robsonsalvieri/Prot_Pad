#INCLUDE 'APWEBEX.CH'
#INCLUDE "APWEBSRV.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "AP5MAIL.CH"
#Include "topconn.ch"


WSSTRUCT SRetForm
	WSDATA Pagina			AS String OPTIONAL
	WSDATA Cmps			AS Array Of SCmps OPTIONAL
	WSDATA RetCmbs		AS Array Of SRetCmbs OPTIONAL
	WSDATA Grids			AS String OPTIONAL
	WSDATA ContGrid		AS Array Of AGrids OPTIONAL
ENDWSSTRUCT

WSSTRUCT AGrids
	WSDATA Grid			AS String
	WSDATA xCols         AS String OPTIONAL
	WSDATA xHeader       AS String OPTIONAL
	WSDATA ACols			AS Array Of SStrGrid
	WSDATA AHeader		AS Array Of SStrGrid
ENDWSSTRUCT

WSSTRUCT SStrGrid
	WSDATA Valores	   AS Array Of String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SRetCmbs
	WSDATA CampoG			AS String	OPTIONAL
	WSDATA CBOX			AS String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDataFrm
	WSDATA ChaveLay		AS String	OPTIONAL	
	WSDATA DadCombo		AS String OPTIONAL
	WSDATA RecnoReg     AS String OPTIONAL
	WSDATA DataAux      AS String OPTIONAL
	WSDATA TpPortWS		AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDataInput
	WSDATA ChaveLay		AS String		
	WSDATA Dados			AS Array Of SCmpVlr
	WSDATA Recnus			AS String OPTIONAL
	WSDATA RecnoReg      AS String OPTIONAL
	WSDATA UserLogin		AS String OPTIONAL
	WSDATA TpPortal		AS String OPTIONAL
	WSDATA Matric		AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT SCmpVlr
	WSDATA Tipo			AS String	OPTIONAL
	WSDATA Campo			AS String	OPTIONAL
	WSDATA Valor			AS String	OPTIONAL
	WSDATA Tabela			AS String	OPTIONAL
	WSDATA SeqGrid		AS String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SCmps
	WSDATA Tipo			AS String	OPTIONAL
	WSDATA Nome			AS String	OPTIONAL
	WSDATA Descri			AS String	OPTIONAL
	WSDATA CmpGrid		AS Array Of SCmpGrid OPTIONAL
	WSDATA aCols			AS Array Of String	OPTIONAL
	WSDATA aHeader		AS Array Of String	OPTIONAL
	WSDATA xCols			AS String	OPTIONAL
	WSDATA xHeader		AS String	OPTIONAL
	WSDATA Valid			AS String	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao do Web Service de Controle do Usuario                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSERVICE PLCADWEB	 				DESCRIPTION "Funções de criação e gerenciamento de layouts no portal"
	WSDATA RetForm					AS SRetForm OPTIONAL
	WSDATA UserCode					AS String
	WSDATA ChaveLay					AS String
	WSDATA DataForm					AS SDataFrm OPTIONAL
	WSDATA DataInput				AS SDataInput OPTIONAL
	WSDATA WSNULL					AS String
	WSDATA DataAux					As String
	WSDATA nome						As String 
	WSDATA MsgCrit					As String 
	WSDATA GrauPa					As String 
	WSDATA UserLGPD                 AS String OPTIONAL
	WSDATA RotinLGPD                AS String OPTIONAL

	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Metodo																   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	WSMETHOD VerifyStatus			DESCRIPTION "Verifica se o status deixa editar o Beneficiário"
	WSMETHOD GetCmbForm				DESCRIPTION "Cria a estrutura necessária para a utilização de dados da WEB nas combos dos layouts"
	WSMETHOD GetForm				DESCRIPTION "Cria o formulario dinamico em html"
	WSMETHOD GrvForm				DESCRIPTION "Grava os dados do formulario generico"
	WSMETHOD ValNomeBe				DESCRIPTION "Verifica se o nome está dentro do padrão de quantidade de caracteres" 
	WSMETHOD ValCodTit              DESCRIPTION "Retorna o código do titular configurado no sistema" 
	WSMETHOD LogLGPD                DESCRIPTION "Registra acesso do usuario conforme LGPD"
	WSMETHOD GetVldFam				DESCRIPTION "Verifica se a familia esta bloqueada."

ENDWSSERVICE

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função  VerifyStatus ³Autor  ³ Rafael Soares da Silva ³ Data ³08.04.2021³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o status deixa editar o Beneficiário	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VerifyStatus WSRECEIVE UserCode,DataForm WSSEND WSNULL WSSERVICE PLCADWEB
LOCAL lRetorno 	:= .T.

Default ::WSNULL := ""

If AllTrim(DataForm:CHAVELAY) == "PPLALTSOL"
	If PrtChkUser( ::UserCode , "PLCADWEB", "VerifyStatus" )

		BBA->(DbGoTo(Val(DataForm:RecnoReg)))
		If BBA->BBA_STATUS $ "1,2" .And. BBA->BBA_TIPMAN $ "1,2"
			Return lRetorno
		Else
			lRetorno := .F.
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf
EndIf

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetCmbFormT ³Autor  ³ Rogerio Machado Tabosa ³ Data ³01.02.2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os campos do TIpo Combo da GUIA dinamica do Portal	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetCmbForm WSRECEIVE UserCode,DataForm WSSEND RetForm WSSERVICE PLCADWEB

LOCAL lRetorno 	:= .T.
LOCAL aArea    	:= GetArea()
LOCAL nCmp			:= 0
LOCAL cCampo		:= ""
LOCAL cBOXRet		:= ""
LOCAL cFunc		:= ""
local cSql			:= ""

If PrtChkUser( ::UserCode , "PLCADWEB", "GetCmbForm" )
	//VARIÁVEL DE RETORNO
	::RetForm := WsClassNew( "SRetForm" )
	::RetForm:RetCmbs := {}
	
	B90->(DbSetOrder(2))
	If B90->(MsSeek(xFilial("B90")+DataForm:ChaveLay) )
		cSql := " SELECT B91_NOMXMO, B91_CBOX, B91_TIPO "
		csql += " FROM " + RetSqlName("B91") + " B91 "
		csql += " WHERE B91_FILIAL = '" + xFilial("B90") + "' "
		csql += " AND B91_SEQUEN = '" + B90->B90_SEQUEN + "' "
		csql += " AND B91_TIPO IN ('G', 'P') AND B91.D_E_L_E_T_ = ' ' " 
		
		csql := ChangeQuery(cSql)
		TcQuery csql New Alias "TabTmp"
		While !TabTmp->(EOF())
			cCampo 	:= AllTrim(TabTmp->B91_NOMXMO)
			cFunc		:= Alltrim(TabTmp->B91_CBOX)
			cBkpFunc := cFunc

			If "#" $ TabTmp->B91_CBOX
				cFunc := RIGHT(TabTmp->B91_CBOX, Len(TabTmp->B91_CBOX)-1)
				cFunc := &(cFunc)
			EndIf
			cBOXRet 	:=  cFunc

			//Adiciona o grid a estrutura
			AaDd( ::RetForm:RetCmbs, WsClassNew( "SRetCmbs" ) )
			nCmp := Len(::RetForm:RetCmbs)
			::RetForm:RetCmbs[nCmp]:CampoG := cCampo
			::RetForm:RetCmbs[nCmp]:CBOX := cBOXRet

			TabTmp->(DbSkip())
		EndDo
		TabTmp->(dbclosearea())
	endif
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetForm ³Autor  ³ Tabosa			           ³ Data ³06.03.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Monta formulario da guia no padrao da TISS configurado  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetForm WSRECEIVE UserCode,DataForm WSSEND RetForm WSSERVICE PLCADWEB

	Local lRetorno := .T.
	Local lContinua := .T.
	Local aArea := GetArea()
	Local cRecnoReg := ""
	Local cDataAux := ""
	Local oForm := Nil
	Local oTabPriFP := Nil
	Local oTabGrids := Nil
	Local oHtml := Nil
	Local RetFrm := NIL
	Local nI := 0
	Local cGrids := ""
	Local aCposRel := {}
	Local aGridOb := {}
	Local cDesGri := ""
	Local cFieldsOb	:= "" 
	Local cSeqGri := ""
	Local cAllField	:= ""
	Local cJsForm := ""
	Local cDadRelac	:= ""
	Local lTipGri := .F.
	Local cFuncGrv := ""
	Local cRecnus := ""
	Local cJsFAgain	:= ""
	Local aDadosTermo := {}
	Local cHtmlTermo := ""
	Local cVldComp   := ""
	Local oLieCon := Nil
	Local oFSLiCo := Nil
	Local oMenLiC := Nil
	Local oChkLiC := Nil
	Local oCHTMLc := Nil
	Local oTabTermo := Nil

	cRecnoReg := DataForm:RecnoReg 
	cDataAux  := DataForm:DataAux
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa Usuário														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode , "PLCADWEB", "GetForm" )
		//VARIÁVEL DE RETORNO
		::RetForm := WsClassNew( "SRetForm" )
		::RetForm:Cmps := {}
		::RetForm:ContGrid := {}

		//VARIAVEL QUE É MANIPULADA
		RetFrm := WsClassNew( "SRetForm" )
		RetFrm:Cmps := {}

		DbSelectArea("B7C")
		DbSelectArea("B90")
		DbSelectArea("B91")
		B7C->(DbSetOrder(2))
		B91->(DbSetOrder(2))	
		B90->(DbSetOrder(2))
		
		If B90->(MsSeek(xFilial("B91")+DataForm:ChaveLay) )	
			cFuncLoad := AllTrim(B90->B90_FUNLOA)
			//cFuncVoltar := AllTrim(BCL->BCL_PORVOL)		cFuncImp := AllTrim(BCL->BCL_PORIMP)
			cFuncGrv := AllTrim(B90->B90_FUNGRV)
			cJsFAgain := Alltrim(B90->B90_FNRELD)
			
			If AllTrim(Upper(DataForm:ChaveLay)) == "PPLALTBEN"
				cFuncVoltar := "frediinicio(true);"
			ElseIf AllTrim(Upper(DataForm:ChaveLay)) == "PPLALTSOL" .Or. AllTrim(Upper(DataForm:ChaveLay)) == "PPLALTB7L"
				cFuncVoltar := "fretAltSol(true);"
			EndIf

			If Empty(cFuncGrv)
				cFuncGrv := 'fProcForm(FrmLay);'
			EndIf                                     
		Else
			cFuncLoad	:= ""		
			cFuncImp 	:= ""
			cJsFAgain	:= ""
		EndIf

		//Vou varrer uma vez antes para pegar os relacionamentos e grids obrigatorios pois dentro do while do mntgrupo perde a referencia
		B7C->(DbSetOrder(2))
		If B7C->(MsSeek(xFilial("B7C")+B90->B90_SEQUEN) )
			While !B7C->(EOF()) .AND. xFilial("B7C")+B90->B90_SEQUEN == B7C->(B7C_FILIAL+B7C_SEQB90)
				If !Empty(cRecnoReg)
					If B7C->B7C_TIPO == "G" //significa que é grid e preciso criar a estrutura para carregá-lo na grid
						RetFrm:ContGrid :=  {}
					EndIf
					If !Empty(B7C->B7C_GRUPAI) .AND. !Empty(cRecnoReg)

						If B7C->(FieldPos("B7C_VALCMP")) > 0
							cVldComp := B7C->B7C_VALCMP
						EndIf

						SetFilhoPai(B7C->B7C_GRUPAI, B7C->B7C_ORDEM, @aCposRel, B7C->B7C_CHVIND, B7C->B7C_SEQB90, cVldComp )
					EndIf
				EndIf
				AADD(aCposRel, { B7C->B7C_ORDEM, B7C->B7C_TIPO, B7C->B7C_GRUPAI, B7C->B7C_NOMGRI, B7C->B7C_CPOREL , "" /* campo relac que ira preencher */, "" ,{}} )
				If B7C->B7C_TIPO == "G" .AND. B7C->B7C_OBRIGA
					AADD(aGridOb, {Alltrim(B7C->B7C_NOMGRI), Alltrim(B7C->B7C_DESCRI) } ) 
				EndIf
				B7C->(DbSkip())
			EndDo
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Cria a página 
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		oHtml := WCHtml():New()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Cria a função de confirmação do formulario
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		cJsForm += CRLF + "<script language='JavaScript'>" + CRLF
		cJsForm += "function fProcForm(formulario) {" + CRLF
		cJsForm += "   var lGrvFormGen = false; " + CRLF
		cJsForm += "   var lPertForm     = false;" + CRLF	
		cJsForm += "      if (!valida()) return;" + CRLF	
		cJsForm += "   RetiraDisable(); " + CRLF
		cJsForm += "   var cForm = formulario.innerHTML.toUpperCase(); " + CRLF	

		cJsForm += "   if ( (cForm.match(/PPLALTBEN/))) { " + CRLF
		cJsForm += "  		var cRet = VerifCampos(document.forms[0].elements,false,'');  " + CRLF
		cJsForm += "		if (document.getElementById('cHashCampos').value == cRet && cForm.match(/PPLALTBEN/)){" + CRLF
		cJsForm += "			modalBS('Atenção', 'Não houve alteração de dados.', '@Fechar~closeModalBS();window.frames[0].frediinicio(true);', 'white~#FABE3E');" + CRLF
		cJsForm += "			return;" + CRLF
		cJsForm +=	"		}; " + CRLF	
		cJsForm +=	"	};" + CRLF	
			
		cJsForm += "   if ( (cForm.match(/PLSALTRDAF/)) || (cForm.match(/PLSALTRDAJ/)) ) { " + CRLF
		cJsForm += "      lPertForm = true; " + CRLF	
		cJsForm += "      lGrvFormGen = veriatualizacoes(formulario); " + CRLF
		cJsForm += "   } " + CRLF
		cJsForm += "   if ( (!lGrvFormGen && lPertForm) ) { return; } " + CRLF	
		cJsForm += "      document.forms[0].action = 'W_PPLGRVGEN.APW';" + CRLF	
		For nI := 1 To Len(aGridOb)
			cJsForm += CRLF
			cJsForm += " if (typeof o" + aGridOb[nI,1] + " == 'string') { "  + CRLF 
			cJsForm += " 		alert('Informe pelo menos um item [" + aGridOb[nI,2] + "]!'); "  + CRLF
			cJsForm += " 		return; } "  + CRLF
		Next nI
		// Valida o Li e Concordo do Termo de Consentimento
		cJsForm += "   if ( (cForm.match(/PPLINCBEN/)) || (cForm.match(/PPLALTBEN/)) || (cForm.match(/PPLALTSOL/)) || (cForm.match(/PPLALTB7L/)) ) { " + CRLF
		cJsForm += "   		var CheckLiCon = document.getElementById('Field_CHKLICO'); " + CRLF
		cJsForm += "   		if (CheckLiCon != null){ " + CRLF			
		cJsForm += "		    if (!CheckLiCon.checked){" + CRLF
		cJsForm += "			    modalBS('Atenção', 'Para confirmar, é necessário marcar o campo Li e Concordo do Termo de Consentimento.', '@Fechar~closeModalBS();', 'white~#FABE3E');" + CRLF
		cJsForm += "			    return;" + CRLF
		cJsForm +="		        } " + CRLF
		cJsForm += "   		} " + CRLF		
		cJsForm += "   }; " + CRLF

		cJsForm += "   Ajax.send(formulario, {callback: CarregaProcForm,error: ExibeErro});" + CRLF	
		cJsForm += "}" + CRLF
			
		cJsForm += " function veriatualizacoes(form) {" + CRLF
		cJsForm += "    nQtdRegConfirma = 0;" + CRLF
		cJsForm += "    ContLinGenerico(true);" + CRLF
		cJsForm += "    var lRegistros =  (nQtdRegConfirma > nQtdRegAtual) ? true : false;" + CRLF
		cJsForm += "    for (var i=0; i<form.length; i++) {" + CRLF
		cJsForm += "       var el = form[i];" + CRLF
		cJsForm += "          if ( ('origValueP' in el.dataset && el.dataset.origValueP !== el.value) || lRegistros || lSalvAcionado ) {" + CRLF
		cJsForm += "              return true;" + CRLF
		cJsForm += "          }" + CRLF
		cJsForm += "    }" + CRLF
		cJsForm += "  modalBS('Atenção', 'Não houve alteração de dados.', '@Fechar~window.frames[0].frediinicio();', 'white~#FABE3E'); " + CRLF	
		cJsForm += "  return false;" + CRLF	
		cJsForm += "}" + CRLF
	
	/*
	AResult[0] - Texto da Mensagem ou em Branco para redirecionamento de página.
	AResult[1] - Botões se for mensagem ou Caminho da página se for redirecionamento
	AResult[2] - Desabilita ou não campos e botão da página.
	*/
		cJsForm += "function RetiraDisable() {" + CRLF
		cJsForm += " var aCmps = document.getElementById('cCampos').value.split(';')[1].split('|'); " + CRLF
		cJsForm += " for(var i = 0; i<aCmps.length - 1; i++){ " + CRLF
		cJsForm += " 		if(document.getElementById(aCmps[i]).disabled){ " + CRLF
		cJsForm += " 			document.getElementById(aCmps[i]).disabled = false; " + CRLF					
		cJsForm += " 		}" + CRLF
		cJsForm += "	}" + CRLF
		cJsForm += " }" + CRLF	
		
		cJsForm += "function CarregaProcForm(v) {" + CRLF
		cJsForm += " var aResult = v.split('|'); " + CRLF
		
		cJsForm += "	if (aResult.length == 1 || aResult.length == 3) " + CRLF
		cJsForm += "      modalBS('Atenção', aResult[0], (aResult.length == 3 ? aResult[1] : '@Fechar~closeModalBS();'), '', '', 'N' ); //alert(aResult[0]); " + CRLF //Roberto - Substituido por modal para permitir apresentar botões na mensagem após a validação.
		
		cJsForm += "	if (aResult.length == 2) " + CRLF
		cJsForm += "	 window.frames.location=aResult[1]; " + CRLF //W_PPLCADGEN.APW?cChave=PLSALTRDA&cRecno=" + cRecno;alert('Funcionou!  ' + aResult[1]); " + CRLF
		
		cJsForm += "  if (aResult.length != 3 || (aResult.length == 3 && aResult[2] == 'S')){  " + CRLF
		cJsForm += " setDisable('bconfirma',true); " + CRLF	
		cJsForm += " setDisable('bconfirmanovo',true); " + CRLF	
		cJsForm += "$('form :input').prop('disabled', true);" + CRLF
		cJsForm += "$('.infoBarBottom :input').prop('disabled', false);" + CRLF
		cJsForm += "$('form table').prop('class', $('form table').prop('class') + ' disabled');" + CRLF
		cJsForm += "$('form table img').attr('onclick', 'return false'); } " + CRLF
		cJsForm += "  }" + CRLF

		cJsForm += " function frediinicio(lVoltaSolic) {" + CRLF
		cJsForm += " 	var lVoltaSolic = (wasDef(typeof(lVoltaSolic))) ? lVoltaSolic : false;" + CRLF
		cJsForm += "    closeModalBS(); " + CRLF
		cJsForm += "    if (lVoltaSolic){ " + CRLF
		cJsForm += "    	window.location='W_PPLSOLMBEN.APW'; " + CRLF
		cJsForm += "    } else {; " + CRLF
		cJsForm += "    	window.location='W_PPLSW0C.APW'; " + CRLF
		cJsForm += " 	} " + CRLF
		cJsForm += " } " + CRLF

		cJsForm += " function fretAltSol(lVoltaSolic) {" + CRLF
		cJsForm += " 	var lVoltaSolic = (wasDef(typeof(lVoltaSolic))) ? lVoltaSolic : false;" + CRLF
		cJsForm += "    closeModalBS(); " + CRLF
		cJsForm += "    if (lVoltaSolic){ " + CRLF
		cJsForm += "    	window.location='W_PPLCONBEN.APW'; " + CRLF
		cJsForm += "    } else {; " + CRLF
		cJsForm += "    	window.location='W_PPLSW0C.APW'; " + CRLF
		cJsForm += " 	} " + CRLF
		cJsForm += " } " + CRLF

		cJsForm += " </script> " 

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Cria cabeçalho da página
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ	
		If !Empty(B90->B90_INCLJS) 
			::RetForm:Pagina := "true|" + oHtml:getDType(.T.,.T.,Alltrim(B90->B90_INCLJS), cJsForm)
		Else
			::RetForm:Pagina := "true|" + oHtml:getDType(.T.,.T.,"", cJsForm)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Formulario
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		oForm := WCForm():New("FrmLay")
		oForm:setWidth("800")
		oForm:setTitle(B90->B90_TITULO)

		//Funções e botões
		oForm:setJsFClick(cFuncGrv) // "fProcForm(FrmGuia); return false;")
		oForm:setFuncLoad(cFuncLoad)//("SADTLoad()")
		oForm:setFAgain(cJsFAgain)

		If Alltrim(Upper((B90->B90_CHAVE))) == "PPLALTBEN"
			oForm:setFback(cFuncVoltar)
		endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Tabela principal
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		oTabPriFP := WCTable():New("tabPrincipal")
		
		oTabGrids :=  WCTable():New("tabGrids")
		oTabGrids:setIsFolder()
			
		If !Empty(B90->B90_IMGUP )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Logo Institucional
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			oLiImgInst:= WCLine():new()
			oGrpImgInst := WCFieldSet():new("","770","100","100",.T.)
		
			oBLegBr := WCComponent():New("BI","bLegBr","Logo Institucional")
			oBLegBr:SetJsFunc("fLinkLogo();")	
			oBLegBr:setImgBtn("/" + B90->B90_IMGUP )
			oBLegBr:setHelpBtn("Logo Institucional")
			oBLegBr:setAlign('right')
			oBLegBr:setDisable()
			oBLegBr:setImgWidth("186")
			oBLegBr:setImgHeight("83")
			
			oGrpImgInst:setAddCFS(oBLegBr)
			oLiImgInst:setAddComp(oGrpImgInst)
			oTabPriFP:setAddLine(oLiImgInst)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Monta os Grupos de Campos e Campos da tela
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aReturn := MntGrupo(B90->B90_SEQUEN,,@oTabPriFP,@RetFrm,@oForm, DataForm:DadCombo, @cGrids, @cDesGri, @cAllField, @aCposRel, @oTabGrids, @cFieldsOb, @cSeqGri, cRecnoReg, @cRecnus, cDataAux)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Se for alteração, gravo o RECNO do registro principal
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !Empty(cRecnoReg)
			oForm:setAddFieldHidden("cRecnoReg",cRecnoReg)
		EndIf
		//Cria o campo que guarda os nomes e descrições dos grids
		oForm:setAddFieldHidden(alltrim('cGrids'),Alltrim(cGrids))
		oForm:setAddFieldHidden("cCampos",cAllField)
		oForm:setAddFieldHidden("cChvLay",Alltrim(B90->B90_CHAVE))
		oForm:setAddfieldHidden("cRecnus", cRecnus)
		oForm:setAddfieldHidden("cTPortWS", DataForm:TpPortWS)
		For nI := 1 To Len(aCposRel)
			If aCposRel[nI,2] == "G" .AND. !Empty(aCposRel[nI,6])
				cDadRelac += Alltrim(aCposRel[nI,4]) + "~" + Alltrim(aCposRel[nI,6]) + "~" + Alltrim(aCposRel[nI,7]) + ";"
			EndIf
			//B7C->B7C_ORDEM, B7C->B7C_TIPO, B7C->B7C_GRUPAI, B7C->B7C_NOMGRI, B7C->B7C_CPOREL
		Next nI
		oForm:setAddFieldHidden("cDadRelac",cDadRelac)

		lContinua := aReturn[1]

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Tabelas do form
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		oForm:setAddTables(oTabPriFP)
		oForm:setAddTables(oTabGrids)
		
		// Termo de Consentimento do Beneficiario para tratamento de dados pessoais (LGPD)	
		aDadosTermo := GetTermoDadosPessoais(DataForm:ChaveLay)
		If Len(aDadosTermo) > 0
			cHtmlTermo := MontaTermoConsentimento(aDadosTermo)

			oTabTermo := WCTable():New("tabTermoConsentimento")

			oLieCon := WCLine():New()
			oFSLiCo := WCFieldSet():New("Termo de Consentimento para Tratamento de Dados Pessoais", "800", "10", "10")

			oMenLiC := WCComponent():New("CHTM")
			oMenLiC:setValue("<div class='alert alert-info' id='infoGrid' style='display;'>" + cHtmlTermo + "</div>")
			oFSLiCo:setAddCFS(oMenLiC)

			oChkLiC := WCComponent():New("CHTM")
			oChkLiC:setValue("<input type='checkbox' value='' id='Field_CHKLICO'> Li e Concordo</input>")
			oFSLiCo:setAddCFS(oChkLiC)

			oCHTMLc	:= WCComponent():new('CHTM')
			oCHTMLc:setValue("<div id='EspacoBranco' style='height:50px;'></div>")

			oLieCon:setAddComp(oFSLiCo)
			oLieCon:setAddComp(oCHTMLc)      
			oTabTermo:SetAddLine(oLieCon)

			oForm:SetAddTables(oTabTermo)
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Form no HTML
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		oHtml:setObj(oForm)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Se deu tudo certo, retorna o HTML
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If lContinua
			::RetForm:Pagina += oHtml:loadWC()
			::RetForm:Cmps := aClone(RetFrm:Cmps)
			::RetForm:Grids	:= cGrids
			::RetForm:ContGrid := aClone(RetFrm:ContGrid)
		Else
			::RetForm := WsClassNew( "SRetForm" )
			::RetForm:Pagina := aReturn[2]
		EndIf

	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MntGrupo ³Autor  ³ Tabosa	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Monta grupo de campos              						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function MntGrupo(cSeqLay, cPai, oTabPriFP,RetForm,oForm, cDadCmb,cGrids,cDesGri, cFields, aCposRel, oTabGrids, cFieldsOb, cSeqGri, cRecnoReg,cRecnus,cDataAux)
LOCAL aReturn 		:= {.T.,""}
LOCAL aArea		:= B7C->(GetArea())
Local cAlias		:= ""
Local aDataAux		:= {}

LOCAL nI := 0
LOCAL nPosGru := 0

DEFAULT cPai		:= CriaVar("B7C_GRUPAI")
DEFAULT cFields		:= ""
DEFAULT aCposRel	:= {}
DEFAULT cDataAux	:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Varre a tabela de grupos de campos do portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
B7C->(DbSetOrder(2))
If !Empty(cSeqLay+cPai) .and. B7C->(MsSeek(xFilial("B7C")+cSeqLay+cPai) ) 
	While !B7C->(EOF()) .AND. xFilial("B7C")+cSeqLay+cPai ==;
				B7C->(B7C_FILIAL+B7C_SEQB90+B7C_GRUPAI)
		If dataForm:chaveLay == "PPLALTSOL"
			cAlias := B7C->B7C_ALIAS
		ElseIf dataForm:chaveLay == "PPLALTB7L"
			BBA->(DBGoTo(Val(cRecnoReg)))
			aadd(aDataAux,BBA->BBA_CODSEQ)
			B7L->(DBSetOrder(3))
			If B7L->(MsSeek(xFilial("B7L")+BBA->BBA_CODSEQ))
				BA1->(DbGoTo(Val(B7L->B7L_RECREG)))
				cRecnoReg := AllTrim(STR(BA1->(Recno())))
			EndIf
					
			cAlias := B7C->B7C_ALIAS
		Else
			cAlias := B7C->B7C_ALIAS
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Monta os campos do Grupo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If B7C->B7C_TIPO <> 'G'
			cFields += cAlias + ";"
			//Aqui eu posiciono a tabela caso seja uma alteração para carregar os dados no layout
			If Empty(Alltrim(B7C->B7C_GRUPAI)) .AND. !Empty(cRecnoReg)
				DbSelectArea(cAlias)
				&(cAlias + "->(DbGoto(" + cRecnoReg + "))")

				//executo a macro da chave informada caso o cabeçalho possua registros filhos
				If (nPosGru := aScan( aCposRel , {|x| AllTrim(x[1]) == B7C->B7C_ORDEM } )) > 0
			  		For nI := 1 to len(aCposRel[nPosGru,8])
			  			If !Empty(aCposRel[nPosGru,8,nI,2]) 
			   				aAdd(aCposRel[nPosGru,8,nI,3], &( Separa( aCposRel[nPosGru,8,nI,2], "|" )[1] ) )
			   			EndIf
			   		Next nI 
				EndIf	
			
			EndIf				
		EndIf
		MntCampo(cSeqLay,cPai,@oTabPriFP,@RetForm,@oForm, cDadCmb, @cGrids,@cDesGri, @cFields, @aCposRel, @oTabGrids, @cFieldsOb, @cSeqGri, cRecnoReg, @cRecnus, cAlias, Iif(dataForm:chaveLay == "PPLALTB7L", aDataAux, nil))

		B7C->(DbSkip())
	EndDo
Else
	aReturn[1] := .F.
	aReturn[2] := "<b>Não existem campos configurados para o layout <br>"
EndIf

RestArea( aArea )

Return aReturn

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MntCampo ³Autor  ³ Tabosa	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o procedimento e valido						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function MntCampo(cSeqLay, cPai, oTabPriFP,RetForm,oForm, cDadCmb,cGrids,cDesGri, cFields, aCposRel, oTabGrids, cFieldsOb, cSeqGri, cRecnoReg, cRecnus, cAlias, aDataAux)
LOCAL cTamanho  := ""
LOCAL nOrdem	:= Val(B7C->B7C_ORDEM)
LOCAL nCmp		:= 0
LOCAL cBtn			:= ""
LOCAL cBtnS	    := ""
LOCAL nI			:= 0
LOCAL nJ          := 0
LOCAL nK			:= 0
LOCAL nW          := 0
LOCAL nOrdemOld 	:= "0"
LOCAL aArSess   	:= {}
LOCAL aArAux		:= {}
LOCAL aCmbs 		:= {}
LOCAL lCpoRelac	:= .F.
LOCAL cTpField	:= ""
LOCAL nPosRel		:= 0
LOCAL lCboxPes	:= .F.
LOCAL aConteudo  := {}
LOCAL cValCar		:= ""
LOCAL aCposGri    := {}
LOCAL nPosGru     := 0
LOCAL nPosGrd     := 0
LOCAL nPosGrd2    := 0
LOCAL nPosCmp     := 0
LOCAL aArrRel     := {}
LOCAL aCols       := {}
LOCAL aAux        := {}
LOCAL aHeader     := {}
LOCAL nPos        := 0
LOCAL nPosVirtua  := 0
LOCAL xConteudo   := ""
LOCAL nTamConGri  := 0
LOCAL nTamAcols   := 0
LOCAL nTamAheader := 0
LOCAL nTamStrVal  := 0
LOCAL nCountReg   := 0
LOCAL nNumAux     := 0
Local nB7LAux	  := 0

LOCAL cRelAux     := ""
LOCAL cSql		  := ""
LOCAL aCmbsRel    := {}
LOCAL aCmpsVirtua := {}
LOCAL AB7LAUX	  := {}
LOCAL lB7L		  := .F.
Local cMacroComp  := ""

Default cDesGri	  := ""
Default cFieldsOb := ""
Default cSeqGri   := ""
Default cAlias	  := ""
Default aCposRel  := {}
Default aDataAux  := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Cria nova Linha
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
&("oLi"+ B7C->B7C_ORDEM ):= WCLine():new()
&("oLi"+ B7C->B7C_ORDEM ):setHGroup()
&("oLi"+ B7C->B7C_ORDEM ):setNomeHGr(Alltrim(B7C->B7C_VARGRU))
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Cria o grupo fieldset
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
cGrupo := "oFS" + B7C->B7C_ORDEM
&(cGrupo) := WCFieldSet():new(B7C->B7C_DESCRI,"770","10","10")

oCHTM	:= WCComponent():new('CHTM')
	//oCHTM:setValue("<div id='iframeDiv' style='display:none'><iframe id='upload_Anexo' style='width:100%;height:550px;overflow-y:scroll;border:none;'></iframe></div>")
oCHTM:setValue("<div id='iframeDiv' style='display:none'></div>")
&(cGrupo):setAddCFS(oCHTM) 
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Varre os campos do grupo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
If B91->(MsSeek(xFilial("B91")+cSeqLay+B7C->B7C_ORDEM ) )
	While !B91->(EOF()) .AND. xFilial("B91")+cSeqLay+B7C->B7C_ORDEM ==;
			B91->(B91_FILIAL+B91_SEQUEN+B91_GRUPO)
		nPosRel := 0
		aArrRel := {}
		//Se o campo não tiver nome de variável nem tipo vai para o próximo...
		If Empty(B91->B91_NOMXMO) .OR. Empty(B91->B91_TIPO)
			FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01', "Campo: " + noAcento(Alltrim(B91->B91_DESCRI)) + ", sem variavel ou tipo atribuido!" , 0, 0, {})
			B91->(DbSkip())
			Loop
		EndIf
		//Adiciona campo Hidden quando no cadastro do Layout Genérico Estiver marcado com Não Visual e váriavel que representa o campo estiver iniciando com h
		If !B91->B91_VISUAL .and. B91->B91_TIPO = 'O'//SUBSTR(B91->B91_NOMXMO,1,1) = 'h'
			oForm:setAddFieldHidden(alltrim(B91->B91_NOMXMO), "000000")
			cFields += Alltrim(B91->B91_NOMXMO) + "|"
		endif
		// Se nao for visual nao exibe na pagina
		If !B91->B91_VISUAL
			B91->(DbSkip())
			Loop
		EndIf
		If !Empty(B91->B91_INIPAD)
			oForm:setAddFieldHidden(alltrim('aInipad'+B91->B91_NOMXMO),Alltrim(B91->B91_INIPAD))
		EndIf
		cCampo := AllTrim("oCmp"+B91->B91_NOMXMO)
		cDescri := iif(B7C->B7C_TIPO == "G" .AND. B91->B91_TIPO == "S", '<mark class="markInv">CMPSEQ*</mark>'+ Alltrim(B91->B91_DESCRI), Alltrim(B91->B91_DESCRI ) )
		cNome := AllTrim(B91->B91_NOMXMO)

		//Contador de campos
		nCmp := Len(RetForm:Cmps)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Alimenta a Struct que servirá de guia na página
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If B7C->B7C_TIPO == 'G'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Adiciona o grid a estrutura
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If !Empty(B7C->B7C_GRUPAI) .AND. !Empty(cRecnoReg) .AND. B91->B91_VISUAL
				aAdd(aCposGri, {cAlias, B91->B91_CAMPO, cDescri, B91->B91_NOMXMO})
			EndIf
			
			If B91->B91_VIRTUA .AND. !Empty(cRecnoReg) //só preciso carregar os campos quando for alteração, e só é alteração quando temos o recno do cabeçalho
				aAdd(aCmpsVirtua, {B91->B91_CAMPO, allTrim(B91->B91_POSICI)})
			EndIf

			If !Empty(B7C->B7C_NOMGRI)
				cGrid := AllTrim(B7C->B7C_NOMGRI)
			Else
				cGrid := "Brw" + B7C->B7C_ORDEM
			EndIf
			If nCmp == 0 .OR. nOrdemOld <> B91->B91_GRUPO
				nCmp++
				nK := 1
				AaDd( RetForm:Cmps, WsClassNew( "SCmps" ) )
				RetForm:Cmps[nCmp]:Tipo := 'G'
				RetForm:Cmps[nCmp]:Nome := cGrid
				RetForm:Cmps[nCmp]:Descri := ""
				RetForm:Cmps[nCmp]:CmpGrid := {}
				RetForm:Cmps[nCmp]:aCols := {}
				RetForm:Cmps[nCmp]:aHeader := {}
				RetForm:Cmps[nCmp]:xCols := ""
				RetForm:Cmps[nCmp]:xHeader := ""

				oForm:setGlobalVar("o"+cGrid)

				//Prepara variável que seja passada para o JS com os campos do Grid
				If !Empty(cGrids)
					cGrids += "@"
				EndIf
				cGrids += cGrid + "~" + cAlias + "~"
				//cGrids += "'" + cGrid + "'~"

			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Adiciona os campos da Grid
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			AaDd( RetForm:Cmps[nCmp]:CmpGrid, WsClassNew( "SCmpGrid" ) )
			RetForm:Cmps[nCmp]:CmpGrid[nK]:Tipo := B91->B91_TIPO
			RetForm:Cmps[nCmp]:CmpGrid[nK]:Nome := cNome
			RetForm:Cmps[nCmp]:CmpGrid[nK]:Descri := cDescri
			nK++
			nOrdemOld := B91->B91_GRUPO
			
			cGrids += cNome + ","
			cDesGri += Alltrim(cDescri) + ","
			If B91->B91_OBRIGA
				cFieldsOb += Alltrim(B91->B91_NOMXMO) + ","
			EndIf
			If B91->B91_TIPO == "S" .AND. EMPTY(B91->B91_DADSRV) .AND. B91->B91_VISUAL
				cSeqGri += Alltrim(B91->B91_NOMXMO) + "|" + str(TamSX3(B91->B91_CAMPO)[1]) + ","
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Adiciona os campos
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			nCmp++
			AaDd( RetForm:Cmps, WsClassNew( "SCmps" ) )

			RetForm:Cmps[nCmp]:Tipo := B91->B91_TIPO
			RetForm:Cmps[nCmp]:Nome := cNome
			RetForm:Cmps[nCmp]:Descri := cDescri
			RetForm:Cmps[nCmp]:CmpGrid := {}
			cFields += Alltrim(cNome) + "|"
		EndIf

		//Recupera tamanho do campo
		If Len(cDescri) > B91->B91_TAMANH
			cTamanho := STR(Len(cDescri))
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Monta os objetos HTML
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		cTpField := B91->B91_TIPO
		cRelAux := ""
		If !Empty(B91->B91_VARREL)			 
			If GetTpGPai(B7C->B7C_GRUPAI, @aCposRel , Alltrim(B91->B91_NOMXMO), Alltrim(B91->B91_VARREL)) == 'G' // se o grupo que tem o dado relacinado for um grid monta uma combo se não monta um field 
				cTpField := "G"
					
				//verifico se existe grupo pai e se o recno não está vazio pq ai é alteração 
				If !Empty(Alltrim(B7C->B7C_GRUPAI)) .AND. !Empty(cRecnoReg)
					//acho onde está o grupo pai no array
					If (nPosGru := aScan( aCposRel , {|x| AllTrim(x[1]) == B7C->B7C_GRUPAI} )) > 0
						//acho o filho dentro do pai
						If (nPosGrd := aScan( aCposRel[nPosgru,8] , {|x| allTrim(x[1]) == B7C->B7C_ORDEM } )) > 0
						// agora preciso verificar se o campo está dentro do pai para preencher o array da combo	
							If ( Len(aCposRel[nPosGru,8,nPosGrd, 4]) > 0 )
								If(nPosCmp := aScan( aCposRel[nPosGru,8,nPosGrd, 4] , {|x| allTrim(x[1]) == alltrim(B91->B91_CAMPO) } )) > 0
									For nI := 1 to Len(aCposRel[nPosGru,8,nPosGrd, 4, nPosCmp, 4])
										//adiciono a opção para o combobox
										aAdd(aArrRel, aCposRel[nPosGru,8,nPosGrd, 4, nPosCmp,4, nI])
										cRelAux += aCposRel[nPosGru,8,nPosGrd, 4, nPosCmp,4, nI] + ";"
									Next nI
									
									If RIGHT(cRelAux, 1) == ";" //tiro o ; final 
										cRelAux := left(cRelAux, (len(cRelAux)-1))
									EndIf
									
									If len(aArrRel) > 0
										aAdd(aCmbsRel, alltrim(B91->B91_NOMXMO)+";"+cRelAux)
									EndIf
									
									cRelAux := ""
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
				
				
				
				//NESSE MOMENTO PREENCHO O ARRAY
			Else
				cTpField := "C"
			EndIf
		ElseIf cTpField == "S" // aqui eu mudo para caracter para criar o componente
			cTpField := "C"	
		EndIf
		
		Do Case
			//C=Texto;M=Memo;G=Combo;N=Numerico                                                                                               
			Case cTpField == 'C'			
				&(cCampo) := WCComponent():new("F",cNome,cDescri,Alltrim(cTamanho),Alltrim(STR(B91->B91_TAMANH)),B91->B91_OBRIGA)				
			Case cTpField == 'F' // Tipo File
				If B91->B91_MAXLEN > 0
					&(cCampo) := WCComponent():new("F",cNome,cDescri,Alltrim(STR(B91->B91_TAMANH)),Alltrim(STR(B91->B91_MAXLEN)),B91->B91_OBRIGA)
				Else
					&(cCampo) := WCComponent():new("F",cNome,cDescri,Alltrim(cTamanho),Alltrim(STR(B91->B91_TAMANH)),B91->B91_OBRIGA)
				EndIf
				&(cCampo):setType("file") // Falo que é do tipo file
	
			Case cTpField == 'M'
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ Insere objeto do tipo TEXTAREA
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				&(cCampo) := WCComponent():new("TA",cNome,cDescri,'500',STR(B91->B91_TAMANH))
	
			Case cTpField == 'G' .OR. cTpField == 'P'
				cTamanho := Alltrim(B91->B91_TAMANH)
				lCboxPes := IIF(cTpField == 'P',.T.,.F.)

				aArSess 	:= {}
				aCmbs 	:= {}
				aArAux		:= {}
				If ValType(cDadCmb) <> 'U'
					aCmbs := StrToArray(cDadCmb, "|")
				EndIf
				&(cCampo) := WCComponent():new("C",cNome,cDescri,cTamanho,Alltrim(STR(B91->B91_TAMANH)),B91->B91_OBRIGA,.f.,,,,,,,,lCboxPes)
				&(cCampo):setCboxPes(lCboxPes)
				For nI := 1 To Len(aCmbs)
					If  Alltrim(B91->B91_NOMXMO) $ aCmbs[nI] .AND. ";" $ aCmbs[nI]
						aArAux := Separa(aCmbs[nI], ";")
						Exit
					EndIf
				Next nI
				
				cRelAux := ""
				For nI := 2 To Len(aArAux) // Começa a partir da segunda posição pois a primeira eh o nome do campo
					AADD(aArSess, aArAux[nI])
					cRelAux += aArAux[nI]
					cRelAux += ";"
				Next			

				If RIGHT(cRelAux, 1) == ";" //tiro o ; final 
					cRelAux := left(cRelAux, (len(cRelAux)-1))
				EndIf
									
				aAdd(aCmbsRel, alltrim(B91->B91_NOMXMO)+";"+cRelAux)
	
				If !Empty(aArSess)
					&(cCampo):setArrCombo(aArSess)
				EndIf
				
				If !Empty(aArrRel)
					&(cCampo):setArrCombo(aArrRel)
				EndIf
	
				&(cCampo):setIsName()
			Case cTpField == 'N'			
				&(cCampo) := WCComponent():new("F",cNome,cDescri,Alltrim(cTamanho),Alltrim(STR(B91->B91_TAMANH)),B91->B91_OBRIGA)				
				If (B91->B91_EDITAR)
					&(cCampo):setNumber(.T.)
				EndIf
			Case cTpField == 'D'			
				&(cCampo) := WCComponent():new("F",cNome,cDescri,Alltrim(cTamanho),Alltrim(STR(B91->B91_TAMANH)),B91->B91_OBRIGA)
				If (B91->B91_EDITAR)
					&(cCampo):setData(.T.)
				EndIf
		EndCase

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Seta as propriedades comuns dos campos
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !Empty(Alltrim(B91->B91_INIPAD))
			cIniPad := AllTrim(B91->B91_INIPAD)
			If B91->B91_TIPO == 'G'
				&(cCampo):setDefCB(cInipad)
			EndIf		
			&(cCampo):setValue(cIniPad)
			
		EndIf
		
		If B7C->B7C_TIPO == "G" .AND. B91->B91_TIPO == "S"
			&(cCampo):setCssDiv("hideCmp")
		EndIf
		//ele tem que ficar aqui do lado de fora pois o usuario pode criar um inicializador novo, dai la no jsusr.pls eu ja coloquei todos campos do grid
		//oForm:setAddFieldHidden(alltrim('aInipad'+B91->B91_CAMPO),Alltrim(B91->B91_INIPAD))
		If !Empty(B91->B91_INIPAD)
			oForm:setAddFieldHidden(alltrim('aInipad'+B91->B91_NOMXMO),Alltrim(B91->B91_INIPAD))
		EndIf
		If lCpoRelac // Campo de relacionamento é somente leitura 
			&(cCampo):setReadOnly()
		EndIf
		If !(B91->B91_EDITAR)
			&(cCampo):setReadOnly()
		&(cCampo):setDisable()
		EndIf

		If !Empty(Alltrim(B91->B91_KEYPRE))
			&(cCampo):setJSKeyPre(alltrim(B91->B91_KEYPRE))
		EndIf

		If B7C->B7C_TIPO <> 'G' .AND. (B91->B91_OBRIGA .OR. !Empty(B91->B91_VARREL))	// QUANDO EH CAMPO QUE NECESSITA DE PREENCHER O RELACIONAMENTO
			oForm:setObrigat(B91->B91_NOMXMO,AllTrim(B91->B91_KEYPRE))
		EndIf

		If !Empty(Alltrim(B91->B91_KEYDOW))
			If lCpoRelac .AND. cTpField == "C" // Quando o dado do campo vai ser relacionamento de filhos preenche automatico
				&(cCampo):setJSKeyDown(alltrim(B91->B91_KEYDOW))
			Else
				&(cCampo):setJSKeyDown(alltrim(B91->B91_KEYDOW))
			EndIf
		EndIf

		If !Empty(Alltrim(B91->B91_VALID))
			cValid := AllTrim(B91->B91_VALID)
			&(cCampo):setJSBlur(cValid)
		EndIf

		If !Empty(Alltrim(B91->B91_GATILH))
			cGatilho := AllTrim(B91->B91_GATILH)
			cChave := AllTrim(B91->B91_CHVGAT)
			&(cCampo):setJSChange("validCmpGen(null"+",'"+;
				cNome+"',"+IIF(Empty(cGatilho),"null","'"+cGatilho+"'")+","+IIF(Empty(cChave),"null","'"+cChave+"'")+")")
		EndIf

		If !Empty(Alltrim(B91->B91_F3))
			&(cCampo):setJsFF3(B91->B91_F3)
			&(cCampo):setOpenGrp(.T.)
			&(cCampo):setCloseGrp(.T.)
		EndIf

		If !Empty(Alltrim(B91->B91_ACTION))
			&(cCampo):setJsFBtn(B91->B91_ACTION)
			&(cCampo):setOpenGrp(.T.)
			&(cCampo):setCloseGrp(.T.)
		EndIf
		
		If !Empty(B91->B91_TOOTIP)
			&(cCampo):setToolTip(Alltrim(B91->B91_TOOTIP))
		EndIf

		If !Empty(Alltrim(B91->B91_CHANGE))
			cChange := AllTrim(B91->B91_CHANGE)
			&(cCampo):setJSChange(cChange)
		EndIf
				
		//Aqui eu verificarei se será necessário carregar o layout cabeçalho, (grids devem ser carregadas no B90_FUNLOA via JavaScript)
		//então se não for grid e não tiver grupo pai, é pq é o formulário principal
		If B7C->B7C_TIPO <> 'G' .AND. Empty(Alltrim(B7C->B7C_GRUPAI)) .AND. !Empty(cRecnoReg)
			SX3->(DbSelectArea("SX3"))
			SX3->(DbSetOrder(2))	
			//se existe o campo no X3 e se não é virtual para pegar o dado no banco	
			If SX3->(MsSeek(B91->B91_CAMPO)) //.AND. SX3->X3_CONTEXT <> "V"
				If SX3->X3_CONTEXT == "V"
					xConteudo := IIF(!Empty(B91->B91_POSICI), &(B91->B91_POSICI), "")
					If valType(xConteudo) == "N"
						cValCar := STR(xConteudo)
					ElseIf valType(xConteudo) == "D"
						cValCar := dToS(xConteudo)
					Else
						cValCar := xConteudo
					EndIf
				Else
					cValCar := IIF( SUBSTR(Alltrim(B91->B91_CAMPO),1,3) ==  cAlias, &(cAlias + "->" + Alltrim(B91->B91_CAMPO) ) , '')
					If SX3->X3_TIPO == "N" 
						cValCar := STR(cValCar)
					ElseIf SX3->X3_TIPO == "D"
						cValCar := dToS(cValCar) 
					EndIf
				EndIf

				If dataForm:chaveLay == "PPLALTB7L" 
					B7L->(DBSetOrder(3))
					If B7L->(MsSeek(xFilial("B7L")+PADR(aDataAux[1], TamSX3("B7L_CHAVE")[1]) + B91->B91_CAMPO))
						cValCar := B7L->B7L_VLPOS
					EndIf
				EndIf

				//Carregar corretamente a operadora + grupo empresa na alteração/inclusão de beneficiário
				If B91->B91_CAMPO == "B2N_CODEMP" .AND. dataForm:chaveLay == "PPLALTSOL" 
					cOperadora := PLSINTPAD()
					cValCar := cOperadora + "." + cValCar
				EndIf

				If B91->B91_TIPO == 'G' .OR. B91->B91_TIPO == 'P'
					&(cCampo):setDefCB(Alltrim(cValCar))
				ElseIf B91->B91_TIPO == 'C' .OR. B91->B91_TIPO == 'N' 
					&(cCampo):setValue(Alltrim(cValCar))		
				ElseIf  B91->B91_TIPO == 'D'			
					&(cCampo):setValue(SubStr(cValCar,7,2) + '/'+ SubStr(cValCar,5,2)+'/'+ SubStr(cValCar,0,4))
				EndIf
			EndIf		   
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Seta componente ao fiedlset
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		&(cGrupo):setAddCFS(&(cCampo))
		B91->(DbSkip())

	EndDo //AQUI ACABA O WHILE

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ As Grids necessitam de alguns objetos a mais
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If B7C->B7C_TIPO == 'G' // O G na B7C é para GRID
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Crio a tab da grid
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ		
		&("oTab"+ Alltrim(B7C->B7C_NOMGRI) ):= WCTable():new("tab" + Alltrim(B7C->B7C_NOMGRI))
		&("oTab"+ Alltrim(B7C->B7C_NOMGRI) ):setTitFolder(Alltrim(B7C->B7C_DESCRI))
		cGrids += "|" + cDesGri
       cGrids += "~" + cFieldsOb + "~" + cSeqGri 
		cSeqGri := ""
		cDesGri := ""
		cFieldsOb := ""
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Campo oculto RECNO
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		oForm:setAddFieldHidden(cGrid + "_RECNO","")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Botao incluir
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !Empty(B7C->B7C_LINOK)
			cBtn := "oInc" + cGrid
			&(cBtn) := WCComponent():New("B","bInc" + cGrid,"Incluir")

			cFunInc := B7C->B7C_LINOK + " ; "
			&(cBtn):SetJsFunc(cFunInc)
			&(cBtn):setAlign('right')
			&(cBtn):setCSS("Botoes")
			&(cBtn):setNoTagTDIE()
			&(cBtn):setOpenGrp(.T.)
			&(cBtn):setCloseGrp(.F.)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Botao Salvar
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !Empty(B7C->B7C_FUNSAV)
			cBtnS := "oSave" + cGrid
			&(cBtnS) := WCComponent():New("B","bSave" + cGrid,"Salvar")

			cFunSave := B7C->B7C_FUNSAV + " ; "
			&(cBtnS):SetJsFunc(cFunSave)
			&(cBtnS):setAlign('right')
			&(cBtnS):setDisable()
			&(cBtnS):setCSS("Botoes")
			&(cBtnS):setNoTagTDIE()
			&(cBtnS):setOpenGrp(.F.)
			&(cBtnS):setCloseGrp(.T.)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Grid
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//verifico se existe grupo pai e se o recno não está vazio pq ai é alteração 
		If !Empty(Alltrim(B7C->B7C_GRUPAI)) .AND. !Empty(cRecnoReg)
			//acho onde está o grupo pai no array
			If (nPosGru := aScan( aCposRel , {|x| AllTrim(x[1]) == B7C->B7C_GRUPAI} )) > 0
			    //acho o filho dentro do grupo pai
				If (nPosGrd := aScan( aCposRel[nPosgru,8] , {|x| allTrim(x[1]) == B7C->B7C_ORDEM } )) > 0
			       //se existir alguma chave para o filho, preciso fazer o seek	
					If ( Len(aCposRel[nPosGru,8,nPosGrd, 3]) > 0 )
					
						//criação da estrutura da grid para adicionar o acols e o aheader de cada grid
						aAdd( RetForm:ContGrid, WsClassNew('AGrids') )
						nTamConGri := Len(RetForm:ContGrid)
						RetForm:ContGrid[nTamConGri]:Grid := cGrid
						RetForm:ContGrid[nTamConGri]:ACols := {}
						RetForm:ContGrid[nTamConGri]:AHeader := {}
						xHeader := "["
						If B7C->B7C_ATUALI
							xHeader += "{name:'Alterar'},"
						EndIf
						If B7C->B7C_EXCLUI
							xHeader += "{name:'Excluir'},"
						EndIf
						
						cRecnus += "@" + cAlias + "~"
												
						For nK := 1 to Len(aCposGri)
							xHeader += "{name:'" + alltrim(aCposGri[nK,3]) + "'}"
							xHeader += Iif(nK == Len(aCposGri), "]", ",")
						Next nK
						
						xCols   := "[" //abro o xcols (usado no javascript para controlar os grids, o xheader tbm)
								 	
						B7C->(dbSetOrder(VAL(B7C->B7C_INDICE)))

			           //para cada chave, faço o seek executando a macro da chave
						For nI := 1 to Len(aCposRel[nPosGru,8,nPosGrd, 3])
							
							nCountReg := 0								
							If &(cAlias + "->(MsSeek('" + aCposRel[nPosGru,8,nPosGrd,3,nI] + "'))")		

								cMacroComp := If(EMPTY(aCposRel[nPosGru,8,nPosGrd,5]), ".T.", aCposRel[nPosGru,8,nPosGrd,5])

								While !(&(cAlias+"->(EOF())")) .AND. aCposRel[nPosGru,8,nPosGrd,3,nI] == &(cAlias+"->(" + Separa(aCposRel[nPosGru,8,nPosGrd,2], "|")[2] + ")")
									  
									//Executa a validacao complementar utilizando outros campos que nao estao no indice  
									If &(cMacroComp)
										
										//verifico se a grid possui filhos para poder preencher os conteudos certos já que pode existir mais de uma chave e mais de um filho
										If (nPosGrd2 := aScan( aCposRel , {|x| AllTrim(x[1]) == B7C->B7C_ORDEM} )) > 0										 		
										
											For nJ := 1 to len(aCposRel[nPosGrd2,8])
												aAdd(aCposRel[nPosGrd2,8,nJ,3], &( Separa( aCposRel[nPosGrd2,8,nJ,2], "|" )[1] ) )
										
												//aqui eu preciso adicionar os itens que eu preciso pra preencher o combobox de relacionamento
												For nW := 1 to Len(aCposRel[nPosGrd2,8,nJ,4])
										
													If aCposRel[nPosGrd2,8,nJ,4,nW,3] <> ""
														aVarRel := Separa(aCposRel[nPosGrd2,8,nJ,4,nW,3], "|")
														aAdd(aCposRel[nPosGrd2,8,nJ,4,nW,4], &(cAlias+"->"+aVarRel[1]) + "=" + alltrim(&(cAlias+"->"+aVarRel[2])))
													EndIf
												Next nW
											Next nJ  		
										EndIf

										nCountReg++
										aHeader := {}
										nNumAux := 0
										
										//monto o acols e o aheader para mandar pro WCCOMPONENT do tipo BW para poder contruir a grid e carregar na tela
										aAdd(RetForm:ContGrid[nTamConGri]:ACols, WsClassNew('SStrGrid'))
										aAdd(RetForm:ContGrid[nTamConGri]:AHeader, WsClassNew('SStrGrid'))
										
										nTamAcols := Len(RetForm:ContGrid[nTamConGri]:ACols)
										nTamAheader := Len(RetForm:ContGrid[nTamConGri]:AHeader)
										
										RetForm:ContGrid[nTamConGri]:AHeader[nTamAheader]:Valores := {}
										RetForm:ContGrid[nTamConGri]:ACols[nTamAcols]:Valores := {}
										
										For nK := 1 to Len(aCposGri)
										
											If aCposGri[nK,1] == cAlias
												
												If SX3->(MsSeek(aCposGri[nK,2]))
														aAdd(aHeader, alltrim(aCposGri[nK,3]))
														aAdd(RetForm:ContGrid[nTamConGri]:AHeader[nTamAheader]:Valores, alltrim(aCposGri[nK,4]))
														If SX3->X3_CONTEXT == "V"

															If (nPosVirtua := aScan(aCmpsVirtua , {|x| AllTrim(x[1]) == alltrim(aCposGri[nK,2]) } )) > 0
																If !Empty(aCmpsVirtua[nPosVirtua,2])
																	xConteudo := &(aCmpsVirtua[nPosVirtua,2])
																Else
																	xConteudo := ""
																EndIf
															Else
																xConteudo := ""
															EndIf
														Else
															xConteudo := &(cAlias + "->" + aCposGri[nK,2])							   			
														EndIf 	
																																				
														If valType(xConteudo) == "D"
															xConteudo := dToS(xConteudo)
														ElseIf valType(xConteudo) == "N"
															xConteudo := STR(xConteudo)
														EndIf

														If  SX3->X3_TIPO == "D"	.And. !Empty(xConteudo)		
															xConteudo := (SubStr(xConteudo,7,2) + "/"+ SubStr(xConteudo,5,2)+ "/"+ SubStr(xConteudo,0,4))
														EndIf

														xConteudo := alltrim(xConteudo) + IIF( "CMPSEQ" $ aCposGri[nK,3], '<mark class="markInv">*CMPSEQ</mark>', "")	
														
														//todos os campos do tipo combobox devem carregar na grid como codigo*descricao
														//todos esses campos são guardados no aCmbsRel
														If len(aCmbsRel)>0
															aArAux := {}
															For nW := 1 To Len(aCmbsRel)
																If  alltrim(aCposGri[nK,4]) $ aCmbsRel[nW] .AND. ";" $ aCmbsRel[nW]
																	aArAux := Separa(aCmbsRel[nW], ";")
																	Exit
																EndIf
															Next nW
															
															For nW := 2 To Len(aArAux) // Começa a partir da segunda posição pois a primeira eh o nome do campo
																If xConteudo+"=" $ aArAux[nW]
																	xConteudo := '<mark class="markInv">' +Separa(aArAux[nW], "=")[1]+'*</mark>'+Separa(aArAux[nW], "=")[2] 
																EndIf 
															Next nW
														EndIf
														
														aAdd(aAux, xConteudo)
														aAdd(RetForm:ContGrid[nTamConGri]:ACols[nTamAcols]:Valores, xConteudo)
																																						
												EndIf
											EndIf
											
											//MONTO XCOLS
											
											If nK == 1
											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
											//Adiciona os botões da linha e coloca o Recno
											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
												If B7C->B7C_ATUALI .OR. B7C->B7C_EXCLUI
													xCols += "{"
												EndIf
												
												If B7C->B7C_ATUALI
													xCols += alltrim(str(nNumAux)) + ":{field:'RECNO', value:'0#" + AllTrim(Str(nCountReg)) + "," + cGrid + ".id,4'},"
													nNumAux++
												EndIf
												
												If B7C->B7C_EXCLUI										
													xCols += alltrim(str(nNumAux)) + ":{field:'RECNO', value:'1#" + AllTrim(Str(nCountReg)) + "," + cGrid + ".id,5,true," + '""' + " ," + '""' + " ,cCampoDefault'}," //Botão Excluir
													nNumAux++
												EndIf
											EndIf
											
											If !B7C->B7C_ATUALI .AND. !B7C->B7C_EXCLUI
													xCols += "{"
											EndIf
											
											xCols += alltrim(str(nNumAux)) + ":{field:'" + alltrim(aCposGri[nK,4]) + "', value:'" + xConteudo + "'}" 
											xCols += IIF(nK < Len(aCposGri), "," , "")
											nNumAux++
											
										Next nK
										
										xCols += "},"
										
										aAdd(RetForm:ContGrid[nTamConGri]:AHeader[nTamAheader]:Valores, "Marca") //campo de controle do header do grid
										aAdd(RetForm:ContGrid[nTamConGri]:ACols[nTamAcols]:Valores, "1")		   // campo de controle do acols do grid					
										aAdd(aCols, aAux)
										
										cRecnus += AllTrim(Str( &(cAlias + "->(Recno())") )) + "~"
										
										aAux := {}			
									EndIf									
									
									&(cAlias + "->(dbSkip())")
								EndDo
							EndIf
						Next nI
						
						If RIGHT(xCols, 1) == "," //tiro a virgula pois ja sai do while  e não existe mais registro a ser adicionado
							xCols := left(xCols, (len(xCols)-1))
						EndIf 
						
						xCols += "]"	//acabou todos os registros ai eu fecho o xCols
						RetForm:ContGrid[nTamConGri]:xCols := xCols
						RetForm:ContGrid[nTamConGri]:xHeader := xHeader
					EndIf
				EndIf
			EndIf
		EndIf
		
		&(cGrid) := WCComponent():New("BW",cGrid)
		&(cGrid):setBrWidth("770")
		&(cGrid):setJsFunc("")
		&(cGrid):setPosicao("30")
		&(cGrid):setAHeader(aHeader)
		&(cGrid):setACols(aCols)
		&(cGrid):setAltGrid(B7C->B7C_ATUALI)
		&(cGrid):setDelGrid(B7C->B7C_EXCLUI)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Adiciona os componentes ao grupo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !Empty(B7C->B7C_LINOK)
			&(cGrupo):setAddCFS(&(cBtn))
		EndIf
		If !Empty(B7C->B7C_FUNSAV)
			&(cGrupo):setAddCFS(&(cBtnS))
		EndIf

		&(cGrupo):setAddCFS(&(cGrid))
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//Seta o Grupo à Linha
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	&("oLi"+ B7C->B7C_ORDEM ):setAddComp(&(cGrupo))
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Fechamento da Tabela
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
If B7C->B7C_TIPO == 'G'
		&("oTab"+ Alltrim(B7C->B7C_NOMGRI) ):setAddLine(&("oLi"+ B7C->B7C_ORDEM ))
		oTabGrids:setAddTables(&("oTab"+ Alltrim(B7C->B7C_NOMGRI) ))
Else
		oTabPriFP:setAddLine(&("oLi"+ B7C->B7C_ORDEM ))
EndIf

If (Len(cRecnus)) > 0
	cRecnus := Left(cRecnus, Len(cRecnus) - 1)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Cria subgrupos
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
MntGrupo(B90->B90_SEQUEN,B7C->B7C_ORDEM,@oTabPriFP,@RetForm,@oForm,DataForm:DadCombo,@cGrids, @cDesGri, @cFields, @aCposRel, @oTabGrids, @cFieldsOb, @cSeqGri, cRecnoReg, @cRecnus)
Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MntHidden ³Autor  ³ Rogerio Tabosa         ³ Data ³06.03.2015³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Insere campos hidden na guia                         		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function MntHidden(cChvLay,oForm,aCampos)

Local nLen	:= 0
Local nPos	:= 0

DEFAULT aCampos := { {"cChvLay"		, cChvLay	},;											
						{"cTpRecGlo"		, ""		};
						}

//Permite a inclusão de campos Hidden por P.E.
If ExistBlock("PLSCPHID")
	aCampos := ExecBlock("PLSCPHID",.F.,.F.,{cTipGui,aCampos})
Endif

While (nPos:=aScan( aCampos , {|x| AllTrim(x[1]) == cTipGui} )) > 0 .AND. aCampos[nPos][1] == cTipGui
	oForm:setAddFieldHidden(aCampos[nPos,2],aCampos[nPos,3])
	nSize := Len(aCampos)
	aDel(aCampos,nPos)
	aSize(aCampos,nSize-1)
EndDo

Return


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GrvForm   ³Autor  ³ Rogerio Machado Tabosa ³ Data ³01.02.2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os campos do TIpo Combo da GUIA dinamica do Portal	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GrvForm WSRECEIVE UserCode,DataInput,DataAux WSSEND WSNULL WSSERVICE PLCADWEB

	Local lRetorno := .T.
	Local aArea := GetArea()
	Local nI := 0
	Local cLayout := ""
	Local cMsg := ""
	Local cCombo := ""
	Local atCmb := 0
	Local cRecGri := ::DataInput:Recnus
	Local cRecPai := ::DataInput:RecnoReg
	Local aDadosForm := {}
	Local cProtocolo := ""

	Private lGrvDadServ	:= .T.
	Private cLogin		:= IiF( ValType(::DataInput:UserLogin) == "C", ::DataInput:UserLogin, "" )
	Private cTpPortal		:= IiF( ValType(::DataInput:TpPortal) == "C", alltrim(::DataInput:TpPortal), "" )
	Private cMatric		:= IiF( ValType(::DataInput:Matric) == "C", ::DataInput:Matric, "" )
	Private xDataAux		:= IIF( ValType(::DataAux) == "C", ::DataAux, "")
	Private aDados		:= {}
	Private aRet			:= {.T.,""} // [.T./.F. , Mensagem de erro, qualquer informação para usar na FUNPOS]

	FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01', ::DataAux , 0, 0, {})
	If PrtChkUser( ::UserCode , "PLCADWEB", "GrvForm" )
		
		//VARIÁVEL DE RETORNO
		::WSNULL := "false|"
			
		cLayout := ::DataInput:ChaveLay	
		
		B90->(DbSetOrder(2))
		B90->(MsSeek(xFilial("B90") + cLayout))
		
		B7C->(DbSetOrder(2))
		B7C->(MsSeek(xFilial("B7C") + B90->B90_SEQUEN ))
		While !B7C->(EOF()) .AND. xFilial("B7C")+B90->B90_SEQUEN == B7C->(B7C_FILIAL+B7C_SEQB90)
			For nI := 1 to Len( ::DataInput:Dados )
					B91->(DbGoTop())
					B91->(DbSetOrder(1))
					If (B91->(MsSeek(xFilial("B91") + B90->B90_SEQUEN + B7C->B7C_ORDEM + ::DataInput:Dados[nI]:Campo)))
						If allTrim(B91->B91_TIPO) == "G" .OR. allTrim(B91->B91_TIPO) == "P"
								//aqui eu trato o campo combo, ele adiciona código e descrição separados por *, preciso somente da descrição.
								If "markInv" $ ::DataInput:Dados[nI]:Valor
									//markInv é a class que marca que o codigo do combo está invisivel, vou retirar a tag mark e manter só o código 
									cCombo := strtokarr(::DataInput:Dados[nI]:Valor,"*")[1]
									If (atCmb := at(">", cCombo)) > 0
										::DataInput:Dados[nI]:Valor := SUBSTR(cCombo, atCmb+1)
										atCmp := 0
									Else
										::DataInput:Dados[nI]:Valor := ""
									EndIf	
								EndIf
						EndIf
						
						If "CMPSEQ" $ ::DataInput:Dados[nI]:Valor //quando a tabela tem um campo sequencial e isso foi informado no layout, o campo sempre fica com valor_do_campo*CMPSEQ
							::DataInput:Dados[nI]:Valor := strtokarr(::DataInput:Dados[nI]:Valor,"*")[1]
						EndIf
						AADD(aDados, { ::DataInput:Dados[nI]:Tabela, ::DataInput:Dados[nI]:Campo, ::DataInput:Dados[nI]:Valor, ::DataInput:Dados[nI]:SeqGrid, .F. ,Alltrim(B91->B91_CAMPO) } )				 
					EndIf	  		
			Next nI
			B7C->(DBSkip())
		EndDo
		
		aDadosForm := aClone(aDados)
		PLaRecno(cRecPai, cRecGri, @aDados)
		
		Begin Transaction
			If !Empty(B90->B90_FUNPRE) // Função ADVPL configurada no Layout para ser executada antes da gravação (validações)
				aRet := &(Alltrim(B90->B90_FUNPRE))  // devera retornar o array com duas posições [.T./.F. , Mensagem de erro, qualquer informação para usar na FUNPOS]  e sera passado o aDados para manipulação
			EndIf
			If !aRet[1] // Se a validação retornou false
				::WSNULL := "false|" + Alltrim(aRet[2]) // atribui a mensagem
			Else				
				If PLGRVLWEB(cLayout, aDados, cRecGri, cRecPai)
					If !Empty(B90->B90_FUNPOS) // Função ADVPL configurada no Layout para ser executada após a gravação				
						cMsg := &(Alltrim(B90->B90_FUNPOS))
					EndIf
					If !Empty(cMsg)
						::WSNULL := "true|" + cMsg
					Else
						::WSNULL := "true|Formulário gravado com sucesso!"
					EndIf
					cProtocolo := IIF(!Empty(BBA->BBA_NROPRO), BBA->BBA_NROPRO, "") 
					GrvTermoConsentimento(cLayout, cLogin, cMatric, cProtocolo, aDadosForm)
				Else
					::WSNULL := "false|Não foi possivel realizar a gravação!"
				EndIf
			EndIf
		End Transaction	
	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno

/*=================================================================================
Retorno o Tipo do Agrupamento do grupo pai
B7C->B7C_ORDEM, B7C->B7C_TIPO, B7C->B7C_GRUPAI,B7C->B7C_NOMGRI,B7C->B7C_CPOREL , ""
/*=================================================================================*/
Static Function GetTpGPai(cPai, aCposRel, cNomXmo, cVarRel)
Local nPosGru	:= 0
Local cTipo	:= ""

If (nPosGru := aScan( aCposRel , {|x| AllTrim(x[1]) == cPai} )) > 0
	cTipo := aCposRel[nPosGru,2] // Pego o tipo do grupo
	aCposRel[nPosGru,6] := Iif(!Empty(aCposRel[nPosGru,6]), aCposRel[nPosGru,6], cNomXmo) // atribuo os campos que esse cara vai preencher
	aCposRel[nPosGru,7] := cVarRel
EndIf

Return(cTipo)

/*=================================================================================
Adiciono os registros filhos no pai
B7C->B7C_GRUPAI, B7C->B7C_ORDEM, aCposRel ,B7C->B7C_CHVIND, B7C_CHVIND
/*=================================================================================*/
Static Function SetFilhoPai(cPai, cFilho, aCposRel, cDadChv, cSeqB90, cMacroValComp)
	
	Local nPosGru	:= 0
	Local cTipo	:= ""
	Local aArea   := getArea()
	local cSql		:= ""

	Default cPai 		  := ""
	Default cFilho 		  := ""
	Default aCposRel 	  := ""
	Default cDadChv 	  := ""
	Default cSeqB90 	  := ""
	Default cMacroValComp := "" //executa a macro de validacao complementar relacionado ao campo B7C_CHVIND

	If (nPosGru := aScan( aCposRel , {|x| AllTrim(x[1]) == cPai} )) > 0
		
		AADD(aCposRel[nPosGru,8], {cFilho, Alltrim(cDadChv), {}, {} /* campos b91_varrel que serão preenchidos quando for alteração entre grids */, AllTrim(cMacroValComp)} )
		
		B91->(dbSetOrder(1))

		If B91->(MsSeek(xFilial("B91")+cSeqB90) )

			cSql := " SELECT B91_VARREL, B91_NOMXMO, B91_CAMPO, B91_SEQUEN "
			cSql += " FROM " + RetSqlName("B91")
			cSql += " WHERE B91_FILIAL = '" + xFilial("B91") + "' "
			cSql += " AND B91_SEQUEN = '" + cSeqB90 + "' AND B91_VARREL <> ' ' AND D_E_L_E_T_ = ' ' " 
			
			cSql := ChangeQuery(cSql)
			TcQuery csql New Alias "TabB91F"
			
			while !TabB91F->(eof())

				If GetTpGPai(B7C->B7C_GRUPAI, @aCposRel , Alltrim(TabB91F->B91_NOMXMO), Alltrim(TabB91F->B91_VARREL)) == 'G' // se o grupo que tem o dado relacinado for um grid é uma combo e eu preciso dos itens
					aAdd( aCposRel[nPosGru,8, Len(aCposRel[nPosGru,8]) ,4], { TabB91F->B91_CAMPO, TabB91F->B91_NOMXMO, GetCposRel(TabB91F->B91_SEQUEN, cPai, TabB91F->B91_VARREL), {} } ) //ultima posição é o array que receberá o conteudo desses campos, lembrando que podemos ter mais de um registro no relacionamento, por isso um array
				EndIf

				TabB91F->(dbskip())
			enddo	
						
			TabB91F->(dbclosearea())
		EndIf
	EndIf
		
	restArea(aArea)
Return
/*=================================================================================
Pego os campos do pai para relacionamento entre grids
B91->SEQUEN, B7C->B7C_GRUPAI, B91_VARREL
/*=================================================================================*/
Static Function GetCposRel(cSequen, cGrupo, cNomXmo)
LOCAL aArea := B91->(getArea())
LOCAL aNomXmo := separa(cNomXmo, "|")
LOCAL cCpos := ""
LOCAL nCount := 0 //variavel que identifica se foram achados os dois campos necessários no relacionamento

B91->(dbSelectArea("B91"))
B91->(dbSetOrder(1))

If B91->(MsSeek(xFilial("B91")+cSequen+cGrupo+aNomXmo[1] ) )
   cCpos += alltrim(B91->B91_CAMPO) + "|"
   nCount++
EndIf

If B91->(MsSeek(xFilial("B91")+cSequen+cGrupo+aNomXmo[2] ) )
   cCpos += alltrim(B91->B91_CAMPO)
   nCount++
EndIf

If nCount < 2
 cCpos := ""
EndIf

restArea(aArea)

Return cCpos

/*/{Protheus.doc} PLVALNOME
Valida o nome do beneficiário e nome da mãe na inclusão de beneficiários no portal do beneficiário
/*/
WSMETHOD ValNomeBe WSRECEIVE UserCode, Nome, MsgCrit WSSEND WSNULL WSSERVICE PLCADWEB 

LOCAL lRet 		 := .T.

If PrtChkUser( ::UserCode , "PLCADWEB", "ValNomeBe" )
	
	If !PLVlANSNome(::Nome)
		::WSNULL := 'false|' + ::MsgCrit
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRet

/*/{Protheus.doc} ValCodTit
Verifica se o código de titular configurado no sistema é o mesmo do beneficiário selecionado
na inclusão de beneficiários no portal
/*/
WSMETHOD ValCodTit WSRECEIVE UserCode, GrauPa WSSEND WSNULL WSSERVICE PLCADWEB 

Local cMV_TITU := getNewPar("MV_PLCDTGP", "01") 

If PrtChkUser( ::UserCode , "PLCADWEB", "ValCodTit" )
	
	If ::GrauPa == cMV_TITU

		::WSNULL := "true|true"
	Else	
		::WSNULL := "true|false"
	EndIf 
	
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} LogLGPD
Loga os webservices acionados pelo Portal.

@author sakai
@since 10/12/2020
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD LogLGPD WSRECEIVE UserCode,UserLGPD,RotinLGPD WSSEND WSNULL WSSERVICE PLCADWEB 

	LOCAL aArea 	:= GetArea()
	LOCAL lRetorno := .T.

	if PrtChkUser( self:UserCode , "PLCADWEB","LogLGPD" )
		if !empty(self:UserLGPD) .And. !empty(self:RotinLGPD)
			PLogPortLG(self:RotinLGPD,self:UserLGPD)
			::WSNULL := "true|true" 
		else
			::WSNULL := "true|false"  
		endif
	else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	endIf

	RestArea( aArea )

Return lRetorno

//----------------------------------------------------------------------------
/*/{Protheus.doc} GetTermoDadosPessoais
Retorna os Dados Pessoais do termo de consentimento correspondente 
ao Layout

@author Vinicius Queiros Teixeira
@since 04/05/2021
@version Protheus 12
/*/
//----------------------------------------------------------------------------
Static Function GetTermoDadosPessoais(cLayout)

	Local cQuery := ""
	Local cAlias := ""
	Local cTermoLayout := GetNewPar("MV_PLLYTER", "PPLINCBEN/PPLALTBEN/PPLALTSOL/PPLALTB7L")
	Local aDadosTermo := {}
	Local aRetorno := {}
	Local cTermoCabecalho := ""
	Local lTermoCabecalho := .T.
	Local aAreaB91 := B91->(GetArea())
	Local aAreaB90 := B90->(GetArea())

	If B91->(FieldPos("B91_TERCON")) == 0 .Or. B91->(FieldPos("B91_FINALI")) == 0 .Or.;
	    !(cLayout $ cTermoLayout)
		Return aRetorno
	EndIf

	cQuery += " SELECT B91.R_E_C_N_O_ RECNOB91, B90.R_E_C_N_O_ RECNOB90 " 
	cQuery += " FROM "+RetSQLName("B91")+" B91 "
	cQuery += " INNER JOIN "+RetSQLName("B7C")+" B7C " 	
	cQuery += " 	 ON B7C.B7C_FILIAL = '"+xFilial("B7C") + "'" 
	cQuery += "	    AND B7C.B7C_SEQB90 = B91.B91_SEQUEN" 
	cQuery += "	    AND B7C.B7C_ORDEM = B91.B91_GRUPO" 
	cQuery += "     AND B7C.D_E_L_E_T_ = ' ' "
	cQuery += " INNER JOIN "+RetSQLName("B90")+" B90 " 	
	cQuery += " 	 ON B90.B90_FILIAL = '"+xFilial("B90") + "'" 
	cQuery += "	    AND B90.B90_SEQUEN = B7C.B7C_SEQB90" 
	cQuery += "     AND B90.D_E_L_E_T_ = ' ' "
	cQuery += " WHERE B90.B90_CHAVE = '"+cLayout+"'"
	cQuery += "   AND B91.B91_TERCON = 'T'"
	cQuery += "   AND B91.B91_NOMXMO <> ' '"
	cQuery += "   AND B91.B91_TIPO <> ' '"
	cQuery += "   AND B91.B91_VISUAL = 'T'"
	cQuery += "   AND B91.D_E_L_E_T_ = ' '"

	cAlias := GetNextAlias()
    DbUseArea(.T., "TOPCONN",TCGENQRY(,, cQuery), cAlias, .F., .T.)

	While (cAlias)->(!Eof())

		If lTermoCabecalho // So preenche uma vez o cabecalho do termo
			B90->(DbGoTo((cAlias)->RECNOB90))
			cTermoCabecalho := B90->B90_CABTER
			lTermoCabecalho := .F.
		EndIf

		B91->(DbGoTo((cAlias)->RECNOB91))
		aAdd(aDadosTermo, {Alltrim(B91->B91_CAMPO), B91->B91_DESCRI, B91->B91_FINALI})

		(cAlias)->(DbSkip())
	EndDo

	If Len(aDadosTermo) > 0
		aRetorno := {cTermoCabecalho, aDadosTermo}
	EndIf

	(cAlias)->(DbCloseArea())

	RestArea(aAreaB91)
	RestArea(aAreaB90)

Return aRetorno

//----------------------------------------------------------------------------
/*/{Protheus.doc} MontaTermoConsentimento
Monta o HTML do Termo de Consentimento do Beneficiário para Tratamento
de Dados Pessoais

@author Vinicius Queiros Teixeira
@since 03/05/2021
@version Protheus 12
/*/
//----------------------------------------------------------------------------
Static Function MontaTermoConsentimento(aDadosTermo)

	Local cHtmlTermo := ""
	Local cHtmlDados := ""
	Local cHtmlFinalidade := ""
	Local nX := 0

	If !Empty(aDadosTermo[1])
		cHtmlTermo += aDadosTermo[1]
		cHtmlTermo += "<br>"
	EndIf
	
	cHtmlDados += "<ol>"
	cHtmlFinalidade += "<ol>"

	For nX := 1 To Len(aDadosTermo[2])
		cHtmlDados += "<li>"+Alltrim(aDadosTermo[2][nX][2])+"</li>"
		cHtmlFinalidade += "<li>"+Alltrim(aDadosTermo[2][nX][3])+"</li>"
	Next nX

	cHtmlDados += "</ol>"
	cHtmlFinalidade += "</ol>"
	cHtmlTermo += "<strong>Dados Pessoais</strong><br>"
	cHtmlTermo += cHtmlDados
	cHtmlTermo += "<strong>Finalidades do Tratamento dos Dados</strong><br>"
	cHtmlTermo += cHtmlFinalidade

	cHtmlTermo += "Ao preencher os Dados Pessoais listados neste termo, o Beneficiário <strong>ACEITA</strong> que seus Dados Pessoais sejam coletados, caso  <br>"
	cHtmlTermo += "<strong>NÃO ACEITE</strong> a coleta dos Dados é só não informa-los.<br> "

Return cHtmlTermo

//----------------------------------------------------------------------------
/*/{Protheus.doc} GrvTermoConsentimento
Grava Termo de Consentimento do Beneficiário de acordo com o 
preenchimento no Portal

@author Vinicius Queiros Teixeira
@since 04/05/2021
@version Protheus 12
/*/
//----------------------------------------------------------------------------
Static Function GrvTermoConsentimento(cLayout, cLogin, cChvMatric, cProtocolo, aDadosForm)

	Local lRetorno := .F.
	Local aDadosTermo := {}
	Local nBusca := 0
	Local nX := 0
	Local cCPFBeneficiario := ""
	Local cNomeBeneficiario := ""
	Local cTabela := ""
	Local cCampoCPF := ""
	Local cCampoNome := ""
	Local cOperadora := Substr(cChvMatric, 1, 4)
	Local cCodEmpresa := Substr(cChvMatric, 5, 4)
	Local cMatricula := Substr(cChvMatric, 9, 6)
	Local oModel := Nil
	Local oModelB6V := Nil
	Local lExisteBeneficiario := .F.
	Local lAddLinha := .T.
	Local cHorario := Time()
	Local cDadoPessoal := ""
	Local cAceite := ""
	Local cCampoTabela := ""
	Local cFinalidade := ""

	Default aDadosForm := {}

	aDadosTermo := GetTermoDadosPessoais(cLayout)

	If Len(aDadosTermo) > 0 .And. Len(aDadosForm) > 0 .And. PlsAliasExi("B6V") .And. FindFunction("PLSA260B6V")
		cTabela := aDadosForm[1][1]
		Do Case
			Case cTabela == "B2N"
				cCampoCPF := "B2N_CPFUSR"
				cCampoNome := "B2N_NOMUSR"

			Case cTabela == "BA1"
				cCampoCPF := "BA1_CPFUSR"
				cCampoNome := "BA1_NOMUSR"
		EndCase

		nBusca := Ascan(aDadosForm,{|x| Alltrim(x[6]) == cCampoCPF})
		cCPFBeneficiario := IIF(nBusca > 0, aDadosForm[nBusca][3], "")

		cCPFBeneficiario := StrTran(cCPFBeneficiario,".","")
		cCPFBeneficiario := StrTran(cCPFBeneficiario,"-","")

		nBusca := Ascan(aDadosForm,{|x| Alltrim(x[6]) == cCampoNome})
		cNomeBeneficiario := IIF(nBusca > 0, aDadosForm[nBusca][3], "")

		oModel := FWLoadModel("PLSA260B6V")
		oModelB6V := oModel:GetModel("MASTERB6V")
		oModelB6W := oModel:GetModel("DETAILB6W")
	
		B6V->(DBSetOrder(1))
    	lExisteBeneficiario := B6V->(MsSeek(xFilial("B6V")+cOperadora+cCodEmpresa+cMatricula))

		If lExisteBeneficiario
			oModel:SetOperation(4)
		Else
			oModel:SetOperation(3)					
		EndIf

		oModel:Activate()	

		If lExisteBeneficiario
			lAddLinha := oModelB6W:AddLine()
		Else
			oModelB6V:SetValue("B6V_CODINT", cOperadora)
			oModelB6V:SetValue("B6V_CODEMP", cCodEmpresa)
			oModelB6V:SetValue("B6V_MATRIC", cMatricula)
		EndIf

		If lAddLinha
			For nX := 1 To Len(aDadosTermo[2])

				If nX <> 1
					lAddLinha := oModelB6W:AddLine()
				EndIf

				If lAddLinha
					cDadoPessoal := aDadosTermo[2][nX][2]
					cCampoTabela := aDadosTermo[2][nX][1]
					cFinalidade := aDadosTermo[2][nX][3]

					nBusca := Ascan(aDadosForm,{|x| Alltrim(x[6]) == cCampoTabela})
					If nBusca > 0
						cAceite := IIF(Empty(aDadosForm[nBusca][3]), "0", "1")
					Else
						cAceite := "0" 
					EndIf

					oModelB6W:SetValue("B6W_CPF", cCPFBeneficiario)
					oModelB6W:SetValue("B6W_NOME", Upper(cNomeBeneficiario))
					oModelB6W:SetValue("B6W_DADPES", cDadoPessoal)
					oModelB6W:SetValue("B6W_ACEITE", cAceite)
					oModelB6W:SetValue("B6W_DATA", dDataBase)
					oModelB6W:SetValue("B6W_HORA", cHorario)
					oModelB6W:SetValue("B6W_LOGIN", cLogin)
					oModelB6W:SetValue("B6W_CAMPO", cCampoTabela)
					oModelB6W:SetValue("B6W_FINALI", cFinalidade)
					oModelB6W:SetValue("B6W_PROTOC", cProtocolo)
				EndIf
			Next nX
		EndIf

		If oModel:VldData()
			oModel:CommitData()
			lRetorno := .T.
		Else
			lRetorno := .F.
		EndIf

		oModel:DeActivate()
		oModel:Destroy()
		oModel := NIL
	EndIf

Return lRetorno

//----------------------------------------------------------------------------
/*/{Protheus.doc} ValMacroComp
Nao permite retornar retornar as especialidades que estao bloqueadas para o 
os dados cadastrais no portal do prestador

Esta funcao esta sendo chamada no layout PLSALTRDAF campo B7C_VALCMP

@version Protheus 12
/*/
//----------------------------------------------------------------------------
Function ValMacroComp()

	Local lRetComp := .F.

	If EMPTY(BAX->BAX_DATBLO)
		lRetComp := .T.
	
	ElseIf BAX->BAX_DATBLO > dDatabase
		lRetComp := .T.
	EndIf

Return lRetComp

//----------------------------------------------------------------------------
/*/{Protheus.doc} GetVldFam
Verifica se a familia esta bloqueda.

@author Cesar Almeida
@since 05/07/2022
@version Protheus 12
/*/
//----------------------------------------------------------------------------
WSMETHOD GetVldFam WSRECEIVE UserCode,DataAux WSSEND WSNULL WSSERVICE PLCADWEB

Local lRetorno := .T.

If PrtChkUser( ::UserCode , "PLCADWEB", "GetVldFam" )

  ::WSNULL := "true|" + iif(PLVLDFAM(::DataAux),"true","false")
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno



