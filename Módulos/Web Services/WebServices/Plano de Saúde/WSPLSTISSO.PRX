#INCLUDE "PROTHEUS.CH"
#INCLUDE "ERROR.CH"
#INCLUDE "XMLXFUN.CH"
#INCLUDE "WSPLSTISSO.ch"
//Ŀ
// Define de tipos de WS de retorno										 
//
#DEFINE RESPOSTATISSSTRING "respostaTISSString"
#DEFINE RESPOSTAMENSAGEMTISSZIP "tissTransmiteMensagemZIP_OperationResponse"
#DEFINE PROTOCOLORECEBIMENTO "protocoloRecebimento"
#DEFINE RECIBOCANCELAGUIA "reciboCancelaGuiaWS"

#DEFINE SITUACAOAUTORIZACAO "situacaoAutorizacao"
#DEFINE SITUACAOAUTWS "situacaoAutorizacaoWS"

#DEFINE SITUACAOPROTOCOLO "situacaoProtocolo"
#DEFINE DEMONSTRATIVORETORNO "DemonstrativoRetorno"

#DEFINE RETORNOELEGIBILIDADE "retornoElegibilidade"
#DEFINE RESPOSTAELEGIBILIDADE "respostaElegibilidade"
#DEFINE RESPOSTAELEWS "respostaElegibilidadeWS"

#DEFINE AUTORIZACAOPROCEDIMENTO "autorizacaoProcedimento"
#DEFINE AUTORIZACAOPROCWS "autorizacaoProcedimentoWS"
#DEFINE AUTORIZACAOSERVICO "autorizacaoServico"

#DEFINE PROTOCOLORECEBIMENTORECURSO "recebimentoRecursoGlosa"
#DEFINE SITUACAOPROTOCOLORECURSO "situacaoProtocoloRecurso"

#DEFINE SOLICITACAODEMONSTRATIVORETORNOWS "solicitacaodemonstrativoretorno"
#DEFINE DEMONSTRATIVORETORNOWS "demonstrativoRetornoWS"

//Ŀ
// Staticas																 
//
STATIC cSemaforo   	:= "PLSXML973ON.SMF"
STATIC cFileTmp	   	:= "XMLTMPON"
STATIC cTRecFault  	:= "PROTOCOLO_RECEBIMENTO"
/*/


Ŀ
Funo	 tissTransmiteMensagemAutor   Alexander Santos  Data  13.06.08 
Ĵ
Descrio Transacao Web Service Tiss Transmite Mensagem e a Zip				
ٱ


/*/
Function tissTransmiteMensagem()
	LOCAL cRet	 := ""
	LOCAL cRes	 := Iif( At("TISSTRANSMITEMENSAGEMZIP",Upper(httpHeadIn->MAIN) )>0,RESPOSTAMENSAGEMTISSZIP,RESPOSTATISSSTRING)

	cTRecFault 	 := "PROTOCOLO_RECEBIMENTO"
	//Ŀ
	// Verfica se a versao suporta esta transacao								 
	//
	If Upper(httpHeadIn->MAIN)=="TISSTRANSMITEMENSAGEMZIP" .And. TISVERS == "2.01.02"
		cRet := HttpSoapFault(cRes,"9903",STR0018+TISVERS+STR0008,"Verificar parametro de controle de versao MV_TISSVER")//"Transao no suportada nesta verso [ " //"]"
	Else
		cRet := ProcOnLine(cRes)
	EndIf
	//Ŀ
	// Fim da Funcao															 
	//
Return StrTran( StrTran( StrTran( cRet ,Chr(13),""),Chr(10),""),Chr(9),"")


/*/


Ŀ
Funo	 tissVerificaElegibilidadeAutor Alexander Santos  Data  13.06.08 
Ĵ
Descrio Transacao Web Service Verifica Elegibilidade						  
ٱ


/*/
Function tissVerificaElegibilidade()
	LOCAL cRet := ""
	LOCAL cTissVer	:=  ""

	LOCAL cEnv := GetEnvServer()
	LOCAL cEmp := AllTrim(GETPVPROFSTRING(cEnv,"JEMP","",GetADV97()))
	LOCAL cFil := AllTrim(GETPVPROFSTRING(cEnv,"JFIL","",GetADV97()))
	LOCAL lLogTissOn := .F.

	If !Empty(cEmp) .And. !Empty(cFil)
		RpcSetEnv( cEmp,cFil,,,"PLS",,)
	else
        return "A ENVIRONMENT ["+cEnv+" ] no tem declarada as variaveis JEMP e JFIL"
	EndIf

	lLogTissOn := Iif(GetNewPar("MV_PTLOGTO","0")=="1",.T.,.F.)
	If lLogTissOn
		PlsPtuLog("------------------------------------------------------------------", "tissonanalise.log")
		PlsPtuLog(PLSRetTime() + " - Iniciando tissVerificaElegibilidade (WSPLSTISSO)", "tissonanalise.log")
	EndIf

	cTissVer	:=  PGETTISVER()

	cTRecFault 	:= "SITUACAO_ELEGIBILIDADE"

	If cTissVer < '3'
		cRetWS := RESPOSTAELEGIBILIDADE
	Else
		cRetWS := RESPOSTAELEWS
	Endif

	cRet := ProcOnLine(RETORNOELEGIBILIDADE,cRetWS)
	//Ŀ
	// Fim da Funcao															 
	//
	If lLogTissOn
		PlsPtuLog(PLSRetTime() + " - Finalizando tissVerificaElegibilidade (WSPLSTISSO)", "tissonanalise.log")
	EndIf

Return StrTran( StrTran( StrTran( cRet ,Chr(13),""),Chr(10),""),Chr(9),"")
/*/


Ŀ
Funo	 tissCancelaGuia          Autor Alexander Santos  Data  13.06.08 
Ĵ
Descrio Transacao Web Service CancelaGuia									  
ٱ


/*/
Function tissCancelaGuia()
	LOCAL cRet  := ""
	LOCAL cEnv := GetEnvServer()
	LOCAL cEmp := AllTrim(GETPVPROFSTRING(cEnv,"JEMP","",GetADV97()))
	LOCAL cFil := AllTrim(GETPVPROFSTRING(cEnv,"JFIL","",GetADV97()))

	If !Empty(cEmp) .And. !Empty(cFil)
		RpcSetEnv( cEmp,cFil,,,"PLS",,)
	else
        return "A ENVIRONMENT ["+cEnv+" ] no tem declarada as variaveis JEMP e JFIL"
	EndIf

	cRet := PLSCanceGui()
	//Ŀ
	// Fim da Funcao                                                            
	//
Return cRet

/*/


Ŀ
Funo	 tissSolicitacaoProcedimento     Autor Alexander Santos  Data  13.06.08 
Ĵ
Descrio Transacao Web Service Status Autorizacao							         
ٱ


/*/
Function tissSolicitacaoProcedimento()
	LOCAL cRet 		:= ""
	LOCAL cRes 		:= ""
	LOCAL cResAux  := ""
	LOCAL cTissVer	:=""
	LOCAL cEnv := GetEnvServer()
	LOCAL cEmp := AllTrim(GETPVPROFSTRING(cEnv,"JEMP","",GetADV97()))
	LOCAL cFil := AllTrim(GETPVPROFSTRING(cEnv,"JFIL","",GetADV97()))
	LOCAL lLogTissOn := .F.
	Local lDemons := .F.
	Local lSolis  := .F.
	Local lStRec := .F.
	Local cIdInteg := ""

	If !Empty(cEmp) .And. !Empty(cFil)
		RpcSetEnv( cEmp,cFil,,,"PLS",,)
	else
        return "A ENVIRONMENT ["+cEnv+" ] no tem declarada as variaveis JEMP e JFIL"
	EndIf

	If PlsAliasExi("BKG")
		cIdInteg := totvs.protheus.health.plan.integration.monitor.tissonline.InputIntegration(nil,httpOtherContent(),nil,3)
	EndIf

	lLogTissOn := Iif(GetNewPar("MV_PTLOGTO","0")=="1",.T.,.F.)
	If lLogTissOn
		PlsPtuLog("-----------------------------------------------", "tissonanalise.log")
		PlsPtuLog("Iniciando (WSPLSTISSO)", "tissonanalise.log")
		PlsPtuLog(Substr(Dtos(dDataBase),7,2)+"/"+Substr(Dtos(dDataBase),5,2)+"/"+Substr(Dtos(dDataBase),1,4) + " - " + Time(),"tissonanalise.log")
		PlsPtuLog("-----------------------------------------------","tissonanalise.log")
		PlsPtuLog("Soap Recebido:","tissonanalise.log")
		PlsPtuLog(httpOtherContent(),"tissonanalise.log")
	EndIf
	cTissVer	:=  PGETTISVER()

	cTRecFault 	:= "RESPOSTA_SOLICITACAO"
	//Ŀ
	// Verfica qual tipo de solicitacao										 
	//
	Do Case
		Case "TISSSOLICITACAOPROCEDIMENTO" $ Upper(httpHeadIn->MAIN)
			If cTissVer < '3'
				cRes 	:= AUTORIZACAOPROCEDIMENTO
			Else
				cRes 	:= AUTORIZACAOPROCWS
			Endif
			cResAux := AUTORIZACAOSERVICO
		Case "TISSSOLICITACAODEMONSTRATIVORETORNO" $ Upper(httpHeadIn->MAIN)
			cRes := DEMONSTRATIVORETORNOWS
			lDemons := .T.
		Case "TISSSOLICITACAOSTATUSAUTORIZACAO" $ Upper(httpHeadIn->MAIN)
			If cTissVer > '3'
				cRes    := SITUACAOAUTWS
				cResAux := SITUACAOAUTORIZACAO
			Else
				cRes := SITUACAOAUTWS
			Endif
		Case "TISSSOLICITACAOSTATUSPROTOCOLO" $ Upper(httpHeadIn->MAIN)
			cRes := SITUACAOPROTOCOLO
			lSolis := aScan(Httpget->aGets,{|x| x == "WSDL" }) == 0
		Case "TISSSOLICITACAOSTATUSRECURSOGLOSA" $ Upper(httpHeadIn->MAIN)
			cRes := SITUACAOPROTOCOLORECURSO
			lStRec := .T.
		OtherWise
			If cTissVer < '3'
				cRes 	:= AUTORIZACAOPROCEDIMENTO
			Else
				cRes 	:= AUTORIZACAOPROCWS
			Endif
	EndCase

	If lDemons
		cRet := PLDempgOnl()
	elseIf lSolis
		cRet := PLStaProto()
	elseIf lStRec
		cRet := PLStaReGlo()
	else
		cRet := ProcOnLine(cRes,cResAux)
	endIf
	//Ŀ
	// Fim da Funcao															 
	//
	If lLogTissOn
		PlsPtuLog("-----------------------------------------------","tissonanalise.log")
		PlsPtuLog("Finalizando (WSPLSTISSO)","tissonanalise.log")
		PlsPtuLog(Substr(Dtos(dDataBase),7,2)+"/"+Substr(Dtos(dDataBase),5,2)+"/"+Substr(Dtos(dDataBase),1,4) + " - " + Time(),"tissonanalise.log")
		PlsPtuLog("-----------------------------------------------","tissonanalise.log")
		PlsPtuLog("Soap Respondido:","tissonanalise.log")
		PlsPtuLog(cRet,"tissonanalise.log")
	EndIf

	If PlsAliasExi("BKG")
		totvs.protheus.health.plan.integration.monitor.tissonline.InputIntegration(nil,nil,cRet,4,cIdInteg)
	EndIf

Return cRet


//-------------------------------------------------------------------
/*/{Protheus.doc} tissComunicacaoBeneficiario
Transacao Web Service Comunicacao Beneficiario

@author  sakai
@version P12
@since   04/06/19
/*/
//-------------------------------------------------------------------
Function tissComunicacaoBeneficiario(lAuto,cXmlAuto)

	Local cRet  := ""
	Local cEnv  := GetEnvServer()
	Local cEmp  := AllTrim(GETPVPROFSTRING(cEnv,"JEMP","",GetADV97()))
	Local cFil  := AllTrim(GETPVPROFSTRING(cEnv,"JFIL","",GetADV97()))
	Local lLogTissOn := .F.
	Local oComunBen

	Default lAuto   := .F.
	Default cXmlAuto := ""

	if !lAuto
		if !Empty(cEmp) .And. !Empty(cFil)
			RpcSetEnv( cEmp,cFil,,,"PLS",,)
		else
        	return "A ENVIRONMENT ["+cEnv+" ] no tem declarada as variaveis JEMP e JFIL"
		endIf
	endIf

	lLogTissOn := Iif(GetNewPar("MV_PTLOGTO","0")=="1",.T.,.F.)
	if lLogTissOn
		PlsPtuLog("------------------------------------------------------------------", "tissonanalise.log")
		PlsPtuLog(PLSRetTime() + " - Iniciando tissComunicacaoBeneficiario (WSPLSTISSO)", "tissonanalise.log")
	endIf

	oComunBen := PComunBen():New()
	cRet := oComunBen:procXML(lAuto,cXmlAuto)

	FreeObj(oComunBen)
	oComunBen := Nil

	if lLogTissOn
		PlsPtuLog(PLSRetTime() + " - Finalizando tissSolicitacaoProcedimento (WSPLSTISSO)", "tissonanalise.log")
	endIf

Return cRet


/*/


Ŀ
Funo    ProcOnLineAutor   Alexander Santos             Data  13.06.08 
Ĵ
Descrio Processa solicitacao enviada										   
ٱ


/*/
Function ProcOnLine(cTagResposta,cTagResAux,lAuto,cSoapAuto,cAutHeadIn)
	LOCAL lEncod		:= .F.
	LOCAL nI			:= 0
	LOCAL nX			:= 0
	LOCAL nPosFB 		:= 0
	LOCAL nPosSB 		:= 0
	LOCAL cMsg			:= ""
	LOCAL cXml			:= ""
	LOCAL cErro			:= ""
	LOCAL cAviso		:= ""
	LOCAL cNumeSeq		:= ""
	LOCAL cSegArq		:= ""
	LOCAL cFileHas		:= ""
	LOCAL cNodPai		:= ""
	LOCAL cSoap			:= ""
	LOCAL cSoapObj		:= ""
	LOCAL cSoapAux		:= ""
	LOCAL cURLGet 		:= ""
	LOCAL PVirtual		:= ""
	LOCAL cCntType		:= ""
	LOCAL aCntType      := {"TEXT/XML","TEXT/XML; CHARSET=UTF-8","SOAP+XML","APPLICATION/SOAP+XML; CHARSET=UTF-8","TEXT/XML;CHARSET=UTF-8","TEXT/XML;CHARSET=ISO-8859-1","APPLICATION/XML"}
	LOCAL oXmlEnv		:= NIL
	LOCAL oNodFilho		:= NIL
	LOCAL oXml			:= NIL
	LOCAL aRet			:= {}
	LOCAL aMatDir   	:= {}//{DIRSUBRAI,DIRCAIEN,DIRCAISA,DIRPROCE,DIRNAPRO,DIRLOG}
	LOCAL cEnv 			:= GetEnvServer()
	LOCAL cEmp 			:= AllTrim(GETPVPROFSTRING(cEnv,"JEMP","",GetADV97()))
	LOCAL cFil 			:= AllTrim(GETPVPROFSTRING(cEnv,"JFIL","",GetADV97()))
	LOCAL cRdaOri		:= ""//PlsIntPad()
	LOCAL cPrefNS		:= ""//StrTran(NAMESPACE,":","")
	LOCAL cHeadIn       := ""
	Local nPosZ         := ""
	LOCAL cTissVerOn    := ""
	LOCAL lLogTissOn    := .F.
	LOCAL cHttpHost     := ""
	LOCAL cHttpHeadIn   := ""
	local lGrvCxTiss	:= .F.
	local cNameArqVl	:= ""
	local nGetPort := GetPort(4) //O indice 4 indica que ir verificar se o https est ativo, caso sim, retorna o numero da porta

	PRIVATE __cTissWs   := ""
	PRIVATE __cTissTNS	:= ""
	PRIVATE __lTraZip	:= .F.

	DEFAULT cTagResAux  := ""
	DEFAULT lAuto       := .F.
	DEFAULT cSoapAuto   := ""
	DEFAULT cAutHeadIn  := ""

	//So for automacao nao precisamos inicializar o ambiente
	If !lAuto
		If !Empty(cEmp) .And. !Empty(cFil)
			RpcSetEnv( cEmp,cFil,,,"PLS",,)
		EndIf
	EndIf

	cHeadIn := iif(lAuto,cAutHeadIn,httpHeadIn->MAIN)

	nPosZ      := At( "V3" , cHeadIn ) + 1
	lGrvCxTiss	:= GetNewPar("MV_PTIONGS",'0') == '1'

	//Ŀ
	// Define de pastas	  													 
	//
	PRIVATE DIRRAIZ 	:= PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
	PRIVATE TISVERS	    := ""
	PRIVATE __ENCOD     := ""
	PRIVATE VERARQWSDL  := ""
	PRIVATE DIRONLINE 	:= PLSMUDSIS( "ONLINE\" )
	PRIVATE DIRSUBRAI 	:= DIRRAIZ+DIRONLINE
	PRIVATE DIRTEMP	  	:= PLSMUDSIS( DIRRAIZ+"TEMP\" )
	PRIVATE DIRCAIEN  	:= PLSMUDSIS( DIRSUBRAI+"CAIXAENTRADA\" )
	PRIVATE DIRCAISA  	:= PLSMUDSIS( DIRSUBRAI+"CAIXASAIDA\" )
	PRIVATE DIRPROCE  	:= PLSMUDSIS( DIRSUBRAI+"PROCESSADOS\" )
	PRIVATE DIRNAPRO  	:= PLSMUDSIS( DIRSUBRAI+"NAOPROCESSADOS\" )
	PRIVATE DIRLOG 		:= PLSMUDSIS( DIRSUBRAI+"LOG\" )
	PRIVATE DIRSCHEMA 	:= PLSMUDSIS( DIRRAIZ+"SCHEMAS\" )
	PRIVATE NAMESPACE  	:= ""
	PRIVATE TISS_DEBUG	:=IiF(GetNewPar("MV_PLTIDEB","1")=="1",.T.,.F.)
	PRIVATE LOG_CONOUT 	:= IiF(GetNewPar("MV_PLTILOG","1")=="1",.T.,.F.)
	PRIVATE cComplex 	:= ''
	PRIVATE cRdaCom 	:= ''

	cSoap := iif(lAuto,cSoapAuto,HttpOtherContent())
	cTissVerOn	:= Substr(cSoap,At("Padrao>", cSoap) + Len("Padrao>"),7)
	if empty(cTissVerOn)
		BA0->(DbSetOrder(1))
		if BA0->(DbSeek(xFilial("BA0")+PlsIntPad()))
			cTissVerOn := If( nPosZ > 1, STRTRAN( substr(cHeadIn, nPosZ, 7), "_", "."), Alltrim(BA0->BA0_TISVER) )
		else
			cTissVerOn := If( nPosZ > 1, STRTRAN( substr(cHeadIn, nPosZ, 7), "_", "."), "30000")
		endIf
	endIf

	//Verifica se tem a verso do TISS no endpoint do WS e substitui, ex:
	//TISSVERIFICAELEGIBILIDADEV4_00_01 -> TISSVERIFICAELEGIBILIDADE
	__cTissWs  := Iif( ( nPos := At( "V"+StrTran( cTissVerOn, ".", "_" ) , cHeadIn ) ) > 0, Left(cHeadIn,nPos-1), cHeadIn)
	__cTissTNS := "http://www.ans.gov.br/tiss/ws/tipos/"+__cTissWs
	__lTraZip  := ( Upper(__cTissWs) == "TISSTRANSMITEMENSAGEMZIP" )

	TISVERS    := cTissVerOn
	__ENCOD    :=  Iif(TISVERS != "2.02.01",'UTF-8','ISO-8859-1')
	VERARQWSDL := "V"+StrTran( TISVERS ,".","_" )+".WSDL"
	NAMESPACE  :=  Iif(TISVERS < "2.02.02" .OR. TISVERS >= "3" ,"ans:","ansTISS:")

	lLogTissOn := Iif(GetNewPar("MV_PTLOGTO","0")=="1",.T.,.F.)
	If lLogTissOn
		PlsPtuLog(PLSRetTime() + " - Iniciando ProcOnLine (WSPLSTISSO)", "tissonanalise.log")
	EndIf

	cRdaOri		:= PlsIntPad()
	cPrefNS		:= StrTran(NAMESPACE,":","")
	aMatDir   	:= {DIRSUBRAI,DIRCAIEN,DIRCAISA,DIRPROCE,DIRNAPRO,DIRLOG}

	//foi feita a troca da tag de resposta aqui pois na funcao da elegibilidade a variavel da versao nao existe ainda
	If (TISVERS >= "3" .AND. cTagResposta == RETORNOELEGIBILIDADE)
		cTagResposta := RESPOSTAELEWS
	EndIf

	If (TISVERS >= "3")
		cTissVerOn := TISVERS
	EndIf

	//Ŀ
	// Se for transacao com objeto												 
	//
	lObj := ( !Upper(__cTissWs) $ "TISSTRANSMITEMENSAGEMZIP" )
	//Ŀ
	// Define o tipo de pacote													 
	//
	HttpCtType( "text/xml; charset="+__ENCOD )
	//Ŀ
	// Verifica se as pastas base estao criadas e cria							 
	//
	If ExistDir(DIRRAIZ)
		//Ŀ
		// Verifica se as pastas base estao criadas e cria							 
		//
		For nI:=1 To  Len(aMatDir)
			If !ExistDir(aMatDir[nI])
				If MakeDir( aMatDir[nI] ) <> 0
					LogOnl(STR0003+aMatDir[nI]+STR0004)//"Impossel criar diretorio ( "###" )"
					Return ""
				EndIf
			EndIf
		Next
	Else
		LogOnl(STR0005+DIRRAIZ+STR0006)//"Diretorio ( "###" ) no encontrado"
		Return ""
	EndIf
	//Ŀ
	// Caso o debug esteja ligado vai logar na console e em arquivo			 
	//
	If TISS_DEBUG
		LogOnl( Replicate("*",79) )
		LogOnl(STR0007+__cTissWs+STR0008)//"Recebido do WebService [ "###" ]"
		LogOnl("")
		LogOnl(HttpInfo())
		LogOnl("")
		LogOnl(Replicate("*",79) )
	Endif
	//Ŀ
	// Carrega o WSDL para pegar o endereco de TNS								 
	//
	oXml := XmlParserFile(DIRSCHEMA+__cTissWs+VERARQWSDL,"_",@cErro,@cAviso)

	If Empty(cErro) .And. Empty(cAviso)
		If XmlNodeExist(oXml,"_WSDL_DEFINITIONS") .And. XmlNodeExist(oXml:_WSDL_DEFINITIONS,"_XMLNS_TNS")
			__cTissTNS := oXml:_WSDL_DEFINITIONS:_XMLNS_TNS:TEXT
		ElseIf XmlNodeExist(oXml,"_DEFINITIONS") .And. XmlNodeExist(oXml:_DEFINITIONS,"_XMLNS_TNS")
			__cTissTNS := oXml:_DEFINITIONS:_XMLNS_TNS:TEXT
		EndIf
	Else
		cMsg := Iif( !Empty(cErro) ,STR0009+cErro,"")//" Erro: "
		cMsg += Iif( !Empty(cAviso),STR0010+cAviso,"")//" Aviso: "
		LogOnl(cMsg)

		Return HttpSoapFault(cTagResposta,"9902",STR0012+__cTissWs+VERARQWSDL,"",,,,lObj)//"Transao no suportada : "
	EndIf
	//Ŀ
	// Verifica se e uma solicitacao do WSDL									 
	//
	If (!lAuto .And. aScan(Httpget->aGets,{|x| x == "WSDL" }) > 0 .And. Len(Httpget->aGets)==1) .Or. (lAuto .And. Empty(cSoapAuto))

		cHttpHost   := iif(lAuto,"localhost:2000"                 ,httpHeadIn->Host)
		cHttpHeadIn := iif(lAuto,"/portal/"+cAutHeadIn+".apw?wsdl",httpHeadIn->aHeaders[1])
		__cTissWs   := iif(lAuto,cAutHeadIn                       ,httpHeadIn->MAIN)

		//
		// Procurando pasta virtual na URL
		//
		PVirtual := "/"
		If lAuto .Or. Len(httpHeadIn->aHeaders) >= 1
			nPosFB 	:= At("/",cHttpHeadIn)
			If nPosFB>0
				cURLGet := SubStr(cHttpHeadIn,nPosFB+1)
				nPosSB 	:= At("/",cURLGet)+1
				If nPosSB>0

					PVirtual := SubStr(cHttpHeadIn,nPosFB,nPosSB)
					If At(".APW",Upper(PVirtual) ) > 0 .Or. At("?WSDL",Upper(PVirtual) ) > 0
						PVirtual := "/"
					EndIf

				EndIf
			EndIf
		EndIf
		FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01', "Pasta virtual: "+PVirtual , 0, 0, {})

		//Ŀ
		// Verifica se e wsdl da versao 2 ou 3										 
		//
		If XmlNodeExist(oXml,"_WSDL_DEFINITIONS") .And. XmlNodeExist(oXml:_WSDL_DEFINITIONS,"_WSDL_SERVICE") .And.;
				XmlNodeExist(oXml:_WSDL_DEFINITIONS:_WSDL_SERVICE,"_WSDL_PORT") .And. XmlNodeExist(oXml:_WSDL_DEFINITIONS:_WSDL_SERVICE:_WSDL_PORT,"_SOAP_ADDRESS") .And.;
				XmlNodeExist(oXml:_WSDL_DEFINITIONS:_WSDL_SERVICE:_WSDL_PORT:_SOAP_ADDRESS,"_LOCATION")

			oXml:_WSDL_DEFINITIONS:_WSDL_SERVICE:_WSDL_PORT:_SOAP_ADDRESS:_LOCATION:TEXT := "http://"+cHttpHost+PVirtual+__cTissWs + "V" + STRTRAN(TISVERS, ".", "_")+".apw"


		ElseIf  XmlNodeExist(oXml,"_DEFINITIONS") .And. XmlNodeExist(oXml:_DEFINITIONS,"_SERVICE") .And.;
				XmlNodeExist(oXml:_DEFINITIONS:_SERVICE,"_PORT") .And. XmlNodeExist(oXml:_DEFINITIONS:_SERVICE:_PORT,"_SOAP_ADDRESS") //.And.;
			//XmlNodeExist(oXml:_DEFINITIONS:_SERVICE:_PORT:_SOAP_ADDRESS,"_LOCATION")
			//na versao 3.02.00 o atribudo location nao esta sendo carregado no protheus, entao eu criei ele forcadamente
			If !XmlNodeExist(oXml:_DEFINITIONS:_SERVICE:_PORT:_SOAP_ADDRESS,"_LOCATION")
				XmlNewNode(oXml:_DEFINITIONS:_SERVICE:_PORT:_SOAP_ADDRESS, "_LOCATION", "_LOCATION", "ATT" )
				oXml:_DEFINITIONS:_SERVICE:_PORT:_SOAP_ADDRESS:_LOCATION:REALNAME 	:=	"location"
			Endif

			If "V3" $ __cTissWs
				oXml:_DEFINITIONS:_SERVICE:_PORT:_SOAP_ADDRESS:_LOCATION:TEXT := iif(nGetPort > 0,"https://"+cHttpHost+PVirtual+__cTissWs +".apw","http://"+cHttpHost+PVirtual+__cTissWs +".apw")
			else
				oXml:_DEFINITIONS:_SERVICE:_PORT:_SOAP_ADDRESS:_LOCATION:TEXT := iif(nGetPort > 0,"https://"+cHttpHost+PVirtual+__cTissWs +".apw","http://"+cHttpHost+PVirtual+__cTissWs +".apw")
			endIf
		EndIf

		SAVE oXml XMLSTRING cXML
		//Ŀ
		// Caso o debug esteja ligado vai logar na console e em arquivo			 
		//
		If TISS_DEBUG
			LogOnl( Replicate("*",79) )
			LogOnl(STR0011)//"Retornando WSDL ao Cliente"
			LogOnl("")
			LogOnl(cXML)
			LogOnl("")
			LogOnl(Replicate("*",79) )
		EndIf
		//Ŀ
		// Retorna o WSDL como solicitado											 
		//
		Return cXML
	EndIf
	//Ŀ
	// Verifica se e um pacote valido											 
	//
	If !lAuto
		cCntType := Upper(HttpRCTType())
		If aScan(aCntType,{|x| x == cCntType}) <= 0
			cDescErro := STR0012 + " - "
			cDescErro += cCntType
			Return HttpSoapFault(cTagResposta,"9902",cDescErro,"",,,,lObj)//"Transao no suportada : "
		EndIf
	EndIf
	//Ŀ
	// Apos as validaoes acima entende-se que e um pacote soap valido e iniciar
	// o desmembramento do pacote para retirada do xml							 
	//
	cSoap := iif(lAuto,cSoapAuto,HttpOtherContent())
	//Ŀ
	// Verifica se e transacao obj												 
	//
	If lObj .Or. __lTraZip
		nPos := At("BODY",Upper(cSoap))
		cSoapObj := Substr(cSoap,nPos+4,len(cSoap))
		nPos := At(">",Upper(cSoapObj))
		cSoapObj := Substr(cSoapObj,nPos+1,len(cSoapObj))

		nPos := At("BODY>",Upper(cSoapObj)) //Com o sinal > para no pegar o texto body dentro da tag se existir.
		for nX := 1 to nPos
			if Substr(cSoapObj,nPos-nX,1) == "<"
				cSoapObj := Substr(cSoapObj,1,nPos-(nX+1))
				Exit
			endif
		next
		If !__lTraZip
			If TISVERS != "2.02.01"
				cSoapAux := EncodeUtf8(cSoapObj)
				If ValType(cSoapAux) != 'U'
					cSoapObj := cSoapAux
					lEncod	 := .T.
				EndIf
			EndIf
		EndIf
	Else
		cSoapObj := cSoap
	EndIf
	//Ŀ
	// Correcao do nome da transacao ate a ANS acertar.						 
	//
	cSoapObj := StrTran(cSoapObj,"solicitacaoStatusAutorizacao","solicitaStatusAutorizacao")
	//Ŀ
	// Parse do XML de String													 
	//

	If !lObj
		oXmlEnv	:= XmlParser( cSoapObj ,"_",@cErro,@cAviso )

		If Empty(cErro) .And. Empty(cAviso)
			cNodPai	:= "oXmlEnv"
			While .T.
				If XmlChildCount( Eval( &( "{||"+cNodPai+"}" ) ) ) > 0
					oNodFilho := XmlGetchild( Eval( &( "{||"+cNodPai+"}" ) ) , XmlChildCount( Eval( &( "{||"+cNodPai+"}" ) ) ))
					If oNodFilho:Type <> "NOD"
						Exit
					EndIf

					If "MENSAGEMTISSZIP" $ Upper(oNodFilho:REALNAME)
						oNodFilho := XmlGetchild( Eval( &( "{||"+cNodPai+"}" ) ) , XmlChildCount( Eval( &( "{||"+cNodPai+"}" ) ) ))
						cNodPai += ":_"+StrTran(StrTran(oNodFilho:REALNAME,":","_"),"-","_")
						cNodPai += ":_"+StrTran(StrTran(oNodFilho:REALNAME,":","_"),"-","_")
						Exit
					EndIf
					//Ŀ
					// Monta NO pai															 
					//
					cNodPai += ":_"+StrTran(StrTran(oNodFilho:REALNAME,":","_"),"-","_")
				Else
					Exit
				EndIf
			EndDo
			//Ŀ
			// Verifica se existe algum conteudo no pacote								 
			//
			If Empty( Eval( &("{||"+cNodPai+":TEXT }") ) )
				Return HttpSoapFault(cTagResposta,"9904",STR0013,"",,,,lObj) //"Pacote SOAP-XML Vazio"
			Endif
		Else
			cMsg := Iif( !Empty(cErro) ,STR0009 +cErro,"") //" Erro: "
			cMsg += Iif( !Empty(cAviso),STR0010+cAviso,"") //" Aviso: "

			LogOnl(cMsg)
			Return HttpSoapFault(cTagResposta,"9905",cMsg,"Erro ao tentar fazer o parse do arquivo xml",,,,lObj)
		EndIf
	EndIf
	//Ŀ
	// Tudo ok Carrego o conteudo do XML										 
	//
	If lObj
		//Ŀ
		// Parse para verificacao se o xml esta ok								 	 
		//
		oXml := XmlParser( cSoapObj ,"_",@cErro,@cAviso )

		If Empty(cErro) .And. Empty(cAviso)
			//Ŀ
			// Correcao do nome da transacao ate a ANS acertar.						 
			//
			__cTissWs := StrTran(__cTissWs,Upper("solicitacaoStatusAutorizacao"),Upper("solicitaStatusAutorizacao"))
			//Ŀ
			// Ajusto o Xml														     
			//
			cXml :=  TranXml( AllTrim(cSoapObj),"E")
		Else
			cMsg := Iif( !Empty(cErro) ,STR0009 +cErro,"") //" Erro: "
			cMsg += Iif( !Empty(cAviso),STR0010+cAviso,"") //" Aviso: "
			FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01', cMsg , 0, 0, {})
			Return HttpSoapFault(cTagResposta,"9906",cMsg,"Erro ao tentar fazer o parse do arquivo xml",,,,lObj)
		EndIf
		//Ŀ
		// Ajuste de encoding														 
		//
		If !lEncod
			If TISVERS != "2.02.01"
				cSoapAux := EncodeUtf8(cXml)
				If ValType(cSoapAux) != 'U'
					cXml := cSoapAux
				EndIf
			EndIf
		EndIf
		//Ŀ
		// Parse do xml ajustado													 
		//
		oXml := XmlParser( cXml ,"_",@cErro,@cAviso )
	Else
		//Ŀ
		// Pega conteudo do obj													 
		//
		cXml := Eval( &("{||"+cNodPai+":TEXT }") )
		//Ŀ
		// Descompacta ZIP															 
		//
		If __lTraZip
			cXml := DECODE64(cXml)
		EndIf
		//Ŀ
		// Caso o debug esteja ligado vai logar na console e em arquivo			 
		//
		If TISS_DEBUG
			LogOnl( Replicate("*",79) )
			LogOnl(STR0014) //"XML descompactado"
			LogOnl("")
			LogOnl(cXML)
			LogOnl("")
			LogOnl(Replicate("*",79) )
		EndIf
		//Ŀ
		// Monta OBJ																 
		//
		oXml := XmlParser( HtmlTags( cXml ) ,"_",@cErro,@cAviso )
	EndIf
	//Ŀ
	// Verifica se ok no parse													 
	//
	If Empty(cErro) .And. Empty(cAviso)
		SAVE oXml XMLSTRING cXML
	Else
		cMsg := Iif( !Empty(cErro) ,STR0009+cErro,"") //" Erro: "
		cMsg += Iif( !Empty(cAviso),STR0010+cAviso,"") //" Aviso: "
		FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01', cMsg , 0, 0, {})
		Return HttpSoapFault(cTagResposta,"9907",cMsg,"Erro ao tentar fazer o parse do arquivo xml",,,,lObj)
	EndIf
	//Ŀ
	// Pega o sequencial do arquivo e o hash do arquivo						 
	//
	If 	Eval( &( "{|| XmlNodeExist(oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_IDENTIFICACAOTRANSACAO, '_" + cPrefNS + "_SEQUENCIALTRANSACAO') } " ) ) .And.;
			Eval( &( "{|| XmlNodeExist(oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_EPILOGO, '_" + cPrefNS + "_HASH') } " ) )

		If TISVERS >= "3" .And. Eval( &( "{|| XmlNodeExist(oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_ORIGEM, '_"  + cPrefNS + "_REGISTROANS' ) } " ) )
			cComplex := "_REGISTROANS, '_"
			cRdaCom := "_REGISTROANS"

		ElseIf TISVERS >= "3" .And. Eval( &( "{|| XmlNodeExist(oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_ORIGEM, '_"  + cPrefNS + "_IDENTIFICACAOPRESTADOR' ) } " ) )
			cComplex := "_IDENTIFICACAOPRESTADOR, '_"
			cRdaCom := "_IDENTIFICACAOPRESTADOR:_"
		Else
			cComplex := "_CODIGOPRESTADORNAOPERADORA, '_"
			cRdaCom := "_CODIGOPRESTADORNAOPERADORA:_"
		EndIf

		If XmlNodeExist(oXml:_ans_MENSAGEMTISS:_ans_CABECALHO,"_ans_ORIGEM") //Verifica se foi informado a TAG ORIGEM
			If Eval( &( "{|| XmlNodeExist(oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_ORIGEM, '_"  + cPrefNS + "_REGISTROANS' ) } " ) )

				cRdaOri  := AllTrim( Eval( &( "{|| oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_ORIGEM:_" + cPrefNS + cRdaCom + "  } " ) ):Text )

			ElseIf Eval( &( "{|| XmlNodeExist(oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_ORIGEM:_" + cPrefNS + cComplex + cPrefNS + "_CODIGOPRESTADORNAOPERADORA' ) } " ) )

				cRdaOri  := AllTrim( Eval( &( "{|| oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_ORIGEM:_" + cPrefNS + cRdaCom + cPrefNS + "_CODIGOPRESTADORNAOPERADORA  } " ) ):Text )

			ElseIf Eval( &( "{|| XmlNodeExist(oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_ORIGEM:_" + cPrefNS + cComplex + cPrefNS + "_CPF') } " ) )

				cRdaOri  := AllTrim( Eval( &( "{|| oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_ORIGEM:_" + cPrefNS + cRdaCom + cPrefNS + "_CPF  } " ) ):Text )

			ElseIf Eval( &( "{|| XmlNodeExist(oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_ORIGEM:_" + cPrefNS + cComplex + cPrefNS + "_CNPJ' ) } " ) )

				cRdaOri  := AllTrim( Eval( &( "{|| oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_ORIGEM:_" + cPrefNS + cRdaCom + cPrefNS + "_CNPJ  } " ) ):Text )

			EndIf
		EndIf

		cNumeSeq 	:= Eval( &( "{|| oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_IDENTIFICACAOTRANSACAO:_" + cPrefNS + "_SEQUENCIALTRANSACAO } " ) ):Text
		cSegArq  	:= StrZero(Val(cNumeSeq),20)
		cFileHas 	:= Eval( &( "{|| oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_EPILOGO:_" + cPrefNS + "_HASH } " ) ):Text
		cTRecFault	:= TranDePara( Upper( Eval( &( "{|| oXml:_" + cPrefNS + "_MENSAGEMTISS:_" + cPrefNS + "_CABECALHO:_" + cPrefNS + "_IDENTIFICACAOTRANSACAO:_" + cPrefNS + "_TIPOTRANSACAO } " ) ):Text ) )
	Else
		Return HttpSoapFault(cTagResposta,"9909",STR0015,"",,,,lObj) //"Estrutura recebida invalida."
	EndIf

	//Ŀ
	// Grava o arquivo para processamento									   	 
	//
	if lGrvCxTiss
		cXML := '<?xml version="1.0" encoding="ISO-8859-1"?>'+Chr(10)+cXML
		cNameArqVl := cXML
	else
		nH := FCreate( DIRCAIEN+cSegArq+"_"+cFileHas+".XML",2)
		FWrite(nH,'<?xml version="1.0" encoding="ISO-8859-1"?>'+Chr(10)+ cXML)
		FClose(nH)
		cNameArqVl := DIRCAIEN+cSegArq+"_"+cFileHas+".XML"
	endif

	If (TISVERS >= "3")
		//faz a validao do XML gerado pelo TranXml com o XSD
		If ( (!lGrvCxTiss .and. !XmlFVldSch(cNameArqVl, DIRSCHEMA+"TISSV"+StrTran(TISVERS, ".", "_")+".XSD", @cErro,@cAviso)) .or.;
			(lGrvCxTiss .and. !XmlSVldSch(cNameArqVl, DIRSCHEMA+"TISSV"+StrTran(TISVERS, ".", "_")+".XSD", @cErro,@cAviso))	)
		cMsg := Iif( !Empty(cErro) ,STR0009 +cErro,"") //" Erro: "
		cMsg += Iif( !Empty(cAviso),STR0010+cAviso,"") //" Aviso: "
		FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01', cMsg , 0, 0, {})
		Return HttpSoapFault(cTagResposta,"5002",cMsg,"XML recebido no est no formato correto.",,,,lObj)
	EndIf
	EndIf

	//Ŀ
	// Chama rotina do processamento de XML no plsa973							 
	//
	if !lGrvCxTiss
		aRet := PLSA973PRO(cNameArqVl,DIRONLINE,.T.,nil,nil,.T., cTissVerOn)
	else
		aRet := P973SoPrFi(cXML,cTissVerOn,cFileHas)
	endif
	//Ŀ
	// Se nao teve mensagem de erro monta pacote								 
	//
	If Empty(aRet[1])
		cXml := iif( !lGrvCxTiss, MemoRead(DIRCAISA+aRet[2]), aRet[6] )
		//Ŀ
		// Compacta Retorno														 
		//
		If __lTraZip
			cXml := ENCODE64(cXml)
		EndIf
	Else
		Return HttpSoapFault(cTagResposta,Iif(len(aRet)>=5.and.!Empty(aRet[5]),aRet[5],"9911"),aRet[1],"Retorno referente ao processamento do arquivo",cNumeSeq,cRdaOri,If(!Empty(aRet[1]),'descricaoGlosa',cTagResAux),lObj,aRet[1])
	EndIf

	//Ŀ
	// Troca XML																 
	//
	If lObj
		cXml := TranXml( AllTrim(cXml),"R",cTagResposta,cTagResAux )
	EndIf
	//Ŀ
	// Monta o pacote de retorno												 
	//
	cXml := HttpEnvSoap(cXml,cTagResposta)
	//Ŀ
	// Fim da Rotina															 
	//
	If lLogTissOn
		PlsPtuLog(PLSRetTime() + " - Finalizando ProcOnLine (WSPLSTISSO)", "tissonanalise.log")
	EndIf

Return cXml
/*/


Ŀ
Funo	 HtmlTags    Autor   Alexander Santos           Data  13.06.08 
Ĵ
Descrio Troca caracters por simbolos para montar as tags				    
ٱ


/*/
STATIC Function HtmlTags(cXml)

	cXml := StrTran(cXml,"&lt;","<")
	cXml := StrTran(cXml,"&gt;",">")
	cXml := StrTran(cXml,"&amp;","&")
	cXml := StrTran(cXml,"&quot;",'"')
	//Ŀ
	// Fim da rotina															
	//
Return cXml
/*/


Ŀ
Funo	 IsVldMacro  Autor   Alexander Santos           Data  13.06.08 
Ĵ
Descrio Para auxiliar no DEBUG											
ٱ


/*/
STATIC Function IsVldMacro(cString)
	//Ŀ
	// Vazio																	 
	//
	If Empty( cString := alltrim(cString) )
		Return .F.
		//Ŀ
		// Primeiro caracter nao aCRLFabetico										 
		//
	ElseIf !upper(left(cString,1))$"ABCDEFGHIJKLMNOPQRSTUVWXYZ_"
		Return .F.
	Else
		While !Empty(cString)
			If !Upper(left(cString,1))$"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_"
				Return .f.
			EndIf
			cString := SubStr(cString,2)
		Enddo
	Endif
	//Ŀ
	// Fim da rotina															
	//
Return .T.
/*/


Ŀ
Funo	 VarExInfo   Autor   Alexander Santos           Data  13.06.08 
Ĵ
Descrio Para auxiliar no DEBUG											
ٱ


/*/
STATIC Function VarExInfo(cId,cMain,lHtml,lEcho)
	LOCAL nI
	LOCAL aInfo := &(cId+"->"+cMain)
	LOCAL cRet  := VarInfo(cId, aInfo ,,lHtml,lEcho )
	//Ŀ
	// Monta retorno															 
	//
	If ValType(aInfo)="A"
		For nI := 1 to len(aInfo)
			If Empty(aInfo[nI])
				cRet += VarInfo(aInfo[nI]+" (EMPTY)" , NIL ,,lHtml,lEcho)
			ElseIf !IsVldMacro(aInfo[nI])
				cRet += VarInfo(aInfo[nI]+" (INVALID)" , NIL ,,lHtml,lEcho)
			Else
				cRet += VarInfo(aInfo[nI] , &(cId+"->"+aInfo[nI]) ,,lHtml,lEcho)
			EndIf
		Next
	EndIf
	//Ŀ
	// Fim da Rotina															 
	//
Return cRet
/*/


Ŀ
Funo	 HttpEnvSoap Autor   Alexander Santos           Data  13.06.08 
Ĵ
Descrio Monta o pacote soap												
ٱ


/*/
STATIC Function HttpEnvSoap(cXml,cTagResposta)

	LOCAL cSoap 	:= '<?xml version="1.0" encoding="'+__ENCOD+'"?>'+Chr(10)
	LOCAL cSubName  := "ans:"
	Local cMV_PLTOTNS := GetNewPar("MV_PLTOTNS","")//TISS Online TNS
	__cTissTNS := "http://www.ans.gov.br/padroes/tiss/schemas" //Ajustando a TAG pois o anterior no est mais disponvel
	//Ŀ
	// Verifica o tipo de retorno												 
	//
	If lObj
		cSoap += '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:'+StrTran(NAMESPACE,":","")+'="http://www.ans.gov.br/padroes/tiss/schemas" >'+Chr(10)
		cSoap += '<soap:Body>'+Chr(10)

		If Empty(cMV_PLTOTNS)
			cSoap += '<'+cSubName+cTagResposta+' xmlns:'+"ans"+'="'+__cTissTNS+'">'+Chr(10)
		Else
			cSoap += '<'+cSubName+cTagResposta+' xmlns:'+"ans"+'="'+cMV_PLTOTNS+'" xmlns:ns2="http://www.w3.org/2000/09/xmldsig#">'+Chr(10)
		EndIf
		cSoap += cXml+Chr(10)
		cSoap += '</'+cSubName+cTagResposta+'>'+Chr(10)

		cSoap += '</soap:Body>'+Chr(10)
		cSoap += '</soap:Envelope>'+Chr(10)

	ElseIf __lTraZip

		cSoap += '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">'+Chr(10)
		cSoap += '<soap:Body>'+Chr(10)
		cSoap += '<'+cSubName+cTagResposta+' xmlns:'+StrTran(cSubName,':','')+'="'+__cTissTNS+'">'+Chr(10)

		cSoap += '<'+cSubName+'tissTransmiteMensagemZIP_OperationResult>'+Chr(10)
		cSoap += '<'+cSubName+'RespostaMensagemTissZIP>'+cXml+'</'+cSubName+'RespostaMensagemTissZIP>'+Chr(10)
		cSoap += '<'+cSubName+'RespostaTipoMensagem>'+cTRecFault+'</'+cSubName+'RespostaTipoMensagem>'+Chr(10)
		cSoap += '</'+cSubName+'tissTransmiteMensagemZIP_OperationResult>'+Chr(10)

		cSoap += '</'+cSubName+cTagResposta+'>'+Chr(10)
		cSoap += '</soap:Body>'+Chr(10)
		cSoap += '</soap:Envelope>'+Chr(10)
	Else
		cSoap += '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">'+Chr(10)
		cSoap += '<soap:Body>'+Chr(10)

		cSoap += '<'+cTagResposta+' xmlns="'+__cTissTNS+'">'+Chr(10)
		cSoap += HtmlNoTags(cXml)+Chr(10)
		cSoap += '</'+cTagResposta+'>'+Chr(10)

		cSoap += '</soap:Body>'+Chr(10)
		cSoap += '</soap:Envelope>'+Chr(10)
	EndIf
	//Ŀ
	// Caso o debug esteja ligado vai logar na console e em arquivo			 
	//
	If TISS_DEBUG
		LogOnl( Replicate("*",79) )
		LogOnl("Retornando o pacote SOAP-XML")
		LogOnl("")
		LogOnl(cSoap)
		LogOnl("")
		LogOnl(Replicate("*",79) )
	EndIf
	//Ŀ
	// Fim da Funcao															 
	//
Return(cSoap)
/*/


Ŀ
Funao	 HttpSoapFaultAutor   Alexander Santos          Data  13.06.08 
Ĵ
Descrio Monta pacote soap fault											
ٱ


/*/
STATIC Function HttpSoapFault(cTagResposta,cCodErro,cDesErro,cObsErro,cNumeSeq,cRdaOri,cTagResAux,lObj,cDescErro)
	LOCAL cXml	  	 	:= "Nao gerou arquivo na caixa de saida"
	LOCAL cArqRet 	 	:= ""
	DEFAULT cNumeSeq 	:= "1"
	DEFAULT cRdaOri	 	:= PlsIntPad()
	DEFAULT lObj	 	:= ( !Upper(__cTissWs) $ "TISSTRANSMITEMENSAGEMZIP" )
	DEFAULT cTagResAux 	:= ""
	DEFAULT cDesErro		:= ""

	If At("Transao no", cDesErro) > 0
		cDesErro := STRTRAN(cDesErro, "", "a")
		cDesErro := STRTRAN(cDesErro, "", "c")
	EndIF
	//Ŀ
	// Monta retorno															 
	//
	cTRecFault := iif(upper(cTagResposta) $ "RECIBODOCUMENTOSWS", "RECEBIMENTO_DOCUMENTO", cTRecFault)
	nH := PLSAbreSem(cSemaforo)
	FErase(DIRTEMP+cFileTmp)
	cArqRet := PLSPROCRES(	{ {} , cTRecFault+"="+cTagResposta ,cNumeSeq,'','','','','', , ,{}, {}} , NIL, .T., AllTrim(cCodErro), PLSXMLTACE( AllTrim(cDesErro) ), PLSXMLTACE(AllTrim(cObsErro)), cFileTmp, cRdaOri,DIRONLINE,.T.)
	PLSFechaSem(nH,cSemaforo)
	//Ŀ
	// Verifica se o arquivo foi criado										 
	//
	If !Empty(cArqRet)
		cXml := MemoRead(DIRCAISA+cArqRet)
		If lObj
			cXml := TranXml( AllTrim(cXml),"R",cTagResposta,cTagResAux,cDesErro )
		EndIf
		cXml := HttpEnvSoap(cXml,cTagResposta)
	EndIf
	//Ŀ
	// Fim da Funcao															 
	//
Return cXml
/*/


Ŀ
Funo	 HttpInfo    Autor   Alexander Santos           Data  13.06.08 
Ĵ
Descrio Log Debug do que esta chegando									
ٱ


/*/
STATIC Function HttpInfo()
	LOCAL cHtml := ""

	cHtml +=   VarInfo("aHeaders          ",httpHeadIn->aHeaders,,.f.,.f.)
	cHtml += VarExInfo("httpCookies       ","aCookies",.f.,.f.)
	cHtml += VarExInfo("httpPost          ","aPost",.f.,.f.)
	cHtml += VarExInfo("httpGet           ","aGets",.f.,.f.)
	cHtml +=   VarInfo("HttpRCtType()     ",HttpRCtType(),,.f.,.f.)
	cHtml +=   VarInfo("HttpRCtLen()      ",HttpRCtLen(),,.f.,.f.)
	cHtml +=   VarInfo("HttpRCtDisp()     ",HttpRCtDisp(),,.f.,.f.)
	cHtml +=   VarInfo("SoapRAction()     ",SoapRAction(),,.f.,.f.)
	cHtml +=   VarInfo("HttpOtherContent()",HttpOtherContent(),,.f.,.f.)
	//Ŀ
	// Fim da Funcao															 
	//
Return(cHtml)
/*/


Ŀ
Funo	 LogOnl    Autor   Alexander Santos             Data  13.06.08 
Ĵ
Descrio Gera log		 													
ٱ


/*/
Function LogOnl(cErro,lDebug)

	PRIVATE DIRRAIZ 	:= PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
	PRIVATE DIRONLINE 	:= PLSMUDSIS( "ONLINE\" )
	PRIVATE DIRSUBRAI 	:= DIRRAIZ+DIRONLINE
	PRIVATE DIRLOG 	:= 	PLSMUDSIS( DIRSUBRAI+"LOG\" )

	PlsPtuLog(cErro,"tissonline.log" )
	//Ŀ
	// Se tiver ligado vai enviar para console									 
	//
	If LOG_CONOUT
		FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01', cErro , 0, 0, {})
	EndIf
	//Ŀ
	// Fim da Funcao															 
	//
Return
/*/


Ŀ
Funo	 TranXml   Autor   Alexander Santos             Data  13.06.08 
Ĵ
Descrio Ajusta Xml	 													
ٱ


/*/
STATIC Function TranXml(cXml,cTipo,cTagCorpo,cTagResAux,cDesErro)
	LOCAL nI
	LOCAL cTag	  	 	:= ""
	LOCAL cConteudo  	:= ""
	LOCAL aMatXml 	 	:= {}
	LOCAL cTagWs	 	:= ""
	LOCAL lTagCorpo		:= .T.
	LOCAL lHash			:= .F.
	DEFAULT cTagCorpo   := ""
	DEFAULT cTagResAux 	:= ""
	DEFAULT cDesErro		:= ""
	//Ŀ
	// Ajuste tag																 
	//
	cTagWs := StrTran( Upper(__cTissWs) , "TISS" ,"")

	If (TISVERS >= "3")
		//na verso 3 da tiss o nome do webservide  diferente do nome da tag no XML
		If (cTagWs == "VERIFICAELEGIBILIDADE")
			cTagWs := "PEDIDOELEGIBILIDADE"
		EndIf
		If (cTagWs == "SOLICITACAOSTATUSAUTORIZACAO")
			cTagWs := "SOLICITASTATUSAUTORIZACAO"
		EndIf
	EndIf

	//Ŀ
	// Faz a troca pelo Aux pq a tag principal nao e igual a tag corpo			 
	//
	If !Empty(cTagResAux)
		cTagCorpo := cTagResAux
	EndIf
	//Ŀ
	// Debug																	 
	//
	If TISS_DEBUG
		LogOnl( Replicate("*",79) )
		LogOnl(STR0016)// "Xml Original"
		LogOnl("")
		LogOnl(cXml)
		LogOnl("")
		LogOnl( Replicate("*",79) )
	EndIf
	//Ŀ
	// Monta matriz com as Tag													 
	//
	While At(">",cXml) > 1
		cTag := SubStr(cXml,At("<",cXml),At(">",SubStr(cXml,At("<",cXml))))

		cTag := StrTran( cTag ,"<types:","<" )
		cTag := StrTran( cTag ,"<TYPES:","<" )
		cTag := StrTran( cTag ,"<Types:","<" )

		If At("xmlns:",cTag) > 0
			cTag := AllTrim( Left( cTag, At("xmlns:",cTag)-1) ) + '>'
		EndIf

		If At("xmlns=",cTag) > 0
			cTag := AllTrim( Left( cTag, At("xmlns=",cTag)-1) ) + '>'
		EndIf

		If At("xsi:type",cTag) > 0
			cTag := AllTrim( Left( cTag, At("xsi:type",cTag)-1) ) + '>'
		EndIf

		If At("<",cTag) > 0 .And. At("</",cTag) == 0
			If At(":",cTag)>0 .And. At("xmlns:",Lower(cTag))==0
				cTag := "<" + NAMESPACE + SubStr( cTag,At(":",cTag)+1,Len(cTag) )
			Else
				cTag := "<" + NAMESPACE + SubStr( cTag,At("<",cTag)+1,Len(cTag) )
			EndIf
		EndIf

		If At("</",cTag) > 0 .And. !lHash
			If At(":",cTag)>0
				cTag := "</" + NAMESPACE + SubStr( cTag,At(":",cTag)+1,Len(cTag) )
			Else
				cTag := "</" + NAMESPACE + SubStr( cTag,At("<",cTag)+2,Len(cTag) )
			EndIf
		EndIf

		AaDd(aMatXml,cTag)

		cXml := SubStr(cXml,At(">",cXml)+1,Len(cXml))

		cConteudo := AllTrim(SubStr(cXml,1,At("<",cXml)-1))
		If !Empty(cConteudo)
			If TISVERS != "2.02.01"
				AaDd(aMatXml,DecodeUtf8(cConteudo) )//cConteudo
			Else
				AaDd(aMatXml,cConteudo )//cConteudo
			EndIf
		EndIf

	EndDo
	//Ŀ
	// Envio																	 
	//
	If cTipo == "E"
		//Ŀ
		// Ajustando																 
		//
		If Len(aMatXml) > 0
			aMatXml[1] 				:= '<' + NAMESPACE + 'mensagemTISS xmlns="http://www.w3.org/2001/XMLSchema" xmlns:'+StrTran(NAMESPACE,':','')+'="http://www.ans.gov.br/padroes/tiss/schemas">'
			aMatXml[Len(aMatXml)] 	:= '</' + NAMESPACE + 'mensagemTISS>'
		EndIf
		//Ŀ
		// Ajusta as tag's															 
		//
		cXml := ""
		For nI:= 1 To Len(aMatXml)

			If TISS_DEBUG
				LogOnl( Upper(aMatXml[nI]) )
			Endif

			If Upper(aMatXml[nI]) == "<" + Upper(NAMESPACE) + cTagWs+">" .AND. At("<" + NAMESPACE + "prestadorParaOperadora>",cXml) == 0
				aMatXml[nI] := "<" + NAMESPACE + "prestadorParaOperadora>"+aMatXml[nI]
				If (TISVERS >= "3")
					//a tag que vem pelo webservide eh pedidoElegibilidade, porem o que esta no tissV3_00_01.xsd eh verificaElegibilidade
					aMatXml[nI] := StrTran(aMatXml[nI], "pedidoElegibilidade", "verificaElegibilidade")
				EndIf
			EndIf

			If Upper(aMatXml[nI]) == "</" + Upper(NAMESPACE) + cTagWs+">"
				aMatXml[nI] := aMatXml[nI]+"</" + NAMESPACE + "prestadorParaOperadora>"
				If (TISVERS >= "3")
					//a tag que vem pelo webservide eh pedidoElegibilidade, porem o que esta no tissV3_00_01.xsd eh verificaElegibilidade
					aMatXml[nI] := StrTran(aMatXml[nI], "pedidoElegibilidade", "verificaElegibilidade")
				EndIf
			EndIf

			If Upper(aMatXml[nI]) == "<" + Upper(NAMESPACE) + "HASH>" .AND. At("<" + NAMESPACE + "epilogo>",cXml) == 0
				aMatXml[nI] := "<" + NAMESPACE + "epilogo>"+aMatXml[nI]
			EndIf

			If Upper(aMatXml[nI]) == "</" + Upper(NAMESPACE) + "HASH>"
				aMatXml[nI] := aMatXml[nI]+"</" + NAMESPACE + "epilogo>"
			EndIf
			If Upper(aMatXml[nI]) == "</" + Upper(NAMESPACE) + "EPILOGO>" .AND. (At("</" + NAMESPACE + "epilogo>",cXml) <> 0 .OR. At("</" + NAMESPACE + "EPILOGO>",cXml) <> 0)
				aMatXml[nI] := ""
			EndIf
			If Upper(aMatXml[nI]) == "</" + Upper(NAMESPACE) + "PRESTADORPARAOPERADORA>" .AND. (At("</" + NAMESPACE + "prestadorParaOperadora>",cXml) <> 0 .OR. At("</" + NAMESPACE + "PRESTADORPARAOPERADORA>",cXml) <> 0)
				aMatXml[nI] := ""
			EndIf
			cXml += AllTrim(aMatXml[nI])
		Next
		//Ŀ
		// Resposta																 
		//
	ElseIf cTipo == "R"
		//Ŀ
		// Ajustando																 
		//
		If Len(aMatXml) > 0
			aMatXml[1] 				:= ""
			aMatXml[Len(aMatXml)] 	:= ""
		EndIf
		//Ŀ
		// Ajusta as tag's															 
		//
		cXml := ""
		For nI:= 1 To Len(aMatXml)

			If Empty(aMatXml[nI])
				Loop
			EndIf

			If At( "<" + Upper(NAMESPACE) + "?XML",Upper(aMatXml[nI]) ) > 0
				aMatXml[nI] := ""
			EndIf

			If At( "<" + Upper(NAMESPACE) + "MENSAGEMTISS",Upper(aMatXml[nI]) ) > 0
				aMatXml[nI] := ""
			EndIf

			//o retrno da situacaoAutorizacaoWs nao pode ter o Ws no corpo da mensagem versao3
			If UPPER("situacaoAutorizacaoWS") $ UPPER(aMatXml[nI])
				aMatXml[nI] := StrTran(aMatXml[nI], "situacaoAutorizacaoWS", "situacaoAutorizacao")
			Endif

			If Upper(aMatXml[nI]) == "<" + Upper(NAMESPACE) + "OPERADORAPARAPRESTADOR>"
				aMatXml[nI] := ""
			EndIf

			If Upper(aMatXml[nI]) == "</" + Upper(NAMESPACE) + "OPERADORAPARAPRESTADOR>"
				aMatXml[nI] := ""
			EndIf

			If Upper(aMatXml[nI]) == "<" + Upper(NAMESPACE) + "EPILOGO>"
				aMatXml[nI] := ""
			EndIf

			If Upper(aMatXml[nI]) == "</" + Upper(NAMESPACE) + "EPILOGO>"
				aMatXml[nI] := ""
			EndIf


			//na versao 3 esta tag estava tirando o ans: da tag servicoAutorizado
			If TISVERS < '3'
				If Upper(aMatXml[nI]) == "<" + Upper(NAMESPACE) + "CABECALHO>"
					aMatXml[nI] := "<cabecalho>"
				EndIf

				If Upper(aMatXml[nI]) == "</" + Upper(NAMESPACE) + "CABECALHO>"
					aMatXml[nI] := "</cabecalho>"
				EndIf

				If Upper(aMatXml[nI]) == "<" + Upper(NAMESPACE) + Upper(cTagCorpo) + ">" .And. lTagCorpo
					aMatXml[nI] := "<"+cTagCorpo+">"
					lTagCorpo := .F.
				EndIf

				If Upper(aMatXml[nI]) == "</" + Upper(NAMESPACE) + Upper(cTagCorpo) + ">" .And. Len(aMatXml) <> nI

					If aScan(aMatXml,{|x| Upper(x) == "</" + Upper(NAMESPACE) + Upper(cTagCorpo) + ">" },(nI+1) ) == 0
						aMatXml[nI] := "</"+cTagCorpo+">"
					EndIf

				EndIf
			Else
				iF !Empty(cDesErro) // Exibe a descrio da glosa no retorno

					nPos := aScan(aMatXml,{|x| ValType(x) == "C" .AND. Upper(x) == "<" + Upper(NAMESPACE) + Upper("descricaoglosa") + ">" },(nI) )
					If nPos > 0
						aMatXml[nPos+1] := cDesErro
					EndIf

				Endif

			Endif

			//na versao 3 esta tag estava tirando o ans: da tag servicoAutorizado
			If TISVERS < '3'
				If Upper(aMatXml[nI]) == "<" + Upper(NAMESPACE) + "HASH>" .And. Len(aMatXml) <> nI
					aMatXml[nI] := "<hash>"
				EndIf

				If Upper(aMatXml[nI]) == "</" + Upper(NAMESPACE) + "HASH>" .And. Len(aMatXml) <> nI
					aMatXml[nI] := "</hash>"
				EndIf
			Endif
			cXml += AllTrim(aMatXml[nI])
		Next

	EndIf
	//Ŀ
	// Debug																	 
	//
	If TISS_DEBUG
		LogOnl( Replicate("*",79) )
		LogOnl(STR0017)//"Xml Ajustado"
		LogOnl("")
		LogOnl(cXml)
		LogOnl("")
		LogOnl(Replicate("*",79) )
	EndIf
	//Ŀ
	// Fim da Funcao															 
	//
Return cXml
/*/


Ŀ
Funo	 TranDeParaAutor   Alexander Santos             Data  13.06.08 
Ĵ
Descrio Retorna o nome da transacao de retorno							
ٱ


/*/
STATIC Function TranDePara(cTran)

	Do Case
		Case cTran $ "ENVIO_LOTE_GUIAS,RE_APRESENTACAO_GUIA,AUTORIZACAO_ODONTOLOGIA"
			cTran := "PROTOCOLO_RECEBIMENTO"
		Case cTran == "VERIFICA_ELEGIBILIDADE"
			cTran := "SITUACAO_ELEGIBILIDADE"
		Case cTran == "SOLIC_DEMONSTRATIVO_RETORNO"
			cTran := "DEMONSTRATIVO_PAGAMENTO,DEMONSTRATIVO_ANALISE_CONTA,DEMONSTRATIVO_ODONTOLOGIA"
		Case cTran == "SOLIC_STATUS_PROTOCOLO"
			cTran := "SITUACAO_PROTOCOLO"
		Case cTran == "SOLICITACAO_PROCEDIMENTOS"
			cTran := "RESPOSTA_SOLICITACAO"
		Case cTran == "CANCELA_GUIA"
			cTran := "CANCELAMENTO_GUIA_RECIBO"
		Case cTran == "SOLICITA_STATUS_AUTORIZACAO"
			cTran := "STATUS_AUTORIZACAO"
		Case cTran == "SOLIC_STATUS_RECURSO_GLOSA"
			cTran := "RESPOSTA_RECURSO_GLOSA"
		Case cTran == "RECURSO_GLOSA"
			cTran := "RECEBIMENTO_RECURSO_GLOSA"
	EndCase
	//Ŀ
	// Fim da Funcao															 
	//
Return cTran


/*/

Ŀ
Funao	 solicitademonst      Autor   Renan Martins     Data  01/2016  
Ĵ
Descrio Transacao Web Service Solicitaod de Demonstrativo    			
ٱ

/*/
Function tissSolDemonstrativoRetorno()
	//TODO: Revisar essa funo e como ser utilizada no futuro pois o nome anterior "TISSSOLICITACAODEMONSTRATIVORETORNO" conflita com a funo de solicitao de procedimentos
	LOCAL cRet	:= ""

	cTRecFault 	:= "DEMONSTRATIVO_PAGAMENTO,DEMONSTRATIVO_ANALISE_CONTA,DEMONSTRATIVO_ODONTOLOGIA"

	If !Empty(cRet)
		cRet := HttpSoapFault(DEMONSTRATIVORETORNOWS,"9902",STR0012+cRet,"",,,,.T.)//"Transao no suportada : "
	Else
		cRet := ProcOnLine(DEMONSTRATIVORETORNOWS)
	EndIf
	//Ŀ
	// Fim da Funcao															 
	//
Return StrTran( StrTran( StrTran( cRet ,Chr(13),""),Chr(10),""),Chr(9),"")


//----------------------------------------------------------------
/*/{Protheus.doc} PLSRetTime
Retorna o tempo do servidor com milisegundos

@type function
@author Renan Sakai
@since 29.08.18
@version 1.0
/*/
//----------------------------------------------------------------
Function PLSRetTime()
	Local nHH, nMM , nSS, nMS := seconds()

	nHH := int(nMS/3600)
	nMS -= (nHH*3600)
	nMM := int(nMS/60)
	nMS -= (nMM*60)
	nSS := int(nMS)
	nMS := (nMs - nSS)*1000

Return strzero(nHH,2)+":"+strzero(nMM,2)+":"+strzero(nSS,2)+"."+strzero(nMS,3)
