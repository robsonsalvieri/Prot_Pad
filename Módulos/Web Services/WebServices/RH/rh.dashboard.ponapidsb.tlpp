#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "TOTVS.CH"
#include "PONAPIDSB.CH"
#include "PONCALEN.CH"

NameSpace totvs.protheus.rh.dashboard.sigapon

//---------------------------------------------------------------------
/*/{Protheus.doc} DbHrBranches
@type			method
@description	Serviço para retornar as filiais do Protheus
@author			Marco Nakazawa
@since			19/08/2022
/*/
//---------------------------------------------------------------------
@GET("api/rh/v1/DbHrBranches")
Function dbHrBranches()
Local oResp			:= JsonObject():New()	as Json
Local aFiliais		:= {}					as Array
Local aGetFil		:= {}					as Array
Local cValidFil		:= ""					as Character
Local nI			:= 0					as Numeric

aGetFil		:= GetFilRecnos(cEmpAnt , Space(FWGETTAMFILIAL), Replicate("Z", FWGETTAMFILIAL))
cValidFil 	:= fValidFil()

If !Empty(aGetFil)
	For nI := 1 To Len(aGetFil)
		If aGetFil[nI,1] $ cValidFil
			aAdd(aFiliais,AllTrim(aGetFil[nI,1]))
		EndIf
	Next
EndIf

oResp["branches"] := aFiliais
oResp := oResp:ToJson()

Return oRest:setResponse(oResp)

//---------------------------------------------------------------------
/*/{Protheus.doc} DbHrManagers
@type			method
@description	Serviço para retornar as filiais do Protheus
@author			Marco Nakazawa
@since			19/08/2022
/*/
//---------------------------------------------------------------------
@GET("api/rh/v1/DbHrManagers")
Function DbHrManagers()
Local oResp			:= JsonObject():New()					as Json
Local aGestores		:= {}									as Array

fBscGestor(.T., @aGestores)

If (Empty(aGestores), oResp["managers"] := {}, oResp["managers"] := aGestores)

oResp := oResp:ToJson()
Return oRest:setResponse(oResp)

//---------------------------------------------------------------------
/*/{Protheus.doc} DbHrAttendanceControl
@type			method
@description	Serviço para retornar total de funcionários com o ponto completo e incompleto - Gadget funcionários com pontos completos e funcionários com pontos incompletos
@author			Marco Nakazawa
@since			25/05/2022
/*/
//---------------------------------------------------------------------
@POST("api/rh/v1/DbHrAttendanceControl")
Function dbHrAttendanceControl()
Local aTabCalend	:= {}										as Array
Local aFiliais		:= {}										as Array
Local aTabCalQtd	:= {}										as Array
Local aMarcFunc		:= {}										as Array
Local aGetFil		:= {}										as Array
Local cBody	    	:= oRest:getBodyRequest()					as Character
Local cAlias		:= GetNextAlias()							as Character
Local cJoiFilSP8	:= "%" + FWJoinFilial("SP8", "SRA") + "%"	as Character
Local cJoiFilSQB	:= "%" + FWJoinFilial("SQB", "SRA") + "%"	as Character
local cDataDe		:= ""										as Character
local cDataAte		:= "" 										as Character
Local cWhereFil		:= ""										as Character
Local cFilAccess	:= ""										as Character
Local cGesFunQry	:= ""										as Character
Local cFilAnt		:= ""										as Character
Local cMatAnt		:= ""										as Character
Local cNomeFil		:= ""										as Character
Local cValidFil		:= ""										as Character
Local cRealSP8		:= ""										as Character
Local cRealSPG		:= ""										as Character
Local cNomeSGDB 	:= Upper(TCGetDB())							as Character
Local dDateDe		:= sToD("  /  /  ") 						as Date
Local dDateAte		:= sToD("  /  /  ") 						as Date
Local oResp			:= JsonObject():New()						as Json
Local oJparams		:= JsonObject():New()						as Json
Local lEof			:= .T.										as Logical
Local nLenFil		:= 0										as Numeric
Local nLenGetFil	:= 0										as Numeric
Local nI			:= 0										as Numeric

Static aTodasMarc	:= {}										as Json
Static aPtCompl		:= {}										as Json
Static aPtIncomp	:= {} 										as Json
Static aSemMarc		:= {} 										as Json
Static aTodosFil	:= {}										as Json
Static aPtCompFil	:= {}										as Json
Static aPtIncFil	:= {} 										as Json
Static aSemMrcFil	:= {} 										as Json
Static nTotIncomp	:= 0 										as Numeric
Static nTotInFil	:= 0 										as Numeric

oJparams:FromJSON(cBody)

If checkParams(oJparams)
	cDataDe		:= StrTran(oJparams["startDate"],"-","")
	cDataAte	:= StrTran(oJparams["endDate"],"-","")
	aFiliais	:= oJparams["branches"]
	nLenFil		:= Len(aFiliais)
	
	fLimpVarPt()
	
	If nLenFil == 1 .And. aFiliais[1] == "todas"
		aGetFil		:= GetFilRecnos(cEmpAnt , Space(FWGETTAMFILIAL), Replicate("Z", FWGETTAMFILIAL))
		cValidFil 	:= fValidFil()
		nLenGetFil	:= Len(aGetFil)
		
		For nI := 1 To nLenGetFil
			If aGetFil[nI,1] $ cValidFil
				If Empty(cFilAccess)
					cFilAccess += "'" + aGetFil[nI,1] + "'"
				Else
					cFilAccess += ",'" + aGetFil[nI,1] + "'"
				EndIf
			EndIf
		Next
		
		cWhereFil := "%SRA.RA_FILIAL IN (" + cFilAccess + ")%"
	ElseIf nLenFil == 1 .And. aFiliais[1] <> "todas"
		cWhereFil := "%SRA.RA_FILIAL = '" + aFiliais[1] + "'%"
	Else
		cWhereFil := "%SRA.RA_FILIAL IN ('" + ArrTokStr(aFiliais,"','") + "')%"
	EndIf
	
	If oJparams["managers"] <> Nil .And. !Empty(oJparams["managers"])
		cGesFunQry := fGestFunc(oJparams["managers"], cWhereFil)
	Else
		cGesFunQry := fGestFunc({"todos"}, cWhereFil)
	EndIf
	
	If Alltrim(cNomeSGDB) == "ORACLE"
		cRealSP8 := "%SUBSTR(CAST(LISTAGG(REPLACE(TO_CHAR(P8_HORA,'00.00'),'.',':'),' - ') WITHIN GROUP (ORDER BY P8_DATAAPO,P8_HORA ASC) AS VARCHAR(4000)),1,4000) AS REALIZADO%"
		cRealSPG := "%SUBSTR(CAST(LISTAGG(REPLACE(TO_CHAR(PG_HORA,'00.00'),'.',':'),' - ') WITHIN GROUP (ORDER BY PG_DATAAPO,PG_HORA ASC) AS VARCHAR(4000)),1,4000) AS REALIZADO%"		
	ElseIf Alltrim(cNomeSGDB) == "POSTGRES"
		cRealSP8 := "%STRING_AGG(REPLACE(TO_CHAR(P8_HORA, '00.00'),'.',':'),' - ' ORDER BY P8_DATAAPO,P8_HORA) AS REALIZADO%"
		cRealSPG := "%STRING_AGG(REPLACE(TO_CHAR(PG_HORA, '00.00'),'.',':'),' - ' ORDER BY PG_DATAAPO,PG_HORA) AS REALIZADO%"
	Else
		cRealSP8 := "%CAST(STUFF(REPLACE(REPLACE((SELECT ' - ' + REPLICATE('0', 5 - len((REPLACE(LTRIM(STR(P8_HORA,5,2)),'.',':')))) + REPLACE(LTRIM(STR(P8_HORA,5,2)),'.',':') FROM " + RetSqlName("SP8") + " AS SP8HRS WHERE SP8HRS.D_E_L_E_T_= ' ' AND SP8HRS.P8_DATAAPO = SP8.P8_DATAAPO AND SP8HRS.P8_MAT = SP8.P8_MAT AND SP8HRS.P8_FILIAL = SP8.P8_FILIAL GROUP BY P8_DATAAPO, P8_HORA ORDER BY P8_DATAAPO, P8_HORA FOR XML PATH('h')),'</h><h>',''),'</h>',''),1,6,'') AS VARCHAR(100)) AS REALIZADO%"
		cRealSPG := "%CAST(STUFF(REPLACE(REPLACE((SELECT ' - ' + REPLICATE('0', 5 - len((REPLACE(LTRIM(STR(PG_HORA,5,2)),'.',':')))) + REPLACE(LTRIM(STR(PG_HORA,5,2)),'.',':') FROM " + RetSqlName("SPG") + " AS SPGHRS WHERE SPGHRS.D_E_L_E_T_= ' ' AND SPGHRS.PG_DATAAPO = SPG.PG_DATAAPO AND SPGHRS.PG_MAT = SPG.PG_MAT AND SPGHRS.PG_FILIAL = SPG.PG_FILIAL GROUP BY PG_DATAAPO, PG_HORA ORDER BY PG_DATAAPO, PG_HORA FOR XML PATH('h')),'</h><h>',''),'</h>',''),1,6,'') AS VARCHAR(100)) AS REALIZADO%"
	EndIf
	
	BeginSql alias cAlias
		SELECT
			SRA.RA_FILIAL,
			SRA.RA_MAT,
			SRA.RA_NOME,
			SRA.RA_CC,
			SQB.QB_DESCRIC,
			SRA.RA_DEMISSA,
			SRA.R_E_C_N_O_ AS RECNO,
			SP8.DATAMARC,
			COALESCE(SP8.TOTALMARCS,0) AS TOTALMARCS,
			SP8.REALIZADO,
			SRAGEST.GESTOR,
			SRAGEST.FILGESTOR,
			SRAGEST.MATGESTOR
		FROM %table:SRA% SRA
		%exp:cGesFunQry%
		LEFT JOIN %table:SQB% SQB ON %exp:cJoiFilSQB% AND SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.%notDel%
		LEFT JOIN (
			SELECT
				SP8.P8_FILIAL,
				SP8.P8_MAT,
				SP8.P8_DATAAPO AS DATAMARC,
				COUNT(SP8.P8_MAT) AS TOTALMARCS,
				%exp:cRealSP8%
			FROM %table:SP8% SP8
			WHERE SP8.P8_TPMCREP <> 'D'
				AND (SP8.P8_DATAAPO >= %exp:cDataDe% AND SP8.P8_DATAAPO <= %exp:cDataAte%)
				AND SP8.%notDel%
			GROUP BY SP8.P8_FILIAL, SP8.P8_MAT, SP8.P8_DATAAPO
			UNION ALL
			SELECT
				SPG.PG_FILIAL,
				SPG.PG_MAT,
				SPG.PG_DATAAPO AS DATAMARC,
				COUNT(SPG.PG_MAT) AS TOTALMARCS,
				%exp:cRealSPG%
			FROM %table:SPG% SPG
			WHERE SPG.PG_TPMCREP <> 'D'
				AND (SPG.PG_DATAAPO >= %exp:cDataDe% AND SPG.PG_DATAAPO <= %exp:cDataAte%)
				AND SPG.%notDel%
			GROUP BY SPG.PG_FILIAL, SPG.PG_MAT, SPG.PG_DATAAPO
		) SP8 ON %exp:cJoiFilSP8% AND SP8.P8_MAT = SRA.RA_MAT
		WHERE SRA.RA_TNOTRAB <> ' '
			AND SRA.RA_SEQTURN <> ' '
			AND SRA.RA_REGRA <> ' '
			AND (SRA.RA_DEMISSA = ' ' OR SRA.RA_DEMISSA >= %exp:cDataDe%)
			AND SRA.RA_ADMISSA <= %exp:cDataAte%
			AND (SRA.RA_DEMISSA = ' ' OR SP8.DATAMARC < SRA.RA_DEMISSA)
			AND %exp:cWhereFil%
			AND SRA.%notDel%
		GROUP BY SRA.RA_FILIAL, SRA.RA_MAT, SRA.RA_NOME, SRA.RA_CC, SQB.QB_DESCRIC, SRA.RA_DEMISSA, SRA.R_E_C_N_O_, SP8.DATAMARC, SP8.TOTALMARCS, SP8.REALIZADO, SRAGEST.GESTOR, SRAGEST.FILGESTOR, SRAGEST.MATGESTOR
		ORDER BY SRA.RA_FILIAL, SRA.RA_MAT, SRA.RA_NOME, SRA.RA_CC, SQB.QB_DESCRIC, SRA.RA_DEMISSA, SRA.R_E_C_N_O_, SP8.DATAMARC, SP8.TOTALMARCS, SP8.REALIZADO, SRAGEST.GESTOR, SRAGEST.FILGESTOR, SRAGEST.MATGESTOR
	EndSql
	
	DbSelectArea("SRA")
	
	dDateDe := sToD(cDataDe)
	dDateAte := sToD(cDataAte)
	
	While lEof
		lEof := !(cAlias)->(Eof())
		
		If Empty(cFilAnt) .And. Empty(cMatAnt)
			If lEof
				aAdd(aMarcFunc,{(cAlias)->RA_FILIAL,(cAlias)->RA_MAT,(cAlias)->RA_NOME,(cAlias)->QB_DESCRIC,sToD((cAlias)->DATAMARC),(cAlias)->TOTALMARCS,(cAlias)->REALIZADO,(cAlias)->RA_CC,(cAlias)->RECNO,(cAlias)->GESTOR,(cAlias)->FILGESTOR + " - " + (cAlias)->MATGESTOR})
			EndIf
		ElseIf (cAlias)->RA_FILIAL == cFilAnt .And. (cAlias)->RA_MAT == cMatAnt
			If (lEof,aAdd(aMarcFunc,{(cAlias)->RA_FILIAL,(cAlias)->RA_MAT,(cAlias)->RA_NOME,(cAlias)->QB_DESCRIC,sToD((cAlias)->DATAMARC),(cAlias)->TOTALMARCS,(cAlias)->REALIZADO,(cAlias)->RA_CC,(cAlias)->RECNO,(cAlias)->GESTOR,(cAlias)->FILGESTOR + " - " + (cAlias)->MATGESTOR}),Nil)
		EndIf
		
		If (cAlias)->RA_FILIAL <> cFilAnt .Or. (cAlias)->RA_MAT <> cMatAnt .Or. !lEof
			If !Empty((cAlias)->RA_FILIAL) .And. !Empty((cAlias)->RA_MAT) .And. aScan(aTodasMarc, {|x| x["branch"] == (cAlias)->RA_FILIAL .And. x["registration"] == (cAlias)->RA_MAT}) == 0
				AAdd(aTodasMarc,{"branch":(cAlias)->RA_FILIAL,"registration":(cAlias)->RA_MAT,"name":AllTrim((cAlias)->RA_NOME),"department":(cAlias)->QB_DESCRIC, "manager":(cAlias)->GESTOR,"managerId":(cAlias)->FILGESTOR + " - " + (cAlias)->MATGESTOR})
			EndIf
			
			If !Empty(aMarcFunc)
				SRA->(dbGoto(aMarcFunc[1,9]))
				If (!Empty(SRA->RA_DEMISSA) .And. SRA->RA_DEMISSA < dDateAte, dDateAte := SRA->RA_DEMISSA,Nil)
				If (SRA->RA_ADMISSA > dDateDe, dDateDe := SRA->RA_ADMISSA,Nil)
				
				aTabCalend := {}
				
				CriaCalend(	dDateDe					,;	//01 -> Data Inicial do Periodo
							dDateAte				,;	//02 -> Data Final do Periodo
							Nil						,;	//03 -> Turno Para a Montagem do Calendario
							Nil						,;	//04 -> Sequencia Inicial para a Montagem Calendario
							Nil						,;	//05 -> Array Tabela de Horario Padrao
							@aTabCalend				,;	//06 -> Array com o Calendario de Marcacoes
							aMarcFunc[1,1]			,;	//07 -> Filial para a Montagem da Tabela de Horario
							aMarcFunc[1,2]			,;	//08 -> Matricula para a Montagem da Tabela de Horario
							aMarcFunc[1,8]			,;	//09 -> Centro de Custo para a Montagem da Tabela
							Nil		     			,;	//10 -> Array com as Trocas de Turno
							Nil						,;	//11 -> Array com Todas as Excecoes do Periodo
							Nil						,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
							Nil						,;	//13 -> Se executa a funcao se sincronismo do calendario
							.F.			 			,;	//14 -> Se Forca a Criacao de Novo Calendario
							Nil		 				,;  //15 -> Array com marcacoes para tratamento de Turnos Opcionais
							Nil		 				,;  //16 -> Se considera as exceções cadastradas
							Nil						,; //17 -> Chamada do GPEXPER
							Nil						,; //18 -> Considera a SRA posicionada para a montagem do calendário
							60			 			 ; //19 -> Adiciona a quantidade de dias no inicio do período para buscar trocas de turnos
				)
				
				aTabCalQtd := fFrtCalen(aTabCalend)

				dDateDe := sToD(cDataDe)
				dDateAte := sToD(cDataAte)
			EndIf
			
			If !Empty(cFilAnt) .And. !Empty(cMatAnt)
				If Empty(aMarcFunc[Len(aMarcFunc),5]) .And. !Empty(aTabCalQtd)
					fValdMarca(aMarcFunc, aTabCalQtd, .T., @aTodasMarc)
					
					If lEof .And. !Empty(cFilAnt) .And. !Empty(cMatAnt) .And. aScan(aMarcFunc, {|x| x[1] == (cAlias)->RA_FILIAL .And. x[2] == (cAlias)->RA_MAT}) == 0
						aMarcFunc := {}
						AAdd(aMarcFunc,{(cAlias)->RA_FILIAL,(cAlias)->RA_MAT,(cAlias)->RA_NOME,(cAlias)->QB_DESCRIC,sToD((cAlias)->DATAMARC),(cAlias)->TOTALMARCS,(cAlias)->REALIZADO,(cAlias)->RA_CC,(cAlias)->RECNO,(cAlias)->GESTOR,(cAlias)->FILGESTOR + " - " + (cAlias)->MATGESTOR})
					Else
						aMarcFunc := {}
						aTabCalQtd := {}
					EndIf
				Else
					fValdMarca(aMarcFunc, aTabCalQtd, .F., @aTodasMarc)
					aMarcFunc := {}
					aTabCalQtd := {}
					
					If lEof
						AAdd(aMarcFunc,{(cAlias)->RA_FILIAL,(cAlias)->RA_MAT,(cAlias)->RA_NOME,(cAlias)->QB_DESCRIC,sToD((cAlias)->DATAMARC),(cAlias)->TOTALMARCS,(cAlias)->REALIZADO,(cAlias)->RA_CC,(cAlias)->RECNO,(cAlias)->GESTOR,(cAlias)->FILGESTOR + " - " + (cAlias)->MATGESTOR})
					EndIf
				EndIf
			EndIf
		EndIf
		
		cMatAnt := (cAlias)->RA_MAT
		cFilAnt := (cAlias)->RA_FILIAL
		(cAlias)->(dbSkip())
	Enddo
	
	For nI := 1 To nLenFil
		If nLenFil == 1
			If (aFiliais[nI] == "todas",cNomeFil := STR0020, cNomeFil := aFiliais[nI])
				oResp[cValToChar(nI)] := {;
					"branch":cNomeFil,;
					"totalEmployees":Len(aTodasMarc),;
					"totalDetails":aTodasMarc,;
					"clockMarkingsComplete":Len(aPtCompl),;
					"completeDetails":aPtCompl,;
					"clockMarkingsIncomplete":nTotIncomp,;
					"incompleteDetails":aPtIncomp,;
					"withoutClockMarkings":Len(aSemMarc),;
					"withoutDetails":aSemMarc;
				}
		Else
			If nI == 1
				cNomeFil := STR0020
				oResp[cValToChar(nI)] := {;
					"branch":cNomeFil,;
					"totalEmployees":Len(aTodasMarc),;
					"totalDetails":aTodasMarc,;
					"clockMarkingsComplete":Len(aPtCompl),;
					"completeDetails":aPtCompl,;
					"clockMarkingsIncomplete":nTotIncomp,;
					"incompleteDetails":aPtIncomp,;
					"withoutClockMarkings":Len(aSemMarc),;
					"withoutDetails":aSemMarc;
				}
			EndIf
			
			aTodosFil	:= {}
			aPtCompFil	:= {}
			aPtIncFil	:= {}
			nTotInFil	:= 0
			aSemMrcFil	:= {}
			
			fIndFunc(aFiliais[nI])
				cNomeFil := aFiliais[nI]
				oResp[cValToChar(nI+1)] := {;
					"branch":cNomeFil,;
					"totalEmployees":Len(aTodosFil),;
					"totalDetails":aTodosFil,;
					"clockMarkingsComplete":Len(aPtCompFil),;
					"completeDetails":aPtCompFil,;
					"clockMarkingsIncomplete":nTotInFil,;
					"incompleteDetails":aPtIncFil,;
					"withoutClockMarkings":Len(aSemMrcFil),;
					"withoutDetails":aSemMrcFil;
				}
		EndIf
	Next
	
	oResp := oResp:ToJson()
	
	SRA->(DbCloseArea())
	(cAlias)->(DbCloseArea())
Else
	lRet := .F.
	SetRestFault(400, EncodeUTF8(STR0012)) // "Parâmetros inválidos: Verifique se os parâmetros startDate, endDate e branches foram enviados."
EndIf
Return oRest:setResponse(oResp)

//---------------------------------------------------------------------
/*/{Protheus.doc} DbHrClockin
@type			method
@description	Serviço para retornar as informações dos Gadgets do Clock In do Dashboard RH - Gadget Total de marcações, marcações Integradas, Existentes para Integração e marcações sem NSR
@author			Marco Nakazawa
@since			25/05/2022
/*/
//---------------------------------------------------------------------
@POST("api/rh/v1/DbHrClockin")
Function dbHrClockin()
Local aDisps		:= {}								as Array
Local aMarcs		:= {}								as Array
Local aRetDisps		:= {}								as Array
Local aFiliais		:= {}								as Array
Local aFiltro		:= {}								as Array
Local aIntegrads	:= {} 								as Array
local cBody			:= oRest:getBodyRequest()			as Character
local cDataDe		:= ""								as Character
local cDataAte		:= ""								as Character
Local oResp			:= JsonObject():New()				as Json
Local oJparams		:= JsonObject():New()				as Json
Local lMSA			:= TcCanOpen("MSA_CONTROL_MARCAC")	as Logical
Local lRet			:= .T.								as Logical
Local lDashBoard	:= .T.								as Logical
Local lRR1			:= .F.								as Logical
Local nI			:= 0								as Numeric
Local nTotMarc		:= 0								as Numeric
Local nLenFil		:= 0								as Numeric
Local nLenaMarcs	:= 0								as Numeric

Static aTodasCk		:= {}								as Json
Static aProc		:= {}								as Json
Static aPenden		:= {} 								as Json
Static aSemNsr		:= {} 								as Json
Static aTodCkFil	:= {} 								as Json
Static aProcFil		:= {}								as Json
Static aPendenFil	:= {}								as Json
Static aSemNsrFil	:= {} 								as Json

Private aLog		:= {{}}								as Array
Private aLogIntegC	:= {}								as Array
Private aLogTecInt	:= {}								as Array
Private aParams		:= {}								as Array
Private lApiToken	:= .F.								as Logical
Private lGeraTokn	:= .F.								as Logical

lRR1 := SuperGetMV("MV_APICLOD", .F., .F.) .And. TcCanOpen(RetSqlName("RR1"))

oJparams:FromJSON(cBody)

If checkParams(oJparams)
	cDataDe		:= StrTran(oJparams["startDate"],"-","")
	cDataAte	:= StrTran(oJparams["endDate"],"-","")
	cDataDe		:= Substr(cDataDe,1,4) + "-" + Substr(cDataDe,5,2) + "-" + Substr(cDataDe,7,2)
	cDataAte	:= Substr(cDataAte,1,4) + "-" + Substr(cDataAte,5,2) + "-" + Substr(cDataAte,7,2)
	aFiliais	:= oJparams["branches"]
	nLenFil		:= Len(aFiliais)

	fLimpVarCk()
	
	aParams := fBuscaParam()
	aDisps := fDispBusc()
	
	If aDisps[1] .and. Len(aDisps[3]) > 0
		aRetDisps := aDisps[3,1]
	EndIf
	
	If nLenFil == 1 .And. aFiliais[1] == "todas"
		aFiltro := {}
	Else
		aFiltro := aClone(aFiliais)
	EndIf
			
	aDados := fMarcBusc(Nil, aRetDisps, Nil, cDataDe, cDataAte, lDashBoard, aFiltro)

	If aDados[1] .And. Len(aDados[3]) > 0
		For nI := 1 To Len(aDados[3])
			If (ValType(aDados[3,nI,7]) == "C", aDados[3,nI,7] := Val(aDados[3,nI,7]), Nil)
			aDados[3,nI,8] := aDados[3,nI,8] := SubStr(aDados[3,nI,8],9,2) + "/" + SubStr(aDados[3,nI,8],6,2) + "/" + SubStr(aDados[3,nI,8],1,4) + " " + SubStr(aDados[3,nI,8],12,5)
			aAdd(aTodasCk,{"cnpj":aDados[3,nI,1],"cpf":aDados[3,nI,2],"pis":aDados[3,nI,3],"branch":aDados[3,nI,4],"name":DecodeUTF8(aDados[3,nI,5]),"device":aDados[3,nI,6],"nsr":aDados[3,nI,7],"dateTime":aDados[3,nI,8]})
		Next
		
		aSort(aDados[3],,,{|x,y| (x[6] < y[6]) .Or. (x[6] == y[6] .And. x[7] < y[7])})

		nTotMarc := Len(aDados[3])
		aMarcs := fFormDados(aDados[3])
		nLenaMarcs := Len(aMarcs)

		If lRR1 .And. !Empty(aParams[4])				
			For nI := 1 To nLenaMarcs
				fBuscClkIn(aMarcs[nI,1],aMarcs[nI,2],lRR1,@aIntegrads)
			Next
		ElseIf !lRR1 .And. lMSA .And. !Empty(aParams[4])
			For nI := 1 To nLenaMarcs
				fBuscClkIn(aMarcs[nI,1],aMarcs[nI,2],lRR1,@aIntegrads)
			Next
		EndIf

		fGerTdsVar(aTodasCk,aIntegrads)
	EndIf

	For nI := 1 To nLenFil
		If nLenFil == 1
			If (aFiliais[nI] == "todas",cNomeFil := STR0020, cNomeFil := aFiliais[nI])
				oResp[cValToChar(nI)] := {;
					"branch":cNomeFil,;
					"totalClockMarkings":Len(aTodasCk),;
					"totalDetails":aTodasCk,;
					"totalIntegrated":Len(aProc),;
					"integratedDetails":aProc,;
					"totalToBeIntegrated":Len(aPenden),;
					"toBeIntegratedDetails":aPenden,;
					"totalWhitoutNSR":Len(aSemNsr),;
					"whitoutNsrDetails":aSemNsr;
				}
		Else
			If nI == 1
				cNomeFil := STR0020
				oResp[cValToChar(nI)] := {;
					"branch":cNomeFil,;
					"totalClockMarkings":Len(aTodasCk),;
					"totalDetails":aTodasCk,;
					"totalIntegrated":Len(aProc),;
					"integratedDetails":aProc,;
					"totalToBeIntegrated":Len(aPenden),;
					"toBeIntegratedDetails":aPenden,;
					"totalWhitoutNSR":Len(aSemNsr),;
					"whitoutNsrDetails":aSemNsr;
				}
			EndIf

			aTodCkFil	:= {}
			aProcFil	:= {}
			aPendenFil	:= {}
			aSemNsrFil	:= {}

			fIndClockI(aFiliais[nI])
				cNomeFil := aFiliais[nI]
				oResp[cValToChar(nI+1)] := {;
					"branch":cNomeFil,;
					"totalClockMarkings":Len(aTodCkFil),;
					"totalDetails":aTodCkFil,;
					"totalIntegrated":Len(aProcFil),;
					"integratedDetails":aProcFil,;
					"totalToBeIntegrated":Len(aPendenFil),;
					"toBeIntegratedDetails":aPendenFil,;
					"totalWhitoutNSR":Len(aSemNsrFil),;
					"whitoutNsrDetails":aSemNsrFil;
				}
		EndIf
	Next

	oResp := oResp:ToJson()
Else
	lRet := .F.
	SetRestFault(400, EncodeUTF8(STR0012))  // "Parâmetros inválidos: Verifique se os Parâmetros startDate, endDate e branches foram enviados."
EndIf
Return oRest:setResponse(oResp)

//---------------------------------------------------------------------
/*/{Protheus.doc} DbHrEmail
@type			method
@description	Serviço para enviar e-mail com as informações do Dashboard
@author			Marco Nakazawa
@since			25/05/2022
/*/
//---------------------------------------------------------------------
@POST("api/rh/v1/DbHrEmail")
Function dbHrEmail()
Local cBody    		:= ""								as Character
Local cGpeMail		:= SuperGetMV("MV_GPEMAIL",.F.,"")	as Character
Local cRelausr		:= SuperGetMV("MV_RELAUSR",.F.,"")	as Character
Local oResp			:= JsonObject():New()				as Json
Local oJparams		:= JsonObject():New()				as Json
	
cBody := oRest:getBodyRequest()
oJparams:fromJson(cBody)

If ValType(oJparams) == "J" .And. oJparams["data"] <> Nil .And. !Empty(oJparams["data"])
	If Empty(cGpeMail) .And. Empty(cRelausr)
		lRet := .F.
		SetRestFault(400, EncodeUTF8(STR0019)) //"Falha no envio do e-mail, verifique as configurações do sistema para o envio de e-mails."
	Else
		If !PONA480A(.T.,oJparams)
			lRet := .F.
			SetRestFault(400, EncodeUTF8(STR0019)) //"Falha no envio do e-mail, verifique as configurações do sistema para o envio de e-mails."
		EndIf
	EndIf
Else
	lRet := .F.
	SetRestFault(401, EncodeUTF8(STR0024)) //"Parâmetros inválidos: Verifique se todos os Parâmetros foram enviados corretamente."
EndIf
Return oRest:setResponse(oResp)

//---------------------------------------------------------------------
/*/{Protheus.doc} DbHrGetExcel
@type			method
@description	Serviço para gerar o excel com os detalhamentos dos indicadores
@author			Marco Nakazawa
@since			08/11/2023
/*/
//---------------------------------------------------------------------
@POST("api/rh/v1/DbHrGetExcel")
Function DbHrGetExcel()
Local aResp			:= {}					as Array
Local cBody    		:= ""					as Character
Local oResp			:= JsonObject():New()	as Json
Local oJparams		:= JsonObject():New()	as Json
Local nLenData		:= 0					as Numeric
	
cBody := oRest:getBodyRequest()
oJparams:fromJson(cBody)

If ValType(oJparams) == "J" .And. oJparams["data"] <> Nil .And. !Empty(oJparams["data"])
	nLenData := Len(oJparams["data"])

	aResp := fExcelDash(oJparams["data", nLenData, "grpIndicators"], !oResp["managerIsEmpty"], .T.)
	
	If !Empty(aResp)
		oResp["fileName"]	:= aResp[1,1]
		oResp["file"]		:= aResp[1,2]
	EndIf
Else
	lRet := .F.
	SetRestFault(401, EncodeUTF8(STR0024)) //"Parâmetros inválidos: Verifique se todos os Parâmetros foram enviados corretamente."
EndIf
Return oRest:setResponse(oResp)

/*/{Protheus.doc} checkParams
Validação dos parâmetros recebidos.
@author Marco Nakazawa
@since 25/05/2022
/*/
Static Function checkParams(oJparams)
Local lRet 	:= .T. 		as Logical

Default oJparams = ""

If ValType(oJparams) == "J" .And. (oJparams["startDate"] == Nil .Or. oJparams["endDate"] == Nil .Or. oJparams["branches"] == Nil .Or. Empty(oJparams["branches"]))
	lRet := .F.
EndIf
Return lRet

/*/{Protheus.doc} fFormDados
Formata os dados de retorno da Carol para utilizar na query de marcações integradas.
@author Marco Nakazawa
@since 25/05/2022
/*/
Static Function fFormDados(aDados)
Local nI		:= 0	as Numeric
Local nLenDados	:= 0	as Numeric
Local cDisp		:= ""	as Character
Local aRetDados	:= {}	as Array

Default aDados := {}

If !Empty(aDados)
	nLenDados := Len(aDados)

	For nI := 1 To nLenDados
		If cDisp <> aDados[nI,6] .And. aDados[nI,7] > 0
			cDisp := aDados[nI,6]
			aAdd(aRetDados,{cDisp,{cValToChar(aDados[nI,7])}})
		ElseIf cDisp == aDados[nI,6] .And. aDados[nI,7] > 0
			aAdd(aRetDados[Len(aRetDados),2],cValToChar(aDados[nI,7]))
		EndIf
	Next
EndIf
Return aClone(aRetDados)

/*/{Protheus.doc} fBuscClkIn
Verifica quais marcações já estão integradas com o Protheus
@author Marco Nakazawa
@since 25/05/2022
/*/
Static Function fBuscClkIn(cDisp,aNSR,lRR1,aIntegrads)
Local nI			:= 0			as Numeric
Local nLenNSR		:= 0			as Numeric
Local nLimite		:= 0			as Numeric
Local cAlias		:= "TMPMARC"	as Character
Local cQuery		:= ""			as Character
Local aNsrWhere		:= {}			as Array

Static __oST1						as Object

Default cDisp		:= ""
Default aNSR		:= {}
Default aIntegrads	:= {}
Default lRR1		:= .F.

If __oSt1 == Nil
	__oSt1 := FWPreparedStatement():New()
	
	If !lRR1
		cQuery := "SELECT COD_RELOGIO_EXT_CHAVE AS DISPOSITIVO, COD_NSR AS NSR FROM MSA_CONTROL_MARCAC "
		cQuery += "WHERE COD_RELOGIO_EXT_CHAVE = ?"
		cQuery += "  AND COD_NSR IN (?)"
		cQuery += "  AND COD_UNID_EXT_CHAVE = '" + aParams[4] + "'"
	Else
		cQuery := "SELECT RR1.RR1_CODREL AS DISPOSITIVO, RR1.RR1_CODNSR AS NSR FROM "
		cQuery += RetSqlName("RR1") + " RR1 "
		cQuery += "WHERE RR1.RR1_CODREL = ?"
		cQuery += "  AND RR1.RR1_CODNSR IN (?)"
		cQuery += "  AND RR1.RR1_CODUNI = '" + aParams[4] + "'"
		cQuery += "  AND RR1.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery(cQuery)
	
	__oSt1:SetQuery(cQuery)
EndIf

If !Empty(aNSR)
	nLenNSR := Len(aNSR)

	If nLenNSR > 1000
		nLimite := 1000
		
		For nI := 1 To nLenNSR
			aAdd(aNsrWhere,aNSR[nI])
			
			If nI == nLimite .Or. nI == nLenNSR
				__oSt1:SetString(1,cDisp)
				__oSt1:SetIn(2,aNsrWhere)
				
				cQuery := __oSt1:getFixQuery()

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias)

				nLimite += 1000
				aNsrWhere := {}

				While !(cAlias)->(Eof())
					aAdd(aIntegrads,{AllTrim((cAlias)->DISPOSITIVO),(cAlias)->NSR})
					(cAlias)->(dbSkip())
				Enddo
				
				dbSelectArea(cAlias)
				dbCloseArea()
			EndIf
		Next
	Else
		__oSt1:SetString(1,cDisp)
		__oSt1:SetIn(2,aNSR)
				
		cQuery := __oSt1:getFixQuery()

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias)
		
		While !(cAlias)->(Eof())
			aAdd(aIntegrads,{AllTrim((cAlias)->DISPOSITIVO),(cAlias)->NSR})
			(cAlias)->(dbSkip())
		Enddo
		
		dbSelectArea(cAlias)
		dbCloseArea()
	EndIf

EndIf
Return

/*/{Protheus.doc} fFrtCalen
Formata o aTabCalend para resumir as informações por dia.
@author Marco Nakazawa
@since 03/04/2023
/*/
Static Function fFrtCalen(aTabCalend)
Local cPrevisto		:= ""									as Character
Local nI			:= 0									as Numeric
Local nLenTabCal	:= 0									as Numeric
Local nQtdmar		:= 0									as Numeric
Local aCalenFrt		:= {}									as Array
Local dDateAtu		:= sToD("  /  /  ")						as Date
Local dDateAnt		:= sToD("  /  /  ")						as Date
local lPrimeiro		:= .T.									as Logical
local lCpoIsento	:= SPA->(ColumnPos("PA_ISENTO")) > 0	as Logical

Default aTabCalend := {}

nLenTabCal := len(aTabCalend)

For nI := 1 To nLenTabCal
	dDateAtu := aTabCalend[nI,CALEND_POS_DATA_APO]
	
	If lPrimeiro
		dDateAnt := aTabCalend[nI,CALEND_POS_DATA_APO]
		lPrimeiro := .F.
	EndIf
	
	If nI == nLenTabCal
		cPrevisto += StrZero(aTabCalend[nI,CALEND_POS_HORA],5,2)
		cPrevisto := StrTran(cPrevisto,".",":")
		
		aAdd(aCalenFrt,{dDateAtu,++nQtdmar,cPrevisto, If(lCpoIsento, aTabCalend[nI,CALEND_POS_ISENTMARC], .F.), aTabCalend[nI,CALEND_POS_TIPO_DIA]})
		
		nQtdmar := 0
		cPrevisto := ""
		Loop
	EndIf
	
	If dDateAtu <> dDateAnt .And. nQtdmar > 0
		cPrevisto := SubStr(cPrevisto,1,Len(cPrevisto)-3)
		cPrevisto := StrTran(cPrevisto,".",":")
		
		aAdd(aCalenFrt,{dDateAnt,nQtdmar,cPrevisto, If(lCpoIsento, aTabCalend[nI-1,CALEND_POS_ISENTMARC], .F.), aTabCalend[nI-1,CALEND_POS_TIPO_DIA]})
		
		dDateAnt := dDateAtu
		nQtdmar := 0
		cPrevisto := ""
	EndIf
	
	nQtdmar++
	cPrevisto += StrZero(aTabCalend[nI,CALEND_POS_HORA],5,2) + " - "
	dDateAnt := aTabCalend[nI,CALEND_POS_DATA_APO]
	
Next
Return aCalenFrt

/*/{Protheus.doc} fValdMarca
Valida se o ponto do funcionário está completo, incompleto ou o funcionário não possui marcações no período
@author Marco Nakazawa
@since 03/04/2023
/*/
Static Function fValdMarca(aMarcFunc, aTabCalQtd, lFuncSMarc, aTodasMarc)
local cDataFormt	:= ""				as Character
Local nI			:= 0				as Numeric
Local nLenTabCal	:= 0				as Numeric
Local nPosMarc		:= 0				as Numeric
Local nPosFunc		:= 0				as Numeric
Local lPtComplet	:= .T.				as Logical
Local lIstTotPer	:= .T.				as Logical
Local lFds			:= .T.				as Logical

Default aMarcFunc	:= {}
Default aTabCalQtd	:= {}
Default aTodasMarc	:= {}
Default lFuncSMarc	:= .F.

For nI := 1 To Len(aTabCalQtd)
	If !aTabCalQtd[nI, 4]
		lIstTotPer := .F.
		Exit
	EndIf
Next

For nI := 1 To Len(aTabCalQtd)
	If aTabCalQtd[nI, 5] == "S"
		lFds := .F.
		Exit
	EndIf
Next

If lIstTotPer
	If !Empty(aMarcFunc)
		nPosFunc := aScan(aTodasMarc, {|x| x["branch"] == aMarcFunc[1, 1] .And. x["registration"] == aMarcFunc[1, 2]})
		If nPosFunc > 0
			aDel(aTodasMarc, nPosFunc)
			aSize(aTodasMarc, Len(aTodasMarc)-1)
		EndIf
	EndIf
	Return 	
EndIf

If lFuncSMarc 
	If lFds
		aAdd(aPtCompl,{"branch":aMarcFunc[1,1],"registration":aMarcFunc[1,2],"name":aMarcFunc[1,3],"department":aMarcFunc[1,4],"manager":aMarcFunc[1,10],"managerId":aMarcFunc[1,11]})
	Else
		aAdd(aSemMarc,{"branch":aMarcFunc[1,1],"registration":aMarcFunc[1,2],"name":aMarcFunc[1,3],"department":aMarcFunc[1,4],"manager":aMarcFunc[1,10],"managerId":aMarcFunc[1,11]})
	EndIf
Else
	nLenTabCal := len(aTabCalQtd)
	
	For nI := 1 To nLenTabCal
		If !aTabCalQtd[nI,4] .And. (nPosMarc := aScan(aMarcFunc, {|x| x[5] == aTabCalQtd[nI,1]})) > 0
			cDataFormt := dToS(aTabCalQtd[nI,1])
			cDataFormt := SubStr(cDataFormt,7,2) + "/" + SubStr(cDataFormt,5,2) + "/" + SubStr(cDataFormt,1,4)
			
			If aMarcFunc[nPosMarc,6] < aTabCalQtd[nI,2] .And. aTabCalQtd[nI, 5] == "S"
				If aTabCalQtd[nI,2] - aMarcFunc[nPosMarc,6] == 1
					aAdd(aPtIncomp,{"branch":aMarcFunc[1,1],"registration":aMarcFunc[1,2],"name":aMarcFunc[1,3],"department":aMarcFunc[1,4],"manager":aMarcFunc[1,10],"dateTime":cDataFormt,"reason":STR0022, "estimated":aTabCalQtd[nI,3],"performed":aMarcFunc[nPosMarc,7],"managerId":aMarcFunc[1,11]})
				Else
					aAdd(aPtIncomp,{"branch":aMarcFunc[1,1],"registration":aMarcFunc[1,2],"name":aMarcFunc[1,3],"department":aMarcFunc[1,4],"manager":aMarcFunc[1,10],"dateTime":cDataFormt,"reason":cValToChar((aTabCalQtd[nI,2] - aMarcFunc[nPosMarc,6])) + " " + STR0025, "estimated":aTabCalQtd[nI,3],"performed":aMarcFunc[nPosMarc,7],"managerId":aMarcFunc[1,11]})
				EndIf
				
				lPtComplet := .F.
				Loop
			EndIf
		ElseIf !aTabCalQtd[nI,4] .And. aTabCalQtd[nI, 5] == "S"	
			cDataFormt := dToS(aTabCalQtd[nI,1])
			cDataFormt := SubStr(cDataFormt,7,2) + "/" + SubStr(cDataFormt,5,2) + "/" + SubStr(cDataFormt,1,4)
			
			aAdd(aPtIncomp,{"branch":aMarcFunc[1,1],"registration":aMarcFunc[1,2],"name":aMarcFunc[1,3],"department":aMarcFunc[1,4],"manager":aMarcFunc[1,10],"dateTime":cDataFormt,"reason":STR0023, "estimated":aTabCalQtd[nI,3],"performed":"","managerId":aMarcFunc[1,11]})
			
			lPtComplet := .F.
			Loop
		EndIf
		
		If nI == nLenTabCal .And. lPtComplet
			aAdd(aPtCompl,{"branch":aMarcFunc[1,1],"registration":aMarcFunc[1,2],"name":aMarcFunc[1,3],"department":aMarcFunc[1,4],"manager":aMarcFunc[1,10],"managerId":aMarcFunc[1,11]})
		EndIf
	Next
EndIf

If (!lPtComplet,nTotIncomp++,Nil)
Return

/*/{Protheus.doc} fIndFunc
Separa os indicadores de funcionários por filial
@author Marco Nakazawa
@since 03/04/2023
/*/
Static Function fIndFunc(cFil)
Local nI 			:= 0					as Numeric
Local nLenPtComp	:= Len(aPtCompl)		as Numeric
Local nLenPtInco	:= Len(aPtIncomp)		as Numeric
Local nLenSemMar	:= Len(aSemMarc)		as Numeric
Local cMatAnt		:= ""					as Character

Default cFil := ""

If !Empty(cFil)
	cFil := AllTrim(cFil)
	
	For nI := 1 To nLenPtComp
		If AllTrim(aPtCompl[nI,"branch"]) == cFil
			aAdd(aTodosFil,aPtCompl[nI])
			aAdd(aPtCompFil,aPtCompl[nI])
		EndIf
	Next

	For nI := 1 To nLenPtInco
		If AllTrim(aPtIncomp[nI,"branch"]) == cFil
			aAdd(aPtIncFil,aPtIncomp[nI])
			
			If AllTrim(aPtIncomp[nI,"registration"]) <> cMatAnt
				aAdd(aTodosFil,{"branch":aPtIncomp[nI,"branch"],"registration":aPtIncomp[nI,"registration"],"name":aPtIncomp[nI,"name"],"department":aPtIncomp[nI,"department"],"manager":aPtIncomp[nI,"manager"],"managerId":aPtIncomp[nI,"managerId"]})
				nTotInFil++
				cMatAnt := AllTrim(aPtIncomp[nI,"registration"])
			EndIf
		EndIf
	Next

	For nI := 1 To nLenSemMar
		If AllTrim(aSemMarc[nI,"branch"]) == cFil
			aAdd(aTodosFil,aSemMarc[nI])
			aAdd(aSemMrcFil,aSemMarc[nI])
		EndIf
	Next
EndIf
Return 

/*/{Protheus.doc} fLimpVarPt
Limpa as variáveis estáticas dos indicadores de funcionários
@author Marco Nakazawa
@since 03/04/2023
/*/
Static Function fLimpVarPt()
aTodasMarc	:= {}
aPtCompl	:= {}
aPtIncomp	:= {}
nTotIncomp	:= 0
aSemMarc	:= {}
aTodosFil	:= {}
aPtCompFil	:= {}
aPtIncFil	:= {}
nTotInFil	:= 0 
aSemMrcFil	:= {}
Return

/*/{Protheus.doc} fLimpVarCk
Limpa as variáveis estáticas dos indicadores do Clock In
@author Marco Nakazawa
@since 03/04/2023
/*/
Static Function fLimpVarCk()
aTodasCk	:= {}
aProc		:= {}
aPenden		:= {}
aSemNsr		:= {}
aTodCkFil	:= {}
aProcFil	:= {}
aPendenFil	:= {}
aSemNsrFil	:= {}
Return

/*/{Protheus.doc} fGerTdsVar
Gera o array com todas as marcações e suas situações (Integradas ou não integradas)
@author Marco Nakazawa
@since 03/04/2022
/*/
Static Function fGerTdsVar(aTodasCk,aIntegrads)
Local nI			:= 0					as Numeric

Default aTodasCk	:= {}
Default aIntegrads	:= {}

If !Empty(aTodasCk)
	For nI := 1 To Len(aTodasCk)
		If aTodasCk[nI,"nsr"] == 0
			aAdd(aSemNsr,aTodasCk[nI])
		ElseIf aScan(aIntegrads,{|x| x[1] == aTodasCk[nI,"device"] .And. x[2] == aTodasCk[nI,"nsr"]}) > 0
			aAdd(aProc,aTodasCk[nI])
		Else
			aAdd(aPenden,aTodasCk[nI])
		EndIf
	Next
EndIf
Return

/*/{Protheus.doc} fIndClockI
Separa os indicadores do Clock In por filial
@author Marco Nakazawa
@since 03/04/2023
/*/
Static Function fIndClockI(cFil)
Local nI 			:= 0					as Numeric
Local nLenProc		:= Len(aProc)			as Numeric
Local nLenPend		:= Len(aPenden)			as Numeric
Local nLenSemNsr	:= Len(aSemNsr)			as Numeric

Default cFil := ""

If !Empty(cFil)
	cFil := AllTrim(cFil)
	
	For nI := 1 To nLenProc
		If AllTrim(aProc[nI,"branch"]) == cFil
			aAdd(aTodCkFil,aProc[nI])
			aAdd(aProcFil,aProc[nI])
		EndIf
	Next

	For nI := 1 To nLenPend
		If AllTrim(aPenden[nI,"branch"]) == cFil
			aAdd(aTodCkFil,aPenden[nI])
			aAdd(aPendenFil,aPenden[nI])
		EndIf
	Next

	For nI := 1 To nLenSemNsr
		If AllTrim(aSemNsr[nI,"branch"]) == cFil
			aAdd(aTodCkFil,aSemNsr[nI])
			aAdd(aSemNsrFil,aSemNsr[nI])
		EndIf
	Next
EndIf
Return 

/*/{Protheus.doc} fGestFunc
Retorna a query para trazer os funcionários que estão abaixo do gestor
@author Marco Nakazawa
@since 08/08/2023
/*/
Function fGestFunc(aGestores, cWhereFil)
Local nI 			:= 0										as Numeric
Local nLenGestor	:= 0										as Numeric
Local cOrgCfg		:= SuperGetMV("MV_ORGCFG", .F., "0")		as Character
Local cJoiFilSQB	:= FWJoinFilial("SQB", "SRA")				as Character
Local cJoiFilSRJ	:= FWJoinFilial("SRJ", "SRA")				as Character
Local cFilGestor	:= ""										as Character
Local cMatGestor	:= ""										as Character
Local cInGesto		:= ""										as Character
local cGestor		:= ""										as Character
Local cQuery		:= ""										as Character

Default aGestores := {}
Default cWhereFil := ""

nLenGestor := Len(aGestores)

DbSelectArea("SQB")

If !Empty(nLenGestor)
	If (!Empty(cWhereFil), cWhereFil := StrTran(cWhereFil,"%",""), cWhereFil := "SRA.RA_FILIAL <> ' '")
	
	If cOrgCfg == "1"
		If nLenGestor == 1 .And. aGestores[1] == "todos"
			cInGesto := "RCX.RCX_FILFUN || RCX.RCX_MATFUN = SRA.RA_FILIAL || SRA.RA_MAT"
			cQuery := "%LEFT JOIN ( "
		ElseIf nLenGestor == 1 .And. aGestores[1] <> "todos"
			cGestor		:= SubStr(aGestores[1], At("(", aGestores[1]) + 1)
			cGestor		:= StrTran(cGestor, ")", "")
			cFilGestor	:= SubStr(cGestor, 1, FWSizeFilial())
			cMatGestor	:= SubStr(cGestor, At("-", cGestor) + 2)
			cInGesto	:= "RCX.RCX_FILFUN || RCX.RCX_MATFUN IN ('" + cFilGestor + cMatGestor + "')"
			cQuery := "%INNER JOIN ( "
		ElseIf nLenGestor > 1
			cInGesto	:= "RCX.RCX_FILFUN || RCX.RCX_MATFUN IN ("
			cQuery := "%INNER JOIN ( "
			
			For nI := 1 To nLenGestor
				cGestor		:= SubStr(aGestores[nI], At("(", aGestores[nI]) + 1)
				cGestor		:= StrTran(cGestor, ")", "")
				cFilGestor	:= SubStr(cGestor, 1, FWSizeFilial())
				cMatGestor	:= SubStr(cGestor, At("-", cGestor) + 2)
				If nI == nLenGestor
					cInGesto += "'" + cFilGestor + cMatGestor + "')"
				Else
					cInGesto += "'" + cFilGestor + cMatGestor + "',"
				EndIf
			Next
		EndIf
		
		cQuery += "SELECT "
		cQuery += "  SRA.RA_FILIAL, "
		cQuery += "  SRA.RA_MAT, "
		cQuery += "  SRAG.RA_NOME AS GESTOR,"
		cQuery += "  SRAG.RA_FILIAL AS FILGESTOR,"
		cQuery += "  SRAG.RA_MAT AS MATGESTOR, "
		cQuery += "  SRAG.RA_EMAIL AS EMAILGESTOR "
		cQuery += "FROM " + RetSqlName("RD4") + " RD4 "
		cQuery += "INNER JOIN " + RetSqlName("RCX") + " RCX ON RCX.RCX_POSTO = RD4.RD4_CODIDE "
		cQuery += "INNER JOIN " + RetSqlName("SRA") + " SRA ON RCX.RCX_FILFUN = SRA.RA_FILIAL AND RCX.RCX_MATFUN = SRA.RA_MAT "
		cQuery += "INNER JOIN ( "
		cQuery += "	SELECT RD4_FILIDE, RD4.RD4_ITEM, SRA.RA_NOME, SRA.RA_FILIAL, SRA.RA_MAT, SRA.RA_EMAIL FROM " + RetSqlName("RCX") + " RCX "
		cQuery += "	INNER JOIN " + RetSqlName("RD4") + " RD4 ON RCX.RCX_POSTO = RD4.RD4_CODIDE "
		cQuery += "	INNER JOIN " + RetSqlName("SRA") + " SRA ON RCX.RCX_FILFUN = SRA.RA_FILIAL AND RCX.RCX_MATFUN = SRA.RA_MAT "
		
		If (nLenGestor == 1 .And. aGestores[1] == "todos", Nil, cQuery += "  WHERE " + cInGesto + " ")
		
		cQuery += ") SRAG ON SRAG.RD4_ITEM = RD4.RD4_TREE AND SRAG.RD4_FILIDE = RD4.RD4_FILIDE "
		cQuery += "WHERE  SRA.RA_SITFOLH <> 'D' "
		cQuery += "  AND " + cWhereFil + " "
		cQuery += "  AND RCX.RCX_SUBST = '2' "
		cQuery += "  AND RCX.RCX_TIPOCU = '1' "
		cQuery += "  AND RCX.RCX_FILIAL = RD4.RD4_FILIDE "
		cQuery += "  AND RD4.D_E_L_E_T_ = ' ' "
		cQuery += "  AND SRA.D_E_L_E_T_ = ' ' "
		cQuery += "  AND RCX.D_E_L_E_T_ = ' ' "
		cQuery += "GROUP BY SRA.RA_FILIAL, SRA.RA_MAT, SRAG.RA_NOME, SRAG.RA_FILIAL, SRAG.RA_MAT, SRAG.RA_EMAIL "
		cQuery += ") SRAGEST ON SRAGEST.RA_FILIAL = SRA.RA_FILIAL AND SRAGEST.RA_MAT = SRA.RA_MAT%"
	Else
		If nLenGestor == 1 .And. aGestores[1] == "todos"
			cQuery := "%LEFT JOIN ( "
		ElseIf nLenGestor == 1 .And. aGestores[1] <> "todos"
			cGestor		:= SubStr(aGestores[1], At("(", aGestores[1]) + 1)
			cGestor		:= StrTran(cGestor, ")", "")
			cFilGestor	:= SubStr(cGestor, 1, FWSizeFilial())
			cMatGestor	:= SubStr(cGestor, At("-", cGestor) + 2)
			cInGesto	:= "SQB.QB_FILRESP || SQB.QB_MATRESP IN ('" + cFilGestor + cMatGestor + "')"
			cQuery := "%INNER JOIN ( "
		ElseIf nLenGestor > 1
			cInGesto	:= "SQB.QB_FILRESP || SQB.QB_MATRESP IN ("
			cQuery := "%INNER JOIN ( "
			For nI := 1 To nLenGestor
				cGestor		:= SubStr(aGestores[nI], At("(", aGestores[nI]) + 1)
				cGestor		:= StrTran(cGestor, ")", "")
				cFilGestor	:= SubStr(cGestor, 1, FWSizeFilial())
				cMatGestor	:= SubStr(cGestor, At("-", cGestor) + 2)
				If nI == nLenGestor
					cInGesto += "'" + cFilGestor + cMatGestor + "')"
				Else
					cInGesto += "'" + cFilGestor + cMatGestor + "',"
				EndIf
			Next
		EndIf
		
		cQuery += "SELECT "
		cQuery += "  SRA.RA_FILIAL,"
		cQuery += "  SRA.RA_MAT, "
		cQuery += "  SRAG.RA_NOME AS GESTOR,"
		cQuery += "  SRAG.RA_FILIAL AS FILGESTOR,"
		cQuery += "  SRAG.RA_MAT AS MATGESTOR, "
		cQuery += "  SRAG.RA_EMAIL AS EMAILGESTOR "
		cQuery += "FROM " + RetSqlName("SRA") + " SRA "
		cQuery += "INNER JOIN " + RetSqlName("SQB") + " SQB ON SQB.QB_DEPTO = SRA.RA_DEPTO AND " + cJoiFilSQB + " AND SQB.D_E_L_E_T_= ' ' "
		cQuery += "INNER JOIN " + RetSqlName("SRA") + " SRAG ON SQB.QB_DEPTO = SRA.RA_DEPTO AND SQB.QB_FILRESP || SQB.QB_MATRESP = SRAG.RA_FILIAL || SRAG.RA_MAT "
		cQuery += "LEFT JOIN " + RetSqlName("SRJ") + " SRJ ON SRJ.RJ_FUNCAO = SRA.RA_CODFUNC AND " + cJoiFilSRJ + " AND SRJ.D_E_L_E_T_= ' ' "
		cQuery += "WHERE SRA.RA_SITFOLH <> 'D' "
		cQuery += "  AND SRA.D_E_L_E_T_= ' ' "
		cQuery += "  AND " + cWhereFil + " "
		
		If (nLenGestor == 1 .And. aGestores[1] == "todos",Nil,cQuery += "  AND " + cInGesto + " ")

		cQuery += "  AND SQB.QB_FILRESP || SQB.QB_MATRESP <> SRA.RA_FILIAL || SRA.RA_MAT "
		cQuery += "GROUP BY SRA.RA_FILIAL, SRA.RA_MAT, SRAG.RA_NOME, SRAG.RA_FILIAL, SRAG.RA_MAT, SRAG.RA_EMAIL "
		cQuery += ") SRAGEST ON SRAGEST.RA_FILIAL = SRA.RA_FILIAL AND SRAGEST.RA_MAT = SRA.RA_MAT%"
	EndIf
EndIf


Return cQuery
