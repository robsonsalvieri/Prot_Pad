#include 'totvs.ch'
#include "tlpp-core.th"

/*/{Protheus.doc} OFSoCustomerService
	Classe para tratar mensagens relacionados a customer para o service operations

	@type class
	@author Vinicius Gati
	@since 30/06/2021
/*/
Class OFSoCustomerService
	Public data lExplicit
	Public data lAsync
	Public data oLockService
	public data oMessage
	Public data cMsgVX5
	Public data cOriId

	Public Method New()
	Public Method SetWorkAsExplicit()
	Public Method SetWorkAsAsync()
	Public Method CanContinueProcess()
	Public Method Save()
	Public Method Delete()

	Public Method SendCreatedMessage()
	Public Method SendUpdatedMessage()
	Public Method SendRemovedMessage()
	Public Method Process()
EndClass

/*/{Protheus.doc} New
	Construtor Simples

	@type method
	@author Vinicius Gati
	@since 30/06/2021
/*/
Method New(cMsgVX5, cOriId) Class OFSoCustomerService
	::lExplicit := .f. //TODO: default to implicit lock
	::lAsync := .f. //TODO: implementar quando JD implementar, hoje é idc
	//::oLockService := OFSoLockService():New(.t.)
	::cMsgVX5   := cMsgVX5
	::cOriId    := cOriId
Return SELF

/*/{Protheus.doc} SetWorkAsExplicit
	Seta o serviço para trabalhar com lock explicito

	@type method
	@author Vinicius Gati
	@since 10/08/2021
/*/
Method SetWorkAsExplicit() Class OFSoCustomerService
	self:lExplicit := .t.
Return .t.

/*/{Protheus.doc} SetWorkAsAsync
	Seta a estrategia de trabalho como assincrona

	@type method
	@author Vinicius Gati
	@since 10/08/2021
/*/
Method SetWorkAsAsync() Class OFSoCustomerService
	self:lAsync := .t.
Return .t.

/*/{Protheus.doc} CanContinueProcess
	Verifica se é possivel continuar o processo desejado, pelo parametro do cliente 
	sei se será um update ou um novo cliente passando um objeto em branco
	Mas o que define se pode ou não é a obtenção de um lock no MIG caso explicito, caso implicito só libera

	@type method
	@author Vinicius Gati
	@since 10/08/2021
/*/
// Method CanContinueProcess(oCliente) Class OFSoCustomerService
// 	lNew := oCliente:IsNew()
// 	if ! self:lExplicit
// 		return .t. // trabalhando com implicito é tranquilo, faz depois perunta de lock
// 	endif

// 	if lNew
// 		oMessage := OFSoCustomerCreatedInDbsMessage():New(oCliente)
// 		//self:oLockService:Lock(oMessage)
// 	else
// 		// updated in dbs message
// 		// self:oLock := adquire o lock para a mensagem
// 	endif
// Return .f.

/*/{Protheus.doc} Save
	Salva o objeto passado, vai criar ou alterar dependendo da situacao

	@type method
	@author Vinicius Gati
	@since 11/08/2021
/*/
Method Save(oCliente) Class OFSoCustomerService
	lNew     := oCliente:IsNew()
	lSuccess := oCliente:Save()
	if lSuccess
		if lNew
			oMessage := OFSoCustomerCreatedInDbsMessage():New(oCliente)
			oMessage:Send()
		else
			oMessage := OFSoCustomerUpdatedInDbsMessage():New(oCliente)
			oMessage:Send()
		endif
	endif
Return .f.


/*/{Protheus.doc} SendCreatedMessage
	envia mensagem de createdinDbs

	@type method
	@author Vinicius Gati
	@since 13/08/2021
/*/
Method SendCreatedMessage(oSoCustomer) Class OFSoCustomerService
	local cJson
	local cErro := ""
	self:oMessage := OFSoCustomerCreatedInDbsMessage():New(oSoCustomer)
	//self:oMessage := OFSoCustomerCreatedInDbsMessage():New()
	self:oMessage:oSoRequest:Set("VK5_ORITAB", "VK7")
	self:oMessage:oSoRequest:Set("VK5_MESSAG", self:cMsgVX5)
	self:oMessage:oSoRequest:Set("VK5_ORIKEY", self:cOriId)
//	self:oMessage:oSoRequest:Set("VK5_REQBOD", oSoCustomer:toJson())
	cJson := FGX_JSONform( oSoCustomer:toJson(), .T., @cErro )
	self:oMessage:oSoRequest:Set("VK5_REQBOD", iif( empty( cErro ), cJson, oSoCustomer:toJson() ) )
Return self:oMessage:Send()

/*/{Protheus.doc} SendUpdatedMessage
	SendUpdatedMessage

	@type method
	@author Vinicius Gati
	@since 13/08/2021
/*/
Method SendUpdatedMessage(oSoCustomer) Class OFSoCustomerService
	local cJson
	local cErro := ""
	self:oMessage := OFSoCustomerUpdatedInDbsMessage():New(oSoCustomer)
	self:oMessage:oSoRequest:Set("VK5_ORITAB", "VK7")
	self:oMessage:oSoRequest:Set("VK5_MESSAG", self:cMsgVX5)
	self:oMessage:oSoRequest:Set("VK5_ORIKEY", self:cOriId)
//	self:oMessage:oSoRequest:Set("VK5_REQBOD", oSoCustomer:toJson())
	cJson := FGX_JSONform( oSoCustomer:toJson(), .T., @cErro )
	self:oMessage:oSoRequest:Set("VK5_REQBOD", iif( empty( cErro ), cJson, oSoCustomer:toJson() ) )
Return self:oMessage:Send()


/*/{Protheus.doc} SendRemovedMessage
	SendRemovedMessage

	@type method
	@author Vinicius Gati
	@since 13/08/2021
/*/
Method SendRemovedMessage(oSoCustomer) Class OFSoCustomerService
	local cJson
	local cErro := ""
	self:oMessage := OFSoCustomerRemovedInDbsMessage():New(oSoCustomer)
	self:oMessage:oSoRequest:Set("VK5_ORITAB", "VK7")
	self:oMessage:oSoRequest:Set("VK5_MESSAG", self:cMsgVX5)
	self:oMessage:oSoRequest:Set("VK5_ORIKEY", self:cOriId)
//	self:oMessage:oSoRequest:Set("VK5_REQBOD", oSoCustomer:toJson())
	cJson := FGX_JSONform( oSoCustomer:toJson(), .T., @cErro )
	self:oMessage:oSoRequest:Set("VK5_REQBOD", iif( empty( cErro ), cJson, oSoCustomer:toJson() ) )
Return self:oMessage:Send()

/*/{Protheus.doc} Process
	Metodo que processa as requisicoes vindas do Service Operations

	@type method
	@author Vinicius Gati
	@since 30/06/2021
/*/
Method Process(aQueryParams as Array, cBody as Character, cGatewayHeader as Character) Class OFSoCustomerService
	local jGatewayHeader := JsonObject():New()
	local cParseHead := jGatewayHeader:fromJson(cGatewayHeader)
	Local oSoRequest := OFSoRequestBody():New(cBody)

	if ! empty(cParseHead)
		return OFSoInvalidGatewayHeaderResponse():New()
	endif

	if ! oSoRequest:IsValid()
		return OFSoInvalidBodyResponse():New()
	endif

	if oSoRequest:GetName() == "CustomerCreatedInFieldService"
		return OFSoCustomerCreatedInFieldServiceInteractor():Process(oSoRequest, jGatewayHeader)
	elseif oSoRequest:GetName() == "CustomerUpdatedInFieldService"
		return OFSoCustomerUpdatedInFieldServiceInteractor():Process(oSoRequest, jGatewayHeader)
	endif
Return OFSoInvalidBodyResponse():New()
