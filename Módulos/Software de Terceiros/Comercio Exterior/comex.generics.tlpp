#include "msobject.ch"
#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "comex.generics.ch"

namespace comex.generics

/*
nomes longos: https://tdn.totvs.com/display/tec/Nomes+longos
namespace: https://tdn.totvs.com/display/tec/Namespace
classes: https://tdn.totvs.com/display/tec/Classes
tipagem: https://tdn.totvs.com/display/tec/Tipagem+em+TLPP
ProtheusDoc: https://marketplace.visualstudio.com/items?itemName=AlencarGabriel.protheusdoc-vscode
docs: https://github.com/totvs/tlpp-sample-rest-documentation/wiki
*/

/*{Protheus.doc} setFilterInQueryPreparedStatement
Objetivo de aplicar filtros em uma query do tipo prepared statement
@type function
@author Maurício
@since 11/7/2024
@param cAlias, character, alias que sofrerá a aolicaçaõ dos filtros
@param cQuery, character, script do sql que será executado
@param aQryInfo, array, array com os filtros a serem aplicados na query
@param aSetField, array, array com os campos para aplicar tcsetField
@return variant, sem retorno
*/
function setFilterInQueryPreparedStatement(cAlias,cQuery,aQryInfo,aSetField) 
Local nInd as integer
Local oQuery := FWPreparedStatement():New(cQuery)        
for nInd := 1 to len(aQryInfo)
    Do Case 
        Case aQryInfo[nInd][2] == "C"
	        oQuery:SetString( nInd , aQryInfo[nInd][1] )
        Case aQryInfo[nInd][2] == "D" //Formato AAAAMMDD
            oQuery:SetDate( nInd , StoD(aQryInfo[nInd][1]) )
        Case aQryInfo[nInd][2] == "DD" //Formato DD/MM/AAAA
            oQuery:SetDate( nInd , aQryInfo[nInd][1] )
        Case aQryInfo[nInd][2] == "N"
	        oQuery:SetNumeric( nInd , aQryInfo[nInd][1] )            
    EndCase        
next

cQuery := oQuery:GetFixQuery()
fwFreeObj(oQuery)
MPSysOpenQuery(cQuery, cAlias)

for nInd := 1 to len(aSetfield)
    TCSetField(cAlias,aSetField[nInd][1],aSetField[nInd][2],aSetField[nInd][3],aSetField[nInd][4])
next

Return 

/*/{Protheus.doc} validJson
    Realiza a validação de um JSON

    @type  Function
    @author user
    @since 19/12/2024
    @version version
    @param cJson, caracter, Json no formato em string
    @return lRet, logico, Verdadeiro o json está correto, falso caso contrário
    @example
    (examples)
    @see (links_or_references)
    /*/
function validJson(cJson, cError)
    local lRet   as logical
    local oJson  as object

    default cJson := ""

    lRet := .T.
    if !empty(cJson)
        oJson  := JsonObject():New()
        cError := oJson:FromJson(cJson)
        lRet := ValType(cError) == "U"
        FwFreeObj(oJson)
    endif

return lRet

/*/{Protheus.doc} SetStringJson
    Realiza o tratamento de informação de string de atributo do JSON

    @type  Function
    @author user
    @since 19/12/2024
    @version version
    @param cInfJson, caracter, Informação em string do JSON
    @return cRet, caracter, Conteúdo da string do JSON tratado
    @example
    (examples)
    @see (links_or_references)
    /*/
function SetStringJson(cInfJson)
    local cRet   as character 

    default cInfJson := ""

    cRet := cInfJson
    if !empty(cRet)
        cRet := allTrim(cRet)
        cRet := strTran(cRet, '"', '\"')
        cRet := strTran(cRet, chr(13)+chr(10), " ")
    endif

return cRet

/*/{Protheus.doc} IsWebApp
    Função para verificar se é webapp

    @type  Function
    @author user
    @since 19/12/2024
    @version version
    @param cInfJson, caracter, Informação em string do JSON
    @return cRet, caracter, Conteúdo da string do JSON tratado
    @example
    (examples)
    @see (links_or_references)
    /*/
function IsWebApp(cLibClient, nTypeRemot)
   local lIsWebApp  := .F.

   default cLibClient := ""
   default nTypeRemot := 0
   
   nTypeRemot := GetRemoteType(@cLibClient)   
   lIsWebApp  := "HTML" $ alltrim(upper(cLibClient))

return lIsWebApp

/*/{Protheus.doc} VldVrsWAgt
    Realiza a validação da versão do WebAgent
    
    @type  Function
    @author user
    @since 01/07/2025
    @version version
    @param cParVersao, caractere, versão corrente
           cVerValid, caractere, versão ser validada
           cToken, caractere, token de separação entre os números da versão (padrão é ponto ".")
    @return lRet, logico, Verdadeiro é uma versão valida, falso se não for passado as versões para comparação ou se é uma versão inválida
    @example
    (examples)
    @see (links_or_references)
/*/
function VldVrsWAgt(cVerValid, cParVersao, cToken)
    local lRet      as logical
    local aVersao   as array
    local aVerVld   as array
    local nLenIni   as integer
    local nLenFim   as integer
    local nLenMenor as integer
    local nI        as integer
    
    default cVerValid  := ""
    default cParVersao := if( existFunc("GetWebAgentInfo"), GetWebAgentInfo()[1], "")
    default cToken := "."

    if (lRet := !empty(cParVersao) .and. !empty(cVerValid))
        aVersao := StrToKArr(cParVersao, cToken)
        aVerVld := StrToKArr(cVerValid, cToken)
        nLenIni := Len(aVersao)
        nLenFim := Len(aVerVld)
        nLenMenor := Min(nLenIni, nLenFim)

        for nI := 1 to nLenMenor
            if Val(aVersao[nI]) < Val(aVerVld[nI])
                lRet := .F.
                exit
            endif
        next
    endif

return lRet

/*/{Protheus.doc} LoadAphLogo
    Função para carregar a logo do repositório de imagens da Totvs
    @type  Function
    @author user
    @since 08/08/2025
    @version version
    @param 
    @return cLogo, caracter, Caminho da logo carregada
    @example
    (examples)
    @see (links_or_references)
    /*/
Function LoadAphLogo()
Local cFileName := "LOGOAPH"
Local cPathPict := GetTempPath()
Local oObjImg   := FwBmpRep():New()
Local cMod      := cModulo
Local cEmpresa  := FWCodEmp()
Local cFil      := FWCodFil()
Local lExist    := .F.
Private cLogo   := ""

    IF(EasyEntryPoint("Comex_Generics"),ExecBlock("Comex_Generics",.F.,.F.,"ALTERA_LOGO"),)

    If Empty(cLogo)
        oObjImg:OpenRepository()

        Do Case
            Case oObjImg:ExistBmp(cMod + cFileName + cEmpresa + cFil)
                cFileName := cMod + cFileName + cEmpresa + cFil
                lExist := .T.
            Case oObjImg:ExistBmp(cFileName + cEmpresa + cFil)
                cFileName := cFileName + cEmpresa + cFil
                lExist := .T.
            Case oObjImg:ExistBmp(cMod + cFileName + cEmpresa)
                cFileName := cMod + cFileName + cEmpresa
                lExist := .T.
            Case oObjImg:ExistBmp(cFileName + cEmpresa)
                cFileName := cFileName + cEmpresa
                lExist := .T.
            Case oObjImg:ExistBmp(cMod + cFileName)
                cFileName := cMod + cFileName
                lExist := .T.
            Case oObjImg:ExistBmp(cFileName)
                lExist := .T.
        End Case

        If lExist
            oObjImg:Extract(cFileName, cPathPict+cFileName)
            // Atualmente só é possível importar JPG ou BMP no Respositório de Imagens da TOTVS, por isso essa verificação simples
            cLogo := IIF(File(cPathPict+cFileName+'.jpg'), cPathPict+cFileName+'.jpg', cPathPict+cFileName+'.bmp')
        EndIf
        oObjImg:CloseRepository()
    EndIf

Return cLogo

/*/{Protheus.doc} TEOpenExcel
   Função para abrir o arquivo excel

   @type  Static Function
   @author user
   @since 24/01/2025
   @version version
   @param cFileName, caracter, nome do arquivo
   @return nenhum
   @example
   (examples)
   @see (links_or_references)
/*/
function TEOpenExcel(cFileName)
   local oExcelApp
   local cFileTMP := GetTempPath(, IIF(GetRemoteType() == 5, .T., .F.))

    TRY        
        oExcelApp := MsExcel():New()
        CpyS2T(cFileName, cFileTMP)
        oExcelApp:WorkBooks:Open(cFileTMP + cFileName)
        oExcelApp:SetVisible(.T.)
        oExcelApp:Destroy()
    CATCH oError
        easyHelp(oError:description,STR0001,STR0002) //'Atenção','Verifique ou instale o excel no seu ambiente'
    ENDTRY

return nil
