#INCLUDE "DBINFO.CH"
#INCLUDE "MNTA420.ch"
#INCLUDE "PROTHEUS.CH"

Static lRel12133 := GetRPORelease() >= '12.1.033'
Static lHasFlut  := SuperGetMV( 'MV_NGFLUT' , .F., 'N' ) == 'S'
Static lHasMNTCM := SuperGetMV( 'MV_NGMNTCM', .F., 'N' ) == 'S'
Static lHasMNTES := SuperGetMV( 'MV_NGMNTES', .F., 'N' ) == 'S'
Static lUseLoclz := SuperGetMv( 'MV_LOCALIZ', .F., 'N' ) == 'S'
Static cGerSA    := SuperGetMv( 'MV_NGGERSA', .F., 'N' )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MNTA420  ³ Autor ³ Inacio Luiz Kolling   ³ Data ³ 13/06/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa para OS corretivas                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA420( cTipoOS, cCodBem )

	Local aNGBeginPrm := {}
	Local aRotinaNew  := {}
	Local nX
	Local aServRef
	Local aServCon  

	If ( !FindFunction( 'MNTAmIIn' ) .Or. MNTAmIIn( 19, 35, 95 ) ) .And. fVersion()

		aNGBeginPrm := NGBeginPrm()

		Private cChavSTL, aBlo
		Private aSav650	:= Array(20)

		// Usado na funcao NGGERASA.. Nao mexer
		Private cNumSA          := Space(Len(SCP->CP_NUM))
		Private lGFrota			:= MNTA420FR()
		Private aRotina			:= MenuDef(lGFrota)
		Private aInd420			:= {}
		Private bFiltraBrw		:= {|| Nil}
		Private lFILBRW			:= .T.
		Private MV_PAR02		:= Space(6),MV_PAR05 := Space(6),MV_PAR01 := Space(6),cARQF3,cCampoF3
		Private cPar01			:= Space(6), cPar02 := Space(6), cPar05 := Space(3)
		Private cUsaIntPc		:= AllTrim(GetMV("MV_NGMNTPC"))
		Private cUsaIntCm		:= AllTrim(GetMV("MV_NGMNTCM"))
		Private cUsaIntEs		:= AllTrim(GetMV("MV_NGMNTES"))
		Private cCadastro		:= OemToAnsi(STR0009) //"O.S. Corretiva"
		Private aHEAINSAL		:= {}  // -> CONTEM OS CAMPOS DO GETDADOS
		Private aGETINSAL		:= {}  // -> CONTEM OS DADOS DO STL ( GRAVADOS ANTEIROMENTE)
		Private aARINALTR		:= {}  // -> CONTEM OS DADOS ALTERADOS
		Private aARIDELET		:= {}  // -> CONTEM OS DADOS DELETADOS
		Private aARINOVOS		:= {}  // -> CONTEM OS DADOS NOVOS
		Private aARTRABAL		:= {}  // -> USADA PARA TRABALHO ( AUXILIAR )
		Private faltera			:= .F.
		Private lecodbem		:= .F.
		Private flgservico		:= .T.   // O TS_SERVICO tambem e' usado no MNTA430
		Private lSITUACA		:= .T.
		Private cCUSANT, cNOCANT, cTRAANT,cNOTANT, dDTAANT, cHORANT
		Private cCUSDEP, cNOCDEP, cTRADEP,cNOTDEP, dDTADEP, cHORDEP, nCONANT, nCONDEP
		Private lTEMFACI		:= .F.
		Private aSize			:= MsAdvSize(,.F.,430), aObjects := {}

		// NAO RETIRAR A VARIAVEL lSH1     := .F.
		Private lSH1			:= .F.
		Private lWhenOs			:= .T.
		Private cSerefor		:= Alltrim(GETMV("MV_NGSEREF"))
		Private cSercons		:= Alltrim(GETMV("MV_NGSECON"))

		//Variaveis para carregar campos TJ_CODBEM e TJ_TIPOOS automaticamente
		Private cCodBem420, cTipoOS420

		// Declaração obrigatória -  usada no dicionário e funções que são chamadas
		Private cBemRet 		:= Space( TamSX3("TJ_CODBEM")[1] )

		Private nOpcai		:= 0
		Private nQTDHEA		:= 0
		Private nTIPHEA		:= 0
		Private aTrocaF3	:= {}
		Private aNGFIELD	:= {}
		Private lRETORNO	:= .F.
		Private TI_PLANO	:= "000000"
		Private cPrograma	:= "MNTA420"
		Private cParCani	:= SuperGetMv("MV_NGSTACA",.F.," ")

		//-----------------------------------------------------------------
		// INICIO - Variáveis usadas na geração de solicitação de compras
		//-----------------------------------------------------------------
		Private aDataOPC1	:= {}, aDataOPC7 := {}, aOPC1 := {}, aOPC7 := {}
		Private vVetP		:= {}, aNumSC1 := {}
		Private cNumSC1		:= Space(Len(SC1->C1_NUM))
		Private cNuISC1		:= 0
		Private lconsterc	:= .T.
		Private lconsNPT	:= .T.
		Private lUsouF7		:= .F.
		//-----------------------------------------------------------------
		// FIM
		//-----------------------------------------------------------------

		//Verifica se Gera Solicit. ao Armazem em vez de Solic. Compras
		Private lGeraSA		:= NG420CHKSA()

		Private lChkPR		:= GetNewPar("MV_NGCOQPR","N") == "S" //checa qtd pecas de reposicao
		Private aCores		:= {}

		//Variavel para guardar a data da emissao da S.A. Variavel usada no MNTUTIL_OS
		Private aDtSa 			:= {}
		cParCani := IIf(cParCani = Nil, '  ', SubStr(cParCani, 1, 2))
		aServRef := StrTokArr( cSerefor, ';' )
		aServCon := StrTokArr( cSercons, ';' ) 

		cConSit   := 'LP'
		cALMCOMP  := Space(2)
		cALMEMPE  := Space(2)
		cCadastro := OemToAnsi(STR0010) //" O.S. Corretiva"

		Aadd(aObjects,{050,050,.T.,.T.})
		Aadd(aObjects,{100,100,.T.,.T.})

		aInfo	:= {aSize[1], aSize[2], aSize[3], aSize[4], 0, 0}
		aPosObj	:= MsObjSize(aInfo, aObjects,.T.)

		If ExistBlock("MNTA420C")
			aRotinaNew := ExecBlock("MNTA420C",.F.,.F.,aRotina)
			If ( ValType(aRotinaNew) == "A" )
				aRotina := aClone(aRotinaNew)
			EndIf
		EndIf

		lTEMFACI	:= NGINTESTORG()
		aPos1		:= {15, 1, 95, 315}
		lCORRET		:= .T.
		aBLO		:= { {},{},{},{},{} }
		nQtdComp	:= 0.00
		lProblema	:= .F.

		dbSelectArea("STJ")
		dbSetOrder(1)
		If ExistBlock("MNTA420A")
			ExecBlock("MNTA420A", .F., .F.)
		EndIf

		cFilMbrSTJ := "TJ_PLANO = '000000' And TJ_TERMINO = 'N' And TJ_ORDEPAI = '" + Space( TamSX3("TJ_ORDEPAI")[1] ) + "' "
		cFilMbrSTJ += "And (TJ_SITUACA = 'L' OR TJ_SITUACA = 'P') "
		
		//Preenche a variavel cSerefor com todos os serviços do parametro MV_NGSEREF
		If !Empty(cSerefor)

			For nX := 1 To Len(aServRef)
				If nX == 1
					cSerefor := "'"+aServRef[nX]+"'"
				Else
					cSerefor += ",'"+aServRef[nX]+"'"
				EndIf
			Next nX

		Else

			//Garante que a aspas vão certas para a Query
			cSerefor := "' '"

		EndIf

		//Preenche a variavel cSercons com todos os serviços do parametro MV_NGSECON
		If !Empty(cSercons)

			For nX := 1 To Len(aServCon)
				If nX == 1
					cSercons := "'"+aServCon[nX]+"'"
				Else
					cSercons += ",'"+aServCon[nX]+"'"
				EndIf
			Next nX

		Else

			//Garante que a aspas vão certas para a Query
			cSercons := "' '"

		EndIf

		// Não lista O.S com o serviço de Reforma de Pneus (Frota)
		If !Empty(cSerefor)
			cFilMbrSTJ += " AND TJ_SERVICO NOT IN (" + cSeRefor  +") "
		EndIf

		// Não lista O.S com o serviço de Conserto de Pneus (Frota)
		If !Empty(cSercons)
			cFilMbrSTJ += " AND TJ_SERVICO NOT IN (" + cSerCons + ") "
		EndIf

		If ValType(cTipoOS) == "C" .And. ValType(cCodBem) == "C"
			cTipoOS420 := cTipoOS
			cCodBem420 := cCodBem
			cFilMbrSTJ += " And TJ_CODBEM = '" + cCodBem + "' And TJ_TIPOOS = '" + cTipoOS + "'"

			//-----------------------------------------------
			// Não apresentar a tela para informar a filial
			//-----------------------------------------------
			SetBrwCHGAll(.F.)
		EndIf

		If ExistBlock("MNTA420L")
			cFilMbrSTJ += ExecBlock("MNTA420L",.F.,.F.)
		EndIf

		//--------------------------------------------------
		//  Ponto de Entrada - Define as Cores do MBrowse
		//--------------------------------------------------
		If ExistBlock("MNTA420M")
			ExecBlock("MNTA420M",.F.,.F.)
		EndIf

		MBrowse(6,1,22,75,"STJ",,,,,,aCores,,,,,,,,cFilMbrSTJ)

		NGRETURNPRM( aNGBeginPrm )

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NG420INC
Rotina de Inclusao de OS bem, servico corretivas

@param cAlias, 	Caracter, Alias da tabela utilizada.
@param nReg, 	Numérico, Recno do registro posicionado.
@param nOpcx, 	Numérico, Numero da opção selecionada.
@param cCodBem, Caracter, Código do bem.
@param cCodFil, Caracter, Código da filial.
@param cTipoOS, Caracter, Tipo da OS.
@param lRetCod, Lógico,   Determina o retorno da função, podendo ser lógico ou caracter.

@author	Inacio Luiz Kolling
@since	13/06/97

@return If(!lRetCod, lGrava, cCodOS), Lógico ou Caracter, Retorna se gravou OS ou o Código da OS.
/*/
//---------------------------------------------------------------------
Function NG420INC( cAlias, nReg, nOpcx, cCodBem, cCodFil, cTipoOS, lRetCod )

	//--------------------------------------------------
	//  Guarda conteudo e declara variaveis padroes
	//--------------------------------------------------
	Local aNGBEGINPRM 	:= If(!IsInCallStack("MNTA420"),NGBEGINPRM(,"MNTA420",/*aChkAlias*/,.F.),{})

	Local cALIASTJ		:= "STJ"
	Local nORDSTJ		:= STJ->(IndexOrd())
	Local nREGSTJ		:= STJ->(Recno())
	Local lPRI420		:= .T.
	Local l420Grava		:= .T.
	Local cCodOS		:= Space(Len(STJ->TJ_ORDEM))
	Local lRetAlte		:= .T.
	Local lMsgExec      := .F.
	Local aAreaSTJ		:= {}
	Local lFuncCont2    := FindFunction("MNTCont2") //FindFunction remover na release GetRPORelease() >= '12.1.027'
	Local lUsePrAlt     := AllTrim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And. cGerSA == 'N'
	Local nX            := 0
	Local nY	        := 0
	Local nInd1         := 0
	Local nInd2         := 0
	Local nPosRec       := 0
	Local nPosGet       := 0
	Local nTamTAF       := FWTamSX3( 'TAF_CODNIV' )[1]
	Local lAlterou      := .F.

	// DSERLOCA-3173 - SIGALOC - 09/05/2024 - Frank Fuga
	Local lLOCM011 	:= FindFunction("LOCA011")

	Default lRetCod		:= .F.//Indica se retorna codigo da OS

	Private aRBackRM    := {}
	Private nINDSTQ		:= 1, cINSPREV := "P"
	Private cARQUISAI	:= "STJ"
	Private lTEMFACI	:= .F.
	Private lSaveSTQ    := .F.
	Private lSaveTTC    := .F.
	Private lSaveSTN    := .F.
	Private nTIPHEA		:= 0
	Private cUsaIntEs	:= AllTrim(GetMV("MV_NGMNTES"))
	Private nCOPIAOS	:= GetMV("MV_NGCOPOS")
	Private nCODINS		:= 0, nUSACAL := 0 , nDATAIN := 0, nHORAIN := 0
	Private dINI, hINI
	Private vCAMPOS		:= Space(16)
	Private aSize		:= MsAdvSize(,.F.,430), aObjects := {}
	Private aNgTabSCP	:= {} //ATENCAO - Não excluir esta variavel - A variavel está sendo utilizada para armazenar as S.A. que serão gravadas na chamada de um ponto de entrada.
	Private cFilOld		:= cFilAnt
	Private cFILBEM		:= If(Type("cFILBEM")<>"C",xFilial("ST9"),cFILBEM)
	Private lWhenTJBem	:= .T.
	Private lUSATARG	:= If(FindFunction("NGUSATARPAD"),NGUSATARPAD(),.F.)
	Private cPxSeq		:= Space(3),cPxQSeq := cPxSeq
	Private nQTETA		:= 0,nQTARE := 0
	Private nOpcai		:= 0
	Private lObserv 	:= .T. // Indica se deve ou nao apresentar a tela de Observacoes ao fim do processo
	Private aButton		:= IIf(Type("aNgButton") == "A", aClone(aNgButton), {})

	Private nPosNum		:= 0
	Private nPosItem    := 0
	Private aNewSC      := {}

	/*-----------------------------------+
	| Variáveis utilizadas em dicionário |
	+-----------------------------------*/
	Private oGetOcorr
	Private oGetEtapa

	Default cTipoOS     := ''

	//--------------------------------------------------
	// Carrega array de botões para Ações relacionadas
	// baseados nas tabelas de clique da direita
	//--------------------------------------------------
	If Len( aButton ) == 0
		NGClickBar( @aButton, NGRIGHTCLICK("MNTA420") )
	EndIf

	faltera := (nOpcx == 4)

	MV_PAR01   := Space(6)
	MV_PAR02   := Space(6)
	MV_PAR05   := Space(6)

	vVetMvP    := NGSALVAMVPA()

	If Type("lCorret") <> "L"
		lCorret := .T.
	EndIf

	lTEMFACI := NGINTESTORG()

	Aadd(aObjects,{050,050,.T.,.T.})
	Aadd(aObjects,{100,100,.T.,.T.})

	aInfo := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
	aPosObj := MsObjSize(aInfo, aObjects,.T.)

	If nOpcx == 3
		SetKey(VK_F11,{||NGTAFMNT("M->TJ_CODBEM",.T.)})
		SetKey(VK_F10,{||If(Type("ODLG") == 'U',MNTA420ESB(),.T.)})

		If AllTrim(GetNewPar("MV_NGMNTAT","N")) $ "2/3"
			SetKey(VK_F7 ,{||MNT420F7()})
		EndIf
	EndIf

	If FindFunction("NGSEQETA")
		nINDSTQ := NGSEQETA("STQ",nINDSTQ)
	EndIf

	aBLO := {{},{},{},{},{}}

	If nOpcx == 4
		If STJ->TJ_TIPOOS = "B"
			If !NGBEMATIV(STJ->TJ_CODBEM)
				Return If(!lRetCod, .F., "")
			EndIf
		EndIf
	EndIf

	INCLUI   := (nOpcx == 3)
	lSITUACA := (nOpcx == 3)

	If nOpcx == 5

		If GetNewPar("MV_NGMNTCC","N") == "S"
			aAreaSTJ := GetArea()
			dbSelectArea("TV9")
			dbSetOrder(1)
			If dbSeek(xFilial("TV9")+STJ->TJ_CODBEM+STJ->TJ_ORDEM)
				MsgStop(STR0198,STR0018)
				Return .F.
			EndIf
			RestArea(aAreaSTJ)
		EndIf

		dbSelectArea("STL")
		dbSetOrder(03)
		dbSeek(xFilial('STL')+STJ->TJ_ORDEM+STJ->TJ_PLANO+"1  ",.T.)
		While !EoF() .and. stl->tl_filial == xFilial('STL') .And.;
				stl->tl_ordem == stj->tj_ordem .And. stl->tl_plano == stj->tj_plano

			If Val(stl->tl_seqrela) <> 0
				Help(" ",1,"HAREPORT")
				dbSelectArea("STJ")
				Return If(!lRetCod, .F., "")
			EndIf
			dbSkip()
		End While
	EndIf

	aVARNAO	:= {}
	TIPOACOM	:= .F.
	TIPOACOM2	:= .F.
	cBEMCONT	:= Space(Len(STJ->TJ_CODBEM))

	bNGGRAVA	:= {|| NG420CHK(nOpcx,cCodFil) }
	aCHOICE		:= {"TJ_ORDEM"	,"TJ_TIPOOS" ,"TJ_CODBEM" ,"TJ_NOMBEM" ,"TJ_SERVICO",;
					"TJ_NOMSERV","TJ_DTORIGI","TJ_POSCONT","TJ_HORACO1","TJ_OBSERVA",;
					"TJ_SITUACA","TJ_POSCON2","TJ_HORACO2","TJ_TERCEIR","TJ_DTPRINI","TJ_HOPRINI"}

	If cTipoOS == 'L' .And.	Empty( NgSeek( 'TAF', 'X2' + SubStr( cCodBem, 1, nTamTAF ), 7, 'TAF_CCUSTO' ) )

		aAdd( aChoice, 'TJ_CCUSTO' )
		aAdd( aChoice, 'TJ_NOMCUST' )

	EndIf

	/*-----------------------------+
	| Integração SIGAGFR x SIGALOC |
	+-----------------------------*/
	If SuperGetMV( 'MV_NG1LOC', .F., .F. )

		aAdd( aChoice, 'TJ_AS' )
		aAdd( aChoice, 'TJ_PROJETO' )
		aAdd( aChoice, 'TJ_OBRA' )

	EndIf

	If ExistBlock("MNTA4206")
		ExecBlock("MNTA4206",.F.,.F.)
	EndIf

	Private aCHKDEL	:= {}
	Private aTELA[0][0],aGETS[0],aHeader[0],Continua,nUsado:=0
	Private oMenu

	bCampo	:= {|nCPO| Field(nCPO) }
	cSP		:= " "

	dbSelectArea("STL")
	RegtoMemory("STL",(nOPCX == 3))

	dbSelectArea("STQ")
	dbSetOrder(nINDSTQ)
	RegtoMemory("STQ",(nOPCX == 3))

	dbSelectArea("STJ")
	RegtoMemory("STJ",(nOPCX == 3))

	//Inicializa campo Observacao
	If !NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
		M->TJ_OBSERVA := Space(50)
	EndIf
	If nOpcx <> 3
		If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
			M->TJ_OBSERVA := NGMEMOSYP(STJ->TJ_MMSYP)
		Else
			M->TJ_OBSERVA := STJ->TJ_OBSERVA
		EndIf
	EndIf

	If IsInCallStack("MNTA291")
		M->TJ_OBSERVA := NGMEMOSYP(TQB->TQB_CODMSS)
	EndIf

	//Variaveis para carregar TJ_CODBEM e TJ_TIPOOS automaticamente
	If Type("cCodBem420") == "C" .And. Type("cTipoOS420") == "C"
		cCodBem := cCodBem420
		cTipoOS := cTipoOS420
	EndIf

	If ValType(cCodBem) == "C"  .And. INCLUI .And. !IsInCallStack("MNTA985")
		M->TJ_CODBEM := cCodBem
		M->TJ_TIPOOS := If(Empty(cTipoOS),"B",cTipoOS)

		If !(&(X3Valid("TJ_CODBEM")) .And. VldUser("TJ_CODBEM"))
			Return If(!lRetCod, .F., "")
		EndIf

		lWhenTJBem := .F.
	EndIf

	If IsInCallStack("MNTA985")
		Set Key VK_F8 To

		NGDBAREAORDE("ST9",01)
		dbSeek(cCodFil+cCodBem)
		M->TJ_CODBEM := ST9->T9_CODBEM
		M->TJ_DTORIGI := If(IsInCallStack("MNT985ENT"),M->TTI_DTENT,dDatabase)

		TIPOACOM := If(ST9->T9_TEMCONT = "S" .And. M->TJ_DTORIGI <= dDataBase,.T.,.F.)

		If lFuncCont2
			TIPOACOM2 := MNTCont2(cCodFil, cCodBem) .And. M->TJ_DTORIGI <= dDataBase
		Else
			NGDBAREAORDE("TPE",01)
			TIPOACOM2 := If(dbSeek(NGTROCAFILI("TPE",cCodFil)+cCodBem) .And. M->TJ_DTORIGI <= dDataBase ,.T.,.F.)
		EndIf

		M->TJ_TIPOOS := "B"

		If TIPOACOM .And. IsInCallStack("MNT985ENT")
			M->TJ_HORACO1 := M->TTI_HRENT
			M->TJ_POSCONT := If(!FindFunction("NGBlCont") .Or. NGBlCont( cCodBem ), M->TTI_POS1EN, NGTpCont(M->TJ_CODBEM, M->TJ_DTORIGI, M->TJ_HORACO1, M->TTI_POS1EN))//M->TTI_POS1EN
		EndIf

		If TIPOACOM2 .And. IsInCallStack("MNT985ENT")
			M->TJ_HORACO2 := M->TTI_HRENT
			M->TJ_POSCON2 := M->TTI_POS2EN
		EndIf

		cFILBEM := cCodFil
	EndIf

	If IsInCallStack("MNTA902") .And. M->TJ_TIPOOS == "B"
		dbSelectArea("ST9")
		dbSetOrder(1)
		If dbSeek( xFilial("ST9") + cBemAL )
			M->TJ_NOMBEM := ST9->T9_NOME // Carrega descrição do bem
			TIPOACOM     := IIf(ST9->T9_TEMCONT = "S" .And. M->TJ_DTORIGI <= dDataBase,.T.,.F.)
			If lFuncCont2
				TIPOACOM2 := MNTCont2(xFilial("TPE"), cBemAL) .And. M->TJ_DTORIGI <= dDataBase
			Else
				NGDBAREAORDE("TPE",01)
				TIPOACOM2 := If(dbSeek(xFilial("TPE")+cBemAL) .And. M->TJ_DTORIGI <= dDataBase,.T.,.F.)
			EndIf
		EndIf
	EndIf

	//Ponto de Entrada para carregar variaveis em tela
	If ExistBlock("MNTA420J")
		ExecBlock("MNTA420J",.F.,.F.,{nOPCX,cCodbem,cCodFil})
	EndIf

	If nOPCX == 3

		dbSelectArea("STJ")
		dbSetOrder(1)

		//Tratamento para evitar duplicação de número de O.S. em base
		If dbSeek(xFilial("STJ") + M->TJ_ORDEM )

			aArea := GetArea()

			dbSelectArea( "STJ" )
			dbSetOrder( 01 )
			While dbSeek( xFilial( "STJ" ) + M->TJ_ORDEM)
				ConfirmSX8()
				M->TJ_ORDEM := GetSXENum( "STJ","TJ_ORDEM" )
			End While

			RestArea( aArea )

		EndIf

	EndIf

	M->TJ_PLANO	  := "000000"
	M->TJ_SEQRELA := '000'

	M->TL_SEQRELA := "0  "
	M->TL_TAREFA  := "0     "

	nSEQUENC := "0  "
	lRETORNO := .F.
	aHEAINS	 := {}
	aHEAETA	 := {}
	aHEASIN	 := {}
	aHeaOcr  := {}
	aGETINS	 := {}
	aGETETA	 := {}
	aGETSIN	 := {}
	aGetOcr  := {}
	aDATINS	 := {}

	NG420ININS(nOPCX)
	NG420INETA(nOPCX)

	If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0

		fOcorrGetD( nOPCX )

	EndIf

	If NGCADICBASE('TTC_CODBEM','A','TTC',.F.)
		NG420INSIN(nOPCX)
	EndIf

	// USADO NA ALTERACAO
	aHEAINSAL := ACLONE(aHEAINS)
	aGETINSAL := ACLONE(aGETINS)

	dbSelectArea( "STJ" )

	aPos1	:= {15,1,120,315 }
	nOpca	:= 0

	dINI	:= M->TJ_DTORIGI
	hINI	:= If(!Empty(M->TJ_HOMPINI),M->TJ_HOMPINI,SubStr( Time(),1,5))

	If ExistBlock("MNTA420D")
		If !ExecBlock("MNTA420D",.F.,.F.)
			Return If(!lRetCod, .F., "")
		EndIf
	EndIf

	Define MsDialog oDlg420 Title Ccadastro From aSize[7],00 To aSize[6],aSize[5] PIXEL

		//Adiciona na posição 4 do aPos1 a area util para utilizacao em tela (largura) para correta adequacao na ver11
		//Este tratamento nao foi feito na criacao do array pois esta alteracao serve apenas quando os botoes nao sao criados
		//no lado direito.
		aPos1[4] := aPosObj[2,4]

		//Painel para Enchoice
		oPanel1OS := TPanel():New(01,01,,oDlg420,,,,,,0,aPosObj[2,1]+125,.F.,.F.)
			oPanel1OS:Align := CONTROL_ALIGN_ALLCLIENT
			oEnchoice := Msmget():New(cALIAS, nReg, nopcx,,,,aCHOICE,aPOS1,,3,,,,oPanel1OS)

		//Painel para botoes
		oPanel2 := TPanel():New(01,01,,oDlg420,,,,,,1,20,.F.,.F.)
			oPanel2:Align := CONTROL_ALIGN_BOTTOM

		// Ponto de Entrada utilizado para retirar todos os botoes na tela, podendo adicionar botoes personalizados.
		If ExistBlock("MNTA42BT")
			ExecBlock("MNTA42BT",.F.,.F.)
		Else
	
			@ 005,005 Button STR0012 Size 38,12 Pixel Of oPanel2 Action NG420INSU() //"&Insumos"
			@ 005,055 Button STR0013 Size 38,12 Pixel Of oPanel2 Action NG420ETAPA() //"&Etapas"
			@ 005,105 Button "&Sintomas" Size 38,12 Pixel Of oPanel2 Action MNT420SINT()
	
			If ST8->( FieldPos( 'T8_TAREFA' ) ) > 0

				@ 005,155 Button STR0211 Size 38,12 Pixel Of oPanel2 Action fCadOcorre() // Ocorrências

			EndIf

		EndIf

	Activate MsDialog oDlg420 On Init EnchoiceBar(oDlg420,{||nOpca:=1, IIf(!obrigatorio(aGets,aTela),nOpca := 0,;
		IIf(!Eval(bNGGRAVA),nOpca := 0,oDlg420:End()))},{||oDlg420:End()},AlignObject(oDlg420,{oEnchoice:oBox},1), aButton)

	If nOPCA != 1
		Set Key VK_F10 To
		Set Key VK_F11 To
		Set Key VK_F8 To
		Set Key VK_F7 To

		dbSelectArea(cALIASTJ)
		dbSetOrder(nORDSTJ)
		dbGoTo(nREGSTJ)

		If __lSX8
			RollbackSx8()
		EndIf

		Return If(!lRetCod, .F., "")
	EndIf

	// Caso seja alteração valida se houve alteração nos Insumos
	If nOpcx == 4
		
		If Len( aGetInSal ) == Len( aGetIns )

			nPosRec := GDFieldPos( 'TL_REC_WT', aHeaIns )

			For nInd1 := 1 to Len( aGetInSal )

				If ( nPosGet := aScan( aGetIns, { |x| x[nPosRec] == aGetInSal[nInd1,nPosRec] } ) ) > 0

					For nInd2 := 1 To Len( aGetInSal[nPosGet] )

						If aGetInSal[nInd1,nInd2] != aGetIns[nPosGet,nInd2]
							
							lAlterou := .T.
							
							Exit
						
						EndIf

					Next nInd2

				EndIf

			Next nInd1

		Else

			lAlterou := .T.

		EndIf

	EndIf

	// Caso não seja inclusão e não tenha alteração de Insumo segue com o valor que já possui
	If nOpcx == 3 .Or. lAlterou
		dINI := M->TJ_DTORIGI
		dFIM := M->TJ_DTORIGI
	Else	
		dINI := M->TJ_DTMPINI
		dFIM := M->TJ_DTMPFIM
	EndIf

	hFIM := If(!Empty(M->TJ_HOMPINI),M->TJ_HOMPINI,SubStr( Time(),1,5))
	dMAX := M->TJ_DTORIGI
	hMAX := If(!Empty(M->TJ_HOMPINI),M->TJ_HOMPINI,SubStr( Time(),1,5))
	dMIN := M->TJ_DTORIGI
	hMIN := If(!Empty(M->TJ_HOMPINI),M->TJ_HOMPINI,SubStr( Time(),1,5))

	lnOpcae := .F.

	If lUsePrAlt .And. cUsaIntEs == 'S' .And. M->TJ_SITUACA == 'L'
		aGETINS  := NGALTPROD( aGETINS, aHeaIns, M->TJ_CODBEM, 'TL', 'MNTA420', , IIf( ALTERA, M->TJ_ORDEM, '' ) )
	EndIf

	Begin Transaction

	MNT420GAR(nOPCX) //funcao para verificar se o servico tem controle de garantia

	If nOPCX == 3 .or. nOPCX == 4
		NG420CALDF() //Alterado para chamar esta funcao ao inves de NG420DTFIM()
		lPRI420 := .T.
		For ny := 1 To Len(aDATINS)

			If lPRI420 .AND. !Empty(aDATINS[ny][2]) .AND. !Empty(aDATINS[ny][4])
				lPRI420 := .F.
				dMIN := aDATINS[ny][2]
				hMIN := aDATINS[ny][3]
				dMAX := aDATINS[ny][4]
				hMAX := aDATINS[ny][5]
			Else
				If !Empty(aDATINS[ny][2])
					If aDATINS[ny][2] < dMIN
						dMIN := aDATINS[ny][2]
						hMIN := aDATINS[ny][3]
					Else
						If aDATINS[ny][3] < hMIN
							hMIN := aDATINS[ny][3]
						EndIf
					EndIf
				EndIf

				If !Empty(aDATINS[ny][4])
					If aDATINS[ny][4] > dMAX
						dMAX := aDATINS[ny][4]
						hMAX := aDATINS[ny][5]
					Else
						If aDATINS[ny][5] > hMAX
							hMAX := aDATINS[ny][5]
						EndIf
					EndIf
				EndIf
			EndIf
		Next

		M->TJ_DTMPINI := dMIN
		M->TJ_HOMPINI := hMIN

		nPos1 := aScan(aCHOICE,"TJ_DTMPFIM")

		If nPos1 <= 0 .Or. Empty(M->TJ_DTMPFIM)
			M->TJ_DTMPFIM := dMAX
		EndIf

		M->TJ_HOMPFIM := hMAX

		l420Grava := .T.

		If nOPCX == 3
			
			cBEMRET := M->TJ_CODBEM

			aArea := GetArea()

			dbSelectArea( "STJ" )
			dbSetOrder( 01 )
			While dbSeek( xFilial( "STJ" ) + M->TJ_ORDEM )
				ConfirmSX8()
				M->TJ_ORDEM := GETSXENUM( "STJ","TJ_ORDEM" )
			End While

			RestArea( aArea )

			//Verifica se Gera OP
			If M->TJ_SITUACA == 'L'
				//---------------------------------------------------
				//Gera ordem de Producao para a OS
				//---------------------------------------------------
				cUsaIntPc := AllTrim(GetMV("MV_NGMNTPC"))
				If cUsaIntPc == "S"
					//Irá verificar apenas o primeiro Produto Manutenção do parâmetro
					cCODPRO := If(FindFunction("NGProdMNT"), NGProdMNT("M")[1], GetMv("MV_PRODMNT"))
					dDataIni := MNT420DTOP(M->TJ_DTORIGI)
					dDataFim := MNT420DTOP(M->TJ_DTORIGI)

					// Busca o C.C. do bem na TPN ou utiliza o C.C. da ordem de serviço quando seja do tipo localização.
					cCusto := IIf( M->TJ_TIPOOS == 'B', NGFilTPN( M->TJ_CODBEM, M->TJ_DTORIGI, SubStr( Time(), 1, 5 ), , xFilial( 'ST9' ) )[2],;
						M->TJ_CCUSTO )

					If !GERAOPNEW(cCODPRO,1,M->TJ_ORDEM,dDataIni,dDataFim,,,cCusto,"PLANO 000000")
						l420Grava :=  .F.
					EndIf
				EndIf
			EndIf

			If l420Grava
				//Grava a O.S.
				RecLock("STJ",.T.)
				For ny := 1 To Fcount()
					nx := "m->" + FieldName(ny)

					If "_FILIAL"$Upper(nx)
						FieldPut(ny, xFilial('STJ'))
					Else
						CC := &NX.
						FieldPut(ny, &nx.)
					EndIf
				Next ny
				STJ->( MsUnlock() )

				cCodOS    := STJ->TJ_ORDEM
			
				l420Grava := NG420GRAVA( nOpcX ) //Realiza gravação dos insumos previstos.

				MNT420FIT( .F. ) //Destrava a rotina de gravação de insumos em inclusão.
			
			EndIf

		ElseIf nOPCX == 4
			dbSelectArea("STJ")
			dbGoto(nREGSTJ)
			cCodOS := STJ->TJ_ORDEM
			// VERIFICA SE CONFIRMOU A ALTERAÇÃO NOS INSUMOS
			If Len(aGETINS) > 0// nOpcai == 1
				Processa({ |lEnd| lRetAlte := NG420ALTE(.T.) },STR0041)//"Aguarde... verificando alteracoes.."
			EndIf
		EndIf

		If l420Grava .And. lRetAlte
			/* ATENCAO
				Esta alteracao foi feita para corrigir um problema pontual com a Geracao de Solicitacao de Compras (funcao 'NGINTCOMPEST()'),
			onde o MNTA420, diferente de outras rotinas (como o MNTA410), gera primeiro a solicitacao, para só depois gravar a O.S.
			Se for alterar, tem que ser avaliado um jeito de mudar a logica de gravacao para ser semelhante a do MNTA410 (O.S. antes da Solicitacao)
			O Problema é a alteracao 'NG420ALTE()' que utiliza o estado anterior da STJ.
			Obs.: Isto nao foi avaliado nesta alteracao, porque o cliente estava parado na producao esperando esta atualizacao.
			*/
			//Altera a O.S.

			If nOPCX <> 3
				RecLock("STJ",.F.)
				For ny := 1 To Fcount()
					nx := "m->" + FieldName(ny)

					If "_FILIAL"$Upper(nx)
						FieldPut(ny, xFilial('STJ'))
					Else
						CC := &NX.
						FieldPut(ny, &nx.)
					EndIf
				Next ny
				MSUNLOCK("STJ")
			EndIf

			If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
				MsMM(M->TJ_MMSYP,80,,M->TJ_OBSERVA,1,,,"STJ","TJ_MMSYP")
			EndIf

			//Grava o status da ordem de servico se o servico for contralado por follow-up
			If nOPCX == 3
				dbSelectArea("ST4")
				dbSetOrder(01)
				If dbSeek(xFilial("ST4")+STJ->TJ_SERVICO)
					If ST4->T4_FOLLOWU == "S" .And. STJ->TJ_SITUACA == "P" .And. STJ->TJ_TERMINO == "N"
						dbSelectArea("TQW")
						dbSetOrder(03)
						If dbSeek(xFILIAL("TQW")+"6 ")
							dbSelectArea("STJ")
							RecLock("STJ",.F.)
							STJ->TJ_STFOLUP := TQW->TQW_STATUS
							MsUnlock("STJ")
						EndIf
					EndIf

					//Gera nao-conformidade
					If Val(STJ->TJ_PLANO) == 0 .And. FindFunction("NGGERAFNC")
						NGGERAFNC(STJ->TJ_ORDEM,STJ->TJ_CODBEM,STJ->TJ_SERVICO,STJ->TJ_DTORIGI)
					EndIf
				EndIf
			EndIf

			//---------------------------------------------------
			lSTJAchou  := A420STJBUS(M->TJ_CODBEM)

			dbSelectArea("ST9")
			dbSetOrder(1)

			If dbSeek(cFILBEM+M->TJ_CODBEM)
				RecLock("ST9",.F.)
				If Empty(ST9->T9_TERCEIR)
					ST9->T9_TERCEIR := "1"
				EndIf

				If M->TJ_TERCEIR = "1" .And. lSTJAchou = .F.
					ST9->T9_TERCEIR := M->TJ_TERCEIR
				EndIf

				If M->TJ_TERCEIR = "2" .Or. lSTJAchou = .T.
					ST9->T9_TERCEIR := "2"
				EndIf

				MsUnlock("ST9")
			EndIf
			//---------------------------------------------------

			If lSaveSTQ

				Processa( { |lEnd| NG420ATETA() }, STR0033 ) // Aguarde ..Gravando as Etapas..

			EndIf

			If lSaveTTC
				Processa({ |lEnd| MNT420ATSI() },STR0123) //"Aguarde ..Gravando os Sintomas.."
			EndIf

			If lSaveSTN

				Processa( { |lEnd| fCommitSTN() }, STR0212 ) // Aguarde.. Gravando as Ocorrências..

			EndIf

			EvalTrigger()       // Processa Gatilhos

			If ExistBlock("MNTA4204")
				ExecBlock("MNTA4204",.F.,.F.)
			EndIf

			If ExistBlock("NgAddEtapa")
				ExecBlock("NgAddEtapa",.F.,.F.)
			EndIf

			dbSelectArea("STJ")

			If ExistBlock("NGETAPNEX")
				ExecBlock("NGETAPNEX",.F.,.F.)
			EndIf

			// DSERLOCA-3173 - SIGALOC - 09/05/2024 - Frank Fuga
			If SuperGetMV( 'MV_NG1LOC', .F., .F. ) .and. lLOCM011
				LOCM011(nOpcx, STJ->TJ_ORDEM)
			EndIf
		EndIf

	ElseIf nOPCX == 5 // EXCLUSAO

		dbSelectArea("STJ")
		dbGoto(nREGSTJ)

		cCodOS := STJ->TJ_ORDEM

		//Set Filter to
		If !NGGERCOTAC(STJ->TJ_ORDEM)[1]
			l420Grava := .F.
		EndIf

		//Checa se existe SA com Pre-Requisicao
		If l420Grava .And. !NGCHKSAPR(STJ->TJ_ORDEM,STJ->TJ_PLANO,,.F.,.T.)
			l420Grava := .F.
		EndIf

		If l420Grava .And. ExistBlock("NGTERMOT")
			If !ExecBlock("NGTERMOT",.F.,.F.)
				l420Grava := .F.
			EndIf
		EndIf

		If l420Grava

			cSALVASTJ := STJ->TJ_CODBEM

			If NGDELETOS( STJ->TJ_ORDEM, STJ->TJ_PLANO )

				//Exclui o lancamento de contador relacionado ao bem do Contador 1
				If !EMPTY(STJ->TJ_HORACO1) .And. STJ->TJ_POSCONT > 0
					MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO1,1)
				EndIf

				//Exclui o lancamento de contador relacionado ao bem do Contador 2
				If !EMPTY(STJ->TJ_HORACO2) .And. STJ->TJ_POSCON2 > 0
					MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO2,2)
				EndIf

				If ExistBlock("MNTA420G")
					ExecBlock("MNTA420G",.F.,.F.)
				EndIf

				// chama funcao para alteracao do campo Observacao
				If lObserv
					NG400ALTMM(nREGSTJ)
				EndIf
		
				// DSERLOCA-3173 - SIGALOC - 09/05/2024 - Frank Fuga
				If SuperGetMV( 'MV_NG1LOC', .F., .F. ) .and. lLOCM011
					LOCM011(nOpcx, cCodOS)
				EndIf
			Else

				DisarmTransaction()
				lMsgExec := .T. // Utiliza somente mensagem de erro do ExecAuto.

			EndIf

		EndIf

	EndIf

	dbSelectArea(cALIASTJ)
	lREFRESH := .T.
	Set Key VK_F10 To
	Set Key VK_F11 To
	Set Key VK_F8 To
	Set Key VK_F7 To

	If l420Grava .And. nOPCX == 5 // EXCLUSAO
		lSTJAchou  := A420STJBUS(cSALVASTJ)
		dbSelectArea("ST9")
		dbSetOrder(1)
		If dbSeek(cFILBEM+M->TJ_CODBEM)
			RecLock("ST9",.F.)
			If lSTJAchou = .F.
				ST9->T9_TERCEIR := "1"
			EndIf
			ST9->(MsUnlock())
		EndIf
	EndIf

	cPxSeq	:= Space(3)
	cPxQSeq	:= Space(3)
	nQTETA	:= 0
	nQTARE	:= 0

	// Ponto de Entrada para execução antes da inclusão, alteração ou exclusão do registro.
	If l420Grava .And. ExistBlock("MNTA420X")
		l420Grava := ExecBlock("MNTA420X",.F.,.F.,{STJ->TJ_ORDEM})
	EndIf

	If l420Grava .And. lRetAlte
		//Confirma a transação
		ConfirmSX8()
		// Ponto de Entrada para execução após inclusão, alteração ou exclusão do registro.
		If ExistBlock("MNTA420P")
			ExecBlock("MNTA420P",.F.,.F.,{nOPCX})
		EndIf
	Else
		
		If l420Grava

			//Caso esteja integrado ao RM efetua a exclusão da O.S.
			If SuperGetMV( 'MV_NGINTER', .F., 'N' ) == 'M'

				For nInd1 := 1 To Len( aRBackRM )

					M->CP_FILIAL  := aRBackRM[nInd1,1]
					M->CP_NUM 	  := aRBackRM[nInd1,2]
					M->CP_SOLICIT := aRBackRM[nInd1,3]
					M->CP_EMISSAO := aRBackRM[nInd1,4]
					M->CP_ITEM 	  := aRBackRM[nInd1,5]
					M->CP_PRODUTO := aRBackRM[nInd1,6]
					M->CP_UM 	  := aRBackRM[nInd1,7]
					M->CP_QUANT   := aRBackRM[nInd1,8]
					M->CP_LOCAL   := aRBackRM[nInd1,9]
					M->CP_DATPRF  := aRBackRM[nInd1,10]
					M->CP_OP 	  := aRBackRM[nInd1,11]
					M->CP_CC 	  := aRBackRM[nInd1,12]
					M->CP_OBS 	  := aRBackRM[nInd1,13]

					NGMUReques( Nil, 'SCP', .T., 5, , { { M->CP_NUM, M->CP_ITEM } } ) 

				Next nInd1

				If nOPCX == 3

					NGMUMntOrd( Nil, 5, .T. )

				EndIf
			
			EndIf

			RollBackSX8()

			DisarmTransaction()

		EndIf

	EndIf

	End Transaction

	If l420Grava .And. lRetAlte

		If ExistBlock( 'MNTA420Z' )
			
			/*-----------------------------------------------------------------------+
			| Ponto de Entrada similar ao MNTA420P, porém sem controle de transação. |
			+-----------------------------------------------------------------------*/
			ExecBlock( 'MNTA420Z', .F., .F., { nOpcX, aGETINS, aHeaIns, aGetInsAL } )
		
		EndIf

	EndIf

	If !l420Grava .Or. !lRetAlte
		If nOPCX == 3 //Inclusão
			MsgStop(STR0201,STR0047) //"Devido à inconsistência o processo de inclusão não foi efetuado."###"Não Conformidade"
		ElseIf nOPCX == 4 .And. !lMsgExec//Alteração
			MsgStop(STR0202,STR0047) //"Devido à inconsistência o processo de alteração não foi efetuado."###"Não Conformidade"
		EndIf
		//Limpa conteúdo da variável cCodOS para manter o legado no Return
		cCodOS := ''
	EndIf

	//Reposicionada gravação para que seja possível realizar rollback em ambiente Oracle
	If l420Grava .And. STJ->TJ_SITUACA = 'L'
		dbSelectArea("STJ")
		dbSetOrder(1)
		If ExistBlock("NGIMPOS")
			If !ExecBlock("NGIMPOS",.F.,.F.,{stj->tj_plano,stj->tj_ordem,stj->tj_dtmpini})
				l420Grava := .F.
				cCodOS 	  := ''
			EndIf
		EndIf

		//Chama a funcao especifica para fazer copias da ordem de servico
		If l420Grava .And. nCOPIAOS = 2 .And. nOPCx == 3
			NGCOPIAOS(M->TJ_ORDEM,"000000")
		EndIf
	EndIf

	If l420Grava .And. FindFunction("MNTW215") .AND. (M->TJ_SITUACA == 'L' .AND. nOPCx == 3)
		MNTW215(,{M->TJ_ORDEM})
	EndIf

	dbSelectArea("STJ")
	dbSetOrder(nORDSTJ)

	//--------------------------------------------------
	//  Retorna conteudo de variaveis padroes
	//--------------------------------------------------
	NGRETURNPRM(aNGBEGINPRM)

Return If(!lRetCod, l420Grava, cCodOS)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CHKA420   ³ Autor ³ Inacio Luiz Kolling   ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consistencia dos campos obrigatorios                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function chka420(aGets,aTela)

If !obrigatorio(aGets,aTela)
	Return .F.
EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} NG420GRAVA
Grava registro

@author  Inacio Luiz Kolling
@since   XX/XX/XXXX
@version P11/P12
@param   nVOPCX, Numérico, Opção da rotina.
@return  lGrava, Lógico, Define se foi gravado registro corretamente.

/*/
//-------------------------------------------------------------------
Function NG420GRAVA( nVOPCX )

	Local lGrava := .T.
	lUsouF7   := If( Type( "lUsouF7" ) <> "U", lUsouF7, .F. )

	cLOCAL     := Space(Len(SB1->B1_LOCPAD))
	Private cUsaIntPc := AllTrim(GetMV("MV_NGMNTPC"))
	Private cUsaIntCm := AllTrim(GetMV("MV_NGMNTCM"))
	Private cUsaIntEs := AllTrim(GetMV("MV_NGMNTES"))
	Private lGerouSC1 := .F.

	If lUsouF7
		CARREGIMBO()
	EndIf

	dbSelectArea("ST9")
	dbSetOrder(1)
	dbSeek(xFilial("ST9")+M->TJ_CODBEM)

	aBLO := { {},{},{},{},{}}

	nTAREFA := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_TAREFA" })
	nPOSINS := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	nPOSCOD := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	nPOSQTD := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_QUANTID"})
	nPOSREC := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_QUANREC"})
	nUNIDAD := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_UNIDADE"})
	nUSACAL := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_USACALE" })
	nDATAIN := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })
	nHORAIN := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_HOINICI" })
	ndDTFIM := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_DTFIM"})
	nhHORAF := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_HOFIM"})

	dbSelectArea('STJ')
	nRecSTJ := Recno()
	dbSetOrder(1)

	If M->TJ_SITUACA == "L"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gera ordem de Producao para a OS                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cUsaIntPc == "S"
			If ExistBlock("MNTA4201")
				// Alterado pelo Thiago
				cCODPRO := If(FindFunction("NGProdMNT"), NGProdMNT("M")[1], GetMv("MV_PRODMNT")) //Ira verificar apenas o primeiro Produto Manutencao do parametro
				cOP     := M->TJ_ORDEM + "OS001"
				cOP := Alltrim(cOP)+Space(Len(SC1->C1_OP) - Len(Alltrim(cOP)))
				GERAOP(cCODPRO, 1, cOP, M->TJ_DTORIGI, M->TJ_DTORIGI,If(FieldPos("T9_ALMOPER") > 0, ST9->T9_ALMOPER, Nil))

				//-- Grava os Campos Especificos na OP
				dbSelectArea('SC2')
				RecLock('SC2', .F.)
				SC2->C2_CC      := M->TJ_CCUSTO
				SC2->C2_EMISSAO := MNT420DTOP(M->TJ_DTMPINI)
				SC2->C2_STATUS  := 'U'
				SC2->C2_OBS     := 'PLANO 000000'
				MsUnlock('SC2')
			EndIf
		EndIf

		If !Empty( GDFieldGet( 'TL_CODIGO', 1, .F., aHeaIns, aGetIns ) )

			If GETMV("MV_NGCORPR") == "S" .and. nPOSINS > 0 .and. ;
					nPOSCOD > 0 .and. nPOSQTD > 0 .and. nPOSREC > 0

				cOP  := M->TJ_ORDEM + "OS001"
				cOP := Alltrim(cOP)+Space(Len(SC1->C1_OP) - Len(Alltrim(cOP)))
				aBLO := { {},{},{},{},{}}

				Processa({ |lEnd| MNTA420IN() },STR0034) // "Aguarde ..Preparando Para Gerar Insumos..." )

			EndIf
			
			Processa({ |lEnd| NG420ATINS() },STR0032) // "Aguarde ..Gravando os Insumos.." )

			//-------------------------------------------------------------
			// Efetua o bloqueio de Ferramentas
			//-------------------------------------------------------------
			Processa({ |lEnd| MNTA420FE() },STR0035) // "Aguarde ..Bloqueando Ferramentas..." )

			//-------------------------------------------------------------
			// Efetua o bloqueio de Mao de Obras (FUNCIONARIO)
			//-------------------------------------------------------------
			Processa({ |lEnd| MNTA420FU() },STR0036) // "Aguarde ..Bloqueando Mao-de-Obra..." )

			//-------------------------------------------------------------
			// Efetua o bloqueio de Especialistas (FUNCIONARIO)
			//-------------------------------------------------------------
			Processa({ |lEnd| MNTA420ES() },STR0037) // "Aguarde ..Bloqueando Especialidade.." )

			//-------------------------------------------------------------
			// Efetua o bloqueio de Produtos
			//-------------------------------------------------------------
			Processa({ |lEnd| lGrava := MNTA420PR(nVOpcx) },STR0038) // "Aguarde ..Bloqueando Produto e Integra‡Æo.." )

			If lGrava
				
				//-------------------------------------------------------------
				// Gera Solicitacao de compra para terceiros
				//-------------------------------------------------------------
				Processa({ |lEnd| MNTA420TE() },STR0039) // "Aguarde ..Bloqueando Terceiros.." )

			EndIf

		EndIf

	Else

		If Len(aGETINS) > 0
			Processa({ |lEnd| NG420ATINS() },STR0032) // "Aguarde ..Gravando os Insumos.." )
		EndIf

	EndIf

	/*/
		Reposicionada gravação de contadores para garantir rollback em ambiente com banco Oracle
	/*/
	If lGrava .And. M->TJ_TIPOOS = "B"

		If TIPOACOM .And. M->TJ_POSCONT > 0

			NGTRETCON( cBEMRET, M->TJ_DTORIGI, M->TJ_POSCONT, M->TJ_HORACO1, 1, , .F., , cFILBEM )

		Endif

		If TIPOACOM2 .And. M->TJ_POSCON2 > 0

			NGTRETCON( cBEMRET, M->TJ_DTORIGI, M->TJ_POSCON2, M->TJ_HORACO2, 2, , .F., , cFILBEM )

		Endif

	Endif

Return lGrava

//-------------------------------------------------------------------
/*/{Protheus.doc} MNTA420IN
Preparando tabelas dos insumos ( bloqueios e Integração )

@author  Inacio Luiz Kolling
@since   XX/XX/XXXX
@version P11/P12

/*/
//-------------------------------------------------------------------
Function MNTA420IN()

	Local pr := 0, nPOS4201 := 0
	Local dINIBLOQ,hINIBLOQ,dFIMBLOQ,hFIMBLOQ,nTAREFA
	Local vDTAHOR := {},aGRAVCALEN := {}
	Local nNumSC	 := aScan(aHeaIns, {|x| AllTrim(Upper(X[2])) == "TL_NUMSC"})
	Local nItemSc	 := aScan(aHeaIns, {|x| AllTrim(Upper(X[2])) == "TL_ITEMSC"})
	Local lForCor	 := .F.
	Local lProgr	 := Type("cPrograma") <> Nil
	Local cLocPad 	 := Padr( SuperGetMV("MV_NGLOCPA",.F.,"01"), TamSx3("NNR_CODIGO")[1] )
	Local cNGUNIDT	 := AllTrim(GetMv("MV_NGUNIDT"))
	Local cLoclz     := ''
	Local lIntRM     := AllTrim( GetNewPar("MV_NGINTER", "N") ) == "M"
	Local aNumItemSA := { 24, 25 } // Define posicionamento dos campos TL_NUMSA e TL_ITEMSA
	Local cBranchSCP := xFilial( 'SCP' )
	Local cTarefa    := PadR( '0', FwTamSX3( 'TL_TAREFA' )[1] )
	Local lAgluItem  := .T.
	Local lNumSATela := .T.
	Local nPosBlo    := 0
	Local nPosArr    := 0
	Local nPosLocali := 0
	Local nSubtrai   := 0 // Variavel utilizada apenas quando integrado com RM para posicionar corretamente no insumo
	Local nPosRcn    := aScan( aHeaIns, { |x| AllTrim( Upper( x[2] ) ) == 'TL_REC_WT'  } )
	Local lMNTA420O  := ExistBlock( 'MNTA420O' )
	Local lNGTARGE   := SuperGetMV( 'MV_NGTARGE', .F., '2' ) == '1'
	Local lNGGERSA   := SuperGetMV( 'MV_NGGERSA', .F., 'N' ) $ 'S/P'
	Local lNGMNTAS   := SuperGetMV( 'MV_NGMNTAS', .F., '2' ) == '1'
	Local nTipReg    := GDFieldPos( 'TL_TIPOREG', aHeaIns )
	Local nFornec    := GDFieldPos( 'TL_FORNEC' , aHeaIns )
	Local nForLoja   := GDFieldPos( 'TL_LOJA'   , aHeaIns )

	nLOCAL     := aScan( aHeaIns, { |x| AllTrim(Upper(X[2])) == "TL_LOCAL"})
	nTAREFA    := aScan( aHeaIns, { |x| AllTrim(Upper(X[2])) == "TL_TAREFA"})
	nOBS       := aScan( aHeaIns, { |x| AllTrim(Upper(X[2])) == "TL_OBSERVA"})
	nPosNum    := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_NUMSA' } )
	nPosItem   := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_ITEMSA' } )
	nPosLocali := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_LOCALIZ' } )

	// Verifica se os campos NumSA e ItemSA estão presentes em tela.
	If nPosNum == 0 .And. nPosItem == 0
		lNumSATela := .F.
	EndIf

	/*---------------------------------------------------------------------+
	| Verifica se os campos fornecedor e loja são apresentados na GetDados |
	+---------------------------------------------------------------------*/
	If nFornec > 0 .And. nForLoja > 0
		lForCor := .T.
	Else
		aNumItemSA := { 22, 23 }
	EndIf

	ProcRegua(Len(aGETINS))

	For pr := 1 to Len(aGETINS)

		cLOCAL := Space(Len(SB1->B1_LOCPAD))
		IncProc()

		If cGerSA == 'N' .Or. ( cGerSA == 'P' .And. aGetIns[Pr,nTipReg] == 'T' )

			/*------------------------------------------------------------------------------------------------------+
			| Para insumos que possuam S.C. verifica se este passou por alguma alteração que reflita na integração. | 
			| Caso não desconsidera o envio do insumo para a integração.                                            |
			+------------------------------------------------------------------------------------------------------*/
			If !fVldAltSC( aGetIns[Pr,nPosRcn],	aGetIns, nPosRcn, nPosQtd, nPosCod, nLocal, nNumSC, nItemSc )

				Loop

			EndIf

		EndIf

		If lNumSATela .And. !Empty( aGetIns[Pr,nPosNum] ) .And. !Empty( aGetIns[Pr,nPosItem] )
			
			/*------------------------------------------------------------------------------------------------------+
			| Para insumos que possuam S.A. verifica se este passou por alguma alteração que reflita na integração. | 
			| Caso não desconsidera o envio do insumo para a integração.                                            |
			+------------------------------------------------------------------------------------------------------*/
			If !fVldAltSA( aGetIns[Pr,nPosRcn], aGetIns, aHeaIns )

				Loop

			EndIf

			/*------------------------------------------------------------------------------------------+
			| Para insumos que possuam S.A. encerrada desconsidera o envio do insumo para a integração. |
			+------------------------------------------------------------------------------------------*/
			dbSelectArea( 'SCP' )
			dbSetOrder( 1 )
			If msSeek( FWxFilial( 'SCP' ) + aGetIns[Pr,nPosNum] + aGetIns[Pr,nPosItem] ) .And.;
				( SCP->CP_STATUS == 'E' .Or. SCP->CP_PREREQU == 'S' ) 

				Loop

			EndIf

		EndIf

		If aGETINS[pr][len(aGETINS[pr])]
			nSubtrai++
			Loop
		EndIf

		cTAREFA := IIf( nTAREFA > 0, aGETINS[pr,nTAREFA], cTAREFA )
		cCODPRO := aGETINS[pr][nPOSCOD]
		nQTDPRO := aGETINS[pr][nPOSQTD]
		nQTDBLQ := If(aGETINS[pr][nPOSINS]$"E/F", aGETINS[pr][nPOSREC],aGETINS[pr][nPOSQTD])

		If nLOCAL > 0
			cLOCAL := aGETINS[pr][nLOCAL]
		EndIf

		cLOCAL := If(Empty(cLOCAL),cLocPad,cLOCAL)

		If !Empty( nPosLocali )
			
			cLoclz := aGetIns[Pr,nPosLocali]

		EndIf

		If lMNTA420O

			aPE420O := ExecBlock( 'MNTA420O', .F., .F., { aGetIns, aHeaIns, Pr } )

			If !Empty( aPE420O )

				cCODPRO := aPE420O[1]
				cLOCAL  := aPE420O[2]

			EndIf

			FWFreeArray( aPE420O )

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta Array para Ferramentas, Funcionarios , Especia- ³
		//³listas e Produtos; contendo Codigo, quantidade e prazo³
		//³em que sera utilizado (Data e hora Inicio e Fim).     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nTIP := 0
		If     aGETINS[pr][nPOSINS] == "F" ; nTIP := 1
		ElseIf aGETINS[pr][nPOSINS] == "M" ; nTIP := 2
		ElseIf aGETINS[pr][nPOSINS] == "E" ; nTIP := 3
		ElseIf aGETINS[pr][nPOSINS] == "P" ; nTIP := 4
		ElseIf aGETINS[pr][nPOSINS] == "T" ; nTIP := 5
		EndIf

		If nTIP > 0
			
			If nTIP <> 4
				
				nQUANTINS := aGETINS[pr][nPOSQTD]

				//Se o tipo de hora for igual a 'Decimal' e o funcionário não utiliza funcionário
				If FunName() <> "MNTA420" //Ordem de Serviço Corretiva
					If cNGUNIDT == "D" .And. aGETINS[pr][nPOSINS] $ "E/F/M/T" .And. aGETINS[pr][nUSACAL] == "N"
						nVALINHOR := Int(aGETINS[pr][nPOSQTD])
						nVALINMIM := (aGETINS[pr][nPOSQTD] - Int(aGETINS[pr][nPOSQTD])) * 0.6
						nQUANTINS := nVALINHOR+nVALINMIM
					EndIf
				EndIf

				If nTIP == 2 .And. aGETINS[pr][nUSACAL] == "S"
					dINIBLOQ := aGETINS[pr][nDATAIN]
					hINIBLOQ := aGETINS[pr][nHORAIN]

					If lHasFlut //Utiliza turno flutuante

						cCODCAL := MNTCALFLU( Substr(cCODPRO,1,6),dINIBLOQ,dINIBLOQ )
						If Empty( cCodCal ) //Se o funcionário não estiver relacionado à uma equipe de manutenção
							cCODCAL := NGSEEK( "ST1",Substr( cCODPRO,1,6 ),1,"T1_TURNO" )
						EndIf
					Else
						cCODCAL := NGSEEK( "ST1",Substr( cCODPRO,1,6 ),1,"T1_TURNO" )
					EndIf

					cCODCAL := NGSEEK("ST1",Substr(cCODPRO,1,6),1,"T1_TURNO")

					nPOS4201 := Ascan(aGRAVCALEN,{|x| x[1] = cCODCAL})
					If nPOS4201 > 0
						aMATCA := aGRAVCALEN[nPOS4201][2]
					Else
						aMATCA := NGCALENDAH(cCODCAL)
						AAdd(aGRAVCALEN,{cCODCAL,aMATCA})
					EndIf

					vDTAHOR := NGDTHORFCALE(dINIBLOQ,hINIBLOQ,nQUANTINS,cCODCAL)
					dFIMBLOQ := vDTAHOR[1]
					hFIMBLOQ := vDTAHOR[2]
				Else
					If Inclui
						If lProgr
							dINIBLOQ := IIF( cPrograma == "MNTA420",dINI,aGETINS[pr][nDATAIN] ) //Data Início
							hINIBLOQ := IIF( cPrograma == "MNTA420",hINI,aGETINS[pr][nHORAIN] ) //Hora Início
						Else
							dINIBLOQ := IIF( FunName() == "MNTA420",dINI,aGETINS[pr][nDATAIN] ) //Data Início
							hINIBLOQ := IIF( FunName() == "MNTA420",hINI,aGETINS[pr][nHORAIN] ) //Hora Início
						EndIf

						vDTAHOR  := NGDTHORFIM( dINIBLOQ,hINIBLOQ,nQTDPRO )
						dFIMBLOQ := vDTAHOR[1]
						hFIMBLOQ := vDTAHOR[2]
					Else
						dINIBLOQ := IIF( FunName() == "MNTA990",aGETINS[pr][nDATAIN],dINI ) //Data Início
						hINIBLOQ := IIF( FunName() == "MNTA990",aGETINS[pr][nHORAIN],SubStr( Time(),1,5 )) //Hora Início

						vDTAHOR  := NGDTHORFIM( dINIBLOQ,hINIBLOQ,nQTDPRO )
						dFIMBLOQ := vDTAHOR[1]
						hFIMBLOQ := vDTAHOR[2]
					EndIf
				EndIf

				aAdd( aBLO[nTIP], {;
					cTAREFA                  ,; // 01 -Tarefa
					cCODPRO                  ,; // 02 - Código do Produto
					nQTDBLQ                  ,; // 03 - Quantidade
					dINIBLOQ                 ,; // 04 - Data inicio
					hINIBLOQ                 ,; // 05 - Hora inicio
					dFIMBLOQ                 ,; // 06 - Data Fim
					hFIMBLOQ                 ,; // 07 - Hora fim
					M->TJ_ORDEM              ,; // 08 - Número da O.S.
					M->TJ_PLANO              ,; // 09 - Plano
					M->TJ_CCUSTO             ,; // 10 - Centro de Custo
					aGetIns[Pr,nNumSC]       ,; // 11 - NUMERO DA SOLICITACAO DE COMPRA
					aGetIns[Pr,nItemSC]      ,; // 12 - NUMERO DO ITEM DA SOLICITACAO DE COMPRA
					0.00                     ,; // 13 - QUANTIDADE DO ESTOQUE DA OPERACAO   TL_QTDOPER
					Space(Len(SB2->B2_LOCAL)),; // 14 - CODIGO DO ALMOXARIFADO OPERACAO     TL_ALMOPERA
					0.00                     ,; // 15 - QUANTIDADE DO ESTOQUE DA MATRIZ     TL_QTDOMAT
					Space(Len(SB2->B2_LOCAL)),; // 16 - CODIGO DO ALMOXARIFADO DA MATRIZ    TL_ALMOMAT
					0.00                     ,; // 17 - QUANTIDADE DA SOLICITACAO DE COMPRA TL_QTDSC1
					cLOCAL                   ,; // 18 - CODIGO DO LOCAL GRAVADO NO STL
					aGETINS[pr][nUNIDAD]     ,; // 19 - UNIDADE DO INSUMO
					aGETINS[pr][nOBS]        ,; // 20 - OBSERVACAO DO INSUMO
					0.00                     ,; // 21 - QUANTIDADE DA SOLICITACAO DE COMPRA TL_QTDSC1
					''                       ,; // 22 - Fornecedor TL_FORNEC
					''                       ,; // 23 - Loja do fornecedor TL_LOJA
					''                       ,; // 24 - Número S.A.
					''                       ;  // 25 - Item S.A.
				} ) 

				nPosArr := Len( aBLO[nTIP] )

				/*-------------------------------------------------------------+
				| Valida a existência dos campos fornecedor e loja na GetDados |
				+-------------------------------------------------------------*/

				If lForCor

					aBLO[nTIP,nPosArr,22] := aGETINS[Pr,nFornec]  // 22 - Fornecedor TL_FORNEC
					aBLO[nTIP,nPosArr,23] := aGETINS[Pr,nForLoja] // 23 - Loja do fornecedor TL_LOJA

				EndIf

				If lNumSATela

					aBLO[nTIP,nPosArr,24]  := aGetIns[Pr,nPosNum]  // 24 - Número S.A.
					aBLO[nTIP,nPosArr,25]  := aGetIns[Pr,nPosItem] // 25 - Item S.A.

				EndIf
				
			Else
				
				If lNGTARGE .And. lNGGERSA .And. !lNGMNTAS

					// Verifica se a tarefa + código + local + localização já foi adicionado ao array aBlo
					nPosBlo := aScan( aBlo[nTIP], { |x| x[1] + x[2] + x[18] + x[26] == cTarefa + cCodPro + cLocal + cLoclz } )

				Else
					
					
					// Verifica se o código + local já foi adicionado ao array aBLO
					nPosBlo := aScan( aBLO[nTIP], { |x| x[2] + x[18] + x[26] == cCODPRO + cLOCAL + cLoclz } )

				EndIf
				
				If lIntRM

					// Caso for alteração, o código + local já foi adicionado no ablo e os campos de TL_ITEMSA e TL_NUMSA estiverem em tela
					If Altera .And. nPosBlo > 0 .And. lNumSATela

						// Verifica se o produto encontrado na posição nPosBlo possui uma S.A. e verifica se o insumo posicionado no aGetIns não possui uma S.A.
						If !Empty( aBLO[ nTIP, nPosBlo, aNumItemSA[ 1 ] ] ) .And. Empty( aGetIns[ pr, nPosNum ])

							// Verifica no RM se a S.A. existente pode sofrer alteração.
							lAgluItem := NGMUTRAREQ( 'SCP', aBLO[ nTIP, nPosBlo, aNumItemSA[ 1 ] ],;
									cBranchSCP, .F., aBLO[ nTIP, nPosBLO, aNumItemSA[ 2 ] ], aBLO[ nTIP, nPosBLO, 3 ], aBLO[ nTIP, nPosBLO, 18 ] )

						Else

							lAgluItem := .T.

						EndIf

					EndIf

				EndIf

				If nPosBlo > 0 .And. lAgluItem
					nSubtrai++
					aBLO[nTIP][nPosBlo][3] += nQTDPRO
				Else

					aAdd( aBLO[nTIP], {;
						cTAREFA                  ,; // 01 -Tarefa
						cCODPRO                  ,; // 02 - Código do Produto
						nQTDPRO                  ,; // 03 - Quantidade
						dINI                     ,; // 04 - Data inicio
						hINI                     ,; // 05 - Hora inicio
						dFIM                     ,; // 06 - Data Fim
						hFIM                     ,; // 07 - Hora fim
						M->TJ_ORDEM              ,; // 08 - Número da O.S.
						M->TJ_PLANO              ,; // 09 - Plano
						M->TJ_CCUSTO             ,; // 10 - Centro de Custo
						aGetIns[Pr,nNumSC]       ,; // 11 - NUMERO DA SOLICITACAO DE COMPRA
						aGetIns[Pr,nItemSC]      ,; // 12 - NUMERO DO ITEM DA SOLICITACAO DE COMPRA
						0.00                     ,; // 13 - QUANTIDADE DO ESTOQUE DA OPERACAO   TL_QTDOPER
						Space(Len(SB2->B2_LOCAL)),; // 14 - CODIGO DO ALMOXARIFADO OPERACAO     TL_ALMOPERA
						0.00                     ,; // 15 - QUANTIDADE DO ESTOQUE DA MATRIZ     TL_QTDOMAT
						Space(Len(SB2->B2_LOCAL)),; // 16 - CODIGO DO ALMOXARIFADO DA MATRIZ    TL_ALMOMAT
						0.00                     ,; // 17 - QUANTIDADE DA SOLICITACAO DE COMPRA TL_QTDSC1
						cLOCAL                   ,; // 18 - CODIGO DO LOCAL GRAVADO NO STL
						aGETINS[Pr,nUNIDAD]      ,; // 19 - UNIDADE DO INSUMO
						aGETINS[Pr,nOBS]         ,; // 20 - OBSERVACAO DO INSUMO
						0.00                     ,; // 21 - QUANTIDADE DA SOLICITACAO DE COMPRA TL_QTDSC1
						''                       ,; // 22 - Fornecedor TL_FORNEC
						''                       ,; // 23 - Loja do fornecedor TL_LOJA
						''                       ,; // 24 - Número S.A.
						''                       ,; // 25 - Item S.A.
						cLoclz                   ;  // 26 - Localização
					} )

					nPosArr := Len( aBLO[nTIP] )

					/*-------------------------------------------------------------+
					| Valida a existência dos campos fornecedor e loja na GetDados |
					+-------------------------------------------------------------*/

					If lForCor

						aBLO[nTIP,nPosArr,22] := aGETINS[Pr,nFornec]  // 22 - Fornecedor TL_FORNEC
						aBLO[nTIP,nPosArr,23] := aGETINS[Pr,nForLoja] // 23 - Loja do fornecedor TL_LOJA

					EndIf

					If lNumSATela

						aBLO[nTIP,nPosArr,24] := aGETINS[Pr,nPosNum]  // 24 - Número S.A.
						aBLO[nTIP,nPosArr,25] := aGETINS[Pr,nPosItem] // 25 - Item S.A.

					EndIf

				EndIf

			EndIf

		EndIf

	Next pr

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNTA420FE ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Blqueio de Ferramentas                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA420FE()

Local i := 0

ProcRegua(Len(aBLO[1]))

For i := 1 to Len(aBLO[1])
	IncProc()
	a330FER(aBLO[1][i])
Next

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNTA420FU ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Bloqueio de Funcionário                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA420FU()

	Local i     := 0
	Local aArea := GetArea()

	ProcRegua(Len(aBLO[2]))

	For i := 1 To Len(aBLO[2])
		IncProc()
		a330FUN(aBLO[2][i])
	Next i

	RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNTA420ES ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Blqueio de Especialidades                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA420ES()

	Local i     := 0
	Local aArea := GetArea()

	ProcRegua(Len(aBLO[3]))

	For i := 1 To Len(aBLO[3])
		IncProc()
		a330ESP(aBLO[3][i])
	Next i

	RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MNTA420PR
Bloqueio de Produtos e Integração

@author  Paulo Pego
@since   XX/XX/XXXX
@version P11/P12
@param   nOpM  , Numérico, Opção da rotina.
@param   cSC1Num, string, backup da SC1
@return  lGrava, Lógico  , Define se gravou arquivos corretamente.
/*/
//-------------------------------------------------------------------
Function MNTA420PR( nOpM, cSC1Num )

	Local lMNTA4208  := ExistBlock("MNTA4208")
	Local lMNTA4201  := ExistBlock("MNTA4201")
	Local lAltera    := If(nOpM = Nil,.F.,If(nOpM = 4,.T.,.F.))
	Local lGrava     := .T.
	Local lLogix     := AllTrim( GetNewPar("MV_NGINTER", "N") ) == "L"
	Local lIntRM     := AllTrim( GetNewPar("MV_NGINTER", "N") ) == "M"
	Local lNGTARGE   := SuperGetMV( 'MV_NGTARGE', .F., '2' ) == '1'
	Local lNGGERSA   := SuperGetMV( 'MV_NGGERSA', .F., 'N' ) $ 'S/P'
	Local lNGMNTAS   := SuperGetMV( 'MV_NGMNTAS', .F., '2' ) == '1'
	Local aLinhaProd := {}
	Local nPosNumSA  := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_NUMSA"})
	Local nPosItemSA := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_ITEMSA"})
	Local lFornec    := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_FORNEC"}) > 0
	Local lNumSATela := nPosNumSA > 0 .And. nPosItemSA > 0
	Local aNumItemSA := { 24, 25 } // Posição dos campos TL_NUMSA e TL_ITEMSA dentro do array aBlo

	Default cSC1Num  := ' '

	Private nPRO //Variavel utilizada pela funcao NGPRODALTER
	Private lGeraSA	:= NG420CHKSA()
	Private aSCGer		:= {}

	cNuISC1   := 0 //utilizada na S.C.

	If !lFornec
		aNumItemSA := { 22, 23 }
	EndIf

	aIAglu := {}

	ProcRegua(Len(aBLO[4]))
	nPRO := 1
	While nPRO <= Len(aBLO[4])
		IncProc()
		
		Iold		:= nPRO
		cCodPro	    := Left(aBLO[4][nPRO][2], Len(SB1->B1_COD))
		cOP			:= AllTrim(aBLO[4][nPRO][8]) + "OS001"
		cOP			:= Alltrim(cOP)+Space(Len(SC1->C1_OP) - Len(Alltrim(cOP)))
		cLOCSTL	    := aBLO[4][nPRO][18]
		cLocAux	    := aBLO[4][nPRO][18]
		cCodLoclz   := aBLO[4,nPRO,26]
		nQTDCOMP	:= aBLO[4][nPRO][3] //0.00
		lPROBLEMA	:= .F.
		cALMCOMP	:= '01'
		cALMEMPE	:= '01'
		cOPrin		:= cOP
		cTAREFA	    := aBLO[4][nPRO][1]

		If !lMNTA4208
			
			If !lMNTA4201

				If lNGTARGE .And. lNGGERSA .And. !lNGMNTAS

					nPosSC := aScan( aIAglu, { |x| x[5] + x[1] + x[2] == cTarefa + cCodPro + cLocSTL } )

				Else

					nPosSC := aScan( aIAglu, { |x| x[1] + x[2] == cCodPro + cLocSTL } )

				EndIf

				If nPosSC > 0 .And. !lIntRM

					aIAglu[nPosSC][3] += nQTDCOMP

					If lAltera
						aIAglu[nPosSC,11] += nQTDCOMP
					EndIf

					If !Empty( cCodLoclz )

						aAdd( aIAglu[nPosSC,17], { 	aBLO[4,nPRO,26],; // Endereço
													nQTDCOMP       ;  // Quantidade
											  	} )

					Else

						/*---------------------------------------------------------------+
						| Inclui TL_NUMSC e TL_ITEMSC para processo de alteração da SC1. |
						+---------------------------------------------------------------*/
						aIAglu[nPosSC,15] := aBLO[4,nPRO,11]
						aIAglu[nPosSC,16] := aBLO[4,nPRO,12]

					EndIf

				Else

					aAdd( aIAglu, { cCodPro         ,; // Cód. Produto
									cLOCSTL         ,; // Local
									nQTDCOMP        ,; // Quantidade
									cOp             ,; // O.P.
									cTAREFA         ,; // Tarefa
									STJ->TJ_CCUSTO  ,; // Centro de Custo
									aBLO[4][nPRO][4],; // Data Inicio
									"S"             ,; // Reserva
									aBLO[4,nPRO,8]  ,; // O.S.
									aBLO[4,nPRO,9]  ,; // Plano
									Nil             ,; // Quantidade Real
									Nil             ,; // Núm. S.A.
									Nil             ,; // Item S.A.
									aBLO[4,nPRO,20] ,; // Observação
									Nil             ,; // Num. S.C.
									Nil             ,; // Item S.C.
									{ }	             ; // Lista de Endereços
								} )
					
					If lAltera

						aIAglu[Len( aIAglu ),11] := nQTDCOMP

						// Caso os campos de TL_NUMSA e TL_ITEMSA estejam em tela.
						If lNumSATela

							// Adiciona TL_ITEMSA e TL_NUMSA para poder realizar o ajuste corretamente na SCP.
							aIAglu[Len( aIAglu ),12] := aBLO[4,nPRO,aNumItemSA[1]]
							aIAglu[Len( aIAglu ),13] := aBLO[4,nPRO,aNumItemSA[2]]

						EndIf

						/*---------------------------------------------------------------+
						| Inclui TL_NUMSC e TL_ITEMSC para processo de alteração da SC1. |
						+---------------------------------------------------------------*/
						aIAglu[Len( aIAglu ),15] := aBLO[4,nPRO,11]
						aIAglu[Len( aIAglu ),16] := aBLO[4,nPRO,12]


					EndIf

					If !Empty( cCodLoclz )
						
						aAdd( aIAglu[Len( aIAglu ),17], {	cCodLoclz,; // Endereço
															nQTDCOMP ;  // Quantidade
														} )
					
					EndIf

				EndIf

			Else
				dbSelectArea("ST9")
				dbSetOrder(1)
				dbSeek(xFilial("ST9")+M->TJ_CODBEM)
				If FieldPos('T9_ALMOPER') > 0
					cLOCSTL := st9->t9_almoper
				EndIf
				ExecBlock("MNTA4201",.F.,.F.)
			EndIf
		Else
			ExecBlock("MNTA4208",.F.,.F.)
		EndIf

		nPRO++

	End While

	If !ExistBlock("MNTA4208")
		If !ExistBlock("MNTA4201")
			If M->TJ_SITUACA = "L"

				If lAltera
				// RETIRA A QUANTIDADE JA SOLICITADA, ESTA NO mntutil_os
					NGRETJACOMP(cOP)
				EndIf

				If lLogix .And. Empty(aLinhaProd)
					dbSelectArea("STL")
					dbSetOrder(1)
					If dbSeek( xFilial("STL") + STJ->TJ_ORDEM + STJ->TJ_PLANO )
						While !Eof() .And. STJ->TJ_ORDEM == STL->TL_ORDEM .And. STJ->TJ_PLANO == STL->TL_PLANO
							If Alltrim(STL->TL_SEQRELA) == "0"
								aAdd(aLinhaProd, {STL->TL_CODIGO, STL->TL_ORDEM, STL->TL_QUANTID, STL->TL_CODAEN})
							EndIf

							dbSelectArea("STL")
							dbSkip()
						End
					EndIf
				EndIf

				//Ponto de Entrada AEN LOGIX
				If ExistBlock( 'MNTA420Q' )
					ExecBlock( 'MNTA420Q', .F., .F., { 'MNTA420' } )
				Else
					
					// Função localizada no mntutil_os - Utiliza o array aIAglu
					lGrava := NGINTCOMPEST( STJ->TJ_DTMPINI, STJ->TJ_DTMPFIM, 'MNTA420', ,;
						aLinhaProd, , , cSC1Num )

				EndIf

			EndIf

		EndIf

	EndIf

Return lGrava

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNTA420TE ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Blqueio de Terceiros                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA420TE()

	Local i 		:= 0
	Local cAlmox	:= Padr( SuperGetMV("MV_NGLOCPA",.F.,"01"), TamSx3("NNR_CODIGO")[1] )
	Local lMNTA4201	:= ExistBlock( 'MNTA4201' )
	Local lMNTA420O	:= ExistBlock( 'MNTA420O' )
	Local lOk       := .T.

	ProcRegua(Len(aBLO[5]))

	//Ordena registros conforme a maior quantidade solicitada
	aSort(aBLO[5],,,{|x,y| x[3] > y[3]})

	For i := 1 To Len(aBLO[5])
		
		IncProc()

		If lMNTA420O

			lOk := a340TER( aBlo[5,i], aBlo[5,i,18], aBlo[5,i,3], aBlo[5,i,19], .F., i, aBlo[5,i,2], aBlo[5,i,20] )

		Else

			If !lMNTA4201

				If M->TJ_SITUACA = "L"

					If Empty(aBLO[5][i][18])
						lOk := a340TER( aBlo[5,i], cAlmox, aBlo[5,i,3], aBlo[5,i,19], .F., i, , aBlo[5,i,20] )
					Else
						lOk := a340TER( aBlo[5,i], aBlo[5,i,18], aBlo[5,i,3], aBlo[5,i,19], .F., i, , aBlo[5,i,20] )
					EndIf

				EndIf

			Else

				// USADO PELA SUPORTE
				lOk := a340TER( aBlo[5,i], cALMEMPE, aBlo[5,i,3], aBlo[5,i,19], .T., i, , aBlo[5,i,20] )

			EndIf

		EndIf

		If !lOk
			Exit
		EndIf

	Next i

Return lOk

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CHKSER    ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consite so campo servico                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CHKSER()

	Local cSerefor		:= Alltrim(GETMV("MV_NGSEREF"))
	Local aServRef  	:= StrTokArr( cSerefor, ';' ) 
	Local cSercons		:= Alltrim(GETMV("MV_NGSECON"))
	Local aServCon 		:= StrTokArr( cSercons, ';' ) 

	If aScan(aServRef, {|x| x == AllTrim(M->TJ_SERVICO)}) > 0 .or. aScan(aServCon, {|x| x == AllTrim(M->TJ_SERVICO)}) > 0
		MsgStop(STR0181)
		Return .F.
	EndIf
	If !ST4->(DbSeek(xFilial('ST4') + m->TJ_SERVICO))
		Help(" ",1,"SERVICONAOEXIST")
		Return .F.
	EndIf
	If NGFUNCRPO("NGSERVBLOQ",.F.)  .And.  !NGSERVBLOQ(M->TJ_SERVICO)
		Return .F.
	EndIf
	If !STE->(DbSeek(xFilial('STE') + ST4->T4_TIPOMAN))
		Help(" ",1,"TIPONAOEXIST")
		Return .F.
	EndIf

	If STE->TE_CARACTE != "C"
		Help(" ",1,"SERVNAOCORRET")
		Return .F.
	EndIf

	If ExistBlock("MNTA4209")
		If !ExecBlock("MNTA4209",.F.,.F.)
			Return .F.
		EndIf
	EndIf


// Valida permissao do usuario ao preencher Servico
// de acordo com restricao de acesso na Arvore Logica
If (IsInCallStack("MNTA902") .Or. IsInCallStack("MNTA907"))
	If !NGValidTUA(Nil,{|cTipo,cGrpUsr| NGVerifTUB(cTipo,cGrpUsr,'7',M->TJ_SERVICO)})
		MsgStop(STR0132,STR0018) //"Usuário sem permissão para incluir O.S com este serviço."
		Return .F.
	EndIf
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420ININS³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NG420ININS(nOPCX)

	Local aNAO      := {}
	Local cKEY      := ''
	Local cGETWHILE := '' 
	Local nG        := 0
	Local nTarSTL   := 0

	nQTARE := 0

	cKEY := M->TJ_ORDEM + M->TJ_PLANO + M->TL_SEQRELA
	cGETWHILE := "TL_FILIAL == xFilial('STL') .and. "
	cGETWHILE += "TL_ORDEM  == M->TJ_ORDEM .and. "
	cGETWHILE += "TL_PLANO  == M->TJ_PLANO .and. "
	cGETWHILE += "TL_SEQRELA == m->TL_SEQRELA"

	aNAO := { 	"TL_DTFIM"  , "TL_HOFIM"  , "TL_ORDEM"  , "TL_PLANO"  , "TL_SEQUENC", "TL_SEQRELA", "TL_NOMSEQ" ,;
				"TL_NOMTREG", "TL_CUSTO"  , "TL_CUSTO2" , "TL_CUSTO3" , "TL_CUSTO4" , "TL_CUSTO5" , "TL_CUSENT1",;
				"TL_CUSENT2", "TL_CUSENT3", "TL_CUSENT4", "TL_CUSENT5", "TL_OCORREN", "TL_REPFIM" , "TL_NUMSEQ" ,;
				"TL_CODOBS" , 'TL_PCTHREX', "TL_CONTROL", "TL_ETAPA"  , "TL_GARANTI", "TL_NOMETAP", "TL_NOMLOCA",;
				"TL_NUMLOTE", "TL_LOTECTL", "TL_DTVALID", "TL_NUMSERI", "TL_POSCONT", "TL_POSCON2" }

	/*-----------------------------+
	| Integração SIGAGFR x SIGALOC |
	+-----------------------------*/
	If SuperGetMV( 'MV_NG1LOC', .F., .F. )

		aAdd( aNAO, 'TL_AS' )

	EndIf

	If NGCADICBASE("TL_PERMDOE","A","STL",.F.)
		Aadd(aNAO,"TL_PERMDOE")
	EndIf

	If NGCADICBASE("TL_MOEDA","A","STL",.F.)
		Aadd(aNAO,"TL_MOEDA")
	EndIf

	If !lUSATARG
		cKEY += M->TL_TAREFA
		cGETWHILE += ".and. TL_TAREFA == m->TL_TAREFA"
		Aadd(aNAO,"TL_TAREFA")
		Aadd(aNAO,"TL_NOMTAR")
	EndIf

	dbSelectArea( "STL" )
	dbSetOrder(3)

	If nOPCX == 3  //Codigo para trazer os campos virtuais em branco na inclusao
		dbGoBottom()
		dbSkip()
	EndIf

	aHEAINS := CABECGETD("STL", aNAO,2)

	//Inclui coluna de registro atraves de funcao generica
	ADHeadRec("STL",aHEAINS)

	If nOPCX == 3
		aGETINS := BLANKGETD(aHeaIns)
	Else
		aGETINS := MAKEGETD("STL", cKEY,aHeaIns, cGETWHILE)
		If Empty(aGETINS)
			aGETINS := BLANKGETD(aHeaIns)
		EndIf

	EndIf

	nSEE := aSCAN(aHEAINS,{|x| AllTrim(Upper(X[2])) == "TL_SEQTARE"})
	For NG := 1 To Len(aGETINS)
		xx := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
		M->TL_TIPOREG := If(xx > 0, aGETINS[nG][xx], " ")

		xx := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_CODIGO"})
		M->TL_CODIGO := If(xx > 0, aGETINS[nG][xx], Space(15))

		xx := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
		If xx > 0

			aGetIns[nG][xx] := VirtInsumo( M->TL_TIPOREG, M->TL_CODIGO, GDFieldGet( 'TL_LOJA', nG, .F., aHeaIns, aGetIns ) )
		
		EndIf

		If nSEE > 0
			If ng = 1
				cPxSeq := aGETINS[ng,nSEE]
			Else
				If aGETINS[ng,nSEE] > cPxSeq
					cPxSeq := aGETINS[ng,nSEE]
				EndIf
			EndIf
			nQTARE ++
		EndIf
	Next

	nQTDHEA := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
	nTIPHEA := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })

	If nQTDHEA > 0
		aHEAINS[nQTDHEA,6]  := "NAOVAZIO() .And. POSITIVO() .And. NG420QUANT(oGet:aCOLS[oGet:nAt,nTIPHEA],M->TL_QUANTID,oGet:Acols,oGet:nAt)"
	EndIf

	nUSACAL := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_USACALE" })
	nCODINS := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	nDATAIN := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })
	nHORAIN := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI" })

	If nUSACAL > 0
		aHEAINS[nUSACAL,6]  := "Pertence('SN') .And. NGCHKCALEN(oGet:aCOLS[oGet:nAt,nCODINS],6,'ST1','T1_TURNO') .And. MNT420ACHO(oGet:Acols,oGet:nAt)"
	EndIf

	If nDATAIN > 0  .And. nHORAIN > 0
		aHEAINS[nDATAIN,6] := "NAOVAZIO() .And. NGDTAINSUIN(M->TL_DTINICI) .And. NGVDTIN420()"
		aHEAINS[nHORAIN,6] := "NG420HOINI( oGet:aCols, oGet:nAt, oGet:aHeader )"
	EndIf

	If nTIPHEA > 0
		aHEAINS[nTIPHEA,6] := "PERTENCE('MPFTE') .And. NGVALTERC(M->TL_TIPOREG) .And. NGRETNOREG(M->TL_TIPOREG) .And. "
		aHEAINS[nTIPHEA,6] += 'MNT420ACHO( oGet:aCols, oGet:nAt ) .And. NGCLEARSTL() .And. NG420VLTR( oGet:aCols, oGet:nAt, oGet:aHeader )'
	EndIf

	If nCODINS > 0
		aHEAINS[nCODINS,6] += " .And. MNT420BSA('','') "
	EndIf

	If ( nPosLocali := aScan( aHEAINS, { |x| AllTrim( Upper( X[2] ) ) == 'TL_LOCALIZ' } ) ) > 0

		aHEAINS[nPosLocali,6]  := "MNTA420LOC( .T. )"
		aHEAINS[nPosLocali,13] := "MNTA420WHE( 'TL_LOCALIZ' )"

	EndIf

	If ( nTarSTL := GDFieldPos( 'TL_TAREFA', aHeaIns ) ) > 0

		aHeaIns[nTarSTL,6]  := "MNTA420Vld( 'TL_TAREFA' )"
		aHeaIns[nTarSTL,9]  := 'TT9COR'
		aHeaIns[nTarSTL,13] := ''

	EndIf

	dbSelectArea( "STL" )
	dbSetOrder(1)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420INETA³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NG420INETA(nOPCX)

	Local aNAO	    := {}
	Local cKEY      := ''
	Local cGETWHILE := ''
	Local nTarSTQ   := 0
	Local nx	    := 0

	nQTETA		:= 0
	cKEY		:= M->TJ_ORDEM + M->TJ_PLANO
	cGETWHILE	:= "TQ_FILIAL == xFilial('STQ') .and. TQ_ORDEM == M->TJ_ORDEM .and. TQ_PLANO == M->TJ_PLANO"
	aNAO		:= {"TQ_ORDEM","TQ_PLANO","TQ_TIPRES","TQ_OPCAO",;
						"TQ_NOMSITU","TQ_OK","TQ_TIPORES","TQ_OPCAO","TQ_CODFUNC"}

	If SuperGetMv( 'MV_NGTARGE', .F., '2' ) == '2'

		aAdd( aNao, 'TQ_TAREFA' )
		aAdd( aNao, 'TQ_NOMTARE' )
	
	ElseIf TT9->( FieldPos( 'TT9_CARACT' ) ) == 0

		aAdd( aNao, 'TQ_NOMTARE' )

	EndIf

	aHEAETA := CABECGETD( 'STQ', aNAO, 2 )

	//Inclui coluna de registro atraves de funcao generica
	ADHeadRec("STQ",aHEAETA)

	If nOPCX == 3
		aGETETA := BLANKGETD(aHeaEta)
	Else
		aGETETA := MAKEGETD("STQ", cKEY,aHeaEta, cGETWHILE)
		If Empty(aGETETA)
			aGETETA := BLANKGETD(aHeaEta)
		EndIf
	EndIf

	nSEE := aSCAN(aHEAETA,{|x| AllTrim(Upper(X[2])) == "TQ_SEQTARE"})
	For nx = 1 To Len(aGETETA)
		If nSEE > 0
			If nx = 1
				cPxQSeq := aGETETA[nx,nSEE]
			Else
				If aGETETA[nx,nSEE] > cPxQSeq
					cPxQSeq := aGETETA[nx,nSEE]
				EndIf
			EndIf
			nQTETA ++
		EndIf
	Next nx

	If ( nTarSTQ := GDFieldPos( 'TQ_TAREFA', aHeaEta ) ) > 0

		aHeaEta[nTarSTQ,6]  := "MNTA420Vld( 'TQ_TAREFA' )"
		aHeaEta[nTarSTQ,9]  := 'TT9COR'
		aHeaEta[nTarSTQ,13] := ''

	EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420INSU ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG420INSU()

	Local aOldSCP	:= aClone(aNgTabSCP)
	Local bKeyF4    := SetKey(VK_F4)
	Local lMNTA420W	:= ExistBlock("MNTA420W")

	Private aNgCadBtn := {}, aTempBut := {}

	If Type("aTela") = "A"
		If !obrigatorio(aGets,aTela)
			Return
		EndIf
	EndIf

	// Foi mudado o nome da função de U_MNTA420GSA para U_MNTA420Y pois nome da função
	// ultrapassava o limite de 10 caracteres e entrava em conflito com outra função U_MNTA420G.
	If ExistBlock( 'MNTA420Y' )
		aTempBut := ExecBlock( 'MNTA420Y', .F., .F. )
		If ValType(aTempBut) == "A"
			aNgCadBtn := aClone(aTempBut)
		EndIf
	EndIf

	// SOMENTE QUANDO INTEGRADO AO RM, ADICIONA BOTÃO AO AÇÕES RELACIONADAS.
	If SuperGetMv( 'MV_NGINTER', .F., '' ) == 'M' .And. FindFunction( 'MntUpdCost' )

		// Atualiza Saldo/Custo do Produto
		aAdd( aNgCadBtn, { Nil, { || MntUpdCost( oGet:aCols, oGet:aHeader ) }, STR0203 } )

	EndIf

	aHEADER	 := aCLONE(aHEAINS)
	aCOLS	 := aCLONE(aGETINS)
	cTUDOKI	 := "NG420TUDOK(oGet:aCOLS)"
	cLINOKI	 := "NG420LINOK(oGet:aCOLS, oGet:nAt ) .And. PutFileInEof('STL') " //Coloca tabela de insumos STL em fim de arquivo para não apresentar informações na nova linha.
	nPOSINS	 := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	nQTDHEA	 := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
	nPosCodI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	nPosNum	 := aSCAN(aHeaIns, {|x| AllTrim(Upper(X[2])) == "TL_NUMSA"})
	nPosItem := aSCAN(aHeaIns, {|x| AllTrim(Upper(X[2])) == "TL_ITEMSA"})
	dINI	 := M->TJ_DTORIGI

	SetKey( VK_F4 , { || MntViewSB2( oGet:aCols[oGet:nAt,nPOSINS], oGet:aCols[oGet:nAt,nPosCodI] ) } )
	SetKey( VK_F5 , { || MntF5Saldo( oGet:aHeader, oGet:aCols ) } )
	SetKey( VK_F12, { || NGINSUF12( 'M->TL_CODIGO', M->TJ_CODBEM, oGet:aCols[oGet:nAt,nPOSINS], .T., , 'TL_NOMCODI' ) } )

	nOpcai := 0

	//Ponto de Entrada customizar ordenamento dos insumos
	If lMNTA420W
		aCols := ExecBlock("MNTA420W",.F.,.F., {aCols,aHEADER})
	EndIf

	Define MsDialog oDlg2 Title STR0025 From 163,0 To 463,If(GetScreenRes()[1] <= 800,750,GetScreenRes()[1]*0.73) Pixel Of oMainWnd //"Insumos - O.S. Corretiva"

		oGet := MsNewGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],GD_INSERT + GD_UPDATE + GD_DELETE,;
									cLINOKI,cTUDOKI,,,,9999,,,"NG420DELI(oGet:aCOLS,oGet:nAt)",oDlg2,aHeader,aCols)
		oGet:aInfo[nQTDHEA,4] := Space(Len(Posicione("SX3",2, "","X3_WHEN")))

	ACTIVATE MSDIALOG oDLG2 ON INIT EnchoiceBar(oDLG2,{||nOpcai:=1, If(oGET:TUdoOK(),oDLG2:End(), nOpcai := 0)},{||oDLG2:End()},;
		AlignObject(oDLG2,{oGet:oBrowse},1),aNgCadBtn)

	If nOpcai == 1
		aHEAINS := aCLONE(oGet:aHeader)
		aGETINS := aCLONE(oGet:aCOLS)
		If ExistBlock("MNTA420E")
			ExecBlock("MNTA420E",.F.,.F.)
		EndIf
	Else
		aNgTabSCP := aClone(aOldSCP) //Se cancelar a tela, a variavel aNgTabSCP é restaurada
	EndIf

	Set Key VK_F12 To

	SetKey(VK_F4,bKeyF4)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420ETAPA³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG420ETAPA()

	If Type("aTela") = "A"
		If !obrigatorio(aGets,aTela)
			Return
		EndIf
	EndIf

	aHeader	:= aClone( aHeaEta )
	aCols	:= aClone( aGetEta )
	nOpcae	:= 0

	Define MsDialog oDlg2 Title STR0026 From 163,0 To 463,If(GetScreenRes()[1] <= 800,750,GetScreenRes()[1]*0.73) Pixel Of oMainWnd //"Etapas - O.S. Corretiva"

		oGetEtapa := MsNewGetDados():New( aPosObj[2,1], aPosObj[2,2], aPosObj[2,3], aPosObj[2,4], GD_INSERT + GD_UPDATE + GD_DELETE,;
			'NG420ETALI()', 'NG420ETALI()', , , , 9999, , , , oDlg2, aHeader, aCols )

	Activate MsDialog oDLG2 On Init ( EnchoiceBar( oDLG2, { || nOpcae:=1, IIf( oGetEtapa:TudoOk(),oDLG2:End(),.F.)},{||oDLG2:End()}),;
									AlignObject(oDLG2,{oGetEtapa:oBrowse},1))
	If nOpcae == 1

		aHeaEta  := aClone( oGetEtapa:aHeader )
		aGetEta  := aClone( oGetEtapa:aCols )

		// Caso alguma linha tenha sofrido alteração, libera a gravação dos registros.
		lSaveSTQ := ( lSaveSTQ .Or. ( Len( oGetEtapa:aLastEdit ) > 0 .Or. oGetEtapa:lModified ) )

	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420ATINS³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG420ATINS()

	Local dDTFIMINS
	Local cHRFIMINS		:= ''
	Local cNGUNIDT		:= AllTrim( SuperGetMv( 'MV_NGUNIDT' ) )
	Local nPOS4201		:= 0
	Local nCOL			:= 0
	Local nHEA			:= 0
	Local nULT 			:= Len( aGETINS[ 1 ] )
	Local nTARi 		:= aSCAN( aHeaIns, { | x | AllTrim( Upper( X[ 2 ] ) ) == 'TL_TAREFA' } )
	Local nSETi 		:= aSCAN( aHeaIns, { | x | AllTrim( Upper( X[ 2 ] ) ) == 'TL_SEQTARE' } )
	Local nDtInc 		:= aSCAN( aHeaIns, { | x | AllTrim( Upper( X[ 2 ] ) ) == 'TL_DTINICI' } )
	Local nHoInc 		:= aSCAN( aHeaIns, { | x | AllTrim( Upper( X[ 2 ] ) ) == 'TL_HOINICI' } )
	Local nDtFim 		:= aSCAN( aHeaIns, { | x | AllTrim( Upper( X[ 2 ] ) ) == 'TL_DTFIM' } )
	Local nHoFim 		:= aSCAN( aHeaIns, { | x | AllTrim( Upper( X[ 2 ] ) ) == 'TL_HOFIM' } )
	Local nNumSC		:= aSCAN( aHeaIns, { | x | AllTrim( Upper( X[ 2 ] ) ) == 'TL_NUMSC' } )
	Local nPosNum       := aSCAN( aHeaIns, { | x | AllTrim( Upper( X[ 2 ] ) ) == 'TL_NUMSA' } )
	Local nPosRec       := GDFieldPos( 'TL_REC_WT', aHeaIns )
	Local nPosTip		:= GDFieldPos( 'TL_TIPOREG', aHeaIns )
	Local nPosCod		:= GDFieldPos( 'TL_CODIGO', aHeaIns )
	Local lMMoeda 		:= NGCADICBASE( 'TL_MOEDA', 'A', 'STL', .F. )
	Local lMNTA420R		:= ExistBlock( 'MNTA420R' )
	Local aCstMoeda		:= {}
	Local aArea         := GetArea()
	Local lLogix        := AllTrim( GetNewPar( 'MV_NGINTER', 'N' ) ) == 'L'
	Local aLinhaProd    := {}
	Local nAEN          := 0
	Local nSeq          := 0

	Private lGeraSA		:= NG420CHKSA()
	Private aSAGer		:= {}
	Private cNumSA		:= Space( Len( SCP->CP_NUM ) ) // Usado na funcao NGGERASA

	lUSATARG	:= If( FindFunction( 'NGUSATARPAD' ) .And. nTARi > 0, NGUSATARPAD(), .F. )

	m->TL_PLANO   := If( FunName() = 'MNTA420', '000000', M->TJ_PLANO )
	m->TL_SEQRELA := '0  '

	dbSelectArea("STL")
	dbSetOrder(1)
	ProcRegua(Len(aGETINS))

	For nCOL := 1 to Len(aGETINS)

		If lUSATARG
			M->TL_TAREFA := aGETINS[nCOL][nTARi]
		Else
			M->TL_TAREFA  := PadR( '0', TamSX3('TL_TAREFA')[1] )
		EndIf
		IncProc()
		xx := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
		M->TL_TIPOREG := If(xx > 0, aGETINS[nCOL][xx], " ")

		xx := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_CODIGO"})
		M->TL_CODIGO := If(xx > 0, aGETINS[nCOL][xx], Space(15))

		If Empty(aGETINS[nCOL][1])
			Loop
		EndIf

		cChavSTL := M->TJ_ORDEM + M->TL_PLANO + M->TL_TAREFA + aGETINS[nCOL][nPosTip] + aGETINS[nCOL][nPosCod] + M->TL_SEQRELA
		If nSETi <> 0
			cChavSTL += aGETINS[nCOL,nSETi]
		EndIf

		If aGETINS[nCOL][nULT]

			If msSeek( FWxFilial( 'STL' ) + cChavSTL )

				RecLock("STL", .F.)
					dbDelete()
				MsUnlock("STL")
			
				EndIf

			Loop

		EndIf

		lNOVOSTL := .F.

		nSeq := 1

		dbSelectArea( 'STL' )
		dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
		While msSeek( FWxFilial('STL') + M->TJ_ORDEM + M->TL_PLANO + M->TL_TAREFA + aGETINS[ nCOL, nPosTip ] + M->TL_CODIGO + M->TL_SEQRELA + PADL( cValToChar( nSeq ), 3, '0' ) )
			
			If STL->(Recno()) == aGETINS[ nCOL, nPosRec ]
				
				// Se o registro já existe mantem o SeqTare
				nSeq := Val( cValToChar( STL->TL_SEQTARE ) )
				Exit

			Else
				
				nSeq ++

			EndIf

		End

		If Empty( aGetIns[ nCol, nPosRec ] )

			lNOVOSTL := .T.

			RecLock( 'STL', .T. )

				STL->TL_FILIAL	:= FWxFilial( 'STL' )
				STL->TL_ORDEM	:= M->TJ_ORDEM
				STL->TL_PLANO	:= M->TL_PLANO
				STL->TL_SEQRELA	:= M->TL_SEQRELA
				STL->TL_TAREFA	:= M->TL_TAREFA
				STL->TL_TIPOHOR	:= cNGUNIDT

		Else

			msGoTo( aGetIns[nCol,nPosRec] )

			RecLock( 'STL', .F. )

		EndIf

		For nHEA := 1 To Len(aHEAINS)
			If aHEAINS[nHEA][10] != "V"
				If !lNOVOSTL
					If nPosNum > 0
						//Caso os campos estejam vazios não altera seus valores.
						If AllTrim(Upper(aHEAINS[nHEA][2])) $ "TL_NUMSA/TL_ITEMSA" .AND. Empty(aGETINS[nCOL][nPosNum])
							Loop
						EndIf
					EndIf
					//Condição para não "limpar" ITEMSC e NUMSC caso estejam preenchidos na STL
					If nNumSC > 0
						//Caso os campos estejam vazios não altera seus valores.
						If AllTrim(Upper(aHEAINS[nHEA][2])) $ "TL_NUMSC/TL_ITEMSC" .AND. Empty(aGETINS[nCOL][nNumSC])
							Loop
						EndIf
					EndIf
				ElseIf AllTrim(Upper(aHEAINS[nHEA][2])) $ "TL_SEQTARE" // Apenas na Inclusão
					 Loop
				EndIf
				
				xx := "STL->" + aHEAINS[nHEA][2]
				yy := aGETINS[nCOL][nHEA]
				&xx. := yy
			EndIf
		Next

		STL->TL_SEQTARE := PADL( cValToChar( nSeq ), 3, '0' )
		STL->TL_USACALE := If(Empty(STL->TL_USACALE),"N",STL->TL_USACALE)
		If STL->TL_USACALE == "S"
			STL->TL_TIPOHOR := "S"
		Else
			STL->TL_TIPOHOR := cNGUNIDT
		EndIf
		STL->TL_GARANTI := If(Empty(STL->TL_GARANTI),"N",STL->TL_GARANTI)


		If FunName() $ 'MNTA990'
			STL->TL_DTINICI	:= aGETINS[nCOL][nDtInc] //Data Início
			STL->TL_HOINICI	:= aGETINS[nCOL][nHoInc] //Hora Início
			STL->TL_DTFIM	:= aGETINS[nCOL][nDtFim] //Data Fim
			STL->TL_HOFIM	:= aGETINS[nCOL][nHoFim] //Hora Fim
		Else

			nPOS4201  := aScan(aDATINS,{|x| x[6]+x[1]+x[7] = M->TL_TIPOREG + M->TL_CODIGO + aGETINS[ nCOL, nSETI ] })

			dDTFIMINS := aDATINS[nPOS4201][4]
			cHRFIMINS := aDATINS[nPOS4201][5]

			If STL->TL_TIPOREG = "P"
				STL->TL_DTINICI := M->TJ_DTORIGI
				STL->TL_HOINICI := hINI
				STL->TL_DTFIM   := STL->TL_DTINICI
				STL->TL_HOFIM   := STL->TL_HOINICI
			Else

				STL->TL_DTINICI := IIf( STL->TL_USACALE == 'S', STL->TL_DTINICI, M->TJ_DTORIGI )
				If Empty( StrTran( STL->TL_HOINICI, ":", "", 1, ) )
					STL->TL_HOINICI := hINI
				EndIf

				If !Empty(dDTFIMINS)
					STL->TL_DTFIM   := dDTFIMINS
					STL->TL_HOFIM   := cHRFIMINS
				Else
					// Calcula a data e hora fim a partir de uma data e hora início
					vDataHora := NGDTHORFIM( STL->TL_DTINICI,STL->TL_HOINICI,STL->TL_QUANTID )
					STL->TL_DTFIM := vDataHora[1] //Data Fim
					STL->TL_HOFIM := vDataHora[2] //Hora Fim
				EndIf

			EndIf
		EndIf

		If lMMoeda .And. FindFunction("NGCALCUSMD")
			aCstMoeda     := NGCALCUSMD(stl->tl_codigo,stl->tl_tiporeg,stl->tl_quantid,stl->tl_local,stl->tl_tipohor,,,stl->tl_quanrec)
			STL->TL_CUSTO := aCstMoeda[1]
			STL->TL_MOEDA := aCstMoeda[2]
		Else
			STL->TL_CUSTO := NGCALCUSTI(stl->tl_codigo,stl->tl_tiporeg,stl->tl_quantid,stl->tl_local,stl->tl_tipohor,,,stl->tl_quanrec)
			If lMMoeda
				STL->TL_MOEDA := "1"
			EndIf
		EndIf

		If lLogix
			nAEN := aScan(aHEAINS,{|x| Trim(upper(x[2])) == "TL_CODAEN"})
			If nAEN > 0
				STL->TL_CODAEN := aGETINS[nCOL][nAEN]
			EndIf
			aAdd(aLinhaProd, {STL->TL_CODIGO, M->TJ_ORDEM, STL->TL_QUANTID, STL->TL_CODAEN})
		EndIf

		STL->(MsUnlock())

		If lMNTA420R

			ExecBlock( 'MNTA420R', .F., .F., { nCol, aGetIns, aHeaIns } )

		EndIf

	Next

	RestArea(aArea)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420ATETA³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG420ATETA()

	Local lNGTARGE := AliasIndic("TT9") .And. GetNewPar("MV_NGTARGE","2") == '1'
	Local nTARQ    := aScan(aHeaEta,{|x| Trim(upper(x[2])) == "TQ_TAREFA"})
	Local nETAQ    := aScan(aHeaEta,{|x| Trim(upper(x[2])) == "TQ_ETAPA"})
	Local nSeqTar  := GDFieldPos( 'TQ_SEQTARE', aHeaEta )
	Local nx       := 0
	Local i        := 0
	Local cTask    := Padr( '0', TamSx3('TQ_TAREFA')[1] )

	nMaxArray := LEN(aGETETA)
	aCOLS     := aCLONE(aGETETA)
	aHEADER   := aCLONE(aHeaEta)

	If Empty(aCols[1][1])
		nMaxArray := 0
	EndIf

	//--------------------------------------------------
	// Deleta SQT caso não encontre no acols de etapas
	//--------------------------------------------------
	NGIFDBSEEK("STQ",M->TJ_ORDEM+M->TJ_PLANO,1)
	While !Eof() .And. STQ->TQ_FILIAL == xFILIAL("STQ") .And.;
		STQ->TQ_ORDEM  == M->TJ_ORDEM .And. STQ->TQ_PLANO == M->TJ_PLANO

		If aSCAN( aCOLS,{|x| IIF( lNGTARGE, x[nTARQ], cTask ) + x[nETAQ] == STQ->TQ_TAREFA+STQ->TQ_ETAPA}) == 0
			NGDELETAREG("STQ")
		EndIf

		dbSelectArea("STQ")
		dbSkip()
	End

	//-----------------------------------------------------------
	// Verifica se nao foi excluido nenhum registro e grava
	// as novas inclusoes e alteracoes efetuadas
	//-----------------------------------------------------------
	For nx := 1 TO nMaxArray

		If lNGTARGE
			cTask := aCOLS[nx][nTARQ]
		EndIf

		If aCOLS[nx][LEN(aCOLS[nx])]

			If NGIFDBSEEK( "STQ", M->TJ_ORDEM + M->TJ_PLANO + cTask + aCOLS[nx][nETAQ], 1 )
				cTAR := cTask
				cETA := aCOLS[nx][nETAQ]
				nQTD := 0

				If lNGTARGE
					aEVAL(aCOLS,{|x| If(x[nTARQ]+x[nETAQ] == cTAR+cETA,nQTD++,NIL)})
				Else
					aEVAL(aCOLS,{|x| If(x[nETAQ] == cETA,nQTD++,NIL)})
				EndIf

				If nQTD <= 1
					dbSelectArea("STQ")
					NGDELETAREG("STQ")
				EndIf
			EndIf

			Loop

		EndIf

		dbSelectArea( 'STQ' )
		dbSetOrder( 1 ) // TQ_FILIAL + TQ_ORDEM + TQ_PLANO + TQ_TAREFA + TQ_ETAPA + TQ_SEQTARE + TQ_SEQRELA
		If msSeek( FWxFilial( 'STQ' ) + M->TJ_ORDEM + M->TJ_PLANO + cTask +;
			aCols[nX,nETAQ] + aCols[nX,nSeqTar] + '0  ')

			RecLock( 'STQ', .F. )

		Else

			RecLock( 'STQ', .T. )
			
			STQ->TQ_FILIAL  := FWxFILIAL( 'STQ' )
			STQ->TQ_ORDEM   := STJ->TJ_ORDEM
			STQ->TQ_PLANO   := STJ->TJ_PLANO

			If !lNGTARGE

				STQ->TQ_TAREFA := cTask
				
			EndIf

		EndIf

		For i := 1 TO FCOUNT()
			xx := GDFIELDPOS(AllTrim(FIELDNAME(i)))
			If xx > 0
				vv   := "STQ->"+FIELDNAME(i)
				&vv. := aCOLS[nx][xx]
			EndIf
		Next i

		If STQ->( FieldPos( 'TQ_SEQRELA' ) ) > 0

			STQ->TQ_SEQRELA := '0  '

		EndIf

		MsUnLock()

	Next nX

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420DTFIM³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG420DTFIM()

Local nD,nQTD,nUND,nTIP
Local nTEMPO := HTOM(hINI)

nTIP := aScan(aHeaIns,{|x| Trim(upper(x[2])) == "TL_TIPOREG"})
nQTD := aScan(aHeaIns,{|x| Trim(upper(x[2])) == "TL_QUANTID"})
nUND := aScan(aHeaIns,{|x| Trim(upper(x[2])) == "TL_UNIDADE"})

If nTIP == 0 .or. nQTD == 0 .or. nUND == 0
	Return Nil
EndIf

aDATINS := {}

For nD := 1 to Len(aGETINS)
	If aGETINS[nD][nTIP] == "P"
		AAdd(aDATINS, {dINI, hINI})
		Loop
	EndIf

	cUNDAD := ALLTRIM(aGETINS[nD][nUND])

	If cUNDAD == "D"
		dFIM := dINI + aGETINS[nD][nQTD]
	ElseIf cUNDAD == "S"
		dFIM := dINI + (aGETINS[nD][nQTD] * 7)
	ElseIf cUNDAD == "M"
		nAno := Year(dINI)
		nMES := Month(dINI)
		nDIA := Day(dINI)
		nMES := nMES + aGETINS[nD][nQTD]

		While nMES > 12
			nMES := nMES - 12
			nANO := nANO + 01
		End

		nDIA := Strzero(nDIA,2)
		nMES := Strzero(nMES,2)
		nANO := Alltrim( Strzero(nANO,4) )

		dFIM := CtoD(nDIA + '/' + nMES + '/' + nANO)

		While Empty(dFIM)
			nDIA := Val(nDIA)-1
			nDIA := Strzero(nDIA,2)
			dFIM := CtoD(nDIA + '/' + nMES + '/' + nANO)
		End

	Else
		nTEMPO := nTEMPO + (aGETINS[nD][nQTD] * 60)
		nSOMA  := 0

		While nTEMPO > 1440
			nSOMA	:= nSOMA + 1
			nTEMPO	:= nTEMPO - 1440
		End

		dFIM := dINI + nSOMA
		hFIM := MtoH(nTEMPO)
	EndIf
	AAdd(aDATINS, {dFIM, hFIM} )
Next

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NG420CHK ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG420CHK(nOpcx,cFilTroc)

	Local nPOS420 := 0
	Local lRet 	  := .T. //Utilizar a variavel, para fechamento de tabelas no multiempresa
	Local cFilSt9
	Local cUnidade := ""
	Local nTamTAF  := FWTamSX3( 'TAF_CODNIV' )[1]

	//Verifica a data inicio da ordem de servico
	If !MNT420DTIN()
		lRet :=  .F.
	EndIf

	If M->TJ_DTORIGI == dDatabase .And. M->TJ_DTORIGI >= Date() .And. M->TJ_HORACO1 > Time()
		MsgStop( STR0185 ) //"A hora do contador 1 não pode ser maior que a hora atual."
		lRet :=  .F.
	EndIf

	//Verifica as datas de parada da O.S.
	If (!Empty(M->TJ_HOPRINI) .AND. M->TJ_HOPRINI <> "  :  ") .AND. Empty(M->TJ_DTPRINI)
		ShowHelpDlg(STR0098,{STR0168},2,{STR0170},2)//"ATENÇÃO"###"Data de Início da Parada não preenchida."###"Preencha todos os campos de data de parada."
		lRet :=  .F.
	ElseIf (Empty(M->TJ_HOPRINI) .OR. M->TJ_HOPRINI == "  :  ") .AND. !Empty(M->TJ_DTPRINI)
		ShowHelpDlg(STR0098,{STR0169},2,{STR0170},2)//"ATENÇÃO"###"Hora de Início da Parada não preenchida."###"Preencha todos os campos de data de parada."
		lRet :=  .F.
	EndIf

	If lRet .and. M->TJ_SITUACA = "C"
		If !MNT420NIE()
			lRet := .F.
		EndIf
	EndIf

	cFilSt9 := NGTrocaFil("ST9", cFilTroc)

	If lRet .and. nOPCX == 3
		If !NGOSABRVEN(M->TJ_CODBEM,M->TJ_SERVICO,.T.,.T.,.T.,,cFilTroc,,,1)
			lRet := .F.
		EndIf
	EndIf

	If lRet

		If ( nPos420 := aScan(aChoice,{|x| Trim( Upper(x) ) == "TJ_CODAREA"}) ) == 0
			M->TJ_CODAREA := ST4->T4_CODAREA
		EndIf

		If ( nPos420 := aScan(aChoice,{|x| Trim( Upper(x) ) == "TJ_TIPO"}) ) == 0
			M->TJ_TIPO := STE->TE_TIPOMAN
		EndIf

		If nOpcx == 3
			If M->TJ_TIPOOS == 'B'

				dbSelectArea("ST9")
				dbSetOrder(1)
				If dbSeek(cFilSt9 + M->TJ_CODBEM)

					If ( nPos420 := aScan(aChoice, {|x| Trim( Upper(x) ) == "TJ_CCUSTO"}) ) == 0
						M->TJ_CCUSTO := ST9->T9_CCUSTO
					EndIf

					If ( nPos420 := aScan(aChoice, {|x| Trim( Upper(x) ) == "TJ_CENTRAB"}) ) == 0
						M->TJ_CENTRAB := ST9->T9_CENTRAB
					EndIf

					If ( nPos420 := aScan(aChoice, {|x| Trim( Upper(x) ) == "TJ_PRIORID"}) ) == 0
						M->TJ_PRIORID := ST9->T9_PRIORID
					EndIf
				EndIf

			ElseIf M->TJ_TIPOOS == 'L'

				dbSelectArea( 'TAF' )
				dbSetOrder( 7 )
				If msSeek( FWxFilial( 'TAF' ) + 'X2' + SubStr( M->TJ_CODBEM, 1, nTamTAF ) )

					If ( nPos420 := aScan(aChoice, {|x| Trim( Upper(x) ) == "TJ_CCUSTO"}) ) == 0
						M->TJ_CCUSTO := TAF->TAF_CCUSTO
					EndIf

					If ( nPos420 := aScan(aChoice, {|x| Trim( Upper(x) ) == "TJ_CENTRAB"}) ) == 0
						M->TJ_CENTRAB := TAF->TAF_CENTRA
					EndIf
				EndIf

			EndIf
		EndIf

		M->TJ_TERMINO := "N"
		M->TJ_USUARIO := IIf( Len(STJ->TJ_USUARIO) > 15, cUsername, SubStr(cUsuario, 7, 15) )

		cBemRet := M->TJ_CODBEM

	EndIf

	If lRet .and. nOpcx == 3
		If !NGMNTOSCO(M->TJ_TIPOOS,M->TJ_CODBEM,M->TJ_SERVICO,M->TJ_DTORIGI,'Val(STJ->TJ_PLANO) = 0')
			lRet := .F.
		EndIf
	EndIf

	If (nOpcx == 3) .And. lRet

		//Adicionada validação que impede prosseguir com contador preenchido e hora vazio
		If lRet .And. !NGCONTRET(M->TJ_DTORIGI,M->TJ_POSCONT,M->TJ_HORACO1,TIPOACOM,;
			M->TJ_DTORIGI,M->TJ_POSCON2,M->TJ_HORACO2,TIPOACOM2,.T.)
			lRet := .F.
		EndIf

		// INCLUIDO 06/03/03 TESTE DE HISTORICO  - In cio
		If lRet .And. TIPOACOM .and. nOPCX <> 5
			If M->TJ_POSCONT > 0
				If !NGCHKHISTO(cBEMRET,M->TJ_DTORIGI,M->TJ_POSCONT,M->TJ_HORACO1,1,,.T.,cFilSt9) .Or.;
						!NGVALIVARD(cBEMRET,M->TJ_POSCONT,M->TJ_DTORIGI,M->TJ_HORACO1,1,.T.,,cFilSt9)
					lRet := .F.
				EndIf
			EndIf

			//Verifica se o veiculo tem viagem escalada
			If lRet .and. !NGCHKTMS(cBEMRET,M->TJ_DTORIGI,M->TJ_HORACO1)
				lRet := .F.
			EndIf
		EndIf

		If lRet .And. TipoAcom2 .And. M->TJ_POSCON2 > 0 .And. nOPCX <> 5
			If !NGCHKHISTO(cBEMRET,M->TJ_DTORIGI,M->TJ_POSCON2,M->TJ_HORACO2,2,,.T.,cFilSt9) .Or.;
					!NGVALIVARD(cBEMRET,M->TJ_POSCON2,M->TJ_DTORIGI,M->TJ_HORACO2,2,.T.,,cFilSt9)
				lRet := .F.
			EndIf
		EndIf
	EndIf

	If lRet .and. !NGCONFBLQBE(M->TJ_CODBEM,"C")
		lRet := .F.
	EndIf

	If lRet

		dbSelectArea("ST9")
		dbSetOrder(1)
		If dbSeek(xFilial("ST9") + M->TJ_CODBEM)
			If ST9->T9_UNGARAN == "H"
				cUnidade := IIf( ST9->T9_PRGARAN > 1 , STR0171 , STR0172 )//"Horas"###"Hora"
			ElseIF ST9->T9_UNGARAN == "D"
				cUnidade := IIf( ST9->T9_PRGARAN > 1 , Capital(STR0134) , STR0075 )//"Dias"###"Dia"
			ElseIF ST9->T9_UNGARAN == "S"
				cUnidade := IIf( ST9->T9_PRGARAN > 1 , Capital(STR0135) , STR0076 )//"Semanas"###"Semana"
			ElseIf ST9->T9_UNGARAN == "M"
				cUnidade := IIf( ST9->T9_PRGARAN > 1 , Capital(STR0136) , STR0077 )//"Meses"###"Mês"
			ElseIF ST9->T9_UNGARAN == "A"
				cUnidade := IIf( ST9->T9_PRGARAN > 1 , STR0174 , STR0173 )//"Anos"###"Ano"
			ElseIf ST9->T9_UNGARAN == "K"
				cUnidade := IIf( ST9->T9_PRGARAN > 1 , STR0175 , STR0176 )//"Quilometros"###"Quilometro"
			EndIf

			If !Empty(ST9->T9_DTGARAN) .And. ST9->T9_DTGARAN >= dDataBase
				If !Empty(ST9->T9_PRGARAN)
					lRet := MsgYesNo(STR0177+AllTrim(Str(ST9->T9_PRGARAN))+" "+cUnidade+STR0178+DtoC(ST9->T9_DTGARAN)+STR0179,STR0098)//"Este Bem possui garantia de "###", com vencimento em  "###". Deseja continuar?"###"ATENÇÃO"
				Else
					lRet := MsgYesNo(STR0180+DtoC(ST9->T9_DTGARAN)+STR0179,STR0098)//"Este Bem possui garantia com vencimento em "###". Deseja continuar?"###"ATENÇÃO"
				EndIf
			EndIf
		EndIf
	EndIf

	If lRet .AND. Inclui .OR. Altera
		If !MNTA420GAR(aGETINS,aHEAINS)
			lRet := .F.
		EndIf
	EndIf

	If lRet .and. ExistBlock("MNTA4207")
		lRet := ExecBlock("MNTA4207",.F.,.F.)
	EndIf

	If nOpcx == 5

		If lRet	

			/*--------------------------------------------------------------------------------+
			| Consiste se existe SA vinculada diretamente a OS, sem um insumo ter gerado a SA |
			+--------------------------------------------------------------------------------*/
			lRet := MNTVldSAOS( M->TJ_ORDEM )

		EndIf

		If lRet .And. ExistBlock("MNTA420F")
			lRet := ExecBlock("MNTA420F",.F.,.F.)
		EndIf
	
	EndIf

	If lRet .And. Inclui
		dbSelectArea("STJ")
		M->TJ_CONTINI := M->TJ_POSCONT
		M->TJ_USUAINI := cUserName
	EndIf

	//Realiza tarvamento da rotina de gravação de insumos para inclusões.
	If nOpcX == 3 .And. lRet
		If !MNT420FIT( .T. )
			lRet :=  .F.
		EndIf
	EndIf

	//---------------------------------------------------
	//Mensagm Única - Integra OS gerada com o backoffice
	//---------------------------------------------------
	If lRet
		If AllTrim(GetNewPar("MV_NGINTER","N")) == "M" .And. (nOpcx == 3 .Or. nOpcx == 4) .And. M->TJ_SITUACA == 'L' //Mensagem Unica
			lRet := NGMUMntOrd(STJ->(RecNo()),nOpcx,.T.)
		EndIf
	EndIf
	//---------------------------------------------------

	//Realiza destravamento da rotina de gravação de insumos para inclusões.
	If !lRet .And. nOpcX == 3
		MNT420FIT( .F. )
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} NG420LINOK
Verifica Consiste a Linha da GETDADOS
@author  Paulo Pego
@since
@version P12
@param  aColsUse - Objeto da GetDados     - Não obrigatório
		nLinAtu  - Linha Atua da GetDados - Não obrigatório

/*/
//-------------------------------------------------------------------
Function NG420LINOK( aColsUse, nLinAtu )

	Local nx
	Local lRet	     := .T.
	Local qtd		 := 0, nMAX
	Local dDtFimM    := CtoD("  /  /  ")
	Local dDtAtuFi   := CtoD("  /  /  ")
	Local cHrFimM    := ""
	Local cHrAtuFi   := ""
	Local cCaledM	 := ""
	Local cCaledAtu  := ""
	Local cIntComps	 := SuperGetMv( "MV_NGMNTCM",.F.,"N" ) //Integração entre MNT e Compras
	Local cIntEstoq	 := SuperGetMv( "MV_NGMNTES",.F.,"N" ) //Integração entre MNT e Estoque
	Local lIntRM     := AllTrim(GetNewPar("MV_NGINTER","N")) == "M" // Integração com Mensagem Unica ( RM )
	Local nInsumos   := 0
	Local lUseTar    := .T.
	Local lNumSATela := .T.

	Default aColsUse := oGet:aCols
	Default nLinAtu  := oGet:nAt

	If cPrograma <> "MNTA902"
		NGRETAUMVPA(vVetMvP)
	EndIf

	nTAR    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TAREFA" })
	nTIP    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	nCOD    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	nQTR    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANREC" })
	nQUTD   := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
	nDES    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DESTINO" })
	nUND    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_UNIDADE" })
	nLOC    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOCAL" })
	nUSC    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_USACALE" })
	nDTI    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })
	nHOI    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI" })
	nSQT    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_SEQTARE" })
	nGAR    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOCAPLI" })
	nLOJ    := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOJA" })
	nNumSa  := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_NUMSA" })
	nItemSA := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_ITEMSA" })

	// Verifica se os campos NumSA e ItemSA estão presentes em tela.
	If nNumSa == 0 .And. nItemSA == 0
		lNumSATela := .F.
	EndIf

	If nTAR == 0
		If nTip == 0 .or. nCOD == 0 .or. nQUTD == 0 .or. nDES == 0
			Return .T.
		EndIf
		lUseTar := .F.
	Else
	   If nTAR == 0 .or. nTip == 0 .or. nCOD == 0 .or. nQUTD == 0 .or. nDES == 0
	      Return .T.
	   EndIf
	EndIf

	nLIN := 1
	If Len(aColsUse) == 1
	   If aColsUse[1][Len(aColsUse[1])]
	      Return .T.
	   EndIf
	Else
	   nLIN := n
	EndIf

	cTAR := If(nTAR > 0,aColsUse[nLIN][nTAR],Space(Len(STL->TL_TAREFA)))
	cCOD := aColsUse[nLIN][nCOD]
	cTIP := aColsUse[nLIN][nTIP]
	cQTR := aColsUse[nLIN][nQTR]
	cQTD := aColsUse[nLIN][nQUTD]
	cDES := aColsUse[nLIN][nDES]
	cUND := aColsUse[nLIN][nUND]
	cLOC := aColsUse[nLIN][nLOC]
	cUSC := aColsUse[nLIN][nUSC]
	cDTI := aColsUse[nLIN][nDTI]
	cHOI := IIf( Empty( aColsUse[nLIN][nHOI] ) .And. aColsUse[nLIN][nTIP] == 'M', SubStr( Time(), 1, 5), aColsUse[nLIN][nHOI] )
	cSQT := If(nSQT > 0,aColsUse[nLIN][nSQT],Space(1))
	cGAR := If(nGAR > 0,aColsUse[nLIN][nGAR],Space(15))

	If !Empty( nLoj )

		cLOJ := aColsUse[nLIN,nLoj]

	EndIf

	If Empty(cTAR) .And. Empty(cCOD) .And. Empty(cTIP) .And. Empty(cQTR);
	   .And. Empty(cQTD) .And. Empty(cDES) .And. Empty(cUND)
	   Return .T.
	EndIf

	nMax := Len(aColsUse[n])

	If cTIP == 'E' .Or. !NGCADICBASE( 'TL_SEQTARE', 'A', 'STL', .F. )

		IIf( nTAR == 0, aEval( aColsUse, { |x| IIf( ( x[nTIP] == cTIP .And. cCOD == x[nCOD] .And. !x[nMax] .And. IIf( !Empty( cSQT ), x[nSQT] == cSQT, .T. ) ), qtd++, NIL ) } ),;
			aEval( aColsUse, { |x| IIf( ( x[nTAR] == cTAR .And. x[nTIP] == cTIP .And. cCOD == x[nCOD] .And. IIf( !Empty( nLOJ ), cLOJ == x[nLOJ], .T. ) .And. !x[nMax] ), qtd++, NIL ) } ) )

		If qtd > 1

			Help(' ',1,'TARJAEXIST')
			lRet := .F.
			Return .F.
		
		EndIf

	EndIf

	nQTD := 0
	
	//Validação apenas para Produtos
	If cTIP == "P"

		If lIntRM .And. Altera .And. lNumSATela

			// TAR+PROD+LOC já existe acols
			For nInsumos := 1 To Len(aColsUse)

				// Verifica se o insumo inserido é Produto, se não está deletado,
				// se existe algum outro registro no aColsUse que possuia a mesma chave (TAR+COD+LOC)
				// e que não seja a linha que está posicionada o LinOK(nLIN)
				If aColsUse[ nInsumos, nTIP ] == 'P' .And. !aTail( aColsUse[ nInsumos ] ) .And.;
					IIf( lUseTar, aColsUse[ nInsumos, nTAR ] == cTAR, .T. ) .And. aColsUse[ nInsumos, nCOD ] == cCod .And.;
					aColsUse[ nInsumos, nLOC ] == cLOC .And. nInsumos != nLIN

					If !Empty( aColsUse[ nInsumos, nNumSa ] ) .And.;
						NGMUTRAREQ( 'SCP', aColsUse[ nInsumos, nNumSa ], xFilial("SCP"), .F.,;
						aColsUse[ nInsumos, nItemSA ], , aColsUse[ nInsumos, nLOC ] )

						nQTD++
						Exit

					EndIf

				EndIf

			Next nInsumos

		Else
			
			If !fVlDpIns()
				Return .F.
			EndIf

		EndIf
		
	Else
		//Verificar se usa Tarefa Generica
		If lUSATARG
			
			aEVAL( aColsUse, { |x| IIf( x[nCOD] == cCOD .And. x[nTAR] == cTAR .And. x[nGAR] == cGAR .And. x[nSQT] == cSQT .And.;
				x[nTIP] == cTIP .And. x[nLOC] == cLOC .And. x[nDES] == cDES .And. x[nDTI] == cDTI .And. x[nHOI] == cHOI .And.;
				IIf( !Empty( nLoj ), x[nLOJ] == cLOJ, .T. ) .And. !x[Len( x )], nQTD++, Nil ) } )

		Else
			
			aEVAL( aColsUse, { |x| IIf( x[nCOD] == cCOD .And. x[nGAR] == cGAR .And. x[nTIP] == cTIP .And. x[nLOC] == cLOC .And.;
				x[nDES] == cDES .And. x[nDTI] == cDTI .And. x[nHOI] == cHOI .And. IIf( !Empty( nLoj ), x[nLOJ] == cLOJ, .T. ) .And.;
				!x[Len( x )], nQTD++, Nil ) } )

		EndIf

	EndIf

	If nQTD > 1 .And. !Empty(cCOD)
		Help(" ",1,"JAGRAVADO")
		lRET := .F.
		Return .F.
	EndIf

	//Verifica sobreposição  de Mão de Obra Prevista
	If cTIP == "M" .And. cUSC == "S" .And. !empty(cDTI) .And. !Empty(cHOI)

		//Verificar o calendário do funcionário que será informado na getdados
		dbSelectArea("ST1")
		dbSetOrder( 01 ) // T1_FILIAL+T1_CODFUNC
		If dbSeek( xFilial( "ST1" ) + cCOD )
			
			If lHasFlut //Utiliza turno flutuante.
				cCaledAtu := MNTCALFLU( cCOD,cDTI,cDTI )
				If Empty( cCaledAtu ) //Se o funcionário não estiver relacionado à uma equipe de manutenção
					cCaledAtu := ST1->T1_TURNO
				EndIf
			Else
				cCaledAtu := ST1->T1_TURNO
			EndIf
		EndIf

		dDtAtuFi := NGDTHORFCALE(cDTI,cHOI,cQTD,cCaledAtu)[1] //Data fim do insumo atual
		cHrAtuFi := NGDTHORFCALE(cDTI,cHOI,cQTD,cCaledAtu)[2] //Hora fim do insumo atual

		For nX := 1 to len(aColsUse)
			//Verificar se o insumor é mão de obra
			If aColsUse[nX][nTIP] == "M" .And. nX <> nLIN
				//Verifica se a linha digitada é o mesma informado em outra linha na get dados
				If cCOD == aColsUse[nx][nCOD] .And. aColsUse[nX][nTAR] == cTAR .And. aColsUse[nX][nGAR] == cGAR .And. ;
						aColsUse[nX][nTIP] ==  cTIP .And. aColsUse[nX][nLOC] == cLOC .And. aColsUse[nX][nDES] == cDES

					//Verificar o calendário do funcionário já informado na getdados
					dbSelectArea("ST1")
					dbSetOrder(1)
					If dbSeek(xFilial("ST1")+aColsUse[nX][nCOD])
						cCaledM := ST1->T1_TURNO
					EndIf
					dDtFimM := NGDTHORFCALE(aColsUse[nX][nDTI],aColsUse[nX][nHOI],aColsUse[nX][nQUTD],cCaledM)[1] //Data fim do insumo percorrido
					cHrFimM := NGDTHORFCALE(aColsUse[nX][nDTI],aColsUse[nX][nHOI],aColsUse[nX][nQUTD],cCaledM)[2] //Hora fim do insumo percorrido

					//Comparação para verificar se existe sobreposição de horas
					If DtoS(cDTI)+cHOI < DtoS(dDtFimM)+cHrFimM .and.;
						DtoS(dDtAtuFi)+cHrAtuFi > DtoS(aColsUse[nX][nDTI])+aColsUse[nX][nHOI]
						MsgStop(STR0184)  //"Já existe uma previsão de mão de obra no intervalo de Data/Hora informada."
						lRet := .F.
						Exit
					EndIf
				EndIf
			EndIf
		Next nX
	EndIf

	If lRet

		lRet := NG420CHKLIN( nLIN, .T., aColsUse )

	EndIf

	If lRet .And. ( cIntComps == "S" .Or. cIntEstoq == "S" ) //Se houver integração entre os módulos (MNT e Compras) OU (MNT e Estoque).
		If cTIP == "T" .And. Empty( cLOC ) //Se o insumo for do tipo 'Terceiro' e o campo 'Almoxarifado' estiver vazio.
			//"O insumo " # " não tem conteúdo para o campo de almoxarifado. Quando insumo do tipo terceiro, o mesmo deve ser preenchido." # "Preencha o campo Almoxarifado."
			ShowHelpDlg( STR0098,{ STR0186+AllTrim( cCOD )+STR0187 },2,{ STR0188 },2 )
			lRet := .F.
		EndIf
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} NG420TUDOK
Verifica Consiste a GETDADOS
@author  Paulo Pego
@since
@version P12
@param  aColsUse - Objeto da GetDados     - Não obrigatório

/*/
//-------------------------------------------------------------------
Function NG420TUDOK(aColsUse)

	Local lRet     := .T.
	Local i        := 0
	Local aArea    := GetArea()
	Local lEmpenho := cUsaIntEs == 'S' .And. cGerSA == 'N'
	Local aProdEmp := {}
	Local nPosArr

	Default aColsUse := aCols

	nTAR := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TAREFA" })
	nTIP := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	nCOD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	nQTR := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANREC" })
	nQTD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
	nDES := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DESTINO" })
	nUND := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_UNIDADE" })
	nLOC := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOCAL" })
	nUSC := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_USACALE" })
	nDTI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })
	nHOI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI" })

	If nTAR = 0
		If nTIP == 0 .AND. nCOD == 0 .and. nQTR == 0 .and. nQTD == 0 .and. nDES == 0
			Return .T.
		EndIf
	Else
		If nTAR == 0 .And. nTIP == 0 .AND. nCOD == 0 .and. nQTR == 0 .and. nQTD == 0 .and. nDES == 0
			Return .T.
		EndIf
	EndIf

	If Len(aColsUse) == 1
		If !aColsUse[1][Len(aColsUse[1])]
			cCOD := aColsUse[1][nCOD]
			cTIP := aColsUse[1][nTIP]
			cQTR := aColsUse[1][nQTR]
			cQTD := aColsUse[1][nQTD]
			cDES := aColsUse[1][nDES]
			cUND := aColsUse[1][nUND]
			cLOC := aColsUse[1][nLOC]
			cTAR := If(nTAR > 0,aColsUse[1][nTAR],Space(Len(STL->TL_TAREFA)))
			If Empty(cTAR) .And. Empty(cCOD) .And. Empty(cTIP) .And. Empty(cQTR);
					.And. Empty(cQTD) .And. Empty(cDES) .And. Empty(cUND)
				Return .T.
			EndIf
		EndIf
	EndIf

	For i := 1 To Len(aColsUse)

		If !aColsUse[i][Len(aColsUse[i])]

			cCOD := aColsUse[I][nCOD]
			cTIP := aColsUse[I][nTIP]
			cQTR := aColsUse[I][nQTR]
			cQTD := aColsUse[I][nQTD]
			cDES := aColsUse[I][nDES]
			cUND := aColsUse[I][nUND]
			cLOC := aColsUse[I][nLOC]
			cUSC := aColsUse[I][nUSC]
			cDTI := aColsUse[I][nDTI]
			cHOI := IIf( Empty( aColsUse[I][nHOI] ) .And. aColsUse[I][nTIP] == 'M', SubStr( Time(), 1, 5), aColsUse[I][nHOI] )
			cTAR := If(nTAR > 0,aColsUse[I][nTAR],Space(Len(STL->TL_TAREFA)))

			lRet := NG420CHKLIN( I, .F., aColsUse )

			If !lRet
				Exit
			EndIf

		EndIf

		If lEmpenho .And. aColsUse[I][nTIP] == "P"
	    	If ( nPosArr := aScan( aProdEmp, {|x| x[1] + x[2] == aColsUse[I][nCOD] + aColsUse[I][nLOC] } ) ) == 0
	    		aAdd( aProdEmp, { aColsUse[I][nCOD], aColsUse[I][nLOC], 0 } )
	    		nPosArr := Len( aProdEmp )
	    	EndIf

	   		If !aColsUse[i][Len(aColsUse[i])]
				aProdEmp[nPosArr][3] += aColsUse[I][nQTD]
			EndIf
		EndIf

	Next

	If lRet .And. lEmpenho
		MNT420IND4( M->TJ_ORDEM, M->TJ_PLANO, aHeader, aColsUse, @aProdEmp )

		If !Empty(aProdEmp)
			lRet := MNT420VSD4( M->TJ_ORDEM, aProdEmp )
		EndIf
	EndIf

	RestArea( aArea )

Return lRet

//----------------------------------------------------------------------------
/*/{Protheus.doc} NG420CHKLIN
Consiste a GETDADOS.
@type function

@author Inácio Luiz Kolling
@since 15/04/2004

@sample NG420CHKLIN( 1 )

@param  nVLIN      , Numérico, Número da linha da getdados que será validada.
@param  [lVdlLinha], Lógico  , Se realiza validação da linha.
@param  [aColsChk] , Array   , aCols para validação.
@return lRETCHK    , Lógico  , Se a linha foi validada com sucesso.
/*/
//----------------------------------------------------------------------------
Function NG420CHKLIN( nVLIN, lVdlLinha, aColsChk )

	Local lRETCHK     := .T.
	Local lVerHrCal   := .T.
	Local vDatsMdo    := {}
	Local cCodCal	  := ''
	Local nTarSTL     := 0

	Private nVLINPE	  := nVLIN // nao retirar,usado no P.E. MNTA420K
	Private lChkPR	  := GetNewPar( 'MV_NGCOQPR', 'N' ) == 'S' //checa qtd pecas de reposicao
	Private lUsaTarG  := NGUsaTarPad()

	Default lVdlLinha := .T.
	Default aColsChk  := aCols

	If !Positivo(cQTD)
		Return .F.
	EndIf

	If Empty(cTIP) .Or. Empty(cCOD) .Or. (lUSATARG .And. Empty(cTAR))
		Help(" ",1,"NGPROBINSU")
		lRETCHK := .F.
	EndIf

	If lRETCHK
		M->TL_TIPOREG := cTIP
		M->TL_CODIGO  := cCOD
		M->TL_QUANTID := cQTD
		M->TL_USACALE := cUSC
		M->TL_DTINICI := cDTI
		M->TL_HOINICI := cHOI
		M->TL_UNIDADE := cUND
		M->TL_TAREFA  := If(!Empty(cTAR),cTAR,"0     ")

		If cTIP <> 'P'
			aColsChk[nVLIN,nUND] := 'H' + Space( Len( aColsChk[nVLIN,nUND] )-1 )

			If Empty(cQTD)
				Help(" ",1,"NGATENCAO",,STR0067,3,1) //"Campo quantidade obrigatorio."
				lRETCHK := .F.
			EndIf

			If cTIP == "M" .And.  cUSC == "S"  .And. lRETCHK
				If Empty(cDTI) .Or. Empty(cHOI)
					Help(" ",1,"NGATENCAO",,STR0068+" "+Alltrim(Str(nVLIN,3))+".",3,1)  //"Data/Hora obrigatorio quando o campo Usa calend. = 'S'. Item"
					lRETCHK := .F.
				EndIf

				If lVerHrCal .And. lRETCHK //Se os campos Data/Hora Início estiverem preenchidos
					
					If lHasFlut //Verificar turno flutuante
						cCodCal := MNTCALFLU( cCOD,cDTI,cDTI )
						If Empty( cCodCal ) //Se o funcionário não estiver relacionado à uma equipe de manutenção
							cCodCal := NGSEEK( "ST1",Substr( cCOD,1,6),1,"T1_TURNO" )
						EndIf
					Else
						cCodCal := NGSEEK( "ST1",Substr( cCOD,1,6),1,"T1_TURNO" )
					EndIf

					If !NGVALHRCALE( cCodCal,cDTI,cHOI,"I" ) //Consistência da hora do calendário
						lRETCHK := .F.
						Return .F.
					EndIf
				EndIf

				If lRETCHK
					M->TL_TIPOREG := cTIP
					M->TL_USACALE := cUSC
					M->TL_CODIGO  := cCOD
					M->TL_DTINICI := cDTI
					M->TL_HOINICI := cHOI

					If !NGSTLHORIN( nVLIN, aColsChk )
						lRETCHK := .F.
					EndIf
				EndIf
			EndIf

			If lRETCHK
				lRETCHK := NGQUANTCHK(M->TL_TIPOREG,M->TL_UNIDADE,M->TL_QUANTID)
			EndIf

			If cTIP == "M" .And. lRETCHK

				vDatsMdo := M420RETDAT(cCOD,If(cUSC == "S",cDTI,dINI),If(cUSC == "S",cHOI,hINI),cQTD,cUSC)

				//Verifica Afastamentos da mao de obra
				If !NGFRHAFAST(cCOD,vDatsMdo[1],vDatsMdo[3],.T.)
					lRETCHK := .F.
				EndIf

				//Verifica bloqueios da mao de obra
				If lRETCHK
					If !NG420VBLOF(cUSC,cCOD,cDTI,cHOI,cQTD,nVLIN,If(!Empty(cTAR),cTAR,"0     "))
						lRETCHK := .F.
					EndIf
				EndIf
			ElseIf cTIP == "E" .And. lRETCHK .and. !Empty(cQTR)
				//Verifica bloqueios da especialidade
				If lVdlLinha //Somente no LinOK
					If !NGTTYBLOQ( cCOD, cDTI, cHOI, cQTD, cQTR, nVLIN, M->TJ_ORDEM, 1, M->TJ_PLANO )
						lRETCHK := .F.
					EndIf
				EndIf
			EndIf
		Else
			If Empty(cQTD) .Or. Empty(cUND)
				Help(" ",1,"NGPROBINSU")
				lRETCHK := .F.
			EndIf
			If lRETCHK
				If cTIP == "P"
					If Empty(cDES)
						Help(" ",1,"DESTINO")
						lRETCHK := .F.
					EndIf
					If lRETCHK .and. cUsaIntEs == "S"  //INTEGRACAO COM ESTOQUE
						If !NGEMPALM(cLOC,nVLIN)
							lRETCHK := .F.
						Else
							If !NGPROALM(cCOD,cLOC,nVLIN)
								lRETCHK := .F.
							EndIf
						EndIf
					EndIf
					If lRETCHK .And. lChkPR		//checa qtd de pecas de reposicao do bem
						lRETCHK := NGCHKLIMP(If(cPrograma=="MNTA295",cBEMSOLI,M->TJ_CODBEM),M->TL_CODIGO,M->TL_QUANTID)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	If lRETCHK
		If cTIP $ "F/E" .and. Empty(cQTR)
			Help(" ",1,"QUANTIDADE")
			lRETCHK := .F.
		EndIf
	EndIf

	If lRETCHK
		If lUSATARG
			nTARL := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TAREFA"})
			If nTARL > 0
				If !Atail(oGet:aCOLS[oGet:nAt])
					If Empty(oGet:aCOLS[oGet:nAt,nTARL])
						MsgInfo(STR0106+" "+STR0109,STR0047)
						lRETCHK := .F.
					Endif
				Endif
			EndIf
		EndIf
	EndIf

	If lRETCHK

		/*----------------------+
		| Validação de endereço |
		+----------------------*/
		lRETCHK := MNTA420LOC()

	EndIf

	If lRetChk .And. ( nTarSTL := GDFieldPos( 'TL_TAREFA', aHeaIns ) ) > 0

		/*--------------------+
		| Validação de tarefa |
		+--------------------*/
		lRetChk := MNTA420VTG( aColsChk[nVLin,nTarSTL] )

	EndIf

	If lRETCHK .And. ExistBlock( 'MNTA420K' )

		lRETCHK := ExecBlock( 'MNTA420K', .F., .F., { aColsChk, nVLIN, aHeader } )

	EndIf

Return lRETCHK

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420ALTE ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ ALTERACAO                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG420ALTE(lBloqProd)

	Local lMNTA420U		:= ExistBlock( 'MNTA420U' )
	Local lMNTA420V     := ExistBlock( 'MNTA420V' )
	Local lMntSa		:= .F.
	Local lDelSc		:= .F.
	Local nAlterou  	:= 0
	Local nSCPNum		:= 0
	Local nInd1 		:= 0
	Local nInd2			:= 0
	Local nTamSC2OP		:= 0
	Local nRec          := GDFieldPos( 'TL_REC_WT', aHeaIns )
	Local nPosISA       := 0
	Local nPosNSA       := 0
	Local nPosISC       := 0
	Local nPosNSC       := 0
	Local nPosValid     := 0
	Local nPosGet       := 0
	Local aSCPNum 		:= {}
	Local lIntRM        := AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
	Local lIntLog  		:= AllTrim( GetNewPar( 'MV_NGINTER', 'N' ) ) == 'L'
	Local cPRODTER		:= AllTrim(GetMV("MV_PRODTER"))
	Local cNGMNTAS		:= SuperGetMv("MV_NGMNTAS",.F.,"2")
	Local lRet 			:= .T.
	Local lC1Unico      := SuperGetMv( 'MV_NGMNTCP', .F., 'N'  ) == 'S'
	Local cOSProd       := Padr( M->TJ_ORDEM + 'OS001', TAMSX3( 'C1_OP' )[1] )
	Local cSC1Num       := ' '

	Default lBloqProd := .T.

	// Verificar se houve alteração nos insumos
	If Len( aGetInSal ) == Len( aGetIns )
		
		For nInd1 := 1 To Len( aGetInSal )

			If ( nPosGet := aScan( aGetIns, { |x| x[nRec] == aGetInSal[nInd1,nRec] } ) ) > 0

				For nInd2 := 1 To Len( aGetInSal[nInd1] )

					If aGetInSal[nInd1,nInd2] != aGetIns[nPosGet,nInd2]

						nAlterou++

						Exit

					EndIf

				Next nInd2

			EndIf

		Next nInd1

		If nAlterou == 0

			Return .T.

		EndIf

	EndIf

	//P.E. que gera ação no processo de gravação de insumos alterados.
	If lMNTA420V
		ExecBlock( 'MNTA420V', .F., .F., { aGetIns, aGetInSal, aHEADER } )
	EndIf

	cUsaIntPc := AllTrim(GetMV("MV_NGMNTPC"))
	cUsaIntCm := AllTrim(GetMV("MV_NGMNTCM"))
	cUsaIntEs := AllTrim(GetMV("MV_NGMNTES"))
	aHEADER   := ACLONE(aHEAINS)

	// aHEAINSAL  -> CONTEM OS CAMPOS DO GETDADOS
	// aGETINSAL  -> CONTEM OS DADOS DO STL ( GRAVADOS ANTEIROMENTE)

	nSET := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_SEQTARE" })
	nTIP := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	nCOD := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	nQTD := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
	nQTR := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_QUANREC" })
	nUND := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_UNIDADE" })
	nDES := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_DESTINO" })
	nTAR := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_TAREFA" })
	nSEE := aSCAN(aHEAETA,{|x| AllTrim(Upper(X[2])) == "TQ_SEQTARE" })
	nLOC := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_LOCAL" })
	nLcz := aScan( aHeader, { |x| AllTrim( Upper( X[2] ) ) == 'TL_LOCALIZ' } )
	nPosISA := aScan( aHeader, { |x| AllTrim( Upper( x[2] ) ) == 'TL_ITEMSA' } )
	nPosNSA := aScan( aHeader, { |x| AllTrim( Upper( x[2] ) ) == 'TL_NUMSA' } )
	nPosISC := aScan( aHeader, { |x| AllTrim( Upper( x[2] ) ) == 'TL_ITEMSC' } )
	nPosNSC := aScan( aHeader, { |x| AllTrim( Upper( x[2] ) ) == 'TL_NUMSC' } )

	//Inicia transação, caso haja problema no XML
	ProcRegua(Len(aGETINS))
	If NGIFDBSEEK("STL",STJ->TJ_ORDEM+STJ->TJ_PLANO,1,.F.)
		
		While STL->(!EoF()) .And. STL->TL_FILIAL = xFilial("STL") .And.;
				STL->TL_ORDEM = STJ->TJ_ORDEM .And. STL->TL_PLANO = STJ->TJ_PLANO

			If STL->TL_SEQRELA = "0  "
				If STJ->TJ_SITUACA = "L"
					
					If STL->TL_TIPOREG = "P" .Or. STL->TL_TIPOREG = "T"

						lMntSa := NG420CHKSA( STL->TL_TIPOREG )

						cCodPSC1 := STL->TL_CODIGO
						If STL->TL_TIPOREG = "T"
							//Ira verificar apenas o primeiro Produto Terceiro do parametro
							cCodPTer := If(FindFunction("NGProdMNT"), NGProdMNT("T")[1], cPRODTER)
							cCodPSC1 := cCodPTer+Space(Len(sb1->b1_cod)-Len(cCodPTer))
						EndIf

						If !lMntSa //Nao gera S.A.

							//Ponto de Entrada para validar exclusão de uma Solicitação de Compra.
							If lMNTA420U
						
								lDelSc := ExecBlock("MNTA420U",.F.,.F.,{xFilial('SC1'),STJ->TJ_ORDEM,'OS001',cCodPSC1})

							EndIf
								
							If STL->TL_TIPOREG == 'P' .And. NGIFDBSEEK( 'SD4', STL->TL_CODIGO + cOSProd, 1 ) .And. ( aScan( aGetIns, { |x| x[nTIP] == STL->TL_TIPOREG .And.;
								x[nCOD] == STL->TL_CODIGO .And. x[nLoc] == STL->TL_LOCAL .And. !x[Len( aGetIns[1] )] .And. IIf( !Empty( nLcz ), x[nLcz] == STL->TL_LOCALIZ, .T. ) } ) == 0 .Or. lDelSc )

								If NGIFDBSEEK( 'SD4', STJ->TJ_ORDEM + 'OS001', 2 )

									If lIntLog						

										/*-----------------+
										| Integração LOGIX |
										+-----------------*/
										NGAtuErp( 'SD4', 'DELETE' )

									EndIf

								EndIf
								
								/*----------------------------------------------------+
								| Aciona o ExecAuto MATA381 para exclusão de espenho. |
								+----------------------------------------------------*/
								lRet := MntExecSD4( cOSProd, { { STL->TL_CODIGO, STL->TL_LOCAL } }, 5 )[1]

							EndIf

							If lRet

								//-------------------------------------------
								// Backup da SC1 que será deletada
								//-------------------------------------------
								If lC1Unico .And. Empty( cSC1Num )

									cSC1Num := MntSC1OfOp( cOSProd )[1]

								EndIf

								nPosValid := aScan( aGetIns, { |x| x[nRec] == STL->( RecNo() ) } )

								/*---------------------------------+
								| Deleta a S.C. e relacionamentos. |
								+---------------------------------*/
								If ( aGetIns[nPosValid,Len( aGetIns[1] )] .And.;
									!Empty( aGetIns[nPosValid,nPosNSC] ) ) .Or. lDelSc

									/*--------------------------------------------------------------------+
									| Chamada do ExecAuto MATA110 para Deleção da S.C. e relacionamentos. |
									+--------------------------------------------------------------------*/
									If !( lRet := MntExecSC1( aGetIns[nPosValid,nPosNSC], aGetIns[nPosValid,nPosISC], , 5 )[1] )

										Exit

									EndIf

									/*------------------------------------+
									| Deleta O.P. e seus relacionamentos. |
									+------------------------------------*/
									GERAOPNEW( cCodPSC1, STL->TL_QUANTID, STJ->TJ_ORDEM, , , , , , , 5 )

								EndIf

							EndIf

						ElseIf NG420CHKSA( STL->TL_TIPOREG )

							If fVldDelSA( aGetIns, aHeaIns ) .And. NGIFDBSEEK( 'SCP', STL->TL_NUMSA + STL->TL_ITEMSA, 1, .F. ) .And.;
								SCP->CP_QUJE <= 0 .And. SCP->CP_PREREQU != 'S'

								If lIntRM

									If NGMUTRAREQ( 'SCP', SCP->CP_NUM, FWxFilial("SCP"), .F., SCP->CP_ITEM,;
										SCP->CP_QUANT, SCP->CP_LOCAL )

										If cNGMNTAS == "1"

											aAdd( aSCPNum, { SCP->CP_NUM, SCP->CP_ITEM } )

										Else

											If NGMUReques( SCP->( RecNo() ), 'SCP', .F., 5, , , SCP->CP_ITEM )

												If !( lRet := MntExecSCP( SCP->CP_NUM, SCP->CP_ITEM, , 5 )[1] )

													Exit

												EndIf

											EndIf

										EndIf

									EndIf

								Else

									If !( lRet := MntExecSCP( SCP->CP_NUM, SCP->CP_ITEM, , 5 )[1] )

										Exit

									EndIf

								EndIf

							EndIf

						EndIf

					EndIf

					//Deleta os bloqueios de Ferramentas
					If lRet .And. STL->TL_TIPOREG == 'F'
						If NGIFDBSEEK("SH9","F"+SubStr(STL->TL_CODIGO,1,Len(SH9->H9_FERRAM))+DtoS(STL->TL_DTINICI)+STL->TL_HOINICI,3)
							RecLock("SH9",.F.,.T.)
							dbDelete()
							SH9->(MsUnLock())
						EndIf
					EndIf

				EndIf

			EndIf

			If !lRet
				Exit
			EndIf

			STL->(dbSkip())

		End While

		If lRet

			For nSCPNum := 1 To Len( aSCPNum )

				If NGIFDBSEEK( 'SCP', aSCPNum[nSCPNum,1] + aSCPNUM[nSCPNum,2], 1, .F. )

					If NGMUReques( SCP->( RecNo() ), 'SCP', .F., 5, , aSCPNum, SCP->CP_ITEM )

						If !( lRet := MntExecSCP( SCP->CP_NUM, SCP->CP_ITEM, , 5 )[1] )

							Exit

						EndIf

					EndIf

				EndIf

			Next nSCPNum

			//Delete os Bloqueios de Especialidades
			If NGCADICBASE("TTY_ORDEM","A","TTY",.F.)
				NGIFDBSEEK("TTY",STJ->TJ_ORDEM+STJ->TJ_PLANO,1)
				While !Eof() .And. TTY->(TTY_FILIAL+TTY_ORDEM+TTY_PLANO) == xFILIAL("TTY")+STJ->TJ_ORDEM+STJ->TJ_PLANO
					RecLock("TTY",.F.,.T.)
					dbDelete()
					TTY->(MsUnLock())
					dbSkip()
				End While
			EndIf

			//Delete os Bloqueios de Funcionarios
			NGIFDBSEEK("STK",STJ->TJ_ORDEM+STJ->TJ_PLANO,1)
			While !Eof() .And. STK->(TK_FILIAL+TK_ORDEM+TK_PLANO) == xFilial("STK")+STJ->TJ_ORDEM+STJ->TJ_PLANO
				RecLock("STK",.F.)
				dbDelete()
				STK->(MsUnlock())
				dbSkip()
			End While

			//Deleta todos os Problemas antes de refazer os bloqueios de bens e insumos
			NGIFDBSEEK("STA",STJ->TJ_ORDEM+STJ->TJ_PLANO,1)
			While !Eof() .And. STA->TA_FILIAL+STA->TA_ORDEM+STA->TA_PLANO == xFilial("STA")+STJ->TJ_ORDEM+STJ->TJ_PLANO
				RecLock("STA",.F.,.T.)
				dbDelete()
				STA->(MsUnLock())
				dbSkip()
			End While

		EndIf

	EndIf
	
	If lRet .And. Len(aGETINS) > 0

		nPOSINS := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
		nPOSCOD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
		nPOSQTD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID"})
		nPOSREC := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANREC"})
		nUNIDAD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_UNIDADE"})
		cOP		:= M->TJ_ORDEM + "OS001"
		cOP := Alltrim(cOP)+Space(Len(SC1->C1_OP) - Len(Alltrim(cOP)))
		If GETMV("MV_NGCORPR") == "S" .and. nPOSINS > 0 .and. ;
				nPOSCOD > 0 .and. nPOSQTD > 0 .and. nPOSREC > 0
			aBLO := { {},{},{},{},{}}
			Processa({ |lEnd| MNTA420IN() },STR0034) // "Aguarde ..Preparando Para Gerar Insumos..." )
		EndIf

		// Efetua a geração de insumos
		Processa({ |lEnd| NG420ATINS() },STR0032) // "Aguarde ..Gravando os Insumos.."

		//-------------------------------------------------------------
		// Efetua o bloqueio de Ferramentas
		//-------------------------------------------------------------
		Processa({ |lEnd| MNTA420FE() },STR0035) // "Aguarde ..Bloqueando Ferramentas..." )

		//-------------------------------------------------------------
		// Efetua o bloqueio de Mao de Obras (FUNCIONARIO)
		//-------------------------------------------------------------
		Processa({ |lEnd| MNTA420FU() },STR0036) // "Aguarde ..Bloqueando Mao-de-Obra..." )

		//-------------------------------------------------------------
		// Efetua o bloqueio de Especialistas (FUNCIONARIO)
		//-------------------------------------------------------------
		Processa({ |lEnd| MNTA420ES() },STR0037) // "Aguarde ..Bloqueando Especialidade.." )

		nTamSC2OP := ( TAMSX3("C2_NUM")[1] + TAMSX3("C2_ITEM")[1] + TAMSX3("C2_SEQUEN")[1] )
		NGIFDBSEEK("SC2",SubStr(cOP,1,nTamSC2OP),1)
		If lBloqProd

			//-------------------------------------------------------------
			// Efetua o bloqueio de Produtos
			//-------------------------------------------------------------
			Processa({ |lEnd| lRet := MNTA420PR( 4, cSC1Num ) },STR0038) // "Aguarde ..Bloqueando Produto e Integra‡Æo.." )

			//-------------------------------------------------------------
			// Efetua o bloqueio de Terceiros
			//-------------------------------------------------------------
			If lRet
				Processa({ |lEnd| lRet := MNTA420TE() },STR0039) // "Aguarde ..Bloqueando Terceiros.." )
			EndIf

		EndIf
	EndIf
	
	MsUnlockAll() //Destrava todos os registros que estavam eventualmente locados

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} NG420DELI
Verifica se Ha pedido de compra para o item a ser deletado
@author  Inacio Luiz Kolling
@since   06/08/2001
@version P12
@param  aColsUse - Objeto da GetDados     - Não obrigatório
		nLinAtu  - Linha Atua da GetDados - Não obrigatório

/*/
//-------------------------------------------------------------------
Function NG420DELI(aColsUse,nLinAtu)

	Local aAreaAtu	:= GetArea()
	Local nTIPOREG	:= aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TIPOREG" })
	Local nCODIGO	:= aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_CODIGO" })
	Local nTAR		:= aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TAREFA" })
	Local nPosNum	:= aSCAN( aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_NUMSA"})
	Local nPosItem 	:= aSCAN( aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_ITEMSA"})
	Local lRETORDE 	:= .T.

	Default aColsUse := aCols
	Default nLinAtu  := N

	//Valida apenas se for deletar a linha
	If !Atail(aColsUse[N]) .And. nPosNum > 0 .And. nPosItem > 0
		lRETORDE := MNT420BSA(aColsUse[N][nPosNum], aColsUse[N][nPosItem] )
	EndIf

	lUSATARG := NGUSATARPAD()

	If !aColsUse[N][Len(aColsUse[1])] .And. lRETORDE
		lRETORDE := NGCOTAPEDI(M->TJ_ORDEM,M->TJ_PLANO,If(lUSATARG .And. nTAR > 0,aColsUse[N][nTAR],M->TL_TAREFA),;
			aColsUse[N][nTIPOREG],aColsUse[N][nCODIGO],"0",Len(aGETINSAL),n,If(READVAR() = "M->TL_QUANTID",.F.,.T.))
		If lRETORDE
			If ExistBlock("NGTERMOU")
				cCUSTOSZC := ST9->T9_CCUSTO
				cCODSZC   := aCols[n][nCODIGO]
				lRETORDE  := ExecBlock('NGTERMOU',.F.,.F.)
			EndIf
		EndIf
	Endif

	If lRETORDE .And. ExistBlock( 'MNTA4200' )

		lRETORDE := ExecBlock( 'MNTA4200', .F., .F., { aColsUse, nLinAtu, aHeader } )

	EndIf

	RestArea(aAreaAtu)

Return lRETORDE

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGCHKBEMLOC³ Autor ³ Inacio Luiz Kolling   ³ Data ³17/02/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Consistencia do bem/localizacao                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGCHKBEMLOC(cTIPOS)

	Local cMENSAT	:= Space(10)
	Local aT9Area	:= ST9->(GetArea())
	Local lRet		:= .T.
	Local lOtherEmp := .F.
	Local cOldFil	:= cFilAnt
	Local cFILBEM
	Local cEmpBem
	Local nTamTAF   := FWTamSX3( 'TAF_CODNIV' )[1]
	
	lUsouF7 := If( Type( "lUsouF7" ) <> "U", lUsouF7, .F. )

	If cTIPOS == 'L'

		nORDTAF := 7
		cCODBEM := 'X2' + SubStr( M->TJ_CODBEM, 1, nTamTAF )
		cMENSAT := STR0044

		dbSelectArea( 'TAF' )
		dbSetOrder( nORDTAF )
		If !dbSeek( FWxFILIAL( 'TAF' ) + cCODBEM )
			
			MsgInfo( STR0045 + cMENSAT + STR0046, STR0047 )
			
			Return .F.

		EndIf

		M->TJ_NOMBEM := If( cTIPOS == 'L', TAF->TAF_NOMNIV, M->TJ_NOMBEM )
		
		NG420VERCON( cCODBEM, cTIPOS )

	Else
		cFILBEM := cFilAnt
		cEmpBem := cEmpAnt

		//Alterado para garantir que os campos reservados (Bloqueado - T9_MSBLQL) sejam avaliados
		If !ExistCpo("ST9",M->TJ_CODBEM)
			If lUsouF7
				If !ExistCpo("SN1",M->TJ_CODBEM) //Valida também o Ativo Fixo relacionado.
					lRet := .F.
				EndIf
			Else
				lRet := .F.
			EndIf
		EndIf

		// Realiza verificação se o bem encontra-se ativo e disponivel para manutenção.
		If lRet .And. !lUsouF7
			lRet := MNTVALBEM( M->TJ_CODBEM )
		EndIf

		//Utilizado para validacao Multiempresa de CC
		cFilAnt := cFilBem
		If lRet .AND. !CTB105CC(ST9->T9_CCUSTO)
			lRet := .F.
		EndIf
		cFilAnt := cOldFil

		If lRet
			//Consistencia do contador
			NG420VERCON(M->TJ_CODBEM,M->TJ_TIPOOS,cFILBEM)
		EndIf

		If lRet .And. !NGIFDBSEEK("SH7",NGSEEK("ST9",M->TJ_CODBEM,1,"T9_CALENDA",),1) .And. !lUsouF7
			Help(" ",1,"NGCALENBEM",,CHR(13) + OemToAnsi(STR0113) + NGSEEK("ST9",M->TJ_CODBEM,1,"T9_CALENDA") ,3,0)  //"Calendário: "
			lRet := .F.
		EndIf

		If lRet .And. !lOtherEmp
			M->TJ_TIPOOS  := "B"
			If lUsouF7

				cNomeBem := NGSEEK("SN1",M->TJ_CODBEM,1,"SN1->N1_DESCRIC")

				If Empty(cNomeBem)
					cNomeBem := NGSEEK("ST9",M->TJ_CODBEM,1,"ST9->T9_NOME")
				EndIf
			Else
				cNomeBem := NGSEEK("ST9",M->TJ_CODBEM,1,"ST9->T9_NOME")
			EndIf
			M->TJ_NOMBEM  := cNomeBem
		EndIf

	Endif

	If ExistBlock("MNTA420H")
		If !ExecBlock("MNTA420H",.F.,.F.)
			Return .F.
		EndIf
	EndIf

	RestArea(aT9Area)

Return lRet

//----------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} NGRELABEMLOC
Consistencia da relacao do tj_nombem
@type function

@author Inacio Luiz Kolling
@since 17/02/2004

@sample NGRELABEMLOC( 'B', '001' )

@param  cTipOS  , Caracter, Informa o tipo de OS, se corrensponde a BEM ou LOCALIZAÇÃO.
@param  cCodBemLoc , Caracter, Informa o código do Bem/Localização.
@return cNoBemTJ, Caracter, Descrição do bem ou localização.

@todo Ajustar o nome da função e suas chamadas em dícionario, a mesma possui mais caracteres que o permitido.
/*/
//----------------------------------------------------------------------------------------------------------
Function NGRELABEMLOC( cTipOS, cCodBemLoc )

	Local cNoBemTJ     := Space( 30 )

	Default cCodBemLoc := M->TJ_CODBEM

	If !Empty( cCodBemLoc )
		
		If cTipOS == 'B'
			
			dbSelectArea( 'ST9' )
			dbSetOrder( 1 ) //T9_FILIAL + T9_CODBEM
			
			If MsSeek( FwxFilial( 'ST9' ) + cCodBemLoc )
				cNoBemTJ := ST9->T9_NOME
			EndIf
		
		ElseIf cTipOS == 'L'
			
			dbSelectArea( 'TAF' )
			dbSetOrder( 7 ) //TAF_FILIAL + TAF_MODMNT + TAF_INDCON + TAF_CODNIV
			If msSeek( FWxFilial( 'TAF' ) + 'X2' + SubStr( cCodBemLoc, 1, FWTamSX3( 'TAF_CODNIV' )[1] ) )
				cNoBemTJ := TAF->TAF_NOMNIV
			EndIf
			
		EndIf

	EndIf

Return cNoBemTJ

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGINIBEMLOC ³ Autor ³ Inacio Luiz Kolling   ³ Data ³17/02/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Consistencia do inibe browse do tj_nombem                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGINIBEMLOC(cTIPOS)

	Local aAreaTAF := TAF->( FWGetArea() )
	Local aAreaST9 := ST9->( FWGetArea() )
	Local aAreaSTJ := STJ->( FWGetArea() )
	Local cNOBEMTJ := Space(30)
	Local cFilSTJ
	Local nTamTAF  := FWTamSX3( 'TAF_CODNIV' )[1]

	If cTIPOS == 'B'

		If NGSX2MODO("STJ") = "E" .And. NGSX2MODO("ST9") = "E"
			cFilSTJ := STJ->TJ_FILIAL
		EndIf

		cNOBEMTJ := NGSEEK("ST9",STJ->TJ_CODBEM,1,"T9_NOME",cFilSTJ)
		
	ElseIf cTIPOS == 'L'

		dbSelectArea( 'TAF' )
		dbSetOrder( 7 )
		If msSeek( FWxFilial( 'TAF' ) + 'X2' + SubStr( STJ->TJ_CODBEM, 1, nTamTAF ) )

			cNOBEMTJ := TAF->TAF_NOMNIV
		
		EndIf

	EndIf

	FWRestArea( aAreaTAF )
	FWRestArea( aAreaST9 )
	FWRestArea( aAreaSTJ )

	FWFreeArray( aAreaTAF )
	FWFreeArray( aAreaST9 )
	FWFreeArray( aAreaSTJ )

Return cNOBEMTJ

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420VERCON ³ Autor ³ Inacio Luiz Kolling   ³ Data ³17/02/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Consistencia do contador                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NG420VERCON(cVCODBEM,cVTPOS,cFILBEM)

Store .F. To TIPOACOM,TIPOACOM2

Default cFILBEM := cFilAnt

If cVTPOS = "B" .Or. cVTPOS = "M"
	dbSelectArea("ST9")
	dbSetOrder(1)
	If dbSeek(xFILIAL("ST9",cFILBEM)+cVCODBEM)
		TIPOACOM := If(st9->t9_temcont = "S" ,.T.,.F.)

		If ExistBlock("MNTA420B")
			ExecBlock("MNTA420B",.F.,.F.)
		Else
			M->TJ_POSCONT := If(st9->t9_temcont = "S",M->TJ_POSCONT,0)
			M->TJ_HORACO1 := If(st9->t9_temcont = "S",M->TJ_HORACO1,"  :  ")
		EndIf

	EndIf

	//FindFunction remover na release GetRPORelease() >= '12.1.027'
	If FindFunction("MNTCont2")
		TIPOACOM2 := MNTCont2(cFILBEM, cVCODBEM)
	Else
		dbSelectArea("TPE")
		dbSetOrder(1)
		If dbSeek(xFILIAL("TPE",cFILBEM)+cVCODBEM)
			TIPOACOM2 := .T.
		EndIf
	EndIf

	If !TIPOACOM2
		M->TJ_POSCON2 := 0
		M->TJ_HORACO2 := "  :  "
	EndIf

Else
	Store "  :  " To M->TJ_HORACO1,M->TJ_HORACO2
	Store 0       To M->TJ_POSCONT,M->TJ_POSCON2
EndIf

lREFRESH := .T.

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNTA420IM ³ Autor ³Inacio Luiz Kolling    ³ Data ³17/08/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Impressao da ordem de servico                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA420IM()

aEval(aInd420,{|x| Ferase(x[1]+OrdBagExt())})

dbSelectArea("STJ")
dbSetOrder(1)

NGIMP675(stj->tj_ordem,stj->tj_plano,.F.,,STJ->(RECNO()))

dbSelectArea("STJ")

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} NG420QUANT
Consistencia da quantidade de insumo
@author  Inacio Luiz Kolling
@since   04/08/2005
@version P12
@param  cVTIPREG - Tipo do Insumo         - Obrigatório
		nQTDIN   - Quantidade do Insumo   - Obrigatório
		aColsUse - Objeto da GetDados     - Não obrigatório
		nLinAtu  - Linha Atua da GetDados - Não obrigatório

/*/
//-------------------------------------------------------------------
Function NG420QUANT(cVTIPREG,nQTDIN,aColsUse,nLinAtu)

	Local lRet       := .T.

	Default aColsUse := aCols
	Default nLinAtu  := n

	If cVTIPREG $ 'P/T'
		
		lRet := MNT420BSA()
		
	Else

		lRet := NGVALQUANT(cVTIPREG,"H",nQTDIN)
	
	EndIf

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNTA420RO ³ Autor ³Inacio Luiz Kolling    ³ Data ³27/09/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Consistencia e chamada do rodados                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA420RO()

Local cMenSOS := Space(1),lSerCan := .F.
Local cSerMov := Space(Len(stj->tj_servico)), cSerRod := cSerMov,cSerCan := cSerRod
Local lOpen232 := .F.
Local lPERodds := .F. //Variável utilizada no ponto de entrada MNTA420N.

If STJ->TJ_SITUACA = "P"
   cMenSOS := STR0055
EndIf

If Empty(cMenSOS)
	cSerMov := GetNewPar('MV_NGSERPN',Space(Len(STJ->TJ_SERVICO)))
	cSerRod := GetNewPar('MV_NGRODIZ',Space(Len(STJ->TJ_SERVICO)))
	cSerCan := GetNewPar('MV_NGSERCA',Space(Len(STJ->TJ_SERVICO)))
	lSerCan := If(!Empty(cSerCan),.T.,.F.)

	If Empty(cSerMov) .Or. Empty(cSerRod)
		If Empty(cSerMov) .And. Empty(cSerRod)
			cMenSOS := STR0056+" MV_NGSERPN "+STR0057+" MV_NGRODIZ "+STR0058
		ElseIf Empty(cSerMov)
			cMenSOS := STR0056+" MV_NGSERPN "+STR0058
		ElseIf Empty(cSerRod)
			cMenSOS := STR0056+" MV_NGRODIZ "+STR0058
		EndIf
	EndIf

	If Empty(SuperGetMv("MV_NGSTEST",.F.," "))
		cMenSOS := STR0056+" MV_NGSTEST "+STR0058
	EndIf
EndIf

If Empty(cMenSOS)
	If Alltrim(STJ->TJ_SERVICO) = cSerMov .Or. Alltrim(STJ->TJ_SERVICO) = cSerRod .Or.;
			(lSerCan .And. Alltrim(STJ->TJ_SERVICO) = cSerCan)
	Else
		cMenSOS := STR0059
	EndIf
EndIf

If !Empty(cMenSOS)
	MsgInfo(cMenSOS,STR0047)
	Return
EndIf

If !NGTIPSER(cSerMov,"C")
	Return .F.
EndIf

If !NGTIPSER(cSerRod,"C")
	Return .F.
EndIf

If lSerCan .And. stj->tj_servico = cSerCan
	If !NGTIPSER(cSerCan,"C")
		Return .F.
	EndIf
	cMenSOS := " "
	cParFr := SuperGetMv("MV_NGSTACA",.F.," ")
	If cParFr = Nil .Or. Empty(cParFr)
		cMenSOS := STR0104+" (MV_NGSTACA)"+Chr(13)+STR0058+" (SX6)"
	EndIf
	If Empty(cMenSOS)
		If !NGIFDBSEEK("TQY",SubStr(cParFr,1,2),1,.F.)
			cMenSOS := STR0105+" (MV_NGSTACA) "+Chr(13)+STR0058
		EndIf
	EndIf

	If !Empty(cMenSOS)
		MsgInfo(cMenSOS,STR0047)
		Return
	EndIf

EndIf

cTipSer := If(STJ->TJ_SERVICO = cSerMov,'M',If(STJ->TJ_SERVICO = cSerRod,'R','C'))

If cTipSer <> 'C'
	cParFr := SuperGetMv("MV_NGSTACA",.F.," ")
	If ValType(cParFr) == "C"
		cStatST9 :=   NGSEEK("ST9",STJ->TJ_CODBEM,1,"ST9->T9_STATUS")
		If !Empty(cStatST9) .And. !Empty(cParFr) .And. Alltrim(cStatST9) == Alltrim(cParFr)
			MsgInfo(STR0101+Chr(13)+Chr(13)+STR0102+Chr(13)+STR0103,STR0047)
			Return .F.
		EndIf
	EndIf
EndIf

If NGCADICBASE("TQ0_CODEST","A","TQ0",.F.)
	dbSelectArea("ST9")
	dbSetOrder(1)
	dbSeek(xFilial("ST9")+STJ->TJ_CODBEM)

	If lRel12133
		lOpen232 := MNTSeekPad( 'TQ0', 1, ST9->T9_CODFAMI, ST9->T9_TIPMOD ) .And. !Empty(TQ0->TQ0_CODEST)
	Else
		lOpen232 := !Empty(NGSEEK("TQ0",ST9->T9_CODFAMI+ST9->T9_TIPMOD,1,"TQ0->TQ0_CODEST"))
	EndIf
EndIf

//---------------------------------------------------------------------------------
// verifica se há pneus na estrutura com status aguardando marcação de fogo
//---------------------------------------------------------------------------------
If FindFunction( 'MNTAGFOGO' ) .And. !Empty( MNTAGFOGO( STJ->TJ_CODBEM ) )
	Return .F.
EndIf

If NGIFDBSEEK("ST9",STJ->TJ_CODBEM,1,.F.) .And. ST9->T9_TEMCONT <> "S"
	cParFr := SuperGetMv("MV_NGRODSC",.F.," ")
	If ValType(cParFr) == "C" .And. cParFr == "N"
		MsgInfo(STR0115+" MV_NGRODSC."+Chr(13)+STR0116+Chr(13)+STR0117+Chr(13)+Chr(13),STR0047)
		Return .F.
	EndIf
EndIf

If ExistBlock( "MNTA420N" ) //Se existe o ponto de entrada MNTA420N.
	lPERodds := ExecBlock( "MNTA420N", .F., .F., lPERodds ) //Executa ponto de entrada que ativa o Esquema de Rodados no modo Gráfico.
EndIf

If lOpen232 .And. If ( lPERodds, .T., MsgYesNo(STR0114,STR0018) ) //"Deseja abrir o Esquema de Rodados no modo Gráfico?"##"Atenção"
	MNTA232(STJ->TJ_ORDEM,STJ->TJ_PLANO,cTipSer)
Else
	MNTA231(STJ->TJ_ORDEM,STJ->TJ_PLANO,cTipSer)
EndIf

dbSelectArea("STJ")

//Remove O.S. da arvore lógica
If IsInCallStack('MNTA902')
	dbSetOrder(1)
	dbSeek(xFilial("STJ")+AllTrim((cTRBSGA)->CODTIPO))
	If STJ->TJ_TERMINO <> "N" .Or. STJ->TJ_SITUACA <> "L"

		cNivSup  := (cTRBSGA)->NIVSUP
		oTree:TreeSeek(AllTrim((cTRBSGA)->CODPRO)+AllTrim((cTRBSGA)->CARGO)+cFilAnt)
		oTree:DelItem()
		RecLock((cTRBSGA),.F.)
		dbDelete()
		(cTRBSGA)->(MsUnlock())
		oTree:TreeSeek(AllTrim(cNivSup))
		oTree:Refresh()

	EndIf
EndIf

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNA420CON ³ Autor ³Elisangela Costa       ³ Data ³04/10/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Consulta de Historico das ordens de servico                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NG420INC                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNA420CON(cCODBEM420)

Local cALIASTJ, nORDSTJ
Local cORDEMTJ, cPLANOTJ

dbSelectArea("STJ")

cALIASTJ	:= Alias()
nORDSTJ	:= IndexOrd()
cORDEMTJ	:= M->TJ_ORDEM
cPLANOTJ	:= M->TJ_PLANO

MNA080CON(cCODBEM420)

M->TJ_ORDEM	:= cORDEMTJ
M->TJ_PLANO	:= cPLANOTJ

dbSelectArea(cALIASTJ)

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    MNT420PERP Autor ³Elisangela Costa       ³ Data ³04/10/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Consulta de utilizacao de pecas de reposicao                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NG420INC                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420PERP( cCODBEM420 )

	Local aAreaSTJ := STJ->( FWGetArea() )

	MNT080PERP( cCODBEM420 )

	FWRestArea( aAreaSTJ )

	FWFreeArray( aAreaSTJ )

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNC420ORD ³ Autor ³Elisangela Costa       ³ Data ³04/10/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Consulta de Ordens de Servico                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NG420INC                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNC420ORD(cCODBEM420)

Local cALIASTJ, nORDSTJ
Local aMemory := NGGetMemory("STJ") //Guarda as variaveis de memoria da STJ

dbSelectArea("STJ")
cALIASTJ	:= Alias()
nORDSTJ	:= IndexOrd()

MNC600ORD(cCODBEM420)

nOpca := 0

//Retorna as variaveis de memoria da STJ
NgRestMemory(aMemory)

dbSelectArea(cALIASTJ)

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNC420MAES³ Autor ³Elisangela Costa       ³ Data ³04/10/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Consulta de manutencao da estrutura                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³NG420INC                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNC420MAES(cCODBEM420)

Local aHEOLD  := aCLONE(aHeader)

MNTC090(cCODBEM420)
aHeader:= aCLONE(aHEOLD)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG420HOINI
Valida se a Data/hora esta dentro do calendario da M-D-O
@type function

@author  Elisangela Costa
@since   06/11/06

@sample NG420HOINI( oGet:aCols, oGet:nAt, oGet:aHeader )

@param  [aColsUse], Array   , Acols de Insumos.
@param  [nLinAtu] , Numérico, Linha atual que esta posicionada.
@param  [aHeadUse], Array   , aHeader de insumos
@return .T.
/*/
//---------------------------------------------------------------------
Function NG420HOINI( aColsUse, nLinAtu, aHeadUse )

	Default aColsUse := aCols
	Default nLinAtu  := n
	Default aHeadUse := aHeader

	M->TL_USACALE := GDFieldGet( 'TL_USACALE', nLinAtu, .F., aHeadUse, aColsUse )

	If !NGVALHORA( M->TL_HOINICI, .T., (M->TL_USACALE == 'S') )
		Return .F.
	EndIf

	If !NGSTLHORIN()
			Return .F.
	EndIf

Return .T.

//--------------------------------------------------------------------
/*/{Protheus.doc} NGVDTIN420
Valida o campo data inicio de aplicacao do insumo.
@type function
 
@author Elisangela Costa
@since 06/11/06
@version P10 R4
 
@param [dDataInic], data, Indica qual a data Inicial da O.S.
@return Lógico, valida se a Data é válida
/*/
//--------------------------------------------------------------------

Function NGVDTIN420(dDataInic)

Local dDATA

DEFAULT dDataInic := M->TJ_DTMPINI

dDATA := If(!Empty(dDataInic),dDataInic,M->TJ_DTORIGI)

If M->TL_DTINICI < dDATA
	MSGINFO(STR0069+" "+DTOC(dDATA),STR0047) //"Data de inicio informada e menor do que a data prevista para inicio da OS." #"NAO CONFORMIDADE"
	Return .F.
EndIf

Return .T.

//----------------------------------------------------------------
/*/{Protheus.doc} MNT420ACHO
Altera o valor do campo TL_USACALE/TL_DTINICI/TL_HOINICI

@author Elisangela Costa
@since 06/11/06
@version P11/P12
@param  aColsUse - Objeto da GetDados     - Não obrigatório
		nLinAtu  - Linha Atua da GetDados - Não obrigatório
@return .T.
/*/
//----------------------------------------------------------------
Function MNT420ACHO(aColsUse,nLinAtu)

	Local cVar420	:= ReadVar()
	Local dData		:= CTOD( "  /  /  " )
	Local cHora		:= "  :  "
	Local cCodCal	:= ""
	Local vDTAHOR	:= {}

	Local nCodigo := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO"	})
	Local nUSACAL := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_USACALE"	})
	Local nQuantd := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID"	})
	Local nDATAIN := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI"	})
	Local nHORAIN := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI"	})
	Local ndDTFIM := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_DTFIM"		})
	Local nhHORAF := aSCAN(aHEAINS, {|x| AllTrim(Upper(X[2])) == "TL_HOFIM"		})

	Default aColsUse := aCols
	Default nLinAtu := n

	If cVar420 == "M->TL_TIPOREG" //Campo que esta sendo digitado
		
		If !IsInCallStack( 'NG410INC' ) .And. !NG420DELI()
			Return .F.
		EndIf

		If M->TL_TIPOREG <> "M"
			
			aColsUse[nLinAtu][nUSACAL] := 'N'

			If !FWIsInCallStack( 'MNTA990' ) 

				aColsUse[nLinAtu][nDATAIN] := dData
				aColsUse[nLinAtu][nHORAIN] := cHora

			EndIf

		EndIf

	ElseIf cVar420 == "M->TL_USACALE" //O campo digitado está sendo 'Usa Calendário'.
		If M->TL_USACALE <> "S" // Se o funcionário não utiliza calendário.
			If !IsInCallStack( "MNTA990" ) // Não for executada pelo rotina 'Programação de O.S'
				aColsUse[nLinAtu][nDATAIN] := dData //Limpa Data Início
				aColsUse[nLinAtu][nHORAIN] := cHora //Limpa Hora Início
			ElseIf !Empty( aCols[n][nDATAIN] ) .And. !Empty( aCols[n][nHORAIN] )
				//Calcula a data e hora fim a partir de uma data e hora
				vDTAHOR := NGDTHORFIM( aColsUse[nLinAtu][nDATAIN],aColsUse[nLinAtu][nHORAIN],aColsUse[nLinAtu][nQuantd] )
				aColsUse[nLinAtu][ndDTFIM] := vDTAHOR[1] //Data Fim
				aColsUse[nLinAtu][nhHORAF] := vDTAHOR[2] //Hora Fim
			EndIf
		Else

			// Se for executada pelo rotina 'Programação de O.S' e não for um novo registro.
			If FWIsInCallStack( 'MNTA990' ) .And. !Empty( aColsUse[nLinAtu,nDATAIN] ) .And.;
				!Empty( aColsUse[nLinAtu,nHORAIN] ) .And. !Empty( aColsUse[nLinAtu,nCodigo] )
				
				If lHasFlut //Utiliza turno flutuante

					cCodCal := MNTCALFLU( Substr( aColsUse[nLinAtu][nCodigo],1,6 ),aColsUse[nLinAtu][nDATAIN],aColsUse[nLinAtu][nDATAIN] )
					If Empty( cCodCal ) //Se o funcionário não estiver relacionado à uma equipe de manutenção
						cCodCal := NGSEEK( "ST1",Substr( aColsUse[nLinAtu][nCodigo],1,6 ),1,"T1_TURNO" )
					EndIf

				Else

					cCodCal := NGSeek( 'ST1', SubStr( aColsUse[nLinAtu,nCodigo], 1, 6 ), 1, 'T1_TURNO' )

				EndIf

				If !Empty( cCodCal )

					//Calcula a data e hora fim usando calendário
					vDTAHOR := NGDTHORFCALE( aColsUse[nLinAtu,nDATAIN], aColsUse[nLinAtu,nHORAIN],;
						aColsUse[nLinAtu,nQuantd], cCodCal )

					aColsUse[nLinAtu,ndDTFIM] := vDTAHOR[1] //Data Fim
					aColsUse[nLinAtu,nhHORAF] := vDTAHOR[2] //Hora Fim

				EndIf 

			EndIf

		EndIf

	EndIf

Return .T.

//----------------------------------------------------------------
/*/{Protheus.doc} NG420CALDF
Calcula a data e hora fim do insumo.

@author Elisangela Costa
@since 14/11/06
@version P11/P12
@return .T.
/*/
//----------------------------------------------------------------
Function NG420CALDF()

	Local nD,nQTD,nUND,nTIP,nUSC,nDTI,nHOI,nCOD,nPOS4201
	Local aGRAVCALEN 	:= {}
	Local cCodCal 		:= ""
	Local cNGUNIDT		:= AllTrim(GetMv("MV_NGUNIDT"))

	nCOD := aSCAN(aHeaIns,{|x| Trim(Upper(X[2])) == "TL_CODIGO"  })
	nTIP := aScan(aHeaIns,{|x| Trim(upper(x[2])) == "TL_TIPOREG" })
	nQTD := aScan(aHeaIns,{|x| Trim(upper(x[2])) == "TL_QUANTID" })
	nUND := aScan(aHeaIns,{|x| Trim(upper(x[2])) == "TL_UNIDADE" })
	nUSC := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_USACALE" })
	nDTI := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	nHOI := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_HOINICI" })
	nSQT := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_SEQTARE" })

	If nTIP == 0 .or. nQTD == 0 .or. nUND == 0
	   Return Nil
	EndIf

	aDATINS := {}

	For nD := 1 to Len( aGETINS ) //Percorre os insumos

		If !aGETINS[nD][len(aGETINS[nD])]

			If nSQt > 0
				If Empty(aGETINS[nD][nSQT])
					cSEQTARE := If( FindFunction("Soma1Old"),PADR(Soma1Old(cPxSeq),3),PADR(Soma1(cPxSeq),3 ))

					cPxSeq	 := cSEQTARE
					aGETINS[nD][nSQT] := cPxSeq
				EndIf
			EndIf

			If aGETINS[nD][nTIP] == "P"
				AAdd(aDATINS, {aGETINS[nD][nCOD],dINI, hINI,dINI, hINI,aGETINS[nD][nTIP],If(nSQT > 0,aGETINS[nD][nSQT],"")})
				Loop
			EndIf

			nQUANTINS := aGETINS[nD][nQTD] //Quantidade de horas de insumo

			//Se o tipo de hora for igual a 'Decimal' e o funcionário não utiliza funcionário
			If FunName() <> "MNTA420" //Se não for executado pelo rotina de 'Ordem de Serviço Corretiva'
				If cNGUNIDT == "D" .And. aGETINS[nD][nTIP] $ "E/F/M/T" .And. aGETINS[nD][nUSC] == "N"
					nVALINHOR := Int(aGETINS[nD][nQTD])
					nVALINMIM := (aGETINS[nD][nQTD] - Int(aGETINS[nD][nQTD])) * 0.6
					nQUANTINS := nVALINHOR+nVALINMIM
				EndIf
			EndIf

			If aGETINS[nD][nTIP] == "M" .And. aGETINS[nD][nUSC] ==  "S" //Tipo de registro 'Mão de Obra' e utiliza calendário
				
				If lHasFlut //Utiliza turno flutuante

					cCodCal := MNTCALFLU( Substr( aGETINS[nD][nCOD],1,6 ),aGETINS[nD][nDTI],aGETINS[nD][nDTI] )
					If Empty( cCodCal ) //Se o funcionário não estiver relacionado à um equipe de manutenção
						cCodCal := NGSEEK( "ST1",Substr( aGETINS[nD][nCOD],1,6 ),1,"T1_TURNO" )
					EndIf
				Else
					cCodCal := NGSEEK( "ST1",Substr( aGETINS[nD][nCOD],1,6 ),1,"T1_TURNO" )
				EndIf

				nPOS4201 := Ascan(aGRAVCALEN,{|x| x[1] = cCodCal})
				If nPOS4201 > 0
					aMATCA := aGRAVCALEN[nPOS4201][2]
				Else
					aMATCA := NGCALENDAH(cCodCal)
					AAdd(aGRAVCALEN,{cCodCal,aMATCA})
				EndIf
				//Calcula a data e hora fim usando calendário
				vDTAHOR := NGDTHORFCALE( aGETINS[nD][nDTI],aGETINS[nD][nHOI],nQUANTINS,cCodCal )
				AAdd(aDATINS, {aGETINS[nD][nCOD],aGETINS[nD][nDTI],aGETINS[nD][nHOI],vDTAHOR[1],vDTAHOR[2],aGETINS[nD][nTIP],If(nSQT > 0,aGETINS[nD][nSQT],"")})
			Else
				//Calcula a data e hora fim a partir de uma data e hora
				vDTAHOR := NGDTHORFIM( dINI,hINI,nQUANTINS )
				AAdd( aDATINS,{ aGETINS[nD][nCOD],dINI,hINI,vDTAHOR[1],vDTAHOR[2],aGETINS[nD][nTIP],If(nSQT > 0,aGETINS[nD][nSQT],"") })
	       EndIf

		EndIf
	Next

Return .T.

//------------------------------------------------------------------------------------
/*/{Protheus.doc} NG420VBLOF
Verifica se já existe bloqueio para o funcionário no periodo.
@type function

@author Elisangela Costa
@since 16/11/2006

@sample NG420VBLOF( 'S', 'TRUMP', 28/05/1999, '18:00', 15, 1, '0', '000100', '000000', .F. )

@param  cUSCAL    , Caracter, Indica se considera calendário ou não.
@param  cCODMDO   , Caracter, Código da mão-de-obra.
@param  cDTINIC   , Caracter, Data Inicio de aplicação da mão-de-obra.
@param  cHOINIC   , Caracter, Hora Inicio de aplicação da mão-de obra.
@param  cQTDMDO   , Caracter, Quantidade da mão-de-obra.
@param  nVLITEM   , Númerico, Número da linha.
@param  cTarGe    , Caracter, Código da tarefa genérica.
@param  [cOrder]  , Caracter, Ordem de Serviço.
@param  [cPlan]   , Caracter, Plano de Manutenção.
@param  [lShowMsg], Lógico  , Indica se deve ou não apresentar a mensagem ao usuário.
@return Lógico  , Indica se o processo foi validado com êxito.

@todo função deverá ser descontinuada na realese 12.1.29
/*/
//------------------------------------------------------------------------------------
Function NG420VBLOF(cUSCAL,cCODMDO,cDTINIC,cHOINIC,cQTDMDO,nVLITEM, cTarGe, cOrder, cPlan, lShowMsg )

	Local cCodeMO  := Left( cCODMDO, Len( STK->TK_CODFUNC ) )
	Local lRet     := .T.
	Local vVETFUNC,vVetDatas

	Default cOrder   := M->TJ_ORDEM
	Default cPlan    := M->TJ_PLANO
	Default lShowMsg := .T.

	If FindFunction( 'MntVldBlqM' )

		lRet := MntVldBlqM( cOrder, cPlan, { cTarGe, cCodeMO, cUSCAL, cQTDMDO, cDTINIC, cHOINIC }, nVLITEM, .T. )[1]

	Else

		If GETMV( 'MV_NGCORPR' ) == 'S'

			//Retorna a Data Incicio/Data fim de aplicacoa da mao de obra
			vVetDatas := M420RETDAT( cCODMDO,cDTINIC,cHOINIC,cQTDMDO,cUSCAL )

			dbSelectArea("STK")
			dbSetOrder(1)
			If dbSeek(xFILIAL("STK")+M->TJ_ORDEM+"000000"+cTAR+cCodeMO)
				While !Eof() .And. STK->TK_FILIAL == xFilial("STK") .And. STK->TK_ORDEM == M->TJ_ORDEM .And. STK->TK_PLANO == "000000" ;
						.And. STK->TK_TAREFA == cTAR .And. STK->TK_CODFUNC == cCodeMO
					If DtoS(STK->TK_DATAINI)+STK->TK_HORAINI == DtoS(vVetDatas[1])+vVetDatas[2]
						vVETFUNC := MNT160CKDA(cCodeMO,vVetDatas[1],vVetDatas[2],vVetDatas[3],vVetDatas[4],Recno(),.F.)
						dbSkip()
						Loop
					EndIf
					STK->(dbSkip())
				End
			Else
				vVETFUNC := MNT160CKDA(cCodeMO,vVetDatas[1],vVetDatas[2],vVetDatas[3],vVetDatas[4],,.F.)
			EndIf

			If Empty(vVETFUNC)
				vVETFUNC := MNT160CKDA(cCodeMO,vVetDatas[1],vVetDatas[2],vVetDatas[3],vVetDatas[4],,.F.)
			EndIf

			If !vVETFUNC[1]
				If !MsgYesNo(STR0070+Alltrim(Str(nVLITEM,3))+CHR(13)+; //"Ja existe bloqueio do funcionario no periodo, item "
					STR0071,STR0047) // "Deseja prosseguir mesmo assim ?" # "NAO CONFORMIDADE"
					lRet := .F.
				EndIf
			EndIf

		EndIf

	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³M420RETDAT³ Autor ³ Elisangela Costa      ³ Data ³17/11/06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna a data/hora inicio e fim de aplicacao da mao de obra³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³cCODMDO = Codigo da mao de obra                             ³±±
±±³          ³cDTINIC = Data Inicio de aplicacao da mao de obra           ³±±
±±³          ³cHOINIC = Hora Inicio de aplicacao da mao de obra           ³±±
±±³          ³cQTDMDO = Quantidade da mao de obra                         ³±±
±±³          ³cUSCAL  = Indica se considera calendario ou nao             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function M420RETDAT(cCODMDO,cDTINIC,cHOINIC,cQTDMDO,cUSCAL)

	Local cCodCal := ''
	Local vDTAHOR

	If cUSCAL ==  "S"

		/*-------------------------------------------------------+
		| Pega o calendário quando habilitado o turno flutuante. |
		+-------------------------------------------------------*/
		If lHasFlut
			cCodCal := MNTCALFLU( cCodMDO, cDtInic, cDtInic )
		EndIf
		
		/*-------------------------------------------------------------------------+
		| Se o turno flutuante não estiver habilitado ou o funcionário não estiver |
		| relacionado à uma equipe de manutenção.                                  |
		+-------------------------------------------------------------------------*/
		If Empty( cCodCal )
			cCodCal := NGSEEK( 'ST1', SubStr( cCodMDO, 1, 6 ), 1, 'T1_TURNO' )
		EndIf
		
		aMATCA  := NGCALENDAH(cCODCAL)
		vDTAHOR := NGDTHORFCALE(cDTINIC,cHOINIC,cQTDMDO,cCODCAL)

	Else
		vDTAHOR := NGDTHORFIM(cDTINIC,cHOINIC,cQTDMDO)
	EndIf

Return {cDTINIC,cHOINIC,vDTAHOR[1],vDTAHOR[2]}

//------------------------------------------------------------------------------
/*/{Protheus.doc} NGCHKTMS
Verifica se o veiculo tem viagem escalada.

@author Evaldo Cevinscki Jr.
@since 26/01/2007

@param cVei, Caractere, Codigo do Bem
@param dDtOS, Caractere, Data da OS
@param cHrOS, Caractere, Hora da OS
@param [lShowMsg], Lógico, Define se exibe ou não as mensagens

@return Array, Array contendo a mensagem e falso, ou retorno lógico.
/*/
//------------------------------------------------------------------------------
Function NGCHKTMS(cVei,dDtOS,cHrOS, lShowMsg)

	Local aArea	  := GetArea()
	Local lChkVia := GetNewPar("MV_NGMNTMS","N") == "S"
	Local cVeiTMS := " "
	Local vDtTran := {} // vetor para guardar data e hora que o bem estava em transito
	Local i
	Local aRet := {"", .T., .T.}

	Default lShowMsg := .T.

	lGFrota := MNTA420FR(.T.)

	If lChkVia .And. lGFrota .And. SuperGetMv("MV_NG1VALV",.F.,"2") == "2"

		cVeiTMS := NGSEEK("ST9",cVei,1,"T9_CODTMS")

		dbSelectArea("DTQ") //Para criar as tabelas na base de dados
		dbSelectArea("DTR")
		dbSelectArea("DTW")

		cAliasQry := GetNextAlias()

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Busca se o veiculo se encontra em alguma viagem - tabela DTR: veiculos da viagem. ³
		//³ Verifica o status da viagem - tabela DTQ: viagem.                                 ³
		//³ Encontra as operacoes da viagem com atividade de entrada e saida - tabela DTW.    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := "SELECT "
		cQuery += "DTW.DTW_FILORI, DTQ.DTQ_STATUS, DTW.DTW_VIAGEM, DTW.DTW_SEQUEN, DTW.DTW_STATUS, DTW.DTW_DATREA, DTW.DTW_HORREA, DTW.DTW_ATIVID "
		cQuery += "FROM "+RetSqlName("DTQ")+" DTQ, "
		cQuery += RetSqlName("DTR")+" DTR, "
		cQuery += RetSqlName("DTW")+" DTW "
		cQuery += "WHERE "

		If NGSX2MODO("DTQ") == NGSX2MODO("DTR")
			cQuery += " DTQ.DTQ_FILIAL = DTR.DTR_FILIAL "
		Else
			cQuery += " DTQ.DTQ_FILIAL = '"+xFilial("DTQ")+"' AND DTR.DTR_FILIAL = '"+xFilial("DTR")+"' "
		EndIf

		cQuery += "AND DTQ.DTQ_FILORI = DTR.DTR_FILORI "
		cQuery += "AND DTQ.DTQ_VIAGEM = DTR.DTR_VIAGEM "
		cQuery += "AND (DTQ.DTQ_STATUS <> '3' AND DTQ.DTQ_STATUS <> '9') "
		cQuery += "AND DTR.DTR_CODVEI='"+cVeiTMS+"' "
		cQuery += "AND (DTW.DTW_ATIVID = '"+GetNewPar('MV_ATIVCHG',' ')+"' OR DTW.DTW_ATIVID = '"+GetNewPar('MV_ATIVSAI',' ')+"') AND "

		If NGSX2MODO("DTW") == NGSX2MODO("DTR")
			cQuery += "DTW.DTW_FILIAL = DTR.DTR_FILIAL "
		Else
			cQuery += "DTW.DTW_FILIAL = '"+xFilial("DTW")+"' AND DTR.DTR_FILIAL = '"+xFilial("DTR")+"' "
		EndIf

		cQuery += "AND DTW.DTW_FILORI = DTR.DTR_FILORI "
		cQuery += "AND DTW.DTW_VIAGEM = DTR.DTR_VIAGEM "
		cQuery += "AND DTQ.D_E_L_E_T_ <> '*' AND DTR.D_E_L_E_T_ <> '*' AND DTW.D_E_L_E_T_ <> '*' "
		cQuery += "ORDER BY DTW.DTW_SEQUEN"

		cQuery := ChangeQuery(cQuery)
		dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

		dbSelectArea((cAliasQry))
		dbGoTop()

		While !Eof()
			If (cAliasQry)->DTW_ATIVID == '049' .And. !Empty((cAliasQry)->DTW_DATREA)
				aAdd(vDtTran,{(cAliasQry)->DTW_DATREA,(cAliasQry)->DTW_HORREA,,})
			ElseIf (cAliasQry)->DTW_ATIVID == '050' .And. !Empty((cAliasQry)->DTW_DATREA)
				vDtTran[Len(vDtTran),3] := (cAliasQry)->DTW_DATREA
				vDtTran[Len(vDtTran),4] := (cAliasQry)->DTW_HORREA
			EndIf
			dbSelectArea((cAliasQry))
			dbSkip()
		End

		For i := 1 to Len(vDtTran)
			If Empty(vDtTran[i,3]) .And. !Empty(vDtTran[i,1])
				If vDtTran[i,1]+vDtTran[i,2] < DTOS(M->TJ_DTORIGI)+StrTran(M->TJ_HORACO1,":","")
					If lShowMsg
						MsgInfo(STR0073,STR0047) // "Não é possível efetuar esta operação, pois o veículo está em trânsito"
						Return .F.
					Else
						aRet := {STR0073, .F., .T.}
					EndIf
				EndIf
			ElseIf vDtTran[i,1]+vDtTran[i,2] < DTOS(M->TJ_DTORIGI)+StrTran(M->TJ_HORACO1,":","") .And. ;
					vDtTran[i,3]+vDtTran[i,4] > DTOS(M->TJ_DTORIGI)+StrTran(M->TJ_HORACO1,":","") // verificar se a ordem de serivico esta entre o periodo que o  veiculo estava transito.
				If lShowMsg
					MsgInfo(STR0073,STR0047) // "Não é possível efetuar esta operação, pois o veículo está em trânsito"
					Return .F.
				Else
					aRet := {STR0073, .F., .T.}
				EndIf
			EndIf
		Next i

		dbSelectArea((cAliasQry))
		dbGoTop()

		If !Eof()
			If (cAliasQry)->DTQ_STATUS == '1'
				If lShowMsg
					If !MsgYesNo(STR0074,STR0018) // "Existe viagem programada para esse veículo, confirma inclusão?"
						(cAliasQry)->(dbCloseArea())
						RestArea(aArea)
						Return .F.
					EndIf
				Else
					aRet := {STR0074, .F., .F.}
				EndIf
			ElseIf (cAliasQry)->DTQ_STATUS == '5'
				If lShowMsg
					If !MsgYesNo(STR0074+CHR(13)+STR0100+": "+NGRETSX3BOX("DTQ_STATUS","5"),STR0018)
						(cAliasQry)->(dbCloseArea())
						RestArea(aArea)
						Return .F.
					EndIf
				Else
					aRet := {STR0074 + CHR(13) + STR0100 + ": " + NGRETSX3BOX("DTQ_STATUS","5"), .F., .F.}
				Endif
			ElseIf (cAliasQry)->DTQ_STATUS == '4'
				If lShowMsg
					If !MsgYesNo(STR0074+CHR(13)+CHR(13)+STR0100+": "+NGRETSX3BOX("DTQ_STATUS","4"),STR0018)
						(cAliasQry)->(dbCloseArea())
						RestArea(aArea)
						Return .F.
					EndIf
				Else
					aRet := {STR0074 + CHR(13) + CHR(13) + STR0100 + ": " + NGRETSX3BOX("DTQ_STATUS","4"), .F., .F.}
				Endif
			EndIf
		EndIf

		dbSelectArea((cAliasQry))
		(cAliasQry)->(dbCloseArea())
	EndIf

	RestArea(aArea)

Return IIf(!lShowMsg, aRet, .T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MNT420GAR ³ Autor ³Evaldo Cevinscki Jr.   ³ Data ³26/10/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Inclusao da Garantia para servicos com garantia            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420GAR(nOPCX)

Local cUni		:= " "
Local cCont	:= " "
Local nQtde	:= 0
Local nOPGA2	:= 0
Local nQtdeC	:= 0

aUni		:= {" ",STR0075,STR0076,STR0077}  //"Dia"###"Semana"###"Mes"
aCont		:= {" ",STR0078,STR0079}  //"Contador 1"###"Contador 2"
cLocaliz	:= Space(Len(TPS->TPS_CODLOC))
cNomLoc	:= Space(20)

dbSelectArea("ST4")
If nOPCX == 3
	If ST4->T4_GARANTI == 'S'
		Define Msdialog oDlg1 From  000,000 To 300,570 Title  STR0080 Pixel //"Serviço controlado por Garantia"

			@ 1.5,.5 To 3.5,34 LABEL STR0081 OF oDlg1  //"Localização"

			@ 30,008 Say OemToAnsi(STR0082) Size 47,07 Of oDlg1 Pixel  //"Local"
			@ 30,040 MsGet cLocaliz Size 38,08 Of oDlg1 Pixel Picture '@!' F3 "TPS" Valid NGLOCGAR(cLocaliz) HASBUTTON
			@ 30,100 MsGet oNomLoc Var cNomLoc Of oDlg1 Pixel Picture '@!' When .F. Size 90,08

			@ 4.0,.5 To 6.0,34 LABEL STR0083 OF oDlg1  //"Garantia por Tempo"

			@ 65,008 Say OemToAnsi(STR0084) Size 47,07 Of oDlg1 Pixel  //"Qde"
			@ 65,040 MsGet nQtde Size 38,08 Of oDlg1 Pixel Picture '@E 999,999,999'

			@ 65,100 Say OemToAnsi(STR0085) Size 47,07 Of oDlg1 Pixel  //"Unidade"
			@ 65,132 Combobox cUni Items aUni Size 40,50 OF oDLG1 Pixel Valid NG400CON(cUni,cCont,1,nQtde)

			@ 6.5,.5 To 8.5,34 LABEL STR0086 OF oDlg1  //"Garantia por Contador"

			@ 100,008 Say OemToAnsi(STR0084) Size 47,07 Of oDlg1 Pixel  //"Qde"
			@ 100,040 MsGet nQtdeC Size 38,08 Of oDlg1 Pixel Picture '@E 999,999,999'

			@ 100,100 say OemToAnsi(STR0087) Size 47,07 Of oDlg1 Pixel     //"Tp Contador"
			@ 100,132 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NG400CON(cUni,cCont,2,nQtdeC)

		Activate Msdialog oDlg1 On Init MNT420BAR(oDlg1,{||nOPGA2:=2,If(!MNT420TOKG(nQtde,nQtdeC),nOPGA2:=1,oDlg1:End())},;
					{||nOPGA2:=1,oDlg1:End()}) Centered
	EndIf

	If nOPGA2 == 2
		MNT420GRVGAR(cLocaliz,nQtde,cUni,cCont,nQtdeC)
	EndIf
	MNT420VIOGAR(cLocaliz)
ElseIf nOPCX == 5

	dbSelectArea("TPZ")
	dbSetOrder(2)
	dbSeek(xFilial("TPZ")+STJ->TJ_ORDEM+STJ->TJ_PLANO)
	While !Eof() .And. xFilial("TPZ") == TPZ->TPZ_FILIAL .And. TPZ->TPZ_ORDEM == STJ->TJ_ORDEM .And. TPZ->TPZ_PLANO == STJ->TJ_PLANO
		RecLock("TPZ", .F.)
		dbDelete()
		MsUnlock("TPZ")
		dbSelectArea("TPZ")
		dbSkip()
	End
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MNT420GRVGAR³ Autor ³Evaldo Cevinscki Jr. ³ Data ³26/10/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava a garantia na tabela TPZ                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420GRVGAR(cLocaliz,nQtde,cUni1,cCont,nQtdeC)

Local lIndTPZ	:= If(NgVerify("TPZ"),.T.,.F.)
Local cServ	:= M->TJ_SERVICO+Space(Len(TPZ->TPZ_CODIGO) - Len(M->TJ_SERVICO))
Local cCodBem	:= M->TJ_CODBEM
Local cOrdem	:= M->TJ_ORDEM
Local cPlano	:= M->TJ_PLANO

If cUni1 = STR0075  //"Dia"
	cUni := "D"
ElseIf cUni1 = STR0076 //"Semana"
	cUni := "S"
ElseIf cUni1 = STR0077 //"Mes"
	cUni := "M"
Else
	cUni := " "
EndIf

dbSelectArea("TPZ")
dbSetOrder(1)
dbSeek(xFilial("TPZ")+cCodBem+"S"+cServ+cLocaliz+cOrdem+cPlano)
If !Found()
	RecLock("TPZ",.T.)
	TPZ->TPZ_FILIAL := xFilial("TPZ")
	TPZ->TPZ_CODBEM := M->TJ_CODBEM
	TPZ->TPZ_TIPORE := "S"
	TPZ->TPZ_CODIGO := M->TJ_SERVICO
	TPZ->TPZ_LOCGAR := cLocaliz
	TPZ->TPZ_ORDEM  := M->TJ_ORDEM
	TPZ->TPZ_PLANO  := M->TJ_PLANO
	TPZ->TPZ_DTGARA := M->TJ_DTORIGI
	If lIndTPZ
		TPZ->TPZ_SEQREL := "0"
	EndIf
	TPZ->TPZ_QTDGAR := nQtde
	TPZ->TPZ_UNIGAR := cuni
	If cCont = STR0078 //"Contador 1"
		TPZ->TPZ_CONGAR := "1"
	ElseIf cCont =STR0088 //" Contador 2"
		TPZ->TPZ_CONGAR := "2"
	Else
		TPZ->TPZ_CONGAR := " "
	EndIf
	If NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)
		TPZ->TPZ_QTDCON := nQtdeC
	EndIf
	MsUnlock("TPZ")
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MNT420VIOGAR³ Autor ³Evaldo Cevinscki Jr. ³ Data ³26/10/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se a garantia de servico foi violada              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420VIOGAR(cLocaliz)

Local cServ	:= M->TJ_SERVICO+Space(Len(TPZ->TPZ_CODIGO) - Len(M->TJ_SERVICO))
Local cCodBem	:= M->TJ_CODBEM
Local cOrdem	:= M->TJ_ORDEM
Local cPlano	:= M->TJ_PLANO

dbSelectArea("TPZ")
dbSetOrder(1)
dbSeek(xFilial("TPZ")+cCodBem+"S"+cServ+cLocaliz+cOrdem+cPlano)

nRecTPZ := Recno()
If Found()
	If !Empty(TPZ->TPZ_CONGAR)
		cOrdem1 := TPZ->TPZ_ORDEM
		cPlano1 := TPZ->TPZ_PLANO

		STJ->(dbSetOrder(1))
		STJ->(dbSeek(xFilial("STJ")+cOrdem1+cPlano1))

		nPoscont	:= IIf(TPZ->TPZ_CONGAR=="1",M->TJ_POSCONT,M->TJ_POSCON2)
		nRecno		:= Recno()

		If !Bof()
			dbSkip(-1)
		EndIf

		If Empty(TPZ->TPZ_CONGAR)
			While !Bof() .and. Empty(TPZ->TPZ_CONGAR)
				dbSkip(-1)
			End
		EndIf
		If TPZ->TPZ_CODIGO == cServ .AND. TPZ->TPZ_LOCGAR == cLocaliz
			cOrdem := TPZ->TPZ_ORDEM
			cPlano := TPZ->TPZ_PLANO
			nQuant := If(NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.),TPZ->TPZ_QTDCON,TPZ->TPZ_QTDGAR)

			STJ->(dbSetOrder(1))
			STJ->(dbSeek(xFilial("STJ")+cOrdem+cPlano))

			nPoscont2 := IIf(TPZ->TPZ_CONGAR="1",STJ->TJ_POSCONT,STJ->TJ_POSCON2)
			nSoma := nPoscont2 + nQuant

			If nSoma > nPoscont
				MsgAlert(STR0089+CHR(13)+CHR(13);  //"Serviço refeito no prazo de Garantia"
					+STR0090+AllTrim(Str(nPoscont2))+CHR(13);  //"Contador no inicio do uso    : "
					+STR0091+cOrdem+CHR(13);  //"O.S.                                     : "
					+STR0092+AllTrim(Str(nPoscont))+CHR(13);  //"Contador atual                     : "
					+STR0093+AllTrim(Str(nSoma))) //"Garantia Ate                         : "
			EndIf
		EndIf
	EndIf

	dbGoTo(nRecTPZ)

	cOrdem := TPZ->TPZ_ORDEM
	cPlano := TPZ->TPZ_PLANO

	If !Empty(TPZ->TPZ_QTDGAR)
		dData1   := TPZ->TPZ_DTGARA
		cLocaliz := TPZ->TPZ_LOCGAR
		dbSkip(-1)
		cLocal1 := TPZ->TPZ_LOCGAR
		If TPZ->TPZ_CODBEM == cCodBem .And. TPZ->TPZ_TIPORE == "S" .And.;
				TPZ->TPZ_CODIGO == cServ
			If TPZ->TPZ_ORDEM <> cOrdem
				cOrdem2 := TPZ->TPZ_ORDEM
				cPlano1 := TPZ->TPZ_PLANO
				If NgVerify("TPZ")
					nSequen := TPZ->TPZ_SEQREL
				Else
					nSequen := TPZ->TPZ_SEQUEN
				EndIf
				dData   := TPZ->TPZ_DTGARA
			Else
				While !Bof() .And. TPZ->TPZ_ORDEM == cOrdem
					nRecTPZ := Recno()
					dbSkip(-1)
				End While

				dbGoTo(nRecTPZ)

				cOrdem2 := TPZ->TPZ_ORDEM
				cPlano1 := TPZ->TPZ_PLANO

				If NgVerify("TPZ")
					nSequen := TPZ->TPZ_SEQREL
				Else
					nSequen := TPZ->TPZ_SEQUEN
				EndIf

				dData   := TPZ->TPZ_DTGARA
			EndIf
			If cLocaliz == cLocal1
				If TPZ->TPZ_UNIGAR = "D"
					dData2 := TPZ->TPZ_QTDGAR + dData
					If dData2 > dData1
						MsgAlert(STR0089+CHR(13); //"Serviço refeito no prazo de Garantia"
							+STR0094+AllTrim(Str(Day(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Month(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Year(TPZ->TPZ_DTGARA)))+STR0095+STJ->TJ_ORDEM+CHR(13); //"Data de Inicio de uso:"###"    O.S.:"
							+STR0096+AllTrim(Str(Day(dData2))+"/"+AllTrim(Str(Month(dData2)))+"/"+AllTrim(Str(Year(dData2))))) //"Garantia Até................:"
					EndIf
				ElseIf TPZ->TPZ_UNIGAR = "S"
					dData2 := (TPZ->TPZ_QTDGAR * 7) + dData
					If dData2 > dData1
						MsgAlert(STR0089+CHR(13); //"Serviço refeito no prazo de Garantia"
							+STR0094+AllTrim(Str(Day(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Month(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Year(TPZ->TPZ_DTGARA)))+STR0095+STJ->TJ_ORDEM+CHR(13); //"Data de Inicio de uso:"###"    O.S.:"
							+STR0096+AllTrim(Str(Day(dData2))+"/"+AllTrim(Str(Month(dData2)))+"/"+AllTrim(Str(Year(dData2))))) //"Garantia Até................:"
					EndIf
				ElseIf TPZ->TPZ_UNIGAR = "M"
					dData2 := NGSomaMes(TPZ->TPZ_DTGARA,TPZ->TPZ_QTDGAR)

					If dData2 > dData1
						MsgAlert(STR0089+CHR(13); //"Serviço refeito no prazo de Garantia"
							+STR0094+AllTrim(Str(Day(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Month(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Year(TPZ->TPZ_DTGARA)))+STR0095+STJ->TJ_ORDEM+CHR(13); //"Data de Inicio de uso:"###"    O.S.:"
							+STR0096+AllTrim(Str(Day(dData2))+"/"+AllTrim(Str(Month(dData2)))+"/"+AllTrim(Str(Year(dData2))))) //"Garantia Até................:"
					EndIf
				EndIf
			EndIf
		Else
			dbSkip()
			dData   := TPZ->TPZ_DTGARA
		EndIf
	EndIf
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNT420BAR  ³Autor  ³Evaldo Cevinscki Jr.   ³ Data ³30/10/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Barra de botoes especifica                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MNT420BAR(oDlg,bOk,bCancel)

DEFINE BUTTONBAR oBar SIZE 25,25 3D TOP OF oDlg
DEFINE BUTTON RESOURCE "S4WB008N" OF oBar GROUP ACTION Calculadora() PROMPT "" TOOLTIP OemToAnsi("Calc")
DEFINE BUTTON RESOURCE "S4WB010N" OF oBar  PROMPT "" TOOLTIP OemToAnsi("Spool")
DEFINE BUTTON RESOURCE "S4WB016N" OF oBar GROUP ACTION HelProg() PROMPT "" TOOLTIP OemToAnsi("Help")
DEFINE BUTTON oBtOk RESOURCE "OK" OF oBar GROUP ACTION Eval(bOK) PROMPT "" TOOLTIP OemToAnsi("Ok")
DEFINE BUTTON oBtCancel RESOURCE "CANCEL" OF oBar GROUP ACTION Eval(bCancel) PROMPT "" TOOLTIP OemToAnsi(STR0112) //"Cancelar"
SetKEY(15,oBtOk:bAction)

oDlg:lEscClose := .F.
oDlg:bSet15 := oBtOk:bAction
oBar:bRClicked := {|| AllwaysTrue()}

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MNT420TOKG  ³ Autor ³Evaldo Cevinscki Jr. ³ Data ³30/10/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se foi informado a quatidade de garantia do servico³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420TOKG(nQtde,nQtdeC)

If Empty(nQtde) .And. Empty(nQtdeC)
	MsgStop(STR0097,STR0098) //"Informe a quantidade de Garantia."###"ATENÇÃO"
	Return .F.
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420ESB    ³ Autor ³ Marcos Wagner Junior  ³ Data ³22/08/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta tela com a estrutura do bem                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNTA420ESB()

Local aHeaderOld  := aCLONE(aHeader)
Local cBemRet,nPos
Local cEmpBem := Nil
Local cFilBem := Nil
Local lRet    := .T.

//Executa Valid do campo posicionado
If ReadVar() != "M->TJ_CODBEM"
	nPos := aScan(oDlg420:aControls,{|x| x:cREADVAR = ReadVar()})
	If(nPos > 0)
		lRet := EVAL(oDlg420:aControls[nPos]:bValid)
		lRet := If(lRet == Nil,.T.,lRet)
	EndIf
EndIf

//Encontra posicao do controle referente ao campo TJ_CODBEM
nPos := aScan(oDlg420:aControls,{|x| x:cREADVAR = "M->TJ_CODBEM"})
If lRet .And. (nPos > 0)
	//Move o foco para o TJ_CODBEM
	oDlg420:aControls[nPos]:SetFocus()

	cBemRet := NGRETCOMPEST(M->TJ_CODBEM,cEmpBem,cFilBem)
	If !Empty(cBemRet)
		M->TJ_CODBEM := cBemRet
	EndIf
EndIf

aHeader:= aCLONE(aHeaderOld)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Ricardo Dal Ponte     ³ Data ³29/11/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transa‡„o a ser efetuada:                        ³±±
±±³          ³    1 - Pesquisa e Posiciona em um Banco de Dados           ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±³          ³7. Filtro 				                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef(lGFrota)

//Adicionado .F. nas opções para evitar que pelo menu funcional sejam alterados registros não permitidos.
Local lPyme := Iif(Type("__lPyme") <> "U",__lPyme,.F.)
Local aRotina := {{ STR0004 , "AxPesqui"    , 0 , 1},;   //"Pesquisar"
					{ STR0125 , "NGCAD01"    , 0 , 2},;   //"Visualizar"
					{ STR0006 , "NG420INC"    , 0 , 3},;   //"Incluir"
					{ STR0007 , "NG420INC"    , 0 , 4,0, .F. },; //"Alterar"
					{ STR0112 , "NG420INC"    , 0 , 5,3, .F. },; //"cancElar"
					{ STR0048 , "MNTA420IM()" , 0 , 6,0, .F. }}  //"Imprimir"

Default lGFrota := If(Select("SX2") > 0, MNTA420FR(.T.),.F.)

//Adicionado .F. nas opções para evitar que pelo menu funcional sejam alterados registros não permitidos.
If !lPyme
	AAdd( aRotina, { STR0040, "MsDocument", 0, 4, , .F. } )  //"Conhecimento"
EndIf

If ExistBlock("MNTA420S")
	Aadd(aROTINA,{STR0099,"NG420BOT", 0, 7}) //"Copiar"
EndIf

If ExistBlock("CER1A050")
	Aadd (aRotina, {STR0100,"U_CER1A050()", 0, 9}) //"Status"
EndIf

//Adicionado .F. nas opções para evitar que pelo menu funcional sejam alterados registros não permitidos.
If lGFrota
	Aadd (aRotina,{ STR0054 , "MNTA420RO()" , 0 , 7,0, .F.}) //"Rodados
EndIf

If ExistBlock("MNTA420I")
	aRotina:= ExecBlock("MNTA420I",.F.,.F.,{aRotina})
EndIf

Return(aRotina)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NG420BOT   ³ Autor ³Elisangela Costa      ³ Data ³12/03/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Botao que chama o ponto de entrado do cliente, tratado como ³±±
±±³          ³um botao para copiar OS ja cadastrada anteriormente         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG420BOT()

	Local aRotOld  := aClone(aRotina)

	ExecBlock("MNTA420S", .F., .F., {STJ->TJ_ORDEM, STJ->TJ_PLANO})

	aRotina   := aClone(aRotOld)

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A420STJBUS ³ Autor ³Ricardo Dal Ponte     ³ Data ³03/05/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Busca Ordens de servico com status de terceiros para um     ³±±
±±³          ³determinado bem                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A420STJBUS(cBEMSTJ)

dbSelectArea("STJ")
dbSetOrder(2)

lSTJAchou	:= .F.
nRecnoSTJ	:= STJ->(Recno())

dbSeek(xFILIAL("STJ")+"B"+cBEMSTJ)

While !Eof() .And. STJ->TJ_FILIAL  = xFILIAL("STJ");
		.And. STJ->TJ_TIPOOS  = "B";
		.And. STJ->TJ_CODBEM  = cBEMSTJ

	If STJ->TJ_SITUACA = "C"
		dbSkip()
		Loop
	EndIf

	If STJ->TJ_TERMINO = "N" .And. STJ->TJ_TERCEIR = "2"
		lSTJAchou := .T.
	EndIf

	dbSelectArea("STJ")
	dbSkip()
End While

STJ->(dbGoTo(nRecnoSTJ))

Return lSTJAchou

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNTA420FR ³ Autor ³In cio Luiz Kolling    ³ Data ³15/02/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se usa frota                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNTA420FR(lInPneu)

Local lRetS	:= .T. ,vRetS := {}, nFv := 0
Local vVetA	:= {"TQS_FILIAL + TQS_CODBEM",;
					"TR1_FILIAL + TR1_CODBEM + DTOS(TR1_DTPEND) + TR1_HRPEND + TR1_CODPEN",;
					"TQZ_FILIAL + TQZ_CODBEM + DTOS(TQZ_DTSTAT) + TQZ_HRSTAT + TQZ_STATUS",;
					"TQV_FILIAL + TQV_CODBEM + DTOS(TQV_DTMEDI) + TQV_HRMEDI + TQV_BANDA",;
					"T9_CODBEM+T9_SITBEM"}

lRetS	:= IIf( lRel12133, MNTFrotas(), SuperGetMv("MV_NGMNTFR",.F.," ") == 'S') // Possui frotas

If lRetS .And. (lInPneu <> Nil .Or. !lInPneu)
	cParFr := SuperGetMv("MV_NGPNEUS",.F.," ")
	lRetS  := If(cParFr = Nil .Or. cParFr = 'N',.F.,.T.)
EndIf


If lRetS
	cParFr := SuperGetMv("MV_NGSTEST"+Space(5-Len(Alltrim( "STEST" ))),.F.," ")
	If cParFr = Nil .Or. Empty(cParFr)
			lRetS := .F.
	EndIf

	cParFr := SuperGetMv("MV_NGDIFSU"+Space(5-Len(Alltrim( "DIFSU" ))),.F.," ")
	If cParFr = Nil .Or. Empty(cParFr)
			lRetS := .F.
	EndIf

	cParFr := SuperGetMv("MV_NGSERPN"+Space(5-Len(Alltrim( "SERPN" ))),.F.," ")
	If cParFr = Nil .Or. Empty(cParFr)
			lRetS := .F.
	EndIf

	cParFr := SuperGetMv("MV_NGRODIZ"+Space(5-Len(Alltrim( "RODIZ" ))),.F.," ")
	If cParFr = Nil .Or. Empty(cParFr)
			lRetS := .F.
	EndIf

	cParFr := SuperGetMv("MV_NGSTEP"+Space(5-Len(Alltrim( "STEP" ))),.F.," ")
	If cParFr = Nil .Or. Empty(cParFr)
			lRetS := .F.
	EndIf

	cParFr := SuperGetMv("MV_NGSTAPL"+Space(5-Len(Alltrim( "STAPL" ))),.F.," ")
	If cParFr = Nil .Or. Empty(cParFr)
			lRetS := .F.
	EndIf

	cParFr := SuperGetMv("MV_NGMOROD"+Space(5-Len(Alltrim( "MOROD" ))),.F.," ")
	If cParFr = Nil .Or. Empty(cParFr)
			lRetS := .F.
	EndIf
EndIf

If lRetS
	For nFv := 1 To Len(vVetA)
		nColF	:= If(nFv = 5,2,3)
		cAliA	:= SubStr(vVetA[nFv],1,nColF)
		cCamA	:= Alltrim(cAliA)
		cAliA	:= If(nFv = 5,'S'+Alltrim(cAliA),cAliA)

		vRetS	:= NGCADICBASE(cCamA+'_FILIAL','A',cAliA)

		lRetS	:= If(!vRetS[1],.F.,.T.)

		If !lRetS
			Exit
		EndIf

		If lRetS
			lRetS := If(NGRETORDEM(cAliA,vVetA[nFv],.T.) = 0,.F.,.T.)
		EndIf

		If !lRetS
			Exit
		EndIf
	Next nFv
EndIf

Return lRetS

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420ETALI³ Autor ³In cio Luiz Kolling    ³ Data ³15/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Consistencia da tarefa e etapas                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG420ETALI()

	Local lRet    := .T.
	Local nTARQL  := GDFIELDPOS("TQ_TAREFA",aHeaEta)
	Local nETAQL  := GDFIELDPOS("TQ_ETAPA",aHeaEta)
	Local nSEQETA := GDFIELDPOS("TQ_SEQETA",aHeaEta)
	Local nTarSTQ := 0

	If lUSATARG
		If nTARQL > 0
			If !Atail(aCOLS[n])
				If (Empty(aCOLS[n,nTARQL]) .And. Empty(aCOLS[n,nETAQL]) .And. Empty(aCOLS[n,nSEQETA]))
					If n == 1
						Return .F.
					EndIf
				ElseIf !Empty(aCOLS[n,nTARQL]) .And. !Empty(aCOLS[n,nETAQL])
				Else
					MsgInfo(STR0106+" "+STR0107+" "+STR0108+" "+STR0109,STR0047)
					Return .F.
				EndIf
			EndIf
		EndIf
	EndIf

	If lRet .And. ( nTarSTQ := GDFieldPos( 'TQ_TAREFA', aHeaEta ) ) > 0

		/*--------------------+
		| Validação de tarefa |
		+--------------------*/
		lRet := MNTA420VTG( aCols[n,nTarSTQ] )

	EndIf

	NGSETIFARQUI("STQ","F",1)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNT420SEQE³ Autor ³In cio Luiz Kolling    ³ Data ³15/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida campo de sequencia da etapa                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420SEQE()

Local nTARQL := GDFIELDPOS("TQ_TAREFA",aHeaEta)
Local nETAQL := GDFIELDPOS("TQ_ETAPA",aHeaEta)

If If(nTARQL>0,Empty(aCOLS[n,nTARQL]),.T.) .And. Empty(aCOLS[n,nETAQL])
	MsgInfo(STR0106+" "+STR0107+" "+STR0108+" "+STR0109,STR0047)
	Return .F.
EndIf

Return .T.

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} fOcorrGetD
Cria aHeader e aCols para tabela STN - Ocorrências.
@type function

@author Alexandre Santos
@since 24/07/2023

@return Nil
/*/
//-----------------------------------------------------------------------------------
Static Function fOcorrGetD( nOpcX )

	Local aNoField := {}
	Local nTarSTN  := 0
	Local nProble  := 0

	aNoField := {'TN_ORDEM', 'TN_PLANO', 'TN_SEQRELA', 'TN_CAUSA',;
		'TN_NOMCAUS', 'TN_SOLUCAO', 'TN_NOMSOLU', 'TN_SEQUENC' }

	If SuperGetMv( 'MV_NGTARGE', .F., '2' ) == '2'

		aAdd( aNoField, 'TN_TAREFA' )
		aAdd( aNoField, 'TN_NOMETAR' )

	EndIf

	FillGetDados( nOpcx, 'STN', , , , , aNoField, , , , { || fColsOcr() }, .T., aHeaOcr )

	If ( nTarSTN := GDFieldPos( 'TN_TAREFA', aHeaOcr ) ) > 0

		aHeaOcr[nTarSTN,6]  := "Mnta420Vld( 'TN_TAREFA' )"
		aHeaOcr[nTarSTN,9]  := "TT9COR"

	EndIf

	If ( nProble := GDFieldPos( 'TN_CODOCOR', aHeaOcr ) ) > 0

		aHeaOcr[nProble,6]  := "MNTA420Vld( 'TN_CODOCOR' )"
		aHeaOcr[nProble,9]  := "ST8420"

	EndIf

	PutFileInEof( 'STN' )

	FWFreeArray( aNoField )

Return

//-----------------------------------------------------------------------------------------
/*/{Protheus.doc} fColsIns
realiza montagem e preenchimento do aCols de insumos.
@type function

@author Alexandre Santos
@since 24/10/2019

@sample fColsIns()

@param
@return
/*/
//-----------------------------------------------------------------------------------------
Static Function fColsOcr()

	Local aGetAux  := {}
	Local cAlsSTN  := GetNextAlias()
	Local cFields  := "%"
	Local cCast    := ''
	Local cJoin    := "%"
	Local cDbase   := TCGetDB()
	Local lUseTarG := SuperGetMv( 'MV_NGTARGE', .F., '2' ) == '1'

	If lUseTarG

		cFields += " ,STN.TN_TAREFA  "
		cFields += " ,TT9.TT9_DESCRI "

		cJoin += "INNER JOIN "
		cJoin +=	RetSQLName( 'TT9' ) + " TT9 ON "
		cJoin +=		"TT9.TT9_FILIAL = " + ValToSQL( FWxFilial( 'TT9' ) ) + " AND "
		cJoin +=		"TT9.TT9_TAREFA = STN.TN_TAREFA AND "
		cJoin +=		"TT9.D_E_L_E_T_ = ' ' "

	EndIf

	cCast := ", STN.TN_DESCRIC " // INFORMIX

	Do Case
		
		Case cDbase == 'ORACLE'
			
			cCast := ", UTL_RAW.CAST_TO_VARCHAR2( dbms_lob.substr( STN.TN_DESCRIC, 2000, 1 ) ) AS TN_DESCRIC "
		
		Case cDbase == 'POSTGRES'
			
			cCast := ", COALESCE( CAST( CAST( STN.TN_DESCRIC AS bytea ) AS bytea ), '' ) AS TN_DESCRIC "
			
		Case 'MSSQL' $ cDbase

			cCast := ", ISNULL( CAST( CAST( STN.TN_DESCRIC AS VARBINARY( 2000 ) ) AS VARCHAR( 2000 ) ),'') AS TN_DESCRIC "
	
	End Case

	cFields += cCast
	cFields += "%"
	cJoin   += "%"

	BeginSQL Alias cAlsSTN

		SELECT
			STN.TN_CODOCOR,
			ST8.T8_NOME   ,
			STN.R_E_C_N_O_
			%exp:cFields%
		FROM
			%table:STN% STN
		INNER JOIN
			%table:ST8% ST8 ON
				ST8.T8_FILIAL  = %xFilial:ST8%  AND
				ST8.T8_CODOCOR = STN.TN_CODOCOR AND
				ST8.%NotDel%
		%exp:cJoin%
		WHERE
			STN.TN_FILIAL  = %xFilial:STN%     AND
			STN.TN_ORDEM   = %exp:M->TJ_ORDEM% AND
			STN.TN_PLANO   = %exp:M->TJ_PLANO% AND
			STN.TN_SEQRELA = '0'               AND
			STN.%NotDel%

	EndSQL

	If (cAlsSTN)->( !EoF() )
	
		While (cAlsSTN)->( !EoF() )

			aGetAux := {}

			If lUseTarG
				
				aAdd( aGetAux, (cAlsSTN)->TN_TAREFA )
				aAdd( aGetAux, (cAlsSTN)->TT9_DESCRI )

			EndIf

			aAdd( aGetAux, (cAlsSTN)->TN_CODOCOR )
			aAdd( aGetAux, (cAlsSTN)->T8_NOME )
			aAdd( aGetAux, (cAlsSTN)->TN_DESCRIC )
			aAdd( aGetAux, 'STN' )
			aAdd( aGetAux, (cAlsSTN)->R_E_C_N_O_ )
			aAdd( aGetAux, .F. )

			aAdd( aGetOcr, aClone( aGetAux ) )

			(cAlsSTN)->( dbSkip() )

		End

	Else 

		aAdd( aGetOcr, aClone( BlankGetD( aHeaOcr )[1] ) )

	EndIf

	(cAlsSTN)->( dbCloseArea() )

	FWFreeArray( aGetAux )  

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420INSIN³ Autor ³ Felipe N. Welter      ³ Data ³ 10/10/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carrega dados na GetDados da TTC                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NG420INSIN(nOPCX)

Local aNAO := {},cKEY,cGETWHILE

cKEY		:= M->TJ_ORDEM + M->TJ_PLANO
cGETWHILE	:= "TTC_FILIAL == xFilial('TTC') .and. TTC_ORDEM == M->TJ_ORDEM .and. TTC_PLANO == M->TJ_PLANO"
aNAO		:= {"TTC_CODBEM","TTC_ORDEM","TTC_PLANO","TTC_DATA"}

If NGCADICBASE("TTC_CDSERV","D","TTC",.F.) //Santa Cruz
	aAdd(aNAO,"TTC_CDSERV");aAdd(aNAO,"TTC_DESERV");aAdd(aNAO,"TTC_DTEXEC");aAdd(aNAO,"TTC_SEREXE")
EndIf

aHEASIN := CABECGETD("TTC", aNAO)

//Inclui coluna de registro atraves de funcao generica
ADHeadRec("TTC",aHEASIN)

If nOPCX == 3
	aGETSIN := BLANKGETD(aHEASIN)
Else
	aGETSIN := MAKEGETD("TTC", cKEY,aHEASIN, cGETWHILE)
	If Empty(aGETSIN)
		aGETSIN := BLANKGETD(aHEASIN)
	EndIf
EndIf

Return Nil

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} fCadOcorre
Monta GetDados de Ocorrências.
@type function

@author Alexandre Santos
@since 21/08/2023

@param
@return
/*/
//-----------------------------------------------------------------------------------
Static Function fCadOcorre()

	Local cTitBkp   := cCadastro
	Local cTudOk	:= 'AllAlwaysTrue()'
	Local cLinOk	:= 'Mnta420LOk()'
	Local lOk       := .F.
	Local oDlgOcorr
	Local oPnlOcorr

	If !Empty( M->TJ_CODBEM )

		cCadastro := STR0211 // Ocorrências

		Define MsDialog oDlgOcorr Title STR0211 From 163,0 To 463,If(GetScreenRes()[1] <= 800,750,GetScreenRes()[1]*0.73) Pixel Of oMainWnd

			oPnlOcorr := TPanel():New( 01, 01, , oDlgOcorr, , , , , , , , .F., .F. )
			oPnlOcorr:Align := CONTROL_ALIGN_ALLCLIENT

			oGetOcorr := MsNewGetDados():New( 0, 0, 0, 0, GD_INSERT + GD_UPDATE + GD_DELETE, cLinOK,;
				cTudOK, , , , 9999, , , , oPnlOcorr, aHeaOcr, aGetOcr )

		Activate MsDialog oDlgOcorr ON INIT ( EnchoiceBar( oDlgOcorr, { | | lOk := fTudOkOcr( oDlgOcorr ) },;
			{ | | oDlgOcorr:End() } ), AlignObject( oDlgOcorr, { oGetOcorr:oBrowse }, 1 ) )

		If lOk

			aHeaOcr := aClone( oGetOcorr:aHeader )
			aGetOcr := aClone( oGetOcorr:aCols )

			/*----------------------------------------------------------------------------+
			| Caso alguma linha tenha sofrido alteração, libera a gravação dos registros. |
			+----------------------------------------------------------------------------*/
			lSaveSTN := ( lSaveSTN .Or. ( Len( oGetOcorr:aLastEdit ) > 0 .Or. oGetOcorr:lModified ) )

		EndIf

	Else

		Help( '', 1, 'OBRIGAT', , Chr( 13 ) + RetTitSX3( 'TJ_CODBEM' ) + Space( 35 ), 3 )

	EndIf

	cCadastro := cTitBkp

	FWFreeObj( oDlgOcorr )
	FWFreeObj( oGetOcorr )

Return

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} Mnta420LOk
Validação de linha para o GetDados de Ocorrências.
@type function

@author Alexandre Santos
@since 21/08/2023

@param nLine   , integer, Linha em validação.
@return boolean, Indica se a linha foi validada.
/*/
//-----------------------------------------------------------------------------------
Function Mnta420LOk( nLine )

	Local cCodTar := ''
	Local lRet    := .T.
	Local nInd1   := 0
	Local nQtdOcr := 0
	Local nProble := GDFieldPos( 'TN_CODOCOR', aHeaOcr )
	Local nTarSTN := GDFieldPos( 'TN_TAREFA' , aHeaOcr )

	Default nLine := oGetOcorr:nAt

	If !aTail( oGetOcorr:aCols[nLine] )

		If nTarSTN > 0 .And. Empty( oGetOcorr:aCols[nLine,nTarSTN] )

			Help( '', 1, 'OBRIGAT2', , Chr( 13 ) + RetTitSX3( 'TN_TAREFA' ) + Space( 35 ), 3 )

			lRet := .F.

		ElseIf Empty( oGetOcorr:aCols[nLine,nProble] )

			Help( '', 1, 'OBRIGAT2', , Chr( 13 ) + RetTitSX3( 'TN_CODOCOR' ) + Space( 35 ), 3 )

			lRet := .F.

		Else

			/*------------------------------------------------+
			| Valida se já existe uma mesma TAREFA + PROBLEMA |
			+------------------------------------------------*/
			For nInd1 := 1 To Len( oGetOcorr:aCols )

				If ( ( nTarSTN > 0 .And. oGetOcorr:aCols[nInd1,nTarSTN] == oGetOcorr:aCols[nLine,nTarSTN] ) .Or. nTarSTN == 0 ) .And.;
					oGetOcorr:aCols[nInd1,nProble] == oGetOcorr:aCols[nLine,nProble] .And. !aTail( oGetOcorr:aCols[nInd1] )

					nQtdOcr++

				EndIf
				
			Next nInd1
			
			If nQtdOcr > 1

				Help( '', 1, 'JAGRAVADO' )
				
				lRet := .F.

			EndIf

			If lRet .And. nTarSTN > 0

				lRet := MNTA420VTG( oGetOcorr:aCols[nLine,nTarSTN] )

			EndIf

			If lRet .And. nProble > 0

				If nTarSTN > 0

					cCodTar := oGetOcorr:aCols[nLine,nTarSTN]
				
				Else

					cCodTar := '0'

				EndIf

				lRet := MNA420VOcr( oGetOcorr:aCols[nLine,nProble],;
					cCodTar )

			EndIf

		EndIf
		
	EndIf
	
Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} fTudOkOcr
Validação de final para o GetDados de Ocorrências.
@type function

@author Alexandre Santos
@since 21/08/2023

@param oDlgOcorr, object, Objeto que contém o getdados de Ocorrências.
@return boolean , Indica se foi validado.
/*/
//-----------------------------------------------------------------------------------
Static Function fTudOkOcr( oDlgOcorr )

	Local nInd1 := 0
	Local lRet  := .T.

	For nInd1 := 1 To Len( oGetOcorr:aCols )

		If !aTail( oGetOcorr:aCols[nInd1] )

			lRet := Mnta420LOk( nInd1 )
			
			If !lRet
				
				Exit

			EndIf

		EndIf

	Next nInd1

	If lRet

		oDlgOcorr:End()

	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNT420SINT³ Autor ³ Felipe N. Welter      ³ Data ³ 10/10/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta GetDados dos Sintomas                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNT420SINT()

	Local i

	aHeader	:= aClone( aHEASIN )
	aCols	:= aClone( aGetSin )
	cTudoOk	:= 'AllAlwaysTrue()'
	cLinOk	:= 'MNT420SLin()'
	nOpcas	:= 0

	Define MsDialog oDlgSin Title STR0110 From 163,0 To 463,If(GetScreenRes()[1] <= 800,750,GetScreenRes()[1]*0.73) Pixel Of oMainWnd //"Sintomas - O.S. Corretiva"

		If setmdichild()
		oGet := MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],3,cLINOK,cTUDOOK,"",.T.,,,,300)
		Else
		oGet := MSGetDados():New(13,1,140,315,3,cLINOK,cTUDOOK,"",.T.,,,,300)
		EndIf

	Activate MsDialog oDlgSin On Init (EnchoiceBar(oDlgSin,{||If(MNT420STOK(),oDlgSin:End(),)},;
											{||oDlgSin:End()}), AlignObject(oDlgSin,{oGet:oBrowse},1))

	If nOpcas == 1
		If Len(aCols) > 0
			For i := 1 to Len(aCols)
				If !aCols[i][Len(aCols[i])]
					lTemSint := .T.
				EndIf
			Next
		EndIf

		aHeaSin := aClone( aHeader )
		aGetSin := aClone( aCols )

		// Caso alguma linha tenha sofrido alteração, libera a gravação dos registros.
		lSaveTTC := ( lSaveTTC .Or. ( Len( oGet:aLastEdit ) > 0 .Or. oGet:lModified ) )

	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNT420SLin³ Autor ³ Felipe N. Welter      ³ Data ³ 14/10/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao cLINOK para os sintomas                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420SLin(o)

Local lRet	:= .T.
Local nMax	:= Len(aCols[n])
Local nQtd	:= 0
Local lDel	:= aCOLS[n][Len(aCOLS[n])]

If lDel
	Return .T.
EndIf

nCOD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TTC_CDSINT" })

nLIN := 1

If Len(aCOLS) == 1
	If aCOLS[1][Len(aCOLS[1])]
	Return .T.
	EndIf
Else
	nLIN := n
EndIf

cCOD := aCOLS[nLIN][nCOD]
nMax := Len(aCols[n])

aEval(aCOLS, {|x| If( (x[1] == cCOD .And. !x[nMax]), nQtd++, NIL ) })

If nQtd > 1
	Help(" ",1, "JAGRAVADO")
	lRet := .F.
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNT420STOK³ Autor ³ Felipe N. Welter      ³ Data ³ 14/10/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao cTUDOOK para os Sintomas                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420STOK()

Local i
Local lRet := .T.

For i := 1 To Len(aCOLS)
	If !aCOLS[i][Len(aCOLS[i])]
		lRet := MNT420SLin(I)
		If !lRet
			Exit
		EndIf
	EndIf
Next

nOpcas := If(lRet,1,0)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNT420ATSI³ Autor ³ Felipe N. Welter      ³ Data ³ 10/10/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava TTC                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420ATSI()

Local nCOL,nHEA,nULT := Len(aGETSIN[1])

M->TTC_PLANO  := "000000"

dbSelectArea("TTC")
dbSetOrder(1)

ProcRegua(Len(aGETSIN))
For nCOL := 1 to Len(aGETSIN)
	IncProc()
	xx := aScan(aHEASIN,{|x| Trim(Upper(x[2])) == "TTC_CDSINT"})
	M->TTC_CDSINT := If(xx > 0, aGETSIN[nCOL][xx], Space(6))

	If Empty(aGETSIN[nCOL][1])
		Loop
	EndIf

	If aGETSIN[nCOL][nULT]
		If dbSeek(xFilial("TTC")+M->TJ_ORDEM+M->TTC_PLANO+M->TTC_CDSINT)
			RecLock("TTC", .F.)
			dbDelete()
			MsUnlock("TTC")
		EndIf
		Loop
	EndIf

	dbSelectArea("TTC")
	dbSetOrder(1)
	If !dbSeek(xFilial("TTC")+M->TJ_ORDEM+M->TTC_PLANO+M->TTC_CDSINT)
		RecLock("TTC",.T.)
	Else
		RecLock("TTC",.F.)
	EndIf

	TTC->TTC_FILIAL := xFilial("TTC")
	TTC->TTC_CODBEM := M->TJ_CODBEM
	TTC->TTC_ORDEM  := M->TJ_ORDEM
	TTC->TTC_PLANO  := M->TTC_PLANO
	TTC->TTC_DATA   := M->TJ_DTORIGI

	If NGCADICBASE('ZZ2_CDSERV','A','ZZ2',.F.)
		TTC->TTC_CDSERV := NGSEEK('ZZ2',M->TTC_CDSINT,1,'ZZ2_CDSERV')
	EndIf

	For nHEA := 1 to Len(aHEASIN)
		If aHEASIN[nHEA][10] != "V"
			xx := "TTC->" + aHEASIN[nHEA][2]
			yy := "M->" + aHEASIN[nHEA][2]
			yy := aGETSIN[nCOL][nHEA]
			&xx. := yy
		EndIf
	Next

	MsUnlock("TTC")
Next

Return .T.

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} fCommitSTN
Gravação de Ocorrências.
@type function

@author Alexandre Santos
@since 21/08/2023

@param
@return
/*/
//-----------------------------------------------------------------------------------
Static Function fCommitSTN()

	Local cField   := ''
	Local cGetD    := ''
	Local cCodTar  := ''
	Local cSeqRel  := PadR( '0', FWTamSX3( 'TN_SEQRELA' )[1] )
	Local nTamTar  := FWTamSX3( 'TN_TAREFA' )[1]
	Local nTarSTN  := GDFieldPos( 'TN_TAREFA' , aHeaOcr )
	Local nProble  := GDFieldPos( 'TN_CODOCOR', aHeaOcr )
	Local nInd1    := 0
	Local nInd2    := 0
	Local lFound   := .F.
	Local lUseTarG := SuperGetMv( 'MV_NGTARGE', .F., '2' ) == '1'

	dbSelectArea( 'STN' )
	dbSetOrder( 1 ) // TN_FILIAL + TN_ORDEM + TN_PLANO + TN_TAREFA + TN_SEQRELA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO

	ProcRegua( Len( aGetOcr ) )

	For nInd1 := 1 To Len( aGetOcr )

		IncProc()

		If lUseTarG

			cCodTar := aGetOcr[nInd1,nTarSTN]

		Else

			cCodTar := PadR( '0', nTamTar )

		EndIf

		lFound := msSeek( FWxFilial( 'STN' ) + M->TJ_ORDEM + M->TJ_PLANO +;
			cCodTar + cSeqRel + aGetOcr[nInd1,nProble] )

		If aTail( aGetOcr[nInd1] )

			If lFound

				RecLock( 'STN', .F. )
					dbDelete()
				MsUnlock()

			EndIf

		Else

			RecLock( 'STN', !lFound )

				STN->TN_FILIAL  := FWxFilial( 'STN' )
				STN->TN_ORDEM   := M->TJ_ORDEM
				STN->TN_PLANO   := M->TJ_PLANO
				STN->TN_SEQRELA := '0'

				If !lUseTarG

					STN->TN_TAREFA := '0'

				EndIf

				For nInd2 := 1 To Len( aHeaOcr )

					If lUseTarG .And. Trim( aHeaOcr[nInd2,2] ) == 'TN_TAREFA' 

						STN->TN_TAREFA := aGetOcr[nInd1,nInd2]

					ElseIf aHeaOcr[nInd2,10] != 'V'

						cField   := 'STN->' + aHeaOcr[nInd2,2]
						cGetD    := aGetOcr[nInd1,nInd2]
						&cField. := cGetD

					EndIf

				Next nInd2

			MsUnLock()
		
		EndIf
		
	Next

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MNT420AL
Funcao para preencher os campos da tela quando chamado a
partir da arvore logica.

@author  Rafael Diogo Richter
@since   31/10/2008
@version P12
/*/
//-------------------------------------------------------------------
Function MNT420AL()

	If ValType(lBemAL) == "C"
		Return Space(Len(ST9->T9_CODBEM))
	EndIf

	M->TJ_CODBEM := cBemAL

	If lBemAL

		NGIFDBSeek( 'ST9', M->TJ_CODBEM, 1 )

		TIPOACOM  := ST9->T9_TEMCONT == 'S' .And. M->TJ_DTORIGI <= dDataBase
		M->TJ_TIPOOS := 'B'
		M->TJ_NOMBEM := ST9->T9_NOME

	Else

		TIPOACOM  := .F.
		TIPOACOM2 := .F.
		M->TJ_TIPOOS := 'L'
		M->TJ_NOMBEM := NGSEEK( 'TAF', '001'+ AllTrim( M->TJ_CODBEM ), 2, 'TAF_NOMNIV' )

	EndIf

Return M->TJ_CODBEM

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNT420QNC ³ Autor ³ Evaldo Cevinscki Jr.  ³ Data ³ 26/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Integracao com QNC                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420QNC(cFilQI2,cFNC,cREVFNC)

	Local cALIAH := Alias(), nINDOH := IndexOrd()
	Local aRotiold := Aclone(aRotina), ccondiQI2, ccadold := cCADASTRO

	Private aIndQI2	:= {}, bFiltraBrw := {|| Nil}
	Private cQFilQI2	:= cFilQI2,cQFNC := cFNC,cQREVFNC := cREVFNC

	If AllTrim(GetMv("MV_NGMNTQN")) <> "S"
		MsgStop(STR0124,STR0098) //"Não integrado ao módulo de Não-Conformidade"
		Return .T.
	EndIf

	aROTINA := {{STR0004,"PesqBrw" , 0, 1},;   //"Pesquisar"
					{STR0125,"NGCAD01", 0, 2}}    //"Visualizar"

	cCADASTRO	:= OemToAnsi(STR0126) //"Ficha de Não Conformidade"
	ccondiQI2	:= 'QI2->QI2_FILIAL == cQFilQI2 .And. QI2->QI2_ANO == SUBSTR(cQFNC,7,4) .And. QI2->QI2_FNC == cQFNC .And. QI2->QI2_REV == cQREVFNC'

	dbSelectArea("QI2")
	dbSetOrder(1)
	dbGoTop()

	nINDSTP := IndexOrd()

	MBROWSE(6,1,22,75,"QI2")

	aEval(aIndQI2,{|x| Ferase(x[1]+OrdBagExt())})
	EndFilbrw("QI2",aIndQI2)

	dbSelectArea("QI2")
	dbSetOrder(1)

	aRotina   := Aclone(aRotiold)
	cCADASTRO := ccadold

	dbSelectArea(cALIAH)
	dbSetOrder(nINDOH)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NG420CONT ³ Autor ³Felipe N. Welter       ³ Data ³ 20/05/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validacao dos campos de contador na tela                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG420CONT(nTIP)

	Local lRet	  := .F.
	Local cVar420 := ReadVar()

	If "TJ_POSCONT" $ cVar420
		lRet := If(M->TJ_POSCONT > 0,CHKPOSLIM(M->TJ_CODBEM,M->TJ_POSCONT,1),If(POSITIVO(),.T.,.F.))
	ElseIf "TJ_POSCON2" $ cVar420
		lRet := If(M->TJ_POSCON2 > 0,CHKPOSLIM(M->TJ_CODBEM,M->TJ_POSCON2,2),If(POSITIVO(),.T.,.F.))
	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNT420NIE ³ Autor ³In cio Luiz Kolling    ³ Data ³10/11/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Consistencia de insumos e/ou etapas para OS cancelada       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT420NIE()

	Local nIA := 0,lRetG := .T.

	For nIA := 1 to Len(aGETINS)
		If Atail(aGETINS[nIA])
			lRetG := .F.
			Exit
		EndIf
	Next nIA

	If lRetG
		For nIA := 1 to Len(aGETETA)
			If Atail(aGETETA[nIA])
				lRetG := .F.
				Exit
			EndIf
		Next nIA
	EndIf

	If !lRetG
		MsgInfo(STR0118,STR0047)
	EndIf

Return lRetG

//---------------------------------------------------------------------
/*/{Protheus.doc} NG420CHKSA
Checa se utiliza geracao de Solicitacao ao Armazem

cTipoInsumo - Consiste solicitacao de armazem para produto

@author Evaldo Cevinscki Jr.
@since 29/12/2009
@version MP11
@return
/*/
//---------------------------------------------------------------------
Function NG420CHKSA(cTipoInsumo)

	Local aArea := GetArea()

	Private aRetSA := {}

	Default cTipoInsumo := "T"

	cUsaIntEs	:= AllTrim(GetMV("MV_NGMNTES"))
	lGeraSA	:= .F.

	If NGCADICBASE('TL_NUMSA','A','STL',.F.) .And. FindFunction("NGGERASA")
		If cUsaIntEs == "S"
			If cGerSA == 'S' .Or. ( cGerSA == 'P' .And. cTipoInsumo == 'P' )
				lGeraSA := .T.
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return lGeraSA

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNTWTJBEM ³ Autor ³Vitor Emanuel Batista  ³ Data ³20/11/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida X3_WHEN do campo TJ_CODBEM                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³SIGAMNT                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTWTJBEM()

	If FunName() $ 'MNTA902/MNTA985'
		Return .F.
	ElseIf Type("lWhenTJBem") = "L"
		Return lWhenTJBem
	EndIf

Return .T.

//--------------------------------------------------------------------------------------------------
/*/{Proteus.doc} NGTTYBLOQ
Verifica se existe bloqueio para a especialidade no periodo.
@type function

@author Denis
@since  16/11/2006

@sample NGTTYBLOQ( 4 )

@param  cCodMdo, Caracter, Código da especialidade.
@param  dDtInic, Data    , Data inicio de aplicação da mão-de-obra.
@param  cHoInic, Caracter, Hora inicio de aplicação da mão-de-obra.
@param  nQtdMdo, Númerico, Quantidade de horas.
@param  nQtdRec, Númerico, Quantidade de Recursos.
@param  nVlItem, Númerico, Número da linha.
@param  cNumOS , Caracter, Ordem de Serviço.
@param  nTpRet , Númerico, Tipo Retorno (1 - Lógico, 2 - Número de Erro ou 3 - Array com Lógico e Mensagem).
@return Lógico , Define se o processo foi realizado com êxito.

@todo função deverá ser descontinuada na realese 12.1.29
/*/
//------------------------------------------------------------------------------------------------
Function NGTTYBLOQ( cCODMDO, dDTINIC, cHOINIC, nQtdMdo, nQtdRec, nVLITEM, cNumOS, nTpRet, cPlan )

	Local cEspCod  := ''
	Local aDtHoFim := {}
	Local cMsg     := ''
	Local lRet     := .T.

	Default nTpRet  := 1
	Default nVlItem := 0
	Default cPlan   := M->TJ_PLANO

	If FindFunction( 'MntVldBlqE' )

		lRet := MntVldBlqE( cNumOS, cPlan, { cCODMDO, nQtdMdo, nQtdRec, dDTINIC, cHOINIC }, nVLITEM, .T. )[1]

	Else

		If GETMV("MV_NGCORPR") == "S" .and. NGCADICBASE("TTY_ORDEM","A","TTY",.F.)

			cEspCod := PadR( cCODMDO , Len(ST2->T2_ESPECIA) )

			//Le ST2 acumula a quantidade de especialistas disponiveis
			dbSelectArea("ST2")
			dbSetOrder(2)
			dbSeek(xFilial("ST2")+cEspCod)
			While !Eof() .And. ST2->T2_FILIAL+ST2->T2_ESPECIA == xFilial("ST2")+cEspCod
				nCont++
				dbSkip()
			End

			If nCont == 0
				cMsg := STR0119 //"Não existe funcionário para esta especialidade."
			ElseIf nCont < cQTDREC
				cMsg := STR0120 //"A Quantidade de funcionário para esta especialidade é insuficiente."
			Else

				//Retorna a Data Inicio/Data fim da especialidade
				aDtHoFim := NGDTHORFIM(dDTINIC,cHOINIC,cQTDMDO)

				//Le TTY (bloqueios especialidades)
				dbSelectArea("TTY")
				dbSetOrder(2)
				dbSeek(xFilial("TTY")+cEspCod+DTOS(dDTINIC),.T.)
				If Eof() .Or. xFilial("TTY")+cEspCod+DTOS(dDTINIC) != TTY->(TTY_FILIAL+TTY_CODESP+DTOS(TTY_DTINI))
					dbSkip(-1)
					If Bof() .Or. xFilial("TTY")+cEspCod != TTY->(TTY_FILIAL+TTY_CODESP)
						dbSkip()
					EndIf
				EndIf
				dbSelectArea("TTY")
				While !Eof() .and. xFilial("TTY")+cEspCod == TTY->(TTY_FILIAL+TTY_CODESP) .and. TTY->TTY_DTINI <= aDtHoFim[1]
					If TTY->TTY_QUANTI > 0 .and. cNumOS <> TTY->TTY_ORDEM .and. ;
					DtoS(dDTINIC)+cHOINIC < DtoS(TTY->TTY_DTFIM)+TTY->TTY_HRFIM .and.;
					DtoS(aDtHoFim[1])+aDtHoFim[2] > DtoS(TTY->TTY_DTINI)+TTY->TTY_HRINI

						nCont := nCont - TTY->TTY_QUANTI
					EndIf
					dbSkip()
				End
				If (nCont - cQTDREC) < 0
					cMsg := STR0121+Alltrim(Str(nVLITEM,3))+"." //"Já existe bloqueio para a especialidade no período, item "
				EndIf

			EndIf

		EndIf

		If lTipoRet == 1
			If !Empty(cMsg)
				If !MsgYesNo(cMsg+CHR(13)+STR0122,STR0047) //"Deseja prosseguir mesmo assim?" # "NAO CONFORMIDADE"
					lRet := .F.
				EndIf
			EndIf
			Return lRet
		EndIf

	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNT420F7  ³ Autor ³ Evaldo Cevinscki Jr.  ³ Data ³ 26/02/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao carregando consulta atraves de F7 consulta de bens   ³±±
±±³          ³Multi-Empresa                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNT420F7()

Local nPos
Local lRet	:= .T.
Local bF7	:= SetKey(VK_F7)

//Carre
If FindFunction("MNTFAST")
	MNTFAST()
Else
	MsgInfo(STR0127) //"Para utilização dessa funcionalidade, deverá ser atualizado o programa MNTUTIL.PRX"
	Return .F.
EndIf

//Executa Valid do campo posicionado
If ReadVar() != "M->TJ_CODBEM"
	nPos := aScan(oDlg420:aControls,{|x| x:cREADVAR = ReadVar()})
	If(nPos > 0)
		lRet := EVAL(oDlg420:aControls[nPos]:bValid)
		lRet := If(lRet == Nil,.T.,lRet)
	EndIf
EndIf

//Encontra posicao do controle referente ao campo TJ_CODBEM
nPos := aScan(oDlg420:aControls,{|x| x:cREADVAR = "M->TJ_CODBEM"})
If lRet .And. (nPos > 0)
	//Move o foco para o TJ_CODBEM
	oDlg420:aControls[nPos]:SetFocus()

	dbSelectArea("SN1")
	dbSetOrder(1)
	dbGoTop()
	lCONDP := CONPAD1(NIL,NIL,NIL,"NG9   ",NIL,NIL,.F.)
	If lCONDP //Se confirmou a consulta
		M->TJ_CODBEM := SN1->N1_CBASE+SN1->N1_ITEM
		M->TJ_TIPOOS := "B"
		M->TJ_NOMBEM := SN1->N1_DESCRIC
		lUsouF7 := .T.
	EndIf
EndIf

SetKey(VK_F7, bF7)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CARREGIMBO³ Autor ³ Evaldo Cevinscki Jr.  ³ Data ³26/02/10  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Alimenta os campos do ST9 com os campos do SN1             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function CARREGIMBO()

Local aArea := GetArea()
Local lAchouIm := .F.

//Verifica se ja existe outro bem com mesmo codigo de imobilizado
NGIFDBSEEK("ST9",M->TJ_CODBEM,8)
While !Eof() .And. ST9->T9_FILIAL == xFilial("ST9") .And. ST9->T9_CODIMOB == SN1->N1_CBASE;
		.And. !lAchouIm

	lAchouIm  := .T.
	cCODBIMOB := ST9->T9_CODBEM
	NGDBSELSKIP("ST9")
End While

If lAchouIm
	MsgInfo(STR0128+" "+Alltrim(cCODBIMOB)+"."+CHR(13); //"Imobilizado já cadastrado para o bem" //"Imobilizado já cadastrado para o bem"
			+STR0129,STR0047) //"Informe outro código de Imobilizado."#"NÃO CONFORMIADE" //"Informe outro código de Imobilizado."
	Return .F.
EndIf


If !NGIFDBSEEK( "ST9", M->TJ_CODBEM, 8 ) .And. !NGIFDBSEEK( "ST9", M->TJ_CODBEM, 1 )
	NGIFDBSEEK( "SN1", M->TJ_CODBEM, 1 )
	If SN1->N1_QUANTD == 1
		RecLock("ST9",.T.)
		ST9->T9_FILIAL  := xFilial("ST9")
		ST9->T9_CODBEM  := SN1->N1_CBASE+SN1->N1_ITEM
		ST9->T9_CODIMOB := SN1->N1_CBASE+SN1->N1_ITEM
		ST9->T9_CATBEM  := "1"
		ST9->T9_PADRAO  := "N"

		If !Empty(SN1->N1_GRUPO)
			ST9->T9_CODFAMI := SN1->N1_GRUPO
			If !NGIFDBSEEK("ST6",SN1->N1_GRUPO,1)
				RecLock("ST6",.T.)
				ST6->T6_FILIAL := xFilial("ST6")
				ST6->T6_CODFAMI:= SN1->N1_GRUPO
				ST6->T6_NOME   := NGSEEK("SNG",SN1->N1_GRUPO,1,"NG_DESCRIC")
				ST6->(MsUnLock())
			EndIf
		Else
			ST9->T9_CODFAMI := "GENERI"
		EndIf

		ST9->T9_TEMCONT := "N"
		ST9->T9_ESTRUTU := "N"
		ST9->T9_PRIORID := "ZZZ"
		ST9->T9_SITBEM  := "A"
		ST9->T9_SITMAN  := "A"
		ST9->T9_DTCOMPR := SN1->N1_AQUISIC
		ST9->T9_CALENDA := "24H"
		ST9->T9_NOME    := SN1->N1_DESCRIC + Space(40-Len(SN1->N1_DESCRIC))
		ST9->T9_CHAPA   := SN1->N1_CHAPA
		ST9->T9_FORNECE := SN1->N1_FORNEC
		ST9->T9_LOJA    := SN1->N1_LOJA
		ST9->T9_LOCAL   := SN1->N1_LOCAL
		ST9->T9_MOVIBEM := "S"
		ST9->T9_BITMAP  := SN1->N1_BITMAP
		ST9->T9_NFCOMPR := SN1->N1_NFISCAL


		If NGIFDBSEEK("SN3",SN1->N1_CBASE+SN1->N1_ITEM,1)
			ST9->T9_CCUSTO := If(Empty(SN3->N3_CUSTBEM),"CCGENERI",SN3->N3_CUSTBEM)
			ST9->T9_VALCPA := SN3->N3_VORIG1
		EndIf
		ST9->(MsUnLock())
	Else
		MSGINFO(STR0130 + Chr(13);//"O relacionamento do Ativo Fixo com o Bem nao pode ser realizado. O campo" //"O relacionamento do Ativo Fixo com o Bem nao pode ser realizado. O campo"
		+STR0131,STR0029) //"'Quantidade' no cadastro do Ativo Fixo e diferente de 1." //"'Quantidade' no cadastro do Ativo Fixo e diferente de 1."
		Return .F.
	EndIf
EndIf

RestArea(aArea)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MNTA420ATF³ Autor ³ Evaldo Cevinscki Jr.  ³ Data ³26/02/10  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Filtro da consulta NG9 para carregar somente os ativos que ³±±
±±³          ³ ainda nao estao na ST9                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA420ATF()

	Local aArea := GetArea()

	If FunName() == "MNTA420"
		If !NGIFDBSEEK("ST9",SN1->N1_CBASE+SN1->N1_ITEM,8)
			RestArea(aArea)
			Return .T.
		Else
			RestArea(aArea)
			Return .F.
		EndIf
	EndIf
	RestArea(aArea)

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MNTA420GARºAutor  ³Taina A. Cardoso    º Data ³  15/08/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se esta ocorrendo quebra na garantia.              º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MNTA420                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MNTA420GAR(aCols,aHEADER)

Local i, j, x
Local dDtVal
Local dDtIni	:= If(IsInCallStack("MNTA400"),STJ->TJ_DTORIGI,M->TJ_DTORIGI)
Local nPosCon
Local nContador
Local cProduto
Local cTipoGar
Local cCodBem	 := If(IsInCallStack("MNTA400"),STJ->TJ_CODBEM,M->TJ_CODBEM)
Local cHoraCont	 := If(IsInCallStack("MNTA400"),STJ->TJ_HORACO1,M->TJ_HORACO1)
Local cHoraCont2 := If(IsInCallStack("MNTA400"),STJ->TJ_HORACO2,M->TJ_HORACO2)
Local nPosCont1	 := If(IsInCallStack("MNTA400"),STJ->TJ_POSCONT,M->TJ_POSCONT)
Local nPosCont2	 := If(IsInCallStack("MNTA400"),STJ->TJ_POSCON2,M->TJ_POSCON2)
Local cContGar	 := ""
Local cGarant	 := ""
Local cLocaliz	 := ""
Local cTPZOrdem	 := ""
Local lGarTemp	 := .F.//Indica se tem garantia por tempo
Local lGarCont	 := NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)//Indica se tem garantia por contador
Local aAreaSTJ	 := STJ->(GetArea())
Local aHisCont1	 := NGACUMEHIS(cCodBem,dDtIni,cHoraCOnt,1,"A",,,.F.)//Retorna previsao do contador1 anterior
Local aHisCont2	 := NGACUMEHIS(cCodBem,dDtIni,cHoraCont2,2,"A",,,.F.)//Retorna previsao do contador2 anterior
Local nCont1	 := aHisCont1[2]+(nPosCont1 - aHisCont1[1])//Previsão do acumulado do contador1
Local nCont2	 := aHisCont2[2]+(nPosCont2 - aHisCont2[1])//Previsão do acumulado do contador2
Local aAreaSTL	 := STL->(GetArea())
Private aGarant	 := {}
Private aMsgGar	 := {}
Private aOrdTpz	 := {}
Private lCancela := .T.
Private lGarant	 := .F.
Private lTemOs	 := .F.

nPOSINS := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_TIPOREG"})
nPOSCOD := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
nPOSLOC := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_LOCAPLI"})
nPOSDES := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_DESTINO"})
nPOSQTD := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_QUANTID"})
nPOSOBS := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_OBSERVA"})
nPosUni := aSCAN(aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_UNIDADE"})

For i := 1 to len(aCols)
	If !aCols[i][Len(aCols[i])] .And. aCols[i][nPOSINS] == "P"  .Or. aCols[i][nPOSINS] == "T"
		dDtIni  := If(IsInCallStack("MNTA400"),STJ->TJ_DTORIGI,M->TJ_DTORIGI)
		cCodBem := If(IsInCallStack("MNTA400"),STJ->TJ_CODBEM,M->TJ_CODBEM)
		dbSelectArea("TPZ")
		dbSetOrder(1)
		If dbSeek(xFilial("TPZ")+cCodBem+aCols[i,nPOSINS]+aCols[i][nPOSCOD]+aCols[i][nPOSLOC])
			While !Eof() .And. xFilial("TPZ")+cCodBem+aCols[i][nPOSINS]+aCols[i][nPOSCOD]+aCols[i][nPOSLOC] == TPZ->TPZ_FILIAL+TPZ->TPZ_CODBEM+TPZ->TPZ_TIPORE+TPZ->TPZ_CODIGO+aCols[i][nPOSLOC]
				nPosCon   := 0
				nContador := 0
				cContGar  := ""
				cTipoGar  := ""
				lGarTemp  := .F.
				If TPZ->TPZ_UNIGAR = "D"
					dDtVal := TPZ->TPZ_DTGARA + TPZ->TPZ_QTDGAR
					cTipoGar := STR0134 //"dias."
					lGarTemp := .T.
				ElseIf TPZ->TPZ_UNIGAR = "S"
					dDtVal := TPZ->TPZ_DTGARA + (TPZ->TPZ_QTDGAR * 7)
					cTipoGar := STR0135 //"semanas."
					lGarTemp := .T.
				ElseIf TPZ->TPZ_UNIGAR = "M"
					dDtVal   := NGSomaMes(TPZ->TPZ_DTGARA,TPZ->TPZ_QTDGAR)
					cTipoGar := STR0136 //"meses."
					lGarTemp := .T.
				EndIf

				cProduto := NGSEEK("SB1",aCols[i][nPOSCOD],1,"B1_DESC")
				cLocaliz := NGSEEK("TPS",TPZ->TPZ_LOCGAR,1,"TPS_NOME")

				If lGarTemp
					//Caso tipo da unidade esteja preenchido, possui garantia por tempo, entao valida tambem por contador
					If dDtIni <= dDtVal .And. dDtIni >= TPZ->TPZ_DTGARA
						If Empty(TPZ->TPZ_ORDEM)
							//Sem ordem de serviço as peças foram adquiridas na compra do bem, valida pelo acumulado de inclusão
							cMsgGar := STR0149  //"Peças adquiridas na compra do bem "
							If lGarCont
								dbSelectArea("TPY")
								dbSetOrder(1)
								If dbSeek(xFilial("TPY")+TPZ->TPZ_CODBEM+TPZ->TPZ_CODIGO+TPZ->TPZ_LOCGAR)
									If TPZ->TPZ_CONGAR == "1"
										dbSelectArea("STP")
										dbSetOrder(8)
										If dbSeek(xFilial("STP")+TPZ->TPZ_CODBEM+"I")
					    					nPosCon := STP->TP_ACUMCON
					    					nContador := nCont1
					    				EndIf
				    				Else
				    					dbSelectArea("TPP")
										dbSetOrder(8)
										If dbSeek(xFilial("TPP")+TPZ->TPZ_CODBEM+"I")
					    					nPosCon := TPP->TPP_ACUMCO
					    					nContador := nCont2
					    				EndIf
				    				EndIf
								EndIf
							EndIf
						Else
							//Por ordem de servico, valida de acordo com o acumulado da O.S.
							cMsgGar := STR0137
							If lGarCont
								dbSelectArea("STJ")
								dbSetOrder(1)
								If dbSeek(xFilial("STJ")+TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO)
									If TPZ->TPZ_CONGAR == "1"
				    					nPosCon := NGACUMEHIS(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO1,1,"E",,,.F.)[2]
				    					nContador := nCont1
				    				Else
				    					nPosCon := NGACUMEHIS(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO2,2,"E",,,.F.)[2]
				    					nContador := nCont2
				    				EndIf
								EndIf
							EndIf
						EndIf

						If lGarCont .and. nPosCon <> 0 .and. TPZ->TPZ_QTDCON > 0 .and. (nPosCon + TPZ->TPZ_QTDCON) > nContador
	    					cContGar := STR0154+" ("+AllTrim(Str(TPZ->TPZ_QTDCON))+"). "+STR0155+AllTrim(Str(nPosCon))+". "+STR0156+AllTrim(Str((nPosCon + TPZ->TPZ_QTDCON)))//" e por contador trabalhado"###"Contador anterior: "###"Até contador: "
	    				EndIf
	    				//Adiciona em um array as ordens de servico dos produtos em garantia
	    				nPosTpz := aSCAN(aOrdTpz,{|x| AllTrim(Upper(X[1])) == TPZ->TPZ_ORDEM})
	    				If nPosTpz == 0 .And. !Empty(TPZ->TPZ_ORDEM)
		    				aAdd(aOrdTpz,{TPZ->TPZ_ORDEM})
		    				lTemOs := .T.
		    			EndIf

						aAdd(aMsgGar,{aCols[i][nPOSCOD],cMsgGar+TPZ->TPZ_ORDEM+", "+"("+Alltrim(aCols[i][nPOSCOD])+")"+Alltrim(cProduto)+" - "+Alltrim(Str(aCols[i][nPOSQTD]))+" "+Alltrim(aCols[i][nPosUni])+STR0138+dToc(TPZ->TPZ_DTGARA)+; // "#Foram incluidos na O.S. " ## " no dia "
							If(!Empty(TPZ->TPZ_LOCGAR),STR0139+AllTrim(TPZ->TPZ_LOCGAR)+" - "+AllTrim(cLocaliz),"")+;//" na localização "
							STR0140+Alltrim(Str(TPZ->TPZ_QTDGAR))+" "+Alltrim(cTipoGar)+cContGar+". "+; //" que possuia a garantia de "
							STR0141}) //"Dessa forma a troca desse(s) produto(s) poderá violar a garantia.#"

						AAdd(aGarant,{TPZ->TPZ_ORDEM,Chr(13)+Chr(10)+"("+Alltrim(aCols[i][nPOSCOD])+")"+Alltrim(cProduto)+" - "+Alltrim(Str(aCols[i][nPOSQTD]))+" "+Alltrim(aCols[i][nPosUni])+STR0138+dToc(TPZ->TPZ_DTGARA)+;//" no dia "
							If(!Empty(TPZ->TPZ_LOCGAR),STR0139+AllTrim(TPZ->TPZ_LOCGAR)+" - "+AllTrim(cLocaliz),"")+;//" na localização "
							STR0140+Alltrim(Str(TPZ->TPZ_QTDGAR))+" "+Alltrim(cTipoGar)+cContGar+". "+Chr(13)+Chr(10)+Chr(13)+Chr(10)}) //" que possuia a garantia de "

						lGarant  := .T.

						For x := 1 to len(aMsgGar)
							If aMsgGar[x][1] == aCols[i][nPOSCOD] .And. (Inclui .Or. Altera)
								If !(aMsgGar[x][2] $ aCols[i][nPOSOBS])
									aCols[i][nPOSOBS] := aCols[i][nPOSOBS]
									If !Empty(aCols[i][nPOSOBS])
										aCols[i][nPOSOBS] += Chr(13) + Chr(10) + Chr(13) + Chr(10)
									EndIf
									aCols[i][nPOSOBS] += aMsgGar[x][2]
								EndIf
							EndIf
						Next x
						Exit
					EndIf
				Else
					//Caso tipo da unidade nao esteja preenchido, nao possui garantia por tempo, validando somente por contador
					If lGarCont
						If Empty(TPZ->TPZ_ORDEM)
							//Sem ordem de serviço as peças foram adquiridas na compra do bem, valida pelo acumulado de inclusão
							cMsgGar := STR0149  //"Peças adquiridas na compra do bem "
							dbSelectArea("TPY")
							dbSetOrder(1)
							If dbSeek(xFilial("TPY")+TPZ->TPZ_CODBEM+TPZ->TPZ_CODIGO+TPZ->TPZ_LOCGAR)
								If TPZ->TPZ_CONGAR == "1"
									dbSelectArea("STP")
									dbSetOrder(8)
									If dbSeek(xFilial("STP")+TPZ->TPZ_CODBEM+"I")
				    					nPosCon := STP->TP_ACUMCON
				    					nContador := nCont1
				    				EndIf
			    				Else
			    					dbSelectArea("TPP")
									dbSetOrder(8)
									If dbSeek(xFilial("TPP")+TPZ->TPZ_CODBEM+"I")
				    					nPosCon := TPP->TPP_ACUMCO
				    					nContador := nCont2
				    				EndIf
			    				EndIf
							EndIf
						Else
							//Por ordem de servico, valida de acordo com o acumulado da O.S.
							cMsgGar := STR0137

							dbSelectArea("STJ")
							dbSetOrder(1)
							If dbSeek(xFilial("STJ")+TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO)
								If TPZ->TPZ_CONGAR == "1"
			    					nPosCon := NGACUMEHIS(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO1,1,"E",,,.F.)[2]
			    					nContador := nCont1
			    				Else
			    					nPosCon := NGACUMEHIS(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO2,2,"E",,,.F.)[2]
			    					nContador := nCont2
			    				EndIf
							EndIf
						EndIf
						If nPosCon <> 0 .and. TPZ->TPZ_QTDCON > 0 .and. (nPosCon + TPZ->TPZ_QTDCON) > nContador

	    					cContGar := STR0157+" ("+AllTrim(Str(TPZ->TPZ_QTDCON))+"). "+STR0155+AllTrim(Str(nPosCon))+". "+STR0156+AllTrim(Str((nPosCon + TPZ->TPZ_QTDCON)))//" por contador trabalhado"###"Contador anterior: "###"Até contador: "

							aAdd(aMsgGar,{aCols[i][nPOSCOD],cMsgGar+TPZ->TPZ_ORDEM+", "+"("+Alltrim(aCols[i][nPOSCOD])+")"+Alltrim(cProduto)+" - "+Alltrim(Str(aCols[i][nPOSQTD]))+" "+Alltrim(aCols[i][nPosUni])+STR0138+dToc(TPZ->TPZ_DTGARA)+;// "#Foram incluidos na O.S. " ## " no dia "
								If(!Empty(TPZ->TPZ_LOCGAR),STR0139+AllTrim(TPZ->TPZ_LOCGAR)+" - "+AllTrim(cLocaliz),"")+;//" na localização "
								STR0158+cContGar+". "+; //" que possuia a garantia "
								STR0141}) //"Dessa forma a troca desse(s) produto(s) poderá violar a garantia.#"

							AAdd(aGarant,{TPZ->TPZ_ORDEM,Chr(13)+Chr(10)+"("+Alltrim(aCols[i][nPOSCOD])+")"+Alltrim(cProduto)+" - "+Alltrim(Str(aCols[i][nPOSQTD]))+" "+Alltrim(aCols[i][nPosUni])+" "+STR0138+dToc(TPZ->TPZ_DTGARA)+; //" na localização "
								If(!Empty(TPZ->TPZ_LOCGAR),STR0139+AllTrim(TPZ->TPZ_LOCGAR)+" - "+AllTrim(cLocaliz),"")+;//" na localização "
								STR0158+cContGar+". "+Chr(13)+Chr(10)+Chr(13)+Chr(10)}) //" que possuia a garantia "

							lGarant  := .T.

							For x := 1 to len(aMsgGar)
								If aMsgGar[x][1] == aCols[i][nPOSCOD] .and. INCLUI
									aCols[i][nPOSOBS] := aCols[i][nPOSOBS] + aMsgGar[x][2]
								ElseIf aMsgGar[x][1] == aCols[i][nPOSCOD] .and. ALTERA
									aCols[i][nPOSOBS] := aMsgGar[x][2]
								EndIf
							Next x
							Exit
						EndIf
					EndIf
				EndIf

				dbSelectArea("TPZ")
				dbSkip()
			End
		EndIf
	EndIf
Next i

If lGarant
	aSort(aGarant,,,{|x,y| x[1] < y[1]})

	If Empty(aGarant[1][1])
		cGarant := STR0149 + Chr(13)+Chr(10) //"Peças adquiridas na compra do bem "
	Else
		cGarant := STR0133+aGarant[1][1]+":"+Chr(13)+Chr(10)
	EndIF

	cTPZOrdem := aGarant[1][1]

	For j := 1 to len(aGarant)
		If cTPZOrdem <> aGarant[j][1]
			cGarant := cGarant + STR0133+aGarant[j][1]+":"+Chr(13)+Chr(10)
		EndIf
		cGarant := cGarant +  aGarant[j][2]
		cTPZOrdem := aGarant[j][1]
	Next j

	cGarant := cGarant +STR0148 //"Dessa forma a troca desse(s) produto(s) poderá violar a garantia."
	RestArea(aAreaSTJ)
	RestArea(aAreaSTL)
	MntVerLog(cGarant,1)
EndIf

RestArea(aAreaSTL)
RestArea(aAreaSTJ)

Return lCancela

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MntVerLog ³ Autor ³Taina Alberto Cardoso  ³ Data ³16/08/2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Exibe o arquivo de log da quebra de garantia                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA420                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MntVerLog(cArq,nRecno)

Local cTexto := ""
Local oFont, oDlgl
Local cMask  := STR0144 //"Arquivos Texto (*.TXT) |*.txt|"
Local nX


//Guarda as variaveis de memoria da STJ
Local aMemory := NGGetMemory("STJ")

Private cFILTER := ""
Private aLog   := Array(1)
Private cOrdem := ""
Private dDtOrigi := CtoD(""), cBem := "" , cServico := "", nContador := 0, cHoraCont := "", nCont2 := 0, cHrcont2 := "", cSituaca := ""
Private cTerceiro := "", cTermino := "", cTipoRet := "", dDTMRINI := CTOD(""), cHOMRINI := "", dDTMRFIM := CTOD(""), cHOMRFIM := ""

//Monta a condicao de filtro para a consulta de O.S.
If lTemOs
	For nX := 1 to len(aOrdTpz)
		cFILTER += "STJ->TJ_ORDEM == '" + aOrdTpz[nX][1]+ "'"
		If nX <> Len(aOrdTpz)
			cFILTER += " .Or. "
		EndIf
	Next nX
EndIf

If !Empty(cArq)
	cTexto := cArq
	aLog[1] := {cTexto}
	cLog := STR0145 //"Atualizacao de Dados"
	DEFINE FONT oFont NAME "Courier New" SIZE 5,0
	DEFINE MSDIALOG oDlgl TITLE STR0146 From 3,0 to 340,417 COLOR CLR_BLACK,CLR_WHITE PIXEL //"Verificar violação de garantia"
		@ 5,5 GET oMemo  VAR cTexto MEMO SIZE 200,145 OF oDlgl PIXEL
			oMemo:bRClicked := {||AllwaysTrue()}
			oMemo:oFont := oFont
			oMemo:lReadOnly := .T.

		DEFINE SBUTTON FROM 153,145 TYPE 1  ACTION oDlgl:End() ENABLE OF oDlgl PIXEL
		DEFINE SBUTTON FROM 153,175 TYPE 2  ACTION (lCancela := .F., oDlgl:End()) ENABLE OF oDlgl PIXEL
		DEFINE SBUTTON FROM 153,115 TYPE 13 ACTION (cFile:=cGetFile(cMask,OemToAnsi(STR0147)),If(cFile="",.T.,MemoWrite(cFile,cTexto)),) ENABLE OF oDlgl PIXEL  //"Salvar Como..."
		If lTemOs
			DEFINE SBUTTON FROM 153,85  TYPE 9  ACTION MNC600ORD(M->TJ_CODBEM,cFILTER) ENABLE OF oDlgl PIXEL
		EndIf
	ACTIVATE MSDIALOG oDlgl CENTERED
EndIf

//Retorna as variaveis de memoria da STJ
NgRestMemory(aMemory)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MNT420DTOPºAutor  ³Taina A. Cardoso    º Data ³  14/12/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica a data da ordem de servico para gravar a data      º±±
±±º          ³de emissao da OP.                                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MNTA420                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MNT420DTOP(dDtEmissao)

	Private dDTULMES  := SuperGetMV("MV_ULMES",.F.,STOD(""))
	Private cUsaIntEs := AllTrim(GetMV("MV_NGMNTES"))

	If dDtEmissao >= dDataBase .And. dDtEmissao > dDTULMES
		Return dDtEmissao
	ElseIf cUsaIntEs == "S" .And. dDtEmissao <= dDTULMES
		dDtEmissao := dDTULMES+1
	EndIf

Return dDtEmissao

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCHKLIMP
Verifica a data inicio da ordem de servico se nao é menor que o
Parametro 'MV_ULMES'

@author	Taina A. Cardoso
@since	15/12/11
/*/
//---------------------------------------------------------------------
Function MNT420DTIN()

	Private dDTULMES  := SuperGetMV("MV_ULMES",.F.,STOD(""))
	Private cUsaIntEs := AllTrim(GetMV("MV_NGMNTES"))

	If INCLUI
		If cUsaIntEs == "S" .And. M->TJ_DTORIGI <= dDTULMES
			MsgInfo(STR0152+DTOC(dDTULMES)+".",STR0153) //"A data de origem não pode ser menor ou igual que a data do ultimo fechamento do estoque " ## "INCONFORMIDADE"
			Return .F.
		EndIf
	EndIf

	//Validacao para quando a data for maior que a data base feche os campos de contador
	If (TIPOACOM .Or. TIPOACOM2) .And. M->TJ_DTORIGI > dDataBase

		TIPOACOM	  := .F.
		TIPOACOM2	  := .F.
		M->TJ_POSCONT := 0
		M->TJ_HORACO1 := "  :  "
		M->TJ_POSCON2 := 0
		M->TJ_HORACO2 := "  :  "
	Else
		dbSelectArea("ST9")
		dbSetOrder(1)
		If dbSeek(xFILIAL("ST9")+M->TJ_CODBEM)
			TIPOACOM := If(st9->t9_temcont = "S" ,.T.,.F.)
		EndIf

		//FindFunction remover na release GetRPORelease() >= '12.1.027'
		If FindFunction("MNTCont2")
			TIPOACOM2 := MNTCont2(xFilial("TPE"), M->TJ_CODBEM)
		Else
			dbSelectArea("TPE")
			dbSetOrder(1)
			If dbSeek(xFILIAL("TPE")+M->TJ_CODBEM)
				TIPOACOM2 := .T.
			EndIf
		EndIf
	EndIf

	If TIPOACOM .And. !Empty( NGUSELANEX( M->TJ_CODBEM ) )
						
		M->TJ_POSCONT := NGACUMEHIS( M->TJ_CODBEM, M->TJ_DTORIGI, M->TJ_HORACO1, 1, 'E' )[1]
		
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCHKLIMP
Cheka a quantidade limite do produto digitado.
cVBEM		- Codigo do bem
cVCODIGO	- Codigo do produto
cVQUANTID	- Quantidade do produto digitado

@author	Elisangela Costa
@since		02/12/2003
@version	MP12
/*/
//---------------------------------------------------------------------
Function NGCHKLIMP( cVBEM,cVCODIGO,nVQUANTID )

	Local lRet := .T.

	If NGIFDBSEEK( "TPY",cVBEM+cVCODIGO,1 ) //Verifica se encontra o código do bem e produto no cadastro de peças de reposição do Bem.
		If nVQUANTID > TPY->TPY_QUANTI //Se a quantidade de produto informado for maior que a quantidade quantidade de peças de reposição para o bem.
			MsgInfo( STR0189 + AllTrim( cVBEM ) + ".", STR0018 ) //"A quantidade do produto informado e maior que a quantidade de pecas de reposicao para o bem "###"ATENCAO"
			lRet := .F.
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NG420VLTR
 Valida tipo de registro.
 Caso: seja terceiro, almoxarifado nulo, e o MNT possui Intregração com o
 Compras ou Estoque irá setar para esse campo o valor padrão do parametro
 MV_NGLOCPA.

@author Maicon André Pinheiro.
@since	14/01/2016

@sample NG420VLTR()

@param  [aColsUse], Array   , Acols de Insumos.
@param  [nLinAtu] , Numérico, Linha atual que esta posicionada.
@param  [aHeadUse], Array   , aHeader de insumos
@return .T.
/*/
//---------------------------------------------------------------------
 Function NG420VLTR( aColsUse, nLinAtu, aHeadUse )

	Local nLin       := 1
	Local nLoc       := 0
	Local nTIP       := 0
	Local cIntComps	 := SuperGetMv( "MV_NGMNTCM",.F.,"N" ) //Integração entre MNT e Compras
	Local cIntEstoq	 := SuperGetMv( "MV_NGMNTES",.F.,"N" ) //Integração entre MNT e Estoque
	Local cLocPad    := Padr( SuperGetMV( 'MV_NGLOCPA', .F., '01' ), TamSx3( 'NNR_CODIGO' )[1] )

	Default aColsUse := aCols
	Default aHeadUse := aHeader
	Default nLinAtu  := n

	nLoc := aScan( aHeadUse, { |x| Trim( Upper( x[2] ) ) == 'TL_LOCAL'   } )
	nTIP := aScan( aHeadUse, { |x| Trim( Upper( x[2] ) ) == 'TL_TIPOREG' } )

	If Len( aColsUse ) == 1
		If aTail( aColsUse[1] )
			Return .T.
		EndIf
	Else
		nLin := nLinAtu
	EndIf

	If !Empty( cLocPad ) .And. ( cIntComps == "S" .Or. cIntEstoq == "S" )
		If Empty( aColsUse[nLin][nLoc] ) .And. M->TL_TIPOREG == 'T'
			aColsUse[nLin][nLoc] := cLocPad
		Else
		    aColsUse[nLin][nLoc] := ""
		EndIf
	EndIf

 Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT420IND4
Valida se usuario retirou itens ja existentes na STL para posterior avaliacao de seus empenhos.

@author	Hugo R. Pereira
@since	21/12/15
@param	cOrdemServ	Numero da ordem de servico
@param	cPlano		Numero do plano da ordem de servico
@param	aHeaderIns	Cabecalho da getdados de insumos
@param	aColsIns		Linhas/Itens da getdados de insumos
@param	aProdEmp		Array que sera atualizado com os insumos encontrados na STL que nao estao presentes na getdados atual.
					Necessario passar este parametro com @. Ex: MNT420IND4( cOrdemServ, cPlano, aHeaderIns, aColsIns, @aProdEmp )
/*/
//---------------------------------------------------------------------
Function MNT420IND4( cOrdemServ, cPlano, aHeaderIns, aColsIns, aProdEmp )

	Local aArea		:= GetArea()
	Local aAreaSTL	:= STL->(GetArea())
	Local nPosArr, nPosIns

	Local	nTpReg := aScan( aHeaderIns, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" }), ;
			nCodPr := aScan( aHeaderIns, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO"  }), ;
			nLocal := aScan( aHeaderIns, {|x| AllTrim(Upper(X[2])) == "TL_LOCAL"   })

	Default aProdEmp := {}

	dbSelectArea("STL")
	dbSetOrder(1)
	If dbSeek( xFilial("STL") + cOrdemServ + cPlano )

		While !Eof() .And. ( STL->TL_FILIAL + STL->TL_ORDEM + STL->TL_PLANO == xFilial("STL") + cOrdemServ + cPlano )

			If Trim(STL->TL_SEQRELA) == "0" .And. STL->TL_TIPOREG == "P" .And. ( nPosIns := aScan( aColsIns,{|x|	x[nTpReg] == STL->TL_TIPOREG .And. x[nCodPr] == STL->TL_CODIGO .And. ;
															x[nLocal] == STL->TL_LOCAL } ) ) == 0

		    	If ( nPosArr := aScan( aProdEmp, {|x| x[1] + x[2] == STL->TL_CODIGO + STL->TL_LOCAL } ) ) == 0
		      		aAdd( aProdEmp, { STL->TL_CODIGO, STL->TL_LOCAL, 0 } )
		      	EndIf

			EndIf

			STL->(dbSkip())
		End
	EndIf

	RestArea(aAreaSTL)
	RestArea(aArea)

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT420VSD4
Valida empenho de produtos.

@author	Hugo R. Pereira
@since	21/12/15
@param	cOrdemServ	Numero da ordem de servico
@param	aInfoProd		Informacoes dos produtos
					aInfoIns = { cProd, cLocal, nQtdTot }

/*/
//---------------------------------------------------------------------
Function MNT420VSD4( cOrdemServ, aInfoProd )

	Local aArea		:= GetArea()
	Local aAreaSD4	:= SD4->(GetArea())
	Local lReturn 	:= .T.
	Local nIndProd, cCodPro, cCodArmz

	Local cOrdemProd := Padr(cOrdemServ + "OS001", TAMSX3("D4_OP")[1] )
	Local lReturnOK	 := .T.
	Local cIncons	 := ""

	dbSelectArea("SD4")
	dbSetOrder(2) // D4_FILIAL+D4_OP+D4_COD+D4_LOCAL

	For nIndProd := 1 To Len( aInfoProd )

		cCodPro	 := Padr( aInfoProd[nIndProd][1], TAMSX3("B1_COD")[1] )
		cCodArmz	 := Padr( aInfoProd[nIndProd][2], TAMSX3("B1_LOCPAD")[1] )

		// Se encontrar algum empenho para o produto com origem nesta ordem de servico
		If SD4->( dbSeek( xFilial("SD4") + cOrdemProd + cCodPro + cCodArmz ) ) // Filial + Produto + Ordem de Producao

			// Se a quantidade total do produto for menor que a quantiade empenhada na SD4 (Usuario diminuiu a quantidade do insumo produto)
			// E se ja houve alguma baixa para este empenho
			If aInfoProd[nIndProd][3] < ( SD4->D4_QTDEORI - SD4->D4_QUANT )
				cIncons += "[" + cCodPro + " / " + cCodArmz + " ] - " + Trim( NGSEEK("SB1", cCodPro, 1, "B1_DESC" ) ) + "  (" + cValToChar(SD4->D4_QTDEORI - SD4->D4_QUANT) + ")" +  CRLF
				lReturn := .F.
			EndIf

		EndIf

	Next nIndProd

	RestArea(aAreaSD4)
	RestArea(aArea)

	If !( lReturnOK := Empty(cIncons) )
		NGMSGMEMO( STR0196, STR0197 + CRLF + CRLF + cIncons )
	EndIf

Return lReturnOK

//-------------------------------------------------------------------------
/*/{Protheus.doc} MNT420FIT
Controle de semafaro para a gravação de insumos.
@type function

@author	Tainã Alberto Cardoso
@since	02/06/16

@sample MNT420FIT( .T. )

@param  lLock, Lógico, Define se bloqueia(.T.) ou desbloqueia(.F.) rotina.
@return lRetT, Lógico, Define se o processo foi realizado com sucesso.

@obs Reescrito por: Alexandre Santos, 26/12/2018.
/*/
//-------------------------------------------------------------------------
Function MNT420FIT( lLock )

	Local lRetT  := .F.

	If lLock
		Processa( {|| lRetT := NGTRAVAROT( 'NG420GRAVA' ) }, STR0034 ) //Aguarde ..preparando para gerar insumos...
	Else
		NGDETRAVAROT( 'NG420GRAVA' )
		lRetT := .T.
	EndIf

Return lRetT

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT420BSA
Verifica se existe uma Baixa de S.A. para o insumo Previsto.

@author	Tainã Alberto Cardoso
@since	05/12/16

@param [cNumSA]   , Caracter, Código da S.A.
@param [cItem]	  , Caracter, Item da S.A.
@param [lMsg]     , Lógico  , Variavel para veriricar se deve mostrar a mensagem de alert.
@param [aArraySC] , Array   , aArraySC[1] - Numero da OS
							  aArraySC[2] - Código do Produto
							  aArraySC[3] - Número da SC
							  aArraySC[4] - Item SC
@sample MNT420BSA()

@return lRet      , Lógico  , Veririfica se p registro é valido.

/*/
//---------------------------------------------------------------------------------------------------
Function MNT420BSA(cNumSA, cItem, lMsg, aArraySC)

	Local cAliasQry   := GetNextAlias()
	Local cTipoReg    := ""
	Local nPosTpReg   := IIf(Type("aHeader") == "A", aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"}), 0)
	Local nPosQntd    := IIf(Type("aHeader") == "A", aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_QUANTID"}), 0)
	Local nPosNumSA   := IIf(Type("aHeader") == "A", aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_NUMSA"})  , 0)
	Local nPosItemSA  := IIf(Type("aHeader") == "A", aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_ITEMSA"}) , 0)
	Local nPosLocal   := IIf(Type("aHeader") == "A", aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_LOCAL"})  , 0)
	Local nPosNumSC   := 0
	Local nPosItemSC  := 0
	Local lRet        := .T.
	Local lIntegRM    := AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
	Local lInsTer     := .F.
	Local nTotIns     := 0
	Local nQtSA       := 0

	//Atualiza para acesso por outras rotinas
	Private cUsaIntEs := SuperGetMv( "MV_NGMNTES",.F.,"N" ) //Integração com Estoque
	Private cUsaIntCp := SuperGetMv( "MV_NGMNTCM",.F.,"N" ) //Integração com Compras
	Private cUsaNaoSa := cGerSA //Se gera SA (S) ou SC (N)

	Default cNumSA    := ''
	Default cItem     := ''
	Default lMsg      := .T.
	Default aArraySC  := {}

	If nPosTpReg > 0

		aArraySC  := { M->TJ_ORDEM, GDFieldGet( 'TL_CODIGO', oGet:nAt, .F., oGet:aHeader, oGet:aCols ), GDFieldGet( 'TL_NUMSC',;
			oGet:nAt, .F., oGet:aHeader, oGet:aCols ), GDFieldGet( 'TL_ITEMSC', oGet:nAt, .F., oGet:aHeader, oGet:aCols ) }

		nPosNumSC   := GDFieldPos( 'TL_NUMSC' , oGet:aHeader )
		nPosItemSC  := GDFieldPos( 'TL_ITEMSC', oGet:aHeader )

		cTipoReg := oGet:aCols[oGet:nAt][nPosTpReg]
		If Empty(cTipoReg)
			cTipoReg := M->TL_TIPOREG
		EndIf

		If cTipoReg == "T"//Se for insumo do tipo Terceiro altera a variável cCodPro

			aArraySC[2] := NGProdMNT("T")[1]

			If !Empty( GDFieldPos( 'TL_FORNEC', oGet:aHeader ) )

				lInsTer := .T.
			
			EndIf

		EndIf

	EndIf

	If Empty(cNumSA) .And. nPosNumSA > 0
		cNumSA := oGet:aCols[oGet:nAt][nPosNumSA]
		cItem  := oGet:aCols[oGet:nAt][nPosItemSA]
	EndIf

	If !Empty(cNumSA)
		//Verificar se possui integração com BackOffice
		If lIntegRM

			If ReadVar() == 'M->TL_QUANTID'

				nQtSA := M->TL_QUANTID

			EndIf

			If nPosQntd > 0

				// Processa aCols para somar quantidade dos insumos que possuem o mesmo Numero e Item da S.A.
				For nTotIns := 1 To Len( oGet:aCols )

					If oGet:nAt != nTotIns .And. !aTail( oGet:aCols[ oGet:nAt ] ) .And.;
						( cNumSA + cItem ) == ( oGet:aCols[ nTotIns, nPosNumSA ] + oGet:aCols[ nTotIns, nPosItemSA ] )

						nQtSA += oGet:aCols[ nTotIns, nPosQntd ]

					EndIf

				Next nTotIns

			EndIf

			// Chama a função para verificar o Status do produto RM
			If Type("aHeader") == "A"
				lRet := NGMUTRAREQ( 'SCP', cNumSA, xFilial( 'SCP' ), lMsg, cItem, nQtSA, oGet:aCols[ oGet:nAt, nPosLocal ] )
			Else
				lRet := NGMUTRAREQ( 'SCP', cNumSA, xFilial( 'SCP' ), lMsg, cItem, STL->TL_QUANTID, STL->TL_LOCAL )
			EndIf


		ElseIf cUsaIntEs == "S"

			cQuery := " SELECT COUNT(CP_NUM) QTD FROM " + RetSqlName("SCP")
			cQuery += " WHERE CP_NUM = '" +cNumSA+ "' AND CP_ITEM = '" +cItem+ "' "
			cQuery += " AND CP_FILIAL = '"+xFilial("SCP")+"'"
			cQuery += " AND CP_PREREQU <> ' ' AND D_E_L_E_T_ = ' ' " //Implementada validação do campo Pré-Requisição
			cQuery := ChangeQuery(cQuery)
			dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

			If (cAliasQry)->QTD > 0
				lRet :=  .F.
				If lMsg
					MSGINFO(STR0199+chr(13)+; //"Esse insumo nao pode ser alterado ou excluido porque esta vinculado a uma"
						STR0200+Chr(13)+Chr(13) ) //"movimentacao originaria de um movimento interno do estoque."
				EndIf

			EndIf

			(cAliasQry)->(dbCloseArea())

		EndIf
	EndIf

	If cUsaIntCp == "S" .And. cUsaNaoSa == "N"

		cAliasQry := GetNextAlias()
		cOp       := aArraySC[1] + 'OS001'
		cWhere    := '%'

		// Define se a pesquisa considera o fornecedor.
		cWhere    += IIf( lInsTer, ' AND C1_FORNECE = ' + ValToSql( GDFieldGet( 'TL_FORNEC', oGet:nAt, .F., oGet:aHeader, oGet:aCols ) ), '' )

		// Define o item da S.C. de pesquisa.
		cWhere    += IIf( nPosItemSC > 0, ' AND C1_ITEM    = ' + ValToSql( aArraySC[4] ), '' )

		// Define S.C. de pesquisa.
		cWhere    += IIf( nPosNumSC > 0 , ' AND C1_NUM     = ' + ValToSql( aArraySC[3] ), '' )

		cWhere    += '%'

		BeginSQL Alias cAliasQry

			SELECT
				C1_COTACAO,
				C1_NUM
			FROM
				%table:SC1%
			WHERE
				C1_OP      = %exp:cOp%         AND
				C1_PRODUTO = %exp:aArraySC[2]% AND
				C1_FILIAL  = %xFilial:SC1%     AND
				( C1_COTACAO <> ' ' OR
				  C1_PEDIDO <> ' ' )           AND
				%NotDel%
				%exp:cWhere%

		EndSQL

		If (cAliasQry)->( !EoF() )

			If !Empty( (cAliasQry)->C1_NUM ) .And. ( !Empty( (cAliasQry)->C1_COTACAO ) .And.;
			   !( SubStr( (cAliasQry)->C1_COTACAO, 1, 6 ) $ 'IMPORT#XXXXXX' ) )

				// Este insumo não poderá ser alterado ou excluído pois possui vínculo com uma solicitação de compras com cotação em aberto.
				Help( '', 1, "NGATENCAO", , STR0204, 3, 1 )
				lRet := .F.

			Else

				lRet :=  .F.
				MSGINFO(STR0199+chr(13)+; //"Esse insumo nao pode ser alterado ou excluido porque esta vinculado a uma"
				STR0200+Chr(13)+Chr(13) ) //"movimentacao originaria de um movimento interno do estoque."

			EndIf

		EndIf

		(cAliasQry)->(dbCloseArea())

	EndIf

Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} fVldAltSA
Realiza validação considerando se o insumo sofreu alteração e devera recriar
a solicitação de armazém.
@type function

@author Alexandre Santos
@since 01/04/2019

@sample fVldAltSA( 1, aCols, aHeader )

@param  nRecSTL , numeric, Recno do registro STL já gravado em base.
@param  xInputs , array  , aCols no qual consta as alterações sofridas pelos insumos.
@param  [aCabec], array  , aHeader de insumos utilizado na rotina.

@return boolean  , Define se o insumo sofreu alguma alteração referente a S.A.
/*/
//-----------------------------------------------------------------------------------
Function fVldAltSA( nRecSTL, xInputs, aCabec )

	Local aAreaTL  := STL->( GetArea() )
	Local aArea    := GetArea()
	Local nPosit   := 0
	Local nInd1    := 0

	/*-------------------------------------------+
	| Váriaveis iniciadas com valores utilizados |
	| no MNTNG, no qual não possui aHeader.      |
	+-------------------------------------------*/
	Local nPosCod  := 3
	Local nPosQtd  := 7
	Local nPosAlx  := 12
	Local nPosObs  := 13
	Local nPosRec  := 15
	Local nPosNSA  := 0
	Local nPosISA  := 0
	
	Default aCabec := {}

	dbSelectArea( 'STL' )
	dbGoTo( nRecSTL )

	If ValType( xInputs ) == 'A'

		If !Empty( aCabec )

			nPosRec  := GDFieldPos( 'TL_REC_WT' , aCabec )
			nPosQtd  := GDFieldPos( 'TL_QUANTID', aCabec )
			nPosCod  := GDFieldPos( 'TL_CODIGO' , aCabec )
			nPosAlx  := GDFieldPos( 'TL_LOCAL'  , aCabec )
			nPosObs  := GDFieldPos( 'TL_OBSERVA', aCabec )
			nPosNSA  := GDFieldPos( 'TL_NUMSA'  , aCabec )
			nPosISA  := GDFieldPos( 'TL_ITEMSA' , aCabec )

		EndIf
		
		/*------------------------------+
		| Validação considerando aCols. |
		+------------------------------*/
		nPosit := aScan( xInputs, { |x|  x[nPosRec] == nRecSTL .And. ( aTail( x ) .Or. !( x[nPosCod] == STL->TL_CODIGO ) .Or.;
			x[nPosQtd] != STL->TL_QUANTID .Or. !( x[nPosAlx] == STL->TL_LOCAL ) .Or. ( nPosObs == 0 .Or. !( x[nPosObs] == STL->TL_OBSERVA ) ) ) } )

		If nPosit == 0 .And. nPosNSA > 0 .And. nPosISA > 0

			For nInd1 := 1 To Len( xInputs )
				
				If xInputs[nInd1,nPosRec] != nRecSTL .And. xInputs[nInd1,nPosNSA] == STL->TL_NUMSA .And. xInputs[nInd1,nPosISA] == STL->TL_ITEMSA

					dbSelectArea( 'STL' )
					dbGoTo( xInputs[nInd1,nPosRec] )

					/*--------------------------------------------------------------------------------------------------+
					| Consiste se um insumo diferente do posicionado e de mesmo número e item da S.A. sofreu alteraçao. |
					+--------------------------------------------------------------------------------------------------*/
					nPosit := aScan( xInputs, { |x|  x[nPosRec] == STL->( RecNo() ) .And. ( aTail( x ) .Or. !( x[nPosCod] == STL->TL_CODIGO ) .Or.;
						x[nPosQtd] != STL->TL_QUANTID .Or. !( x[nPosAlx] == STL->TL_LOCAL ) .Or. ( nPosObs == 0 .Or. !( x[nPosObs] == STL->TL_OBSERVA ) ) ) } )

					If nPosit > 0

						Exit

					EndIf

				EndIf

			Next nInd1

		EndIf

	Else

		/*------------------------------------------+
		| Validação considerando tabela temporaria. |
		+------------------------------------------*/
		cAlsTmp := GetNextAlias()

		BeginSQL Alias cAlsTmp

			SELECT
				COUNT( TMP.RECNO ) AS FOUND
			FROM 
				%exp:xInputs% TMP
			WHERE
				TMP.RECNO = %exp:nRecSTL% AND
				( 	TMP.TL_CODIGO  <> %exp:STL->TL_CODIGO%  OR
					TMP.TL_QUANTID <> %exp:STL->TL_QUANTID% OR
					TMP.TL_LOCAL   <> %exp:STL->TL_LOCAL%   OR
					TMP.STATUS = 3 ) 

		EndSQL

		nPosit := (cAlsTmp)->FOUND

		(cAlsTmp)->( dbCloseArea() )
		
	EndIf

	RestArea( aAreaTL )
	RestArea( aArea )

Return nPosit > 0

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} fVldAltSC
Realiza validação considerando se o insumo sofreu alteração e devera enviar a S.C. 
para integração.
@type function

@author Alexandre Santos
@since 27/10/2021

@sample fVldAltSC( 1, aCols, 25, 6, 4, 3 )

@param  nRecSTL  , numeric, Recno do registro STL já gravado em base.
@param  aInputs  , array  , aCols no qual consta as alterações sofridas pelos insumos.
@param  nPosRec  , numeric, Posição do campo TL_REC_WT no aHeader.
@param  nPosQtd  , numeric, Posição do campo TL_QUANTID no aHeader.
@param  nPosCod  , numeric, Posição do campo TL_CODIGO no aHeader.
@param  nPosAlx  , numeric, Posição do campo TL_LOCAL no aHeader.
@param  [nPosNSc], numeric, Posição do campo TL_NUMSC no aHeader.
@param  [nPosISc], numeric, Posição do campo TL_ITEMSC no aHeader.

@return boolean  , Define se o insumo sofreu alguma alteração referente a S.C.
/*/
//-----------------------------------------------------------------------------------
Function fVldAltSC( nRecSTL, aInputs, nPosRec, nPosQtd, nPosCod, nPosAlx, nPosNSc, nPosISc )

	Local aAreaTL   := STL->( FWGetArea() )
	Local nPosit    := 0

	Default nPosNSc := 0
	Default nPosISc := 0

	dbSelectArea( 'STL' )
	dbGoTo( nRecSTL )

	/*----------------------------------------------------------------------------+
	| Validação se insumo posicionado sofreu alguma alteração que reflete na S.C. |
	+----------------------------------------------------------------------------*/
	nPosit := aScan( aInputs, { |x|  x[nPosRec] == nRecSTL .And. ( x[nPosCod] != STL->TL_CODIGO .Or.;
		x[nPosQtd] != STL->TL_QUANTID .Or. x[nPosAlx] != STL->TL_LOCAL .Or. x[Len( x )] ) } )

	If nPosit == 0 .And. nPosNSc > 0

		/*-------------------------------------------------------------------------------------------------------+
		| Valida se este produto/terceiro possui outro de mesmo código e local que não gerou S.C. para aglutinar |
		+-------------------------------------------------------------------------------------------------------*/
		nPosit := aScan( aInputs, { |x|  x[nPosRec] != nRecSTL .And. x[nPosCod] == STL->TL_CODIGO .And.;
			x[nPosAlx] == STL->TL_LOCAL .And. ( Empty( x[nPosNSc] ) .And. Empty( x[nPosISc] ).Or.;
			( x[nPosNSc] == STL->TL_NUMSC .And. x[nPosISc] == STL->TL_ITEMSC ) ) } )

	EndIf

	FWRestArea( aAreaTL )

	FWFreeArray( aAreaTL )

Return nPosit > 0

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA420LOC
Valida o endereço do produto.
@type function

@author Alexandre Santos
@since 18/07/2022

@param  lMemory, boolean, Indica se considera memória ou o registro do aCols.
@return boolean, Define se o endereço poderá ser utilizado.
/*/
//-----------------------------------------------------------------------------------
Function MNTA420LOC( lMemory )

	Local cLocaliz := ''
	Local lRet     := .T.
	Local nPosProd := 0 
	Local nPosAlmx := 0
	Local nPosQtda := 0
	Local nPosDtIn := 0
	Local nPosEnde := GDFieldPos( 'TL_LOCALIZ' , oGet:aHeader )
	
	If !Empty( nPosEnde )

		If lMemory

			cLocaliz := M->TL_LOCALIZ
		
		Else

			cLocaliz := oGet:aCols[oGet:nAt,nPosEnde]

		EndIf

		If !Empty( cLocaliz )
		
			If MntUseExec( 'SDC' )

				nPosProd := GDFieldPos( 'TL_CODIGO' , oGet:aHeader )  
				nPosAlmx := GDFieldPos( 'TL_LOCAL'  , oGet:aHeader )
				nPosQtda := GDFieldPos( 'TL_QUANTID', oGet:aHeader )
				nPosDtIn := GDFieldPos( 'TL_DTINICI', oGet:aHeader )

				lRet := NGCHKFRASTO( oGet:aCols[oGet:nAt,nPosProd], oGet:aCols[oGet:nAt,nPosDtIn], , ,;
					oGet:aCols[oGet:nAt,nPosAlmx], , cLocaliz, oGet:aCols[oGet:nAt,nPosQtda] )

			Else

				Help( '', 1, 'NGATENCAO', , STR0209,; // Não será possivel utilizar o controle de endereço, visto que alguns campos da tabela SDC não possuem USO no módulo SIGAGFR.
					2, 0, , , , , , { STR0210 } ) // Para prosseguir com o processo de previsão de endereço, favor aplicar o pacote de atualizações do dicionário de dados.

				lRet := .F.

			EndIf

		EndIf

	EndIf

Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA420VTG
Valida a tarefa genérica.
@type function

@author Alexandre Santos
@since 18/08/2023

@param  cCodTar, boolean, Código da Tarefa.
@return boolean, Indica se a tarefa é valida.
/*/
//-----------------------------------------------------------------------------------
Function MNTA420VTG( cCodTar )

	Local lRet := .T.

	If M->TJ_PLANO != '000000'

		lRet := AllTrim( cCodTar ) == '0' .Or. NGALTTAR( STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA, cCodTar )

	Else
	
		If ( lRet := ExistCPO( 'TT9', cCodTar, 1 ) )
		
			If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0
				
				dbSelectArea( 'TT9' )
				dbSetOrder( 1 ) // TT9_FILIAL + TT9_TAREFA
				If msSeek( FWxFilial( 'TT9' ) + cCodTar ) .And.;
					!( TT9->TT9_CARACT $ '2/4' )

					Help( '', 1, 'TARCARACT' )

					lRet := .F.                                                    

				EndIf

			EndIf
		
		EndIf

	EndIf

Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MNA420VOcr
Valida a Ocorrência.
@type function

@author Alexandre Santos
@since 18/08/2023

@param  cCodOcr, string, Código da Ocorrência.
@param  cCodTar, string, Código da Tarefa.
@return boolean, Indica se a tarefa é valida.
/*/
//-----------------------------------------------------------------------------------
Function MNA420VOcr( cCodOcr, cCodTar, cTipOco )

	Local lRet      := .T.

	Default cTipOco := 'P'

	If ( lRet := ExistCPO( 'ST8', cCodOcr, 1 ) )

		dbSelectArea( 'ST8' )
		dbSetOrder( 1 ) // T8_FILIAL + T8_CODOCOR + T8_TIPO + T8_TAREFA
		If msSeek( FWxFilial( 'ST8' ) + cCodOcr )

			If ST8->T8_TIPO != cTipOco

				Help( '', 1, 'OCORRPRO' )
				
				lRet := .F.

			EndIf

			If lRet .And. !Empty( ST8->T8_TAREFA ) .And.;
				!( cCodTar == '0' ) .And. !Empty( cCodTar )

				If !( ST8->T8_TAREFA == cCodTar )

					Help( '', 1, 'TAREOCOR' )

					lRet := .F.

				EndIf

			EndIf

			If lRet

				lRet := MNT125VOC( 'ST8', .T. )

			EndIf

		EndIf

	EndIf

Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA420WHE
Valida se determinado campo deve estar disponivel para edição.
@type function

@author Alexandre Santos
@since 28/09/2022

@param  cField , string, Indicao campo que será validado.
@return boolean, Define se o campo está disponivel para edição.
/*/
//-----------------------------------------------------------------------------------
Function MNTA420WHE( cField )

	Local lRet := .T.

	If cField == 'TL_LOCALIZ' 
		
		If lHasMNTCM .And. lUseLoclz
			
			lRet := GDFieldGet( 'TL_TIPOREG', oGet:nAt, .F., oGet:aHeader, oGet:aCols ) == 'P' .And.;
				Localiza( GDFieldGet( 'TL_CODIGO', oGet:nAt, .F., oGet:aHeader, oGet:aCols ) )
		
		EndIf

	EndIf

Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA420Vld
Validações de campo para O.S. Corretiva.
@type function

@author Alexandre Santos
@since 28/09/2022

@param  cField , string, Indicao campo que será validado.
@return boolean, Define se o conteúdo do campo esta valido.
/*/
//-----------------------------------------------------------------------------------
Function MNTA420Vld( cField )

	Local cCodTar := ''
	Local nTarSTN := 0
	Local nProble := 0
	Local lRet    := .T.

	Do Case

		Case cField == 'TL_TAREFA' 

			lRet := MNTA420VTG( M->TL_TAREFA )
		
		Case cField == 'TQ_TAREFA' 

			lRet := MNTA420VTG( M->TQ_TAREFA )

		Case cField == 'TN_TAREFA' 

			If ( nProble := GDFieldPos( 'TN_CODOCOR', aHeaOcr ) ) > 0
			
				lRet := MNTA420VTG( M->TN_TAREFA )

				If lRet .And. !Empty( GDFieldGet( 'TN_CODOCOR' ) )

					dbSelectArea( 'ST8' )
					dbSetOrder( 1 ) // T8_FILIAL + T8_CODOCOR + T8_TIPO + T8_TAREFA
					If msSeek( FWxFilial( 'ST8' ) + GDFieldGet( 'TN_CODOCOR' ) ) .And.;
						ST8->T8_TAREFA != M->TN_TAREFA

						Help( '', 1, 'TAREOCOR' )

						lRet := .F.

					EndIf

				EndIf
			
			EndIf
		
		Case cField == 'TN_CODOCOR'

			If ( nTarSTN := GDFieldPos( 'TN_TAREFA', aHeaOcr ) ) > 0

				cCodTar := GDFieldGet( 'TN_TAREFA' )
			
			Else

				cCodTar := '0'

			EndIf

			lRet := MNA420VOcr( M->TN_CODOCOR, cCodTar )
		
	End Case

Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA420SXB
Filtro para consulta padrão ST8420.
@type function

@author Alexandre Santos
@since 21/08/2023

@param 
@return boolean, Condição SQL para filtro dos registros de ocorrências.
/*/
//-----------------------------------------------------------------------------------
Function MNTA420SXB()

	Local cCodTar := ''
	Local cCodFam := Posicione( 'ST9', 1, FWxFilial( 'ST9' ) + M->TJ_CODBEM, 'T9_CODFAMI' )

	If GDFieldPos( 'TN_TAREFA', aHeaOcr ) > 0

		cCodTar := GDFieldGet( 'TN_TAREFA' )

	EndIf

	/*--------------------------------------------------------------------------------------+
	| Deve-se filtrar as ocorrencias que estejam na tabela ST8 e não contidas na tabela TUS |
	+--------------------------------------------------------------------------------------*/
	cReturn := "@"
	cReturn +=	"T8_FILIAL  =  " + ValToSQL( FWxFilial( 'ST8' ) ) + " AND "

	If Empty( cCodTar )

		cReturn += "T8_TAREFA = ' ' AND "

	Else
		
		cReturn += "( T8_TAREFA = ' ' OR ( "
		cReturn += 							"T8_TAREFA = " +  ValToSQL( cCodTar ) + " AND "
		cReturn += 							"EXISTS ( SELECT "
		cReturn += 										"1 "
		cReturn += 									 "FROM "
		cReturn += 										RetSQLName( 'TT9' ) + " TT9 "
		cReturn += 									 "WHERE "
		cReturn += 									 	"TT9.TT9_FILIAL = " + ValToSQL( FWxFilial( 'TT9' ) ) + " AND "
		cReturn += 									 	"TT9.TT9_TAREFA = " + ValToSQL( cCodTar )            + " AND "
		cReturn += 									 	"TT9.TT9_CARACT IN ( '2', '4' )                          AND "
		cReturn += 									 	"TT9.D_E_L_E_T_ = ' ' "
		cReturn += 									" ) "
		cReturn += 						" ) "
		cReturn += " ) AND "

	EndIf

	cReturn +=	"T8_TIPO    = 'P' AND "
	cReturn +=	"T8_CODOCOR NOT IN ( "
	cReturn +=							"SELECT "
	cReturn +=								"TUS_CODOCO "
	cReturn +=							"FROM "
	cReturn +=								RetSQLName( 'TUS' ) + " "
	cReturn +=							"WHERE "
	cReturn +=								"TUS_FILIAL = " + ValToSQL( FWxFilial( 'TUS' ) ) + " AND "
	cReturn +=								"TUS_FAMILI = " + ValToSQL( cCodFam )            + " AND "
	cReturn +=								"TUS_TIPO   =  'P'                                   AND "
	cReturn +=								"D_E_L_E_T_ = ' ' )      AND "
	cReturn +=	"D_E_L_E_T_ = ' '"

Return cReturn

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} fVersion
Valida a versão de fontes relacionado, consistindo se é necessário atualizações.
@type function

@author Alexandre Santos
@since 26/04/2022

@return boolean  , Define se o insumo sofreu alguma alteração referente a S.C.
/*/
//-----------------------------------------------------------------------------------
Static Function fVersion()

	Local aVersion := {}
	Local cError   := ''
	Local lRet     := .T.

	If lHasMNTCM .Or. lHasMNTES

		aVersion := { { 'MNTA340.prx'   , SToD( '20220318' ), '08:00' },;
					  { 'MNTA435.prx'   , SToD( '20221014' ), '07:00' },;
					  { 'MNTA490.prx'   , SToD( '20221014' ), '07:00' },;
					  { 'MNTUTIL.prx'   , SToD( '20221103' ), '12:00' },;
					  { 'MNTUTIL_OS.prw', SToD( '20221018' ), '16:00' },;
					  { 'MNTUTIL01.prw' , SToD( '20220420' ), '08:00' },;
					  { 'NGUTIL.prx'    , SToD( '20221014' ), '07:00' } }
		
		If !NgVldRpo( aVersion )

			// Para a correta utilização da integração com os módulos Estoque/Custos e Compras deve-se realizar a aplicação do pacote acumulado de atualizações.
			cError += STR0205 + CRLF + CRLF

		EndIf

		If lHasMNTCM .And. !MntUseExec( 'SD4' )

			// Deve-se atualizar o dicionário de dados, referente a tabela SD4 utilizada na integração, conforme o link:.
			cError := STR0206 + ' https://tdn.totvs.com/pages/viewpage.action?pageId=666465698' + CRLF + CRLF

		EndIf

	EndIf

	If !Empty( cError )

		NGMSGMEMO( STR0018,; // Atenção
				cError )
		
		lRet := .F.

	EndIf

	/*--------------------------------------------------+
	| Desaloca consumo de memória p/ melhor performance |
	+--------------------------------------------------*/
	aSize( aVersion, 0 )
	aVersion := Nil
	
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MNT410WH
Função responsável pelo When

@type   Function

@author Eduardo Mussi
@since  30/07/2024
@param  cField, caracter, campo a ser verificado

@return lógico, Define se o campo será manipulável
/*/
//-------------------------------------------------------------------
Function MNT410WH( cField )

	Local lWhen := .F.
	
	If IsInCallStack( 'NG410INC' ) .And. cField == 'TL_DESTINO'
		lWhen := oGet:aCOLS[ oGet:nAt, nPosTpReg ] == 'P'
	Else
		lWhen := M->TL_TIPOREG == 'P'
	EndIf

Return lWhen

//-------------------------------------------------------------------
/*/{Protheus.doc} MNT410VL
Função responsável pelo Valid

@type   Function

@author Eduardo Mussi
@since  30/07/2024
@param  cField, caracter, campo a ser verificado

@return lógico, define se a validação foi bem sucedida
/*/
//-------------------------------------------------------------------
Function MNT410VL( cField )

	Local lRet := .F.
	
	If IsInCallStack( 'NG410INC' ) .And. cField == 'TL_DESTINO'
		lRet := IIF( oGet:aCOLS[ oGet:nAt, nPosTpReg ] == 'P', PERTENCE( 'AST' ), EMPTY( oGet:aCOLS[ oGet:nAt, nPosDesti ] ) ) .AND. MNT400DEST()
	Else
		lRet := IIF( M->TL_TIPOREG == 'P', PERTENCE( 'AST' ), EMPTY( M->TL_DESTINO ) ) .AND. MNT400DEST()
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fVldDelSA
Valida a exclusão de insumos que tem vinculo com SA.
@type Function

@author Alexandre Santos
@since  09/01/2025

@param  aGetIns, array, Lista com insumos previstos.
@param  aHeaIns, array, Cabec dos campos de insumos.

@return boolean, Indica se a S.A. pode ser excluida.
/*/
//-------------------------------------------------------------------
Static Function fVldDelSA( aGetIns, aHeaIns )

	Local lRet    := .F.
	Local nPosNSA := GDFieldPos( 'TL_NUMSA' , aHeaIns )
	Local nPosISA := GDFieldPos( 'TL_ITEMSA', aHeaIns )

	If !Empty( STL->TL_NUMSA )

		/*----------------------------------------------+
		| Validação se insumo posicionado foi excluido. |
		+----------------------------------------------*/
		lRet := aScan( aGetIns, { |x| aTail( x ) .And. x[nPosNSA] == STL->TL_NUMSA .And.;
			x[nPosISA] == STL->TL_ITEMSA } ) > 0

		If lRet

			/*-------------------------------------------------------------------------------------------+
			| Valida se este produto/terceiro possui outro de mesmo código e local que não foi excluido. |
			+-------------------------------------------------------------------------------------------*/
			lRet := aScan( aGetIns, { |x| !aTail( x ) .And. x[nPosNSA] == STL->TL_NUMSA .And.;
				x[nPosISA] == STL->TL_ITEMSA .And. x[nPosISA] == STL->TL_ITEMSA } ) == 0

		EndIf
	
	EndIf

Return lRet
