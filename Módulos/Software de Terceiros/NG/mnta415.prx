#INCLUDE "MNTA415.CH"
#INCLUDE "PROTHEUS.CH"

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA415
Programa de retorno de insumos simplificado.
Refeito em 08/05/03  - Inácio

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 05/09/2001

@sample MNTA415()

@return Lógico
/*/
//---------------------------------------------------------------------
Function MNTA415()

	Local aNGBEGINPRM
	Local aButtons      := {}
	Local x				:= 0
	Local nI			:= 0
	Local aCposAlter	:= {}
	Local lMNTA4156     := ExistBlock( 'MNTA4156' )
	Local nZ            := 0
	Local nCodBem 		:= 0
	Local bKeyF4		:= SetKey(VK_F4)
	Local bKeyF5		:= SetKey(VK_F5)
	Local oARQXTRB
	Local oPanelTot//Painel Principal para montagem da tela.
	Local oPnlAll  //Painel para GetDados.
	Local oPnlTop  //Painel para botões do Topo.
	Local cNGMNTES

	//Campos da STL que não serão acrescentados ao aHeader
	Local aNAO 			:= {	"TL_FILIAL"	, "TL_PLANO"  , "TL_SEQRELA", "TL_NOMTAR" , "TL_SEQUENC", "TL_NOMSEQ" ,;
								"TL_NOMTREG", "TL_CUSTO2" , "TL_CUSTO3" , "TL_CUSTO4" , "TL_CUSTO5" , "TL_CUSENT1", "TL_CUSENT2",;
								"TL_CUSENT3", "TL_CUSENT4", "TL_CUSENT5", "TL_OCORREN", "TL_REPFIM" , "TL_CODOBS" , "TL_CONTROL",;
								"TL_LOCAPLI", "TL_NOMETAP", "TL_NOMLOCA", "TL_ALI_WT" , "TL_REG_WT" , "TL_POSCONT", "TL_POSCON2",;
								"TL_NUMSC"	, "TL_ITEMSC" , "TL_NUMOP"  , "TL_ITEMOP" , "TL_SEQUEOP", "TL_SERVICO", "TL_SEQMAN" ,;
								"TL_TIPOHOR", "TL_SEQRMAN", "TL_NUMSA"  , "TL_ITEMSA" , "TL_SEQTARE",;
								"TL_DOC"	, "TL_ITEM"	  , "TL_ORIGNFE", 'TL_NUMSEQ';
							}
	//Campos da STL que serão acrescentados ao aHeader
	Local aINDXTRB := {}
	Local nInd     := 0
	Local nTot     := 0
	Local nTamanho := 0
	Local nDecimal := 0
	Local cCampo   := ""
	Local cArquivo := ""
	Local cTitulo  := ""
	Local cPicture := ""
	Local cValid   := ""
	Local cUsado   := ""
	Local cTipo    := ""
	Local cContext := ""
	Local cX3Nivel := ""

	If !FindFunction( 'MNTAmIIn' ) .Or. MNTAmIIn( 19, 35, 95 )

		aNGBEGINPRM	:= NGBEGINPRM(,,,,.T.)
		lMNT41506	:= ExistBlock( 'MNT41506' )
		cNGMNTES	:= AllTrim(GetMV("MV_NGMNTES"))

		Private cTRBSTN		:= GetNextAlias()
		Private cTRBQ400, cTRB3400, cTRBZ400, cTRBK400, cARQTRAZ
		Private cIntrbrTRBZ, cARQTRAK, cIntrbrTRBK, cTRBQBKP
		Private oDLG,oGET,oMenu
		Private aSize       := MsAdvSize()
		Private aObjects    := {}
		Private aTrocaF3    := {}
		Private aChoice     := {}
		Private lCORRET		:= .F.
		Private cLocaliz    := Space( TAMSX3("TPS_CODLOC")[1] )
		Private cCadastro	:= STR0001 //"Retorno Simplificado"
		Private cNGINSPREA  := "R"	// Indica se o insumo é realizado ou previsto, não deve ser retirado.
		// Usada para fazer checagem em funções dos NG...
		Private nUsado      := 0
		Private aDBFXTRB	:= {}
		Private aGar		:= {}
		Private aInsSub		:= {}
		Private aCposAlTPQ	:= {}
		Private aVETINR     := {}
		Private aProd435	:= {}  //PRODUTOS atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
		Private aLote435	:= {}  //LOTE atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
		Private aSubL435	:= {}  //SUB-LOTE atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
		Private aEnde435	:= {}  //ENDERECAMENTO atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
		Private lRefresh    := .T.
		Private lVldExcG	:= .T. //Flag utilizada em P.E. para que a validação da exclusao do insumo não seja executado duas vezes.
		Private lCervPetro  := .F.
		Private lRETORNO    := .F.
		Private lFoiF6      := .F.
		Private lTelaEtapa  := .F.
		Private lCriouTRBQ  := .F.
		Private lUSATARG    := IIf( FindFunction("NGUSATARPAD"), NGUSATARPAD(), .F. )
		Private lMMoeda     := NGCADICBASE("TL_MOEDA","A","STL",.F.) // Multi-Moeda
		Private cVALPECRE   := AllTrim(GetMv("MV_NGCOQPR"))
		Private dDTREAL     := CToD("  /  /  ")
		Private cMARCA      := GetMark()

		Private cPar01		:= Space(6), cPar02 := Space(6), cPar05 := Space(3)

		Private aCoBrw6		:= {}
		Private aCols		:= {}
		Private oBrw6

		If !NGCADICBASE("TB0_FILORD","A","TB0",.F.) .AND. NGFUNCRPO("SgaMntEst",.F.) .And.;
		GetMv("MV_SGAMNT") == "S" .And. GetMv("MV_NGSGAES") <> "N"

			If !NGINCOMPDIC("UPDSGA01","00000015391/2010")
				Return
			EndIf
		EndIf

		aAdd(aObjects, { 015, 020, .T., .T. } )
		aAdd(aObjects, { 100, 100, .T., .T. } )

		aInfo   := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
		aPosObj := MsObjSize(aInfo, aObjects,.T.)

		If NGCADICBASE("ZZY_DTREPR","D","ZZY",.F.) .And. NGCADICBASE("ZZY_SEQUEN","D","ZZY",.F.) .And.;
		NGCADICBASE("ZZY_SERVIC","D","ZZY",.F.)

			lCervPetro := .T.
		EndIf

		Store .T. To INCLUI,lWhile,lRET,lTipo,LTIPODAT,LEDATAINI
		Store .F. To lHoras,lCorret,lEDESTINO,LEUNIDADE,lBEM
		Store Space(5) To M->TL_HOINICI,M->TL_HOFIM
		Store Ctod(' /  /  ') To M->TL_DTINICI,M->TL_DTFIM

		M->TL_CODIGO	:= SPACE(15)
		M->TL_TIPOREG	:= SPACE(01)
		M->TL_UNIDADE	:= SPACE(03)
		M->TL_QUANTID	:= 0
		M->TL_USACALE	:= "N"
		aPOS1			:= {15,1,95,315}

		cUSAINT1		:= AllTrim(GETMv("MV_NGMNTPC"))
		cUSAINT2		:= AllTrim(GetMv("MV_NGMNTCM"))
		cUSAINT3		:= AllTrim(GetMv("MV_NGMNTES"))
		lEstNega		:= AllTrim( GetMv("MV_ESTNEG") ) == "S"
		cUSAINT			:= AllTrim(cUsaInt1 + cUsaInt2 + cUsaInt3)
		lCUSTO			:= ( cUSAINT3 == 'N' )

		DbSelectArea("STN")
		aDBFXTRB := STN->(DbStruct())
		aAdd(aDBFXTRB,{"TN_SEQCONT","C", 03,0})
		//Indice Tabela Temporária
		aINDXTRB := {{"TN_ORDEM","TN_PLANO","TN_TAREFA","TN_SEQRELA","TN_CODOCOR","TN_CAUSA","TN_SOLUCAO"}}
		//Cria Tabela Temporária
		oARQXTRB := NGFwTmpTbl(cTRBSTN, aDBFXTRB, aINDXTRB)

		NGSETIFARQUI("STL","F")
		Dbskip()
		cSTLOBS			:= STL->TL_OBSERVA
		aHeader			:= {}
		aHoBrw4			:= {}
		cSX3VTAR		:= NGSEEKDIC("SX3","TL_TAREFA" ,2,"X3_VALID")
		cSX3VTIP		:= NGSEEKDIC("SX3","TL_TIPOREG",2,"X3_VALID")

		cFunVal := Posicione("SX3",2,"TL_PERMDOE","X3_VALID")
		cFunVal := StrTran(cFunVal,'M->TL_PERMDOE,M->TL_TAREFA)','M->TL_PERMDOE,aCOLS[n,nTAREF4],aCOLS,{nTIPOI4,nPERMI4,nTAREF4,n,nORDEM4})')
		aAdd(aHeader,{"TL_PERMDOE",{,,,,,cFunVal}})

		If lMMoeda
			aAdd(aHeader, {"TL_MOEDA",{}})
		EndIf

		cRELATAR := NGSEEKDIC("SX3","TL_TAREFA",2,"X3_RELACAO")
		cRELATIP := NGSEEKDIC("SX3","TL_TIPOREG",2,"X3_RELACAO")

		//Seleciona os campos necessários para montar o aHeader
		aHoBrw4 := fCabecGet( "TPL", {} )
		aHoBrw5 := fCabecGet( "STL", aNAO )
		aHeader := fCabecGet( "STL", aNAO )

		//Acrescenta o campo TPL_ORDEM no lugar do campo TL_ORDEM
		aHeader[1] := aHoBrw4[1]

		//Altera posição do campo TL_CODBEM para manter o legado da rotina
		nCodBem := aScan(aHoBrw5,{|x| TRIM(UPPER(x[2])) == "TL_CODBEM"}) //Busca posição do campo
		aHeader[2] := aHoBrw5[nCodBem]

		//|--------------------------------------------------------------------------|
		//| Ao adicionar o campo 'TL_CODBEM' no aHeader, retira do array aHoBrw5,    |
		//| pois não deverá ser considerado novamente, sendo que já foi adicionado.  |
		//|--------------------------------------------------------------------------|
		ADEL( aHoBrw5 , nCodBem )

		//|--------------------------------------------------------------------------|
		//| Percorre todo o aHeader para fazer as adquações nas posições dos campos. |
		//|--------------------------------------------------------------------------|
		For nZ := 3 To Len(aHeader)
			aHeader[nZ] := aHoBrw5[nZ-1]
		Next nZ

		//+--------------------------------------------+
		//| Preenche o array auxiliar aCposAlter...    |
		//+--------------------------------------------+
		If ExistBlock("NG415CPU")
			aCposAlter := ExecBlock("NG415CPU",.F.,.F.)
		EndIf
		//+--------------------------------------------------+
		//| Agrega no array aHeader os campos de Usuarios... |
		//+--------------------------------------------------+

		// Agrega no array aHeader os campos de Usuarios...
		nTot := Len(aCposAlter)
		For nInd := 1 To nTot

			cCampo   := aCposAlter[nInd]
			If STL->(FieldPos(cCampo)) > 0

				cTitulo  := AllTrim(Posicione("SX3",2,cCampo,"X3Titulo()"))
				cArquivo := Posicione("SX3",2,cCampo,"X3_ARQUIVO")
				cPicture := X3Picture(cCampo)
				nTamanho := TAMSX3(cCampo)[1]
				nDecimal := TAMSX3(cCampo)[2]
				cValid   := Posicione("SX3",2,cCampo,"X3_VALID")
				cUsado   := Posicione("SX3",2,cCampo,"X3_USADO")
				cTipo    := Posicione("SX3",2,cCampo,"X3_TIPO")
				cContext := Posicione("SX3",2,cCampo,"X3_CONTEXT")
				cX3Nivel := Posicione("SX3",2,cCampo,"X3_NIVEL")

				If X3USO(cUsado) .And. cNivel >= cX3Nivel
					nUsado++
					aAdd(aHeader,{cTitulo,cCampo,cPicture,nTamanho,nDecimal,cValid,cUsado,cTipo,cArquivo,cContext})
				EndIf

			EndIf

		Next nInd


		//Inclui coluna de registro atraves de funcao generica
		ADHeadRec("STL",aHeader)
		nUsado := Len(aHeader)

		nORDEM4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TPL_ORDEM"})
		nCOBEM4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_CODBEM"})
		nTAREF4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_TAREFA"})
		nTIPOI4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_TIPOREG"})
		nCODIG4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_CODIGO"})
		nDESCR4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_NOMCODI"})
		nUSACA4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_USACALE"})
		nQUANR4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_QUANREC"})
		nQUANT4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_QUANTID"})
		nUNIDA4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_UNIDADE"})
		nDATAI4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_DTINICI"})
		nHORAI4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_HOINICI"})
		nDATAF4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_DTFIM"})
		nHORAF4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_HOFIM"})
		nHREXT4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == IIf(NGCADICBASE("TL_PCTHREX","A","STL",.F.),"TL_PCTHREX","TL_HREXTRA")})
		nDESTI4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_DESTINO"})
		nCUSTO4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_CUSTO"})
		nLOCAL4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_LOCAL"})
		nLOTEC4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_LOTECTL"})
		nNUMLO4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_NUMLOTE"})
		nOBSER4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_OBSERVA"})
		nDTVAL4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_DTVALID"})
		nLOCALI := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_LOCALIZ"})
		nNUMSEI := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_NUMSERI"})
		nGARAN4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_GARANTI"})
		nPERMI4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_PERMDOE"})
		nMOEDA4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_MOEDA"  })
		nETAPA4 := aScan(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_ETAPA"})
		nNTFIS4 := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TL_NOTFIS"})
		nSERIE4 := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TL_SERIE"})

		//When do campo Código do Bem
		If nCOBEM4 > 0
			aHeader[nCOBEM4,12]  := lBEM
		EndIf

		//Valid e When do campo Tipo Insumo
		If nTIPOI4 > 0
			aHeader[nTIPOI4,6]  := cSX3VTIP + " .And. MNTA415TP() .And. MNT415LIMP()"
			aHeader[nTIPOI4,12] := lTipo
		EndIf

		//Valid do campo Tarefa
		If nTAREF4 > 0
			aHeader[nTAREF4,6]  := cSX3VTAR + " .And. NG415TARE()"
		EndIf

		//Valid do campo Código da OS
		If nCODIG4 > 0
			aHeader[nCODIG4,6]  := "NGCHKPROD() .And. NGPROBLQ(M->TL_CODIGO) .And. MNT415DESC(M->TL_TIPOREG,M->TL_CODIGO)"
		EndIf

		//Valid do campo Quantidade
		If nQUANT4 > 0
			aHeader[nQUANT4,6]  := "Positivo() .And. NG415VLIM() .And. NG415QUANT() .And. NGCALDTHO()"
		EndIf

		//Valid do campo Data Início
		If nDATAI4 > 0
			aHeader[nDATAI4,6]  := "NG415DTINI() .And. NGCALDTHO() .And. If(aCOLS[n][nTIPOI4] = 'M',NGFUNCRH(aCOLS[n][nCODIG4],.T.,M->TL_DTINICI),.T.)"
		EndIf

		//Valid do campo Hora Início
		If nHORAI4 > 0
			aHeader[nHORAI4,6] := "NG415HOINI() .And. NGCALDTHO()"
		EndIf

		//Valid do campo Data Fim
		If nDATAF4 > 0
			aHeader[nDATAF4,6] := "NG415DTFIM() .And. NGCALDTHO() .And. If(aCOLS[n][nTIPOI4] = 'M',NGFUNCRH(aCOLS[n][nCODIG4],.T.,M->TL_DTFIM),.T.)"
		EndIf

		//Valid do campo Hora Fim
		If nHORAF4 > 0
			aHeader[nHORAF4,6] := "NG415HOFIM() .And. NGCALDTHO()"
		EndIf

		//Valid do campo Destino
		If nDESTI4 > 0
			aHeader[nDESTI4,6] := "MNT400DEST()"
		EndIf

		//Valid do campo Local
		If nLOCAL4 > 0
			aHeader[nLOCAL4,6] := "NG415ALM()"
		EndIf

		//Valid do campo Lote
		If nLOTEC4 > 0
			aHeader[nLOTEC4,6] := "NG415LOTCT()"
		EndIf

		//Valid do campo Sub-Lote
		If nNUMLO4 > 0
			aHeader[nNUMLO4,6] := "NG415NUMLO()"
		EndIf

		//Valid do campo Localização
		If nLOCALI > 0
			aHeader[nLOCALI,6] := "NG415LOCAL()"
		EndIf

		//Valid do campo Garantia
		If nGARAN4 > 0
			aHeader[nGARAN4,6] := "MNT415GAR()"
		EndIf

		NGDBAREAORDE("SX3",1)

		aCols   := Array(1,nUsado+1)
		aColsax := Aclone(aCols)

		NG415ACOLS()
		SetKey(VK_F12,{||NGA415F12()})
		SetKey(VK_F4,{|| MntViewSB2(aCOLS[n,nTIPOI4],aCOLS[n,nCODIG4]) })
		SetKey( VK_F5, {|| fF5KEY()})
		nOpcx := 3
		While .T.
			nOpcb := 1
			Define Msdialog oDLG Title cCadastro From aSize[7],0 To aSize[6],aSize[5] Of oMainWnd PIXEL STYLE nOR(WS_VISIBLE,WS_POPUP)

			oPanelTot := TPanel():New(0,0,,oDLG,,,,,,0,0,.F.,.F.)
				oPanelTot:Align := CONTROL_ALIGN_ALLCLIENT

			oPnlTop := TPanel():New(00,00,,oPanelTot,,,,,,aSize[5],21,.F.,.F.)
				oPnlTop:Align := CONTROL_ALIGN_TOP
			
			aAdd( aButtons, { 005, 002, STR0027, { || NG415ETA() }, 'oBtnEta' } )
			aAdd( aButtons, { 005, 052, STR0028, { || NG415OCO() }, 'oBtnOco' } )
			aAdd( aButtons, { 005, 102, STR0029, { || NG415FIM() }, 'oBtnFin' } )
			aAdd( aButtons, { 005, 152, STR0125, { || MNTA402()  }, 'oBtnRat' } )

			If cNGMNTES == 'S'
				aAdd( aButtons, { 005, 202, STR0108, { || MNTC290( IIf( aTail( aCols[n] ), '', aCols[n,nORDEM4] ) ) }, 'oBtnSC' } )
			EndIf

			If lMNTA4156
				aButtons := ExecBlock( 'MNTA4156', .F., .F., { aButtons } )
			EndIf

			For nInd := 1 to Len( aButtons )

				@ aButtons[nInd,1], aButtons[nInd,2] BUTTON &( aButtons[nInd,5] ) PROMPT aButtons[nInd,3] SIZE 40,12 OF oPnlTop PIXEL
				
				&( aButtons[nInd,5] ):bAction   := aButtons[nInd,4]
				&( aButtons[nInd,5] ):bLClicked := aButtons[nInd,4]
				
			Next nInd	

			oPnlAll := TPanel():New(00,00,,oPanelTot,,,,,,aSize[5],aSize[6],.F.,.F.)
			oPnlAll:Align := CONTROL_ALIGN_ALLCLIENT

			oGet := MSGetDados():New(30,aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],3,"MNTA415TU(n)","NG415TudOk","",.T.,,,,300,,,,,oPnlAll)
			oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

			If nDESCR4 > 0
				aCols[1][nDESCR4] := Space(40)
			EndIf

			If Len(aSMenu) > 0
				NGPOPUP(asMenu,@oMenu)
				oDlg:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg)}
			EndIf

			Activate MSDIALOG oDlg On Init EnchoiceBar(oDlg,{||nOpcb := 2, IIf(!MNTA415TU(,.T.),nOpcb:=1,oDlg:End())},{ || oDlg:End() } )

			If nOpcb = 1
				Exit
			EndIf

			For nI := 1 to Len(aCols)
				nLS := aScan(aGar,{|x| x[7] = nI})
				If !ATail(aCols[nI]) .And. nLS > 0 .And. aCOLS[nI][nGARAN4]  == "S"
					MNT415GRVG(aCOLS[nI][nORDEM4],aCOLS[nI][nCOBEM4],aCOLS[nI][nCODIG4],aGar[nLS][2],;
					aGar[nLS][3],aGar[nLS][4],aGar[nLS][5],aGar[nLS][6],aCOLS[nI][nTIPOI4])
				EndIf
			Next nI

			NG415ACOLS()
			DbSelectArea(cTRBSTN)
			PACK
			DbSelectArea("STL")

		EndDo

		SetKey(VK_F4,bKeyF4)
		SetKey(VK_F5,bKeyF5)

		//Deleta os Arquivos temporarios fisicamente
		oARQXTRB:Delete()

		DbSelectArea("STL")

		NGRETURNPRM(aNGBEGINPRM)

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCHKPROD
Busca a unidade do insumo

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 06/09/2001

@sample NGCHKPROD()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NGCHKPROD()

	Local aAINSUMO := NGNOMINSUMO(aCOLS[n][nTIPOI4],M->TL_CODIGO,20, IIf( aCOLS[n][nTIPOI4] == "T",  SA2->A2_LOJA, '' ) )
	Local _RET     := .T. ,cHelp
	Local OldAli   := Alias()

	//Testa o tamanho do campo para nao permitir informar codigo invalido
	If aCOLS[n][nTIPOI4] == "M"  //Mao de obra
		If Len(AllTrim(M->TL_CODIGO)) > Len(ST1->T1_CODFUNC)
			_RET  := .F.
			cHelp := "FUNCNEXIST"
		EndIf
	ElseIf aCOLS[n][nTIPOI4] == "T"  //Terceiros
		If Len(AllTrim(M->TL_CODIGO)) > Len(SA2->A2_COD)
			_RET  := .F.
			cHelp := "TERCNEXIST"
		EndIf
	ElseIf aCOLS[n][nTIPOI4] == "F"  //Ferramenta
		If Len(AllTrim(M->TL_CODIGO)) > Len(SH4->H4_CODIGO)
			_RET  := .F.
			cHelp := "FERRNEXIS"
		EndIf
	ElseIf aCOLS[n][nTIPOI4] == "P"  //Produto
		If Len(AllTrim(M->TL_CODIGO)) > Len(SB1->B1_COD)
			_RET  := .F.
			cHelp := "PRODNEXIST"
		EndIf
	EndIf

	If !_RET
		Help(" ",1,cHelp)
		DbSelectArea(OldAli)
		Return .F.
	EndIf

	If Empty(aAINSUMO[1][2])
		MsgInfo(STR0025,STR0014)//'Insumo nao cadastrado','ATENCAO'
		Return .F.
	Else
		If acols[n][nTIPOI4] = "P"
			aCols[n][nUNIDA4] := NGSEEK("SB1",M->TL_CODIGO,1,"B1_UM")
			NGIFDBSEEK("STJ",aCols[n][nORDEM4],1,.F.)
			aCols[n][nLOCAL4] := NGALMOXA(STJ->TJ_CODBEM,M->TL_CODIGO,aCols[n][nTIPOI4],.T.)

			//Zera os campos de controle de rastreabilidade quando for trocado o codigo do
			//produto
			If nLOTEC4 > 0 .And. nNUMLO4  > 0 .And. nDTVAL4 > 0
				If !Empty(aCOLS[n][nLOTEC4]) .Or. !Empty(aCOLS[n][nNUMLO4]) .Or. !Empty(aCOLS[n][nDTVAL4])
					aCOLS[n][nLOTEC4] := Space(Len(STL->TL_LOTECTL))
					aCOLS[n][nNUMLO4] := Space(Len(STL->TL_NUMLOTE))
					aCOLS[n][nDTVAL4] := CTOD("  /  /  ")
					aCOLS[n][nLOCALI] := Space(Len(STL->TL_LOCALIZ))
					aCOLS[n][nNUMSEI] := Space(Len(STL->TL_NUMSERI))
				EndIf
			EndIf
		Else
			aCols[n][nUNIDA4] := "H"
			lTipo := .F.
		EndIf
	EndIf
	oGet:Refresh()

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415FIM
Finaliza a Ordem de Servico

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 06/09/2001

@sample NG415FIM()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415FIM()

	Local lRet   	:= .T.
	Local lShow		:= .T.
	Local lFINAL 	:= .T.
	Local lMNTA415A := ExistBlock("MNT415A")
	Local lNG415FOS := ExistBlock("NG415FOS")
	Local pi		:= 0
	Local yx		:= 0
	Local x			:= 0
	Local nI		:= 0
	Local aBEMCX 	:= {}
	Local aMNT415A	:= {}
	Local aArea		:= GetArea()

	If ExistBlock("MNT41502")
		If !ExecbLock("MNT41502",.F.,.F.)
			Return .F.
		EndIf
	EndIf

	For pi := 1 To Len(aCols)
		If !aCOLS[pi][LEN(aCOLS[pi])] .And. FindFunction("NGVLDSTL") .And. !NGVLDSTL(aCols[pi][nORDEM4]) // verifica se não existe insumo com data e hora inicial igual a data e hora final
			RestArea(aArea)
			Return .F.
		EndIf
	Next yx

	aARRAYOS := {}

	If MNTA415TU()
		For pi := 1 to LEN(aCols)
			If !aCOLS[pi][LEN(aCOLS[pi])]
				
				//-----------------------------------------------------------
				// Verifica se não há pneus aguardando aplicação
				//-----------------------------------------------------------
				If FindFunction( 'MNTVLDFIN' ) .And. !MNTVLDFIN( aCols[pi][nORDEM4] )[1]
					Return .F.
				EndIf

				If NGFUNCRPO("NGRESPETAEX",.F.)
					If !NGRESPETAEX(aCols[pi][nORDEM4],.T.)
						Return
					EndIf
				EndIf

				If cUsaInt3 == 'S'
					If !NGIFDBSEEK("SC2",aCols[pi][nORDEM4]+'OS001',1,.F.)
						MsgInfo(STR0011+aCols[pi][nORDEM4]+STR0012+chr(13)+chr(13)+STR0013,STR0014)
						Return .F.
					EndIf
				EndIf

				/*/ Verifica se o insumo é do tipo produto, se tem integração entre (SIGAMNT) e (SIGAEST)
				e se o sistema permite que os saldos em estoque dos produtos fique negativo./*/
				If aCols[pi][nTIPOI4] == "P" .And. cUSAINT3 == 'S' .And. lEstNega
					If !NGSALSB2( aCols[pi][nCODIG4], aCols[pi][nLOCAL4], aCols[pi][nQUANT4], .T. )
						Return .F.
					EndIf
				EndIf

				NGIFDBSEEK("STJ",aCols[pi][nORDEM4],1,.F.)

				cBEMRET := Space(Len(stj->tj_codbem))
				cBEMRET := NGTBEMPAI(stj->tj_codbem,cBEMRET)
				cBEMRET := IIf(Empty(cBEMRET),stj->tj_codbem,cBEMRET)

				nPOS := aScan(aBEMCX,{|x| x[1] = cBEMRET})
				TipoAcom  := .F.
				TipoAcom2 := .F.
				//FindFunction remover na release GetRPORelease() >= '12.1.027'
				If FindFunction("MNTCont2")
					TIPOACOM2 := MNTCont2(xFILIAL("TPE"), cBEMRET)
				Else
					TipoAcom2 := NGIFDBSEEK("TPE",cBEMRET,1,.F.)
				EndIf
				If nPOS = 0
					cTIPOCON := " "
					cTIPOCON := NGSEEK("ST9",cBEMRET,1,"T9_TEMCONT")
					TIPOACOM := IIf(cTIPOCON = "S",.T.,.F.)
					cBEMFIM := cBEMRET
					aAdd(aBEMCX,{cBEMFIM,TipoAcom,TipoAcom2})
					nINCRE := Len(aBEMCX)
				Else
					nINCRE    := nPOS
					cBEMFIM   := aBEMCX[nINCRE][1]
					TipoAcom  := aBEMCX[nINCRE][2]
				EndIf

				If aScan(aARRAYOS,{|x| x[1] == aCols[pi][nORDEM4]}) = 0
					aAdd(aARRAYOS,{aCols[pi][nORDEM4],Ctod("  /  /  "),Ctod("  /  /  "),; // ordem,dt.parada inicio,dt.parada fim
					Space(5),Space(5),0,Space(5),0,Space(5),;        // hora parada inicio,hora parada fim,contador 1,hora cont. 1,contador 2, hora cont. 2
					Ctod("  /  /  "),TipoAcom,TipoAcom2,cBEMFIM,;    // dt real final,tem contador 1,tem contador 2,Bem contador
					stj->tj_plano,Space(3),Ctod("  /  /  "),"  :  ","  :  "}) //Data Mnt. Real Ini., Hora Mnt. Real Ini., Hora Mnt. Real Fim

				EndIf
			EndIf
		Next pi

		If lMNTA415A
			aMNT415A 	:= aClone(ExecBlock("MNT415A",.F.,.F.,{aARRAYOS, lShow}))
			aARRAYOS[1]	:= aClone(aMNT415A[1])
			lShow		:= aMNT415A[2]
		EndIf

		aARROAUX := Aclone(aCols)
		aARRORDI := Asort(aARROAUX,,,{|x,y| x[1] <= y[1]})

		For yx := 1 To Len(aARRAYOS)

			If NG415CAD(yx,lShow)
				lFinal := .T.
			Else
				lFinal := .F.
				Exit
			EndIf

			If lFINAL
				If lNG415FOS
					lFINAL := ExecBlock("NG415FOS",.F.,.F.)
					If !lFINAL
						Exit
					EndIf
				EndIf
			EndIf
		Next yx

		If lFINAL // grava inumos STL etc..
			Processa({ |lEnd| MNTA415PI() },STR0033+STR0034)
			Processa({ |lEnd| MNTA415OF() },STR0033+STR0035)
			For nI := 1 to Len(aCols)
				nLS := aScan(aGar,{|x| x[7] = nI})
				If !ATail(aCols[nI]) .And. nLS > 0 .And. aCOLS[nI][nGARAN4]  == "S"
					MNT415GRVG(aCOLS[nI][nORDEM4],aCOLS[nI][nCOBEM4],aCOLS[nI][nCODIG4],aGar[nLS][2],;
					aGar[nLS][3],aGar[nLS][4],aGar[nLS][5],aGar[nLS][6],aCOLS[nI][nTIPOI4])
				EndIf
			Next nI
			NG415aCols()
			oGet:Refresh()
		EndIf

		If lFINAL
			If ExistBlock("MNT41501")
				ExecBlock("MNT41501",.F.,.F.)
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA415PI
Processa os insumos das O.S

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 12/05/2003

@sample MNTA415PI()

@return Nil
/*/
//---------------------------------------------------------------------
Function MNTA415PI()

	Local xy 			:= 0
	Local ii			:= 0
	Local nPosCpo 		:= 0
	Local nI			:= 0
	Local ny			:= 0
	Local iz			:= 0
	Local aCamposSGA 	:= {}
	Local aCposAlter 	:= {}
	Local aCstMoeda 	:= {}
	Local lMNT41509		:= ExistBlock("MNT41509")
	Local lSeqTare  	:= NGCADICBASE("TL_SEQTARE","A","STL",.F.)
	Local lMMoeda   	:= NGCADICBASE("TL_MOEDA","A","STL",.F.) // Multi-Moeda
	Local cNGUNIDT		:= AllTrim(SuperGetMv("MV_NGUNIDT", .F., ""))

	If ExistBlock("NG415CPU")
		aCposAlter := ExecBlock("NG415CPU",.F.,.F.)
	EndIf

	ProcRegua(Len(aCols))
	For ii := 1 to LEN(aCols)
		IncProc(OemtoAnsi(STR0034+aCols[ii,nORDEM4])) //"Processando Insumos Ordem "
		If !aCOLS[ii][LEN(aCOLS[ii])]
			If NGIFDBSEEK("STJ",aCols[ii][nORDEM4],1,.F.)
				cTIPOMAN := IIf(Val(stj->tj_plano) = 0,"C","P")

				//Passado os parametros de local, lote, sublote e data de validade para gravar no STL, ao
				//informar um almoxarifado diferente do padrao 01 sempre estava baixado estoque do 01
				If !NGRETINS(aCols[ii][nORDEM4],STJ->TJ_PLANO,cTIPOMAN,,,,;
				aCols[ii][nTAREF4],aCols[ii][nTIPOI4],aCols[ii][nCODIG4],aCols[ii][nQUANT4],;
				aCols[ii][nUNIDA4],aCols[ii][nDESTI4],"Consumo",aCols[ii][nDATAI4],;
				aCols[ii][nHORAI4],"F",aCols[ii][nLOCAL4],IIf(nLOTEC4 > 0,aCols[ii][nLOTEC4],),;
				IIf(nNUMLO4 > 0,aCols[ii][nNUMLO4],),IIf(nDTVAL4 > 0,aCols[ii][nDTVAL4],),IIf(nLOCALI > 0,aCols[ii][nLOCALI],),;
				IIf(nPERMI4 > 0,aCols[ii,nPERMI4],))
					Return .F.
				EndIf

				RecLock("STL",.F.)
				For iz := 1 To STL->( fCount() )
					//Se encontrar o campo (FieldName(iz)) dentro do aHeader, faz as validações se necessárias
					If ( nPos := aScan( aHeader, { |x| AllTrim(x[2]) == FieldName(iz) } ) ) > 0
						If FieldName(iz) = "TL_USACALE"
							STL->&( FieldName(iz) ) := IIf( aCols[ii][nUSACA4] <> "S", "N", aCols[ii][nUSACA4] )
						ElseIf FieldName(iz) = "TL_TIPOHOR"
							STL->&( FieldName(iz) ) := IIf( STL->TL_USACALE = "S", "S", cNGUNIDT)
						ElseIf FieldName(iz) = "TL_CUSTO"
							If cUSAINT3 == 'N'
								STL->&( FieldName(iz) ) := IIf( nCUSTO4 > 0 , aCols[ii][nCUSTO4] , 0 )
							Else
								If lMMoeda .And. FindFunction("NGCALCUSMD")
									aCstMoeda := NGCALCUSMD(STL->TL_CODIGO,STL->TL_TIPOREG,STL->TL_QUANTID,STL->TL_LOCAL,STL->TL_TIPOHOR,,,STL->TL_QUANREC)
									STL->&( FieldName(iz) ) := aCstMoeda[1]
								Else
									STL->&( FieldName(iz) ) := NGCALCUSTI( STL->TL_CODIGO , STL->TL_TIPOREG , STL->TL_QUANTID , STL->TL_LOCAL , STL->TL_TIPOHOR , , , STL->TL_QUANREC )
									If lMMoeda
										STL->TL_MOEDA := "1"
									EndIf
								EndIf
							EndIf
						ElseIf FieldName(iz) = "TL_MOEDA"
							If cUSAINT3 == 'N'
								STL->&( FieldName(iz) ) := IIf( nMOEDA4 > 0 , aCols[ii][nMOEDA4] , "1" )
							Else
								If lMMoeda .And. FindFunction("NGCALCUSMD")
									aCstMoeda := NGCALCUSMD( STL->TL_CODIGO , STL->TL_TIPOREG , STL->TL_QUANTID , STL->TL_LOCAL , STL->TL_TIPOHOR , , , STL->TL_QUANREC )
									STL->&( FieldName(iz) ) := aCstMoeda[2]
								Else
									STL->&( FieldName(iz) ) := NGCALCUSTI( STL->TL_CODIGO , STL->TL_TIPOREG , STL->TL_QUANTID , STL->TL_LOCAL , STL->TL_TIPOHOR , , , STL->TL_QUANREC )
									If lMMoeda
										STL->TL_MOEDA := "1"
									Endif
								EndIf
							EndIf
						ElseIf FieldName(iz) = "TL_DTFIM"
							If STL->TL_TIPOREG <> "P"
								STL->&( FieldName(iz) ) := aCols[ii][nDATAF4]
							EndIf
						ElseIf FieldName(iz) = "TL_HOFIM"
							If STL->TL_TIPOREG <> "P"
								STL->&( FieldName(iz) ) := aCols[ii][nHORAF4]
							EndIf
						ElseIf FieldName(iz) = "TL_PCTHREX"
							STL->&( FieldName(iz) ) := aCols[ii][nHREXT4]
						ElseIf FieldName(iz) = "TL_HREXTRA"
							STL->&( FieldName(iz) ) := cValtoChar(aCols[ii][nHREXT4])
							//Se o campo não cair nas validações anteriores, pega conteúdo dele próprio no aCols.
						Else
							STL->&( FieldName(iz) ) := aCols[ii][nPos]
						EndIf
					EndIf
				Next iz
				MsUnlock("STL")

				If STL->TL_TIPOREG == 'P'
					aAdd(aCamposSGA,{STL->TL_CODIGO,STL->TL_DTINICI,STL->TL_HOINICI,;
					STL->TL_QUANTID,STL->TL_ORDEM,STL->TL_PLANO,;
					STL->TL_SEQRELA,STL->TL_FILIAL,STL->TL_NUMSEQ})
				EndIf

				If Len(aCposAlter) > 0
					RecLock("STL",.F.)
					For nI := 1 To Len(aCposAlter)
						nPosCpo := aScan(aHeader,{|x| AllTrim(x[2])==aCposAlter[nI]})
						STL->(FieldPut(FieldPos(aCposAlter[nI]),aCols[ii][nPosCpo]))
					Next nI
					MsUnLock("STL")

					If cUsaInt3 == 'S'
						If NGIFDBSEEK("SD3",STL->TL_NUMSEQ,4,.F.)
							For nI := 1 To Len(aCposAlter)
								nONDERL := At("_",aCposAlter[nI])
								If nONDERL > 0
									cCAMIGUA := AllTrim(Substr(aCposAlter[nI],nONDERL+1,Len(aCposAlter[nI])))
									cCAMPSTL := "STL->TL_"+cCAMIGUA
									cCAMPSD3 := "SD3->D3_"+cCAMIGUA
									cFILPOS3 := "D3_"+cCAMIGUA
									If FieldPos(cFILPOS3) > 0
										RecLock("SD3",.F.)
										&cCAMPSD3 := &cCAMPSTL
										MsUnLock("SD3")
									EndIf
									If NGPRODESP(SD3->D3_COD,.F.,"M")
										NGAtuErp("SD3","UPDATE")
									EndIf
								EndIf
							Next nI
							//-------------------------------------
							//INTEGRACAO POR MENSAGEM UNICA
							//-------------------------------------
							If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"  //Mensagem Unica
								If SubStr(SD3->D3_CF,1,2) == "RE"//
									NGMUStoTuO(SD3->(RecNo()),"SD3")
								Else
									NGMUCanReq(SD3->(RecNo()),"SD3")
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf

				If lMNT41509
					ExecBlock("MNT41509")
				EndIf

				cSEFSTN := AllTrim(Str(ii,3))
				cSEFSTN := cSEFSTN + Space(3-Len(cSEFSTN))
				If NGIFTRBSEEK((cTRBSTN),STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+cSEFSTN,1)
					While !Eof() .And. (cTRBSTN)->TN_ORDEM = STL->TL_ORDEM .And.;
					(cTRBSTN)->TN_PLANO = STL->TL_PLANO .And.;
					(cTRBSTN)->TN_TAREFA = STL->TL_TAREFA .And.;
					(cTRBSTN)->TN_SEQRELA = cSEFSTN

						RecLock("STN",.T.)

						For ny := 1 To FCOUNT()
							nx := "(cTRBSTN)->" + FieldName(ny)
							If "_FILIAL"$Upper(nx)
								&nx. := xFilial("STN")
							EndIf

							FieldPut(ny, &nx.)
						Next ny
						STN->TN_FILIAL  := xFilial("STN")
						STN->TN_SEQRELA := STL->TL_SEQRELA
						MsUnLock('STN')
						/*
						STN->TN_FILIAL  := xFilial("STN")
						STN->TN_ORDEM   := (cTRBSTN)->TN_ORDEM
						STN->TN_PLANO   := (cTRBSTN)->TN_PLANO
						STN->TN_TAREFA  := (cTRBSTN)->TN_TAREFA
						STN->TN_SEQRELA := STL->TL_SEQRELA
						STN->TN_CODOCOR := (cTRBSTN)->TN_CODOCOR
						STN->TN_CAUSA   := (cTRBSTN)->TN_CAUSA
						STN->TN_SOLUCAO := (cTRBSTN)->TN_SOLUCAO
						STN->TN_DESCRIC := (cTRBSTN)->TN_DESCRIC
						*/
						DbSelectArea(cTRBSTN)
						RecLock((cTRBSTN),.F.)
						DbDelete()
						(cTRBSTN)->(MsUnLock())
						Dbskip()
					End
				EndIf
			EndIf
		EndIf
	Next ii

	If NGFUNCRPO("SgaMntEst",.F.) .And. GetMv("MV_SGAMNT") == "S" .And. GetMv("MV_NGSGAES") <> "N"
		SGINTMNT(aCamposSGA,2)
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA415OF
Processa finalizacao de O.S

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 12/05/2003

@sample MNTA415OF()

@return Nil
/*/
//---------------------------------------------------------------------
Function MNTA415OF()

	Local xy := 0
	Local aLista := {}

	Local cQueryTPL := ""
	Local cAliasTPL := ""

	ProcRegua(Len(aARRAYOS))
	For xy := 1 to len(aARRAYOS)

		cAliasTPL := GetNextAlias()

		cQueryTPL := " SELECT COUNT(*) AS TOTAL FROM " + RetSQLName("TPL") + " TPL "
		cQueryTPL += " WHERE TPL_FILIAL = " + ValToSQL(xFilial("STJ"))
		cQueryTPL += " AND TPL_ORDEM = " + ValToSQL(aARRAYOS[xy][1])
		cQueryTPL += " AND (TPL_DTFIM = '' "
		cQueryTPL += " OR TPL_HOFIM = '') "

		cQueryTPL := ChangeQuery(cQueryTPL)

		dbUseArea(.T., "TOPCONN", TCGENQRY(,, cQueryTPL), cAliasTPL, .F., .T.)

		If (cAliasTPL)->TOTAL == 0
			IncProc(OemtoAnsi(STR0035+aARRAYOS[xy][1]))
			NGIFDBSEEK("STJ",aARRAYOS[xy][1],1,.F.)
			If aARRAYOS[xy][11] .Or. aARRAYOS[xy][12]
				DbSelectArea("STJ")
				RecLock("STJ",.F.)
				STJ->TJ_POSCONT := aARRAYOS[xy][6] //Contador 1
				STJ->TJ_HORACO1 := aARRAYOS[xy][7] //Hora Cont 1
				STJ->TJ_POSCON2 := aARRAYOS[xy][8] //Contador 2
				STJ->TJ_HORACO2 := aARRAYOS[xy][9] //Hora Cont 2
				STJ->TJ_IRREGU  := aARRAYOS[xy][15] //Irregularidade
				If NGSTLPRO(aARRAYOS[xy][1],aARRAYOS[xy][14])
					STJ->TJ_DTMRINI := aARRAYOS[xy][16] //Data Manutencao Real Inicio
					STJ->TJ_HOMRINI := aARRAYOS[xy][17] //Hora Manutencao Real Inicio
					STJ->TJ_DTMRFIM := aARRAYOS[xy][10] //Data Manutencao Real Fim
					STJ->TJ_HOMRFIM := aARRAYOS[xy][18] //Hora Manutencao Real Fim
				EndIf
				cACODBEM := STJ->TJ_CODBEM
				MsUnlock("STJ")

				NGFINAL(aARRAYOS[xy][1],aARRAYOS[xy][14],aARRAYOS[xy][2],aARRAYOS[xy][4],;
				aARRAYOS[xy][3],aARRAYOS[xy][5],aARRAYOS[xy][6],aARRAYOS[xy][8],;
				aARRAYOS[xy][13],aARRAYOS[xy][7],aARRAYOS[xy][9])
			Else
				DbSelectArea("STJ")
				RecLock("STJ",.F.)
				STJ->TJ_IRREGU  := aARRAYOS[xy][15] //Irregularidade
				If NGSTLPRO(aARRAYOS[xy][1],aARRAYOS[xy][14])
					STJ->TJ_DTMRINI := aARRAYOS[xy][16] //Data Manutencao Real Inicio
					STJ->TJ_HOMRINI := aARRAYOS[xy][17] //Hora Manutencao Real Inicio
					STJ->TJ_DTMRFIM := aARRAYOS[xy][10] //Data Manutencao Real Fim
					STJ->TJ_HOMRFIM := aARRAYOS[xy][18] //Hora Manutencao Real Fim
				EndIf
				cACODBEM := STJ->TJ_CODBEM
				MsUnlock("STJ")

				NGFINAL(aARRAYOS[xy][1],aARRAYOS[xy][14],aARRAYOS[xy][2],aARRAYOS[xy][4],;
				aARRAYOS[xy][3],aARRAYOS[xy][5],aARRAYOS[xy][6],aARRAYOS[xy][8])
			EndIf

			//---------------------------------------------------
			lSTJAchou  := A415STJBUS(cACODBEM)
			If NGIFDBSEEK("ST9",cACODBEM,1,.F.)
				RecLock("ST9",.F.)
				If lSTJAchou = .F.
					ST9->T9_TERCEIR := "1"
				EndIf
				MsUnlock("ST9")
			EndIf
			//---------------------------------------------------

			NGIFDBSEEK("STj",aARRAYOS[xy][1],1,.F.)

			//Fechamento de solicitacao de servico
			//Redifinicao da variavel de controle para manipulacao do fechamento do solicitacao de servico
			lINCLUI  := INCLUI
			INCLUI   := .F.

			NGFECHASS(aARRAYOS[xy][1])
			INCLUI := lINCLUI

			(cAliasTPL)->(dbCloseArea())
		Else

			aAdd(aLista, aARRAYOS[xy][1])

			(cAliasTPL)->(DbCloseArea())

		EndIf

	Next xy

	If !Empty(aLista)
		MNT415MOTA(aLista)
	EndIf

	aLista := {}

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415CAD
Monta tela de finalizacao de O.S

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 06/09/2001

@sample NG415CAD()

@return lPROBSTP - Lógico
/*/
//---------------------------------------------------------------------
Function NG415CAD(nINCRE, lShow)

	Local xm         := 0
	Local oDlg3
	Local oMenu
	Local nLin       := 0
	Local cLaBel     := "X3_TITULO"
	Local lInsDifPro := .F.
	Local lWhen      := .T. // Indica se o campo dos contadores estarão fechados.

	Private cTENDFLAHA := AllTrim(GETMv("MV_NGTNDFL"))
	Private hHOPRINI,hHOPRFIM,hHOCON1,hHOCON2,dDTPRFIM,dDTPRINI,nPOSCO1,nPOSCO2
	Private cIRREGU    := SPACE(3), cNIRREGU := SPACE(40)

	Private dDTREAL,hHOREAL   := "  :  "
	Private dDINISTJ,cHINISTJ := "  :  ",cHFIMSTJ := "  :  "

	Private lLECON1 := aARRAYOS[nINCRE][11]
	Private lLECON2 := aARRAYOS[nINCRE][12]

	Default lShow   := .T.

	Store Space(5) To hHOPRINI,hHOPRFIM
	Store Ctod("  /  /  ") To dDTPRFIM,dDTPRINI,dDTREAL,dDINISTJ

	nPOSCO1 := IIf(lLECON1,NGSEEK('ST9',aARRAYOS[nINCRE][13],1,'T9_POSCONT'),0)
	nPOSCO2 := IIf(lLECON2,NGSEEK('TPE',aARRAYOS[nINCRE][13],1,'TPE_POSCON'),0)

	hHOREAL := "00:01"
	For xm := 1 To Len(aARRORDI)
		If !ATail(aARRORDI[xm]) .And. ;
		aARRORDI[xm][1] = aARRAYOS[nINCRE][1] .And. aARRORDI[xm,4] <> "P"
			If aARRORDI[xm][nDATAF4] > dDTREAL
				dDTREAL := aARRORDI[xm][nDATAF4]
				hHOREAL := aARRORDI[xm][nHORAF4]
			ElseIf aARRORDI[xm][nDATAF4] = dDTREAL
				hREAL1  := HtoM(hHOREAL)
				hREAL2  := HtoM(aARRORDI[xm][nHORAF4])
				hMAXIMA := MAX(hREAL1,hREAL2)
				hHOREAL := MtoH(hMAXIMA)
			EndIf
		EndIf
	Next xm

	If NGIFDBSEEK("STL",aARRORDI[nINCRE][1],1,.F.)
		While !Eof() .And. stl->tl_filial = Xfilial('STL') .And.;
		stl->tl_ordem = aARRORDI[nINCRE][1]
			If stl->tl_seqrela <> "0  " .And. stl->tl_tiporeg <> "P"
				dDTREAL := MAX(dDTREAL,stl->tl_dtfim)
				hREAL1  := HtoM(hHOREAL)
				hREAL2  := HtoM(stl->tl_hofim)
				hMAXIMA := MAX(hREAL1,hREAL2)
				hHOREAL := MtoH(hMAXIMA)
			EndIf
			Dbskip()
		End
	EndIf

	hHOCON1 := IIf(lLECON1,hHOREAL,'  :  ')
	hHOCON2 := IIf(lLECON2,hHOREAL,'  :  ')

	NGIFDBSEEK("STJ",aARRAYOS[nINCRE][1],1,.F.)
	lPROBSTP := .F.
	nOpca := 0

	If lShow

		If ExistBlock( "MNTA415B" )
			If cTipoCon <> 'N'
				lWhen := ExecBlock( "MNTA415B", .F., .F., { nPOSCO1, nPOSCO2 } )
			Else
				lWhen := .F.
			EndIf
		EndIf

		Define MsDialog oDlg3 Title STR0036 From 12,10 To 30,70 Of oMainWnd COLOR CLR_BLACK,CLR_WHITE
		oPnlPai := TPanel():New(00,00,,oDlg3,,,,,,70,28,.F.,.F.)
		oPnlPai:Align := CONTROL_ALIGN_ALLCLIENT

		@ 10,018 SAY OEMTOANSI(STR0037) SIZE 47,07 OF oPnlPai PIXEL Color CLR_HBLUE
		@ 10,050 MSGET aARRAYOS[nINCRE][1] SIZE 38,08 OF oPnlPai PIXEL When .F.

        @ 22,132 SAY OEMTOANSI(STR0039) SIZE 47,07 OF oPnlPai PIXEL
        @ 22,164 MSGET hHOCON1 SIZE 38,08 OF oPnlPai PIXEL PICTURE "99:99";
            VALID MNTA415HO(hHOCON1,nPOSCO1) .And. MNTA415CCB(aARRAYOS[nINCRE][13], IIF(Empty(dDINISTJ),dDTREAL,dDINISTJ), hHOCON1) When lWhen

		@ 22,018 SAY OEMTOANSI(STR0040) SIZE 47,07 OF oPnlPai PIXEL
		@ 22,050 MSGET dDTPRINI SIZE 45,08 OF oPnlPai PIXEL PICTURE '99/99/9999' HASBUTTON

		@ 34,132 SAY OEMTOANSI(STR0041) SIZE 47,07 OF oPnlPai PIXEL
		@ 34,164 MSGET hHOPRINI SIZE 38,08 OF oPnlPai PIXEL PICTURE "99:99" //VALID MNT415HI()

		@ 34,018 SAY OEMTOANSI(STR0042) SIZE 47,07 OF oPnlPai PIXEL
		@ 34,050 MSGET dDTPRFIM SIZE 45,08 OF oPnlPai PIXEL PICTURE '99/99/9999' HASBUTTON

		@ 46,132 SAY OEMTOANSI(STR0043) SIZE 47,07 OF oPnlPai PIXEL
		@ 46,164 MSGET hHOPRFIM SIZE 38,08 OF oPnlPai PIXEL PICTURE "99:99" //VALID MNT415HF()

		@ 58,132 SAY OEMTOANSI(STR0045) SIZE 47,07 OF oPnlPai PIXEL
		@ 58,164 MSGET hHOCON2 SIZE 38,08 OF oPnlPai PIXEL PICTURE "99:99";
		VALID MNTA415HO(hHOCON2,nPOSCO2) When lWhen

		For xm := 1 to Len(aCols)
			If !ATail(aCOLS[xm]) .AND. aCols[xm][nORDEM4] == aARRAYOS[nINCRE][1] .AND.;
			aCols[xm][nTIPOI4] $ "TFM"
				lInsDifPro := .T.
			EndIf
		Next

		If NGSTLPRO(aARRAYOS[nINCRE][1],aARRAYOS[nINCRE][14]) .And. !lInsDifPro
			dDINISTJ := STJ->TJ_DTMPINI
			cHINISTJ := STJ->TJ_HOMPINI
			cHFIMSTJ := STJ->TJ_HOMPFIM

			@ 46,018 SAY OEMTOANSI(RetTitSX3("TJ_DTMRINI")) SIZE 47,07 OF oPnlPai PIXEL
			@ 46,050 MSGET dDINISTJ SIZE 45,08 OF oPnlPai PIXEL PICTURE '99/99/9999' When .T. HASBUTTON

			@ 70,132 SAY OEMTOANSI(RetTitSX3("TJ_HOMRINI")) SIZE 47,07 OF oPnlPai PIXEL
			@ 70,164 MSGET cHINISTJ SIZE 38,08 OF oPnlPai PIXEL PICTURE "99:99" VALID VALHORA(cHINISTJ) When .T.

			dDTREAL := STJ->TJ_DTMPFIM
			@ 82,018 SAY OEMTOANSI(RetTitSX3("TJ_DTMRFIM")) SIZE 47,07 OF oPnlPai PIXEL
			@ 82,050 MSGET dDTREAL  SIZE 45,08 OF oPnlPai PIXEL PICTURE '99/99/9999' When .T. HASBUTTON

			@ 82,132 SAY OEMTOANSI(RetTitSX3("TJ_HOMRFIM")) SIZE 47,07 OF oPnlPai PIXEL
			@ 82,164 MSGET cHFIMSTJ SIZE 38,08 OF oPnlPai PIXEL PICTURE "99:99" VALID VALHORA(cHFIMSTJ) .AND. COMPDATA(dDINISTJ,cHINISTJ,dDTREAL,cHFIMSTJ) When .T.
			nLin := 12
		Else
			@ 46,018 SAY OEMTOANSI(RetTitSX3("TJ_DTMRFIM")) SIZE 47,07 OF oPnlPai PIXEL
			@ 46,050 MSGET dDTREAL SIZE 45,08 OF oPnlPai PIXEL PICTURE '99/99/9999' When .F. HASBUTTON
			@ 70,132 SAY OEMTOANSI(RetTitSX3("TJ_HOMRFIM")) SIZE 47,07 OF oPnlPai PIXEL
			@ 70,164 MSGET hHOREAL SIZE 38,08 OF oPnlPai PIXEL PICTURE "99:99" When .F.
		EndIf

        @ 58,018 SAY OEMTOANSI(STR0038)SIZE 47,07 OF oPnlPai PIXEL
        @ 58,050 MSGET nPOSCO1 SIZE 38,08 OF oPnlPai PIXEL PICTURE '999999999';
            Valid MNTA415CO(aARRAYOS[nINCRE][1],nPOSCO1,1) When lWhen .And. (!FindFunction("NGBlCont") .Or. NGBlCont( aARRAYOS[nINCRE][13] ))

		@ 70,018 SAY OEMTOANSI(STR0044) SIZE 47,07 OF oPnlPai PIXEL
		@ 70,050 MSGET nPOSCO2 SIZE 38,08 OF oPnlPai PIXEL PICTURE '999999999';
		Valid MNTA415CO(aARRAYOS[nINCRE][1],nPOSCO2,2) When lWhen

		//FORCA A DIGITACAO DA IRREGULARIDADE
		If cTENDFLAHA != "N" .And. STJ->TJ_PLANO == "000000" //os corretiva
			If cTENDFLAHA = 'S'
				@ 82+nLin,018 SAY STR0073 SIZE 47,07 OF oPnlPai PIXEL Color CLR_HBLUE
			Else
				@ 82+nLin,018 SAY STR0073 SIZE 47,07 OF oPnlPai PIXEL
			EndIf
			@ 82+nLin,050 MSGET cIRREGU SIZE 38,7   OF oPnlPai PIXEL Picture '@!' Valid MNT415TP7() F3 "TP7" HASBUTTON
			@ 82+nLin,089 MSGET cNIRREGU SIZE 113,7 OF oPnlPai PIXEL Picture '@!' When .F.
		EndIf

		NGPOPUP(asMenu,@oMenu)
		oDlg3:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg3)}


		ACTIVATE MSDIALOG oDlg3 ON INIT EnchoiceBar(oDlg3,{||nOpca:=1,IIf(!MNTA415ST(nINCRE,lInsDifPro),nOpca:=2,oDlg3:End())},{||oDlg3:End()}) CENTERED
	Else
		If !Empty(aARRAYOS[nINCRE][15])
			cIrregu := aARRAYOS[nINCRE][15]
		EndIf
		For xm := 1 to Len(aCols)
			If !ATail(aCOLS[xm]) .AND. aCols[xm][nORDEM4] == aARRAYOS[nINCRE][1] .AND.;
			aCols[xm][nTIPOI4] $ "TFM"
				lInsDifPro := .T.
			EndIf
		Next
		If NGSTLPRO(aARRAYOS[nINCRE][1],aARRAYOS[nINCRE][14]) .And. !lInsDifPro
			dDINISTJ := STJ->TJ_DTMPINI
			cHINISTJ := STJ->TJ_HOMPINI
			cHFIMSTJ := STJ->TJ_HOMPFIM
			dDTREAL  := STJ->TJ_DTMPFIM
		EndIf
		nOpca := 1
		MNTA415ST(nINCRE,lInsDifPro)
	EndIf

	NGIFDBSEEK("STJ",aARRAYOS[nINCRE][1],1,.F.)
	If nOpca = 1 .And. lPROBSTP
		aARRAYOS[nINCRE][2]  := dDTPRINI  // dt.parada inicio
		aARRAYOS[nINCRE][3]  := dDTPRFIM  // dt.parada fim
		aARRAYOS[nINCRE][4]  := hHOPRINI  // hora parada inicio
		aARRAYOS[nINCRE][5]  := hHOPRFIM  // hora parada fim
		aARRAYOS[nINCRE][6]  := nPOSCO1   // contador 1
		aARRAYOS[nINCRE][7]  := hHOCON1   // hora cont. 1
		aARRAYOS[nINCRE][8]  := nPOSCO2   // contador 2
		aARRAYOS[nINCRE][9]  := hHOCON2   // hora cont. 2
		aARRAYOS[nINCRE][10] := dDTREAL   // dt real final
		aARRAYOS[nINCRE][15] := cIRREGU   // irregularidade
		If NGSTLPRO(aARRAYOS[nINCRE][1],aARRAYOS[nINCRE][14]) .AND. !lInsDifPro
			aARRAYOS[nINCRE][16] := dDINISTJ   // Data Manutencao Real Inicio
			aARRAYOS[nINCRE][17] := cHINISTJ   // Hora Manutencao Real Inicio
			aARRAYOS[nINCRE][18] := cHFIMSTJ   // Hora Manutencao Real Fim
		EndIf
	Else
		lPROBSTP := .F.
	EndIf

Return lPROBSTP

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT415TP7
Consistência do campo Irregularidade

@type function

@source MNTA415.prx

@author Ricardo Dal Ponte
@since 13/09/2006

@sample MNT415TP7()

@return Lógico
/*/
//---------------------------------------------------------------------
Function MNT415TP7()

	If Empty(cIRREGU)
		cNIRREGU := Space( TAMSX3("TP7_NOME")[1] )
	ElseIf !EXISTCPO("TP7",cIRREGU)
		cNIRREGU := Space( TAMSX3("TP7_NOME")[1] )
		Return .F.
	EndIf

	cNIRREGU := Posicione("TP7",1,xFilial("TP7")+cIRREGU,"TP7_NOME")

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA415ST
Consistência na finalizacão da O.S.

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 12/05/2003

@sample MNTA415ST()

@return lPROBSTP - Lógico
/*/
//---------------------------------------------------------------------
Function MNTA415ST(nVITE,_lInsDifPr)

	lPROBSTP := .F.

	If aARRAYOS[nVITE][11]
		If !Empty(nPOSCO1)
			If !NGCHKHISTO(aARRAYOS[nVITE][13],dDTREAL,nPOSCO1,hHOCON1,1,,.T.)
				Return lPROBSTP
			EndIf
			If !NGVALIVARD(aARRAYOS[nVITE][13],nPOSCO1,dDTREAL,hHOCON1,1,.T.)
				Return lPROBSTP
			EndIf
		EndIf
	EndIf

	If aARRAYOS[nVITE][12]
		If !Empty(nPOSCO2)
			If !NGCHKHISTO(aARRAYOS[nVITE][13],dDTREAL,nPOSCO2,hHOCON2,2,,.T.)
				Return lPROBSTP
			EndIf
			If !NGVALIVARD(aARRAYOS[nVITE][13],nPOSCO2,dDTREAL,hHOCON2,2,.T.)
				Return lPROBSTP
			EndIf
		EndIf
	EndIf

	//FORCA A DIGITACAO DA IRREGULARIDADE
	If cTENDFLAHA == "S" .And. STJ->TJ_PLANO == "000000" //os corretiva
		If Empty(cIRREGU)
			MsgInfo(STR0072 ,STR0014)//'Obrigatorio informar o Codigo da Irregularidade','ATENCAO'
			Return lPROBSTP
		EndIf
	EndIf

	If NGSTLPRO(aARRAYOS[nVITE][1],aARRAYOS[nVITE][14]) .AND. !_lInsDifPr
		If !NGFIMOBRIG(dDINISTJ,cHINISTJ,dDTREAL,cHFIMSTJ)
			Return lPROBSTP
		EndIf
	EndIf

	If Empty(dDTPRINI) .And. Empty(dDTPRFIM) .And. ((Empty(hHOPRINI) .And. Empty(hHOPRFIM)) .Or. (AllTrim(hHOPRINI)) = ":"  .And. (AllTrim(hHOPRFIM)) = ":")
		lPROBSTP := .T.
	Else
		If Empty(dDTPRINI) .Or.  Empty(dDTPRFIM) .Or. (AllTrim(hHOPRINI) = ":" .Or. Empty(hHOPRINI)) .Or. (AllTrim(hHOPRFIM) = ":" .Or. Empty(hHOPRFIM))
			MsgInfo(STR0101+" "+STR0040+' , '+STR0041+" , "+STR0042+" , "+STR0043,STR0052)
			Return lPROBSTP
		Else
			If !MNT415HI()
				Return lPROBSTP
			EndIf
			If !MNT415HF()
				Return lPROBSTP
			EndIf
			If dDTPRFIM < dDTPRINI
				MsgInfo(STR0042+" "+STR0123+' '+STR0040,STR0052)
				Return lPROBSTP
			ElseIf dDTPRFIM = dDTPRINI .And. hHOPRFIM < hHOPRINI
				MsgInfo(STR0043+" "+STR0123+' '+STR0041,STR0052)
				Return lPROBSTP
			EndIf
		EndIf
		lPROBSTP := .T.
	EndIf

Return lPROBSTP

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415CHKOS
Faz a consistencia da Ordem de Servico.

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 06/09/2001

@sample NG415CHKOS()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415CHKOS()

	Local lRet := .T.

	dbSelectArea("STJ")
	dbSetOrder(01)

	If !ExistCpo("STJ",M->TPL_ORDEM)
		lRet := .F.
	EndIf
	If lRet .And. NG400VALOS(NGSEEK("STJ",M->TPL_ORDEM,1,"STJ->TJ_CODBEM"),NGSEEK("STJ",M->TPL_ORDEM,1,"STJ->TJ_SERVICO"))
		lRet := .F.
	EndIf
	NGIFDBSEEK("STJ",M->TPL_ORDEM,1,.F.)
	If lRet .And. STJ->TJ_SITUACA == "C"
		MsgStop(STR0133,STR0014) //"Ordem de Serviço está Cancelada"##"Atenção"
		lRet := .F.
	ElseIf lRet .And. STJ->TJ_SITUACA <> "L"
		MsgStop(STR0126,STR0014) //"Ordem de Serviço não está liberada"##"Atenção"
		lRet := .F.
	ElseIf lRet .And. STJ->TJ_TERMINO <> "N"
		MsgStop(STR0127,STR0014) //"Ordem de Serviço está terminada"##"Atenção"
		lRet := .F.
	EndIf

	If lRet .And. STJ->TJ_TIPOOS == "B"
		If !NGBEMATIV(STJ->TJ_CODBEM)
			lRet := .F.
		EndIf
		If lRet .And. !NGMANATIV(STJ->TJ_CODBEM,STJ->TJ_SERVICO,STJ->TJ_SEQRELA)
			lRet := .F.
		EndIf
	EndIf

	If lRet .And. NGIFDBSEEK("STJ",M->TPL_ORDEM,1,.F.)
		aCols[n][nCOBEM4] := STJ->TJ_CODBEM
		MV_PAR01 := STJ->TJ_CODBEM
		MV_PAR02 := STJ->TJ_SERVICO
		MV_PAR05 := STJ->TJ_SEQRELA
		cPar01   := MV_PAR01
		cPar02   := MV_PAR02
		cPar05   := MV_PAR05
		lCORRET  := IIf(Val(STJ->TJ_PLANO) = 0,.T.,.F.)

		If lCORRET .And. lUSATARG
			aTROCAF3 := {}
			aAdd(aTROCAF3,{"TL_TAREFA", "TT9"})
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415TudOk
Validacao na confirmacao dos dados e gravacao no STL.

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 06/09/2001

@sample NG415TudOk()

@return Lógico
/*/
//---------------------------------------------------------------------
FUNCTION NG415TudOk

	If !MNTA415TU()
		Return .F.
	EndIf

	If !MNTA415NI()
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415ACOLS
Limpa a acols.

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 22/10/2002

@sample NG415ACOLS()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415ACOLS

	Local aCposAlter	:= {}
	Local aPosCpo		:= {}
	Local nPosCpo		:= 0
	Local nI			:= 0

	aCols	:= {}
	aCols	:= BLANKGETD(aHeader)

	aCOLS[1][nTAREF4] := IIf(!Empty(cRELATAR),&cRELATAR,Space(6))	// TAREFA
	aCOLS[1][nTIPOI4] := IIf(!Empty(cRELATIP),&cRELATIP,Space(1))	// TIPO DE INSUMO
	aCols[1][nUSACA4] := "N"										// USA CALENDARIO
	aCOLS[1][nDATAI4] := dDataBase									// DATA INICIO
	If nOBSER4 > 0
		aCOLS[1][nOBSER4] := cSTLOBS								// OBSERVACAO
	EndIf
	aCols[1][nGARAN4] := "N"										// GARANTIA

	If nDESCR4 > 0
		aCols[1][nDESCR4] := Space(40)
	EndIf
	If nPERMI4 > 0
		aCols[1][nPERMI4] := 0.00
	EndIf
	If nNTFIS4 > 0
		aCOLS[1][nNTFIS4] := Space(06)								// NOTA FISCAL
	EndIf

	If nSERIE4 > 0
		aCOLS[1][nSERIE4] := Space(03)								// SERIE NF
	EndIf

	DbSelectArea("SX3")

	//+-----------------------------------------+
	//| Preenche o array auxiliar aCposAlter... |
	//+-----------------------------------------+
	If ExistBlock("NG415CPU")
		aCposAlter := ExecBlock("NG415CPU",.F.,.F.)
	EndIf
	If Len(aCposAlter) > 0
		For nI := 1 To Len(aCposAlter)
			nPosCpo := aScan(aHeader,{|x| AllTrim(x[2])==aCposAlter[nI]})
			aAdd(aPosCpo,{aCposAlter[nI],nPosCpo})
			aCOLS[1][nPosCpo] := CriaVar(aCposAlter[nI])
		Next nI
	EndIf

	aCols[1][Len(aHeader)-1] := "STL"
	aCols[1][Len(aHeader)]   := STL->(Recno())
	aCOLS[1][Len(aHeader)+1] := .F.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA415TU
Verifica campos obrigatorios.

@type function

@source MNTA415.prx

@author Elisangela Costa
@since 22/10/2002

@sample MNTA415TU()

@return lRETOR - Lógico
/*/
//---------------------------------------------------------------------
Function MNTA415TU(nN,lGRAVA)

	Local cMENSA    	:= Space(1)
	Local cOLDALI   	:= ALIAS()
	Local lRETOR    	:= .T.
	Local lMNT41510		:= ExistBlock("MNT41510")
	Local lMNT41508		:= ExistBlock("MNT41508")
	Local nININC    	:= IIf(nN = NIL,1,nN)
	Local nVEZIN    	:= IIf(nN = NIL,Len(aCols),nN),xx
	Local nF 			:= 0
	Local aINSALRAST 	:= {}
	Local aLocFi 		:= {}
	Local aINSALMOX 	:= {}

	If aCols[n][Len(aCols[n])] .and. !lGRAVA//Deletado
		Return .T.
	EndIf
	For xx := nININC to nVEZIN
		If !aCOLS[xx][LEN(aCOLS[xx])]

			If lMNT41510
				If !ExecBlock( 'MNT41510', .F., .F., { xx } )
					Return .F.
				EndIf
			EndIf

			If Empty(aCOLS[xx][nORDEM4])
				cMENSA := STR0015+str(xx,3) //"Ordem de servico nao informada no item  "
			EndIf

			If Empty(cMENSA) .And. Empty(aCOLS[xx][nTAREF4])
				cMENSA := STR0016+str(xx,3) //"Tarefa nao informada no item  "
			EndIf

			If Empty(cMENSA) .And. Empty(aCOLS[xx][nTIPOI4])
				cMENSA := STR0017+str(xx,3) //"Tipo nao informado no item  "
			EndIf

			If Empty(cMENSA) .And. Empty(aCOLS[xx][nCODIG4])
				cMENSA := STR0018+str(xx,3) //"Codigo nao informado no item  "
			EndIf

			If Empty(cMENSA) .And. Empty(aCOLS[xx][nDATAI4])
				cMENSA := STR0021+str(xx,3) //"Data inicio nao informada no item  "
			EndIf

			If Empty(cMENSA) .And. Empty(aCOLS[xx][nHORAI4])
				cMENSA := STR0022+str(xx,3) //"Hora inicio nao informada no item  "
			EndIf

			If Empty(cMENSA) .And. !Empty(aCOLS[xx][nDATAF4]) .And. aCOLS[xx][nDATAF4] > dDataBase
				cMENSA := STR0124+Str(xx,3) //"Data Fim não poderá ser maior do que a data atual no item "
			EndIf

			If  aCOLS[xx][nTIPOI4] = 'F' .And. Empty(ACOLS[xx,nQUANR4])
				cMENSA := STR0128+Str(xx,3) //"'Quantidade do Recurso' não informado no item"
			EndIf

			If !Empty(cMENSA)
				Exit
			EndIf

			//-------------------------------------------------------
			// Ponto de entrada para realizar validações específicas
			// de sobreposição de insumo no Banco de dados
			//-------------------------------------------------------
			If lMNT41508
				If !ExecBlock("MNT41508",.F.,.F.,{xx})
					Return .F.
				EndIf
			Else
				If !NGVDTINS(aCols[xx][nCODIG4],aCols[xx][nDATAI4],aCols[xx][nHORAI4],aCols[xx][nDATAF4],aCols[xx][nHORAF4],aCols[xx][nTIPOI4])
					Return .F.
				EndIf
			EndIf

			M->TL_TIPOREG := aCols[xx,nTIPOI4]
			M->TL_UNIDADE := aCols[xx,nUNIDA4]
			M->TL_QUANREC := aCols[xx,nQUANR4]
			M->TL_QUANTID := aCols[xx,nQUANT4]
			M->TL_CODIGO  := aCols[xx,nCODIG4]
			M->TL_USACALE := aCols[xx,nUSACA4]

			If !CHECKCOD(.T.,.F.)
				Return .F.
			EndIf

			// VALIDAÇÕES PARA INSUMOS DO TIPO PRODUTO.
			If aCOLS[xx][nTIPOI4] == 'P'

				If Empty(aCOLS[xx][nQUANT4])
					cMENSA := STR0019+str(xx,3) //"Quantidade nao informada no item  "
				EndIf

				If Empty(cMENSA) .And. Empty(aCOLS[xx][nUNIDA4])
					cMENSA := STR0020+str(xx,3) //"Unidade nao informada no item  "
				EndIf

				If Empty(cMENSA) .And. Empty(aCOLS[xx][nDESTI4])
					cMENSA := STR0023+str(xx,3) //"Destino nao informado no item  "
				EndIf

				If Empty(cMENSA) .And. Empty(aCOLS[xx][nLOCAL4])
					cMENSA := STR0024+str(xx,3) //"Almoxarifado nao informado no item  "
				EndIf

				If !Empty(cMENSA)
					Exit
				EndIf

				//Alimenta a array para checar o saldo dos produtos de toda
				//a acols
				// - esta validacao esta sendo feita em NGSALDOES, logo abaixo
				If Empty(cMENSA) .And. nN = nil
					If cUSAINT3 = "S" .And. !lEstNega

						nPOS415 := aScan(aINSALMOX,{|x| x[1]+x[2] == aCOLS[xx][nCODIG4]+aCOLS[xx][nLOCAL4]})
						If nPOS415 = 0
							aAdd(aINSALMOX,{aCOLS[xx][nCODIG4],aCOLS[xx][nLOCAL4],aCOLS[xx][nQUANT4]})
						Else
							aINSALMOX[nPOS415][3] += aCOLS[xx][nQUANT4]
						EndIf
					EndIf
				EndIf

				If Empty(cMENSA)
					//verifica se insumo eh controlado por garantia
					If aCols[xx][nGARAN4] == "N"
						If NGIFDBSEEK("TPY",aCols[xx][nCOBEM4]+aCols[xx][nCODIG4],1,.F.)
							If !Empty(TPY->TPY_QTDGAR) .Or. !Empty(TPY->TPY_QTDCON)
								Help(" ",1,"NGATENCAO",,STR0077,3,1)  //"Insumo controlado por garantia, informar campo Tem Garantia = Sim."
								Return .F.
							EndIf
						EndIf
					EndIf
				EndIf

				If Empty(cMENSA)
					If nN <> nil

						// QUANDO INTEGRADO COM O MÓDULO DE ESTOQUE.
						If cUSAINT3 == 'S'

							// VALIDA SE O PRODUTO NO LOCAL INFORMADO ENCONTRA-SE EM PROCESSO DE INVENTÁRIO.
							If ( nCODIG4 > 0 .And. nLOCAL4 > 0 ) .And. BlqInvent( aCols[xx,nCODIG4], aCols[xx,nLOCAL4] )

								Help( '', 1, 'BLQINVENT' )
								Return .F.

							EndIf

							If LOCALIZA(Trim(ACOLS[xx,nCODIG4]))

								//Valida a obrigatoriedade de informar o enderecamento fisico se o produto
								//tem o controle
								If Empty(ACOLS[xx,nLOCALI]) .And. Empty(ACOLS[xx,nNUMSEI])
									Help(" ",1,"LOCALIZOBR")
									Return .F.
								ElseIf Empty(ACOLS[xx,nLOCALI])
									Help(" ",1,"LOCALIZOBR")
									Return .F.
								EndIf

								//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
								If !MtAvlNSer(ACOLS[xx,nCODIG4],ACOLS[xx,nNUMSEI],ACOLS[xx,nQUANT4])
									Return .F.
								EndIf

								cLOC := aCols[xx][nLOCAL4]  // Local/almoxarifado
								cLOL := aCols[xx][nLOCALI]  // Localizacao fisica
								cCOD := aCols[xx][nCODIG4]  // Codigo
								cNUS := aCols[xx][nNUMSEI]  // Numero da serie
								cSBL := aCols[xx][nNUMLO4]  // Numero do lote
								nQTD := aCols[xx][nQUANT4]  // Quantidade
								cLOT := aCols[xx][nLOTEC4]  // lotectla

								For nf := 1 To Len(acols)
									If nf <> nN
										If !aCOLS[nf][LEN(aCOLS[nf])]
											If aCOLS[nf,nTIPOI4] = 'P'
												If aCols[xx][nLOCAL4]+aCols[xx][nLOCALI]+aCols[xx][nCODIG4]+;
												aCols[xx][nNUMSEI]+aCols[xx][nLOTEC4]+aCols[xx][nNUMLO4] = cLOC+cLOL+cCOD+cNUS+cLOT+cSBL
													nQTD += aCols[nf][nQUANT4]
												EndIf
											EndIf
										EndIf
									EndIf
								Next nf

								If (!Empty(cLOC) .Or. !Empty(cNUS)) .And.;
								QtdComp(SaldoSBF(cLOC,cLOL,cCOD,cNUS,cLOT,cSBL,.F.)) < QtdComp(nQTD)
									Help(" ",1,"SALDOLOCLZ")
									Return .F.
								EndIf

							EndIf
						EndIf
					Else

						// QUANDO INTEGRADO COM O MÓDULO DE ESTOQUE.
						If cUSAINT3 == 'S'

							cLOC := aCols[xx][nLOCAL4]  // Local/almoxarifado
							cLOL := aCols[xx][nLOCALI]  // Localizacao fisica
							cCOD := aCols[xx][nCODIG4]  // Codigo
							cNUS := aCols[xx][nNUMSEI]  // Numero da serie
							cSBL := aCols[xx][nNUMLO4]  // Numero do lote
							nQTD := aCols[xx][nQUANT4]  // Quantidade

							// VALIDA SE O PRODUTO NO LOCAL INFORMADO ENCONTRA-SE EM PROCESSO DE INVENTÁRIO.
							If BlqInvent( cCOD, cLOC )

								Help( '', 1, 'BLQINVENT' )
								Return .F.

							EndIf

							If nLOTEC4 > 0
								cLOT := aCols[xx][nLOTEC4]  // lotectla
							Else
								cLOT := Space(Len(STL->TL_LOTECTL))
							EndIf

							nPosLF := aScan(aLocFi,{|x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6] == cLOC+cLOL+cCOD+cNUS+cLOT+cSBL})
							If nPosLF = 0
								aAdd(aLocFi,{cLOC,cLOL,cCOD,cNUS,cLOT,cSBL,nQTD})
							Else
								aLocFi[nPosLF,7] += nQTD
							EndIf
						EndIf
					EndIf
				EndIf
			Else
				M->TL_TIPOREG := aCols[xx,nTIPOI4]
				M->TL_UNIDADE := aCols[xx,nUNIDA4]
				M->TL_QUANREC := aCols[xx,nQUANR4]
				M->TL_QUANTID := aCols[xx,nQUANT4]
				M->TL_USACALE := aCols[xx,nUSACA4]

				If !NGQUANTCHK(M->TL_TIPOREG,M->TL_UNIDADE,M->TL_QUANTID,M->TL_USACALE)
					Return .F.
				EndIf
			EndIf

			If aCOLS[xx][nTIPOI4] <> 'P'
				If Empty(aCOLS[xx][nDATAI4]) .Or. Empty(aCOLS[xx][nHORAF4])
					cMENSA := STR0053+" "+str(xx,3)
					Exit
				EndIf
			EndIf

			If Empty(cMENSA)
				If !NGCHKMESFE(Acols[xx,nDATAI4],Acols[xx,nTIPOI4])
					Return .F.
				EndIf
			EndIf

			//Valida afastamentos da mao de obra no RH
			If aCOLS[xx][nTIPOI4] == 'M' .And. Empty(cMENSA)
				If !NGFRHAFAST(aCOLS[xx][nCODIG4],aCOLS[xx][nDATAI4],aCOLS[xx][nDATAF4],.T.)
					Return .F.
				EndIf

				If !NGFUNCRH(aCOLS[xx][nCODIG4],.T.,aCOLS[xx][nDATAF4])
					Return .F.
				EndIf
			EndIf

			// Valida se a data de baixa de estoque é maior que a data de bloqueio de estoque (MNTA415TU)
			If aCols[xx][nTIPOI4] <> "F"
				If !MNTValDBl(aCols[xx][nDATAI4])
					Return .F.
				EndIf
			EndIf
		EndIf
	Next xx


	// Verifica se o estoque(SB2) podera ficar negativo
	DbSelectArea("STL")
	If aCols[n][nTIPOI4] == "P" .and. !aCOLS[n][LEN(aCOLS[n])]
		nLineOS := n
		If cUsaInt3  == "S"
			If !lEstNega

				DbSelectArea("SB2")
				dbSetOrder(1)
				If !dbSeek(xFilial("SB2") + aCols[n][nCODIG4] + aCols[n][nLOCAL4])
					MsgInfo(STR0061+aCols[n][nCODIG4]+STR0109+aCols[n][nLOCAL4],STR0014) //"Produto "###" não cadastrado no almoxarifado "###'ATENCAO'
					DbSelectArea(cOLDALI)
					Return .F.
				EndIf

				If !NGSALDOES(aCols[n][nCODIG4],aCols[n][nLOCAL4],aCols[n][nQUANT4],.T.,nLineOS,1,,,,,aCols[n][nDATAI4])
					DbSelectArea(cOLDALI)
					Return .F.
				EndIf

				//Adiciona o Produto+Local na lista para checar o estoque na gravacao dos dados
				If aScan( aProd435 ,{|x| x[1]+x[2] == aCols[n][nCODIG4]+aCols[n][nLOCAL4] }) == 0
					aAdd( aProd435 , { aCols[n][nCODIG4] , aCols[n][nLOCAL4] } )
				EndIf
			EndIf

			//Valida saldo(SB8) de controle de rastreabilidade por lote do produto
			If Rastro(aCols[n][nCODIG4])
				If Rastro(aCols[n][nCODIG4],"S")
					//Valida o sub-lote
					If Empty(aCols[n][nNUMLO4])
						Help(" ",1,"NGATENCAO",,STR0069,3,1) //"Numero do sub-lote não informado"
						Return .F.
					Else
						If !NGSALDOES(aCols[n][nCODIG4],aCols[n][nLOCAL4],aCols[n][nQUANT4],.T.,nLineOS,2,aCols[n][nLOTEC4],aCols[n][nNUMLO4],nil,nil,aCols[n][nDATAI4])
							DbSelectArea(cOLDALI)
							Return .F.
						EndIf

						//Adiciona no Array para validar saldo de Sub-Lote
						If aScan( aSubL435 ,{|x| x[1]+x[2]+x[3]+x[4] == aCols[n][nCODIG4]+aCols[n][nLOCAL4]+aCols[n][nLOTEC4]+aCols[n][nNUMLO4] }) == 0
							aAdd( aSubL435 , { aCols[n][nCODIG4] , aCols[n][nLOCAL4] , aCols[n][nLOTEC4] , aCols[n][nNUMLO4] } )
						EndIf
					EndIf
				Else
					//Valida o lote
					If nLOTEC4 > 0
						If Empty(aCols[n][nLOTEC4])
							Help(" ",1,"NGATENCAO",,STR0110,3,1) //"Numero do lote não informado"
							Return .F.
						Else
							If !NGSALDOES(aCols[n][nCODIG4],aCols[n][nLOCAL4],aCols[n][nQUANT4],.T.,nLineOS,3,aCols[n][nLOTEC4],aCols[n][nNUMLO4],nil,nil,aCols[n][nDATAI4])
								DbSelectArea(cOLDALI)
								Return .F.
							EndIf

							//Adiciona no Array para validar saldo de Lote
							If aScan( aLote435 ,{|x| x[1]+x[2]+x[3] == aCols[n][nCODIG4]+aCols[n][nLOCAL4]+aCols[n][nLOTEC4] }) == 0
								aAdd( aLote435 , { aCols[n][nCODIG4] , aCols[n][nLOCAL4] , aCols[n][nLOTEC4] } )
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf

			//Validacao do LOCALIZACAO
			//Verifica se ha problema na habilitacao do controle por enderecamento fisico
			If !Empty(aCols[n][nLOCALI]) .Or. !Empty(aCols[n][nNUMSEI])
				If !LOCALIZA(Trim(aCols[n][nCODIG4]))
					MsgInfo(STR0111+chr(13)+STR0112,; //"O parâmetro MV_LOCALIZ esta desativado ou o campo"###" B1_LOCALIZ do produto esta preenchido com N."
					STR0052) //"NAO CONFORMIDADE"
					Return .F.
				EndIf
			EndIf

			If LOCALIZA(Trim(aCols[n][nCODIG4]))
				//Valida a obrigatoriedade de informar o enderecamento fisico se o produto tem o controle
				If Empty(aCols[n][nLOCALI]) .And. Empty(aCols[n][nNUMSEI])
					Help(" ",1,"LOCALIZOBR")
					Return .F.
				ElseIf Empty(aCols[n][nLOCALI])
					Help(" ",1,"LOCALIZOBR")
					Return .F.
				EndIf

				If !Empty(aCols[n][nLOCALI])
					If !EXISTCPO("SBE",aCols[n][nLOCAL4]+aCols[n][nLOCALI])
						Return .F.
					EndIf
				EndIf

				//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
				If !MtAvlNSer(aCols[n][nCODIG4],aCols[n][nNUMSEI],aCols[n][nQUANT4])
					Return .F.
				EndIf

				If !Empty(aCols[n][nLOCALI]) .Or. !Empty(aCols[n][nNUMSEI])
					If !NGSALDOES(aCols[n][nCODIG4],aCols[n][nLOCAL4],aCols[n][nQUANT4],.T.,nLineOS,4,aCols[n][nLOTEC4],aCols[n][nNUMLO4],aCols[n][nLOCALI],aCols[n][nNUMSEI])
						DbSelectArea(cOLDALI)
						Return .F.
					EndIf

					//Adiciona no Array para validar saldo de Enderecamento
					If aScan( aEnde435 ,{|x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6] == aCols[n][nCODIG4]+aCols[n][nLOCAL4]+;
					aCols[n][nLOCALI]+aCols[n][nNUMSEI]+aCols[n][nLOTEC4]+aCols[n][nNUMLO4] }) == 0
						aAdd( aEnde435 , { aCols[n][nCODIG4] , aCols[n][nLOCAL4] , aCols[n][nLOCALI] , aCols[n][nNUMSEI] , aCols[n][nLOTEC4] , aCols[n][nNUMLO4] } )
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	// - esta validacao esta sendo feita em NGSALDOES, acima
	If nN = nil .And. Empty(cMENSA)
		//Valida estoque negativo
		If Len(aINSALMOX) >  0
			For xx := 1 To Len(aINSALMOX)
				If !NGSALSB2(aINSALMOX[xx][1],aINSALMOX[xx][2],aINSALMOX[xx][3])
					Return .F.
				EndIf
			Next
		EndIf
	EndIf

	If Len(aLocFi) > 0 .And. cUSAINT3 = "S"
		For nf := 1 To Len(aLocFi)
			If LOCALIZA(Trim(aLocFi[nf,3]))

				//Valida a obrigatoriedade de informar o enderecamento fisico se o produto
				//tem o controle
				If Empty(aLocFi[nf,2]) .And. Empty(aLocFi[nf,4])
					Help(" ",1,"LOCALIZOBR")
					Return .F.
				ElseIf Empty(aLocFi[nf,2])
					Help(" ",1,"LOCALIZOBR")
					Return .F.
				EndIf

				//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
				If !MtAvlNSer(aLocFi[nf,3],aLocFi[nf,4],aLocFi[nf,7])
					Return .F.
				EndIf

				If (!Empty(aLocFi[nf,1]) .Or. !Empty(aLocFi[nf,4])) .And.;
				QtdComp(SaldoSBF(aLocFi[nf,1],aLocFi[nf,2],aLocFi[nf,3],aLocFi[nf,4],aLocFi[nf,5],aLocFi[nf,6],.F.)) < QtdComp(aLocFi[nf,7])
					Help(" ",1,"SALDOLOCLZ",,STR0061+" "+aLocFi[nf,3],5,1)
					Return .F.
				EndIf
			EndIf
		Next nf
	EndIf

	If !Empty(cMENSA)
		MsgInfo(cMENSA,STR0014)//'ATENCAO'
		lRETOR := .F.
	EndIf

	If !NGCHKSOBHR(nTIPOI4,nCODIG4,nDATAI4,nHORAI4,nDATAF4,nHORAF4)
		lRETOR := .F.
	EndIf

	If lRETOR
		If nININC = 1
			If !MNTA415NI()
				Return .F.
			EndIf
		EndIf
	EndIf

	If lRETOR
		If lGRAVA <> NIL
			If ExistBlock("MNT41504")
				If !ExecbLock("MNT41504",.F.,.F.)
					Return .F.
				EndIf
			EndIf

			Processa({ |lEnd| MNTA415PI() },STR0033+STR0034)

			If ExistBlock("MNT41503")
				ExecbLock("MNT41503",.F.,.F.)
			EndIf
		EndIf
	EndIf

	PutFileInEof("STL")

Return lRETOR

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415ALM
Verifica se insumo no almoxarifado possui saldo positivo e testa se
existe insumo gravado com o local informado.
@type function

@author Elisangela Costa
@since 22/10/2002

@sample NG415ALM( 1 )

@param  nIte  , Númerico, Indica a linha que está em validação.
@return Lógico, Define se o almoxarifado possui saldo para o insumo.
/*/
//---------------------------------------------------------------------
Function NG415ALM( nITE )

	Local nITEM := IIf(nITE <> NIL,nITE,n)
	Local cLOCA := IIf(nITE <> NIL,aCols[nITE,nLOCAL4],M->TL_LOCAL)
	Local lRet  := .T.

	// Se tiver Integracao com estoque
	If cUSAINT3 == 	'S'

		// Verifica se existe o produto do SB2 com o local informado, se nao tiver cria o produto no al.
		NGPROALM( aCols[nItem,nCodiG4], cLOCA, nItem )

		/*
			Verifica se pode ter saldo negativo ( .T. Prossegue se .F. saldo negativo )
		*/
		If !lEstNega .And. !NGSALSB2( aCols[nItem,nCodiG4], cLOCA, aCols[nItem,nQuant4], .T., , aCols[nItem,nDataI4] )

			lRet := .F.

		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415OCO
Reporte de Ocorrencias

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 06/09/2001

@sample NG415OCO()

@return Nil
/*/
//---------------------------------------------------------------------
Function NG415OCO()

	Local aOldCols := aClone(aCols),aOldHeader:= aClone(aHeader),aNao:= {},nOpca:= 0,x,ng
	Local oDlg2, oMenu, oGetDados
	Local xr := 0
	Local iy
	//Variavies criadas pois serao utilizadas na validacao da ocorrencia quando for ocorrencia por familia (MNTA125)
	Private aCoVal := aClone(aCols), aHeVal := aClone(aHeader), n125Pos := n
	Private nIns := n

	If aCols[n][Len(aCols[n])]
		MsgInfo(STR0026,STR0014)
		Return .F.
	EndIf

	If !MNTA415TU(n)
		Return .F.
	EndIf

	cSEQSTN := AllTrim(Str(nIns,3))
	cSEQSTN := cSEQSTN + Space(3-Len(cSEQSTN))

	NGIFDBSEEK("STJ",aCols[n][nORDEM4],1,.F.)

	M->TN_ORDEM   := STJ->TJ_ORDEM
	M->TN_PLANO   := STJ->TJ_PLANO
	M->TN_TAREFA  := aCols[n][nTAREF4]

	cKey := M->TN_ORDEM+M->TN_PLANO+M->TN_TAREFA+cSEQSTN

	aAdd(aNao,"TN_ORDEM" )
	aAdd(aNao,"TN_PLANO" )
	aAdd(aNao,"TN_TAREFA")
	aAdd(aNao,"TN_NOMETAR")
	aAdd(aNao,"TN_SEQRELA")

	cGetWhile := "TN_ORDEM  == STJ->TJ_ORDEM  .And. "
	cGetWhile += "TN_PLANO  == STJ->TJ_PLANO  .And. "
	cGetWhile += "TN_TAREFA == M->TN_TAREFA   .And."
	cGetWhile += "TN_SEQRELA = cSEQSTN"

	aCols	 := {}
	aHeader := {}
	aHeader := CABECGETD("STN", aNao)

	//Inclui coluna de registro atraves de funcao generica
	ADHeadRec("STN",aHeader)

	aCols   := MAKEGETR((cTRBSTN), cKey,aHeader, cGetWhile,"TN")

	nOCORRE  := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_CODOCOR"})
	nCAUSA	 := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_CAUSA"})
	nSOLUCAO := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_SOLUCAO"})
	nDESCRIC := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_DESCRIC"})

	nDesOco  := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_NOMOCOR"})
	nDesCau  := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_NOMCAUS"})
	nDesSol  := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_NOMSOLU"})

	If Empty(aCols)
		aCols :=BLANKGETD(aHeader)
	EndIf

	For ng := 1 to Len(aCols)
		aCols[ng][nDesOco] := NGSEEK("ST8",aCols[ng][nOCORRE],1,"ST8->T8_NOME")
		aCols[ng][nDesCau] := NGSEEK("ST8",aCols[ng][nCAUSA],1,"ST8->T8_NOME")
		aCols[ng][nDesSol] := NGSEEK("ST8",aCols[ng][nSOLUCAO],1,"ST8->T8_NOME")
	Next ng

	xn := n

	Define MsDialog oDlg2 Title STR0047 From 12,0 To 28,100 Of oMainWnd

	oPainel01 := TPanel():New(00,200,,oDLG2,,,,,,100,28,.F.,.F.)
	oPainel01:Align := CONTROL_ALIGN_ALLCLIENT
	oGetDados := MSGetDados():New(15,1,107,397,3,"M415STNLIN()","M415STNTUD()","",.T., , , ,300,,,,,oPainel01)
	oGetDados:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	NGPOPUP(asMenu,@oMenu)
	oPainel01:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oPainel01)}
	Activate MsDialog oDlg2 On Init EnchoiceBar(oDlg2,{||nOpca:=1,IIf(!M415STNTUD(),nOpca:=1,oDlg2:End())},{||oDlg2:End()}) Centered

	If nOpca == 1
		For xr:=1 To Len(aCols)
			cSEQAUX := AllTrim(Str(xr,3))
			DbSelectArea(cTRBSTN)
			If !aCOLS[xr][LEN(aCOLS[xr])] .And. !Empty(aCols[xr][nOCORRE])
				If Dbseek(M->TN_ORDEM+M->TN_PLANO+M->TN_TAREFA+cSEQSTN+aCols[xr][nOCORRE]+aCols[xr][nCAUSA]+aCols[xr][nSOLUCAO])
					RecLock((cTRBSTN),.F.)
				Else
					RecLock((cTRBSTN),.T.)
				EndIf

				For iy := 1 To (cTRBSTN)->(FCount())

					If FieldName(iy) = "TN_ORDEM"
						(cTRBSTN)->TN_ORDEM   := M->TN_ORDEM
					ElseIf FieldName(iy) = "TN_PLANO"
						(cTRBSTN)->TN_PLANO   := M->TN_PLANO
					ElseIf FieldName(iy) = "TN_TAREFA"
						(cTRBSTN)->TN_TAREFA  := M->TN_TAREFA
					ElseIf FieldName(iy) = "TN_SEQRELA"
						(cTRBSTN)->TN_SEQRELA := cSEQSTN
					EndIf

					nPosx := aScan(aHeader, {|x| AllTrim(Upper(X[2])) == FieldName(iy) })
					If nPosx > 0
						x1 := aCols[xr][nPosx]
						y  := "(cTRBSTN)->"+FieldName(iy)
						&y := x1
						//Replace &y. with &x1.
					EndIf
				Next iy

				(cTRBSTN)->(MsUnLock())
			Else
				If Dbseek(M->TN_ORDEM+M->TN_PLANO+M->TN_TAREFA+cSEQSTN+aCols[xr][nOCORRE]+aCols[xr][nCAUSA]+aCols[xr][nSOLUCAO])
					RecLock((cTRBSTN),.F.)
					DbDelete()
					(cTRBSTN)->(MsUnLock())
				EndIf
			EndIf
		Next xr
	EndIf

	aCols   := aClone(aOldCols)
	aHeader := aClone(aOldHeader)
	n := xn

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415HOFIM
Atualiza hora fim quando digitado qtde de horas.

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 06/09/2001

@sample NG415HOFIM()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415HOFIM()

	If !NGVALHORA(M->TL_HOFIM,.T.)
		Return .F.
	EndIf

	If aCols[n][nTIPOI4] <> 'P'
		If !COMPDATA(aCols[n][nDATAI4],aCols[n][nHORAI4],aCols[n][nDATAF4],M->TL_HOFIM)
			Return .F.
		EndIf

		M->TL_TIPOREG := aCols[n][nTIPOI4]
		M->TL_USACALE := IIf( aCols[n][nUSACA4] <> "S", "N",aCols[n][nUSACA4] )
		M->TL_DTINICI := aCols[n][nDATAI4]
		M->TL_HOINICI := aCols[n][nHORAI4]
		M->TL_DTFIM   := aCols[n][nDATAF4]

		If !NGSTLHORFI()
			Return .F.
		EndIf

		NGCALQUANT()
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415DTINI
Valida a data inicio.

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 06/09/2001

@sample NG415DTINI()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415DTINI()

	If M->TL_DTINICI > dDataBase
		HELP(" ",1,"DATAINVAL")
		Return .F.
	EndIf
	If !NGDTINIC()
		Return .F.
	EndIf

	If !NGCHKMESFE(M->TL_DTINICI,Acols[n,nTIPOI4])
		Return .F.
	EndIf

	If aCols[n][nTIPOI4] = 'P'
		aCols[n][nDATAF4] := M->TL_DTINICI
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415HOINI
Valida e mostra a hora inicio.

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 16/04/2004

@sample NG415HOINI()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415HOINI()

	M->TL_SEQRELA := ""
	M->TL_SEQUENC := 0

	If !Empty(aCOLS[n,nDATAI4])
		M->TL_DTINICI := aCOLS[n,nDATAI4]
	EndIf

	If !NGVALHORA(M->TL_HOINICI,.T.)
		Return .F.
	EndIf

	If aCols[n][nTIPOI4] = 'P'
		aCols[n][nDATAF4] := aCols[n][nDATAI4]
		aCols[n][nHORAF4] := M->TL_HOINICI
	Else
		M->TL_USACALE := IIf(aCols[n][nUSACA4] <> "S","N",aCols[n][nUSACA4])
		If !NGSTLHORIN()
			Return .F.
		EndIf
	EndIf
	//chega se insumo esta na garantia
	MNT415CHKGAR(.F.)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415DTFIM
Valida a data fim.

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 06/09/2001

@sample NG415DTFIM()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415DTFIM()

	If M->TL_DTFIM < aCols[n][nDATAI4]
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415ETA
Retorno de Etapas Executadas.

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 17/01/2003

@sample NG415ETA()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415ETA()

	Local nY

	If ATail(aCols[n])
		MsgInfo(STR0026,STR0014)
		Return .F.
	EndIf

	If !MNTA415TU(n)
		Return .F.
	EndIf

	aSafeCols	:= aClone(aCols)
	aSafeHeader	:= aClone(aHeader)
	nUs415		:= nUsado
	nY			:= n

	NGIFDBSEEK("STJ",aCols[n][nORDEM4],1,.F.)
	NG400ETA()

	aCols	:= aClone(aSafeCols)
	aHeader	:= aClone(aSafeHeader)
	nUsado	:= nUs415
	n		:= nY

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA415CO
Consistencia dos contadores e o.s. preventiva.

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 10/07/2003

@sample MNTA415CO()

@return Lógico
/*/
//---------------------------------------------------------------------
Function MNTA415CO(cVNUOS,nVPOSC,nTIP)

	NGIFDBSEEK("STJ",cVNUOS,1,.F.)
	NGIFDBSEEK("ST9",stj->tj_codbem,1,.F.)

	If !Positivo(nVPOSC)
		Return .F.
	Else
		If !CHKPOSLIM(stj->tj_codbem,nVPOSC,nTIP)
			Return .F.
		EndIf
	EndIf

	If Val(stj->tj_plano) > 0
		NGIFDBSEEK("STF",STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,1,.F.)
		If nTIP == 1
			If lLECON1 .And. nVPOSC <= 0 .And. STF->TF_TIPACOM != "T"
				MsgInfo(STR0048+chr(13)+STR0049+chr(13)+STR0050+chr(13)+STR0051,STR0052)
				Return .F.
			EndIf
		Else
			If lLECON2 .And. nVPOSC <= 0 .And. STF->TF_TIPACOM == "S"
				MsgInfo(STR0048+chr(13)+STR0049+chr(13)+STR0050+chr(13)+STR0051,STR0052)
				Return .F.
			EndIf
		EndIf
	EndIf

	If Empty(nVPOSC)
		If nTIP = 1
			hHOCON1 := '  :  '
		Else
			hHOCON2 := '  :  '
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA415HO
Consistencia da hora.

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 10/07/2003

@sample MNTA415HO()

@return Lógico
/*/
//---------------------------------------------------------------------
Static Function MNTA415HO(hVHORA,nVCONTS)

	If !Empty(nVCONTS)
		If !NGVALHORA(hVHORA,.T.)
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415VLIM
Valida a quantidade limite do produto referente a pecas de
reposicao do bem.

@type function

@source MNTA415.prx

@author Elisangela Costa
@since 02/12/2003

@sample NG415VLIM()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415VLIM()

	If cVALPECRE == "S"
		If !Empty(aCols[n][nORDEM4]) .And. aCols[n][nTIPOI4] = "P"
			If !NGCHKLIMP(STJ->TJ_CODBEM,aCols[n][nCODIG4],M->TL_QUANTID)
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA415NI
Consistencia da quantidade de itens por ordem de servico.

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 15/09/2004

@sample MNTA415NI()

@return Lógico
/*/
//---------------------------------------------------------------------
Static Function MNTA415NI()

	Local nPOSA := 0,ml := 0,nQTDSTL := 0,aOSQTD := {}
	For ml := 1 To len(Acols)
		If !aCOLS[ml][LEN(aCOLS[ml])]
			nPOSA := aScan(aOSQTD,{|x| x[1] = Acols[ml,1]})
			If nPOSA = 0
				aAdd(aOSQTD,{Acols[ml,1],1})
			Else
				aOSQTD[nPOSA,2] += 1
			EndIf
		EndIf
	Next ml

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA415F12
Pesquisa via F12 para insumos tipo produto.

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 18/10/2004

@sample NGA415F12()

@return Lógico
/*/
//---------------------------------------------------------------------
Static Function NGA415F12()

	If !Empty(Acols[n,nORDEM4])
		If NGIFDBSEEK("ST9",Acols[n,nORDEM4],1,.F.)
			NGINSUF12("M->TL_CODIGO",stj->tj_codbem,aCOLS[n,nTIPOI4],.T.,,"TL_NOMCODI")
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415LOTCT
Valida o campo TL_LOTECTL.

@type function

@source MNTA415.prx

@author Elisangela Costa
@since 13/03/2006

@sample NG415LOTCT()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415LOTCT()

Return IIf(!Empty(M->TL_LOTECTL),NGVRASTSB8(aCols[n][nCODIG4],aCols[n][nLOCAL4],M->TL_LOTECTL,aCols[n][nNUMLO4]),.T.)

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415NUMLO
Valida o campo TL_NUMLOTE.

@type function

@source MNTA415.prx

@author Elisangela Costa
@since 13/03/2006

@sample NG415NUMLO()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415NUMLO()

Return IIf(!Empty(M->TL_NUMLOTE),NGVRASTSB8(aCols[n][nCODIG4],aCols[n][nLOCAL4],aCols[n][nLOTEC4],M->TL_NUMLOTE),.T.)

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415LOCAL
Valida o campo TL_LOCALIZ.

@type function

@source MNTA415.prx

@author Elisangela Costa
@since 13/03/2006

@sample NG415LOCAL()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415LOCAL()

Return IIf(!Empty(M->TL_LOCALIZ),ExistCpo('SBE',aCols[n][nLOCAL4]+M->TL_LOCALIZ),.T.)

//---------------------------------------------------------------------
/*/{Protheus.doc} A415STJBUS
Busca Ordens de servico com status de terceiros para um
determinado bem.

@type function

@source MNTA415.prx

@author Ricardo Dal Ponte
@since 03/05/2007

@sample A415STJBUS()

@return lSTJAchou - Lógico
/*/
//---------------------------------------------------------------------
Function A415STJBUS(cBEMSTJ)

	NGDBAREAORDE("STJ",2)
	lSTJAchou := .F.
	nRecnoSTJ := STJ->(Recno())
	Dbseek(xFILIAL("STJ")+"B"+cBEMSTJ)
	While !Eof() .And. STJ->TJ_FILIAL  = xFILIAL("STJ");
	.And. STJ->TJ_TIPOOS  = "B" .And. STJ->TJ_CODBEM = cBEMSTJ

		If STJ->TJ_SITUACA = "C"
			dbSkip()
			Loop
		EndIf

		If STJ->TJ_TERMINO = "N" .And. STJ->TJ_TERCEIR = "2"
			lSTJAchou := .T.
		EndIf

		DbSelectArea("STJ")
		dbSkip()
	End
	STJ->(DbGoTo(nRecnoSTJ))

Return lSTJAchou

//---------------------------------------------------------------------
/*/{Protheus.doc} M415STNTUD
Valida todos os itens da getdados de Ocorrencias.

@type function

@source MNTA415.prx

@author Elisangela Costa
@since 13/08/2007

@sample M415STNTUD()

@return lSTJAchou - Lógico
/*/
//---------------------------------------------------------------------
Function M415STNTUD()

	Local vx := 0

	For vx := 1 To Len(aCols)
		If !M415GETDO(vx,.T.)
			Return .F.
		EndIf
	Next vx

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} M415STNTUD
Valida a linha da getdados das ocorrencias.

@type function

@source MNTA415.prx

@author Elisangela Costa
@since 13/08/2007

@sample M415STNTUD()

@return Lógico
/*/
//---------------------------------------------------------------------
Function M415STNLIN()

	If !M415GETDO(n)
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} M145GETDO
Consiste a linha de getdados das ocorrencias.

@type function

@source MNTA415.prx

@author Elisangela Costa
@since 13/08/2007

@sample M145GETDO()

@Param nLin = Numero da linha na getdados

@return Lógico
/*/
//---------------------------------------------------------------------
Function M415GETDO(nLin,lFim)

	Local nQtd		:= 0
	Local nMax		:= Len(aCols[nLin])
	Local nOCORRE	:= aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_CODOCOR"})
	Local nCAUSA	:= aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_CAUSA"})
	Local nSOLUCAO	:= aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_SOLUCAO"})
	Local nDESCRIC	:= aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_DESCRIC"})
	Local cOCORRE	:= aCols[nLin][nOCORRE]
	Local cCAUSA	:= aCols[nLin][nCAUSA]
	Local cSOLUCAO	:= aCols[nLin][nSOLUCAO]
	Local cDESCRIC	:= aCols[nLin][nDESCRIC]

	Default lFim	:= .F.

	If nOCORRE == 0 .Or. nCAUSA == 0 .Or. nSOLUCAO == 0 .Or. nDESCRIC == 0
		Return .T.
	EndIf

	If Len(aCOLS) == 1
		If aCOLS[1][Len(aCOLS[1])]
			Return .T.
		EndIf
	EndIf

	If Empty(cOCORRE) .And. Empty(cCAUSA) .And. Empty(cSOLUCAO) .And. Empty(cDESCRIC) .AND. lFim
		Return .T.
	EndIf

	If Empty(cOCORRE) .And. IIf(lFim,(!Empty(cCAUSA) .Or. !Empty(cSOLUCAO) .Or. !Empty(cDESCRIC)),.T.)
		Help(" ",1,"NGATENCAO",,STR0100+Chr(13)+Chr(10)+" "+STR0101,3,1)  //"Informe o código da ocorrência,"#"campo obrigatório."
		Return .F.
	EndIf

	aEval(aCOLS, {|x| IIf( (x[nOCORRE] == cOCORRE .And.  x[nCAUSA] == cCAUSA  .And. x[nSOLUCAO] == cSOLUCAO;
	.And. !x[nMax]), nQtd++, Nil)})

	If nQtd > 1
		Help(" ",1,"NGATENCAO",, STR0074+Str(nLin,3)+".",3,1)  //"Já existe registro de ocorrência. Item "
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT415GAR
Chama funcao de controle de garantia.

@type function

@source MNTA415.prx

@author Evaldo Cevinscki Jr.
@since 29/02/2008

@sample MNT415GAR()

@return Lógico
/*/
//---------------------------------------------------------------------
Function MNT415GAR()

	Private cCodBem := aCOLS[n][nCOBEM4]
	Private cOrdem := aCOLS[n][nORDEM4]
	Private cPlano := STJ->TJ_PLANO

	M->TL_SEQRELA := " "
	M->TL_SEQUENC := 0
	cLocaliz := Space( TAMSX3("TPS_CODLOC")[1] )

	MNT415COMG()

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT415COMG
Inclusao de garantia para insumo diferente de produto chama
da a partir do campo garantia.

@type function

@source MNTA415.prx

@author Thiago Olis Machado
@since 17/07/2003

@sample MNT415COMG()

@return Lógico
/*/
//---------------------------------------------------------------------
Function MNT415COMG()

	Local nOPGA2 := 0, oDlg1, oMenu, cProduto := aCols[n][nCODIG4]
	Local oPanel
	Private cUni   := " ",cCont := " " , cNomLoc := Space(20),nQtde := 0, nQtdeC := 0

	lTemCG1 := IIf(NGSEEK("ST9",aCols[n,nCOBEM4],1,"T9_TEMCONT") <> "N",.T.,.F.)
	lTemCG2 := IIf(NGIFDBSEEK("TPE",aCols[n,nCOBEM4],1,.F.),.T.,.F.)

	aUni     := {" ",STR0078,STR0079,STR0080} //"Dia"###"Semana"###"Mes"
	aCont    := {" ",STR0038,STR0044} //"Contador 1"###"Contador 2"
	cLocaliz := Space(Len(TPS->TPS_CODLOC))
	cNomLoc  := Space(20)
	nLS      := aScan(aGar,{|x| x[7] = n })

	If M->TL_GARANTI = "S"
		If NGIFDBSEEK("TPY",aCols[n][nCOBEM4]+aCols[n][nCODIG4],1,.F.)
			nQtde  := TPY->TPY_QTDGAR
			nQtdeC := TPY->TPY_QTDCON
			If TPY->TPY_UNIGAR == "D"
				cUni := aUni[2]
			ElseIf TPY->TPY_UNIGAR == "S"
				cUni := aUni[3]
			ElseIf TPY->TPY_UNIGAR == "M"
				cUni := aUni[4]
			EndIf
			If TPY->TPY_CONGAR == "1"
				cCont  := aCont[2]
			ElseIf TPY->TPY_CONGAR == "2"
				cCont  := aCont[3]
			EndIf
		EndIf

		If nLS > 0
			cProduto  :=  aGar[nLS,1]
			cLocaliz := aGar[nLS,2]
			cNomLoc  := NGSEEK("TPS",cLocaliz,1,"TPS_NOME")
			nQtde    := aGar[nLS,3]
			nIU := IIf(!Empty(aGar[nLs,4]),IIf(aGar[nLS,4] = "D",2,IIf(aGar[nLS,4] = "S",3,4)),1)
			cUni     := aUni[nIU]
			nQtdeC   := aGar[nLS,6]
			cCont    := IIf(!Empty(aGar[nLS,5]),IIf(aGar[nLS,5] = 'Contador 1',aCont[2],aCont[3]),1)
		EndIf

		Define Msdialog oDlg1 From  000,000 To 290,550 Title STR0083 Pixel   //"Garantia"

		oPanel := TPanel():New( 0, 0,, oDlg1,,,,,,,, .F., .F. )
		oPanel:Align := CONTROL_ALIGN_ALLCLIENT

		@ .4,.5 To 2.5,34 LABEL STR0084 OF oPanel   //"Localização"

		@ 17,008 Say Oemtoansi(STR0085) Size 47,07 Of oPanel Pixel   //"Local"
		@ 17,040 MsGet cLocaliz Size 38,08 Of oPanel Pixel Picture '@!' F3 "TPS" Valid NGLOCGAR(cLocaliz)
		@ 17,100 MsGet oNomLoc Var cNomLoc Of oPanel Pixel Picture '@!' When .F. Size 160,08

		@ 2.9,.5 To 5,34 LABEL STR0086 OF oPanel  //"Garantia por Tempo"

		@ 52,007 Say Oemtoansi(STR0087) Size 47,07 Of oPanel Pixel   //"Qde"
		@ 51,040 MsGet nQtde Size 38,08 Of oPanel Pixel Valid positivo(nQtde) Picture '@E 999,999,999'

		@ 52.5,108 Say Oemtoansi(STR0088) Size 47,07 Of oPanel Pixel   //"Unidade"
		@ 49,133 Combobox cUni Items aUni Size 40,50 OF oPanel Pixel Valid NG400CON(cUni,cCont,1,nQtde)

		@ 5.4,.5 To 7.5,34 LABEL STR0089 OF oPanel   //"Garantia por Contador"

		@ 88,007 Say Oemtoansi(STR0087) Size 47,07 Of oPanel Pixel  //"Qde"
		@ 87,040 MsGet nQtdeC Size 38,08 Of oPanel Pixel Valid positivo(nQtdeC) Picture '@E 999,999,999' When lTemCG1 .Or. lTemCG2

		@ 88,099 say OemtoAnSi(STR0090) Size 47,07 Of oPanel Pixel      //"Tp Contador"
		@ 84.5,133 Combobox cCont Items aCont Size 40,50 Of oPanel Pixel Valid NG400CON(cUni,cCont,2,nQtdeC) When lTemCG1 .Or. lTemCG2

		NGPOPUP(asMenu,@oMenu)
		oDlg1:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg1)}
		Activate MsDialog oDLG1 On Init EnchoiceBar(oDLG1,{||nOPGA2 := 1,IIf(!MNT400GF(lTemCG1,lTemCG2),nOPGA2 := 0,oDLG1:End())},{||oDLG1:End()}) CENTERED

		If nOPGA2 == 1
			MNT415CHKGAR(.T.)
			If nLS = 0
				aAdd(aGar,Array(7))
				nLS := Len(aGar)
			End
			aGar[nLS,1] := cProduto
			aGar[nLS,2] := cLocaliz
			aGar[nLS,3] := nQtde
			aGar[nLS,4] := Substr(cUni,1,1)
			aGar[nLS,5] := cCont
			aGar[nLS,6] := nQtdeC
			aGar[nLS,7] := n
		Else
			If nLS = 0
				aCols[n,nGARAN4] := "N"
				M->TL_GARANTI    := "N"
			EndIf
		EndIf
	Else
		If nLS > 0
			Adel(aGar,nLS)
			ASize(aGar,Len(aGar)-1)
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT415GRVG
Grava a garantia na tabela TPZ.

@type function

@source MNTA415.prx

@author Vitor Emanuel Batista
@since 30/10/2008

@sample MNT415GRVG()

@return Lógico
/*/
//---------------------------------------------------------------------
Function MNT415GRVG(cOrdem,cCodBem,cProduto,cLocaliz,nQtde,cUni,cCont,nQtdeC,cTpIns)

	Local cSEQSTL := ''
	Local cPlano  := STJ->TJ_PLANO
	Local lIndTPZ := NgVerify("TPZ")

	NGIFDBSEEK("STJ",cOrdem,1,.F.)
	If NGIFDBSEEK("STL",cOrdem+cPlano+cTpIns+cProduto,4,.F.)
		While !Eof() .And. AllTrim(STL->TL_FILIAL+STL->TL_ORDEM+STL->TL_PLANO+"P"+STL->TL_CODIGO) == AllTrim(xFilial("STL")+cOrdem+cPlano+"P"+cProduto)
			cSEQSTL := STL->TL_SEQRELA
			dbSkip()
		End
	EndIf

	If !NGIFDBSEEK("TPZ",cCodBem+cTpIns+cProduto+cLocaliz+cOrdem+cPlano+cSEQSTL,1,.F.)
		RecLock("TPZ",.T.)
		TPZ->TPZ_FILIAL := xFilial("TPZ")
		TPZ->TPZ_CODBEM := cCodBem
		TPZ->TPZ_TIPORE := cTpIns
		TPZ->TPZ_CODIGO := cProduto
		TPZ->TPZ_LOCGAR := cLocaliz
		TPZ->TPZ_ORDEM  := cOrdem
		TPZ->TPZ_PLANO  := cPlano
		If lIndTPZ
			TPZ->TPZ_SEQREL := cSEQSTL
		EndIf
		TPZ->TPZ_SEQUEN := STL->TL_SEQUENC
		TPZ->TPZ_QTDGAR := nQtde
		TPZ->TPZ_UNIGAR := cUni
		If cCont = STR0038 //"Contador 1"
			TPZ->TPZ_CONGAR := "1"
		ElseIf cCont = STR0044 //"Contador 2"
			TPZ->TPZ_CONGAR := "2"
		Else
			TPZ->TPZ_CONGAR := " "
		EndIf
		If NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)
			TPZ->TPZ_QTDCON := nQtdeC
		EndIf
		TPZ->TPZ_DTGARA := aCols[n][nDATAI4]
		MsUnlock("TPZ")
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT415CHKGAR
Checa se o insumo informado esta em garantia.

@type function

@source MNTA415.prx

@author Evaldo Cevinscki Jr.
@since 20/03/2008

@sample MNT415CHKGAR()

@return Lógico
/*/
//---------------------------------------------------------------------
Function MNT415CHKGAR(lChkLoc)

	Local lGarDt  := .F.,lGarCon := .F.
	Local cLoc    := Space(1)
	Local dDtVal  := CtoD("  /  /  ")
	Local dIniGar := CtoD("  /  /  ")
	Local dFimGar := CtoD("  /  /  ")
	Local cOSGar  := Space(1)
	Local nIniGar := 0
	Local nFimGar := 0
	Local nConAtu := 0, nPosCon := 0

	cFilTPZ := IIf(NgSX2Modo("TPZ")=='C','  ',xFilial("TPZ"))
	cFilSTJ := IIf(NgSX2Modo("STJ")=='C','  ',xFilial("STJ"))
	nConAtu := STJ->TJ_POSCONT
	nConAt2 := STJ->TJ_POSCON2

	DbSelectArea("TPZ")
	DbSetOrder(1)
	DbSeek(cFilTPZ+aCols[n][nCOBEM4]+aCols[n][nTIPOI4]+aCols[n][nCODIG4])
	While !Eof() .And. TPZ->TPZ_FILIAL == xFilial("TPZ") .And. TPZ->TPZ_CODBEM == aCols[n][nCOBEM4] .And. ;
	TPZ->TPZ_TIPORE == aCols[n][nTIPOI4] .And. TPZ->TPZ_CODIGO == aCols[n][nCODIG4]
		If TPZ->TPZ_UNIGAR = "D"
			dDtVal := TPZ->TPZ_DTGARA + TPZ->TPZ_QTDGAR
		ElseIf TPZ->TPZ_UNIGAR = "S"
			dDtVal := TPZ->TPZ_DTGARA + (TPZ->TPZ_QTDGAR * 7)
		ElseIf TPZ->TPZ_UNIGAR = "M"
			dDtVal := TPZ->TPZ_DTGARA + (TPZ->TPZ_QTDGAR * 30)
		EndIf

		If dDtVal > aCols[n][nDATAI4]
			lGarDt := .T.
			cLoc := TPZ->TPZ_LOCGAR
			dIniGar := TPZ->TPZ_DTGARA
			dFimGar := dDtVal
			cOSGar := TPZ->TPZ_ORDEM
		EndIf

		If lGarDt
			lMens := IIf( lChkLoc, (cLoc == cLocaliz), .T.)

			If lMens
				MsgAlert(STR0091+CHR(13); //"Insumo substituido no prazo de Garantia"
				+ STR0092 + AllTrim( Str( Day( dIniGar ) ) ) + "/" + AllTrim( Str( Month( dIniGar ) ) ) +;
				"/" + AllTrim( Str( Year( dIniGar ) ) ) + STR0093 + cOSGar + CHR(13); //"Data de Inicio de uso :"###"    O.S.:"
				+ STR0094 + AllTrim( Str( Day( dFimGar ) ) + "/" + AllTrim( Str( Month( dFimGar ) ) ) +;
				"/" + AllTrim( Str( Year( dFimGar ) ) ) ) + CHR(13);  //"Garantia Ate..............:"
				+ IIf( Empty(cLoc), " ", STR0095 + cLoc ))  //"Na Localização: "
			EndIf

			lGarDt := .F.
		EndIf
		If NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)
			If !Empty(TPZ->TPZ_QTDCON)
				If TPZ->TPZ_CONGAR == '1'
					DbSelectArea("STJ")
					DbSetOrder(1)
					If DbSeek(cFilSTJ+TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO)
						If nConAtu < (STJ->TJ_POSCONT + TPZ->TPZ_QTDCON)
							lGarCon := .T.
							cLoc    := TPZ->TPZ_LOCGAR
							nIniGar := STJ->TJ_POSCONT
							nFimGar := STJ->TJ_POSCONT + TPZ->TPZ_QTDCON
							cOSGar  := TPZ->TPZ_ORDEM
							nPosCon := nConAtu
						EndIf
					EndIf
				ElseIf TPZ->TPZ_CONGAR == '2'
					DbSelectArea("STJ")
					DbSetOrder(1)
					If DbSeek(cFilSTJ+TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO)
						If nConAt2 < (STJ->TJ_POSCON2 + TPZ->TPZ_QTDCON)
							lGarCon := .T.
							cLoc    := TPZ->TPZ_LOCGAR
							nIniGar := STJ->TJ_POSCON2
							nFimGar := STJ->TJ_POSCON2 + TPZ->TPZ_QTDCON
							cOSGar  := TPZ->TPZ_ORDEM
							nPosCon := nConAt2
						EndIf
					EndIf
				EndIf
				If lGarCon

					lMens := IIf( lChkLoc, (cLoc == cLocaliz), .T. )

					If lMens
						MsgAlert(STR0091+CHR(13)+CHR(13);  //"Insumo substituido no prazo de Garantia"
						+STR0096+AllTrim(Str(nIniGar))+CHR(13); //"Contador no inicio do uso    : "
						+STR0097+cOSGar+CHR(13);  //"O.S.                                     : "
						+STR0098+AllTrim(Str(nPosCon))+CHR(13);   //"Contador atual                     : "
						+STR0099+AllTrim(Str(nFimGar))+CHR(13); //"Garantia Ate                         : "
						+ IIf(Empty(cLoc), " ", STR0095 + cLoc))  //"Na Localização: "

						lGarCon := .F.
					EndIf
				EndIf
			EndIf
		EndIf
		DbSelectArea("TPZ")
		DbSkip()
	EndDo

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415QUANT
Validacao da quantidade quando tipo insumo <> Produto "P".

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 22/10/2008

@sample NG415QUANT()

@return lRetQ - Lógico
/*/
//---------------------------------------------------------------------
Function NG415QUANT()

	Local lRetQ := .T.

	If aCols[n,nTIPOI4] <> "P"
		M->TL_TIPOREG := aCols[n,nTIPOI4]
		M->TL_UNIDADE := aCols[n,nUNIDA4]
		M->TL_USACALE := aCols[n,nUSACA4]
		lRetQ := NGQUANTCHK(M->TL_TIPOREG,M->TL_UNIDADE,M->TL_QUANTID,M->TL_USACALE)
	EndIf

Return lRetQ

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA415TP
Validacao adicional na informacao do tipo do insumo.

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 23/01/2009

@sample NG415QUANT()

@return lRet - Lógico
/*/
//---------------------------------------------------------------------
Function MNTA415TP()

	Local lRet := .T.

	If ExistBlock("MNT41505")
		lRet := ExecbLock("MNT41505",.F.,.F.)
	EndIf
	If nPERMI4 > 0 .And. M->TL_TIPOREG <> "M"
		aCOLS[n,nPERMI4] := 0.00
	EndIf

Return lRet

//----------------------------------------------------------------------------
/*/{Protheus.doc} NGCHKSOBHR
Validacao adicional na informacao do tipo do insumo.

@return lRet  , Lógico  , Valor que verifica a integridade

@param nPosTP , Numerico, Posicao no aCols do Tipo do Insumo
@param nPosCod, Numerico, Posicao no aCols do Codigo do Insumo
@param nPosDtI, Numerico, Posicao no aCols da Data Inicio
@param nPosHrI, Numerico, Posicao no aCols da Hora Inicio
@param nPosDtF, Numerico, Posicao no aCols da Data Fim
@param nPosHrF, Numerico, Posicao no aCols da Hora Fim
@param nPosAt , Numerico, Valor da linha atual do getdados. (oGet:nAt)

@sample
NGCHKSOBHR()

@author Evaldo Cevinscki Jr.
@since 09/02/2009
@version 1.0
/*/
//----------------------------------------------------------------------------
Function NGCHKSOBHR(nPosTP,nPosCod,nPosDtI,nPosHrI,nPosDtF,nPosHrF,nPosAt)

	Local nY     := 0
	Local cTpIns := ""

	Default nPosAt := n

	cTpIns := aCols[nPosAt][nPosTP]

	If !aCols[nPosAt][LEN(aCOLS[nPosAt])] //Se linha nao for deletada
		If cTpIns <> "P" .And. cTpIns <> "T"

			//-------------------------------------------------------
			// Ponto de entrada para realizar validações específicas
			// de sobreposição de insumo no aCols
			//-------------------------------------------------------
			If ExistBlock("MNT41507")
				Return ExecBlock("MNT41507",.F.,.F.,{nTIPOI4,nCODIG4,nDATAI4,nHORAI4,nDATAF4,nHORAF4})
			Else
				For nY := 1 to Len(aCols)
					If nPosAt <> nY .and. !aCols[nY][LEN(aCOLS[nY])]
						If aCols[nPosAt][nPosCod] == aCols[nY][nPosCod] .And. aCols[nY][nPosTP] == cTpIns
							If ((DtoS(aCols[nPosAt][nPosDtI])+aCols[nPosAt][nPosHrI] > DtoS(aCols[nY][nPosDtI])+aCols[nY][nPosHrI] .And.;
							DtoS(aCols[nPosAt][nPosDtI])+aCols[nPosAt][nPosHrI] < DtoS(aCols[nY][nPosDtF])+aCols[nY][nPosHrF]) .Or.;
							(DtoS(aCols[nPosAt][nPosDtF])+aCols[nPosAt][nPosHrF] > DtoS(aCols[nY][nPosDtI])+aCols[nY][nPosHrI] .And.;
							DtoS(aCols[nPosAt][nPosDtF])+aCols[nPosAt][nPosHrF] <  DtoS(aCols[nY][nPosDtF])+aCols[nY][nPosHrF])) .Or.;
							((DtoS(aCols[nY][nPosDtI])+aCols[nY][nPosHrI] > DtoS(aCols[nPosAt][nPosDtI])+aCols[nPosAt][nPosHrI] .And.;
							DtoS(aCols[nY][nPosDtI])+aCols[nY][nPosHrI] < DtoS(aCols[nPosAt][nPosDtF])+aCols[nPosAt][nPosHrF]) .Or.;
							(DtoS(aCols[nY][nPosDtF])+aCols[nY][nPosHrF] > DtoS(aCols[nPosAt][nPosDtI])+aCols[nPosAt][nPosHrI] .And.;
							DtoS(aCols[nY][nPosDtF])+aCols[nY][nPosHrF] < DtoS(aCols[nPosAt][nPosDtF])+aCols[nPosAt][nPosHrF] )) .Or. ;
							((DtoS(aCols[nPosAt][nPosDtI])+aCols[nPosAt][nPosHrI] == DtoS(aCols[nY][nPosDtI])+aCols[nY][nPosHrI] .And.;
							DtoS(aCols[nPosAt][nPosDtF])+aCols[nPosAt][nPosHrF] == DtoS(aCols[nY][nPosDtF])+aCols[nY][nPosHrF]))
								MsgInfo(STR0102+aCols[nPosAt][nPosCod]+chr(13)+; //"Existe sobreposição de horas lançadas para o Insumo: "
								STR0103+AllTrim(Str(nY))+Chr(13)+; //" Lançamento existente na linha: "
								STR0104+Substr(DtoS(aCols[nY][nPosDtI]),7,2)+"/"+Substr(DtoS(aCols[nY][nPosDtI]),5,2)+"/"+Substr(DtoS(aCols[nY][nPosDtI]),1,4)+Chr(13)+; //" Data Inicio: "
								STR0105+aCols[nY][nPosHrI]+Chr(13)+; //" Hora Inicio: "
								STR0106+Substr(DtoS(aCols[nY][nPosDtF]),7,2)+"/"+Substr(DtoS(aCols[nY][nPosDtF]),5,2)+"/"+Substr(DtoS(aCols[nY][nPosDtF]),1,4)+Chr(13)+; //" Data Fim: "
								STR0107+aCols[nY][nPosHrF]+Chr(13),STR0014)//'ATENCAO'  //" Hora Fim: "
								Return .F.
							EndIf
						EndIf
					EndIf
				Next nY
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415TARE
Atribuicao de valor para percentual de Mao-de-Oba.

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 12/04/2010

@sample NG415TARE()

@return Lógico
/*/
//---------------------------------------------------------------------
Function NG415TARE()

	If nPERMI4 > 0 .And. M->TL_TAREFA <> aCOLS[n,nTAREF4]
		aCOLS[n,nPERMI4] := 0.00
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGSALDOES
Verifica o saldo do produto em estoque.

@type function

@source MNTA415.prx

@author Denis
@since 04/09/2001

@sample NGSALDOES()

@Param cVCOD   - Codigo do Produto
@Param cALMOX  - Codigo do Almoxifado
@Param nQUANT  - Quantidade Solicitada
@Param lMENSA  - Indicador de saida da mensagem (.T.,.F.)
@Param nLineOS - Linha da Matriz aCols
@Param nTipoVal- 1 - Saldo SB2
- 2 - Saldo Sub-Lote
- 3 - Saldo Lote
- 4 - Saldo Enderecamento
@Param cLOTECTL- Codigo do Lote
@Param cNUMLOTE- Codigo do SubLote
@Param cLOCALIZ- Codigo do Endereco
@Param cNUMSERI- Codigo do Numero de Serie

@return lPROBLEM - Lógico
/*/
//---------------------------------------------------------------------
Static Function NGSALDOES(cVCOD,cALMOX,nQUANT,lMENSA,nLineOS,nTipoVal,cLOTECTL,cNUMLOTE,cLOCALIZ,cNUMSERI,dDTINICI)

	Local cALIASOLD := ALIAS()
	Local nOLDKEY   := INDEXORD()
	Local cALMOXAF  := IIf(Empty(cALMOX),"01",cALMOX)
	Local lPROBLEM  := .T.
	Local lSAIDAME  := IIf(lMENSA = Nil,.T.,lMENSA)
	Local nXX, nYY
	Local cChvPrAlm := ""

	Private nP435Tip := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Private nP435Cod := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Private nP435Loc := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Private nP435Qtd := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Private nP435Sub := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	Private nP435Lot := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	Private nP435End := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	Private nP435NuS := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	Private nForXX,nForYY
	Private bChv1Alm := "''"
	Private bChv2Alm := "''"
	Private bChv3Alm := "''"

	If nP435Cod == 0 .or. nP435Tip == 0 .or. nP435Qtd == 0
		Return .T.
	EndIf


	If nTipoVal == 1 //Saldo SB2
		cChvPrAlm := cVCOD+cALMOXAF
		bChv1Alm  := "aCols[nForXX,nP435Cod]+aCols[nForXX,nP435Loc]"
		bChv2Alm  := "aCols[nForXX,nP435Cod]+aCols[nForXX,nP435Loc]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]"
	ElseIf nTipoVal == 2 //Saldo SubLote
		cChvPrAlm := cVCOD+cALMOXAF+cLOTECTL+cNUMLOTE
		bChv1Alm  := "aCols[nForXX,nP435Cod]+aCols[nForXX,nP435Loc]+aCols[nForXX,nP435Lot]"+;
		"+aCols[nForXX,nP435Sub]"
		bChv2Alm  := "aCols[nForXX,nP435Cod]+aCols[nForXX,nP435Loc]+aCols[nForXX,nP435Lot]"+;
		"+aCols[nForXX,nP435Sub]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]+aCols[nForYY,nP435Lot]+aCols[nForYY,nP435Sub]"
	ElseIf nTipoVal == 3 //Saldo Lote
		cChvPrAlm := cVCOD+cALMOXAF+cLOTECTL
		bChv1Alm  := "aCols[nForXX,nP435Cod]+aCols[nForXX,nP435Loc]+aCols[nForXX,nP435Lot]"
		bChv2Alm  := "aCols[nForXX,nP435Cod]+aCols[nForXX,nP435Loc]+aCols[nForXX,nP435Lot]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]+aCols[nForYY,nP435Lot]"
	ElseIf nTipoVal == 4 //Saldo Enderecamento
		cChvPrAlm := cVCOD+cALMOXAF+cLOCALIZ+cNUMSERI+cLOTECTL+cNUMLOTE
		bChv1Alm  := "aCols[nForXX,nP435Cod]+aCols[nForXX,nP435Loc]+aCols[nForXX,nP435End]"+;
		"+aCols[nForXX,nP435NuS]+aCols[nForXX,nP435Lot]+aCols[nForXX,nP435Sub]"
		bChv2Alm  := "aCols[nForXX,nP435Cod]+aCols[nForXX,nP435Loc]+aCols[nForXX,nP435End]"+;
		"+aCols[nForXX,nP435NuS]+aCols[nForXX,nP435Lot]+aCols[nForXX,nP435Sub]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]+aCols[nForYY,nP435End]+aCols[nForYY,nP435NuS]+"+;
		"aCols[nForYY,nP435Lot]+aCols[nForYY,nP435Sub]"
	EndIf

	//Analisa se existe retiradas do estoque na tela e desconta do saldo atual.
	nDiffOS := 0
	For nXX := 1 To Len(aCols)
		nForXX := nXX
		If nLineOS != nXX
			If ATail(aCols[nXX])
				Loop //Deletado
			EndIf

			If aCols[nXX,nP435Tip] == "P"
				If &(bChv2Alm) == cChvPrAlm
					nDiffOS -= aCols[nXX,nP435Qtd]
				EndIf
			EndIf

		EndIf
	Next nXX

	If nTipoVal == 1 //Saldo SB2
		lPROBLEM := NGSALSB2(cVCOD,cALMOX,nQUANT,,,dDTINICI)

	ElseIf nTipoVal == 2 //Saldo SubLote

		DbSelectArea("SB8")
		dbSetOrder(2)
		If dbSeek(xFilial("SB8")+cNUMLOTE+cLOTECTL+cVCOD+cALMOX)
			nSaldoLote := SB8Saldo(.F.,!Empty(cLOTECTL+cNUMLOTE),NIL,NIL,NIL,NIL,NIL,dDTINICI)
			nSaldoLote := nSaldoLote + nDiffOS
			If QtdComp(nSaldoLote) < QtdComp(nQUANT)

				cHelp:= STR0061 + AllTrim(cVCOD) + Chr(13) + STR0119 + cALMOX + Chr(13) + STR0120 +; //"Produto "###"Local "###"Saldo Disponível "
				AllTrim( Transform( nSaldoLote, PesqPictQt("B8_SALDO", 14) ) ) + Chr(13) + STR0121 + AllTrim(cLOTECTL) +; //"Lote "
				Chr(13) + STR0122 + AllTrim(cNUMLOTE) //"Sub-lote "

				Help(" ",1,"A240LOTENE",,cHelp,4,1)
				lPROBLEM := .F.
			EndIf
		Else
			Help(" ",1,"NGATENCAO",,STR0065+Chr(13)+Chr(10)+; //"Numero do sub-lote não corresponde ao produto que foi "
			STR0066,3,1) //" informado. Digite um sub-lote correspondente."
			lPROBLEM := .F.
		EndIf

	ElseIf nTipoVal == 3 //Saldo Lote

		DbSelectArea("SB8")
		dbSetOrder(03)
		If dbSeek(xFilial("SB8")+cVCOD+cALMOX+cLOTECTL)
			nSaldoLote := SaldoLote(cVCOD,cALMOX,cLOTECTL,NIL,.F.,!Empty(cLOTECTL+cNUMLOTE),NIL,dDTINICI)
			nSaldoLote := nSaldoLote + nDiffOS
			If QtdComp(nSaldoLote) < QtdComp(nQUANT)
				cHelp := STR0061 + AllTrim(cVCOD) + Chr(13) + STR0119 + cALMOX + Chr(13) + STR0120 +;//"Produto "###"Local "###"Saldo Disponível "
				AllTrim( Transform(nSaldoLote, PesqPictQt("B8_SALDO", 14))) + Chr(13) + STR0121 + AllTrim(cLOTECTL) //"Lote "

				Help(" ",1,"A240LOTENE",,cHelp,4,1)
				lPROBLEM := .F.
			EndIf
		Else
			Help(" ",1,"NGATENCAO",,STR0067+Chr(13)+Chr(10)+; //"Numero do lote não corresponde ao produto que foi "
			STR0068,3,1) //" informado. Digite um lote correspondente."
			lPROBLEM := .F.
		EndIf

	ElseIf nTipoVal == 4 //Saldo Enderecamento
		nSaldoLote := SaldoSBF(cALMOX,cLOCALIZ,cVCOD,cNUMSERI,cLOTECTL,cNUMLOTE,.F.)
		nSaldoLote := nSaldoLote + nDiffOS
		If QtdComp(nSaldoLote) < QtdComp(nQUANT)
			Help(" ",1,"SALDOLOCLZ")
			lPROBLEM := .F.
		EndIf
	EndIf

	DbSelectArea(cALIASOLD)
	dbSetOrder(nOLDKEY)

Return lPROBLEM

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT415HF
Validacao da hora fim da parada.

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 29/10/2010

@sample MNT415HF()

@return Lógico
/*/
//---------------------------------------------------------------------
Function  MNT415HF()

	If !(AllTrim(hHOPRFIM) = ":" .And. (AllTrim(hHOPRINI) = ":"  .Or. Empty(hHOPRINI)) .And. Empty(dDTPRINI) .And. Empty(dDTPRFIM))
		If !NGVALHORA(hHOPRFIM,.T.)
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT415HI
Validacao da hora fim da parada.

@type function

@source MNTA415.prx

@author Inácio Luiz Kolling
@since 29/10/2010

@sample MNT415HI()

@return Lógico
/*/
//---------------------------------------------------------------------
Function  MNT415HI()

	If !(Empty(hHOPRINI) .Or. AllTrim(hHOPRINI) = ":" .And. Empty(dDTPRINI))
		If !NGVALHORA(hHOPRINI,.T.)
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT415DESC
Retorna a Descrição do Insumo.

@type function

@source MNTA415.prx

@author Rodrigo Soledade
@since 08/08/2011

@sample MNT415DESC()

@return Lógico
/*/
//---------------------------------------------------------------------
Function MNT415DESC(cTIPOREG,cCODIGO)

	Local nPosNCod := aScan( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_NOMCODI"})
	Local cLoja    := IIf( cTIPOREG == 'T' .AND. Alltrim( cCODIGO ) ==  Alltrim( SA2->A2_COD ), SA2->A2_LOJA, '')

	If nPosNCod > 0
		aCols[n,nPosNCod] := NOMINSBRW( cTIPOREG, cCODIGO, cLoja )//M->TL_TIPOREG,M->TL_CODIGO
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT415LIMP
Limpa campos.

@type function

@source MNTA415.prx

@author Rodrigo Soledade
@since 08/08/2011

@sample MNT415LIMP()

@return Lógico
/*/
//---------------------------------------------------------------------
Function MNT415LIMP()

	Local nPOS, nPOS1

	nPOS	:= aScan( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_NOMCODI"})
	nPOS1	:= aScan( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TIPOREG"})

	If M->TL_TIPOREG <> aCols[n,nPOS1] .And. nPOS > 0
		aCols[n,nPOS] := Space(40)
	EndIf

Return .T.

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} fF5KEY()
Mostra o saldo da localização do produto

@author Tainã Alberto Cardoso
@since 20/02/2015


@return Logico
/*/
//---------------------------------------------------------------------------------------
Static Function fF5KEY()

	Local cVar			:= ReadVar()
	Local nTLLOCALIZ	:= aScan(aHEADER,{|x| Trim( Upper(x[2]) ) == "TL_LOCALIZ" })
	Local nTLNUMSERI	:= aScan(aHEADER,{|x| Trim( Upper(x[2]) ) == "TL_NUMSERI" })

	ShowF4MNT()

	If cVar == "M->TL_LOCALIZ" .Or. cVar == "M->TL_NUMSERI"
		M->TL_LOCALIZ := IIf(nTLLOCALIZ > 0, aCols[n][nTLLOCALIZ], Space(TAMSX3("TL_LOCALIZ")[1]))
		M->TL_NUMSERI := IIf(nTLNUMSERI > 0, aCols[n][nTLNUMSERI], Space(TAMSX3("TL_NUMSERI")[1]))
	EndIf

Return .T.

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT415MOTA
Mostra as O.S.s que possuem motivo atraso sem Data Fim/Hora Fim não informados.

@author Éwerton Cercal
@since 05/06/2015
@version P11
@return Nil Nulo
/*/
//---------------------------------------------------------------------------------------
Static Function MNT415MOTA(aArq)

	Local cTexto := ""
	Local oFont
	Local cMask  := STR0131 //"Arquivos Texto (*.TXT) |*.txt|"
	Local oDlgMot
	Local nI := 0

	Private aLog := Array(1)

	cTexto := STR0130 //"A(s) seguinte(s) O.S.(s) não pode(m) ser finalizada(s), pois existem um ou mais motivos de atrasos sem Data Fim/Hora Fim informados:"
	cTexto += CRLF + CRLF

	For nI := 1 To Len(aArq)

		cTexto += aArq[nI] + CRLF

	Next nI

	If !Empty(cTexto)
		aLog[1] := {cTexto}
		Define Font oFont Name "Courier New" Size 5,0
		Define MsDialog oDlgMot Title STR0129 From 3,0 To 340,417 Color CLR_BLACK, CLR_WHITE Pixel //"O.S.(s) com Inconsistência(s)"
		@ 5,5 Get oMemo  Var cTexto Memo Size 200,145 Of oDlgMot Pixel
		oMemo:bRClicked := {|| AllwaysTrue()}
		oMemo:oFont := oFont
		oMemo:lReadOnly := .T.

		Define SButton From 153,175 Type 1 Action oDlgMot:End() Enable Of oDlgMot Pixel
		Define SButton From 153,145 Type 13 Action (cFile := cGetFile(cMask, OemToAnsi(STR0132)), IIf(cFile == "", .T., MemoWrite(cFile, cTexto)),) Enable Of oDlgMot Pixel	//"Salvar Como..."
		Activate MsDialog oDlgMot Centered
	EndIf

	cTexto := ""

Return

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} fCabecGet
Monta o cabeçalho (aHEADER) de uma GetDados.

@author Rodrigo Luan Backes
@since 02/07/2015
@version P11
@return aRET
/*/
//---------------------------------------------------------------------------------------
Static Function fCabecGet(cALIAS,aNoFields)

	Local aRet		 := {}
	Local aNgHeader  := {}
	Local cCampo     := ""
	Local cArquivo   := ""
	Local cValid     := ""
	Local cF3        := ""
	Local cWhen      := ""
	Local nInd       := 0
	Local nTot       := 0

	aNgHeader := NGHeader(cAlias, aNoFields, (cAlias != "TPL"))

	nTot := Len(aNgHeader)
	For nInd := 1 To nTot

		cCampo  := aNgHeader[nInd,2]
		If AllTrim(cCampo) == "TPL_ORDEM"
			cValid := "NG415CHKOS()"
			cF3    := "STJ"
		Else
			cValid := aNgHeader[nInd,6]
			cF3    := aNgHeader[nInd,9]
		EndIf

		cArquivo := Posicione("SX3",2,cCampo,"X3_ARQUIVO")
		cWhen    := Posicione("SX3",2,cCampo,"X3_WHEN")

		aAdd(aRet,{aNgHeader[nInd,1] ,; //01 - Titulo
				   cCampo             ,; //02 - Campo
				   aNgHeader[nInd,3] ,; //03 - Picture
				   aNgHeader[nInd,4] ,; //04 - Tamanho
				   aNgHeader[nInd,5] ,; //05 - Decimal
				   cValid             ,; //06 - Valid
				   aNgHeader[nInd,7] ,; //07 - Usado
				   aNgHeader[nInd,8] ,; //08 - Tipo
				   cArquivo           ,; //09 - Arquivo
				   aNgHeader[nInd,10],; //10 - Contexto
				   cF3                ,; //11 - F3
				   cWhen})               //12 - When

	Next nInd

Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NG415VLTR
Valida tipo de registro.
Caso o tipo de insumo seja produto, irá replicar a data e hora inicio para
a data fim e hora fim.

@author Maicon André Pinheiro.
@since	14/01/2016
@return True
/*/
//---------------------------------------------------------------------
Function NG415VLTR(cReg)

	Local nLin    := 1
	Local nTIPOREG := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nDATAINI := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nHORAINI := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TL_HOINICI"})
	Local nDATAFIM := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TL_DTFIM"})
	Local nHORAFIM := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TL_HOFIM"})

	If Len(aCols) == 1
		If ATail( aCols[1] )
			Return .T.
		Endif
	Else
		nLin := n
	Endif

	If cReg == 'TL_TIPOREG'

		If M->TL_TIPOREG == 'P'
			aCOLS[nLIN][nDATAFIM] := aCOLS[nLIN][nDATAINI]
			aCOLS[nLIN][nHORAFIM] := aCOLS[nLIN][nHORAINI]
		Else
			aCOLS[nLIN][nDATAFIM] := cToD("  /  /  ")
			aCOLS[nLIN][nHORAFIM] := "  :  "
		EndIf
	EndIF

	If aCOLS[nLIN][nTIPOREG] == 'P'

		If cReg == 'TL_DTINICI'

			aCOLS[nLIN][nDATAFIM] := M->TL_DTINICI
			aCOLS[nLIN][nHORAFIM] := aCOLS[nLIN][nHORAINI]

		ElseIf cReg == 'TL_HOINICI'

			aCOLS[nLIN][nDATAFIM] := aCOLS[nLIN][nDATAINI]
			aCOLS[nLIN][nHORAFIM] := M->TL_HOINICI

		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA415CCB
Carrega o valor do contador do bem se o campo estiver bloqueado

@param cCobBem: Código do bem
@param dData: Data
@param cHora: Hora
@author Wexlei Silveira
@since 27/09/2016
@version MP11
@return True
/*/
//---------------------------------------------------------------------
Static Function MNTA415CCB(cCobBem, dData, cHora)

	If FindFunction("NGBlCont") .And. !NGBlCont( cCobBem )
		nPOSCO1 := NGTpCont(cCobBem, dData, cHora)
	EndIf

Return .T.
