#include "tlpp-core.th"
#include "tlpp-rest.th"
#include 'mntorder.ch'

//---------------------------------------------------------------------
/*/{Protheus.doc} MntOrderGet
Método Get para Leitura de Ordem de Serviço SIGAMNT/SIGAGFR

@param cOrderCode, String, Código da O.S.

@author Cauê Girardi Petri
@since	11/10/2023
@return	Lógico, Define se o processo foi concluido com sucesso
/*/
//---------------------------------------------------------------------

@Get ( endpoint = 'mntOrder/order/:orderCode' )
function MntOrderGet()

    local lRet       := .t.
    local jPath      := oRest:getPathParamsRequest()
    local cOrderCode := jPath[ 'orderCode' ]
	local oError
	local bLastError

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),lRet:= .F., Break(oError) } )

    Begin Sequence

        If lRet

            DbSelectArea( 'STJ' )
            DbSetOrder( 1 )
            If DbSeek( FwxFilial('STJ') + PadR( cOrderCode, TAMSX3( 'TJ_ORDEM' )[1] ) )

                oRest:SetResponse('{ ')

                fExecSTJ()           //Ordem de Serviço
                fExecSTL(cOrderCode) //Insumos
                fExecTTC(cOrderCode) //Sintomas
                fExecSTQ(cOrderCode) //CheckList
                fExecTPL(cOrderCode) //Resposta da Checklist

                oRest:SetResponse( '}' )

                printf( 'Ordem ' + cOrderCode + ' enviada com sucesso' )

            Else

                printf( STR005 )
                
                oRest:setFault('{"error": "' + STR005 +'"}')
                oRest:setStatusCode(400)

            EndIf

        EndIf

	End Sequence

    ErrorBlock(bLastError)

Return .t.

//------------------------------------------------------------------------
/*/{Protheus.doc} MntOrderPUT
Método PUT para Alteração, Finalização e Cancelamento de Ordem de Serviço

@author Cauê Girardi Petri
@since	06/10/2023
@return	Lógico, True
/*/
//------------------------------------------------------------------------

@Put ( endpoint = 'mntOrder/order/:action' )
function MntOrderPUT()

    local oError
	local bLastError
    local cAction    := oRest:URN
    local aReturn    := { '' ,400 }

	bLastError := ErrorBlock( { |oError| MntWSError( oError ),.F., Break(oError) } )
    
    Begin Sequence

        If 'cancel' $ cAction

            aReturn := fOsCancel( oRest )

        ElseIf 'finish' $ cAction

            aReturn := fOsFinish( oRest )

        ElseIf 'reopen' $ cAction

            aReturn := fOsReOpen( oRest )

        EndIf

        oRest:SetStatusCode(aReturn[2])
        oRest:SetResponse(aReturn[1])

	End Sequence
    
    ErrorBlock(bLastError)

    FWFreeArray( aReturn )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} printf
Função para apresentar ou não mensagens no server, utilizado geralmente
para testes de desenvolvimento

@author	Cauê Girardi Petri
@since  21/03/2023
@return string, log + data e hora
/*/
//---------------------------------------------------------------------
Static Function printf(cLog)
return FwLogMsg( 'INFO', cValToChar( ThreadId() ), 'REST', 'mntOrder', '', '01', cLog, 0, 0, {} )

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fExecSTJ
Função para colocar na tela os dados da STJ (Ordem de Serviço)

@author	Cauê Girardi Petri
@since  18/10/2023
/*/
//--------------------------------------------------------------------------------
Static Function fExecSTJ()

    oRest:SetResponse( '"order":{')

    fLoadField( 'STJ' )

    oRest:SetResponse('}')

Return

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fExecSTL
Função para colocar na tela os dados da STL (Insumos)

@param cOrderCode, String, Código da O.S.

@author	Cauê Girardi Petri
@since  19/10/2023
/*/
//--------------------------------------------------------------------------------
Static Function fExecSTL(cOrderCode)

    Local nCount := 0

    DbSelectArea( 'STL' )
    DbSetOrder( 1 )
    If DbSeek( FwxFilial('STL') + cOrderCode )

        oRest:SetResponse(',"inputs":[')

        While STJ->TJ_FILIAL == STL->TL_FILIAL .AND. STJ->TJ_PLANO == STL->TL_PLANO;
            .AND. STJ->TJ_ORDEM == STL->TL_ORDEM

            If nCount >= 1

                oRest:SetResponse(',')

            EndIf

            oRest:SetResponse( '{' )

            oRest:SetResponse( '"fields":{' ) 

            fLoadField( 'STL' )

            oRest:SetResponse('}')

            //Procura e escreve as ocorrencias do insumo
            fExecSTN(cOrderCode)

            oRest:SetResponse('}')

            STL->( DbSkip() )

            nCount++

        End

        oRest:SetResponse(']') 

    EndIf

Return

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fExecTTC
Função para colocar na tela os dados da TTC (Sintomas da O.S.)

@param cOrderCode, String, Código da O.S.

@author	Cauê Girardi Petri
@since  27/10/2023
/*/
//--------------------------------------------------------------------------------
Static Function fExecTTC(cOrderCode)

    Local nCount := 0

    DbSelectArea( 'TTC' )
    DbSetOrder( 1 )
    If DbSeek( FwxFilial('TTC') + cOrderCode )

        oRest:SetResponse( ',"symptoms":[' ) 
        

        While STJ->TJ_FILIAL == TTC->TTC_FILIAL .AND. STJ->TJ_PLANO == TTC->TTC_PLANO;
            .AND. STJ->TJ_ORDEM == TTC->TTC_ORDEM

            If nCount >= 1

                oRest:SetResponse(',')

            EndIf

            oRest:SetResponse( '{' ) 

            fLoadField('TTC')

            oRest:SetResponse( '}' ) 

            TTC->( DbSkip() )

            nCount++

        End

        oRest:SetResponse( ']' ) 

    EndIf

Return

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fExecSTN
Função para colocar na tela os dados da STN (Ocorrência do Insumo)

@param cOrderCode, String, Código da O.S.

@author	Cauê Girardi Petri
@since  19/10/2023
/*/
//--------------------------------------------------------------------------------
Static Function fExecSTN(cOrderCode)

    Local nCount := 0

    DbSelectArea( 'STN' )
    DbSetOrder( 1 )
    If DbSeek( FwxFilial('STN') + cOrderCode )

        oRest:SetResponse( ',"ocurrences":[' ) 
        

        While STL->TL_FILIAL == STN->TN_FILIAL .AND. STL->TL_PLANO == STN->TN_PLANO;
            .AND. STL->TL_ORDEM == STN->TN_ORDEM

            If nCount >= 1

                oRest:SetResponse(',')

            EndIf

            oRest:SetResponse( '{' ) 

            fLoadField('STN')

            oRest:SetResponse( '}' ) 

            STN->( DbSkip() )

            nCount++

        End

        oRest:SetResponse( ']' ) 

    EndIf

Return

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fExecSTQ
Função para colocar na tela os dados da STQ (Checklists)

@param cOrderCode, String, Código da O.S.

@author	Cauê Girardi Petri
@since  20/10/2023
/*/
//--------------------------------------------------------------------------------
Static Function fExecSTQ(cOrderCode)

    Local nCount := 0

    DbSelectArea( 'STQ' )
    DbSetOrder( 1 )
    If DbSeek( FwxFilial('STQ') + cOrderCode )

        oRest:SetResponse( ',"checklists":[' ) 

        While STJ->TJ_FILIAL == STQ->TQ_FILIAL .AND. STJ->TJ_PLANO == STQ->TQ_PLANO;
            .AND. STJ->TJ_ORDEM == STQ->TQ_ORDEM

            If nCount >= 1

                oRest:SetResponse(',')

            EndIf

            oRest:SetResponse('{')

            oRest:SetResponse( '"fields":{' )

            fLoadField('STQ')

            oRest:SetResponse( '}' ) 

            //Procura e escreve as repostas do checklist
            fExecTPQ(cOrderCode)

            STQ->( DbSkip() )

            oRest:SetResponse('}')

            nCount++

        End

        oRest:SetResponse( ']' )

    EndIf

Return

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fExecTPQ
Função para colocar na tela os dados da TPQ (Resposta das checklists)

@param cOrderCode, String, Código da O.S.

@author	Cauê Girardi Petri
@since  20/10/2023
/*/
//--------------------------------------------------------------------------------
Static Function fExecTPQ(cOrderCode)

    Local nCount := 0

    DbSelectArea( 'TPQ' )
    DbSetOrder( 1 )
    If DbSeek( FwxFilial('TPQ') + cOrderCode )

        oRest:SetResponse( ',"answers":[' )
        
        While STQ->TQ_FILIAL == TPQ->TPQ_FILIAL .AND. STQ->TQ_PLANO == TPQ->TPQ_PLANO;
            .AND. STQ->TQ_ORDEM == TPQ->TPQ_ORDEM .AND. STQ->TQ_ETAPA == TPQ->TPQ_ETAPA

            If nCount >= 1

                oRest:SetResponse(',')

            EndIf

            oRest:SetResponse( '{' )

            fLoadField( 'TPQ' )

            oRest:SetResponse('}')

            TPQ->( DbSkip() )

            nCount++

        End

        oRest:SetResponse( ']' )

    EndIf

Return

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fExecTPL
Função para colocar na tela os dados da TPL (Motivo de Atraso)

@param cOrderCode, String, Código da O.S.

@author	Cauê Girardi Petri
@since  20/10/2023
/*/
//--------------------------------------------------------------------------------
Static Function fExecTPL(cOrderCode)

    Local nCount := 0

    DbSelectArea( 'TPL' )
    DbSetOrder( 1 )
    If DbSeek( FwxFilial('TPL') + cOrderCode )

        oRest:SetResponse( ',"reasonsForDelay":[' ) 

        While STJ->TJ_FILIAL == TPL->TPL_FILIAL .AND. STJ->TJ_ORDEM == TPL->TPL_ORDEM
            
        If nCount >= 1

            oRest:SetResponse(',')

        EndIf

            oRest:SetResponse( '{' )

            fLoadField( 'TPL' )

            oRest:SetResponse('}' )

            TPL->( DbSkip() )

            nCount++

        End

        oRest:SetResponse( ']' )

    EndIf

Return

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fLoadField
Função para carregar os campos de cada tabela

@param cAliasTab , String, Alias atual

@author	Cauê Girardi Petri
@since  20/10/2023
/*/
//--------------------------------------------------------------------------------
Static Function fLoadField( cAliasTab )

    Local aCampos   := {}
    Local ni        := 0
    Local cResult   := ''

    RegToMemory( cAliasTab, .F. )
    aCampos := NGHeader( cAliasTab, , .F. )

    For ni := 1 to Len(aCampos)


        If aCampos[ ni,10 ] <> 'V'

            If aCampos[ni][8] == 'C' .OR. aCampos[ni][8] == 'M'

                cResult := '"' + &( cAliasTab + '->' + aCampos[ni][2]) + '"'

            ElseIf aCampos[ni][8] == 'D'

                cResult := '"' + DtoS( &( cAliasTab + '->' +  aCampos[ni][2] ) ) + '"'

            Else

                cResult := cValToChar( &( cAliasTab + '->' +  aCampos[ni][2] ) )

            EndIf

        Else

            cResult := '"' + AllTrim( &( Posicione("SX3",2,aCampos[ni,2],"X3_RELACAO") ) ) + '"'

        EndIf

        If !Empty( cResult )

            If ni > 1

                oRest:SetResponse( ', ' ) 

            EndIf

            oRest:SetResponse( '"'+ aCampos[ni][2] + '"' + ': ' + cResult )

        EndIf

    Next ni

Return

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fOsCancel
Função para cancelar OSs via API

@param oRest, Objeto, Objeto atual

@return  cMsg, String, Mensagem para ser exibida no final do processo
@return nCode,    int, Código HTTP retornado 

@author	Cauê Girardi Petri
@since  06/05/2024
/*/
//--------------------------------------------------------------------------------
Static Function fOsCancel( oRest )

    Local cOrderCode    := ''
    Local cOrderPlan    := ''
    Local cOrderObs     := ''
    Local cMsg          := ''
    Local nCode         := 500
    Local cBody         := oRest:getBodyRequest()
    Local oJson         := JsonObject():New()

    cMsg := oJson:FromJson( cBody )

    oJson := oJson['order']

    If Empty( cMsg )

        If ValType( ( oJson['TJ_ORDEM'] ) ) != 'U'
            cOrderCode := PadR( oJson['TJ_ORDEM'], TAMSX3( 'TJ_ORDEM' )[1] )
        EndIf

        If ValType( ( oJson['TJ_PLANO'] ) ) != 'U'
            cOrderPlan := PadR( oJson['TJ_PLANO'], TAMSX3( 'TJ_PLANO' )[1] )
        EndIf

        If ValType( ( oJson['TJ_OBSERVA'] ) ) != 'U'
            cOrderObs := DecodeUTF8( oJson['TJ_OBSERVA'] )
        EndIf

        DbSelectArea('STJ')
        DbSetOrder(1)
        If DbSeek( FwxFilial('STJ') + cOrderCode + cOrderPlan )

            If STJ->TJ_SITUACA == 'C'

				cMsg    := 'Ordem de servico ja cancelada ' + cOrderCode + '.'

			ElseIf STJ->TJ_TERMINO == 'S'

				cMsg    := 'Ordem de servico ja finalizada ' + cOrderCode + '.'

			EndIf
			
        Else

            cMsg  := 'Ordem de Serviço não encontrada'

        EndIf

        If !Empty( cMsg )

			Return { cMsg, 400 }

		EndIf

        DbSelectArea('STQ')
        DbSetOrder(1)
        If DbSeek( FwxFilial('STQ') + cOrderCode + cOrderPlan )

            While STQ->(!Eof())

                If !Empty(STQ->TQ_OK)
	    				//Verifica se foi gerada OS para esta etapa, e a OS gerada nao esta cancelada
	    				If !MNT400OSG( STQ->TQ_ORDEM , STQ->TQ_PLANO , STQ->TQ_TAREFA , STQ->TQ_ETAPA , .F. , .T. )
    
                            cMsg := 'Existem OSs que foram geradas a partir de uma das etapas a serem excluidas,'
                            cMsg += 'portanto primeiro cancele as OSs impeditivas'                    

	    				ElseIf !MNT400SSG( STQ->TQ_ORDEM, STQ->TQ_PLANO, STQ->TQ_TAREFA, STQ->TQ_ETAPA, .F., .T. )
    
                            cMsg := 'Existem SSs que foram geradas a partir de uma das etapas a serem excluidas,'
                            cMsg += 'portanto primeiro exclua as SSs impeditivas'

	    				EndIf

	    			EndIf

	    		STQ->(dbSkip())

            End

            If !Empty( cMsg )

                Return { cMsg, 400 }

            EndIf

        EndIf

        dbSelectArea("STL")
		dbSetOrder(01)
		dbSeek( FwxFilial('STL') + cOrderCode + cOrderPlan )
		While !EoF() .and. STL->TL_FILIAL == FwxFilial('STL') .And.;
				STL->TL_ORDEM == cOrderCode .And. STL->TL_PLANO == cOrderPlan

            If Val( STL->TL_SEQRELA ) <> 0
				
                cMsg := 'Cancelamento não permitido. Esta Ordem de Serviço já tem insumo reportado.'

			    Return { cMsg, 400 }

            EndIf

            STL->( dbSkip() )

		End While

        Begin Transaction

            DbSelectArea('STJ')
            DbSetOrder(1)
            If DbSeek( FwxFilial('STJ') + cOrderCode + cOrderPlan )

                //Checa se existe SA com Pre-Requisicao
		        If !NGCHKSAPR( STJ->TJ_ORDEM , STJ->TJ_PLANO, , .F., .F. )

                    cMsg := 'Cancelamento da O.S. não permitido pois existe Solicitação ao Armazém'
                    cMsg += ' com Pré-Requisição.'
			        nCode := 400

		        EndIf

                //Valida cotação de solicitação de compras
                aReturn := NGGERCOTAC(STJ->TJ_ORDEM,.F.)

                If nCode == 500 .And. !aReturn[1]

                    cMsg  := aReturn[2]
                    nCode := 400

                EndIf

                If nCode == 500 .And. ExistBlock("NGTERMOT")

			        If !ExecBlock("NGTERMOT",.F.,.F.)

                        cMsg := 'Bloqueio de cancelamento pelo PE NGTERMOT'
				        nCode := 400

			        EndIf

		        EndIf
    
    
                If nCode == 500 .And. aReturn[1]
    
                    aReturn := NGDELETOS( STJ->TJ_ORDEM,STJ->TJ_PLANO,cOrderObs,.T.)

                    If aReturn[1]

                        //Deleta o historico do contador 1 e 2 se tiver registro relacionado a OS
                        If STJ->TJ_POSCONT > 0 .And. !Empty(STJ->TJ_HORACO1)
                            MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO1,1)
                        EndIf

                        If STJ->TJ_POSCON2 > 0 .And. !Empty(STJ->TJ_HORACO2)
                            MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO2,2)
                        EndIf

                        nCode   := 200
                        cMsg    := 'Ordem de Serviço '+ cOrderCode +' cancelada com sucesso'
                    
                    EndIf
    
                EndIf
                
                If nCode == 400 .Or. !aReturn[1]

                    If Empty( cMsg )
    
                        nCode := 400
                        cMsg := 'Não foi possivel cancelar a OS '+ cOrderCode + ' pois ' + aReturn[2]

                    EndIf

                    Disarmtransaction()

                EndIf
    
            EndIf

        End Transaction

    Else

        nCode := 400

    EndIf

Return {cMsg, nCode}

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fOsReOpen
Função para reabrir OSs via API

@param oRest, Objeto, Objeto atual

@return  cMsg, String, Mensagem para ser exibida no final do processo
@return nCode,    int, Código HTTP retornado 

@author	Cauê Girardi Petri
@since  21/08/2024
/*/
//--------------------------------------------------------------------------------
Static Function fOsReOpen( oRest )

    Local cBody     := oRest:getBodyRequest()
    Local oJson     := JsonObject():New()
    Local cOrderCode:= ''
    Local cMsg      := ''
    Local nCode     := 500
    Local aReturn   := { .T., ' '}

    cMsg := oJson:FromJson( cBody )

    oJson := oJson['order']

    If Empty( cMsg ) .And. oJson:hasProperty('TJ_ORDEM')

        If !Empty( oJson['TJ_ORDEM'] )

            cOrderCode := PadR( oJson['TJ_ORDEM'], FwTamSX3( 'TJ_ORDEM' )[1] )

            aReturn := MNTA880( cOrderCode ) 

            If aReturn[1]

                cMsg  := 'Ordem de Serviço ' + cOrderCode + ' reaberta com sucesso'
                nCode := 200

            Else

                cMsg  := aReturn[2]
                nCode := 400 

            EndIf
        
        Else

            cMsg  := 'Ordem de Serviço não informada'
            nCode := 400

        EndIf

    EndIf

    FWFreeArray( aReturn )

Return {cMsg, nCode}

//--------------------------------------------------------------------------------
/*/{Protheus.doc} fOsFinish
Função para finalizar OSs via API

@param oRest, Objeto, Objeto atual

@return  cMsg, String, Mensagem para ser exibida no final do processo
@return nCode,    int, Código HTTP retornado 

@author	Cauê Girardi Petri
@since  15/07/2024
/*/
//--------------------------------------------------------------------------------
Static Function fOsFinish( oRest )

    Local cOrderCode    := ''
    Local cOrderPlan    := ''
    Local cCodIrregu    := ''
    Local cOrderObs     := ''
    Local cDtMrINI      := ''
    Local cDtMrFIM      := ''
    Local cHoMrINI      := ''
    Local cHoMrFIM      := ''
    Local nPosCont      := 0
    Local cHoraCo1      := ''
    Local nPosCont2     := 0
    Local cHoraCo2      := ''
    Local cMsg          := ''
    Local nCode         := 500
    Local cBody         := oRest:getBodyRequest()
    Local oJson         := JsonObject():New()
    Local oObjOs
    Local aReturn       := {}
    Local aCounter      := {}

    cMsg := oJson:FromJson( cBody )

    oJson := oJson['order']

    If Empty( cMsg )

        If ValType( ( oJson['TJ_ORDEM'] ) ) != 'U'
            cOrderCode := PadR( oJson['TJ_ORDEM'], TAMSX3( 'TJ_ORDEM' )[1] )
        EndIf

        If ValType( ( oJson['TJ_PLANO'] ) ) != 'U'
            cOrderPlan := PadR( oJson['TJ_PLANO'], TAMSX3( 'TJ_PLANO' )[1] )
        EndIf

        If ValType( ( oJson['TJ_IRREGU'] ) ) != 'U'
            cCodIrregu := PadR( oJson['TJ_IRREGU'], TAMSX3( 'TJ_IRREGU' )[1] )
        EndIf

        If ValType( ( oJson['TJ_OBSERVA'] ) ) != 'U'
            cOrderObs := DecodeUTF8( oJson['TJ_OBSERVA'] )
        EndIf

        If ValType( ( oJson['TJ_DTMRINI'] ) ) != 'U'
            cDtMrINI := oJson['TJ_DTMRINI']
        EndIf

        If ValType( ( oJson['TJ_HOMRINI'] ) ) != 'U'
            cHoMrINI := PadR( oJson['TJ_HOMRINI'], TAMSX3( 'TJ_HOMRINI' )[1] )
        EndIf

        If ValType( ( oJson['TJ_DTMRFIM'] ) ) != 'U'
            cDtMrFIM := oJson['TJ_DTMRFIM']
        EndIf

        If ValType( ( oJson['TJ_HOMRFIM'] ) ) != 'U'
            cHoMrFIM := PadR( oJson['TJ_HOMRFIM'], TAMSX3( 'TJ_HOMRFIM' )[1] )
        EndIf

        If ValType( ( oJson['TJ_POSCONT'] ) ) != 'U'
            nPosCont := oJson['TJ_POSCONT']
            If ValType( ( oJson['TJ_HORACO1'] ) ) != 'U'
                cHoraCo1 := oJson['TJ_HORACO1']
            EndIf
        EndIf

        If ValType( ( oJson['TJ_POSCON2'] ) ) != 'U'
            nPosCont2 := oJson['TJ_POSCON2']
            If ValType( ( oJson['TJ_HORACO2'] ) ) != 'U'
                cHoraCo2 := oJson['TJ_HORACO2']
            EndIf
        EndIf

    EndIf

    DbSelectArea('STJ')
    DbSetOrder(1)
    If MsSeek( FwxFilial('STJ') + cOrderCode + cOrderPlan )

        oObjOs := JsonObject():New()
        oObjOs['plan']          := cOrderPlan
        oObjOs['order']         := cOrderCode
        oObjOs['fault']         := cCodIrregu
        oObjOs['observation']   := cOrderObs
        oObjOS['startDate']     := cDtMrINI + ' ' + cHoMrINI
        oObjOs['endDate']       := cDtMrFIM + ' ' + cHoMrFIM
        oObjOs['json']          := ''

        If nPosCont > 0

            oObjCont := JsonObject():New()
            oObjCont['value'] := nPosCont
            oObjCont['time']  := cHoraCo1

            aAdd( aCounter, oObjCont )

            If nPosCont2 > 0

                oObjCont2 := JsonObject():New()
                oObjCont2['value'] := nPosCont2
                oObjCont2['time']  := cHoraCo2

                aAdd( aCounter, oObjCont2 )

            EndIf

            oObjOs['counter'] := aCounter

        EndIf

        aReturn := MNTNGFim( oRest, FWJsonSerialize( oObjOs ) )

        If !aReturn[1]

            cMsg := aReturn[2]
            nCode := 400

        Else

            cMsg  := 'Ordem de Serviço ' + cOrderCode + ' finalizada com sucesso'
            nCode := 200

        EndIf

    Else

        cMsg  := 'Ordem de Serviço não encontrada'
        nCode := 400

    EndIf

Return { cMsg, nCode }
