#Include "MDTA180.ch"
#Include "Protheus.ch"
#include "ap5mail.ch"

#DEFINE _nDTENTR_ 4
#DEFINE _nRECFIL_ 8

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTA180
Programa de Cadastro dos riscos existentes na empresa e que a empresa
tem enteresse em controlar. Os campos c.custo, funcao e tarefa
permitem o usuario nformar o local exato do risco ou "*" indicando
que o risco abrange a todos os funcinarios que se enquadram nos
demais parametros. Esta estrurua permite flexibilidade para
o usuario e reduz o tempo no cadastramento dos riscos.

@type Function

@source MDTA180.prx

@sample MDTA180()

@author Marcio Costa
@since 25/01/00
/*/
//---------------------------------------------------------------------
Function MDTA180

	//------------------------------------------------
	// Armazena variaveis p/ devolucao (NGRIGHTCLICK)
	//------------------------------------------------
	Local aNGBEGINPRM := NGBEGINPRM()
	Local aAreaTN0    :={}
	Local nA

	Private aTROCAF3 := {}
	Private aRotina  := MenuDef( , .F. )
	Private aCHKDEL  := {}
	Private cCadastro
	Private bNGGRAVA
	Private aTIPADI
	Private aX3TIPADI

	If AMiIn( 35 ) // Somente autorizado para SIGAMDT

		aTIPADI   := {}
		aX3TIPADI := ComboX3Box( "TMA_TIPADI", X3Cbox() )
		For nA := 1 To Len( aX3TIPADI )
			aAdd( aTIPADI, SubStr( aX3TIPADI[nA], At( "=", aX3TIPADI[nA] ) + 1 ) )
		Next

		lSigaMdtPS := IIf( SuperGetMv( "MV_MDTPS", .F., "N" ) == "S", .T., .F. )

		nSizeCli := IIf( ( TAMSX3( "A1_COD" )[1] ) < 1, 6, ( TAMSX3( "A1_COD" )[1] ) )
		nSizeLoj := IIf( ( TAMSX3( "A1_LOJA" )[1] ) < 1, 2, ( TAMSX3( "A1_LOJA" )[1] ) )
		cDescCC := "SI3->I3_DESC"  //usado no gatilho do campo TN0_CC
		cAliasCC := "SI3"
		cDescr := "I3_DESC"

		If Alltrim( GetMv( "MV_MCONTAB" ) ) == "CTB"
			cDescCC := "CTT->CTT_DESC01"
			cAliasCC := "CTT"
			cDescr := "CTT_DESC01"
		EndIf

		If lSigaMdtps
			cCadastro := OemtoAnsi( STR0012 )  //"Clientes"

			dbSelectArea( "SA1" )
			dbSetOrder( 1 )

			mBrowse( 6, 1, 22, 75, "SA1" )
		Else

			//---------------------------------------------
			// Define o cabecalho da tela de atualizacoes
			//---------------------------------------------
			cCadastro := OemtoAnsi( STR0006 ) //"Riscos"
			Private DTVALIDA  := .T.

			//------------------------------
			// Endereca a funcao de BROWSE
			//------------------------------
			aAreaTN0    := TN0->(GetArea())//Salva Area
			dbSelectArea( "TN0" )
			dbSetOrder( 1 )
			MDTTrcUMed() //Verifica as unidades de medida
			mBrowse( 6, 1, 22, 75, "TN0", , , , , , RiscoCor() )
			RestArea( aAreaTN0 )
		EndIf
	EndIf

	//-----------------------------------------------
	// Devolve variaveis armazenadas (NGRIGHTCLICK)
	//-----------------------------------------------
	NGRETURNPRM( aNGBEGINPRM )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGALT01
Bloqueia campos na alteracao dependendo do campo data da avaliacao
se este campos ja estiver prenchido nada pode ser alterado.

@type Function

@source MDTA180.prx

@sample NGALT01()

@author Marcio Costa/INACIO
@since 28/01/00
/*/
//---------------------------------------------------------------------
Function NGALT01()

	aMemos   := {}
	aTROCAF3 := {}

	If Empty( TN0->TN0_DTAVAL )
		DTVALIDA := .T.
	Else
		DTVALIDA := .F.
	ENDIf

	If NGCADICBASE( "TN0_DANCAU", "D", "TN0", .F. )
		aAdd( aMemos, { "TN0_DANSYP", "TN0_DANCAU" } )
	ENDIf
	If NGCADICBASE( "TN0_SITSYP", "A", "TN0", .F. )
		aAdd( aMemos, { "TN0_SITSYP", "TN0_MSITUA" } )
		aAdd( aMemos, { "TN0_SI2SYP", "TN0_MSITU2" } )
	EndIf

	NGCAD01( "TN0", RECNO(), 4 )
	DTVALIDA := .T.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} D180INCL
Gravando o registro

@type Function

@source MDTA180.prx

@param cALIAT, Caracter, Alias
@param nREG1, Numérico, Recno do Registro
@paramn nOPX, Numérico, Valor da opção da operação
@param [cTRBTAF], Caracter, Tabela da TRB utilizada na estrutura da Arvore Lógica

@return Numérico, Retorna 0/1

@samples D180INCL( "TN0" , 0 , 3 )

@author Denis Hyroshi Souza
@since 29/10/02
/*/
//---------------------------------------------------------------------
Function D180INCL( cALIAT, nREG1, nOPX, cTRBTAF )

	Local cMsg
	Local nTrb
	Local nFld
	Local oWndRis
	Local oPnlWnd
	Local oEnchoice
	Local cKey
	Local bWhile
	Local nOrd
	Local oTempTMPA
	Local nRet    := 0
	Local lEPIRis := SuperGetMv( "MV_NG2EPIR", .F., "1" ) == "2"

	// Controle de aChoice
	Local aChoiceOld := IIf( Type( "aChoice" ) == "A", aClone( aChoice ), {} )

	// Variaveis das dimensoes da tela
	Local aSize     := MsAdvSize( , .F., 430 )
	Local aObjects  := {}
	Local aPosObj   := {}
	Local aObjAlign := {}

	// Variaveis estrutura Getdados
	Local aHead180  := {}
	Local aCols180  := {}
	Local aNoFields := { "TJF_NUMRIS" }
	Local cWhile

	// Estrutura tabelas temporarias
	Local aEstTrbs := {}

	// Variaveis condicionais
	Local lRiscMed
	Local lOlnyVis
	Local lCpyRisc

	//Variavel declarada para ao entrar na visualização do F3 e
	//retornar para tela principal não apagar o registro do acols
	Local aNGBEGINPRM := NGBEGINPRM()

	Default cTRBTAF := IIf( Type( "cTRBSGA" ) == "C", cTRBSGA, "" )

	Private oMenu
	Private oGetWnd
	Private aTela      := {}
	Private aGets      := {}
	Private lSigaMdtPs := SuperGetMv( "MV_MDTPS", .F., "N" ) == "S"
	Private aNao	   := { "TN0_CONFUN", "TN0_PRZVLD", "TN0_PERTRC", "TN0_HIGIEN", "TN0_MANUT" }
	Private aChoice    := IIf( Len( aChoiceOld ) > 0, aClone( aChoiceOld ), IIf( !lEPIRis, NGCAMPNSX3( "TN0", aNao ), Nil ) )
	Private cMrkBrw180 := GetMark()
	Private lCallMS    := .F.

	// When dos campos para a chamada da Arvore Lógica
	Private lTrava902 := .T.
	Private lTravaAmb := .T.

	Private Continua
	Private nUsado 	  := 0
	Private cRiscoAnt := TN0->TN0_NUMRIS
	Private cAgeAnt	  := IIf( nOPX == 3, Space( TamSX3( "TN0_AGENTE" )[1] ), TN0->TN0_AGENTE )

	Private aNgButton  := {} // Botoes especificos NGCAD
	Private aHead180PQ := {}
	Private aCols180PQ := {}

	// MONTA O TEMPORARIO PARA VISUALIZAR OS FUNCIONARIOS
	fCriaTRBFunc( @oTempTMPA )

	//Variaveis condicionais
	lRiscMed   := NGCADICBASE( "TJF_NUMRIS", "A", "TJF", .F. )
	lOlnyVis   := Str( nOpx, 1 ) $ "2/5"
	lCpyRisc   := nOpx == 7

	//---------------------------------------------
	// Define o cabecalho da tela de atualizacoes
	//---------------------------------------------
	cCadastro := OemtoAnsi( STR0006 ) //"Riscos"

	If !lSigaMdtPS
		aAdd( aNgButton, { "ENSAIO1", { || Mdt180PrdQ( nOpx, lCpyRisc ) }, STR0064, STR0068 } ) // "Prod. Quimico" ## "Prod. Quím."
	EndIf
	aAdd( aNgButton, { "VENDEDOR", { || MDT180FER() }, STR0072, STR0072 } ) // "Func.Exp.Risco"

	// Evento para a tecla F10
	If nOpx == 3 .Or. lCpyRisc .Or. ( nOpx == 4 .And. Empty( TN0->TN0_DTAVAL ) )
		bKeyF10 := SetKey( VK_F10 )
		SetKey( VK_F10, { || Mdt180F10() } )

		aEstTrbs := CrtTrbCFT() // Construcao de tabelas temporarias
	EndIf

	// Verifica se a tela necessitara de getdados
	If lRiscMed
		// Define objetos a serem apresentados em tela
		aAdd( aObjects, { 050, 050, .T., .T. } )
		aAdd( aObjects, { 100, 100, .T., .T. } )
		aPosObj := MsObjSize( { aSize[1], aSize[2], aSize[3], aSize[4], 0, 0 }, aObjects, .T. )
	Else
		aAdd( aPosObj, { 0, 0, 0, 0 } )
	EndIf

	DtValida := .T.
	aTROCAF3 := {}

	// Se nao for uma operacao de exclusao, visualizacao
	If !( Str( nOpx, 1 ) $ "5/2" )
		If nOpx == 3 .Or. lCpyRisc
			RollBackSX8()
		ElseIf nOpx == 4
			If !Empty( TN0->TN0_DTAVAL )
				DtValida := .F.
			EndIf
		EndIf
	EndIf

	// Carrega variaveis de memoria
	INCLUI := nOpx == 3
	ALTERA := nOpx == 4
	dbSelectArea( "TN0" )
	RegToMemory( "TN0", INCLUI )

	If INCLUI
		//Validacao de existência do codigo em base
		While MDTNumSQL( "TN0", "TN0_NUMRIS", M->TN0_NUMRIS )
			M->TN0_NUMRIS := GETSXENUM( "TN0", "TN0_NUMRIS" )
		End
	EndIf

	//When para a integração do Risco com a Arvore lógica
	If NGCADICBASE( "TAF_CODAMB", "A", "TAF", .F. )
		fWhenChkRis( cTRBTAF, lCpyRisc )
	EndIf

	If lCpyRisc // Copia
		M->TN0_NUMRIS := GetSXENum( "TN0", "TN0_NUMRIS" )
		nOpx   := 3
		Inclui := .T.
	EndIf

	// Contrucao dos parametros aHeader e aCols para uso da getdados de Medida de Controle
	If lRiscMed
		nOrd   := 1
		cKey   := xFilial( "TJF" ) + TN0->TN0_NUMRIS
		bWhile := {|| TJF->TJF_FILIAL + TJF->TJF_NUMRIS }

		dbSelectArea( "TJF" )
		dbGoTop()
		FillGetDados( nOpx, "TJF", nOrd, cKey, bWhile, {|| .T.}, aNoFields, , , , , nOpx == 3, aHead180, aCols180, , , , , , .T. )
	EndIf

	dbselectarea( "TN0" )
	If nOpx !=  3 .And. Type( "aHead180PQ" ) == "A" .And. Empty( aHead180PQ )
		SelPQKeyAt( nOpx, , lCpyRisc )
	EndIf

	Define MsDialog oWndRis Title cCadastro From aSize[7], 0 To aSize[6], aSize[5] Of oMainWnd Pixel

		// Panel Principal
		oPnlWnd       := TPanel():New( 0, 0, , oWndRis, , , , , , 0, 0 )
		oPnlWnd:Align := CONTROL_ALIGN_ALLCLIENT

			// Campos TN0 - Risco
			oEnchoice := MsMGet():New( cALIAT, nReg1, nOpx, , , , aChoice, aPosObj[1], , 3, , , , oPnlWnd )
			oEnchoice:oBox:Align := IIf( !lRiscMed, CONTROL_ALIGN_ALLCLIENT, CONTROL_ALIGN_TOP )
			aAdd( aObjAlign, oEnchoice:oBox )

			If lRiscMed // Se houver sido aplicado o update de criacao do campo TJF_NUMRIS, apresenta tabela TJF
				oGetWnd := MsNewGetDados():New( 0, 0, 1000, 1000, IIf( !lOlnyVis, GD_INSERT + GD_UPDATE + GD_DELETE, 0 ),;
												 { || MDT180MLOK( .F. ) .And. PutFileInEof( 'TJF' ) }, { || MDT180MLOK( .T. ) },;
												 , , , 9999, , , , oPnlWnd, aHead180, aCols180 )
				oGetWnd:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
				aAdd( aObjAlign, oGetWnd:oBrowse )
			EndIf

		// Tratamento para RightClick
		If Type( "aSMenu" ) == "A" .And. Len( aSMenu ) > 0
			NGPOPUP( aSMenu, @oMenu, oPnlWnd )
			oPnlWnd:bRClicked := { |o, x, y| oMenu:Activate( x, y, oPnlWnd ) }
			oEnchoice:oBox:bRClicked := { |o, x, y| oMenu:Activate( x, y, oEnchoice ) }
		EndIf

	Activate MsDialog oWndRis On Init EnchoiceBar( oWndRis, { || nRet := 1, IIf( Mdt180Vlf( nOpx, { lRiscMed } ), oWndRis:End(), nRet := 0 ) },;
												 { || oWndRis:End() }, AlignObject( oWndRis, aObjAlign, 1 ), aNgButton )

	If nRet == 1 // Se confirmou a tela
		If nOpx != 2 // Se nao for uma operacao de visualizacao

			// Processo de envido de WorkFlow
			If  nOpx == 4 .And. NGCADICBASE( 'TN0_ADIFOL', 'A', 'TN0', .F. )
				Processa( {|| Mdt180WfLa() }, "" )
			EndIf

			Processa( {|| Mdt180Grava( nOpx, lCpyRisc, cTRBTAF ) }, STR0051 ) // "Efetivando gravações..."

			If Type( "aHead180PQ" ) == "A"
				Mdt180GPQ( nOpx, IIf( lCpyRisc, cRiscoAnt, Nil ), lCpyRisc ) // Gravacao de Produtos Quimicos
			EndIf

			If nOpx == 4 // Alteracao
				DtValida := .T.
			EndIf
		EndIf
	Else
		RollBackSX8()
	EndIf

	// Retorna conteudo da variavel aChoice, e o evento da tecla F10
	If nOpx == 3
		aChoice := aClone( aChoiceOld )
		SetKey( VK_F10, bKeyF10 )
	EndIf

	// Finaliza/Deleta tabelas temporarias
	If Len( aEstTrbs ) > 0
		For nTrb := 1 To Len( aEstTrbs )
			aEstTrbs[nTrb][6]:Delete() //otempproc
		Next nTrb
	EndIf

	If Select( "TMPA" ) > 0
		oTempTMPA:Delete()
	EndIf

	//-----------------------------------------------
	// Devolve variaveis armazenadas (NGRIGHTCLICK)
	//-----------------------------------------------
	NGRETURNPRM( aNGBEGINPRM )

Return nRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt180Grava
Gravacao dos Riscos.

@type Function

@source MDTA180.prx

@param nOpcx, Numerico, Operacao atual.
@param [lCpyRisc], Lógico, Indica se trata-se de copia
@param cTRBTAF, Caracter, Tabela da TRB utilizada na estrutura da Arvore Lógica

@return Nulo

@sample Mdt180Grava( 3 , , 'SGC0001' )

@author Hugo R. Pereira
@since 07/01/2013
@obs Função é chamada no MNTA902 e no método TNGPG caso houver alterações
 na função considera las nessas chamadas.
/*/
//---------------------------------------------------------------------
Function Mdt180Grava( nOpcx, lCpyRisc, cTRBTAF )

	Local aMSCCusto	:= SetArrSlc( "TN0_CC" )     // Centro de Custo
	Local aMSFuncao := SetArrSlc( "TN0_CODFUN" ) // Funcao
	Local aMSTarefa := SetArrSlc( "TN0_CODTAR" ) // Tarefa
	Local aMSDeptos := SetArrSlc( "TN0_DEPTO" )  // Departamento

	Local cAuxCC    := ""
	Local cRelease	:= GetRpoRelease()

	Local lRetEso 	:= .T.
	Local lSelFax	:= .F.
	Local lRiscEpi	:= .F.
	Local lRiscExa	:= .F.
	Local lAgenExa	:= .F.
	// Se algum dos array possuir mais que um registro
	Local lMRiscos  := ;
		Len( aMSCCusto ) > 1 ;
		.Or. Len( aMSFuncao ) > 1 ;
		.Or. Len( aMSTarefa ) > 1 ;
		.Or. Len( aMSDeptos )
	Local lCamposEso := IIf( nOpcx == 4, fCamposEso(), .T. ) 

	Local nFldCC
	Local nFldFun
	Local nFldTar
	Local nFldDpt

	Default lCpyRisc := .F.

	Private lVrfExRis := Nil // Variavel de controle para verificacao de risco ja existente

	Begin Transaction

		ProcRegua( 0 )

		If lCpyRisc//Verifica se é cópia
			//Verifica se será copia os Epis relacionados ao risco.
			dbSelectArea( "TNX" )
			dbSetOrder( 1 )
			If dbSeek( xFilial( "TNX" ) + cRiscoAnt )
				If MsgYesNo( STR0026 )  //"Deseja copiar os Epi's relacionados ao risco?"
					lRiscEpi := .T.
				EndIf
			EndIf
			//Verifica se será copia os Exames relacionados ao risco.
			dbSelectArea( "TN2" )
			dbSetOrder( 1 )
			If dbSeek( xFilial( "TN2" ) + cRiscoAnt )
				If MsgYesNo( STR0027 )  //"Deseja copiar os Exames relacionados ao risco?"
					lRiscExa := .T.
				EndIf
			EndIf
		ElseIf nOpcx == 3 .And. !lSigaMdtPs
			dbSelectArea( "TMB" )
			dbSetOrder( 1 )
			If dbSeek( xFilial( "TMB" ) + M->TN0_AGENTE )
				If TMB->( ColumnPos( "TMB_FAIXA" ) ) > 0 .And. cRelease >= "12.1.023"
					If ( lAgenExa := MsgYesNo( STR0217 ) ) //"O Agente informado possui exames relacionados, deseja vincular ao Risco e informar uma faixa periódica para os exames que não possuem?"
						While xFilial( "TMB" ) == TMB->TMB_FILIAL .And. TMB->TMB_AGENTE == M->TN0_AGENTE
							If Empty( TMB->TMB_FAIXA )
								While !lSelFax
									If !( lSelFax := ConPad1( , , , "TMQ", , , .F. ) )
										ShowHelpDlg( STR0032,;        //"Atenção"
													{ STR0143 }, 1,; //"Para continuar é necessário selecionar uma Faixa Periódica."
													{ STR0144 }, 1 ) //"Selecione uma faixa periódica."
									EndIf
								End
								Exit
							Else
								dbSkip()
							EndIf
						End
					EndIf
				Else
					If ( lAgenExa := MsgYesNo( STR0142 ) ) //"O Agente informado possui exames relacionados, deseja vincular ao Risco e informar uma faixa periódica?"
						While !lSelFax
							If !( lSelFax := ConPad1( , , , "TMQ", , , .F. ) )
								ShowHelpDlg( STR0032,;        //"Atenção"
									{ STR0143 }, 1,; //"Para continuar é necessário selecionar uma Faixa Periódica."
									{ STR0144 }, 1 ) //"Selecione uma faixa periódica."
							EndIf
						End
					EndIf
				EndIf
			EndIf
		EndIf

		// Efetua processo de gravação dos riscos
		// Conforme a seleção em tela, efetiva cruzamento entre parâmetros selecionados

		For nFldCC := 1 To Len( aMSCCusto ) // Verifica os centros de custo selecionados

			M->TN0_CC := aMSCCusto[nFldCC]

			For nFldFun := 1 To Len( aMSFuncao ) // Verifica as funções selecionadas

				M->TN0_CODFUN := aMSFuncao[nFldFun]

				For nFldTar := 1 To Len( aMSTarefa ) // Verifica as tarefas selecionadas

					M->TN0_CODTAR := aMSTarefa[nFldTar]

					For nFldDpt := 1 To Len( aMSDeptos )

						M->TN0_DEPTO := aMSDeptos[nFldDpt]

						// Efetua a gravação do registro
						GravaMmry( nOpcx, lMRiscos, lCpyRisc, cTRBTAF, lRiscEpi, lRiscExa, lAgenExa )

						MDTAdicSRA( nOpcx ) // Verifica os adicionais e se necessário ajusta para cada funcionário exposto ao risco

						//-----------------------------------------------------------------
						// Realiza a integração das informações do evento S-2240 ao Governo
						//-----------------------------------------------------------------
						If FindFunction( "MDTIntEsoc" ) .And. lRetEso .And. lCamposEso
							lRetEso := fRisS2240( nOpcx )
						EndIf

					Next nFldDpt

				Next nFldTar

			Next nFldFun

		Next nFldCC

		// Atualiza conteudo das variaveis de memoria conforme ultimo risco inserido
		M->TN0_NUMRIS := TN0->TN0_NUMRIS
		M->TN0_CODFUN := TN0->TN0_CODFUN
		M->TN0_CODTAR := TN0->TN0_CODTAR

		 // Aborta a exclusão em caso de erro no evento S-3000
		If nOpcx == 5 .And. !lRetEso
			DisarmTransaction()
		EndIf

	End Transaction

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} GravaMmry
Efetua gravacao do registro atual em memoria.

@type Function

@source MDTA180.prx

@param nOpcx, Numérico, Operacao atual.
@param [lMRiscos], Lógico, Define se a gravacao sera de multiplos riscos.
@param [lRiscEpi], Lógico, Verifica se terá cópias dos Epis
@param [lRiscExa], Lógico, verifica se terá cópias do Exames.
@param lAgenExa, Lógico, Indica se o agente possui exames vinculados e se deve ser vinculado ao risco

@return Nil

@sample GravaMmry( 3 , , , , .F. )

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function GravaMmry( nOpcx, lMRiscos, lCpyRisc, cTRBTAF, lRiscEpi, lRiscExa, lAgenExa )

	Local nFld
	Local nLin
	Local cField
	Local nPosMed
	Local cMedCtr
	Local nPosFld
	Local cKey
	Local lRiscMed   := NGCADICBASE( "TJF_NUMRIS", "A", "TJF", .F. ) // Verifica aplicacao de update
	Local lExcMNT902 := nOpcx == 5 .And. ( IsInCallStack( "MNTA902" ) .Or. IsInCallStack( "MNTA907" ) )
	Local lSigaMdtPs := SuperGetMv( "MV_MDTPS", .F., "N" ) == "S"
	Local lArvLoc    := IsInCallStack( "MNTA902" )
	Local lCodAmb    := NGCADICBASE( "TAF_CODAMB", "A", "TAF", .F. )
	Local aDadosPE1	 := {}
	Local aDadosPE2	 := {}

	cCliMdtPs := IIf( Type( "cCliMdtPs" ) == "C" .And. !Empty( cCliMdtPs ), cCliMdtPs, SA1->A1_COD + SA1->A1_LOJA )

	Default lMRiscos := .F.
	Default lCpyRisc := .F.
	Default lRiscEpi := .F.
	Default lRiscExa := .F.

	Begin Transaction

		// Se for uma inclusao ou uma copia, efetiva uso do codigo sequencial (SXE)
		If nOpcx == 3 .Or. lCpyRisc
			// Caso a memoria numero do risco esteja em branco, define numero sequencial
			If Empty( M->TN0_NUMRIS )
				M->TN0_NUMRIS := GetSxeNum( "TN0", "TN0_NUMRIS" ) // Gera novo codigo
			EndIf

			//Validacao de existência do codigo em base
			While MDTNumSQL( "TN0", "TN0_NUMRIS", M->TN0_NUMRIS )
				M->TN0_NUMRIS := GETSXENUM( "TN0", "TN0_NUMRIS" )
			End
			ConfirmSx8() // Confirma uso do codigo sequencial
		EndIf

		// Define chave de pesquisa para gravacao do(s) risco(s)
		If lSigaMdtps
			nOrd := 8
			cKey := xFilial( "TN0" ) + cCliMdtPs + M->TN0_NUMRIS
		Else
			nOrd := 1
			cKey := xFilial( "TN0" ) + M->TN0_NUMRIS
		EndIf

		If ExistBlock( "MDTA1802" )
			aAdd( aDadosPE1, nOpcx )
			ExecBlock( "MDTA1802", .F., .F., aDadosPE1 )
		EndIf

		// Grava registro do risco em memoria - Apenas se não for uma operação de exclusão, caso seja exclui o risco posteriormente
		If nOpcx != 5
			dbSelectArea( "TN0" )
			dbSetOrder( nOrd )
			If dbSeek( cKey )
				RecLock( "TN0", .F. )
			Else
				RecLock( "TN0", .T. )
			EndIf

			// Insere registro conforme memoria
			For nFld := 1 To Fcount()
				cField := "M->" + FieldName( nFld )
				If "_FILIAL" $ Upper( cField ) // Caso campo seja _FILIAL
					FieldPut( nFld, xFilial( "TN0" ) ) // Define como conteudo o termo xFilial()
				Else
					FieldPut( nFld, &cField. )
				EndIf
			Next nFld

			If ExistBlock( "MDTA1803" )
				aAdd( aDadosPE2, nOpcx )
				ExecBlock( "MDTA1803", .F., .F., aDadosPE2 )
			EndIf

			TN0->(MsUnLock())

			// Processo de gravacao do(s) risco(s)
			If lCpyRisc // Copia - Alterado Cópia para que seja anterior a propria gravação do Risco para consistências do TAF
				If lRiscEpi//Verifica se será copia os EPIs
					MDT180CREL( cRiscoAnt, M->TN0_NUMRIS, 1 ) //Funcao para copiar os EPIs relacionados
				EndIf
				If lRiscExa//Verifica se será copiado os Exames.
					MDT180CREL( cRiscoAnt, M->TN0_NUMRIS, 2 ) //Funcao para copiar os Exames relacionados
				EndIf
			ElseIf nOpcX == 3 .And. lAgenExa//Caso seja inclusão e o agente possua exames e for selecionado para gerar no risco
				MDT180EXAG( M->TN0_AGENTE, M->TN0_NUMRIS ) //Função para Gravar os Exames do Risco
			EndIf

			//Gravação de Memo
			If NGCADICBASE( "TN0_DANCAU", "D", "TN0", .F. )
				MSMM( , TAMSX3( "TN0_DANCAU" )[1], , M->TN0_DANCAU, 1, , , "TN0", "TN0_DANSYP" )
			EndIf
			If NGCADICBASE( "TN0_MSITUA", "D", "TN0", .F. )
				MSMM( , TAMSX3( "TN0_MSITUA" )[1], , M->TN0_MSITUA, 1, , , "TN0", "TN0_SITSYP" )
				MSMM( , TAMSX3( "TN0_MSITU2" )[1], , M->TN0_MSITU2, 1, , , "TN0", "TN0_SI2SYP" )
			EndIf
		EndIf

		// Verifica existencia de risco equivalente   # Inclui, Altera e Copia
		If nOpcx == 3 .Or. nOpcx == 4 .Or. lCpyRisc
			lVrfExRis := VrfExstRis( nOpcx, lVrfExRis, lMRiscos, lCpyRisc )
		EndIf

		// Caso o campo TJF_NUMRIS exista, verifica getdados referente a tabela TJF
		If lRiscMed
			If lExcMNT902
				nOrd   := 1
				cKey   := xFilial( "TJF" ) + TN0->TN0_NUMRIS
				cWhile := "TJF->TJF_FILIAL + TJF->TJF_NUMRIS"

				// Verifica registros retirados da getdados, existentes na tabela de Medida de Controle
				dbSelectArea( "TJF" )
				dbSetOrder( nOrd )
				If dbSeek( cKey )
					While !Eof() .And. cKey == &cWhile.
						RecLock( "TJF", .F. )
							dbDelete()
						TJF->(MsUnlock())
						dbSelectArea( "TJF" )
						dbSkip()
					End
				EndIf

			ElseIf Len( oGetWnd:aCols ) > 0

				aSort( oGetWnd:aCols, , , { |x, y| x[Len( oGetWnd:aCols[1] )] .And. !y[Len( oGetWnd:aCols[1] )] } ) // Ordena por itens deletados
				nPosMed := aScan( oGetWnd:aHeader, { |x| AllTrim( Upper( x[2] ) ) == "TJF_MEDCON" } ) // Verifica coluna do codigo(chave) da getdados

				If nPosMed > 0
					nOrd   := 1
					cKey   := xFilial( "TJF" ) + TN0->TN0_NUMRIS
					cWhile := "TJF->TJF_FILIAL + TJF->TJF_NUMRIS"

					// Verifica registros retirados da getdados, existentes na tabela de Medida de Controle
					dbSelectArea( "TJF" )
					dbSetOrder( nOrd )
					If dbSeek( cKey )
						While !Eof() .And. cKey == &cWhile.
							If aScan( oGetWnd:aCols, { |x| x[nPosMed] == TJF->TJF_MEDCON  } ) == 0
								RecLock( "TJF", .F. )
									dbDelete()
								TJF->(MsUnlock())
							EndIf
							dbSelectArea( "TJF" )
							dbSkip()
						End
					EndIf

					dbSelectArea( "TJF" )
					dbGoTop()

					// Percorre linhas da getdados
					For nLin := 1 To Len( oGetWnd:aCols )

						cMedCtr := oGetWnd:aCols[nLin][nPosMed] // Campo chave da tabela TJF na getdados

						// Se o registro nao estiver deletado e possuir conteudo valido
						If !oGetWnd:aCols[nLin][Len( oGetWnd:aCols[nLin] )] .And. !Empty( cMedCtr )

							dbSelectArea( "TJF" )
							dbSetOrder( nOrd )
							If dbSeek( cKey + cMedCtr )
								RecLock( "TJF", .F. )
							Else
								RecLock( "TJF", .T. )
							EndIf
								// Efetua gravacao do conteudo da linha da variavel aCols para a tabela TJF
								If nOpcx != 5
									For nFld := 1 to FCount()
										If "_FILIAL" $ Upper( FieldName( nFld ) ) // Filial
											FieldPut( nFld, xFilial( "TJF" ) )
										ElseIf "_NUMRIS" $ Upper( FieldName( nFld ) ) // Num. Risco
											FieldPut( nFld, TN0->TN0_NUMRIS )
										ElseIf lSigaMdtPs .And. "_CLIENT" $ Upper( FieldName( nFld ) ) // [Prestador] Cliente
											FieldPut( nFld, SA1->A1_COD )
										ElseIf lSigaMdtPs .And. "_LOJA" $ Upper( FieldName( nFld ) ) // [Prestador] Loja
											FieldPut( nFld, SA1->A1_LOJA )
										ElseIf (nPosFld := aScan( oGetWnd:aHeader, {|x| AllTrim( Upper( x[2] ) ) == AllTrim( Upper( FieldName( nFld ) ) ) } )) > 0
											FieldPut( nFld, oGetWnd:aCols[nLin][nPosFld] )
										EndIf
									Next nFld
								Else
									dbDelete() // Exclui registro atual
								EndIf
							TJF->(MsUnlock())

						ElseIf !Empty( cMedCtr ) // Se o registro estiver deletado e possuir conteudo valido

							dbSelectArea( "TJF" )
							dbSetOrder( nOrd )
							If dbSeek( cKey + cMedCtr )
								RecLock( "TJF", .F. )
									dbDelete()
								TJF->(MsUnlock())
							EndIf

						EndIf

					Next nLin
				EndIf
			EndIf
		EndIf

		// Vinculo do risco a Árvore lógica
		If ( !lArvLoc .Or. IsInCallStack( "MNTA905" ) ) .And. lCodAmb .And.  !lSigaMdtPs
			Mdt180AtAr( nOpcx, cTRBTAF )
		EndIf

		// Caso seja exclusão, efetiva o delete do risco
		// Risco não excluido anteriormente para integração com a exclusão no TAF ocorrer corretamente
		If nOpcx == 5

			dbSelectArea( 'TN0' )
			dbSetOrder( 1 )

			If dbSeek( xFilial( 'TN0' ) + M->TN0_NUMRIS )

				RecLock( 'TN0', .F. )

					TN0->( dbDelete() )

				TN0->( MsUnLock() )

			EndIf

		EndIf

	End Transaction

	( 'TMPA' )->( DbGoTop() )

	While !( 'TMPA' )->( Eof() )

		RecLock( 'TMPA', .F. )
			( 'TMPA' )->( DbDelete() )
		( 'TMPA' )->( MsUnlock() )

		( 'TMPA' )->( DbSkip() )

	End

	// Limpa conteudo da memoria do campo TN0_NUMRIS para possiveis gravacoes posteriores
	M->TN0_NUMRIS := ""

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} SetArrSlc
Seleciona registros marcados no markbrowse.

@type Function

@source MDTA180.prx

@param cField, Caracter, Campo a ser avaliado.

@return Array, Valor dos campos

@sample SetArrSlc( 'TN0_CC' )

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function SetArrSlc( cField )

	Local aArrSlc   := {}
	Local aEstTrb   := {}
	Local cAliasTrb := "" // Alias tabela temporaria
	Local aFldTrb   := {} // Campos tabela temporaria

	// Se o conteudo do campo for dIferente de '#'
	If AllTrim( &( "M->" + cField ) ) != "#"
		aAdd( aArrSlc, &( "M->" + cField ) )
	Else // Se o conteudo do campo for igual '#'

		// Seleciona estrutura da tabela  temporaria, conforme campo atual
		If cField == "TN0_CC" .And. Type( "aEst180CC" ) == "A"
			aEstTrb  := aClone( aEst180CC )
		ElseIf cField == "TN0_CODFUN" .And. Type( "aEst180Fun" ) == "A"
			aEstTrb  := aClone( aEst180Fun )
		ElseIf cField == "TN0_CODTAR" .And. Type( "aEst180Tar" ) == "A"
			 aEstTrb := aClone( aEst180Tar )
		ElseIf cField == "TN0_DEPTO" .And. Type( "aEst180Dpt" ) == "A"
			aEstTrb := aClone( aEst180Dpt )
		EndIf

		// Armazena no array de itens selecionados, os itens marcados na tabela temporaria
		If Len( aEstTrb ) > 0

			cAliasTrb := aEstTrb[2] // Alias temporario
			aFldTrb   := aEstTrb[4] // Campos tabela temporaria

			dbSelectArea( cAliasTrb )
			dbSetOrder( Len( aEstTrb[3] ) ) // Ultimo indice [Marcados]
			dbGoBottom()
			While !Bof() .And. !Empty( &(cAliasTrb + "->" + aFldTrb[1][1]) ) // Verifica registros marcados
				aAdd( aArrSlc, &(cAliasTrb + "->" + aFldTrb[2][1]) ) // Armazena codigo de referencia
				dbSelectArea( cAliasTrb )
				dbSkip( -1 )
			End
		EndIf

		dbSelectArea( cAliasTrb )
		dbSetOrder( 1 )

	EndIf

Return aArrSlc

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt180Vlf
Validacao final da tela de Riscos.

@type Function

@source MDTA180.prx

@param nOpx, Numérico, Variavel de controle da operacao selecionada.
@param aVarVld, Array, Variaveis de controle especificas.

@return Lógico, Indica consistência da validação

@sample Mdt180Vlf( 3 , {} )

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Function Mdt180Vlf( nOpx, aVarVld )

	Local lOk        := .T.
	Local lCodAmb    := NGCADICBASE( "TAF_CODAMB", "A", "TAF", .F. )
	Local lSigaMdtPs := SuperGetMv( "MV_MDTPS", .F., "N" ) == "S"
	Local aChkDelOld := IIf( Type( "aChkDel" ) == "A", aClone( aChkDel ), Nil )

	/*/---------------------------------------------------------------
	 aCHKDEL array que verifica a INTEGRIDADE REFERENCIAL na exclu-
	 são do registro.

	 1 - Chave de pesquisa
	 2 - Alias de pesquisa
	 3 - Ordem de pesquisa
	----------------------------------------------------------------/*/
	aCHKDEL := { {'TN0->TN0_NUMRIS', "TN2", 1 },;
	             {'TN0->TN0_NUMRIS', "TNJ", 1 },;
	             {'TN0->TN0_NUMRIS', "TNC", 2 },;
	             {'TN0->TN0_NUMRIS', "TO1", 2 },;
	             {'TN0->TN0_NUMRIS', "TNX", 1 },;
	             {'TN0->TN0_NUMRIS', "TO9", 1 },;
	             {'TN0->TN0_NUMRIS', "TMX", 2 } }
	If !(IsInCallStack( "MNTA902" ) .Or. IsInCallStack( "MNTA905" ) .Or. IsInCallStack( "MNTA907" ) ) .And. lCodAmb .And. !lSigaMdtPs
		aAdd( aCHKDEL, { "'7'+PADR( TN0->TN0_NUMRIS, TamSX3('TAF_CODCON')[1] ) + ' X '", "TAF", 10 } ) //TAF_FILIAL+TAF_INDCON+TAF_CODCON+TAF_MODMNT+TAF_MODMDT+TAF_MODSGA
	EndIf

	// Se for exclusao
	If nOpx == 5

		lOk := NGCHKDEL( "TN0" ) .And. CHKTA180( 2 )

	ElseIf nOpx != 2 // Se nao for visualizacao

		lOk := ( !aVarVld[1] .Or. MDT180MLOK( .T. ) ) .And. Obrigatorio( aGets, aTela )

		// Se a validacao geral da tela foi executada corretamente, e se a operacao e de inclusao ou alteracao
		If lOk .And. (nOpx == 3 .Or. nOpx == 4 )
			lOk := CHKTA180( 1, nOpx )
		EndIf

		// Verifica mudanca do agente, para relacao de Produto Quimico x Risco
		If lOk
			lOk := MDT180MuAg()
		EndIf

		//--------------------------------------------------------------------------------------
		// Caso houver integração com o eSocial, verifica se o campo TN0_DTAVAL está preenchido
		//--------------------------------------------------------------------------------------
		If lOk
			lOk := fVldDtAval()
		EndIf

		//-------------------------------------------------------------------------------------
		// Realiza as validações das informações do evento S-2240 que serão enviadas ao Governo
		//-------------------------------------------------------------------------------------
		If lOk .And. FindFunction( "MDTIntEsoc" )
			lOk := fRisS2240( nOpx, .F. )
		EndIf
	EndIf

	If Type( "aChkDelOld" ) == "A"
		aChkDel := aClone( aChkDelOld )
	EndIf

Return lOk

//---------------------------------------------------------------------
/*/{Protheus.doc} VrfExstRis
Verifica se o risco ja existe, e questiona sua eliminacao (Dt. Eliminacao).

@type Function

@source MDTA180.prx

@param nOpcx, Numérico, Operacao efetuada.
@param lPrAnswer, Lógico, Parametro de resposta para possivel inconsistencia encontrada.
@param lMRiscos, Lógico, Define se a operacao e para multiplos riscos.
@param [lCpyRisc], Lógico, Indica que é copia

@return Lógico, Indica existência de risco

@sample VrfExstRis( 3 , .T. , .T. )

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function VrfExstRis( nOpcx, lPrAnswer, lMRiscos, lCpyRisc )

	Local cKey
	Local cWhile
	Local nOrd
	Local lPrAnsw := ValType( lPrAnswer ) == "L"    // Se a resposta foi repassada
	Local lAnswer := IIf( lPrAnsw, lPrAnswer, .F. ) // Resposta repassada

	Default lCpyRisc := .F.

	// Se ja houve resposta e foi negativa
	If lPrAnsw .And. !lAnswer
		Return .F.
	EndIf

	If nOpcx == 4 .And. Empty( M->TN0_DTELIM )
		DtValida := .T.
	EndIf

	// Se a data de avaliacao esta preenchida, e se deve verificar a mesma
	If !Empty( TN0->TN0_DTAVAL ) .And. DtValida

		cTN0_CC     := TN0->TN0_CC
		cTN0_CODFUN := TN0->TN0_CODFUN
		cTN0_CODTAR := TN0->TN0_CODTAR
		cTN0_DEPTO	:= TN0->TN0_DEPTO
		cTN0_AGENTE := TN0->TN0_AGENTE
		cTN0_FONTE  := TN0->TN0_FONTE
		dTN0_DTREC	:= TN0->TN0_DTRECO
		dTN0_DTAVAL := TN0->TN0_DTAVAL

		nRecnoTN0   := TN0->(Recno())
		aAreaTN0    := TN0->(GetArea())

		If lSigaMdtPs
			nOrd   := NGRETORDEM( "TN0", "TN0_FILIAL+TN0_CODCLI+TN0_LOJACL+TN0_CC+TN0_CODFUN+TN0_CODTAR", .T. )
			cKey   := xFilial( "TN0" ) + cCliMdtPs + cTN0_CC + cTN0_CODFUN + cTN0_CODTAR
			cWhile := "TN0->TN0_FILIAL + TN0->TN0_CODCLI + TN0->TN0_LOJACL + TN0->TN0_CC + TN0->TN0_CODFUN + TN0->TN0_CODTAR"
		Else
			nOrd   := 5
			cKey   := xFilial( "TN0" ) + cTN0_CC + cTN0_CODFUN + cTN0_CODTAR + cTN0_DEPTO
			cWhile := "TN0->TN0_FILIAL + TN0->TN0_CC + TN0->TN0_CODFUN + TN0->TN0_CODTAR + TN0_DEPTO"
		EndIf

		If nOrd > 0
			dbSelectArea( "TN0" )
			dbSetOrder( nOrd )
			dbSeek( cKey )
			While !Eof() .And. cKey == &cWhile.
				If nRecnoTN0 != TN0->(Recno()) .And. cTN0_AGENTE == TN0->TN0_AGENTE .And. ;
					cTN0_FONTE == TN0->TN0_FONTE .And. Empty( TN0->TN0_DTELIM )

					cMsg := STR0013 //"Deseja que o risco anterior seja eliminado, utilizando apenas o risco que foi incluido agora?"
					If nOpcx == 4 .Or. lCpyRisc
						cMsg := STR0014  //"Deseja que o risco anterior seja eliminado, utilizando apenas o risco que foi alterado agora?"
					EndIf

					// Se ja houve resposta e afirmativa, ou se ainda nao houve resposta
					If (lPrAnsw .And. lAnswer) .Or. !lPrAnsw

						// Se nao houve resposta
						If !lPrAnsw
							If !lMRiscos // Se a operacao nao e de multiplos riscos
								lAnswer :=	MsgYesNo( STR0015 + " " + cMsg + ;		             //"Já existe risco para este ambiente.
												CRLF + CRLF + ;
												STR0016 + CRLF + ;					             //"Dados do risco encontrado"
												"-" + STR0017 + TN0->TN0_NUMRIS + CRLF + ;       //"Numero Risco: "
												"-" + STR0018 + TN0->TN0_CC + ;		             //"Centro de Custo: "
												CRLF + "-" + STR0113 + TN0->TN0_DEPTO + CRLF + ; //"Departamento:"
												"-" + STR0019 + TN0->TN0_CODFUN + CRLF + ;	     //"Função: "
												"-" + STR0020 + TN0->TN0_CODTAR + CRLF + ;	     //"Tarefa: "
												"-" + STR0021 + TN0->TN0_AGENTE + CRLF + ;	     //"Agente: "
												"-" + STR0022 + TN0->TN0_FONTE + CRLF + ;	     //"Fonte Geradora: "
												"-" + STR0023 + Transform( TN0->TN0_QTAGEN, "@E 99,999,999.999" ) + ; //"Quantidade: "
												" " + TN0->TN0_UNIMED + CRLF + ;
												"-" + STR0024 + DTOC( TN0->TN0_DTAVAL ) )  		 //"Data Avaliação: "
							Else // Se a operacao e de multiplos riscos
								lAnswer := MsgYesNo( STR0052 + CRLF + cMsg ) // "Já existe(m) risco(s) para este ambiente."
							EndIf
						EndIf

						// Se a resposta for afirmativa
						If lAnswer
							RecLock( "TN0", .F. )
								// Se for a mesma Data de Reconhecimento, indica
								// que se trata do mesmo risco (ou copia), gerando a eliminação
								// pela avaliação
								If TN0->TN0_DTRECO == dTN0_DTREC .And. ;
									!Empty( dTN0_DTAVAL )
									TN0->TN0_DTELIM := IIf( TN0->TN0_DTRECO <= dTN0_DTAVAL, dTN0_DTAVAL, TN0->TN0_DTRECO )
								Else
									TN0->TN0_DTELIM := IIf( TN0->TN0_DTRECO <= dTN0_DTREC, dTN0_DTREC, TN0->TN0_DTRECO )
								EndIf
							TN0->(MsUnLock())
						EndIf

						Exit
					EndIf
				EndIf

				dbSelectArea( "TN0" )
				dbSkip()
			End
		EndIf

		RestArea( aAreaTN0 )
	EndIf

Return lAnswer

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt180GPQ
Efetua gravacao do relacionamento entre Risco x Produto Quimico.

@type Function

@source MDTA180.prx

@param nOpcx, Numérico, Operacao atual.
@param [cRisKey], Caracter, Chave do Risco
@param [lCpyRisco], Lógico, Indica se é copia

@return Nulo

@sample Mdt180GPQ( 3 )

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function Mdt180GPQ( nOpcx, cRisKey, lCpyRisc )

	Local nLine
	Local nField
	Local nPosFld
	Local cKey
	Local nOrd
	Local cWhile

	Local nCodPro    := 0
	Local lNoChange  := Len( aHead180PQ ) == 0
	Local lAgntQmc   := NGSEEK( "TMA", TN0->TN0_AGENTE, 1, "TMA_GRISCO" ) == "2"
	Local lSigaMdtPs := SuperGetMv( "MV_MDTPS", .F., "N" ) == "S"

	Default cRisKey  := TN0->TN0_NUMRIS
	Default lCpyRisc := .F.

	// Se o usuario nao acessou a tela de Prod. Quim. e a operacao nao for de exclusao ou de copia
	If ( !lAgntQmc .And. nOpcx != 4 ) .Or. (lNoChange .And. !( Str( nOpcx, 1 ) $ "5/7" ) .And. (nOpcx != 4 .Or. lAgntQmc) )
		Return
	EndIf

	If lCpyRisc .And. lNoChange
		SelPQKeyAt( nOpcx, cRisKey, lCpyRisc )
	EndIf

	// Se for estiver como prestador de servico
	If lSigaMdtps
		nOrd   := 3
		cKey   := xFilial( "TJD" ) + cCliMdtPs + TN0->TN0_NUMRIS
		cWhile := "TJD->TJD_FILIAL + TJD->TJD_CLIENT + TJD->TJD_LOJA + TJD->TJD_NUMRIS"
	Else
		nOrd   := 1
		cKey   := xFilial( "TJD" ) + TN0->TN0_NUMRIS
		cWhile := "TJD->TJD_FILIAL + TJD->TJD_NUMRIS"
	EndIf

	nCodPro := aScan( aHead180PQ, { |x| AllTrim( x[2] ) == "TJD_CODPRO" } ) // Codigo do Produto Quimico

	// Verifica registros excluidos no processo atual
	If !lCpyRisc
		dbSelectArea( "TJD" )
		dbSetOrder( nOrd )
		If dbSeek( cKey )
			While !Eof() .And. cKey == &cWhile.
				If (nOpcx == 5 .Or. !lAgntQmc) .Or. ( aScan( aCols180PQ, { |x| AllTrim( x[nCodPro] ) == AllTrim( TJD->TJD_CODPRO ) } ) == 0 )
					RecLock( "TJD", .F. )
						dbDelete()
					TJD->(MsUnlock())
				EndIf
				dbSelectArea( "TJD" )
				dbSkip()
			End
		EndIf
	EndIf

	dbSelectArea( "TJD" )
	dbGoTop()

	// Percorre acols, efetivando gravacao/atualizacao dos registros
	If nOpcx != 5 .And. lAgntQmc
		For nLine := 1 To Len( aCols180PQ )

			If Empty( aCols180PQ[nLine][nCodPro] )
				Loop
			EndIf

			dbSelectArea( "TJD" )
			dbSetOrder( nOrd )
			If dbSeek( cKey + aCols180PQ[nLine][nCodPro] )
				RecLock( "TJD", .F. )
			Else
				RecLock( "TJD", .T. )
			EndIf
				For nField := 1 To FCount()
					If "_FILIAL" $ Upper( FieldName( nField ) ) // Filial
						FieldPut( nField, xFilial( "TJD" ) )
					ElseIf "_NUMRIS" $ Upper( FieldName( nField ) ) // Num. Risco
						FieldPut( nField, TN0->TN0_NUMRIS )
					ElseIf lSigaMdtPs .And. "_CLIENT" $ Upper( FieldName( nField ) ) // [Prestador] Cliente
						FieldPut( nField, SA1->A1_COD )
					ElseIf lSigaMdtPs .And. "_LOJA" $ Upper( FieldName( nField ) ) // [Prestador] Loja
						FieldPut( nField, SA1->A1_LOJA )
					ElseIf (nPosFld := aScan( aHead180PQ, { |x| AllTrim( Upper( x[2] ) ) == AllTrim( Upper( FieldName( nField ) ) ) } ) ) > 0
						FieldPut( nField, aCols180PQ[nLine][nPosFld] )
					EndIf
				Next nField
			TJD->(MsUnlock())


		Next nLine
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt180WfLa
Verificação para eliminação de risco com adcional de insalubridade
ou periculosidade em folha. Caso tenha laudo vigente, envia email
avisando ao RH

@type Function

@source MDTA180.prx

@return Lógico, Sempre verdadeiro

@sample Mdt180WfLa()

@author Thiago Henrique dos Santos
@since 12/07/2013
/*/
//---------------------------------------------------------------------
Static Function Mdt180WfLa()

	Local aLaudo   := {}
	Local aFuncExp := {}
	Local nI       := 0

	If !Empty( M->TN0_DTELIM ) .And. Empty( TN0->TN0_DTELIM ) .And. TN0->TN0_ADIFOL == "1"
		//Apenas laudos válidos
		dbSelectArea( "TO1" ) //Laudos x Riscos
		TO1->(dbSetOrder( 2 ))
		TO1->(dbSeek( xFilial( "TO1" ) + TN0->TN0_NUMRIS ))

	  	aLaudo := {}

		While TO1->(!Eof()) .And. TO1->TO1_FILIAL == xFilial( "TO1" ) .And. TO1->TO1_NUMRIS == TN0->TN0_NUMRIS
			dbSelectArea( "TO0" )
			TO0->(dbSetOrder( 1 ))
			If TO0->(dbSeek( xFilial( "TO0" ) + TO1->TO1_LAUDO ))
				If Empty( TO0->TO0_DTVALI ) .Or. !Empty( TO0->TO0_DTVALI ) .And. TO0->TO0_DTVALI > M->TN0_DTELIM
					aAdd( aLaudo, TO1->TO1_LAUDO )
				EndIf
			EndIf

			TO1->(DbSkip())

		Enddo

		If !Empty( aLaudo )
			For nI := 1 To Len( aLaudo )
				dbSelectArea( "TJ0" )
				TJ0->(dbSetOrder( 1 ) ) //TJ0_FILIAL+TJ0_LAUDO+TJ0_NUMRIS+TJ0_MAT
				TJ0->(dbSeek( xFilial( "TJ0" ) + aLaudo[nI] + TN0->TN0_NUMRIS ))

				While TJ0->(!Eof()) .And. TJ0->TJ0_FILIAL == xFilial( "TJ0" ) .And. TJ0->TJ0_LAUDO == aLaudo[nI] .And. TJ0->TJ0_NUMRIS == M->TN0_NUMRIS
					If TJ0->TJ0_CONFEX == "1" .And. TJ0->TJ0_PERFOL != 0 .And.;
					 (Empty( TJ0->TJ0_DTFIEX ) .Or. !Empty( TJ0->TJ0_DTFIEX ) .And. TJ0->TJ0_DTFIEX > M->TN0_DTELIM)

						aAdd( aFuncExp, { TJ0_MAT, TJ0->TJ0_PERFOL, TJ0->TJ0_DTINEX } )

					EndIf

					TJ0->(DbSkip())
				Enddo
			Next nI

			If Len( aFuncExp ) > 0
				If PERGUNTE( "MDTA215" )
					PROCESSA( { || MDT180MAIL( aFuncExp ) }, STR0083 ) //"Enviando Email"
				EndIf
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt180AtAr
Função de atribuição do risco na Árvore lógica.

@type Function

@source MDTA180.prx

@param nOpcx, Numérico, Indica a operação
@param cTRBTAF, Caracter, Tabela da TRB utilizada na estrutura da Arvore Lógica

@return Nil

@sample Mdt180AtAr( 3 , 'SGC0001' )

@author Guilherme Benkendorf
@since 13/05/2014
/*/
//---------------------------------------------------------------------
Static Function Mdt180AtAr( nOpcx, cTRBTAF )

	Local cCodEst
	Local cLocal
	Local cCodNiv
	Local cCodRis
	Local cDesPro
	Local cHora
	Local nLevel
	Local lTabTemp   := .F.
	Local cQryAls	 := GetNextAlias()
	Local nTamFun    := Len( TN0->TN0_CODFUN )
	Local nTamTar    := Len( TN0->TN0_CODTAR )
	Local aArea      := GetArea()
	Local cUnidRisco := Posicione( "V3F", 2, xFilial( "V3F" ) + TN0->TN0_UNIMED, "V3F_DESCRI" )

	dbSelectArea( "TAF" )
	dbSetOrder( 10 )//TAF_FILIAL+TAF_INDCON+TAF_CODCON+TAF_MODMNT+TAF_MODMDT+TAF_MODSGA
   	// Inclui nivel na arvore logica quando nao foi ja adcionada a estrutura e a data de avalicao deve estar preenchida
	If !dbSeek( xFilial( "TAF" ) + "7" + PADR( TN0->TN0_NUMRIS, Len( TAF->TAF_CODCON ) ) + " X " ) .And. Empty( TN0->TN0_DTELIM )
		cCodRis := TN0->TN0_NUMRIS
		cDesPro := NGSeek( "TMA", TN0->TN0_AGENTE, 1, "TMA_NOMAGE" )
		cHora   := Substr( Time(), 1, 5 )

		dbSelectArea( "TAF" )
		dbSetOrder( 2 )
		dbGoBottom()
		cLocal := TAF->TAF_CODNIV
		If !Empty( cTRBTAF ) .And. Select( cTRBTAF ) > 0
			dbSelectArea( cTRBTAF )
			dbSetOrder( 2 )
			dbGoBottom()
			cLocal   := IIf( cLocal > (cTRBTAF)->CODPRO, TAF->TAF_CODNIV, (cTRBTAF)->CODPRO )
			lTabTemp := .T.
		EndIf

		If FindFunction( "Soma1Old" )
			cLocal := Soma1Old( AllTrim( cLocal ) )
		Else
			cLocal := Soma1( AllTrim( cLocal ) )
		EndIf

		cCodEst := "001"
		cCodNiv := cLocal
		//Pega o Nivel conforme posicionamento da TRB
		nLevel  :=  IIf( lTabTemp, (cTRBTAF)->NIVEL, TAF->TAF_NIVEL )

		// A atribuição do risco a Árvore lógica só poderá orrocorrer quando for informado a data de avaliação.
		If nOpcx == 3 .Or. nOpcx == 4 .Or. nOpcx == 7 //Inclusão ou Cópia.

			lLocaliz := .F.
			cNivelSup := ""
			nCnt := 1
			If Alltrim( TN0->TN0_CC ) != "*"
				cDepto := Space( Len( TN0->TN0_DEPTO ) )
				If Alltrim( TN0->TN0_DEPTO ) != "*"
					cDepto := TN0->TN0_DEPTO
				EndIf

				BeginSQL Alias cQryAls
					SELECT TAF_CODNIV FROM %Table:TAF% WHERE TAF_FILIAL = %xFilial:TAF% 	AND
													TAF_CODEST = %Exp:cCodEst% 	            AND
													TAF_CCUSTO = %Exp:TN0->TN0_CC% 			AND
													TAF_CODAMB = %Exp:TN0->TN0_CODAMB%		AND
													TAF_DEPTO = %Exp:TN0->TN0_DEPTO%		AND
													%notDel%
						ORDER BY TAF_FILIAL, TAF_CODEST, TAF_CCUSTO, TAF_CODAMB, TAF_DEPTO
				EndSQL

				If ( cQryAls )->( !EoF() )
					cNivelSup := ( cQryAls )->TAF_CODNIV
					lTermino := Alltrim( TN0->TN0_CODFUN ) == "*" .And. Alltrim( TN0->TN0_CODTAR ) == "*"
				Else
					lTermino := .T.
				EndIf
				( cQryAls )->( dbCloseArea() )
			Else
				If Alltrim( TN0->TN0_DEPTO ) != "*"

					BeginSQL Alias cQryAls
						SELECT TAF_CODNIV FROM %Table:TAF% WHERE TAF_FILIAL = %xFilial:TAF%  AND
														   TAF_CODEST = %Exp:cCodEst% 		 AND
														   TAF_CCUSTO = %Exp:TN0->TN0_CC% 	 AND
														   TAF_DEPTO  = %Exp:TN0->TN0_DEPTO% AND
														   %notDel%
							ORDER BY TAF_FILIAL, TAF_CODEST, TAF_CCUSTO, TAF_DEPTO
					EndSQL

					If ( cQryAls )->( !EoF() )
						cNivelSup := ( cQryAls )->TAF_CODNIV
						lTermino := Alltrim( TN0->TN0_CODFUN ) == "*" .And. Alltrim( TN0->TN0_CODTAR ) == "*"
					Else
						lTermino := .T.
					EndIf
					( cQryAls )->( dbCloseArea() )
				Else
					dbSelectArea( 'TAF' )
					dbSetOrder( 1 ) //TAF_FILIAL+TAF_CODEST+TAF_NIVSUP+TAF_ORDEM
					If dbSeek( xFilial( 'TAF' ) + '001' + '000' ) //Se existir o primeiro nível
						cNivelSup := '001'
					EndIf
					lTermino := Alltrim( TN0->TN0_CODFUN ) == "*" .And. Alltrim( TN0->TN0_CODTAR ) == "*"
				EndIf
			EndIf

			While !lTermino

				lLocaliz := .F.

				If nCnt == 1 .And. AllTrim( TN0->TN0_CODFUN ) == "*"
					nCnt++
				EndIf

				dbSelectArea( "TAF" )
				dbSetOrder( 1 ) //TAF_FILIAL+TAF_CODEST+TAF_NIVSUP+TAF_ORDEM
				dbSeek( xFilial( "TAF" ) + cCodEst + cNivelSup )
				While TAF->( !Eof() ) .And. xFilial( "TAF" ) == TAF->TAF_FILIAL .And.;
						TAF->TAF_CODEST == cCodEst .And. TAF->TAF_NIVSUP == cNivelSup

					If nCnt == 1
						If TAF->TAF_INDCON = '3' .And. SubStr( TAF->TAF_CODCON, 1, nTamFun ) == TN0->TN0_CODFUN
							cNivelSup := TAF->TAF_CODNIV
							lLocaliz := .T.
						EndIf
					Else
						If TAF->TAF_INDCON = '4' .And. SubStr( TAF->TAF_CODCON, 1, nTamTar ) == TN0->TN0_CODTAR
							cNivelSup := TAF->TAF_CODNIV
							lLocaliz := .T.
						EndIf
					EndIf

					TAF->( dbSkip() )
				End

				If !lLocaliz
					lTermino  := .T.
					cNivelSup := ""
				Else
					If nCnt == 1 .And. Alltrim( TN0->TN0_CODTAR ) == "*"
						lTermino := .T.
					ElseIf nCnt == 2
						lTermino := .T.
					Else
						nCnt++
					EndIf
				EndIf

			End

			If IsInCallStack( "MNTA905" ) .Or.( !Empty( cNivelSup ) .And.;
				 MsgYesNo( STR0103 + CRLF + CRLF +;                        //"Deseja incluir este risco como nível na estrutura ?"
						 STR0016 + CRLF + ;						           //"Dados do risco encontrado"
						 "- " + STR0017 + TN0->TN0_NUMRIS + CRLF + ;	   //"Numero Risco: "
						 "- " + STR0018 + TN0->TN0_CC + ;		           //"Centro de Custo: "
						 CRLF + "- " + STR0113 + TN0->TN0_DEPTO + CRLF + ; //"Departamento:"
						 "- " + STR0019 + TN0->TN0_CODFUN + CRLF + ;	   //"Função: "
						 "- " + STR0020 + TN0->TN0_CODTAR + CRLF + ;	   //"Tarefa: "
						 "- " + STR0021 + TN0->TN0_AGENTE + CRLF + ;	   //"Agente: "
						 "- " + STR0022 + TN0->TN0_FONTE + CRLF + ;	       //"Fonte Geradora: "
						 "- " + STR0023 + Transform( TN0->TN0_QTAGEN, "@E 99,999,999.999" ) + ; //"Quantidade: "
						 " " + cUnidRisco + CRLF + "- " + STR0024 + DTOC( TN0->TN0_DTAVAL ),;   //"Data Avaliação: "
						 STR0104 ) )	                                                        //"Inclusão na Árvore Lógica"
				//---------------------------------------------------------------
				// Grava Inclusao do Item na tabela de Historico de Movimentacao
				//---------------------------------------------------------------
				If NGCADICBASE( "TCJ_CODNIV", "D", "TCJ", .F. )
					dbSelectArea( "TCJ" )
					dbSetOrder( 1 ) //TCJ_FILIAL+TCJ_CODNIV+TCJ_NIVSUP+TCJ_TIPROC+DTOS(TCJ_DATA)+TCJ_HORA
					If !dbSeek( xFilial( "TCJ" ) + cCodNiv + cNivelSup + 'N' + DTOS( dDataBase ) + cHora )
						RecLock( "TCJ", .T. )
							TCJ->TCJ_FILIAL := xFilial( "TCJ" )
							TCJ->TCJ_CODNIV := cCodNiv
							TCJ->TCJ_DESNIV := cCodRis + " - " + cDesPro
							TCJ->TCJ_NIVSUP := cNivelSup
							TCJ->TCJ_DATA   := dDataBase
							TCJ->TCJ_HORA   := cHora
							TCJ->TCJ_TIPROC := "N" //Inclusao
							TCJ->TCJ_NIVEL  := nLevel + 1
							TCJ->TCJ_MODMDT := "X"
						MsUnLock( "TCJ" )
					EndIf
				EndIf

				RecLock( "TAF", .T. )
				TAF->TAF_CODNIV := cLocal
				TAF->TAF_ORDEM  := cLocal
				TAF->TAF_FILIAL := xFilial( 'TAF' )
				TAF->TAF_CODEST := cCodEst
				TAF->TAF_NOMNIV := cCodRis + " - " + cDesPro
				TAF->TAF_NIVEL  := nLevel + 1
				TAF->TAF_NIVSUP := cNivelSup
				TAF->TAF_INDCON := "7" //Risco
				TAF->TAF_CODCON := cCodRis
				TAF->TAF_MODMDT := "X"
			EndIf
		EndIf
	//Se o Risco não for mais ativo, ser feito a exclusão na estrutura da Arvore
	ElseIf nOpcx == 5 .Or. !Empty( TN0->TN0_DTELIM )
		dbSelectArea( "TAF" )
		dbSetOrder( 10 ) //TAF_FILIAL+TAF_INDCON+TAF_CODCON+TAF_MODMNT+TAF_MODMDT+TAF_MODSGA
		If dbSeek( xFilial( "TAF" ) + "7" + PadR( TN0->TN0_NUMRIS, Len( TAF->TAF_CODCON ) ) + " X " )
			RecLock( 'TAF', .F. )
				dbDelete()
			TAF->( MsUnLock() )
		EndIf
	EndIf

	RestArea( aArea )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180BRW
Inicializa o browse

@type Function

@source MDTA180.prx

@param lIniBrw, Lógico, Indica se é inicializador de Browse ou relação.
@param nCampo, Numérico, Indica o campo a ser executado

@return cDesc, Caracter, Valor da descrição

@sample MDT180BRW( .F. )

@author Denis Hyroshi Souza
@since 29/10/02
/*/
//---------------------------------------------------------------------
Function MDT180BRW( lIniBrw, nCampo )

	Local cDesc
	Local cAlias := "SI3"
	Local cDescr := "I3_DESC"
	Local aArea  := GetArea()

	Default nCampo := 1 //TN0_CC

	If Alltrim( GetMv( "MV_MCONTAB" ) ) == "CTB"
		cAlias := "CTT"
		cDescr := "CTT_DESC01"
	EndIf

	If nCampo == 1 //TN0_CC
		cValCampo := IIf( lIniBrw, TN0->TN0_CC, M->TN0_CC )
	ElseIf nCampo == 2 //TN0_DEPTO
		cValCampo := IIf( lIniBrw, TN0->TN0_DEPTO, M->TN0_DEPTO )
		cAlias    := "SQB"
		cDescr    := "QB_DESCRIC"
	EndIf

	If Alltrim( cValCampo ) == "*"
		cDesc := STR0025  //"TODOS"
	Else
		cDesc := Posicione( cAlias, 1, xFilial( cAlias ) + cValCampo, cDescr )
	EndIf

	RestArea( aArea )

Return cDesc

//---------------------------------------------------------------------
/*/{Protheus.doc} A180DESTIN
Troca F3 campo TN0_CC

@type Function

@source MDTA180.prx

@return Lógico, Retorna .T. quando risco avaliado e .F. quando não avaliado

@sample A180DESTIN()

@author Denis Hyroshi de Souza
@since 18/08/03
/*/
//---------------------------------------------------------------------
Function A180DESTIN()

	Local aArea := GetArea()

	aTROCAF3 := {}

	If Alltrim( GetMv( "MV_MCONTAB" ) ) == "CTB"
		If lSigaMdtps
			aAdd( aTROCAF3, { "TN0_CC", "MDTPS6" } )
		Else
			aAdd( aTROCAF3, { "TN0_CC", "CTT" } )
		EndIf
	Else
		If lSigaMdtps
			aAdd( aTROCAF3, { "TN0_CC", "MDTPS4" } )
		Else
			aAdd( aTROCAF3, { "TN0_CC", "SI3" } )
		EndIf
	EndIf

	RestArea( aArea )

Return DTVALIDA

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180ZZIB
Inicializa o browse do campo TN0_NOMPOS

@type Function

@source MDTA180.prx

@return Caracter, Retorna descrição do posto

@sample MDT180ZZIB()

@author Andre E. Perez Alvarez
@since 22/03/05
/*/
//---------------------------------------------------------------------
Function MDT180ZZIB()

	Local aArea  := GetArea()
	Local cDesc  := " "

	If Alltrim( TN0->TN0_CODPOS ) == "*"
		cDesc := STR0025  //"TODOS"
	Else
		cDesc := Posicione( "ZZI", 1, xFilial( "ZZI" ) + TN0->TN0_CODPOS, "ZZI_DESC" )
	EndIf

	RestArea( aArea )

Return cDesc

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180EPI
Relaciona os EPI's ao risco

@type Function

@source MDTA180.prx

@param cAlias, Caracter, Área de Trabalho
@param nReg, Numérico, Número único do registro
@param nOpcx, Numérico, Valor da operação

@return Lógico, Sempre verdadeiro

@sample MDT180EPI( 'TN0' , 0 , 4 )

@author Liber De Esteban
@since 02/08/05
/*/
//---------------------------------------------------------------------
Function MDT180EPI( cAlias, nReg, nOpcx )

	oldaRotina   := aRotina
	oldaSMENU    := aSMENU
	oldaCHKDEL   := aCHKDEL
	oldbNGGRAVA  := bNGGRAVA
	oldcCadastro := cCadastro

	aRELAC := {  { "TNX_NUMRIS", "TN0->TN0_NUMRIS" },;
				 { "TNX_AGENTE", "TN0->TN0_AGENTE" },;
				 { "TNX_NOMAGE", "NGSeek('TMA',TN0->TN0_AGENTE,1,'TMA->TMA_NOMAGE')" } }

	If lSigamdtps
		aAdd( aRELAC, { "TNX_CLIENT", "SA1->A1_COD" } )
		aAdd( aRELAC, { "TNX_LOJA", "SA1->A1_LOJA" } )
	EndIf

	MDT125EPI( cAlias, nReg, nOpcx )

	aRELAC    := {}
	aRotina   := oldaRotina
	aSMENU    := oldaSMENU
	aCHKDEL   := oldaCHKDEL
	bNGGRAVA  := oldbNGGRAVA
	cCadastro := oldcCadastro

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180EXAME
Relaciona os exames ao risco

@type Function

@source MDTA180.prx

@return Lógico, Sempre verdadeiro

@sample MDT180EXAME()

@author Liber De Esteban
@since 02/08/05
/*/
//---------------------------------------------------------------------
Function MDT180EXAME()

	oldaRotina   := aRotina
	oldaSMENU    := aSMENU
	oldaCHKDEL   := aCHKDEL
	oldbNGGRAVA  := bNGGRAVA
	oldcCadastro := cCadastro

	aRELAC := {  { "TN2_NUMRIS", "TN0->TN0_NUMRIS" },;
				 { "TN2_AGENTE", "TN0->TN0_AGENTE" },;
				 { "TN2_NOMAGE", "NGSeek('TMA',TN0->TN0_AGENTE,1,'TMA->TMA_NOMAGE')" } }

	cRiscsalvo := TN0->TN0_NUMRIS
	dbSelectArea( "TN2" )
	If lSigaMdtps
		MDT180TN2()
	Else
		Set Filter To TN2->TN2_FILIAL == xFilial( "TN2" ) .And. TN2->TN2_NUMRIS == cRiscsalvo
		MDTA185()
	EndIf

	dbSelectArea( "TN2" )
	Set Filter To

	aRELAC := {}
	aRotina   := oldaRotina
	aSMENU    := oldaSMENU
	aCHKDEL   := oldaCHKDEL
	bNGGRAVA  := oldbNGGRAVA
	cCadastro := oldcCadastro

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180Leg
Cria uma janela contendo a legenda da mBrowse

@type Function

@source MDTA180.prx

@return Lógico, Sempre verdadeiro

@sample MDT180Leg()

@author Andre E. Perez Alvarez
@since 02/01/06
/*/
//---------------------------------------------------------------------
Function MDT180Leg()

	BrwLegenda( OemtoAnsi( STR0006 ),; 	                     //"Riscos"
				 OemToAnsi( STR0009 ),;                       //"Situação do risco"
				 { { "BR_VERDE", OemToAnsi( STR0010 ) },;	 //"Ativo (não-eliminado)"
				 {   "BR_VERMELHO", OemToAnsi( STR0011 ) },; //"Inativo (eliminado)"
				 {   "BR_AZUL", OemToAnsi( STR0073 ) } } )   //"Risco com agente insalubre/perigoso"


Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180EXAME
Funcao p/ definir cores p/ as situacoes dos riscos

@type Function

@source MDTA180.prx

@return Array, Informações de semáforo

@sample RiscoCor()

@author Andre E. Perez Alvarez
@since 02/01/06
/*/
//---------------------------------------------------------------------
Function RiscoCor()

	Local aCORES

	aCORES := {  { "NgSemafaro('SubStr(DtoC(TN0->TN0_DTELIM),1,1) == Space(1) .And. MDT180ALL(1)')", "BR_VERDE" },;
				 { "NgSemafaro('SubStr(DtoC(TN0->TN0_DTELIM),1,1) <> Space(1) ')", "BR_VERMELHO" },;
				 { "NgSemafaro('SubStr(DtoC(TN0->TN0_DTELIM),1,1) == Space(1) .And. MDT180ALL(2)')", "BR_AZUL" } }

Return aCores

//---------------------------------------------------------------------
/*/{Protheus.doc} CHKTA180
Validacao no momento da exclusao

@type Function

@source MDTA180.prx

@param nTipoMov, Numérico, Indica se é exclusão (2) ou outra operação (1)
@param nOpcx, Numérico, Indica a operação

@return Lógico, Indica se é permitida executar a operação

@sample CHKTA180( 1 , 3 )

@author Denis Hyroshi de Souza
@since
/*/
//---------------------------------------------------------------------
Function CHKTA180( nTipoMov, nOpcx )

	Local lRet     := .T.
	Local aArea    := GetArea()
	Local lTabObra := .F.
	Local lCodAmb  := NGCADICBASE( "TAF_CODAMB", "A", "TAF", .F. )
	Local lVerif   := .F.

	Default nOpcx := 3

	If nOpcx != 4 .And. nOpcx != 3 .And. nTipoMov == 2
		dbSelectArea( "TOA" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "TOA" ) )
		While !Eof() .And. xFilial( "TOA" ) == TOA->TOA_FILIAL
			If TOA->TOA_TIPREQ == "4"
				If M->TN0_NUMRIS == Substr( TOA->TOA_CODIGO, 1, 9 )
					lRet := .F.
					SX2->(dbSeek( "TOA" ))
					cError := AllTrim( X2Nome() ) + " (TOA)"
					Help( " ", 1, "MA10SC", , cError, 5, 1 )
					Exit
				EndIf
			EndIf
			dbSkip()
		End
		If lRET .And. NGCADICBASE( "TN0_ADIfOL", "A", "TN0", .F. ) .And. TN0->TN0_ADIfOL $ "1sSYy"
			MsgInfo( STR0074, STR0032 )  //"É obrigatorio a emissao de novo Laudo Pericial !" ##"Atencao"
		EndIf
	ElseIf (nOpcx == 4 .Or. nOpcx == 3) .And. nTipoMov == 1
		lTabObra := NGCADICBASE( "TLM_FASE", "A", "TLM", .F. )
		If lTabObra
			If Alltrim( M->TN0_CC ) == "*" .And. !Empty( M->TN0_CODFAS + M->TN0_SUBFAS )
				MsgInfo( STR0030 ) //"Os campos de Fase e Sub-Fase somente devem ser preenchidos quando o campo Centro de Custo (Obra) estiver preenchido."
				lRet := .F.
			ElseIf Alltrim( M->TN0_CC ) != "*" .And. Alltrim( M->TN0_CODTAR ) != "*" .And. !Empty( M->TN0_CODFAS + M->TN0_SUBFAS )
				dbSelectArea( "TLP" )
				dbSetOrder( 1 )
				If !dbSeek( xFilial( "TLP" ) + M->TN0_CC + M->TN0_CODFAS + M->TN0_SUBFAS + M->TN0_CODTAR )
					MsgInfo( STR0031 ) //"O código de tarefa informado não está cadastrado na tabela de Tarefas da Fase da Obra."
					lRet := .F.
				EndIf
			EndIf
		EndIf
		// VALIDA CAMPO INTENSIDADE
		If lRet .And. TN0->(FieldPos( "TN0_PERINT" )) > 0 .And. !MDT180ALL( "TN0_PERINT" )
			lRET := .F.
		EndIf
		//Não pode confirmar com data de avaliação vazia e data de eliminação preenchida.
		If lRet .And. !Empty( M->TN0_DTELIM ) .And. Empty( M->TN0_DTAVAL )
			ShowHelpDlg( "DATAINVAL", { STR0100 }, 2,; //"Data informada inválida."
						 { STR0058 + " " + AllTrim( NGRETTITULO( "TN0_DTAVAL" ) ) + "." }, 2 ) // "Preencha corretamente o campo"
			lRet := .F.
		EndIf
		//Verificação na registros salvos na arvore logica (TAF)
		If lCodAmb .And. !lSigaMdtPs
			If lRet .And. NGCADICBASE( "TN0_DEPTO", "A", "TN0", .F. ) .And. nOpcx == 3
				lRet := fValidDepto()
			EndIf

			If lRet
				If !( IsInCallStack( "MNTA902" ) .Or. IsInCallStack( "MNTA905" ) .Or. IsInCallStack( "MNTA907" ) )
					dbSelectArea( "TAF" )
					dbSetOrder( 10 ) //TAF_FILIAL+TAF_INDCON+TAF_CODCON+TAF_MODMNT+TAF_MODMDT+TAF_MODSGA
					If dbSeek( xFilial( "TAF" ) + "7" + PadR( M->TN0_NUMRIS, Len( TAF->TAF_CODCON ) ) + " X " )
						//Caso o risco estejá vinculado a Planta Grafica, não poderá alterar o Grau do risco
						If !Empty( TAF->TAF_IMAGEM ) .And. M->TN0_GRAU != TN0->TN0_GRAU
							ShowHelpDlg( STR0074, { STR0112 }, 2,; //"Atenção"###"Grau do Risco não pode ser alterado."
										 { STR0106 }, 3 )	       // "O Risco contém um vinculo na estrutra de Árvore Lógica ( TAF )."
							lRet := .F.
						EndIf
						//Caso o risco esteja vinculado a Arvore Lógica não poderá alterar seu código de ambiente.
						If TAF->TAF_NIVSUP == '001'
							dbSetOrder( 1 ) //TAF_FILIAL+TAF_CODEST+TAF_NIVSUP+TAF_ORDEM
							If dbSeek( xFilial( 'TAF' ) + '001' + '000' ) //Se o nível superior for o primeiro e se ele existir
								lVerif := .T.
							EndIf
						Else
							While TAF->( !Bof() ) .And. TAF->( !Eof() ) .And. ;
								TAF->TAF_FILIAL == xFilial( "TAF" ) .And. ;
								TAF->TAF_CODEST == "001" .And. TAF->TAF_INDCON != "2"

								dbSetOrder( 2 ) //TAF_FILIAL+TAF_CODEST+TAF_CODNIV+TAF_NOMNIV
								dbSeek( xFilial( "TAF" ) + "001" + TAF->TAF_NIVSUP )
							End
							lVerif := .T.
						EndIf

						If lVerif .And. !Empty( TAF->TAF_CODAMB ) .And. M->TN0_CODAMB != TAF->TAF_CODAMB
							ShowHelpDlg( STR0074, { STR0105 }, 2,; //"Atenção"###"Código do Ambiente não pode ser alterado."
										 { STR0106 }, 3 )	       // "O Risco contém um vinculo na estrutra de Árvore Lógica ( TAF )."
							lRet := .F.
						EndIf

					EndIf
				Else
					If lRet .And. !Empty( M->TN0_DTELIM )
						ShowHelpDlg( STR0032, { STR0110 }, 2,; //"Atenção"###"Data de Eliminação preenchida."
									 { STR0111 }, 2 )	       // "Para vincular o risco a árvore, é necessário que a data de eliminação esteja vazia."
						lRet := .F.
					EndIf
				EndIf
			EndIf
		EndIf

	EndIf

	RestArea( aArea )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180FUN
Mostra a descricao da funcao

@type Function

@source MDTA180.prx

@param lIniBrw, Lógico, Indica se é Inicializador de Browse (.T.)
						ou na tela cadastral (.F.)

@return Caracter, Descricao da funcao

@sample MDT180FUN(.F.)

@author Andre E. Perez Alvarez
@since 26/09/06
/*/
//---------------------------------------------------------------------
Function MDT180FUN( lIniBrw )

	Local cDesc
	Local aArea   := GetArea()
	Local cFil    := IIf( Len( AllTrim( TN0->TN0_FILIAL ) ) != Len( AllTrim( xFilial( "SRJ" ) ) ), xFilial( "SRJ", TN0->TN0_FILIAL ), TN0->TN0_FILIAL )

	If lIniBrw
		If Alltrim( TN0->TN0_CODFUN ) == "*"
			cDesc := STR0025  //"TODOS"
		Else
			cDesc := Posicione( "SRJ", 1, xFilial( "SRJ", cFil ) + TN0->TN0_CODFUN, "RJ_DESC" )
		EndIf
	Else
		If Alltrim( M->TN0_CODFUN ) == "*"
			cDesc := STR0025  //"TODOS"
		Else
			cDesc := Posicione( "SRJ", 1, xFilial( "SRJ" ) + M->TN0_CODFUN, "RJ_DESC" )
		EndIf
	EndIf

	RestArea( aArea )

Return cDesc

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180CREL
Funcao para copiar os EPIs ou Exames relacionados

@type Function

@source MDTA180.prx

@param cRiscoAnt, Caracter, Risco a ser copiado
@param cRiscoNovo, Caracter, Risco  ser gravado
@param [nTipCpy], Numérico, Indica a opção que será copiada

@return Nulo

@sample MDT180CREL('000000001' , '000000002' )

@author Denis Hyroshi de Souza
@since 26/09/06
/*/
//---------------------------------------------------------------------
Static Function MDT180CREL( cRiscoAnt, cRiscoNovo, nTipCpy )

	Local i
	Local aAreaCpy
	Local aAreaXXX := GetArea()
	Local aAreaTN0 := TN0->(GetArea())
	Local cAlsCpy  := "TNX"
	Local nIdxCpy  := 1
	Local cKeyCpy  := xFilial( "TNX" ) + cRiscoAnt
	Local cWhlCpy  := "TNX->TNX_FILIAL + TNX->TNX_NUMRIS"

	Default nTipCpy := 1

	If cRiscoAnt != cRiscoNovo
		If nTipCpy == 2
			cAlsCpy := "TN2"
			nIdxCpy := 1
			cKeyCpy := xFilial( "TN2" ) + cRiscoAnt
			cWhlCpy := "TN2->TN2_FILIAL + TN2->TN2_NUMRIS"
		EndIf

		dbSelectarea( cAlsCpy )
		dbSetorder( nIdxCpy )
		dbSeek( cKeyCpy )
		While ( cAlsCpy )->( !EoF() ) .And. cKeyCpy == &( cWhlCpy )

			aAreaCpy := ( cAlsCpy )->(GetArea())

			RegToMemory( cAlsCpy, .F. )

			RecLock( cAlsCpy, .T. )
				For i := 1 To FCount()
					If "_FILIAL" $ FieldName( i )
						FieldPut( i, xFilial( cAlsCpy ) )
					ElseIf "_NUMRIS" $ FieldName( i )
						FieldPut( i, cRiscoNovo )
					ElseIf "_AGENTE" $ FieldName( i )
						FieldPut( i, M->TN0_AGENTE )
					Else
						FieldPut( i, &( "M->" + FieldName( i ) ) )
					EndIf
				Next i
			( cAlsCpy )->( MsUnLock() )
			RestArea( aAreaCpy )
			( cAlsCpy )->( dbSkip() )
		End
	EndIf

	RestArea( aAreaTN0 )
	RestArea( aAreaXXX )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de Menu Funcional.

@type Function

@source MDTA180.prx

@param [lMdtPs], Lógico, Indica se executa Menu de Prestador
@param [lMdi], Lógico, Indica se é executado pelo Menu Funcional

@return Array, aRotina com as opções de menu.
					Parametros do array a Rotina:
					1. Nome a aparecer no cabecalho
					2. Nome da Rotina associada
					3. Reservado
					4. Tipo de Transao a ser efetuada:
						1 - Pesquisa e Posiciona em um Banco de Dados
						2 - Simplesmente Mostra os Campos
						3 - Inclui registros no Bancos de Dados
						4 - Altera o registro corrente
						5 - Remove o registro corrente do Banco de Dados
					5. Nivel de acesso
					6. Habilita Menu Funcional

@sample MenuDef()

@author Rafael Diogo Richter
@since 29/11/2006
/*/
//---------------------------------------------------------------------
Static Function MenuDef( lMdtPS, lMdi )

	Local aRotina
	Local nCont
	Local lSigaMdtPS := SuperGetMv( "MV_MDTPS", .F., "N" ) == "S"

	Private aRet := {}

	Default lMdtPS := SuperGetMv( "MV_MDTPS", .F., "N" ) == "S"
	Default lMdi   := .T.

	If lMdtPS
		aRotina := {  { STR0001, "AxPesqui", 0, 1 },; //"Pesquisar"
					  { STR0002, "NGCAD01", 0, 2 },;  //"Visualizar"
					  { STR0006, "MDT180RI", 0, 4 } } //"Riscos"
	Else

		aRotina :={  { STR0001, "AxPesqui", 0, 1 },;		  //"Pesquisar"
					 { STR0002, "D180INCL", 0, 2 },;		  //"Visualizar"
					 { STR0003, "D180INCL", 0, 3 },;		  //"Incluir"
					 { STR0004, "D180INCL", 0, 4 },;		  //"Alterar"
					 { STR0005, "D180INCL", 0, 5, 3 },;		  //"Excluir"
					 { STR0008, "MDT180Leg", 0, 6, 0, .F. } } //"Legenda"

		aAdd( aRotina, { STR0007, "D180INCL", 0, 7 } )    //"Copiar"
		aAdd( aRotina, { STR0028, "MDT180EPI", 0, 4 } )   //"Risco x EPI"
		aAdd( aRotina, { STR0029, "MDT180EXAME", 0, 4 } ) //"Risco x Exame"
		aAdd( aRotina, { STR0102, "MDT180EPC", 0, 4 } )   //"Risco x EPC"

		If !lMdi

			aAdd( aRotina, { STR0109, "MDT181REL", 0, 4 } ) //"Relacionamentos"

			If !lSigaMdtPS .And. AliasInDic( "TY4" ) .And. ;
				SuperGetMv( "MV_NGMDTTR", .F., "2" ) == "1" .And. FindFunction( "MDTGERTRM" )

				aAdd( aRotina, { STR0118, "MDTGERTRM", 0, 4 } )//"Treinamentos"

			EndIf

			If FindFunction( "MDT181RELAC" )
				aAdd( aRotina, { STR0145, "MDT180CPY", 0, 4 } ) //"Copiar Relac."
			EndIf
		EndIf

		If ExistBlock( "MDTA1801" )
			aRet := ExecBlock( "MDTA1801", .F., .F. )

			If Type( "aRet" ) == "A"
				For nCont := 1 To Len( aRet )
					aAdd( aRotina, { aRet[nCont][1], aRet[nCont][2], aRet[nCont][3], aRet[nCont][4] } )
				Next nCont
			Else
				MsgStop( STR0146 ) //"Erro no Ponto de Entrada MDTA1801"
			EndIf
		EndIf

	EndIf

Return aRotina

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180RI
Monta um browse com os Riscos do cliente.

@type Function

@source MDTA180.prx

@return Nulo

@sample MDT180RI()

@author Andre Perez Alvarez
@since 25/09/07
/*/
//---------------------------------------------------------------------
Function MDT180RI()

	Local aArea	    := GetArea()
	Local oldROTINA := aCLONE( aROTINA )
	Local oldCad    := cCadastro
	Local nCont

	Private aRet := {}

	cCliMdtPs    := SA1->A1_COD+SA1->A1_LOJA

	aRotina := MenuDef( .F. )

	//---------------------------------------------
	// Define o cabecalho da tela de atualizacoes
	//---------------------------------------------
	Private cCadastro := OemToAnsi( STR0006 )
	Private aSMENU    := {}
	Private aCHKDEL   := {}
	Private DTVALIDA  := .T.
	Private bNGGRAVA

	//-----------------------------
	// Endereca a funcao de BROWSE
	//-----------------------------
	dbSelectArea( "TN0" )
	Set Filter To TN0->TN0_CODCLI + TN0->TN0_LOJACL == SA1->A1_COD + SA1->A1_LOJA
	dbSetOrder( 1 )
	mBrowse( 6, 1, 22, 75, "TN0", , , , , , RiscoCor() )

	aROTINA := aClone( oldROTINA )
	RestArea( aArea )
	cCadastro := oldCad

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180BRW2
Inicializa o browse

@type Function

@source MDTA180.prx

@sample MDT180BRW2(.T.)

@return Caracter, Retorna o Inicializador de Browser

@author Andre E. Perez Alvarez
@since 09/01/07
/*/
//---------------------------------------------------------------------
Function MDT180BRW2( lIniBrw )

	Local cDesc  := ""
	Local aArea  := GetArea()
	Local cFil   := IIf( Len( AllTrim( TN0->TN0_FILIAL ) ) != Len( AllTrim( xFilial( "TN5" ) ) ), xFilial( "TN5" ), TN0->TN0_FILIAL )

	If lIniBrw
		If AllTrim( TN0->TN0_CODTAR ) == "*"
			cDesc := "TODAS"
		Else
			cDesc := Posicione( "TN5", 1, xFilial( "TN5", cFil ) + TN0->TN0_CODTAR, "TN5_NOMTAR" )
		EndIf
	Else
		If AllTrim( M->TN0_CODTAR ) == '*'
			cDesc := 'TODAS'
		Else
			cDesc := Posicione( "TN5", 1, xFilial( "TN5", cFil ) + M->TN0_CODTAR, "TN5_NOMTAR" )
		EndIf
	EndIf

	RestArea( aArea )

Return cDesc

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180BRW3
Responsavel por realizar a inicialização de browser do campo TN0_NOMFON

@type Function

@source MDTA180.prx

@sample MDT180BRW3()

@return Caracter, Retorna o Inicializador de Browser

@author Guilherme Freudenburg
@since 12/09/2016
/*/
//---------------------------------------------------------------------
Function MDT180BRW3()

	Local cFil := IIf( Len( AllTrim( TN0->TN0_FILIAL ) ) != Len( AllTrim( xFilial( "TN7" ) ) ), xFilial( "TN7" ), TN0->TN0_FILIAL )

Return IIf(TN7->(dbSeek( xFilial( "TN7", cFil ) + TN0->TN0_FONTE ) ), TN7->TN7_NOMFON, "" )

//---------------------------------------------------------------------
/*/{Protheus.doc} fAMBMDTPS
Valida código do Ambiente Físico

@type Function

@source MDTA180.prx

@param CODAMB, Caracter, Código do Ambiente Físico

@return Lógico, Indica se pode inserir código do Ambiente

@sample fAMBMDTPS( '000001' )

@author Denis Hyroshi Souza
@since 22/03/05
/*/
//---------------------------------------------------------------------
Function fAMBMDTPS( CODAMB )

	Local aArea  := GetArea()
	Local lPrest := .F.

	If Type( "cCliMdtPs" ) == "C"
		If !Empty( cCliMdtPs )
			lPrest := .T.
		EndIf
	EndIf

	If lPrest
		dbSelectArea( "TNE" )
		dbSetorder( 3 )
		If !dbSeek( xFilial( "TNE" ) + cCliMdtPs + CODAMB )
			Help( " ", 1, "REGNOIS" )
			RestArea( aArea )
			Return .F.
		EndIf
	Else
		dbSelectArea( "TNE" )
		dbSetOrder( 1 )
		If !dbSeek( xFilial( "TNE" ) + CODAMB )
			Help( " ", 1, "REGNOIS" )
			RestArea( aArea )
			Return .F.
		EndIf
	EndIf

	RestArea( aArea )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180TN2
Monta um browse com os Riscos p/ Exame do cliente

@type Function

@source MDTA180.prx

@return Nulo

@sample MDT180TN2()

@author Andre Perez Alvarez
@since 25/09/07
/*/
//---------------------------------------------------------------------
Function MDT180TN2()

	Local aArea	    := GetArea()
	Local oldROTINA := aClone( aROTINA )
	Local oldCad    := cCadastro
	Local oldChoice := IIf( Type( "aChoice" ) == "A", aClone( aChoice ), {} )

	cCliMdtPs := SA1->A1_COD+SA1->A1_LOJA

	aRotina :={  { STR0001, "AxPesqui", 0, 1 },;   //"Pesquisar"
				 { STR0002, "NGCAD01", 0, 2 },;    //"Visualizar"
				 { STR0003, "NGCAD01", 0, 3 },;    //"Incluir"
				 { STR0004, "NGCAD01", 0, 4 },;    //"Alterar"
				 { STR0005, "NGCAD01", 0, 5, 3 } } //"Excluir"

	//---------------------------------------------
	// Define o cabecalho da tela de atualizacoes
	//---------------------------------------------
	Private cCadastro := OemtoAnsi( STR0006 ) //"Exames por Risco"
	Private aCHKDEL   := {}
	Private bNGGRAVA

	aCHOICE := {}

	//------------------------------
	// Endereca a funcao de BROWSE
	//------------------------------
	dbSelectArea( "TN2" )
	Set Filter To TN2->TN2_FILIAL == xFilial( "TN2" ) .And. TN2->TN2_NUMRIS == cRiscsalvo .And. TN2->(TN2_CLIENT+TN2_LOJA) == cCliMdtps
	dbSetOrder( 1 )
	mBrowse( 6, 1, 22, 75, "TN2" )

	dbSelectArea( "TN2" )
	Set Filter To

	aROTINA := aClone( oldROTINA )
	RestArea( aArea )
	cCadastro := oldCad
	aCHOICE   := oldCHOICE

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} ValFaseTN0
Valida Fase e Sub-fase

@type Function

@source MDTA180.prx

@param nTipo, Numérico, Indica se é fase (1) ou sub-fase (2)

@return Lógico, Indica se fase ou sub-fase é valida

@sample ValFaseTN0( 1 )

@author Denis
@since 06/02/08
/*/
//---------------------------------------------------------------------
Function ValFaseTN0( nTipo )

	Local lRet     := .T.
	Local OldAlias := Alias()
	Local cTempSub := ""

	cTempSub := TLM->TLM_SUBFAS
	If Empty( TLM->TLM_SUBFAS )
		dbSelectArea( "TLM" )
		dbSetOrder( 1 )
		If nTipo == 1 .And. dbSeek( xFilial( "TLM" ) + M->TN0_CC + M->TN0_CODFAS + cTempSub )
			cTempSub := TLM->TLM_SUBFAS
		ElseIf !Empty( M->TN0_SUBFAS )
			cTempSub := M->TN0_SUBFAS
		EndIf
	EndIf

	If nTipo == 1
		If !Empty( M->TN0_CODFAS )
			If !ExistCpo( "TLM", M->TN0_CC + M->TN0_CODFAS )
				lRet := .F.
			Else
				dbSelectArea( "TLM" )
				dbSetOrder( 1 )
				If !dbSeek( xFilial( "TLM" ) + M->TN0_CC + M->TN0_CODFAS + cTempSub )
					If !Empty( M->TN0_SUBFAS )
						If !dbSeek( xFilial( "TLM" ) + M->TN0_CC + M->TN0_CODFAS + cTempSub )
							dbSeek( xFilial( "TLM" ) + M->TN0_CC + M->TN0_CODFAS )
						EndIf
					Else
						dbSeek( xFilial( "TLM" ) + M->TN0_CC + M->TN0_CODFAS )
					EndIf
				EndIf
				M->TN0_SUBFAS := TLM->TLM_SUBFAS
				M->TN0_DESSUB := Substr( Posicione( "TLZ", 1, xFilial( "TLZ" ) + TLM->TLM_SUBFAS, "TLZ_DESCRI" ), 1, 20 )
			EndIf
		Else
			M->TN0_DESFAS := Space( 20 )
			M->TN0_SUBFAS := Space( Len( M->TN0_SUBFAS ) )
			M->TN0_DESSUB := Space( 20 )
		EndIf
	Else
		If !Empty( M->TN0_CODFAS ) .Or. !Empty( M->TN0_SUBFAS )
			If !Empty( M->TN0_SUBFAS )
				If !ExistCpo( "TLM", M->TN0_CC + M->TN0_CODFAS + M->TN0_SUBFAS )
					lRet := .F.
				EndIf
			Else
				If !ExistCpo( "TLM", M->TN0_CC + M->TN0_CODFAS )
					lRet := .F.
				EndIf
			EndIf
		Else
			M->TN0_SUBFAS := Space( Len( M->TN0_SUBFAS ) )
			M->TN0_DESSUB := Space( 20 )
		EndIf
	EndIf

	If !Empty( OldAlias )
		dbSelectArea( OldAlias )
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} A180VLELIM
Valida a data de eliminação do risco

@type Function

@source MDTA180.prx

@param cField

@return Lógico, Indica se a data de eliminação está correto

@sample A180VLELIM()

@author Roger Rodrigues
@since 13/05/2010
/*/
//---------------------------------------------------------------------
Function A180VLELIM()

	If !Empty( M->TN0_DTELIM )
		If !VALDATA( M->TN0_DTRECO, M->TN0_DTELIM, "A180DTVAL" )
			Return .F.
		EndIf
		If M->TN0_DTELIM > dDataBase
			ShowHelpDlg( STR0032, { STR0033 }, 2, { STR0034 }, 2 ) //"A data de eliminação não pode ser maior que a Data de Reconhecimento.""###"Informe uma data menor ou igual a data atual."
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180VRIS
Valida campo TNC_NUMRIS

@type Function

@source MDTA180.prx

@param [cField], Caracter, Indica valor do campo

@return Lógico, Indica se valor está correto

@sample MDT180VRIS()

@author Denis
@since 25/10/2007
/*/
//---------------------------------------------------------------------
Function MDT180VRIS( cField )

	Local lPrest := .F.

	Default cField := M->TNC_NUMRIS

	If Type( "cCliMdtPs" ) == "C"
		If !Empty( cCliMdtPs )
			lPrest := .T.
		EndIf
	EndIf

	If lPrest
		Return ExistCPO( "TN0", cCliMdtps + cField, 8 )
	Else
		Return ExistCPO( "TN0", cField )
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180XREL
Inicializador padrao dos campos: TN0_NOMAMB, TN0_NOMFON

@type Function

@source MDTA180.prx

@param cTabVld, Caracter, Indica tabela de relação
@param nTipoVld, Numérico, Indica tipo de relação: 1 - X3_RELACAO, 2 - X3_INIBRW

@return Caracter, Retorna o valor da descrição

@sample MDT180XREL( 'TNE' , 1 )

@author Denis
@since 25/10/2007
/*/
//---------------------------------------------------------------------
Function MDT180XREL( cTabVld, nTipoVld )

	Local lPrest := .F.

	If Type( "cCliMdtPs" ) == "C"
		If !Empty( cCliMdtPs )
			lPrest := .T.
		EndIf
	EndIf

	If cTabVld == "TNE"
		If lPrest //Prestador
			If nTipoVld == 1 //Relacao
				Return IIf( !INCLUI, Posicione( "TNE", 3, xFILIAL( "TNE" ) + cCliMdtPs + TN0->TN0_CODAMB, "TNE_NOME" ), "" )
			Else //Init. Brw
				Return Posicione( "TNE", 3, xFILIAL( "TNE" ) + cCliMdtPs + TN0->TN0_CODAMB, "TNE_NOME" )
			EndIf
		Else
			If nTipoVld == 1 //Relacao
				Return IIf( !INCLUI, Posicione( "TNE", 1, xFILIAL( "TNE" ) + TN0->TN0_CODAMB, "TNE_NOME" ), "" )
			Else //Init. Brw
				Return Posicione( "TNE", 1, xFILIAL( "TNE" ) + TN0->TN0_CODAMB, "TNE_NOME" )
			EndIf
		EndIf
	ElseIf cTabVld == "TN7"
		If lPrest //Prestador
			If nTipoVld == 1 //Relacao
				Return IIf( !INCLUI, Posicione( "TN7", 3, xFILIAL( "TN7" ) + cCliMdtPs + TN0->TN0_FONTE, "TN7_NOMFON" ), "" )
			Else //Init. Brw
				Return Posicione( "TN7", 3, xFILIAL( "TN7" ) + cCliMdtPs + TN0->TN0_FONTE, "TN7_NOMFON" )
			EndIf
		Else
			If nTipoVld == 1 //Relacao
				Return IIf(!INCLUI, Posicione( "TN7", 1, xFILIAL( "TN7" ) + TN0->TN0_FONTE, "TN7_NOMFON" ), "" )
			Else //Init. Brw
				Return Posicione( "TN7", 1, xFILIAL( "TN7" ) + TN0->TN0_FONTE, "TN7_NOMFON" )
			EndIf
		EndIf
	EndIf

Return Space( 20 )

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180VFGE
Valida campo TN0_FONTE.

@type Function

@source MDTA180.prx

@return Lógico, Indica se valor está correto

@sample MDT180VFGE()

@author Denis
@since 25/10/2007
/*/
//---------------------------------------------------------------------
Function MDT180VFGE()

	Local lPrest := .F.

	If Type( "cCliMdtPs" ) == "C"
		If !Empty( cCliMdtPs )
			lPrest := .T.
		EndIf
	EndIf

	If lPrest
		Return ExistCPO( "TN7", cCliMdtPs + M->TN0_FONTE, 3 )
	Else
		Return ExistCPO( "TN7", M->TN0_FONTE )
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} RisAtiWhen
When dos campos TN0_ATIPER e TN0_ATISAL.

@type Function

@source MDTA180.prx

@param nTipo

@sample RisAtiWhen( 1 )

@return Lógico, Indica se campo pode ser habilitado

@author Denis
@since 20/12/2010
/*/
//---------------------------------------------------------------------
Function RisAtiWhen( nTipo )

	Local lRet     := .T.
	Local aAreaXXX := GetArea()
	Local aAreaTMA := TMA->(GetArea())

	If nTipo == 1 //TN0_ATISAL
		dbSelectArea( "TMA" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "TMA" ) + M->TN0_AGENTE )
			If TMA->TMA_TIPADI != "1"
				M->TN0_ATISAL := "1" //Deve receber esse valor, para voltar ao valor inicial e a validação ficar correta - MDT180INT
				lRet := .F.
			EndIf
		EndIf
	ElseIf nTipo == 2 //TN0_ATIPER
		dbSelectArea( "TMA" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "TMA" ) + M->TN0_AGENTE )
			If TMA->TMA_TIPADI != "2"
				M->TN0_ATIPER := "1" //Deve receber esse valor, para voltar ao valor inicial e a validação ficar correta - MDT180INT
				lRet := .F.
			EndIf
		EndIf
	EndIf

	RestArea( aAreaTMA )
	RestArea( aAreaXXX )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTA180VHORA
Valida a hora.

@type Function

@source MDTA180.prx

@param cHora, Caracter, Valor de hora a ser validada

@sample MDTA180VHORA('08:00')

@return Lógico, Indica se hora é valida

@author Rodrigo Soledade
@since 26/03/2011
/*/
//---------------------------------------------------------------------
Function MDTA180VHORA( cHora ) //cVHORA

	Local lRETVH := .T.
	Local lPROVH := .F.
	Local xh
	Local xm

	If Empty( cHora )
	   lPROVH := .F.
	Else
	   posv := At( ":", cHora )
	   If posv = 0
	    	lPROVH := .T.
	   Else
	    	cHorav   := SubStr( cHora, 1, (posv-1) )
	    	cMinutov := SubStr( cHora, (posv+1), 2 )
	    	If Empty( cHorav ) .Or. Empty( cMinutov ) .Or. Len( Alltrim( cMinutov ) ) < 2
	    		lPROVH := .T.
	    	Else
	    		For xh := 1 To Len( cHorav )
	    	    	cCARACHOR := Substr( cHorav, xh, 1 )
	    	      	If Empty( cCARACHOR ) .Or. !IsDigit( cCARACHOR )
	    	        	lPROVH := .T.
	    	        	Exit
	    	      	EndIf
	    	   	Next xh
	    	   	If !lPROVH
	    	    	For xm := 1 To Len( cMinutov )
	    	        	cCARACMIN := Substr( cMinutov, xm, 1 )
	    	        	If Empty( cCARACMIN ) .Or. !IsDigit( cCARACMIN )
	    	           		lPROVH := .T.
	    	           		Exit
	    	         	EndIf
	    	      	Next xm
	    	   	EndIf
	    	   	If !lPROVH
	    	    	nHorav   := Val( cHorav )
	    	    	nMinutov := Val( cMinutov )
	    	    	If (nHorav > 1000 .And. nMinutov > 60) .Or. (nMinutov > 59)
	    	    		lPROVH := .T.
	    	    	EndIf
	    	   	EndIf
	    	EndIf
	   	EndIf
	EndIf

	If lPROVH
		Help( " ", 1, "HORAINVALI" )
		lRETVH := .F.
	EndIf

Return lRETVH

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180MLOK
Efetua validacao da linha na getdados de Medida de Controle.

@type Function

@source MDTA180.prx

@param [lTudoOk], Lógico, Indica se é validação TudoOK

@sample MDT180MLOK()

@return Lógico, Indica se a linha está correta

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Function MDT180MLOK( lTudoOk )

	Local nMedida := aScan( oGetWnd:aHeader, { |x| AllTrim( x[2] ) == "TJF_MEDCON" } ) // Medida de Controle
	Local lLinOk  := .T.
	Local nLin

	Default lTudoOk := .F.

	If nMedida == 0
		Return .F.
	EndIf

	// Se a linha estiver deletada
	If oGetWnd:aCols[oGetWnd:nAt][Len( oGetWnd:aCols[oGetWnd:nAt] )]
		Return .T.
	EndIf

	If lTudoOk
		If Len( oGetWnd:aCols ) == 1 .And. Empty( oGetWnd:aCols[1][nMedida] )
			Return .T.
		EndIf
	EndIf

	// Avalia campos obrigatorios
	If Empty( oGetWnd:aCols[oGetWnd:nAt][nMedida] ) // Codigo Medida Controle
		ShowHelpDlg( STR0032, { STR0057 + CRLF + AllTrim( NGRETTITULO( "TJF_MEDCON" ) ) }, 1,; // "Atenção" ## "Campo obrigatório não preenchido:"
					 { STR0058 + " " + AllTrim( NGRETTITULO( "TJF_MEDCON" ) ) + "." }, 1 )     // "Preencha corretamente o campo"
		Return .F.
	EndIf

	// Verifica registro duplicado
	For nLin := 1 To Len( oGetWnd:aCols )
		If !oGetWnd:aCols[nLin][Len( oGetWnd:aCols[nLin] )] .And. ( oGetWnd:nAt != nLin )
			If oGetWnd:aCols[nLin][nMedida] == oGetWnd:aCols[oGetWnd:nAt][nMedida]
				Help( " ", 1, "JAEXISTINF" )
				lLinOk := .F.
				Exit
			EndIf
		EndIf
	Next nLin

Return lLinOk

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt180F10
Evento definido para a tecla F10.

@type Function

@source MDTA180.prx

@sample Mdt180F10()

@return Nulo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function Mdt180F10()

  	Local cVarAtu := ReadVar() // Armazena conteudo do ReadVar
  	Local cFldNm  := IIf( !Empty( cVarAtu ), SubStr( cVarAtu, At( ">", cVarAtu ) + 1, Len( cVarAtu ) ), cVarAtu )

	// Caso seja efetuado quando em foco de determinados campos, realiza chamada da tela de multiplas selecoes
	If !Empty( cVarAtu ) .And. cFldNm $ "TN0_CC/TN0_CODFUN/TN0_CODTAR/TN0_DEPTO"
		lCallMS := Mdt180MSlc( cFldNm )
	EndIf

	// Retorna conteudo do ReadVar
	__ReadVar := cVarAtu

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180VCFT
Validacao dos campos de Centro de Custo, Funcao, Tarefa e Departamento.
TN0_CC | TN0_CODFUN | TN0_CODTAR | TN0_DEPTO

@type Function

@source MDTA180.prx

@param cField, Caracter, Campo que efetuou a chamada da funcao [Valid].

@sample MDT180VCFT( 'TN0_CC' )

@return Lógico, Indica se o campo é valido

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Function MDT180VCFT( cField )

	Local cMmryFld := &( "M->" + cField )			// Constroi referencia a memoria do campo
	Local lValOk   := .T.							// Variavel de controle para validacao
	Local lOpenWnd := IsInCallStack( "Mdt180MSlc" )	// Controle de chamada

	// Se a memoria do campo estiver vazia, ou definida como '*'
	If !lOpenWnd .And. Empty( cMmryFld ) .Or. AllTrim( cMmryFld ) == "*"
		Return .T.
	EndIf

	// Se a validacao nao esta sendo feita a partir da tela de multiplas selecoes e o conteudo for '#'
	If ( Inclui .Or. ( Altera .And. Empty( M->TN0_DTAVAL ) ) ) .And. !lOpenWnd .And. AllTrim( cMmryFld ) == "#"
		// Verifica se houve chamada pelo F10 e se foi selecionado algum item
		If Type( "lCallMS" ) == "U" .Or. Type( "lCallMS" ) == "L" .And. !lCallMS
			lValOk := Mdt180MSlc( cField )
		EndIf
		lCallMS := .F.
	Else
		// Validacoes especificas dos campos
		Do Case
			Case cField == "TN0_CC"
				lValOk := (!lSigaMdtPs .And. CTB105CC()) .Or. (lSigaMdtPs .And. MDTCCPSVL( M->TN0_CC ))
			Case cField == "TN0_CODFUN"
				lValOk := ExistCpo( "SRJ", cMmryFld ) .And. !lSigaMdtPs
			Case cField == "TN0_CODTAR"
				If lSigaMdtPs
					lValOk := ExistCpo( "TN5", cCliMdtPs + cMmryFld, 3 )
				Else
					lValOk := ExistCpo( "TN5", cMmryFld )
				EndIf
			Case cField == "TN0_DEPTO"
				lValOk := ExistCpo( "SQB", cMmryFld )
		EndCase
	EndIf

Return lValOk

//---------------------------------------------------------------------
/*/{Protheus.doc} CrtTrbCFT
Constroi tabelas temporarias para Centro de Custos, Funcoes ou Tarefas.

@type Function

@source MDTA180.prx

@sample CrtTrbCFT()

@return Array, Valor de estrutura dos campos

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function CrtTrbCFT()

	Local aEstTrbs := Array( 4 )

	// Cria arquivos de trabalho
	aEstTrbs[1] := CrtTrbBrw( GetNextAlias(), "CTT" ) 							// Centro de Custo
	aEstTrbs[2] := CrtTrbBrw( GetNextAlias(), IIf( lSigaMdtPs, "TOS", "SRJ" ) )	// Funcao
	aEstTrbs[3] := CrtTrbBrw( GetNextAlias(), "TN5" ) 							// Tarefa
	aEstTrbs[4] := CrtTrbBrw( GetNextAlias(), "SQB" ) 							// Departamento

	_SetOwnerPrvt( "aEst180CC", aClone( aEstTrbs[1] ) )  // Centro de Custo
	_SetOwnerPrvt( "aEst180Fun", aClone( aEstTrbs[2] ) ) // Funcao
	_SetOwnerPrvt( "aEst180Tar", aClone( aEstTrbs[3] ) ) // Tarefa
	_SetOwnerPrvt( "aEst180Dpt", aClone( aEstTrbs[4] ) ) // Departamento

Return aEstTrbs

//---------------------------------------------------------------------
/*/{Protheus.doc} CrtTrbBrw
Define estruturas utilizadas pelo processo.
[ Tabelas temporarias, Markbrowse ]

@type Function

@source MDTA180.prx

@param cAliasTrb, Caracter, Alias utilizado pelo markbrowse.
@param cTable, Caracter, Tabela a ser verificada.

@sample CrtTrbBrw( 'SCG0001' , 'CTT' )

@return Array, Valores da estrutura da tabela utilizada

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function CrtTrbBrw( cAliasTrb, cTable )

	Local aColBrw
	Local nInd
	Local nIdx
	Local aIndexes := {} // Indices
	Local aIndSeek := {} // Indices utilizados para pesquisa
	Local aIndTrb  := {} // Indices tabela temporaria
	Local aFldBrw  := {} // Campos utilizados pelo processo

	aFldBrw   := RetFldTbl( cTable )            		// Retorna campos utilizados
	aIndexes  := RetIndexTb( cTable, aFldBrw )  		// Indices da tabela em questao
	aColBrw   := RetFldBrw( aFldBrw, cTable )			// Campos (TRB) e Colunas (Browse)
	nIndexKey := RetIdxKey( cTable, aIndexes[1][1] )	// Retorna indice referente a chave

	// Define, atraves dos indices da tabela de referencia, os indices da tabela temporaria e indices de pesquisa
	For nInd := 1 To Len( aIndexes )
		aAdd( aIndTrb, aIndexes[nInd][1] )  // Indices tabela temporaria
		aAdd( aIndSeek, aIndexes[nInd][2] ) // Indices de pesquisa
	Next nInd

	oTempProc := FWTemporaryTable():New( cAliasTrb, aColBrw[1] )
	For nIdx := 1 To Len( aIndTrb )
		oTempProc:AddIndex( RetAsc( cValToChar( nIdx ), 1, .T. ), StrTokArr( aIndTrb[nIdx], "+" ) )
	Next nIdx
	oTempProc:Create()

//Retorno: {Tabela Ref., Indice Chave}, Alias Temp., Indices Cbb, Campos Trb, CamposMrk, Nome Arq. Trb
Return { {cTable, nIndexKey}, cAliasTrb, aIndSeek, aColBrw[1], aColBrw[2], oTempProc }

//---------------------------------------------------------------------
/*/{Protheus.doc} RetIdxKey
Retorna indice referente a chave.

@type Function

@source MDTA180.prx

@param cTable, Caracter, Tabela a ser verificada.
@param cIndexKey, Caracter, Desricao/Titulo indice a ser verificado.

@sample RetIdxKey( 'CTT' , 'Código' )

@return Numerico, Valor do índice

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function RetIdxKey( cTable, cIndexKey )

	Local aArea     := GetArea()
	Local nIndexKey := 0
	Local cIdxSeek  := "_FILIAL+"
	Local cPrfxTbl  := PrefixoCpo( cTable ) // Armazena prefixo utilizado pelos campos da tabela

	If lSigaMdtPs .And. cTable != "CTT"
		cIdxSeek += cPrfxTbl + "_CLIENT+" + cPrfxTbl + "_LOJA+" + cIndexKey
	Else
		cIdxSeek += cIndexKey
	EndIf

	nIndexKey := NGRETORDEM( cTable, cIdxSeek, .F. )

	RestArea( aArea )

Return nIndexKey

//---------------------------------------------------------------------
/*/{Protheus.doc} RetFldTbl
Retorna campos pre-definidos conforme a tabela informada.

@type Function

@source MDTA180.prx

@param cTable, Caracter , Tabela a ser verificada.

@sample RetFldTbl( 'CTT' )

@return Array, Estrutura da tabela

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function RetFldTbl( cTable )

	Local aFldBrw := {} // Campos TRB e Markbrowse

	// Define campos que serao utilizados para montagem do alias para o markbrowse, assim como os campos que serao apresentados pelo mesmo
	// A segunda posicao do array, define se o campo sera apresentado no 'browse' do markbrowse
	// A estrutura de [OK | CODIGO], deve ser mantida

	// Campos TRB e Markbrowse
	If cTable == "CTT" // Centro de Custo
		aFldBrw := { { "CTT_OK" }, { "CTT_CUSTO" }, { "CTT_DESC01" } }
	ElseIf cTable == "SRJ" // Funcao
		aFldBrw := { { "RJ_OK" }, { "RJ_FUNCAO" }, { "RJ_DESC" } }
	ElseIf cTable == "TN5" // Tarefa
		aFldBrw := { { "TN5_OK" }, { "TN5_CODTAR" }, { "TN5_NOMTAR" } }
	ElseIf cTable == "TOS" // Funcao [Prestador]
		aFldBrw := { { "TOS_OK" }, { "TOS_CODFUN" }, { "TOS_DESFUN" } }
	ElseIf cTable == "SQB"
		aFldBrw := { { "QB_OK" }, { "QB_DEPTO" }, { "QB_DESCRIC" } }
	EndIf

Return aFldBrw

//---------------------------------------------------------------------
/*/{Protheus.doc} RetIndexTb
Retorna os indices referentes a tabela informada.

@type Function

@source MDTA180.prx

@param cTable, Caracter, Codido da tabela a ser verificada.
@param aFldBrw, Array, Campos pre-definidos.

@sample RetIndexTb( 'CTT' , {} )

@return Array, Valores de Índices

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function RetIndexTb( cTable, aFldBrw )

	Local aIndexes := {}
	Local aIndex   := {}
	Local cIndexAt := ""
	Local cDescInd := ""
	Local cOrdem   := ""
	Local cPrfxTbl := PrefixoCpo( cTable ) // Armazena prefixo utilizado pelos campos da tabela
	Local nIndex   := 0

	Local aArea    := GetArea()

	// Define indice chave para a tabela [Indice 1]

	If cTable == "CTT" // Centro de Custo
		aAdd( aIndexes, { "CTT_CUSTO", STR0053 } ) // "Centro de Custo"
	ElseIf cTable == "SRJ" // Funcao
		aAdd( aIndexes, { "RJ_FUNCAO", STR0054 } ) // "Função"
	ElseIf cTable == "TN5" // Tarefa
		aAdd( aIndexes, { "TN5_CODTAR", STR0055 } ) // "Tarefa"
	ElseIf cTable == "TOS" // Funcao [Prestador]
		aAdd( aIndexes, { "TOS_CODFUN", STR0054 } ) // "Função"
		aAdd( aIndexes, { "TOS_DESFUN", STR0056 } ) // "Descrição"
	ElseIf cTable == "SQB"
		aAdd( aIndexes, { "QB_DEPTO", STR0114 } ) //"Departamento"
	EndIf

	aIndex := NGRETINDTAB( cTable )

	If Len( aIndex ) > 0

		For nIndex := 1 To Len( aIndex )
			
			cIndexAt := aIndex[ nIndex ]

			// Verifica se podera utilizar o indice, conforme os campos utilizados
			If CanUseInd( @cIndexAt, aFldBrw )
				If aScan( aIndexes, { |x| x[ 1 ] == cIndexAt } ) == 0
					cOrdem   := AllTrim( AllToChar( nIndex ) )
					cDescInd := Posicione( "SIX", 1, cTable + cOrdem, "DESCRICAO" )
					aAdd( aIndexes, { cIndexAt, AllTrim( cDescInd ) } )
				EndIf
			EndIf

		Next nIndex

	EndIf

	// Adiciona indice 'Marcados' a fim de possibilitar a ordenacao pelo itens marcados no markwbrowse
	aAdd( aIndexes, { aFldBrw[1][1], STR0035 } ) // "Marcados"

	RestArea( aArea )

Return aIndexes

//---------------------------------------------------------------------
/*/{Protheus.doc} CanUseInd
Verifica se o indice pode ser utilizado conforme os campos pre-definidos.

@type Function

@source MDTA180.prx

@param cIndex, Caracter, Indice a ser avaliado.
@param aFldBrw Array, Campos pre-definidos.

@sample CanUseInd( 'CTT_FILIAL' , {} )

@return Lógico, Indica se existe o índice

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function CanUseInd( cIndex, aFldBrw )

	Local nInd
	Local nFldExc
	Local lIndexOk := .T.
	Local aFields  := {}
	Local aFldExc  := { "_FILIAL" }

	If Empty( aFldBrw )
		Return .T.
	EndIf

	// Seleciona campos presentes no indice
	aFields := StrTokArr( AllTrim( cIndex ), "+" )

	// Se prestados, adiciona campos Client e Loja ao array de excessoes
	If lSigaMdtPs
		aAdd( aFldExc, "_CLIENT" )
		aAdd( aFldExc, "_LOJA" )
	EndIf

	// Retira do array campos excessao
	For nInd := 1 To Len( aFldExc )
		nFldExc := aScan( aFields, { |x| aFldExc[nInd] $ AllTrim( x ) } )
		If nFldExc > 0
			aDel( aFields, nFldExc )
			aSize( aFields, Len( aFields ) - 1 )
		EndIf
	Next nInd

	// Verifica se algum dos campos nao esta definido previamente
	For nInd := 1 To Len( aFields )
			If !( lIndexOk := ( aScan( aFldBrw, { |x| x[1] == aFields[nInd] } ) > 0 ) )
				Exit
			EndIf
	Next nInd

	cIndex := ""
	If lIndexOk
		For nInd := 1 To Len( aFields )
			cIndex += IIf( !Empty( cIndex ), "+", "" ) + AllTrim( aFields[nInd] )
		Next nInd
	EndIf

Return lIndexOk

//---------------------------------------------------------------------
/*/{Protheus.doc} RetFldBrw
Define os campos utilizados pelo processo.

@type Function

@source MDTA180.prx

@param aFldBrw, Array, Controle dos campos pre-definidos.
@param cTable, Caracter Tabela a ser analisada

@sample RetFldBrw( {} , 'CTT' )

@return Array, Estrutura de campos do TRB e do Mark

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function RetFldBrw( aFldBrw, cTable )

	Local aArea   := GetArea()
	Local aFldMrk := {}
	Local aFldTrb := {}
	Local aFldEsp := {}
	Local nInd
	Local cCampo

	// Verifica campos selecionados para apresentacao
	For nInd := 1 To Len( aFldBrw )

		cCampo := aFldBrw[nInd][1]
		dbSelectArea( cTable )

		If FieldPos( cCampo ) > 0

			// Define que o campo sera utilizado pelo markbrowse
			SetFldTbl( { AllTrim( cCampo ), GetSx3Cache( cCampo, 'X3_TIPO' ), GetSx3Cache( cCampo, 'X3_TAMANHO' ), GetSx3Cache( cCampo, 'X3_DECIMAL' ),;
					 GetSx3Cache( cCampo, 'X3_PICTURE' ), Posicione( 'SX3', 2, cCampo, 'X3Titulo()' ) }, @aFldMrk, @aFldTrb, aFldBrw[nInd] )
		Else

			// Verifica se o campo existe na relacao de campos especificos
			aFldEsp := GetCpEspAt( cCampo, cTable )
			If !Empty( aFldEsp )

				// Define que o campo sera utilizado pelo markbrowse
				SetFldTbl( { aFldEsp[1], aFldEsp[2], aFldEsp[3], aFldEsp[4], aFldEsp[5], aFldEsp[6] },;
						 @aFldMrk, @aFldTrb, aFldBrw[nInd] )
			EndIf

		EndIf
	Next nInd

	RestArea( aArea )

Return { aFldTrb, aFldMrk }

//---------------------------------------------------------------------
/*/{Protheus.doc} GetCpEspAt
Verifica e retornar campo definido de forma específica, atraves da funcao GetFldEsp().

@type Function

@source MDTA180.prx

@param cField, Caracter, Campo a ser verificado.
@param cTable, Caracter, Tabela a ser verificada.

@sample GetCpEspAt( 'CTT_CODIGO' , 'CTT' )

@return Numérico, Posição do campo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function GetCpEspAt( cField, cTable )

	Local aFldEsp := GetFldEsp( cTable )
	Local nPosFld := 0

	// Verifica se o campo informado esta presente nos campos especificos
	nPosFld := aScan( aFldEsp, { |x| x[1] == cField } )

Return IIf( nPosFld > 0, aFldEsp[nPosFld], {} )

//---------------------------------------------------------------------
/*/{Protheus.doc} GetFldEsp
Define e retorna campos especificos para o processo em questao.

@type Function

@source MDTA180.prx

@param cTable, Caracter, Tabela a ser verificada.

@sample GetFldEsp( 'CTT' )

@return Array, Estrutura do campo de marcação

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function GetFldEsp( cTable )

	Local aFldEsp := {}

	If cTable == "CTT"     // Centro de Custo
		aAdd( aFldEsp, { "CTT_OK", "C", 2, 0, "", " " } )
	ElseIf cTable == "SRJ" // Funcao
		aAdd( aFldEsp, { "RJ_OK", "C", 2, 0, "", " " } )
	ElseIf cTable == "TN5" // Tarefa
		aAdd( aFldEsp, { "TN5_OK", "C", 2, 0, "", " " } )
	ElseIf cTable == "TOS" // Funcao [Prestador]
		aAdd( aFldEsp, { "TOS_OK", "C", 2, 0, "", " " } )
	ElseIf cTable == "SQB"
		aAdd( aFldEsp, { "QB_OK", "C", 2, 0, "", " " } )
	EndIf

Return aFldEsp

//---------------------------------------------------------------------
/*/{Protheus.doc} SetFldTbl
Define os campos, e suas especificações, para montagem do alias e do browse do markbrowse.

@type Function

@source MDTA180.prx

@param aField, Array, Campos e suas especificacoes.
@param aFldMrk, Array, Controle dos campos apresentados no markbrowse.
@param aFldTrb, Array, Controle dos campos presentes no alias do markbrowse.
@param aFldBrw, Array, Controle dos campos pre-definidos.

@sample SetFildTbl( {} , {} , {} , {} )

@return Nulo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function SetFldTbl( aField, aFldMrk, aFldTrb, aFldBrw )

	// Se a apresentacao no markbrowse deve ser considerada, e se o campo foi definido para tal processo
	If ( Len( aFldBrw ) == 1 .Or. aFldBrw[Len( aFldBrw )] )
		aAdd( aFldMrk, { aField[1], Nil, aField[6] } ) // Campos apresentados pelo markbrowse
	EndIf
	aAdd( aFldTrb, { aField[1], aField[2], aField[3], aField[4] } ) // Campos para o alias temporario

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt180MSlc
Tela para multipla selecao de Centro de Custos, Funcoes ou Tarefas.

@type Function

@source MDTA180.prx

@param cField, Caracter, Campo origem. Aquele que efetuou a chamada da funcao.

@sample Mdt180MSlc( 'TN0_CC' )

@return Lógico, Indica se confirmou a tela

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function Mdt180MSlc( cField )

	// Objetos Principais
	Local oWndMSlc
	Local oPnlWnd
	Local oPnlTop
	Local oPnlBtm
	Local oPnlMrk
	Local oPnlTit

	// Variaveis de controle
	Local lConfirm
	Local nTamFld
	Local nLin
	Local nMrkd

	Local aEstTrbAt := {} // Array estrutura atual
	Local aArrMrk   := {} // Array com itens marcados

	// Objetos Secundarios
	Local oGetNumRis
	Local oSayNumRis
	Local oGetNmAgnt
	Local oSayNmAgnt
	Local oGetPsq
	Local oBtnPsq
	Local oCbbInd

	// Variaveis controle objeto
	Local cCbbInd
	Local cMrkPsq

	// Variaveis textos/titulos
	Local cTitleAt  := "" // Titulo janela
	Local cTextPrc  := "" // Primeiro trecho de apresentacao
	Local cTextPrc2 := "" // Segundo trecho de apresentacao

	// Variaveis de controle da tabela atual
	Local cAliasTrbAt := "" // Alias temporario
	Local aIndices    := {} // Indices Markbrowse
	Local aFldTrb     := {} // Campos tabela temporaria
	Local aFldMrk     := {} // Campos Markbrowse

	// Controle de confirmacao tela
	Local lExecute := .F.

	// Define parametros para construcao da tela
	SetPrmTela( cField, @aEstTrbAt, @cTitleAt, @cTextPrc, @cTextPrc2 )

	// Caso nao haja nenhum estrutura selecionada, retorna operacao
	If Len( aEstTrbAt ) == 0
		Return .F.
	EndIf

	cAliasTrbAt := aEstTrbAt[2] // Alias tabela temporaria
	aIndices    := aEstTrbAt[3] // Array Indices
	aFldTrb     := aEstTrbAt[4] // Campos tabela temporaria
	aFldMrk     := aEstTrbAt[5] // Campos markbrowse

	// Salva/Armazena itens marcados no alias utilizado pelo markbrowse
	aArrMrk := SaveMark( cAliasTrbAt, Len( aIndices ), aFldTrb )

	// Alimenta tabela temporaria conforme a tabela de referencia, e os itens marcados
	Processa( { |lEnd| LoadTrb( aEstTrbAt, aArrMrk, cMrkBrw180 ) }, STR0036 ) // "Carregando Informações"

	cCbbInd := aIndices[1] // Define combobox com o primeiro indice
	cMrkPsq := Space( 200 )  // Define tamanho da variavel de pesquisa

	dbSelectArea( cAliasTrbAt )

	Define MsDialog oWndMSlc Title OemToAnsi( cTitleAt ) From 0, 0 To 580, 560 Of oMainWnd Pixel

		// Panel Principal
		oPnlWnd       := TPanel():New( 0, 0, , oWndMSlc, , , , , , 0, 0 )
		oPnlWnd:Align := CONTROL_ALIGN_ALLCLIENT

			// Panel Topo - Campos Risco e Nome do Agente
			oPnlTop       := TPanel():New( 0, 0, , oPnlWnd, , , , , , 0, 20 )
			oPnlTop:Align := CONTROL_ALIGN_TOP

				// Campo Num. Risco
				oSayNumRis := TSay():New( 07.5, 09, { || STR0037 }, oPnlTop, , , , , , .T., , , 100, 20 ) // "Num. Risco"
				oGetNumRis := TGet():New( 06, 38, { |u| IIf( PCount() > 0, M->TN0_NUMRIS := u, M->TN0_NUMRIS ) },;
										 oPnlTop, 040, 008, , , , , , , , .T., , , { || .F. } )

				// Campo Nome do Agente
				oSayNmAgnt := TSay():New( 07.5, 90, { || STR0038 }, oPnlTop, , , , , , .T., , , 100, 20 ) // "Nome do Agente"
				oGetNmAgnt := TGet():New( 06, 133, { |u| IIf( PCount() > 0, M->TN0_NOMAGE := u, M->TN0_NOMAGE ) },;
										 oPnlTop, 130, 008, , , , , , , , .T., , , { || .F. } )

			// Panel Baixo Referencial
			oPnlBtm       := TPanel():New( 0, 0, , oPnlWnd, , , , , , 0, 0 )
			oPnlBtm:Align := CONTROL_ALIGN_ALLCLIENT

				// Panel Topo - Texto Referencia
				oPnlTit := TPanel():New( 0, 0, , oPnlBtm, , , , , , 0, 55 )
				oPnlTit:Align := CONTROL_ALIGN_TOP

					// Grupo - Area Texto
					TGroup():New( 03, 09, 27, 274, "", oPnlTit, , , .T.)

					// Texto Referencia
					TSay():New( 07, 013, { || cTextPrc  }, oPnlTit, , , , , , .T., , , 200, 10 )
					TSay():New( 16, 013, { || cTextPrc2 }, oPnlTit, , , , , , .T., , , 200, 10 )

				// Panel Baixo - Markbrowse Referencia
				oPnlMrk       := TPanel():New( 0, 0, , oPnlBtm, , , , , , 0, 0 )
				oPnlMrk:Align := CONTROL_ALIGN_ALLCLIENT

					// Markbrowse - Referencia
					oMrkAval := MsSelect():New( cAliasTrbAt, aFldMrk[1][1], , aFldMrk, , cMrkBrw180, , , , oPnlMrk )
					oMrkAval:oBrowse:lHasMark    := .T.
					oMrkAval:oBrowse:lCanAllMark := .T.
					oMrkAval:bMark               := { || SetMrkAval( aEstTrbAt, cMrkBrw180, oMrkAval, 1 ) }
					oMrkAval:oBrowse:bAllMark    := { || SetMrkAval( aEstTrbAt, cMrkBrw180, oMrkAval, 2 ) }
					oMrkAval:oBrowse:Align       := CONTROL_ALIGN_ALLCLIENT

					// Pesquisa
					CrtPsqBrw( aEstTrbAt, cCbbInd, @cMrkPsq, { oPnlTit, oMrkAval } )

		oWndMSlc:lEscClose := .F.   // Retira action da tecla 'ESC' para fechamento a janela
		oMrkAval:oBrowse:SetFocus() // Define foco no markbrowse

	Activate MsDialog oWndMSlc On Init EnchoiceBar( oWndMSlc, { || SetOkBrwMs( @lExecute, oWndMSlc ) }, { || oWndMSlc:End() } ) Centered

	If !lExecute // Se nao confirmou a tela do markbrowse
		Processa( { |lEnd| RestMark( cAliasTrbAt, aArrMrk, aFldTrb ) }, STR0059 ) // "Restaurando..."
	EndIf

	nTamFld  := Len( &( "M->" + cField ) ) 											// Tamanho do campo de referencia
	lConfirm := !TblIsEmpty( { cAliasTrbAt, aFldMrk[1][1], aIndices } )	// Verifica se a tabela possui algum item marcado

	// Atualiza campo referencia conforme itens marcados no markbrowse
	If !lConfirm
		&( "M->" + cField ) := Space( nTamFld ) // Limpa conteudo do campo
	Else
		&( "M->" + cField ) := Padr( "#", nTamFld ) // Informa '#' como conteudo do campo
	EndIf

Return lConfirm

//---------------------------------------------------------------------
/*/{Protheus.doc} RestMark
Restaura estado do markbrowse.

@type Function

@source MDTA180.prx

@param cAliasTrbAt, Caracter, Alias temporario markbrowse.
@param aArrMrk, Caracter, Array com registros marcados. (Save)
@param aFldTrb, Caracter, Array campos tabela temporaria.

@sample RestMark( 'SCG0001' , {} , {} )

@return Nulo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function RestMark( cAliasTrbAt, aArrMrk, aFldTrb )

	// Retorna estado anterior ao inicio da abertura da tela, conforme array definido inicialmente
	dbSelectArea( cAliasTrbAt )
	dbGotop()
	ProcRegua( 0 )
	While !Eof()
		RecLock( cAliasTrbAt, .F. )
			If aScan( aArrMrk, { |x| x == &( cAliasTrbAt + "->" + aFldTrb[2][1] ) } ) > 0
				&( cAliasTrbAt + "->" + aFldTrb[1][1] ) := cMrkBrw180 // Efetua marcacao
			Else
				&( cAliasTrbAt + "->" + aFldTrb[1][1] ) := Space( 2 )
			EndIf
		MsUnlock( cAliasTrbAt )

		dbSelectArea( cAliasTrbAt )
		dbSkip()
	End

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} CrtPsqBrw
Cria area de pesquisa do markbrowse.

@type Function

@source MDTA180.prx

@param aEstTrbAt, Array, Estrutura do alias atual.
@param cCbbInd, Caracter, Variavel/String do combobox.
@param cMrkPsq, Caracter, Variavel/String do campo de pesquisa.
@param aObjs, Array, Objetos pais.

@sample CrtPsqBrw( {} , 'TN0_OK' , 'PUDIM' , {} )

@return Nulo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function CrtPsqBrw( aEstTrbAt, cCbbInd, cMrkPsq, aObjs )

	Local oGetPsq, oBtnPsq, oCbbInd

	cCbbInd := aEstTrbAt[3][1] // Inicializa ComboBox

	// Campo de Pesquisa
	oGetPsq    := TGet():New( 35, 130, {|u| IIf( PCount() > 0, cMrkPsq := u, cMrkPsq ) }, aObjs[1], 100, 09, "",;
							 { ||  }, , , , .T., , .T., , .T., , .F., .F., , .F., .F., , cMrkPsq, , , , .T. )

	// Botao Pesquisar
	oBtnPsq    := TButton():New( 35, 233, STR0001, aObjs[1],; // "Pesquisar"
								 { || SearchMrk( aEstTrbAt, aObjs[2], cMrkPsq, oGetPsq ) }, 40, 11.5, , , , .T. )

	// Combobox de Indices
	oCbbInd    := TComboBox():New( 35, 57, { |u| IIf( PCount() > 0, cCbbInd := u, cCbbInd ) }, aEstTrbAt[3], 70, 22, aObjs[1], , ,;
								 { ||  }, , , .T., , , , { ||.T. }, , , , , "cCbbInd" )

	oCbbInd:bChange := { || SetIndexCbb( cCbbInd, aEstTrbAt, aObjs[2], @cMrkPsq, oGetPsq, oBtnPsq ) }

	// Aplica primeiro indice selecionado
	SetIndexCbb( cCbbInd, aEstTrbAt, aObjs[2], @cMrkPsq, oGetPsq, oBtnPsq )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} SetPrmTela
Define parametros para construcao da tela.

@type Function

@source MDTA180.prx

@param cField, Caracter, Campo a ser analisado.
@param aEstTrbAt, Array, Estrutura da tabela atual.
@param cTitleAt, Caracter, Titulo da tela.
@param cTextPrc, Caracter, Primeiro trecho do texto de apresentacao.
@param cTextPrc2, Caracter, Segundo trecho do texto de apresentacao.

@sample SetPrmTela( 'TN0_CC' , {} , 'Titulo' , 'Texto1' , 'Texto2' )

@return Nulo

@Obs Uso da função - MDTA180 | MDTUTIL(filtro do campo TN0_DEPTO)

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Function SetPrmTela( cField, aEstTrbAt, cTitleAt, cTextPrc, cTextPrc2 )

	cTextPrc2 := STR0039 // "Selecione aquelas em que o agente está presente."

	If cField == "TN0_CC" .And. Type( "aEst180CC" ) == "A"
		aEstTrbAt  := aClone( aEst180CC )
		cTitleAt   := STR0040 // "Centro de Custos"
		cTextPrc   := STR0041 // "Estes são os Centros de Custo cadastrados no sistema."
		cTextPrc2  := STR0042 // "Selecione aqueles em que o agente está presente."
	ElseIf cField == "TN0_CODFUN" .And. Type( "aEst180Fun" ) == "A"
		aEstTrbAt  := aClone( aEst180Fun )
		cTitleAt   := STR0043 // "Funções"
		cTextPrc   := STR0044 // "Estas são as Funções cadastrados no sistema."
	ElseIf cField == "TN0_CODTAR" .And. Type( "aEst180Tar" ) == "A"
		 aEstTrbAt := aClone( aEst180Tar )
		 cTitleAt  := STR0045 // "Tarefas"
		 cTextPrc  := STR0046 // "Estas são as Tarefas cadastrados no sistema."
	ElseIf cField == "TN0_DEPTO" .And.  Type( "aEst180Dpt" ) == "A"
		aEstTrbAt  := aClone( aEst180Dpt )
		cTitleAt   := STR0117 //"Departamentos"
		cTextPrc   := STR0115 //"Estes são os Departamentos cadastrados no sistema."
		cTextPrc2  := STR0042 // "Selecione aqueles em que o agente está presente."
	EndIf

Return


//---------------------------------------------------------------------
/*/{Protheus.doc} LoadTrb
Define dados para tabela temporaria referida

@type Function

@source MDTA180.prx

@param aEstTrbAt, Array, Estrutura da tabela atual.
@param aArrMrk, Array, Conteudo os registros marcados/selecionados.
@param cMrkBrw, Caracter, Marca utilizada pelo markbrowse. Definida inicialmente atraves da funcao GetMark().

@sample LoadTrb( {} , {} , 'OK' )

@return Nulo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function LoadTrb( aEstTrbAt, aArrMrk, cMrkBrw )

	Local nField
	Local cFldOri
	Local cFldDest
	Local cKey
	Local cWhile
	Local nFld
	Local nFldPos
	Local cTrbAux  := ""
	Local cTableAt := aEstTrbAt[1][1]		 // Alias de referencia
	Local nIdxKey  := aEstTrbAt[1][2]		 // Indice chave do alias de referencia
	Local cTrbAt   := aEstTrbAt[2]			 // Alias temporario
	Local aFldTrb  := aEstTrbAt[4]			 // Campos tabela temporaria
	Local aAreaTbl := GetArea( cTableAt )	 // Area alias de referencia
	Local aAuxCTT  := {}
	Local cPrfxAt  := PrefixoCpo( cTableAt ) // Prefixo utilizado pelos campos da tabela de referencia
	Local lCTT	   := cTableAt == "CTT"      //Verifica se o Alias é do Centro de Custo
	Local lSQB	   := cTableAt == "SQB"      //Verifica se o Alias é do Departamento
	Local lCentro  := .T.

	// Define estrutura while, conforme campo filial
	cKey   := xFilial( cTableAt )
	cWhile := cTableAt + "->" + cPrfxAt + "_FILIAL"

	If lSigaMdtPs
		cKey += cCliMdtPs
		If cTableAt == "CTT"
			cWhile += " + SubStr(CTT->CTT_CUSTO,1," +  cValToChar( Len( cCliMdtPs ) ) + ")"
		Else
			cWhile := cTableAt + "->(" + cPrfxAt + "_FILIAL" + "+" + cPrfxAt + "_CLIENT" + "+" + cPrfxAt + "_LOJA" + ")"
		EndIf
	EndIf

	If lSQB
		SetPrmTela( "TN0_CC", @aAuxCTT )
		cTrbAux := aAuxCTT[ 2 ]
		nFldPos := aScan( aAuxCTT[ 4 ], { | x | x[ 1 ] == "CTT_CUSTO" } )
	EndIf

	// Limpa alias temporario
	dbSelectArea( cTrbAt )
	ZAP

	// Seleciona tabela de referencia
	dbSelectArea( cTableAt )
	dbSetOrder( nIdxKey )
	dbSeek( cKey )
	ProcRegua( 0 )
	While !Eof() .And. cKey == &cWhile.
		If lCTT//Verificar se o Alias é do Centro de custo
			lCentro:= MDT180Fil( 1 )//Verificar se o Centro de Custo não esta bloqueado
		EndIf

		If lSQB .And. nFldPos > 0
			lCentro := MDT180Fil( 2, , , cTrbAux )
		EndIf

		If lCentro
			dbSelectArea( cTrbAt )
			RecLock( cTrbAt, .T. )
				// Alimenta tabela temporaria com o conteudo da tabela de referencia
				For nField := 1 To (cTrbAt)->(FCount())
	   				If NgCaDicBase( FieldName( nField ), "A", cTableAt, .F. )
						cFldOri  := cTableAt + "->" + FieldName( nField )
						cFldDest := cTrbAt   + "->" + FieldName( nField )
						Replace &cFldDest. with &cFldOri.
					EndIf
				Next nField

				// Caso o item exista no array de Marcados, marca item
	   			If ( nFld := aScan( aArrMrk, { |x| x == &( cTrbAt + "->" + aFldTrb[2][1] ) } ) ) > 0
	   				&( cTrbAt + "->" + aFldTrb[1][1] ) := cMrkBrw
	   			EndIf
			(cTrbAt)->(MsUnlock())
		EndIf
		dbSelectArea( cTableAt )
		dbSkip()

	End

	RestArea( aAreaTbl )

	dbSelectArea( cTrbAt )
	dbSetOrder( 1 )
	dbGoTop()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} SaveMark
Retorna um array com os itens marcados no Alias do markbrowse em questao.

@type Function

@source MDTA180.prx

@param cTableAt, Caracter, Alias utilizado para verificacao. Alias do markbrowse.
@param nLastInd, Numérico, Ultimo indice definido. Indice 'Marcados'.
@param aCpsTrb, Array, Campos utilzados pelo Alias repassado.

@sample SaveMark( 'CTT', 3 , {} )

@return Array, Valores marcados

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function SaveMark( cTableAt, nLastInd, aCpsTrb )

	Local aArea    := GetArea()
	Local aAreaTrb := (cTableAt)->(GetArea())
	Local aArrMrk  := {}

	// Percorre tabela temporaria, armazenando itens marcados
	dbSelectArea( cTableAt )
	dbSetOrder( nLastInd )
	dbGoBottom()
	While !Bof() .And. !Empty( &( cTableAt + "->" + aCpsTrb[1][1] ) )
		aAdd( aArrMrk, &( cTableAt + "->" + aCpsTrb[2][1] ) )
		dbSelectArea( cTableAt )
		dbSkip( -1 )
	End

	RestArea( aAreaTrb )
	RestArea( aArea )

Return aArrMrk

//---------------------------------------------------------------------
/*/{Protheus.doc} TblIsEmpty
Verifica se a tabela esta vazia.

@type Function

@source MDTA180.prx

@param aEstTrbIE, Array, Estrutura tabela atual.

@sample TblIsEmpty( {} )

@return Lógico, Indica se tabela está vazia

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function TblIsEmpty( aEstTrbIE )

	Local aArea    := GetArea()
	Local aAreaTrb := (aEstTrbIE[1])->(GetArea())

	Local nLastInd := 0
	Local lRet

	Default aEstTrbIE := {}

	// Se nao houver estrutura definida
	If Len( aEstTrbIE ) == 0
		Return .F.
	EndIf

	// Seta indice de Marcados, e verifica se ha algum item marcado ou o alias esta vazio
	dbSelectArea( aEstTrbIE[1] )
	dbSetOrder( Len( aEstTrbIE[3] ) )
	dbGoBottom()
	lRet := Eof() .Or. Empty( &( aEstTrbIE[1] + "->" + aEstTrbIE[2] ) )

	RestArea( aAreaTrb )
	RestArea( aArea )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} SetMrkAval
Funcao para marcacao de registro(s) no markbrowse.

@type Function

@source MDTA180.prx

@param aEstTrbAt, Array, Estrutura tabela temporaria atual.
@param cMrkBrw, Caracter, Marca utilizada pelo markbrowse [GetMark()].
@param oMrkAval,Objeto, Objeto markbrowse.
@param nCall, Numérico, Define origem da chamada.
					  Opcoes: 1 - Marcacao de um item. [Mark]
					          2 - Marcacao de todos os itens. [AllMark]

@sample SetMrkAval( {} , 'OK' , oObj , 1 )

@return Nulo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function SetMrkAval( aEstTrbAt, cMrkBrw, oMrkAval, nCall )

	Local aArea     := {}
	Local cAliasTbl := aEstTrbAt[2] 			// Tabela temporaria atual
	Local cFldOk    := aEstTrbAt[5][1][1]	// Campo OK tabela
	Local cVarOk

	Default nCall := 1

	dbSelectArea( cAliasTbl )

	// Se foi chamada pelo AllMark do markbrowse
	If nCall == 2

		aArea := GetArea()
		dbSelectArea( cAliasTbl )
		dbSetOrder( 1 )
		dbGoTop()
		While !Eof()
			// Conteudo do campo OK da tabela
			cVarOk := &(cAliasTbl + "->" + cFldOk)

			// Atualiza campos de controle de marcacao
			RecLock( cAliasTbl, .F. )
				&( cAliasTbl + "->" + cFldOk ) := IIf( Empty( cVarOk ), cMrkBrw, Space( Len( cMrkBrw ) ) )
			(cAliasTbl)->(MsUnlock())

			dbSelectArea( cAliasTbl )
			(cAliasTbl)->(dbSkip())
		End
		RestArea( aArea )

	EndIf

	// Atualiza markbrowse
	oMrkAval:oBrowse:Refresh()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} SetIndexCbb
Aplica ordenacao selecionada no combobox de indices.

@type Function

@source MDTA180.prx

@param cCbbInd, Caracter, Variavel/String do combobox.
@param aEstTrbAt, Array, Estrutura alias atual.'
@param oBrwMrk, Objeto, Objeto do markbrowse.
@param cMrkPsq, Caracter, Variavel/String do campo de pesquisa.
@param oGetPsq, Objeto, Objeto do campo de pesquisa.
@param oBtnPsq, Objeto, Objeto do botao de pesquisa.

@sample SetIndexCbb( 'CTT_FILIAL' , {} , oObj , 'PUDIM', oObj , oObj )

@return Lógico, Sempre verdadeiro

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function SetIndexCbb( cCbbInd, aEstTrbAt, oBrwMrk, cMrkPsq, oGetPsq, oBtnPsq )

	Local nIndice := RetIndCbb( cCbbInd, aEstTrbAt[3] ) // Retorna numero do indice selecionado

	// Efetua ordenacao do alias do markbrowse, conforme indice selecionado
	dbSelectArea( aEstTrbAt[2] )
	dbSetOrder( nIndice )
	dbGoTop()

	// Se o indice selecionado for o ultimo [Marcados]
	If nIndice == Len( aEstTrbAt[3] )
		cMrkPsq := Space( Len( cMrkPsq ) ) // Limpa campo de pesquisa
		oGetPsq:Disable()              // Desabilita campo de pesquisa
		oBtnPsq:Disable()              // Desabilita botao de pesquisa
		oBrwMrk:oBrowse:SetFocus()     // Define foco no markbrowse
	Else
		oGetPsq:Enable()               // Habilita campo de pesquisa
		oBtnPsq:Enable()               // Habilita botao de pesquisa
		oGetPsq:SetFocus()             // Define foco no campo de pesquisa
	EndIf

	oBrwMrk:oBrowse:Refresh()

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} RetIndCbb
Retorna o indice, em numero, do item selecionado no combobox

@type Function

@source MDTA180.prx

@param cCbbInd, Caracter, Indice/Item selecionado no combobox.
@param aIndMrk, Array, Indices de pesquisa do markbrowse.

@sample RetIndCbb( 'CTT_CODIGO' , { } )

@return Numerico, Valor do índice de pesquisa

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function RetIndCbb( cCbbInd, aIndMrk )

	Local nIndice := aScan( aIndMrk, { |x| AllTrim( x ) == AllTrim( cCbbInd ) } )

	// Se o indice nao foi encontrado nos indices pre-definidos, apresenta mensagem
	If nIndice == 0
		ShowHelpDlg( STR0013, { STR0047 }, 1,; // "Atenção" ## "Índice não encontrado."
					 { STR0048 }, 1 )          // "Contate o administrador do sistema."
		nIndice := 1
		cCbbInd := aIndMrk[1]
	EndIf

Return nIndice

//---------------------------------------------------------------------
/*/{Protheus.doc} SearchMrk
Efetua pesquisa no markbrowse.

@type Function

@source MDTA180.prx

@param aEstTrbAt, Array, Estrutura tabela e markbrowse.
@param oBrwMrk, Objeto, Objeto do markbrowse.
@param cMrkPsq, Caracter, Variavel/String do campo de pesquisa.
@param oGetPsq, Objeto, Objeto do campo de pesquisa.

@sample SearchMrk( {} , oObj , 'PUDIM' , oObj )

@return Lógico, Indica se localizou a pesquisa

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function SearchMrk( aEstTrbAt, oBrwMrk, cMrkPsq, oGetPsq )

	Local aArea := GetArea()

	// Efetua pesquisa, e caso nao encontrado apresenta mensagem
	dbSelectArea( aEstTrbAt[2] )
	lFound := dbSeek( AllTrim( cMrkPsq ) )

	If !lFound
		ShowHelpDlg( STR0032, { STR0049 }, 1,; // "Atenção" ## "Nenhum resultado foi encontrado."
					 { STR0050 }, 1 )          // "Realize uma nova pesquisa."
		RestArea( aArea )
	EndIf

	// Atualiza markbrowse
	oBrwMrk:oBrowse:Refresh( .T. )

	// Se a pesquisa nao encontrou nenhum resultado
	If !lFound
		oGetPsq:SetFocus() // Define foco no campo de pesquisa
	Else
		oBrwMrk:oBrowse:SetFocus() // Define foco no markbrowse
	EndIf

Return lFound

//---------------------------------------------------------------------
/*/{Protheus.doc} SetOkBrwMs
Funcao de confirmacao da tela principal.

@type Function

@source MDTA180.prx

@param lExecute, Lógico, Variavel de controle para finalizacao da tela.
@param oWndBrw, Objeto, Objeto principal [MsDialog].

@sample SetOkBrwMs( .T. , oObj )

@return Nulo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function SetOkBrwMs( lExecute, oWndMSlc )

	lExecute := .F.

	If .T.
		lExecute := .T.
		oWndMSlc:End()
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt180PrdQ
Tela para relacionamento de Produtos Quimicos.

@type Function

@source MDTA180.prx

@param nOpcx, Numérico, Valor da operação
@param [lCpyRisc], Lógico, Indica se é copia de risco

@sample Mdt180PrdQ( 3 )

@return Nulo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Function Mdt180PrdQ( nOpcx, lCpyRisc )

	Local oWndPrdQ
	Local oPnlWnd
	Local oPnlTop
	Local oPnlBtm

	Local oSayNumRis
	Local oSayAgnt
	Local oSayNmAgnt
	Local oGetNumRis
	Local oGetAgnt
	Local oGetNmAgnt
	Local aSize     := MsAdvSize( , .F., 430 )
	Local lOlnyVis  := Str( nOpcx, 1 ) $ "2/5"
	Local aNoFields := { "TJD_NUMRIS", "TJD_AGENTE", "TJD_DESAGE" }
	Local aColsCln  := {}

	Local cKey
	Local nOrd
	Local bWhile
	Local cErMsg := ""

	Local lExecute := .F.
	Local nLin

	Default lCpyRisc:= .F.

	Private oGetPrdQ

	If Type( "aHead180PQ" ) != "A"
		Return
	EndIf

	If Empty( M->TN0_AGENTE )
		cErMsg := STR0060 // "Agente não informado."
	ElseIf NGSEEK( "TMA", M->TN0_AGENTE, 1, "TMA_GRISCO" ) != "2"
		cErMsg := STR0061 // "Agente inválido."
	EndIf

	If !Empty( cErMsg )
		ShowHelpDlg( STR0032, { cErMsg + CRLF + STR0062 }, 1,; // "Atenção" ## "O relacionamento de Produtos Químicos, só é permissível para agentes do grupo 'Químico'."
					 { STR0063 }, 1 )                          // "Informe corretamente o Agente."
		Return
	EndIf

	dbSelectArea( "TJD" )

	// Contrucao dos parametros aHeader e aCols para uso da getdados de Produto Quimico
	If Type( "aHead180PQ" ) == "A" .And. Empty( aHead180PQ )
		SelPQKeyAt( nOpcx, , lCpyRisc )
	EndIf

	dbSelectArea( "TJD" )
	dbGoTop()
	aColsCln := aClone( aCols180PQ )

	Define MsDialog oWndPrdQ Title OemToAnsi( STR0064 ) From aSize[7], 0 To aSize[6], aSize[5] Of oMainWnd Pixel // "Produtos Químicos"

		// Panel Principal
		oPnlWnd       := TPanel():New( 0, 0, , oWndPrdQ, , , , , , 0, 0 )
		oPnlWnd:Align := CONTROL_ALIGN_ALLCLIENT

			// Panel Topo - Campos Risco e Nome do Agente
			oPnlTop       := TPanel():New( 0, 0, , oPnlWnd, , , , , , 0, 42 )
			oPnlTop:Align := CONTROL_ALIGN_TOP

				// Campo Num. Risco
				oSayNumRis := TSay():New( 07.5, 09, { || STR0065 }, oPnlTop, , , , , , .T., , , 100, 20 ) // "Num. Risco"
				oGetNumRis := TGet():New( 06, 38, { |u| IIf( PCount() > 0, M->TN0_NUMRIS := u, M->TN0_NUMRIS ) },;
										 oPnlTop, 040, 008, , , , , , , , .T., , , { || .F. } )

				// Campo Num. Risco
				oSayAgnt := TSay():New( 22.5, 09, { || STR0066 }, oPnlTop, , , , , , .T., , , 100, 20 ) // "Agente"
				oGetAgnt := TGet():New( 21, 38, { |u| IIf( PCount() > 0, M->TN0_AGENTE := u, M->TN0_AGENTE ) },;
										 oPnlTop, 040, 008, , , , , , , , .T., , , { || .F. } )

				// Campo Nome do Agente
				oSayNmAgnt := TSay():New( 22.5, 90, { || STR0067 }, oPnlTop, , , , , , .T., , , 100, 20 ) // "Nome do Agente"
				oGetNmAgnt := TGet():New( 21, 133, { |u| IIf( PCount() > 0, M->TN0_NOMAGE := u, M->TN0_NOMAGE ) },;
										 oPnlTop, 130, 008, , , , , , , , .T., , , { || .F. } )

			// Panel Produtos Quimicos
			oPnlBtm       := TPanel():New( 0, 0, , oPnlWnd, , , , , , 0, 0 )
			oPnlBtm:Align := CONTROL_ALIGN_ALLCLIENT

					// GetDados - Produtos Quimicos
					PutFileInEof( "TJD" )
					oGetPrdQ := MsNewGetDados():New( 0, 0, 1000, 1000, IIf( !lOlnyVis, GD_INSERT + GD_UPDATE + GD_DELETE, 0 ),;
													 { || MDT180LOK( .F. ) }, { || MDT180LOK( .T. ) }, , , , 9999, , , , oPnlWnd, aHead180PQ, aCols180PQ )
					oGetPrdQ:oBrowse:Align  := CONTROL_ALIGN_ALLCLIENT

		oWndPrdQ:lEscClose := .F.   // Retira action da tecla 'ESC' para fechamento a janela
		oGetPrdQ:oBrowse:SetFocus() // Define foco na GetDados

	Activate MsDialog oWndPrdQ On Init EnchoiceBar( oWndPrdQ, { || SetOkBrw( @lExecute, oWndPrdQ ) }, { || oWndPrdQ:End() } )

	If !lExecute
		aCols180PQ := aClone( aColsCln )
	Else
 		aCols180PQ	:= {}

		For nLin := 1 To Len( oGetPrdQ:aCols )
			If !oGetPrdQ:aCols[nLin][Len( oGetPrdQ:aCols[nLin] )]
				aAdd( aCols180PQ, aClone( oGetPrdQ:aCols[nLin] ) )
			EndIf
		Next
	EndIf
	//Limpa filtro da TJB com TJC
	dbSelectArea( "TJB" )
	Set Filter To

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} SelPQKeyAt
Alimenta aHeader e aCols da getdados de produtos quimicos.

@type Function

@source MDTA180.prx

@param nOpcx, Numérico, Valor da operação
@param [cRisKey], Caracter, Valor de chave do risco
@param [lCpyRisc], Lógico, Indica se é cópia de risco

@sample SelPQKeyAt( 3 )

@return Nulo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function SelPQKeyAt( nOpcx, cRisKey, lCpyRisc )

	Local cKey
	Local nOrd
	Local bWhile
	Local aNoFields := { "TJD_NUMRIS", "TJD_AGENTE", "TJD_DESAGE" }

	Default cRisKey  := TN0->TN0_NUMRIS
	Default lCpyRisc := .F.

	nOpcx := IIf( lCpyRisc, 3, nOpcx )

	If Type( "lSigaMdtPs" ) == "L" .And. lSigaMdtPs
		nOrd   := 3
		cKey   := xFilial( "TJD" ) + cCliMdtPs + cRisKey
		bWhile := {|| TJD->TJD_FILIAL + TJD->TJD_CLIENT + TJD->TJD_LOJA + TJD->TJD_NUMRIS }
		aAdd( aNoFields, "TJD_CLIENT" )
		aAdd( aNoFields, "TJD_LOJA" )
	Else
		nOrd   := 1
		cKey   := xFilial( "TJD" ) + cRisKey
		bWhile := { || TJD->TJD_FILIAL + TJD->TJD_NUMRIS }
	EndIf
	FillGetDados( nOpcx, "TJD", nOrd, cKey, bWhile, { || .T. }, aNoFields, , , , , nOpcx == 3, aHead180PQ, aCols180PQ, , , , , , .T. )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} SetOkBrw
Funcao de confirmacao da tela principal.

@type Function

@source MDTA180.prx

@param lExecute, Lógico, Variavel de controle para finalizacao da tela.
@param oWndPrdQ, Objeto, Objeto principal [MsDialog].

@sample SetOkBrw( .T. , oObj )

@return Nulo

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Static Function SetOkBrw( lExecute, oWndPrdQ )

	lExecute := .F.

	If MDT180LOK( .T. )
		lExecute := .T.
		oWndPrdQ:End()
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180LOK
Validcao para getdados de Risco x Produto Quimico. [TMA x TJD]

@type Function

@source MDTA180.prx

@param [lTudoOk], Lógico, Indica se é validação TudoOK

@sample MDT180LOK()

@return Lógico, Indica se linha está valida

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Function MDT180LOK( lTudoOk )

	Local nCodPro  := aScan( oGetPrdQ:aHeader, { |x| AllTrim( x[2] ) == "TJD_CODPRO" } ) // Codigo do Produto Quimico
	Local lLinOk   := .T.
	Local nLin

	Default lTudoOk := .F.

	// Verificacoes de controle, e exclusao de linha
	If oGetPrdQ:aCols[oGetPrdQ:nAt][Len( oGetPrdQ:aCols[oGetPrdQ:nAt] )]
		Return .T.
	EndIf

	If lTudoOk
		If Len( oGetPrdQ:aCols ) == 1 .And. Empty( oGetPrdQ:aCols[1][nCodPro] )
			Return .T.
		EndIf
	EndIf

	// Avalia campos obrigatorios
	If Empty( oGetPrdQ:aCols[oGetPrdQ:nAt][nCodPro] ) // Codigo do Produto Quimico
		Help( 1, " ", "OBRIGAT2", , oGetPrdQ:aHeader[nCodPro][1], 3, 0 )
		Return .F.
	EndIf

	// Verifica registro duplicado
	For nLin := 1 To Len( oGetPrdQ:aCols )
		If !oGetPrdQ:aCols[nLin][Len( oGetPrdQ:aCols[nLin] )] .And. ( oGetPrdQ:nAt != nLin )
			If oGetPrdQ:aCols[nLin][nCodPro] == oGetPrdQ:aCols[oGetPrdQ:nAt][nCodPro]
				Help( " ", 1, "JAEXISTINF" )
				lLinOk := .F.
				Exit
			EndIf
		EndIf
	Next nLin

	PutFileInEof( "TJD" )

Return lLinOk

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180RRIS
Validação para getdados de Risco x Produto Quimico. [TMA x TJD]

@type Function

@source MDTA180.prx

@param cField, Caracter, Indica campo de chave

@sample MDT180RRIS( 'TN0_NUMRIS' )

@return Lógico, Indica se localizou valor

@author Hugo R. Pereira
@since 07/01/2013
/*/
//---------------------------------------------------------------------
Function MDT180RRIS( cField )

	Local lSigaMdtPs  := GetNewPar( "MV_MDTPS", "N" ) == "S"
	Local cKey
	Local nOrd

	If lSigaMdtPs
		cCliMdtPs := IIf( Type( "cCliMdtPs" ) == "C" .And. !Empty( cCliMdtPs ), cCliMdtPs, SA1->A1_COD + SA1->A1_LOJA )
		cKey := cCliMdtps + cField
		nOrd := 8
	Else
		cKey := cField
		nOrd := 1
	EndIf

Return NGSEEK( 'TN0', cKey, nOrd, 'TN0_AGENTE' )


//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180MAIL
Envia email para RH sobre eliminação de risco insalubre/perigoso

@type Function

@source MDTA180.prx

@param aFuncExp, Array, Informações dos funcionários expostos

@sample MDT180MAIL( {} )

@return Nulo

@author Thiago Henrique dos Santos
@since 12/07/2013
/*/
//---------------------------------------------------------------------
Static Function MDT180MAIL( aFuncExp )

	Local cSERVER  		:= AllTrim( GetNewPar( "MV_RELSERV", "" ) )
	Local cACCOUNT 		:= AllTrim( GetNewPar( "MV_RELACNT", "" ) )
	Local cPASSWORD		:= AllTrim( GetNewPar( "MV_RELPSW", " " ) )
	Local lAUTENTICA 	:= GetMv( "MV_RELAUTH", , .F. )                 //Determina se o Servidor de Email necessita de Autenticação
	Local cUSERAUT 		:= AllTrim( GetMv( "MV_RELAUSR", , cACCOUNT ) )  //Usuário para Autenticação no Servidor de Email
	Local cPASSAUT		:= AllTrim( GetMv( "MV_RELAPSW", , cPASSWORD ) ) //Senha para Autenticação no Servidor de Email
	Local cFROM			:= cACCOUNT
	Local cCC			:= ""
	Local lOK			:= .F.
	Local cMailError	:= ""
	Local nA
	Local cCCO

	Private nTIMEOUT := GetMv( "MV_RELTIME", , 120 ) //Tempo de Espera antes de abortar a Conexão
	Private cError 	   := ""

	Begin Sequence

		CONNECT SMTP SERVER cSERVER ACCOUNT cACCOUNT PASSWORD cPASSWORD TIMEOUT nTIMEOUT RESULT lOK //Considerar Timeout no Envio

		If !lOK
			MsgInfo( STR0095, STR0032 ) //"Falha na Conexão com Servidor de E-Mail" ## "Atencao"
			Break
		EndIf
		If lAUTENTICA
			If !MAILAUTH( cUSERAUT, cPASSAUT )
				MsgInfo( STR0096, STR0032 ) //"Falha na Autenticação do Usuário" ## "Atencao"
				DISCONNECT SMTP SERVER RESULT lOK
				Break
			EndIf
		EndIf

		// MONTA CORPO DO EMAIL
		cBODY := '<html>'
		cBODY := cBODY+'<body>'
		cBODY := cBODY+'<hr>'
		cBODY := cBODY+STR0084+DTOC( dDATABASE ) //"Relatorio de Atualizacao de Insalubridade / Periculosidade - Emissao.: "
		cBODY := cBODY+'<hr>'
		cBODY := cBODY+'<br>'
		cBODY := cBODY+'<br>'+STR0085//#"Eliminação de Risco com caracterização de pagamento Adicional:"
		cBODY := cBODY+'<br>'
		cBODY := cBODY+'<br>'
		cBODY := cBODY+'<table style="text-align: left; width: 1200Px; height: 100px;" border="1" cellpadding="4" cellspacing="1">'
		cBODY := cBODY+'  <tbody>'
		cBODY := cBODY+'    <tr>'
		cBODY := cBODY+'      <th>'+STR0086+'</th>'  //"Risco"
		cBODY := cBODY+'      <th>'+STR0066+'</th>'  //"Agente"
		cBODY := cBODY+'      <th>'+STR0087+'</th>'  //"Matricula"
		cBODY := cBODY+'      <th>'+STR0088+'</th>'  //"Nome"
		cBODY := cBODY+'      <th>'+STR0089+'</th>'  //"Tipo Adicional"
		cBODY := cBODY+'      <th>'+STR0090+'</th>'  //"Perc.SESMT"
		cBODY := cBODY+'      <th>'+STR0091+'</th>'  //"Perc.Folha"
		cBODY := cBODY+'      <th>'+STR0092+'</th>'  //"Data Inicio"
		cBODY := cBODY+'      <th>'+STR0093+'</th>'  //"Data Fim"
		cBODY := cBODY+'    </tr>'
		lOK := .F.

		For nA := 1 To Len( aFuncExp )
			cBODY := cBODY+'<tr>'
			cBODY := cBODY+'  <td>'+M->TN0_NUMRIS+'</td>'
			cBODY := cBODY+'  <td>'+M->TN0_NOMAGE+'</td>'
			cBODY := cBODY+'  <td>'+aFuncExp[nA, 1]+'</td>'
			cBODY := cBODY+'  <td>'+NGSEEK( "SRA", aFuncExp[nA, 1], 1, "RA_NOME" )+'</td>'
			cBODY := cBODY+'  <td>'+M->TN0_VM_ADI+'</td>'
			cBODY := cBODY+'  <td> 0% </td>'
			cBODY := cBODY+'  <td>'+Transform( aFuncExp[nA, 2], '@E 99.99' )+'%'+'</td>'
			cBODY := cBODY+'  <td>'+DTOC( aFuncExp[nA, 3] )+'</td>'
			cBODY := cBODY+'  <td>'+DTOC( M->TN0_DTELIM )+'</td>'
			cBODY := cBODY+'</tr>'

		Next

		cBODY := cBODY+'  </tbody>'
		cBODY := cBODY+'</table>'
		cBODY := cBODY+'</body>'
		cBODY := cBODY+'</html>'
		//ENVIO DE EMAIL
		cTO := AllTrim( MV_PAR01 )
		cCC := cCCO := ""
		SEND MAIL FROM cFROM To cTO CC cCC BCC cCCO SUBJECT STR0099 BODY cBODY RESULT lOK //"Atualizacao de Insalubridade / Periculosidade"

		If ! lOK
			MsgInfo( STR0094, STR0032 )  //"Não foi possível enviar o email. Falha no envio !" ## "Atenção"
		EndIf

		DISCONNECT SMTP SERVER

	End Sequence

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180ALL
Função 'genérica' para realizar diversas ações

@type Function

@source MDTA180.prx

@param cP_PARA, Caracter, Indica o tipo de excução da função
@param [cP_PARB], Caracter, Indica sub-tipo de excução da função

@sample MDT180ALL( '1' )

@return Indefinido, Retorna valor de acordo com  parâmetros de busca

@author
@since
/*/
//---------------------------------------------------------------------
Function MDT180ALL( cP_PARA, cP_PARB )

	Local xRET
	Local cOALIAS
	Local nA
	Local cQRYA
	Local lOK
	Local dDataFim
	Local cModoTN0
	Local aAreaTN0 := TN0->(GetArea())
	Local aAllFil  := {}
	Local nCont    := 0
	Local cEmpAtu  := "" //variavel que indica a empresa atual
	Local cFilAtu  := "" //variavel que indica a filial atual
	Local cEmpFil  := "" //variavel que indica a empresa mais filial logada

	Private cAUX

	If Type( "aTIPADI" ) != "A"
		aTIPADI   := {}
		aX3TIPADI := ComboX3Box( "TMA_TIPADI", X3Cbox() )
		For nA := 1 To Len( aX3TIPADI )
			aAdd( aTIPADI, SubStr( aX3TIPADI[nA], At( "=", aX3TIPADI[nA] ) + 1 ) )
		Next
	EndIf

	dbSelectArea( "TMA" )
	dbSetOrder( 1 )
	dbSeek( xFilial( "TMA" ) + TN0->TN0_AGENTE )

	cOALIAS := Alias()
	xRET    := .F.
	cP_PARA := IIf( cP_PARA == NIL, "", cP_PARA )
	cP_PARA := IIf( ValType( cP_PARA ) == "N", AllTrim( Str( cP_PARA ) ), cP_PARA )

	If cP_PARA == "1" // "LEGENDA VERDE / VERMELHA"

		If TN0->TN0_PERINT == "5" .Or. Empty( TMA->TMA_TIPADI )
			xRET := .T.
		EndIf

	ElseIf cP_PARA == "2" // "LEGENDA AZUL"

		If TN0->TN0_PERINT != "5" .And. !Empty( TMA->TMA_TIPADI )
			xRET := .T.
		EndIf

	ElseIf cP_PARA == "TN0_VM_ADI"

		xRET    := ""
		cP_PARB := IIf( cP_PARB == NIL, "", cP_PARB )
		cAUX    := IIf( cP_PARB == "GET", "M->TN0_AGENTE", "TN0->TN0_AGENTE" )
		TMA->(dbSetOrder( 1 ))

		If (TMA->(dbSeek( xFilial( "TMA" ) + &cAUX )))
			nA := Val( TMA->TMA_TIPADI )
			If nA > 0 .And. nA <= Len( aTIPADI )
				xRET := aTIPADI[nA]
			EndIf
		EndIf

		If cP_PARB == "GET" .And. Empty( xRET )
			M->TN0_PERINT := ""
		EndIf

	ElseIf cP_PARA == "TN0_PERINT" .And. TN0->(FieldPos( "TN0_PERINT" )) > 0

		xRET := .T.//Retorna antiga validação

		If ! Empty( M->TN0_VM_ADI )

			For nA := 1 To Len( aTIPADI )
				If AllTrim( M->TN0_VM_ADI ) == AllTrim( aTIPADI[nA] )
					cAUX := nA
					nA := Len( aTIPADI ) + 1
				EndIf
			Next
			If Empty( M->TN0_PERINT )
				MsgInfo( STR0075 + AVSX3( "TN0_PERINT", 5 ) + " !", STR0032 ) //"Preenchimento obrigatorio do campo " ## "Atencao"
				xRET := .F.
			ElseIf cAUX == 1 // INSALUBRIDADE
				If At( M->TN0_PERINT, "1245" ) == 0
					MsgInfo( STR0076 + AVSX3( "TN0_VM_ADI", 5 ) + STR0077 + aTIPADI[cAUX] + " !", STR0032 ) //"Informe 10% ou 20% ou 40% ou Nao Caracteriza para " ## " igual a " ## "Atencao"
					xRET := .F.
				EndIf
			ElseIf cAUX == 2 // PERICULOSIDADE
				If At( M->TN0_PERINT, "35" ) == 0
					MsgInfo( STR0078 + AVSX3( "TN0_VM_ADI", 5 ) + STR0077 + aTIPADI[cAUX] + " !", STR0032 ) // "Informe 30% ou Nao Caracteriza para " ## " igual a " ## "Atencao"
					xRET := .F.
				EndIf
			EndIf
		EndIf

	EndIf

	If ! Empty( cOALIAS )
		dbSelectArea( cOALIAS )
	EndIf
	RestArea( aAreaTN0 )

Return ( xRET )

//-------------------------------------------------------------------
/*/{Protheus.doc}MDT180BFUN
Busca os funcionários expostos ao risco atual.

@type    function
@author  Julia Kondlatsch
@since   11/06/2019
@sample  MDT180BFUN()
@param   param, param_type, param_descr

@return  Nil, Sempre Nulo
/*/
//-------------------------------------------------------------------
Function MDT180BFUN()

	Local lOK
	Local dDataFim
	Local aAreaTN0 := TN0->(GetArea())
	Local aAllFil  := {}
	Local cModoTN0 := ''
	Local nCont    := 0
	Local cEmpAtu  := '' //Variavel que indica a empresa atual
	Local cFilAtu  := '' //Variavel que indica a filial atual
	Local cEmpFil  := '' //Variavel que indica a empresa mais filial logada
	Local cAlsExpo := GetNextAlias()
	Local cCenCus  := {}
	Local cFuncao  := {}
	Local cTarefa  := {}
	Local cDepto   := {}
	Local cGetDB   := Upper( TcGetDb() ) //Traz a base de dados
	Local cTodos   := 'Todos'
	Local cTodas   := 'Todas'
	Local cValBrc  := '%ISNULL%'
	Local dIniExp  := CToD( '' )
	Local nCntFil  := 0
	Local cFilFun  := "%"
	Local cFilTN6  := xFilial( "TN6", xFilial( "SRA" ) )
	Local cTamData := Space( 8 )

	//Define o ISNULL de acordo com a base de dados
	If cGetDB == "ORACLE" .Or. cGetDB == "INFORMIX"
		cValBrc := "%NVL%"
	ElseIf "DB2" $ cGetDB .Or. cGetDB == "POSTGRES"
		cValBrc := "%COALESCE%"
	ElseIf cGetDB == "OPENEDGE"
		cValBrc := "%IFNULL%"
	Else
		cValBrc := "%ISNULL%"
	EndIf

	PROCREGUA( 0 )

	// Retorna o compartilhamento da Tabela
	cModoTN0 := NGSEEKDIC( 'SX2', 'TN0', 1, 'X2_MODOEMP+X2_MODOUN+X2_MODO' )
	cEmpAtu := FWCompany( 'SRA' ) // Retorna a empresa atual
	cFilAtu := FWFilial( 'SRA' )  // Retorna a filial atual
	cEmpFil := cEmpAtu + cFilAtu  // Empresa mais filial atual

	If Substr( cModoTN0, 3, 1 ) == 'C'
		If SubStr( cModoTN0, 2, 1 ) == 'C'
			If Substr( cModoTN0, 1, 1 ) == 'C'
				aAllFil := MDTRETFIL( 'SRA', Space( Len( SRA->RA_MAT ) ), Replicate( 'Z', Len( SRA->RA_MAT ) ) )
			Else
				aAllFil := MDTRETFIL( 'SRA', cEmpAtu + Space( Len( SRA->RA_MAT ) - 2 ), cEmpAtu + Replicate( 'Z', Len( SRA->RA_MAT ) - 2 ) )
			EndIf
		Else
			aAllFil := MDTRETFIL( 'SRA', cEmpFil + Space( Len( SRA->RA_MAT ) - 5 ), cEmpFil + Replicate( 'Z', Len( SRA->RA_MAT ) - 5 ) )
		EndIf
	Else
		aAdd( aAllFil, { xFilial( 'SRA' ) } )
	EndIf

	If Len( aAllFil ) > 0
		cFilFun += "SRA.RA_FILIAL IN ("
		For nCntFil := 1 To Len( aAllFil )
			cFilFun += "'" + aAllFil[ nCntFil, 1 ] + "'"
			If nCntFil != Len( aAllFil ) //Enquanto não for a última filial, concatena a ","
				cFilFun += ","
			Else
				cFilFun += ") AND%"
			EndIf
		Next nCntFil
	Else
		cFilFun += "%"
	EndIf

	cCenCus  := IIf( AllTrim( M->TN0_CC ) != '#', Alltrim( M->TN0_CC ), "%'" + ArrTokStr( SetArrSlc( "TN0_CC" ), "','" ) + "'%" )            // Centro de Custo
	cFuncao  := IIf( AllTrim( M->TN0_CODFUN ) != '#', Alltrim( M->TN0_CODFUN ), "%'" + ArrTokStr( SetArrSlc( "TN0_CODFUN" ), "','" ) + "'%" ) // Funcao
	cTarefa  := IIf( AllTrim( M->TN0_CODTAR ) != '#', Alltrim( M->TN0_CODTAR ), "%'" + ArrTokStr( SetArrSlc( "TN0_CODTAR" ), "','" ) + "'%" ) // Tarefa
	cDepto   := IIf( AllTrim( M->TN0_DEPTO ) != '#', Alltrim( M->TN0_DEPTO ), "%'" + ArrTokStr( SetArrSlc( "TN0_DEPTO" ), "','" ) + "'%" )    // Departamento

	dDataIni := M->TN0_DTAVAL
	dDataFim := M->TN0_DTELIM

	If "*" $(cTarefa)

		//Busca todos os funcionários expostos ao risco, com ou sem tarefas
		BeginSQL Alias cAlsExpo
			SELECT * FROM (
				SELECT
					SRA.RA_FILIAL, SRA.RA_MAT, SRA.RA_NOME, SRA.RA_ADMISSA,
					SRA.RA_CC, SRA.RA_CODFUNC, SRA.RA_DEPTO,
					TN6.TN6_CODTAR, TN6.TN6_DTINIC, TN6.TN6_DTTERM
				FROM %Table:SRA% SRA
				LEFT JOIN %Table:TN6% TN6 ON
					TN6.TN6_FILIAL = %exp:cFilTN6% AND
					TN6.TN6_MAT = SRA.RA_MAT AND
					( TN6.TN6_CODTAR IN ( %exp:cTarefa% ) OR %exp:AllTrim( M->TN0_CODTAR )% = '*' ) AND
					//Verifica se o período da função do funcioário coincide com o período de existência do risco
					( ( TN6.TN6_DTTERM = %exp:cTamData% AND %exp:dDataFim% = %exp:cTamData% ) OR
					( TN6.TN6_DTTERM != %exp:cTamData% AND %exp:dDataFim% != %exp:cTamData% AND
							NOT( ( TN6.TN6_DTINIC < %exp:dDataIni% AND
								TN6.TN6_DTTERM < %exp:dDataIni% ) OR
								( TN6.TN6_DTINIC > %exp:dDataFim% AND
								TN6.TN6_DTTERM > %exp:dDataFim% ) ) ) OR
					( TN6.TN6_DTTERM != %exp:cTamData% AND %exp:dDataFim% = %exp:cTamData% AND
							NOT ( TN6.TN6_DTINIC < %exp:dDataIni% AND
								TN6.TN6_DTTERM < %exp:dDataIni% ) ) OR
					( TN6.TN6_DTTERM = %exp:cTamData% AND %exp:dDataFim% != %exp:cTamData% AND
							NOT ( %exp:dDataIni% < TN6.TN6_DTINIC AND
								%exp:dDataFim% < TN6.TN6_DTINIC ) ) ) AND
					TN6.%notDel%
				WHERE
					%exp:cFilFun%
					( SRA.RA_CC IN ( %exp:cCenCus% ) OR %exp:AllTrim( M->TN0_CC )% = '*' ) AND
					( SRA.RA_CODFUNC IN ( %exp:cFuncao% ) OR %exp:AllTrim( M->TN0_CODFUN )% = '*' ) AND
					( SRA.RA_DEPTO IN ( %exp:cDepto% ) OR %exp:AllTrim( M->TN0_DEPTO )% = '*' ) AND
					SRA.RA_SITFOLH != 'D' AND SRA.RA_DEMISSA = %exp:cTamData% AND
					( SRA.RA_ADMISSA <= %exp:dDataFim% OR %exp:dDataFim% = %exp:cTamData% ) AND
					SRA.%notDel%
			) TBL
			WHERE '*' IN ( %exp:cTarefa% ) OR %exp:cValBrc%( TN6_DTINIC, %exp:cTamData% ) != %exp:cTamData%
		EndSQL

	Else

		BeginSQL Alias cAlsExpo
			SELECT * FROM (
				SELECT
					SRA.RA_FILIAL, SRA.RA_MAT, SRA.RA_NOME, SRA.RA_ADMISSA,
					SRA.RA_CC, SRA.RA_CODFUNC, SRA.RA_DEPTO,
					TN6.TN6_CODTAR, TN6.TN6_DTINIC, TN6.TN6_DTTERM
			FROM %Table:SRA% SRA
			LEFT JOIN %Table:TN6% TN6 ON
				TN6.TN6_FILIAL = %exp:cFilTN6% AND
				TN6.TN6_MAT = SRA.RA_MAT AND
				( TN6.TN6_CODTAR IN ( %exp:cTarefa% ) OR %exp:AllTrim( M->TN0_CODTAR )% = '*' ) AND
				//Verifica se o período da função do funcioário coincide com o período de existência do risco
				( ( TN6.TN6_DTTERM = %exp:cTamData% AND %exp:dDataFim% = %exp:cTamData% ) OR
				( TN6.TN6_DTTERM != %exp:cTamData% AND %exp:dDataFim% != %exp:cTamData% AND
						NOT( ( TN6.TN6_DTINIC < %exp:dDataIni% AND
							TN6.TN6_DTTERM < %exp:dDataIni% ) OR
							( TN6.TN6_DTINIC > %exp:dDataFim% AND
							TN6.TN6_DTTERM > %exp:dDataFim% ) ) ) OR
				( TN6.TN6_DTTERM != %exp:cTamData% AND %exp:dDataFim% = %exp:cTamData% AND
						NOT ( TN6.TN6_DTINIC < %exp:dDataIni% AND
							TN6.TN6_DTTERM < %exp:dDataIni% ) ) OR
				( TN6.TN6_DTTERM = %exp:cTamData% AND %exp:dDataFim% != %exp:cTamData% AND
						NOT ( %exp:dDataIni% < TN6.TN6_DTINIC AND
							%exp:dDataFim% < TN6.TN6_DTINIC ) ) ) AND
				TN6.%notDel%
			WHERE
				%exp:cFilFun%
				( SRA.RA_CC IN ( %exp:cCenCus% ) OR %exp:AllTrim( M->TN0_CC )% = '*' ) AND
				( SRA.RA_CODFUNC IN ( %exp:cFuncao% ) OR %exp:AllTrim( M->TN0_CODFUN )% = '*' ) AND
				( SRA.RA_DEPTO IN ( %exp:cDepto% ) OR %exp:AllTrim( M->TN0_DEPTO )% = '*' ) AND
				SRA.RA_SITFOLH != 'D' AND SRA.RA_DEMISSA = %exp:cTamData% AND
				( SRA.RA_ADMISSA <= %exp:dDataFim% OR %exp:dDataFim% = %exp:cTamData% ) AND
				SRA.%notDel%
			) TBL
			WHERE
				%exp:cValBrc%( TN6_DTINIC, %exp:cTamData% ) != %exp:cTamData%	
		EndSQL
		
	EndIf

	While ( cAlsExpo )->( !EoF() )

		dDataIni := M->TN0_DTAVAL
		dDataFim := M->TN0_DTELIM

		If Empty( dDataIni ) .Or. !Empty( dDataIni ) .And. dDataIni < SToD( cValToChar( ( cAlsExpo )->RA_ADMISSA ) )
			dDataIni := SToD( cValToChar( ( cAlsExpo )->RA_ADMISSA ) )
		EndIf

		If !Empty( ( cAlsExpo )->TN6_DTINIC ) // Tem Tarefa

			dDataIni := SToD( cValToChar( ( cAlsExpo )->TN6_DTINIC ) )
			If ( Empty( dDataFim ) .And. !Empty( ( cAlsExpo )->TN6_DTTERM ) ) .Or. ;
			   ( !Empty( ( cAlsExpo )->TN6_DTTERM ) .And. SToD( cValToChar( ( cAlsExpo )->TN6_DTTERM ) ) < dDataFim )

				dDataFim := SToD( cValToChar( ( cAlsExpo )->TN6_DTTERM ) )

			EndIf

		EndIf

		// Busca data de início de exposição ao risco
		dIniExp := fChkDtSRE( dDataIni )
		If !Empty( dIniExp )
			dDataIni := dIniExp
		EndIf

		RecLock( 'TMPA', .T. )
			TMPA->TMPA_MATRI := ( cAlsExpo )->RA_MAT
			TMPA->TMPA_NOMFU := ( cAlsExpo )->RA_NOME
			TMPA->TMPA_DTINI := dDataIni
			TMPA->TMPA_DTFIM := dDataFim
			TMPA->TMPA_TAREF := Posicione( 'TN5', 1, xFilial( 'TN5', ( cAlsExpo )->RA_FILIAL ) + ( cAlsExpo )->TN6_CODTAR, 'TN5_NOMTAR' )
			TMPA->TMPA_CCUST := Posicione( 'CTT', 1, xFilial( 'CTT', ( cAlsExpo )->RA_FILIAL ) + ( cAlsExpo )->RA_CC, 'CTT_DESC01' )
			TMPA->TMPA_FUNCA := Posicione( 'SRJ', 1, xFilial( 'SRJ', ( cAlsExpo )->RA_FILIAL ) + ( cAlsExpo )->RA_CODFUNC, 'RJ_DESC' )
			TMPA->TMPA_NVFIL := ( cAlsExpo )->RA_FILIAL // Salva a filial, pois se possuir funcionários de outra filial deve considerar
			TMPA->TMPA_DEPTO := NgSeek( 'SQB', ( cAlsExpo )->RA_DEPTO, 1, 'QB_DESCRIC', ( cAlsExpo )->RA_FILIAL )
		TMPA->(MsUnlock())

		( cAlsExpo )->( dbSkip() )
	End

	( cAlsExpo )->( DbCloseArea() )
	RestArea( aAreaTN0 )

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180FER
Monta tela de funcionários expostos ao Risco

@type Function

@source MDTA180.prx

@sample MDT180FER()

@return Nulo

@author
@since
/*/
//---------------------------------------------------------------------
Static Function MDT180FER()

	Local oDLG
	Local cOALIAS
	Local bOK
	Local bCANCEL
	Local aBUTTONS
	Local nBTOP
	Local aPOS
	Local oMSELECT
	Local aCPOTMPA
	Local cPERINT
	Local aPERINT
	Local aSIZE
	Local nPosCpo
	Local nPosLoc

	Private aHEADER
	Private aCAMPOS
	Private cMARCA
	Private lINVERTE
	Private nTFRIS

	cOALIAS  := ALIAS()
	cTITULO  := STR0080 // "Funcionario Exp. Risco"
	bOK      := { || nBTOP := 1, oDLG:End() }
	bCANCEL  := { || nBTOP := 0, oDLG:End() }
	aBUTTONS := {}
	nBTOP    := 0
	nPosCpo  := 18
	cMARCA   := GetMark()
	aSIZE    := MsAdvSize( , .F., 450 )
	lINVERTE := .F.

	aCPOTMPA := {    { "TMPA_MATRI", , AVSX3( "TN6_MAT", 5 ) },;
					 { "TMPA_NOMFU", , AVSX3( "TN6_NOME", 5 ) },;
					 { "TMPA_DTINI", , AVSX3( "TN6_DTINIC", 5 ) },;
					 { "TMPA_DTFIM", , AVSX3( "TN6_DTTERM", 5 ) },;
					 { "TMPA_TAREF", , AVSX3( "TN0_NOMTAR", 5 ) },;
					 { "TMPA_CCUST", , AVSX3( "TN0_DESCCC", 5 ) },;
					 { "TMPA_FUNCA", , AVSX3( "TN0_DESCFU", 5 ) },;
					 { "TMPA_NVFIL", , AVSX3( "RA_FILIAL", 5 ) },;
					 { "TMPA_DEPTO", , AVSX3( "TN0_DESCDP", 5 ) } }

	aPERINT  := COMBOX3BOX( "TN0_PERINT", X3CBOX() )

	If Val( M->TN0_PERINT ) > 0 .And. Val( M->TN0_PERINT ) <= Len( aPERINT )
		cPERINT := SubStr( aPERINT[Val( M->TN0_PERINT )], At( "=", aPERINT[Val( M->TN0_PERINT )] ) + 1 )
	Else
		cPERINT := STR0081 //"Nao definido"
	ENDIf

	// CARREGA DADOS PARA WORK
	TMPA->(__DBZAP())
	Processa( { || MDT180BFUN() } )
	TMPA->(dbGoTop())

	nTFRIS := TMPA->( Reccount() )

	DEFINE MSDIALOG oDLG TITLE cTITULO FROM aSIZE[7], 0 To aSIZE[6], aSIZE[5] OF oMainWnd PIXEL

		//Painel de Fundo
		oPanel := TPanel():New( 00, 00, , oDLG, , , , , , 0, 0, .F., .F. )
		oPanel:Align   := CONTROL_ALIGN_ALLCLIENT

			//Painel dos campos
			oPanelCmps := TPanel():New( 00, 00, , oPanel, , , , , , 0, 80, .F., .F. )
			oPanelCmps:Align:= CONTROL_ALIGN_TOP
			// Número do Risco
			@ 06, 010 SAY AVSX3( "TN0_NUMRIS", 5 ) PIXEL OF oPanelCmps
			@ 05, 045 MSGET M->TN0_NUMRIS PICTURE AVSX3( "TN0_NUMRIS", 6 ) SIZE 25, 08 WHEN( .F. ) PIXEL OF oPanelCmps
			// Adicional
			@ 06, 090 SAY AVSX3( "TN0_VM_ADI", 5 ) PIXEL OF oPanelCmps
			@ 05, 120 MSGET M->TN0_VM_ADI PICTURE AVSX3( "TN0_VM_ADI", 6 ) SIZE 40, 08 WHEN( .F. ) PIXEL OF oPanelCmps
			// Intensidade
			@ 06, 170 SAY AVSX3( "TN0_PERINT", 5 ) PIXEL OF oPanelCmps
			@ 05, 205 MSGET cPERINT  SIZE 65, 08 WHEN( .F. ) PIXEL OF oPanelCmps
			// Centro de Custo
			@ 19, 010 SAY AVSX3( "TN0_CC", 5 ) PIXEL OF oPanelCmps
			@ 18, 045 MSGET M->TN0_CC     PICTURE AVSX3( "TN0_CC", 6 ) SIZE 035, 08 WHEN( .F. ) PIXEL OF oPanelCmps
			@ 18, 085 MSGET IIf( AllTrim( M->TN0_CC ) == "#", "", M->TN0_DESCCC) PICTURE AVSX3( "TN0_DESCCC", 6 ) SIZE 100,08 WHEN(.F.) PIXEL OF oPanelCmps

			If NGCADICBASE( "TN0_DEPTO", "A", "TN0", .F. )
				nPosCpo += 11
				nPosLoc := nPosCpo + 11
				// Departamento
				@ nPosCpo + 1, 010 SAY AVSX3( "TN0_DEPTO", 5 ) PIXEL OF oPanelCmps
				@ nPosCpo, 045 MSGET M->TN0_DEPTO  PICTURE AVSX3( "TN0_DEPTO", 6 ) SIZE 035,08 WHEN( .F. ) PIXEL OF oPanelCmps
				@ nPosCpo, 085 MSGET M->TN0_DESCDP PICTURE AVSX3( "TN0_DESCDP", 6 ) SIZE 100,08 WHEN( .F. ) PIXEL OF oPanelCmps
			EndIf

			nPosCpo += 11
			// Código da Função
			@ nPosCpo + 1, 010 SAY AVSX3( "TN0_CODFUN", 5 ) PIXEL OF oPanelCmps
			@ nPosCpo, 045 MSGET M->TN0_CODFUN PICTURE AVSX3( "TN0_CODFUN", 6 ) SIZE 037.5, 08 WHEN( .F. ) PIXEL OF oPanelCmps
			@ nPosCpo, 085 MSGET M->TN0_DESCFU PICTURE AVSX3( "TN0_DESCFU", 6 ) SIZE 100, 08 WHEN( .F. ) PIXEL OF oPanelCmps

			nPosCpo += 11
			// Codigo da tarefa
			@ nPosCpo + 1, 010 SAY AVSX3( "TN0_CODTAR", 5 ) PIXEL OF oPanelCmps
			@ nPosCpo, 045 MSGET M->TN0_CODTAR PICTURE AVSX3( "TN0_CODTAR", 6 ) SIZE 37.5,08 WHEN( .F. ) PIXEL OF oPanelCmps
			@ nPosCpo, 085 MSGET M->TN0_NOMTAR PICTURE AVSX3( "TN0_NOMTAR", 6 ) SIZE 100,08 WHEN( .F. ) PIXEL OF oPanelCmps

			nPosCpo += 11
			// Quantidade Localizados
			@ nPosCpo + 1, 010 SAY STR0082 PIXEL OF oPanelCmps  //"Localizados"
			@ nPosCpo, 045 MSGET nTFRIS PICTURE "@E 999,999,999" SIZE 37.5, 08 WHEN( .F. ) PIXEL OF oPanelCmps

			oPanelObj := TPanel():New( 00, 00, , oPanel, , , , , , 0, 0, .F., .F. )
			oPanelObj:Align   := CONTROL_ALIGN_ALLCLIENT

			oMSELECT := MSSELECT():New( "TMPA", , , aCPOTMPA, @lINVERTE, @cMARCA, , , , oPanelObj )
				oMSELECT:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	ACTIVATE MSDIALOG oDLG ON INIT EnchoiceBar( oDLG, bOK, bCANCEL, , aBUTTONS ) CENTERED

	If !Empty( cOALIAS )
		dbSelectArea( cOALIAS )
	EndIf

Return NIL

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180MuAg
Verifica a mudanca de agente, caso for do tipo químico e houver produto
químico relacionado

@obs Funcao no X3_VALID da TN0_AGENTE

@type Function

@source MDTA180.prx

@sample MDt180MuAg()

@return Lógico, Indica se pode apagar os produtos químicos

@author Guilherme Benkendorf
@since 25/04/2013
/*/
//---------------------------------------------------------------------
Function MDT180MuAg()

	Local nX
	Local lVerIf
	Local nIndTJD	:= 1
	Local cCliente	:= ""
	Local lOk		:= .T.
	Local lApaga	:= .F.
	Local aArea		:= GetArea()

	If lSigaMdtPs
		cCliente	:= cCliMdtps
		nIndTJD		:= 3
	End

	If !Empty( cAgeAnt )
		//Caso seja inclusao ou o aCols esteja preenchido, valida sempre com o aCols
		If INCLUI .Or. Len( aCols180PQ ) > 0
			lApaga := Len( aCols180PQ ) > 0 .And. !Empty( aCols180PQ[ 1, 1 ] )
		Else
			//Caso nao, valida com a Base
			dbSelectArea( "TJD" )
			dbSetOrder( nIndTJD )
			lApaga := dbSeek( xFilial( "TJD" ) + cCliente + M->TN0_NUMRIS )
		EndIf
		//Se existir produto quimico relacionado
		If lApaga
			//Verifica se houve alteracao de agente
			If M->TN0_AGENTE != cAgeAnt
				If NGSEEK( "TMA", cAgeAnt, 1, "TMA_GRISCO" ) == "2"
					lVerIf := MsgYesNo( STR0069 + STR0070, STR0032 ) //Atencao//"Ao alterar o agente, os produtos químicos relacionados à este risco serão desvinculados."//Deseja continuar?

					If lVerIf
						cAgeAnt		:= M->TN0_AGENTE
						aCols180PQ	:= BlankGetD( aHead180PQ )
					Else
						M->TN0_AGENTE := cAgeAnt
						M->TN0_NOMAGE := NGSEEK( "TMA", cAgeAnt, 1, "TMA_NOMAGE" )
						lOk := .F.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	//Atualiza cAgeAnt
	cAgeAnt	:= M->TN0_AGENTE

	RestArea( aArea )

Return lOk

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180VAL
Função de validação da Rotina de Riscos

@type Function

@source MDTA180.prx

@param nCpo, Numerico, Indica o indice para a validação. 1 - TN0_DTRECO, 2 - TN0_DTAVAL

@sample MDT180VAL( 1 )

@return Lógico, Indica se está válido

@author Guilherme Benkendorf
@since 17/12/2013
@version MP11
@return lRet - Boolean
/*/
//---------------------------------------------------------------------
Function MDT180VAL( nCpo )

	Local lRet := .T.

	If nCpo == 1 // TN0_DTRECO - Data de Reconhecimento
		If !Empty( M->TN0_DTRECO )
			//Validação de data de reconhecimento maior que a data atual
			lRet :=  ValData( M->TN0_DTRECO, dDataBase, "DATAINVAL" )

			//Validação de data de reconhecimento maior que a data de Avaliação
			If lRet .And. !Empty( M->TN0_DTAVAL )
				If M->TN0_DTRECO > M->TN0_DTAVAL
					ShowHelpDlg( "DATAINVAL", { STR0100 }, 2,; //"Data informada inválida."
								 { STR0101 + " " + AllTrim( NGRETTITULO( "TN0_DTAVAL" ) ) + ". " }, 2 )	//"Informe uma data menor que a"
					lRet := .F.
				EndIf
			EndIf
			//Validação de data de reconhecimento maior que a data de Eliminação
			If lRet .And. !Empty( M->TN0_DTELIM )
				If M->TN0_DTRECO > M->TN0_DTELIM
					ShowHelpDlg( "DATAINVAL", { STR0100 }, 2,; //"Data informada inválida."
								 { STR0101 + " " + AllTrim( NGRETTITULO( "TN0_DTELIM" ) ) + ". " }, 2 )	//"Informe uma data menor que a"
					lRet := .F.
				EndIf
			EndIf
		EndIf

	ElseIf nCpo == 2 // TN0_DTAVAL - Data de Avaliação
		If !Empty( M->TN0_DTAVAL )

			//Valida se a data de avaliação for maoir que a data de reconhecimento.
			lRet := ValData( M->TN0_DTRECO, M->TN0_DTAVAL, 'A180DTVAL' )
			//Valida se a data de avaliação for maior que a data atual.
			lRet := IIf( lRet, ValData( M->TN0_DTAVAL, dDataBase, 'DATAINVAL' ), lRet )

			If lRet .And. !Empty( M->TN0_DTELIM )
				If M->TN0_DTAVAL > M->TN0_DTELIM
					ShowHelpDlg( "DATAINVAL", { STR0100 }, 2,; //"Data informada inválida."
								 { STR0101 + " " + AllTrim( NGRETTITULO( "TN0_DTELIM" ) ) + ". " }, 2 )	//"Informe uma data menor que a"
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180VALN
Função que retorna uma validação para o campo TN0_NOMAGE

@type Function

@source MDTA180.prx

@sample MDT180VALN()

@rreturn Caracter, Descrição do Agente

@author Guilherme Freudenburg
@since 17/01/2014
/*/
//---------------------------------------------------------------------
Function MDT180VALN()

	Local cFil := IIf( Len( AllTrim( TN0->TN0_FILIAL ) ) != Len( AllTrim( xFilial( "TMA" ) ) ), xFilial( "TMA" ), TN0->TN0_FILIAL )

Return IIf( TMA->( dbSeek( xFilial( "TMA", cFil ) + TN0->TN0_AGENTE ) ), TMA->TMA_NOMAGE, "" )

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180EPC
Levará a rotina de epc, sendo ja possicionado no risco

@type Function

@source MDTA180.prx

@sample MDT180EPC( 'TN0' , 0 , 3 )

@return Nulo

@author Guilherme Freudenburg
@since 16/04/2014
@obs Utilizado no fonte: MDTA180.
/*/
//---------------------------------------------------------------------
Function MDT180EPC( cAlias, nReg, nOpcx )

	Local aSize    := MsAdvSize( , .F., 430 )
	Local aObjects := {}

	oldaRotina   := aRotina
	oldaSMENU    := aSMENU
	oldaCHKDEL   := aCHKDEL
	oldbNGGRAVA  := bNGGRAVA
	oldcCadastro := cCadastro

	aRELAC := {  { "TNX_NUMRIS", "TN0->TN0_NUMRIS" },;
				 { "TNX_AGENTE", "TN0->TN0_AGENTE" },;
				 { "TNX_NOMAGE", "NGSeek('TMA',TN0->TN0_AGENTE,1,'TMA->TMA_NOMAGE')" } }

	If lSigamdtps
		aAdd( aRELAC, { "TNX_CLIENT", "SA1->A1_COD" } )
		aAdd( aRELAC, { "TNX_LOJA", "SA1->A1_LOJA" } )
	EndIf

	aAdd( aSize, { 0 } )
	aAdd( aSize, { 0 } )
	aAdd( aSize, { 609 } )
	aAdd( aSize, { 406 } )
	aAdd( aSize, { 0 } )
	aAdd( aSize, { 0 } )

	aAdd( aObjects, { 050, 050, .T., .T. } )
	aAdd( aObjects, { 100, 100, .T., .T. } )

	MDT265EPC( cAlias, nReg, nOpcx, aSize, aObjects )

	aRELAC    := {}
	aRotina   := oldaRotina
	aSMENU    := oldaSMENU
	aCHKDEL   := oldaCHKDEL
	bNGGRAVA  := oldbNGGRAVA
	cCadastro := oldcCadastro

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fWTarefas
Busca as datas do Risco de acordo com as tarefas

@type Function

@source MDTA180.prx

@param aDatas, Array, Array a ser alimentado com os valores de datas (Obrigatório - passar com @ na frente)
@param cTarefa, Caracter, Tarefa a ser considerada (Obrigatório)
@param cMatricula, Caracter, Matricula a ser considerada (Obrigatório)
@param dDtIniRis, Data, Data de Início do Risco (Obrigatório)
@param dDtFimRis, Data, Data de Fim do Risco (Obrigatório)

@sample fWTarefas( {} , '001' , '000001' , '01/01/2014' , '01/01/15' )

@return Nulo

@author Jackson Machado
@since 16/04/2014
/*/
//---------------------------------------------------------------------
Function fWTarefas( aDatas, cTarefa, cMatricula, dDtIniRis, dDtFimRis )

	dbSelectArea( "TN6" )
	dbSetOrder( 1 ) //TN6_FILIAL+TN6_CODTAR+TN6_MAT+DTOS(TN6_DTINIC)
	dbSeek( xFilial( "TN6" ) + cTarefa + cMatricula )
	While TN6->( !Eof() ) .And. TN6->TN6_FILIAL == xFilial( "TN6" ) .And. ;
						TN6->TN6_CODTAR == cTarefa .And. TN6->TN6_MAT == cMatricula

		dDtIniTmp := STOD( Space( 8 ) )
		dDtFimTmp := STOD( Space( 8 ) )
		lForce := .F.

		aAdd( aDatas, fGetTarefa( TN6->TN6_DTINIC, TN6->TN6_DTTERM, dDtIniRis, dDtFimRis ) )

		TN6->( dbSkip() )
	End

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetTarefa
Função para tratativa das datas de início e fim da tarefa

@type Function

@source MDTA180.prx

@param dDtIniTar, Data, Data de Início da Tarefa
@param dDtFimTar, Data, Data de Fim da Tarefa
@param dDtIniRis, Data, Data de Início do Risco
@param dDtFimRis, Data, Data de Fim do Risco

@sample fGetTarefa( '01/01/14' , '15/01/14' , '01/01/14' , '01/01/15' )

@return Array, Datas a serem consideradas

@author Jackson Machado
@since 16/04/2014
/*/
//---------------------------------------------------------------------
Function fGetTarefa( dDtIniTar, dDtFimTar, dDtIniRis, dDtFimRis )

	Local aDatasGer
	Local dDtIniTmp
	Local dDtFimTmp
	Local lForce

	aDatasGer := {}
	dDtIniTmp := SToD( Space( 8 ) )
	dDtFimTmp := SToD( Space( 8 ) )
	lForce := .F.
	If dDtIniTar >= dDtIniRis .And. ( dDtIniTar <= dDtFimRis .Or. Empty( dDtFimRis ) )
		dDtIniTmp := dDtIniTar
	ElseIf dDtIniTar <= dDtIniRis .And. ( dDtFimTar >= dDtIniRis .Or. Empty( dDtFimTar ) )
		dDtIniTmp := dDtIniRis
	EndIf

	If !Empty( dDtFimRis ) .And. Empty( dDtFimTar )
		dDtFimTmp := dDtFimRis
	ElseIf Empty( dDtFimRis ) .And. !Empty( dDtFimTar )
		dDtFimTmp := dDtFimTar
	ElseIf  Empty( dDtFimRis )	.And. Empty( dDtFimTar )
		lForce := .T.
	Else
		If dDtFimTar >= dDtFimRis .And. dDtIniTar <= dDtFimRis
			dDtFimTmp := dDtFimRis
		ElseIf dDtFimTar >= dDtIniRis .And. dDtFimTar <= dDtFimRis
			dDtFimTmp := dDtFimTar
		EndIf
	EndIf

	If ( !Empty( dDtFimTmp ) .And. !Empty( dDtIniTmp ) ) .Or. lForce
		aDatasGer := { dDtIniTmp, dDtFimTmp }
	EndIf

Return aDatasGer

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180SR7
Função que realiza a busca das filiais no historico do funcionario

@type Function

@source MDTA180.prx

@param [cMat], Caracter, Indica a matricula a ser considerada, caso nao passe, será considerado a matricula posicionada
@param [cFilSR7], Caracter, Indica a filial da SR7
@param [lTipRet], Logico, Indica o tipo de retorno, true para a ultima data e false para todas as datas

@return Indefinido, Retorna ou um array contendo o historico ou a data da ultima alteracao

@sample MDT180SR7()

@author Jackson Machado
@since 16/04/2014
/*/
//---------------------------------------------------------------------
Function MDT180SR7( cMat, cFilSR7, lTipRet )

	Local aArea		:= GetArea()
	Local cQuery	:= ""
	Local xDtRet

	Default cMat	 := SRA->RA_MAT
	Default lTipRet  := .T.
	Default cFilSR7  := cFilAnt

	If !lTipRet
		xDtRet := {}
	EndIf

	#IfDef TOP
		//Caso ambiente seja TopConnect, realiza Query que busca todas as alteracoes salariais vinculadas a matricula especificada
		cQuery := "SELECT SR7.R7_DATA, SR7.R7_FUNCAO "
		cQuery += "FROM "+ RetSqlName( "SR7" ) + " SR7 "
		cQuery += "WHERE SR7.R7_FILIAL = " + ValToSql( xFilial( "SR7", cFilSR7 ) ) + " AND "
		cQuery += 	"SR7.R7_MAT = " + ValToSql( cMat )
		If TcSrvType() != "AS/400"
			cQuery += "   AND SR7.D_E_L_E_T_ <> '*' "
		Else
			cQuery += "   AND SR7.@DELETED@ <> '*' "
		EndIf
		cQuery += " ORDER BY SR7.R7_DATA DESC "
		cQuery := ChangeQuery( cQuery )

		If Select( "QSR7" ) > 0
			dbSelectArea( "QSR7" )
			QSR7->( dbCloseArea() )
		EndIf

		MPSysOpenQuery( cQuery, "QSR7" )
		If lTipRet
			xDtRet := QSR7->R7_DATA
		Else
			While QSR7->( !Eof() )
				aAdd( xDtRet, { QSR7->R7_DATA, QSR7->R7_FUNCAO } )
				QSR7->( dbSkip() )
			End
		EndIf
		QSR7->( dbCloseArea() )
	#Else
		//Caso ambiente seja CodeBase, realiza busca manual de todas as alteracoes salariais vinculadas a matricula especificada
		dbSelectArea( "SR7" )
		SR7->( dbSetOrder( 1 ) )
		SR7->( dbSeek( xFilial( "SR7", cFilSR7 ) + cMat, .T.) )
		//-------------------------------------------------------------------------------
		// Busca no arquivo de historico salarial, as alteracoes categoria funcionario
		//-------------------------------------------------------------------------------
		While SR7( !Eof() ) .And. SR7->R7_FILIAL == xFilial( "SR7", cFilSR7 ) .And. SR7->R7_MAT == cMat
			If lTipRet
				xDtRet := SR7->R7_DATA
			Else
				aAdd( xDtRet, { SR7->R7_DATA, SR7->R7_FUNCAO } )
			EndIf
			SR7->( dbSkip() )
		EndDo

	#ENDIf

	RestArea( aArea )
	If lTipRet
		If ValType( xDtRet ) != "D"
			xDtRet := cValToChar( xDtRet ) //Converte primeiramente para caracter para garatir a conversão em data
			xDtRet := STOD( xDtRet )
		EndIf
	EndIf

Return xDtRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180HFUN
Função que realiza a busca das filiais no historico do funcionario

@type Function

@source MDTA180.prx

@param [cMat], Caracter, Matrincula a ser considerada, caso não for informado sera considerado registro posicionado da tabela SRA
@param [cFilPar], Caracter, Filial a ser considerada, caso não for informado sera considerado registro posicionado da tabela SRA
@param [cCusto], Caracter, Centro de Custo a ser considerado, caso não for informado sera considerado registro posicionado da tabela SRA
@param [dDtAdmis], Data, Data de Admissão do Funcionário, caso não for informado sera considerado registro posicionado da tabela SRA
@param [dDtDemis], Data, Data de Demissao do Funcionario, caso não for informado sera considerado registro posicionado da tabela SRA
@param [bCond], Bloco, Indica uma validação especifica para consitencia
@param [lUltimo], Logico, Indica se considera o ultimo registro de transferencia
@param [lConsDB], Logico, Indica se considera a data base na verificacao
@param [lCC], Logico, Indica se considera o centro de custo na verificacao

@sample MDT180HFUN()

@return Array, Contem as filiais no formato { 'EMPRESA' , 'FILIAL' , 'NOME' , dDataInicio , dDataFim }

@author Jackson Machado
@since 16/04/2014
/*/
//---------------------------------------------------------------------
Function MDT180HFUN( cMat, cFilPar, cCusto, dDtAdmis, dDtDemis, bCond, lUltimo, lConsDB, lCC )

	Local nFil		:= 0 //Contador do FOR
	Local nRecno	:= 0 //Salva o Recno
	Local cCondCus	:= Space( Len( SRA->RA_CC ) ) //Condicao de validacao da troca de centro de custo
	Local cCondALL	:= Space( 10 ) //Condicao principal da pesquisa
	Local cKeyEmp	:= cEmpAnt //Chave Empresa
	Local cKeyFil	//Chave Filial
	Local cKeyMat	//Chave Matricula
	Local cKeyCus	//Chave Centro Custo
	Local dDtFimF	//Data de controle das saídas
	Local dDtEntr	:= SToD( Space( 8 ) ) //Data de Controle das entradas
	Local dINITMP	//Data Admissao
	Local lPrimeiro := .T. //Indica se eh primeiro registro computado
	Local lEncerra	:= .F. // Verifica se acabou o historico de setores
	Local aFiliais	:= {} //Filiais do Funcionario - Nesta funcao o RECNO eh incluida no Array para possivel reordenacao
	Local aArea		:= GetArea()//Salva a area de trabalho atual

	Default cMat		:= SRA->RA_MAT
	Default cFilPar	    := SRA->RA_FILIAL
	Default cCusto		:= SRA->RA_CC
	Default dDtAdmis	:= SRA->RA_ADMISSA
	Default dDtDemis	:= IIf( Empty( SRA->RA_DEMISSA ), dDataBase, SRA->RA_DEMISSA )
	Default lUltimo	    := .F.
	Default lConsDB	    := .F.
	Default lCC			:= .F.

	cKeyFil	:= cFilPar
	cKeyMat	:= cMat
	cKeyCus	:= cCusto
	dDtFimF	:= dDtDemis
	dINITMP	:= dDtAdmis

	//Caso data de demissão seja vazia, considera a data atual como final
	If lConsDB .And. Empty( dDtFimF )
		dDtFimF := dDataBase
	EndIf

	While !lEncerra
		//Reseta variaveis para iniciar a verificacao a cada passagem e reducao de datas
		lPrimeiro 	:= .T.
		dDtEntr		:= SToD( Space( 8 ) )
		cCondCus  	:= cKeyCus
		cCondALL  	:= cKeyEmp + Padr( cKeyFil, Len( SRE->RE_FILIALD ) ) + cKeyMat
		Dbselectarea( "SRE" )
		Dbsetorder( 2 )//RE_EMPP + RE_FILIALP + RE_MATP
		Dbseek( cCondALL )//EMPRESA + FILIAL + MATRICULA
		While !Eof() .And. cCondALL == SRE->RE_EMPP + SRE->RE_FILIALP + SRE->RE_MATP

			//Caso for transferido para mesma empresa, filial, matricula e C.C. desconsidera o registro
			If SRE->RE_EMPP == SRE->RE_EMPD .And. SRE->RE_FILIALP == SRE->RE_FILIALD .And. ;
				SRE->RE_MATP == SRE->RE_MATD .And. SRE->RE_CCP == SRE->RE_CCD
				dbSelectArea( "SRE" )
				dbSkip()
				Loop
			EndIf

			// Verifica se data eh superior a data fim ou inferior a data inicial, caso seja desconsidera
			If SRE->RE_DATA >= dDtFimF .Or. SRE->RE_DATA < dINITMP
				dbSelectArea( "SRE" )
				dbSkip()
				Loop
			EndIf

			//Caso seja centro de custo dIferente da chave, desconsidera
			If !lCC
				If SRE->RE_CCP != cCondCus
					dbSelectArea( "SRE" )
					dbSkip()
					Loop
				EndIf
			EndIf

			If ValType( bCond ) == "B" .And. Eval( bCond )
				dbSelectArea( "SRE" )
				dbSkip()
				Loop
			EndIf

			//Caso for primeira registro da chave, adiciona no array e salva novos valores para a chave
			If lPrimeiro
				cKeyEmp	:= SRE->RE_EMPD
				cKeyFil	:= SRE->RE_FILIALD
				cKeyMat	:= SRE->RE_MATD
				cKeyCus	:= SRE->RE_CCD
				dDtEntr	:= SRE->RE_DATA
				nRecno	:= SRE->( Recno() )
				aAdd( aFiliais, { SRE->RE_EMPP,;//Empresa
								 SRE->RE_FILIALP,; //Filial
								 FWFilialName( SRE->RE_EMPP, SRE->RE_FILIALP, 2 ),; //Nome completo
								 dDtEntr,; //Data de entrada
								 dDtFimF,; //Data de Saída
								 SRE->RE_MATP,; //Matricula
								 If( lCC, SRE->RE_CCP, ),; //Centro de Custo
								 SRE->( Recno() ) } )
			Else
				// Caso seja segundo registro da chave, verifica se a data salva eh superior a atual
				// caso seja, adiciona a data de entrada a tada atual e troca o recno
				If SRE->RE_DATA < aFiliais[ Len( aFiliais ) ][ 4 ]
					cKeyEmp	:= SRE->RE_EMPD
					cKeyFil	:= SRE->RE_FILIALD
					cKeyMat	:= SRE->RE_MATD
					cKeyCus	:= SRE->RE_CCD
					dDtEntr	:= SRE->RE_DATA
					nRecno	:= SRE->( Recno() )
					aFiliais[ Len( aFiliais ) ][ _nDTENTR_ ] := SRE->RE_DATA
					aFiliais[ Len( aFiliais ) ][ _nRECFIL_ ] := SRE->( Recno() )
				EndIf
			EndIf

			lPrimeiro := .F.//IdentIfica que jah fez a primeira verificacao

			dbSelectArea( "SRE" )
			dbSkip()
		End
		If lPrimeiro
			// Caso seja primeira verifica encerra o processo, indica que acho um registro e computa o ultimo registro da SRE
			// desde que a data de inicio seja menor que a ultima data fim
			lEncerra   := .T.
			If dINITMP <= dDtFimF
				aADD( aFiliais, { cKeyEmp,; //Empresa
								 cKeyFil,; //Filial
								 FWFilialName( cKeyEmp, cKeyFil, 2 ),; //Nome completo
								 dINITMP,; //Data de entrada
								 dDtFimF,; //Data de Saída
								 cKeyMat,; //Matricula
								 IIf( lCC, cKeyCus, ),; //Centro de Custo
								 nRecno - 1 } )
			EndIf
		Else
			//Caso jah tenha computado o registro, salva a data fim como sendo a ultima data de entrada e continua verificando
			dDtFimF := dDtEntr
		EndIf
	End

	// Caso tenha adicionado alguma filial, ordena pelo RECNO e retira este do array
	If Len( aFiliais ) > 0
		aFiliais := aSort( aFiliais, , , { | x, y | x[ Len( aFiliais[ 1 ] ) ] < y[ Len( aFiliais[ 1 ] ) ] } )
		For nFil := 1 To Len( aFiliais )
			aDel( aFiliais[ nFil ], Len( aFiliais[ nFil ] ) )
			aSize( aFiliais[ nFil ], Len( aFiliais[ nFil ] ) - 1 )
		Next nFil
	EndIf

	//Retira a ultima posicao do array pois esta corresponde a empresa/filial atual nao sendo necessario
	If !lUltimo .And. Len( aFiliais ) > 0
		aDel( aFiliais, Len( aFiliais ) )
		aSize( aFiliais, Len( aFiliais ) - 1 )
	EndIf

	//Retornar a area salva
	RestArea( aArea )

Return aFiliais

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180VALN
Função que monta a tabela temporaria para  visualizar os funcionarios
expostos ao risco.

@type Function

@source MDTA180.prx

@param oTempTMPA, Objeto, Tabela temporária

@sample fCriaTRBFunc( oObj )

@return Nulo

@obs Reorganizado lógica anterior.

@author Guilherme Benkendorf
@since 29/04/2014
/*/
//---------------------------------------------------------------------
Static Function fCriaTRBFunc( oTempTMPA )

	Local aSEMSX3

	//Estrutura copiada para o fonte MDTA125 - caso seja alterado esta estrutura, cuidar com as alteraçoes.
	// MONTA O TEMPORARIO PARA VISUALIZAR OS FUNCIONARIOS
	aSEMSX3 := { { "TMPA_MATRI", "C", AVSX3( "TN6_MAT", 3 ), 0 },;
				 { "TMPA_NOMFU", "C", AVSX3( "TN6_NOME", 3 ), 0 },;
				 { "TMPA_DTINI", "D", 08, 0 },;
				 { "TMPA_DTFIM", "D", 08, 0 },;
				 { "TMPA_TAREF", "C", AVSX3( "TN0_NOMTAR", 3 ) + AVSX3( "TN0_CODTAR", 3 ) + 1, 0 },;
				 { "TMPA_CCUST", "C", AVSX3( "TN0_DESCCC", 3 ) + AVSX3( "TN0_CC", 3 ) + 1, 0 },;
				 { "TMPA_FUNCA", "C", AVSX3( "TN0_DESCFU", 3 ) + AVSX3( "TN0_CODFUN", 3 ) + 1, 0 },;
				 { "TMPA_NVFIL", "C", TAMSX3( "RA_FILIAL" )[ 1 ], 0 },;
				 { "TMPA_DEPTO", "C", AVSX3( "TN0_DESCDP", 3 ) + AVSX3( "TN0_DEPTO", 3 ) + 1, 0 } }

	oTempTMPA := FWTemporaryTable():New( "TMPA", aSEMSX3 )
	oTempTMPA:AddIndex( "1", { "TMPA_NOMFU" }  )
	oTempTMPA:Create()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fAjustMNT902
Função para polular TN0_CC, TN0_CODFUN, TN0_CODTAR e TN0_NOMAMB na
memória e habilitar variavel para o X3_WHEN deles.

@type Function

@source MDTA180.prx

@param cTRBTAF, Caracter, Tabela temporária

@sample fAjustMNT902( 'SCG0001' )

@return Lógico, Sempre verdadeiro

@author Guilherme Benkendorf
@since 30/04/2014
/*/
//---------------------------------------------------------------------
Static Function fAjustMNT902(cTRBTAF)

	Local cCusto
	Local cTarefa
	Local cFuncao
	Local cAmbiente
	Local cDepto

	dbSelectArea( cTRBTAF )
	dbSetOrder( 2 ) //CODEST+CODPRO+FILIAL
	While AllTrim( (cTRBTAF)->CARGO ) != "LOC" .And. !Empty( (cTRBTAF)->CARGO )

		If AllTrim( (cTRBTAF)->CARGO ) == "TAR"
			cTarefa := (cTRBTAF)->CODTIPO
		ElseIf AllTrim( (cTRBTAF)->CARGO ) == "FUN"
			cFuncao := (cTRBTAF)->CODTIPO
		EndIf

		dbSelectArea( cTRBTAF )
		dbSetOrder( 2 ) //CODEST+CODPRO+FILIAL
		dbSeek( (cTRBTAF)->CODEST+(cTRBTAF)->NIVSUP + cFilAnt )

	End

	If (cTRBTAF)->CODPRO == "001"
		cCusto := "*"
		cDepto := "*"
	Else
		cCusto := (cTRBTAF)->CC
		If !Empty( (cTRBTAF)->DEPTO )
			cDepto := (cTRBTAF)->DEPTO
		Else
			cDepto := "*"
		EndIf
	EndIf

	cAmbiente := (cTRBTAF)->CODAMB

	If Empty( cTarefa )
		cTarefa := "*"
	EndIf

	If Empty( cFuncao )
		cFuncao := "*"
	EndIf

	//When's de TN0_CC, TN0_DEPTO, TN0_CODFUN, TN0_CODTAR e TN0_NOMAMB
	lTrava902 := .F.
	lTravaAmb := Empty( cAmbiente )
	// Carrega memoria na chamada do MNTA902.
	M->TN0_CC     := cCusto
	M->TN0_DESCCC  := MDT180BRW( .F. )
	If NGCADICBASE( "TN0_DEPTO", "A", "TN0", .F. )
		M->TN0_DEPTO  := cDepto
		M->TN0_DESCDP := MDT180BRW( .F., 2 )
	EndIf
	M->TN0_CODFUN := Padr( cFuncao, Len( M->TN0_CODFUN ) )
	M->TN0_DESCFU := MDT180FUN( .F. )
	M->TN0_CODTAR := Padr( cTarefa, Len( M->TN0_CODTAR ) )
	M->TN0_NOMTAR := MDT180BRW2( .F. )
	M->TN0_CODAMB := cAmbiente
	M->TN0_NOMAMB := NGSeek( "TNE", cAmbiente, 1, "TNE_NOME" )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fWhenChkRis
Funçao auxiliar para execução das variaveis do X3_WHEN.

@type Function

@source MDTA180.prx

@param cTRBTAF, Caracter, Tabela Temporária
@param LCpyRisc, Lógico, Indica se é cópia do risco

@sample fWhenChkRis( 'SCG0001' , lCpyRisc )

@return Nulo

@author Guilherme Benkendorf
@since 03/07/2014
/*/
//---------------------------------------------------------------------
Static Function fWhenChkRis( cTRBTAF, lCpyRisc )

	Local aAreaArv := {}
	Local lArvLoc  := IsInCallStack( "MNTA902" ) .Or. IsInCallStack( "MNTA905" )

	If !lSigaMdtPs
		// Ajustas campos para chamada da Arvore Lógica
		If !Empty( cTRBTAF ) .And. Select( cTRBTAF ) > 0 .And. lArvLoc
			fAjustMNT902( cTRBTAF )
		ElseIf !lCpyRisc
			aAreaArv := GetArea()
				dbSelectArea( "TAF" )
				dbSetOrder( 10 ) //TAF_FILIAL+TAF_INDCON+TAF_CODCON+TAF_MODMNT+TAF_MODMDT+TAF_MODSGA
				If dbSeek( xFilial( "TAF" ) + "7" + PadR( M->TN0_NUMRIS, Len( TAF->TAF_CODCON ) ) + " X " )
					lTrava902 := .F.
					lTravaAmb := .F.
				EndIf
			RestArea( aAreaArv )
		EndIf
	EndIf

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} fChkDtSRE
Função para verificação da data inicio de exposição do risco.

@type Function

@source MDTA180.prx

@param dInicio, Data, Data de Início
@param [lCCusto], Lógico, Indica se valida condição de Centro de Custo
@param [lSeek], Lógico, Indica se desconsidera C.C. com '*'

@sample fChkDtSre( '01012018' )

@return Data, Data de Início da Exposição

@author Guilherme Benkendorf
@since 10/09/2014
/*/
//---------------------------------------------------------------------
Static Function fChkDtSRE( dInicio, lCCusto, lSeek )

	Local cCondWhile	:= "SRE->RE_CCP == M->TN0_CC .And. SRE->RE_DATA > dInicio"
	Local cSeek			:= ".T."

	Default lCCusto		:= .T.
	Default lSeek		:= .T.

	If !lCCusto
		cCondWhile := "SRE->RE_EMPD <> cEmpAnt .Or. SRE->RE_FILIALD <> cFilAnt) .And. SRE->RE_DATA > dInicio"
	EndIf
	If lSeek
		cSeek := "ALLTRIM(M->TN0_CC) <> '*'"
	EndIf

	SRExpRisco( 2, cEmpAnt+cFilAnt+SRA->RA_MAT, cSeek, @dInicio, M->TN0_CC, lCCusto )

Return dInicio

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180SX7
Função utilizada para Condição do SX7 - Dicionário - Ergonomia

@type Function

@source MDTA180.prx

@param nTipo, Numérico, Indica o tipo de retorno para o gatilho

@param nTipo Numerico IdentIfica o Tipo de Condicional a ser utilizada

@sample MDT180SX7( 1 )

@return Logico, Retorno .T. se a condição for verdeira

@author Jackson Machado
@since 29/09/2015
/*/
//---------------------------------------------------------------------
Function MDT180SX7( nTipo )

	Local cRet := ".T."

	Default nTipo := 0

	If nTipo == 1
		cRet := "NGSEEK('TMA',M->TN0_AGENTE,1,'TMA_GRISCO') <> '4'"
	EndIf

Return &( cRet )

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTVALTRM
Função para validação padrão dos campos de Treinamento

@type Function

@source MDTA180.prx

@param [nCampo], Numérico, Indica o campo que será validado.
							1 - Calendário, 2 - Curso e 3 - Turma

@sample MDTVALTRM()

@return Logico, Retorno se o campo está correto

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Function MDTVALTRM( nCampo )

	Local lRet := .T.

	Default nCampo := 0

	If nCampo == 1
		lRet := ExistCPO( "RA2", M->TY4_CALEND )
		If lRet
			cCalend := M->TY4_CALEND
		EndIf
	ElseIf nCampo == 2 .And. !Empty( cCalend )
		lRet := ExistCPO( "RA2", cCalend + M->TY4_CURSO )
	ElseIf nCampo == 3 .And. !Empty( cCalend )
		lRet := ExistCPO( "RA2", cCalend + RA2->RA2_CURSO + M->TY4_TURMA )//Posiciona RA2 no gatilha TY4_CURSO,001
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTGERTRM
Função que possibilita a geração de treinamento para grupos de exposição

@type Function

@source MDTA180.prx

@sample MDTGERTRM()

@return Lógico, Indica se realizou vinculo

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Function MDTGERTRM()

	//Variaveis a serem utilizadas para montagem da tela
	Local nReg		:= 0
	Local lOk		:= .F.
	Local lRet		:= .T.
	Local nTipRel	:= 1
	Local aButtons  := { { "pedido", { | | lOk := .T., IIf( MsgYesNo( STR0119 ), IIf( fTudoOk( oGetDad ), IIf( fGerTrm( nTipRel, oGetDad ),;
						 oDialog:End(), lOk := .F. ), lOk := .F. ), lOk := .F. ) }, STR0120 , STR0120 } }//"Deseja realmente gerar a reserva?"//"Ger. Treinamento"
	Local aNao		:= {}
	Local aChoice	:= {}
	Local aColor	:= NGCOLOR()
	Local aRotOld	:= aClone( aRotina )//Salva o aRotina
	Local aArea		:= GetArea()//Salva a area de trabalho atual

	//Variaveis para montagem do aCols e aHeader
	Local nInd		:= 0
	Local cKeyGet	:= ""
	Local cWhileGet	:= ""
	Local aNoFields	:= {}

	//Variaveis de tamanho de tela
	Local lEnchBar	:= .T. // Indica se a janela de diálogo possuirá enchoicebar
	Local lPadrao	:= .F. // Indica se a janela deve respeitar as medidas padrões do Protheus (.T.) ou usar o máximo disponível (.F.)
	Local nMinY		:= 430 // Altura mínima da janela
	Local aSize 	:= MsAdvSize( lEnchBar, lPadrao, nMinY )
	Local aObjects  := {}
	Local aInfo 	:= {}
	Local aPosObj 	:= {}

	//Define os Objetos
	Local oDialog
	Local oPnlPai
	Local oEnchoice
	Local oGetDad

	//Define variaveis privadas
	Private aCols
	Private aHeader
	Private cCalend  := ""

	//Definição do Tipo de Treinamento
	If IsInCallStack( "MDTA180" )
		nTipRel := 4
		If Empty( TN0->TN0_DTAVAL )
			ShowHelpDlg( Upper( STR0032 ),;
						 { STR0121 }, 2,;//"Não é possível realizar o vínculo de treinamento."
						 { STR0122 }, 2 )//"Para identIficar os treinamentos necessários o risco deve estar avaliado."
			lRet := .F.
		EndIf
	ElseIf IsInCallStack( "MDTA626" )
		nTipRel := 3
	ElseIf IsInCallStack( "MDTA625" )
		nTipRel := 2
	EndIf

	If lRet
		//Define um novo aRotina padrao para nao ocorrer erro
		aRotina 	:=	{  	 { STR0001, "AxPesqui", 0, 1 },;   //Pesquisar
	                     	 { STR0002, "NGCAD01", 0, 2 },;    //Visualizar
	                     	 { STR0003, "NGCAD01", 0, 3 },;    //Incluir
	                     	 { STR0004, "NGCAD01", 0, 4 },;    //Alterar
	                     	 { STR0005, "NGCAD01", 0, 5, 3 } } //Excluir

		//Zera o aCols e aHeader ( Genéricos )
		aCols := {}
		aHeader := {}

		// Define os campos que nao apareceram da GetDados
		aAdd( aNoFields, "TY4_FILIAL" )
		aAdd( aNoFields, "TY4_ID" )
		aAdd( aNoFields, "TY4_TIPO" )
		aAdd( aNoFields, "TY4_CC" )
		aAdd( aNoFields, "TY4_CODFUN" )
		aAdd( aNoFields, "TY4_TAREFA" )
		aAdd( aNoFields, "TY4_NUMRIS" )

		//Estrutura padrao de repeticao da tabela
		cWhileGet := "TY4->TY4_FILIAL == '" + xFilial( "TY4" ) + "'"
		cWhileGet += " .And. TY4->TY4_TIPO == '"+ cValToChar( nTipRel ) +"'"
		cKeyGet := "'" + cValToChar( nTipRel ) + "'"

		If nTipRel == 2
			cTable := "SRJ"
			cKeyGet += "+SRJ->RJ_FUNCAO"
			cWhileGet += " .And. TY4->TY4_CODFUN == '" + SRJ->RJ_FUNCAO + "'"
			nInd := 3
			nReg := SRJ->( Recno() )
		ElseIf nTipRel == 3
			cTable := "TN5"
			cKeyGet += "+TN5->TN5_CODTAR"
			cWhileGet += " .And. TY4->TY4_TAREFA == '" + TN5->TN5_CODTAR + "'"
			nInd := 4
			nReg := TN5->( Recno() )
		ElseIf nTipRel == 4
			cTable := "TN0"
			cKeyGet += "+TN0->TN0_NUMRIS"
			cWhileGet += " .And. TY4->TY4_NUMRIS == '" + TN0->TN0_NUMRIS + "'"
			nInd := 5
			nReg := TN0->( Recno() )
		Else
			cTable := "CTT"
			cKeyGet += "+CTT->CTT_CUSTO"
			cWhileGet += " .And. TY4->TY4_CC == '" + CTT->CTT_CUSTO + "'"
			nInd := 2
			nReg := CTT->( Recno() )
		EndIf

		//Define modo de alteracao para a Tabela
		aRotSetOpc( cTable, @nReg, 4 )
		RegToMemory( cTable, .F. )
		INCLUI := .F.
		ALTERA := .T.

		aChoice := NGCAMPNSX3( cTable, aNao )

		//Realiza a montagem do aCols e aHeader
		dbSelectArea( "TY4" )
		dbSetOrder( nInd )
		FillGetDados( 4, "TY4", nInd, cKeyGet, { | | }, { | | .T. }, aNoFields, , , ,;
					 { | | NGMontaaCols( "TY4", &cKeyGet, cWhileGet ) } )

		//Definicoes de tamanho de tela
		aAdd( aObjects, { 100, 100, .T., .T. } )
		aAdd( aObjects, { 315, 70, .T., .T. } )
		aInfo   := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
		aPosObj := MsObjSize( aInfo, aObjects, .F. )

		//Criação da Tela para Vínculo
		Define MsDialog oDialog Title OemToAnsi( STR0123 ) From aSize[ 7 ], 0 To aSize[ 6 ], aSize[ 5 ] Of oMainWnd Pixel//"Vinculo de Treinamento"

			//Panel criado para correta disposicao da tela
			oPnlPai := TPanel():New( , , , oDialog, , , , , , , , .F., .F. )
				oPnlPai:Align := CONTROL_ALIGN_ALLCLIENT

				//Painel - Parte Superior ( Cabeçalho )
				oPnlTop := TPanel():New( , , , oPnlPai, , , , , , , aSize[ 6 ] / 4, .F., .F. )
			   		oPnlTop:Align := CONTROL_ALIGN_TOP

		            //Monta a Enchoice de Laudos
					oEnchoice:= MsMGet():New( cTable, ( cTable )->( Recno() ), 2, , , , aChoice, { 12, 0, aSize[ 6 ] / 2, aSize[ 5 ] / 2 }, , , , , , oPnlTop )
						oEnchoice:oBox:Align := CONTROL_ALIGN_ALLCLIENT

				//Redefine as variaveis para montar as GetDados corretamente
				INCLUI := .F.
				ALTERA := .T.

				//Monta a GetDados de acordo com o Folder
				dbSelectArea( "TY4" )
				PutFileInEof( "TY4" )
				oGetDad  := MsNewGetDados():New( 0, 0, 1000, 1000, IIf( !INCLUI .And. !ALTERA, 0, GD_INSERT+GD_UPDATE+GD_DELETE ),;
												 { | | fLinhaOK( oGetDad ) }, { | | .T. }, , , , 9999, , , , oPnlPai,;
												 aHeader, aCols, { | | fChange( oGetDad ) } )
					oGetDad:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
					oGetDad:oBrowse:Refresh()

		//Ativacao do Dialog
		Activate MsDialog oDialog Centered On Init EnchoiceBar( oDialog, ;
										 { | | lOk := .T., IIf( fTudoOk( oGetDad ), oDialog:End(), lOk := .F. ) },;
										 { | | lOk := .F., oDialog:End() }, , aButtons )

		If lOk//Caso confirmacao da tela, realiza gravacao dos dadods
			Processa( { | lEnd | fGrava( nTipRel, cTable, cWhileGet, nInd, cKeyGet ) }, STR0124 ) //"Gravando Informações"
		EndIf
	EndIf

	//Retorna o aRotina
	aRotina := aClone( aRotOld )

	//Retorna a Area de Trabalho
	RestArea( aArea )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fChange
Posiciona RA2 e cCalend na MSNewGetDados

@type Function

@source MDTA180.prx

@param oObj, Objeto, Indica o Objeto da GetDados (Obrigatório)

@sample fChange( oGetDad )

@return Lógico, Sempre verdadeiro

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fChange( oObj )

	Local nPosRA2 := 3
	Local nPosCal := 1
	Local nAt     := oObj:oBrowse:nAt
	Local aColsOK := aClone( oObj:aCols )
	Local aHeadOK := aClone( oObj:aHeader )

	nPosCal := aScan( aHeadOK, { | x | Trim( Upper( x[ 2 ] ) ) == "TY4_CALEND" } )
	nPosRA2 := aScan( aHeadOK, { | x | Trim( Upper( x[ 2 ] ) ) == "TY4_CURSO" } )

	If !Empty( aColsOK[ nAt, nPosRA2 ] )
		dbSelectArea( "RA2" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "RA2" ) + aColsOK[ nAt, nPosCal ] + aColsOK[ nAt, nPosRA2 ] )
	EndIf

	cCalend := aColsOK[ nAt, nPosCal ]

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fLinhaOk
Validacao de Linha padrao das GetDados

@type Function

@source MDTA180.prx

@param oGetDad, Objeto, Indica o Objeto da GetDados (Obrigatório)
@param [lFim],Lógico, Indica se eh chamado pelo TudoOk

@sample fLinhaOK( oGetDad )

@return Lógico. Indica se esta tudo correto na linha

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fLinhaOK( oGetDad , lFim )

	//Variaveis auxiliares
	Local aColsOk := {}
	Local aHeadOk := {}
	Local nPosCal := 1
	Local nAt     := 1
	Local nPosCur := 0
	Local nPosTur := 0
	Local lRet	  := .T.
	Local f
	Local nCols
	Local nHead

	Default lFim  := .F.

	aCols 	:= oGetDad:aCols
	aHeader := oGetDad:aHeader

	//Salva o aCols e aHeader de acordo com a posicao, o nAt da GetDados posicionada e o código de acordo com sua posicao
	aColsOk	:= aCols
	aHeadOk	:= aHeader
	nAt		:= oGetDad:nAt

	nPosCal	:= aScan( aHeadOk, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_CALEND" } )
	nPosCur	:= aScan( aHeadOk, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_CURSO" } )
	nPosTur	:= aScan( aHeadOk, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_TURMA" } )

	//Percorre aCols
	For f:= 1 To Len( aColsOk )
		If lRet .And. !aColsOk[ f, Len( aColsOk[ f ] ) ]
			If lRet .And. ( lFim .Or. f == nAt )//Caso seja final ou linha atual
				//Verifica se os campos obrigatórios estão preenchidos
				If Empty( aColsOk[ f, nPosCal ] ) .And. IIf( lFim, Len( aColsOk ) != 1, .T. )
					//Mostra mensagem de Help
					Help( 1, " ", "OBRIGAT2", , aHeadOk[ nPosCal, 1 ], 3, 0 )
					lRet := .F.
					Exit
				EndIf
				If Empty( aColsOk[ f, nPosCal ] ) .And. Empty( aColsOk[ f, nPosCur ] ) .And. IIf( lFim, Len( aColsOk ) != 1, .T. )
					//Mostra mensagem de Help
					Help( 1, " ", "OBRIGAT2", , aHeadOk[ nPosCur, 1 ], 3, 0 )
					lRet := .F.
					Exit
				EndIf
				If Empty( aColsOk[ f, nPosCal ] ) .And. Empty( aColsOk[ f, nPosCur ] ) .And. Empty( aColsOk[ f, nPosTur ] ) .And. IIf( lFim, Len( aColsOk ) != 1, .T. )
					//Mostra mensagem de Help
					Help( 1, " ", "OBRIGAT2", , aHeadOk[ nPosTur, 1 ], 3, 0 )
					lRet := .F.
					Exit
				EndIf
			EndIf
			//Verifica se é somente LinhaOk
			If lRet .And. f != nAt .And. !aColsOk[ nAt, Len( aColsOk[ nAt ] ) ]
				If aColsOk[ f, nPosCal ] == aColsOk[ nAt, nPosCal ] .And. ;
					aColsOk[ f, nPosCur ] == aColsOk[ nAt, nPosCur ] .And. ;
					aColsOk[ f, nPosTur ] == aColsOk[ nAt, nPosTur ]
					//Mostra mensagem de Help
					Help( " ", 1, "JAEXISTINF", , aHeadOk[ nPosCal, 1 ] )
					lRet := .F.
					Exit
				EndIf
			EndIf
		EndIf
	Next f

	//Posiciona tabelas em fim de arquivo
	PutFileInEof( "TY4" )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fTudoOk
Validacao final da tela

@type Function

@source MDTA180.prx

@param oGetDad, Objeto, Objeto da GetDados (Obrigatório)

@sample fTudoOk( oGetDad )

@return Lógico, Indica se está tudo correto na tela

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fTudoOk( oGetDad )

	//Variaveis auxiliares
	Local lRet := .T.//Indica o retorno

	If !fLinhaOK( oGetDad, .T. )//Valida todos os Folders
		//Caso encontre inconsistência retorna
		lRet := .F.
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fGrava
Grava as informacoes no banco de dados

@type Function

@source MDTA180.prx

@param nTipRel, Numerico, Indica o tipo de relacionamento (Obrigatório)
@param cTable, Caracter, Indica a tabela relacional (Obrigatório)
@param cWhileGet, Caracter, Indiaca a instrução a ser utilizada como laço de repetição para gravação (Obrigatório)
@param nInd, Numerico, Indica o índice utilizado para gravação (Obrigatório)
@param cKeyGet, Caracter, Indica a instrução a ser utilizada como chave da gravação (Obrigatório)

@sample fGrava( 1 , 'XXX' , 'FILIAL == xFilia()' , 1 , 'xFilial()' )

@return Nulo

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fGrava( nTipRel, cTable, cWhileGet, nInd, cKeyGet )

	//Variaveis auxiliares
	Local j
	Local nPos 			:= 0
	Local nGrav 		:= 0
	Local nPosCal		:= 0
	Local nPosCur		:= 0
	Local nPosTur		:= 0
	Local nPosDel		:= 0
	Local cSeek			:= ""
	Local cWhile		:= ""
	Local aColsGrava	:= {}
	Local aHeadGrava	:= {}

	//Salva tabela e posicao do código do array de relacionamento
	cWhile 		:= cWhileGet
	cSeek		:= cKeyGet

	//Salva aCols e aHeader correspondente
	aColsGrava	:= aCols
	aHeadGrava	:= aHeader

	//Procura a posicao do código
	nPosCal		:= aScan( aHeadGrava, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_CALEND" } )
	nPosCur		:= aScan( aHeadGrava, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_CURSO" } )
	nPosTur		:= aScan( aHeadGrava, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_TURMA" } )
	//Salva a posicao correspondente a indicacao de deletados
	nPosDel		:= Len( aHeadGrava ) + 1

	If nPosCal > 0 .And. nPosCur > 0 .And. nPosTur > 0//Caso encontre a posicao de codigo
		//Coloca os deletados por primeiro
		aSORT( aColsGrava, , , { | x, y | x[ nPosDel ] .And. !y[ nPosDel ] } )

		//Posiciona na tabela e percorre o aCols
		dbSelectArea( "TY4" )
		dbSetOrder( nInd )
		For nGrav := 1 To Len( aColsGrava )
			If !aColsGrava[ nGrav, nPosDel ] .And. !Empty( aColsGrava[ nGrav, nPosCal ] ) .And. ;
				 !Empty( aColsGrava[ nGrav, nPosCur ] ) .And. !Empty( aColsGrava[ nGrav, nPosTur ] )//Caso nao esteja deletada a linha e campo codigo esteja preenchido

				If dbSeek( xFilial( "TY4" ) + &( cSeek ) + aColsGrava[ nGrav, nPosCal ] + aColsGrava[ nGrav, nPosCur ] + aColsGrava[ nGrav, nPosTur ] ) //Verifica se ja existe a informacao na tabela
					RecLock( "TY4", .F. )
					RegToMemory( "TY4", .F. )
				Else
					RegToMemory( "TY4", .T. )
					RecLock( "TY4", .T. )
				EndIf
					For j := 1 To FCount()//Percorre todos os campos da tabela gravando as informacoes, caso necessaria inclusao específica, feita condicao via If/ElseIf
						If "_FILIAL" $ Upper( FieldName( j ) )
							FieldPut( j, xFilial( "TY4" ) )
						ElseIf "_ID" $ Upper( FieldName( j ) )
							FieldPut( j, M->TY4_ID )
						ElseIf "_TIPO" $ Upper( FieldName( j ) )
							FieldPut( j, cValToChar( nTipRel ) )
						ElseIf "_CC" $ Upper( FieldName( j ) ) .And. nTipRel == 1
							FieldPut( j, CTT->CTT_CUSTO )
						ElseIf "_CODFUN" $ Upper( FieldName( j ) ) .And. nTipRel == 2
							FieldPut( j, SRJ->RJ_FUNCAO )
						ElseIf "_TAREFA" $ Upper( FieldName( j ) ) .And. nTipRel == 3
							FieldPut( j, TN5->TN5_CODTAR )
						ElseIf "_NUMRIS" $ Upper( FieldName( j ) ) .And. nTipRel == 4
							FieldPut( j, TN0->TN0_NUMRIS )
						ElseIf ( nPos := aScan( aHeadGrava, { | x | AllTrim( Upper( x[ 2 ] ) ) == AllTrim( Upper( FieldName( j ) ) ) } ) ) > 0//Caso posicao do campo esteja no aHeader
							FieldPut( j, aColsGrava[ nGrav, nPos ] )
						EndIf
					Next j
				TY4->( MsUnLock() )
				ConfirmSX8()
			Else
				If dbSeek( xFilial( "TY4" ) + &( cSeek ) + aColsGrava[ nGrav, nPosCal ] + aColsGrava[ nGrav, nPosCur ] + aColsGrava[ nGrav, nPosTur ] )//Caso campo esteja deletado e exista na tabela, deleta
					RecLock( "TY4", .F. )
						TY4->( dbDelete() )
					TY4->( MsUnLock() )
				EndIf
			EndIf
		Next nGrav

		//Verifica toda a tabela, para que delete os registros caso este nao estejam no aCols ou seja 'exclusao'
		dbSelectArea( "TY4" )
		dbSetOrder( nInd )
		dbSeek( xFilial( "TY4" ) + &( cSeek ) )
		While TY4->( !Eof() ) .And. &( cWhile )
			If aScan( aColsGrava, { | x | x[ nPosCal ] == TY4->TY4_CALEND .And. x[ nPosCur ] == TY4->TY4_CURSO .And. x[ nPosTur ] == TY4->TY4_TURMA .And. !x[ Len( x ) ] } ) == 0
				RecLock( "TY4", .F. )
					TY4->( dbDelete() )
				TY4->( MsUnLock() )
			EndIf
			dbSelectArea( "TY4" )
			TY4->( dbSkip() )
		End
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fGerTrm
Efetiva o registro de reserva de treinamento

@type Function

@source MDTA180.prx

@param nTipRel, Numerico, Indica o tipo de relacionamento (Obrigatório)
@param oGetDad, Objeto, Indica o objeto da GetDados (Obrigatório)

@sample fGerTrm( 1 , oGetDad )

@return Lógico, IdentIfica se gerou os treinamentos

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fGerTrm( nTipRel , oGetDad )

	Local nX
	Local nY
	Local oDlgTrm
	Local nGetTre	:= 0
	Local nPosCal 	:= 1
	Local nPosCur   := 0
	Local nPosTur   := 0
	Local aFunc		:= {}
	Local lRet		:= .T.
	Local nPosic	:= oGetDad:nAt

	//Variaveis do Mark
	Private cTRBTre
	Private lInverte	:= .F.
	Private cMarca 		:= GetMark()

	//Variaveis da Pesquisa
	Private cPesquisar := Space( 200 ) //Valor a ser pesquisado
	Private cCbxPesq   := ""
	Private aCbxPesq   //ComboBox com indices de pesquisa
	Private oBtnPesq
	Private oPesquisar //Botao de Pesquisa e Campo para Pesquisa
	Private oCbxPesq   //ComboBox de Pesquisa

	//Efetiva o aCols e aHeader
	aCols 	:= oGetDad:aCols
	aHeader := oGetDad:aHeader

	If Len( aCols ) > 0 .And. !Empty( aCols[ 1, 1 ] )
		nPosCal	 := aScan( aHeader, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_CALEND" } )
		nPosCur	 := aScan( aHeader, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_CURSO" } )
		nPosTur	 := aScan( aHeader, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_TURMA" } )
		nPosDCal := aScan( aHeader, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_DESC" } )
		nPosDTre := aScan( aHeader, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_DESCCU" } )

		//Monta o TRB
		aTrei := {}
		aAdd( aTrei, { "OK", "C", 02, 0 } )
		aAdd( aTrei, { "MATFUN", "C", 06, 0 } )
		aAdd( aTrei, { "NOMFUN", "C", 30, 0 } )

		cTRBTre	:= GetNextAlias()

		oTempTre := FWTemporaryTable():New( cTRBTre, aTrei )
		oTempTre:AddIndex( "1", { "NOMFUN" }  )
		oTempTre:AddIndex( "2", { "MATFUN" }  )
		oTempTre:AddIndex( "3", { "OK" }  )
		oTempTre:Create()

		aTRB := {}
		aAdd( aTRB, { "OK", NIL, " ", } )
		aAdd( aTRB, { "MATFUN", NIL, STR0129, } )//"Matrícula"
		aAdd( aTRB, { "NOMFUN", NIL, STR0128, } )//"Nome"

		fBuscaFunc( nTipRel, cTRBTre )

		If ( cTRBTre )->( RecCount() ) > 0
			Define MsDialog oDlgTrm Title OemToAnsi( STR0125 ) From 64, 160 To 580, 736 OF oMainWnd Pixel //"Gerar Treinamentos"

					oPanelPai := TPanel():New( 0, 0, , oDlgTrm, , .T., .F., , , 0, 55, .T., .F. )
						oPanelPai:Align := CONTROL_ALIGN_ALLCLIENT

					//--- DESCRICAO ( TOPO )
					oPanel := TPanel():New( 0, 0, , oPanelPai, , .T., .F., , , 0, 55, .T., .F. )
						oPanel:Align := CONTROL_ALIGN_TOP

						@ 8, 9.6 To 45, 280 OF oPanel PIXEL

						TSay():New( 14, 12, { | | STR0223 + AllTrim( aCols[ nPosic, nPosDCal ] ) + " / " + AllTrim( aCols[ nPosic, nPosDTre ] ) }, oPanel, , , .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 200, 010 )//"Treinamento: XXX / YYY"
						TSay():New( 24, 12, { | | OemtoAnsi( STR0126 ) }, oPanel, , , .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 200, 010 )//"Estes são os funcionários que devem receber o treinamento."
						TSay():New( 34, 12, { | | OemtoAnsi( STR0127 ) }, oPanel, , , .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 200, 010 )//"Selecione aqueles que deverão estar na reserva do treinamento."

					//--- PESQUISAR
					//Define as opcoes de Pesquisa
					aCbxPesq := {}
					aAdd( aCbxPesq, STR0128 )//"Nome"
					aAdd( aCbxPesq, STR0129 )//"Matrícula"
					aAdd( aCbxPesq, STR0130 )//"Marcados"
					cCbxPesq := aCbxPesq[ 1 ]

					oPnlPesq 		:= TPanel():New( 01, 01, , oPanelPai, , , , CLR_BLACK, CLR_WHITE, 50, 30, .T., .T. )
						oPnlPesq:Align	:= CONTROL_ALIGN_TOP

							oCbxPesq := TComboBox():New( 002, 002, { | u | IIf( PCount() > 0, cCbxPesq := u, cCbxPesq ) },;
														 aCbxPesq, 200, 08, oPnlPesq, , { | | },;
														 , , , .T., , , , , , , , , "cCbxPesq" )
								oCbxPesq:bChange := { | | fSetIndex( cTRBTre, aCbxPesq, @cPesquisar, oMarkFun ) }

							oPesquisar := TGet():New( 015, 002, { | u | IIf( PCount() > 0, cPesquisar := u, cPesquisar ) }, oPnlPesq, 200, 008, "", { | | .T. }, CLR_BLACK, CLR_WHITE, ,;
									 				.F., , .T., , .F., { | | cCbxPesq != aCbxPesq[ Len( aCbxPesq ) ] }, .F., .F., , .F., .F., "", "cPesquisar", , , , .F. )

							oBtnPesq := TButton():New( 002, 220, STR0001, oPnlPesq, { | | fPesqTRB( cTRBTre, oMarkFun ) },;//"Pesquisar" //"Pesquisar"
													 70, 10, , , .F., .T., .F., , .F., , , .F. )

					oMarkFun := MsSelect():New( ( cTRBTre ), "OK", , aTRB, @lInverte, @cMarca, { 60, 5, 281, 292 }, , , oPanelPai )
						oMarkFun:oBrowse:lHasMark		:= .T.
						oMarkFun:oBrowse:lCanAllMark	:= .T.
						oMarkFun:oBrowse:bAllMark		:= { | | fInverte( cMarca, cTRBTre, oMarkFun, .T. ) }//Funcao inverte marcadores
						oMarkFun:bMark	   				:= { | | fInverte( cMarca, cTRBTre, oMarkFun ) }//Funcao inverte marcadores
						oMarkFun:oBrowse:Align			:= CONTROL_ALIGN_ALLCLIENT

			Activate MsDialog oDlgTrm On Init EnchoiceBar(	oDlgTrm,;
															 { | | nGetTre := 1, IIf( fVldGerTrm( cTRBTre, aCols, aHeader, nPosic ), oDlgTrm:End(), nGetTre := 0 ) },;
															 { | | nGetTre := 0, oDlgTrm:End() } ) CENTERED
			If nGetTre == 1
				dbSelectArea( cTRBTre )
				dbSetOrder( 1 )
				dbGoTop()
				While !Eof()
					If !Empty( ( cTRBTre )->OK )
						aAdd( aFunc, { ( cTRBTre )->MATFUN } )
					EndIf
					dbSelectArea( cTRBTre )
					dbSkip()
				End

				cGerTre	:= aCols[ nPosic, nPosCal ]
				cGerCur := aCols[ nPosic, nPosCur ]
				cTurma	:= aCols[ nPosic, nPosTur ]
				dbSelectArea( "RA2" )
				dbSetOrder( 1 )
				If dbSeek( xFilial( "RA2" ) + cGerTre + cGerCur + cTurma ) .And. ;
					( Empty( RA2->RA2_REALIZ ) .Or. AllTrim( RA2->RA2_REALIZ ) == "N" )
					dbSelectArea( "RA4" )
					dbSetOrder( 3 )
					For nX := 1 To Len( aFunc )
						If dbSeek( xFilial( "RA4" ) + cGerTre + cGerCur + cTurma + aFunc[ nX, 1 ] )
							RecLock( "RA4", .F. )
								RA4->( dbDelete() )
							RA4->( MsUnLock() )
						EndIf
					Next nX

					dbSelectArea( "RAI" )
					dbSetOrder( 1 )
					For nX := 1 To Len( aFunc )
						If dbSeek( xFilial( "RAI" ) + cGerTre + cGerCur + cTurma + aFunc[ nX, 1 ] )
							RecLock( "RAI", .F. )
								RAI->( dbDelete() )
							RAI->( MsUnLock() )
						EndIf
					Next nX


					dbSelectArea( "RA3" )
					dbSetOrder( 1 )
					For nX := 1 To Len( aFunc )
						If dbSeek( xFilial( "RA3" ) + aFunc[ nX, 1 ] + cGerCur )
							RecLock( "RA3", .F. )
						Else
							RecLock( "RA3", .T. )
						EndIf
							RA3->RA3_FILIAL	:= xFilial( "RA3" )
							RA3->RA3_MAT	:= aFunc[ nX, 1 ]
							RA3->RA3_CURSO	:= cGerCur
							RA3->RA3_DATA	:= dDataBase
							RA3->RA3_TURMA	:= cTurma
							RA3->RA3_CALEND	:= cGerTre
							RA3->RA3_RESERV	:= "S"
							RA3->RA3_NVEZAD	:= 0
							RA3->RA3_SEQ	:= 0
						RA3->(MsUnLock())
					Next nX
				EndIf
			EndIf
		Else
			MsgInfo( STR0131 )//"Não há funcionários para gerar treinamentos."
			lRet := .F.
		EndIf
		oTempTre:Delete()
	Else
		MsgInfo( STR0132 )//"Não há treinamentos para serem gerados."
		lRet := .F.
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fBuscaFunc
Busca os Funcionarios

@type Function

@source MDTA180.prx

@param nTipRel, Numerico, Indica o Tipo de Busca (Obrigatório)
@param cAliasTRB, Caracter, Indica a tabela temporaria a ser alimentada (Obrigatório)

@sample fInverte( "X" , 'TRB' )

@return Nulo

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fBuscaFunc( nTipRel , cAliasTRB )

	Local nX
	Local cFiltroSRA

	If nTipRel == 1 .Or. nTipRel == 2
		If nTipRel == 2
			cFiltroSRA := "SRA->RA_CODFUNC == '" + SRJ->RJ_FUNCAO + "'"
		Else
			cFiltroSRA := "SRA->RA_CC == '" + CTT->CTT_CUSTO + "'"
		EndIf

		dbSelectArea( "SRA" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "SRA" ) )
		While SRA->( !Eof() ) .And. xFilial( "SRA" ) == SRA->RA_FILIAL

			If SRA->RA_SITFOLH != "D" .And. Empty( SRA->RA_DEMISSA ) .And. &( cFiltroSRA )
				RecLock( cAliasTRB, .T. )
					( cAliasTRB )->OK		:= ""
					( cAliasTRB )->MATFUN	:= SRA->RA_MAT
					( cAliasTRB )->NOMFUN	:= SRA->RA_NOME
				( cAliasTRB )->( MsUnLock() )
			EndIf

			SRA->( dbSkip() )
		End
	ElseIf nTipRel == 3
		dbSelectArea( "TN6" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "TN6" ) + TN5->TN5_CODTAR )
		While TN6->( !Eof() ) .And. xFilial( "TN6" ) == TN6->TN6_FILIAL .And. ;
			TN6->TN6_CODTAR == TN5->TN5_CODTAR
			dbSelectArea( "SRA" )
			dbSetOrder( 1 )
			If dbSeek( xFilial( "SRA" ) + TN6->TN6_MAT ) .And. SRA->RA_SITFOLH <> "D" .And. ;
				Empty( SRA->RA_DEMISSA ) .And. ( Empty( TN6->TN6_DTTERM ) .Or. TN6->TN6_DTTERM > dDataBase )
				RecLock( cAliasTRB, .T. )
					( cAliasTRB )->OK		:= ""
					( cAliasTRB )->MATFUN	:= SRA->RA_MAT
					( cAliasTRB )->NOMFUN	:= SRA->RA_NOME
				( cAliasTRB )->( MsUnLock() )
			EndIf
			TN6->( dbSkip() )
		End
	ElseIf nTipRel == 4
		aCampos := {	{ "TMPA_MATRI" , "C" , TAMSX3( "RA_MAT" )[ 1 ] , 0 } , ;
		             	{ "TMPA_NOMFU" , "C" , TAMSX3( "RA_NOME" )[ 1 ] , 0 } , ;
		             	{ "TMPA_DTINI" , "D" , 8 , 0 } , ;
		             	{ "TMPA_DTFIM" , "D" , 8 , 0 } , ;
		             	{ "TMPA_TAREF" , "C" , TAMSX3( "TN5_NOMTAR" )[ 1 ] , 0 } , ;
		             	{ "TMPA_CCUST" , "C" , TAMSX3( "CTT_DESC01" )[ 1 ] , 0 } , ;
		             	{ "TMPA_FUNCA" , "C" , TAMSX3( "RJ_DESC" )[ 1 ] , 0 } , ;
		             	{ "TMPA_NVFIL" , "C" , TAMSX3( "RA_FILIAL" )[ 1 ] , 0 } , ;
						{ "TMPA_DEPTO" , "C", TAMSX3( "TM0_DEPTO" )[ 1 ] , 0 } }

		oTempFunc := FWTemporaryTable():New( "TMPA", aCampos )
		oTempFunc:AddIndex( "1", { "TMPA_NOMFU" }  )
		oTempFunc:Create()

		MDT180BFUN()

		dbSelectArea( "TMPA" )
		dbGoTop()
		While TMPA->( !Eof() )

			aDatasGer := {}

			If TN0->TN0_CODTAR != Padr( "*", Len( TN0->TN0_CODTAR ) )
				fWTarefas( @aDatasGer, TN0->TN0_CODTAR, TMPA->TMPA_MATRI, TN0->TN0_DTRECO, TN0->TN0_DTELIM )
			Else
				aAdd( aDatasGer, { TN0->TN0_DTRECO, TN0->TN0_DTELIM } )
			EndIf

			//Caso o funcionário já foi adicionado na TRB
			dbSelectArea( cAliasTRB )
			If !dbSeek( TMPA->TMPA_NOMFU )
				dbSelectArea( "SRA" )
				dbSetOrder( 1 )
				If dbSeek( xFilial( "SRA" ) + TMPA->TMPA_MATRI ) .And. SRA->RA_SITFOLH != "D" .And. ;
					Empty( SRA->RA_DEMISSA )

					For nX := 1 To Len( aDatasGer )
						If Empty( aDatasGer[ nX, 2 ] ) .Or. aDatasGer[ nX, 2 ] > dDataBase
							RecLock( cAliasTRB, .T. )
								( cAliasTRB )->OK		:= ""
								( cAliasTRB )->MATFUN	:= SRA->RA_MAT
								( cAliasTRB )->NOMFUN	:= SRA->RA_NOME
							( cAliasTRB )->( MsUnLock() )
						EndIf

					Next nX

				EndIf
				aDatasGer := {}
			EndIf
			dbSelectArea( "TMPA" )
			TMPA->( dbSkip() )
		End

		oTempFunc:Delete()
	EndIf
	dbSelectArea( cAliasTRB )
	dbGoTop()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fInverte
Inverte a marcacao do browse

@type Function

@source MDTA180.prx

@param cMarca, Caracter, Indica o valor do campo 'OK' (Obrigatório)
@param cAliasTRB, Caracter, Alias da Tabela Temporária Utilizada (Obrigatório)
@param oMark, Objeto, Objeto do MarkBrowse (Obrigatório)
@param [lAll], Lógico, Indica se é inverte todas as Marcações

@sample fInverte( "X" , 'TRB' , oObj )

@return Lógico, Sempre verdadeiro

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fInverte( cMarca, cAliasTRB, oMark, lAll )

	Local aArea := {}

	Default lAll := .F.

	If lAll
		aArea := GetArea()

		dbSelectArea( cAliasTRB )
		dbGoTop()
		While ( cAliasTRB )->( !Eof() )
			( cAliasTRB )->OK := IIf( Empty( ( cAliasTRB )->OK ), cMarca, Space( Len( cMarca ) ) )
			(cAliasTRB)->( dbskip() )
		End

		RestArea( aArea )
	EndIf

	// Atualiza markbrowse
	oMark:oBrowse:Refresh()

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fVldGerTrm
Valida gravação do Treinamento

@type Function

@source MDTA180.prx

@param cTRBTre, Caracter, Tabela temporaria com os funcionarios (Obrigatório)
@param aCols, Array, Array atual do aCols (Obrigatório)
@param aHeader, Array, Array atual do aHeader (Obrigatório)

@sample fVldGerTrm( 'TRB' , {} , {} )

@return Lógico, Retorna verdadeiro caso treinamento possa ser reservado

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fVldGerTrm( cTRBTre, aCols, aHeader, nPosic )

	Local nX
	Local nCont	  := 0
	Local nMax    := 0
	Local lRet	  := .T.
	Local aSCargo := {}
	Local cMsgHlp := ""

	nPosCal	 := aScan( aHeader, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_CALEND" } )
	nPosCur	 := aScan( aHeader, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_CURSO" } )
	nPosTur	 := aScan( aHeader, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_TURMA" } )
	nPosDesc := aScan( aHeader, { | x | AllTrim( Upper( x[ 2 ] ) ) == "TY4_DESCCU" } )

	cGerTre	 := aCols[ nPosic, nPosCal  ]
	cGerCur  := aCols[ nPosic, nPosCur  ]
	cTurma	 := aCols[ nPosic, nPosTur  ]
	cDescCur := aCols[ nPosic, nPosDesc ]

	dbSelectArea( "RA2" )
	dbSetOrder( 1 )
	If dbSeek( xFilial( "RA2" ) + cGerTre + cGerCur + cTurma )
		nMax := RA2->RA2_VAGAS - RA2->RA2_RESERV
	EndIf

	dbSelectArea( cTRBTre )
	dbSetOrder( 1 )
	dbGoTop()
	While ( cTRBTre )->( !Eof() )
		If !Empty( ( cTRBTre )->OK )
			nCont ++
			If !fExistCargo( ( cTRBTre )->MATFUN )
				aAdd( aSCargo, ( cTRBTre )->MATFUN )
			EndIf
		EndIf
		dbSelectArea( cTRBTre )
		dbSkip()
	End
	If Len( aSCargo ) > 0
		Help( ' ', 1, STR0032, , STR0133 + fRetFunc( aSCargo ), 2, 0, , , , , , { STR0134 } ) //"ATENÇÃO"##"O(s) seguinte(s) funcionário(s) está(ão) sem cargo:"##//"Favor infomar cargo(s) para a(s) função(ões) do(s) funcionário(s)."
		dbSelectArea( cTRBTre )
		dbGoTop()
		lRet := .F.
	EndIf
	If lRet
		If nCont > nMax
			// Número de funcionários maior que o permitido. O treinamento OPERAÇÕES PERIGOSAS possui 15 vaga(s).
			cMsgHlp := STR0135 + " " + STR0224 + AllTrim( cDescCur ) + STR0225 + cValToChar( nMax ) + STR0226 + "."
			Help( ' ',  1, STR0032, , cMsgHlp, 2, 0, , , , , , { STR0136 } )//Atenção##"Selecione um número menor de funcionários que irão fazer o treinamento."
			dbSelectArea( cTRBTre )
			dbGoTop()
			lRet := .F.
		ElseIf nCont == 0
			Help( ' ', 1, STR0032, , STR0137, 2, 0, , , , , , { STR0138 } ) //Atenção##Nenhum funcionário selecionado. Informe ao menos um funcionários para geração do treinamento ou clique no botão cancelar para sair."
			dbSelectArea( cTRBTre )
			dbGoTop()
			lRet := .F.
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fExistCargo
Verifica a existencia de cargo para o funcionario

@type Function

@source MDTA180.prx

@param cMat, Caracter, Matricula a ser validada (Obrigatório)

@sample fExistCargo( '000001' )

@return Lógico, Retorna verdadeiro quando cargo do funcionário for preenchido (necessário para o TRM)

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fExistCargo( cMat )

	Local aArea := GetArea()
	Local lRet:= .T.

	dbSelectArea( "SRA" )
	dbSetOrder( 1 )
	If ( lRet := SRA->( dbSeek( xFilial("SRA") + cMat ) ) )
		If Empty( SRA->RA_CARGO )
			dbSelectArea( "SRJ" )
			dbSetOrder( 1 )
			If ( lRet := SRJ->( dbSeek( xFilial( "SRJ" ) + SRA->RA_CODFUNC ) ) )
			   lRet:= !Empty( SRJ->RJ_CARGO )
		    EndIf
		EndIf
	EndIf

	RestArea( aArea )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fRetFunc
Retorna o nome dos funcionários

@type Function

@source MDTA180.prx

@param aFuncionarios, Array, Matriz com os funcionários a serem considerados (Obrigatório)

@sample fRetFunc( { '000001' } )

@return Caracter,  String com o nome de todos os funcionários

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fRetFunc( aFuncionarios )

	Local nX
	Local cFunc := ""

	For nX := 1 To Len( aFuncionarios )
		If Empty( cFunc )
			cFunc += AllTrim( NGSEEK( "SRA", aFuncionarios[ nX ], 1, "RA_NOME" ) )
		Else
			cFunc += ", " + AllTrim( NGSEEK( "SRA", aFuncionarios[ nX ], 1, "RA_NOME" ) )
		EndIf
	Next nX

Return cFunc

//---------------------------------------------------------------------
/*/{Protheus.doc} fSetIndex
Seta o indice para pesquisa

@type Function

@source MDTA180.prx

@param cAliasTRB, Caracter, Alias do TRB ( Obrigatório )
@param aCbxPesq,Array, Indices de pesquisa do markbrowse. ( Obrigatório )
@param cPesquisar, Caracter, Valor da Pesquisa ( Obrigatório )
@param oMark, Objeto, Objeto do MarkBrowse ( Obrigatório )

@sample fSetIndex( 'TRB' , {} , 'Pesq' , Obj )

@return Nulo

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fSetIndex( cAliasTRB, aCbxPesq, cPesquisar, oMark )

	Local nIndice := fRetInd( aCbxPesq ) // Retorna numero do indice selecionado

	// Efetua ordenacao do alias do markbrowse, conforme indice selecionado
	dbSelectArea( cAliasTRB )
	dbSetOrder( nIndice )
	dbGoTop()

	// Se o indice selecionado for o ultimo [Marcados]
	If nIndice == Len( aCbxPesq )
		cPesquisar := Space( Len( cPesquisar ) ) // Limpa campo de pesquisa
		oPesquisar:Disable()              // Desabilita campo de pesquisa
		oBtnPesq:Disable()              // Desabilita botao de pesquisa
		oMark:oBrowse:SetFocus()     // Define foco no markbrowse
	Else
		oPesquisar:Enable()               // Habilita campo de pesquisa
		oBtnPesq:Enable()               // Habilita botao de pesquisa
		oBtnPesq:SetFocus()             // Define foco no campo de pesquisa
	EndIf

	oMark:oBrowse:Refresh()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fRetInd
Retorna o indice, em numero, do item selecionado no combobox

@type Function

@source MDTA180.prx

@param aIndMrk, Array, Indices de pesquisa do markbrowse. ( Obrigatório )

@sample fRetInd( {} )

@return Numerico, Retorna o valor do Indice

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fRetInd( aIndMrk )

	Local nIndice := aScan( aIndMrk, { | x | AllTrim( x ) == AllTrim( cCbxPesq ) } )

	// Se o indice nao foi encontrado nos indices pre-definidos, apresenta mensagem
	If nIndice == 0
		ShowHelpDlg( STR0032, { STR0139 }, 1,; //Atenção//"Índice não encontrado."
					 { STR0140 }, 1 )          //"Contate o administrador do sistema."
		nIndice := 1
	EndIf

Return nIndice

//---------------------------------------------------------------------
/*/{Protheus.doc} fPesqTRB
Funcao de Pesquisar no Browse.

@type Function

@source MDTA180.prx

@param cAliasTRB, Caracter, Alias do MarkBrowse ( Obrigatório )
@param oMark, Objeto, Objeto do MarkBrowse ( Obrigatório )

@sample fPesqTRB( 'TRB' , oObj )

@return Lógico, Indica se localizou no TRB

@author Jackson Machado
@since 28/09/2015
/*/
//---------------------------------------------------------------------
Static Function fPesqTRB( cAliasTRB, oMark )

	Local nRecNoAtu := 1//Variavel para salvar o recno
	Local lRet		:= .T.

	//Posiciona no TRB e salva o recno
	dbSelectArea( cAliasTRB )
	nRecNoAtu := RecNo()

	dbSelectArea( cAliasTRB )
	If dbSeek( AllTrim( cPesquisar ) )
		//Caso exista a pesquisa, posiciona
		oMark:oBrowse:SetFocus()
	Else
		//Caso nao exista, retorna ao primeiro recno e exibe mensagem
		dbGoTo( nRecNoAtu )
		ApMsgInfo( STR0141, STR0032 )//"Valor não encontrado."//ATENÇÃO
		oPesquisar:SetFocus()
		lRet := .F.
	EndIf

	// Atualiza markbrowse
	oMark:oBrowse:Refresh( .T. )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180RIS
Função para verificar se o funcionário esta exposto em algum outro risco
para alimentar os campos de Periculosidade e Insalubridade

@type Function

@source MDTA180.prx

@Param cMatricula, Caracter, Matricula do funcionário
@Param cNumRisco, Caracter, Risco em que o funcionário esta exposto.

@sample MDT180RIS( '000001' , '000000001' , 3 )

@return Caracter, Retorno o código do risco

@author Jean Pytter da Costa
@since 25/02/2016
/*/
//---------------------------------------------------------------------
Function MDT180RIS( cMatricula, cNumRisco, nOpc, dDtElimi )

	Local aRisExp   := {}
	Local cCodRisco	:= ""
	Local cIntAdic  := ""
	Local cRisInt	:= ""
	Local cRisAge	:= ""
	Local cAgeTipo	:= ""

	Local nX

	Default dDtElimi := CToD( "" )

	dbSelectArea( "SRA" )
	dbSetOrder( 1 )
	If dbSeek( xFilial( "SRA" ) + cMatricula )
		aRisExp := MDTRisFun( cMatricula, SRA->RA_CC, SRA->RA_CODFUNC, , SRA->RA_DEPTO, 1 )
	EndIf

	For nX := 1 To Len( aRisExp )

		If ( nOpc == 5 .And. aRisExp[ nX, 1 ] == cNumRisco ) .Or.; //desconsidera o risco em exclusão
			( nOpc == 4 .And. aRisExp[ nX, 1 ] == cNumRisco .And. !Empty(dDtElimi) .And. dDtElimi <= dDataBase) //desconsidera o risco em eliminação
			Loop
		EndIf

		cAgeTipo := ""

		dbSelectArea( "TN0" )
		dbSetOrder( 1 ) //TN0_FILIAL+TN0_NUMRIS
		If dbSeek( xFilial( "TN0" ) + aRisExp[ nX, 1 ] )

			cRisInt := TN0->TN0_PERINT //Intensidade do risco 1-10% 2-20% 3-30% 4-40% 5-Não caracteriza
			cRisAge := TN0->TN0_AGENTE

			dbSelectArea( "TMA" )
			dbSetOrder( 1 ) //TMA_FILIAL+TMA_AGENTE
			If dbSeek( xFilial( "TMA" ) + cRisAge )
				If !Empty( TMA->TMA_TIPADI ) //1-Insalubridade 2-Periculosidade
					cAgeTipo := TMA->TMA_TIPADI
				EndIf
			EndIf
		EndIf

		//Se não tiver pego valor ou o valor de percentual já salvo for menor que o do risco atual,
		//pega o valor do risco atual
		If !Empty( cAgeTipo ) .And. ; //Verifica se o risco possui algum adicional
			( Empty( cIntAdic ) .Or. Val( cIntAdic ) < Val( cRisInt ) ) .And. ;
			cRisInt != "5" .And. Empty( TN0->TN0_DTELIM )//Se Risco atual for Não caracteriza, nao considera

			cCodRisco := aRisExp[ nX, 1 ]
			cIntAdic  := cRisInt

		EndIf

	Next nX

Return cCodRisco

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180INT
Função para alimentar os campos do GPEA010(SRA) de Periculosidade e Insalubridade

@type Function

@source MDTA180.prx

@param cMatricula, Caracter, Matricula do funcionário
@param cNumRisco, Caracter, Risco em que o funcionário esta exposto.
@param lFim, Lógico, Define se é finalização do risco
@param nOpc, Numerico, Operação sendo realizada no momento
@param [cFilDIf], Caracter, Informa a filial, caso for dIferente da logada
@param [dDtElimi], Data, Data de Eliminação

@sample MDT180INT( '000001' , '000000001' , .F. , 3, 'D MG 02', 01/09/2020 )

@return Lógico, Sempre verdadeiro

@author Jean Pytter da Costa
@since 19/02/2016
/*/
//---------------------------------------------------------------------
Function MDT180INT( cMatricula, cNumRisco, lFim, nOpc, cFilDIf, dDtElimi )

	Local nTempEx		:= 0
	Local cRisInt		:= ""
	Local cRisPer		:= ""
	Local cRisIns		:= ""
	Local cRisAge		:= ""
	Local cAgeTipo		:= ""
	Local cFilAntOld	:= cFilAnt

	Default cFilDIf := cFilAnt
	Default dDtElimi := CToD( "" )

	cNumRisco := MDT180RIS( cMatricula, cNumRisco, nOpc, dDtElimi ) //Verifica ql risco q possui maior % para alimentar os campos
	If Empty( cNumRisco )
		lFim := .T.
	EndIf

	If !lFim
		//Verifica se o risco é salubre ou periculoso, e recebe a intensidade
		dbSelectArea( "TN0" )
		dbSetOrder( 1 ) //TN0_FILIAL+TN0_NUMRIS
		If dbSeek( xFilial( "TN0" ) + cNumRisco )
			cRisInt := TN0->TN0_PERINT //Intensidade do risco 1-10% 2-20% 3-30% 4-40% 5-Não caracteriza
			cRisPer := TN0->TN0_ATIPER //Risco  1-Não periculoso 2-Periculoso
			cRisIns := TN0->TN0_ATISAL //Risco  1- Salubre 2-Insalubre
			cRisAge := TN0->TN0_AGENTE
			nTempEx := HToN( TN0->TN0_QTEXPO ) //Tempo de Exposição

			dbSelectArea( "TMA" )
			dbSetOrder( 1 ) //TMA_FILIAL+TMA_AGENTE
			If DbSeek( xFilial( "TMA" ) + cRisAge )
				If !Empty( TMA->TMA_TIPADI ) //1-Insalubridade 2-Periculosidade
					cAgeTipo := TMA->TMA_TIPADI
				EndIf
			EndIf
		EndIf

		//cFilAnt recebe a nova filial para posicionar no seek
		If !Empty( cFilDIf )
			cFilAnt := cFilDIf
		EndIf

		dbSelectArea( "SRA" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "SRA", cFilDIf ) + cMatricula )
			RecLock( "SRA", .F. )
				If cAgeTipo == "1" //Risco insalubre
					//verifica se o funcionário possui Periculosidade e
					//se % de Insalubridade é maior, pois devera considerar o maior %
					//Ou caso seja transferencia e o risco de destino seja insalubre
					If SRA->RA_ADCPERI == "1" .Or. nOpc == 4 .And. !Empty(dDtElimi) .Or. FWIsInCallStack( "GPEA180" )

						//Caso esteja eliminando o risco, garante que a periculosidade estará como não e as horas zeradas
						//Ou seja transferencia
						If nOpc == 4 .And. !Empty(dDtElimi) .Or. FWIsInCallStack( "GPEA180" )
							SRA->RA_ADCPERI := "1"
							SRA->RA_PERICUL := 0
						EndIf

						Do Case

							Case cRisIns == "1" //Salubre
								SRA->RA_ADCINS := cRisIns
								SRA->RA_INSMAX := 0

							Case cRisIns == "2" //Insalubre
								If cRisInt == "1"
									SRA->RA_ADCINS := "2" //Leve
									SRA->RA_INSMAX := SRA->RA_HRSMES//nTempEx
								ElseIf cRisInt == "2"
									SRA->RA_ADCINS := "3" //Média
									SRA->RA_INSMAX := SRA->RA_HRSMES//nTempEx
								ElseIf cRisInt == "4"
									SRA->RA_ADCINS := cRisInt //Alta
									SRA->RA_INSMAX := SRA->RA_HRSMES//nTempEx
								ElseIf cRisInt == "5"
									SRA->RA_ADCINS := "1" //Não tem % de intensidade
									SRA->RA_INSMAX := 0
								EndIf

						EndCase

					//Não ira considerar o risco insalubre, pois o % é menor do que o risco de Periculosidade
					ElseIf SRA->RA_ADCPERI == "2" .And. ( cRisInt == "1" .Or. cRisInt == "2" .Or. cRisInt == "5" )
						SRA->RA_ADCINS := "1"
						SRA->RA_INSMAX := 0

					//Ira considerar o risco insalubre, pois o % é maior do que o risco de Periculosidade
					ElseIf SRA->RA_ADCPERI == "2" .And. cRisInt == "4"
						SRA->RA_ADCPERI := "1"
						SRA->RA_PERICUL := 0
						SRA->RA_ADCINS := cRisInt
						SRA->RA_INSMAX := SRA->RA_HRSMES//nTempEx
					EndIf

				ElseIf cAgeTipo == "2" //Risco Periculoso
					//verifica se o funcionário possui Insalubridade e
					//se % de Periculosidade é maior, pois devera considerar o maior %
					If SRA->RA_ADCINS == "1"
						Do Case

							Case cRisPer == "1" //Não periculoso
								SRA->RA_ADCPERI := cRisPer
								SRA->RA_PERICUL := 0

							Case cRisPer == "2" //Periculoso
								If cRisInt == "3"
									SRA->RA_ADCPERI := "2" //Sim
									SRA->RA_PERICUL := SRA->RA_HRSMES//nTempEx
								ElseIf cRisInt == "5"
									SRA->RA_ADCPERI := "1" //Não
									SRA->RA_PERICUL := 0
								EndIf

						EndCase

					//Não ira considerar o risco insalubre, pois o % é menor do que o risco de Periculosidade
					ElseIf cRisPer == "2"
						SRA->RA_ADCINS := "1"
						SRA->RA_INSMAX := 0
						SRA->RA_ADCPERI := "2"
						SRA->RA_PERICUL := SRA->RA_HRSMES//nTempEx
					EndIf
				EndIf
			SRA->( MsUnlock() )
		EndIf
	Else

		//cFilAnt recebe a nova filial para posicionar no seek
		If !Empty( cFilDIf )
			cFilAnt := cFilDIf
		EndIf

		//Os campos recebem o valor padrão
		dbSelectArea( "SRA" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "SRA", cFilDIf ) + cMatricula )

			RecLock( "SRA", .F. )
				SRA->RA_ADCINS  := "1"
				SRA->RA_INSMAX  := 0
				SRA->RA_ADCPERI := "1"
				SRA->RA_PERICUL := 0
			SRA->( MsUnlock() )

		EndIf

	EndIf

	//retorna para filial correta
	cFilAnt := cFilAntOld

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180Fil
Função de filtro do SQB em medicina e segurança do trabalho, é utilizado
 no cadastro de riscos e na função MDTFilDEP que é o filtro do SXB "MDTSQB"

@type Function

@source MDTA180.prx

@param nChamada, NUmerico, Indica tabela de excução
@param [lF3], Lógico, Indica se é por F3
@param [cFiltroSQB], Caracter, Filtro a ser executado
@param [cTRBFil], Caracter, TRB a ser filtrado

@return Lógico, Indica se registro é válido

@sample MDT180Fil( 1 )

@author Guilherme Benkendorf
@since 29/09/2015
/*/
//---------------------------------------------------------------------
Function MDT180Fil( nChamada, lF3, cFiltroSQB, cTRBFil )

	Local lRet    := .T.
	Local cTrbAux := ""
	Local aAuxCTT := {}

	Default lF3        := .F.
	Default cFiltroSQB := ""
	Default cTRBFil    := ""

	If nChamada == 1 //CTT
		lRet := CTT->CTT_BLOQ == "2"
	ElseIf nChamada == 2 //SQB
		If lF3
			SetPrmTela( "TN0_CC", @aAuxCTT )
			cTrbAux := aAuxCTT[ 2 ]
			nFldPos := aScan( aAuxCTT[ 4 ], { | x | x[ 1 ] == "CTT_CUSTO" } )
			If nFldPos > 0
				cFiltroSQB := "!Empty( Posicione( '" + cTrbAux +"', 1, SQB->QB_CC, '" + cTrbAux +"->CTT_OK' ) ) .Or. Empty(SQB->QB_CC)"
			EndIf
		Else
			cTrbAux := cTRBFil//Neste caso foi definido que o alias da trb foi passado
			If !Empty( SQB->QB_CC )
				If AllTrim( M->TN0_CC ) == "#"
					dbSelectArea( cTrbAux )
					dbSetOrder( 1 )
					lRet := dbSeek( SQB->QB_CC ) .And. !Empty( ( cTrbAux )->CTT_OK )
				ElseIf AllTrim( M->TN0_CC ) != "*"
					lRet := !Empty( SQB->QB_CC ) .And. ( M->TN0_CC == SQB->QB_CC )
				EndIf
			EndIf
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fValidDepto
Função de validação do Centro de Custo da SQB - Departamento, seja igual
a do Centro de Custo da TN0 - Riscos.

@type Function

@source MDTA180.prx

@sample fValidDepto()

@return Lógico, Indica se departamento é válido

@author Guilherme Benkendorf
@since 01/10/2015
/*/
//---------------------------------------------------------------------
Static Function fValidDepto()

	Local cCustoAux := ""
	Local lRet      := .T.
	Local aArea     := {}

	If lRet
		If !( AllTrim( M->TN0_CC ) $ "*#" )
			aArea:= GetArea()
			cCustoAux := NgSeek( "SQB", M->TN0_DEPTO, 1, "SQB->QB_CC" )
			If !Empty( cCustoAux ) .And. cCustoAux != M->TN0_CC
				MsgAlert( STR0116, STR0032 ) //"O departamento está com o Centro de Custo dIferente ao do Risco. Selecione um departamento que possua o mesmo Centro de Custo."//"Atenção"
				lRet := .F.
			EndIf
			RestArea( aArea )
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180AGL
Função para verificar se o funcionário esta exposto em algum outro risco
para alimentar os campos de Periculosidade e Insalubridade aglutinados

@type Function

@source MDTA180.prx

@param cMatricula, Caracter, Matricula do funcionário
@param cNumRisco, Caracter, Risco em que o funcionário esta exposto.
@param [cFilDIf], Caracter, Informa a filial, caso for dIferente da logada
@param nOpc, Numérico, informa o tipo de operação que está sendo realizada
@param dDtElimi, Data, informa a data de eliminação do Risco

@sample MDT180AGL( '000001' , '000000001', 'D MG 02', 4, 01/09/2020 )

@return Nulo

@author Jackson Machado
@since 21/06/2016
/*/
//---------------------------------------------------------------------
Function MDT180AGL( cMatricula, cNumRisco, cFilDIf, nOpc, dDtElimi )


	Local aRisExp    := {}
	Local cCodRisco	 := ""
	Local cIntAdic   := ""
	Local cRisInt	 := ""
	Local cRisAge	 := ""
	Local cAgeTipo	 := ""
	Local nTempEx 	 := 0
	Local cInsalub	 := "1"
	Local cRisIns	 := "1"
	Local cPericul	 := "1"
	Local cFilAntOld := cFilAnt
	Local nInTempEx  := 0
	Local nPeTempEx  := 0
	Local nX

	Default cFilDIf := cFilAnt
	Default dDtElimi := CToD( "" )

	//cFilAnt recebe a nova filial para posicionar no seek
	If !Empty( cFilDIf )
		cFilAnt := cFilDIf
	EndIf

	dbSelectArea( "SRA" )
	dbSetOrder( 1 )
	If dbSeek( xFilial( "SRA", cFilDIf ) + cMatricula )

		aRisExp := MDTRisFun( cMatricula, SRA->RA_CC, SRA->RA_CODFUNC, , SRA->RA_DEPTO, 1 )

		//cFilAnt recebe o valor do bkp para a função fazer as buscas pela filial coreta.
		cFilAnt := cFilAntOld

	EndIf

	For nX := 1 To Len( aRisExp )

		If ( nOpc == 5 .And. aRisExp[ nX, 1 ] == cNumRisco ) .Or.; //desconsidera o risco em exclusão
			( nOpc == 4 .And. aRisExp[ nX, 1 ] == cNumRisco .And. !Empty(dDtElimi) .And. dDtElimi <= dDataBase)
			Loop
		EndIf

		cAgeTipo := ""

		dbSelectArea( "TN0" )
		dbSetOrder( 1 ) //TN0_FILIAL+TN0_NUMRIS
		If dbSeek( xFilial( "TN0" ) + aRisExp[ nX, 1 ] )

			cRisInt := TN0->TN0_PERINT //Intensidade do risco 1-10% 2-20% 3-30% 4-40% 5-Não caracteriza
			cRisAge := TN0->TN0_AGENTE
			nTempEx := HToN( TN0->TN0_QTEXPO ) //Tempo de Exposição

			dbSelectArea( "TMA" )
			dbSetOrder( 1 ) //TMA_FILIAL+TMA_AGENTE
			If dbSeek( xFilial( "TMA" ) + cRisAge )
				If !Empty( TMA->TMA_TIPADI ) //1-Insalubridade 2-Periculosidade
					cAgeTipo := TMA->TMA_TIPADI
				EndIf
			EndIf

			If cAgeTipo == "1"
				cRisIns := "1"
				If cRisInt == "1"
					cRisIns := "2" //Leve
				ElseIf cRisInt == "2"
					cRisIns := "3" //Média
				ElseIf cRisInt == "4"
					cRisIns := cRisInt //Alta
				ElseIf cRisInt == "5"
					cRisIns := "1" //Não tem % de intensidade
				EndIf

				If Val( cRisIns ) > Val( cInsalub )
					cInsalub := cRisIns
				EndIf

				nInTempEx := SRA->RA_HRSMES//nTempEx
			ElseIf cAgeTipo == "2"
				cRisIns := "1"
				If cRisInt == "3"
					cRisIns := "2"
				ElseIf cRisInt == "5"
					cRisIns := "1" //Não tem % de intensidade
				EndIf
				If Val( cRisIns ) > Val( cPericul )
					cPericul := cRisIns
				EndIf
				nPeTempEx := SRA->RA_HRSMES//nTempEx
			EndIf
		EndIf

	Next nX

	//cFilAnt recebe a nova filial para posicionar no seek
	If !Empty( cFilDIf )
		cFilAnt := cFilDIf
	EndIf

	dbSelectArea( "SRA" )
	dbSetOrder( 1 )
	If dbSeek( xFilial( "SRA", cFilDIf ) + cMatricula )

		DbSelectArea( "SRA" )
		RecLock( "SRA", .F. )
			SRA->RA_ADCINS := cInsalub
			SRA->RA_INSMAX := nInTempEx
			SRA->RA_ADCPERI := cPericul
			SRA->RA_PERICUL := nPeTempEx
		SRA->( MsUnlock() )

	EndIf

	//retorna para filial correta
	cFilAnt := cFilAntOld

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180SXB
Função para retornar os riscos conforme o campo TN0_MAPRIS.

@type Function

@source MDTA180.prx

@sample MDT180SXB()

@return Lógico, Indica se apresenta todos riscos.

@author Jean Pytter da Costa
@since 12/08/2016
/*/
//---------------------------------------------------------------------
Function MDT180SXB()

	Local lRet := .T.

	If FwIsInCallStack( 'MDTA650' )

		If TN0->TN0_MAPRIS == '3'

			lRet := TAA->TAA_TIPOPL $ ( '1/2/3/5' )

		Else

			lRet := ( TN0->TN0_MAPRIS == TAA->TAA_TIPOPL )

		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180FSXB
Função para filtrar tabela de prod quimicos na utilização do SXB

@type Function

@source MDTA180.prx

@sample MDT180FSXB()

@return Lógico, sempre verdadeiro

@author Gabriel Gustavo de Mora
@since 14/09/2016
/*/
//---------------------------------------------------------------------
Function MDT180FSXB()

	Local lRet

	//Filtra tabela de Produtos Químicos para utilização no F3
	dbSelectArea( "TJB" )
	dbSetOrder( 1 )
	lRet := &( "TJB->TJB_FILIAL == xFilial( 'TJB' ) .And. " + ;
			 "'" + NGSEEK( "TJC", M->TN0_AGENTE + TJB->TJB_CODPRO, 1, "TJC_CODPRO") + "' == TJB->TJB_CODPRO .And. " + ;
			 If(lSigaMdtPs,"TJB_CLIENT+TJB_LOJA == cCliMdtPs",".T.") )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180EXAG
Gera os exames do Agente no Risco

@type Function

@source MDTA180.prx

@param cAgente, Caracter, Agente de Risco
@param cNumRis, Caracter, Número do Risco

@sample MDT180EXAG( 'RUIDO' , '000000001' )

@return Nulo

@author Jackson Machado
@since 14/02/2017
/*/
//---------------------------------------------------------------------
Function MDT180EXAG( cAgente, cNumRis )

	Local aArea		:= GetArea()
	Local cRelease	:= GetRpoRelease()

	dbSelectArea( "TMB" )
	dbSetOrder( 1 )
	dbSeek( xFilial( "TMB" ) + cAgente )
	While TMB->( !EoF() ) .And. TMB->TMB_FILIAL == xFilial( "TMB" ) .And. ;
		TMB->TMB_AGENTE == cAgente

		dbSelectArea( "TN2" )
		dbSetOrder( 1 )
		If !dbSeek( xFilial( "TN2" ) + cNumRis + TMB->TMB_EXAME )
			RecLock( "TN2", .T. )
			TN2->TN2_FILIAL	:= xFilial( "TN2" )
			TN2->TN2_NUMRIS	:= cNumRis
			TN2->TN2_EXAME	:= TMB->TMB_EXAME
			TN2->TN2_AGENTE	:= cAgente
			If TMB->( ColumnPos( "TMB_FAIXA" ) ) > 0 .And. !Empty( TMB->TMB_FAIXA ) .And. cRelease >= "12.1.023"
				TN2->TN2_FAIXA	:= TMB->TMB_FAIXA
			Else
				TN2->TN2_FAIXA	:= TMQ->TMQ_FAIXA
			EndIf
			TN2->TN2_TIPOEX := "11"
		EndIf

		TMB->( dbSkip() )
	End
	RestArea( aArea )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180CPY
Função para copiar os relacionamentos do Risco.

@type Function

@source MDTA180.prx

@author Jackson Machado
@since 14/02/2017

@param cAlias, Caracter, Tabela posicionada
@param nRecno, Numérico, Posição do RECNO
@param nOpcX, Numérico, Operação selecionada

@sample MDT180CPY( 'TN0' , 1 , 4 )

@return Lógico, Indica se apresenta todos riscos.
/*/
//---------------------------------------------------------------------
Function MDT180CPY( cAlias, nRecno, nOpcX )

	Local ny
	Local nx
	Local nIdx
	Local nRowChk
	Local nColChk
	Local nTotMrk
	Local nRelac
	Local nChk
	Local oDlgCpy
	Local oTrbRis
	Local oPanel
	Local oPnlMrk
	Local oPnlDlg
	Local aRelacio 	:= MDT181RELAC()
	Local aChkRel	:= {}
	Local lConfirm	:= .F.
	Local lVldCpy	:= .T.
	Local cRisCpy	:= TN0->TN0_NUMRIS
	Local cSeekCmp	:= ""
	Local aRisDBF	:= {}
	Local aRisTRB	:= {}

	//Variaveis do Mark
	Private lInverte	:= .F.
	Private cTRBRis		:= GetNextAlias()
	Private cMarca 		:= GetMark()

	//Variaveis da Pesquisa
	Private cPesquisar := Space( 200 )//Valor a ser pesquisado
	Private cCbxPesq   := ""
	Private aCbxPesq   //ComboBox com indices de pesquisa
	Private oBtnPesq
	Private oPesquisar //Botao de Pesquisa e Campo para Pesquisa
	Private oCbxPesq   //ComboBox de Pesquisa
	Private oMarkRis

	//Percorre o array de relacionamentos para verificar os relacionamentos a serem copiados
	For nRelac := 1 To Len( aRelacio )
		//Verifica se existe valor em algum dos relacionamentos
		dbSelectArea( aRelacio[ nRelac, 1 ] )
		If ( nIdx := NGRETORDEM( aRelacio[ nRelac, 1 ], PrefixoCPO( aRelacio[ nRelac, 1 ] ) + "_FILIAL+" + PrefixoCPO( aRelacio[ nRelac, 1 ] ) + "_NUMRIS", .F. ) ) == 0
			nIdx := 1
		EndIf
		dbSetOrder( nIdx )
		If dbSeek( xFilial( aRelacio[ nRelac, 1 ] ) + cRisCpy + IIf( aRelacio[ nRelac, 1 ] == "TO9", IIf( aRelacio[ nRelac, 4 ] == "ST9", "1", "2" ), "" ) ) .And. ;
			aScan( aChkRel, { | x | x[ 1 ] == aRelacio[ nRelac, 1 ] .And. x[ 5 ] == aRelacio[ nRelac, 4 ] } ) == 0

			aAdd( aChkRel, { aRelacio[ nRelac, 1 ], aRelacio[ nRelac, 2 ] , aRelacio[ nRelac, 3 ], .F., aRelacio[ nRelac, 4 ] } )

		EndIf
	Next nRelac

	//Calcula a quantidade de linhas de check que terá em tela
	nTotMrk := Round( Len( aChkRel ) / 2, 0 )

	//Monta o TRB
	aRisDBF := {}
	aAdd( aRisDBF, { "OK", "C", 02, 0 } )
	aAdd( aRisDBF, { "NUMRIS", "C", 09, 0 } )
	aAdd( aRisDBF, { "AGENTE", "C", TamSX3( "TMA_NOMAGE" )[1], 0 } )
	aAdd( aRisDBF, { "CCUSTO", "C", TamSX3( "CTT_DESC01" )[1], 0 } )
	aAdd( aRisDBF, { "DEPTO", "C", TamSX3( "QB_DESCRIC" )[1], 0 } )
	aAdd( aRisDBF, { "FUNCAO", "C", TamSX3( "RJ_DESC" )[1], 0 } )
	aAdd( aRisDBF, { "TAREFA", "C", TamSX3( "TN5_NOMTAR" )[1], 0 } )

	oTrbRis := FWTemporaryTable():New( cTRBRis, aRisDBF )
	oTrbRis:AddIndex( "1", { "AGENTE", "NUMRIS" } )
	oTrbRis:AddIndex( "2", { "NUMRIS", "AGENTE" } )
	oTrbRis:AddIndex( "3", { "CCUSTO" } )
	oTrbRis:AddIndex( "4", { "FUNCAO" } )
	oTrbRis:AddIndex( "5", { "TAREFA" } )
	oTrbRis:AddIndex( "6", { "DEPTO" } )
	oTrbRis:Create()

	aRisTRB := {}
	aAdd( aRisTRB, { "OK", NIL, " ", } )
	aAdd( aRisTRB, { "NUMRIS", NIL, STR0151, } ) //"Código"
	aAdd( aRisTRB, { "AGENTE", NIL, STR0066, } ) //"Agente"
	aAdd( aRisTRB, { "CCUSTO", NIL, STR0147, } ) //"Centro Custo"
	aAdd( aRisTRB, { "DEPTO", NIL, STR0114, } )  //"Departamento"
	aAdd( aRisTRB, { "FUNCAO", NIL, STR0054, } ) //"Função"
	aAdd( aRisTRB, { "TAREFA", NIL, STR0055, } ) //"Tarefa"

	//Busca os riscos dIferentes daquele que está como base para cópia
	fBuscaRis( cTRBRis, cRisCpy )

	//Caso não existam mais riscos ou não existem relacionamentos a serem copiados, não abre a tela
	If ( cTRBRis )->( RecCount() ) > 0 .And. Len( aChkRel ) > 0
		Define MsDialog oDlgCpy Title OemToAnsi( STR0148 ) From 64, 160 To 580, 736 OF oMainWnd Pixel 		 //"Copiar Relacionamentos"
			oPnlDlg := TPanel():New( 0, 0, , oDlgCpy, , .T., .F., , , 0, 0, .T., .F. )
				oPnlDlg:Align := CONTROL_ALIGN_ALLCLIENT

				//--- DESCRICAO ( TOPO )
				oPanel := TPanel():New( 0, 0, , oPnlDlg, , .T., .F., , , 0, 55, .T., .F. )
					oPanel:Align := CONTROL_ALIGN_TOP

					@ 8, 9.6 TO 45, 280 OF oPanel PIXEL

					TSay():New( 19, 12, { | | OemtoAnsi( STR0149 ) }, oPanel, , , .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 300, 010 ) //"Estes são os riscos e os relacionamentos que estão cadastrados."
					TSay():New( 29, 12, { | | OemtoAnsi( STR0150 ) }, oPanel, , , .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 300, 010 ) //"Selecione os relacionamentos que deverão ser copiados e os riscos que receberão a cópia."

				//--- MARCADORES
				oPnlMrk := TPanel():New( 0, 0, , oPnlDlg, , .T., .F., , , 0, 12 + ( 12 * nTotMrk ), .T., .F. )
					oPnlMrk:Align := CONTROL_ALIGN_TOP
					TSay():New( 01, 01, { | | OemtoAnsi( STR0109 ) }, oPnlMrk, , , .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 300, 010 ) //"Relacionamentos"
					nRowChk := 11
					nColChk := 01
					For nChk := 1 To Len( aChkRel )
						//Divide os checks de relacionamento em duas colunas
						If nChk % 2 == 0
							nColChk := 150
						ElseIf nChk <> 1
							nRowChk += 10
							nColChk := 01
						EndIf
						//Define o TCheckBox com o valor da posição do array do relacionamento
						TCheckBox():New( nRowChk, nColChk, aChkRel[ nChk, 2 ], &( "{|u| If(PCount()==0,aChkRel["+cValToChar( nChk )+;
										 ",4],aChkRel["+cValToChar( nChk )+",4]:=u)}" ), oPnlMrk, 100, 210, , , , , , , , .T., , , )
					Next nChk

				//--- PESQUISAR
				//Define as opcoes de Pesquisa
				aCbxPesq := {}
				aAdd( aCbxPesq, STR0066 ) //"Agente"
				aAdd( aCbxPesq, STR0151 ) //"Código"
				aAdd( aCbxPesq, STR0147 ) //"Centro Custo"
				aAdd( aCbxPesq, STR0054 ) //"Função"
				aAdd( aCbxPesq, STR0055 ) //"Tarefa"
				aAdd( aCbxPesq, STR0114 ) //"Departamento"
				cCbxPesq := aCbxPesq[ 1 ]

				oPnlPesq 		:= TPanel():New( 01, 01, , oPnlDlg, , , , CLR_BLACK, CLR_WHITE, 50, 30, .T., .T. )
					oPnlPesq:Align	:= CONTROL_ALIGN_TOP

						oCbxPesq := TComboBox():New( 002, 002, { | u | IIf( PCount() > 0, cCbxPesq := u, cCbxPesq ) },;
													 aCbxPesq, 200, 08, oPnlPesq,, { | | } ;
													 , , , , .T., , , , , , , , , "cCbxPesq" )
							oCbxPesq:bChange := { | | fSetIndex( cTRBRis, aCbxPesq, @cPesquisar, oMarkRis, .F. ) }

						oPesquisar := TGet():New( 015, 002, { | u | IIf( PCount() > 0, cPesquisar := u, cPesquisar ) }, oPnlPesq,;
												 200, 008, "", { | | .T. }, CLR_BLACK, CLR_WHITE, ,;
												.F., , .T., , .F., , .F., .F., , .F., .F., "", "cPesquisar", , , , .F. )

						oBtnPesq := TButton():New( 002, 220, STR0001, oPnlPesq, { | | fPesqTRB( cTRBRis, oMarkRis ) }, ;//"Pesquisar" //"Pesquisar"
																70, 10, , , .F., .T., .F., , .F., , , .F. )

				//Monta o markbrowse de Riscos
				oMarkRis := MsSelect():New( ( cTRBRis ), "OK", , aRisTRB, @lInverte, @cMarca, { 60, 5, 281, 292 }, , , oPnlDlg )
					oMarkRis:oBrowse:lHasMark		:= .T.
					oMarkRis:oBrowse:lCanAllMark	:= .T.
					oMarkRis:oBrowse:bAllMark		:= { | | fInverte( cMarca, cTRBRis, oMarkRis, .T. ) }//Funcao inverte marcadores
					oMarkRis:bMark	   				:= { | | fInverte( cMarca, cTRBRis, oMarkRis ) }//Funcao inverte marcadores
					oMarkRis:oBrowse:Align			:= CONTROL_ALIGN_ALLCLIENT

		Activate MsDialog oDlgCpy On Init EnchoiceBar(	oDlgCpy,;
														 { | | lConfirm := .T., IIf( fVldChk( aChkRel, cTRBRis ), oDlgCpy:End(), lConfirm := .F. ) },;
														 { | | lConfirm := .F., oDlgCpy:End() } ) CENTERED
	Else
		If Len( aChkRel ) == 0//Caso não tenham nenhum relacionamento para cópia
			MsgInfo( STR0152 ) //"Não existem relacionamentos a serem copiados."
		Else
			MsgInfo( STR0153 ) //"Não existem riscos para receber a cópia."
		EndIf
	EndIf

	If lConfirm
		//Percorre todos os relacionamentos
		For nChk := 1 To Len( aChkRel )
			If aChkRel[ nChk, 4 ]//Verifica se relacionamento foi marcado
				cTblCpy := aChkRel[ nChk, 1 ]
				cPfxCpy := PrefixoCPO( cTblCpy )

				//Percorre todos os valores do risco copiado
				If ( nIdx := NGRETORDEM( cTblCpy, PrefixoCPO( cTblCpy ) + "_FILIAL+" + PrefixoCPO( cTblCpy ) + "_NUMRIS", .F. ) ) == 0
					nIdx := 1
				EndIf
				dbSelectArea( cTblCpy )
				dbSetOrder( nIdx )
				dbSeek( xFilial( cTblCpy ) + cRisCpy )
				While ( cTblCpy )->( !EoF() ) .And. ;
					&( cTblCpy + "->" + cPfxCpy + "_FILIAL" ) == xFilial( cTblCpy ) .And. ;
					&( cTblCpy + "->" + cPfxCpy + "_NUMRIS" ) == cRisCpy

					RegToMemory( cTblCpy, .F. )//Salvo o registro em memória
					nRecno := ( cTblCpy )->( Recno() )//Salva o Recno

					//Percorre todo o TRB de Riscos
					dbSelectArea( cTRBRis )
					dbSetOrder( 2 )
					dbGoTop()
					While ( cTRBRis )->( !EoF() )
						If !Empty( ( cTRBRis )->OK )
							//Verifica se o registro já não está gravado de acordo com o campo chave
							dbSelectArea( cTblCpy )
							If cTblCpy == "TO9"
								If (( aChkRel[ nChk, 5 ] == "ST9" .And. TO9->TO9_OPCEPC == "1" ) .Or. ;
									( aChkRel[ nChk, 5 ] == "TO4" .And. TO9->TO9_OPCEPC == "2" ) )
									lVldCpy := .T.
								Else
									lVldCpy := .F.
								EndIf
								cSeekCmp := M->TO9_OPCEPC
							Else
								cSeekCmp := ""
								lVldCpy := .T.
							EndIf
							If !dbSeek( xFilial( cTblCpy ) + ( cTRBRis )->NUMRIS + cSeekCmp + &( "M->" + aChkRel[ nChk, 3 ] ) ) .And. lVldCpy
								RecLock( cTblCpy, .T. )
									//Grava todos os campos conforme memória
									For ny := 1 To fCount()
										nx := "M->" + FieldName( ny )
										If "_FILIAL" $ Upper( nx )
											&nx. := xFilial( cTblCpy )
										ElseIf "_NUMRIS" $ Upper( nx )
											&nx. := ( cTRBRis )->NUMRIS
										ElseIf "_SEQGER" $ Upper( nX )
											&nx. := Space( Len( &nx. ) )
										EndIf
										FieldPut( ny, &nx. )
									Next ny
								( cTblCpy )->( MsUnLock() )
							EndIf
						EndIf
						( cTRBRis )->( dbSkip() )
					End
					dbGoTo( nRecno )
					( cTblCpy )->( dbSkip() )
				End
			EndIf
		Next nChk
	EndIf

	oTrbRis:Delete()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fBuscaRis
Busca os riscos para serem marcados na cópia de relacionamento

@type Function

@source MDTA180.prx

@param cTRBRis, Caracter, Tabela temporária para alimentar com os riscos
@param cRisCpy, Caracter, Código do risco a ser copiado

@sample fBuscaRis( 'SGC00001' , '000000001' )

@return Nulo

@author Jackson Machado
@since 14/02/2017
/*/
//---------------------------------------------------------------------
Static Function fBuscaRis( cTRBRis, cRisCpy )

	dbSelectArea( "TN0" )
	dbSetOrder( 1 )
	dbSeek( xFilial( "TN0" ) )
	While TN0->( !Eof() ) .And. TN0->TN0_FILIAL == xFilial( "TN0" )
		//Adiciona no TRB todos os riscos que não sejam o copiado
		If cRisCpy <> TN0->TN0_NUMRIS

			RecLock( cTRBRis, .T. )
				( cTRBRis )->OK 	:= Space( 2 )
				( cTRBRis )->NUMRIS	:= TN0->TN0_NUMRIS
				( cTRBRis )->AGENTE := NGSEEK( "TMA", TN0->TN0_AGENTE, 1, "TMA_NOMAGE" )
				( cTRBRis )->CCUSTO := IIf( AllTrim( TN0->TN0_CC ) != "*", NGSEEK( "CTT", TN0->TN0_CC, 1, "CTT_DESC01" ), "TODOS" )
				( cTRBRis )->FUNCAO := IIf( AllTrim( TN0->TN0_CODFUN ) != "*", NGSEEK( "SRJ", TN0->TN0_CODFUN, 1, "RJ_DESC" ), "TODAS" )
				( cTRBRis )->TAREFA := IIf( AllTrim( TN0->TN0_CODTAR ) != "*", NGSEEK( "TN5", TN0->TN0_CODTAR, 1, "TN5_NOMTAR" ), "TODAS" )
				( cTRBRis )->DEPTO  := IIf( AllTrim( TN0->TN0_DEPTO ) != "*", NGSEEK( "SQB", TN0->TN0_DEPTO, 1, "QB_DESCRIC" ), "TODOS" )
			( cTRBRis )->( MsUnLock() )
		EndIf

		TN0->( dbSkip() )
	End

	dbSelectArea( cTRBRis )
	dbGoTop()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fVldChk
Valida se há seleções feitas

@type Function

@source MDTA180.prx

@param aChkRel, Array, Indica os relacionamentos que serão copiados
@param cTRBRis, Caracter, Código do risco a ser copiado

@sample fVldChk( { 'TBL' , 'Descrição' , 'CODIGO' , .T. } , 'SCG000001' )

@return Lógico, Indica se as marcações foram realizadas

@author Jackson Machado
@since 14/02/2017
/*/
//---------------------------------------------------------------------
Static Function fVldChk( aChkRel, cTRBRis )

	Local lMarkCopy := .F.
	Local lMarkTRB 	:= .F.

	//Caso não existam check marcados
	If !( lMarkCopy := ( aScan( aChkRel, { | x | x[ 4 ] } ) ) > 0 )
		ShowHelpDlg( STR0032,;        //"Atenção"
					 { STR0154 }, 1,; //"Nenhum relacionamento foi selecionado."
					 { STR0155 }, 1 ) //"Selecione um ou mais relacionamentos para serem copiados."
	EndIf

	If lMarkCopy
		//Percorre o TRB para avaliar se existem riscos marcados
		dbSelectArea( cTRBRis )
		dbSetOrder( 1 )
		dbGoTop()
		While ( cTRBRIS )->( !EoF() )
			If !Empty( ( cTRBRIS )->OK )
				lMarkTRB := .T.
				Exit
			EndIf
			( cTRBRIS )->( dbSkip() )
		End

		If !lMarkTRB
			ShowHelpDlg( STR0032,;        //"Atenção"
						 { STR0156 }, 1,; //"Nenhum risco foi selecionado."
						 { STR0157 }, 1 ) //"Selecione um ou mais riscos para receberem os relacionamentos."
		EndIf
		dbSelectArea( cTRBRis )
		dbSetOrder( 1 )
		dbGoTop()
	EndIf

Return ( lMarkCopy .And. lMarkTRB )

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT180AMB
Valida o conteúdo inserido nos campos TN0_CODAMB e TN0_AGENTE

@type Function

@source MDTA180.prx

@sample MDT180AMB(1)

@param nCampo, Numérico, indica qual campo está sendo validado

@return lRet, Lógico, Verdadeiro se os valors inseridos nos campos
são válidos

@author Julia Kondlatsch
@since 02/03/2018
/*/
//---------------------------------------------------------------------
Function MDT180AMB( nCampo )

	Local lRet := .T.

	If nCampo == 1
		If !ExistCPO( "TNE", M->TN0_CODAMB )
			lRet := .F.
		EndIf
	Else
		If !ExistCPO( "TMA", M->TN0_AGENTE )
			lRet := .F.
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fRisS2240
Realiza a validação e envio das informações do evento S-2240 ao Governo

@param nOpcx, Numerico, Indica a operação que está sendo realizada (3- Inclusão, 4- Alteração ou 5- Exclusão)
@param lEnvio, Boolean, Indica se é envio de informações, caso contrário trata como validação

@sample fRisS2240( 3, .F. )

@return lRet, Boolean, .T. caso não existam inconsistências no envio

@author Luis Fellipy Bett
@since	17/03/2021
/*/
//---------------------------------------------------------------------
Static Function fRisS2240( nOpcx, lEnvio )

	Local aArea	   := GetArea() //Salva a área
	Local aAreaTN0 := TN0->( GetArea() ) //Salva a área da TN0
	Local lRet	   := .T.
	Local aFuncs   := {}

	//Define por padrão como sendo envio de informações
	Default lEnvio := .T.

	aFuncs := fGetFunExp() //Busca os funcionários exposto ao risco cadastrado

	If Len( aFuncs ) > 0 //Caso existam funcionários expostos ao risco cadastrado
		lRet := MDTIntEsoc( "S-2240", nOpcx, , aFuncs, lEnvio ) //Valida as informações a serem enviadas no evento S-2240
	EndIf

	RestArea( aAreaTN0 ) //Retorna a área da TN0
	RestArea( aArea ) //Retorna a área

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTAdicSRA
Adiciona os adicionais ao registro dos funcionários

@Param	nOper, Numérico, Indica a operação que está sendo realizada (3-Inclusão/4-Alteração/5-Exclusão)

@author	Luis Fellipy Bett
@since	24/11/2020
/*/
//---------------------------------------------------------------------
Function MDTAdicSRA( nOper )

	Local aAreaTN0 := TN0->( GetArea() ) //Salva area
	Local cFilBkp  := cFilAnt

	Local lIntGPE	  := SuperGetMv( "MV_MDTGPE", .F., "N" ) == "S"
	Local lMDTAdic	  := SuperGetMv( "MV_MDTADIC", .F., .F. )
	Local nCont		  := 0
	Local cFilDif	  := ""
	Local cTarefa	  := ""
	Local cNumRisco	  := ""
	Local aRisExp	  := {}
	Local aFuncs	  := fGetFunExp() //Busca os funcionários expostos ao risco cadastrado
	Local lGPEA010	  := IsInCallStack( "GPEA010" )
	Local lGPEA010MNT := IsInCallStack( "GPEA010MNT" )
	Local lGPEA180	  := IsInCallStack( "GPEA180" )
	Local lMDTA180	  := IsInCallStack( "MDTA180" )

	//Verifica se realiza a manutenção dos adicionais
	If Len( aFuncs ) > 0 .And. lMDTAdic .And. lIntGPE .And. ( lGPEA010 .Or. lGPEA010MNT .Or. lMDTA180 .Or. lGPEA180 )

		//Percorre todos os funcionários
		For nCont := 1 To Len( aFuncs )

			//Verifica se as informações foram passados no array aFuncs
			If Len( aFuncs[ nCont ] ) > 1 .And. aFuncs[ nCont, 2 ] != Nil
				cFilDif := aFuncs[ nCont, 2 ]
			EndIf
			If Len( aFuncs[ nCont ] ) > 2 .And. aFuncs[ nCont, 3 ] != Nil
				cNumRisco := aFuncs[ nCont, 3 ]
			EndIf
			If Len( aFuncs[ nCont ] ) > 3 .And. aFuncs[ nCont, 4 ] != Nil
				cTarefa := aFuncs[ nCont, 4 ]
			EndIf

			If Empty( cFilDif )
				cFilDif := cFilAnt
			Else
				//cFilAnt recebe a nova filial para posicionar no seek
				cFilAnt := cFilDif
			EndIf

			dbSelectArea( "SRA" )
			dbSetOrder( 1 )
			If dbSeek( xFilial( "SRA", cFilDif ) + aFuncs[ nCont, 1 ] )

				//cFilAnt recebe o valor do bkp para a função fazer as buscas pela filial coreta.
				cFilAnt := cFilBkp

				If SRJ->( ColumnPos( "RJ_CUMADIC" ) ) > 0 .And. Posicione( "SRJ", 1, xFilial( "SRJ" ) + SRA->RA_CODFUNC, "RJ_CUMADIC" ) == "2"
					MDT180AGL( aFuncs[ nCont, 1 ], IIf( ( nOper == 5 .Or. nOper == 4 ) .And. lMDTA180, cNumRisco, "" ), cFilDif, nOper, M->TN0_DTELIM )
				Else
					MDT180INT( aFuncs[ nCont, 1 ], IIf( ( nOper == 5 .Or. nOper == 4 ) .And. lMDTA180, cNumRisco, "" ), .F., nOper, cFilDif, M->TN0_DTELIM ) //Preenchimento dos campos de Insalubridade e periculosidade da SRA
				EndIf

				// cFilAnt recebe o valor do bkp para a função fazer as buscas pela filial coreta.
				If cFilBkp != cFilDif
					cFilAnt := cFilDif
				Else
					cFilAnt := cFilBkp
				EndIf

				//Tratativa dos valores de insalubridade e periculosidade do funcionário
				aRisExp := MDTRisFun( aFuncs[ nCont, 1 ], SRA->RA_CC, SRA->RA_CODFUNC, cTarefa, SRA->RA_DEPTO )

				If Len( aRisExp ) == 0 .And. lGPEA010 //Se for chamada pelo GPE, zera os valores caso não tenha riscos
					dbSelectArea( "SRA" )
					RecLock( "SRA", .F. )
						SRA->RA_ADCINS  := "1"
						SRA->RA_ADCPERI := "1"
						SRA->RA_INSMAX  := 0
						SRA->RA_PERICUL := 0
					SRA->( MsUnlock() )
				EndIf

				//Zera array para validação do laço
				aRisExp := {}

			EndIf
		Next nCont
	EndIf

	//Retorna para filial correta
	cFilAnt := cFilBkp
	RestArea( aAreaTN0 )

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fGetFunExp
Busca os funcionários expostos ao risco atual sendo processado

@sample  fGetFunExp()

@return  aFuncs, Array, Array contendo os funcionários expostos ao risco atual

@author  Luis Fellipy Bett
@since   17/03/2021
/*/
//-------------------------------------------------------------------
Static Function fGetFunExp()

	Local aFuncs := {} //Array contendo os funcionários expostos ao risco cadastrado

	//Caso exista a tabela temporária
	If Select( "TMPA" ) > 0

		MDT180BFUN()

		dbSelectArea( "TMPA" )
		dbGoTop()
		While TMPA->( !Eof() )

			If aScan( aFuncs, { |x| x[1] == TMPA->TMPA_MATRI } ) == 0
				aAdd( aFuncs, { TMPA->TMPA_MATRI, TMPA->TMPA_NVFIL, M->TN0_NUMRIS } )
			EndIf

			TMPA->( dbSkip() )
		End

	EndIf

Return aFuncs

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTTrcUMed
Caso a integração com o eSocial esteja habilitada, verifica se existem
Riscos avaliados com a unidade de medida antiga. Caso tenha, monta uma
GetDados para realizar o De/Para das unidades de medida

@sample  MDTTrcUMed()

@return  Nulo

@author  Luis Fellipy Bett
@since   04/05/2020
/*/
//-------------------------------------------------------------------
Function MDTTrcUMed()

	Local aArea		:= GetArea()
	Local leSocial	:= IIf( FindFunction( "MDTVldEsoc" ), MDTVldEsoc(), .F. )
	Local cAlsUnMed	:= GetNextAlias()
	Local lConcil	:= IsInCallStack( "MDTA890" )
	Local aHeader	:= {}
	Local aCols		:= {}
	Local aColsVld	:= {}
	Local lOk		:= .F.
	Local lAlterou	:= .F.
	Local nCont		:= 0

	If leSocial

		BeginSQL Alias cAlsUnMed
			SELECT TN0.TN0_NUMRIS, TN0.TN0_AGENTE, TN0.TN0_UNIMED
				FROM %table:TN0% TN0
				WHERE TN0.TN0_FILIAL = %xFilial:TN0% AND
						TN0.TN0_DTAVAL <> "" AND
						TN0.TN0_DTELIM = "" AND
						TN0.TN0_UNIMED NOT IN ( "1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
											    "11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
												"21", "22", "23", "24", "25", "26", "27", "28", "29", "30",
												"31", "32", "33", "34", "35", "36", "37", "38", "39", "40",
												"41", "42", "43", "44", "45", "46", "47" ) AND
						TN0.TN0_UNIMED <> "" AND
						TN0.%NotDel%
		EndSQL

		dbSelectArea( cAlsUnMed )
		( cAlsUnMed )->( dbGoTop() )

		While ( cAlsUnMed )->( !Eof() )
			aAdd( aCols, { ( cAlsUnMed )->TN0_NUMRIS, ;
						   Posicione( "TMA", 1, xFilial( "TMA" ) + ( cAlsUnMed )->TN0_AGENTE, "TMA_NOMAGE" ),;
						    ( cAlsUnMed )->TN0_UNIMED,;
						    Space( TAMSX3( "V3F_CODIGO" )[1] ),;
						    .F. } )
			( cAlsUnMed )->( dbSkip() )
		End

		( cAlsUnMed )->( dbCloseArea() )

		//Caso tenha algum Risco com a unidade de medida antiga, monta a tela de De/Para
		If Len( aCols ) > 0

			aAdd( aHeader, { STR0086, "RISCO", "@!", TAMSX3( "TN0_NUMRIS" )[1], 0, "", "", "C", "", "" } ) //"Risco"
			aAdd( aHeader, { STR0066, "AGENTE", "@!", TAMSX3( "TMA_NOMAGE" )[1], 0, "", "", "C", "", "" } ) //"Agente"
			aAdd( aHeader, { STR0228, "UNMED", "@!", TAMSX3( "TN0_UNIMED" )[1], 0, "", "", "C", "", "" } ) //"Unidade Medida"
			aAdd( aHeader, { STR0229, "UMESOC", "@!", TAMSX3( "V3F_CODIGO" )[1], 0, "", "", "C", "MDTV3F", "R" } ) //"Unidade Medida eSocial"

			oDlg := MSDialog():New( 0, 0, 450, 660, STR0230, , , .F., , , , , , .T., , , .T. ) //"De/Para Unidade de Medida eSocial"

			oPanel := TPanel():New( 0, 0, , oDlg, , .T., .F., , , 0, 045, .T., .F. )
				oPanel:Align := CONTROL_ALIGN_ALLCLIENT

			@ 005, 005 TO 045, 325 OF oPanel PIXEL

			TSay():New( 012, 012, { || STR0231 }, oPanel, , , .F., .F., .F., .T., , ) //"Ao habilitar a integração com o eSocial (MV_NG2ESOC) é necessário substituir as unidades de medidas"
			TSay():New( 022, 012, { || STR0232 }, oPanel, , , .F., .F., .F., .T., , ) //"antigas pelas disponibilizadas no leiaute. Caso não deseje que a unidade seja substituída, deixe o"
			TSay():New( 032, 012, { || STR0233 }, oPanel, , , .F., .F., .F., .T., , ) //"campo em branco. A substituição pode ser feita também pelo botão Outras Ações da rotina Conciliação MDT"

			oGetDad := MsNewGetDados():New( 80, 5, 222, 327, GD_UPDATE, { || fUnMedOK() }, '', '', { "UMESOC" }, 0, 99, 'AllwaysTrue()', , '', oDlg, aHeader, aCols )

			oDlg:Activate( , , , .T., , , EnchoiceBar( oDlg, ;
													{ || lOk := .T., IIf( fUnMedOK(), oDlg:End(), lOk := .F. ) }, ;
													{ || lOk := .F., oDlg:End() } ) )

			If lOk
				aColsVld := aClone( oGetDad:aCols )
				dbSelectArea( "TN0" )
				dbSetOrder( 1 )
				For nCont := 1 To Len( aColsVld )
					If dbSeek( xFilial( "TN0" ) + aColsVld[ nCont, 1 ] ) .And. !Empty( aColsVld[ nCont, 4 ] )
						RecLock( "TN0", .F. )
							TN0->TN0_UNIMED := aColsVld[ nCont, 4 ]
						MsUnlock()
						lAlterou := .T.
					EndIf
				Next nCont
				If lAlterou
					Help( ' ', 1, STR0032, , STR0235, 2, 0 ) //"Atenção"##"Registros de unidade de medida alterados com sucesso!"
				EndIf
			EndIf

		Else
			If lConcil //Caso seja pela rotina de Conciliação do eSocial
				Help( ' ', 1, STR0032, , STR0234, 2, 0 ) //"Atenção"##"Não existem Riscos que necessitem de substituição da unidade de medida"
			EndIf
		EndIf

	EndIf

	RestArea( aArea )

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fUnMedOK

Valida a linha da GetDados da unidade de medida

@sample  fUnMedOK()

@return  lRet, Boolean, .T. se estiver tudo Ok, senão .F.

@author  Luis Fellipy Bett
@since   06/05/2020
/*/
//-------------------------------------------------------------------
Static Function fUnMedOK()

	Local lRet	  := .T.
	Local aColsOk := aClone( oGetDad:aCols )
	Local nAt	  := oGetDad:nAt

	If !Empty( aColsOk[ nAt, 4 ] )
		lRet := ExistCpo( "V3F", aColsOk[ nAt, 4 ], 2 )
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fVldDtAval
Valida se a data de avaliação está preenchida e emite a mensagem

@sample  fVldDtAval()

@return  lRet, Boolean, .T. se estiver preenchida, senão .F.

@author  Luis Fellipy Bett
@since   17/11/2021
/*/
//-------------------------------------------------------------------
Static Function fVldDtAval()

	Local leSocial := IIf( FindFunction( "MDTVldEsoc" ), MDTVldEsoc(), .F. )
	Local lRet := .T.

	//---------------------------------------------------------------------
	// Caso houver integração e a data de avaliação não estiver preenchida
	//---------------------------------------------------------------------
	If leSocial .And. Empty( M->TN0_DTAVAL )
		lRet := MsgYesNo( STR0236 ) //"O risco está sem data de avaliação prenchida e por isso não será integrado ao SIGATAF/Middleware. Deseja continuar?"
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Mdt180Cla
Retorna a classificação do risco de acordo com a severidade e
probabilidade.

@author Gabriel Sokacheski
@since 01/06/2022
 
@param lCodigo, lógico, Indica se imprime o código da classificação
@param cSeveri, caractere, Severidade do risco
@param cProbab, caractere, probabilidade do risco
 
@return cRisco, caractere, classificação do risco na matriz
/*/
//-------------------------------------------------------------------
Function Mdt180Cla( lCodigo, cSeveri, cProbab )

	Local cRisco := ''

	If !Empty( cSeveri ) .And. !Empty( cProbab )

		If lCodigo

			Do Case

				Case cProbab == '1'
					cRisco := 'A' + cSeveri + ' - '
				Case cProbab == '2'
					cRisco := 'B' + cSeveri + ' - '
				Case cProbab == '3'
					cRisco := 'C' + cSeveri + ' - '
				Case cProbab == '4'
					cRisco := 'D' + cSeveri + ' - '
				Case cProbab == '5'
					cRisco := 'E' + cSeveri + ' - '

			End Case

		EndIf

		Do Case

			Case cSeveri == '1' .And. cProbab $ '123'
				cRisco += STR0237 // "Trivial"
			Case cSeveri == '2' .And. cProbab == '1'
				cRisco += STR0237 // "Trivial"
			Case cSeveri == '1' .And. cProbab $ '45'
				cRisco += STR0238 // "Tolerável"
			Case cSeveri == '2' .And. cProbab $ '234'
				cRisco += STR0238 // "Tolerável"
			Case cSeveri == '3' .And. cProbab == '1'
				cRisco += STR0238 // "Tolerável"
			Case cSeveri == '2' .And. cProbab == '5'
				cRisco += STR0239 // "Moderado"
			Case cSeveri == '3' .And. cProbab $ '234'
				cRisco += STR0239 // "Moderado"
			Case cSeveri == '4' .And. cProbab $ '12'
				cRisco += STR0239 // "Moderado"
			Case cSeveri == '5' .And. cProbab == '1'
				cRisco += STR0239 // "Moderado"
			Case cSeveri == '3' .And. cProbab == '5'
				cRisco += STR0240 // "Substancial"
			Case cSeveri == '4' .And. cProbab $ '34'
				cRisco += STR0240 // "Substancial"
			Case cSeveri == '5' .And. cProbab == '2'
				cRisco += STR0240 // "Substancial"
			Case cSeveri == '4' .And. cProbab == '5'
				cRisco += STR0241 // "Intolerável"
			Case cSeveri == '5' .And. cProbab $ '345'
				cRisco += STR0241 // "Intolerável"

		End Case

	EndIf

Return cRisco

//-------------------------------------------------------------------
/*/{Protheus.doc} Mdt180Sx3
Função utilizada para conter o X3_VALID, X3_RELACAO e X3_INIBRW do
cadastro de riscos.

@author Gabriel Sokacheski
@since 31/05/2022
 
@param nRegra, numérico, opção do campo a ser validado/retornado
@param cCampo, caracter, campo a ser validado/retornado
 
@return xRet, indefinido, retorno de acordo com o contexto
/*/
//-------------------------------------------------------------------
Function Mdt180Sx3( nRegra, cCampo )

    Local xRet // Variável de retorno

    If nRegra == 1 //Caso for X3_VALID

		Do Case

           	Case cCampo == 'TN0_SEVERI'
                xRet := .T.
			Case cCampo == 'TN0_PROBAB'
                xRet := .T.

        End Case

    ElseIf nRegra == 2 // Caso for X3_RELACAO

		Do Case

           	Case cCampo == 'TN0_CLASSI'
                xRet := Mdt180Cla( .F., M->TN0_SEVERI, M->TN0_PROBAB )

        End Case

	ElseIf nRegra == 3 // Caso for X3_INIBRW



    EndIf

Return xRet

//--------------------------------------------------------------------------
/*/{Protheus.doc} fCamposEso
Valida alterações dos campos enviados ao eSocial.

@author Eloisa Anibaletto
@since 10/04/2024

@return lRet, Boolean, Retorna .T. caso houve alteração
/*/
//--------------------------------------------------------------------------
Static Function fCamposEso()

	Local aCampos := {;
        'TN0_QTAGEN',;
		'TN0_UNIMED',;
		'TN0_TECUTI',;
        'TN0_EPC'   ,;
        'TN0_NECEPI',;
        'TN0_CONFUN',;
        'TN0_PRZVLD',;
        'TN0_PERTRC',;
		'TN0_DTELIM',;
		'TN0_HIGIEN';
    }

	Local cMenTN0 := ''
	Local cRegTN0 := ''

	Local lRet    := .F.

	Local nCampos := 0

	For nCampos := 1 To Len( aCampos )

		cRegTN0 := "TN0->"	+ aCampos[ nCampos ]
		cMenTN0 := "M->" 	+ aCampos[ nCampos ]

		If &( cRegTN0 ) != &( cMenTN0 )
			lRet := .T.
		EndIf

	Next nCampos

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} mdta180X3W
Função utilizada no X3_WHEN dos campos da rotina

@author Elisson França
@since 27/02/2025

@return lRet, retorno da permissão para edição
/*/
//-------------------------------------------------------------------
Function mdta180X3W( cCampo )

    Local lRet := .T.

    Do Case
        Case cCampo $ 'TN0_SITSYP/TN0_MSITUA/TN0_SI2SYP/TN0_MSITU2/TN0_SITUAC'
			lRet := NGSEEK( "TMA", M->TN0_AGENTE, 1, "TMA_GRISCO" ) $ "4/8"
    End Case

Return lRet
