#INCLUDE "Mdta695.ch"
#Include "Protheus.ch"

Static lSigaMdtPS	:= SuperGetMv( "MV_MDTPS", .F., "N" ) == "S"

Static _nHeader  := 1
Static _nCols    := 2
Static _nAt      := 3
Static _DELETADO := "X"

Static _ErroLogix := "ERROR"

//------------------------------------------------------------------
/*/{Protheus.doc} MDTA695
Programa Cadastro de EPI's entregues aos funcionarios.
O programa inicia com o browser da tabela de funcionarios, ao teclar
no botao EPI, o programa mostra uma tela estilo pai filho, na parte
pai dados do funcionario epi e na parte filho, mostra os Epi's
entregues para o funcionario, o usuario podera incluir novos.

@return .T.

@author Elisangela Costa
@since 29/05/2002
/*/
//---------------------------------------------------------------------
Function MDTA695( cProgCham, xAutoCab, xAutoItens, nOpcAuto, cArqPath )

	Local aNGBEGINPRM

	Local lRet 			:= .T.
	Local lBackupAut	:= .F.

	//-------------------
	// Rotina Automática
	//-------------------
	Private l695Auto	:= ValType( xAutoCab ) != "U" .And. ValType( xAutoItens ) != "U"
	Private aAutoItens	:= {}
	Private aAutoCab	:= {}
	Private aEpiAltEso	:= {}
	Private lHist695	:= ValType( cProgCham ) == "C" .And. cProgCham == "MDTA696" //Se a rotina MDTA695 for chamada pela rotina MDTA696, não fazer integração com estoque
	Private aRotina		:= MenuDef()
	Private cCadastro	:= ""
	Private nEPIDev
	Private dDtEntEpi
	Private lCpoLegX	:= .F. //Indica se existe a coluna do Semaforo

	//--------------------------
	// Integracao com o Estoque
	//--------------------------
	Private cUsaInt1    := SuperGetMv( 'MV_NGMDTES', .F., 'N' ) //Integracao do SIGAMDT com o Estoque Informar S=Sim ou N=Nao
	Private cUsaInt2    := SuperGetMv( 'MV_NG2SA', .F., 'N' )
	Private cUsaLocz    := SuperGetMv( "MV_LOCALIZ", .F., "" ) //Indica se produtos poderao usar controle de localizacao fisica ou nao. (S)im ou (N)ao.
	Private cUsaRast    := SuperGetMv( "MV_RASTRO", .F., "" )  //Determina a utilizacao ou nao  da  Rastreabilidade dos Lotes de Producao (Informar S para  Sim  ou  N para Nao).
	Private lESTNEGA    := SuperGetMv( "MV_ESTNEG", .F., "N" ) == "S" //Identifica se o sistema permitira que os saldos em estoque dos produtos fique negativo atraves de movimentacao. Conteudo deve ser (S)im ou (N)ao.
	Private lMdtGerSA   := SuperGetMv( "MV_NG2SA", .F., "N" ) == "S"  //Indica se gera SA ao inves de requisitar do estoque
	Private lGera_SA    := cUsaInt1 == "S" .And. lMdtGerSA //Indica que será gerado Solicitação de Armazem (SA)
	Private aColsNaoDel := {} // Array para controle de envio de SA ao SIGAEST

	Private dDataBloq  := SuperGetMv( "MV_DBLQMOV" ) //Data para bloqueio de movimentos.

	//--------------------------
	//Devolução Biométrica
	//--------------------------
	Private lDEVBIO     := NGCADICBASE( "TNF_DEVBIO", "D", "TNF", .F. )
	Private aOld_TLW    := {}

	//----------------------------------------------------------
	// Variáveis utilizadas na apresentação do erro no execauto
	//----------------------------------------------------------
	Private nMsgAut := IIf( ValType( cArqPath ) == "U", 1, IIf( !Empty( cArqPath ), 2, 3 ) ) //1- Salvar em um caminho padrão; 2- Salvar em caminho passado pelo execauto; 3- Mostrar em tela
	Private cCamArq := IIf( ValType( cArqPath ) == "U", "", cArqPath )

	Default lMsErroAuto := .F.

	If NGCADICBASE( "TN3_GENERI", "A", "TN3", .F. ) .And. fVldTL0Six()
		If !NGINCOMPDIC( "UPDMDTB2", "TRNT52" )
			lRet := .F.
		EndIf
	EndIf

	If lRet .And. AMiIn( 35 ) // Somente autorizado para SIGAMDT

		If cProgCham != "MDTA696" .And. !l695Auto
			aNGBEGINPRM := NGBEGINPRM()
		EndIf

		If (cUsaInt1 != "S" .Or. cUsaLocz != "S" .And. cUsaRast != "S")

			cUsaLocz := "N"
			cUsaRast := "N"
		EndIf

		//Se a rotina MDTA695 for chamada pela rotina MDTA696, não fazer integração com estoque
		If lHist695
			cUsaInt1  := "N"
			lMdtGerSA := .F.
			lGera_SA  := .F.
		EndIf

		Pergunte( "MDT695", .F. )
		nEPIDev := MV_PAR01
		dDtEntEpi := MV_PAR02

		// Carrega variaveis da rotina automatica.
		aAutoCab   := aClone( xAutoCab )
		aAutoItens := aClone( xAutoItens )

		If lSigaMdtps

			cCadastro := OemtoAnsi( STR0071 )  //"Clientes"

			dbSelectArea( "SA1" )
			dbSetOrder( 1 )

			mBrowse( 6, 1, 22, 75, "SA1" )

		Else
			//---------------------------------------------------
			// Define o cabecalho da tela de atualizacoes
			//---------------------------------------------------

			cCadastro := OemtoAnsi( STR0004 )  //"Epis Entregues por Funcionario"

			Private lForPad := .F.
			Private cForPad := ""

			fFornecPdr( @lForPad, @cForPad )

			//---------------------------------------------------
			// Endereca a funcao de BROWSE
			//---------------------------------------------------
			dbSelectArea( "SRA" )
			dbSetOrder( 1 )
			If l695Auto //Caso a a chamada seja para Rotina Automatica

				MBrowseAuto( nOpcAuto, aClone( aAutoCab ), "SRA" )

				If lMsErroAuto .And. !lBackupAut

					lBackupAut := .T.

				EndIf

				lMsErroAuto := .F. // Define a variável de erro como falso para validar o próximo EPI

				lMsErroAuto := lBackupAut

			Else
				mBrowse( 6, 1, 22, 75, "SRA", , , , , , fCriaCor() )
			EndIf

		EndIf

		//---------------------------------------------------
		// Devolve variaveis armazenadas (NGRIGHTCLICK)
		//---------------------------------------------------
		If cProgCham != "MDTA696" .And. !l695Auto
			NGRETURNPRM( aNGBEGINPRM )
		EndIf
	EndIf

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} MDT695INDE
Função para retornar o inicializador padrão do campo TNF_INDDEV

@return Numérico

@author Luis Fellipy Bett
@since 20/06/2017
/*/
//---------------------------------------------------------------------
Function MDT695INDE()

	Local cRet		:= "2"
	Local lMdtEst	:= SuperGetMv( "MV_NGMDTES", .F., "N" ) == "S"
	Local lGeraSA	:= SuperGetMv( "MV_NG2SA", .F., "N" ) == "S"

	If lMdtEst .And. lGeraSA
		cRet := "3"
	EndIf

Return cRet

//------------------------------------------------------------------
/*/{Protheus.doc} NGFUN695
Programa de Inclusao,alteracao,exclusao

@type function

@return .T.

@param cAlias, Caracter, Alias do arquivo
@param nReg, Numérico,  Numero do registro
@param nOpcx, Numérico, Opcao selecionada no menu
@param [oParent], Objeto, Pai onde serão criados os objetos
@param [oGet], Objeto, MSGetDados passado por referencia
@param [oArqTLW], Objeto, Utilizado no MDTA410 para passar a referência do objeto da tabela temporaria

@author Elisangela Costa
@since 29/05/2002
/*/
//---------------------------------------------------------------------
Function NGFUN695( cAlias, nReg, nOpcx, oParent, oGetEPI, oArqTLW )

	Local oDlg695
	Local oPnlSup
	Local oMenu
	Local oRadOp2
	Local nX
	Local aSize			:= MsAdvSize( , .F., 430 )
	Local cMDTInteg 	:= SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lLogix		:= cMDTInteg == "2"
	Local aButtons		:= {}
	Local aButtPont		:= {}
	Local aChoiceSRA	:= { "RA_MAT", "RA_NOME", "RA_NASC", "RA_SEXO", "RA_CC", "RA_DESCCC", "RA_CODFUNC", "RA_DESCFUN", "RA_ADMISSA" }
	Local aColors		:= NGCOLOR()
	Local aFind 		:= { STR0085,; //{"Data de Entrega",
							 STR0086,; //"Hora de Entrega",
							 STR0087,; //"Código EPI",
							 STR0088,; //"Nome EPI",
							 STR0089,; //"Fornecedor + Loja",
							 STR0090 } //"Num. C. A."}
	Local aItemRadio	:= { STR0092,;  //"Data Entrega + Hora Entrega + Código EPI"
							 STR0093,;  //"Código EPI + Data Entrega + Hora Entrega"
							 STR0094,;  //"Nome EPI + Data Entrega + Hora Entrega"
							 STR0095,;  //"Fornecedor + Loja + Código EPI + Data Entrega"
							 STR0096,;  //"Código EPI +  Num. C. A."
							 STR0097 }  //"Num. C. A. + Código EPI"

	Local cValPesq    := Space( Len( DToC( dDataBase ) ) )
	Local cVerVal	  := SuperGetMv( 'MV_NG2EPDU', .F., '0' )
	Local nOrdem      := 1
	Local nTamFor     := IIf( ( TAMSX3( "A2_COD" )[ 1 ] ) < 1, 6, ( TAMSX3( "A2_COD" )[ 1 ] ) )
	Local nTamLoj     := IIf( ( TAMSX3( "A2_LOJA" )[ 1 ] ) < 1, 6, ( TAMSX3( "A2_LOJA" )[ 1 ] ) )
	Local lRetEPI     := .T.
	Local lParent     := ValType( oParent ) == "O"
	Local lCallMDT410 := IsInCallStack( "MDTA410" )
	Local bGrava695   := { || fImpEPIDev( oGetTNF695 ), fCleanVar( oArquivTLW ), IIf( !lParent, oDlg695:End(), ) }
	Local oArquivTLW
	Local oPesq
	Local cPesq       := aFind[1]
	Local nPosEPI
	Local nPosDtEn
	Local nPosHrEn

	// Variável definida para utilização da rotina automatica
	Private l695Auto	:= Type( "aAutoCab" ) == "A" .And. Type( "aAutoItens" ) == "A" .And. IsInCallStack( "MDTA695" )
	Private lContinua	:= !l695Auto
	Private lAtuGet		:= .F.
	Private lWhenEpi	:= .F.
	Private lExecLogix	:= .F. //Função utilizada para não executar o bChange ao iniciar o MsNewGetDados
	Private cIndRelac	:= " "
	Private cMARCA		:= GetMark()
	Private aColsTNF	:= {}
	Private aColsTLW 	:= {}
	Private aBkpTLW		:= {}
	Private aColsFilt	:= {}

	Private lWh695TNF := .T. //Variavel que controla o X3_WHEN dos campos da TNF
	Private lWh695IND := .T. //Variavel que controla o X3_WHEN do campo TNF_INDDEV
	Private lWh695LOT := .T. //Variavel que controla o X3_WHEN do campo Lote SubLote
	Private lWh695OBS := .T. //Variavel que controla o X3_WHEN do campo Observação
	Private nPosChv	  := 0
	Private nPosAnt	  := 0

	//Controle da rotina automatica
	Private aColsAut		:= {}
	Private aHeaderAut		:= {}
	Private l695ExibeMsg	:= .T. //Controla a verificação da apresentação da Mensagem do Controle de Estoque (MDTMOVEST - MDTUTIL)

	// Este ponto de entrada deverá retornar uma variavél do tipo array
	// contendo configurações de botões.Na rotina Funcionários x EPI, ao
	// selecionar o funcionário e clicar no botão Epis, o ponto de entrada
	// será executado e serão adicionados na parte superior da tela os botões
	// configurados no ponto de entrada.
	If ExistBlock( "MDTA6951" )
		aButtPont := ExecBlock( "MDTA6951", .F., .F. )
	EndIf

	//-----------------------------------------------------------
	//1-Entrega EPI Vencido / 2-Não entrega EPI Vencido / 3-Pergunta se entrega EPI Vencido
	//-----------------------------------------------------------
	Private nOpcVenc := SuperGetMV( "MV_MDTEPIV", .F., 3 )

	//-----------------------------------------------------------
	// Verifica qual tipo de produto eh o tipo EPI
	// e atualiza a consulta padrao de EPI's de acordo com isso
	//-----------------------------------------------------------
	Private cTipo := SuperGetMv( "MV_MDTPEPI", .F., "" )
	Private lSX5  := !Empty( cTipo )  //Variaveis utilizadas na validacao do campo TNX_EPI

	//Define variaveis privadas caso não seja pela Nova Ficha Médica
	If !lCallMDT410
		Private aHeader		:= {}
		Private aCols		:= {}
		Private aHeadTLW	:= {} //Cabeçalho da TLW
		Private aChvTNF		:= {}
		Private aDevEpi 	:= {}
		Private aDevPar     := {}

	Else
		aHeader  := {}
		aCols    := {}
		aHeadTLW := {} //Cabeçalho da TLW
	EndIf

	If !lHist695

		If l695Auto

			// Cria a TRB
			cAliasTLW := GetNextAlias()
			MDT695TLW( @oArquivTLW )
			oArqTLW := oArquivTLW

			MDT695TRB( SRA->RA_MAT ) // Carrega valores da TLW

		EndIf

		SetKey( VK_F4, { || MDT695Loc( oGetTNF695 ) } )

	EndIf

	If ValType( aButtPont ) == "A"
		aButtons := aClone( aButtPont )
	EndIf

	aAdd( aButtons, { "NG_ICO_LEGENDA", { || LegMdtTNF() }, STR0016, STR0016 } ) //"Legenda"

	If !l695Auto // A validação é realizada posteriormente no caso de execauto
		lRetEPI := !fChkFunc()
	EndIf

	If lRetEPI

		nOpcao := nOpcx
		//------------------------------------------
		// Verifica se existe algum dado no arquivo
		//------------------------------------------
		dbSelectArea( cAlias )
		dbSetOrder( 1 )

		RegToMemory( cAlias, .F. )

		cAlias := "TNF"

		If lSigaMdtps
			nIndTNF := 8  //TNF_FILIAL+TNF_CLIENT+TNF_LOJACL+TNF_MAT+TNF_CODEPI+DTOS(TNF_DTENTR)+TNF_HRENTR
			cSeekTNF := xFilial( "TNF" ) + cCliMdtps + SRA->RA_MAT
			cCondTNF := "TNF->TNF_FILIAL+TNF->TNF_CLIENT+TNF->TNF_LOJACL+TNF->TNF_MAT"

			nInd2TNF:= NGRETORDEM( "TNF", "TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CLIENT+TNF_LOJACL+TNF_CODEPI+TNF_NUMCAP+TNF_MAT+DTOS(TNF_DTENTR)+TNF_HRENTR", .F. )
			nIndTNF	:= IIf( nIndTNF > 0, nIndTNF, 11 )  //TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CLIENT+TNF_LOJACL+TNF_CODEPI+TNF_NUMCAP+TNF_MAT+DTOS(TNF_DTENTR)+TNF_HRENTR

		Else
			nIndTNF := 3  //TNF_FILIAL+TNF_MAT+TNF_CODEPI+DTOS(TNF_DTENTR)+TNF_HRENTR
			cSeekTNF := xFilial( "TNF" ) + SRA->RA_MAT
			cCondTNF := "TNF->TNF_FILIAL+TNF->TNF_MAT"

			nInd2TNF := 1  //TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CODEPI+TNF_NUMCAP+TNF_MAT+DTOS(TNF_DTENTR)+TNF_HRENTR
		EndIf

		//-------------------
		// Monta o cabecalho
		//-------------------
		fMontaCabec()

		If lContinua //Validação da GetDados através da rotina automática, caso não seja rotina automática o default é .T.

			lCpoLegX := TNFColBmp( 1, @aHeader, @aCols ) //Adiciona a coluna BMP no aHeader e aCols
			If l695Auto
				lCpoLegX := TNFColBmp( 1, @aHeaderAut, @aColsAut ) //Adiciona a coluna BMP no aHeader e aCols
			EndIf

			nPosDtEn := GdFieldPos( "TNF_DTENTR" )
			nPosHrEn := GdFieldPos( "TNF_HRENTR" )
			nPosEPI := GdFieldPos( "TNF_CODEPI" )

			If Empty( aCols )
				aCols := BlankGetd( aHeader )
			ElseIf cVerVal $ "1/2/3" //1=Somente Epi c/ devolucao, 2=Somente Epi s/ devolucao, 3=Todos.
				Mdta695Ven( aCols, cVerVal )
				aSort( aCols, , , { |x, y| DToS( x[ nPosDtEn ] ) + x[ nPosHrEn ] + x[ nPosEPI ] < ;
				DToS( y[ nPosDtEn ] ) + y[ nPosHrEn ] + y[ nPosEPI ] } )    //Data Entrega + Hora Entrega + Código EPI
			EndIf

			//Este ponto de entrada está disponível na rotina Funcionários x EPI e
			// será executado ao selecionar algum funcionário e clicar no botão Epis.
			If ExistBlock( "MDTA6952" )
				ExecBlock( "MDTA6952", .F., .F. )
			EndIf

			//----------------------------------------------------
			// DEVOLUÇÂO PARCIAL
			//----------------------------------------------------
			// Carrega TRB da TLW, verifica se existe a tabela com
			// o nome de cAliasTLW e se há o arquivo criado em
			// oArquivTLW
			// Se existe será apagado os registros contidos e
			// recarregados
			// Verificação feita pela multiplas chamadas no MDTA410,
			// de diferentes funcionários.
			//----------------------------------------------------
			If Type( "cAliasTLW" ) != "U"
				dbSelectArea( cAliasTLW )
				ZAP
			Else
				//Cria a TRB
				cAliasTLW := GetNextAlias()
				MDT695TLW( @oArquivTLW )
				oArqTLW := oArquivTLW//Salva para uso no MDTA410
			EndIf
			//Carrega valores da TLW
			MDT695TRB( SRA->RA_MAT )

			//--------------------------------
			//Caso seja rotina automática atribui os backup's feitos antes da interferência da função MSGETDAUTO
			//e define a variavel de controle 'nOpca' == 1 como se tivesse sido confirmada a tela
			//--------------------------------
			If l695Auto
				aColsTNF := aClone( aColsAut )
				aHeaTNF	 := aClone( aHeaderAut )
				nOpca	 := 1
			Else
				aColsTNF := aClone( aColsFilt )
				aHeaTNF  := aClone( aHEADER )
				nOpca	 := 0
			EndIf

			Inclui := .T.
			lPrimeiro := .F.

			If !l695Auto // se for rotina automatica não monta tela.
				If lParent
					oDlg695 := oParent
				Else
					oDlg695 := MSDialog():New( 0, 0, aSize[6], aSize[5], cCadastro,,,,;
							   nOr(WS_VISIBLE,WS_POPUP), CLR_BLACK, CLR_WHITE,, GetWndDefault(), .T. )
				EndIf

				//Painel geral (unico diretamente alocado na dialog)
				oPnlAll := TPanel():New( 02, 02,, oDlg695,,,,,, 0, 0, .F., .F. )
					oPnlAll:Align := CONTROL_ALIGN_ALLCLIENT

				//Splitter que divide a tela ao meio na horizontal, separando a enchoice e filtros da grid e botões
				oSplitter := tSplitter():New( 0, 0, oPnlAll, 0, 0, 1 )
					oSplitter:Align := CONTROL_ALIGN_ALLCLIENT

				//Painel agrupador da parte superior da tela
				oPnlSup := TPanel():New( 0, 0,, oSplitter,,,,,, 0, 150, .F., .F. )
					oPnlSup:Align := CONTROL_ALIGN_TOP
				
				//Painel pesquisa
				oPnlSearch := TPanel():New( 0, 0, OemToAnsi(STR0099), oPnlSup,,,,,, 120, 0, .T., .T. )
					oPnlSearch:Align := CONTROL_ALIGN_RIGHT
				
				//Painel filtro
				oPnlFilter := TPanel():New( 0, 0, OemToAnsi(STR0091), oPnlSup,,,,,, 140, 0, .T., .T. )
					oPnlFilter:Align := CONTROL_ALIGN_RIGHT

				oBtnSearch := TButton():New( 002, 002, ">", oPnlFilter, , 5, 10, , , .F., .T., .F., , .F., , , .F. )
					oBtnSearch:bAction := {|x, y| (oBtnSearch:cTitle := IIf( oBtnSearch:cTitle == ">", "<", ">" ),;
						IIf( oBtnSearch:cTitle == ">", oPnlSearch:Show(), oPnlSearch:Hide() ) ), oEnchoice:SetFocus() }
					oBtnSearch:Align := CONTROL_ALIGN_RIGHT

				//Painel enchoice
				oPnlField := TPanel():New( 0, 0,, oPnlSup,,,,,, 0, 0, .F., .F. )
					oPnlField:Align := CONTROL_ALIGN_ALLCLIENT

				oBtnFilter := TButton():New( 002, 002, ">", oPnlField, , 5, 10, , , .F., .T., .F., , .F., , , .F. )
					oBtnFilter:bAction := {|x, y| (oBtnFilter:cTitle := IIf( oBtnFilter:cTitle == ">", "<", ">" ),;
						IIf( oBtnFilter:cTitle == ">", oPnlFilter:Show(), oPnlFilter:Hide() ) ), oEnchoice:SetFocus() }
					oBtnFilter:Align := CONTROL_ALIGN_RIGHT
				
				//Painel agrupador da parte inferior da tela
				oPnlBot := TPanel():New( 0, 0,, oSplitter,,,,,, 0, 0, .F., .F. )
					oPnlBot:Align := CONTROL_ALIGN_ALLCLIENT

				//Painel de botões (direita)
				oPnlButton := TPanel():New( 0, 0,, oPnlBot,,,,, NGCOLOR()[2], 12, 12, .F., .F. )
					oPnlButton:Align := CONTROL_ALIGN_RIGHT
				
				//Painel da grid
				oPnlGrid := TPanel():New( 0, 0,, oPnlBot,,,,,, 12, 12, .F., .F. )
					oPnlGrid:Align :=  CONTROL_ALIGN_ALLCLIENT

				//Enchoice - Funcionario
				oEnchoice := MsMGet():New( "SRA", SRA->( Recno() ), 2,,,, aChoiceSRA,;
					{ 12, 0, 0/*oPnlSup:nHeight/4*/, 0/*oPnlSup:nWidth*/ },,,,,, oPnlField,,,,, .T. )
					oEnchoice:oBox:Align := CONTROL_ALIGN_ALLCLIENT

				//Ordem dos EPI`s Entregues
				oRadMenu := TRadMenu():New( 15, 5, aItemRadio,, oPnlFilter,, { || fAlterCus( oGetTNF695, nOrdem ) },,,,,, 200, 12,,,, .T. )
					oRadMenu:bSetGet := { |u| IIf( PCount() == 0, nOrdem, nOrdem := u ) }
				oBtnOrder := TButton():New( 077, 5, STR0098, oPnlFilter, { || fAlterCus( oGetTNF695, nOrdem ) }, 60, 12,,,, .T. )//"Reodernar"

				//Pesquisa de EPI`s Entregues
				TSay():New( 16, 5, { || STR0100 }, oPnlSearch, , , , , , .T. ) //"Objeto de Pesquisa:"
				TComboBox():New( 15, 57, { |u| IIf( Pcount() > 0, cPesq := u, cPesq ) }, aFind,;
					60, 3, oPnlSearch,,, { |u| MDT695PES( @cValPesq, u, @oPesq ) },,, .T. )

				TSay():New( 30, 5, { || STR0101 }, oPnlSearch, , , , , , .T. ) //"Valor a procurar:"
				oPesq := TGet():New( 29, 57, { |u| IIf( PCount() > 0, cValPesq := u, cValPesq ) },;
					oPnlSearch, 60, 6, "@!",,,,,,, .T.,,, { || .T. },,,,,,,,,,, .T. )

				TButton():New( 50, 5, STR0102, oPnlSearch, { || MDTPes695( 1, oGetTNF695, cPesq, cValPesq ) }, 50, 12,,,, .T. ) //"Localizar Anterior"
				TButton():New( 50, 60, STR0103, oPnlSearch, { || MDTPes695( 2, oGetTNF695, cPesq, cValPesq ) }, 50, 12,,,, .T. ) //"Localizar Próxim&o"

				TSay():New( 80, 5, { || OemToAnsi(STR0128) }, oPnlSearch,,,,,, .T. ) //"Fornecedor"
				TSay():New( 96, 5, { || STR0129 }, oPnlSearch,,,,,, .T. ) //"Fornecedor"
				TGet():New( 95, 40, { || SubStr( cForPad, 1, nTamFor ) }, oPnlSearch,;
					60, 6, "@!",,,,,,, .T.,,, {|| .F. },,,,,,,,,,, .T. )

				TSay():New( 110, 5, { || STR0130 }, oPnlSearch,,,,,, .T. ) //"Loja"
				TGet():New( 109, 40, { || SubStr( cForPad, nTamFor + 1, ( nTamFor + nTamLoj ) ) }, oPnlSearch,;
					24, 6, "@!",,,,,,, .T.,,, {|| .F. },,,,,,,,,,, .T. )

				//Getdados de EPI`s
				oGetTNF695 := MsNewGetDados():New( 0, 0, 135, 315, IIf( nOpcx != 3 .And. nOpcx != 4, 0,;
					GD_INSERT + GD_UPDATE + GD_DELETE ),, "AllwaysTrue()",,,, 999999,,,, oPnlGrid, @aHeader, @aCols )
					oGetTNF695:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
					oGetTNF695:bDelOk	:= { || NG695EXCC( oGetTNF695 ) }
					oGetTNF695:bLinhaOk	:= { || NG695LinOk( oGetTNF695 ) }
					oGetTNF695:bTudoOk	:= { || NG695TudOk() }
					oGetTNF695:bChange	:= { || fChg695GD( oGetTNF695 ), lExecLogix := .T. }
				
				oBtnNec := TBtnBmp():NewBar( "ng_ico_EPI_necessario", "ng_ico_EPI_necessario",,,,;
					{ || MDT695EPIN( @oGetTNF695 ) },, oPnlButton,,, STR0197,,,,, "" ) //"Epi's Necessários"
					oBtnNec:bWhen := {|| IIf( lCallMDT410, oGetTNF695:lActive, .T. ) }
					oBtnNec:Align := CONTROL_ALIGN_TOP

				If !lLogix
					oBtnDev := TBtnBmp():NewBar( "ng_ico_devolucao_parcial", "ng_ico_devolucao_parcial",,,,;
						{ || MDT695DVPA( nOpcx, @oGetTNF695 ) },, oPnlButton,,, STR0134,,,,, "" ) //"Devolução Parcial"
						oBtnDev:bWhen := { || IIf( lCallMDT410, oGetTNF695:lActive, .T. ) }
						oBtnDev:Align := CONTROL_ALIGN_TOP
				EndIf
	
				dbSelectArea( "TNF" )
				//----------------------------------------------------
				// Altera When de TNF através da aplicação no MDTA695
				//----------------------------------------------------
				fChgWhTNF( oGetTNF695, "fChg695GD()", Type( "lHist695" ) == "L" .And. lHist695 )

				If !lParent
					ACTIVATE MSDIALOG oDlg695 ON INIT EnchoiceBar( oDlg695,;
					 { || nOpca := 1, IIf( oGetTNF695:TudoOk() .And. GravaEpi( nOpca, nOpcx ), Eval( bGrava695 ), nOpca := 0 ) },;
					 { ||fCleanVar( oArquivTLW ) , oDlg695:End() , nOpca := 0 }, , aButtons )
				Else
					oGetEPI := oGetTNF695
					Return { || IIf( GravaEpi( 1, nOpcx ), Eval( bGrava695 ), Nil ) }
				EndIf
			Else
				Eval( { || GravaEpi( nOpca, nOpcx ), fCleanVar( oArquivTLW ) } )
			EndIf
		EndIf
	EndIf

	//Zera o botão F4
	If !lHist695
		SetKey( VK_F4, Nil )
	EndIf

Return lRetEPI

//------------------------------------------------------------------
/*/{Protheus.doc} GravaEpi
Grava informacoes finais

@return .T.

@param nOpca - Indica se foi confirmado a tela, 1 - Sim; 2 - Não.
@param nOpcx - Indica a opção da operação. (3=Inclui;4=Altera;5=Exclui;etc.)

@author Vitor Emanuel Batista
@since 19/04/2011
/*/
//---------------------------------------------------------------------
Static Function GravaEpi( nOpca, nOpcx )

	Local aArea410  := SRA->(GetArea())
	Local lRet      := .T.
	Local aColsAlt	:= {}
	Local aGridAux  := fStructEPI()
	Local aColsAux  := aGridAux[ _nCols ]

	If FindFunction( "MDTA410" )
		aDevEpi := {}
	EndIf

	If nOpca == 1

		RegToMemory( "SRA", .F. )

		If IsInCallStack( "MDTA410" )
			If !oGetTNF695:TudoOK()
				If Type( "lAtuTel" ) == "L"
					lAtuTel := .F.
				EndIf
				Return .F.
			EndIf
		EndIf

		Begin Transaction

			aColsAlt := MDT695LinAl( aColsAux, aCols, aHeader ) //Verifica as linhas alteradas
			lRet := NG695GRAV( nOpca, , aColsAlt ) .And. !lMsErroAuto

			SetKey( VK_F4, { || MDT695Loc( oGetTNF695 ) } )

			If lRet
				//Processa Gatilhos
				EvalTrigger()
			EndIf

		End Transaction
	EndIf

	RestArea( aArea410 )

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} NG695GRAV
Grava os dados no TNF

@return .T.

@param nOpcao - Indica a opção da operação. (3=Inclui;4=Altera;5=Exclui;etc.)

@author Elisangela Costa
@since 29/05/2002

/*/
//---------------------------------------------------------------------
Function NG695GRAV( nOpcao, cTRBTN3, aColsAlt )

	Local nx
	Local nY
	Local i
	Local nInd
	Local nXYZ
	Local nXXXX

	Local aMemosTNF 	:= GetMemoTNF()
	Local aArea     	:= GetArea()
	Local aAreaSRA  	:= SRA->( GetArea() )
	Local aNumSA    	:= {}
	Local aGridAux  	:= {}
	Local aColsAux  	:= {}
	Local aFuncs		:= {}
	Local aSitEPI   	:= {}
	Local aAreaTNF

	Local bPosMdt630 	:= { | x | TNF->TNF_MAT == x[ nPosMatr ] .And. ;
							TNF->TNF_DTENTR == x[ nPosDtEn ] .And. ;
							TNF->TNF_HRENTR == x[ nPosHrEn ] }
	Local bPosMdt695 	:= { | x | TNF->TNF_FORNEC == x[ nPosForn ] .And. ;
							TNF->TNF_LOJA == x[ nPosLoja ] .And. ;
							TNF->TNF_CODEPI == x[ nPosEPI ] .And. ;
							TNF->TNF_NUMCAP == x[ nPosNumC ] .And. ;
							TNF->TNF_DTENTR == x[ nPosDtEn ] .And. ;
							TNF->TNF_HRENTR == x[nPosHrEn] }

	Local cTimeGrav   	:= SubStr( Time(), 1, 5 )
	Local cTNFNumSeq  	:= ""
	Local cD3Custo	  	:= ""
	Local cObsSCP	  	:= ""
	Local cNumSeq     	:= ""
	Local cCond2TNF
	Local cChvDelTLW
	Local cMDTInteg 	:= SuperGetMv( "MV_NG2INTE", .F., "1" )

	Local dDataTmp 		:= CToD('  /  /  ')

	Local nAt
	Local nInd2
	Local nQtdDev		:= 0
	Local nPosTNF 		:= 0
	Local nPosDevBio
	Local nPosDtDev
	Local nPosHrDev
	Local nPosQtDev
	Local nPosTpDev
	Local nPosLocDev
	Local nPosTNFAux 	:= 0
	Local nPosEpiEso 	:= 0
	Local nDevoQtdade 	:= 0 // Quantidade Devolvida

	Local lLogix	  	:= cMDTInteg == "2"
	Local lIncTNF     	:= .F.
	Local lRecLockTLW 	:= .F.
	Local lTmpTLW     	:= Type( "cAliasTLW" ) != "U" .And. Select( cAliasTLW ) > 0 .And. !lLogix
	Local lProcTLW    	:= .F.
	Local lObser      	:= TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
	Local lObserva    	:= .F. // Alteração da Observação - Logix
	Local lCallMDT630 	:= IsInCallStack( "MDTA630" )
	Local lRet		  	:= .T.
	Local lDelPar     	:= .T.
	Local lDevPar		:= .F.
	Local lDevTot		:= .F.
	Local lExistMAT   	:= Type( "M->RA_MAT" ) == "C"
	Local lExistCOD   	:= Type( "M->RA_CODFUNC" ) == "C"
	Local lAltCols

	Private aEpiSA		:= {}

	Private cTNFNumSA	:= ""
	Private cTNFItemSA	:= ""

	Private lDEVBIO	 := NGCADICBASE( "TNF_DEVBIO", "D", "TNF", .F. )

	Private nItemSA		:= 0
	Private nContReg	:= 0 // Controle de Geração de SA

	Default cTRBTN3   := ""

	Default aColsAlt  := {}

	dbSelectArea( "TNF" )

	// Verifica se o ultimo elemento do array esta em branco
	aGridAux  := fStructEPI()
	aColsAux  := aGridAux[ _nCols ]
	nAt		  := aGridAux[ _nAt ]
	nMaxArray := Len( aColsAux )

	nPosEPI    := GdFieldPos( "TNF_CODEPI", aGridAux[ _nHeader ] )
	nPosForn   := GdFieldPos( "TNF_FORNEC", aGridAux[ _nHeader ] )
	nPosLoja   := GdFieldPos( "TNF_LOJA", aGridAux[ _nHeader ] )
	nPosNumC   := GdFieldPos( "TNF_NUMCAP", aGridAux[ _nHeader ] )
	nPosLot    := GdFieldPos( "TNF_LOTECT", aGridAux[ _nHeader ] )
	nPosSubL   := GdFieldPos( "TNF_LOTESB", aGridAux[ _nHeader ] )
	nPosDtEn   := GdFieldPos( "TNF_DTENTR", aGridAux[ _nHeader ] )
	nPosHrEn   := GdFieldPos( "TNF_HRENTR", aGridAux[ _nHeader ] )
	nPosQtde   := GdFieldPos( "TNF_QTDENT", aGridAux[ _nHeader ] )
	nPosInDe   := GdFieldPos( "TNF_INDDEV", aGridAux[ _nHeader ] )
	nPosDtDe   := GdFieldPos( "TNF_DTDEVO", aGridAux[ _nHeader ] )
	nPosQTDDv  := GdFieldPos( "TNF_QTDEVO", aGridAux[ _nHeader ] )
	nPosEnd    := GdFieldPos( "TNF_ENDLOC", aGridAux[ _nHeader ] )
	nPosNSer   := GdFieldPos( "TNF_NSERIE", aGridAux[ _nHeader ] )
	nPosLocal  := GdFieldPos( "TNF_LOCAL", aGridAux[ _nHeader ] )
	nPosNSA    := GdFieldPos( "TNF_NUMSA", aGridAux[ _nHeader ] )
	nPosISA    := GdFieldPos( "TNF_ITEMSA", aGridAux[ _nHeader ] )
	nPosTipoDv := GdFieldPos( "TNF_TIPODV", aGridAux[ _nHeader ] )
	nPosLcDv   := GdFieldPos( "TNF_LOCDV", aGridAux[ _nHeader ] )
	nPosNSeq   := GdFieldPos( "TNF_NUMSEQ", aGridAux[ _nHeader ] )
	nPosMatr   := GdFieldPos( "TNF_MAT", aGridAux[ _nHeader ] )
	nPosSaiLog := GdFieldPos( "TNF_SAILOG", aGridAux[ _nHeader ] )
	nPosEntLog := GdFieldPos( "TNF_ENTLOG", aGridAux[ _nHeader ] )
	nPosObs    := GdFieldPos( "TNF_OBSLOG", aGridAux[ _nHeader ] )
	nPosLeg    := GdFieldPos( "COLBMP", aGridAux[ _nHeader ] )

	If lCallMDT630
		nPosNumSA	:= GdFieldPos( "TNF_NUMSA", aGridAux[ _nHeader ] )
		nPosItemSA	:= GdFieldPos( "TNF_ITEMSA", aGridAux[ _nHeader ] )
	EndIf
	nPosDtDev	:= GdFieldPos( "TLW_DTDEVO", aHeadTLW )
	nPosHrDev	:= GdFieldPos( "TLW_HRDEVO", aHeadTLW )
	nPosQtDev	:= GdFieldPos( "TLW_QTDEVO", aHeadTLW )
	nPosLocDev	:= GdFieldPos( "TLW_LOCAL", aHeadTLW )
	nPosTpDev	:= GdFieldPos( "TLW_TIPODV", aHeadTLW )

	cCliMDTPs := ""

	If lCallMDT630
		If lSigaMdtPs
			cCliMDTPs := SA1->A1_COD+SA1->A1_LOJA
			nIndTNF   := NGRETORDEM( "TNF", "TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CLIENT+TNF_LOJACL+TNF_CODEPI+TNF_NUMCAP+TNF_MAT+DTOS(TNF_DTENTR)+TNF_HRENTR", .F. )
			nIndTNF   := IIf( nIndTNF > 0, nIndTNF, 11 )  //TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CLIENT+TNF_LOJACL+TNF_CODEPI+TNF_NUMCAP+TNF_MAT+DTOS(TNF_DTENTR)+TNF_HRENTR
			nInd2TNF  := NGRETORDEM( "TNF", "TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CLIENT+TNF_LOJACL+TNF_CODEPI+TNF_NUMCAP+TNF_MAT+DTOS(TNF_DTENTR)+TNF_HRENTR", .F. )
			cSeekTNF  := xFilial( "TNF" ) + ( cTRBTN3 )->FORNEC + ( cTRBTN3 )->LOJA + cCliMDTPs + ( cTRBTN3 )->CODEPI + ( cTRBTN3 )->NUMCAP
			cCondTNF  := "TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CLIENT+TNF_LOJACL+TNF_CODEPI+TNF_NUMCAP"
		Else
			nIndTNF  := 1  //TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CODEPI+TNF_NUMCAP+TNF_MAT+DTOS(TNF_DTENTR)+TNF_HRENTR
			nInd2TNF := 1  //TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CODEPI+TNF_NUMCAP+TNF_MAT+DTOS(TNF_DTENTR)+TNF_HRENTR
			cSeekTNF := xFilial( "TNF" ) + ( cTRBTN3 )->FORNEC + ( cTRBTN3 )->LOJA + ( cTRBTN3 )->CODEPI + ( cTRBTN3 )->NUMCAP
			cCondTNF := "TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CODEPI+TNF_NUMCAP"
		EndIf
	EndIf

	//Deleta registros que foram alterados
	dbSelectArea( "TNF" )
	dbSetOrder( nIndTNF ) // 3 ou 8 para Prestador
	dbSeek( cSeekTNF )

	While TNF->( !Eof() ) .And. cSeekTNF == &(cCondTNF)

		//Caso o registro não tenha sido incluido/alterado pula
		If !( aScan( aColsAlt, { |x| x[1] == TNF->TNF_MAT + TNF->TNF_CODEPI + DToS( TNF->TNF_DTENTR ) + TNF->TNF_HRENTR } ) > 0 )
			TNF->( dbSkip() )
			Loop
		EndIf

		If lCallMDT630
			cCond2TNF := TNF->TNF_MAT + DToS( TNF->TNF_DTENTR ) + Substr( TNF->TNF_HRENTR, 1, 5 )
			nPosAux   := aScan( aColsAux, { | x | x[ nPosMatr ] + DToS( x[ nPosDtEn ] ) + Substr( x[ nPosHrEn ], 1, 5 ) == cCond2TNF } )
		Else
			cCond2TNF:= TNF->TNF_FORNEC + TNF->TNF_LOJA + TNF->TNF_CODEPI + DToS( TNF->TNF_DTENTR ) + Substr( TNF->TNF_HRENTR, 1, 5 ) + TNF->TNF_NUMCAP
			nPosAux := aScan( aColsAux, { | x | x[ nPosForn ] + x[ nPosLoja ] + x[ nPosEPI ] +;
			DToS( x[ nPosDtEn ] ) + Substr( x[ nPosHrEn ], 1, 5 ) + x[ nPosNumC ] == cCond2TNF } )
		EndIf

		If nPosAux == 0
			//Nao permitir que dados sejam perdidos
			If !(( TNF->TNF_INDDEV == "2" .And. nEPIDev == 2 ) .Or. ; //Situacao do Epi -> 2=Epi em uso; & Mostrar EPI? -> 2 = "Devolvidos"
					( TNF->TNF_INDDEV == "1" .And. nEPIDev == 3 ) .Or. ; //Situacao do Epi -> 1=Epi devolvido; & Mostrar EPI? -> 3 = "Não Devolvidos"
					( TNF->TNF_INDDEV == "3" .And. nEPIDev == 2 ) .Or. ; //Situacao do Epi -> 3=Epi em Solic. Armazem. & Mostrar EPI? -> 2 = "Devolvidos"
					( Empty( TNF->TNF_INDDEV ) .And. nEPIDev == 2 ) ) //Situacao do Epi -> Vazio & Mostrar EPI? -> 2 = "Devolvidos"

				//--------------------------------
				// Atualiza relacionamento da TNF
				//--------------------------------
				lRet := fAtuRelTNF()

				If !lRet
					Return .F.
				EndIf

				If lLogix
					nPosAux := aScan( aColsTNF, { | x | x[ nPosForn ] + x[ nPosLoja ] + x[ nPosEPI ] +;
							DToS( x[ nPosDtEn ] ) + Substr( x[ nPosHrEn ], 1, 5 ) + x[ nPosNumC ] == cCond2TNF } )
					If nPosAux > 0 .And. Len( aColsAux ) >= nPosAux
						If nPosSaiLog > 0
							aColsAux[ nPosAux, nPosSaiLog ] := aColsTNF[ nPosAux, nPosSaiLog ]
						EndIf

						If nPosEntLog > 0
							aColsAux[ nPosAux, nPosEntLog ] := aColsTNF[ nPosAux, nPosEntLog ]
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		dbSelectArea( "TNF" )
		Dbskip()
	End

	nColuna := Len( aColsAux[1] )
	aSort( aColsAux, , , { |x, y| (x[nColuna] .And. !y[nColuna]) .Or. (x[ nPosInDe ] == "1" .And. y[ nPosInDe ] != "1" .And. !x[nColuna] .And. !y[nColuna]) } )

	For nx := 1 To nMaxArray

		If aTail( aColsAux[nx] )  //Se o registro de EPI entregue foi deletado

			If lCallMDT630
				cTNFSeek := ( cTRBTN3 )->FORNEC+( cTRBTN3 )->LOJA+cCliMDTPs+( cTRBTN3 )->CODEPI+( cTRBTN3 )->NUMCAP + aColsAux[ nx, nPosMatr ]
			Else
				cTNFSeek := aColsAux[ nx, nPosForn ]+aColsAux[ nx, nPosLoja ]+cCliMDTPs+aColsAux[ nx, nPosEPI ]+aColsAux[ nx, nPosNumC ] + M->RA_MAT
			EndIf

			cSeekTmp := xFilial( "TNF" ) + cTNFSeek + DToS( aColsAux[ nx, nPosDtEn ] ) + aColsAux[nx, nPosHrEn]
			If lSigaMdtps
				cSeekTmp := xFilial( "TNF" ) + aColsAux[ nx, nPosForn ] + aColsAux[ nx, nPosLoja ] + cCliMdtps + aColsAux[ nx, nPosEPI ] +;
							 aColsAux[ nx, nPosNumC ] + SRA->RA_MAT + DToS( aColsAux[ nx, nPosDtEn ] ) + aColsAux[nx, nPosHrEn]
			EndIf
			dbSelectArea( "TNF" )
			dbSetOrder( nInd2TNF )
			If dbSeek( cSeekTmp )
				//--------------------------------
				// Atualiza relacionamento da TNF
				//--------------------------------
				lRet := fAtuRelTNF( .T. )

				If !lRet
					Return .F.
				EndIf
			EndIf

			dbSelectArea( "TNF" )
			Loop
		EndIf

		cTNFSeek := IIf( lCallMDT630, aColsAux[ nx, nPosMatr ], aColsAux[ nx, nPosEPI ] )

		If !Empty( cTNFSeek )

			If	Empty( aColsAux[ nx, nPosInDe ] ) //Coloca o Status do Epi como "2=Epi em uso" caso o mesmo seja inclusão e esteja vazio.
				aColsAux[ nx, nPosInDe ] := "2"
			EndIf

			//Tenta localizar a linha no aColsAux salvo
			nPosTNF  := fRetChave( aColsAux[ nx ], aGridAux[ _nHeader ] )

			lAltCols := .T. //Se alterou algum campo da linha

			If nPosTNF > 0
				lAltCols := !ArrayCompare( aColsAux[ nX ], aColsTNF[ nPosTNF ] )
			EndIf

			If !lAltCols //Se não alterou nenhum campo da linha, não processa a linha.
				Loop
			EndIf

			If lCallMDT630
				cTNFSeek := ( cTRBTN3 )->FORNEC + ( cTRBTN3 )->LOJA + cCliMDTPs + ( cTRBTN3 )->CODEPI + ( cTRBTN3 )->NUMCAP + aColsAux[ nx, nPosMatr ]
			Else
				cTNFSeek := aColsAux[ nx, nPosForn ] + aColsAux[ nx, nPosLoja ] + cCliMDTPs + aColsAux[ nx, nPosEPI ] + aColsAux[ nx, nPosNumC ] + M->RA_MAT
			EndIf

			dbSelectArea( "TNF" )
			dbSetOrder( nInd2TNF )
			cSeekTmp := xFilial( "TNF" ) + cTNFSeek + DToS( aColsAux[ nx, nPosDtEn ] ) + aColsAux[ nx, nPosHrEn ]

			lIncTNF := !dbSeek( cSeekTmp )

			RegToMemory( "TNF", .T. )
			M->TNF_FILIAL := xFilial( 'TNF' )
			M->TNF_MAT    := SRA->RA_MAT
			M->TNF_CODFUN := SRA->RA_CODFUNC
			If lSigaMdtps
				M->TNF_CLIENT := SA1->A1_COD
				M->TNF_LOJACL := SA1->A1_LOJA
			EndIf
			dbSelectArea( "TNF" )
			dbSetOrder( nInd2TNF )

			For i := 1 To FCount()
				If lCallMDT630 //Caso seja através do MDTA630
					If FieldName( i ) == "TNF_FILIAL" .Or. FieldName( i ) == "TNF_MAT" .Or. FieldName( i ) == "TNF_FORNEC";
					.Or. FieldName( i ) == "TNF_LOJA" .Or. FieldName( i ) == "TNF_CODEPI" .Or. FieldName( i ) == "TNF_NUMCAP" .Or. GdFieldPos( FieldName( i ) ) < 1
						Loop
					EndIf
				Else
					If FieldName( i ) == "TNF_FILIAL" .Or. FieldName( i ) == "TNF_MAT" .Or. GdFieldPos( FieldName( i ) ) < 1
						Loop
					EndIf
				EndIf
				If lSigaMdtps
					If FieldName( i ) == "TNF_CLIENT" .Or. FieldName( i ) == "TNF_LOJACL"
						Loop
					EndIf
				EndIf
				x   := "M->" + FieldName( i )
				&x. := aColsAux[ nx, GdFieldPos( FieldName( i ) ) ]
			Next i

			If lCallMDT630 //Caso seja MDTA630
				M->TNF_FORNEC := ( cTRBTN3 )->FORNEC
				M->TNF_LOJA   := ( cTRBTN3 )->LOJA
				M->TNF_CODEPI := ( cTRBTN3 )->CODEPI
				M->TNF_NUMCAP := ( cTRBTN3 )->NUMCAP
			EndIf

		EndIf

		If !lMSErroAuto

			dbSelectArea( "TNF" )
			RecLock( "TNF", lIncTNF )
				//-----------------------------------------
				//	Atualiza dados dos epi's entregues
				//-----------------------------------------
				TNF->TNF_FILIAL := xFilial( 'TNF' )
				If IsInCallStack( "MDTA410" )
					cMatricula := M->TM0_MAT
				ElseIf lExistMAT
					cMatricula := M->RA_MAT
				ElseIf lCallMDT630
					cMatricula := aColsAux[ nx, nPosMatr ]
				Else
					cMatricula := SRA->RA_MAT
				EndIf

				TNF->TNF_MAT  := cMatricula

				If lExistCOD
					TNF->TNF_CODFUN := M->RA_CODFUNC
				ElseIf lCallMDT630
					TNF->TNF_CODFUN := NGSeek( "SRA", aColsAux[ nx, nPosMatr ], 1, "SRA->RA_CODFUNC" )
				Else
					TNF->TNF_CODFUN := SRA->RA_CODFUNC
				EndIf

				If lCallMDT630 //Caso seja chamado pelo MDTA630
					TNF->TNF_FORNEC := ( cTRBTN3 )->FORNEC
					TNF->TNF_LOJA   := ( cTRBTN3 )->LOJA
					TNF->TNF_CODEPI := ( cTRBTN3 )->CODEPI
					TNF->TNF_NUMCAP := ( cTRBTN3 )->NUMCAP
				EndIf

				If !lIncTNF .And. M->TNF_EPIEFI != TNF->TNF_EPIEFI // Ao alterar a eficácia do EPI deve ser gerado um novo evento S-2240
					aAdd( aEpiAltEso, AllTrim( TNF->TNF_NUMCAP ) )
				EndIf

				If lSigaMdtps
					TNF->TNF_CLIENT := SA1->A1_COD
					TNF->TNF_LOJACL := SA1->A1_LOJA
				EndIf

				dbSelectArea( "TNF" )
				dbSetOrder( nInd2TNF )

				If l695Auto .And. ( lDevPar := M->TNF_QTDEVO > 0 .And. M->TNF_QTDENT > M->TNF_QTDEVO )
					lDevTot := M->TNF_QTDENT == ( TNF->TNF_QTDEVO + M->TNF_QTDEVO )
				EndIf

				nQtdDev := M->TNF_QTDEVO // Salva qtd. devolvida atual para gravar na TLW

				For i := 1 To FCount()

					If lCallMDT630 //Caso seja através do MDTA630
						If FieldName( i ) == "TNF_FILIAL" .Or. FieldName( i ) == "TNF_MAT" .Or. FieldName( i ) == "TNF_FORNEC";
						.Or. FieldName( i ) == "TNF_LOJA" .Or. FieldName( i ) == "TNF_CODEPI" .Or. FieldName( i ) == "TNF_NUMCAP" .Or. GdFieldPos( FieldName( i ) ) < 1
							Loop
						EndIf
					Else
						If FieldName( i ) == "TNF_FILIAL" .Or. FieldName( i ) == "TNF_MAT" .Or. GdFieldPos( FieldName( i ) ) < 1
							Loop
						EndIf
					EndIf

					If l695Auto .And. lDevPar

						// Campo de numeração preenchido automaticamente na entrega portanto não é informado no execauto
						If FieldName( i ) == 'TNF_NUMSEQ'
							Loop
						EndIf

						// Devolução parcial
						If !lDevTot

							// Esses campos não devem ser gravados na devolução parcial mas precisam ser informados para o estoque
							If FieldName( i ) == 'TNF_DTDEVO' .Or. FieldName( i ) == 'TNF_TIPODV';
							.Or. FieldName( i ) == 'TNF_LOCDV'
								Loop
							EndIf

						// Devolução parcial total
						ElseIf FieldName( i ) == 'TNF_INDDEV'
							aColsAux[ nx, GdFieldPos( 'TNF_INDDEV' ) ] := '1'
						ElseIf FieldName( i ) == 'TNF_QTDENT'
							aColsAux[ nx, GdFieldPos( 'TNF_QTDEVO' ) ] := TNF->TNF_QTDEVO + M->TNF_QTDEVO
						EndIf

					EndIf

					x   := "m->" + FieldName( i )
					&x. := aColsAux[ nx, GdFieldPos( FieldName( i ) ) ]
					y   := "TNF->" + FieldName( i )
					&y := &x
				Next i

				If lCallMDT630 //Caso seja chamado pelo MDTA630
					//Adiciona os valores na memória
					M->TNF_FORNEC := ( cTRBTN3 )->FORNEC
					M->TNF_LOJA   := ( cTRBTN3 )->LOJA
					M->TNF_CODEPI := ( cTRBTN3 )->CODEPI
					M->TNF_NUMCAP := ( cTRBTN3 )->NUMCAP

					//Adiciona os valores no campo
					TNF->TNF_FORNEC := ( cTRBTN3 )->FORNEC
					TNF->TNF_LOJA   := ( cTRBTN3 )->LOJA
					TNF->TNF_CODEPI := ( cTRBTN3 )->CODEPI
					TNF->TNF_NUMCAP := ( cTRBTN3 )->NUMCAP
				EndIf

			TNF->(MsUnLock())

			For nY := 1 To Len( aMemosTNF )
				nPosMemo := GdFieldPos( aMemosTNF[ ny, 2 ] )
				If nPosMemo > 0
					If Empty( &( "TNF->" + aMemosTNF[ ny, 1 ] ) )
						MSMM( , TamSx3( aMemosTNF[ny][2] )[1], , aColsAux[ nx, nPosMemo ], 1, , , "TNF", aMemosTNF[ny][1] )

					Else
						MSMM( &( "TNF->" + aMemosTNF[ny][1] ), TamSx3( aMemosTNF[ny][2] )[1], , aColsAux[ nx, nPosMemo ], 1, , , "TNF", aMemosTNF[ny][1] )
					EndIf
				EndIf

			Next nY

			If ( nPosTNF == 0 .Or. aColsTNF[ nPosTNF, nPosInDe ]  != "1" ) .And. M->TNF_INDDEV == "1" .And. !lLogix

				fGraDevTlw( cTimeGrav, nPosLcDv, nQtdDev )

			ElseIf l695Auto .And. M->TNF_INDDEV == '2' .And. M->TNF_QTDEVO > 0;
			.And. M->TNF_QTDENT > M->TNF_QTDEVO

				fGraDevTlw( cTimeGrav, nPosLcDv, nQtdDev )

			EndIf

		EndIf

	Next nx

	If lTmpTLW
		dbSelectArea( cAliasTLW )
		dbSetOrder( 1 )//TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)
		dbGoTop()
		While ( cAliasTLW )->( !Eof() )

			dbSelectArea( "TLW" )
			dbSetOrder( 1 )
			If dbSeek( xFilial( "TLW" ) +( cAliasTLW )->TLW_FORNEC + ( cAliasTLW )->TLW_LOJA + ( cAliasTLW )->TLW_CODEPI + ( cAliasTLW )->TLW_NUMCAP + ;
			( cAliasTLW )->TLW_MAT + DTOS( ( cAliasTLW )->TLW_DTENTR ) + ( cAliasTLW )->TLW_HRENTR + ;
			DTOS( ( cAliasTLW )->TLW_DTDEVO ) + ( cAliasTLW )->TLW_HRDEVO )
				dbSelectArea( "TNF" )
				dbSetOrder( 1 )//TNF_FILIAL+TNF_FORNEC+TNF_LOJA+TNF_CODEPI+TNF_NUMCAP+TNF_MAT+DTOS(TNF_DTENTR)+TNF_HRENTR
				If !dbSeek( xFilial( "TNF" ) + TLW->TLW_FORNEC + TLW->TLW_LOJA + TLW->TLW_CODEPI + TLW->TLW_NUMCAP + TLW->TLW_MAT +;
				DTOS( TLW->TLW_DTENTR ) + TLW->TLW_HRENTR ) .Or. ( cAliasTLW )->TLW_DELETE == _DELETADO
					dbSelectArea( "TLW" )

					If ( cAliasTLW )->TLW_DELETE == _DELETADO .And. cUsaInt1 == "S" .And. TLW->TLW_TIPODV == "1"
						aMovEst := fGetTmpMov()
						cNUMSEQ := MdtMovEst( "RE0", TLW->TLW_LOCAL, TLW->TLW_CODEPI, TLW->TLW_QTDEVO,;
						TLW->TLW_DTDEVO, " ", TLW->TLW_MAT, Nil, Nil, Nil,;
						 aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4] )
						If Empty( cNUMSEQ )// Indica que a transação não foi executada
							DisarmTransaction()
							Return .F.
						EndIf
					EndIf
					RecLock( "TLW", .F. )
					dbDelete()
					lRecLockTLW := .F.
				Else
					lRecLockTLW := .T.
					lOperacao   := .F.
				EndIf
			Else
				If ( cAliasTLW )->TLW_DELETE == _DELETADO
					( cAliasTLW )->( dbSkip() )
					Loop
				EndIf

				lRecLockTLW := .T.
				lOperacao   := .T.
			EndIf

			If lRecLockTLW
				If lCallMDT630
					nPosTNF := aScan( aColsTNF, { | x | (cAliasTLW)->TLW_MAT == x[ nPosMatr ] .And. ;
					(cAliasTLW)->TLW_DTENTR == x[ nPosDtEn ] .And.;
					(cAliasTLW)->TLW_HRENTR == Substr( x[ nPosHrEn ], 1, 5 ) } )
				Else
					nPosTNF := aScan( aColsTNF, { | x | (cAliasTLW)->TLW_FORNEC == x[ nPosForn ] .And. (cAliasTLW)->TLW_LOJA == x[ nPosLoja ] .And. ;
					(cAliasTLW)->TLW_CODEPI == x[ nPosEPI ] .And. (cAliasTLW)->TLW_NUMCAP == x[ nPosNumC ] .And. ;
					(cAliasTLW)->TLW_DTENTR == x[ nPosDtEn ] .And. (cAliasTLW)->TLW_HRENTR == x[nPosHrEn] } )
				EndIf
				aMovEst := fGetTmpMov( .T. )
				If cUsaInt1 == "S" .And. (cAliasTLW)->TLW_TIPODV == "1"
					// Quando inclui TLW é gerado uma devolução na movimentação do estoque
					If lOperacao
						cNumSeq := MdtMovEst( "DE0", (cAliasTLW)->TLW_LOCAL, (cAliasTLW)->TLW_CODEPI, (cAliasTLW)->TLW_QTDEVO,;
						 (cAliasTLW)->TLW_DTDEVO, " ", (cAliasTLW)->TLW_MAT, Nil, Nil, Nil,;
						 aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4] )
						If Empty( cNUMSEQ ) // Indica que a transação não foi executada
							DisarmTransaction()
							Return .F.
						EndIf
						RecLock( cAliasTLW, .F. )
							(cAliasTLW)->TLW_NUMSEQ := cNumSeq
						(cAliasTLW)->( MSUnLock() )
					ElseIf ( TLW->TLW_TIPODV == "1" .And. (cAliasTLW)->TLW_TIPODV != "1" )
						cNUMSEQ := MdtMovEst( "DE0", TNF->TNF_LOCAL, TNF->TNF_CODEPI, TNF->TNF_QTDEVO,;
						 TNF->TNF_DTDEVO, " ", TNF->TNF_MAT, Nil, Nil, Nil,;
						 aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4] )
						If Empty( cNUMSEQ )// Indica que a transação não foi executada
							DisarmTransaction()
							Return .F.
						EndIf
					EndIf
				EndIf

				RecLock( "TLW", lOperacao )
				For nX := 1 To FCount()
					cCampo := FieldName( nX )
					If TLW->( FieldPos( cCampo ) ) > 0 .And. ( cAliasTLW )->( FieldPos( cCampo ) ) > 0
						xResult := ( cAliasTLW )->&( cCampo )
						TLW->&( cCampo ) := xResult
					EndIf
				Next nX
				IncluiTLW := .F.
			EndIf

			TLW->( MsUnLock() )

			( cAliasTLW )->( dbSkip() )
		End
	EndIf

	lProcTLW := .F.

	dbSelectArea( "TNF" )
	dbSetOrder( nIndTNF ) //TNF_FILIAL+TNF_MAT+TNF_CODEPI+DTOS(TNF_DTENTR)+TNF_HRENTR
	dbSeek( cSeekTNF )

	While !Eof() .And. cSeekTNF == &(cCondTNF)

		//Caso o registro não tenha sido incluido/alterado pula
		If !( aScan( aColsAlt, { |x| x[1] == TNF->TNF_MAT + TNF->TNF_CODEPI + DToS( TNF->TNF_DTENTR ) + TNF->TNF_HRENTR } ) > 0 )
			TNF->( dbSkip() )
			Loop
		EndIf

		//Incrementa o EPI processado para controle de SA
		nContReg++

		lProcTLW 	:= .F.
		If lCallMDT630
			cTNFSeek := ( cTRBTN3 )->FORNEC + ( cTRBTN3 )->LOJA + ( cTRBTN3 )->CODEPI + ( cTRBTN3 )->NUMCAP + TNF->TNF_MAT + DToS( TNF->TNF_DTENTR ) + TNF->TNF_HRENTR
		Else
			cTNFSeek := TNF->TNF_FORNEC + TNF->TNF_LOJA + TNF->TNF_CODEPI + TNF->TNF_NUMCAP + TNF->TNF_MAT + DToS( TNF->TNF_DTENTR ) + TNF->TNF_HRENTR
		EndIf
		aAreaTNF := TNF->( GetArea() )
		dbSelectArea( "TLW" )
		dbSetOrder( 1 )
		If lTmpTLW .And. dbSeek( xFilial( "TLW" ) + cTNFSeek )
			lProcTLW := .T.
			While !Eof() .And. xFilial( "TLW" ) == TLW->TLW_FILIAL .And. ;
			TLW->TLW_FORNEC + TLW->TLW_LOJA + TLW->TLW_CODEPI + TLW->TLW_NUMCAP +;
			TLW->TLW_MAT + DToS( TLW->TLW_DTENTR ) + TLW->TLW_HRENTR == cTNFSeek
				dbSelectArea( cAliasTLW )
				dbSetOrder( 1 ) //TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)
				If !dbSeek( cTNFSeek + DToS( TLW->TLW_DTDEVO ) + TLW->TLW_HRDEVO )
					RecLock( "TLW", .F. )
						dbDelete()
					TLW->(MsUnLock())
				EndIf

				TLW->( dbSkip() )
			End
		EndIf

		cMatricula := TNF->TNF_MAT

		// Localiza a linha correspondente do registro nos arrays
		If lCallMDT630
			nPosTNF := aScan( aColsTNF, bPosMdt630 )
			nPosTNFAux := aScan( aColsAux, bPosMdt630 )
		Else
			nPosTNF := aScan( aColsTNF, bPosMdt695 )
			nPosTNFAux := aScan( aColsAux, bPosMdt695 )
		EndIf

		If lCallMDT630
			cCodEPI   := TN3->TN3_CODEPI
			cFilialSRA := NGSeek( "SRA", cMatricula, 1, "SRA->RA_FILIAL" )
			cCenCusto  := NGSeek( "SRA", cMatricula, 1, "SRA->RA_CC" )
		Else
			cCodEPI    := TNF->TNF_CODEPI
			cFilialSRA := M->RA_FILIAL
			cCenCusto  := M->RA_CC
		EndIf

		lQtdIgual  := .T. //Se nao foi alterado a quantidade/almoxarifado
		lDevolvido := .F. //Se foi devolvido
		lDevRetorn := .F. //Se foi re-entregue ao funcionario
		lDevAlmox2 := .F. //Se foi devolvido e alterado o almoxarifado na devolucao
		lReDevAlm2 := .F. //Se foi alterado o almoxarifado ja delvovido
		lEntGeraSA := .F. //Se antes estava entregue e agora gerado S.A.

		nDevoQtdade := 0
		cTNFNumSeq := ""
		cD3Custo   := ""
		cTNFSaiLog := ""
		cTNFEntLog := ""
		lObserva   := .F.

		If cUsaInt1 == "S" .And. nPosTNF > 0 //Movimentação de estoque de EPIs já entregues/devolvidos caso tenham sido alterados

			lAlterou := .F.
			If TNF->TNF_INDDEV != aColsTNF[ nPosTNF, nPosInDe ]
				lAlterou := .T.
			Else
				//Verifica se o campo alterado foi o LOCAL, pois estava vazio e preenchido inicialmente
				If cUsaInt1 == "S" .And. nPosLocal > 0
					lAlterou := !Empty( aColsTNF[ nPosTNF, nPosLocal ] ) .And. TNF->TNF_LOCAL != aColsTNF[ nPosTNF, nPosLocal ]
				EndIf

				If nPosTipoDv > 0
					lAlterou := TNF->TNF_TIPODV != aColsTNF[ nPosTNF, nPosTipoDv ]
				EndIf
			EndIf

			If !lAlterou .And. cUsaRast == "S"
				lAlterou := TNF->TNF_LOTECT != aColsTNF[ nPosTNF, nPosLot ] .Or. TNF->TNF_LOTESB != aColsTNF[ nPosTNF, nPosSubL ]
			EndIf

			If !lAlterou .And. cUsaLocz == "S"
				lAlterou := TNF->TNF_ENDLOC != aColsTNF[ nPosTNF, nPosEnd ] .Or. TNF->TNF_NSERIE != aColsTNF[ nPosTNF, nPosEnd ]
			EndIf

			If !lAlterou .And. lLogix
				lAlterou := AllTrim( MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ) ) !=AllTrim( aColsTNF[ nPosTNF, nPosObs ] )
			EndIf

			If lAlterou
				lQtdIgual := aColsTNF[ nPosTNF, nPosQtde ] == TNF->TNF_QTDENT

				// Analisa ( se o Almoxarifado foi trocado ) Ou ( se há rastreio e ( foi alterado o Lote ou o Sub Lote do EPI ))
				// Ou ( se há utilização de localização e foi alterado o endereço ou o número de série )
				// Se sim indica que quantidade não é igual e que
				If	nPosLcDv > 0
					If aColsTNF[ nPosTNF, nPosLcDv ] != TNF->TNF_LOCDV .And. !Empty( aColsTNF[ nPosTNF, nPosLcDv ] )
						lQtdIgual := .F.
						lDevAlmox2 := .T.
					EndIf
				ElseIf ( nPosLocal > 0 .And. aColsTNF[ nPosTNF, nPosLocal ] != TNF->TNF_LOCAL .And. !Empty( aColsTNF[ nPosTNF, nPosLocal ] ) )
					lQtdIgual := .F.
					lDevAlmox2 := .T.
				EndIf

				If ( cUsaRast == "S" .And. ( aColsTNF[ nPosTNF, nPosLot ] != TNF->TNF_LOTECT .Or. aColsTNF[ nPosTNF, nPosSubL ] != TNF->TNF_LOTESB ) ) .Or.;
					( cUsaLocz == "S" .And. ( !Empty( AllTrim( aColsTNF[ nPosTNF, nPosEnd ] ) ) .And. aColsTNF[ nPosTNF, nPosEnd ] != TNF->TNF_ENDLOC .Or. ;
					!Empty( AllTrim( aColsTNF[ nPosTNF, nPosNSer ] ) ) .And. aColsTNF[ nPosTNF, nPosNSer ] != TNF->TNF_NSERIE ) )

					lQtdIgual := .F.
					lDevAlmox2 := .T.
				EndIf

				If lDevAlmox2
					//Se não alterou o status do EPI como devolvido
					If  TNF->TNF_INDDEV == "1" .And. !Empty( TNF->TNF_DTDEVO ) .And.;
					aColsTNF[ nPosTNF, nPosInDe ] == "1" .And. !Empty( aColsTNF[ nPosTNF, nPosDtDe ] )

						lReDevAlm2 := .T. //Indica que já foi encaminhado uma solicitação ao armazém
					EndIf
				EndIf

				//Verifica se alterou para reentregar ao Funcionario, se troca o Status que era de Devolvido, ou a data de Devolução não esta mais
				//preenchido ou o não será devolvido ao almoxarifado.
				If aColsTNF[ nPosTNF, nPosInDe ] == "1" .And. !Empty( aColsTNF[ nPosTNF, nPosDtDe ] ) .And.;
					 ( IIf( nPosTipoDv > 0, aColsTNF[ nPosTNF, nPosTipoDv ] != "2", .T. ) )

					If ( TNF->TNF_INDDEV != "1" .Or. Empty( TNF->TNF_DTDEVO ) .Or. ;
					(	IIf( nPosTipoDv > 0, TNF->TNF_TIPODV == "2", .F. ) ) )
						If !lProcTLW
							lDevRetorn := .T.
						EndIf
					EndIf
				EndIf

				//Verifica se troca o Status que era de Devolvido, ou a data de Devolução estiver preenchida ou indica que será devolvido ao almoxarifado.
				If TNF->TNF_INDDEV == "1" .And. !Empty( TNF->TNF_DTDEVO ) .And.;
				( IIf( nPosTipoDv > 0, TNF->TNF_TIPODV != "2", .F. ) ) .And.;
				( aColsTNF[ nPosTNF, nPosInDe ] != "1" .Or.;
				Empty( aColsTNF[ nPosTNF, nPosInDe ] ) .Or.;
				( IIf( nPosTipoDv > 0, aColsTNF[ nPosTNF, nPosTipoDv ] == "2", .F. ) ) )

					lDevolvido := .T.
					//Se o EPI ficou para solicitação de armazém e antes estava sendo usado ou sem status
					//deverá gerar Solicitação de Armazem, e que EPI antigo foi devolvido
				ElseIf TNF->TNF_INDDEV == "3" .And. ( aColsTNF[ nPosTNF, nPosInDe ] == "2" .Or. Empty( aColsTNF[ nPosTNF, nPosInDe ] ) )
					lDevolvido := .T.
					lEntGeraSA := .T.
				Else // Caso nenhum dos casos não foram concluido, quer dizer que não houve troca de Almoxarifado
					lDevAlmox2 := .F.
				EndIf

				lObserva := lLogix .And. nPosObs > 0 .And. AllTrim( MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ) ) !=;
							 AllTrim( aColsTNF[ nPosTNF, nPosObs ] )

				// Se alterou a quantidade, não foi reentregue, não foi devolvido e nem alterado o almoxarifado de entrega
				If ( !lQtdIgual .And. !lDevRetorn .And. !lDevolvido .And. !lReDevAlm2 ) .Or.;
				( lDevolvido .And. lQtdIgual ) .Or. ; // Ou se foi devolvido a mesma quantidade entregue
				( lDevolvido .And. lEntGeraSA ) // Ou se foi devolvido EPI e deverá gerar Solicitação de Armazem

					dDataTmp := IIf( lDevolvido .And. !Empty( aColsTNF[ nPosTNF, nPosDtDe ] ), aColsTNF[ nPosTNF, nPosDtDe ],;
								 aColsAux[ nPosTNFAux, nPosDtDe ] )
					nQtMovim := aColsTNF[ nPosTNF, nPosQtde ]
					lGerarD3 := .T.

					If lGera_SA
						If aColsTNF[ nPosTNF, nPosInDe ] == "3" .And. !Empty( aColsTNF[ nPosTNF, nPosNSA ] ) .And. !Empty( aColsTNF[ nPosTNF, nPosISA ] )
							aNumSA := MdtMovSA( "D", cCodEPI, aColsTNF[ nPosTNF, nPosQtde ], aColsTNF[ nPosTNF, nPosNSeq ],;
									 aColsTNF[ nPosTNF, nPosNSA ], aColsTNF[ nPosTNF, nPosISA ], aColsTNF[ nPosTNF, nPosDtEn ],;
									 cMatricula, , cFilialSRA, aColsTNF[ nPosTNF, nPosLocal ],;
									 IIf( nPosSaiLog > 0, aColsTNF[ nPosTNF, nPosSaiLog ], "" ) )
							If Len( aNumSA ) > 2 .And. aNumSA[3] == _ErroLogix
								Return .F.
							EndIf
							RecLock( "TNF", .F. )
								TNF->TNF_NUMSA  := Space( Len( TNF->TNF_NUMSA ) )
								TNF->TNF_ITEMSA := Space( Len( TNF->TNF_ITEMSA ) )
							TNF->(MsUnLock())
							lGerarD3 := .F.
						EndIf
					EndIf

					If lGerarD3 .And. lProcTLW
						//Quantidade ja devolvida do EPI
						If !lQtdIgual
							nQtMovim := nQtMovim - aColsTNF[ nPosTNF, nPosQTDDv ]
							aMovEst := fGetTmpMov( , aColsTNF[ nPosTNF ] )
							cNUMSEQ := MdtMovEst( "DE0", IIf( nPosLcDv == 0, aColsTNF[ nPosTNF, nPosLocal ], aColsTNF[ nPosTNF, nPosLcDv ] ),;
												 cCodEPI, nQtMovim, dDataTmp, " ", cMatricula, Nil, Nil,;
												 aColsTNF[ nPosTNF, nPosNSeq ], aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4] )
							If Empty( cNUMSEQ )// Indica que a transação não foi executada
								DisarmTransaction()
								Return .F.
							EndIf
						Else
							nDevoQtdade := fQuantDevo( cTNFSeek )
							nQtMovim := nQtMovim - nDevoQtdade

							If nQtMovim > 0
								nHoraTLW := HtoM( cTimeGrav )
								dDateTLW := TNF->TNF_DTDEVO
								cHoraTLW := ""
								dbSelectArea( "TLW" )
								dbSetOrder( 1 )
								If !dbSeek( xFilial( "TLW" ) + cTNFSeek + DtoS( dDateTLW ) + MtoH( nHoraTLW ) )
									cHoraTLW := MtoH( nHoraTLW )
								Else
									While Empty( cHoraTLW ) .And. dDateTLW < TNF->TNF_QTDEVO + 2
										nHoraTLW++
										If nHoraTLW >= 1440  //Se possou de 24 horas
											nHoraTLW := 1
											dDateTLW++
										EndIf
										If !dbSeek( xFilial( "TLW" ) + cTNFSeek + DtoS( dDateTLW ) + MtoH( nHoraTLW ) )

											cHoraTLW := MtoH( nHoraTLW )
										EndIf
									End
								EndIf
								If !Empty( cHoraTLW )
									dbSelectArea( "TLW" )
									RecLock( "TLW", .T. )
										TLW->TLW_FILIAL := xFilial( "TLW" )
										TLW->TLW_FORNEC := TNF->TNF_FORNEC
										TLW->TLW_LOJA   := TNF->TNF_LOJA
										TLW->TLW_CODEPI := TNF->TNF_CODEPI
										TLW->TLW_NUMCAP := TNF->TNF_NUMCAP
										TLW->TLW_MAT    := cMatricula
										TLW->TLW_DTENTR := TNF->TNF_DTENTR
										TLW->TLW_HRENTR := TNF->TNF_HRENTR
										TLW->TLW_DTDEVO := dDateTLW
										TLW->TLW_HRDEVO := cHoraTLW
										TLW->TLW_QTDEVO := nQtMovim
										TLW->TLW_TIPODV := TNF->TNF_TIPODV
										TLW->TLW_LOCAL  := IIf( nPosLcDv == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV )
									TLW->(MSUNLOCK())
									If TLW->TLW_TIPODV != "2"
										aMovEst := fGetTmpMov( , aColsTNF[ nPosTNF] )
										cNumSeq := MdtMovEst( "DE0", TLW->TLW_LOCAL, TLW->TLW_CODEPI, TLW->TLW_QTDEVO, TLW->TLW_DTDEVO, " ",;
												 TLW->TLW_MAT, Nil, Nil, aColsTNF[ nPosTNF, nPosNSeq ], aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4] )
										If Empty( cNUMSEQ ) // Indica que a transação não foi executada
											DisarmTransaction()
											Return .F.
										EndIf
										RecLock( "TLW", .F. )
											TLW->TLW_NUMSEQ := cNumSeq
										TLW->( MSUnlock())
									EndIf
								EndIf
							EndIf
						EndIf
					ElseIf lGerarD3
						lMdtEstorno := !lDevolvido .And. !lQtdIgual .And. nDevoQtdade == 0
						If lDevolvido .And. lQtdIgual
							cTmp_Local := IIf( nPosLcDv == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV )
						Else
							cTmp_Local := IIf( nPosLcDv == 0, aColsTNF[ nPosTNF, nPosLocal ], aColsTNF[ nPosTNF, nPosLcDv ] )
						EndIf

						aMovEst := fGetTmpMov( lDevolvido .And. lQtdIgual, aColsTNF[ nPosTNF ] )
						If lQtdIgual .And. Empty( cNUMSEQ )
							cNUMSEQ := MdtMovEst( "DE0", cTmp_Local, cCodEPI, nQtMovim, dDataTmp, " ", cMatricula,;
											 Nil, lMdtEstorno, aColsTNF[ nPosTNF, nPosNSeq ],;
											 aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4] )
						EndIf
						If Empty( cNUMSEQ )// Indica que a transação não foi executada
							DisarmTransaction()
							Return .F.
						EndIf
						If lLogix .And. lDevolvido .And. lQtdIgual
							dbSelectArea( "SRA" )
							dbSetOrder( 1 ) //RA_FILIAL+RA_MAT
							dbSeek( xFilial( "SRA" ) + TNF->TNF_MAT )

							dbSelectArea( "SB1" )
							dbSetOrder( 1 )
							dbSeek( xFilial( "SB1" ) + IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI ) )

							//Campo CC
							If !Empty( TNF->TNF_MAT ) .And. FindFunction( "MDTCCFunc" )
								cCCSCP := MDTCCFunc( TNF->TNF_MAT, cCenCusto, TNF->TNF_DTDEVO )
							Else
								cCCSCP := cCenCusto
							EndIf

							//Campo Observação
							If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
								cObsSCP	:= SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
							Else
								cObsSCP	:= STR0166 + ": " + SRA->RA_FILIAL + "-" + cMatricula //"FUNCIONARIO"
							EndIf
							cCodEpiSCP := IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI )
							cCodLocSCP := IIf( nPosLcDv == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV )

							dbSelectArea( "SCP" )
							RegToMemory( "SCP", .T. )
							M->CP_PRODUTO := IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI )
							M->CP_UM      := SB1->B1_UM
							M->CP_QUANT   := TNF->TNF_QTDEVO
							M->CP_DATPRF  := TNF->TNF_DTDEVO
							M->CP_LOCAL   := IIf( nPosLcDv == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV )
							M->CP_CC      := IIf( !Empty( TNF->TNF_MAT ) .And. FindFunction( "MDTCCFunc" ),;
											 MDTCCFunc( TNF->TNF_MAT, cCenCusto, TNF->TNF_DTDEVO ), cCenCusto )
							M->CP_EMISSAO := dDataBase
							M->CP_DESCRI  := SB1->B1_DESC
							M->CP_SOLICIT := cUserName
							M->CP_OBS     := STR0166 + ": " + SRA->RA_FILIAL + "-" + cMatricula //"FUNCIONARIO"
							If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
								M->CP_OBS := SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
							EndIf
							If lRet
								cMDTSerie   := "ENTRADA"
								cMdtReserva := ""
								cMDTNumRes  := ""
								lRet := NGMUReques( , "SCP", .T., 4 )
								If !lRet
									Return .F.
								EndIf
								cTNFEntLog := cMdtReserva
							Else
								Return .F.
							EndIf
						EndIf
					EndIf
					//Se Epi ja foi devolvido, e foi alterado apenas o almoxarifado
					If lReDevAlm2  .And. ( IIf( nPosTipoDv > 0, aColsTNF[ nPosTNF, nPosTipoDv ] != "2", .T. ) )
						//Quantidade ja devolvida do EPI
						nQtMovim := nQtMovim - aColsTNF[ nPosTNF, nPosQTDDv ]
						aMovEst := fGetTmpMov()
						cNUMSEQ := MdtMovEst( "RE0", aColsTNF[ nPosTNF, nPosLocal ], cCodEPI, nQtMovim,;
											 TNF->TNF_DTDEVO, " ", cMatricula, Nil, Nil, Nil,;
											 aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4] )
						If Empty( cNUMSEQ )// Indica que a transação não foi executada
							DisarmTransaction()
							Return .F.
						EndIf
					EndIf
				EndIf
			Else
				//Verifica se foi alterado somente a quantidade do epi entregue, se for deverá somente alterar a qtd na SCP
				If TNF->TNF_QTDENT != aColsTNF[ nPosTNF, nPosQtde ]
					If lLogix
						//Campo Observação
						If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
							cObsSCP	:= SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
						Else
							cObsSCP	:= STR0166 + ": " + SRA->RA_FILIAL + "-" + cMatricula //"FUNCIONARIO"
						EndIf

						dbSelectArea( "SB1" )
						dbSetOrder( 1 )
						dbSeek( xFilial( "SB1" ) + cCodEPI )
						dbSelectArea( "SCP" )
						dbSetOrder( 1 )
						If dbSeek( xFilial( "SCP" ) + TNF->TNF_NUMSA ) .And. SCP->CP_PRODUTO == cCodEpi
							cMDTSerie   := "SAIDA"
							cMdtReserva := ""
							cMDTNumRes  := TNF->TNF_SAILOG
							RegToMemory( "SCP", .F. )
							M->CP_QUANT := TNF->TNF_QTDENT
							M->CP_OBS   := cObsSCP
							//Realiza o Ajuste do que já foi lançado
							lRet := NGMUReques( , "SCP", .T., 4 )

						EndIf
					Else
						aNumSA := MdtMovSA( "R", cCodEpi, TNF->TNF_QTDENT, TNF->TNF_NUMSEQ, TNF->TNF_NUMSA, TNF->TNF_ITEMSA,;
									TNF->TNF_DTENTR, TNF->TNF_MAT, cCenCusto, cFilialSRA, TNF->TNF_LOCAL, ;
									IIf( nPosSaiLog > 0, TNF->TNF_SAILOG, "" ), IIf( lObser, TNF->TNF_CODOBS, "" ), , Len( aColsAlt ) )
						cTNFNumSA	:= ""
						cTNFItemSA	:= ""
						If Len( aNumSA ) > 2
							Return .F.
						EndIf
					EndIf

				ElseIf TNF->TNF_INDDEV == "1" .And. !Empty( TNF->TNF_DTDEVO ) .And.;
							( IIf( nPosTipoDv > 0, TNF->TNF_TIPODV != "2", .T. ) )
					lDevolvido := .T.
				EndIf
			EndIf
		EndIf
		//lQtdIgual se a Quantidade ou almoxafiado não forem iguais, se foi reentregue ao funcionario, ou se antes estava entregue e agora gera SA
		If cUsaInt1 == "S" .And. ( nPosTNF == 0 .Or. !lQtdIgual .Or. lDevRetorn .Or. lEntGeraSA )

			//Se o EPI indica como devolvido e se devolve ao almoxarifado
			If TNF->TNF_INDDEV == "1" .And. ( IIf( nPosTipoDv > 0, TNF->TNF_TIPODV == "1", .T. ) )
				//Reposicao - Incluir saldo
				//Se foi devolvido e alterado o almoxarifado na devolucao ou Se foi alterado o almoxarifado ja delvovido
				// Ou é um novo EPI e tem a data de devolução preenchida
				// E se devolve ao amoxarifado.
				If ( (nPosTNF == 0 .And. !Empty( TNF->TNF_DTDEVO ) ) .Or. lDevAlmox2 .Or. lReDevAlm2 ) .And.;
				 ( IIf( nPosTipoDv > 0, TNF->TNF_TIPODV == "1", .T. ) ) .And. IIf( nPosTNF != 0, .T., nEPIDev != 3 )

					aMovEst := fGetTmpMov()
					cNUMSEQ := MdtMovEst( "DE0", IIf( nPosLcDv == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV ), IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI ),;
										 TNF->TNF_QTDENT, TNF->TNF_DTDEVO, " ", TNF->TNF_MAT, Nil, Nil, TNF->TNF_NUMSEQ,;
										 aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4] )
					If Empty( cNUMSEQ )// Indica que a transação não foi executada
						DisarmTransaction()
						Return .F.
					EndIf
					cTNFNumSeq := cNUMSEQ

					cD3Custo := SD3->D3_CUSTO1

					If lLogix .And. lDevolvido .And. lQtdIgual
						dbSelectArea( "SRA" )
						dbSetOrder( 1 ) //RA_FILIAL+RA_MAT
						dbSeek( xFilial( "SRA" ) + TNF->TNF_MAT )
						dbSelectArea( "SB1" )
						dbSetOrder( 1 )
						dbSeek( xFilial( "SB1" ) + IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI ) )

						//Campo CC
						If !Empty( TNF->TNF_MAT ) .And. FindFunction( "MDTCCFunc" )
							cCCSCP := MDTCCFunc( TNF->TNF_MAT, cCenCusto, TNF->TNF_DTDEVO )
						Else
							cCCSCP := cCenCusto
						EndIf

						//Campo Observação
						If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
							cObsSCP	:= SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
						Else
							cObsSCP	:= STR0166 + ": " + SRA->RA_FILIAL + "-" + cMatricula //"FUNCIONARIO"
						EndIf
						cCodEpiSCP := IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI )
						cCodLocSCP := IIf( nPosLcDv == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV )

						dbSelectArea( "SCP" )
						RegToMemory( "SCP", .T. )
						M->CP_PRODUTO := IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI )
						M->CP_UM      := SB1->B1_UM
						M->CP_QUANT   := TNF->TNF_QTDEVO
						M->CP_DATPRF  := TNF->TNF_DTDEVO
						M->CP_LOCAL   := IIf( nPosLcDv == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV )
						M->CP_CC      := IIf( !Empty( TNF->TNF_MAT ) .And. FindFunction( "MDTCCFunc" ),;
											 MDTCCFunc( TNF->TNF_MAT, cCenCusto, TNF->TNF_DTDEVO ), cCenCusto )
						M->CP_EMISSAO := dDataBase
						M->CP_DESCRI  := SB1->B1_DESC
						M->CP_SOLICIT := cUserName
						M->CP_OBS     := STR0166 + ": " + SRA->RA_FILIAL + "-" + cMatricula //"FUNCIONARIO"
						If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
							M->CP_OBS  := SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
						EndIf

						If lRet
							cMDTSerie   := "ENTRADA"
							cMdtReserva := ""
							cMDTNumRes  := ""
							lRet        := NGMUReques( , "SCP", .T., IIf( nPosTNF == 0, 3, 4 ) )
							If !lRet
								Return .F.
							EndIf
							cTNFEntLog := cMdtReserva
						Else
							Return .F.
						EndIf
					EndIf
				EndIf
			Else

				// Requisicao - Subtrair saldo
				If ( !lDevolvido .And. !lDevAlmox2 .And. !lReDevAlm2 )
					lGerarD3 := .T.

					If lGera_SA .And. TNF->TNF_INDDEV == "3" // Gera Solicitação de Armazem
						//Requisita o Armazem gerando SA
						aNumSA	:= MdtMovSA( "R", IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI ), TNF->TNF_QTDENT, TNF->TNF_NUMSEQ,;
									TNF->TNF_NUMSA, TNF->TNF_ITEMSA, TNF->TNF_DTENTR, TNF->TNF_MAT, cCenCusto, cFilialSRA, TNF->TNF_LOCAL,;
									IIf( nPosSaiLog > 0, TNF->TNF_SAILOG, "" ), IIf( lObser, TNF->TNF_CODOBS, "" ), , Len( aColsAlt ) )
						lGerarD3   := .F.
						cTNFNumSA  := aNumSA[1]
						cTNFItemSA := aNumSA[2]

						If Len( aNumSA ) > 2

							If aNumSA[3] == _ErroLogix
								Return .F.
							Else
								cTNFSaiLog := aNumSA[3]
							EndIf

						EndIf

					EndIf

					// Se não gerou SA, requisita movimentação no Estoque
					If lGerarD3

						aMovEst := fGetTmpMov()
						cNUMSEQ := MdtMovEst( "RE0", TNF->TNF_LOCAL, TNF->TNF_CODEPI, TNF->TNF_QTDENT, TNF->TNF_DTENTR, " ", cMatricula, Nil,;
											 Nil, Nil, aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4] )
						If Empty( cNUMSEQ )// Indica que a transação não foi executada
							DisarmTransaction()
							Return .F.
						EndIf
						cTNFNumSeq := cNUMSEQ
						cD3Custo   := SD3->D3_CUSTO1
					EndIf

					// Se antes estava entregue e agora gerado S.A.
				ElseIf lGera_SA .And. lDevolvido .And. lEntGeraSA .And. TNF->TNF_INDDEV == "3" // Gera Solicitação de Armazem
					aNumSA := MdtMovSA( "R", IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI ), TNF->TNF_QTDENT, TNF->TNF_NUMSEQ,;
								TNF->TNF_NUMSA, TNF->TNF_ITEMSA, TNF->TNF_DTENTR, TNF->TNF_MAT, cCenCusto, cFilialSRA, TNF->TNF_LOCAL,;
								IIf( nPosSaiLog > 0, TNF->TNF_SAILOG, "" ), IIf( lObser, TNF->TNF_CODOBS, "" ), , Len( aColsAlt ) )
					cTNFNumSA	:= aNumSA[1]
					cTNFItemSA	:= aNumSA[2]

					If Len( aNumSA ) > 2

						If aNumSA[3] == _ErroLogix
							Return .F.
						Else
							cTNFSaiLog := aNumSA[3]
						EndIf

					EndIf
				EndIf
			EndIf
		EndIf

		If ValType( aAreaTNF ) == "A" .And. Len( aAreaTNF ) > 0
			RestArea( aAreaTNF )
		EndIf
		// Caso observação possui alteração, gera efetivação desta no Logix
		// Alinhado com Logix que pode ser enviado em processos separados
		If lObserva
			aArea := GetArea()
			aAreaTNF := TNF->( GetArea() )

			dbSelectArea( "SRA" )
			dbSetOrder( 1 ) //RA_FILIAL+RA_MAT
			dbSeek( xFilial( "SRA" ) + TNF->TNF_MAT )
			dbSelectArea( "SB1" )
			dbSetOrder( 1 )
			dbSeek( xFilial( "SB1" ) + IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI ) )

			//Campo CC
			If !Empty( TNF->TNF_MAT ) .And. FindFunction( "MDTCCFunc" )
				cCCSCP := MDTCCFunc( TNF->TNF_MAT, SRA->RA_CC, M->CP_DATPRF )
			Else
				cCCSCP := SRA->RA_CC
			EndIf

			//Campo Observação
			If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
				cObsSCP	:= SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
			Else
				cObsSCP	:= STR0166 + ": " + SRA->RA_FILIAL + "-" + cMatricula //"FUNCIONARIO"
			EndIf

			If TNF->TNF_INDDEV != "1"
				nQntEntSCP	:= TNF->TNF_QTDENT
				cDataEntSCP	:= TNF->TNF_DTENTR
				cLocalSCP	:= TNF->TNF_LOCAL
				cMDTSerie   := "SAIDA"
				cMDTNumRes  := TNF->TNF_SAILOG
			Else
				nQntEntSCP  := TNF->TNF_QTDEVO
				cDataEntSCP := TNF->TNF_DTDEVO
				cLocalSCP	:= IIf( nPosLcDv == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV )
				cMDTSerie   := "ENTRADA"
				cMDTNumRes  := TNF->TNF_ENTLOG
			EndIf
			cCodEpiSCP := IIf( lCallMDT630, ( cTRBTN3 )->CODEPI, TNF->TNF_CODEPI )

			dbSelectArea( "SCP" )
			RegToMemory( "SCP", .T. )
			M->CP_PRODUTO := TNF->TNF_CODEPI
			M->CP_UM      := SB1->B1_UM
			M->CP_QUANT   := TNF->TNF_QTDEVO
			M->CP_DATPRF  := TNF->TNF_DTDEVO
			M->CP_LOCAL   := IIf( lLocDevol == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV )
			cCCustoAux    := NgSeek( "SRA", TNF->TNF_MAT, 1, "SRA->RA_CC" )
			M->CP_CC      := IIf( !Empty( TNF->TNF_MAT ) .And. FindFunction( "MDTCCFunc" ),;
							 MDTCCFunc( TNF->TNF_MAT, cCCustoAux, TNF->TNF_DTDEVO ), cCCustoAux )
			M->CP_EMISSAO := dDataBase
			M->CP_DESCRI  := SB1->B1_DESC
			M->CP_SOLICIT := cUserName
			M->CP_OBS     := STR0166 + ": " + xFilial( "SRA", TNF->TNF_FILIAL ) + "-" + TNF->TNF_MAT //"FUNCIONARIO"
			If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
				M->CP_OBS := SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
			EndIf

			If lRet
				cMdtReserva := ""
				lRet := NGMUReques( , "SCP", .T., 4 )
				If !lRet
					RestArea( aAreaTNF )
					RestArea( aArea )
					Return .F.
				EndIf
			Else
				RestArea( aAreaTNF )
				RestArea( aArea )
				Return .F.
			EndIf
			RestArea( aAreaTNF )
			RestArea( aArea )
		EndIf

		//Guarda o funcionário para envio do evento S-2240 ao Governo
		If aScan( aFuncs, { | x | x[ 1 ] == TNF->TNF_MAT } ) == 0 .And. TNF->TNF_INDDEV <> "1"
			aAdd( aFuncs, { TNF->TNF_MAT, , , , , , , {} } )
		EndIf

		If Len( aFuncs ) > 0
			If ( nPosEpiEso := aScan( aFuncs, { |x| x[1] == TNF->TNF_MAT } ) ) > 0
				aAdd( aFuncs[ nPosEpiEso, 8 ], { TNF->TNF_CODEPI, TNF->TNF_DTENTR, TNF->TNF_DTDEVO, TNF->TNF_INDDEV, TNF->TNF_FORNEC, TNF->TNF_LOJA, TNF->TNF_NUMCAP, TNF->TNF_EPIEFI, Nil, TNF->TNF_HRENTR } )
			EndIf
		EndIf

		RecLock( "TNF", .F. )

		If Empty( TNF->TNF_QTDEVO )
			TNF->TNF_QTDEVO := nDevoQtdade
		EndIf
		If !Empty( cTNFNumSeq )
			TNF->TNF_NUMSEQ := cTNFNumSeq
		EndIf
		If !Empty( cD3Custo )
			TNF->TNF_CUSTO  := cD3Custo
		EndIf
		If !Empty( cTNFNumSA )
			TNF->TNF_NUMSA  := cTNFNumSA
		EndIf
		If !Empty( cTNFItemSA )
			TNF->TNF_ITEMSA := cTNFItemSA
		EndIf
		If !Empty( cTNFSaiLog )
			TNF->TNF_SAILOG := cTNFSaiLog
		EndIf
		If !Empty( cTNFEntLog )
			TNF->TNF_ENTLOG := cTNFEntLog
		EndIf

		TNF->( MsUnLock() )

		TNF->( dbSkip() )
	End

	//-----------------------------------------------------------------
	// Realiza a integração das informações do evento S-2240 ao Governo
	//-----------------------------------------------------------------
	If Len( aFuncs ) > 0 .And. FindFunction( "MDTIntEsoc" )
		MDTEpiS2240( aFuncs )
	EndIf

	aEpiAltEso := {}

	dbSelectArea( "SRA" )
	RestArea( aAreaSRA )
	RestArea( aArea )

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} NG695LinOk
Critica se a linha digitada esta' Ok

@return .T.

@param oGetAux		Object		Objeto derivada da classe MsNewGetDados da TNF

@author Elisangela Costa
@since 29/05/2002
/*/
//---------------------------------------------------------------------
Function NG695LinOk( oGetAux, nTudoOk )

	Local aArea     	:= GetArea()
	Local aParam    	:= {}
	Local aGridAux  	:= fStructEPI()
	Local aColsAux
	Local aHeadAux

	Local bConBio		:= IIf(;
		SuperGetMV( 'MV_BIOMDT', .F., '1' ) == '1',;
		{ || !Empty( TNF->TNF_DIGIT1 ) .And. !Empty( TNF->TNF_DIGIT2 ) },;
		{ || TNF->TNF_ENTBIO == '1' };
	)
	Local bCamLot		:= { || ( nPosLot == 0 .And. !Empty( cLote ) ) .Or. ( nPosLot > 0 .And. aColsTNF[ nPosTNF, nPosLot ] != cLote ) } // TNF_LOTE
	Local bCamSub		:= { || ( nPosSubL == 0 .And. !Empty( cSubLote ) ) .Or. ( nPosSubL > 0 .And. aColsTNF[ nPosTNF, nPosSubL ] != cSubLote ) } // TNF_LOTESB
	Local bCamEnd		:= { || ( nPosEnd == 0 .And. !Empty( cEndLoc ) ) .Or. ( nPosEnd > 0 .And. aColsTNF[ nPosTNF, nPosEnd ] != cEndLoc ) } // TNF_ENDLOC
	Local bCamSer		:= { || ( nPosNSer == 0 .And. !Empty( cNSerie ) ) .Or. ( nPosNSer > 0 .And. aColsTNF[ nPosTNF, nPosNSer ] != cNSerie ) } // TNF_NSERIE

	Local cMsg			:= ""
	Local cEfiEpi		:= ''
	Local cSeekTN3
	Local cMDTInteg 	:= SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local cSeek4TNF

	Local dManu			:= CtoD( '  /  /    ' )
	Local dRecibo		:= CtoD( '  /  /    ' )
	Local dDataBloq 	:= SuperGetMv( "MV_DBLQMOV" ) //Data para bloqueio de movimentos.

	Local lRet      	:= .T.
	Local lLogix		:= cMDTInteg == "2"//Logix
	Local lFound    	:= .F.
	Local lYesNo    	:= .T.
	Local lTudoOk   	:= .F.
	Local lBloEpi		:= SuperGetMv( 'MV_NG2EPIB', .F., '1' ) == '1'
	Local lMsnEpi   	:= .F.
	Local lAlterou  	:= .T.
	Local lDelLine  	:= .F.
	Local lAjsStat  	:= .F.
	Local lBiometria	:= .F.

	Local nX
	Local nAt
	Local nEpi      	:= 0
	Local nIndTN3
	Local nPosEfi		:= 0
	Local nPosTNF
	Local nPosDtRec 	:= 0
	Local nPosDtMan		:= 0

	Default nTudoOk 	:= 0

	lTudoOk := nTudoOk != 0

	If l695Auto

		aColsAut := aClone( aEpiBackup ) // Por algum motivo a função de execução automática altera o array erroneamente
		aCols := fDelUltEle( aCols )

		For nEpi := 1 To Len( aColsAut )
			If aScan( aCols, { | x | x[ 1 ] + x[ 3 ] + x[ 4 ] + x[ 5 ] + DtoS( x[ 6 ] ) + x[ 7 ] == aColsAut[ nEpi, 1 ] + aColsAut[ nEpi, 3 ] + aColsAut[ nEpi, 4 ] + aColsAut[ nEpi, 5 ] + DtoS( aColsAut[ nEpi, 6 ] ) + aColsAut[ nEpi, 7 ] } ) == 0
        		aAdd( aCols, aColsAut[ nEpi ] )
  			EndIf
		Next nEpi

		aColsTNF := aClone( aColsAut )
		aHeaTNF  := aClone( aHeaderAut )
		aColsAux := aCols
		aHeadAux := aClone( aHeader )
		nAt      := n
		lAtuGet  := .T.

	Else
		aColsAux := aGridAux[ _nCols ]
		aHeadAux := aClone( aGridAux[ _nHeader ] )
		nAt      := IIf( lTudoOk, nTudoOk, aGridAux[ _nAt ] )
	EndIf

	If lBloEpi
		lBiometria := Eval( bConBio )
	EndIf

	nPosLeg   	:= GdFieldPos( "COLBMP", aHeadAux )
	nPosEPI   	:= GdFieldPos( "TNF_CODEPI", aHeadAux )
	nPosForn  	:= GdFieldPos( "TNF_FORNEC", aHeadAux )
	nPosLoja  	:= GdFieldPos( "TNF_LOJA", aHeadAux )
	nPosNumC  	:= GdFieldPos( "TNF_NUMCAP", aHeadAux )
	nPosDtEn  	:= GdFieldPos( "TNF_DTENTR", aHeadAux )
	nPosHrEn  	:= GdFieldPos( "TNF_HRENTR", aHeadAux )
	nPosQtde  	:= GdFieldPos( "TNF_QTDENT", aHeadAux )
	nPosLocal 	:= GdFieldPos( "TNF_LOCAL", aHeadAux )
	nPosLcDv  	:= GdFieldPos( "TNF_LOCDV", aHeadAux )
	nPosInDe  	:= GdFieldPos( "TNF_INDDEV", aHeadAux )
	nPosDtDe  	:= GdFieldPos( "TNF_DTDEVO", aHeadAux )
	nPosTipoDv 	:= GdFieldPos( "TNF_TIPODV", aHeadAux )
	nPosQTDDv 	:= GdFieldPos( "TNF_QTDEVO", aHeadAux )
	nPosLot   	:= GdFieldPos( "TNF_LOTECT", aHeadAux )
	nPosSubL  	:= GdFieldPos( "TNF_LOTESB", aHeadAux )
	nPosEnd   	:= GdFieldPos( "TNF_ENDLOC", aHeadAux )
	nPosNSer  	:= GdFieldPos( "TNF_NSERIE", aHeadAux )
	nPosSaiLog 	:= GdFieldPos( "TNF_SAILOG", aHeadAux )
	nPosEntLog	:= GdFieldPos( "TNF_ENTLOG", aHeadAux )
	nPosDtRec	:= GdFieldPos( 'TNF_DTRECI', aHeadAux )
	nPosEfi		:= GdFieldPos( 'TNF_EPIEFI', aHeadAux )
	nPosDtMan	:= GdFieldPos( 'TNF_DTMANU', aHeadAux )

	cCodEPI 	:= aColsAux[ nAt, nPOSEpi ]
	cFornec 	:= aColsAux[ nAt, nPosForn ]
	cLoja		:= aColsAux[ nAt, nPosLoja ]
	cNumCAP 	:= aColsAux[ nAt, nPosNumC ]
	dDtEntr 	:= aColsAux[ nAt, nPosDtEn ]
	cHrEntr 	:= aColsAux[ nAt, nPosHrEn ]
	nQntEntr	:= aColsAux[ nAt, nPosQtde ]
	cLocalEPI	:= IIf( nPosLocal > 0, aColsAux[ nAt, nPosLocal ], "" )
	cIndDevol	:= aColsAux[ nAt, nPosInDe ]
	dDtDevol	:= aColsAux[ nAt, nPosDtDe ]
	cTipDevol	:= IIf( nPosTipoDv > 0, aColsAux[ nAt, nPosTipoDv ], "" )
	nQntDevol	:= aColsAux[ nAt, nPosQTDDv ]
	cLote		:= IIf( nPosLot > 0, aColsAux[ nAt, nPosLot ], "" )
	cSubLote	:= IIf( nPosSubL > 0, aColsAux[ nAt, nPosSubL ], "" )
	cEndLoc		:= IIf( nPosEnd > 0, aColsAux[ nAt, nPosEnd ], "" )
	cNSerie		:= IIf( nPosNSer > 0, aColsAux[ nAt, nPosNSer ], "" )
	cLocDev		:= IIf( nPosLcDv > 0, aColsAux[ nAt, nPosLcDv ], "" )
	cEfiEpi		:= aColsAux[ nAt, nPosEfi ]
	dManu		:= aColsAux[ nAt, nPosDtMan ]
	dRecibo		:= aColsAux[ nAt, nPosDtRec ]

	//Caso for execução automática, indica o EPI que está sendo validado
	If l695Auto
		cMsg := STR0044 + ": " + AllTrim( cCodEPI ) + " / " + STR0146 + ": " + AllTrim( cNumCAP ) + " / " + STR0129 + ": " + AllTrim( cFornec ) + " / " + STR0130 + ": " + AllTrim( cLoja ) + " / " + STR0147 + ": " + DToC( dDtEntr ) + " / " + STR0148 + ": " + cHrEntr + CRLF
	EndIf

	If lSigaMdtps
		cSeek4TNF := xFilial( "TNF" ) + cFornec + cLoja + cCliMdtps + cCodEPI + cNumCAP + SRA->RA_MAT + DToS( dDtEntr ) + cHrEntr
		nIndTN3 := 3  //TN3_FILIAL+TN3_FORNEC+TN3_LOJA+TN3_CLIENT+TN3_LOJACL+TN3_CODEPI+TN3_NUMCAP
		cSeekTN3 := xFilial( "TN3" ) + cFornec + cLoja + cCliMdtps + cCodEPI + cNumCAP
	Else
		cSeek4TNF := xFilial( "TNF" ) + cFornec + cLoja + cCodEPI + cNumCAP + SRA->RA_MAT + DToS( dDtEntr ) + cHrEntr
		nIndTN3 := 1  //TN3_FILIAL+TN3_FORNEC+TN3_LOJA+TN3_CODEPI+TN3_NUMCAP
		cSeekTN3 := xFilial( "TN3" ) + cFornec + cLoja + cCodEPI + cNumCAP
	EndIf

	If lRet .And. !Empty( cCodEPI )

		lAlterou := .T. //Se alterou algum campo da linha
		nPosTNF  := aScan( aColsTNF, { | x | cFornec == x[ nPosForn ] .And. cLoja == x[ nPosLoja ] .And. ;
						 cCodEPI == x[ nPOSEpi ] .And. cNumCAP == x[ nPosNumC ] .And. ;
						 dDtEntr == x[ nPosDtEn ] .And. cHrEntr == x[ nPosHrEn ] } )
		If nPosTNF > 0
			lAlterou := !ArrayCompare( aColsAux[ nAt ], aColsTNF[ nPosTNF ] )
		EndIf

		If !aTail( aColsAux[ nAt ] ) .And. !lTudoOk

			dbSelectArea( "TNF" )
			dbSetOrder( nInd2TNF )
			lInclusao := !dbSeek( cSeek4TNF )

			If Empty( nQntEntr )
				IIf( l695Auto, AutoGrLog( cMsg + STR0015 + AllTrim( NGRETTITULO( "TNF_QTDENT" ) ) + STR0240 + "." ), Help( ' ', 1, STR0020, , STR0015 + AllTrim( NGRETTITULO( "TNF_QTDENT" ) ) + STR0240 + ".", 2, 0, , , , , , { STR0255 + AllTrim( NGRETTITULO( "TNF_QTDENT" ) ) + "." } ) )
				lRet := .F.
			EndIf

			If lRet .And. Empty( cFornec )
				IIf( l695Auto, AutoGrLog( cMsg + STR0015 + AllTrim( NGRETTITULO( "TNF_FORNEC" ) ) + STR0240 + "." ), Help( ' ', 1, STR0020, , STR0015 + AllTrim( NGRETTITULO( "TNF_FORNEC" ) ) + STR0240 + ".", 2, 0, , , , , , { STR0255 + AllTrim( NGRETTITULO( "TNF_FORNEC" ) ) + "." } ) )
				lRet := .F.
			EndIf

			If lRet .And. nQntDevol > nQntEntr
				IIf( l695Auto, AutoGrLog( cMsg + STR0137 ), Help( " ", 1, STR0234, , STR0137, 4, 5 ) ) //"A quantidade devolvida não pode ser maior que a quantidade entregue."
				lRet := .F.
			EndIf

			If nPosTNF == 0 // Se não é uma nova linha, verifica se foi alterado a linha
				//Se linha nova e integração com estoque
				If lRet .And. ( !lLogix .And. cUsaInt1 == "S" ) .And. cIndDevol == "1"
					IIf( l695Auto, AutoGrLog( cMsg + STR0190 ), Help( " ", 1, STR0234, , STR0190, 4, 5 ) ) //"Na inclusão de uma entrega de EPI, não poderá ser informado como EPI Devolvido."
					lRet := .F.
				EndIf
			EndIf

			If lRet .And. lAlterou
				//Data devolucao deve ser preenchida caso campo Ind Devolucao = SIM
				If cIndDevol == "1" .And. Empty( dDtDevol )
					IIf( l695Auto, AutoGrLog( cMsg + STR0112 ), Help( " ", 1, STR0234, , STR0112, 4, 5 ) ) //"O campo Dt. Devoluc. é obrigatório quando informado 'Sim' no campo Devolucao."
					lRet := .F.
				EndIf

				If lRet .And. Type( "lHist695" ) == "L" .And. lHist695 //Se for histórico
					If !fNgDtTNF( dDtEntr, .T. )
						lRet := .F.
					EndIf
				EndIf
			EndIf

			//--------------------------------------------------
			// Se integrado com Estoque e foi alterada a linha
			//--------------------------------------------------
			If lRet .And. lAlterou .And. ( !lLogix .And. cUsaInt1 == "S" )
				//O alerta abaixo irá aparecer caso o campo "Local Almoxarifado" esteja vazio, e haja necessidade de movimentacao de estoque no SD3
				If nPosTNF == 0 //Se o registro é novo

					If nPosLocal > 0 .And. Empty( cLocalEPI )
						IIf( l695Auto, AutoGrLog( cMsg + STR0065 ), Help( " ", 1, STR0234, , STR0065, 4, 5 ) ) //"O campo Local Almox. deve ser informado"
						lRet := .F.
					EndIf

				ElseIf lRet

					If ( nPosLocal > 0 .And. aColsTNF[ nPosTNF, nPosLocal ] != cLocalEPI ) .Or.;  //Local foi alterado
					( nPosTipoDv > 0 .And. aColsTNF[ nPosTNF, nPosTipoDv ] != cTipDevol ) .Or.;  //Repor Estoque foi alterado
					( aColsTNF[nPosTNF, nPosQtde ] != nQntEntr ) .Or.;  //Qtde foi alterada
					( aColsTNF[nPosTNF, nPOSEpi] != cCodEPI ) .Or.;  //Epi foi alterado
					( aColsTNF[nPosTNF, nPosDtEn] != dDtEntr ) .Or.;  //Data da entrega foi alterada
					(;
					cIndDevol == "1" .And. !Empty( dDtDevol ) .And. ;  //Agora o Epi foi devolvido
					( aColsTNF[nPosTNF, nPosInDe ] != "1" .Or. Empty( dDtDevol ) );//Antes o Epi foi requisitado
					) .Or.;
					(;
					( cIndDevol != "1" .Or. Empty( dDtDevol ) ) .And. ;   //Agora o Epi foi requisitado
					( aColsTNF[nPosTNF, nPosInDe ] == "1" .And. !Empty( dDtDevol ) ) ;//Antes o Epi foi devolvido.
					) .Or.;
					( IIf( cUsaRast == "S", aColsTNF[ nPosTNF, nPosLot ] != cLote, .F. ) ) .Or.; //Lote Alterado
					( IIf( cUsaRast == "S", aColsTNF[ nPosTNF, nPosSubL ] != cSubLote, .F. ) ) .Or.; //SubLote Alterado
					( IIf( cUsaLocz == "S", aColsTNF[ nPosTNF, nPosEnd ] != cEndLoc, .F. ) ) .Or.; //Localizacao Alterado
					( IIf( cUsaLocz == "S", aColsTNF[ nPosTNF, nPosNSer ] != cNSerie, .F. ) ) //Num Serie Alterado

						If nPosTipoDv > 0 .And. cIndDevol == "1"
							If Empty( cTipDevol )
								IIf( l695Auto, AutoGrLog( cMsg + STR0110 ), Help( " ", 1, STR0234, , STR0110, 4, 5 ) ) //"O campo Repor Estoque deve ser informado."
								lRet := .F.
							ElseIf nPosLcDv > 0
								If Empty( cLocDev )
									IIf( l695Auto, AutoGrLog( cMsg + STR0239 ), Help( " ", 1, STR0234, , STR0239, 4, 5 ) ) //"O campo Armazém Dev. deve ser informado."
									lRet := .F.
								EndIf
							EndIf
						EndIf

						//Mostra MSG caso Almoxarifado vazio e apenas houve alteracao pela Devolucao Parcial
						If lRet .And. nPosLocal > 0 .And. Empty( cLocalEPI )
							If !( aColsTNF[ nPosTNF, nPosLocal ] == cLocalEPI .And.;  //Local continua vazio
							aColsTNF[nPosTNF, nPosDtEn] == dDtEntr .And.;  //Data da entrega nao foi alterada
							aColsTNF[nPosTNF, nPOSEpi] == cCodEPI .And.;  //Epi nao foi alterado
							aColsTNF[nPosTNF, nPosQtde ] == nQntEntr .And.;  //Qtde nao foi alterada
							(;
							(cIndDevol == "1" .And. aColsTNF[nPosTNF, nPosInDe ] != "1") .Or.;
							(cIndDevol != "1" .And. aColsTNF[nPosTNF, nPosInDe ] == "1");
							) .And. MDTTLWEDIT( 1 );
							)
								IIf( l695Auto, AutoGrLog( cMsg + STR0065 ), Help( " ", 1, STR0234, , STR0065, 4, 5 ) ) //"Aviso"//"O campo Local Almox. deve ser informado"
								lRet := .F.
							EndIf
						EndIf
					EndIf
				EndIf

				If lRet .And. lAlterou .And. nPosTNF > 0
					lExistLin := .T.
					lQntMaior := .F.
					lQntIgual := .F.
					lAuxTpDv  := .F.
					lAuxSB2   := .F.
					lDevRet   := .F.
					lDevRepor := .F.

					//--------------------------------------------------------------------------------------------
					// Carrega variaveis auxiliares para analisar as validações conforme suas alterações na linha
					//--------------------------------------------------------------------------------------------

					//---------------------------------------------------
					// Prefixo lQnt verifica se foi alterado (para Maior)
					// ou mantido (Igual) a quantidade entregue
					//---------------------------------------------------
					If nQntEntr > aColsTNF[ nPosTNF, nPosQtde ]
						lQntMaior := .T.
					ElseIf nQntEntr == aColsTNF[ nPosTNF, nPosQtde ]
						lQntIgual:= .T.
					EndIf
					//-------------------------------------------------------
					// lAuxSB2 validará quando for alterado o local do EPI ou
					// Se usa controle de rastreio, sendo alterado Lote ou o SubLote ou
					// Se usa controle de localização fisica,sendo alterado a localizacao ou o número de série
					//-------------------------------------------------------
					If nPosLocal > 0 .And. cLocalEPI != aColsTNF[nPosTNF, nPosLocal ]
						lAuxSB2 := .T.
					Else
						If cUsaRast == "S"
							lAuxSB2 := cLote != aColsTNF[ nPosTNF, nPosLot ] .Or. cSubLote != aColsTNF[ nPosTNF, nPosSubL ]

						EndIf

						If cUsaLocz == "S"
							lAuxSB2 := cEndLoc != aColsTNF[nPosTNF, nPosEnd ] .Or. cNSerie != aColsTNF[ nPosTNF, nPosNSer ]

						EndIf
					EndIf
					//-----------------------------------------------
					// Se Status do EPI foi de Usado para Devolvido
					//-----------------------------------------------
					lDevRet := cIndDevol == "2" .And. aColsTNF[nPosTNF, nPosInDe ] == "1"

					If nPosTipoDv > 0
						//Se Devolucao = S e Repor Estoque = S
						If cIndDevol == "1" .And. cTipDevol == "1"
							//----------------------------------------------
							// Se houve alteração n para Repor o Estoque ou
							// na data de devolução
							//----------------------------------------------
							lAuxTpDv := cTipDevol != aColsTNF[nPosTNF, nPosTipoDv ] .Or. dDtDevol != aColsTNF[ nPosTNF, nPosDtDe ]
						EndIf
						// Se esta como devolvido e foi alterado para Reportar Estoque
						// Então indica que deverá reportar
						lDevRepor := cIndDevol == "1" .And. ( cTipDevol == "2" .And. aColsTNF[nPosTNF, nPosTipoDv ] == "1" )
					EndIf
					//---------------------------
					// Inicia a analise da linha
					//---------------------------
					If nPosTNF == 0
						lExistLin := .T.
					Else
						If aColsTNF[ nPosTNF, nPosQTDDv ] > 0 .Or. nQntDevol > 0
							If lRet .And. nQntEntr != aColsTNF[ nPosTNF, nPosQtde ]
								IIf( l695Auto, AutoGrLog( cMsg + STR0138 ), Help( " ", 1, STR0234, , STR0138, 4, 5 ) ) //"A Quantidade Entregue não poderá ser alterada, caso o Epi já foi devolvido totalmente ou parcialmente."
								lRet := .F.
							EndIf
							If lRet .And. !Empty( aColsTNF[nPosTNF, nPosLocal ] ) .And. lAuxSB2
								IIf( l695Auto, AutoGrLog( cMsg + STR0139 ), Help( " ", 1, STR0234, , STR0139, 4, 5 ) ) //"O Almoxarifado não poderá ser alterado, caso o Epi já foi devolvido totalmente ou parcialmente."
								lRet := .F.
							EndIf
							If lRet .And. cUsaLocz == "S"
								If !Empty( AllTrim( aColsTNF[nPosTNF, nPosEnd ] ) ) .And. cEndLoc != aColsTNF[nPosTNF, nPosEnd ]
									IIf( l695Auto, AutoGrLog( cMsg + STR0173 ), Help( " ", 1, STR0234, , STR0173, 4, 5 ) ) //"A Localização não poderá ser alterado, caso o Epi já foi devolvido totalmente ou parcialmente."
									lRet := .F.
								EndIf
								If lRet .And. !Empty( AllTrim( aColsTNF[ nPosTNF, nPosNSer ] ) ) .And. cNSerie != aColsTNF[ nPosTNF, nPosNSer ]
									IIf( l695Auto, AutoGrLog( cMsg + STR0174 ), Help( " ", 1, STR0234, , STR0174, 4, 5 ) ) //"O Num. de Série não poderá ser alterado, caso o Epi já foi devolvido totalmente ou parcialmente."
									lRet := .F.
								EndIf
							EndIf
						EndIf
					EndIf

					cTmpLote := IIf( cUsaRast == "S", cLote, "" )
					cTmpSubL := IIf( cUsaRast == "S", cSubLote, "" )
					cTmpLocz := IIf( cUsaLocz == "S", cEndLoc, "" )
					cTmpNSer := IIf( cUsaLocz == "S", cNSerie, "" )

					If lRet .And. ( lInclusao .Or. lExistLin .Or. !lQntIgual .Or. lAuxSB2 .Or. lDevRet )

						If lRet .And. ( lInclusao .Or. lExistLin .Or. lQntMaior .Or. lAuxSB2 .Or. lDevRet )
							If cIndDevol != "1"
								If !lESTNEGA
									nQtClass   := NGSeek( "SB2", cCodEPI + cLocalEPI, 1, "SB2->B2_QACLASS" )
									nQtClass   := IIf( ValType( nQtClass ) == "N", nQtClass, 0 )
									nAcumulado := A695RTACUM( 4, cCodEPI, cLocalEPI, , , , )
									If nAcumulado > 0
										If !NGSALSB2( cCodEPI, cLocalEPI, nAcumulado, , nQtClass, , IsInCallStack( "MDTA410" ) )
											lRet := .F.
										EndIf
									EndIf
								EndIf
							EndIf

							If lRet .And. ( cUsaRast == "S" .Or. cUsaLocz == "S" )
								If !MdtSldSBF( cCodEPI, cLocalEPI, cTmpLote, cTmpSubL, cTmpLocz, cTmpNSer,;
											 IIf( cIndDevol != "1", nQntEntr, Nil ), .T., dDtEntr )
									lRet := .F.
								EndIf
							EndIf

						EndIf
					EndIf

					If (lAuxSB2 .And. cIndDevol == "1") .Or. ( nPosTNF > 0 .And.;
					( ( cIndDevol == "1" .And. aColsTNF[nPosTNF, nPosInDe ] != "1" ) .Or. ( nQntDevol != aColsTNF[nPosTNF, nPosQTDDv ] ) ) )

						If cUsaRast == "S" .And. Rastro( cCodEPI )
							If lRet .And. !Empty( cTmpSubL )
								nAcumulado := A695RTACUM( 1, cCodEPI, cLocalEPI, cTmpLote, cTmpSubL, , , .F. )
								dbSelectArea( "SB8" )
								dbSetOrder( 02 )
								If dbSeek( xFilial( "SB8" ) + cTmpSubL ) .And. cTmpLote + cCodEPI +;
									 cLocalEPI == SB8->B8_LOTECTL + SB8->B8_PRODUTO + SB8->B8_LOCAL
									If QtdComp( SB8SALDO( , , , , , , , , .T. ) + nAcumulado ) > QtdComp( SB8->B8_QTDORI )
										Help( " ", 1, "A240LOTQTD" ) //A quantidade da devolução somada ao saldo do lote ultrapassa a quantidade original o mesmo.
										lRet := .F.					 //Digite uma quantidade que somada ao saldo do lote seja no máximo a quantidade original deste
									EndIf
								EndIf
							Else
								nAcumulado := A695RTACUM( 2, cCodEPI, cLocalEPI, cTmpLote, , , , .F. )
								dbSelectArea( "SB8" )
								dbSetOrder( 03 )
								If lRet .And. dbSeek( xFilial( "SB8" ) + cCodEPI + cLocalEPI + cTmpLote )
									If QtdComp( SB8SALDO( , , , , , , , , .T. ) + nAcumulado ) > QtdComp( SB8->B8_QTDORI )
										Help( " ", 1, "A240LOTQTD" ) //A quantidade da devolução somada ao saldo do lote ultrapassa a quantidade original o mesmo.
										lRet := .F.					 //Digite uma quantidade que somada ao saldo do lote seja no máximo a quantidade original deste
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf

					//Verifica se a data entrega do equipamento foi informada depois do parametro MV_ULMES
					If lRet .And. ( lInclusao .Or. lExistLin .Or. !lQntIgual .Or. lAuxSB2 .Or. lDevRet .Or. lDevRepor )
						If cIndDevol == "1" .And. !lDevRepor
							If !fDataDvTNF( dDtDevol, .T. )
								lRet := .F.
							EndIf
						Else
							If nPosTNF == 0 .And. !fNgDtTNF( dDtEntr, .T., , lDevRepor )
								lRet := .F.
							EndIf
						EndIf
					ElseIf lAuxTpDv //Repor Estoque = S - houve alteração de data ou antes Repor Estoque = N
						If !fDataDvTNF( dDtDevol, .T. )
							lRet := .F.
						EndIf
					EndIf
				EndIf
			EndIf

			If lRet .And. dDtDevol > dDatabase
				IIf( l695Auto, AutoGrLog( cMsg + STR0113 ), Help( " ", 1, STR0234, , STR0113, 4, 5 ) ) //"Data da devolução não poderá ser superior à data atual"
				lRet := .F.
			EndIf

			If lRet
				For nX := 1 To Len( aColsAux )
					If nX != nAt .And. !aTail( aColsAux[nAt] ) .And. !aTail( aColsAux[nx] )

						If !Empty( cCodEPI ) .And. aColsAux[nX, nPOSEpi] == cCodEpi .And. aColsAux[nX, nPosDtEn] == dDtEntr .And.;
							aColsAux[nX, nPosHrEn] == cHrEntr .And. aColsAux[nX, nPosForn] == cFornec .And.;
						 	aColsAux[nX, nPosLoja] == cLoja .And. aColsAux[nX, nPosNumC] == cNumCAP

							lRet := .F.
							IIf( l695Auto, AutoGrLog( cMsg + "JAEXISTINF" ), Help( " ", 1, "JAEXISTINF" ) )
							Exit
						EndIf
						If lRet .And. !l695Auto .And. nPosTNF == 0 .And. ;//Caso rotina automatica, não pergunta.
						aColsAux[ nx, nPOSEpi ] == cCodEPI .And.;
						aColsAux[ nx, nPosDtEn] == dDtEntr .And.;
						aColsAux[ nx, nPosInDe ] != "1" .And. cIndDevol != "1"

							lRet := MsgYesNo( STR0209 )  //"Este EPI já foi entregue hoje para este funcionário. Deseja confirmar a entrega?"

							If lRet
								Exit
							EndIf
						EndIf
					EndIf
				Next nX
			EndIf

			If lRet .And. Type( "lHist695" ) == "L" .And. !lHist695 //Se não for histórico
				dbSelectArea( "TN3" )
				dbSetOrder( nIndTN3 )
				If lAlterou .And. dbSeek( cSeekTN3 ) .And. !aTail( aColsAux[ nAt ] )

					If !Empty( dDtEntr ) .And. !Empty( TN3->TN3_DTVENC ) .And.;
						dDtEntr > TN3->TN3_DTVENC .And. aColsAux[ nAt, nPosInDe ] != '1'
						// 2-Não entrega EPI Vencido
						If nOpcVenc == 2 .Or. ( l695Auto .And. nOpcVenc == 3 )

							IIf( l695Auto, ;
								AutoGrLog( cMsg + STR0022 + CRLF + STR0024 + DToC( TN3->TN3_DTVENC ) + CRLF + STR0025 + DToC( dDtEntr ) ), ;
								Help( " ", 1, STR0026, , STR0022 ; //"A data de entrega do Epi está ultrapassando a data de vencimento."
								+ CRLF + STR0024 + DToC( TN3->TN3_DTVENC ) ; //"Data de Vencimento: "
								+ CRLF + STR0025 + DToC( dDtEntr ), 4, 5 ) ) //"Data de Entrega: "###"ATENCAO"
							lRet := .F.

							// 3-Pergunta se entrega EPI Vencido
						ElseIf nOpcVenc == 3

							If !MsgYesNo( STR0022 + CRLF + ; //"A data de entrega do Epi está ultrapassando a data de vencimento."
							STR0023 + CRLF + CRLF +; //"Confirma a entrega do Epi?"
							STR0024 + DToC( TN3->TN3_DTVENC ) + CRLF + ; //"Data de Vencimento: "
							STR0025 + DToC( dDtEntr ), STR0026 ) //"Data de Entrega: "###"ATENCAO"
								lRet := .F.

							EndIf
						EndIf
					EndIf
				EndIf

			EndIf

			If lBloEpi .And. lRet .And. l695Auto .And. ( !Empty( dRecibo ) .Or. lBiometria )

				If !lInclusao .And. lAlterou

					// (*) Testar a validação desses campos posteriormente e separar a validação
					Do Case
						Case aColsTNF[ nPosTNF, nPosQtde ] != nQntEntr // TNF_QTDENT
							lRet := .F.
						Case ( nPosLocal == 0 .And. !Empty( cLocalEPI ) );
						.Or. ( nPosLocal > 0 .And. aColsTNF[ nPosTNF, nPosLocal ] != cLocalEPI ) // TNF_LOCAL
							lRet := .F.
						Case ( nPosEfi == 0 .And. !Empty( cEfiEpi ) );
						.Or. ( nPosEfi > 0 .And. aColsTNF[ nPosTNF, nPosEfi ] != cEfiEpi ) // TNF_EPIEFI
							lRet := .F.
						Case ( nPosDtMan == 0 .And. !Empty( dManu ) );
						.Or. ( nPosDtMan > 0 .And. aColsTNF[ nPosTNF, nPosDtMan ] != dManu ) // TNF_DTMANU
							lRet := .F.
						Case Eval( bCamLot ) .Or. Eval( bCamSub ) .Or. Eval( bCamEnd ) .Or. Eval( bCamSer ) // TNF_LOTECT // TNF_LOTESB* // TNF_ENDLOC* // TNF_NSERIE*
							lRet := .F.
					EndCase

					If !lRet
						AutoGrLog( cMsg + STR0238 ) // "Não é possível alterar este EPI, pois já foi entregue. Permitida apenas devolução."
					EndIf

				EndIf

				If lRet .And. nQntDevol > 0 .And. nQntEntr > nQntDevol

					Do Case
						Case lInclusao
							AutoGrLog( cMsg + STR0191 ) // "Durante a inclusão de uma entrega de EPI, não é possível registrar devolução parcial."
							lRet := .F.
						Case cIndDevol == '1'
							AutoGrLog( cMsg + STR0266 ) // "Para devolução parcial, o campo Situação EPI (TNF_INDDEV) deve estar definido como 2 - EPI em uso."
							lRet := .F.
						Case Empty( dRecibo )
							AutoGrLog( cMsg + STR0246 ) // "Para prosseguir com a devolução parcial, imprima antes o recibo de entrega de EPI."
							lRet := .F.
					EndCase

				EndIf

			EndIf

			RestArea( aArea )

			If ExistBlock( "MDTA6958" )

				aParam := { nPosChv, aChvTNF, nPosTNF, cCodEPI, dDtEntr, cHrEntr, cIndDevol, aCols, aCOLStnf, nPOSEpi, nPosDtEn, nPosHrEn, lFound, lRET, l695Auto, cUsaInt1,;
						 dDataBloq, dDtDevol, nQntDevol, nQntEntr, oGetAux } //Parâmetros necessários no ponto de entrada.

				aCols := ExecBlock( "MDTA6958", .F., .F., aParam ) //Acols atual recebe valor do ponto de entrada.

				If !l695Auto //Atualiza o Browser
					If ValType( oGetAux:oBrowse ) == "O"
						oGetAux:oBrowse:nAt	:= n
						oGetAux:oBrowse:Refresh()
						oGetAux:oBrowse:SetFocus()
					ElseIf ValType( oGetAux ) == "O"
						oGetAux:nAt	:= n
						oGetAux:Refresh()
						oGetAux:SetFocus()
					EndIf
				EndIf

			Else

				nPosChv := aScan( aChvTNF, {|x| x == cCodEpi + DToS( dDtEntr ) + cHrEntr } )
				If lRet .And. nPosChv == 0 .And. nPosTNF == 0 .And. cIndDevol == "2" .And. !lMdtGerSA
					aAdd( aChvTNF, cCodEpi + DToS( dDtEntr ) + cHrEntr )
					For nX := 1 To Len( aColsAux )
						If nx != nAt .And. !( aTail( aColsAux[nX] ) .And. aTail( aColsAux[ nAt ] ) ) // .And. lRET

							nPosAnt := aScan( aColsTNF, { | x | aColsAux[ nx, nPOSEpi ] == x[ nPOSEpi ] .And. aColsAux[ nx, nPosDtEn ] == x[ nPosDtEn ] .And.;
											 aColsAux[ nx, nPosHrEn ] == x[ nPosHrEn ] } )

							dbSelectArea( "TNF" )
							dbSetOrder( 3 )
							//Se o EPI for o mesmo que está sendo entregue, estiver em uso e tiver data de impressão do recibo
							If nPosAnt > 0 .And. aColsAux[nX, nPOSEpi] == cCodEPI .And. aColsAux[nX, nPosInDe ] == "2" .And.;
								IIf(dbSeek( xFilial( "TNF" ) + SRA->RA_MAT + aColsAux[nX, nPosEPI] + DToS( aColsAux[nX, nPosDtEn] ) +;
									 aColsAux[nX, nPosHrEn] ), !Empty( TNF->TNF_DTRECI ), .T. )

								If !l695Auto .And. !lMsnEpi
									lMsnEpi	:= .T.
									If NGSEEK( "TN3", aCols[ n, nPosForn ] + aCols[ n, nPosLoja ] + aCols[ n, nPosEPI  ] + aCols[ n, nPosNumC ], 1, "TN3_INDEVO" ) != "2"
										lYesNo:= MsgYesNo( STR0195 + CRLF + STR0196 ) //"Este funcionário já possui um EPI do mesmo tipo."##"Deseja alterar o status do EPI anterior para 'Devolvido'?"
										If !l695Auto  .And. lYesNo
											If cUsaInt1 == "S" .And. ( dDtEntr <= dDataBloq .And.;
											!Empty( aColsAux[ nX, nPosDtEn ] ) .And.;
											Empty( aColsAux[ nX, nPosDtDe ] ) ) .Or.;
											( aColsAux[ nX, nPosDtDe ] <= dDataBloq .And.;
											!Empty( aColsAux[ nX, nPosDtDe ] ) )
												ShowHelpDlg( STR0020, { STR0241 }, 1,; //ATENÇÃO //"A data informado está bloqueada para movimentos."
												 { STR0242 }, 2 ) //"Favor verificar o parâmetro MV_DBLQMOV."
												lRET := .F.
											Else
												If Empty( aColsAux[ nx, nPosDtDe ] )
													aColsAux[ nx, nPosLeg ] := "BR_VERMELHO" //Altera para vermelho
													aColsAux[ nx, nPosDtDe ] := dDtEntr //Preenche data de entrega
												EndIf
												aColsAux[ nx, nPosInDe ] := "1"
												aColsAux[ nx, nPosQTDDv ] := aColsAux[ nx, nPosQtde ]
												If !l695Auto
													If ValType( oGetAux:oBrowse ) == "O"
														lAjsStat := .T.
														oGetAux:oBrowse:nAt := nX
														oGetAux:oBrowse:Refresh()
														oGetAux:oBrowse:SetFocus()
													ElseIf ValType( oGetAux ) == "O"
														lAjsStat := .T.
														oGetAux:nAt := nX
														oGetAux:Refresh()
														oGetAux:SetFocus()
													EndIf
												EndIf
											EndIf
										EndIf
									EndIf
								EndIf
							EndIf
						EndIf
					Next
				EndIf
			EndIf
		EndIf

		//Se for integração Logix
		If lRet .And. lLogix

			dbSelectArea( "SB1" )
			dbSetOrder( 1 )
			dbSeek( xFilial( "SB1" ) + cCodEPI )

			//Campo CC
			If !Empty( TNF->TNF_MAT ) .And. FindFunction( "MDTCCFunc" )
				cCCSCP := MDTCCFunc( TNF->TNF_MAT, SRA->RA_CC, dDtEntr )
			Else
				cCCSCP := SRA->RA_CC
			EndIf

			//Campo Observação
			If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
				cObsSCP	:= SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
			Else
				cObsSCP	:= STR0166 + ": " + SRA->RA_FILIAL + "-" + SRA->RA_MAT //"FUNCIONARIO"
			EndIf
			nOcpx := IIf( Empty( aColsAux[ nAt, nPosEntLog ] ), 3, IIf( lDelLine, 5, 4 ) )

			//----------------------------------------------------------------
			//Função de Execução automatica
			//----------------------------------------------------------------
			dbSelectArea( "SCP" )
			RegToMemory( "SCP", .T. )
			M->CP_PRODUTO := cCodEPI
			M->CP_UM      := SB1->B1_UM
			M->CP_QUANT   := nQntEntr
			M->CP_DATPRF  := dDtEntr
			M->CP_LOCAL   := cLocalEPI
			M->CP_CC      := IIf( FindFunction( "MDTCCFunc" ), MDTCCFunc( SRA->RA_MAT, SRA->RA_CC, dDtEntr ), SRA->RA_CC )
			M->CP_EMISSAO := dDataBase
			M->CP_DESCRI  := SB1->B1_DESC
			M->CP_SOLICIT := cUserName
			M->CP_OBS     := STR0166 + ": " + SRA->RA_FILIAL + "-" + SRA->RA_MAT //"FUNCIONARIO"
			If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
				M->CP_OBS := SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
			EndIf
			If !lRet
				Return .F.
			EndIf
			nPosTNF     := aScan( aColsTNF, { | x | cFornec == x[ nPosForn ] .And. cLoja == x[ nPosLoja ] .And. ;
								cCodEPI == x[ nPOSEpi ] .And. cNumCAP == x[ nPosNumC ] .And. ;
								dDtEntr == x[ nPosDtEn ] .And. cHrEntr == x[ nPosHrEn ] } )
			cMDTSerie   := ""
			cMdtStatus  := ""
			cMdtReserva := ""
			lDelLine    := aTail( aColsAux[ nAt ] )

			//----------------------
			// Simulação de Entrada
			//----------------------
			If ( lDelLine .And. !Empty( aColsAux[ nA, nPosEntLog ] ) ) .Or.; // Houve exclusão com Código de Entrada Logix /
			( !lDelLine .And. nPosTNF > 0 .And. lAlterou .And. ;// Houve alteração de uma linha já existente
			( ( nQntDevol == nQntEntr .And. cIndDevol != "1" .And. aColsTNF[ nPosTNF, nPosInDe ] == "1" ) );
			)

				cMDTSerie := "SIMULENT"
				nOperacao := IIf( Empty( aColsAux[ nAt, nPosEntLog ] ), 3, IIf( lDelLine, 5, 4 ) )
				cMDTNumRes:= aColsAux[ nAt, nPosEntLog ]
				lRet := NGMUReques( , "SCP", .T., nOperacao )
			EndIf

			//--------------------
			// Simulação de Saída
			//--------------------
			If lRet .And. ( ( !lDelLine .And. ( nPosTNF == 0 .Or. lAlterou ) .And.;
			( cIndDevol $ "2|3"  ) ) .Or. ( lDelLine .And. !Empty( aColsAux[ nAt, nPosSaiLog ] ) ) )

				cMDTSerie := "SIMULSAI"
				nOperacao := IIf( Empty( aColsAux[ nAt, nPosSaiLog ] ), 3, IIf( lDelLine, 5, 4 ) )
				cMDTNumRes:= IIf( nOperacao != 3, aColsAux[ nAt, nPosSaiLog ], "" )
				lRet := NGMUReques( , "SCP", .T., nOperacao )
			EndIf

			If !lTudoOk .And. !Empty( M->CP_PRODUTO ) .And. !Empty( cMdtStatus )
				If cMdtStatus == "1" // 1  Verde  Solicitação atendida onde a reserva de estoque foi baixada.
					aColsAux[ nAt, nPosLeg ] := "BR_VERDE"
				ElseIf cMdtStatus == "2"// 2  Amarela  Solicitação não atendida com estoque e sem solicitação de compra pendente.
					aColsAux[ nAt, nPosLeg ] := "BR_AMARELO"
				ElseIf cMdtStatus == "3"// 3  Laranja  Solicitação não atendida sem estoque e com solicitação de compra pendente.
					aColsAux[ nAt, nPosLeg ] := "BR_LARANJA"
				ElseIf cMdtStatus == "4"// 4  Amarela  Solicitação não atendida com estoque e com o recebimento da solicitação de compra pendente.
					aColsAux[ nAt, nPosLeg ] := "BR_AMARELO"
				ElseIf cMdtStatus == "5"// 5  Vermelho  Solicitação de devolução ao estoque atendida.
					aColsAux[ nAt, nPosLeg ] := "BR_VERMELHO"
				ElseIf cMdtStatus == "6"// 6  Azul  Solicitação de devolução ao estoque não atendida.
					aColsAux[ nAt, nPosLeg ] := "BR_AZUL"
				EndIf
			EndIf

			RegToMemory( "SCP", .T. )
		EndIf

	Else

		If !l695Auto
			cMsg := ""
		EndIf

		Help( Nil, Nil, STR0234, Nil, cMsg + STR0015 + STR0087 + STR0240, 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0255 } )
		lRet := .F.

	EndIf

	If !l695Auto
		PutFileInEof( "TNF" )
	EndIf

	//P.O.G. - Caso haja alteração de Status, não permite a GetDados
	//criar uma nova linha para não se perder no posicionamento
	If lAjsStat
		lRet := .F.
	EndIf

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} NG695TudOk
Critica se a nota toda esta' Ok

@return lRet	Boolean	Retorno .F. caso houver alguma discordância

@param

@author Elisangela Costa
@since 29/05/2002
/*/
//---------------------------------------------------------------------
Function NG695TudOk()

	Local aGridAux
	Local aColsAux

	Local cDev := ''
	Local cReq := ''
	Local cMsg := ''
	Local cLote := ''
	Local cNSerie := ''
	Local cSubLote := ''
	Local cEnderec := ''
	Local lExist695VL := ExistBlock( "MDT695VL" )

	Local nX, nAt, nPosEpiEfi
	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )

	Local lRet := .T.
	Local lLogix := cMDTInteg == "2"//Logix
	Local lAlterou := .F.

	Private aEpiEso := {}

	Default cUsaInt1 := SuperGetMv( 'MV_NGMDTES', .F., 'N' )
	Default cUsaInt2 := SuperGetMv( 'MV_NG2SA', .F., 'N' )

	aGridAux	:= fStructEPI()
	aColsAux	:= aGridAux[ _nCols ]
	nAt			:= aGridAux[ _nAt ]
	aColsNaoDel := {} // Limpa o Array para considerar certo mesmo com multiplas entregas sem fechar a rotina

	nPosEPI		:= GdFieldPos( "TNF_CODEPI", aGridAux[ _nHeader ] )
	nPosQtde	:= GdFieldPos( "TNF_QTDENT", aGridAux[ _nHeader ] )
	nPosDtEn	:= GdFieldPos( "TNF_DTENTR", aGridAux[ _nHeader ] )
	nPosHrEn	:= GdFieldPos( "TNF_HRENTR", aGridAux[ _nHeader ] )
	nPosLocal	:= GdFieldPos( "TNF_LOCAL", aGridAux[ _nHeader ] )
	nPosInDe	:= GdFieldPos( "TNF_INDDEV", aGridAux[ _nHeader ] )
	nPosDtDe	:= GdFieldPos( "TNF_DTDEVO", aGridAux[ _nHeader ] )
	nPosForn	:= GdFieldPos( "TNF_FORNEC", aGridAux[ _nHeader ] )
	nPosLoja	:= GdFieldPos( "TNF_LOJA", aGridAux[ _nHeader ] )
	nPosNumC	:= GdFieldPos( "TNF_NUMCAP", aGridAux[ _nHeader ] )
	nPosTipoDv	:= GdFieldPos( "TNF_TIPODV", aGridAux[ _nHeader ] )
	nPosQTDDv	:= GdFieldPos( "TNF_QTDEVO", aGridAux[ _nHeader ] )

	nPosLot		:= GdFieldPos( "TNF_LOTECT", aGridAux[ _nHeader ] )
	nPosSubL	:= GdFieldPos( "TNF_LOTESB", aGridAux[ _nHeader ] )
	nPosEnd		:= GdFieldPos( "TNF_ENDLOC", aGridAux[ _nHeader ] )
	nPosNSer	:= GdFieldPos( "TNF_NSERIE", aGridAux[ _nHeader ] )
	nPosEpiEfi  := GdFieldPos( "TNF_EPIEFI", aGridAux[ _nHeader ] )

	If l695Auto //Caso seja rotina automatica carrega novamente as posições dos campos.
		// Verifica se a get dados já foi atualizada
		If !lAtuGet
			aEval( aColsAut, { |x| aAdd( aCols, x ) } )
			aColsTNF := aClone( aColsAut )
			aHeaTNF  := aClone( aHeaderAut )
		EndIf
	EndIf

	If lRet .And. cUsaInt1 == 'S' .And. cUsaInt2 == 'N' // Integração com o estoque habilitada de forma automática via execauto

		cDev := SuperGetMv( 'MV_NG2D3DE', .F., '' )
		cReq := SuperGetMv( 'MV_NG2D3RE', .F., '' )

		If Empty( cDev ) .Or. cDev == '499'

			IIf( l695Auto, AutoGrLog( 'MV_NG2D3DE' + CRLF + STR0261 + Space( 1 ) + '(499)' ), Help( Nil, Nil, 'MV_NG2D3DE', Nil, STR0261 + Space( 1 ) + '(499)', 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0262 } ) )
			lRet := .F.

		EndIf

		If ( Empty( cReq ) .Or. cReq == '999' )

			IIf( l695Auto, AutoGrLog( 'MV_NG2D3RE' + CRLF + STR0261 + Space( 1 ) + '(999)' ), Help( Nil, Nil, 'MV_NG2D3RE', Nil, STR0261 + Space( 1 ) + '(999)', 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0263 } ) )
			lRet := .F.

		EndIf

	EndIf

	If lRet

		aColsAux := fDelUltEle( aColsAux )

		For nX := 1 to Len( aColsAux )

			//Caso for execução automática, indica o EPI que está sendo validado
			If l695Auto
				cMsg := STR0044 + ": " + AllTrim( aColsAux[ nX, nPosEPI ] ) + " / " + STR0146 + ": " + AllTrim( aColsAux[ nX, nPosNumC ] ) + " / " + STR0129 + ": " + AllTrim( aColsAux[ nX, nPosForn ] ) + " / " + STR0130 + ": " + AllTrim( aColsAux[ nX, nPosLoja ] ) + " / " + STR0147 + ": " + DToC( aColsAux[ nX, nPosDtEn ] ) + " / " + STR0148 + ": " + aColsAux[ nX, nPosHrEn ] + CRLF
			EndIf

			If lRet .And. lLogix .And. !l695Auto .And. ( nAt != nX .Or. aTail( aColsAux[ nX ] ) )
				lRet := NG695LinOk( , nX )
			EndIf

			If lRet .And. !aTail( aColsAux[ nX ] )

				nPosTNF  := aScan( aColsTNF, {|x| aColsAux[ nX, nPosForn] == x[nPosForn] .And. ; //Fornecedor
								 aColsAux[ nX, nPosLoja] == x[nPosLoja] .And. ; //Loja
								 aColsAux[ nX, nPOSEpi ] == x[nPOSEpi]  .And. ; //Epi
								 aColsAux[ nX, nPosNumC] == x[nPosNumC] .And. ; //Num CA
								 aColsAux[ nX, nPosDtEn] == x[nPosDtEn] .And. ; //Data Entrega
								 aColsAux[ nX, nPosHrEn] == x[nPosHrEn] } ) //Hora Entrega

				lAlterou := .T. //Se alterou algum campo da linha

				If nPosTNF > 0
					lAlterou := !ArrayCompare( aColsAux[ nX ], aColsTNF[ nPosTNF ] )
				EndIf

				If lRet .And. cUsaInt1 == "S"
					lInclusao := .T.
					lExistLin := .F.
					lQntMaior := .F.
					lQntIgual := .F.
					lAuxSB2   := .F.
					dbSelectArea( "TNF" )
					dbSetOrder( nInd2TNF )
					If dbSeek( xFilial( "TNF" ) + aColsAux[ nX, nPosForn ] + aColsAux[ nX, nPosLoja ] + IIf( lSigaMdtps, cCliMdtps, "" ) +;
							 aColsAux[ nX, nPOSEpi ] + aColsAux[ nX, nPosNumC ] + SRA->RA_MAT + DToS( aColsAux[nX, nPosDtEn] )+;
							 aColsAux[ nX, nPosHrEn] )
						lInclusao := .F.
					EndIf

					If nPosTNF == 0
						lExistLin := .T.
					Else
						If aColsAux[ nX, nPosQtde ] > aColsTNF[ nPosTNF, nPosQtde ]
							lQntMaior := .T.
						ElseIf aColsAux[ nX, nPosQtde ] == aColsTNF[ nPosTNF, nPosQtde ]
							lQntIgual := .T.
						EndIf

						If nPosLocal > 0
							If aColsAux[ nX, nPosLocal ] != aColsTNF[ nPosTNF, nPosLocal ]
								lAuxSB2 := .T.
							Else
								If cUsaRast == "S"

									If aColsAux[ nX, nPosLot ] != aColsTNF[ nPosTNF, nPosLot ] .Or. aColsAux[ nX, nPosSubL ] != aColsTNF[ nPosTNF, nPosSubL ]
										lAuxSB2 := .T.
									EndIf

								EndIf
								If cUsaLocz == "S"

									If aColsAux[nX, nPosEnd ] != aColsTNF[nPosTNF, nPosEnd ] .Or. aColsAux[ nX, nPosNSer ] != aColsTNF[ nPosTNF, nPosNSer ]
										lAuxSB2 := .T.
									EndIf

								EndIf
							EndIf
						EndIf

					EndIf

					If lInclusao .Or. lExistLin .Or. lQntIgual .Or. lAuxSB2
						If lAlterou
							If (lInclusao .Or. lExistLin .Or. lQntMaior .Or. lAuxSB2) .And. aColsAux[nX, nPosInDe ] != "1"

								If lRet .And. !lESTNEGA
									nQtClass := NGSEEK( "SB2", aColsAux[ nX, nPOSEpi ] + aCols[ nX, nPosLocal ], 1, "SB2->B2_QACLASS" )
									nQtClass := IIf( ValType( nQtClass ) == "N", nQtClass, 0 )
									cLote 		:= ""
									cSubLote	:= ""
									cEnderec 	:= ""
									cNSerie 	:= ""
									If cUsaLocz == "S"
										cEnderec	:= aColsAux[ nX, nPosEnd ]
										cNSerie		:= aColsAux[ nX, nPosNSer ]
									EndIf
									If cUsaRast == "S"
										cLote 		:= aColsAux[ nX, nPosLot ]
										cSubLote	:= aColsAux[ nX, nPosSubL ]
									EndIf
									nAcumulado := A695RTACUM( 4, aColsAux[ nX, nPOSEpi ], aColsAux[ nX, nPosLocal ], cLote, cSubLote, cEnderec, cNSerie )
									If nAcumulado > 0
										If !NGSALSB2( aColsAux[ nX, nPOSEpi ], aColsAux[ nX, nPosLocal ], nAcumulado, , nQtClass, , IsInCallStack( "MDTA410" ) )
											IIf( l695Auto, AutoGrLog( cMsg ), Help( " ", 1, STR0234, , STR0064 + Alltrim( Str( nX, 9 ) ), 4, 5 ) ) //"Problema ocorreu na linha: "
											lRet := .F.
										EndIf
									EndIf
								EndIf
								If lRet .And. ( cUsaRast == "S" .Or. cUsaLocz == "S" )
									aMovEst := fGetTmpMov( .F., aColsAux[ nX ] )

									If !MdtSldSBF( aColsAux[ nX, nPOSEpi ], aColsAux[ nX, nPosLocal ], aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4],;
											 	 aColsAux[ nX, nPosQtde ], .T., aColsAux[ nX, nPosDtEn ] )

										IIf( l695Auto, AutoGrLog( cMsg ), Help( " ", 1, STR0234, , STR0064 + Alltrim( Str( nX, 9 ) ), 4, 5 ) ) //"Problema ocorreu na linha: "
										lRet := .F.
									EndIf
								EndIf
							EndIf
							If aCols[nX, nPosInDe ] == "1"
								If lRet .And. !fDataDvTNF( aColsAux[ nX, nPosDtDe ], .T., STR0114 + Alltrim( Str( nX, 9 ) ), nX )
									lRet := .F.
								EndIf
							Else
								If nPosTNF == 0 .And. !fNgDtTNF( aColsAux[ nX, nPosDtEn ], .T., STR0114 + Alltrim( Str( nX, 9 ) ) ) //"Linha: "
									lRet := .F.
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf

			//MDT695VL - Consiste os Epis Informados ao Validar a Inclusão
			If lRet .And. lExist695VL
				lRet := ExecBlock( 'MDT695VL', .F., .F., {nX} )
				If ValType( lRet ) != "L"
					lRet := .T.
				EndIf
			EndIf

			// Cria um array somente com os EPI nao deletados
			If !aColsAux[nX, Len( aColsAux[nX] )]
				aAdd( aColsNaoDel, aColsAux[nX] )
			EndIf

			//------------------------------------------------------------
			// Adiciona EPI ao array para validação de envio ao eSocial
			//------------------------------------------------------------
			If aScan( aEpiEso, { | x | x[ 1 ] == aColsAux[ nX, nPosEPI ] } ) == 0 .And. aColsAux[ nX, nPosInDe ] <> "1"
				aAdd( aEpiEso, {;
					aColsAux[ nX, nPosEPI ],;		// [1]
					aColsAux[ nX, nPosDtEn ],; 		// [2]
					aColsAux[ nX, nPosDtDe ],; 		// [3]
					aColsAux[ nX, nPosInDe ],; 		// [4]
					aColsAux[ nX, nPosForn ],; 		// [5]
					aColsAux[ nX, nPosLoja ],; 		// [6]
					aColsAux[ nX, nPosNumC ],; 		// [7]
					aColsAux[ nX, nPosEpiEfi ],;	// [8]
					SRA->RA_MAT,; 					// [9]
					aColsAux[ nX, nPosHrEn ];		// [10]
				} )
			EndIf

		Next nX
	EndIf

	// Ponto de entrada chamado na validação da tela de Funcionário x EPI,
	// após validar as linhas de EPIs, como última validação a ser realizada.
	// Através desse ponto de entrada é possível realizar validações e gravações específicas.
	If lRet .And. ExistBlock( "MDTA6954" )
		lRet := ExecBlock( "MDTA6954", .F., .F., { aColsAux, aGridAux [ _nHeader ] } )
		If ValType( lRet ) != "L"
			lRet := .T.
		EndIf
	EndIf

	//-------------------------------------------------------------------------------------
	// Realiza as validações das informações do evento S-2240 que serão enviadas ao Governo
	//-------------------------------------------------------------------------------------
	If lRet .And. FindFunction( "MDTIntEsoc" )
		lRet := MDTEpiS2240( { { SRA->RA_MAT, , , , , , , aEpiEso } }, .F. )
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} D695CHK
Consiste a existencia de outro codigo na GetDados

@author  Elisangela Costa
@since   29/05/2002
@return  lRet, Verdadeiro se não houver códigos iguais.
/*/
//-------------------------------------------------------------------
Function D695CHK() //Esta funcao nao esta sendo utilizado

	Local xx := 0, nPOSEpi, lRet := .T.
	Local nX

	nPOSEpi := aScan( aHEADER, { |x| AllTrim( Upper( x[2] ) ) == "TNF_CODEPI" } )
	nPOS1 	:= aScan( aHEADER, { |x| AllTrim( Upper( x[2] ) ) == "TNF_DTENTR" } )
	nPOS2 	:= aScan( aHEADER, { |x| AllTrim( Upper( x[2] ) ) == "TNF_HRENTR" } )

	If nPOSEpi > 0

		If ExistChav( "TNF", SRA->RA_MAT )
			Return .F.
		EndIf

		cEpi    := aCOLS[N][nPOSEpi]
		dENTR   := aCOLS[N][nPOS1]

		MsgStop( 'CEPI ->' + cEpi + '   DATA ENTR ->' + DToC( dENTR ) )

		For nX := 1 To Len( aCOLS )
			If !aCOLS[nx][Len( aCOLS[nx] )]
				If aCOLS[nX][nPOSEpi] == cEpi .And. aCOLS[nX][nPOS1] == dENTR .And. aCOLS[nX][nPOS2] == m->TNF_HRENTR
					xx := xx + 1
				EndIf
			EndIf
		Next
	EndIf

	If xx > 0
		Help( " ", 1, "JAEXISTINF" )
		lRet := .F.
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} NG695FUNC
Retorna a funcao do funcionario

@author  Elisangela Costa
@since   29/05/2002
@return  .T., Sempre verdadeiro.
/*/
//-------------------------------------------------------------------
Function NG695FUNC()

	nCODFUN := aScan( aHEADER, { |x| AllTrim( Upper( X[2] ) ) == c2CodFun } )

	dbSelectArea( "SRA" )

	If nCODFUN > 0
		aCols[n][nCODFUN]:= SRA->(&(c1CodFun))
	EndIf
	lREFRESH := .T.

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} fEPIMDT695
Validacao do campo TNF_CODEPI

@return .T.

@param cCODEPI - Indica o código do EPI à ser verificado. Obrigatório
@param lCall_a695   - Indica se a funcao foi chamada internamente no
processo do MDTA695
@param lTNB  -

@author Denis Hyroshi de Souza
@since 08/10/2003
/*/
//---------------------------------------------------------------------
Function fEPIMDT695( cCODEPI, lCall_a695, lTNB )

	Local aArea      := GetArea()
	Local lRet       := .T.
	Local lTemFor    := .F.
	Local lSemForn   := .F.
	Local aFornec    := {}
	Local aForPad    := {}
	Local aSize		 := MsAdvSize( , .F., 430 )
	Local cCondicao1 := " "
	Local aGridAux   := fStructEPI()
	Local aColsAux   := {}
	Local lTemTL0    := NGCADICBASE( "TN3_GENERI", "D", "TN3", .F. )
	Local aForSel    := {} //Indica o fornecedor selecionado para o EPI genérico
	Local lMarcado   := .F.
	Local nSizeSA2   := IIf( ( TAMSX3( "A2_COD" )[1]) < 1, 6, (TAMSX3( "A2_COD" )[1] ) )
	Local nSizeFOR   := IIf( ( TAMSX3( "A2_NOME" )[1]) < 1, 30, (TAMSX3( "A2_NOME" )[1] ) )
	Local nSizeLoj   := IIf( ( TAMSX3( "A2_LOJA" )[1]) < 1, 2, (TAMSX3( "A2_LOJA" )[1] ) )
	Local lArqProd   := SuperGetMv( "MV_ARQPROD", .F., "SB1" ) == "SB1"
	Local aAreaSB1   := {} //Salva area da SB1
	Local nParEPIV   := SuperGetMV( "MV_MDTEPIV", .F., 1 ) //Indica se EPI vencida sera entregue ou nao.
	Local aEPICombo  := { STR0076, STR0257 } //"Todos"##"EPI's não vencidos"
	Local oTempTable
	Local nPOSEpi
	Local nPosDtEn
	Local nPosHrEn
	Local nPosForn
	Local nPosLoja
	Local nPosNumC
	Local nPosInDe
	Local nPosDesc
	Local nPosLocal
	Local nPosFunc
	Local nX
	Local nAt
	Local nEpiAlt
	Local nSizeCod
	Local nIndTN3
	Local nIndTL0
	Local cSeekTN3
	Local cSeekTL0
	Local cCondTN3
	Local cCondTL0
	Local cEpiSel
	Local cCaEpiSel
	Local aEpiSel
	Local oDlgEPI
	Local oMenu
	Local oPnlPai
	Local oPnlTop
	Local cQryFil
	Local oEPICombo
	Local cKeyEPI   := ''

	// 1=Entregar EPI vencida, 2=Nao Entregar ou 3=Pergunta se deve ou nao entrega
	Private nRegMark   := 0
	Private lInverte   := .F.
	Private cAliasTN3  := GetNextAlias()

	Default lCall_a695 := .F.

	If lSigaMdtps
		nIndTN3  := 4  //TN3_FILIAL+TN3_CLIENT+TN3_LOJACL+TN3_CODEPI+TN3_NUMCAP
		cSeekTN3 := xFilial( "TN3" ) + cCliMdtps + cCODEPI
		cCondTN3 := "TN3->TN3_FILIAL+TN3->TN3_CLIENT+TN3->TN3_LOJACL+TN3->TN3_CODEPI"
		If lTemTL0
			nIndTL0  := 1 //TL0_FILIAL+TL0_EPIGEN+TL0_FORNEC+TL0_LOJA+TL0_EPIFIL
			cSeekTL0 := xFilial( 'TL0' ) + cCliMdtps + cCODEPI
			cCondTL0 := "TL0->TL0_FILIAL+TL0->TL0_CLIENT+TL0->TL0_LOJACL+TL0->TL0_EPIFIL"
		EndIf
	Else
		nIndTN3  := 2  //TN3_FILIAL+TN3_CODEPI
		cSeekTN3 := xFilial( "TN3" ) + cCODEPI
		cCondTN3 := "TN3->TN3_FILIAL+TN3->TN3_CODEPI"
		If lTemTL0
			nIndTL0  := 2
			cSeekTL0 := xFilial( "TL0" ) + cCODEPI
			cCondTL0 := "TL0->TL0_FILIAL+TL0->TL0_EPIFIL"
		EndIf
	EndIf

	If !lCall_a695

		dbSelectArea( "TN3" ) //Verifica se o EPI esta cadastrado junto a um fornecedor
		dbSetOrder( nIndTN3 )
		If !dbSeek( cSeekTN3 )
			lSemForn := .T.
		EndIf
		If lTemTL0
			dbSelectArea( "TL0" )
			dbSetOrder( nIndTL0 )
			If dbSeek( cSeekTL0 ) //Verifica se está relacionado a um EPI genérico
				lSemForn := .F.
			EndIf
		EndIf

		If lSemForn //Se não estiver relacionado diretamente ao fornecedor ou um EPI genérico
			Help( " ", 1, STR0234, , STR0039 + CRLF + STR0040, 4, 5 ) //"Aviso"//"Este Epi não está cadastrado junto a um fornecedor."
			lRet := .F.
		EndIf

		If lRet .And. Type( "lHist695" ) == "L" .And. !lHist695 .And. !l695Auto //Se não for histórico //Caso rotina automática, sempre entrega o EPI.
			dbSelectArea( "TNB" )
			dbSetOrder( 1 )
			If !dbSeek( xFilial( "TNB" ) + IIf( lSigaMdtps, cCliMdtps, "" ) + SRA->RA_CODFUNC + cCODEPI )
				cQryFil := GetNextAlias()
				BeginSQL Alias cQryFil
					SELECT TL0.TL0_EPIGEN, TL0.TL0_FORNEC, TL0.TL0_LOJA, TL0.TL0_EPIFIL FROM %table:TL0% TL0
						JOIN %table:TN3% TN3 ON	TN3.TN3_CODEPI	= TL0.TL0_EPIGEN AND
												TN3.TN3_FORNEC	= TL0.TL0_FORNEC AND
												TN3.TN3_LOJA	= TL0.TL0_LOJA AND
												TN3.%notDel%
						JOIN %table:TNB% TNB ON	TNB.TNB_CODFUN	= %exp:SRA->RA_CODFUNC% AND
												TNB.TNB_CODEPI	= TL0.TL0_EPIGEN AND
												TNB.%notDel%
						WHERE TL0.TL0_EPIFIL = %exp:cCODEPI% AND TL0.%notDel%
				EndSQL
				If ( cQryFil )->( EoF() )
					lRet := MsgYesNo( STR0041, STR0020 ) //"EPI não consta no cadastro de EPI x Função, confirmar a entrega do EPI?"###"ATENÇÃO"
				EndIf
				( cQryFil )->( dbCloseArea() )
			EndIf
		EndIf

		// Este ponto de entrada tem o propósito de permitir que o usuário
		// crie a sua própria regra de validação para a entrega ou não do EPI.
		If lRet .And. ExistBlock( "MDTA6953" )
			xRetorno := ExecBlock( "MDTA6953", .F., .F. )

			If ValType( xRetorno ) == "L"
				lRet := xRetorno
			EndIf
		EndIf

	EndIf

	//-----------------------------
	// Traz os fornecedores do EPI
	//-----------------------------
	dbSelectArea( "TN3" )
	dbSetOrder( nIndTN3 )
	dbSeek( cSeekTN3 )
	While !Eof() .And. cSeekTN3 == &(cCondTN3)

		If TN3->( FieldPos( "TN3_MSBLQL" ) ) > 0
			If TN3->TN3_MSBLQL == "1"
				dbSelectArea( "TN3" )
				Skip()
				Loop
			EndIf
		EndIf

		If TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
			aAdd( aFornec, { TN3->TN3_FORNEC, TN3->TN3_LOJA, TN3->TN3_CODEPI, TN3->TN3_NUMCAP, TN3->TN3_DTVENC, TN3->TN3_DTVALI } )
		Else
			aAdd( aFornec, { TN3->TN3_FORNEC, TN3->TN3_LOJA, TN3->TN3_CODEPI, TN3->TN3_NUMCAP, TN3->TN3_DTVENC } )
		EndIf

		If lForPad .And. TN3->TN3_FORNEC + TN3->TN3_LOJA == cForPad
			lTemFor := .T.
			If TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
				aAdd( aForPad, { TN3->TN3_FORNEC, TN3->TN3_LOJA, TN3->TN3_CODEPI, TN3->TN3_NUMCAP, TN3->TN3_DTVENC, TN3->TN3_DTVALI } )
			Else
				aAdd( aForPad, { TN3->TN3_FORNEC, TN3->TN3_LOJA, TN3->TN3_CODEPI, TN3->TN3_NUMCAP, TN3->TN3_DTVENC } )
			EndIf
		EndIf

		If lTemTL0 .And. TN3->TN3_GENERI == '2' //Só valida fornecedor se não for epi genérico
			If TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
				aAdd( aForSel, { TN3->TN3_FORNEC, TN3->TN3_LOJA, TN3->TN3_CODEPI, '', '', TN3->TN3_DTVALI } )
			Else
				aAdd( aForSel, { TN3->TN3_FORNEC, TN3->TN3_LOJA, TN3->TN3_CODEPI, '', '' } )
			EndIf
		EndIf
		dbSelectArea( "TN3" )
		TN3->(Dbskip())
	End

	//------------------------------------
	// Se gere EPI genéricos verifica TL0
	//------------------------------------
	If lTemTL0
		If Len( aForSel ) > 0 //Se informado EPi genérico
			//-----------------------------------------------
			// Se o EPI possuir mais de um fornecedor,
			// exibirá uma tela para selecionar o fornecedor+loja (NG695SELFR)
			// Com o fornecedor e loja, será exebido uma tela para selecionar o EPI filho (NG695EPIF)
			//-----------------------------------------------
			If Len( aForSel ) > 1
				lGenSelFor := .T.
				aForSel := NG695SELFR( aForSel )
				aEpiSel := NG695EPIF( aForSel[ 1, 1 ], aForSel[ 1, 2 ], cCODEPI )
				If Len(aEpiSel) > 0
					cEpiSel := aEpiSel[1]
					cCaEpiSel := aEpiSel[2]
				EndIf
				// Caso houver apenas um fornecedor pede para selecionar o EPI filho
			ElseIf Len( aForSel ) == 1
				aEpiSel := NG695EPIF( aForSel[1, 1], aForSel[1, 2], cCODEPI )
				If Len(aEpiSel) > 0
					cEpiSel := aEpiSel[1]
					cCaEpiSel := aEpiSel[2]
				EndIf
			EndIf

			If !Empty( cEpiSel )
				dbSelectArea( "TL0" )
				dbSetOrder( 01 )
				dbSeek( xFilial( "TL0" ) + cCODEPI + aForSel[ 1, 1 ] + aForSel[ 1, 2 ] + cEpiSel + cCaEpiSel )
				If TL0->( FieldPos( "TL0_DTVALI" ) ) > 0
					aFornec := { { TL0->TL0_FORNEC, TL0->TL0_LOJA, TL0->TL0_EPIFIL, TL0->TL0_NUMCAP, TL0->TL0_DTVENC, TL0->TL0_DTVALI } }
				Else
					aFornec := { { TL0->TL0_FORNEC, TL0->TL0_LOJA, TL0->TL0_EPIFIL, TL0->TL0_NUMCAP, TL0->TL0_DTVENC } }
				EndIf
				cCODEPI := TL0->TL0_EPIFIL
			Else
				lRet := .F.
			EndIf
		Else
			dbSelectArea( "TL0" )
			dbSetOrder( nIndTL0 )
			dbSeek( cSeekTL0 )
			While TL0->( !Eof() ) .And. cSeekTL0 == &(cCondTL0)

				If dDataBase >= TL0->TL0_DTINIC .And. (dDataBase <= TL0->TL0_DTFIM .Or. Empty( TL0->TL0_DTFIM ))  // Se estiver ativo o fornecimento adiciona fornecedor.

					If TL0->( FieldPos( "TL0_DTVALI" ) ) > 0
						aAdd( aFornec, { TL0->TL0_FORNEC, TL0->TL0_LOJA, TL0->TL0_EPIFIL, TL0->TL0_NUMCAP, TL0->TL0_DTVENC, TL0->TL0_DTVALI } )
					Else
						aAdd( aFornec, { TL0->TL0_FORNEC, TL0->TL0_LOJA, TL0->TL0_EPIFIL, TL0->TL0_NUMCAP, TL0->TL0_DTVENC } )
					EndIf
					If lForPad
						If TL0->TL0_FORNEC+TL0->TL0_LOJA == cForPad
							lTemFor := .T.
							If TL0->( FieldPos( "TL0_DTVALI" ) ) > 0
								aAdd( aForPad, { TL0->TL0_FORNEC, TL0->TL0_LOJA, TL0->TL0_EPIFIL, TL0->TL0_NUMCAP, TL0->TL0_DTVENC, TL0->TL0_DTVALI } )
							Else
								aAdd( aForPad, { TL0->TL0_FORNEC, TL0->TL0_LOJA, TL0->TL0_EPIFIL, TL0->TL0_NUMCAP, TL0->TL0_DTVENC } )
							EndIf
						EndIf
					EndIf
				EndIf

				dbSelectArea( "TL0" )
				TL0->(dbSkip())

			End

			If lRet .And. l695Auto
				If Len( aFornec ) > 0
					lTemFor := .T.
					aForPad := aClone( aFornec )
				ElseIf Len( aForPad ) > 0
					lTemFor := .T.
					aFornec := aClone( aForPad )
				Else
					Help( " ", 1, STR0234, , STR0235, 4, 5 ) //"Este EPI não está vinculado a um fornecedor, o processo será abortado e o EPI não será entregue."
					lRet := .F.
				EndIf
			EndIf

		EndIf
	EndIf

	If !lCall_a695 .And. Type( "lHist695" ) == "L" .And. !lHist695

		If lRet .And. Len( aFornec ) == 0
			Help( " ", 1, STR0234, , STR0235, 4, 5 ) //"Este EPI não está vinculado a um fornecedor, o processo será abortado e o EPI não será entregue."
			lRet := .F.
		EndIf

		//Se houver um fornecedor e se não aceitar entrega de EPI vencido
		If lRet .And. Len( aFornec ) == 1 .And. nParEPIV != 1
			If ( !Empty( aFornec[ 1, 5 ] ) .And. aFornec[ 1, 5 ] < dDatabase ) //Data de vencimento
				If nParEPIV == 2 //Não entrega EPI vencido
					If lRet .And. !l695Auto
						Help( " ", 1, STR0234, , STR0117, 4, 5 ) //"Aviso"###"Este EPI está com a data de vencimento ultrapassada."
					EndIf
					lRet := .F.
				ElseIf nParEPIV == 3 //Pergunta se entrega EPI Vencido
					If lRet .And. l695Auto
						lRet := .F.
					ElseIf lRet .And. !MsgYesNo( STR0117 + " " + STR0118 ) //"Este EPI está com a data de vencimento ultrapassada."###"Deseja continuar?"
						lRet := .F.
					EndIf
				EndIf
			ElseIf TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
				If !Empty( aFornec[ 1, 6 ] ) .And. aFornec[ 1, 6 ] < dDatabase //Data de Validade
					If nParEPIV == 2 //Não entrega EPI vencido
						If lRet .And. !l695Auto
							Help( " ", 1, STR0234, , STR0250, 4, 5 ) //"Aviso"###"Este EPI está com a data de validade ultrapassada."
						EndIf
						lRet := .F.
					ElseIf nParEPIV == 3 //Pergunta se entrega EPI Vencido
						If l695Auto
							lRet := .F.
						ElseIf !MsgYesNo( STR0250 + " " + STR0118 ) //"Este EPI está com a data de validade ultrapassada."###"Deseja continuar?"
							lRet := .F.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

	EndIf

	If lRet
		nPosEPI  := GdFieldPos( "TNF_CODEPI", aGridAux[ _nHeader ] )
		nPosDesc := GdFieldPos( "TNF_DESC", aGridAux[ _nHeader ] )
		nPosForn := GdFieldPos( "TNF_FORNEC", aGridAux[ _nHeader ] )
		nPosLoja := GdFieldPos( "TNF_LOJA", aGridAux[ _nHeader ] )
		nPosNumC := GdFieldPos( "TNF_NUMCAP", aGridAux[ _nHeader ] )
		nPosDtEn := GdFieldPos( "TNF_DTENTR", aGridAux[ _nHeader ] )
		nPosHrEn := GdFieldPos( "TNF_HRENTR", aGridAux[ _nHeader ] )
		nPosFunc := GdFieldPos( "TNF_CODFUN", aGridAux[ _nHeader ] )
		nPosInDe := GdFieldPos( "TNF_INDDEV", aGridAux[ _nHeader ] )
		nPosLocal:= GdFieldPos( "TNF_LOCAL", aGridAux[ _nHeader ] )

		nAt := aGridAux[ _nAt ]
		aColsAux := aGridAux[ _nCols, nAt ]

		dbSelectArea( "SB1" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "SB1" ) + cCODEPI )
		aColsAux[ nPosDesc ] := SB1->B1_DESC
		If nPosLocal > 0
			If lArqProd //Caso seja SB1
				aColsAux[ nPosLocal ] := SB1->B1_LOCPAD
			Else
				aAreaSB1 := SB1->( GetArea() )//Salva area da SB1
				dbSelectArea( "SBZ" )
				dbSetOrder( 1 ) //BZ_FILIAL+BZ_COD
				If dbSeek( xFilial( "SBZ" ) + cCODEPI )
					aColsAux[ nPosLocal ] := SBZ->BZ_LOCPAD
				EndIf
				RestArea( aAreaSB1 )
			EndIf
		EndIf

		If lTemFor
			If nPosForn > 0
				aColsAux[ nPosForn ] := aForPad[ 1, 1 ]
			EndIf
			If nPosLoja > 0
				aColsAux[ nPosLoja ] := aForPad[ 1, 2 ]
			EndIf
			If nPosNumC > 0
				aColsAux[ nPosNumC ] := aForPad[ 1, 4 ]
			EndIf
			If aColsAux[ nPosForn ] == aForPad[ 1, 1 ] .And. aColsAux[ nPosLoja ] == aForPad[ 1, 2 ]
				RestArea( aArea )
				Return .T.
			EndIf
		EndIf

		If ( !lCall_a695 .Or. lGenSelFor ) .And. ( Len( aFornec ) == 1 .Or. ( IIf( nPosForn > 0, Empty( aColsAux[ nPosForn ] ), .F. ) ) )
			If Len( aFornec ) == 1
				If nPosForn > 0
					aColsAux[ nPosForn ] := aFornec[ 1, 1 ]
				EndIf
				If nPosLoja > 0
					aColsAux[ nPosLoja ] := aFornec[ 1, 2 ]
				EndIf
				If nPosNumC > 0
					aColsAux[ nPosNumC ] := aFornec[ 1, 4 ]
				EndIf
			EndIf

			If Len( aForSel ) > 0 //Se informado EPi genérico atualiza campo da getdados
				aColsAux[ nPosEPI ] := cCODEPI
				M->TNF_CODEPI       := cCODEPI
			EndIf
		EndIf

		If nPosFunc > 0
			aColsAux[ nPosFunc ] := SRA->RA_CODFUNC
		EndIf
		If nPosDtEn > 0 .And. Empty( aColsAux[ nPosDtEn ] )
			aColsAux[ nPosDtEn ] := dDataBase
		EndIf
		If nPosHrEn > 0 .And. Empty( aColsAux[ nPosHrEn ] )
			aColsAux[ nPosHrEn ] := SubStr( Time(), 1, 8 )
		EndIf
		If nPosInDe > 0 .And. Empty( aColsAux[ nPosInDe ] )
			aColsAux[ nPosInDe ] := cIndRelac
		EndIf

		// Verifica se há apenas um fornecedor, caso tenha mais será realizado o processo para
		// escolher qual fornecedor deseja para fazer a entrega
		If Len( aFornec ) > 1

			dbSelectArea( "TN3" )

			aDBF := {}
			aAdd( aDBF, { "TN3_OK", "C", 02, 0 } )
			aAdd( aDBF, { "FORNEC", "C", nSizeSA2, 0 } )
			aAdd( aDBF, { "NOMFOR", "C", nSizeFOR, 0 } )
			aAdd( aDBF, { "LOJA", "C", nSizeLoj, 0 } )
			aAdd( aDBF, { "NUMCAP", "C", 12, 0 } )
			aAdd( aDBF, { "DTVENC", "D", 08, 0 } )
			If TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
				aAdd( aDBF, { "DTVALI", "D", 08, 0 } )
			EndIf

			aTRB1 := {}
			aAdd( aTRB1, { "TN3_OK", NIL, " ", } )
			aAdd( aTRB1, { "FORNEC", NIL, STR0029, } )     //"Fornecedor"
			aAdd( aTRB1, { "NOMFOR", NIL, STR0006, } )     //"Nome"
			aAdd( aTRB1, { "LOJA", NIL, STR0030, } )       //"Loja"
			aAdd( aTRB1, { "NUMCAP", NIL, STR0042, } )     //"Certificado Aprovacao"
			aAdd( aTRB1, { "DTVENC", NIL, STR0032, } )     //"Data Vencimento"
			If TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
				aAdd( aTRB1, { "DTVALI", NIL, STR0249, } ) //"Data Validade"
			EndIf

			//Cria arquivo temporario
			oTempTable := FWTemporaryTable():New( cAliasTN3, aDBF )
			oTempTable:AddIndex( "1", {"FORNEC", "LOJA", "NUMCAP"} )
			oTempTable:AddIndex( "2", {"TN3_OK"} )
			oTempTable:AddIndex( "3", {"DTVALI"} )
			oTempTable:Create()

			If lCall_a695
				cCondicao1 := (cAliasEPI)->FORNEC+(cAliasEPI)->LOJA+(cAliasEPI)->NUMCAP
			Else
				If nPosForn > 0 .And. nPosLoja > 0
					cCondicao1 := aColsAux[ nPosForn ] + aColsAux[ nPosLoja ]
					If nPosNumC > 0
						cCondicao1 := aColsAux[ nPosForn ] + aColsAux[ nPosLoja ] + aColsAux[ nPosNumC ]
					EndIf
				EndIf
			EndIf

			lAchouIgual := .F.
			For nX := 1 to Len( aFornec )
				dbSelectArea( "SA2" )
				dbSetOrder( 1 )
				If dbSeek( xFilial( "SA2" ) + aFornec[ nX, 1 ] + aFornec[ nX, 2 ] )

					cCondicao := aFornec[ nX, 1 ] + aFornec[ nX, 2 ] + aFornec[ nX, 4 ]

					dbSelectArea( cAliasTN3 )
					If !dbSeek( cCondicao )
						RecLock( cAliasTN3, .T. )
						(cAliasTN3)->TN3_OK := Space( 2 )
						If cCondicao == cCondicao1
							(cAliasTN3)->TN3_OK := cMarca
							lAchouIgual := .T.
							nRegMark := (cAliasTN3)->(Recno())
						EndIf
						(cAliasTN3)->FORNEC := aFornec[ nX, 1 ]
						(cAliasTN3)->NOMFOR := Substr( SA2->A2_NOME, 1, 30 )
						(cAliasTN3)->LOJA   := aFornec[ nX, 2 ]
						(cAliasTN3)->NUMCAP := aFornec[ nX, 4 ]
						(cAliasTN3)->DTVENC := aFornec[ nX, 5 ]
						If TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
							(cAliasTN3)->DTVALI := aFornec[nX][6]
						EndIf
						(cAliasTN3)->(Msunlock( cAliasTN3 ))
					EndIf
				EndIf
			Next nX

			If !lAchouIgual
				dbSelectArea( cAliasTN3 )
				Dbgotop()
				While !eof()
					If (cAliasTN3)->DTVENC >= dDatabase .And.;
					( (!Empty( (cAliasTN3)->DTVALI ) .And. (cAliasTN3)->DTVALI >= dDatabase) .Or. Empty( (cAliasTN3)->DTVALI ) )
						RecLock( cAliasTN3, .F. )
							(cAliasTN3)->TN3_OK := cMarca
						(cAliasTN3)->(Msunlock( cAliasTN3 ))
						nRegMark := (cAliasTN3)->(Recno())
						Exit
					EndIf
					dbSkip()
				End
				If nRegMark == 0 .And. nOpcVenc == 1 //1-Entrega EPI Vencido
					dbSelectArea( cAliasTN3 )
					Dbgotop()
					If !Eof() .Or. !Bof()
						RecLock( cAliasTN3, .F. )
							(cAliasTN3)->TN3_OK := cMarca
						(cAliasTN3)->(Msunlock( cAliasTN3 ))
						nRegMark := (cAliasTN3)->(Recno())
					EndIf
				EndIf
			EndIf

			dbSelectArea( cAliasTN3 )
			Dbgotop()
			nOpca := 2

			//----------------
			//	Monta Dialog
			//----------------
			oDlgEPI := MSDialog():New( 0, 0, aSize[6]/2, aSize[5]/1.5, STR0043, , , , , CLR_BLACK, CLR_WHITE, , GetWndDefault(), .T. ) //"Selecione o Fornecedor do Epi"

				//Painel onde sera feita a disposicao da tela
				oPnlPai := TPanel():New( 0, 0, Nil, oDlgEPI, Nil, .T., .F., Nil, Nil, 0, 60, .T., .F. )
					oPnlPai:Align := CONTROL_ALIGN_ALLCLIENT

					//Tamanho do campo de acordo com o conteúdo de cCODEPI
					//o +5 representa um tamanho mínimo para margem do conteúdo para o componente
					//5 é aproximadamente quanto cada letra ocupa em pixels
					nSizeCod := (Len( AllTrim( cCODEPI ) ) * 5 ) + 5
					oPnlTop := TPanel():New( 0, 0, , oPnlPai, , , , , , 0, 40, .F., .F. )
						oPnlTop:Align := CONTROL_ALIGN_TOP

						TSay():New( 07, 10, { || STR0044 }, oPnlTop, , , , , , .T. ) //"Epi",
						TGet():New( 05, 20, { || cCODEPI }, oPnlTop, nSizeCod, 10, "@!", , , , , , , .T., , , { || .F. } )

						TSay():New( 07, 30 + nSizeCod, { || STR0215 }, oPnlTop, , , , , , .T. ) //"Descrição"
						TGet():New( 05, 60 + nSizeCod, { || Substr( SB1->B1_DESC, 1, 40 ) }, oPnlTop, 130, 10, "@!", , , , , , , .T., , , { || .F. } )

						//Campo combo de indice para busca
						TSay():New( 27, 10, { || STR0074 }, oPnlTop, , , , , , .T. ) //"Filtrar EPIs Vencidos"
						oEPICombo := TComboBox():New( 25, 40, {|u| IIf( Pcount()>0, cKeyEPI:= u, cKeyEPI ) }, aEPICombo,;
												 190, 10, oPnlTop, , {|| oMARK:oBROWSE:SetFocus() }, , , CLR_BLACK,;
												 .T., , , , , , , , , cKeyEPI, , , , CLR_BLACK )

					oPnlBot := TPanel():New( 0, 0, , oPnlPai, , , , , , 0, , .F., .F. )
						oPnlBot:Align := CONTROL_ALIGN_ALLCLIENT

						oMARK := MsSelect():New( cAliasTN3, "TN3_OK", , aTRB1, @lINVERTE, @cMARCA, , , , oPnlBot )
						oMARK:oBROWSE:lHASMARK		:= .F.
						oMARK:oBROWSE:lCANALLMARK	:= .F.
						oMARK:bMARK := {|| MDTA695MAQ( cMarca, (cAliasTN3)->(Recno()), cAliasTN3 ) .And. oMARK:oBROWSE:REFRESH( .T. ) }
						oMARK:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
						oMARK:oBrowse:bGotFocus := { || MstMarkEPI( @oEPICombo, @oMark ) }

			ACTIVATE MSDIALOG oDlgEPI ON INIT EnchoiceBar( oDlgEPI, {|| nOpca := 1, oDlgEPI:End()}, {|| nOpca := 2, oDlgEPI:End()} ) Centered

			If nOpca == 1
				dbSelectArea( cAliasTN3 )
				dbSetOrder( 2 )
				If dbSeek( cMarca )
					lMarcado := .T.
					If lTemTL0
						aColsAux[ nPosEPI ] := cCODEPI
					EndIf
					If !lCall_a695
						If nPosForn > 0
							aColsAux[ nPosForn ] := (cAliasTN3)->FORNEC
						EndIf
						If nPosLoja > 0
							aColsAux[ nPosLoja ] := (cAliasTN3)->LOJA
						EndIf
						If nPosNumC > 0
							aColsAux[ nPosNumC ] := (cAliasTN3)->NUMCAP
						EndIf
						If nPosFunc > 0
							aColsAux[ nPosFunc ] := SRA->RA_CODFUNC
						EndIf
						If nPosDtEn > 0 .And. Empty( aColsAux[ nPosDtEn ] )
							aColsAux[ nPosDtEn ] := dDataBase
						EndIf
						If nPosHrEn > 0 .And. Empty( aColsAux[ nPosHrEn ] )
							aColsAux[ nPosHrEn ] := SubStr( Time(), 1, 5 )
						EndIf
						If nPosInDe > 0 .And. Empty( aColsAux[ nPosInDe ] )
							aColsAux[ nPosInDe ] := cIndRelac
						EndIf
					Else
						dbSelectArea( "SA2" )
						dbSetOrder( 1 )
						dbSeek( xFilial( "SA2" ) + (cAliasTN3)->FORNEC )
						dbSelectArea( cAliasEPI )
						RecLock( cAliasEPI, .F. )
							(cAliasEPI)->FORNEC := (cAliasTN3)->FORNEC
							(cAliasEPI)->NOME	:= Substr( SA2->A2_NOME, 1, 20 )
							(cAliasEPI)->LOJA	:= (cAliasTN3)->LOJA
							(cAliasEPI)->NUMCAP	:= (cAliasTN3)->NUMCAP
							(cAliasEPI)->DTVENC	:= (cAliasTN3)->DTVENC
							If TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
								(cAliasEPI)->DTVALI	:= (cAliasTN3)->DTVALI
							EndIf
						( cAliasEPI )->( Msunlock() )
						//Adiciona ou altera no Array
						If ( nEpiAlt := aScan( aEpiAlt, { | x | x[ 1 ] == ( cAliasEPI )->CODEPI} ) ) == 0
							aAdd( aEpiAlt, { ( cAliasEPI )->CODEPI, {} } )
							nEpiAlt := Len( aEpiAlt )
							For nX:=1 To Len( aDBFEPI )
								aAdd( aEpiAlt[ nEpiAlt, 2 ], { aDBFEPI[ nX, 1 ], &("(cAliasEPI)->" + aDBFEPI[ nX, 1 ] ) } )
							Next nX
						Else
							For nX:=1 To Len( aDBFEPI )
								aEpiAlt[ nEpiAlt, 2, nX, 2 ] := &("(cAliasEPI)->" + aEpiAlt[nEpiAlt, 2, nX, 1])
							Next nX
						EndIf
					EndIf
				End
			EndIf
			If nOpca == 2 .Or. !lMarcado
				aColsAux[ nPosDesc ] := Space( 20 )
				aColsAux[ nPosDtEn ] := SToD( Space( 8 ) )
				aColsAux[ nPosHrEn ] := Space( 5 )
				If nPosLocal > 0
					aColsAux[ nPosLocal ] := Space( 2 )
				EndIf
			EndIf
			//Deleta TRB
			oTempTable:Delete()
		EndIf
	EndIf

	If !l695Auto .And. Type( "oGetTNF695" ) == "O"
		oGetTNF695:oBrowse:Refresh()
	EndIf

	RestArea( aArea )

Return lRet
//------------------------------------------------------
/*/{Protheus.doc} MstMarkEPI()
Função filtro de EPI's não vencidos da MarkBrose conforme selecionado
no ComboBox

@param  oCombo, objeto, Objeto do comboBox
@param  oMark,  objeto, Objeto do MarkBrowse

@author  Milena Leite de Oliveira
@since   20/02/2020
@return  Lógico, sempre .T.
/*/
//------------------------------------------------------
Static Function MstMarkEPI( oCombo, oMark )

	Local nIndEPI := 0

	nIndEPI := oCombo:nAt

	dbSelectArea( cAliasTN3 )

	If nIndEPI == 2
		dbSetOrder( 3 )
		dbSeek( dDatabase, .T. )
		Set Filter To !Empty( (cAliasTN3)->DTVALI ) .And. (cAliasTN3)->DTVALI > dDatabase
	Else
		Set Filter To
		 (cAliasTN3)-> (dbGoTop())
	EndIf

	oMark:oBrowse:Refresh( .T. )

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} MDTA695MAQ
Inverte a marcacao do browse

@return .T.

@param cMarca   - Quando preenchido, indica que registro esta marcado.
@param nRegs    - Indica o recno da TN3

@author Denis Hyroshi de Souza
@since 25/07/2003
/*/
//---------------------------------------------------------------------
Static Function MDTA695MAQ( cMarca, nRegs, cAliasTN3 )

	Local aArea    := GetArea()
	Local nParEPIV := SuperGetMV( "MV_MDTEPIV", .F., 1 ) //Indica se EPI vencida sera entregue ou nao.
	//1=Entregar EPI vencida, 2=Nao Entregar ou 3=Pergunta se deve ou nao entrega
	Local lRefazer  := .F.
	Local lExistHis := Type( "lHist695" ) == "L"

	dbSelectArea( cAliasTN3 )
	Dbgotop()
	While (cAliasTN3)->( !Eof() )
		If nRegs == (cAliasTN3)->(Recno())
			(cAliasTN3)->TN3_OK := cMARCA
			If nOpcVenc != 1 // 1=Entregar EPI vencida
				If lExistHis .And. !lHist695 //Se não for histórico
					If nRegs != nRegMark
						If (cAliasTN3)->DTVENC < dDatabase
							If nParEPIV == 2
								MsgStop( STR0117 ) //"Este EPI está com a data de vencimento ultrapassada."
								(cAliasTN3)->TN3_OK := "  "
								lRefazer := .T.
								Exit
							Else
								If !MsgYesNo( STR0117 + " " + STR0118 ) //"Este EPI está com a data de vencimento ultrapassada."###"Deseja continuar?"
									lRefazer := .T.
									Exit
								EndIf
							EndIf
						Else
							If TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
								If !Empty( (cAliasTN3)->DTVALI ) .And. (cAliasTN3)->DTVALI < dDatabase
									If nParEPIV == 2
									 	MsgStop( STR0250 )//"Este EPI está com a data de validade ultrapassada."
										(cAliasTN3)->TN3_OK := "  "
										lRefazer := .T.
										Exit
									Else
										If !MsgYesNo( STR0250 + " " + STR0118 ) //"Este EPI está com a data de validade ultrapassada."###"Deseja continuar?"
											lRefazer := .T.
											Exit
										EndIf
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
				nRegMark := (cAliasTN3)->(Recno())
			EndIf
		Else
			(cAliasTN3)->TN3_OK := "  "
		EndIf

		(cAliasTN3)->( Dbskip() )
	End

	If nOpcVenc == 3 // 3-Pergunta se entrega EPI Vencido
		If lRefazer
			dbSelectArea( cAliasTN3 )
			Dbgotop()
			While !eof()
				If nRegMark == (cAliasTN3)->(Recno())
					(cAliasTN3)->TN3_OK := cMARCA
				Else
					(cAliasTN3)->TN3_OK := "  "
				EndIf
				Dbskip()
			End
		EndIf
	EndIf

	RestArea( aArea )

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} MDT695MKFU
Efetua a marcação no browse.

@author  Denis Hyroshi de Souza
@since   25/07/2003
@sample  MDT695MKFU("LY", .F.)
@param   cMarca, Caractere, Marca do browse
@param   lInverte, Lógico, Se iverte a macação
@uso 	 MDTA450

@return  Nil, Sempre nulo
/*/
//-------------------------------------------------------------------
Function MDT695MKFU( cMarca, lInverte )

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTA695INV
Inverte todas as marcações do browse.

@author  Denis Hyroshi de Souza
@since   25/07/2003
@sample  MDTA695INV("LY", .F.)
@param   cMarca, Caractere, Marca do browse
@param   lTNB, Lógico, Se iverte a macação da Tabela temporária
da TNB
@uso 	 MDTA450

@return  .T., Sempre verdadeiro
/*/
//-------------------------------------------------------------------
Function MDTA695INV( cMarca, lTNB )

	Local aArea := GetArea()

	dbSelectArea( cAliasTRB1 )
	Dbgotop()
	While !eof()
		If lTNB
			(cAliasTRB1)->TNB_OK := IIf( TNB_OK == "  ", cMARCA, "  " )
		Else
			(cAliasTRB1)->TOH_OK := IIf( TOH_OK == "  ", cMARCA, "  " )
		EndIf
		Dbskip()
	End

	RestArea( aArea )

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de Menu Funcional.

@return Array aRotina

@author Elisangela Costa
@since 29/05/2002
/*/
//---------------------------------------------------------------------
Static Function MenuDef( lSigaMdtPs )

	Local aRotina
	Local aTmpRot
	Local cAltera := IIf( Type( "lHist695" ) == "L" .And. lHist695, STR0167, STR0003 ) //"Histórico"//"Epis"
	Local lPyme   := IIf( Type( "__lPyme" ) != "U", __lPyme, .F. )

	Default lSigaMdtPS	:= SuperGetMv( "MV_MDTPS", .F., "N" ) == "S"

	If lSigaMdtps
		aRotina := { { STR0001, "AxPesqui", 0, 1 },;  //"Pesquisar"
					 { STR0002, "NGCAD01", 0, 2  },;  //"Visualizar"
					 { STR0073, "MDT695SRA", 0, 4 } } //"Funcionários"
	Else
		aRotina :=	{ { STR0001, "AxPesqui", 0, 1 },;         //"Pesquisar"
					  { STR0002, "NGCAD01", 0, 2  },;         //"Visualizar"
					  { cAltera, "NGFUN695", 0, 4 },;         //"Epis" //"Histórico"
					  { STR0074, "NG695Fil", 0, 5 },;         //"Filtrar EPI"
					  { STR0016, "gpLegend", 0, 6, 0, .F. } } //"Legenda"

		If ExistBlock( "MDTA6956" )
			If ValType( aTmpRot := ExecBlock( "MDTA6956", .F., .F. ) ) == "A"
				aEval( aTmpRot, { | x | aAdd( aRotina, x ) } )
			EndIf
		EndIf
	EndIf

	If !lPyme
		aAdd( aRotina, { STR0256, "MsDocument", 0, 4 } )  //"Conhecimento"
	EndIf

Return aRotina

//------------------------------------------------------------------
/*/{Protheus.doc} NG695EXCC
Solicita confirmacao de exclusao de epi

@return Array aRotina

@author Denis Hyroshi de Souza
@since 30/05/2006
/*/
//---------------------------------------------------------------------
Function NG695EXCC( oGetAux, lValMemory )

	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lLogix    := cMDTInteg == "2"//Logix
	Local cSeek4TNF
	Local cMatricula
	Local cFuncionario
	Local cTxtSoluc
	Local nAt
	//Utilizada para verificar se é rotina de materiais
	//----------
	Local lRotMat    := IIf( IsInCallStack( "MATA240" ) .Or. IsInCallStack( "MATA241" ) .Or. IsInCallStack( "MATA185" ), .T., .F. )
	//----------
	Local nPosTipoDv := IIf( lRotMat, 0, GdFieldPos( "TNF_TIPODV", aHeader ) )
	Local aArea      := GetArea()
	Local lRet       := .T.
	Local lDelLine   := .F.
	Local lCallEst   := IsInCallStack( "MDTValEst" )
	Local lSigaMdtPS := SuperGetMv( "MV_MDTPS", .F., "N" ) == "S"
	Local aColsAux

	Default lValMemory := .F.

	If lValMemory
		RegToMemory( "TNF", .F. )
		cMatricula := TNF->TNF_MAT
	Else
		nAt      := oGetAux:nAt
		aColsAux := oGetAux:aCols
		lDelLine := !( aTail( aColsAux[ nAt ] ) )

		M->TNF_CODEPI := aColsAux[ nAt, GdFieldPos( "TNF_CODEPI", oGetAux:aHeader ) ]
		M->TNF_FORNEC := aColsAux[ nAt, GdFieldPos( "TNF_FORNEC", oGetAux:aHeader ) ]
		M->TNF_LOJA   := aColsAux[ nAt, GdFieldPos( "TNF_LOJA", oGetAux:aHeader ) ]
		M->TNF_NUMCAP := aColsAux[ nAt, GdFieldPos( "TNF_NUMCAP", oGetAux:aHeader ) ]
		M->TNF_DTENTR := aColsAux[ nAt, GdFieldPos( "TNF_DTENTR", oGetAux:aHeader ) ]
		M->TNF_HRENTR := aColsAux[ nAt, GdFieldPos( "TNF_HRENTR", oGetAux:aHeader ) ]
		M->TNF_INDDEV := aColsAux[ nAt, GdFieldPos( "TNF_INDDEV", oGetAux:aHeader ) ]
		M->TNF_DTDEVO := aColsAux[ nAt, GdFieldPos( "TNF_DTDEVO", oGetAux:aHeader ) ]
		M->TNF_NUMSA  := aColsAux[ nAt, GdFieldPos( "TNF_NUMSA", oGetAux:aHeader ) ]
		M->TNF_ITEMSA := aColsAux[ nAt, GdFieldPos( "TNF_ITEMSA", oGetAux:aHeader ) ]

		If nPosTipoDv > 0
			M->TNF_TIPODV := aColsAux[ nAt, nPosTipoDv ]
		EndIf

		cMatricula := SRA->RA_MAT
	EndIf

	If lDelLine .Or. lValMemory

		cFuncionario := STR0243 + Space( 1 ) + AllTrim( cMatricula ) + " - " + AllTrim( NGSeek( "SRA", cMatricula, 1, "SRA->RA_NOME" ) ) //"Funcionário:"

		// Indica se solicita confirmacao de exclusao de Epi entregue ao funcionario. S=Sim;N=Nao
		If lRet .And. SuperGetMv( "MV_MDTEPID", .F., "N" ) == "S" .And. lCallEst

				cTxtSoluc := STR0244 + CRLF + cFuncionario // "Confirma o estorno do EPI entregue ao funcionário?"

				lRet := MsgYesNo( cTxtSoluc )

		EndIf

		If lRet .And. M->TNF_INDDEV == "3"
			If Type( "lHist695" ) == "L" .And. lHist695 //Se for histórico
				Help( " ", 1, STR0234, , STR0168, 4, 5 ) //"Este Epi não poderá ser excluído, pois foi está em solicitação ao armazém."
				lRet := .F.
			Else
				dbSelectArea( "SCP" )
				dbSetOrder( 1 )
				If dbSeek( xFilial( "SCP" ) + M->TNF_NUMSA + M->TNF_ITEMSA ) .And.;
				SCP->CP_PRODUTO == M->TNF_CODEPI .And. SCP->CP_PREREQU == "S" .And. SCP->CP_STATUS != "E"


					Help( " ", 1, STR0234, , STR0140, 4, 5 ) //"Aviso"//"Este Epi não poderá ser excluído, pois foi gerado pré-requisição."
					lRet := .F.
				EndIf
			EndIf
		EndIf

		//"Indica se será bloqueado o Epi, após a impressão do relatório. 1 = Bloqueado ou  2 = Não Bloqueado."
		If lRet .And. SuperGetMv( "MV_NG2EPIB", .F., "1" ) == "1"
			If lSigaMdtps
				cSeek4TNF := xFilial( "TNF" ) + M->TNF_FORNEC + M->TNF_LOJA + cCliMdtps +;
							 M->TNF_CODEPI + M->TNF_NUMCAP + cMatricula +;
							 DToS( M->TNF_DTENTR ) + M->TNF_HRENTR
			Else
				cSeek4TNF := xFilial( "TNF" ) + M->TNF_FORNEC + M->TNF_LOJA + M->TNF_CODEPI + M->TNF_NUMCAP +;
							 cMatricula + DToS( M->TNF_DTENTR ) + M->TNF_HRENTR
			EndIf

			dbSelectArea( "TNF" )
			dbSetOrder( 1 )
			If dbSeek( cSeek4TNF )
				If !Empty( TNF->TNF_DTRECI )

					If lCallEst
						cTxtSoluc := STR0245 + CRLF + cFuncionario //"O EPI não pode ser estornado, pois já foi entregue ao funcionário. É necessário realizar a devolução."
					Else
						cTxtSoluc := STR0237 //"O EPI não pode ser deletado, pois já foi entregue ao funcionário. É permitido somente a devolução."
					EndIf

					Help( " ", 1, STR0234, , cTxtSoluc, 3, 0 ) //"Aviso"
					lRet := .F.
				//Se gerar S.A., e ser realizado a entrega do EPI ao funcionário, e
				//o Status do epi ficar 'em Uso' não poderá mais excluir.
				ElseIf SuperGetMv( "MV_NG2SA", .F., "N" ) == "S"
					If M->TNF_INDDEV == "2"
						If IsInCallStack( "MATA185" )
							cTxtSoluc := STR0254 //"O EPI não pode ser estornado, pois já foi entregue ao funcionário. É permitido somente a devolução."
						Else
							cTxtSoluc := STR0237 //"O EPI não pode ser deletado, pois já foi entregue ao funcionário. É permitido somente a devolução."
						EndIf
						Help( " ", 1, STR0234, , cTxtSoluc, 3, 0 ) //"Aviso"
						lRet := .F.
					EndIf
				EndIf
			EndIf
		EndIf

		If lRet .And. M->TNF_INDDEV $ " 2" .And. Empty( M->TNF_DTDEVO ) .And. SuperGetMv( "MV_NGMDTES", .F., "" ) == "S"
			dbSelectArea( "TNF" )
			dbSetOrder( 1 )
			If !fDataDvTNF( M->TNF_DTDEVO, .T., , , lValMemory )
				lRet := .F.
			ElseIf !fNgDtTNF( M->TNF_DTENTR, .T., , M->TNF_TIPODV == "1" .And. M->TNF_INDDEV == "1", lValMemory )
				lRet := .F.
			EndIf
		EndIf

	EndIf

	RestArea( aArea )

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} ImpRecibo
Impressao do Recibo de Entrega do EPI

@return Array aRotina

@author Denis Hyroshi de Souza
@since 30/05/2006
/*/
//---------------------------------------------------------------------
Static Function ImpRecibo( nRetAviso, aDevEPI, aOldACols, nOpcReci )

	Local aDados    := {}
	Local nSizeCod  := IIf( (TAMSX3( "A1_COD" )[1] ) < 1, 6, (TAMSX3( "A1_COD" )[1] ) )
	Local nSizeLoj  := IIf( (TAMSX3( "A1_LOJA" )[1] ) < 1, 2, (TAMSX3( "A1_LOJA" )[1] ) )
	Local aArea		:= GetArea()
	Local aAreaSRA	:= SRA->( GetArea() )
	Local aAreaTM0	:= TM0->( GetArea() )
	Local cFiltSRA	:= SRA->( dbFilter() )
	Local cFiltTM0	:= TM0->( dbFilter() )
	Local cSeekTM0	:= ""
	Local lCondTM0	:= .F.

	Default aDevEPI   := {}
	Default aOldACols := {}
	//Indica se utiliza Biometria na Devolucao do EPI.//Indica se utiliza Biometria na Entrega de EPI.
	lCondTM0	:= IIf( Len( aDevEPI ) > 0, SuperGetMv( "MV_DEVBIOM", .F., "2" ) == "1", SuperGetMv( "MV_NG2BIOM", .F., "2" ) == "1" )

	If lCondTM0
		dbSelectArea( "TM0" )
		dbSetOrder( 3 )
		If IsInCallStack( "MDTA410" )
			cSeekTM0 := SRA->RA_FILIAL+SRA->RA_MAT
		Else
			cSeekTM0 := M->RA_FILIAL+M->RA_MAT
		EndIf
		If dbSeek( cSeekTM0 ) .And. TM0->TM0_INDBIO == "1"
			MDT333EPI( , , , Len( aDevEPI ) > 0, Len( aOldACols ) > 0, nRetAviso )
			Return .T.
		EndIf
	EndIf

	If lSigaMdtps
		aAdd( aDados, { "Mv_par01", Substr( cCliMdtps, 1, nSizeCod ) } )
		aAdd( aDados, { "Mv_par02", Substr( cCliMdtps, nSizeCod + 1, nSizeLoj ) } )
		aAdd( aDados, { "Mv_par03", Substr( cCliMdtps, 1, nSizeCod ) } )
		aAdd( aDados, { "Mv_par04", Substr( cCliMdtps, nSizeCod + 1, nSizeLoj ) } )
		aAdd( aDados, { "Mv_par05", SRA->RA_MAT } )
		aAdd( aDados, { "Mv_par06", SRA->RA_MAT } )
		aAdd( aDados, { "Mv_par07", dDataBase } )
		aAdd( aDados, { "Mv_par08", dDataBase } )
		aAdd( aDados, { "Mv_par09", 1 } )
		aAdd( aDados, { "Mv_par13", SRA->RA_CC } )
		aAdd( aDados, { "Mv_par14", SRA->RA_CC } )
		aAdd( aDados, { "Mv_par15", 1 } )
		aAdd( aDados, { "Mv_par17", SRA->RA_ADMISSA } )
		aAdd( aDados, { "Mv_par18", SRA->RA_ADMISSA } )
		aAdd( aDados, { "Mv_par19", nRetAviso - 1 } )
	Else
		If IsInCallStack( "MDTA410" )
			TM0->(dbClearFilter())
			SRA->(dbClearFilter())
			aAdd( aDados, { "Mv_par01", M->TM0_MAT } )
			aAdd( aDados, { "Mv_par02", M->TM0_MAT } )
			aAdd( aDados, { "Mv_par03", dDt695Min } )
			aAdd( aDados, { "Mv_par04", dDt695Max } )
			aAdd( aDados, { "Mv_par05", 1 } )
			aAdd( aDados, { "Mv_par09", M->TM0_CC } )
			aAdd( aDados, { "Mv_par10", M->TM0_CC } )
			aAdd( aDados, { "Mv_par11", 1 } )
			aAdd( aDados, { "Mv_par13", NgSeek( "SRA", M->TM0_MAT, 1, "RA_ADMISSA" ) } )
			aAdd( aDados, { "Mv_par14", NgSeek( "SRA", M->TM0_MAT, 1, "RA_ADMISSA" ) } )
			aAdd( aDados, { "Mv_par17", nRetAviso - 1 } )
		ElseIf Type( "M->RA_MAT" ) == "C"
			aAdd( aDados, { "Mv_par01", M->RA_MAT } )
			aAdd( aDados, { "Mv_par02", M->RA_MAT } )
			aAdd( aDados, { "Mv_par03", dDt695Min } )
			aAdd( aDados, { "Mv_par04", dDt695Max } )
			aAdd( aDados, { "Mv_par05", 1 } )
			aAdd( aDados, { "Mv_par09", M->RA_CC } )
			aAdd( aDados, { "Mv_par10", M->RA_CC } )
			aAdd( aDados, { "Mv_par11", 1 } )
			aAdd( aDados, { "Mv_par13", M->RA_ADMISSA } )
			aAdd( aDados, { "Mv_par14", M->RA_ADMISSA } )
			aAdd( aDados, { "Mv_par17", nRetAviso - 1 } )
		Else
			aAdd( aDados, { "Mv_par01", SRA->RA_MAT } )
			aAdd( aDados, { "Mv_par02", SRA->RA_MAT } )
			aAdd( aDados, { "Mv_par03", dDt695Min } )
			aAdd( aDados, { "Mv_par04", dDt695Max } )
			aAdd( aDados, { "Mv_par05", 1 } )
			aAdd( aDados, { "Mv_par09", SRA->RA_CC } )
			aAdd( aDados, { "Mv_par10", SRA->RA_CC } )
			aAdd( aDados, { "Mv_par11", 1 } )
			aAdd( aDados, { "Mv_par13", SRA->RA_ADMISSA } )
			aAdd( aDados, { "Mv_par14", SRA->RA_ADMISSA } )
			aAdd( aDados, { "Mv_par17", nRetAviso - 1 } )
		EndIf
	EndIf

	If ExistBlock( "MDTA6957" )
		ExecBlock( "MDTA6957", .F., .F. )
	Else
		If nOpcReci == 2 //Entrega de EPI
			MDTR805( aDados, aOldACols )
		Else //Devolução de EPI
			MDTR805( aDados, , aDevEPI, .T., aDevPar )
		EndIf
	EndIf
	If !Empty( cFiltTM0 )
		dbSelectArea( "TM0" )
		Set Filter To &( cFiltTM0 )
	EndIf
	If !Empty( cFiltSRA )
		dbSelectArea( "SRA" )
		Set Filter To &( cFiltSRA )
	EndIf

	RestArea( aAreaSRA )
	RestArea( aAreaTM0 )
	RestArea( aArea )
Return

//------------------------------------------------------------------
/*/{Protheus.doc} MDT695SRA
Monta um browse com as tarefas por funcionario

@return

@author Andre Perez Alvarez
@since 24/09/2007
/*/
//---------------------------------------------------------------------
Function MDT695SRA()

	Local aArea		:= GetArea()
	Local aOldRotina:= IIf( Type( "aRotina" ) != "A", Nil, aClone( aROTINA ) )
	Local cOldCad	:= cCadastro
	Local nSizeSA1	:= IIf( (TAMSX3( "A1_COD" )[1] ) < 1, 6, (TAMSX3( "A1_COD" )[1] ) )
	Local nSizeLo1	:= IIf( (TAMSX3( "A1_LOJA" )[1] ) < 1, 2, (TAMSX3( "A1_LOJA" )[1] ) )

	cCliMdtPs := SA1->A1_COD+SA1->A1_LOJA

	aRotina :=	MenuDef( .F. )

	//---------------------------------------------
	// Define o cabecalho da tela de atualizacoes
	//---------------------------------------------
	Private cCadastro := OemtoAnsi( STR0073 )  //"Funcionários"
	Private nTamFor   := IIf( (TAMSX3( "A2_COD" )[1] ) < 1, 6, (TAMSX3( "A2_COD" )[1] ) )
	Private nTamLoj   := IIf( (TAMSX3( "A2_LOJA" )[1] ) < 1, 6, (TAMSX3( "A2_LOJA" )[1] ) )
	Private lForPad   := .F.
	Private cForPad   := ""

	fFornecPdr( @lForPad, @cForPad )

	//---------------------------------------------
	// Endereca a funcao de BROWSE
	//---------------------------------------------
	dbSelectArea( "SRA" )
	Set Filter To SubStr( SRA->RA_CC, 1, nSizeSA1 + nSizeLo1 ) == cCliMdtps
	dbSetOrder( 1 )
	mBrowse( 6, 1, 22, 75, "SRA", , , , , , fCriaCor() )

	dbSelectArea( "SRA" )
	Set Filter To

	If Type( "aOldRotina" ) != "U"
		aROTINA := aClone( aOldRotina )
	EndIf

	RestArea( aArea )
	cCadastro := cOldCad

Return

//------------------------------------------------------------------
/*/{Protheus.doc} NG695Fil
Filtra EPI pelo campo Devolucao

@return .T.

@author Vitor Emanuel Batista
@since 18/07/08
/*/
//---------------------------------------------------------------------
Function NG695Fil( cAlias, nReg )

	If Pergunte( "MDT695", .T. )
		nEPIDev := MV_PAR01
		dDtEntEpi := MV_PAR02
		NGFUN695( cAlias, nReg, 3 )
	EndIf

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} MDT695PES
Carrega campo de Pesquisa de acordo com o valor do combobox

@return .T.

@author Vitor Emanuel Batista
@since 18/07/08
/*/
//---------------------------------------------------------------------
Static Function MDT695PES( cValPesq, oCombo, oPesq )

	Local nAt	 := oCombo:nAt
	Local cOpcao := IIf( nAt > 0, oCombo:aItems[nAt], "" )
	Local nTa2	 := IIf( ( TAMSX3( "A2_COD" )[1] ) < 1, 6, ( TAMSX3( "A2_COD" )[ 1 ] ) )
	Local nTa2L	 := IIf( ( TAMSX3( "A2_LOJA" )[1] ) < 1, 2, ( TAMSX3( "A2_LOJA" )[ 1 ] ) )

	If cOpcao== STR0085  //"Data de Entrega"
		cValPesq := Space( Len( DToC( dDataBase ) ) )
	ElseIf cOpcao == STR0086  //"Hora de Entrega"
		cValPesq := Space( 5 )
	ElseIf cOpcao == STR0087  //"Código EPI"
		cValPesq := Space( 15 )
	ElseIf cOpcao == STR0088  //"Nome EPI"
		cValPesq := Space( 20 )
	ElseIf cOpcao == STR0089  //"Fornecedor + Loja"
		cValPesq := Space( nTa2 + nTa2L )
	ElseIf cOpcao == STR0090  //"Num. C. A."
		cValPesq := Space( 12 )
	EndIf

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} MDTPes695
Localiza EPI pelo GetDados

@return .T.

@author Vitor Emanuel Batista
@since 18/07/08
/*/
//---------------------------------------------------------------------
Static Function MDTPes695( nOpt, oGet, cFind, cValPesq )

	Local nX
	Local cMsgStop
	Local nStart   := 1
	Local nLinha   := 0
	Local aGridAux := fStructEPI()
	Local aColsAux := aGridAux[ _nCols ]
	Local nAt      :=  aGridAux[ _nAt ]
	Local nColunm  := 0
	Local nColunm2 := 0
	Local nPosEPI  := GdFieldPos( "TNF_CODEPI", aGridAux[ _nHeader ] )
	Local nPosForn := GdFieldPos( "TNF_FORNEC", aGridAux[ _nHeader ] )
	Local nPosLoja := GdFieldPos( "TNF_LOJA", aGridAux[ _nHeader ] )
	Local nPosNuCp := GdFieldPos( "TNF_NUMCAP", aGridAux[ _nHeader ] )
	Local nPosDtEn := GdFieldPos( "TNF_DTENTR", aGridAux[ _nHeader ] )
	Local nPosHrEn := GdFieldPos( "TNF_HRENTR", aGridAux[ _nHeader ] )
	Local nPosDesc := GdFieldPos( "TNF_DESC", aGridAux[ _nHeader ] )

	If nAt > 1
		nStart := IIf( nOpt == 1, nAt - 1, nAt + 1 )
	ElseIf nAt == 1 .And. lPrimeiro
		nStart    := nOpt
		lPrimeiro := .F.
	EndIf

	If cFind == STR0085  //"Data de Entrega"

		cMsgStop := STR0104 //"Não foram localizados EPI's entregues com esta data."
		If nOpt == 2  //Localizar proximo
			nLinha := aScan( aColsAux, { |x| x[nPosDtEn] == CToD( cValPesq ) }, nStart )
		Else
			bExecPesq := { | x, y, z | aColsAux[ x, y ] == CToD( z ) }
			nColunm := nPosDtEn
		EndIf

	ElseIf cFind == STR0086  //"Hora de Entrega"
		cMsgStop := STR0105 //"Não foram localizados EPI's entregues com este horário."
		If nOpt == 2  //Localizar proximo
			nLinha := aScan( aColsAux, { |x| x[nPosHrEn] == cValPesq }, nStart )
		Else
			bExecPesq := { | x, y, z | aColsAux[ x, y ] ==  z }
			nColunm := nPosHrEn
		EndIf
	ElseIf cFind == STR0087  //"Código EPI"
		cMsgStop := STR0106 //"Não foram localizados EPI's entregues com este código."
		If nOpt == 2  //Localizar proximo
			nLinha := aScan( aColsAux, { |x| x[nPOSEpi] == cValPesq }, nStart )
		Else
			bExecPesq := { | x, y, z | AllTrim( aColsAux[ x, y ] ) == AllTrim( z ) }
			nColunm := nPOSEpi
		EndIf
	ElseIf cFind == STR0088  //"Nome EPI"
		cMsgStop := STR0107 //"Não foram localizados EPI's entregues com este nome."
		If nOpt == 2  //Localizar proximo
			nLinha := aScan( aColsAux, { |x| AllTrim( cValPesq ) $ x[nPosDesc] }, nStart )
		Else
			bExecPesq := { | x, y, z | AllTrim( z ) $ AllTrim( aColsAux[ x, y ] ) }
			nColunm := nPosDesc
		EndIf
	ElseIf cFind == STR0089  //"Fornecedor + Loja"
		cMsgStop := STR0108 //"Não foram localizados EPI's entregues com este fornecedor."
		If nOpt == 2  //Localizar proximo
			nLinha := aScan( aColsAux, { |x| x[ nPosForn ] + x[nPosLoja] == cValPesq}, nStart )
		Else
			bExecPesq := { | x, y, z, t | AllTrim( aColsAux[ x, y ] + aColsAux[ x, t ] ) == AllTrim( z ) }
			nColunm := nPosForn
			nColunm2:= nPosLoja
		EndIf

	ElseIf cFind == STR0090  //"Num. C. A."
		cMsgStop := STR0109 //"Não foram localizados EPI's entregues com este certificado de aprovação."
		If nOpt == 2  //Localizar proximo
			nLinha := aScan( aColsAux, { |x| x[nPosNuCp] == cValPesq}, nStart )
		Else
			bExecPesq := { | x, y, z | AllTrim( aColsAux[ x, y ] ) == AllTrim( z ) }
			nColunm := nPosNuCp
		EndIf
	EndIf

	If nOpt == 2
		If nLinha >= nStart
			oGet:oBrowse:nAt := nLinha
			oGet:oBrowse:Refresh()
			oGet:oBrowse:SetFocus()
			If nAt == 1
				lPrimeiro := .T.
			EndIf
		EndIf
	Else
		nLinha := 0
		For nX := nStart To 1 Step -1
			If Eval( bExecPesq, nX, nColunm, cValPesq, nColunm2 )
				nLinha := nX
				Exit
			EndIf
		Next nX

		If nLinha > 0
			oGet:oBrowse:nAt := nLinha
			oGet:oBrowse:Refresh()
			oGet:oBrowse:SetFocus()
			If nAt == 1
				lPrimeiro := .T.
			EndIf
		EndIf

	EndIf

	If nLinha == 0
		Msgstop( cMsgStop, STR0020 )  //"ATENÇÃO"
	EndIf

Return

//------------------------------------------------------------------
/*/{Protheus.doc} fAlterCus
Ordena GetDados conforme opcao do radio button

@param oGet		Object		Objeto da MsNewGetDados dos EPIs (TNF)
@param nOrdem	Numeric		Indica a ordem que deverar estar conforme
pre difinido

@return Nil
@author Denis Hyroshi de Souza
@since 18/07/08
/*/
//---------------------------------------------------------------------
Static Function fAlterCus( oGet, nOrdem )

	Local nPosEPI  := GdFieldPos( "TNF_CODEPI", oGet:aHeader )
	Local nPosForn := GdFieldPos( "TNF_FORNEC", oGet:aHeader )
	Local nPosLoja := GdFieldPos( "TNF_LOJA", oGet:aHeader )
	Local nPosNumC := GdFieldPos( "TNF_NUMCAP", oGet:aHeader )
	Local nPosDtEn := GdFieldPos( "TNF_DTENTR", oGet:aHeader )
	Local nPosHrEn := GdFieldPos( "TNF_HRENTR", oGet:aHeader )
	Local nPosDesc := GdFieldPos( "TNF_DESC", oGet:aHeader )
	Local nAt := oGet:nAt
	Local nLinha
	//FORNEC+TNF_LOJA+TNF_CODEPI+TNF_NUMCAP+TNF_MAT+DTOS(TNF_DTENTR)+TNF_HRENTR
	Local cChave := oGet:aCols[ nAt, nPosForn ] + oGet:aCols[ nAt, nPosLoja ] +;
					oGet:aCols[ nAt, nPosEpi ] + oGet:aCols[ nAt, nPosNumC ] +;
					SRA->RA_MAT + DToS( oGet:aCols[ nAt, nPosDtEn ] ) + oGet:aCols[ nAt, nPosHrEn ]
	Local bBloco

	CursorWait()
	/*
	1- "Data Entrega + Hora Entrega + Código EPI",;
	2- "Código EPI + Data Entrega + Hora Entrega",;
	3- "Nome EPI + Data Entrega + Hora Entrega",;
	4- "Fornecedor + Loja + Código EPI + Data Entrega + Hora Entrega",;
	5- "Código EPI +  Num. C. A.",;
	6- "Num. C. A. + Código EPI";
	*/
	If nOrdem == 1
		bBloco := { |x, y| DToS( x[nPosDtEn] ) + x[nPosHrEn] + x[nPosEpi] < DToS( y[nPosDtEn] ) + y[nPosHrEn] + y[nPosEpi] }
	ElseIf nOrdem == 2
		bBloco := { |x, y| x[nPosEpi] + DToS( x[nPosDtEn] ) + x[nPosHrEn] < y[nPosEpi] + DToS( y[nPosDtEn] ) + y[nPosHrEn] }
	ElseIf nOrdem == 3
		bBloco := { |x, y| x[nPosDesc] + DToS( x[nPosDtEn] ) + x[nPosHrEn] < y[nPosDesc] + DToS( y[nPosDtEn] ) + y[nPosHrEn] }
	ElseIf nOrdem == 4
		bBloco := { |x, y| x[ nPosForn ] + x[nPosLoja] + x[nPosEpi] + DToS( x[nPosDtEn] ) + x[nPosHrEn] < y[ nPosForn ] +;
					 y[nPosLoja] + y[nPosEpi] + DToS( y[nPosDtEn] ) + y[nPosHrEn] }
	ElseIf nOrdem == 5
		bBloco := { |x, y| x[nPosEpi] + x[nPosNumC] + DToS( x[nPosDtEn] ) < y[nPosEpi] + y[nPosNumC] + DToS( y[nPosDtEn] ) }
	ElseIf nOrdem == 6
		bBloco := { |x, y| x[nPosNumC] + x[nPosEpi] + DToS( x[nPosDtEn] ) < y[nPosNumC] + y[nPosEpi] + DToS( y[nPosDtEn] ) }
	EndIf

	If ValType( bBloco ) != "U"
		aSort( oGet:aCols, , , bBloco )
	EndIf
	nLinha := aScan( oGet:aCols, { |x| x[ nPosForn ] + x[ nPosLoja ] + x[ nPosEpi ] + x[ nPosNumC ] +;
					 SRA->RA_MAT + DToS( x[ nPosDtEn ] ) + x[ nPosHrEn ] == cChave } )

	If nLinha > 0
		oGet:oBrowse:nAt := nLinha
	EndIf

	oGet:oBrowse:SetFocus()
	oGet:oBrowse:Refresh()
	CursorArrow()

Return Nil

//------------------------------------------------------------------
/*/{Protheus.doc} MDT695DVPA
Mostra tela de devolucao parcial

@param oGetEpi	Object		Objeto da MsNewGetDados dos EPIs (TNF)
@param nOrdem		Numeric		Indica a ordem que deverar estar conforme
pre difinido

@return Nil

@author Denis Hyroshi de Souza
@since 18/07/08

@obs Uso MDTA695, MDTA630 e MDTA410
/*/
//---------------------------------------------------------------------
Function MDT695DVPA( nOpcx, oGetEpi, cTRBTN3 )

	Local nX
	Local nCps
	Local oDlgDev
	Local oPnlSup
	Local oPnlBot
	Local nOpcTLW  := 0
	Local aGridAux := fStructEPI()
	//aHeader e aCols da TNF
	Local aOldHea := aGridAux[ _nHeader ]
	Local aOldCol := aGridAux[ _nCols ]

	Local cKEY
	Local cD1
	Local nAt        := aGridAux[ _nAt ]
	Local aAreaPosic := {}
	Local aDigTM0    := {}
	Local aReg       := {}
	Local nPosEPI	 := GdFieldPos( "TNF_CODEPI", aOldHea )
	Local nPosForn	 := GdFieldPos( "TNF_FORNEC", aOldHea )
	Local nPosLoja	 := GdFieldPos( "TNF_LOJA", aOldHea )
	Local nPosNumC	 := GdFieldPos( "TNF_NUMCAP", aOldHea )
	Local nPosDtEn	 := GdFieldPos( "TNF_DTENTR", aOldHea )
	Local nPosHrEn	 := GdFieldPos( "TNF_HRENTR", aOldHea )
	Local nPosQtde	 := GdFieldPos( "TNF_QTDENT", aOldHea )
	Local nPosDesc	 := GdFieldPos( "TNF_DESC", aOldHea )
	Local nPosDtDe	 := GdFieldPos( "TNF_DTDEVO", aOldHea )
	Local nPosInDe	 := GdFieldPos( "TNF_INDDEV", aOldHea )
	Local nPosTipoDv := GdFieldPos( "TNF_TIPODV", aOldHea )
	Local nDtReci    := GdFieldPos( "TNF_DTRECI", aOldHea )
	Local nPosQTDDv	 := GdFieldPos( "TNF_QTDEVO", aOldHea )
	Local nPosMatr	 := GdFieldPos( "TNF_MAT", aOldHea )
	Local nPosLocal	 := GdFieldPos( "TNF_LOCAL", aOldHea )
	Local nPosDevBio := GdFieldPos( "TNF_DEVBIO", aOldHea )
	Local nPosLcDv   := GdFieldPos( "TNF_LOCDV", aOldHea )

	Local aArea  := GetArea()

	Private aEpiProg  := {} // Para MDT333EPI
	//Utilizado para MDTLWLINOK -> A695RTACUM
	Private aOldTNF   := aClone( aOldCol )
	Private nSalTNF   := nAt
	Private aBkpTLW   := {} //Utilização em MDTLWLINOK -> A695RTACUM
	Private cLoteSvEn := Space( 10 )
	Private cSublSvEn := Space( 6 )
	Private cAlmoSvEn := IIf( nPosLcDv > 0, aOldCol[ nAt, nPosLcDv ], IIf( nPosLocal > 0, aOldCol[ nAt, nPosLocal ], Space( 2 ) ) )
	Private lDigital  := .F.
	Private oGetTLW695
	Private nQtdadeEn
	Private dDataSvEn
	Private cHoraSvEn
	Private cEpiSvoEn
	Private cFornecEn
	Private cLojaSvEn
	Private cNumCapEn
	Private cDesSb1En
	Private cMatricEn
	Private cNomeFuEn

	// Variaveis Privates para a utilização do X3_WHEN de TLW_QTDEVO,TLW_LOCAL,TLW_TIPODV,TLW_DTDEVO e TLW_HRDEVO
	Private oGetAuxWhen := oGetEpi
	Private aHeadPrin   := aClone( aOldHea )

	Default cTRBTN3 := ""

	aColsTLW  := {}
	aHeadTLW  := {}
	nQtdadeEn := aOldCol[ nAt, nPosQtde ]
	dDataSvEn := aOldCol[ nAt, nPosDtEn ]
	cHoraSvEn :=  IIf( Len( (cAliasTLW)->TLW_HRENTR ) < 8, SubStr( aOldCol[ nAt, nPosHrEn ], 1, 5 ), aOldCol[ nAt, nPosHrEn ] )

	If IsInCallStack( "MDTA695" ) .Or. IsInCallStack( "MDTA410" )
		//Busca o aCols
		cEpiSvoEn := aOldCol[ nAt, nPosEPI ]
		cFornecEn := aOldCol[ nAt, nPosForn ]
		cLojaSvEn := aOldCol[ nAt, nPosLoja ]
		cNumCapEn := aOldCol[ nAt, nPosNumC ]
		cDesSb1En := aOldCol[ nAt, nPosDesc ]
		cMatricEn := SRA->RA_MAT
		cNomeFuEn := SRA->RA_NOME

	ElseIf IsInCallStack( "MDTA630" )

		cEpiSvoEn := ( cTRBTN3 )->CODEPI
		cFornecEn := ( cTRBTN3 )->FORNEC
		cLojaSvEn := ( cTRBTN3 )->LOJA
		cNumCapEn := ( cTRBTN3 )->NUMCAP
		cDesSb1En := NGSEEK( "SB1", cEpiSvoEn, 1, "B1_DESC" )
		cMatricEn := aOldCol[ nAt, nPosMatr ]
		cNomeFuEn := NGSEEK( "SRA", cMatricEn, 1, "RA_NOME" )

	EndIf

	cKEY := cFornecEn + cLojaSvEn + cEpiSvoEn + cNumCapEn + cMatricEn + DtoS( dDataSvEn ) + cHoraSvEn

	lRet := fValidDevEpi( cKEY, aOldHea, aOldCol, nAt )

	If lRet

		fCarregaCols( cKey, @aHeadTLW, @aColsTLW )

		aOld_TLW := aClone( aColsTLW )
		aBkpTLW := aClone( aColsTLW )
		oDlgDev := MSDialog():New( 0, 0, 410, 815, STR0134, , , , , CLR_BLACK, CLR_WHITE, , GetWndDefault(), .T. ) //"Devolução Parcial"

		oPnlAll := TPanel():New( 0, 0, , oDlgDev, , , , , , 12, 12, .F., .F. )
		oPnlAll:Align := CONTROL_ALIGN_ALLCLIENT

		oPnlTop := TPanel():New( 0, 0, , oPnlAll, , , , , , 12, 80, .F., .F. )
		oPnlTop:Align := CONTROL_ALIGN_TOP

		TSay():New( 07, 05, { || OemToAnsi( STR0005 ) }, oPnlTop, , , , , , .T. ) //"Matricula"
		TGet():New( 06, 40, { || MDTHideCpo( cMatricEn, "RA_MAT" ) }, oPnlTop, 30, 06, "@!", , , , , , , .T., , , { || .F. } )

		TSay():New( 07, 80, { || OemToAnsi( STR0006 ) }, oPnlTop, , , , , , .T. ) //"Nome"
		TGet():New( 06, 100, { || MDTHideCpo( cNomeFuEn, "RA_NOME" ) }, oPnlTop, 150, 06, "@!", , , , , , , .T., , , { || .F. } )

		TSay():New( 25, 05, { || OemToAnsi( STR0129 ) }, oPnlTop, , , , , , .T. ) //"Fornecedor"
		TGet():New( 24, 40, { || cFornecEn }, oPnlTop, 30, 06, "@!", , , , , , , .T., , , { || .F. } )

		TSay():New( 25, 80, { || OemToAnsi( STR0130 ) }, oPnlTop, , , , , , .T. ) //"Loja"
		TGet():New( 24, 100, { || cLojaSvEn }, oPnlTop, 10, 06, "@!", , , , , , , .T., , , { || .F. } )

		TSay():New( 25, 125, { || OemToAnsi( STR0145 ) }, oPnlTop, , , , , , .T. ) //"Nome Fornecedor"
		TGet():New( 24, 180, { || Posicione( "SA2", 1, xFilial( "SA2" ) + cFornecEn + cLojaSvEn, "A2_NOME" ) },;
					 oPnlTop, 120, 06, "@!", , , , , , , .T., , , { || .F. } )

		TSay():New( 43, 05, { || OemToAnsi( STR0044 ) }, oPnlTop, , , , , , .T. ) //"Epi"
		TGet():New( 42, 15, { || cEpiSvoEn }, oPnlTop, 160, 06, "@!", , , , , , , .T., , , { || .F. } )

		TSay():New( 43, 190, { || OemToAnsi( STR0215 ) }, oPnlTop, , , , , , .T. ) //"Descrição"
		TGet():New( 42, 220, { || cDesSb1En }, oPnlTop, 160, 06, "@!", , , , , , , .T., , , { || .F. } )

		TSay():New( 61, 05, { || OemToAnsi( STR0146 ) }, oPnlTop, , , , , , .T. ) //"Num. C.A."
		TGet():New( 60, 40, { || cNumCapEn }, oPnlTop, 70, 06, "@!", , , , , , , .T., , , { || .F. } )

		TSay():New( 61, 120, { || OemToAnsi( STR0147 ) }, oPnlTop, , , , , , .T. ) //"Data Entrega"
		TGet():New( 60, 155, { || dDataSvEn }, oPnlTop, 50, 06, "@!", , , , , , , .T., , , { || .F. }, , , , , , , , , , , .T. )

		TSay():New( 61, 210, { || OemToAnsi( STR0148 ) }, oPnlTop, , , , , , .T. ) //"Hora Entrega"
		TGet():New( 60, 250, { || cHoraSvEn }, oPnlTop, 05, 06, "@!", , , , , , , .T., , , { || .F. }, , , , , , , , , , , .T. )

		TSay():New( 61, 287, { || OemToAnsi( STR0149 ) }, oPnlTop, , , , , , .T. ) //"Qtde. Entregue"
		TGet():New( 60, 325, { || nQtdadeEn }, oPnlTop, 12, 06, "@E 999.99", , , , , , , .T., , , { || .F. }, , , , , , , , , , , .T. )

		oPnlBot := TPanel():New( 0, 0, , oPnlAll, , , , , , 12, 12, .F., .F. )
		oPnlBot:Align := CONTROL_ALIGN_ALLCLIENT

		dbSelectArea( "TLW" )
		oGetTLW695 := MsNewGetDados():New( 1, 1, 1, 1, IIf( nOpcx != 3 .And. nOpcx != 4, 0, GD_INSERT + GD_UPDATE + GD_DELETE ),;
										 , , , , , 999999, , , , oPnlBot, @aHeadTLW, @aColsTLW )
		oGetTLW695:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
		oGetTLW695:bDelOk        := { | | NGTLWExcC( oGetTLW695 ) }
		oGetTLW695:bLinhaOk      := { | | MDTLWLinOk( oGetTLW695 ) }
		oGetTLW695:bTudoOk       := { | | MDTLWAllOk( oGetTLW695 ) }
		oGetTLW695:bChange       := { | | fChange2( oGetTLW695 ) }

		ACTIVATE MSDIALOG oDlgDev ON INIT EnchoiceBar( oDlgDev, { | | nOpcTLW := 1, IIf( oGetTLW695:TudoOk(), oDlgDev:End(), nOpcTLW := 0 ) },;
														{ | | oDlgDev:End(), nOpcTLW := 0 } ) CENTERED

		If nOpcTLW == 1
			nPosDtDev := GdFieldPos( "TLW_DTDEVO", oGetTLW695:aHeader )
			nPosHrDev := GdFieldPos( "TLW_HRDEVO", oGetTLW695:aHeader )
			nPosQtDev := GdFieldPos( "TLW_QTDEVO", oGetTLW695:aHeader )
			nPosTpDev := GdFieldPos( "TLW_TIPODV", oGetTLW695:aHeader )
			nPosLocDev:= GdFieldPos( "TLW_LOCAL", oGetTLW695:aHeader )

			nTotalDig := 0
			cTipoDevo := "1"
			dDtDevoMa := SToD( Space( 8 ) )
			cHrDevoMa := "00:00"
			aColsTLW := aClone( oGetTLW695:aCols )
			For nX := 1 To Len( aColsTLW )

				If ValType( lMsErroAuto ) != "L" .Or. !lMsErroAuto
					dbSelectArea( cAliasTLW )
					dbSetOrder( 1 )//TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)
					If dbSeek( cKey + DToS( aColsTLW[ nX, nPosDtDev ] ) + aColsTLW[ nX, nPosHrDev ] )
						RecLock( cAliasTLW, .F. )
					Else
						RecLock( cAliasTLW, .T. )
					EndIf

					If !aTail( aColsTLW[ nX ] )

						(cAliasTLW)->TLW_FILIAL := xFilial( "TLW" )
						(cAliasTLW)->TLW_FORNEC := cFornecEn
						(cAliasTLW)->TLW_LOJA   := cLojaSvEn
						(cAliasTLW)->TLW_CODEPI := cEpiSvoEn
						(cAliasTLW)->TLW_NUMCAP := cNumCapEn
						(cAliasTLW)->TLW_MAT    := cMatricEn
						(cAliasTLW)->TLW_DTENTR := dDataSvEn
						(cAliasTLW)->TLW_HRENTR := cHoraSvEn

						For nCps := 1 To Len( aHeadTLW )
							If aHeadTLW[ nCps, 2 ] == "TLW_QTDEVO" .And. (cALiasTLW)->TLW_QTDEVO != aColsTLW[ nX, nCps ]
								(cAliasTLW)->TLW_ALTERA := "X"
							EndIf

							( cAliasTLW )->&(  aHeadTLW[ nCps, 2 ] ) := aColsTLW[ nX, nCps ]

						Next nCps

						nTotalDig += aColsTLW[ nX, nPosQtDev ]
					Else
						(cAliasTLW)->TLW_DELETE := _DELETADO
					EndIf

					( cAliasTLW )->( MsUnLock() )
				EndIf
			Next nX

			dbSelectArea( cAliasTLW )
			dbSetOrder( 1 )//TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)
			dbSeek( cKey )
			While (cAliasTLW)->( !Eof() ) .And. (cAliasTLW)->( TLW_FORNEC + TLW_LOJA + TLW_CODEPI + TLW_NUMCAP +;
				 TLW_MAT + DToS( TLW_DTENTR ) + TLW_HRENTR ) == cKey

				If ( aScan( aColsTLW, { | x | (cAliasTLW)->TLW_DTDEVO == x[ nPosDtDev ] .And. ;
					(cAliasTLW)->TLW_HRDEVO == x[ nPosHrDev ] .And. ;
					IIf( nPosTpDev > 0, (cAliasTLW)->TLW_TIPODV == x[ nPosTpDev ], .T. ) .And. ;
					IIf( nPosLocDev > 0, AllTrim( (cAliasTLW)->TLW_LOCAL ) == AllTrim( x[ nPosLocDev ] ), .T. ) ;
					} ) ) == 0

					RecLock( cAliasTLW, .F. )
						( cAliasTLW )->( dbDelete() )
					( cAliasTLW )->( MsUnLock() )
				EndIf

				( cAliasTLW )->( dbSkip() )
			End

			//Ordenando por data+hora devolucao
			aSort( aColsTLW, , , { |x, y| DToS( x[ nPosDtDev ] ) + x[ nPosHrDev ] > DToS( y[ nPosDtDev ] ) + y[ nPosHrDev ] .And. !aTail( x ) } )
			dDtDevoMa := aColsTLW[ 1, nPosDtDev ]
			cHrDevoMa := aColsTLW[ 1, nPosHrDev ]
			If nPosLocDev > 0
				cArmDevo  := aColsTLW[ 1, nPosLocDev ]
			EndIf
			If nPosTpDev > 0
				cTipoDevo := aColsTLW[ 1, nPosTpDev ]
			EndIf

			If nTotalDig == nQtdadeEn
				aOldCol[ nAt, nPosInDe ] := "1"
				aOldCol[ nAt, nPosDtDe ] := dDtDevoMa
				If nPosLcDv > 0 .And. nPosLocDev > 0
					aOldCol[ nAt, nPosLcDv ] := cArmDevo
				EndIf
				If nPosTipoDv > 0 .And. nPosTpDev > 0
					aOldCol[ nAt, nPosTipoDv ] := cTipoDevo
				EndIf
			Else
				aSort( aBkpTLW, , , { |x, y| DToS( x[ nPosDtDev ] ) + x[ nPosHrDev ] > DToS( y[ nPosDtDev ] ) + y[ nPosHrDev ] .And. !aTail( x ) } )
				If !ArrayCompare( aColsTLW, aBkpTLW )
					aOldCol[ nAt, nPosInDe ] := "2"
					aOldCol[ nAt, nPosDtDe ] := SToD( "" )
					If nPosTipoDv > 0
						aOldCol[ nAt, nPosTipoDv ] := " "
					EndIf
				EndIf
			EndIf

			aOldCol[ nAt, nPosQTDDv ] := nTotalDig
			If nPosDevBio > 0 .And. lDigital
				aOldCol[ nAt, nPosDevBio ] := "1"
			EndIf

			If IsInCallStack( "MDTA695" ) .Or. IsInCallStack( "MDTA410" )
				oGetEPI:aCols := aClone( aOldCol )
				fChg695GD( oGetEpi )
			ElseIf IsInCallStack( "MDTA630" )
				aCols := aClone( aOldCol )
				fChg630GD()
			EndIf
		EndIf
	EndIf
	oGetEPI:Refresh()
	oGetEPI:oBrowse:SetFocus()
	RestArea( aArea )

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} MDTLWLINOK
Função auxiliar da MDT695DVPA o bloco bLinhaOk da MsGetDados da TLW

@param oGetEpi	Object	Objeto da MsNewGetDados dos EPIs devolvidos (TLW)

@return lRet	Boolean	Indica se foi reprovado a linha (.F.), conforme regra

@author Guilherme Benkendorf
@since 15/06/2015
@obs Uso MDTA695
/*/
//---------------------------------------------------------------------
Function MDTLWLINOK( oGet )

	Local nPosDtDev := GdFieldPos( "TLW_DTDEVO", oGet:aHeader )
	Local nPosHrDev := GdFieldPos( "TLW_HRDEVO", oGet:aHeader )
	Local nPosQtDev := GdFieldPos( "TLW_QTDEVO", oGet:aHeader )
	Local nPosLocDev:= GdFieldPos( "TLW_LOCAL", oGet:aHeader )
	Local nPosTpDev := GdFieldPos( "TLW_TIPODV", oGet:aHeader )
	Local lRet      := .T.
	Local aColsAux  := oGet:aCols
	Local nAt       := oGet:nAt
	Local cMsg      := ""
	Local aArea     := GetArea()
	Local nX

	If !aTail( aColsAux[ nAt ] )
		If !Positivo( aColsAux[ nAt, nPosQtDev ] )
			lRet := .F.
		EndIf

		For nX := 1 To Len( aColsAux )
			If !aTail( aColsAux[ nX ] ) .And. nX != nAt
				If aColsAux[ nAt, nPosDtDev ] == aColsAux[ nX, nPosDtDev ] .And. aColsAux[ nAt, nPosHrDev ] == aColsAux[ nX, nPosHrDev ]
					Help( " ", 1, STR0026, STR0026, Alltrim( Memoline( STR0150, 40, 1 ) ) + CRLF + Memoline( STR0150, 40, 2 ), 3, 4 ) // "ATENCAO"###"ATENCAO"////"Já existe registro com a mesma Data/Hora Devolução."
					lRet := .F.
					Exit
				EndIf
			EndIf
		Next nX

		If lRet .And. Empty( aColsAux[ nAt, nPosDtDev ] )
			cMsg := STR0151 //"O campo Dt Devolucao é obrigatório."
			lRet := .F.
		EndIf

		If lRet .And. Empty( aColsAux[ nAt, nPosHrDev ] ) .Or. Alltrim( aColsAux[ nAt, nPosHrDev ] ) == ":"
			cMsg := STR0152 //"O campo Hr Devolucao é obrigatório."
			lRet := .F.
		EndIf

		If lRet .And. Empty( aColsAux[ nAt, nPosQtDev ] )
			cMsg := STR0153 //"O campo Quant. Devo. é obrigatório."
			lRet := .F.
		EndIf

		If lRet .And. aColsAux[ nAt, nPosDtDev ] > dDatabase
			cMsg := STR0113 //"Data da devolução não poderá ser superior à data atual"
			lRet := .F.
		EndIf

		If cUsaInt1 == "S"
			If lRet .And. Empty( aColsAux[ nAt, nPosTpDev ] )
				cMsg := STR0154 //"O campo Repor Estoq. é obrigatório."
				lRet := .F.
			EndIf

			If lRet .And. Empty( aColsAux[ nAt, nPosLocDev ] )
				Help( " ", 1, STR0026, STR0026, STR0155, 3, 4 ) // "ATENCAO"###"ATENCAO"###"O campo Almoxarifado é obrigatório."
				cMsg := STR0155 //"O campo Almoxarifado é obrigatório."
				lRet := .F.
			Else
				dbSelectArea( "SB2" )
				dbSetOrder( 1 )
				If lRet .And. !dbSeek( xFilial( "SB2" ) + cEpiSvoEn + aColsAux[ nAt, nPosLocDev ] )
					cMsg := STR0156 //"Este Almoxarifado não existe."
					lRet :=  .F.
				EndIf
				If lRet .And. cUsaRast == "S"
					If !Empty( cSublSvEn ) .And. !Empty( cLoteSvEn )
						dbSelectArea( "SB8" )
						dbSetOrder( 02 )
						If lRet .And. !(dbSeek( xFilial( "SB8" ) + cSublSvEn ) .And. cLoteSvEn + cEpiSvoEn +;
							 aColsAux[ nAt, nPosLocDev ] == SB8->B8_LOTECTL + SB8->B8_PRODUTO + SB8->B8_LOCAL )
							cMsg := STR0193 //"O Sub-Lote do produto não existe no almoxarifado informado."
							lRet := .F.
						Else
							If lRet .And. aColsAux[ nAt, nPosTpDev ] == "1"
								nAcumulado := A695RTACUM( 1, cEpiSvoEn, aColsAux[ nAt, nPosLocDev ], cLoteSvEn, cSublSvEn, , , .F., .T. )
								If QtdComp( SB8SALDO( , , , , , , , , .T. ) + nAcumulado ) > QtdComp( SB8->B8_QTDORI )
									Help( " ", 1, "A240LOTQTD" )
									lRet := .F.
								EndIf
							EndIf
						EndIf
					ElseIf !Empty( cLoteSvEn )
						dbSelectArea( "SB8" )
						dbSetOrder( 03 )
						If lRet .And. !dbSeek( xFilial( "SB8" ) + cEpiSvoEn + aColsAux[ nAt, nPosLocDev ] + cLoteSvEn )
							cMsg := STR0194 //"O Lote do produto não existe no almoxarifado informado."
							lRet := .F.

						Else
							If lRet .And. aColsAux[ nAt, nPosTpDev ] == "1"
								nAcumulado := A695RTACUM( 2, cEpiSvoEn, aColsAux[ nAt, nPosLocDev ], cLoteSvEn, , , , .F., .T. )
								If QtdComp( SB8SALDO( , , , , , , , , .T. ) + nAcumulado ) > QtdComp( SB8->B8_QTDORI )
									Help( " ", 1, "A240LOTQTD" )
									lRet := .F.
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
			// Valida se Reporta Estoque...

			nPosAnt := aScan( aBkpTLW, { | x | 	x[ nPosDtDev ] == aColsAux[ nAt, nPosDtDev ] .And.;
			x[ nPosHrDev ] == aColsAux[ nAt, nPosHrDev ] .And.;
			x[ nPosQtDev ] == aColsAux[ nAt, nPosQtDev ] .And.;
			x[ nPosLocDev ] == aColsAux[ nAt, nPosLocDev ] .And.;
			x[ nPosTpDev ] == aColsAux[ nAt, nPosTpDev ] } )
			nPos_TLW := aScan( aBkpTLW, { | x |	x[ nPosDtDev ] == aColsAux[ nAt, nPosDtDev ] .And.;
			x[ nPosHrDev ] == aColsAux[ nAt, nPosHrDev ] .And.;
			x[ nPosQtDev ] == aColsAux[ nAt, nPosQtDev ] .And.;
			x[ nPosLocDev ] == aColsAux[ nAt, nPosLocDev ] } )

			lA01B02 := nPos_TLW > 0 .And. aColsAux[ nAt, nPosTpDev ] == "1" .And. aBkpTLW[nPos_TLW, nPosTpDev ] == "2"

			If (nPosAnt == 0 .And. aColsAux[ nAt, nPosTpDev ] == "1") .Or. lA01B02
				If lRet .And. !MDTTLWDTHO( 3, .T., lA01B02 )
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	If !lRet .And. !Empty( cMsg )
		HELP( " ", 1, STR0026, STR0026, cMsg, 3, 4 ) // "ATENCAO"###"ATENCAO"
	EndIf

	PutFileInEof( "TLW" )

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} MDTLWALLOK
Função auxiliar da MDT695DVPA o bloco bTudoOk da MsGetDados da TLW

@param oGetEpi	Object	Objeto da MsNewGetDados dos EPIs devolvidos (TLW)

@return lRet		Boolean	Indica se foi reprovado a linha (.F.), conforme regra

@author Guilherme Benkendorf
@since 15/06/2015

@obs Uso MDTA695
/*/
//---------------------------------------------------------------------
Function MDTLWALLOK( oGet )

	Local nPosQtDev := GdFieldPos( "TLW_QTDEVO", oGet:aHeader )
	Local nX
	Local nTotalDig := 0

	Local lRet := .T.
	Local cMsg := STR0137 //"A quantidade devolvida não pode ser maior que a quantidade entregue."

	For nX := 1 To Len( oGet:aCols )
		If !aTail( oGet:aCols[ nX ] )
			nTotalDig += oGet:aCols[ nX, nPosQtDev ]
		EndIf
	Next nX

	If nTotalDig > nQtdadeEn
		Help( " ", 1, STR0026, STR0026, Alltrim( Memoline( cMsg, 40, 1 ) ) +;
		CRLF + Memoline( cMsg, 40, 2 ), 3, 4 ) // "ATENCAO"###"ATENCAO"
		lRet := .F.
	EndIf

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} MDTTLWDTHO
Função auxiliar da MDT695DVPA o bloco bTudoOk da MsGetDados da TLW

@param nTipo		Numeric		Indica que campo será verificado
1 - TLW_DTDEVO / 2 - TLW_HRDEVO /
3- Data Devolução no aCols chamado pelo bTudoOk

@param lViaProg	Boolean		Se a chamada da funcao é realizada atraves do programa
@param lRequis	Boolean		Se reporta o armazem deverá ser validado o MV_ULMES

@return lRet		Boolean	Indica se foi reprovado a linha (.F.), conforme regra

@author Guilherme Benkendorf
@since 15/06/2015

@obs Uso X3_VALID -> TLW_DTDEVO
@obs Uso X3_VALID -> TLW_HRDEVO
/*/
//---------------------------------------------------------------------
Function MDTTLWDTHO( nTipo, lViaProg, lRequis )

	Local nAt        := oGetTLW695:nAt
	Local cMsg1      := STR0157 //"A Data Devolução não pode ser menor que a Data Entrega."
	Local cMsg2      := STR0158 //"A Hora Devolução não pode ser menor que a Hora Entrega."
	Local aHeaderTLW := oGetTLW695:aHeader
	Local aColsAux   := oGetTLW695:aCols[ nAt ]
	Local nPosDtDev  := GdFieldPos( "TLW_DTDEVO", aHeaderTLW )
	Local nPosTpDev  := GdFieldPos( "TLW_TIPODV", aHeaderTLW )
	Local dDataBloq  := SuperGetMv( "MV_DBLQMOV" ) //Data para bloqueio de movimentos.
	Local lVldUlMes  := .T.
	Local lRet       := .T.

	Default lViaProg:= .F.
	Default lRequis := .F.

	If nTipo == 1 .Or. nTipo == 3 //Valida Data

		If nTipo == 3
			M->TLW_DTDEVO := aColsAux[ nPosDtDev ]
		EndIf

		lRet := NaoVazio( M->TLW_DTDEVO )

		If lRet .And. M->TLW_DTDEVO < dDataSvEn
			Help( " ", 1, STR0026, STR0026, Alltrim( Memoline( cMsg1, 40, 1 ) )+ CRLF + Memoline( cMsg1, 40, 2 ), 3, 4 ) // "ATENCAO"###"ATENCAO"
			lRet := .F.
		EndIf
		If lRet .And. M->TLW_DTDEVO > dDatabase
			Help( " ", 1, STR0026, , STR0113, 4, 5 ) //"Data da devolução não poderá ser superior à data atual"
			lRet := .F.
		EndIf

		If lRet .And. Type( "lHist695" ) == "L" .And. lHist695 //Se for histórico
			If M->TLW_DTDEVO >= dDataBase
				Help( " ", 1, STR0026, , STR0169 + CRLF +; //"Não pode ser digitada data igual ou maior do que a data atual,"
					STR0170, 4, 5 ) //"Atenção" //"pois esta rotina serve para adicionar informações no histórico."
				lRet := .F.
			EndIf
		EndIf

		If cUsaInt1 == "S"
			dDataUlMes := GetMV( 'MV_ULMES' )

			lVldUlMes := nPosTpDev > 0 .And. aColsAux[ nPosTpDev ] == "1"

			If lRet .And. ( lVldUlMes .Or. lRequis )

				//Se o usuario alterou o conteudo do campo
				If aColsAux[ nPosDtDev ] != M->TLW_DTDEVO .Or. lViaProg
					//---------------------------------------------------
					// Verificar data do ultimo fechamento do Estoque.
					//---------------------------------------------------
					If dDataUlMes >= M->TLW_DTDEVO
						MsgInfo( STR0159 + CRLF +; //"Não pode ser digitada devolução com data anterior"
							STR0160 + CRLF + CRLF + ; //"ou igual à última data de fechamento do estoque."
							STR0161 + DTOC( dDataUlMes ), STR0144 ) //"Atenção" //"Data de fechamento do estoque: "
						lRet := .F.
					EndIf
				EndIf

				If M->TLW_DTDEVO <= dDataBloq .And. !Empty( M->TLW_DTDEVO ) .And. lRet//verifica a data de bloqueio
					ShowHelpDlg( STR0020, { STR0241 }, 1, { STR0242 }, 2 )//ATENÇÃO # "A data informado está bloqueada para movimentos." # "Favor verificar o parâmetro MV_DBLQMOV."
					Return .F.
				EndIf
			EndIf
		EndIf
	ElseIf nTipo == 2 //Valida Hora
		If !NgValHora( M->TLW_HRDEVO, .T. )
			lRet := .F.
		EndIf
		If lRet .And. !Empty( aColsAux[ nPosDtDev ] ) .And. aColsAux[ nPosDtDev ] == dDataSvEn .And. M->TLW_HRDEVO < cHoraSvEn
			Help( " ", 1, STR0026, STR0026, Alltrim( Memoline( cMsg2, 40, 1 ) ) + CRLF + Memoline( cMsg2, 40, 2 ), 3, 4 ) // "ATENCAO"###"ATENCAO"
			lRet := .F.
		EndIf
	EndIf

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} MDTTLWEDIT
Verifica se foi alterado a tela de Devolucao Parcial

@param nTipo	Numeric		Indica que campo será verificado
1 - TLW_DTDEVO / 2 - TLW_HRDEVO /
3- Data Devolução no aCols chamado pelo bTudoOk

@param nTipo	Numeric		Se a chamada da funcao é realizada atraves do
1 = MDTA695 / 2 = MDTA630

@author Guilherme Benkendorf
@since 15/06/2015

@obs Uso MDTA695 / MDTA630

/*/
//---------------------------------------------------------------------
Function MDTTLWEDIT( nTipo )

	Local aGridAux := fStructEPI()
	Local aColsAux := {}
	Local cKeyTmp
	Local nAt      := aGridAux[ _nAt ]
	Local nPosEPI  := GdFieldPos( "TNF_CODEPI", aGridAux[ _nHeader ] )
	Local nPosForn := GdFieldPos( "TNF_FORNEC", aGridAux[ _nHeader ] )
	Local nPosLoja := GdFieldPos( "TNF_LOJA", aGridAux[ _nHeader ] )
	Local nPosNumC := GdFieldPos( "TNF_NUMCAP", aGridAux[ _nHeader ] )
	Local nPosDtEn := GdFieldPos( "TNF_DTENTR", aGridAux[ _nHeader ] )
	Local nPosHrEn := GdFieldPos( "TNF_HRENTR", aGridAux[ _nHeader ] )
	Local nPosMatr := GdFieldPos( "TNF_MAT", aGridAux[ _nHeader ] )
	Local lAltTLW := .F.

	aColsAux:= aGridAux[ _nCols, nAt ]

	If nTipo == 1
		cKeyTmp := aColsAux[ nPosForn ] + aColsAux[ nPosLoja ] + aColsAux[ nPosEPI ] + aColsAux[ nPosNumC ] + SRA->RA_MAT +;
					 DtoS( aColsAux[ nPosDtEn ] ) + IIf( Len( (cAliasTLW)->TLW_HRENTR ) < 8, SubStr( aColsAux[ nPosHrEn ], 1, 5 ), aColsAux[ nPosHrEn ] )
		cCondTLW:= "TLW->TLW_FILIAL+TLW->TLW_FORNEC+TLW->TLW_LOJA+TLW->TLW_CODEPI+TLW->TLW_NUMCAP+TLW->TLW_MAT+DTOS(TLW->TLW_DTENTR)+TLW->TLW_HRENTR"
	Else
		cKeyTmp := aColsAux[ nPosMatr ] + DtoS( aColsAux[ nPosDtEn ] ) +;
					IIf( Len( (cAliasTLW)->TLW_HRENTR ) < 8, SubStr( aColsAux[ nPosHrEn ], 1, 5 ), aColsAux[ nPosHrEn ] )
		cCondTLW:= "TLW->TLW_MAT+DTOS(TLW->TLW_DTENTR)+TLW->TLW_HRENTR"
	EndIf

	dbSelectArea( "TLW" )
	dbSetOrder( 1 )//TLW_FILIAL+TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+TLW_DTDEVO+TLW_HRDEVO
	If dbSeek( xFilial( "TLW" ) + cKeyTmp )
		While TLW->( !Eof() ) .And. xFilial( "TLW" ) + cKeyTmp == &cCondTLW
			dbSelectArea( cAliasTLW )
			dbSetOrder( 1 )//TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)
			If dbSeek( cKeyTmp )
				If DToS( TLW->TLW_DTDEVO ) != DToS( (cAliasTLW)->TLW_DTDEVO ) .Or. TLW->TLW_HRDEVO != (cAliasTLW)->TLW_HRDEVO
					lAltTLW := .T.
					Exit
				EndIf
			Else
				lAltTLW := .T.
				Exit
			EndIf
			TLW->( dbSkip() )
		End
	EndIf

Return lAltTLW

//------------------------------------------------------------------
/*/{Protheus.doc} TNFColBmp
Adiciona a coluna BMP no aHeader e aCols

@param nTipoChm		Numeric		Indica que campo será verificado
1 - TLW_DTDEVO / 2 - TLW_HRDEVO /
3- Data Devolução no aCols chamado pelo bTudoOk

@param aHeaderAtu	Array			Cabeçalho da TNF para adicionar posição da legenda
@param aColsAtu		Array			Registros da TNF para adicionar a legenda conforme
regra

@author Denis Hyroshi de Souza
@since 15/01/09

@obs Uso MDTA695 / MDTA630
/*/
//---------------------------------------------------------------------
Function TNFColBmp( nTipoChm, aHeaderAtu, aColsAtu )

	Local nCnt
	Local aHeaderAux
	Local aTmp
	Local lRet      := .F.
	Local lEmpty    := .F.
	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lLogix	:= cMDTInteg == "2"
	Local lRetCons  := .F.
	Local cCodEpi   := " "
	Local cLegenda  := IIf( lLogix, "", "BR_VERDE" )

	//Posições do aHeader
	Local nPosInDe
	Local nPosTipoDv
	Local nPosNSA
	Local nPosISA
	Local nPosEpi
	Local nPosQtde
	Local nPosDtEn
	Local nPosLocal
	Local nPosSaiLog
	Local nPosEntLog

	Default aHeaderAtu := aHeader
	Default aColsAtu   := aCols

	nPosForn  := GdFieldPos( "TNF_FORNEC", aHeaderAtu )
	nPosLoja  := GdFieldPos( "TNF_LOJA", aHeaderAtu )
	nPosNumC  := GdFieldPos( "TNF_NUMCAP", aHeaderAtu )
	nPosInDe  := GdFieldPos( "TNF_INDDEV", aHeaderAtu )
	nPosTipoDv:= GdFieldPos( "TNF_TIPODV", aHeaderAtu )
	nPosNSA   := GdFieldPos( "TNF_NUMSA", aHeaderAtu )
	nPosISA   := GdFieldPos( "TNF_ITEMSA", aHeaderAtu )
	nPosEPI   := GdFieldPos( "TNF_CODEPI", aHeaderAtu )
	nPosQtde  := GdFieldPos( "TNF_QTDENT", aHeaderAtu )
	nPosDtEn  := GdFieldPos( "TNF_DTENTR", aHeaderAtu )
	nPosHrEn  := GdFieldPos( "TNF_HRENTR", aHeaderAtu )
	nPosLocal := GdFieldPos( "TNF_LOCAL", aHeaderAtu )
	nPosSaiLog:= GdFieldPos( "TNF_SAILOG", aHeaderAtu )
	nPosEntLog:= GdFieldPos( "TNF_ENTLOG", aHeaderAtu )
	nPosMatr  := GdFieldPos( "TNF_MAT", aHeaderAtu )
	nPosObs   := GdFieldPos( "TNF_OBSLOG", aHeaderAtu )

	If nPosInDe > 0
		lRet := .T.
		aHeaderAux := aClone( aHeaderAtu )
		aHeaderAtu := {}
		aAdd( aHeaderAtu, {	"", "COLBMP", "@BMP", 11, 0, "", Chr( 251 ), "C", "", "V" } )

		aEval( aHeaderAux, { | x | aAdd( aHeaderAtu, aClone( x ) ) } )

		If Len( aColsAtu ) == 0
			aColsAtu := BlankGetd( aHeaderAtu )
			lEmpty := .T.
		EndIf
		If !lEmpty
			For nCnt := 1 To Len( aColsAtu )
				aTmp := aClone( aColsAtu[nCnt] )
				aColsAtu[nCnt] := {}
				cCodEpi := IIf( nTipoChm == 2, TN3->TN3_CODEPI, aTmp[nPosEpi] )

				If lLogix

					cMDTSerie  := "CONSULTA"
					cMdtStatus := ""
					cMdtReserva:= ""
					If !Empty( aTmp[ nPosEntLog ] )
						cMDTNumRes:= aTmp[ nPosEntLog ]
					Else
						cMDTNumRes:= aTmp[ nPosSaiLog ]
					EndIf
					If nPosTipoDv > 0 .And. aTmp[ nPosTipoDv ] == "2" .And. aTmp[ nPosInDe ] == "1"
						cLegenda := "BR_CINZA"
					ElseIf aTmp[ nPosInDe ] != "2" .Or. ( aTmp[ nPosInDe ] == "2" .And. !Empty( aTmp[ nPosEntLog ] ) )
						If !Empty( cMDTNumRes )

							If nTipoChm == 2
								dbSelectArea( "SRA" )
								dbSetOrder( 1 )
								dbSeek( xFilial( "SRA" ) + aTmp[ nPosMatr ] )
							EndIf

							dbSelectArea( "SB1" )
							dbSetOrder( 1 )
							dbSeek( xFilial( "SB1" ) + cCodEpi )

							//Campo CC
							If FindFunction( "MDTCCFunc" )
								cCCSCP := MDTCCFunc( SRA->RA_MAT, SRA->RA_CC, aTmp[ nPosDtEn ] )
							Else
								cCCSCP := SRA->RA_CC
							EndIf

							//Campo Observação
							If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
								cObsSCP	:= SubStr( AllTrim( M->CP_OBS ) + " " + aTmp[ nPosObs ], 1, 180 )
							Else
								cObsSCP	:= STR0166 + ": " + SRA->RA_FILIAL + "-" + SRA->RA_MAT //"FUNCIONARIO"
							EndIf

							dbSelectArea( "SCP" )
							RegToMemory( "SCP", .T. )
							M->CP_PRODUTO := cCodEpi
							M->CP_UM      := SB1->B1_UM
							M->CP_QUANT   := aTmp[ nPosQtde ]
							M->CP_DATPRF  := aTmp[ nPosDtEn ]
							M->CP_LOCAL   := aTmp[ nPosLocal ]
							M->CP_EMISSAO := dDataBase
							M->CP_DESCRI  := SB1->B1_DESC
							M->CP_SOLICIT := cUserName
							M->CP_CC      := IIf( FindFunction( "MDTCCFunc" ), MDTCCFunc( SRA->RA_MAT, SRA->RA_CC, aTmp[ nPosDtEn ] ), SRA->RA_CC )
							M->CP_OBS     := STR0166 + ": " + SRA->RA_FILIAL + "-" + SRA->RA_MAT //"FUNCIONARIO"
							If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
								M->CP_OBS     := SubStr( AllTrim( M->CP_OBS ) + " " + aTmp[ nPosObs ], 1, 180 )
							EndIf
							lRetCons := NGMUReques( , "SCP", .T., 4 )
						EndIf
						If lRetCons
							If cMdtStatus == "1" // 1  Verde  Solicitação atendida onde a reserva de estoque foi baixada.
								cLegenda := "BR_VERDE"
								// Contextualização:
								// É entregue um EPI pelo MDTA695, sendo feito um pedido de reserva para o Logix
								// No ambiente é dado baixa, caracterizando como EPI entregue, mas o Logix não atualiza o Protheus
								// com REQUEST, assim, quando for acessado a rotina MDTA695 será atualizado o TNF_INDDEV para EPI em Uso
								dbSelectArea( "TNF" )
								dbSetOrder( 1 )
								If dbSeek( xFilial( "TNF" ) + aTmp[ nPosForn ] + aTmp[ nPosLoja ] + cCodEPI + aTmp[ nPosNumC ] +;
								SRA->RA_MAT + DToS( aTmp[ nPosDtEn  ] ) + aTmp[ nPosHrEn ] ) .And. TNF->TNF_INDDEV != "2"
									RecLock( "TNF", .F. )
										TNF->TNF_INDDEV := "2"
									TNF->( MsUnLock() )
									aTmp[ nPosInDe ] := "2"
								EndIf
							ElseIf cMdtStatus == "2"// 2  Amarela  Solicitação não atendida com estoque e sem solicitação de compra pendente.
								cLegenda := "BR_AMARELO"
							ElseIf cMdtStatus == "3"// 3  Laranja  Solicitação não atendida sem estoque e com solicitação de compra pendente.
								cLegenda := "BR_LARANJA"
							ElseIf cMdtStatus == "4"// 4  Amarela  Solicitação não atendida com estoque e com o recebimento da solicitação de compra pendente.
								cLegenda := "BR_AMARELO"
							ElseIf cMdtStatus == "5"// 5  Vermelho  Solicitação de devolução ao estoque atendida.
								cLegenda := "BR_VERMELHO"
							ElseIf cMdtStatus == "6"// 6  Azul  Solicitação de devolução ao estoque não atendida.
								cLegenda := "BR_AZUL"
							EndIf
						EndIf
					Else
						cLegenda := "BR_VERDE"
					EndIf
				Else
					If aTmp[ nPosInDe ] == "3"
						dbSelectArea( "SCP" )
						dbSetOrder( 1 )
						If dbSeek( xFilial( "SCP" ) + aTmp[nPosNSA] + aTmp[nPosISA] ) .And.;
							SCP->CP_PRODUTO == cCodEpi .And. SCP->CP_PREREQU == "S" .And. SCP->CP_STATUS != "E"
							If CP_QUJE == 0
								cLegenda := "BR_LARANJA"
							ElseIf SCP->CP_QUJE != SCP->CP_QUANT
								cLegenda := "BR_AZUL_CLARO"
							ElseIf aTmp[ nPosInDe ] == "3"
								cLegenda := "BR_AMARELO"
							EndIf
						ElseIf aTmp[ nPosInDe ] == "3
							cLegenda := "BR_AMARELO"
						EndIf
					ElseIf aTmp[ nPosInDe ] == "1"
						cLegenda := "BR_VERMELHO"
					Else
						cLegenda := "BR_VERDE"
					EndIf
				EndIf

				aAdd( aColsAtu[ nCnt ], cLegenda )

				aEval( aTmp, { | x | aAdd( aColsAtu[nCnt], x ) } )

			Next nCnt
		Else
			If nTipoChm != 3
				aCols[ 1, 1 ] := IIf( lLogix, "", "BR_VERDE" )
			EndIf
		EndIf
	EndIf

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} LegMdtTNF
Cria uma janela contendo a legenda da Getdados

@author Denis Hyroshi de Souza
@since 05/04/2005

@obs Uso MDTA695 / MDTA630
/*/
//---------------------------------------------------------------------
Function LegMdtTNF()

	Local aLeg      := {}
	Local cOldCad   := IIf( Type( "cCadastro" ) != "U", cCadastro, "" )
	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lLogix	:= cMDTInteg == "2"

	If lLogix
		aAdd( aLeg, { "BR_VERDE", "Solicitação atendida onde a reserva de estoque foi baixada." } )
		aAdd( aLeg, { "BR_AMARELO", "Solicitação não atendida com estoque e sem solicitação " } )
		aAdd( aLeg, { " ", "de compra pendente.\Solicitação não atendida com estoque " } )
		aAdd( aLeg, { " ", "e com o recebimento da solicitação de compra pendente." } )
		aAdd( aLeg, { "BR_LARANJA", "Solicitação não atendida sem estoque e com solicitação de" } )
		aAdd( aLeg, { " ", " compra pendente." } )
		aAdd( aLeg, { "BR_VERMELHO", "Solicitação de devolução ao estoque atendida." } )
		aAdd( aLeg, { "BR_AZUL", "Solicitação de devolução ao estoque não atendida." } )
		aAdd( aLeg, { "BR_CINZA", "Produto não reportado ao estoque." } )
	Else
		aAdd( aLeg, { "BR_VERMELHO", STR0162 } ) //"Epi devolvido, desgastado ou perdido."
		aAdd( aLeg, { "BR_VERDE", STR0163 } ) //"Epi em uso."

		If lGera_SA
			aAdd( aLeg, { "BR_AMARELO", STR0164 } ) //"Epi em solicitação ao armazém"
			aAdd( aLeg, { "BR_LARANJA", STR0164 } ) //"Epi em solicitação ao armazém"
			aAdd( aLeg, { "", STR0165 } ) //"(com pré-requisição)"
			aAdd( aLeg, { "BR_AZUL_CLARO", "EPI com pré-requisição parcialmente baixada" } ) //"EPI com pré-requisição parcialmente baixada"
		EndIf
	EndIf

	cCadastro := STR0016 //"Legenda"
	BrwLegenda( OemToAnsi( cCadastro ), OemToAnsi( STR0016 ), aLeg ) //"Legenda"

	If !Empty( cOldCad )
		cCadastro := cOldCad
	EndIf

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} MdtMovSA
Inclui / Exclui a geracao da solicitação do armazem

@author Denis Hyroshi de Souza
@since 27/11/2009

@param cMov			Caracter	Código do tipo de movimentação ("D"/"R")
@param cCodEpi		Caracter	Código do EPI
@param nQtdEnt		Numeric		Quantidade de EPI Entregue
@param cNumSeq		Caracter	Numero da sequencia do EPI
@param cNumTNF_SA	Caracter	Código da Solicitação do Armazem
@param cItemTNF_SA	Caracter	Código do Item da Solicitação do Armazem
@param dDtNecess	Date		Data prevista da necessidade
@param cMatric		Caracter	Matricula do funcionario que recebe o EPI
@param cCenCusto	Caracter	Centro de custo do funcionario
@param cFilMatric	Caracter	Filial do funcionario
@param cLocalB1		Caracter	Código do Armazem

@return aRet		Array 	Array com duas colunas, primeira o Numero da SA,
Numero do Item da SA, gerados quando for requisicao
( cMov = "R" )

@obs Uso MDTA695 / MDTA630
/*/
//---------------------------------------------------------------------
Function MdtMovSA( cMov, cCodEpi, nQtdEnt, cNumSeq, cNumTNF_SA, cItemTNF_SA, dDtNecess, cMatric, cCenCusto, cFilMatric, cLocalB1, cSaiLogix, cObserv, lDelLogix, nRegAlt )

	Local cLimpa    := Space( 1 )
	Local aArea     := GetArea()
	Local aRet      := { Space( 6 ), Space( 2 ) }
	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lLogix	:= cMDTInteg == "2"
	Local lRet      := .T.
	Local aArrAlt	:= {}
	Local aEpiExc	:= {}

	Private cMdtReserva := "" // Variavel responsavel para buscar conteudo da TAG 'mr_num_reserva' na integração Logix
	Private cMDTSerie := "SAIDA"
	Private cMDTNumRes := ""

	Default cSaiLogix := ""
	Default cObserv   := ""
	Default lDelLogix := .F.

	cMDTNumRes := cSaiLogix
	dbSelectArea( "SRA" )
	dbSetOrder( 1 ) //RA_FILIAL+RA_MAT
	dbSeek( xFilial( "SRA" ) + cMatric )

	// Parametro MV_NG2INTE possui os seguintes valores:
	// 1 - Não
	// 2 - Logix
	If cMov == "D"
		nITLY := NGRETORDEM( "TLY", "TLY_FILIAL+TLY_NUMSA+TLY_ITEMSA", .F. )

		If nITLY > 0
			dbSelectArea( "TLY" )
			dbSetOrder( nITLY )

			If dbSeek( xFilial( "TLY" ) + cNumTNF_SA + cItemTNF_SA ) .And. TLY->TLY_CODEPI == cCodEpi
				RecLock( "TLY", .F. )
					TLY->TLY_OK     := cLimpa
					TLY->TLY_NUMSA  := cLimpa
					TLY->TLY_ITEMSA := cLimpa
				TLY->(MsUnLock())
			EndIf

		EndIf

		dbSelectArea( "SCP" )
		dbSetOrder( 1 )

		If dbSeek( xFilial( "SCP" ) + cNumTNF_SA + IIf( lLogix, '', cItemTNF_SA ) ) .And. SCP->CP_PRODUTO == cCodEpi

			If lLogix .And. lDelLogix
				lRet := NGMUReques( SCP->( Recno()), "SCP", .F., 5 )
			EndIf

			//Adiciona EPI's no array
			aAdd( aEpiExc, { cCodEPI, , nQtdEnt, , , SCP->CP_EMISSAO, , , , , cNumTNF_SA, cItemTNF_SA } )

			// Função de Execução automatica
			lRet := MDT695AUTO( aEpiExc, 5 )

		EndIf

	Else
		dbSelectArea( "SB1" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "SB1" ) + cCodEpi )

		dbSelectArea( "SCP" )
		dbSetOrder( 1 )

		If !Empty( cNumTNF_SA ) .And. !Empty( cItemTNF_SA ) .And. dbSeek( xFilial( "SCP" ) + cNumTNF_SA + cItemTNF_SA ) // Se tiver número de SA e não ouver registro do item
			nOpcSCP := 4 // Alteração
		Else
			nOpcSCP := 3 // Inclusão
		EndIf

		If Empty( cNumTNF_SA ) .And. Empty( cTNFNumSA )
			cNumTNF_SA := GetSxeNum( "SCP", "CP_NUM" ) // Função GetSxeNum é a utilizada no inicializador padrão do campo

			While SCP->( dbSeek( xFilial( 'SCP' ) + cNumTNF_SA ) ) // Garante que o número já não existe na SCP (Validação também feita no estoque)
				ConfirmSX8()
				cNumTNF_SA := GetSXENum( 'SCP', 'CP_NUM' )
			EndDo
		ElseIf Empty( cNumTNF_SA ) .And. !Empty( cTNFNumSA )
			cNumTNF_SA := cTNFNumSA
		EndIf

		If Empty( cItemTNF_SA ) //Incrementa numeração do Item de SA
			nItemSA++
			cItemTNF_SA := StrZero( nItemSA, 2 )
		EndIf

		// Campo Observação
		If !Empty( cObserv )
			cObsSCP	:= SubStr( AllTrim( SCP->CP_OBS ) + " " +  MSMM( cObserv, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
		Else
			cObsSCP	:= STR0166 + ": " + cFilMatric + "-" + cMatric //"FUNCIONARIO"
		EndIf

		//Campo CC
		If FindFunction( "MDTCCFunc" )
			cCCSCP := MDTCCFunc( cMatric, cCenCusto, dDtNecess )
		Else
			cCCSCP := cCenCusto
		EndIf

		If nOpcSCP == 4
			aAdd( aArrAlt, { cCodEpi, SB1->B1_UM, nQtdEnt, cLocalB1, dDataBase, dDataBase,;
				cUserName, cCCSCP, SB1->B1_DESC, cObsSCP, cNumTNF_SA, cItemTNF_SA } )
		Else
			//Adiciona EPI's no array
			aAdd( aEpiSA, { cCodEpi, SB1->B1_UM, nQtdEnt, cLocalB1, dDataBase, dDataBase,;
				cUserName, cCCSCP, SB1->B1_DESC, cObsSCP, cNumTNF_SA, cItemTNF_SA } )
		EndIf

		//Caso seja alteração, envia o EPI ao Estoque
		If nOpcSCP == 4
			lRet := MDT695AUTO( aArrAlt, nOpcSCP ) // Função de Execução automatica
			aArrAlt := {} //Zera array
		EndIf

		//Caso o número de registros alterados é igual ao último registro a ser
		//processado, envia os EPI's ao Estoque
		If nRegAlt == nContReg .And. Len( aEpiSA ) > 0
			lRet := MDT695AUTO( aEpiSA, 3 ) // Função de Execução automatica
		EndIf

		aRet := { cNumTNF_SA, cItemTNF_SA }

		If lRet

			If lLogix

				If !Empty( cMDTNumRes )
					lRet := NGMUReques( SCP->( Recno()), "SCP", .F., 4 )
				Else
					lRet := NGMUReques( SCP->( Recno()), "SCP", .F., 3 )
				EndIf

			EndIf

			// Ponto de entrada para gravação de campos específicos na
			// tabela SCP (Solicitação ao armazém) na entrega de EPI ao funcionário.
			If ExistBlock( "MDTA6955" )
				ExecBlock( "MDTA6955", .F., .F. )
			EndIf

		EndIf

	EndIf

	If !Empty( cMdtReserva ) .Or. !lRet

		If !lRet
			aAdd( aRet, _ErroLogix )
		Else
			aAdd( aRet, cMdtReserva )
		EndIf

	EndIf

	RestArea( aArea )

Return aRet

//------------------------------------------------------------------
/*/{Protheus.doc} fChg695GD
Funcao executada quando o foco muda de linha do MsNewGetDados

@author Denis Hyroshi de Souza
@since 27/11/2009

@param oGet	Object	Objeto da MsNewGetDados dos EPIs devolvidos (TLW)

@return lRet	Boolean .T.

@obs Uso MDTA695 / MDTA630
/*/
//---------------------------------------------------------------------
Function fChg695GD(oGetAux)

	Local nAt
	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lLogix	:= cMDTInteg == "2"
	Local lAlterou  := .F. //Se alterou algum campo da linha
	Local lTemPreR  := .F.
	Local lDevEntr  := .F.
	Local lParcBai  := .F.
	Local aGridAux  := fStructEPI()
	Local aColsAux  := {}

	Local nPosEPI    := GdFieldPos( "TNF_CODEPI", aGridAux[ _nHeader ] )
	Local nPOSDesc   := GdFieldPos( "TNF_DESC", aGridAux[ _nHeader ] )
	Local nPosForn   := GdFieldPos( "TNF_FORNEC", aGridAux[ _nHeader ] )
	Local nPosLoja   := GdFieldPos( "TNF_LOJA", aGridAux[ _nHeader ] )
	Local nPosNumC   := GdFieldPos( "TNF_NUMCAP", aGridAux[ _nHeader ] )
	Local nPosDtEn   := GdFieldPos( "TNF_DTENTR", aGridAux[ _nHeader ] )
	Local nPosHrEn   := GdFieldPos( "TNF_HRENTR", aGridAux[ _nHeader ] )
	Local nPosInDe   := GdFieldPos( "TNF_INDDEV", aGridAux[ _nHeader ] )
	Local nPosQtde   := GdFieldPos( "TNF_QTDENT", aGridAux[ _nHeader ] )
	Local nPosDtDe   := GdFieldPos( "TNF_DTDEVO", aGridAux[ _nHeader ] )
	Local nPosNSA    := GdFieldPos( "TNF_NUMSA", aGridAux[ _nHeader ] )
	Local nPosISA    := GdFieldPos( "TNF_ITEMSA", aGridAux[ _nHeader ] )
	Local nPosLeg    := GdFieldPos( "COLBMP", aGridAux[ _nHeader ] )
	Local nPosDevBio := GdFieldPos( "TNF_DEVBIO", aGridAux[ _nHeader ] )
	Local nPosLot    := GdFieldPos( "TNF_LOTECT", aGridAux[ _nHeader ] )
	Local nPosSubL   := GdFieldPos( "TNF_LOTESB", aGridAux[ _nHeader ] )
	Local nPosLocal  := GdFieldPos( "TNF_LOCAL", aGridAux[ _nHeader ] )
	Local nPosSaiLog := GdFieldPos( "TNF_SAILOG", aGridAux[ _nHeader ] )
	Local nPosEntLog := GdFieldPos( "TNF_ENTLOG", aGridAux[ _nHeader ] )
	Local cReadVar   := AllTrim( ReadVar() )

	nAt := aGridAux[ _nAt ]
	aColsAux := aGridAux[ _nCols, nAt ]

	If nPosDevBio > 0
		If cReadVar != "M->TNF_DEVBIO"
			M->TNF_DEVBIO := aColsAux[ nPosDevBio ]
		EndIf
	EndIf

	If cReadVar != "M->TNF_CODEPI"
		M->TNF_CODEPI := aColsAux[ nPOSEpi ]
		If Empty( M->TNF_CODEPI )
			aColsAux[nPOSDesc] := ""
		EndIf
	EndIf
	If cReadVar != "M->TNF_DTENTR"
		M->TNF_DTENTR := aColsAux[ nPosDtEn ]
	EndIf
	If cReadVar != "M->TNF_HRENTR"
		M->TNF_HRENTR := aColsAux[ nPosHrEn ]
	EndIf

	If cReadVar != "M->TNF_INDDEV"
		M->TNF_INDDEV := aColsAux[ nPosInDe ]
	EndIf

	If cReadVar != "M->TNF_QTDENT"
		M->TNF_QTDENT := aColsAux[ nPosQtde ]
	EndIf

	If cReadVar != "M->TNF_DTDEVO"
		M->TNF_DTDEVO := aColsAux[ nPosDtDe ]
	EndIf

	lWh695TNF := .T. //Variavel que controla o X3_WHEN dos campos da TNF
	lWh695IND := .T. //Variavel que controla o X3_WHEN do campo TNF_INDDEV
	lWh695LOT := .T. //Variavel que controla o X3_WHEN do campo Lote SubLote
	lWh695OBS := .F. //Variavel que controla o X3_WHEN do campo Observação

	// Verifica se EPI, data de entrega ou hora da entrega foi alterado
	nPosTNF   := aScan( aColsTNF, { |x| aColsAux[ nPosForn ] == x[nPosForn] .And. aColsAux[ nPosLoja ] == x[nPosLoja] .And. ;
					M->TNF_CODEPI  == x[nPOSEpi]  .And. aColsAux[ nPosNumC ] == x[nPosNumC] .And. ;
					M->TNF_DTENTR == x[nPosDtEn] .And. M->TNF_HRENTR == x[nPosHrEn] } )

	//Se foi incluso uma nova linha
	If nPosTNF == 0
		If cUsaInt1 == "S" .And. !lGera_SA // Caso MDT faça integração com Estoque e não é pra gerar Solicitação de Armazem
			aColsAux[ nPosInDe ] := "2"
			lWh695IND := .F.
		EndIf
	Else
		// Histórico não faz integração com estoque, então, se opção estiver como solicitação de armazem, trava campos correspondentes
		If Type( "lHist695" ) == "L" .And. lHist695
			If aColsTNF[ nPosTNF, nPosInDe ] == "3"
				lWh695TNF := .F.
				If ValType( oGetAux ) == "O"
					oGetAux:oBrowse:Refresh()
				EndIf
				Return .T.
			EndIf
		Else
			//Se usa rastreio, é verificado se a quantidade entregue não foi alterada
			// E se o Lote ou Sublote foram informados, não poderá altera los
			If cUsaRast == "S"
				If M->TNF_QTDENT == aColsTNF[ nPosTNF, nPosQtde ] .And. ( !Empty( aColsTNF[ nPosTNF, nPosLot ] ) .Or. !Empty( aColsTNF[ nPosTNF, nPosSubL ] ) )
					lWh695LOT := .F.
				EndIf
			EndIf
		EndIf

		lDevEntr := ( M->TNF_INDDEV != "1" .Or. Empty( M->TNF_DTDEVO ) ) .And. ; //Agora o Epi foi requisitado
					( aColsTNF[ nPosTNF, nPosInDe ] == "1" .And. !Empty( M->TNF_DTDEVO ) ) //Antes o Epi foi devolvido.

		//Qtde foi alterada ou Re-entrega
		lAlterou := aColsTNF[ nPosTNF, nPosQtde ] != M->TNF_QTDENT .Or. lDevEntr
		If !lLogix
			If aColsTNF[ nPosTNF, nPosInDe ] == "3" //Se estiver Entregue ou em Solic. Armazém

				dbSelectArea( "SCP" )
				dbSetOrder( 1 )
				If dbSeek( xFilial( "SCP" ) + aCols[nAt, nPosNSA] + aCols[nAt, nPosISA] ) .And. SCP->CP_PRODUTO == M->TNF_CODEPI .And. SCP->CP_PREREQU == "S" .And. SCP->CP_STATUS != "E"
					If CP_QUJE == 0
						lTemPreR  := .T. //Indica pré-requicisao
						lWh695TNF := .F.
					ElseIf SCP->CP_QUJE != SCP->CP_QUANT
						lParcBai  := .T. //Indica que a pré-requisição foi parcialmente baixada
					EndIf
				EndIf

			EndIf
		EndIf
	EndIf

	If lGera_SA
		If lAlterou
			aColsAux[ nPosInDe ] := "3"
		EndIf
		If aColsAux[ nPosInDe ] $ "1/3"
			lWh695IND := .F. //Desativa o campo TNF_INDDEV
		EndIf
	EndIf

	If nPosInDe > 0 .And. nPosLeg > 0

		// Se não for Logix atualiza legenda conforme Status do EPI
		// Ou se a Consulta no Logix retornou como não consistente
		If !lLogix
			If M->TNF_INDDEV == "3"
				If lTemPreR
					aColsAux[ nPosLeg ] := "BR_LARANJA"
				ElseIf lParcBai
					aColsAux[ nPosLeg ] := "BR_AZUL_CLARO"
				Else
					aColsAux[ nPosLeg ] := "BR_AMARELO"
				EndIf
			ElseIf M->TNF_INDDEV == "1"
				aColsAux[ nPosLeg ] := "BR_VERMELHO"
			Else
				aColsAux[ nPosLeg ] := "BR_VERDE"
			EndIf
		ElseIf Empty( aColsAux[ nPosEPI ] )//Quando for Logix e a linha for nova, com o EPI não informado, legenda padrao é Verde
			aColsAux[ nPosLeg ] := "BR_AMARELO"
			lWh695OBS := .T.
		ElseIf AllTrim( aColsAux[ nPosLeg ] ) $ "BR_LARANJA|BR_AMARELO"
			lWh695OBS := .T.
		ElseIf AllTrim( aColsAux[ nPosLeg ] ) $ "BR_VERMELHO|BR_CINZA"
			lWh695TNF := .F.
		ElseIf AllTrim( aColsAux[ nPosLeg ] ) $ "BR_VERDE"
			lWh695IND := .T.
		EndIf
	EndIf

	//Se historico, limpa campo data devolucao
	If Type( "lHist695" ) == "L" .And. lHist695
		If aColsAux[ nPosInDe ] == "2" .And. !Empty( aColsAux[ nPosDtDe ] )
			aColsAux[ nPosDtDe ] := StoD( "" )
		EndIf
	EndIf

	If ValType( oGetAux ) == "O"
		oGetAux:oBrowse:Refresh()
	EndIf

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} fChg695GD
Altera o X3_WHEN na MsNewGetDados

@author Denis Hyroshi de Souza
@since 27/11/2009

@param oGet		Object		Objeto da MsNewGetDados dos EPIs devolvidos (TLW)
@param cFuncGD	Caracter	Função adicionada na estrutura do aHeader, para verificar
X3_WHEN através de aplicação, no MDTA695, MDTA630 e MDTA410
@param lTmpHist	Boolean		Indica se esta sendo executado a rotina de Histórico de EPI

@return lRet	Boolean .T.

@obs Uso MDTA695 / MDTA630
/*/
//---------------------------------------------------------------------
Function fChgWhTNF( oGet, cFuncGD, lTmpHist )

	Local nX
	Local aHeadAux := aClone( fStructEPI()[ _nHeader ] )
	Local nPosInDe := GdFieldPos( "TNF_INDDEV", aHeadAux )
	Local nPosObs  := GdFieldPos( "TNF_OBSLOG", aHeadAux )

	Local nPosLot   := GdFieldPos( "TNF_LOTECT", aHeadAux )
	Local nPosSubL  := GdFieldPos( "TNF_LOTESB", aHeadAux )
	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lLogix	:= cMDTInteg == "2"

	For nX := 1 To Len( oGet:aInfo )
		If lGera_SA .Or. lTmpHist
			If Empty( oGet:aInfo[ nX, 4 ] )
				oGet:aInfo[ nX, 4 ] := "lWh695TNF"
			Else
				oGet:aInfo[ nX, 4 ] := Alltrim( oGet:aInfo[ nX, 4 ] ) + " .And. lWh695TNF"
			EndIf
			If nPosInDe == nX
				oGet:aInfo[ nX, 4 ] := Alltrim( oGet:aInfo[ nX, 4 ] ) + " .And. lWh695IND"
			EndIf
		ElseIf cUsaInt1 == "S"
			If nPosInDe == nX
				If Empty( oGet:aInfo[ nX, 4 ] )
					oGet:aInfo[ nX, 4 ] := "lWh695IND"
				Else
					oGet:aInfo[ nX, 4 ] := Alltrim( oGet:aInfo[ nX, 4 ] ) + " .And. lWh695IND"
				EndIf
			EndIf
		EndIf

		If cUsaInt1 == "S" .And. lLogix .And. nPosObs == nX
			If Empty( oGet:aInfo[ nX, 4 ] )
				oGet:aInfo[ nX, 4 ] := "lWh695OBS"
			Else
				oGet:aInfo[ nX, 4 ] := Alltrim( oGet:aInfo[ nX, 4 ] ) + " .And. lWh695OBS"
			EndIf
		EndIf

		If cUsaRast == "S" .And. ( nPosLot == nX .Or. nPosSubL == nX )
			If Empty( oGet:aInfo[ nX, 4 ] )
				oGet:aInfo[ nX, 4 ] := "lWh695LOT"
			Else
				oGet:aInfo[ nX, 4 ] := Alltrim( oGet:aInfo[ nX, 4 ] ) + " .And. lWh695LOT"
			EndIf
		EndIf
	Next nX

	For nX := 1 To Len( aHeadAux )
		If Alltrim( aHeadAux[ nX, 2 ] ) $ "TNF_CODEPI,TNF_MAT,TNF_DTENTR,TNF_HRENTR,TNF_QTDENT,TNF_INDDEV,TNF_DTDEVO"
			If Empty( aHeadAux[ nX, 6 ] )
				aHeadAux[ nX, 6 ] := cFuncGD
			Else
				aHeadAux[ nX, 6 ] := "( " + Alltrim( aHeadAux[ nX, 6 ] ) + " ) .And. " + cFuncGD
			EndIf
		EndIf
	Next nX

	If lCpoLegX
		oGet:aInfo[ 1, 4 ] := ".F." //Desativando X3_WHEN do campo Semaforo
	EndIf

	If IsInCallStack( "MDTA695" )
		oGetTNF695:aHeader := aClone( aHeadAux )
	ElseIf IsInCallStack( "MDTA630" )
		If Type( "oGetTNF630" ) != "U"
			oGetTNF630:aHeader := aClone( aHeadAux )
		Else
			aHeader := aClone( aHeadAux )
		EndIf
	EndIf

Return Nil

//------------------------------------------------------------------
/*/{Protheus.doc} MdtIntSCP
Função executada ao baixar pré-requisição ou Excluir S.A.
Utiliazada nos fontes MATA105 e MATA185.

@author Denis Hyroshi de Souza
@since 27/11/2009

@param nTipMov, Numércio, Indica o tipo de movimentação 1 - Baixa de SA
2 - Exclusao de SA
@param cCP_NUM, Caractere, Código da SA
@param cCP_ITEM, Caractere, Código do item da SA
@param cD3_NUMSEQ, Caractere, Código da Sequencia da SA
@param cCP_PRODUTO, Caractere, Código do produta da SA

/*/
//---------------------------------------------------------------------
Function MdtIntSCP( nTipMov, cCP_NUM, cCP_ITEM, cD3_NUMSEQ, cCP_PRODUTO, cD3_NUMSERI, cD3_LOTE, cD3_SUBLOTE, cD3_LOCALIZ )

	Local aRet := {}
	Local aArea := GetArea()
	Local aMemosTNF := GetMemoTNF()

	Local lRet := .T. // Retorno do eSocial
	Local lCont := .T.
	Local lMdtSA := SuperGetMv( "MV_NG2SA", .F., "N" ) == "S" // Se não tem integração MDT com EST(S.A.)

	If lMdtSA .Or. ( lMdtSA .And. SuperGetMv( "MV_NGMDTES", .F., "" ) == "S" ) // Integracao do SIGAMDT com o Estoque Informar S=Sim ou N=Nao

		nIndSA := NGRETORDEM( "TNF", "TNF_FILIAL+TNF_NUMSA+TNF_ITEMSA", .F. )

		If nIndSA > 0

			dbSelectArea( "TNF" )
			dbSetOrder( nIndSA )

			If dbSeek( xFilial( "TNF" ) + cCP_NUM + cCP_ITEM )

				While !Eof() .And. xFilial( "TNF" ) + cCP_NUM + cCP_ITEM == TNF->(TNF_FILIAL+TNF_NUMSA+TNF_ITEMSA) .And. lCont

					If TNF->TNF_CODEPI == cCP_PRODUTO

						If nTipMov == 1 .And. TNF->TNF_INDDEV == "3" // Baixar Pre-Requisicao // 3=Epi em Solic. Armazem

							// Só Muda o status do EPI para 'Em uso' se todos os itens da pré requisição da SA foram baixados
							If SCP->CP_QUJE == SCP->CP_QUANT

								aAreaTNF := TNF->(GetArea())

								aRet := fDtHrTNF( TNF->(Recno()), TNF->TNF_DTENTR, TNF->TNF_HRENTR,;
												TNF->(TNF_FILIAL + TNF_FORNEC + TNF_LOJA + TNF_CODEPI + TNF_NUMCAP + TNF_MAT) )

								RestArea( aAreaTNF )

								BEGIN TRANSACTION

									RecLock( "TNF", .F. )

										TNF->TNF_INDDEV := "2"
										TNF->TNF_NUMSEQ := cD3_NUMSEQ
										TNF->TNF_DTENTR := aRet[ 1 ]
										TNF->TNF_HRENTR := aRet[ 2 ]
										TNF->TNF_NSERIE := cD3_NUMSERI
										TNF->TNF_LOTECT := cD3_LOTE
										TNF->TNF_LOTESB := cD3_SUBLOTE
										TNF->TNF_ENDLOC := cD3_LOCALIZ

										If TNF->(FieldPos( "TNF_CUSTO" )) > 0

											If !Empty( SD3->D3_CUSTO1 )

												TNF->TNF_CUSTO  := SD3->D3_CUSTO1

											EndIf

										EndIf

									TNF->(MsUnLock())

									If FindFunction( "MDTIntEsoc" )

										lRet := MDTEpiS2240( { { TNF->TNF_MAT, , , , , , , { { TNF->TNF_CODEPI, TNF->TNF_DTENTR, , , , , TNF->TNF_NUMCAP } } } }, .T. )

									EndIf

									/*If !lRet

										DisarmTransaction()

									EndIf*/

								END TRANSACTION

								lCont := .F.

								Exit

							EndIf

						ElseIf nTipMov == 2 .And. TNF->TNF_INDDEV $ "1/3" // Excluir S.A. // 1=Epi devolvido;3=Epi em Solic. Armazem

							RecLock( "TNF", .F. )

								dbDelete()

							TNF->(MsUnLock())

							aEval( aMemosTNF, { |x| MSMM( &( "TNF->" + x[1] ), , , , 2, , , , , ) } )

							lCont := .F.

							Exit

						EndIf

					EndIf

					dbSelectArea( "TNF" )
					dbSkip()

				End

			EndIf

		EndIf

		If nTipMov == 2 // Excluir S.A.

			nITLY := NGRETORDEM( "TLY", "TLY_FILIAL+TLY_NUMSA+TLY_ITEMSA", .F. )

			If nITLY > 0

				dbSelectArea( "TLY" )
				dbSetOrder( nITLY )

				If dbSeek( xFilial( "TLY" ) + cCP_NUM + cCP_ITEM ) .And. TLY->TLY_CODEPI == cCP_PRODUTO

					RecLock( "TLY", .F. )

						TLY->TLY_OK     := " "
						TLY->TLY_NUMSA  := " "
						TLY->TLY_ITEMSA := " "

					TLY->(MsUnLock())

				EndIf

			EndIf

		EndIf

	EndIf

	RestArea( aArea )

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} fDtHrTNF
Verifica proxima data/hora para entregar o Epi

@author Denis Hyroshi de Souza
@since 27/11/2009

@return Boolean .T.

@obs Uso MDTA695 / MDTA800
/*/
//---------------------------------------------------------------------
Function fDtHrTNF( nRecTNF, dDtTNF, cHrTNF, cChvTNF )

	Local aRet := { dDtTNF, cHrTNF }
	Local dTmp := dDataBase
	Local cTmp := Time()
	Local nCnt := 0
	Local nMin

	While nCnt < 500
		nCnt++
		dbSelectArea( "TNF" )
		dbSetOrder( 1 )
		If !dbSeek( cChvTNF + DToS( dTmp ) + cTmp )
			aRet := { dTmp, cTmp }
			nCnt := 999
			Exit
		Else
			If nRecTNF == TNF->(Recno())
				nCnt := 999
				Exit
			Else
				nMin := HToM( cTmp ) + 1
				If nMin >= 1440
					cTmp := "00:00"
					dTmp++
				Else
					cTmp := MToH( nMin )
				EndIf
			EndIf
		EndIf
	End

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fChangeGD
Funcao executada quando o foco muda de linha da GD

@author  Denis
@since   27/11/2009
@param   oGet, Objeto, Objeto que está sendo usado
@uso 	 MDTA695 e MDTA630

@return  .T., Sempre verdadeiro
/*/
//-------------------------------------------------------------------
Static Function fChangeGD( oGet )

	fChg695GD( oGet )
	If ValType( oGet ) == "O" .And. oGet:oBrowse:nColPos == 1
		oGet:oBrowse:nColPos := 2
		oGet:oBrowse:Refresh()
	EndIf

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} MdtSldSBF
Valida Saldos do Lote/SubLote/Endereco/Numero Serie do EPI

@author Denis Hyroshi de Souza
@since 30/03/2010

@return Boolean lRet

@obs Uso MDTA695 / MDTA630
/*/
//---------------------------------------------------------------------
Function MdtSldSBF( cProduto, cLocal, cLote, cSubLote, cLocaliza, cNumSerie, nNumQtde, lMsg, dDtValid )

	Local lRet	    := .T.
	Local lLote     := .F.
	Local lSubL     := .F.
	Local lLocz     := .F.
	Local lNoQt     := !ValType( nNumQtde ) == "N"
	Local lUsaRastr := cUsaRast == "S"
	Local dDtTm     := dDataBase

	Default lMsg := .T.

	If ValType( dDtValid ) == "D" .And. !Empty( dDtValid )
		dDtTm := dDtValid
	EndIf

	If lUsaRastr
		If lLote := Rastro( cProduto ) //Pesquisa no SB1 se produto corrente usa rastreabilidade por Lote
			lSubL := Rastro( cProduto, "S" )//Pesquisa no SB1 se produto corrente usa rastreabilidade por Sub Lote
		EndIf
	EndIf
	If cUsaLocz == "S"
		lLocz := Localiza( cProduto ) //Pesquisa no SB1 se produto corrente usa localizacao fisica (B1_LOCALIZ == "S")
	EndIf

	If lSubL //Valida SubLote
		If Empty( cSubLote ) .And. MDTTNFWHEN( "M->TNF_LOTESB" )
			If lMsg
				Help( " ", 1, "NGATENCAO", , STR0175, 3, 1 ) //"Número do sub-lote não informado"
			EndIf
			lRet := .F.
		EndIf
		dbSelectArea( "SB8" )
		dbSetOrder( 2 )
		If lRet .And. dbSeek( xFilial( "SB8" ) + cSubLote ) .And. cLote + cProduto + cLocal == SB8->B8_LOTECTL + SB8->B8_PRODUTO + SB8->B8_LOCAL
			If !lNoQt //Nao valida o saldo
				//Calcula o saldo do SB8 Posicionado
				nSaldoLote := SB8Saldo( .F., !Empty( cLote + cSubLote ), NIL, NIL, NIL, NIL, NIL, dDtTm )
				nAcumulado := A695RTACUM( 1, cProduto, cLocal, cLote, cSubLote, , )
				If QtdComp( nSaldoLote ) < QtdComp( nAcumulado )
					If lMsg
						Help( " ", 1, "A240LOTENE" )
					EndIf
					lRet := .F.
				EndIf
			EndIf
		ElseIf lMsg .And. MDTTNFWHEN( "M->TNF_LOTESB" )
			Help( " ", 1, "NGATENCAO", , STR0181 + CRLF +; //"Número do sub-lote não corresponde ao produto que foi "
				 STR0182, 3, 1 ) //" informado. Digite um sub-lote correspondente."
			lRet := .F.
		EndIf

	ElseIf lLote //Valida Lote

		If Empty( cLote ) .And. MDTTNFWHEN( "M->TNF_LOTECT" )
			If lMsg
				Help( " ", 1, "NGATENCAO", , STR0183, 3, 1 ) //"Número do lote não informado"
			EndIf
			lRet := .F.
		EndIf

		If lRet .And. !Empty( cSubLote )
			If lMsg
				Help( " ", 1, "NGATENCAO", , STR0184, 3, 1 ) //"O Número do sub-lote não pode ser informado"
			EndIf
			lRet := .F.
		EndIf

		If  lRet
			dbSelectArea( "SB8" )
			dbSetOrder( 3 ) //B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
			If dbSeek( xFilial( "SB8" ) + cProduto + cLocal + cLote )
				If !lNoQt //Nao valida o saldo
					nSaldoLote := SaldoLote( cProduto, cLocal, cLote, NIL, .F., !Empty( cLote + cSubLote ), NIL, dDtTm )
					nAcumulado := A695RTACUM( 2, cProduto, cLocal, cLote, , , )
					If QtdComp( nSaldoLote ) < QtdComp( nAcumulado )
						If lMsg
							Help( " ", 1, "A240LOTENE" )
						EndIf
						lRet := .F.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	If lRet
		If lLocz
			If !lSubL
				If !lLote
					If !Empty( cLote )
						If lMsg
							Help( " ", 1, "NGATENCAO", , STR0187, 3, 1 ) //"O Número do lote não pode ser informado"
						EndIf
						lRet := .F.
					EndIf
				EndIf
				If lRet .And. !Empty( cSubLote )
					If lMsg
						Help( " ", 1, "NGATENCAO", , STR0184, 3, 1 ) //"O Número do sub-lote não pode ser informado"
					EndIf
					lRet := .F.
				EndIf
			EndIf
			If lRet .And. Empty( cLocaliza ) .And. Empty( cNumSerie ).And. MDTTNFWHEN( "M->TNF_ENDLOC" )
				If lMsg
					Help( " ", 1, "LOCALIZOBR" )
				EndIf
				lRet := .F.
			EndIf
			If lRet .And. !Empty( cLocaliza )
				lRet := ExistCpo( "SBE", cLocal + cLocaliza )
			EndIf
			//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
			If lRet .And. !lNoQt //Nao valida o saldo
				//Avalia qtd utilizada em movimentos com Numero de Serie
				If !MtAvlNSer( cProduto, cNumSerie, nNumQtde )
					lRet := .F.
				EndIf
				nSaldoLote := SaldoSBF( cLocal, cLocaliza, cProduto, cNumSerie, cLote, cSubLote, .F. )
				nAcumulado := A695RTACUM( 3, cProduto, cLocal, cLote, cSubLote, cLocaliza, cNumSerie )
				If lRet  .And. ( QtdComp( nSaldoLote ) < QtdComp( nAcumulado ) )
					If lMsg
						Help( " ", 1, "SALDOLOCLZ" )
					EndIf
					lRet := .F.
				EndIf
			EndIf
		Else
			If lRet .And. !Empty( cLocaliza )
				If lMsg
					Help( " ", 1, "NGATENCAO", , STR0188, 3, 1 ) //"A Localização não pode ser informado"
				EndIf
				lRet := .F.
			EndIf
			If lRet .And. !Empty( cNumSerie )
				If lMsg
					Help( " ", 1, "NGATENCAO", , STR0189, 3, 1 ) //"O Núm. de Série não pode ser informado"
				EndIf
				lRet := .F.
			EndIf
			If lRet .And. !lSubL
				If !lLote .And. !Empty( cLote )
					If lMsg
						Help( " ", 1, "NGATENCAO", , STR0187, 3, 1 ) //"O Número do lote não pode ser informado"
					EndIf
					lRet := .F.
				EndIf
				If lRet .And. !Empty( cSubLote )
					If lMsg
						Help( " ", 1, "NGATENCAO", , STR0184, 3, 1 ) //"O Número do sub-lote não pode ser informado"
					EndIf
					lRet := .F.
				EndIf

			EndIf
		EndIf
	EndIf

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} MdtVldSBF
Valida Codigo do Lote/SubLote/Endereco/Numero Serie do EPI

@author Denis Hyroshi de Souza
@since 30/03/2010

@return Boolean lRet

@obs Uso X3_VALID -> TNF_LOTECT;TNF_LOTESB;TNF_ENDLOC.
/*/
//---------------------------------------------------------------------
Function MdtVldSBF( nTipoVal )

	Local lLote := .F.
	Local lSubL := .F.
	Local lLocz := .F.
	Local lRet  := .T.

	Local cProduto
	Local cLocal
	Local cLote
	Local cSubLote
	Local cLocaliza

	Local nPosEPI
	Local nPosLocal
	Local nPosLot
	Local nPosSubL
	Local nAt

	Local aGridAux := fStructEPI() //Busca a estrutura do MsNewGetDados correspondente -> MDTA695/MDTA630
	Local aColsAux := {}

	nPosEPI  := GdFieldPos( "TNF_CODEPI", aGridAux[ _nHeader ] )
	nPosLocal:= GdFieldPos( "TNF_LOCAL", aGridAux[ _nHeader ] )
	nPosLot  := GdFieldPos( "TNF_LOTECT", aGridAux[ _nHeader ] )
	nPosSubL := GdFieldPos( "TNF_LOTESB", aGridAux[ _nHeader ] )
	nAt      := aGridAux[ _nAt ]

	aColsAux := aGridAux[ _nCols, nAt ]

	cProduto := IIf( nPosEPI > 0, aColsAux[ nPosEPI ], TN3->TN3_CODEPI )
	cLocal   := aColsAux[ nPosLocal ]

	If nTipoVal == 1 .Or. nTipoVal == 2
		cLote	 := IIf( nTipoVal != 1, aColsAux[ nPosLot ], M->TNF_LOTECT )
		cSubLote := IIf( nTipoVal != 2, aColsAux[ nPosSubL ], M->TNF_LOTESB )
		If Rastro( cProduto )
			lSubL := Rastro( cProduto, "S" )
			lLote := !lSubL
		EndIf
		If lSubL
			dbSelectArea( "SB8" )
			dbSetOrder( 02 ) //B8_FILIAL+B8_NUMLOTE+B8_LOTECTL+B8_PRODUTO+B8_LOCAL+DTOS(B8_DTVALID)
			If !( dbSeek( xFilial( "SB8" ) + cSubLote ) )
				If ( cLote + cProduto + cLocal == SB8->B8_LOTECTL + SB8->B8_PRODUTO + SB8->B8_LOCAL ) .And. !Empty( cLote ) .And. !Empty( cSubLote )
					Help( " ", 1, "NGATENCAO", , STR0181 + CRLF + ; //"Número do sub-lote não corresponde ao produto que foi "
						STR0182, 3, 1 ) //" informado. Digite um sub-lote correspondente."
					lRet := .F.
				EndIf
			ElseIf cProduto + cLocal == SB8->B8_PRODUTO + SB8->B8_LOCAL .And. !Empty( cSubLote )
				aColsAux[ nPosLot ] := SB8->B8_LOTECTL
			Else
				Help( " ", 1, "NGATENCAO", , STR0181 + CRLF + ; //"Número do sub-lote não corresponde ao produto que foi "
				STR0182, 3, 1 ) //" informado. Digite um sub-lote correspondente."
				lRet := .F.
			EndIf
		Else
			If lLote
				If nTipoVal == 1
					dbSelectArea( "SB8" )
					dbSetOrder( 03 )
					If !dbSeek( xFilial( "SB8" ) + cProduto + cLocal + cLote )
						Help( " ", 1, "NGATENCAO", , STR0185 + CRLF + ; //"Número do lote não corresponde ao produto que foi "
						STR0186, 3, 1 ) //" Informado. Digite um lote correspondente."
						lRet := .F.
					EndIf
				EndIf
			Else
				If nTipoVal == 1 .And. !Empty( cLote )
					Help( " ", 1, "NGATENCAO", , STR0187, 3, 1 ) //"O Número do lote não pode ser informado"
					lRet := .F.
				EndIf
			EndIf
			If lRet .And. nTipoVal == 2 .And. !Empty( cSubLote )
				Help( " ", 1, "NGATENCAO", , STR0184, 3, 1 ) //"O Número do sub-lote não pode ser informado"
				lRet := .F.
			EndIf
		EndIf
	EndIf

	If lRet .And. nTipoVal == 3
		cLocaliza := M->TNF_ENDLOC
		lLocz := Localiza( cProduto )

		If lLocz
			If !Empty( cLocaliza )
				lRet := ExistCpo( "SBE", cLocal + cLocaliza )
			EndIf
		Else
			If !Empty( cLocaliza )
				Help( " ", 1, "NGATENCAO", , STR0188, 3, 1 ) //"A Localização não pode ser informado"
				lRet := .F.
			EndIf
		EndIf
	EndIf

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} A695RTACUM
Acumula a quantidade entregue ou devolvida por Lote/End/Prod

@author Denis Hyroshi de Souza
@since 17/07/2001

@return Numeric nDiffOS

@obs Uso MDTA695 / MDTA630
/*/
//---------------------------------------------------------------------
Function A695RTACUM( nTipoReg, cProduto, cLocal, cLote, cSubLote, cLocaliz, cNumSerie, lChkEntr, lTelaTLW )

	Local aGridAux   := fStructEPI() //Busca a estrutura do MsNewGetDados correspondente -> MDTA695/MDTA630
	Local aColsChk   := aClone( aGridAux[ _nCols ] )
	Local nPosEPI    := GdFieldPos( "TNF_CODEPI", aGridAux[ _nHeader ] )
	Local nPosMatr   := GdFieldPos( "TNF_MAT", aGridAux[ _nHeader ] )
	Local nPosLocal  := GdFieldPos( "TNF_LOCAL", aGridAux[ _nHeader ] )
	Local nPosQtde   := GdFieldPos( "TNF_QTDENT", aGridAux[ _nHeader ] )
	Local nPosInDe   := GdFieldPos( "TNF_INDDEV", aGridAux[ _nHeader ] )
	Local nPosForn   := GdFieldPos( "TNF_FORNEC", aGridAux[ _nHeader ] )
	Local nPosLoja   := GdFieldPos( "TNF_LOJA", aGridAux[ _nHeader ] )
	Local nPosNumC   := GdFieldPos( "TNF_NUMCAP", aGridAux[ _nHeader ] )
	Local nPosDtEn   := GdFieldPos( "TNF_DTENTR", aGridAux[ _nHeader ] )
	Local nPosTipoDv := GdFieldPos( "TNF_TIPODV", aGridAux[ _nHeader ] )
	Local nPosHrEn   := GdFieldPos( "TNF_HRENTR", aGridAux[ _nHeader ] )
	Local nPosQTDDv  := GdFieldPos( "TNF_QTDEVO", aGridAux[ _nHeader ] )
	Local nPosLot    := GdFieldPos( "TNF_LOTECT", aGridAux[ _nHeader ] )
	Local nPosSubL   := GdFieldPos( "TNF_LOTESB", aGridAux[ _nHeader ] )
	Local nPosEnd    := GdFieldPos( "TNF_ENDLOC", aGridAux[ _nHeader ] )
	Local nPosNSer   := GdFieldPos( "TNF_NSERIE", aGridAux[ _nHeader ] )
	Local nPosDtDev  := GdFieldPos( "TLW_DTDEVO", aHeadTLW )
	Local nPosHrDev  := GdFieldPos( "TLW_HRDEVO", aHeadTLW )
	Local nPosQtDev  := GdFieldPos( "TLW_QTDEVO", aHeadTLW )
	Local nPosLocDev := GdFieldPos( "TLW_LOCAL", aHeadTLW )
	Local nPosTpDev  := GdFieldPos( "TLW_TIPODV", aHeadTLW )
	Local nX
	Local nY
	Local nPosTNF
	Local nXYZ
	Local nDiffOS   := 0
	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lCall695  := IsInCallStack( "MDTA695" ) .Or. IsInCallStack( "MDTA410" )
	Local lUsaRastr := SuperGetMv( "MV_RASTRO", .F., "" ) == "S"
	Local lLocaliza := SuperGetMv( "MV_LOCALIZ", .F., "" ) == "S"
	Local lLogix	:= cMDTInteg == "2"

	Default cLote	  := ""
	Default cSubLote  := ""
	Default cLocaliz  := ""
	Default cNumSerie := ""
	Default lChkEntr  := .T. //Indica se verifica Entrega (.T.) ou devolução (.F.)
	Default lTelaTLW  := .F. //Indica se esta na tela TLW

	If !lChkEntr .And. lTelaTLW
		aColsChk := aClone( aOldTNF ) //Devolucao TLW //Devolucao TNF
	EndIf

	aColsChk := fDelUltEle( aColsChk )

	//---------------------------
	// Verifica Lote e Sub-lote
	//---------------------------
	For nX := 1 To Len( aColsChk )

		cProdTmp := IIf( nPosEPI > 0, aColsChk[ nX, nPosEPI ], TN3->TN3_CODEPI )

		If !aTail( aColsChk[ nX ] ) .And. ;
			IIf( lUsaRastr,;
				 ( cProdTmp + aColsChk[ nX, nPosLot ] == cProduto + cLote .And.;
				 IIf( nTipoReg == 2, Empty( aColsChk[ nX, nPosSubL ] ), aColsChk[ nX, nPosSubL ] == cSubLote ) ),;
				 .T. )

			nDevoTotal  := 0 //Quantidade Devolvida Total
			lDevoTLW    := .F. //Indica que a devolucao foi efetivada pelas devolucoes parciais.
			nPosTNF     := 0

			nPosTNF := fRetChave( aColsChk[ nX ], aGridAux[ _nHeader ] )

			If nPosTNF > 0

				//Carrega EPIs devolvidos
				cKeyTmp := 	""
				If lCall695
					cKeyTmp := 	aColsChk[ nX, nPosForn ] + aColsChk[ nX, nPosLoja ] + aColsChk[ nX, nPosEPI ] +;
					aColsChk[ nX, nPosNumC ] + SRA->RA_MAT + DtoS( aColsChk[ nX, nPosDtEn ] ) +;
					aColsChk[ nX, nPosHrEn ]
				Else
					cKeyTmp := TN3->TN3_FORNEC + TN3->TN3_LOJA + TN3->TN3_CODEPI + TN3->TN3_NUMCAP +;
					aColsChk[ nX, nPosMatr ] + DtoS( aColsChk[ nX, nPosDtEn ] ) + aColsChk[ nX, nPosHrEn ]
				EndIf
				If !lLogix
					If lTelaTLW .And. nSalTNF == nX
						For nXYZ := 1 To Len( aCols )
							If !aTail( aCols[ nXYZ ] ) .And. !Empty( aCols[ nXYZ, nPosQtDev ] )
								nDevoTotal += aCols[ nXYZ, nPosQtDev ]
								If aCols[ nXYZ, nPosTpDev ] == "1" .And. cLocal == aCols[ nXYZ, nPosLocDev ]
									dbSelectArea( "TLW" )
									dbSetOrder( 1 )//TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)
									If dbSeek( xFilial( "TLW" ) + cKeyTmp )
										If TLW->TLW_DTDEVO == aCols[ nXYZ, nPosDtDev ] .And. TLW->TLW_HRDEVO == aCols[ nXYZ, nPosHrDev ] .And.;
										TLW->TLW_TIPODV == aCols[ nXYZ, nPosTpDev ] .And. TLW->TLW_QTDEVO == aCols[ nXYZ, nPosQtDev ] .And.;
										TLW->TLW_LOCAL == aCols[ nXYZ, nPosLocDev ]
											Loop
										EndIf
									EndIf
									nDiffOS += aCols[ nXYZ, nPosQtDev ]
								EndIf
							EndIf
						Next nXYZ
					Else
						dbSelectArea( cAliasTLW )
						dbSetOrder( 1 )//TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)
						If dbSeek( cKeyTmp )
							While ( cAliasTLW )->( !Eof() ) .And. cKeyTmp == ;
								( cAliasTLW )->( TLW_FORNEC + TLW_LOJA + TLW_CODEPI + TLW_NUMCAP + TLW_MAT + DTOS( TLW_DTENTR ) + TLW_HRENTR )
								If ( cAliasTLW )->TLW_DELETE != _DELETADO .And. !Empty( ( cAliasTLW )->TLW_QTDEVO )
									nDevoTotal += ( cAliasTLW )->TLW_QTDEVO
									If ( cAliasTLW )->TLW_TIPODV == "1" .And. cLocal == ( cAliasTLW )->TLW_LOCAL
										dbSelectArea( "TLW" )
										dbSetOrder( 1 )
										If dbSeek( xFilial( "TLW" ) + cKeyTmp )
											If TLW->TLW_DTDEVO == ( cAliasTLW )->TLW_DTDEVO .And. TLW->TLW_HRDEVO == ( cAliasTLW )->TLW_HRDEVO .And.;
											 TLW->TLW_TIPODV == ( cAliasTLW )->TLW_TIPODV .And. TLW->TLW_QTDEVO == ( cAliasTLW)->TLW_QTDEVO .And.;
											 TLW->TLW_LOCAL == ( cAliasTLW )->TLW_LOCAL
												( cAliasTLW )->( dbSkip() )
												Loop
											EndIf
										EndIf
										nDiffOS += ( cAliasTLW )->TLW_QTDEVO
									EndIf
								EndIf
								( cAliasTLW )->( dbSkip() )
							End
						EndIf
						//Verifica se devolvou tudo
						lDevoTLW := nDevoTotal > 0 .And. aColsChk[ nX, nPosQtde ] == nDevoTotal
						If cLocal == aColsChk[ nX, nPosLocal ] .And. aColsChk[ nX, nPosInDe ] == "1" .And. !lDevoTLW .And.;
						 ( nPosTipoDv > 0 .And. aColsChk[ nX, nPosTipoDv ] == "1" )
							If ( aColsTNF[ nPosTNF, nPosInDe ] != "1" ) .Or.;
								( aColsChk[ nX, nPosLocal ] != aColsTNF[ nPosTNF, nPosLocal ] ) .Or.;
								IIf( lUsaRastr,;
										 ( aColsChk[ nX, nPosLot ] != aColsTNF[ nPosTNF, nPosLot ] ) .Or.;
										 ( aColsChk[ nX, nPosSubL ] != aColsTNF[ nPosTNF, nPosSubL ]),;
										 .F. )

								nDiffOS += IIf( nDevoTotal > 0, aColsChk[ nX, nPosQtde ] - nDevoTotal, aColsChk[ nX, nPosQtde ] )
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Next nX

	//---------
	// Entrega
	//---------
	If lChkEntr

		If nTipoReg == 1
			//-----------------------
			// Verifica sub-lote
			//-----------------------
			//Verificado o aCols e a origem (aColsTNF), no primeiro FOR seleciona qual array será verificado
			// e faz suas operações correspondentes a cada array.
			// o aCols é somado a nDiffOS
			// e aColsTNF é subtraido a nDiffOS
			For nY := 1 To 2

				aColsChk := aClone( IIf( nY == 1, aGridAux[ _nCols ], aColsTNF ) )

				For nX := 1 To Len( aColsChk )
					If !aTail( aColsChk[ nX ] ) .And. !( aColsChk[ nX, nPosInDe ] $ "1/3" )
						//Soma apenas os registro que são do mesmo local, lote, sublote e quando for chamada de MNDTA695/MDTA410 verifica o produto.
						If IIf( lUsaRastr,;
								 aColsChk[ nX, nPosLocal ] + aColsChk[ nX, nPosLot ] + aColsChk[ nX, nPosSubL ] == cLocal + cLote + cSubLote,;
								 aColsChk[ nX, nPosLocal ] == cLocal) .And.;
								 (IIf( lCall695, aColsChk[ nX, nPosEPI ] == cProduto, .T. ) )
							nDiffOS := IIf( nY == 1, nDiffOS + aColsChk[ nX, nPosQtde ], nDiffOS - aColsChk[ nX, nPosQtde ] )
						EndIf
					EndIf
				Next nX
			Next nY

		ElseIf nTipoReg == 2
			//------------------
			// Verifica lote
			//------------------
			//Verificado o aCols e a origem (aColsTNF), no primeiro FOR seleciona qual array será verificado
			// e faz suas operações correspondentes a cada array.
			// o aCols é somado a nDiffOS
			// e aColsTNF é subtraido a nDiffOS
			For nY := 1 To 2

				aColsChk := aClone( IIf( nY == 1, aGridAux[ _nCols ], aColsTNF ) )

				For nX := 1 To Len( aColsChk )
					If !aColsChk[nX, Len( aColsChk[nX] )] .And. !(aColsChk[nX, nPosInDe] $ "1/3") .And. lCall695
						If lUsaRastr
							If (aColsChk[ nX, nPosEPI ] + aColsChk[nX, nPosLocal] + aColsChk[ nX, nPosLot ] ==;
								cProduto + cLocal + cLote .And. Empty( aColsChk[ nX, nPosSubL ] ) ) .Or.;
								( aColsChk[nX, nPosLocal] + aColsChk[ nX, nPosLot ] == cLocal + cLote .And. Empty( aColsChk[ nX, nPosSubL ] ) )

							nDiffOS := IIf( nY == 1, nDiffOS + aColsChk[ nX, nPosQtde ], nDiffOS - aColsChk[ nX, nPosQtde ] )
							EndIf
						Else
							If aColsChk[ nX, nPosEPI ] + aColsChk[ nX, nPosLocal ] == cProduto + cLocal
								nDiffOS := IIf( nY == 1, nDiffOS + aColsChk [ nX, nPosQtde], nDiffOS - aColsChk [ nX, nPosQtde ] )
							EndIf
						EndIf
					EndIf
				Next nX
			Next nY

		ElseIf nTipoReg == 3
			//-----------------------------
			// Valida Saldo Enderecamento
			//-----------------------------
			//Verificado o aCols e a origem (aColsTNF), no primeiro FOR seleciona qual array será verificado
			// e faz suas operações correspondentes a cada array.
			// o aCols é somado a nDiffOS
			// e aColsTNF é subtraido a nDiffOS
			For nY := 1 To 2
				aColsChk := aClone( IIf( nY == 1, aGridAux[ _nCols ], aColsTNF ) )
				For nX := 1 To Len( aColsChk )
					If !aTail( aColsChk[ nX ] ) .And. !( aColsChk[ nX, nPosInDe ] $ "1/3" )
						If aColsChk[ nX, nPosLocal ] == cLocal .And. ;
						IIf( lLocaliza, aColsChk[ nX, nPosEnd ] == cLocaliz .And.;
						 aColsChk[ nX, nPosNSer ] == cNumSerie, .T. ) .And. IIf( lCall695, aColsChk[ nX, nPosEPI ] == cProduto, .T. ) .And.;
						IIf( lUsaRastr, aColsChk[ nX, nPosLot ] + aColsChk[ nX, nPosSubL ] == cLote + cSubLote, .T. )

							If aScan( aColsTNF, { | x | IIf( lCall695, aColsChk[ nX, nPosForn ]  == x[ nPosForn ]  .And. ;
							 aColsChk[ nX, nPosLoja ] == x[ nPosLoja ] .And. aColsChk[ nX, nPosEPI ] == x[ nPosEPI ] .And. ;
							 aColsChk[ nX, nPosNumC ]  == x[ nPosNumC ], .T. ) .And. aColsChk[ nX, nPosQtde ] == x[ nPosQtde ] .And. ;
							 aColsChk[ nX, nPosInDe ] == x[ nPosInDe ] .And. aColsChk[ nX, nPosDtEn ] == x[ nPosDtEn ] .And. ;
							 aColsChk[ nX, nPosHrEn ]  == x[ nPosHrEn ]  .And. aColsChk[ nX, nPosLocal ] == x[ nPosLocal ] .And. ;
							 IIf( lUsaRastr, aColsChk[ nX, nPosLot ] == x[ nPosLot ], .T. ) .And. ;
							 IIf( lUsaRastr, aColsChk[ nX, nPosSubL ] == x[ nPosSubL ], .T. ) .And. ;
							 IIf( lLocaliza, aColsChk[ nX, nPosEnd ] == x[ nPosEnd ] .And. aColsChk[ nX, nPosNSer ] == x[ nPosNSer ], .T. ) } ) == 0

								nDiffOS := IIf( nY == 1, nDiffOS + aColsChk[ nX, nPosQtde ], nDiffOS - aColsChk[ nX, nPosQtde ] )
							EndIf
						EndIf
					EndIf
				Next nX
			Next nY

		ElseIf nTipoReg == 4
			//----------------
			// Verifica SB2
			//----------------
			//Verificado o aCols e a origem (aColsTNF), no primeiro FOR seleciona qual array será verificado
			// e faz suas operações correspondentes a cada array.
			// o aCols é somado a nDiffOS
			// e aColsTNF é subtraido a nDiffOS
			For nY := 1 To 2

				aColsChk := aClone( IIf( nY == 1, aGridAux[ _nCols ], aColsTNF ) )
				aColsChk := fDelUltEle( aColsChk )

				For nX := 1 To Len( aColsChk )
					If !aTail( aColsChk[ nX ] ) .And. !( aColsChk[ nX, nPosInDe ] $ "1/3" )
						If ( lCall695 .And. aColsChk[ nX, nPosEPI ] + aColsChk[ nX, nPosLocal ] == cProduto + cLocal ) .Or.;
						( aColsChk[ nX, nPosLocal ] == cLocal )

							nDiffOS := IIf( nY == 1, nDiffOS + aColsChk[ nX, nPosQtde ], nDiffOS - aColsChk[ nX, nPosQtde ] )
						EndIf
					EndIf
				Next nX
			Next nY
		EndIf
	EndIf

Return nDiffOS

//---------------------------------------------------------------------
/*/{Protheus.doc} fDelUltEle
Função que valida se array esta preenchido e elimina ultima posição do
array caso esteja vazia.

@author Eloisa Anibaletto
@since 31/01/2023

@param aDados, contém o array que sera utilizado na função

/*/
//---------------------------------------------------------------------
Function fDelUltEle( aDados )

	If !Empty( aDados ) .And. Empty( aTail( aDados )[ 1 ] )
		aDel( aDados, Len( aDados ) )
		aSize( aDados, Len( aDados ) - 1 )
	EndIf

Return aDados

//------------------------------------------------------------------
/*/{Protheus.doc} fChange2
Funcao chamada ao mudar de linha na GetDados (Dev. Parcial)

@author Denis Hyroshi de Souza
@since 17/07/2001

@return Boolean .T.

@obs Uso MDTA695
/*/
//---------------------------------------------------------------------
Static Function fChange2( oGetAux )

	Local nPosLocDev := GdFieldPos( "TLW_LOCAL", oGetAux:aHeader )
	Local nAt		 := oGetAux:nAt

	If nPosLocDev > 0
		If Empty( oGetAux:aCols[ nAt, nPosLocDev ] )
			aCOLS[ nAt, nPosLocDev ] := cAlmoSvEn
			oGetAux:oBrowse:Refresh()
		EndIf
	EndIf

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} NGTLWEXCC
Valida se pode excluir a linha da devolucao

@author Denis Hyroshi de Souza
@since 12/05/10

@return Boolean lRet

@obs Uso MDTA695 / MDTA630
/*/
//---------------------------------------------------------------------
Function NGTLWEXCC()

	Local nPosTpDev := GdFieldPos( "TLW_TIPODV" )
	Local nPosDt    := GdFieldPos( "TLW_DTDEVO" )
	Local lRet      := .T.

	If !aTail( aCols[n] )
		If cUsaInt1 == "S" .And. aCols[n, nPosTpDev] != "2"
			dDataUlMes := SuperGetMv( "MV_ULMES" )
			dDataBloq  := SuperGetMv( "MV_DBLQMOV" )
			If !Empty( aCols[n, nPosDt] ) .And. ( dDataUlMes >= aCols[n, nPosDt] .Or. aCols[n, nPosDt] <= dDataBloq )

				Help( " ", 1, "FECHTO" )
				lRet := .F.
			EndIf
		EndIf
	EndIf

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT695EPIN
Monta tela com todos os EPI's necessarios ao funcionario

@type function

@source MDTA695.prx

@author Roger Rodrigues
@since 03/11/10

@param oGet, Objeto, Objeto da tela.

@sample MDT695EPIN( oGet )

@return Lógico, Sempre verdadeiro.
/*/
//---------------------------------------------------------------------
Function MDT695EPIN( oGet )

	Local oDlgEpiN
	Local oPnlHlp
	Local oPnlOpc
	Local oFont    := TFont():New( "Arial", , 14 )
	Local aSize	   := MsAdvSize( , .F., 430 )
	Local nCols
	Local lOk      := .F.
	Local aColsOk  := aClone( oGet:aCols )
	Local aHeadOk  := aClone( oGet:aHeader )
	Local aColsTp  := BLANKGETD( aHeadOk )
	Local aArea    := GetArea()
	Local dData695 := dDatabase
	Local dDataAux := CToD( "" )
	Local cTime695 := Substr( Time(), 1, 8 )
	Local nSizeSA2 := IIf( (TAMSX3( "A2_COD" )[1] ) < 1, 6, (TAMSX3( "A2_COD" )[1] ) )
	Local nSizeFOR := IIf( (TAMSX3( "A2_NOME" )[1] ) < 1, 30, (TAMSX3( "A2_NOME" )[1] ) )
	Local nSizeLoj := IIf( (TAMSX3( "A2_LOJA" )[1] ) < 1, 2, (TAMSX3( "A2_LOJA" )[1] ) )
	Local nSizeLoc := IIf( (TAMSX3( "TNF_LOCAL" )[1] ) < 1, 2, (TAMSX3( "TNF_LOCAL" )[1] ) )
	Local oTempTable

	//Variaveis de posicao da GetDados
	Local nPosFunc	:= GdFieldPos( "TNF_CODFUN" )
	Local nPosEPI	:= GdFieldPos( "TNF_CODEPI" )
	Local nPosForn	:= GdFieldPos( "TNF_FORNEC" )
	Local nPosLoja	:= GdFieldPos( "TNF_LOJA" )
	Local nPosDesc	:= GdFieldPos( "TNF_DESC" )
	Local nPosNumC	:= GdFieldPos( "TNF_NUMCAP" )
	Local nPosDtEn	:= GdFieldPos( "TNF_DTENTR" )
	Local nPosHrEn	:= GdFieldPos( "TNF_HRENTR" )
	Local nPosLocal	:= GdFieldPos( "TNF_LOCAL" )
	Local nPosInDe	:= GdFieldPos( "TNF_INDDEV" )
	Local nPosLeg	:= GdFieldPos( "COLBMP" )
	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lLogix	:= cMDTInteg == "2"
    Local lArqProd  := SuperGetMv( "MV_ARQPROD", .F., "SB1" ) == "SB1"
	Local cCodEPI   := ""

	Private oMarkEPI
	Private lObrTNB := (TNB->(FieldPos( "TNB_OBRIGA" )) > 0)
	Private lObrTNX := (TNX->(FieldPos( "TNX_TIPO" )) > 0)
	Private lTarTIK := !lSigaMdtPS .And. NGCADICBASE( "TIK_TAREFA", "A", "TIK", .F. )
	Private lGenSelFor := .F.

	//Variaveis do TRB
	Private aVetInr   := {}
	Private aDBFEPI   := {}
	Private aTRBEPI   := {}
	Private cAliasEPI := GetNextAlias()
	Private cArqEPI

	Private aEpiAlt := {} //Array com os Epi's que tiverem fornecedor alterado
	Private aRiscos := {} //Array com os Riscos do funcionario

	//Tamanhos de Campo
	Private nSizeSB1 := IIf( ( TAMSX3( "B1_DESC" )[1] ) < 1, 30, ( TAMSX3( "B1_DESC" )[1] ) )
	Private nSizeCod := IIf( ( TAMSX3( "B1_COD" )[1] ) < 1, 15, ( TAMSX3( "B1_COD" )[1] ) )

	//Variaveis de CheckBox
	Private oCheck1
	Private oCheck2
	Private oCheck3
	Private oCheck4
	Private oCheck5

	Store .F. To lCheck1, lCheck2, lCheck3, lCheck4, lCheck5

	//Se integracao com estoque
	If cUsaInt1 == "S"
		dDataUlMes := GetMV( 'MV_ULMES' )
		dDataBloq  := SuperGetMv( "MV_DBLQMOV" )
		dDataAux   := IIf( dDataUlMes > dDataBloq, dDataUlMes, dDataBloq )
		//Se data do fechamento do estoque maior que database, database sera alterada para um dia apos fecham.
		If dDataAux >= dData695
			dData695 := dDataAux + 1
		EndIf
	EndIf

	lInverte := .F.

	aAdd( aDBFEPI, { "OK", "C", 02, 0 } )
	aAdd( aDBFEPI, { "CODEPI", "C", nSizeCod, 0 } )
	aAdd( aDBFEPI, { "DESCRI", "C", nSizeSB1, 0 } )
	aAdd( aDBFEPI, { "FORNEC", "C", nSizeSA2, 0 } )
	aAdd( aDBFEPI, { "NOME", "C", nSizeFOR, 0 } )
	aAdd( aDBFEPI, { "LOJA", "C", nSizeLoj, 0 } )
	aAdd( aDBFEPI, { "NUMCAP", "C", 12, 0 } )
	aAdd( aDBFEPI, { "DTVENC", "D", 08, 0 } )
	If TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
		aAdd( aDBFEPI, { "DTVALI", "D", 08, 0 } )
	EndIf
	If lObrTNB .Or. lObrTNX
		aAdd( aDBFEPI, { "OBRIGA", "C", 03, 0 } )
	EndIf
	aAdd( aDBFEPI, { "LOCPAD", "C", nSizeLoc, 0 } )
	aAdd( aTRBEPI, { "OK", NIL, " ", } )
	aAdd( aTRBEPI, { "CODEPI", NIL, STR0027, } ) //"Codigo"
	aAdd( aTRBEPI, { "DESCRI", NIL, STR0028, } ) //"Descricao do Epi"
	aAdd( aTRBEPI, { "FORNEC", NIL, STR0029, } ) //"Fornecedor"
	aAdd( aTRBEPI, { "NOME", NIL, STR0006, } ) //"Nome"
	aAdd( aTRBEPI, { "LOJA", NIL, STR0030, } ) //"Loja"
	aAdd( aTRBEPI, { "NUMCAP", NIL, STR0031, } ) //"Certif. Aprovacao"
	aAdd( aTRBEPI, { "DTVENC", NIL, STR0032, } ) //"Data Vencimento"
	If TN3->( FieldPos( "TN3_DTVALI" ) ) > 0
		aAdd( aTRBEPI, { "DTVALI", NIL, STR0249, } ) //"Data Validade"
	EndIf
	If lObrTNB .Or. lObrTNX
		aAdd( aTRBEPI, { "OBRIGA", NIL, STR0052, } ) //"Obrigatório"
	EndIf
	//Cria arquivo temporario
	oTempTable := FWTemporaryTable():New( cAliasEPI, aDBFEPI )
	oTempTable:AddIndex( "1", { "CODEPI","FORNEC" } )
	oTempTable:Create()

	oDlgEpiN := MSDialog():New( 0, 0, ( aSize[6]/1.5 ), ( aSize[5] /1.5 ), STR0198, , , , , CLR_BLACK, CLR_WHITE, , GetWndDefault(), .T. ) //"Epi's Necessários ao Funcionário"

	//------------------
	// Painel de Help
	//------------------
	oPnlAll := TPanel():New( 0, 0, , oDlgEpiN, , , , , , 0, 0, .F., .F. )
	oPnlAll:Align := CONTROL_ALIGN_ALLCLIENT

	oPnlTop := TPanel():New( 0, 0, , oPnlAll, , , , , , 0, 60, .F., .F. )
	oPnlTop:Align := CONTROL_ALIGN_TOP

	oPnlHlp := TPanel():New( 0, 0, , oPnlTop, , , , , , 0, 50, .F., .F. )
	oPnlHlp:Align := CONTROL_ALIGN_TOP

	TGroup():New( 04, 04, 40, aSize[5]/4, , oPnlHlp, , , .T. )
	TSay():New( 06, 15, { || STR0199 }, oPnlHlp, , oFont, , , , .T. ) //"Estes são os Epi's necessários ao funcionário."
	TSay():New( 17, 15, { || STR0036 }, oPnlHlp, , oFont, , , , .T. ) //"Selecione os epi's que serão entregues ao funcionário."
	TSay():New( 27, 15, { || STR0037 }, oPnlHlp, , oFont, , , , .T. ) //"Caso deseje alterar o fornecedor do epi, clique no botão 'Alterar'."

	oBtnAlt := tButton():New( 22, aSize[5]/3.5, STR0038, oPnlHlp, {|| }, 40, 10, , , , .T. ) //"&Alterar"
	oBtnAlt:bAction := { || fActBtAlt(), IIf( lGenSelFor, oDlgEpiN:End(), Nil ) } //"Favor selecionar um Epi."##"Atenção"

	oPnlOpc := TPanel():New( 0, 0, , oPnlTop, , , , , , 0, 10, .F., .F. )
	oPnlOpc:Align := CONTROL_ALIGN_ALLCLIENT

	oCheck1 := TCheckBox():New( 01, 01, STR0201, , oPnlOpc, 40, 7, , , , , , , , .T., , , ) //"Função"
	oCheck1:bSetGet   := { | u | IIf( PCount() == 0, lCheck1, lCheck1 := u ) }
	oCheck1:bLClicked := { | u | f695CAREPN( u, 1 ) }

	oCheck2 := TCheckBox():New( 01, 60, STR0202, , oPnlOpc, 80, 7, , , , , , , , .T., , , ) //"Centro de Custo"
	oCheck2:bSetGet   := { | u | IIf( PCount() == 0, lCheck2, lCheck2 := u ) }
	oCheck2:bLClicked := { | u | f695CAREPN( u, 2 ) }

	oCheck3 := TCheckBox():New( 01, 135, STR0203, , oPnlOpc, 40, 7, , , , , , , , .T., , , ) //"Risco"
	oCheck3:bSetGet   := { | u | IIf( PCount() == 0, lCheck3, lCheck3 := u ) }
	oCheck3:bLClicked := { | u | f695CAREPN( u, 3 ) }

	oCheck4 := TCheckBox():New( 01, 195, STR0204, , oPnlOpc, 80, 7, , , , , , , , .T., , , )//"Função x Centro de Custo"
	oCheck4:bSetGet   := { | u | IIf(PCount() == 0, lCheck4, lCheck4 := u ) }
	oCheck4:bLClicked := { | u | f695CAREPN( u, 4 ) }

	If lTarTIK
		oCheck5 := TCheckBox():New( 01, 290, STR0232, , oPnlOpc, 80, 7, , , , , , , , .T., , , )//"Tarefa"
		oCheck5:bSetGet   := { | u | IIf(PCount() == 0, lCheck5, lCheck5 := u ) }
		oCheck5:bLClicked := { | u | f695CAREPN( u, 5 ) }
	EndIf

	oPnlMrk := TPanel():New( 0, 0, , oPnlAll, , , , , , 0, 0, .F., .F. )
	oPnlMrk:Align := CONTROL_ALIGN_ALLCLIENT

	oMarkEPI := MsSelect():New( cAliasEPI, "OK", , aTRBEPI, @lINVERTE, @cMARCA, {55, 5, 215, 375}, , , oPnlMrk )
	oMarkEPI:oBrowse:lHASMARK := .T.
	oMarkEPI:oBrowse:lCANALLMARK := .T.
	oMarkEPI:oBrowse:bALLMARK := {|| f695MRK( cMarca ) }
	oMarkEPI:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	Activate MsDialog oDlgEpiN On Init EnchoiceBar( oDlgEpiN, {|| lOk := .T., MDT695GE( cAliasEPI ) .And. oDlgEpiN:End()},;
													 {|| lOk := .F., oDlgEpiN:End()} ) Centered

	If lOk
		If Empty( aColsOk[ oGet:nAt, nPosEpi ] )
			aDel( aColsOk, oGet:nAt )
			aSize( aColsOk, Len( aColsOk ) - 1 )
		EndIf

		dbSelectArea( cAliasEPI )
		dbGoTop()
		While ( cAliasEPI )->( !Eof() )
			If !Empty( ( cAliasEPI )->OK ) .And. aScan( oGet:aCols, { | x |	(cAliasEPI)->CODEPI == x[nPosEpi] .And.;
			 (cAliasEPI)->FORNEC == x[nPosForn] .And. ;
			 (cAliasEPI)->LOJA   == x[nPosLoja] .And. ;
			 dData695 == x[nPosDtEn] .And. ;
			 cTime695 == Substr( x[nPosHrEn], 1, 8 ) .And.;
			 (cAliasEPI)->NUMCAP == x[nPosNumC] } ) == 0
				aAdd( aColsOk, aClone( aColsTp[ 1 ] ) )
				If nPosFunc > 0
					aColsOk[ Len( aColsOk ), nPosFunc ] := SRA->RA_CODFUNC
				EndIf
				If nPosEpi > 0
					aColsOk[ Len( aColsOk ), nPosEpi] := (cAliasEPI)->CODEPI
				EndIf
				If nPosDesc > 0
					aColsOk[ Len( aColsOk ), nPosDesc] := (cAliasEPI)->DESCRI
				EndIf
				If nPosForn > 0
					aColsOk[ Len( aColsOk ), nPosForn] := (cAliasEPI)->FORNEC
				EndIf
				If nPosLoja > 0
					aColsOk[ Len( aColsOk ), nPosLoja] := (cAliasEPI)->LOJA
				EndIf
				If nPosNumC > 0
					aColsOk[ Len( aColsOk ), nPosNumC] := (cAliasEPI)->NUMCAP
				EndIf
				If nPosHrEn > 0
					aColsOk[ Len( aColsOk ), nPosHrEn] := cTime695
				EndIf
				If nPosLocal > 0
					If !lArqProd
						cCODEPI := (cAliasEPI)->CODEPI
						aAreaSB1 := SB1->( GetArea() )//Salva area da SB1
						dbSelectArea( "SBZ" )
						dbSetOrder( 1 )//BZ_FILIAL+BZ_COD
						If dbSeek( xFilial( "SBZ" ) + cCODEPI )
							aColsOk[ Len( aColsOk ), nPosLocal] := SBZ->BZ_LOCPAD
						EndIf
						RestArea( aAreaSB1 )
					Else
						aColsOk[ Len( aColsOk ), nPosLocal] := (cAliasEPI)->LOCPAD
					EndIf
				EndIf
				If nPosInDe > 0 .And. lGera_SA
					aColsOk[ Len( aColsOk ), nPosInDe] := "3"
				EndIf

				If nPosDtEn > 0
					aColsOk[ Len( aColsOk ), nPosDtEn] := dData695
				EndIf

				If nPosInDe > 0 .And. nPosLeg > 0
					If lLogix
						aColsOk[ Len( aColsOk ), nPosLeg] := "BR_AMARELO"
					Else
						If aColsOk[ Len( aColsOk ), nPosInDe] == "3"
							aColsOk[ Len( aColsOk ), nPosLeg] := "BR_AMARELO"
						ElseIf aColsOk[ Len( aColsOk ), nPosInDe] == "1"
							aColsOk[ Len( aColsOk ), nPosLeg] := "BR_VERMELHO"
						Else
							aColsOk[ Len( aColsOk ), nPosLeg] := "BR_VERDE"
						EndIf
					EndIf
				EndIf
			EndIf
			( cAliasEPI )->(dbSkip())
		End
		oGet:aCols := aClone( aColsOK )
		If Len( aColsOk ) > 0
			oGet:nAt :=  Len( aColsOk )
		EndIf
	EndIf

	oGet:oBrowse:Refresh()
	oGet:oBrowse:SetFocus()

	//Deleta TRB
	oTempTable:Delete()

	dbSelectArea( "SRA" )
	RestArea( aArea )

Return .T.
//------------------------------------------------------------------
/*/{Protheus.doc} f695CAREPN
Carrega os Epis necessarios ao funcionario de acordo com os parametros

@author Roger Rodrigues
@since 11/03/2010

@return Boolean .T.

@obs Uso MDTA695 / MDTA410
/*/
//---------------------------------------------------------------------
Static Function f695CAREPN( oCheckAux, nOpcao )

	Local lFuncao	:= lCheck1
	Local lCentro	:= lCheck2
	Local lRisco	:= lCheck3
	Local lFunCC	:= lCheck4
	Local lFound	:= .F.
	Local lGrava 	:= .F.
	Local aAreaAux 	:= SRA->( GetArea() )
	Local nX
	Local j

	//Variaveis de prestador
	Local cSeekTNB	:= xFilial( "TNB" ) + SRA->RA_CODFUNC
	Local cCondTNB	:= "TNB->TNB_FILIAL+TNB->TNB_CODFUN"
	Local cCond2TNB	:= xFilial( "TNB" ) + SRA->RA_CODFUNC

	If lSigaMdtps
		cSeekTNB	:= xFilial( "TNB" ) + cCliMdtps + SRA->RA_CODFUNC
		cCondTNB	:= "TNB->TNB_FILIAL+TNB->TNB_CLIENT+TNB->TNB_LOJA+TNB->TNB_CODFUN"
		cCond2TNB	:= xFilial( "TNB" ) + cCliMdtps + SRA->RA_CODFUNC
	EndIf

	//Verifica as opcoes Funcao, CC e Funcao x CC
	If nOpcao == 4 .And. (lCheck1 .Or. lCheck2)
		lCheck1 := .F.
		lCheck2 := .F.
	ElseIf (nOpcao == 1 .Or. nOpcao == 2 ) .And. lCheck4
		lCheck4 := .F.
	EndIf

	dbSelectArea( cAliasEPI )
	Zap

	//--------------------------------------
	// Função / Função x Centro de Custo
	//--------------------------------------
	If lCheck1 .Or. lCheck4
		lFound := .F.
		dbSelectArea( "TNB" )
		dbSetOrder( 1 )
		dbSeek( cSeekTNB )
		ProcRegua( TNB->(RecCount()) )
		While !Eof() .And. &(cCondTNB) == cCond2TNB
			IncProc()
			//Se for Funcao x C.C.
			dbSelectArea( "TOH" )
			dbSetOrder( 1 )
			If !dbSeek( xFilial( "TOH" ) + SRA->RA_CC + TNB->TNB_CODEPI ) .And. lCheck4
				dbSelectArea( "TNB" )
				dbSkip()
				Loop
			EndIf

			lGrava := fGrvEPINec( TNB->TNB_CODEPI, nOpcao )
			lFound := IIf( lGrava, .T., lFound )

			dbSelectArea( "TNB" )
			dbSkip()
		End
		If !lFound
			If nOpcao == 1
				Msgstop( STR0205 + CRLF +;//"Não existem EPI's para serem visualizados nessa opção."
						 CRLF + STR0120 + CRLF +;  //"Verifique se:"
						 STR0121 + CRLF +;  //"1) Existe EPI no cadastro de produtos e ele não está bloqueado."
						 STR0122 + CRLF +;  //"2) O EPI está relacionado à função do funcionário."
						 STR0123 )		   //"3) Existe um fornecedor para o EPI."
			ElseIf nOpcao == 4
				Msgstop( STR0205 + CRLF +;//"Não existem EPI's para serem visualizados nessa opção."
						 CRLF + STR0120 + CRLF +;  //"Verifique se:"
						 STR0121 + CRLF +;  //"1) Existe EPI no cadastro de produtos e ele não está bloqueado."
						 STR0126 + CRLF +;  //"2) O EPI está relacionado à função e centro de custo do funcionário."
						 STR0123 )		   //"3) Existe um fornecedor para o EPI."
			EndIf
		EndIf

		If lSigaMdtps
			dbSelectArea( "TOS" )
			dbSetOrder( 2 )  //TOS_FILIAL+TOS_CLIENT+TOS_LOJA+TOS_CODFUN
			dbSeek( xFilial( "TOS" ) + cCliMdtps + SRA->RA_CODFUNC )
		Else
			dbSelectArea( "SRJ" )
			dbSetOrder( 1 )
			dbSeek( xFilial( "SRJ" ) + SRA->RA_CODFUNC )
		EndIf
	EndIf

	//-------------------
	// Centro de Custo
	//-------------------
	If lCheck2
		lFound := .F.
		dbSelectArea( "TOH" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "TOH" ) + SRA->RA_CC )
		ProcRegua( TOH->(RecCount()) )
		While !Eof() .And. TOH->TOH_FILIAL + TOH->TOH_CC == xFilial( "TOH" ) + SRA->RA_CC
			IncProc()

			//Se a Função estiver marcada e o epi for o mesmo não retorna
			dbSelectArea( "TNB" )
			dbSetOrder( 1 )
			If dbSeek( xFilial( "TNB" ) + SRA->RA_CODFUNC + TOH->TOH_CODEPI ) .And. lCheck1
				dbSelectArea( "TOH" )
				dbSkip()

				lFound := .T.
			Else

				lGrava := fGrvEPINec( TOH->TOH_CODEPI, nOpcao )
				lFound := IIf( lGrava, .T., lFound )

				dbSelectArea( "TOH" )
				Dbskip()

			EndIf
		EndDo
		If !lFound .And. nOpcao == 2
			Msgstop( STR0205 + CRLF +;//"Não existem EPI's para serem visualizados nessa opção."
					 CRLF + STR0120 + CRLF +;  //"Verifique se:"
					 STR0121 + CRLF +;  //"1) Existe EPI no cadastro de produtos e ele não está bloqueado."
					 STR0125 + CRLF +;  //"2) O EPI está relacionado ao centro de custo do funcionário."
					 STR0123 )		   //"3) Existe um fornecedor para o EPI."
		EndIf
	EndIf

	//-------------
	// Risco
	//-------------
	If lCheck3
		lFound := .F.
		If Len( aRiscos ) == 0
			aRiscos := MDTRETRIS( , , , , , , , .F. )[1]
			RestArea( aAreaAux )
		EndIf
		ProcRegua( Len( aRiscos ) )
		For nX:=1 To Len( aRiscos )
			IncProc()
			dbSelectArea( "TNX" )
			dbSetOrder( 1 )
			dbSeek( xFilial( "TNX" ) + aRiscos[ nX, 1 ] )
			While !Eof() .And. TNX->TNX_FILIAL + TNX->TNX_NUMRIS == xFilial( "TNX" ) + aRiscos[ nX, 1 ]

				lGrava := fGrvEPINec( TNX->TNX_EPI, nOpcao )
				lFound := IIf( lGrava, .T., lFound )
				dbSelectArea( "TNX" )
				Dbskip()
			End
		Next i
		If !lFound .And. nOpcao == 3
			Msgstop( STR0205 + CRLF +;//"Não existem EPI's para serem visualizados nessa opção."
					 CRLF + STR0120 + CRLF +;  //"Verifique se:"
					 STR0121 + CRLF +;  //"1) Existe EPI no cadastro de produtos e ele não está bloqueado."
					 STR0206 + CRLF +;  //"2) O EPI está relacionado aos riscos que o funcionário está exposto."
					 STR0123 + CRLF +;  //"3) Existe um fornecedor para o EPI."
					 STR0260 )			//"4) O Risco possui data de avaliação."
		EndIf
	EndIf

	//-----------
	// Tarefas
	//-----------
	If lCheck5
		lFound := .F.
		dbSelectArea( "TN6" )
		dbSetOrder( 2 )//TN6_FILIAL+TN6_MAT
		dbSeek( xFilial( "TN6" ) + SRA->RA_MAT )
		While !Eof() .And. TN6->TN6_FILIAL == xFilial( "TN6" ) .And. TN6->TN6_MAT == SRA->RA_MAT
			dbSelectArea( "TIK" )
			dbSetOrder( 1 ) //TIK_FILIAL+TIK_TAREFA+TIK_EPI
			If !dbSeek( xFilial( "TIK" ) + TN6->TN6_CODTAR ) .Or. !(TN6->TN6_DTINIC <= dDatabase .And.;
				 (TN6->TN6_DTTERM >= dDatabase .Or. Empty( TN6->TN6_DTTERM ) ) )
				dbSelectArea( "TN6" )
				dbSkip()
				Loop
			EndIf

			While !Eof() .And. TIK->TIK_FILIAL == xFilial( "TIK" ) .And. TIK->TIK_TAREFA == TN6->TN6_CODTAR

				lGrava := fGrvEPINec( TIK->TIK_EPI, nOpcao )
				lFound := IIf( lGrava, .T., lFound )

				dbSelectArea( "TIK" )
				dbSkip()
			End

			dbSelectArea( "TN6" )
			dbSkip()
		End
		If !lFound .And. nOpcao == 5
			Msgstop( STR0205 + CRLF +;//"Não existem EPI's para serem visualizados nessa opção."
					 CRLF + STR0120 + CRLF +;  //"Verifique se:"
					 STR0121 + CRLF +;  //"1) Existe EPI no cadastro de produtos e ele não está bloqueado."
					 STR0233 + CRLF +;  //"2) O EPI está relacionado a tarefa do funcionário."
					 STR0123 )		   //"3) Existe um fornecedor para o EPI."
		EndIf
	EndIf

	dbSelectArea( cAliasEPI )
	dbGoTop()

	//Atualiza itens da tela
	oMarkEPI:oBrowse:Refresh()

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} f695MRK
Inverte marcacao de todos EPI's

@author Roger Rodrigues
@since 04/11/2010

@return Boolean .T.

@obs Uso MDTA695 / MDTA410
/*/
//---------------------------------------------------------------------
Static Function f695MRK( cMarca )

	Local aArea := GetArea()

	dbSelectArea( cAliasEPI )
	dbGoTop()
	While !Eof()
		(cAliasEPI)->OK := IIf( (cAliasEPI)->OK == "  ", cMARCA, "  " )
		dbSkip()
	End

	RestArea( aArea )
Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} AllDigit
Função para reduzir codigo da Biometria.

@author Rodrigo Soledade
@since 10/07/2013

@return Boolean lRet

@obs Uso MDTA695
/*/
//---------------------------------------------------------------------
Static Function AllDigit( cVar )

	Local lRet	:= .T.
	Local nX	:= 0

	For nX := 1 To Len( cVar )
		If ! IsDigit( SubStr( cVar, nX, 1 ) )
			lRet := .F.
			Exit
		EndIf
	Next

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NG695EPIF
Função para seleção de um EPI relacionado ao EPI genérico informado na
entrega.

@type function

@source MDTA695.prx

@param cForn , Caracter, Código do Fornecedor
@param cLoj, Caracter, Código da Loja
@param cEpiPai, Caracter, Código do Epi Pai
@param [cMensagem], Caractere, Mensagem para aparecer no topo da tela de
seleção dos EPIs filhos

@author Cezar Augusto Padilha
@since 12/04/2013

@sample NG695EPIF( "0001", "01", "00000001" )

@return Caracter, Código do Epi filho.
/*/
//---------------------------------------------------------------------
Function NG695EPIF( cForn, cLoj, cEpiPai, cMensagem )

	Local nX
	Local aEpiFil	:= {}
	Local aEpis     := {}
	Local aCabec    := { STR0214, STR0215, STR0216, STR0217, STR0218, STR0219  }//"Epi"//"Descrição"//"Num. Cap."//"Dt. Venc."//"Dt. Inic."//"Dt. Fim"
	Local lRet      := .T.
	Local nParEPIV  := SuperGetMV( "MV_MDTEPIV", .F., 1 ) //Indica se EPI vencida sera entregue ou nao.

	Default cMensagem := STR0213 //"Indique para qual EPI genérico vinculado ao fornecedor que deseja relacionar os EPIs Filhos."

	If TL0->( FieldPos( "TL0_DTVALI" ) ) > 0
		aAdd( aCabec, STR0251 ) //"Dt. Valid."
	EndIf

	dbSelectArea( "TL0" )
	dbSetOrder( 1 )
	dbSeek( xFilial( "TL0" ) + cEpiPai + cForn + cLoj )
	While TL0->( !Eof() ) .And. TL0->TL0_EPIGEN + TL0->TL0_FORNEC + TL0->TL0_LOJA == cEpiPai + cForn + cLoj

		If TL0->TL0_DTVENC >= dDataBase .Or. nParEPIV != 2

			If dDataBase >= TL0->TL0_DTINIC .And. ( Empty( DTOS( TL0->TL0_DTFIM ) ) .Or. dDataBase <= TL0->TL0_DTFIM )

				aAdd( aEpis, { TL0->TL0_EPIFIL,;
					NGSEEK( 'SB1', TL0->TL0_EPIFIL, 1, 'SB1->B1_DESC' ),;
						 TL0->TL0_NUMCAP,;
						 TL0->TL0_DTVENC,;
					 	 TL0->TL0_DTINIC,;
					 	 TL0->TL0_DTFIM } )
				If TL0->( FieldPos( "TL0_DTVALI" ) ) > 0
					aAdd( aEpis[Len( aEpis )], TL0->TL0_DTVALI )
				EndIf

			EndIf
		EndIf

		dbSelectArea( "TL0" )
		TL0->( dbSkip() )

	End

	If Len( aEpis ) == 1
		aEpiFil := { aEpis[ 1, 1 ], aEpis[ 1, 3 ]}
	ElseIf Len( aEpis ) > 1

		// Tela de seleção do EPI
		Define Font oFontN Name "Arial" Size 07, 17

		Define msDialog oDlgP Title STR0212 From 000, 000 To 450, 660 Pixel //"Seleção do EPI"
		oDlgP:lEscClose := .F. //Desabilita fechar a tela com o botão ESC

		oPnlTopo := TPanel():New( 00, 00, , oDlgP, , , , , , 400, 30, .F., .F. )
		oPnlTopo:Align := CONTROL_ALIGN_TOP

		TSay():New( 07, 08, { || cMensagem }, oPnlTopo, , oFontN, , , , .T. )

		oPnlSel := TPanel():New( 15, 00, , oDlgP, , , , , , 400, 50, .F., .F. )
		oPnlSel:Align := CONTROL_ALIGN_ALLCLIENT

		oBrwEPI := TCBrowse():New( 2, 5, 323, 157, , , , oPnlSel, , , , {||}, {||}, , , , , , , .F., , .T., , .F., , .T., .T. )
		For nX := 1 To Len( aCabec )
			oBrwEPI:AddColumn( TCColumn():New( aCabec[nX], &("{ || aEpis[oBrwEPI:nAt," + cValToChar( nX ) + "]}"), , , , , , .F., .F., , , , , ) )
		Next nX

		oBrwEPI:SetArray(aEpis) // Seta vetor para a browse
		oBrwEPI:bLine := {|| {aEpis[oBrwEPI:nAt, 1], aEpis[oBrwEPI:nAt, 2], aEpis[oBrwEPI:nAt, 3], aEpis[oBrwEPI:nAt, 4], aEpis[oBrwEPI:nAt, 5],;
							aEpis[oBrwEPI:nAt, 6], aEpis[oBrwEPI:nAt, 7 ] } }
		oBrwEPI:bChange := {|| (aEpiFil := { aEpis[oBrwEPI:nAt, 1], aEpis[oBrwEPI:nAt, 3] } )}

		oBrnOk := tButton():New( 180, 307, STR0220, oPnlSel, {|| (lRet := .T., oDlgP:End())}, 20, 11, , , , .T. ) //"Ok"

		Activate MsDialog oDlgP Valid lRet Centered

	Else
		//"Atenção" # "Não foi encontrado nenhum EPI filho relacionado ao EPI genérico."
		Help( " ", 1, STR0144, , STR0211, 4, 5 )
	EndIf

Return aEpiFil
//---------------------------------------------------------------------
/*/{Protheus.doc} NG695SELFR
Função para seleção de de um dos fornecedores do EPI genérico.

@author Cezar Augusto Padilha
@since 15/04/2013
@version MP10
/*/
//---------------------------------------------------------------------
Static Function NG695SELFR(aForns)

	Local aRet := {}
	Local lRet := .F.

	// Tela de seleção do Fornecedor para EPI genérico
	Define Font oFontN Name "Arial" Size 07, 17

	Define msDialog oDlgP Title STR0221 From 000, 000 To 450, 660 Pixel //"Seleção de Fornecedor"
	oDlgP:lEscClose := .F. //Desabilita fechar a tela com o botão ESC

	oPnlTop := TPanel():New( 00, 00, , oDlgP, , , , , , 400, 30, .F., .F. )
	oPnlTop:Align := CONTROL_ALIGN_TOP

	TSay():New( 07, 08, { || STR0222 }, oPnlTop, , oFontN, , , , .T. )//"Indique para qual fornecedor deseja buscar os EPIs Filhos:"

	oPnlFor := TPanel():New( 15, 00, , oDlgP, , , , , , 400, 50, .F., .F. )
	oPnlFor:Align := CONTROL_ALIGN_ALLCLIENT

	oBrwEPI := TCBrowse():New( 2, 5, 323, 157, , , , oPnlFor, , , , {||}, {||}, , , , , , , .F., , .T., , .F., , .T., .T. )
	oBrwEPI:AddColumn( TCColumn():New( STR0223, {|| aForns[oBrwEPI:nAt, 1] }, , , , , , .F., .F., , , , , ) ) //"Fornecedor"
	oBrwEPI:AddColumn( TCColumn():New( STR0224, {|| NGSEEK( 'SA2', aForns[oBrwEPI:nAt, 1], 1, 'SA2->A2_NOME' ) }, , , , , , .F., .F., , , , , ) ) //"Nome"
	oBrwEPI:AddColumn( TCColumn():New( STR0130, {|| aForns[oBrwEPI:nAt, 2] }, , , , , , .F., .F., , , , , ) ) //"Loja"
	oBrwEPI:SetArray( aForns ) // Seta vetor para a browse
	oBrwEPI:bLine := { || { aForns[oBrwEPI:nAt, 1], aForns[oBrwEPI:nAt, 2] } }
	oBrwEPI:bChange := {|| (aRet := { { aForns[oBrwEPI:nAt, 1], aForns[oBrwEPI:nAt, 2] } } ) }

	oBrnOk := tButton():New( 180, 307, STR0220, oPnlFor, {|| (lRet := .T., oDlgP:End())}, 20, 11, , , , .T. ) //"Ok"

	Activate MsDialog oDlgP Valid lRet Centered

Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT695Loc
Função de atalho F4 para consulta de saldo por endereço.

@author Guilherme Benkendorf
@since 05/02/2013
@version MP11
@return Nil, Sempre nulo
/*/
//---------------------------------------------------------------------
Function MDT695Loc( oGet )

	Local nAt
	Local aColsOK  := {}
	Local aGridAux := fStructEPI()

	Local cReadVar := ReadVar()
	//Variaveis para posicionamento no aHeader
	Local nPosEPI
	Local nPosLoca
	Local nPosQtde
	Local nPosLot
	Local nPosSubL
	Local cAlias   := Alias()

	Private cProduto1
	Private cLocOrig
	Private nQtd
	Private cNumLote
	Private cLoteDigi

	If cReadVar == "M->TNF_ENDLOC"

		If( ValType( oGet ) != Nil )
			nAt := aGridAux[ _nAt ]
			aColsOk := aClone( aGridAux[ _nCols, nAt ] )
		EndIf

		If FindFunction( "F4Localiz" ) .And. Len( aColsOK ) > 0 .And. nAt > 0
			//Encontra posicionamento de campos no aHeader
			nPosEPI	:= GdFieldPos( "TNF_CODEPI", aGridAux[ _nHeader ] )//cProduto1
			nPosLoca:= GdFieldPos( "TNF_LOCAL", aGridAux[ _nHeader ] )//cLocOrig
			nPosQtde:= GdFieldPos( "TNF_QTDENT", aGridAux[ _nHeader ] )//nQtd
			nPosLot := GdFieldPos( "TNF_LOTECT", aGridAux[ _nHeader ] )//cNumLote
			nPosSubL:= GdFieldPos( "TNF_LOTESB", aGridAux[ _nHeader ] )//cLoteDigi
			//--------------------------------------------------------------------------------
			// Verificação do produto, caso for chamado da rotina MDTA630 utiliza TN3_CODEPI.
			// Caso contrario utilizará posição do aCols
			//--------------------------------------------------------------------------------
			If IsInCallStack( "MDTA630" ) // EPI x Funcionario
				cProduto1 := TN3->TN3_CODEPI
			Else
				cProduto1 := IIf( nPosEPI > 0, aColsOK[ nPosEPI ], "" )
			EndIf
			cLocOrig  := IIf( nPosLoca > 0, aColsOK[ nPosLoca ], "" )
			nQtd      := IIf( nPosQtde  > 0, aColsOK[ nPosQtde], "" )
			cNumLote  := IIf( nPosLot > 0, aColsOK[ nPosLot ], "" )
			cLoteDigi := IIf( nPosSubL > 0, aColsOK[ nPosSubL ], "" )

			//---------------------------------------------
			// Função do fonte sigacusb.prx retorna tela
			// para consulta de saldo por endereço
			//---------------------------------------------
			F4Localiz( , , , "A310", , , , cReadVar )

		EndIf

	ElseIf cUsaInt1 == "S" //Se possui integração com o estoque

		If cReadVar == "M->TNF_CODEPI"

			MaViewSB2( M->TNF_CODEPI )

		ElseIf cReadVar == "M->TNF_QTDENT" .Or. cReadVar == "M->TNF_LOCAL"

			If( ValType( oGet ) != Nil )
				nX := oGet:oBrowse:nAt
				aColsOk := aClone( aCols )
				aHeadOK := aClone( aHeader )
			EndIf
			If Len( aColsOK ) > 0 .And. nX > 0
				//Encontra posicionamento de campos no aHeader
				nPosCodE := aScan( aHeadOK, {|x| AllTrim( Upper( X[2] ) ) == "TNF_CODEPI" } )//cProduto
				//---------------------------------------------
				// Função do fonte comxfun.prx retorna tela
				// para consulta de saldo
				//---------------------------------------------
				MaViewSB2( aColsOK[ nX, nPosCodE ] )
			EndIf

		ElseIf cAlias == "SB1" .And. !Empty( SB1->B1_COD )

			MaViewSB2( SB1->B1_COD )

		EndIf

	EndIf

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTVALTNF()
Valida alteração dos campos da TNF - EPI's entregues

@Obs Utilização:	X3_VALID de->	TNF_CODEPI\TNF_MAT\TNF_DTENTR\TNF_HRENTR\
TNF_QTDENT\TNF_MOTIVO\TNF_LOCAL\TNF_EPIEFI\
TNF_DTMANU\TNF_LOTECT\TNF_LOTESB\TNF_ENDLOC\
TNF_NSERIE

@author Bruno Lobo
@since 20/08/2014
@version MP11
/*/
//---------------------------------------------------------------------
Function MDTVALTNF()

	Local lRet       := .T.
	Local lEpiDevBio := .F.
	Local lChk       := .T.
	Local lCall630   := IsInCallStack( "MDTA630" )
	Local lCall695   := IsInCallStack( "MDTA695" )
	Local lCall410   := IsInCallStack( "MDTA410" )
	Local dDataBloq  := SuperGetMv( "MV_DBLQMOV" ) // Data para bloqueio de movimentos.
	Local aArea
	Local cFornec    := ""
	Local cLojFor    := ""
	Local cCodEPI    := ""
	Local cNumCAP    := ""

	Local nDtReci	 := GdFieldPos( "TNF_DTRECI", aHeader )
	Local nPosCpo	 := GdFieldPos( Substr( ReadVar(), 4, Len( ReadVar() ) ), aHeader )
	Local nPosForn	 := GdFieldPos( "TNF_FORNEC", aHeader )
	Local nPosLoja	 := GdFieldPos( "TNF_LOJA", aHeader )
	Local nPosEPI	 := GdFieldPos( "TNF_CODEPI", aHeader )
	Local nPosNumC	 := GdFieldPos( "TNF_NUMCAP", aHeader )
	Local nPosDtEn	 := GdFieldPos( "TNF_DTENTR", aHeader )
	Local nPosHrEn	 := GdFieldPos( "TNF_HRENTR", aHeader )
	Local nPosMatr	 := GdFieldPos( "TNF_MAT", aHeader )
	Local nPosLoca	 := GdFieldPos( "TNF_LOCAL", aHeader )
	Local nPosTipoDv := GdFieldPos( "TNF_TIPODV", aHeader )

	Local cEpiCond := IIf( SuperGetMV('MV_BIOMDT', .F., '1') == '1',;
							"!Empty( TNF->TNF_DIGIT1 ) .And. !Empty( TNF->TNF_DIGIT2 )",;
							"TNF->TNF_ENTBIO == '1'")

	// "Indica se será bloqueado o Epi, após a impressão do relatório. 1 = Bloqueado ou  2 = Não Bloqueado."
	If SuperGetMv( "MV_NG2EPIB", .F., "1" ) == "1"

		dbSelectArea( "TNF" )
		dbSetOrder( 1 )
		If lCall630 // Epi x Funcionário

			cFornec := (cTRBTN3)->FORNEC
			cLojFor := (cTRBTN3)->LOJA
			cCodEPI := (cTRBTN3)->CODEPI
			cNumCAP := (cTRBTN3)->NUMCAP

			dbSeek( xFilial( "TNF" ) + (cTRBTN3)->FORNEC + (cTRBTN3)->LOJA + (cTRBTN3)->CODEPI + (cTRBTN3)->NUMCAP +;
					 aCols[n, nPosMatr] + DtoS( aCols[n, nPosDtEn] ) + aCols[n, nPosHrEn] )
		ElseIf lCall695 .Or. lCall410 // Funcionário x Epi ou Ficha Médica Mod. 2

			cFornec := aCols[ n, nPosForn ]
			cLojFor	:= aCols[ n, nPosLoja ]
			cCodEPI := aCols[ n, nPosEPI  ]
			cNumCAP := aCols[ n, nPosNumC ]

			dbSeek( xFilial( "TNF" ) + aCols[ n, nPosForn ] + aCols[n, nPosLoja] + aCols[n, nPosEPI] +;
					 aCols[ n, nPosNumC ] + SRA->RA_MAT + DtoS( aCols[n, nPosDtEn ] ) + aCols[n, nPosHrEn] )
		EndIf

		aArea := GetArea()
		dbSelectArea( "TN3" )
		dbSetOrder( 1 ) // TN3_FILIAL + TN3_FORNEC+TN3_LOJA + TN3_CODEPI+TN3_NUMCAP

		If "TNF_DTENTR" $ ReadVar() .And. !( dbSeek( xFilial( "TN3" ) + cFornec + cLojFor + cCodEPI + cNumCAP ) )
			dbSelectArea( "TL0" )
			dbSetOrder( 2 ) // TL0_FILIAL + TL0_EPIFIL + TL0_FORNEC + TL0_LOJA + TL0_NUMCAP

			If ( dbSeek( xFilial( "TL0" ) + cCodEPI +  cFornec + cLojFor + cNumCAP ) )

				If ( M->TNF_DTENTR < TL0->TL0_DTINIC ) .Or. ( M->TNF_DTENTR > TL0->TL0_DTFIM .And. !Empty( TL0->TL0_DTFIM ) )
					ShowHelpDlg( STR0144,;      //"Atenção"
								 {STR0252}, 1,; //"A data de entrega não está entre o período cadastrado do EPI."
								 {STR0253}, 1 ) //"Favor informar um valor válido para a data de entrega do EPI."
					lRet := .F.
				EndIf

			EndIf

		EndIf

		RestArea( aArea )
		
		
		If &(cEpiCond)
			lEpiDevBio := .T.
		EndIf

		// Validação para conseguir alterar o campo de almoxarifado caso o mesmo esteja vazio.
		If "M->TNF_LOCAL" == AllTrim( ReadVar() ) .And. GetMv( "MV_NGMDTES" ) == "S"

			If lCall695 .Or. lCall410 // Caso seja Funcionário x Epi ou Ficha Médica Mod. 2
				nPosTNF  := aScan( aColsTNF, {|x| aCols[ n, nPosForn ] == x[ nPosForn ] .And.;
								 aCols[ n, nPosLoja ] == x[ nPosLoja ] .And.;
								 aCols[ n, nPosEPI ] == x[ nPosEPI ]   .And.;
								 aCols[ n, nPosNumC ] == x[ nPosNumC ] .And.;
								 aCols[ n, nPosDtEn ] == x[ nPosDtEn ] .And.;
								 aCols[ n, nPosHrEn ] == x[ nPosHrEn ] } )

			ElseIf lCall630 // Caso seja Epi x Funcionário
				nPosTNF  := aScan( aColsTNF, {|x| aCols[ n, nPosMatr ] == x[ nPosMatr ] .And.;
								 aCols[ n, nPosDtEn ] == x[ nPosDtEn ] .And.;
								 aCols[ n, nPosHrEn ] == x[ nPosHrEn ] } )
			EndIf

			lChk := !( nPosTNF > 0 .And. Empty( aColsTNF[ nPosTNF, nPosLoca ] ) .And. !Empty( M->TNF_LOCAL ) )
		EndIf

		If ( lCall695 .Or. lCall630 .Or. lCall410 ) .And. !l695Auto

			If lChk

				If( ( &(ReadVar()) != aCols[n, nPosCpo] ) .And. !Empty( aCols[n, nDtReci] ) ) .Or. lEpiDevBio
					Help( " ", 1, STR0234, , STR0238, 3, 0 )// Aviso ## "O EPI não pode ser alterado, pois já foi entregue ao funcionário. É permitido somente a devolução."
					lRet := .F.
				EndIf

			EndIf

		EndIf

	EndIf

	If lRet .And. cUsaInt1 == "S" .And. nPosTipoDv > 0 .And. aCols[ n, nPosTipoDv ] == "1" .And. IIf( Type( "lHist695" ) == "L", !lHist695, .T. ) // Verifica a data de entrega

		If "M->TNF_DTENTR" == AllTrim( ReadVar() )

			If	M->TNF_DTENTR <= dDataBloq .And. !Empty( M->TNF_DTENTR )
				lRet := .F.
				ShowHelpDlg( STR0020,;
				          	 { STR0248 }, 1,; // "ATENÇÃO"#"Não pode ser digitada entrega com data anterior ou igual à data de bloqueio de movimentação."
				           	 { STR0242 }, 2 )  // "Favor verificar o parâmetro MV_DBLQMOV."
			EndIf

		ElseIf "M->TNF_DTDEVO" == AllTrim( ReadVar() ) // Verifica a data de devolução

			If	M->TNF_DTDEVO <= dDataBloq .And. !Empty( M->TNF_DTDEVO )
				lRet := .F.
				ShowHelpDlg( STR0020, { STR0247 }, 1,; // "ATENÇÃO" ## "Não pode ser digitada devolução com data anterior ou igual à data de bloqueio de movimentação."
				             { STR0242 }, 2 )  // "Favor verificar o parâmetro MV_DBLQMOV."
			EndIf

		EndIf

	EndIf

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRelTNF()
Função genérica de X3_RELACAO da tabela TNF

@param nCampo - Indica qual campo da TNF será analisado.

@Obs Utilização:	X3_RELACAO de->	TNF_OBSLOG ( MDTRelTNF( 1 ) )

@author Guilherme Freudenburg
@since 27/08/2015
@return .T.
/*/
//---------------------------------------------------------------------
Function MDTRelTNF( nCampo )

	Local xRelac := ""

	Default nCampo := 0

	If nCampo == 1 //TNF_OBSLOG
		xRelac := MSMM( TNF->TNF_CODOBS, 80 )
	EndIf

Return xRelac

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT695DEVO()
Função responsavel por enviar a quantidade total de Epi's entreges para o campo de
Devolução.

@Obs Utilização:	X3_VALID de->	TNF_DTDEVO

@author Guilherme Freudenburg
@since 03/10/2014
@return .T.
/*/
//---------------------------------------------------------------------
Function MDT695DEVO()

	Local aGridAux := fStructEPI()
	Local aColsAux
	Local nPosQtde	:= GDFieldPos( "TNF_QTDENT", aGridAux[ _nHeader ] ) // Verifica a posição da Quantidade de entrega
	Local nPosQTDDv	:= GDFieldPos( "TNF_QTDEVO", aGridAux[ _nHeader ] ) // Verifica a posição da Quantidade de devolução
	Local nPosInDe	:= GDFieldPos( "TNF_INDDEV", aGridAux[ _nHeader ] ) // Verifica a posição da situação do EPI
	Local nAt		:= aGridAux[ _nAt ]

	aColsAux := aGridAux[ _nCols, nAt ]

	If( aColsAux[ nPosInDe ] == "1")//Se Epi esta devolvido
		aColsAux[ nPosQTDDv ] := aColsAux[ nPosQtde ] // A quantidade de Devolução recebe a quantidade de Entrega
	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT695WHEN()
Função utilizada para travar o campo, caso ja tenha alguma devolução cadastrada.

@Obs Utilização: TLW_DTDEVO/TLW_HRDEVO/TLW_QTDEVO/TLW_LOCAL/TLW_TIPODV

@author Guilherme Freudenburg
@since 10/10/2014
@return .T.
/*/
//---------------------------------------------------------------------
Function MDT695WHEN( nCampo )

	Local lRet     := .T.
	Local nPosCol
	Local lCall695 := IsInCallStack( "MDTA695" ) .Or. IsInCallStack( "MDTA410" )
	Local lCall630 := IsInCallStack( "MDTA630" )
	Local nPosForn
	Local nPosLoja
	Local nPosEPI
	Local nPosCA
	Local nPosDtEn
	Local nPosHrEn

	If (lCall695 .Or. lCall630) .And. SuperGetMv( "MV_NGMDTES", .F., "" ) == "S" //Integracao do SIGAMDT com o Estoque Informar S=Sim ou N=Nao
		nPosCol    := oGetAuxWhen:oBrowse:nAt
		nPosForn   := GdFieldPos( "TNF_FORNEC", aHeadPrin )
		nPosLoja   := GdFieldPos( "TNF_LOJA", aHeadPrin )
		nPosEPI    := GdFieldPos( "TNF_CODEPI", aHeadPrin )
		nPosCA     := GdFieldPos( "TNF_NUMCAP", aHeadPrin )
		nPosDtEn   := GdFieldPos( "TNF_DTENTR", aHeadPrin )
		nPosHrEn   := GdFieldPos( "TNF_HRENTR", aHeadPrin )
		nPosDt     := GdFieldPos( "TLW_DTDEVO", aHeadTLW )
		nPosHr     := GdFieldPos( "TLW_HRDEVO", aHeadTLW )
		nPosLocDev := GdFieldPos( "TLW_LOCAL", aHeadTLW )
		nPosTpDev  := GdFieldPos( "TLW_TIPODV", aHeadTLW )

		If lCall695
			cSeekTLW := aColsTNF[ nPosCol, nPosForn ] + aColsTNF[ nPosCol, nPosLoja ] + aColsTNF[nPosCol,nPosEPI] + aColsTNF[nPosCol,nPosCA]
		Else
			cSeekTLW := M->TN3_FORNEC + M->TN3_LOJA + M->TN3_CODEPI + M->TN3_NUMCAP
		EndIf

		cSeekTLW += SRA->RA_MAT + DTOS( aColsTNF[ nPosCol, nPosDtEn] ) +;
		aColsTNF[ nPosCol, nPosHrEn ] + DTOS( aCols[ n, nPosDt ] ) + aCols[ n, nPosHr ]

		dbSelectArea( "TLW" )
		dbSetOrder( 1 )//TLW_FILIAL+TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)+TLW_HRDEVO
		If dbSeek( xFilial( "TLW" ) + cSeekTLW )
			lRet:= .F.
		EndIf
		If ( nCampo == 4 .And. Empty( aCols[ n, nPosLocDev ] ) ) .Or. ( nCampo == 5 .And. Empty( aCols[ n, nPosTpDev ] ) )
			lRet:=.T.
		EndIf

	EndIf

Return lRet

//------------------------------------------------------------------
/*/{Protheus.doc} MDT695GE
Responsavel por trazer a tela para seleção dos epis filhos.

@return .T.

@author Guilherme Freudenburg
@since 31/03/2016
/*/
//---------------------------------------------------------------------
Static Function MDT695GE( cAliasEPI )

	Local aEpiFil := {}
	Local aAlterar := {}

	Local cEpiFil := ""
	Local cCaEpiFil := ""

	Local lTemTL0 := NGCADICBASE( "TN3_GENERI", "D", "TN3", .F. )

	Local i := 0
	Local nI
	Local nEpiAlt := 0

	If lTemTL0

		dbSelectArea( cAliasEPI )
		dbGotop()

		While .T.

			If Eof() // Não alterar esta condição, pois pode ocasionar em um loop infinito

				( cAliasEPI )->( dbGotop() )

				For nI := 1 To Len( aAlterar )

					If DbSeek( aAlterar[ nI, 1 ] )

						RecLock( cAliasEPI, .F. )

							(cAliasEPI)->CODEPI := aAlterar[ nI, 2 ]
							(cAliasEPI)->DESCRI := aAlterar[ nI, 3 ]
							(cAliasEPI)->NUMCAP := aAlterar[ nI, 4 ]
							(cAliasEPI)->DTVENC := aAlterar[ nI, 5 ]

						MsUnlock( cAliasEPI )

					EndIf

				Next

				Exit // Sai do laço de repetição

			EndIf

			If (cAliasEPI)->OK == cMarca

				dbSelectArea( "TN3" )
				dbSetOrder( 1 ) // TN3_FILIAL+TN3_FORNEC+TN3_LOJA+TN3_CODEPI+TN3_NUMCAP

				If dbSeek( xFilial( "TN3" ) + (cAliasEPI)->FORNEC + (cAliasEPI)->LOJA + (cAliasEPI)->CODEPI ) // Verifica se está cadastrado ao fornecedor

					If TN3->TN3_GENERI == "2" // Caso seja um epi generico

						aEpiFil := NG695EPIF( (cAliasEPI)->FORNEC, (cAliasEPI)->LOJA, (cAliasEPI)->CODEPI ) // Busca os epis filhos

						If Len(aEpiFil) > 0

							cEpiFil := aEpiFil[1]
							cCaEpiFil := aEpiFil[2]

							dbSelectArea( "TL0" )
							dbSetOrder( 1 ) // TL0_FILIAL+TL0_EPIGEN+TL0_FORNEC+TL0_LOJA+TL0_EPIFIL

							If dbSeek( xFilial( "TL0" ) + (cAliasEPI)->CODEPI + (cAliasEPI)->FORNEC + (cAliasEPI)->LOJA + cEpiFil + cCaEpiFil ) // Posiciona no epi filho

								aAdd( aAlterar, {;
									( cAliasEPI )->CODEPI,;
									TL0->TL0_EPIFIL,;
									AllTrim( NGSEEK( "SB1", TL0->TL0_EPIFIL, 1, "B1_DESC" ) ),;
									TL0->TL0_NUMCAP,;
									TL0->TL0_DTVENC;
								} )

							EndIf

							// Realiza a alteração dos epis.

							If ( nEpiAlt := aScan( aEpiAlt, { |x| x[1] == (cAliasEPI)->CODEPI } ) ) == 0

								aAdd( aEpiAlt, { (cAliasEPI)->CODEPI, {} } )

								nEpiAlt := Len( aEpiAlt )

								For i := 1 To Len( aDBFEPI )

									aAdd( aEpiAlt[nEpiAlt][2], { aDBFEPI[i][1], &("(cAliasEPI)->" + aDBFEPI[i][1] ) } )

								Next i

							EndIf

						EndIf

					EndIf

				EndIf

			EndIf

			dbSelectArea( cAliasEPI )
			(cAliasEPI)->(dbSkip())

		End

	EndIf

Return .T.
//------------------------------------------------------------------
/*/{Protheus.doc} fVldTL0Six
Valida se o índice está errado - Função replicada pois nao tinha necessidade de ser Function

@return lRet Logico Retorna verdadeiro quando índice esteja correto

@author Jackson Machado
@since 14/01/2015
/*/
//---------------------------------------------------------------------
Static Function fVldTL0Six()

	Local cIdx
	Local lRet	:= .F.
	Local aArea	:= GetArea()

	//Busca o primeiro índice para salvar o valor
	dbSelectArea( "SIX" )
	dbSetOrder( 1 )
	dbSeek( "TL0" + "1" )

	cIdx := SIX->CHAVE

	//Verifica se o primeiro índice está contido no segundo, caso esteja, deve-se executar o UPDATE
	dbSeek( "TL0" + "2" )

	lRet := AllTrim( cIdx ) $ AllTrim( SIX->CHAVE )

	RestArea( aArea )

Return lRet
//------------------------------------------------------------------
/*/{Protheus.doc} fFornecPdr
Função para retornar nos parâmetros se há código padrão de fornecedor
lPadrao (.T./.F.) e qual o código preenchido cPadrao ( conteúdo de
MV_NGFORPD ), caso contenha na SA2.

@return lRet Nil

@author Guilherme Benkendorf
@since 15/05/2015
/*/
//---------------------------------------------------------------------
Static Function fFornecPdr( lPadrao, cPadrao )

	Local nTamFor := IIf( ( TAMSX3( "A2_COD" )[ 1 ] ) < 1, 6, ( TAMSX3( "A2_COD" )[ 1 ] ) )
	Local nTamLoj := IIf( ( TAMSX3( "A2_LOJA" )[ 1 ] ) < 1, 6, ( TAMSX3( "A2_LOJA" )[ 1 ] ) )

	cPadrao := SuperGetMv( "MV_NGFORPD", .F., "" )

	If !Empty( cPadrao )
		dbSelectArea( "SA2" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "SA2" ) + SubStr( cPadrao, 1, nTamFor ) + SubStr( cPadrao, nTamFor + 1, ( nTamFor + nTamLoj) ) )
			lPadrao := .T.
			cPadrao := GetMv( "MV_NGFORPD" )
		EndIf
	EndIf

Return NIL
//------------------------------------------------------------------
/*/{Protheus.doc} fMontaCabec
Monta cabeçalho de EPI no NGFUN695.

@return lRet Nil

@author Guilherme Benkendorf
@since 15/05/2015
/*/
//---------------------------------------------------------------------
Static Function fMontaCabec()

	Local aNoFields	:= {}

	Local cGetWhTNF
	Local cFilif
	Local cQuery	:= ""

	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lLogix	:= cMDTInteg == "2"

	Private aEpiBackup := {}

	aAdd( aNoFields, 'TNF_MAT' )
	aAdd( aNoFields, 'TNF_NOME' )
	aAdd( aNoFields, 'TNF_CODFUN' )
	If !lLogix
		aAdd( aNoFields, 'TNF_ENTLOG' )
		aAdd( aNoFields, 'TNF_SAILOG' )
		aAdd( aNoFields, 'TNF_OBSLOG' )
	EndIf
	If cUsaInt1 != "S"
		aAdd( aNoFields, "TNF_TIPODV" )
		aAdd( aNoFields, "TNF_NUMSEQ" )
		aAdd( aNoFields, "TNF_CUSTO" )
		aAdd( aNoFields, "TNF_LOCAL" )
		aAdd( aNoFields, "TNF_LOTECT" )
		aAdd( aNoFields, "TNF_LOTESB" )
		aAdd( aNoFields, "TNF_ENDLOC" )
		aAdd( aNoFields, "TNF_NSERIE" )
		If TNF->(FieldPos( "TNF_LOCDV" )) > 0 //Verifica se o campo existe
			aAdd( aNoFields, "TNF_LOCDV" )
		EndIf
	Else
		If cUsaLocz != "S"
			aAdd( aNoFields, "TNF_ENDLOC" )
			aAdd( aNoFields, "TNF_NSERIE" )
		EndIf
		If cUsaRast != "S"
			aAdd( aNoFields, "TNF_LOTECT" )
			aAdd( aNoFields, "TNF_LOTESB" )
		EndIf
	EndIf

	If lSigaMdtps
		aAdd( aNoFields, 'TNF_CLIENT' )
		aAdd( aNoFields, 'TNF_LOJACL' )

		cQuery := "SELECT * FROM " + RetSqlName( "TNF" )
		cQuery += " TNF WHERE TNF.TNF_FILIAL = " + VALTOSQL( xFilial( "TNF" ) ) + " AND TNF.TNF_CLIENT = " + VALTOSQL( SA1->A1_COD )
		cQuery += " AND TNF.TNF_LOJACL = " + VALTOSQL( SA1->A1_LOJA )
		cQuery += " AND TNF.TNF_MAT = " + VALTOSQL( SRA->RA_MAT ) + " AND TNF.D_E_L_E_T_ = ' '"
		FillGetDados( 4, "TNF", 10, xFilial( "TNF" ) + cCliMdtps + SRA->RA_MAT,;
						{|| "TNF->TNF_FILIAL + TNF->TNF_CLIENT + TNF->TNF_LOJACL + TNF->TNF_MAT" },;
						{|| .T.}, aNoFields , , , cQuery )
		aColsFilt 	:= aClone( aCols )
		TNFColBmp( 3, aHeader, aColsFilt )
		aCols 		:= {}
		aHeader		:= {}

		If nEPIDev == 2 .Or. nEPIDev == 3 //Mostrar EPI's devolvidos//Nao devolvidos
			cQuery +=  " AND TNF.TNF_INDDEV"
			cQuery +=  IIf( nEPIDev == 2, " = '1'", " != '1'" )
		EndIf

		FillGetDados( 4, "TNF", 10, xFilial( "TNF" ) + cCliMdtps + SRA->RA_MAT,;
					 {|| "TNF->TNF_FILIAL + TNF->TNF_CLIENT + TNF->TNF_LOJACL + TNF->TNF_MAT" },;
					 {|| .T.}, aNoFields, , , cQuery )
	Else

		dbSelectArea( "TNF" )
		dbSetOrder( 3 ) //TNF_FILIAL+TNF_MAT+TNF_CODEPI+DTOS(TNF_DTENTR)+TNF_HRENTR

		cGetWhTNF := "TNF->TNF_FILIAL == '"+xFilial( "TNF" )+"' .And. TNF->TNF_MAT = '"+SRA->RA_MAT+"'"
		FillGetDados( 4, "TNF", 5, "SRA->RA_MAT", {|| }, {|| .T.}, aNoFields, , , ,;
						{|| NGMontaAcols( "TNF", SRA->RA_MAT, cGetWhTNF, cFilif, 3 ), , @aHeader, @aCols } )
		aColsFilt 	:= aClone( aCols )
		TNFColBmp( 3, aHeader, aColsFilt )
		aCols 		:= {}
		aHeader		:= {}

		If nEPIDev == 2 //Mostrar EPI's devolvidos
			cFilif :=  " TNF->TNF_INDDEV == '1'"
			If !Empty(dDtEntEpi)
				cFilif += " .And. dToS(TNF->TNF_DTENTR) >= '" + dToS(dDtEntEpi) + "'"
			EndIf
		ElseIf nEPIDev == 3 //Nao devolvidos
			cFilif :=  " TNF->TNF_INDDEV != '1'"
			If !Empty(dDtEntEpi)
				cFilif += " .And. dToS(TNF->TNF_DTENTR) >= '" + dToS(dDtEntEpi) + "'"
			EndIf
		Else
			If !Empty(dDtEntEpi)
				cFilif := "dToS(TNF->TNF_DTENTR) >= '" + dToS(dDtEntEpi) + "'"
			EndIf
		EndIf

		FillGetDados( 4, "TNF", 5, "SRA->RA_MAT", {|| }, {|| .T.}, aNoFields, , , ,;
		{|| NGMontaAcols( "TNF", SRA->RA_MAT, cGetWhTNF, cFilif, 3 ), , @aHeader, @aCols } )

		If l695Auto

			aColsAut   	:= aClone( aCols )
			aHeaderAut 	:= aClone( aHeader )
			aAutoCab   	:= MsAuto2Ench( 'SRA' )
			aEpiBackup	:= aClone( aColsAut )

			If MsGetDAuto( aAutoItens, { || NG695LinOk() }, { || NG695TudOk() }, aAutoCab, 4 )
				If !lMSErroAuto
					lContinua := .T.
				EndIf
			Else
				//Chama a função de exibição/gravação do log de erros
				fMostraErr( 1 )
			EndIf

		EndIf
	EndIf

Return NIL

//------------------------------------------------------------------
/*/{Protheus.doc} Mdta695Ven
Retorna os EPIs vencidos

@author Guilherme Benkendorf
@since 15/05/2015

@param, aColsAux, array, lista para verificação
@param, cVerVal, caractere, parâmetro que diz se verifica a validade,
@param, cTRBTN3, caractere, tabela com EPI da rotina MDTA630

@return aVencidos, array, EPIs vencidos
/*/
//---------------------------------------------------------------------
Function Mdta695Ven( aColsAux, cVerVal, cTRBTN3 )

	Local aAreaSR8 	:= ( 'SR8' )->( GetArea() )
	Local aAreaTN3 	:= ( 'TN3' )->( GetArea() )
	Local aVencidos	:= {}

	Local cCliMDTPs := ""
	Local cCodEpi 	:= ''
	Local cCodFor	:= ''
	Local cCodLoj	:= ''
	Local cCodNum	:= ''

	Local lMdta630	:= FwIsInCallStack( 'MDTA630' )

	Local nX
	Local nAfast   	:= 0
	Local nDurabi
	Local nPosDtDe 	:= GdFieldPos( "TNF_DTDEVO" )
	Local nPosEPI  	:= GdFieldPos( "TNF_CODEPI" )
	Local nPosForn 	:= GdFieldPos( "TNF_FORNEC" )
	Local nPosLoja 	:= GdFieldPos( "TNF_LOJA" )
	Local nPosNumC 	:= GdFieldPos( "TNF_NUMCAP" )
	Local nPosDtEn 	:= GdFieldPos( "TNF_DTENTR" )
	Local nIndexTN3 := 1

	Default cTRBTN3 := ''

	If lMdta630
		cCodEpi := ( cTRBTN3 )->CODEPI
		cCodFor := ( cTRBTN3 )->FORNEC
		cCodLoj := ( cTRBTN3 )->LOJA
		cCodNum := ( cTRBTN3 )->NUMCAP
	EndIf

	For nX := 1 To Len( aColsAux )

		If !lMdta630
			cCodEpi := aColsAux[ nX, nPosEPI 	]
			cCodFor := aColsAux[ nX, nPosForn 	]
			cCodLoj := aColsAux[ nX, nPosLoja	]
			cCodNum := aColsAux[ nX, nPosNumC	]
		EndIf

		If Empty( aColsAux[ nX, nPosDtDe ] )

			If aScan( aVencidos, { | x | AllTrim( Upper( x[ 1 ] ) ) == AllTrim( Upper( cCodEpi ) ) } ) == 0
				nDurabi := 0
				dbSelectArea( "TN3" )
				dbSetOrder( nIndexTN3 )
				If dbSeek( xFilial( "TN3" ) + cCodFor + cCodLoj +;
				 cCliMDTPs + cCodEpi + cCodNum )
					If TN3->TN3_INDEVO == Substr( cVerVal, 1, 1 ) .Or. Substr( cVerVal, 1, 1 ) == "3"
						nDurabi := TN3->TN3_DURABI
					EndIf
				EndIf

				//------------------------------------------
				// Verifica se a durabilidade do EPI eh
				// por dias de Uso e desconta os afastamentos
				//-------------------------------------------
				If TN3->TN3_TPDURA == "U"
					nAfast := 0
					dbSelectArea( "SR8" )
					dbSetOrder( 1 )//R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)
					dbSeek( xFilial( "SR8" ) + SRA->RA_MAT )
					While !eof() .And. xFilial( "SR8" ) + SRA->RA_MAT == SR8->R8_FILIAL + SR8->R8_MAT .And. SR8->R8_DATAINI <= dDataBase
						If ( Empty( SR8->R8_DATAFIM ) .Or. SR8->R8_DATAFIM > aColsAux[ nX, nPosDtEn ] )
							nAfast += ( dDataBase - SR8->R8_DATAINI )
						ElseIf SR8->R8_DATAFIM >= aColsAux[ nX, nPosDtEn ] .And. SR8->R8_DATAINI <= aColsAux[ nX, nPosDtEn ]
							nAfast += ( SR8->R8_DATAFIM - aColsAux[ nX, nPosDtEn ] )
						ElseIf SR8->R8_DATAFIM <= dDataBase .And. SR8->R8_DATAINI >= aColsAux[ nX, nPosDtEn]
							nAfast += ( SR8->R8_DATAFIM - SR8->R8_DATAINI )
						EndIf
						dbSelectArea( "SR8" )
						dbSkip()
					End
				EndIf
				If !Empty( aColsAux[ nX, nPosDtEn ] ) .And. ( ( dDataBase - aColsAux[ nX, nPosDtEn ] - nAfast ) > nDurabi ) .And. nDurabi > 0
					aAdd( aVencidos, { cCodEpi, AllTrim( NGSEEK( "SB1", cCodEpi, 1, "B1_DESC" ) ) } )
				EndIf
			EndIf
		EndIf
	Next nX

	If Len( aVencidos ) > 0

		cMsg := STR0265 + Chr( 13 )
		aEval( aVencidos, { | x |  cMsg += CRLF + AllTrim( x[ 1 ] ) + ' - ' + AllTrim( x[ 2 ] ) } )

		If lMdta630 .Or. !l695Auto
			//-----------------------------------------------------------------------------
            // Mensagens:
            // "Atenção"
            // "EPI com vida útil ultrapassada."
            // "Os EPIs abaixo estão com a vida útil ultrapassada:"
            //-----------------------------------------------------------------------------
            Help( Nil, Nil, STR0144, Nil, STR0264, 1, 0, Nil, Nil, Nil, Nil, Nil, { cMsg } )
		EndIf

	EndIf

	RestArea( aAreaSR8 )
	RestArea( aAreaTN3 )

Return aVencidos

//------------------------------------------------------------------
/*/{Protheus.doc} fCleanVar

Limpa variaveis após fechar tela de NGFUN695

@return lRet Nil

@author Guilherme Benkendorf
@since 15/05/2015
/*/
//---------------------------------------------------------------------
Static Function fCleanVar(oArquivTLW)

	If Type( "lHist695" ) == "L" .And. !lHist695
		SetKey( VK_F4, Nil )
	EndIf

	If !l695ExibeMsg
		lMsErroAuto := .F.
	EndIf

	If ValType( oArquivTLW ) == "O" .And. ;
		Select( oArquivTLW:GetAlias() ) > 0 .And. ;
		!IsInCallStack( "MDTA410" )
		oArquivTLW:Delete()
	EndIf

Return Nil
//------------------------------------------------------------------
/*/{Protheus.doc} fImpEPIDev

Função para verificar se imprimirá o recibo de EPIs entregues e devolvido

@return lRet Nil

@author Guilherme Benkendorf
@since 15/05/2015
/*/
//---------------------------------------------------------------------
Static Function fImpEPIDev( oGetAux )

	Local nRetAviso
	Local nPosEPI	:= GdFieldPos( "TNF_CODEPI", oGetAux:aHeader )// Codigo do Epi
	Local nPosForn	:= GdFieldPos( "TNF_FORNEC", oGetAux:aHeader )// Fornecedor
	Local nPosLoja	:= GdFieldPos( "TNF_LOJA"  , oGetAux:aHeader )// Loja
	Local nPosNumC	:= GdFieldPos( "TNF_NUMCAP", oGetAux:aHeader )// Numero CA
	Local nPosDtEn	:= GdFieldPos( "TNF_DTENTR", oGetAux:aHeader )// Data Entrega
	Local nPosHrEn	:= GdFieldPos( "TNF_HRENTR", oGetAux:aHeader )// Hora Entrega
	Local nPosDtDe	:= GdFieldPos( "TNF_DTDEVO", oGetAux:aHeader )
	Local nPosInDe	:= GDFieldPos( "TNF_INDDEV", oGetAux:aHeader ) // Verifica a posição da situação do EPI
	Local nPosRec   := GDFieldPos( "TNF_REC_WT", oGetAux:aHeader ) // Verifica a posição da situação do EPI
	Local nPosQTDDv := GdFieldPos( "TNF_QTDEVO", oGetAux:aHeader )
	Local nPosQTEnt := GdFieldPos( "TNF_QTDENT", oGetAux:aHeader )
	Local lImprime  := .F.

	Local nW        := 0
	Local nCont     := 0
	Local nQtdEPI   := 0
	Local lExistDiff
	Local aOldACols := aClone( aColsTNF )
	Local aColsTLW	:= {}
	Local cTypeAls  := Type( "cAliasTLW" ) != "U"

	Private dDt695Min := dDataBase
	Private dDt695Max := dDataBase

	//Se não for histórico
	If Type( "lHist695" ) == "L" .And. !lHist695

		//TNF_DTENTR - Pega data maxima e minimo da entrega
		aSort( oGetAux:aCols, , , { |x, y| x[ nPosEPI ] + DTOS( x[nPosDtEn] ) + x[nPosHrEn] < y[ nPosEPI ] + DTOS( y[ nPosDtEn ] ) + y[nPosHrEn] } ) // Codigo Epi + Data Entrega + Hora Entrega
		aSort( aOldACols, , , { |x, y| x[ nPosEPI ] + DTOS( x[ nPosDtEn ] ) + x[nPosHrEn] < y[ nPosEPI ] + DTOS( y[ nPosDtEn ] ) + y[nPosHrEn] } ) // Codigo Epi + Data Entrega + Hora Entrega

		lExistDiff := .F.
		If Len( aOldACols ) > 0
			If Len( oGetAux:aCols ) != Len( aOldACols )
				For nCont := 1 To Len( oGetAux:aCols )
					If fRetChave( oGetAux:aCols[ nCont ], oGetAux:aHeader, aOldACols ) == 0
						If oGetAux:aCols[ nCont, nPosInDe ] != "3" //Situação EPI
							lExistDiff := .T.
							Exit
						EndIf
					EndIf
				Next nCont
			Else
				For nCont := 1 To Len( oGetAux:aCols )
					If ( aOldACols[ nCont, nPosEPI ] != oGetAux:aCols[ nCont, nPosEPI ]  .Or. ; //Codigo Epi
					    	aOldACols[ nCont, nPosNumC] != oGetAux:aCols[ nCont, nPosNumC]  .Or. ; // Num C. A.
							aOldACols[ nCont, nPosDtEn] != oGetAux:aCols[ nCont, nPosDtEn]  .Or. ; //Data Entrega
							aOldACols[ nCont, nPosHrEn] != oGetAux:aCols[ nCont, nPosHrEn] ) .And.; //Hora Entrega
							oGetAux:aCols[ nCont, nPosInDe ] != "3" //Situação EPI

							lExistDiff := .T.
							Exit
					EndIf
				Next nCont
			EndIf
		EndIf

		If !lExistDiff
			dDt695Min := dDataBase
			dDt695Max := dDataBase
			aOldACols := {}
		Else
			aSort( oGetAux:aCols, , , { | x, y | x[ nPosDtEn ] < y[ nPosDtEn ] } )
			dDt695Min := oGetAux:aCols[ 1, nPosDtEn ]
			dDt695Max := oGetAux:aCols[ Len( oGetAux:aCols ), nPosDtEn ]
		EndIf

		nQtdEPI := 0
		dbSelectArea( "TNF" )
		dbSetOrder( IIf( lSigaMdtps, 10, 5 ) )
		dbSeek( cSeekTNF + DToS( dDt695Min ) )
		While TNF->( !Eof() ) .And. cSeekTNF == &(cCondTNF) .And. DTOS( TNF->TNF_DTENTR ) >= DToS( dDt695Min )

			If ( TNF->TNF_INDDEV == "2" .Or. Empty( TNF->TNF_INDDEV ) ) .And. Empty( TNF->TNF_DTRECI )
				nQtdEPI++
				Exit
			EndIf
			dbSelectArea( "TNF" )
			dbSkip()
		End

		//-------------------------
		// Busca os EPI devolvidos
		//-------------------------
		If NGCADICBASE( "TNF_DEVBIO", "D", "TNF", .F. )
			For nCont := 1 To Len( oGetAux:aCols )

				dbSelectArea( "TNF" )
				dbSetOrder( IIf( lSigaMdtps, 10, 5 ) )
				If dbSeek( cSeekTNF + DToS( oGetAux:aCols[ nCont, nPosDtEn] ) + oGetAux:aCols[nCont, nPosHrEn] + oGetAux:aCols[nCont, nPosEPI] )//1=Epi devolvido;2=Epi em uso;3=Epi em Solic. Armazem

					nPosTNF := fRetChave( oGetAux:aCols[ nCont ], oGetAux:aHeader, aColsTNF )
					If nPosTNF > 0 .And. cTypeAls .And. Select( cAliasTLW ) > 0

						cKeyDev := TNF->TNF_FORNEC + TNF->TNF_LOJA + TNF->TNF_CODEPI + TNF->TNF_NUMCAP +;
								  TNF->TNF_MAT + DtoS( TNF->TNF_DTENTR ) + IIf(Len( ( cAliasTLW )->TLW_HRENTR ) < 8, SubStr( TNF->TNF_HRENTR, 1, 5 ), TNF->TNF_HRENTR )
						dbSelectArea( cAliasTLW )
						dbSetOrder( 1 )//TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)+TLW_HRDEVO
						dbSeek( cKeyDev )
						While ( cAliasTLW )->( !Eof() ) .And. ;
							( cAliasTLW )->( TLW_FORNEC + TLW_LOJA + TLW_CODEPI + TLW_NUMCAP + TLW_MAT + DTOS( TLW_DTENTR ) + TLW_HRENTR ) == cKeyDev
							If !Empty( ( cAliasTLW )->TLW_ALTERA )
								If aScan( aDevEpi, { | x | x == TNF->(Recno()) } ) == 0
									aAdd( aDevEpi, TNF->(Recno()) )
								EndIf
								aAdd( aDevPar, { TNF->TNF_FILIAL, TNF->TNF_CODEPI, TNF->TNF_FORNEC, ;
												TNF->TNF_LOJA, TNF->TNF_NUMCAP, TNF->TNF_MAT, TNF->TNF_DTENTR, TNF->TNF_HRENTR, ;
												( cAliasTLW )->TLW_DTDEVO, ( cAliasTLW )->TLW_HRDEVO, ( cAliasTLW )->TLW_QTDEVO} )
							EndIf
							( cAliasTLW )->( dbSkip() )
						End
					EndIf
				EndIf
			Next nCont
		EndIf

		If Len( aDevEpi ) > 0 .And. !lMsErroAuto
			nRetAviso := Aviso( STR0144, STR0225, { STR0116, STR0207, STR0208 } )//"Atenção"##"Deseja imprimir o recibo de devolução de EPI?"##"Não"##"Analítico"##"Sintético"
			If nRetAviso > 1
				ImpRecibo( nRetAviso, aDevEpi, aDevPar, 1 )
				lImprime := .T.
			EndIf
		EndIf
		If SuperGetMv( "MV_NG2RECI", .F., "1" ) == "1" //Se deve mostrar a tela de sugestão de impressão
			If ( nQtdEPI > 0 .And. lExistDiff ) .And. IIf( cPrograma == "MDTA410", !aCols[n][Len( aCols[n] )], .T. )
				nRetAviso := Aviso( STR0144, STR0072, { STR0116, STR0207, STR0208 } )//"Atenção"##"Deseja imprimir o recibo de entrega de EPI?"##"Não"##"Analítico"##"Sintético"
				If nRetAviso > 1
					ImpRecibo( nRetAviso, , aOldACols, 2 )
					lImprime := .T.
				EndIf
			EndIf
		EndIf
		If ExistBlock( "MDTA695A" )
			ExecBlock( "MDTA695A", .F., .F., { aOldACols, oGetAux:aCols } )
		EndIf
	EndIf

	//-------------------------------------------------------------------
	// Atualiza o MsNewGetDados, realizado desta maneira pois não há como
	// saber qual o TNF será alterada na impressão
	//-------------------------------------------------------------------
	If lImprime .And. IsInCallStack( "MDTA410" )
		aAreaImp := GetArea()
		aCols   := {}
		aHeader := {}

		//-------------------
		// Monta o cabecalho
		//-------------------
		fMontaCabec()
		//-----------------------------------------
		// Adiciona a coluna BMP no aHeader e aCols
		//-----------------------------------------
		TNFColBmp( 1, @aHeader, @aCols )

		aHeader := aClone( oGetTNF695:aHeader )
		oGetTNF695:aCols := aClone( aCols )
		oGetTNF695:Refresh()
		RestArea( aAreaImp )
	EndIf

Return Nil

//------------------------------------------------------------------
/*/{Protheus.doc} fImpEPIDev

Função que estrutura o retorno de { aHeader , aCols , nAt } conforme objeto
selecionado.

@return lRet Nil

@author Guilherme Benkendorf
@since 15/05/2015
/*/
//---------------------------------------------------------------------
Static Function fStructEPI()

	Local oGetAux
	Local nAt	   := 0
	Local aGridEPI := {}

	If Type( "oGetTNF695" ) != "U"
		oGetAux := oGetTNF695
	ElseIf Type( "oGetTNF630" ) != "U"
		oGetAux := oGetTNF630
	EndIf

	If ValType( oGetAux ) != "U"
		nAt		 := oGetAux:nAt
		aGridEPI := { oGetAux:aHeader, oGetAux:aCols, nAt }
	Else
		aGridEPI := { aClone( aHeader ), aCols, n }
	EndIf

Return aGridEPI
//------------------------------------------------------------------
/*/{Protheus.doc} MDT695TLW

Cria TRB da TLW - Devolução Parcial

@return lRet Nil

@author Guilherme Benkendorf
@since 15/05/2015
/*/
//---------------------------------------------------------------------
Function MDT695TLW( oTempTRB )

	Local cIndex   := ""
	Local aDBF     := {}
	Local aIdx     := {}
	Local oTempTRB
	Local nSizeFil := IIf( FindFunction( "FWSizeFilial" ), FwSizeFilial(), Len( TLW->TLW_FILIAL ) )
	Local nSizeSA2 := IIf( (FwTamSX3( "A2_COD" )[1]) < 1, 06, (FwTamSX3( "A2_COD" )[1] ) )
	Local nSizeLoj := IIf( (FwTamSX3( "A2_LOJA" )[1]) < 1, 02, (FwTamSX3( "A2_LOJA" )[1] ) )
	Local nSizeCod := IIf( ( FwTamSX3( "B1_COD" )[1] ) < 1, 15, ( FwTamSX3( "B1_COD" )[1] ) )
	Local nSizeLoc := IIf( (FwTamSX3( "TLW_LOCAL" )[1]) < 1, 02, (FwTamSX3( "TLW_LOCAL" )[1] ) )

	//--------------------------
	// Inicia Montagem do TRB
	//--------------------------
	aAdd( aDBF, { "TLW_FILIAL"	, "C", nSizeFil						, 0 } )
	aAdd( aDBF, { "TLW_DELETE"	, "C", 1							, 0 } )
	aAdd( aDBF, { "TLW_ALTERA"	, "C", 1							, 0 } )
	aAdd( aDBF, { "TLW_FORNEC"	, "C", nSizeSA2						, 0 } )
	aAdd( aDBF, { "TLW_LOJA"	, "C", nSizeLoj						, 0 } )
	aAdd( aDBF, { "TLW_CODEPI"	, "C", nSizeCod						, 0 } )
	aAdd( aDBF, { "TLW_NUMCAP"	, "C", FwTamSX3( 'TLW_NUMCAP' )[ 1 ], 0 } )
	aAdd( aDBF, { "TLW_MAT"		, "C", FwTamSX3( 'TLW_MAT' )[ 1 ]	, 0 } )
	aAdd( aDBF, { "TLW_DTENTR"	, "D", FwTamSX3( 'TLW_DTENTR' )[ 1 ], 0 } )
	aAdd( aDBF, { "TLW_HRENTR"	, "C", FwTamSX3( 'TLW_HRENTR' )[ 1 ], 0 } )
	aAdd( aDBF, { "TLW_DTDEVO"	, "D", FwTamSX3( 'TLW_DTDEVO' )[ 1 ], 0 } )
	aAdd( aDBF, { "TLW_HRDEVO"	, "C", FwTamSX3( 'TLW_HRDEVO' )[ 1 ], 0 } )
	aAdd( aDBF, { "TLW_QTDEVO"	, "N", FwTamSX3( 'TLW_QTDEVO' )[ 1 ], 0 } )
	aAdd( aDBF, { "TLW_NUMSEQ"	, "C", FwTamSX3( 'TLW_NUMSEQ' )[ 1 ], 0 } )
	aAdd( aDBF, { "TLW_TIPODV"	, "C", FwTamSX3( 'TLW_TIPODV' )[ 1 ], 0 } )
	aAdd( aDBF, { "TLW_LOCAL"	, "C", nSizeLoc						, 0 } )

	//-------------------
	// Cria a Tabela Temporaria
	//-------------------
	oTempTRB := FWTemporaryTable():New( cAliasTLW, aDBF )
	oTempTRB:AddIndex( "1", { "TLW_FORNEC", "TLW_LOJA", "TLW_CODEPI", "TLW_NUMCAP", "TLW_MAT", "TLW_DTENTR",;
						 "TLW_HRENTR", "TLW_DTDEVO", "TLW_HRDEVO", "TLW_TIPODV", "TLW_LOCAL" } )
	oTempTRB:Create()

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} fRetChave
Função para buscar na aColsTNF a posição correspondente no parametro
aColsPesq.

@return nPosTNF	Numeric	Posição correspondente no aColsTNF

@sample fRetChave( oGet:aCols, nX , oGet:aHeader )

@author Guilherme Benkendorf
@since 15/05/2015
/*/
//---------------------------------------------------------------------
Static Function fRetChave( aColsPesq, aHeaderAux, aColsCons )

	Local lCall695	:= IsInCallStack( "MDTA695" ) .Or. IsInCallStack( "MDTA410" )

	Local nPosMatr := GdFieldPos( "TNF_MAT", aHeaderAux )    // Matricula
	Local nPosForn := GdFieldPos( "TNF_FORNEC", aHeaderAux ) // Fornecedor
	Local nPosLoja := GdFieldPos( "TNF_LOJA", aHeaderAux )   // Loja
	Local nPosEPI  := GdFieldPos( "TNF_CODEPI", aHeaderAux ) // Codigo do Epi
	Local nPosNumC := GdFieldPos( "TNF_NUMCAP", aHeaderAux ) // Numero CA
	Local nPosDtEn := GdFieldPos( "TNF_DTENTR", aHeaderAux ) // Data Entrega
	Local nPosHrEn := GdFieldPos( "TNF_HRENTR", aHeaderAux ) // Hora Entrega

	Local nPosTNF := 0

	Default aColsCons := aClone( aColsTNF )

	If lCall695
		nPosTNF := aScan( aColsCons, { | x | aColsPesq[ nPosForn ] == x[ nPosForn ] .And. ;
						 aColsPesq[ nPosLoja ] == x[ nPosLoja ] .And. ;
						 aColsPesq[ nPosEPI ] == x[ nPosEPI ] .And. ;
						 aColsPesq[ nPosNumC ] == x[ nPosNumC ] .And. ;
						 aColsPesq[ nPosDtEn ] == x[ nPosDtEn ] .And. ;
						 aColsPesq[ nPosHrEn ] == x[ nPosHrEn ] } )
	Else
		nPosTNF := aScan( aColsCons, { | x | aColsPesq[ nPosMatr ] == x[ nPosMatr ] .And. ;
						 aColsPesq[ nPosDtEn ] == x[ nPosDtEn ] .And. ;
						 aColsPesq[ nPosHrEn ] == x[ nPosHrEn ] } )
	EndIf

Return nPosTNF

//---------------------------------------------------------------------
/*/{Protheus.doc} fChkFunc
Analisa se é permetido a entrega de EPI para funcionarios fora de atividade,
através do parâmetro MV_NGEPIEN

@return Nil

@sample fChkFunc()
@return lRetEPI Boolean Indica a existência de alguma obstrução.

@author Guilherme Benkendorf
@since 15/05/2015
/*/
//---------------------------------------------------------------------
Static Function fChkFunc()

	Local cTextoMsg := ""
	Local cMsgInfo1
	Local cMsgInfo2
	Local cMsgInfo3

	//Define se a entrega de EPI sera permitida caso  o funcionario nao esteja com situacao ativa. Ex: S=Permite/N=Nao Permite
	Local lPerEntEPI := SuperGetMv( "MV_NGEPIEN", .F., "N"  ) == "N"
	Local lRetEPI    := .F.

	If FindFunction( "MDTFunAti" )
		lRetEPI := MDTFunAti( SRA->RA_MAT, l695Auto )
	Else
		If lPerEntEPI
			cMsgInfo1 := STR0131// "O funcionário está demitido, não é possível a entrega de EPI's."
			cMsgInfo2 := STR0132 //"O funcionário está afastado, não é possível a entrega de EPI's."
			cMsgInfo3 := STR0133 //"O funcionário está de férias, não é possível a entrega de EPI's."
		Else
			cMsgInfo1 := STR0017 //"O funcionário está demitido, deseja efetuar as entregas de EPIs?"
			cMsgInfo2 := STR0019 //"O funcionário está de férias, deseja efetuar as entregas de EPIs?"
			cMsgInfo3 := STR0018 //"O funcionário está afastado temporariamente, deseja efetuar as entregas de EPIs?"
		EndIf

		If lPerEntEPI
			dbSelectArea( "SRA" )
			If !Empty( SRA->RA_SITFOLH )
				If SRA->RA_SITFOLH == "D"
					If (SRA->RA_DEMISSA <= dDataBase)
						cTextoMsg := cMsgInfo1
					EndIf
				EndIf
			EndIf
			If Empty( cTextoMsg )
				dbSelectArea( "SRH" )
				dbSetOrder( 1 )
				dbSeek( xFilial( "SRH" ) + SRA->RA_MAT )
				While !Eof() .And. SRH->RH_FILIAL + SRH->RH_MAT == xFilial( "SRH" ) + SRA->RA_MAT
					If !Empty( SRH->RH_DATAINI ) .And. dDataBase >= SRH->RH_DATAINI .And. (dDataBase <= SRH->RH_DATAFIM .Or. Empty( SRH->RH_DATAFIM ))
						cTextoMsg := cMsgInfo2
						Exit
					EndIf
					dbSelectArea( "SRH" )
					dbSkip()
				End
			EndIf

			If Empty( cTextoMsg )
				dbSelectArea( "SR8" )
				dbSetOrder( 1 )
				dbSeek( xFilial( "SR8" ) + SRA->RA_MAT )
				While !Eof() .And. SR8->R8_FILIAL + SR8->R8_MAT == xFilial( "SR8" ) + SRA->RA_MAT
					If SR8->R8_DATAINI <= dDataBase .And. (Empty( SR8->R8_DATAFIM ) .Or. SR8->R8_DATAFIM >= dDataBase)
						If SR8->R8_TIPO == "F"
							cTextoMsg := cMsgInfo3
							Exit
						ElseIf SR8->R8_TIPO == "D"
							cTextoMsg := cMsgInfo1
							Exit
						Else
							cTextoMsg := cMsgInfo2
							Exit
						EndIf
					EndIf
					dbSelectArea( "SR8" )
					dbSkip()
				End
			EndIf

			If !Empty( cTextoMsg )
				If lPerEntEPI
					Help( " ", 1, STR0234, , cTextoMsg, 4, 5 ) //Aviso
					lRetEPI := .T.
				Else
					If l695Auto // Se for rotina automatica não entrega
						lRetEPI := .T.
					ElseIf !MsgYesNo( cTextoMsg, STR0020 ) //"ATENÇÃO"
						lRetEPI := .T.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

Return lRetEPI

//---------------------------------------------------------------------
/*/{Protheus.doc} fAtuRelTNF


@return Nil

@sample fAtuRelTNF()
@return Nil

@author Guilherme Benkendorf
@since 20/05/2015
/*/
//---------------------------------------------------------------------
Static Function fAtuRelTNF( lChange )

	Local nQtMovim
	Local nQtdDevol

	Local lRet := .T.
	Local lMdtEstorno
	Local lLocDevol := TNF->( FieldPos( "TNF->TNF_LOCDV" ) ) == 0
	Local cMDTInteg := SuperGetMv( "MV_NG2INTE", .F., "1" )
	Local lLogix    := cMDTInteg == "2"
	Local aMovEst

	Local cChvDelTLW
	Local cNumSeq

	Default lChange := .F.

	cChvDelTLW := TNF->( TNF_FORNEC + TNF_LOJA + TNF_CODEPI + TNF_NUMCAP + TNF_MAT + DtoS( TNF_DTENTR ) + TNF_HRENTR )

	//-----------------------
	// Quando houver geração de Solicitação de Armazem
	// E a
	//-----------------------
	If lGera_SA .And. TNF->TNF_INDDEV == "3" .And. !Empty( TNF->TNF_NUMSA ) .And. !Empty( TNF->TNF_ITEMSA )

		aNumSA := MdtMovSA( "D", TNF->TNF_CODEPI, TNF->TNF_QTDENT, TNF->TNF_NUMSEQ, TNF->TNF_NUMSA,;
						 TNF->TNF_ITEMSA, TNF->TNF_DTENTR, TNF->TNF_MAT, SRA->RA_CC, SRA->RA_FILIAL,;
						 TNF->TNF_LOCAL, IIf( lLogix, TNF->TNF_SAILOG, "" ), , lChange )
		If Len( aNumSA ) > 2 .And. aNumSA[3] == _ErroLogix
			lRet := .F.
		EndIf

	ElseIf !( TNF->TNF_INDDEV == "1" .And. !Empty( TNF->TNF_DTDEVO ) )

		//Integracao do SIGAMDT com o Estoque Informar S=Sim ou N=Nao
		If cUsaInt1 == "S"
			nQtMovim := TNF->TNF_QTDENT

			//Quantidade ja devolvida do EPI
			If lLogix
				nQtdDevol := TNF->TNF_QTDEVO
			Else
				nQtdDevol := NgQtEpiDv( TNF->TNF_FORNEC, TNF->TNF_LOJA, TNF->TNF_CODEPI, TNF->TNF_DTENTR,;
									 TNF->TNF_HRENTR, TNF->TNF_NUMCAP, TNF->TNF_MAT )
			EndIf
			nQtMovim := nQtMovim - nQtdDevol

			If ( !lLogix .And. nQtMovim > 0 ) .Or. ( lLogix .And. nQtMovim == 0 )
				lMdtEstorno := nQtMovim == TNF->TNF_QTDENT .Or. lLogix
				aMovEst := fGetTmpMov()

				cNumSeq := MdtMovEst( "DE0", IIf( lLocDevol, TNF->TNF_LOCAL, TNF->TNF_LOCDV ), TNF->TNF_CODEPI, nQtMovim, dDataBase, " ",;
									 TNF->TNF_MAT, Nil, lMdtEstorno, TNF->TNF_NUMSEQ, aMovEst[1], aMovEst[2], aMovEst[3], aMovEst[4] )
				If Empty( cNUMSEQ )// Indica que a transação não foi executada
					DisarmTransaction()
					Return .F.
				EndIf
				If lLogix
					cMDTSerie   := "ENTRADA"
					cMdtReserva := ""
					cMDTNumRes  := ""
					dbSelectArea( "SB1" )
					dbSetOrder( 1 )
					dbSeek( xFilial( "SB1" ) + TNF->TNF_CODEPI )

					//Campo Observação
					If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
						cObsSCP	:= SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
					Else
						cObsSCP	:= STR0166 + ": " + xFilial( "SRA", TNF->TNF_FILIAL ) + "-" + TNF->TNF_MAT //"FUNCIONARIO"
					EndIf
					//Campo CC
					If !Empty( TNF->TNF_MAT ) .And. FindFunction( "MDTCCFunc" )
						cCCustoAux := NgSeek( "SRA", TNF->TNF_MAT, 1, "SRA->RA_CC" )
						cCCSCP     := MDTCCFunc( TNF->TNF_MAT, cCCustoAux, TNF->TNF_DTDEVO )
					Else
						cCCSCP := cCCustoAux
					EndIf
					cCodLocSCP := IIf( lLocDevol == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV )

					dbSelectArea( "SCP" )
					RegToMemory( "SCP", .T. )
					M->CP_PRODUTO := TNF->TNF_CODEPI
					M->CP_UM      := SB1->B1_UM
					M->CP_QUANT   := TNF->TNF_QTDEVO
					M->CP_DATPRF  := TNF->TNF_DTDEVO
					M->CP_LOCAL   := IIf( lLocDevol == 0, TNF->TNF_LOCAL, TNF->TNF_LOCDV )
					cCCustoAux := NgSeek( "SRA", TNF->TNF_MAT, 1, "SRA->RA_CC" )
					M->CP_CC      := IIf( !Empty( TNF->TNF_MAT ) .And. FindFunction( "MDTCCFunc" ),;
									 MDTCCFunc( TNF->TNF_MAT, cCCustoAux, TNF->TNF_DTDEVO ), cCCustoAux )
					M->CP_EMISSAO := dDataBase
					M->CP_DESCRI  := SB1->B1_DESC
					M->CP_SOLICIT := cUserName
					M->CP_OBS     := STR0166 + ": " + xFilial( "SRA", TNF->TNF_FILIAL ) + "-" + TNF->TNF_MAT //"FUNCIONARIO"
					If TNF->( FieldPos( "TNF_CODOBS" ) ) > 0
						M->CP_OBS := SubStr( AllTrim( M->CP_OBS ) + " " + MSMM( TNF->TNF_CODOBS, TamSX3( "TNF_OBSLOG" )[1] ), 1, 180 )
					EndIf
					If lRet
						lRet := NGMUReques( , "SCP", .T., IIf( lChange, 5, 4 ) )
					EndIf
				EndIf

			EndIf
		EndIf
	EndIf

	If lRet
		//Somente deleta o registro se o EPI não estiver bloqueado para inventário
		If Type( "lMSErroAuto" ) != "L" .Or. !lMSErroAuto
			RecLock( "TNF", .F., .T. )
			dbDelete()
			TNF->( MsUnLock() )
		EndIf

		cChvDelTLW := xFilial( "TLW" ) + cChvDelTLW
		dbSelectArea( "TLW" )
		dbSetOrder( 1 )
		dbSeek( cChvDelTLW )
		While !Eof() .And. TLW->TLW_FILIAL + TLW->TLW_FORNEC + TLW->TLW_LOJA + TLW->TLW_CODEPI +;
			TLW->TLW_NUMCAP + TLW->TLW_MAT + DTOS( TLW->TLW_DTENTR ) + TLW->TLW_HRENTR == cChvDelTLW

			RecLock( "TLW", .F. )
				dbDelete()
			TLW->( MsUnLock() )
			dbSkip()
		End
	EndIf

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} fGetTmpMov

@return Nil

@sample fGetTmpMov()
@return Nil

@author Guilherme Benkendorf
@since 20/05/2015
/*/
//---------------------------------------------------------------------
Static Function fGetTmpMov( lValTNF, aColsMov )

	Local aGridAux := fStructEPI()

	Local cTmpLote := ""
	Local cTmpSubL := ""
	Local cTmpLocz := ""
	Local cTmpNSer := ""

	Local nPosLot  := GdFieldPos( "TNF_LOTECT", aGridAux[ _nHeader ] )
	Local nPosSubL := GdFieldPos( "TNF_LOTESB", aGridAux[ _nHeader ] )
	Local nPosEnd  := GdFieldPos( "TNF_ENDLOC", aGridAux[ _nHeader ] )
	Local nPosNSer := GdFieldPos( "TNF_NSERIE", aGridAux[ _nHeader ] )

	Default aColsMov := {}
	Default lValTNF := Len( aColsMov ) == 0 // Variavel que indica se o retorno será o aCols

	If cUsaRast == "S"
		cTmpLote := IIf( lValTNF, TNF->TNF_LOTECT, aColsMov[ nPosLot ] )
		cTmpSubL := IIf( lValTNF, TNF->TNF_LOTESB, aColsMov[ nPosSubL ] )
	EndIf

	If cUsaLocz == "S"
		cTmpLocz := IIf( lValTNF, TNF->TNF_ENDLOC, aColsMov[ nPosEnd ] )
		cTmpNSer := IIf( lValTNF, TNF->TNF_NSERIE, aColsMov[ nPosNSer ] )
	EndIf

Return { cTmpLote, cTmpSubL, cTmpLocz, cTmpNSer }

//---------------------------------------------------------------------
/*/{Protheus.doc} fQuantDevo

Função auxiliar da gravação, para pegar a quantidade de EPI parciais
devolvidos

@param cSeekPar Caracter Chave de devolução

@sample fQuantDevo( cSeekTNF, "TRB" )
@return nDevolvido Numerico Quantidade total devolvido

@author Guilherme Benkendorf
@since 01/06/2015
/*/
//---------------------------------------------------------------------
Static Function fQuantDevo( cSeekPar )

	Local nDevolvido := 0

	dbSelectArea( cAliasTLW )
	dbSetOrder( 1 )
	dbSeek( cSeekPar )
	While ( cAliasTLW )->( !Eof() ) .And. ( ( cAliasTLW )->TLW_FORNEC + ( cAliasTLW )->TLW_LOJA + ( cAliasTLW )->TLW_CODEPI +;
		( cAliasTLW )->TLW_NUMCAP + ( cAliasTLW )->TLW_MAT + DTOS( ( cAliasTLW )->TLW_DTENTR ) +;
		( cAliasTLW )->TLW_HRENTR ) == cSeekPar

		If ( cAliasTLW )->TLW_DELETE == _DELETADO
			( cAliasTLW )->( dbSkip() )
			Loop
		EndIf

		nDevolvido += ( cAliasTLW )->TLW_QTDEVO

		( cAliasTLW )->( dbSkip() )
	End

Return nDevolvido
//---------------------------------------------------------------------
/*/{Protheus.doc} GetMemoTNF

Retorna em um array bidirecional

@param cSeekPar Caracter Chave de devolu

@sample fQuantDevo( cSeekTNF, "TRB" )
@return nDevolvido Numerico Quantidade total devolvido

@author Guilherme Benkendorf
@since 01/06/2015
/*/
//---------------------------------------------------------------------
Static Function GetMemoTNF()

	Local lObser := TNF->( FieldPos( "TNF_CODOBS" ) ) > 0 .And. SuperGetMv( "MV_NG2INTE", .F., "1" ) == "2"

	Local aMemosTNF := {}

	If lObser
		aAdd( aMemosTNF, { "TNF_CODOBS", "TNF_OBSLOG" } )
	EndIf

Return aMemosTNF

//------------------------------------------------------------------
/*/{Protheus.doc} fGrvEpiNec
Analisa se exite o código e fornecedor para o Epi

@author Roger Rodrigues
@since 11/03/2010

/*/
//---------------------------------------------------------------------
Static Function fGrvEpiNec( cCodEPI, nOpcao )

	Local cFilEpiFil	:= ''

	Local lFound    	:= .F.
	Local lExistHis 	:= Type( 'lHist695' ) == 'L'

	Local nX			:= 0
	Local nPosEpi		:= 0
	Local nSizeFor  	:= IIf( ( TamSX3( 'A2_NOME' )[ 1 ] ) < 1, 30, ( TamSX3( 'A2_NOME' )[ 1 ] ) )

	( 'SB1' )->( DbSelectArea( 'SB1' ) )
	( 'SB1' )->( DbSetOrder( 01 ) )

	If ( 'SB1' )->( DbSeek( xFilial( 'SB1' ) + cCodEPI ) ) .And. SB1->B1_MSBLQL != '1'

		DbSelectArea( 'TN3' )
		( 'TN3' )->( DbSetOrder( 02 ) )

		If ( 'TN3' )->( DbSeek( xFilial( 'TN3' ) + cCodEPI ) )

			While ( 'TN3' )->( !Eof() .And. TN3->TN3_CODEPI == cCodEPI )

				( 'SA2' )->( DbSelectArea( 'SA2' ) )
				( 'SA2' )->( DbSetOrder( 01 ) )

				If ( 'SA2' )->( DbSeek( xFilial( 'SA2' ) + TN3->TN3_FORNEC + TN3->TN3_LOJA ) )

					cFilEpiFil := xFilial( 'TL0' ) + TN3->TN3_CODEPI + TN3->TN3_FORNEC + TN3->TN3_LOJA

					//----------------------------------------------------------------------
					// Valida validade do Epi, pode ser ignorado com o parâmetro MV_MDTEPIV
					// Em caso de Epi genérico a validação é feita posteriormente
					//----------------------------------------------------------------------
					If( TN3->TN3_DTVENC >= dDataBase .Or. nOpcVenc != 2 .Or. ( lExistHis .And. lHist695 );
					.Or. ( TN3->TN3_GENERI == '2' .And. !Empty( Posicione( 'TL0', 1, cFilEpiFil, 'TL0_EPIFIL' ) ) ) )

						// Verifica se o EPI está bloqueado ( este campo é reservado e pode ser criado automaticamente pelo configurador )
						If TN3->( FieldPos( 'TN3_MSBLQL' ) ) > 0

							If TN3->TN3_MSBLQL == '1'

								( 'TN3' )->( dbSkip() )
								Loop

							EndIf

						EndIf

						lFound := .T.

						dbSelectArea( cAliasEPI )

						If !dbSeek( TN3->TN3_CODEPI + TN3->TN3_FORNEC )

							RecLock( cAliasEPI, .T. )

							//Verifica se ja foi alterado fornecedor
							If (nPOSEpi := aScan( aEpiAlt, {|x| x[1] == TNB->TNB_CODEPI} )) > 0

								For nX:=1 To Len( aDBFEPI )

									&("(cAliasEPI)->" + aDBFEPI[nX, 1]) := aEpiAlt[nPOSEpi, 2, nX, 2]

								Next nX

							Else

								If lObrTNB .And. ( nOpcao == 1 .Or. nOpcao == 4 )

									(cAliasEPI)->OBRIGA := IIf( TNB->TNB_OBRIGA == "S", STR0115, STR0116 )		 //"Sim"###"Não"
									(cAliasEPI)->OK     := IIf( TNB->TNB_OBRIGA == "S", cMarca, "" )

								ElseIf lObrTNX .And. ( nOpcao == 3 )

									(cAliasEPI)->OBRIGA := IIf( TNX->TNX_TIPO == "1", STR0115, STR0116 )		 //"Sim"###"Não"
									(cAliasEPI)->OK     := IIf( TNX->TNX_TIPO == "1", cMarca, "" )

								Else
									(cAliasEPI)->OK     := cMarca

								EndIf

								(cAliasEPI)->CODEPI := cCodEPI
								(cAliasEPI)->DESCRI := Substr( SB1->B1_DESC, 1, nSizeSB1 )
								(cAliasEPI)->FORNEC := TN3->TN3_FORNEC
								(cAliasEPI)->NOME   := Substr( SA2->A2_NOME, 1, nSizeFOR )
								(cAliasEPI)->LOJA   := SA2->A2_LOJA
								(cAliasEPI)->NUMCAP := TN3->TN3_NUMCAP
								(cAliasEPI)->DTVENC := TN3->TN3_DTVENC
								(cAliasEPI)->LOCPAD := SB1->B1_LOCPAD

							EndIf

							(cAliasEPI)->(MsUnlock( cAliasEPI ))

						EndIf

					EndIf

				EndIf

				( 'TN3' )->( dbSkip() )

			End

		EndIf

	EndIf

Return lFound

//------------------------------------------------------------------
/*/{Protheus.doc} fCarregaCols
Função auxiliar da MDT695DVPA para carregar a aHeader e aCols
Carrega através da tabela temporaria da TLW

@param cChave		Caracter	Conteúdo para busca na TRB
@param aHeadTLW	Array			Array do cabeçalho da TLW
@param aCoslTLW	Array			Array dos registros da TLW

@return Nil

@author Guilherme Benkendorf
@since 15/06/2015

@obs Uso MDTA695
/*/
//---------------------------------------------------------------------
Static Function fCarregaCols( cChave, aHeadTLW, aColsTLW )

	Local nX
	Local cCond := "TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR"
	Local cCampo
	Local aNaoTLW := {}

	If cUsaInt1 != "S"
		aAdd( aNaoTLW, "TLW_TIPODV" )
		aAdd( aNaoTLW, "TLW_LOCAL"  )
	EndIf

	aHeadTLW := CABECGETD( "TLW", aNaoTLW, 2 )
	aColsTLW := {}
	aAuxCols := BlankGetD( aHeadTLW )
	dbSelectArea( cAliasTLW )
	dbSetOrder( 1 )//TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)
	dbSeek( cChave )
	While (cAliasTLW)->( !Eof() ) .And. (cAliasTLW)->( TLW_FORNEC + TLW_LOJA + TLW_CODEPI +;
			 TLW_NUMCAP + TLW_MAT + DTOS( TLW_DTENTR ) + TLW_HRENTR ) == cChave

		aAdd( aColsTLW, aClone( aAuxCols[1] ) )

		For nX := 1 To Len( aHeadTLW )

			cCampo := aHeadTLW [ nX, 2 ]
			aColsTLW[ Len( aColsTLW ), nX ] := (cAliasTLW)->&( cCampo )

		Next nX
		aTail( aColsTLW[ Len( aColsTLW ) ] ) := (cAliasTLW)->TLW_DELETE == _DELETADO
		(cAliasTLW)->( dbSkip() )
	End

	If Len( aColsTLW ) == 0
		aColsTLW := aClone( aAuxCols )
	EndIf

Return Nil

//------------------------------------------------------------------
/*/{Protheus.doc} MDT695TRB
Função para carregar TRB da devolucao parcial

@param cChave		Caracter	Conteúdo para busca na TLW
@param lCallTN3	Boolean		Indica se a busca será feita com os valores
de busca do fornecedor

@return Nil

@author Guilherme Benkendorf
@since 15/06/2015

@obs Uso MDTA695
/*/
//---------------------------------------------------------------------
Function MDT695TRB( cMat, cFornec, cLoja, cCodEpi, cNumCA, lCallTN3 )

	Local nX
	Local cAliasQry := GetNextAlias()

	Local cCampo
	Local xResult

	Local aNaoTLW    := {}

	Default cMat     := ""
	Default cFornec  := ""
	Default cLoja    := ""
	Default cCodEpi  := ""
	Default cNumCA   := ""
	Default lCallTN3 := .F.

	If Select( cAliasTLW ) > 0

		cQuery := " SELECT * FROM " + RetSQLTab( "TLW" )
		cQuery += " WHERE " + RetSQLFil( "TLW" )
		cQuery += " AND " + RetSQLDel( "TLW" )
		If lCallTN3
			cQuery += " AND TLW.TLW_FORNEC = " + ValToSQL( cFornec )
			cQuery += " AND TLW.TLW_LOJA = " + ValToSQL( cLoja )
			cQuery += " AND TLW.TLW_CODEPI = " + ValToSQL( cCodEpi )
			cQuery += " AND TLW.TLW_NUMCAP = " + ValToSQL( cNumCA )
		Else
			cQuery += " AND TLW.TLW_MAT = " + ValToSQL( cMat )
		EndIf
		cQuery := ChangeQuery( cQuery )
		dbUseArea( .T., "TOPCONN", TCGENQRY( , , cQuery ), cAliasQry, .F., .T. )

		While ( cAliasQry )->( !Eof() )
			//Verifica cada coluna da tabela da TRB através do For
			dbSelectArea( cAliasTLW )
			RecLock( cAliasTLW, .T. )
				For nX := 1 To FCount()
					cCampo := FieldName( nX )
					If TLW->( FieldPos( cCampo ) ) > 0
						If ValType( (cAliasTLW)->&( cCampo ) ) == "D"
							xResult := STOD( (cAliasQry)->&( cCampo ) )
						Else
							xResult := (cAliasQry)->&( cCampo )
						EndIf
						(cAliasTLW)->&( cCampo ) := xResult
					EndIf
				Next nX
			( cAliasTLW )->( MsUnLock() )
			( cAliasQry )->( dbSkip() )
		End

		dbSelectArea( cAliasQry )
		dbCloseArea()
	EndIf

Return Nil

//------------------------------------------------------------------
/*/{Protheus.doc} fValidDevEpi
Pré - Validação de acesso na funcionalidade de Devolução parcial
na rotina MDTA695

@return lRet	Boolean Retorna .F. se há alguma inconsistência.

@param cSeekEPI Caracter	Chave para verificar posicionar TNF
@param aOldHea	Array			Array do aHeader da TNF, para buscar posições no aCols
@param aOldCol	Array			Array do aCols da TNF trabalhada
@param nAt			Numérico	Número indicando a linha posicionada no aOldCol

@author Guilherme Benkendorf
@since 08/06/2015
/*/
//---------------------------------------------------------------------
Static Function fValidDevEpi( cSeekEPI, aOldHea, aOldCol, nAt )

	Local nPosInDe	:= GdFieldPos( "TNF_INDDEV", aOldHea )
	Local nPosLot	:= GdFieldPos( "TNF_LOTECT", aOldHea )
	Local nPosSubL	:= GdFieldPos( "TNF_LOTESB", aOldHea )

	Local lBioLeg := SuperGetMV('MV_BIOMDT', .F., '1') <> '2'
	Local lFieldBio := IIf( lBioLeg, NGCADICBASE( "TNF_DEVBIO", "D", "TNF", .F. ),;
		NGCADICBASE( "TM0_REGBIO", "D", "TM0", .F. ) )

	Local lRet := .T.

	If lRet
		dbSelectArea( "TNF" )
		dbSetOrder( 1 )
		If !dbSeek( xFilial( "TNF" ) + cSeekEPI )
			MsgStop( STR0191 ) // "Durante a inclusão de uma entrega de EPI, não é possível registrar devolução parcial."
			lRet := .F.
		Else
			If Empty( TNF->TNF_DTRECI )
				MsgStop( STR0246 ) // "Para prosseguir com a devolução parcial, imprima antes o recibo de entrega de EPI."
				lRet := .F.
			ElseIf TNF->TNF_INDDEV == "1" .And. TNF->TNF_QTDEVO == 0
				MsgStop( STR0192 ) //"Se a quantidade entregue de EPI já foi devolvida totalmente, não poderá ser informada devolução parcial."
				lRet := .F.
			EndIf
		EndIf
	EndIf

	If lRet .And. Empty( cMatricEn )
		MsgInfo( STR0230, STR0144 ) //"É necessario informar um funcionario."##"Atenção"
		lRet := .F.
	EndIf

	If lRet .And. Empty( dDataSvEn )
		MsgInfo( STR0231, STR0144 ) //"É necessario informar a Data de Entrega."##"Atenção"
		lRet := .F.
	EndIf

	If lRet .And. !( nQtdadeEn > 0 )
		MsgInfo( STR0142, STR0144 ) //"A quantidade entregue deve ser informada." //"Atenção"
		lRet := .F.
	EndIf

	If lRet .And. Empty( cEpiSvoEn )
		MsgInfo( STR0143, STR0144 ) //"Nenhum Epi foi selecionado." //"Atenção"
		lRet := .F.
	EndIf

	If lRet .And. lFieldBio .And. SuperGetMv( "MV_DEVBIOM", .F., "N" ) == "1"
		dbSelectArea( "TM0" )
		dbSetOrder( 11 ) //TM0_FILIAL+TM0_MAT
		If dbSeek( xFilial( "TM0" ) + cMatricEn )

			If lBioLeg
				//Busca as digitais
				aDigTM0 := MdtRetBio( TM0->TM0_NUMFIC, "TM0" )

				If Len( aDigTM0 ) > 0
					cD1 := BioFGetFinger()
					If AllDigit( SubStr( cD1, 1, 12 ) )
						cD1:= SubStr( cD1, 13 )
					EndIf

					If "ERRO" $ cD1 .Or. Len( Alltrim( cD1 ) ) < 60
						If !("ERRO" $ cD1)
							MsgStop( STR0226 ) //"Falhou captura da impressão digital."
						EndIf
						lRet := .F.
					EndIf

					nRet := BioChkFingers( cD1, aDigTM0 )

					If lRet
						If nRet == 0
							MsgStop( STR0227 ) //"Digital não confere com o cadastro deste funcionário."
							lRet := .F.
						Else
							If !MsgYesNo( STR0228 ) //"Digital confere com o cadastro deste funcionário. Confirmar a entrega do EPI?"
								lRet := .F.
							EndIf
							lDigital := .T.
						EndIf
					EndIf
				Else
					If !MsgYesNo( STR0229 ) //"O funcionário não possui cadastro biometrico. Deseja continuar assim mesmo?"
						lRet := .F.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	If lRet .And. aOldCol[ nAt, nPosInDe ] == "3"
		MsgInfo( STR0141 ) //"O Epi está em solicitação ao armazém, portanto, não poderá ser devolvido."
		lRet := .F.
	EndIf

	If cUsaRast == "S"
		cLoteSvEn := aOldCol[ nAt, nPosLot ]
		cSublSvEn := aOldCol[ nAt, nPosSubL ]
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT695AUTO
Execução automatica da tabela SCP

@type function

@source MDTA695.prx

@param cCodEpi		, Caracter, Indica o código de Epi.
@param cUniMed		, Caracter, Indica a unidade de medida.
@param nQuanti		, Numerico, Indica a quantidade de Epi.
@param cLocal 		, Caracter, Indica o Local.
@param dDtNec		, Data    , Indica a data de necessidade.
@param dDtEmi 		, Data    , Indica a data de emissao.
@param cNomeSolic	, Caracter, Indica o nome do solicitante.
@param cNomCC 		, Caracter, Indica o nome do CC.
@param cDescProd	, Caracter, Indica a descrição do Produto.
@param cObserv		, Caracter, Indica a observação.
@param nOpcSCP		, Numerico, Indica a operação realizada.
@param cNumSA 		, Caracter, Indica o numero da S.A.
@param cItemSA 		, Caracter, Indica o item da S.A.

@author Jean Pytter da Costa
@since 23/05/2017

@return Nulo, Sempre Nulo
/*/
//---------------------------------------------------------------------
Function MDT695AUTO( aEpiSA, nOpcSCP )

	Local lLogix := SuperGetMv( "MV_NG2INTE", .F., "1" ) == "2"
	Local aCab	 := {}
	Local aItem	 := {}
	Local nCont	 := 0
	Local nPe    := 0

	Private aRet := {} //Deixa a variável privada para tratar seu retorno pelo Type

	For nCont := 1 To Len( aEpiSA )
		If lLogix

			aCab := {  	 { "CP_NUM", aEpiSA[ nCont, 11 ], NIL },;
						 { "CP_PRODUTO", aEpiSA[ nCont, 1 ], NIL } }

			aAdd( aItem, {   { "CP_PRODUTO", aEpiSA[ nCont, 1 ], NIL },;
						 	 { "CP_UM", aEpiSA[ nCont, 2 ], NIL },;
							 { "CP_QUANT", aEpiSA[ nCont, 3 ], NIL },;
							 { "CP_LOCAL", aEpiSA[ nCont, 4 ], NIL },;
							 { "CP_DATPRF", aEpiSA[ nCont, 5 ], NIL },;
							 { "CP_EMISSAO", aEpiSA[ nCont, 6 ], NIL },;
							 { "CP_SOLICIT", aEpiSA[ nCont, 7 ], NIL },;
							 { "CP_CC", aEpiSA[ nCont, 8 ], NIL },;
							 { "CP_DESCRI", aEpiSA[ nCont, 9 ], NIL },;
							 { "CP_OBS", aEpiSA[ nCont, 10 ], NIL } } )
		Else

			aCab := {  { "CP_NUM", aEpiSA[ nCont, 11 ], NIL },;
					   { "CP_ITEM", aEpiSA[ nCont, 12 ], NIL },;
					   { "CP_EMISSAO", aEpiSA[ nCont, 6 ], NIL } }

			If nOpcSCP == 5
				aAdd( aItem, {  { "CP_ITEM", aEpiSA[ nCont, 12 ], NIL },;
								 { "CP_PRODUTO", aEpiSA[ nCont, 1 ], NIL },;
								 { "CP_QUANT", aEpiSA[ nCont, 3 ], NIL },;
								 { "AUTDELETA", 'S', Nil } } )
			Else
				aAdd( aItem, {   { "CP_ITEM", aEpiSA[ nCont, 12 ], NIL },;
								 { "CP_NUM", aEpiSA[ nCont, 11 ], NIL },;
								 { "CP_PRODUTO", aEpiSA[ nCont, 1 ], NIL },;
								 { "CP_UM", aEpiSA[ nCont, 2 ], NIL },;
								 { "CP_QUANT", aEpiSA[ nCont, 3 ], NIL },;
								 { "CP_LOCAL", aEpiSA[ nCont, 4 ], NIL },;
								 { "CP_DATPRF", aEpiSA[ nCont, 5 ], NIL },;
								 { "CP_EMISSAO", aEpiSA[ nCont, 6 ], NIL },;
								 { "CP_SOLICIT", aEpiSA[ nCont, 7 ], NIL },;
								 { "CP_CC", aEpiSA[ nCont, 8 ], NIL },;
								 { "CP_DESCRI", aEpiSA[ nCont, 9 ], NIL },;
								 { "CP_OBS", aEpiSA[ nCont, 10 ], NIL } } )
			EndIf
		EndIf
	Next nCont

	If !lLogix

		//Ponto de entrada para adicionar campos diferentes ou novos campos na SCP.
		If ExistBlock( "MDTA6959" )
			aRet := ExecBlock( "MDTA6959", .F., .F., { aCab, aItem } )

			//Adiciona novos campos nos arrays
			If Type( "aRet[ 1 ]" ) == "A"
				aCab := aClone( aRet[ 1 ] )
			EndIf

			If Type( "aRet[ 2 ]" ) == "A"
				For nPe := 1 To Len(aRet[ 2 ])
					aItem[ nPe ] := aClone( aRet[ 2, nPe ] )
				Next nPe
			EndIf

		EndIf

	EndIf

	Begin Transaction

		MSExecAuto( { |x, y, z| mata105( x, y, z ) }, aCab, aItem, nOpcSCP )
		
		//Caso ocorra erro na integração com o estoque
		If lMsErroAuto

			//Mostra o erro em tela
			MostraErro()

			//Disarma a transação
			DisarmTransaction()

		Else

			ConfirmSX8()

		EndIf

	End Transaction

	If lLogix//Retorna para o Registro Gravado
		dbSelectArea( "SCP" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "SCP" ) + aEpiSA[ Len( aEpiSA ), 11 ] )
	EndIf

Return !lMsErroAuto

//-------------------------------------------------------------------
/*/{Protheus.doc} MDT695LinAl
Busca as linhas que foram incluídas/alteradas/excluídas no aCols

@sample MDT695LinAl( aCols, aColsTNF, aHeader )

@param	aColsNov, Array, aCols após as alterações
@param	aColsAnt, Array, aCols antes das alterações
@param	aHeader, Array, aHeader da grid

@author Luis Fellipy Bett
@since  28/08/2020

@return	aColsAlt, Array, Array contendo a matrícula dos funcionários
que tiveram seuas cadastros alterados no aCols
/*/
//-------------------------------------------------------------------
Function MDT695LinAl( aColsNov, aColsAnt, aHeader )

	Local nCont
	Local lExist
	Local aColsAlt	:= {}
	Local nFor	:= aScan( aHeader, { |x| AllTrim( Upper( X[2] ) ) == "TNF_FORNEC" } )
	Local nLoj	:= aScan( aHeader, { |x| AllTrim( Upper( X[2] ) ) == "TNF_LOJA" } )
	Local nEPI	:= aScan( aHeader, { |x| AllTrim( Upper( X[2] ) ) == "TNF_CODEPI" } )
	Local nCAP	:= aScan( aHeader, { |x| AllTrim( Upper( X[2] ) ) == "TNF_NUMCAP" } )
	Local nMat	:= aScan( aHeader, { |x| AllTrim( Upper( X[2] ) ) == "TNF_MAT" } )
	Local nDt	:= aScan( aHeader, { |x| AllTrim( Upper( X[2] ) ) == "TNF_DTENTR" } )
	Local nHr	:= aScan( aHeader, { |x| AllTrim( Upper( X[2] ) ) == "TNF_HRENTR" } )

	//Caso for chamado pela MDTA630 ou caso for chamado pelo MDTA695 e não for execução via rotina automática
	If IsInCallStack( "MDTA630" ) .Or. ( IsInCallStack( "MDTA695" ) .And. !l695Auto ) .Or. IsInCallStack( 'MDTA410' )
	
		For nCont := 1 To Len( aColsNov )

			If !aTail( aColsNov[ nCont ] ) //Caso o registro não esteja excluído, adiciona ao array
				If nMat > 0 //Caso for via MDTA630
					lExist := ( nPosReg := aScan( aColsAnt, { |x| x[ nMat ] + DToS( x[ nDt ] ) + x[ nHr ] == ;
								aColsNov[ nCont ][ nMat ] + DToS( aColsNov[ nCont ][ nDt ] ) + aColsNov[ nCont ][ nHr ] } ) ) > 0
				Else
					lExist := ( nPosReg := aScan( aColsAnt, { |x| x[ nFor ] + x[ nLoj ] + x[ nEPI ] + x[ nCAP ] + DToS( x[ nDt ] ) + x[ nHr ]  == ;
								aColsNov[ nCont ][ nFor ] + aColsNov[ nCont ][ nLoj ] + aColsNov[ nCont ][ nEPI ] + aColsNov[ nCont ][ nCAP ] + ;
								DToS( aColsNov[ nCont ][ nDt ] ) + aColsNov[ nCont ][ nHr ] } ) ) > 0
				EndIf

				If !lExist .Or. ( lExist .And. !ArrayCompare( aColsNov[ nCont ], aColsAnt[ nPosReg ] ) .Or. !ArrayCompare( aColsNov [ nCont ], aColsAnt [ nPosReg ] ) )
					If nMat > 0 //Caso for via MDTA630
						aAdd( aColsAlt, { aColsNov[ nCont, nMat ] + ( cTRBTN3 )->CODEPI + DToS( aColsNov[ nCont, nDt ] ) + ;
										Padr( aColsNov[ nCont, nHr ], TAMSX3( "TNF_HRENTR" )[1] ) } )
					Else
						aAdd( aColsAlt, { SRA->RA_MAT + aColsNov[ nCont, nEPI ] + DToS( aColsNov[ nCont, nDt ] ) + ;
										Padr( aColsNov[ nCont, nHr ], TAMSX3( "TNF_HRENTR" )[1] ) } )
					EndIf
				EndIf
			EndIf

		Next nCont

	Else

		//Percorre o array dos EPI's a serem cadastrados via ExecAuto
		For nCont := 1 To Len( aAutoItens )

			//Busca os campos de acordo com as posições passadas no array
			nMat := aScan( aAutoItens[ nCont ], { |x| x[ 1 ] == "TNF_MAT" } )
			nEPI := aScan( aAutoItens[ nCont ], { |x| x[ 1 ] == "TNF_CODEPI" } )
			nDt := aScan( aAutoItens[ nCont ], { |x| x[ 1 ] == "TNF_DTENTR" } )
			nHr := aScan( aAutoItens[ nCont ], { |x| x[ 1 ] == "TNF_HRENTR" } )

			aAdd( aColsAlt, { Padr( aAutoItens[ nCont, nMat, 2 ], TAMSX3( "TNF_MAT" )[1] ) + ;
							Padr( aAutoItens[ nCont, nEPI, 2 ], TAMSX3( "TNF_CODEPI" )[1] ) + ;
							DToS( aAutoItens[ nCont, nDt, 2 ] ) + ;
							Padr( aAutoItens[ nCont, nHr, 2 ], TAMSX3( "TNF_HRENTR" )[1] ) } )

		Next nCont

	EndIf

Return aColsAlt

//-------------------------------------------------------------------
/*/{Protheus.doc} fActBtAlt
Ação do botão de alteração dos fornecedores dos epis necessários

@sample fActBtAlt()

@author Luis Fellipy Bett
@since  22/01/2021

@return	Nil, Nulo
/*/
//-------------------------------------------------------------------
Static Function fActBtAlt()

	Local cEpiPos	:= ( cAliasEPI )->CODEPI
	Local aMarcados := {}
	Local nCont		:= 0

	If ( cAliasEPI )->( RecCount() ) > 0

		//Valida se o Epi selecionado possui mais de um fornecedor
		dbSelectArea( "TN3" )
		dbSetOrder( 2 )
		dbSeek( xFilial( "TN3" ) + cEpiPos )
		While TN3->TN3_FILIAL == xFilial( "TN3" ) .And. TN3->TN3_CODEPI == cEpiPos
			nCont++
			dbSkip()
		End

		If nCont == 1 //Caso esteja relacionado a apenas um fornecedor emite a mensagem
			MsgStop( STR0258, STR0144 ) //"O EPI posicionado está relacionado apenas a um fornecedor"
		Else
			//Verifica se o registro posicionado também está marcado
			dbSelectArea( cAliasEPI )
			dbGoTop()
			While !Eof()
				If !Empty( ( cAliasEPI )->OK )
					aAdd( aMarcados, { ( cAliasEPI )->CODEPI } )
				EndIf
				dbSkip()
			End
			dbSeek( cEpiPos ) //Posiciona novamente no registro selecionado no MarkBrowse

			If aScan( aMarcados, { |x| x[1] == cEpiPos } ) > 0
				fEPIMDT695( cEpiPos, .T., .F. )
			Else
				MsgStop( STR0259, STR0144 ) //"Para alterar o fornecedor certifique-se de que o registro do EPI está marcado e que o cursor esteja posicionado sobre ele"
			EndIf
		EndIf
	Else
		MsgStop( STR0200, STR0144 )
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTEpiS2240
Realiza a validação e envio das informações do evento S-2240 ao Governo

@param aFuncs, Array, Array contendo os funcionários a serem enviados ao Governo
@param lEnvio, Boolean, Indica se é envio de informações, caso contrário trata como validação

@sample MDTEpiS2240( { { "000023" } }, .F. )

@return lRet, Boolean, .T. caso não existam inconsistências no envio

@author Luis Fellipy Bett
@since	17/03/2021
/*/
//---------------------------------------------------------------------
Function MDTEpiS2240( aFuncs, lEnvio )

	//Salva as áreas
	Local aArea := GetArea()
	Local aAreaSB1 := SB1->( GetArea() )

	//Variáveis de controle e busca das informações
	Local cMsgErr := ""
	Local lRet := .T.

	//Define por padrão como sendo envio de informações
	Default lEnvio := .T.
	Default l695Auto := .F.

	// Ponto de entrada para não gerar o evento S-2240 na entrega de EPI
	If ExistBlock( 'MDTA695B' ) .And. ExecBlock( 'MDTA695B', .F., .F. )
		Return .T.
	EndIf

	If Len( aFuncs ) > 0 //Caso existam funcionários expostos ao risco cadastrado
		lRet := MDTIntEsoc( "S-2240", 4, , aFuncs, lEnvio, , , @cMsgErr ) //Valida as informações a serem enviadas no evento S-2240
	EndIf

	//Caso for execução automática e existam erros na validação dos registros a serem enviados
	If l695Auto .And. !Empty( cMsgErr )

		//Adiciona os erros retornados na variável
		AutoGrLog( cMsgErr )

		//Chama a função de exibição/gravação do log de erros
		fMostraErr( 2 )

		//Define a variável de erro do ExecAuto de acordo com o retorno do eSocial
		lMsErroAuto := !lRet

	EndIf

	//Retorna as áreas
	RestArea( aAreaSB1 )
	RestArea( aArea )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fMostraErr
Função responsável por mostrar o erro em tela ou gerar o arquivo no local definido

@sample fMostraErr()

@return Nil, Nulo

@author Luis Fellipy Bett
@since	05/05/2022
/*/
//---------------------------------------------------------------------
Function fMostraErr( nOpcVld )

	//Variáveis de criação do arquivo .txt
	Local cBarras := IIf( IsSrvUnix(), "/", "\" )
    Local cDirPai := cBarras + 'execauto_mdt'
    Local cDirFil := cBarras + 'execauto_mdt' + cBarras + 'epi'
	Local cNomArq := ""

	//Define os valores padrões das variáveis
	Default cCamArq := ""
	Default nMsgAut := 1

	//-------------------------------------------------------------
	// Caso será gerado o arquivo de gravação do erro, verifica se
	// as pastas existem e define o nome do arquivo a ser gerado
	//-------------------------------------------------------------
	If nMsgAut == 1 .Or. nMsgAut == 2

		//Caso será gerado um arquivo na pasta padrão
		If nMsgAut == 1
		
			//Cria o diretório pai
			If !File( cDirPai )
				MakeDir( cDirPai )
			EndIf

			//Cria o diretório filho
			If !File( cDirFil )
				MakeDir( cDirFil )
			EndIf
		
		EndIf

		//Define o nome do arquivo
		cNomArq := "mdta695_" + DToS( Date() ) + "_" + StrTran( Time(), ":", "" ) + "_validacoes_" + IIf( nOpcVld == 2, "esocial", "cadastro" ) + ".txt"

	EndIf

	//Define a execução da mensagem de inconsistências de acordo com a variável
	If nMsgAut == 1 //Salvar em um arquivo texto definido na pasta padrão do sistema

		MostraErro( cDirFil, cNomArq )

	ElseIf nMsgAut == 2 //Salvar em um arquivo texto no caminho passado pelo execauto

		MostraErro( cCamArq, cNomArq )

	ElseIf nMsgAut == 3 //Mostrar em tela

		MostraErro()

	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} Mdta695X3V
Função utilizada no X3_VALID dos campos da rotina

@author Gabriel Sokacheski
@since 21/12/2023

@param cCampo, nome do campo a ser validado

@return lRet, retorno da validação do campo
/*/
//-------------------------------------------------------------------
Function Mdta695X3V( cCampo )

	Local lRet		:= .T.

	Local xValor 	:= &( 'M->' + cCampo ) 

    If !Empty( xValor )
        Do Case
            Case cCampo == 'TNF_MOTIVO'
				lRet := Pertence( '12345678X' )
        End Case
    EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fGraDevTlw
Grava a devolução na tabela temporária da TLW

@author Gabriel Sokacheski
@since 10/09/2025

@param cHorGra, caractere, hora da gravação
@param nPosLcDv, numérico, referência ao campo local de devolução
@param nQtdDev, numérico, qtd. devolvida originalmente

/*/
//---------------------------------------------------------------------
Static Function fGraDevTlw( cHorGra, nPosLcDv, nQtdDev )

	DbSelectArea( cAliasTLW )
	DbSetOrder( 1 ) // TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR+DTOS(TLW_DTDEVO)

	If !DbSeek( M->TNF_FORNEC + M->TNF_LOJA + M->TNF_CODEPI + M->TNF_NUMCAP + cMatricula + DToS( M->TNF_DTENTR ) +;
	IIf( Len( (cAliasTLW)->TLW_HRENTR ) == 5, SubStr( M->TNF_HRENTR, 1, 5 ), M->TNF_HRENTR ) + DToS( M->TNF_DTDEVO ) )

		RecLock( cAliasTLW, .T. )
			( cAliasTLW )->TLW_FILIAL := FwXFilial( 'TLW' )
			( cAliasTLW )->TLW_FORNEC := M->TNF_FORNEC
			( cAliasTLW )->TLW_LOJA   := M->TNF_LOJA
			( cAliasTLW )->TLW_CODEPI := M->TNF_CODEPI
			( cAliasTLW )->TLW_NUMCAP := M->TNF_NUMCAP
			( cAliasTLW )->TLW_MAT    := M->TNF_MAT
			( cAliasTLW )->TLW_DTENTR := M->TNF_DTENTR
			( cAliasTLW )->TLW_HRENTR := M->TNF_HRENTR
			( cAliasTLW )->TLW_DTDEVO := M->TNF_DTDEVO
			( cAliasTLW )->TLW_HRDEVO := cHorGra // Hora Atual
			( cAliasTLW )->TLW_QTDEVO := nQtdDev
			( cAliasTLW )->TLW_LOCAL  := IIf( nPosLcDv == 0, M->TNF_LOCAL, M->TNF_LOCDV )
			( cAliasTLW )->TLW_TIPODV := M->TNF_TIPODV // Repor estoque
			( cAliasTLW )->TLW_NUMSEQ := M->TNF_NUMSEQ
			( cAliasTLW )->TLW_ALTERA := 'X'
		( cAliasTLW )->( MsUnlock() )

	EndIf

Return
