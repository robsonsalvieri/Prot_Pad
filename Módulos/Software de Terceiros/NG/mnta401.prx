#INCLUDE "MNTA401.CH"
#INCLUDE "PROTHEUS.CH"

Static nPosHrCnt1
Static nPosHrCnt2

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA401
Retorno em Lote   ... Refeito em 06/05/03 - Inácio
@author Ng Informatica
@since 12/12/99
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA401()

	//Guarda conteudo e declara variaveis padroes
	Local aNGBEGINPRM := NGBEGINPRM(,,,,.T.)

	Local GetList    := {},xx1,ic,iz,nI,nX
	Local oPanel
	Local aCposAlter := {}
	Local aPosCpo    := {}
	Local aRadio	 := {} // A variável está sendo utilizada em um PE, não modificar/apagar.
	Local nPosCpo    := 0
	Local nInd       := 0
	Local nTot       := 0
	Local nTamanho   := 0
	Local nDecimal   := 0
	Local aButton    := {{"AVGARMAZEM",{|| MNTA402() },STR0102,STR0101}} //"Rateio"##"Rateio de Insumos"
	Local lMUOK      := .T.
	Local bKeyF4 	 := SetKey(VK_F4)
	Local cTitulo    := ""
	Local cCampo     := ""
	Local cPicture   := ""
	Local cValid     := ""
	Local cUsado     := ""
	Local cTipo      := ""
	Local cArquivo   := ""
	Local cContext   := ""
	Local cX3Nivel   := ""
	Local lMNTA4015  := ExistBlock('MNTA4015')

	Private aRotina   := MenuDef()
	Private aTrocaF3  := {}, aBEMRET := {}
	Private cCadastro := STR0022 //"Retorno em Lote"
	Private cBEMRET   := space(len(stj->tj_codbem))
	Private lSH1      := .F.
	Private oDlg,oGet,oMenu, xx
	Private cLocal,cLoteCtl,cNumLote,cTos,lCalend
	Private cNGINSPREA := "R" // Indica se o insumo e realizado ou previsto, nao deve ser retirado
	// esta variavel ela e usada para fazer checagem em funcoes dos ng..
	Private cGERAPREV := AllTrim(GETMv("MV_NGGERPR"))
	Private cCODRASPR := Space(15), cTIPOINSR := STR0023
	Private cVALPECRE := AllTrim(GETMv("MV_NGCOQPR"))
	Private cPROGRAMA := "MNTA401"
	Private lUSATARG  := If(FindFunction("NGUSATARPAD"),NGUSATARPAD(),.f.)
	Private cTarefa   := '0     ',cNomeTa := If(lUSATARG,NGSEEK("TT9","0     ",1,"TT9_DESCRI"),Space(30))
	Private _cTipoIns
	Private nCusto

	If !NGCADICBASE("TB0_FILORD","A","TB0",.F.) .AND. NGFUNCRPO("SgaMntEst",.F.) .And. GetMv("MV_SGAMNT") == "S" .And. GetMv("MV_NGSGAES") <> "N"
		If !NGINCOMPDIC("UPDSGA01","00000015391/2010")
			Return
		Endif
	Endif

	Store Space(5) To M->TL_HOINICI,M->TL_HOFIM
	Store Ctod(' /  /  ') To M->TL_DTINICI,M->TL_DTFIM
	M->TL_QUANTID := 0
	M->TL_USACALE := "N"
	M->TL_TIPOREG := Space(1)

	dULMESFE  := AllTrim(GETMV("MV_ULMES"))
	cUsaInt1  := AllTrim(GetMv("MV_NGMNTPC"))
	cUsaInt2  := AllTrim(GetMv("MV_NGMNTCM"))
	cUsaInt3  := AllTrim(GetMv("MV_NGMNTES"))

	lIntegr   := If(cUsaInt3 = 'S',.T.,.F.)
	lCusto1   := If(cUsaInt3 = "N",.T.,.F.)

	aTprg     := {STR0023,STR0024,STR0025,STR0026}  //"Produto"###"Terceiros"###"Mao de Obra"###"Ferramenta"
	aDest     := {STR0027,STR0028,STR0029," "}  //"Apoio"###"Troca"###"Substituicao"
	aTos      := {STR0014,STR0015}
	dDataFix  := dDataBase
	cGeraEst  := 2
	nTotal    := 0.00
	nQuanRec  := 0
	cLocal    := SPACE(02)
	cLoteCtl  := SPACE(10)
	cHORAFIX  := Substr(Time(),1,5)
	_cTipoIns := aTprg[1]

	Store .f. To TIPOACOM,TIPOACOM2,lEdestino,LEDATAINI,lCONT401,lCalend
	Store .t. To lTipoDat,lRet,lReto,Inclui,lCorret,lCusto
	Store 1 To cTipoDat,cTipo_Os,cFecha,cOsCor
	Store Space(1) To M->TL_TIPOREG,cDestino
	Store Space(06) To cServico,cNumLote,cPRIMOSN,cULTIOSN
	Store Space(40) To cNomeSer,cNomeIns
	Store Ctod('  /  /  ') To dPRIMOSN,dULTIOSN

	cOsIMP   := 2
	cDestino := STR0027  //"Apoio"
	cTipoIns := STR0023  //"Produto"
	vOSUTILI := {}

	M->TL_CODIGO := Space(Len(STL->TL_CODIGO))

	aALIAS := "SB1"
	DbSelectArea("STC")
	DbGOBOTTOM()
	DbSKIP()
	DbSelectArea("STG")
	DbGOBOTTOM()
	DbSKIP()
	DbSelectArea("STT")
	DbGOBOTTOM()
	DbSKIP()
	DbSelectArea("STL")
	DbGOBOTTOM()
	DbSKIP()
	DbSelectArea("TQA")
	DbGOBOTTOM()
	DbSKIP()

	nUsado  := 0
	aHeader := {}
	fMntCabec()

	// Preenche o array auxiliar aCposAlter...
	If ExistBlock("NG401CPU")
		aCposAlter := ExecBlock("NG401CPU",.F.,.F.)
	EndIf

	// Agrega no array aHeader os campos de Usuarios...
	nTot := Len(aCposAlter)
	For nInd := 1 To nTot

		cCampo   := aCposAlter[nInd]
		If STL->(FieldPos(cCampo)) > 0

			cTitulo  := AllTrim(Posicione("SX3",2,cCampo,"X3Titulo()"))
			cArquivo := Posicione("SX3",2,cCampo,"X3_ARQUIVO")
			cPicture := X3Picture(cCampo)
			nTamanho := TAMSX3(cCampo)[1]
			nDecimal := TAMSX3(cCampo)[2]
			cValid   := Posicione("SX3",2,cCampo,"X3_VALID")
			cUsado   := Posicione("SX3",2,cCampo,"X3_USADO")
			cTipo    := Posicione("SX3",2,cCampo,"X3_TIPO")
			cContext := Posicione("SX3",2,cCampo,"X3_CONTEXT")
			cX3Nivel := Posicione("SX3",2,cCampo,"X3_NIVEL")

			If X3USO(cUsado) .And. cNivel >= cX3Nivel
				nUsado++
				aAdd(aHeader,{cTitulo,cCampo,cPicture,nTamanho,nDecimal,cValid,cUsado,cTipo,cArquivo,cContext})
			EndIf

		EndIf

	Next nInd

	//Inclui coluna de registro atraves de funcao generica
	ADHeadRec("STL",aHeader)
	nUsado := nUsado + 2

	dbSelectArea("SX3")
	dbSetOrder(1)
	aCols := Array(1,nUsado+1)

	nBEMGD  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TC_CODBEM"})
	nUSACA  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_USACALE"})
	nQUTGD  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_QUANTID"})
	nUNIGD  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_UNIDADE"})
	nDATGD  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_DTINICI"})
	nHORAI  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_HOINICI"})
	nDATAF  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_DTFIM"})
	nHORAF  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_HOFIM"})
	nPO1GD  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TQA_POSCON"})
	nPO2GD  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TQA_POSCO2"})
	nVALGD  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_CUSTO"})
	nVALGE  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TT_CUSTO"})
	nLOCAL  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_LOCAL"})
	nLOTEC  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_LOTECTL"})
	nNUMLO  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_NUMLOTE"})
	nTOCUS  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TT_CUSTO"})
	nDTVAL  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_DTVALID"})
	nLOCALI := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_LOCALIZ"})
	nNUMSEI := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_NUMSERI"})
	nQTDREC := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_QUANREC"})
	nMOEDA  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_MOEDA"  })

	nPosHrCnt1 := GdFieldPos( 'TQA_HORAC1' )
	nPosHrCnt2 := GdFieldPos( 'TQA_HORAC2' )

	aCOLS[1][nBEMGD] := SPACE(16)                // CODBEM
	Store 0 To aCOLS[1][nPO1GD],aCOLS[1][nPO2GD] // VALOR,CONTADOR 1,CONTADOR 2
	Store CTOD(' /  /  ') To aCOLS[1][nDATGD],aCOLS[1][nDATAF];
	// DATA EMISSAO
	aCOLS[1][nUNIGD] := SPACE(03)                // UNIDADE
	Store '  :  ' To aCOLS[1][nHORAI],aCOLS[1][nHORAF]
	//      HORA INICICO     HORA FIM
	Store 0.00 To aCOLS[1][nQUTGD]               // QUANTIDADE,VALOR ACUMULADO
	If !Empty(nVALGD)
		aCOLS[1][nVALGD] := 0.00
	EndIf
	nCusto := If(nVALGD > 0,aCOLS[1][nVALGD],0)

	If !Empty(nMOEDA)
		aCOLS[1][nMOEDA] := "1"
	Endif

	aCOLS[1][nUSACA]    := "N"      // USA CALENDA
	aCOLS[1][nLOCAL]    := SPACE(02)// LOCAL
	aCOLS[1][nLOTEC]    := SPACE(10)// NUMERO DO LOTE
	aCOLS[1][nNUMLO]    := SPACE(06)// SEQUENCIA DO LOTE
	aCOLS[1][nDTVAL]    := CTOD(' /  /  ')// DATA DE VALIDADE DO LOTE
	aCOLS[1][nLOCALI]   := SPACE(15)// LOCALIZACAO
	aCOLS[1][nNUMSEI]   := SPACE(20)// NUMERO DA SERIE
	aCols[1,nPosHrCnt1] := Time()
	aCols[1,nPosHrCnt2] := Time()

	//+-------------------------------------------------------------------+
	//| Preenche o array auxiliar aCposAlter...              			  |
	//+-------------------------------------------------------------------+
	If Len(aCposAlter) > 0
		For nI := 1 To Len(aCposAlter)
			nPosCpo := Ascan(aHeader,{|x| AllTrim(x[2])==aCposAlter[nI]})
			AADD(aPosCpo,{aCposAlter[nI],nPosCpo})
			aCOLS[1][nPosCpo] := CriaVar(aCposAlter[nI])
		Next nI
	EndIf

	dbSelectArea("STL")
	dbGoTop()
	aCols[1][nUsado-1] := "STL"
	aCols[1][nUsado] := STL->(Recno())
	aCOLS[1][Len(aCOLS[1])] := .F.

	nOpcx := 3
	nOpca := 1

	cF3 := 'SB1'
	SetKey(VK_F4,{|| MntViewSB2(cTipoIns,M->TL_CODIGO) })
	DEFINE MSDIALOG oDLG FROM  134,1 TO 500,795 TITLE cCadastro COLOR CLR_BLACK,CLR_WHITE PIXEL

	@ 020,020 MSPANEL oPanel OF oDlg

	@ 03,006 TO 33,048 LABEL STR0030 of oPanel Pixel //"Tp.Data"
	@ 010,009 RADIO oRad VAR cTIPODAT ITEMS STR0007, STR0008 on change NGA4013() 3D SIZE 35,10 of oPanel Pixel//"&Fixa"###"&Variavel"

	@ 003,058 TO 33,100 LABEL STR0010 of oPanel Pixel//"Trat. O.S."
	@ 010,061 RADIO oRad VAR cTIPO_OS ITEMS STR0011, STR0012 3D SIZE 35,10 of oPanel Pixel//"&Nova"###"&Aproveita"

	@ 003,111 TO 33,151 LABEL STR0013 of oPanel Pixel//"Gera Estoque"
	@ 010,114 RADIO oRad1 VAR cGERAEST ITEMS STR0014, STR0015 Valid Alert("") on change NGA4017() 3D SIZE 33,10 of oPanel Pixel //"&Sim"###"&Nao"

	If lCusto1
		oRad1:SetDisable()
	EndIf
	@ 003,162 To 33,204 LABEL OEMTOANSI(STR0035) OF oPanel PIXEL //"Fecha O.S"
	@ 010,165 RADIO oRadio Var cFECHA ITEMS STR0014,STR0015 3D SIZE 35,10 OF oPanel PIXEL

	@ 003,216 To 33,258 LABEL OEMTOANSI(STR0039) OF oPanel PIXEL //"Corretiva"
	@ 010,219 RADIO oRad Var cOsCor   ITEMS STR0014, STR0015 3d  SIZE 35,10 OF oPanel PIXEL //"&Sim"###"&Nao"

	@ 003,269 To 33,311 LABEL OEMTOANSI(STR0077) OF oPanel PIXEL //"Imp. O.S. Nova"
	@ 010,271 RADIO oRad Var cOsIMP   ITEMS STR0014, STR0015 3d  SIZE 36,10 OF oPanel PIXEL //"&Sim"###"&Nao"

	@ 038,008 say OemtoAnsi(STR0005) of oPanel Pixel //"Servico"
	@ 038,040 Msget cSERVICO Picture '@!' Valid chkserv(cServico) F3 "ST4" SIZE 25,7 of oPanel HASBUTTON Pixel
	@ 038,080 Msget cNOMESER picture '@!' When .f. SIZE 180,7 of oPanel Pixel

	@ 054,008 say OemtoAnsi(STR0009) of oPanel PIXEL//"Data Fixa"
	@ 053,040 MSGET dDATAFIX PICTURE '99/99/99' WHEN LTIPODAT VALID naovazio() .AND. NGA40111() SIZE 43,7 OF oPanel HASBUTTON PIXEL

	@ 054,090 say OemtoAnsi(STR0049) of oPanel PIXEL //"Hora Fixa"
	@ 053,115 MSGET cHORAFIX PICTURE '99:99' WHEN LTIPODAT VALID naovazio() .AND. NGVALHORA(cHORAFIX,.T.) SIZE 35,7 OF oPanel PIXEL

	If lUSATARG
		@ 054,165 say OemtoAnsi(STR0103) of oPanel PIXEL //"Tarefa"
		@ 053,185 MSGET cTarefa PICTURE '@!' VALID MNT401NTAR() F3 "TT9" SIZE 30,7 OF oPanel PIXEL HASBUTTON
		@ 053,225 MSGET cNomeTa PICTURE '@!' When .f. SIZE 130,7 OF oPanel PIXEL
	Endif

	@ 067,008 say OemtoAnsi(STR0017) of oPanel Pixel//"Tipo Insumo"

	@ 066,040 COMBOBOX cTipoIns ITEMS aTPRG Valid MNT401C() SIZE 45,7 OF oPanel PIXEL;
	ON CHANGE (NG401F3())

	@ 067,090 say OemtoAnsi(STR0018) of oPanel Pixel//"Codigo"
	@ 066,115 MSGET M->TL_CODIGO Picture "@" Valid NGA4016() .AND. NGPROBLQ(M->TL_CODIGO,IIF(cTIPOINS==STR0023,.t.,.f.)) F3 cF3 SIZE 43,7 of oPanel HASBUTTON Pixel
	@ 066,165 Msget cNOMEINS picture '@!' When .f. SIZE 150,7 of oPanel Pixel

	@ 080,008 say OemtoAnsi(STR0020) of oPanel Pixel//"Destino"
	@ 079,040 COMBOBOX cDestino ITEMS aDest When leDestino SIZE 35,7 OF oPanel PIXEL
	@ 080,090 say OemtoAnsi(STR0016) of oPanel Pixel //"Total"
	@ 079,115 MSGET nTOTAL Picture "@E 9,999,999.99"  SIZE 43,7 of oPanel Pixel When lCusto VALID NaoVazio() HASBUTTON

	@ 080,165 say OemtoAnsi(STR0106) of oPanel Pixel //"Quant. Recurso"
	@ 079,210 MSGET nQuanRec Picture "@E 999" Valid fQuanRec() SIZE 30,7 of oPanel Pixel When cTipoIns == STR0026 //"Ferramenta"

	/*----------------------------------------------
	Ponto de Entrada criado com o intuito de manipular o valor default dos
	campos tipo data, trat. OS, gera estoque, fecha OS, Corretiva, Imp. OS. Nova,
	considerando as regras já presentes nos campos.
	----------------------------------------------*/
	If ExistBlock( "MNTA4014" )
		aRadio = {	{cTIPODAT , oRad   },; // Tipo Data
		{cTIPO_OS , oRad   },; // Trat. O.S.
		{cGERAEST , oRad1  },; // Gera Estoque
		{cFECHA   , oRadio },; // Fecha O.S.
		{cOsCor   , oRad   },; // Corretiva
		{cOsIMP	  , oRad   }}  // Imp. O.S. Nova
		ExecBlock( "MNTA4014", .F., .F., { aRadio } )
	EndIf

	oGet := MSGetDados():New(120,1,188,315,nOpcx,"MNTA401LOK","MNTA401TOK",,.T.,,1,,300,"MNTA401CAB()",,,"MNTA401DEL()")
	oGet:aInfo[nNUMLO,4] := "lCONT401"
	oGet:aInfo[nLOTEC,4] := "lCONT401"
	NGPOPUP(asMenu,@oMenu)
	oDlg:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg)}
	ACTIVATE MSDIALOG oDlg ON INIT ( EnchoiceBar(oDlg,{||nOpca:=2,if(oGet:TudoOk(),oDlg:End(),nOpca := 1)},{||nOpca:=1,oDlg:End()},,aButton) ,;
	AlignObject(oDlg,{oPanel,oGet:oBrowse},1,,{190}))

	If nOpca == 1
		NGRETURNPRM(aNGBEGINPRM)
		Return NIL
	Endif

	cPLANO := If(cOsCor = 1,'000000','000001')

	For XX1 := 1 to len(aCols)
		XX := XX1
		lMUOK := .T.

		If !aCols[XX1][Len(aCols[XX1])]
			dbSelectArea("ST9")
			dbSetOrder(01)
			DbSeek(xFilial("ST9")+aCols[XX1][nBEMGD])
			If cTIPO_OS == 1 // Nova O.S.

				cORDEM := GETSXENUM("STJ","TJ_ORDEM")
				If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"  //Mensagem Unica
					//carrega os dados conforme o que vai ser gravado em NGA401STJ()
					M->TJ_ORDEM   := cORDEM
					M->TJ_CODBEM  := aCOLS[XX1][nBEMGD]
					M->TJ_OBSERVA := ''
					M->TJ_SITUACA := "L"
					M->TJ_TERMINO := "N"
					M->TJ_POSCON2 := aCOLS[XX1][nPO1GD]
					M->TJ_POSCONT := aCOLS[XX1][nPO2GD]
					M->TJ_USUARIO := If(Len(STJ->TJ_USUARIO) > 15,cUsername,Substr(cUsuario,7,15))
					M->TJ_DTORIGI := aCOLS[XX1][nDATGD]
					M->TJ_SERVICO := cSERVICO
					M->TJ_INTPRJ  := ''
					M->TJ_INTTSK  := ''
					lMUOK := NGMUMntOrd(STJ->(RecNo()),3,.T.)
				EndIf

				If lMUOK
					ConfirmSX8()
					// GRAVA NO ARQUIVO STJ )
					NGA401STJ(cORDEM,cPLANO,cTIPO_OS)
					DbSelectArea("STJ")
					DbSetOrder(1)
					If DbSeek(xFilial("STJ")+cORDEM)
						MNTA401GRA()
					EndIf
				Else
					RollBackSX8()
				EndIf

			Else
				lACHOU  := .F.
				dbSelectArea('STJ')
				dbSetOrder(2)
				DbSeek(xFilial("STJ")+"B"+aCols[XX1][nBEMGD]+cSERVICO)
				While !Eof() .and. xFilial("STJ") = STJ->TJ_FILIAL .and.;
				STJ->TJ_TIPOOS = "B" .And. STJ->TJ_CODBEM = aCols[XX1][nBEMGD];
				.and. STJ->TJ_SERVICO == cSERVICO

					If STJ->TJ_SITUACA = 'L' .And. STJ->TJ_TERMINO == 'N'
						lACHOU := .T.
						MNTA401GRA()
						Exit
					Endif
					dbSelectArea('STJ')
					dbSkip()
				End
				If !lACHOU

					cORDEM := GETSXENUM("STJ","TJ_ORDEM")
					If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"  //Mensagem Unica
						//carrega os dados conforme o que vai ser gravado em NGA401STJ()
						M->TJ_ORDEM   := cORDEM
						M->TJ_CODBEM  := aCOLS[XX1][nBEMGD]
						M->TJ_OBSERVA := ''
						M->TJ_SITUACA := "L"
						M->TJ_TERMINO := "N"
						M->TJ_POSCON2 := aCOLS[XX1][nPO1GD]
						M->TJ_POSCONT := aCOLS[XX1][nPO2GD]
						M->TJ_USUARIO := If(Len(STJ->TJ_USUARIO) > 15,cUsername,Substr(cUsuario,7,15))
						M->TJ_DTORIGI := aCOLS[XX1][nDATGD]
						M->TJ_SERVICO := cSERVICO
						M->TJ_INTPRJ  := ''
						M->TJ_INTTSK  := ''
						lMUOK := NGMUMntOrd(STJ->(RecNo()),3,.T.)
					EndIf

					If lMUOK
						ConfirmSX8()
						// GRAVA NO ARQUIVO STJ )
						NGA401STJ(cORDEM,cPLANO,1)
						DbSelectArea("STJ")
						DbSetOrder(1)
						If DbSeek(xFilial("STJ")+cORDEM)
							MNTA401GRA()
						Endif
					Else
						RollBackSX8()
					EndIf

				EndIf
			Endif

			If lMUOK .And. aSCAN(vOSUTILI,{|x| x == stj->tj_ordem}) = 0
				Aadd(vOSUTILI,stj->tj_ordem)
			Endif

		Endif
	Next XX1

	//+-------------------------------------------------------------------+
	//| Testa a impressao das O.S. novas.								  |
	//| Somente se for O.S. = NOVAS,ImpressÆo = SIM e fecha as O.S. = NAO |
	//+-------------------------------------------------------------------+

	If cTIPO_OS = 1 .And. cOsIMP = 1 .And. cFECHA = 2

		If MSGYESNO(STR0040,STR0041) //"Deseja Imprimir a O.S.?"###"ATENCAO"

			MNTR676(.F.,cPLANO,,,)

		Endif
	Endif

	//fechamento de O.S.
	If cFECHA == 1

		// FECHAMENTO PELO PADRAO ???  ... ITEM DA VERSÇO ANTERIOR

		// DESTE QUANDO UMA O.S. COM INSUMOS PREVISTO
		// PODE SER FECHADA PELO PADRÇO ????

		For iz := 1 To Len(vOSUTILI)
			Dbselectarea("STJ")
			Dbsetorder(1)
			If Dbseek(xFILIAL('STJ')+vOSUTILI[iz])
				cCODBEM := STJ->TJ_CODBEM
				If FindFunction("NGVLDSTL") .And. NGVLDSTL(vOSUTILI[iz]) // verifica se não existe insumo com data e hora inicial igual a data e hora final
					// Ponto de entrada que valida a finalização de OS
					If lMNTA4015 .And. !ExecBlock('MNTA4015', .F., .F., {STJ->TJ_ORDEM, STJ->TJ_PLANO})
						Loop
					EndIf
					NGFINAL(STJ->TJ_ORDEM,STJ->TJ_PLANO,STJ->TJ_DTPRINI,STJ->TJ_HOPRINI,;
					STJ->TJ_DTPRFIM,STJ->TJ_HOPRFIM,STJ->TJ_POSCONT,STJ->TJ_POSCON2, , , , ,If(cGERAEST = 1,.T.,.F.))

					//---------------------------------------------------
					lSTJAchou  := A401STJBUS(cCODBEM)

					dbSelectArea("ST9")
					dbSetOrder(1)

					If dbSeek(xFilial("ST9")+cCODBEM)
						RecLock("ST9",.F.)

						If lSTJAchou = .F.
							ST9->T9_TERCEIR := "1"
						EndIf

						MsUnlock("ST9")
					EndIf
				EndIf
			EndIf
		Next iz
	EndIf

	If ExistBlock("MNTA4013")
		ExecBlock("MNTA4013",.F.,.F.)
	EndIf
	SetKey(VK_F4,bKeyF4)

	//+-------------------------------------------------------------------+
	//|Retorna conteudo de variaveis padroes       						  |
	//+-------------------------------------------------------------------+

	NGRETURNPRM(aNGBEGINPRM)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA401GRA
Grava os dados no STL e STJ
@author Inacio Luiz Kolling
@since 09/11/99
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA401GRA()

	m->TJ_ORDEM := STJ->TJ_ORDEM
	m->TJ_PLANO := STJ->TJ_PLANO
	m->TL_ORDEM := STJ->TJ_ORDEM
	m->TL_PLANO := STJ->TJ_PLANO
	nSEQSTL := UltSeq(Recno())
	// GRAVA NO ARQUIVO STL )
	STL4011(m->TJ_ORDEM,m->TJ_PLANO,nSEQSTL)
	dbSelectArea('STJ')
	dbsetorder(1)

	If dbseek(xFilial("STJ")+m->TJ_ORDEM+m->TJ_PLANO)
		RecLock('STJ',.F.)
		STJ->TJ_DTMPFIM := MAX(STJ->TJ_DTMPFIM,STL->TL_DTFIM)
		If STJ->TJ_DTMPFIM = STJ->TJ_DTMPINI
			If STL->TL_HOFIM > STJ->TJ_HOMPFIM
				STJ->TJ_HOMPFIM := STL->TL_HOFIM
				STJ->TJ_HOMPINI := STL->TL_HOINICI
			Endif
		Else
			If Empty(STJ->TJ_HOMPFIM)
				STJ->TJ_HOMPFIM := STL->TL_HOFIM
			EndIf
		Endif
		cACODBEM := STJ->TJ_CODBEM
		MsUnLock("STJ")

		//+-------------------------------------------------------------------+
		lSTJAchou  := A401STJBUS(cACODBEM)

		dbSelectArea("ST9")
		dbSetOrder(1)

		If dbSeek(xFilial("ST9")+cACODBEM)
			RecLock("ST9",.F.)

			If lSTJAchou = .F.
				ST9->T9_TERCEIR := "1"
			EndIf

			MsUnlock("ST9")
		Endif

		//+-------------------------------------------------------------------+
		//| atualiza dados da OS -- desconsidera retorno					  |
		//| (o maximo que pode acontecer eh nao atualizar a OS)				  |
		//+-------------------------------------------------------------------+

		If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"  //Mensagem Unica
			NGMUMntOrd(STJ->(RecNo()),3)
		EndIf

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA401STJ
Gera ordem de servico ( STJ )
@author Inacio Luiz Kolling
@since 09/11/99
@version undefined
@param cORDEM, characters
@param cPLANO, characters
@param cOSTIPO, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGA401STJ(cORDEM,cPLANO,cOSTIPO)

	Local cAli := Alias(), nOrd := indexord(), nRec := REcno()
	Local lMMoeda := NGCADICBASE("TL_MOEDA","A","STL",.F.)
	Local lIntTEC := .F.

	DbSelectArea('TEW')
	lIntTEC := FindFunction("At040ImpST9") .And. ( TEW->(FieldPos('TEW_TPOS')) > 0 )

	If cOSTIPO == 1
		If Empty(cPRIMOSN)
			Store cORDEM To cPRIMOSN,cULTIOSN
		Endif
		cPRIMOSN := StrZero(MIN(Val(cORDEM),Val(cPRIMOSN)),6)
		cULTIOSN := StrZero(MAX(Val(cORDEM),Val(cULTIOSN)),6)

		If Empty(dPRIMOSN)
			Store aCols[XX][nDATGD] To dPRIMOSN,dULTIOSN
		Endif
		dPRIMOSN := MIN(aCols[XX][nDATGD],dPRIMOSN)
		dULTIOSN := MAX(aCols[XX][nDATGD],dULTIOSN)

		dbSelectArea( 'STJ' )

		RecLock( 'STJ', .T. )
		
			STJ->TJ_FILIAL   := FWxFilial( 'STJ' )
			STJ->TJ_ORDEM    := cORDEM
			STJ->TJ_PLANO    := cPLANO
			STJ->TJ_CODBEM   := aCols[XX][nBEMGD]
			STJ->TJ_TIPOOS   := "B"
			STJ->TJ_SERVICO  := cSERVICO
			STJ->TJ_SEQRELA  := If(coscor = 1,'000','001')
			STJ->TJ_DTORIGI  := aCols[XX][nDATGD]
			STJ->TJ_TIPO     := ST4->T4_TIPOMAN
			STJ->TJ_SITUACA  := "L"
			STJ->TJ_TERMINO  := "N"
			STJ->TJ_CODAREA  := ST4->T4_CODAREA
			STJ->TJ_CCUSTO   := ST9->T9_CCUSTO
			STJ->TJ_CENTRAB  := ST9->T9_CENTRAB
			STJ->TJ_DTMPINI  := aCols[XX][nDATGD]
			STJ->TJ_HOMPINI  := TIME()
			STJ->TJ_USUARIO  := If(Len(STJ->TJ_USUARIO) > 15,cUsername,Substr(cUsuario,7,15))
			STJ->TJ_PRIORID  := ST9->T9_PRIORID
			STJ->TJ_LUBRIFI  := "N"
			STJ->TJ_TIPORET  := "S"
			STJ->TJ_TERCEIR  := '1'

			If aCols[XX,nPO1GD] > 0

				STJ->TJ_POSCONT := aCols[xx,nPO1GD]
				STJ->TJ_HORACO1 := aCols[xx,nPosHrCnt1]

			EndIf

			If aCols[XX,nPO2GD] > 0

				STJ->TJ_POSCON2 := aCols[xx,nPO2GD]
				STJ->TJ_HORACO2 := aCols[xx,nPosHrCnt2]

			EndIf

			If lMMoeda
			
				STJ->TJ_MOEDA  := '1'
			
			EndIf

		MsUnLock()

		If lIntTEC
			At800OsxTec( .F. /*Exclusão?*/ )
		EndIf

		If AllTrim(GetMV("MV_NGMNTPC")) = "S"
			cCODPRO := If(FindFunction("NGProdMNT"), NGProdMNT("M")[1], GetMv("MV_PRODMNT")) //Ira verificar apenas o primeiro Produto Manutencao do parametro
			cOP     := STJ->TJ_ORDEM + "OS001"
			GERAOP(cCODPRO, 1, cOP, STJ->TJ_DTORIGI,STJ->TJ_DTORIGI)
			//-- Grava os Campos Especificos na OP
			DbSelectArea('SC2')
			RecLock('SC2', .F.)
			SC2->C2_CC      := st9->t9_CCUSTO
			SC2->C2_EMISSAO := MNT420DTOP(STJ->TJ_DTMPINI)
			SC2->C2_STATUS  := 'U'
			SC2->C2_OBS     := 'PLANO '+stj->tj_plano
			MsUnlock('SC2')
		Endif

	EndIf
	Dbselectarea(cAli)
	Dbsetorder(nOrd)
	Dbgoto(nRec)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} STL4011
Grava no STL
@author Inacio Luiz Kolling
@since 09/11/99
@version undefined
@param cORDEM, characters
@param cPLANO, characters
@param nSEQUENC, numeric
@type function
/*/
//---------------------------------------------------------------------
Function STL4011(cORDEM,cPLANO,nSEQUENC)

	Local lDTHORFI   := .T.
	Local aCposAlter := {}
	Local nPosCpo    := 0
	Local cItemCta   := ""
	Local nI
	Local cDocumSD3
	Local cBem := NGSEEK("STJ",cORDEM,1,"TJ_CODBEM")
	Local lMMoeda := NGCADICBASE("TL_MOEDA","A","STL",.F.)

	If NGCADICBASE("T9_ITEMCTA","A","ST9",.F.)
		cItemCta := NGSEEK("ST9",STJ->TJ_CODBEM,1,"T9_ITEMCTA")
	EndIf

	If ExistBlock("NG401CPU")
		aCposAlter := ExecBlock("NG401CPU",.F.,.F.)
	EndIf

	If !Empty( aBEMRET[xx] ) .And. !Empty( aCols[xx,nDATAF] )

		If !Empty( aCols[xx,nPO1GD] ) .And. AllTrim( aCols[xx,nPosHrCnt1] ) != ':'
			
			NGTRETCON( aBEMRET[xx], aCols[xx,nDATAF], aCols[xx,nPO1GD], aCols[xx,nPosHrCnt1], 1, , .T. )
			lDTHORFI := .F.

		EndIf

		If !Empty( aCols[xx,nPO2GD] ) .And. AllTrim( aCols[xx,nPosHrCnt2] ) != ':'

			NGTRETCON( aBEMRET[xx], aCols[xx,nDATAF], aCols[xx,nPO2GD], aCols[xx,nPosHrCnt2], 2, , .F. )

		EndIf

	EndIf

	NGA4015()

	DbSelectArea('STL')
	RecLock('STL',.T.)

	stl->tl_filial  := xfilial("STL")
	stl->tl_ordem   := cORDEM
	stl->tl_plano   := cPLANO
	stl->tl_tarefa  := cTarefa
	stl->tl_tiporeg := M->TL_TIPOREG
	stl->tl_codigo  := M->TL_CODIGO
	stl->tl_usacale := aCols[xx][nUSACA]
	stl->tl_seqrela := nSEQUENC
	stl->tl_quantid := aCols[xx][nQUTGD]
	stl->tl_unidade := aCols[xx][nUNIGD]
	stl->tl_destino := If (cTipoIns == STR0023,cDESTINO,Space(1))
	stl->tl_dtinici := aCols[xx][nDATGD]
	stl->tl_hoinici := aCols[xx][nHORAI]
	stl->tl_dtfim   := If(stl->tl_tiporeg = "P",stl->tl_dtinici,aCols[xx][nDATAF])
	stl->tl_hofim   := If(stl->tl_tiporeg = "P",stl->tl_hoinici,aCols[xx][nHORAF])
	stl->tl_garanti := 'N'
	stl->tl_tipohor := If(stl->tl_usacale = "S","S",Alltrim(GetMv("MV_NGUNIDT")))
	stl->tl_localiz := aCols[xx][nLOCALI]
	stl->tl_numseri := aCols[xx][nNUMSEI]
	STL->TL_QUANREC := nQuanRec

	If STL->TL_TIPOREG = 'P'
		STL->TL_LOCAL := If(Empty(aCols[xx][nLOCAL]),;
		NGALMOXA(STJ->TJ_CODBEM,STL->TL_CODIGO,STL->TL_TIPOREG,.T.),;
		aCols[xx][nLOCAL])
		cLocal := STL->TL_LOCAL
	Endif

	If cGERAEST  = 1 .And. STL->TL_TIPOREG = "P" .And. Rastro(M->TL_CODIGO)
		STL->TL_LOTECTL := aCols[xx][nLOTEC]
		STL->TL_NUMLOTE := aCols[xx][nNUMLO]
		STL->TL_DTVALID := aCols[xx][nDTVAL]
	EndIf

	//Grava os campos de usuario
	If Len(aCposAlter) > 0
		For nI := 1 To Len(aCposAlter)
			nPosCpo := Ascan(aHeader,{|x| AllTrim(x[2])==aCposAlter[nI]})
			STL->(FieldPut(FieldPos(aCposAlter[nI]),aCols[xx][nPosCpo]))
		Next nI
	EndIf

	If cGERAEST == 1 // GERA ESTOQUE

		If cTIPOINS <> STR0026 //"Ferramenta"

			cNUMSEQ := MNTGERAD3("RE0")

			If NGPRODESP(SD3->D3_COD,.F.,"M")
	    		 NGAtuErp("SD3","INSERT")
			EndIf

			If LOCALIZA(M->TL_CODIGO) .AND. SD3->D3_TM > '500'
				RecLock("SD3",.F.)
				SD3->D3_LOCALIZ := stl->tl_localiz
				SD3->D3_NUMSERI := stl->tl_numseri
				MsUnLock("SD3")
			EndIf

			If NGPRODESP(SD3->D3_COD,.F.,"M")
				NGAtuErp("SD3","INSERT")
			EndIf

			//+-------------------------------------------------------------------+
			//| Pega os 5 custos medios atuais             						  |
			//+-------------------------------------------------------------------+
			aCM := PEGACMATU(SD3->D3_COD,SD3->D3_LOCAL)
			//+-------------------------------------------------------------------+
			//| Grava o custo da movimentacao              						  |
			//+-------------------------------------------------------------------+
			aCUSTO := GRAVACUSD3(aCM)
			//+-------------------------------------------------------------------+
			//| Atualiza o saldo atual (VATU) com os dados do SD3     			  |
			//+-------------------------------------------------------------------+

			//+-------------------------------------------------------------------+
			//| MNTGERAD3 JA ATUALIZOU O SALDO									  |
			//+-------------------------------------------------------------------+
			C2ATUCOMD3(aCUSTO)

			RecLock('STL',.F.)
			STL->TL_NUMSEQ := cNUMSEQ
			STL->TL_CUSTO  := SD3->D3_CUSTO1
			If lMMoeda
				STL->TL_MOEDA  := "1"
			Endif
		EndIf
	Else
		nCusto := If(!Empty(nVALGD),aCols[xx][nVALGD],0)
		stl->tl_custo := nCusto
		If lMMoeda
			STL->TL_MOEDA := If(nMOEDA > 0,aCols[xx][nMOEDA],"1")
		Endif
	Endif
	MsUnLock("STL")

	If ExistBlock("MNTA4011")
		ExecBlock("MNTA4011",.F.,.F.)
	Endif
	//+-------------------------------------------------------------------+
	//| GERA O.S AUTOMATICA POR CONTADOR								  |
	//+-------------------------------------------------------------------+
	If (cGERAPREV = "S" .Or. cGERAPREV = "C") .And. (!Empty(aCOLS[xx][nPO1GD]) .Or. !Empty(aCOLS[xx][nPO2GD]))
		If NGCONFOSAUT(cGERAPREV)
			NGGEROSAUT(aBEMRET[xx],If(!Empty(aCOLS[xx][nPO1GD]),aCOLS[xx][nPO1GD],aCOLS[xx][nPO2GD]))
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA401LOK
Critica se a linha digitada esta' Ok
@author Inacio Luiz Kolling
@since XX/XX/XXXX
@version undefined
@param o, object
@type function
/*/
//---------------------------------------------------------------------
FUNCTION MNTA401LOK(o)

	Local lRET   := .T.,nx1 := 0
	Local lTEMBE := .F.
	Local aBEMCX := {}
	Local cMENSA := Space(1)
	Local cMENHL := Space(1)
	Local cMENS1 := STR0050
	Local cMENS2 := STR0051
	Local lCONT1 := TipoAcom
	Local lCONT2 := TipoAcom2,xw,ww,rr,nz
	//Variáveis de verificação das O.S.'s
	Local cOrdem := Space(6)
	Local cAlias := GetNextAlias()
	Local cQry   := ""
	Local vx

	Local aAreaXXX := GetArea()
	Local oTmpTbl1
	Private cTRBZ := GetNextAlias()

	//Valida o tipo de insumo terceiro
	If !NGVALTERC(If(cTIPOINS == STR0024,"T","N"),If(cGERAEST = 1,"S","N"))
		Return .F.
	EndIf

	If !aCOLS[n][Len(aCOLS[n])]
		If Empty(aCOLS[n][nDATGD])
			lRET   := .F.
			cMENHL := "DATAIMPLAN"
		EndIf
		If Empty(aCOLS[n][nDATGD])
			cMENSA := STR0078// "Data de Emissao nao informada"
			lRET   := .F.
		EndIf

		If lRET
			If Empty(aCOLS[n][nHORAI]) .Or. Alltrim(aCOLS[n][nHORAI]) = ":"
				cMENSA := STR0079 //"Hora inicio nao informada"
				lRET   := .F.
			EndIf
		EndIf

		If Empty(aCOLS[1][nQUTGD])
			MsgInfo(STR0110,STR0036) //"O campo Quantidade é obrigatório."###"ATENÇÃO"
			Return .F.
		EndIf

		If !NGVDTINS(M->TL_CODIGO,aCols[n][nDATGD],aCols[n][nHORAI],aCols[n][nDATAF],aCols[n][nHORAF],SubStr(cTipoIns,1,1))
			Return .F.
		EndIf
		If M->TL_TIPOREG = "P"
			If lRET
				If Empty(aCOLS[n][nQUTGD])
					lRET   := .F.
					cMENHL := "QUANTIDADE"
				EndIf

				If lRET

					If cGERAEST = 1
						//Valida saldo(SB8) de controle de rastreabilidade por lote do produto
						If Rastro(M->TL_CODIGO)

							If Rastro(M->TL_CODIGO,"S")
								//Valida o sub-lote
								If Empty(aCOLS[n][nNUMLO])
									Help(" ",1,"NGATENCAO",,STR0088+Str(n,3),3,1)  //"Numero do sub-lote não informado item "
									Return .F.
								Else
									DbSelectArea("SB8")
									DbSetOrder(02)
									If DbSeek(xFilial("SB8")+aCOLS[n][nNUMLO]+aCOLS[n][nLOTEC]+M->TL_CODIGO+aCOLS[n][nLOCAL])
										nSaldoLote := SB8Saldo(.F.,!Empty(aCOLS[n][nLOTEC]+aCOLS[n][nNUMLO]),NIL,NIL,NIL,NIL,NIL,aCOLS[n][nDATGD])
										If QtdComp(nSaldoLote) < QtdComp(aCOLS[n][nQUTGD])
											cHelp:=OemToAnsi(STR0080)+AllTrim(M->TL_CODIGO)+OemToAnsi(STR0081)+aCOLS[n][nLOCAL]+OemToAnsi(STR0082); //"Produto "#" Local "#" Saldo Disponivel "
											+Alltrim(Transform(nSaldoLote,PesqPictQt("B8_SALDO", 14)))+OemToAnsi(STR0083)+Alltrim(aCOLS[n][nLOTEC]);  //" Lote "
											+OemToAnsi(STR0090)+Alltrim(aCOLS[n][nNUMLO])  //"Sub-lote"
											Help(" ",1,"A240LOTENE",,cHelp,4,1)
											Return .F.
										EndIf
									Else
										Help(" ",1,"NGATENCAO",,STR0084+Chr(13)+Chr(10)+; //"Numero do sub-lote não corresponde ao produto que foi "
										STR0085,3,1) //" informado. Digite um sub-lote correspondente."
										Return .F.
									EndIf
								EndIf
							Else
								//Valida o lote
								If Empty(aCOLS[n][nLOTEC])
									Help(" ",1,"NGATENCAO",,STR0089+Str(n,3),3,1) //"Numero do lote não informado item "
									Return .F.
								Else
									DbSelectArea("SB8")
									DbSetOrder(03)
									If DbSeek(xFilial("SB8")+M->TL_CODIGO+aCOLS[n][nLOCAL]+aCOLS[n][nLOTEC])
										nSaldo:=SaldoLote(M->TL_CODIGO,aCOLS[n][nLOCAL],aCOLS[n][nLOTEC],NIL,.F.,!Empty(aCOLS[n][nLOTEC]+aCOLS[n][nNUMLO]),NIL,aCOLS[n][nDATGD])
										cHelp:=OemToAnsi(STR0080)+AllTrim(M->TL_CODIGO)+OemToAnsi(STR0081)+aCOLS[n][nLOCAL]+OemToAnsi(STR0082);//"Produto "#" Local "#" Saldo Disponivel "
										+Alltrim(Transform(nSaldo,PesqPictQt("B8_SALDO", 14)))+OemToAnsi(STR0083)+Alltrim(aCOLS[n][nLOTEC]) //" Lote "
										If QtdComp(nSaldo) < QtdComp(aCOLS[n][nQUTGD])
											Help(" ",1,"A240LOTENE",,cHelp,4,1)
											Return .F.
										EndIf
									Else
										Help(" ",1,"NGATENCAO",,STR0086+Chr(13)+Chr(10)+; //"Numero do lote não corresponde ao produto que foi "
										STR0087,3,1)  //" informado. Digite um lote correspondente."
										Return .F.
									EndIf
								EndIf
							EndIf
						EndIf

						// VALIDA SE O PRODUTO NO LOCAL INFORMADO ENCONTRA-SE EM PROCESSO DE INVENTÁRIO.
						If cUsaInt3 == 'S' .And. nLOCAL > 0 .And. BlqInvent( M->TL_CODIGO, aCols[n][nLOCAL] )

							Help( '', 1, 'BLQINVENT' )
							Return .F.

						EndIf

						If LOCALIZA(Trim(M->TL_CODIGO))
							//Valida a obrigatoriedade de informar o enderecamento fisico se o produto
							//tem o controle
							If Empty(ACOLS[n,nLOCALI]) .And. Empty(ACOLS[n,nNUMSEI])
								Help(" ",1,"LOCALIZOBR")
								Return .F.
							ElseIf Empty(ACOLS[n,nLOCALI])
								Help(" ",1,"LOCALIZOBR")
								Return .F.
							EndIf

							//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
							If !MtAvlNSer(M->TL_CODIGO,ACOLS[n,nNUMSEI],ACOLS[n,nQUTGD])
								Return .F.
							EndIf

							cLOC := aCols[n][nLOCAL]   // Local/almoxarifado
							cLOL := aCols[n][nLOCALI]  // Localizacao fisica
							cCOD := M->TL_CODIGO       // Codigo
							cNUS := aCols[n][nNUMSEI]  // Numero da serie
							cSBL := aCols[n][nNUMLO]   // Numero do lote
							nQTD := aCols[n][nQUTGD]   // Quantidade
							cLOT := aCols[n][nLOTEC]   // lotectla

							If (!Empty(cLOC) .Or. !Empty(cNUS)) .And.;
							QtdComp(SaldoSBF(cLOC,cLOL,cCOD,cNUS,cLOT,cSBL,.F.)) < QtdComp(nQTD)
								Help(" ",1,"SALDOLOCLZ")
								Return .F.
							EndIf

						EndIf

					EndIf
				EndIf
			EndIf
		Else
			If Empty(aCOLS[n][nQUTGD])
				lRET   := .F.
				cMENHL := "QUANTIDADE"
			EndIf
		EndIf

		If lRET
			If cTipoIns == STR0023
				If cGERAEST = 1 // GERA ESTOQUE
					If !NGCHKMESFE(aCOLS[n,nDATGD],"P")
						lRET := .F.
						Return .f.
					EndIf
				EndIf
			EndIf
		EndIf
		If lRET
			If M->TL_TIPOREG <> "P"
				If !NGDATHORIF(aCOLS[n][nDATGD],aCOLS[n][nHORAI],;
				aCOLS[n][nDATAF],aCOLS[n][nHORAF],n)
					Return .f.
				EndIf

				If !NGSTLHORFI()
					Return .f.
				EndIf

				//Valida afastamentos da mao de obra no RH
				If M->TL_TIPOREG == "M"
					If !NGFUNCRH(M->TL_CODIGO,.T.,aCOLS[n][nDATAF])
						Return .F.
					EndIf
					If !NGFRHAFAST(M->TL_CODIGO,aCOLS[n][nDATGD],aCOLS[n][nDATAF],.T.)
						Return .F.
					EndIf
					If !NG401SOBHR(SubStr(cTipoIns,1,1),M->TL_CODIGO,nDATGD,nHORAI,nDATAF,nHORAF)
						Return .F.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	If dDataBase == aCOLS[n][nDATAF] .And. !Empty(M->TL_HOFIM) .And. !Empty(aCOLS[n][nHORAI]) .And. HTOM(aCOLS[n][nHORAF]) > HTOM(Substr(Time(),1,5))
		MsgStop(STR0112) //"Hora fim não pode ser maior que a hora atual."
		Return .F.
	EndIf

	aBEMRET := {}

	If !lRET
		If !Empty(cMENHL)
			HELP(" ",1,cMENHL)
		Else
			MsgInfo(cMENSA,STR0036)
		Endif
		TipoAcom  := lCONT1
		TipoAcom2 := lCONT2
	Else
		
		For xw := 1 To Len(aCOLS)
			
			cBEMFIM := space(len(stj->tj_codbem))
			
			If !aCols[xw][Len(aCols[xw])]
				If cGERAEST = 2 .And. nVALGD > 0
					If Empty(aCOLS[xw][nVALGD]) .AND. xw == n
						MsgInfo(STR0047+' '+STR0033+' '+STR0052+' '+Str(xw,2))
						lRET := .F.
						Exit
					Endif
				Endif

				nPOS := Ascan(aBEMCX,{|x| x[1] = aCOLS[xw][nBEMGD]})
				TipoAcom  := .f.
				TipoAcom2 := .f.
				If nPOS = 0
					cTIPOCON := " "
					cBEMRET  := aCOLS[xw][nBEMGD]
					cTIPOCON := NGSEEK("ST9",cBEMRET,1,"T9_TEMCONT")
					TIPOACOM := If(cTIPOCON = "S",.T.,.F.)

					//FindFunction remover na release GetRPORelease() >= '12.1.027'
					If FindFunction("MNTCont2")
						TIPOACOM2 := MNTCont2(xFilial('TPE'), cBEMRET)
					Else
						DbSelectArea("TPE")
						DbSetOrder(01)
						TIPOACOM2 := DbSeek(xFILIAL("TPE")+cBEMRET)
					Endif

					cBEMFIM := cBEMRET
					Aadd(aBEMCX,{aCOLS[xw][nBEMGD],TipoAcom,TipoAcom2})
					nINCRE := Len(aBEMCX)
				Else
					nINCRE    := nPOS
					cBEMFIM   := aBEMCX[nINCRE][1]
					TipoAcom  := aBEMCX[nINCRE][2]
					TipoAcom2 := aBEMCX[nINCRE][2]
				Endif

				cMENSA := Space(1)

				/*-----------+
				| Contador 1 |
				+-----------*/
				If aBEMCX[nINCRE,2] .And. !Empty( aCols[xw,nPO1GD] )

					If Empty( aCols[xw,nPO1GD] ) .Or. Empty( aCols[xw,nDATAF] ) .Or.;
						AllTrim( aCols[xw,nPosHrCnt1] ) == ':'
						
						cMENSA := STR0050 + ' 1 ' + STR0051
					
					EndIf

				EndIf

				/*-----------+
				| Contador 2 |
				+-----------*/
				If aBEMCX[nINCRE][3] .And. !Empty(aCols[xw][nPO2GD])

					If Empty( aCols[xw,nPO2GD] ) .Or. Empty( aCols[xw,nDATAF] ) .Or.;
						AllTrim( aCols[xw,nPosHrCnt2] ) == ':'

						cMENSA := STR0050 + ' 2 ' + STR0051

					EndIf

				EndIf

				If !Empty(cMENSA)
					MsgInfo(cMENSA,STR0036)
					lRET := .F.
					Exit
				Else
					lTEMBE := .T.
				Endif

				If aBEMCX[nINCRE][2] .And. !Empty(aCols[xw][nPO1GD])

					If !NGCHKHISTO( aBEMCX[nINCRE,1], aCols[xw,nDATAF], aCols[xw,nPO1GD],;
						aCols[xw,nPosHrCnt1], 1, xw, .T. )

						lRET := .F.
						Exit

					EndIf

					If !NGVALIVARD( aBEMCX[nINCRE,1], aCols[xw,nPO1GD], aCols[xw,nDATAF],;
						aCols[xw,nPosHrCnt1], 1, .T., xw )

						lRET := .F.
						Exit

					EndIf

				EndIf

				If aBEMCX[nINCRE][3] .And. !Empty(aCols[xw][nPO2GD])

					If !NGCHKHISTO( aBEMCX[nINCRE,1], aCols[xw,nDATAF], aCols[xw,nPO2GD],;
						aCols[xw,nPosHrCnt2], 2, xw, .T. )

						lRET := .F.
						Exit

					EndIf

					If !NGVALIVARD( aBEMCX[nINCRE,1], aCols[xw,nPO2GD], aCols[xw,nDATAF],;
						aCols[xw,nPosHrCnt2], 2, .T., xw )

						lRET := .F.
						Exit

					EndIf

				EndIf

			EndIf

			aAdd( aBEMRET, cBEMFIM )

		Next xw

		If lRET .And. lTEMBE .And. Len(aCOLS) > 1
			If Select(cTRBZ) > 0

				oTmpTbl1:Delete() //Deleta Tab. Temporária 1

			Endif

			aDBF := {}
				Aadd(aDBF,{"TRB_BEM"   ,"C",16,0})
				Aadd(aDBF,{"TRB_DATA1" ,"D",08,0})
				Aadd(aDBF,{"TRB_CONT1" ,"N",09,0})
				Aadd(aDBF,{"TRB_HORA1" ,"C",05,0})
				Aadd(aDBF,{"TRB_DATA2" ,"D",08,0})
				Aadd(aDBF,{"TRB_CONT2" ,"N",09,0})
				Aadd(aDBF,{"TRB_HORA2" ,"C",05,0})
				Aadd(aDBF,{"TRB_ITEM"  ,"N",03,0})

			//Cria Tabela Temporária
			oTmpTbl1 := NGFwTmpTbl(cTRBZ, aDBF, {{"TRB_BEM"}})

			For ww := 1 To Len(aCOLS)

				If !aCols[ww][Len(aCols[ww])]

					If !Empty( aCols[ww,nPO1GD] ) .And. !Empty( aCols[ww,nDATAF] ) .And.;
						AllTrim( aCols[ww,nPosHrCnt1] ) != ':'

						RecLock( (cTRBZ), .T. )
							
						(cTRBZ)->TRB_BEM   := aCOLS[ww][nBEMGD]
						(cTRBZ)->TRB_DATA1 := aCOLS[ww][nDATAF]
						(cTRBZ)->TRB_CONT1 := aCOLS[ww][nPO1GD]
						(cTRBZ)->TRB_HORA1 := aCols[ww,nPosHrCnt1]
						(cTRBZ)->TRB_DATA2 := aCOLS[ww][nDATAF]
						(cTRBZ)->TRB_CONT2 := aCOLS[ww][nPO2GD]
						(cTRBZ)->TRB_HORA2 := aCols[ww,nPosHrCnt2]
						(cTRBZ)->TRB_ITEM  := ww

						MsUnlock()

					EndIf

				EndIf

			Next ww
			
			Dbselectarea(cTRBZ)
			Dbgotop()
			If reccount() > 1
				While !Eof()
					cBEMTRB := (cTRBZ)->TRB_BEM
					aARTRB1 := {}
					aARTRB2 := {}
					lPROBLE := .F.
					lCONTDO := .F.
					While !Eof() .And. (cTRBZ)->TRB_BEM = cBEMTRB
						Aadd(aARTRB1,{(cTRBZ)->TRB_DATA1,(cTRBZ)->TRB_CONT1,(cTRBZ)->TRB_HORA1,(cTRBZ)->TRB_ITEM})
						If !Empty((cTRBZ)->TRB_DATA2) .And. !Empty((cTRBZ)->TRB_CONT2) .And. Alltrim((cTRBZ)->TRB_HORA2) <> ':'
							Aadd(aARTRB2,{(cTRBZ)->TRB_DATA2,(cTRBZ)->TRB_CONT2,(cTRBZ)->TRB_HORA2,(cTRBZ)->TRB_ITEM})
							lCONTDO := .t.
						Endif
						Dbskip()
					End

					nVINCR := If(lCONTDO,2,1)

					// TESTA DATA E CONTADOR MENOR
					For nz := 1 To nVINCR
						aARGERAL := If(nz = 1,Aclone(aARTRB1),Aclone(aARTRB2))
						nCONTDOR := If(nz = 1,1,2)

						If Len(aARGERAL) > 1
							aARTRBB := {}
							// ORDENAR A MATRIZ POR BEM DATA E HORA
							aARTRBB := Asort(aARGERAL,,,{|x,y| Dtos(x[1])+x[3] <= Dtos(y[1])+y[3]})
							dDATFF := aARTRBB[1][1]
							nCONTF := aARTRBB[1][2]
							cHORAF := aARTRBB[1][3]
							nITEMF := aARTRBB[1][4]
							For rr := 2 To Len(aARTRBB)
								If aARTRBB[rr][2] < nCONTF;
								.Or. (aARTRBB[rr][1] = dDATFF .And. aARTRBB[rr][3] = cHORAF)
									MsgInfo(STR0053+' '+Str(nCONTDOR,2)+' '+STR0054+' '+Str(aARTRBB[rr][4],3)+chr(13)+chr(13);
									+STR0055+Alltrim(cBEMTRB)+chr(13);
									+STR0056+dtoc(aARTRBB[rr][1])+chr(13);
									+STR0058+Str(aARTRBB[rr][2],9)+chr(13);
									+STR0057+Substr(aARTRBB[rr][3],1,5)+chr(13)+chr(13);
									+STR0059+Str(nITEMF,3)+chr(13);
									+STR0060+chr(13);
									+STR0061+Dtoc(dDATFF)+chr(13);
									+STR0062+str(nCONTF,9)+chr(13);
									+STR0063+Substr(cHORAF,1,5)+chr(13)+chr(13);
									+STR0064+chr(13);
									+STR0065+chr(13);
									+STR0066+chr(13);
									+STR0067,STR0048)

									oTmpTbl1:Delete() //Deleta Tab. Temporária 1

									Dbselectarea("ST9")
									Return .F.
								Endif
								dDATFF := aARTRBB[rr][1]
								nCONTF := aARTRBB[rr][2]
								cHORAF := aARTRBB[rr][3]
								nITEMF := aARTRBB[rr][4]
							Next rr

						Endif
					Next nz

					Dbselectarea(cTRBZ)
				End
			Endif
			If Select(cTRBZ) > 0
				oTmpTbl1:Delete() //Deleta Tab. Temporária 1
			Endif
		Endif
	Endif
	nQUATOT := 0.00
	For nx1 := 1 to len(aCols)
		If !aCols[nx1][Len(aCols[nx1])]
			nCusto := If(!Empty(nVALGD),aCols[nx1][nVALGD],0)
			nQUATOT := nQUATOT + nCusto
			aCols[nx1][nTOCUS] := nQUATOT
		Endif
	Next nx1

	Dbselectarea("ST9")
	If cTIPO_OS == 2 .And. cFECHA = 1 .And. NGFUNCRPO("NGRESPETAEX",.F.) .and. lRET
		For nx1 := 1 to len(aCols)
			If !aCols[nx1][Len(aCols[nx1])]
				lACHOU  := .F.
				cOrdem  := Space(6)
				cQry := " SELECT STJ.TJ_ORDEM AS ORDEM FROM "+RetSqlName("STJ")+" STJ WHERE STJ.TJ_SITUACA = 'L' AND STJ.TJ_TERMINO = 'N' "
				cQry += " AND STJ.TJ_TIPOOS = 'B' AND STJ.TJ_CODBEM = "+ValToSql(aCols[nx1][nBEMGD])
				cQry += " AND STJ.TJ_FILIAL = "+ValToSql(xFilial("STJ"))+" AND STJ.TJ_SERVICO = "+ValToSql(cSERVICO)
				cQry := ChangeQuery(cQry)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQry),(cAlias), .T., .T.)
				dbSelectArea(cAlias)
				dbGoTop()
				While (cAlias)->(!Eof())
					lACHOU := .T.
					cOrdem := (cAlias)->ORDEM
					Exit
				EndDo
				(cAlias)->(dbCloseArea())
				If lACHOU .and. !Empty(cOrdem)
					If !NGRESPETAEX(cOrdem,.T.)
						Return .f.
					Endif
				Endif
			Endif
		Next nx1
	Endif

	// Valida se a data de baixa de estoque é maior que a data de bloqueio de estoque (MNTA401LOK)
	If Substr(CTIPOINS,1,1) <> "F"
		If !MNTValDBl(aCols[n][nDATGD])
			Return .F.
		EndIf
	EndIf

	RestArea(aAreaXXX)

Return lRET

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡Æo    ³MNTA401TOK³ Autor ³ In cio Luiz Kolling   ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Critica se a nota toda esta' Ok                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA401TOK
 Critica se a nota toda esta' Ok
@author Inacio Luiz Kolling
@since XX/XX/XXXX
@version undefined
@param o, object
@type function
/*/
//---------------------------------------------------------------------
Function MNTA401TOK(o)

	Local nx,ny,cTIPFIM := Upper(Alltrim(STR0023))
	Local nTOTQUAND  := 0.0
	Local aINSALMOX  := {}, aINSALRAST := {}
	Local cLOCALALM
	Local lESTNEGA := If(AllTrim(GETMV("MV_ESTNEG")) == 'S',.T.,.F.)
	Local lVALRAST := If(Upper(Alltrim(cTIPOINS)) = cTIPFIM .And. Rastro(M->TL_CODIGO),.T.,.F.)
	Local aLocFi   := {}

	//Variáveis de verificação das O.S.'s
	Local cOrdem := Space(6)
	Local cAlias := GetNextAlias()
	Local cQry   := ""

	If Empty(cTIPODAT) .or. Empty(dDATAFIX) .or. Empty(cTIPO_OS) .or.;
	Empty(cTIPOINS) .or. Empty(M->TL_CODIGO) .or.;
	(cTIPOINS == STR0023 .and. Empty(cDESTINO))
		Help(" ",1,"OBRIGCAMPO")
		Return .f.
	Endif

	OldAli := Alias()
	tam    := 6
	If cTIPOINS = STR0023
		cXCODIGO := M->TL_CODIGO
	Else
		cXCODIGO := SUBSTR(M->TL_CODIGO,1,tam)
	Endif

	dbSelectArea(aalias)
	dbSetOrder(01)
	If !DbSeek(xFilial(aalias) + cXCODIGO)
		Help(" ",1,"CODINUSMON")
		DbSelectArea(OldAli)
		Return .F.
	Endif

	//Valida o campo quantidade de recurso.
	If !fQuanRec()
		Return .F.
	EndIf

	For nx := 1 to len(aCols)
		If !aCols[nx][Len(aCols[nx])]
			If Empty(aCols[nx][nDATGD])
				Help(" ",1,"DATAIMPLAN")
				Return .f.
			Endif
			cUNID := ALLTRIM(aCols[nx][nUNIGD])
			If Upper(Alltrim(cTIPOINS)) = cTIPFIM
				If cUNID <> ALLTRIM(SB1->B1_UM)
					Help(" ",1,"UNIDADEINS")
					DbSelectArea(OldAli)
					Return .F.
				Endif
				If cGERAEST = 1 // GERA ESTOQUE
					If !NGCHKMESFE(aCOLS[nx,nDATGD],"P")
						Return .f.
					Endif

					cLOCALALM := aCOLS[nx][nLOCAL]
					If Empty(cLOCALALM)
						cLOCALALM := NGALMOXA(aCols[nx][1],M->TL_CODIGO,"P",.T.)
						If Empty(cLOCALALM)
							DbSelectArea("SB1")
							DbSetOrder(1)
							If DbSeek(xFilial("SB1")+M->TL_CODIGO)
								cLOCALALM := SB1->B1_LOCPAD
							EndIf
						EndIf
					EndIf

					//Array para checar estoque negativo do produto
					If !lESTNEGA
						nPOS401 := Ascan(aINSALMOX,{|x| x[1]+x[2] == M->TL_CODIGO+cLOCALALM})
						If nPOS401 = 0
							Aadd(aINSALMOX,{M->TL_CODIGO,cLOCALALM,aCOLS[nx,nQUTGD],aCOLS[nx,nDATGD]})
						Else
							aINSALMOX[nPOS401][3] += aCOLS[nx,nQUTGD]
						EndIf
					EndIf

					//Valida os codigos de lote e sub-lote e grava array para checar saldos
					//por lote
					If lVALRAST
						If Rastro(M->TL_CODIGO,"S")
							If Empty(aCOLS[nx][nNUMLO])
								Help(" ",1,"NGATENCAO",,STR0088+Str(nx,3),3,1)  //"Numero do sub-lote não informado item "
								Return .F.
							EndIf

							nPOS401 := Ascan(aINSALRAST,{|x| x[1]+x[2]+x[3] == cLOCALALM+aCOLS[nx][nLOTEC]+aCOLS[nx][nNUMLO]})

						Else

							If Empty(aCOLS[nx][nLOTEC])
								Help(" ",1,"NGATENCAO",,STR0089+Str(nx,3),3,1) //"Numero do lote não informado item "
								Return .F.
							EndIf

							nPOS401 := Ascan(aINSALRAST,{|x| x[1]+x[2] == cLOCALALM+aCOLS[nx][nLOTEC]})

						EndIf

						If nPOS401 = 0
							Aadd(aINSALRAST,{cLOCALALM,aCOLS[nx][nLOTEC],aCOLS[nx][nNUMLO],aCOLS[nx][nQUTGD],aCOLS[nx][nDATGD]})
						Else
							aINSALRAST[nPOS401][4] += aCOLS[nx][nQUTGD]
							aINSALRAST[nPOS401][5] := Min(aCOLS[nx][nDATGD],aINSALRAST[nPOS401][5])
						EndIf

					EndIf
				Endif
			Else
				If !Pertence('MHDS',cUNID)
					Help(" ",1,"UNIDADEINS")
					DbSelectArea(OldAli)
					Return .F.
				Endif
			Endif
			nCusto := If(!Empty(nVALGD),aCols[nx][nVALGD],nTOTAL)
			nTOTQUAND := nTOTQUAND + nCusto

			If aCols[nx][nPO1GD] > 0
				dbSelectArea('ST9')
				dbSetOrder(01)
				DbSeek(xFilial("ST9") + aCols[nx][nBEMGD])
			Endif
		Endif

		If !NG401SOBHR(SubStr(cTipoIns,1,1),M->TL_CODIGO,nDATGD,nHORAI,nDATAF,nHORAF)
			Return .f.
		EndIf
	Next

	If !Empty(nTOTAL) .and. nTOTAL <> nTOTQUAND
		Help(" ",1,"TOTALQUANT")
		Return .f.
	Endif

	//Valida o Estoque Negativo
	If Upper(Alltrim(cTIPOINS)) = cTIPFIM
		If cGERAEST = 1  .And. !lESTNEGA
			For ny := 1 To Len(aINSALMOX)

				If !NGSALSB2(aINSALMOX[ny][1],aINSALMOX[ny][2],aINSALMOX[ny][3],,,aINSALMOX[ny][4])
					Return .F.
				EndIf

			Next
		EndIf

		//Checa Saldos por Lote
		If Len(aINSALRAST) > 0
			lTIPORAS :=  If(Rastro(M->TL_CODIGO,"S"),.T.,.F.)

			For ny := 1 To Len(aINSALRAST)
				If lTIPORAS  //Rastreabilidade por sub-lote
					DbSelectArea("SB8")
					DbSetOrder(02)
					If DbSeek(xFilial("SB8")+aINSALRAST[ny,3]+aINSALRAST[ny,2]+M->TL_CODIGO+aINSALRAST[ny,1])
						nSaldoLote := SB8Saldo(.F.,!Empty(aINSALRAST[ny,2]+aINSALRAST[ny,3]),NIL,NIL,NIL,NIL,NIL,aINSALRAST[ny,5])
						If QtdComp(nSaldoLote) < QtdComp(aINSALRAST[ny,4])
							cHelp:=OemToAnsi(STR0080)+AllTrim(M->TL_CODIGO)+OemToAnsi(STR0081)+aINSALRAST[ny,1]+OemToAnsi(STR0082); //"Produto "#" Local "#" Saldo Disponivel "
							+Alltrim(Transform(nSaldoLote,PesqPictQt("B8_SALDO", 14)))+OemToAnsi(STR0083)+Alltrim(aINSALRAST[ny,2]); //" Lote "
							+OemToAnsi(STR0090)+Alltrim(aINSALRAST[ny,3]) //" Sub-lote "
							Help(" ",1,"A240LOTENE",,cHelp,4,1)
							Return .F.
						EndIf
					Else
						Help(" ",1,"NGATENCAO",,STR0084+Chr(13)+Chr(10)+; //"Numero do sub-lote não corresponde ao produto que foi "
						STR0085,3,1) //" informado. Digite um sub-lote correspondente."
						Return .F.
					EndIf
				Else
					DbSelectArea("SB8")
					DbSetOrder(03)
					If DbSeek(xFilial("SB8")+M->TL_CODIGO+aINSALRAST[ny,1]+aINSALRAST[ny,2])
						nSaldo:=SaldoLote(M->TL_CODIGO,aINSALRAST[ny,1],aINSALRAST[ny,2],NIL,.F.,!Empty(aINSALRAST[ny,2]+aINSALRAST[ny,3]),NIL,aINSALRAST[ny,5])
						cHelp:=OemToAnsi(STR0080)+AllTrim(M->TL_CODIGO)+OemToAnsi(STR0081)+aINSALRAST[ny,1]+OemToAnsi(STR0082);//"Produto "#" Local "#" Saldo Disponivel "
						+Alltrim(Transform(nSaldo,PesqPictQt("B8_SALDO", 14)))+OemToAnsi(STR0083)+Alltrim(aINSALRAST[ny,2]) //" Lote "
						If QtdComp(nSaldo) < QtdComp(aINSALRAST[ny,4])
							Help(" ",1,"A240LOTENE",,cHelp,4,1)
							Return .F.
						EndIf
					Else
						Help(" ",1,"NGATENCAO",,STR0086+Chr(13)+Chr(10)+; //"Numero do lote não corresponde ao produto que foi "
						STR0087,3,1)  //" informado. Digite um lote correspondente."
						Return .F.
					EndIf
				EndIf
			Next
		EndIf
	EndIf

	If cGERAEST = 1 .And. cTIPOINS = STR0023 .And. LOCALIZA(Trim(M->TL_CODIGO))
		For nx := 1 to len(aCols)
			If !aCols[nx][Len(aCols[nx])]
				cLOC := aCols[nx][nLOCAL]   // Local/almoxarifado
				cLOL := aCols[nx][nLOCALI]  // Localizacao fisica
				cCOD := M->TL_CODIGO        // Codigo
				cNUS := aCols[nx][nNUMSEI]  // Numero da serie
				cSBL := aCols[nx][nNUMLO]   // Numero do lote
				nQTD := aCols[nx][nQUTGD]   // Quantidade
				cLOT := aCols[nx][nLOTEC]   // lotectla

				nPosLF := Ascan(aLocFi,{|x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6] == cLOC+cLOL+cCOD+cNUS+cLOT+cSBL})
				If nPosLF = 0
					Aadd(aLocFi,{cLOC,cLOL,cCOD,cNUS,cLOT,cSBL,nQTD})

				Else
					aLocFi[nPosLF,7] += nQTD
				EndIf
			EndIf
		Next nx

		If Len(aLocFi) > 0
			For nx := 1 To Len(aLocFi)
				//Valida a obrigatoriedade de informar o enderecamento fisico se o produto
				//tem o controle
				If Empty(aLocFi[nx,2]) .And. Empty(aLocFi[nx,4])
					Help(" ",1,"LOCALIZOBR")
					Return .F.
				ElseIf Empty(aLocFi[nx,2])
					Help(" ",1,"LOCALIZOBR")
					Return .F.
				EndIf

				//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
				If !MtAvlNSer(aLocFi[nx,3],aLocFi[nx,4],aLocFi[nx,7])
					Return .F.
				EndIf
				If (!Empty(aLocFi[nx,1]) .Or. !Empty(aLocFi[nx,4])) .And.;
				QtdComp(SaldoSBF(aLocFi[nx,1],aLocFi[nx,2],aLocFi[nx,3],aLocFi[nx,4],aLocFi[nx,5],aLocFi[nx,6],.F.)) < QtdComp(aLocFi[nx,7])
					Help(" ",1,"SALDOLOCLZ",,STR0080+" "+aLocFi[nx,3],5,1)
					Return .F.
				EndIf
			Next nx
		Endif
	Endif

	If cTIPO_OS == 2 .And. cFECHA = 1 .And. NGFUNCRPO("NGRESPETAEX",.F.)
		For nX := 1 to len(aCols)
			If !aCols[nX][Len(aCols[nX])]
				lACHOU  := .F.
				cOrdem  := Space(6)
				cQry := " SELECT STJ.TJ_ORDEM AS ORDEM FROM "+RetSqlName("STJ")+" STJ WHERE STJ.TJ_SITUACA = 'L' AND STJ.TJ_TERMINO = 'N' "
				cQry += " AND STJ.TJ_TIPOOS = 'B' AND STJ.TJ_CODBEM = "+ValToSql(aCols[nX][nBEMGD])
				cQry += " AND STJ.TJ_FILIAL = "+ValToSql(xFilial("STJ"))+" AND STJ.TJ_SERVICO = "+ValToSql(cSERVICO)
				cQry := ChangeQuery(cQry)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQry),(cAlias), .T., .T.)
				dbSelectArea(cAlias)
				dbGoTop()
				While (cAlias)->(!Eof())
					lACHOU := .T.
					cOrdem := (cAlias)->ORDEM
					Exit
				EndDo
				(cAlias)->(dbCloseArea())
				If lACHOU .and. !Empty(cOrdem)
					If !NGRESPETAEX(cOrdem,.T.)
						Return .f.
					Endif
				Endif
			Endif
		Next nX
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA4011
Programa de Validacao do Bem
@author Inacio Luiz Kolling
@since 09/11/99
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGA4011

	Store .F. To TipoAcom,TipoAcom2,lIntegr

	If !NGBEMATIV(M->TC_CODBEM)
		Return .f.
	Endif

	nSeq := If(coscor = 1,"0  ","1  ")

	If !NGMANATIV(M->TC_CODBEM,cServico,nseq)
		Return .f.
	Endif

	If !EXISTCPO("ST9",M->TC_CODBEM)
		Return .f.
	Endif

	If cTipoIns = STR0023 //'Produto'
		If cUsaInt3 == "S" .or. cUsaInt2 == "S"
			M->TL_TIPOREG := "P"
			lIntegr := .t.
			aCols[n,nLOCAL] := NGALMOXA( aCols[n,nBEMGD], M->TL_CODIGO, M->TL_TIPOREG, .T. )
		EndIf
	Endif

	If cTIPODAT == 1
		Store dDATAFIX To aCOLS[n][nDATGD],aCOLS[n][nDATAF],M->TQA_DTLEI1,M->TQA_DTLEI2
		Store cHORAFIX To aCOLS[n][nHORAF],M->TQA_HORAC1,M->TQA_HORAC2
	Endif

	cBEMRET   := M->TC_CODBEM
	cTIPOCON  := NGSEEK( 'ST9', cBEMRET, 1, 'T9_TEMCONT' )
	TIPOACOM  := cTIPOCON == 'S'
	TIPOACOM2 := MNTCont2( FWxFilial( 'TPE' ), cBEMRET )

	If !Empty( cBEMRET )

		If TIPOACOM

			MNTA401Cnt( 1 )

		Else

			aCols[n,nPO1GD]     := 0
			aCols[n,nPosHrCnt1] := '  :  '

		EndIf

		If TIPOACOM2

			MNTA401Cnt( 2 )

		Else

			aCols[n,nPO2GD]     := 0
			aCols[n,nPosHrCnt2] := '  :  '

		EndIf

	Else
		Store 0 To aCOLS[n][nPO1GD],aCOLS[n][nPO2GD]
		Store CTOD(' /  /  ') To aCOLS[n][nDATAF]
	Endif

	lRefresh := .T.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA4013
Programa de Validacao da data fixa
@author Inacio Luiz Kolling
@since 09/11/99
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGA4013()

	Local xy

	LTIPODAT  := .F.
	LEDATAINI := .T.

	If cTIPODAT == 1
		LTIPODAT  := .T.
		LEDATAINI := .F.
		For XY := 1 to len(aCols)
			Store dDATAFIX To aCOLS[XY][nDATGD],aCOLS[XY][nDATAF]
			Store cHORAFIX To aCOLS[XY][nHORAF]
		Next
		oGet:FORCEREFRE()
		lRefresh := .t.
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA4015
Altera a Consulta conforme o tipo de insumo (F3)
@author Inacio Luiz Kolling
@since XX/XX/XXXX
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGA4015

	Local cTipo := If(cTIPOINS == STR0024,"T","N")

	If Type("oRad1") == "O"
		oRad1:Enable(1)
		If !NGVALTERC(cTipo,If(cGERAEST = 1,"S","N"))
			Return .F.
		ElseIf cTipo == "T"
			oRad1:Disable(1)
		EndIf
	EndIf

	Store .f. To LEDESTINO,lCalend
	aTrocaF3  := {}

	If cTIPOINS == STR0025 //"Mao de Obra"
		Aadd(aTrocaF3,{"TL_CODIGO", "ST1"})
		aalias  := "ST1"
		lCalend := .t.
		m->tl_tiporeg := 'M'
		cF3 := 'ST1'
	ElseIf cTIPOINS == STR0023 //"Produto"
		Aadd(aTrocaF3,{"TL_CODIGO", "SB1"})
		aalias := "SB1"
		LEDESTINO := .T.
		m->tl_tiporeg := 'P'
		cF3 := 'SB1'
	ElseIf cTIPOINS == STR0024 //"Terceiros"
		Aadd(aTrocaF3,{"TL_CODIGO", "SA2"})
		aalias := "SA2"
		m->tl_tiporeg := 'T'
		cF3 := 'SA2'
	ElseIf cTIPOINS == STR0026 //"Ferramenta"
		Aadd(aTrocaF3,{"TL_CODIGO", "SH4"})
		aalias := "SH4"
		m->tl_tiporeg := 'F'
		cF3 := 'SH4'
	Endif

	If !IsInCallStack("NG401F3")
		_cTipoIns := cTipoIns
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA4016
Consistencia do codigo do insumo
@author Inacio Luiz Kolling
@since XX/XX/XXXX
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGA4016

	Local xy ,_RET := .T., cHelp
	Local lMMoeda  := NGCADICBASE("TL_MOEDA","A","STL",.F.)

	If Vazio()
		Return .f.
	Endif
	OldAli := Alias()
	tam    := 6

	If cTIPOINS = STR0023 //"Produto"
		tam := Space(Len(STL->TL_CODIGO))
		cXCODIGO := M->TL_CODIGO
	Else
		cXCODIGO := SUBSTR(M->TL_CODIGO,1,tam)
	Endif

	//Testa o tamanho do campo para nao permitir informar codigo invalido
	If cTIPOINS == STR0025  //Mao de obra
		If Len(Alltrim(M->TL_CODIGO)) > Len(ST1->T1_CODFUNC)
			_RET  := .F.
			cHelp := "FUNCNEXIST"
		EndIf
	ElseIf cTIPOINS == STR0024 //Terceiros
		If Len(Alltrim(M->TL_CODIGO)) > Len(SA2->A2_COD)
			_RET := .F.
			cHelp := "TERCNEXIST"
		EndIf
	ElseIf cTIPOINS == STR0026 //Ferramenta
		If Len(Alltrim(M->TL_CODIGO)) > Len(SH4->H4_CODIGO)
			_RET := .F.
			cHelp := "FERRNEXIS"
		EndIf
	ElseIf cTIPOINS = STR0023 //"Produto"
		If Len(Alltrim(M->TL_CODIGO)) > Len(SB1->B1_COD)
			_RET := .F.
			cHelp := "PRODNEXIST"
		EndIf
	EndIf

	If !_RET
		Help(" ",1,cHelp)
		DbSelectArea(OldAli)
		Return .F.
	EndIf

	dbSelectArea(aalias)
	dbSetOrder(01)
	If !DbSeek(xFilial(aalias) + cXCODIGO)
		Help(" ",1,"CODINUSMON")
		DbSelectArea(OldAli)
		Return .F.
	Endif

	If cTIPOINS == STR0025 //"Mao de Obra"
		//Valida a disponibilidade da mao de obra
		cNOMEINS := SUBSTR(ST1->T1_NOME,1,40)
	ElseIf cTIPOINS == STR0023 //"Produto"
		cNOMEINS := SUBSTR(SB1->B1_DESC,1,40)
	ElseIf cTIPOINS == STR0024 //"Terceiros"
		cNOMEINS := SUBSTR(SA2->A2_NOME,1,40)
	ElseIf cTIPOINS == STR0026 //"Ferramenta"
		cNOMEINS := SUBSTR(SH4->H4_DESCRI,1,40)
	Endif

	If M->TL_TIPOREG = "M"
		DbSelectArea("SH7")
		DbSetOrder(01)
		DbSeek(xFilial("SH7") + ST1->T1_TURNO)
	Endif

	cUNIDA := If (cTIPOINS = STR0023,SB1->B1_UM,"H")
	For XY := 1 to len(aCols)
		aCOLS[XY][nUNIGD] := cUNIDA
		//Zera os campos de custo muda o codigo do produto ou tipo de insumo
		If (cTIPOINSR <> cTIPOINS  .And. cTIPOINS <> STR0023) .Or. (M->TL_CODIGO <> cCODRASPR .And. cTIPOINS = STR0023)

			If M->TL_CODIGO != cCODRASPR .And. cTIPOINS == STR0023

				aCols[XY,nLOCAL] := NGALMOXA( aCols[n,nBEMGD], M->TL_CODIGO, M->TL_TIPOREG, .T. )

			Else

				aCols[XY,nLOCAL] := Space( 02 )

			EndIf

			If cGERAEST  = 1
				aCOLS[XY][nVALGD] := 0.00
				aCOLS[XY][nVALGE] := 0.00
				If lMMoeda .And. nMOEDA > 0
					aCOLS[XY][nMOEDA] := "1"
				Endif
			EndIf
		EndIf

		//Zera os campos de rastreabilidade se mudou o codigo do produto ou tipo de insumo
		If (lCONT401 .And. M->TL_CODIGO <> cCODRASPR) .Or. (cTIPOINS <> STR0023 .And. lCONT401)
			aCOLS[XY][nLOTEC] := Space(10)      // Numero do Lote
			aCOLS[XY][nNUMLO] := Space(06)      // Numero do sub-lote
			aCOLS[XY][nLOCALI]:= SPACE(15)      // Localizacao
			aCOLS[XY][nDTVAL] := CTOD(' /  /  ')// Data de validade
			aCOLS[XY][nNUMSEI]:= SPACE(20)      // NUMERO DA SERIE
		EndIf

	Next XY
	//Recalcula novamente o custo do insumo do tipo produto se
	//mudou de o codigo do produto ou tipo do insumo para produto
	If (cTIPOINSR <> cTIPOINS .And. cTIPOINS = STR0023) .Or. (M->TL_CODIGO <> cCODRASPR .And. cTIPOINS = STR0023);
	.And. cGERAEST  = 1
		MNTA401ATU(2,2)
	EndIf
	lCONT401  := If(cTIPOINS <> STR0023,.F.,NG401LOT())
	cCODRASPR := M->TL_CODIGO
	cTIPOINSR := cTIPOINS

	oGet:FORCEREFRE()
	DbSelectArea(OldAli)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA4018
Consistencia da unidade do insumo
@author Inacio Luiz Kolling
@since XX/XX/XXXX
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGA4018

	If Vazio()
		Return .f.
	Endif
	If cTIPOINS <> STR0023
		cUNID := ALLTRIM(M->TT_UNIDADE)
		If !Pertence('MHDS',cUNID)
			Return .F.
		Endif
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA40111
Consistencia da data da O.S.
@author Deivys Joenck
@since 25/01/02
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGA40111()

	Local xd

	If cTIPODAT == 1
		If dDATAFIX > dDATABASE
			If dDATAFIX > dDATABASE
				MsgStop(STR0114) //"A data início não pode ser maior que a data atual."
				Return .F.
			EndIf
		EndIf
		If dDATAFIX < dDATABASE
			If !MSGYESNO(STR0037,STR0036) // Data de inicio informada e menor do que a data prevista para inicio da OS.
				Return .F.
			EndIf
		EndIf
	Endif
	For XD := 1 to len(aCols)
		aCOLS[XD][nDATGD] := dDATAFIX
	Next XD

	oGet:FORCEREFRE()

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA40112
Consistencia da data da O.S.
@author Deivys Joenck
@since 25/01/02
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGA40112()

	Local lACHOUSTJ := .F.
	Local dDATASTJ

	If cTIPO_OS == 1
		If M->TL_DTINICI > dDataBase
			MsgStop(STR0114) //"A data início não pode ser maior que a data atual."
			Return .F.
		EndIf
	EndIf

	If cTIPO_OS == 2
		Dbselectarea("STJ")
		Dbsetorder(2)
		Dbseek(xFILIAL("STJ")+"B"+aCOLS[n][nBEMGD]+cSERVICO)
		While !Eof() .And. xFILIAL("STJ") = STJ->TJ_FILIAL .And.;
		STJ->TJ_TIPOOS = "B" .And. STJ->TJ_CODBEM = aCOLS[n][nBEMGD];
		.And. STJ->TJ_SERVICO == cSERVICO .And. !lACHOUSTJ

			If STJ->TJ_SITUACA = 'L' .And. STJ->TJ_TERMINO = 'N'
				lACHOUSTJ := .t.
				dDATASTJ  := IF(!EMPTY(STJ->TJ_DTMPINI),STJ->TJ_DTMPINI,STJ->TJ_DTORIGI)
			EndIf
			Dbselectarea("STJ")
			Dbskip()
		End
		If !lACHOUSTJ
			If M->TL_DTINICI > dDataBase
				MsgStop(STR0114) //"A data início não pode ser maior que a data atual."
				Return .F.
			EndIf
		Else
			If M->TL_DTINICI < dDATASTJ
				If !MsgYesNo(STR0038,STR0036)
					Return .F.
				EndIf
			Else
				If M->TL_DTINICI > dDATASTJ .And. M->TL_DTINICI > dDataBase
					MsgStop(STR0114) //"A data início não pode ser maior que a data atual."
					Return .F.
				EndIf
			EndIf
		EndIf
	EndIf
	If cTIPOINS == STR0025 //"Mao de Obra"
		//Valida a disponibilidade da mao de obra

		If !NGFUNCRH(M->TL_CODIGO,.T.,M->TL_DTINICI)
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA401ATU
Acumula o total codigo do insumo
@author Inacio Luiz Kolling
@since XX/XX/XXXX
@version undefined
@param lCustoMd, logical
@type function
/*/
//---------------------------------------------------------------------
Function NGA401ATU(lCustoMd)
	Local nCustMd, nMoedaAtu, xk, nMoedaNew

	// Multi-Moeda
	Local lMMoeda   := NGCADICBASE("TL_MOEDA","A","STL",.F.)
	Local nMOEDA    := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "TL_MOEDA"})

	Default lCustoMd := .F.

	nVALORUM := 0.00
	For XK := 1 to len(aCols)

		If !aCols[XK][Len(aCols[XK])]

			nMoedaNew := Val( If(lCustoMd, M->TL_MOEDA, If(nMOEDA > 0, aCOLS[XK][nMOEDA], "1")) )
			nMoedaAtu := If(!lCustoMd, nMoedaNew  , Val(aCOLS[XK][nMOEDA]) )
			nCustMd   := If(!lCustoMd, M->TL_CUSTO, aCOLS[XK][nVALGD])

			If XK == n
				nVALORUM := nVALORUM + M->TL_CUSTO
			Else
				nCusto := If(!Empty(nVALGD),aCOLS[XK][nVALGD],0)
				nVALORUM := nVALORUM + nCusto
			Endif
			aCOLS[XK][nVALGE] := nVALORUM
			lRefresh := .t.
		Endif
	Next

	If !Empty(nTOTAL) .And. aCOLS[n][nVALGE] > nTOTAL
		MsgStop(STR0093+CHR(13)+CHR(13);//"Total acumulado é maior que o total geral. O total acumulado"
		+STR0094,STR0041) //"ATENCAO"  # "deve ser igual ao total geral."
		Return .f.
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA40115
Consistencia da unidade do insumo
@author Inacio Luiz Kolling
@since XX/XX/XXXX
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGA40115()

	If cTIPOINS == STR0023

		If cVALPECRE == "S"
			//CHEKA SE A QUANDIDADE DE PRODUTO NAO PASSA DA QUANTIDADE DE PECAS DE REPOSICAO
			If !NGCHKLIMP(aCols[n][nBEMGD],M->TL_CODIGO,M->TL_QUANTID)
				Return .F.
			EndIf
		EndIf

		DbSelectArea("SB1")
		DbSetOrder(1)
		DbSeek(xFilial("SB1")+M->TL_CODIGO)
		aCols[n][nUNIGD]   := SB1->B1_UM
		M->TT_UNIDADE := SB1->B1_UM
		MNTA401ATU(2,1)
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} CHKSERV
Consistencia em relação ao tipo de serviço
@author Inacio Luiz Kolling
@since 23/04/03
@version undefined
@param cServico, characters
@type function
/*/
//---------------------------------------------------------------------
Static Function CHKSERV(cServico)

	Local cTIPOSER  := If(coscor == 1,"C","P")
	Local lRETOSER  := .F.
	Local cSerefor  := AllTrim( GETMV( "MV_NGSEREF" ) )
	Local aServRef 	:= StrTokArr( cSerefor, ';' ) 
	Local cSercons  := AllTrim( GETMV( "MV_NGSECON" ) )
	Local aServCon 	:= StrTokArr( cSercons, ';' ) 

	If aScan(aServRef, {|x| x == AllTrim(cServico)}) > 0 .Or.;
	aScan(aServCon, {|x| x == AllTrim(cServico)}) > 0
		MsgStop(STR0104)
		cSERVICO := ""
		Return .F.
	EndIf

	If !ExistCpo("ST4",cServico)
		Return .F.
	Endif
	If NGFUNCRPO("NGSERVBLOQ",.F.)  .And.  !NGSERVBLOQ(cServico)
		Return .f.
	EndIf

	ST4->(Dbseek(XFILIAL("ST4")+cServico))
	lRETOSER := NGTIPSER(cServico,cTIPOSER)
	cNOMESER := ST4->T4_NOME

Return lRETOSER

//---------------------------------------------------------------------
/*/{Protheus.doc} NGA4017
Altera a leitura do campo custo
@author Inacio Luiz Kolling
@since 23/04/03
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGA4017()

	Local xy
	lCusto := If(cGeraEst == 1,.f.,.t.)

	If cGeraEst = 1
		nTotal := 0.00
		nCusto := 0.00
		For xy := 1 To Len(aCOLS)
			If nVALGD > 0
				aCOLS[xy][nVALGD] := 0.00
			Endif
			If nVALGE > 0
				aCOLS[xy][nVALGE] := 0.00
			Endif
			If nMOEDA > 0
				aCOLS[xy][nMOEDA] := "1"
			Endif
		Next
		oGet:FORCEREFRE()
	Endif

	//Zera os campos de rastreabilidade se nao gera estoque
	If cGeraEst = 2  .And. lCONT401
		lCONT401 := .F.
		For xy := 1 To Len(aCOLS)
			aCOLS[xy][nLOTEC]  := Space(10)      // Numero do lote
			aCOLS[xy][nNUMLO]  := Space(06)      // Numero do sub-lote
			aCOLS[xy][nLOCALI] := SPACE(15)      // Localizacao
			aCOLS[xy][nDTVAL]  := CTOD(' /  /  ')// Data de validade
			aCOLS[xy][nNUMSEI] := SPACE(20)      // NUMERO DA SERIE
		Next
		oGet:FORCEREFRE()
	Else
		//Verifica a variavel de controle do When dos
		//campos de rastreabilidade
		lCONT401 := NG401LOT()
	Endif

	lRefresh := .T.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA401CAB
Consistencia dos campos obrigatório do cabecalho
@author Inacio Luiz Kolling
@since 23/04/03
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA401CAB()

	Local cCAMPOCA := Space(1)

	If Empty(cSERVICO)
		cCAMPOCA := STR0005  // "Servico"
	ElseIf Empty(M->TL_CODIGO)
		cCAMPOCA := STR0018  //"Codigo"
	ElseIf lCusto
		If nTOTAL < 0
			cCAMPOCA := STR0016  //"Total"
		Endif
	Endif
	If !Empty(cCAMPOCA)
		MsgInfo(STR0047+Space(1)+cCAMPOCA,STR0048)
		Return .F.
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA401VC
Consistencia dos campos do contadores
@author Inacio Luiz Kolling
@since 09/06/03
@version undefined
@param nVALCON, numeric
@param nTIPC, numeric
@type function
/*/
//---------------------------------------------------------------------
Function MNTA401VC(nVALCON,nTIPC)

	If Empty(nVALCON)
		aCols[n][nHORAF] := '  :  '
	Else
		If !Positivo(nVALCON) .Or. !CHKPOSLIM(aCols[n][nBEMGD],nVALCON,nTIPC)
			Return .F.
		Endif
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG401HOINI
Valida e mostra a hora inicio
@author Inacio Luiz Kolling
@since 19/04/2004
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG401HOINI()

	If !NGVALHORA(M->TL_HOINICI,.T.)
		Return .f.
	Endif

	If cTIPOINS = STR0023 //"Produto"
		aCols[n][nDATAF] := aCols[n][nDATGD]
		aCols[n][nHORAF] := M->TL_HOINICI
	Else
		M->TL_DTINICI := aCols[n][nDATGD]
		M->TL_USACALE := aCols[n][nUSACA]

		If (M->TL_HOINICI == aCols[n][nHORAF]) .And. (aCols[n][nDATGD] == aCols[n][nDATAF])
			MsgStop(STR0108) //"A hora início não pode ser igual à hora fim."
			Return .F.
		EndIf

		If dDataBase == aCols[n][nDATGD] .And. !Empty(M->TL_HOINICI) .And. HTOM(M->TL_HOINICI) > HTOM(Substr(Time(),1,5))
			MsgStop(STR0111) //"Hora início não pode ser menor que a hora atual."
			Return .F.
		EndIf

		If !NGSTLHORIN()
			Return .f.
		Endif
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG401DTFIM
Valida a data fim
@author Inacio Luiz Kolling
@since 19/04/2004
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG401DTFIM()

	If M->TL_DTFIM < aCols[n][nDATGD]
		Return .f.
	Endif
	If cTIPOINS == STR0025 //"Mao de Obra"
		//Valida a disponibilidade da mao de obra

		If !NGFUNCRH(M->TL_CODIGO,.T.,M->TL_DTFIM)
			Return .F.
		EndIf
	EndIf

	If dDataBase < M->TL_DTFIM
		MsgStop(STR0113) //"Data fim não pode ser maior que a data atual."
		Return .F.
	ElseIf M->TL_DTFIM <> aCols[n][nDATGD] .And. M->TL_DTFIM > dDataBase
		MsgStop(STR0113) //"Data fim não pode ser maior que a data atual."
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG401HOFIM
Atualiza hora fim quando digitado qtde de horas.
@author Inacio Luiz Kolling
@since 19/04/2004
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG401HOFIM()

	If !NGVALHORA(M->TL_HOFIM,.T.)
		Return .f.
	EndIf

	If cTIPOINS <> STR0023 //"Produto"
		If !COMPDATA(aCols[n][nDATGD],aCols[n][nHORAI],aCols[n][nDATAF],M->TL_HOFIM)
			Return .f.
		EndIf
		M->TL_DTINICI := aCols[n][nDATGD]
		M->TL_HOINICI := aCols[n][nHORAI]
		M->TL_DTFIM   := aCols[n][nDATAF]
		M->TL_USACALE := aCols[n][nUSACA]
		M->TL_UNIDADE := "H"

		If (aCols[n][nHORAI] == M->TL_HOFIM) .And. (aCols[n][nDATGD] == aCols[n][nDATAF])
			MsgStop(STR0109) //"A hora fim não pode ser igual à hora início."
			Return .F.
		EndIf

		If !NGSTLHORFI()
			Return .f.
		Endif

		NGCALQUANT()

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA401ALM
Consistencia do local do estoque
@author Inacio Luiz Kolling
@since 18/08/2004
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA401ALM()

	IF cTipoIns == STR0023
		If !NGPROALM(M->TL_CODIGO,M->TL_LOCAL)
			Return .f.
		Endif
		MNTA401ATU(1,2)
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA401ATU
Atualiza totalizador do getdados
@author Inacio Luiz Kolling
@since 18/08/2004
@version undefined
@param nPAR, numeric
@param nPAR2, numeric
@type function
/*/
//---------------------------------------------------------------------
Function MNTA401ATU(nPAR,nPAR2)

	Local vx := 0,nTOGE := 0.00, nCUSAC := 0.00,cALMX
	Local lMMoeda := NGCADICBASE("TL_MOEDA","A","STL",.F.)
	Local aCstMoeda := {}
	Local cMoedaCst  := "1"

	If !lCUSTO
		For vx = 1 To Len(aCOLS)
			If !aCols[vx][Len(aCols[vx])]
				If vx = n
					cALMX := If(nPAR  = 2,aCols[vx,nLOCAL],M->TL_LOCAL)
					nQTDX := If(nPAR2 = 2,aCols[vx,nQUTGD],M->TL_QUANTID)
				Else
					cALMX := aCols[vx,nLOCAL]
					nQTDX := aCols[vx,nQUTGD]
				Endif

				If lMMoeda .And. nMOEDA > 0 .And. FindFunction("NGCALCUSMD")
					aCstMoeda := NGCALCUSMD(M->TL_CODIGO,"P",nQTDX,cALMX,If(aCols[vx,nUSACA] = "S","S",""),,,If(nQTDREC > 0,aCols[vx,nQTDREC],1))
					nCUSAC    := aCstMoeda[1]
					cMoedaCst := aCstMoeda[2]
				Else
					nCUSAC := NGCALCUSTI(M->TL_CODIGO,"P",nQTDX,cALMX,If(aCols[vx,nUSACA] = "S","S",""),,,If(nQTDREC > 0,aCols[vx,nQTDREC],1))
					If lMMoeda .And. nMOEDA > 0
						cMoedaCst := "1"
					Endif
				Endif

				nCusto := nCUSAC
				If nVALGD > 0
					aCOLS[vx,nVALGD] := nCUSAC
				EndIf

				If lMMoeda .And. nMOEDA > 0
					aCOLS[vx,nMOEDA] := cMoedaCst
				Endif

				nTOGE := nTOGE+nCUSAC
				aCOLS[vx,nTOCUS] := nTOGE
			Endif
		Next
	Endif

	nTOTIMT := aCOLS[len(aCOLS),nTOCUS]
	oNTOTAL := nTOTIMT
	oDlg:Refresh(.T.)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA401DEL
Recalcula o totalizador do getdados
@author Inacio Luiz Kolling
@since 18/08/2004
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA401DEL()

	Local nx := 1,nTOGED := 0.00
	nCusto := If(!Empty(nVALGD),aCOLS[nx,nVALGD],0)

	For nx := 1 To Len(aCOLS)
		If nx = n // A MsGetDados cria a variavel publica n que indica qual a linha posicionada do aCols.
			If aCols[nx][Len(aCols[nx])]
				nTOGED := nTOGED+nCusto
				aCOLS[nx,nTOCUS] := nTOGED
			Endif
		Else
			If !aCols[nx][Len(aCols[nx])]
				nTOGED := nTOGED+nCusto
				aCOLS[nx,nTOCUS] := nTOGED
			Endif
		Endif
	Next

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG401LOTCT
Valida o campo TL_LOTECTL
@author Elisangela Costa
@since 13/03/06
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG401LOTCT()
Return If(!Empty(M->TL_LOTECTL),NGVRASTSB8(M->TL_CODIGO,aCols[n][nLOCAL],M->TL_LOTECTL,aCols[n][nNUMLO]),.T.)

//---------------------------------------------------------------------
/*/{Protheus.doc} NG401NUMLO
Valida o campo TL_NUMLOTE
@author Elisangela Costa
@since 13/03/06
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG401NUMLO()
Return If(!Empty(M->TL_NUMLOTE),NGVRASTSB8(M->TL_CODIGO,aCols[n][nLOCAL],aCols[n][nLOTEC],M->TL_NUMLOTE),.T.)

//---------------------------------------------------------------------
/*/{Protheus.doc} NG401LOCAL
Valida o campo TL_LOCALIZ
@author Elisangela Costa
@since 13/03/06
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG401LOCAL()
Return If(!Empty(M->TL_LOCALIZ),ExistCpo('SBE',aCols[n][nLOCAL]+M->TL_LOCALIZ),.T.)

//---------------------------------------------------------------------
/*/{Protheus.doc} NG401LOT
Valida os campos de lote e sub-lote, controla X3_WHEN
@author Elisangela Costa
@since 17/04/06
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG401LOT()

	Local lRET401 := .F.

	If cTipoIns == STR0023 .And. Alltrim(GetMv("MV_RASTRO")) = "S" .And. cGERAEST  = 1
		lRET401 := .T.
	EndIf

Return lRET401

//---------------------------------------------------------------------
/*/{Protheus.doc} A401STJBUS
Busca Ordens de servico com status de terceiros para um determinado bem
@author Ricardo Dal Ponte
@since 03/05/2007
@version undefined
@param cBEMSTJ, characters
@type function
/*/
//---------------------------------------------------------------------
Function A401STJBUS(cBEMSTJ)

	Dbselectarea("STJ")
	DbSetOrder(2)

	lSTJAchou  := .F.
	nRecnoSTJ  := STJ->(Recno())

	Dbseek(xFILIAL("STJ")+"B"+cBEMSTJ)

	While !Eof() .And. STJ->TJ_FILIAL  = xFILIAL("STJ");
			  	 .And. STJ->TJ_TIPOOS  = "B";
				 .And. STJ->TJ_CODBEM  = cBEMSTJ

		If STJ->TJ_SITUACA = "C"
			dbSkip()
			Loop
		EndIf

		If STJ->TJ_TERMINO = "N" .And. STJ->TJ_TERCEIR = "2"
			lSTJAchou := .T.
		EndIf

		Dbselectarea("STJ")
		dbSkip()
	End

	STJ->(DbGoTo(nRecnoSTJ))

Return lSTJAchou

//---------------------------------------------------------------------
/*/{Protheus.doc} NG401F3
Altera o F3 na consulta do insumo
@author Inacio Luiz Kolling
@since 03/04/2008
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG401F3()
	NGA4015()
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de menu Funcional
@author Vitor Emanuel Batista
@since 22/07/2008
@version undefined
@return array com opcoes da rotina.
@type function
/*/
//---------------------------------------------------------------------
Static Function MenuDef()

	//+----------------------------------------------------------+
	//|	Parametros do array a Rotina:                 	     	 |
	//| 1. Nome a aparecer no cabecalho                          |
	//| 2. Nome da Rotina associada                              |
	//| 3. Reservado                                             |
	//| 4. Tipo de Transação a ser efetuada:                     |
	//|    1 - Pesquisa e Posiciona em um Banco de Dados         |
	//|    2 - Simplesmente Mostra os Campos                     |
	//|    3 - Inclui registros no Bancos de Dados               |
	//|    4 - Altera o registro corrente                        |
	//|    5 - Remove o registro corrente do Banco de Dados      |
	//| 5. Nivel de acesso                                       |
	//| 6. Habilita Menu Funcional                 		     	 |
	//+----------------------------------------------------------+

	Local aRotina := {{STR0001 , "AxPesqui" , 0 , 1},; //"Pesquisar"
					  {STR0002 , "NGCAD02"  , 0 , 2},; //"Visualizar"
					  {STR0003 , "MNTA401"  , 0 , 3}}  //"Incluir"

Return(aRotina)

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT401QTD
Validacao da quantidade quando tipo insumo <> Produto "P"
@author Rafael Diogo Richter
@since 30/10/2008
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT401QTD()

	Local lRetQ := .T.

	If M->TL_TIPOREG <> "P"
		M->TL_UNIDADE := aCols[n,nUNIGD]
		M->TL_USACALE := aCols[n,nUSACA]
		lRetQ := NGQUANTCHK(M->TL_TIPOREG,M->TL_UNIDADE,M->TL_QUANTID,M->TL_USACALE)
	Endif

Return lRetQ

//---------------------------------------------------------------------
/*/{Protheus.doc} NG401SOBHR
Checa sobreposicao de insumo no aCols
@author Evaldo Cevinscki Jr.
@since 10/02/09
@version undefined
@param cTPIns, characters, Posicao no aCols do Tipo do Insumo;
@param cCodIns, characters, Posicao no aCols do Codigo do Insumo;
@param nPosDtI, numeric, Posicao no aCols da Data Inicio;
@param nPosHrI, numeric, Posicao no aCols da Hora Inicio;
@param nPosDtF, numeric, Posicao no aCols da Data Fim;
@param nPosHrF, numeric, Posicao no aCols da Hora Fim;
@type function
/*/
//---------------------------------------------------------------------
Static Function NG401SOBHR(cTPIns,cCodIns,nPosDtI,nPosHrI,nPosDtF,nPosHrF)

	Local nY

	If cTpIns <> "P" .And. cTpIns <> "T"
		For nY := 1 to Len(aCols)
			If n <> nY
				If (DtoS(aCols[n][nPosDtI])+aCols[n][nPosHrI] >  DtoS(aCols[nY][nPosDtI])+aCols[nY][nPosHrI] .And.;
				    DtoS(aCols[n][nPosDtI])+aCols[n][nPosHrI] <  DtoS(aCols[nY][nPosDtF])+aCols[nY][nPosHrF]) .Or.;
				   (DtoS(aCols[n][nPosDtI])+aCols[n][nPosHrI] == DtoS(aCols[nY][nPosDtI])+aCols[nY][nPosHrI] .And.;
				    DtoS(aCols[n][nPosDtI])+aCols[n][nPosHrF] == DtoS(aCols[nY][nPosDtF])+aCols[nY][nPosHrF])

					MsgInfo(STR0095+cCodIns+CHR(13)+; //"Existe sobreposição de horas lançadas para o Insumo: "
					STR0096+AllTrim(Str(nY))+CHR(13)+; //" Lançamento existente na linha: "
					STR0097+Substr(DtoS(aCols[nY][nPosDtI]),7,2)+"/"+Substr(DtoS(aCols[nY][nPosDtI]),5,2)+"/"+Substr(DtoS(aCols[nY][nPosDtI]),1,4)+Chr(13)+; //" Data Inicio: "
					STR0098+aCols[nY][nPosHrI]+CHR(13)+; //" Hora Inicio: "
					STR0099+Substr(DtoS(aCols[nY][nPosDtF]),7,2)+"/"+Substr(DtoS(aCols[nY][nPosDtF]),5,2)+"/"+Substr(DtoS(aCols[nY][nPosDtF]),1,4)+Chr(13)+; //" Data Fim: "
					STR0100+aCols[nY][nPosHrF]+CHR(13),STR0014)//'ATENCAO'###" Hora Fim: "
					Return .F.
				EndIf
			EndIf
		Next nY
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT401NTAR
Consistencia da tarefa
@author Inacio Luiz Kolling
@since 08/02/2010
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT401NTAR()

	Local lRet := .F.

	If NGSTLTAR(,cTarefa)
		cNomeTa := Space(30)
		cNomeTa := SubStr(NGSEEK("TT9",cTarefa,1,"TT9_DESCRI"),1,35)
		lRet    := .T.
	Endif

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT401C
Limpa campo de nome
@author Jackson Machado
@since 11/04/2011
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT401C()

	If _cTipoIns != cTipoIns
		If !NGCLEARSTL()
			Return .F.
		Endif
		cNOMEINS := ""
	Endif
	If !NGA4015()
		Return .F.
	Endif
	If cTipoIns <> STR0026 //"Ferramenta"
		nQUANTI := 0
	EndIf

Return .T.


//---------------------------------------------------------------------|
/*/{Protheus.doc} fQuanRec
Verifica se o valor digitado é positivo e se foi informada a quantidade
para a ferramenta

@return .T.

@author Tainã Alberto Cardoso
@since 05/11/2013
@version 1.0
/*/
//---------------------------------------------------------------------|
Static Function fQuanRec()

	If cTipoIns == STR0026 //"Ferramenta"
		dbSelectArea("SH4")
		dbSetOrder(1)
		If dbSeek(xFilial("SH4")+M->TL_CODIGO)
			If nQuanRec > SH4->H4_QUANT
				MsgInfo(STR0107 + cvaltoChar(SH4->H4_QUANT) ) //"A quantidade disponivel de ferramenta é "
				Return .F.
			EndIf
		EndIf

		If nQuanRec == 0
			MsgInfo(STR0105) //"Para Insumo do tipo Ferramente é obrigatório informar a quantidade de recurso."
			Return .F.
		EndIf
	EndIf

Return Positivo(nQuanRec)

//-------------------------------------------------------------------
/*/{Protheus.doc} fMntCabec
Monta os dados do cabeçalho

@author  Maicon André Pinheiro
@since   03/05/2018
@version P12
/*/
//-------------------------------------------------------------------
Static Function fMntCabec()

	Local nInd     := 0
	Local nTot     := 0
	Local nTamanho := 0
	Local nDecimal := 0
	Local cCampo   := ""
	Local cTitulo  := ""
	Local cPicture := ""
	Local cValid   := ""
	Local cUsado   := ""
	Local cTipo    := ""
	Local cArquivo := ""
	Local cContext := ""
	Local cF3      := ""
	Local xWhen    := Nil
	Local lInsere  := .T.
	Local lMoeda   := NGCADICBASE("TL_MOEDA","A","STL",.F.)
	Local aCampos  := { 'TC_CODBEM', 'TL_USACALE', 'TL_QUANTID', 'TL_UNIDADE', 'TL_DTINICI', 'TL_HOINICI', 'TL_DTFIM', 'TL_HOFIM',;
		'TQA_POSCON', 'TQA_HORAC1', 'TQA_POSCO2', 'TQA_HORAC2', 'TL_CUSTO', 'TT_CUSTO', 'TL_LOCAL', 'TL_LOTECTL', 'TL_NUMLOTE',;
		'TL_DTVALID', 'TL_LOCALIZ', 'TL_NUMSERI' }

	If lMoeda //caso utilize multimoedas.
		aAdd( aCampos,"TL_MOEDA" )
	EndIf

	nTot := Len(aCampos)
	For nInd := 1 To nTot

		cCampo   := aCampos[nInd]
		cArquivo := Posicione("SX3",2,cCampo,"X3_ARQUIVO")
		If (cArquivo)->(FieldPos(cCampo)) > 0

			cTitulo  := AllTrim(Posicione("SX3",2,cCampo,"X3Titulo()"))
			cPicture := X3Picture(cCampo)
			nTamanho := TAMSX3(cCampo)[1]
			nDecimal := TAMSX3(cCampo)[2]
			cValid   := Posicione("SX3",2,cCampo,"X3_VALID")
			cUsado   := Posicione("SX3",2,cCampo,"X3_USADO")
			cTipo    := Posicione("SX3",2,cCampo,"X3_TIPO")
			cContext := Posicione("SX3",2,cCampo,"X3_CONTEXT")
			cF3      := Posicione("SX3",2,cCampo,"X3_F3")
			xWhen    := Nil
			lInsere  := .T.

			Do Case
				Case cCampo == "TC_CODBEM"
					cValid := "NGA4011()"
				Case cCampo == "TL_USACALE"
					xWhen := lCalend
				Case cCampo == "TL_QUANTID"
					cValid := "Positivo() .And. NaoVazio() .AND. NGA40115() .And. MNT401QTD() .And. NGCALDTHO()"
				Case cCampo == "TL_UNIDADE"
					cValid := "Naovazio() .And. Pertence('M  H  D  S  ')"
					xWhen  := .F.
				Case cCampo == "TL_DTINICI"
					cTitulo := STR0032 //"Emissao"
					cValid  := "NaoVazio() .AND. NGA40112() .And. NGCALDTHO() .And. MNTA401Cnt( 1 ) .And. MNTA401Cnt( 2 )"
					xWhen   := LEDATAINI
				Case cCampo == "TL_HOINICI"
					cValid := "NG401HOINI() .And. NGCALDTHO() .And. MNTA401Cnt( 1 ) .And. MNTA401Cnt( 2 )"
				Case cCampo == "TL_DTFIM"
					cValid := "NG401DTFIM() .And. NGCALDTHO() .And. MNTA401Cnt( 1, M->TL_DTFIM ) .And. MNTA401Cnt( 2, M->TL_DTFIM )"
				Case cCampo == "TL_HOFIM"
					cValid := "NG401HOFIM() .And. NGCALDTHO()"
				Case cCampo == "TQA_POSCON"
					cValid := "MNTA401VC(M->TQA_POSCON,1)"
					xWhen  := TIPOACOM
				Case cCampo == "TQA_POSCO2"
					cValid := "MNTA401VC(M->TQA_POSCO2,2)"
					xWhen  := TIPOACOM2
				Case cCampo == "TL_CUSTO"
					cTitulo := STR0033 // "Valor"
					cValid  := "Positivo() .and. NGA401ATU()"
					lInsere := X3USO(cUsado)
				Case cCampo == "TL_MOEDA"
					cValid := "NGVLDMDMV(M->TL_MOEDA) .And. NGA401ATU(.T.)"
				Case cCampo == "TT_CUSTO"
					cTitulo := STR0034 // "Acumulado"
					cValid  := ""
				Case cCampo == "TL_LOCAL"
					cValid := "MNTA401ALM()"
					xWhen  := lIntegr
				Case cCampo == "TL_LOTECTL"
					cValid := "NG401LOTCT()"
					xWhen  := lCONT401
				Case cCampo == "TL_NUMLOTE"
					cValid := "NG401NUMLO()"
					xWhen  := lCONT401
				Case cCampo == "TL_DTVALID"
					cValid := ""
				Case cCampo == "TL_LOCALIZ"
					cValid := "NG401LOCAL()"
				Case cCampo == "TL_NUMSERI"
					cValid := ""
				Case cCampo == 'TQA_HORAC1'
					cValid := 'NGVALHORA( M->TQA_HORAC1, .T. ) .And. MNTA401Cnt( 1, Nil, M->TQA_HORAC1 )'
				Case cCampo == 'TQA_HORAC2'
					cValid := 'NGVALHORA( M->TQA_HORAC2, .T. ) .And. MNTA401Cnt( 2, Nil, M->TQA_HORAC2 )'
			EndCase

			If lInsere
				nUsado++
				aAdd(aHeader,{cTitulo,cCampo,cPicture,nTamanho,nDecimal,cValid,cUsado,cTipo,cArquivo,cContext,cF3,xWhen})
			EndIf

		EndIf
	Next nInd

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MNTA401Cnt
Carrega o campo contador conforme o ultimo lançamento.
@type function

@author  Alexandre Santos
@since   09/12/2022

@param nCont  , integer, Indica qual tipo de contador será carregado.
@param dDtCont, date   , Data de leitura do contador.
@param cHrCont, string , Hora de leitura do contador.
/*/
//-------------------------------------------------------------------
Function MNTA401Cnt( nCont, dDtCont, cHrCont )

	If nCont == 1

		Default dDtCont := aCols[n,nDATAF]
		Default cHrCont := aCols[n,nPosHrCnt1]

		If NGSEEK( 'ST9', cBEMRET, 1, 'T9_TEMCONT' ) == 'S' .And. !Empty( dDtCont ) .And.;
			AllTrim( cHrCont ) != ':'
				
			GDFieldPut( 'TQA_POSCON', NGACUMEHIS( cBEMRET, dDtCont, cHrCont, 1, 'E' )[1], n )

		Else

			GDFieldPut( 'TQA_POSCON', 0, n )

		EndIf

	ElseIf nCont == 2

		Default dDtCont := aCols[n,nDATAF]
		Default cHrCont := aCols[n,nPosHrCnt2]

		If MNTCont2( FWxFilial( 'TPE' ), cBEMRET ) .And. !Empty( dDtCont ) .And.;
			AllTrim( cHrCont ) != ':'

			GDFieldPut( 'TQA_POSCO2', NGACUMEHIS( cBEMRET, dDtCont, cHrCont, 2, 'E' )[1], n )
		
		Else

			GDFieldPut( 'TQA_POSCO2', 0, n )

		EndIf

	EndIf
	
Return .T.
