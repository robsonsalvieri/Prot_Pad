#INCLUDE "MDTA055.ch"
#Include "Protheus.ch"

/*/


Ŀ
Funo     MDTA055   Autor  Marcio Costa           Data  03/01/00 
Ĵ
Descrio  Programa de Cadastro de Questionario Medico                
Ĵ
 Uso       Generico                                                   
ٱ


/*/
Function MDTA055

	//------------------------------------------------
	// Armazena variaveis p/ devolucao (NGRIGHTCLICK)
	//------------------------------------------------
	Local aNGBEGINPRM := NGBEGINPRM( )

	Private lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )
	Private aRotina := MenuDef()
	Private lCombo2 := NGCADICBASE("TMH_COMBO2","D","TMH",.F.)
	Private cCadastro
	Private bNGWHEN
	Private lCopia := .F.

	If AMiIn( 35 ) // Somente autorizado para SIGAMDT

		If lSigaMdtps
			cCadastro := OemtoAnsi(STR0007)  //"Clientes"

			DbSelectArea("SA1")
			DbSetOrder(1)

			mBrowse( 6, 1,22,75,"SA1")
		Else

			//-----------------------------------------------
			// Define o cabecalho da tela de atualizacoes
			//-----------------------------------------------
			cCadastro := OemtoAnsi(STR0006) //"Questionario Padrao"
			PRIVATE aCHKDEL := {}, bNGGRAVA

			aCHOICE := {}
			aVARNAO := {}

			aGETNAO := { { "TMH_QUESTI" , "M->TMG_QUESTI"},;
						{ "TMH_NOMQUE" , " "            } }

			cGETWHILE := "TMH_FILIAL == xFilial('TMH') .and. TMH_QUESTI == M->TMG_QUESTI"
			cGETMAKE  := "TMG->TMG_QUESTI"
			cGETKEY   := "M->TMG_QUESTI + M->TMH_QUESTA"
			cGETALIAS := "TMH"
			cTUDOOK   := "AllwaysTrue()"
			cLINOK    := "MDT55LINOK()"

			//-----------------------------------------------------------------
			// aCHKDEL array que verifica a INTEGRIDADE REFERENCIAL na exclu-
			// so do registro.
			//
			// 1 - Chave de pesquisa
			// 2 - Alias de pesquisa
			// 3 - Ordem de pesquisa
			//------------------------------------------------------------------
			aCHKDEL := {{'TMG->TMG_QUESTI',"TMI",2},{'TMG->TMG_QUESTI',"TO6",2}}

			////-----------------------------------------------
			// Endereca a funcao de BROWSE
			//-----------------------------------------------
			DbSelectArea("TMH")
			DbSetOrder(1)

			DbSelectArea("TMG")
			DbSetOrder(1)
			mBrowse( 6, 1,22,75,"TMG")
		Endif
	EndIf

	//-----------------------------------------------
	//  Devolve variaveis armazenadas (NGRIGHTCLICK)
	//-----------------------------------------------
	NGRETURNPRM(aNGBEGINPRM)

Return .T.
/*/


Ŀ
Funo    MDT55LINOK Autor Denis Hyroshi de Souza  Data  01/04/05 
Ĵ
Descrio  Valida a cada linha incluida na GetDados                   
ٱ


/*/
Function MDT55LINOK()

	Local xx := 0, npos, lRET := .T.
	Local nX

	nPOS := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TMH_QUESTA"})

	If nPOS > 0
		For nX := 1 to Len(aCOLS)
			If n <> nX
				If aCOLS[nX][nPOS] == aCOLS[n][nPOS]
					xx++
					Exit
				Endif
			Endif
		Next
	Endif

	If xx > 0
	Help(" ",1,"JAEXISTINF")
	lRet := .f.
	Endif

Return lRet
/*/


Ŀ
Funo    MDT55VALID Autor Denis Hyroshi de Souza  Data  01/04/05 
Ĵ
Descrio  Valida a cada linha incluida na GetDados                   
ٱ


/*/
Function MDT55VALID()

	Local xx := 0, npos, lRET := .T.
	Local nX

	nPOS := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TMH_QUESTA"})

	If nPOS > 0
		For nX := 1 to Len(aCOLS)
			If n <> nX
				If aCOLS[nX][nPOS] == M->TMH_QUESTA
					xx++
					Exit
				Endif
			Endif
		Next
	Endif

	If xx > 0
	Help(" ",1,"JAEXISTINF")
	lRet := .f.
	Endif

Return lRet

/*/


Ŀ
Funo     MenuDef   Autor  Rafael Diogo Richter   Data 29/11/2006
Ĵ
Descrio Utilizacao de Menu Funcional.                               
Ĵ
 Uso       SigaMDT                                                    
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados         
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    F.O    Motivo da Alteracao                     
Ĵ
                                                                    
ٱ


/*/
Static Function MenuDef(lMenu2)

	Local lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )
	Local aRotina
	Default lMenu2 := .F.

	If lSigaMdtps .and. !lMenu2
		aRotina := { { STR0001, "AxPesqui"  , 0 , 1},; //"Pesquisar"
					{ STR0002, "NGCAD01"   , 0 , 2},; //"Visualizar"
					{ STR0008, "MDT055TMG" , 0 , 4} } //"Questionrio"
	Else
		aRotina := { { STR0001, "AxPesqui"     , 0 , 1},; //"Pesquisar"
					{ STR0002, "A55CALLCAD"   , 0 , 2},; //"Visualizar"
					{ STR0003, "A55CALLCAD"   , 0 , 3},; //"Incluir"
					{ STR0004, "A55CALLCAD"   , 0 , 4},; //"Alterar"
					{ STR0005, "A55CALLCAD"   , 0 , 5, 3},;  //"Excluir"
					{ STR0034, "A55COPY", 0, 4}}   //"Copiar"
	Endif

Return aRotina
/*/


Ŀ
Funo    MDT055TMG | Autor Denis Hyroshi de Souza  Data  01/04/05 
Ĵ
Descrio  Funcao de inclusao, alteracao e exclusao de questionario   
           medico                                                     
ٱ


/*/
Function MDT055TMG()

	Local aArea	    := GetArea()
	Local oldROTINA := aCLONE(aROTINA)
	Local oldCad    := cCadastro
	Local aCpsTMG   := { "TMG_QUESTI", "TMG_NOMQUE" }
	Local aNao      := { "TMG_CLIENT", "TMG_LOJA", "TMG_FILIAL"}

	cCliMdtPs := SA1->A1_COD+SA1->A1_LOJA

	lCombo2 := NGCADICBASE("TMH_COMBO2","D","TMH",.F.)
	aRotina := MenuDef(.T.)

	//Ŀ
	// Define o cabecalho da tela de atualizacoes                   
	//
	Private cCadastro := OemtoAnsi(STR0006) //"Questionario Padrao"
	Private aCHKDEL := {}, bNGGRAVA

	aChoice := NGCAMPNSX3( "TMG", aNao )

	aVARNAO := {}

	aGETNAO := { { "TMH_QUESTI" , "M->TMG_QUESTI"},;
				{ "TMH_NOMQUE" , " "            },;
				{ "TMH_CLIENT" , "SA1->A1_COD"  },;
				{ "TMH_LOJA"   , "SA1->A1_LOJA" } }

	cGETWHILE := "TMH_FILIAL == xFilial('TMH') .and. TMH_QUESTI == M->TMG_QUESTI .AND. TMH_CLIENT+TMH_LOJA == cCliMdtps"
	cGETMAKE  := "TMG->TMG_CLIENT+TMG->TMG_LOJA+TMG->TMG_QUESTI"
	cGETKEY   := "cCliMdtps + M->TMG_QUESTI + M->TMH_QUESTA"
	cGETALIAS := "TMH"
	cTUDOOK   := "AllwaysTrue()"
	cLINOK    := "MDT55LINOK()"

	//Ŀ
	//aCHKDEL array que verifica a INTEGRIDADE REFERENCIAL na exclu-
	//so do registro.                                              
	//                                                              
	//1 - Chave de pesquisa                                         
	//2 - Alias de pesquisa                                         
	//3 - Ordem de pesquisa                                         
	//
	aCHKDEL := { {'TMG->TMG_QUESTI',"TMI",2},;
				{'TMG->TMG_QUESTI',"TO6",2} }

	//Ŀ
	// Endereca a funcao de BROWSE                                  
	//
	nTMHi := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI+TMH_QUESTA",.T.)
	If nTMHi == 0
		nTMHi := 1
	Endif
	DbSelectArea("TMH")
	DbSetOrder(nTMHi)

	DbSelectArea("TMG")
	Set Filter To TMG->(TMG_CLIENT+TMG_LOJA) == cCliMdtps
	DbSetOrder(2)
	mBrowse( 6, 1,22,75,"TMG")

	DbSelectArea("TMG")
	Set Filter To

	aROTINA := aCLONE(oldROTINA)
	RestArea(aArea)
	cCadastro := oldCad

Return

/*/


Ŀ
Funo    fMarkOpca  Autor  Denis Hyroshi de Souza Data  09/05/08 
Ĵ
Descrio  Funcao para marcar ou desmarcar as opes                  
ٱ


/*/
Static Function fMarkOpca(nColuna)

	Local nAntes3

	If !aBoxPerg[oBoxPerg:nAt][1]// .or. (nColuna <> 1 .and. oBoxPerg:nAt > 3)
		nAntes3 := aBoxPerg[oBoxPerg:nAt][3]
		lEditCell(@aBoxPerg,oBoxPerg,'',3)
		If !Empty(aBoxPerg[oBoxPerg:nAt][3])
			If "=" $ aBoxPerg[oBoxPerg:nAt][3] .or. ";" $ aBoxPerg[oBoxPerg:nAt][3]
				aBoxPerg[oBoxPerg:nAt][3] := nAntes3
				MsgInfo(STR0011 + STR0012 ) //"Os seguintes caracteres no podero ser utilizados: "###"= (sinal de igualdade) ou ; (ponto e virgula)"
				Return
			Endif
			//Se o parametro for informado corretamente, a listbox  atualizada
			aBoxPerg[oBoxPerg:nAt][1] := .t.
			aBoxPerg[oBoxPerg:nAt][3] := PadR(aBoxPerg[oBoxPerg:nAt][3],30)
			oBoxPerg:REFRESH()
		Else
			aBoxPerg[oBoxPerg:nAt][1] := .f.
			aBoxPerg[oBoxPerg:nAt][3] := Space(30)
			oBoxPerg:REFRESH()
		Endif
	Else
		//Caso o usuario desmarque o checkbox
		aBoxPerg[oBoxPerg:nAt][1] := .f.
		aBoxPerg[oBoxPerg:nAt][3] := Space(30)
		oBoxPerg:REFRESH()
	Endif

Return

/*/


Ŀ
Funo     fValTRBX  Autor  Denis Hyroshi de Souza Data  09/05/08 
Ĵ
Descrio  Funcao para validar a confirmao da tela                  
ٱ


/*/
Static Function fValTRBX2()

	Local nXX
	Local nPosCmp := aScan(aHeader, {|x| AllTrim(Upper(X[2])) == "TMH_COMBO" })
	Local lRespos := NGCADICBASE( "TMH_RESPOS", "D", "TMH", .F. )

	If !Empty(M->TMH_DEFAUL)
		lAcho := .F.
		For nXX := 1 To Len(aBoxPerg)
			If aBoxPerg[nXX,1] .and. aBoxPerg[nXX,2] == AllTrim(M->TMH_DEFAUL)
				lAcho := .T.
			Endif
		Next nXX
		If !lAcho
			MsgInfo(STR0020) //"A opo Default no foi selecionada"
			Return lAcho
		EndIf
	EndIf
	M->TMH_COMBO := ""
	oBrwB:aCols[oBrwB:nAt,7] := M->TMH_DEFAUL
	For nXX := 1 To Len(aBoxPerg)
		If aBoxPerg[nXX,1] .and. !Empty(aBoxPerg[nXX,3])
			If !Empty(M->TMH_COMBO)
				M->TMH_COMBO += ";"
			Endif
			M->TMH_COMBO += aBoxPerg[nXX,2] + "=" + Alltrim(Substr(aBoxPerg[nXX,3],1,30))
		Endif
	Next nXX
	//Se no for aplicado o UPDMDT96 faz a verificao da quantidade de caracteres no campo TMH_COMBO
	If !lRespos .And. Len(M->TMH_COMBO) > 250
		MsgInfo(STR0013) //"A quantidade de caracteres no campo Editar Opc. ultrapassou 250."
		Return .f.
	ElseIf Empty(M->TMH_COMBO)
		M->TMH_COMBO := "1="+STR0015+";"+"2="+STR0016+";"+"3="+STR0017 //"Sim"###"Nao"###"Sem Resposta"
		MsgInfo(STR0014) //"Nenhum item foi selecionado, portanto, sero consideradas as opes padro (Sim, No e Sem Resposta)."
	Endif

	aCols[n,nPosCmp] := If( lRespos, M->TMH_COMBO, PadR(M->TMH_COMBO,250) )

Return .t.

/*/


Ŀ
Funo     MDTA55CAD Autor  Taina A. Cardoso       Data 04/11/2010
Ĵ
Descrio  Tela de manutencao do questionario                         
Ĵ
 Uso                                                                  
ٱ


/*/
Function MDTA55CAD(cAlias, nRecno, nOpcx)

	Local oFont, oGet, oDlg, nX2, nX , oPanelTot
	Local nControl    := 0
	Local aPages      := {}
	Local aTitles     := {}
	Local lAltProg    := .T.
	Local oFont12     := TFont():New("Arial",,-14,.T.,.T.)
	Local nIndTMH
	Local cSeekTMH
	Local cCondTMH
	Local lRespos     := NGCADICBASE( "TMH_RESPOS", "D", "TMH", .F. )
	Local nPos
	Local aArea	      := {}
	Local nCps        := 0

	//Arrays para a montagem do aHeader
	Local aFldGrp     := { "TMH_CODGRU", "TMH_NOMGRU" }
	Local aFldQst     := { "TMH_PERGUN", "TMH_INDSEX", "TMH_TPLIST", "TMH_ONMEMO", "TMH_COMBO" }
	Local aExcGrp     := {  { "TMH_CODGRU", 'X3_VALID', 'DESCRIGR()'}, { "TMH_NOMGRU", 'X3_VALID', 'DESCRIGR()'}  } //Array de excees

	Private lAltInd   := .t.
	Private aSvATela  := {}, aSvAGets := {}, aTela := {}, aGets := {}, aNao := {}
	Private oChecked  := LoadBitmap(GetResources(),'LBTIK')
	Private oUnCheck  := LoadBitmap(GetResources(),'LBNO')
	Private lCopia    := If(Type("lCopia") = "L",lCopia,.f.)

	//Carregando variaveis - Grupo de Perguntas
	Private aCoBrwA   := {}
	Private aHoBrwA   := {}
	Private oBrwA
	Private aMemos    := {}

	//Carregando variaveis - Perguntas
	Private a00BrwB   := {}
	Private aSvBrwB   := {}
	Private aCoBrwB   := {}
	Private aHoBrwB   := {}
	Private aCoBrwGru := {} //Backup do grupo de pergunta existente
	Private aCoBrwPer := {} //Backup das perguntas existentes
	Private oBrwB
	Private aCampPE   := {} //Variavel com os campos criados atravs do PE MDTA0551
	Private aValues   := { 	{ "TMH_CODGRU" , 1 } , ;
							{ "TMH_PERGUN" , 2 } , ; //Array com as posies dos campos no aSvBrwB
							{ "TMH_INDSEX" , 9 } , ;
							{ "TMH_TPLIST" , 3 } , ;
							{ "TMH_ONMEMO" , 4 } , ;
							{ "TMH_COMBO " , 5 } , ;
							{ "TMH_ORDEM " , 6 } , ;
							{ "TMH_QUESTA" , 7 } , ;
							{ "TMH_DEFAUL" , 8 } , ;
							{ "D_E_L_E_T_" , 10} }


	If nOpcx == 2 .or. nOpcx == 5
		lAltProg := .f.
	Endif

	If lRespos //Caso utilize o campo memo
		aAdd( aValues , { "TMH_RESPOS " , 5 } )
	Endif

	If ExistBlock("MDTA0551")
		aCampPE := ExecBlock("MDTA0551")
		If ValType( aCampPE ) <> "A"
			aCampPE := {}
		Else
			aArea := getArea()
			For nX := 1 to len(aCampPE)
				If Empty( GetSx3Cache( aCampPE[ nX , 1 ] , "X3_ORDEM" ) ) .Or. ;
					IIf( Len( aCampPE[nX] ) > 1 ,TMH->(FieldPos( aCampPE[nX , 2] ) ) == 0 , .F. )
					aCampPE := {}
					MsgInfo("Um ou mais campos informados no P.E. MDTA0551 no existem em dicionrio, favor incluir os campos.")
					Exit
				EndIf
			Next nX
			restArea(aArea)
			aArea := {}
		EndIf
	EndIf

	If Len( aCampPE ) > 0
		For nCps := 1 To Len( aCampPE )
			If ValType( aCampPE[ nCps , 1 ] ) == "C" .And. NGIFDICIONA( "SX3" , aCampPE[ nCps , 1 ] , 2 )
				aAdd( aFldQst , aCampPE[ nCps , 1 ] )
				aArea := getArea()
				If !Empty( GetSx3Cache( aCampPE[ nCps , 1 ] , "X3_ORDEM" ) ) .And. Len( aCampPe[ nCps ] ) > 1
					cTipo := GetSx3Cache( aCampPE[ nCps , 1 ], "X3_TIPO" )
					cContx := GetSx3Cache( aCampPE[ nCps , 1 ], "X3_CONTEXT" )
					//Verifica se o novo campo possui um SYP e  do tipo Memo. Se sim, adiciona ao aMemos
					If !Empty( aCampPE[nCps , 2] ) .And. cTipo == "M" .And. cContx == "V"
						aAdd( aMemos , { aCampPE[ nCps , 2 ] , aCampPE[ nCps , 1 ] } )
					EndIf
				EndIf
				RestArea(aArea)
			EndIf
		Next nCps
	EndIf

	//Monta os Headers
	aHoBrwA := NGHeadExc( aFldGrp, , .F., .F., aExcGrp )
	aHoBrwB := NGHeadExc( aFldQst, , .F., .F. )

	a00BrwB := BLANKGETD(aHoBrwB)
	a00BrwB[1,aScan(aFldQst,{|x| x == "TMH_INDSEX"})] := "3"
	a00BrwB[1,aScan(aFldQst,{|x| x == "TMH_TPLIST"})] := "1"
	a00BrwB[1,aScan(aFldQst,{|x| x == "TMH_ONMEMO"})] := "2"
	a00BrwB[1,Len(a00BrwB[1])] := Space(6)
	aAdd( a00BrwB[1] , Space(1) )
	aAdd( a00BrwB[1] , .F. )

	dbSelectArea("TMG")
	RegToMemory("TMG",(nOpcx == 3))

	If lSigaMdtps
		If ( nIndTMH := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI+TMH_QUESTA",.T.) ) == 0
			nIndTMH := 1
		EndIf
		cSeekTMH:= cCliMdtps+M->TMG_QUESTI
		cCondTMH:= "TMH->(TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI)"
	Else
		nIndTMH := 1
		cSeekTMH:= M->TMG_QUESTI
		cCondTMH:= "TMH->(TMH_FILIAL+TMH_QUESTI)"
	Endif
	If nOpcx <> 3
		dbSelectArea("TMH")
		dbSetOrder(nIndTMH)
		dbSeek(xFilial("TMH")+cSeekTMH)
		While !Eof() .and. xFilial("TMH")+cSeekTMH == &(cCondTMH)
			If aScan( aCoBrwA, {|x| x[1] == TMH->TMH_CODGRU } ) == 0
				dbSelectArea("TK0")
				dbSetOrder(1)
				dbSeek(xFilial("TK0")+TMH->TMH_CODGRU)
				aAdd( aCoBrwA , { TMH->TMH_CODGRU , TK0->TK0_DESCRI , .F. } )
			Endif
			aAdd( aSvBrwB , { TMH->TMH_CODGRU ,;
										TMH->TMH_PERGUN ,;
										TMH->TMH_TPLIST ,;
										TMH->TMH_ONMEMO ,;
										If( lRespos, TMH->TMH_RESPOS, TMH->TMH_COMBO + TMH->TMH_COMBO2 ) ,;
										TMH->TMH_ORDEM  ,;
										TMH->TMH_QUESTA ,;
										TMH->TMH_DEFAUL ,;
										TMH->TMH_INDSEX , .F. } )
			If Len( aCampPE ) > 0
				For nCps := 1 To Len( aCampPE ) //Adiciona os campos criados pelo PE MDTA0551 ao aSvBrwB
					//Verifica se possui campo SYP. Se sim o cadastra.
					If Len( aCampPE[ nCps ] ) > 1
						aAdd( aSvBrwB[ Len( aSvBrwB ) ] , &( "TMH->" + aCampPE[ nCps , 2 ] ) )
						If ExistIni(aCampPE[ nCps , 1 ])
							aAdd( aSvBrwB[ Len( aSvBrwB ) ] , InitPad( GetSx3Cache( aCampPE[ nCps , 1 ], "X3_RELACAO" ) ) )
						Else
							aAdd( aSvBrwB[ Len( aSvBrwB ) ] , "" )
						EndIf
					Else
						aAdd( aSvBrwB[ Len( aSvBrwB ) ] , &( "TMH->" + aCampPE[ nCps , 1 ] ) )
					EndIf
				Next nCps
			EndIf
			dbSelectArea("TMH")
			dbSkip()
		End
	EndIf
	If Len( aCampPE ) > 0
		nCntCps := 10
		For nCps := 1 To Len( aCampPE ) //Adiciona a posio dos novos campos no aSvBrwB no array aValues.
			nCntCps++
			If Len( aCampPE[nCps]) > 1
				aAdd( aValues , { aCampPE[ nCps , 2 ] , nCntCps } )
				nCntCps++
				aAdd( aValues , { aCampPE[ nCps , 1 ] , nCntCps } )
			Else
				aAdd( aValues , { aCampPE[ nCps , 1 ] , nCntCps } )
			EndIf
		Next nCps
	EndIf

		aCoBrwGru := aClone(aCoBrwA) //Realiza a cpia
		aCoBrwPer := aClone(aSvBrwB) //Realiza a cpia

	If Len(aCoBrwA) == 0
		aCoBrwA := BLANKGETD(aHoBrwA)
	Else
		cGrpTemp := aCoBrwA[1,1]
		For nX := 1 To Len(aSvBrwB)
			If cGrpTemp == aSvBrwB[nX,1]
				If len( aCampPE ) > 0
					//Adiciona uma nova linha no aCols, com um array vazio, do mesmo tamanho do aHeader + 1 para considerar o valor de excluso
					aAdd( aCoBrwB , Array( Len( aHoBrwB ) + 1 ) )
					nPosAdd := Len( aCoBrwB )
					//Roda o aHeader para incluir os valores dos campos correspondentes ao aSvBrwB
					For nCps := 1 to Len(aHoBrwB)
						//Procura no aSvBrwB qual o valor correspondente ao campo do aHeader
						If ( nPos := aScan( aValues , { | x | AllTrim( x[ 1 ] ) == AllTrim( aHoBrwB[ nCps , 2 ] ) } ) ) > 0
							nPos2 := aValues[ nPos , 2 ]
							aCoBrwB[ nPosAdd , nCps ] := aSvBrwB[nX , nPos2]//Adiciona na posio do aCols o valor contido no aSvBrwB
						EndIf
					Next nCps
					//Marca o valor de D_E_L_E_T_
					If ( nPos := aScan( aValues , { | x | x[ 1 ] == "D_E_L_E_T_" } ) ) > 0
						nPos2 := aValues[ nPos , 2 ]
						aCoBrwB[ nPosAdd , Len( aCoBrwB[ nPosAdd ] ) ] := aSvBrwB[nX , nPos2]//Adiciona na posio do aCols o valor contido no aSvBrwB
					EndIf
				Else
					aAdd( aCoBrwB , { aSvBrwB[nX,2] , aSvBrwB[nX,9], aSvBrwB[nX,3] , aSvBrwB[nX,4] , aSvBrwB[nX,5] , aSvBrwB[nX,7] , aSvBrwB[nX,8],.F. } )
				EndIf
			Endif
		Next nX
	Endif
	If Len(aCoBrwB) == 0
		aCoBrwB := aClone(a00BrwB)
	Endif

	//aChoice recebe os campos que serao apresentados na tela
	aNao    := {}
	aChoice := NGCAMPNSX3("TMG",aNao)
	aTela   := {}
	aGets   := {}

	//Tamanho da tela
	Private aAC := {STR0021,STR0022},aCRA:= {STR0022,STR0023,STR0021} //"Abandona"###"Confirma"###"Confirma"###"Redigita"###"Abandona"
	Private aHeader[0],Continua,nUsado:=0
	Private aSize := MsAdvSize(,.f.,430), aObjects := {}
	Aadd(aObjects,{200,200,.t.,.f.})
	aInfo := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
	aPosObj := MsObjSize(aInfo, aObjects,.t.)

	nOpca:=0
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(cCadastro) From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL

	//Cria Painel para adequao da tela.
	oPanelTot := TPanel():New(0,0,,oDlg,,,,,,0,0,.F.,.F.)
			oPanelTot:Align := CONTROL_ALIGN_ALLCLIENT

	//
	//Enchoice tabela TMG                          
	//
	@ 000,000 MSPANEL oPanel SIZE aSize[6],aSize[5] OF oPanelTot
	oPanel:Align := CONTROL_ALIGN_TOP
	oPanel:nHeight := 80
	If lCopia
		oEnc01:= MsMGet():New("TMG",nRecno,3,,,,aChoice,{0,0,40,aPosObj[1,4]},,,,,,oPanel,,,.f.,"aSvATela")
	Else
		oEnc01:= MsMGet():New("TMG",nRecno,nOpcx,,,,aChoice,{0,0,40,aPosObj[1,4]},,,,,,oPanel,,,.f.,"aSvATela")
	EndIf
	oEnc01:oBox:bGotFocus := {|| NgEntraEnc("TMG")}
	aSvATela := aClone(aTela)
	aSvAGets := aClone(aGets)

	nTelaX := ( aSize[6]/2.02 ) - 68
	nTelaY := ( aSize[5]/2.01 ) - 26

	//
	//Tela dos Grupos                              
	//
	@ 000,000 MSPANEL oPanel4 SIZE aSize[5],aSize[6] OF oPanelTot
	oPanel4:Align := CONTROL_ALIGN_ALLCLIENT

	@ 05,001 SAY STR0024 OF oPanel4 Pixel //"Selecione os grupos de perguntas:"
	@ 05,250 SAY STR0025 OF oPanel4 Pixel //"Selecione as perguntas do grupo:"
	@ 04,340 SAY oTextPerf Prompt aCoBrwA[1,2] PIXEL OF oPanel4 Font oFont12

	dbSelectArea("TMH")
	oBrwA   := MsNewGetDados():New(20,1,nTelaX,220,IIF(!lAltProg,0,GD_INSERT+GD_UPDATE+GD_DELETE),;
								{|| .T. },{|| .T. },,,,9999,,,,oPanel4,aHoBrwA,aCoBrwA)

	oBrwA:oBrowse:Default()
	oBrwA:oBrowse:Refresh()
	oBrwA:oBrowse:bChange := {|| fChangeA() }
	oBrwA:oBrowse:bGotFocus := {|| fAltFocus(.T.,.F.) }
	oBrwA:oBrowse:bValid := {|| fAltFocus(.F.,) }
	oBrwA:bLINHAOK := {|| A55LinOK(.T.) }

	@ 40,455 BTNBMP oBtUp01 Resource "PMSSETAUP" Size 29,29 Pixel Of oPanel4 Noborder Pixel Action fPrgNext(1,1) When (Inclui .or. Altera)
	oBtUp01:cToolTip := STR0026 //"Altera a ordem do Grupo."
	@ 80,455 BTNBMP oBtDw01 Resource "PMSSETADOWN" Size 29,29 Pixel Of oPanel4 Noborder Pixel Action fPrgNext(1,2) When (Inclui .or. Altera)
	oBtDw01:cToolTip := STR0026 //"Altera a ordem do Grupo."

	//
	//Tela das Questoes do Grupo                   
	//
	dbSelectArea("TMH")
	oBrwB := MsNewGetDados():New(20,250,nTelaX,nTelaY,IIF(!lAltProg,0,GD_INSERT+GD_UPDATE+GD_DELETE),;
							{|| fLinOK_B(1) },{|| fLinOK_B(2) },,,,9999,,,,oPanel4,aHoBrwB,aCoBrwB)
	oBrwB:oBrowse:Default()
	oBrwB:oBrowse:Refresh()
	oBrwB:oBrowse:bChange := {|| fChangeB() }
	oBrwB:oBrowse:bValid  := {|| fLinOK_B(3) }
	oBrwB:oBrowse:bGotFocus := {|| fAltFocus(.F.,.T.) }
	oBrwB:bLINHAOK := {|| A55LinOK(,.T.) }

	@ 40,(nTelaY*2)+15 BTNBMP oBtUp02 Resource "PMSSETAUP" Size 29,29 Pixel Of oPanel4 Noborder Pixel Action fPrgNext(2,1) When (Inclui .or. Altera)
	oBtUp02:cToolTip := STR0027 //"Altera a ordem da Pergunta."
	@ 80,(nTelaY*2)+15 BTNBMP oBtDw02 Resource "PMSSETADOWN" Size 29,29 Pixel Of oPanel4 Noborder Pixel Action fPrgNext(2,2) When (Inclui .or. Altera)
	oBtDw02:cToolTip := STR0027 //"Altera a ordem da Pergunta."

	dbSelectArea("TMG")

	If lCopia

		RegToMemory( 'TMG', .T., .T. )

		nOpcx := 3

		SetInclui()

	EndIf

	Activate MsDialog oDlg On Init EnchoiceBar(;
		oDlg,;
		{ || nOpca := 1, IIf( !MDT55OK( nOpcx ), nOpca := 0, fControNum( oDlg ) ) },;
		{ || RollBackSX8(), oDlg:End() };
	) CENTERED

	If nOpca == 1
		Begin Transaction
			MDT55Grv(nOpcx)
		End Transaction
	Endif

Return .T.
/*/


Ŀ
Funo    MDTA55BOX  Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Funcao para mostar lista de opes ao entrar no campo      
           TMH_COMBO  e TMH_COMBO2                                    
ٱ


/*/
Function MDT055WBOX()

	Local lRet := .f.
	Local nXX


	Local oChecked := LoadBitmap(GetResources(),'LBTIK')
	Local oUnCheck := LoadBitmap(GetResources(),'LBNO')
	Local aCodBox  := {	"1","2","3","4","5","6","7","8","9",;
						"A","B","C","D","E","F","G","H","I",;
						"J","K","L","M","N","O","P","Q","R",;
						"S","T","U","V","W","X","Y","Z" }

	Private oBoxPerg, aBoxPerg, bBoxPerg

	aBoxPerg := {}

	For nXX := 1 To Len(aCodBox)
		nPos := At( aCodBox[nXX]+"=" , M->TMH_COMBO )
		If nPos > 0
			nPos1 := At( ";" , Substr( M->TMH_COMBO , nPos+2 ) )
			cDesc := Alltrim(Substr( M->TMH_COMBO , nPos+2 ))
			If nPos1 > 0
				cDesc := Alltrim(Substr( M->TMH_COMBO , nPos+2 , nPos1-1 ))
			Endif
			aAdd( aBoxPerg , { .T. , aCodBox[nXX] , PadR(cDesc,30) } )
		Else
			If aCodBox[nXX] == "1"
				aAdd( aBoxPerg , { .F. , aCodBox[nXX] , STR0015 } ) //"Sim"
			ElseIf aCodBox[nXX] == "2"
				aAdd( aBoxPerg , { .F. , aCodBox[nXX] , STR0016 } ) //"Nao"
			ElseIf aCodBox[nXX] == "3"
				aAdd( aBoxPerg , { .F. , aCodBox[nXX] , STR0017 } ) //"Sem Resposta"
			Else
				aAdd( aBoxPerg , { .F. , aCodBox[nXX] , Space(30) } )
			Endif
		Endif
	Next nXX

	opcaoZZ  := 0

	DEFINE MSDIALOG oDlg1 TITLE OemToAnsi(STR0009) from 10,15 To 30,70 COLOR CLR_BLACK,CLR_WHITE of oMainwnd //"Editar Lista de Opes"

		@ 05,9  SAY STR0010 OF oDlg1 Pixel //"Configure a lista de opes:"
		oBoxPerg := VCBrowse():New( 17 , 010, 200, 110,,{' ',STR0018,STR0019},{10,20,130},; //"Opo"###"Descrio"
									oDlg1,,,,,{||},,,,,,,.F.,,.T.,,.F.,,.t.,.t.)
		oBoxPerg:SetArray(aBoxPerg)
		bBoxPerg := { || { If(aBoxPerg[oBoxPerg:nAt,1],oChecked,oUnCheck), aBoxPerg[oBoxPerg:nAt,2], aBoxPerg[oBoxPerg:nAt,3] } }
		oBoxPerg:bLine:= bBoxPerg
		oBoxPerg:bLDblClick := {|| fMarkOpca(oBoxPerg:nColPos) }

		DEFINE SBUTTON FROM 135,155 TYPE 1 ENABLE OF oDlg1 ACTION ( If( fValTRBX(), (opcaoZZ := 1,oDlg1:End()) , opcaoZZ := 0))
		DEFINE SBUTTON FROM 135,185 TYPE 2 ENABLE OF oDlg1 ACTION oDlg1:END()

	ACTIVATE MSDIALOG oDlg1 CENTERED

Return .f.

/*/


Ŀ
Funo     MDT55OK   Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Funcao chamada na validacao do OK                          
Ĵ
 Uso                                                                  
ٱ


/*/
Function MDT55OK(nOpcx)

	Local lRet := .T.
	aCoBrwA := aClone(oBrwA:aCols)
	If Len(aCoBrwA) > 0 .And. Len(aSvBrwB) == 0
		MsgStop(STR0035) //"Para incluir um grupo de perguntas deve-se incluir perguntas ao mesmo."
		lRet := .F.
	EndIf
	If Empty(M->TMG_QUESTI) .Or. Empty(M->TMG_NOMQUE)
		MsgInfo(STR0028,STR0029) //"Alguns campos obrigatrios no foram informados"###"ATENO"
		lRet := .F.
	EndIf
	If nOpcx == 5 .And. lRet
		lRet := NGVALSX9("TMH",{},.T.,.T.)
	EndIf

Return lRet

/*/


Ŀ
Funo    MDT55Grv   Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Funcao chamada para gravacao                               
Ĵ
 Uso                                                                  
ٱ


/*/
Function MDT55Grv(nOpcx)

	Local ny,nx,nZ ,nOrdTMG, nPosTMH
	Local aTMHs := {}
	Local nSizeCli := If((TAMSX3("A1_COD")[1]) < 1,6,(TAMSX3("A1_COD")[1]))
	Local nSizeLoj := If((TAMSX3("A1_LOJA")[1]) < 1,2,(TAMSX3("A1_LOJA")[1]))
	Local nIndTMH, cSeekTMH, cCondTMH
	Local nIndTMI, nIndTO6, cCondTMI
	Local bCampo
	Local aQuest := {}
	Local nC := 0
	Local lTrocaPosic := .F. //Verifica a troca de posio.
	Local nUltTMH := 0
	Local lDelTMH := .T.

	nIndTMH  := 1
	cSeekTMH := TMG->TMG_QUESTI
	cCondTMH := "TMH->(TMH_FILIAL+TMH_QUESTI)"
	nIndTMI  := 2
	cCondTMI := "TMI->(TMI_FILIAL+TMI_QUESTI)"
	nIndTO6  := 2
	If lSigaMdtps
		nIndTMH  := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI+TMH_QUESTA",.T.)
		If nIndTMH == 0
			nIndTMH := 1
		Endif
		cSeekTMH := cCliMdtps+TMG->TMG_QUESTI
		cCondTMH := "TMH->(TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI)"
		nIndTMI  := NGRETORDEM("TMI","TMI_FILIAL+TMI_CLIENT+TMI_LOJA+TMI_QUESTI",.T.)
		If nIndTMI == 0
			nIndTMI := 2
		Endif
		cCondTMI := "TMI->(TMI_FILIAL+TMI_CLIENT+TMI_LOJA+TMI_QUESTI)"

		nIndTO6  := NGRETORDEM("TO6","TO6_FILIAL+TO6_CLIENT+TO6_LOJA+TO6_QUESTI+TO6_QUESTA",.T.)
		If nIndTO6 == 0
			nIndTO6 := 2
		Endif
	Endif

	If nOpcx == 3 .or. nOpcx == 4

		//Inclui ou altera o cadastro do Tipo de Ficha
		dbSelectArea("TMG")
		RecLock("TMG", (nOpcx==3) )
		For ny := 1 To fCount()
			nx := "M->" + FieldName(ny)
			FieldPut(ny, &nx.)
		Next ny
		If nOPCx == 3
			TMG->TMG_FILIAL := xFilial("TMG")
			If lSigaMdtps
				TMG->TMG_CLIENT	:= SubStr(cCliMdtPs,1,nSizeCli)
				TMG->TMG_LOJA	:= SubStr(cCliMdtPs,nSizeCli+1,nSizeLoj)
			Endif
		Endif
		TMG->(MsUnLock())

		If lSigaMdtps
			cSeekTMH := cCliMdtps+TMG->TMG_QUESTI
		Else
			cSeekTMH := TMG->TMG_QUESTI
		Endif

		//Inclui ou altera o cadastro de itens do Tipo de Ficha
		nOrdTMG := 0
		For nx := 1 To Len(aCoBrwA)
			If aCoBrwA[nx,3]
				Loop
			Endif

				If lDelTMH //Verifica se j foi apagados os registros j existentes
					For nC := 1 To Len(aCoBrwGru)
						//Caso tenha alguma posio diferente
						If aCoBrwGru[nC,1] <> aCoBrwA[nC,1] .And. !lTrocaPosic
							lTrocaPosic := .T.  //Caso tenha trocado alguma posio.
						Endif
					Next nC
					If !lTrocaPosic .ANd. Len(aSvBrwB) <> Len(aCoBrwPer) //Verifica se foi alterado a posio de alguma pergunta.
						For nC := 1 To Len(aCoBrwPer)
							If !lTrocaPosic .And. ( aSvBrwB[nC,6] <> aCoBrwPer[nC,6] .Or. aSvBrwB[nC,7] <> aCoBrwPer[nC,7] .Or. aSvBrwB[nC,Len(aSvBrwB[nC])] )
								lTrocaPosic := .T.  //Caso tenha trocado alguma posio.
							EndIf
						Next nC
					Endif
				EndIf

			For ny := 1 To Len(aSvBrwB)
				nPosDel := aScan( aValues , { | x | x[ 1 ] == "D_E_L_E_T_" } )
				If !aSvBrwB[ny,nPosDel] .and. aCoBrwA[nx,1] == aSvBrwB[ny,1] .and. !Empty(aSvBrwB[ny,2])
					nOrdTMG++ //Incrementa Ordem
					nPosOrd := aScan( aValues , { | x | AllTrim( x[ 1 ] ) == "TMH_QUESTA" } )
					nUltTMG := Val(aSvBrwB[ny,aValues[nPosOrd,2]])
					If nUltTMG == 0
						nUltTMG := fUltQuest(cSeekTMH,nIndTMH,cCondTMH)
					Endif
						If !lTrocaPosic //Caso no tenha troca de posio.
					dbSelectArea("TMH")
					dbSetOrder(nIndTMH)
					If dbSeek( xFilial("TMH") + cSeekTMH + StrZero(nUltTMG,3) )
						RecLock("TMH",.F.)
					Else
						RecLock("TMH",.T.)
						TMH->TMH_FILIAL := xFilial("TMH")
						TMH->TMH_QUESTI := TMG->TMG_QUESTI
						TMH->TMH_QUESTA := StrZero(nUltTMG,3)
						If lSigaMdtps
							TMH->TMH_CLIENT	:= SubStr(cCliMdtPs,1,nSizeCli)
							TMH->TMH_LOJA	:= SubStr(cCliMdtPs,nSizeCli+1,nSizeLoj)
						Endif
					Endif
						Else //Caso foi realizado a troca de posio.
							If lDelTMH //Verifica a necessidade de apagar as questes.
								For nC := 1 To Len(aSvBrwB)
									nUltTMH := Val(aSvBrwB[nC,aValues[nPosOrd,2]])
									dbSelectArea("TMH")
									dbSetOrder(nIndTMH)
									If dbSeek( xFilial("TMH") + cSeekTMH + StrZero(nUltTMH,3) ) //Apaga todos os registros existentes
										RecLock("TMH",.F.)
										dbDelete()
										TMH->(MsUnLock())
									Endif
								Next nC
								lDelTMH := .F.
							Endif

							dbSelectArea("TMH") //Posiciona na tabela
							dbSetOrder(nIndTMH)
							If !dbSeek( xFilial("TMH") + cSeekTMH + StrZero(nOrdTMG,3) )//Adiciona o registro novamente.
								RecLock("TMH",.T.)
								TMH->TMH_FILIAL := xFilial("TMH")
								TMH->TMH_QUESTI := TMG->TMG_QUESTI
								TMH->TMH_QUESTA := StrZero(nOrdTMG,3)
								If lSigaMdtps
									TMH->TMH_CLIENT	:= SubStr(cCliMdtPs,1,nSizeCli)
									TMH->TMH_LOJA	:= SubStr(cCliMdtPs,nSizeCli+1,nSizeLoj)
								Endif
							Endif

						Endif
					TMH->TMH_ORDEM  := StrZero(nOrdTMG,6)
					bCampo  := {|nCPO| Field(nCPO) }
					//Roda campos da TMH cadastrando os campos com os dados do aSvBrwB
					For nZ := 1 to FCount()
						If ( nPosTMH := aScan(aValues, {|x| AllTrim( x[1] ) == AllTrim( Field(nZ) ) })) > 0
							If AllTrim( aValues[nPosTMH , 1] ) == "TMH_COMBO"
								TMH->TMH_RESPOS := aSvBrwB[ nY , aValues[nPosTMH , 2] ]
							ElseIf AllTrim( aValues[nPosTMH , 1] ) != "TMH_QUESTA" .And. ;
								AllTrim( aValues[nPosTMH , 1] ) != "TMH_ORDEM"//No inclui TMH->TMH_QUESTA e TMH->TMH_ORDEM novamente
								TMH->&(EVAL(bCampo,nZ)) := aSvBrwB[ nY , aValues[nPosTMH , 2] ]
							EndIf
						EndIf
					Next nZ
					If Len( aMemos ) > 0
						For nZ := 1 to Len(aMemos)
							If ( nPosTMH := aScan(aValues, {|x| AllTrim( x[1] ) == AllTrim( aMemos[nZ][2] ) })) > 0
								cVar :=  aSvBrwB[ nY , aValues[nPosTMH , 2] ]
								cVar1:= aMemos[nZ][1]
								If TMH->(FieldPos(cVar1)) > 0
									If nOPCX == 3
										MSMM(,TamSx3(aMemos[nZ][2])[1],,cVar,1,,,"TMH",aMemos[nZ][1],)
									Else
										MSMM(&cVar1,TamSx3(aMemos[nZ][2])[1],,cVar,1,,,"TMH",aMemos[nZ][1],)
									EndIf
								Endif
							EndIf
						Next nZ
					EndIf
					TMH->(MsUnLock())
					aAdd(aTMHs , TMH->TMH_QUESTA )
				Endif
			Next ny
		Next nx

		dbSelectArea("TMH")
		dbSetOrder(nIndTMH)
		If dbSeek( xFilial("TMH") + cSeekTMH )
			While !Eof() .and. xFilial("TMH") + cSeekTMH == &(cCondTMH)
				If aScan(aTMHs, {|x| x == TMH->TMH_QUESTA }) == 0
					dbSelectArea("TMI")
					dbSetOrder(nIndTMI)
					dbSeek( xFilial("TMI") + cSeekTMH )
					While !Eof() .and. xFilial("TMI") + cSeekTMH == &(cCondTMI)
						If TMH->TMH_QUESTA == TMI->TMI_QUESTA
							dbSelectArea("TMI")
							RecLock("TMI",.F.)
							dbDelete()
							TMI->(MsUnLock())
						Endif
						dbSelectArea("TMI")
						dbSkip()
					End
					dbSelectArea("TMH")
					RecLock("TMH",.F.)
					dbDelete()
					TMH->(MsUnLock())
				Endif
				dbSelectArea("TMH")
				dbSkip()
			End
		Endif

	ElseIf nOpcx == 5

		lDelTMG := .T.
		dbSelectArea("TMI")
		dbSetOrder(nIndTMI)
		If dbSeek( xFilial("TMI") + cSeekTMH )
			cError := AllTrim(FwX2Nome("TMI")) + " (TMI)"
			HELP(" ",1,"NGINTMOD",,cError,5,1)
			lDelTMG := .F.
		Else
			dbSelectArea("TO6")
			dbSetOrder(nIndTO6)
			If dbSeek( xFilial("TO6") + cSeekTMH )
				cError := AllTrim(FwX2Nome("TO6")) + " (TO6)"
				HELP(" ",1,"NGINTMOD",,cError,5,1)
				lDelTMG := .F.
			Endif
		Endif

		dbSelectArea("TMG")
		If lDelTMG
			dbSelectArea("TMH")
			dbSetOrder(nIndTMH)
			dbSeek( xFilial("TMH") + cSeekTMH )
			While !Eof() .and. xFilial("TMH") + cSeekTMH == &(cCondTMH)
				dbSelectArea("TMH")
				RecLock("TMH",.F.)
				dbDelete()
				TMH->(MsUnLock())
				dbSelectArea("TMH")
				dbSkip()
			End

			dbSelectArea("TMG")
			RecLock("TMG", .F. )
			dbDelete()
			TMG->(MsUnLock())
		Endif
	Endif

Return .T.

/*/


Ŀ
Funo     fUltQuest Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Verifica a ultima questao do questionario                  
Ĵ
 Uso                                                                  
ٱ


/*/
Function fUltQuest(cTMG_QUESTI,_nOrdTMH,_cCondTMH)

	Local nRet := 1
	Default _nOrdTMH := 1

	dbSelectArea("TMH")
	dbSetOrder(_nOrdTMH)
	dbSeek( xFilial("TMH") + cTMG_QUESTI + "999999" , .T. )
	If !Found()
	dbSkip(-1)
	Endif
	If !Eof() .and. !Bof() .and. &(_cCondTMH) == xFilial("TMH") + cTMG_QUESTI
		nRet := Val(TMH->TMH_QUESTA) + 1
	Endif

Return nRet

/*/


Ŀ
Funo     fChangeA  Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Funcao chamada ao mudar de linha                           
Ĵ
 Uso                                                                  
ٱ


/*/
Function fChangeA()

	Local nX, nY

	cGrpTemp := oBrwA:aCols[oBrwA:nAt,1]
	oBrwB:aCols := {}

	For nX := 1 To Len(aSvBrwB)
		nPosDel := aScan( aValues , { | x | x[ 1 ] == "D_E_L_E_T_" } )
		If !aSvBrwB[nX,nPosDel]
			If cGrpTemp == aSvBrwB[nX,1]
				aAdd( oBrwB:aCols , {} )
				nPosAdd := Len( oBrwB:aCols )
				//Roda o aHeader para incluir os valores dos campos correspondentes ao aSvBrwB
				For nY := 1 to Len(aHoBrwB)
					//Procura no aSvBrwB qual o valor correspondente ao campo do aHeader
					If ( nPos := aScan( aValues , { | x | AllTrim( x[ 1 ] ) == AllTrim( aHoBrwB[ nY , 2 ] ) } ) ) > 0
						nPos2 := aValues[ nPos , 2 ]
						aAdd( oBrwB:aCols[ nPosAdd ] , aSvBrwB[nX , nPos2] )//Adiciona na posio do aCols o valor contido no aSvBrwB
					EndIf
				Next nY

					//Adiciona o campo de TMH_QUESTA
					If ( nPos := aScan( aValues , { | x | x[ 1 ] == "TMH_QUESTA" } ) ) > 0
						nPos2 := aValues[ nPos , 2 ]
						aAdd( oBrwB:aCols[ nPosAdd ] , aSvBrwB[nX , nPos2] )//Adiciona na posio do aCols o valor contido no aSvBrwB
					EndIf

					//Adiciona o campo de TMH_DEFAUL
					If ( nPos := aScan( aValues , { | x | x[ 1 ] == "TMH_DEFAUL" } ) ) > 0
						nPos2 := aValues[ nPos , 2 ]
						aAdd( oBrwB:aCols[ nPosAdd ] , aSvBrwB[nX , nPos2] )//Adiciona na posio do aCols o valor contido no aSvBrwB
					EndIf

				//Marca o valor de D_E_L_E_T_
				If ( nPos := aScan( aValues , { | x | x[ 1 ] == "D_E_L_E_T_" } ) ) > 0
					nPos2 := aValues[ nPos , 2 ]
					aAdd( oBrwB:aCols[ nPosAdd ] , aSvBrwB[nX , nPos2] )//Adiciona na posio do aCols o valor contido no aSvBrwB
				EndIf
			Endif
		Endif
	Next nX

	If Len(oBrwB:aCols) == 0
		oBrwB:aCols := aClone(a00BrwB)
	Endif

	oTextPerf:SetText(oBrwA:aCols[oBrwA:nAt,2]) //Atualiza texto

	aCoBrwB := aClone(oBrwB:aCols)
	n := 1
	oBrwB:nAt := 1
	oBrwB:lNewLine := .F.
	oBrwB:oBrowse:Refresh()

Return .T.

/*/


Ŀ
Funo     fLinOK_B  Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Valida linha dos itens do grupo                            
Ĵ
 Uso                                                                  
ٱ


/*/
Function fLinOK_B(nTipoC)

	Local nX, nCps, nPos, nPos2, nPosAdd, nPosBkp
	Local nP1 := 4
	Local nP2 := 5
	Local aColsBkp := aClone( oBrwB:aCols )

	If !Empty(aColsBkp[oBrwB:nAt,1]) .or. !Empty(aColsBkp[oBrwB:nAt,nP2])
		If aColsBkp[oBrwB:nAt,nP1] != "1" .And. Empty(aColsBkp[oBrwB:nAt,nP2])
			MsgInfo(STR0030) //" obrigatrio informar a Lista de Opes ou Campo Obs."
			Return .F.
		Endif
	Endif

	cGrpTemp := oBrwA:aCols[oBrwA:nAt,1]
	For nX := 1 To Len(aSvBrwB)
		If cGrpTemp == aSvBrwB[nX,1]
			aSvBrwB[nX, 10] := .T. //D_E_L_E_T_  /*aSvBrwB[nX,Len(aSvBrwB[nX])] := .T.*/
		Endif
	Next nX

		For nX := 1 To Len(aColsBkp)
			If len( aCampPE ) > 0
				//Adiciona uma nova linha no aCols, com um array vazio, do mesmo tamanho do aHeader + 1 para considerar o valor de excluso
				aAdd( aSvBrwB , Array( Len( aValues ) ) )
				nPosAdd := Len( aSvBrwB )
				//Roda o aHeader para incluir os valores dos campos correspondentes ao oBrwA:aCols
				For nCps := 1 to Len(aValues)
					If "TMH_CODGRU" $ aValues[ nCps , 1 ]
						nPosBkp := aValues[ nCps , 2 ]
						aSvBrwB[ nPosAdd, nPosBkp ] := cGrpTemp
					ElseIf "D_E_L_E_T_" $ aValues[ nCps , 1 ]
						nPosBkp := aValues[ nCps , 2 ]
						aSvBrwB[ nPosAdd, nPosBkp ] := .F.
					Else
						If ( nPos := aScan( aHoBrwB , { | x | AllTrim( x[ 2 ] ) == AllTrim( aValues[ nCps , 1 ] ) } ) ) > 0
							nPosBkp := aValues[ nCps , 2 ]
							aSvBrwB[ nPosAdd , nPosBkp ] := aColsBkp[ nX , nPos ]
						Else
							nPosBkp := aValues[ nCps , 2 ]
							If ExistIni(aValues[ nCps , 1 ])
								aSvBrwB[ nPosAdd , nPosBkp ] := InitPad (GetSx3Cache( aValues[ nCps , 1 ], "X3_RELACAO" ) )
							Else
								aSvBrwB[ nPosAdd , nPosBkp ] := ""
							EndIf
						EndIf
					EndIf
				Next nCps
			Else
				If !aColsBkp[nX,Len(aColsBkp[nX])]
					cValue1 := Space(6)
					cValue2 := Space(1)
					If Len( aColsBkp[ nX ] ) > 7
						cValue1 := aColsBkp[nX,6]
						cValue2 := aColsBkp[nX,7]
					EndIf
					aAdd( aSvBrwB , { cGrpTemp , aColsBkp[nX,1] , aColsBkp[nX,3] , aColsBkp[nX,4] , ;
										aColsBkp[nX,5] , ""  , cValue1 , cValue2 , aColsBkp[nX,2], .F. } )
				EndIf
			Endif
		Next nX

		aCoBrwB := aClone(aColsBkp)

		If nTipoC == 3
			fAltFocus(,.F.) //Habilita / Desabilita botes
		Endif
		PutFileInEof("TMH")

Return .T.

/*/


Ŀ
Funo     fChangeB  Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Funcao chamada ao mudar de linha                           
Ĵ
 Uso                                                                  
ٱ


/*/
Function fChangeB()

	Local lTemp
	Local nX

	If Len(oBrwB:aCols[oBrwB:nAt]) < 7
		lTemp := oBrwB:aCols[oBrwB:nAt,Len(oBrwB:aCols[oBrwB:nAt])]
		oBrwB:aCols[oBrwB:nAt,Len(oBrwB:aCols[oBrwB:nAt])] := Space(6)
		aAdd( oBrwB:aCols[oBrwB:nAt] , Space(1) )
		aAdd( oBrwB:aCols[oBrwB:nAt] , lTemp )
	Endif

Return .T.

/*/


Ŀ
Funo     fAltFocus Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Habilita / Desabilita botes                               
Ĵ
 Uso                                                                  
ٱ


/*/
Function fAltFocus(lBrw1,lBrw2)

	If ValType(lBrw1) == "L"
		If lBrw1
			oBtUp01:Enable()
			oBtDw01:Enable()
		Else
			oBtUp01:Disable()
			oBtDw01:Disable()
		Endif
		oBtUp01:Refresh()
		oBtDw01:Refresh()
	Endif
	If ValType(lBrw2) == "L"
		If lBrw2
			oBtUp02:Enable()
			oBtDw02:Enable()
		Else
			oBtUp02:Disable()
			oBtDw02:Disable()
		Endif
		oBtUp02:Refresh()
		oBtUp02:Refresh()
Endif

Return .T.

/*/


Ŀ
Funo    MDTA055OK  Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Valida nome da questao                                     
ٱ


/*/
Function MDTA055OK(nTipo)

	Local xx := 0, lRet := .T.
	Local nX

	If nTipo == 1 //Valida duplicidade Pergunta
		For nX := 1 to Len(oBrwB:aCols)
			If oBrwB:nAt <> nX
				If oBrwB:aCols[nX][1] == M->TMH_PERGUN
					xx++
					Exit
				Endif
			Endif
		Next nX
	ElseIf nTipo == 2 //Valida duplicidade Grupo
		For nX := 1 to Len(oBrwA:aCols)
			If oBrwA:nAt <> nX
				If oBrwA:aCols[nX][1] == M->TMH_CODGRU
					xx++
					Exit
				Endif
			Endif
		Next nX
		If xx == 0
			dbSelectArea("TK0")
			dbSetOrder(1)
			dbSeek(xFilial("TK0")+M->TMH_CODGRU)
			oBrwA:aCols[oBrwA:nAt][2] := TK0->TK0_DESCRI
		Endif
	Endif

	If xx > 0
		Help(" ",1,"JAEXISTINF")
		lRet := .f.
	Endif

Return lRet

/*/


Ŀ
Funo     fPrgNext  Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Altera a posio das linhas na GetDados                    
ٱ


/*/
Function fPrgNext(nTipoGet,nTipoBtn)

	Local aTmp
	Local nPos := 0

	//GetDados - Grupo
	If nTipoGet == 1 .and. Len(oBrwA:aCols) > 1
		If nTipoBtn == 1
			If oBrwA:nAt > 1
				aTmp := aClone(oBrwA:aCols[oBrwA:nAt-1])
				oBrwA:aCols[oBrwA:nAt-1] := aClone(oBrwA:aCols[oBrwA:nAt])
				oBrwA:aCols[oBrwA:nAt]   := aClone(aTmp)
				nPos := oBrwA:nAt - 1
			Endif
		Else
			If oBrwA:nAt < Len(oBrwA:aCols)
				aTmp := aClone(oBrwA:aCols[oBrwA:nAt+1])
				oBrwA:aCols[oBrwA:nAt+1] := aClone(oBrwA:aCols[oBrwA:nAt])
				oBrwA:aCols[oBrwA:nAt]   := aClone(aTmp)
				nPos := oBrwA:nAt + 1
			Endif
		Endif
		If nPos > 0
			oBrwA:nAt := nPos
			oBrwA:oBrowse:nAt := nPos
			oBrwA:oBrowse:nRowPos := nPos
		Endif
		oBrwA:oBrowse:Refresh()

	ElseIf nTipoGet == 2 .and. Len(oBrwB:aCols) > 1
	//GetDados - Questoes
		If nTipoBtn == 1
			If oBrwB:nAt > 1
				aTmp := aClone(oBrwB:aCols[oBrwB:nAt-1])
				oBrwB:aCols[oBrwB:nAt-1] := aClone(oBrwB:aCols[oBrwB:nAt])
				oBrwB:aCols[oBrwB:nAt]   := aClone(aTmp)
				nPos := oBrwB:nAt - 1
			Endif
		Else
			If oBrwB:nAt < Len(oBrwB:aCols)
				aTmp := aClone(oBrwB:aCols[oBrwB:nAt+1])
				oBrwB:aCols[oBrwB:nAt+1] := aClone(oBrwB:aCols[oBrwB:nAt])
				oBrwB:aCols[oBrwB:nAt]   := aClone(aTmp)
				nPos := oBrwB:nAt + 1
			Endif
		Endif
		If nPos > 0
			oBrwB:nAt := nPos
			oBrwB:oBrowse:nAt := nPos
			oBrwB:oBrowse:nRowPos := nPos
		Endif
		oBrwB:oBrowse:Refresh()

	Endif

Return .t.

/*


ͻ
Programa  DESCRIGR  Autor  Taina A. Cardoso     Data   04/11/10   
͹
Desc.     Dispara um gatilho para preencher a descricao do grupo      
           de perguntas.                                              
͹
Uso        MDTA055                                                    
ͼ


*/
Function DESCRIGR()

	If !Empty(M->TMH_CODGRU)
		If aScan( oBrwA:aCols, {|x| x[1] == M->TMH_CODGRU } ) > 0
			MsgStop(STR0036) //"Esse Grupo de Pergunta j esta sendo usado nesse questionrio."
			Return .F.
		EndIf
		If !ExistCpo('TK0',M->TMH_CODGRU)
			Return .F.
		EndIf
	EndIf

	dbSelectArea("TK0")
	dbSetOrder(1)
	If dbSeek(xFilial("TK0")+M->TMH_CODGRU)
		oBrwA:aCols[oBrwA:nAt,2] := TK0->TK0_DESCRI
	EndIf

Return .T.
/*/


Ŀ
Funo    MDTA55BOX  Autor  NG INFORMATICA         Data 01/10/2010
Ĵ
Descrio  Funcao para mostar lista de opes ao entrar no campo      
           TMH_COMBO  e TMH_COMBO2                                    
ٱ


/*/
Function MDT55WBOX(nTipo)

	Local lRet := .f.
	Local nXX
	Local cDefaul  := ""
	Local nPosCmp  := aScan(aHoBrwB, {|x| AllTrim(Upper(X[2])) == "TMH_COMBO" })
	Local oChecked := LoadBitmap(GetResources(),'LBTIK')
	Local oUnCheck := LoadBitmap(GetResources(),'LBNO')
	Local aCodBox  := {	"1","2","3","4","5","6","7","8","9",;
						"A","B","C","D","E","F","G","H","I",;
						"J","K","L","M","N","O","P","Q","R",;
						"S","T","U","V","W","X","Y","Z" }

	Private oBoxPerg, aBoxPerg, bBoxPerg

	M->TMH_COMBO  := oBrwB:aCols[oBrwB:nAt,nPosCmp]
	M->TMH_DEFAUL := oBrwB:aCols[oBrwB:nAt,7]
	aBoxPerg := {}

	For nXX := 1 To Len(aCodBox)
		nPos := At( aCodBox[nXX]+"=" , M->TMH_COMBO )
		If nPos > 0
			nPos1 := At( ";" , Substr( M->TMH_COMBO , nPos+2 ) )
			cDesc := Alltrim(Substr( M->TMH_COMBO , nPos+2 ))
			If nPos1 > 0
				cDesc := Alltrim(Substr( M->TMH_COMBO , nPos+2 , nPos1-1 ))
			Endif
			aAdd( aBoxPerg , { .T. , aCodBox[nXX] , PadR(cDesc,30) } )
		Else
			aAdd( aBoxPerg , { .F. , aCodBox[nXX] , Space(30) } )

		Endif
	Next nXX

	opcaoZZ  := 0

	DEFINE MSDIALOG oDlg1 TITLE OemToAnsi(STR0009) from 10,15 To 30,70 COLOR CLR_BLACK,CLR_WHITE of oMainwnd //"Editar Lista de Opes"

		@ 05,9  SAY STR0010 OF oDlg1 Pixel //"Configure a lista de opes:"
		oBoxPerg := VCBrowse():New( 17 , 010, 200, 110,,{' ',STR0018,STR0019},{10,20,130},; //"Opo"###"Descrio"
									oDlg1,,,,,{||},,,,,,,.F.,,.T.,,.F.,,.t.,.t.)
		oBoxPerg:SetArray(aBoxPerg)
		bBoxPerg := { || { If(aBoxPerg[oBoxPerg:nAt,1],oChecked,oUnCheck), aBoxPerg[oBoxPerg:nAt,2], aBoxPerg[oBoxPerg:nAt,3] } }
		oBoxPerg:bLine:= bBoxPerg
		oBoxPerg:bLDblClick := {|| fMarkOpca(oBoxPerg:nColPos) }

		@ 135,010 SAY STR0031 Of oDlg1 Pixel  //"Opo Default"
		@ 135,047 MSGET M->TMH_DEFAUL Picture "@!" SIZE 10,9 Pixel

		DEFINE SBUTTON FROM 135,155 TYPE 1 ENABLE OF oDlg1 ACTION ( If( fValTRBX2(), (opcaoZZ := 1,oDlg1:End()) , opcaoZZ := 0))
		DEFINE SBUTTON FROM 135,185 TYPE 2 ENABLE OF oDlg1 ACTION oDlg1:END()

	ACTIVATE MSDIALOG oDlg1 CENTERED

Return .f.

/*/


Ŀ
Funo    MDT055RELA Autor  Denis Hyroshi de Souza Data  09/05/08 
Ĵ
Descrio  Relacao do campo TMH_COMBO                                 
ٱ


/*/
Function MDT055RELA()

	Local cRet := PadR( "1="+STR0015+";"+"2="+STR0016+";"+"3="+STR0017 , 250 ) //"Sim"###"Nao"###"Sem Resposta"

Return cRet

/*/


Ŀ
Funo     fValTRBX  Autor  Denis Hyroshi de Souza Data  09/05/08 
Ĵ
Descrio  Funcao para validar a confirmao da tela                  
ٱ


/*/
Static Function fValTRBX()

	Local nXX
	Local nPosCmp := aScan(aHeader, {|x| AllTrim(Upper(X[2])) == "TMH_COMBO" })

	M->TMH_COMBO := ""

	For nXX := 1 To Len(aBoxPerg)
		If aBoxPerg[nXX,1] .and. !Empty(aBoxPerg[nXX,3])
			If !Empty(M->TMH_COMBO)
				M->TMH_COMBO += ";"
			Endif
			M->TMH_COMBO += aBoxPerg[nXX,2] + "=" + Alltrim(Substr(aBoxPerg[nXX,3],1,30))
		Endif
	Next nXX

	If Len(M->TMH_COMBO) > 250
		MsgInfo(STR0013) //"A quantidade de caracteres no campo Editar Opc. ultrapassou 250."
		Return .f.
	ElseIf Empty(M->TMH_COMBO)
		M->TMH_COMBO := "1="+STR0015+";"+"2="+STR0016+";"+"3="+STR0017 //"Sim"###"Nao"###"Sem Resposta"
		MsgInfo(STR0014) //"Nenhum item foi selecionado, portanto, sero consideradas as opes padro (Sim, No e Sem Resposta)."
	Endif

	aCols[n,nPosCmp] := PadR(M->TMH_COMBO,250)

Return .t.

/*


ͻ
Programa  A55CALLCADAutor  Roger Rodrigues      Data   10/12/10   
͹
Desc.     Faz chamada da funcao de cadastro                           
                                                                      
͹
Uso       MDTA055                                                     
ͼ


*/
Function A55CALLCAD(cAlias, nRecno, nOpcx)

	If nOpcx != 4 .Or. fValInt()
		MDTA55CAD( cAlias, nRecno, nOpcx )
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fValInt
Valida a integridade do registro para permitir alterao

@author Gabriel Sokacheski
@since 29/04/2024	

@return, lRet, verdadeiro se for permitido alterar
/*/
//-------------------------------------------------------------------
Static Function fValInt()

	Local lRet := .T.

	If !FwIsInCallStack( 'A55COPY' ) .And. !FwCheckSX9( 'TMG', Nil, { 'TMH' }, Nil, .F. )

		//-------------------------------------------------------------------------------
		// Mensagens:
		// "Ateno"
		// "Alterao no permitida, existe uma resposta cadastrada para o questionrio"
		// "Verifique a integridade da informao acima nas tabelas TMI, TO6 e TOX"
		//-------------------------------------------------------------------------------
		Help( Nil, Nil, STR0029, Nil, STR0037 + '.', 1, 0, Nil, Nil, Nil, Nil, Nil, { STR0038 + '.' } )

		lRet := .F.

	EndIf

Return lRet

/*


ͻ
Programa  A55CHECQUEAutor  Taina A. Cardoso     Data   22/09/11   
͹
Desc.     Verifica se foi respondido algum questionario com o tipo de 
          sexo alterado.                                              
͹
Uso        MDTA055                                                    
ͼ


*/
Function A55CHECQUE()

	Local cSexo := ""
	Local nPos := aScan( aValues , { | x | AllTrim( x[ 1 ] ) == "TMH_INDSEX" } )

	dbSelectArea("TO6")
	dbSetOrder(2)
	If dbSeek(xFilial("TO6")+M->TMG_QUESTI+oBrwB:aCols[oBrwB:nAt,nPos])
		While !Eof() .And. xFilial("TO6") + M->TMG_QUESTI + oBrwB:aCols[oBrwB:nAt,nPos] == TO6->TO6_FILIAL+TO6->TO6_QUESTI+TO6->TO6_QUESTA
			dbSelectArea("TNC")
			dbSetOrder(1)
			If dbSeek(xFilial("TNC")+TO6->TO6_ACIDEN)
				If !Empty(TNC->TNC_NUMFIC)
					dbSelectArea("TM0")
				dbSetOrder(1)
					If dbSeek(xFilial("TM0")+TNC->TNC_NUMFIC)
						cSexo := TM0->TM0_SEXO
						If cSexo == "1" .And. M->TMH_INDSEX == "2"
							MsgStop(STR0032) //"Essa pergunta ja foi respondida por um funcionrio do sexo masculino, sendo assim no pode ser alterada para o sexo oposto."
							Return .F.
						ElseIf cSexo == "2" .And. M->TMH_INDSEX == "1"
							MsgStop(STR0033) //"Essa pergunta ja foi respondida por um funcionrio do sexo feminino, sendo assim no pode ser alterada para o sexo oposto."
							Return .F.
						EndIf
					EndIf
				EndIf
			EndIf
			dbSelectArea("TO6")
			dbSkip()
		End
	Endif

Return .T.

/*/


Ŀ
Funo    A55COPY    Autor Robson Pereira          Data 02/01/2012
Ĵ
Descrio  Copia questionario que esta selecionado                    
Ĵ
 Uso       MDTA055                                                    
ٱ


/*/
Function A55COPY()

	Local nRecno := TMG->(Recno()),lOk := .T.
	Private lCopia := .f.

	If xFilial("TMG") != TMG->TMG_FILIAL .Or. (TMG->(Eof()) .And. TMG->(Bof()))
	HELP(" ",1,"ARQVAZIO")
	lOk := .F.
	Endif

	If lOk
	lCopia := .t.
	A55CALLCAD("TMG",nRecno,4)
	lCopia := .f.
	EndIf

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTA055
Valida a cada linha incluida na GetDados.

@return Nil

@sample
A55LinOK(.T.)

@author Rodrigo Soledade
@since 21/01/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function A55LinOK(lLinA,lLinB)

	Local lRet := .T.
	Default lLinA := .F.
	Default lLinB := .F.

	If lLinA
		If Empty(oBrwA:aCols[oBrwA:nAt,1])
			lRet := .F.
		EndIf
	Else
		If Empty(oBrwB:aCols[oBrwB:nAt,1])
			lRet := .F.
		EndIf
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fControNum
Confirma a numerao e fecha a tela.

@author Gabriel Sokacheski
@since 18/02/2022

@param oDlg, Objeto, Tela da rotina.
/*/
//-------------------------------------------------------------------
Static Function fControNum( oDlg )

	ConfirmSX8()
	oDlg:End()

Return
