#INCLUDE "MNTA400.CH"
#INCLUDE "PROTHEUS.CH"

Static lHasMNTREQ := !Empty( SuperGetMV( 'MV_MNTREQ', .F., '' ) ) // Param. utilizado para realizar requisições ao estoque.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA400
Programa para Retorno das OS de manutencao
@author Inacio Luiz Kolling
@since 13/06/97
@version undefined
@param cPlano, characters
@type function
/*/
//---------------------------------------------------------------------
Function MNTA400(cPlano)

	//+-------------------------------------------------------------------+
	//| Guarda conteudo e declara variaveis padroes						  |
	//+-------------------------------------------------------------------+
	Local aNGBEGINPRM  := NGBEGINPRM()

	If !FindFunction( 'MNTAmIIn' ) .Or. MNTAmIIn( 19, 95, 35 )

		Private lCervPetro  := .F.
		Private aRotina     := MenuDef()
		Private aIndSTJ     := {}
		Private aInsFPre    := {}
		Private aChoice		:= {}
		Private bFiltraBrw  := {|| Nil}
		Private lTLTTIPINS  := .T.
		Private nOPCAO      := .F.
		Private nOPCAO2     := .T., LCORRET := .F.
		Private cPla        := cPlano
		Private lRETORNO    := .F.
		Private lFILBRW     := .T.
		Private c002FILBem  := ""
		Private cArqF3      := ""
		Private cCampoF3    := ""
		Private cNGINSPREA  := "R" //Indica se o insumo e realizado ou previsto, nao deve ser retirado
		//esta variavel ela e usada para fazer checagem em funcoes dos ng..

		Private nCONTOL1    := 0 // Utilizado no ponto de entrada MNTA4002
		Private nCONTOL2    := 0 // Utilizado no ponto de entrada MNTA4002
		Private cRetfil400
		Private lFoiF6      := .F.
		Private lTelaEtapa  := .F.
		Private aCposAlTPQ  := {}
		Private lCriouTRBQ  := .F.
		Private cLocaliz    := Space( TAMSX3('TPS_CODLOC')[1] )  //Codigo de Localizacao
		Private lTesGar     := .F.
		Private cPar01      := Space(6)
		Private cPar02      := Space(6)
		Private cPar05      := Space(3)
		Private aTROCAF3    := {}
		Private lWhenOs     := .T.
		Private lFun        := .F.
		Private dDtFolha
		Private cHorIniF
		Private cHorFimF
		Private cSerefor    := Alltrim(GETMV("MV_NGSEREF"))
		Private cSercons    := Alltrim(GETMV("MV_NGSECON"))
		Private lIntSFC     := FindFunction("NGINTSFC") .And. NGINTSFC() // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]
		Private lMMoeda     := NGCADICBASE("TL_MOEDA","A","STL",.F.) // Multi-Moeda

		Private oTmpTbl3 //Obj. Tab. Temporária 3
		Private oTmpTbl4 //Obj. Tab. Temporária 4
		Private oTmpTbl5 //Obj. Tab. Temporária 5
		Private oTmpTbl6 //Obj. Tab. Temporária 6
		Private oTmpTbl7 //Obj. Tab. Temporária 7

		Private lTmpTbl6 := .F.// Variavel de controle para deletar Tabelas Temporárias

		Private cTRBQ400 := '' // Alias Tab. 3 e 6
		Private cTRB3400 := '' // Alias Tab. 4
		Private cTRBQBKP := '' // Alias Tab. 5
		Private cTRBZ400 := '' // Alias Tab. 8

		Private cTENDFLAHA  := AllTrim( GetMv( "MV_NGTNDFL" ) ) //Tornada leitura do parametro para não refazer a leitura em outros pontos.

		If FindFunction( 'MNTA400A' )

			If !NGCADICBASE("TB0_FILORD","A","TB0",.F.) .And. NGFUNCRPO("SgaMntEst",.F.) .And. GetMv("MV_SGAMNT") == "S" .And. GetMv("MV_NGSGAES") <> "N"
				If !NGINCOMPDIC("UPDSGA01","00000015391/2010")
					Return
				EndIf
			EndIf

			SETKEY(VK_F8, {|| NGINSUPRE()})
			SETKEY(VK_F5, {|| ShowF4MNT()})

			// VERIFICA SE TEM INTEGRACAO COM MICROSIGA
			cUSAINT1  := AllTrim(GETMv("MV_NGMNTPC"))
			cUsaInt2  := AllTrim(GetMv("MV_NGMNTCM"))
			cUsaInt3  := AllTrim(GetMv("MV_NGMNTES"))
			cUIntHis  := AllTrim(GetMv("MV_NGHISES"))
			MV_PAR02  := Space(6)
			MV_PAR01  := Space(6)
			aTROCAF3  := {}
			aARTAR    := {}
			lINVERTE  := .F.
			cMARCA    := GetMark()
			lQUERY    := .T.

			Private cCADASTRO := Oemtoansi(STR0011) //"Retorno Manutencao"
			aPOS1 := {15,1,95,315}
			dbSelectArea("STJ")

			nINDSTJ := INDEXORD()

			dbGoBottom()
			nREGFIM := Recno()

			//--inicio--SS 027154 //
			// Foi alterada essa validação para permitir fazer o retorno de OS de outras filiais.
			SetBrwCHGAll( .T. )   // Apresenta a tela para informar a filial.
			//---fim----SS 027154 //

			If ExistBlock("MNTA400H")
				Execblock("MNTA400H",.F.,.F.)
			Else
				mBrowse(6,1,22,75,"STJ",,,,,,NGCRIACOR(),,,,,,,,fFilterbrw())
			EndIf

		Else

			// A rotina de Retorno (MNTA400) encontra-se em uma versão desatualizada, desta forma ela não será executada.
			// Baixe e aplique a última versão das rotinas MNTA400 e MNTA400A para prosseguir com a utilização do Retorno.
			Help( '', 1, 'MNTA400',, STR0440, 2, 0,,,,,, { STR0441 } )

		EndIf

		dbSelectArea( 'STJ' )
		Set Filter To

		dbSelectArea( 'STJ' )
		dbSetOrder( 1 )
		dbSeek( xFilial( 'STJ' ) )

	EndIf

	NGRETURNPRM( aNGBEGINPRM ) // Retorna conteudo de variaveis padroes

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400FIM
Programa para finalizacao OS de servico de Manutencao
@author Inacio Luiz Kolling
@since 13/06/97
@version undefined
@param cALIAS, characters
@param nREG, numeric
@param nOPCX, numeric
@type function
/*/
//---------------------------------------------------------------------
Function NG400FIM(cALIAS,nREG,nOPCX)

	Local cGERAPREV  := AllTrim(GETMv("MV_NGGERPR")),cTIPOCON := " "
	Local cRet400
	Local nRECNSTJ
	Local cParSX6Ret, lRetNgRep := .F.
	Local nCont, nI
	Local aChoiceADD := {}
	Local lSemIns    := .F.
	Local cFilBem    := ""
	Local lIntSFC    := FindFunction("NGINTSFC") .And. NGINTSFC() // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]
	Local lMMoeda    := NGCADICBASE("TL_MOEDA","A","STL",.F.) // Multi-Moeda
	Local cQueryTPL  := ""
	Local cAliasTPL  := GetNextAlias()
	Local lIntTEC 	 := .F.
	Local oTmpTbl1
	Local cLanex     := IIf( FindFunction('NGUSELANEX'), NGUSELANEX( TQA->TQA_CODBEM ) , ;
						AllTrim( SuperGetMv( 'MV_NGLANEX', .F., '' ) )  )

	Private cTRBP400 := GetNextAlias()
	Private cEmptyHour := "  :  "
	Private lFimOSWhen := .T.
	Private aCHKDEL    := {}, bNGGRAVA, TIPOACOM := .F., TIPOACOM2 := .F., lINSUSRET := .F.
	Private cTENDFLAHA  := AllTrim( GetMv( "MV_NGTNDFL" ) ) //Tornada leitura do parametro para não refazer a leitura em outros pontos.

	dbSelectArea('TEW')
	lIntTEC := FindFunction("At800OsxTec") .And. ( TEW->(FieldPos('TEW_TPOS')) > 0 )

	cQueryTPL := " SELECT COUNT(TPL_ORDEM) AS TOTAL FROM " + RetSQLName("TPL") + " TPL "
	cQueryTPL += " WHERE TPL_FILIAL = " + ValToSQL(xFilial("STJ"))
	cQueryTPL += " AND TPL_ORDEM    = " + ValToSQL(STJ->TJ_ORDEM)
	cQueryTPL += " AND (TPL_DTFIM   = ''"
	cQueryTPL += " OR TPL_HOFIM     = '')"
	cQueryTPL += " AND D_E_L_E_T_ = ' '"

	cQueryTPL := ChangeQuery(cQueryTPL)

	dbUseArea(.T., "TOPCONN", TCGENQRY(,, cQueryTPL), cAliasTPL, .F., .T.)

	cLocaliz := Space( TAMSX3("TPS_CODLOC")[1] )  //CÓdigo de Localização
	cCodBem  := STJ->TJ_CODBEM
	cOrdem   := STJ->TJ_ORDEM
	cPlano   := STJ->TJ_PLANO
	aInsFPre := {}
	nRET     := 0

	//-----------------------------------------------------------
	// Verifica se não há pneus aguardando aplicação
	//-----------------------------------------------------------
	If FindFunction( 'MNTVLDFIN' ) .And. !MNTVLDFIN( STJ->TJ_ORDEM )[1]
		Return .F.
	EndIf

	If FindFunction("NGVLDSTL") .And. !NGVLDSTL(STJ->TJ_ORDEM) // verifica se não existe insumo com data e hora inicial igual a data e hora final
		Return .F.
	EndIf

	If NGFUNCRPO("NGRESPETAEX",.F.)
		If !NGRESPETAEX(STJ->TJ_ORDEM,.T.)
			Return
		EndIf
	EndIf

	cRet400 := SuperGetMv("MV_NGUSUAL",.F.," ")
	If !Empty(cRet400)
		If !(Upper(AllTrim(cUsername)) $ Upper(AllTrim(cRet400)))
			MsgStop(STR0192,STR0025) //"Usuário não autorizado para encerrar a O.S." #"ATENÇÃO"
			Return .F.
		EndIf
	EndIf

	If ExistBlock("MNT40011")
		lRet := ExecBlock("MNT40011",.F.,.F.)
		If !lRet
			Return .F.
		EndIf
	EndIf

	// Se estiver integrado ao SIGASFC
	// Verifica se é possível finalizar a O.S.
	If lIntSFC .And. !NGSFCATPRD(STJ->TJ_ORDEM,{{"CZ2_LGMN",.F.}},.F.,.F.)
		NGSFCSNDML(4, {{STJ->TJ_ORDEM}})
		Return .F.
	EndIf

	lTEMINUS := .T.
	lPDR     := .F.
	dDTMRINI := STJ->TJ_DTMRINI
	dDTMRFIM := STJ->TJ_DTMRFIM
	cHOMRINI := STJ->TJ_HOMRINI
	cHOMRFIM := STJ->TJ_HOMRFIM
	nCONTOL1 := STJ->TJ_POSCONT
	nCONTOL2 := STJ->TJ_POSCON2

	cUSAINT1 := AllTrim(GETMv("MV_NGMNTPC"))
	cUsaInt2 := AllTrim(GetMv("MV_NGMNTCM"))
	cUsaInt3 := AllTrim(GetMv("MV_NGMNTES"))
	lESTNEGA := If(AllTrim(GETMV("MV_ESTNEG")) == 'S',.T.,.F.)

	If cUsaInt3 == 'S'
		dbSelectArea("SC2")
		dbSetOrder(01)
		If !dbSeek(xFilial("SC2")+STJ->TJ_ORDEM+'OS001')
			MsgInfo(STR0112+STJ->TJ_ORDEM+STR0113+chr(13)+chr(13)+STR0114,STR0025)
			Return
		EndIf
	EndIf

	dbSelectArea("STJ")
	nINDSTJ   := IndexOrd()
	nRECSTJ   := Recno()

	MV_PAR01  := STJ->TJ_CODBEM
	MV_PAR02  := STJ->TJ_SERVICO
	MV_PAR05  := STJ->TJ_SEQRELA
	cPar01    := MV_PAR01
	cPar02    := MV_PAR02
	cPar05    := MV_PAR05

	If STJ->TJ_TIPOOS = "B"
		If !NGBEMATIV(STJ->TJ_CODBEM)
			Return .F.
		EndIf

		If !NGMANATIV(STJ->TJ_CODBEM,STJ->TJ_SERVICO,STJ->TJ_SEQRELA)
			Return .F.
		EndIf
	EndIf

	dULMES := GETMV("MV_ULMES")

	If Empty(STJ->TJ_ORDEM)
		Help(" ",1,"ARQVAZIO")
		Return Nil
	EndIf

	If STJ->TJ_TERMINO == "S"
		Help(" ",1,"OSJAFINAL")
		Return Nil
	EndIf

	cBEMRET := Space(Len(STJ->tj_codbem))
	cBEMRET := NGTBEMPAI(STJ->tj_codbem,cBEMRET)
	cBEMRET := If(Empty(cBEMRET),STJ->tj_codbem,cBEMRET)
	cTIPOCON := NGSEEK("ST9",cBEMRET,1,"T9_TEMCONT")

	TIPOACOM := (cTIPOCON == "S")
	nCONTBEM := ST9->T9_POSCONT
	nCONTSTJ := 0

	//FindFunction remover na release GetRPORelease() >= '12.1.027'
	If FindFunction("MNTCont2")
		TIPOACOM2 := MNTCont2(xFilial("TPE"), cBemRet )
	Else
		dbSelectArea("TPE")
		dbSetOrder(01)
		TIPOACOM2 := dbSeek(xFilial("TPE")+cBemRet)
	EndIf

	dbSelectArea("STJ")
	If lTEMINUS
		lPDR := NGCHKRET(STJ->TJ_ORDEM,STJ->TJ_PLANO)
	EndIf

	bNGGRAVA := {|| NG400CHKFIM()}
	aCHOICE  := {"TJ_ORDEM","TJ_DTPRINI","TJ_DTPRFIM","TJ_HOPRINI","TJ_HOPRFIM","TJ_POSCONT","TJ_HORACO1","TJ_POSCON2","TJ_HORACO2",;
				 "TJ_DTMRINI","TJ_HOMRINI","TJ_DTMRFIM","TJ_HOMRFIM"}
	aAdd(aCHOICE,"TJ_OBSERVA")

	If ExistBlock("MNT40017")
		ExecBlock("MNT40017",.F.,.F.)
	EndIf

	//FORCA A DIGITACAO DA IRREGULARIDADE
	If cTENDFLAHA <> "N" .And. STJ->TJ_PLANO == "000000" //os corretiva
		aAdd(aCHOICE,"TJ_OBSERVA")
		aAdd(aCHOICE,"TJ_IRREGU")
		aAdd(aCHOICE,"TJ_NIRREGU")
	EndIf

	cParSX6Ret := SuperGetMv("MV_NGREPRE",.F.," ")
	lRetNgRep  := If(cParSX6Ret == Nil .Or. Empty(cParSX6Ret) .Or. Alltrim(cParSX6Ret) == "N",.F.,.T.)
	If !lPDR .And. lRetNgRep
		aArraIPre := NG400VINPR() //Verifica se tem algum insumo faltando reportar a quantidade prevista
		lINSUSRET := If(!Empty(aArraIPre),.T.,.F.)
	EndIf

	If NGUSATARPAD()
		LCORRET := If(Val(STJ->tj_plano) = 0,.T.,.F.)
	EndIf

	//+-------------------------------------------------------------------+
	//| Ponto de entrada que indica se a O.S 							  |
	//| podera ser finalizada sem insumos    							  |
	//+-------------------------------------------------------------------+
	If ExistBlock("NGSEMINS")
		lSemIns := ExecBlock("NGSEMINS",.F.,.F.)
		lSemIns := If(ValType(lSemIns) == "L",lSemIns,.F.)
	EndIf

	If (cAliasTPL)->TOTAL == 0
		If !lSemIns .And. (lPDR .Or. lINSUSRET)

			cPrograma := "NG400PA"
			aDBFP     := STL->(dbStruct())

			//Instancia classe FWTemporaryTable
			oTmpTbl1:= FWTemporaryTable():New( cTRBP400, aDBFP )
			//Adiciona os Indices
			oTmpTbl1:AddIndex( "Ind01" , {"TL_FILIAL"} )
			//Cria a tabela temporaria
			oTmpTbl1:Create()

			aHEAINS   := {}
			aGETINS   := {}

			nRETPRD   := NG400PADRA()

			If lPDR

				If nRETPRD == 1
					// VERIFICA A DATA E HORA FINAL PARA O.S. COM INSUMOS PREVISTOS

					vVETDTH := NGDATHOPR(STJ->TJ_ORDEM,STJ->tj_plano,aHEAINS,aGETINS,.T.,lPDR)

					If !vVETDTH[1]
						Return
					EndIf
					dDTINI := vVETDTH[3]
					hORINI := vVETDTH[4]
					dDTFIM := vVETDTH[5]
					hORFIM := vVETDTH[6]
					vCONLA := NGACUMEHIS(cBEMRET,dDTFIM,hORFIM,1,IIf(!Empty(cLanex),"E","P"))
					aRELAC := MNT400RELAC(,'I')

					If ExistBlock("MNT40012")
						aRelacPE := ExecBlock("MNT40012",.F.,.F.)
					EndIf
					If(Type("aRelacPE") == "A")
						If Len(aRelacPE) > 0
							For nCont := 1 To Len(aRelacPE)
								aAdd(aRELAC,aRelacPE[nCont])
							Next
						EndIf
					EndIf
					lInsDifPro := .T.
					lFimOsWhen := .T.
					nTIPOINS := aSCAN(aHEAINS,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
					For nI := 1 to Len(aGETINS)
						If !aGETINS[nI][Len(aGETINS[nI])] .And. (aGETINS[nI][nTIPOINS] == "T" .OR.;
						aGETINS[nI][nTIPOINS] == "F" .OR. aGETINS[nI][nTIPOINS] == "M")
							lInsDifPro := .F.
							lFimOSWhen := .F.
						EndIf
					Next

					If lInsDifPro
						MNT400RELAC(lInsDifPro)
					EndIf

					bNGGRAVA := { | | NG400CHKFIM( lInsDifPro ) .And.;
						NGFINALPD2( STJ->TJ_ORDEM, STJ->TJ_PLANO ) }

					nRET := NGCAD01( 'STJ', STJ->( RecNo() ), 4 )

					If nRET == 1

						nCONTSTJ := STJ->TJ_POSCONT

						If ExistBlock( 'NGFIMPAD' )

							ExecBlock("NGFIMPAD",.F.,.F.)

						EndIf

					EndIf

				Else
					cPrograma := "MNTA400"
					oTmpTbl1:Delete()//Deleta Tabela Temporária
					Return
				EndIf

			Else

				If nRETPRD == 1

					// VERIFICA A DATA E HORA FINAL PARA O.S. COM INSUMOS PREVISTOS
					vVETDTH := NGDATHOPR(STJ->TJ_ORDEM,STJ->tj_plano,aHEAINS,aGETINS,.T.,lPDR)
					If !vVETDTH[1]
						Return
					EndIf
					dDTINI1 := vVETDTH[3]
					hORINI1 := vVETDTH[4]
					dDTFIM1 := vVETDTH[5]
					hORFIM1 := vVETDTH[6]

					// VERIFICA A DATA E HORA FINAL PARA O.S. COM INSUMOS REAL
					vVETDTH1 := NGDATHOSTL(STJ->TJ_ORDEM,STJ->tj_plano,.T.)
					If !vVETDTH[1]
						Return
					EndIf

					dDTINI2 := IIF(!Empty(vVETDTH1[3]),vVETDTH1[3],STJ->TJ_DTMPINI)
					hORINI2 := IIF(vVETDTH1[4] != '  :  ',vVETDTH1[4],STJ->TJ_HOMPINI)
					dDTFIM2 := IIF(!Empty(vVETDTH1[5]),vVETDTH1[5],STJ->TJ_DTMPINI)
					hORFIM2 := IIF(vVETDTH1[6] != '  :  ',vVETDTH1[6],STJ->TJ_HOMPINI)

					If dDTINI1 == dDTINI2
						If hORINI1 > hORINI2
							hORINI := hORINI1
						Else
							hORINI := hORINI2
						EndIf
						dDTINI := dDTINI1
					Else
						If dDTINI1 > dDTINI2
							dDTINI := dDTINI1
							hORINI := hORINI1
						Else
							dDTINI := dDTINI2
							hORINI := hORINI2
						EndIf
					EndIf

					If dDTFIM1 == dDTFIM2
						If hORFIM1 > hORFIM2
							hORFIM := hORFIM1
						Else
							hORFIM := hORFIM2
						EndIf
						dDTFIM := dDTFIM1
					Else
						If dDTFIM1 > dDTFIM2
							dDTFIM := dDTFIM1
							hORFIM := hORFIM1
						Else
							dDTFIM := dDTFIM2
							hORFIM := hORFIM2
						EndIf
					EndIf

					vCONLA := NGACUMEHIS(cBEMRET,dDTFIM,hORFIM,1,IIf(!Empty(cLanex),"E","P"))
					lFimOSWhen := NGINSPRODDH(STJ->TJ_ORDEM,STJ->TJ_PLANO)[1]
					aRELAC := MNT400RELAC(,'I')

					If ExistBlock("MNT40012")
						aRelacPE := ExecBlock("MNT40012",.F.,.F.)
					EndIf
					If(Type("aRelacPE") == "A")
						If Len(aRelacPE) > 0
							For nCont := 1 To Len(aRelacPE)
								aAdd(aRELAC,aRelacPE[nCont])
							Next
						EndIf
					EndIf

					bNGGRAVA := { | | NG400CHKFIM() .And.;
						NGFINALPD2( STJ->TJ_ORDEM, STJ->TJ_PLANO ) }

					nRET := NGCAD01( 'STJ', STJ->( RecNo() ) , 4 )

					If nRET == 1

						nCONTSTJ := STJ->TJ_POSCONT

						If ExistBlock( 'NGFIMPAD' )

							ExecBlock("NGFIMPAD",.F.,.F.)

						EndIf

					EndIf

				Else
					// VERIFICA A DATA E HORA FINAL PARA O.S. COM INSUMOS REAL
					vVETDTH := NGDATHOSTL(STJ->TJ_ORDEM,STJ->tj_plano,.T.)
					If !vVETDTH[1]
						Return
					EndIf

					dDTINI := IIF(!Empty(vVETDTH[3]),vVETDTH[3],STJ->TJ_DTMPINI)
					hORINI := IIF(vVETDTH[4] != '  :  ',vVETDTH[4],STJ->TJ_HOMPINI)
					dDTFIM := IIF(!Empty(vVETDTH[5]),vVETDTH[5],STJ->TJ_DTMPINI)
					hORFIM := IIF(vVETDTH[6] != '  :  ',vVETDTH[6],STJ->TJ_HOMPINI)
					vCONLA := NGACUMEHIS(cBEMRET,dDTFIM,hORFIM,1,IIf(!Empty(cLanex),"E","P"))
					aRELAC := MNT400RELAC(,'I')

					If ExistBlock("MNT40012")
						aRelacPE := ExecBlock("MNT40012",.F.,.F.)
					EndIf
					If(Type("aRelacPE") == "A")
						If Len(aRelacPE) > 0
							For nCont := 1 To Len(aRelacPE)
								aAdd(aRELAC,aRelacPE[nCont])
							Next
						EndIf
					EndIf

					dbSelectArea("STJ")
					nRET  :=  NGCAD01("STJ",nREG,4)
				EndIf

			EndIf

			bNGGRAVA := { || NG400CHKFIM() }

			cPrograma := "MNTA400"
			oTmpTbl1:Delete()//Deleta Tabela Temporária

		Else

			// VERIFICA A DATA E HORA FINAL PARA O.S. COM INSUMOS REAL

			vVETDTH := NGDATHOSTL(STJ->TJ_ORDEM,STJ->tj_plano,.T.)
			If !vVETDTH[1]
				Return
			EndIf

			dDTINI := IIF(!Empty(vVETDTH[3]),vVETDTH[3],STJ->TJ_DTMPINI)
			hORINI := IIF(vVETDTH[4] != '  :  ',vVETDTH[4],STJ->TJ_HOMPINI)
			dDTFIM := IIF(!Empty(vVETDTH[5]),vVETDTH[5],STJ->TJ_DTMPINI)
			hORFIM := IIF(vVETDTH[6] != '  :  ',vVETDTH[6],STJ->TJ_HOMPINI)
			vCONLA := NGACUMEHIS(cBEMRET,dDTFIM,hORFIM,1,IIf(!Empty(cLanex),"E","P"))
			aRELAC := MNT400RELAC(,'I')
			MNT400RELAC()

			If ExistBlock("MNT40012")
				aRelacPE := ExecBlock("MNT40012",.F.,.F.)
			EndIf
			If(Type("aRelacPE") == "A")
				If Len(aRelacPE) > 0
					For nCont := 1 To Len(aRelacPE)
						aAdd(aRELAC,aRelacPE[nCont])
					Next
				EndIf
			EndIf

			dbSelectArea("STJ")
			nRET  :=  NGCAD01("STJ",nREG,4)
		EndIf

		dbSelectArea("STJ")
		nRECNSTJ := Recno()

		If nRET == 1

			cAORDEM   := STJ->TJ_ORDEM
			cAPLANO   := STJ->TJ_PLANO
			cACODBEM  := STJ->TJ_CODBEM
			cASERVICO := STJ->TJ_SERVICO
			nASEQUENC := STJ->TJ_SEQRELA
			nCONTSTJ  := STJ->TJ_POSCONT
			nDIFX     := nCONTSTJ - nCONTBEM
			nDIF      := If(nDIFX > 0,nDIFX,0)

			If lTEMINUS
				NGFINAL(STJ->TJ_ORDEM,STJ->TJ_PLANO,STJ->TJ_DTPRINI,STJ->TJ_HOPRINI,;
				STJ->TJ_DTPRFIM,STJ->TJ_HOPRFIM,STJ->TJ_POSCONT,STJ->TJ_POSCON2,;
				cBEMRET,STJ->TJ_HORACO1,STJ->TJ_HORACO2,nDIF,,,,,cFilBem)
			Else
				dbSelectArea("STF")
				dbSetOrder(1)
				If dbSeek(xFilial("STF")+STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA)
					RecLock("STF",.F.)
					STF->TF_QUANTOS := STF->TF_QUANTOS + 1
					If STF->( FieldPos("TF_CONPREV") ) > 0
						STF->TF_CONPREV := STF->TF_CONPREV + STF->TF_INENMAN
					EndIf
					MsUnLock('STF')
				EndIf

				dbSelectArea("STJ")
				RecLock("STJ",.F.)
				STJ->TJ_DTMRINI := If(Empty(dDTMRINI),STJ->tj_dtmpini,dDTMRINI)
				STJ->TJ_HOMRINI := If(Empty(cHOMRINI) .Or. Alltrim(cHOMRINI) = ':',;
				STJ->tj_hompini,cHOMRINI)
				STJ->TJ_DTMRFIM := If(Empty(dDTMRFIM),STJ->tj_dtmpfim,dDTMRFIM)
				STJ->TJ_HOMRFIM := If(Empty(cHOMRFIM) .Or. Alltrim(cHOMRFIM) = ':',;
				STJ->tj_hompfim,cHOMRFIM)
				STJ->TJ_TERMINO := "S"
				STJ->TJ_DTPRINI := If(Empty(dDTMRINI),STJ->tj_dtmpini,dDTMRINI)
				STJ->TJ_HOPRINI := If(Empty(cHOMRINI) .Or. Alltrim(cHOMRINI) = ':',;
				STJ->tj_hompini,cHOMRINI)
				STJ->TJ_DTPRFIM := If(Empty(dDTMRFIM),STJ->tj_dtmpfim,dDTMRFIM)
				STJ->TJ_HOPRFIM := If(Empty(cHOMRFIM) .Or. Alltrim(cHOMRFIM) = ':',;
				STJ->tj_hompfim,cHOMRFIM)
				STJ->TJ_CUSTMDO := 0
				STJ->TJ_CUSTMAT := 0
				STJ->TJ_CUSTMAA := 0
				STJ->TJ_CUSTMAS := 0
				STJ->TJ_CUSTTER := 0

				If lMMoeda
					STJ->TJ_MOEDA := "1"
				EndIf

				If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
					MsMM(,80,,STJ->TJ_OBSERVA,1,,,"STJ","TJ_MMSYP")
				EndIf
				MsUnLock("STJ")

				If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"  //Mensagem Unica
					NGMUMntOrd(STJ->(RecNo()),4)
				EndIf

				If Val(STJ->TJ_PLANO) > 0
					NGATUMANUT(STJ->TJ_CODBEM,STJ->TJ_SERVICO,STJ->TJ_SEQRELA,;
					STJ->TJ_DTMRFIM,STJ->TJ_HOMRFIM,nDIF,STJ->TJ_HORACO1,STJ->TJ_HORACO2)
				EndIf

				//GERAR O.S AUTOMATICA POR CONTADOR
				dbSelectArea("STJ")
				dbSetOrder(nINDSTJ)
				If (cGERAPREV = "S" .Or. cGERAPREV = "C") .And. (!Empty(STJ->TJ_POSCONT) .Or. !Empty(STJ->TJ_POSCON2))
					If NGCONFOSAUT(cGERAPREV)
						NGGEROSAUT(STJ->TJ_CODBEM,If(!Empty(STJ->TJ_POSCONT),STJ->TJ_POSCONT,STJ->TJ_POSCON2))
					EndIf
				EndIf

				If Val(cAPLANO) > 0
					NGOSABRVEN(cACODBEM,cASERVICO,.F.,.T.,.F.,nASEQUENC)

					If GETMV("MV_NGOSAUT") == 'S'
						NGOSPORTEM(cACODBEM,cASERVICO,nASEQUENC,.T.)
					EndIf

				EndIf
			EndIf

			//---------------------------------------------------
			lSTJAchou  := A400STJBUS(cACODBEM)

			dbSelectArea("ST9")
			dbSetOrder(1)

			If dbSeek(xFilial("ST9")+cACODBEM)
				RecLock("ST9",.F.)

				If lSTJAchou = .F.
					ST9->T9_TERCEIR := "1"
				EndIf

				MsUnLock("ST9")
			EndIf
			//---------------------------------------------------

			lOSPOST := If(AllTrim(GETMV("MV_NGREPRO")) == 'S',.T.,.F.)

			If STJ->tj_dtmrfim <> STJ->tj_dtmpfim .And. Val(STJ->tj_plano) > 0 .And. lOSPOST

				NGOSREPROG(STJ->tj_codbem,STJ->tj_servico,STJ->tj_seqrela,;
				STJ->tj_dtmrfim,STJ->tj_dtmpfim)
			EndIf

			dbSelectArea("STJ")
			dbGoto(nRECSTJ)

			If lIntTEC// Verifica se a Ordem de Serviço está vinculada
		       At800OsxTec( .F. /*lExclusao*/, .T./*lGravaCusto*/ )
			EndIf

			If ExistBlock("NG400FI1")
				ExecBlock("NG400FI1",.F.,.F.)
			EndIf

			dbSelectArea("STJ")
			dbGoto(nRECSTJ)

			bNGGRAVA := {}

			If lIntSFC .And. !Empty(NGVRFMAQ(STJ->TJ_CODBEM))
				NGSFCATPRD(STJ->TJ_ORDEM,{{"CZ2_LGMN",.F.}})
			EndIf

			//Fechamento de solicitacao de servico
			NGFECHASS(STJ->TJ_ORDEM)

		EndIf

		dbSelectArea("STJ")
		If Type("aIndSTJ") = "A" .And. Type("cCondicao") == "C"
			bFiltraBrw := {|| FilBrowse("STJ",@aIndSTJ,@cCondicao) }
			Eval(bFiltraBrw)
			If nRET == 1
				dbSetOrder(nINDSTJ)
				dbGotop()
				If nREGFIM == nRECSTJ
					dbGoBottom()
				Else
					dbGoTo(nRECSTJ)
					dbSkip()
				EndIf
			Else
				dbSetOrder(nINDSTJ)
				dbGoto(nRECNSTJ)
			EndIf
		Else
			If IsInCallStack("MNTA400")
				If nRET == 1
					dbSetOrder(nINDSTJ)
					dbGotop()
					If nREGFIM == nRECSTJ
						dbGoBottom()
					Else
						dbGoTo(nRECSTJ)
						dbSkip()
					EndIf
				Else
					dbSetOrder(nINDSTJ)
					dbGoto(nRECNSTJ)
				EndIf
			Else
				dbSetOrder(nINDSTJ)
				lREFRESH := .T.
			EndIf
		EndIf
	Else

		ShowHelpDlg("ATENCAO", {STR0432}, 2,;//"Existe(m) motivo(s) de atraso(s) reportado(s) para a ordem de serviço sem a data ou a hora final informados."
		{STR0433}, 2)	//"Favor, informar uma data fim/hora fim para o(s) motivo(s) em questão para proceder com a finalização da O.S."

		(cAliasTPL)->(dbCloseArea())

		Return .F.

	EndIf

	(cAliasTPL)->(dbCloseArea())

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400TAR
Programa de inclusao de Retorno de Tarefas Executada.
@type function

@author	Paulo Pego
@since	XX/XX/XXXX

@param cAlias, Caracter, Tabela corrente.
@param nREG  , Númerico, Número do registro.
@param nOpcX , Númerico, Operação selecionada.
@return
/*/
//---------------------------------------------------------------------
Function NG400TAR(cALIAS,nREG,nOPCX)

	Local xx         := 0
	Local acbrowold  := acbrowse
	Local lRet       := .F.
	Local oTmpTbl2                                        //Obj. Tabela Temporária 2

	Private cTRBR400 := GetNextAlias()
	Private cLocaliz := Space( Len( TPS->TPS_CODLOC ) )  // Código de Localização

	If !FindFunction( 'MNTA400A' )

		//+-------------------------------------------------------------------+
		//| Ponto de entrada para retornar um valor   						  |
		//| logico de maneira que permita validar,    						  |
		//| se e possivel agregar ou modificar        						  |
		//| insumos para OS selecionada pelo usuario. 						  |
		//+-------------------------------------------------------------------+
		If ExistBlock("MNTA400L")
			lRet := ExecBlock("MNTA400L",.F.,.F.)
			If !lRet
				Return .F.
			EndIf
		EndIf

		acbrowse := "xxxxxxxxxx"
		dbSelectArea("STJ")
		nINDSTJ := IndexOrd()

		aIndSTL  := {}
		bFiltraBrw := {|| Nil}
		condSTL := 'STL->TL_FILIAL ="'+ xFilial("STL")+'"'+'.And. '
		condSTL += 'STL->TL_ORDEM = STJ->TJ_ORDEM .And. Alltrim(STL->TL_SEQRELA) <> "0"'

		If STJ->TJ_TIPOOS = "B"
			If !NGBEMATIV(STJ->TJ_CODBEM)
				Return .F.
			EndIf

			If !NGMANATIV(STJ->TJ_CODBEM,STJ->TJ_SERVICO,STJ->TJ_SEQRELA)
				Return .F.
			EndIf
		EndIf

		cUSAINT1 := AllTrim(GETMv("MV_NGMNTPC"))
		cUsaInt2 := AllTrim(GetMv("MV_NGMNTCM"))
		cUsaInt3 := AllTrim(GetMv("MV_NGMNTES"))
		lESTNEGA := If(AllTrim(GETMV("MV_ESTNEG")) == 'S',.T.,.F.)

		dbSelectArea("STJ")
		If Empty(STJ->TJ_ORDEM)
			Return Nil
		EndIf

		lCORRET := If(Val(STJ->TJ_PLANO) = 0,.T.,.F.)
		OLDROT  := aCLONE(aROTINA)
		cMESTRE := "STJ"

		Private cCodBem := STJ->TJ_CODBEM
		Private cOrdem  := STJ->TJ_ORDEM
		Private cPlano  := STJ->TJ_PLANO
		Private aROTINA := {{STR0004 ,"PesqBrw"  , 0, 1},; //"Pesquisar"
							{STR0005 ,"MNT400VIS", 0, 2},; //"Visualizar"
							{STR0013 ,"NG401INC" , 0, 3},; //"Incluir"
							{STR0014 ,"NG401INC" , 0, 4},; //"Alterar"
							{STR0009 ,"NG401INC" , 0, 5, 3}} //"Excluir"
		If !lPyme
			aAdd( aRotina, { STR0152, "MsDocument", 0, 4 } )  //"Conhecimento"
		EndIf
		If cUsaInt3 == 'S'
			aAdd( aRotina, { STR0248, "MNTA400COM()", 0, 4 } ) //"C&omplemento"
		EndIf
		aPOS1     := {15,1,95,315}
		lRETORNO  := .T.
		cCADASTRO := Oemtoansi(STR0015) //"Retorno Tarefas"

		dbSelectArea("STF")
		dbSetOrder(01)
		dbSeek(xFilial('STF')+STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA)
		M->TF_CODBEM  := STJ->TJ_CODBEM
		M->TF_SERVICO := STJ->TJ_SERVICO
		M->TF_SEQRELA := STJ->TJ_SEQRELA
		M->TJ_ORDEM   := STJ->TJ_ORDEM
		M->TJ_PLANO   := STJ->TJ_PLANO

		MV_PAR01      := STJ->TJ_CODBEM
		MV_PAR02      := STJ->TJ_SERVICO
		MV_PAR05      := STJ->TJ_SEQRELA
		cPar01 := MV_PAR01
		cPar02 := MV_PAR02
		cPar05 := MV_PAR05

		dbSelectArea("STL")
		nINDSTL := IndexOrd()
		dbSetOrder(01)
		dbSeek(xFilial('STL')+STJ->TJ_ORDEM)

		If ExistBlock("NGTERMOR")
			aDBFR := STL->(dbStruct())

			//Instancia classe FWTemporaryTable
			oTmpTbl2:= FWTemporaryTable():New( cTRBR400, aDBFR )
			//Adiciona os Indices
			oTmpTbl2:AddIndex( "Ind01" , {"TL_ORDEM","TL_PLANO","TL_TAREFA","TL_TIPOREG","TL_CODIGO","TL_SEQRELA"} )
			//Cria a tabela temporaria
			oTmpTbl2:Create()

			dbSelectArea("STL")
			dbSetOrder(01)
			dbSeek(xFilial('STL')+STJ->TJ_ORDEM)
			While !EoF() .And. stl->tl_filial = xFilial('STL') .And. stl->tl_ordem = STJ->TJ_ORDEM
				If stl->tl_tiporeg = 'P' .And. Alltrim(stl->tl_seqrela) = "0"
					RecLock(cTRBR400,.T.)
					dbSelectArea("STL")
					For XX   := 1 To Fcount()
						ny   := (cTRBR400)+"->" + Fieldname(XX)
						nx   := "STL->" + Fieldname(XX)
						&ny. := &nx.
					Next
				EndIf
				dbSelectArea("STL")
				dbSkip()
			End
		EndIf

		dbSelectArea("STL")
		dbSetOrder(01)
		dbSeek(xFilial('STL')+STJ->TJ_ORDEM)

		NG400FILSTL()

		dbSelectArea("STL")
		SetBrwCHGAll( .F. ) // nao apresentar a tela para informar a filial
		mBrowse(6,1,22,75,"STL")
		aEval(aIndSTL,{|x| Ferase(x[1]+OrdBagExt())})
		ENDFILBRW('STL',aIndSTL)

		dbSelectArea("STL")
		Set Filter To
		dbSetOrder(1)
		dbSeek(xFilial("STL"))

		NG400PROC(STJ->TJ_ORDEM+STJ->TJ_PLANO)

		If ExistBlock("NGTERMOR")
			oTmpTbl2:Delete()//Deleta Tabela Temporária 2
		EndIf


		dbSelectArea("STJ")
		nREGTAR := Recno()
		If Type("aIndSTJ") = "A" .And. Type("cCondicao") == "C"
			bFiltraBrw := {|| FilBrowse("STJ",@aIndSTJ,@cCondicao) }
			Eval(bFiltraBrw)
			dbGoto(nREGTAR)
		Else
			bFiltraBrw := {|| Nil}
			dbSetOrder(nINDSTJ)
			lREFRESH := .T.
		EndIf

	Else

		MNTA400A()

	EndIf

	acbrowse := acbrowold

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NG401INC
Programa para Retorno das OS de servico de Manutencao
@author Inacio Luiz Kolling
@since 13/06/97
@version undefined
@param cALIAS, characters
@param nREG, numeric
@param nOPCX, numeric
@obs Novo Layout - Paulo Pego 01/08/97
@type function
/*/
//---------------------------------------------------------------------
Function NG401INC(cALIAS,nREG,nOPCX)

	Local bKeyF4 := SetKey(VK_F4)
	Local dDTINSTL,lDELSTP := .F.,cINSCOD := Space(len(stl->tl_codigo))
	Local cTLNUMSEQ := Space(6), cHORASTL
	Local nQUANTDSTL, dDTINICSTL, cLOCALSTL, cLOTESTL, cNUMLOSTL, cNUMSERSTL, cHOINICSTL, dDATAFISTL, cHORAFISTL
	Local lOSHESTO := .F.
	Local lOK      := .T.
	Local nOPCIns  := 0
	Local cNSeqD3  := ''
	Local nCustD3  := 0
	Local cOldCODIGO, cOldNUMSEQ, cOldORDEM, cOldSEQREL, cOldTIPORE, cOldFILIA
	Local lMMoeda   := NGCADICBASE("TL_MOEDA","A","STL",.F.)
	Local aCstMoeda := {}
	Local aCpoUsado := {}

	Private aInsSub  := {}
	Private lNumSeq2 := NGCADICBASE("TL_NUMSEQ2","A","STL",.F.)
	Private lUSATARG := If(FindFunction("NGUSATARPAD"),NGUSATARPAD(),.F.)
	Private nQuantO  := 0
	Private nCustoO  := 0 // Custo origem para insumos de produto, utilizado dentro de P.E.

	lTelaEtapa := .F. //Varivel responsavel para abrir a tela de etapa.

	If nOPCX = 4
		If stl->tl_tiporeg = "P"
			nQuantO := stl->tl_quantid
			nCustoO := STL->TL_CUSTO
		EndIf
	EndIf

	lTesGar := .F.
	lBAIXAEST := .T.

	aTROCAF3 := {}

	If nOPCX == 3  //Codigo para trazer os campos virtuais em branco na inclusao
		dbSelectArea("STL")
		dbGoBottom()
		dbSkip()
	EndIf

	dbSelectArea("STJ")

	If lUSATARG
		LCORRET := If(Val(STJ->tj_plano) = 0,.T.,.F.)
	EndIf

	nREG400 := Recno()

	cUSAINT1 := AllTrim(GETMv("MV_NGMNTPC"))
	cUsaInt2 := AllTrim(GetMv("MV_NGMNTCM"))
	cUsaInt3 := AllTrim(GetMv("MV_NGMNTES"))
	cUIntHis := AllTrim(GetMv("MV_NGHISES"))
	lESTNEGA := If(AllTrim(GETMV("MV_ESTNEG")) == 'S',.T.,.F.)

	//Verifica se o registro e originado do documento de entrada
	If nOPCX = 5 .Or. nOPCX = 4
		If cUsaInt3 = "S" .And. STL->TL_TIPOREG $"PMT" .And. !Empty(STL->TL_NUMSEQ)
			If NGIFDBSEEK("SD1",STL->TL_NUMSEQ,4,.F.)
				MSGINFO(STR0178+chr(13);  //"Esse insumo nao pode ser alterado ou excluido porque esta vinculado a uma"
				+STR0179+chr(13); //"NF de Entrada. Para que essa alocacao seja modificada e necessario executar"
				+STR0180+chr(13); //"o acerto na NF de entrada atraves da transacao Documento de Entrada."
				+STR0181+chr(13); //"Alertamos que, se o estoque ja estiver fechado e a NF ja tiver sido"
				+STR0182+chr(13); //"contabilizada essa alteracao nao sera possivel. Outra situacao que tem"
				+STR0183+chr(13); //"que ser considerada e que a NF de entrada somente podera ser modificada"
				+STR0184+chr(13); //"se a O.S vinculada a mesma ainda estiver em aberto. Se a OS estiver"
				+STR0185+chr(13)+chr(13); //"fechada sera necessario a reabertura da mesma."
				+STR0250+chr(13); //"Caso deseje complementar informações referentes à Tarefa, Lote, Sub-Lote,"
				+STR0251+chr(13),STR0137) //"Garantia e Ocorrências, clicar no botão Complemento."
				Return .F.
			Else
				If NGIFDBSEEK("SD3",STL->TL_NUMSEQ,4,.F.)
					If NGCADICBASE("TL_ORIGNFE","A","STL",.F.)
						//Inclusão via Documento de entrada ou via Pré-requisição SA
						If STL->TL_ORIGNFE == "SD3" .Or. ( !Empty(STL->TL_NUMSA) .Or. !Empty(STL->TL_ITEMSA) )
							//"Esse insumo não pode ser alterado ou excluído porquê está vinculado a uma"
							//"movimentação originária de um movimento interno do estoque."
							MSGINFO(STR0178+chr(13)+STR0311+Chr(13)+Chr(13)+STR0312,STR0137)
							Return .F.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		If ExistBlock("MNT40013")
			ExecBlock("MNT40013",.F.,.F.)
		EndIf
	EndIf
	SetKey(VK_F4,{|| MntViewSB2(M->TL_TIPOREG,M->TL_CODIGO) })
	SetKey(VK_F6,{||MNTA400F6(M->TL_TIPOREG,M->TL_CODIGO)})
	SetKey(VK_F10,{||NGRELOCORRC("M->TN_CAUSA",aCOLS[n,1],"P",.T., ,"TN_NOMCAUS")})
	SetKey(VK_F11,{||NGRELOCORRC("M->TN_SOLUCAO",aCOLS[n,3],"C",.T., ,"TN_NOMSOLU")})
	SetKey(VK_F12,{||NGINSUF12("M->TL_CODIGO",STJ->tj_codbem,m->tl_tiporeg)})

	dbSelectArea("STL")
	nINDSTL2 := INDEXORD()
	nREG2    := Recno()
	lCUSTO   := .F.
	If cUSAINT3 == 'N'
		lCUSTO := .T.
	EndIf

	If cUSAINT3 == 'S' .And. cUIntHis == "N" .And. STJ->TJ_SERVICO == "HISTOR"
		lCUSTO   := .T.
		lOSHESTO := .T.
	EndIf

	aCHOICE :=	{ "TL_TAREFA","TL_TIPOREG","TL_CODIGO","TL_USACALE","TL_QUANREC","TL_QUANTID","TL_UNIDADE","TL_DESTINO",;
				  "TL_DTINICI","TL_HOINICI","TL_DTFIM","TL_HOFIM","TL_HREXTRA","TL_LOCAL","TL_GARANTI", }

	aCpoUsado := NGX3USO({ "TL_NOMTAR" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_NOMTAR" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_NOMTAR" ) //Adiciona no aCHOICE o campo 'TL_NOMTAR'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_NOMTREG" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_NOMTREG" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_NOMTREG" ) //Adiciona no aCHOICE o campo 'TL_NOMTREG'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_NOMCODI" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_NOMCODI" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_NOMCODI" ) //Adiciona no aCHOICE o campo 'TL_NOMCODI'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_PCTHREX" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_PCTHREX" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,If( NGCADICBASE( 'TL_PCTHREX','A','STL',.F. ),"TL_PCTHREX","TL_HREXTRA" )) //Adiciona no aCHOICE o campo 'TL_PCTHREX'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_LOTECTL" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_LOTECTL" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_LOTECTL" ) //Adiciona no aCHOICE o campo 'TL_LOTECTL'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_NUMLOTE" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_NUMLOTE" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_NUMLOTE" )  //Adiciona no aCHOICE o campo 'TL_NUMLOTE'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_DTVALID" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_DTVALID" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_DTVALID" ) //Adiciona no aCHOICE o campo 'TL_DTVALID'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_LOCALIZ" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_LOCALIZ" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_LOCALIZ" )  //Adiciona no aCHOICE o campo 'TL_LOCALIZ'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_ETAPA" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_ETAPA" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_ETAPA" ) //Adiciona no aCHOICE o campo 'TL_ETAPA'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_OBSERVA" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_OBSERVA" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_OBSERVA" ) //Adiciona no aCHOICE o campo 'TL_OBSERVA'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_FORNEC" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_FORNEC" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_FORNEC" ) //Adiciona no aCHOICE o campo 'TL_FORNEC'.
	EndIf

	aCpoUsado := NGX3USO({ "TL_LOJA" }) //Verifica X3_USADO
	If aSCAN( aCpoUsado,{|x| x == "TL_LOJA" }) > 0 //Se a propriedade do campo estiver habilitada como 'Usado'
		aAdd( aCHOICE,"TL_LOJA" )  //Adiciona no aCHOICE o campo 'TL_LOJA'.
	EndIf

	If NGCADICBASE("TL_PERMDOE","A","STL",.F.) .And. NGFUNCRPO("NGMDOEXECU",.F.)
		aAdd(aCHOICE,"TL_PERMDOE")
	EndIf

	If lMMoeda
		aAdd(aChoice, "TL_MOEDA")
	EndIf

	If Len(NGX3USO({"TL_CUSTO"})) > 0
		aAdd(aCHOICE,"TL_CUSTO")
	EndIf

	M->TL_PLANO := M->TJ_PLANO
	M->TL_ORDEM := M->TJ_ORDEM

	If INCLUI
		M->TL_SEQRELA := ULTSEQ(Recno())
	Else
		M->TL_SEQRELA := STL->TL_SEQRELA
		cTLNUMSEQ := STL->TL_NUMSEQ
	EndIf

	M->TL_NOMETAR := "  "
	nSEQUENC := M->TL_SEQRELA

	aVARNAO := {{"M->TL_ORDEM","M->TJ_ORDEM"},{"M->TL_PLANO","M->TJ_PLANO"},;
				{"M->TL_SEQRELA", If(nOPCX == 4,"STL->TL_SEQRELA","nSEQUENC")}}

	M->TN_ORDEM   := M->TL_ORDEM
	M->TN_PLANO   := M->TL_PLANO
	M->TN_SEQRELA := M->TL_SEQRELA
	M->TN_CODOBS  := Space(6)

	aGETNAO := {{"TN_ORDEM"  ,"M->TJ_ORDEM"  },;
				{"TN_PLANO"  ,"M->TJ_PLANO"  },;
				{"TN_TAREFA" ,"M->TL_TAREFA" },;
				{"TN_NOMETAR","M->TL_NOMETAR"},;
				{"TN_CODOBS" ,"SPACE(06)"    },;
				{"TN_SEQRELA","nSEQUENC"     }}

	cGETWHILE := "TN_FILIAL  == Xfilial('STN') .And. "
	cGETWHILE += "TN_ORDEM   == STL->TL_ORDEM  .And. "
	cGETWHILE += "TN_PLANO   == STL->TL_PLANO  .And. "
	cGETWHILE += "TN_TAREFA  == STL->TL_TAREFA .And. "
	cGETWHILE += "TN_SEQRELA == STL->TL_SEQRELA"
	cGETMAKE  := "M->TL_ORDEM + M->TL_PLANO + M->TL_TAREFA + M->TL_SEQRELA"
	cGETKEY   := "M->TN_ORDEM + M->TN_PLANO + M->TN_TAREFA + M->TN_SEQRELA + M->TN_CODOCOR + M->TN_CAUSA + M->TN_SOLUCAO"

	cGETALIAS := "STN"
	cTUDOOK   := "M400STNTUD()"
	cLINOK    := "M400STNLIN()"
	aCHKDEL   := {}
	bNGGRAVA  := { |x| NGMSGARAN(nOpcx) .And. fInteg( nOPCX, lOSHESTO, @cNSeqD3, @nCustD3 ) }

	If nOPCX = 5
		If stl->tl_tiporeg = 'P'
			dDTINSTL := stl->tl_dtinici
			cHORASTL := stl->tl_hoinici
			lDELSTP  := .T.
		EndIf
	EndIf

	If nOPCX = 4
		nQUANTDSTL := STL->TL_QUANTID
		dDTINICSTL := STL->TL_DTINICI
		cHOINICSTL := STL->TL_HOINICI
		dDATAFISTL := STL->TL_DTFIM
		cHORAFISTL := STL->TL_HOFIM
		cLOCALSTL  := STL->TL_LOCAL
		cLOTESTL   := STL->TL_LOTECTL
		cNUMLOSTL  := STL->TL_NUMLOTE
		cLOCALIZ   := STL->TL_LOCALIZ
		cNUMSERSTL := STL->TL_NUMSERI
	EndIf

	cOldFILIA  := STL->TL_FILIAL
	cOldCODIGO := STL->TL_CODIGO
	cOldNUMSEQ := STL->TL_NUMSEQ
	cOldORDEM  := STL->TL_ORDEM
	cOldSEQREL := STL->TL_SEQRELA
	cOldTIPORE := STL->TL_TIPOREG

	nQtdAntiga := STL->TL_QUANTID

	nOPCIns := NGCAD02("STL",nREG2,nOPCX)

	If nOPCIns <> 1
		cOrdem := STJ->TJ_ORDEM
		cPlano := STJ->TJ_PLANO
		If nOPCX == 3
			NGARANDELETE()
		EndIf
		dbSelectArea("STL")
		dbGoTo(STL->(LastRec()))
	EndIf

	If nOPCX == 5 .And. nOPCIns == 1

		If lDELSTP

			// MOSTRA OS REGISTROS DO HISTORICO PARA EXECLUIR
			NGDELINSLAN(STJ->tj_codbem,dDTINSTL,cHORASTL)

		EndIf

		NGARANDELETE()

		MNT400TTA(nOPCX,nQtdAntiga,STL->TL_QUANTID)

		If ExistBlock("MNT40014")
			ExecBlock("MNT40014",.F.,.F.)
		EndIf

		If STL->TL_TIPOREG == 'M'
			cAliasQry := GetNextAlias()
			cQuery := " SELECT 1 "
			cQuery += " FROM " + RetSqlName("STL")
			cQuery += " WHERE TL_CODIGO = '"+STL->TL_CODIGO+"'"
			cQuery += " AND   TL_ORDEM  = '"+STJ->TJ_ORDEM+"'"
			cQuery += " AND   TL_PLANO  = '"+STJ->TJ_PLANO+"'"
			cQuery += " AND   D_E_L_E_T_ = ' ' "
			cQuery := ChangeQuery(cQuery)
			dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
			dbgotop()
			If EoF()
				If NGIFDBSEEK("STQ",STJ->TJ_ORDEM+STJ->TJ_PLANO,1)
					While !EoF() .And. STJ->TJ_ORDEM ==STQ->TQ_ORDEM .And. STJ->TJ_PLANO == STQ->TQ_PLANO
						If AllTrim(STQ->TQ_CODFUNC) == AllTrim(STL->TL_CODIGO)
							RecLock("STQ",.F.)
							STQ->TQ_OK      := Space(Len(STQ->TQ_OK))
							STQ->TQ_CODFUNC := Space(Len(STQ->TQ_CODFUNC))
							STQ->(MsUnLock())
						EndIf
						dbSkip()
					End
				EndIf
			EndIf
			(cAliasQry)->(dbCloseArea())
		EndIf

	EndIf

	If nOPCX == 4 .And. nOPCIns == 1

		dbGoTo(STL->(LastRec()))

		If STL->TL_TIPOREG $ 'PM'

			RecLock( 'STL', .F. )

			STL->TL_NUMSEQ := cNSeqD3
			STL->TL_CUSTO  := nCustD3

			If lMMoeda
				STL->TL_MOEDA  := "1"
			EndIf

			MsUnLock()

		EndIf

		If STL->TL_TIPOREG == "F"
			RecLock('STL',.F.)

			If lMMoeda .And. FindFunction("NGCALCUSMD")
				aCstMoeda     := NGCALCUSMD(STL->TL_CODIGO,STL->TL_TIPOREG,STL->TL_QUANTID,STL->TL_LOCAL,STL->TL_TIPOHOR;
				,,,STL->TL_QUANREC)
				STL->TL_CUSTO := aCstMoeda[1]
				STL->TL_MOEDA := aCstMoeda[2]
			Else
				STL->TL_CUSTO := NGCALCUSTI(STL->TL_CODIGO,STL->TL_TIPOREG,STL->TL_QUANTID,STL->TL_LOCAL,STL->TL_TIPOHOR;
				,,,STL->TL_QUANREC)
				If lMMoeda
					STL->TL_MOEDA := "1"
				EndIf
			EndIf

			MsUnLock("STL")
		EndIf

		dbSelectArea("STL")
		If STL->TL_TIPOREG <> "P"
			If nQUANTDSTL <> STL->TL_QUANTID .Or. dDTINICSTL <> STL->TL_DTINICI .Or.;
			cHOINICSTL <> STL->TL_HOINICI .Or. dDATAFISTL <> STL->TL_DTFIM   .Or.;
			cHORAFISTL <> STL->TL_HOFIM
				RecLock("STL",.F.)
				STL->TL_TIPOHOR := If(stl->tl_usacale = "S","S",AllTrim(GETMV("MV_NGUNIDT")))
				MsUnLock("STL")
			EndIf
		EndIf
		MNT400TTA(nOPCX,nQtdAntiga,STL->TL_QUANTID)
		If STL->TL_GARANTI = "N"
			NGDELTODASGA(STL->TL_ORDEM,STL->TL_PLANO,STL->TL_SEQRELA)
		EndIf

	EndIf

	If nOPCX == 3 .And. nOPCIns == 1

		dbSelectArea("STL")
		nRecSTLA := STL->(LastRec())
		dbGoTo(STL->(LastRec()))

		RecLock( 'STL', .F. )

		If STL->TL_TIPOREG $ 'PM'

			STL->TL_NUMSEQ := cNSeqD3
			STL->TL_CUSTO  := nCustD3
			If lMMoeda
				STL->TL_MOEDA := "1"
			EndIf

		EndIf

		If STL->TL_TIPOREG <> "P"
			STL->TL_TIPOHOR := If(stl->tl_usacale = "S","S",AllTrim(GETMV("MV_NGUNIDT")))
		EndIf

		MsUnLock("STL")

		If STL->TL_TIPOREG == "F"
			RecLock('STL',.F.)

			If lMMoeda .And. FindFunction("NGCALCUSMD")
				aCstMoeda     := NGCALCUSMD(STL->TL_CODIGO,STL->TL_TIPOREG,STL->TL_QUANTID,STL->TL_LOCAL,STL->TL_TIPOHOR;
				,,,STL->TL_QUANREC)
				STL->TL_CUSTO := aCstMoeda[1]
				STL->TL_MOEDA := aCstMoeda[2]
			Else
				STL->TL_CUSTO := NGCALCUSTI(STL->TL_CODIGO,STL->TL_TIPOREG,STL->TL_QUANTID,STL->TL_LOCAL,STL->TL_TIPOHOR;
				,,,STL->TL_QUANREC)
				If lMMoeda
					STL->TL_MOEDA := "1"
				EndIf
			EndIf

			MsUnLock("STL")
		EndIf
		If STL->Tl_TIPOREG == "T" .OR. STL->TL_TIPOREG == "M"
			If STL->TL_TIPOREG == "T"
				cPROD := STL->TL_CODIGO
				nMULT := 0
			Else
				ST1->( dbSeek( xFilial('ST1') + AllTrim(STL->TL_CODIGO) ) )
				cProd := IIf( FindFunction( 'MntGetPrdM' ), MntGetPrdM(), PadR( 'MOD' + ST1->T1_CCUSTO, TamSX3( 'B1_COD' )[1] ) )
				nMULT := If(NGCADICBASE('TL_PCTHREX','A','STL',.F.), STL->TL_PCTHREX, VAL(STL->TL_HREXTRA))/100
			EndIf
			cLocPad := Padr( GetMv("MV_NGLOCPA"), TamSx3("NNR_CODIGO")[1] )
			SB1->(dbSeek(xFilial('SB1')+cPROD))
			SB2->(dbSeek(xFilial('SB2')+cPROD+cLocPad))
			nQTDSTL := STL->TL_QUANTID+(STL->TL_QUANTID*nMULT)
		EndIf

		If ExistBlock("NG400INS")
			ExecBlock("NG400INS",.F.,.F.)
		EndIf
		If STL->TL_GARANTI = "N"
			NGDELTODASGA(STL->TL_ORDEM,STL->TL_PLANO,STL->TL_SEQRELA)
		EndIf
	EndIf

	If nOPCIns == 1 .And. (nOPCX == 3 .Or. nOPCX == 4)
		MNA400GEPA(.T.)
		If ExistBlock("MNTA4003")
			ExecBlock("MNTA4003",.F.,.F.)
		EndIf
	EndIf

	// Se confirmou a tela de cadastros de insumos
	If nOPCIns == 1

		If NGFUNCRPO("SgaMntEst",.F.) .And. GetMv("MV_SGAMNT") == "S" .And. GetMv("MV_NGSGAES") <> "N"
			SgaMntEst(nOpcx,cOldCODIGO,cOldNUMSEQ,cOldORDEM,cOldSEQREL,cOldTIPORE,nQtdAntiga,cOldFILIA)
		EndIf
	EndIf

	dbSelectArea("STL")
	dbSetOrder(nINDSTL2)
	cALIASOLD := ALIAS()

	dbSelectArea("STJ")
	dbGoto(nREG400)

	dbSelectArea(cALIASOLD)
	lREFRESH := .T.

	Set Key VK_F6  To
	Set Key VK_F10 To
	Set Key VK_F11 To
	Set Key VK_F12 To
	SetKey(VK_F4,bKeyF4)
	lCriouTRBQ := .F.

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400FILSTL
Filtra os insumos da O.S. de Servico
@author Inacio Luiz Kolling
@since 18/03/02
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG400FILSTL()

	condSTL    := 'STL->TL_FILIAL ="'+ xFilial("STL")+'"'+'.And. '
	condSTL    += 'STL->TL_ORDEM = STJ->TJ_ORDEM .And. ( AllTrim( STL->TL_SEQRELA ) <> "0" .Or. Val( STL->TL_SEQRELA ) != 0 )'

	If (ExistBlock("MNTA4007"))
		condSTL += ExecBlock("MNTA4007",.F.,.F.)
	EndIf

	bFiltraBrw := {|| FilBrowse("STL",@aIndSTL,@condSTL) }
	Eval(bFiltraBrw)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400ETA
cadastra as etapas das tarefas
@author Inacio Luiz Kolling
@since 13/06/97
@version undefined
@param cALIAS, caracter, Alias da tabela
@param nREG, numerico, Recno da tabela
@param nOPCX, numerico, Tipo de operação
@param lRotF6, Logico, Se é utilizado via F6 de insumos.
@type function
/*/
//---------------------------------------------------------------------
Function NG400ETA(cAlias,nReg,nOpcx,lRotF6)

	Local OldRot
	Local oMenu
	Local nIndEta    := 0
	Local nfor       := 0
	Local cVPREVEN   := {}
	Local cVOSCORR   := {}
	Local lRet       := .F.
	Local lExistSeq  := .F.
	Local cAnMVPAR01 := MV_PAR01
	Local cCampo     := ""
	Local cTipo      := ""
	Local nTamanho   := 0
	Local nDecimal   := 0
	Default lRotF6   := .F.

	Private nINDSTQ  := 1

	// Valida se a O.S. não foi cancelada paralelamente em outra rotina.
	If MNTA400Can()

		lTelaEtapa := .T.
		lTmpTbl6   := .F.

		cTRBQ400 := GetNextAlias() // Alias Tab. 3 e 6
		cTRB3400 := GetNextAlias() // Alias Tab. 4
		cTRBQBKP := GetNextAlias() // Alias Tab. 5
		cTRBZ400 := GetNextAlias() // Alias Tab. 8
		/*-------------------------------------------
		| Ponto de entrada para retornar um valor   |
		| logico de maneira que permita validar,    |
		| se e possivel agregar ou modificar        |
		| etapas para OS selecionada pelo usuario.  |
		-------------------------------------------*/
		If ExistBlock("MNTA400M")
			lRet := ExecBlock("MNTA400M",.F.,.F.)
			If !lRet
				Return .F.
			EndIf
		EndIf

		dbSelectArea("STJ")
		nRECNOSTJ := Recno()
		nINDETA   := Indexord()

		If !lRotF6
			lCriouTRBQ := .F.
		EndIf

		If FindFunction("NGSEQETA")
			nINDSTQ := NGSEQETA("STQ",nINDSTQ)
		EndIf

		lINVERTE  := .F.
		If ValType(cMARCA) != 'C'
			cMARCA    := GetMark()
		EndIf
		lQUERY    := .T.
		lTAREFA   := .T.

		If STJ->TJ_TIPOOS == "B"
			If !NGBEMATIV(STJ->TJ_CODBEM)
				Return .F.
			EndIf

			If !NGMANATIV(STJ->TJ_CODBEM,STJ->TJ_SERVICO,STJ->TJ_SEQRELA)
				Return .F.
			EndIf
		EndIf

		If ExistBlock("MNTA4001")
			ExecBlock("MNTA4001",.F.,.F.)
			dbSelectArea("STJ")
			dbSetOrder(nINDETA)
			dbGoto(nRECNOSTJ)
			Return Nil
		EndIf

		nORDEM  := STJ->TJ_ORDEM
		nPLANO  := STJ->TJ_PLANO
		OLDROT  := aCLONE(aROTINA)
		aROTINA := {{STR0013 ,"NGPROCETA", 0,3},; //"Incluir"
					{STR0009 ,"NGPROCETA", 0,4}}  //"Excluir"

		MV_PAR01 := 1
		dbSelectArea("STQ")

		//busca o tamanho da picture do dicionario para descricao da etapa
		cETAPIC := NGSEEKDIC("SX3","TPA_DESCRI",2,"X3_PICTURE")
		nETATAM := VAL(SUBSTR(cETAPIC,(at("S",cETAPIC)+1),LEN(cETAPIC)))

		aDBF    := {}
			aAdd(aDBF,{"TQ_OK"     ,"C",02, 0 })
			aAdd(aDBF,{"TQ_ORDEM"  ,"C",06, 0 })
			aAdd(aDBF,{"TQ_PLANO"  ,"C",06, 0 })
			aAdd(aDBF,{"TQ_TAREFA" ,"C",06, 0 })
			aAdd(aDBF,{"TQ_ETAPA"  ,"C",06, 0 })
			aAdd(aDBF,{"TQ_SEQETA" ,"C",03, 0 })
			aAdd(aDBF,{"TQ_DESCRIC","C",If(nETATAM<>0,nETATAM,50), 0 })
			aAdd(aDBF,{"TQ_CODFUNC","C",06, 0 })


		aTRBQ := {}
			aAdd(aTRBQ,{"TQ_OK"     ,Nil," "    ,})
			aAdd(aTRBQ,{"TQ_TAREFA" ,Nil,STR0115,}) //"Tarefa"
			aAdd(aTRBQ,{"TQ_ETAPA"  ,Nil,STR0016,}) //"Etapa"
			aAdd(aTRBQ,{"TQ_SEQETA" ,Nil,STR0150,}) //"Seq.Etapa"
			aAdd(aTRBQ,{"TQ_DESCRIC",Nil,STR0017,}) //"Descricao "
			aAdd(aTRBQ,{"TQ_CODFUNC",Nil,STR0018,}) //"Executante"

		//Instancia classe FWTemporaryTable
		oTmpTbl3:= FWTemporaryTable():New( cTRBQ400, aDBF )
		//Adiciona os Indices
		oTmpTbl3:AddIndex("01" 	, {"TQ_OK","TQ_ORDEM"})
		oTmpTbl3:AddIndex("02"	, {"TQ_ETAPA", "TQ_SEQETA"})
		oTmpTbl3:AddIndex("03"	, {"TQ_TAREFA", "TQ_ETAPA", "TQ_ORDEM", "TQ_SEQETA","TQ_OK"})
		oTmpTbl3:AddIndex("04"  , {"TQ_TAREFA", "TQ_SEQETA", "TQ_ETAPA"})
		//Cria a tabela temporaria
		oTmpTbl3:Create()

		aDBF3 := TPC->(dbStruct())
			aAdd(aDBF3,{"TPC_RESPOS","C", TAMSX3( 'TPQ_RESPOS' )[1],0})
			aAdd(aDBF3,{"TPC_OK"    ,"C",02,0})
			aAdd(aDBF3,{"TPC_TAREFA","C",06,0})

		If ExistBlock("NG405CPU")
			aCposAlTPQ := ExecBlock("NG405CPU",.F.,.F.)
		EndIf

		//+-------------------------------------------------------------------+
		//| Agrega no array aHeader os campos de Usuarios...     			  |
		//+-------------------------------------------------------------------+
		If Len(aCposAlTPQ) > 0
			For nfor := 1 To Len(aCposAlTPQ)

				cCampo := aCposAlTPQ[nfor]
				If FieldPos(cCampo) > 0
					cTipo    := Posicione("SX3",2,cCampo,"X3_TIPO")
					nTamanho := TAMSX3(cCampo)[1]
					nDecimal := TAMSX3(cCampo)[2]
					aAdd(aDBF3,{cCampo,cTipo,nTamanho,nDecimal})
				EndIf

			Next nFor
		EndIf

		//Instancia classe FWTemporaryTable
		oTmpTbl4:= FWTemporaryTable():New( cTRB3400, aDBF3 )
		//Adiciona os Indices
		oTmpTbl4:AddIndex( "Ind01" , {"TPC_ETAPA","TPC_TAREFA","TPC_OPCAO"})
		//Cria a tabela temporaria
		oTmpTbl4:Create()

		If !lCriouTRBQ
			lCriouTRBQ := .T.
			dbSelectArea("STQ")
			dbSetOrder(nINDSTQ)
			dbSeek(xFilial("STQ")+STJ->TJ_ORDEM+STJ->TJ_PLANO)
			While !EoF() .And. STQ->TQ_FILIAL == xFilial("STQ") .And. STQ->TQ_ORDEM == STJ->TJ_ORDEM .And. STQ->TQ_PLANO == STJ->TJ_PLANO
				dbSelectArea("TPA")
				dbSetOrder(1)
				dbSeek(xFilial('TPA')+STQ->TQ_ETAPA)
				(cTRBQ400)->(dbAppend())
				(cTRBQ400)->TQ_OK      := If(Empty(STQ->TQ_OK),"  ",cMARCA)
				(cTRBQ400)->TQ_ORDEM   := STQ->TQ_ORDEM
				(cTRBQ400)->TQ_PLANO   := STQ->TQ_PLANO
				(cTRBQ400)->TQ_TAREFA  := STQ->TQ_TAREFA
				(cTRBQ400)->TQ_ETAPA   := STQ->TQ_ETAPA
				(cTRBQ400)->TQ_DESCRIC := TPA->TPA_DESCRI
				(cTRBQ400)->TQ_CODFUNC := STQ->TQ_CODFUNC
				(cTRBQ400)->TQ_SEQETA  := STQ->TQ_SEQETA
				If !Empty(STQ->TQ_SEQETA)
					lExistSeq := .T.
				EndIf
				dbSelectArea("STQ")
				dbSkip()
			EndDo
			dbSelectArea(cTRBQ400)
			If lExistSeq //Ordena pela sequencia da etapa caso tenha alguma preenchida
				dbSetOrder(4)
			Else
				dbSetOrder(3)
			EndIf
		EndIf

		//Instancia classe FWTemporaryTable
		oTmpTbl5:= FWTemporaryTable():New( cTRBQBKP, aDBF )
		//Adiciona os Indices
		oTmpTbl5:AddIndex("Ind01" 	, {"TQ_OK","TQ_ORDEM"})
		//Cria a tabela temporaria
		oTmpTbl5:Create()

		dbSelectArea(cTRBQ400)
		dbGotop()
		While !EoF()
			(cTRBQBKP)->(dbAppend())
			(cTRBQBKP)->TQ_OK      := (cTRBQ400)->TQ_OK
			(cTRBQBKP)->TQ_ORDEM   := (cTRBQ400)->TQ_ORDEM
			(cTRBQBKP)->TQ_PLANO   := (cTRBQ400)->TQ_PLANO
			(cTRBQBKP)->TQ_TAREFA  := (cTRBQ400)->TQ_TAREFA
			(cTRBQBKP)->TQ_ETAPA   := (cTRBQ400)->TQ_ETAPA
			(cTRBQBKP)->TQ_DESCRIC := (cTRBQ400)->TQ_DESCRIC
			(cTRBQBKP)->TQ_CODFUNC := (cTRBQ400)->TQ_CODFUNC
			(cTRBQBKP)->TQ_SEQETA  := (cTRBQ400)->TQ_SEQETA
			dbSelectArea(cTRBQ400)
			dbSkip()
		EndDo
		dbGoTop()
		nOPCY   := 0
		Define MsDialog oDLG1 Title STR0019 From 163,0 To 500,If(GetScreenRes()[1] <= 800,750,GetScreenRes()[1]*0.73) Pixel Of oMAINWND //"Etapas Da Ordem Servico"

		oPainelPai       := TPanel():New(00,00,,oDLG1,,,,,,0,115,.F.,.F.)
		oPainelPai:Align := CONTROL_ALIGN_ALLCLIENT

		@ 0.5,5  Button STR0013 Of oPainelPai Size 40,12 Action (NGX400ETA('STJ',Recno(),1)) //"Incluir"
		@ 0.5,20 Button STR0009 Of oPainelPai Size 40,12 Action (NGX400ETA('STJ',Recno(),2)) //"Excluir"
		@ 0.5,35 Button STR0018 Of oPainelPai Size 40,12 Action (NG400EXCU())                //"Executante"

		If ExistBlock("UEM1A002")
			c002FILBem := STJ->TJ_CODBEM
			@ 2,50 Button STR0176 Of oPainelPai Size 40,12 Action ExecBlock("UEM002FILB",.F.,.F.)  //"&
		EndIf

		oPnl1       := TPanel():New(00,00,,oPainelPai,,,,,,0,115,.F.,.F.)
		oPnl1:Align := CONTROL_ALIGN_BOTTOM

		oMark                     := MsSelect():New(cTRBQ400,"TQ_OK",,aTRBQ,@lINVERTE,@cMARCA,{39,1,160,318},,,oPnl1)
		oMark:bMARK               := {|| MNTA405(), oMark:oBrowse:Refresh(.F.)}
		oMark:oBrowse:lHASMARK    := .T.
		oMark:oBrowse:lCANALLMARK := .T.
		oMark:oBrowse:bALLMARK    := {|| NG400INV(cMARCA) }
		oMark:oBrowse:Align       := CONTROL_ALIGN_ALLCLIENT

		If (cTRBQ400)->(RecCount()) == 0
			oMark:oBrowse:Disable()
		Else
			oMark:oBrowse:Enable()
		EndIf

		NGPOPUP(aSMenu,@oMenu)
		oPainelPai:bRClicked := { |o,x,y| oMenu:Activate(x,y,oPainelPai)}
		Activate MsDialog oDLG1 On Init EnchoiceBar(oDLG1,{|| nOPCY := 1,If(!MNTA400EFI(),nOPCY  := 0,oDLG1:End())},{|| MNTA400ECA(),oDLG1:End()}) CENTERED

		If nOPCY == 1

			If !lRotF6
				MNA400GEPA(.F.)
				If ExistBlock("MNTA400E")
					ExecBlock("MNTA400E",.F.,.F.)
				EndIf
				lCriouTRBQ := .F.
			EndIf
		Else
			dbSelectArea("STQ")
			dbSetOrder(01)
			If dbSeek(STJ->TJ_FILIAL+STJ->TJ_ORDEM+STJ->TJ_PLANO)
				While !EoF() .And. STJ->TJ_ORDEM == STQ->TQ_ORDEM .And. STJ->TJ_PLANO == STQ->TQ_PLANO

					nIgualTRB := 0
					dbSelectArea(cTRBQBKP)
					dbGotop()
					While !EoF()
						If STQ->TQ_TAREFA == (cTRBQBKP)->TQ_TAREFA .And. STQ->TQ_ETAPA == (cTRBQBKP)->TQ_ETAPA
							nIgualTRB++
						EndIf
						dbSelectArea(cTRBQBKP)
						dbSkip()
					EndDo
					If nIgualTRB == 0
						dbSelectArea(cTRBQBKP)
						RecLock((cTRBQBKP),.T.)
						(cTRBQBKP)->TQ_OK      := STQ->TQ_OK
						(cTRBQBKP)->TQ_ORDEM   := STQ->TQ_ORDEM
						(cTRBQBKP)->TQ_PLANO   := STQ->TQ_PLANO
						(cTRBQBKP)->TQ_TAREFA  := STQ->TQ_TAREFA
						(cTRBQBKP)->TQ_ETAPA   := STQ->TQ_ETAPA
						(cTRBQBKP)->TQ_DESCRIC := NGSEEK("TPA",STQ->TQ_ETAPA,1,"TPA_DESCRI")
						(cTRBQBKP)->TQ_CODFUNC := STQ->TQ_CODFUNC
						(cTRBQBKP)->TQ_SEQETA  := STQ->TQ_SEQETA
						MsUnLock(cTRBQBKP)
					EndIf
					dbSelectArea("STQ")
					dbSkip()
				EndDo
			EndIf

			lTmpTbl6 := .T.
			cTRBQ400 := GetNextAlias()
			//Instancia classe FWTemporaryTable
			oTmpTbl6:= FWTemporaryTable():New( cTRBQ400, aDBF )
			//Adiciona os Indices
			oTmpTbl6:AddIndex( "Ind01" , {"TQ_OK","TQ_ORDEM"} )
			//Cria a tabela temporaria
			oTmpTbl6:Create()

			dbSelectArea(cTRBQBKP)
			dbGotop()
			While !EoF()
				(cTRBQ400)->(dbAppend())
				(cTRBQ400)->TQ_OK      := (cTRBQBKP)->TQ_OK
				(cTRBQ400)->TQ_ORDEM   := (cTRBQBKP)->TQ_ORDEM
				(cTRBQ400)->TQ_PLANO   := (cTRBQBKP)->TQ_PLANO
				(cTRBQ400)->TQ_TAREFA  := (cTRBQBKP)->TQ_TAREFA
				(cTRBQ400)->TQ_ETAPA   := (cTRBQBKP)->TQ_ETAPA
				(cTRBQ400)->TQ_DESCRIC := (cTRBQBKP)->TQ_DESCRIC
				(cTRBQ400)->TQ_CODFUNC := (cTRBQBKP)->TQ_CODFUNC
				(cTRBQ400)->TQ_SEQETA  := (cTRBQBKP)->TQ_SEQETA
				dbSelectArea(cTRBQBKP)
				dbSkip()
			EndDo
		EndIf

		aROTINA := aCLONE(OLDROT)

		dbSelectArea("STQ")
		dbSeek(xFilial('STQ'))
		dbSelectArea("STJ")
		dbSetOrder(nINDETA)
		MV_PAR01 := cAnMVPAR01

		If !lRotF6
			oTmpTbl3:Delete()
			oTmpTbl4:Delete()
			oTmpTbl5:Delete()
			If lTmpTbl6
				oTmpTbl6:Delete()
				lTmpTbl6 := .F.
			EndIf
		EndIf

	EndIf

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400GPRE
Consiste e gera O.S. preventiva
@author Paulo Pego
@since XX/XX/XXXX
@version undefined
@param cTIPOETA, characters
@type function
/*/
//---------------------------------------------------------------------
Function NG400GPRE(cTIPOETA)

	Local cVINCLUIOS := { .F., Space( TAMSX3("TJ_ORDEM")[1] ) }
	Local nSEQTP1    := nSEQSTJ,nSEQPOS := nSEQSTJ
	Local aSeqSTF    := {}
	Local aRegSTF    := {}
	Local aAreaSTJ   := STJ->(GetArea())

	Local cTipoMan, cServCar
	dbSelectArea("TP1")
	dbSetOrder(1)
	If dbSeek( xFilial("TP1") + cBemSTJ + (cTRB3400)->TPC_SERVIC + nSEQPOS + (cTRB3400)->TPC_TAREFA +;
	(cTRB3400)->TPC_ETAPA + (cTRB3400)->TPC_OPCAO )
		nSEQTP1 := TP1->TP1_SEQRMN
	EndIf

	//Tenta encontrar a Manutenção, com a sequencia da tabela TP1
	dbSelectArea("STF")
	dbSetOrder(1)
	If dbSeek(xFilial("STF")+cBEMSTJ+(cTRB3400)->TPC_SERVIC+nSEQTP1)
		aSeqSTF := STF->(GetArea())
	Else
		//Se não encontrar, verifica as manutenções ativas
		dbSelectArea("STF")
		dbSetOrder(1)
		If dbSeek(xFilial("STF")+cBEMSTJ+(cTRB3400)->TPC_SERVIC)
			While !EoF() .And. xFilial("STF")+cBEMSTJ+(cTRB3400)->TPC_SERVIC == STF->(TF_FILIAL+TF_CODBEM+TF_SERVICO)
				If STF->TF_ATIVO <> "N"
					aSeqSTF := STF->(GetArea())
					aAdd( aRegSTF , { 	.F.            ,; //Marcado S/N
					STF->TF_SEQRELA,; //Sequencia
					STF->TF_NOMEMAN,; //Nome Manutenção
					STF->TF_DTULTMA,; //Data Ultima Manutenção
					NGSEEK("STD",STF->TF_CODAREA,1,"STD->TD_NOME"),; //Area
					NGSEEK("STE",STF->TF_TIPO,1,"STE->TE_NOME") } ) //Tipo
				EndIf
				dbSelectArea("STF")
				dbSkip()
			EndDo
		EndIf

		//Se encontrar mais do que 1 manutenção, abre tela para o usuário selecionar qual sequência da manutenção deseja gerar
		If Len(aRegSTF) > 1
			aSeqSTF := {}
			nRetTmp := MNT400STF(aRegSTF,cNOSOLD,cBEMOLD,cBEMSTJ,cSEROLD,(cTRB3400)->TPC_SERVIC,(cTRB3400)->TPC_ETAPA)
			If nRetTmp > 0 .And. Len(aRegSTF) >= nRetTmp
				dbSelectArea("STF")
				dbSetOrder(1)
				If dbSeek(xFilial("STF")+cBEMSTJ+(cTRB3400)->TPC_SERVIC+aRegSTF[nRetTmp,2])
					aSeqSTF := STF->(GetArea())
				EndIf
			EndIf
		ElseIf Len(aRegSTF) == 0
			cDessEta := Alltrim(Upper( NGSEEK("TPA",(cTRB3400)->TPC_ETAPA,1,"TPA->TPA_DESCRI") ))

			ShowHelpDlg( STR0025, { STR0286 + " '" + cDessEta + "', " + STR0287 }, 3, { STR0288 + " " +;
			AllTrim(cBEMSTJ) + STR0289 + STR0279 + " " + AllTrim( (cTRB3400)->TPC_SERVIC ) + STR0290 }, 2 )

			// "Atenção" ## "Houve a necessidade de gerar uma O.S. Preventiva a partir da resposta da etapa"
			// "porém não existe manutenção cadastrada para o Bem e Serviço."
			// "Serviço" ## "Cadastrar uma manutenção para o Bem" ## " com o "
			// " na rotina MNTA120."
		EndIf
	EndIf

	If Len(aSeqSTF) > 0
		RestArea(aSeqSTF)
		nSEQTP1 := STF->TF_SEQRELA

		dbSelectArea("STJ")
		Set Filter To

		cTipoMan := NGSEEK( "ST4", (cTRB3400)->TPC_SERVIC, 1, "T4_TIPOMAN")
		cServCar := NGSEEK( "STE", cTipoMan, 1, "TE_CARACTE")
		lRetorna := NGGERAOS( cServCar, dDataBase, cBemSTJ, (cTRB3400)->TPC_SERVIC,;
		nSeqTP1, "N", "N", "N", , NG400VPAR() )

		If lRETORNA[1][1] == 'S' .And. Empty(lRETORNA[1][2])
			If cTIPOETA <> Nil .And. cMODULO <> "MNT"
				dbSelectArea("TPC")
				dbSetOrder(01)
				If dbSeek(xFilial("TPC")+(cTRB3400)->TPC_ETAPA+(cTRB3400)->TPC_OPCAO)
					If !Empty(TPC->TPC_OBSERV)
						dbSelectArea("STJ")
						dbSetOrder(1)
						If dbSeek(xFilial("STJ")+lRETORNA[1][3]+"000001")
							RecLock("STJ",.F.)
							If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
								MsMM(,80,,TPC->TPC_OBSERV,1,,,"STJ","TJ_MMSYP")
							Else
								STJ->TJ_OBSERVA := TPC->TPC_OBSERV
							EndIf
							MsUnLock("STJ")
						EndIf
					EndIf
				EndIf
			EndIf

			dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(xFilial("STJ")+lRETORNA[1][3]+"000001")
				NGRAVATRBZ()
				If !(cTIPOETA <> Nil .And. cMODULO <> "MNT")
					cMsgObs := STR0291 + ": " + (cTRBZ400)->OSORIG + Chr(13) + Chr(10) //"O.S. Origem"
					cMsgObs += STR0016 + ": " + (cTRBZ400)->ETAPA + " - " + AllTrim(NGSEEK("TPA",(cTRBZ400)->ETAPA,1,"TPA_DESCRI")) + Chr(13) + Chr(10) //"Etapa"
					cMsgObs += STR0292 + ": " + (cTRBZ400)->OPCAO + Chr(13) + Chr(10) //"Opção"

					If (cTRBZ400)->TIPOET = '2'
						cMsgObs += STR0293 + ": " + NGSEEK("TPC",(cTRBZ400)->ETAPA+(cTRBZ400)->OPCAO,1,"TPC_CONDIN") + Chr(13) + Chr(10) //"Limite"
						cMsgObs += STR0294 + ": " + (cTRBZ400)->RESPOS //"Informou"
					Else
						cMsgObs += STR0295 + ": " + STR0027 //"Marcou"//"Sim"
					EndIf

					RecLock("STJ",.F.)

					If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
						MsMM(,80,,cMsgObs,1,,,"STJ","TJ_MMSYP")
					Else
						STJ->TJ_OBSERVA := cMsgObs
					EndIf
					MsUnLock("STJ")
				EndIf
			EndIf

			cVINCLUIOS := {.T.,lRETORNA[1][3]}
		EndIf

		dbSelectArea("STJ")
		If Type("aIndSTJ") == "A" .And. Type("cCondicao") == "C"
			bFiltraBrw := {|| FilBrowse("STJ",@aIndSTJ,@cCondicao) }
			Eval(bFiltraBrw)
		ElseIf Type("aInd460R") == "A" .And. Type("ccond460R") == "C"
			bFiltraBrw := {|| FilBrowse("STJ",@aInd460R,@ccond460R) }
			Eval(bFiltraBrw)
		EndIf
		RestArea(aAreaSTJ)
	EndIf

Return cVINCLUIOS

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400GCOR
Consiste e gera O.S. corretiva
@author Paulo Pego
@since XX/XX/XXXX
@version undefined
@param cTIPOETA, characters
@param cOPCAO, characters
@param cRESPOS, characters
@type function
/*/
//---------------------------------------------------------------------
Function NG400GCOR(cTIPOETA,cOPCAO,cRESPOS)

	Local cVINCLUIOS := { .F., Space( TAMSX3( 'TJ_ORDEM')[1]) }
	Local aAreaSTJ   := STJ->(GetArea())
	Local cServCar, cTipoMan

	If !Empty((cTRB3400)->TPC_SERVIC)
		dbSelectArea("STJ")
		Set Filter To

		cTipoMan := NGSEEK( "ST4", (cTRB3400)->TPC_SERVIC, 1, "T4_TIPOMAN")
		cServCar := NGSEEK( "STE", cTipoMan, 1, "TE_CARACTE")
		lRetorna := NGGERAOS( cServCar , dDATABASE, cBEMSTJ, (cTRB3400)->TPC_SERVIC, 0, "N", "N", "N", , NG400VPAR())

		If lRETORNA[1][1]= 'S' .And. Empty(lRETORNA[1][2])
			cXORDEM := STJ->TJ_ORDEM
			cXPLANO := STJ->TJ_PLANO

			dbSelectArea('TPE')
			dbSetOrder(1)
			If dbSeek(xFilial('TPE')+STJ->TJ_CODBEM)
				dbSelectArea( "STJ" )
				RecLock("STJ",.F.)
				STJ->TJ_POSCON2 := TPE->TPE_POSCON
				MsUnLock('STJ')
			EndIf
			If cTIPOETA <> Nil .And. cMODULO <> "MNT"
				dbSelectArea("TPC")
				dbSetOrder(01)
				If dbSeek(xFilial("TPC")+(cTRB3400)->TPC_ETAPA+(cTRB3400)->TPC_OPCAO)
					If !Empty(TPC->TPC_OBSERV)
						dbSelectArea("STJ")
						RecLock("STJ",.F.)
						If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
							MsMM(,80,,TPC->TPC_OBSERV,1,,,"STJ","TJ_MMSYP")
						Else
							STJ->TJ_OBSERVA := TPC->TPC_OBSERV
						EndIf
						MsUnLock("STJ")
					EndIf
				EndIf
			EndIf

			NGRAVATRBZ(cTIPOETA,cOPCAO,cRESPOS)
			dbSelectArea("STJ")
			dbSetOrder(01)
			If dbSeek(xFilial("STJ")+lRETORNA[1][3]+"000000")
				If !(cTIPOETA <> Nil .And. cMODULO <> "MNT")
					cMsgObs := STR0291 + ": " + (cTRBZ400)->OSORIG + Chr(13) + Chr(10) //"O.S. Origem"
					cMsgObs += STR0016 + ": " + (cTRBZ400)->ETAPA + " - " + AllTrim(NGSEEK("TPA",(cTRBZ400)->ETAPA,1,"TPA_DESCRI")) + Chr(13) + Chr(10) //"Etapa"
					cMsgObs += STR0292 + ": " + (cTRBZ400)->OPCAO + Chr(13) + Chr(10) //"Opção"

					If (cTRBZ400)->TIPOET = '2'
						cMsgObs += STR0431 + ": " + AllTrim( NGSEEK( "TPC", (cTRBZ400)->ETAPA + (cTRBZ400)->OPCAO, 1, "TPC_FORMUL" )) + Chr(13) + Chr(10) //"Limite" ## "Fórmula"
						cMsgObs += STR0294 + ": " + (cTRBZ400)->RESPOS //"Informou"
					Else
						cMsgObs += STR0295 + ": " + STR0027 //"Marcou"//"Sim"
					EndIf

					RecLock("STJ",.F.)

					If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
						MsMM(,80,,cMsgObs,1,,,"STJ","TJ_MMSYP")
					Else
						STJ->TJ_OBSERVA := cMsgObs
					EndIf
					MsUnLock("STJ")
				EndIf
			EndIf
			cVINCLUIOS := {.T.,lRETORNA[1][3]}
		EndIf

		dbSelectArea("STJ")
		If Type("aIndSTJ") == "A" .And. Type("cCondicao") == "C"
			bFiltraBrw := {|| FilBrowse("STJ",@aIndSTJ,@cCondicao) }
			Eval(bFiltraBrw)
		ElseIf Type("aInd460R") == "A" .And. Type("ccond460R") == "C"
			bFiltraBrw := {|| FilBrowse("STJ",@aInd460R,@ccond460R) }
			Eval(bFiltraBrw)
		EndIf
		RestArea(aAreaSTJ)
	EndIf

Return cVINCLUIOS

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400EXC
Exclusao de O.S. de qualquer tipo
@author Paulo Pego
@since XX/XX/XXXX
@version undefined
@param cALIAS, characters, alias do registro
@param nREG, numeric, numero do registro
@param nOPC, numeric, numero da opcao do menu
@param cCnclTxt, characters, obs de cancelamento. indica que nao mostra telas
@type function
/*/
//---------------------------------------------------------------------
Function NG400EXC(cALIAS,nREG,nOPC,cCnclTxt)

	Local lVAR01 := 1,nLINHAS := 0,bCAMPO,nOPCA,nCNTDELE := 0,cCOD
	Local oDLG
	Local lERRO 	:= .F.
	Local i			:= 0
	Local oMenu
	Local lCLICK   	:= (TYPE("aSMENU")   == "A") .And. Len(aSMENU) > 0
	Local lIntSFC 	:= FindFunction("NGINTSFC") .And. NGINTSFC() // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]
	Local aAreaSTJ 	:= {}
	Local cNGMNTES 	:= AllTrim(GetMv("MV_NGMNTES"))
	Local nRecStj   := 0

	Default cCnclTxt := ''

	Private aTELA[0][0],aGETS[0]
	Private cCADASTRO := Oemtoansi(STR0023) //"Cadastro de O.S."
	Private TIPOACOM := .F., TIPOACOM2 := .F.,LSITUACA := "L"
	Private aSize := MsAdvSize(), aObjects := {}
	Private lObserv   := .T.
	Private nRec

	dbSelectArea("STJ")
	nINDSTJ := IndexOrd()

	If !NGFUNCRPO("NGACERTOMANU",,"NGUTIL05.PRX")
		dbSelectArea("STJ")
		dbSetOrder(nINDSTJ)
		Return 1
	EndIf

	If GetNewPar("MV_NGMNTCC","N") == "S"
		aAreaSTJ := GetArea()
		dbSelectArea("TV9")
		dbSetOrder(1)
		If dbSeek(xFilial("TV9")+STJ->TJ_CODBEM+STJ->TJ_ORDEM)
			MsgStop(STR0438,STR0022)
			Return .F.
		EndIf
		RestArea(aAreaSTJ)
	EndIf

	// Caso integrado ao modulo SIGASFC, e o bem for uma maquina
	// Verifica se será possivel cancelar a parada programada relacionada a O.S.
	If STJ->TJ_PLANO > "000000" .And. lIntSFC .And. !Empty(NGVRFMAQ(STJ->TJ_CODBEM)) .And. ;
	!NGSFCDELPP(STJ->TJ_ORDEM,.F.,.F.)

		NGSFCSNDML(3, {{STJ->TJ_ORDEM}}) // Envia e-mail ao responsavel no SIGASFC

		dbSelectArea("STJ")
		dbSetOrder(nINDSTJ)
		Return
	EndIf

	bCAMPO := {|nCPO| Field(nCPO)}
	If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
		M->TJ_OBSERVA := NGMEMOSYP(STJ->TJ_MMSYP)
	Else
		M->TJ_OBSERVA := STJ->TJ_OBSERVA
	EndIf

	dbSelectArea("STL")
	dbSetOrder(03)
	dbSeek(xFilial('STL')+STJ->TJ_ORDEM+STJ->TJ_PLANO)
	While !EoF() .And. STL->TL_FILIAL == xFilial('STL') .And.;
	STL->TL_ORDEM == STJ->TJ_ORDEM .And. STL->TL_PLANO == STJ->TJ_PLANO
		If Alltrim(STL->TL_SEQRELA) <> "0"
			Help(" ",1,"HAREPORT")
			dbSelectArea("STJ")
			Return 1
		EndIf

		If cNGMNTES == "S"

			//Verificar se possui uma S.A. com pré-requisição
			If !NGCHKSAPR( STL->TL_CODIGO, STL->TL_PLANO, , .F., .T. )
				Return 1
			EndIf

		EndIf
		dbSelectArea("STL")
		dbSkip()
	End

	dbSelectArea(cALIAS)
	dbSetOrder(1)
	For i := 1 To FCount()
		M->&(EVAL(bCampo,i)) := &(EVAL(bCampo,i))
	Next i

	If Empty(cCnclTxt)
		nOPCA := 0
		aAdd(aObjects,{015,020,.T.,.T.})
		aAdd(aObjects,{100,100,.T.,.T.})
		aInfo   := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
		aPosObj := MsObjSize(aInfo, aObjects,.T.)

		Define Msdialog oDLG Title cCADASTRO From aSize[7],0 To aSize[6],aSize[5] Of oMAINWND PIXEL
		oEnchoice := Msmget():New("STJ",nREG,nOPC,,,,,;
		{10/*Linha Inicial*/,aPosObj[2,2]/*Coluna Inicial*/,aPosObj[2,3]/*Linha Final*/,aPosObj[2,4]/*Coluna Final*/},;
		,3,,,,oDLG)
		oEnchoice:oBox:Align := CONTROL_ALIGN_ALLCLIENT

		If lCLICK
			NGPOPUP(aSMenu,@oMenu)
			oDLG:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDLG)}
			oEnchoice:oBox:bRClicked := { |o,x,y| oMenu:Activate(x,y,oDlg)}
		EndIf

		Activate Msdialog oDLG On Init EnchoiceBar(oDLG,{|| nOPCA := 2,If(MNT400VFIN(),oDLG:End(),nOPCA := 1)},{|| nOPCA := 1,oDLG:End()})

	EndIf

	dbSelectArea(cALIAS)
	If !Empty(cCnclTxt) .Or. nOPCA == 2

		nRecStj := STJ->(RecNo())

		If !NGGERCOTAC(STJ->TJ_ORDEM)[1]
			nOPCA := 1
			Return nOPCA
		EndIf

		If ExistBlock("NGTERMOT")
			If !ExecBlock("NGTERMOT",.F.,.F.)
				Return nOPCA
			EndIf
		EndIf


		If !NGDELETOS(STJ->TJ_ORDEM,STJ->TJ_PLANO)
			Return 1 // Encerra processo caso ocorreu algum problema.
		EndIf
		//Exclui o lancamento de contador relacionado ao bem do Contador 1
		If !EMPTY(STJ->TJ_HORACO1) .And. STJ->TJ_POSCONT > 0
			MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO1,1)   // Hora de inclusão da O.S. não tem
			If !Empty(STJ->TJ_DTMRFIM)
				MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTMRFIM,STJ->TJ_HORACO1,1)
			EndIf
		EndIf

		//Exclui o lancamento de contador relacionado ao bem do Contador 2
		If !EMPTY(STJ->TJ_HORACO2) .And. STJ->TJ_POSCON2 > 0
			MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO2,2)  // Hora de inclusão da O.S. não tem
			If !Empty(STJ->TJ_DTMRFIM)
				MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTMRFIM,STJ->TJ_HORACO2,2)
			EndIf
		EndIf

		// chama funcao para alteracao do campo Observacao
		If lObserv
			If ExistBlock("MNTA400A")
				ExecBlock("MNTA400A",.F.,.F.)
			ElseIf !Empty(cCnclTxt)
				dbSelectArea("STJ")
				dbGoTo(nRecStj)
				dbSelectArea("STJ")
				RecLock('STJ',.F.)
				If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
					MsMM(STJ->TJ_MMSYP,80,,cCnclTxt,1,,,"STJ","TJ_MMSYP")
				Else
					STJ->TJ_OBSERVA := cCnclTxt
				EndIf
				MsUnLock('STJ')
			Else
				NG400ALTMM(nRecStj)
			EndIf
		EndIf
		//---------------------------------------------------
		cCODBEM := STJ->TJ_CODBEM
		lSTJAchou  := A400STJBUS(cCODBEM)

		dbSelectArea("ST9")
		dbSetOrder(1)

		If dbSeek(xFilial("ST9")+cCODBEM)
			RecLock("ST9",.F.)

			If lSTJAchou = .F.
				ST9->T9_TERCEIR := "1"
			EndIf

			MsUnLock("ST9")
		EndIf
		//---------------------------------------------------

		If Select("TQE") > 0
			dbSelectArea("TQE")
			dbSetOrder(1)
			If dbSeek(xFilial("TQE")+STJ->TJ_ORDEM+STJ->tj_plano)
				RecLock('TQE',.F.)
				TQE->TQE_SITUAC := "C"
				MsUnLock('TQE')
			EndIf
		EndIf

		If lIntSFC .And. !Empty(NGVRFMAQ(cCodBem))
			NGSFCDELPP(STJ->TJ_ORDEM)
		EndIf

		If Val(STJ->TJ_PLANO) > 0 .And. !Empty(STJ->TJ_DTMRFIM)
			NGACERTOMANU(STJ->TJ_CODBEM,STJ->TJ_SERVICO,STJ->TJ_SEQRELA,STJ->TJ_DTMRFIM,STJ->TJ_HORACO1,STJ->TJ_HORACO2)
		EndIf

	EndIf
	dbSelectArea("STJ")
	dbSetOrder(nINDSTJ)

Return nOPCA

//------------------------------------------------------------------------
/*/{Proteus.doc} MNT400VFIN
Consistencias na confirmação do Cancelamento de O.S.
@type function

@author Hugo Rizzo Pereira
@since  26/12/2011

@sample MNT400VFIN()

@param  
@return boolean, Indica ser a ordem de serviço pode ser cancelada.
/*/
//------------------------------------------------------------------------
Function MNT400VFIN()

	Local lRet := .T.

	lCriouTRBQ := .F.

	/*--------------------------------------------------------------------------------+
	| Consiste se existe SA vinculada diretamente a OS, sem um insumo ter gerado a SA |
	+--------------------------------------------------------------------------------*/
	If !MNTVldSAOS( STJ->TJ_ORDEM )

		lRet := .F.

	EndIf

	If lRet .And. ExistBlock( 'MNTA400G' )

		If !ExecBlock( 'MNTA400G', .F., .F. )

			lRet := .F.

		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400ALTMM
Monta tela para alteracao do campo Observacao da OS
@author Felipe Nathan Welter
@since 20/05/10
@version undefined
@param nRecNo, numeric, RecNo da OS (STJ) a ser alterada
@param aSMenu, array, Menu do click da direita - Opcional
@type function
/*/
//---------------------------------------------------------------------
Function NG400ALTMM(nRecNo,aSMenu)

	Local aArea := GetArea()
	Local cObs  := ""
	Local nOpcc := 0
	Local oDlg, oObs, oMenu

	dbSelectArea("STJ")
	dbGoTo(nRecNo)

	If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
		cObs := NGMEMOSYP(STJ->TJ_MMSYP)
	Else
		cObs := CriaVar("TJ_OBSERVA")
		cObs := STJ->TJ_OBSERVA
	EndIf

	Define Msdialog oDlg Title STR0105+STJ->TJ_ORDEM From 18,20 To 33,80 Of oMainWnd  //"Cancelamento da O.S.
	@ 37,8 Say STR0106 Of oDlg Pixel  //"Observacao"
	@ 45,8 Get oObs Var cObs Of oDlg Multiline Size 215,55 Pixel

	If ValType(aSMenu) == "A"
		NGPOPUP(aSMenu,@oMenu)
		oDlg:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg)}
	EndIf

	Activate Msdialog oDlg On Init EnchoiceBar(oDlg,{||nOpcc:=1,oDlg:End()},{||oDlg:End()})

	If nOpcc == 1
		dbSelectArea("STJ")
		RecLock('STJ',.F.)
		If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
			MsMM(STJ->TJ_MMSYP,80,,cObs,1,,,"STJ","TJ_MMSYP")
		Else
			STJ->TJ_OBSERVA := cObs
		EndIf
		MsUnLock('STJ')
	EndIf

	RestArea(aArea)

Return (nOpcc == 1)

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400MARCA
Consiste o campo OK
@author Paulo Pego
@since XX/XX/XXXX
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG400MARCA()

	If LastKey() == K_ENTER	 	// Marca Corrente
		RecLock("TRB",.F.)
		Replace TRB->TQ_OK With IIF(Empty(TRB->TQ_OK),cMARCA,"  ")
		MsUnLock()
	ElseIf LastKey() == K_ALT_M // Marca todos
		dbSelectArea("TRB")
		dbGotop()
		While !EoF()
			RecLock("TRB",.F.)
			Replace TRB->TQ_OK With cMARCA
			MsUnLock()
			dbSkip()
		End
		dbSelectArea("TRB")
		dbGotop()
	ElseIf LastKey() == K_ALT_R                             // Remove todas as marcas
		dbSelectArea("TRB")
		dbGotop()
		While !EoF()
			RecLock("TRB",.F.)
			Replace TRB->TQ_OK With "  "
			MsUnLock()
			dbSkip()
		End
		dbSelectArea("TRB")
		dbGotop()
	EndIf

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} ULTSEQ
Retorna próxima sequencia de um insumo

@author Paulo Pego
@since 01/08/97
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function ULTSEQ()

	Local aAreaSTL := STL->( GetArea() )
	Local cSEQ     := "0  "
	Local lPRIMLO  := .T.

	OLDKEY := INDEXORD()

	dbSelectArea("STL")
	dbSetOrder(3)
	dbSeek(xFilial("STL")+M->TL_ORDEM+M->TL_PLANO)

	While !EoF() .And. STL->TL_FILIAL == xFilial('STL') .And. STL->TL_ORDEM == M->TJ_ORDEM;
	.And. STL->TL_PLANO == M->TJ_PLANO

		If Val(stl->tl_seqrela) > 0
			If Val(STL->TL_SEQRELA) > Val(cSEQ)
				cSEQ := STL->TL_SEQRELA
			EndIf
		Else
			If isDigit(Substr(stl->tl_seqrela,1,1))
			Else
				cSEQ := If(lPRIMLO,stl->tl_seqrela,If(stl->tl_seqrela > cSEQ,stl->tl_seqrela,cSEQ))
				lPRIMLO := .F.
			EndIf
		EndIf

		dbSkip()
	End

	If !lPRIMLO
		If FindFunction("Soma1Old")
			cSEQR := PADL(Soma1Old(cSEQ),3)
		Else
			cSEQR := PADL(Soma1(cSEQ),3)
		EndIf
	Else
		If FindFunction("Soma1Old")
			cSEQR := If(Val(cSEQ) = 0,'1',PADL(Soma1Old(cSEQ),3))
		Else
			cSEQR := If(Val(cSEQ) = 0,'1',PADL(Soma1(cSEQ),3))
		EndIf
	EndIf

	RestArea( aAreaSTL )

Return cSEQR

//------------------------------------------------------------------------------------
/*/{Protheus.doc} VERDESTINO
Consistencia para o campo destino do insumo.
@type function

@author Inácio Luiz Kolling
@since 25/10/1997

@sample VERDESTINO( .T. )

@param  lTroca, Boolean, Força a troca do F3 para o campo código insumo.
@return .T.
/*/
//------------------------------------------------------------------------------------
Function VERDESTINO(lTroca)

	Local lACOLSD   := Type("aHeader") == "A"
	Local nPOSTIPRD := 0

	Default lTroca := .F.

	If (ReadVar() = 'M->TL_CODIGO') .Or. lTroca

		aTROCAF3 := {}

		If lACOLSD .And. cPrograma <> "MNTA402"
			nPOSTIPRD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
			If nPOSTIPRD > 0
				M->TL_TIPOREG := aCOLS[n][nPOSTIPRD]
			EndIf
		EndIf

		If M->TL_TIPOREG == "M"
			aAdd(aTROCAF3,{"TL_CODIGO", "ST1"})
		ElseIf M->TL_TIPOREG == "E"
			aAdd(aTROCAF3,{"TL_CODIGO", "ST0"})
		ElseIf M->TL_TIPOREG == "P"
			aAdd(aTROCAF3,{"TL_CODIGO", "SB1"})
		ElseIf M->TL_TIPOREG == "T"
			aAdd(aTROCAF3,{"TL_CODIGO", "SA2"})
		ElseIf M->TL_TIPOREG == "F"
			aAdd(aTROCAF3,{"TL_CODIGO", "SH4"})
		EndIf

		If ExistBlock( 'MNTA4000' )
			
			aTrocaF3 := ExecBlock( 'MNTA4000', .F., .F., { aTrocaF3, M->TL_TIPOREG } )

		EndIf

	EndIf

Return .T.

//----------------------------------------------------------------------------
/*/{Protheus.doc} CHECKCOD
Verifica se o codigo do produto nao existe (para Inclusao)
@tye function

@author Paulo Pego
@since 02/09/1997

@sample CHECKCOD( .T., .T. oGet:nAt, oGet:aCols, oGet:aHeader )

@param [lVld]   , Lógico  , Indica se consiste local estoque padrao
@param [lChF]   , Lógico  , Indica se consiste localizacao fisica na confirmacao
@param [nPosAt] , Numerico, Valor da linha atual do getdados. (oGet:nAt)
@param [aColIns], Array   , aCols de insumos para validação. (oGet:aCols)
@param [aHeaIns], Array   , aHeader de insumos para validação. (oGet:aHeader)
@return .T.
/*/
//----------------------------------------------------------------------------
Function CHECKCOD(lVld, lChF, nPosAt, aColIns, aHeaIns )

	Local nRECNO	:= STL->( Recno() )
	Local lACOLSP 	:= .T.
	Local nPOSTIPRP	:= 0
	Local nUNIDAD   := 0
	Local l400RET   := If(Type("M->TJ_PLANO") == "U",.F.,.T.)
	Local lChFGra 	:= If( lChF == Nil, .T., lChF )
	Local cLoja		:= Space( TAMSX3("B1_LOCPAD")[1] )

	Local nForLoja  := 0
	Local nFornec   := 0

	Default nPosAt  := n
	Default aColIns := aCols
	Default aHeaIns := aHeader

	lRETORNO:= If(Type("lRETORNO")<> "L",.F.,lRETORNO)

	lVld := If(lVld == Nil,.F.,lVld)

	nOPCAO2        := .T.
	M->TL_NOMCODI  := Space(TAMSX3("TL_NOMCODI")[1])

	nUNIDAD   := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_UNIDADE' } )
	laColsP   := ValType( aHeaIns ) == "A"

	// Validação de insumos do tipo mão de obra.
	If M->TL_TIPOREG == 'M'

		//Testa o tamanho do campo para nao permitir informar codigo invalido
		If Len(Alltrim(M->TL_CODIGO)) > Len(ST1->T1_CODFUNC)
			Help(" ",1,"FUNCNEXIST")
			Return .F.
		EndIf

		If !ExistCpo( 'ST1', SubStr( M->TL_CODIGO, 1, Len( ST1->T1_CODFUNC ) ) )

			Return .F.

		EndIf

		M->TL_NOMCODI := Posicione( 'ST1', 1, xFilial( 'ST1' ) + SubStr( M->TL_CODIGO, 1, Len( ST1->T1_CODFUNC ) ), 'T1_NOME' )

		lVldRH := .T.

		If FunName() == 'MNTA400' // Se for MNTA400, somente será validado Situação de Demissão no botão Confirmar(OK)

			lVldRH := .F.

		EndIf

		If !NGFUNCRH( M->TL_CODIGO, .T., M->TL_DTFIM, lVldRH )

			Return .F.

		EndIf

	// Validação de insumos do tipo produto.
	ElseIf M->TL_TIPOREG == 'P'

		//Não permite selecionar um produto 'bloqueado'
		If !Empty(M->TL_CODIGO)
			If !EXISTCPO("SB1",M->TL_CODIGO)
				Return .F.
			EndIf
		EndIf

		//Testa o tamanho do campo para nao permitir informar codigo invalido
		If Len(Alltrim(M->TL_CODIGO)) > Len(SB1->B1_COD)
			Help(" ",1,"PRODNEXIST")
			Return .F.
		EndIf

		cCODSTL := Substr(M->TL_CODIGO,1,Len(SB1->B1_COD))
		If !Empty( cCODSTL ) .And. !NGPRODESP( cCODSTL )
			Return .F.
		EndIf

		If !ExistCpo( 'SB1', cCODSTL, 1  )
			Return .F.
		EndIf

		If nUNIDAD > 0
			aColIns[nPosAt,nUNIDAD] := SB1->B1_UM
		Else
			M->TL_UNIDADE := SB1->B1_UM
		EndIf

		M->TL_NOMCODI := SB1->B1_DESC
		lREFRESH := .T.
		nOPCAO2 := .F.

		nLOC := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_LOCAL"})

		If !lVld
			dbSelectArea("ST9")
			If lCORRET .Or. nLOC > 0
				If nLOC > 0
					If FieldPos('T9_ALMOPER') > 0
						aColIns[nPosAt][nLOC] := ST9->T9_ALMOPER
					Else
						aColIns[nPosAt][nLOC] := NGALMOXA( ST9->T9_CODBEM, M->TL_CODIGO, M->TL_TIPOREG, .T. )
					EndIf
				Else
					M->TL_LOCAL := NGALMOXA( ST9->T9_CODBEM, M->TL_CODIGO, M->TL_TIPOREG, .T. )
				EndIf
			Else
				If FieldPos('T9_ALMOPER') > 0
					M->TL_LOCAL := ST9->T9_ALMOPER
				Else
					M->TL_LOCAL := NGALMOXA( ST9->T9_CODBEM, M->TL_CODIGO, M->TL_TIPOREG, .T. )
				EndIf
				lREFRESH    := .T.
			EndIf
		EndIf

		dbSelectArea("STL")

		//Zera os campos de controle de rastreabilidade quando for trocado o codigo do produto
		nLOTECTL := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
		nNUMLOTE := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
		nDTVALID := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_DTVALID"})
		nLOCALIZ := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
		nNUMSERI := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})

		If lChFGra
			If nLOTECTL > 0 .And. nNUMLOTE > 0 .And. nDTVALID > 0 .And. nLOCALIZ > 0 .And. nNUMSERI > 0
				If !Empty(aColIns[nPosAt][nLOTECTL]) .Or. !Empty(aColIns[nPosAt][nNUMLOTE]) .Or. !Empty(aColIns[nPosAt][nDTVALID]);
				.Or. !Empty(aColIns[nPosAt][nLOCALIZ]) .Or. !Empty(aColIns[nPosAt][nNUMSERI])
					aColIns[nPosAt][nLOTECTL] := Space(Len(STL->TL_LOTECTL))
					aColIns[nPosAt][nNUMLOTE] := Space(Len(STL->TL_NUMLOTE))
					aColIns[nPosAt][nDTVALID] := CTOD("  /  /  ")
					aColIns[nPosAt][nLOCALIZ] := Space(Len(STL->TL_LOCALIZ))
					aColIns[nPosAt][nNUMSERI] := Space(Len(STL->TL_NUMSERI))
				EndIf
			Else
				If !Empty(M->TL_LOTECTL) .Or. !Empty(M->TL_NUMLOTE) .Or. !Empty(M->TL_DTVALID);
				.Or. !Empty(M->TL_LOCALIZ) .Or. !Empty(M->TL_NUMSERI)
					M->TL_LOTECTL := Space(Len(STL->TL_LOTECTL))
					M->TL_NUMLOTE := Space(Len(STL->TL_NUMLOTE))
					M->TL_DTVALID := CTOD("  /  /  ")
					M->TL_LOCALIZ := Space(Len(STL->TL_LOCALIZ))
					M->TL_NUMSERI := Space(Len(STL->TL_NUMSERI))
				EndIf
			EndIf
		EndIf

	// Validação de insumos do tipo terceiros.
	ElseIf M->TL_TIPOREG == 'T'

		//Testa o tamanho do campo para nao permitir informar codigo invalido
		If Len(Alltrim(M->TL_CODIGO)) > Len(SA2->A2_COD)
			Help(" ",1,"TERCNEXIST")
			Return .F.
		EndIf

		nLoc     := GDFieldPos( 'TL_LOCAL' , aHeaIns )
		nFornec  := GDFieldPos( 'TL_FORNEC', aHeaIns )
		nForLoja := GDFieldPos( 'TL_LOJA'  , aHeaIns )

		If Empty( M->TL_CODIGO )

			If !Empty( nLoc )

				GDFieldPut( 'TL_LOCAL', Space( 2 ), nPosAt, aHeaIns, aColIns )

			EndIf

			If !Empty( nFornec ) .And. !Empty( nForLoja )

				GDFieldPut( 'TL_FORNEC', Space( Len( SA2->A2_COD ) ) , nPosAt, aHeaIns, aColIns )
				GDFieldPut( 'TL_LOJA'  , Space( Len( SA2->A2_LOJA ) ), nPosAt, aHeaIns, aColIns )

			EndIf

		Else

			If M->TL_CODIGO != SA2->A2_COD
				SA2->(dbSetOrder(1))
				SA2->(dbSeek(xFilial("SA2")+Alltrim(M->TL_CODIGO)))
			EndIf

			cLoja := SA2->A2_LOJA

			If !ExistCpo( 'SA2', PadR( M->TL_CODIGO, FWTamSX3( 'A2_COD' )[1] ) + cLoja )

				Return .F.
			
			EndIf

			M->TL_NOMCODI := SA2->A2_NOME

			If !Empty( nFornec ) .And. !Empty( nForLoja )

				GDFieldPut( 'TL_FORNEC', SA2->A2_COD , nPosAt, aHeaIns, aColIns )
				GDFieldPut( 'TL_LOJA'  , cLoja       , nPosAt, aHeaIns, aColIns )

			EndIf

		EndIf

	// Validação de insumos do tipo ferramentas.
	ElseIf M->TL_TIPOREG == 'F'

		//Testa o tamanho do campo para nao permitir informar codigo invalido
		If Len(Alltrim(M->TL_CODIGO)) > Len(SH4->H4_CODIGO)
			Help(" ",1,"FERRNEXIS")
			Return .F.
		EndIf

		If !ExistCpo( 'SH4', SubStr( M->TL_CODIGO, 1, Len( SH4->H4_CODIGO ) ) )

			Return .F.

		EndIf

		M->TL_NOMCODI := Posicione( 'SH4', 1, xFilial( 'SH4' ) + SubStr( M->TL_CODIGO, 1, Len( SH4->H4_CODIGO ) ), 'H4_DESCRI' )

	// Validação de insumos do tipo especialidade.
	ElseIf M->TL_TIPOREG == 'E'

		//Testa o tamanho do campo para nao permitir informar codigo invalido
		If Len(Alltrim(M->TL_CODIGO)) > Len(ST0->T0_ESPECIA)
			Help(" ",1,"ESPENEXIST")
			Return .F.
		EndIf

		If !ExistCpo( 'ST0', SubStr( M->TL_CODIGO, 1, Len( ST0->T0_ESPECIA ) ) )

			Return .F.

		EndIf

		M->TL_NOMCODI := Posicione( 'ST0', 1, xFilial( 'ST0' ) + SubStr( M->TL_CODIGO, 1, Len( ST0->T0_ESPECIA ) ), 'T0_NOME' )

	Else
		M->TL_TIPOREG := "M"

		If laColsP .And. ( nPosTipRP := aScan( aHeaIns, { |x| AllTrim( Upper( x[2] ) ) == 'TL_TIPOREG' } ) ) > 0

			If !Empty( aColIns[nPosAt,nPosTipRP] )
				M->TL_TIPOREG := aColIns[nPosAt,nPosTipRP]
			Else
				aColIns[nPosAt,nPosTipRP] := M->TL_TIPOREG
			EndIf

		EndIf

		VERDESTINO(.T.)

		If M->TL_TIPOREG == "M"

			//Testa o tamanho do campo para nao permitir informar codigo invalido
			If Len(Alltrim(M->TL_CODIGO)) > Len(ST1->T1_CODFUNC)
				Help(" ",1,"FUNCNEXIST")
				Return .F.
			EndIf

			cCODSTL := Substr(M->TL_CODIGO,1,Len(ST1->T1_CODFUNC))
			If !ST1->(dbSeek(xFilial('ST1')+cCODSTL))
				Help(" ",1,"FUNCNEXIST")
				Return .F.
			EndIf
			M->TL_NOMCODI := ST1->T1_NOME
		EndIf
	EndIf

	If lRETORNO
		If ExistBlock("NGTERMOR")
			If !ExecBlock("NGTERMOR",.F.,.F.)
				Return .F.
			EndIf
		EndIf
	EndIf

	If !( FunName() $ 'MNTA990' .Or. IsInCallStack( 'NG410INC' ) .Or. IsInCallStack( 'MNTA232' ) .Or.;
		FWIsInCallStack( 'fExecEtap' ) .Or. FWIsInCallStack( 'MNA435VLDA' ) )

		If INCLUI .And. l400RET
			M->TL_SEQRELA := nSEQUENC
			OLDKEY := STL->(IndexKey())
			STL->(dbSetOrder(1))
			STL->(dbSeek(xFilial('STL')+M->TJ_ORDEM+M->TJ_PLANO+M->TL_TAREFA+M->TL_TIPOREG+M->TL_CODIGO+M->TL_SEQRELA))
			If Found()
				If STL->TL_FILIAL == xFilial("STL") .And.  M->TJ_ORDEM == STL->TL_ORDEM .And.;
				M->TJ_PLANO == STL->TL_PLANO .And. M->TL_TAREFA == STL->TL_TAREFA  .And.;
				M->TL_TIPOREG == STL->TL_TIPOREG .And. M->TL_CODIGO == STL->TL_CODIGO .And.;
				M->TL_SEQRELA == STL->TL_SEQRELA
					Help(" ",1,"RETJAEXIT")
					Return .F.
				EndIf
			EndIf
			STL->(dbSetOrder(1))
			STL->(dbGoto(nRECNO))
		EndIf

	EndIf

	xx := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
	If xx > 0
		aColIns[nPosAt][xx] := M->TL_NOMCODI
	EndIf

	If M->TL_TIPOREG <> "P"
		If nUNIDAD > 0
			aColIns[nPosAt,nUNIDAD] := "H"
		Else
			M->TL_UNIDADE := "H"
		EndIf
	EndIf

	If ValType(MV_PAR01) <> "C" .And. Type("cPar01") <> "U"
		MV_PAR01 := cPar01
		MV_PAR02 := cPar02
		MV_PAR05 := cPar05
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MOSTRADAT
Mostra a data final de consumo de insumo
@author FERNANDO MELIM
@since XX/XX/XXXX
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MOSTRADAT()

	If M->TL_TIPOREG != 'P'
		dbSelectArea("STF")
		dbSetOrder(01)
		dbSeek(xFilial('STF')+STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,.T.)
		If Upper(AllTrim(M->TL_UNIDADE)) == "H"
			cINI  := HTOM(M->TL_HOINICI)
			cDAT  := M->TL_DTINICI
			cFIM  := cINI + (M->TL_QUANTID * (60))
			nSOMA := 0
			While cFIM > 1440
				nSOMA++
				cFIM -= 1440
			Enddo
			ARR := {cDAT+nSOMA,MTOH(cFIM)}
		Else
			ARR := PROXDAT(M->TL_DTINICI,M->TL_HOINICI,M->TL_UNIDADE,M->TL_QUANTID)
		EndIf
	EndIf
	If M->TL_TIPOREG != 'P'
		M->TL_DESTINO := ' '
		M->TL_DTFIM   := ARR[1]
		M->TL_HOFIM   := ARR[2]
	Else
		M->TL_DTFIM   := M->TL_DTINICI
	EndIf
	lREFRESH := .T.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} CALCQTDHO
Calcula a quantidade de horas
@author FERNANDO MELIM
@since XX/XX/XXXX
@version undefined

@type function
/*/
//---------------------------------------------------------------------
Function CALCQTDHO()

	M->TL_QUANTID := NGCALCH100(M->TL_DTINICI,M->TL_HOINICI,M->TL_DTFIM,M->TL_HOFIM)
	M->TL_UNIDADE := 'H'
	lREFRESH := .T.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCHKRET
Verifica se não existe retorno para o plano
@author PAULO PEGO
@since XX/XX/XXXX
@version undefined
@param cORDEM, characters
@param cPLANO, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGCHKRET(cORDEM,cPLANO)

	dbSelectArea("STL")
	dbSetOrder(1)
	dbSeek(xFilial('STL')+cORDEM+cPLANO)
	While !EoF() .And. STL->TL_FILIAL == xFilial('STL') .And.;
	STL->TL_ORDEM == cORDEM .And. STL->TL_PLANO == cPLANO
		If Alltrim(STL->TL_SEQRELA) != "0"
			Return .F.
		EndIf
		dbSkip()
	End

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} PROXDAT
Calcula a data final da tarefa e hora fim
@author Inacio Luiz Kolling
@since XX/XX/XXXX
@version undefined
@param dINI, date
@param hINI, , descricao
@param cUND, characters
@param nQTD, numeric
@type function
/*/
//---------------------------------------------------------------------
Function PROXDAT(dINI,hINI,cUND,nQTD)

	Local nREST,nTEMPO,nSEM,nFOL,nDIA,OLDDIA
	Local dFIM,hFIM

	cUND    := Trim(cUND)
	dFIM    := DINI
	hFIM    := hINI
	dMAX    := dFIM
	hMAX    := HTOM(hFIM)
	nSEM    := If(DOW(dINI)==1,7,DOW(dINI)-1)
	aDIAMAN := NG_H7(STF->TF_CALENDA)
	cHORA   := HTOM(hINI)
	OLDDIA  := 0

	If Empty(aDIAMAN) .Or. (Len(aDIAMAN) < nSEM)
		Help(" ",1,"CALENDINEX")
		Return {dINI, hINI}
	EndIf

	If cUND == "H"
		nTEMPO := nQTD * 60
		nFOL   := 0
		nSEM   := If(DOW(dINI)==1,7,DOW(dINI)-1)
		nHORA  := HTOM(aDIAMAN[nSEM][2]) - HTOM(hINI)
		nHORA  -= INTERVALO(hINI,aDIAMAN[nSEM][2],nSEM)
		nREST  := nTEMPO - nHORA
		nDIA   := nTEMPO
		OLDDIA := MAX(OLDDIA,nDIA)
		If nREST > 0
			While .T.
				If nTEMPO <= nHORA
					hFIM  := MTOH(cHORA+nTEMPO)
					nINTE := INTERVALO(MTOH(cHORA),hFIM,nSEM)
					hFIM  := MTOH(HTOM(hFIM)+nINTE)
					Exit
				EndIf
				dFIM++
				nTEMPO -= nHORA
				nSEM   := If(DOW(dFIM)==1,7,DOW(dFIM)-1)
				nHORA  := HTOM(aDIAMAN[nSEM][3])
				cHORA  := HTOM(aDIAMAN[nSEM][1])
			End
		Else
			hFIM  := MTOH(HTOM(hINI)+nTEMPO)
			nINTE := INTERVALO(MTOH(nDIA),hFIM,nSEM)
			hFIM  := MTOH(HTOM(hFIM)+nINTE)
			dFIM  := dINI
		EndIf
	Else
		If cUND == "S"
			nFOL   := (nQTD * 7)
			nTEMPO := 0
		ElseIf cUND == "M"
			nFOL   := (nQTD * 30)
			nTEMPO := 0
		Else
			nFOL   := nQTD
			nTEMPO := 0
		EndIf
		dFAZ   := dINI
		FIMS   := 0
		While .T.
			If nFOL <= 0; Exit; End
			nSEM := If(DOW(dFAZ)==1,7,DOW(dFAZ)-1)
			If nFOL > 0 .And. nFOL < 1
				nTEMPO += (HTOM(aDIAMAN[nSEM][3])*nFOL)
			Else
				nTEMPO += HTOM(aDIAMAN[nSEM][3])
			EndIf
			If HTOM(aDIAMAN[nSEM][3]) == 0 .And. cUND == "D"
				nFOL++
			EndIf
			nFOL--
			dFAZ++
		End
		nDIA   := nTEMPO
		OLDDIA := MAX(OLDDIA,nDIA)
		dFIM   := dFAZ
		nSEM   := If(DOW(dINI)==1,7,DOW(dINI)-1)

		If (HTOM(hINI) - HTOM(aDIAMAN[nSEM][1])) > 0
			nTEMPO += (HTOM(hINI) - HTOM(aDIAMAN[nSEM][1]))
			nTEMPO -= INTERVALO(aDIAMAN[nSEM][1],hINI,nSEM)
		EndIf

		nHORA := HTOM(aDIAMAN[nSEM][3])
		nREST := nTEMPO - nHORA
		dFIM  := dINI
		cHORA := HTOM(hINI)
		If nREST > 0
			While .T.
				If nTEMPO <= nHORA
					hFIM  := MTOH(cHORA+nTEMPO)
					nINTE := INTERVALO(MTOH(cHORA),hFIM,nSEM)
					hFIM  := MTOH(HTOM(hFIM)+nINTE)
					Exit
				EndIf
				dFIM++
				nTEMPO -= nHORA
				nSEM   := If(DOW(dFIM)==1,7,DOW(dFIM)-1)
				nHORA  := HTOM(aDIAMAN[nSEM][3])
				cHORA  := HTOM(aDIAMAN[nSEM][1])
			End
		Else
			hFIM  := MTOH(cHORA+nTEMPO)
			nINTE := INTERVALO(MTOH(cHORA),hFIM,nSEM)
			hFIM  := MTOH(HTOM(hFIM)+nINTE)
		EndIf
	EndIf

	If dFIM > dMAX
		dMAX := dFIM
		hMAX := HTOM(hFIM)
	ElseIf dFIM == dMAX .And. HTOM(hFIM) > hMAX
		hMAX := HTOM(hFIM)
	EndIf

	cHORA := HTOM(hINI)
	cHORA := hMAX

Return {dMAX,MTOH(hMAX)}

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400PROC

@author Inacio Luiz Kolling
@since XX/XX/XXXX
@version undefined
@param cCOD, characters, descricao
@type function
/*/
//---------------------------------------------------------------------
Function NG400PROC(cCOD)

	Local OLDALI 	:= ALIAS()
	Local lGRAVA	:= .F.
	Local cAliasSTL := GetNextAlias()
	Local cOrdem	:= Substr(cCOD,1,6)
	Local cPlano	:= Substr(cCOD,7,6)

	BeginSql Alias cAliasSTL
		SELECT TL_SEQRELA
		FROM %table:STL% STL
		WHERE	TL_FILIAL 	= %xFilial:STL%
			AND	TL_ORDEM 	= %exp:cOrdem%
			AND TL_PLANO	= %exp:cPlano%
			AND TL_SEQRELA  > "0"
			AND STL.%NotDel%
		ORDER BY TL_SEQRELA
	EndSql

	lGRAVA := ( cAliasSTL )->( !EoF() )

	(cAliasSTL)->(DbCloseArea())

	dbSelectArea("STJ")
	If lGRAVA
		RecLock("STJ",.F.)
		STJ->TJ_TIPORET := "S"
		MsUnLock("STJ")
	Else
		//Inclusão de validação sobre os campos Reservados, pois eles são gravados erroneamente pelo
		//framework apenas por existir no dicionário (sem alteração qualquer)
		If !Empty(STJ->TJ_TIPORET)
			RecLock("STJ",.F.)
			STJ->TJ_TIPORET := " "
			MsUnLock("STJ")
		EndIf
	EndIf
	dbSelectArea(OLDALI)

Return (STJ->TJ_TIPORET == "S")

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400VARDIA
Funcao que v lida a novo variacao dia
@author Inacio Luiz Kolling
@since 19/11/99
@version undefined
@param nQTD, numeric, Valor do Contador
@param cBEM, characters, Codigo do bem
@param cTIPO, characters, Tipo de retorno
@param nQTDPROD, numeric, Qunatidade produzida
@param cORDEM, characters, Numero da ordem de servico
@param cPLANO, characters, Numero do plano de manutencao
@param nQTD2, numeric, descricao
@type function
/*/
//---------------------------------------------------------------------
Function NG400VARDIA(nQTD,cBEM,cTIPO,nQTDPROD,cORDEM,cPLANO,nQTD2)

	Local dMAX := CTOD("01/01/1980")
	Local ALIASOLD := ALIAS()

	If !lTEMINUS
		dDTMRINI := M->TJ_DTMRINI
		dDTMRFIM := M->TJ_DTMRFIM
		cHOMRINI := M->TJ_HOMRINI
		cHOMRFIM := M->TJ_HOMRFIM
		cMENSHLP := Space(10)

		If !Empty(dDTMRINI) .And. !Empty(dDTMRFIM) .And. !Empty(cHOMRINI);
		.And. !Empty(cHOMRFIM)
			If dDTMRINI < STJ->TJ_DTMPINI
				cMENSHLP := "NGDTMANREI"
			ElseIf dDTMRFIM <= dDTMRINI
				cMENSHLP := "NGDTMANREF"
			EndIf
		Else
			cMENSHLP := "NGDTMANOBR"
		EndIf
		If !Empty(cMENSHLP)
			Help(" ",1,cMENSHLP)
			dbSelectArea(ALIASOLD)
			Return .F.
		EndIf

	EndIf

	dbSelectArea("ST9")
	dbSetOrder(1)

	If dbSeek(xFilial('ST9')+cBEM)
		If ST9->T9_TEMCONT == 'N'
			dbSelectArea(ALIASOLD)
			Return .T.
		EndIf
		If ST9->T9_POSCONT == nQTD .OR. Empty(nQTD)
			dbSelectArea(ALIASOLD)
			Return .T.
		EndIf
	EndIf

	dbSelectArea("STL")
	dbSetOrder(1)

	While !EoF() .And. STL->TL_FILIAL == xFilial('STL') .And.;
	STL->TL_ORDEM == cORDEM .And. STL->TL_PLANO  == cPLANO

		If lPDR  // PELO PADRAO
			If Alltrim(STL->TL_SEQRELA) == "0"
				dMAX := MAX(dMAX,STL->TL_DTFIM)
			Else
				dbSkip()
				Loop
			EndIf
		Else  // REALIZADO
			If Alltrim(STL->TL_SEQRELA) == "0"
				dbSkip()
				Loop
			EndIf
			dMAX := MAX(dMAX,STL->TL_DTFIM)
		EndIf
		dbSelectArea("STL")
		dbSkip()
	End

	dbSelectArea(ALIASOLD)
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400INV
Inverte marcacoes - Windows
@author Paulo Pego
@since 09/11/99
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG400INV()
	Local nReg 		:= (cTRBQ400)->(Recno())
	Local lMNTA400C := ExistBlock("MNTA400C")
	Local lFunGrav	:= Type('lGravaFun') != 'U'

	dbSelectArea(cTRBQ400)
	dbSetOrder(02)
	DBGoTop()
	Do While !EoF()

		//Nao pode desmarcar Etapa, caso a resposta desta etapa gerou uma OS e esta OS nao esta com situação cancelada
		If !Empty((cTRBQ400)->TQ_OK)
			//Verifica se foi gerada OS para esta etapa, e a OS gerada nao esta cancelada
			If !MNT400OSG( (cTRBQ400)->TQ_ORDEM , (cTRBQ400)->TQ_PLANO , (cTRBQ400)->TQ_TAREFA , (cTRBQ400)->TQ_ETAPA , .F. )
				dbSelectArea(cTRBQ400)
				dbSkip()
				Loop
			ElseIf !MNT400SSG( (cTRBQ400)->TQ_ORDEM, (cTRBQ400)->TQ_PLANO, (cTRBQ400)->TQ_TAREFA, (cTRBQ400)->TQ_ETAPA, .F. )
				dbSelectArea(cTRBQ400)
				dbSkip()
				Loop
			EndIf
		EndIf

		If lMNTA400C
			If !ExecBlock("MNTA400C",.F.,.F.)
				dbSelectArea(cTRBQ400)
				dbSkip()
				Loop
			EndIf
		EndIf

		Reclock(cTRBQ400, .F.)

		(cTRBQ400)->TQ_OK := IIF(Empty(TQ_OK), cMARCA, Space(TAMSX3('TQ_OK')[1]))

		If Empty((cTRBQ400)->TQ_OK)
			(cTRBQ400)->TQ_CODFUNC := Space(TAMSX3("TQ_CODFUNC")[1])
		Else
			If lFunGrav
				(cTRBQ400)->TQ_CODFUNC := M->TL_CODIGO
			EndIf
		EndIf

		MsUnLock(cTRBQ400)

		dbSkip()
	EndDo

	(cTRBQ400)->(DBGoTo(nReg))
	lREFRESH := .T.

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NGTRBACRIA
Cria arquivo temporarios O.S. geradas e Mensagens tolerancia
@author Inacio Luiz Kolling
@since 06/06/2001
@version undefined
@param nOperation, numeric, Define a operação;
		1=Criação, 2=Deleção
@type function
@obs USO MNTA400/MNTA480
/*/
//---------------------------------------------------------------------

Function NGTRBACRIA(nOperation,cAlias1,cAlias2,oTmp1,oTmp2,oTmp3)

	If nOperation == 1
		aDBFZ := {}
			aAdd(aDBFZ,{"ORDEM"  ,"C",06, 0 })
			aAdd(aDBFZ,{"PLANO"  ,"C",06, 0 })
			aAdd(aDBFZ,{"CODBEM" ,"C",16, 0 })
			aAdd(aDBFZ,{"NOMBEM" ,"C",30, 0 })
			aAdd(aDBFZ,{"SERVICO","C",06, 0 })
			aAdd(aDBFZ,{"NOMSER" ,"C",30, 0 })
			aAdd(aDBFZ,{"SEQRELA","C",03, 0 })
			aAdd(aDBFZ,{"ETAPA"  ,"C",06, 0 })
			aAdd(aDBFZ,{"OPCAO"  ,"C",15, 0 })
			aAdd(aDBFZ,{"TIPOET" ,"C",01, 0 })
			aAdd(aDBFZ,{"RESPOS" ,"C",TAMSX3( 'TPQ_RESPOS' )[1], 0 })
			aAdd(aDBFZ,{"OSORIG" ,"C",06, 0 })

			aAdd(aTRBZ,{STR0029 ,"ORDEM"   ,"C",06,0,"@!"})  //"Ordem"
			aAdd(aTRBZ,{STR0030 ,"PLANO"   ,"C",06,0,"@!"})  //"Plano"
			aAdd(aTRBZ,{STR0031 ,"CODBEM"  ,"C",16,0,"@!"})  //"Bem"
			aAdd(aTRBZ,{STR0032 ,"NOMBEM"  ,"C",30,0,"@!"})  //"Nome Bem"
			aAdd(aTRBZ,{STR0033 ,"SERVICO" ,"C",06,0,"@!"})  //"Servico"
			aAdd(aTRBZ,{STR0034 ,"NOMSER"  ,"C",30,0,"@!"})  //"Nome Servico"
			aAdd(aTRBZ,{STR0035 ,"SEQRELA" ,"C",03,0,"@!"})  //"Sequen"

			//Instancia classe FWTemporaryTable
			oTmp3:= FWTemporaryTable():New( cTRBZ400, aDBFZ )
			//Adiciona os Indices
			oTmp3:AddIndex( "Ind01" , {"ORDEM"} )
			//Cria a tabela temporaria
			oTmp3:Create()

		aDBFK := {}
			aAdd(aDBFK,{"ORDEM"    ,"C",TamSx3("TJ_ORDEM")[1], 0 })
			aAdd(aDBFK,{"PLANO"    ,"C",TamSx3("TJ_PLANO")[1], 0 })
			aAdd(aDBFK,{"BEM"      ,"C",16, 0 })
			aAdd(aDBFK,{"ETAPA"    ,"C",06, 0 })
			aAdd(aDBFK,{"OPCAO"    ,"C",15, 0 })
			aAdd(aDBFK,{"RESPOSTA" ,"C",TAMSX3( 'TPQ_RESPOS' )[1], 0 })
			aAdd(aDBFK,{"INFORMOU" ,"C",10, 0 })
			aAdd(aDBFK,{"PERCENTO" ,"N",06, 2 })
			aAdd(aDBFK,{"VLRMENOR" ,"N",12, 2 })
			aAdd(aDBFK,{"VLRMAIOR" ,"N",12, 2 })
			aAdd(aDBFK,{"OBSERVA"  ,"C",50, 0 })

			aAdd(aTRBK,{STR0029 ,"ORDEM"    ,"C",TamSx3("TJ_ORDEM")[1],0,"@!"})//"Ordem"
			aAdd(aTRBK,{STR0030 ,"PLANO"    ,"C",TamSx3("TJ_PLANO")[1],0,"@!"})//"Plano"
			aAdd(aTRBK,{STR0031 ,"BEM"      ,"C",16,0,"@!"})                //"Bem"
			aAdd(aTRBK,{STR0016 ,"ETAPA"    ,"C",06,0,"@!"})                //"Etapa"
			aAdd(aTRBK,{STR0036 ,"OPCAO"    ,"C",15,0,"@!"})                //"Opcao"
			aAdd(aTRBK,{STR0037 ,"INFORMOU" ,"C",10,0,"@!"})                //"Informado"
			aAdd(aTRBK,{STR0038 ,"RESPOSTA" ,"C",TAMSX3( 'TPQ_RESPOS' )[1],0,"@!"})                //"Resposta"
			aAdd(aTRBK,{STR0039 ,"OBSERVA"  ,"C",40,0,"@!"})                //"Observacao"
			aAdd(aTRBK,{STR0040 ,"PERCENTO" ,"N",06,2,"@E 999.99"})         //"Percent."
			aAdd(aTRBK,{STR0041 ,"VLRMENOR" ,"N",12,2,"@E 999,999,999.99"}) //"Vlr Menor"
			aAdd(aTRBK,{STR0042 ,"VLRMAIOR" ,"N",12,2,"@E 999,999,999.99"}) //"Vlr Maior"

		//+--------------------------+
		//| Cria tabelas temporárias |
		//+--------------------------+
		cAlias1 := GetNextAlias() //Define alias
		oTmp1 := FWTemporaryTable():New( cAlias1, aDBFZ ) //Instancia a classe
		oTmp1:AddIndex( "Ind01" , {"ORDEM"} ) //Define o indice
		oTmp1:Create() //Cria a tabela

		cAlias2 := GetNextAlias() //Define alias
		oTmp2:= FWTemporaryTable():New( cAlias2, aDBFK ) //Instancia a classe
		oTmp2:AddIndex( "Ind01" , {"BEM","ETAPA"} ) //Define o indice
		oTmp2:Create() //Cria a tabela

	Else
		//+--------------+
		//|Deleta tabela |
		//+--------------+
		oTmp1:Delete()
		oTmp2:Delete()
		oTmp3:Delete()
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGRAVATRBZ
Grava o arquivo temporarios O.S. geradas
@author Inacio Luiz Kolling
@since 06/06/2001
@version undefined
@param cTIPOETA, characters
@param cOPCAO, characters
@param cRESPOS, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGRAVATRBZ(cTIPOETA,cOPCAO,cRESPOS)

	Local xalias := alias()

	dbSelectArea("ST9")
	dbSetOrder(1)
	dbSeek(xFilial('ST9') + STJ->TJ_CODBEM)
	dbSelectArea("ST4")
	dbSetOrder(1)
	dbSeek(xFilial('ST4') + STJ->TJ_SERVICO)

	dbSelectArea(cTRBZ400)
	RecLock((cTRBZ400),.T.)
	(cTRBZ400)->ORDEM   := STJ->TJ_ORDEM
	(cTRBZ400)->PLANO   := STJ->TJ_PLANO
	(cTRBZ400)->CODBEM  := STJ->TJ_CODBEM
	(cTRBZ400)->NOMBEM  := ST9->T9_NOME
	(cTRBZ400)->SERVICO := STJ->TJ_SERVICO
	(cTRBZ400)->NOMSER  := ST4->T4_NOME
	(cTRBZ400)->SEQRELA := STJ->TJ_SEQRELA
	(cTRBZ400)->ETAPA   := (cTRB3400)->TPC_ETAPA
	(cTRBZ400)->OPCAO   := If(cOPCAO <> Nil,cOPCAO,(cTRB3400)->TPC_OPCAO)
	(cTRBZ400)->TIPOET  := If(cTIPOETA <> Nil,cTIPOETA,(cTRB3400)->TPC_TIPRES)
	(cTRBZ400)->RESPOS  := If(cRESPOS <> Nil,cRESPOS,(cTRB3400)->TPC_RESPOS)

	If Type("cTRBQ400") == "C"
		(cTRBZ400)->OSORIG := (cTRBQ400)->TQ_ORDEM
	EndIf

	MsUnLock(cTRBZ400)
	dbSelectArea(xalias)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGGERAMENS
Grava o arquivo temporarios das tolerancia - opcoes resposta
@author Inacio Luiz Kolling
@since 06/06/2001
@version undefined
@param cORDEM, characters
@param cPLANO, characters
@param cBEM, characters
@param cETAPA, characters
@param cOPCAO, characters
@param cRESPOS, characters
@param cCONDIN, characters
@param nPERCEN, numeric
@param nMENOR, numeric
@param nMAIOR, numeric
@param cOBSERV, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGGERAMENS(cORDEM,cPLANO,cBEM,cETAPA,cOPCAO,cRESPOS,cCONDIN,nPERCEN,nMENOR,nMAIOR,cOBSERV)

	Local xalias := alias()

	dbSelectArea(cTRBK400)
	RecLock((cTRBK400),.T.)

	(cTRBK400)->ORDEM    := cORDEM
	(cTRBK400)->PLANO    := cPLANO
	(cTRBK400)->BEM      := cBEM
	(cTRBK400)->ETAPA    := cETAPA
	(cTRBK400)->OPCAO    := cOPCAO
	(cTRBK400)->RESPOSTA := cRESPOS
	(cTRBK400)->INFORMOU := cCONDIN
	(cTRBK400)->PERCENTO := nPERCEN
	(cTRBK400)->VLRMENOR := nVLRMENOR
	(cTRBK400)->VLRMAIOR := nVLRMAIOR
	(cTRBK400)->OBSERVA  := cOBSERV
	MsUnLock(cTRBK400)
	dbSelectArea(xalias)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGMOSTTRBZ
Mostra as O.S. geradas pelas opcoes de resposta da etapa
@author Inacio Luiz Kolling
@since 06/06/2001
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGMOSTTRBZ()

	Local aOldRotin   := aClone( aRotina )
	Private aROTINA   := {{STR0044,"NGTRBZIMP()", 0, 1}}
	Private cCADASTRO := Oemtoansi(STR0043) //"O.S. Geradas Pela Respostas das Opcoes das Etapas"

	aPOS1 := {15,1,95,315}
	dbSelectArea(cTRBZ400)
	dbGotop()
	mBrowse(6,1,22,75,cTRBZ400,aTRBZ)

	dbSelectArea("STJ")

	aRotina := aClone(aOldRotin)

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGTRBKMOST
Mostra as Tolerancia das opcoes de resposta da etapa
@author Inacio Luiz Kolling
@since 06/06/2001
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGTRBKMOST()

	Local aOldRotin   := aClone(aRotina)

	Private aROTINA   := {{STR0044,"NGTRBKIMP()", 0, 1}} //"Imprimir"
	Private cCADASTRO := Oemtoansi(STR0045) //"Nivel de tolerancia Para Analise"

	aPOS1 := {15,1,95,315}
	dbSelectArea(cTRBK400)
	dbGotop()
	mBrowse(6,1,22,75,cTRBK400,aTRBK)

	dbSelectArea("STJ")

	aRotina := aClone(aOldRotin)

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGTRBKIMP
Imprime as tolerancia das opcoes de resposta da etapa
@author Inacio Luiz Kolling
@since 06/06/2001
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGTRBKIMP()

	Local cString := "STJ"
	Local cdesc1  := STR0046 //"Emissao dos Bens Que atinguiram O Nivel de tolerancia"
	Local cdesc2  := STR0047 //"nas Resposta das Opcoes das Etapas"
	Local cdesc3  := " "
	Local wnrel   := "MNTA400"

	Private aReturn  := { STR0048, 1,STR0049, 1, 2, 1, "",1 } //"Zebrado"###"Administracao"
	Private nLastKey := 0
	Private Titulo   := STR0050 //"Bens Que Atinguiram o Nivel de tolerancia nas Respostas das Opcoes da Etapa"
	Private Tamanho  := "M"

	wnrel:=SetPrint(cString,wnrel,,titulo,cDesc1,cDesc2,cDesc3,.F.,"")
	If nLastKey = 27
		Set Filter To
		dbSelectArea("STJ")
		Return
	EndIf

	SetDefault(aReturn,cString)
	If nLastKey = 27
		Set Filter To
		dbSelectArea("STJ")
		Return
	EndIf

	RptStatus({|lEnd| NGIMPTRBK(@lEnd,wnRel,titulo,tamanho)},titulo)

	dbSelectArea("STI")

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³NGIMPTRBK ³ Autor ³In cio Luiz Kolling    ³ Data ³06/06/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Chamada do Relat¢rio de impressao tolerancia               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
//---------------------------------------------------------------------
/*/{Protheus.doc} NGIMPTRBK
Chamada do Relatório de impressao tolerancia
@author Inacio Luiz Kolling
@since 06/06/200
@version undefined
@param lEnd, logical
@param wnRel
@param titulo
@param tamanho
@type function
/*/
//---------------------------------------------------------------------
Static Function NGIMPTRBK(lEnd,wnRel,titulo,tamanho)

	Local cRodaTxt := ""
	Local nCntImpr := 0

	Private li := 80 ,m_pag := 1
	Private Cabec1   := STR0051 //"     Opcao               Resposta  Inf. Opcap  tolerancia  Valor Menor Valor Maior   Observacao Da Opcao De Resposta"
	Private Cabec2   := " "
	Private nomeprog := "MNTA400"
	Private nTipo    := IIF(aReturn[4]==1,15,18)

	dbSelectArea(cTRBK400)
	dbGotop()
	SetRegua(LastRec())

	/*
	1         2         3         4         5         6         7         8          9          100      110       120    130
	0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
	*************************************************************************************************************************************
	OPCAO           RESPOSTA  INF. OPCAO    TOLERNACIA    VALOR MENOR VALOR MAIOR   OBSERVACAO DA OPCAO DE RESPOSTA
	*************************************************************************************************************************************

	BEM..: XXXXXXXXXXXXXXXX  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	ETAPA..: XXXXXX  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


	XXXXXXXXXXXXXXX XXXXXXXXX XXXXXXXXX        999,99%     999.999,99  999.999,99   12345678901234567890123456789012345678901234567890
	*/

	While !EoF()

		cBEMTRBK := (cTRBK400)->BEM

		NGSOMALI(58)
		dbSelectArea("ST9")
		dbSetOrder(1)
		dbSeek(xFilial('ST9') + cBEMTRBK)
		@ Li,000 PSay STR0052 //"Bem..:"
		@ Li,007 PSay cBEMTRBK
		@ Li,025 PSay ST9->T9_NOME

		dbSelectArea(cTRBK400)
		While !EoF() .And. (cTRBK400)->BEM == cBEMTRBK

			cETAPA := (cTRBK400)->ETAPA
			NGSOMALI(58)
			dbSelectArea("TPA")
			dbSetOrder(1)
			dbSeek(xFilial('TPA') + cETAPA)
			@ Li,003 PSay STR0053 //"Etapa..:"
			@ Li,012 PSay cETAPA
			@ Li,020 PSay TPA->TPA_DESCRI

			dbSelectArea(cTRBK400)
			While !EoF() .And. (cTRBK400)->BEM == cBEMTRBK .And. (cTRBK400)->ETAPA == cETAPA

				IncRegua()
				NGSOMALI(58)
				@ Li,005 PSay (cTRBK400)->OPCAO    Picture '@!'
				@ Li,025 PSay (cTRBK400)->RESPOSTA Picture '@!'
				@ Li,035 PSay (cTRBK400)->INFORMOU Picture '@!'
				@ Li,050 PSay (cTRBK400)->PERCENTO Picture '@E 999.99%'
				@ Li,060 PSay (cTRBK400)->VLRMENOR Picture '@E 999,999.99'
				@ Li,072 PSay (cTRBK400)->VLRMAIOR Picture '@E 999,999.99'
				@ Li,085 PSay (cTRBK400)->OBSERVA  Picture '@!'
				dbSelectArea(cTRBK400)
				dbSkip()
			End
		End
	End

	Roda(nCntImpr,cRodaTxt,Tamanho)

	RetIndex("ST9")
	Set Filter To
	Set device To Screen

	If aReturn[5] = 1
		Set Printer To
		dbCommitAll()
		OurSpool(wnrel)
	EndIf
	MS_FLUSH()

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NGTRBZIMP
Imprime as O.S. Geradas pelas opcoes de resposta da etapa
@author Inacio Luiz Kolling
@since 06/06/2001
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGTRBZIMP()

	Local cString := "STJ"
	Local cdesc1  := STR0055 //"Emissao dos Ordens de Servico Geradas Pelo"
	Local cdesc2  := STR0056 //"Processo das Resposta das Opcoes das Etapas"
	Local cdesc3  := " "
	Local wnrel   := "MNTA400"

	Private aReturn  := { STR0048, 1,STR0049, 1, 2, 1, "",1 } //"Zebrado"###"Administracao"
	Private nLastKey := 0
	Private Titulo   := STR0057 //"O. S. Geradas Pelo Processo das Resposta das Opcoes das Etapas"
	Private Tamanho  := 'M'

	wnrel:=SetPrint(cString,wnrel,,titulo,cDesc1,cDesc2,cDesc3,.F.,"")
	If nLastKey = 27
		Set Filter To
		dbSelectArea("STJ")
		Return
	EndIf

	SetDefault(aReturn,cString)
	If nLastKey = 27
		Set Filter To
		dbSelectArea("STJ")
		Return
	EndIf

	RptStatus({|lEnd| NGIMPTRBZ(@lEnd,wnRel,titulo,tamanho)},titulo)

	dbSelectArea("STI")

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NGIMPTRBZ
Chamada do Relatório
@author Inacio Luiz Kolling
@since 06/06/2001
@version undefined
@param lEnd, logical
@param wnRel
@param titulo
@param tamanho
@type function
/*/
//---------------------------------------------------------------------
Static Function NGIMPTRBZ(lEnd,wnRel,titulo,tamanho)

	Local cRodaTxt := ""
	Local nCntImpr := 0

	Private li := 80 ,m_pag := 1
	Private Cabec1   := STR0058 //"Ordem  Plano  Bem              Nome do Bem                             Servico Nome Servico                             Seq."
	Private Cabec2   := " "
	Private nomeprog := "MNTA400"
	Private nTipo    := IIF(aReturn[4]==1,15,18)

	dbSelectArea(cTRBZ400)
	dbGotop()
	SetRegua(LastRec())

	/*
	1         2         3         4         5         6         7         8          9          100      110       120    130
	0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
	*************************************************************************************************************************************
	Ordem  Plano  Bem              Nome do Bem                             Servico Nome Servico                             Seq.
	*************************************************************************************************************************************
	XXXXXX XXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXX  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 999
	O.S.Origem: XXXXXX   Etapa: XXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Opcao: XXXXXXXXXXXXXXXX   Informou: XXXXXXXXXX
	XXXXXX XXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXX  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 999
	O.S.Origem: XXXXXX   Etapa: XXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  Opcao: XXXXXXXXXXXXXXXX   Marcou: SIM
	*/

	While !EoF()

		IncRegua()
		NGSOMALI(58)
		@ Li,000 PSay (cTRBZ400)->ORDEM  Picture "@!"
		@ Li,007 PSay (cTRBZ400)->PLANO  Picture "@!"
		@ Li,014 PSay (cTRBZ400)->CODBEM Picture "@!"

		dbSelectArea("ST9")
		dbSetOrder(1)
		dbSeek(xFilial('ST9') + (cTRBZ400)->CODBEM)
		@ Li,031 PSay Substr(ST9->T9_NOME,1,40)

		@ Li,071 PSay (cTRBZ400)->SERVICO Picture "@!"
		dbSelectArea("ST4")
		dbSetOrder(1)
		dbSeek(xFilial('ST4') + (cTRBZ400)->SERVICO)
		@ Li,079 PSay Substr(ST4->T4_NOME,1,40)
		@ Li,120 PSay (cTRBZ400)->SEQRELA Picture "@!"

		NGSOMALI(58)
		If cPrograma == "MNTA480"
			@ Li,007 PSay STR0016+":" //"Etapa:"
			@ Li,014 PSay (cTRBZ400)->ETAPA Picture "@!"
			@ Li,021 PSay  NGSEEK("TPA",(cTRBZ400)->ETAPA,1,"SubStr(TPA_DESCRI,1,30)") Picture "@!"
			@ Li,053 PSay STR0036+":" //"Opcao:"
			@ Li,060 PSay (cTRBZ400)->OPCAO Picture "@!"

			If (cTRBZ400)->TIPOET = '2'
				@ Li,072 PSay STR0225+NGSEEK("TPC",(cTRBZ400)->ETAPA+(cTRBZ400)->OPCAO,1,"TPC_CONDIN") //"Limite: "
				@ Li,090 PSay STR0171 //"Informou:"
				@ Li,100 PSay (cTRBZ400)->RESPOS Picture "@!"
			Else
				@ Li,100 PSay STR0172+STR0027  //"Marcou: "#"Sim"
			EndIf
		Else
			@ Li,007 PSay STR0170 //"O.S.Origem:"
			@ Li,019 PSay (cTRBZ400)->OSORIG Picture "@!"
			@ Li,028 PSay STR0016+":" //"Etapa:"
			@ Li,035 PSay (cTRBZ400)->ETAPA Picture "@!"
			@ Li,042 PSay  NGSEEK("TPA",(cTRBZ400)->ETAPA,1,"SubStr(TPA_DESCRI,1,30)") Picture "@!"
			@ Li,074 PSay STR0036+":" //"Opcao:"
			@ Li,081 PSay (cTRBZ400)->OPCAO Picture "@!"

			If (cTRBZ400)->TIPOET = '2'
				@ Li,093 PSay STR0225+NGSEEK("TPC",(cTRBZ400)->ETAPA+(cTRBZ400)->OPCAO,1,"TPC_CONDIN") //"Limite: "
				@ Li,111 PSay STR0171 //"Informou:"
				@ Li,121 PSay (cTRBZ400)->RESPOS Picture "@!"
			Else
				@ Li,100 PSay STR0172+STR0027  //"Marcou: "#"Sim"
			EndIf
		EndIf
		dbSelectArea(cTRBZ400)
		dbSkip()
	EndDo

	Roda(nCntImpr,cRodaTxt,Tamanho)

	RetIndex("ST9")
	Set Filter To
	Set device To Screen

	If aReturn[5] = 1
		Set Printer To
		dbCommitAll()
		OurSpool(wnrel)
	EndIf
	MS_FLUSH()

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400LEG
Cria uma janela contendo a legenda da mBrowse
@author Thiago Olis Machado
@since 27.06.01
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG400LEG()


	If lCervPetro
		BrwLegenda(cCadastro,STR0010,{{"BR_VERMELHO",STR0199},;//"Falta de Material"
									  {"BR_AMARELO" ,STR0200},;//"Suspensa"
									  {"BR_AZUL"    ,STR0201},;//"Reprogramada"
									  {"BR_VERDE"   ,STR0202},;//"Disponível"
									  {"BR_LARANJA" ,STR0203}} )//"Andamento"
	ElseIf ExistBlock("MNT400LE")
		ExecBlock("MNT400LE",.T.,.T.)
	Else
		BrwLegenda(cCadastro,STR0010,{{"ENABLE",Oemtoansi(STR0059)},;    //"Legenda"###"Com Insumo"
										  {"BR_AZUL",STR0060},;          //"Sem Insumo"
										  {"BR_VERMELHO" ,STR0061+" "+STR0060},; //"Atrasada"###"Sem Insumo"
										  {"BR_LARANJA"    ,STR0061+" "+STR0059}} )//"Atrasada"###"Com Insumo"

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCRIACOR
Funcao p/ definir cores p/ as situacoes das Ordens
@author Thiago Olis Machado
@since 27.06.2001
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGCRIACOR()
	Local aCores := {}
	Local _aCores

	If !lCervPetro
		aCores := { {"NGSEMAFARO('!Empty(STJ->TJ_TIPORET) .And. STJ->TJ_DTMPFIM >= dDataBase')" , 'BR_VERDE'   },;
					{"NGSEMAFARO('Empty(STJ->TJ_TIPORET) .And. STJ->TJ_DTMPFIM >= dDataBase' )" , 'BR_AZUL'},;
					{"NGSEMAFARO('Empty(STJ->TJ_TIPORET) .And. STJ->TJ_DTMPFIM < dDataBase'  )" , 'BR_VERMELHO' },;
					{"NGSEMAFARO('!Empty(STJ->TJ_TIPORET) .And. STJ->TJ_DTMPFIM < dDataBase' )" , 'BR_LARANJA'    }}
	Else
		aCores := {{"NGSEMAFARO('STJ->TJ_STATUS = "+'"01"'+"')" , "BR_VERMELHO"},;
				   {"NGSEMAFARO('STJ->TJ_STATUS = "+'"02"'+"')" , "BR_AMARELO" },;
				   {"NGSEMAFARO('STJ->TJ_STATUS = "+'"03"'+"')" , "BR_AZUL"	   },;
				   {"NGSEMAFARO('STJ->TJ_STATUS = "+'"05"'+"')" , "BR_VERDE"   },;
				   {"NGSEMAFARO('STJ->TJ_STATUS = "+'"04"'+"')" , "BR_LARANJA" }}
	EndIf

	If ExistBlock("MNTA400COR")
		_aCores := ExecBlock("MNTA400COR",.F.,.F.)
		If ValType(_aCores) == "A"
			aCores := _aCores
		EndIf
	EndIf

Return aCores

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400EXCU
Funcao do executante da etapa
@author Inacio Luiz Kolling
@since 29/06/2001
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG400EXCU()

	Local oMenu
	Local oGet1
	// [LGPD] Caso o usuário não possua acesso ao(s) campo(s), deve-se ofuscá-lo(s)
	Local lOfuscar := FindFunction( 'FWPDCanUse' ) .And. FwPdCanUse( .T. );
						.And. Len( FwProtectedDataUtil():UsrAccessPDField( __CUSERID, { 'T1_NOME' } ) ) == 0

	If Empty((cTRBQ400)->TQ_OK)
		Help(" ",1,"NGMSEETAEX") //"Nao Foi Selecionada a Etapa Como Executada"
		Return
	EndIf
	cNOMFUNC := Space(40)
	cCODFUNC := (cTRBQ400)->TQ_CODFUNC

	dbSelectArea("ST1")
	dbSetOrder(1)
	If dbSeek(xFilial("ST1")+cCODFUNC)
		cNOMFUNC := ST1->T1_NOME
		lRefresh := .T.
	EndIf

	nExec := 0
	Define Msdialog oDlg7 From 300,120 To 420,650 Title Oemtoansi(STR0018+STR0063+STR0064) Pixel //"Executante"###" da "###" Etapa"

	@ 1.4,1  Say Oemtoansi(STR0018) //"Executante"
	@ 1.4,5  MsGet cCODFUNC  Picture '@!' Size 60,7 F3 "ST1" Valid NG400FUN(cCODFUNC) HASBUTTON
	@ 1.4,14 MsGet oGet1 Var cNOMFUNC When .F. Size 140,7
	If lOfuscar
		oGet1:lObfuscate := .T.
		oGet1:bWhen := {|| .F. }
	EndIf

	Define SButton From 40, 180 Type 1 Enable Of oDlg7 Action ( nExec:=1,If(fNG400VETA(),oDlg7:End(),.F.) )
	Define SButton From 40, 220 Type 2 Enable Of oDlg7 Action ( nExec:=2,oDlg7:End() )

	NGPOPUP(aSMenu,@oMenu)
	oDLG7:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDLG7)}
	Activate Msdialog oDlg7 Centered

	If nExec == 1
		dbSelectArea(cTRBQ400)
		nRECNO := Recno()
		Reclock((cTRBQ400),.F.)
		(cTRBQ400)->TQ_CODFUNC := cCODFUNC
		MsUnLock(cTRBQ400)
		dbGotop()
		oMark:oBrowse:Refresh()
		dbGoto(nRECNO)

	EndIf
	dbSelectArea(cTRBQ400)
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400FUN
Consistencia do Funcionario/Executante
@author Inacio Luiz Kolling
@since 29/06/2001
@version undefined
@param cFun, characters
@type function
/*/
//---------------------------------------------------------------------
Function NG400FUN(cFun)

	cNOMFUNC := Space( TamSx3('T1_NOME')[1] )
	If !Empty(cFun)

		//Valida se o registro existe na ST1 ou se está bloquado
   		If !ExistCpo("ST1", cFun)
			Return .F.
		Else
			dbSelectArea("ST1")
			dbSetOrder(1) //T1_FILIAL + T1_CODFUNC
			If dbSeek( xFilial('ST1') + cFun )
				cNOMFUNC := ST1->T1_NOME
				lRefresh := .T.
			EndIf
		EndIf

		If !NGFUNCRH(cFun,.F.)
			If !MsgYesNo(STR0318+DtoC(ST1->T1_DTFIMDI); //"Executante consta como indisponivel a partir de "
			+STR0319) //". Confirma esse executante?"
				Return .F.
			EndIf
		EndIf

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} NGGARANT
Inclusao da Garantia para tipo de insumo igual a Produto
@author Thiago Olis Machado
@since 17/07/2001
@version undefined

@type function
/*/
//---------------------------------------------------------------------
Function NGGARANT()

	Local nOPGA1 := 0
	Local lTEMQTC := NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)
	Local bGarantia
	Local oMenu

	Private cUni   := " ",cCont := " "
	aUni := {" ",STR0066,STR0067,STR0068} //"Dia"###"Semana"###"Mes"
	aCont:= {" ",STR0116,STR0117} //"Contador 1"###"Contador 2"
	cNomLoc := Space(20)

	If M->TL_TIPOREG = "P"
		dbSelectArea("TPY")
		dbSetOrder(1)
		/*Abre tela de garantia quando o produto estiver como peca de reposicao e se o bem estiver com
		os campos de garantia preenchido, de tempo ou contador. */
		If dbSeek(xFilial("TPY")+cCodBem+M->TL_CODIGO) .And. (!Empty(TPY->TPY_QTDGAR) .Or. !Empty(TPY->TPY_CONGAR))
			cLocaliz := If(Empty(TPY->TPY_LOCGAR),Space(Len(TPS->TPS_CODLOC)),TPY->TPY_LOCGAR)
			bGarantia	:= {|| M->TL_GARANTI := "S"}
			nQtde  := TPY->TPY_QTDGAR
			If lTEMQTC
				nQtdeC := If(Empty(TPY->TPY_QTDCON),0,TPY->TPY_QTDCON)
			Else
				nQtdeC := 0
			EndIf
			cUni1  := TPY->TPY_UNIGAR
			If cUni1 = "D"
				cUni := aUni[2] //STR0098
			ElseIf cUni1 = "S"
				cUni := aUni[3] //STR0099
			Else
				cUni := aUni[4] //STR0100
			EndIf
			If !Empty(TPY->TPY_CONGAR)
				If TPY->TPY_CONGAR == '1'
					cCont := aCont[2]
				Else
					cCont := aCont[1]
				EndIf
			EndIf
			nL45 := If(!lTEMQTC,45,65)
			nL60 := If(!lTEMQTC,60,100)
			Define Msdialog oDlg1 From  000,000 To 280,550 Title STR0069 Pixel //"Garantia"
			@ 30,008 Say Oemtoansi(STR0070) Size 47,07 Of oDlg1 Pixel //"Local"
			@ 30,040 MsGet cLocaliz Size 38,08 Of oDlg1 Pixel Picture '@!' F3 "TPS" Valid NGLOCGAR(cLocaliz) HASBUTTON
			@ 30,100 MsGet oNomLoc Var cNomLoc Of oDlg1 Pixel Picture '@!' When .F. Size 90,08
			@ nL45,008 Say Oemtoansi(STR0071) Size 47,07 Of oDlg1 Pixel //"QDE"
			@ nL45,040 MsGet oQTDE VAR nQtde Valid positivo(nQtde) Picture '@E 999,999,999' Size 38,8 Of oDlg1 Pixel
			@ nL45,100 Say Oemtoansi(STR0072) Size 47,07 Of oDlg1 Pixel //"Unidade"
			@ nL45,132 Combobox cUni Items aUni Size 40,50 Of oDLG1 Pixel Valid NG400CON(cUni,cCont,1)
			NGPOPUP(aSMenu,@oMenu)
			oDLG1:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDLG1)}
			If !lTEMQTC
				@ nL60,008 Say Oemtoansi(STR0124) Size 47,07 Of oDlg1 Pixel //"Unidade" //"Tp Contador"
				@ nL60,040 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NG400CON(cUni,cCont,2)
				Activate Msdialog oDlg1 On Init EnchoiceBar(oDlg1,{||nOPGA1:=2,oDlg1:End()},{||nOPGA1:=1,oDlg1:End()}) Centered
			Else
				@ 1.5,.5 To 3.5,34 LABEL STR0186 OF oDlg1 //"Localização"
				@ 4.0,.5 To 6.0,34 LABEL STR0069+" "+STR0187+" "+STR0188 OF oDlg1 //"Garantia //por // Tempo"
				@ 6.5,.5 To 8.5,34 LABEL STR0069+" "+STR0187+" "+STR0127 OF oDlg1 //"Garantia // por //Contador" OF oDlg1
				@ nL60,008 Say Oemtoansi(STR0071) Size 47,07 Of oDlg1 Pixel //"Qde"
				@ nL60,040 MsGet oQTDEC VAR nQtdeC Valid positivo(nQTDEC) Size 38,8 Of oDlg1 Pixel Picture '@E 999,999,999'
				@ nL60,100 say OemtoAnSi(STR0124) Size 47,07 Of oDlg1 Pixel    //"Tp Contador"
				@ nL60,132 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NG400CON(cUni,cCont,2,nQtdeC)
				Activate MsDialog oDLG1 On Init EnchoiceBar(oDLG1,	{||nOPGA1 := 1,If(!MNT400GF(),nOPGA1 := 0,oDLG1:End() .And. Eval(bGarantia))},;
				{||oDLG1:End()}) CENTERED
			EndIf
		EndIf
	EndIf
	If nOPGA1 == 1
		NGGARANGRAVA(cLocaliz,nQtde,cUni,cCont,nQtdeC)
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGLOCGAR
Consistencia para mostrar a descricao da Localizacao
@author Thiago Olis Machado
@since 17/07/2001
@version undefined
@param cLocaliz, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGLOCGAR(cLocaliz)

	If !Empty(cLocaliz)
		If !EXISTCPO("TPS",cLocaliz)
			Return .F.
		EndIf
	EndIf
	dbSelectArea("TPS")
	dbSetOrder(1)
	If dbSeek(xFilial("TPS")+cLocaliz)
		cNomLoc := TPS->TPS_NOME
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGMSGARAN
Consistencia da mensagem para ver se o insumo ainda esta na garantia
@author Thiago Olis Machado
@since 17/07/2001
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function NGMSGARAN(nOpcx)

	Local cOLDALI := ALIAS()
	Local cMESNDT := Space(10)
	Local cMENDAT := STR0147
	Local lRETPON := .T.
	Local nRESTLP := 0
	Local nQUATSH4   := 0
	Local aRETVALINT := {}, nQUANTFERR := 0, nORDSTL
	Local nORDOLD, nRECNOOL, lPROPLSTL := .F., nRECSTL
	Local nQtdDe := 0

	If Type('nQuantO') <> 'U'
		nQtdDe := nQuantO
	EndIf

	lBAIXAEST := .T.

	dbSelectArea("STL")
	nRESTLP := Recno()

	//critica a alteração dos campos de data e hora quando é registro incluído pela rotina de apontamento de MDO

	If nOPCX = 4 .And.!NGVLDSTL2({	STL->TL_ORDEM, ;//Ordem
	STL->TL_CODIGO,;//Funcionário banco
	STL->TL_TAREFA,;//Tarefa no banco
	STL->TL_ETAPA,; //Etapa no banco
	STL->TL_DTINICI,;//Data Inicial banco
	STL->TL_HOINICI,;//Hora Inicial banco
	STL->TL_DTFIM,;//Data Final banco
	STL->TL_HOFIM,;// Hora Final banco
	M->TL_CODIGO,; //Código do Funcionário memória
	M->TL_TAREFA,; //Código da Tarefa na memória
	M->TL_ETAPA,;  //Código da Etapa memória
	M->TL_DTINICI,;//Data Inicial na memória
	M->TL_HOINICI,;//Hora Inicial na memória
	M->TL_DTFIM,;  //Data Final na memória
	M->TL_HOFIM})  //Hora Final na memória
		Return .F.
	EndIf

	If nOpcx = 5
		If ExistBlock("NGCDELIN")
			lRETPON := ExecBlock("NGCDELIN",.F.,.F.)
			If !lRETPON
				dbSelectArea("STL")
				dbGoto(nRESTLP)
				Return .F.
			EndIf
		EndIf
	EndIf

	dbSelectArea("STL")
	dbGoto(nRESTLP)

	cOrdem2 := space(Len(STL->TL_ORDEM))
	cPlano1 := Space(Len(STL->TL_PLANO))
	nSequen := Space(3)
	lRET    := .T.

	If M->TL_DTFIM == dDataBase .And. M->TL_HOFIM > SubStr(Time(),1,5)
		MsgInfo(STR0331,STR0137) //"A hora Fim não pode ser maior que a hora atual."
		Return .F.
	EndIf

	If M->TL_DTINICI > dDataBase
		MsgInfo(STR0321+STR0355,STR0137)
		Return .F.
	ElseIf M->TL_DTFIM > dDataBase
		MsgInfo(STR0356,STR0137)
		Return .F.
	ElseIf M->TL_DTINICI >	M->TL_DTFIM
		MsgInfo(STR0357,STR0137)
		Return .F.
	EndIf

	If (nOpcx = 3 .Or. nOpcx = 4) .And. !MNTA400GAR()
		Return .F.
	EndIf


	If M->TL_TIPOREG == "P"
		If Empty(M->TL_DESTINO)
			Help("",1,"DESTINO")
			Return .F.
		EndIf

		cUNPROD := NGSEEK("SB1",M->TL_CODIGO,1,"B1_UM")
		If Alltrim(cUNPROD) <> Alltrim(M->TL_UNIDADE)
			Help("",1,"UNIDADE")
			Return .F.
		EndIf

		// QUANDO INTEGRADO COM O MÓDULO DE ESTOQUE.
		If cUsaInt3  == "S"

			If !NGPROALM(M->TL_CODIGO,M->TL_LOCAL)
				Return .F.
			EndIf

			If !NGCHKMESFE(M->TL_DTINICI,M->TL_TIPOREG)
				Return .F.
			EndIf

			// VALIDA SE O PRODUTO NO LOCAL INFORMADO ENCONTRA-SE EM PROCESSO DE INVENTÁRIO.
			If BlqInvent( M->TL_CODIGO, M->TL_LOCAL )

				Help( '', 1, 'BLQINVENT' )
				Return .F.

			EndIf

		EndIf

	Else
		If M->TL_TIPOREG == "M"
			If !NGCHKMESFE(M->TL_DTINICI,M->TL_TIPOREG)
				Return .F.
			EndIf

			//Verifica se a mao de obra possui afastamentos no RH
			If (nOpcx = 3 .Or. nOpcx = 4) .And. !NGFRHAFAST(M->TL_CODIGO,M->TL_DTINICI,M->TL_DTFIM,.T.)
				Return .F.
			EndIf

			If (nOpcx = 3 .Or. nOpcx = 4) .And. !NGFUNCRH(M->TL_CODIGO,.T.,M->TL_DTFIM)
				Return .F.
			EndIf

		EndIf

		If Alltrim(M->TL_UNIDADE)$"MHDS"
		Else
			Help("",1,"UNIDADE")
			Return .F.
		EndIf
	EndIf

	If nOpcx = 3 .Or. nOpcx = 4

		//Limpa o filtro para visualizar todas as OS
		dbSelectArea("STJ")
		nORDOLD  := IndexOrd()
		nRECNOOL := Recno()

		dbSelectArea("STL")
		nORDSTL := IndexOrd()
		nRECSTL := Recno()
		//Set Filter to
		If Type("aIndSTL") = "A"
			ENDFILBRW("STL",aIndSTL)
		EndIf

		If M->TL_TIPOREG == "M"
			aRETVALINT := NGVALDATIN(M->TL_CODIGO,cOrdem,cPlano,M->TL_DTINICI,M->TL_HOINICI,M->TL_DTFIM,M->TL_HOFIM,"M",;
			If(nOpcx = 4,nRECSTL, ),"STL")
			If !aRETVALINT[1]
				lPROPLSTL := .T.
			EndIf

			If !lPROPLSTL
				aRETVALINT := NGVALDATIN(M->TL_CODIGO,cOrdem,cPlano,M->TL_DTINICI,M->TL_HOINICI,M->TL_DTFIM,M->TL_HOFIM,"M", ,"STT")
				If !aRETVALINT[1]
					lPROPLSTL := .T.
				EndIf
			EndIf

		ElseIf M->TL_TIPOREG == "F"

			dbSelectArea("SH4")
			dbSeek(xFilial("SH4")+SubStr(M->TL_CODIGO,1,6))
			nQUATSH4 := SH4->H4_QUANT

			//STL
			aRETVALINT := NGVALDATIN(M->TL_CODIGO,cOrdem,cPlano,M->TL_DTINICI,M->TL_HOINICI,M->TL_DTFIM,M->TL_HOFIM,"F",;
			If(nOpcx = 4,nRECSTL, ),"STL")
			nQUANTFERR := aRETVALINT[2]
			nRESTQUA   := nQUATSH4 - nQUANTFERR

			If M->TL_QUANREC == 0
				MsgInfo(STR0442,STR0025) //"O campo Quant. Rec. é obrigatório."###"ATENÇÃO"
				Return .F.
			EndIf

			If nRESTQUA >= 0
				//STT
				aRETVALINT := NGVALDATIN(M->TL_CODIGO,cOrdem,cPlano,M->TL_DTINICI,M->TL_HOINICI,M->TL_DTFIM,M->TL_HOFIM,"F", ,"STT")
				nQUANTFERR += aRETVALINT[2]
				nRESTQUA   := nQUATSH4 - nQUANTFERR
			EndIf

			If nRESTQUA <= 0 .And. nQUANTFERR > 0
				MsgInfo(STR0226 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
				+STR0227 + ".....: " + dtoc(M->TL_DTINICI)+chr(13); //"Data Inicio"
				+STR0228 + ".....: " + Substr(M->TL_HOINICI,1,5)+chr(13); //"Hora Inicio"
				+STR0229 + "........: " + dtoc(M->TL_DTFIM)+chr(13); //"Data Fim"
				+STR0230 + "........: " + Substr(M->TL_HOFIM,1,5),STR0022) //"Hora Fim"
				lPROPLSTL := .T.
			EndIf
		ElseIf M->TL_TIPOREG == "T"
			aRETVALINT := NGVALDATIN(M->TL_CODIGO,cOrdem,cPlano,M->TL_DTINICI,M->TL_HOINICI,M->TL_DTFIM,M->TL_HOFIM,"T",If(nOpcx = 4,nRECSTL, ),"STL")
			If !aRETVALINT[1]
				lPROPLSTL := .T.
			EndIf

			If !lPROPLSTL
				aRETVALINT := NGVALDATIN(M->TL_CODIGO,cOrdem,cPlano,M->TL_DTINICI,M->TL_HOINICI,M->TL_DTFIM,M->TL_HOFIM,"T", ,"STT")
				If !aRETVALINT[1]
					lPROPLSTL := .T.
				EndIf
			EndIf
		EndIf

		dbSelectArea("STJ")
		dbSetOrder(nORDOLD)
		dbGoto(nRECNOOL)

		//Volta o filtro do STL
		dbSelectArea("STL")
		If Type("aIndSTL") = "A"
			bFiltraBrw := {|| FilBrowse("STL",@aIndSTL,@condSTL) }
			Eval(bFiltraBrw)
		Else
			dbSetOrder(nORDSTL)
		EndIf
		If nOpcx = 4
			dbGoto(nRECSTL)
		EndIf

		If lPROPLSTL
			Return .F.
		EndIf

		If !CHECKCOD(.T.,.F.)
			Return .F.
		EndIf

		If !NGQUANTCHK(M->TL_TIPOREG,M->TL_UNIDADE,M->TL_QUANTID,M->TL_USACALE)
			Return .F.
		EndIf

	EndIf

	// Verifica se o estoque(SB2) podera ficar negativo
	dbSelectArea("STL")
	If M->TL_TIPOREG = "P" .And. (nOpcx = 3 .Or. nOpcx = 4)
		If cUsaInt3  == "S"

			If cUIntHis == 'N' .And. STJ->TJ_SERVICO == 'HISTOR'
				lBaixaEst := .F.
			EndIf

			//+----------------------------------------------------------+
			//| PE que consiste se o produto ira baixar estoque			 |
			//+----------------------------------------------------------+
			If ExistBlock("MNT40016")
				lBAIXAEST := ExecBlock("MNT40016",.F.,.F.)
			EndIf

			If lBAIXAEST
				If !lESTNEGA
					If nOpcx = 4
						lIncluiX := INCLUI
						INCLUI := .T.
					EndIf

					/*-------------------------------------------------------------------------------------------------+
					| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
					+-------------------------------------------------------------------------------------------------*/
					If !lHasMNTREQ

						If !NGSALSB2(M->TL_CODIGO,M->TL_LOCAL,M->TL_QUANTID,,nQuantO,M->TL_DTINICI)
							dbSelectArea(cOLDALI)
							If nOpcx = 4
								INCLUI := lIncluiX
							EndIf
							Return .F.
						EndIf

					EndIf

					If nOpcx = 4
						INCLUI := lIncluiX
					EndIf
				EndIf

				//Valida saldo(SB8) de controle de rastreabilidade por lote do produto
				If M->TL_TIPOREG == "P" .And. Rastro(M->TL_CODIGO)

					If Rastro(M->TL_CODIGO,"S")
						//Valida o sub-lote
						If Empty(M->TL_NUMLOTE)
							Help(" ",1,"NGATENCAO",,STR0166,3,1)  //"Numero do sub-lote não informado"
							Return .F.
						Else
							dbSelectArea("SB8")
							dbSetOrder(02)
							If dbSeek(xFilial("SB8")+M->TL_NUMLOTE+M->TL_LOTECTL+M->TL_CODIGO+M->TL_LOCAL)

								/*-------------------------------------------------------------------------------------------------+
								| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
								+-------------------------------------------------------------------------------------------------*/
								If !lHasMNTREQ

									nSaldoLote := SB8Saldo( .F., !Empty( M->TL_LOTECTL + M->TL_NUMLOTE ), Nil, Nil,;
										Nil, Nil, Nil, M->TL_DTINICI )

									If QtdComp(nSaldoLote)+nQtdDe < QtdComp(M->TL_QUANTID)
										cHelp:=OemToAnsi(STR0158)+AllTrim(M->TL_CODIGO)+OemToAnsi(STR0159)+M->TL_LOCAL+OemToAnsi(STR0160);//"Produto"#"Local "#" Saldo Disponivel "
										+Alltrim(Transform(nSaldoLote+nQtdDe,PesqPictQt("B8_SALDO", 14)))+OemToAnsi(STR0161)+Alltrim(M->TL_LOTECTL);// //"Lote"
										+OemToAnsi(STR0168)+Alltrim(M->TL_NUMLOTE)//  " Sub-lote "
										Help(" ",1,"A240LOTENE",,cHelp,4,1)
										Return .F.
									EndIf

								EndIf

							Else
								Help(" ",1,"NGATENCAO",,STR0162+CRLF+; //"Numero do sub-lote não corresponde ao produto que foi "
								STR0163+CRLF+CRLF+STR0164+CRLF+STR0165,3,1) //" informado. Digite um sub-lote correspondente."
								Return .F.
							EndIf
						EndIf
					Else
						//Valida o lote
						If Empty(M->TL_LOTECTL)
							Help(" ",1,"NGATENCAO",,STR0167,3,1)  //"Numero do lote não informado"
							Return .F.
						Else
							dbSelectArea("SB8")
							dbSetOrder(03)
							If dbSeek(xFilial("SB8")+M->TL_CODIGO+M->TL_LOCAL+M->TL_LOTECTL)

								/*-------------------------------------------------------------------------------------------------+
								| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
								+-------------------------------------------------------------------------------------------------*/
								If !lHasMNTREQ

									nSaldo:=SaldoLote( M->TL_CODIGO, M->TL_LOCAL, M->TL_LOTECTL, Nil, .F., !Empty( M->TL_LOTECTL + M->TL_NUMLOTE ), Nil,;
										M->TL_DTINICI )

									If QtdComp(nSaldo)+nQtdDe < QtdComp(M->TL_QUANTID)
										cHelp:=OemToAnsi(STR0158)+AllTrim(M->TL_CODIGO)+OemToAnsi(STR0159)+M->TL_LOCAL+OemToAnsi(STR0160); //"Produto "#" Local "#" Saldo Disponivel "
										+Alltrim(Transform(nSaldo+nQtdDe,PesqPictQt("B8_SALDO", 14)))+OemToAnsi(STR0161)+Alltrim(M->TL_LOTECTL) //" Lote "
										Help(" ",1,"A240LOTENE",,cHelp,4,1)
										Return .F.
									EndIf

								EndIf

							Else
								Help(" ",1,"NGATENCAO",,STR0164+Chr(13)+Chr(10)+; //"Numero do lote não corresponde ao produto que foi "
								STR0165,3,1)  //" informado. Digite um lote correspondente."
								Return .F.
							EndIf
						EndIf
					EndIf
				EndIf

				//Validacao do LOCALIZACAO
				If M->TL_TIPOREG == "P"

					//Verifica se ha problema na habilitacao do controle por enderecamento fisico
					If !Empty(M->TL_LOCALIZ) .Or. !Empty(M->TL_NUMSERI)
						If !LOCALIZA( Padr( M->TL_CODIGO, TAMSX3("B1_COD")[1] ) )
							MsgInfo(STR0156+chr(13)+STR0157,STR0137)//'O paramtro "MV_LOCALIZ" esta desativado ou o campo'
							//' "B1_LOCALIZ" do produto esta preenchido com "N".'
							Return .F.
						EndIf
					EndIf

					If LOCALIZA( Padr( M->TL_CODIGO, TAMSX3("B1_COD")[1] ) )

						//Valida a obrigatoriedade de informar o enderecamento fisico se o produto
						//tem o controle
						If Empty(M->TL_LOCALIZ) .And. Empty(M->TL_NUMSERI)
							Help(" ",1,"LOCALIZOBR")
							Return .F.
						ElseIf Empty(M->TL_LOCALIZ)
							Help(" ",1,"LOCALIZOBR")
							Return .F.
						EndIf

						If !Empty(M->TL_LOCALIZ)
							If !EXISTCPO("SBE",M->TL_LOCAL+M->TL_LOCALIZ)
								Return .F.
							EndIf
						EndIf

						//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
						If !MtAvlNSer(M->TL_CODIGO,M->TL_NUMSERI,M->TL_QUANTID)
							Return .F.
						EndIf

						/*-------------------------------------------------------------------------------------------------+
						| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
						+-------------------------------------------------------------------------------------------------*/
						If !lHasMNTREQ

							If (!Empty(M->TL_LOCALIZ) .Or. !Empty(M->TL_NUMSERI)) .And. QtdComp( SaldoSBF( M->TL_LOCAL, M->TL_LOCALIZ, M->TL_CODIGO,;
								M->TL_NUMSERI, M->TL_LOTECTL, M->TL_NUMLOTE, .F. ) ) + nQtdDe < QtdComp( M->TL_QUANTID )

								Help(" ",1,"SALDOLOCLZ")
								Return .F.

							EndIf

						EndIf

					EndIf

				EndIf

			EndIf

		EndIf

	EndIf

	If Altera
		If M->TL_TIPOREG <> STL->TL_TIPOREG .OR. M->TL_CODIGO <> STL->TL_CODIGO
			NGCOMGARA("A")
		EndIf
	EndIf

	If nOpcx = 5
		cOrdem       := STJ->TJ_ORDEM
		cPlano        := STJ->TJ_PLANO
		NGARANDELETE()

	EndIf

	If M->TL_GARANTI == "S" .And. nOpcx <> 5
		#IFDEF TOP
		#ELSE
		dbSelectArea("TPZ")
		dbSetOrder(1)
		dbSeek(xFilial("TPZ")+cCodBem+M->TL_TIPOREG+M->TL_CODIGO+cLocaliz)
		nRecTPZ := Recno()
		If Found()
			If !NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)
				RecLock("TPZ",.F.)
				If Empty(M->TL_DTFIM)
					TPZ->TPZ_DTGARA := M->TL_DTINICI
				Else
					TPZ->TPZ_DTGARA := M->TL_DTFIM
				EndIf
				MsUnLock("TPZ")
				If !Empty(TPZ->TPZ_CONGAR)
					cOrdem1 := TPZ->TPZ_ORDEM
					cPlano1 := TPZ->TPZ_PLANO

					STJ->(dbSeek(xFilial("STJ")+cOrdem1+cPlano1))
					nPoscont := IIf(TPZ->TPZ_CONGAR="1",STJ->TJ_POSCONT,STJ->TJ_POSCON2)
					nRecno  := Recno()
					If !BoF()
						dbSkip(-1)
					EndIf
					If Empty(TPZ->TPZ_CONGAR)
						While !BoF() .And. Empty(TPZ->TPZ_CONGAR)
							dbSkip(-1)
						End
					EndIf
					cOrdem := TPZ->TPZ_ORDEM
					cPlano := TPZ->TPZ_PLANO
					nQuant := TPZ->TPZ_QTDGAR
					STJ->(dbSeek(xFilial("STJ")+cOrdem+cPlano))
					nPoscont2 := IIf(TPZ->TPZ_CONGAR="1",STJ->TJ_POSCONT,STJ->TJ_POSCON2)
					nSoma := nPoscont + nQuant
					If nSoma > nPoscont2
						MsgAlert(STR0101+CHR(13)+CHR(13); //"Insumo substituido no prazo de Garantia"
						+STR0118+AllTrim(Str(nPoscont))+CHR(13); //"Contador no inicio do uso    : "
						+STR0119+cOrdem+CHR(13); //"O.S.                                     : "
						+STR0120+AllTrim(Str(nPoscont2))+CHR(13); //"Contador atual                     : "
						+STR0121+AllTrim(Str(nSoma))) //"Garantia Ate                         : "
					EndIf
				Else
					dData1   := TPZ->TPZ_DTGARA
					cLocaliz := TPZ->TPZ_LOCGAR
					dbSkip(-1)
					cLocal1 := TPZ->TPZ_LOCGAR
					If TPZ->TPZ_CODBEM == cCodBem .And. TPZ->TPZ_TIPORE == M->TL_TIPOREG .And.;
					TPZ->TPZ_CODIGO == M->TL_CODIGO
						If TPZ->TPZ_ORDEM <> cOrdem
							cOrdem2 := TPZ->TPZ_ORDEM
							cPlano1 := TPZ->TPZ_PLANO
							If NgVerify("TPZ")
								nSequen := TPZ->TPZ_SEQREL
							Else
								nSequen := TPZ->TPZ_SEQUEN
							EndIf
							dData   := TPZ->TPZ_DTGARA
						Else
							While !BoF() .And. TPZ->TPZ_ORDEM == cOrdem
								dbSkip(-1)
							End
							cOrdem2 := TPZ->TPZ_ORDEM
							cPlano1 := TPZ->TPZ_PLANO
							If NgVerify("TPZ")
								nSequen := TPZ->TPZ_SEQREL
							Else
								nSequen := TPZ->TPZ_SEQUEN
							EndIf
							dData   := TPZ->TPZ_DTGARA
						EndIf
						If cLocaliz == cLocal1
							If TPZ->TPZ_ORDEM <> cOrdem
								If TPZ->TPZ_UNIGAR = "D"
									dData2 := TPZ->TPZ_QTDGAR + dData
									If dData2 > dData1
										MsgAlert(STR0101+CHR(13);
										+STR0102+AllTrim(Str(Day(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Month(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Year(TPZ->TPZ_DTGARA)))+STR0103+TPZ->TPZ_ORDEM+CHR(13);
										+STR0104+AllTrim(Str(Day(dData2))+"/"+AllTrim(Str(Month(dData2)))+"/"+AllTrim(Str(Year(dData2))))+CHR(13);
										+If(Empty(cLocaliz)," ",STR0222+cLocaliz))
									EndIf
								ElseIf TPZ->TPZ_UNIGAR = "S"
									dData2 := (TPZ->TPZ_QTDGAR * 7) + dData
									If dData2 > dData1
										MsgAlert(STR0101+CHR(13);
										+STR0102+AllTrim(Str(Day(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Month(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Year(TPZ->TPZ_DTGARA)))+STR0103+TPZ->TPZ_ORDEM+CHR(13);
										+STR0104+AllTrim(Str(Day(dData2))+"/"+AllTrim(Str(Month(dData2)))+"/"+AllTrim(Str(Year(dData2))))+CHR(13);
										+If(Empty(cLocaliz)," ",STR0222+cLocaliz))
									EndIf
								ElseIf TPZ->TPZ_UNIGAR = "M"
									dData2 := (TPZ->TPZ_QTDGAR * 30) + dData
									If dData2 > dData1
										MsgAlert(STR0101+CHR(13);
										+STR0102+AllTrim(Str(Day(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Month(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Year(TPZ->TPZ_DTGARA)))+STR0103+TPZ->TPZ_ORDEM+CHR(13);
										+STR0104+AllTrim(Str(Day(dData2))+"/"+AllTrim(Str(Month(dData2)))+"/"+AllTrim(Str(Year(dData2))))+CHR(13);
										+If(Empty(cLocaliz)," ",STR0222+cLocaliz))
									EndIf
								EndIf
							EndIf
						EndIf
					Else
						dbSkip()
						dData   := TPZ->TPZ_DTGARA
					EndIf
				EndIf
			Else
				RecLock("TPZ",.F.)
				If Empty(M->TL_DTFIM)
					TPZ->TPZ_DTGARA := M->TL_DTINICI
				Else
					TPZ->TPZ_DTGARA := M->TL_DTFIM
				EndIf
				MsUnLock("TPZ")
				If !Empty(TPZ->TPZ_CONGAR)
					cOrdem1 := TPZ->TPZ_ORDEM
					cPlano1 := TPZ->TPZ_PLANO

					STJ->(dbSeek(xFilial("STJ")+cOrdem1+cPlano1))
					nPoscont := IIf(TPZ->TPZ_CONGAR="1",STJ->TJ_POSCONT,STJ->TJ_POSCON2)
					nRecno  := Recno()
					If !BoF()
						dbSkip(-1)
					EndIf
					If Empty(TPZ->TPZ_CONGAR)
						While !BoF() .And. Empty(TPZ->TPZ_CONGAR)
							dbSkip(-1)
						End
					EndIf
					cOrdem := TPZ->TPZ_ORDEM
					cPlano := TPZ->TPZ_PLANO
					dbSelectArea("TPZ")
					nQuant := TPZ->TPZ_QTDCON
					STJ->(dbSeek(xFilial("STJ")+cOrdem+cPlano))
					nPoscont2 := IIf(TPZ->TPZ_CONGAR="1",STJ->TJ_POSCONT,STJ->TJ_POSCON2)
					nSoma := nPoscont2 + nQuant   //nSoma := nPoscont + nQuant
					If nSoma > nPoscont
						MsgAlert(STR0101+CHR(13)+CHR(13); //"Insumo substituido no prazo de Garantia"
						+STR0118+AllTrim(Str(nPoscont2))+CHR(13); //"Contador no inicio do uso    : "
						+STR0119+cOrdem+CHR(13); //"O.S.                                     : "
						+STR0120+AllTrim(Str(nPoscont))+CHR(13); //"Contador atual                     : "
						+STR0121+AllTrim(Str(nSoma))) //"Garantia Ate                         : "
					EndIf
				EndIf
				dbGoTo(nRecTPZ)
				cOrdem := TPZ->TPZ_ORDEM
				cPlano := TPZ->TPZ_PLANO
				If !Empty(TPZ->TPZ_QTDGAR) //Else
					dData1   := TPZ->TPZ_DTGARA
					cLocaliz := TPZ->TPZ_LOCGAR
					dbSkip(-1)
					cLocal1 := TPZ->TPZ_LOCGAR
					If TPZ->TPZ_CODBEM == cCodBem .And. TPZ->TPZ_TIPORE == M->TL_TIPOREG .And.;
					TPZ->TPZ_CODIGO == M->TL_CODIGO
						If TPZ->TPZ_ORDEM <> cOrdem
							cOrdem2 := TPZ->TPZ_ORDEM
							cPlano1 := TPZ->TPZ_PLANO
							If NgVerify("TPZ")
								nSequen := TPZ->TPZ_SEQREL
							Else
								nSequen := TPZ->TPZ_SEQUEN
							EndIf

							dData   := TPZ->TPZ_DTGARA
						Else
							While !BoF() .And. TPZ->TPZ_ORDEM == cOrdem
								nRecTPZ := Recno()
								dbSkip(-1)
							End
							dbGoTo(nRecTPZ)
							cOrdem2 := TPZ->TPZ_ORDEM
							cPlano1 := TPZ->TPZ_PLANO
							If NgVerify("TPZ")
								nSequen := TPZ->TPZ_SEQREL
							Else
								nSequen := TPZ->TPZ_SEQUEN
							EndIf
							dData   := TPZ->TPZ_DTGARA
						EndIf
						If cLocaliz == cLocal1
							If TPZ->TPZ_ORDEM <> cOrdem
								If TPZ->TPZ_UNIGAR = "D"
									dData2 := TPZ->TPZ_QTDGAR + dData
									If dData2 > dData1
										MsgAlert(STR0101+CHR(13);
										+STR0102+AllTrim(Str(Day(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Month(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Year(TPZ->TPZ_DTGARA)))+STR0103+TPZ->TPZ_ORDEM+CHR(13);
										+STR0104+AllTrim(Str(Day(dData2))+"/"+AllTrim(Str(Month(dData2)))+"/"+AllTrim(Str(Year(dData2))))+CHR(13);
										+If(Empty(cLocaliz)," ",STR0222+cLocaliz))
									EndIf
								ElseIf TPZ->TPZ_UNIGAR = "S"
									dData2 := (TPZ->TPZ_QTDGAR * 7) + dData
									If dData2 > dData1
										MsgAlert(STR0101+CHR(13);
										+STR0102+AllTrim(Str(Day(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Month(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Year(TPZ->TPZ_DTGARA)))+STR0103+TPZ->TPZ_ORDEM+CHR(13);
										+STR0104+AllTrim(Str(Day(dData2))+"/"+AllTrim(Str(Month(dData2)))+"/"+AllTrim(Str(Year(dData2))))+CHR(13);
										+If(Empty(cLocaliz)," ",STR0222+cLocaliz))
									EndIf
								ElseIf TPZ->TPZ_UNIGAR = "M"
									dData2 := (TPZ->TPZ_QTDGAR * 30) + dData
									If dData2 > dData1
										MsgAlert(STR0101+CHR(13);
										+STR0102+AllTrim(Str(Day(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Month(TPZ->TPZ_DTGARA)))+"/"+AllTrim(Str(Year(TPZ->TPZ_DTGARA)))+STR0103+TPZ->TPZ_ORDEM+CHR(13);
										+STR0104+AllTrim(Str(Day(dData2))+"/"+AllTrim(Str(Month(dData2)))+"/"+AllTrim(Str(Year(dData2))))+CHR(13);
										+If(Empty(cLocaliz)," ",STR0222+cLocaliz))
									EndIf
								EndIf
							EndIf
						EndIf
					Else
						dbSkip()
						dData   := TPZ->TPZ_DTGARA
					EndIf
				EndIf
			EndIf
		EndIf
		#ENDIF
		cLocaliz := ""
	EndIf

	If nOpcx = 3
		If ExistBlock("NGCHKINS")
			lRETPON := ExecBlock("NGCHKINS",.F.,.F.)
			If !lRETPON
				dbSelectArea("STL")
				dbGoto(nRESTLP)
				Return .F.
			EndIf
		EndIf
	EndIf

	If ExistBlock("MNT40015")
		If !ExecBlock("MNT40015",.F.,.F.)
			Return .F.
		EndIf
	EndIf

	// Valida se a data de baixa de estoque é maior que a data de bloqueio de estoque (NGMSGARAN)
	If M->TL_TIPOREG <> "F" .And. M->TL_TIPOREG <> "M"
		If !MNTValDBl(M->TL_DTINICI)
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCOMGARA
Inclusao de garantia para insumo diferente de produto chamada
a partir do campo garantia
@author Thiago Olis Machado
@since 17/07/2001
@version undefined
@param cUsa, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGCOMGARA(cUsa)

	Local oMenu
	Local nOPGA2 := 0

	If !IsInCallStack("MNTA400")
		Private lTesGar := .F.
	EndIf

	lTemCG1 := If(NGSEEK("ST9",STJ->TJ_CODBEM,1,"T9_TEMCONT") <> "N",.T.,.F.)
	lTemCG2 := If(NGIFDBSEEK("TPE",STJ->TJ_CODBEM,1,.F.),.T.,.F.)

	If M->TL_GARANTI = "N"
		lTesGar := .F.
		cLocaliz := Space(6)
		nQtde    := 0
		cUni      := " "
		cCont    := " "
		nQtdeC  := 0
		Return .T.
	EndIf
	If lTesGar
		Return .T.
	EndIf
	Private nQtde := 0, nQtdeC := 0,cUni := " ",cCont := " "

	If M->TL_GARANTI == "S" .And. (Empty(M->TL_TAREFA) .Or. Empty(M->TL_CODIGO) .Or. Empty(M->TL_QUANTID))
		Help(" ",1,"OBRIGAT")
		Return .F.
	EndIf

	aUni     := {" ",STR0066,STR0067,STR0068} //"Dia"###"Semana"###"Mes"
	aCont    := {" ",STR0116,STR0117} //"Contador 1"###"Contador 2"
	cLocaliz := Space(Len(TPS->TPS_CODLOC))
	cNomLoc  := Space(20)

	If M->TL_GARANTI = "S" .And. !Empty(M->TL_SEQRELA)
		If NGIFDBSEEK("TPZ",M->TL_ORDEM+M->TL_PLANO+M->TL_SEQRELA,2,.F.)
			cLocaliz := TPZ->TPZ_LOCGAR
			cNomLoc  := NGSEEK("TPS",cLocaliz,1,"TPS_NOME")
			nQtde    := TPZ->TPZ_QTDGAR
			nIU      := If(!Empty(TPZ->TPZ_UNIGAR),If(TPZ->TPZ_UNIGAR = "D",2,If(TPZ->TPZ_UNIGAR = "S",3,4)),1)
			cUni     := aUni[nIU]
			nQtdeC   := TPZ->TPZ_QTDCON
			cCont    := If(!Empty(TPZ->TPZ_CONGAR),If(TPZ->TPZ_CONGAR = '1',aCont[2],aCont[3]),"           ")
		EndIf
	EndIf

	lTEMQTD := If(NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.),.T.,.F.)
	nL45    := If(!lTEMQTD,45,65)
	nL60    := If(!lTEMQTD,60,100)

	If M->TL_GARANTI = "S"
		Define Msdialog oDlg1 From  000,000 To 280,550 Title STR0069 Pixel //"Garantia"

		@ 30,008 Say Oemtoansi(STR0070) Size 47,07 Of oDlg1 Pixel //"Local"
		@ 30,040 MsGet cLocaliz Size 38,08 Of oDlg1 Pixel Picture '@!' F3 "TPS" Valid NGLOCGAR(cLocaliz) HASBUTTON
		@ 30,100 MsGet oNomLoc Var cNomLoc Of oDlg1 Pixel Picture '@!' When .F. Size 90,08

		@ nL45,008 Say Oemtoansi(STR0071) Size 47,07 Of oDlg1 Pixel //"Qde"
		@ nL45,040 MsGet oQTDE VAR nQtde Size 38,8 Of oDlg1 Pixel Valid positivo(nQtde) Picture '@E 999,999,999'

		@ nL45,100 Say Oemtoansi(STR0072) Size 47,07 Of oDlg1 Pixel //"Unidade"
		@ nL45,132 Combobox cUni Items aUni Size 40,50 OF oDLG1 Pixel Valid NG400CON(cUni,cCont,1)
		NGPOPUP(aSMenu,@oMenu)
		oDLG1:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDLG1)}
		If !lTEMQTD
			@ nL60,008 say OemtoAnSi(STR0124) Size 47,07 Of oDlg1 Pixel    //"Tp Contador"
			@ nL60,040 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NG400CON(cUni,cCont,2)
			Activate Msdialog oDlg1 On Init EnchoiceBar(oDlg1,{|| nOPGA2:=2,If(MNT400GAR(cLocaliz,nQtde,cUni,,cCont),oDlg1:End(),nOPGA2:=1)},{||nOPGA2:=0,oDlg1:End()}) Centered
		Else
			@ 1.5,.5 To 3.5,34 LABEL STR0186 OF oDlg1 //"Localização"
			@ 4.0,.5 To 6.0,34 LABEL STR0069+" "+STR0187+" "+STR0188 OF oDlg1 //"Garantia // por // Tempo"
			@ 6.5,.5 To 8.5,34 LABEL STR0069+" "+STR0187+" "+STR0127 OF oDlg1 //"Garantia //por // Contador" OF oDlg1
			@ nL60,008 Say Oemtoansi(STR0071) Size 47,07 Of oDlg1 Pixel //"Qde"
			@ nL60,040 MsGet oQTDEC VAR nQtdeC Size 38,8 Of oDlg1 Pixel Valid positivo(nQtdeC) Picture '@E 999,999,999' When lTemCG1 .Or. lTemCG2
			@ nL60,100 say OemtoAnSi(STR0124) Size 47,07 Of oDlg1 Pixel    //"Tp Contador"
			@ nL60,132 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NG400CON(cUni,cCont,2,nQtdeC) When lTemCG1 .Or. lTemCG2
			Activate MsDialog oDLG1 On Init EnchoiceBar(oDLG1,{||nOPGA2 := 1,If(!MNT400GF(lTemCG1,lTemCG2),nOPGA2 := 0,oDLG1:End())},{||oDLG1:End()}) CENTERED
		EndIf
	EndIf

	If nOPGA2 == 1
		NGGARANGRAVA(cLocaliz,nQtde,cUni,cCont,nQtdeC)
	Else
		If M->TL_GARANTI == "S"
			If Empty(cLocaliz) .And. Empty(nQtde) .And. Empty(nQtdeC) .And.;
			Empty(cUni) .And. Empty(cCont)
				M->TL_GARANTI := "N"
				lREFRESH := .T.
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGGARANGRAVA
Grava a garantia na tabela TPZ
@author Thiago Olis Machado
@since 17/07/2001
@version undefined
@param cLocaliz, characters
@param nQtde, numeric
@param cUni1, characters
@param cCont, characters
@param nQtdeC, numeric
@type function
/*/
//---------------------------------------------------------------------
Function NGGARANGRAVA(cLocaliz,nQtde,cUni1,cCont,nQtdeC)

	If cUni1 = STR0066 //"Dia"
		cUni := "D"
	ElseIf cUni1 = STR0067 //"Semana"
		cUni := "S"
	ElseIf cUni1 = STR0068 //"Mes"
		cUni := "M"
	Else
		cUni := " "
	EndIf

	If Type("cCodBem") == "U"
		cCodBem := STJ->TJ_CODBEM
		cOrdem  := STJ->TJ_ORDEM
		cPlano  := STJ->TJ_PLANO
	Else
		cOrdem  := M->TJ_ORDEM
	EndIf

	If cPrograma == "NG400PADRA"
		M->TL_SEQRELA := Alltrim(Str(n,3))
	EndIf

	If !NGIFDBSEEK("TPZ",+cOrdem+cPlano+M->TL_SEQRELA,2,.F.)
		RecLock("TPZ",.T.)
		TPZ->TPZ_FILIAL := xFilial("TPZ")
		TPZ->TPZ_CODBEM := cCodBem
		TPZ->TPZ_ORDEM  := cOrdem
		TPZ->TPZ_PLANO  := cPlano
		TPZ->TPZ_SEQREL := If(Empty(M->TL_SEQRELA),"1",M->TL_SEQRELA)
	Else
		RecLock("TPZ",.F.)
	EndIf

	TPZ->TPZ_TIPORE := M->TL_TIPOREG
	TPZ->TPZ_CODIGO := M->TL_CODIGO
	TPZ->TPZ_LOCGAR := cLocaliz
	TPZ->TPZ_QTDGAR := nQtde
	TPZ->TPZ_UNIGAR := cuni
	If cPrograma == "MNTA400"
		TPZ->TPZ_DTGARA := If(Empty(M->TL_DTFIM),M->TL_DTINICI,M->TL_DTFIM)
	ElseIf cPrograma == "NG400PADRA"
		nDTI  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTINICI" })
		nDTF  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTFIM" })
		TPZ->TPZ_DTGARA := If(Empty(aCols[n][nDTF]),aCols[n][nDTI],aCols[n][nDTF])
	EndIf

	If cCont=STR0116 //"Contador 1"
		TPZ->TPZ_CONGAR := "1"
	ElseIf cCont=STR0117 //"Contador 2"
		TPZ->TPZ_CONGAR := "2"
	Else
		TPZ->TPZ_CONGAR := " "
	EndIf
	If NGCADICBASE('TPZ_QTDCON','A','TPZ',.F.)
		TPZ->TPZ_QTDCON := nQtdeC
	EndIf
	MsUnLock("TPZ")
	If cPrograma == "NG400PADRA"
		aAdd(aGar,{cOrdem,cCodBem,M->TL_CODIGO,cPlano,M->TL_GARANTI,M->TL_TIPOREG,cLocaliz})
	EndIf

	If Type("aHeader") <> "U"
		nPosG := GDFIELDPOS("TL_GARANTI",aHEADER)
		If nPosG > 0
			aCOLS[n][nPosG] := "S"
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGARANDELETE
Deleta a garantia se nao confirmada a inclusao do insumo
@author Thiago Olis Machado
@since 17/07/2001
@version undefined
@param cOs, characters
@param cPl, characters
@param cCdBem, characters
@param cTpIns, characters
@param cLocIns, characters
@param cCodIns, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGARANDELETE(cOs,cPl,cCdBem,cTpIns,cLocIns,cCodIns)

	If cPrograma == "MNTA400"
		dbSelectArea("TPZ")
		dbSetOrder(2)
		dbSeek(xFilial("TPZ")+cOrdem+cPlano+M->TL_SEQRELA)
		If Found()
			RecLock("TPZ",.F.)
			dbDelete()
			MsUnLock("TPZ")
		EndIf
	ElseIf cPrograma == "NG400PA"
		dbSelectArea("TPZ")
		dbSetOrder(1)
		dbSeek(xFilial("TPZ")+cCdBem+cTpIns+cCodIns+cLocIns+cOs+cPl)
		If Found()
			RecLock("TPZ",.F.)
			dbDelete()
			MsUnLock("TPZ")
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400PADRA
Finalizacao pelo padrao
@author Inacio Luiz Kolling
@since 03/08/2001
@version undefined
@param cAlias, characters
@param nReg, numeric
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function NG400PADRA(cAlias,nReg,nOpcx)

	Local bKeyF4 := SetKey(VK_F4)
	Local oMenu
	Local i, nz, nITENS, j
	Local cNGUNIDT	:= AllTrim(GetMv("MV_NGUNIDT"))
	Local nLocaliz  := 0

	Private aSize := MsAdvSize(), aObjects := {}
	Private aTELA[0][0],aGETS[0],aHeader[0],Continua,nUsado:=0
	Private aGar := {}
	bCampo   := {|nCPO| Field(nCPO) }

	dbSelectArea("STL")
	For i := 1 To Fcount()
		M->&(EVAL(bCampo,i)) := &(EVAL(bCampo,i))

		If nOPCX == 3    //INCLUIR
			If ValType(M->&(EVAL(bCampo,i))) == "C"
				M->&(EVAL(bCampo,i)) := Space(Len(M->&(EVAL(bCampo,i))))
			ElseIf ValType(M->&(EVAL(bCampo,i))) == "N"
				M->&(EVAL(bCampo,i)) := 0
			ElseIf ValType(M->&(EVAL(bCampo,i))) == "D"
				M->&(EVAL(bCampo,i)) := cTod("  /  /  ")
			ElseIf ValType(M->&(EVAL(bCampo,i))) == "L"
				M->&(EVAL(bCampo,i)) := .F.
			EndIf
		EndIf
	Next i

	lINCLOLD := INCLUI
	INCLUI  := .T.
	cPROGOLD := cPROGRAMA
	cPROGRAMA := "NG400PADRA"
	asMenu := NGRIGHTCLICK("MNTA400")

	INCLUI        := .T.
	M->TJ_ORDEM   := STJ->TJ_ORDEM
	M->TJ_PLANO   := STJ->TJ_PLANO
	M->TJ_TAREFA  := "0"
	M->TL_SEQRELA := Space(3)
	nSEQUENC      := Space(3)

	aHEAINS := {}
	aGETINS := {}

	MNTA400IN(nOPCX)
	lCUSTO := .F.
	If cUSAINT3 == 'N'
		lCUSTO := .T.
	EndIf

	If cUSAINT3 == 'S' .And. cUIntHis == "N" .And. STJ->TJ_SERVICO == "HISTOR"
		lCUSTO   := .T.
	EndIf

	aHeader := aCLONE(aHEAINS)
	aCOLS   := aCLONE(aGETINS)
	nITENS  := Len(aCOLS)
	If nITENS == 1 .And. Empty(aCols[1][1]) .And. Empty(aCols[1][2]) .And. Empty(aCols[1][3])
		nITENS := 0
	EndIf


	cTUDOOK := "NG400TUDOK"
	cLINOK  := "NG400LINOK() .And. PutFileInEof('STL')" //Colocar a tabela STL em EOF para não mostrar nome do Insumo na nova linha
	nTIPOREG := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TIPOREG" })
	nCODIGO  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_CODIGO" })

	// Valid padrão do campo TL_LOCALIZ utiliza dois campos de memória porém o objeto da rotina trabalha apenas com um em validações de campo
	nLocaliz := aSCAN( aHeader, { | x | Trim( Upper( x[ 2 ] ) ) == 'TL_LOCALIZ' } )
	If nLocaliz > 0
		
		aHeader[ nLocaliz, 6 ] := 'MNT400LOC()'
	
	EndIf

	SetKey(VK_F12,{||NGINSUF12("M->TL_CODIGO",STJ->tj_codbem,aCOLS[n,nTIPOREG],.T.,,"TL_NOMCODI")})
	SetKey(VK_F4,{|| MntViewSB2(aCOLS[n,nTIPOREG],aCOLS[n,nCODIGO]) })
	nOPFPA  := 0

	aAdd(aObjects,{015,020,.T.,.T.})
	aAdd(aObjects,{100,100,.T.,.T.})
	aInfo   := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
	aPosObj := MsObjSize(aInfo, aObjects,.T.)

	Define Msdialog oDlg5 Title STR0074+STJ->TJ_ORDEM From aSize[7],0 To aSize[6],aSize[5] Of oMainWnd  PIXEL //"FINALIZACAO PELO PADRAO - Insumos Previsto O.S. -> "

	@ 13,001 Button STR0075 Of ODLG5 Size 50,12 Pixel Action (MNTA400DTH()) //"&Alt. Data/Hora"

	oGet := MSGetDados():New(C(30),aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],3,cLINOK,cTUDOOK,"",.T., , , ,300,"NG400DELP", , ,"NG400DELP")

	NGPOPUP(aSMenu,@oMenu)
	oDLG5:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDLG5)}
	Activate MsDialog oDLG5 On Init EnchoiceBar(oDLG5,{||nOPFPA:=1,IIf(oGet:tudook(),oDLG5:End(),.F.)},{||nOPFPA := 0,oDLG5:End()})

	INCLUI    := lINCLOLD
	cPROGRAMA := cPROGOLD

	If nOPFPA == 1

		aGETINS  := Aclone(aCOLS)
		nTAREFA  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TAREFA" })
		nTIPOREG := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TIPOREG" })
		nCODIGO  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_CODIGO" })
		nQUANREC := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_QUANREC" })
		nQUANTID := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_QUANTID" })
		nUNIDADE := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_UNIDADE" })
		nDESTINO := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DESTINO" })
		nDINICIO := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTINICI" })
		nHOINICI := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_HOINICI" })
		nDTFIM   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTFIM" })
		nHOFIM   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_HOFIM" })
		nLOCAL   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_LOCAL" })
		nUSACA   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_USACALE" })
		nOBSERVA := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_OBSERVA" })
		nCUSTO   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_CUSTO" })
		nLOTE    := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_LOTECTL" })
		nSUBLOTE := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_NUMLOTE" })
		nDTVALID := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTVALID" })
		nLOCALIZ := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_LOCALIZ" })
		nNUMSERI := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_NUMSERI" })
		nGAR     := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_GARANTI" })
		nMOEDA   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_MOEDA"   })

		For I := 1 To Len(aCOLS)

			If !aCols[I][Len(aCols[I])]

				cTAREFA := "0"

				If I <= Len(aARTAR)
					cTAREFA  := aARTAR[I][1]
					cTIPOHOR := aARTAR[I,2]
				Else
					cTAREFA  := aCols[I][nTAREFA]
					cTIPOHOR := ""
				EndIf

				cUNIDAD := ALLTRIM(aCOLS[I][nUNIDADE])
				dINI    := aCols[I][nDINICIO]
				hINI    := aCols[I][nHOINICI]
				dFIM    := aCols[I][nDINICIO]
				hFIM    := aCols[I][nHOINICI]

				dbSelectArea(cTRBP400)
				Reclock(cTRBP400,.T.)
				(cTRBP400)->TL_ORDEM   := STJ->TJ_ORDEM
				(cTRBP400)->TL_PLANO   := STJ->TJ_PLANO
				(cTRBP400)->TL_SEQRELA := "0"
				(cTRBP400)->TL_DTINICI := aCols[I][nDINICIO]
				(cTRBP400)->TL_HOINICI := aCols[I][nHOINICI]
				(cTRBP400)->TL_DTFIM   := If(aCols[I][nTIPOREG] = "P",(cTRBP400)->TL_DTINICI,aCols[I][nDTFIM])
				(cTRBP400)->TL_HOFIM   := If(aCols[I][nTIPOREG] = "P",(cTRBP400)->TL_HOINICI,aCols[I][nHOFIM])
				(cTRBP400)->TL_TIPOHOR := IIf( aCols[I][nUSACA] == "S","S",cNGUNIDT)

				If cUsaInt3  = 'S' .And. aCols[I][nTIPOREG] = "P" .And. Rastro(aCols[I][nCODIGO])
					(cTRBP400)->TL_LOTECTL := aCols[I][nLOTE]
					(cTRBP400)->TL_NUMLOTE := aCols[I][nSUBLOTE]
					(cTRBP400)->TL_DTVALID := aCols[I][nDTVALID]
				EndIf
				If cUsaInt3  = 'S' .And. aCols[I][nTIPOREG] = "P" .And. Localiza( Padr( aCols[I][nCODIGO], TAMSX3("B1_COD")[1] ) )
					(cTRBP400)->TL_LOCALIZ := aCols[I][nLOCALIZ]
					(cTRBP400)->TL_NUMSERI := aCols[I][nNUMSERI]
				EndIf

				For nz := 1 To Fcount()
					If FieldName(nz) <> "TL_FILIAL"  .And. FieldName(nz) <> "TL_ORDEM"   .And.;
					FieldName(nz) <> "TL_PLANO"   .And. FieldName(nz) <> "TL_SEQRELA" .And.;
					FieldName(nz) <> "TL_SEQUENC" .And. FieldName(nz) <> "TL_DTFIM"   .And.;
					FieldName(nz) <> "TL_HOFIM"   .And. FieldName(nz) <> "TL_TIPOHOR" .And.;
					FieldName(nz) <> "TL_LOTECTL" .And. FieldName(nz) <> "TL_NUMLOTE" .And.;
					FieldName(nz) <> "TL_DTVALID" .And. FieldName(nz) <> "TL_LOCALIZ" .And.;
					FieldName(nz) <> "TL_NUMSERI"

						xx := aSCAN(aHEADER,{|x| AllTrim(x[2]) == AllTrim(Fieldname(nz))})
						If xx > 0
							vv   := (cTRBP400)+"->"+Fieldname(nz)
							&vv. := aCOLS[i][xx]
						EndIf
					EndIf
				Next nz
				MsUnLock(cTRBP400)

				If aCols[i,nGAR] = "S" .And. Len(aGar) > 0
					If I <= Len(aGar)
						nPosTP := Ascan(aGar,{|x| x[3]+x[6] == (cTRBP400)->TL_CODIGO+(cTRBP400)->TL_TIPOREG})
						If nPosTP > 0
							cSequeG := Alltrim(Str(i,3))
							cLocalG := aGar[nPosTP,7]
							dbSelectArea("TPZ")
							dbSetOrder(1)
							If dbSeek(xFilial("TPZ")+cCodBem+(cTRBP400)->TL_TIPOREG+(cTRBP400)->TL_CODIGO+cLocalG+STJ->TJ_ORDEM+STJ->TJ_PLANO+cSequeG)
								RecLock("TPZ",.F.)
								TPZ->TPZ_DTGARA := If(Empty((cTRBP400)->TL_DTFIM),(cTRBP400)->TL_DTINICI,(cTRBP400)->TL_DTFIM)
								MsUnLock("TPZ")
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf

		Next I
	Else
		nCOD  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_CODIGO" })
		nGAR  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_GARANTI" })

		If Len(aCols) > 0
			For j := 1 to Len(aCols)
				If aCols[j][nGAR] == "S" .And. Len(aGar) > 0
					nPosGar := Ascan(aGar,{|x| x[1]+x[2]+x[3] == STJ->TJ_ORDEM+STJ->TJ_CODBEM+aCOLS[j][nCOD]})
					If nPosGar > 0
						NGARANDELETE(aGar[nPosGar][1],aGar[nPosGar][4],aGar[nPosGar][2],aGar[nPosGar][6],aGar[nPosGar][7],aGar[nPosGar][3])
					EndIf
				EndIf
			Next j
		EndIf
	EndIf
	SetKey(VK_F4,bKeyF4)
	Set Key VK_F12 To

Return nOPFPA

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA400IN
Inclui de Insumos nos itens previstos
@author Inacio Luiz Kolling
@since 03/08/2001
@version undefined
@param nOPCX, numeric
@type function
/*/
//---------------------------------------------------------------------
Function MNTA400IN(nOPCX)

	Local cKEY      := STJ->TJ_ORDEM + STJ->TJ_PLANO + '0  '
	Local cGETWHILE := "TL_FILIAL = xFilial('STL') .And. TL_ORDEM == STJ->TJ_ORDEM .And. TL_PLANO == STJ->TJ_PLANO .And. AllTrim(TL_SEQRELA) == '0'"
	Local cCALENDIN := ""
	Local cCondIf   := ""
	Local nG        := 0
	Local nQUATINS  := 0
	Local nQUANDIF  := 0
	Local nTIPREG   := 0
	Local nCODIGO   := 0
	Local nTAREFA   := 0
	Local nQUANTI   := 0
	Local nUNIDAD   := 0
	Local nDTAFIM   := 0
	Local nHFIM     := 0
	Local nCUSTO    := 0
	Local nLOCAL    := 0
	Local nUSACAL   := 0
	Local nMOEDA    := 0
	Local aRATARSAL := {}
	Local aCstMoeda := {}
	Local aNAO      := {}
	Local vDTAHOR   := {}
	Local nHQUAND   := 0
	Local nHQUANDIF := 0
	Local lHRFORCAL := .T.
	Local lMMoeda   := NGCADICBASE("TL_MOEDA","A","STL",.F.) // Multi-Moeda

	//Não sugere insumos previstos que contenham SA para realização. Quando integrado com estoque.
	If AllTrim(GetMv('MV_NGMNTES')) == 'S'
		cCondIf := "Empty(TL_NUMSA)"
	Else
		cCondIf := ".T." //Caso não esteja integrado com estoque, inclui todos os insumos
	EndIf

	aAdd(aNAO,"TL_ORDEM")
	aAdd(aNAO,"TL_PLANO")
	aAdd(aNAO,"TL_SEQRELA")
	aAdd(aNAO,"TL_SEQUENC")
	aAdd(aNAO,"TL_NOMSEQ")
	aAdd(aNAO,"TL_NOMTAR")
	aAdd(aNAO,"TL_NOMTREG")
	aAdd(aNAO,"TL_CUSTO2")
	aAdd(aNAO,"TL_CUSTO3")
	aAdd(aNAO,"TL_CUSTO4")
	aAdd(aNAO,"TL_CUSTO5")
	aAdd(aNAO,"TL_CUSENT1")
	aAdd(aNAO,"TL_CUSENT2")
	aAdd(aNAO,"TL_CUSENT3")
	aAdd(aNAO,"TL_CUSENT4")
	aAdd(aNAO,"TL_CUSENT5")
	aAdd(aNAO,"TL_OCORREN")
	aAdd(aNAO,"TL_REPFIM")
	aAdd(aNAO,"TL_NUMSEQ")
	aAdd(aNAO,"TL_CODOBS")
	aAdd(aNAO,If(NGCADICBASE('TL_PCTHREX','A','STL',.F.), "TL_PCTHREX", "TL_HREXTRA"))
	aAdd(aNAO,"TL_CONTROL")
	aAdd(aNAO,"TL_ETAPA")
	aAdd(aNAO,"TL_LOCAPLI")
	aAdd(aNAO,"TL_NOMETAP")
	aAdd(aNAO,"TL_NOMLOCA")

	aARTAR := {}
	dbSelectArea("STL")
	dbSetOrder(1)
	dbSeek(xFilial("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO)
	While !EoF() .And. xFilial('STL') == STL->TL_FILIAL;
				 .And. STL->TL_ORDEM  == STJ->TJ_ORDEM .And. STL->TL_PLANO == STJ->TJ_PLANO

		If Alltrim(stl->tl_seqrela) == "0"
			aadd(aARTAR,{STL->TL_TAREFA,STL->TL_TIPOHOR})
		EndIf

		dbSelectArea( "STL" )
		dbSkip()
	End

	aHEAINS := CABECGETD("STL", aNAO)

	//Inclui coluna de registro atraves de funcao generica
	ADHeadRec("STL",aHEAINS)

	If nOPCX == 3
		aGETINS :=BLANKGETD(aHeaIns)
	Else
		dbSelectArea("STL")
		dbSetOrder(3)
		aGETINS := MAKEGETD("STL", cKEY, aHeaIns, cGETWHILE, cCondIf)
		dbSelectArea("STL")
		dbSetOrder(1)

		If Empty(aGETINS)
			aGETINS := BLANKGETD(aHeaIns)
		Else
			M->TJ_ORDEM := STJ->TJ_ORDEM
		EndIf
	EndIf

	For NG := 1 To Len(aGETINS)
		xx := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
		M->TL_TIPOREG := If(xx > 0, aGETINS[nG][xx], " ")

		xx := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_CODIGO"})
		M->TL_CODIGO := If(xx > 0, aGETINS[nG][xx], Space(15))

		xx := aScan(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
		If xx > 0
			aGetIns[nG][xx] := VirtInsumo(M->TL_TIPOREG, M->TL_CODIGO)
		EndIf

	Next

	//Verifica insumos que ainda nao teve toda a quantidade prevista reportada
	nTIPREG := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	nCODIGO := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_CODIGO"})
	nTAREFA := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_TAREFA"})
	nQUANTI := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	nUNIDAD := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_UNIDADE"})
	nDTAFIM := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_DTFIM"})
	nHFIM   := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_HOFIM"})
	nCUSTO  := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_CUSTO"})
	nLOCAL  := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_LOCAL"})
	nUSACAL := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_USACALE"})
	nQTDREC := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_QUANREC"})
	nMOEDA  := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_MOEDA"  })

	//Verifica insumos que ainda nao teve toda a quantidade prevista reportada
	If lINSUSRET
		aGetAux  := AClone(aGETINS)
		vVetdeG  := {}
		For NG := 1 To Len(aGetAux)

			nPosIn := Ascan(aInsFPre ,{|x| x[1]+x[2]+x[3] == aGetAux[NG,nTAREFA]+aGetAux[NG,nTIPREG]+aGetAux[NG,nCODIGO]})

			If nPosIn = 0
				aAdd(vVetdeG,NG)
			Else
				aGetAux[NG,nQUANTI] := aInsFPre[nPosIn,4]
			EndIf

		Next NG

		aGETINS := {}
		For NG := 1 To Len(aGetAux)
			If Ascan(vVetdeG,{|x| x == NG}) = 0
				aAdd(aGETINS,aGetAux[NG])
			EndIf
		Next NG

		For NG := 1 To Len(aGETINS)
			cChaveSt := aGETINS[NG][nTAREFA]+aGETINS[NG][nTIPREG]+aGETINS[NG][nCODIGO]+'0  '

			If aGETINS[NG][nTIPREG] <> "P"
				If NGIFDBSEEK("STL",cChaveSt,1,.F.)
					nHQUAND := NGCONVERHORA(aGETINS[NG,nQUANTI],"D","S")
					If STL->TL_TIPOHOR == "S"
						nHQUANDIF := nHQUAND
					Else
						nHQUANDIF := aGETINS[NG,nQUANTI]
					EndIf

					//Projeta a data e hora fim conforme a quantidade
					If STJ->TJ_PLANO > "000000"
						cCALENDIN := NGSEEK("STF",STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,1,"TF_CALENDA")

						lHRFORCAL := .T.
						lHRFORCAL := NGVALHRCALE(cCALENDIN,STL->TL_DTINICI,STL->TL_HOINICI,"I",.F.)
						If lHRFORCAL
							vDTAHOR := NGDTHORFCALE(STL->TL_DTINICI,STL->TL_HOINICI,nHQUAND,cCALENDIN)
						Else
							vDTAHOR := NGDTHORFIM(STL->TL_DTINICI,STL->TL_HOINICI,If(STL->TL_TIPOHOR = "S",nHQUAND,nQUANDIF))
						EndIf
					Else
						If STL->TL_USACALE == "S"
							cCALENDIN := NGSEEK("ST1",Substr(STL->TL_CODIGO,1,6),1,"T1_TURNO")
							lHRFORCAL := .T.
							lHRFORCAL := NGVALHRCALE(cCALENDIN,STL->TL_DTINICI,STL->TL_HOINICI,"I",.F.)
							If lHRFORCAL
								vDTAHOR := NGDTHORFCALE(STL->TL_DTINICI,STL->TL_HOINICI,nHQUAND,cCALENDIN)
							Else
								vDTAHOR := NGDTHORFIM(STL->TL_DTINICI,STL->TL_HOINICI,If(STL->TL_TIPOHOR = "S",nHQUAND,nQUANDIF))
							EndIf
						Else
							vDTAHOR   := NGDTHORFIM(STL->TL_DTINICI,STL->TL_HOINICI,If(STL->TL_TIPOHOR = "S",nHQUAND,nQUANDIF))
						EndIf
					EndIf

					aGETINS[NG][nUNIDAD] := If(aGETINS[NG][nUNIDAD] <> "H","H",aGETINS[NG][nUNIDAD])
					aGETINS[NG][nDTAFIM] := vDTAHOR[1]
					aGETINS[NG][nHFIM]   := vDTAHOR[2]

					If lMMoeda .And. nMOEDA > 0 .And. FindFunction("NGCALCUSMD")
						aCstMoeda     := NGCALCUSMD(STL->TL_CODIGO,STL->TL_TIPOREG,nQUANDIF,STL->TL_LOCAL,STL->TL_TIPOHOR,,,STL->TL_QUANREC)
						aGETINS[NG][nCUSTO] := aCstMoeda[1]
						aGETINS[NG][nMOEDA] := aCstMoeda[2]
					Else
						aGETINS[NG][nCUSTO] := NGCALCUSTI(STL->TL_CODIGO,STL->TL_TIPOREG,nQUANDIF,STL->TL_LOCAL,STL->TL_TIPOHOR,,,STL->TL_QUANREC)
						If lMMoeda .And. nMOEDA > 0
							aGETINS[NG][nMOEDA] := "1"
						EndIf
					EndIf

				EndIf
			Else

				If lMMoeda .And. nMOEDA > 0 .And. FindFunction("NGCALCUSMD")
					aCstMoeda := NGCALCUSMD(aGETINS[NG][nCODIGO],aGETINS[NG][nTIPREG],aGETINS[NG][nQUANTI],aGETINS[NG][nLOCAL],;
					If(aGETINS[NG,nUSACAL] = "S","S",""),,,If(nQTDREC > 0,aGETINS[NG,nQTDREC],1))
					aGETINS[NG][nCUSTO]    := aCstMoeda[1]
					aGETINS[NG][nMOEDA] := aCstMoeda[2]
				Else
					aGETINS[NG][nCUSTO] := NGCALCUSTI(aGETINS[NG][nCODIGO],aGETINS[NG][nTIPREG],aGETINS[NG][nQUANTI],aGETINS[NG][nLOCAL],;
					If(aGETINS[NG,nUSACAL] = "S","S",""),,,If(nQTDREC > 0,aGETINS[NG,nQTDREC],1))
					If lMMoeda .And. nMOEDA > 0
						aGETINS[NG][nMOEDA] := "1"
					EndIf
				EndIf

			EndIf
		Next

	Else
		//Se diferente de Produto e unidade diferente de Hora coverte para hora
		For NG := 1 To Len(aGETINS)

			If aGETINS[NG][nTIPREG] <> "P" .And. aGETINS[NG][nUNIDAD] <> "H"
				dbSelectArea("STL")
				dbSetOrder(1)
				If dbSeek(xFilial("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO+aGETINS[NG][nTAREFA]+aGETINS[NG][nTIPREG]+aGETINS[NG][nCODIGO]+'0  ')

					vVETHORAS := NGTQUATI2(STL->TL_CODIGO,STL->TL_TIPOREG,STL->TL_USACALE,;
					STL->TL_QUANTID,STL->TL_TIPOHOR,STL->TL_DTINICI,;
					STL->TL_HOINICI,STL->TL_DTFIM,STL->TL_HOFIM,STL->TL_UNIDADE,;
					STL->TL_SEQRELA,STJ->TJ_CODBEM,;
					STJ->TJ_SERVICO,STJ->TJ_SEQRELA,;
					STJ->TJ_PLANO)
					nQUANDIF := vVETHORAS[1]
					nHQUAND := NGCONVERHORA(nQUANDIF,"D","S")
					If STL->TL_TIPOHOR == "S"
						nHQUANDIF := nHQUAND
					Else
						nHQUANDIF := nQUANDIF
					EndIf

					//Projeta a data e hora fim conforme a quantidade
					If STJ->TJ_PLANO > "000000"
						cCALENDIN := NGSEEK("STF",STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,1,"TF_CALENDA")

						lHRFORCAL := .T.
						lHRFORCAL := NGVALHRCALE(cCALENDIN,STL->TL_DTINICI,STL->TL_HOINICI,"I",.F.)
						If lHRFORCAL
							vDTAHOR := NGDTHORFCALE(STL->TL_DTINICI,STL->TL_HOINICI,nHQUAND,cCALENDIN)
						Else
							vDTAHOR := NGDTHORFIM(STL->TL_DTINICI,STL->TL_HOINICI,If(STL->TL_TIPOHOR = "S",nHQUAND,nQUANDIF))
						EndIf
					Else
						If STL->TL_USACALE == "S"
							cCALENDIN := NGSEEK("ST1",Substr(STL->TL_CODIGO,1,6),1,"T1_TURNO")
							lHRFORCAL := .T.
							lHRFORCAL := NGVALHRCALE(cCALENDIN,STL->TL_DTINICI,STL->TL_HOINICI,"I",.F.)
							If lHRFORCAL
								vDTAHOR := NGDTHORFCALE(STL->TL_DTINICI,STL->TL_HOINICI,nHQUAND,cCALENDIN)
							Else
								vDTAHOR := NGDTHORFIM(STL->TL_DTINICI,STL->TL_HOINICI,If(STL->TL_TIPOHOR = "S",nHQUAND,nQUANDIF))
							EndIf
						Else
							vDTAHOR   := NGDTHORFIM(STL->TL_DTINICI,STL->TL_HOINICI,If(STL->TL_TIPOHOR = "S",nHQUAND,nQUANDIF))
						EndIf
					EndIf

					aGETINS[NG][nQUANTI] := nHQUANDIF
					aGETINS[NG][nUNIDAD] := If(aGETINS[NG][nUNIDAD] <> "H","H",aGETINS[NG][nUNIDAD])
					aGETINS[NG][nDTAFIM] := vDTAHOR[1]
					aGETINS[NG][nHFIM]   := vDTAHOR[2]

					If lMMoeda .And. nMOEDA > 0 .And. FindFunction("NGCALCUSMD")
						aCstMoeda := NGCALCUSMD(STL->TL_CODIGO,STL->TL_TIPOREG,nQUANDIF,STL->TL_LOCAL,STL->TL_TIPOHOR,,,STL->TL_QUANREC)
						aGETINS[NG][nCUSTO]    := aCstMoeda[1]
						aGETINS[NG][nMOEDA] := aCstMoeda[2]
					Else
						aGETINS[NG][nCUSTO] := NGCALCUSTI(STL->TL_CODIGO,STL->TL_TIPOREG,nQUANDIF,STL->TL_LOCAL,STL->TL_TIPOHOR,,,STL->TL_QUANREC)
						If lMMoeda .And. nMOEDA > 0
							aGETINS[NG][nMOEDA] := "1"
						EndIf
					EndIf

				EndIf
			EndIf
		Next NG
	EndIf

	dbSelectArea("STL")
	dbSetOrder(1)

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400LINOK
Consiste a Linha da GETDADOS
@author Inacio Luiz Kolling
@since 03/08/2001
@version undefined
@param o, object
@type function
/*/
//---------------------------------------------------------------------
Function NG400LINOK(o)

	Local nx,lRet := .T.,lDeleted := .F., cSavOrd
	Local cTAR, qtd := 0, nTAR, nMAX
	Local lDel := aCOLS[n][Len(aCOLS[n])]
	Local nQtdDe := 0
	If Type('nQuantO') <> 'U'
		nQtdDe := nQuantO
	EndIf

	If lDel
		Return .T.
	EndIf

	nTAR := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TAREFA" })
	nTIP := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	nCOD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	nQTR := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANREC" })
	nQTD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
	nDES := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DESTINO" })
	nUND := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_UNIDADE" })
	nDIN := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })
	nHIN := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI" })
	nDFI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTFIM" })
	nHFI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOFIM" })
	nLOC := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOCAL" })
	nLOT := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOTECTL" })
	nSBL := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_NUMLOTE" })
	nLOL := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOCALIZ" })
	nNUS := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_NUMSERI" })

	cTAR := aCols[n][nTAR]
	cTIP := aCols[n][nTIP]
	cCOD := aCols[n][nCOD]
	cQTR := aCols[n][nQTR]
	cQTD := aCols[n][nQTD]
	cDES := aCols[n][nDES]
	cUND := aCols[n][nUND]
	cDIN := aCols[n][nDIN]
	cHIN := aCols[n][nHIN]
	cDFI := aCols[n][nDFI]
	cHFI := aCols[n][nHFI]
	cLOC := aCols[n][nLOC]
	cLOT := If(nLOT > 0,aCols[n][nLOT],Space(Len(STL->TL_LOTECTL)))
	cSBL := If(nSBL > 0,aCols[n][nSBL],Space(Len(STL->TL_NUMLOTE)))
	cLOL := If(nLOL > 0,aCols[n][nLOL],Space(Len(STL->TL_LOCALIZ)))
	cNUS := If(nNUS > 0,aCols[n][nNUS],Space(Len(STL->TL_NUMSERI)))

	If nTip == 0 .Or. nCOD == 0 .Or. nQTR == 0 .Or. nDES == 0;
	.Or. nDIN == 0 .Or. nHIN == 0 .Or. nTAR == 0
		Return .F.
	EndIf

	If M->TL_TIPOREG = "M"
		If M->TL_USACALE = "S"
			If !Empty(M->TL_HOINICI)
				cCODCAL := NGSEEK("ST1",Substr(M->TL_CODIGO,1,6),1,"T1_TURNO")
				If !NGVALHRCALE(cCODCAL,M->TL_DTINICI,M->TL_HOINICI,"I")
					Return .F.
				EndIf
			EndIf
		EndIf
	EndIf
	nMax := Len(aCols[n])

	If Empty(cTAR)
		Help(" ",1,"OBRIGAT",,STR0115,5,1)
		Return .F.
	EndIf

	//Valida o tipo de insumo terceiro
	If aCols[n][nTIP] == "T"
		If !NGVALTERC(aCols[n][nTIP])
			Return .F.
		EndIf
	EndIf

	//Valida a disponibilidade da mao de obra
	If aCols[n][nTIP] == "M"
		If !NGFUNCRH(aCols[n][nCOD],.F.,cDFI)
			MsgInfo(STR0175+chr(13)+chr(13);  //"Mao de obra nao habilitada junto a folha (RH)."
			+"E/ou "+STR0154+chr(13)+chr(13); //"Mao de obra indisponivel no cadastro de funcionarios."
			+STR0155+aCols[n][nCOD],STR0137) //"Mao de Obra..: " #"NAO CONFORMIDADE"
			Return .F.
		EndIf

		If !NGFRHAFAST(cCOD,cDIN,cDFI,.T.)
			Return .F.
		EndIf
	EndIf

	If cUsaInt3 == 'S' .And. aCols[n][nTIP] == "P"

		//Valida saldo(SB8) de controle de rastreabilidade por lote do produto
		If  Rastro(cCOD)

			If Rastro(cCOD,"S")
				//Valida o sub-lote
				If Empty(cSBL)
					Help(" ",1,"NGATENCAO",,STR0166+" "+STR0169+" "+Str(n,3),3,1)  //"Numero do sub-lote não informado"#"item"
					Return .F.
				Else
					dbSelectArea("SB8")
					dbSetOrder(02)
					If dbSeek(xFilial("SB8")+cSBL+cLOT+cCOD+cLOC)

						/*-------------------------------------------------------------------------------------------------+
						| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
						+-------------------------------------------------------------------------------------------------*/
						If !lHasMNTREQ

							nSaldoLote := SB8Saldo( .F., !Empty( cLOT + cSBL ), Nil, Nil, Nil, Nil, Nil, cDIN )

							If QtdComp(nSaldoLote)+nQtdDe < QtdComp(cQTD)
								cHelp:=OemToAnsi(STR0158)+AllTrim(cCOD)+OemToAnsi(STR0159)+cLOC+OemToAnsi(STR0160); //"Produto "#" Local "#" Saldo Disponivel "
								+Alltrim(Transform(nSaldoLote+nQtdDe,PesqPictQt("B8_SALDO", 14)))+OemToAnsi(STR0161)+Alltrim(cLOT);  //" Lote "
								+OemToAnsi(STR0168)+Alltrim(cSBL)
								Help(" ",1,"A240LOTENE",,cHelp,4,1)
								Return .F.
							EndIf

						EndIf

					Else
						Help(" ",1,"NGATENCAO",,STR0162+CRLF+; //"Numero do sub-lote não corresponde ao produto que foi "
						STR0163+CRLF+CRLF+STR0164+CRLF+STR0165,3,1) //" informado. Digite um sub-lote correspondente."
						Return .F.
					EndIf

				EndIf

			Else
				//Valida o lote
				If Empty(cLOT)
					Help(" ",1,"NGATENCAO",,STR0167+" "+STR0169+" "+Str(n,3),3,1)  //"Numero do lote não informado"#"item"
					Return .F.
				Else

					dbSelectArea("SB8")
					dbSetOrder(03)
					If dbSeek(xFilial("SB8")+cCOD+cLOC+cLOT)

						/*-------------------------------------------------------------------------------------------------+
						| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
						+-------------------------------------------------------------------------------------------------*/
						If !lHasMNTREQ

							nSaldo := SaldoLote( cCOD, cLOC, cLOT, Nil, .F., !Empty( cLOT + cSBL ), Nil, cDIN ) + nQtdDe

							cHelp:=OemToAnsi(STR0158)+AllTrim(cCOD)+OemToAnsi(STR0159)+cLOC+OemToAnsi(STR0160);//"Produto "#" Local "#" Saldo Disponivel "
							+Alltrim(Transform(nSaldo,PesqPictQt("B8_SALDO", 14)))+OemToAnsi(STR0161)+Alltrim(cLOT)  //" Lote "
							If QtdComp(nSaldo)+nQtdDe < QtdComp(cQTD)
								Help(" ",1,"A240LOTENE",,cHelp,4,1)
								Return .F.
							EndIf

						EndIf

					Else
						Help(" ",1,"NGATENCAO",,STR0164+Chr(13)+Chr(10)+; //"Numero do lote não corresponde ao produto que foi "
						STR0165,3,1)  //" informado. Digite um lote correspondente."
						Return .F.
					EndIf

				EndIf

			EndIf

		EndIf

		//Validacao do LOCALIZACAO
		//Verifica se ha problema na habilitacao do controle por enderecamento fisico
		If !Empty(cLOL) .Or. !Empty(cNUS)
			If !LOCALIZA( Padr( cCOD, TAMSX3("B1_COD")[1] ) )
				MsgInfo(STR0156+chr(13)+STR0157,STR0137)//'O paramtro "MV_LOCALIZ" esta desativado ou o campo'
				//' "B1_LOCALIZ" do produto esta preenchido com "N".'
				Return .F.
			EndIf
		EndIf

		If LOCALIZA( Padr( cCOD, TAMSX3("B1_COD")[1] ) )

			//Valida a obrigatoriedade de informar o enderecamento fisico se o produto
			//tem o controle
			If Empty(cLOL) .And. Empty(cNUS)
				Help(" ",1,"LOCALIZOBR",,STR0158+"  "+Trim(cCOD)+" "+STR0169+" "+Str(n,3)+"." ,5,1) //"item"
				Return .F.
			ElseIf Empty(cLOL)
				Help(" ",1,"LOCALIZOBR",,STR0158+"  "+Trim(cCOD)+" "+STR0169+" "+Str(n,3)+"." ,5,1) //"item"
				Return .F.
			EndIf

			If !Empty(cLOL)
				If !EXISTCPO("SBE",cLOC+cLOL)
					Return .F.
				EndIf
			EndIf

			//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
			If !MtAvlNSer(cCOD,cNUS,cQTD)
				Return .F.
			EndIf

			/*-------------------------------------------------------------------------------------------------+
			| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
			+-------------------------------------------------------------------------------------------------*/
			If !lHasMNTREQ

				If ( !Empty( cLOL ) .Or. !Empty( cNUS ) ) .And. QtdComp( SaldoSBF( cLOC, cLOL, cCOD,;
					cNUS, cLOT, cSBL, .F. ) ) + nQtdDe < QtdComp( cQTD )

					Help(" ",1,"SALDOLOCLZ")
					Return .F.

				EndIf

			EndIf

		EndIf
	EndIf

	aEval(aCOLS, {|x| If( (x[nTIP] == cTIP .And. cCOD == x[nCOD] .And. cTAR == x[nTAR] .And. !x[nMax]), qtd++, Nil ) })
	lRET := NG400CHKLIN(n,.T.)

	If cDIN > dDataBase
		MsgStop(STR0328) //"Data inicio não pode ser maior que a data atual."
		Return .F.
	EndIf

	If cDIN == dDataBase .And. !Empty(cHIN)
		If cHIN > Substr(Time(),1,5)
			MsgStop(STR0330) //"Hora inicio não pode ser  maior que a hora atual."
			Return .F.
		EndIf
	EndIf

	If cDFI > dDataBase
		MsgStop(STR0329) //"Data fim não pode ser maior que a data atual."
		Return .F.
	EndIf

	If cDIN == cDFI .And. !Empty(cHFI) .And. cHIN > cHFI
		MsgStop(STR0332) //"Hora fim não pode ser menor que a hora inicio."
		Return .F.
	EndIf

	If dDataBase == cDFI .And. !Empty(cHFI) .And. cHFI > Substr(Time(),1,5)
		MsgStop(STR0331) //"Hora fim não pode ser menor que a hora atual."
		Return .F.
	EndIf

	// Valida se a data de baixa de estoque é maior que a data de bloqueio de estoque (NG400LINOK)
	If cTIP <> "F" .And. cTIP <> "M"
		If !MNTValDBl(cDIN)
			Return .F.
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400TUDOK
Consiste a GETDADOS
@author Inacio Luiz Kolling
@since 03/08/2001
@version undefined
@param o, object
@type function
/*/
//---------------------------------------------------------------------
Function NG400TUDOK(o)

	Local lRet   := .T.,i,ix, lItemBl := .F.
	Local lTEMIN := .F.,nQTDIOK := 0, aCOLFI := Aclone(aCOLS)
	Local aINSALMOX  := {}, aINSALRAST := {} , aINSLOCALIZ  := {}
	Local nQtdDe := 0

	If Type('nQuantO') <> 'U'
		nQtdDe := nQuantO
	EndIf

	nTIPOREG := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TIPOREG" })
	nCODIGO  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_CODIGO" })

	If M->TL_TIPOREG = "M"
		If M->TL_USACALE = "S"
			If !Empty(M->TL_HOINICI)
				cCODCAL := NGSEEK("ST1",Substr(M->TL_CODIGO,1,6),1,"T1_TURNO")
				If !NGVALHRCALE(cCODCAL,M->TL_DTINICI,M->TL_HOINICI,"I")
					Return .F.
				EndIf
			EndIf
		EndIf
	EndIf

	For i := 1 To Len(aCOLS)
		If !aCols[i][Len(aCols[i])]
			lTEMIN  := .T.
			nQTDIOK += 1
			If aCols[i][nTIPOREG] == 'P'
				dbSelectArea("SB1")
				dbSetOrder(01)
				If dbSeek(xFilial("SB1")+aCols[i][nCODIGO]) .And. SB1->B1_MSBLQL == '1'
					lItemBl := .T.
				EndIf
			EndIf
		EndIf
	Next
	If !lTEMIN
		Help(" ",1,"NGMUMINSUMO") //"Para Finalizar Pelo Padrao e Necessario Que Tenha"
		//"Pelo Menos Um Insumo Informado Corretamente."###"ATENCAO"
		lRet := .F.
	ElseIf lItemBl
		MsgInfo(STR0259,STR0022) //"Para Finalizar a O.S., a mesma não poderá ter itens bloqueados."###ATENCAO"
		lRet := .F.
	Else
		nTAR := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TAREFA" })
		nTIP := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
		nCOD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
		nQTR := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANREC" })
		nQTD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
		nDES := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DESTINO" })
		nUND := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_UNIDADE" })
		nDIN := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })
		nHIN := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI" })
		nDFI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTFIM" })
		nHFI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOFIM" })
		nLOC := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOCAL" })
		nLOT := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_LOTECTL" })
		nSBL := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_NUMLOTE" })
		nLOL := aSCAN( aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_LOCALIZ" })
		nNUS := aSCAN( aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_NUMSERI" })
		nGAR := aSCAN( aHEADER,{|x| AllTrim(Upper(X[2])) == "TL_GARANTI" })

		aCOLFI := aSORT(aCOLFI,,,{|x,y| x[nTIP]+x[nTAR]+x[nCOD] < y[nTIP]+y[nTAR]+y[nCOD]})
		For ix := 1 To Len(aCOLS)
			cCOD := aCols[ix][nCOD]
			cTIP := aCols[ix][nTIP]
			cQTR := aCols[ix][nQTR]
			cQTD := aCols[ix][nQTD]
			cDES := aCols[ix][nDES]
			cUND := aCols[ix][nUND]
			cDIN := aCols[ix][nDIN]
			cHIN := aCols[ix][nHIN]
			cDFI := aCols[ix][nDFI]
			cHFI := aCols[ix][nHFI]
			cLOC := aCols[ix][nLOC]
			cLOT := If(nLOT > 0,aCols[ix][nLOT],Space(Len(STL->TL_LOTECTL)))
			cSBL := If(nSBL > 0,aCols[ix][nSBL],Space(Len(STL->TL_NUMLOTE)))
			cLOL := If(nLOL > 0,aCols[ix][nLOL],Space(Len(STL->TL_LOCALIZ)))
			cNUS := If(nNUS > 0,aCols[ix][nNUS],Space(Len(STL->TL_NUMSERI)))

			If !aCols[ix][Len(aCols[ix])]

				//Valida o tipo de insumo terceiro
				If aCols[ix][nTIP] == "T"
					If !NGVALTERC(aCols[ix][nTIP])
						Return .F.
					EndIf
				EndIf

				If aCols[ix][nTIP] == "E"
					MsgInfo(STR0145+chr(13)+STR0146+" "+str(ix,3),STR0137)
					lRet := .F.
					Exit
				EndIf

				lRET := NG400CHKLIN(ix,.F.)
				If !lRET
					Exit
				EndIf

				If aCols[ix][nTIP] == "P"
					dDATULMES := dULMES
					If cUsaInt3 = "S"
						If dULMES >= aCols[ix][nDIN]
							MsgInfo(STR0078+chr(13)+chr(13); //"Nao Podera Ser Finalizado Pelo Padrao, Por Que a Data"
							+STR0079+chr(13)+chr(13); //"Do Ultimo Fechamento do Estoque e Maior do Que a Data"
							+STR0080+chr(13)+chr(13); //"Final de Utilizacao do Produto"
							+STR0081+aCols[ix][nCOD]+chr(13)+chr(13); //"Codigo do Produto          -> "
							+STR0082+Dtoc(dDATULMES)+chr(13)+chr(13); //"Data Ultimo Fechamento -> "
							+STR0083+DTOC(aCols[ix][nDin]),STR0022) //"Data Final Do Insumo      -> "###"ATENCAO"
							lRet := .F.
							Exit
						EndIf

						//Array para checar estoque negativo do produto
						If !lESTNEGA
							nPOS400 := Ascan(aINSALMOX,{|x| x[1]+x[2] == cCOD+cLOC})
							If nPOS400 = 0
								aAdd(aINSALMOX,{cCOD,cLOC,cQTD})
							Else
								aINSALMOX[nPOS400][3] += cQTD
							EndIf
						EndIf

						//Valida saldo(SB8) de controle de rastreabilidade por lote do produto
						If Rastro(cCOD)

							If Rastro(cCOD,"S")
								//Valida o sub-lote
								If Empty(cSBL)
									Help(" ",1,"NGATENCAO",,STR0166+" "+STR0169+" "+Str(ix,3),3,1)  //"Numero do sub-lote não informado"#"item"
									Return .F.
								Else
									nPOS400X := Ascan(aINSALRAST,{|x| x[1]+x[2]+x[3]+x[4] == cCOD+cLOC+cLOT+cSBL})
									If nPOS400X = 0
										aAdd(aINSALRAST,{cCOD,cLOC,cLOT,cSBL,cQTD,cDIN,"S"})
									Else
										aINSALRAST[nPOS400X][5] += cQTD
										aINSALRAST[nPOS400X][6] := Min(aINSALRAST[nPOS400X][6],cDIN)
									EndIf
								EndIf
							Else
								//Valida o lote
								If Empty(cLOT)
									Help(" ",1,"NGATENCAO",,STR0167+" "+STR0169+" "+Str(ix,3),3,1)  //"Numero do lote não informado"#"item"
									Return .F.
								Else
									nPOS400X := Ascan(aINSALRAST,{|x| x[1]+x[2]+x[3] == cCOD+cLOC+cLOT})
									If nPOS400X = 0
										aAdd(aINSALRAST,{cCOD,cLOC,cLOT,cSBL,cQTD,cDIN,"L"})
									Else
										aINSALRAST[nPOS400X][5] += cQTD
										aINSALRAST[nPOS400X][6] := Min(aINSALRAST[nPOS400X][6],cDIN)
									EndIf
								EndIf
							EndIf
						EndIf

						//Verifica se ha problema na habilitacao do controle por enderecamento fisico
						If !Empty(cLOL) .Or. !Empty(cNUS)
							If !LOCALIZA( Padr( cCOD, TAMSX3("B1_COD")[1] ) )
								MsgInfo(STR0218+" "+chr(13)+; //"O parametro 'MV_LOCALIZ' esta desativado ou o campo 'B1_LOCALIZ' do"
								STR0158+" "+Trim(cCOD)+" "+STR0219,STR0137)  //"esta preenchido como 'N'."
								Return .F.
							EndIf
						EndIf

						If LOCALIZA( Padr( cCOD, TAMSX3("B1_COD")[1] ) )

							//Valida a obrigatoriedade de informar o enderecamento fisico se o produto
							//tem o controle
							If Empty(cLOL) .And. Empty(cNUS)
								Help(" ",1,"LOCALIZOBR",,STR0158+"  "+Trim(cCOD)+" "+STR0169+" "+Str(ix,3)+"." ,5,1) //"item"
								Return .F.
							ElseIf Empty(cLOL)
								Help(" ",1,"LOCALIZOBR",,STR0158+"  "+Trim(cCOD)+" "+STR0169+" "+Str(ix,3)+"." ,5,1) //"item"
								Return .F.
							EndIf

							If !Empty(cLOL) .Or. !Empty(cNUS)
								nPOS400X := Ascan(aINSLOCALIZ ,{|x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6] == cLOC+cLOL+cCOD+cNUS+cLOT+cSBL})
								If nPOS400X = 0
									aAdd(aINSLOCALIZ,{cLOC,cLOL,cCOD,cNUS,cLOT,cSBL,cQTD})
								Else
									aINSLOCALIZ[nPOS400X][7] += cQTD
								EndIf
							EndIf
						EndIf
					EndIf
				ElseIf aCols[ix][nTIP] == "M"
					If !NGFUNCRH(aCols[ix][nCOD],.F.,cDFI)
						MsgInfo(STR0175+chr(13)+chr(13);  //"Mao de obra nao habilitada junto a folha (RH)."
						+"E/ou "+STR0154+chr(13)+chr(13); //"Mao de obra indisponivel no cadastro de funcionarios."
						+STR0155+aCols[ix][nCOD],STR0137) //"Mao de Obra..: " #"NAO CONFORMIDADE"
						Return .F.
					EndIf

					If !NGFRHAFAST(cCOD,cDIN,cDFI,.T.)
						Return .F.
					EndIf

					If cUsaInt3 = "S"
						dDATULMES := dULMES
						If dULMES >= aCols[ix][nDIN]
							MsgInfo(STR0078+chr(13)+chr(13); //"Nao Podera Ser Finalizado Pelo Padrao, Por Que a Data"
							+STR0079+chr(13)+chr(13); //"Do Ultimo Fechamento do Estoque e Maior do Que a Data"
							+STR0080+chr(13)+chr(13); //"Final de Utilizacao do Produto"
							+STR0081+aCols[ix][nCOD]+chr(13)+chr(13); //"Codigo do Produto          -> "
							+STR0082+Dtoc(dDATULMES)+chr(13)+chr(13); //"Data Ultimo Fechamento -> "
							+STR0083+DTOC(aCols[ix][nDin]),STR0022) //"Data Final Do Insumo      -> "###"ATENCAO"
							lRet := .F.
							Exit
						EndIf
					EndIf
				EndIf
			Else
				If aCols[ix][nGAR] == "S" .And. Len(aGar) > 0
					nPosGar := Ascan(aGar,{|x| x[1]+x[2]+x[3] == STJ->TJ_ORDEM+STJ->TJ_CODBEM+aCOLS[ix][nCOD]})
					If nPosGar > 0
						NGARANDELETE(aGar[nPosGar][1],aGar[nPosGar][4],aGar[nPosGar][2],aGar[nPosGar][6],aGar[nPosGar][7],aGar[nPosGar][3])
					EndIf
				EndIf
			EndIf
		Next

		//Valida o Estoque Negativo
		If cUsaInt3 = "S"  .And. lRet

			/*-------------------------------------------------------------------------------------------------+
			| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
			+-------------------------------------------------------------------------------------------------*/
			If !lESTNEGA .And. !lHasMNTREQ

				For ix := 1 To Len(aINSALMOX)
					If !NGSALSB2(aINSALMOX[ix][1],aINSALMOX[ix][2],aINSALMOX[ix][3])
						Return .F.
					EndIf
				Next

			EndIf

			//Checa Saldos por Lote
			If Len(aINSALRAST) > 0
				For ix := 1 To Len(aINSALRAST)
					If aINSALRAST[ix][7] = "S" //Sub-lote

						dbSelectArea("SB8")
						dbSetOrder(02)
						If dbSeek(xFilial("SB8")+aINSALRAST[ix][4]+aINSALRAST[ix][3]+aINSALRAST[ix][1]+aINSALRAST[ix][2])

							/*-------------------------------------------------------------------------------------------------+
							| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
							+-------------------------------------------------------------------------------------------------*/
							If !lHasMNTREQ

								nSaldoLote := SB8Saldo( .F., !Empty( aINSALRAST[ix][3] + aINSALRAST[ix][4] ), Nil, Nil, Nil, Nil, Nil,;
									aINSALRAST[ix][6] ) + nQtdDe

								If QtdComp(nSaldoLote)+nQtdDe < aINSALRAST[ix][5]
									cHelp:=OemToAnsi(STR0158)+AllTrim(aINSALRAST[ix][1])+OemToAnsi(STR0159)+aINSALRAST[ix][2]+OemToAnsi(STR0160); //"Produto "#" Local "#" Saldo Disponivel "
									+Alltrim(Transform(nSaldoLote,PesqPictQt("B8_SALDO",14)))+OemToAnsi(STR0161)+Alltrim(aINSALRAST[ix][3]);  //" Lote "
									+OemToAnsi(STR0168)+Alltrim(aINSALRAST[ix][4]) //Sub-lote
									Help(" ",1,"A240LOTENE",,cHelp,4,1)
									Return .F.
								EndIf

							EndIf

						Else
							Help(" ",1,"NGATENCAO",,STR0162+CRLF+; //"Numero do sub-lote não corresponde ao produto que foi "
							STR0163+CRLF+CRLF+STR0164+CRLF+STR0165,3,1) //" informado. Digite um sub-lote correspondente."
							Return .F.
						EndIf

					Else //Lote

						dbSelectArea("SB8")
						dbSetOrder(03)
						If dbSeek(xFilial("SB8")+aINSALRAST[ix][1]+aINSALRAST[ix][2]+aINSALRAST[ix][3])

							/*-------------------------------------------------------------------------------------------------+
							| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
							+-------------------------------------------------------------------------------------------------*/
							If !lHasMNTREQ

								nSaldo := SaldoLote( aINSALRAST[ix][1], aINSALRAST[ix][2], aINSALRAST[ix][3], Nil, .F., !Empty( aINSALRAST[ix][3] + aINSALRAST[ix][4] ),;
									Nil, aINSALRAST[ix][6] ) + nQtdDe

								cHelp :=OemToAnsi(STR0158)+AllTrim(aINSALRAST[ix][1])+OemToAnsi(STR0159)+aINSALRAST[ix][2]+OemToAnsi(STR0160);//"Produto "#" Local "#" Saldo Disponivel "
								+Alltrim(Transform(nSaldo,PesqPictQt("B8_SALDO", 14)))+OemToAnsi(STR0161)+Alltrim(aINSALRAST[ix][3])  //" Lote "
								If QtdComp(nSaldo) < QtdComp(aINSALRAST[ix][5])
									Help(" ",1,"A240LOTENE",,cHelp,4,1)
									Return .F.
								EndIf

							EndIf

						Else
							Help(" ",1,"NGATENCAO",,STR0164+Chr(13)+Chr(10)+; //"Numero do lote não corresponde ao produto que foi "
							STR0165,3,1)  //" informado. Digite um lote correspondente."
							Return .F.
						EndIf

					EndIf

				Next ix

			EndIf

			/*-------------------------------------------------------------------------------------------------+
			| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
			+-------------------------------------------------------------------------------------------------*/
			If Len(aINSLOCALIZ) > 0 .And. !lHasMNTREQ

				For ix := 1 To Len(aINSLOCALIZ)

					If QtdComp(SaldoSBF(aINSLOCALIZ[ix][1],aINSLOCALIZ[ix][2],aINSLOCALIZ[ix][3],;
					aINSLOCALIZ[ix][4],aINSLOCALIZ[ix][5],aINSLOCALIZ[ix][6],.F.))+nQtdDe < QtdComp(aINSLOCALIZ[ix][7])

						If !Empty(aINSLOCALIZ[ix][4])
							cHelp := OemToAnsi(STR0158)+" "+AllTrim(aINSLOCALIZ[ix][3])+" "+OemToAnsi(STR0070)+" "+AllTrim(aINSLOCALIZ[ix][1]); //"Produto " #"Local"
							+" "+OemToAnsi(STR0186)+" "+AllTrim(aINSLOCALIZ[ix][2])+" "+OemToAnsi(STR0220); //"Localizacao" # "Num. Serie"
							+" "+AllTrim(aINSLOCALIZ[ix][4])
							Help(" ",1,"SALDOLOCLZ", ,cHelp,4,1)
							Return .F.
						Else
							cHelp := OemToAnsi(STR0158)+" "+AllTrim(aINSLOCALIZ[ix][3])+" "+OemToAnsi(STR0070)+" "+AllTrim(aINSLOCALIZ[ix][1]); //#"Local"
							+" "+OemToAnsi(STR0186)+" "+AllTrim(aINSLOCALIZ[ix][2]) //"Localizacao"
							Help(" ",1,"SALDOLOCLZ", ,cHelp,4,1)
							Return .F.
						EndIf

					EndIf
				Next ix
			EndIf

		EndIf

		If lRET
			If ExistBlock("NGTERMOP")
				If !ExecBlock("NGTERMOP",.F.,.F.)
					lRet := .F.
				EndIf
			EndIf
		EndIf

	EndIf
	//Validacao para hora e data.
	If lRET
		For ix := 1 To Len(aCOLS)
			If !aCols[ix][Len(aCols[ix])]
				If aCols[ix][nDIN] > dDataBase
					MsgStop(STR0333+cValtoChar(ix)+".") //"Data inicio não pode ser maior que a data atual, item "
					Return .F.
				EndIf
				If aCols[ix][nDIN] == dDataBase .And. !Empty(aCols[ix][nHIN])
					If aCols[ix][nHIN] > Substr(Time(),1,5)
						MsgStop(STR0334+cValtoChar(ix)+".") //"Hora inicio não pode ser  maior que a hora atual, item "
						Return .F.
					EndIf
				EndIf
				If aCols[ix][nDFI] > dDataBase
					MsgStop(STR0335+cValtoChar(ix)+".") //"Data fim não pode ser maior que a data atual, item "
					Return .F.
				EndIf
				If aCols[ix][nDIN] == aCols[ix][nDFI] .And. aCols[ix][nHIN] > aCols[ix][nHFI]
					MsgStop(STR0336+cValtoChar(ix)+".") //"Hora fim não pode ser menor que a hora inicio, item "
					Return .F.
				EndIf
				If dDataBase == aCols[ix][nDFI] .And. !Empty(aCols[ix][nHFI]) .And. aCols[ix][nHFI] > Substr(Time(),1,5)
					MsgStop(STR0338+cValtoChar(ix)+".") //"Hora fim não pode ser menor que a hora atual, item "
					Return .F.
				EndIf
				If aCols[ix][nDIN] == aCols[ix][nDFI] .And. aCols[ix][nHIN] == aCols[ix][nHFI] .And. aCols[ix][nTIP] <> "P"
					MsgStop(STR0228+" "+	STR0373+" "+STR0230+" " +STR0169+"   "+cValtoChar(ix)+".")
					Return .F.
				EndIf

				// Valida se a data de baixa de estoque é maior que a data de bloqueio de estoque (NG400TUDOK)
				If aCols[ix][nTIP] <> "F" .And. aCols[ix][nTIP] <> "M"
					If !MNTValDBl(aCols[ix][nDIN])
						Return .F.
					EndIf
				EndIf
			EndIf
		Next
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400CHKLIN
Consiste a GETDADOS
@author Inacio Luiz Kolling
@since 15/04/2004
@version undefined
@param nVLIN, numeric
@param lCHEKLINH, logical
@type function
/*/
//---------------------------------------------------------------------
Function NG400CHKLIN(nVLIN,lCHEKLINH)

	Local lRETCHKL   := .T.
	Local aRETVALINT := {}, nORDOLD, nRECNOOL

	If Empty(cCOD) .Or. Empty(cTIP)
		Help(" ",1,"NGPROBINSU")
		lRETCHKL := .F.
	EndIf

	If lRETCHKL
		If cTIP = "P"
			If Empty(cDES) .Or. Empty(cQTD) .Or. Empty(cUND) .Or. Empty(cDIN);
			.Or. Empty(cHIN)
				Help(" ",1,"NGPROBINSU")
				lRETCHKL := .F.
			EndIf
			If lRETCHKL
				If !NGEMPALM(cLOC,nVLIN)
					lRETCHKL := .F.
				Else
					If !NGPROALM(cCOD,cLOC,nVLIN)
						lRETCHKL := .F.
					EndIf
				EndIf

				// VALIDA SE O PRODUTO NO LOCAL INFORMADO ENCONTRA-SE EM PROCESSO DE INVENTÁRIO.
				If lRETCHKL .And. BlqInvent( cCOD, cLOC )

					Help( '', 1, 'BLQINVENT' )
					lRETCHKL := .F.

				EndIf

				If lRETCHKL .And. lCHEKLINH .And. cUsaInt3 == "S" //Verifica integração com estoque
					cLOCAL := cLOC
					dbSelectArea( "SB2" )
					dbSetOrder(1)
					If dbSeek(xFilial("SB2")+cCOD+cLOCAL)
						If !lESTNEGA
							lRETCHKL := NGSALSB2(cCOD,cLOCAL,cQTD,,,cDIN)
						Else
							lRETCHKL := .T.
						EndIf
					Else
						lRETCHKL := .F.
					EndIf
				EndIf
			EndIf
		Else
			If cTIP $ "F/E" .And. Empty(cQTR)
				Help(" ",1,"QUANTIDADE")
				lRETCHKL := .F.
			EndIf

			If lRETCHKL
				If !NGDATHORIF(cDIN,cHIN,cDFI,cHFI,nVLIN)
					lRETCHKL := .F.
				EndIf
			EndIf

			//Valida o intervalo de data/hora para ferramenta e mao de obra, em arquivo e acols
			If lRETCHKL

				dbSelectArea("STJ")
				nORDOLD  := IndexOrd()
				nRECNOOL := Recno()

				If cTIP == "M"

					//Valida no arquivo STL/STT
					aRETVALINT := NGVALDATIN(cCOD,M->TJ_ORDEM,M->TJ_PLANO,cDIN,cHIN,cDFI,cHFI,"M", ,"STL")
					If !aRETVALINT[1]
						lRETCHKL := .F.
					EndIf

					If lRETCHKL
						aRETVALINT := NGVALDATIN(cCOD,M->TJ_ORDEM,M->TJ_PLANO,cDIN,cHIN,cDFI,cHFI,"M", ,"STT")
						If !aRETVALINT[1]
							lRETCHKL := .F.
						EndIf
					EndIf

					//Valida na acols
					If lRETCHKL
						aRETVALINT := MNT400VLTA(cCOD,M->TJ_ORDEM,M->TJ_PLANO,cDIN,cHIN,cDFI,cHFI,"M",nVLIN)
						If !aRETVALINT[1]
							lRETCHKL := .F.
						EndIf
					EndIf

				ElseIf cTIP == "F"

					dbSelectArea("SH4")
					dbSeek(xFilial("SH4")+SubStr(cCOD,1,6))
					nQUATSH4 := SH4->H4_QUANT

					//Valida no arquivo
					//STL
					aRETVALINT := NGVALDATIN(cCOD,M->TJ_ORDEM,M->TJ_PLANO,cDIN,cHIN,cDFI,cHFI,"F", ,"STL")
					nQUANTFERR := aRETVALINT[2]
					nRESTQUA   := nQUATSH4 - nQUANTFERR

					If nRESTQUA >= 0
						//STT
						aRETVALINT := NGVALDATIN(cCOD,M->TJ_ORDEM,M->TJ_PLANO,cDIN,cHIN,cDFI,cHFI,"F", ,"STL")
						nQUANTFERR += aRETVALINT[2]
						nRESTQUA   := nQUATSH4 - nQUANTFERR
					EndIf

					If nRESTQUA >= 0
						//Valida na Acols
						aRETVALINT := MNT400VLTA(cCOD,M->TJ_ORDEM,M->TJ_PLANO,cDIN,cHIN,cDFI,cHFI,"F",nVLIN)
						nQUANTFERR += aRETVALINT[2]
						nRESTQUA   := nQUATSH4 - nQUANTFERR
					EndIf

					If nRESTQUA <= 0 .And. nQUANTFERR > 0
						MsgInfo(STR0226 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
						+STR0227 +".....: "+ dtoc(cDIN)+chr(13); //"Data Inicio"
						+STR0228 +".....: " + Substr(cHIN,1,5)+chr(13); //"Hora Inicio"
						+STR0229 +"........: " + dtoc(cDFI)+chr(13); //"Data Fim"
						+STR0230 +"........: " + Substr(cHFI,1,5)+chr(13); //"Hora Fim"
						+STR0231 +"................: " + Alltrim(Str(nVLIN,3)),STR0022) //"Item"
						lRETCHKL := .F.
					EndIf

				EndIf
				dbSelectArea("STJ")
				dbSetOrder(nORDOLD)
				dbGoto(nRECNOOL)
			EndIf
		EndIf
	EndIf

Return lRETCHKL

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA400DTH
Altera a data e Hora inicio do Insumo
@author Inacio Luiz Kolling
@since 12/07/2001
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA400DTH()

	Local dINICI := STJ->TJ_DTORIGI,xi
	Local oMenu, nHQTDF, Reg
	Local cHOINI 	:= SubStr(Time(),1,5)
	Local vALTDT 	:= {}
	Local cNGUNIDT 	:= AllTrim(GetMv("MV_NGUNIDT"))

	Private cCALEND := ""

	If !NG400LINOK()
		Return .F.
	EndIf

	nDINI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })
	nHONI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI" })
	nTPRG := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	nDTFI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTFIM" })
	nHOFI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOFIM" })
	nQTDE := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
	nCDGO := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TL_CODIGO"})
	nTRFA := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TL_TAREFA"})
	nUNID := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TL_UNIDADE"})
	nLCAL  := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TL_LOCAL"})
	nQTDR := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TL_QUANREC"})
	nUSCA := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TL_USACALE"})

	For Reg := 1 to Len(aCols)
		If  aCols[Reg][nTPRG] == "M" .And. aCols[Reg][nUSCA] == "S"
			If M->TJ_PLANO > "000000"
				cCALEND := NGSEEK("STF",STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,1,"TF_CALENDA")
			ElseIf  M->TJ_PLANO == "000000"
				cCALEND := NGSEEK("ST1",Substr(M->TL_CODIGO,1,6),1,"T1_TURNO")
			EndIf
		EndIf
	Next Reg

	If nDINI > 0 .And. nHONI > 0
		nOpcon := 0
		Define Msdialog oDlg8 From 480,220 To 585,550 Title Oemtoansi(STR0089) Pixel //"Alteracao Geral Data/Hora Inicio do Insumo"

		@ 0.6,1  Say Oemtoansi(STR0090) //"Data Inicio"
		@ 0.5,4.5  MsGet dINICI Picture "99/99/99" Size 45,10  Valid MNTA400DIN(dINICI) HASBUTTON
		@ 0.6,11 Say Oemtoansi(STR0091) //"Hora Inicio"
		@ 0.5,15 MsGet cHOINI Picture "99:99" Size 10,10 Valid NGVALHORA(cHOINI,.T.)

		Define SButton From 30,090 Type 1 Enable Of oDlg8 Action ( nOpcon:=1,If (MNT400VLDC(dINICI,cHOINI),oDlg8:End(),.F.) )
		Define SButton From 30,130 Type 2 Enable Of oDlg8 Action ( nOpcon:=2,oDlg8:End() )

		NGPOPUP(aSMenu,@oMenu)
		oDLG8:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDLG8)}
		Activate Msdialog oDlg8 Centered

		If nOpcon == 1
			For xi := 1 To Len(aCOLS)

				cChvST := STJ->TJ_ORDEM+STJ->TJ_PLANO+aCols[xi][nTRFA]+aCols[xi][nTPRG]+aCols[xi][nCDGO]+'0  '
				If lTSeqt .And. !Empty(aCols[xi][nSEQT])
					cChvST += aCols[xi][nSEQT]
				EndIf

				If aCols[xi][nTPRG] <> "P"
					nHQTD := NGCONVERHORA(aCols[xi][nQTDE],"D","S")
					If (NGIFDBSEEK("STL",cChvST,1,.F.) .And. STL->TL_TIPOHOR == "S") .Or. (STL->(!Found()) .And. cNGUNIDT == "S")
						nHQTDF := nHQTD
					Else
						nHQTDF := aCols[xi][nQTDE]
					EndIf

					If STJ->TJ_PLANO > "000000"
						If M->TL_TIPOREG == "M" .And. STL->TL_USACALE == "S"
							cCALEND := NGSEEK("STF",STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,1,"TF_CALENDA")

							lHRCAL := .T.
							lHRCAL := NGVALHRCALE(cCALEND,dINICI,cHOINI,"I",.F.)
							If lHRCAL
								vALTDT := NGDTHORFCALE(dINICI,cHOINI,nHQTD,cCALEND)
							EndIf
						Else
							vALTDT := NGDTHORFIM(dINICI,cHOINI,If(STL->TL_TIPOHOR == "S",nHQTD,nHQTDF))
						EndIf
					Else
						If STL->TL_USACALE == "S" .And. M->TL_TIPOREG == "M"
							cCALEND := NGSEEK("ST1",Substr(STL->TL_CODIGO,1,6),1,"T1_TURNO")

							lHRCAL := .T.
							lHRCAL := NGVALHRCALE(cCALEND,dINICI,cHOINI,"I",.F.)
							If lHRCAL
								vALTDT := NGDTHORFCALE(dINICI,cHOINI,nHQTD,cCALEND)
							EndIf
						Else
							vALTDT := NGDTHORFIM(dINICI,cHOINI,If(STL->TL_TIPOHOR == "S",nHQTD,nHQTDF))
						EndIf
					EndIf
				Else
					aAdd(vALTDT,dINICI)
					aAdd(vALTDT,cHOINI)
				EndIf

				If !aCols[xi][Len(aCols[xi])]
					aCols[xi][nDINI] := dINICI
					aCols[xi][nHONI] := cHOINI
					aCols[xi][nDTFI] := vALTDT[1]
					aCols[xi][nHOFI] := vALTDT[2]
				EndIf
			Next
			oGet:oBrowse:refresh()
		EndIf
	Else
		MsgStop(STR0092+' TL_DTNINCI, TL_HOINICI '+")") //"Ha Problemas de Definicao de Campos a Ser Usados ("
		Return
	EndIf
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA400DIN
Validacao data inicio do Insumo ( alteracao Geral )
@author Inacio Luiz Kolling
@since 03/08/2001
@version undefined
@param dVDINI, date
@type function
/*/
//---------------------------------------------------------------------
Function MNTA400DIN(dVDINI)

	If dVDINI < STJ->TJ_DTORIGI .OR. dVDINI > dDataBase
		MsgInfo(STR0093+chr(13)+chr(13); //"Data Inicio Devera Ser Maior ou Igual a Data De Origem"
		+STR0094+chr(13)+chr(13); //"da Ordem de Servico ou Menor do Que a Data Atual."
		+STR0095+dtoc(STJ->TJ_DTORIGI)+chr(13)+chr(13); //"Data Origem da O.S. -> "
		+STR0096+dtoc(dDataBase)+chr(13)+chr(13); //"Data Atual                 -> "
		+STR0097+dtoc(dVDINI),STR0022) //"Data Informada         -> "###"ATENCAO"
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400DELP
Verifica se Ha pedido de compra para o iten a ser deletado
@author Inacio Luiz Kolling
@since 06/08/2001
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG400DELP()

	nTIPOREG := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TIPOREG" })
	nCODIGO  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_CODIGO" })

	cTAREFAX := '0'+Replicate(' ',Len(STL->TL_TAREFA)-1)

	If n <= Len(aARTAR)
		cTAREFAX := aARTAR[n][1]
	EndIf

	lRETOR := NGCOTAPEDI(STJ->TJ_ORDEM,STJ->TJ_PLANO,cTAREFAX,;
	aCols[n][nTIPOREG],aCols[n][nCODIGO],"0",Len(aARTAR),n)
	If lRETOR
		If ExistBlock("NGTERMOU")
			cCUSTOSZC := STJ->TJ_CCUSTO
			cCODSZC   := aCols[n][nCODIGO]
			lRETOR    := ExecBlock('NGTERMOU',.F.,.F.)
		EndIf
	EndIf

Return lRETOR

//---------------------------------------------------------------------
/*/{Protheus.doc} NGRETNOREG
Mostra o nome do tipo de insumo
@author Inacio Luiz Kolling
@since 06/08/2001
@version undefined
@param cTipreg, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGRETNOREG(cTipreg)

	Local nCODOC := 0
	Local lMMoeda := NGCADICBASE("TL_MOEDA","A","STL",.F.) // Multi-Moeda

	If cTIPREG = 'E'
		If cPROGRAMA = "MNTA400" .Or. cPROGRAMA = "MNTA415" .Or. cPROGRAMA = "MNTA360" .Or. cPROGRAMA = "NG400PADRA"
			MsgInfo(STR0143+chr(13)+chr(10)+STR0144,STR0137)
			M->TL_NOMTREG := Space(20) //STR0107 //"ESPECIALIDADE"
			M->TL_UNIDADE := "H"
			Return .F.
		EndIf
	ElseIf cTIPREG == 'M'
		M->TL_NOMTREG :=STR0108 //"FUNCIONARIO  "
		M->TL_UNIDADE := "H"
	ElseIf cTIPREG == 'P'
		If ExistBlock("MNTA4009")
			If !ExecBlock("MNTA4009",.F.,.F.)
				Return .F.
			EndIf
		EndIf
		M->TL_NOMTREG := STR0109 //"PRODUTO      "
	ElseIf cTIPREG == 'F'
		M->TL_NOMTREG := STR0110 //"FERRAMENTA   "
		M->TL_UNIDADE := "H"
	ElseIf cTIPREG == 'T'
		M->TL_NOMTREG := STR0111 //"TERCEIROS    "
		M->TL_UNIDADE := "H"
	EndIf

	// Multi-Moeda
	If lMMoeda .And. Type("M->TL_MOEDA") == "C"
		M->TL_MOEDA := "1"
	EndIf
	If Type ("aHEADER") == "A"
		nCODOC := GDFIELDPOS("TN_CODOCOR" )
	EndIf

	If NGCADICBASE("TL_PERMDOE","A","STL",.F.) .And. cTipreg <> "M" .And. nCODOC > 0 .And. NGFUNCRPO("NGMDOEXECU",.F.)
		M->TL_PERMDOE := 0.00
		aCols := BLANKGETD(aHeader)
		oGet:FORCEREFRE()
	EndIf

	lRefresh := .T.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400CON

@author  NG Informatica
@since 17/01/2017
@version undefined
@param cUni, characters, descricao
@param cCont, characters, descricao
@param nTipo, numeric, descricao
@param nQtd, numeric, descricao
@type function
/*/
//---------------------------------------------------------------------
Function NG400CON(cUni,cCont,nTipo,nQtd)

	If NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)
		If nTipo =2
			If Empty(cCont) .And. !Empty(nQtd)
				MsgStop(STR0189) //  "Informe qual tipo do contador"
				Return .F.
			EndIf
		Else
			If Empty(cUni) .And. !Empty(nQtd)
				MsgStop(STR0190) // "Informe a unidade"
				Return .F.
			EndIf
		EndIf
	Else
		If nTipo =2
			If !Empty(cUni) .And. !Empty(cCont)
				MsgStop(STR0122) //"Não podemos ter garantia controlada por Tempo e Contador!"
				Return .F.
			EndIf
		Else
			If !Empty(cUni) .And. !Empty(cCont)
				MsgStop(STR0122)  //"Não podemos ter garantia controlada por Tempo e Contador!"
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400CHKFIM
Mostra o nome do tipo de insumo
@author Inacio Luiz Kolling
@since 06/08/2001
@version undefined
@param lVld400, logical
@type function
/*/
//---------------------------------------------------------------------
Function NG400CHKFIM(lVld400)

	Local lVldPos  		:= .T.
	Local lVldPos2 		:= .T.
	Local lRet          := .T.
	Local cFilBem		:= ""

	If ExistBlock("NGFINALI")
		If !ExecBlock("NGFINALI",.F.,.F.)
			Return .F.
		EndIf
	EndIf

	//PROB. GERADO  S.S. 014765
	If lVld400 = Nil
		lSoprod := NGINSPRODDH(STJ->TJ_ORDEM,STJ->TJ_PLANO)[1]
	Else
		lSoprod := lVld400
	EndIf

	If lSoprod  // SÓ TEM PRODUTOS
		If M->TJ_DTPRFIM == M->TJ_DTPRINI .And. ( !Empty(M->TJ_HOPRFIM) .And. AllTrim(M->TJ_HOPRFIM) <> ":" ) .And. HTOM(M->TJ_HOPRINI) >= HTOM(M->TJ_HOPRFIM)
			MsgStop(STR0339) //"A 'Ho.Par.Re.I.' não pode ser maior que a 'Ho.Par.Re.F.'"
			Return .F.
		EndIf

		If M->TJ_DTPRFIM == dDataBase
			If HTOM(M->TJ_HOPRFIM) > HTOM(SubStr(Time(),1,5))
				MsgStop(STR0325) //"A "Ho.Par.Re.F." é maior que a hora atual"
				Return .F.
			EndIf
		EndIf

		If DTOS(M->TJ_DTPRFIM) == DTOS(M->TJ_DTPRINI) .And. !Empty(M->TJ_DTPRINI)
			If HTOM(M->TJ_HOPRFIM) <= HTOM(M->TJ_HOPRINI)
				MsgStop(STR0359)
				Return .F.
			EndIf
		EndIf

		If M->TJ_DTMRFIM == dDataBase .And. M->TJ_HORACO1 > SubStr(Time(),1,5) .And. M->TJ_POSCONT > 0
			MsgStop(STR0322) //"Hora do primiero contador não pode ser maior que a data atual"
			Return .F.
		EndIf

		If M->TJ_DTMRINI > dDataBase
			MsgStop(STR0342) //"A 'Dt.Man.Re.I.' não pode ser maior que a data atual."
			Return .F.
		EndIf

		If !Empty(M->TJ_DTMRINI) .And. M->TJ_DTMRINI == M->TJ_DTMRFIM .And. !Empty(M->TJ_HOMRFIM) .And. HTOM(M->TJ_HOMRINI) > HTOM(M->TJ_HOMRFIM)
			MsgStop(STR0345) //"A 'Ho.Man.Re.I.' não pode ser maior que a 'Ho.Ma.Re.F.'"
			Return .F.
		ElseIf M->TJ_DTMRINI == dDataBase .And. HTOM(M->TJ_HOMRINI) > HTOM(SubStr(Time(),1,5))
			MsgStop(STR0346) //"A Ho.Man.Re.I.' não pode ser maior que a hora atual."
			Return .F.
		EndIf

		If M->TJ_DTMRFIM > dDataBase
			MsgStop(STR0343) //"A 'Dt.Man.Re.F.' não pode ser maior que a data atual."
			Return .F.
		ElseIf !Empty(M->TJ_DTMRINI) .And. DTOS(M->TJ_DTMRINI) > DTOS(M->TJ_DTMRFIM)
			MsgStop(STR0341) //"A 'Dt.Man.Re.F.' não pode ser maior que a 'Dt.Man.Re.I."
			Return .F.
		EndIf

		If !Empty(M->TJ_DTMRFIM) .And. M->TJ_DTMRINI == M->TJ_DTMRFIM .And. !Empty(M->TJ_HOMRINI) .And. HTOM(M->TJ_HOMRINI) > HTOM(M->TJ_HOMRFIM)
			MsgStop(STR0347) //"A 'Ho.Man.Re.F.' não pode ser menor que a 'Ho.Man.Re.I.'"
			Return .F.
		ElseIf M->TJ_DTMRFIM == dDataBase .And. HTOM(M->TJ_HOMRFIM) > HTOM(SubStr(Time(),1,5))
			MsgStop(STR0348) //"A 'Ho.Man.Re.F.' não pode ser maior que a hora atual."
			Return .F.
		EndIf

		If !Empty(M->TJ_DTMRINI) .And. DTOS(M->TJ_DTMRINI) < DTOS(M->TJ_DTMPINI)
			If !MsgYesNo(STR0349+"'"+DTOC(M->TJ_DTMPINI)+"'. "+STR0351) //"A 'Dt.Man.Re.I.' é menor que a data prevista inicio , deseja continuar"
				Return .F.
			EndIf
		EndIf

		If !Empty(M->TJ_DTMRFIM) .And. DTOS(M->TJ_DTMRFIM) < DTOS(M->TJ_DTMPFIM)
			If !MsgYesNo(STR0350+"'"+DTOC(M->TJ_DTMPFIM)+"'. "+STR0351) //"A 'Dt.Man.Re.F.' é menor que a data prevista fim , deseja continuar"
				Return .F.
			EndIf
		EndIf

		If !Empty(M->TJ_DTPRINI) .Or. (!Empty(M->TJ_HOPRINI) .And. AllTrim(M->TJ_HOPRINI) <> ":")  .Or. !Empty(M->TJ_DTPRFIM) .Or.;
		(!Empty(M->TJ_HOPRFIM) .And. AllTrim(M->TJ_HOPRFIM) <> ":" )  // Se um dos campos estiverem preenchidos
			If Empty(M->TJ_DTPRINI) .Or. Empty(M->TJ_HOPRINI) .Or. AllTrim(M->TJ_HOPRINI) == ":" .Or. Empty(M->TJ_DTPRFIM) .Or.;
			Empty(M->TJ_HOPRFIM) .Or. AllTrim(M->TJ_HOPRFIM) == ":" // Se um dos campos hora e data estiverem vazio, retorna Falso.
				MsgStop(STR0360)// "Um ou mais campos da data ou hora de parada não foram preenchidos."
				Return .F.
			EndIf
		EndIf

		If !Empty(M->TJ_DTMRINI) .Or. !Empty(M->TJ_HOMRINI) .Or. !Empty(M->TJ_DTMRFIM) .Or. !Empty(M->TJ_HOMRFIM)
			If Empty(M->TJ_DTMRINI) .Or. Empty(M->TJ_HOMRINI) .Or. Empty(M->TJ_DTMRFIM) .Or. Empty(M->TJ_HOMRFIM)
				MsgStop(STR0361)
				Return .F.
			EndIf
		EndIf
	Else

		//----------------------------------------------
		// Valida campos de parada
		//----------------------------------------------
		If !MNT400VPAR()
			Return .F.
		EndIf

	EndIf

	dbSelectArea("TPE")
	dbSetOrder(1)
	If dbSeek(xFilial("TPE")+M->TJ_CODBEM) .And. M->TJ_DTPRFIM = dDataBase
		If M->TJ_HORACO2 > SubStr(Time(),1,5)
			MsgStop(STR0340) //"A Hora do segundo contador não pode ser maior que a hora atual"
			Return .F.
		EndIf
	EndIf

	If !Empty(cBEMRET)
		If Val(STJ->tj_plano) > 0
			dbSelectArea("STF")
			dbSetOrder(1)
			dbSeek(xFilial("STF")+STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA)

			If TIPOACOM .And. M->TJ_POSCONT <= 0 .And. STF->TF_TIPACOM != "T"
				MsgInfo(STR0139+chr(13)+STR0140+chr(13)+STR0141+chr(13)+STR0142,STR0137)
				Return .F.
			Else
				lVldPos := .F.
			EndIf

			If TIPOACOM2 .And. M->TJ_POSCON2 <= 0 .And. STF->TF_TIPACOM == "S"
				MsgInfo(STR0139+chr(13)+STR0140+chr(13)+STR0141+chr(13)+STR0142,STR0137)
				Return .F.
			Else
				lVldPos2 := .F.
			EndIf
		EndIf
	EndIf

	If TIPOACOM
		If !Empty(cBEMRET)

			If !NGCONTRET(M->TJ_DTMRFIM,M->TJ_POSCONT,M->TJ_HORACO1,TIPOACOM  .And. lVldPos,;
				M->TJ_DTMRFIM,M->TJ_POSCON2,M->TJ_HORACO2,TIPOACOM2 .And. lVldPos2,.T.)
				Return .F.
			EndIf

			If M->TJ_POSCONT > 0

				If !NGCHKHISTO(cBEMRET,M->TJ_DTMRFIM,M->TJ_POSCONT,M->TJ_HORACO1,1,,.T.,cFilBem)
					Return .F.
				EndIf

				If !NGVALIVARD(cBEMRET,M->tj_poscont,m->tj_dtmrfim,m->tj_horaco1,1,.T.,,cFilBem)
					Return .F.
				EndIf
			EndIf

			If TIPOACOM2 .And. M->TJ_POSCON2 > 0
				If !NGCHKHISTO(cBEMRET,M->TJ_DTMRFIM,M->TJ_POSCON2,M->TJ_HORACO2,2,,.T.,cFilBem)
					Return .F.
				EndIf

				If !NGVALIVARD(cBEMRET,M->tj_poscon2,m->tj_dtmrfim,m->tj_horaco2,2,.T.,,cFilBem)
					Return .F.
				EndIf
			EndIf
		EndIf
	EndIf

	If ExistBlock("MNTA400F")
		If !ExecBlock("MNTA400F",.F.,.F.)
			Return .F.
		EndIf
	EndIf

	/*-----------------------------+
	| Integração SIGAGFR x SIGALOC |
	+-----------------------------*/
	If SuperGetMV( 'MV_NG1LOC', .F., .F. ) .And.;
		FindFunction( 'LOCM012' )

		lRet := LOCM012()

	EndIf

	If lRet .And. AllTrim(GetNewPar("MV_NGINTER","N")) == "M"  //Mensagem Unica

		lRet := NGMUMntOrd(STJ->(RecNo()),4,.T.)

		If !lRet
			Return .F.
		EndIf

	EndIf

	If lRet .And. cTENDFLAHA == 'S' .And. STJ->TJ_PLANO == "000000" //os corretiva

		If Empty(M->TJ_IRREGU)
			MsgInfo(STR0437) //"O Código da Irregularidade não pode ser vazio."
			Return .F.
		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NGDELINSLAN
Verifica se o insuma tem relacionamento com lancamentos de
contador, caso haja sera excluido os lancamentos (1/2)
@author Inacio Luiz Kolling
@since 06/02/2004
@version undefined
@param cBEMF, characters
@param dVDTIN, date
@param cVHORIN, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGDELINSLAN(cBEMF,dVDTIN,cVHORIN)

	Local IPZ := 0, aCOMOPSTZ := {}

	If STJ->tj_poscont > 0 .Or. STJ->tj_poscon2 > 0
		aCOMOPSTZ := NGCOMPPCONT(cBEMF,dVDTIN,cVHORIN)
		If STJ->tj_poscont > 0
			NGDELCONTLAN(cBEMF,dVDTIN,cVHORIN,1)
			If Len(aCOMOPSTZ) > 0
				For IPZ := 1 To Len(aCOMOPSTZ)
					NGDELCONTLAN(aCOMOPSTZ[IPZ,1],dVDTIN,cVHORIN,1)
				Next IPZ
			EndIf
		EndIf
		If STJ->tj_poscon2 > 0
			NGDELCONTLAN(cBEMF,dVDTIN,cVHORIN,2)
			If Len(aCOMOPSTZ) > 0
				For IPZ := 1 To Len(aCOMOPSTZ)
					NGDELCONTLAN(aCOMOPSTZ[IPZ,1],dVDTIN,cVHORIN,2)
				Next IPZ
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGDELCONTLAN
Deleta o lancamento de contador (1/2) e atualiza as informações
relacionadas ao contador
@author Inacio Luiz Kolling
@since 06/02/2004
@version undefined
@param cVBEMF, characters
@param dVDTINS, date
@param cVHORINS, characters
@param nCTIPO, numeric
@type function
/*/
//---------------------------------------------------------------------
Function NGDELCONTLAN(cVBEMF,dVDTINS,cVHORINS,nCTIPO)

	Local nRECSTP := 0 ,nITENS := GETMV("MV_VARDIA"),aARRSTP := {},nTAMHIS := nITENS
	Local nMAXAR  := 0, nACUMFIM := 0, dDTACUFI := Ctod('  /  /  ')
	Local nCONTAFI := 0, nVARDIFI := 0, IPZ, xz
	Local vVETLAN := If(nCTIPO = 1,{'STP','stp->tp_dtleitu','stp->tp_hora',;
									'stp->tp_acumcon','stp->tp_poscont',;
									'stp->tp_vardia','stp->tp_filial','stp->tp_codbem'},;
									{'TPP','tpp->tpp_dtleit','tpp->tpp_hora',;
									'tpp->tpp_acumco','tpp->tpp_poscon',;
									'tpp->tpp_vardia','tpp->tpp_filial','tpp->tpp_codbem'})

	Local vVETBEM := If(nCTIPO = 1,{'ST9','st9->t9_dtultac','st9->t9_poscont',;
									'st9->t9_contacu','st9->t9_vardia'},;
									{'TPE','tpe->tpe_dtulta','tpe->tpe_poscon',;
									'tpe->tpe_contac','tpe->tpe_vardia'})
	Private aARRSER := {}

	dbSelectArea(vVETLAN[1])
	dbSetOrder(5)
	lULTIMO := .T.
	If dbSeek(xFilial(vVETLAN[1])+cVBEMF+Dtos(dVDTINS)+cVHORINS)
		nRECSTP  := Recno()
		dDATASTP := &(vVETLAN[2])
		hHORASTP := &(vVETLAN[3])
		dbSkip(-1)
		If !EoF() .And. !BoF() .And. &(vVETLAN[7]) = Xfilial(vVETLAN[1]) .And.;
		&(vVETLAN[8]) = cVBEMF
			nACUMFIM := &(vVETLAN[4])
			dDTACUFI := &(vVETLAN[2])
			nCONTAFI := &(vVETLAN[5])
			nVARDIFI := &(vVETLAN[6])
		EndIf

		dbGoto(nRECSTP)
		RecLock(vVETLAN[1],.F.)
		dbDelete()
		MsUnLock(vVETLAN[1])
		dbSkip()
		If !EoF() .And. &(vVETLAN[7]) = Xfilial(vVETLAN[1]) .And. &(vVETLAN[8]) = cVBEMF
			nRECSTP := Recno()
			While !BoF() .And. &(vVETLAN[7]) = Xfilial(vVETLAN[1]) .And.;
			&(vVETLAN[8]) = cVBEMF .And. nITENS > 0
				If !Empty(&(vVETLAN[2]))
					aAdd(aARRSTP,{&(vVETLAN[2]),&(vVETLAN[4]),&(vVETLAN[5])})
					nITENS--
				EndIf
				dbSkip(-1)
			End

			nMAXAR := Len(aARRSTP)+1

			For xz := 1 To Len(aARRSTP)
				aAdd(aARRSER,aARRSTP[nMAXAR-xz])
			Next

			dbSelectArea(vVETLAN[1])
			dbGoto(nRECSTP)
			ProcRegua(Reccount())
			While !EoF() .And. &(vVETLAN[7]) = Xfilial(vVETLAN[1]) .And. &(vVETLAN[8]) = cVBEMF
				IncProc()
				lULTIMO := .F.
				nVARDNOV := NGDCALVAR(cVBEMF,aARRSER,nCTIPO)
				RecLock(vVETLAN[1],.F.)
				&(vVETLAN[4]) := aARRSER[Len(aARRSER)][2]
				&(vVETLAN[6])  := nVARDNOV
				MsUnLock(vVETLAN[1])

				nACUMFIM := &(vVETLAN[4])
				dDTACUFI := &(vVETLAN[2])
				nCONTAFI := &(vVETLAN[5])
				nVARDIFI := &(vVETLAN[6])
				dbSkip()
				If !EoF() .And. &(vVETLAN[7]) = Xfilial(vVETLAN[1]) .And. &(vVETLAN[8]) = cVBEMF
					If Len(aARRSER) < nTAMHIS
						aAdd(aARRSER,{&(vVETLAN[2]),&(vVETLAN[4]),&(vVETLAN[5])})
					Else
						If Len(aARRSER) = nTAMHIS
							Adel(aARRSER,1)
							Asize(aARRSER,Len(aARRSER)-1)
							aAdd(aARRSER,{&(vVETLAN[2]),&(vVETLAN[4]),&(vVETLAN[5])})
						EndIf
					EndIf
				EndIf
			End
			If !Empty(nACUMFIM)
				dbSelectArea(vVETBEM[1])
				dbSetOrder(1)
				If dbSeek(xFilial(vVETBEM[1])+cVBEMF)
					RecLock(vVETBEM[1],.F.)
					If &(vVETBEM[2]) < dDTACUFI
						&(vVETBEM[3]) := nCONTAFI
						&(vVETBEM[4]) := nACUMFIM
						&(vVETBEM[2]) := dDTACUFI
						&(vVETBEM[5]) := nVARDIFI
					ElseIf &(vVETBEM[2]) = dDTACUFI
						&(vVETBEM[3]) := If(&(vVETBEM[3]) <> nCONTAFI,nCONTAFI,&(vVETBEM[3]))
						&(vVETBEM[4]) := If(&(vVETBEM[4]) <> nACUMFIM,nACUMFIM,&(vVETBEM[4]))
						&(vVETBEM[5]) := nVARDIFI
					EndIf
					MsUnLock(vVETBEM[1])
				EndIf
			EndIf
		EndIf
		If lULTIMO
			If !Empty(nACUMFIM)
				dbSelectArea(vVETBEM[1])
				dbSetOrder(1)
				If dbSeek(xFilial(vVETBEM[1])+cVBEMF)
					RecLock(vVETBEM[1],.F.)
					&(vVETBEM[3]) := nCONTAFI
					&(vVETBEM[4]) := nACUMFIM
					&(vVETBEM[2]) := dDTACUFI
					&(vVETBEM[5]) := nVARDIFI
					MsUnLock(vVETBEM[1])
				EndIf
			EndIf
		EndIf
	EndIf
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGDCALVAR
Atualiza historico de contador (Variacao dia)
@author Inacio Luiz Kolling
@since 31/07/2003
@version undefined
@param cVBEMLI, characters, Codiog do bem              - Obrigatorio
@param aVARR, array, Array com os contadore acumulados - Obrigatorio
@param nVTIP, numeric, Tipo do contador (1/2)          - Obrigatorio
@type function
/*/
//---------------------------------------------------------------------
Function NGDCALVAR(cVBEMLI,aVARR,nVTIP)

	Local cALIOLD  := Alias(), nVARD1 := 1, nCONTATU := 0,nCONTANT := 0,nDIFER := 0
	Local nLIMIST9 := If(nVTIP = 1,NGSEEK("ST9",cVBEMLI,1,"T9_LIMICON"),;
	NGSEEK("TPE",cVBEMLI,1,"TPE_LIMICO"))
	If Len(aVARR) > 1
		nCONTATU := aVARR[Len(aVARR)][3]
		nCONTANT := aVARR[Len(aVARR)-1][3]
		If nCONTATU < nCONTANT
			nDIFER := (nLIMIST9 - nCONTANT)+nCONTATU
		Else
			nDIFER := nCONTATU - nCONTANT
		EndIf
		aVARR[Len(aVARR)][2] := aVARR[Len(aVARR)-1][2] + nDIFER
		nVARD1 := Round ( (aVARR[Len(aVARR),2] - aVARR[1,2]) / (aVARR[Len(aVARR),1] - aVARR[1,1]) ,0)
		nVARD1 := If(nVARD1 == 0,1,nVARD1)
	EndIf
	dbSelectArea(cALIOLD)

Return nVARD1

//----------------------------------------------------------------------------
/*/{Protheus.doc} NGQUANTCHK
Pre-consistencia da quantidade do insumo

@return lRet  , Lógico  , Valor que verifica a integridade
@param  nPosAt, Numerico, Valor da linha atual do getdados. (oGet:nAt)

@sample
NGQUANTCHK()

@author Elynton Fellipe Bazzo
@since 21/07/2014
@version 1.0
/*/
//----------------------------------------------------------------------------
Function NGQUANTCHK(nPosAt)

	Local lRet			:= .T.
	Local nTipReg		:= aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_TIPOREG" })
	Local nUnidad		:= aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_UNIDADE" })
	Local nQtdade		:= aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_QUANTID" })
	Local nUsaCale	    := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_USACALE" })

	Default nPosAt := n

	If IsInCallStack( "NG400FIM" ) //Se executado pela rotina de Retorno.
		If !NGVALQUANT( aCols[nPosAt][nTipReg],aCols[nPosAt][nUnidad],aCols[nPosAt][nQtdade],.T.,aCols[nPosAt][nUsaCale] )
			lRet := .F.
		EndIf
	Else
		If !NGVALQUANT( M->TL_TIPOREG,M->TL_UNIDADE,M->TL_QUANTID,.T.,M->TL_USACALE )
			lRet := .F.
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NGTLDTINS
Valida a Data inicio e fim do insumo.
@author Taina A. Cardoso
@since 10/01/11
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGTLDTINS()

	nHORA   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_HOFIM"  })
	nHORAIN := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_HOINICI"  })
	nDtIni  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTINICI"})
	nDtFim  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTFIM"  })

	// Se for chamada a Rotina de  O.S Corretiva. Vai ser apresentada a mensagem de validacao no calendario do funcionario.
	If IsInCallStack("MNTA231") .Or. IsInCallStack("MNTA232")
		If DTOS(M->TL_DTINICI) > DTOS(dDataBase)
			MsgStop(STR0328)
			Return .F.
		EndIf
	EndIf

	If IsInCallStack("NG400FIM")
		If DTOS(M->TL_DTINICI) > DTOS(aCols[n][nDtFim]) .And. !Empty(aCols[n][nDtFim])
			MsgStop(STR0362)
			Return .F.
		EndIf
	EndIf

Return .T.

//----------------------------------------------------------------------------
/*/{Protheus.doc} NGSTLHORIN
Consistencia da hora inicio do insumo.
@type function

@author Inácio Luiz Kolling
@since 10/02/2004

@sample NGSTLHORIN( 1, oGet:aCols() )

@param [nLine]   , Numérico, Número da linha da getdados que será validada.
@param [aColsVld], Array   , aCols para validação.
@return .T.
/*/
//----------------------------------------------------------------------------
Function NGSTLHORIN( nLine, aColsVld )

	Local dDataini   := Ctod('  /  /  ')
	Local cCodCal    := ''
	Local cCodFun    := ''
	Local cTipoReg   := ''

	Default nLine    := 0
	Default aColsVld := {}

	If IsInCallStack( "MNTA435" ) .Or. IsInCallStack( "MNTA295" ) .Or. IsInCallStack( "MNTA990" ) .Or.;
	   IsInCallStack( "MNTA420" ) .Or. IsInCallStack( "MNTA265" ) .Or. IsInCallStack( "MNTA415" )

		nLine    := IIf( nLine == 0, n, nLine )
		aColsVld := IIf( Empty( aColsVld ), aCols, aColsVld )

		nCod	 := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_CODIGO" })
		nHORA    := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_HOFIM"  })
		nHORAIN  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_HOINICI"})
		nDtIni   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTINICI"})
		nDtFim   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTFIM"  })
		nTipoR   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TIPOREG"})

		cTipoReg := aColsVld[nLine][nTipoR]

		If IsInCallStack( "MNTA990" )
			cCodFun  := aColsVld[nLine][nCod]   //Código Funcionário
			dDataini := aColsVld[nLine][nDtini] //Data Início
		EndIf

	ElseIf IsInCallStack( "NG480HOINI" )
		cCodFun  := M->TL_CODIGO //Código Funcionário
		dDataini := M->TL_DTINICI //Data Início
	Else
		cCodFun  := M->TL_CODIGO
		dDataini := M->TL_DTINICI
		dDataFim := M->TL_DTFIM
		cHoraIni := M->TL_HOINICI
		cHoraFim := M->TL_HOFIM
	EndIf

	If M->TL_TIPOREG == "M" .And. ( Empty(cTipoReg) .Or. cTipoReg == "M" ) //Se o tipo de registro for igual a 'Mão de Obra'.
		If M->TL_USACALE == "S" //Se utiliza calendário
			If !Empty( M->TL_HOINICI ) .And. !Empty( dDataini )// Se a hora e a data(get dados) inicial estiverem preenchidos
				If GetNewPar( "MV_NGFLUT","N" ) == "S" //Verificar turno flutuante
					cCodCal := MNTCALFLU( cCodFun,dDataini,dDataini )
					If Empty( cCodCal ) //Se o funcionário não estiver relacionado à uma equipe de manutenção
						cCodCal := NGSEEK("ST1",Substr( cCodFun,1,6),1,"T1_TURNO")
					EndIf
				Else
					cCodCal := NGSEEK("ST1",Substr( cCodFun,1,6),1,"T1_TURNO")
				EndIf
				If !NGVALHRCALE( cCodCal,dDataini,M->TL_HOINICI,"I" )
					Return .F.
				EndIf
			ElseIf IsInCallStack( "MNTA415" )
				If !Empty( M->TL_HOINICI ) .And. !Empty( aColsVld[nLine][nDtini] ) .And. Empty( aColsVld[nLine][nCod] )
					MsgInfo(STR0435) //"Deve ser informado o código do funcionário."
					Return .F.
				EndIf
			EndIf
		EndIf
	ElseIf M->TL_TIPOREG = "P"
		M->TL_DTFIM := M->TL_DTINICI
		M->TL_HOFIM := M->TL_HOINICI
	EndIf

	If cPrograma <> "MNTA480"
		MNT400CHKGAR()
		MNT400PCKGAR()
	EndIf

	If IsInCallStack( 'MNTA400A' ) .Or. IsInCallStack( 'NG480HOINI' )

		If M->TL_DTINICI == dDataBase .And. !Empty( M->TL_HOINICI )

			If HTOM(M->TL_HOINICI) > HTOM(Substr(Time(),1,5))
				MsgStop(STR0330) //"A Hora inicio não pode ser  maior que a hora atual."
				Return .F.
			EndIf

		EndIf

	EndIf

	If IsInCallStack("NG400FIM") .And. !IsInCallStack("NG480HOINI")

		nLine    := IIf( nLine == 0, n, nLine )
		aColsVld := IIf( Empty( aColsVld ), aCols, aColsVld )

		nHORA    := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_HOFIM"  })
		nHORAIN  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_HOINICI"})
		nDtIni   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTINICI"})
		nDtFim   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTFIM"  })
		nTipoR   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TIPOREG"})

		If aColsVld[nLine][nTipoR] == 'P'
			aColsVld[nLine][nHORA]  := M->TL_HOINICI
			aColsVld[nLine][nDtFim] := aColsVld[nLine][nDtIni]
		EndIf

		If aColsVld[nLine][nDtIni] == aColsVld[nLine][nDtFim] .And. !Empty( aColsVld[nLine][nHORA] ) .And. !Empty( aColsVld[nLine][nHORAIN] ) .And. M->TL_HOINICI > aColsVld[nLine][nHORA]
			MsgStop( STR0338 ) //Hora inicio não pode ser maior ou igual a hora fim.
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGSTLHORFI
Consistencia da hora Fim do insumo
@type function

@author Inacio Luiz Kolling
@since 10/02/2004

@return lRet, Lógica, Retorna a condição da verificação.
/*/
//---------------------------------------------------------------------
Function NGSTLHORFI()

	Local lRet := .T.
	Local lFlut := GetNewPar("MV_NGFLUT","N") == "S"

	Local cCodIns  := ''
	Local cUsaCale := ''
	Local cTipReg  := ''
	Local dDataFim := cToD('  /  /   ')
	Local choraFi  := ''

	hINI := HToM( M->TL_HOINICI )

	// Caso hora fim não tenha sido informado.
	If Empty( StrTran( M->TL_HOFIM, ':' ) )

		MsgStop( STR0439 ) // É necessário informar uma hora fim para o insumo.
		lRet := .F.

	Else

		hFim := HToM( M->TL_HOFIM )

		If !IsInCallStack("NG480HOFIM")
			nHORA    := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_HOFIM"  })
			nHORAIN  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_HOINICI"})
			nDtIni   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTINICI"})
			nDtFim   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTFIM"  })
			nTIPOREG := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TIPOREG"})
			nCalend  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_USACALE"})
			nCodTl   := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_CODIGO" })
		EndIf

		If IsInCallStack("NG400FIM") .And. !IsInCallStack("NG480HOFIM")
			If aCols[n][nDtIni] = aCols[n][nDtFim] .And. !Empty(aCols[n][nHORAIN]) .And. HTOM(M->TL_HOFIM) == HTOM(aCols[n][nHORAIN]) .And. aCols[n][nTIPOREG] <> "P"
				MsgStop(STR0332) //"Hora fim não pode ser menor ou igual a hora inicio."
				lRet := .F.
			EndIf
		EndIf

		If ( IsInCallStack( 'MNTA400A' ) .Or. IsInCallStack( 'NG480HOFIM' ) ) .And. lRet

			If M->TL_DTINICI = M->TL_DTFIM .And. !Empty(M->TL_HOINICI) .And. hFIM = hINI .And. M->TL_TIPOREG <> "P"
				MsgStop(STR0332) //"Hora fim não pode ser menor ou igual a hora inicio."
				lRet := .F.
			ElseIf M->TL_DTINICI = M->TL_DTFIM .And. !Empty(M->TL_HOINICI) .And.  hFIM < hINI
				MsgStop(STR0332) //"Hora fim não pode ser menor ou igual a hora inicio."
				lRet := .F.
			EndIf

		EndIf

		If lRet

			If !IsInCallStack("MNTA231FIN") .And. !IsInCallStack("NG400FIM") .And. !IsInCallStack("MNTA990")
				cCodIns  := M->TL_CODIGO
				cUsaCale := M->TL_USACALE
				cTipReg  := M->TL_TIPOREG
				dDataFim := M->TL_DTFIM
				choraFi  := M->TL_HOFIM
			Else
				cCodIns  := aCols[n][nCodTl]
				cUsaCale := aCols[n][nCalend]
				cTipReg  := aCols[n][nTIPOREG]
				dDataFim := aCols[n][nDtFim]
				choraFi  := IIf( ReadVar() == 'M->TL_HOFIM', M->TL_HOFIM, aCols[n,nHORA] )
			EndIf

			If cTipReg = "M"
				If cUsaCale = "S"
					If lFlut
						cCODCAL := MNTCALFLU(cCodIns,dDataFim,dDataFim)
					Else
						cCODCAL := NGSEEK("ST1",Substr(cCodIns,1,6),1,"T1_TURNO")
					EndIf
					If !NGVALHRCALE(cCODCAL,dDataFim,choraFi,"F")
						lRet := .F.
					EndIf
				EndIf
			EndIf

		EndIf

		If !IsInCallStack("MNTA990") .And. dDataBase == M->TL_DTFIM .And. ;
				!Empty(M->TL_HOFIM) .And. HTOM(M->TL_HOFIM) > HTOM(Substr(Time(),1,5)) .And. lRet

			MsgStop(STR0331) //"Hora fim não pode ser menor que a hora atual."
			lRet := .F.

		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NGCALQUANT
Consistencia da quantidade do insumo
@author Inacio Luiz Kolling
@since 10/02/2004
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGCALQUANT()

	Local cCALFUNC := Space(len(sh7->h7_codigo))
	Local nQTDCOLS := 0 , nUNICOLS := 0

	If M->TL_TIPOREG <> 'P'
		If M->TL_TIPOREG = 'M'
			If GetNewPar("MV_NGFLUT","N") == "S" .And. !Empty(M->TL_DTFIM)
				cCALFUNC := MNTCALFLU(M->TL_CODIGO,M->TL_DTFIM,M->TL_DTFIM)
			Else
				cCALFUNC := NGSEEK('ST1',Substr(M->TL_CODIGO,1,6),1,"T1_TURNO")
			EndIf
		EndIf
		M->TL_QUANTID := NGQUANTIHOR(M->TL_TIPOREG,M->TL_UNIDADE,M->TL_DTINICI,;
		M->TL_HOINICI,M->TL_DTFIM,M->TL_HOFIM,;
		M->TL_USACALE,cCALFUNC)
		M->TL_UNIDADE := "H"

		If Valtype(aheader) = "A"
			nQTDCOLS := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANTID" })
			nUNICOLS := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_UNIDADE" })
			If nQTDCOLS > 0
				aCOLS[n][nQTDCOLS] := M->TL_QUANTID
			EndIf
			If nUNICOLS > 0
				aCOLS[n][nUNICOLS] := M->TL_UNIDADE
			EndIf
		EndIf
		lREFRESH := .T.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGFECHASS
Fechamento de uma S.S. vinculada a uma ordem de servico
@author Inacio Luiz Kolling
@since 27/09/2004
@version undefined
@param cVORDFSS, characters, Numero da ordem de servico  - Obrigatorio
@param lMsgTela, logical, Apresenta mensagem (erro) em tela?
@type function
/*/
//---------------------------------------------------------------------
Function NGFECHASS(cVORDFSS,lMsgTela)

	Local cSolici
	Local aOldNGBtn
	Local nOS     := 0
	Local aAreaSS := GetArea()
	Local cMsg    := ""
	Local lFinSS  := .T. // Váriavel que define se apresentará a tela de finalização da SS - É mudada apenas no PE MNTA400N

	Private aNgButton

	Default lMsgTela := .F.

	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek(xFilial("STJ")+cVORDFSS)

	If AllTrim(GetNewPar("MV_NGSSWRK","N")) == "S"
		If AllTrim(GetNewPar("MV_NGMULOS","N")) <> "S"
			dbSelectArea("TQB")
			dbSetOrder(04)
			If dbSeek(xFilial("TQB")+cVORDFSS)
				MNW29502(TQB->TQB_CDSOLI)
			EndIf
		Else
			dbSelectArea("TT7")
			dbSetOrder(2)
			If dbSeek(xFilial("TT7")+cVORDFSS)
				dbSelectArea("TQB")
				dbSetOrder(1)
				dbSeek(xFilial("TQB")+TT7->TT7_SOLICI)
				MNW29502(TQB->TQB_CDSOLI)
			EndIf
		EndIf
	EndIf

		aOldNGBtn := If(Type("aNGButton") == "A",ACLONE(aOldNGBtn),{})
		aNgButton := {}

		If ExistBlock("MNTA4012")
			ExecBlock("MNTA4012",.F.,.F.)
		ElseIf !Empty(cVORDFSS)
			If AllTrim(GetNewPar("MV_NGMULOS","N")) <> "S"
				dbSelectArea("TQB")
				dbSetOrder(04)
				If dbSeek(xFilial("TQB")+cVORDFSS)
					If TQB->TQB_SOLUCA == "D"

						//Ponto de entrada para não apresentar tela de finalização de SS.
						If ExistBlock("MNTA400N")
							lFinSS := ExecBlock("MNTA400N",.F.,.F.)
						EndIf

						If lFinSS
							MNTA290FEC(STR0149+" "+cVORDFSS, 3)
						EndIf

					Else
						cMsg := "'"+NGRETTITULO("TQB_SOLUCA")+"' "+STR0313+cVORDFSS+STR0314+" '"+NGRETSX3BOX("TQB_SOLUCA","D")+"'."  //"da SS "##" não está como"
					EndIf
				Else
					cMsg := STR0315+cVORDFSS+"."  //"Não existe SS para a OS "
				EndIf
			Else
				dbSelectArea("TT7")
				dbSetOrder(2)
				If dbSeek(xFilial("TT7")+cVORDFSS)
					cSolici := TT7->TT7_SOLICI
					RecLock("TT7",.F.)
					TT7->TT7_TERMIN := "S"
					MsUnLock("TT7")

					dbSelectArea("TT7")
					dbSetOrder(1)
					dbSeek(xFilial("TT7")+cSolici)
					While !EoF() .And. TT7->TT7_FILIAL == xFilial("TT7") .And. TT7->TT7_SOLICI == cSolici
						dbSelectArea("STJ")
						dbSetOrder(1)
						dbSeek(xFilial("STJ")+TT7->TT7_ORDEM)
						If STJ->TJ_TERMINO == "N"
							nOS++
						EndIf
						dbSelectArea("TT7")
						dbSkip()
					End
					If nOs == 0
						dbSelectArea("TQB")
						dbSetOrder(01)
						If dbSeek(xFilial("TQB")+cSolici)
							If TQB->TQB_SOLUCA = "D"

								//Ponto de entrada para não apresentar tela de finalização de SS.
								If ExistBlock("MNTA400N")
									lFinSS := ExecBlock("MNTA400N",.F.,.F.)
								EndIf

								If lFinSS
									MNTA290FEC(STR0149+" "+cSolici, 3)
								EndIf

							EndIf
						EndIf
					Else
						cMsg := STR0316+cSolici+"."  //"Ainda existe ao menos uma O.S. não terminada para a SS "
					EndIf
				Else
					cMsg := STR0317+cVORDFSS+"."  //"Não existe SS para a OS "
				EndIf
			EndIf
		EndIf

		If lMsgTela .And. !Empty(cMsg)
			MsgInfo(cMsg)
		EndIF

		aNgButton := aClone(aOldNGBtn)

	RestArea(aAreaSS)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA400EFI
Consistencia final das etapas e respostas
@author Inacio Luiz Kolling
@since 22/02/2005
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA400EFI()

	dbSelectArea(cTRBQ400)
	dbGotop()
	While !EoF()
		If !Empty((cTRBQ400)->TQ_OK)
			dbSelectArea("TPA")
			dbSetOrder(1)
			If dbSeek(xFilial("TPA")+(cTRBQ400)->TQ_ETAPA)
				If TPA->TPA_OPCOES <> "0"
					dbSelectArea(cTRB3400)
					dbSetOrder(1)
					If dbSeek((cTRBQ400)->TQ_ETAPA)
						lREPOS := .F.
						While !EoF() .And. (cTRB3400)->TPC_ETAPA = (cTRBQ400)->TQ_ETAPA
							If !Empty((cTRB3400)->TPC_OK)
								lREPOS := .T.
								Exit
							EndIf
							dbSkip()
						End
						If !lREPOS
							MsgInfo(STR0151+" "+(cTRBQ400)->TQ_ETAPA+"  "+STR0115+" "+(cTRBQ400)->TQ_TAREFA,STR0137)
							Return .F.
						EndIf
					Else
						dbSelectArea("TPQ")
						dbSetOrder(1)
						If !dbSeek(xFilial("TPQ")+STJ->TJ_ORDEM+STJ->TJ_PLANO+(cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA)
							MsgInfo(STR0151+" "+(cTRBQ400)->TQ_ETAPA+"  "+STR0115+" "+(cTRBQ400)->TQ_TAREFA,STR0137)
							Return .F.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		dbSelectArea(cTRBQ400)
		dbSkip()
	End

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de Menu Funcional.
@type static

@author	Ricardo Dal Ponte
@since	29/11/2006

@return Array,  [1] - Nome que é apresentado no cabeçalho.
				[2] - Nome da rotina associada.
				[3] - Reservado.
				[4] - Tipo de transação a ser efetuada.
				[5] - Nível de acesso.
				[6] - Habilita menu funcional.
/*/
//---------------------------------------------------------------------
Static Function MenuDef()

	Local lPyme      := Iif(Type("__lPyme") <> "U",__lPyme,.F.)
	Local aROTINA    := {}
	Local cUsaIntCom := AllTrim( GetMv( "MV_NGMNTCM" ))
	Local lCervPetro := .F.

	If ExistBlock("MNTA4008")
		aROTINA := ExecBlock("MNTA4008",.F.,.F.)
		Return(aRotina)
	Else
		//SS: 027154 - Segundo parametro de insumo alterado de 3-Incluir, para 4-Alterar, para que ao incluir um insumo, não apresenta a tela
		//de seleção de filial. Sempre usando a filial da OS a ter insumo adicionado.

		aRotina := { { STR0004, 'PesqBrw'    , 0, 1        },; // Pesquisar
					 { STR0005, 'NGCAD01'    , 0, 2        },; // Visualizar
					 { STR0007, 'MNTA400A'   , 0, 4, , .F. },; // Insumos
					 { STR0006, 'NG400FIM'   , 0, 4        },; // Final
					 { STR0008, 'NG400ETA'   , 0, 4        },; // EtApas
					 { STR0221, 'NG400EXC'   , 0, 5, 3     },; // Cancelar
					 { STR0204, 'NG400MOT'   , 0, 4, , .F. },; // Mot. Atraso
					 { STR0010, 'NG400LEG'   , 0, 4, , .F. },; // Legenda
					 { STR0044, 'MNT400IMP()', 0, 4        },; // Imprimir
					 { STR0237, 'MNT400ROD'  , 0, 4        },; // Rodízio
					 { STR0306, 'MNTA402'    , 0, 4        };  // Rateio
					}

		If ExistBlock("MNTA400I")
			aRotina:= ExecBlock("MNTA400I",.F.,.F.,{aRotina})
		EndIf

		If cUsaIntCom == "S"
			aAdd(aROTINA,{STR0301,"MNTC290(STJ->TJ_ORDEM)"  ,0,4}) //"Sol. Compra"
		EndIf
	EndIf

	If ExistBlock("MNTA4005")
		aAdd(aROTINA,{STR0177,"NG400BOT", 0, 7})  //"Consulta"
	EndIf

	If ExistBlock("CER1A050")
		lCervPetro := .T.
		aAdd (aRotina, {STR0197,"U_MNTA425R('S')", 0, 6}) //"Reprogramar"
		aAdd (aRotina, {STR0195, "U_CER1A050()", 0, 8}) //"Status"
	EndIf

	If ExistBlock("MRB1A001")
		aAdd(aROTINA,{STR0197,"U_MRB1A001()", 0, 9})  //"Reprogramar"
	EndIf

	If !lPyme
		aAdd( aRotina, { STR0152, "MsDocument", 0, 4 } )//"Conhecimento"
	EndIf

Return aRotina

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400BOT
Botao que chama o ponto de entrado do cliente, tratado como
um botao para consultas
@author Elisangela Costa
@since 04/12/2006
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG400BOT()

	Local nINDSTJ := 0, nRECSTJ := 0
	Local OLDROT  := aCLONE(aROTINA)
	Local OLDCCAS := cCADASTRO

	If ExistBlock("MNTA4005")

		dbSelectArea("STJ")
		nINDSTJ := IndexOrd()
		nRECSTJ := Recno()
		dbSetOrder(1)

		Set Filter to
		ExecBlock("MNTA4005",.F.,.F.)

		dbSelectArea("STJ")
		If Type("aIndSTJ") == "A" .And. Type("cCondicao") == "C"
			bFiltraBrw := {|| FilBrowse("STJ",@aIndSTJ,@cCondicao) }
			Eval(bFiltraBrw)
		EndIf
		dbGoto(nRECSTJ)
		dbSetOrder(nINDSTJ)

		cCADASTRO := OLDCCAS
		aROTINA   := aCLONE(OLDROT)
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGFILHO
Cria um vetor com os componente da estrutura da OS
@author Marcos Wagner Junior
@since 21/02/07
@version undefined
@param cVPAI, characters, Codigo da OS Pai - Obrigatório
@return aEstru - Vetor contendo os elementos da estrutura
@type function
/*/
//---------------------------------------------------------------------
Function NGFILHO(cVPAI)

	Local cALIASOL := ALIAS()
	Local nORDEROL := IndexOrd()

	Private aESTRU := {}
	Private cFilStc  := xFilial("ZZ9")

	dbSelectArea("ZZ9")
	dbSetOrder(1)
	If dbSeek(cFilStc+cVPAI)
		NGFILPROC(cVPAI)
	EndIf

	If !Empty(cALIASOL)
		dbSelectArea(cALIASOL)
	EndIf

	If !Empty(nORDEROL)
		dbSetOrder(nORDEROL)
	EndIf

Return aESTRU

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³NGFILPROC   ³ Autor ³Marcos Wagner Junior ³ Data ³ 21/02/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Monta vetor                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      |NGFILHO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
//---------------------------------------------------------------------
/*/{Protheus.doc} NGFILPROC
Monta vetor
@author Marcos Wagner Junior
@since 21/02/07
@version undefined
@param cVPAI, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGFILPROC(cVPAI)

	While !EoF() .And. ZZ9->ZZ9_FILIAL == cFilStc .And.;
	ZZ9->ZZ9_ORDPAI == cVPAI

		nRec1    := Recno()
		cFILHO    := ZZ9->ZZ9_ORDFIL
		aAdd(aESTRU,cFILHO)
		If dbSeek(cFilStc+cFILHO)
			NGFILHOFIL(cFILHO)
		EndIf

		dbGoTo(nRec1)
		dbSkip()
	End

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGFILHOFIL
Inclui os elementos filhos no vetor
@author Marcos Wagner Junior
@since 21/02/07
@version undefined
@param cVCOMP, characters, descricao
@type function
/*/
//---------------------------------------------------------------------
Function NGFILHOFIL(cVCOMP)

	Local nRec2

	While !EoF() .And. ZZ9->ZZ9_FILIAL == cFilStc .And.;
	ZZ9->ZZ9_ORDPAI == cVCOMP

		nRec2 := Recno()
		cFILHO := ZZ9->ZZ9_ORDFIL

		aAdd(aESTRU,cFILHO)

		dbSelectArea("ZZ9")
		If dbSeek(cFilStc+cFILHO)
			NGFILHOFIL(cFILHO)
		EndIf

		dbGoTo(nRec2)
		dbSkip()
	End

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400INC
Inclui um PI
@author Marcos Wagner Junior
@since 28/05/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
User Function NG400INC()

	aVARNAO := {'ZZ7_DTISOL','ZZ7_HRISOL','ZZ7_REISOL','ZZ7_DTEXAR','ZZ7_HREXAR','ZZ7_RESEXA',;
				'ZZ7_DTENC' ,'ZZ7_HRENC' ,'ZZ7_RESENC','ZZ7_DTNOR' ,'ZZ7_HRNOR' ,'ZZ7_RESNOR',;
				'ZZ7_APROV' ,'ZZ7_RESAPR','ZZ7_DTAPRO','ZZ7_DTRINI','ZZ7_HRRINI','ZZ7_DTRFIM','ZZ7_HRRFIM'}

	aCHOICE  := NGCAMPNSX3("ZZ7",aVarNao)

	If Type("Inclui") <> "U"
		Inclui := .T.
		IncluiOld := Inclui
	EndIf
	dbSelectArea("ZZ7")
	dbSetOrder(01)
	If !dbSeek(xFilial("ZZ7")+STJ->TJ_ORDEM+STJ->TJ_PLANO)
		NGCAD01("ZZ7",Recno(),3)
	Else
		MsgStop(STR0198,STR0025)	//"Já existe P.I. para esta Ordem de Serviço!" #"Atenção"
		Return .F.
	EndIf
	Inclui := IncluiOld

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA400INC
Inclusao de Status da OS
@author Marcos Wagner Junior
@since 24/08/07
@version undefined
@param cALIAS, characters
@param nREG, numeric
@param nOPCX, numeric
@type function
/*/
//---------------------------------------------------------------------
Function MNTA400INC(cALIAS,nREG,nOPCX)

	Local aAreaOld := GetArea()
	Local OldRot   := aClone(aRotina)
	Local nRet
	Local cOldStatus := STJ->TJ_STATUS
	Local lGrava := .T.
	lTelaEtapa   := .F.

	aRELAC  := {{'TJ_ORDEM' ,'STJ->TJ_ORDEM'},;
				{'TJ_STATUS','STJ->TJ_STATUS'}}

	aCHOICE  := {'TJ_ORDEM','TJ_STATUS','TJ_DESTAT'}

	nRet := NGCAD01("STJ",Recno(),4)

	If nRet = 1
		If	STJ->TJ_STATUS = '30'
			If !NG400FIM(cALIAS,nREG,nOPCX)
				lGrava := .F.
				dbSelectArea('STJ')
				RecLock('STJ',.F.)
				STJ->TJ_STATUS := cOldStatus
				MsUnLock('STJ')
			EndIf
		EndIf
		If lGrava
			dbSelectArea('TRE')
			RecLock('TRE',.T.)
			TRE->TRE_FILIAL := xFilial("TRE")
			TRE->TRE_ORDEM  := STJ->TJ_ORDEM
			TRE->TRE_DTALT  := dDATABASE
			TRE->TRE_HRALT  := TIME()
			TRE->TRE_STATUS := STJ->TJ_STATUS
			TRE->TRE_LOGIN  := If(Len(TRE->TRE_LOGIN) > 15,cUsername,Substr(cUsuario,7,15))
			MsUnLock('TRE')
		EndIf
	EndIf
	aRotina := aClone(OldRot)
	RestArea(aAreaOld)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400STA
Validacao de Alteracao de Status
@author Marcos Wagner Junior
@since 26/09/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
User Function NG400STA()

	If !(Upper(AllTrim(cUsername)) $ Upper(AllTrim(GETMV("MV_NGUSUAL")))) .And. M->TJ_STATUS = '30'
		MsgStop(STR0192,STR0025)	//"Usuário não autorizado para encerrar a O.S." #"Atenção"
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400VIS
Visualizacao dos insumos
@author Elisangela Costa
@since 15/03/2007
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT400VIS()

	Local aOldChoice := IIf( Type("aChoice") == "A", aClone(aChoice), Nil)

	aChoice := Nil

	M->TL_TIPOREG := STL->TL_TIPOREG
	aHeader  := {}
	aTrocaF3 := {}
	VERDESTINO(.T.)

	If Val(STL->TL_PLANO) == 0 .And. NGUSATARPAD()
		aAdd(aTrocaF3,{"TL_TAREFA","TT9"})
	EndIf

	NGCAD01("STL",Recno(),2)
	aTrocaF3 := {}

	aChoice := aOldChoice

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} A400STJBUS
Busca Ordens de servico com status de terceiros para um determinado bem
@author Ricardo Dal Ponte
@since 03/05/2007
@version undefined
@param cBEMSTJ, characters
@type function
/*/
//---------------------------------------------------------------------
Function A400STJBUS(cBEMSTJ)

	Local cAliasQry := GetNextAlias()
	Local cQuerySTJ := ""
	Local lSTJAchou := .F.

	cQuery := " SELECT COUNT(TJ_CODBEM) QUANT FROM " + RetSqlName("STJ")
	cQuery += " 	WHERE TJ_CODBEM = " + ValToSql(cBEMSTJ) + " AND TJ_TIPOOS = 'B' "
	cQuery += "		AND TJ_FILIAL = " + ValToSQL(xFilial("STJ"))
	cQuery += "		AND TJ_SITUACA <> 'C' AND TJ_TERMINO = 'N' "
	cQuery += "		AND TJ_TERCEIR = '2' AND D_E_L_E_T_ <> '*' "

	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

	If (cAliasQry)->QUANT > 0
		lSTJAchou := .T.
	EndIf

	(cAliasQry)->(DbCloseArea())

Return lSTJAchou

//---------------------------------------------------------------------
/*/{Protheus.doc} M400STNTUD
Valida todos os itens da getdados de Ocorrencias
@author Elisangela Costa
@since 13/08/2007
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function M400STNTUD()

	Local vx := 0
	hINI := HtoM(M->TL_HOINICI)
	hFIM := HtoM(M->TL_HOFIM)

	If M->TL_DTINICI = M->TL_DTFIM .And. hFIM = hINI .And. M->TL_TIPOREG <> "P"
		MsgStop(STR0332) //"Hora fim não pode ser menor ou igual a hora inicio."
		Return .F.
	ElseIf M->TL_DTINICI = M->TL_DTFIM .And. hFIM < hINI
		MsgStop(STR0332) //"Hora fim não pode ser menor ou igual a hora inicio."
		Return .F.
	EndIf

	For vx := 1 To Len(aCols)
		If !M400GETDO(vx)
			Return .F.
		EndIf
	Next vx

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} M400STNLIN
Valida a linha da getdados das ocorrencias
@author Elisangela Costa
@since 13/08/2007
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function M400STNLIN()

	If !M400GETDO(n)
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} M400GETDO
Consiste a linha de GetDados das ocorrências.
@type Function

@author Elisangela Costa
@since 13/08/2007

@param nLin    , integer , Número da linha na GetDados.

@return boolean, Indica se a linha está valida.
/*/
//---------------------------------------------------------------------
Function M400GETDO( nLin )

	Local lRet     := .T.
	Local nQtd     := 0
	Local nInd1    := 0
	Local nMax     := Len(aCols[nLin])
	Local nOCORRE  := GDFieldPos( 'TN_CODOCOR' )
	Local nCAUSA   := GDFieldPos( 'TN_CAUSA' )
	Local nSOLUCAO := GDFieldPos( 'TN_SOLUCAO' )
	Local nDESCRIC := GDFieldPos( 'TN_DESCRIC' )
	Local nPosTar  := GDFieldPos( 'TN_TAREFA' )
	Local cOCORRE  := aCols[nLin][nOCORRE]
	Local cCAUSA   := aCols[nLin][nCAUSA]
	Local cSOLUCAO := aCols[nLin][nSOLUCAO]
	Local cDESCRIC := aCols[nLin][nDESCRIC]
	Local cCodTar  := '0'

	If nOCORRE == 0 .Or. nCAUSA == 0 .Or. nSOLUCAO == 0 .Or. nDESCRIC == 0
		Return .T.
	EndIf

	If Len(aCOLS) == 1
		If aCOLS[1][Len(aCOLS[1])]
			Return .T.
		EndIf
	EndIf

	If nPosTar > 0

		If Empty( aCols[nLin,nPosTar] ) .And. Empty( cOCORRE ) .And. Empty( cCAUSA ) .And.;
			Empty( cSOLUCAO ) .And. Empty( cDESCRIC )

			Return .T.

		EndIf

	Else

		If Empty( cOCORRE ) .And. Empty( cCAUSA ) .And. Empty( cSOLUCAO ) .And. Empty( cDESCRIC )

			Return .T.

		EndIf
	
	EndIf

	If !aTail( aCols[nLin] ) .And. Empty( cOCORRE )

		Help( '', 1, 'NGATENCAO', , STR0223 + Chr( 13 ) + Chr( 10 ) + " " + STR0224, 3, 1 ) // Informe o código da ocorrência, # campo obrigatório.

		Return .F.

	EndIf

	If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0 .And.;
		FWIsInCallStack( 'MNTA435' )

		If nPosTar > 0

			cCodTar := aCols[nLin,nPosTar]

		EndIf

		For nInd1 := 1 To Len( aCols )
			
			If !aTail( aCols[nInd1] ) .And. aCols[nInd1,nOCORRE] == cOCORRE .And. aCols[nInd1,nCAUSA] == cCAUSA .And.;
				aCols[nInd1,nSOLUCAO] == cSOLUCAO .And. aCols[nInd1,nPosTar] == cCodTar

				nQtd++

			EndIf

		Next nInd1

	Else

		aEval( aCOLS, { |x| IIf( ( x[nOCORRE] == cOCORRE .And. x[nCAUSA] == cCAUSA .And.;
			x[nSOLUCAO] == cSOLUCAO .And. !x[nMax] ), nQtd++, Nil ) } )

	EndIf

	If nQtd > 1
		Help(" ",1,"NGATENCAO",,STR0191+Str(nLin,3)+".",3,1) //"Já existe registro de ocorrência. Item "
		Return .F.
	EndIf

	If TT9->( FieldPos( 'TT9_CARACT' ) ) > 0 .And.;
		FWIsInCallStack( 'MNTA435' )

		If nPosTar > 0

			cCodTar := aCols[nLin,nPosTar]

		EndIf

		/*-----------------------------+
		| Validação de tarefa genérica | 
		+-----------------------------*/
		lRet := MNTA420VTG( cCodTar )

		If lRet

			/*------------------------------------+
			| Valid. ocorrência do tipo problema. | 
			+------------------------------------*/
			lRet := MNA420VOcr( aCols[nLin,nOCORRE],;
				cCodTar, 'P' )

		EndIf

		If lRet .And. !Empty( aCols[nLin,nCAUSA] )

			/*---------------------------------+
			| Valid. ocorrência do tipo causa. | 
			+---------------------------------*/
			lRet := MNA420VOcr( aCols[nLin,nCAUSA],;
				cCodTar, 'C' )

		EndIf

		If lRet .And. !Empty( aCols[nLin,nSOLUCAO] )

			/*-----------------------------------+
			| Valid. ocorrência do tipo solução. | 
			+-----------------------------------*/
			lRet := MNA420VOcr( aCols[nLin,nSOLUCAO],;
				cCodTar, 'S' )

		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400IMP
Impressao de Ordem de Servico
@author Elisangela Costa
@since 27/09/2007
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT400IMP()

	Local ic := 0
	dbSelectArea("STJ")
	cAliasimp := Alias()
	nIndeximp := IndexOrd()
	nIMP675RE := Recno()

	If Type("aIndSTJ") == "A"
		aEval(aIndSTJ,{|x| Ferase(x[1]+OrdBagExt())})
	EndIf
	dbSelectArea("STJ")
	Set Filter to
	dbsetOrder(1)

	NGIMP675(STJ->TJ_ORDEM,STJ->TJ_PLANO,.F.,,STJ->(RECNO()))

	dbSelectArea("STJ")
	If Type("aIndSTJ") == "A"
		Eval(bFiltraBrw)
	EndIf
	dbgoto(nIMP675RE)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400MOT
Motivo do atraso da OS
@author Marcos Wagner Junior
@since 02/04/2007
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG400MOT()

	Local lINCLOLD := INCLUI
	Local aOldArea := GetArea()
	Local lGRAVA   := (TYPE("bNGGRAVA") == "B"), bNGRAOLD := {}
	Local aMnu400  := ACLONE(asMenu)
	Local cCadOld  := cCADASTRO
	Private INCLUI := .T.

	// Valida se a O.S. não foi cancelada paralelamente em outra rotina.
	If MNTA400Can()

		OLDROT  := aCLONE(aROTINA)
		If lGRAVA
			bNGRAOLD := aCLONE(bNGGRAVA)
		EndIf

		bNGGRAVA := {||NGCKINTDAT(M->TPL_ORDEM,M->TPL_CODMOT,M->TPL_DTINIC,M->TPL_HOINIC,M->TPL_DTFIM,M->TPL_HOFIM,.T.)}
		aRELAC   := {{"TPL_ORDEM","STJ->TJ_ORDEM"}}

		dbSelectArea("TPL")
		dbGoBottom()
		dbSkip()

		MNTA035()

		INCLUI := lINCLOLD

		RestArea(aOldArea)
		aROTINA := aCLONE(OLDROT)
		asMenu := ACLONE(aMnu400)
		cCADASTRO := cCadOld
		If lGRAVA
			bNGGRAVA := aCLONE(bNGRAOLD)
		EndIf

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGINSUPRE
Monta pesquisa dos insumos previstos
@author Inacio Luiz Kolling
@since 29/02/2008
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGINSUPRE()

	Local aPREArea := GetArea()
	Local im := 0,aTROCAOL := {},lTemCorr := .F.
	Local cSEQPRE := If(NGVERIFY("STJ"),STJ->TJ_SEQRELA,Str(STJ->TJ_SEQUENC,3))
	Local cChST5P := STJ->TJ_CODBEM+STJ->TJ_SERVICO+cSEQPRE

	If ReadVar() = 'M->TL_TAREFA'
		If Type("aTROCAF3") <> "U"
			aTROCAOL := Aclone(aTROCAF3)
		EndIf

		aTROCAF3 := {}
		aAdd(aTROCAF3,{"TL_TAREFA", "STLPRE"})

		If Type("lCORRET") <> "U"
			lCORROL  := lCORRET
			lTemCorr := .T.
		Else
			lCORRET := If(Val(STJ->TJ_PLANO) = 0,.T.,.F.)
		EndIf

		lUSATARN := If(FindFunction("NGUSATARPAD"),NGUSATARPAD(),.F.)
		dbSelectArea("STL")
		Set Filter To
		dbSetOrder(3)
		If !dbSeek(xFilial("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO+"0  ")
			MsgInfo(STR0205+" "+STJ->TJ_ORDEM,STR0137)
			bFiltraBrw := {|| FilBrowse("STL",@aIndSTL,@condSTL) }
			Eval(bFiltraBrw)
		Else
			lRetC := CONPAD1(,,,'STLPRE')
			If lRetC
				dbSelectArea("STL")
				If !NGVALTERC(STL->TL_TIPOREG)
					bFiltraBrw := {|| FilBrowse("STL",@aIndSTL,@condSTL) }
					Eval(bFiltraBrw)
					Return .F.
				EndIf
				If !NGRETNOREG(STL->TL_TIPOREG)
					bFiltraBrw := {|| FilBrowse("STL",@aIndSTL,@condSTL) }
					Eval(bFiltraBrw)
					Return .F.
				EndIf
				For im := 1 To FCount()
					M->&(Fieldname(im)) := &(Fieldname(im))
				Next im
				M->TL_NOMTAR  := If(Alltrim(M->TL_TAREFA) <> '0',;
				If(lUSATARN,NGNOMETAR(STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,;
				M->TL_TAREFA),;
				NGSEEK('ST5',cCHST5P+M->TL_TAREFA,1,"T5_DESCRIC")),STR0206)

				M->TL_NOMTREG := TIPREGBRW(M->TL_TIPOREG)
				M->TL_NOMCODI := NOMINSBRW(M->TL_TIPOREG,M->TL_CODIGO)
				If Empty(M->TL_USACALE)
					M->TL_USACALE := "N"
				EndIf
				If Empty(M->TL_GARANTI)
					M->TL_GARANTI := "N"
				EndIf
				If M->TL_TIPOREG = 'P'
					M->TL_DTFIM := M->TL_DTINICI
					M->TL_HOFIM := M->TL_HOINICI
				Else
					vVetDH := NGCALDATF(M->TL_DTINICI,M->TL_HOINICI,M->TL_QUANTID,M->TL_UNIDADE)
					M->TL_DTFIM := vVetDH[3]
					M->TL_HOFIM := vVetDH[4]
				EndIf
				M->TL_HREXTRA := If(M->TL_TIPOREG = "M","000.00","          ")
			EndIf
		EndIf
		dbSelectArea("STL")
		bFiltraBrw := {|| FilBrowse("STL",@aIndSTL,@condSTL) }
		Eval(bFiltraBrw)

		If lTemCorr
			lCORRET := lCORROL
		EndIf

		If !Empty(aTROCAOL)
			aTROCAF3 := Aclone(aTROCAOL)
		EndIf
	EndIf
	RestArea(aPREArea)
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400CHKGAR
Checa se o insumo informado esta em garantia.
@author Evaldo Cevinscki Jr.
@since 26/03/2008
@version undefined
@obs Funcao alterada para fazer somente o update da Dt.Gar.
@type function
/*/
//---------------------------------------------------------------------
Function MNT400CHKGAR()

	Local cLoc   := Space(1)
	Local dIniGar:= CtoD("  /  /  ")
	Local cOSGar := Space(1)
	Local nConAtu:= 0
	Local aArea  := GetArea()
	Local nRecSTJ := 0

	// Problema
	If Type("cLocaliz") = "U"
		cLocaliz := Space(Len(TPS->TPS_CODLOC))
	EndIf
	If Type("cOrdem") = "U"
		cOrdem := STJ->TJ_ORDEM
	EndIf
	If Type("cPlano") = "U"
		cPlano := STJ->TJ_PLANO
	EndIf

	cFilTPZ := If(NgSX2Modo("TPZ")=='C','  ',xFilial("TPZ"))
	cFilSTJ := If(NgSX2Modo("STJ")=='C','  ',xFilial("STJ"))
	nConAtu := STJ->TJ_POSCONT
	nConAt2 := STJ->TJ_POSCON2
	cBem := STJ->TJ_CODBEM
	cFilGar := Space(2)
	cBemGar := Space(16)
	cTipGar := Space(1)
	cCodGar := Space(6)
	cLoc    := Space(4)
	dIniGar := CtoD("  /  /  ")
	cOSGar  := Space(6)
	nContGar:= 0
	cConGar := Space(1)
	cPlanGar:= Space(6)
	cSeqStl := If(Type("M->TL_SEQRELA") == "U","",M->TL_SEQRELA)

	dbSelectArea("STJ")
	nRecSTJ := STJ->(Recno())
	dbSelectArea("TPZ")
	dbSetOrder(1)
	dbSeek(cFilTPZ+cBem+M->TL_TIPOREG+M->TL_CODIGO+cLocaliz+cOrdem+cPlano+cSeqStl)
	If Found()
		RecLock("TPZ",.F.)
		If Empty(M->TL_DTFIM)
			TPZ->TPZ_DTGARA := M->TL_DTINICI
		Else
			TPZ->TPZ_DTGARA := M->TL_DTFIM
		EndIf
		MsUnLock("TPZ")
	EndIf
	dbSelectArea("STJ")
	dbGoTo(nRecSTJ)
	RestArea(aArea)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400VLTA
Valida o intervalo de data/hora do insumo tipo mao de obra,
terceiro e ferramenta na acols
@author Elisangela Costa
@since 29/08/08
@version undefined
@param cCODINSU, characters, Codigo do insumo
@param cORDEMSTL, characters, Data inicio de aplicacao do insumo
@param cPLANOSTL, characters, Data inicio de aplicacao do insumo
@param dDTINISTL, date, Data inicio de aplicacao do insumo
@param cHRINISTL, characters, Hora inicio de aplicao do insumo
@param dDTFIMSTL, date, Data fim de aplicacao do insumo
@param cHRFIMSTL, characters, Hora fim de aplicao do insumo
@param cTIPOINS, characters, Tipo do insumo
@param nNUMRACOLS, numeric, Numero da linha na acols
@type function
@return Retorno de isumo
/*/
//---------------------------------------------------------------------
Function MNT400VLTA(cCODINSU,cORDEMSTL,cPLANOSTL,dDTINISTL,cHRINISTL,dDTFIMSTL,;
					cHRFIMSTL,cTIPOINS,nNUMRACOLS)

	Local ix := 0
	Local nCOD := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_CODIGO" })
	Local nTIP := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_TIPOREG" })
	Local nQTR := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_QUANREC" })
	Local nDIN := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTINICI" })
	Local nHIN := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOINICI" })
	Local nDFI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_DTFIM" })
	Local nHFI := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TL_HOFIM" })
	Local cCOD, cTIP, cQTR, cDIN, cHIN, cDFI, cHFI
	Local cHrIniTemp := cHRINISTL
	Local cHrFimTemp := cHRFIMSTL
	Local dDtIniTemp := dDTINISTL
	Local dDtFimTemp := dDTFIMSTL

	Private dDTINIAPL := Ctod('  /  /  '), cHRINIAPL := "  :  "  //Data e hora inicio de aplicacao do insumo
	Private dDTFIMAPL := Ctod('  /  /  '), cHRFIMAPL := "  :  "  //Data e hora inicio de aplicacao do insumo
	Private cORDEMSER := Space(Len(STL->TL_ORDEM)) //Ordem de servico de aplicacao do insumo
	Private cPLANPSER := Space(Len(STL->TL_PLANO)) //Plano de aplicacao do insumo
	Private lMENSINS  := .F.                        //Variavel logica do controle do While
	Private nQUATFEU  := 0                          //Guarda a quantidade da mesma ferrameta utilizada no mesmo intervalo de data/hora
	Private nQUATISH4 := 0                          //Guarda a quantidade de ferramenta disponivel no SH4

	If cTIPOINS == "F"
		dbSelectArea("SH4")
		dbSeek(xFilial("SH4")+SubStr(M->TL_CODIGO,1,6))
		nQUATISH4 := SH4->H4_QUANT
	EndIf

	//Validacao para permitir insumos no mesmo intervalo de data/hora inicio/fim
	If cHRINISTL == '23:59'
		dDTINISTL += 1
	EndIf
	If cHRFIMSTL == '00:00'
		dDTFIMSTL -= 1
	EndIf
	cHRINISTL := MTOH(HTOM(cHRINISTL)+1)
	cHRFIMSTL := MTOH(HTOM(cHRFIMSTL)-1)

	For ix := 1 To Len(aCOLS)

		If lMENSINS
			Exit
		EndIf

		cCOD := aCols[ix][nCOD]
		cTIP := aCols[ix][nTIP]
		cQTR := aCols[ix][nQTR]
		cDIN := aCols[ix][nDIN]
		cHIN := aCols[ix][nHIN]
		cDFI := aCols[ix][nDFI]
		cHFI := aCols[ix][nHFI]

		If !aCols[ix][Len(aCols[ix])]

			//Valida o tipo de insumo terceiro
			If cTIP == cTIPOINS .And. cCOD = cCODINSU .And. ix <> nNUMRACOLS

				If dDTFIMSTL < cDFI
					If dDTFIMSTL = cDIN
						If cHRFIMSTL >= cHIN
							//Carrega variaveis
							NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
							cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
							Loop
						EndIf
					ElseIf dDTINISTL > cDIN
						//Carrega variaveis
						NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
						cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
						Loop
					ElseIf dDTFIMSTL > cDIN
						//Carrega variaveis
						NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
						cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
						Loop
					EndIf
				Else
					If dDTFIMSTL > cDFI
						If dDTINISTL = cDFI
							If cHRINISTL <= cHFI
								//Carrega variaveis
								NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
								cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
								Loop
							EndIf
						Else
							If dDTINISTL < cDFI
								//Carrega variaveis
								NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
								cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
								Loop
							EndIf
						EndIf
					Else
						If dDTINISTL > cDIN
							If dDTFIMSTL = cDFI
								If dDTINISTL = cDFI
									If cHRINISTL <= cHFI
										//Carrega variaveis
										NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
										cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
										Loop
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf

				If dDTINISTL < cDIN
					If dDTFIMSTL = cDIN
						If cHRFIMSTL >= cHIN
							//Carrega variaveis
							NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
							cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
							Loop
						EndIf
					Else
						If dDTFIMSTL = cDFI
							//Carrega variaveis
							NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
							cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
							Loop
						EndIf
					EndIf
				Else
					If dDTINISTL > cDIN
						If dDTINISTL <> cDFI
							If dDTFIMSTL = cDFI
								//Carrega variaveis
								NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
								cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
								Loop
							EndIf
						EndIf
					Else
						If dDTINISTL = cDIN
							If dDTFIMSTL = cDIN
							Else
								If dDTFIMSTL < cDFI
									//Carrega variaveis
									NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
									cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
									Loop
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf

				If dDTINISTL = cDIN .And. dDTFIMSTL = cDFI
					If cDIN = cDFI //DATAS IGUAIS MESMO DIA
						If cHRFIMSTL >= cHIN //INICIO DE ARQUIVO
							If cHRINISTL < cHIN
								//Carrega variaveis
								NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
								cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
								Loop
							EndIf
						EndIf
						If cHRINISTL <= cHFI   //FINAL DE ARQUIVO
							If cHRFIMSTL > cHFI
								//Carrega variaveis
								NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
								cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
								Loop
							EndIf
						EndIf
						If cHRINISTL >= cHIN
							If cHRFIMSTL <= cHFI
								//Carrega variaveis
								NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
								cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
								Loop
							EndIf
						EndIf
					Else //DATAS IGUAIS DIAS DIFERENTE
						If cHRINISTL >= cHIN
							//Carrega variaveis
							NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
							cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
							Loop

						Else
							If cHRFIMSTL <= cHFI
								//Carrega variaveis
								NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
								cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
								Loop
							EndIf
						EndIf
						If cHRINISTL <= cHIN .And. cHRFIMSTL >= cHFI
							//Carrega variaveis
							NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
							cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
							Loop
						EndIf
					EndIf
				Else
					If dDTINISTL = cDIN.And. dDTFIMSTL = cDIN
						If cHRFIMSTL >= cHIN
							//Carrega variaveis
							NGCARRINSU(cDIN,cHIN,cDFI,cHFI,cORDEMSTL,;
							cPLANOSTL,If(cTIPOINS <> "F",.T.,.F.),cTIPOINS)
							Loop
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Next ix

	//Retorna valores iniciais das variaveis
	cHRINISTL := cHrIniTemp
	cHRFIMSTL := cHrFimTemp
	dDTINISTL := dDtIniTemp
	dDTFIMSTL := dDtFimTemp

	If lMENSINS  .And. cTIPOINS <> "F"

		MsgInfo(STR0232 + chr(13)+chr(13); //"Ja existe aplicacao de insumo no intervalo de Data/Hora informada."
		+STR0233 + ": " + cCODINSU+chr(13); //"Codigo Insumo"
		+STR0234 + "....: " + cORDEMSTL+chr(13); //"Ordem Serv"
		+STR0235 +"...............: " + cPLANOSTL+chr(13); //"Plano"
		+STR0227 + ".......: " + dtoc(dDTINISTL)+chr(13); //"Data Inicio"
		+STR0228 + ".......: " + Substr(cHRINISTL,1,5)+chr(13); //"Hora Inicio"
		+STR0229 + "..........: " + dtoc(dDTFIMSTL)+chr(13); //"Data Fim"
		+STR0230 + "..........: " + Substr(cHRFIMSTL,1,5)+chr(13)+chr(13); //"Hora Fim"
		+STR0236 + ":" + chr(13)+chr(13); //"Aplicacao do insumo ja existente"
		+STR0234 + "..: " + cORDEMSER+chr(13); //"Ordem Serv"
		+STR0235 +".............: " + cPLANPSER+chr(13); //"Plano"
		+STR0227 + ".....: " + dtoc(dDTINIAPL)+chr(13); //"Data Inicio"
		+STR0228 + ".....: " + Substr(cHRINIAPL,1,5)+chr(13); //"Hora Inicio"
		+STR0229 + "........: " + dtoc(dDTFIMAPL)+chr(13); //"Data Fim"
		+STR0230 + "........: " + Substr(cHRFIMAPL,1,5),STR0022)//"Hora Fim"

		Return {.F.,0}

	ElseIf cTIPOINS == "F"
		Return {.F.,nQUATFEU}
	EndIf

Return {.T.,0}

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400ROD
Abre programa de rodizio da estrutura
@author Vitor Emanuel Batista
@since 08/08/2008
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT400ROD()

	Local cBEMPAI := STJ->TJ_CODBEM

	dbSelectarea("STC")
	dbSetOrder(1)
	If !dbSeek(xFilial('STC')+cBEMPAI)
		Help(" ",1,"NGMBNEXEST")
		Return .F.
	EndIf
	MNTA098(cBEMPAI)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400DEST
Funcao de validacao do campo TL_DESTINO
@author Evaldo Cevinscki Jr.
@since 15/09/08
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT400DEST()

	Local aOldArea := GetArea()
	Local nOpca    := 0
	Local cBotaoNada := ' '
	Private cProd    := " "
	Private cCodAlmo := Space(02)
	Private cCodProd := Space(15)
	Private cNomCodP := Space(30)
	Private cCodSTLEst := Space(15)
	Private cCodSTLAlm := Space(2)

	If If(Type("cINSPREV") == "C",cINSPREV<>"P",.T.)
		If If(Type("cUSAINT3") == "C",cUSAINT3 == "S",.F.) .And. If(Type("lNumSeq2") == "L",lNumSeq2,.F.)
			If cPrograma == "MNTA415"
				cProd := AllTrim(aCols[n][nCODIG4])
			Else
				cProd := AllTrim(M->TL_CODIGO)
			EndIf

			If M->TL_DESTINO == "S"

				Define Font oFontB Name "Arial" Size 07,17 Bold
				Define Font oFontN Name "Arial" Size 07,17
				Define msDialog oDlgP Title STR0238 From 000,000 To 140,500 Pixel //"Informe o novo código de produto"

				@ 17,008 Say OemToAnsi(STR0239+cProd+STR0240) Font oFontN Size 400,10 Of oDlgP Pixel //"Indique o código do produto "##" substituído,"
				@ 28,008 Say OemToAnsi(STR0241) Font oFontN Size 400,10 Of oDlgP Pixel //"que irá ser devolvido para o Estoque:"

				@ 44,008 Say OemToAnsi(STR0242) Size 47,07 Of oDlgP Pixel //"Produto"
				@ 43,045 MsGet cCodProd Size  60,08 OF oDlgP Pixel Picture "@!" F3 "SB1" Valid MNT400PROD(cCodProd) HASBUTTON
				@ 43,108 MsGet cNomCodP Size 120,08 OF oDlgP Pixel Picture '@!' When .F.
				@ 57,008 Say OemToAnsi(STR0243) Size 47,07 Of oDlgP Pixel //"Almoxarifado"
				@ 56,045 MsGet cCodAlmo Size  12,08 OF oDlgP Pixel Picture "@!" Valid NaoVazio()
				@ 80,125 MsGet cBotaoNada Size 10,08 OF oDlgP Pixel Picture '@!' When .T.

				oDlgP:LESCCLOSE := .F.

				Activate MsDialog oDlgP On Init EnchoiceBar(oDlgP,{|| (nOpca:=1,oDlgP:End())},{||oDlgP:End()}) Center

				If nOpca == 1
					cCodSTLEst := cCodProd
					cCodSTLAlm := cCodAlmo
				Else
					cCodSTLEst := ' '
					cCodSTLAlm := ' '
					MsgStop(STR0244,STR0025)//"Para insumo substituído, é obrigatório informar o produto para devolução ao estoque."##"ATENÇÃO"
					RestArea(aOldArea)
					Return .F.
				EndIf
				If cPrograma == "MNTA400" .Or. cPrograma == "NG400PADRA"
					aAdd(aInsSub,{STJ->TJ_ORDEM,M->TL_CODIGO,cCodSTLEst,cCodSTLAlm})
				ElseIf cPrograma == "MNTA415"
					aAdd(aInsSub,{Str(n),aCols[n][nORDEM4],aCols[n][nCODIG4],cCodSTLEst,cCodSTLAlm})
				EndIf
			EndIf
		EndIf
	EndIf
	RestArea(aOldArea)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400PROD
Validacao do campo Produto
@author Evaldo Cevinscki Jr.
@since 15/09/0
@version undefined
@param cCodProd, characters
@type function
/*/
//---------------------------------------------------------------------
Function MNT400PROD(cCodProd)

	Local aOldArea := GetArea()

	If Empty(cCodProd)
		Help(" ",1,"NGMNCODINS") //"Codigo do Insumo nao informado!"
		Return .F.
	EndIf

	If !EXISTCPO("SB1",Trim(cCodProd))
		Return .F.
	EndIf

	If AllTrim(cCodProd) == AllTrim(cProd)
		MsgStop(STR0245+cProd,STR0025) //"O código do produto deverá ser diferente do código que esta sendo aplicado:"##"ATENÇÃO"
		Return .F.
	EndIf
	dbSelectArea("SB1")
	dbSeek(xFilial("SB1")+Trim(cCodProd))
	cNomCodP := SubStr(SB1->B1_DESC,1,30)
	cCodAlmo := SB1->B1_LOCPAD
	RestArea(aOldArea)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400MOVEST
Gera Movimento de Requisicao e/ou Devolucao nos Arquivos de
Movimentacao Interna (SD3).
@author Evaldo Cevinscki Jr.
@since 16/09/2008
@version undefined
@param cCod, characters, descricao
@param cCodSTLEst, characters, descricao
@param cCodSTLAlm, characters, descricao
@param dDtIns, date, descricao
@param cOrdem, characters, descricao
@param nQtd, numeric, descricao
@param cNumSeq2, characters, descricao
@param nOPEX, numeric, Opcao de Movimentacao 3=Inclusao, 5= Exclusao
@param lEstor, logical, descricao
@type function
/*/
//---------------------------------------------------------------------
Function MNT400MOVEST(cCod,cCodSTLEst,cCodSTLAlm,dDtIns,cOrdem,nQtd,cNumSeq2,nOPEX,lEstor)

	Local lEstoSD3	 := If(lEstor = Nil,.F.,lEstor)
	Local cLoteCtl   := CriaVar( 'D3_LOTECTL' )
	Local cNumLote   := CriaVar( 'D3_NUMLOTE' )
	Local cLocaliz   := CriaVar( 'D3_LOCALIZ' )
	Local cNumSeri   := CriaVar( 'D3_NUMSERI' )
	Local cnumSeqD   := CriaVar( 'D3_NUMSEQ' )
	Local cItemCta   := CriaVar( 'D3_ITEMCTA' )
	Local nQtdOco    := 0
	Local cCodBem

	cOP := cOrdem+"OS001"

	If NGCADICBASE("T9_ITEMCTA","A","ST9",.F.)
		cCodBem  := NGSEEK("STJ",cOrdem,1,"TJ_CODBEM")
		cItemCta := If(!Empty(cCodBem),NGSEEK("ST9",cCodBem,1,"T9_ITEMCTA"),"")
	EndIf

	If !Empty(cNumSeq2)
		dbSelectArea("SD3")
		dbSetOrder(4)
		dbSeek(xFilial("SD3")+cNumSeq2)
		cCodSTLEst := SD3->D3_COD
		cCodSTLAlm := SD3->D3_LOCAL
		nQtd       := SD3->D3_QUANT
		dDtIns     := SD3->D3_EMISSAO
		cNumSeqD   := cNumSeq2
		cOP        := SD3->D3_OP
	EndIf

	SB1->(dbSetOrder(1))
	If SB1->(dbSeek(xFilial('SB1')+cCodSTLEst))
		cB1Aprop := SB1->B1_APROPRI
		cB1Medid := SB1->B1_UM
	EndIf

	cCodSTLAlm  := If(Empty(cCodSTLAlm),'01',cCodSTLAlm)
	cProduto := cCodSTLEst

	dbSelectArea("SBF")
	dbSetOrder(2)
	dbSeek(xFilial("SBF")+cProduto+cCodSTLAlm)
	cAlmoxa  := cCodSTLAlm
	cLoteCtl := If(Empty('BF_LOTECTL'), '', SBF->BF_LOTECTL)
	cNumLote := If(Empty('BF_NUMLOTE'), '', SBF->BF_NUMLOTE)
	cLocaliz := If(Empty('BF_LOCALIZ'), '', SBF->BF_LOCALIZ)
	cNumSeri := If(Empty('BF_NUMSERI'), '', SBF->BF_NUMSERI)

	cLOCALD3 := If(Empty(cAlmoxa),SB1->B1_LOCPAD,cAlmoxa)
	cB1APROP := SB1->B1_APROPRI

	SB2->(dbSetOrder(1))
	If !SB2->(dbSeek(xFilial('SB2')+SubStr(cProduto,1,15)+cLOCALD3))
		CriaSB2(cProduto,cCodSTLAlm)
		// A FUNCAO ACIMA NAO LIBERA O REGISTRO
		MsUnLock("SB2")
	EndIf
	If Empty(cNumSeqD)
		cNumSeqD := ProxNum()
	EndIf

	aAutoItens := {{"D3_TM"      , If(cCod=='RE0', '999', '499')                             , '.T.'},;
				   {"D3_COD"     , cProduto                                                  , Nil},;
				   {"D3_UM"      , cB1Medid                                                  , Nil},;
				   {"D3_QUANT"   , nQtd                                                      , Nil},;
				   {"D3_CF"      , cCod                                                      , Nil},;
				   {"D3_CONTA"   , SB1->B1_CONTA                                             , Nil},;
				   {"D3_LOCAL"   , cLOCALD3                                                  , Nil},;
				   {"D3_EMISSAO" , dDtIns                                                    , Nil},;
				   {"D3_NUMSEQ"  , cNumSeqD                                                  , Nil},;
				   {"D3_SEGUM"   , SB1->B1_SEGUM                                             , Nil},;
				   {"D3_QTSEGUM" , ConvUm(SB1->B1_COD,nQtdOco,0,2)                           , Nil},;
				   {"D3_GRUPO"   , SB1->B1_GRUPO                                             , Nil},;
				   {"D3_TIPO"    , SB1->B1_TIPO                                              , Nil},;
				   {"D3_NUMSERI" , cNumSeri                                                  , Nil},;
				   {"D3_CHAVE"   , SubStr(SD3->D3_CF,2,1)+If(SD3->D3_CF $ 'RE4|DE4','9','0') , Nil},;
				   {"D3_USUARIO" , SubStr(cUsuario,7,15)                                     , Nil},;
				   {"D3_ESTORNO" , If(Substr(cCod,1,1) = "D","S"," ")                        , Nil},;
				   {"D3_OP"      , cOP                                                       , Nil} }

	If NGCADICBASE("T9_ITEMCTA","A","ST9",.F.)
		If !Empty(cItemCta)
			aAdd( aAutoItens , {"D3_ITEMCTA",cItemCta,Nil} )
		EndIf
	EndIf

	lMsErroAuto := .F.

	If nOPEX == 5
		Inclui := .T.
	EndIf
	MSExecAuto({|x| MATA240(x)},aAutoItens)
	If nOPEX == 5
		Inclui := .F.
		dbSelectArea("SD3")
		RecLock("SD3",.F.)
		SD3->D3_NUMSEQ := cNumSeq2
		MsUnLock("SD3")
	EndIf
	If lMsErroAuto
		Mostraerro()
	EndIf

	dbSelectArea("SD3")
	RecLock("SD3",.F.)
	SD3->D3_ESTORNO := If(lEstoSD3,'S',Space(Len(sd3->d3_estorno)))
	MsUnLock("SD3")

	If !lMsErroAuto
		//-------------------------------------
		//INTEGRACAO POR MENSAGEM UNICA
		//-------------------------------------
		If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"  //Mensagem Unica
			If SubStr(cCod,1,2) == "RE"//
				NGMUStoTuO(SD3->(RecNo()),"SD3")
			Else
				NGMUCanReq(SD3->(RecNo()),"SD3")
			EndIf
		EndIf
	EndIf
	cCodSTLEst := " "
	cCodSTLAlm := " "

Return SD3->D3_NUMSEQ

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400PCKGAR
Checa se o insumo informado esta em garantia, pelo retorno padrao
@author Evaldo Cevinscki Jr.
@since 20/03/2008
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT400PCKGAR()

	Local lGarDt  := .F.,lGarCon := .F.
	Local cLoc    := Space(1)
	Local cTLoc   := ""
	Local dDtVal  := CtoD("  /  /  ")
	Local dIniGar := CtoD("  /  /  ")
	Local dFimGar := CtoD("  /  /  ")
	Local cOSGar  := Space(1)
	Local nIniGar := 0
	Local nFimGar := 0
	Local nConAtu := 0, nPosCon := 0
	Local nTIPREG,nCODIGO,nDTINIC
	Local cTipReg := " ", cCodIns := " ", dDtIni := " "
	Local aIGar   := {}, i
	Local aArea   := GetArea()
	Local nRecSTJ := 0
	cFilTPZ := If(NgSX2Modo("TPZ")=='C','  ',xFilial("TPZ"))
	cFilSTJ := If(NgSX2Modo("STJ")=='C','  ',xFilial("STJ"))
	dbSelectArea("STJ")
	nRecSTJ := STJ->(Recno())
	nConAtu := STJ->TJ_POSCONT
	nConAt2 := STJ->TJ_POSCON2

	If cPrograma == "MNTA400"
		cTipReg := M->TL_TIPOREG
		cCodIns := M->TL_CODIGO
		dDtIni  := M->TL_DTINICI
	ElseIf cPROGRAMA == "NG400PADRA"
		nTIPREG := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
		nCODIGO := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_CODIGO"})
		nDTINIC := aSCAN(aHeaIns,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
		cTipReg := aCols[n][nTIPREG]
		cCodIns := aCols[n][nCODIGO]
		dDtIni  := aCols[n][nDTINIC]
	EndIf

	dbSelectArea("TPZ")
	dbSetOrder(1)
	dbSeek(cFilTPZ+STJ->TJ_CODBEM+cTipReg+cCodIns)
	While !EoF() .And. TPZ->TPZ_FILIAL == xFilial("TPZ") .And. TPZ->TPZ_CODBEM == STJ->TJ_CODBEM .And. ;
	TPZ->TPZ_TIPORE == cTipReg .And. TPZ->TPZ_CODIGO == cCodIns
		If TPZ->TPZ_ORDEM == STJ->TJ_ORDEM .And. TPZ->TPZ_PLANO == STJ->TJ_PLANO .And. AllTrim(TPZ->TPZ_SEQREL) == AllTrim(M->TL_SEQRELA)
			dbSelectArea("TPZ")
			dbSkip()
			Loop
		EndIf
		If TPZ->TPZ_UNIGAR = "D"
			dDtVal := TPZ->TPZ_DTGARA + TPZ->TPZ_QTDGAR
		ElseIf TPZ->TPZ_UNIGAR = "S"
			dDtVal := TPZ->TPZ_DTGARA + (TPZ->TPZ_QTDGAR * 7)
		ElseIf TPZ->TPZ_UNIGAR = "M"
			dDtVal := TPZ->TPZ_DTGARA + (TPZ->TPZ_QTDGAR * 30)
		EndIf

		If dDtVal > dDtIni
			lGarDt := .T.
			cLoc := TPZ->TPZ_LOCGAR
			dIniGar := TPZ->TPZ_DTGARA
			dFimGar := dDtVal
			cOSGar := TPZ->TPZ_ORDEM
		EndIf
		If lGarDt
			If cLoc == cLocaliz
				lMens := .T.
			Else
				lMens := .F.
			EndIf
			cMsgAlert := (STR0101+CHR(13); //"Insumo substituido no prazo de Garantia"
			+STR0102+AllTrim(Str(Day(dIniGar)))+"/"+AllTrim(Str(Month(dIniGar)))+"/"+AllTrim(Str(Year(dIniGar)))+STR0103+cOSGar+CHR(13); //"Data de Inicio de uso :"###"    O.S.:"
			+STR0104+AllTrim(Str(Day(dFimGar))+"/"+AllTrim(Str(Month(dFimGar)))+"/"+AllTrim(Str(Year(dFimGar))))+CHR(13);  //"Garantia Ate..............:"
			+If(Empty(cLoc)," ",STR0222+cLoc))  //"Na Localização: "
			lGarDt := .F.
			aAdd(aIGar,{1,cLoc,cMsgAlert,lMens})
		EndIf
		If NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)
			If !Empty(TPZ->TPZ_QTDCON)
				If TPZ->TPZ_CONGAR == '1'
					dbSelectArea("STJ")
					STJ->(dbSetOrder(1))
					If dbSeek(cFilSTJ+TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO)
						If nConAtu < (STJ->TJ_POSCONT + TPZ->TPZ_QTDCON)
							lGarCon := .T.
							cLoc    := TPZ->TPZ_LOCGAR
							nIniGar := STJ->TJ_POSCONT
							nFimGar := STJ->TJ_POSCONT + TPZ->TPZ_QTDCON
							cOSGar  := TPZ->TPZ_ORDEM
							nPosCon := nConAtu
						EndIf
					EndIf
				ElseIf TPZ->TPZ_CONGAR == '2'
					dbSelectArea("STJ")
					dbSetOrder(1)
					If dbSeek(cFilSTJ+TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO)
						If nConAt2 < (STJ->TJ_POSCON2 + TPZ->TPZ_QTDCON)
							lGarCon := .T.
							cLoc    := TPZ->TPZ_LOCGAR
							nIniGar := STJ->TJ_POSCON2
							nFimGar := STJ->TJ_POSCON2 + TPZ->TPZ_QTDCON
							cOSGar  := TPZ->TPZ_ORDEM
							nPosCon := nConAt2
						EndIf
					EndIf
				EndIf
				If lGarCon
					If cLoc == cLocaliz
						lMens := .T.
					Else
						lMens := .F.
					EndIf
					cMsgAlert := (STR0101+CHR(13)+CHR(13);  //"Insumo substituido no prazo de Garantia"
					+STR0118+AllTrim(Str(nIniGar))+CHR(13); //"Contador no inicio do uso    : "
					+STR0119+cOSGar+CHR(13);  //"O.S.                                     : "
					+STR0120+AllTrim(Str(nPosCon))+CHR(13);   //"Contador atual                     : "
					+STR0121+AllTrim(Str(nFimGar))+CHR(13); //"Garantia Ate                         : "
					+If(Empty(cLoc)," ",STR0222+cLoc))  //"Na Localização: "
					lGarCon := .F.
					aAdd(aIGar,{2,cLoc,cMsgAlert,lMens})
				EndIf
			EndIf
		EndIf
		dbSelectArea("TPZ")
		dbSkip()
	End

	lMens := .F.
	cMens := ""
	cMsg  := ""
	If Len(aIGar) > 0
		For i := 1 to Len(aIGar)
			If !Empty(aIGar[i][2])
				cTLoc += If(!Empty(cTLoc),","+AllTrim(aIGar[i][2]),AllTrim(aIGar[i][2]))
			EndIf

			If aIGar[i][4] //se ja foi informada a localicao
				cMens += aIGar[i][3]
			ElseIf !Empty(cTLoc)
				lMens := .T.
			Else
				cMsg += aIGar[i][3]
			EndIf
		Next i

		If !Empty(cMens)
			MsgAlert(cMens)
		ElseIf lMens
			//chama funcao com tela para ser informada a localizacao do insumo trocado
			MNT400LG(cCodIns,cTLoc)
			nPos := Ascan(aIGar,{|x| x[2] == cLocaliz})
			If nPos > 0
				MsgAlert(aIGar[nPos][3])
			EndIf
		Else
			MsgAlert(cMsg)
		EndIf
	EndIf

	dbSelectArea("STJ")
	dbGoTo(nRecSTJ)
	RestArea(aArea)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400LG
Mensagem de garantia quando for controlada por localizacao
@author Evaldo Cevinscki Jr.
@since 25/10/2008
@version undefined
@param cProd, characters
@param cLocs, characters
@type function
/*/
//---------------------------------------------------------------------
Function MNT400LG(cProd,cLocs)

	cLocaliz := Space(Len(TPS->TPS_CODLOC))
	cNomLoc  := Space(20)

	Define Font oFontB Name "Arial" Size 07,17 Bold
	Define Font oFontN Name "Arial" Size 07,17
	Define msDialog oDlgG Title STR0069 From 000,000 To 180,500 Pixel //"Garantia"

	@ 17,008 Say OemToAnsi(STR0158+AllTrim(cProd)+STR0246) Font oFontN Size 400,10 Of oDlgG Pixel //"Produto " //" esta na garantia na(s) localização(ões):"
	@ 28,008 Say OemToAnsi(cLocs) Font oFontN Size 400,10 Of oDlgG Pixel
	@ 39,008 Say OemToAnsi(STR0247) Font oFontN Size 400,10 Of oDlgG Pixel //"Indique a localizaçao do insumo atual para obter detalhes da garantia."

	@ 55,008 Say Oemtoansi(STR0070) Size 47,07 Of oDlgG Pixel //"Local"
	@ 54,045 MsGet cLocaliz Size 38,08 Of oDlgG Pixel Picture '@!' F3 "TPS" Valid NGLOCGAR(cLocaliz) HASBUTTON
	@ 54,108 MsGet oNomLoc Var cNomLoc Of oDlgG Pixel Picture '@!' When .T. Size 90,08

	oDlgG:LESCCLOSE := .F.
	Activate MsDialog oDlgG On Init EnchoiceBar(oDlgG,{|| (nOpca:=1,oDlgG:End())},{||oDlgG:End()}) Center

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400TTA
Checa se foi lancado pelo abast.em lote e altera tabela TTA
@author Marcos Wagner Junior
@since 28/10/08
@version undefined
@param nPar, numeric
@param nQtdAntiga, numeric
@param nQtdNova, numeric
@type function
/*/
//---------------------------------------------------------------------
Function MNT400TTA(nPar,nQtdAntiga,nQtdNova)

	If NGCADICBASE('TQN_OSLUBR','D',"TQN",.F.) .And. NGCADICBASE('TL_NOTFIS','D',"STL",.F.) .And. NGCADICBASE('TL_FORNEC','D',"STL",.F.)
		If !EoF() .And. M->TL_SEQRELA == '1  '
			If nPar == 4
				If nQtdAntiga <> nQtdNova
					dbSelectArea("TTA")
					dbSetOrder(1)
					If dbSeek(xFilial("TTA")+STL->TL_FORNEC+STL->TL_LOJA+STL->TL_NOTFIS)
						RecLock("TTA",.F.)
						TTA->TTA_TOTLUB -= nQtdAntiga
						TTA->TTA_TOTLUB += nQtdNova
						If TTA->TTA_TOTLUB == 0
							TTA->TTA_SERTRO := Space(Len(TTA->TTA_SERTRO))
							TTA->TTA_SERREP := Space(Len(TTA->TTA_SERREP))
						EndIf
						MsUnLock("TTA")
					EndIf
				EndIf
			Else
				dbSelectArea("TTA")
				dbSetOrder(1)
				If dbSeek(xFilial("TTA")+STL->TL_FORNEC+STL->TL_LOJA+STL->TL_NOTFIS)
					RecLock("TTA",.F.)
					TTA->TTA_TOTLUB -= nQtdAntiga
					If TTA->TTA_TOTLUB == 0
						TTA->TTA_SERTRO := Space(Len(TTA->TTA_SERTRO))
						TTA->TTA_SERREP := Space(Len(TTA->TTA_SERREP))
					EndIf
					MsUnLock("TTA")
				EndIf
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA400F6
Funcao que ira chamar a tela de Etapas da O.S.
@author Marcos Wagner Junior
@since 10/02/09
@version undefined
@param cTipoIns, characters
@param cCodIns, characters
@type function
/*/
//---------------------------------------------------------------------
Function MNTA400F6(cTipoIns,cCodIns)

	Local aOldCols := aClone(aCols)
	Local aOldHeader := aClone(aHeader)
	Local aOldRot := aClone(aRotina)
	Local nOldN := n

	Private lGravaFun := .T.
	lFoiF6 := .T.

	If (Empty(cCodIns) .OR. (cTipoIns != 'M') .OR. (Type("oDLG1") != 'U'))
		Return
	Else
		NG400ETA(,,,lFoiF6)
	EndIf

	aCols	:= aClone(aOldCols)
	aHeader := aClone(aOldHeader)
	aRotina := aClone(aOldRot)
	n := nOldN
	lFoiF6 := .F.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA400COM
Complemento do Insumo
@author Marcos Wagner Junior
@since 27/02/09
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA400COM()

	Local nI		 := 0
	Local lRet 		 := .F.
	Local lMNTA4014	 := ExistBlock("MNTA4014",.F.,.F.)
	Local aCmpSTL    := {"TL_TAREFA","TL_CODIGO" ,"TL_NOMCODI","TL_LOTECTL","TL_NUMLOTE","TL_GARANTI","TL_OBSERVA"}
	Local aNoFields  := {"TN_FILIAL","TN_SEQRELA","TN_ORDEM"  ,"TN_PLANO"  ,"TN_TAREFA" ,"TN_NOMETAR","TN_SEQUENC"}
	Local nInd       := 0
	Local nTot       := 0
	Local cCampo     := ""
	Local oSize      := FwDefSize():New(.T.) // Com enchoicebar
	Local nTamHoriz  := oSize:aWorkArea[3]
	Local nLinFimTla := oSize:aWindSize[3]
	Local nColFimTla := oSize:aWindSize[4]
	Local nAltSup    := oSize:aWorkArea[4] * 0.8
	Local nAltInf    := oSize:aWorkArea[4] * 0.2

	Private nOpca := 0, nCnt, oDlg, oGet, bNGGRAVA
	Private aTELA[0][0],aGETS[0],aHeader[0],Continua,oMenu

	dbSelectArea("STL")
	If STL->TL_TIPOREG $ "PMT" .And. !Empty(STL->TL_NUMSEQ)
		lRet := NGIFDBSEEK("SD1",STL->TL_NUMSEQ,4,.F.)
		If !lRet
			If NGIFDBSEEK("SD3",STL->TL_NUMSEQ,4,.F.)
				If NGCADICBASE("TL_ORIGNFE","A","STL",.F.)
					If STL->TL_ORIGNFE = "SD3"
						lRet := .T.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	If !lRet
		MsgStop(STR0249+" "+If(NGCADICBASE("TL_ORIGNFE","A","STL",.F.),STR0307," "),STR0133) //"Insumo não foi originado por documento de entrada"
		Return .F.
	EndIf

	cKEY      := STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+STL->TL_SEQRELA
	cGETWHILE := "TN_FILIAL == xFilial('STN') .And. TN_ORDEM == STL->TL_ORDEM .And. "+;
				 "TN_PLANO  == STL->TL_PLANO  .And. TN_SEQRELA == STL->TL_SEQRELA .And. "+;
				 "TN_TAREFA == M->TL_TAREFA"
	nContI    := 0
	bCampo    := {|nCPO| Field(nCPO) }
	aFields   := {}
	aPos1     := {15,1,78,315 }
	cChaveSTL := STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+STL->TL_TIPOREG+STL->TL_CODIGO+STL->TL_SEQRELA
	cTarefaA  := STL->TL_TAREFA
	cChavSTLP := STL->TL_ORDEM+STL->TL_PLANO
	cChavSTLF := STL->TL_TIPOREG+STL->TL_CODIGO+STL->TL_SEQRELA
	cChavSTLS := STL->TL_SEQRELA
	nSalvoRec := Recno()

	dbSelectArea("STL")
	For nI := 1 To FCount()
		x   := "m->" + FieldName(nI)
		&x. := FieldGet(nI)
	Next i

	nTot := Len(aCmpSTL)
	For nInd := 1 To nTot
		If STL->(FieldPos(aCmpSTL[nInd])) > 0
			aAdd(aFields,aCmpSTL[nInd])
		EndIf
	Next nInd

	FillGetDados(3,"STN",1,,,{|| .T.},aNoFields)

	nPOSOCORR := aSCAN(aHeader,{|x| Trim(Upper(x[2])) == "TN_CODOCOR"})
	nPOSCAUSA := aSCAN(aHeader,{|x| Trim(Upper(x[2])) == "TN_CAUSA"})
	nPOSSOLUC := aSCAN(aHeader,{|x| Trim(Upper(x[2])) == "TN_SOLUCAO"})
	nPOSDESCR := aSCAN(aHeader,{|x| Trim(Upper(x[2])) == "TN_DESCRIC"})

	nContI := nContI + 2
	Private aCOLX[1][nContI+1]
	aCOLS := Aclone(aCOLX)

	dbSelectArea("STN")
	dbSetOrder(1)
	dbSeek(xFilial("STN")+cKEY)
	nCnt := 0
	While !EoF() .And. STN->TN_FILIAL == xFilial("STN") .And. STN->TN_ORDEM+STN->TN_PLANO+STN->TN_TAREFA+STN->TN_SEQRELA == cKEY
		nCnt++
		dbSkip()
	End

	aCols := MAKEGETD("STN",cKEY,aHeader,cGETWHILE)
	If Empty(aCols)
		aCols := BLANKGETD(aHeader)
	EndIf

	lCORRET := Val(STL->TL_PLANO) == 0
	If lCORRET .And. NGUSATARPAD()
		aAdd(aTrocaF3,{"TL_TAREFA","TT9"})
	EndIf

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0015) From 0,0 To nLinFimTla,nColFimTla OF oMainWnd Pixel Style nOR(WS_VISIBLE,WS_POPUP) //"Retorno Tarefas"

		oPnlTot       := TPanel():New(000,000,,oDlg,,,,,CLR_WHITE,000,000)
		oPnlTot:Align := CONTROL_ALIGN_ALLCLIENT

		oEncComp            := Msmget():New("STL",nSalvoRec,4,,,,aFields,,,3,,,,oPnlTot,,,.F.)
		oEncComp:oBox:Align := CONTROL_ALIGN_TOP

		nPosTar := aScan(oEncComp:AENTRYCTRLS,{|x| "TL_TAREFA" $ x:cREADVAR})
		oEncComp:AENTRYCTRLS[nPosTar]:bWhen  := {|| .T.}

		oGet               := MSGetDados():New(000,000,000,000,4,"M400STNLIN()" ,"M400STNTUD()" ,"",.T.,,,,3000,,,,,oPnlTot)
		oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

		NGPOPUP(asMenu,@oMenu)
		oDlg:bRClicked          := { |o,x,y| oMenu:Activate(x,y,oDlg)}
		oEncComp:oBox:bRClicked := { |o,x,y| oMenu:Activate(x,y,oDlg)}

	Activate MsDialog oDLG On Init EnchoiceBar(oDLG,{||nOpca:=1,IIf(oGet:tudook(),oDLG:End(),.F.)},{||nOpca := 0,oDLG:End()},;
											   AlignObject(oDlg,{oEncComp:oBox,oGet:oBrowse},1)) Center

	If nOpca == 1
		If NGIFDBSEEK("STL",cChaveSTL,1,.F.)
			RecLock("STL",.F.)
			STL->TL_TAREFA  := M->TL_TAREFA
			STL->TL_LOTECTL := M->TL_LOTECTL
			STL->TL_NUMLOTE := M->TL_NUMLOTE
			STL->TL_GARANTI := M->TL_GARANTI
			STL->TL_OBSERVA := M->TL_OBSERVA
			MsUnLock("STL")

			/* Ponto de Entrada criado com o objetivo de gravar campos de
			usuários, após a confirmação da tela de Complemento.*/
			If lMNTA4014
				ExecBlock("MNTA4014")
			EndIf

		EndIf

		If NGIFDBSEEK("STN",cKEY,1,.F.)
			While !EoF() .And. STN->TN_FILIAL == xFilial("STN") .And. STN->TN_ORDEM+STN->TN_PLANO+;
			STN->TN_TAREFA+STN->TN_SEQRELA = cKEY
				RecLock("STN",.F.)
				dbDelete()
				MsUnLock("STN")
				dbSkip()
			End
		EndIf

		For nI := 1 to Len(aCols)
			If !aCols[nI][Len(aHeader)+1]  .And. !Empty(aCols[nI,nPOSOCORR])
				If !NGIFDBSEEK("STN",cChavSTLP+M->TL_TAREFA+cChavSTLS+aCols[nI][nPOSOCORR]+;
				aCols[nI][nPOSCAUSA]+aCols[nI][nPOSSOLUC],1,.F.)
					RecLock("STN",.T.)
					STN->TN_FILIAL  := xFilial("STN")
					STN->TN_ORDEM   := STL->TL_ORDEM
					STN->TN_PLANO   := STL->TL_PLANO
					STN->TN_TAREFA  := M->TL_TAREFA
					STN->TN_SEQRELA := STL->TL_SEQRELA
					STN->TN_CODOCOR := aCols[nI][nPOSOCORR]
					STN->TN_CAUSA   := aCols[nI][nPOSCAUSA]
					STN->TN_SOLUCAO := aCols[nI][nPOSSOLUC]
					STN->TN_DESCRIC := aCols[nI][nPOSDESCR]
					MsUnLock("STN")
				EndIf
			EndIf
		Next
		If M->TL_GARANTI = "N"
			NGDELTODASGA(STJ->TJ_ORDEM,STJ->TJ_PLANO,STL->TL_SEQRELA)
		EndIf

		If NGFUNCRPO("SgaMntEst",.F.) .And. GetMv("MV_SGAMNT") == "S" .And. GetMv("MV_NGSGAES") <> "N"
			cAliasQry := GetNextAlias()
			cQuery := " SELECT 1 "
			cQuery += " FROM " + RetSqlName("TB0")
			cQuery += " WHERE TB0_DATA   = '" + DTOS(STL->TL_DTINICI) + "'"
			cQuery += " AND   TB0_HORA   = '" + STL->TL_HOINICI + "'"
			cQuery += " AND   TB0_ORDEM  = '" + STL->TL_ORDEM   + "'"
			cQuery += " AND   TB0_NUMSEQ = '" + STL->TL_NUMSEQ  + "'"
			cQuery += " AND   TB0_ORIGEM = '2' "
			cQuery += " AND   D_E_L_E_T_ <> '*' "
			cQuery := ChangeQuery(cQuery)
			dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
			dbGoTop()
			If EoF()
				SgaMntEst(3)
			End
			(cAliasQry)->(dbCloseArea())
		EndIf
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400GAR

@author Marcos Wagner Junior
@since 27/02/09
@version undefined
@param cLocaliz, characters
@param nQtde, numeric
@param cUni, characters
@param nQtdeC, numeric
@param cCont, characters
@type function
/*/
//---------------------------------------------------------------------
Function MNT400GAR(cLocaliz,nQtde,cUni,nQtdeC,cCont)

	Local lRet := .T.

	If !NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)
		If Empty(cLocaliz) .And. Empty(nQtde) .And. Empty(cUni) .And. Empty(cCont)
			lRet := .F.
			oDlg1:End()
		ElseIf Empty(nQtde) .And. (!Empty(cUni) .OR. !Empty(cCont))
			MsgStop(STR0252+STR0071+STR0253) //"O campo "###"Qde"###" deverá ser preenchido!"
			lRet := .F.
		ElseIf !Empty(nQtde) .And. Empty(cUni) .And. Empty(cCont)
			MsgStop(STR0252+STR0072+STR0254+STR0124+STR0253) //"O campo "###"Unidade"###" ou "###"Tp Contador"###" deverá ser preenchido!"
			lRet := .F.
		ElseIf (!Empty(cUni) .OR. !Empty(cCont)) .And. Empty(nQtde)
			MsgStop(STR0252+STR0071+STR0253) //"O campo "###"Qde"###" deverá ser preenchido!"
			lRet := .F.
		EndIf
	Else
		If Empty(cLocaliz) .And. Empty(nQtde) .And. Empty(cUni) .And. Empty(nQtdeC) .And. Empty(cCont)
			lRet := .F.
			oDlg1:End()
		ElseIf !Empty(nQtde) .And. Empty(cUni)
			MsgStop(STR0252+STR0072+STR0253) //"O campo "###"Unidade"###" deverá ser preenchido!"
			lRet := .F.
		ElseIf Empty(nQtde) .And. !Empty(cUni)
			MsgStop(STR0252+STR0071+STR0253) //"O campo "###"Qde"###" deverá ser preenchido!"
			lRet := .F.
		ElseIf !Empty(nQtdeC) .And. Empty(cCont)
			MsgStop(STR0252+STR0124+STR0253) //"O campo "###"Tp Contador"###" deverá ser preenchido!"
			lRet := .F.
		ElseIf Empty(nQtdeC) .And. !Empty(cCont)
			MsgStop(STR0252+STR0071+STR0253) //"O campo "###"Qde"###" deverá ser preenchido!"
			lRet := .F.
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNA400GEPA
Grava as Etapas
@author Marcos Wagner Junior
@since 16/03/09
@version undefined
@param lRotF6, Logico, Se é utilizado via F6 de insumos.
@type function
/*/
//---------------------------------------------------------------------
Function MNA400GEPA(lRotF6)

	Local nfor
	Local cForm, cResp, cServCar, cTipoMan, cMsgSS
	Local lTpGeraOS, lTPGeraSS, lCondicao
	Local aSolic  := {}
	Local cTRBK400, cTRBZ400
	Local oTmp400Z, oTmp400K //Obj. Tab. Temporária
	Local oTmpZ400 //Objeto da tabela temporária cTRBZ400

	Default lRotF6 := .F.

	Store .F. To lTpGeraOS, lTPGeraSS, lCondicao
	If Type( "lTelaEtapa" ) != "L"
		lTelaEtapa := .F.
	EndIf

	If !lTelaEtapa
		Return
	EndIf

	nOPCY := 1
	dbSelectArea(cTRBQ400)
	dbGotop()
	If !EoF()
		nOPCY := 2
	EndIf

	If nOPCY == 2
		cORDSTJ := STJ->TJ_ORDEM
		cPLASTJ := STJ->TJ_PLANO
		cBEMSTJ := STJ->TJ_CODBEM
		cSERSTJ := STJ->TJ_SERVICO
		nSEQSTJ := STJ->TJ_SEQRELA
		nSEQOLD := STJ->TJ_SEQRELA
		cBEMOLD := STJ->TJ_CODBEM
		cSEROLD := STJ->TJ_SERVICO
		cNOSOLD := STJ->TJ_ORDEM

		aTRBZ := {}
		aTRBK := {}

		NGTRBACRIA(1,@cTRBZ400,@cTRBK400,@oTmp400Z,@oTmp400K,@oTmpZ400) //Criação Tabela Temporária

		dbSelectArea(cTRBQ400)
		dbGotop()
		While !EoF()
			nSEQSTJ := nSEQOLD
			dbSelectArea("STQ")
			dbSetOrder(1)

			cChveSTQ := (cTRBQ400)->TQ_ORDEM+(cTRBQ400)->TQ_PLANO+(cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA

			If !dbSeek(xFilial('STQ')+cChveSTQ)
				RecLock("STQ",.T.)
				STQ->TQ_FILIAL  := xFilial("STQ")
				STQ->TQ_ORDEM   := (cTRBQ400)->TQ_ORDEM
				STQ->TQ_PLANO   := (cTRBQ400)->TQ_PLANO
				STQ->TQ_TAREFA  := (cTRBQ400)->TQ_TAREFA
				STQ->TQ_ETAPA   := (cTRBQ400)->TQ_ETAPA
				STQ->TQ_SEQETA  := (cTRBQ400)->TQ_SEQETA
			Else
				RecLock("STQ",.F.)
			EndIf
			STQ->TQ_OK := (cTRBQ400)->TQ_OK
			STQ->TQ_CODFUNC := (cTRBQ400)->TQ_CODFUNC
			MsUnLock("STQ")

			aArray  := {}
			aArray2 := {}

			// Opções de resposta das etapas
			// Verifica se houve marcação anteriormente
			If Empty((cTRBQ400)->TQ_OK)
				dbSelectArea("TPQ")
				dbSetOrder(1)
				If dbSeek(xFilial("TPQ")+(cTRBQ400)->TQ_ORDEM+(cTRBQ400)->TQ_PLANO+(cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA)

					While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And. TPQ->TPQ_ORDEM == (cTRBQ400)->TQ_ORDEM .And.;
					TPQ->TPQ_PLANO == (cTRBQ400)->TQ_PLANO .And. TPQ->TPQ_TAREFA == (cTRBQ400)->TQ_TAREFA .And.;
					TPQ->TPQ_ETAPA  == (cTRBQ400)->TQ_ETAPA
						RecLock('TPQ',.F.)
						DBDelete()
						MsUnLock('TPQ')
						dbSelectArea("TPQ")
						dbSkip()
					EndDo
				EndIf
			Else
				dbSelectArea("TPQ")
				dbSetOrder(1)
				If dbSeek(xFilial("TPQ")+(cTRBQ400)->TQ_ORDEM+(cTRBQ400)->TQ_PLANO+(cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA)

					While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And. TPQ->TPQ_ORDEM == (cTRBQ400)->TQ_ORDEM .And.;
					TPQ->TPQ_PLANO == (cTRBQ400)->TQ_PLANO .And. TPQ->TPQ_TAREFA == (cTRBQ400)->TQ_TAREFA .And.;
					TPQ->TPQ_ETAPA == (cTRBQ400)->TQ_ETAPA
						dbSelectArea(cTRB3400)
						dbSetOrder(1)
						If dbSeek((cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_TAREFA)
							dbSelectArea("TPQ")
							aAdd(aArray,{TPQ->TPQ_OPCAO,TPQ->TPQ_TAREFA})
							aAdd(aArray2,{TPQ->TPQ_RESPOS,TPQ->TPQ_TAREFA})
							RecLock('TPQ',.F.)
							DBDelete()
							MsUnLock('TPQ')
						EndIf
						dbSelectArea("TPQ")
						dbSkip()
					EndDo
				EndIf
				dbSelectArea(cTRB3400)
				dbSetOrder(1)
				If dbSeek((cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_TAREFA)
					While !EoF() .And. (cTRB3400)->TPC_ETAPA == (cTRBQ400)->TQ_ETAPA .And.;
					(cTRB3400)->TPC_TAREFA == (cTRBQ400)->TQ_TAREFA
						nSEQSTF := nSEQOLD
						cBEMSTJ := cBEMOLD
						lTPGeraSS := .F.
						lTPGeraOs := .F.
						dbSelectArea('TPQ')
						RecLock('TPQ',.T.)
						Replace TPQ_FILIAL With xFilial("TPQ"),;
						TPQ_ORDEM  With (cTRBQ400)->TQ_ORDEM,;
						TPQ_PLANO  With (cTRBQ400)->TQ_PLANO,;
						TPQ_TAREFA With (cTRBQ400)->TQ_TAREFA,;
						TPQ_ETAPA  With (cTRBQ400)->TQ_ETAPA,;
						TPQ_OPCAO  With (cTRB3400)->TPC_OPCAO,;
						TPQ_RESPOS With (cTRB3400)->TPC_RESPOS,;
						TPQ_OK     With (cTRBQ400)->TQ_OK
						If Len(aCposAlTPQ) > 0
							For nfor := 1 To Len(aCposAlTPQ)
								cCAMPTPQ  := "TPQ->"+aCposAlTPQ[nfor]
								cCAMPTRB  := (cTRB3400)+"->"+aCposAlTPQ[nfor]
								&cCAMPTPQ := &cCAMPTRB
							Next nfor
						EndIf
						MsUnLock('TPQ')
						cSERSTJ := (cTRB3400)->TPC_SERVIC

						If (cTRB3400)->TPC_TPMANU == '1'
							lTPGeraOs := .T.
							cTipoMan  := NGSEEK( "ST4", (cTRB3400)->TPC_SERVIC, 1, "T4_TIPOMAN")
							cServCar  := NGSEEK( "STE", cTipoMan, 1, "TE_CARACTE")
						ElseIf (cTRB3400)->TPC_TPMANU == '2'
							lTPGeraSS := .T.
							cServCar  := (cTRB3400)->TPC_SERVIC
						EndIf
						// IDENTIFICAÇAO DA GERAÇÃO DA ORDEM
						If (cTRB3400)->TPC_PORBEM == '2'
							cBEMOR := Space( TAMSX3('T9_CODBEM')[1] )
							If !Empty((cTRB3400)->TPC_DESCRI)
								cBEMOR := SubStr((cTRB3400)->tpc_descri,1,16)
								dbSelectArea("ST9")
								dbSetOrder(1)
								If !dbSeek(xFilial('ST9')+cBEMOR)
									cBemOr := Space( TAMSX3( 'T9_CODBEM')[1] )
								Else
									If lTPGeraOs
										If cServCar == 'P' // O.S. PREVENTIVA
											nSEQSTJ := IIf( AllTrim( nSEQSTF ) == '0', '1  ', nSEQSTJ )
											dbSelectArea("STF")
											dbSetOrder(1)
											If !dbSeek(xFilial('STF')+cBEMOR+cSERSTJ+nSEQSTJ)
												cBemOr := Space( TAMSX3( 'T9_CODBEM' )[1] )
											EndIf
										EndIf
									EndIf
								EndIf
							EndIf

							cBemSTJ := IIf( Empty( cBEMOR ), cBEMSTJ, cBEMOR )
						EndIf
						// PROCESSA A GERAÇÃO DE O.S.
						If !NG400VALOS(,(cTRB3400)->TPC_SERVIC,.F.)
							If (cTRB3400)->TPC_TIPRES == '2' // Informada
								If !Empty((cTRB3400)->TPC_RESPOS)
									dbSelectArea("TPC")
									dbSetOrder(1)
									If dbSeek( xFilial("TPC") + (cTRBQ400)->TQ_ETAPA + (cTRB3400)->TPC_OPCAO )
										lCONDICAO := .F.

										Do Case
											Case TPC->TPC_TIPCAM == "L"
											cResp := AllTrim( (cTRB3400)->TPC_RESPOS )

											Case TPC->TPC_TIPCAM == "N"
											cResp := cValToChar( Val( (cTRB3400)->TPC_RESPOS ) )
											Case TPC->TPC_TIPCAM == "D"
											cResp := "'" + DToS( cToD( (cTRB3400)->TPC_RESPOS ) ) + "'"
											Case TPC->TPC_TIPCAM == "C"
											cResp := "'" + AllTrim( (cTRB3400)->TPC_RESPOS ) + "'"
										EndCase
										cForm := StrTran( (cTRB3400)->TPC_FORMUL, '#RESP#', cResp )
										lCondicao := &( cForm )
									EndIf
								EndIf
							EndIf

							If lCondicao .Or. (cTRB3400)->TPC_TIPRES == '1'

								If lTPGeraOs
									If cServCar == 'P'
										cVPREVEN := IIf( (cTRB3400)->TPC_TIPRES == '1', NG400GPRE(), NG400GPRE('2') )

										If cVPREVEN[1]
											dbSelectArea("TPQ")
											dbSetOrder(01)
											If dbSeek( xFilial("TPQ") + (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA +;
											(cTRBQ400)->TQ_ETAPA + (cTRB3400)->TPC_OPCAO)
												RecLock("TPQ",.F.)
												TPQ->TPQ_ORDEMG := cVPREVEN[2]
												MsUnLock("TPQ")
											EndIf
										ElseIf !cVPREVEN[1] .And. !Empty( cVPREVEN[2] )
											MsgInfo( STR0411 + cVOSCORR[2]) //"Não foi possível gerar a OS. "
										EndIf
									ElseIf cServCar == 'C' // Gera O.S. automática após alterar a resposta da etapa.
										cVOSCORR := IIf( (cTRB3400)->TPC_TIPRES == '1', NG400GCOR(), NG400GCOR('2') )
										If cVOSCORR[1]
											dbSelectArea("TPQ")
											dbSetOrder(01)
											If dbSeek( xFilial("TPQ") + (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA +;
											(cTRBQ400)->TQ_ETAPA + (cTRB3400)->TPC_OPCAO )
												RecLock("TPQ",.F.)
												TPQ->TPQ_ORDEMG := cVOSCORR[2]
												MsUnLock("TPQ")
											EndIf
										ElseIf !cVOSCORR[1] .And. !Empty( cVOSCORR[2] )
											MsgInfo( STR0411 + cVOSCORR[2]) //"Não foi possível gerar a OS. "
										EndIf
									EndIf
								ElseIf lTPGeraSS

									cMsgSS := STR0412 + ": " + STJ->TJ_ORDEM + Chr(13) + Chr(10)			//"O.S. Origem"
									cMsgSS += STR0413 + ": " + (cTRB3400)->TPC_ETAPA + Chr(13) + Chr(10)	//"Etapa"
									cMsgSS += STR0414 + ": " + (cTRB3400)->TPC_OPCAO + Chr(13) + Chr(10)	//"Opção"

									If (cTRB3400)->TPC_TIPRES == '2'
										cMsgSS +=  STR0415 + ": " + (cTRB3400)->TPC_RESPOS //"Resposta"
									Else
										cMsgSS +=  STR0416 + ": " + STR0417 //"Marcou" ## "Sim"
									EndIf
									// aSolic := { Código do Bem, Ramal, Descrição da Solicitação, Serviço }
									aSolic := { { "TQB_CODBEM", cBemSTJ, Nil },;
												{ "TQB_RAMAL" , "0000", Nil },;
												{ "TQB_DESCSS", cMsgSS, Nil },;
												{ "TQB_CDSERV", (cTRB3400)->TPC_SERVIC, Nil } }
									lMSHelpAuto := .T. // Não apresenta erro em tela
									lMSErroAuto := .F. // Caso a variável torne-se .T. apos MsExecAuto, apresenta erro em tela
									MSExecAuto( {|x,z,y,w| MNTA280(x,z,y,w)},,, aSolic )
									If lMsErroAuto
										MostraErro()
									Else
										MsgInfo( STR0418 ) //"Foi gerada uma S.S. conforme a resposta da etapa!"
										dbSelectArea("TPQ")
										dbSetOrder(01)
										If dbSeek( xFilial("TPQ") + (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA +;
										(cTRBQ400)->TQ_ETAPA + (cTRB3400)->TPC_OPCAO )
											RecLock( "TPQ", .F.)
											TPQ->TPQ_ORDEMG := TQB->TQB_SOLICI
											MsUnLock("TPQ")
										EndIf
									EndIf
								EndIf
							EndIf
						EndIf
						dbSelectArea(cTRB3400)
						dbSkip()
					EndDo
				EndIf
			EndIf
			dbSelectArea(cTRBQ400)
			dbSkip()
		EndDo
	EndIf

	If nOPCY == 2

		dbSelectArea(cTRBZ400)
		dbGotop()
		If Reccount() > 0
			NGMOSTTRBZ()
		EndIf

		dbSelectArea(cTRBK400)
		dbGotop()
		If Reccount() > 0
			NGTRBKMOST()
		EndIf
		NGTRBACRIA(2,@cTRBZ400,@cTRBK400,@oTmp400Z,@oTmp400K,@oTmpZ400)//Deleção Tabela Temporária
	EndIf

	If lRotF6
		oTmpTbl3:Delete()//Deleta Tabela Temporária 3
		oTmpTbl4:Delete()//Deleta Tabela Temporária 4
		oTmpTbl5:Delete()//Deleta Tabela Temporária 3
		If lTmpTbl6
			oTmpTbl6:Delete()
			lTmpTbl6 := .F.
		EndIf
	EndIf

	lCriouTRBQ := .F.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} C
Verifica a resolucao do monitor e o tema p/ montar tela
@author Evaldo Cecinscki Jr.
@since 22/10/08
@version undefined
@param nTam, numeric
@type function
/*/
//---------------------------------------------------------------------
Static Function C(nTam)

	Local nHRes	:=	oMainWnd:nClientWidth	// Resolucao horizontal do monitor
	nTamRet := nTam

	If nHRes == 640	// Resolucao 640x480 (soh o Ocean e o Classic aceitam 640)
		nTamRet := nTam * 0.8
	ElseIf (nHRes == 798).Or.(nHRes == 800)	// Resolucao 800x600
		nTamRet := nTam * 1
	Else	//Resolucao 1024x768 e acima
		nTamRet := nTam * 1.28
	EndIf

	//+-------------------------------------------------------------------+
	//| Tratamento para tema "Flat"										  |
	//+-------------------------------------------------------------------+
	If "P10" $ oApp:cVersion
		If (Alltrim(GetTheme()) == "FLAT") .Or. SetMdiChild()
			nTamRet := nTam * 0.9
		EndIf
	EndIf

Return Int(nTamRet)

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400GF
Consistencia final na garantia do insumo
@author Inacio Luiz Kolling
@since 10/07/2009
@version undefined
@param lCont1, logical, Tem Contador 1            - Nao Obrigatorio
@param lCont2, logical, Tem Contador 2            - Nao Obrigatorio
@type function
/*/
//---------------------------------------------------------------------
Function MNT400GF(lCont1,lCont2)

	Local lCon1 := If(lCont1 = Nil,.T.,lCont1)
	Local lCon2 := If(lCont2 = Nil,.T.,lCont2)
	lTesGar := .F.
	If !Empty(cUni)
		If !NGMAQUEZERO(nQtde,STR0069+" "+STR0187+" "+STR0188+" "+STR0071,,.T.)
			Return .F.
		EndIf
	EndIf

	If !Empty(cCont)
		If !NGMAQUEZERO(nQtdeC,STR0069+" "+STR0187+" "+STR0127+" "+STR0071,,.T.)
			Return .F.
		EndIf
	EndIf

	If (Empty(nQtde) .And. !Empty(cUni)) .Or. (Empty(nQtdeC) .And. !Empty(cCont))
		MsgStop(STR0308,STR0137) //"Informe a quantidade da garantia"
		Return .F.
	ElseIf (!Empty(nQtde) .And. Empty(cUni)) .Or. (!Empty(nQtdeC) .And. Empty(cCont))
		MsgStop(STR0309,STR0137)//"Informe a unidade da garantia"
		Return .F.
	ElseIf (Empty(nQtde) .And. Empty(cUni)) .And. (Empty(nQtdeC) .And. Empty(cCont))
		MsgStop(STR0310,STR0137) //"Informe o tipo de garantia"
		Return .F.
	EndIf

	If !Empty(nQtdeC)
		cTiPMC := Space(1)
		If  !lCon2 .And. cCont = STR0117
			cTiPMC := STR0117
		ElseIf !lCon1 .And. cCont = STR0116
			cTiPMC := STR0116
		EndIf
		If !Empty(cTiPMC)
			MsgStop(STR0031+" "+Alltrim(STJ->TJ_CODBEM)+" "+STR0028+" "+STR0231+" "+cTiPMC,STR0137)
			Return .F.
		EndIf
	EndIf
	lTesGar := .T.

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400STF
Apresenta tela com as Sequecias existentes na STF para um
mesmo Bem + Servico. O usuario devera selecionar a sequencia
que a OS Preventiva (Manual) sera gerada.
@author Denis Hyroshi de Souza
@since 21/07/2009
@version undefined
@param aRegSTF, array, Matriz com dados das sequencias da manutencao
@param _cOrdOrig, , OS Origem
@param _cBemOrig, , Codigo do Bem da OS origem
@param _cBemDest, , Codigo do Bem da Nova OS
@param _cSerOrig, , Codigo do Servico da OS origem
@param _cSerDest, , Codigo do Servico da Nova OS
@param _cEtaOrig, , Codigo da Etapa Respondida
@type function
/*/
//---------------------------------------------------------------------
Function MNT400STF(aRegSTF,_cOrdOrig,_cBemOrig,_cBemDest,_cSerOrig,_cSerDest,_cEtaOrig)

	Local nXX, nYY, nZZ, nXXX, oDlg1
	Local oChecked := LoadBitmap(GetResources(),'LBTIK')
	Local oUnCheck := LoadBitmap(GetResources(),'LBNO')
	Local cOrdOrig := _cOrdOrig
	Local cBemOrig := Alltrim(_cBemOrig) + " - " + NGSEEK("ST9",_cBemOrig,1,"ST9->T9_NOME")
	Local cBemDest := Alltrim(_cBemDest) + " - " + NGSEEK("ST9",_cBemDest,1,"ST9->T9_NOME")
	Local cSerOrig := Alltrim(_cSerOrig) + " - " + NGSEEK("ST4",_cSerOrig,1,"ST4->T4_NOME")
	Local cSerDest := Alltrim(_cSerDest) + " - " + NGSEEK("ST4",_cSerDest,1,"ST4->T4_NOME")
	Local cDsEtapa := Upper( NGSEEK("TPA",_cEtaOrig,1,"TPA->TPA_DESCRI") )

	Private oCdoArea, aCdoArea, bCdoArea
	aCdoArea := aClone(aRegSTF)

	For nXXX := 1 To Len(aCdoArea)
		aCdoArea[nXXX,1] := .F.
	Next nXXX

	opcaoZZ  := 0

	DEFINE MSDIALOG oDlg1 TITLE OemToAnsi(STR0276) from 10,15 To 35,110 of oMainwnd //"Sequências da Manutenção"
	oDlg1:lEscClose := .F.

	@ 3,3 SCROLLBOX oScr1 SIZE 183,370 OF oDlg1 BORDER

	@ 1,2   To 47, 175 Label STR0277 OF oScr1 PIXEL //"Dados da O.S. Origem"
	@ 10,5  SAY STR0278 OF oScr1 Pixel //"O.S."
	@ 10,40 MsGet cOrdOrig Of oScr1 Pixel Size 40,08 When .F.
	@ 22,5  SAY STR0031 OF oScr1 Pixel //"Bem"
	@ 22,40 MsGet cBemOrig Of oScr1 Pixel Size 120,08 When .F.
	@ 34,5  SAY STR0279 OF oScr1 Pixel //"Serviço"
	@ 34,40 MsGet cSerOrig Of oScr1 Pixel Size 120,08 When .F.

	@ 53,3  SAY STR0286+" '"+Alltrim(cDsEtapa)+"'." OF oScr1 Pixel //"Houve a necessidade de gerar uma O.S. Preventiva a partir da resposta da etapa"
	@ 63,3  SAY STR0299 OF oScr1 Pixel //"Selecionar a sequência da manutenção para gerar uma nova O.S."

	@ 1,187  To 35, 360 Label STR0285 OF oScr1 PIXEL //"Dados da Nova O.S."
	@ 10,191 SAY STR0031 OF oScr1 Pixel //"Bem"
	@ 10,225 MsGet cBemDest Of oScr1 Pixel Size 120,08 When .F.
	@ 22,191 SAY STR0279 OF oScr1 Pixel //"Serviço"
	@ 22,225 MsGet cSerDest Of oScr1 Pixel Size 120,08 When .F.

	oCdoArea := VCBrowse():New( 80 , 4, 362, 80,,{" ",STR0280,STR0281,STR0282,STR0283,STR0284},{10,25,80,40,60,60},; //"Sequência"//"Nome Manutenção"//"Última Manut."//"Área da Manut."//"Tipo de Manut."
	oScr1,,,,,{||},,,,,,,.F.,,.T.,,.F.,,.T.,.T.)
	oCdoArea:SetArray(aCdoArea)
	bCdoArea := { || { If(aCdoArea[oCdoArea:nAt,1],oChecked,oUnCheck), aCdoArea[oCdoArea:nAt,2], aCdoArea[oCdoArea:nAt,3],;
	aCdoArea[oCdoArea:nAt,4], aCdoArea[oCdoArea:nAt,5], aCdoArea[oCdoArea:nAt,6] } }
	oCdoArea:bLine:= bCdoArea
	oCdoArea:bLDblClick := {|| fMarkManut() }
	oCdoArea:nAt := 1

	DEFINE SBUTTON FROM 170,300 TYPE 1 ENABLE OF oDlg1 ACTION ( If( fVldMkMnt(.T.) 	,;
	(opcaoZZ := 1,oDlg1:End()),;
	(opcaoZZ := 0) ) )

	DEFINE SBUTTON FROM 170,330 TYPE 2 ENABLE OF oDlg1 ACTION ( If( fVldMkMnt(.F.) 	,;
	(opcaoZZ := 0,oDlg1:End()),;
	(opcaoZZ := 0) ) )

	ACTIVATE MSDIALOG oDlg1 CENTERED

	If opcaoZZ == 1
		For nXXX := 1 To Len(aCdoArea)
			If aCdoArea[nXXX,1]
				Return nXXX
			EndIf
		Next nXXX
	EndIf
Return 0

//---------------------------------------------------------------------
/*/{Protheus.doc} fMarkManut
Funcao para marcar/desmarcar opcao selecionada
@author Denis Hyroshi de Souza
@since 25/07/03
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Static Function fMarkManut()

	Local nXX

	For nXX := 1 To Len(aCdoArea)
		aCdoArea[nXX,1] := If( oCdoArea:nAt == nXX , .T. , .F. )
	Next nXX
	oCdoArea:Refresh()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fVldMkMnt
Valida tela de selecionar sequencia
@author Denis Hyroshi de Souza
@since 25/07/03
@version undefined
@param lTipo, logical
@type function
/*/
//---------------------------------------------------------------------
Static Function fVldMkMnt(lTipo)

	Local nXXX
	If lTipo
		For nXXX := 1 To Len(aCdoArea)
			If aCdoArea[nXXX,1]
				Return .T.
			EndIf
		Next nXXX
		MsgInfo(STR0296,STR0025) //"Atenção" //"Nenhuma sequência foi selecionada."
		Return .F.
	Else
		If !MsgYesNo(STR0297+" "+STR0298) //"Se cancelar esta tela, a O.S. Preventiva não será gerada."//"Confirma o cancelamento?"
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGX400ETA
Monta tela de inclusao ou exclusao da Etapa
@author Denis Hyroshi de Souza
@since 21/07/2009
@version undefined
@param cAlias, characters
@param nRecno, numeric
@param nOpcEta, numeric
@type function
/*/
//---------------------------------------------------------------------
Function NGX400ETA(cAlias , nRecno , nOpcEta)

	Local nRegist := 0

	Private nTpEtapa := nOpcEta

	If nOpcEta == 2
		//Nao pode excluir Etapa, caso a resposta desta etapa gerou uma OS e esta OS nao esta com situação cancelada
		If !Empty((cTRBQ400)->TQ_OK) .And. !Empty((cTRBQ400)->TQ_ETAPA)
			//Verifica se foi gerada OS para esta etapa, e a OS gerada nao esta cancelada
			If !MNT400OSG( (cTRBQ400)->TQ_ORDEM , (cTRBQ400)->TQ_PLANO , (cTRBQ400)->TQ_TAREFA , (cTRBQ400)->TQ_ETAPA , .T. , .T. )
				Return .F.
			ElseIf !MNT400SSG( (cTRBQ400)->TQ_ORDEM, (cTRBQ400)->TQ_PLANO, (cTRBQ400)->TQ_TAREFA, (cTRBQ400)->TQ_ETAPA, .T., .T. )
				Return .F.
			EndIf
		EndIf
	EndIf
	If ExistBlock("MNTA400B")
		If !ExecBlock("MNTA400B",.F.,.F.)
			Return .F.
		EndIf
	EndIf
	NGPROCETA(cAlias , nRecno , nOpcEta)
	dbSelectArea(cTRBQ400)
	pack
	dbGotop()
	While !EoF()
		If	!Empty((cTRBQ400)->TQ_ETAPA)
			nRegist := 1
		EndIf
		dbSelectArea(cTRBQ400)
		dbSkip()
	EndDo
	If nRegist == 0
		oMark:oBrowse:Disable()
	Else
		oMark:oBrowse:Enable()
	EndIf

	oMark:oBrowse:Refresh()
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400OSG
Verifica se a Opcao da Etapa Marcada, gerou uma OS automaticamente.
Se gerou OS e esta OS gerada nao for Cancelada, sera apresentada
mensagem e retorno .F.
@author Denis Hyroshi de Souza
@since 21/07/2009
@version undefined
@param _cOrdem,, Ordem de Servico
@param _cPlano,, Plano
@param _cTarefa,, Tarefa
@param _cEtapa,, Etapa
@param lMsg, logical, Indica se mostra help
@param lTipoOp,logical,Indica se é Exclusao (.T.) ou Alteracao (.F.) da Etapa
@type function
/*/
//---------------------------------------------------------------------
Function MNT400OSG(_cOrdem , _cPlano , _cTarefa , _cEtapa , lMsg , lTipoOp )

	Local aAreaXXX := GetArea()
	Local aAreaSTJ := STJ->(GetArea())
	Local aAreaTPQ := STJ->(GetArea())
	Local lRet      := .T.
	Local cMsgOS    := ""
	Local cTpManu   := Space( TAMSX3('TPC_TPMANU')[1] )
	Local lGerouOS  := .T.

	Default lMsg    := .T.
	Default lTipoOp := .F.

	dbSelectArea("STJ")
	Set Filter To

	dbSelectArea("TPQ")
	dbSetOrder(1)
	dbSeek( xFilial("TPQ") + _cOrdem + _cPlano + _cTarefa + _cEtapa )
	While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And.;
	TPQ->TPQ_ORDEM == _cOrdem .And. TPQ->TPQ_PLANO == _cPlano .And. ;
	TPQ->TPQ_TAREFA == _cTarefa .And. TPQ->TPQ_ETAPA == _cEtapa

		If !Empty(TPQ->TPQ_ORDEMG)
			cTpManu     := NGSEEK( "TPC", TPQ->TPQ_ETAPA + TPQ->TPQ_OPCAO, 1, "TPC_TPMANU" )
			lGerouOS    := ( cTpManu == '1' )
			If lGerouOS
				dbSelectArea("STJ")
				dbSetOrder(1)
				If dbSeek(xFilial("STJ")+TPQ->TPQ_ORDEMG)
					If STJ->TJ_SITUACA <> "C"
						lRet := .F.
						If !Empty(cMsgOS)
							cMsgOS += "/ "
						EndIf
						cMsgOS += TPQ->TPQ_ORDEMG
					EndIf
				EndIf
			EndIf
		EndIf

		dbSelectArea("TPQ")
		dbSkip()
	EndDo

	If Type("aIndSTJ") == "A" .And. Type("cCondicao") == "C"
		dbSelectArea("STJ")
		bFiltraBrw := {|| FilBrowse("STJ",@aIndSTJ,@cCondicao) }
		Eval(bFiltraBrw)
	ElseIf Type("aInd460R") == "A" .And. Type("ccond460R") == "C"
		dbSelectArea("STJ")
		bFiltraBrw := {|| FilBrowse("STJ",@aInd460R,@ccond460R) }
		Eval(bFiltraBrw)
	EndIf

	If !lRet .And. lMsg
		If lTipoOp
			If "/" $ cMsgOS
				ShowHelpDlg(STR0025,{STR0266},3,; //"Atenção" //"Não será possível excluir esta etapa, pois foram geradas O.S. através da etapa respondida."
				{STR0267+cMsgOS+STR0269},2) //"As O.S. " //" geradas deverão ser canceladas e em seguida esta etapa poderá ser excluída."
			Else
				ShowHelpDlg(STR0025,{STR0270},3,; //"Atenção" //"Não será possível excluir esta etapa, pois foi gerada uma O.S. através da etapa respondida."
				{STR0268+cMsgOS+STR0271},2) //"A O.S. " //" gerada deverá ser cancelada e em seguida esta etapa poderá ser excluída."
			EndIf
		Else
			If "/" $ cMsgOS
				ShowHelpDlg(STR0025,{STR0272},3,; //"Atenção" //"Não será possível desmarcar esta etapa, pois foram geradas O.S. através da etapa respondida."
				{STR0267+cMsgOS+STR0273},2) //"As O.S. " //" geradas deverão ser canceladas e em seguida esta etapa poderá ser desmarcada."
			Else
				ShowHelpDlg(STR0025,{STR0274},3,; //"Atenção" //"Não será possível desmarcar esta etapa, pois foi gerada uma O.S. através da etapa respondida."
				{STR0268+cMsgOS+STR0275},2) //"A O.S. " //" gerada deverá ser cancelada e em seguida esta etapa poderá ser desmarcada."
			EndIf
		EndIf
	EndIf

	RestArea(aAreaSTJ)
	RestArea(aAreaTPQ)
	RestArea(aAreaXXX)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NGFIMOBRIG
Verifica se os campos Data/Hora Manutencao Real Inicio/Fim
foram preenchidos e demais validacoes
@author Marcos Wagner Junior
@since 29/07/2009
@version undefined
@param _dDataIni, , Data Manutencao Real Inicio
@param _cHoraIni, , Data Manutencao Real Inicio
@param _dDataFim, , Data Manutencao Real Fim
@param _cHoraFim, , Data Manutencao Real Fim
@type function
/*/
//---------------------------------------------------------------------
Function NGFIMOBRIG(_dDataIni,_cHoraIni,_dDataFim,_cHoraFim)

	Local cDINIBASE := Alltrim( FWX3Titulo( 'TJ_DTMRINI' ) )
	Local cHINIBASE := Alltrim( FWX3Titulo( 'TJ_HOMRINI' ) )
	Local cDFIMBASE := Alltrim( FWX3Titulo( 'TJ_DTMRFIM' ) )
	Local cHFIMBASE := Alltrim( FWX3Titulo( 'TJ_HOMRFIM' ) )

	If Empty(_dDataIni)
		MsgStop("'"+cDINIBASE+"'"+STR0303,STR0022) //" deverá ser preenchido!"###"ATENCAO"
		Return .F.
	ElseIf Empty(_cHoraIni)
		MsgStop("'"+cHINIBASE+"'"+STR0303,STR0022) //" deverá ser preenchido!"###"ATENCAO"
		Return .F.
	ElseIf Empty(_dDataFim)
		MsgStop("'"+cDFIMBASE+"'"+STR0303,STR0022) //" deverá ser preenchido!"###"ATENCAO"
		Return .F.
	ElseIf Empty(_cHoraFim)
		MsgStop("'"+cHFIMBASE+"'"+STR0303,STR0022) //" deverá ser preenchido!"###"ATENCAO"
		Return .F.
	EndIf

	If _dDataIni < STJ->TJ_DTORIGI
		MsgStop("'"+cDINIBASE+"'"+STR0305+DTOC(STJ->TJ_DTORIGI),STR0022) //" deverá ser maior ou igual à "###"ATENCAO"
		Return .F.
	ElseIf _dDataIni == STJ->TJ_DTORIGI .And. _cHoraIni < STJ->TJ_HOMPINI
		MsgStop("'"+cHINIBASE+"'"+STR0305+STJ->TJ_HOMPINI,STR0022) //" deverá ser maior ou igual à "###"ATENCAO"
		Return .F.
	EndIf

	If _dDataIni > dDATABASE
		MsgStop("'"+cDINIBASE+"'"+STR0302,STR0022) //" não poderá ser maior que a data atual!"###"ATENCAO"
		Return .F.
	ElseIf _dDataFim > dDATABASE
		MsgStop("'"+cDFIMBASE+"'"+STR0302,STR0022) //" não poderá ser maior que a data atual!"###"ATENCAO"
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400RELAC
Adiciona o relacao nos campos da tabela STJ
@author Inacio Luiz Kolling
@since 06/04/2011
@version undefined
@param lSoProd, logical
@param lInRela, logical
@type function
/*/
//---------------------------------------------------------------------
Function MNT400RELAC(lSoProd,lInRela)

	Local cBemRet   := ''
	Local cHoraCo1	:= ""
	Local cHoraCo2	:= ""
	Local aArCamp := {{"TJ_DTMRINI","STJ->TJ_DTMPINI"},{"TJ_HOMRINI","STJ->TJ_HOMPINI"},{"TJ_DTMRFIM", "STJ->TJ_DTMPFIM"},;
					  {"TJ_HOMRFIM","STJ->TJ_HOMPFIM"}},nFi := 0
	Local lValHrCo2 := .T.

	If lInRela = Nil
		lFimOSWhen := .F.
		If lSoProd = Nil
			lSoTemP := NGINSPRODDH(STJ->TJ_ORDEM,STJ->TJ_PLANO)[1]
		Else
			lSoTemP := lSoProd
		EndIf
		If lSoTemP
			lFimOSWhen := .T.
			For nFi := 1 To Len(aArCamp)
				nPosIn := Ascan(aRELAC ,{|x| x[1] == aArCamp[nFi,1]})
				If nPosin >0
					aRELAC[nPosin,2] := aArCamp[nFi,2]
				EndIf
			Next nFi
		EndIf
	EndIf

	cBemRet  := NGTBEMPAI( STJ->TJ_CODBEM, cBemRet)
	cBemRet  := IIf( Empty(cBEMRET), STJ->TJ_CODBEM, cBemRet )

	If NGIFDBSEEK( "ST9",cBemRet,01,.F. )
		cHoraCo1 := If( ST9->T9_TEMCONT == "S","hORFIM",If( Type( "cEmptyHour" ) == "C","cEmptyHour","STJ->TJ_HORACO1" ) )
	EndIf

	//FindFunction remover na release GetRPORelease() >= '12.1.027'
	If FindFunction("MNTCont2")
		lValHrCo2 := MNTCont2(xFilial('TPE'), cBemRet)
	EndIf
	If lValHrCo2
		cHoraCo2 := If ( NGIFDBSEEK( "TPP",cBemRet,02,.F. ),"hORFIM",If( Type( "cEmptyHour" ) == "C","cEmptyHour","STJ->TJ_HORACO2" ) ) // ##Indice: TPP_FILIAL+TPP_CODBEM+DTOS(TPP_DTORIG)+DTOS(TPP_DTLEIT)
	EndIf

	aArr1 := {{"TJ_DTMRINI","dDTINI"},{"TJ_HOMRINI","hORINI"},{"TJ_HOMRFIM","hORFIM"},{"TJ_DTMRFIM","dDTFIM"},;
			  {"TJ_HORACO1",cHoraCo1},{"TJ_HORACO2",cHoraCo2},{"TJ_POSCONT","vCONLA[1]"}}

	If ExistBlock("MNTA400J")
		aArr := ExecBlock("MNTA400J",.F.,.F.,aArr1)
	Else
		aArr := aArr1
	EndIf

Return If(lInRela = Nil,.T., aArr)

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400VINPR
Checa se ha insumo previsto com quantidade ainda nao reportada
@author Elisangela Costa
@since 19/05/2008
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG400VINPR()

	Local aARINSPRE := {},nQUATINS := 0, nQUANDIF := 0, xy := 0
	Local lINSSEMR  := .F.
	Local aInsFRea  := {}
	aInsFPre        := {}

	dbSelectArea("STL")
	dbSetOrder(1)
	dbSeek(xFilial("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO)
	While !EoF() .And. STL->TL_FILIAL == xFilial("STL");
	.And. STL->TL_ORDEM == STJ->TJ_ORDEM .And. STL->TL_PLANO == STJ->TJ_PLANO

		If Alltrim(STL->TL_SEQRELA) == "0"

			nPosIn := Ascan(aInsFPre ,{|x| x[1]+x[2]+x[3] == STL->TL_TAREFA+STL->TL_TIPOREG+STL->TL_CODIGO})
			If nPosIn = 0
				aAdd(aInsFPre ,{STL->TL_TAREFA,STL->TL_TIPOREG,STL->TL_CODIGO,STL->TL_QUANTID})
			Else
				aInsFPre [nPosIn,4] += STL->TL_QUANTID
			EndIf
			aAdd(aARINSPRE,{STL->TL_TAREFA,STL->TL_TIPOREG,STL->TL_CODIGO,STL->TL_QUANTID})
		Else
			nPosIn := Ascan(aInsFRea ,{|x| x[1]+x[2]+x[3] == STL->TL_TAREFA+STL->TL_TIPOREG+STL->TL_CODIGO})
			If nPosIn = 0
				aAdd(aInsFRea ,{STL->TL_TAREFA,STL->TL_TIPOREG,STL->TL_CODIGO,STL->TL_QUANTID})
			Else
				If STL->TL_TIPOREG <> "P"
					vVETHORAS := NGTQUATI2(STL->TL_CODIGO,STL->TL_TIPOREG,STL->TL_USACALE,;
					STL->TL_QUANTID,STL->TL_TIPOHOR,STL->TL_DTINICI,;
					STL->TL_HOINICI,STL->TL_DTFIM,STL->TL_HOFIM,STL->TL_UNIDADE,;
					STL->TL_SEQRELA,STJ->TJ_CODBEM,;
					STJ->TJ_SERVICO,STJ->TJ_SEQRELA,;
					STJ->TJ_PLANO)
					nQUATINS := vVETHORAS[1]
				Else
					nQUATINS := STL->TL_QUANTID
				EndIf
				aInsFRea[nPosIn,4] += nQUATINS
			EndIf
		EndIf
		dbSelectArea("STL")
		dbSkip()
	EndDo

	aReaAux := Aclone(aInsFRea)
	vReaDel := {}
	vPreDel := {}

	For xy := 1 To Len(aInsFRea)
		nPosIn := Ascan(aInsFPre ,{|x| x[1]+x[2]+x[3] == aInsFRea[xy,1]+aInsFRea[xy,2]+aInsFRea[xy,3]})
		If nPosIn = 0
			aAdd(vReaDel,xy)
		EndIf
	Next xy

	aInsFRea := {}
	For xy := 1 To Len(aReaAux)
		If Ascan(vReaDel,{|x| x == xy}) = 0
			aAdd(aInsFRea,aReaAux[xy])
		EndIf
	Next xy

	For xy := 1 To Len(aARINSPRE)
		nPosIn := Ascan(aInsFRea ,{|x| x[1]+x[2]+x[3] == aARINSPRE[xy,1]+aARINSPRE[xy,2]+aARINSPRE[xy,3]})
		If nPosIn > 0
			If aInsFRea[nPosIn,4] = aARINSPRE[xY,4]
				Adel(aInsFRea,nPosin)
				Asize(aInsFRea,Len(aInsFRea)-1)
				aAdd(vPreDel,xy)
			Else
				If aInsFRea[nPosIn,4] > aARINSPRE[xY,4]
					aInsFRea[nPosIn,4] -= aARINSPRE[xY,4]
					aAdd(vPreDel,xy)
				Else
					aARINSPRE[xY,4] -=  aInsFRea[nPosIn,4]
					Adel(aInsFRea,nPosin)
					Asize(aInsFRea,Len(aInsFRea)-1)
				EndIf
			EndIf
		EndIf
	Next xy
	aInsFPre := {}
	For xy := 1 To Len(aARINSPRE)
		If Ascan(vPreDel,{|x| x == xy}) = 0
			aAdd(aInsFPre,aARINSPRE[xy])
		EndIf
	Next xy

Return aInsFPre

//---------------------------------------------------------------------
/*/{Protheus.doc} NGTQUATI2
Faz o tratamento da quantidade de insumo (tipo de unidade,
tipo de hora, tratamento do calendario quando mao de obra)
para insumos do  tipo M=MAO DE OBRA, E=ESPECIALIDADE,
F=FERRAMENTA e T=TERCEIRO
@author Elisangela Costa
@since 07/12/06
@version undefined
@param cCodIns , characters, Codigo do Insumo           - Obrigatorio
@param cTipoIns, characters, Tipo do Insumo             - Obrigatorio
@param cUsaCale, characters,Indica utilizacao de calendario quando mao de obra, Obg.
@param nQuantid, numeric   , Quantidade aplicada        - Obrigatorio
@param cTipoHor, characters, Tipo de Hora               - Obrigatorio
@param dDataIni, date      , Data Inicio aplicacao ins  - Obrigatorio
@param cHorInic, characters, Hora Inicio aplicacao ins. - Obrigatorio
@param dDataFim, date      , Data Fim aplicacao ins.    - Obrigatorio
@param cHoraFim, characters, Hora Fim aplicacao ins.    - Obrigatorio
@param cUnidade, characters, Unidade de medida          - Obrigatorio
@param VSeqIns ,           , Sequencia do Insumo        - Obrigatorio
@param cCodBem , characters, Codigo do Bem              - Obrigatorio
@param cServico, characters, Servico da Manutencao      - Obrigatorio
@param VSeq    ,           , Sequencia da Manutencao    - Obrigatorio
@param cPlano  , characters, Sequencia da Manutencao    - Obrigatorio
@type function
@return aVETQUANT Pos = 1 Hora decimal(Ex: 01:30 retorna 1,50) numer.
@return Pos = [2] Hora em formato decimal mais como hora  (Ex: 1:30 retorna 1,30) em numerico
@return Pos = [3] Hora sexagesimal (Ex: 1,50 retorna 01:30) em caracter
/*/
//---------------------------------------------------------------------
Static Function NGTQUATI2( cCodIns, cTipoIns, cUsaCale, nQuantid, cTipoHor, dDataIni, cHorInic, dDataFim,;
						   cHoraFim, cUnidade, VSeqIns, cCodBem, cServico, VSeq, cPlano)

	Local nHORDEC   := 0.0     //Hora em decimal  1,50 (numerico)
	Local nHORANUM  := 0.0     //Hora em numerico 1,30 (numerico)
	Local cHORASE   := "00:00" //Hora em formato sexagesimal 01:30 (Caracter)
	Local vVETHODH  := {}, aVETQUANT := {}
	Local cCALENDIN
	Local VSEQUENC  := If(ValType(VSEQ) = "C",VSEQ,Str(VSEQ,3))

	If cTIPOINS <> "P"
		If cUNIDADE = "H"
			If cTIPOHOR = "S"
				vVETHODH := NGRETHORDDH(nQUANTID)
				nHORDEC  := vVETHODH[2]
				nHORANUM := nQUANTID
				cHORASE  := vVETHODH[1]
			Else
				nHORDEC  := nQUANTID
				nHORANUM := NGRHODSEXN(nQUANTID,cTIPOHOR)
				cHORASE  := NTOH(nQUANTID)
			EndIf
		Else
			If cUSACALE == "S"  .And. cTIPOINS == "M"
				cCALENDIN := NGSEEK("ST1",Substr(cCODINS,1,6),1,"T1_TURNO")
				nHORA := NGCALENHORA(dDATAINI,cHORINIC,dDATAFIM,cHORAFIM,cCALENDIN)
				vVETHODH := NGRETHORDDH(nHORA)
				nHORDEC  := vVETHODH[2]
				nHORANUM := nHORA
				cHORASE  := vVETHODH[1]
			Else
				//Verifica a quantidade de horas para insumos previstos pelo calendario da manutencao
				//quando unidade diferente de Horas
				If cPLANO > "000000" .And. Alltrim(VSEQINS) == '0'
					cCALENDIN := NGSEEK("STF",cCODBEM+cSERVICO+VSEQUENC,1,"TF_CALENDA")
					nHORA := NGCALENHORA(dDATAINI,cHORINIC,dDATAFIM,cHORAFIM,cCALENDIN)
					vVETHODH := NGRETHORDDH(nHORA)
					nHORDEC  := vVETHODH[2]
					nHORANUM := nHORA
					cHORASE  := vVETHODH[1]
				Else
					nHORA := NGCALCH100(dDATAINI,cHORINIC,dDATAFIM,cHORAFIM)
					nHORDEC  := nHORA
					nHORANUM := NGRHODSEXN(nHORA,"D")
					cHORASE  := NTOH(nHORA)
				EndIf
			EndIf
		EndIf
		aVETQUANT := {nHORDEC,nHORANUM,cHORASE}
	Else
		aVETQUANT := {nQUANTID,nQUANTID,nQUANTID}
	EndIf

Return aVETQUANT

//---------------------------------------------------------------------
/*/{Protheus.doc} NGDELTODASGA
Deleta todas as garantias do insumo
@author Inacio Luiz Kolling
@since 05/05/2010
@version undefined
@param cORDEM, characters
@param cPLANO, characters
@param cSEQRELA, characters
@type function
/*/
//---------------------------------------------------------------------
Function NGDELTODASGA(cORDEM,cPLANO,cSEQRELA)

	If NGIFDBSEEK("TPZ",cORDEM+cPLANO+cSEQRELA,2,.F.)
		While !EoF() .And. TPZ->TPZ_FILIAL == xFilial( "TPZ" ) .And.;
		TPZ->TPZ_ORDEM == cOrdem .And. TPZ->TPZ_PLANO == cPlano .And.;
		TPZ->TPZ_SEQREL == cSeqRela
			RecLock("TPZ",.F.)
			dbDelete()
			MSUNLOCK("TPZ")
			dbSkip()
		EndDo
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400VLDC
Função para validar a alteração de Data/Horário conforme, o calendário.
@author Microsiga
@since 18/28/10
@version undefined
@param dINICI, date
@param cHOINI, characters
@type function
/*/
//---------------------------------------------------------------------
Function MNT400VLDC(dINICI,cHOINI)

	Local i

	If !Empty(cCALEND)
		lHRCAL := .T.
		For i := 1 to Len(aCols)
			If !NGVALHRCALE(cCALEND,dINICI,cHOINI,"I")
				Return .F.
			EndIf
		Next i
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} HRINIFOS
Valida a hora para avisa que a hora e maior que a hora atual.

@type function

@author Taina A. Cardoso
@since 17/12/10
/*/
//---------------------------------------------------------------------
Function HRINIFOS()

	If ReadVar() == 'M->TJ_HOPRINI' .And. M->TJ_DTPRINI == dDataBase .And. M->TJ_HOPRINI > SubStr( Time(),1,5 )

		If !MsgYesNo( STR0323 ) // A 'Ho.Par.Re.I' é maior que a hora atual, deseja continuar?
			Return .F.
		EndIf

	EndIf

	If M->TJ_DTPRFIM > dDataBase .And. M->TJ_DTPRINI < M->TJ_DTPRFIM
		lRet := MsgYesNo( STR0363 )//"A 'Dt.Par.Re.F.' é maior que a data atual, deseja continuar?."
		If !lRet
			Return .F.
		EndIf
	EndIf

	If !Empty(M->TJ_DTPRFIM) .And. !Empty(M->TJ_DTPRINI) .And. DTOS(M->TJ_DTPRFIM) < DTOS(M->TJ_DTPRINI)
		MsgStop(STR0326)//"'Dt.Par.Re.F.' não pode ser menor que a 'Dt.Par.Ref.I.'."
		Return .F.
	EndIf

	If M->TJ_DTPRFIM == M->TJ_DTPRINI .And. (!Empty(M->TJ_HOPRFIM) .And. Alltrim(M->TJ_HOPRFIM) <> ":");
	.And. HTOM(M->TJ_HOPRINI) >= HTOM(M->TJ_HOPRFIM)

		MsgStop(STR0339) //"A 'Ho.Par.Re.I.' não pode ser maior que a 'Ho.Par.Re.F.'"
		Return .F.
	EndIf

	If ReadVar() = 'M->TJ_HORACO1'
		If M->TJ_DTORIGI == dDataBase .And. M->TJ_DTORIGI >= Date()
			If M->TJ_HORACO1 > SubStr(Time(),1,5)
				MsgStop(STR0393) //"A hora do contador não pode ser maior que a hora atual."
				Return .F.
			ElseIf M->TJ_HORACO2 > SubStr(Time(),1,5)
				MsgStop(STR0394) //"A hora do segundo contador não pode ser maior que a hora atual."
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} HRFUNIS
Valida a hora de para fim
@author Taina A. Cardoso
@since 13/01/11
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function HRFUNIS()

	If DTOS(M->TJ_DTPRFIM) == DTOS(M->TJ_DTPRINI) .And. !Empty(M->TJ_DTPRINI)
		If HTOM(M->TJ_HOPRFIM) <= HTOM(M->TJ_HOPRINI)
			MsgStop(STR0364) //"A 'Ho.Par.Re.F.' nao poder ser menor ou igual que a 'Ho.Par.Re.I.'"
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} DTHMOAT
Valida as Horas fim e Inicio, Data fim e inicio dos motivos de atraso das S.S.
@author Taina A. Cardoso
@since 23/12/10
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function DTHMOAT()

	Local  nDTITPL,nHOITPL,nDTFTPL,nHOFTPL
	Store 0 To nDTITPL,nHOITPL,nDTFTPL,nHOFTPL

	If Type("aHeader") == "A"   // Chamada para consertar problema de variavéis e dicionário feito na SS 014765
		nDTITPL := GDFIELDPOS("TPL_DTINIC")
		nHOITPL := GDFIELDPOS("TPL_HOINIC")
		nDTFTPL := GDFIELDPOS("TPL_DTFIM")
		nHOFTPL := GDFIELDPOS("TPL_HOFIM")
		If  nDTITPL >0 .And.  nHOITPL >0 .And. nDTFTPL > 0 .And. nHOFTPL > 0
			If ReadVar() = "M->TPL_DTINIC"
				M->TPL_HOINIC := aCols[n,nHOITPL]
				M->TPL_DTFIM := aCols[n,nDTFTPL]
				M->TPL_HOFIM := aCols[n,nHOFTPL]
			ElseIF ReadVar() = "M->TPL_HOINIC"
				M->TPL_DTINIC := aCols[n,nDTITPL]
				M->TPL_DTFIM := aCols[n,nDTFTPL]
				M->TPL_HOFIM := aCols[n,nHOFTPL]
			ElseIF ReadVar() = "M->TPL_DTFIM"
				M->TPL_DTINIC:= aCols[n,nDTITPL]
				M->TPL_HOINIC := aCols[n,nHOITPL]
				M->TPL_HOFIM := aCols[n,nHOFTPL]
			ElseIF ReadVar() = "M->TPL_HOFIM"
				M->TPL_DTINIC:= aCols[n,nDTITPL]
				M->TPL_HOINIC := aCols[n,nHOITPL]
				M->TPL_DTFIM := aCols[n,nDTFTPL]
			EndIf
		EndIf
	EndIf

	If M->TPL_DTINIC > dDataBase
		Help("",1,STR0025,,STR0328,3,1) //Data Inicio não pode ser maior que a data atual.
		Return .F.
	EndIf

	If M->TPL_DTFIM >	dDataBase
		Help(" ",1,STR0025,,STR0329,3,1) //"Data Fim não pode ser maior que a data atual."
		Return .F.
	EndIf
	If M->TPL_DTINIC == dDataBase .And. M->TPL_HOINIC > SubStr(Time(),1,5)
		Help(" ",1,STR0025,,STR0330,3,1) //"A hora Inicio não pode ser maior que a hora atual."
		Return .F.
	EndIf

	If M->TPL_DTFIM == dDataBase .And. !Empty(M->TPL_HOFIM) .And. M->TPL_HOFIM > SubStr(Time(),1,5)
		Help(" ",1,STR0025,,STR0331,3,1) //"A hora Fim não pode ser maior que a hora atual."
        Return .F.
	EndIf

    If M->TPL_DTINIC == M->TPL_DTFIM .And. !Empty(M->TPL_HOFIM)  .And. HTOM(M->TPL_HOINIC) >= HTOM(M->TPL_HOFIM)
        Help(" ",1,STR0025,,STR0228+" "+STR0373+" "+STR0230,3,1) //"Hora incio não pode ser menor ou igual a hora fim."
        Return .F.
    EndIf

	If !Empty(M->TPL_DTFIM) .And. (!Empty(M->TPL_HOFIM) .And. AllTrim(M->TPL_HOFIM) <> ":") .And. M->TPL_DTINIC > M->TPL_DTFIM
		Help(" ",1,STR0025,,STR0434,3,1) //"A Data Início não pode ser maior que a Data Fim.
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} VALHINI
Valida a hora inicial do atraso de O.S.
@author Taina A. Cardoso
@since 28/12/10
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function VALHINI()

	Local  nDTITPL,nHOITPL,nDTFTPL,nHOFTPL
	Store 0 To nDTITPL,nHOITPL,nDTFTPL,nHOFTPL

	If Type("aHeader") == "A"   // Chamada para consertar problema de variavéis e dicionário feito na SS 014765
		nDTITPL := GDFIELDPOS("TPL_DTINIC")
		nHOITPL := GDFIELDPOS("TPL_HOINIC")
		nDTFTPL := GDFIELDPOS("TPL_DTFIM")
		nHOFTPL := GDFIELDPOS("TPL_HOFIM")
		If  nDTITPL >0 .And.  nHOITPL >0 .And. nDTFTPL > 0 .And. nHOFTPL > 0
			If ReadVar() = "M->TPL_DTINIC"
				M->TPL_HOINIC := aCols[n,nHOITPL]
				M->TPL_DTFIM := aCols[n,nDTFTPL]
				M->TPL_HOFIM := aCols[n,nHOFTPL]
			ElseIF ReadVar() = "M->TPL_HOINIC"
				M->TPL_DTINIC := aCols[n,nDTITPL]
				M->TPL_DTFIM := aCols[n,nDTFTPL]
				M->TPL_HOFIM := aCols[n,nHOFTPL]
			ElseIF ReadVar() = "M->TPL_DTFIM"
				M->TPL_DTINIC:= aCols[n,nDTITPL]
				M->TPL_HOINIC := aCols[n,nHOITPL]
				M->TPL_HOFIM := aCols[n,nHOFTPL]
			ElseIF ReadVar() = "M->TPL_HOFIM"
				M->TPL_DTINIC:= aCols[n,nDTITPL]
				M->TPL_HOINIC := aCols[n,nHOITPL]
				M->TPL_DTFIM := aCols[n,nDTFTPL]
			EndIf
		EndIf
	EndIf

	If M->TPL_DTINIC == M->TPL_DTFIM .And. !Empty(M->TPL_HOFIM)  .And. HTOM(M->TPL_HOINIC) >= HTOM(M->TPL_HOFIM)
		Help(" ",1,STR0025,,STR0338,3,1) //"Hora inicio não pode ser maior ou igual a hora fim."
		Return .F.
	EndIf
	If M->TPL_DTINIC == dDataBase .And. HTOM(M->TPL_HOINIC) > HTOM(SubStr(Time(),1,5))
		Help(" ",1,STR0025,,STR0330,3,1)
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} DTHCONT2
Valida a data e a hora do Segundo contador.
@author Taina A. Cardoso
@since 29/12/10
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function DTHCONT2()

	dbSelectArea("TPE")
	dbSetOrder(1)

	If dbSeek(xFilial("TPE")+M->TJ_CODBEM)
		If DTOS(M->TJ_DTMRFIM) == DTOS(dDataBase) .And. M->TJ_HORACO2 > SubStr(Time(),1,5)
			MsgStop(STR0340) //"A Hora do segundo contador não pode ser maior que a hora atual"
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} DTFIMIN
Valida a data final do insumo.
@author Taina A. Cardoso
@since 30/12/10
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function DTFIMIN()

	Local nDTISTL  := 0, nDTFSTL := 0
	Local dDataIni := cTod("  /  /    "), dDataFim := cTod("  /  /    ")

	If Type("aHeader") == "A"   // Chamada por rotinas que possuem GetDados
		nDTISTL := GDFIELDPOS("TL_DTINICI")
		nDTFSTL := GDFIELDPOS("TL_DTFIM")
		If  nDTISTL > 0 .And.  nDTFSTL > 0
			dDataIni := aCols[n][nDTISTL]
			dDataFim := IIf(ValType(M->TL_DTFIM) == "U", aCols[n][nDTFSTL], M->TL_DTFIM )
		EndIf

	Else
		dDataIni := M->TL_DTINICI
		dDataFim := M->TL_DTFIM
	EndIf

	If ( !Empty(dDataFim) .And. !Empty(dDataIni) )  .And. DtoS(dDataFim) < DtoS(dDataIni)
		MsgStop(STR0365)
		Return .F.
	EndIf
	If !Empty(dDataFim) .And. dDataFim > dDatabase
		MsgStop(STR0366)
		Return .F.
	EndIf

	If !Empty(dDataFim)
		dDATA := If(!EMPTY(STJ->TJ_DTMPFIM),STJ->TJ_DTMPFIM,STJ->TJ_DTORIGI)
		If dDataFim < dDATA
			If !MSGYESNO(STR0367+" '"+DTOC(dDATA)+"'."+STR0351,STR0025)
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} DTINIPA
Valida a data inicio de parada

@type function

@author Taina A. Cardoso
@since 30/12/10

@return lRet, lógico, Retorna falso caso data seja preenchida incorretamente.
/*/
//---------------------------------------------------------------------
Function DTINIPA()

	Local lRet := .T.

	If !Empty( M->TJ_DTPRFIM ) .And. !Empty( M->TJ_DTPRINI ) .And. DTOS( M->TJ_DTPRFIM ) < DTOS( M->TJ_DTPRINI )
		lRet := .F.
		MsgStop( STR0368 ) // "A 'Dt.Par.Ref.I.' não pode ser maior que a 'Dt.Par.Re.F.'"
	ElseIf M->TJ_DTPRINI > dDataBase

		lRet := MsgYesNo( STR0324 ) // A 'Dt.Par.Re.I.' é maior que a data atual, deseja continuar?

	EndIf

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} DTMANINI
Valida a data  real do inicio da manutencao da O.S.
@author Taina A. Cardoso
@since 30/12/10
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function DTMANINI()

	If M->TJ_DTMRINI > dDataBase
		MsgStop(STR0342) //"A 'Dt.Man.Re.I.' não pode ser maior que a data atual."
		Return .F.
	EndIf
	If !Empty(M->TJ_DTMRINI) .And. M->TJ_DTMRINI == M->TJ_DTMRFIM .And. !Empty(M->TJ_HOMRFIM) .And. HTOM(M->TJ_HOMRINI) > HTOM(M->TJ_HOMRFIM)
		MsgStop(STR0345) //"A 'Ho.Man.Re.I.' não pode ser maior que a 'Ho.Ma.Re.F.'"
		Return .F.
	ElseIf M->TJ_DTMRINI == dDataBase .And. HTOM(M->TJ_HOMRINI) > HTOM(SubStr(Time(),1,5))
		MsgStop(STR0346) //"A Ho.Man.Re.I.' não pode ser maior que a hora atual."
		Return .F.
	EndIf
	If !Empty(M->TJ_DTMRINI) .And. DTOS(M->TJ_DTMRINI) < DTOS(M->TJ_DTMPINI)
		If !MsgYesNo(STR0349+"'"+DTOC(M->TJ_DTMPINI)+"'. "+STR0351) //"A 'Dt.Man.Re.I.' é menor que a data prevista inicio , deseja continuar"
			Return .F.
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} HOMANINI
Valida a hora real inicio da manutencao da O.S.
@author Taina A. Cardoso
@since 05/01/11
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function HOMANINI()

	If !Empty(M->TJ_DTMRINI) .And. M->TJ_DTMRINI == M->TJ_DTMRFIM .And. !Empty(M->TJ_HOMRFIM) .And. HTOM(M->TJ_HOMRINI) > HTOM(M->TJ_HOMRFIM)
		MsgStop(STR0345) //"A 'Ho.Man.Re.I.' não pode ser maior que a 'Ho.Ma.Re.F.'"
		Return .F.
	ElseIf M->TJ_DTMRINI == dDataBase .And. HTOM(M->TJ_HOMRINI) > HTOM(SubStr(Time(),1,5))
		MsgStop(STR0346) //"A Ho.Man.Re.I.' não pode ser maior que a hora atual."
		Return .F.
	EndIf

	If !Empty(M->TJ_DTMRFIM) .And. M->TJ_DTMRINI == M->TJ_DTMRFIM .And. !Empty(M->TJ_HOMRINI) .And. HTOM(M->TJ_HOMRINI) > HTOM(M->TJ_HOMRFIM)
		MsgStop(STR0347) //"A 'Ho.Man.Re.F.' não pode ser menor que a 'Ho.Man.Re.I.'"
		Return .F.
	ElseIf M->TJ_DTMRFIM == dDataBase .And. HTOM(M->TJ_HOMRFIM) > HTOM(SubStr(Time(),1,5))
		MsgStop(STR0348) //"A 'Ho.Man.Re.F.' não pode ser maior que a hora atual."
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} DTMANFIM
Valida a data real do final da manutencao da O.S.
@author Taina A. Cardoso
@since 30/12/10
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function DTMANFIM()

	If M->TJ_DTMRFIM > dDataBase
		MsgStop(STR0343) //"A 'Dt.Man.Re.F.' não pode ser maior que a data atual."
		Return .F.
	ElseIf !Empty(M->TJ_DTMRINI) .And. DTOS(M->TJ_DTMRINI) > DTOS(M->TJ_DTMRFIM)
		MsgStop(STR0344) //"A 'Dt.Man.Re.F.' não pode ser maior que a 'Dt.Man.Re.I."
		Return .F.
	EndIf

	If !Empty(M->TJ_DTMRFIM) .And. M->TJ_DTMRFIM < M->TJ_DTMPFIM
		If !MsgYesNo(STR0350+"'"+DTOC(M->TJ_DTMPFIM)+"'. "+STR0351) //"A 'Dt.Man.Re.F.' é menor que a data prevista fim , deseja continuar"
			Return .F.
		EndIf
	EndIf

	If TIPOACOM .And. !Empty( IIf( FindFunction('NGUSELANEX'), NGUSELANEX( M->TJ_CODBEM ) , ;
						AllTrim( SuperGetMv( 'MV_NGLANEX', .F., '' ) )  ) )
		M->TJ_POSCONT := NGACUMEHIS(M->TJ_CODBEM,M->TJ_DTMRFIM,M->TJ_HORACO1,1,"E")[1]
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGDTPROD
Replica data inicio do insumo produto.
@author Taina A. Cardoso
@since 19/01/11
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NGDTPROD()

	nDtFim  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_DTFIM"  })
	nTipoR  := aSCAN( aHEADER, { |x| Trim( Upper(x[2]) ) == "TL_TIPOREG"})

	If IsInCallStack("NG400FIM")
		If aCols[n][nTipoR] == "P"
			aCols[n][nDtFim] := M->TL_DTINICI
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA400ECA
Funcao para disparar ponto de entrada ao cancelar
@author Taina A. Cardoso
@since 25/11/11
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA400ECA()

	lCriouTRBQ := .F.
	If ExistBlock("MNTA400D")
		ExecBlock("MNTA400D",.F.,.F.)
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400VPAR
Funcção que valida parâmetro padrão MV_NGGERAOS, e passa o valor ao parâmetro da função NGGERAOS().
@author Cezar Augusto Padilha
@since 16/07/2012
@version P11
@return .T.
/*/
//---------------------------------------------------------------------
Function NG400VPAR()

	Local cRet := IIf( GETMV( "MV_NGGEROS" ) <> '2', 'L', 'P' )
Return cRet
//---------------------------------------------------------------------
/*/{Protheus.doc} NG400VALOS
Funcção que valida se a ordem de serviço é uma reforma ou conserto de pneu.
@Param cCodBem = código do bem da OS
@Param cServos = código do serviço da OS
@Param lMens
@author Cezar Augusto Padilha
@since 06/08/2012
@version P11
@return .T.
/*/
//---------------------------------------------------------------------
Function NG400VALOS(cCodBem,cServos,lMens)

	Local cSerefor  := AllTrim( GETMV( "MV_NGSEREF" ) )
	Local aServRef 	:= StrTokArr( cSerefor, ';' )
	Local cSercons  := AllTrim( GETMV( "MV_NGSECON" ) )
	Local aServCon 	:= StrTokArr( cSercons, ';' )
	Local lRet 		:= .F.
	Local lFrota	:= NGVERUTFR()

	If lFrota .And.;
	( ( !Empty( aServRef ) .And. aScan(aServRef, {|x| x == AllTrim(cServos)}) > 0 ) .Or.;
	( !Empty( aServCon ) .And. aScan(aServCon, {|x| x == AllTrim(cServos)}) > 0) )
		IIf( !lMens, MsgStop(STR0392), )
		lRet := .T.
	EndIf

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} fNG400VETA
Funcao que valida executante da etapa.
@Param cTipo
@author Guilherme Benkendorf
@since 03/12/2012
@version P10/P11
@return .T.
/*/
//---------------------------------------------------------------------
Static Function fNG400VETA()
	Local lRet := .T.

	If ExistBlock("MNTA400K")
		If ExecBlock("MNTA400K",.F.,.F.,cCODFUNC)
			lRet := .T.
		Else
			lRet := .F.
		EndIf
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400WHMD
Define se possibilita edicao do campo Moeda [ TL_MOEDA ].
Situada no X3_WHEN do campo em questao.

@author Hugo R. Pereira
@since 12/06/2012
@version MP10
@return lReturn Indica se sera possiel editar o campo.

/*/
//---------------------------------------------------------------------
Function MNT400WHMD()

	Local lExistCst := Type("lCusto") == "L"
	Local lReturn   := If( lExistCst, lCusto, GetNewPar("MV_NGMNTES","N") == "N" )

Return lReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA400GAR
Verifica se esta ocorrendo quebra na garantia.

@author Tainã Cardoso
@since 06/12/2013
@version MP11

/*/
//---------------------------------------------------------------------
Function MNTA400GAR()

	Local i, j, x, k
	Local dDtVal
	Local dDtIni := STJ->TJ_DTORIGI
	Local nQuanti, nPosCon, nContador
	Local cProduto, cTipoGar
	Local cCodBem    := STJ->TJ_CODBEM
	Local cHoraCont  := STJ->TJ_HORACO1
	Local cHoraCont2 := STJ->TJ_HORACO2
	Local nPosCont1  := STJ->TJ_POSCONT
	Local nPosCont2  := STJ->TJ_POSCON2
	Local cContGar   := ""
	Local cGarant    := "", cLocaliz := "", cTPZOrdem := ""
	Local lGarTemp   := .F.//Indica se tem garantia por tempo
	Local lGarCont   := NGCADICBASE("TPZ_QTDCON","A","TPZ",.F.)//Indica se tem garantia por contador
	Local aAreaSTJ   := STJ->(GetArea())
	Local aHisCont1  := NGACUMEHIS(cCodBem,dDtIni,cHoraCOnt,1,"A",,,.F.)//Retorna previsao do contador1 anterior
	Local aHisCont2  := NGACUMEHIS(cCodBem,dDtIni,cHoraCont2,2,"A",,,.F.)//Retorna previsao do contador2 anterior
	Local nCont1     := aHisCont1[2]+(nPosCont1 - aHisCont1[1])//Previsão do acumulado do contador1
	Local nCont2     := aHisCont2[2]+(nPosCont2 - aHisCont2[1])//Previsão do acumulado do contador2
	Local aAreaSTL := STL->(GetArea())
	Private aGarant  := {}
	Private aMsgGar  := {}
	Private aOrdTpz  := {}
	Private lCancela := .T.
	Private lGarant  := .F.
	Private lTemOs   := .F.



	dbSelectArea("TPZ")
	dbSetOrder(1) //TPZ_FILIAL+TPZ_CODBEM+TPZ_TIPORE+TPZ_CODIGO+TPZ_LOCGAR
	If dbSeek(xFilial("TPZ") + cCodBem + M->TL_TIPOREG + M->TL_CODIGO )
		While !EoF() .And. xFilial("TPZ") == TPZ->TPZ_FILIAL .And. cCodBem == TPZ->TPZ_CODBEM .And.;
		M->TL_TIPOREG == TPZ->TPZ_TIPORE .And. M->TL_CODIGO == TPZ->TPZ_CODIGO
			nPosCon   := 0
			nContador := 0
			cContGar  := ""
			cTipoGar  := ""
			lGarTemp  := .F.
			If TPZ->TPZ_UNIGAR = "D"
				dDtVal := TPZ->TPZ_DTGARA + TPZ->TPZ_QTDGAR
				cTipoGar := STR0395 // "dias."
				lGarTemp := .T.
			ElseIf TPZ->TPZ_UNIGAR = "S"
				dDtVal := TPZ->TPZ_DTGARA + (TPZ->TPZ_QTDGAR * 7)
				cTipoGar := STR0396  //"semanas."
				lGarTemp := .T.
			ElseIf TPZ->TPZ_UNIGAR = "M"
				dDtVal   := NGSomaMes(TPZ->TPZ_DTGARA,TPZ->TPZ_QTDGAR)
				cTipoGar := STR0397 //"meses."
				lGarTemp := .T.
			EndIf
			cProduto := NGSEEK("SB1",M->TL_CODIGO,1,"B1_DESC")
			cLocaliz := NGSEEK("TPS",TPZ->TPZ_LOCGAR,1,"TPS_NOME")
			If lGarTemp
				//Caso tipo da unidade esteja preenchido, possui garantia por tempo, entao valida tambem por contador
				If dDtIni <= dDtVal .And. dDtIni >= TPZ->TPZ_DTGARA
					If Empty(TPZ->TPZ_ORDEM)
						//Sem ordem de serviço as peças foram adquiridas na compra do bem, valida pelo acumulado de inclusão
						cMsgGar := STR0398 //"Peças adquiridas na compra do bem "
						If lGarCont
							dbSelectArea("TPY")
							dbSetOrder(1)
							If dbSeek(xFilial("TPY")+TPZ->TPZ_CODBEM+TPZ->TPZ_CODIGO+TPZ->TPZ_LOCGAR)
								If TPZ->TPZ_CONGAR == "1"
									dbSelectArea("STP")
									dbSetOrder(8)
									If dbSeek(xFilial("STP")+TPZ->TPZ_CODBEM+"I")
										nPosCon := STP->TP_ACUMCON
										nContador := nCont1
									EndIf
								Else
									dbSelectArea("TPP")
									dbSetOrder(8)
									If dbSeek(xFilial("TPP")+TPZ->TPZ_CODBEM+"I")
										nPosCon := TPP->TPP_ACUMCO
										nContador := nCont2
									EndIf
								EndIf
							EndIf
						EndIf
					Else
						//Por ordem de servico, valida de acordo com o acumulado da O.S.
						cMsgGar := STR0399  //"Foram incluidos na O.S. "
						If lGarCont
							dbSelectArea("STJ")
							dbSetOrder(1)
							If dbSeek(xFilial("STJ")+TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO)
								If TPZ->TPZ_CONGAR == "1"
									nPosCon := NGACUMEHIS(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO1,1,"E",,,.F.)[2]
									nContador := nCont1
								Else
									nPosCon := NGACUMEHIS(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO2,2,"E",,,.F.)[2]
									nContador := nCont2
								EndIf
							EndIf
						EndIf
					EndIf

					If lGarCont .And. nPosCon <> 0 .And. TPZ->TPZ_QTDCON > 0 .And. (nPosCon + TPZ->TPZ_QTDCON) > nContador
						cContGar := STR0400+" ("+AllTrim(Str(TPZ->TPZ_QTDCON))+"). "+STR0401+AllTrim(Str(nPosCon))+". "+STR0402+AllTrim(Str((nPosCon + TPZ->TPZ_QTDCON)))//" e por contador trabalhado"###"Contador anterior: "###"Até contador: "
					EndIf
					//Adiciona em um array as ordens de servico dos produtos em garantia
					nPosTpz := aSCAN(aOrdTpz,{|x| AllTrim(Upper(X[1])) == TPZ->TPZ_ORDEM})
					If nPosTpz == 0 .And. !Empty(TPZ->TPZ_ORDEM)
						aAdd(aOrdTpz,{TPZ->TPZ_ORDEM})
						lTemOs := .T.
					EndIf

					aAdd( aMsgGar, { M->TL_CODIGO, cMsgGar + TPZ->TPZ_ORDEM + ", " + "(" + AllTrim( M->TL_CODIGO ) + ")" +;
					AllTrim( cProduto ) + " - " + AllTrim( Str( M->TL_QUANTID ) ) + " " +;
					AllTrim( M->TL_UNIDADE ) + STR0403 + DToC( TPZ->TPZ_DTGARA ) +;
					If( !Empty( TPZ->TPZ_LOCGAR ), STR0404 + AllTrim( TPZ->TPZ_LOCGAR ) + " - " +;
					AllTrim( cLocaliz ), "" ) + STR0405 + AllTrim( Str( TPZ->TPZ_QTDGAR ) ) + " " +;
					AllTrim( cTipoGar ) + cContGar + ". " + STR0406})
					aAdd( aGarant, { TPZ->TPZ_ORDEM, Chr(13) + Chr(10) + "(" + AllTrim( M->TL_CODIGO ) + ")" +;
					AllTrim( cProduto ) + " - " + AllTrim( Str( M->TL_QUANTID ) ) + " " +;
					AllTrim( M->TL_UNIDADE )+ STR0403 + DToC( TPZ->TPZ_DTGARA ) + ;
					If(!Empty( TPZ->TPZ_LOCGAR), STR0404 + AllTrim( TPZ->TPZ_LOCGAR ) + " - " +;
					AllTrim(cLocaliz),"") + STR0405 + AllTrim( Str( TPZ->TPZ_QTDGAR ) ) + " " +;
					AllTrim( cTipoGar ) + cContGar + ". " + Chr(13) + Chr(10) + Chr(13) + Chr(10) })
					lGarant  := .T.
					For x := 1 to len(aMsgGar)
						If aMsgGar[x][1] == M->TL_CODIGO .And. INCLUI
							M->TL_OBSERVA := M->TL_OBSERVA + aMsgGar[x][2]
						ElseIf aMsgGar[x][1] == M->TL_CODIGO .And. ALTERA
							M->TL_OBSERVA := aMsgGar[x][2]
						EndIf
					Next x
					Exit
				EndIf
			Else
				//Caso tipo da unidade nao esteja preenchido, nao possui garantia por tempo, validando somente por contador
				If lGarCont
					If Empty(TPZ->TPZ_ORDEM)
						//Sem ordem de serviço as peças foram adquiridas na compra do bem, valida pelo acumulado de inclusão
						cMsgGar := STR0398  //"Peças adquiridas na compra do bem "
						dbSelectArea("TPY")
						dbSetOrder(1)
						If dbSeek(xFilial("TPY")+TPZ->TPZ_CODBEM+TPZ->TPZ_CODIGO+TPZ->TPZ_LOCGAR)
							If TPZ->TPZ_CONGAR == "1"
								dbSelectArea("STP")
								dbSetOrder(8)
								If dbSeek(xFilial("STP")+TPZ->TPZ_CODBEM+"I")
									nPosCon := STP->TP_ACUMCON
									nContador := nCont1
								EndIf
							Else
								dbSelectArea("TPP")
								dbSetOrder(8)
								If dbSeek(xFilial("TPP")+TPZ->TPZ_CODBEM+"I")
									nPosCon := TPP->TPP_ACUMCO
									nContador := nCont2
								EndIf
							EndIf
						EndIf
					Else
						//Por ordem de servico, valida de acordo com o acumulado da O.S.
						cMsgGar := STR0399  //"Foram incluidos na O.S. "
						dbSelectArea("STJ")
						dbSetOrder(1)
						If dbSeek(xFilial("STJ")+TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO)
							If TPZ->TPZ_CONGAR == "1"
								nPosCon := NGACUMEHIS(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO1,1,"E",,,.F.)[2]
								nContador := nCont1
							Else
								nPosCon := NGACUMEHIS(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO2,2,"E",,,.F.)[2]
								nContador := nCont2
							EndIf
						EndIf
					EndIf
					If nPosCon <> 0 .And. TPZ->TPZ_QTDCON > 0 .And. (nPosCon + TPZ->TPZ_QTDCON) > nContador
						cContGar := STR0407+" ("+AllTrim(Str(TPZ->TPZ_QTDCON))+"). "+STR0401+AllTrim(Str(nPosCon))+". "+STR0402+AllTrim(Str((nPosCon + TPZ->TPZ_QTDCON)))//" por contador trabalhado"###"Contador anterior: "###"Até contador: "

						aAdd( aMsgGar, { M->TL_CODIGO, cMsgGar + TPZ->TPZ_ORDEM + ", " + "(" + AllTrim( M->TL_CODIGO ) + ")" +;
						AllTrim( cProduto ) + " - " + AllTrim( Str( M->TL_QUANTID ) ) + " " +;
						AllTrim( M->TL_UNIDADE ) + STR0403 + DToC( TPZ->TPZ_DTGARA ) +;
						If( !Empty( TPZ->TPZ_LOCGAR ), STR0404 + AllTrim( TPZ->TPZ_LOCGAR ) +;
						" - " + AllTrim( cLocaliz ), "" ) + STR0408 + cContGar + ". " + STR0406})

						aAdd( aGarant, { TPZ->TPZ_ORDEM, Chr(13) + Chr(10) + "(" + AllTrim( M->TL_CODIGO ) + ")" +;
						AllTrim( cProduto ) + " - " + AllTrim( Str( M->TL_QUANTID ) ) + " " +;
						AllTrim( M->TL_UNIDADE ) + " " + STR0403 + DToC( TPZ->TPZ_DTGARA ) +;
						If( !Empty( TPZ->TPZ_LOCGAR ), STR0404 + AllTrim( TPZ->TPZ_LOCGAR ) + " - " +;
						AllTrim( cLocaliz ), "" ) + STR0408 + cContGar + ". " + Chr(13) + Chr(10) + Chr(13) + Chr(10) })
						lGarant  := .T.
						For x := 1 to len(aMsgGar)
							If aMsgGar[x][1] == M->TL_CODIGO .And. INCLUI
								M->TL_OBSERVA := M->TL_OBSERVA + aMsgGar[x][2]
							ElseIf aMsgGar[x][1] == M->TL_CODIGO .And. ALTERA
								M->TL_OBSERVA := aMsgGar[x][2]
							EndIf
						Next x
						Exit
					EndIf
				EndIf
			EndIf
			dbSelectArea("TPZ")
			dbSkip()
		EndDo
	EndIf


	If lGarant
		aSort(aGarant,,,{|x,y| x[1] < y[1]})
		If Empty(aGarant[1][1])
			cGarant := STR0398 + Chr(13)+Chr(10) //"Peças adquiridas na compra do bem "
		Else
			cGarant := STR0399+aGarant[1][1]+":"+Chr(13)+Chr(10)  //"Foram incluidos na O.S. "
		EndIF
		cTPZOrdem := aGarant[1][1]
		For j := 1 to len(aGarant)
			If cTPZOrdem <> aGarant[j][1]
				cGarant := cGarant + STR0399+aGarant[j][1]+":"+Chr(13)+Chr(10) //"Foram incluidos na O.S. "
			EndIf
			cGarant := cGarant +  aGarant[j][2]
			cTPZOrdem := aGarant[j][1]
		Next j
		cGarant := cGarant +STR0409 //"Dessa forma a troca desse(s) produto(s) poderá violar a garantia."
		RestArea(aAreaSTJ)
		RestArea(aAreaSTL)
		MntVerLog(cGarant,1)
	EndIf
	RestArea(aAreaSTL)
	RestArea(aAreaSTJ)
Return lCancela

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT400SSG
Verifica se a Opção da Etapa Marcada gerou uma SS automaticamente, se
gerou OS e esta SS gerada não for Cancelada, será apresentada mensagem
e retorno .F.

@author Pedro Henrique Soares de Souza
@since 14/06/2014
@version MP11

@param _cOrdem     Ordem de Servico
@param _cPlano	     Plano
@param _cTarefa	 Tarefa
@param _cEtapa	     Etapa
@param lMsg		 Indica se mostra help
@param lTipoOp     Indica se é Exclusao (.T.) ou Alteracao (.F.) da Etapa

/*/
//---------------------------------------------------------------------
Function MNT400SSG( _cOrdem , _cPlano, _cTarefa, _cEtapa, lMsg, lTipoOp )

	Local aArea  := GetArea()
	Local lRet   := .T.
	Local cMsgOS := ""

	Local cTpManu   := Space( TAMSX3('TPC_TPMANU')[1] )
	Local lGerouSS  := .T.

	Default lMsg    := .T.
	Default lTipoOp := .F.

	/*-------------------------------------------------------------------------
	Verifica na TPQ se há alguma solicitação de serviço gerada a partir da
	resposta deste item, e caso exista alguma S.S. não permite que o item
	seja desmarcado
	-------------------------------------------------------------------------*/
	dbSelectArea("TPQ")
	dbSetOrder(1)
	dbSeek( xFilial('TPQ') + _cOrdem + _cPlano + _cTarefa + _cEtapa )
	While !EoF() .And. TPQ->TPQ_FILIAL == xFilial( 'TPQ' ) .And.;
	TPQ->TPQ_ORDEM == _cOrdem .And. TPQ->TPQ_PLANO == _cPlano .And.;
	TPQ->TPQ_TAREFA == _cTarefa .And. TPQ->TPQ_ETAPA == _cEtapa

		If !Empty(TPQ->TPQ_ORDEMG)
			cTpManu     := NGSEEK( "TPC", TPQ->TPQ_ETAPA + TPQ->TPQ_OPCAO, 1, "TPC_TPMANU" )
			lGerouSS    := ( cTpManu == '2' )

			If lGerouSS
				dbSelectArea("TQB")
				dbSetOrder(1)
				If dbSeek( xFilial("TQB") + TPQ->TPQ_ORDEMG )
					lRet := .F.

					If !Empty(cMsgOS)
						cMsgOS += "/ "
					EndIf

					cMsgOS += TPQ->TPQ_ORDEMG
				EndIf
			EndIf
		EndIf

		dbSelectArea("TPQ")
		dbSkip()
	EndDo

	If !lRet .And. lMsg
		If lTipoOp
			If "/" $ cMsgOS
				ShowHelpDlg( "ATENÇÃO", { STR0419 }, 3,;	//"Não será possível excluir esta etapa, pois foram geradas S.S. através da etapa respondida."
				{ STR0420 + cMsgOS + STR0421 }, 2 )	//"As S.S. " ## " geradas deverão ser excluídas e em seguida esta etapa poderá ser excluída."
			Else
				ShowHelpDlg( "ATENÇÃO", { STR0422 }, 3,;	//"Não será possível excluir esta etapa, pois foi gerada uma S.S. através da etapa respondida."
				{ STR0423 + cMsgOS + STR0424 }, 2 )	//"A S.S. " ## " gerada deverá ser cancelada e em seguida esta etapa poderá ser excluída."
			EndIf
		Else
			If "/" $ cMsgOS
				ShowHelpDlg( "ATENÇÃO", { STR0425 }, 3,; //"Não será possível desmarcar esta etapa, pois foram geradas S.S. através da etapa respondida."
				{ STR0426 + cMsgOS + STR0427 }, 2 ) //"As S.S. " ## " geradas deverão ser canceladas e em seguida esta etapa poderá ser desmarcada."
			Else
				ShowHelpDlg( "ATENÇÃO", { STR0428 }, 3,; //"Não será possível desmarcar esta etapa, pois foi gerada uma S.S. através da etapa respondida."
				{ STR0429 + cMsgOS + STR0430 }, 2) // "A S.S. " ## " gerada deverá ser cancelada e em seguida esta etapa poderá ser desmarcada."
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return lRet

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fFilterBrw
Função que realiza montagem do filtro padrão do browse

@author Alexandre Santos
@since 04/07/2017
@version 2.0

@obs Condição do filtro deve ser em SQL
@sample fFilterBrw()

@return cFiltroTop , Caracter, Confição que será aplicada ao filtro.
/*/
//------------------------------------------------------------------------------------
Static Function fFilterBrw()

	Local cSerefor  := AllTrim( GETMV( "MV_NGSEREF" ) )
	Local aServRef 	:= StrTokArr( cSerefor, ';' )
	Local cSercons  := AllTrim( GETMV( "MV_NGSECON" ) )
	Local aServCon 	:= StrTokArr( cSercons, ';' )
	Local cFiltroTop := ""
	Local nX

	cFiltroTop := "TJ_LUBRIFI <> 'S' And TJ_TERMINO = 'N' And "
	cFiltroTop += "TJ_SITUACA = 'L'  And TJ_ORDEPAI = " + ValToSQL(Space(Len(STJ->TJ_ORDEPAI)))

	//Preenche a variavel cSerefor com todos os serviços do parametro MV_NGSEREF
	If !Empty(cSerefor)

		For nX := 1 To Len(aServRef)
			If nX == 1
				cSerefor := "'"+aServRef[nX]+"'"
			Else
				cSerefor += ",'"+aServRef[nX]+"'"
			EndIf
		Next nX

	Else

		//Garante que a aspas vão certas para a Query
		cSerefor := "' '"

	EndIf

	//Preenche a variavel cSercons com todos os serviços do parametro MV_NGSECON
	If !Empty(cSercons)

		For nX := 1 To Len(aServCon)
			If nX == 1
				cSercons := "'"+aServCon[nX]+"'"
			Else
				cSercons += ",'"+aServCon[nX]+"'"
			EndIf
		Next nX

	Else

		//Garante que a aspas vão certas para a Query
		cSercons := "' '"

	EndIf

	// Não lista O.S com o serviço de Reforma de Pneus (Frota)
	If !Empty(aServRef)
		cFiltroTop += " AND TJ_SERVICO NOT IN (" + cSerefor + ")"
	EndIf

	// Não lista O.S com o serviço de Conserto de Pneus (Frota)
	If !Empty(aServCon)
		cFiltroTop += " AND TJ_SERVICO NOT IN (" + cSercons + ")"
	EndIf

	//PE para inclusão de novas condições ao filtro padrão.
	If ExistBlock("MNTA400O")
		cFiltroTop += " AND " + ExecBlock("MNTA400O",.F.,.F.)
	EndIf

Return cFiltroTop

//------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA400Can
Valida se O.S. foi cancelada em outra rotina enquanto o retorno estava em uso.
@type function

@author Alexandre Santos
@since 20/08/2020

@param
@return boolean, Define se O.S. está apta para reportes.
/*/
//------------------------------------------------------------------------------------
Function MNTA400Can()

	Local lRet := .T.

	If STJ->TJ_SITUACA == 'C'

		/*
			Esta ordem de serviço foi cancelada por outra rotina. Portanto não é possível realizar reportes para a ordem de serviço.
			Ao retornar ao browse principal a listagem de ordens de serviço disponivéis será atualizada.
		*/
		Help( '', 1, 'MNTA400',, STR0443, 2, 0,,,,,, { STR0444 } )
		lRet := .F.

	EndIf

Return lRet

//------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT400VPAR
Valida campos de parada para finalização

@author Maria Elisandra de Paula
@since 14/04/21
@return boolean
/*/
//------------------------------------------------------------------------------------
Function MNT400VPAR()

	Local cMenPrb := ''

	If !Empty(M->TJ_DTPRINI) .And. !Empty(M->TJ_DTPRFIM) .And. ;
		!Empty(M->TJ_HOPRINI) .And. !Empty(M->TJ_HOPRFIM) .And. ;
		AllTrim(M->TJ_HOPRINI) <> ":"  .And. AllTrim(M->TJ_HOPRFIM) <> ":"

		If M->TJ_DTPRINI > dDataBase
			cMenPrb := NGRETTITULO("TJ_DTPRINI")+" "+STR0369+" "+ STR0372 //"nao pode ser maior que a" ## "data atual"
		ElseIf M->TJ_DTPRINI = dDataBase .And. M->TJ_HOPRINI > SubS(Time(),1,5)
			cMenPrb := NGRETTITULO("TJ_HOPRINI")+" "+STR0369+" "+STR0371  //"nao pode ser maior que a" ## "hora atual"
		EndIf

		If Empty(cMenPrb) .And. M->TJ_DTPRINI > M->TJ_DTPRFIM
			cMenPrb := NGRETTITULO("TJ_DTPRINI")+" "+STR0369+" "+NGRETTITULO("TJ_DTPRFIM")//"nao pode ser maior que a"
		EndIf

		If Empty(cMenPrb) .And. M->TJ_DTPRINI = M->TJ_DTPRFIM
			If M->TJ_HOPRINI >= M->TJ_HOPRFIM
				cMenPrb := NGRETTITULO("TJ_HOPRINI")+" "+STR0373+" "+NGRETTITULO("TJ_HOPRFIM")//"nao pode ser maior ou igual que a"
			ElseIf M->TJ_HOPRFIM <= M->TJ_HOPRINI
				cMenPrb := NGRETTITULO("TJ_HOPRFIM")+" "+STR0374+" "+NGRETTITULO("TJ_HOPRINI")//"nao pode ser menor ou igual que a"
			EndIf
		EndIf

	ElseIf Empty(M->TJ_DTPRINI) .And. Empty(M->TJ_DTPRFIM) .And. ;
		(Empty(M->TJ_HOPRINI) .Or. Alltrim(M->TJ_HOPRINI) == ":") .And.;
		(Empty(M->TJ_HOPRFIM) .Or. Alltrim(M->TJ_HOPRFIM) == ":")

		cMenPrb := ''

	Else

		cMenPrb := STR0360//"Um ou mais campos da data ou hora de parada não foram preenchidos."

	EndIf

	If !Empty(cMenPrb)
		MsgStop(cMenPrb,STR0137)//"NAO CONFORMIDADE"
	EndIf

Return Empty( cMenPrb )

//------------------------------------------------------------------------------------
/*/{Protheus.doc} fInteg
Realiza o processo de integração com estoque para os insumos.

@author Alexandre Santos
@since 09/12/2021

@param nOpcX   , numeric, Indica a operação em processo.
@param lOSHESTO, boolean, Define se trata-se de uma O.S. de histórico.
@param cNSeqD3 , string , Valor do D3_NUMSEQ para gravação na tabela STL.
@param nCustD3 , numeric, Custo da movimentação para gravação na tabela STL.
@return boolean, Indica se o processo foi concluido corretamente.
/*/
//------------------------------------------------------------------------------------
Static Function fInteg( nOpcX, lOSHESTO, cNSeqD3, nCustD3 )

	Local aError   := {}
	Local aInfoSTL := {}
	Local aRetSD3  := {}
	Local lOk      := .T.

	Begin Transaction

		If nOPCX == 5 .And. cUsaInt3  = 'S' .And. !Empty( M->TL_NUMSEQ )

			lOkInteg := .T.
			aInfoSTL := { STJ->TJ_ORDEM, STJ->TJ_PLANO, M->TL_TIPOREG, M->TL_CODIGO , M->TL_QUANTID, M->TL_LOCAL  , M->TL_LOTECTL, M->TL_NUMLOTE,;
			 			  M->TL_LOCALIZ, M->TL_NUMSERI, M->TL_DTVALID, M->TL_HREXTRA, M->TL_PCTHREX, M->TL_NUMSEQ , M->TL_UNIDADE, M->TL_DTINICI,;
						  M->TL_TIPOHOR, M->TL_CUSTO }

			aRetSD3 := MNTGERAD3( 'DE1', Nil, @lOkInteg, , .F., .T., aInfoSTL )

			If aRetSD3[2]

				cNUMSEQ := aRetSD3[1]

				If NGPRODESP( SD3->D3_COD, .F., 'M' )
					NGAtuErp("SD3","INSERT")
				EndIf

			Else

				aAdd( aError, { aRetSD3[3], STJ->TJ_ORDEM, STJ->TJ_PLANO, M->TL_TAREFA, M->TL_TIPOREG, M->TL_CODIGO,;
					M->TL_SEQRELA, M->TL_NUMSEQ } )

			EndIf

		EndIf

		If nOPCX == 4

			If cUsaInt3  = 'S' .And. STL->TL_TIPOREG $"PM"

				aInfoSTL := { STJ->TJ_ORDEM, STJ->TJ_PLANO, M->TL_TIPOREG, M->TL_CODIGO , M->TL_QUANTID, M->TL_LOCAL  , M->TL_LOTECTL, M->TL_NUMLOTE,;
			 			  	  M->TL_LOCALIZ, M->TL_NUMSERI, M->TL_DTVALID, M->TL_HREXTRA, M->TL_PCTHREX, M->TL_NUMSEQ , M->TL_UNIDADE, M->TL_DTINICI,;
						  	  M->TL_TIPOHOR, M->TL_CUSTO }

				If M->TL_QUANTID != STL->TL_QUANTID .Or. M->TL_DTINICI != STL->TL_DTINICI .Or. M->TL_LOCAL != STL->TL_LOCAL .Or.;
					M->TL_LOTECTL != STL->TL_LOTECTL .Or. M->TL_NUMLOTE != STL->TL_NUMLOTE .Or. M->TL_NUMSERI != STL->TL_NUMSERI .Or.;
					M->TL_LOCALIZ != STL->TL_LOCALIZ

					nEmpQTD := 0
					dbSelectArea("STL")
					nRecSTLA := Recno()

					If !Empty( M->TL_NUMSEQ )

						aRetSD3 := MNTGERAD3( 'DE1', , , , .F., .T., aInfoSTL )

						If aRetSD3[2]

							cNUMSEQ := aRetSD3[1]

							nEmpQTD := SB2->B2_QEMP

							If NGPRODESP(SD3->D3_COD,.F.,"M")
								NGAtuErp("SD3","INSERT")
							EndIf

							If lBAIXAEST

								aRetSD3 := MNTGERAD3( 'RE0', , , , .F., .T., aInfoSTL )

								If aRetSD3[2]

									If NGPRODESP(SD3->D3_COD,.F.,"M")
										NGAtuErp("SD3","INSERT")
									EndIf

									cNSeqD3 := aRetSD3[1]
									nCustD3 := SD3->D3_CUSTO1

								Else

									aAdd( aError, { aRetSD3[3], STJ->TJ_ORDEM, STJ->TJ_PLANO, M->TL_TAREFA, M->TL_TIPOREG, M->TL_CODIGO,;
										M->TL_SEQRELA, M->TL_NUMSEQ } )

								EndIf

							EndIf

						Else

							aAdd( aError, { aRetSD3[3], STJ->TJ_ORDEM, STJ->TJ_PLANO, M->TL_TAREFA, M->TL_TIPOREG, M->TL_CODIGO,;
								M->TL_SEQRELA, M->TL_NUMSEQ } )

						EndIf

					EndIf

				EndIf

			EndIf

		EndIf

		If nOPCX == 3

			If M->TL_TIPOREG $"PM"

				If cUsaInt3  = 'S' .And. !lOSHESTO

					If lBAIXAEST

						aInfoSTL := { STJ->TJ_ORDEM, STJ->TJ_PLANO, M->TL_TIPOREG, M->TL_CODIGO , M->TL_QUANTID, M->TL_LOCAL  , M->TL_LOTECTL, M->TL_NUMLOTE,;
			 			 			  M->TL_LOCALIZ, M->TL_NUMSERI, M->TL_DTVALID, M->TL_HREXTRA, M->TL_PCTHREX, M->TL_NUMSEQ , M->TL_UNIDADE, M->TL_DTINICI,;
						  			  M->TL_TIPOHOR, M->TL_CUSTO }

						aRetSD3 := MNTGERAD3( 'RE0' , , , , .F., .T., aInfoSTL )

						If aRetSD3[2]

							cNSeqD3 := aRetSD3[1]
							nCustD3 := SD3->D3_CUSTO1

							If NGPRODESP(SD3->D3_COD,.F.,"M")
								NGAtuErp("SD3","INSERT")
							EndIf

						Else

							aAdd( aError, { aRetSD3[3], STJ->TJ_ORDEM, STJ->TJ_PLANO, M->TL_TAREFA, M->TL_TIPOREG, M->TL_CODIGO,;
								M->TL_SEQRELA, M->TL_NUMSEQ } )

						EndIf

					EndIf

				EndIf
			EndIf

		EndIf

		If !Empty( aError )

			MNTA435Log( aError )

			DisarmTransaction()

			lOk := .F.

		EndIf

	End Transaction


Return lOK

//----------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT400LOC
Executa a validação do campo TL_LOCALIZ
(Função necessária pois o valid padrão do campo utiliza campos em memória que não existem)
@type function

@author João Ricardo Santini Zandoná
@since 07/08/2024

@return Logica, Informa se o código de Localização informado é ou não válido
/*/
//----------------------------------------------------------------------------------------
Function MNT400LOC()

	Local lReturn := .T.

	If !Empty( M->TL_LOCALIZ )

		lReturn := ExistCpo( 'SBE', aCols[ n, aScan( aHeaIns,{ | x | Trim( Upper( x[ 2 ] ) ) == 'TL_LOCAL'}) ] + M->TL_LOCALIZ )

	Else

		lReturn := .T.

	EndIf

Return lReturn
