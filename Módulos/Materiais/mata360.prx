#INCLUDE "MATA360.CH" 
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "APWIZARD.CH"
#INCLUDE "FWLIBVERSION.CH"

#DEFINE MAXGETDAD 4096

Static aIntSE4	 := {} //Definida como Static pois no mvc Ser necessrio gerar na pr-validao e finalizar no commit
Static __lMetric := Nil

/*/


Ŀ
Funo     MATA360   Autor  Claudinei Matasso Benzi Data  10/02/92 
Ĵ
Descrio  Programa de atualizacao do cadastro de Cond. de Pagamentos  
Ĵ
Sintaxe    Void MATA360(void)                                          
Ĵ
Uso        Generico                                                    
ٱ


/*/
Function MATA360(xAutoCab,xAutoItens,nOpcAuto) 

//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
//
PRIVATE aRotina	  := MenuDef()
PRIVATE cCadastro := OemToAnsi(STR0006)	//"Condio de Pagamento"


If !Empty(xAutoCab)
	If ValType(xAutoItens) <> "A"
		xAutoItens := {}	
	EndIf
	FWMVCRotAuto(ModelDef(),"SE4",nOpcAuto,{{"SE4MASTER",xAutoCab},{"SECDETAIL",xAutoItens}})
Else
	DEFINE FWMBROWSE oMBrowse ALIAS "SE4" DESCRIPTION STR0006 //"Condio de Pagamento"
		oMBrowse:SetAttach( .T. )			// Habilita visoes
		oMBrowse:SetTotalDefault('E4_FILIAL','COUNT',STR0031) //'Total de Registros'
		//Se no for SIGACRM inibe a exibio do grfico
		If nModulo <> 73
			oMBrowse:SetOpenChart( .F. )
		EndIf
	ACTIVATE FWMBROWSE oMBrowse
EndIf
	
Return

/*/


Ŀ
Programa  MenuDef    Autor  Vendas & CRM           Data 18/01/2012
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados         
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
ٱ


/*/           
Static Function MenuDef()     

Private aRotina	:= {} 


ADD OPTION aRotina Title STR0001 Action 'PesqBrw'         OPERATION 1 ACCESS 0 //'Pesquisar'
ADD OPTION aRotina Title STR0002 Action 'VIEWDEF.MATA360' OPERATION 2 ACCESS 0 //"Visualizar"
ADD OPTION aRotina Title STR0003 Action 'VIEWDEF.MATA360' OPERATION 3 ACCESS 0 //"Incluir"
ADD OPTION aRotina Title STR0004 Action 'VIEWDEF.MATA360' OPERATION 4 ACCESS 0 //"Alterar"
ADD OPTION aRotina Title STR0005 Action 'VIEWDEF.MATA360' OPERATION 5 ACCESS 3 //"Excluir"
If ( cPaisLoc == "BRA" )		
	ADD OPTION aRotina Title STR0025 Action 'A360SimCnd' OPERATION 7 ACCESS 0	 //"Simulao"
Endif
ADD OPTION aRotina Title STR0008 Action 'MATR035' OPERATION 8 ACCESS 0	 //"Imprimir"

If IsInCallStack("MATA360") 
	aRotina:= CRMXINCROT("SE4",aRotina)
EndIf
		
If ExistBlock ("MTA360MNU")
	ExecBlock ("MTA360MNU",.F.,.F.)
Endif	

return (aRotina)

/*/


Ŀ
Funcao    ViewDef      Autor Vendas & CRM            Data  18/01/12 
Ĵ
Descrio  Definicao da View                                          	
Ĵ
Retorno    oView                                                       	
Ĵ
Parametros Nenhum														
ٱ


/*/
Static Function ViewDef()
Local oModel   := FWLoadModel( 'MATA360' )	// Cria um objeto de Modelo de dados baseado no ModelDef do fonte informado
Local oStruSE4 := FWFormStruct( 2, 'SE4' )	// Cria as estruturas a serem usadas na View
Local oStruSEC := FWFormStruct( 2, 'SEC' ) // Cria as estruturas a serem usadas na View
Local oView									// Interface de visualizao construda

oView := FWFormView():New()								// Cria o objeto de View
oView:SetContinuousForm()
oView:SetModel( oModel )									// Define qual Modelo de dados ser utilizado				
oView:AddField( 'VIEW_SE4', oStruSE4, 'SE4MASTER' )	// Adiciona no nosso View um controle do tipo formulrio (antiga Enchoice)
oView:AddGrid( 'VIEW_SEC' , oStruSEC, 'SECDETAIL' )	// Adiciona no nosso View um controle do tipo Grid (antiga Getdados)
oView:AddIncrementField( 'VIEW_SEC', 'EC_ITEM' )		// Item Incremental do Grid

// Cria um "box" horizontal para receber cada elemento da view
oView:CreateHorizontalBox( 'SUPERIOR', 35 )			
oView:CreateHorizontalBox( 'INFERIOR', 65 )

// Relaciona o identificador (ID) da View com o "box" para exibio
oView:SetOwnerView( 'VIEW_SE4', 'SUPERIOR' )			
oView:SetOwnerView( 'VIEW_SEC', 'INFERIOR' )

Return oView

/*/


Ŀ
Funcao    ModelDef     Autor Vendas & CRM            Data  18/01/12 
Ĵ
Descrio  Definicao do Model                                         	
Ĵ
Retorno    oModel                                                      	
Ĵ
Parametros Nenhum														
ٱ


/*/
Static Function ModelDef()
// Cria as estruturas a serem usadas no Modelo de Dados
Local oStruSE4	:= FWFormStruct( 1, 'SE4' )	// Estrutura SE4
Local oStruSEC	:= FWFormStruct( 1, 'SEC' ) // Estrutura SEC
Local oModel 								// Modelo de dados construdo

// Cria o objeto do Modelo de Dados
oModel := MPFormModel():New( 'MATA360', /*pre*/,{|oModel| A360Pos(oModel) },{|oModel| A360Commit(oModel) })
oModel:SetVldActivate( { |oModel| A360VldAct( oModel ) } )
oModel:SetActivate({|oModel| A360Activ(oModel) })

// Adiciona ao modelo um componente de formulrio
oModel:AddFields('SE4MASTER' /*cId*/,;
                 /*cOwner*/,;
                 oStruSE4 /*oModelStruct*/,;
                 {|oMdlSE4, cAction, cField, xValue| Mt360PrVdF(oMdlSE4, cAction, cField, xValue)} /*bPre*/,;
                 /*bPost*/,;
                 /*bLoad*/)
// Adiciona ao modelo uma componente de grid
oModel:AddGrid( 'SECDETAIL', 'SE4MASTER', oStruSEC , /*pre*/,{|oModel| A360LPos(oModel) })
oModel:GetModel( 'SECDETAIL'):SetOptional( .T. )
// Faz relacionamento entre os componentes do model
oModel:SetRelation( 'SECDETAIL', { { 'EC_FILIAL', 'xFilial("SEC")' }, { 'EC_CODIGO', 'E4_CODIGO' } }, SEC->( IndexKey( 1 ) ) )
// Adiciona a descrio do Modelo de Dados
oModel:SetDescription( STR0006 ) //"Condio de Pagamento"
// Retorna o Modelo de dados

Return oModel

//------------------------------------------------------------------------------
/*/{Protheus.doc} Mt360PrVdF
@Description  Bloco de Cdigo de pr-validao do submodelo.
                Esse bloco  invocado quando h uma tentativa de atribuio de valores.
@sample        MT360PVldF(oMdlSE4, cAction, cField, xValue)
@param         oMdlSE4: Objeto do Modelo
                cAction: Ao a ser executada
                cField: Campo posicionado
                xValue: Contedo para o campo
@return		ExpL - Verdadeiro (Validao OK) ou Falso (Inconsistncia na validao)
@author        CRM/Faturamento
@since         02/02/2018
@version       12.1.20
/*/
//------------------------------------------------------------------------------
Static Function Mt360PrVdF(oMdlSE4, cAction, cField, xValue)

Local lRet		:= .T.
Local cAliasQry	:= ""
Local cQuery	:= ""

If cAction == "SETVALUE"
	If cPaisLoc == "BRA"
		If cField == "E4_IPI"
			If	oMdlSE4:GetValue("E4_TIPO") == "9"
				If ( !("%" $ oMdlSE4:GetValue("E4_COND")) .AND. xValue $ "JS" ) .OR.;
				   (   "%" $ oMdlSE4:GetValue("E4_COND")  .AND. xValue == "S" )
					Help( " ",1,"A360TIPO9" )
					lRet	:= .F.
				EndIf
			EndIf
		ElseIf cField == "E4_SOLID"
			If	oMdlSE4:GetValue("E4_TIPO") == "9"
				If ( !("%" $ oMdlSE4:GetValue("E4_COND")) .AND. xValue $ "JS" ) .OR.;
				   (   "%" $ oMdlSE4:GetValue("E4_COND")  .AND. xValue == "S" )
					Help( " ",1,"A360TIPO9" )
					lRet	:= .F.
				EndIf
			ElseIf	oMdlSE4:GetValue("E4_TIPO") == "8" .AND. xValue $ "JS"
				Help( " ",1,"A360TIPO8" )
				lRet	:= .F.
			EndIf
		ElseIf cField == "E4_CTRADT"
			If	oMdlSE4:GetOperation() = MODEL_OPERATION_UPDATE .And. xValue <> oMdlSE4:GetValue("E4_CTRADT") .And. xValue <> "1"
				cAliasQry := GetNextAlias()

				cQuery := "SELECT DISTINCT SE4.E4_CODIGO "
				cQuery += "FROM " + RetSqlName("SE4") + " SE4 "
				cQuery += "INNER JOIN " + RetSqlName("SC5") + " SC5 "
				cQuery += "ON SC5.C5_FILIAL = SE4.E4_FILIAL AND SC5.C5_CONDPAG = SE4.E4_CODIGO AND SC5.D_E_L_E_T_ = ' ' "
				cQuery += "INNER JOIN " + RetSqlName("FIE") + " FIE "
				cQuery += "ON FIE.FIE_FILIAL = SC5.C5_FILIAL AND FIE.FIE_PEDIDO = SC5.C5_NUM AND (CASE  "
				cQuery += "WHEN  FIE.FIE_CLIENT <> ' ' "
				cQuery += "THEN FIE.FIE_CLIENT "
				cQuery += "ELSE FIE.FIE_FORNEC "
				cQuery += "END) = SC5.C5_CLIENTE AND FIE.D_E_L_E_T_ = ' ' "
				cQuery += "WHERE SE4.E4_FILIAL = '" + xFilial("SE4") + "' "
				cQuery += "AND SE4.E4_CODIGO = '" + oMdlSE4:GetValue("E4_CODIGO") + "' "
				cQuery += "AND SE4.D_E_L_E_T_ = ' ' "
				cQuery := ChangeQuery(cQuery)
				
				dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry, .T., .T. )

				If (cAliasQry)->( !Eof() )
					lRet	:= .F.
					(cAliasQry)->( dbCloseArea() )
					Help( "", 1, "NOALTERA", , Chr(13) + Chr(10) +  "SE4 - " + AllTrim( RetTitle( "E4_CTRADT" ) ), 3, 0 )
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
Return lRet

/*/


Ŀ
Funcao    A360LPos     Autor Vendas & CRM            Data  18/01/12 
Ĵ
Descrio  Validao de Linha - LinOK - Grid SEC						
Ĵ
Retorno    oModel                                                      	
Ĵ
Parametros Nenhum														
ٱ


/*/
Function A360LPos(oModelSEC)
Local lRet 		:= .T.
Local oModel 	:= FwModelActive() 
Local oModelSE4 := oModel:GetModel( 'SE4MASTER' )

If oModelSE4:GetValue("E4_TIPO") == "B"
	If !oModelSEC:IsDeleted()
		If Empty(oModelSEC:GetValue("EC_COND")) .OR. oModelSEC:GetValue("EC_RATEIO") == 0 .OR. Empty(oModelSEC:GetValue("EC_TIPO"))		
			Help(" ",1,"OBRIGAT")
			lRet := .F.
		Endif
	
	Endif	
Else
	If !oModelSEC:IsDeleted()
		If !Empty(oModelSEC:GetValue("EC_COND")) .OR. oModelSEC:GetValue("EC_RATEIO") != 0 .OR. !Empty(oModelSEC:GetValue("EC_TIPO"))		
			Help(" ",1,"M360DESMEM")
			lRet := .F.
		Endif
	Endif	
Endif	

Return lRet

/*/


Ŀ
Funcao    A360VldAct   Autor Vendas & CRM            Data  18/01/12 
Ĵ
Descrio  Validao de Ativao do Model								
Ĵ
Retorno    oModel                                                      	
Ĵ
Parametros Nenhum														
ٱ


/*/
Function A360VldAct(oModel)
Local lRet := .T.

If oModel:getOperation() == MODEL_OPERATION_DELETE
	lRet := A360CanDel(SE4->E4_CODIGO)
EndIf      	
		
Return lRet 
/*/


Ŀ
Funcao    A360Activ    Autor Vendas & CRM            Data  18/01/12 
Ĵ
Descrio  Pre-Validao do Model                                    	
Ĵ
Retorno    oModel                                                      	
Ĵ
Parametros Nenhum														
ٱ


/*/
Function A360Activ(oModel)
Local lRet 	:= .T.
Local nOper := oModel:GetOperation()

If nOper == MODEL_OPERATION_INSERT .OR.;
	nOper == MODEL_OPERATION_UPDATE .OR.;
	nOper == MODEL_OPERATION_DELETE
	
	//Inicializa na Pr Validao
	aIntSE4 := {}	
	A035Int( 1, nOper, aIntSE4 )		
EndIf

Return lRet

/*/


Ŀ
Funcao    A360Pos      Autor Vendas & CRM            Data  18/01/12 
Ĵ
Descrio  Pos-Validao do Model                                    	
Ĵ
Retorno    oModel                                                      	
Ĵ
Parametros Nenhum														
ٱ


/*/
Function A360Pos(oModel)

Local lRet 			:= .T.
Local nI				:= 0
Local nPercent		:= 0
Local oModelSE4	 	:= oModel:GetModel("SE4MASTER")
Local oModelSEC	 	:= oModel:GetModel("SECDETAIL")
Local nOper			:= oModel:GetOperation()

If nOper <> 5 .And. !A360Cond()
    Help( " ",1,"A360TIPO" )
    lRet := .F.
EndIf

If lRet .AND. cPaisLoc == "BRA"

	If	oModelSE4:GetValue("E4_TIPO") == "9" .AND. oModelSE4:GetIdField("E4_IPI") > 0 .AND. oModelSE4:GetIdField("E4_SOLID") > 0
		If ( !("%" $ oModelSE4:GetValue("E4_COND")) .AND. ( oModelSE4:GetValue("E4_IPI") $ "JS" .OR. oModelSE4:GetValue("E4_SOLID") $ "JS" )) .OR.;
		   (   "%" $ oModelSE4:GetValue("E4_COND")  .AND. ( oModelSE4:GetValue("E4_IPI") == "S" .OR. oModelSE4:GetValue("E4_SOLID") == "S" ))
			Help( " ", 1, "A360TIPO9" )
			lRet	:= .F.
		EndIf
	ElseIf	oModelSE4:GetValue("E4_TIPO") == "8" .AND. oModelSE4:GetIdField("E4_SOLID") > 0 .AND. oModelSE4:GetValue("E4_SOLID") $ "JS"
		Help( " ", 1, "A360TIPO8" )
		lRet	:= .F.
	EndIf

EndIf

//Ŀ
//Verifica se a soma dos rateios informados                
//
If lRet .AND. oModel:GetValue("SE4MASTER","E4_TIPO") == "B"

	For nI := 1 To oModelSEC:Length()
		oModelSEC:GoLine( nI )
		If !oModelSEC:IsDeleted()
			nPercent += oModelSEC:GetValue("EC_RATEIO")
			If Empty(oModelSEC:GetValue("EC_COND")) .Or. Empty(oModelSEC:GetValue("EC_TIPO")) .Or. oModelSEC:GetValue("EC_RATEIO") == 0
				Help(" ",1,"OBRIGAT")
				lRet := .F.
			Endif
		Endif
	Next nX
	
	If lRet .AND. nPercent <> 100
		Help(" ",1,"M360RATEIO")
		lRet := .F.
	EndIf

Else

	If lRet .AND. oModel:GetValue("SE4MASTER","E4_TIPO") == "2" .And. Val(Subs(oModel:GetValue("SE4MASTER","E4_CODIGO"),2,1)) == 0
		Help( " ",1,"A360TIPO2" )
		lRet := .F.
	Endif
 
	If lRet
		For nI := 1 To oModelSEC:Length()
			oModelSEC:GoLine( nI )
			If !oModelSEC:IsDeleted() .And. (!Empty(oModelSEC:GetValue("EC_COND")) .Or. oModelSEC:GetValue("EC_RATEIO") <> 0 .Or. ;
											!Empty(oModelSEC:GetValue("EC_TIPO")))
				Help(" ",1,"M360DESMEM")
				lRet := .F.
			Endif
		Next nX
	Endif 
Endif 
 
If lRet
	If ExistBlock("MT360VLD")
		lRet := ExecBlock("MT360VLD",.F.,.F.) 
	Endif

	/* Integrao RISK - TOTVS Mais Negcios
	Avalia se existem registros com a condio de pagamento do TOTVS Mais Negcios */
	If lRet .And. FindFunction( "RskIsActive" ) .And. RskIsActive()
		lRet := RskVdPayCond( oModel )
	EndIf
Endif 

Return lRet

/*/


Ŀ
Funcao    A360Commit   Autor Vendas & CRM            Data  18/01/12 
Ĵ
Descrio  Gravao            	                                    	
Ĵ
Retorno    oModel                                                      	
Ĵ
Parametros Nenhum														
ٱ


/*/
Function a360Commit(oModel)
Local nOper 		:= oModel:GetOperation()
Local lOk 			:= .T.

If nOper == MODEL_OPERATION_DELETE
	If ExistBlock("MT360DEL")
		lOk := ExecBlock("MT360DEL",.F.,.F.)
		lOk := IIf(ValType(lOk)<>"L",.T.,lOk)
	EndIf	
EndIf

If lOk
	lOk := FwFormCommit(oModel)
	
	// Integra Protheus x LEGAL DESK - SIGAPFS             
	// Grava na fila de sincronizao se o parmetro MV_JFSINC = '1' - SIGAPFS
	If lOk .AND. FindFunction("J170GRAVA")
		J170GRAVA("SE4", xFilial("SE4") + FwFldGet("E4_CODIGO"), AllTrim(Str(nOper)))
	EndIf
	
	// Funo usada para validar se existe integrao do Protheus com o RM Solum e
	// Para chamar a validao especfica do RM Solum na deleo do Produto. (PMSXFUNB)
	If lOk .AND. FindFunction("PmsSlmPrd") .AND. !PmsSlmPrd("CP")
		lOk := .F.
	Endif
	
	//Ŀ
	//Ponto de entrada apos a atualizacao das tabelas da Cond.Pagto
	//
	If lOk .AND. ExistBlock("MT360GRV")
		ExecBlock("MT360GRV",.F.,.F.)
	EndIf

	//Valida a data da LIB para utilizao na Telemetria
	If (nOper <> MODEL_OPERATION_DELETE) .And. FwFldGet("E4_CTRADT") == "1" .And. FatLibMetric()
		//Telemetria - Pagamentos com Recebimento Antecipado
		FwCustomMetrics():setUniqueMetric("MATA360", "faturamento-protheus_patamentos-recebimentos-antecipados_total", FwFldGet("E4_CTRADT"), /*dDateSend*/, /*nLapTime*/,"MATA360")
	EndIf
EndIf

If lOk 	
	A035Int( 2, nOper , aIntSE4 )
	MT360AltOk()
		
	//Limpa aps gravao
	aSize(aIntSE4,0)			
EndIf

Return lOk

/*/

Ŀ
Funo    A360Man    Autor  Henry Fila             Data  15/10/03 
Ĵ
Descrio  Rotina de Inclusao                                         
Ĵ
ParametrosExpC1: Alias do cabecalho do pedido de venda                
          ExpN2: Recno do cabecalho do pedido de venda                
          ExpN3: Opcao do arotina                                     
Ĵ
Sintaxe e  A360Inclui()                                               
Ĵ
 Uso       MATA360                                                    
ٱ


/*/
Function A360Man(cAlias,nReg,nOpc)

Local aPosObj   := {}
Local aObjects  := {}
Local aSize     := MsAdvSize() 

Local cSeek     := ""
Local cWhile    := ""

Local oDlg

Local lContinua := .T.
Local lInclui   := (nOpc == 3)
Local lAltera   := (nOpc == 4)

Local nOpca     := 0
Local nSaveSx8  := GetSx8Len()
Local aIntSE4	:= {}

//Ŀ
// Monta a entrada de dados do arquivo                          
//
Private aCols     := {}
Private aHeader   := {}
Private aTELA[0][0]
Private aGETS[0]                    
Private aRotina   := MenuDef()


A035Int( 1, nOpc, aIntSE4 )

If nOpc > Len(aRotina)
	nOpc := 1
Endif

SaveInter()

If nOpc == 5
	lContinua := A360CanDel(SE4->E4_CODIGO)
Endif	

If lContinua

	If lInclui
		RegToMemory( "SE4", .T., .F. )
	Else
		If lAltera
			SoftLock("SE4")
			RegToMemory( "SE4", .F., .F. )
		Else
			RegToMemory( "SE4", .F., .F. )
			lContinua := .T.
		EndIf
	EndIf

	dbSelectArea("SEC")
	dbSetOrder(1)
	
	If lContinua
		//Ŀ
		// Monta aHeader e aCols utilizando a funcao FillGetDados.      
		//
		If !lInclui
			cSeek  := xFilial("SEC")+M->E4_CODIGO
			cWhile := "SEC->EC_FILIAL+SEC->EC_CODIGO"
			//Ŀ
			// Sintaxe da FillGetDados(nOpcX,Alias,nOrdem,cSeek,bSeekWhile,uSeekFor,aNoFields,aYesFields,lOnlyYes,cQuery,bMontCols,lEmpty,aHeaderAux,aColsAux,bAfterCols,bBeforeCols,bAfterHeader,cAliasQry |
			//	
			FillGetDados(nOpc,"SEC",1,cSeek,{|| &cWhile },,,,,,,,aHeader,aCols,,,,)
		Endif
		
		If Empty(aCols)
			//Ŀ
			// Sintaxe da FillGetDados(nOpcX,Alias,nOrdem,cSeek,bSeekWhile,uSeekFor,aNoFields,aYesFields,lOnlyYes,cQuery,bMontCols,lEmpty,aHeaderAux,aColsAux,bAfterCols,bBeforeCols,bAfterHeader,cAliasQry |
			//
			FillGetDados(nOpc,"SEC",1,,,,,,,,,.T.,aHeader,aCols,,,,)
			aCols[1][aScan(aHeader,{|x| Trim(x[2])=="EC_ITEM"})] := StrZero(1,Len(SEC->EC_ITEM))
		Endif	

		If ( Type("l360Auto") == "U" .OR. !l360Auto )
			aObjects := {} 
			AAdd( aObjects, { 100, 100, .t., .t. } )
			AAdd( aObjects, { 100, 100, .t., .t. } )
			
			aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 } 
			aPosObj := MsObjSize( aInfo, aObjects ) 
			
		 	DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 To aSize[6],aSize[5] of oMainWnd PIXEL
				EnChoice( "SE4", nReg, nOpc,,,,,aPosObj[1], , 3, , , , , ,.F. )
				oGetD := MsNewGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],IIF(!lInclui.And.!lAltera,0,GD_INSERT+GD_UPDATE+GD_DELETE),"A360LinOk()","A360TudOk()","+EC_ITEM",/*alteraveis*/,/*freeze*/,MAXGETDAD,/*fieldok*/,/*superdel*/,/*delok*/,,aHeader,aCols)	
				
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| nOpca := 1,aCols:=oGetD:aCols,If(Obrigatorio(aGets,aTela) .And. oGetD:TudoOk(),oDlg:End(), nOpca :=  0 )},{|| nOpca := 2,oDlg:End()})
		Else
			//Ŀ
			// validando dados pela rotina automatica                       
			//
			If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)},aRotina[nOpc][4]) .And. MsGetDAuto(aAutoItens,"A360LinOk()",{|| A360TudOk()},aAutoCab,aRotina[nOpc][4])
				nOpcA := 1
			EndIf		
		EndIf
		If nOpca == 1
			Begin Transaction
				lGravou := A360Grava(nOpc-2,aCols,aHeader)
				
				If ( lGravou )
					EvalTrigger()
					While (GetSx8Len() > nSaveSx8)
						ConfirmSx8()
					EndDo
				EndIf
				
			End Transaction
		
			If (lGravou)
				A035Int( 2, nOpc, aIntSE4 )
			EndIf
		
			While (GetSx8Len() > nSaveSx8)
				RollBackSx8()
			EndDo
		
			MsUnlockAll()    	
		Else
			While (GetSx8Len() > nSaveSx8)
				RollBackSx8()
			EndDo			
		Endif	
	Endif	

Endif
RestInter()
	
Return

/*/

Ŀ
Funo    A360Limite Autor  Raul C. Capeleti       Data  28/03/94 
Ĵ
Descrio  Verifica o valor dos limites digitados.                    
Ĵ
Sintaxe e  A360Limite()                                               
Ĵ
 Uso       MATA360                                                    
ٱ


/*/
FUNCTION A360Limite()
If Empty(M->E4_INFER) .and. Empty(M->E4_SUPER)
	Return .T.
ElseIf !Empty(M->E4_INFER) .and. Empty(M->E4_SUPER)
	Return .T.
ElseIf !Empty(M->E4_INFER) .and. !Empty(M->E4_SUPER)
	If M->E4_INFER > M->E4_SUPER
		Help(" ",1,"A360LIMINF")
		Return .F.
	End
ElseIf Empty(M->E4_SUPER) .AND. !Empty(M->E4_INFER)
	Help(" ",1,"A360LIMINF")
	Return .F.
End
Return .T.


/*/

Ŀ
Funo    A360Grava  Autor  Henry Fila             Data  15/10/03 
Ĵ
Descrio  Rotina de Gravacao                                         
Ĵ
ParametrosExpC1: Alias do cabecalho do pedido de venda                
          ExpN2: Recno do cabecalho do pedido de venda                
          ExpN3: Opcao do arotina                                     
Ĵ
Sintaxe e  A360Grava()                                                
Ĵ
 Uso       MATA360                                                    
ٱ


/*/

Function A360Grava(nOpcao,aCols,aHeader)

Local aArea     := GetArea()
Local bCampo 	:= {|nCPO| Field(nCPO) }
Local lGravou   := .F.
Local lOk		  := .T.
Local nX        := 0
Local nY        := 0        
Local nPosRecno := Len(aHeader)
Local lIntegDef  := FWHasEAI("MATA360",.T.,,.T.)

Private INCLUI  := .F.
PRIVATE ALTERA  :=  .F.
Do Case
Case nOpcao <> 3

	//Ŀ
	//Grava o Cabecalho                                             
	//
	dbSelectArea("SE4")
	dbSetOrder(1)
	If MsSeek(xFilial("SE4")+M->E4_CODIGO)
		ALTERA := .T.
		RecLock("SE4",.F.)
	Else
		INCLUI := .T.
		RecLock("SE4",.T.)
	EndIf
	For nX := 1 TO FCount()
		FieldPut(nX,M->&(EVAL(bCampo,nX)))
	Next nX
	SE4->E4_FILIAL := xFilial("SE4")
	
	SE4->(FkCommit())

	If lIntegDef
		FwIntegDef("MATA360")
	EndIf
	//Ŀ
	//Verifica se o tipo e de desmembramento de condicoes          
	//

	If M->E4_TIPO == "B"

		dbSelectArea("SEC")	

		For nX := 1 To Len(aCols)
	
			If !aCols[nX,Len(aCols[nX])]
	
				If aCols[nX][nPosRecno] > 0    
					dbGoto(aCols[nX][nPosRecno])
					RecLock("SEC",.F.)											
				Else 
					RecLock("SEC",.T.)					
				Endif						

				For nY := 1 To Len(aHeader)
					If ( aHeader[nY][10] != "V" )
						SEC->(FieldPut(FieldPos(aHeader[nY][2]),aCols[nX][nY]))
					EndIf
				Next nY

				SEC->EC_FILIAL := xFilial("SEC")
				SEC->EC_CODIGO := M->E4_CODIGO
				MsUnLock()

			Else
				dbSelectArea("SEC")
				If aCols[nX][nPosRecno] > 0    
					dbGoto(aCols[nX][nPosRecno])
					RecLock("SEC")
						dbDelete() 
					MsUnlock()
				Endif						

			Endif
    		
		Next nX
	Else

		//Ŀ
		//Se for diferente do tipo B verifica se existe alguma linha   
		//no acols e deleta pois nao deve existir SEC com tipo <> de B 		
		//
		dbSelectArea("SEC")
		For nX := 1 To Len(aCols)	
			If aCols[nX][nPosRecno] > 0    
				dbGoto(aCols[nX][nPosRecno])
				RecLock("SEC")
					dbDelete() 
				MsUnlock()
			Endif						
		Next nX
		
	Endif	
                
	lGravou := .T.                                  

OtherWise

	//Ŀ
	//De acordo com a normalizacao exclui itens depois o cabecalho 
	//
	//Ŀ
	//Verifica se o tipo e de desmembramento de condicoes          
	//
	If ExistBlock("MT360DEL")
		lOk := ExecBlock("MT360DEL",.F.,.F.)
		lOk := IIf(ValType(lOk)<>"L",.T.,lOk)
	EndIf	
   
	If lOk
		If M->E4_TIPO == "B"
		                                  
			dbSelectArea("SEC")
			For nX := 1 To Len(aCols)
				If aCols[nX][nPosRecno] > 0    
					dbGoto(aCols[nX][nPosRecno])
					RecLock("SEC")
						dbDelete() 
					MsUnlock()
				Endif						
			Next nX
			
	    Endif
		
		RecLock("SE4",.F.)
			dbDelete()
		MsUnlock()
					
		If lIntegDef
			FwIntegDef("MATA360")
		EndIf
		
		// Funo usada para validar se existe integrao do Protheus com o RM Solum e
		// Para chamar a validao especfica do RM Solum na deleo do Produto. (PMSXFUNB)
		If FindFunction("PmsSlmPrd") .AND. !PmsSlmPrd("CP")
			lGravou := .F.
			Return lGravou
		Endif
		
		lGravou := .T.                                  
	EndIf

EndCase

//Ŀ
//Ponto de entrada apos a atualizacao das tabelas da Cond.Pagto
//
If ExistBlock("MT360GRV")
	ExecBlock("MT360GRV",.F.,.F.)
EndIf	

If lGravou
	MT360AltOk()
EndIf
RestArea(aArea)
Return(lGravou)

/*/

Ŀ
Funo    A360CanDel Autor  Henry Fila             Data  15/10/03 
Ĵ
Descrio  Rotina de Gravacao                                         
Ĵ
ParametrosExpC1: Codigo da condicao de pagamento                      
          ExpL2: Exibe help                                           
Ĵ
Sintaxe e  A360CanDel()                                               
Ĵ
 Uso       MATA360                                                    
ٱ


/*/

Function A360CanDel(cCodigo,lHelp)

Local aArea     := GetArea()
Local aAreaSE4  := SE4->(GetArea())
Local aAreaSEC  := SEC->(GetArea())
Local lCanDel   := .T.          
Local cQuery    := ""

Default lHelp   := .T.
Default cCodigo := " "
//Ŀ
// Monta a entrada de dados do arquivo                          
//

dbSelectArea( "SE4" )
If lCanDel

   //Ŀ
   //Verifica nos pedidos de venda                            
   //
   	cQuery := "SELECT COUNT(*) RECSC5 FROM "
	cQuery += RetSqlName("SC5") + " SC5 "
	cQuery += " WHERE "                                    
	cQuery += "C5_FILIAL = '"+xFilial("SC5")+"' AND "
	cQuery += "C5_CONDPAG = '" + cCodigo + "' AND "
	cQuery += "SC5.D_E_L_E_T_ = ' ' "
	
	cQuery := ChangeQuery(cQuery)
	
	dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBSC5",.F.,.T.)
	
	If TRBSC5->RECSC5 > 0
		If lHelp
			a360DelMsg("SC5")
		Endif	
		lCanDel := .F.
	Endif							
	
	dbCloseArea()
	dbSelectArea("SE4")
	
	//Ŀ
	//Verifica nos orcamentos                                  
	//
	If lCanDel
		cQuery := "SELECT COUNT(*) RECSCJ FROM "
		cQuery += RetSqlName("SCJ") + " SCJ "
		cQuery += " WHERE "                                    
		cQuery += "CJ_FILIAL = '"+xFilial("SCJ")+"' AND "
		cQuery += "CJ_CONDPAG = '" + cCodigo + "' AND "
		cQuery += "SCJ.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBSCJ",.F.,.T.)
	
		If TRBSCJ->RECSCJ > 0
			If lHelp
				a360DelMsg("SCJ")
			Endif	
			lCanDel := .F.
		Endif							
		
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif
	
	//Ŀ
	//Verifica nos pedidos de compra                           
	//
	If lCanDel
		cQuery := "SELECT COUNT(*) RECSC7 FROM "
		cQuery += RetSqlName("SC7") + " SC7 "
		cQuery += " WHERE "                                    
		cQuery += "C7_FILIAL = '"+xFilial("SC7")+"' AND "
		cQuery += "C7_COND = '" + cCodigo + "' AND "
		cQuery += "SC7.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBSC7",.F.,.T.)
	
		If TRBSC7->RECSC7 > 0
			If lHelp
				a360DelMsg("SC7")
			Endif	
			lCanDel := .F.
		Endif							
	
		dbCloseArea()
		dbSelectArea("SE4")
	                     
	Endif
	
	//Ŀ
	//Verifica nos clientes                                    
	//
	If lCanDel
		cQuery := "SELECT COUNT(*) RECSA1 FROM "
		cQuery += RetSqlName("SA1") + " SA1 "
		cQuery += " WHERE "
		cQuery += "A1_FILIAL = '"+xFilial("SA1")+"' AND "
		cQuery += "A1_COND = '" + cCodigo + "' AND "
		cQuery += "SA1.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBSA1",.F.,.T.)
	
		If TRBSA1->RECSA1 > 0
			If lHelp
				a360DelMsg("SA1")
			Endif	
			lCanDel := .F.
		Endif							
	
		dbCloseArea()
		dbSelectArea("SE4")
	                     
	Endif
	
	//Ŀ
	//Verifica nas cotacoes                                    
	//
	
	If lCanDel
		cQuery := "SELECT COUNT(*) RECSC8 FROM "
		cQuery += RetSqlName("SC8") + " SC8 "
		cQuery += " WHERE "                                    
		cQuery += "C8_FILIAL = '"+xFilial("SC8")+"' AND "
		cQuery += "C8_COND = '" + cCodigo + "' AND "
		cQuery += "SC8.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBSC8",.F.,.T.)
	
		If TRBSC8->RECSC8 > 0
			If lHelp
				a360DelMsg("SC8")
			Endif	
			lCanDel := .F.
		Endif							
	
		dbCloseArea()
		dbSelectArea("SE4")
	
	                     
	Endif
	
	//Ŀ
	//Verifica nas notas de entrada                            
	//
	If lCanDel
		cQuery := "SELECT COUNT(*) RECSF1 FROM "
		cQuery += RetSqlName("SF1") + " SF1 "
		cQuery += " WHERE "                                    
		cQuery += "F1_FILIAL = '"+xFilial("SF1")+"' AND "
		cQuery += "F1_COND = '" + cCodigo + "' AND "
		cQuery += "SF1.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBSF1",.F.,.T.)
	
		If TRBSF1->RECSF1 > 0
			If lHelp
				a360DelMsg("SF1")
			Endif	
			lCanDel := .F.
		Endif							
	
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif
	
	//Ŀ
	//Verifica nas notas de saida                              
	//
	If lCanDel
		cQuery := "SELECT COUNT(*) RECSF2 FROM "
		cQuery += RetSqlName("SF2") + " SF2 "
		cQuery += " WHERE "                                    
		cQuery += "F2_FILIAL = '"+xFilial("SF1")+"' AND "
		cQuery += "F2_COND = '" + cCodigo + "' AND "
		cQuery += "SF2.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBSF2",.F.,.T.)
	
		If TRBSF2->RECSF2 > 0
			If lHelp
				a360DelMsg("SF2")
			Endif	
			lCanDel := .F.
		Endif							
		
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif
	
	//Ŀ
	//Verifica os contratos de parceria - compras              
	//
	If lCanDel
		cQuery := "SELECT COUNT(*) RECSC3 FROM "
		cQuery += RetSqlName("SC3") + " SC3 "
		cQuery += " WHERE "                                    
		cQuery += "C3_FILIAL = '"+xFilial("SC3")+"' AND "
		cQuery += "C3_COND = '" + cCodigo + "' AND "
		cQuery += "SC3.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBSC3",.F.,.T.)
	
		If TRBSC3->RECSC3 > 0
			If lHelp
				a360DelMsg("SC3")
			Endif	
			lCanDel := .F.
		Endif							
		
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif
	
	//Ŀ
	//Verifica os contratos de parceria - vendas               
	//
	If lCanDel
		cQuery := "SELECT COUNT(*) RECADA FROM "
		cQuery += RetSqlName("ADA") + " ADA "
		cQuery += " WHERE "                                    
		cQuery += "ADA_FILIAL = '"+xFilial("ADA")+"' AND "
		cQuery += "ADA_CONDPG = '" + cCodigo + "' AND "
		cQuery += "ADA.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBADA",.F.,.T.)
	
		If TRBADA->RECADA > 0
			If lHelp
				a360DelMsg("ADA")
			Endif	
			lCanDel := .F.
		Endif							
		
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif
	//Ŀ
	//Verifica os Projetos - Field Service                     
	//
	If lCanDel 
		cQuery := "SELECT COUNT(*) RECABH FROM "
		cQuery += RetSqlName("ABH") + " ABH "
		cQuery += " WHERE "                                    
		cQuery += "ABH_FILIAL = '"+xFilial("ABH")+"' AND "
		cQuery += "ABH_CPAGPV = '" + cCodigo + "' AND "
		cQuery += "ABH.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBABH",.F.,.T.)
	
		If TRBABH->RECABH > 0
			If lHelp
				a360DelMsg("ABH")
			Endif	
			lCanDel := .F.
		Endif							
		
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif
	//Ŀ
	//Verifica os Oramentos - Field Service                     
	// 
	If lCanDel
		cQuery := "SELECT COUNT(*) RECAB3 FROM "
		cQuery += RetSqlName("AB3") + " AB3 "
		cQuery += " WHERE "                                    
		cQuery += "AB3_FILIAL = '"+xFilial("AB3")+"' AND "
		cQuery += "AB3_CONPAG = '" + cCodigo + "' AND "
		cQuery += "AB3.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBAB3",.F.,.T.)
	
		If TRBAB3->RECAB3 > 0
			If lHelp
				a360DelMsg("AB3")
			Endif	
			lCanDel := .F.
		Endif							
		
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif 
	
	//Ŀ
	//Verifica os Tabela de preo                              
	// 
	If lCanDel 
		cQuery := "SELECT COUNT(*) RECDA0 FROM "
		cQuery += RetSqlName("DA0") + " DA0 "
		cQuery += " WHERE "                                    
		cQuery += "DA0_FILIAL = '"+xFilial("DA0")+"' AND "
		cQuery += "DA0_CONDPG = '" + cCodigo + "' AND "
		cQuery += "DA0.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBDA0",.F.,.T.)
	
		If TRBDA0->RECDA0 > 0
			If lHelp
				a360DelMsg("DA0")
			Endif	
			lCanDel := .F.
		Endif							
		
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif
				
	//Ŀ
	//Verifica as Regras de Desconto                           
	// 
	If lCanDel 
		cQuery := "SELECT COUNT(*) RECACO FROM "
		cQuery += RetSqlName("ACO") + " ACO "
		cQuery += " WHERE "                                    
		cQuery += "ACO_FILIAL = '"+xFilial("ACO")+"' AND "
		cQuery += "ACO_CONDPG = '" + cCodigo + "' AND "
		cQuery += "ACO.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBACO",.F.,.T.)
	
		If TRBACO->RECACO > 0
			If lHelp
				a360DelMsg("ACO")
			Endif	
			lCanDel := .F.
		Endif							
		
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif
	
	//Ŀ
	//Verifica as Regras de Bonificao                           
	// 
	If lCanDel 
		cQuery := "SELECT COUNT(*) RECACQ FROM "
		cQuery += RetSqlName("ACQ") + " ACQ "
		cQuery += " WHERE "                                    
		cQuery += "ACQ_FILIAL = '"+xFilial("ACQ")+"' AND "
		cQuery += "ACQ_CONDPG = '" + cCodigo + "' AND "
		cQuery += "ACQ.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBACQ",.F.,.T.)
	
		If TRBACQ->RECACQ > 0
			If lHelp
				a360DelMsg("ACQ")
			Endif	
			lCanDel := .F.
		Endif							
		
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif
	
	//Ŀ
	//Verifica as Regras de Negocio                            
	// 
	If lCanDel 
		cQuery := "SELECT COUNT(*) RECACT FROM "
		cQuery += RetSqlName("ACT") + " ACT "
		cQuery += " WHERE "                                    
		cQuery += "ACT_FILIAL = '"+xFilial("ACT")+"' AND "
		cQuery += "ACT_CONDPG = '" + cCodigo + "' AND "
		cQuery += "ACT.D_E_L_E_T_ = ' ' "
	
		cQuery := ChangeQuery(cQuery)
	
		dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBACT",.F.,.T.)
	
		If TRBACT->RECACT > 0
			If lHelp
				a360DelMsg("ACT")
			Endif	
			lCanDel := .F.
		Endif							
		
		dbCloseArea()
		dbSelectArea("SE4")
		
	Endif
			
EndIf             

RestArea(aAreaSEC)
RestArea(aAreaSE4)
RestArea(aArea)

Return(lCanDel)

/*


ͻ
Programa  A360DelMsgAutor  Microsiga           Fecha   01/06/05   
͹
Desc.     Exibe uma mensagem de aviso para os items que nao podem ser 
          excluidos porque estao em outros arquivos.                  
͹
Parametros cAlias - arquivo onde o item foi encontrado.               
͹
Uso        AP                                                         
ͼ


*/
Function a360DelMsg(cAlias)
Local cMsg := ""

SX2->(MsSeek(cAlias))
cMsg:=STR0027+' "'+Lower(Alltrim(X2Nome()))+'"'+CRLF+Lower(STR0009) //"Ha itens em"
Help(" ",1,"NODELETA",,cMsg,3)
Return .F.

/*/


Ŀ
Funcao    A360LinOk  Autor Henry Fila              Data 16.10.2003
Ĵ
Descrio Validacao da Linha Ok da Getdados do desmembramento das     
          condicoes de pagamento                                      
Ĵ
ParametrosNenhum                                                      
                                                                      
Ĵ
Retorno   ExpL1: Indica se a linha e valida                           
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo efetuar a validacao da linhaOk
                                                                      
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais                                                  
ٱ


/*/
Function a360LinOk()

Local lRet     := .T.
Local nPosCond := Ascan(aHeader,{|x| Alltrim(x[2]) == "EC_COND"})
Local nPosTipo := Ascan(aHeader,{|x| Alltrim(x[2]) == "EC_TIPO"})
Local nPosRat  := Ascan(aHeader,{|x| Alltrim(x[2]) == "EC_RATEIO"})

If M->E4_TIPO == "B"

	If !aCols[n][Len(aHeader)+1]

		If Empty(aCols[n][nPosCond]) .Or. aCols[n][nPosRat] == 0 .Or. Empty(aCols[n][nPosTipo])
			Help(" ",1,"OBRIGAT")
			lRet := .F.
		Endif
	
	Endif	
Else
	If !aCols[n][Len(aHeader)+1]

		If !Empty(aCols[n][nPosCond]) .Or. aCols[n][nPosRat] != 0 .Or. !Empty(aCols[n][nPosTipo])
			Help(" ",1,"M360DESMEM")
			lRet := .F.
		Endif
	Endif	
Endif	

Return(lRet)


/*/


Ŀ
Funcao    A360TudOk  Autor Henry Fila              Data 16.10.2003
Ĵ
Descrio Validacao da TudoOk da Getdados do desmembramento da condi  
          cao de pagamento                                            
Ĵ
Parametros                                                            
                                                                      
Ĵ
Retorno   ExpL1: Indica se todos os itens sao validos                 
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo efetuar a validacao da TudoOk 
                                                                      
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
ٱ


/*/
Function a360TudOk()

Local lRet     := .T.
Local nX       := 0
Local nPercent := 0                                                 
Local nPosCond := Ascan(aHeader,{|x| Alltrim(x[2]) == "EC_COND"})
Local nPosTipo := Ascan(aHeader,{|x| Alltrim(x[2]) == "EC_TIPO"})
Local nPosRat  := Ascan(aHeader,{|x| Alltrim(x[2]) == "EC_RATEIO"})

lRet := A360Cond() //verifica o tipo e a condio de pagamento

//Ŀ
//Verifica se a soma dos rateios informados                
//

If M->E4_TIPO == "B"

	For nX := 1 to Len(aCols)
		If !aCols[nX][Len(aHeader)+1]
			nPercent += aCols[nX][nPosRat]
			
			If Empty(aCols[nX][nPosCond]) .Or. Empty(aCols[nX][nPosTipo]) .Or. aCols[nX][nPosRat] == 0
				Help(" ",1,"OBRIGAT")
				lRet := .F.
			Endif	
			
		Endif		
	Next nX
	
	If nPercent <> 100
		Help(" ",1,"M360RATEIO")
		lRet := .F.
	EndIf

Else

	If M->E4_TIPO == "2" .And. Val(Subs(M->E4_CODIGO,2,1)) == 0
		Help( " ",1,"A360TIPO2" )
		lRet := .F.
	Endif

	If lRet
		For nX := 1 to Len(aCols)
			If !aCols[nX][Len(aHeader)+1] .And. (!Empty(aCols[nX][nPosCond]) .Or. aCols[nX][nPosRat] <> 0 .Or. ;
											!Empty(aCols[nX][nPosTipo]))
				Help(" ",1,"M360DESMEM")
				lRet := .F.
			Endif		
		Next nX
    Endif
    
Endif

If lRet
	If ExistBlock("MT360VLD")
		lRet := ExecBlock("MT360VLD",.F.,.F.)
	Endif
Endif	

	
Return(lRet)


/*/


Ŀ
Funcao    A360VldTP  Autor Henry Fila              Data 16.10.2003
Ĵ
Descrio Validacao da condicao de pagamento informada no desmembra-  
          mento                                                       
Ĵ
Parametros                                                            
                                                                      
Ĵ
Retorno   ExpL1: Indica se a condicao de pagamento informada e valida 
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo efetuar a validacao da condi- 
          cao de pagamento no desmembramento                          
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
ٱ


/*/
Function a360VldTP()

Local lRet     := .T.        
Local aArea    := GetArea()
Local aAreaSE4 := SE4->(GetArea())
Local oMdl


oMdl := FwModelActive()	 
If oMdl:GetValue("SECDETAIL","EC_TIPO") == "9" 
	Help(" ",1,"M360TIPO9")
	lRet := .F.            
Endif


RestArea(aAreaSE4)
RestArea(aArea)

Return(lRet)

/*/


Ŀ
Fun  o  A360ConDes Autor  Henry Fila             Data  08/05/96 
Ĵ
Descrio  Executa a Validacao da Condicao de Pagamento               
Ĵ
Sintaxe e  A360ConDes()                                               
Ĵ
 Uso       MATA360                                                    
ٱ


/*/

Function A360ConDes()

Local lRet   := .T.
Local nNumEl := 0
Local aTp8   := {}
Local oMdl	 := FwModelActive()        
Local nPosTipo
Local oMdlSEC
Local cTipoCond

If ValType(oMdl) == "O"

	
	oMdlSEC := oMdl:GetModel("SECDETAIL")
	
	Begin Sequence
			
		cTipoCond := oMdlSEC:GetValue("EC_TIPO")
		
		Do Case
		Case A360CndErr( cTipoCond,oMdlSEC:GetValue("EC_COND"),@nNumEl )
			Help( " ",1,"A360TIPO" ) 
			lRet := .F.
		Case ((cTipoCond == "1") .And. (nNumEl < 01)) 
			Break( nil )
		Case ((cTipoCond == "2") .And. (nNumEl # 01)) 
			Break( nil )
		Case ((cTipoCond == "3") .And. (nNumEl < 03)) 
			Break( nil )
		Case ((cTipoCond == "4") .And. (nNumEl # 03)) 
			Break( nil )
		Case ((cTipoCond == "5") .And. (nNumEl # 03)) 
			Break( nil )
		Case ((cTipoCond == "6") .And. (nNumEl # 04)) 
			Break( nil )
		Case ((cTipoCond == "7") .And. (nNumEl # 13)) 
			Break( nil )
		Case ((cTipoCond == "8"))
			If nNumEl < 01
				Break( nil )
			Else
				aTp8:=ArrayTP8(oMdlSEC:GetValue("EC_COND"))
				If Len(aTP8) = 0
					Break( Nil )
				EndIf
			EndIf
		Case ((cTipoCond == "9") .And. (nNumEl > 01)) ; Break( nil )
		Case (cTipoCond == "A")
		EndCase
		Recover
		
		Help( " ",1,"A360TIP"+cTipoCond ) 
		lRet := .F.
		
	End Sequence
Else 
	nPosTipo := Ascan(aHeader,{|x| Alltrim(x[2]) == "EC_TIPO"})

	Begin Sequence
		
		Do Case
		Case A360CndErr( aCols[n][nPosTipo],M->EC_COND,@nNumEl )
			Help( " ",1,"A360TIPO" ) 
			lRet := .F.
		Case ((aCols[n][nPosTipo] == "1") .And. (nNumEl < 01)) 
			Break( nil )
		Case ((aCols[n][nPosTipo] == "2") .And. (nNumEl # 01)) 
			Break( nil )
		Case ((aCols[n][nPosTipo] == "3") .And. (nNumEl < 03)) 
			Break( nil )
		Case ((aCols[n][nPosTipo] == "4") .And. (nNumEl # 03)) 
			Break( nil )
		Case ((aCols[n][nPosTipo] == "5") .And. (nNumEl # 03)) 
			Break( nil )
		Case ((aCols[n][nPosTipo] == "6") .And. (nNumEl # 04)) 
			Break( nil )
		Case ((aCols[n][nPosTipo] == "7") .And. (nNumEl # 13)) 
			Break( nil )
		Case ((aCols[n][nPosTipo] == "8"))
			If nNumEl < 01
				Break( nil )
			Else
				aTp8:=ArrayTP8(M->EC_COND)
				If Len(aTP8) = 0
					Break( Nil )
				EndIf
			EndIf
		Case ((aCols[n][nPosTipo] == "9") .And. (nNumEl > 01)) ; Break( nil )
		Case (aCols[n][nPosTipo] == "A")
		EndCase
		Recover
		
		Help( " ",1,"A360TIP"+aCols[n][nPosTipo] ) 
		lRet := .F.
		
	End Sequence
EndIf
Return( lRet )



/*/

Ŀ
Funo	 a360SimCnd Autor  Henry Fila             Data  23.10.03  
Ĵ
Descrio  Rotina para simulacao de condicao de pagamento              
Ĵ
Sintaxe	  a360SimCnd()                                                
Ĵ
Parametros Nenhum                                                      
Ĵ
Uso		  Generico 										           
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL. 					   
Ĵ
 PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO					   
Ĵ
ٱ


/*/

Function a360SimCnd()

Local aVencto  := {}
Local aArea    := GetArea()
Local aAreaSE4 := SE4->(GetArea())

Local cCodigo  := SE4->E4_CODIGO
Local cTipo    := SE4->E4_TIPO

Local lRet     := .F.

Local nValTit  := 0      
Local nValIpi  := 0      
Local nValSol  := 0      
Local nY       := 0
Local dDataRef := Ctod("//")        

Local oWizard   
Local oValTit                         
Local oValIPI
Local oValSol
Local oDataRef     
Local oVencto
    

DEFINE WIZARD oWizard TITLE OemtoAnsi(STR0010) HEADER OemtoAnsi(STR0011) ; //"Simulacao de aplicacao de condicao de pagamento"###"Dados Genericos"
		MESSAGE OemtoAnsi(STR0012)  TEXT " "; //"Informe os dados necessarios para a simulacao da condicao de pagamento."
		NEXT {|| .t.} ;
		FINISH {||.F.} PANEL NOFIRSTPANEL 

	oWizard:GetPanel(1)
	
	@ 15,20 SAY OemtoAnsi(STR0013) OF oWizard:GetPanel(1) SIZE 60,8 PIXEL  //"Data de referencia"
	@ 15,80 MSGET oDataRef VAR dDataRef OF oWizard:GetPanel(1) SIZE 60,8 PIXEL 
	
	@ 30,20 SAY OemtoAnsi(STR0014) OF oWizard:GetPanel(1) SIZE 60,8 PIXEL  //"Valor de referencia"
	@ 30,80 MSGET oValTit VAR nValTit Picture "@E 99,999,999.99" OF oWizard:GetPanel(1) SIZE 60,8 PIXEL 

	CREATE PANEL oWizard  HEADER OemtoAnsi(STR0015) MESSAGE OemtoAnsi(STR0016) ; //"Informe os valores dos impostos a serem calculados"
	 BACK {||.T.} PANEL


	oWizard:GetPanel(2)
	
	@ 15,20 SAY OemtoAnsi(STR0017) OF oWizard:GetPanel(2) SIZE 60,8 PIXEL  //"Valor do IPI"
	@ 15,80 MSGET oValIPI VAR nValIpi Picture "@E 99,999,999.99" OF oWizard:GetPanel(2) SIZE 60,8 PIXEL 
	
	@ 30,20 SAY OemtoAnsi(STR0018) OF oWizard:GetPanel(2) SIZE 70,8 PIXEL  //"Valor do Icms Solidario"
	@ 30,80 MSGET oValSol VAR nValSol Picture "@E 99,999,999.99" OF oWizard:GetPanel(2) SIZE 60,8 PIXEL 


	CREATE PANEL oWizard  HEADER OemtoAnsi(STR0019) MESSAGE " " ; //"Resumo das informacoes"
	 BACK {||.T.} FINISH {|| lRet := .T. } PANEL

	oWizard:GetPanel(3)

	@ 05,20 SAY OemtoAnsi(STR0020) OF oWizard:GetPanel(3) SIZE 60,8 PIXEL  //"Codigo da condicao "
	@ 05,80 MSGET cCodigo OF oWizard:GetPanel(3) SIZE 30,8 F3 "SE4" READONLY PIXEL 

	@ 18,20 SAY OemtoAnsi(STR0021) OF oWizard:GetPanel(3) SIZE 60,8 PIXEL  //"Tipo "
	@ 18,80 MSGET cTipo OF oWizard:GetPanel(3) SIZE 15,8 PIXEL When .F.

	@ 31,20 SAY OemtoAnsi(STR0014) OF oWizard:GetPanel(3) SIZE 60,8 PIXEL  //"Valor de referencia"
	@ 31,80 MSGET nValTit OF oWizard:GetPanel(3) Picture "@E 99,999,999.99" SIZE 60,8 PIXEL 

	@ 44,20 SAY OemtoAnsi(STR0013) OF oWizard:GetPanel(3) SIZE 60,8 PIXEL  //"Data de referencia"
	@ 44,80 MSGET dDataRef OF oWizard:GetPanel(3) SIZE 60,8 When .F. PIXEL 

	@ 57,20 SAY OemtoAnsi(STR0017) OF oWizard:GetPanel(3) SIZE 60,8 PIXEL  //"Valor do IPI"
	@ 57,80 MSGET nValIpi OF oWizard:GetPanel(3) Picture "@E 99,999,999.99" SIZE 60,8 When .F. PIXEL 

	@ 70,20 SAY OemtoAnsi(STR0018) OF oWizard:GetPanel(3) SIZE 60,8 PIXEL  
	@ 70,80 MSGET nValSol OF oWizard:GetPanel(3) Picture "@E 99,999,999.99" SIZE 60,8 When .F. PIXEL 


ACTIVATE WIZARD oWizard CENTERED  WHEN {||.T.}

If lRet
	aVencto := Condicao(nValTit,cCodigo,nValIpi,dDataRef,nValSol)                          

	For nY := 1 To Len(aVencto)
		aVencto[nY][2] := TransForm(aVencto[nY][2],PesqPict("SE1","E1_VALOR"))
	Next nY
    If Len(aVencto)>0
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0022) FROM 09,00 TO 28,80 //"Titulos a serem gerados de acordo com a simulacao"
	                                                                                                        
			@ 005,004 LISTBOX oVencto FIELDS TITLE OemtoAnsi(STR0023),OemtoAnsi(STR0024) SIZE 310,120 PIXEL
			oVencto:SetArray(aVencto)
			oVencto:bLine := {|| aVencto[oVencto:nAt] }
	
			DEFINE SBUTTON FROM 130 ,280 TYPE 1 PIXEL ACTION (oDlg:End()) ENABLE OF oDlg Pixel
	
		ACTIVATE MSDIALOG oDlg CENTERED
	EndIf
Endif

RestArea(aAreaSE4)
RestArea(aArea)
Return


/*/

Ŀ
Funo	 a360F3     Autor  Henry Fila             Data  23.10.03  
Ĵ
Descrio  Rotina para inclusao de condicaoo de pagamento via F3       
Ĵ
Sintaxe	  a360F3()                                                    
Ĵ
Parametros ExpC1 3=Inclusao;2=Visualizacao                             
Ĵ
Uso		  Generico 										           
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL. 					   
 Ĵ
 PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO					   
Ĵ
ٱ


/*/
	
Function a360F3(nTipo)	

If !IsInCallStack("CNTA100") .AND. !IsInCallStack("FINA290")
	SaveInter()
	FWExecView(,'MATA360', nTipo)
	RestInter()
Else 
	A360Man("SE4",SE4->(Recno()),nTipo)
EndIf
Return  

/*


Ŀ
Funcao    MT360AltOk Autor  Nunzio Autorino Junior Data  31/03/08 
Ĵ
Descricao  Responsavel em enviar os dados da condicao de pagamento    
			  para integracao    										  
Ĵ
Uso        Cadastro de condicao de pagamento                          
ٱ


*/
Function MT360AltOk()

Local cTipo 		:= ""				   							//Como os dados serao integrados no processo offline
Local oProcessOff 	:= Nil				   							//Objeto do tipo LJCProcessoOffLine
Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)			//Identifica se o ambiente esta operando em offline
	
//Verifica se o ambiente esta em off-line
If lAmbOffLn
	//Instancia o objeto LJCProcessoOffLine
	oProcessOff := LJCProcessoOffLine():New("013")
		
	//Determina o tipo de operacao 
	If INCLUI
		cTipo := "INSERT"
	ElseIf ALTERA
		cTipo := "UPDATE"
	Else
		cTipo := "DELETE"
			
		//Considera os registros deletados
		SET DELETED OFF
	EndIf
			    
	If !Empty(cTipo)
		//Insere os dados do processo (registro da tabela)
		oProcessOff:Inserir("SE4", xFilial("SE4") + SE4->E4_CODIGO, 1, cTipo)
		
		//Processa os dados 
		oProcessOff:Processar()
	EndIf
		
	//Desconsidera os registros deletados
	SET DELETED ON
EndIf
Return Nil


/*/


Ŀ
Funo    A035Int Autor  Vendas CRM                Data  15/09/2009 
Ĵ
Descrio  Realiza integracao com a criterium ou outra integracao       
          que utiliza o framework do SIGALOJA de integracao.            
           O parmetro aIntSB1 normalmente  vazio.                     
Ĵ
Sintaxe   A035Int()                                                     
Ĵ
ParametrosExpN1: Momento da chamada, sendo:                             
                     1: Antes de qualquer alterao                     
                     2: Depois das alteraes                           
          ExpN2: Opo da rotina                                        
          ExpA3: Array contendo o nmero do registro e adaptador do SE4.
ٱ


/*/
Static Function A035Int( nMomento, nOpc, aIntSE4 )
Local lIntegra 		:= SuperGetMv("MV_LJGRINT", .F., .F.)	// Se h integrao ou no
Local aArea			:= GetArea()

If lIntegra
	If nMomento == 1
		MsgRun( STR0029, STR0028, {|| A035IniInt( nOpc, aIntSE4 ) } ) // "Anotando registros para integrao" "Aguarde"
	ElseIf nMomento == 2
		MsgRun( STR0030, STR0028, {|| A035FimInt( nOpc, aIntSE4 ) } ) // "Executando integrao" "Aguarde"
	EndIf
EndIf
	
RestArea( aArea )
Return

/*/


Ŀ
Funo    A035IniInt    Autor  Vendas CRM          Data  15/09/2009 
Ĵ
Descrio  Faz o cache dos itens antes de serem excludos, possibilitan-
          do o envio dos mesmos, mesmo aps de serem apagados.          
           O parmetro aIntSE4 normalmente  vazio.                     
Ĵ
Sintaxe   A035IniInt()                                                  
Ĵ
ParametrosExpN1: Opo da rotina                                        
          ExpA2: Array contendo o nmero do registro e adaptador do SE4.
ٱ


/*/
Static Function A035IniInt( nOpc, aIntSE4 )
Local oFactory		:= LJCAdapXmlEnvFactory():New()
Local cChave		:= ""
	
	// Se houver integrao e no for incluso, anota todos os registros para excluso, caso algum seja excludo
If nOpc != 3
	aIntSE4 :=	{ SE4->(Recno()), oFactory:Create( "SE4" ) }
	cChave 	:= xFilial( "SE4" ) + SE4->E4_CODIGO
	aIntSE4[2]:Inserir( "SE4", cChave, "1", "5" )
	aIntSE4[2]:Gerar()
EndIf
Return

/*/


Ŀ
Funo    A035FimInt    Autor  Vendas CRM          Data  15/09/2009 
Ĵ
Descrio  Envia os itens apagados e todos os outros itens.             
           O parmetro aIntSE4 normalmente  vazio.                     
Ĵ
Sintaxe   A035FimInt()                                                  
Ĵ
ParametrosExpN1: Opo da rotina                                        
          ExpA2: Array contendo o nmero do registro e adaptador do SE4.
ٱ


/*/
Static Function A035FimInt( nOpc, aIntSE4 )
Local oFactory		:= LJCAdapXmlEnvFactory():New( )	// Cria a fabrica de Adaptadores de envio
Local cChave		:= ""
	
// Verifica se houve algum registro apagado, e gera a integrao desse registro
If nOpc != 3
	// Procura pelo registro do cabealho
	SE4->(DbGoTo( aIntSE4[1] ) )
		
	// Se no encontrar, significa que o cabealho foi apagado, ento envia somente a excluso do cabealho
	If SE4->( DELETED() )
		aIntSE4[2]:Finalizar()
	EndIf
EndIf
	
// Independente de ter registros apagados ou no, gera quando no for excluso, todos os outros registros
If nOpc != 5
	aIntSE4 := { SE4->( Recno() ), oFactory:Create( "SE4" ) }
	cChave 	:= xFilial( "SE4" ) + SE4->E4_CODIGO
	aIntSE4[2]:Inserir( "SE4", cChave, "1", cValToChar( nOpc ) )
	aIntSE4[2]:Gerar()
	aIntSE4[2]:Finalizar()
EndIf
Return

/*


ͻ
 Funcao    IntegDef  Autor  Danilo Dias         Data  22/03/2012  
͹
 Desc.     Funcao de integracao com o adapter EAI para envio e        
           recebimento do cadastro de condicoes de pagamento (SE4)    
           utilizando o conceito de mensagem unica.                   
͹
 Uso       MATA360                                                    
ͼ


*/
Static Function IntegDef( cXML, nTypeTrans, cTypeMsg, cVersion, cTransaction, lJSon )
Local aRet 			:= {}

Default cXml 		:= ""
Default nTypeTrans 	:= ""
Default cTypeMsg	:= ""
Default cVersion 	:= ""
Default cTransaction:= ""
Default lJson 		:= .F.

//Apenas os tipos 1,2,4,5,6 so enviados atualmente.
//Todas as condies recebidas so criadas como tipo 1, sendo que
//o nmero mximo de parcelas  limitado ao tamanho do campo E4_COND
//que permite cerca de 11 parcelas no mximo.
If lJSon .And. FindFunction( "MATI360O" )
	aRet := MATI360O( cXML, nTypeTrans, cTypeMsg, cVersion, cTransaction )
Else	
	aRet := MATI360( cXML, nTypeTrans, cTypeMsg, cVersion, cTransaction )
Endif

Return aRet

/*/{Protheus.doc} FatLibMetric
Funo utilizada para validar a data da LIB para ser utilizada na Telemetria
@type       Function
@author     CRM/Faturamento
@since      Maio/2021
@version    12.1.27
@return     __lMetric, lgico, se a LIB pode ser utilizada para Telemetria
/*/
Static Function FatLibMetric()

If __lMetric == Nil 
	__lMetric := FWLibVersion() >= "20210517"
EndIf

Return __lMetric
