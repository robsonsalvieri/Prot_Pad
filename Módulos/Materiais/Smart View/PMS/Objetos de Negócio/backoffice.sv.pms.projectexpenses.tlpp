#Include "FWLIBVERSION.CH"
#Include "totvs.ch"
#Include "msobject.ch"
#Include "totvs.framework.treports.integratedprovider.th"
#Include "tlpp-rest.th"
#Include "tlpp-core.th"
#Include "backoffice.sv.pms.projectexpenses.ch"

Static __lLookUp := FwLibVersion() >= "20231121" as logical

namespace totvs.protheus.backoffice.sv.pms.projectexpenses.treportsintegratedprovider
using namespace totvs.framework.treports.integratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAPMS", tables="AF8,SA1", name="Despesas do Projeto", country="ALL", customTables="ALL")

/*/{Protheus.doc} projectexpensesSmartViewBusinessObject
	Classe para criação do Objeto de Negócio para Relação de Despesas do Projeto
	@author Squad CRM/Faturamento
	@since 10/05/2023
	@version 12.1.2410
*/
Class projectexpensesSmartViewBusinessObject from Integratedprovider
    public method new()			as object
    public method getData()		as object
    public method getSchema()	as object
	public method PMSSV005CreateSQL()

    protected data aFields		as array
    protected data aStruct		as array
    protected data aFieldsValue	as array
    protected data jItems		as json
    protected data cAlias	as character
    protected data cSelectLoc	as character
	protected data cWhereLoc	as character

Endclass


/*{Protheus.doc} new
	Método de instância da classe
	@return object: self
	@author Squad CRM/Faturamento
	@since 10/05/2023
	@version 12.1.2410
*/
   
Method new() class projectexpensesSmartViewBusinessObject

    _Super:new()
    self:appendArea(STR0001) 	 // "Gestão de Projetos"
    self:setDisplayName(STR0002) // "Despesas do Projeto"
    self:setDescription(STR0003) // "Relação de Despesas do Projeto"
    self:setIsLookUp(.T.)

Return self

/*{Protheus.doc} getData
	Retorna os dados do objeto de negócio
	@param nPage, numérico, indica a página atual do relatório
	@param oFilter, objeto, contém o filtro do TReports
	@return object: self:oData
	@author Squad CRM/Faturamento
	@since 10/05/2023
	@version 12.1.2410
*/
Method getData(nPage as numeric, oFilter as object) as object class projectexpensesSmartViewBusinessObject

	Local xValue		:= ""   as  variant	
	Local nX            := 0    as  numeric
	Local nY            := 0    as  numeric
	Local nScan         := 0    as  numeric	
	Local nSaldo        := 0    as  numeric
	Local nPos	        := 0    as  numeric
	Local nPosDt        := 0    as  numeric
	Local nSaldoAcm     := 0    as  numeric
	Local nSaldoDia     := 0    as  numeric
	Local nValAux	    := 0    as  numeric
	Local dIni			:= CTOD("31/12/2050") as  date 
	Local dFim			:= CTOD("01/01/1900") as  date
	Local dX			:= CTOD("  /  /    ") as  date
    Local lObfuscated   := .F.  as  logical
    Local aPDFields     := {}   as  array
	Local aArrayFlx 	:= {}  	as  array
	Local aHandle   	:= {}	as  array
	Local aFluxo	   	:= {}	as  array
	Local aTitAntec	   	:= {}	as  array

	MV_FIL := ""
	MV_DATAERP := Date()
	
	//Metodo para retorno do json dos parametros
	FatSetValueMVPAR(oFilter:GetParameters(),"PMR230") 

	//Array para processamento
    self:aFieldsValue    := { {"TB_DATA",	 {"TB_DATA",     "", 'aArrayFlx[nY][1]'}},;						 
							  {"TB_VLRPREV", {"TB_VLRPREV",  "", 'aArrayFlx[nY][2]'}},;						 
							  {"TB_VLRDESP", {"TB_VLRDESP",  "", 'aArrayFlx[nY][3]'}},;
							  {"TB_DESPDIA", {"TB_DESPDIA",  "", 'aArrayFlx[nY][4]'}},;
							  {"TB_DESPACUM",{"TB_DESPACUM", "", 'aArrayFlx[nY][5]'}}}

    //Verifica se precisa fazer o tratamento para LGPD   
    aPDFields	:= FatGetfieldsLGPD(self:aFields, self:getCustomFields())
    lObfuscated	:= Len(aPDFields) > 0

	//Método que monta a Query
	self:PMSSV005CreateSQL()

	dDatabase := MV_DATAERP

    (self:cAlias)->(dbGoTop())

	While !(self:cAlias)->(Eof())

		nSaldo    := 0
		nSaldoAcm := 0
		nSaldoDia := 0
		aArrayFlx := {}
		dIni      := MV_PAR04             //Data de referencia
		dFim      := MV_PAR04 + MV_PAR03  //Data de referencia + numero de dias
		aHandle   := PmsIniFin((self:cAlias)->AF8_PROJET,(self:cAlias)->AF8_REVISA,Padr((self:cAlias)->AF8_PROJET,Len(AFC->AFC_EDT)),.T.)
		aFluxo    := PmsRetFinVal(aHandle,4,Padr((self:cAlias)->AF8_PROJET,Len(AFC->AFC_EDT)))

		AEval( aFluxo[2], {|x| (IIf( x[3] > 0 .And. MV_PAR05 == 2, aAdd(aTitAntec, { x[1], 'PA', x[3] }), ) ) } )

		aSort(aFluxo[2],,,{|x,y| x[1]<y[1]} )
		aSort(aTitAntec,,,{|x,y| x[1]<y[1]} )

		nSaldo    := aFluxo[6] - aFluxo[3] // Receita - Despesa
		nSaldoAcm := nSaldo

		dX := dIni
		While dX <= dFim

			nSaldoDia := 0
			aAdd(aArrayFlx,{dX,0,0,0,0})

			//titulos a pagar - AFR 
			nPosDt := aScan(aFluxo[2],{|x| x[1] == dX})
			If nPosDt > 0

				aArrayFlx[Len(aArrayFlx)][3] := aFluxo[2][nPosDt][2]

				//Se Acumular Antecipados e o registro do fluxo nao eh antecipado entao
				//a variavel nValAux pega o valor do titulo, abate os valores antecipados e depois totaliza no saldo do dia,saldo acumulado,etc
				If (Mv_par05 == 2) .And. (aFluxo[2,nPosDt,3] == 0)

					nValAux := aFluxo[2,nPosDt,2]
					nPos := aScan(aTitAntec, {|x| x[1] <= aFluxo[1,nPosDt,1] .And. x[2] == 'PA' .And. x[3] > 0 })

					AEval(aTitAntec,{|x|(nPos := aScan( aTitAntec, {|x| x[1] <= aFluxo[1,nPosDt,1] .And. x[2] == 'PA' .And. x[3] > 0 } ),;
											IIf(nPos > 0 .And. nValAux > 0,;
												IIf(aTitAntec[nPos,3] >= nValAux,;
													(aTitAntec[nPos,3] -= nValAux, nValAux := 0),;
													(nValAux -= aTitAntec[nPos,3], aTitAntec[nPos,3] := 0);
												),;
											);
										);
									};
					)

					nSaldoDia -= nValAux
					nSaldoAcm -= nValAux
				Else
					nSaldoDia -= aFluxo[2,nPosDt,2]
					nSaldoAcm -= aFluxo[2,nPosDt,2]
				Endif

			Endif

			//pedidos de compra - AFG
			nPosDt := aScan(aFluxo[1],{|x| x[1] == dX})
			If nPosDt > 0

				aArrayFlx[Len(aArrayFlx)][2] := aFluxo[1][nPosDt][2]

				//Se Acumular Antecipados
				//a variavel nValAux pega o valor do titulo, abate os valores antecipados e depois totaliza no saldo do dia,saldo acumulado,etc
				If (Mv_par05 == 2)
					nValAux := aFluxo[1,nPosDt,2]
					nPos    := aScan( aTitAntec, {|x| x[1] <= aFluxo[1,nPosDt,1] .And. x[2] == 'PA' .And. x[3] > 0 } )

					AEval(aTitAntec,{|x|(nPos := aScan( aTitAntec, {|x| x[1] <= aFluxo[1,nPosDt,1] .And. x[2] == 'PA' .And. x[3] > 0 } ),;
											IIf(nPos > 0 .And. nValAux > 0,;
												IIf(aTitAntec[nPos,3] >= nValAux,;
													(aTitAntec[nPos,3] -= nValAux, nValAux := 0),;
													(nValAux -= aTitAntec[nPos,3], aTitAntec[nPos,3] := 0);
												),;
											);
										);
									};
					)

					nSaldoDia -= nValAux
					nSaldoAcm -= nValAux

				Else
					nSaldoDia -= aFluxo[1,nPosDt,2]
					nSaldoAcm -= aFluxo[1,nPosDt,2]
				Endif

			Endif

			aArrayFlx[Len(aArrayFlx)][4] := nSaldoDia
			aArrayFlx[Len(aArrayFlx)][5] := nSaldoAcm

			dX++

		Enddo

		For nY := 1 to Len( aArrayFlx )

			self:jItems := JsonObject():new()

			For nX := 1 To Len(self:aStruct)

				//Verifica se existe tratamento para valores do JSON
				If (nScan := aScan(self:aFieldsValue,  {|x| x[1] == self:aStruct[nX][5] } ) ) > 0
					xValue  := &(FatGetValueFields(self:aFieldsValue[nScan][1], "self:cAlias", self:aFieldsValue[nScan][2]))
				Else
					xValue  := (self:cAlias)->(FieldGet(FieldPos(self:aStruct[nX][5])))
				Endif

				//Verificação para tratamento de LGPD e campos tipo Data antes informar no JSON
				If lObfuscated .and. (nScan := aScan(aPDFields,  {|x| x[1] == self:aStruct[nX][5] } ) )  > 0 
					self:jItems[self:aStruct[nX][1]] := aPDFields[nScan][2]
				ElseIf UPPER(self:aStruct[nX][3]) == "DATE"
					self:jItems[self:aStruct[nX][1]] := Iif(ValType(xValue) == "C", totvs.framework.treports.date.stringToTimeStamp( xValue ), totvs.framework.treports.date.dateToTimeStamp( xValue ))
				Else
					self:jItems[self:aStruct[nX][1]] := xValue
				Endif

			Next nX

			self:processData(1) //Tratamento para commit localizado
			self:oData:appendData(self:jItems)

		Next nY

		(self:cAlias)->(dbSkip())

	Enddo

	(self:cAlias)->(DBCloseArea())
	
	aSize(aFluxo,      0)
	aSize(aHandle,     0)
	aSize(aPDFields,   0)
	aSize(aTitAntec,   0)
	aSize(aArrayFlx,   0)
	FwFreeArray(self:aFieldsValue)

return self:oData
 
/*{Protheus.doc} getSchema
	Retorna a estrutura dos campos
 	@return object: self:oSchema'
	@author Squad CRM/Faturamento
	@since 10/05/2023
	@version 12.1.2410
	@return Nil
*/
method getSchema() as object class projectexpensesSmartViewBusinessObject

	Local nX 			:= 0  as  numeric
	Local aCposFake 	:= {} as  array
	Local aParameters	:= {} as  array

    self:aFields := {'AF8_FILIAL','AF8_PROJET','AF8_DESCRI','A1_NOME','AF8_REVISA','TB_DATA','TB_VLRPREV','TB_VLRDESP','TB_DESPDIA','TB_DESPACUM'}
	
	aCposFake := {{"TB_DATA"	  , STR0004 , "date"  , STR0004 , "TB_DATA"},;
				  {"TB_VLRPREV"   , STR0005 , "number", STR0005 , "TB_VLRPREV"},;
				  {"TB_VLRDESP"   , STR0006 , "number", STR0006 , "TB_VLRDESP"},;
				  {"TB_DESPDIA"	  , STR0007 , "number", STR0007 , "TB_DESPDIA"},;
				  {"TB_DESPACUM"  , STR0008 , "number", STR0008 , "TB_DESPACUM"}}
				  
    self:aStruct := FatTrGetStruct(self:aFields,aCposFake)

	//Cria a estrutura dos campos Padroes
	For nX := 1 To Len(self:aStruct)
		self:addProperty(self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5])
	Next nX

	//Busca no SX1 os parâmetros que serão utilizados.
	aParameters := FtSVSetParam('PMR230', {'MV_PAR06','MV_PAR07'} )

	self:oSchema:addParameter("MV_FIL", STR0010 + " ?" ,"string",  .T.,,,,,, FTSVHelp(,,,.T.)) //Filial   

    For nX := 1 To Len(aParameters)
		self:oSchema:addParameter(aParameters[nX][1], aParameters[nX][2], aParameters[nX][3], aParameters[nX][4],,,,,, aParameters[nX][5])
	Next nX

	self:oSchema:addParameter("MV_DATAERP" , STR0009 ,"date", .F.,,,,,,STR0011) //Data base do Fluxo do projeto

	If __lLookUp
		self:setCustomURL("MV_PAR02", "api/framework/v1/genericLookupService/smartview/AF82", 2)
		self:setCustomURL("MV_PAR01", "api/framework/v1/genericLookupService/smartview/AF82", 2)
		self:setCustomURL("MV_PAR05", "api/framework/treports/integratedprovider/v1/options/PMR230/MV_PAR05", 1)
		self:setCustomURL("MV_FIL",   "api/framework/v1/genericLookupService/smartview/SM0", 2)
	Endif

	FwFreeArray(aCposFake)
	FwFreeArray(aParameters)

Return self:oSchema


/*{Protheus.doc} PMSSV005CreateSQL
	Retorna todas as querys montadas
	@author Squad CRM/Faturamento
	@since 23/06/2025
	@version 12.1.2410
	@return Nil
*/
Method PMSSV005CreateSQL() Class projectexpensesSmartViewBusinessObject 
    
	Local cFieldsQry := "" as character
    Local cQuery     := "" as character
    Local cNameTmp   := "" as character
    Local nParam     := 1  as numeric
    Local aFiliais	 := {} as array
    Local oQuery     := Nil as object
	Local oTempTableBranch := Nil as object
	
	// Função que verifica se há filiais informadas no parâmetro
	aFiliais := FatGetMVFiliais(MV_FIL)
    
	// Função que irá criar a tabela temporaria para fazer o Join de filiais
	oTempTableBranch := FatSVTableTempBranch(aFiliais, "AF8", "AF8_FILIAL")

    cNameTmp := oTempTableBranch:GetTableNameForQuery()
    
	cFieldsQry := 'AF8_FILIAL,AF8_PROJET,AF8_DESCRI,A1_NOME,AF8_REVISA'

	//Adiciona campos customizados (no array da estrutura, )
	FatInjCposPerson(@self:aFieldsValue, @self:aStruct, @cFieldsQry, self:getCustomFields(), .T., .T., .T.)

	cQuery := " SELECT ? "
	cQuery += " ? " //Ajuste de SELECT para objeto localizado
	cQuery += " FROM " + RetSqlName("AF8") + " AF8 "
	cQuery += " INNER JOIN ? TMPFIL"
	cQuery += " ON TMPFIL.TMP_FILIAL = AF8.AF8_FILIAL"	
	cQuery += " LEFT JOIN " + RetSqlName("SA1") + " SA1 ON ? "
	cQuery += " AND SA1.A1_COD = AF8.AF8_CLIENT "
	cQuery += " AND SA1.A1_LOJA = AF8.AF8_LOJA "
	cQuery += " AND SA1.D_E_L_E_T_ = ? "
	cQuery += " WHERE AF8.AF8_FILIAL = TMPFIL.TMP_FILIAL "
	
	If !Empty(MV_PAR01)	
		cQuery += " AND AF8.AF8_PROJET >= ? "
	Endif

	If !Empty(MV_PAR02)	
		cQuery += " AND AF8.AF8_PROJET <= ? "
	Endif

	cQuery += " ? " //Where que foi populado no objeto localizado
	cQuery += " AND AF8.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY AF8_FILIAL, AF8_PROJET"

	oQuery := FwExecStatement():New(ChangeQuery(cQuery))
	oQuery:SetUnsafe(nParam++, cFieldsQry)
	oQuery:SetUnsafe(nParam++ ,self:cSelectLoc ) //Ajuste de SELECT para objeto localizado
	oQuery:SetUnsafe(nParam++ , cNameTmp)
	oQuery:SetUnsafe(nParam++ , FwJoinFilial("SA1", "AF8"))
	oQuery:SetString(nParam++ , ' ')
	
	If !Empty(MV_PAR01)	
		oQuery:SetString(nParam++, MV_PAR01 )
	Endif

	If !Empty(MV_PAR02)
		oQuery:SetString(nParam++, MV_PAR02 )
	Endif

	oQuery:SetUnsafe(nParam++ ,self:cWhereLoc) //Adição de condições para objeto localizado no where
	oQuery:SetString(nParam++ , ' ')

	self:cAlias := oQuery:OpenAlias()

    oTempTableBranch:Delete()
    FWFreeObj(oTempTableBranch)
    
    oQuery:Destroy()
    FreeObj(oQuery)
	oQuery:= Nil
    
	aSize(aFiliais,0) 

Return
