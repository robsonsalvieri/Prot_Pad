#include "protheus.ch"
#include "fwmvcdef.ch"
#include "totvs.ch"
#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-rest.th"
#include "tlpp-core.th"
#include "fat.treports.fatxtrep.ch"

//-------------------------------------------------------------------
/*{Protheus.doc} FatTrGetStruct
Prepara a estrutura dos campos

@param aCpos array: Array com os campos do relatório

@return array: Array com a estrutura dos campos

@author FAT/CRM
@since 12/04/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Function FatTrGetStruct(aCpos As array, aCposFake as array) As Array

    Local aDeParaCpo    := {{"C", "string"}, {"D", "date"}, {"N", "number"}, {"L", "boolean"}} as array
    Local aCpoTmp       := {} as array
    Local cCampo        := "" as character
    Local cCpoQry       := "" as character
    Local cTipR         := "" as character
    Local cTipo         := "" as character
    Local nPos          := 0  as numeric
    Local nC            := 0  as numeric
    Local nPosFake      := 0  as numeric

    Default aCpos       := {}
    Default aCposFake   := {}
    
    For nC := 1 to Len(aCpos)
        If (nPosFake := Ascan(aCposFake, {|x| x[1] == aCpos[nC]})) > 0
             AAdd(aCpoTmp, {strTran(aCposFake[nPosFake][1], "_", ""), aCposFake[nPosFake][2],  aCposFake[nPosFake][3],  aCposFake[nPosFake][2], aCposFake[nPosFake][1]})
        Else
            cCpoQry := aCpos[nC]
            nPos    := AT(".", aCpos[nC]) + 1
            cCampo  := IIf( nPos > 0, Substr(cCpoQry, nPos), cCpoQry )
            cTipo   := GetSx3Cache(cCampo, "X3_TIPO")
            cTipR   := IIf( (nPos := aScan(aDeParaCpo, {|c| c[01] = cTipo})) > 0, aDeParaCpo[nPos, 02], "string" )
        
            AAdd(aCpoTmp, {strTran(cCampo, "_", ""), FWSX3Util():GetDescription(cCampo), cTipR, FWSX3Util():GetDescription(cCampo), cCampo})
        EndIf
    Next nC
 
Return (aCpoTmp)

//-------------------------------------------------------------------
/*{Protheus.doc} FatGetStructTab
Retorna campos da tabela informada tratando tipos de campos e tipo de retorno

@param cTabela character    : Nome da tabela que deseja retornar os campos
@param lQuery numeric       : Informar se o retorno será utilizado em uma query '.T.'(String), '.F.'(Array) 
@param lCpoMemo logical     : Se retorna campos do tipo memo
@param lCpoLogico logical   : Se retorna campos do tipo lógico
@param lSimplesArr logical  : Se retorna uma array simples aplenas com os nomes dos campos(Respeitado apenas se o lQuery = .F.)

@return: Sting caso lQuery = .T., Array caso lQuery = .F.

@author Leonardo Kichitaro
@since 24/04/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Function FatGetStructTab(cTabela as character, lQuery as logical, lCpoMemo as logical, lCpoLogico as logical, lSimplesArr as logical)

    Local aCpoStru      := {} as array
    Local aCpoMemo      := {} as array
    Local aCampos       := {} as array
    Local aDetCpo       := {} as array
    Local cCpoQry       := "" as character
    Local cCpoMemo      := "" as character
    Local nX            := 0  as numeric
    Local uRet          := Nil

    Default cTabela     := ""
    Default lQuery      := .T.
    Default lCpoMemo	:= .F.
    Default lCpoLogico	:= .F.
    Default lSimplesArr := .F.

    uRet := IIf( lQuery, "", {} )

    //Capturo o nome de todos os campos desprezando os campos virtuais
    aCampos := FWSX3Util():GetAllFields(cTabela, .F.)

    //capturo o tamanho, decimal e tipo
    For nX := 1 to Len(aCampos)
        aDetCpo := FwTamSx3(aCampos[nX])
        If (aDetCpo[3] <> "M" .And. aDetCpo[3] <> "L") .Or. (lCpoMemo .And. aDetCpo[3] == "M") .Or. (lCpoLogico .And. aDetCpo[3] == "L")
            If aDetCpo[3] == "M"
                aAdd(aCpoMemo, IIf( !lSimplesArr, {aCampos[nX],aDetCpo[3],aDetCpo[1],aDetCpo[2]}, aCampos[nX] ))
            Else
                aAdd(aCpoStru, IIf( !lSimplesArr, {aCampos[nX],aDetCpo[3],aDetCpo[1],aDetCpo[2]}, aCampos[nX] ))
            EndIf

            If aDetCpo[3] == "M"
                cCpoMemo += IIf(!Empty(cCpoMemo), ', ', '')
                cCpoMemo += AllTrim(aCampos[nX])
            Else
                cCpoQry += IIf(!Empty(cCpoMemo), ', ', '')
                cCpoQry += AllTrim(aCampos[nX])
            EndIf
        EndIf
    Next nX

    If lCpoMemo //Tratamento criado para inclusão dos campos Memo por ultimo no retorno
        If Len(aCpoMemo) > 0
            For nX := 1 To Len(aCpoMemo)
                aAdd(aCpoStru, aCpoMemo[nX])
            Next
        EndIf
        cCpoQry += IIf(!Empty(cCpoMemo), ', ' + cCpoMemo, '')
    EndIf

    cCpoQry := IIf(Empty(cCpoQry), '*', cCpoQry)
    uRet    := IIf(lQuery, cCpoQry, aClone(aCpoStru))

Return (uRet)

//------------------------------------------------------------------- 
/*/{Protheus.doc} FatSetValueMVPAR()
Seta os valores para os MV_PAR publicas.
@type  Static Function
@author CRM/FAT
@since 25/04/2023
@version 1.0
@return Nil
/*/
//------------------------------------------------------------------- 
Function FatSetValueMVPAR(oJsonMvPar as json, cPergunte as character)

    Local nY	    := 0  as numeric
	Local nX	    := 0  as numeric
	Local cTipoPar  := "" as character
    Local oJson     := oJsonMvPar:GetNames()      as json
    Local nJson	    := Len(oJsonMvPar:GetNames()) as numeric

	//Carrega os MV_PAR para a memória
	Pergunte(cPergunte,.F.)

	//Popula com os novos valores
	For nY := 1 To nJson

		cTipoPar := ValType(&(Upper(oJson[nY])))

        //Tratamento para parâmetros do tipo Range
        If Len(&("oJsonMvPar:"+oJson[nY])) > 1
            &( UPPER( oJson[nY] ) )  := ""
            For nX := 1 to Len( &("oJsonMvPar:"+oJson[nY]) )
                &( UPPER( oJson[nY] ) ) += IIf(oJsonMvPar[ oJson[nY] ][nX] != Nil, oJsonMvPar[ oJson[nY] ][nX]  + ";", "")
            Next nX
            &( UPPER( oJson[nY] ) ) := SubStr( &( UPPER( oJson[nY] ) ) , 1 , Len(&( UPPER( oJson[nY] ) )) - 1  )
		ElseIf cTipoPar == "D"
            If oJsonMvPar[oJson[nY]][1] == Nil
                oJsonMvPar[oJson[nY]][1] := "  /  /  "
            Endif
			&( UPPER( oJson[nY] ) ) := StoD( SubStr(StrTran(oJsonMvPar[ oJson[nY] ][1],"-",""),1,8) )
		ElseIf cTipoPar == "N"
			&( UPPER( oJson[nY] ) ) := IIf( ValType(oJsonMvPar[ oJson[nY] ][1]) == "C",	Val(oJsonMvPar[ oJson[nY] ][1]),  oJsonMvPar[ oJson[nY] ][1] )
		ElseIf cTipoPar == "C"
			&( UPPER( oJson[nY] ) ) := IIf( Len(oJsonMvPar[ oJson[nY] ]) > 0 , oJsonMvPar[ oJson[nY] ][1], '')
		EndIf
	Next nY

Return

//-------------------------------------------------------------------
/*{Protheus.doc} FatSVQryRange
Retorna a string para query preparada para filtro de dados seguênciais e/ou não sequênciais.

@param cFiltroDe  character  : Valor inícial do Filtro de/Ate
@param cFiltroAte character : Valor final do Filtro de/Ate
@param cFiltroIn  character  : Valor para o filtro IN (separado por ;)
@param cPrefix    character  : Prefixo caso a query original utilize (EX: PRF.CAMPO)
@param cCampo     character  : Campo da Tabela para montagem da query.

@return cQuery: Trecho da query com o tratramento necessário.

@author FAT/CRM
@since 29/08/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Function FatSVQryRange(cFiltroDe as character, cFiltroAte as character, cFiltroIn as character, cPrefix as character, cCampo as character ) as character

    Local cQuery := "" as character

    cPrefix := IIf( !Empty(cPrefix), cPrefix + ".", "" )

    If ( !Empty(cFiltroDe) .Or. !Empty(cFiltroAte)  ) .And. !Empty(cFiltroIn)
        cQuery  += "AND ( "+ cPrefix+cCampo + " IN "+ FormatIn( cFiltroIn, ";" ) + " OR " + cPrefix+cCampo + " BETWEEN '" + cFiltroDe + "' AND '" + cFiltroAte + "' ) "
    ElseIF  ( !Empty(cFiltroDe) .Or. !Empty(cFiltroAte) ) .And. Empty(cFiltroIn) 
        cQuery  += "AND ( "+ cPrefix+cCampo + " BETWEEN '" + cFiltroDe + "' AND '" + cFiltroAte + "' ) "
    ElseIf !Empty(cFiltroIn)
        cQuery  += "AND "+ cPrefix+cCampo + " IN "+ FormatIn( cFiltroIn, ";" ) +" "
    EndIF

Return cQuery

//-------------------------------------------------------------------
/*{Protheus.doc} FATSVGetMemo
Rotina que coloca em uma string o campo memo do banco de dados.

@return character: cRetMemo

@author FAT/CRM
@since 31/08/2023
@version 1.0
*/
//-------------------------------------------------------------------
Function FATSVGetMemo(cDado as character) as character

    Local cRetMemo  := "" as character  //Retorna conteúdo do campo MEMO

    cRetMemo := MSMM(cDado, 500)

Return cRetMemo

//-------------------------------------------------------------------
/*{Protheus.doc} FatGetfieldsLGPD
Retorna campos sensiveis e conteudo ofuscado para tratamento de LGPD.

@param aCamposObj   array   : Array com campos fixos do objeto de negocio
@param aCamposAdic  array   : Array com campos adicionais para verificação de LGPD

@return: aCamposLGPD array  : Array com campos sensiveis

@author Leonardo Kichitaro
@since 07/09/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Function FatGetfieldsLGPD(aCamposObj as array, aCamposAdic as array) as array

    Local nX            := 0    as numeric
    Local nTamCampo     := 0    as numeric
    Local aCamposLGPD   := {}   as array
    Local aCamposAll    := {}   as array
    Local aPDFields     := {}   as array
    Local aEstrutura    := {}   as array
    Local cTipo         := ''   as character
    Local lObfuscated   := .F.  as logical

	//Junta os campos fixos e campos adicionais para verificar se existem campos sensiveis
    aCamposAll := aClone(aCamposObj)
    If Len(aCamposAdic) > 0
        aEval(aCamposAdic , {|x|  aadd(aCamposAll, x[1]) } )
    EndIf

    //Verifica se precisa fazer o tratamento para LGPD
    aPDFields	:= FwProtectedDataUtil():UsrAccessPDField(__cUserID, aCamposAll)
    lObfuscated	:= Len(aPDFields) != Len(aCamposAll)

    If lObfuscated
        For nX := 1 To Len(aCamposAll)
            If aScan(aPDFields, aCamposAll[nX]) == 0
                aEstrutura := FWSX3Util():GetFieldStruct(aCamposAll[nX])
                nTamCampo := aEstrutura[3]
                cTipo     := aEstrutura[2]
                If cTipo == 'D'
                    aAdd(aCamposLGPD, {aCamposAll[nX], totvs.framework.treports.date.dateToTimeStamp(CTOD('01/01/1950'))})
                ElseIf cTipo == 'N'
                    aAdd(aCamposLGPD, {aCamposAll[nX], Val( Repl('9',nTamCampo) )})
                Else
                    aAdd(aCamposLGPD, {aCamposAll[nX], FwProtectedDataUtil():ValueAsteriskToAnonymize(Repl("X", nTamCampo))})
                EndIf
            EndIf
        Next
    EndIf

	aSize(aCamposAll, 0)
	aSize(aPDFields,  0)
    aSize(aEstrutura, 0)

Return aCamposLGPD

//-------------------------------------------------------------------
/*{Protheus.doc} FatGetValueFields
Retorna string com conteúdo a ser gravado no campo informado.

@param cField   character   : Campo Alias para apontamento de retorno de campos da tabela posicionada
@param cAlias   character   : Alias para apontamento de retorno de campos da tabela posicionada
@param aFieldsPut   array   : Array com campos com conteúdos que serão gravados
                                [1] - Nome do campo
                                [2] - Alias para campos que não fazem parte da Query principal(Caso não dependa de campo de tabela, informar vazio("").)
                                [3] - Conteúdo a ser gravado no campo informado no primeiro parâmetro

@return: cValueField character  : String de retorno contendo instruções para ser macro executado

@observacoes: Caso a posição 2 da array 'aFieldsPut' seja informado, é necessario informar
            o nome do campo na posição 3 e que o mesmo exista na tabela informada.

@author Leonardo Kichitaro
@since 07/09/2023
@version 1.0
*/
//-------------------------------------------------------------------
Function FatGetValueFields(cField as character, cAlias as character, aFieldsPut as array) as character

    Local cValueField := "" as character

    If ValType(aFieldsPut) == "A" .And. Len(aFieldsPut) > 0
        //Busca campo informado na array com tratamentos de retorno
        cValueField := IIf(!Empty(aFieldsPut[2]), aFieldsPut[2] + "->" + aFieldsPut[1], aFieldsPut[3])
    Else
        //Campo sem tratamento especifico, retorna o campos pesquisado ponteirado com a tabela informada no cAlias
        cValueField := "(" + cAlias + ")->" + cField
    EndIf

Return cValueField

//-------------------------------------------------------------------
/*{Protheus.doc} FatSeekTable
Realiza pesquisa na tabela informada e retorna o conteúdo do campo informado

@param cAliasSeek   character: Alias da tabela que será pesquisada
@param nIndexSeek   numeric  : Indice que será utilizado para pesquisa
@param cKeySeek     character: Chave de pesquisa para pesquisa
@param cFieldReturn character: Nome do campo para retorno do conteúdo da tabela pesquisada

@return: xValueField: Conteúdo do campo informado para retorno

@author Leonardo Kichitaro
@since 07/09/2023
@version 1.0
*/
//-------------------------------------------------------------------
Function FatSeekTable(cAliasSeek as character, nIndexSeek as numeric, cKeySeek as character, cFieldReturn as character, lOrder as logical)

    Local xValueField := Nil
    Local aAreaAlias := (cAliasSeek)->(FwGetArea()) as array

    If lOrder
        (cAliasSeek)->(dbSetOrder(nIndexSeek))      //Seta o indice informado
    EndIf

    (cAliasSeek)->(MsSeek(cKeySeek))                //Pesquisa registro na tabela informada
    xValueField := (cAliasSeek)->&(cFieldReturn)    //Recebe o valor do campo informado para retorno

	FwRestArea(aAreaAlias)

    aSize(aAreaAlias, 0)

Return xValueField

//-------------------------------------------------------------------
/*{Protheus.doc} FatInjCposPerson
Inseri no array de dados os campos personalizados caso existam.

@param aCposDados   array : Array com os campos que serão utilizados no relatório
@param aStruct      array : Array com as estruturas dos campos do relatório.
@param cCposSelect  character : String com os campos do SELECT da query príncipal.
@param acCposPerson array : Array com os campos personalizados.

@param aTabNQry     array : Array com tabelas que os campos serão desconsideradas na inclusão do cCposSelect.

@return: Nill

@author CRM/FAT
@since 07/09/2023
@version 1.0
*/
//-------------------------------------------------------------------
Function FatInjCposPerson(aCposDados as array, aStruct as array, cCposSelect as character, acCposPerson as array, lAtuQry as logical, lAtuADados as logical, lAtuAStruct as logical, cPrefixoTabNQry as character)

    Local nX                := 0   as numeric
    Local aCposSelect       := {}  as array
    Local cField            := "" as character
    Local cFieAl            := "" as character

    Default lAtuQry         := .T.
    Default lAtuADados      := .T.
    Default lAtuAStruct     := .T.
    Default cPrefixoTabNQry := ''

    If Len(acCposPerson)

        For nX := 1 to Len( acCposPerson )

            cField := acCposPerson[nX][1]
            cFieAl := IIf( Len(acCposPerson[nX]) == 5, acCposPerson[nX][5] + "." + cField, cField )

            aCposSelect := StrTokArr(cCposSelect, ",")

            //Valida se o campo não existe no aCposDados
            IIf( lAtuADados .And. ( aScan(aCposDados, {|x| x[01] = cField})) == 0, aadd(aCposDados , { cField ,{}} ), .T.) 

            //Valida se o campo não existe no aStruct
            IIf( lAtuAStruct .And. ( aScan(aStruct, {|x| x[01] = cField})) == 0, aadd(aStruct, {cField, acCposPerson[nX][4],  acCposPerson[nX][3],  acCposPerson[nX][4], cField}), .T.) 

            If (aScan(aCposSelect, {|x| AllTrim(x) == cField}) == 0) .And. (aScan(aCposSelect, {|x| AllTrim(x) == cFieAl}) == 0) .And. lAtuQry
                cCposSelect += IIf( !(SubStr(AllTrim(Upper(cField)), 1, At('_',cField)) $ cPrefixoTabNQry), ', ' + cField, '' )
            EndIf

        Next nX

        aSize(aCposSelect, 0)

    EndIf

Return Nil

//-------------------------------------------------------------------
/*{Protheus.doc} FatGetCboX1
Função que retorno as strings do combo do SX1

@return array: Array com as opções do combo.

@author FAT/CRM
@since 14/11/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Function FatGetCboX1( cPergunte as character, nOrder as numeric )

    Local aReturn   := {}                    as array
    Local aPergunte := {}                    as array
    Local nX 	    := 0			         as numeric
    Local cDescr    := ''                    as character
    Local oObj      := FWSX1Util():New()     as object    

    If oObj:ExistPergunte( cPergunte )
        oObj:AddGroup(Alltrim(cPergunte))
        oObj:SearchGroup()
        aPergunte := oObj:GetGroup(Alltrim(cPergunte))

        For nX := 1 to 5
            cDescr := Alltrim( &('aPergunte[2][nOrder]:CX1_DEF0' + Alltrim(Str(nX))) )
            If !Empty(cDescr)
                aadd(aReturn, cDescr)
            EndIF
        Next nX
    EndIF
    
    oObj:Destroy()
    oObj := nil
    FreeObj(oObj)

    aSize(aPergunte,0)
    
Return aReturn

//-------------------------------------------------------------------
/*{Protheus.doc} FatGetStrCpos
Função para pegar os nomes dos campos do dicionário concatenando para
demonstrar nos combos do SmartView.

@return array: Array com os campos.

@author FAT/CRM
@since 15/08/2023
@version 1.0
*/
//-------------------------------------------------------------------
Function FatGetStrCpos(aCpos as array)

	Local cDescCpos := '' as character
	Local nX 	    := 1  as numeric

	For nX := 1 to Len( aCpos )
		cDescCpos += Alltrim( FWX3Titulo(aCpos[nX]) ) + IIf(nX < Len(aCpos), ' + ', '')
	Next nX

Return cDescCpos

//-------------------------------------------------------------------
/*{Protheus.doc} FtSVSetParam
Função para setar os parâmetros no schema do objeto de negócio.
Quando for necessário a exclusão de algum parâmetro da SX1.

@param cPergunte  character : Nome do pergunte do SX1
@param aParaExc   array : Array com os parametros a serem excluídos.
@param aSeqSx1    array : Array com o sequencial dos parametros a serem excluídos
@param aParamOrd  array : Array com a ordem redefinida dos parâmetros, o valor deve ser de acordo com campo X1_ORDEM (caso queira excluir algum parâmetro, basta omitir)
@param aParamNov  array : Array com novos parâmetros, que não estão na SX1

@return aReturn array: Array com os parâmetros válidos adicionados.

@author FAT/CRM
@since 15/08/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Function FtSVSetParam(cPergunte as character, aParaExc as array, lCheckOrd as logical, aSeqSx1 as array, aParamOrd as array, aParamNov as array) as array

    Local oObj          := FWSX1Util():New() as object
    Local nX            := 0                 as numeric
    Local nScan         := 0                 as numeric
    Local nScanOrd      := 0                 as numeric
    Local nScanNov      := 0                 as numeric
    Local cOrdPar       := ''                as character
    Local cPergunt      := ''                as character
    Local cPergOrd      := ''                as character
    Local aPergunte     := {}                as array
    Local aMvsPerg      := {}                as array
    Local aReturn       := {}                as array

    Default lCheckOrd   := .F.
    Default aParaExc    := {}
    Default aSeqSx1     := {}
    Default aParamOrd   := {}
    Default aParamNov   := {}

    If oObj:ExistPergunte( cPergunte )
        oObj:AddGroup(Alltrim(cPergunte))
        oObj:SearchGroup()
        aPergunte := oObj:GetGroup(Alltrim(cPergunte))

        If Empty(aParamOrd)

            For nX := 1 To Len(aPergunte[2])

                //Se não encontrar no array para exclusão adiciona
                cOrdPar  := aPergunte[2][nX]:CX1_ORDEM
                nScan    := Ascan( aParaExc, Upper(Alltrim( aPergunte[2][nX]:CX1_VAR01 ) ) )
                nScanOrd := Ascan( aSeqSx1 , Upper(Alltrim( cOrdPar ) ) )

                If nScan == 0 .And. nScanOrd == 0

                    cPergOrd := 'MV_PAR'+ AllTrim(cOrdPar)
                    cPergunt := IIf(!Empty(Upper(Alltrim(aPergunte[2][nX]:CX1_VAR01))), Upper(Alltrim(aPergunte[2][nX]:CX1_VAR01)), 'MV_PAR'+ cOrdPar)
                    cPergunt := IIf(lCheckOrd .And. cPergunt <> cPergOrd, cPergOrd, cPergunt)

                    aAdd( aReturn , { cPergunt,;
                            Alltrim( aPergunte[2][nX]:CX1_PERGUNT ),;
                            IIf( aPergunte[2][nX]:CX1_TIPO == 'C', 'string', IIf(aPergunte[2][nX]:CX1_TIPO == 'N' , 'number' , 'date')),;
                            IIf( aPergunte[2][nX]:CX1_GSC == 'R' , .T. , .F. ),;
                            FTSVHelp(cPergunte, cOrdPar);
                        })

                EndIf

            Next nX

        Else

            // Pega os MV's do pergunte
            For nX := 1 To Len(aPergunte[2])
                aAdd(aMvsPerg, {;
                    'MV_PAR' + AllTrim(aPergunte[2][nX]:CX1_ORDEM),; // Nome do parâmetro
                    AllTrim(aPergunte[2][nX]:CX1_PERGUNT),;          // Label do parâmetro
                    Upper(AllTrim(aPergunte[2][nX]:CX1_TIPO)),;      // Tipo do parâmetro
                    Upper(AllTrim(aPergunte[2][nX]:CX1_GSC));        // Tipo da pergunta (Get, Combo, etc)
                })
            Next nX

            For nX := 1 To Len(aParamOrd)

                cOrdPar  := aParamOrd[nX]
                nScan    := aScan(aMvsPerg,  {|x| Upper(x[01]) == 'MV_PAR' + cOrdPar})
                nScanNov := Ascan(aParamNov, {|x| Upper(x[01]) == cOrdPar})

                If nScan > 0
                    aAdd( aReturn, { aMvsPerg[nScan][1],;
                        Alltrim( aMvsPerg[nScan][2]),;
                        IIf( aMvsPerg[nScan][3] == 'C', 'string', IIf(aMvsPerg[nScan][3] == 'N' , 'number' , 'date')),;
                        IIf( aMvsPerg[nScan][4] == 'R', .T. , .F. ),;
                        FTSVHelp(cPergunte, cOrdPar);
                    })

                ElseIf nScanNov > 0
                    aAdd( aReturn, { aParamNov[nScanNov][1],;
                        Alltrim(aParamNov[nScanNov][2]),;
                        aParamNov[nScanNov][3],;
                        aParamNov[nScanNov][4],;
                        aParamNov[nScanNov][5];
                    })

                EndIf

            Next nX

        EndIf

    EndIf

    oObj:Destroy()
    oObj := Nil
    FreeObj(oObj)

    aSize(aPergunte, 0)
    aSize(aParaExc,  0)
    aSize(aSeqSx1,   0)
    aSize(aMvsPerg,  0)
    aSize(aParamOrd, 0)
    aSize(aParamNov, 0)

Return aReturn

//-------------------------------------------------------------------
/*{Protheus.doc} FatGetSX5
Função que retorno as strings do combo do SX5

@param cCodTabSX5 character : Código da tabela para retorno dos registros da SX5
@param aNotChave  array     : Array com código de chave que serão desconsiderados

@return array: Array com as opções do combo.

@author FAT/CRM
@since 04/12/2023
@version 1.0
*/
//-------------------------------------------------------------------
Function FatGetX5(cCodTabSX5 as character, aNotChave as array) as array

    Local nX        := 0  as numeric
    Local aReturn   := {} as array
    Local aDadosSx5 := {} as array

    Default aNotChave := {}

    If !Empty(cCodTabSX5)
        aDadosSx5 := FWGetSX5(cCodTabSX5)

		For nX := 1 To Len(aDadosSx5)
            If aScan(aNotChave, {|x| AllTrim(x[1]) == AllTrim(aDadosSX5[nX][3])}) == 0
			    aAdd(aReturn, AllTrim(aDadosSX5[nX][3]) + ' - ' + AllTrim(aDadosSX5[nX][4]))
            EndIf
		Next
    EndIf

    aSize(aDadosSx5,0)

Return aReturn

//-------------------------------------------------------------------
/*{Protheus.doc} FATSVProcessData
Função para tratar o conteudo antes de passar para o ProcessData

@param aFields  array       : Relacao de campos
@param lLGPD    logical     : Tratamento LGPD
@param aCpoLGPD array       : Campos Protegidos (LGPD)
@param cAlias   character   : Alias da tabela

@return character: Conteudo para gravar

@author FAT/CRM
@since 11/10/2024
@version 1.0
*/
//-------------------------------------------------------------------
Function FATSVProcessData(aFields as array, lLGPD as logical, aCpoLGPD as array, cAlias as character, aFieldsValue as array)

    Local xResult   := Nil
    Local nScan     := 0 as numeric

    Default aCpoLGPD     := {}
    Default aFields      := {}
    Default aFieldsValue := {}
    Default cAlias       := ""
    Default lLGPD        := .F.

    If (nScan := aScan(aFieldsValue,  {|x| x[1] == aFields[5] } )) > 0

        xResult := &(FatGetValueFields(aFieldsValue[nScan][1], "cAlias", aFieldsValue[nScan][2]))
        
    Else

        If !Empty(aFields)

            If  lLGPD .And. (nScan := aScan(aCpoLGPD, {|x| x[1] == aFields[5]})) > 0

                xResult := aCpoLGPD[nScan][2]

            ElseIf AllTrim(aFields[3]) == "date"

                xResult := IIf( ValType((cAlias)->&(aFields[5])) == "D",;
                    totvs.framework.treports.date.dateToTimeStamp((cAlias)->&(aFields[5])),;
                    totvs.framework.treports.date.stringToTimeStamp((cAlias)->&(aFields[5])) )
            
            Else
                If AllTrim(aFields[3]) == "string"
                    xResult := RTrim((cAlias)->&(aFields[5]))
                Else
                    xResult := (cAlias)->&(aFields[5])
                EndIf
            EndIf 

        EndIf

    EndIf

Return xResult

//-------------------------------------------------------------------
/*{Protheus.doc} FatGetMVFiliais
Função que retorna o array com o código das filiais

@param xBranches : Valor do parâmetro de filiais

@return character: Retorna uma String com a filial da tabela com tratamento de tabelas compartilhadas

@author FAT/CRM
@since 07/10/2024
@version 1.0
*/
//-------------------------------------------------------------------
Function FatGetMVFiliais(xBranches as variant)

    Local aBranches := {} as array

    If ValType(xBranches) == "C"
        If Empty(xBranches)
            aAdd(aBranches, FwCodFil())
        Else
            aBranches := StrTokArr(xBranches, ";")
        EndIf
    ElseIf ValType(xBranches) == "A"
        If Empty(xBranches)
            aAdd(aBranches, FwCodFil())
        Else
            aBranches := xBranches
        EndIf
    EndIf

Return aBranches

//-------------------------------------------------------------------
/*{Protheus.doc} FatSVFilial
Função que retorna uma string com código da filial

@param cTable  character  : Nome da tabela no parâmetro da query
@param cField  character  : Nome do campo que irá receber o parâmetro de filiais na query
@param cBranch character  : Filial selecionada no parâmetro de filiais do Smart View

@return character: Retorna uma String com a filial da tabela com tratamento de tabelas compartilhadas

@author FAT/CRM
@since 07/10/2024
@version 1.0
*/
//-------------------------------------------------------------------
Function FatSVFilial(cTable as character, cField as character, cBranch as character) as character

    Local cTabShared := "" as character

    // Adiciona a filial no array de retorno de acordo com o tamanho do campo na tabela informada
    cTabShared := FWxFilial(cTable, PadR(cBranch, FwTamSx3(cField)[1], " "))

Return cTabShared

//-------------------------------------------------------------------
/*{Protheus.doc} FTSVHelp
Função que retorna uma string com a descrição do Help do Parâmetro

@param cPergCmpo character  : Recebe o nome do pergunte ou do campo para consulta do Help
@param cOrdemMV  character  : Recebe a ordem do parâmetro de acordo com a SX1. Necessário somente quando consultar Help de parâmetro, para campo deve vir vazia
@param lOrdHelp  logical    : Identifica se é um parâmetro Ordem do relatório. Nesse caso irá usar um Help padrão definido na função
@param lFilHelp  logical    : Identifica se é um parâmetro Filial do relatório. Nesse caso irá usar um Help padrão definido na função

@return cReturn character: Retorna uma String com o Help do Parâmetro informado, de acordo com a XB4

@author FAT/CRM
@since 24/10/2024
@version 1.0
*/
//-------------------------------------------------------------------
Function FTSVHelp(cPergCmpo as character, cOrdemMV as character, lOrdHelp as logical, lFilHelp as logical) as character

    Local nX        := 0  as numeric
    Local nHelp     := 0  as numeric
    Local cReturn   := "" as character
    Local cHelp     := "" as character

    Default lOrdHelp := .F.
    Default lFilHelp := .F.

    If lOrdHelp
        Return cReturn := STR0001
    ElseIf lFilHelp
        Return cReturn := STR0002
    EndIf

    //Se a variavel cOrdemMV estiver preenchida, indica que irá consulta o Help do Parâmetro, 
    //senão consulta o Help do Campo informado no cPergCmpo
    If !Empty(cOrdemMV)
        cHelp := cValToChar(GetHlpSoluc("." + cPergCmpo + cOrdemMV + ".")[1])
    Else
        cHelp := GetHlpSoluc(cPergCmpo)[1]
    EndIf

    //Verifica quantos caracteres tem no Help
    nHelp := Len(cHelp)

    //Cria a string de retorno passando por todas as linhas
    //Essa tratativa é necessária pois está lendo de um campo MEMO
    For nX := 1 To MLCount(cHelp)
        cReturn += AllTrim(MemoLine(cHelp, nHelp, nX)) + " "
    Next nX

Return cReturn

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} FatSVTableTempBranch
Cria tabela temporária e a popula para realizar join para filtrar registros de acordo com a seleção de filiais

@param aBranches array        : Recebe o array de filias que foram selecionadas no Smart View
@param cTable    character    : Recebe o nome da tabela que será feito o Join
@param cFieldBranch character : Recebe o nome do campo da tabela que será feito o Join

@return oTempTableBranch object : Retorna um Objeto da tabela temporária criada e populada

@author  FAT/CRM
@since	 10/01/2025
@version 1.0
/*/
//---------------------------------------------------------------------------------------------
Function FatSVTableTempBranch(aBranches as array, cTable as character, cFieldBranch as character) as object

	Local cAlias           := ""                        as Character
	Local aFields          := {}                        as Array
	Local nBranches        := 0                         as Numeric
	Local oTempTableBranch := FwTemporaryTable():New()  as Object

	aAdd(aFields, {"TMP_FILIAL", GetSX3Cache(cFieldBranch, "X3_TIPO"), GetSX3Cache(cFieldBranch, "X3_TAMANHO"), GetSX3Cache(cFieldBranch, "X3_DECIMAL")})
    aAdd(aFields, {"TMP_FILORI", GetSX3Cache(cFieldBranch, "X3_TIPO"), GetSX3Cache(cFieldBranch, "X3_TAMANHO"), GetSX3Cache(cFieldBranch, "X3_DECIMAL")})

	oTempTableBranch:SetFields(aFields)
	oTempTableBranch:AddIndex("01", {"TMP_FILIAL","TMP_FILORI"})

	oTempTableBranch:Create()

	cAlias := oTempTableBranch:GetAlias()
	DbSelectArea(cAlias)

	For nBranches := 1 to Len(aBranches)
		RecLock(cAlias, .T.)
		(cAlias)->TMP_FILIAL := FWxFilial(cTable, PadR(aBranches[nBranches], FwTamSx3(cFieldBranch)[1], " "))
        (cAlias)->TMP_FILORI := aBranches[nBranches]
		(cAlias)->(MsUnLock())
	Next

	FwFreeArray(aFields)

Return oTempTableBranch

//---------------------------------------------------------------------------------------------
/*/{Protheus.doc} SVTkEntidade
Irá carregar o valor do campo de acordo com a entidade (tabela) e tipo (define o campo) enviado nos parametros

@param cEntidade character : Recebe o nome da tabela que será feito o Join
@param cChave    character : Recebe a chave de pesquisa, utilizada no MsSeek
@param nTipo     numeric   : Recebe o numero com o tipo do valor que deverá retornar
@param nOrdEnt   character : Recebe a ordem do índice da tabela
@param cFilOr    character : Recebe a da filial que deverá fazer s busca da chave

@return cRet     character : Retorna um o valor do campo de acordo com o numero do tipo,
conforme numero do tipo abaixo:
01 - Nome
02 - Endereco
03 - Municipio
04 - Estado
05 - CEP
06 - Telefone
07 - E
08 - Homepage
09 - DDD
10 - BAIRRO
11 - Fantasia
12 - Loja

@author  FAT/CRM
@since	 20/02/2025
@version 1.0
/*/
//---------------------------------------------------------------------------------------------
Function SVTkEntidade(cEntidade, cChave, nTipo, nOrdEnt, cFilOr,lLGPDField) 

    Local cCampo	:= "" as character
    Local cRet		:= "" as character
    Local aTbCpos	:= {{"SU2", {"U2_CONCOR",  "U2_END",     "U2_MUN",     "U2_EST",     "U2_CEP",     "U2_TEL",     "",          "",          "U2_DDD",  "U2_BAIRRO",  "",           ""}},;			//Concorrentes
                        {"AC4", {"AC4_NOME",   "AC4_END",    "AC4_MUN",    "AC4_EST",    "AC4_CEP",    "AC4_TEL",    "",          "AC4_HPAGE", "AC4_DDD", "AC4_BAIRRO", "AC4_NREDUZ", ""}},;			//Parceiros
                        {"ACH", {"ACH_RAZAO",  "ACH_END",    "ACH_CIDADE", "ACH_EST",    "ACH_CEP",    "ACH_TEL",    "ACH_EMAIL", "ACH_URL",   "ACH_DDD", "ACH_BAIRRO", "ACH_NFANT",  "ACH_LOJA"}},;	//Suspect
                        {"SA1", {"A1_NOME",    "A1_END",     "A1_MUN",     "A1_EST",     "A1_CEP",     "A1_TEL",     "A1_EMAIL",  "A1_HPAGE",  "A1_DDD",  "A1_BAIRRO",  "A1_NREDUZ",  "A1_LOJA"}},;		//Cliente
                        {"SA2", {"A2_NOME",    "A2_END",     "A2_MUN",     "A2_EST",     "A2_CEP",     "A2_TEL",     "A2_EMAIL",  "A2_HPAGE",  "A2_DDD",  "A2_BAIRRO",  "A2_NREDUZ",  "A2_LOJA"}},;		//Fornecedor
                        {"SA3", {"A3_NOME",    "A3_END",     "A3_MUN",     "A3_EST",     "A3_CEP",     "A3_TEL",     "A3_EMAIL",  "A3_HPAGE",  "",        "A3_BAIRRO",  "A3_NREDUZ",  ""}},;			//Vendedor
                        {"SA4", {"A4_NOME",    "A4_END",     "A4_MUN",     "A4_EST",     "A4_CEP",     "A4_TEL",     "A4_EMAIL",  "A4_HPAGE",  "A4_DDD",  "A4_BAIRRO",  "A4_NREDUZ",  ""}},;			//Transportadora
                        {"SUS", {"US_NOME",    "US_END",     "US_MUN",     "US_EST",     "US_CEP",     "US_TEL",     "US_EMAIL",  "US_URL",    "US_DDD",  "US_BAIRRO",  "US_NREDUZ",  "US_LOJA"}},;		//Prospect
                        {"JA2", {"JA2_NOME",   "JA2_END",    "JA2_CIDADE", "JA2_EST",    "JA2_CEP",    "JA2_TEL",    "",          "",          "",        "JA2_BAIRRO", "",           ""}},;			//Alunos
                        {"BA1", {"BA1_NOMUSR", "BA1_ENDERE", "BA1_MUNICI", "BA1_ESTADO", "BA1_CEPUSR", "BA1_TELEFO", "",          "",          "BA1_DDD", "BA1_BAIRRO", "BA1_NREDUZ", ""}},;			//Familia/Usuario
                        {"RD0", {"RD0_NOME",   "",           "",           "",           "",           "",           "",          "",          "",        "",           "",           ""}},;
                        {"BAU", {"BAU_NOME",   "BAU_END",    "BAU_MUN",    "BAU_EST",    "BAU_CEP",    "BAU_TEL",    "BAU_EMAIL", "BAU_WEB",   "",        "BAU_BAIRRO", "BAU_NREDUZ", ""}}}				//Rede de Atendimento (Prestador PLS)
    Local nPosTb	:= aScan(aTbCpos,{|x| x[01] == cEntidade})

    Default nOrdEnt	:= 1
    Default lLGPDField	:= .T.

    If nPosTb > 0

        cCampo := aTbCpos[nPosTb, 2, nTipo]

        If (cEntidade == "BA1" .AND. nTipo == 1)
            nOrdEnt	:= If(Len(Alltrim(cChave)) > 17, 1, GetNewPar("MV_PLORDTM", 2))
        EndIf

        If (cEntidade == "BAU" .AND. nTipo == 1)
			nOrdEnt	:= 1
		EndIf

        If !Empty(cCampo)
            (cEntidade)->(DbSetOrder(nOrdEnt))
            (cEntidade)->(MsSeek(FWxFilial(cEntidade, cFilOr) + cChave))		
            
            If lLGPDField
                cRet := FTPDObfuscate(AllTrim((cEntidade)->&(cCampo)),cCampo,, .T.)
            Else 
                cRet := AllTrim((cEntidade)->&(cCampo))
            Endif        
        EndIf

    EndIf

Return cRet
