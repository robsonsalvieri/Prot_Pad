#include "protheus.ch"
#include "fwlibversion.ch"
#include "totvs.ch"
#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-rest.th"
#include "tlpp-core.th"
#include "backoffice.sv.fat.salesstatisticsbypaymentterm.ch"

Static __lLookUp := FwLibVersion() >= "20231121"

namespace totvs.protheus.backoffice.sv.fat.salesstatisticsbypaymentterm.treportsintegratedprovider
using namespace totvs.framework.treports.integratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAFAT", tables="SE1,SD1,SD2,SF2", name="Estatística de Venda por Prazo de Pagamento", country="ALL")

//-------------------------------------------------------------------
/*/{Protheus.doc} salesstatisticsbypaymenttermSmartViewBusinessObject
Classe para criação do Objeto de Negócio para Relacao de Estatística
de Venda por Prazo de Pagamento

@author FAT/CRM
@since 24/07/2023
@version 1.0
*/
//-------------------------------------------------------------------
Class salesstatisticsbypaymenttermSmartViewBusinessObject From IntegratedProvider

    public method new()				as object
    public method getData()			as object
    public method getSchema()		as object

	public method FatSV010CreateSQL()

    protected data aFields			as array
    protected data aStruct			as array
    protected data ojItems			as json
	protected data cAliasTmpSE1Loc	as character
	protected data cAliasTmpSD2Loc	as character
	protected data cAlSubTmpSE1Loc	as character
	protected data cSelectSD2Loc	as character
	protected data cCpoRemito		as character
	protected data lRemito			as logical
	protected data nDevolIPILoc		as numeric

EndClass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe

@return object: self

@author FAT/CRM
@since 24/07/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method new() Class salesstatisticsbypaymenttermSmartViewBusinessObject

	_Super:new()
    self:appendArea(STR0001) 	 //Faturamento
    self:setDisplayName(STR0002) //Estatística de Venda por Prazo de Pagamento
    self:setDescription(STR0003) //Relação de Estatística de Venda por Prazo de Pagamento
	self:setIsLookUp(.T.)		 //Habilita o recurso de consulta padrao e ComboBox

	self:aFields := {}

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio

@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do TReports

@return object: self:oData

@author FAT/CRM
@since 24/07/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getData(nPage as numeric, oFilter as object) as object Class salesstatisticsbypaymenttermSmartViewBusinessObject

	Local aVenc			:= {} as array
	Local aFaturas  	:= {} as array

	Local cNotFat   	:= "" as character
	Local cPrazo1		:= "" as character
	Local cPrazo2		:= "" as character
	Local cPrazo3		:= "" as character
	Local cPrazo4		:= "" as character
	Local cPrazo5		:= "" as character
	Local cPrazo6		:= "" as character
	Local cDatAnt		:= "" as character
	Local cALiasQrySE1 	:= "" as character
	Local cALiasQrySD2 	:= "" as character
	Local cAliasSubSE1 	:= "" as character
	Local cRegAnt		:= "" as character
	Local cChave		:= "" as character
	Local cFilReg		:= "" as character
	Local cDatAtu		:= "" as character

	Local nX			:= 0 as numeric
	Local nAd1  		:= 0 as numeric
	Local nAd2   		:= 0 as numeric
	Local nAd3   		:= 0 as numeric
	Local nAd4   		:= 0 as numeric
	Local nAd5   		:= 0 as numeric
	Local nAd6   		:= 0 as numeric
	Local nAg1			:= 0 as numeric
	Local nAg2 			:= 0 as numeric
	Local nAg3 			:= 0 as numeric
	Local nAg4 			:= 0 as numeric
	Local nAg5 			:= 0 as numeric
	Local nAg6 			:= 0 as numeric
	Local nSoma			:= 0 as numeric
	Local nDecs			:= 0 as numeric
	Local nDevol		:= 0 as numeric
	Local nDevolIPI		:= 0 as numeric
	Local nParam		:= 1 as numeric
	Local nTotReg		:= 0 as numeric

	Private oQuerySE1 	:= Nil as object
	Private oQuerySD2 	:= Nil as object
	Private oSubQrSE1	:= Nil as object

	Private nNumFils	:= 0  as numeric
	Private NORDER		:= 0  as numeric
	Private MV_MOEDA	:= 0  as numeric
	Private MV_FIL		:= "" as character
	Private cFieldsSE1  := "" as character
	Private cFieldsSD2	:= "" as character
	Private cFldsSubSE1 := "" as character
	Private aFiliais	:= {} as array

	//Metodo para retorno do json dos parametros
    FatSetValueMVPAR(oFilter:GetParameters(), "MTR560")

	NORDER:= IIf(NORDER == 0, 1, NORDER)

    //Tratamento para permitir apenas o número de moedas utilizadas
    MV_MOEDA := IIf(MV_MOEDA <= 0 .Or. MV_MOEDA > ContaMoeda(), 1, MV_MOEDA)

	nDecs := MsDecimais(MV_MOEDA)

	//Prazos a serem impressos no cabecalho de acordo com parametros inform,ado pelo usuario
	cPrazo1 := IIf(MV_PAR03 = 0, STR0004, Alltrim(Str(MV_PAR03,3))) //A Vista
	cPrazo2 := Alltrim(Str(MV_PAR04,3))
	cPrazo3 := Alltrim(Str(MV_PAR05,3))
	cPrazo4 := Alltrim(Str(MV_PAR06,3))
	cPrazo5 := Alltrim(Str(MV_PAR07,3))
	cPrazo6 := Alltrim(Str(MV_PAR08,3))

	//Irá montar as queries do objeto de negócio
	self:FatSV010CreateSQL()

	For nX := 1 To nNumFils

		oQuerySE1:SetUnsafe(nParam++ , cFieldsSE1)
		oQuerySE1:SetString(nParam++ , FatSVFilial('SF2', 'F2_FILIAL', aFiliais[nX]))
		oQuerySE1:SetString(nParam++ , ' ')
		oQuerySE1:SetString(nParam++ , FatSVFilial('SE4', 'E4_FILIAL', aFiliais[nX]))
		oQuerySE1:SetString(nParam++ , ' ')
		oQuerySE1:SetString(nParam++ , FatSVFilial('SE1', 'E1_FILIAL', aFiliais[nX]))
		oQuerySE1:SetString(nParam++ , DToS(MV_PAR01))
		oQuerySE1:SetString(nParam++ , DToS(MV_PAR02))
		oQuerySE1:SetString(nParam++ , Substr(MVNOTAFIS,1,3))
		oQuerySE1:SetString(nParam++ , ' ')
		oQuerySE1:SetString(nParam++ , 0)
		oQuerySE1:SetString(nParam++ , ' ')

	Next nX

	cALiasQrySE1 := oQuerySE1:OpenAlias()
    self:cAliasTmpSE1Loc := cALiasQrySE1

	//Posiciona no registro inicial
	(cALiasQrySE1)->(dbGoTop())

	//Tipo 2 - valida se esse registro do Alias pode ser considerado na listagem
	self:cCpoRemito := "(cALiasQrySE1)->F2_TIPODOC"
	self:processData(2)

	While !(cALiasQrySE1)->(Eof()) .And. !self:lRemito

		If (cRegAnt != (cALiasQrySE1)->E1_FILIAL + (cALiasQrySE1)->E1_EMISSAO + (cALiasQrySE1)->E1_NUM + (cALiasQrySE1)->E1_SERIE .And. NORDER == 1) .Or.;
			(NORDER == 2 .And. cDatAnt != (cALiasQrySE1)->E1_EMISSAO)
			cDatAnt := ""
			nAd1 	:= 0
			nAd2 	:= 0
			nAd3 	:= 0
			nAd4 	:= 0
			nAd5 	:= 0
			nAd6 	:= 0
		EndIf

		nDevol    := 0
		nDevolIPI := 0

		//Trato a Devolucao de Vendas
		If MV_PAR10 == 1

			nParam := 1

			For nX := 1 To nNumFils

				oQuerySD2:SetUnsafe(nParam++ , cFieldsSD2)
				oQuerySD2:SetString(nParam++ , FatSVFilial('SD1', 'D1_FILIAL', aFiliais[nX]))
				oQuerySD2:SetString(nParam++ , DToS(MV_PAR01))
				oQuerySD2:SetString(nParam++ , DToS(MV_PAR02))
				oQuerySD2:SetString(nParam++ , 'D')
				oQuerySD2:SetString(nParam++ , ' ')
				oQuerySD2:SetString(nParam++ , FatSVFilial('SD2', 'D2_FILIAL', aFiliais[nX]))
				oQuerySD2:SetString(nParam++ , (cALiasQrySE1)->E1_NUM)
				oQuerySD2:SetString(nParam++ , (cALiasQrySE1)->E1_SERIE)
				oQuerySD2:SetString(nParam++ , (cALiasQrySE1)->E1_CLIENTE)
				oQuerySD2:SetString(nParam++ , (cALiasQrySE1)->E1_LOJA)
				oQuerySD2:SetString(nParam++ , ' ')

			Next nX

			cALiasQrySD2 := oQuerySD2:OpenAlias()
    		self:cAliasTmpSD2Loc := cALiasQrySD2

			//Posiciona no registro inicial
			(cALiasQrySD2)->(dbGoTop())

			DbSelectArea(cALiasQrySD2)

			//Tipo 2 - valida se esse registro do Alias pode ser considerado na listagem
			self:cCpoRemito := "(cALiasQrySD2)->D2_TIPODOC"
			self:processData(2)

			//Soma Devolucoes
			While (cALiasQrySD2)->(!Eof()) .And. !self:lRemito

				//Tipo 2 - valida se esse registro do Alias pode ser considerado na listagem
				self:cCpoRemito := "(cALiasQrySD2)->D1_TIPODOC"
				self:processData(2)

				If !self:lRemito

					nDevol += ( ((cALiasQrySD2)->D1_TOTAL-(cALiasQrySD2)->D1_VALDESC)+(cALiasQrySD2)->D1_VALFRE+(cALiasQrySD2)->D1_SEGURO+(cALiasQrySD2)->D1_DESPESA+(cALiasQrySD2)->D1_ICMSRET )

					//Considera a devolucao de IPI (Brasil)
					self:processData(3)
					nDevolIPI += IIf(self:nDevolIPILoc > 0, self:nDevolIPILoc, 0)

				EndIf

				(cALiasQrySD2)->(DbSkip())

			EndDo

			(cALiasQrySD2)->(dbCloseArea())

		EndIf

		DbSelectArea(cALiasQrySE1)

		If ((cALiasQrySE1)->E4_TIPO == "9" .And. MV_PAR10 == 2) .Or. ((cALiasQrySE1)->E4_TIPO <> "9")
			aVenc  := Condicao(100,(cALiasQrySE1)->F2_COND)
			nDevol := ( nDevol + nDevolIPI ) / Len(aVenc)
		EndIf

		cFilReg := (cALiasQrySE1)->E1_FILIAL
		cNotFat := (cALiasQrySE1)->E1_NUM    + (cALiasQrySE1)->E1_SERIE
		cChave	:= (cALiasQrySE1)->E1_FILIAL + (cALiasQrySE1)->E1_BAIXA + (cALiasQrySE1)->E1_FATURA + (cALiasQrySE1)->E1_FATPREF + (cALiasQrySE1)->E1_TIPOFAT

		//Se gerou fatura a partir de uma duplicata vinda do faturamento,
		//considera a fatura (tipo FT) e nao a duplicata (tipo NF)
		If !Empty((cALiasQrySE1)->E1_FATURA) .And. AllTrim((cALiasQrySE1)->E1_FATURA) != "NOTFAT"

			//Caso mais de uma parcela desta nota gerou fatura, calcula o valor
			//das faturas apenas atraves da primeira duplicata e desconsideraas outras parcelas parcelas desta nota
			If aScan(aFaturas, cChave) == 0

				aAdd(aFaturas, cChave)
				nParam := 1

				For nX := 1 To nNumFils

					oSubQrSE1:SetUnsafe(nParam++ , cFldsSubSE1)
					oSubQrSE1:SetString(nParam++ , FatSVFilial('SE1', 'E1_FILIAL', aFiliais[nX]))
					oSubQrSE1:SetString(nParam++ , (cALiasQrySE1)->E1_CLIENTE)
					oSubQrSE1:SetString(nParam++ , (cALiasQrySE1)->E1_LOJA)
					oSubQrSE1:SetString(nParam++ , (cALiasQrySE1)->E1_FATPREF)
					oSubQrSE1:SetString(nParam++ , (cALiasQrySE1)->E1_FATURA)
					oSubQrSE1:SetString(nParam++ , (cALiasQrySE1)->E1_BAIXA)
					oSubQrSE1:SetString(nParam++ , ' ')

				Next nX

				cAliasSubSE1 := oSubQrSE1:OpenAlias()
				self:cAlSubTmpSE1Loc := cAliasSubSE1

				DbSelectArea(cAliasSubSE1)

				//Posiciona no registro inicial
				(cAliasSubSE1)->(dbGoTop())

				//Busca todas as faturas geradas a partir de uma duplicata vinda do faturamento (tipo NF)
				While (cAliasSubSE1)->(!Eof())

					SVC560Valor(@nAd1,@nAd2,@nAd3,@nAd4,@nAd5,@nAd6,nDevol,nDecs, (cALiasQrySE1)->E1_TIPOFAT == (cAliasSubSE1)->E1_TIPO,;
							(cAliasSubSE1)->E1_TIPOLIQ,(cAliasSubSE1)->E1_VALOR,(cAliasSubSE1)->E1_SALDO,(cAliasSubSE1)->E1_VENCREA,(cAliasSubSE1)->E1_VENCTO,(cAliasSubSE1)->E1_MOEDA,(cAliasSubSE1)->E1_EMISSAO)

					dbSelectArea(cAliasSubSE1)

					DbSkip()

				EndDo

				(cAliasSubSE1)->(dbCloseArea())

			EndIf

		Else
			If (((cALiasQrySE1)->E4_TIPO == "9" .And. MV_PAR10 == 2) .Or. ((cALiasQrySE1)->E4_TIPO == "9" .And. nDevol == 0) .Or. (cALiasQrySE1)->E4_TIPO <> "9") 
				SVC560Valor(@nAd1,@nAd2,@nAd3,@nAd4,@nAd5,@nAd6,nDevol,nDecs,.T.,(cALiasQrySE1)->E1_TIPOLIQ,(cALiasQrySE1)->E1_VALOR,(cALiasQrySE1)->E1_SALDO,(cALiasQrySE1)->E1_VENCREA,(cALiasQrySE1)->E1_VENCTO,(cALiasQrySE1)->E1_MOEDA,(cALiasQrySE1)->E1_EMISSAO)
			EndIf
		EndIf

		// Armazena as informações do registro atual
		cRegAnt := (cALiasQrySE1)->E1_FILIAL + (cALiasQrySE1)->E1_EMISSAO + (cALiasQrySE1)->E1_NUM + (cALiasQrySE1)->E1_SERIE
		cDatAnt := (cALiasQrySE1)->E1_EMISSAO
		cDatAtu := totvs.framework.treports.date.stringToTimeStamp((cALiasQrySE1)->E1_EMISSAO)
		nTotReg := nAd1 + nAd2 + nAd3 + nAd4 + nAd5 + nAd6

		// Vai para o próximo registro
		(cALiasQrySE1)->(DbSkip())

		// Compara se é o mesmo registro para retornar no while e somar os valores
		If cRegAnt == (cALiasQrySE1)->E1_FILIAL + (cALiasQrySE1)->E1_EMISSAO + (cALiasQrySE1)->E1_NUM + (cALiasQrySE1)->E1_SERIE

			Loop

		// Se for totalizador por dia e o próximo registro é da mesma data do anterior, retorna no inicio do while para totalizar
		ElseIf NORDER == 2 .And. cDatAnt == (cALiasQrySE1)->E1_EMISSAO

			Loop

		Else

			If NORDER == 2
				cNotFat := ""
			EndIf

			self:ojItems := JsonObject():new()
			self:ojItems["FILIAL"]  := cFilReg					 	 //Filial
			self:ojItems["EMISSAO"] := cDatAtu					 	 //Data de Emissao
			self:ojItems["NOTA"] 	:= cNotFat						 //Numero da nota
			self:ojItems["PRAZO1"] 	:= cPrazo1		 				 //Prazo 01
			self:ojItems["VALOR1"] 	:= nAd1							 //Valor 01
			self:ojItems["PRAZO2"] 	:= cPrazo2		 				 //Prazo 02
			self:ojItems["VALOR2"]	:= nAd2							 //Valor 02
			self:ojItems["PRAZO3"] 	:= cPrazo3	 					 //Prazo 03
			self:ojItems["VALOR3"] 	:= nAd3							 //Valor 03
			self:ojItems["PRAZO4"] 	:= cPrazo4		 				 //Prazo 04
			self:ojItems["VALOR4"] 	:= nAd4							 //Valor 04
			self:ojItems["PRAZO5"] 	:= cPrazo5						 //Prazo 05				
			self:ojItems["VALOR5"] 	:= nAd5							 //Valor 05
			self:ojItems["PRAZO6"] 	:= cPrazo6		 				 //Prazo 06	
			self:ojItems["VALOR6"] 	:= nAd6							 //Valor 06
			self:ojItems["TOTAL"] 	:= nAd1+nAd2+nAd3+nAd4+nAd5+nAd6 //Valor Total

			self:processData(1)
			self:oData:appendData(self:ojItems)

		EndIf

		//Variaveis cumulativas do Total Geral/Percentuais
		nAg1  += nAd1
		nAg2  += nAd2
		nAg3  += nAd3
		nAg4  += nAd4
		nAg5  += nAd5
		nAg6  += nAd6
		nSoma := nAg1 + nAg2 + nAg3 + nAg4 + nAg5 + nAg6

	EndDo

	//Imprime Percentuais
	If nSoma != 0

		self:ojItems := JsonObject():new()
		self:ojItems["NOTA"] 	:= STR0005				//Percentuais
		self:ojItems["PRAZO1"] 	:= cPrazo1		 		//Prazo 01
		self:ojItems["VALOR1"] 	:= (nAg1 * 100) / nSoma	//Percentual 01
		self:ojItems["PRAZO2"] 	:= cPrazo2		 		//Prazo 02
		self:ojItems["VALOR2"]	:= (nAg2 * 100) / nSoma	//Percentual 02
		self:ojItems["PRAZO3"] 	:= cPrazo3	 			//Prazo 03
		self:ojItems["VALOR3"] 	:= (nAg3 * 100) / nSoma	//Percentual 03
		self:ojItems["PRAZO4"] 	:= cPrazo4		 		//Prazo 04
		self:ojItems["VALOR4"] 	:= (nAg4 * 100) / nSoma	//Percentual 04
		self:ojItems["PRAZO5"] 	:= cPrazo5				//Prazo 05	
		self:ojItems["VALOR5"] 	:= (nAg5 * 100) / nSoma	//Percentual 05
		self:ojItems["PRAZO6"] 	:= cPrazo6		 		//Prazo 06	
		self:ojItems["VALOR6"] 	:= (nAg6 * 100) / nSoma	//Percentual 06
		self:ojItems["TOTAL"] 	:= 0 					//Valor Total

		self:processData(1)
		self:oData:appendData(self:ojItems)

	EndIf

	(cALiasQrySE1)->(dbCloseArea())

	FreeObj(oQuerySE1)
	FreeObj(oQuerySD2)
	FreeObj(oSubQrSE1)

	aSize(aFiliais, 0)
	aSize(aVenc,    0)
	aSize(aFaturas, 0)

Return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} SVC560Valor
Calcula valor a ser impresso
 
@return
 
@author FAT/CRM
@since 24/07/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Static Function SVC560Valor(nAd1 as numeric, nAd2 as numeric, nAd3 as numeric, nAd4 as numeric, nAd5 as numeric, nAd6 as numeric, nDevol as numeric, nDecs as numeric, lContinue as logical, cTpLiq as character, nValor as numeric, nSaldo as numeric, cVencReal as character, cVenc as character, nMoeda as numeric, cEmissao as character)

	Local nValCl 	:= IIf(Empty(cTpLiq), nValor, nSaldo)  					as numeric
	Local dVencto 	:= IIf(MV_PAR11 == 1, SToD(cVencReal), SToD(cVenc) ) 	as date
	Local dEmissao 	:= SToD(cEmissao) 										as date

	If lContinue

		nDevol := XMoeda(nDevol, nMoeda, MV_MOEDA, dVencto, nDecs + 1)
		nValCl := XMoeda(nValCl, nMoeda, MV_MOEDA, dVencto, nDecs + 1) - nDevol

		Do Case
			Case dVencto - dEmissao <= MV_PAR03
				nAd1 += nValCl
			Case dVencto - dEmissao <= MV_PAR04
				nAd2 += nValCl
			Case dVencto - dEmissao <= MV_PAR05
				nAd3 += nValCl
			Case dVencto - dEmissao <= MV_PAR06
				nAd4 += nValCl
			Case dVencto - dEmissao <= MV_PAR07
				nAd5 += nValCl
			OtherWise
				nAd6 += nValCl
		EndCase

	EndIf

Return

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema
 
@author FAT/CRM
@since 26/04/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getSchema() as object Class salesstatisticsbypaymenttermSmartViewBusinessObject

	Local nX 			:= 0  as numeric
	Local aCposFake		:= {} as array
    Local aParameters	:= {} as array

	self:aFields := {"FILIAL","EMISSAO","NOTA","PRAZO1","VALOR1","PRAZO2","VALOR2","PRAZO3","VALOR3","PRAZO4","VALOR4","PRAZO5","VALOR5","PRAZO6","VALOR6","TOTAL"}

	aCposFake := {	{"FILIAL",	STR0026, "string", 	STR0026, "FILIAL"},;	//Filial
					{"EMISSAO",	STR0006, "date", 	STR0006, "EMISSAO"},;	//Emissão
					{"NOTA", 	STR0007, "string", 	STR0007, "NOTA"},;		//Nota Fiscal
					{"PRAZO1", 	STR0008, "string", 	STR0008, "PRAZO1"},; 	//Dias 1º Periodo
					{"VALOR1", 	STR0009, "number", 	STR0009, "VALOR1"},; 	//Valores 1º Periodo
					{"PRAZO2", 	STR0010, "string", 	STR0010, "PRAZO2"},; 	//Dias 2º Periodo
					{"VALOR2", 	STR0011, "number", 	STR0011, "VALOR2"},; 	//Valores 2º Periodo
					{"PRAZO3", 	STR0012, "string", 	STR0012, "PRAZO3"},; 	//Dias 3º Periodo
					{"VALOR3", 	STR0013, "number", 	STR0013, "VALOR3"},; 	//Valores 3º Periodo
					{"PRAZO4", 	STR0014, "string", 	STR0014, "PRAZO4"},; 	//Dias 4º Periodo
					{"VALOR4", 	STR0015, "number", 	STR0015, "VALOR4"},; 	//Valores 4º Periodo
					{"PRAZO5", 	STR0016, "string", 	STR0016, "PRAZO5"},; 	//Dias 5º Periodo
					{"VALOR5", 	STR0017, "number", 	STR0017, "VALOR5"},; 	//Valores 5º Periodo
					{"PRAZO6", 	STR0018, "string", 	STR0018, "PRAZO6"},; 	//Dias 6º Periodo
					{"VALOR6", 	STR0019, "number", 	STR0019, "VALOR6"},; 	//Valores 6º Periodo
					{"TOTAL", 	STR0020, "number", 	STR0020, "TOTAL"}} 		//Total

    // Carrega os dados dos campos no array do aStruct
    self:aStruct := FatTrGetStruct(self:aFields, aCposFake)

	// Cria a estrutura dos campos Padroes
	For nX := 1 To Len(self:aStruct)
		self:addProperty(self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5])
	Next nX

	// Busca no SX1 os parâmetros que serão utilizados e remove os que estão no array
	aParameters := FtSVSetParam('MTR560',,, {'09'})

	// Adiciona parametro Ordem
	self:oSchema:addParameter("MV_FIL", STR0026, "string", .T.,,,,,, FTSVHelp(,,, .T.)) //Filial
	self:oSchema:addParameter("NORDER", STR0021, "number", .F.,,,,,, FTSVHelp(,, .T.))  //Ordem

	For nX := 1 To Len(aParameters) 
		self:oSchema:addParameter(aParameters[nX][1], aParameters[nX][2], aParameters[nX][3], aParameters[nX][4],,,,,, aParameters[nX][5])
	Next nX

	// Adiciona parametro Moeda por ultimo
	self:oSchema:addParameter("MV_MOEDA", STR0025, "number", .F.,,,,,, FTSVHelp('MTR560','09')) //Moeda

	If __lLookUp
		self:setCustomURL("MV_FIL",   "api/framework/v1/genericLookupService/smartview/SM0",2)										//Filial
        self:setCustomURL("NORDER",   "api/faturamento/smartview/v1/options/fat/salesstatisticsbypaymentterm/SVCBFATSV010/1", 1) 	//Ordem
		self:setCustomURL("MV_PAR10", "api/faturamento/smartview/v1/options/fat/salesstatisticsbypaymentterm/SVCBFATSV010/2", 1) 	//Inclui Devolução
		self:setCustomURL("MV_PAR11", "api/faturamento/smartview/v1/options/fat/salesstatisticsbypaymentterm/SVCBFATSV010/3", 1) 	//Vencimento Real
    EndIf

	aSize(aCposFake,   0)
    aSize(aParameters, 0)

Return self:oSchema

//-------------------------------------------------------------------
/*{Protheus.doc} SVCBFATSV010
Retorna as opçoes disponível para o parâmetro de ordem.

@return array: Array com as opçoes.

@author FAT/CRM
@since 30/04/2024
@version 1.0
*/
//-------------------------------------------------------------------
Function SVCBFATSV010(cOpcao)

	Local aRet := {} as array

	If cOpcao == "1"
		aRet := {STR0022 + " - " + STR0023, STR0022 + " - " + STR0024} // "Diario - Detalhado" | "Diario - Totalizado"
	ElseIf cOpcao == "2"
		aRet := FatGetCboX1('MTR560', 10)
	ElseIf cOpcao == "3"
		aRet := FatGetCboX1('MTR560', 11)
	EndIf

Return aRet

//-------------------------------------------------------------------
/*{Protheus.doc} FatSv010CreateSQL
Retorna todas as querys montadas

@return Nil

@author FAT/CRM
@since 09/10/2024
@version 1.0
*/
//-------------------------------------------------------------------
Method FatSV010CreateSQL() class salesstatisticsbypaymenttermSmartViewBusinessObject

	Local nX 		:= 0  as numeric
	Local cQuerySE1	:= "" as character
	Local cQuerySD2 := "" as character
	Local cSubQrSE1	:= "" as character

	// Função que verifica se há filiais informadas no parâmetro
    aFiliais := FatGetMVFiliais(MV_FIL)
	nNumFils := Len(aFiliais)

	cFieldsSE1 := "E1_FILIAL,E1_NUM,E1_SERIE,E1_EMISSAO,E1_TIPOLIQ,E1_SALDO,E1_TIPO,E1_FATURA,E1_FATPREF,E1_BAIXA,E1_NOMCLI,E1_TIPOFAT,E1_VALOR,E1_MOEDA,E1_VENCTO,E1_VENCREA,"
	cFieldsSE1 += "E1_CLIENTE,E1_LOJA,F2_COND,E4_TIPO"

	cFieldsSD2 := "D1_FILIAL,D1_DTDIGIT,D1_TIPO,D1_ITEMORI,D1_TOTAL,D1_VALDESC,D1_VALFRE,D1_DESPESA,D1_SEGURO,D1_ICMSRET,D1_VALIPI,D2_ITEM"
	cFieldsSD2 += self:cSelectSD2Loc

	cFldsSubSE1 := "E1_TIPOFAT,E1_TIPO,E1_TIPOLIQ,E1_VALOR,E1_SALDO,E1_VENCREA,E1_VENCTO,E1_MOEDA,E1_EMISSAO"

	// Faz o union das tabelas de acordo com a quantidade de filiais informadas
	For nX := 1 To nNumFils

		// Monta a query primcipal SE1
		cQuerySE1 += "SELECT ? "
		cQuerySE1 += "  FROM "  	+ RetSqlName("SE1") + " SE1 "
		cQuerySE1 += "LEFT JOIN " 	+ RetSqlName("SF2") + " SF2 "
		cQuerySE1 += "  ON  SF2.F2_FILIAL	= ? "
		cQuerySE1 += "  AND SF2.F2_DOC		= SE1.E1_NUM "
		cQuerySE1 += "  AND SF2.F2_SERIE	= SE1.E1_SERIE "
		cQuerySE1 += "  AND SF2.F2_CLIENTE	= SE1.E1_CLIENTE "
		cQuerySE1 += "  AND SF2.F2_LOJA		= SE1.E1_LOJA "
		cQuerySE1 += "  AND SF2.D_E_L_E_T_	= ? "
		cQuerySE1 += "LEFT JOIN " 	+ RetSqlName("SE4") + " SE4 "
		cQuerySE1 += "  ON  SE4.E4_FILIAL	= ? "
		cQuerySE1 += "  AND SE4.E4_CODIGO	= SF2.F2_COND "
		cQuerySE1 += "  AND SE4.D_E_L_E_T_	= ? "
		cQuerySE1 += "WHERE SE1.E1_FILIAL   = ? "
		cQuerySE1 += "  AND SE1.E1_EMISSAO >= ? "
		cQuerySE1 += "  AND SE1.E1_EMISSAO <= ? "
		cQuerySE1 += "  AND SE1.E1_TIPO     = ? "
		cQuerySE1 += "  AND (SE1.E1_TIPOLIQ = ? OR SE1.E1_SALDO <> ? ) "
		cQuerySE1 += "  AND SE1.D_E_L_E_T_  = ? "

		// Monta a query da SD2 e SD1 para buscar devoluções
		cQuerySD2 += "SELECT ? "
		cQuerySD2 += "  FROM " 	  + RetSqlName("SD2") + " SD2 "
		cQuerySD2 += "LEFT JOIN " + RetSqlName("SD1") + " SD1 "
		cQuerySD2 += "  ON  SD1.D1_FILIAL   = ? "
		cQuerySD2 += "  AND SD1.D1_SERIORI  = SD2.D2_SERIE "
		cQuerySD2 += "  AND SD1.D1_NFORI    = SD2.D2_DOC "
		cQuerySD2 += "  AND SD1.D1_COD      = SD2.D2_COD "
		cQuerySD2 += "  AND SD1.D1_ITEMORI  = SD2.D2_ITEM "
		cQuerySD2 += "  AND SD1.D1_DTDIGIT >= ? "
		cQuerySD2 += "  AND SD1.D1_DTDIGIT <= ? "
		cQuerySD2 += "  AND SD1.D1_TIPO     = ? "
		cQuerySD2 += "  AND SD1.D_E_L_E_T_  = ? "
		cQuerySD2 += "WHERE SD2.D2_FILIAL   = ? "
		cQuerySD2 += "  AND SD2.D2_DOC      = ? "
		cQuerySD2 += "  AND SD2.D2_SERIE    = ? "
		cQuerySD2 += "  AND SD2.D2_CLIENTE  = ? "
		cQuerySD2 += "  AND SD2.D2_LOJA     = ? "
		cQuerySD2 += "  AND SD2.D_E_L_E_T_  = ? "

		// Monta a subquery da SE1 para buscar faturados
		cSubQrSE1 += "SELECT ? "
		cSubQrSE1 += "  FROM " + RetSqlName("SE1") + " SUB_SE1 "
		cSubQrSE1 += "WHERE SUB_SE1.E1_FILIAL  = ? "
		cSubQrSE1 += "  AND SUB_SE1.E1_CLIENTE = ? "
		cSubQrSE1 += "  AND SUB_SE1.E1_LOJA    = ? "
		cSubQrSE1 += "  AND SUB_SE1.E1_PREFIXO = ? "
		cSubQrSE1 += "  AND SUB_SE1.E1_NUM     = ? "
		cSubQrSE1 += "  AND SUB_SE1.E1_EMISSAO = ? "
		cSubQrSE1 += "  AND SUB_SE1.D_E_L_E_T_ = ? "

		If nNumFils > 1 .And. nX < nNumFils
			cQuerySE1 += "  UNION ALL "
			cQuerySD2 += "  UNION ALL "
			cSubQrSE1 += "  UNION ALL "
		Else
			// Deve seguir essa ordenação para realizar os cálculos corretamente
			cQuerySE1 += "  ORDER BY SE1.E1_FILIAL,SE1.E1_EMISSAO,SE1.E1_NUM,SE1.E1_SERIE "
		EndIf

	Next nX

	// Executa a query principal SE1
	cQuerySE1 := ChangeQuery(cQuerySE1)
	oQuerySE1 := FwExecStatement():New(cQuerySE1)

	// Executa a query da SD2
	cQuerySD2 := ChangeQuery(cQuerySD2)
	oQuerySD2 := FwExecStatement():New(cQuerySD2)

	// Executa a subquery da SE1
	cSubQrSE1 := ChangeQuery(cSubQrSE1)
	oSubQrSE1 := FwExecStatement():New(cSubQrSE1)

Return
