#INCLUDE "PROTHEUS.CH"
#INCLUDE "LOCXNF.CH"
#include 'fwmvcdef.ch'
//Define's
#DEFINE MAX_GETD   400
//Constante com a descricao do remito
#Define DESCREM	 GetDescRem()
#Define _RMCONS 	"A"
//Tipos de validacao de parametros
#Define SpEmpty	   1
#Define SpValor	   2
#Define SpLenArray 3
#Define Sp2String  4
#Define Sp4String  5
#Define SpValType  6
//Numero maximo de pontos de entrada
#Define SnMaxPE    78
//Parametro aAtualiza
#Define SlCtbilOL  1
#Define SlAtuEstq  2
#Define SlAtuFina  3
#Define SlAtuImp   4
#Define SlAtuLF    5
#Define SlConsist  6
#Define SnMaxAtua  6
//Parametro aFin
#Define SnMoedaFin 1
#Define ScNatureza 2
#Define SnMaxFin   2
//Parametro aPergs
#Define SlAmarraca 1 //Incluir Amarraçäo  ? (Cli.xProd.) ou (For.xProd.)
#Define SlGerCtbil 2 //Lancamentos On-Line?
#Define SlVerCtbil 3 //Mostra Lanç.Contab ?
#Define SlAglutina 4 //Aglut Lançamentos  ?
#Define SlCtbEmiss 5 //Contabiliza por    ? Emissao/Data Base
#Define SnMaxPergs 6
//Array aPosicionou
#Define lSF4 		1
#Define lSB1 		2
#Define lSAx 		3
#Define lSC5 		4
#Define lSC6 		5
#Define lSC9		6
#Define lSC7		7
#Define lSD2		8
#Define lSD1		9
#Define nRecSD2	10
#Define nRecSD1	11
#Define nRecSF1	12
#Define lSF1		13
#Define lDAK		14
#Define nMaxPos 	14
//Array aCfgNf
#Define SnTipo      1
#Define ScCliFor    2
#Define SlFormProp  3
#Define SAliasHead  4
#Define SAliasCols  5
#Define ScOpEstoq   6
#Define ScAliasFin  7
#Define ScEspecie   8
#Define ScOpFin     9
#Define ScTipoDoc  10
#Define SaAtualiza 11
#Define SaLancPadC 12
#Define SaLancPadI 13
#Define SaBotoes   14
#Define SaTeclas   15
#Define SaPergs    16
#Define SaPE	   17
#Define SlRemito   18
#Define ScDescri   19
#Define ScDescGer  20
#Define SlPedido   21
#Define SbF12	   22
#Define SaCposGD   23
#Define SlConFrDp  24
#Define ScFilRot   25
#Define SaCposBr   26
#Define SaLancPCO  27
#Define SnMaxCfg   27
//Controle de Notas Fiscais em outras estacoes
Static cMayUse,__aCodLocs
Static aSX7_Total
Static lFolios := .T.
Static lHashPTG :=  cPaisLoc=="PTG" .And. SF1->(ColumnPos("F1_HASH")) > 0   .And. SF2->(ColumnPos("F2_HASH")) > 0  .And.  SF2->(ColumnPos("F2_VERHASH")) > 0
Static lLxModPE	:= FindFunction("LxModPE")
Static lChkLxProp := FindFunction("ChkLxProp")
/*³Programador ³Data    ³ BOPS     ³ Motivo da Alteracao ³±±
±±³Ivan Gomez  ³18/10/17³DMICNS-335³Se realiza replica de Issue DMICNS-132 ³±±
Funcao    Mata467n     Autor Leandro C.G. Data 14.03.2002
Descri‡…o Chamada da Nota de Saida Manual e de Benefiamento a Cliente
xAutoCab	- Array do Cabecalho
xAutoItens	- Array dos Itens
nOpcAuto	- Opcao da Rotina: 3-Inclusao | 5-Exclusao /*/
Function Mata467n(xAutoCab,xAutoItens,nOpcAuto,lSeek,nTipoOper,nTipo,xCartaPorte)
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)//Funcao Origem
Private aLlaveOrg := {}
Default nTipo   := 0
DEFAULT lSeek	:=	.T.
nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)
If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
EndIf
Do While nTipo == 0
	If Pergunte("MT467N",.T.)
		If MV_PAR01 == 1
			nTipo := 1	// Normal
		ElseIf MV_PAR01 == 2
			If cPaisLoc <> "BRA"
				MsgAlert(OemToAnsi(STR0453),OemToAnsi(STR0224))	//"Opción disponible solo para el país Brasil."#"ATENCIÓN"
				Loop
			EndIf
			nTipo := 11	// Benefici
		ElseIf MV_PAR01 == 3 .And. cPaisLoc == "EQU"
			nTipo := 17 //N de Venta
		ElseIf MV_PAR01 == 3 .And. cPaisLoc == "AUS"
			nTipo := 18 //RCTI
		ElseIf MV_PAR01 == 3 .And. cPaisLoc $ "MEX|PER|PAR"
			nTipo := 19 //Adiantamento
		ElseIf MV_PAR01 == 4 .And. cPaisLoc  $ "MEX" //jgr
			nTipo := 21 //Traslado
		EndIf
	EndIf
	Exit
EndDo
If nTipo > 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek,nTipoOper,,xCartaPorte)
Endif
SetKey(VK_F4	,{|| Nil })
SetKey(VK_F5	,{|| Nil })
SetKey(VK_F6	,{|| Nil })
SetKey(VK_F7	,{|| Nil })
SetKey(VK_F8	,{|| Nil })
SetKey(VK_F9	,{|| Nil })
SetKey(VK_F10	,{|| Nil })
SetKey(VK_F11	,{|| Nil })
SetKey(VK_F12	,{|| Nil })
Return
/*/
±±³Funcao    ³Mata462n    ³ Autor ³Bruno Sobieski  ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada da Remito  Saida Manual e de Benefiamento a Cliente ³±±
/*/
Function Mata462n(xAutoCab,xAutoItens,nOpcAuto,lSeek)
Local nTipo		:= 0
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
DEFAULT lSeek	:=	.T.

nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)
If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
	If nTipo == 0
		If Pergunte("MT467N",.T.)
			If MV_PAR01 == 1
				nTipo	:=	50
			ElseIf MV_PAR01 == 2
				nTipo	:=	52
			EndIf
		EndIf
	EndIf
Else
	Do While .T.
		If Pergunte("MT467N",.T.)
			If MV_PAR01 == 1
				LocxNf(50)
			ElseIf MV_PAR01 == 2
				LocxNf(52)
			Else
				Alert(STR0280)
			EndIf
		EndIf
		Exit
	EndDo
Endif
If nTipo > 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek)
Endif
SetKey(VK_F4	,{|| Nil })
SetKey(VK_F5	,{|| Nil })
SetKey(VK_F6	,{|| Nil })
SetKey(VK_F7	,{|| Nil })
SetKey(VK_F8	,{|| Nil })
SetKey(VK_F9	,{|| Nil })
SetKey(VK_F10	,{|| Nil })
SetKey(VK_F11	,{|| Nil })
SetKey(VK_F12	,{|| Nil })
Return
/*/
±±³Funcao ³Mata462dn ³ Autor ³Bruno Sobieski ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada da Remito de devolucao  (Faturamento)    ³±±
/*/
Function Mata462dn()
If Pergunte('MT462D',.T.)
	If mv_par01 == 1
		LocxNf(51)
	Else
		LocxNf(53)
	Endif
Endif
Return
/*/
±±³Funcao    ³Mata462R    ³ Autor ³Bruno Sobieski ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada da Remito de retorno simbolico (Faturamento)  ³±±
/*/
Function Mata462R(xAutoCab,xAutoItens,nOpcAuto,lSeek)
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
DEFAULT lSeek	:=	.T.

LocxNf(63,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek)
Return
/*/
±±³Funcao    ³Mata462TN   ³ Autor ³Guilherme C. Leal    ³ Data ³ 20020918 ³±±
±±³Descri‡…o ³Rotina de remitos de Transferencia. ³±±
/*/
Function Mata462TN()
If Pergunte('REMT10',.T.)
	If mv_par01 == 1
		LocxNf(64)	// Entrada
	Else
		LocxNf(54)	// Saida
	Endif
Endif
Return
/*³Funcao    ³Mata102dn   ³ Autor ³Bruno Sobieski ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada da Remito de devolucao  (Compras)   ³*/
Function Mata102dn(xAutoCab,xAutoItens,nOpcAuto,lSeek)
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem

DEFAULT lSeek	:=	.T.

LocxNf(61,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek)
Return

/*³Funcao    ³Mata101n    ³ Autor ³Leandro C.G. ³ Data ³14.03.2002³±±
±±³Descri‡…o ³Chamada da Nota de Entrada Manual ³*/
Function Mata101n(xAutoCab,xAutoItens,nOpcAuto,lSeek,nTipoOper,nTipo,xRatEvEz)
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
Local nPosAuto	:=0
Local nAux		:=0
Private lDocSp	:= .F.
Private aValor  := {}
Private lValor  := .F.
Private lAutoFact	:= .F.
Private aAutofac:={0}
DEFAULT lSeek	:=	.T.
DEFAULT nTipo	:= 0

nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)
If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])

	nPosAuto:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_AUTOFAC"})
	If nPosAuto>0
		nAux:=Val(xAutoCab[nPosAuto,2])
		IF nAux==1
			lAutoFact:=.T.
			aAutofac[1]:=5
		EndIf
	Endif
	If nTipo == 0
		If Pergunte("MT101N",.T.)
			If MV_PAR01 == 1
				nTipo := 10
			ElseIf MV_PAR01 == 2
				nTipo := 12
			ElseIf MV_PAR01 == 3
				nTipo := 13
			ElseIf MV_PAR01 == 4
				nTipo := 14
			ElseIf MV_PAR01 == 5 // THJRBP
				nTipo := 20
			EndIf
		EndIf
	EndIf
Else
	Do While nTipo == 0
		If Pergunte("MT101N",.T.)
			If MV_PAR01 == 1
				nTipo := 10
			ElseIf MV_PAR01 == 2
				If cPaisLoc <> "BRA"
					MsgAlert(OemToAnsi(STR0453),OemToAnsi(STR0224))	//"Opción disponible solo para el país Brasil."#"ATENCIÓN"
					Loop
				EndIf
				nTipo := 12
			ElseIf MV_PAR01 == 3
				nTipo := 13
			ElseIf MV_PAR01 == 4
				nTipo := 14
			ElseIf MV_PAR01 == 5 // THJRBP PERU y //MEXICO
				IF cPaisLoc == 'COL'
					nTipo := 10 //Doc. Soporte
					lDocSp := .T.
				ElseIF cPaisLoc $ "PAR|CHI"
					nTipo := 10 // factura normal
					lAutoFact:=.T.
					aAutofac:={5}
				Else
					nTipo := 20 //Adiantamento
				EndIf
			EndIf
		EndIf
		Exit
	EndDo
EndIf
If nTipo > 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek,nTipoOper,xRatEvEz)
Endif
SetKey(VK_F4	,{|| Nil })
SetKey(VK_F5	,{|| Nil })
SetKey(VK_F6	,{|| Nil })
SetKey(VK_F7	,{|| Nil })
SetKey(VK_F8	,{|| Nil })
SetKey(VK_F9	,{|| Nil })
SetKey(VK_F10	,{|| Nil })
SetKey(VK_F11	,{|| Nil })
SetKey(VK_F12	,{|| Nil })
Return
/*
±±³Funcao    ³Mata102n    ³ Autor ³Bruno Sobieski       ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada da Remito entrada Manual e de Benefiamento a Cliente³±±
*/
Function Mata102n(xAutoCab,xAutoItens,nOpcAuto,lSeek,nTipoOper,nTipo)
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
DEFAULT lSeek	:=	.T.
Default nTipo		:= 0

nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)

If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
	If nTipo == 0
		If Pergunte("MT102N",.T.)
			If MV_PAR01 == 1
				nTipo	:=	60
			Else
				nTipo	:=	62
			EndIf
		EndIf
	Endif
Else
	Do While .T.
		If Pergunte("MT102N",.T.)
			If MV_PAR01 == 1
				LocxNf(60)
			Else
				LocxNf(62)
			EndIf
		EndIf
		Exit
	EndDo
Endif
If nTipo > 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek,nTipoOper)
Endif
SetKey(VK_F4	,{|| Nil })
SetKey(VK_F5	,{|| Nil })
SetKey(VK_F6	,{|| Nil })
SetKey(VK_F7	,{|| Nil })
SetKey(VK_F8	,{|| Nil })
SetKey(VK_F9	,{|| Nil })
SetKey(VK_F10	,{|| Nil })
SetKey(VK_F11	,{|| Nil })
SetKey(VK_F12	,{|| Nil })
Return
/*
±±³Funcao    ³Mata465n    ³ Autor ³Leandro C.G.³ Data ³14.03.2002³±±
±±³Descri‡…o ³Chamada da Nota de Debito e Credito ao Cliente ³±±
*/
Function Mata465n(xAutoCab,xAutoItens,nOpcAuto,lSeek,nTipoOper,nTipo)
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
Public aDocOrig := {}
Default nTipo   := 0
DEFAULT lSeek	:=	.T.
nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)
If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
	If nTipo == 0
		If Pergunte("MT465N",.T.)
			Do Case
				Case MV_PAR01 == 1 .AND. MV_PAR02 == 1//NDC|
					nTipo := 2
				Case MV_PAR01 == 2 .AND. MV_PAR02 == 2//NCE³
					nTipo := 3
				Case MV_PAR01 == 1 .AND. MV_PAR02 == 2//NCC³
					nTipo := 4
				Case MV_PAR01 == 2 .AND. MV_PAR02 == 1//NDE³
					nTipo := 5
			EndCase
		EndIf
	EndIf
Else
	If nTipo == 0
	If Pergunte("MT465N",.T.)
		Do Case
			Case MV_PAR01 == 1 .AND. MV_PAR02 == 1//NDC|
				nTipo := 2
			Case MV_PAR01 == 2 .AND. MV_PAR02 == 2//NCE³
				nTipo := 3
			Case MV_PAR01 == 1 .AND. MV_PAR02 == 2//NCC³
				nTipo := 4
			Case MV_PAR01 == 2 .AND. MV_PAR02 == 1//NDE³
				nTipo := 5
			Case  MV_PAR02 == 3//NCC³NCA
				nTipo := 24
		EndCase
		If MV_PAR01 <> 1 //Leandro Prado - 10/03/2014
			lFolios := .F.
		EndIf
	EndIf
	EndIf
EndIf
//³Chamando programas de Notas Fiscais³
If nTipo <> 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek,nTipoOper)
EndIf
Return
/*
±±³Funcao    ³Mata466n    ³ Autor ³Leandro C.G.³ Data ³14.03.2002³±±
±±³Descri‡…o ³Chamada da Nota de Debito e Credito ao Fornecedor³±±
*/
Function Mata466n(xAutoCab,xAutoItens,nOpcAuto,lSeek,nTipoOper,nTipo)
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
Public aDocOrig := {}
Default nTipo   := 0
DEFAULT lSeek	:=	.T.
nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)

If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
	If nTipo == 0
		If  Pergunte("MT466N",.T.)
			Do Case
				Case MV_PAR01 == 1 .AND. MV_PAR02 == 1//NCI
					nTipo := 6
				Case MV_PAR01 == 2 .AND. MV_PAR02 == 2//³NCP
					nTipo := 7 //SD2
				Case MV_PAR01 == 1 .AND. MV_PAR02 == 2//³NDI
					nTipo := 8 //SD1
				Case MV_PAR01 == 2 .AND. MV_PAR02 == 1//³NDP
					nTipo := 9
			EndCase
		EndIf
	EndIf

	If nTipo == 7 .or. nTipo == 9
		lFolios := .F.
	EndIf
Else
	If nTipo == 0
	If  Pergunte("MT466N",.T.)
		Do Case
			Case MV_PAR01 == 1 .AND. MV_PAR02 == 1//NCI³
				nTipo := 6
			Case MV_PAR01 == 2 .AND. MV_PAR02 == 2//³NCP³
				nTipo := 7
			Case MV_PAR01 == 1 .AND. MV_PAR02 == 2//³NDI³
				nTipo := 8
			Case MV_PAR01 == 2 .AND. MV_PAR02 == 1//³NDP³
				nTipo := 9
			Case cPaisLoc == 'COL' .and. FINDFUNCTION( 'LxObtTpCol' )
				nTipo := LxObtTpCol( MV_PAR01,  MV_PAR02) //Nota Ajuste Locxcol
		EndCase
		If MV_PAR01 <> 1
			lFolios := .F.
		EndIf
	EndIf
	EndIf
Endif
If PCount() >= 2 .AND. cModulo == "EIC"
	LocxNCPEic(xAutoCab,xAutoItens,nOpcAuto)
	Return
EndIf
//³Chamando programas de Notas Fiscais³
If nTipo <> 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek,nTipoOper)
EndIf
Return nTipo
/*
±±³Funcao    ³Mata463N    ³ Autor ³Bruno Sobieski   ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada do recibo de servicos(compras)³±±
*/
Function Mata463N(xAutoCab,xAutoItens,nOpcAuto,lSeek)
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
DEFAULT lSeek	:=	.T.

LocxNf(15,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek)
Return
/*
±±³Fun‡…o    ³ LOCXNF   ³ Autor ³ Guilherme/Leandro C. G.³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Notas Fiscais  ³±±
*/
Function LOCXNF(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFuncName,lSeek,nTipoOper,xRatEvEz,xCartaPorte)
Local cMsgCFD   := ""
//Local FilD1D2   := ""
Local cLocxFil  := ""
Local cNotaTip  := "3,5"
Local cRetPe    := ""
//Local cAlias    := ""
//Local cCamposAd := ""
Local aPerg := {'MATXNF',.T.}
Local aRetPE  	:= {}
Local nX	  	:= 0					//Variavel de controle de LOOP
Local lCtbInTran:= .T.
Local aPergs			:=	{}	//Array com o conteudo das perguntas feitas na tela de NF
/*	[SlAmarraca 1]-Incluir Amarracao  ? (Cli.xProd.) ou (For.xProd.)
	[SlGerCtbil 2]-lanç. On-Line?
	[SlVerCtbil 3]-Mostra Lanç.Contab ?
	[SlAglutina 4]-Aglut Lançamentos  ?
	[SlQbraAliq 5]-Quebra do Rodapé   ? Por Alíquota/Por Imposto
   	[SlCtbEmiss 6]-Contabiliza por    ? Emissao/Data Base
*/
Local cFilSQL:='' //gsa
Local nTipoRem := 0
Local lLocxPdv  := ExistBlock("LOCXPDV")
Local cPdvFijo := ''
local nXy := 0
Local lfina998 := IsInCallStack("FINA887") .Or. IsInCallStack("FINA998")
Local lLOCXFILT := ExistBlock("LOCXFILT")
Local cMVVeiculo := SuperGetMv("MV_VEICULO",.F.,"N")
Local lR2410       := GetRPORelease() >= "12.1.2410"
Local lFATSV503    := ExistFunc("FATSV503") 
Local lSX1SV503    := FWSX1Util():ExistPergunte("FATSV503") 
Private nVlTit := 0
Private oMultNat := NIL
Private aIndD1D2:=	{} //Array necessario para a funcao FilBrowse
Private aCfgNF	:=	{}	//Array com todas as configuracoes da NF
Private oModelAct := Nil
Private oObj := Nil
/*	[SnTipo]	- codigo do tipo de NF
  	[ScEspecie]	- codigo da especie da NF
    [ScCliFor]	- indica se e cliente("C") ou fornecedor("F")
	[SlFormProp]- indica se e formulario proprio(0) ou nao(1)
	[SAliasHead]- arquivo de cabecalho da nota
	[SAliasCols]- arquivo de itens da nota
	[ScOpEstoq]	- indica se soma ou subtrai o estoque
	[ScAliasFin]- arquivo financeiro a atualizar
	[ScOpFin]	- indica sinal para movimentacao financeira
	[ScTipoDoc]	- tipo de documento {N- ;C- ;D-	;B)
	[SaAtualiza]- array com as permissoes para efetuar movimentacoes
	[SaLancPadC]- Array contendo o numero dos lancamentos padrao referentes a Cabecalho
	[SaLancPadI]- Array contendo o numero dos lancamentos padrao referentes a Itens
    [SaBotoes]	- Array com os botoes da tela, quando for tela
    [SaTeclas]	- Array com as funcoes chamadas por tecla te atalho e todas as respectivas teclas
	[SaPergs]	- Array com as perguntas efetuadas na entrada da NF (aPergs)
    [SaPE]		- Array com todos os pontos de entrada em suas devidas posicoes, de acordo com o tipo de Nota
    [SlRemito]	- Define se se trata de um remito
    [ScDescri]	- Descricao do documentro
    [SaCposBr]	- Campos que serao exibidos no Browse
*/
Private aPE	:= Array(SnMaxPE,2)	//Array com os pontos de entrada
/*	[1]- No inicio da rotina da tela que cria a EnchoiceBar
	[2]- Antes de comecar a montagem da tela, aCols e aHeader
	[3]- Apos o Ponto de entrada anterior
	[4]- No inicio da Rotina de Gravacao
	[5]- Apos gravacao do Livro Fiscal
	[6]- Permite alterar o valor da duplicata
	[7]- Integracao com o Celerina, depois de gravar a NF
	[8]- Apos gravacao do arquivo de cabecalho da Nota e todas as atualizacoes referentes a este arquivo
	[9]- Apos gravacao do arquivo de cabecalho da Nota e antes das atualizacoes referentes a este arquivo
	[10]- Apos atualizacoes do arquivo SB2
	[11]- Apos a gravacao da NF fora da transacao
	[12]- Na atualizacao do arquivo SC9
	[13]- Retorna a quantidade da segunda unidade de medida
	[14]- Apos a gravacao do SD1 e todas as atualizacoes referentes a este arquivo
	[15]- Apos a gravacao do SD1
	[16]- Apos as validacoes da rotina TudOk
	[17]- Apos as validacoes de cada item (LinOk)
	[18]- Apos a gravacao do arquivo financeiro
	[19]- Tecla F4 - Pedidos de Compra em Aberto
	[20]- Permite alterar a condicao de pagamento
	[21]- Altera os vencimentos da duplicata
	[22]- Deixa alterar a data inicial da condicao de pagamento
	[23]- Alteracao do numero e prefixos do aqruivo financeiro
	[24]- Apos confirmar o numero da NF
	[25]- Apos a geracao das comissoes
' Sempre que for incluido um ponto de entrada sera preciso alterar o "Define" no inicio do fonte de nome "SnMaxPE" '*/
//³Variaveis utilizadas para serem utilizadas como referencia nos pontos de entrada³
Private cEspecie 	:= "" //Especie da NF
Private nNFTipo  	:= 0  //Tipo da NF Numerica  (1,2,3,4,5,6,7,8,9,....)
Private cNFTipo	 	:= "" //Tipo da NF caractere ("N|D|C|B..."
Private cCadastro	:= FunDesc()
Private lCliente	:=.T.
Private nMoedaNf
Private cTASARTF    := 0.000
Private cNatFin
Private aRotina		:=	{}
Private aCores		:=	{}
Private bFilBrw		:=	{|| }
Private aDupl		:={}
Private aRegsLock	:={}
Private cEspecDoc   := Space(3)
Private bDoRefresh	:= {|| NIL}
Private lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)    //Integracao SIGAEIC
Private lEICFinanc	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.) //Integracao SIGAEIC - Financeiro
Private lFacImport	:= .F.
Private l103Class	:= .F.
Private lAnulaSF3   := .F.  //Determina se anula ou exclui o registro no Livro Fiscal(MaFisAtuSF3)
Private lFiLD1D2    := GetMv('MV_FLTD1D2')
//³Uso para comprovantes fiscais digitais³
Private aGerarCFD := {}
Private lGerarCFD := .F.
//³Variaveis da Rotina Automatica     ³
Private aAutoCab	:= IIf(xAutoCab==NIL,{},xAutoCab)  			//Array do Cabecalho
Private aAutoItens	:= IIf(xAutoItens==NIL,{},xAutoItens)		//Array dos Itens
Private aRatEvEz	:= IIf(xRatEvEz==NIL,{},xRatEvEz)		//Array dos Itens miltinaturaleza
Private cFunName	:= IIf(cFuncName==NIL .Or. Empty(cFuncName),Upper(Alltrim(FunName())),cFuncName)	//Funcao Origem
Private lLocxAuto	:= ( ValType(xAutoCab) == "A" .AND. ValType(xAutoItens) == "A" )
Private l103Auto	:= lLocxAuto	// Compatibilidade com as rotinas do MATA103()
Private lAtuFor		:= .F.
Private cPathXML	:= "", _cArq:="", _cRFC:="", _cRFCRec:="", _cUUID:=""
If cPaisLoc == "GUA"
	Private cMotivo     := Space(6)
	Private lGeraNCC    := .F.
	Private aDadosSF2   := {}
	Private aDadosSD2   := {}
	Private cNumResol   := Space(TamSX3("FQ_RESOLUC")[1])
EndIf
Private aTrocaF3	:= {}
PRIVATE aMemoSDE    := {}
PRIVATE aNotasTrf	:= {}
If funname() != "FINA100"
	PRIVATE aImpIB2		:= {}
EndIf
PRIVATE aImpCCO		:= {}
PRIVATE aImpSFC		:= {}
PRIVATE aImpSFF		:= {}
PRIVATE aImpSFH		:= {}
PRIVATE aImpLivr	:= {}
PRIVATE aTesMXF		:= {}
PRIVATE cUltCpo		:= ""
If !(cPaisLoc=="ARG" .and. (funname() $ "FINA846|FINA935|FISA828" .Or. lfina998) )
	Private cLocxNFPV	:= "" //- Armazenara o número do PV p/ argentina
EndIf
Private cIdPVArg	:= "" //- Armazenara o id do PV p/ argentina
Private lActFjRm	:= .F.
Private cFactApoc   := ""
Private cCompOnL    := SuperGetMV("MV_NCCONL",.F.,"")
Private cCFDUso     := Alltrim(GetMv("MV_CFDUSO", .T., "1"))
Private lFilPV:=.T.
Private aTESPedC    := {}
If cPaisLoc =='EQU' .and. nTipo == 1
	Private cFormCrbo   := "" //Forma de Cobro EQU
EndIf
Private aCartaPorte	:= IIf(xCartaPorte==NIL,{},xCartaPorte)  			//Array de Carta Porte

Default nTipo 	 	:= 1
If cPaisLoc=="ARG"   .And.  !(FunName() $ ("FINA846|FINA935|FISA828") .Or. lfina998)
		cLocxNFPV	:= Space(Tamsx3("F1_PV")[1])
EndIf
nOpcAuto := IIf(nOpcAuto == NIL,3,nOpcAuto)//3-Inclusao | 5-Exclusao
If lIntegracao .AND. nTipo==10
	IF !ChkFile("SWN",.F.)
		HELP(" ",1,"SWNEmUso")
		Return(.F.)
	Endif
Endif
If ( Type("lLocxAuto") <> "U" .AND. lLocxAuto ) .and. nOpcAuto == 3 .and. cPaisLoc == "ARG"
	If Len(xAutoCab[1]) > 0
		cUltCpo := nRetOrdem(Iif(Substring(xAutoCab[1][1],1,2)=="F1","SF1","SF2"))
	Endif
EndIf
SX3->(dbSetOrder(1))
//³Chama o grupo de Perguntas e acerta o array de perguntas O tipo da variavel aPergunta estah sendo modificado para que a funcao Pergunte nao
//restaure a pergunta anterior
If Type("aPergunta")=="A"
	aPergunta  := NIL
EndIf
//³PE de para adicionar grupos de perguntas ³
If ExistBlock('LOCXPERG')
	aPerg := Execblock('LOCXPERG',.F.,.F.,nTipo)
Else
	//³Chama o grupo de Perguntas e acerta o array de perguntas³
	aPerg := If(AllTrim(Str(nTipo,2))$cNotaTip,{'MATXNF',.T.},{'MTXRED',.T.})
EndIf
//³PE de para adicionar Tipos de Nota  nas perguntas ³
If ExistBlock('LOCXOKPG')
	cRetPe := Execblock('LOCXOKPG',.F.,.F.,{cNotaTip})
	If VALTYPE(cNotaTip) == "C"
		cNotaTip:=cRetPe
	EndIf
EndIf

If lLocxAuto
	Pergunte(aPerg[1],.F.)
Else
	If !Pergunte(aPerg[1],aPerg[2])
		Return .F.
	Endif
EndIf
//Opción de compensación OnLine
If Valtype(cCompOnL) == "U" .Or. Empty(cCompOnL) .Or. !(cCompOnL $ "1|2|3")
	If cPaisLoc == "MEX" .And. cCFDUso <> "0"
		cCompOnL := "1" //Fact. Electrónica y compensa en línea
	ElseIf cPaisLoc $ "CHI|COL|EQU|PER|BOL|PAR"
		cCompOnL := "2" //Fact. Electrónica y NO compensa en línea (por tiempo de espera en retorno de estatus de timbrado)
	Else
		cCompOnL := "3" //NO Fact. Electrónica y compensa en línea
	EndIf
EndIf
LoadPergs(aPerg,@aPergs)
//Leandro Prado - 21/02/2014 - Controle de Ponto de Venda
lFilPV:=.T.
If (cPaisLoc == "ARG") .and. ExistBlock("DESAPV")
	lFilPV:=.F.
EndIf
If (cPaisLoc == "ARG") .AND.lFilPV .And. ( ( cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA462N|MATA462DN|MATA462TN|MATA102DN|FINA096|MATA462R") .or. (FUNNAME() == "FINA074" .Or. (FUNNAME() == "FINA095" .And. nTipo <> 9)))
	nTipoRem := MV_PAR01
	If (lFolios .and. !(cFunName== "MATA462DN"))  .or. (cFunName== "MATA462DN" .and. ntipo<>53 )
		If lLocxPdv
			cPdvFijo := ExecBlock("LOCXPDV",.F.,.F.,{cFunName, ntipo})
			MV_PAR01 := cPdvFijo
		Endif
		If Empty(cPdvFijo)
			If !Pergunte("PVXARG",.T.)
				Return .F.
			Endif
		Endif
 		cLocxNFPV := MV_PAR01
 		cIdPVArg := POSICIONE("CFH",1, xFilial("CFH")+cLocxNFPV,"CFH_IDPV")
 		If !F083ExtSFP(MV_PAR01, .T.)
 			Return .F.
 		EndIf
 		If cFunName == "MATA462N"
 			MV_PAR01 := nTipoRem
 		EndIf
 	EndIf
EndIf
If aPerg[1] == "MTXRED"
	AAdd(aPergs,.F.)
Endif
//³Monta array de configuracao da NF ³
aCfgNF := MontaCfgNf(nTipo,aPergs,.T.)
If Empty(aCfgNF)
	Return .F.
EndIf
//Nao e permitido utilizar lanç On-Line com TTS ativado (c/ excecoes)
If ( aCfgNf[SaPergs][SlGerCtbil] .And. __TTSInUse .And. !cPaisLoc $ "PTG|ARG|MEX|BOL|CHI|URU|COL|RUS|PER|VEN|PAR|EUA|EQU|" )
	// Verifica se contabilizacao pode ser executada dentro da transacao
	If cPaisLoc == "PER"
		lCtbInTran := IIf(CTBINTRAN(1,aCfgNf[SaPergs][SlVerCtbil]),.T.,.F.)
	EndIf
	If ( cPaisLoc <> "PER" .Or. (cPaisLoc == "PER" .And. !lCtbInTran) )
		HELP(" ",1,"460TTSLANC")
		Return .F.
	EndIf
Endif
//³Incilializa variaveis privates³
NFSetPrv(aCfgNF)
cCadastro:= aCfgNF[ScDescGer]
cEspecDoc  := aCfgNF[ScEspecie]
//³Acertando o F12.                    ³
If cPaisLoc == "ARG" .And. ( Subs(cFunName,1,3) $ "PMS" .Or. cFunName $ "MATA462N|MATA521B|" .Or. funname() == "ARGREMELET")
	SetKey(VK_F12, Nil)
Else
	SetKey(VK_F12, aCfgNF[SbF12])
EndIf
//³Acertando arrauy dos PE³
aPE	      := aClone(aCfgNF[SaPE])
//³ PE para adicao de campos memo do usuario       ³
cPe	:= LocxPE(73)
If !Empty(cPE)
	If Valtype(	aMemUser := ExecBlock( cPE, .F., .F. ) ) == "A"
		aEval( aMemUser, { |x| aAdd( aMemoSDE, x ) } )
	EndIf
EndIf
//³Monta aRotina, Browse e configracoes da tela³
aRotina := MenuDef()
nX	:=	Iif((cPaisLoc == "RUS"), Len(aRotina)+1, 4)
If lIntegracao .AND. '10' $ aCfgNf[ScFilRot]
	AAdd(aRotina,{ OemToAnsi(STR0161),"LocxDlgNF(aCfgNF,4,bFilBrw)", 0 , 4,0,NIL}) //"Classificar"
	nX++
Endif
//Nao permitir a exclusao dos docs. emitidos de acordo com a SAT - Loc. Guatemala// Nao permitir exclusao de notas fiscais Loc. Rep. Dom.
If IIf(cPaisLoc == "DOM" .AND. (aCfgNF[SAliasHead] == "SF2" .OR. aCfgNf[ScEspecie] $ "NCC"),.F.,.T.) .And. IIf(cPaisLoc == "GUA",aCfgNF[SnTipo] >= 50,.T.) .And. IIf(cPaisLoc == "MEX",IIf( ( (cFunName $ "MATA467N/MATA465N") .And. (SuperGetMV("MV_BORRFAT",,.T.)) ) .Or. ( !(cFunName $ "MATA467N/MATA465N") ),.T.,.F.),.T.)
	If !(cFunName $ "MATA103CG/MATA103CF/MATA462G") .and. aCfgNf[SnTipo] <> 24
		AAdd(aRotina,{ OemToAnsi(STR0025	) 	,"LocxDlgNF(aCfgNF,"+STR(nX,1)+",bFilBrw)", 0 , 5,0,NIL}) //"Excluir"
	   nX++
	EndIf
	If  cPaisLoc == "ARG"
		If  cFunName == "MATA462N"
			AAdd(aRotina,{ OemToAnsi(STR0189) 	,"LocxAnula(aCfgNF,"+STR(nX,1)+",bFilBrw)" , 0 , 5,0,NIL}) //"Anular"
			nX++
		EndIf
	Endif
EndIf
If aCfgNf[SlFormProp] .AND.  !aCfgNf[ScEspecie] $ "RFN|RFD|RFB|RET|RCB|RCD" .AND. ;
   IIf(Trim(aCfgNf[ScEspecie])=="NF" .AND. aCfgNf[SnTipo]==11,.F.,.T.) .AND. aCfgNf[SnTipo] <> 24
	AAdd(aRotina,{ OemToAnsi(STR0189	) 	,"LocxAnula(aCfgNF,"+STR(nX,1)+",bFilBrw)" , 0 , 5,0,NIL}) //"Cancelar"
	nX++
EndIf

If lR2410 .And. lFATSV503 .And. lSX1SV503 .and. ( cFunName == "MATA462N" )
	aAdd(aRotina,{STR0465, "FATSV503()", 0, 7, 0, NIL}) // Imprimir remisión
Endif


If (cPaisLoc == "RUS") .and. ( cFunName == "MATA462N")
	aAdd(aRotina,{STR0391, "RU05R02()", 0, 7, 0, NIL}) //print report M-15
	nX++
EndIf
If cPaisLoc == "MEX" //Accciones
	LXMexAcc(@aRotina)
EndIf
If cPaisLoc == "RUS"  .And. (cFunName$ "MATA101N")
	aAdd(aRotina,{STR0389,"RU02R01()", 0, 6, 0, Nil})
	aAdd(aRotina,{STR0386,"RU02R02()", 0, 7, 0, Nil})//print report M-7
	aAdd(aRotina,{STR0388,"RU02R03()", 0, 8, 0, Nil})//print report TORG-1
	aAdd(aRotina,{STR0390,"RU02R04()", 0, 9, 0, Nil})//print report TORG-2
EndIf
//³Gera faturas eletronicas³
If cPaisLoc == "RUS"  .And. (cFunName$ "MATA102N")
	aAdd(aRotina,{STR0389,"RU02R01()", 0, 6, 0, Nil})
	aAdd(aRotina,{STR0424,"RU04R02()", 0, 7, 0, Nil})
EndIf

If cPaisLoc == "RUS"  .And. (cFunName$ "MATA102DN")
	aAdd(aRotina,{STR0425,"RU04R03()", 0, 7, 0, Nil})
EndIf

lGerarCFD := .F.
aGerarCFD := {}
If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
	If !(cPaisLoc $ "PTG|ANG")
		aGerarCFD := CFDVerific()
	Else
		aGerarCFD := {"0"}
	Endif
	If cCompOnL == "1" //Fact. Electrónica y compensación Online
		If Empty(aGerarCFD[2])
			lGerarCFD := .T.
			If aCfgNF[SAliasHead] == "SF2"
				If cFunName $ "MATA467N|MATA465N" .And. (nNFTipo == 1 .Or. nNFTipo == 2 .Or. nNFTipo == 21)
					AAdd(aRotina,{OemToAnsi(STR0247),"CFDGerXML(SF2->F2_ESPECIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE)",0,2,0,NIL})
				EndIf
				If cFunName == "MATA467N" .And. (nNFTipo == 1 .Or. nNFTipo == 21) .and. FindFunction("LxCartaPor") .And. SF2->(ColumnPos("F2_TPCOMPL")) > 0
					AAdd(aRotina,{OemToAnsi(STR0438),"LxCartaPor('SF2',SF2->F2_FILIAL,SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_ESPECIE,SF2->F2_TPCOMPL=='S',.T.)",0,2,0,NIL}) //"Carta Porte"
				EndIf
			Else
				If cFunName $ "MATA465N" .And. nNFTipo == 4
					AAdd(aRotina,{OemToAnsi(STR0247),"CFDGerXML(SF1->F1_ESPECIE,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE)",0,2,0,NIL})
				EndIf
			EndIf
		Else
		    If !lLocxAuto
				cMsgCFD := ""
				For nX := 1 To Len(aGerarCFD[2])
					cMsgCFD += aGerarCFD[2][nX][2] + CRLF
				Next
				MsgAlert(cMsgCFD,STR0248)
			Endif
		Endif
	Else
		lGerarCFD := .F.
	Endif
Endif
If cPaisLoc == "PAR" .and. cFunName == "MATA467N" .and. aGerarCFD[1] <> "0"
	AAdd(aRotina,{OemToAnsi(STR0427),"M486PAGOS(SF2->F2_ESPECIE, SF2->F2_DOC, SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_COND, SF2->F2_VALBRUT,4)",0,2,0,NIL}) //"Registro Pagos"
EndIf
If !lFiLD1D2.OR. Alltrim(Str(nTipo))$"1|10|50|60|11|12|13|14|17|18|19|20|21"
	AAdd(aRotina,{ OemToAnsi(STR0017)   ,"LocxLegenda()",0 , 2,0,.F.} )
	If aCfgNF[SAliasHead] == "SF2"
		AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"01"' + IIF(cPaisLoc == "MEX",'.AND. !(F2_FLFTEX $ "8|7|9")','')	, 'DISABLE'})		// NF Normal
		If cPaisLoc == "EQU"
			AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"17"', 'BR_BRANCO'})	// Nota de Venta
		ElseIf cPaisLoc == "AUS"
			AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"18"', 'BR_BRANCO'})	// RCTI
		ElseIf cPaisLoc  $ "MEX|PER"
			If cPaisLoc == "MEX"
				AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"21"', 'BR_VERDE'})	 // Traslado - México
				AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"01" .AND. F2_FLFTEX ==	"7"', 'BR_AZUL_CLARO'})	 // Cancel. Fuera de Periodo
				AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"01" .AND. F2_FLFTEX ==	"8"', 'BR_VERDE_ESCURO'})	 // Cancel. Fuera de Periodo
				AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"01" .AND. F2_FLFTEX ==	"9"', 'BR_VIOLETA'})	 // Cancel. Fuera de Periodo
			Else
				AAdd(aCores,{ 	'F2_TIPO	==	"A" 	.AND. F2_TIPODOC	==	"19"', 'BR_BRANCO'}) // Adiantamento
			EndIf
		ElseIf cPaisLoc  $ "PAR"
			AAdd(aCores,{ 	'F2_TIPO	==	"A" 	.AND. F2_TIPODOC	==	"19"', 'BR_BRANCO'}) // Adiantamento
		endif
		AAdd(aCores,{  'F2_TIPO	==	"C"	.AND. F2_TIPODOC	$	"02/03"'		, 'BR_PINK'})		// NF de Compl. Preco/Frete
		AAdd(aCores,{  'F2_TIPO	==	"B"	'										, 'BR_CINZA'})		// NF de Beneficiamento
		AAdd(aCores,{  'F2_TIPO	==	"D"	.AND. F2_TIPODOC	$	"06/07"' 		, 'BR_AMARELO'}) 	// NF de Devolucao
		AAdd(aCores,{  'F2_TIPO	==	"D"	.AND. F2_TIPODOC	==	"61"' 			, 'BR_AZUL'})		// Remito de devolucao
		AAdd(aCores,{  'F2_TIPO	==	"N"	.AND. F2_TIPODOC	==	"50"' 			, 'BR_MARROM'})		// Remito
		AAdd(aCores,{  'F2_TIPO	==	"B"	.AND. F2_TIPODOC	==	"54"'    		, 'BR_PRETO'}) 		// Remito transf.
	ElseIf aCfgNF[SAliasHead] == "SF1" .And. SuperGetMV("MV_CONFFIS",.F.,"N") == "S" .And. cFunName $ "MATA102N|MATA462DN|MATA101N|MATA466N"
		If lIntegracao
			AAdd(aCores,{'Empty(F1_STATUS) .AND. !Empty(F1_TIPO_NF)'																,'BR_VERDE'})		// NF Importacao (nao classificada)
			AAdd(aCores,{'F1_STATUS=="A" .AND. !Empty(F1_TIPO_NF)'																	,'BR_PRETO'})	    // NF Importacao (classificada)
		Endif
		AAdd(aCores,{  '((F1_STATCON $ "1|4") .OR. EMPTY(F1_STATCON)) .And. F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"10"   '	, 'DISABLE'})		// NF Normal
		AAdd(aCores,{  '((F1_STATCON $ "1|4") .OR. EMPTY(F1_STATCON)) .And. F1_TIPO	==	"C"	.AND. F1_TIPODOC	$	"08/09"'	, 'BR_PINK'})		// NF Compl. Preco
		AAdd(aCores,{  'F1_TIPO	==	"B"	.AND. F1_TIPODOC	<>	"63"   '																, 'BR_CINZA'})		// NF Beneficiamento
		AAdd(aCores,{  'F1_TIPO	==	"D"	.AND. F1_TIPODOC	$	"04/05"'    															, 'BR_AMARELO'})	// NF Devolucao
		AAdd(aCores,{  '((F1_STATCON $ "1|4") .OR. EMPTY(F1_STATCON)) .And. F1_TIPO	==	"D"	.AND. F1_TIPODOC	$	"51/53"'	, 'BR_AZUL'})		// Remito devolucao
		AAdd(aCores,{  '((F1_STATCON $ "1|4") .OR. EMPTY(F1_STATCON)) .And. F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"60"   '	, 'BR_MARROM'})	// Remito
		AAdd(aCores,{  'F1_TIPO	==	"C"	.AND. F1_TIPODOC	$	"13/14"'																, 'BR_LARANJA'})	// Desp.Importacao
		AAdd(aCores,{  'F1_TIPO	==	"B"	.AND. F1_TIPODOC	==	"63"   '																, 'BR_BRANCO'})	// NF de Ret.Simbolico
		AAdd(aCores,{  'F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"64"   '																, 'BR_PRETO'})	    // Remito Transferencia
		AAdd(aCores,{  '!(F1_STATCON $ "1|4") .AND. !EMPTY(F1_STATCON)'																, 'BR_VIOLETA'})  // NF Bloq. para Conferencia
		If cPaisLoc $ "|MEX|PER|"
			AAdd(aCores,{ 	'F1_TIPO	==	"A" 	.AND. F1_TIPODOC	==	"20"'															, 'BR_BRANCO'})	// Adiantamento
        Endif
	ElseIf aCfgNF[SAliasHead] == "SF1"
		If lIntegracao
			AAdd(aCores,{'Empty(F1_STATUS) .AND. !Empty(F1_TIPO_NF)','BR_VERDE'})				// NF Importacao (nao classificada)
			AAdd(aCores,{'F1_STATUS=="A" .AND. !Empty(F1_TIPO_NF)','BR_PRETO'})	    			// NF Importacao (classificada)
		Endif
		AAdd(aCores,{  'F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"10"   '	, 'DISABLE'})		// NF Normal
		AAdd(aCores,{  'F1_TIPO	==	"C"	.AND. F1_TIPODOC	$	"08/09"'	, 'BR_PINK'})		// NF Compl. Preco
		AAdd(aCores,{  'F1_TIPO	==	"B"	.AND. F1_TIPODOC	<>	"63"   '	, 'BR_CINZA'})		// NF Beneficiamento
		AAdd(aCores,{  'F1_TIPO	==	"D"	.AND. F1_TIPODOC	$	"04/05"'    , 'BR_AMARELO'})	// NF Devolucao
		AAdd(aCores,{  'F1_TIPO	==	"D"	.AND. F1_TIPODOC	$	"51/53"'	, 'BR_AZUL'})		// Remito devolucao
		AAdd(aCores,{  'F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"60"   '	, 'BR_MARROM'})	    // Remito
		AAdd(aCores,{  'F1_TIPO	==	"C"	.AND. F1_TIPODOC	$	"13/14"'	, 'BR_LARANJA'})	// Desp.Importacao
		AAdd(aCores,{  'F1_TIPO	==	"B"	.AND. F1_TIPODOC	==	"63"   '	, 'BR_BRANCO'})	    // NF de Ret.Simbolico
		AAdd(aCores,{  'F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"64"   '	, 'BR_PRETO'})	    // Remito Transferencia
		If cPaisLoc $ "|MEX|PER|"
			AAdd(aCores,{ 	'F1_TIPO	==	"A" 	.AND. F1_TIPODOC	==	"20"', 'BR_BRANCO'})	// Adiantamento
        Endif

	EndIf
EndIf

aAdd(aRotina,{STR0349,"CTBC662"	, 0 , 2 , 0 , NIL})  // "Tracker Contábil"
If ExistBlock("MT462MNU")
	ExecBlock("MT462MNU",.F.,.F.)
EndIf
//PE adicionar Status a Legenda LOCXPE63
aCores:=LocxLegCor(1,aCfgNF[SAliasHead],aCores)

// Rotina Automatica
If ( Type("lLocxAuto") <> "U" .AND. lLocxAuto )
	If cPaisLoc == "EUA" .And. FindFunction("LxCanNFEUA") //Ajuste para corregir el cancelamiento de NF via execauto
		LxCanNFEUA(nOpcAuto, cFunName, @lAnulaSF3, aAutoCab, aCfgNF[SAliasHead], lSeek)
	Else
		If (nOpcAuto == 6 .And. (cFunName $ "MATA467N")) ; //6-Cancelar/Anular (via execauto)
		.Or. (cPaisLoc $ "PER|MEX" .And. nOpcAuto == 6 .And. cFunName $ "MATA465N") //Anulación vía execauto para NDC y NCC
			nOpcAuto  := 5			//5-Exclusão
			lAnulaSF3 := .T.		//Determina se anula ou exclui o registro no Livro Fiscal
		EndIf
		MBrowseAuto(nOpcAuto,Aclone(aAutoCab),aCfgNF[SAliasHead],lSeek)
		If ((cFunName $ "MATA467N") .And. nOpcAuto == 5 .And. lAnulaSF3) ;
		.Or. (cPaisLoc $ "PER|MEX" .And. (cFunName $ "MATA465N") .And. nOpcAuto == 5 .And. lAnulaSF3)
			lAnulaSF3 := .F.
		EndIf
	EndIf
Else
	If lFiLD1D2

	    cFilD1D2 := PrefixoCpo(aCfgNF[SAliasHead]) + "_TIPODOC $ '" + aCfgNF[ScFilRot] + "'"
	    cFilSQL :=PrefixoCpo(aCfgNF[SAliasHead]) + "_TIPODOC IN ('" + STRTRAN (aCfgNF[ScFilRot] , "/" , "','" ,1,len(aCfgNF[ScFilRot]) ) + "')" //GSA

		// MODULO DMS ( 11 - VEICULOS )
		If cMVVeiculo == "S" .And. FindFunction("VA1810031_Filtro_Browse")
			VA1810031_Filtro_Browse(@cFilD1D2,@cFilSQL)
		EndIf

		If lLOCXFILT
			cLocxFil := ExecBlock("LOCXFILT",.F.,.F.,{PrefixoCpo(aCfgNF[SAliasHead]),aCfgNF[ScFilRot],cFilD1D2} )
			If ( ValType(cLocxFil) == "C" ) .And. !Empty(cLocxFil)
				cFilD1D2 += IIf(Empty(cFilD1D2),"",".And.")+cLocxFil
			EndIf
		EndIf
		lFilPV:=.T.
		If (cPaisLoc == "ARG") .and. ExistBlock("DESAPV")
			lFilPV:=.F.
		EndIf
		If (cPaisLoc == "ARG") .And. lFilPV  .And. ( cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA462N|MATA462DN|MATA462R") .And. lFolios // Leandro Prado - 21/02/2014 - Controle de Ponto de Venda.
			cFilD1D2 += IIf(Empty(cFilD1D2),"",".And. " ) + PrefixoCpo(aCfgNF[SAliasHead]) + "_PV $ '" + cLocxNFPV + "'"
		EndIf
       	if cPaisLoc <> "ARG" .AND. !AllTrim(cFunName)$"MATA462N/MATA462DN/MATA465N/MATA467N" .and. !(cPaisLoc == "RUS" .AND. AllTrim(cFunName)$"MATA466N/MATA467N")
       		If !Empty(cLocxFil) .and. cFunName $ "MATA101N|MATA102N|MATA102DN|MATA466N"
				bFilBrw	:=	{|| FilBrowse(aCfgNF[SAliasHead],@aIndD1D2,@cFilD1D2)}
				Eval(bFilBrw)
			Endif
       	endif
	Endif
	If nTipoOper <> Nil
		nRotina := aScan(aRotina, {|x| x[4] == nTipoOper})
		If nRotina > 0
			// executa qualquer rotina
			&(aRotina[nRotina][2])
		EndIf
	Else
		cPE := LOCXPE(61)	//³PE para adicionar campos no browse ³
        If !Empty(cPE)
			aRetPE:= ExecBlock(cPE,.F.,.F.,{IIF(ValType(cFuncName)=="C",cFunName,""),nOpcAuto,nTipo,aCfgNF[SAliasHead],aCfgNF[SaCposBr]})
			If ValType(aRetPE) == "A"
				aCfgNF[SaCposBr]  := aClone(aRetPE)
			EndIf
        EndIf
        // Consulta Padrao
        If FunName()=="MATA465N"
	    	aTrocaF3:= AltConPad("F1_FORNECE","SA1")
        EndIf
        If FunName()=="MATA466N"
	        aTrocaF3:= AltConPad("F2_CLIENTE","SA2")
	  	EndIf
	  	If cFunName $ "MATA101N/MATA465N|MATA466N" .and. cPaisLoc == "ARG" .or. !EMPTY(cLocxNFPV)  .or. (!lFilPV .and. cPaisLoc == "ARG") .Or. (cPaisLoc == "RUS" .And. cFunName $ "MATA466N/MATA467N")
			oObj := FwMBrowse():New()
			oObj:SetDescription(aCfgNF[ScDescGer])
			If PrefixoCpo(aCfgNF[SAliasHead]) == "F1"
				oObj:SetAlias("SF1")
			Else
				oObj:SetAlias("SF2")
			EndiF
			For nXy:=1 To Len(aCores)
				oObj:addLegend(aCores[nXy][1],aCores[nXy][2])
			Next nXy
			If PrefixoCpo(aCfgNF[SAliasHead]) == "F1"
				if Empty(cLocxNFPV)
					oObj:addFilter("Filtro Padron","SF1->"+cFilD1D2,.T.,.T.,,.T.)
				Else
					oObj:addFilter("Filtro Padron","SF1->("+cFilD1D2+") ",.T.,.T.,,.T.)
				EndIf
			Else
				if Empty(cLocxNFPV)
					oObj:addFilter("Filtro Padron","SF2->"+cFilD1D2,.T.,.T.,,.T.)
				Else
					oObj:addFilter("Filtro Padron","SF2->("+cFilD1D2+") ",.T.,.T.,,.T.)
				EndIf
			EndiF
			oObj:SetIniWindow({||FilBrowIni(aCfgNF[SAliasHead],aCfgNF[ScCliFor])})
			oObj:Activate()
	  	Else
	  	    If cFunName $ "MATA101N/MATA102N/MATA465N/MATA462N/MATA462DN/MATA467N/MATA466N/MATA102DN"
	  	    	mBrowse(6,1,22,75,aCfgNF[SAliasHead],aCfgNF[SaCposBr],,,,,aCores,,,,,,,,cFilSQL)
	  	    Else
	  	    	mBrowse(6,1,22,75,aCfgNF[SAliasHead],aCfgNF[SaCposBr],,,,,aCores)
	  		EndIf
		EndIf
	Endif
	If lFiLD1D2
		If cPaisLoc <> "ARG" .AND. !cFunName$"MATA103CG/MATA103CF/MATA462G/MATA101N/MATA102N/MATA465N/MATA462N/MATA462DN"
			EndFilBrw(aCfgNF[SAliasHead],@aIndD1D2)
		EndIf
	Endif
Endif
SetKey(VK_F12	,{|| Nil })
Return .T.
/*/{Protheus.doc} FilBrowIni
	Función que cambia los titulos de las columnas de los campos del Browse
	@type  Function
	@author eduardo.manriquez
	@since 10/09/2025
	@version 1.0
	@param cAliasSF, caracter, Alias de la tabla SF2/SF1
	@param cAliasSA, caracter, Alias de la tabla SA2/SA1
	@return
	@example
	FilBrowIni(cAliasSF,cAliasSA)
	@see (links_or_references)
	/*/
Function FilBrowIni(cAliasSF,cAliasSA)
	Local nPos      := 0
	Local cTitle    := ""
	Default cAliasSF := ""
	Default cAliasSA := ""

	If (cAliasSA == "SA2") .AND. (cAliasSF == "SF2")
		nPos := AsCan(oObj:aColumns,{|x| x:CREADVAR == "F2_CLIENTE"})
		cTitle := Alltrim(FwX3Titulo("F1_FORNECE"))
	ElseIf (cAliasSA == "SA1") .AND. (cAliasSF == "SF1")
		nPos := AsCan(oObj:aColumns,{|x| x:CREADVAR == "F1_FORNECE"})
		cTitle := Alltrim(FwX3Titulo("F2_CLIENTE"))
	Endif

	if nPos > 0
		oObj:GetColumn(nPos):SetTitle(cTitle)
		oObj:UpdateBrowse()
	Endif
Return
/*³ ³LocxDlgNF  Monta a Dialog para as Notas Fiscais                          ³
Parametros
a__CfgNf - Array com todas as configuracoes da NF, conteudo na declaracao da variavel,
 __nOpcx - Opcao do arotina
	(2)	- Visualizar
	(3)	- Incluir
	(4)	- Excluir */
Function LocxDlgNF(a__CfgNf,__nOpcx,bFilBrowse)
//Local aAreaF1 		:= {}
Local cHawb			:= ""
Local lOutrasNF		:= .F.
Local nX 			:= 0			//Flag para Loop's
Local aArea			:= { Alias() , IndexOrd() , RecNo() } //Area da entrada da rotina
Local aCposNF		:=	{}			//Campos do cabecalho da NF, que serao utilizados
Local aObjsNF		:=	{}			//Array contendo os objetos que devem ser criados na tela com seus devidos comando de criacao
Local aUsObjNF      := {}
Local cFunOk        := NIL
Local cLinOk        := NIL
Local nOpca			:=	aRotina[__nOpcx][4]
Local aCposRodape	:=	{}			//Array com dados e configuracoes do Rodape
Local aMoedas 		:= 	{}			//Array com as moedas em uso
Local cVld 			:= ""			//String coma validacao de campos do SX3 mais as validacoes manuais
//Local cValBrut   	:= ""
Local cCont      	:= ""
Local cAliasGrid 	:= ""
Local cWhileGrid 	:= ""
Local cSeekGrid  	:= ""
Local cSerSXBa      := "01"
Local cSerSXB       := "01"
Local nIndGrid   	:= 1
Local cCondIf    	:= NIL
Local aParCols   	:= {}
Local aOpcTeclas  	:= {}
Local aUsButtons 	:= {}
Local cOnInit     	:= ""
Local nItens     		:= GetMV("MV_NUMITEN")
//Local nAuxItens  	:= 0
//Local aTiposNF    	:= NIL
Local cFieldOk    	:= "NFFldOk()"
Local bSavF12		:=	SetKey(VK_F12)
Local cFunCanc
Local aBotoes		:= {}
//Local aTeclas		:= {}
Local aCposExt  	:= NIL
Local nPos			:=	0
Local aEspecies		:= {{'SF2 /SF2N/SF2B','MATA467N/MATA462N'},;
							 {'SF2C/SF1D','MATA465N'},;
							 {'SF1C'	 ,'MATA466N/MATA101N'},;
							 {'SF2D'	 ,'MATA466N'},;
							 {'SF1 /SF1N/SF1B','MATA101N/MATA102N/MATA463N'}}
Local aSizeAut		:= MsAdvSize(,.F.,200)
Local aObjects		:= {}
Local aInfo		 	:= { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 }
Local aPosObj	    :=	{}
Local aCoordGD   	:= {060,002,130,317}	//Array com as coordenadas da GetDados
Local aCordW    	:= Nil
Local aPosFold		:=	{132,002,315,074}
Local lRetOrigem    := .T.
Local lSeqEspecie   := SuperGetMV("MV_SEQESPE",,.F.)
Local aOrdItem		:= {}
Local xRet
Local dDatRet       := MVUlmes()
Local cMsgCFD       := ""
Local lContrFol     :=	.F.
//Local cAliasAtual   := ""
//Local nRecnoAtual   := 0
// Passagens aereas - Bolivia
//Local cMsgPTG   := ""
//Local cAliasCab := ""
//Local cAliasIte := ""
Local aCposPE	:={}
Local cFilSF1	:= xFilial("SF1")
Local cFilSF2	:= xFilial("SF2")
Local lEditImp  := GetNewPar( "MV_EDITIMP", .F. )
Local cDescSai	:= GetNewPar('MV_DESCSAI','1')
Local dDataBloq	:= GetNewPar("MV_ATFBLQM",CTOD("")) //Data de Bloqueio da Movimentação - MV_ATFBLQM
Local lRet			:= .T.
Local dDataRef	:= CTOD("  /  /  ")
//Local cSFx := "", cSFT := ""
Local cTabla := ""
Local cNtabla:=""
Local nTamPSE5   := TamSX3('E5_PARCELA')[1]
//Local nTamTSE5   := TamSX3('E5_TIPO')[1]
Local aBkpCfgInc := {}
Local lBkpCfgInc := .F.
Local lEstruc	:= .T.
Local oCampos
Local nPosCurren := 0
Local lConsTrack	:= (!(cPaisLoc$"BRA|RUS") .And. (IsInCallStack("MaPrepView") .Or. IsInCallStack("MaComView")) .And. Type("cCadastro") <> "U" .And. !Empty(cCadastro))
Local cMoneda := ""
Local cVersion := GetRpoRelease()
Local lfDocAFIP := FindFunction("fDocAFIP")

//Variaveis para identificação do cliente Equ
Private cNomeCli  := ""
Private cDoctoId  := ""
Private cFunName	:= IIf(Type("cFunName")=="U" .Or. Empty(cFunName) .Or. cFunName==NIL,Upper(Alltrim(ProcName())),cFunName)
Private lInclui   	:= (nOpca==3)
Private lDeleta   	:= (nOpca==5)
Private lVisualiza  := (nOpca==2)
Private aHGastos	:= {}	//utilizados pela locxgastos
Private aCGastos	:= {}	//inclusao das despesas na nota de frete
Private aGeraCFD	:= {}
Private _nTotOper_  := 0	//contem o total de operacoes efetuadas com um cliente/fornecedor em um determinado periodo
Private _aValItem_  := 0	//contem os valores unitarios dos itens da fatura
Private aRecnoSE1 	:= {}	// Array com os Titulos de Adiantamento recebidos do financeiro para a Nota Atual.
Private lLeSDE		:= .T.
Private aImp1 := {}
Private lSerie2 := (((SF2->(FieldPos("F2_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (a__CfgNf[ScEspecie]$"NCE|NCP")) .or. (cPaisLoc == "COL" .and. aCfgNf[SAliasHead] == "SF2" ) ); // Determina o uso do campo F2_SERIE2 para o Peru
						.Or. ((SF1->(FieldPos("F1_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (Trim(a__CfgNf[ScEspecie])$"NF|NDP|NDE") .And. !a__CfgNf[SlFormProp])
Private aOPBenef	:= ""
Private lSerOri := .F.
Private aItemsPCO	:= {}
If cPaisLoc == "RUS"
	Private aRelAdv := {}
EndIf
If Type('lDocSp') == "U"
	Private lDocSp := .F.
EndIf
If Type('lAutoFact') == "U"
	Private lAutoFact := .F.
EndIf
oModelAct := Nil
lBkpCfgInc := (cPaisLoc$"MEX" .And. !lInclui .And. !Empty(aCfgNf))
aBkpCfgInc := IIf(lBkpCfgInc,aClone(aCfgNf),{})
If cPaisLoc $ "MEX|PER|COL|EQU" .And. SuperGetMV("MV_PCOINTE",.F., "2") == "1"
	If Len(aCfgNf[SaLancPCO]) > 0
		PcoIniLan(aCfgNf[SaLancPCO][1]) //Inicia lanzamiento de PCO
	EndIf
Endif
If cPaisLoc == "MEX" .And. (AllTrim(FunName()) $ "MATA101N|MATA102N")
	nMoedaNF := 1
Endif
If cPaisLoc $ "ARG|CHI|BOL|PAR|URU" .And. (AllTrim(FunName()) $ "MATA101N|MATA102N|MATA102DN")
	LocxAtuMoeda(,,.t.)
Endif
If cPaisloc $ "PER|COL"
	lSerOri := ((a__CfgNf[ScEspecie]$"NCE|NCP"); // Determina o uso do campo F2_SERORI para o Peru
						.Or. ((Trim(a__CfgNf[ScEspecie]))$"NF|NDP|NDE|RCN") .And. !a__CfgNf[SlFormProp])
EndIf
If (cPaisLoc == "RUS")
	If (( __nOpcX == 5 ) .Or. ( __nOpcX == 6 )) ;
		.And. (&(aCfgNf[SAliasHead] + "->" + PrefixoCpo(aCfgNf[SAliasHead])+"_STATUSR") == "2")
		Help("",1,"LocxDlgNF",,STR0383,1,0)	// "Delete VAT Invoice linked to this record first."
		Return .F.
	EndIf
EndIf
If Type("lAtuFor") == "U"
	lAtuFor := .F.
EndIf
If !IsMemVar("cEspecie")
	Private &("cEspecie") := ""
EndIf
If __nOpcx == 3 .And. dDatRet>=dDataBase
	Help( " ", 1, "FECHTO" )
	Return(.F.)
EndIf
If (cPaisLoc == "ARG" .And. (cFunName == "MATA465N" .Or. cFunName == "MATA466N"))
	aDocOrig := {}
EndIf

// Controle de Folios - Bolivia
If cPaisLoc == "DOM" // Republica Dominicana
	lContrFol := GetNewPar("MV_CTRLFOL",.T.)
	If (!lContrFol) .AND. __nOpcx == 3
		MsgAlert(STR0285) //"Atencao o parametro MV_CTRLFOL para Controle de Folios esta desativado!"
	EndIf
ElseIf cPaisLoc <> "ARG"
	lContrFol     := cPaisLoc $ "BOL|URU" .And. AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720" ;
	                 .And. GetNewPar("MV_CTRLFOL",.F.)
Else
	lContrFol := AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720|MATA462AN" .And. GetNewPar("MV_CTRLFOL",.F.)
EndIf
If Type("lIntegracao")!= "L"
	lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)
Endif
If Type("lEICFinanc")!= "L"
	lEICFinanc	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
Endif
If Type("lFacImport")!= "L"
	lFacImport	:=	.F.
Endif
Private l103Class 	:= (lIntegracao .AND. nOpca==4 )

If !lInclui

	aCfgNF := MontaCfgNf(Val(&(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead]) + "_TIPODOC")) ,aCfgNF[SaPergs],.T.)

	NFSetPrv(aCfgNF)
Endif
//³Redimensionar objetos quando a definicao eh maior o igual a 800x600³
If Type("oMainWnd")!= "U" .And. oMainWnd:nClientWidth >= 800
	AAdd( aObjects, { 0,   100, .T., .F. } )
	AAdd( aObjects, { 100, 100, .T., .T. } )
	AAdd( aObjects, { 0,    75, .T., .F. } )
	aPosObj 	:= MsObjSize( aInfo, aObjects )
	aCordW    	:= {aSizeAut[7],0,aSizeAut[6],aSizeAut[5]}
	aCoordGD	:= {aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4]+3} //Array com as coordenadas da GetDados
	aPosFold	:=	{aPosObj[3,1],aPosObj[3,2],315,074}
Endif
//³Parametro que analisa condicao para alteracao da serie da nota.³
If cPaisLoc $ "ARG|MEX"
	Private lAltSerie 	:= If(cPaisLoc == "ARG",SuperGetMV("MV_ALTSER",,.T.),SuperGetMV("MV_ALTTSR",,.T.))
	Private lFuncAtual	:= AllTrim(FunName()) $ If(cPaisLoc == "ARG","MATA101N|MATA465N|MATA466N|MATA467N","MATA462TN")
EndIf
SetKey(VK_F12,{|| Nil })
lLocxAuto  := IIf(Type("lLocxAuto") != "U",lLocxAuto,.F.)
cP1:=PrefixoCpo(aCfgNf[ScCliFor])   + "_"
cP2:=PrefixoCpo(aCfgNf[ScAliasFin]) + "_"
cP3:=PrefixoCpo(aCfgNf[SAliasHead]) + "_"
cP4:=PrefixoCpo(aCfgNf[SAliasCols]) + "_"

Private aCposNo		:=	{}
Private aCpos		:=	{}
Private aRecSE2     := {}
Private aRecSE1     := {}
Private aRecsSF1 := IIf(Type("lLocxAuto") != "U" .And. lLocxAuto, iif(Type("aRecsSF1") = "U",{},aRecsSF1),{})
Private aAmarrAFN   := {}
Private aCols     	:= {}
Private aHeader   	:= {}
Private aRatCC    	:= {}
If (cPaisLoc <> "RUS" .Or. Type("cCadastro") == "U" .Or. Empty(cCadastro))
	Private cCadastro 	:= IIf(lConsTrack, cCadastro, FunDesc())
EndIf
If cPaisLoc=="RUS"
	Private dMemoryDate as Date //this variable need to get last date which was selected by user and put it into memory
	Private nMoedaCor := IIf(Type("nMoedaCor")=="U",1,nMoedaCor)
else
	Private nMoedaCor	:= 1
EndIf
Private aHeadSEV    := {}
Private aColsSEV    := {}
Private lContSEV    := iif(cPaisLoc <> "BRA" ,.T.,.F.)
Private lReajuste	:= .T.
Private lConsLoja	:= .T.
Private lCarteira	:= .T.
Private cA100For 	:= ""
Private cLoja    	:= ""
Private dDEmissao	:= dDatabase
Private aCposTela 	:= Array(3) // 1- Campos  2- Conteudo 3-Flag que indica se deve ser totalizado. Neste caso, entende-se que na pos. 2, existe o campo (ou formula) a serem totalizados.
Private aRatAFN 	:= {} //Int.c/PMS
Private aHdrAFN 	:= {} //Int.c/PMS (Cab. da aRatAFN)
Private aRatAFS 	:= {} //Int.c/PMS
Private aHdrAFS 	:= {} //Int.c/PMS (Cab. da aRatAFN)
Private nTaxa		:= 1
Private aLivro		:= {}
Private aDescontos	:= {}
Private aImpVarSD2	:= {0,0,0,0,0,{},""}
Private aImpVarDup	:= {}
Private aGetBook	:= {}
Private cA467Cli  	:= ""
Private cNitCC		:= ""
Private lRatValor 	:= .F.
Private nTotPeso  	:= 0
Private nBsFrete1 	:= 0
Private nValNeg   	:= 0
Private nTotMerc  	:= 0
Private nTotServ  	:= 0
Private nValDesp  	:= 0
Private nSeguro   	:= 0
Private nValFrete 	:= 0
Private nValDesc  	:= 0
Private aImpS     	:= {}
Private cVenda    	:= "NORMAL"
Private cNFiscal  	:= ""
Private cSerie    	:= ""
Private l103Visual	:= !lInclui .AND. !l103Class
Private aRecSF3	  	:= {}
Private cTipo       := ""
Private aRecnos		:=	{}
Private cTipoRet    := AllTrim(Str(GetMv('MV_TIPORET')))
Private lLibImp     := GetNewPar("MV_LIBIMP","S") == "S"	// Utiliza liberacao de NF import.
Private lBloqImp    := .F.
Private lUsaCor		:= .F.
Private lCFiscal    := .F.
Private	nValNTrib	:=	0
Private	nValTara	:=	0
Private aImp		:= {}
Private cHead       := ""
Private cHeadun     := ""
Private lMetImpEdi	:=.F. // usada edicion de impuestos (FISA081 FISA0084)

IF cPaisLoc == 'RUS' .And. Type("aAutoCab") != "U"
	//³Feedeing nMOedacor
	nPosCurren:= Ascan(aAutoCab,{|x| x[1] == "F1_MOEDA" .OR. X[1] == "F2_MOEDA"})
	If nPosCurren > 0
		nMoedaCor := aAutoCab[nPosCurren,2]
	EndIf
EndIf

If nOpca==5 .And. cPaisloc=="ARG" .And. (ALLTRIM(a__CfgNf[8])=="NDC".Or. ALLTRIM(a__CfgNf[8])=="NCC" )
cTabla:= a__CfgNf[4]
cNtabla:= RIGHT(cTabla,1)
	If  funname() <> "FINA935" .And.    SEL->(ColumnPos("EL_TIPAGR")) >0	.and. SEL->(ColumnPos("EL_DOCPOS"))>0 .and. &(cTabla)->(ColumnPos("F"+cNtabla+"_RECPOS")) >0  .and.  &(cTabla)->(ColumnPos("F"+cNtabla+"_IVAPOS")) >0 .and. SE1->(ColumnPos("E1_RECGR")) >0
		If !Empty(&(cTabla+"->F"+cNtabla+"_RECPOS")) .And. !Empty(&(cTabla+"->F"+cNtabla+"_IVAPOS"))
			MsgAlert(STR0419,STR0418)
			Return .F.
		EndIF
	EndIf
EndIf
If  nOpca==5 .And. cPaisloc=="ARG" .And. Alltrim(Funname()) == "MATA101N" .And. ALLTRIM(a__CfgNf[8])=="NF" .And. a__CfgNf[4] == "SF1"
	DbSelectArea("SE5")
	SE5->(DbSetOrder(7))
	If SE5->(MsSeek(xFilial("SE5")+ SF1->F1_SERIE + SF1->F1_DOC + SPACE(nTamPSE5))) //E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
		While !SE5->(Eof()) .And. (AllTrim(SE5->E5_CLIFOR) == AllTrim(SF1->F1_FORNECE) .And. AllTrim(SE5->E5_LOJA) == AllTrim(SF1->F1_LOJA))
		If  Alltrim(SE5->E5_ORIGEM) == "FINA100" .And. Alltrim(SF1->F1_DOC) == Alltrim(SE5->E5_NUMERO) .And. Alltrim(SF1->F1_SERIE) == Alltrim(SE5->E5_PREFIXO)
			Aviso(STR0018,OemToAnsi( STR0134 ),{STR0021})
			Return .F.
		EndIf
			DBSkip()
		EndDo
	EndIf
Endif
If ( Type("cFunName") == "C" ) .AND. ( cFunName == "MATA467N")
	Static cMTabPrc := "" // Var.p/validacao da tab.preco
Endif
If GetMv("MV_REMMAN")=="N" .AND. aCfgNF[SnTipo] == 50
	Aviso( STR0018,OemToAnsi( STR0118 ) + DESCREM + OemToAnsi( STR0119) + Chr(10) + Chr(13) + OemToAnsi(STR0120  ) ,{STR0021}) //"ATENCAO"###"Para incluir "###" manualmente inicialize o parametro MV_REMMAN com 'S' "###" ou Use Geracao Automatica" ###"OK"
	Return .F.
Endif
//Verifica se existe bloqueio contábil
If !(Empty(SF1->F1_EMISSAO)) .And. a__CfgNf[4] <> "SF2"
	dDataRef := SF1->F1_EMISSAO
ElseIf !(Empty(SF2->F2_EMISSAO)) .And. a__CfgNf[4] == "SF2"
	dDataRef := SF2->F2_EMISSAO
EndIf
If cPaisLoc == "ARG" .and. (Type("CRELEASERP") == "C" .and. Val(Substr(CRELEASERP,6,3)) < 23)
	UpdValImp()
EndIf
If lDeleta .And. cPaisLoc == "CHI" .AND.(IIf(a__CfgNf[4]== "SF1",SF1->(ColumnPos('F1_FLFTEX'))>0 .And. SF1->F1_FLFTEX == "6",SF2->(ColumnPos('F2_FLFTEX '))>0 .And. SF2->F2_FLFTEX == "6"))
	Alert(STR0402) // Nota fiscal autorizadas nao pode ser excluida
	Return .F.
ElseIf !(Empty(dDataRef)) .And. lDeleta
	If lRet := (CtbValiDt(Nil,dDataRef,/*.T.*/ ,Nil ,Nil ,{"COM001"}/*,"Data de apuração bloqueada pelo calendário contábil."*/))
		If (!Empty(dDataBloq) .AND. (dDataRef <= dDataBloq))
			Help(" ",1,"ATFCTBBLQ") //P: Processo bloqueado pelo Calendário Contábil ou parâmetro de bloqueio nesta data ou período. S: Caso possível altere a data de referência do processo, verifique o parâmetro ou contate o responsável pelo Módulo Contábil.)
			Return .F.
		EndIf
	End
	If !lRet
		Return .F.
	EndIf
EndIf
If lRet .And. lDeleta .And. cPaisLoc == "ARG" .AND. IIf(a__CfgNf[4]== "SF1",SF1->(ColumnPos("F1_CC"))>0 .And. !Empty(SF1->F1_CC),SF2->(ColumnPos('F2_CC '))>0 .And. !Empty(SF2->F2_CC))
	IF a__CfgNf[4] =="SF1"   .AND.  !MVerifCC(a__CfgNf[4],SF1->F1_ESPECIE,SF1->F1_SERIE,SF1->F1_DOC,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_CC)
		Return .F.
	ElseIF a__CfgNf[4] =="SF2"  .and.  !MVerifCC(a__CfgNf[4],SF2->F2_ESPECIE,SF2->F2_SERIE,SF2->F2_DOC,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_CC)
		Return .F.
	EndIf
EndIf
//Limpa Filtro criado pela função FilBrowse
SF1->(dbClearFilter())
If nOpca <> 3
	If	!(&(aCfgNF[SAliasHead] +'->'+ cP3+"TIPODOC") $ aCfgNF[ScFilRot])
		If nOpca == 5
			Help(" ",1,"LOCXNF0001",,&(aCfgNF[SAliasHead]+'->'+cP3+"ESPECIE")+"--->"+aEspecies[Ascan(aEspecies,{|x| aCfgNF[SAliasHead]+&(aCfgNF[SAliasHead]+'->'+cP3+"TIPO")$x[1]})][2],3,1)
		Else
			Help(" ",1,"LOCXNF0002",,&(aCfgNF[SAliasHead]+'->'+cP3+"ESPECIE")+"--->"+aEspecies[Ascan(aEspecies,{|x| aCfgNF[SAliasHead]+&(aCfgNF[SAliasHead]+'->'+cP3+"TIPO")$x[1]})][2],3,1)
		Endif
		Return .F.
	Endif
	lFacImport:= (aCfgNf[SAliasHead]=="SF1") .AND. AllTrim(SF1->F1_TIPO_NF) $ "123456789AB"
	If lIntegracao .AND. !lFacImport .AND. l103Class
		Aviso(STR0018,OemToAnsi(STR0158),{STR0021})
		Return .F.
	EndIf
	If lIntegracao .AND. (aCfgNF[SnTipo]==10 .OR. aCfgNF[SnTipo]==13 .OR. aCfgNF[SnTipo]==60) .AND. lFacImport
		SD1->(MsSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
		If Empty(SD1->D1_TES)
			If nOpca == 5			//Nao permitir desclassificar notas de import. ainda nao classificadas.
				Aviso(STR0201,STR0149+" "+Alltrim(SF1->F1_DOC)+" "+STR0150,{STR0021})
				Return .F.
			ElseIf nOpca == 4 .AND. SD1->D1_EMISSAO>dDataBase
				Help("",1,"A100DATAM")
				Return .F.
			Endif
		Else
			If nOpca == 4 //Nao permitir classificar notas de import. ja classificadas.
				Help("",1,"NFCLAS")
				Return .F.
			ElseIf nOpca == 5
				If GetNewPar("MV_CUSTIMP","1") <> "1" .And. SF1->F1_TIPO_NF $ "58"  //Para ambientes com atualizacao de custos / estoque atraves de remito,
					aAreaSF1 := SF1->(GetArea())	//nao permitir desclassificar nota FOB(ou CIF) se existirem notas de outros tipos
					DbSetOrder(5)
					cHawb := SF1->F1_HAWB
					SF1->(dbSeek(cFilSF1+cHawb+"6",.T.))
					lOutrasNF:=.F.
					While !Eof() .AND. SF1->F1_FILIAL == cFilSF1 .AND. ;
						SF1->F1_HAWB == cHawb .AND. !lOutrasNF
						If SF1->F1_TIPO_NF $ "679A"
							lOutrasNF := .T.
						EndIf
						DbSkip()
					End
					RestArea(aAreaSF1)
					If lOutrasNF
						Aviso(STR0018,STR0192,{STR0021})
						Return .F.
					EndIf
				Endif
			Endif
		Endif
		//Se Processo de Importação ja estiver encerrado não permitir movtos.
		DbSelectArea("SW6")
		DbSetOrder(1)
		If nOpca <> 2
			If MsSeek(xFilial("SW6")+SF1->F1_HAWB)
				If !Empty(SW6->W6_DT_ENCE)
					Aviso(STR0018,STR0192,{STR0021})	// "Proceso encerrado!"
					Return .F.
				EndIf
			EndIf
		Endif
	EndIf
    If cPaisLoc == "GUA" .AND. lDeleta .AND. aCfgNf[ScCliFor] == "SA1"
       If !lAnulaSF3
          Aviso(STR0097,STR0226+chr(13)+STR0227,{STR0235})
          Return .F.
       Else
          If aCfgNF[SAliasHead] == "SF2"
             SD2->(DbSetOrder(3))
		     SD2->(MsSeek(xFilial("SD2")+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA))
		     lRetOrigem  := SD2->D2_ORIGLAN != "LO"
          EndIf
          If !lRetOrigem
             Aviso(STR0097,STR0231,{STR0235})
             Return .F.
          EndIf
       EndIf
    EndIf
Else
	If !FisChkDt(dDatabase)
		Return
	Endif
EndIf
If cpaisLoc=="ARG" .And. lfDocAFIP
	If !fDocAFIP(aCfgNf, lDeleta)
		Return .F.
	EndIf
EndIf
If cPaisLoc <> "BRA" .AND. lLibImp .AND. lFacImport .AND. l103Class
	If SF1->F1_TIPO_NF == "5"
		lBloqImp	:=	.T.
	Endif
Endif
Private aBKPCfgNF		:=	AClone(a__CfgNf)
If Type("aPE") <> "A"
	Private aPE	    := Array(SnMaxPE,2)
Endif
If Type("nMoedaNf")!= "N"
	nMoedaNf := 1
EndIf
aCfgNf 		:= AClone(a__CfgNf)
If Type("bFunAuto")!="B"
	bFunAuto := {|| NIL }
EndIf
For nX	:=	1 To MoedFin()
	cMoneda := SuperGetMV("MV_MOEDA" + Alltrim(STR(nX)))
	If !Empty(cMoneda)
		AAdd(aMoedas, Alltrim(STR(nX)) +"="+ cMoneda)
	Else
		Exit
	Endif
Next
cPe	:=	LocxPE(1)
If !Empty(cPE)
	If ValType(aUsButtons := ExecBlock(cPe, .F., .F.) ) == "A"
		AEval( aUsButtons, { |x| AAdd( aCfgNf[SaBotoes], x ) } )
	EndIf
EndIf
cPe	:=	LocxPE(2)
If !Empty(cPe)
	xRet  := Execblock(cPE,.F.,.F.,nOpca)
	If ValType(xRet) == "L"
	   If !xRet
	      Return .F.
	   EndIf
	EndIf
EndIf
cPe	:=	LocxPE(3)
If !Empty(cPE)
	__cExpF4 := ExecBlock(cPE,.F.,.F.)
EndIf
bDoRefresh  := {|| NIL }
bRefresh    := {|| Iif(Type("bDoRefresh") <> "B",{|| Nil},Eval(bDoRefresh))}
bListRefresh:= {|| (MaFisToCols(aHeader,aCols,,"MT100")),Iif(!lLocxAuto,(oLstSF3:Refresh(),oLstImp:Refresh()),Nil)}
bGDRefresh  := {|| NIL}
cTipo := aCfgNF[ScTipoDoc]
If Type("lGerarCFD") != "L"
	lGerarCFD := .F.
	aGerarCFD := {}
	If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
		aGerarCFD := CFDVerific()
		If aGerarCFD[1] <> "0"
			If Empty(aGerarCFD[2])
				lGerarCFD := .T.
			Else
	    		If !Empty(aGerarCFD[2]) .AND. !lLocxAuto
					cMsgCFD := ""
					For nX := 1 To Len(aGerarCFD[2])
						cMsgCFD += aGerarCFD[2][nX][2] + CRLF
					Next
					MsgAlert(cMsgCFD,STR0248)
				Endif
			Endif
		Else
			lGerarCFD := .F.
		Endif
	Endif
Endif
//Utilizacao do numero correlativo de compras
lUsaCor:=.F.
lUsaCor:=CORR_USO()
lUsaCor:=lUsaCor .AND. Strzero(aCfgNF[SnTipo],2)$"07|09|10|12|13|14|22|23"  //ncp|ndp|nf|benef|import|frete|Nota Ajuste NCP|Nota Ajuste NDP
cSerSXBa  := IIf(aCfgNf[ScEspecie]$"NCC|NCI","CHB",IIf(aCfgNf[ScEspecie]$"NDC|NDI","CHD",Iif(Substr(aCfgNf[ScEspecie],1,2)=="RF","CHE","01")))
cSerSXB   := IIf(lSeqEspecie,IIf(AllTrim(aCfgNf[ScEspecie])=="NF","CHA",cSerSXBa),"01")
DbSelectArea("SX3")
DbSetOrder(2)
If  (cPaisLoc == "ARG") .And. aCfgNf[SlFormProp] .And. ( cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA462N|MATA462DN|MATA462R|MATA462TN|MATA102DN|OMSA320") .And. lFolios // Leandro Prado - 21/02/2014 - Controle de Ponto de Venda.
	If ExistBlock("DESAPV")
		cLocxNFPV :=Execblock("DESAPV",.F.,.F.,)
		cIdPVArg := POSICIONE("CFH",1, xFilial("CFH")+cLocxNFPV,"CFH_IDPV")
	EndIf
EndIf
	lEstruc := FindFunction("InputFields") .and. FindFunction("OutputFields")
Do Case
	Case !lEstruc
		Help("",1,"LOCXNF",,STR0430 + "LOCXNF",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
		Return .F.
	Case aCfgNf[SAliasHead]=="SF1" .and. lEstruc
		oCampos := InputFields(cPaisLoc,.T., .F., .F., lInclui, .F., .F., aCfgNF[ScEspecie])

		IIf(Type("cLocxNFPV") != "C", cLocxNFPV := "", )
		IIf(Type("lLocxAuto") != "L", lLocxAuto := .F., )
		IIf(Type("lGerarCFD") != "L", lGerarCFD := .F., )
		IIf(Type("lAutoFact") != "L", lAutoFact := .F., )
		IIf(Type("lSerie2") != "L", lSerie2 := .F., )
		IIf(Type("lDocSp") != "L", lDocSp := .F., )

		aCposNF := Aclone(oCampos:GetStructure(l103Class, l103Visual, lLocxAuto, cLocxNFPV, lDocSp, lGerarCFD, lSerie2, lAutoFact, aCfgNf))

		If !(lInclui)
			cNFiscal	:=	SF1->F1_DOC
			cSerie		:=	SF1->F1_SERIE
			nTaxa		:=	SF1->F1_TXMOEDA
			nMoedaNF	:=	SF1->F1_MOEDA
		Endif
	Case aCfgNf[SAliasHead]=="SF2" .and. lEstruc
		oCampos := OutputFields(cPaisLoc,.T., .F., .F., lInclui, .F., .F., aCfgNF[ScEspecie])

		IIf(Type("cLocxNFPV") != "C", cLocxNFPV := "", )
		IIf(Type("lLocxAuto") != "L", lLocxAuto := .F., )
		IIf(Type("lGerarCFD") != "L", lGerarCFD := .F., )
		IIf(Type("lSerie2") != "L", lSerie2 := .F., )

		aCposNF := Aclone(oCampos:GetStructure(l103Class, l103Visual, lLocxAuto, cLocxNFPV, lGerarCFD, lSerie2, aCfgNf))

		If lInclui .AND. aCfgNf[SnTipo] == 54
			aCposExt := CposToHead({'D2_LOCDEST','D2_TESENT'})
			aSize(aCposExt[1],12)
			aSize(aCposExt[2],12)
			aCposExt[1][12] := 16  // Def.ord.campo
			aCposExt[2][12] := 10  // Def.ord.campo
			cVld := LocX3VALID('D2_TESENT')
			If !Empty(cVld)
				cVld := "(" + cVld + ") .AND. "
			EndIf
			cVld += "NFVldTES()"
			aCposExt[2][06] := cVld
		EndIf
		If !(lInclui)
			cNFiscal	:=	SF2->F2_DOC
			cSerie 		:=	SF2->F2_SERIE
			nTaxa		:=	SF2->F2_TXMOEDA
			nMoedaNF	:=	SF2->F2_MOEDA
		Endif

	OtherWise
		aCfgNF	:=	aClone(aBKPCfgNF)
		NFSetPrv(aCfgNF)
		SetKey(VK_F12,bSavF12)
		Return .F.
EndCase
cFldConf := IIF(LocxVlCon(lDeleta),",'"+ STR0352 + "'" ,"") //"Conferência Física"
aPosFold[3] := aSizeAut[3]
AAdd(aObjsNF,{"oFldRodape","TFolder():New("+Str(aPosFold[1])+","+Str(aPosFold[2])+",{'" + STR0026 + "','" + STR0027 + "','" + STR0028 + "','" + STR0029 + "','" + STR0030  + "','" + STR0031 + "'" + IIf(aCfgNF[SnTipo] == 10, ",'" + STR0130 + "'","") + cFldConf + "},{'HEADER'},,,,,.T.,.F.,"+Str(aPosFold[3])+","+Str(aPosFold[4])+",)",1}) //'Totais'###'Inf. Fornec./Cliente'###'Despesas'###'Duplicatas'###'Livros Fiscais'###'Impostos'###'Caixinha'###'Conferência Física'
AAdd(aObjsNF,{"aoSbx"     ,"Array(8)",1})
AAdd(aObjsNF,{"aoSbx[1]"  ,"TScrollBox():New(oFldRodape:aDialogs[1], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
AAdd(aObjsNF,{"Aux"       ,"aoSbx[1]:Disable()",1})
AAdd(aObjsNF,{"oBSomaItens","TotalQtd(aoSbx[1],{04,203,270,37})" ,1})//Browse de totalizacao
AAdd(aObjsNF,{"aoSbx[2]"  ,"TScrollBox():New(oFldRodape:aDialogs[2], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
AAdd(aObjsNF,{"aoSbx[3]"  ,"TScrollBox():New(oFldRodape:aDialogs[3], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
AAdd(aObjsNF,{"aoSbx[4]"  ,"TScrollBox():New(oFldRodape:aDialogs[4], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
AAdd(aObjsNF,{"aoSbx[5]"  ,"TScrollBox():New(oFldRodape:aDialogs[5], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
AAdd(aObjsNF,{"aoSbx[6]"  ,"TScrollBox():New(oFldRodape:aDialogs[6], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
If aCfgNF[SnTipo] == 10
	AAdd(aObjsNF,{"aoSbx[7]"  ,"TScrollBox():New(oFldRodape:aDialogs[7], 000,000,61,313,.T.,.T.,.F.)",1})
	If LocxVlCon(lDeleta)
		AAdd(aObjsNF,{"aoSbx[8]"  ,"TScrollBox():New(oFldRodape:aDialogs[8], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
	Endif
Else
	If LocxVlCon(lDeleta)
		AAdd(aObjsNF,{"aoSbx[7]"  ,"TScrollBox():New(oFldRodape:aDialogs[7], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
	Endif
EndIf
AAdd(aObjsNF,{"oLine1"	   ,"TGroup():New(43,4,44,"+Str(aPosFold[3]-16)+",'',aoSbx[1],,,.T.)",1})
AAdd(aObjsNF,{"oLine2"	   ,"TGroup():New(43,4,44,"+Str(aPosFold[3]-16)+",'',aoSbx[3],,,.T.)",1})

//³Aarray de configuracoes do Rodape³

	AAdd(aCposRodape,{,cP3+"DESPESA",,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_DESPESA')" ,),,,"aoSbx[1]",,,".F.",005,040})
	AAdd(aCposRodape,{,cP3+"DESCONT",,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_DESCONTO')",),,,"aoSbx[1]",,,".F.",005,140})
	AAdd(aCposRodape,{,cP3+"FRETE"  ,,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_FRETE')"   ,),,,"aoSbx[1]",,,".F.",018,040})
	AAdd(aCposRodape,{,cP3+"SEGURO" ,,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_SEGURO')"  ,),,,"aoSbx[1]",,,".F.",018,140})
	If cPaisLoc $ "MEX|PER|PAR"
		AAdd(aCposRodape,{,cP3+"VALADI"  ,,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_ADIANT')"   ,),,,"aoSbx[1]",,,".F.",031,040}) //Adiantamento
	EndIf
	If cPaisLoc == "ARG" .And. cTipo == "D" .And. GetNewPar('MV_DESCSAI','1') =='2' .And. ALLTRIM(SF1->F1_ESPECIE) $ "RFD"
		AAdd(aCposRodape,{,cP3+"VALMERC",,12,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_VALMERC')" ,IIf(cDescSai=='2' .And. aCfgNF[SAliasHead]=="SF1",IIF (INCLUI, "MaFisRet(,'NF_VALMERC')+MaFisRet(,'NF_DESCONTO')","SF1->F1_VALMERC + SF1->F1_DESCONT"), ) ),,,"aoSbx[1]",,,".F.",031,140})
	else
		AAdd(aCposRodape,{,cP3+"VALMERC",,12,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_VALMERC')" ,IIf(cDescSai=='2' .And. aCfgNF[SAliasHead]=="SF2",IIF (INCLUI, "MaFisRet(,'NF_VALMERC')+MaFisRet(,'NF_DESCONTO')","SF2->F2_VALMERC + SF2->F2_DESCONT"), ) ),,,"aoSbx[1]",,,".F.",031,140})
	EndIF
	If cPaisLoc == "CHI"
		AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. lVisualiza .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"Round(MaFisRet(,'NF_TOTAL'),"+"MsDecimais( IIf(Type('nMoedaNF')=='N',nMoedaNF,1) )"+")"   ,),,,"aoSbx[1]",,,".F.",047,140})
	ElseIf cPaisLoc == "ARG"
		AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. (aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_TOTAL')" ,),,,"aoSbx[1]",,,".F.",047,140})
	ElseIf cPaisLoc $ "MEX|COL|PER"
		If cFunName $ "MATA101N|MATA102N|MATA466N|MATA462DN|MATA465N"
			AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. lVisualiza .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),IIf((aCfgNf[SAliasHead] == "SF1" .And. aCfgNf[SAliasCols] == "SD1") .And. cDescSai=='1' .and. !(cFunName $ "MATA101N|MATA466N") .and. !(aCfgNf[ScEspecie]$"NCC|RFD")	, "MaFisRet(,'NF_TOTAL')+MaFisRet(,'NF_DESCONTO')", IIf(lVisualiza, "", "MaFisRet(,'NF_TOTAL')")),),,,"aoSbx[1]",,,".F.",047,140})
		Else
			AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. lVisualiza .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),IIf((aCfgNf[SAliasHead] == "SF1" .And. aCfgNf[SAliasCols] == "SD1") .And. cDescSai=='1' .and. !(aCfgNf[ScEspecie]$"NCC"), "MaFisRet(,'NF_TOTAL')+MaFisRet(,'NF_DESCONTO')", IIf(lVisualiza, "", "MaFisRet(,'NF_TOTAL')")),),,,"aoSbx[1]",,,".F.",047,140})
		EndIf
	ElseIf cPaisLoc $ "PAR|BOL|URU"
		AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. (aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_TOTAL')" ,),,,"aoSbx[1]",,,".F.",047,140})
	Else
		AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. lVisualiza .OR.(aCfgNF[SAliasHead] == "SF1" .AND. Empty(&(aCfgNF[SAliasHead] + "->" + cP3 + "STATUS"))), IIf((aCfgNf[SAliasHead] == "SF1" .And. aCfgNf[SAliasCols] == "SD1") .And. cDescSai == '1' .and. !(aCfgNf[ScEspecie] $ "NCC") .And. !(FunName() $ "MATA101N|MATA466N"), "MaFisRet(,'NF_TOTAL')+MaFisRet(,'NF_DESCONTO')", "MaFisRet(,'NF_TOTAL')"),),,,"aoSbx[1]",,,".F.",047,140})
	EndIf
	If cPaisLoc	== "RUS"
		AAdd(aCposRodape,{,cP3+"VLMERCM",,16,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_VALMERC_C1')" ,IIf(cDescSai=='2' .And. aCfgNF[SAliasHead]=="SF2",IIF (INCLUI, "MaFisRet(,'NF_VALMERC_C1')+MaFisRet(,'NF_DESCONTO')","SF2->F2_VALMERC_C1 + SF2->F2_DESCONT"), ) ),,,"aoSbx[1]",,,".F.",047,440})
		AAdd(aCposRodape,{,cP3+"BSIMP1M",,16,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_BASEIV1_C1')" ,),,,"aoSbx[1]",,,".F.",047,570})
		AAdd(aCposRodape,{,cP3+"VLIMP1M",,16,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_VALIV1_C1')" ,),,,"aoSbx[1]",,,".F.",047,700})
		AAdd(aCposRodape,{,cP3+"VLBRUTM",,16,,,,,,,IIf(lInclui .OR. l103Class .OR. (aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_TOTAL_C1')" ,),,,"aoSbx[1]",,,".F.",047,830})
	EndIf

SX3->(dbSetOrder(2))
SX3->(MsSeek(Right(aCfgNF[SAliasCols],2)+"_QUANT"))
AAdd(aCposRodape,{RetTitle("B1_QTDACUM"),"nTotQtIte",PesqPict("SD1","D1_QUANT"),SX3->X3_TAMANHO,SX3->X3_DECIMAL,,,SX3->X3_TIPO,SX3->X3_ARQUIVO,,,,,"aoSbx[1]",,,".F.",047,253,,,,{||0}}) //Get do total de itens
//³Inf.Fornec./Cliente ³
If cPaisLoc == "RUS"
	cCont := "Posicione('" + aCfgNf[ScCliFor] + "',1,xFilial('" + aCfgNf[ScCliFor] + "') + M->" + IIf(aCfgNf[SAliasHead]=="SF2","F2_CLIENTE","F1_FORNECE") + " + M->" + cP3 + "LOJA,'"
	AAdd(aCposRodape,{,cP1+"NREDUZ"   ,,59,,,,,,,cCont + cP1 + "NREDUZ')"  ,,,"aoSbx[2]",,,".F.",005,040})
	AAdd(aCposRodape,{,cP1+"TEL"    ,,14,,,,,,,cCont + cP1 + "TEL')"   ,,,"aoSbx[2]",,,".F.",031,040})
	AAdd(aCposRodape,{,cP1+"PRICOM" ,,07,,,,,,,cCont + cP1 + "PRICOM')",,,"aoSbx[2]",,,".F.",044,150})
	AAdd(aCposRodape,{,cP1+"ULTCOM" ,,07,,,,,,,cCont + cP1 + "ULTCOM')",,,"aoSbx[2]",,,".F.",044,263})
	AAdd(aCposRodape,{,cP1+"EST"    ,,10,,,,,,,cCont + cP1 + "EST')"   ,,,"aoSbx[2]",,,".F.",005,375})
	If aCfgNf[ScCliFor] == 'SA2' .Or. aCfgNf[ScCliFor] == 'SA1'
		If aCfgNf[ScCliFor] == 'SA2'
			AAdd(aCposRodape,{,cP1+"KPP"    ,,10,,,,,,,cCont + cP1 + "KPP')"   ,,,"aoSbx[2]",,,".F.",031,263})
			AAdd(aCposRodape,{STR0395,cP1+"HEAD"    ,,10,,,,,,,"RUXXTS01('HEAD',cP1)" ,,,"aoSbx[2]",,,".F.",018,375})
			AAdd(aCposRodape,{STR0396,cP1+"HEADUN"    ,,10,,,,,,,"RUXXTS01('HEADUN',cP1)" ,,,"aoSbx[2]",,,".F.",031,375})
		Else // SA1
			AAdd(aCposRodape,{,cP1+"INSCGAN"    ,,10,,,,,,,cCont + cP1 + "INSCGAN')"   ,,,"aoSbx[2]",,,".F.",031,263})
			AAdd(aCposRodape,{STR0395,"AI0_HEAD"    ,,10,,,,,,,"RUXXTS01('HEAD',cP1)" ,,,"aoSbx[2]",,,".F.",018,375})
			AAdd(aCposRodape,{STR0396,"AI0_HEADUN"    ,,10,,,,,,,"RUXXTS01('HEADUN',cP1)" ,,,"aoSbx[2]",,,".F.",031,375})
		EndIf
		AAdd(aCposRodape,{STR0392,"AGA_END"    ,,60,,,,,,,"RUXXTS03('2',cP1,aCfgNf[2])" ,,,"aoSbx[2]",,,".F.",005,470})
		AAdd(aCposRodape,{STR0393,"AGA_END"    ,,60,,,,,,,"RUXXTS03('0',cP1,aCfgNf[2])" ,,,"aoSbx[2]",,,".F.",018,470})
		AAdd(aCposRodape,{,cP1+"CODZON"    ,,14,,,,,,,cCont + cP1 + "CODZON')"   ,,,"aoSbx[2]",,,".F.",031,150})
		AAdd(aCposRodape,{STR0394,cP1+"NREDUZ"    ,,59,,,,,,,"RUXXTS02(cP1,aCfgNf[2])" ,,,"aoSbx[2]",,,".F.",018,040})
	Else
		AAdd(aCposRodape,{,cP1+"CGC"    ,,14,,,,,,,cCont + cP1 + "CGC')"   ,,,"aoSbx[2]",,,".F.",018,235})
		AAdd(aCposRodape,{,cP1+"END"    ,,31,,,,,,,cCont + cP1 + "END')"   ,,,"aoSbx[2]",,,".F.",031,235})
	EndIf
Else
	cCont := "Posicione('" + aCfgNf[ScCliFor] + "',1,xFilial('" + aCfgNf[ScCliFor] + "') + M->" + IIf(aCfgNf[SAliasHead]=="SF2","F2_CLIENTE","F1_FORNECE") + " + M->" + cP3 + "LOJA,'"
	AAdd(aCposRodape,{,cP1+"NOME"   ,,31,,,,,,,cCont + cP1 + "NOME')"  ,,,"aoSbx[2]",,,".F.",005,040})
	AAdd(aCposRodape,{,cP1+"TEL"    ,,14,,,,,,,cCont + cP1 + "TEL')"   ,,,"aoSbx[2]",,,".F.",005,235})
	AAdd(aCposRodape,{,cP1+"PRICOM" ,,07,,,,,,,cCont + cP1 + "PRICOM')",,,"aoSbx[2]",,,".F.",018,040})
	AAdd(aCposRodape,{,cP1+"ULTCOM" ,,07,,,,,,,cCont + cP1 + "ULTCOM')",,,"aoSbx[2]",,,".F.",018,136})
	AAdd(aCposRodape,{,cP1+"CGC"    ,,14,,,,,,,cCont + cP1 + "CGC')"   ,,,"aoSbx[2]",,,".F.",018,235})
	AAdd(aCposRodape,{,cP1+"END"    ,,31,,,,,,,cCont + cP1 + "END')"   ,,,"aoSbx[2]",,,".F.",031,040})
	AAdd(aCposRodape,{,cP1+"EST"    ,,10,,,,,,,cCont + cP1 + "EST')"   ,,,"aoSbx[2]",,,".F.",031,235})
EndIf
If aCfgNf[ScCliFor] ==	'SA1'
	AAdd(aObjsNF	 ,{"oBtnFin"	   ,"TButton():New(43,36,'"+STR0144+"',aoSbx[2],{|| LocxFc010() },48,12,,,,.T.,,,,{||!Empty("+aCfgNf[ScCliFor]+"->"+cP1+"NOME)} )",1})
Else
	AAdd(aObjsNF	 ,{"oBtnFin"	   ,"TButton():New(43,36,'"+STR0144+"',aoSbx[2],{|| A103TOFC030(IIf('"+cTipo+"'$'DB','S','E')) },48,12,,,,.T.,,,,{|| !Empty("+aCfgNf[ScCliFor]+"->"+cP1+"NOME)})",1})
Endif
//³Folder de Desp.Acessorias ³Permete os campos de Desp.Acessorias sejam preenchidos caso nao seja Fat.Frete ou Despesa

	AAdd(aCposRodape,{,cP3+"DESPESA",,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_DESPESA' ,M->"+cP3+"DESPESA)",,,,,IIf(lInclui,"MaFisRet(,'NF_DESPESA')",),,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),005,045,,,If(lInclui,&("{|| M->"+cP3+"DESPESA := MaFisRet(,'NF_DESPESA')}"),)})
	AAdd(aCposRodape,{,cP3+"DESCONT",,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_DESCONTO',M->"+cP3+"DESCONT)",,,,,IIf(lInclui,"MaFisRet(,'NF_DESCONTO')",),,,"aoSbx[3]",,,,005,200,,,If(lInclui,&("{|| M->"+cP3+"DESCONT := MaFisRet(,'NF_DESCONTO')}"),)})
	AAdd(aCposRodape,{,cP3+"FRETE"  ,,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_FRETE'   ,M->"+cP3+"FRETE)"  ,,,,,IIf(lInclui,"MaFisRet(,'NF_FRETE')"   ,),,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),018,045,,,If(lInclui,&("{|| M->"+cP3+"FRETE := MaFisRet(,'NF_FRETE')}"),)})
	AAdd(aCposRodape,{,cP3+"SEGURO" ,,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_SEGURO'  ,M->"+cP3+"SEGURO)" ,,,,,IIf(lInclui,"MaFisRet(,'NF_SEGURO')"  ,),,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),018,200,,,If(lInclui,&("{|| M->"+cP3+"SEGURO := MaFisRet(,'NF_SEGURO')}"),)})

SX3->(MsSeek(cP3+"VALBRUT"))

cTotFolder3:="M->"+cP3+"FRETE"+"+"+"M->"+cP3+"SEGURO"+"+"+"M->"+cP3+"DESPESA"

AAdd(aCposRodape,{STR0032,"nTOTDesp",SX3->X3_PICTURE,12,SX3->X3_DECIMAL,LocX3VALID(),SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT,cTotFolder3,,,"aoSbx[3]",,,".F.",047,200}) //"Total"
//³Dados Financeiros³
cCondicao := CriaVar(cP3+"COND")
cNatureza := CriaVar(cP3+"NATUREZ")
If !Empty(aCfgNf[ScOpFin])
	AAdd(aObjsNF,{"xAux"	,"IIF(l103Visual,AtuDadosFin('" + aCfgNf[ScAliasFin] + "','" + aCfgNf[SAliasHead] + "'),)",3 })
Endif
If l103Class
	AAdd(aObjsNF,{"oLstFin"	,"LxA103Financ(@cCondicao,aoSbx[4],lEICFinanc,aRecSE2,215,!lEICFinanc,aRecSE1,"+If(lInclui,".T.",".F.")+",'"+aCfgNf[ScAliasFin]+"')" ,1})
Else
	AAdd(aObjsNF,{"oLstFin"	,"LxA103Financ(@cCondicao,aoSbx[4],l103Visual,aRecSE2,215,!l103Visual,aRecSE1,"+If(lInclui,".T.",".F.")+",'"+aCfgNf[ScAliasFin]+"')" ,1})
Endif
If lLocxAuto
	//³Estes dois campos são os unicos montados em outra função, e com nome de        ³
	//³variável ao invés de nopme de CAMPO, por isto que a aAutoCab deve ser adaptada ³
	//³para guardar os valores nas variáveis cCondicao e cNaturez.                    ³
	//³Se mudar esta validação, também deve mudar a a chamada a ela na LxA103Financ() ³
	cNatureza	:=	""
	Aadd(aCposRodape,{'',"cCondicao",,,,"Vazio().OR.(LxA103Cond(cCondicao) .AND.CheckSX3('F1_COND') .AND. Eval({|| LxA103Dupl(MaFisRet(,'NF_BASEDUP'),nMoedaCor,dDEmissao,cCondicao,,,,,,,@M->cNatureza),.T.}))"})
	Aadd(aCposRodape,{'',"cNatureza",,,,"Vazio().OR.(ExistCpo('SED') .AND. LxA103VFold('NF_NATUREZA',&(ReadVar())))"})
	nPos	:=	Ascan(aAutoCab,{|x| Alltrim(x[1]) == cP3+"COND" } )
	If nPos > 0
		aAutoCab[nPos][1]	:=	"cCondicao"
	Endif
	//Russia - ULCD we need keep the same Naturez form original document for credit and debit invoice || manter a mesma natureza do F2_NATUREZ, para nota de crédito via ExecAuto
	If !(cPaisLoc=='RUS' .and. FunName() $ 'MATA467N|MATA465N|RU05D01')
	nPos	:=	Ascan(aAutoCab,{|x| x[1] == cP3+"NATUREZ" } )
		If nPos > 0
			IF (FwIsInCallStack("MATA143") .and. cPaisLoc == "CHI") .or. (cPaisLoc == "URU")
				Aadd(aAutoCab,{aAutoCab[nPos][1],aAutoCab[nPos][2],})
				aAutoCab[nPos][1]	:=	"cNatureza"
			Else
				aAutoCab[nPos][1]	:=	"cNatureza"
			EndIF
		Endif
	Endif
Endif
// Folder de Livros Fiscais
AAdd(aObjsNF,{"oLstSF3"	,"MaFisBrwLivro(aoSbx[5],{003,005,"+Str(aPosFold[3]-15)+",55},.T.,Nil,l103Visual)",1})
aImp := MaFisRelImp('MT100',{aCfgNf[SAliasHead],aCfgNf[SAliasCols]})
aImp1 := MaFisRelImp('MT100',{aCfgNf[SAliasHead],aCfgNf[SAliasCols]})
AAdd(aObjsNF,{"Aux"    ,"MaFisIni('      ','  ',IIf('"+aCfgNf[ScCliFor]+"'=='SA1','C','F'),cTipo,Nil,aImp,,.F.,,,'"+StrZero(aCfgNF[SnTipo],2)+"','"+IIf(cPaisLoc == "RUS",aCfgNF[ScEspecie],"")+"')",3})
// Folder de Impostos
AAdd(aObjsNF,{"oLstImp"	,"MaFisRodape(2,aoSbx[6],,{003,005,"+Str(aPosFold[3]-15)+",55},{|| (MaFisToCols(aHeader,aCols,,'"+iif(aCfgNf[SAliasHead]=="SF2","MT460","MT100")+"')),Eval(bRefresh),Eval(bGdRefresh)},"+If(lInclui,".F.",".T.")+",,,,,,,,,,,,," + Iif( lEditImp .and. INCLUI .and. !aCfgNf[SlFormProp] .and. AllTrim( aCfgNf[ScEspecie] ) $ 'NF|NCP|NDP|NDE|NCE', ".T.", ".F." ) + ")",1})
cAliasGrid:= aCfgNf[SAliasCols]
cWhileGrid:= "!" + aCfgNf[SAliasCols] + "->(EOF()) .AND. " + aCfgNf[SAliasCols] + "->" + cP4 + "FILIAL==XFilial('" + aCfgNf[SAliasCols] + "') .AND. !Empty(M->" + cP3 + "DOC) .AND. " + aCfgNf[SAliasCols] + "->" + cP4 + "DOC==M->" + cP3 + "DOC .AND. " + aCfgNf[SAliasCols] + "->" + cP4 + "SERIE==M->" + cP3 + "SERIE .AND. " + aCfgNf[SAliasCols] + "->" + IIF(cP4=="D1_","D1_FORNECE","D2_CLIENTE")+"==M->" + IIF(cP3=="F1_","F1_FORNECE","F2_CLIENTE")+" .AND. " + aCfgNf[SAliasCols] + "->" + cP4 + "LOJA==M->" + cP3 + "LOJA"
cSeekGrid := "xFilial('" + aCfgNf[SAliasCols] + "')+M->" + cP3 + "DOC+M->" + cP3 + "SERIE+M->" + IIF(cP3=="F1_","F1_FORNECE","F2_CLIENTE")+"+M->" + cP3 + "LOJA"
nIndGrid  := If(aCfgNf[SAliasHead]=="SF2",3,1)
// Conferência Física
If LocxVlCon(lDeleta) .And. aCfgNF[SAliasHead] == "SF1"
	If aCfgNF[SnTipo] == 10
		AAdd(aObjsNF,{"oLstFin"	,"LocxConf(aoSbx[8])" ,1})
	Else
		AAdd(aObjsNF,{"oLstFin"	,"LocxConf(aoSbx[7])" ,1})
	Endif
Endif
//³Dados do Caixinha³
If aCfgNF[SnTipo] == 10
	SX3->(DbSetOrder(2))
	SEU->(MsSeek("|||",.F.))
	SX3->(MsSeek("EU_CAIXA"))
	AAdd(aCposRodape,{X3Titulo(),"cCxCaixa",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid(),,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_CAIXA") }  })
	SX3->(MsSeek("EU_VALOR"))
	If (cPaisLoc == "ARG" .OR. cPaisLoc == "BOL") .And. ALLTRIM(cEspecie) == "NF" .And. ALLTRIM(cFunName) == "MATA101N"
		cVld := "Vazio().OR.Positivo()"
	Else
		cVld := "Vazio().OR.Positivo() .AND. Fa560Valor(nCxValor,cCxCaixa,.F.)"
	EndIf
	If cPaisLoc == "CHI"
		AAdd(aCposRodape,{X3Titulo(),"nCxValor",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,,SX3->X3_TIPO,,,"nCxValor := IIf(Type('cCxCaixa')!='U' .And. !Empty(cCxCaixa), Round(MaFisRet(,'NF_TOTAL'),"+"MsDecimais( IIf(Type('nMoedaNF')=='N',nMoedaNF,1) )"+"),0)",,,"aoSbx[7]",,SX3->X3_F3,".F.",,,,,,{|| CriaVar("EU_VALOR") }  })
	Else
		AAdd(aCposRodape,{X3Titulo(),"nCxValor",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_VALOR") }  })
	Endif
	SX3->(MsSeek("EU_BENEF"))
	AAdd(aCposRodape,{X3Titulo(),"cCxBenef",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid(),,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_BENEF") }  })
	SX3->(MsSeek("EU_HISTOR"))
	AAdd(aCposRodape,{X3Titulo(),"cCxHistor",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid(),,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_HISTOR") }  })
	SX3->(MsSeek("EU_NROADIA"))
	AAdd(aCposRodape,{X3Titulo(),"cCxAdian",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid(),,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_NROADIA") }  })
	If SX3->(MsSeek("EU_NRREND"))
		AAdd(aCposRodape,{X3Titulo(),"cCxRendic",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid(),,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_NRREND") }  })
	Endif
EndIf
If ExistBlock("NFCPOSRODPE")
	For nX:=1 To len(aCposRodape)
		AAdd(aCposPE,{aCposRodape[nX][2],aCposRodape[nX][17]})
	Next
	aCposPE  := ExecBlock("NFCPOSRODPE",.F.,.F.,{aCposPE})
	If ValType(aCposPE) == "A" .AND. len(aCposRodape) == len(aCposPE) //NAO ESQUECE DE COLCOAR PRA ALTERAR SO PRA SIM, NAO DEIXA VLOTAR
		For nX:=1 To len(aCposRodape)
			aCposRodape[nX][17] := IiF(ValType(aCposPE[nX][2])=="C" .AND. aCposPE[nX][2]==".F.",".F.",aCposRodape[nX][17])
		Next
	EndIf
EndIf
//Tira os cpos amarracao c/pedido se o tipo de nota nao puder ser amarrado com o pedido
If !aCfgNf[SlPedido]
	aCposNo	:=	{'D1_ITEMPC','D1_PEDIDO','D2_ITEMPV','D2_PEDIDO' }
Endif
//Inclui os campos que sao exclusivos do remito.
If aCfgNf[SlRemito]
	aCpos  	:=	{'D2_GERANF','D2_LOCDEST','D2_AGREG'}
	Aadd(aCposNo,"D2_REMITO")
	Aadd(aCposNo,"D2_ITEMREM")
	Aadd(aCposNo,"D2_SERIREM")
	Aadd(aCposNo,"D1_REMITO")
	Aadd(aCposNo,"D1_ITEMREM")
	Aadd(aCposNo,"D1_SERIREM")
Endif
//Inclui os campos de integracao com o PMS
If IntePMS()
	AAdd(aCpos,'D2_PROJPMS')
	If aCfgNF[SnTipo]<>7 .AND. aCfgNF[SnTipo]<>22 .AND. aCfgNF[SnTipo]<>8
		AAdd(aCpos,'D2_EDTPMS')
	Else
		AAdd(aCposNo,'D2_EDTPMS')
	Endif
	AAdd(aCpos,'D2_TASKPMS')
Endif
If aCfgNf[SAliasCols] $ "SD1|SD2"
	If aCfgNf[SAliasCols] == "SD1"
		cCondIf := (aCfgNf[SAliasCols]+"->"+cP4+"FORMUL")+" == SF1->F1_FORMUL .AND. "
		cCondIf := cCondIf+(aCfgNf[SAliasCols]+"->"+cP4+"ESPECIE")+" == SF1->F1_ESPECIE"
	Else
		cCondIf := (aCfgNf[SAliasCols]+"->"+cP4+"FORMUL")+" == SF2->F2_FORMUL .AND. "
		cCondIf := cCondIf+(aCfgNf[SAliasCols]+"->"+cP4+"ESPECIE")+" == SF2->F2_ESPECIE"
	Endif
Endif
aParCols  := {cAliasGrid,cWhileGrid,cCondIf,,,cSeekGrid,nIndGrid,,aCposNo,aCposExt,{,"MT103PN"}}
//Pto de Entrada para adicionar campo
cPe	:=	LocxPE(33)
If !Empty(cPE)
	aCposNF	:=	ExecBlock(cPe,.F.,.F.,{aCposNF,aCfgNF[SnTipo]})
Else  //PE: Adicionar campo (S3)
	If __lPyme .And. ExistBlock( "LOCXS333" , .F. , .T. )
    	aCposNF :=	Execblock( "LOCXS333" , .F. , .F. , {aCposNF,aCfgNF[SnTipo]} )
	EndIf
Endif
If lInclui
	If !lLocxAuto
		cOnInit := "SetValItem({{'"+Right(aCfgNF[SAliasCols],2)+"_COD','AtuContQt()'},{'"+ Right(aCfgNF[SAliasCols],2)+ "_QUANT','Positivo() .And. AtuContQt()'},{'"+ Right(aCfgNF[SAliasCols],2)+ "_QTSEGUM','Positivo() .And. AtuContQt()'}},1)"
		If lUsaCor
			If aCfgNF[SAliasHead] == "SF1" .And. cPaisLoc <> "CHI"
				cOnInit += ",M->F1_NUMCOR:=CORR_PROX(M->F1_DTDIGIT)"
			ElseIf aCfgNF[SAliasHead] == "SF2" .And. cPaisLoc <> "CHI"
				cOnInit += ",M->F2_NUMCOR:=CORR_PROX(M->F2_DTDIGIT)"
			Endif
	    Endif
		cLinok  := "PrepLinOk()"
		cFunOk  := "PrepGravaNf(aCfgNf["+AllTrim(Str(SnTipo))+"],__aCpTela)"
		cTudoOk := "PrepTudoOk(" + Alltrim(Str(aCfgNf[SnTipo])) + ",__aCpTela)"
	   	cFunCanc:= 'MsUnLockAll()'
	Else
		cFunOk  := "PrepGravaNf(aCfgNf["+AllTrim(Str(SnTipo))+"],__aCpTela)"
		cFunCanc:= 'MsUnLockAll()'
		cLinOk  := NIL
		cTudoOk := NIL
	EndIf
ElseIf lDeleta
	cOnInit 	:= "(InicializaFis(aHeader,aCols,'" + aCfgNf[SAliasHead] + "','" + aCfgNf[SAliasCols] + "','" + aCfgNf[ScCliFor] + "','" + aCfgNf[ScTipoDoc] + "',,.T.))"
	cOnInit     +=	",NFSetImps('"+aCfgNf[SAliasCols]+"')"
	If Type("lLocxAuto") <> "L"  .OR. !lLocxAuto
		cOnInit     +=	",AtuLoadQt()"
	Endif
	cOnInit 	:= IIf((Type("lLocxAuto") <> "U" .AND. lLocxAuto),cOnInit,"MsAguarde({|| " + cOnInit + "})")
	lMostraCtb 	:= aCfgNf[SaPergs][SlVerCtbil]
	lAglCtb    	:= aCfgNf[SaPergs][SlAglutina]
	lContab    	:= aCfgNf[SaPergs][SlGerCtbil]
	lCarteira  	:= .T.
	cFunCanc	:=	'DbUnLockAll()'
	cFunOk	    :=	Iif(StrZero(aCfgNf[SnTipo],2)$'01/11/50/52',"lCarteira:=LocxChePed('"+aCfgNf[SAliasHead]+"'," + aCfgNf[SAliasHead] + "->(Recno())),","")
	If !lLocxAuto .Or. (FunName() $ "MATA447" .And. GetRemoteType() <> -1)
		cFunOk 	+= "LocxDelNf('" + aCfgNf[SAliasHead] + "'," + aCfgNf[SAliasHead] + "->(Recno()),lMostraCtb,lAglCtb,lContab,lCarteira,.T.)"
	Else
		cFunOk 	+= "LocxDelNf('" + aCfgNf[SAliasHead] + "'," + aCfgNf[SAliasHead] + "->(Recno()),(Iif(cPaisLoc == 'ARG',lMostraCtb,Funname() $ 'FISA817' .And. lMostraCtb)),lAglCtb,lContab,lCarteira,.F.,.F.)"
		Endif
	cTudoOk 	:= NIL
ElseIf l103Class
	cOnInit := "(InicializaFis(aHeader,aCols,'" + aCfgNf[SAliasHead] + "','" + aCfgNf[SAliasCols] + "','" + aCfgNf[ScCliFor] + "','" + aCfgNf[ScTipoDoc] + "',.T.))"
	cOnInit := "MsAguarde({|| " + cOnInit + "})"
	cOnInit +=	",AtuLoadQt()"
	If lUsaCor
		If aCfgNF[SAliasHead] == "SF1" .And. cPaisLoc <> "CHI"
			cOnInit += ",M->F1_NUMCOR:=CORR_PROX(M->F1_DTDIGIT)"
		ElseIf aCfgNF[SAliasHead] == "SF2" .And. cPaisLoc <> "CHI"
			cOnInit += ",M->F2_NUMCOR:=CORR_PROX(M->F2_DTDIGIT)"
		Endif
    Endif
	cFunOk  := "PrepGravaNf(aCfgNf["+AllTrim(Str(SnTipo))+"],__aCpTela)"
	cTudoOk := "PrepTudoOk(" + Alltrim(Str(aCfgNf[SnTipo])) + ",__aCpTela)"   // validacao
	cLinOk	:= "PrepLinOk()"
Else
	If lFacImport
		cOnInit := "(InicializaFis(aHeader,aCols,'" + aCfgNf[SAliasHead] + "','" + aCfgNf[SAliasCols] + "','" + aCfgNf[ScCliFor] + "','" + aCfgNf[ScTipoDoc] + "',.T.))"
		cOnInit +=	",NFSetImps('"+aCfgNf[SAliasCols]+"')"
	Else
		cOnInit := "(InicializaFis(aHeader,aCols,'" + aCfgNf[SAliasHead] + "','" + aCfgNf[SAliasCols] + "','" + aCfgNf[ScCliFor] + "','" + aCfgNf[ScTipoDoc] + "',,.T.))"
		cOnInit +=	",NFSetImps('"+aCfgNf[SAliasCols]+"')"
	Endif
	cOnInit     +=	",AtuLoadQt()"
	cOnInit 	:= "MsAguarde({|| " + cOnInit + "})"
	cFunOk  	:= NIL
	cTudoOk 	:= NIL
EndIf
AAdd(aObjsNF,{"oFldRodape:bChange","{|| ModxAtuObj(.F.) .AND. oGetDados:oBrowse:SetFocus() }",1})
//³Quando for remito nao mostrar os folders de Duplicatas, impostos e livros fiscais³
If lFacImport .AND. !lInclui
	If aCfgNf[SlRemito]
		AAdd(aObjsNF,{"oFldRodape:bSetOption","{|nNewOption| Iif(nNewOption >3,MsgAlert('"+STR0106+" '),Nil),nNewOption <4}",1})
	Else
		AAdd(aObjsNF,{"oFldRodape:bSetOption","{|nNewOption| If(nNewOption==3 .OR. nNewOption==7,MsgAlert('"+STR0106+" '),Nil),(nNewOption<>7 .AND. nNewOption <> 3)}",1})
	Endif
Else
	If aCfgNf[SlRemito] .AND. cPaisLoc <> "RUS"
		AAdd(aObjsNF,{"oFldRodape:bSetOption","{|nNewOption| Iif(nNewOption >3,MsgAlert('"+STR0106+" '),Nil),nNewOption <4}",1})
	ElseIf Empty(aCfgNf[ScOpFin])
		AAdd(aObjsNF,{"oFldRodape:bSetOption","{|nNewOption| Iif(nNewOption ==4 ,MsgAlert('"+STR0106+" '),Nil),nNewOption <> 4 }",1})
	Endif
Endif
cOnInit 	:= "EVAL(bFunAuto)" + If(Empty(cOnInit),"",",") + cOnInit
aOpcTeclas 	:= ChkTeclas(aCfgNf[SaTeclas],nOpca)
aBotoes 	:= ChkButtons(aCfgNf[SaBotoes],nOpca)
AAdd(aOrditem,PrefixoCpo(aCfgNf[5]) + "_ITEM")
__aCodLocs	:= {}
//PE: Manipular Array com os objetos que devem ser criados na tela com seus devidos comando de criacao
cPe	:=	LocxPE(48)
If !Empty(cPE)
	aUsObjNF :=	ExecBlock(cPe,.F.,.F.,{aObjsNF})
	If ValType(aUsObjNF) == "A"
	   aObjsNF := aUsObjNF
	Endif
Endif
If cPaisLoc == "COL" .And. FINDFUNCTION( "lxVlTitulo" ) .And. (lDocSp .Or. aCfgNF[SnTipo] == 22 .Or. aCfgNF[SnTipo]== 23) //Docto Soporte //Nota Crédito //Nota Débito
	cCadastro:= lxVlTitulo(lDocSp, aCfgNF[SnTipo], cCadastro ) //obtiene el titulo del documento
Endif
If cPaisLoc == "MEX" .And. aCfgNF[SnTipo] == 24  //Nota Crédito - Documento de Cancelación
	cCadastro += " - " + STR0456 // Documento de Cancelación
Endif
LocxMod(,aCposNF,,aCposRodape,aParCols,,cCadastro,aCordW,.T.,aCoordGD,,nOpca,cFieldOk,cLinOk,cTudoOk,cFunOk,cFunCanc,If(lInclui,"+" + cP4 + "ITEM",),aCfgNF[SaCposGD],IIf(aCfgNf[SlFormProp],nItens,MAX_GETD),!(lVisualiza .OR. lDeleta),aBotoes,aOpcTeclas,aObjsNF," LxA103Del().AND. AtuContQt()",cOnInit,,,aOrditem)

If cPaisLoc == "EQU"  .and. FunName() == "MATA467N" .and. aCfgNF[SAliasHead] == "SF2" .and. Alltrim(SF2->F2_ESPECIE) =="NF" .and.  FindFunction("MAT488END") .and. SF2->(FieldPos("F2_TPDOC")) > 0 .and.  Len(aLlaveOrg) > 0
	MAT488END() //limpia variables y tabla temporal de reembolsos.
Endif
If cPaisLoc == "MEX" //.And. SF2->(ColumnPos("F2_TPCOMPL")) > 0 .And. cFunName == "MATA467N" .And. (nNFTipo == 1 .Or. nNFTipo == 21)
	oModelAct := Nil
EndIf

For nX:=1 To Len(__aCodLocs)
	UnLockByName(__aCodLocs[nX],.T.,!Empty(cFilSF2),.T.)
	UnLockByName(__aCodLocs[nX],.T.,!Empty(cFilSF1),.T.)
Next
__aCodLocs	:= {}
If MaFisFound()
	MaFisEnd()
EndIf
If Type("aImpIB2")== "A"
	aImpIB2:={}
EndIf
//Geracao da NCC para cancelamento de NF - Loc. Guatemala
If cPaisLoc == "GUA" .AND. lDeleta .AND. lGeraNCC .AND. Len(aDadosSF2) > 0
   If !LocxGerNCC()
      Return (.F.)
   EndIf
EndIf
//Quando Recebimento de Meio Magnetico nao restaura area para nao desposicionar do documento gerado
If AllTrim(FunName()) <> "LOJA470"
	dbSelectArea(aArea[1])
	dbSetOrder(aArea[2])
	MsGoto(aArea[3])
EndIf
If bFilBrowse <> Nil
	Eval(bFilBrowse)
Endif
aCfgNF	:=	AClone(IIf(lBkpCfgInc, aBkpCfgInc, aBKPCfgNF))
NFSetPrv(aCfgNF)
SetKey(VK_F12,bSavF12)

If (Valtype("cFactApoc") <> "U", cFactApoc := "", "")
Return
/*³Fun‡…o    ³ EnablePanel   ³ Autor ³ Guilherme C. Leal ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Habilita os paineis do rodape.       ³*/
Function EnablePanel()
aoSbx[1]:Enable()
aoSbx[1]:Refresh()
oLstFin:Enable()
oLstFin:Refresh()
oLstImp:Enable()
oLstImp:Refresh()
Return .T.
/*³Fun‡…o    ³ NFCalcImp     ³ Autor ³ Guilherme C. Leal      ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Inicializa variaveis necessárias para calculo dos impostos.        ³*/
Function NFCalcImp()
Local nPosDesc:=0
nPosDesc:=AScan(aHeader,{|x| Upper(Alltrim(x[2]))$"D1_VALDESC|D2_DESCON"})
If nPosDesc>0
	AEval(aCols,{|x| AAdd(aDescontos,x[nPosDesc])})
Endif
If aCfgNf[SAliasHead]=="SF2"
	cA467Cli  :=M->&("M->F2_CLIENTE")
Else
	cA467Cli  :=M->&("M->F1_FORNECE")
EndIf
cNitCC:=""
lRatValor :=.F.
nTotMerc  :=M->&(cP3+"VALMERC")
nValDesp  :=M->&(cP3+"DESPESA")
nSeguro   :=M->&(cP3+"SEGURO")
nValFrete :=M->&(cP3+"FRETE")
nValDesc  :=M->&(cP3+"DESCONT")
aImpS     := {}
cEspecie  :=M->&(cP3+"ESPECIE")
cVenda    := "NORMAL"
cNFiscal  :=M->&(cP3+"DOC")
cSerie    :=M->&(cP3+"SERIE")
nTaxa		:=	M->&(cP3+"TXMOEDA")
nMoedaNF	:=	M->&(cP3+"MOEDA")
If Empty(cEspecie)
	cEspecie  :=   Alltrim(aCfgNf[ScEspecie])
	M->&(cP3+"ESPECIE"):= cEspecie
EndIf

Return
/*³Fun‡…o    ³ PrepTudoOk    ³ Autor ³ Guilherme C. Leal      ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Prepara todas as informações necessárias para a chamada da TudoOk. ³*/
Function PrepTudoOk(nTipoNf,aGetsTela)
Local aCpos := {}, nX := 0
Local aCposTela:=Array(3) //Dados do cabecalho de uma NF
Local lRet := .T.
Local aAuxCols := {}
Local oModel
private ldupli := .T.
If Type("cCxCaixa") == "U"
	cCxCaixa	:= ""
EndIf
nMoedaCor := Iif(Type("nMoedaCor") == "N", nMoedaCor, 1)
/*	[1] - campos do cabecalho
	[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
	[3] - indica se o campo e totalizador (Default .F.)
	Obs.: se o campo for um totalizador, a formula para se totalizar deve ser colocada no lugar do conteudo [2]
    e deve ser levado em consideracao que ira totalizar sempre o conteudo atual mais o conteudo da formula a cada item gravado*/
//Si hay un valor para caja chica, calcula que sean válidos los campos.
If !Empty(cCxCaixa)
	If !Fa560Valor(nCxValor,cCxCaixa,.F.,cCxAdian,cCxRendic)
		Return .F.
	EndIf
EndIf
aCposTela[1]:={};	aCposTela[2]:={};	aCposTela[3]:={}
For nX := 1 TO Len(aGetsTela)
	If Ascan(aCpos,{|x| x[1] == aGetsTela[nX][1]})==0
		Aadd(aCpos,aGetsTela[nX])
	Endif
Next
aGetsTela:=aClone(aCpos)
//Carrega campos e conteudos dos objetos da tela para o array aCposTela desconsiderando os campos que nao fazem parte do cabecalho da NF
AEVal(aGetsTela,{|x| IIf(cP3==Left(x[1],At("_",x[1])),AAdd(aCposTela[1],x[1]),),IIf(cP3==Left(x[1],At("_",x[1])),AAdd(aCposTela[2],x[2]),) })
//Busca os campos que possuem um conteudo padrao/automatico na gravacao da NF, de acordo com a nota e inclui os campos e seus respectivos conteudos no array aCposTela
aAux 			:= CposAutoNf(aCfgNf[SAliasHead],aCfgNf[ScCliFor],aCfgNf[SlFormProp],aCposTela[1],{aCposTela[2]},aCfgNf[ScTipoDoc])
aCposTela[1] 	:= aClone(aAux[1])
aCposTela[2] 	:= aClone(aAux[2][1])
//³Chamada da funcao de consistencia TUDOK³
If FindFunction('LoadMdData') .and. !Empty(LxSelecMod(aCfgNf[SnTipo]))
	aAuxCols := CposAutoNf(aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[SlFormProp],HeaderCpos(),aCols,aCfgNf[ScTipoDoc])
	oModel := LoadMdData(aCfgNf[SnTipo], aCposTela[1], aCposTela[2], aAuxCols[1], aAuxCols[2], aCfgNF[ScEspecie], MaFisRet(,"NF_BASEDUP"), cPaisLoc, aDupl, IIf(Type("lLocxAuto") != "U",lLocxAuto,.F.), nMoedaCor, IIf(Type("cNatureza") == "C",cNatureza,""))
	If Type("aHeadSEV") == "A" .and. Type("aColsSEV") == "A" .and. Len(aColsSEV) > 0
		MdFillNat(@oModel, "SEV_DETAIL", aHeadSEV, aColsSEV)
	EndIf
	MdFillAFN(@oModel, "AFN_DETAIL", Iif(ValType(aHdrAFN)== "A",aHdrAFN,{}), Iif(ValType(aRatAFN)== "A",@aRatAFN,{}), aCols)
	If FindFunction('MFillCaixa') .and. Type("cCxBenef") == "C" .and. Type("nCxValor") == "N" .and. Type("cCxCaixa") == "C" .and. Type("cCxAdian") == "C" .and. Type("cCxHistor") == "C"
		MFillCaixa(oModel, cCxBenef, nCxValor, cCxCaixa, cCxAdian, cCxHistor, Iif(Type("cCxRendic") == "C",cCxRendic,"") )
	EndIf
	lRet := vldModel(oModel)
	If lRet
		ModUpdDoc(oModel, @aCposTela, @aGetsTela) //Actualización de numeración en caso de haber sido reemplazada. (Modxfun.tlpp)
	EndIf
	oModel:DeActivate()
EndIf
//³Chamada da funcao de consistencia TUDOK³
lRet := lRet .and. NfTudOk(aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCposTela,HeaderCpos(),aCols,Len(aCols),aCfgNf[ScTipoDoc],aCfgNf[SlFormProp],aGetsTela)
Return lRet
/*³Fun‡…o    ³ PrepGravaNf   ³ Autor ³ Guilherme C. Leal      ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Prepara informacoes e chama a gravacao da nf.                      ³*/
Function PrepGravaNf(nTipoNf,aGetsTela,bExecute)
//Local nX 		:= 0
//Local cMsgCFD	:= ""
Local aFin		:= Array(SnMaxFin) //Dados especificos para gravacao do financeiro
/*	[SnMoedaFin]	- Moeda a ser gravada no financeiro
	[ScNatureza]	- Naturaza da operacao financeira*/
Local aCfgOri 	:={}
Local aCposTela := Array(3)	//Dados do cabecalho da Nota
/*	[1] - campos do cabecalho
	[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
	[3] - indica se o campo e totalizador (.T./.F.)
	Obs.: se o campo for um totalizador, a formula para se totalizar deve ser colocada no lugar do conteudo [2]
	e deve ser levado em consideracao que ira totalizar sempre o conteudo atual mais o conteudo da formula a cada item gravado,
	pois a formula de um campo totalizador e rodada sempre ao gravar os itens */
Local lRetPE	:= .T.
Local lContinua	:= .T.
Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1" //Integracao com o módulo ACD
Local lImprime	:= .F.
Local cCompNc	:= SuperGetMV("MV_COMPNC", .F., "3")//Indica qdo comp. a NCC-NDE 1-Sempre compensa,2-Nunca3-Pergunta
Local lGenXML	:= .T.
Local aArea		as Array
Local lComp     := .T.
Local cVersion := GetRpoRelease()
Local lIntGC 	:= IIf((SuperGetMV("MV_VEICULO",,"N")) == "S",.T.,.F.) // Módulos Concessionárias

DEFAULT	bExecute	:=	{|| Nil	}

aArea := {}

//³Ponto de Entrada para manipular aCols³
cPe	:=	LocxPE(60)
If !Empty(cPE)
	If ValType(lRetPE := ExecBlock(cPE,.F.,.F.) ) == "L"
		lContinua := lRetPE
	Endif
EndIf
aCposTela[1]:= {}
aCposTela[2]:= {}
//³Preparando o parametro dos dados financ.³
aFin[SnMoedaFin] := nMoedaCor
aFin[ScNatureza] := cNatureza
If cPaisloc $ "BOL" .And. (Type("cFunName")<>"U" .and. cFunName $'FINA087A|FINA085A|FINA074|FINA084')
	aDupl:={}
EndIf
//³Busca campos e conteudos para compor o array aCposTela, dos objetos da Tela, retirando os campos que nao
//³fazem parte do arquivo de cabecalho da NF que sera gravada
AEVal(aGetsTela,{|x| IIf(cP3==Left(x[1],At("_",x[1])),AAdd(aCposTela[1],x[1]),),IIf(cP3==Left(x[1],At("_",x[1])),AAdd(aCposTela[2],x[2]),) })
//³Chamada da funcao de gravacao da NF que retorna .T. ou .F.³
lRetGravacao:=.F.
If lContinua .And. ( Type("lLocxAuto") <> "U" .And. lLocxAuto )
	lRetGravacao := GravaNfGeral(aCposTela,aCols,HeaderCpos(),nTipoNf,aCfgNf[SaPergs],aRatCC,.f.,aClone(aFin),aRecsSF1,aDupl,,aGetsTela)
ElseIf lContinua
	MsAguarde( {|| lRetGravacao := GravaNfGeral(aCposTela,aCols,HeaderCpos(),nTipoNf,aCfgNf[SaPergs],aRatCC,.T.,aClone(aFin),aRecsSF1,aDupl,,aGetsTela)},,STR0033,) //"Gravando Registros..."
Endif
If lRetGravacao .And. lContinua
	If aCfgNf[SlRemito] .AND. aCfgNf[SnTipo] == 54 .AND. Type("M->F2_TIPORET")=='C' .AND. M->F2_TIPORET == '1'
		aCfgOri := AClone(aCfgNF)
		If !GerTrfRet(SF2->(Recno()),M->F2_FILDEST)
			Aviso(STR0018,STR0183,{STR0021}) // "Nao foi possivel gerar documento de retorno, a entrada devera ser feita manualmente."
		EndIf
		aCfgNf := AClone(aCfgOri)
		NFSetPrv(aCfgNF)
	EndIf
	//Integracao com o módulo ACD
	If lIntAcd
		If SF1->F1_TIPODOC $ "51*53" .And. SuperGetMv("MV_IMPIP",.F.,"3") == "2" .Or. ;
		SF1->F1_TIPODOC $ "60" .And. ((SA2->A2_IMPIP == "2") .Or. (SA2->A2_IMPIP $ "03 " .And. SuperGetMv("MV_IMPIP",.F.,"3") == "2" ))
			ACDI10NF(SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA,.T.,lLocxAuto)
		ElseIf SF1->F1_TIPODOC $ "08*09*10" .And. ((SA2->A2_IMPIP == "2") .Or. (SA2->A2_IMPIP $ "03 " .And. SuperGetMv("MV_IMPIP",.F.,"3") == "2" ))
			SD1->(DbSetOrder(1))
			If SD1->(dbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
				While SD1->(!EOF()) .And.;
				xFilial('SD1')	== SD1->D1_FILIAL 	.And. ;
				SD1->D1_DOC     	== SF1->F1_DOC    		.And. ;
				SD1->D1_SERIE   	== SF1->F1_SERIE  	.And. ;
				SD1->D1_FORNECE 	== SF1->F1_FORNECE 	.And. ;
				SD1->D1_LOJA    	== SF1->F1_LOJA
					If Empty(SD1->D1_REMITO)
						lImprime := .T.
						Exit
					EndIf
					SD1->(dbSkip())
				End
				If lImprime
					ACDI10NF(SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA,.T.,lLocxAuto)
				EndIf
			EndIf
		EndIf
	EndIf
	//Geracao Fat.Eletronicas
	If Type("lGerarCFD") != "L" .And. FunName() <> "MATA466N"
		lGerarCFD := .F.
		aGerarCFD := {}
		If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
			aGerarCFD := CFDVerific()
			If aGerarCFD[1] <> "0"
				If Empty(aGerarCFD[2])
					lGerarCFD := .T.
				Endif
			Else
				lGerarCFD := .F.
			Endif
		Endif
	Endif
	// LLama pantalla de Pagos
	If  cPaisLoc == "PAR" .and. aCfgNf[SnTipo] == 1  .and. aCfgNF[SAliasHead] == "SF2" .and. aGerarCFD[1] <> "0" .and. SE4->E4_BXTITAV == "1"
		M486PAGOS(SF2->F2_ESPECIE, SF2->F2_DOC, SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_COND,SF2->F2_VALBRUT,4)
	EndIf
	If (aCfgNf[SnTipo] == 4 .OR. aCfgNf[SnTipo] == 5) .And. aCfgNf[ScEspecie] $ MV_CRNEG .And. lGerarCFD .And. cCompOnL == "1"
		lGenXML := .T.
		If cPaisLoc == "MEX"
			lGenXML := !Empty(SF1->F1_UUID)
		EndIf
		If lGenXML
			If cVersion >= "12.1.2210"
				If cCompNc	== "3" .Or. cCompNc	== "1"
					lComp := iif(cCompNc	== "3",MsgYesNo(STR0035,STR0036),.T.) //"Deseja fazer agora a compensacao do titulo gerado?"###"Compensacao de titulos"
					If lComp
						FINA998()
					Endif
				EndIf
			Else
				If cCompNc	== "3" .AND. MsgYesNo(STR0035,STR0036) //"Deseja fazer agora a compensacao do titulo gerado?"###"Compensacao de titulos"
					Fina087a("","",{})
				ElseIf cCompNc	== "1"
					If SuperGetMV("MV_FINCTMD",.T.,1) == 1
						Fina087a("","",{})
					Else
						SetFunName("FINA846")
						FINA840()
						SetFunName(cFunName)
					EndIf
				EndIf
			Endif
		EndIf
	EndIf

	If lIntGC // Modulos do DMS
		If FindFunction("OA2900078_a103Grava_MI_AposGravacao")
			OA2900078_a103Grava_MI_AposGravacao()
		EndIf
	EndIf

EndIf
// WMS Integration - Service Order Generation.
If cPaisLoc == "RUS"
	If SuperGetMV("MV_WMSNEW",.F.,.F.) .and. lContinua .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE=="S" .And. FindFunction("WmsIntMI") .And. IntWMS()
		aArea := GetArea()
			WmsIntMI()
		RestArea(aArea)
	EndIf
ELSE
//Integração WMS - Geração Ordem de Serviço
	If lContinua .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE=="S" .And. !(AllTrim(cEspecie) $ "RCD|NCP") .AND. FindFunction("WmsIntMI") .And. IntWMS()
		WmsIntMI()
	EndIf
EndIf
//Libera Lock de Pedidos Bloqueados
If !lRetGravacao .and. Type("aRegsLock")<>"U"
	maDestrava(aRegsLock)
EndIf

If lContinua .And. cFunName == "MATA462TN" .AND. AllTrim(cEspecie) == "RTS" .And. FindFunction("WMSMovRemt")
	WMSMovRemt()
EndIf

Return lRetGravacao
/*³Fun‡…o    ³ SetVar        ³ Autor ³ Guilherme C. Leal      ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Seta valor de algumas variaveis que sao utilizadas posteriormente. ³*/
Function SetVar(cVar)
Do Case
	Case cVar == "F1_FORNECE"
		If Type('cA100For') <> 'U' .and. cA100For != M->F1_FORNECE
			cA100For	:= M->F1_FORNECE
			lAtuFor	:= .T.
		Else
			lAtuFor := .F.
		EndIf
	Case cVar == "F1_EMISSAO"
		If cPaisLoc=="RUS"
			dMemoryDate:=dDEmissao
		EndIf
		dDEmissao:=M->F1_EMISSAO
	Case cVar == "F2_EMISSAO"
		dDEmissao:=M->F2_EMISSAO
	Case cVar == "F1_LOJA"
		cLoja    := M->F1_LOJA
		If !Empty(M->F1_FORNECE)
		   cA100For := M->F1_FORNECE
		EndIf
EndCase
Return(.T.)
/*³Fun‡…o    ³ PrepLinOk     ³ Autor ³ Guilherme C. Leal      ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Habilita os paineis do rodape.  ³*/
Function PrepLinOk()
Local aAux := {} 	//Carrega os campos referentes aos itens da Nota que possuem conteudos padrao
Local aAuxCab  := {}
Local aCposTela:= {{}, {}}
Local cP3	   := ""
Local lRet 	   := .T.
//Altera foco para validacao da multinatureza
If Type("oGetDados")=="O"
	oGetDados:oBrowse:SetFocus()
EndIf
nMoedaCor := Iif(Type("nMoedaCor") == "N", nMoedaCor, 1)
//Carregando os campos que possuem conteudos padrao com os campos que ja estavam declarados no aHeader³e armazenados no aCols
aAux := CposAutoNf(aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[SlFormProp],HeaderCpos(),aCols,aCfgNf[ScTipoDoc],n)
If FindFunction('LoadMdData') .and. !Empty(LxSelecMod(aCfgNf[SnTipo]))
	
	aCposTela[1] :={}	
	aCposTela[2] :={}
	cP3 := Iif(aCfgNf[SAliasHead] == "SF2","F2_", "F1_")
	//Carrega campos e conteudos dos objetos da tela para o array aCposTela desconsiderando os campos que nao fazem parte do cabecalho da NF
	AEVal(__aCpTela,{|x| IIf(cP3==Left(x[1],At("_",x[1])),AAdd(aCposTela[1],x[1]),),IIf(cP3==Left(x[1],At("_",x[1])),AAdd(aCposTela[2],x[2]),) })
	//Busca os campos que possuem um conteudo padrao/automatico na gravacao da NF, de acordo com a nota e inclui os campos e seus respectivos conteudos no array aCposTela
	aAuxCab 		:= CposAutoNf(aCfgNf[SAliasHead],aCfgNf[ScCliFor],aCfgNf[SlFormProp],aCposTela[1],{aCposTela[2]},aCfgNf[ScTipoDoc])
	aCposTela[1] 	:= aClone(aAuxCab[1])
	aCposTela[2] 	:= aClone(aAuxCab[2][1])

	oModel := LoadMdData(aCfgNf[SnTipo], aCposTela[1], aCposTela[2], aAux[1], {aAux[2][n]}, aCfgNF[ScEspecie], MaFisRet(,"NF_BASEDUP"), cPaisLoc, aDupl, IIf(Type("lLocxAuto") != "U",lLocxAuto,.F.), nMoedaCor, IIf(Type("cNatureza") == "C",cNatureza,""))
	MdFillAFN(@oModel, "AFN_DETAIL", Iif(ValType(aHdrAFN)== "A",aHdrAFN,{}), Iif(ValType(aRatAFN)== "A",aRatAFN,{}))
	lRet := VldModLn(oModel, aAux[1], @aAux[2], @aCols, n, .T.)
	oModel:DeActivate()
EndIf
//Chamada da funcao de consistencias LINOK
lRet := lRet .and. NfLinOk(aCfgNf[SAliasCols],aAux[1],aCfgNf[ScCliFor],aAux[2],aCfgNf[ScTipoDoc],n,aCfgNf[SlFormProp])
Return lRet
/*
ºPrograma  ³GRAVANFGERAL ºLenadro C.G. ³Microsiga  º Data ³  09/10/01   º
ºDesc.     ³ Efetua a atuaizacao de todos os arquivos que devem ser     ¹
º          ³atualizados na gravacao de todos os tipos de notas fiscais. º*/
/*Parametros
aCabNotaOri - dados do cabecalho da Nota
[1] - campos do cabecalho
[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
[3] - indica se o campo e totalizador (Default .F.)
 Obs.: se o campo for um totalizador, a formula para se totalizar deve ser colocada no lugar do conteudo [2]
 e deve ser levado em consideracao que ira totalizar sempre o conteudo atual mais o conteudo da formula a cada item gravado
aCpItensOri - campos dos itens (posicoes [2] do aHeader - usar funcao HeaderCpos)
aCitensOri  - conteudo dos itens da NF (aCols) * o conteudo de cada campo pode ser uma formula
nTipo    - tipo de NF
aPergs	- Array com o conteudo das perguntas feitas na tela de NF
	[SlAmarraca 1]-Incluir Amarraçäo  ? (Cli.xProd.) ou (For.xProd.)
	[SlGerCtbil 2]-lanç. On-Line?
	[SlVerCtbil 3]-Mostra Lanç.Contab ?
	[SlAglutina 4]-Aglut Lançamentos  ?
	[SlQbraAliq 5]-Quebra do Rodapé   ? Por Alíquota    /  Por Imposto
	[SlCtbEmiss 6]-Contabiliza por    ? Emissao         /  Data Base
aRatCC	- array com os itens de rateios por centro de custo de todos os itens da NF
	[1] - Numero do Item da NF (D1/D2_ITEM)
	[2] - Itens de Rateios por centro de custo para este item (dados que serao gravados no arquivo SDE)
lTela - Indica se a funcao foi chamada da tela ou nao
aFin - Parametro com os dados especificos de gravacao do financeiro
	[SnMoedaFin]-Numero da moeda de gravacao do financeiro
	[ScNatureza]-Natureza da operacao financeira
aRecsSF1 - Parametro com os registros das notas de entrada originais (usado nas notas de conhecimento de frete e despesas de import..
aDupl - Detalhe dos dados que devem ser gerados no financeiro
cNota - ?
aGetsTela - Vetor com todos os campos DIGITAVEIS da tela da Factura, utilizado para acessar informacoes complementares das folders da tela
lModelGrav - Indica si el grabado es llamado desde las nuevas rutinas de MVC
*/
Function GravaNfGeral(aCabNotaOri,aCitensOri,aCpItensOri,nTipo,aPergs,aRatCC,lTela,aFin,aRecsSF1,aDupl,cNota,aGetsTela,lModelGrav)
Local cAproFol	:= ""
Local cCertFol	:= ""
Local nI,nX     //flag's para loop's
Local cProd		:= "" //armazena codigo de produto
Local cLocal	:= "" //armazena almoxarifado
Local nQuant	:= 0  //armazena qtde do item da nota
Local aRecnoI	:= {} //array que guarda o numero dos registros de itens gravados e a pos. de cada registro na get dados
Local nRecnoC	:= 0  //Guarda o numero do registro de cabecalho gravado
Local aCusto	:= NIL //se necessario armazena valor de custos especiais para passar para rotina de saldos e custos
Local aAux		:= {} //Array auxiliar
Local nPos		:= 0  //pos. de um dado na pos. de um array
Local cPrefC	:= "" //Prefixo do Arquivo de Cabecalho
Local aLdel		:= {} //Numero das linhas do aCols que estao excluidas
Local aSavaCols	:= {} //Guarda o aCols original antes de retirar os itens deletados
Local aGeraPv	:= {} //Array indicando se cada item deve ou nao gerar pedido de venda quando for uma devolucao de venda
Local nValor	:= 0  //Valor referente ao valor base das duplicatas
Local aCitens	:= aClone(aCitensOri) 	//Conteudo dos itens da NF (aCols) * o conteudo de cada campo pode ser uma formula
Local aPars		:= {} //Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local lGeraPed	:=	.F.
Local aCpItens	:= aClone(aCpItensOri)	//Campos dos itens (posicoes [2] do aHeader - usar funcao HeaderCpos)
Local aCabNota	:= aClone(aCabNotaOri)	//Cabecalho da Nota
/*
[1] - campos do cabecalho
[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
[3] - indica se o campo e totalizador (Default .F.)
Obs.: se o campo for um totalizador, a formula para se totalizar deve ser colocada no lugar do conteudo [2]
e deve ser levado em consideracao que ira totalizar sempre o conteudo atual mais o conteudo da formula a cada item gravado
*/
Local aPosicionou 	:= Array(nMaxPos)	//Array com a indicacao dos arquivos que estao posicionados
/*
[lSF4]-Indica se foi posicionado SF4 (TES)
[lSB1]-Indica se foi posicionado SB1 (PRODUTO)
[lSAx]-Indica se foi posicionado SA1 OU SA2 (CLIENTE OU FORN.)
[lSC5]-Indica se foi posicionado SC5 (PEDIDOS DE VENDA)
[lSC6]-Indica se foi posicionado SC6 (ITENS DE PEDIDOS DE VENDA)
[lSC9]-Indica se foi posicionado SC9 (PEDIDOS DE VENDA LIBERADOS)
[lSC7]-Indica se foi posicionado SC7 (PEDIDOS DE COMPRA)
*/
Local aCpTotal	:= {}  //Array que acumula o nome dos campo de cabecalho que devem ser totalizados na gravacao dos itens
Local lRet		:= .T. //Retorno da funcao. Indica incosistencia da funcao
Local aFormTot	:= {}  //Array com a formula do conteudo para os campos totalizadores
/*
[1] - aCabNota
[2] - aCitens
[3]	- aCpItens
Obedece a devolucao da rotina ConsisNf
*/
Local cFilOri := cFilAnt
Local nNF:= 0
Local cCompNc	:= GetNewPar("MV_COMPNC","3")//Indica qdo comp. a NCC-NDE 1-Sempre compensa,2-Nunca3-Pergunta
Local aRecCols := {}
Local xRet                              //Retorno do PE LocxPE24
Local cChSF3:="",cCorrelat:="",aSF3:={},aAreaAnt:={},aAreaASD1:={},aAreaASD2:={},aAreaASF4:={},aAreaASF9:={}
Local nY := 0
Local cNomePE := ""
Local cNumAut		:= ""
Local cCodCtr		:= ""
Local aRetCF	:= {}
Local aDados 	:= {"","","","","",0}
Local cKey		:= ""
// Controle de Folios
Local lContrFol     := .f.
// Passagens aereas - Bolivia
Local lPassag 	:= 	cPaisLoc == "BOL" .And. GetNewPar("MV_PASSBOL",.F.)
Local lTipComp  :=	cPaisLoc == "BOL"
Local cTipCom		:= ""
Local cRecibo       := ""
Local cCompan		:= ""
Local cLojComp		:= ""
Local cPassage		:= ""
Local cCompSF3      := ""
Local dDtPassag		:= cToD("//")
Local cHash         := "" // Inicializada para todos ambientes, porem utilizada somente para ambientes de Portugal
Local cBaseATF 		:= ""
Local nV       		:= 0
Local lIntNtCRDB    := SuperGetMV( "MV_ATFNCRD", .F., .F. )	//Parâmetro de ativação do ajuste de valor do bem.
Local cTipoRem		:= ""
Local nPosRateio	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_RATEIO"	} )
Local nPosRemito	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_REMITO"	} )
Local nPosItemRem	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_ITEMREM"	} )
Local nPNfOri		:= aScan(aHeader,{|x| AllTrim(Subs(x[2],4)) $ "NFORI"})
Local nPSerOri	:= aScan(aHeader,{|x| AllTrim(Subs(x[2],4)) $ "SERIORI"})
Local cDocMan       := ""
Local cSerMan       := ""
Local dEmiMan       := cToD("//")
Local lDISTMOV	:= SuperGetMV("MV_DISTMOV",.F.,.F.)
Local aDigEnd	:= {}
Local lVer116	:= .T.
Local cCndplim:= SuperGetmv("MV_CNDPLIM",.F.,"1")
Local cFilSD2	:= xFilial("SD2")
Local cFilSD3	:= xFilial("SD3")
Local cFilSDB	:= xFilial("SDB")
Local cFilSF1	:= xFilial("SF1")
Local cFilSF2	:= xFilial("SF2")
Local cFilSF4	:= xFilial("SF4")
Local cFilSF9	:= xFilial("SF9")
Local cFilSWD	:= xFilial("SWD")
Local cFilSWN	:= xFilial("SWN")
Local cFilSWW	:= xFilial("SWW")
Local lITEMSWN	:= .F.
Local lDOCSWN		:= .F.
Local lBENSATF	:= .F.
Local eJ       := 0
Local eK       := 0
Local aCalCod  := {}
Local nLenCon  := 0
Local cFormLib:=""
Local lFormLib:=.F.
Local cNumb		:= ""
Local cLvroRetC  := SuperGetMV("MV_LVRORIC",,"") //Número de libro para ret. de IVA al 0% (Ecuador)
Local lGenXML   := .T.
Local cCFDUso   := Alltrim(GetMv("MV_CFDUSO", .T., "1"))
Local cFunName    := IIf(Type("cFunName")=="U", FunName(), cFunName)
Local cVersion := GetRpoRelease()
Local lLxChkAtF := FindFunction("LxChkAtF")
Local cMVVeiculo := SuperGetMv("MV_VEICULO",.F.,"N")
Local lMvLocBac		:= SuperGetMv("MV_LOCBAC",.F.,.F.) .And. FindFunction("LOCM008") //Integração com Módulo de Locações SIGALOC
Local lChiAnuNCC:=  FINDFUNCTION("fGuNDanuNC")
If cPaisLoc <> "ARG"
	lContrFol     :=  cPaisLoc $ "BOL"	.And. ((AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720|MATA143") .Or. ChkProp("ControlFolios")) ;
	                  .And. GetNewPar("MV_CTRLFOL",.F.)
Else
	lContrFol     := ((AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720|MATA462R") .Or. ChkProp("ControlFolios")) .And. GetNewPar("MV_CTRLFOL",.F.)
EndIf
aCfgNf 				:= {}   			//Array com todas as config. da NF, ver conteudo na funcao LOCXNF
//Variaveis utilizadas para serem utilizadas como referencia nos PE
Private nNFTipo  := 0			//Tipo da NF Numerica  (1,2,3,4,5,6,7,8,9,....)
Private cNFTipo	 := ""			//Tipo da NF caractere ("N|D|C|B..."
Private aRecIMP	:=	{}
Private lInclui   := .T.
Private nTotDup		:= 0
Private a100CliFor  := ""
Private aPE			:= Array(SnMaxPE,2)
lLocxAuto 			:=	Iif(Type("lLocxAuto") <> "U", lLocxAuto, .F. )
Default aPergs      := {}
Default aRatCC		:= {}
Default aFin 		:= {}
Default lTela		:= .F.
Default aRecsSF1 	:= {}
Default aDupl    	:= {}
DEFAULT cNota		:=	cNFiscal
Default aGetsTela   := {}
Default __aCodLocs	:= {}
If ValType('nTaxa') == 'U'
	Private 	nTaxa
Endif
If ValType('nMoedaNF') == 'U'
	Private 	nMoedaNF
Endif
If ValType('cNFiscal') == 'U'
	Private 	cNFiscal
Endif
If ValType('cSerie') == 'U'
	Private 	cSerie
Endif
If ValType('cEspecie') == 'U'
	Private	cEspecie
Endif
If ( Type("l103Auto") == "U" )
	Private l103Auto:= lLocxAuto
EndIf
If Type('aRecnoSE1') == 'U'
	Private	aRecnoSE1:={}
Endif
If !IsMemVar("lGerarCFD")
	Private lGerarCFD:= .F.
EndIf
If !IsMemVar("cPathXML")
    Private cPathXML := ""
EndIf
If Type('lDocSp') == 'U'
	Private	lDocSp := .F.
Endif
If Type('lAutoFact') == "U"
	Private lAutoFact := .F.
EndIf
Private laRatEvEz := (Type ("aRatEvEz") <> "U" .AND. aRatEvEz <> Nil)//contenido para multi naturaleza
Private lMultNat  := SuperGetMv("MV_MULNATP") // multiples modalidades Ctas/Pagar
Private lProrrCC  := SuperGetMv("MV_MULNATS") //porrateo CC
Default lModelGrav	:= .F.
/*³Verificacao/definicao das variaveis utilizadas para distinguir NF de import.a das das demais.                                    ³*/
lFacImport	:=	If(Type("lFacImport")	<>"L",.F.	,lFacImport)
l103Class	:=	If(Type("l103Class")	<>"L",.F.	,l103Class)
l103Visual	:=	If(Type("l103Visual")	<>"L",.F.	,l103Visual)
aRatAFN 	:=	If(Type("aRatAFN")		<>"A",{}	,aRatAFN)	 //Variavel private utilizada na itegracao com o PMS
lUsaCor		:=	If(Type("lUsaCor")		<>"L",.F.	,lUsaCor)	 //Utilizacao do correlativo de compras
If FunName() == "MATA101N" .And. lInclui .And. (nPosRateio*nPosRemito*nPosItemRem > 0) .And.;
	aCols[n][nPosRateio] == "1" .And. !Empty(aCols[n][nPosRemito]) .And. !Empty(aCols[n][nPosItemRem]) .And. lLeSDE .And. Len(aRatCC) == 0
	aRatCC := BuscaSDE()[3]
EndIf
//³Montando array com todas as configuracoes da NF que sera gravada, utilizadas durante toda a
//³gravacao. Cada pos. desse array servira como flag para atualizacao de arquivos e processos
aCfgNf  := MontaCfgNf(nTipo,aPergs,lTela)
//³Montando array de pontos de entrada³
aPE	   := aClone(aCfgNf[SaPE])
//³Ponto de Entrada para numeracao da NF³
cPe	:=	LocxPE(24)
If !Empty(cPE)
	xRet  := ExecBlock(cPE,.F.,.F.,{"1",Nil})
	If ValType(xRet) == "L"
	   If !xRet
	      Return .F.
	   EndIf
	EndIf
EndIf
//Geracao Fat.Eletronicas
If Type("lGerarCFD") != "L"
	lGerarCFD := .F.
	aGerarCFD := {}
	If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
		aGerarCFD := CFDVerific()
		If aGerarCFD[1] <> "0"
			If Empty(aGerarCFD[2])
				lGerarCFD := .T.
			Else
	    		If !Empty(aGerarCFD[2]) .AND. !lLocxAuto
					cMsgCFD := ""
					For nX := 1 To Len(aGerarCFD[2])
						cMsgCFD += aGerarCFD[2][nX][2] + CRLF
					Next
					MsgAlert(cMsgCFD,STR0248)
				Endif
			Endif
		Else
			lGerarCFD := .F.
		Endif
	Endif
Endif
If Type("cCompOnL") != "L"
	cCompOnL := SuperGetMV("MV_NCCONL",.F.,"")
EndIf
//Opción de compensación OnLine
If Valtype(cCompOnL) == "U" .Or. Empty(cCompOnL) .Or. !(cCompOnL $ "1|2|3")
	If cPaisLoc == "MEX" .And. cCFDUso <> "0"
		cCompOnL := "1" //Fact. Electrónica y compensa en línea
	Else
		cCompOnL := "3" //NO Fact. Electrónica y compensa en línea
	EndIf
EndIf
//³Iniciando Trasacoes³
begin transaction
	//³Consistindo param.³
	Aadd(aPars, {"nTipo"	,nTipo		,SpValor	,1	,65})
	Aadd(aPars, {"aCitens"	,aCitens	,SpEmpty		   })
	Aadd(aPars, {"aCpItens"	,aCitens	,SpEmpty		   })
	Aadd(aPars, {"aCabNota",aCabNota	,SpLenArray	,2	,3 })
	Aadd(aPars, {"aCabNota",aCabNota[1]	,SpEmpty		   })
	Aadd(aPars, {"aCabNota",aCabNota[2]	,SpEmpty		   })
	lRet := LocxParam("GRAVANFGERAL",aPars)
	//³Verifica Natureza Financeira a ser utilizada no titulo quando NF gerada por Despacho³
	CheckNat()
	//³Ponto de entrada antes de iniciar a gravacao da NF³
	cPe	:=	LocxPE(4)
	If lRet .AND. !Empty(cPE)
		ExecBlock(cPE,.F.,.F.)
	Endif
	If lRet .And. Type("cCondicao") <> "U"
		If aCfgNf[SAliasHead] == "SF2" .And. Alltrim(aCfgNf[ScEspecie]) == "NF"
			dbSelectArea("SE4")
			dbSetOrder(1)
			If SE4->(MsSeek(xFilial("SE4") + cCondicao))
				If M->F2_VALMERC > SE4->E4_SUPER .AND. SE4->E4_SUPER <> 0 .And. cCndplim=="1"
				    Help(" ","1","LJLIMSUPER")
					lRet := .F.
				ElseIf M->F2_VALMERC < SE4->E4_INFER .AND. SE4->E4_INFER <> 0 .And. cCndplim=="1"
					Help(" ","1","LJLIMINFER")
					lRet := .F.
				 EndIf
			EndIf
		 EndIf
	EndIf
	If lRet
		//³Acertando parametro aCitens e aFin³
		Aeval(aCitens, { |x,y| Asize(aCitens[y],Len(aCpItens)+1), If(Empty(x[Len(x)]),x[Len(x)]:=.F.,) })
		Asize(aFin, SnMaxFin)
		lRet    := !Empty(aCfgNf)
		nNF		:= Ascan(aCabNotaOri[1],PrefixoCpo(aCfgNf[SAliasHead])+ "_DOC")
		cNFiscal := cNota
		If nNF > 0 .AND. aCabNota[2][nNF] <> cNFiscal
			aCabNota[2][nNF]   	:= cNFiscal
			aCabNotaOri[2][nNF]	:= cNFiscal
		EndIf
	Endif
	If lRet
		//³Iniciando Fiscal, se necessario                      ³
		//³Se for sem tela, os dados das linhas e do cabecalho  ³
		//³teme que vir com os dados fiscais necesarios para o  ³
		//³calculo de impostos preenchidos.                     ³
		If !MaFisFound()
			InicializaFis(MontaHeader(aCpItens),aCItens,aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[ScTipoDoc],.T.)
		Endif
		//³Inicializa as variaveis do CABECALHO DA NF³
		AEVAL(aCabNota[1],{|x,y| &("M->"+x) :=	Nil})
		nNFTipo  := aCfgNf[SnTipo]
		cNFTipo	:= aCfgNf[ScTipoDoc]
		cEspecie := aCfgNf[ScEspecie]
		cPrefC	:= aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])
		//³Se nao houver aCols declarado ou estiver em branco, preenche um novo aCols³
		If 	(	Type("aCols") == "U"  .OR.;
			Empty(aCols) 			   .OR.;
			Len(aCols) != Len(aCitens))
			aCols   := aCitensOri
			aHeader := MontaHeader(aCpItensOri)
		EndIf
		//³Retira os itens deletados do aCols e trabalha apenas com os itens validos.       ³
		//³E necessaria esta alteracao dentro desta rotina pois as atualizacoes referentes  ³
		//³aos itens da NF sao feitas depois da gravacao dos itens e a partir de entao      ³
		//³a rotina se baseia no proprio arquivo gravado sendo preciso que o aCols contenha ³
		//³apenas as informacoes gravadas para que nao exista nenhum problema com futuras gravacoes  ³
		aSavaCols 	:= aClone(aCols)
		Aeval(aCitens	, { |x,y| IIf( x[Len(x)], Aadd(aLdel,y), ) })
		For nX	:= Len(aLdel) TO 1 STEP -1
			Adel(aCitens,aLdel[nX])
		Next
		ASize(aCItens,Len(aCItens)-Len(aLdel))
		//³Acerta preenchimento de campos de valore automaticos/padrao de cabecalho³
		aAux 		:= CposAutoNf(aCfgNf[SAliasHead],aCfgNf[ScCliFor],aCfgNf[SlFormProp],aCabNotaOri[1],{aCabNotaOri[2]},aCfgNf[ScTipoDoc])
		aCabNota[1]	:= aAux[1]
		aCabNota[2]	:= aAux[2][1]
		//³Inicializa variaveis privates necesarias em outras rotinas padrao do sistema. ³
		If aCfgNF[SAliasHead] == "SF1"
			nTaxa		:=	M->F1_TXMOEDA
			nMoedaNF	:=	M->F1_MOEDA
			cNFiscal  	:=  M->F1_DOC
			cSerie    	:=	M->F1_SERIE
		Else
			nTaxa		:=	M->F2_TXMOEDA
			nMoedaNF	:=	M->F2_MOEDA
			cNFiscal  	:=	M->F2_DOC
			cSerie    	:=	M->F2_SERIE
		EndIf
		//³Acerta preenchimento de campos de valore automaticos/padrao de itens    ³
		aAux 		:= CposAutoNf(aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[SlFormProp],aCpItensOri,aCitensOri,aCfgNf[ScTipoDoc])
		aCpItens	:= aAux[1]
		aCitens	:= aAux[2]
		//³Ponto de entrada para incluir campos customizados no cabeçalho da nota  ³
		cPe	:= LocxPE(72)
		If !Empty(cPe) .And. ValType(aCabNota)=="A" .And. Type("aAutoCab")=="A"
			aRetPe72:=ExecBlock(cPE,.F.,.F.,{aCabNota,aAutoCab})
			If ValType(aRetPe72) == "A" .and. len(aRetPe72)>0
				aCabNota:=aRetPe72
			EndIf
		Endif
		//³Acertando parametro aCabNota³
		Asize(aCabNota, 3)
		aCabNota[3] := IIf(Empty(aCabNota[3]) .OR. ValType(aCabNota[3]) != "A", {}, aCabNota[3])
		Asize(aCabNota[3], Len(aCabNota[1]))
		Aeval(aCabNota[3], {|x,y| If(x==NIL,aCabNota[3][y]:=.F.,)})
		//³Efetua a consistencia de todos os campos que devem ser gravados tanto no cabecalho como nos itens da NF³
		//³A rotina de consistencia adiciona formulas para campos que devem ser gravados, nao foram passados mas possuem   ³
		//³um conteudo padrao. Isso faz com as posicoes incluidas com uma formula nos array's de conteudos sejam um array  ³
		//³de duas posicoes. A primeira e a formula e a segunda e o indicador de que e uma formula						       ³
		If aCfgNf[SaAtualiza][SlConsist] .and. !lModelGrav
			If !ConsisteNf(aCfgNf,@aCabNota,@aCitens,aCpItens,lTela)
				Alert(STR0034)
				lRet := .F.
			EndIf
		EndIf

		If lRet
			//Processa a gravacao do ID do cabecalho para garantir a integridade referencial antes de gravar os itens
	        nRecnoC := GravaCabNF(aCabNota,aCfgNf[SAliasHead],.T.,cHash)
			//Verifica todos os campos que devem ser totalizados³
			AEval(aCabNota[3], { |x,y| If(aCabNota[3][y],AADD(aCpTotal, aCabNota[1][y]),),If(aCabNota[3][y],AADD(aFormTot, aCabNota[2][y]),) })
			//³Guarda o tipo de remito definido no cabecalho para atualizacao dos itens ³
			If aCfgNf[SAliasHead]=="SF2"
				cTipoRem := aCabNota[2][aScan(aCabNota[1],"F2_TIPOREM")]
			EndIf
			//Grava os itens da NF a partir dos param. aCitens e aCpItens e armazena o numero
			//de cada registro gravado no array aRecnoI como tambem efetua o calculo dos campos totalizadores
			aAux    := GravaItensNF(aCitens,aCpItens,aCfgNf[SAliasCols],{aCpTotal,aFormTot},aCfgNf[ScCliFor],aCfgNf[ScTipoDoc],cTipoRem)
			aRecnoI := aAux[1]
			aRecCols:= aAux[4]
			If aRecnoI == NIL
				lRet := .F.
			EndIf
			If cPaisLoc == "RUS" .AND. aCfgNF[SAliasHead] == "SF1"
				AADD(aCabNota[1], "F1_F5QUID")
				AADD(aCabNota[2], M->F1_F5QUID)
				AADD(aCabNota[3], .F.)
			ElseIf cPaisLoc == "RUS" .AND. aCfgNF[SAliasHead] == "SF2"
				AADD(aCabNota[1], "F2_F5QUID")
				AADD(aCabNota[2], M->F2_F5QUID)
				AADD(aCabNota[3], .F.)
			EndIf
			If lRet
				//³Verifica os campos totalizadores e inclui os mesmo no array de cabecalho³
				nI := 0
				For nI := 1 to len(aAux[2])
					nPos := Ascan(aCabNota[1], aAux[2][nI])
					If nPos > 0
						aCabNota[2][nPos] := aAux[3][nI]
					Else
						AADD(aCabNota[1], aAux[2][nI])
						AADD(aCabNota[2], aAux[3][nI])
					EndIf
				Next nI
				//³Grava cabecalho da NF a partir do parametro aCabNota e armazena numero do registro gravado³
			    (aCfgNf[SAliasHead])->(MsGoto( nRecnoC))  // garante que se posiciona no Id do cabecalho ja gravado
				nRecnoC := GravaCabNF(aCabNota,aCfgNf[SAliasHead],.F.)
				If aCfgNF[SAliasHead] == "SF2" .And. nPNfOri > 0 .And. nPSerOri > 0
					RecLock("SF2",.F.)
					SF2->F2_NFORI := acols [1][nPNfOri] //Doc Orig
					SF2->F2_SERIORI	:= aCols [1][nPSerOri]	//Serie Doc. Orig
					MsUnLock()
				ElseIf aCfgNF[SAliasHead] == "SF1" .And. nPNfOri > 0 .And. nPSerOri > 0
					RecLock("SF1",.F.)
					SF1->F1_NFORIG := acols [1][nPNfOri] //Doc Orig
					SF1->F1_SERORIG	:= aCols [1][nPSerOri]	//Serie Doc. Orig
					MsUnLock()
				EndIf
				If nRecnoC <= 0
					lRet := .F.
				EndIf
				If lRet
					//³Posicionando todos os arquivos que devem ser utilizados na atualizacao de processos a paritr ³
					//³do cabecalho da NF. Nao devem ser efetuados "Seek's" em nenhum arquivo a nao ser 	³
					//³dentro desta rotina ou na rotina PosicionaI, nao sendo estritamente necessario	 			³
					PosicionaC(aCfgNf[SAliasHead],nRecnoC,aCfgNf[ScCliFor])
					//³Verifica se e necessario inicializar as variaveis referentes ao tratamento de impostos³
					If !MaFisFound()
						If !InicializaFis(MontaHeader(aCpItens),aCItens,aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[ScTipoDoc])
							lRet := .F.
						EndIf
					EndIf
					If lRet
						//³Verifica se algum item deve gerar pedido de venda, de acordo com o campo virtual D1_GERAPV³
						//³somente quando for devolucao de venda. Isto se faz necessario pelo fato de que este campo ³
						//³nao existe no arquivo e o aCitens ou aCols nao e utilizado dentro da funcao VarreItNf	 ³
						If aCfgNf[SAliasCols] == "SD1" .AND. aCfgNf[ScTipoDoc] == "D"
							nPos := aScan(aCpItens, "D1_GERAPV")
							If nPos > 0
								Aeval(aCitens, { |x,y| Aadd( aGeraPv, IIf(x[nPos]=="S",.T.,.F.) ) })
							EndIf
						EndIf
						//³Efetua todas as atualizacoes referentes aos itens da NF. Varre todos os itens e efetua³
						//³todas as atualizacoes necessarias para cada um												  ³
						If !l103Class
							If !VarreItNf(aClone(aCfgNf),aClone(aRecnoI),nRecnoC,aClone(aRatCC),aClone(aGeraPv),aRecsSF1,@aDigEnd)
								lRet := .F.
							EndIf
						Else
							If aCfgNf[SAliasCols] == "SD1" .AND. ( Empty(SF1->F1_TIPO_NF) .OR. (SF1->F1_TIPO_NF == "5" .AND. GetNewPar("MV_CUSTIMP","1") $ "1|2") )
								If !VarreItNf(aClone(aCfgNf),aClone(aRecnoI),nRecnoC,aClone(aRatCC),aClone(aGeraPv),aRecsSF1,@aDigEnd)
									lRet := .F.
								EndIf
							EndIf
						EndIf
						If ( ( aCfgNf[SnTipo] == 54 .AND. M->F2_TIPORET == '2' ) .OR. aCfgNf[SnTipo] == 64 )
							For nI := 1 To Len(aRecnoI)
								If  aCfgNf[SnTipo] == 64
									cFilAnt := M->F1_FILORIG
								EndIf
								lRet := GerSD3Trf(aCfgNf[SAliasCols],aRecnoI[nI,1],IIf(aCfgNf[SnTipo] == 54,1,2),cFilOri)
								If  aCfgNf[SnTipo] == 64
									cFilAnt := cFilOri
								EndIf
							Next nI
						EndIf
						//³ Efetua a Atualizacao da Assistencia Tecnica Somente para os paises localizados
						//³ Obs.: A Geração quando o item não utiliza localização é feita na função GravaItensNF()
						For nI := 1 To Len(aRecnoI)
							If aCfgNf[SAliasCols]=="SD2" .AND. (cPaisLoc $ "ARG|PAR|URU|CHI|MEX|EUA|POR|BOL")
								SD2->(MsGoTo(aRecnoI[nI,1]))
								If ( SF4->F4_ATUTEC=="S" )
									If ( Localiza(SD2->D2_COD) )
										dbSelectArea("SDB")
										dbSetOrder(1)
										If ( MsSeek(cFilSDB+SD2->D2_COD+SD2->D2_LOCAL+SD2->D2_NUMSEQ+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA) )
											dbEval({|| 	AtTrfEqpto(SD2->D2_CODFAB,SD2->D2_LOJAFA,SD2->D2_COD,SDB->DB_NUMSERI,SD2->D2_CLIENTE,SD2->D2_LOJA) },;
											   		{|| !Empty(SDB->DB_NUMSERI)},;
													{|| 	xFilial("SDB")	==	SDB->DB_FILIAL .And.;
														SD2->D2_COD		==	SDB->DB_PRODUTO .And.;
														SD2->D2_LOCAL  == SDB->DB_LOCAL .And.;
														SD2->D2_NUMSEQ == SDB->DB_NUMSEQ .And.;
														SD2->D2_DOC		== SDB->DB_DOC .And.;
														SD2->D2_SERIE	== SDB->DB_SERIE .And.;
														SD2->D2_CLIENTE== SDB->DB_CLIFOR .And.;
														SD2->D2_LOJA	== SDB->DB_LOJA },,,.T.)
										EndIf
									EndIf
								EndIf
							EndIf
						Next
						//³Efetua a Atualização da Assistência Técnica Somente para os países localizados
						//³Quando é uma conduce de devolução ou invoice de crédito Trata tanto quando tem localização como também quando não tem localização
						For nI := 1 To Len(aRecnoI)
							If aCfgNf[SAliasCols]=="SD1" .AND. (cPaisLoc $ "ARG|PAR|URU|CHI|MEX|EUA|POR|BOL")
								//³ Estorno da transf. da base instalada - Field Service     ³
								If (SF4->F4_ESTOQUE == "S" .And. SF4->F4_ATUTEC == "S")
									SD1->(MsGoTo(aRecnoI[nI,1]))
									SD2->(DbSetOrder(3))
									If SD2->(MsSeek( cFilSD2 + SD1->D1_NFORI + SD1->D1_SERIORI + SD1->D1_FORNECE + SD1->D1_LOJA + SD1->D1_COD + SD1->D1_ITEMORI ))
										//³Verifica se a nota veio de um remito/conduce.³
										If !Empty(SD2->D2_REMITO)
											//³Localiza a conduce dela, pois o movimento de distribuição (SDB) é a dona do movimento.³
											If SD2->(MSSeek(cFilSD2+SD2->D2_REMITO+SD2->D2_SERIREM+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMREM))
												MaEstNfAA3()
											EndIf
										Else
											MaEstNfAA3()
										EndIf
									EndIf
								EndIf
							EndIf
						Next
						//³Libera Faturas de import.  ³
						If lRet .AND. aCfgNf[SAliasCols] == "SD1"
							If !Empty(SF1->F1_HAWB)
								If lBloqImp
								   BloqFatImp()
								EndIf
							EndIf
			            EndIf
						If lRet
							//³Grava Impostos³
							If aCfgNf[SaAtualiza][SlAtuImp] .AND. (!l103Class .OR. (SF1->F1_TIPO_NF=="9" .AND. SuperGetMV("MV_DESPSD1",,"N")=="S"))
								If !GravaImposto(aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aClone(aCpItens),aClone(aCitens),aCfgNf[ScTipoDoc],nRecnoC,aRecCols,.F.)
									lRet := .F.
								EndIf
							EndIf
							If lRet
								//³Acerta livro Fiscal³
								If aCfgNf[SaAtualiza][SlAtuLF]
									MaFisAtuSF3(1,IIf(aCfgNf[SAliasHead]=="SF1","E","S"),nRecnoC,aCfgNf[SAliasHead])
									SF3->(MsUnLock())

									//Leandro Prado - 06/03/2014 - Controle de Ponto de venda para argentina
									If (cPaisLoc == "ARG")
										ArgGeraLF(lFolios,aCfgNF)
									EndIf
									If lUsaCor     //atualiza o numero correlativo
										aAreaAnt:=GetArea()
										DbSelectArea("SF3")
										aSF3:=GetArea()
										DbSetOrder(1)
										cChSF3:=xFilial("SF3")
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DTDIGIT"
										cChSF3+=DTOS(&cCorrelat)
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC"
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE"
										cChSF3+=&cCorrelat
										cCorrelat:=IF(aCfgNf[SAliasHead]=="SF1","F1_FORNECE","F2_CLIENTE")
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA"
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_NUMCOR"
										cCorrelat:=&cCorrelat
										dbSeek(cChSF3)
										While !SF3->(EOF()) .AND. F3_FILIAL+DTOS(F3_ENTRADA)+F3_NFISCAL+F3_SERIE+F3_CLIEFOR+F3_LOJA==cChSF3
											RecLock("SF3",.F.)
											Replace F3_NUMCOR With cCorrelat
											MsUnlock()
											DbSkip()
										End
										RestArea(aSF3)
										RestArea(aAreaAnt)
									Endif
									If lGerarCFD .And. !(cPaisLoc $ "COL|PAR")		//Comprovante fiscal digital
										aAreaAnt:=GetArea()
										DbSelectArea("SF3")
										aSF3:=GetArea()
										DbSetOrder(1)
										cChSF3:=xFilial("SF3")
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DTDIGIT"
										cChSF3+=DTOS(&cCorrelat)
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC"
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE"
										cChSF3+=&cCorrelat
										cCorrelat:=IF(aCfgNf[SAliasHead]=="SF1","F1_FORNECE","F2_CLIENTE")
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA"
										cChSF3+=&cCorrelat
										cAproFol:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_APROFOL"
										cCertFol:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_CERTFOL"
										MsSeek(cChSF3)
										While !SF3->(EOF()) .AND. F3_FILIAL+DTOS(F3_ENTRADA)+F3_NFISCAL+F3_SERIE+F3_CLIEFOR+F3_LOJA==cChSF3
											RecLock("SF3",.F.)
											Replace F3_APROFOL With &(cAproFol)
											Replace F3_CERTFOL With &(cCertFol)
											MsUnlock()
											DbSkip()
										End
										RestArea(aSF3)
										RestArea(aAreaAnt)
									Endif
									//³Ponto de Entrada apos gravacao do livro fiscal³
									If cPaisLoc == 'EUA'
										cPe	:= SF3ZONFIS(aCfgNf, cFunname)
									EndIf

									cPe	:= LocxPE(5)

									If !Empty(cPE)
										ExecBlock(cPE,.F.,.F.)
									EndIf
									//³Controle de Folios  ³
									If lContrFol .And. (!cPaisLoc $'ARG|EQU|VEN|PER|DOM')
										aAreaAnt:=GetArea()
										DbSelectArea("SF3")
										aSF3:=GetArea()
										DbSetOrder(1)
										cChSF3:=xFilial("SF3")
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DTDIGIT"
										cChSF3+=DTOS(&cCorrelat)
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC"
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE"
										cChSF3+=&cCorrelat
										cCorrelat:=IF(aCfgNf[SAliasHead]=="SF1","F1_FORNECE","F2_CLIENTE")
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA"
										cChSF3+=&cCorrelat
										cNumAut :=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_NUMAUT"
										cCodCtr:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_CODCTR"
										MsSeek(cChSF3)
										While !SF3->(EOF()) .AND. F3_FILIAL+DTOS(F3_ENTRADA)+F3_NFISCAL+F3_SERIE+F3_CLIEFOR+F3_LOJA==cChSF3
											RecLock("SF3",.F.)
											Replace F3_NUMAUT  With &(cNumAut)
											Replace F3_CODCTR With &(cCodCtr)
											MsUnlock()
											DbSkip()
										End
										RestArea(aSF3)
										RestArea(aAreaAnt)
										//³Gera Numero de Autorizacao e Codigo de Controle ³
										aDados[1] := &(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE")
										aDados[2] := &(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_ESPECIE")
										aDados[3] := &(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC")
										If aCfgNF[SAliasHead] == "SF2"
											If Alltrim(aDados[2])$"NDI/NCP"
												aDados[4] := Posicione("SA2",1,xFilial("SA2")+SF2->F2_CLIENTE+SF2->F2_LOJA,"A2_CGC")
											Else
												aDados[4] := Posicione("SA1",1,xFilial("SA1")+SF2->F2_CLIENTE+SF2->F2_LOJA,"A1_CGC")
											Endif
											aDados[5] := DtoS(SF2->F2_EMISSAO)
											aDados[6] := IIf(Alltrim(SF2->F2_ESPECIE)=="NF",Round(SF2->F2_VALBRUT,0),SF2->F2_VALBRUT)
										Else
											If Alltrim(aDados[2])$"NDE/NCC"
												aDados[4] := Posicione("SA1",1,xFilial("SA1")+SF1->F1_FORNECE+SF1->F1_LOJA,"A1_CGC")
											Else
												aDados[4] := Posicione("SA2",1,xFilial("SA2")+SF1->F1_FORNECE+SF1->F1_LOJA,"A2_CGC")
											Endif
											aDados[5] := DtoS(SF1->F1_EMISSAO)
											aDados[6] := IIf(Alltrim(SF1->F1_ESPECIE)=="NF",Round(SF1->F1_VALBRUT,0),SF1->F1_VALBRUT)
										Endif
										aRetCF := RetCF(aDados)
										//³Grava Numero de Autorizacao e Codigo de Controle³
										//³Tabelas: SF1 e/ou SF2 e SF3                     ³
										If !Empty(aRetCF[1])
											If aCfgNF[SAliasHead] == "SF2"
												RecLock("SF2",.F.)
												SF2->F2_NUMAUT	:= aRetCF[1]	//Numero de Autorizacao
												SF2->F2_CODCTR	:= aRetCF[2]	//Codigo de Controle
												SF2->F2_LIMEMIS	:= aRetCF[3]	//Data Limite de Emisao
												MsUnLock()
												cKey := xFilial("SF3")+SF2->(DtoS(F2_DTDIGIT)+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA)
											Else
												RecLock("SF1",.F.)
												SF1->F1_NUMAUT	:= aRetCF[1]	//Numero de Autorizacao
												SF1->F1_CODCTR	:= aRetCF[2]	//Codigo de Controle
												If cPaisLoc == "BOL" .and. cFunName $ "MATA143"
												 	GrvSF1Bol()
												Else
													If Empty(aRetCF[2]).AND. !Empty(M->F1_CODCTR)
													  	SF1->F1_CODCTR := M->F1_CODCTR
													EndIf
													If !Empty(M->F1_NUMAUT)
														SF1->F1_NUMAUT := M->F1_NUMAUT
													EndIf
												EndIf
												MsUnLock()
												cKey := xFilial("SF3")+SF1->(DtoS(F1_DTDIGIT)+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA)
											Endif
										Else
											If aCfgNF[SAliasHead] == "SF2"
												aRetCF[1] := SF2->F2_NUMAUT		//Numero de Autorizacao
												aRetCF[2] := SF2->F2_CODCTR		//Codigo de Controle
												aRetCF[3] := SF2->F2_LIMEMIS	//Data Limite de Emisao
												cKey := xFilial("SF3")+SF2->(DtoS(F2_DTDIGIT)+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA)
											Else
												If cPaisLoc == "BOL" .and. cFunName $ "MATA143"
													GrvSF1Bol()
												Else
													aRetCF[1] := SF1->F1_NUMAUT		//Numero de Autorizacao
													aRetCF[2] := SF1->F1_CODCTR		//Codigo de Controle
												Endif
												cKey := xFilial("SF3")+SF1->(DtoS(F1_DTDIGIT)+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA)
											EndIf
										Endif
										If !(cPaisLoc $ 'BOL')
											aAreaAnt:= GetArea()
											aSF3	:= SF3->(GetArea())
											dbSelectArea("SF3")
											dbSetOrder(1)
											If MsSeek(cKey)
												While !SF3->(EOF()) .AND. SF3->(F3_FILIAL+DTOS(F3_ENTRADA)+F3_NFISCAL+F3_SERIE+F3_CLIEFOR+F3_LOJA) == cKey
													RecLock("SF3",.F.)
													SF3->F3_NUMAUT := aRetCF[1]		//Numero de Autorizacao
													SF3->F3_CODCTR := aRetCF[2]		//Codigo de Controle
													If aCfgNF[SAliasHead] == "SF1"
														If Empty(aRetCF[2]).AND. !Empty(M->F1_CODCTR)
															SF3->F3_CODCTR := M->F1_CODCTR
														EndIf
														If !Empty(M->F1_NUMAUT)
															SF3->F3_NUMAUT := M->F1_NUMAUT
														EndIf
													EndIf
													MsUnlock()
													dbSkip()
												Enddo
											Endif
											RestArea(aSF3)
											RestArea(aAreaAnt)
										EndIf
									Endif
									/*Actualización SF3 - País Bolivia*/
									If cPaisLoc == "BOL"
										LxGrvLFBol(aCfgNF, aRetCF, lContrFol, cKey, cFunname)
									EndIf
								EndIf
								// Controle de Honorarios Chile
								If cPaisLoc == "CHI"
									LxGrvLFChi(aCfgNf[SAliasHead]) //Actualiza SF3
								Endif
								//³Verifica se e necessario inicializar as variaveis referentes a gravacao de impostos³
								If !MaFisFound()
									If !InicializaFis(MontaHeader(aCpItens),aCItens,aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[ScTipoDoc])
										lRet := .F.
									EndIf
								EndIf
								If cPaisLoc == "EUA" .AND. lLocxAuto .AND. lMultNat.AND. lProrrCC .AND. laRatEvEz // rutina automatica multinaturaleza y prorrateo de centros de costo EUA
									Multiauto(@aColsSEV,@aHeadSEV,"SE2","SEV") //Obtiene estructura encabezado y detalle para SEV
									If !FinSEVAut(aRatEvEz,@aColsSEV,@aHeadSEV) // valida valores SEV y SEZ y asigna a tabla temporal
										 lRet := .F.
									Endif
								EndIf
								If lRet
									If If(lFacImport,!lEICFinanc,.T.)
										//³Atualiza Financeiro - Comissoes³
										If !Empty(aCfgNf[ScEspecie]) .AND. !Empty(aCfgNf[ScOpFin]) .AND. aCfgNf[SaAtualiza][SlAtuFina]
											a100CliFor := &(cPrefC+IIf(aCfgNf[SAliasHead]=="SF1","_FORNECE","_CLIENTE"))
											nValor 	   := MaFisRet(,"NF_BASEDUP")
											//³Ponto de Entrada que permite alterar o valor total da Nota para base de calculos das duplicatas³
											cPe	:=	LocxPE(6)
											If !Empty(cPE)
												nValor := ExecBlock(cPe,.F.,.F.)
												If nValor <> MaFisRet(,"NF_BASEDUP")
													MaFisAlt(cPe,nValor)
												EndIf
											EndIf
											//Quando houver adiantamento vinculado devera gerar financeiro
											If nValor>0 .OR. (cPaisLoc  $ "MEX|PER|RUS" .AND. MaFisRet(,"NF_ADIANT") > 0) //jgr
												GravaFina(aCfgNf[SAliasHead],aCfgNf[ScAliasFin],aDupl,aCfgNf[ScEspecie],aCfgNf[ScOpFin],aCfgNf[ScTipoDoc],aFin,aRecnoI,aRecnoSE1)
											EndIf
										EndIf
									Endif
								EndIf //lRet
								//Efetua a atualizacao do Ativo Imobilizado - (SN1-SN2-SN3)
								If lRet
									If aCfgNf[SnTipo] == 10 .Or. aCfgNf[SnTipo] == 60	//Apenas doc. entrada
										nI := 0
										nV := 0
										lBENSATF := .T.
										aAreaASD1:=SD1->(GetArea())
										aAreaASF4:=SF4->(GetArea())
										aAreaASF9:=SF9->(GetArea())
										If Type("inclui") == "U"
											inclui := .T.	//Private utilizada na funcao abaixo que e do padrao
										EndIf
										If Type("altera") == "U"
											altera := .F.  //Private utilizada na funcao abaixo que e do padrao
										EndIf
										For nI := 1 to Len(aRecnoI)
											SD1->(MsGoTo(aRecnoI[nI,1]))
											SF9->(DbSetOrder(1))
											SF9->(MsSeek(cFilSF9+SD1->D1_CODCIAP))
											SF4->(DbSetOrder(1))
											SF4->(MsSeek(cFilSF4+SD1->D1_TES))
											If SF4->F4_ATUATF == "S"
												If aCfgNf[SnTipo] == 10 .And. lLxChkAtF .And. !LxChkAtF()
													Loop	// Es factura de entrada y ya se registró en remisión, ir al siguiente ítem
												EndIf
												cBaseATF := ""
												If lBENSATF .And. SF4->F4_BENSATF == "1" .And. SD1->D1_QUANT >= 1
													If cPaisLoc == "PER"
														Private aCampos    := {}
														Private aBkpHeader := {}
														Private aBkpAcols  := {}
													EndIf
													For nV := 1 To Int(SD1->D1_QUANT)
														//#Brasil#
														//If cPaisLoc == "BRA"
															//a103GrvAtf(1,@cBaseATF,StrZero(nV,Len(SN1->N1_ITEM)),SD1->D1_CODCIAP,IIf(SF4->F4_CIAP=="S".AND.SD1->D1_VALICM>0.AND.SF4->F4_CREDICM=="S",SF9->F9_VALICMS,0))
														//Else
															If !lActFjRm
																a103GrvAtf(1,@cBaseATF,StrZero(nV,Len(SN1->N1_ITEM)),"",0,,,aRatCC)
																If cPaisloc	== "RUS"
																	cNumb+=cBaseATF +", "
																	cBaseATF := ""
																EndIF
															Endif
														//EndIf
													Next
												Else
													//#Brasil#
													//If cPaisLoc == "BRA"
														//a103GrvAtf(1,@cBaseATF,StrZero(nI,Len(SN1->N1_ITEM)),SD1->D1_CODCIAP,IIf(SF4->F4_CIAP=="S".AND.SD1->D1_VALICM>0.AND.SF4->F4_CREDICM=="S",SF9->F9_VALICMS,0))
													//Else
														If !lActFjRm
															a103GrvAtf(1,@cBaseATF,StrZero(nI,Len(SN1->N1_ITEM)),"",0,,,aRatCC)
															If cPaisLoc == "RUS"
																cNumb+=cBaseATF +", "
															EndIf
														EndIf
													//EndIf
												Endif
											EndIf
											Next nI
											RestArea(aAreaASD1)
											RestArea(aAreaASF4)
											RestArea(aAreaASF9)
											//Ajuste de valor do bem por nota de crédito (Baixa)
										ElseIf AllTrim(cEspecie) $ "NCP|NDI" .And. lIntNtCRDB
											aAreaASD2:=SD2->(GetArea())
											aAreaASF4:=SF4->(GetArea())
											For nI := 1 To Len(aRecnoI)
												SD2->(MsGoTo(aRecnoI[nI,1]))
												SF4->(DbSetOrder(1))
												SF4->(MsSeek(cFilSF4+SD2->D2_TES))
												If SF4->F4_ATUATF == "S"
													lRet := a103GrvAtf( 100 )
												EndIf
											Next nI
											RestArea(aAreaASF4)
											RestArea(aAreaASD2)
											//Ajuste de valor do bem por nota de débito (Incorporação)
										ElseIf AllTrim(cEspecie) $ "NDP|NCI" .And. lIntNtCRDB
											aAreaASD1:=SD1->(GetArea())
											aAreaASF4:=SF4->(GetArea())
											cBaseATF := ""
											For nI := 1 To Len(aRecnoI)
												SD1->(MsGoTo(aRecnoI[nI,1]))
												SF4->(DbSetOrder(1))
												SF4->(MsSeek(cFilSF4+SD1->D1_TES))
												If SF4->F4_ATUATF == "S"
													lRet := a103GrvAtf( 101, @cBaseATF,,,"",0,, aRatCC )
												EndIf
											Next nI
											RestArea(aAreaASF4)
											RestArea(aAreaASD1)
										EndIf
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		If lInclui .And. aCfgNF[SAliasHead] == "SF1" .And. !("NC" $ SF1->F1_ESPECIE)
			If cPaisLoc $ "VEN|COS"
				aDadSFE:={}
				If cPaisloc $ "VEN"
					If (SF1->F1_VALIMP2+SF1->F1_VALIMP3+SF1->F1_VALIMP4)>0 .OR. SF1->F1_VALIMP6>0
				   		Aadd(aDadSFE,{.F.,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE})
				   		FGrvCrt(1,aDadSFE)
				   	EndIf
			   	Else
			   		If cPaisloc == "COS"
				   	    If SF1->F1_VALIMP5 >0 ///retencao de IR
							Aadd(aDadSFE,{.F.,"",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,"RIR",0,0,0,SF1->F1_ESPECIE})
				   			GrvRetSFE(1,aDadSFE,.F.,.T.)
				   		EndIf
				   	EndIf
			   	EndIf
			 EndIf
		Endif
		If lInclui .And. aCfgNF[SAliasHead] == "SF2" .And. ("NCP" $ SF2->F2_ESPECIE)
			If cPaisLoc $ "VEN"
				aDadSFE:={}
				If (SF2->F2_VALIMP2+SF2->F2_VALIMP3+SF2->F2_VALIMP4)>0 .OR. SF2->F2_VALIMP6>0
				   	Aadd(aDadSFE,{.F.,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE})
				   	FGrvCrt(2,aDadSFE)
			   	Endif
			EndIf
		Endif
		If lRet .And. cPaisLoc == "EQU"
			lRet := LxGrvNfEqu(lInclui, aCfgNF, nNFTipo, IIf(Type('cDoctoId') <> 'U', cDoctoId, ""), IIf(Type('cNomeCli') <> 'U', cNomeCli, ""), IIf(Type('aLlaveOrg') <> 'U', aLlaveOrg, {}), IIf(Type("cFunName")<>"U", cFunName, Funname()))
		EndIf
		If lRet .And. cPaisLoc == "CHI"
			lRet := LxGrvNfChi(aCfgNF, lInclui)
			
			IF lChiAnuNCC .AND. ALLTRIM(cEspecie)=="NDC"
				fGuNDanuNC(aCabNotaOri,aCpItensOri,aCitensOri)
			ENDIF
		EndIf
		//factura de entrada para Mexico y actualiza nuevo folio fiscal
		If cPaisLoc == "MEX"
			xGrvCabMex(aCfgNF, nNFTipo, cPathXML, IIf(Type("cFunName")<>"U", cFunName, ""))
		EndIf
		//Notas Fiscais NF, RCTI, NC e ND conforme regra LxVldLim precisam de identificacao
		If cPaisLoc == "URU"
			GravaNFGURU(aCfgNF, lInclui)
		EndIf
		If cPaisLoc=="ARG" .And. Alltrim(cEspecie) $ "NF|NCP|NDP" .and. !aCfgNf[SlFormProp] .and. SF1->(ColumnPos("F1_CC")) > 0 .and. SF2->(ColumnPos("F2_CC")) > 0
			If !Empty(SF1->F1_CC) .OR. !Empty(SF2->F2_CC)
				GRAVACC(aCfgNf[ScCliFor],aCfgNF[SAliasHead],cEspecie)
			EndIf
		EndIf
		If cPaisLoc == "ARG" .AND. GetMV("MV_EASY")=="S" .AND. Alltrim(cEspecie) == "NCP"
			lQtdZero  := .T.
			aCusto    := {}
			aCM       := {}
			cTesEIC   := ""
			nTxCusEIC := 0.00
			aImposto  := {}
			nPosSWN   := 0
			lITEMSWN  := .T.
			lDOCSWN	  := .T.
			DbSelectArea("SWN")
			DbSetOrder(2)
			If dbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
			   While !Eof() .AND.;
			   	  WN_FILIAL == cFilSWN .AND.;
				  WN_DOC == SF2->F2_DOC .AND.;
				  WN_SERIE == SF2->F2_SERIE
				  SD2->(DbSetOrder(3))
				  SD2->(dbSeek(cFilSD2+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA))
				  If WN_TIPO_NF == "N"
				     // Gravar no SD3 a 'DE8' para o Produto
				     RecLock('SD3',.T.)
				     Replace D3_FILIAL  With cFilSD3
					 Replace D3_COD	   With SWN->WN_PRODUTO
					 Replace D3_GRUPO   With SB1->B1_GRUPO
					 Replace D3_TIPO    With SB1->B1_TIPO
					 Replace D3_LOCAL   With SWN->WN_LOCAL
					 Replace D3_UM	   With SB1->B1_UM
					 Replace D3_CONTA   With SB1->B1_CONTA
					 Replace D3_DOC	   With SWN->WN_DOC
					 Replace D3_QUANT   With 0.00
					 Replace D3_CF	   With 'RE8' 	//-- Identifica Movimentacao com Origem no SIGAEIC
					 Replace D3_TM	   With '999'
					 Replace D3_USUARIO With SubStr(cUsuario,7,15)
					 Replace D3_NUMSEQ  With SD2->D2_NUMSEQ
					 Replace D3_EMISSAO With dDataBase
					 Replace D3_CHAVE   With 'E9' 	//-- N„o Alterar !!!
					 Replace D3_QTSEGUM With SWN->WN_QTSEGUM
					 Replace D3_SEGUM   With SB1->B1_SEGUM
					 Replace D3_IDENT   With ""		//cNumSeqD1  //-- Diferencia as Movimentacoes
					 If lDOCSWN
						Replace D3_DOCSWN  With SWN->WN_PO_NUM
					 EndIf
					 If lITEMSWN
						Replace D3_ITEMSWN With SWN->WN_ITEM
					 EndIf
					 MsUnLock()
			         aCusto := {SWN->WN_VALOR,0,0,0,0}
					 SWW->(DbSetOrder(1))
					 If SWW->(MsSeek(cFilSWW+SF2->F2_DOC+SF2->F2_SERIE))
						While ! SWW->(EOF()).AND.SWW->WW_FILIAL==cFilSWW .AND.;
						    SWW->WW_NF_COMP == SF2->F2_DOC     .AND.;
					       	SWW->WW_SE_NFC  == SF2->F2_SERIE
							SWD->(DbSetOrder(3))
				       		If SWD->(MsSeek(cFilSWD+Left(SWW->WW_DESPESA,3)+SWW->WW_NF_COMP+SWW->WW_HAWB))
				       		   cTesEIC   := SWD->WD_TES
							   nTxCusEIC := SWD->WD_TX_MOE
				       		   Exit
				       		EndIf
				       		SWW->(DbSkip())
						End
					 EndIf
					 aImpostos := TesImpInf(cTesEIC) //O tes é o mesmo para todos os itens do SWN
					 For nY:=1 to Len(aImpostos)
					 	nPosSWN :=SWN->(FieldPos("WN_"+Substr(aImpostos[nY][2],4)))
						If nPosSWN > 0
							If ( aImpostos[nY][3]+aImpostos[nY][5] == "SN" )
								aCusto[1][1]+= SWN->(FieldGet(nPosSWN))
							ElseIf ( aImpostos[nY][3]+aImpostos[nY][5] == "NS" )
								aCusto[1][1]-= SWN->(FieldGet(nPosSWN))
							EndIf
						Endif
					 Next nY
					 aCM := AClone(aCusto)
					 For nI := 1 To Len(aCusto)
					 	cMoeda := Str(nI,1)
						If nI > 1 .AND. !Empty(GetMV("MV_MOEDA"+cMoeda))
						    If Empty(nTxCusEic)
						    	nTxCusEic := RecMoeda(dDataBase,nI)
						    EndIf
						    aCM[nI] := aCM[1]/nTxCusEic
						EndIf
					 Next nI
					 aCusto := GravaCusD3(aCM,,,,lQtdZero)
					 B2AtuComD3(aCusto,NIL,NIL,NIL,NIL,.T.)
				EndIf
				DbSelectArea("SWN")
				DbSkip()
			   End
			EndIf
		EndIf
		If lFacImport .AND. l103Class   //Geracao de remisiones para notas de import.
		    DbSelectArea("SF1")
		    LocXGerRem(,@aRecIMP)
		Endif
		//PE para integracao com Celerina
		cPe	:=	LocxPE(7)
		If lRet .AND. !Empty(cPE)
			ExecBlock(cPE,.F.,.F.)
		EndIf
		//PE apos a gravacao de cabecalho da nota a apos as atualizacoes gerais
		cPe	:=	LocxPE(8,@cNomePE)
		//Para a localizacao Mexico, sera processada a funcao do ponto de entrada SF2460I no padrao.
		If cPaisLoc == "MEX" .AND. Substr(cPrefC,1,3) == "SF2"
			RcFatMex()
		Endif
		If lRet .AND. !Empty(cPE)
			ExecBlock(cPE,.F.,.F.)
		EndIf
		// Para Integração com SIGALOC(94)
		If alltrim(FUNNAME())$"MATA462DN" .and. lMvLocBac  //Remito de devolucion de ventas tentar integrar com Rental
			Locm008(3, 1) // 3 = Inclusão de Remito de Devolução / 1 = Tela confirmada
		endif
		If cPaisLoc == "EUA"
			LxGrvNfEUA(aCfgNf, aCitens, cEspecie, cFunName)
		EndIf
		// Caixinha deve ser a ultima validacao
		If lRet .And. Type("cCxCaixa")!="U" .And. Type("nCxValor")!="U" .And. !Empty(cCxCaixa) .and. !Empty(nCxValor)
			lRet := NFVldCxa(3,cCxBenef,nCxValor,cCxCaixa,cCxAdian,cCxHistor,If(Type("cCxRendic")!="U",cCxRendic,""))
		EndIf
		//Acerta a numeracao da NF
		If lRet
			If aCfgNf[SlFormProp] .OR. (cPaisLoc == "COL" .AND. (lDocSp .OR. aCfgNF[SnTipo] == 22 .OR. aCfgNF[SnTipo] == 23 ) .AND. ((cFunName $ "MATA101N|MATA466N") .Or. ChkProp("DocumentoSoporte"))  )
				If cPaisLoc <> "EUA"
					lRet := AtuNumNF(&(cPrefC+"_DOC"),&(cPrefC+"_SERIE"),aCfgNf[ScTipoDoc],aCfgNf[ScCliFor])
				EndIf
				If lRet .And.  cPaisLoc=="VEN" .And.    SF1->(ColumnPos("F1_FORMLIB")) > 0 .and.  SF2->(ColumnPos("F2_FORMLIB")) > 0
					nMumAt:= AtuNumFL(&(cPrefC+"_FORMLIB"))
					If nMumAt<> &(cPrefC+"_FORMLIB")
						If aCfgNF[SAliasHead] == "SF2"
							SF2->(RecLock("SF2",.F.))
							SF2->F2_FORMLIB:= nMumAt
							SF2->(MsUnlock())
						Else
							SF1->(RecLock("SF1",.F.))
							SF1->F1_FORMLIB:= nMumAt
							SF1->(MsUnlock())
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		If FwIsInCallStack("MATA101N") // Factura de Entrada
			aRetInt := FwIntegDef("MATA101N")	//-- Invoice
			If Valtype(aRetInt) == "A"
				If Len(aRetInt) == 2
					If !aRetInt[1]
						If Empty(AllTrim(aRetInt[2]))
							cMsgRet := "Verificar problema no Monitor EAI"
						Else
							cMsgRet := AllTrim(aRetInt[2])
						Endif
						Aviso("Atenção",cMsgRet,{"Ok"},3)
						lRet:= .F.
					Endif
				Endif
			EndIf
		EndIf
		If FwIsInCallStack("MATA466n") // Nota de Debito/Credito
			aRetInt := FwIntegDef("MATA466n")	//-- Invoice
			If Valtype(aRetInt) == "A"
				If Len(aRetInt) == 2
					If !aRetInt[1]
						If Empty(AllTrim(aRetInt[2]))
							cMsgRet := "Verificar problema no Monitor EAI"
						Else
							cMsgRet := AllTrim(aRetInt[2])
						Endif
						Aviso("Atenção",cMsgRet,{"Ok"},3)
						lRet:= .F.
					Endif
				Endif
			EndIf
		EndIf
	If lRet
		If cPaisLoc == "MEX" .And. SF2->(ColumnPos("F2_TPCOMPL")) > 0 .And. SF2->F2_TPCOMPL == "S" .And. (cFunName == "MATA467N" .Or. FWIsInCallStack("MATA467N"))
			xCartPorte(oModelAct, cFunName, lLocxAuto, aCartaPorte, @lRet)
		EndIf
		If FunName() <> "MATA466N" .And. lGerarCFD .And. lRet .And. aCfgNF[SnTipo] <> 24 .And. cPaisLoc <> "COL"
			If aCfgNF[SAliasHead] == "SF2"
				lGenXML := CFDGerXML(SF2->F2_ESPECIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE,(aGerarCFD[1] == "1" .AND. !lLocxAuto),!lLocxAuto)
			Else
				lGenXML := CFDGerXML(SF1->F1_ESPECIE,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE,(aGerarCFD[1] == "1" .AND. !lLocxAuto),!lLocxAuto) .and. cFunName == "MATA465N"
			EndIf
			If lGenXML
				cPe	:=	LocxPE(67)
				If !Empty(cPE)
					ExecBlock(cPE,.F.,.F.)
				Else
					If __lPyme .And. ExistBlock( "LOCXS367" , .F. , .T. )
						Execblock( "LOCXS367" , .F. , .F. )
					EndIf
				EndIf
			EndIf
		Endif
	Endif
	If cPaisLoc == "BOL" .and. Type("aGerarCFD") == "A" .and. Len(aGerarCFD) > 0 .and. aGerarCFD[1] <> "0" .and. FindFunction("FACTONBOL")
		FACTONBOL(aCfgNF[SAliasHead])
	EndIf
	If cPaisLoc == "COL" .And. Type("aGerarCFD") == "A" .And. Len(aGerarCFD) > 0 .And. aGerarCFD[1] $ "1|2|3" .And. Len(aGerarCFD[2]) == 0 .And. FindFunction("LxTraCOL")
		LxTraCOL(aCfgNF[SAliasHead], Alltrim(aCfgNF[ScEspecie]),IIf(aCfgNF[SAliasHead] == "SF2",SF2->F2_SERIE,SF1->F1_SERIE),IIf(aCfgNF[SAliasHead]=="SF2",SF2->F2_DOC,SF1->F1_DOC))
	EndIf
	If lRet
 		// MODULO DMS ( 11 - VEICULOS )
		If cMVVeiculo == "S" .And. FindFunction("VA1810011_GravaNfGeral")
			lRet := VA1810011_GravaNfGeral( nTipo , aCfgNF[SAliasHead] , &(aCfgNF[SAliasHead]+"->(RecNo())") , aRecsSF1 )
		EndIf
	EndIf
	//Finalizando Transacao
	If !lRet
		DisarmTransaction()
	EndIf

End transaction

If lRet
	/*Chamar Função DigLot [Permite endereçar manualmente os itens da NF]*/
	IF (lVer116 .AND. lDistMov .And. Len(aDigEnd) > 0).and. (nTipo = 10 .Or. nTipo = 60)
   		A103DigEnd(aDigEnd)
	endif
EndIf
If  (cPaisLoc == "PAR"  .AND. ((cFunName $ "MATA101N") .Or. ChkProp("Autofactura")) .AND. lAutoFact )
	 AtuNumNF(&(cPrefC+"_DOC"),&(cPrefC+"_SERIE"),aCfgNf[ScTipoDoc],aCfgNf[ScCliFor])
ENDIF
If  cPaisLoc == "CHI"  .AND.( ((cFunName $ "MATA101N") .AND. lAutoFact )  .Or. ChkProp("Autofactura"))
	 AtuNumNF(&(cPrefC+"_DOC"),&(cPrefC+"_SERIE"),aCfgNf[ScTipoDoc],aCfgNf[ScCliFor])
ENDIF
//Destrava todos os registros que possam estar eventualmente travados.
MsUnlockAll()
//³Tratamento a ser considerado para o Peru quanto utilizar conceito de Serie-2 ³
If cPaisLoc=="PER"
	GrvSer2Per(cPrefC)
EndIf
 If !aCfgNF[SlRemito] .And.   cPaisLoc=="VEN" .And.    SF1->(ColumnPos("F1_FORMLIB")) > 0  .and.  SF2->(ColumnPos("F2_FORMLIB")) > 0 .and. SF3->(ColumnPos("F3_FORMLIB")) > 0
	If cPrefC=="SF1->F1"
		cCompSF3:=SF1->(F1_FILIAL+F1_FORNECE+F1_LOJA+F1_DOC+F1_SERIE)
	Else
		cCompSF3:=SF2->(F2_FILIAL+F2_CLIENTE+F2_LOJA+F2_DOC+F2_SERIE)
	EndIf
	DbSelectArea("SF3")
	SF3->(DbGotop())
	DbSetOrder(4)
	DbSeek(cCompSF3)
	Do While !Eof() .And. SF3->(F3_FILIAL+F3_CLIEFOR+F3_LOJA+F3_NFISCAL+F3_SERIE)==cCompSF3
		RecLock("SF3",.F.)
		SF3->F3_FORMLIB := &(cPrefC+"_FORMLIB")
		MsUnLock()
		DbSkip()
	EndDo
EndIf
//Contabilizacao
//A contabilizacao pode ser desabilitada atraves do parametro aAtualiza, caso nao seja, obedece
//a configuracao das perguntas no parametro aPergs
If lRet .AND. aCfgNf[SaAtualiza][SlCtbilOL] .AND. aCfgNf[SaPergs][SlGerCtbil]
	If cPaisLoc == "MEX" .AND. aCfgNf[SnTipo] != 24
		xGenXmlMex(lGerarCFD, cPrefC)
	EndIf
	If ValType(apergs) <> "A" .Or. (ValType(apergs) == "A" .And. len(Apergs) < Len(aCfgNf[SaPergs]))
		Apergs:=aCfgNf[SaPergs]
	EndIf
	IF aCfgNf[SlRemito] .AND. (aCfgNf[SnTipo] == 54 .or. aCfgNf[SnTipo] == 64) .AND. ValType("M->F2_TIPORET")=="C" .AND. M->F2_TIPORET == "1"
		CtbilNF(aCfgNf[SAliasHead],aCfgNf[SAliasCols],nRecnoC,aRecnoI,aCfgNf[SaLancPadC],aCfgNf[SaLancPadI],aCfgNf[SaPergs][SlVerCtbil],aCfgNf[SaPergs][SlAglutina])
	Else
		CtbilNF(aCfgNf[SAliasHead],aCfgNf[SAliasCols],nRecnoC,aRecnoI,aCfgNf[SaLancPadC],aCfgNf[SaLancPadI],aPergs[SlVerCtbil],aPergs[SlAglutina])
	Endif
EndIf
//³PCO	³
If lRet
	PcoLancto(aCfgNf[SAliasHead],aCfgNf[SAliasCols],nRecnoC,aRecnoI,aCfgNf[SaLancPCO][1],aCfgNf[SaLancPCO][2],aCfgNf[SaLancPCO][4],aCfgNf[SaLancPCO][3], .T./*lInclui*/, .F./*lDeleta*/)
EndIf
//³Chamada da funcao de compensacao financeira quando for NCC e NDE³
If lRet .AND. (aCfgNf[SnTipo] == 4 .OR. aCfgNf[SnTipo] == 5) .AND. aCfgNf[ScEspecie] $ MV_CRNEG .AND. lTela .And. cCompOnL == "3"
	If cCompNc	== "1" .AND. !(cPaisLoc $ "CHI|ARG|URU|COL|EQU|PER|BOL|PAR")
		CompensaNCC(aCfgNf[SAliasCols],aCfgNf[ScEspecie],aCfgNf[SaPergs])
	Elseif  cCompNc == "1" .OR. (cCompNc == "3" .AND. MsgYesNo(STR0035,STR0036)) //"Deseja fazer agora a compensacao do titulo gerado?"###"Compensacao de titulos"
		If cVersion >= "12.1.2210"
			FINA998()
			SetFunName(cFunName)
		Else
			If SuperGetMV("MV_FINCTMD",.T.,1) == 1
				Fina087a("","",{})
			Else
				SetFunName("FINA846")
					FINA840()
				SetFunName(cFunName)
			EndIf
		Endif
	EndIf
EndIf
//³Se for utilizado o GetSXENum() confirma o numero.
If __lSX8
	ConfirmSX8()
Endif
//³Verifica se deve finalizar as variaveis de gravacao de impostos³
If !lTela .AND. MaFisFound() .and. (!aCfgNF[SlRemito] .or. (cPaisloc =="CHI" .and. funname() == "MATA468N" .and. aCfgNF[SlRemito] .and. aCfgNF[ScEspecie] == "RET" ))
	MaFisEnd()
Endif
//³Ponto de entrada apos todas as gravacoes e apos fechamento da transacao³
cPe	:=	LocxPE(11,@cNomePE)

//³Para a localizacao Mexico, sera processada a funcao do ponto de entrada MT100AGR no padrao³
If cPaisLoc == "MEX" .AND. Substr(cPrefC,1,3) == "SF1"
	PgComMex()
Endif
If lRet .AND. !Empty(cPE)
	ExecBlock(cPE,.F.,.F.)
EndIf
//³Verifica se deve chamar a rotina de geracao de pedidos.
If	lRet	.AND. lTela 	.AND.	aCfgNf[ScTipoDoc] $ 'BD'	.AND.	aCfgNf[SAliasHead] == 'SF1'
	nPos := AScan(aCabNota[1],{|x| x=='F1_GERAPED' })
	If nPos > 0
		If ValType(aCabNota[2][nPos]) == "A"
			lGeraPed := (&(aCabNota[2][nPos][1]) == "1")
		Else
			lGeraPed := (aCabNota[2][nPos] == "1")
		EndIf
	EndIf
	If lGeraPed
		Processa({|| lRet := LocxGrvPed()},STR0121) //'Gerando informacao de pedidos...'
	Endif
EndIf
//Llamada de metricas
If lRet .and. FINDFUNCTION( "LOCXMETGRV" )
	LOCXMETGRV(IIf(Type("cFunName")=="U",Upper(Alltrim(FunName())),cFunName), aCfgNf[ScEspecie] ,lDocSp)
EndIf
//³Restaura aCols original
aCols := aClone(aSavaCols)
For nX:=1 To Len(__aCodLocs)
	UnLockByName(__aCodLocs[nX],.T.,!Empty(cFilSF2),.T.)
	UnLockByName(__aCodLocs[nX],.T.,!Empty(cFilSF1),.T.)
Next
__aCodLocs	:= {}

/*(09/04/18): Message about created FA*/
If cPaisLoc=="RUS" .AND. !Empty(cNumb)
	RU01MSG(cNumb, , )
EndIF
//Métrica para contabilizar cantidad de Carta Porte registradas por mes.
If cPaisLoc == "MEX" .And. lRet .And. FindFunction("LxMetCarP") .And. SF2->(ColumnPos("F2_TPCOMPL")) > 0 .And. SF2->F2_TPCOMPL == "S" ;
	.And. cFunName == "MATA467N" .And. SF2->F2_TIPODOC $ "01|21"
	LxMetCarP(cFunName)
EndIf
If cPaisLoc == "EQU" .and.  cFunName == "MATA467N" .and. lRet .and. aCfgNF[SAliasHead] == "SF2" .and. Alltrim(SF2->F2_ESPECIE) =="NF" .and. FindFunction("LxMetReem") .and. SF2->(FieldPos("F2_TPDOC")) > 0 .and. SF2->(FieldPos("F2_TPVENT")) > 0 .and. SF2->(FieldPos("F2_TIPOPE")) > 0
	If SF2->F2_TPDOC == PadR("01",TamSX3("F2_TPDOC")[1]) .and. SF2->F2_TPVENT == "1" .and. SF2->F2_TIPOPE == PadR("41",TamSX3("F2_TIPOPE")[1])
 		LxMetReem(cFunName) //Métrica
	Endif
Endif
//Registro de eventos para visualizacion en EventViewer
If lRet .And. cPaisLoc $ "COL" .And. ((cFunName $ "MATA101N") .Or. ChkProp("EventViewer")) .And. aCfgNf[SnTipo] == 10 .And. FindFunction("LxEventIn")
	LxEventIn(aCabNota, aCItens, aCpItens)
EndIf
Return(lRet)

/*ºPrograma  ³GRAVAITENSNF ºLenadro C.G. ³Microsiga  º Data ³  09/10/01   º±±
±±ºDesc.     ³ Efetua gravacao de todos os itens de Notas Fiscais         º±±
param.
aCitensOri  - conteudo dos itens
aCpItensOri - campos dos itens
cAlias		- nome do arquivo(Alias) de itens da nota
cAliasCF	- Alias do cliente ou fornec. (SA1/SA2)
aTotaliz 	- informacoes sobre os campos que devem ser totalizados
			[1] - array com o nome dos campo de cabecalho que devem ser totalizados
			[2] - array com a formula para totalizar cada um dos campos
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cTipRem     - Tipo de Remito que esta sendo gerado
Obs.: Pode ser passado tanto o conteudo propriamente dito quanto uma formula para o conteudo no array aCittens, mas
quando for uma formula, mudar a pos. de conteudo para que seja um array de duas posicoes onde a formula esta na
primeira e na seguna alguma expressao booleana para execucao da formula
Retorno
aRet - retorno da funcao
 [1] - aRecnoI
 [2] - aCpTotal
 [3] - aTotal*/
Function GravaItensNF(aCitensOri,aCpItensOri,cAlias,aTotaliz,cAliasCF,cTipDoc,cTipRem)
Local nI,nX,cI :=StrZero(0,TamSX3(If(cAlias=="SD2",'D2_','D1_')+'ITEM')[1])	//flag's para loop's
Local aArea    := {}   //guarda config. de arquivo
Local aRecnoI  := {}   //acumula o numero dos registros que foram gravados sequencialmente
Local lForm	   := .F.  //Indica se a linha atual do array aCitens possui algum conteudo que seja formula
Local aRet 	   := array(4) //Array com o conteudo do retorno da funcao
Local lRet 	   := .T.  //Retorno da funcao. Indica incosistencia da funcao
Local aPars	   := {}   //Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local aCitens  := aClone(aCitensOri)
Local aCpItens := aClone(aCpItensOri)
Local nPosItem := 0
Local nPosCod  := 0
Local cItemOri := ""
//Local cAux     := ""
Local aRecTmp  := {}
//Local nDeleted := 0
Local nPosAFN  := 0
Local nPosRatCC:= 0
//Local lVer116  := .T.
//Local lDISTMOV := SuperGetMV("MV_DISTMOV",.F.,.F.)
Local nRecD1   := 0
Local cFilSD1		:= xFilial("SD1")
//Local cFilSFB		:= xFilial("SFB")
Local lRemDevo	:= GetNewPar("MV_REMDEVO",.F.)
Local cDescSai	:= GetNewPar('MV_DESCSAI','1')
Local nT_PRCVEN	:= TamSX3("D2_PRCVEN")[2]
//Local nT_VUNIT	:= TamSX3("D1_VUNIT")[2]
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local aTmpQ := {}
Local nX1 := 0
Local cUserLG := ""
Local oArrayTes := Tes_Impuesto():New()
Local lActItPAR := FindFunction("ActItemPAR") .And. cPaisLoc == "PAR"
DEFAULT cTipRem := ""
aRatCC := If(Type("aRatCC")	<>"A", {}, aRatCC)
Asize(aTotaliz, 3)
aTotaliz[3] := IIf(Empty(aTotaliz[3]) .OR. ValType(aTotaliz[3]) != "A", {}, aTotaliz[3])
Asize(aTotaliz[3], Len(aTotaliz[1]))
Asize(aTotaliz[2], Len(aTotaliz[1]))
Aeval(aTotaliz[2], { |x,y| If(x==NIL,aTotaliz[2][y]:="0",) })
Afill(aTotaliz[3], 0)
//³Consiste passagem de param.³
Aadd(aPars, {"aCitens"	, aCitens	, SpEmpty					} )
Aadd(aPars, {"aCpItens"	, aCpItens	, SpEmpty					} )
Aadd(aPars, {"cAlias"	, cAlias	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String	, "SA1"	, "SA2"	} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty					} )
lRet := LocxParam("GRAVAITENSNF", aPars)
If lRet //(1)
	aArea  := GetArea()
	//³Iniciando Fiscal, se necessario ³
	If !MaFisFound()
		InicializaFis(MontaHeader(aCpItens),aCitens,IIf(cAlias=="SD1","SF1","SF2"),cAlias,cAliasCF,cTipDoc)
	Endif
	//³Grava Itens e acumula totais³
	DBSelectArea(cAlias)
	nI := 0
	nPosItem := Ascan(aCpItens,{|x| Alltrim(x)=="D1_ITEM"})
	nPosCod := Ascan(aCpItens,{|x| Alltrim(x)=="D1_COD"})
	If lUsaNewKey
		nPosSERIE:= Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_SERIE"})
		nPosEMISS:= Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_EMISSAO"})
		nPosESPEC:= Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_ESPECIE"})
		nPosSDOC := Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_SDOC"})
		nPosSEORI:= Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_SERIORI"})
		nPosSDOCO:= Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_SDOCORI"})
	Endif
	If l103Class
		For nI := 1 To Len(aCItens)
			SD1->(MsSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aCitens[nI][nPosCod]+aCitens[nI][nPosItem]))
		   	Aadd(aRecnoI,{SD1->(Recno()),ni})
	 	Next nI
	Endif
	//O item eh recalculado e regravado, portanto tem que ser flagueado com um diferencial ('X') frente, para poder ser substituido
	//pelo codigo de item definitivo
	If IntePms()
		For nPosAFN := 1 To Len(aRatAFN)
			aRatAFN[nPosAFN,1] := 'X'+aRatAFN[nPosAFN,1]
		Next
	Endif
	For nPosRatCC := 1 To Len(aRatCC)
		aRatCC[nPosRatCC,1] := 'X'+aRatCC[nPosRatCC,1]
	Next
	For nI := 1 to Len(aCitens)
		//³Verifica se a linha nao esta deletada³
		If aCitens[nI][Len(aCitens[nI])]
			If !l103Class
				AADD(aRecnoI,{0,ni})
			Endif
			Loop
		EndIf
		//³Consiste qtde de campos e conteudos passados³
		If Len(aCitens[nI]) != Len(aCpItens)+1
			Alert(cAlias+" ; FUNCTION:'GRAVAITENSNF'")
			RestArea(aArea)
			lRet := .F.
		EndIf
		If lRet //(2)
			//³Se posuir algum campo que seja formula, carrega o conteudo dos campos em variaveis de memoria³
			lForm := .F.
			Aeval(aCitens[nI], { |x| If(ValType(x)=="A",lForm:=.T.,) })
	    	IIf(lForm, 	Aeval(aCpItens, { |x,y| If(x!=NIL,{ || &("M->"+x):=CriaVar(x),&("M->"+x):=If(ValType(aCitens[nI][y])!="A",aCitens[nI][y],NIL)},) }), )
			//³Trava Registro³
			If l103Class
				(cAlias)->(MsGoto(aRecnoI[nI,1]))
				RecLock(cAlias,.F.)
			Else
				RecLock(cAlias,.T.)
				If cAlias=="SD2" .And. SD2->(Fieldpos("D2_USERLGI")) > 0
					cUserLG := D2_USERLGI
				EndIf
			Endif
			//³Varrendo todos os campos para cada item³
			nX := 0
			For nX := 1 to Len(aCpItens)
				//³Verifica a existencia do campo no arquivo³
				If &(cAlias+"->"+"(FieldPos('"+aCpItens[nX]+"')) <> 0")
					//³Verifica se deve executar formula ou ja e o conteudo. O que define isso e o caracteristica da pos. do array ³
					//³de dados. Se for um array, o mesmo deve conter duas posicoes e a segunda pos. indica se e formula ou nao.   ³
					//³Se a segunda pos. deste array for .T., executa-se entao a formula que deve estar contida na primeira pos.³
					//³do array 																									  ³
					If !l103Class
						If ValType(aCitens[nI][nX]) == "A"
							If Len(aCitens[nI][nX]) >= 2 .AND. !Empty(aCitens[nI][nX][2]) .AND. aCitens[nI][nX][2]
								Replace &(aCpItens[nX]) With ExecFormula(aCitens[nI][nX][1],,)
							EndIf
						Else
							If lUsaNewKey
								If nX<>nPosSERIE .AND. nX<>nPosSDOC .AND. nX<>nPosSEORI .AND. nX<>nPosSDOCO
									Replace &(aCpItens[nX]) With aCitens[nI][nX]
								ElseIf nX==nPosSERIE
									SerieNfId(cAlias,1,PrefixoCpo(cAlias)+"_SERIE",aCitens[nI][nPosEMISS],aCitens[nI][nPosESPEC],aCitens[nI][nPosSERIE])
								ElseIf nX==nPosSEORI
									If !(empty(aCitens[nI][nPosSEORI]))
										SerieNfId(cAlias,1,PrefixoCpo(cAlias)+"_SERIORI",,,,aCitens[nI][nPosSEORI])
									EndIf
								EndIf
							Else
								Replace &(aCpItens[nX]) With aCitens[nI][nX]
							Endif
						EndIf
					Else
						If lUsaNewKey
			  				If aCfgNf[SaCposGD]<> Nil .AND. (Ascan(aCfgNf[SaCposGD],{|x| x==Alltrim(aCpItens[nX])})> 0)
								If nX<>nPosSERIE .AND. nX<>nPosSDOC .AND. nX<>nPosSEORI .AND. nX<>nPosSDOCO
									Replace &(aCpItens[nX]) With aCitens[nI][nX]
								ElseIf nX==nPosSERIE
									SerieNfId(cAlias,1,PrefixoCpo(cAlias)+"_SERIE",aCitens[nI][nPosEMISS],aCitens[nI][nPosESPEC],aCitens[nI][nPosSERIE])
								ElseIf nX==nPosSEORI
									If !(empty(aCitens[nI][nPosSEORI]))
										SerieNfId(cAlias,1,PrefixoCpo(cAlias)+"_SERIORI",,,,aCitens[nI][nPosSEORI])
									EndIf
								Endif
							EndIf
						Else
			  				If aCfgNf[SaCposGD]<> Nil .AND. (Ascan(aCfgNf[SaCposGD],{|x| x==Alltrim(aCpItens[nX])})> 0)
								Replace &(aCpItens[nX]) With aCitens[nI][nX]
							EndIf
						Endif
					EndIf
				EndIf
			Next nX
  			cI	:=	Soma1(cI,Len(cI))
  			cItemOri	:= &(PrefixoCpo(aCfgNF[SAliasCols])+"_ITEM")
  			Replace &(PrefixoCpo(aCfgNF[SAliasCols])+"_ITEM") With cI
			If cAlias == "SD2" .AND. cDescSai == '2' .And. !lActItPAR
	     		SD2->D2_TOTAL := SD2->D2_TOTAL - SD2->D2_DESCON
				//#Brasil#
				//If cPaisLoc <> "BRA"
					SD2->D2_PRCVEN := Round(SD2->D2_TOTAL / SD2->D2_QUANT, nT_PRCVEN)
				//Else
					//SD2->D2_PRCVEN := NoRound(SD2->D2_TOTAL/SD2->D2_QUANT, nT_PRCVEN)
				//EndIf
			EndIf
			If cPaisLoc == "ARG"
	     		ArgActItem(cAlias, aCfgNf[ScTipoDoc], cDescSai, @oArrayTes)
			EndIf
			If lActItPAR
				ActItemPAR(cAlias, aCfgNf, cDescSai, IIf(cAlias == "SD1", SF1->F1_MOEDA, SF2->F2_MOEDA))
			EndIf
			//³Compatibiliza conteudo do campo D2_TIPOREM com tipo selecionado no cabecalho
			If cAlias=="SD2" .AND. !Empty(cTipRem)
  				SD2->D2_TIPOREM := cTipRem
			EndIf
			If cAlias=="SD2" .AND. !Empty(cUserLG)
  				SD2->D2_USERLGI := cUserLG
			EndIf
			//³ Efetua a Atualizacao da Assistencia Tecnica Somente para os paises localizados
			//³ Obs.: A Geração quando o item utiliza localização é feita após a geração do SDB na função GravaNfGeral()
			If cAlias=="SD2" .AND. (cPaisLoc $ "ARG|PAR|URU|CHI|MEX|EUA|POR|BOL")
				If ( SF4->F4_ATUTEC=="S" )
					If ( !Empty(SD2->D2_NUMSERI) )
						AtTrfEqpto(SD2->D2_CODFAB,SD2->D2_LOJAFA,SD2->D2_COD,SD2->D2_NUMSERI,SD2->D2_CLIENTE,SD2->D2_LOJA)
					EndIf
				EndIf
			EndIf
			If cAlias=="SD1" .AND. l103Class
				SD1->D1_DTDIGIT	:= dDataBase
			Endif
			//³ Na inclusao de uma devolucao de remito de entrada, atualiza a qtde.³
			//³ a classificar do remito de entrada.
			If cAlias == "SD2" .AND. SD2->D2_TIPO == "D" .AND. SD2->D2_TIPODOC == "61" .AND.;
				Alltrim(SD2->D2_ESPECIE) == "RCD" .AND. !l103Class
				SD1->(dbSetOrder(1))
				If SD1->(MsSeek(cFilSD1+SD2->D2_NFORI+SD2->D2_SERIORI+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMORI))
					SD1->(RecLock("SD1",.F.))
					//³ Quando o parametro MV_REMDEVO estiver criado no SX6 com o conteudo .T. ³
					//³ a gravacao do D1_QTDACLA sera adiada quando a inclusao do remito de    ³
					//³ devolucao baixar a qtde do remito original. Isto                 ³
					//³ possibilitara que o remito original possa ser vinculado posteriormente ³
					//³ a fatura de entrada mesmo estando seu saldo totalmente consumido pelo  ³
					//³ remito de devolucao.
					If !lRemDevo
						SD1->D1_QTDACLA := SD1->D1_QTDACLA - SD2->D2_QUANT
                    EndIf
					SD1->(MsUnLock())
				EndIf
			EndIf
			//³ Estorna classificação dos remitos
			If !aCfgNF[SlRemito] .And. cAlias == "SD2" .AND. SD2->D2_TIPO == "D" .AND. SD2->D2_TIPODOC == "07" .AND.;
				Alltrim(SD2->D2_ESPECIE) == "NCP" .AND. !l103Class
				nRecD1 := SD1->(Recno())
				cChaveItem	:=	cFilSD1+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMREM
				aCusto		:=	{SD1->D1_CUSTO/SD1->D1_QUANT,SD1->D1_CUSTO2/SD1->D1_QUANT,SD1->D1_CUSTO3/SD1->D1_QUANT,SD1->D1_CUSTO4/SD1->D1_QUANT,SD1->D1_CUSTO5/SD1->D1_QUANT}
				nQtdItem	:=	SD1->D1_QUANT
				If !Empty(SD1->D1_REMITO) .And. SD1->(MsSeek(cChaveItem))
					If !(cPaisLoc $ "ARG|URU|CHI|BOL|PAR")
						NFAtuSD1(nQtdItem,-1,aCusto)
						SD1->(MsGoTo(nRecD1))
					EndIf
				EndIf
				// Retorna o alias selecionado para SD2 para atualizar os Recnos corretos na sequencia do processo
				DBSelectArea("SD2")
			EndIf
			//³Destrava Registro³
			MsUnlock()
			//Acerta no AFN com o o item que realmente foi gravado
			If IntePms()
				nPosAFN := Ascan(aRatAFN,{|x| x[1] == 'X'+cItemOri})
				If nPosAFN > 0
					aRatAFN[nPosAFN,1] := cI
				Endif
			Endif
			//Acerta no Rat.CC com o o item que realmente foi gravado
			nPosRatCC := Ascan(aRatCC,{|x| AllTrim(x[1]) == AllTrim('X'+cItemOri)})
			If nPosRatCC > 0
				aRatCC[nPosRatCC,1] := cI
			Endif
			//³Acumula o numero dos registros gravados³
			If !l103Class
				AADD(aRecnoI,{Recno(),ni})
			Endif
		Else
			Loop
		EndIf
	Next nI
	If lRet
		//³Calculando campos que devem ser totalizados³
		If !Empty(aTotaliz)
			Aeval(aTotaliz[2], { |x,y| aTotaliz[3][y]:=IIf(!Empty(x),ExecTotal(x,aCpItensOri,aCitens),0) })
		EndIf
		//³Acertando conteudo de retorno³
		aRecTmp := aClone(aRecnoI)
		aRet[4] := aRecnoI
		aRet[2] := aTotaliz[1]
		aRet[3] := aTotaliz[3]
		aTmpQ:={}
		for nX1 := 1 to Len(aRecTmp)
			If Valtype(aRecTmp[nX1]) == "A" .and. aRecTmp[nX1,1] >0
				aAdd(aTmpQ,aRecTmp[nX1])
			EndIf
		Next nX1
		aRet[1] := aTmpQ //aRecTmp
		//Devolve a pos. do array com o conteudo original, sem 0. Foi adicionada 0 qdo o item for apagado.
		//Essa alteracao refletira na funcao grava imposto. (Eval que chama a MaFisWrite)
	EndIf
	If lRet .and. FINDFUNCTION( "LOCXMET" )
		LocxMet(IIf(Type("cFunName")=="U",Upper(Alltrim(FunName())),cFunName),Val(cI),,,.T.,"A")
	EndIf
EndIf
//³Devolvendo configuracoes de arquivo³
RestArea(aArea)
Return(aRet)
/*ºPrograma  ³GRAVACABNF   ºLenadro C.G. ³Microsiga  º Data ³  09/10/01   º±±
±±ºDesc.     ³ Efetua gravacao do cabecalho de Notas Fiscais              º±±
param.
aCabNotaOri - cabecalho da Nota
		   [1] - campos do cabecalho
		   [2] - conteudo dos campos do cabecalho * pode ser uma formula inclusive quando for um totalizador
		   [3] - indica se o campo e totalizador (Default .F.)
cAlias   - nome do arquivo(Alias) de itens da nota
Obs.: Pode ser passado tanto o conteudo propriamente dito quanto uma formula para o conteudo no array aCabNota[2], mas
quando for uma formula, mudar a pos. de conteudo para que seja um array de duas posicoes onde a formula esta na
primeira e na seguna alguma expressao booleana para execucao da formula
*/
Function GravaCabNF(aCabNotaOri,cAlias,lID,cHash)
Local nI,nX					//flag's para loop's
Local aArea    := {}		//guarda config. de arquivo
Local nRecnoC  := 0			//armazena o numero do registro gravado
Local aPars	   := {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local lForm    := .F.		//Flag que indica se algum conteudo de cabecalho e uma formula
Local lRet 	   := .T.		//Retorno da funcao. Indica incosistencia da funcao
Local aCabNota := aClone(aCabNotaOri)
Local nPosCor  := 0
Local cCpoCor  := ''
Local cSeek    := ''
Local lConfere := .F.
Local nPosRem := aScan(aHeader, {|x| UPPER(AllTrim(x[2])) == "D1_REMITO"})
Local nPosRemS:= aScan(aHeader, {|x| UPPER(AllTrim(x[2])) == "D1_SERIREM" })
Local nPosTes := aScan(aHeader, {|x| UPPER(AllTrim(x[2])) == "D1_TES" })
Local nPosForn:= aScan(aHeader, {|x| UPPER(AllTrim(x[2])) == "D1_FORNECE" })
Local nPosLoja:= aScan(aHeader, {|x| UPPER(AllTrim(x[2])) == "D1_LOJA" })
Local nPosCorDat:=0,nPosCorSer:=0,nPosCorEsp:=0,nPosCorFor:=0,nPosCorLoj:=0 //cPosCorDoc:=0,
//Local cInvoiceDate := ""     // AAAA-MM-DD
//Local cInvDateMan  := ""
//Local cSystemEntryDate := "" // AAAA-MM-DDTHH:MM:SS
//Local cInvoceNo    := ""     // código interno do documento SERIE / DOCUMENTO
//Local cGrossTotal  := ""     // Valor total
Local lContFol  := ((AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720") .Or. ChkProp("ControlFolios"))  .And. GetNewPar("MV_CTRLFOL",.F.)
Local nPosHon   := 0
Local lConfFis		:= SuperGetMV("MV_CONFFIS",.F.,"N") == "S"
Local lRemDiv		:= SuperGetMV("MV_REMDIV",.F.,.F.)
Local aAreaSF1		:= {}
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local nPosEMISS:=0
Local nPosSERIE:=0
Local nPosESPEC:=0
Local nPosSDOC :=0
Local nPosSERIE2:=0
//Local cCpSer2:=""
Local cIdCorr	:= ""
//Local nValcot	  := 0
//Local aAreaSB5	:= {}
//Local lSb5 := .F.
//Local nZ := 0
//Local cCpo := ""
//Local nPosSerie := 0
//Local nPosEspec := 0

If Type('lDocSp') == "U"
	Private lDocSp := .F.
EndIf
If Type('lAutoFact') == "U"
	Private lAutoFact := .F.
EndIf
Default cHash           := ""  // (So Portugal) Hash (campo do documento anterior na mesma série, vazio quando se tratar do primeiro documento da série ou do exercício)
Aadd(aPars, {"aCabNota"	,aCabNota		,SpLenArray		,2		,3		} )
Aadd(aPars, {"aCabNota",aCabNota[1]		,SpEmpty						} )
Aadd(aPars, {"aCabNota",aCabNota[2]		,SpEmpty						} )
Aadd(aPars, {"aCabNota",cAlias			,Sp2String		,"SF1"	,"SF2"	} )
lRet := LocxParam("GRAVACABNF",aPars)
Aeval(aCabNota[1], { |x,y| IIf(Empty(aCabNota[3][y]),aCabNota[3][y]:=.F.,) })
If lRet //(1)
	//³Salvando configuracoes do arquivo³
	aArea  := GetArea()
	nPosHon:=Ascan(aCabNota[1],PrefixoCpo(cAlias)+"_RECHON")
	If nPosHon >0  .And. 	aCabNota[2][nPosHon]=="1"
	   	 lUsaCor:=.F.
	EndIf
	//³Se posuir algum campo que seja formula, carrega o conteudo dos campos em variaveis de memoria
	lForm := .F.
	Aeval(aCabNota[2], { |x| If(ValType(x)=="A",lForm:=.T.,) })
	IIf(lForm, 	Aeval(aCabNota[1], { |x,y| If(x!=NIL,{ || &("M->"+x):=CriaVar(x),&("M->"+x):=If(ValType(aCabNota[2][y])!="A",aCabNota[2][y],NIL)},) }), )
	If lUsaNewKey //Projeto Chave Unica - Tiago Silva
		If cPaisLoc == "PER"
			CposSerPer(cAlias, @aCabNota, @nPosSERIE, @nPosSERIE2)
		Else
			nPosSERIE:=Ascan(aCabNota[1],PrefixoCpo(cAlias)+"_SERIE")
		Endif
		nPosESPEC:=Ascan(aCabNota[1],PrefixoCpo(cAlias)+"_ESPECIE")
		nPosEMISS:=Ascan(aCabNota[1],PrefixoCpo(cAlias)+"_EMISSAO")
		nPosSDOC :=Ascan(aCabNota[1],PrefixoCpo(cAlias)+"_SDOC")
	Endif
	If lUsaCor .AND. lID //grava o numero correlativo
		cCpoCor:=PrefixoCpo(cAlias)
		nPosCor:=Ascan(aCabNota[1],cCpoCor+"_NUMCOR")
		If nPosCor>0
			nPosCorDat:=Ascan(aCabNota[1],cCpoCor+"_DTDIGIT")
			If nPosCorDat==0
				nPosCorDat:=Ascan(aCabNota[1],cCpoCor+"_EMISSAO")
			Endif
			nPosCorDoc:=Ascan(aCabNota[1],cCpoCor+"_DOC")
			nPosCorSer:=Ascan(aCabNota[1],cCpoCor+"_SERIE")
			nPosCorEsp:=Ascan(aCabNota[1],cCpoCor+"_ESPECIE")
			nPosCorFor:=Ascan(aCabNota[1],cCpoCor+If(cCpoCor="F1","_FORNECE","_CLIENTE"))
			nPosCorLoj:=Ascan(aCabNota[1],cCpoCor+"_LOJA")
			cIdCorr:=Iif(lUsaNewKey,SerieNfId(cAlias,4,PrefixoCpo(cAlias)+"_SERIE",aCabNota[2][nPosCorDat],aCabNota[2][nPosCorEsp],aCabNota[2][nPosCorSer]),aCabNota[2][nPosCorSer])
			aCabNota[2][nPosCor]:=CORR_GRAVA(If(nPosCorDat>0,aCabNota[2][nPosCorDat],dDataBase),;
												aCabNota[2][nPosCor],;
												If(nPosCorDoc>0,aCabNota[2][nPosCorDoc],""),;
												If(nPosCorSer>0,cIdCorr,""),; //If(nPosCorSer>0,aCabNota[2][nPosCorSer],"") //Chave Unica
												If(nPosCorEsp>0,aCabNota[2][nPosCorEsp],""),;
												If(nPosCorFor>0,aCabNota[2][nPosCorFor],""),;
												If(nPosCorLoj>0,aCabNota[2][nPosCorLoj],""))
		Endif
	Endif

	If cPaisLoc == "ARG"
		LOCXCabNf2(@aCabNota,@aCabNotaOri,SAliasHead,aCfgNf)
	EndIf

	//³Grava cabecalho³
	DBSelectArea(cAlias)
	RecLock(cAlias,!l103Class .AND. lID)
	nI := 0
	IF (cPaisloc== "PAR")
		xGrvCabPAR(FunName(), @aCabNota, cAlias)
	ENDIF
	IF (cPaisloc== "CHI") .AND. FindFunction("fGrvCabCHI")
		fGrvCabCHI(FunName(), @aCabNota, cAlias)
	ENDIF
	For nI := 1 to Len(aCabNota[1])
		//³Verifica existencia do campo³
		If &(cAlias+"->"+"(FieldPos('"+aCabNota[1][nI]+"')) <> 0")
			//³Verifica se e formula ou conteudo propriamente dito. O que define isso e a caracteristica da pos. do	³
			//³array de conetudo. Se for um array, a segunda pos. do mesmo deve indicar se e uma formula ou nao.	³
			//³Se for .T. executa formula do conteudo da pos. [1]
			If ValType(aCabNota[2][nI]) == "A"
				If Len(aCabNota[2][nI]) >= 2 .AND. !Empty(aCabNota[2][nI][1]) .AND. aCabNota[2][nI][2]
					Replace &(aCabNota[1][nI]) With ExecFormula(aCabNota[2][nI][1],,)
				EndIf
			ElseIf 	(PrefixoCpo(cAlias)+"_NUMCOR" == aCabNota[1][nI] .AND. lID ) .OR. PrefixoCpo(cAlias)+"_NUMCOR" <> aCabNota[1][nI]
				If lUsaNewKey
					If nI<>nPosSERIE .AND. nI<>nPosSDOC
						If cPaisLoc == "COL"
							xGrvCabCOL(aCabNota, nI)
						else
							Replace &(aCabNota[1][nI]) With aCabNota[2][nI]
						endif
					ElseIf nI==nPosSERIE
						SerieNfId(cAlias,1,PrefixoCpo(cAlias)+"_SERIE",aCabNota[2][nPosEMISS],aCabNota[2][nPosESPEC],aCabNota[2][nPosSERIE])
					EndIf
				Else
					If cPaisLoc == "COL"
						xGrvCabCOL(aCabNota, nI)
					else
						Replace &(aCabNota[1][nI]) With aCabNota[2][nI]
					endif
				Endif
			EndIf
		EndIf
	Next nI
	If cAlias=="SF1"
	   If l103Class
		  SF1->F1_RECBMTO := SF1->F1_DTDIGIT
		  SF1->F1_DTDIGIT := dDataBase
		  SF1->F1_FORMUL  := IIF(aCfgNF[SlFormProp],"S",IIF(SF1->F1_FORMUL=="N","N"," "))
		  If !Empty(SF1->F1_HAWB)
	  			SWN->(DbSetOrder(2))
				If SWN->(MsSeek(xFilial("SWN")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
					If SF1->F1_TIPO_NF $ '58'
                    	SW9->(dbSetOrder(1))
                 		SW9->(DbSeek(xFilial("SW9")+SF1->F1_DOC+Space(Len(SW9->W9_INVOICE)-Len(SF1->F1_DOC))+SF1->F1_FORNECE))
						SF1->F1_EMISSAO := SW9->W9_DT_EMIS
					ElseIf SF1->F1_TIPO_NF $ '67'
                        SW6->(dbSetOrder(1))
                        SW6->(MsSeek(xFilial("SW6")+SF1->F1_HAWB))
						SF1->F1_EMISSAO := SW6->W6_DTREG_D
					ElseIf SF1->F1_TIPO_NF $ '9A'
			        	//-- Posiciona Despesas/Gastos da import.
			        	SWD->(DbSetOrder(1))
			            SWD->(DbSeek(cSeek:=xFilial("SWD")+SWN->WN_HAWB))
						Do While SWD->(!Eof()) .AND. cSeek == SWD->WD_FILIAL+SWD->WD_HAWB
						    If SWD->WD_DOCTO == SWN->WN_DOC .AND. SWD->WD_SE_DOC == SWN->WN_SERIE
						    	Exit
						    EndIf
							SWD->(dbSkip())
						EndDo
						SF1->F1_EMISSAO := If( Empty(SWD->WD_DT_EMIS),SWD->WD_DES_ADI,SWD->WD_DT_EMIS)
					EndIf
                EndIf
		  EndIf
	   EndIf
	   IF cPaisLoc == "COL" .And. (lDocSp .Or. aCfgNF[SnTipo] == 23) .And. FINDFUNCTION( 'lxModDocSp' ) //Doc. Soporte - Nota Ajuste NDP
	   		lxModDocSp(cAlias, lDocSp,aCfgNF[SnTipo] )
	   Endif
       If cPaisLoc == "GUA" .AND. SF1->(FieldPos("F1_MOTIVO")) > 0 .AND. aCfgNf[ScTipoDoc] == "D" .AND. aCfgNF[SnTipo] < 10 //Nao deve considerar as Notas de envio(remitos)
		  SF1->F1_MOTIVO  := cMotivo
	   EndIf

	   //Grava total do adiantamento Mexico
	   If cPaisLoc $ "MEX|PER"
	     If MafisRet(,"NF_ADIANT") > 0
	   		SF1->F1_VALADI := MafisRet(,"NF_ADIANT")
	     EndIf
	   EndIf
	   If cPaisLoc == "ARG" .And. cTipo == "D" .And. GetNewPar('MV_DESCSAI','1') =='2' .And. ALLTRIM(SF1->F1_ESPECIE) $ "RFD"
	   		SF1->F1_VALMERC -= SF1->F1_DESCONT
	   EndIf
	Endif
	If cAlias=="SF2"
	   If GetNewPar('MV_DESCSAI','1') =='2'
		  SF2->F2_VALMERC -= SF2->F2_DESCONT
	   EndIf
       If cPaisLoc == "GUA" .AND. SF2->(FieldPos("F2_MOTIVO")) > 0 .AND. aCfgNf[ScTipoDoc] == "D" .AND. aCfgNF[SnTipo] < 10   //Nao deve considerar as Notas de envio(remitos)
		  SF2->F2_MOTIVO  := cMotivo
	   EndIf
	   If aCfgNf[ScCliFor] == "SA1" .AND. (aCfgNf[SnTipo] == 1 .OR. aCfgNf[SnTipo] == 50)
		   SF2->F2_REGIAO := Posicione("SA1",1,xFilial("SA1")+SF2->F2_CLIENTE+SF2->F2_LOJA,"A1_REGIAO")
       Endif

	   IF cPaisLoc == "COL" .And.  aCfgNF[SnTipo] == 22 .And. FINDFUNCTION( 'lxModDocSp' ) //Nota Ajuste NCP
	   		lxModDocSp(cAlias, lDocSp,aCfgNF[SnTipo] )
	   Endif
	   If cPaisLoc == "ARG"
	   		ArgActSF2(lContFol,@aCols,aHeader)
	   EndIf
	   //Grava total do adiantamento Mexico
	   If cPaisLoc $ "MEX|PER"
	   		If MafisRet(,"NF_ADIANT") > 0
	   			SF2->F2_VALADI := MafisRet(,"NF_ADIANT")
	   		EndIf
	   EndIf
	Endif
	If cPaisLoc == "EQU"
		LxGrvCabEq(cAlias, IIf(Type('cFormCrbo') <> 'U', cFormCrbo, ""))
	EndIf
	//Integraçao com o modulo ACD
	//Gera conferencia quando documento possui TES com controle de estoque
	If lConfFis .And. cAlias=="SF1"
		If SF1->F1_TIPODOC $ "51*53*60"
			SF4->(DbSelectArea("SF4"))
			SF4->(DbSetOrder(1))
			For nX := 1 to Len(aCols)
				If !aCols[nx][Len(aHeader)+1]
					If !Empty(aCols[nX][nPosTes])
						SF4->(MsSeek(xFilial("SF4")+aCols[nX][nPosTes]))
						If SF4->F4_ESTOQUE == "S"
			            	lConfere := .T.
			            	Exit
		    	    	EndIf
	    	   		EndIf
	           	EndIf
			Next
		ElseIf SF1->F1_TIPODOC $ "08*09*10"
			SF4->(DbSelectArea("SF4"))
			SF4->(DbSetOrder(1))
			For nX := 1 to Len(aCols)
				If !aCols[nx][Len(aHeader)+1]
					If !Empty(aCols[nX][nPosTes]) .And. Empty(aCols[nX][nPosRem])
						SF4->(MsSeek(xFilial("SF4")+aCols[nX][nPosTes]))
						If SF4->F4_ESTOQUE == "S"
			            	lConfere := .T.
			            	Exit
		    	    	EndIf
	    	   		EndIf
	           	EndIf
			Next
		EndIf
		If lConfere
			SF1->F1_STATCON := "0"
		EndIf
	EndIf
	MsUnlock()
	//³Guarda numero do registro³
	nRecnoC := Recno()
EndIf //lRet (1)
//Se Factura estiver vinculada a remito com divergencia, altera F1_STATCON para 4
If lConfFis .And. lRemDiv .And. cAlias=="SF1" .And. !lConfere .And. SF1->F1_TIPODOC == "10"
	aAreaSF1 := SF1->(GetArea())
	SF1->(dbSetOrder(1))
	For nX := 1 to Len(aCols)
		If !Empty(aCols[nX][nPosRem])
			If SF1->(MsSeek(xFilial("SF1")+aCols[nX][nPosRem]+aCols[nX][nPosRemS]+	aCols[nX][nPosForn]+aCols[nX][nPosLoja])) .And. SF1->F1_STATCON == "2"
				RestArea(aAreaSF1)
				RecLock("SF1", .F.)
					SF1->F1_STATCON := "4"
				MsUnlock()
			EndIf
		EndIf
	Next nX
EndIf
//³Ponto de Entrada apos gravacao dos campos de cabecalho³
cPe	:=	LocxPE(9)
If lRet .AND. !Empty(cPE) .AND. !lID
	ExecBlock(cPE,.F.,.F.)
EndIf
//³Devolvendo configuracoes do arquivo³
RestArea(aArea)
Return(nRecnoC)
/*ºPrograma  ³CONSISTECAMPOS ºLeandro C.G. ³Microsiga º Data ³  09/10/01  º±±
±±ºDesc.     ³ Verifica existencia de campos em um arquivo retornando os  º±±
±±º			 ³ campos que nao existem                                     º±±
param.
aCpos    - campos que devem ser consistidos
cAlias   - arquivo(Alias) em que os campos devem existir
lDevolve - Indica se deve retornar os campos nao existente ou nao (padrao .F.)
Obs.: se nao retornar os campos devolve .T. quando existirem todos os campos e .F. se algum campo nao existir
*/
Function ConsisteCampos(aCpos,cAlias,lDevolve)
Local nI   		   				//flag's para loop's
Local aArea      := GetArea()
Local aAreaSX3   := GetArea("SX3")
Local lRet       := .F.		//Devolucao da funcao
Local aNExist    := {} 		//Array que armazena todos os campos nao existentes. Pode ser devolvida como parametro se "lDevolve == .T."
Local aAux       := {}
Default lDevolve := .F.

//³Verifica existencia do Alias passado por parametro
If cAlias == NIL
	lRet := .F.
EndIf
If cAlias == NIL .OR. !ExisteAlias(cAlias)
	lRet := .F.
EndIf

If lRet //(1)
	//³Verifica existencia de cada campo passado como parametro para o Alias³
	DBSelectArea("SX3")
	DBSetOrder(2)
	Default aCpos := {}
	nI   := 0
	For nI := 1 to Len(aCpos)
		aAux := ExisteCampo(aCpos[nI],.T.) //Devolve duas posicoes [1]-indica existencia do campo [2]-indica status do campo(vide "ExisteCampo")
		//³Quando aAux[1] == .F. significa que o campo nao e valido                   ³
		//³Quando aAux[2] == 1, significa que o campo e virtual. Neste caso e feita a ³
		//³consistencia da existencia do campo no arquivo, atraves do FieldPos
		If 	!aAux[1]
			If !lDevolve
				RestArea(aAreaSX3)
				RestArea(aArea)
				lRet := .F.
				Loop
			EndIf
			AADD(aNExist,aCpos[nI])
		EndIf
	Next nI
EndIf //lRet (1)
RestArea(aAreaSX3)
RestArea(aArea)
//³Devolve campos que nao existem se houverem ou simplesmente indica ³
//³inconsistencia dos campos passadosÙ
Return(IIf(lDevolve, IIf(lRet,aNExist,{}), lRet))
/*ºPrograma  ³GravaCusNF     ºLeandro C.G. ³Microsiga º Data ³  15/10/01   º±±
±±ºDesc.     ³ Grava o valor de custo total de um item de uma NF		   º±±
±±º          ³nas cinco moedas, atualizando SD1 ou SD2					   º±±
cAlias   - Alias que deve ser gravado (SD1/SD2) (obrigt)
aCusto   - Custo a ser atualizado nas cinco moedas
*/
Function GravaCusNF(cAlias, aCusto)
Local cPrefixo := ""		//Prefixo do Alias (cAlias)
Local lRet 	   := .T.		//Retorno da funcao. Indica incosistencia da funcao
Local aArea    := {}		//Guarda config. atuais de arquivos
Local aPars	   := {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nI	   := 0

//³Consistindo param.
Aadd(aPars, {"cAlias"	, cAlias	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars, {"aCusto"	, aCusto	, SpEmpty					} )
Aadd(aPars, {"aCusto"	, aCusto[1]	, SpEmpty					} )
lRet := LocxParam("GRAVACUSNF",aPars)

ASIZE(aCusto, 5)
aArea  := GetArea()
If lRet //(1)
	//³Atualizando valor de custo³
	cPrefixo := PrefixoCpo(cAlias)
    RecLock(cAlias,.F.)
	Replace &( cPrefixo + "_CUSTO" )	With &( AllTrim(Str(aCusto[1])) )
	nI := 0
	For nI := 2 to Len(aCusto)
		Replace &( cPrefixo + "_CUSTO" + AllTrim(Str(nI)) )		With &( AllTrim(Str(aCusto[nI])) )
	Next nI
	Replace &( cPrefixo + "_CUSORI" )	With &( AllTrim(Str(aCusto[1])) )
	MsUnlock()
    If GetNewPar("MV_NGMNTES","N") == "S"
        NGSD1STL( , SD1->D1_FILIAL, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_COD, SD1->D1_ITEM, .T.)
    EndIf
EndIf //lRet (1)
Return(lRet)
/*ºPrograma  ³ESTQNOTA       ºLeandro C.G. ³Microsiga º Data ³  19/10/01   º±±
±±ºDesc.     ³ Efetua o controle de todas as atualizacoes referentes ao    º±±
±±º          ³estoque que sao necessarias na gravacao de uma NF  param:	   º±±
cAliasC		-	Alias de cabecalho de NF
cAliasI		- 	Alias de Itens de NF
cAliasCF	- 	Indica se e cliente ou fornec. (SA1-Cliente ; SA2-Fornec.)
cSinal 		- 	Indica se a movimentacao deve somar ou subtrair o estoque (+/-)
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
nRecnoC		- 	Numero do registro referente ao cabecalho da NF
aCusto		- 	Custo referente ao item da atualizacao de estoque em todas as moedas utilizadas
aPosicionou	- 	Array com a indicacao dos arquivos que estao posicionados posicionados
				[lSF4]-Indica se foi posicionado SF4 (TES)
				[lSB1]-Indica se foi posicionado SB1 (PRODUTO)
				[lSAx]-Indica se foi posicionado SA1 OU SA2 (CLIENTE OU FORN.)
				[lSC5]-Indica se foi posicionado SC5 (PEDIDOS DE VENDA)
				[lSC6]-Indica se foi posicionado SC6 (ITENS DE PEDIDOS DE VENDA)
				[lSC9]-Indica se foi posicionado SC9 (PEDIDOS DE VENDA LIBERADOS)
				[lSC7]-Indica se foi posicionado SC7 (PEDIDOS DE COMPRA)
lGeraPv		-	Indica se deve gerar pedido de venda sobre a NF, valido apenas para notas de devolucao (Default .F.)
Obs.: Esta rotina parte do principio que o registro de cabecalho e itens da NF ja estao posicionados no registro correto
*/
Function EstqNota(cAliasC,cAliasI,cSinal,cTipDoc,cAliasCF,nRecnoC,aCusto,aPosicionou,lGeraPv,aRecsSF1)
//³Variaveis Locais
Local nI//,nX														 	//Flag's para Loop's
//Local cPrefC      := cAliasC + "->" + PrefixoCpo(cAliasC)			//Prefixo do Alias de cabcalho (F1;F2)
Local cPrefI      := cAliasI + "->" + PrefixoCpo(cAliasI)  			//Prefixo do Alias de Itens (D1;D2)
Local cCliFor     := IIf(cAliasI=="SD1", "_FORNECE", "_CLIENTE")  	//Indica se e cliente ou fornec.
//Local cPreco      := IIf(cAliasI=="SD1", "_VUNIT", "_PRCVEN")  	//Indica se e cliente ou fornec.
//Local nQtdMoeda   := 5												//qtde utilizada de moedas
//Local aCusTot     := array(nQtdMoeda)								//Custo total em todas as moedas
Local lRet		  := .T.											//Retorno da funcao. Indica incosistencia da funcao
Local lEnviaCQ	  := .F.											//Indica se o item foi ou nao enviado ao controle de qualidade
Local aPars	   	  := {}												//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local cChave	  := ""
//Local nRecBD	  := 0
Local nQtdDist	  := 0
Local lRastro	  := .F.
Local cLoteSDA	  := ""
Local cFilSDB		:= xFilial("SDB")
Local aNfOrig     := array(7)		//array com o conteudo dos campos utilizados para chave de busca da nota de origem
Local lWmsNew  := SuperGetMV("MV_WMSNEW",.F.,.F.)
/*  [1]- _FILIAL
  	[2]- _DOC
	[3]- _SERIE
	[4]- _FORNECE;_CLIENTE
	[5]- _LOJA
	[6]- _COD
	[7]- _ITEM*/
//Local aDados     := array(15)		//Conteudo dos campos que serao gravados no SB6
/*
	[1] - Sequencia Identificadora (NUMSEQ quando for "Poder3 == R" e IDENTB6 quando for "Poder3 == D"
	[2]	 - Codigo do Produto
	[3]	 - Local - Almoxarifado
	[4]	 - Preco unitario do produto
	[5]	 - qtde da Movimentacao na unidade de medida 1
	[6]	 - Unidade de medida 1
	[7]	 - qtde da Movimentacao na unidade de medida 2
	[8]	 - Unidade de medida 2
	[9]	 - Codigo do Cliente ou Fornec.
	[10] - Codigo da loja do cliente ou Fornec.
	[11] - Numero da NF
	[12] - Serie da NF
	[13] - Data de Emissao da NF
	[14] - Data de lanç da NF
	[15] - Codigo do TES
*/

//Local cFilOri
Private cTipo 	 := cTipDoc			//Utiizada na funcao LxA103SB2 e precisava ser declarada
Private aPedPV	 := array(1)		//aray com conteudo para geracao de pedidos de venda a partir de uma nota de devolucao
/*
	[x][1] - serie da nota de origem (D1_SERIORI)
	[x][2] - numero da nota de origem (D1_NFORI)
	[x][3] - item da Nota de Origem (D1_ITEMORI)
	[x][4] - fornec. (D1_FORNECE)
	[x][5] - loja (D1_LOJA)
	[x][6] - qtde atual (D1_QUANT)
	[x][7] - Registro atual (Recno)
*/
Default lGeraPv  := .F.
Default aRecsSF1 := {}

//³Consistindo param.
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String	, "SF1"	, "SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars, {"cSinal"	, cSinal	, Sp2String	, "+"	, "-"	} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty					} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String	,"SA1"	, "SA2"	} )
Aadd(aPars, {"nRecnoC"	, nRecnoC	, SpEmpty					} )
Aadd(aPars, {"aCusto"	, aCusto	, SpEmpty					} )
If aCfgNf[SlConFrDp][1].OR.aCfgNf[SlConFrDp][2]
	Aadd(aPars, {"aRecsSF1"	, aRecsSF1	, SpEmpty	} )
Endif
lRet := LocxParam("ESTQNOTA", aPars)
If lRet
	//³Definindo valores padrao³
	Asize(aPosicionou, nMaxPos)
	nI := 0
	For nI := 1 to nMaxPos
		aPosicionou[nI] := IIf(aPosicionou[nI]==NIL, .F., aPosicionou[nI])
	Next nI
	If lRet
		//³Montando array com dados para localizar uma possivel NF de Origem
		aNfOrig := { &(cPrefI+"_FILIAL")	, &(cPrefI+"_NFORI")	, &(cPrefI+"_SERIORI")	, &(cPrefI+cClifor)	,;
		&(cPrefI+"_LOJA")		, &(cPrefI+"_COD")		, &(cPrefI+"_ITEMORI") 	}
		If lRet //(3)
			//³ Atualiza SB6 - Poder de Terceiros
			If SF4->F4_PODER3 $ "R|D"
				MaAtuSB6(cAliasI,IIf(cAliasI=="SD1",1,3))
			EndIf
			//³Ponto de Entrada apos atualizacoes do SB2³
			cPe	:=	LocxPE(10)
			If !Empty(cPE)
				ExecBlock(cPE,.F.,.F.)
			EndIf
			If lRet
				//³Tratamento do Controle de Qualidade³
				lEnviaCQ := TrataCQ(cAliasI,SF4->F4_CODIGO,SF4->F4_PODER3,cTipDoc,aRecsSF1)
				//³Atualiza SB2 - Saldos Fisico e financeiro  e Rastreabilidade³
				If cAliasI == "SD1"  //Chama rotina do padrao
					B2AtuComD1(&(cSinal + "1"))
				Else
					B2AtuComD2({SD2->D2_CUSTO1,SD2->D2_CUSTO2,SD2->D2_CUSTO3,SD2->D2_CUSTO4,SD2->D2_CUSTO5},;
						&(cSinal + "1"),If(aPosicionou[lSC9],{ {SD2->D2_PEDIDO,SD2->D2_ITEMPV,SD2->D2_SEQUEN,SD2->D2_QUANT,SD2->D2_QTSEGUM} },),aPosicionou[lSC9])

					//Atualização Estoque WMS
					If FindFunction("WmsFatMI")
						lRet := WmsFatMI(SD2->D2_PEDIDO, SD2->D2_ITEMPV, SD2->D2_SEQUEN, SD2->D2_COD,aPosicionou[lSC9],cEspecie)
					EndIf

					If lRet
						If(FindFunction("AtuLotEnd"),AtuLotEnd(),.F.) // Atualiza Lote e Endereco do Remito
						//³Gera o Servico no DCF - INTEGRACAO COM O WMS	 ³
						If  GetMV('MV_INTDL') == 'S' .AND. !Empty(SD2->D2_SERVIC) .AND. cAliasI == "SD2" .And. (!lWmsNew .OR. (lWmsNew .AND. !(AllTrim(cEspecie) $ "RTS|RCD|NCP"))) //quando e remito de transferencia será trado na funco acima o processo da ordem de serviço devido a nao possuir pedido de venda
							CriaDCF('SD2')
						EndIf
					EndIf
				EndIf
				If lRet
					//³ Envia o Produto em questao para o CQ (Materiais ou Celerina)
					If lEnviaCQ
						LxA103AtuQuali(SD1->D1_COD, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_ITEM, cTipDoc, .T., 1, aRecsSF1)
					EndIf
					//³ Gera Req. RE5 vinculada a NF Entrada ( Apr. OP )
					If cAliasI == "SD1"
						LxA103GerRE5(lEnviaCQ)
					EndIf
					//³Tratamento exclusivo para Notas de Devolucao³
					If cTipDoc == "D"
						//³Atualiza NF de Origem
						AtuNfOri(cAliasI,aNfOrig)
						//³Verifica se deve gerar pedido de venda
						If cAliasI == "SD1"  .AND. lGeraPv
							aPedPv[1] := { SD1->D1_SERIORI,SD1->D1_NFORI,SD1->D1_ITEMORI,SD1->D1_FORNECE+SD1->D1_LOJA,SD1->D1_QUANT,SD1->(Recno()) }
							a103GrvPV(1,aPedPv)
						EndIf
					EndIf
					//³Tratamento exclusivo para Notas de Retorno
					If aCfgNf[SnTipo] == 63
						//³Atualiza NF de Origem
						AtuNfOri(cAliasI,aNfOrig)
						//³Faz a distribuicao automatica
						If Localiza(SD1->D1_COD).AND. Alltrim(SF1->F1_PEDVEND) == "AUTO"
							nQtdDist	:=	SD1->D1_QUANT
							SD2->(DBSetOrder(3))
							If SD2->(MSSeek(aNfOrig[1]+aNfOrig[2]+aNfOrig[3]+aNfOrig[4]+aNfOrig[5]+aNfOrig[6]+aNfOrig[7]))
								cChave	:=	SD2->(D2_COD+D2_LOCAL+D2_NUMSEQ+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA)
								SDA->(DbSetOrder(1))
								SDA->(MsSeek(xFilial("SDA")+cChave))
								cLoteSDA	:=	SDA->DA_LOTECTL
								lRastro	:=	Rastro(SDA->DA_PRODUTO)
								SDB->(DbSetOrder(1))
								SDB->(MsSeek(xFilial("SDB")+cChave))
								While nQtdDist > 0 .AND. !SDB->(EOF()) .AND. cFilSDB == SDB->DB_FILIAL .AND. cChave == ;
									SDB->(DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC+DB_SERIE+DB_CLIFOR+DB_LOJA)
									If lRastro .AND. !(cLoteSDA==SDB->DB_LOTECTL)
										SDB->(dbSkip())
										Loop
									EndIf
									nRecDb	:=	SDB->(Recno())
									A100Distri(SD1->D1_COD, SD1->D1_LOCAL, SD1->D1_NUMSEQ, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SDB->DB_LOCALIZ, SDB->DB_NUMSERI, Min(SDB->DB_QUANT,nQtdDist), SDB->DB_LOTECTL, SDB->DB_NUMLOTE )
									nQtdDist	-=	Min(SDB->DB_QUANT,nQtdDist)
									SDB->(MsGoTo(nRecDb))
									SDB->(DbSkip())
								End
							Endif
						Endif
					Endif
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
Return(lRet)
/*ºPrograma  ³PosicionaC     ºLeandro C.G. ³Microsiga º Data ³  22/10/01   º±±
±±ºDesc.     ³ Posiciona arquivos utilizados na atualizacao da NF 		   º±±
±±º			 ³a partir do cabcalho da NF						   		   º±±
param.
cAliasC		- Alias de cabecalho da NF (SF1;SF2)
nRecnoC		- Numero do Registro de cabecalho da NF
cAliasCF	- Indica se deve posicionar Cliente ou Fornec. (SA1;SA2)
*/
Function PosicionaC(cAliasC,nRecnoC,cAliasCF)
Local cPrefC  := cAliasC + "->" + PrefixoCpo(cAliasC)			//Prefixo do Alias do cabecalho de NF
Local cCliFor := IIf(cAliasC=="SF2", "_CLIENTE", "_FORNECE")	//Campo de cliente ou fornec. de acordo com o arquivo de Nota
Local lRet 	  := .T.											//Retorno da funcao. Indica incosistencia da funcao
Local aPars   := {}												//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
//³Consistindo param.³
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String	, "SF1"	, "SF2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String	, "SA1"	, "SA2"	} )
Aadd(aPars, {"nRecnoC"	, nRecnoC	, SpEmpty					} )
lRet := LocxParam("POSICIONAC",aPars)
If lRet //(1)
	//³Posicionando arquivos³
	&( cAliasC  + "->(MSGoto(" + AllTrim(Str(nRecnoC)) + "))" ) //Cabecalho da Nota
	&( cAliasCF + "->(DBSetOrder(1))" )							 //Cliente ou fornec.
	&( cAliasCF + "->(MSSeek('" + xFilial(cAliasCF) + &(cPrefc+cCliFor) + &(cPrefC+"_LOJA") + "', .F.))" )
EndIf //lRet (1)
Return
/*ºPrograma  ³PosicionaI     ºLeandro C.G. ³Microsiga º Data ³  22/10/01   º±±
±±ºDesc.     ³ Posiciona arquivos utilizados na atualizacao da NF		   º±±
±±º			 ³a partir dos itens da NF						   	   		   º±±
param.
cAliasI	- Indica o Alias de Itens da NF
cAliasCF	- Indica se e cliente ou fornec. (SA1-CLIENTE / SA2-FORN.)
*/
Function PosicionaI(cAliasI,cAliasCF)
Local cPrefI  := ""							//Prefixo do Alias de Itens de Notas Fiscais
Local cPrefCF := ""    						//Prefixo do Alias de Cliente ou Fornec.
Local cCliFor := ""						    //Guarda nome do campo de cliente (_CLIENTE) ou (_FORN.) conforme o necessario
Local lRet 	  := .T.						//Retorno da funcao. Indica incosistencia da funcao
//Local cAliasR := ""							//Indica o Alias de Remito (SCN/SCM) utilizado de acordo com o tipo de NF
Local aPars   := {}						    //Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local aSeek   := Array(nMaxPos)			    //Array com indicacao dos arquivos que foram posicionados
Local aArea	  := GetArea()
Local aAreaI  := (cAliasI)->(GetArea())
Local aAreaSF1
/*
	[lSF4]-Indica se foi posicionado SF4 (TES)
	[lSB1]-Indica se foi posicionado SB1 (PRODUTO)
	[lSAx]-Indica se foi poscionado SA1 OU SA2 (CLIENTE OU FORN.)
	[lSC5]-Indica se foi posicionado SC5 (PEDIDOS DE VENDA)
	[lSC6]-Indica se foi posicionado SC6 (ITENS DE PEDIDOS DE VENDA)
	[lSC9]-Indica se foi posicionado SC9 (PEDIDOS DE VENDA LIBERADOS)
	[lSC7]-Indica se foi posicionado SC7 (PEDIDOS DE COMPRA)
	[lSD1]-Indica se foi posicionado SD1 (REMITO DE COMPRA)
	[lSD2]-Indica se foi posicionado SD2 (REMITO DE VENDA)
	[nRecSD1]-Indica o recno do SD1 se posicionado
	[nRecSD2]-Indica o recno do SD2 se posicionado */

//³Consistindo param.
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String	, "SA1"	, "SA2"	} )
lRet := LocxParam("POSICIONAI",aPars)

If lRet //(1)
	//³Definindo valores padrao³
	cPrefI  := cAliasI  + "->" + PrefixoCpo(cAliasI)
	cPrefCF := cAliasCF + "->" + PrefixoCpo(cAliasCF)
	cCliFor := IIf(cAliasI=="SD1","_FORNECE","_CLIENTE")
	Afill(aSeek, .T.)
	If SF4->(EOF().OR.BOF()) .OR. SF4->F4_FILIAL+SF4->F4_CODIGO != xFilial("SF4")+&(cPrefI+"_TES")
		SF4->( DBSetOrder(1) )
		aSeek[lSF4] := SF4->(MSSeek(xFilial("SF4")+&(cPrefI+"_TES"), .F.))
	EndIf
	If SB1->(EOF().OR.BOF()) .OR. SB1->B1_FILIAL+SB1->B1_COD != xFilial("SB1")+&(cPrefI+"_COD")
		SB1->( DBSetOrder(1) )
		aSeek[lSB1] := SB1->(MSSeek(xFilial("SB1")+&(cPrefi+"_COD"), .F.))
	EndIf
	If (cAliasCF)->(EOF().OR.BOF()) .OR. &(cPrefCF+"_FILIAL")+&(cPrefCF+"_COD")+&(cPrefCF+"_LOJA") != xFilial(cAliasCF)+&(cPrefI+cClifor)+&(cPrefI+"_LOJA")
		&( cAliasCF + "->( DBSetOrder(1) )" )
		aSeek[lSAx] := &( cAliasCF + "->( MSSeek('" + xFilial(cAliasCF) + &(cPrefI+cClifor) + &(cPrefI+"_LOJA") + "', .F.) )" )
	EndIf
	//³Arquivos so utilizados quando o arquivo de Notas for SD2
	If cAliasI == "SD2"
		//³PEDIDOS DE VENDA (SC5)
		If Empty(SD2->D2_PEDIDO)
			aSeek[lSC5] := .F.
		ElseIf SC5->(EOF().OR.BOF()) .OR. SC5->C5_FILIAL+SC5->C5_NUM != xFilial("SC5")+SD2->D2_PEDIDO
			SC5->(DBSetOrder(1))
			aSeek[lSC5] := SC5->(MSSeek(xFilial("SC5")+SD2->D2_PEDIDO, .F.))
		EndIf
		//³ITENS DE PEDIDOS DE VENDA (SC6)
		If Empty(SD2->D2_PEDIDO)
			aSeek[lSC6] := .F.
		ElseIf SC6->(EOF().OR.BOF()) .OR. SC6->C6_FILIAL+SC6->C6_NUM+SC6->C6_ITEM+SC6->C6_PRODUTO != xFilial("SC6")+SD2->D2_PEDIDO+SD2->D2_ITEMPV+SD2->D2_COD
	    	SC6->(DBSetOrder(1))
	    	aSeek[lSC6] := SC6->(MSSeek(xFilial("SC6")+SD2->D2_PEDIDO+SD2->D2_ITEMPV+SD2->D2_COD, .F.))
	 	EndIf
		//³PEDIDOS LIBERADOS (SC9)
		If Empty(SD2->D2_PEDIDO)
			aSeek[lSC9] := .F.
		ElseIf SC9->(EOF().OR.BOF()) .OR. SC9->C9_FILIAL+SC9->C9_CLIENTE+SC9->C9_LOJA+SC9->C9_PEDIDO+SC9->C9_ITEM+SC9->C9_SEQUEN+SC9->C9_PRODUTO != xFilial("SC9")+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_PEDIDO+SD2->D2_ITEMPV+SD2->D2_SEQUEN+SD2->D2_COD
			SC9->(DBSetOrder(1))
			aSeek[lSC9] := SC9->(MSSeek(xFilial("SC9")+SD2->D2_PEDIDO+SD2->D2_ITEMPV+SD2->D2_SEQUEN+SD2->D2_COD, .F.))
		EndIf
		//³CARGAS (DAK)
		If Empty(SF2->F2_CARGA)
			aSeek[lDAK] := .F.
		ElseIf (DAK->(EOF().OR.BOF()) .OR. DAK->(DAK_FILIAL+DAK_COD+DAK_SEQCAR) != xFilial("DAK")+SF2->(F2_CARGA+F2_SEQCAR))
			DAK->(DBSetOrder(1))
			aSeek[lDAK] := DAK->(MSSeek(xFilial("DAK")+SF2->(F2_CARGA+F2_SEQCAR), .F.))
		EndIf
		//³REMITOS³
		SD2->(DbSetOrder(3))
		aSeek[lSD2] 	:= SD2->(MSSeek(xFilial("SD2")+SD2->D2_REMITO+SD2->D2_SERIREM+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMREM))
		aSeek[nRecSD2]	:=	If(aSeek[lSD2],SD2->(Recno()),0)
		//³Acerta indicador de posicionamento de arquivos que nao foram posicionados³
		aSeek[lSC7] 	:= .F.
		aSeek[lSD1] 	:= .F.
		aSeek[nRecSD1]	:=	0
		aSeek[lSF1] 	:= .F.
		aSeek[nRecSF1]	:=	0
	//³Arquivos so utilizados quando o arquivo de Notas for SD2³
	ElseIf cAliasI == "SD1"
		//³PEDIDOS DE COMPRA (SC7)³
		If SC7->(EOF().OR.BOF()) .OR. SC7->C7_FILENT+SC7->C7_NUM+SC7->C7_ITEM != xFilEnt(xFilial("SC7"))+SD1->D1_PEDIDO+SD1->D1_ITEMPC
	    	SC7->(DBSetOrder(14))
	    	aSeek[lSC7] := SC7->(MSSeek(xFilEnt(xFilial("SC7"))+SD1->D1_PEDIDO+SD1->D1_ITEMPC, .F.))
		EndIf
		//³REMITOS³
		SD1->(DbSetOrder(1))
		aSeek[lSD1] 	:= SD1->(MSSeek(xFilial("SD1")+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMREM))
		aSeek[nRecSD1]	:=	If(aSeek[lSD1],SD1->(Recno()),0)

 		aAreaSF1  := SF1->(GetArea())
		SF1->(DbSetOrder(3))
		aSeek[lSF1] 	:= SF1->(MSSeek(xFilial("SF1")+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO))
		aSeek[nRecSF1]	:=	If(aSeek[lSF1],SF1->(Recno()),0)
		RestArea(aAreaSF1)
		//³Acerta indicador de posicionamento de arquivos que nao foram posicionados³
		aSeek[lSC5] 	:= .F.
		aSeek[lSC6] 	:= .F.
		aSeek[lSC9] 	:= .F.
		aSeek[lSD2] 	:= .F.
		aSeek[nRecSD2]	:=	0
	EndIf
	RestArea(aAreaI)
	RestArea(aArea)
EndIf //lRet (1)
Return(IIf(lRet,aSeek,NIL))
/*ºPrograma  ³AtuNfOri       ºLeandro C.G. ³Microsiga º Data ³  19/10/01   º±±
±±ºDesc.     ³ Atualiza dados de um item de uma NF de Origem no   		   º±±
±±º			 ³momento da devolucao										   º±±
param.
cAlias		- Alias do item da Nota de Devolucao
aNfOrig 	- array com o conteudo dos campos utilizados para chave de busca da nota de origem
          	As posicoes deste array se referem aos seguintes campos :
		  	[1]-D1_FILIAL
		  	[2]-D1_DOC
		  	[3]-D1_SERIE
		  	[4]-D1_FORNECE
		  	[5]-D1_LOJA
		  	[6]-D1_COD
		  	[7]-D1_ITEM
Obs.: Considera que a Nota de Devolucao esta posicionada no registro correto */
Static Function AtuNfOri(cAlias,aNfOrig)
Local cAOri    := ""			//Alias da Nota Original
Local cPref    := ""			//Prefixo do Alias atual
Local cPrefOri := ""			//Prefixo do Alias da Nota Original
Local aArea    := GetArea()		//Guarda area atual
Local lRet 	   := .T.			//Retorno da funcao. Indica incosistencia da funcao
Local aPars	   := {}			//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local cPesquisa := ""			// utilizada na pesquisa da nota pra atualizar a quantidade devolvida na noa correta

ASIZE(aNfOrig, 7)
//³Consistindo param. ³
Aadd(aPars, {"cAlias"	, cAlias, Sp2String		,"SD1"	,"SD2"	} )
lRet := LocxParam("ATUNFORI",aPars)

If lRet //(1)
	//³Atribuindo valores padrao³
	cAOri    := IIf(cAlias=="SD1", "SD2", "SD1") 		//Inverte o Alias
	cPref    := cAlias + "->" + PrefixoCpo(cAlias)
	cPrefOri := cAOri  + "->" + PrefixoCpo(cAOri)
	//³Posiciona Nota Original³
	&( cAOri + "->(DBSetOrder(" + IIf(cAOri=="SD1","1","3") + "))" )
	// devolução de protuto Loja
	// Pelo loja tem que usar o cliente de origem da SF2 pois se vendar para cliente padrão e devolver para outro cliente
	// a devolução tem que ser realizada no item da nota de origem
	If IsInCallStack("LOJA720")
		cPesquisa := cAOri + "->(MSSeek('" + aNfOrig[1]+aNfOrig[2]+aNfOrig[3]+SF2->F2_CLIENTE+SF2->F2_LOJA+aNfOrig[6]+aNfOrig[7] + "',	.F.))"
	Else
		cPesquisa := cAOri + "->(MSSeek('" + aNfOrig[1]+aNfOrig[2]+aNfOrig[3]+aNfOrig[4]+aNfOrig[5]+aNfOrig[6]+aNfOrig[7] + "',	.F.))"
	EndIf
	If &(cPesquisa)
		//³Atualizando dados³
		RecLock(cAOri, .F.)
		Replace &( cPrefOri + "_QTDEDEV" ) With &( cPrefOri + "_QTDEDEV + " + cPref + "_QUANT" )
		Replace &( cPrefOri + "_VALDEV" )  With &( cPrefOri + "_VALDEV + "  + cPref + "_TOTAL" )
		MsUnlock()
		//³Sao atualizados tambem os campos QTDEDEV e VALDEV das notas ou remitos associados³
		//³a nota ou remito original aqui posicionado.                                      ³
		//³Isso garante que futuras notas de credito ou remitos de devolucao considerem o   ³
		//³saldo a devolver corretamente.                                                   ³
		If "MATA102" $ Funname() .OR. "MATA462" $ Funname()
			// Pesquisa pela nota gerada pelo remito original
			DBSelectArea(cAOri)
			DBSetOrder(If(cAOri=="SD1",10,9))
			If MsSeek(aNfOrig[1]+aNfOrig[4]+aNfOrig[5]+aNfOrig[3]+aNfOrig[2]+aNfOrig[7], .F.)
				RecLock(cAOri, .F.)
				Replace &( cPrefOri + "_QTDEDEV" ) With &( cPrefOri + "_QTDEDEV + " + cPref + "_QUANT" )
				Replace &( cPrefOri + "_VALDEV" )  With &( cPrefOri + "_VALDEV + "  + cPref + "_TOTAL" )
				MsUnlock()
			EndIf
		Elseif "MATA465" $ Funname() .OR. "MATA466" $ Funname()
			// Pesquisa, se houver, o remito vinculado aa nota original
			If !Empty( &( cPrefOri + "_REMITO" )+&( cPrefOri + "_SERIREM" ) )
				DBSelectArea(cAOri)
				DBSetOrder(If(cAOri=="SD1",1,3))
				If MsSeek(aNfOrig[1]+&( cPrefOri + "_REMITO" )+&( cPrefOri + "_SERIREM" )+aNfOrig[4]+aNfOrig[5]+aNfOrig[6]+&( cPrefOri + "_ITEMREM" ), .F.)
					RecLock(cAOri, .F.)
					Replace &( cPrefOri + "_QTDEDEV" ) With &( cPrefOri + "_QTDEDEV + " + cPref + "_QUANT" )
					Replace &( cPrefOri + "_VALDEV" )  With &( cPrefOri + "_VALDEV + "  + cPref + "_TOTAL" )
					MsUnlock()
				EndIf
			EndIf
		EndIf
	EndIf
	//³Reposiciona area atual³
	RestArea(aArea)
EndIf //lRet (1)
Return(lRet)
/*ºPrograma  ³TrataCQ        ºLeandro C.G. ³Microsiga º Data ³  19/10/01   º±±
±±ºDesc.     ³ Atualiza dados de um item de uma NF de Origem no  		   º±±
±±º			 ³momento da devolucao										   º±±
param.
cAlias		- Alias da NF
cTes		- Tes utilizado na NF
cPoder3		- Indica qual a movimentacao de poder de terceiros (R-Remessa / D-Devolucao)
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
aRecSF1Ori  - Registros referentes as Notas Originais quando for uma Nota de Complemento ou de Frete

.:Devolve como resultado a variavel lEnviaCQ que diz se o produto foi enviado ao controle de qualidade.
Isto so ira ocorrer quando se tratar de uma de Entrada não de uma Devolucao */
Function TrataCQ(cAlias,cTes,cPoder3,cTipDoc,aRecSF1Ori)
Local cLocal 	:= ""
Local lEnviaCQ 	:= .F.
//³Verifica que tipo de arquivo de nota esta sendo gravado para saber se e uma entrada ou uma saida
//³ Verifica se o Produto em questao sera enviado ao CQ
//³ Atualiza o almoxarifado dos aqruivos do Items da NF e de Poder de 3os, gravando no ³
//³campo D1_LOCAL E B6_LOCAL o almoxarifado referente ao Controle de Qualidade
If cAlias == "SD1"
	If Empty(SD1->D1_REMITO)
		If 	LxA103ChkQuali(SD1->D1_COD, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_ITEM, cTipDoc, NIL) .AND.;
 			LxA103PreQuali(SD1->D1_COD, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_ITEM, SD1->D1_TES, .T.,@cLocal)

			lEnviaCQ := .T.
		EndIf
	EndIf
//³Nota de Saida  ³Esta parte da rotina foi retirada do fonte MATA461
ElseIf SF2->F2_TIPO == "D" .AND. cAlias == "SD2"
	//³Posiciona Nota de origem se houver³
	SD1->(dbSetOrder(1))
	If SD1->(MSSeek(xFilial("SD1")+SD2->D2_NFORI+SD2->D2_SERIORI+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM, .F.))
		//³Baixa do CQ
		If !Empty(SD1->D1_NUMCQ)
			MaCQ2SD2()
		EndIf
		//³ Atualiza lotes
		If Rastro(SD2->D2_COD) .AND. SF4->F4_ESTOQUE == "S" .AND. !(SF2->F2_TIPO) $ "CIP"
			RecLock("SD1",.F.)
			SD1->D1_NUMLOTE := SD2->D2_NUMLOTE
			SD1->D1_LOTECTL := SD2->D2_LOTECTL
			SD1->D1_DTVALID := SD2->D2_DTVALID
			MsUnLock()
		EndIf
	EndIf
EndIf
Return(lEnviaCQ)
/*³Fun‡…o    ³Amarracao ³±±
±±³Descri‡…o ³Atualiza amarracao de Cliente    X Produto ; (SA7)          ³±±
±±³			 ³						Fornec. X Produto ; (SA5)      	      ³±±
±±³			 ³ 						Fornec. X Grupo     (SAD)		  	  ³±±
param.
cPreco		- Preco unitario de amarracao 	 (obrigt qdo lInd1 ou lInd2 igual a .T.)
dEmissao 	- Data de emissao para amarracao (obrigt qdo lInd1 ou lInd2 igual a .T.)
lInd1		- Indica se deve ser feita amarracao de CLIENTEXPRODUTO    (Default .F.)
lInd2		- Indica se deve ser feita amarracao de FORNECEDORXPRODUTO (Default .F.)
lInd3		- Indica se deve ser feita amarracao de FORNECEDORXGRUPO   (Default .F.)
Obs.:Considera que os registros de Produto e Cliente ou Fornec. ja estao posicionados no registro correto */
Function Amarracao(cPreco,dEmissao,lInd1,lInd2,lInd3)
Local lAtuaSa7 := .F.	//Indica inclusao de registro no arquivo SA7 (CLIENTEXPRODUTO)
Local cAux,cAux1			//Auxiliares para carecteres
Local nAux,nAux1			//Auxiliares para numericos
Local lRet := .T.			//Retorno da funcao. Indica incosistencia da funcao
Local aPars := {}			//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nI,nX				//Flag's para Loop's
Default lInd1 := .F.
Default lInd2 := .F.
Default lInd3 := .F.
//³Consistindo param.³
If lInd1 .OR. lInd2
	Aadd(aPars, {"cPreco"	, cPreco	, SpEmpty	} )
	Aadd(aPars, {"dEmissao"	, dEmissao	, SpEmpty	} )
	lRet := LocxParam("AMARRACAO",aPars)
EndIf
If lRet //(1)
	//³Atualiza amarracao de CLIENTE X PRODUTO³
	If lInd1
		//³Verifica se já existe amarracao³
		SA7->(dbSetOrder(1))
		If !SA7->(MsSeek(xFilial("SA7")+SA1->A1_COD+SA1->A1_LOJA+SB1->B1_COD))
			//³Cria novo registro de amarracao³
			lAtuaSa7 := .T.
			Reclock("SA7",.T.)
			Replace A7_FILIAL  With xFilial("SA7")
			Replace A7_PRODUTO With SB1->B1_COD
			Replace A7_CLIENTE With SA1->A1_COD
			Replace A7_LOJA    With SA1->A1_LOJA
			Replace A7_PRECO01 With cPreco
			Replace A7_DTREF01 With dEmissao
			MsUnlock()
		Else
			//³Atualiza registro ja existente³
			nI := 0
			Reclock("SA7",.F.)
			For nI := 1 TO 12
				cAux := StrZero(nI,2)
				If Empty(A7_DTREF&cAux)
					lAtuaSa7 := .T.
					Replace A7_PRECO&cAux With cPreco
					Replace A7_DTREF&cAux With dEmissao
					MsUnlock()
					Exit
				EndIf
			Next nI
			//³Se necessario acerta valores dos ultimos 12 precos³
			If !(lAtuaSa7)
				nI := 0
				Reclock("SA7")
				For nI := 1 To 11
					nAux1 := nI + 1
					cAux  := StrZero(nI,2)
					cAux1 := StrZero(nAux1,2)
					Replace A7_PRECO&cAux With A7_PRECO&cAux1
					Replace A7_DTREF&cAux With A7_DTREF&cAux1
				Next nI
				Replace A7_PRECO12  With cPreco
				Replace A7_DTREF12  With dEmissao
				MsUnlock()
			EndIf
		EndIf
	EndIf
	//³Atualiza amarracao FORNECEDOR X PRODUTO³
	If lInd2
		SA5->(dbSetOrder(1))
		If !SA5->(MSSeek(xFilial("SA5")+SA2->A2_COD+SA2->A2_LOJA+SB1->B1_COD))
			RecLock("SA5",.T.)
			Replace A5_FILIAL  With xFilial("SA5")	,;
					A5_FORNECE With SA2->A2_COD		,;
					A5_LOJA    With SA2->A2_LOJA	,;
					A5_NOMEFOR With SA2->A2_NOME	,;
					A5_PRODUTO With SB1->B1_COD		,;
					A5_NOMPROD With SB1->B1_DESC
		EndIf
	EndIf
	//³Atualiza amarracao FORNECEDOR X GRUPO³
	If lInd3
		//³Posiciona arquivo de tabelas³
		SBM->(DBSetOrder(1))
		SBM->(MSSeek(xFilial("SBM")+SB1->B1_GRUPO))
		//³Verifica se existe o grupo e se ainda nao existe registro de amarracao³
       If !Empty(SB1->B1_GRUPO)
			SAD->(DBSetOrder(1))
			If !SAD->(MSSeek(xFilial("SAD")+SA2->A2_COD+SA2->A2_LOJA+SB1->B1_GRUPO))
				RecLock("SAD",.T.)
				Replace     AD_FILIAL   With xFilial("SAD")	,;
							AD_FORNECE  With SA2->A2_COD	,;
							AD_LOJA     With SA2->A2_LOJA	,;
							AD_NOMEFOR  With SA2->A2_NOME	,;
							AD_GRUPO    With SB1->B1_GRUPO	,;
							AD_NOMGRUP  With SBM->BM_DESC
			EndIf
		EndIf
	EndIf
EndIf //lRet (1)
Return(lRet)
/*³Fun‡…o    ³ExisteCampo ³ Autor ³ Leandro C. G.         ³ Data ³29/10/2001³±±
±±³Descri‡…o ³Verifica existencia de um campo qualquer param:               ³±±
cCampo		- Campo que sera procurado
lVirtual    - Considera(.T.) ou nao considera(.F.) campo virtual como campo existente (default .T.)
lForaUso	- Considera(.T.) ou nao considera(.F.) campo fora de uso como campo existente (default .T.)
lSemNivel	- Considera(.T.) ou nao considera(.F.) campo sem nivel como campo existente (default .T.)
Retorno
aRet		- array de duas posicoes com a validacao e o status do campo em relacao ao SX3
			(1) - lRet
			(2) - nRet */
Function ExisteCampo(cCampo,lVirtual,lForaUso,lSemNivel)
Local   aArea     := GetArea()
Local   aSX3	  := GetArea("SX3")
Local   lRet      := .T.				//Indica validacao do campo (.T./.F.)
Local   nRet      := 0
	/*De acordo com o numero, indica caracteristica do campo do SX3
		(0) - EXISTENTE
		(1) - NAO ENCONTRADO DO SX3
		(2) - CAMPO VIRTUAL
		(3) - CAMPO FORA DE USO
		(4) - NIVEL INSUFICIENTE
	*/
Local   aRet      := Array(2)			//(1)-lRet / (2)-nRet
Default cCampo    := ""
Default lVirtual  := .T.
Default lForaUso  := .T.
Default lSemNivel := .T.

aRet[1] := lRet
aRet[2] := nRet

DBSelectArea("SX3")
DBSetOrder(2)
If MSSeek(cCampo, .F.)
	lRet := IIf(!lVirtual.AND.SX3->X3_CONTEXT=="V",.F.,.T.)
	nRet := IIf(SX3->X3_CONTEXT=="V",2,0)
	If !(Substr(cCampo,4,6) $ "BASIMP*ALQIMP*VALIMP")
		lRet := IIf(lRet.AND.!lForaUso,IIf(!X3uso(SX3->X3_USADO),.F.,.T.),lRet)
		nRet := IIf(!X3uso(SX3->X3_USADO),3,nRet)
		lRet := IIf(lRet.AND.!lSemNivel,IIf(cNivel<SX3->X3_NIVEL,.F.,.T.),lRet)
		nRet := IIf(cNivel<SX3->X3_NIVEL,4,nRet)
	Endif
Else
	nRet := 1
	lRet := .F.
EndIf

aRet[1] := lRet
aRet[2] := nRet

RestArea(aArea)
RestArea(aSX3)
Return(aRet)
/*
±±³Fun‡…o    ³ExisteAlias ³ Autor ³ Leandro C. G.         ³ Data ³29/10/2001³±±
±±³Descri‡…o ³Verifica existencia de um Alias qualquer                      ³±±
param:   cAlias		- Alias que sera procurado */
Function ExisteAlias(cAlias)
Local   aArea	:= GetArea("SX2")
Local   lRet    := .T.
Default cAlias  := ""

SX2->(DBSetOrder(1))
lRet := IIf(!SX2->(MSSeek(cAlias, .F.)), .F., .T.)
RestArea(aArea)
Return(lRet)
/*³Fun‡…o    ³PrecoMarkup ³ ±±
±±³Descri‡…o ³Efetua a atualizacao do Preco de Venda de um produto com base ³±±
±±³          ³no Markup 	param:						                    ³±±
cProd		- Produto que deve ser atualizado
nQuant		- Qtde da movimentacao do produto
nCusto		- Custo total da movimentacao na moeda1
cGrupo		- Codigo do Grupo do Produto */
Function PrecoMarkup(cProd,nQuant,nCusto,cGrupo)
Local lRet 	 := .T.			//Retorno da funcao. Indica incosistencia da funcao
Local aPars  := {}				//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
//³Consistindo param.
Aadd(aPars, {"cProd"	, cProd		, SpEmpty		} )
Aadd(aPars, {"nQuant"	, nQuant	, SpEmpty		} )
Aadd(aPars, {"nCusto"	, nCusto	, SpEmpty		} )
lRet := LocxParam("PRECOMARKUP",aPars)

If lRet //(1)
	//³Atualizacao do Preco de Venda com base no Markup
	DBSelectArea("SBM")
	DBSetOrder(1)
	If MSSeek(xFilial("SBM")+cGrupo, .F.)
		If SBM->BM_MARKUP > 0 .AND. !Empty(SBM->BM_PRECO)
			If SBM->BM_PRECO > "1"
				DBSelectArea("SB5")
				DBSetOrder(1)
				If FieldPos("B5_PRV"+SBM->BM_PRECO)<>0 .AND. MSSeek(xFilial("SB5")+cProd, .F.)
					RecLock("SB5")
					FieldPut(FieldPos("B5_PRV"+SBM->BM_PRECO),nCusto*SBM->BM_MARKUP/nQuant)
					MsUnlock()
				EndIf
			Else
				RecLock("SB1")
				SB1->B1_PRV1 := nCusto*SBM->BM_MARKUP/nQuant
				MsUnLock()
			EndIf
		EndIf
	EndIf
EndIf //(1)
Return(lRet)
/*³Fun‡…o    ³AtuSA2Nf    ³ Autor ³ Leandro C. G.         ³ Data ³31/10/2001³±±
±±³Descri‡…o ³Efetua todas as atualizacoes necessarias no arquivo de 		³±±
±±³          ³fornec. (SA2)		param:						 				³±±
cAliasC		- Alias de cabecalho de NF
cAliasI		- Alias de Itens de NF
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cTipAtu     - Indica se e uma atualizacao pelo cabecalho da nota ou pelos itens
			  "C" - Cabecalho ; "I" - Itens
Obs.: Considera que os arquivos de NF e Fornec. estao posicionados no registro correto */
Function AtuSA2Nf(cAliasC,cAliasI,cTipDoc,cTipAtu)
Local nMCompra := 0							//Valor da maior compra
Local lRet 	   := .T.						//Retorno da funcao. Indica incosistencia da funcao
Local aPars	   := {}						//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
//³Consistindo paramteros³
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"cTipAtu"	, cTipAtu	, Sp2String		,"C"	,"I"	} )
lRet := LocxParam("ATUSA2NF",aPars)
If lRet //(1)
	//³Atualizacoes de cabecalho
	If cTipAtu == "C"
		//³Verifica valor da maior compra do fornec.³
		If cAliasC == "SF1" .AND. cTipDoc == "N"
			nMCompra := xMoeda(SF1->F1_VALBRUT,SF1->F1_MOEDA,Val(GetMv("MV_MCUSTO")),SF1->F1_DTDIGIT)
			If SA2->A2_MCOMPRA < nMCompra
				RecLock("SA2",.F.)
				Replace A2_MCOMPRA With nMCompra
				Replace A2_MNOTA   With Max(SA2->A2_MNOTA,nMCompra)
				MsUnlock()
			EndIf
		EndIf
	EndIf
EndIf //lRet (1)
Return(lRet)
/*³Fun‡…o    ³AtuSA1Nf    ³ Autor ³ Leandro C. G.         ³ Data ³31/10/2001³±±
±±³Descri‡…o ³Efetua todas as atualizacoes necessarias no arquivo de 		³±±
±±³          ³Clientes (SA1)												³±±
±±³ Uso      ³ ESTQNOTA  			param:								    ³±±
cAliasC		- Alias de cabecalho de NF
cAliasI		- Alias de Itens de NF
cTipDoc 	- Tipo de documento, utilizado para identificar se e uma devolucao
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cTipAtu     - Indica se e uma atualizacao pelo cabecalho da nota ou pelos itens
			  "C" - Cabecalho ; "I" - Itens
lPosicSC5	- Indica que foi posicionado o arquivo SC5 (pedidos de venda)
lPosicSC9	- Indica que foi posicionado o arquivo SC9 (itens de pedidos liberados)
Obs.: Considera que os arquivos de NF, TES e Clientes estao posicionados no registro correto */
Function AtuSA1Nf(cAliasC,cAliasI,cTipDoc,cTipAtu,lPosicSC5,lPosicSC9,nSinal)
Local lRet 	      := .T.	//Retorno da funcao. Indica incosistencia da funcao
Local aPars	   	  := {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nMCusto     := 0
Default lPosicSC5 := .F.
Default lPosicSC9 := .F.
Default nSinal		:=	1

//³Consistindo paramteros³
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"cTipAtu"	, cTipAtu	, Sp2String		,"C"	,"I"	} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty						} )
Aadd(aPars, {"nSinal"	, nSinal		, SpEmpty					} )
lRet := LocxParam("ATUSA1NF",aPars)
If lRet //(1)
	//³Atualizacoes de cabecalho da Nota cTipAtu == "C"³
	If cTipAtu == "C"
		//³Atualizando saldo de pedidos liberados³
		If !cTipDoc $ "DB" .AND. lPosicSC5 .AND. lPosicSC9 .AND. SF4->F4_DUPLIC == "S"
			Reclock("SA1",.F.)
			nMCusto := If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			Replace A1_SALPEDL With A1_SALPEDL - (xMoeda(SC9->C9_PRCVEN*SC9->C9_QTDLIB, SC5->C5_MOEDA, nMCusto, SC9->C9_DATALIB) * nSinal)
			MsUnlock("SA1")
		EndIf
	EndIf
EndIf //lRet (1)
Return(lRet)
/*
±±³Fun‡…o    ³AtuSB1Nf    ³ Autor ³ Leandro C. G.         ³ Data ³31/10/2001³±±
±±³Descri‡…o ³Efetua todas as atualizacoes necessarias no arquivo de 		³±±
±±³          ³Produtos (SB1)	param:										³±±
cAliasC		- Alias de cabecalho de NF
cAliasI		- Alias de Itens de NF
cTipDoc 	- Tipo de documento, utilizado para identificar se e uma devolucao
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cTipAtu     - Indica se e uma atualizacao pelo cabecalho da nota ou pelos itens
			  "C" - Cabecalho ; "I" - Itens
Obs.: Considera que os arquivos de NF, TES e Produtos estao posicionados no registro correto
*/
Function AtuSB1Nf(cAliasC,cAliasI,cTipDoc,cTipAtu)
Local   lRet 	    := .T.						//Retorno da funcao. Indica incosistencia da funcao
Local 	aPars	    := {}						//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local   aArea	    := {}
Local   cAuxPaisL   := "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"

//³Consistindo paramteros
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty						} )
Aadd(aPars, {"cTipAtu"	, cTipAtu	, Sp2String		,"C"	,"I"	} )
lRet := LocxParam("ATUSB1NF",aPars)
If lRet //(1)
	//³Atualizacoes de Itens da Nota cTipAtu == "I"³
	If cTipAtu == "I"
		//³Atualiza ultimo preco de compra³
		If 	cAliasC=="SF1" .AND. cTipDoc=="N" .AND. SF4->F4_UPRC=="S" .AND. SF1->F1_EMISSAO >= RetFldProd(SB1->B1_COD,"B1_UCOM")
			If RetArqProd(SB1->B1_COD)
				RecLock("SB1",.F.)
				Replace B1_UCOM With SF1->F1_EMISSAO
				Replace B1_UPRC With xMoeda(SD1->D1_VUNIT,SF1->F1_MOEDA,1,dDataBase,,SF1->F1_TXMOEDA)
				MsUnlock()
			Else
				aArea := GetArea()
				RecLock("SBZ",.F.)
				Replace BZ_UCOM With SF1->F1_EMISSAO
				Replace BZ_UPRC With xMoeda(SD1->D1_VUNIT,SF1->F1_MOEDA,1,dDataBase,,SF1->F1_TXMOEDA)
				MsUnlock()
				RestArea(aArea)
			Endif
			RecLock("SB1",.F.)
			If cPaisLoc $ cAuxPaisL
				Replace B1_UMOEC With SF1->F1_MOEDA
				Replace B1_UVLRC With SD1->D1_VUNIT
			EndIf
			MsUnlock()
		EndIf
	EndIf
EndIf //lRet (1)
Return(lRet)
/*
±±³Fun‡…o    ³AtuarqNf    ³ Autor ³ Leandro C. G.         ³ Data ³05/11/2001³±±
±±³Descri‡…o ³Efetua atualizacoes necessarias em todos os arquivos que devem³±±
±±³          ³ser gravados em uma gravacao de Notas Fiscais					³±±
±±³ Uso      ³ ESTQNOTA  	param:										    ³±±
cAliasC		- Alias de cabecalho de NF
cAliasI		- Alias de Itens de NF
cTipDoc 	- Tipo de documento, utilizado para identificar se e uma devolucao
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cTipAtu     - Indica se a funcao foi chamada na gravacao do cabecalho da nota ou do item
			  "C" - Cabecalho ; "I" - Item
aPosicionou	- 	Array com a indicacao dos arquivos que estao posicionados posicionados
				[lSF4]-Indica se foi posicionado SF4 (TES) ... obrigatoria
				[lSB1]-Indica se foi posicionado SB1 (PRODUTO)
				[lSAx]-Indica se foi posicionado SA1 OU SA2 (CLIENTE OU FORN.)
				[lSC5]-Indica se foi posicionado SC5 (PEDIDOS DE VENDA)
				[lSC6]-Indica se foi posicionado SC6 (ITENS DE PEDIDOS DE VENDA)
				[lSC9]-Indica se foi posicionado SC9 (PEDIDOS DE VENDA LIBERADOS)
				[lSC7]-Indica se foi posicionado SC7 (PEDIDOS DE COMPRA)
aCusto		- valor do custo referente ao item em todas as moedas utilizadas
aRateio		- array com os itens de rateio por centro de custo referente ao item atual (dados a atualizar no arquivo SDE)
			[x][1] - numero do item (XX_ITEM)
			[x][2] - dados a serem atualizados
aPergs		- Array com o conteudo das perguntas feitas na tela de NF
			[SlAmarraca 1]	-   Incluir Amarraçäo  ? (Cli.xProd.) ou (For.xProd.)
			[SlGerCtbil 2]	-   lanç. On-Line?
			[SlVerCtbil 3]	- 	Mostra Lanç.Contab ?
			[SlAglutina 4]	-	Aglut Lançamentos  ?
			[SlQbraAliq 5]	-	Quebra do Rodapé   ? Por Alíquota    /  Por Imposto
			[SlCtbEmiss 6]	-	Contabiliza por    ? Emissao         /  Data Base
aAtualiza 	- Define atualizacoes a serem feitas .T./.F. (quando .F. prevalece sobre o TES) - Default .T.
			   [SlCtbilOL]  - contabilzar On-line
			   [SlAtuEstq]  - atualizar estoque
			   [SlAtuFina]  - atualizar financeiro
			   [SlAtuImp]   - gravar impostos
			   [SlAtuLF]    - atualizar livros fiscais
			   [SlConsist]  - efetuar as rotinas de consistencia
			   [SlCusto]	- efetuar atualizacao do custo
nItem		- Numero do Item que esta sendo atualizado, quando a atualizacao for a partir da gravacao do item da Nota
Obs.: Considera que todos os arquivos de envolvidos com as atualizacoes estao posicionados em seus registros corretos
*/
Function AtuArqNf(cAliasC,cAliasI,cAliasCF,cTipDoc,cTipAtu,aPosicionou,nItem,aCusto,aRateio,aPergs,aAtualiza)
//Local nI,nX														//Flag's para Loop's
Local aArea    := GetArea()										//Salva area de trabalho
Local cPrefI   := ""											//Prefixo do Alias de itens da NF
Local cPreco   := IIf(cAliasI=="SD1", "_VUNIT", "_PRCVEN")  	//Indica se e cliente ou fornec.
Local lRet 	   := .T.											//Retorno da funcao. Indica incosistencia da funcao
Local aPars	   := {}											//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
//Local nV       := 0
//Local cBaseATF := ""
Local aAreaSD1 := {}
Local lAtuSB3:=.T.

//³Consistindo paramteros³
Aadd(aPars		, {"cAliasC"	, cAliasC	, Sp2String	, "SF1"	, "SF2"	} )
Aadd(aPars		, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars		, {"cAliasCF"	, cAliasCF	, Sp2String	, "SA1"	, "SA2"	} )
Aadd(aPars		, {"cTipAtu"	, cTipAtu	, Sp2String	, "C"	, "I"	} )
Aadd(aPars		, {"cTipDoc"	, cTipDoc	, SpEmpty					} )
If cTipAtu == "I"
	Aadd(aPars	, {"nItem"	, nItem	, SpEmpty							} )
EndIf
lRet := LocxParam("ATUARQNF",aPars)

//³Valores padrao³
cPrefI 			  := cAliasI + "->" + PrefixoCpo(cAliasI)
Default aCusto	  := {}
Default aRateio	  := {}
Default aPergs    := {}
Default aAtualiza := {}

If lRet //(1)
	//³Atualizacoes efetuadas quando a rotina for chamada pela gravacao de um item da NF ³
	If cTipAtu == "I"
		//³Atualizacoes relacionadas exclusivamente ao arquivo SD1/SF1³
		If cAliasI == "SD1"
			//³Atualizacao do preco de venda com base no Markup³
			If aPosicionou[lSF4] .AND. SF4->F4_UPRC == "S" .AND. aPosicionou[lSB1]
				If !PrecoMarkup(SD1->D1_COD,SD1->D1_QUANT,SD1->D1_CUSTO,SB1->B1_GRUPO)
					lRet := .F.
				EndIf
			EndIf
			If lRet //(2)
				//³Atualizacoes referentes ao Arquivo de Pedidos de Compra³
				If  aPosicionou[lSC7]
					LxA103SC7(1)
				EndIf
				//³Atualiza Rateios por Centro de Custo³
				If !Empty(aRateio) .AND. aScan(aRateio, { |x| x[1] == &(cPrefI+"_ITEM") } ) > 0
					NfRateioCC(aRateio,1,aCusto,nItem)
				EndIf
				//³ Grava os dados referentes ao CIAP SF9 ³
				LxA103SF9(1)
				//³EXECUTAR CHAMADA DE FUNCAO p/ integracao com sistema de Distribuicao - NAO REMOVER ³
				If GetMV("MV_FATDIST") == "S" // Apenas quando utilizado pelo modulo de Distribuicao
					DS100SD1I()
				EndIf
				//³Integracao TMS  ³
				If IntTMS() .And. ( (Type("aRatVei") == "A" .And. Len(aRatVei) > 0) .Or. (Type("aRatFro") == "A" .And. Len(aRatFro) > 0) )
					//³Verifica se o Item da NF foi rateado por Veiculo/Viagem ou por Frota    ³
				    If Type("aRatVei") == "A" .And. aScan(aRatVei,{|x| x[1] == SD1->D1_ITEM}) > 0
					    A103GrvSDG(aRatVei,"V")
					ElseIf Type("aRatFro") == "A" .AND. aScan(aRatFro,{|x| x[1] == SD1->D1_ITEM}) > 0
						A103GrvSDG(aRatFro,"F")
					EndIf
				EndIf
				//³ Integracao com o modulo de Projetos ³
				If IntePms()
					//³Atualiza os arquivos de Gerenciamento de Projetos - SIGAPMS - 1:Inclusao³
					PmsWriteNF(1,"SD1")
				EndIf
			EndIf //lRet (2)
		//³Atualizacoes relacionadas exclusivamente ao arquivo SD2/SF2³
	   ElseIf cAliasI == "SD2" .AND. lRet
			//³Atualizacao dos Itens de Pedido de Vendas (SC6)³
			If aPosicionou[lSC6]
				//³Atualizando Itens de PEDIDOS de venda (SC6)³
				RecLock("SC6",.F.)
				MaAvalSC6("SC6",5,,,,,,,,,"SD2",aCfgNF[SlRemito])
				//³Ponto de Entrada na atualizacao do SC6³
				cPe	:=	LocxPE(12)
				If !Empty(cPE)
					Execblock(cPE,.F.,.F.)
				EndIf
				MsUnlock()
			EndIf
			//³Atualizacao do Pedido de Vendas (SC5)³
			If aPosicionou[lSC5] .AND. SC5->C5_NOTA != SD2->D2_DOC
				MaAvalSC5("SC5",5,,,,,,,,SD2->D2_PEDIDO)
			EndIf
			//³Atualiza Rateios por Centro de Custo³
			If !Empty(aRateio) .AND. aScan(aRateio, { |x| x[1] == &(cPrefI+"_ITEM") } ) > 0
				NCRateioCC(aRateio,1,aCusto,nItem)
			EndIf
			//³Atualizacao dos Itens de Pedido de Vendas Liberados (SC9)³
			If aPosicionou[lSC9]
				//³Atualizando Itens de PEDIDOS de venda Liberados (SC9)³
				RecLock("SC9",.F.)
				MaAvalSC9("SC9",11,,,,,,,,aCfgNF[SlRemito])
				MsUnlock("SC9")
			EndIf
			
			If lRet .And. ExistBlock('MT462BLQ') 
				lAtuSB3 := ExecBlock('MT462BLQ', .F., .F., {SF2->F2_ESPECIE})
			EndIf
			
			//³Atualizacao do Arquivo de demandas (SB3)³
			If cTipDoc <> "B" .And. lAtuSB3
				AtuSB3Nf()
			EndIf
			//³ Integracao com o modulo de Projetos
			If IntePms()
				//³Atualiza os arquivos de gerenciamento de Projetos
				If Type("aHdrAFS") == "A" .and. Type("aRatAFS") == "A"
					SF4->(PmsWriteD2(1,"SD2",,@aHdrAFS, @aRatAFS))
				else
					SF4->(PmsWriteD2(1,"SD2"))
				EndIf
			Endif
			//³ Actualiza cantidad entregada en el pedido de compra por inclusion de remito de devolucion (SC7)
			If cPaisLoc == "ARG" .And. FunName() $ "MATA102DN|MATA466N"
				aAreaSD1 := SD1->(GetArea())
				dbSelectArea("SD1")
				SD1->(DbSetOrder(1)) //D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
				If SD1->(MsSeek(xFilial("SD1") + SD2->(D2_NFORI + D2_SERIORI + D2_CLIENTE + D2_LOJA + D2_COD + D2_ITEMORI)))
					If FindFunction("ArgActQUJE")
						ArgActQUJE(SD1->D1_PEDIDO,SD1->D1_ITEMPC,SD2->D2_QUANT,SD2->D2_TES)
					EndIf
					If  FunName() $ "MATA102DN" 
						ArgActSB2(SD2->D2_COD,SD2->D2_QUANT,SD1->D1_COD,SD1->D1_LOCAL,SD1->D1_TES)
					EndIf 
				EndIf
				RestArea(aAreaSD1)
			EndIf
		EndIf
		If lRet //(3)//³Atualizacoes Gerais³
			If &(cAliasI+"->(FieldPos('"+PrefixoCpo(cAliasI)+"_REMITO'))<>0") .AND. !Empty(&(cPrefI+"_REMITO"))
				//³Atualizacao de Remitos (SD1/SD2) ³
				If !aCfgNF[SlRemito].AND. (aPosicionou[lSD1] .OR. aPosicionou[lSD2])
					AtuREMNF(aPosicionou)
				EndIf
			EndIf
			//³Amarracao de CLIENTEXPRODUTO / FORNECEDORXPRODUTO / FORNECEDORXGRUPO³
			If !Amarracao( &(cPrefI+cPreco), &(cPrefI+"_EMISSAO"), (cAliasCF=="SA1" .AND. aPergs[SlAmarraca]), (cAliasCF=="SA2" .AND. aPergs[SlAmarraca]), (cAliasCF=="SA2" .AND. aPergs[SlAmarraca]) )
				lRet := .F.
			EndIf
			//³Atualizacao de Cargas e Transportes³
			If aPosicionou[lDAK] .AND. aPosicionou[lSC9] .AND. !Empty(SC9->C9_CARGA)
				OsAvalDAK("SC9",7,,,aCfgNF[SlRemito])
			EndIf
		EndIf //lRet (3)
	EndIf
	//³Atualizacoes que podem ocorrer tanto na gravacao dos itens quanto na gravacao de cabecalho³
	If lRet //(4)
		//³Cadastro de Produtos³
		If aPosicionou[lSB1]
			AtuSB1Nf(cAliasC,cAliasI,cTipDoc,cTipAtu)
		EndIf
		//³Arquivo de Cliente ou Fornec. ³
		If cAliasCF == "SA1"
			AtuSA1Nf(cAliasC,cAliasI,cTipDoc,cTipAtu)		//CLIENTE
		Else
			AtuSA2Nf(cAliasC,cAliasI,cTipDoc,cTipAtu)		//FORN.
		EndIf
	EndIf //(4)
EndIf //lRet (1)
RestArea(aArea)
Return lRet
/*
±±³Fun‡…o    ³AtuSB3Nf    ³ Autor ³ Leandro C. G.         ³ Data ³07/11/2001³±±
±±³Descri‡…o ³Atualiza arquivo de Demandas a partir da NF 	   	 		    ³±±
±±³ Uso      ³ ATUARQNF  												    ³±±
Obs.: Considera que o arquivo de NF esta posicionado no registro correto
*/
Function AtuSB3Nf()
//³Atualizando Arquivo de demandas (SB3)³
SB3->(DBSetOrder(1))
RecLock("SB3", !SB3->(MSSeek(xFilial("SB3")+SD2->D2_COD, .F.)))
SB3->B3_FILIAL := xFilial("SB3")
SB3->B3_COD    := SD2->D2_COD
SB3->B3_MES    := SD2->D2_EMISSAO
&( "SB3->B3_Q" + StrZero(Month(SD2->D2_EMISSAO), 2) + " " + IIf(SD2->D2_TES<="500","-","+") + "= SD2->D2_QUANT" )
MsUnlock("SB3")
Return(.T.)

/*
±±³Fun‡…o    ³AtuRemNf    ³ ±±
±±³Descri‡…o ³Atualiza arquivo de Remito de Venda ou compra a partir da NF  ³±±
±±³ Uso      ³ ATUARQNF  													³±±
*/
Function AtuREMNf(aPosicionou)
Local nQuant		:= 0
Local aArea			:=	GetArea()
Local aAreaI
Local aCusto		:=	{}
If aPosicionou[lSD2]
	aAreaI	:=	SD2->(GetArea())
	nQuant	:=	SD2->D2_QUANT
	SD2->(MsGoTo(aPosicionou[nRecSD2]))

	//³Atualizando SD2³
	RecLock("SD2", .F.)
	SD2->D2_QTDEFAT += nQuant
	SD2->D2_QTDAFAT := SD2->D2_QUANT - SD2->D2_QTDEFAT
	MsUnLock()

	RestArea(aAreaI)
ElseIf aPosicionou[lSD1]
	aCusto	:=	{SD1->D1_CUSTO/SD1->D1_QUANT,SD1->D1_CUSTO2/SD1->D1_QUANT,SD1->D1_CUSTO3/SD1->D1_QUANT,SD1->D1_CUSTO4/SD1->D1_QUANT,SD1->D1_CUSTO5/SD1->D1_QUANT}
	aAreaI	:=	SD1->(GetArea())
	nQuant	:=	SD1->D1_QUANT
	SD1->(MsGoTo(aPosicionou[nRecSD1]))

	//³Atualizando SD1 - Remito³
	NfAtuSD1(nQuant,1,aCusto)
	RestArea(aAreaI)
Endif
RestArea(aArea)
Return .T.

/*
±±³Fun‡…o    ³VarreItNf
±±³Descri‡…o ³Varre os itens da NF que esta sendo gravada e efetua		    ³±±
±±³			 ³todas as atualizacoes necessarias						       	³±±
param.
aCfgNf	-	Array com todas as config. da NF
			[SnTipo]		- codigo do tipo de NF
			[ScEspecie]		- codigo da especie da NF
    		[ScCliFor]		- indica se e cliente("C") ou fornec.("F")
			[SlFormProp]	- indica se e formulario proprio(0) ou nao(1)
			[SAliasHead]	- arquivo de cabecalho da nota
			[SAliasCols]	- arquivo de itens da nota
			[ScOpEstoq]		- indica se soma ou subtrai o estoque
			[ScAliasFin]	- arquivo financeiro a atualizar
			[ScOpFin]		- indica sinal para movimentacao financeira
			[ScTipoDoc]		- tipo de documento {N- ;C- ;D-	;B)
			[SaAtualiza]	- array com as permissoes para efetuar movimentacoes
			[SaLancPadC]	- Array com o numero dos lanç. padrao referentes a Cabecalho
			[SaLancPadI]	- Array com o numero dos lanç. padrao referentes a Itens
       	[SaBotoes]		- Array com os botoes da tela, quando for tela
			[SaTeclas]		- Array com as funcoes chamadas por tecla te atalho e todas as respectivas teclas
			[SaPergs]		- Array com as perguntas efetuadas na entrada da NF (aPergs)
			[SaPE]			- Array com todos os pontos de entrada em suas devidas posicoes, de acordo com o tipo de Nota
			[SlRemito]		- Define se se trata de um remito
aRecnoI 	-	Array que guarda o numero dos registros de itens gravados
nRecnoC 	-	Guarda o numero do registro de cabecalho gravado
aRatCC		- array com os itens de rateios por centro de custo de todos os itens da NF
			[x][1] - Numero do Item da NF (D1/D2_ITEM)
			[x][2] - Itens de Rateios por centro de custo para este item (dados que serao gravados no ar
aGeraPv		- array indicando se cada item deve ou nao gerar pedido de venda quando for uma devolucao de venda
*/
Function VarreItNf(aCfgNf,aRecnoI,nRecnoC,aRatCC,aGeraPv,aRecsSF1, aDigEnd)
Local aArea			:= GetArea()
Local aAreaSA2      := SA2->(GetArea())
Local lRemInt       := SuperGetMv("MV_REMINT",.F.,.F.)
Local lEIC          := Iif(SuperGetMv("MV_EASY",.F.,"N")=="S",.T.,.F.)
Local nI//,nX								//Flag's para loop's
Local nCt           := 0
Local aCusto 		:= {}				//Array com os custos do item
//Local nPos			:= 0				//Posição qualquer de um array
Local lRet			:= .T.				//Indica inconsistencia da Rotina
Local cAliasI		:= aCfgNf[SAliasCols]
Local aAreaSD2  	:= {}
Local aPars	   		:= {}				//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local lVer116  		:= .T.
Local lDISTMOV 		:= SuperGetMV("MV_DISTMOV",.F.,.F.)
Local aPosicionou 	:= array(nMaxPos)	//Array com a indicacao dos arquivos que estao posicionados posicionados
/*	[lSF4]-Indica se foi posicionado SF4 (TES)
	[lSB1]-Indica se foi posicionado SB1 (PRODUTO)
	[lSAx]-Indica se foi posicionado SA1 OU SA2 (CLIENTE OU FORN.)
	[lSC5]-Indica se foi posicionado SC5 (PEDIDOS DE VENDA)
	[lSC6]-Indica se foi posicionado SC6 (ITENS DE PEDIDOS DE VENDA)
	[lSC9]-Indica se foi posicionado SC9 (PEDIDOS DE VENDA LIBERADOS)
	[lSC7]-Indica se foi posicionado SC7 (PEDIDOS DE COMPRA)
*/
Local nRecno		:= 0
//Local lPrNFBen 		:= SuperGetMV("MV_PRNFBEN",.F.,.F.)
Local cFilSD2		:= xFilial("SD2")
Local nTotRecnoI := Len(aRecnoI)
Local  aAreaAt:= {}
//Local nCantFA := 0
//Local nTotlFA := 0
Local lActQta := FindFunction("LxMxPFact") .And. SD2->(ColumnPos("D2_DESGR1")) > 0  .And. SD2->(ColumnPos("D2_DESGR2")) > 0

//³Consistindo param
Aadd(aPars, {"aCfgNf"	, aCfgNf	, SpEmpty				} )
Aadd(aPars, {"aRecnoI"	, aRecnoI	, SpEmpty				} )
Aadd(aPars, {"nRecnoC"	, nRecnoC	, SpEmpty				} )
lRet := LocxParam("VARREITNF",aPars)
If lRet //(1)
	//³Valores Padrao³
	cPref := aCfgNf[SAliasCols] + "->" + PrefixoCpo(aCfgNf[SAliasCols])
	Asize(aGeraPv, Len(aRecnoI))
	Aeval(aGeraPv, {|x,y| IIf(Empty(x),aGeraPv[y]:=.F.,)} )
	//³Varrendo todos os itens
	nI := 0
	For nI := 1 to nTotRecnoI
		nRecno := SF1->(RecNo())
 		If nCt==0
			If aCfgNf[SAliasHead] == "SF1" .AND. aCfgNf[SnTipo] == 13
				A119Grava(.F.,nRecnoC,aRecsSF1,,aAmarrAFN)
				nCt++
			EndIf
			If aCfgNf[SAliasHead] == "SF1" .AND. aCfgNf[SnTipo] == 14
				A116Grava(.F.,nRecnoC,aRecsSF1,,aAmarrAFN)
				nCt++
			EndIf
		SF1->(MsGoTo(nRecno))
		EndIf
		//³Verifica validade do numero do registro atual e posiciona o arquivo de itens
		If aRecnoI[nI,1] == NIL .OR. aRecnoI[nI,1] <= 0
			Loop
		Else
			DBSelectArea(aCfgNf[SAliasCols])
			MSGoto(aRecnoI[nI,1])
		EndIf
		If cAliasI == "SD1"
			//³ Tratamento para Remitos Internos
			If lRemInt
			  	If (SD1->D1_TIPO_NF $ '5' .AND. SD1->D1_TIPODOC $ '10') .OR. ;
				  	(!Empty(SD1->D1_REMITO) .And. !lEIC) .OR. SD1->D1_TIPO_NF $ '6789AB'
					Loop
				EndIf
			EndIf
		EndIf
		//³Posicionando todos os arquivos que devem ser utilizados na atualizacao de processos a partir ³
		//³de um item da NF. Nao devem ser efetuados "Seek's" em nenhum arquivo a nao ser 	    ³
		//³dentro desta rotina ou na rotina PosicionaC, nao sendo estritamente necessario
		aPosicionou := PosicionaI(aCfgNf[SAliasCols],aCfgNf[ScCliFor])
		If aPosicionou == NIL
			lRet := .F.
		EndIf
		If lRet //(2)
			//³PE para alterar qtde na segunda unidade de medida³
			cPe	:=	LocxPE(13)
			If !Empty(cPE) .AND. aCfgNf[SAliasCols] == 'SD2'
				nQtd2UM := Execblock(cPE,.F.,.F.,SC9->(Recno()))
				If cAliasI == "SD2" .AND. !Empty(nQtd2UM) .AND. nQtd2UM > 0
					RecLock("SD2",.F.)
					SD2->D2_QTSEGUM := nQtd2UM
					MsUnlock()
				EndIf
			EndIf
			//³Grava o custo do Item da NF e devolve os valores gravados em todas as moedas³
			aCusto := NfGravaCusto(aCfgNf[SAliasCols],aCfgNf[ScTipoDoc],aRecnoi[nI,2])
	  		If Empty(&(aCfgNf[SAliasCols]+"->"+PrefixoCpo(aCfgNf[SAliasCols])+"_REMITO"))
				//³Efetua todas as atualizacoes referentes ao Estoque³
				If aPosicionou[lSF4] .AND. SF4->F4_ESTOQUE == "S" .AND. aCfgNf[SaAtualiza][SlAtuEstq]
					If !EstqNota(aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScOpEstoq],aCfgNf[ScTipoDoc],aCfgNf[ScCliFor],nRecnoC,aCusto,aPosicionou,aGeraPv[nI],aRecsSF1)
						lRet := .F.
					EndIf
				ElseIf aPosicionou[lSF4] .AND. SF4->F4_ESTOQUE == "N"
					If SF4->F4_PODER3 $ "R|D"
						//³ Atualiza SB6 - Poder de Terceiros
						MaAtuSB6(cAliasI,If(cAliasI=="SD1",1,3))
					Else
						aAreaSD2 := SD2->(GetArea())
						If cPaisLoc $ "ARG|CHI|URU|PAR"
    						 aAreaAt:=GetArea()
    						DbSelectArea("SD2")
    						SD2->(DbSetOrder(3))
						EndIf
						If (aCfgNF[SnTipo]== 21 .Or. aCfgNF[SnTipo]== 01) .And. cPaisLoc $ "MEX" .And. lActQta
							xItNFMex(cFilSD2)
						Else
							If SD2->( MsSeek(cFilSD2+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMORI) )
								RecLock("SD2",.F.)
								Replace SD2->D2_QTDEDEV With SD2->D2_QTDEDEV + SD1->D1_QUANT
								Replace SD2->D2_VALDEV  With SD2->D2_VALDEV  + SD1->D1_TOTAL
								MsUnlock("SD2")
							EndIf
						EndIF

						If cPaisLoc $ "ARG|CHI|URU|PAR"
							RestArea(aAreaAt)
						EndIf
						RestArea(aAreaSD2)
					EndIf
				EndIf
			Endif
			If lRet //(3)
				//³Efetua atualizacao de todos os arquivos necessarios, na gravacao de um item de uma NF
				If !AtuArqNf(aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[ScTipoDoc],"I",aPosicionou,nI,aCusto,aRatCC,aCfgNf[SaPergs],aCfgNf[SaAtualiza])
					lRet := .F.
				EndIf
				//³Ponto de Entrada apos as atualizacoes de cada item³
				DBSelectArea(aCfgNf[SAliasCols])
				cPe	:=	LocxPE(14)
				If lRet .AND. !Empty(cPE)
					ExecBlock(cPE,.F.,.F.,{nI})
				Endif
				//³ Disparar Rdmakes para Tratamento especifico. ³
				cPe	:=	LocxPE(15)
				If !Empty(cPE)
					ExecBlock(cPE,.F.,.F., { SD1->D1_REMITO, SD1->D1_ITEMREM, SD1->D1_DOC, SD1->D1_SERIE, nI })
				EndIf
			EndIf //lRet (3)
		EndIf //lRet (2)
		//Diglot
		IF lVer116 .AND. lDistMov .and. Localiza(SD1->D1_COD) .And. SF4->F4_ESTOQUE == 'S' .AND. Empty(SD1->D1_REMITO)
				aADD(aDigEnd,{;
								SD1->D1_ITEM,;
								SD1->D1_COD,;
								SD1->D1_LOCAL,;
								SD1->D1_LOTECTL,;
								SD1->D1_NUMLOTE,;
								SD1->D1_DTVALID,;
								SD1->D1_QUANT,;
								SD1->D1_NUMSEQ,;
								SD1->D1_DOC,;
								SD1->D1_SERIE,;
								SD1->D1_FORNECE,;
								SD1->D1_LOJA,;
								.F.;
							 })
		EndIf
	Next nI
	//³Fim da varredura dos itens da NF ³
	//³Quando for uma Nota de despesas de Importacao monta um array com o numero dos registros de todas   ³
	//³as Notas Originais e cria os registros de amarracao da Notas Atuais com as de origem no arquivo SF8³
	If nCt == 0
		If aCfgNf[SAliasHead] == "SF1" .AND. aCfgNf[SnTipo] == 13
			A119Grava(.F.,nRecnoC,aRecsSF1,,aAmarrAFN)
		EndIf
	EndIf
	//³Quando for uma Nota de conhecimento de frete monta um array com o numero dos registros de todas    ³
	//³as Notas Originais e cria os registros de amarracao da Notas Atuais com as de origem no arquivo SF8³
	If nCt == 0
		If aCfgNf[SAliasHead] == "SF1" .AND. aCfgNf[SnTipo] == 14
			A116Grava(.F.,nRecnoC,aRecsSF1,,aAmarrAFN)
		EndIf
	EndIf
	//³Grava OP's da NF retorno Benef.³
	If lRet .And. Type("aOPBenef") == "A" .And. !Empty(aOPBenef)
		lRet := (MTIncluiPR(aOPBenef))
	EndIf
EndIf //lRet (1)
RestArea(aAreaSA2)
RestArea(aArea)
Return(lRet)
/*
±±³Fun‡…o    ³MontaCfgNf  ³ Autor ³ Leandro C. G.         ³ Data ³09/11/2001³±±
±±³Descri‡…o ³Monta array com todas as confg da NF de acordo c/Tipo param.  ³±±
nTipo    - tipo de NF
aPergs	- Array com o conteudo das perguntas feitas na tela de NF
		[SlAmarraca 1]	-   Incluir Amarraçäo  ? (Cli.xProd.) ou (For.xProd.)
		[SlGerCtbil 2]	-   lanç. On-Line?
		[SlVerCtbil 3]	- 	Mostra Lanç.Contab ?
		[SlAglutina 4]	-	Aglut Lançamentos  ?
		[SlQbraAliq 5]	-	Quebra do Rodapé   ? Por Alíquota    /  Por Imposto
		[SlCtbEmiss 6]	-	Contabiliza por    ? Emissao         /  Data Base
*/
Function MontaCfgNf(nTipo,aPergs,lTela)
//Local nI,nX								//Flag's para loop's
Local lRet		:= .T.					//Indica consistencia da funcao
//Local cTipDoc	:= ""					//Indica se a Nota e de Devolucao ou Complemento quando for Debito ou Credito
Local aCfg 		:= {}   				//Array com todas as config. da NF
/*
	[SnTipo]		- codigo do tipo de NF
	[ScCliFor]		- indica se e cliente("C") ou fornec.("F")
	[SlFormProp]	- indica se e formulario proprio(0) ou nao(1)
	[SAliasHead]	- arquivo de cabecalho da nota
	[SAliasCols]	- arquivo de itens da nota
	[ScOpEstoq]		- indica se soma ou subtrai o estoque
	[ScAliasFin]	- arquivo financeiro a atualizar
	[ScOpFin]		- indica sinal para movimentacao financeira
	[ScTipoDoc]		- tipo de documento {N- ;C- ;D-	;B)
	[SaAtualiza]	- array com as permissoes para efetuar movimentacoes
	[SaLancPadC]	- Array com o numero dos lanç. padrao referentes a Cabecalho
	[SaLancPadI]	- Array com o numero dos lanç. padrao referentes a Itens
	[SaBotoes]		- Array com os botoes da tela, quando for tela
	[SaTeclas]		- Array com as funcoes chamadas por tecla te atalho e todas as respectivas teclas
	[SaPergs]		- Array com as perguntas efetuadas na entrada da NF (aPergs)
	[SaPE]			- Array com todos os pontos de entrada em suas devidas posicoes, de acordo com o tipo de Nota
	[SlRemito]		- Define se se trata de um remito
	[SlPedido]  	- Define se o tipo de nota tem amarração com com pedido de compras/vendas

*/
Local aLpC		:= {}					//Array com o numero dos lanç. padrao referentes a Cabecalho
Local aLpI		:= {}					//Array com o numero dos lanç. padrao referentes a Itens
Local aPE       := Array(SnMaxPE,2)		//Array com os pontos de entrada de acordo com o tipo da Nota
Local aPars	    := {}					//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local aBotoes   := AClone(CarregaBotoes(nTipo))
Local aTeclas   := AClone(CarregaTeclas(nTipo))
Local aAtualiza := AClone(CarregaAtualiza(nTipo,lTela))
Local aPcoLanc  := aClone(PcoCarregaLancto(nTipo))
Local bF12	 	:=	{|| Nil }
Local aCposGD   :=Nil
Local cFunName	:= IIf(Type("cFunName")=="U" .Or. Empty(cFunName) .Or. cFunName==NIL,Upper(Alltrim(ProcName())),cFunName)//IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem  IIf(Type(cFunName)==nil,Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
Local cTitView as character
LocaL bF12Mex	:= {|| Nil }
Local b12Chi	:= {|| Nil }
Local lb12Chi	:=  cPaisLoc=="CHI" .AND. FindFunction("fMontaAux") .AND. FindFunction("fF12auto")
If Type("lDocSp") == "U"
	Private lDocSp := .F.
EndIf
If Type("l103Class")!= "L"
	Private l103Class	:=	.F.
EndIf
If Type('lAutoFact') == "U"
	Private lAutoFact := .F.
EndIf
If Type('aAutofac') == "U"
	Private aAutofac:={0}
EndIf
If Type("lIntegracao")!= "L"
	lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)
Endif
//³Consistindo param.³
Aadd(aPars, {"nTipo", nTipo	, SpValor,1	,65	})
lRet := LocxParam("MONTACFGNF",aPars)
IF lb12Chi
	b12Chi:={|| LxPergunte("MT101N",.T.),aCfgNF := MontaCfgNf(fMontaAux(MV_PAR01),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF),fF12auto(MV_PAR01,@lAutoFact,@aAutofac)  }
ENDIF
If lRet //(1)
	//³Carregando lanç. padrao de acordo com o tipo da NF ³
	aAux := CarregaLanc(nTipo)
	aLpC := aAux[1]
	aLpI := aAux[2]
	//³Carregando todos os pontos de entrada de acordo com o tipo de Nota³
	aPE := MontaPE(nTipo)
	If cPaisLoc == "MEX" .And. (nTipo==1 .Or. nTipo==11 .Or. nTipo==19 .Or. nTipo==21)
		bF12Mex := {|| LxPergunte("MT467N",.T.),aCfgNF := MontaCfgNf(IIf(MV_PAR01==1,1,IIf(MV_PAR01==2,11,IIf(MV_PAR01==3,19,21))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
	EndIf
	Do Case
		Case nTipo==1
			//mata467
			bF12	:=	{|| LxPergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,1,11),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			If cPaisLoc=='MEX'
				bF12 := bF12Mex
	 			aCfg := {1,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew(MVNOTAFIS),"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0112+STR0142,STR0112,.F.,bF12,aCposGD,{.F.,.F.},"01/11/21", NIL, aPcoLanc} //GSA040118
	 		Else
		 		aCfg := {1,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew(MVNOTAFIS),"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0112+STR0142,STR0112,.F.,bF12,aCposGD,{.F.,.F.},"01/11", NIL, aPcoLanc}
	 		EndIf
		Case nTipo==2
			//mata465
			aCfg := {2,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew("NDC")	 	,"+","C",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0124,STR0124,.F.,bF12,aCposGD,{.F.,.F.},"02", NIL, aPcoLanc}
		Case nTipo==3
			//mata465
			aCfg := {3,"SA1",.F.,"SF2","SD2","-","SE1",GetSESNew("NCE")	 	,"+","C",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0113+STR0115,STR0113+STR0115,.F.,bF12,aCposGD,{.F.,.F.},"03", NIL, aPcoLanc}
		Case nTipo==4
			//mata465
			aCfg := {4,"SA1",.T.,"SF1","SD1","+","SE1",GetSESNew("NCC")	 	,"-","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0113,STR0113,.F.,bF12,aCposGD,{.F.,.F.},"04", NIL, aPcoLanc}
		Case nTipo==5
			//mata465
			aCfg := {5,"SA1",.F.,"SF1","SD1","+","SE1",GetSESNew("NDE")	 	,"-","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0117,STR0117,.F.,bF12,aCposGD,{.F.,.F.},"05", NIL, aPcoLanc}
		Case nTipo==6
			//mata466
			aCfg := {6,"SA2",.T.,"SF2","SD2","-","SE2",GetSESNew("NDI")	 	,"-","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0116,STR0116,.F.,bF12,aCposGD,{.F.,.F.},"06", NIL, aPcoLanc}
		Case nTipo==7
			//mata466
			aCfg := {7,"SA2",.F.,"SF2","SD2","-","SE2",GetSESNew("NCP")	 	,"-","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0113,STR0113,.F.,bF12,aCposGD,{.F.,.F.},"07", NIL, aPcoLanc}
		Case nTipo==8
			//mata466
			aCfg := {8,"SA2",.T.,"SF1","SD1","+","SE2",GetSESNew("NCI")	 	,"+","C",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0113+STR0114,STR0113+STR0114,.F.,bF12,aCposGD,{.F.,.F.},"08", NIL, aPcoLanc}
		Case nTipo==9
			//mata466
			aCfg := {9,"SA2",.F.,"SF1","SD1","+","SE2",GetSESNew("NDP")  	,"+","C",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0124,STR0124,.F.,bF12,aCposGD,{.F.,.F.},"09", NIL, aPcoLanc}
		Case nTipo==10
			//mata101 / mata103cf
			If !cFunName$"MATA103CF" .and. cPaisLoc == "PER"
				bF12	:=	{|| LxPergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,Iif(mv_par01==4,14,20)))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			Else
				bF12	:=	{|| LxPergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif((MV_PAR01 == 1) .or. (cPaisLoc == "PAR" .AND. MV_PAR01 ==5),10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,14))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF),IIF ((cPaisLoc == "PAR" .AND. FindFunction("autoFactPar")), aAutofac[1]:=autoFactPar(MV_PAR01,@lAutoFact),"")  }
				IF lb12Chi
					bF12:=b12Chi
				ENDIF
			EndIf
			If lIntegracao .AND. l103Class
				aCposGD	:=	{"D1_TES","D1_CF","D1_CONTA","D1_CC","D1_ITEMCTA","D1_CLVL"}
			Endif
			//(05/04/2018): Edit title if it call for View Invoice from Fixed asset
			If	(cPaisloc=="RUS") .AND. IsInCallStack("ATFA012PIN")
				cTitView := STR0141
			Else
				cTitView	:= IIF(!cFunName$"MATA103CF",STR0141+STR0142,STR0302)
			EndIf
			aCfg 	:= {10,"SA2",IIf(cPaisLoc == "COL" .AND. lDocSp,.T.,.F.),"SF1","SD1","+","SE2",MVNOTAFIS,"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,IIF(!cFunName$"MATA103CF",STR0141+STR0142,STR0302),IIF(!cFunName$"MATA103CF",STR0141,STR0302),.T.,bF12,aCposGD,{.F.,.F.},"10/12/13/14", NIL, aPcoLanc}
			IIf(cPaisLoc == "COL" .AND. lDocSp, aCfg[20] :=  aCfg[20] + " - " + STR0448,) //"Documento Soporte"
		//Beneficiamento
		Case nTipo == 11
			//Mata467
			bF12	:=	{|| Pergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,1,11),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			If cPaisLoc=='MEX'
				bF12 := bF12Mex
				aCfg := {11,"SA2",.T.,"SF2","SD2"	,"-",""	,MVNOTAFIS				,"","B",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)		,aClone(aPE),.F.,STR0112+STR0111,STR0112,.F.,bF12,aCposGD,{.F.,.F.},"01/11/21", NIL, aPcoLanc}
			ELSE
				aCfg := {11,"SA2",.T.,"SF2","SD2"	,"-",""	,MVNOTAFIS				,"","B",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)		,aClone(aPE),.F.,STR0112+STR0111,STR0112,.F.,bF12,aCposGD,{.F.,.F.},"01/11", NIL, aPcoLanc}
			ENDIF
		Case nTipo == 12
			//Mata101
			bF12	:=	{|| Pergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif((MV_PAR01 == 1) .or. (cPaisLoc == "PAR" .AND. MV_PAR01 ==5),10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,14))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF),IIF ((cPaisLoc == "PAR" .AND. FindFunction("autoFactPar")), aAutofac[1]:=autoFactPar(MV_PAR01,@lAutoFact),"") }
			aCfg 	:= {12,"SA1",.F.,"SF1","SD1"	,"+",""	,MVNOTAFIS				,"","B",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)		,aClone(aPE),.F.,STR0141+STR0111,STR0141,.T.,bF12,aCposGD,{.F.,.F.},"10/12/13/14", NIL, aPcoLanc}
			
		Case nTipo	==	13
			//MATA119
			bF12	:=	{|| LxPergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif((MV_PAR01 == 1) .or. (cPaisLoc == "PAR" .AND. MV_PAR01 ==5),10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,14))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF),IIF ((cPaisLoc == "PAR" .AND. FindFunction("autoFactPar")), aAutofac[1]:=autoFactPar(MV_PAR01,@lAutoFact),"") }
			aCposGD	:=	{"D1_VUNIT","D1_TOTAL","D1_CONTA","D1_CC","D1_CF","D1_TES","D1_ITEMCTA","D1_CLVL","D1_CONCEPT"}
			aCfg 	:= {13,"SA2",.F.,"SF1","SD1","+","SE2",MVNOTAFIS				,"+","C",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0141+STR0140,STR0141,.T.,bF12,aCposGD,{.F.,.T.},"10/12/13/14", NIL, aPcoLanc}
			IF lb12Chi
				bF12:=b12Chi
			ENDIF
		Case nTipo	==	14
			//MATA116
			bF12	:=	{|| LxPergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif((MV_PAR01 == 1) .or. (cPaisLoc == "PAR" .AND. MV_PAR01 ==5),10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,14))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF),IIF ((cPaisLoc == "PAR" .AND. FindFunction("autoFactPar")), aAutofac[1]:=autoFactPar(MV_PAR01,@lAutoFact),"") }
			aCposGD	:=	{"D1_VUNIT","D1_TOTAL","D1_CONTA","D1_CC","D1_CF","D1_TES","D1_ITEMCTA","D1_CLVL"}
			aCfg 	:= {14,"SA2",.F.,"SF1","SD1","+","SE2",MVNOTAFIS				,"+","C",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0141+STR0164,STR0141,.T.,bF12,aCposGD,{.T.,.F.},"10/12/13/14", NIL, aPcoLanc}
			IF lb12Chi
				bF12:=b12Chi
			ENDIF
		Case nTipo == 15
			//mata463
			aCfg 	:= {15,"SA2",.F.,"SF1","SD1","+","SE2",'REC'		,"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0225,STR0225,.T.,,aCposGD,{.F.,.F.},"15", NIL, aPcoLanc}
		Case nTipo == 17 //Nota de Venta - Especifico EQUADOR
			bF12	:=	{|| LxPergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,1,11),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg	:= {nTipo,"SA1",.T.,"SF2","SD2","-","SE1","NV ","+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0271,STR0271,.F.,bF12,aCposGD,{.F.,.F.},"17", NIL, aPcoLanc} // "Nota de venta"
		Case nTipo == 18 //RCTI - Especifico Australia
			bF12	:=	{|| Pergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,1,11),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg	:=  {nTipo,"SA1",.F.,"SF2","SD2","-","SE1","RTI","+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0322,STR0322,.F.,bF12,aCposGD,{.F.,.F.},"18", NIL, aPcoLanc} // "RCTI"
		Case nTipo == 19 .and. cPaisLoc $ "|MEX|PER|PAR" //Adiantamento - Especifico Mexico
			//mata467
			bF12	:=	IIf(cPaisLoc == "MEX",bF12Mex,{|| LxPergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,1,11),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) })
 			aCfg := {nTipo,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew(MVNOTAFIS),"+","A",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0112+" "+STR0264,STR0112,.F.,bF12,aCposGD,{.F.,.F.},"19", NIL, aPcoLanc}	//Adiantamento
	     //Remitos (facturacion)
	   	Case nTipo == 20 .and. cPaisLoc $ "|MEX|PER|" //Adiantamento - para Mexico y Peru
			//mata101n
			if cPaisLoc == "MEX"
				bF12 :=	{|| LxPergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,Iif(mv_par01==4,14,19)))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
				aCfg := {nTipo,"SA2",.F.,"SF1","SD1","-","SE2",GetSESNew(MVNOTAFIS),"+","A",aAtualiza,aLpC,aLpI,aBotoes,aTeclas,AClone(aPergs),aClone(aPE),.F.,STR0141+" - "+STR0264,STR0141,.F.,bF12,aCposGD,{.F.,.F.},"20", NIL, aPcoLanc}	//Adiantamento
			else
				bF12 :=	{|| LxPergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,Iif(mv_par01==4,14,19)))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
 				aCfg := {nTipo,"SA2",.F.,"SF1","SD1","-","SE2",GetSESNew(MVNOTAFIS),"+","A",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,IIF(!cFunName$"MATA103CF",STR0141+" "+STR0264,STR0302),IIF(!cFunName$"MATA103CF",STR0141,STR0302),.F.,bF12,aCposGD,{.F.,.F.},"20", NIL, aPcoLanc}	//Adiantamento
			endif
		Case nTipo == 21 .and. cPaisLoc == "MEX" //TRASLADOS
			//mata467
			bF12 :=	bF12Mex
			aCfg := {nTipo,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew(MVNOTAFIS),"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0112+" ("+ STR0385 +")",STR0112+" ("+ STR0385 +")",.F.,bF12,aCposGD,{.F.,.F.},"01/11/21", NIL, aPcoLanc} //"Factura de salida "//Traslado
		Case cPaisLoc == "COL" .AND. (nTipo == 22 .OR. nTipo == 23) .AND. FINDFUNCTION( 'lxEstrcCol' ) //Nota Ajuste NCP -NDP
			//mata466
			aCfg :=  lxEstrcCol(nTipo,aAtualiza, aLpC,aLpI,aBotoes,aTeclas,aPergs, aPE,bF12,aCposGD,aPcoLanc)
		Case cPaisLoc == "MEX" .AND. nTipo == 24
			//mata465
			aCfg := {24,"SA1",.T.,"SF1","SD1","+","SE1",GetSESNew("NCC")	 	,"-","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0113,STR0113+ ' - ' + STR0456,.F.,bF12,aCposGD,{.F.,.F.},"24", NIL, aPcoLanc} //'Documento de Cancelación'
		Case nTipo == 50
			//Mata462
			bF12	:=	{|| LxPergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,50,52),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			If cPaisLoc == "EUA"
				aCfg := {50,"SA1",.T.,"SF2","SD2","-","SE1"	,GetSESNew('RFN')		,"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0142,DESCREM,.F.,bF12,aCposGD,{.F.,.F.},"50", NIL, aPcoLanc}
			Else
				aCfg := {50,"SA1",.T.,"SF2","SD2","-",""	,GetSESNew('RFN')		,"","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0142,DESCREM,.F.,IIf(cPaisLoc <> "ARG", bF12, ""),aCposGD,{.F.,.F.},"50", NIL, aPcoLanc}
			EndIf
		Case nTipo == 51
			//Mata462D Proprio
			bF12	:=	{|| Pergunte("MT462D",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,51,53),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg := {51,"SA1",.T.,"SF1","SD1","+",""	,GetSESNew("RFD")		,"","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0105,DESCREM+STR0105,.F.,bF12,aCposGD,{.F.,.F.},"51/53", NIL, aPcoLanc}
		Case nTipo == 52
			//Mata462
			bF12	:=	{|| LxPergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,50,52),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
 			aCfg := {52,"SA2",.T.,"SF2","SD2","-",""	,GetSESNew('RFB')		,"","B",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0111,DESCREM,.F.,IIf(cPaisLoc <> "ARG", bF12, ""),aCposGD,{.F.,.F.},"52", NIL, aPcoLanc}
		Case nTipo == 53
			//Mata462 Doc nao proprio
			bF12	:=	{|| Pergunte("MT462D",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,51,53),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg := {53,"SA1",.F.,"SF1","SD1","+",""	,GetSESNew("RFD")		,"","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0105+STR0115,DESCREM+STR0105,.F.,bF12,aCposGD,{.F.,.F.},"51/53", NIL, aPcoLanc}
		Case nTipo == 54 // Remito de transf. Saida
			//Mata462
 			aCfg := {54,"SA2",.T.,"SF2","SD2","-",""	,GetSESNew('RTS')		,"","B",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0166,DESCREM,.F.,,aCposGD,{.F.,.F.},"54", NIL, aPcoLanc}
 		//Remitos (Compras)
		Case nTipo == 60
			//Mata102
			bF12	:=	{|| Pergunte("MT102N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,60,62),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg 	:= {60,"SA2",.F.,"SF1","SD1","+",""	,GetSESNew('RCN')		,"","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0310,DESCREM,.T.,bF12,aCposGD,{.F.,.F.}	,"60/62", NIL, aPcoLanc}
		Case nTipo == 61
			//Mata102
			aCfg := {61,"SA2",.T.,"SF2","SD2","-",""	,GetSESNew('RCD')		,"","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0105,DESCREM+STR0105,.F.,bF12,aCposGD,{.F.,.F.},"61", NIL, aPcoLanc}
		Case nTipo == 62
			//Mata102
			bF12	:=	{|| Pergunte("MT102N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,60,62),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg := {62,"SA1",.F.,"SF1","SD1","+",""	,GetSESNew("RCB")		,"","B",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0111,DESCREM,.F.,bF12,aCposGD,{.F.,.F.},"60/62", NIL, aPcoLanc}
		Case nTipo == 63
			//Retorno SIMBOLICO
			aCfg := {63,"SA1",.T.,"SF1","SD1","+",""	,GetSESNew("RET")		,"","B",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0145,DESCREM+STR0145,.F.,bF12,aCposGD,{.F.,.F.},"63", NIL, aPcoLanc}
		Case nTipo == 64
			aCposGD	:=	{"D1_LOCAL","D1_VUNIT","D1_TOTAL","D1_CONTA","D1_CC","D1_CF","D1_TES","D1_ITEMCTA","D1_CLVL"}
 			If GetNewPar("MV_ALTQTRT","N")=="S"
 				AAdd(aCposGD,"D1_QUANT")
 			EndIf
			aCfg 	:= {64,"SA2",.F.,"SF1","SD1","+",""	,GetSESNew('RTE'),"","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0167,DESCREM,.T.,,aCposGD,{.F.,.F.}	,"64", NIL, aPcoLanc}
		Case nTipo==65
			//mata103n e mata103cg
			If !cFunName$"MATA103CG"
	     		bF12	:=	{|| Pergunte("MT103N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,65,65),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
	  		EndIf
			If lIntegracao .AND. l103Class
				aCposGD	:=	{"D1_TES","D1_CF","D1_CONTA","D1_CC","D1_ITEMCTA","D1_CLVL"}
			Endif
			aCfg 	:= {65,"SA2",.F.,"SF1","SD1","+","SE2",GetSESNew("GDN"),"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,IIF(!cFunName$"MATA103CG",DESCREM+STR0309,STR0297),IIF(!cFunName$"MATA103CG",DESCREM+STR0309,STR0297),.T.,bF12,aCposGD,{.F.,.F.},"65", NIL, aPcoLanc}
	EndCase

	//Monta Array com os campos e os titulos que devem ser exibidos na mBrowse
	aCfg[SaCposBr] := MontCabBrow(aCfg)
EndIf //lRet (1)
IF cPaisLoc=="PAR" .AND. cFunName$"MATA101N"
		IIF(aAutofac[1]==5,lAutoFact:=.T.,lAutoFact:=.F.)
ENDIF
Return aCfg

/*
±±³Fun‡…o    ³ConsisteNf  ³ Autor ³ Leandro C. G.         ³ Data ³12/11/2001³±±
±±³Descri‡…o ³Efetua todas as consistencias necessarias para a gravacao de  ³±±
±±³			 ³uma NF                									             ³±±
±±³ Uso      ³ GRAVANFGERAL												          ³±±
aCabNotaOri - cabecalho da Nota
 [1] - campos do cabecalho
 [2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
 [3] - indica se o campo e totalizador (Default .F.)
aCpItensOri - campos dos itens (devem obedecer a sequencia do aHeader)
aCitensOri  - conteudo dos itens da NF (devem odebecer a sequencia do aCols) * o conteudo de cada campo pode ser uma formula
aCfgNf  	- array com todas as configuracoes da NF
 [SnTipo]		- codigo do tipo de NF
 [ScEspecie]	- codigo da especie da NF
 [ScCliFor]	- indica se e cliente("C") ou fornec.("F")
 [SlFormProp]	- indica se e formulario proprio(0) ou nao(1)
 [SAliasHead]	- arquivo de cabecalho da nota
 [SAliasCols]	- arquivo de itens da nota
 [ScOpEstoq]	- indica se soma ou subtrai o estoque
 [ScAliasFin]	- arquivo financeiro a atualizar
 [ScOpFin]		- indica sinal para movimentacao financeira
 [ScTipoDoc]	- tipo de documento {N- ;C- ;D-	;B)
 [SaAtualiza]	- array com as permissoes para efetuar movimentacoes
 [SaLancPadC]	- Array com o numero dos lanç. padrao referentes a Cabecalho
 [SaLancPadI]	- Array com o numero dos lanç. padrao referentes a Itens
*/

Function ConsisteNf(aCfgNf,aCabNotaOri,aCitensOri,aCpItensOri,lTela)
Local nI  					//Flag's para Loop's
Local cCpMoeda     := ""	//nome do campo de moeda no array de cabecalho
Local nPosMoeda    := 0		//pos. do campo de moeda no array de cabecalho
Local lRet		   := .T.	//Indica consistencia da funcao
Local aCitens      := aClone(aCitensOri)
Local aCpItens     := aClone(aCpItensOri)
Local aCabNota     := aClone(aCabNotaOri)
Local oModel
Private inclui    := .T.	//indica que e inclusao de dados (ExistChav())
Private n					//linha atual do acols
If cPaisLoc=="RUS"
	Private nMoedaCor := IIf(Type("nMoedaCor")=="U",1,nMoedaCor)
else
	Private nMoedaCor	:= 1
EndIf
Private aHeader   := IIf(Type("aHeader")=="U",{},aHeader)
Private aNfItem	  := IIf(Type("aNfItem")=="U",{},aNfItem)
Private aNfCab	  := IIf(Type("aNfCab")=="U",{},aNfCab)

Default lTela := .T.

//³Verificando moeda corrente³
cCpMoeda  := PrefixoCpo(aCfgNf[SAliasHead])+"_MOEDA"
nPosMoeda := Ascan(aCabNota[1], AllTrim(cCpMoeda))
nMoedaCor := IIf(nPosMoeda>0,aCabNota[2][nPosMoeda],1)
//³Acertando parametro aCabNota³
Asize(aCabNota, 3)
aCabNota[3] := IIf(Empty(aCabNota[3]) .OR. ValType(aCabNota[3]) != "A", {}, aCabNota[3])
Asize(aCabNota[3], Len(aCabNota[1]))
nI := 0
For nI := 1 to Len(aCabNota[1])
aCabNota[3][nI] := IIf(Empty(aCabNota[3][nI]), .F., aCabNota[3][nI])
Next nI

If SuperGetMV("MV_MULNATP") == .T. .And. FunName() == "MATA143"
	lContSEV:= .T.
EndIf

//³Consistencias especiais que dependendem dos dados de gravacao de cada nota.Dentro desta rotina estao as consistencias ³
//³do TudOk e LinOk
If FindFunction('LoadMdData') .and. !Empty(LxSelecMod(aCfgNf[SnTipo]))
	oModel := LoadMdData(aCfgNf[SnTipo], aCabNotaOri[1], aCabNotaOri[2], aCpItensOri, aCitensOri, aCfgNF[ScEspecie], Iif(Mafisfound(),MaFisRet(,"NF_BASEDUP"),), cPaisLoc, Iif(Type("aDupl") == "A",aDupl,{}), !lTela, nMoedaCor, IIf(Type("cNatureza") == "C",cNatureza,""))
	lRet := vldModel(oModel)
	If lRet
		ModUpdDoc(oModel, @aCabNotaOri, {}, aCpItensOri, @aCitensOri) //Actualización de numeración en caso de haber sido reemplazada. (Modxfun.tlpp)
		aCabNota := aClone(aCabNotaOri)
		aCitens := aClone(aCitensOri)
	EndIf
	oModel:DeActivate()
EndIf
If lRet
	lRet := NfTudOk(aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCabNotaOri,aCpItensOri,aCitensOri,,aCfgNf[ScTipoDoc],aCfgNf[SlFormProp],,lTela)
EndIf

If ! lLocxAuto
	If lRet //lRet (1)
		//³Verificando moeda corrente³
		cCpMoeda  := PrefixoCpo(aCfgNf[SAliasHead])+"_MOEDA"
		nPosMoeda := Ascan(aCabNota[1], AllTrim(cCpMoeda))
		nMoedaCor := IIf(nPosMoeda>0,aCabNota[2][nPosMoeda],1)
		//³Executando a validacao do conteudo dos campos atraves do SX3³
		If !ConsisteSX3(aCabNota[1],aCabNota[2],aCabNota[3],aCpItens,aCitens)
			lRet := .F.
		EndIf
	EndIf //(1)
EndIf
Return(lRet)

/*
±±³Fun‡…o    ³CposObrig   ³ Autor ³ Leandro C. G.         ³ Data ³27/11/2001³±±
±±³Descri‡…o ³Verifica todos os campos obrigatorios de um arquivo de acordo ³±±
±±³			 ³como as configuracoes do SX3  					      		³±±
±±³ Uso      ³ GENERICA              										³±±
param.
cAlias	- Alias que se deseja saber o campos obrigatoios.
aCampos  - Campos que se deseja saber se sao obrigatorios.
*/
Function CposObrig(cAlias,aCampos)
Local aCpObrig		:= {}				//Array que guarda os campos obrigatorios
Local aArea			:= GetArea()
DEFAULT aCampos	:=	{}

DBSelectArea("SX3")
DBSetOrder(1)
If MSSeek(cAlias+"01", .F.)
	While !Eof() .AND. X3_ARQUIVO == cAlias
		If  X3OBRIGAT(X3_CAMPO) .AND. (Len(aCampos) == 0 .OR. Ascan(aCampos,{|x| Alltrim(x)==X3_CAMPO}) >0)
			AADD(aCpObrig, X3_CAMPO)
		EndIf
		DBSkip()
	End
EndIf
RestArea(aArea)
Return(aCpObrig)

/*
±±³Fun‡…o    ³CposObrigNf ³ Autor ³ Leandro C. G.         ³ Data ³27/11/2001³±±
±±³Descri‡…o ³Verifica todos os campos obrigatorios de um arquivo na 		³±±
±±³			 ³gravacao de uma NF		  									³±±
±±³ Uso      ³ CONSISTENF  												    ³±±
param.
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
aObrigSX3	- Campos que sao obrigatorios de acordo com SX3
cAlias		- Alias que se deseja saber o campos obrigatoios
*/
Function CposObrigNf(cAlias,cTipDoc,aObrigSX3,aCampos)
Local aCpObrig := {}			//Array que guarda os campos obrigatorios
Local lRet	   := .T.			//Indica consistencia da funcao
//Local cFunName := IIf(Type("cFunName")=="U",Upper(Alltrim(FunName())),cFunName)
Local nPos

//³Consistencias³
Default cTipDoc   := ""
Default aObrigSX3 := IIf(!Empty(cAlias), CposObrig(cAlias,aCampos), {})
If Empty(cAlias)
	lRet := .F.
EndIf
cPe	:=	LocxPE(30)
If !Empty(cPE)
	aObrigSX3	:=	ExecBlock(cPe,.F.,.F.,{aObrigSX3,aCfgNF[SnTipo]})
Endif

aCpObrig := aClone(aObrigSX3)
If lRet //lRet (1)
	Do Case
		//SF1 - Cabecalho de Entrada
		Case cAlias == "SF1"
			IIf(Ascan(aObrigSX3, "F1_FORNECE")<=0.AND.ExisteCampo("F1_FORNECE",.T.)[1]	, AADD(aCpObrig, "F1_FORNECE")	,)
			IIf(Ascan(aObrigSX3, "F1_LOJA")<=0	.AND.ExisteCampo("F1_LOJA",.T.)[1]			, AADD(aCpObrig, "F1_LOJA")	,)
			IIf(Ascan(aObrigSX3, "F1_DOC")<=0.AND.ExisteCampo("F1_DOC",.T.)[1]				, AADD(aCpObrig, "F1_DOC")		,)
			IIf(Ascan(aObrigSX3, "F1_EMISSAO")<=0.AND.ExisteCampo("F1_EMISSAO",.T.)[1]	, AADD(aCpObrig, "F1_EMISSAO") ,)
			IIf(Ascan(aObrigSX3, "F1_DTDIGIT")<=0.AND.ExisteCampo("F1_DTDIGIT",.T.)[1]	, AADD(aCpObrig, "F1_DTDIGIT") ,)
			IIf(Ascan(aObrigSX3, "F1_MOEDA")<=0.AND.ExisteCampo("F1_MOEDA",.T.)[1]			, AADD(aCpObrig, "F1_MOEDA"	)	,)
			IIf(Ascan(aObrigSX3, "F1_TXMOEDA")<=0.AND.ExisteCampo("F1_TXMOEDA",.T.)[1]	, AADD(aCpObrig, "F1_TXMOEDA") ,)
			IIf(Ascan(aObrigSX3, "F1_TIPO")<=0.AND.ExisteCampo("F1_TIPO",.T.)[1]			, AADD(aCpObrig, "F1_TIPO")	,)
			IIf(Ascan(aObrigSX3, "F1_FORMUL")<=0.AND.ExisteCampo("F1_FORMUL",.T.)[1]		, AADD(aCpObrig, "F1_FORMUL")  ,)
			IIf(Ascan(aObrigSX3, "F1_ESPECIE")<=0.AND.ExisteCampo("F1_ESPECIE",.T.)[1]	, AADD(aCpObrig, "F1_ESPECIE") ,)
			IIf(Ascan(aObrigSX3, "F1_TIPODOC")<=0.AND.ExisteCampo("F1_TIPODOC",.T.)[1]	, AADD(aCpObrig, "F1_TIPODOC")	,)
			If (nPos := Ascan(aCpObrig, "F1_COND"))> 0
				ADel(aCpObrig,nPos)
				aSize(aCpObrig,Len(aCpObrig)-1)
			Endif
		//SD1 - Itens de Entrada
		Case cAlias == "SD1"
			IIf(Ascan(aObrigSX3, "D1_COD")<=0.AND.ExisteCampo("D1_COD",.T.)[1]			, AADD(aCpObrig, "D1_COD")	  ,)
			IIf(Ascan(aObrigSX3, "D1_UM")<=0.AND.ExisteCampo("D1_UM",.T.)[1]				, AADD(aCpObrig, "D1_UM") ,)
			If !aCfgNF[SlRemito]
				IIf(Ascan(aObrigSX3, "D1_VUNIT")<=0.AND.ExisteCampo("D1_VUNIT",.T.)[1]		, AADD(aCpObrig, "D1_VUNIT"	),)
				IIf(Ascan(aObrigSX3, "D1_TOTAL")<=0.AND.ExisteCampo("D1_VUNIT",.T.)[1]		, AADD(aCpObrig, "D1_VUNIT"	),)
			Endif
			IIf(Ascan(aObrigSX3, "D1_TES")<=0.AND.ExisteCampo("D1_TES",.T.)[1]			, AADD(aCpObrig, "D1_TES")	,)
			IIf(Ascan(aObrigSX3, "D1_LOCAL")<=0.AND.ExisteCampo("D1_LOCAL",.T.)[1]		, AADD(aCpObrig, "D1_LOCAL"	),)
			IIf(Ascan(aObrigSX3, "D1_CF")<=0.AND.ExisteCampo("D1_CF",.T.)[1]			, AADD(aCpObrig, "D1_CF")	,)
		//SF2 - Cabecalho de Saida
		Case cAlias == "SF2"
			IIf(Ascan(aObrigSX3, "F2_TIPO")<=0.AND.ExisteCampo("F2_TIPO",.T.)[1]			, AADD(aCpObrig, "F2_TIPO")	,)
			IIf(Ascan(aObrigSX3, "F2_DOC")<=0.AND.ExisteCampo("F2_DOC",.T.)[1]		  	, AADD(aCpObrig, "F2_DOC") 	,)
			IIf(Ascan(aObrigSX3, "F2_CLIENTE")<=0.AND.ExisteCampo("F2_CLIENTE",.T.)[1]	, AADD(aCpObrig, "F2_CLIENTE")	,)
			IIf(Ascan(aObrigSX3, "F2_LOJA")<=0.AND.ExisteCampo("F2_LOJA",.T.)[1]			, AADD(aCpObrig, "F2_LOJA")	,)
			IIf(Ascan(aObrigSX3, "F2_COND")<=0.AND.ExisteCampo("F2_COND",.T.)[1]			, AADD(aCpObrig, "F2_COND")	,)
			IIf(Ascan(aObrigSX3, "F2_EMISSAO")<=0.AND.ExisteCampo("F2_EMISSAO",.T.)[1]	, AADD(aCpObrig, "F2_EMISSAO")	,)
			IIf(Ascan(aObrigSX3, "F2_ESPECIE")<=0.AND.ExisteCampo("F2_ESPECIE",.T.)[1]	, AADD(aCpObrig, "F2_ESPECIE")	,)
			IIf(Ascan(aObrigSX3, "F2_MOEDA")<=0.AND.ExisteCampo("F2_MOEDA",.T.)[1]	  	, AADD(aCpObrig, "F2_MOEDA") 	,)
			IIf(Ascan(aObrigSX3, "F2_TXMOEDA")<=0.AND.ExisteCampo("F2_TXMOEDA",.T.)[1]	, AADD(aCpObrig, "F2_TXMOEDA")	,)
			IIf(Ascan(aObrigSX3, "F2_TIPODOC")<=0.AND.ExisteCampo("F2_TIPODOC",.T.)[1]	, AADD(aCpObrig, "F2_TIPODOC")	,)
			If (nPos := Ascan(aCpObrig, "F2_COND"))> 0
				ADel(aCpObrig,nPos)
				aSize(aCpObrig,Len(aCpObrig)-1)
			Endif
		//SD2 - Itens de Saida
		Case cAlias == "SD2"
			If !aCfgNF[SlRemito]
				IIf(Ascan(aObrigSX3, "D2_PRCVEN")	<=0	.AND.ExisteCampo("D2_PRCVEN",.T.)[1]	, AADD(aCpObrig, "D2_PRCVEN")	,)
				IIf(Ascan(aObrigSX3, "D2_TOTAL") 	<=0	.AND.ExisteCampo("D2_TOTAL",.T.)[1]	, AADD(aCpObrig, "D2_TOTAL")	,)
			Endif
			IIf(Ascan(aObrigSX3, "D2_GERANF") 	<=0	.AND.ExisteCampo("D2_GERANF",.T.)[1]	, AADD(aCpObrig, "D2_GERANF")	,)
			IIf(Ascan(aObrigSX3, "D2_NUMSEQ")	<=0	.AND.ExisteCampo("D2_NUMSEQ",.T.)[1]	, AADD(aCpObrig, "D2_NUMSEQ")	,)
			IIf(Ascan(aObrigSX3, "D2_COD")		<=0	.AND.ExisteCampo("D2_COD",.T.)[1]		, AADD(aCpObrig, "D2_COD")		,)
			IIf(Ascan(aObrigSX3, "D2_UM")			<=0	.AND.ExisteCampo("D2_UM",.T.)[1]		, AADD(aCpObrig, "D2_UM")		,)
			IIf(Ascan(aObrigSX3, "D2_CF")			<=0	.AND.ExisteCampo("D2_CF",.T.)[1]		, AADD(aCpObrig, "D2_CF")		,)
			IIf(Ascan(aObrigSX3, "D2_TES")		<=0	.AND.ExisteCampo("D2_TES",.T.)[1]		, AADD(aCpObrig, "D2_TES")		,)
			If aCfgNf[SlRemito] .AND. aCfgNf[SnTipo] == 54 .AND. Type("M->F2_TIPORET")=='C' .AND. (M->F2_TIPORET == '1') .AND. Ascan(aObrigSX3, "D2_LOCDEST")		<=0	.AND.ExisteCampo("D2_LOCDEST",.T.)[1]
				AADD(aCpObrig, "D2_LOCDEST")
			EndIf
			If aCfgNf[SlRemito] .AND. aCfgNf[SnTipo] == 54 .AND. Type("M->F2_TIPORET")=='C' .AND. M->F2_TIPORET == '1' .AND. Ascan(aObrigSX3, "D2_TESENT")		<=0	.AND.ExisteCampo("D2_TESENT",.T.)[1]
				AADD(aCpObrig, "D2_TESENT")
			EndIf
	EndCase
EndIf //(1)
Return aCpObrig

/*
±±³Fun‡…o    ³CposAutogNf ³ Autor ³ Leandro C. G.         ³ Data ³27/11/2001³±±
±±³Descri‡…o ³Verifica todos os campos que possuem um conteudo padrao e 	³±±
±±³			 ³devolve tanto o campo como o conteudo padrao					³±±
±±³ Uso      ³ CONSISTENF  												    ³±±
param.
cAlias		- Alias de onde devem ser buscados os campos e valores padrao (obrgit)
lFormP  	- Indica e formulario proprio ou nao
cAliasCF	- Alias do cliente (SA1) ou fornec. (SA2) (obrigt)
aCposOri	- Campos do Alias em questao que estao sendo considerados
aDadosOri	- Conteudo dos campos do array aCposOri (deve ser bidimensional)
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
nLinha		- se o array aDadosOri possuir mais que uma linha e so deve ser tartada uma linha especifica, passa-se o numnero da linha atraves deste parametro.
			Se for nulo ou 0, considera todas as linhas
Retorno
aRet		- Array com campos e conteudos inclusive os contedos padrao para o arquivo
		  [1] - nome dos campos incluindo os campos automaticos
		  [2] - conteudo dos campos incluindo o dos campos automaticos
*/
Function CposAutoNf(cAlias,cAliasCF,lFormP,aCposOri,aDadosOri,cTipDoc,nLinha)

Local nI,nX,cI						//Flag para Loop
Local aPars	   		:= {}			//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nSavn			:= IIf(Type("n")=="N",n,0)
Local aRet			:= array(2)		//Array com os campos e os conteudos
/*									[1] - campos (aCpAuto)
									[2] - conteudos (aCpad) */
Local lForce		:= FindFunction('LoadMdData')
Local xValAux
Local lAutomato		:= IsBlind()
Private aCpos		:= IIf(!Empty(aCposOri),aClone(aCposOri),NIL)		//Campos referentes aos itens (aHeader)
Private aDados		:= IIf(!Empty(aDadosOri),aClone(aDadosOri),NIL)	//Conteudo dos itens
Private aCpAuto		:= {}			//Array com os campos que possuem um conteudo padrao/default
Private aCpad		:= {}			//Array com o conteudo dos campos

//³Consistindo param.³
Aadd(aPars, {"cAlias"	,cAlias		,Sp4String	, "SF1"	,"SF2"	, "SD1"	, "SD2"	} )
Aadd(aPars, {"cAliasCF"	,cAliasCF	,Sp2String	, "SA1"	,"SA2"					} )
Aadd(aPars, {"cTipDoc"	,cTipDoc	,SpEmpty									} )
Aadd(aPars, {"aCpos"	,aCpos		,SpEmpty									} )
Aadd(aPars, {"aDados"	,aDados		,SpEmpty									} )
Aadd(aPars, {"lFormP"	,lFormP		,SpEmpty									} )
If !LocxParam("",aPars,.F.)
	Return({aCposOri,aDadosOri})
EndIf

Default nLinha := 0

//³Montagem de todos os campos obrigatorios e seu respectivo conteudo, de acordo com o arquivo³
Do Case
	//³SF1 - Cabecalho de Entrada³
	Case cAlias == "SF1"
		If ExisteCampo("F1_FORMUL",.T.)[1]
			AADD(aCpAuto, "F1_FORMUL")
			AADD(aCpad	, IIf(aCfgNf[SlFormProp],"S","N"))
		EndIf
		If ExisteCampo("F1_STATUS",.T.)[1]
			AADD(aCpAuto, "F1_STATUS")
			AADD(aCpad	, "A")
		EndIf
		If ExisteCampo("F1_RECBMTO",.T.)[1]
			AADD(aCpAuto, "F1_RECBMTO")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("F1_DTDIGIT",.T.)[1]
			AADD(aCpAuto, "F1_DTDIGIT")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("F1_EMISSAO",.T.)[1]
			AADD(aCpAuto, "F1_EMISSAO")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("F1_EST",.T.)[1]
			AADD(aCpAuto, "F1_EST")
			AADD(aCpad	, {'Posicione("'+cAliasCF+'",1,xFilial("'+cAliasCF+'")+M->F1_FORNECE+M->F1_LOJA,PrefixoCpo("'+cAliasCF+'")+"_EST")',.T.})
		EndIf
		If ExisteCampo("F1_TIPO",.T.)[1]
			AADD(aCpAuto, "F1_TIPO")
			AADD(aCpad	, cTipDoc)
		EndIf
		If ExisteCampo("F1_FILIAL",.T.)[1]
			AADD(aCpAuto, "F1_FILIAL")
			AADD(aCpad	, xFilial('SF1'))
		EndIf
		If ExisteCampo("F1_DUPL",.T.)[1]
			AADD(aCpAuto, "F1_DUPL")
			AADD(aCpad	, {"IIf(MaFisRet(,'NF_BASEDUP')>0,M->F1_DOC,'')",.T.})
		Endif
		If ExisteCampo("F1_MOEDA",.T.)[1]
			AADD(aCpAuto, "F1_MOEDA")
			AADD(aCpad	, 1)
		EndIf
		If ExisteCampo("F1_TXMOEDA",.T.)[1]
			AADD(aCpAuto, "F1_TXMOEDA")
			AADD(aCpad	, {"IIF(M->F1_MOEDA==1,0,RecMoeda(dDataBase,M->F1_MOEDA))",.T.})
		EndIf
		If ExisteCampo("F1_COND",.T.)[1]
			AADD(aCpAuto, "F1_COND")
			AADD(aCpad	, {"IIf(Type('cCondicao')=='C',cCondicao,NIL)",.T.})
		EndIf
		If lAutomato .and. ExisteCampo("F1_NATUREZ",.T.)[1]
			AADD(aCpAuto, "F1_NATUREZ")
			AADD(aCpad	, {"IIf(Type('cNatureza')=='C',cNatureza,NIL)",.T.})
		EndIf
		If ExisteCampo("F1_TIPODOC",.T.)[1]
			AADD(aCpAuto, "F1_TIPODOC")
			AADD(aCpad	, StrZero(aCfgNF[SnTipo],2))
		EndIf
		If ExisteCampo("F1_ESPECIE",.T.)[1]
			AADD(aCpAuto, "F1_ESPECIE")
			AADD(aCpad	, aCfgNF[ScEspecie])
		EndIf
		If ExisteCampo("F1_TIPO",.T.)[1]
			AADD(aCpAuto, "F1_TIPO")
			AADD(aCpad	, aCfgNF[ScTipoDoc])
		EndIf
		If ExisteCampo("F1_ORIGLAN",.T.)[1]
			AADD(aCpAuto, "F1_ORIGLAN")
			AADD(aCpad	, IIf(aCfgNF[SlConFrDp][1],"F ",Iif(aCfgNF[SlConFrDp][2]," D","")))
		EndIf
		If ExisteCampo("F1_DESPESA",.T.)[1]
			AADD(aCpAuto, "F1_DESPESA")
			AADD(aCpad	, {"MaFisRet(,'NF_DESPESA')",.T.})
		EndIf
		If ExisteCampo("F1_DESCONT",.T.)[1]
			AADD(aCpAuto, "F1_DESCONT")
			AADD(aCpad	, {"MaFisRet(,'NF_DESCONTO')",.T.})
		EndIf
		If ExisteCampo("F1_FRETE",.T.)[1]
			AADD(aCpAuto, "F1_FRETE")
			AADD(aCpad	, {"MaFisRet(,'NF_FRETE')",.T.})
		EndIf
		If ExisteCampo("F1_SEGURO",.T.)[1]
			AADD(aCpAuto, "F1_SEGURO")
			AADD(aCpad	, {"MaFisRet(,'NF_SEGURO')",.T.})
		EndIf
		If ExisteCampo("F1_VALMERC",.T.)[1]
			AADD(aCpAuto, "F1_VALMERC")
			AADD(aCpad	, {"MaFisRet(,'NF_VALMERC')",.T.})
		EndIf
		If ExisteCampo("F1_VALBRUT",.T.)[1]
			AADD(aCpAuto, "F1_VALBRUT")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_TOTAL')",.T.},0))
		EndIf

		If aCfgNF[ScTipoDoc]  == "D"
			If ExisteCampo("F1_GERAPED",.T.)[1]
				AADD(aCpAuto, "F1_GERAPED")
				If ExistBlock('MT46205')
					AADD(aCpad	, { "If(ExecBlock('MT46205',.F.,.F.),'1','2')",.T. })
				Else
					AADD(aCpad	, "2" )
				Endif
			EndIf
		Endif
		If aCfgNF[SnTipo]  == 63 //Retorno de beneficiamento
			If ExisteCampo("F1_GERAPED",.T.)[1]
				AADD(aCpAuto, "F1_GERAPED")
				AADD(aCpad	, "1" )
			EndIf
		Endif
		If ExisteCampo("F1_HORA",.T.)[1]
			AADD(aCpAuto, "F1_HORA")
			If ExistBlock( "LXHORANFIS" ) .and. Iif(lLxModPE,LxModPE(, "LXHORANFIS"),.T.)
				AADD(aCpad	, { "ExecBlock('LXHORANFIS',.F.,.F.)",.T. })
			Else
				AADD(aCpad	, {"Substr(GetRmtTime(),1,8)",.T.})
			EndIf
		EndIf
		If ExisteCampo("F1_SECSRI",.T.)[1]
			AADD(aCpAuto, "F1_SECSRI")
			AADD(aCpad	, {"1",.T.})
		EndIf
		If lUsaCor			//Numero correlativo de compras
			If ExisteCampo("F1_NUMCOR",.T.)[1]
				AADD(aCpAuto, "F1_NUMCOR")
				AADD(aCpad	, {"M->F1_NUMCOR",.T.})
			Endif
		Endif
	//³SD1 - Itens de Entrada³
	Case cAlias == "SD1"
		If ExisteCampo("D1_DOC",.T.)[1]
			AADD(aCpAuto, "D1_DOC")
			AADD(aCpad	, {"M->F1_DOC", .T.})
		EndIf
		If ExisteCampo("D1_FORMUL",.T.)[1]
			AADD(aCpAuto, "D1_FORMUL")
			AADD(aCpad	, IIf(aCfgNf[SlFormProp],"S","N"))
		EndIf
		If ExisteCampo("D1_TIPO",.T.)[1]
			AADD(aCpAuto, "D1_TIPO")
			AADD(aCpad	, cTipDoc)
		EndIf
		If ExisteCampo("D1_ESPECIE",.T.)[1]
			AADD(aCpAuto, "D1_ESPECIE")
			AADD(aCpad	, aCfgNF[ScEspecie])
		EndIf
		If ExisteCampo("D1_DTDIGIT",.T.)[1]
			AADD(aCpAuto, "D1_DTDIGIT")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("D1_EMISSAO",.T.)[1]
			AADD(aCpAuto, "D1_EMISSAO")
			AADD(aCpad	, {"M->F1_EMISSAO", .T.})
		EndIf
		If ExisteCampo("D1_SERIE",.T.)[1]
			AADD(aCpAuto, "D1_SERIE")
			AADD(aCpad	, {"M->F1_SERIE", .T.})
		EndIf
		If ExisteCampo("D1_LOJA",.T.)[1]
			AADD(aCpAuto, "D1_LOJA")
			AADD(aCpad	, {"M->F1_LOJA", .T.})
		EndIf
		If ExisteCampo("D1_FORNECE",.T.)[1]
			AADD(aCpAuto, "D1_FORNECE")
			AADD(aCpad	, {"M->F1_FORNECE", .T.})
		EndIf
		If ExisteCampo("D1_FILIAL",.T.)[1]
			AADD(aCpAuto, "D1_FILIAL")
			AADD(aCpad	, xFilial('SD1'))
		EndIf
		If ExisteCampo("D1_UM",.T.)[1]
	    	AADD(aCpAuto, "D1_UM")
    		AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D1_COD,'B1_UM')",.T.})
  		EndIf
		If ExisteCampo("D1_SEGUM",.T.)[1]
			AADD(aCpAuto, "D1_SEGUM")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D1_COD,'B1_SEGUM')",.T.})
		EndIf
		If ExisteCampo("D1_GRUPO",.T.)[1]
			AADD(aCpAuto, "D1_GRUPO")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D1_COD,'B1_GRUPO')",.T.})
		EndIf
		If ExisteCampo("D1_TP",.T.)[1]
			AADD(aCpAuto, "D1_TP")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D1_COD,'B1_TIPO')",.T.})
		EndIf
		If ExisteCampo("D1_NUMSEQ",.T.)[1]
			AADD(aCpAuto, "D1_NUMSEQ")
			AADD(aCpad	, {"ProxNum()",.T.})
		EndIf
		If ExisteCampo("D1_CF",.T.)[1] .AND. !(cPaisLoc $ "BRA|RUS")
			AADD(aCpAuto, "D1_CF")
			AADD(aCpad	, {"Posicione('SF4',1,xFilial('SF4')+M->D1_TES,'F4_CF')",.T.})
		EndIf
		If ExisteCampo("D1_IDENTB6",.T.)[1]
			AADD(aCpAuto, "D1_IDENTB6")
			AADD(aCpad	, {"BuscaIdentB6('SD1')",.T.})
		EndIf
		If ExisteCampo("D1_RATEIO",.T.)[1]
			AADD(aCpAuto, "D1_RATEIO")
			AADD(aCpad	, "")
		EndIf
		If ExisteCampo("D1_TIPODOC",.T.)[1]
			AADD(aCpAuto, "D1_TIPODOC")
			AADD(aCpad	, StrZero(aCfgNF[SnTipo],2))
		EndIf
		If ExisteCampo("D1_QTDACLA",.T.)[1]
			AADD(aCpAuto, "D1_QTDACLA")
			AADD(aCpad	, If(aCfgNF[SlRemito],{"M->D1_QUANT",.T.},0))
		EndIf
		If ExisteCampo("D1_ORIGLAN",.T.)[1]
			AADD(aCpAuto, "D1_ORIGLAN")
			AADD(aCpad	, IIf(aCfgNF[SlConFrDp][1],"FR",Iif(aCfgNF[SlConFrDp][2],"DP","")))
		EndIf
		If ExisteCampo("D1_NUMDESP",.T.)[1]
			AADD(aCpAuto, "D1_NUMDESP")
			AADD(aCpad	, {Iif(Type("M->F1_NUMDES")=="C","M->F1_NUMDES",""),.T.})
		EndIf
		If ExisteCampo("D1_ORIGEM",.T.)[1]
			AADD(aCpAuto, "D1_ORIGEM")
			AADD(aCpad	, {Iif(Type("M->F1_ORIGEM")=="C","M->F1_ORIGEM",""),.T.})
		EndIf
		If ExisteCampo("D1_REVISAO",.T.)[1]
			 AADD(aCpAuto, "D1_REVISAO")
			 AADD(aCpad , "")
		EndIf
		If (cPaisLoc == "RUS")
			// Campos referentes ao imposto
			lFim := .F.
			cI 	 := "0"
			While !lFim
				cI	:=	Soma1(cI)
				If 		ExisteCampo("D1_BASIMP"+cI,.T.)[1] .AND.	;
				   		ExisteCampo("D1_VALIMP"+cI,.T.)[1] .AND.	;
				   		ExisteCampo("D1_ALQIMP"+cI,.T.)[1]
					Aadd(aCpAuto, "D1_BASIMP"+cI )
					Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_BASEIV"+cI+"'),0)",.T.},0))
					Aadd(aCpAuto, "D1_VALIMP"+cI )
					Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_VALIV"+cI+"'),0)",.T.},0))
					Aadd(aCpAuto, "D1_ALQIMP"+cI )
					Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_ALIQIV"+cI+"'),0)",.T.},0))
				Else
					lFim := .T.
				EndIf
			End
		Endif
		If cPaisLoc == "RUS"
			If ExisteCampo("D1_BSIMP1M",.T.)[1]
				Aadd(aCpAuto, "D1_BSIMP1M" )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_BASEIV1_C1'),0)",.T.},0))
			EndIf
			If ExisteCampo("D1_VLIMP1M",.T.)[1]
				Aadd(aCpAuto, "D1_VLIMP1M" )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_VALIV1_C1'),0)",.T.},0))
			EndIf
		EndIf
	//³SF2 - Cabecalho de Saida³
	Case cAlias == "SF2"
		If ExisteCampo("F2_FILIAL",.T.)[1]
			AADD(aCpAuto, "F2_FILIAL")
			AADD(aCpad	, xFilial('SF2'))
		EndIf
		If ExisteCampo("F2_FORMUL",.T.)[1]
			AADD(aCpAuto, "F2_FORMUL")
			AADD(aCpad	, IIf(aCfgNf[SlFormProp],"S","N"))
		EndIf
		If ExisteCampo("F2_TIPO",.T.)[1]
			AADD(aCpAuto, "F2_TIPO")
			AADD(aCpad	, cTipDoc)
		EndIf
		If ExisteCampo("F2_DTDIGIT",.T.)[1]
			AADD(aCpAuto, "F2_DTDIGIT")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("F2_EST",.T.)[1]
			AADD(aCpAuto, "F2_EST")
			AADD(aCpad	, {'Posicione("'+cAliasCF+'",1,xFilial("'+cAliasCF+'")+M->F2_CLIENTE+M->F2_LOJA,PrefixoCpo("'+cAliasCF+'")+"_EST")',.T.})
		EndIf
		If !Empty(aCfgNF[ScOpFin])
			AADD(aCpAuto, "F2_DUPL")
			AADD(aCpad	, {"M->F2_DOC",.T.})
		Endif
		If ExisteCampo("F2_HORA",.T.)[1]
			AADD(aCpAuto, "F2_HORA")
			If ExistBlock( "LXHORANFIS" )
				AADD(aCpad	, { "ExecBlock('LXHORANFIS',.F.,.F.)",.T. })
			Else
				AADD(aCpad	, {"SubStr(GetRmtTime(),1,"+Alltrim(STR(GetSX3Cache("F2_HORA","X3_TAMANHO")))+")",.T.})
			EndIf
		EndIf
		If 	ExisteCampo("F2_TIPOCLI",.T.)[1] .AND. cAliasCF == "SA1"
			AADD(aCpAuto, "F2_TIPOCLI")
			AADD(aCpad	, {"Posicione('SA1',1,xFilial('SA1')+M->F2_CLIENTE+M->F2_LOJA,'A1_TIPO')",.T.})
		EndIf
		If ExisteCampo("F2_MOEDA",.T.)[1]
			AADD(aCpAuto, "F2_MOEDA")
			AADD(aCpad	, 1)
		EndIf
		If ExisteCampo("F2_TXMOEDA",.T.)[1]
			AADD(aCpAuto, "F2_TXMOEDA")
			AADD(aCpad	, {"IIF(M->F2_MOEDA==1,0,RecMoeda(dDataBase,M->F2_MOEDA))",.T.})
		EndIf
		If ExisteCampo("F2_COND",.T.)[1]
			AADD(aCpAuto, "F2_COND")
			AADD(aCpad	, {"IIf(Type('cCondicao')=='C',cCondicao,NIL)",.T.})
		EndIf
		If lAutomato .and. ExisteCampo("F2_NATUREZ",.T.)[1]
			AADD(aCpAuto, "F2_NATUREZ")
			AADD(aCpad	, {"IIf(Type('cNatureza')=='C',cNatureza,NIL)",.T.})
		EndIf
		If ExisteCampo("F2_TIPODOC",.T.)[1]
			AADD(aCpAuto, "F2_TIPODOC")
			AADD(aCpad	, StrZero(aCfgNF[SnTipo],2))
		EndIf
		If ExisteCampo("F2_ESPECIE",.T.)[1]
			AADD(aCpAuto, "F2_ESPECIE")
			AADD(aCpad	, aCfgNF[ScEspecie])
		EndIf
		If ExisteCampo("F2_TIPO",.T.)[1]
			AADD(aCpAuto, "F2_TIPO")
			AADD(aCpad	, aCfgNF[ScTipoDoc])
		EndIf
		If ExisteCampo("F2_DESPESA",.T.)[1]
			AADD(aCpAuto, "F2_DESPESA")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_DESPESA')",.T.},0))
		EndIf
		If ExisteCampo("F2_DESCONT",.T.)[1]
			AADD(aCpAuto, "F2_DESCONT")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_DESCONTO')",.T.},0))
		EndIf
		If ExisteCampo("F2_FRETE",.T.)[1]
			AADD(aCpAuto, "F2_FRETE")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_FRETE')",.T.},0))
		EndIf
		If ExisteCampo("F2_SEGURO",.T.)[1]
			AADD(aCpAuto, "F2_SEGURO")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_SEGURO')",.T.},0))
		EndIf
		If ExisteCampo("F2_VALMERC",.T.)[1]
			AADD(aCpAuto, "F2_VALMERC")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_VALMERC')",.T.},0))
		EndIf
		If ExisteCampo("F2_VALBRUT",.T.)[1]
			AADD(aCpAuto, "F2_VALBRUT")
			AADD(aCpad	,Iif(MaFisFound(), {"MaFisRet(,'NF_TOTAL')",.T.},0))
		EndIf
		If cPaisLoc == "RUS"
			If ExisteCampo("F2_VLMERCM",.T.)[1]
				AADD(aCpAuto, "F2_VLMERCM")
				AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_VALMERC_C1')",.T.},0))
			EndIf
			If ExisteCampo("F2_VLBRUTM",.T.)[1]
				AADD(aCpAuto, "F2_VLBRUTM")
				AADD(aCpad	,Iif(MaFisFound(), {"MaFisRet(,'NF_TOTAL_C1')",.T.},0))
			EndIf
		EndIf
		If ExisteCampo("F2_TIPOREM",.T.)[1]
			AADD(aCpAuto, "F2_TIPOREM")
			If aCfgNF[SnTipo] == 54
				AADD(aCpad	, '6')
			Else
				AADD(aCpad	, '0')
			EndIf
		EndIf
		If ExisteCampo("F2_TIPORET",.T.)[1]
			AADD(aCpAuto, "F2_TIPORET")
			AADD(aCpad	, AllTrim(Str(GetMv('MV_TIPORET'))))
		EndIf
		If ExisteCampo("F2_SECSRI",.T.)[1]
			AADD(aCpAuto, "F2_SECSRI")
			AADD(aCpad	, {'1',.T.})
		EndIf
	//³SD2 - Itens de Saida³
	Case cAlias == "SD2"
		If ExisteCampo("D2_DOC",.T.)[1]
			AADD(aCpAuto, "D2_DOC")
			AADD(aCpad	, {"M->F2_DOC", .T.})
		EndIf
		If ExisteCampo("D2_NUMSEQ",.T.)[1]
			AADD(aCpAuto, "D2_NUMSEQ")
			AADD(aCpad	, {"ProxNum()", .T.})
		EndIf
		If ExisteCampo("D2_FORMUL",.T.)[1]
			AADD(aCpAuto, "D2_FORMUL")
			AADD(aCpad	, IIf(aCfgNf[SlFormProp],"S","N"))
		EndIf
		If ExisteCampo("D2_ESPECIE",.T.)[1]
			AADD(aCpAuto, "D2_ESPECIE")
			AADD(aCpad	, aCfgNF[ScEspecie])
		EndIf
		If ExisteCampo("D2_TIPO",.T.)[1]
			AADD(aCpAuto, "D2_TIPO")
			AADD(aCpad	, cTipDoc)
		EndIf
		If ExisteCampo("D2_DTDIGIT",.T.)[1]
			AADD(aCpAuto, "D2_DTDIGIT")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("D2_EMISSAO",.T.)[1]
			AADD(aCpAuto, "D2_EMISSAO")
			AADD(aCpad	, {"M->F2_EMISSAO", .T.})
		EndIf
		If ExisteCampo("D2_SERIE",.T.)[1]
			AADD(aCpAuto, "D2_SERIE")
			AADD(aCpad	, {"M->F2_SERIE", .T.})
		EndIf
		If ExisteCampo("D2_LOJA",.T.)[1]
			AADD(aCpAuto, "D2_LOJA")
			AADD(aCpad	, {"M->F2_LOJA", .T.})
		EndIf
		If ExisteCampo("D2_CLIENTE",.T.)[1]
			AADD(aCpAuto, "D2_CLIENTE")
			AADD(aCpad	, {"M->F2_CLIENTE", .T.})
		EndIf
		If ExisteCampo("D2_FILIAL",.T.)[1]
			AADD(aCpAuto, "D2_FILIAL")
			AADD(aCpad	, {'xFilial("SD2")',.T.})
		EndIf
		If ExisteCampo("D2_UM",.T.)[1]
		  	AADD(aCpAuto, "D2_UM")
    		AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_UM')",.T.})
  		EndIf
		If ExisteCampo("D2_SEGUM",.T.)[1]
			AADD(aCpAuto, "D2_SEGUM")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_SEGUM')",.T.})
		EndIf
		If ExisteCampo("D2_GRUPO",.T.)[1]
			AADD(aCpAuto, "D2_GRUPO")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_GRUPO')",.T.})
		EndIf
		If ExisteCampo("D2_TP",.T.)[1]
			AADD(aCpAuto, "D2_TP")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_TIPO')",.T.})
		EndIf
		If ExisteCampo("D2_PRUNIT",.T.)[1]
			AADD(aCpAuto, "D2_PRUNIT")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_PRV1')",.T.})
		EndIf
 		If ExisteCampo("D2_CF",.T.)[1]	.AND. !(cPaisLoc $ "BRA|RUS")
			AADD(aCpAuto, "D2_CF")
			AADD(aCpad	, {"Posicione('SF4',1,xFilial('SF4')+M->D2_TES,'F4_CF')",.T.})
		EndIf
		If ExisteCampo("D2_IDENTB6",.T.)[1]
			AADD(aCpAuto, "D2_IDENTB6")
			AADD(aCpad	, {"BuscaIdentB6('SD2')",.T.})
		EndIf
		If ExisteCampo("D2_CONTA",.T.)[1]
			AADD(aCpAuto, "D2_CONTA")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_CONTA')",.T.})
		EndIf
		If ExisteCampo("D2_EST",.T.)[1]
			AADD(aCpAuto, "D2_EST")
			AADD(aCpad	, {'Posicione("'+cAliasCF+'",1,xFilial("'+cAliasCF+'")+M->F2_CLIENTE+M->F2_LOJA,PrefixoCpo("'+cAliasCF+'")+"_EST")',.T.})
		EndIf
		If ExisteCampo("D2_PESO",.T.)[1]
			AADD(aCpAuto, "D2_PESO")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_PESO')",.T.})
		EndIf
		If ExisteCampo("D2_TPDCENV",.T.)[1]
			AADD(aCpAuto, "D2_TPDCENV")
			AADD(aCpad	, " " )
		Endif
		If ExisteCampo("D2_TIPODOC",.T.)[1]
			AADD(aCpAuto, "D2_TIPODOC")
			AADD(aCpad	, StrZero(aCfgNF[SnTipo],2))
		EndIf
		If ExisteCampo("D2_GERANF",.T.)[1]
			AADD(aCpAuto, "D2_GERANF" )
			If aCfgNf[SlRemito] .AND. aCfgNf[ScTipoDoc] == "N" .AND. ExisteCampo("D2_QTDAFAT",.T.)[1]
				AADD(aCpad	, {'Iif(Posicione("'+cAliasCF+'",1,xFilial("'+cAliasCF+'")+M->F2_CLIENTE+M->F2_LOJA,PrefixoCpo("'+cAliasCF+'")+"_CONFREM")=="1","N","S")',.T.}  )
			Else
				AADD(aCpad	, "N" )
			Endif
		Endif
		If ExisteCampo("D2_REVISAO",.T.)[1]
			 AADD(aCpAuto, "D2_REVISAO")
			 AADD(aCpad , "")
		EndIf
		If (aCfgNf[SlRemito] .AND. aCfgNf[ScTipoDoc] == "N" .AND. ExisteCampo("D2_QTDAFAT",.T.)[1]) .OR. aCfgNf[SnTipo]==54
			AADD(aCpAuto, "D2_QTDAFAT")
		    If aCfgNf[SnTipo]==54
				AADD(aCpad	, {"M->D2_QUANT",.T.})
			Else
				AADD(aCpad	, {"Iif( M->D2_GERANF<>'N'.AND. Posicione('SA1',1,xFilial('SA1')+M->F2_CLIENTE+M->F2_LOJA,'A1_CONFREM')#'1',M->D2_QUANT,0)",.T.})
			EndIf
		EndIf
		If aCfgNf[SlRemito] .AND. aCfgNf[ScTipoDoc] == "N" .AND. ExisteCampo("D2_TIPOREM",.T.)[1]
			AADD(aCpAuto, "D2_TIPOREM")
			If aCfgNF[SnTipo] == 54
				AADD(aCpad	, '6')
			Else
				AADD(aCpad	, '0')
			EndIf
		Endif
		// Campos de comissoes
		For nI := 1 to Fa440CntVen()
			If ExisteCampo("D2_COMIS"+AllTrim(Str(nI)),.T.)[1]
				Aadd(aCpAuto, "D2_COMIS"+AllTrim(Str(nI)) )
				Aadd(aCpad	, {"NfComis("+AllTrim(Str(nI))+")",.T.})
			EndIf
		Next nI
		// Campos referentes ao imposto
		lFim := .F.
		cI 	 := "0"
		While !lFim
			cI	:=	Soma1(cI)
			If 		ExisteCampo("D2_BASIMP"+cI,.T.)[1] .AND.	;
			   		ExisteCampo("D2_VALIMP"+cI,.T.)[1] .AND.	;
			   		ExisteCampo("D2_ALQIMP"+cI,.T.)[1]
				Aadd(aCpAuto, "D2_BASIMP"+cI )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_BASEIV"+cI+"'),0)",.T.},0))
				Aadd(aCpAuto, "D2_VALIMP"+cI )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_VALIV"+cI+"'),0)",.T.},0))
				Aadd(aCpAuto, "D2_ALQIMP"+cI )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_ALIQIV"+cI+"'),0)",.T.},0))
			Else
				lFim := .T.
			EndIf
		End
		If cPaisLoc == "RUS"
			If ExisteCampo("D2_BSIMP1M",.T.)[1]
				Aadd(aCpAuto, "D2_BSIMP1M" )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_BASEIV1_C1'),0)",.T.},0))
			EndIF
			If ExisteCampo("D2_VLIMP1M",.T.)[1]
				Aadd(aCpAuto, "D2_VLIMP1M" )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_VALIV1_C1'),0)",.T.},0))
			EndIf
		EndIf
EndCase
//³Verifica se todos os campos automaticos dos itens estao sendo considerados e possuem conteudo nos array's enviados por parametro³
If Len(aCpAuto) > 0
	//³Verifica se algum conteudo automatico e formula³
	Aeval(aCpad, { |x| If(ValType(x)=="A",lForm:=.T.,) })
	//³Verifica se existe no parametro passado para a funcao, os campos automaticos e adiciona os que nao houverem, ³
	//³guardando a pos. de cada campo automatico no array passado por parametro no array aPos
	aPos := {}
	For nI	:=	1	To Len(aCpAuto)
		Aadd(aPos, Ascan(aCpos,{|x| Alltrim(x)==aCpAuto[nI]} ))
	Next nI
	Aeval(aPos, { |x,y| IIf(x==0,Aadd(aCpos,aCpAuto[y]),) })
	//³Atualiza o array de conteudos³
	nI := 0
	For nI := IIf(nLinha==0,1,nLinha) to IIf(nLinha==0,Len(aDados),nLinha)
		n := nI
		//³Se existir algum conteudo que seja formula, carrega em variaveis de memoria o conteudo de todos os campos³
		IIf(lForm, Aeval(aCpos, { |x,y| IIf(y<=Len(aDados[nI]),&("M->"+x):=IIf(ValType(aDados[nI][y])!="A",aDados[nI][y],NIL),) }) ,)
		//³Carregando conteudos³
		nX := 0
		For nX := 1 to Len(aCpAuto)
			If aPos[nX] == 0
				nAux := 0
				Aadd(aDados[nI], NIL)
				If ValType(aDados[nI][Len(aDados[nI])-1]) == "L"
					aDados[nI][Len(aDados[nI])]	:= aDados[nI][Len(aDados[nI])-1]
					nAux := 1
				EndIf
				aDados[nI][Len(aDados[nI])-nAux]	:= IIf(ValType(aCpad[nX])!="A",aCpad[nX],ExecFormula(aCpad[nX][1],,))
				&("M->"+aCpAuto[nX]) := aDados[nI][Len(aDados[nI])-nAux]
			ElseIf Empty(aDados[nI][aPos[nX]])
				aDados[nI][aPos[nX]] := IIf(ValType(aCpad[nX])!="A",aCpad[nX],ExecFormula(aCpad[nX][1],,))
				&("M->"+aCpAuto[nX]) := aDados[nI][aPos[nX]]
			ElseIf lForce .and. aCpAuto[nX] $ "F2_VALBRUT|F2_VALMERC|F1_VALBRUT|F1_VALMERC"
				xValAux := IIf(ValType(aCpad[nX])!="A",aCpad[nX],ExecFormula(aCpad[nX][1],,))
				If xValAux > 0
					aDados[nI][aPos[nX]] := xValAux
				EndIf
			EndIf
			If aCfgNF[SlRemito] .AND. aCpAuto[nX] == "D1_QTDACLA" .AND. AllTrim(aCfgNf[ScEspecie])!="RTE" .AND. AllTrim(aCfgNf[ScEspecie])!="RTS"
				If aPos[nX] <> 0
					aDados[nI][aPos[nX]] := IIf(ValType(aCpad[nX])!="A",aCpad[nX],ExecFormula(aCpad[nX][1],,))
					&("M->"+aCpAuto[nX]) := aDados[nI][aPos[nX]]
				EndIf
			Endif
		Next nX
		//³Acertando o array de origem³
		Aeval(aPos, { |x,y| IIf(x>0,IIf(Empty(aDadosOri[nI][x]),aDadosOri[nI][x]:=aDados[nI][x],),) })
	Next nI
EndIf
//³Montando array de Devolucao da funcao³
aRet[1] := aClone(aCpos)
aRet[2] := aClone(aDados)
//³Restaura numero do item do aCols³
If nSavn > 0
	n := nSavn
EndIf
Return(aRet)

/*
±±³Fun‡…o    ³MontaHeader ³ Autor ³ Leandro C. G.         ³ Data ³28/11/2001³±±
±±³Descri‡…o ³Monta o aHeader de acordo com os campos desejados				³±±
param.
aCpos	- Campos que serao incluidos no aHeader
*/
Function MontaHeader(aCpos)
Local aArea  	:= GetArea()			//Guarda configuracao da area atual
Local aSX3		:= GetArea("SX3")
Local nI	   							//Flag's para loop's
Local aH		:= {}

DBSelectArea("SX3")
DBSetOrder(2)

nI := 0
For nI := 1 to Len(aCpos)
	If MSSeek(AllTrim(aCpos[nI]), .F.)
		AADD(aH,{ 	TRIM(x3titulo())	,;
					SX3->X3_CAMPO		,;
					SX3->X3_PICTURE		,;
					SX3->X3_TAMANHO		,;
					SX3->X3_DECIMAL		,;
					SX3->X3_VALID		,;
					SX3->X3_USADO		,;
					SX3->X3_TIPO		,;
					SX3->X3_ARQUIVO		,;
					SX3->X3_CONTEXT		})
	Else
		AADD(aH, {,,,,,,,,,})
	EndIf
Next nI

RestArea(aSX3)
RestArea(aArea)
Return(aH)

/*
±±³Fun‡…o    ³RestauraMatriz ³ Autor ³ Leandro C. G.      ³ Data ³28/11/2001³±±
±±³Descri‡…o ³Restaura conteudo do aCols e do aHeader       				³±±
param.
aSalvaCols		- aCols que estava salvo e deve ser restaurado
aSalvaHeader	- aHeader que estava sendo restaurado
*/
Function RestauraMatriz(aSalvaCols,aSalvaHeader)
IIf(Type("aCols")!="U".AND.!Empty(aSalvaCols)		,aCols		:= aClone(aSalvaCols)	,)
IIf(Type("aHeader")!="U".AND.!Empty(aSalvaHeader)	,aHeader	:= aClone(aSalvaHeader)	,)
Return(.T.)

/*
±±³Fun‡…o    ³ConsisteSX3    ³ Autor ³ Leandro C. G.      ³ Data ³05/12/2001³±±
±±³Descri‡…o ³Efetua consistencias nos campos da NF de acordo com SX3		³±±
param.
aCposc	 - campos de cabecalho que devem ser consistidos
aDadosC	 - dados referentes aos campos de cabecalho que devem ser consistidos
aCposI	 - campos de itens de NF que devem ser consistidos
aDadosI	 - dados referentes aos campos de itens da NF
aFormula - indica quais os conteudos de cabecalho sao totalizadores
*/
Function ConsisteSX3(aCposC,aDadosC,aTotaliz,aCposI,aDadosI)
Local nI,nX					//Flag's para loop's
Local cConteudo				//Conteudo de um determinado campo (pode ser o proprio conteudo ou tambem uma formula
Local lRet	:= .T.			//Indica consistencia da Funcao

//³Variaveis utilizadas em outras funcoes³
IIf(Type("bRefresh")!="B",bRefresh:=&("{|| NIL }"),)
IIf(Type("bListRefresh")!="B",bListRefresh:=&("{|| NIL }"),)

//³Verifica param. dos dados de cabecalho ³
If	!Empty(aCposC) 		.AND.	!Empty(aDadosC)		.AND.;
    Len(aCposC) > 0 	.AND.	Len(aDadosC) > 0	.AND.;
    Len(aCposC)+1 == Len(aDadosC)

	//³Acertana pos. referente a indicador de formula ³
	Default aTotaliz := Array(Len(aCposC))
	Asize(aTotaliz, Len(aCposC))
	Aeval(aTotaliz, { |x,y| If(x==NIL,aTotaliz[y]:=.F.,) })

	//³Consistindo campos de cabecalho³
	nI := 0
	For nI := 1 to Len(aCposC)
		&("M->"+aCposC[nI]) := aDadosC[nI]
		__ReadVar := aCposC[nI]
		//³Verifica se o conteudo do campo e totalizador ou e uma formula³
		If aTotaliz[nI]
			cConteudo := ExecTotal(aDadosC[nI],aCposI,aDadosI)
		ElseIf ValType(aDadosC[nI]) != "A"
			cConteudo := aDadosC[nI]
		ElseIf aDadosC[nI][2]
			cConteudo := ExecFormula(aDadosC[nI][1],aCposC,aDadosC)
		EndIf
		//³Checando validacoes do SX3³
		If !CheckSX3(aCposC[nI],cConteudo)
			lRet := .F.
		EndIf
	Next nI
EndIf

If lRet //(1)
	//³Verifica param. dos dados de itens
	If	!Empty(aCposI) 		.AND.	!Empty(aDadosI)		.AND.;
	    Len(aCposI) > 0 	.AND.	Len(aDadosI) > 0
		nI := 0
		For nI := 1 to Len(aDadosI)
			//³Verifica se a linha nao esta deletada³
			If aDadosI[nI][Len(aDadosI[nI])] .OR. Len(aDadosI) != Len(aCposI)+1
				Loop
			EndIf
			n  := nI 	//variavel utilizada em sub-rotinas de validacao. Representa o numero do item do acols
			nX := 0
			For nX := 1 to Len(aCposI)
				&("M->"+aCposI[nX]) := aDadosI[nI][nX]
				__ReadVar := aCposI[nX]
				//³Verifica se o conteudo do campo e formula³
				If ValType(aDadosI[nI][nX]) != "A"
					cConteudo := aDadosI[nI][nX]
				ElseIf aDadosI[nI][nX][2]
					cConteudo := ExecFormula(aDadosI[nI][nX][1],aCposI,aDadosI[nI])
				EndIf
				//³Checa validacoes do SX3³
				If !CheckSX3(aCposI[nX], cConteudo)	//so consiste dados quando nao for formula (valtype == A)
					lRet := .F.
				EndIf
			Next nX
		Next nI
	EndIf
EndIf //lRet (1)
Return lRet

/*
±±³Fun‡…o    ³NfTudOk        ³ Autor ³ Leandro C. G.      ³ Data ³12/12/2001³±±
±±³Descri‡…o ³Efetua as validacoes gerais na gravacao das notas fiscais  	³±±
±±³ Uso      ³ CONSISTENF												    ³±±
param.
cAliasC			-	Alias de cabecalho de NF
cAliasI			- 	Alias de Itens de NF
cAliasCF		- 	Alias referente ao arquivo de clientes ou fornec. (SA1/SA2)
cTipDoc 		- 	Tipo de documento da NF
			  		N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
lFormP			- Indica se tem formulario proprio(.T.) ou nao(.F.)
aCabNotaOri 	- 	Cabecalho da Nota
		   		[1] - campos do cabecalho
		   		[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
		   		[3] - indica se o campo e totalizador (Default .F.)
		   		Obs.: se o campo for um totalizador, a formula para se totalizar deve ser colocada no lugar do conteudo [2]
           		e deve ser levado em consideracao que ira totalizar sempre o conteudo atual mais o conteudo da formula a cada item gravado
aCpItensOri 	- campos dos itens (aHeader)
aCitensOri  	- conteudo dos itens da NF (aCols) * o conteudo de cada campo pode ser uma formula
nLinha			- se for 0 nao consiste atraves da LinOk, se for > 0 consiste apenas a linha passada pelo parametro e se for nulo consiste todas as linhas
*/
Function NfTudOk(cAliasC,cAliasI,cAliasCF,aCabNotaOri,aCpItensOri,aCitensOri,nLinha,cTipDoc,lFormP,aGetsTela,lTela)
Local nI							//Flag's para Loop's
Local aArea    := GetArea()
Local aAreaC   := GetArea(cAliasC)
Local lRet	   := .T.				//Indica consistencia da rotina
Local aAux	   := {}				//Array auxiliar
Local nPos	   := 0					//pos. de um determinado campo numa matriz
Local cCliFor  := ""
Local cLoja    := ""
Local aPars	   := {}				//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local aCitens  := aClone(aCitensOri)
Local aCpItens := aClone(aCpItensOri)
Local aCabNota := aClone(aCabNotaOri)
Local lGeraBlq := .F.
Local lBlockPed:= .T.
Local aDupli  := IIf(Type("aDupl")=="U",{},aDupl)
Local lIntNtCRDB := SuperGetMV( "MV_ATFNCRD", .F., .F. )	//Parâmetro de ativação do ajuste de valor do bem.
Local lLinhaOK	:= .F.
Local nPosCdBar   := 0
Local cCodBar     := ""
Local nPosCP     := 0 //Posición de campo de Carta Porte
Local nItemSrv   := 0
Local nTpProd    := 0
Local lCartaP    := cPaisLoc == "MEX" .And. SF2->(ColumnPos("F2_TPCOMPL")) > 0 .And. M->F2_TPCOMPL =='S'

// -- Utilizadas pelo controle de adiantameto, Somente para Angola|Mexico.
Local cFunName	:= IIf(Type("cFunName")=="U" .Or. cFunName == Nil,Upper(Alltrim(FunName())),cFunName)	//Funcao Origem
Default aGetsTela := {}

If !IsMemVar("aHdrAFN")
	Private aHdrAFN := {}
EndIf
//utilizada na funcao a465Qtde
If Type("lCliente") == "U"
	Private lCliente := IIf(!Empty(cAliasCF).AND.cAliasCF=="SA1",.T.,.F.)
EndIf
If Type("cNatureza") == "U"
	Private cNatureza := ""
EndIf
//Utilizada na funcao
Private cVendedor := ""

Default lTela	:= .T.

//³Consistindo param.³
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String		,"SA1"	,"SA2"	} )
Aadd(aPars, {"aCabNota"	, aCabNota	, SpLenArray	,1		,3		} )
Aadd(aPars, {"aCitens"	, aCitens	, SpEmpty						} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty						} )
Aadd(aPars, {"lFormP"	, lFormP	, SpEmpty						} )
lRet := LocxParam("NFTUDOK",aPars)

nPosCdBar := Ascan(aCabNotaOri[1], AllTrim(PrefixoCpo(cAliasC)+"_CODBAR"))
nPosCP    := Ascan(aCabNotaOri[1], AllTrim("F2_TPCOMPL"))

If nPosCdBar <> 0
	cCodBar := aCabNotaOri[2][nPosCdBar]
EndIf
If !LocxCODBOK(cAliasC, cCodBar, .T.)
	Return .F.
Endif
If lRet //(1)
	//³Valida as linhas de itens³
	If   nLinha == NIL .OR. nLinha > 0
		aAux 		:= CposAutoNf(cAliasI,cAliasCF,lFormP,aCpItens,aCitens,cTipDoc,)
		aCpItens	:= aAux[1]
		aCitens	:= aAux[2]
		If lCartaP
			nTpProd  := aScan(aAux[1],{|x| AllTrim(x)=="D2_TP"})
		EndIf
		For nI :=1 To Len(aCitens)
			If !aCitens[nI][Len(aCitens[nI])]
				lLinhaOK := .T.
				If nNFTipo == 1 .And. lCartaP .And. nTpProd > 0 .And. aCitens[nI][nTpProd] == "SV" //Factura de Tipo Normal
					nItemSrv += 1
				EndIf
			EndIf
		Next nI
		If !lLinhaOK
			lRet := .F.
		EndIf
		If !NfLinOk(cAliasI,aCpItens,cAliasCF,aCitens,cTipDoc,nLinha,lFormP)
			lRet := .F.
		EndIf
	 	If lRet .AND. !lLocxAuto .AND. Type("oGetDados") <> "U" .AND. lTela
	   		lRet:=	oGetDados:TudoOk()
	  	Endif
	EndIf
	If lRet //(2)
		//Verifica campos de cabecalho obrigatorios
		If !CposVazio(cAliasC,,cTipDoc,aCabNota,,)
			lRet := .F.
		EndIf
		If lRet //(3)
			//³Variaveis sobre campos de cabecalho³
			//³Como algumas validacoes foram retiradas de outros fontes, foi necessario preencher algumas ³
			//³variaveis para nao haver risco de que algum RDMake que possa ter sido criado considerando  ³
			//³a existencia de alguma das variaveis, desse problema										  ³
			//cTipo
			cTipo := cTipDoc
			//cnFiscal
			nPos := Ascan(aCabNota[1], AllTrim(PrefixoCpo(cAliasC)+"_DOC"))
			IIf(nPos>0,cnFiscal:=aCabNota[2][nPos],"")

			lSerie2     := (((SF2->(FieldPos("F2_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (aCfgNf[ScEspecie]$"NCE|NCP")) .or. (cPaisLoc == "COL" .and. aCfgNf[SAliasHead] == "SF2" )); // Determina o uso do campo F2_SERIE2 para o Peru
						.Or. ((SF1->(FieldPos("F1_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (Trim(aCfgNf[ScEspecie])$"NF|NDP|NDE") .And. !aCfgNf[SlFormProp])
			//³Para o Peru pode-se utilizar o campo especifico para serie com 4 digitos caso ³
			//³se tratar de Notas de Credito(NCE/NCP) - Nota de Debito (NDP/NDE) 	         |
			//|Factura de Entrada (NF) que nao utilizem formulario proprio.

			If cPaisLoc == "PER"
				cSerie := LxSer2Per(cAliasC, aCabNota, cSerie, lSerie2)
			ElseIf cPaisLoc == "COL"
				cSerie := LxSer2Col(cAliasC, aCabNota, cSerie, lSerie2)
			Else
				nPos := Ascan(aCabNota[1],{ |x| UPPER(x) == AllTrim(PrefixoCpo(cAliasC)+"_SERIE") } )
				IIf(nPos>0,cSerie:=aCabNota[2][nPos],"")
			EndIf
			//cEspecie
			nPos := Ascan(aCabNota[1], AllTrim(PrefixoCpo(cAliasC)+"_ESPECIE"))
			IIf(nPos>0,cEspecie:=aCabNota[2][nPos],"")
			//cCondicao
			nPos := Ascan(aCabNota[1], AllTrim(PrefixoCpo(cAliasC)+"_COND"))
			IIf(nPos>0,cCondicao:=aCabNota[2][nPos],"")
			//cCliFor
			nPos := Ascan(aCabNota[1], IIf(cAliasC=="SF1","F1_FORNECE","F2_CLIENTE"))
			IIf(nPos>0,cCliFor:=aCabNota[2][nPos],"")
			//cLoja
			nPos := Ascan(aCabNota[1], AllTrim(PrefixoCpo(cAliasC)+"_LOJA"))
			IIf(nPos>0,cLoja:=aCabNota[2][nPos],"")
			//³Verfica vendedores³
			If lRet .AND. cAliasC == "SF2"
				//Validacoes de Adiantamento => Mexico
				If lRet .AND. cPaisLoc  $ "MEX|RUS"	.AND. (aCfgNf[SnTipo] == 1 .OR. aCfgNf[SnTipo] == 19)
					lRet := LxTudOkMex(aCfgNf[ScTipoDoc],cAliasI,aCpItens,aCItens,cNatureza,cCondicao,aRecnoSE1)
				EndIf
			Endif
			//³Validacoes de existencia da nota³
			If lRet .AND. !l103Class
				If cPaisLoc == "BOL"
					AtuNumNF(cNFiscal,cSerie)
				EndIf
			EndIf
			If lRet .and. cPaisLoc $ "VEN" .And. Valtype(aCfgNF[SlFormProp]) == "L" .And. aCfgNF[SlFormProp] .And. (!Str(aCfgNF[SnTipo],2)$"54|64|50|60") .And. GetNewPar("MV_CTRLFOL",.F.)
				lRet := CtrFolios(cFilAnt,cSerie,cEspecie,cnFiscal)
			EndIf

			//³ Verifica a natureza ³
			If lRet .AND. MaFisRet(,"NF_BASEDUP") > 0 .AND. Empty(MaFisRet(,"NF_NATUREZA")) .AND. cTipDoc <> "D"  .AND. cAliasC == "SF1" .And. !aCfgNf[SlRemito] .And. !(cPaisLoc $ "PER")
				If cPaisLoc == "MEX"
					lRet := xVldNatMex(aCfgNf, @cNatureza, cAliasI, aCpItens, aCItens)
				Else
					If !Empty(M->F1_NATUREZ)
						MaFisAlt("NF_NATUREZA",M->F1_NATUREZ)
						cNatureza:=M->F1_NATUREZ
					EndIf
				EndIf
			EndIf

			if AllTrim(FunName()) <> "MATA447"
				//Validacoes de Adiantamento => Mexico
				if lRet .AND. cAliasC == "SF1"
					If lRet .AND. cPaisLoc $ "MEX"	.AND. (aCfgNf[SnTipo] == 10 .OR. aCfgNf[SnTipo] == 20 )
						If ValType(cNatureza) = "U"
							cNatureza := M->F1_NATUREZ
						EndIf
						lRet := LxTudOkMex(aCfgNf[ScTipoDoc],cAliasI,aCpItens,aCItens,cNatureza,cCondicao,aRecnoSE1)
					EndIf
				endif
			Endif
			// Valida que exista informacion de los titulos cuando la condicion de pago es informada
			If lRet .AND. !l103Class .AND. !Empty(aCfgNf[ScOpFin]) .AND. Len(aDupl) > 0 .AND. MaFisRet(,"NF_BASEDUP") > 0 .AND. cPaisLoc $ "ARG" .AND. IIF(cPaisLoc $ "ARG", DesTrans(Extrae(aDupl[1],5))==0, Val(Alltrim(Extrae(aDupl[1],5)))==0) .And. !(cPaisLoc $ "PAR")
				Aviso(STR0018,STR0057,{STR0021}) //"ATENCAO"### "Inconsistencias nos valores financeiros"###"OK"
				lRet	:= .F.
			EndIf

			//Consistencias para Formulario Proprio
			If lRet .AND. lFormP .AND. !l103Class
				//Verifica numero de itens
				If	lRet .AND. (cModulo=="FIS")
					If Len(aCitens) > a460NumIt(cSerie)
						Aviso(STR0018,STR0046+"("+AllTrim(Str(Len(aCitens)))+")",{STR0021})
						lRet := .F.
					EndIf
				EndIf
			EndIf
		EndIf //lRet (3)
	EndIf //lRet (2)
EndIf //lRet (1)

If lRet .and. cPaisLoc == "ARG"
	lRet := TudoOkArg(cAliasC,cAliasI,cAliasCF,aCabNotaOri,aCpItensOri,aCitensOri,nLinha,cTipDoc,lFormP,aGetsTela,lTela,aCfgNF,nMoedaNF,nMoedaCor,nTaxa,cNFiscal,cSerie,cFunName)
EndIf
If lRet .And. cPaisLoc == "COL"
	lRet := NfTudOkCol(cAliasI, cSerie, aCfgNF, aCitens, aCpItens, cFilAnt, cEspecie, cnFiscal, cFunName)
EndIf
If lRet .And. cPaisLoc == "PER"
	lRet := NfTudOkPer(cFunName, aCfgNf, cAliasC, cAliasI, aCpItens, aCItens, @cNatureza, cCondicao, aRecnoSE1, cnFiscal, cSerie, cEspecie, cTipDoc, cFilAnt)
EndIf
If lRet .And. cPaisLoc == "EQU"
	lRet := NfTudOkEqu(nNFTipo, cAliasC, cAliasCF, IIf(Type('cFormCrbo') <> 'U', cFormCrbo, ""), IIf(Type('cNomeCli') <> 'U', cNomeCli, ""), IIf(Type('cDoctoId') <> 'U', cDoctoId, ""), aCItens, aCpItens, aCfgNf, IIf(Type('aLlaveOrg') <> 'U', aLlaveOrg, {}), cFunname)
EndIf
If lRet .And. cPaisLoc == "BOL"
	lRet := NfTudOkBol(aCfgNf, aDupli, MaFisRet(,"NF_BASEDUP"), nMoedaNF, nMoedaCor, nTaxa, l103Class, cFunName)
EndIf
If lRet .And. cPaisLoc == "URU"
	lRet := NfTudOkUru(aCfgNf, aDupli, MaFisRet(,"NF_BASEDUP"), nMoedaNF, nMoedaCor, nTaxa, l103Class, cFunName)
EndIf
If lRet .And. cPaisLoc == "CHI"
	lRet := NfTudOkChi(aCfgNf, aDupli, MaFisRet(,"NF_BASEDUP"), nMoedaNF, nMoedaCor, nTaxa, l103Class, Iif(Type("cCxCaixa")!="U",cCxCaixa,), Iif(Type("nCxValor")!="U",@nCxValor,), cFunName)
EndIf
If lRet .And. cPaisLoc == "PAR"
	lRet := NfTudOkPar(aCfgNf, aDupli, MaFisRet(,"NF_BASEDUP"), nMoedaNF, nMoedaCor, nTaxa, l103Class, cFunName,nNFTipo, cCondicao,cNatureza)
EndIf
If lRet .And. cPaisLoc == "EUA"
	lRet := NfTudOkEUA(aCfgNf, cFunName)
EndIf
//³Valida se o numero esta homologado pela SAT
If lRet .AND. cPaisLoc == "GUA"
   lRet  := LocxNumSAT(cSerie,cNFiscal)
   //³ A gravacao do motivo da devolucao eh Obrigatoriedade fiscal - Loc. Guatemala
   //³ Nao deve considerar as Notas de envio(remitos)
   If lRet .AND. aCfgNf[ScTipoDoc] == "D" .AND. aCfgNF[SnTipo] < 10 .AND. ;
      (Type("lLocxAuto") == "U" .OR. !lLocxAuto )
      lRet  := LocxMotDev()
   EndIf
EndIf

//³Ponto de Entrada para incluir consistencias do tudok³
cPe	:=	LocxPE(16)
If lRet .AND. !Empty(cPE)
	lRet:=ExecBlock(cPE,.F.,.F.)
Endif

//Tirar o foco do campo selecionao para que nao se valide novamente quando se MATA o objeto DIALOG principal
If lRet .AND. Type("oBSomaItens")=="O" .AND. aCfgNf[SnTipo] <> 64
	oBSomaItens:SetFocus()
Endif
If lGeraBlq
	lRet := .F.
Endif


//Validação da integração do ativo fixo com as notas de crédito e débito, para ajuste no valor do bem.
If lRet .And. lIntNtCRDB .And. cEspecie $ "NDP|NCI|NCP|NDI"
	lRet := A103VLNCD( cAliasI, aCpItens, aCItens )
EndIf

If lRet
	//³Bloqueia Pedidos Amarrados ao Processo ³
	If Type("aRegsLock")<>"U"
		cPe	:=LocxPE(70)
		If !Empty(cPE)
			lBlockPed:=	ExecBlock(cPe,.F.,.F.,{})
		Endif
		If lBlockPed
			If !PedidoLock(aCitens,aCpItens)
				Aviso(STR0018,STR0290,{STR0021})
				lret:=.F.
			EndIf
		EndIf
	EndIf
EndIf

If lRet .And. cPaisLoc == "MEX"
	lRet := NfTudOkMex(aCfgNf, aCpItens, aCitens, nLinha, nNFTipo, cAliasC, nItemSrv, lGerarCFD, OAPP, cFilAnt, cSerie, cnFiscal, cEspecie, aCabNotaOri, aCabNota, cFunName)
EndIf


If Type("nNumDocNF") <> "U" .And. (cPaisLoc $ "MEX|PER|COL|EQU|ARG" .And. FunName() == "ATFA036") .Or. (cPaisLoc == "ARG" .And. (FunName() $ "FINA935|FINA846|FISA828" .OR. IsInCallStack("F935GeraNF") .Or. IsInCallStack("FINA998")))
	nNumDocNF := cNFiscal
EndIf

RestArea(aArea)
RestArea(aAreaC)
Return lRet

/*
±±³Fun‡…o    ³ExecTotal      ³ Autor ³ Leandro C. G.      ³ Data ³06/12/2001³±±
±±³Descri‡…o ³Efetua o calculo para campos de um arquivo de cabecalho a     ³±±
±±³			 ³partir dos dados de seus itens							    ³±±
±±³ Uso      ³ EXECTOTAL												    ³±±
param.
cTotaliz	- formula utilizada para conteudo totalizador Ex.: M->D1_TOTAL
aCpos		- nome dos campos referentes aos itens (aHeader[2])
aItens		- Dados dos itens de onde deve ser executada a formula. A formula e executada para cada item
  			somando-se o novo conteudo com o conteudo anterior */
Function ExecTotal(cTotaliz,aCpos,aItens)
Local 	nResult := 0
Local 	nI		:= 0
Default aItens 	:= {}

If Empty(aCpos) .OR. Empty(aItens)
	Return(nResult)
EndIf
nI := 0
For nI := 1 to Len(aItens)
	//³Verifica se a linha nao esta deletada³
	If ValType(aItens[nI][Len(aItens[nI])]) == "L" .AND. aItens[nI][Len(aItens[nI])]
		Loop
	EndIf
	//³Atribui valor dos campos em variaveis de memoria³
	Aeval(aCpos, { |x,y| IIf(x!=NIL,&("M->"+x):=If(ValType(aItens[nI][y])!="A",aItens[nI][y],NIL),) })
	//³Executa totalizador³
	nResult	+= &cTotaliz
Next nI
Return(nResult)

/*
±±³Fun‡…o    ³ExecFormula    ³ Autor ³ Leandro C. G.      ³ Data ³07/12/2001³±±
±±³Descri‡…o ³Efetua o uma formula a partir de dados de um array ou nao 	³±±
±±³ Uso      ³ GENERICO 												    ³±±
param.
cFormula	- formula utilizada para conteudo
aCpos		- nome dos campos serao carregados em memoria antes de executar a formula
aItens		- conteudo dos campos
lMem		- Flag que indica se os campos devem ser carregados em memoria ou nao
*/
Function ExecFormula(cFormula,aCpos,aDados)
Local xResult
//³Verifica se deve carregar campos em memoria³
If !Empty(aCpos) .AND. !Empty(aDados)
	Asize(aDados, Len(aCpos))
	Aeval(aCpos, { |x,y| If(x!=NIL,&("M->"+x):=If(ValType(aDados[y])!="A",aDados[y],NIL),) })
EndIf
xResult := &cFormula
Return(xResult)

/*
±±³Fun‡…o    ³NfLinOk        ³ Autor ³ Leandro C. G.      ³ Data ³17/12/2001³±±
±±³Descri‡…o ³Efetua validacoes referentes a itens de uma NF     			³±±
param.
cAliasI		- 	Alias de Itens de NF
aCposOri	- campos dos itens (posicoes [2] do aHeader)
cAliasCF	- Indica se e cliente ou fornec. (SA1-Cliente ; SA2-Fornec.)
aItensOri	- conteudo dos itens da NF (aCols) * o conteudo de cada campo pode ser uma formula
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
nLinha		- Indica a linha do aDadosIOri que deve ser validada                          ]
lFormP		- indica se e formulario proprio ou nao

Obs.: no caso de haver apenas um linha a ser consistida em aDadosIOri, a mesma dever ser um array, nao esquecer de que o parametro aDadosIOri deve ter sempre duas dimensoes
*/
Function NfLinOk(cAliasI,aCposIOri,cAliasCF,aDadosIOri,cTipDoc,nLinha,lFormP)
Local nI,nX,nZ		 															//Flag's para Loop's
Local cCampo   	:= ""															//Nome de campos
Local cPrefDev 	:= ""			 												//Prefixo do alias da Nota Original de uma devolucao														//Array auxiliar
Local aDadosI	:= aClone(aDadosIOri)
Local aCposI	:= aClone(aCposIOri)															//Indica se algum conteudo refersntes aos campos do parametro aCposI e uma formula
Local lRet		:= .T.															//Indica consistencia da funcao
Local nSalvaN   := IIf(Type("n")!="U",n,0)										//Salva linha atual de um possivel aCols que esteja sendo utilizado
Local nQuantAux := 0															//Somatoria das qtdes de uma nota de origem de uma devolucao
Local cAliasVld	:= ""
Local nTotLin   := 0
Local cFilSB1	:= xFilial("SB1")
Local lLxDelAdt		:= .T.
Local lLocaliz 	:= SuperGetMV("MV_LOCALIZ")=="S"
//³Posicoes dos campos do array de dados³
Local nPosCod:=nPosSerRem:=nPosQuant:=nPosTes				:= 0
Local nPosLocal:=nPoslote:=nPosLoteCtl:=nPosNfOri:=nPosSerOri			:= 0
Local nPosCliFor:=nPosLoja:=nPosLocaliz	:= 0 //nPosItemOri
Local nPosRemito:=nPosItemRem:=nPosNumSer:=nPosEspecie  := 0
Local nPosServ  :=0
Local lVerLoca	:=.T.
Local lFactElec	:= !Empty(SuperGetMV("MV_PROVFE", .F., "")) //Facturacion Electronica Activa
Local nPosItem	:= 0
Local cCpoUbiP  := ""
Local cMVINTDL := SuperGetMV('MV_INTDL')
Local cFuncN	:= Funname()
Local lDoRef	:= Type("bDoRefresh") != "U"
Local lListRef	:= Type("bListRefresh") != "U"
Local lokCHI:=   cPaisLoc == "CHI" .AND.  FindFunction("LxLOkCHI") 
//³Variaveis utilizadas em outras funcoes³
Private cA100For
If Type("n")=="U"
	Private n := 0				//numero de cada linha de dados
EndIf
Private cTipo := ""
Private cLoja := ""
//utilizada na funcao a465Qtde
If Type("lCliente") == "U"
	Private lCliente := IIf(!Empty(cAliasCF).AND.cAliasCF=="SA1",.T.,.F.)
EndIf

If Type("bDoRefresh") == "U"
	bDoRefresh := {|| NIL}
EndIf
If Type("bListRefresh") == "U"
	bListRefresh := {|| NIL}
EndIf
If Type("lLocxAuto") == "U"
	lLocxAuto := .F.
EndIf
If Type('l103Auto') == "U"
	lLocxAuto := .F.
EndIf
If Type("cCFDUso") == "U"
	cCFDUso := ""
EndIf
If Type("cFunname") == "U"
	cFunname := cFuncN
EndIf
If Type("cCondicao") == "U"
	cCondicao := ""
EndIf

//³Valores padrao³
Default nLinha  := 0
cPrefdev		:= IIf(cAliasI=="SD1","SD2->D2","SD1->D1")
nPosItem	:= aScan(aHeader,{|x| AllTrim(x[2]) == IIf(cAliasI == "SD2", "D2_ITEM", "D1_ITEM")}) //Posicion de _ITEM

//³Verificando a pos. dos campos que serao utilizados³
nX := 0
For nX := 1 To Len(aCposI)
	cCampo := AllTrim(aCposI[nx])
	Do Case
	Case cCampo == IIf(cAliasI=="SD1","D1_FORNECE","D2_CLIENTE")
		nPosCliFor  := nx
	Case cCampo == PrefixoCpo(cAliasI)+"_LOJA"
		nPosLoja    := nx
	Case cCampo == PrefixoCpo(cAliasI)+'_COD'
		nPosCod		:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_QUANT'
		nPosQuant	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_TES'
		nPosTes		:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_LOCAL'
		nPosLocal	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_NUMLOTE'
		nPosLote	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_LOTECTL'
		nPosLoteCtl	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_NFORI'
		nPosNFOri	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_SERIORI'
		nPosSerOri	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_ITEMORI'
		nPosItmOri	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+"_LOCALIZ"
		nPosLocaliz := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_NUMSERI"
		nPosNumSer  := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_SERIREM"
		nPosSerRem   := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_REMITO"
		nPosRemito  := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_ITEMREM"
		nPosItemRem := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_ESPECIE"
		nPosEspecie := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_SERVIC"
		nPosServ  	:= nX
	EndCase
Next nx

//Varrendo todos os itens
nI := 0
For nI := IIf(nLinha>0,nLinha,1) to IIf(nLinha>0,nLinha,Len(aDadosI))
	nQuantAux := 0
	//Verifica se a linha nao esta deletada
	If aDadosI[nI][Len(aDadosI[nI])]
		//Se a linha for deletada. Desvincula Titulos de Adiantamento Relacionados
		If cPaisLoc  $ "MEX|PER" .AND. lLxDelAdt
			LxDelAdt(nI, aCols, aRecnoSE1, N, aHeader, bDoRefresh, bListRefresh)
		EndIf
		Loop
	EndIf

	//Seta variaveis utilizadas por outras funcoes
	n 			:= nI
	cA100For := IIf(nPosCliFor>0.AND.cAliasI=="SD1",aDadosI[IIf(!Empty(nLinha),nLinha,1)][nPosCliFor],"") //codigo do fornec. (usada em rotinas de validacao)
	cLoja		:= IIf(nPosLoja>0,aDadosI[IIf(!Empty(nLinha),nLinha,1)][nPosLoja],"")
	cTipo    := cTipDoc
	//Verifica campos de preenchimento obrigatorio
	If !l103Class
		If lRet .AND. !CposVazio(,cAliasI,cTipDoc,,aCposI,aDadosI[nI])
			lRet := .F.
		EndIf
		// Replica chamado TUDCUI - Nao permitir gravar nota com quantidade maior que zero utilizando TES com F4_QTDZERO = Sim
		if cPaisloc=='RUS'
			If lRet .And. nPosTes > 0 .And. nPosQuant > 0 .And. MaTesSel(aDadosI[nI][nPosTes]).And. aDadosI[nI][nPosQuant] > 0
				Aviso(STR0018,STR0048,{STR0021})
				lRet := .F.
			EndIf
		ENDIF
	  	// Obriga preenchimento de D2_LOCALIZ qdo fatura nao vier de um pedido
	  	// e o produto tem controle de localiz. pela MV_LOCALIZ = "S" (sempre que
	  	// a qtde nao for zero)
	  	If nPosTes>0 .AND. nPosCod>0 .AND.;
	  		( lRet ) .AND. lLocaliz .AND.;
	  		 &("Val('"+aDadosI[nI][nPosTes]+"') > 500").AND.;
			(nPosQuant > 0	.AND. aDadosI[nI][nPosQuant] > 0) // Alteracao conforme BOPS 66.670
			cAliasVld := Alias()
			DbSelectArea("SB1")
			DbSetOrder(1)
			MsSeek( cFilSB1+aDadosI[nI][nPosCod] )
			lVerLoca:=.T.
			If cPaisLoc=="ARG" .AND. cMVINTDL == 'S' .AND. nPosServ>0 .AND.    !Empty(aDadosI[nI][nPosServ])
				lVerLoca:=.F.
			EndIf
			If ( RetFldProd(SB1->B1_COD,"B1_LOCALIZ") == "S" ) .And. lVerLoca
				If lRet .And. cPaisLoc == "ARG" .And. FindFunction("VldSerProd") .And. FunName() $ ("MATA467N|MATA462N")
					If SF4->F4_ESTOQUE == "S" .And. Empty(aDadosI[nI][nPosNumSer])
						If VldSerProd(aDadosI[nI][nPosCod], aDadosI[nI][nPosLocal], aDadosI[nI][nPosLocaliz])
							cCpoUbiP := AllTrim(RetTitle('D2_LOCALIZ'))
							Help(" ", 1, "NUMSERI", , STR0442, 2, 0,,,,,, {STRTRAN(STR0443, "[VAR01]", cCpoUbiP )})
							lRet := .F.
						EndIf
					EndIf
				EndIf
			Endif
			DbSelectArea(cAliasVld)
	  	Endif
	EndIf
	//valida que la tes no afecte financiero y stock
	If nPostes>0 .AND. lRet .AND. Strzero(aCfgNF[SnTipo],2)== "21"
		lRet := LxTesTras(aDadosI[nI][nPosTes])
	EndIf

	//Valida si es almacén de calidad
	lRet := (lRet .And. lxLocal(aDadosI[nI][nPosLocal]))

	// Validacao notas fiscais originais
	If lRet .AND. cPaisLoc == "PER"
		lRet := LxLOkPer(cAliasI,aCposIOri,aDadosIOri,cTipDoc,nI,lFormP, aCfgNF, cEspecie, cCondicao, nSalvaN, aHeader, aCols, cFuncN)
	EndIf
	If lRet .AND. cPaisLoc == "MEX"
		lRet := LxLOkMex(cAliasI,aCposIOri,aDadosIOri,cTipDoc,nI,lFormP,IIf(lDoRef,bDoRefresh,Nil), IIf(lListRef,bListRefresh,Nil))
	EndIf
	If lRet .and. cPaisLoc == "ARG"
		lRet := ArgLinOk(cAliasI,aCposIOri,cAliasCF,aDadosIOri,cTipDoc,nI,lFormP,l103Class,aCfgNf)
	EndIf
	If lRet .and. cPaisLoc == "PAR"
		lRet := ParLinOk(cAliasI,aCposIOri,cAliasCF,aDadosIOri,cTipDoc,nI,lFormP,nMoedaNF,l103Class)
	EndIf
	If lRet .and. cPaisLoc == "EQU"
		lRet := LxLOkEqu(aCfgNF, aDadosI, cTipDoc, nI, nPosRemito, nPosItemRem, nPosSerRem, nPosCliFor, nPosLoja, nPosCod, nPosEspecie, nPosNFOri, nPosItmOri, nPosQuant)
	EndIf
	If lRet .and. cPaisLoc == "BOL"
		lRet := LxLOkBol(aHeader, aCols, nI, lFactElec, lFormP, cCFDUso, cEspecie, cFunname, nPosRemito, nPosNFOri, nPosSerOri)
	EndIf

	If lRet .and. lokCHI
		lRet :=  LxLOkCHI(@aCols, nI,cEspecie,  nPosNFOri, nPosSerOri,nPosItmOri,nPosCod,nPosQuant)
	EndIf

Next nI

// Ponto de Entrada para inclusao de consistencias na LINOK
cPe	:=	LocxPE(17)
If lRet .And. !Empty(cPE)
	lRet:= ExecBlock(cPE,.F.,.F.)
Endif
//³Restaurando valores da entrada da funcao³
IIf(nSalvaN>0.And.Type("n")!="U",n:=nSalvaN,)
//³Verifica se existe a necessidade de aumentar o numero maximo de itens|
If Type("oGetDados")=="O" .And. AllTrim(FunName()) <> "MATA462TN"
	If lRet .And. (nLinha == Len(aCols) .And. (nLinha == oGetDados:nMax .Or. nLinha > oGetDados:nMax))
		AEval(aCols,{|x| nTotLin += Iif(!x[Len(aHeader)+1]	,1,0) })
		If nTotLin < LjGetMaxIt(cSerie)
			oGetDados:nMax := (Len(aCols) + 1)
		EndIf
	EndIf
Endif

//Se valida que el Documento Original informado en NDC/NCC - Colombia/Peru
If lRet .And. cPaisLoc $ "COL" .And. nLinha > 0 .And.  FunName() == "MATA465N" .And. cEspecie $ "NDC|NCC" .And. lFormP .And. (aCols[nSalvaN][Len(aHeader)+1] == .F.) .And. (lFactElec) .And. Empty(aCols[nSalvaN][nPosRemito])
	lRet := LxVldDocIt(aCols[nSalvaN][nPosNFOri], aCols[nSalvaN][nPosSerOri], cEspecie)
EndIf

Return(lRet)

/*
±±³Fun‡…o    ³CposVazio      ³ Autor ³ Leandro C. G.      ³ Data ³14/12/2001³±±
±±³Descri‡…o ³Verifica todos os campos obrigatorios para gravacao de uma  	³±±
±±³			 ³NF											   				³±±
param.
cAliasC		-	Alias de cabecalho de NF
cAliasI		- 	Alias de Itens de NF
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
aCabNota 	-	Cabecalho da Nota
		   		[1] - campos do cabecalho
		   		[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
		   		[3] - indica se o campo e totalizador (Default .F.)
aCpItens 	- 	campos dos itens (devem obedecer a sequencia do aHeader)
aCitens  	- 	conteudo do item da NF (devem odebecer a sequencia do aCols) * o conteudo de cada campo pode ser uma formula
				deve ser passado um item por vez
lObrigSX3	-	Indica se devem ser verificados os obrigatorios do SX3
lObrigNF		-  Indica se devem ser verificados os obrigatorios proprios da rotina
*/
Function CposVazio(cAliasC,cAliasI,cTipDoc,aCabNota,aCpItens,aCitens,lObrigSX3,lObrigNF)
Local nI//,nX						//Flag's para loop's
Local aObrigC	   := {}		//Array com os campos obriagtorios de cabecalho
Local aObrigI	   := {}		//Array com os campos obriagtorios de itens
//Local aPos		   := {}		//Posicoes de campos em um array
Local lRet		   := .T.		//Indica consistencia da Funcao
Local nPos		   := 0
Local aPars	   	   := {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local lCartaP      := SF2->(ColumnPos("F2_TPCOMPL")) > 0
DEFAULT lObrigSX3	:=	.T.
DEFAULT lObrigNF	:=	.T.

//³Consistindo param
If !Empty(cAliasI)
	Aadd(aPars	, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
	Aadd(aPars	, {"aCpItens"	, aCpItens	, SpEmpty						} )
	Aadd(aPars	, {"aCitens"	, aCitens	, SpEmpty						} )
EndIf
If !Empty(cAliasC)
	Aadd(aPars	, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
	Aadd(aPars	, {"aCabNota"	, aCabNota	, SpLenArray	,1		,3		} )
EndIf
Aadd(aPars	, {"lObrigSX3"	, lObrigSX3	, SpValType	,	"L"	} )
Aadd(aPars	, {"lObrigNF"	, lObrigNF	, SpValType	,	"L"	} )

lRet := LocxParam("CPOSVAZIO",aPars)

If lRet //(1)
	//³Busca campos obrigatorios nos arquivos de NF, de acordo com SX3
	If lObrigSX3
		IIf(!Empty(cAliasC),aObrigC:=CposObrig(cAliasC,aCabNota[1]),)
		IIf(!Empty(cAliasI),aObrigI:=CposObrig(cAliasI,aCpItens),)
	Endif
	//³Adiciona os campos obrigatorios especificamente na gravacao de uma NF
	If lObrigNF
		IIf(!Empty(cAliasC),aObrigC:=CposObrigNf(cAliasC,cTipDoc,aObrigC,aCabNota[1]),)
		IIf(!Empty(cAliasI),aObrigI:=CposObrigNf(cAliasI,cTipDoc,aObrigI,aCpItens),)
	Endif
	//³Verifica se todos os campos obrigatorios, de cabecalho, estao presentes e preenchidos³
	If !Empty(cAliasC)
		nI := 0
		For nI := 1 to Len(aObrigC)
			nPos := Ascan(aCabNota[1], {|x| Upper(AllTrim(x)) == Upper(AllTrim(aObrigC[nI]))})
			If aObrigC[nI] != (PrefixoCpo(cAliasC)+"_FILIAL") .AND. ; //o campo de filial possui valor automatico
			   (nPos <= 0 .OR. ValType(aCabNota[2][nPos]) == "A" .OR. Empty(aCabNota[2][nPos]))
				SX3->(DBSetOrder(2))
				SX3->(MSSeek(aObrigC[nI],.F.))
				Aviso(STR0038,STR0075+X3Titulo(aObrigC[nI]),{STR0021})
				lRet := .F.
				Exit
			EndIf
		Next nI
	EndIf
	//³Verifica se todos os campos obrigatorios, de itens, estao presentes e preenchidos³
	If !Empty(cAliasI)
		nI := 0
		For nI := 1 to Len(aObrigI)
			If aObrigI[nI] != (PrefixoCpo(cAliasI)+"_FILIAL")
				nPos := Ascan(aCpItens, {|x| Upper(AllTrim(x)) == Upper(AllTrim(aObrigI[nI]))})
				If nPos == 0 .OR. Empty(aCitens[nPos])
					If Alltrim(aObrigI[nI]) $ "D2_PRCVEN|D2_TOTAL" .And. cPaisLoc == "MEX" .And. FWIsInCallStack("MATA467N") .And. (nNFTipo == 21 .Or. (lCartaP .And. M->F2_TPCOMPL == "S"))
						lRet := .T. // Traslado o NF con carta porte ==> aceptar precio unitario y total cero
					Else
						SX3->(DBSetOrder(2))
						SX3->(MsSeek(aObrigI[nI],.F.))
						Aviso(STR0038,STR0076+X3Titulo(aObrigI[nI]),{STR0021})
						lRet := .F.
						Exit
					EndIf
				EndIf
			EndIf
		Next nI
	EndIf
EndIf //lRet (1)
Return(lRet)

/*
±±³Fun‡…o    ³HeaderCpos     ³ Autor ³ Leandro C. G.      ³ Data ³17/12/2001³±±
±±³Descri‡…o ³Devolve um array apenas com o nome dos campos baseados no 	³±±
±±³          ³aHeader que estiver declarado									³±±
*/
Function HeaderCpos()
Local aCpos := {}
If Type("aHeader") != "U"
	Aeval(aHeader, { |x| IIf(Len(x)>=2.AND.!Empty(x[2]),Aadd(aCpos, x[2]),) })
EndIf
Return(aCpos)

/*
±±³Fun‡…o    ³ GravaFina     ³ Autor ³ Leandro C. G.          ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Grava movimentacoes do financeiro                                  ³±±
±±³ Uso      ³ LocXNF                                                             ³±±
param.
cAliasC		- Alias do cabecalho da NF que esta sendo gravada (SF1/SF2)
cAlaisFin	- Alias do arquivo financeiro que sera atualizado (SE1/SE2)
aDuplOri	- Array com os dados referentes aos vencimentos
'			  [x][1] - Serie da NF
			  [x][2] - Numero da NF
			  [x][3] - Parcela referente ao vencimento
			  [x][4] - Data do Vencimento
			  [x][5] - Valor do Vencimento
cTipoFin	- tipo do titulo a ser gravado no financeiro
cSinal 	- indica sinal de operacao financeira (+ = receber ou - = pagar)
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
Obs. :Considera que o arquivo de Notas Fiscais estao posicionados antes da chamada da funcao
Obs. :Considera que as variaveis de impostos estao carregadas
*/
Function GravaFina(cAliasC,cAliasFin,aDuplOri,cTipoFin,cSinal,cTipDoc,aFin,aRecnoI,aRecnoSE1)
Local nX							//Flag's para Loop's
//Local aArea   	:= GetArea()
Local lRet		:= .T.				//Indica consistencia da funcao
//Local aRetIrrf	:= {}
//Local cPrefFin	:= IIf(!Empty(cAliasFin),cAliasFin+"->"+PrefixoCpo(cAliasFin),"")	//Prefixo do Alias do arquivo Financeiro que sera atualizado
Local cPrefC   := IIf(!Empty(cAliasC),cAliasC+"->"+PrefixoCpo(cAliasC),"")  		//Prefixo do Alias de Cabecalho da NF
Local cNatureza:= aFin[ScNatureza]
//Local nTamData := IIf(__SetCentury(),10,8)
//Local nTotDup  := 0																	//Valor total das duplicatas gravadas
//Local aRecSE1  := {}
Local nBaseDup := MaFisRet(,"NF_BASEDUP")
//Local nTotCruz	:= 0
//Local dDataCnd := dDataBase
//Local nValFat  := 0
//Local nMcompra := 0
Local aPars	   := {}						//Array para a funcao de validacao de parametros (Olhar funcao LocxParam())
Local aRet	 	:= {}
Local lOnlineAcc as Logical
Local lShowAcc as Logical
Local aSaveParPg as Array
Local nValDup  := 0 
Local aDuplAux := {}
Local lDifDup  := .F.


Default aRecnoSE1 := {}

//³Variaveis utilizadas em outras rotinas³
Private aCaixaFin:= xCxFina()			// Caixa Geral do Financeiro
Private l103Auto := .T.
Private cNFiscal := ""
Private cSerie   := ""
PRIVATE nValFun  := MaFisRet(,"NF_FUNRURAL")
Private aDupl    := aClone(aDuplOri)		//Array com os dados referentes aos vencimentos
Private nTaxa	 := 0
/*			  								[x][1] - Serie da NF
											[x][2] - Numero da NF
											[x][3] - Parcela referente ao vencimento
											[x][4] - Data do Vencimento
											[x][5] - Valor do Vencimento */
//³Consistindo parametros³
Aadd(aPars, {"cAliasC"		, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasFin"	, cAliasFin	, Sp2String		,"SE1"	,"SE2"	} )
Aadd(aPars, {"cTipoFin"		, cTipoFin	, SpEmpty						} )
Aadd(aPars, {"cSinal"		, cSinal	, Sp2String		,"+"	,"-"	} )
Aadd(aPars, {"cTipDoc"		, cTipDoc	, SpEmpty						} )
lRet := LocxParam("GRAVAFINA",aPars)

If lRet //(1)
	//³Carrega variaveis de acordo com a NF ³
	ASize(aFin,SnMaxFin)
	If cAliasC == "SF1"
		nMoedaNF  := SF1->F1_MOEDA
	Else
		nMoedaNF  := SF2->F2_MOEDA
	EndIf
	If aFin[SnMoedaFin]==Nil
	 	aFin[SnMoedaFin]:=nMoedaNF
	Endif
	nMoedaCor := aFin[SnMoedaFin]
	If aFin[ScNatureza]==Nil.OR.Empty(aFin[ScNatureza])
		If cAliasC == "SF1"
			cNatureza := SF1->F1_NATUREZ
		Else
			cNatureza := SF2->F2_NATUREZ
		EndIf
	 	aFin[ScNatureza]:= cNatureza
	Else
		cNatureza:=aFin[ScNatureza]
	Endif
	If cAliasC == "SF1"
		nTaxa	 := SF1->F1_TXMOEDA
		cNFiscal := SF1->F1_DOC
		cSerie   := SF1->F1_SERIE
	Else
		nTaxa	 := SF2->F2_TXMOEDA
		cNFiscal := SF2->F2_DOC
		cSerie   := SF2->F2_SERIE
	EndIf

	//³Verifica numero de vendedores do sistema³
	nVend := Fa440CntVen()

	//³Carrega o array com os vencimentos da duplicata³
	nValDup := DesTrans(Extrae(aDuplOri[1],5))
	lDifDup := nValDup <> Round(nBaseDup,MsDecimais(1))
	If Empty(aDuplOri) .Or. lDifDup
		If lDifDup
			aDuplAux := {}
		EndIf
		LxA103Dupl(nBaseDup,nMoedaCor,&(cPrefC+"_EMISSAO"),&(cPrefC+"_COND"),IIf(lDifDup,@aDuplAux,@aDuplOri),,,,,,aFin[ScNatureza])
	EndIf
	
	//Ponto de Entrada para generación de SE1/SE2 para ajustar el array de Financiero llamado por MATA475
	If cPaisLoc == "EUA" .And. ExistBlock("MATA475DP") .And. FunName() == 'MATA475'
		aDuplOri :=	ExecBlock("MATA475DP",.F.,.F.,{aDuplOri,aFin})
	EndIf

	//³Ponto de Entrada apos geracao de SE1/SE2
	cPe	:=	LocxPE(38)
	If !Empty(cPE)
		aDuplOri	:=	ExecBlock(cPE,.F.,.F.,{aDuplOri,aFin})
	EndIf
	//Adiantamentos do mexico chama com nBaseDup == 0 Portanto nao deve ser gerado SE1, apenas acionada a baixa
	If nBaseDup > 0
		//³ Gera titulo no financeiro
		If cAliasFin == "SE1"
			aRet	:=	GravaSE1(aDuplOri,aRecnoI,aFin,aDuplAux)
		Else
			aRet	:=	GravaSE2(aDuplOri,Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_EMISSAO,SF2->F2_EMISSAO),aFin)
		Endif
		RecLock(aCfgNf[SAliasHead],.F.)
		If aCfgNf[SAliasHead] == "SF2"
			SF2->F2_VALFAT := aRet[2][1]
		Endif
		If cAliasC == "SF1"
			SF1->F1_PREFIXO := aRet[2][2]
			SF1->F1_DUPL    := aRet[2][3]
		Else
			SF2->F2_PREFIXO := aRet[2][2]
			SF2->F2_DUPL    := aRet[2][3]
		EndIf
		MsUnLock()
		//³ Gera titulo de recolhimento de impostos no financeiro
		If aCfgNf[ScAliasFin]=="SE2"
			GeraTitImp(cAliasC,aRet)
		Endif
		//³Ponto de Entrada apos geracao de SE1/SE2
		cPe	:=	LocxPE(37)
		If !Empty(cPE)
			ExecBlock(cPE,.F.,.F., aRet[1])
		EndIf
		If aCfgNF[ScCliFor] == "SA1"
			//³ Estorna os valores da Comissao.
			If ( SuperGetMv("MV_TPCOMIS")=="O" )
				For nX := 1 To Len(aRet[1])
					dbSelectArea("SE1")
					MsGoto(aRet[1][nX])
					Fa440CalcE(IIf(cTipoFin=="D","MATA100","MATA460") )
					//³Ponto de Entrada apos geracao das comissoes³
					cPe	:=	LocxPE(25)
					If !Empty(cPE)
						ExecBlock(cPE,.F.,.F., aRet[1])
					EndIf
				Next
			EndIf
		Endif
		//³ Executa a baixa de titulos com pagamento a vista
		BaixAutSE1(cCondicao,aRet[1],aCaixaFin,aCfgNf[ScAliasFin])
	EndIf
	//Compensación de anticipos
	If StrZero(aCfgNf[SnTipo],2) $ "|01|10|" .AND. cAliasFin $ "|SE1|SE2|" .AND. A410UsaAdi( cCondicao )
		If !(cPaisLoc $ "MEX|PER") //Para o Mexico a Baixa do RA eh feita sem compensacao, apenas baixa do titulo.
			If cPaisLoc <> "RUS" .Or. (cPaisLoc == "RUS" .And. Len(aRecnoSE1) <= 0)
				a468NCompAd(, aRet[1], aRecnoSE1)
			Else
				aSaveParPg := {}

				For	nX := 1 To 14  //save the conttent of MV before call pergunte
					AAdd(aSaveParPg, &("MV_PAR" + StrZero(nX, 2)))
				Next nX

				Pergunte("FIN330",.F.)
				lOnlineAcc := MV_PAR09
				lShowAcc := MV_PAR07

				For nX := 1 to len(aRecnoSE1)
					If nX <= len(aRelAdv)

						DBSelectArea('SE1')
						SE1->(DbGoTo(aRelAdv[nX][2]))

						aTxMoeda := {}
						aAdd(aTxMoeda,{SE1->E1_MOEDA,SE1->E1_TXMOEDA})
						nTaxaCM := SE1->E1_TXMOEDA

						MaIntBxCR(3,{aRelAdv[nX][1]},,{aRelAdv[nX][2]},,{lOnlineAcc,.F./*lAglutina*/,lShowAcc,.F.,.F.,.F.},,,,,SE1->E1_VALOR,,{aRelAdv[nX][3]},,nTaxaCM,aTxMoeda)
						FaGrvFR3("R","",SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA,aRecnoSE1[nX][3],M->F2_DOC,M->F2_SERIE)
					EndIf
				Next nX

				For nX := 1 To Len(aSaveParPg)  //restore conttent of MV after call pergunte
 					&("MV_PAR" + StrZero(nX, 2)) := aSaveParPg[nX]
				Next nX
			EndIf
		ElseIf Len(aRecnoSE1) > 0
			//Baixa os adiantamentos para o Mexico
			LxBaixaAdt(aRecnoSE1,aCaixaFin,aCols,aHeader,cNatureza)
		EndIf
	EndIf
EndIf //lRet (1)
Return(.T.)


/*ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CTBILNF       º Leandro C.G. ³Microsiga º Data ³  28/12/01  º±±
±±ºDesc.     ³ Efetua atualizacoes Contabeis sobre uma NF   		      º±±
±±ºUso       ³ GRAVANFGERAL                                               º±±
Parametros
cAliasC		-	Alias de cabecalho de NF
cAliasI		- 	Alias de Itens de NF
nRecno 		-	Numero do registro no arquivo de cabecalho
aRecno		-	Numero dos registros nos arquivos de itens
aLpC		-	Array com o numero dos lanç. padrao referentes a Cabecalho
aLpI		-	Array com o numero dos lanç. padrao referentes a Itens
lVerCtbil	-	Indica se deve mostrar na tela o lanç contabil
lAglutina	-	Indica se deve aglutinar lanç. contabeis
*/
Function CtbilNF(cAliasC,cAliasI,nRecno,aRecno,aLpC,aLpI,lVerCtbil,lAglutina)
//Local aArea        := GetArea()
Local cArquivo     := ""  //Nome do arquivo da contabilidade
Local lCtbilC      := .F. //Indica se existe lanç padrao para cabecalho
Local lCtbilI      := .F. 	//Indica se existe lanç padrao para itens
Local lCtbil       := .F. //Indica se existe algum lanç padrao (tanto cabecalho quanto item)
Local lLanctOk     := .F. //Indica se foi lanç contabil foi gerado com sucesso
Local lRet         := .T. //Indica consistencia da funcao
Local lVer613      := .F. //Salida de NCP Devolucao/Beneficiamento ( Proveedor ) - Itens do Rateio
Local lVer641      := .F. //Entrada de NF Devolucao/Beneficiamento ( Cliente ) - Itens do Rateio
Local lVer651      := .F. //Entrada de NF Normal ( Fornec. ) - Itens do Rateio
Local lVer950      := .F. //Indica se deve ou nao gerar lanç. contabeis referentes a import.
Local lVer965      := .F.
Local lVer711      := .F.
Local aPars        := {}  //Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nI           := 0
Local aCtbDia      := {}
Local lShowHelp    := (FunName() == "MATA447" .And. IsInCallStack("MATA447") .And. IsInCallStack("MATA447B"))
Local lShwHlpCol   := (cPaisLoc == "COL" .and. FunName() == "MATA143" .And. IsInCallStack("A143GeraNF") .And. FindFunction("LocxShowHelp")) 
Local lAuxCTB	   :=.T.
Local lSetAuto	   := .T.
Local lSetHelp     := .T.

Private nHdlPrv	   := 0	    //Guarda a evolucao da funcao HeadProva
Private cLote      := ""  	//Lote utilizado nas rotinas contabeis
Private nTotalLcto := 0	    //Acumula totais dos lanç. padores de cada item

Default nRecno      := 0
Default aRecno      := {}
Default aLpC		:= {}
Default aLpI		:= {}
Default lVerCtbil   := .F.
Default lAglutina   := .F.

//³Consistindo parametros
Aadd(aPars, {"nRecno"	, nRecno	, SpEmpty						} )
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"aLpC"		, aLpC		, SpValType		,"A"			} )
Aadd(aPars, {"aLpI"		, aLpI		, SpValType		,"A"			} )
lRet := LocxParam("CTBILNF",aPars)

If lRet //(1)
	If lShowHelp
		HelpInDark(.F.)
	EndIf
	If lShwHlpCol
		LocxShowHelp(@lSetAuto, @lSetHelp, .F.)
	Endif
	//³Verifica existencia dos lanç. contabeis recebidos e dos lanç. fixos (SDE)
	IIf(!Empty(aLpC), Aeval(aLpC, { |x| lCtbilC := IIf(!lCtbilC,VerPadrao(x),lCtbilC) }), )
	IIf(!Empty(aLpI), Aeval(aLpI, { |x| lCtbilI := IIf(!lCtbilI,VerPadrao(x),lCtbilI) }), )
	DBSelectArea(cAliasC)
	MSGoto(nRecno)
	//Confirma posicionamento do arquivo de cabecalho
	If Recno() != nRecno
		lCtbilC := .F.
	EndIf
	lVer641	:= cAliasC == "SF1" .AND. VerPadrao('641') .AND. Recno() == nRecno .AND. SF1->F1_TIPO $ 'BD'		// Entrada de NF Devolucao/Beneficiamento ( Cliente ) - Itens do Rateio
	lVer651	:= cAliasC == "SF1" .AND. VerPadrao('651') .AND. Recno() == nRecno .AND. !(SF1->F1_TIPO $ 'BD')	// Entrada de NF Normal ( Fornec. ) - Itens do Rateio
	lVer950 := cAliasC == "SF1" .AND. VerPadrao('950') .AND. Recno() == nRecno .AND. AllTrim(SF1->F1_TIPO_NF) $ "123456789AB" .AND. GetMV("MV_EASY") == "S"
	lVer965 := cAliasC == "SF1" .AND. VerPadrao('965') .AND. Recno() == nRecno .AND. AllTrim(SF1->F1_TIPO_NF) $ "123456789AB" .AND. GetMV("MV_EASY") == "S"
	lVer613 := cAliasC == "SF2" .AND. VerPadrao('613') .AND. Recno() == nRecno .AND. SF2->F2_TIPO $ 'BD'
	lVer711 := Iif (Len(aLpC) == 1, Iif(aLpC[1] == "711", .T., .F.) , .F.)
	lCtbil  := lCtbilC .OR. lCtbilI .OR. lVer641 .OR. lVer651 .OR. lVer965 .Or. lVer711
	//³ Inicializa o cabecalho dos lanç. Contabeis OnLine
	If  lCtbil
		DBSelectArea("SX5")
		MSSeek(xFilial()+IIf(cAliasC=="SF1","09COM","09FAT"), .F.)
		cLote 	 := IIf(Found(),Trim(X5DESCRI()),IIf(cAliasC=="SF1","COM ","FAT "))
		If Empty(nHdlPrv) .OR. nHdlPrv < 0
			nHdlPrv  := HeadProva(cLote,FunName(),Subs(cUsuario,7,6),@cArquivo)
		Endif
		If nHdlPrv <= 0
			Help(" ",1,"A100NOPRV")
			lRet := .F.
		EndIf
	EndIf
	If lRet //(2)
		//³ Gera lanç contabil  a partir de cabecalho
		If lCtbilC
			//³aLpC e um array com o numero dos	lanç. padrao referentes ao Cabecalho da NF  ³
			//³Para cada um dos lanç. padrao roda-se a funcao "DetProva" atraves do 		³
			//³comando "Aeval" onde "x" sera o numero de cada lanç padrao
			Aeval(aLpC, { |x| IIf((x!="950".OR.lVer950).AND.VerPadrao(x), nTotalLcto+=DetProva(nHdlPrv,x,FunName(),cLote,,,,,,,,,,,,,,,,,lShowHelp), ) })
		EndIf
		//³ Gera lanç contabil  a partir de itens
		If lCtbilI .AND. !Empty(aRecno)
			nI := 0
			For nI := 1 to Len(aRecno)
				DBSelectArea(cAliasI)
				MSGoto(aRecno[nI,1])
				SB1->(dbSetOrder(1))
				//-- Posiciona B1 para lancamentos padrao
				If (cAliasI)->(FieldPos(Substr(cAliasI,2,2) + "_COD")) > 0
					SB1->(dbSeek(xFilial("SB1")+(cAliasI)->&(Substr(cAliasI,2,2) + "_COD")))
				ElseIf (cAliasI)->(FieldPos(Substr(cAliasI,2,2) + "_PRODUTO")) > 0
					SB1->(dbSeek(xFilial("SB1")+(cAliasI)->&(Substr(cAliasI,2,2) + "_PRODUTO")))
				ElseIf (cAliasI)->(FieldPos(cAliasI + "_PRODUT")) > 0
					SB1->(dbSeek(xFilial("SB1")+(cAliasI)->&(cAliasI + "_PRODUT")))
				EndIf
				//Confirma posicionamento do arquivo
				If Recno() == aRecno[nI,1]
					//³aLpI e um array com o numero dos lanç. padrao referentes aos itens da Nota  ³
					//³Para cada um dos lanç. padrao roda-se a funcao "DetProva" atraves do 	   ³
					//³comando "Aeval" onde "x" sera o numero de cada lanç padrao
					Aeval(aLpI, { |x| IIf(VerPadrao(x), nTotalLcto+=DetProva(nHdlPrv,x,FunName(),cLote,,,,,,,,,,,,,,,,,lShowHelp), ) })
				EndIf
			Next nI
		EndIf
		//³ Gera lanç contabil  a partir de itens de importacao
		If lCtbilI .AND. lVer965 .AND. !Empty(aRecIMP)
			nI := 0
			cAliasImp	:=	IIf(GetNewPar("MV_CUSTIMP","1") == "1",'SD3','SWN')
			nPosRec		:=	iF(cAliasImp == 'SD3',1,2)
			For nI := 1 to Len(aRecIMP)
				SWN->(	MSGoto(aRecIMP[nI][2]))
				SD3->(	MSGoto(aRecIMP[nI][1]))
				SB1->(DbSetOrder(1))
				SB1->(DbSeek(xFilial("SB1")+SWN->WN_PRODUTO))
				DbSelectArea(cAliasImp)
				//Confirma posicionamento do arquivo
				If Recno() == aRecIMP[nI][nPosRec]
					//³aLpI e um array com o numero dos lanç. padrao referentes aos itens da Nota  ³
					//³Para cada um dos lanç. padrao roda-se a funcao "DetProva" atraves do 	   ³
					//³comando "Aeval" onde "x" sera o numero de cada lanç padrao
					nTotalLcto+=DetProva(nHdlPrv,'965',FunName(),cLote)
				EndIf
			Next nI
		EndIf
		//³Gera lanç. contabeis dos rateios por centro de custo sobre o arquivo SDE
	   	If cAliasI == "SD1"
			dbSelectArea("SF1")
			MsGoto(nRecno)
			If Recno() == nRecno .AND. (lVer641 .OR. lVer651)
				dbSelectArea("SD1")
				dbSetOrder(1)
				If dbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
					While !Eof() .AND. ;
						xFilial("SD1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA == SF1->F1_FILIAL+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA
						dbSelectArea("SDE")
						dbSetOrder(1)
						If dbSeek(xFilial("SDE")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_ITEM)
							While !Eof() .AND. ;
								SDE->DE_FILIAL+SDE->DE_DOC+SDE->DE_SERIE+SDE->DE_FORNECE+SDE->DE_LOJA+SDE->DE_ITEMNF == xFilial("SDE")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_ITEM
								//³ lanç contabil 641- Devolucao / Beneficiamento
								//³ lanç contabil 651- NF Entrada- Itens
								nTotalLcto	+= DetProva(nHdlPrv,IIf(lVer641,'641','651'),FunName(),cLote)
								dbSelectArea("SDE")
								dbSkip()
							End
						Endif
						dbSelectArea("SD1")
						dbSkip()
					End
				EndIf
			EndIf
		ElseIf cAliasI == "SD2"
			CTBOFFLND2(nRecno,lVer613,@nTotalLcto,FunName(),cLote)
		EndIf
		//³Finalizando lanç. contabeis
		If  lCtbil .AND. nHdlPrv > 0 .AND. nTotalLcto > 0
			SaveInter()
			RodaProva(nHdlPrv, nTotalLcto)
			If ( UsaSeqCor() )
				If cAliasC == "SF1"
					aCtbDia := {{"SF1",SF1->(RECNO()),SF1->F1_DIACTB,"F1_NODIA","F1_DIACTB"}}
					If cPaisLoc == "PER" .And. FindFunction("LxAtuAtf")
						LxAtuAtf(aRecno, @aCtbDia)
					EndIf
				ElseIf cAliasC == "SF2"
					aCtbDia := {{"SF2",SF2->(RECNO()),SF2->F2_DIACTB,"F2_NODIA","F2_DIACTB"}}
				EndIf
			Else
	    		aCtbDia := {}
			EndIF
			lLanctOk := cA100Incl(cArquivo,nHdlPrv,3,cLote,lVerCtbil,lAglutina,,If(aCfgNf[SaPergs][SlCtbEmiss],&(cAliasC+"->"+PrefixoCpo(cAliasC)+"_EMISSAO"),dDataBase ),,,,aCtbDia)
			IF FINDFUNCTION( "fValAsi" )
					lAuxCTB:=fValAsi(nRecno,aCfgNf[SaLancPadC],aCfgNf[SaLancPadI], cAliasC)
			ENDIF
			If lLanctOk .AND. (nRecno > 0) .AND. lAuxCTB
				RecLock(cAliasC,.F.)
				Replace &(cAliasC+"->"+PrefixoCpo(cAliasC)+"_DTLANC") With If(aCfgNf[SaPergs][SlCtbEmiss],&(cAliasC+"->"+PrefixoCpo(cAliasC)+"_EMISSAO"),dDataBase)
				MsUnLock()
				If lVer965 .AND. !Empty(aRecIMP) .AND. GetNewPar("MV_CUSTIMP","1") == "1"
					For nI:= 1 To Len(aRecIMP)
						SD3->(MsGoTo(aRecIMP[nI][1]))
						RecLock('SD3',.F.)
							Replace D3_DTLANC With dDataBase
						MsUnLock()
					Next
				Endif
			Endif
			RestInter()
		EndIf
	EndIf //lRet  (2)
	If lShowHelp
		HelpInDark(.T.)
	EndIf
	If lShwHlpCol
		LocxShowHelp(lSetAuto, lSetHelp, .T.)
	Endif
EndIf //lRet (1)
Return(lRet)

/*ºPrograma  ³GRAVAIMPOSTO  º Leandro C.G. ³Microsiga º Data ³  10/01/02  º±±
±±ºDesc.     ³ Efetua atualizacoes de impostos sobre uma NF    			  º±±
±±ºUso       ³ GENERICO                                                   º±±
param.
cAliasC		-	Alias de cabecalho de NF
cAliasI		- 	Alias de Itens de NF
cAliasCF	- 	Alias do Cliente ou fornec. (SA1/SA2)
nRecno 		-	Numero do registro no arquivo de cabecalho
aRecno		-	Numero dos registros nos arquivos de itens
aCpItens    -   Campos dos itens (posicoes [2] do aHeader - usar funcao HeaderCpos)
aCitens     -   Conteudo dos itens da NF (aCols)
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
lFinaliza   -   Indica se deve finalizar o MatxFis()
*/
Function GravaImposto(cAliasC,cAliasI,cAliasCF,aCpItens,aCitens,cTipDoc,nRecnoC,aRecnoI,lFinaliza)
Local cPrefix	:= IIf(!Empty(cAliasC),cAliasC+"->"+PrefixoCpo(cAliasC),"")  //Prefixo do arquivo de cabecalho
Local lRet		:= .T.														//Indica consistencia das rotinas
Local aPars		:= {}														    //Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nZ		:= 0
//Local nC		:= 0
Local nMoeda	:= 1
Local cPe74		:= LocxPE(74)
Local lTotal	:= SuperGetMV("MV_CUSDESP",.F.,.F.)
Local nPosPed	:= 0
Local nPosCF	:= 0
Local nCodPro   := 0
//Local lPedido 	:= .F.
Local aAreaSB1	:= SB1->(GetArea())
Local cFilSB1   := xFilial("SB1")
Local lProVent  := SF1->(ColumnPos("F1_PROVENT")) > 0
//³Variaveis utilizadas em sub-rotinas³
Private nValFrete	:= 0
Private nValDesc	:= 0
Private aImpS		:= {}
Private cVenda		:= "NORMAL"
Private cNFiscal	:= ""
Private cSerie		:= ""
Private l103Class	:= .F.
Private lInclui		:= .T.
Private aRecSF3		:= {}
Private Inclui		:= .T.
Private cTipo		:= cTipDoc
Private	nValNTrib	:= 0
Private	nValTara	:= 0
If ( Type("l103Auto") == "U" )
	Private l103Auto	:= lLocxAuto
EndIf

Default lFinaliza := .T.

dbSelectArea("SB1")
SB1->(dbSetOrder(1)) //B1_FILIAL + B1_COD
//³Consistindo parametros³
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"aRecnoI"	, aRecnoI	, SpEmpty						} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String		,"SA1"	,"SA2"	} )
Aadd(aPars, {"aCitens"	, aCitens	, SpEmpty						} )
Aadd(aPars, {"aCpItens"	, aCpItens	, SpEmpty						} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty						} )
Aadd(aPars, {"nRecnoC"	, nRecnoC	, SpEmpty						} )
lRet := LocxParam("GRAVAIMPOSTO",aPars)

If lRet //(1)
	//³Posicionando arquivo de cabecalho³
	&(cAliasC+"->(DbGoto("+AllTrim(Str(nRecnoC))+"))")

	//³Carregando variaveis utilizadas em sub-rotinas³
	cNFiscal := &(cPrefix+"_DOC")
	cSerie   := &(cPrefix+"_SERIE")
	cEspecie := &(cPrefix+"_ESPECIE")

	//³Inicializando variaveis para calculos de impostos
	If !MaFisFound()
		If !InicializaFis(MontaHeader(aCpItens),aCItens,cAliasC,cAliasI,cAliasCF,cTipDoc)
			lRet := .F.
		EndIf
	Endif
	If lRet //(2)
		nPosPed	:= Ascan(aHeader,{|x| Alltrim(x[2])=="D1_PEDIDO"})
		nPosCF	:= Ascan(aHeader,{|x| Alltrim(x[2])=="D1_CF"})
		nCodPro := Ascan(aHeader,{|x| Alltrim(x[2])=="D1_COD"}) //Código de Producto
		//³Executando atualizacoes de impostos para cada item
		If l103Auto .and. !lFacImport .And. !lTotal .And. (aAutoItens[1]!=Nil .And. Ascan(aAutoItens[1],{|x| Subs(x[1],4,6) $ "BASIMP|ALQIMP|VALIMP" }) > 0 )
			LxGrvAutoItem(cAliasI,aRecnoI)
	 	Else
			For nZ	:=	1	To Len(aRecnoI)
				If aRecnoI[nZ,1] # 0
					&(cAliasI+"->(DbGoTo("+AllTrim(Str(aRecnoI[nZ,1]))+"))")
					If cPaisLoc == "COL"
						xGrvImpCol(cAliasC, nPosPed, nCodPro, nPosCF, cFilSB1, aCols, nZ)
					EndIf
					RecLock(cAliasI,.F.)
						If cPaisLoc == "ARG" .And. cTipo == "D" .And. GetNewPar('MV_DESCSAI','1') =='2' .And. ALLTRIM(SF1->F1_ESPECIE) $ "RFD"
							MaFisWrite(2,cAliasI,nZ,(cAliasI $ 'SD1'),aCfgNF[SnTipo]>49)
						else
							MaFisWrite(2,cAliasI,nZ,(cAliasI $ 'SD2'),aCfgNF[SnTipo]>49)
						endif
					MsUnlock()
				Endif
			Next
        EndIf
		//³Para os remitos atualiza as referencias fiscais nao contempladas
		If aCfgNF[SnTipo] > 49 .And. cAliasC == 'SF2'
			MaFisAlt('NF_SERIENF',SF2->F2_SERIE)
			MaFisAlt('NF_UFDEST' ,SF2->F2_EST)
		ElseIf aCfgNF[SnTipo] > 49 .And. cAliasC == 'SF1'
			MaFisAlt('NF_SERIENF',SF1->F1_SERIE)
		EndIf
		//³Executando atualizacoes de impostos por cabecalho
		RecLock(cAliasC,.F.)
		nMoeda := &(cPrefix+"_MOEDA")
		If !(cPaisLoc $ "RUS|ARG")
			LocXImpNF(cAliasC)
		Endif
		MaFisWrite(2,cAliasC,,,aCfgNF[SnTipo]>49)
		If  cAliasC == 'SF2'
			(cAliasC)->F2_MOEDA := nMoeda
			If Empty((cAliasC)->F2_SEGURO)
			   (cAliasC)->F2_SEGURO := M->F2_SEGURO
			Endif
			If Empty((cAliasC)->F2_FRETE)
			   (cAliasC)->F2_FRETE := M->F2_FRETE
			Endif
			If Empty((cAliasC)->F2_DESPESA)
			   (cAliasC)->F2_DESPESA := M->F2_DESPESA
			Endif
			If Empty((cAliasC)->F2_VALBRUT)
			   (cAliasC)->F2_VALBRUT := M->F2_VALBRUT
			Endif
			If Empty((cAliasC)->F2_DESCONT)
			   (cAliasC)->F2_DESCONT := M->F2_DESCONT
			Endif
		ElseIf cAliasC == 'SF1'
			(cAliasC)->F1_MOEDA := nMoeda
			If lProVent .And. AllTrim(cEspecie) $ "NDP|NCI|NCP|NDI|RCN" .And. !Empty(cPe74)
				(cAliasC)->F1_PROVENT := MaFisRet(,"NF_PROVENT")
			EndIf
			IF cPaisloc=="ARG" .AND. lProVent 
				IF  !EMPTY(M->F1_PROVENT) .AND. ((cAliasC)->F1_PROVENT <> M->F1_PROVENT)
					(cAliasC)->F1_PROVENT :=M->F1_PROVENT
				ENDIF
			ENDIF
			If cPaisLoc == "ARG" .And. cTipo == "D" .And. GetNewPar('MV_DESCSAI','1') =='2' .And. ALLTRIM(SF1->F1_ESPECIE) $ "RFD"
				(cAliasC)->F1_VALMERC := (M->F1_VALMERC - M->F1_DESCONT)
			EndIf
		EndIf
		If FindFunction("xGrvSFARG")
			xGrvSFARG(cEspecie, cAliasC, aCfgNF)
		EndIf
		MsUnlock()
		If lFinaliza
			MaFisEnd()
		Endif
	EndIf //lRet (2)
EndIf //lRet (1)
RestArea(aAreaSB1)
Return(lRet)

/*ºPrograma  ³InicializaFis º Leandro C.G. ³Microsiga º Data ³  20020111  º±±
±±ºDesc.     ³ Efetua atualizacoes de impostos sobre uma NF  		      º±±
±±ºUso       ³ GENERICO                                                   º±±
Parametros
aH      	- aHeader
aC      	- aCols
cAliasC 	- Alias do Cabecalho da NF
cAliasI 	- Alias dos Itens da NF
cAliasCF	- Alias do cliente ou fornec. (SA1/SA2)
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
*/
Function InicializaFis(aH,aC,cAliasC,cAliasI,cAliasCF,cTipDoc,lRecalc,lVisual)
Local lRet  	:= .T.		//Indica consistencia da funcao
Local aPars		:= {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
//Local cAOri		:=	""
//Local cAval		:=	""
//Local cNfOri	:=	""
//Local nX		:=	0
Local nPosTes	:= 0
Local nPosCFO	:= 0
Local nPosCod   := 0
Local nPosItem  := 0
Local nPosQtd   := 0
Local nI		:= 0
Local cNumDesp  := ""
Local cOrigem   := ""
Local aArea 	:= {}
Local aSEU 		:= {}
Local cChaveSD1 := ""
Local aSD1 		:= {}
Local lW9Proce	:= SW9->(FieldPos("W9_PROCE")) > 0
Local lCpoPrcPAR := FindFunction("fCpoPrcPAR")
Private n 		:= 0
DEFAULT lRecalc	:=	.F.
DEFAULT lVisual	:=	.F.

//³Consistindo Parametros
Aadd(aPars, {"aH"		, aH		, SpEmpty					} )
Aadd(aPars, {"aC"		, aC		, SpEmpty					} )
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String	, "SF1"	, "SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String	, "SA1"	, "SA2"	} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty					} )
Aadd(aPars, {"lRecalc"	, lRecalc	, SpValType,	"L"		} )
lRet := LocxParam("INICIALIZAFIS",aPars)

If lRet //(1)
	//³Inicializando Varivaeis
	If lVisual .AND. cAliasI=="SD2" .AND. GetNewPar('MV_DESCSAI','1') =='2' .AND. SF2->F2_DESCONT > 0
		If cPaisLoc == "PAR" .And. lCpoPrcPAR
			fCpoPrcPAR(@aC, aH, FunName(), cAliasI, SF2->F2_MOEDA)
		Else
			nPosUni:=Ascan(aH,{|x| Alltrim(x[2])=="D2_PRCVEN"})
			nPosDes:=Ascan(aH,{|x| Alltrim(x[2])=="D2_DESCON"})
			nPosTot:=Ascan(aH,{|x| Alltrim(x[2])=="D2_TOTAL" })
			nPosQtd:=Ascan(aH,{|x| Alltrim(x[2])=="D2_QUANT" })

			For nI:= 1 To Len(aC)
				aC[nI][nPosTot]	+=	IIf(Upper(FunName())=="MATA462N" .And. SF2->F2_DESCCAB > 0,(SF2->F2_DESCCAB/Len(aC)),aC[nI][nPosDes])
				aC[nI][nPosUni]	:=	Round(aC[nI][nPosTot]/aC[nI][nPosQtd],MsDecimais(SF2->F2_MOEDA))
			Next
		EndIf
	Endif
	If lVisual .AND. cAliasI=="SD1" .AND. GetNewPar('MV_DESCSAI','1') =='2' .AND. SF1->F1_DESCONT > 0
		nPosUni:=Ascan(aH,{|x| Alltrim(x[2])=="D1_VUNIT"})
		nPosDes:=Ascan(aH,{|x| Alltrim(x[2])=="D1_VALDESC"})
		nPosTot:=Ascan(aH,{|x| Alltrim(x[2])=="D1_TOTAL" })
		nPosQtd:=Ascan(aH,{|x| Alltrim(x[2])=="D1_QUANT" })

		For nI:= 1 To Len(aC)
			aC[nI][nPosTot]	+=	IIf( Upper(FunName())=="MATA462DN" .And. SF1->F1_DESCONT > 0 .And. !(cPaisLoc $ "PER|MEX"), aC[nI][nPosDes] , 0 )
			aC[nI][nPosUni]	:=	Round( aC[nI][nPosTot] / aC[nI][nPosQtd] , MsDecimais(SF1->F1_MOEDA) )
		Next
	Endif
	MaFisIni('      ',' ',IIf(cAliasCF=="SA1","C","F"),cTipDoc,Nil,MaFisRelImp("MT100",{cAliasC,cAliasI}),,.F.,,,StrZero(aCfgNF[SnTipo],2))
	If lFacImport .AND. (l103Class .OR. (l103Visual .AND. Empty(SF1->F1_STATUS)))
		nPosTes:=Ascan(aH,{|x| Alltrim(x[2])=="D1_TES"})
		nPosCFO:=Ascan(aH,{|x| Alltrim(x[2])=="D1_CF"})
		nPosCod:=Ascan(aH,{|x| Alltrim(x[2])=="D1_COD"})
		nPosItem:=Ascan(aH,{|x| Alltrim(x[2])=="D1_ITEM"})
		nPosNumDesp:=Ascan(aH,{|x| Alltrim(x[2])=="D1_NUMDESP"})
		nPosOrigem :=Ascan(aH,{|x| Alltrim(x[2])=="D1_ORIGEM"})
		If SF1->F1_TIPO_NF $ "5678"
			aSD1:=SD1->(GetArea())
			cChaveSD1:=xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA
			nI:=0
			If SD1->(DbSeek(cChaveSD1))
				While (SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA)==cChaveSD1
					If SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC))
						If !Empty(SYD->YD_TES)
							If SF4->(MSSeek(xFilial("SF4")+SYD->YD_TES))
								SW6->(DbSetOrder(1))
								If SW6->(MsSeek(xFilial("SW6")+SF1->F1_HAWB)) .AND. (nPosNumDesp > 0)
	                            	cNumDesp := SW6->W6_DI_NUM
	                            EndIf
	                            SW9->(DbSetOrder(3))
								If SW9->(MsSeek(xFilial("SW9")+SF1->F1_HAWB)) .AND. (nPosOrigem > 0)
	                            	cOrigem := Iif(lW9Proce,SW9->W9_PROCE,"")
								EndIf
								nI:=Ascan(aC,{|x| Alltrim(x[nPosCod])==Alltrim(SD1->D1_COD) .AND. x[nPosItem]==SD1->D1_ITEM})
								If nI>0
									If Empty(aC[nI,nPosTes])
										aC[nI,nPosTes]:=SF4->F4_CODIGO
										aC[nI,nPosCFO]:=SF4->F4_CF
										cPe	:=	LocxPE(40)
										If !Empty(cPe)
											aC[nI,nPosTes] := Execblock(cPE,.F.,.F.)
											aC[nI,nPosCFO]:=SF4->F4_CF
										EndIf
									Endif
									If nPosNumDesp > 0
										aC[nI,nPosNumDesp]:= cNumDesp
									EndIf
									If nPosOrigem > 0
										aC[nI,nPosOrigem] := cOrigem
									EndIf
								Endif
							EndIf
			 			Endif
					Endif
					SD1->(DbSkip())
				End
				SD1->(RestArea(aSD1))
			Endif
		Else
			If SF1->F1_TIPO_NF=="9"
				If SuperGetMV("MV_DESPSD1",,"N")=="S"
					For nI:=1 to Len(aC)
						If SD1->(DbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aC[nI][2]+aC[nI][1]))
							SF4->(DbSetOrder(1))
							SF4->(DbSeek(xFilial("SF4")+SD1->D1_TESDES))
							aC[nI,nPosTes]:=SD1->D1_TESDES
							aC[nI,nPosCFO]:=SF4->F4_CF
						Endif
					Next
					LocxInsDes(aH,aC)
				Endif
			Else
				SW6->(DbSetOrder(1))
				If SW6->(MsSeek(xFilial("SW6")+SF1->F1_HAWB)) .AND. (nPosNumDesp > 0)
					cNumDesp := SW6->W6_DI_NUM
				EndIf
				SW9->(DbSetOrder(3))
				If SW9->(MsSeek(xFilial("SW9")+SF1->F1_HAWB)) .AND. (nPosOrigem > 0)
					cOrigem := Iif(lW9Proce,SW9->W9_PROCE,"")
				EndIf
				If SuperGetMV("MV_DESPSD1",,"N")=="S"
					If SD1->(FieldPos("D1_TESDES")) > 0
						SD1->(DbSetOrder(1))
						For nI:=1 to Len(aC)
							If SD1->(DbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aC[nI][2]+aC[nI][1]))
								SF4->(DbSetOrder(1))
								SF4->(DbSeek(xFilial("SF4")+SD1->D1_TESDES))
								aC[nI,nPosTes]:=SD1->D1_TESDES
								aC[nI,nPosCFO]:=SF4->F4_CF
								cPe	:=	LocxPE(40)
								If !Empty(cPe)
									aC[nI,nPosTes] := Execblock(cPE,.F.,.F.)
									aC[nI,nPosCFO]:=SF4->F4_CF
								EndIf
								If nPosNumDesp > 0
									aC[nI,nPosNumDesp]:= cNumDesp
								EndIf
								If nPosOrigem > 0
									aC[nI,nPosOrigem] := cOrigem
								EndIf
							EndIf
						Next nI
					Else
						cFilSWW:=xFilial("SWW")
						nI:=0
						If SWW->(MsSeek(cFilSWW+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
							While ! SWW->(EOF()).AND.SWW->WW_FILIAL==cFilSWW .AND.;
								SWW->WW_NF_COMP == SF1->F1_DOC     .AND.;
								SWW->WW_SE_NFC  == SF1->F1_SERIE   .AND.;
								SWW->WW_FORNECE == SF1->F1_FORNECE .AND.;
								SWW->WW_LOJA    == SF1->F1_LOJA
								SWD->(DbSetOrder(3))
								If SWD->(DbSeek(xFilial("SWD")+Left(SWW->WW_DESPESA,3)+SWW->WW_NF_COMP+SWW->WW_HAWB))
									For nI:=1 to Len(aC)
										SYB->(DbSetOrder(1))
										If SYB->(MSSeek(xFilial("SYB")+SWD->WD_DESPESA))
											If aC[nI,nPosCod] == SYB->YB_COD_I
												SF4->(DbSetOrder(1))
												SF4->(DbSeek(xFilial("SF4")+SWD->WD_TES))
												aC[nI,nPosTes]:=SWD->WD_TES
												aC[nI,nPosCFO]:=SF4->F4_CF
											Endif
										EndIf
										If nPosNumDesp > 0
											aC[nI,nPosNumDesp]:= cNumDesp
										EndIf
										If nPosOrigem > 0
											aC[nI,nPosOrigem] := cOrigem
										EndIf
									Next nI
								Endif
								SWW->(DbSkip())
							End
						Endif
					EndIf
				Else
					SD1->(DbSetOrder(1))
					SF4->(DbSetOrder(1))
					For nI:=1 to Len(aC)
						If SD1->(DbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aC[nI][2]+aC[nI][1]))
							SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC))
							SF4->(DbSeek(xFilial("SF4")+SYD->YD_TES))
							aC[nI,nPosTes]:=SYD->YD_TES
							aC[nI,nPosCFO]:=SF4->F4_CF
							cPe	:=	LocxPE(40)
							If !Empty(cPe)
								aC[nI,nPosTes] := Execblock(cPE,.F.,.F.)
								aC[nI,nPosCFO]:=SF4->F4_CF
							EndIf
							If nPosNumDesp > 0
								aC[nI,nPosNumDesp]:= cNumDesp
							EndIf
							If nPosOrigem > 0
								aC[nI,nPosOrigem] := cOrigem
							EndIf
						EndIf
					Next nI
				EndIf
			EndIf
		EndIf
		MaColsToFis(aH,aC,,"MT100",lRecalc,lVisual)
		If Type("oGetDados")=="O"
			oGetDados:nMax:=Len(aC)
		EndIf
	Else
		If FunName() == "MATA468N"   //Atualizar os dados da matxfis quando a execucao for por programas externos
			MaColsToFis(aH,aC,,"MT100",lRecalc,lVisual)
		Endif
	Endif
	If lFacImport
		MaFisAlt('NF_SERIENF',cSerie) //Forzar a serie na MATXFIS paar que seja gravado corretamente
		If SF1->F1_TIPO_NF$"9"
			MaFisAlt('NF_FRETE',0)
			MaFisAlt('NF_SEGURO',0)
			MaFisAlt('NF_DESPESA',SF1->F1_DESPESA)
			MaFisAlt('NF_DESCONTO',SF1->F1_DESCONT)
		ElseIf SF1->F1_TIPO_NF $ "AB"
			MaFisAlt('NF_DESPESA',0)
		Else
			MaFisAlt('NF_DESPESA',0)
			MaFisAlt('NF_FRETE',0)
		Endif
		Eval(bDoRefresh)
	Else
		If SF1->F1_TIPODOC=="10"
			If SIX->(DbSeek("SEU7"))
				aArea:=GetArea()
				DbSelectArea("SEU")
				aSEU:=GetArea()
				DbSetOrder(7)
				If DbSeek(xFilial("SEU")+SF1->F1_FORNECE+SF1->F1_LOJA+Padr(SF1->F1_DOC,Len(EU_NRCOMP))+SF1->F1_SERIE)
					If Type("CCXCAIXA")<>"U"
						cCxCaixa:=SEU->EU_CAIXA
					Endif
					If Type("NCXVALOR")<>"U"
						nCxValor:=SEU->EU_VALOR
					Endif
					If Type("CCXBENEF")<>"U"
						cCxBenef:=SEU->EU_BENEF
					Endif
					If Type("CCXHISTOR")<>"U"
						cCxHistor:=SEU->EU_HISTOR
					Endif
					If Type("CCXADIAN")<>"U"
						cCxAdian:=SEU->EU_NROADIA
					Endif
					If Type("CCXRENDIC")<>"U"
						cCxRendic:=SEU->EU_NRREND
					Endif
				Endif
				RestArea(aSEU)
				RestArea(aArea)
			Endif
		Endif
	Endif
EndIf //lRet (1)
Return(lRet)

/*ºPrograma  ³BUSCAIDENTB6  º Leandro C.G. ³Microsiga º Data ³  16/01/02  º±±
±±ºDesc.     ³ Busca o campo XX_IDENB6 na Nota Original para uma Devolucaoº±±
±±ºUso       ³ GENERICO                                                   º±±
Parametros
cAliasI - Alias do Item da NF de Devolucao
Obs.: Campos referentes ao Alias devem estar declarados em variaveis de memoria
*/
Function BuscaIdentB6(cAliasI)
Local cIdentB6 := "" 																	//Codigo sequencial no arquivo SB6
Local cAliasO  := IIf(!Empty(cAliasI),IIf(cAliasI=="SD1","SD2","SD1"),"")				//Alias do item da Nota de Origem
Local cPref		:= IIf(!Empty(cAliasI),"M->"+PrefixoCpo(cAliasI),"")
Local cCF		:= IIf(!Empty(cAliasI),IIf(cAliasI=="SD1","_FORNECE","_CLIENTE"),"")	//Complemento dos campos de acordo com cliente ou fornec. para nota de devolucao
Local cCFo		:= IIf(!Empty(cAliasI),IIf(cAliasI=="SD1","_CLIENTE","_FORNECE"),"")	//Complemento dos campos de acordo com cliente ou fornec. para nota de origem
Local cNfOri,cSeriOri,cItOri,cCliFor,cCod,cLoja  										//Conteudo de Campos para posicioanr a Nota Original

//³Verifica se o TES e de Devolucao³
If !Empty(cAliasI) .AND. (cAliasI == "SD1" .OR. cAliasI == "SD2") .AND.;
	Posicione('SF4',1,xFilial('SF4')+&(cPref+"_TES"),'F4_PODER3') == "D"

	//³Montando campos necessarios para chave de posicionamento da nota original³
    cNfori 		:= &(cPref+"_NFORI") 	+ Space(TamSX3(PrefixoCpo(cAliasO)+"_DOC")[1]-Len(&(cPref+"_NFORI")))
    cSeriOri 	:= &(cPref+"_SERIORI") 	+ Space(TamSX3(PrefixoCpo(cAliasO)+"_SERIE")[1]-Len(&(cPref+"_SERIORI")))
	cCliFor     := &(cPref+cCF) 		+ Space(TamSX3(PrefixoCpo(cAliasO)+cCFo)[1]-Len(&(cPref+cCF)))
	cLoja 		:= &(cPref+"_LOJA")	  	+ Space(TamSX3(PrefixoCpo(cAliasO)+"_LOJA")[1]-Len(&(cPref+"_LOJA")))
	cCod 		:= &(cPref+"_COD")		+ Space(TamSX3(PrefixoCpo(cAliasO)+"_COD")[1]-Len(&(cPref+"_COD")))
	cItOri 		:= &(cPref+"_ITEMORI")	+ Space(TamSX3(PrefixoCpo(cAliasO)+"_ITEM")[1]-Len(&(cPref+"_ITEMORI")))

	//³Posicionando a Nota Original³
	&( cAliasO + "->(DBSetOrder(" + IIf(cAliasO=="SD1","1","3") + "))" )
	If &(cAliasO+"->(MSSeek('"+xFilial(cAliasO)+cNfOri+cSeriOri+cCliFor+cLoja+cCod+cItOri+"',.F.))")
		cIdentB6 := &(cAliasO+"->"+PrefixoCpo(cAliasO)+"_IDENTB6")
	EndIf
EndIf
Return(cIdentB6)

/*
±±ºPrograma  ³CARREGABOTOES ºLeandro C.G.  ³Microsiga º Data ³  05/02/02  º±±
±±ºDesc.     ³Cria os botoes necessarios para a tela de acordo com o tipo º±±
±±º			 ³de NF junto as suas respectivas funcoes		  			  º±±
±±ºUso       ³MONTACFGNF                                                  º±±
*/
Function CarregaBotoes(nTipo)
Local bPMSDlgNF	:= {|| PmsVldNf() }
Local aRet		:= {}
Local lRet      := .F.
Local lIsRemito := .F.
Local cTipDoc   := ""
Local aBtnDocOri:= {}	// Botoes para documento de origem
Local nEscAvs			// Retorno do Aviso
Local aBtnDOChi := {} //Botones para documento origen Chile
Local nChiOp // Regreso de aviso Chile
Local nAuxBtn   := 0
Local cFunName	:= Iif(Type("cFunName")== "U",Upper(AllTrim(FunName())), cFunName)

Default nTipo   := 0

// Verifica se o documento e um remito
lIsRemito := IsRemito(1,"'"+StrZero(nTipo,2)+"'")

Do Case
	//³Botoes para Notas de Entrada quando nao for devolucao³
	Case StrZero(nTipo,2) $ "10|60"
		AAdd(aRet ,	{'PEDIDO'		,{|| lReajuste:=.T.,LxA103ForF4(Nil,lIsRemito,nTipo),ModxAtuObj()}	,STR0077,STR0214,"3"	})	//'Pedidos de Compras [F5]' ## "Ped Comp"
		AAdd(aRet ,	{'PEDIDO'		,{|| lReajuste:=.T.,LxA103ItemPC(,,nTipo),ModxAtuObj()}	,STR0078,STR0215,"3"	})	 			//'Pedidos de Compras( por item ) [F6]'##"Item PC"
		AAdd(aRet , {'RECALC'		,{|| lConsLoja:=!Empty(cLoja),LxA103NFORI()}		,STR0085,STR0216,"3"	})				//'NF Original ( Devolucao/Beneficiamento ) [F7]'
		If SuperGetMV("MV_PRNFBEN",.F.,.F.)
			SF5->(dbSetOrder(1))
			If SF5->(MsSeek(xFilial("SF5")+GetMV("MV_TMPAD")))
				AAdd(aRet , {'RECALC'		,{|| lConsLoja:=!Empty(cLoja),ARetBenef()}, STR0337,STR0338,"3"	}) //'Retorno de Beneficiamento  [F7]#Retorno Ben.'
			EndIf
		EndIf
		If StrZero(nTipo,2) $ "10"
			AAdd(aRet , {'AUTOM'	,{|| nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,IIF(cPaisLoc == "CHI",STR0333,Substr(GetDescRem(),1))}),;
					lRet:=IIf(nAviso==1,SCMToNF(),Iif(nAviso==2,SCMToRem(),.F.))} ,GetDescRem()+' <F8>',Substr(GetDescRem(),1) ,"3"	})  //'Remitos [F8]'
		Endif

		AAdd(aRet ,	{'S4WB013N'		,{|| MontaRATCC()},STR0080,STR0218,""	}) 				//'Rateio por Centro de Custo [F9]'##"Rateio"
		AAdd(aRet ,	{'BMPVISUAL'	,{|| LocxTrack()} ,OemToAnsi(STR0213),STR0220,"2"})	//System Tracker

		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'		,{|| Eval(bPmsDlgNF)}									,STR0083,STR0219,"" }) //'Gerenciamento de Projetos [F10]'##"Int. PMS"
		EndIf
		If cPaisLoc $ "MEX|PER" .AND. StrZero(nTipo,2) == "10"
			Aadd(aRet,{"FINIMG32",{|| LxAdianMex(M->F1_DOC, cCondicao, Eval({|aX|IIf(Len(aX)>0,aX[1][2],0)},Condicao(MaFisRet(,"NF_VALMERC"),cCondicao,0.00,dDataBase,0.00)), @aRecnoSE1, .F., M->F1_FORNECE, M->F1_LOJA, cNatureza, aHeader)},STR0263,STR0264,"3"}) //"Recebimento antecipado"##"Adiantamento"
		ElseIF	cPaisLoc == "RUS" .AND. StrZero(nTipo,2) == "10"
			Aadd(aRet,{"FINIMG32",{|| RU05XFN0U9(M->F1_DOC, cCondicao, Eval({|aX|IIf(Len(aX)>0,aX[1][2],0)},Condicao(MaFisRet(,"NF_VALMERC"),cCondicao,0.00,dDataBase,0.00)), @aRecnoSE1, .F., M->F1_FORNECE, M->F1_LOJA, cNatureza,;
						{M->F1_CONUNI,M->F1_F5QUID,M->F1_EMISSAO})},STR0263,STR0420,"3"}) //##Advances Selection
		EndIf
	Case StrZero(nTipo,2) $ "08|09|12|62|23"
		If StrZero(nTipo,2) $ "08|09|23"
	  		AAdd(aRet      ,{'CONTAINR'	,   {|| LxN466ForF6(nTipo),}	,STR0235,STR0223,"3"	}) //"Prorrateo del custo de los productos <F6>"
	  	EndIf
		If cPaisLoc == "RUS" .And. StrZero(nTipo,2) == "09"
			AAdd(aRet		,{'RECALC'		,	{|| LocXStock('2','M->D1_NFORI')	 },STR0085,STR0216,"3"	})		//"NF Original [F7]"
		EndIf
		Aadd(aRet	   ,{'S4WB013N'			,{|| MontaRATCC()}         ,STR0080,STR0218,""	}) //'Rateio por Centro de Custo [F9]'##"Rateio"
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'		,{|| Eval(bPmsDlgNF)}	,STR0083,STR0219,""   	}) //'Gerenciamento de Projetos [F10]'
		EndIf
	//³Botoes para Notas de Entrada quando for devolucao³
	Case StrZero(nTipo,2) $ "04|05|51|53"
      If  !(StrZero(nTipo,2) $ '51/53')
			AAdd(aRet , {'AUTOM'			,{|| 	nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,Substr(GetDescRem(),1)}),;
											  			lRet:=IIf(nAviso==1,SCMToNF(),Iif(nAviso==2,SCMToRem(),.F.))},;
														GetDescRem()+STR0088,Substr(GetDescRem(),1),"3"	})  //'Remitos [F6]'
      Endif
   		aBtnDocOri := {STR0007,IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(1),STR0223),STR0320}//"Item"#"Facturas"#Pedido
		If cPaisLoc == "CHI" .And. (StrZero(nTipo,2) == "04")
			aBtnDOChi := {STR0124, STR0223} //Nota de Debito # Facturas
			Aadd(aRet, {'RECALC',;
				{|| lConsLoja:=!Empty(cLoja),;
					(If((nChiOp := Aviso(STR0113, STR0005 + " " + STR0124 + " o " + STR0223 + "?", aBtnDOChi)) == 1,; //Selecciona # Nota de Debito # Facturas
					LxDocOri(.T.),;
					If((nEscAvs := Aviso(IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223), STR0005 + " " + IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223) + "?", aBtnDocOri)) == 2, Processa({||LxDocOri()}, STR0241), Iif(nEscAvs == 1, LxA103NFORI(), LxNFOrig("P", SAliasHead, StrZero(nTipo, 2))))));
				},STR0085, STR0216, "3"}) //'NF Original ( Devolucao/Beneficiamento ) [F7]'
		Else
			Aadd(aRet	   ,{'RECALC'		,{|| lConsLoja:=!Empty(cLoja),If((nEscAvs := Aviso(IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223),STR0005+" "+IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223)+"?",aBtnDocOri))==2,Processa({|| LxDocOri()},STR0241),Iif(nEscAvs == 1,LxA103NFORI(),LxNFOrig("P",SAliasHead,StrZero(nTipo,2))))},STR0085,STR0216,"3"	}) //'NF Original ( Devolucao/Beneficiamento ) [F7]'
		EndIf
  		Aadd(aRet	   ,{'BMPINCLUIR'	,{|| A103LoteF4()}												,STR0086,STR0221,"3"	}) //'Lotes Disponiveis [F8]'
		Aadd(aRet	   ,{'S4WB013N'	,{|| MontaRATCC()}                 							,STR0080,STR0218,""	}) //'Rateio por Centro de Custo [F9]'
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'	,{|| Eval(bPmsDlgNF)}										,STR0083,STR0219,""	})	 //'Gerenciamento de Projetos [F10]'
		EndIf
	//³Botoes para Notas de Saida quando nao for Devolucao³
	Case StrZero(nTipo,2) $ "01|02|03|11|50|52|54|17|18|19|21"
		cTipDoc := IIf(StrZero(nTipo,2)$"01|17|18|19|21","N",IIf(StrZero(nTipo,2)$"02|03","C","B"))
		AAdd(aRet		,{'RECALC'		, 	{|| LocxStock('1',"M->D2_QUANT") },STR0122,STR0222,"3"	})		//Consulta ao Estoque [F4]
		If cPaisLoc == "AUS" .AND. StrZero(nTipo,2) $ "02|03"
			Aadd(aRet	    ,{'BMPINCLUIR'	,{|| LxNFOrig(IIf(Aviso(STR0005,STR0319,{STR0320,STR0321})==1,"P","NF"),SAliasHead,StrZero(nTipo,2))},STR0085,STR0216,"3"}) //Selecciona#"Escolha a Maneira de Pesquisar o Documento de Origem"#Pedido#Vendas
		EndIf
		If cPaisLoc == "RUS" .And. StrZero(nTipo,2) $ "02"
			aBtnDocOri := {STR0007,STR0223,STR0320}//"Item"#"Facturas"#Pedido
			Aadd(aRet	   ,{'RECALC'		,{|| lConsLoja:=!Empty(cLoja),;
									If((nEscAvs := Aviso(STR0223,STR0005+" "+STR0223+"?",aBtnDocOri))==2,;
									Processa({|| RU05X0002_OriDoc(aCfgNF[SAliasHead],nTipo)},STR0241),Iif(nEscAvs == 1,LxA103NFORI(),LxNFOrig("P",SAliasHead,StrZero(nTipo,2))))},STR0085,STR0216,"3"	}) //'NF Original ( Devolucao/Beneficiamento ) [F7]'
		EndIf
		If StrZero(nTipo,2) $ "02" .And. !(cPaisLoc $ "PAR|RUS") .And. Findfunction("LDocOriSd") .and. Findfunction("ARGNFORIDB")
			aBtnDocOri := IIF (cFunName == "FINA096",{STR0223},{STR0007,STR0223})//"Item"#"Facturas"
			IIF (cFunName == "FINA096",nAuxBtn :=1,nAuxBtn :=2)
			Aadd(aRet   ,{'RECALC' ,{|| If((nEscAvs := Aviso(STR0223,STR0005+" "+STR0223+"?",aBtnDocOri))==nAuxBtn,Processa({|| LDocOriSd()},STR0241),ARGNFORIDB())},STR0085,STR0216,"3" }) //'NF Original
		Endif
		If StrZero(nTipo,2) $ "02" .and. cPaisLoc == "PAR" .And. Findfunction("DocOriPAR")
			Aadd(aRet   ,{'RECALC' ,{|| Processa({|| DocOriPAR()},STR0241)},STR0085,STR0216,"3" }) //'NF Original
		EndIf
		//O processo de Recebimento Antecipado estará disponivel
		//apenas para TOP no Financeiro.
		If cPaisLoc == "ANG" .AND. StrZero(nTipo,2)=="01"
			Aadd(aRet,{"FINIMG32",{|| A410Adiant(M->F2_DOC, cCondicao, Eval({||IIf(Len(aDupl)>0,DesTrans(Extrae(aDupl[1],5)),0)}), @aRecnoSE1, .F., M->F2_CLIENTE, M->F2_LOJA, NIL,NIL,NIL,NIL,cNatureza)},STR0263,STR0264,"3"}) //"Recebimento antecipado"##"Adiantamento"
		ElseIf cPaisLoc $ "MEX|PER" .AND. StrZero(nTipo,2) $ "01|21"
			If StrZero(nTipo,2) == "01"
				Aadd(aRet,{"FINIMG32",{|| LxAdianMex(M->F2_DOC, cCondicao, Eval({|aX|IIf(Len(aX)>0,aX[1][2],0)},Condicao(MaFisRet(,"NF_VALMERC"),cCondicao,0.00,dDataBase,0.00)), @aRecnoSE1, .F., M->F2_CLIENTE, M->F2_LOJA, cNatureza, aHeader)},STR0263,STR0264,"3"}) //"Recebimento antecipado"##"Adiantamento"
			EndIf
			If cPaisLoc == "MEX" .And. (StrZero(nTipo,2)=="01" .Or. StrZero(nTipo,2)=="21") .And. FindFunction("LxCartaPor") .And. SF2->(ColumnPos("F2_TPCOMPL")) > 0
				Aadd(aRet,{"CARTAPORTE", {|| LxCartaPor("SF2",M->F2_FILIAL,M->F2_DOC,M->F2_SERIE,M->F2_ESPECIE,M->F2_TPCOMPL=='S',.F.) },STR0437,STR0438,"3"}) //"Carta Porte FE" //"Carta Porte"
				IIF( (StrZero(nTipo,2)=="01" .Or. StrZero(nTipo,2)=="21") .And. FindFunction("LxMxPFact"),Aadd(aRet,{"FACTURAS", {||LxMxPFact() },STR0445,STR0445,"3"}),"") // "Facturas" ## "Facturas")
			EndIf
		ElseIf cPaisLoc $ "EQU" .AND. StrZero(nTipo,2)=="01" .AND. FindFunction("MATA488") .AND. SF2->(FieldPos("F2_TPDOC")) > 0
			Aadd(aRet,{"REEMBOLSO", {|| MATA488(M->F2_DOC, M->F2_SERIE, M->F2_CLIENTE, M->F2_LOJA,M->F2_TPDOC,M->F2_TPVENT,M->F2_TIPOPE,M->F2_NATUREZ) },STR0441,STR0441,"3"}) //"Reembolso"##"Reembolso"
		ElseIf cPaisLoc == "RUS" .And. StrZero(nTipo,2) == "01"
			Aadd(aRet,{"FINIMG32",{|| RU05XFN0U9(M->F2_DOC, cCondicao, MaFisRet(,"NF_BASEDUP"), @aRecnoSE1, .F., M->F2_CLIENTE, M->F2_LOJA, cNatureza,{M->F2_CONUNI,M->F2_F5QUID,M->F2_DTSAIDA})},STR0263,STR0420,"3"}) //"Recebimento antecipado"##"Adiantamento RU05XFN0U9_LxAdianRus"
		EndIf
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'	,{|| Eval(bPmsDlgNF)}										,STR0083,STR0219,""	})	 //'Gerenciamento de Projetos [F10]'
		EndIf
	//³Botoes para Notas de SAIDA   que sejam devolucoes³
	Case StrZero(nTipo,2) $ "06|07|61|22"
		AAdd(aRet		,{'PLNPROP'		,	{|| LocXStock('2','M->D2_QUANT')	 },STR0122,STR0222,"3"	})		//Consulta ao Estoque [F4]
		If StrZero(nTipo,2) $ "06/07/22"
	  		AAdd(aRet       ,{'CONTAINR'	,   {|| LxN466ForF6(nTipo),}	,STR0235,STR0223,"3"	}) //"Prorrateo del custo de los productos <F6>"
		EndIf
		AAdd(aRet		,{'RECALC'		,	{|| LocXStock('2','M->D2_NFORI')	 },STR0085,STR0216,"3"	})		//"NF Original [F7]"

		If StrZero(nTipo,2) $ "06/07"
			AAdd(aRet	,{'AUTOM'		,{|| 	nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,Substr(GetDescRem(),1)}),;
									  			lRet:=IIf(nAviso==1,SCMToNF2(),Iif(nAviso==2,SCMToRem2(),.F.))},;
												GetDescRem()+" <F9>",Substr(GetDescRem(),1),"3"	})  //'Remitos [F9]'
		EndIf
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'	,{|| Eval(bPmsDlgNF)}										,STR0083,STR0219,""	})	 //'Gerenciamento de Projetos [F10]'
		EndIf
	Case StrZero(nTipo,2) $ "13"
		AAdd(aRet ,	{'CONTAINR'		,{|| LocXNfDesp(2)	}	,STR0141+STR0087,STR0223,"3"	}) //'Facturas de entrada [F4]'
		Aadd(aRet ,	{'S4WB013N'		,{|| MontaRATCC()	}	,STR0080,STR0218,""	}) //'Rateio por Centro de Custo [F9]'
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'		,{|| Eval(bPmsDlgNF)}									,STR0083,STR0219	}) //'Gerenciamento de Projetos [F10]'
		EndIf
	Case StrZero(nTipo,2) $ "14"
		AAdd(aRet ,	{'CONTAINR'		,{|| LocXNfDesp(1)	}	,STR0141+STR0087,STR0223,"3"	}) //'Facturas de entrada [F4]'
		Aadd(aRet ,	{'S4WB013N'		,{|| MontaRATCC()	}	,STR0080,STR0218,""	}) //'Rateio por Centro de Custo [F9]'
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'		,{|| Eval(bPmsDlgNF)}							,STR0083,STR0219	}) //'Gerenciamento de Projetos [F10]'
		EndIf
	//³Botoes para Recibo de servicos³
	Case StrZero(nTipo,2) $ "15"
		Aadd(aRet	   ,{'S4WB013N'	,{|| MontaRATCC()}                 					,STR0080,""	}) //'Rateio por Centro de Custo [F9]'
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'		,{|| Eval(bPmsDlgNF)}									,STR0083,"" }) //'Gerenciamento de Projetos [F10]'
		EndIf
	//³Botoes para Retorno simbolico(CONSIGNACAO)³
	Case StrZero(nTipo,2) $ "63"
		Aadd(aRet	   ,{'RECALC'		,{|| lConsLoja:=!Empty(cLoja),LxA103NFORI()}			,STR0085,STR0216,"3"	}) //'NF Original ( Devolucao/Beneficiamento ) [F7]'
  		Aadd(aRet	   ,{'BMPINCLUIR'	,{|| A103LoteF4()}											,STR0086,STR0221,"3"	}) //'Lotes Disponiveis [F8]'
	//³Botoes para Entrada transf. ³
	Case StrZero(nTipo,2) $ "64"
		Aadd(aRet	   ,{'RECALC'		,{|| NfTrfOri(M->F1_FILORIG) }		,DESCREM+STR0166,STR0217,"3"	}) //
	//³Guia de Remessa / Guia de Remessa-Cancelada
	Case StrZero(nTipo,2) $ "65"
		AAdd(aRet ,	{'PEDIDO'		,{|| lReajuste:=.T.,LxA103ForF4(Nil,lIsRemito),ModxAtuObj()}	,STR0077,STR0214,"3"	})	//'Pedidos de Compras [F5]' ## "Ped Comp"
		AAdd(aRet ,	{'PEDIDO'		,{|| lReajuste:=.T.,LxA103ItemPC()}					,STR0078,STR0215,"3"	})	 		//'Pedidos de Compras( por item ) [F6]'##"Item PC"
EndCase
Return(aRet)

/*
±±ºPrograma  ³CARREGATECLAS ºLeandro C.G.  ³Microsiga º Data ³  05/02/02  º±±
±±ºDesc.     ³Define todas as teclas com suas respectivas funcoes de 	  º±±
±±º			 ³acordo com o tipo de NF									  º±±
±±ºUso       ³MONTACFGNF                                                  º±±
Parametros: nTipo    - tipo de NF
*/
Function CarregaTeclas(nTipo)
Local bPMSDlgNF	:= {|| PmsVldNf() }
Local aRet		:= {}
Local bTeclaF4	:= {|| NIL } 			//Bloco de codigo para tecla F4
Local aBtnDocOri:= {}
Local lIsRemito := .F.
Local nEscAvs
Local aBtnDOChi := {} //Botones para documento origen Chile
Local nChiOp // Regreso de aviso Chile

Default nTipo   := 0

// Verifica se o documento e um remito
lIsRemito := IsRemito(1,"'"+StrZero(nTipo,2)+"'")

Do Case
	//³Teclas para Notas de Entrada que nao sejam devolucoes³
	Case StrZero(nTipo,2) $ "08/09/10/12/60/23"
		cPe	:=	LocxPE(19)
		bTeclaF4 := IIf(!Empty(cPE),{ || ExecBlock(cPE,.F.,.F.)},{|| A103F4()})
		If StrZero(nTipo,2) $ "08/09/23"
	   	   	AAdd(aRet 		,{VK_F6     ,{|| LxN466ForF6(nTipo) },"3"	}) //'NF de Credito/Debito NCI/NDP [F6]'
	   	EndIf
		If StrZero(nTipo,2) $ "10/60"
			AAdd(aRet		,{VK_F4		, bTeclaF4                  ,"3"})						//Consulta de Pedidos de Compra em Aberto
			AAdd(aRet		,{VK_F5		,{|| LxA103ForF4(Nil,lIsRemito,nTipo)} ,"3"})			//Pedido de compra
			AAdd(aRet		,{VK_F6		,{|| LxA103ItemPC(,,nTipo) 			} ,"3"})			//Pedido de Compra por Item
			AAdd(aRet 		,{VK_F7		,{|| lConsLoja:=!Empty(cLoja),LxA103NFORI() }	,"3"}) //'NF Original ( Devolucao/Beneficiamento )'
			If !StrZero(nTipo,2) $ "60"
		 		AAdd(aRet		,{VK_F8		,{|| nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,GetDescRem()}),;
														  lRet:=IIf(nAviso==1,SCMToNF(),Iif(nAviso==2,SCMToRem(),.F.))} ,"3"})		//'Remitos'
			Endif
		Endif
		AAdd(aRet		,{VK_F9		,{|| MontaRATCC() 			} ,""})		//Rateio por Centro de Custo
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		}})		//Gerenciamento de Projetos
		EndIf
	//³Teclas para Notas de Entrada que sejam devolucoes³
	Case StrZero(nTipo,2) $ "04|05|51|53"
		If cPaisLoc == "CHI" .And. StrZero(nTipo,2) == "04"
		  aBtnDOChi := {STR0124, STR0223} //Nota de Debito # Facturas
		  Aadd(aRet,{VK_F7 ,{|| (If((nChiOp := Aviso(STR0113, STR0005 + " " + STR0124 + " o " + STR0223 + "?", aBtnDOChi)) == 1,LxDocOri(.T.),If((nEscAvs := Aviso(IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223), STR0005 + " " + IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223) + "?", aBtnDocOri)) == 2, Processa({||LxDocOri()}, STR0241), Iif(nEscAvs == 1, LxA103NFORI(), LxNFOrig("P", SAliasHead, StrZero(nTipo, 2))))))},"3"})
		Else
			Aadd(aRet,{VK_F7 ,{|| If(Aviso(IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223),STR0005+IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223)+"?",{STR0007,IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223)})==2,Processa({|| LxDocOri()},STR0241),LxA103NFORI())},"3"})
		EndIf
		AAdd(aRet,{VK_F8 ,{|| A103LoteF4() 					} ,"3"})		//Lotes Disponiveis
		If  !(StrZero(nTipo,2) $ '51/53')
			AAdd(aRet,{VK_F6 ,{|| nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,GetDescRem()}),;
											  lRet:=IIf(nAviso==1,SCMToNF(),Iif(nAviso==2,SCMToRem(),.F.)) } ,"3"})		//'Remitos'
		Endif
		AAdd(aRet		,{VK_F9		,{|| MontaRATCC() 			} ,""})		//Rateio por Centro de Custo
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
		If IntTms()
			AAdd(aRet	,{VK_F11	,{|| A103RatVei() 		} ,"3"})		//Rateio por Veiculo/Viagem - <F11>
		EndIf
	//³Teclas para Notas de SAIDA ³
	Case StrZero(nTipo,2) $ "01|02|03|11|50|52|54|17|18|19|21"
		AAdd(aRet	,{VK_F4	,{|| LocxStock('1') },"3"})		//Consulta ao Estoque
		AAdd(aRet	,{VK_F8	,{|| LocxStock('3') },"3"})		//Consulta Lote e localiz.
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
	//³Teclas para Notas de Saida que sejam devolucoes  ³
	Case StrZero(nTipo,2) $ "06|07|61|22"
		AAdd(aRet	,{VK_F4	,{|| LocxStock('1',"M->D2_QUANT") },"3"})		//Consulta ao Estoque
		If StrZero(nTipo,2) $ "06/07/22"
	   	   	AAdd(aRet   ,{VK_F6 ,{|| LxN466ForF6(nTipo) },"3"	}) //'NF de Credito/Debito - NCP/NDI [F6]'
   	   	EndIf
		AAdd(aRet	,{VK_F7	,{|| LocXStock('2',"M->D2_NFORI") },"3"})		//NF Original
		AAdd(aRet	,{VK_F8	,{|| LocxStock('3') },"3"})		//Consulta Lote e localiz.
		If StrZero(nTipo,2) $ "06/07"
			AAdd(aRet,{VK_F9 ,{|| nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,GetDescRem()}),;
											  lRet:=IIf(nAviso==1,SCMToNF2(),Iif(nAviso==2,SCMToRem2(),.F.)) } ,"3"})		//'Remitos'
   	   	EndIf
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
	//³Teclas para Notas de DESPESAS DE IMPORTACAO      ³
	Case StrZero(nTipo,2) $ "13"
		AAdd(aRet ,	{VK_F4	,{|| LocXNfDesp(2) },"3"}) 					//'Despesas de import.'
		AAdd(aRet ,	{VK_F9	,{|| MontaRATCC() },""})		//Rateio por Centro de Custo
		If IntePms() //.AND.!IsRemito(1,"'"+StrZero(nTipo,2)+"'")
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
	//³Teclas para Notas de conhecimento de frete       ³
	Case StrZero(nTipo,2) $ "14"
		AAdd(aRet ,	{VK_F4	,{|| LocXNfDesp(1) },"3"}) 					//'Despesas de import.'
		AAdd(aRet ,	{VK_F9	,{|| MontaRATCC() },""})		//Rateio por Centro de Custo
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
	//³Botoes para Recibo de servicos                   ³
	Case StrZero(nTipo,2) $ "15"
		AAdd(aRet ,	{VK_F9	,{|| MontaRATCC() },""})		//Rateio por Centro de Custo
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
	//³Teclas para retorno simbolico (consignacao)      ³
	Case StrZero(nTipo,2) $ "63"
		AAdd(aRet,{VK_F7 ,{|| LxA103NFORI()     } ,"3"})		//Notas Orignais da Devolucao
		AAdd(aRet,{VK_F8 ,{|| A103LoteF4()    } ,"3"})		//Lotes Disponiveis
	Case StrZero(nTipo,2) $ "64"
		Aadd(aRet	   ,{VK_F4		,{|| NfTrfOri(M->F1_FILORIG) } ,"3" }) // Remitos de transf.
EndCase

//Documento Original
If StrZero(nTipo,2) $ "04|05|51|53"
	aBtnDocOri := {STR0007,IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(1),STR0223),STR0320}//"Item"#"Facturas",Pedido
	If cPaisLoc == "CHI" .And. StrZero(nTipo,2) == "04"
		aBtnDOChi := {STR0124, STR0223} //Nota de Debito # Facturas
		Aadd(aRet,{VK_F7 ,{|| lConsLoja:=!Empty(cLoja),(If((nChiOp := Aviso(STR0113, STR0005 + " " + STR0124 + " o " + STR0223 + "?", aBtnDOChi)) == 1,LxDocOri(.T.),If((nEscAvs := Aviso(IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223), STR0005 + " " + IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223) + "?", aBtnDocOri)) == 2, Processa({||LxDocOri()}, STR0241), Iif(nEscAvs == 1, LxA103NFORI(), LxNFOrig("P", SAliasHead, StrZero(nTipo, 2))))))},"3"})
	Else
		Aadd(aRet,{VK_F7 ,{|| lConsLoja:=!Empty(cLoja),If((nEscAvs := Aviso(IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223),STR0005+" "+IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223)+"?",aBtnDocOri))==2,Processa({|| LxDocOri()},STR0241),Iif(nEscAvs == 1,LxA103NFORI(),LxNFOrig("P",SAliasHead,StrZero(nTipo,2))))},"3"})
	EndIf
EndIf
Return aRet

/*
±±ºPrograma  ³CarregaAtualizaº ³Microsiga º Data ³  21/01/02  º±±

*/
Function CarregaAtualiza(nTipo,lTela)
Local aRet:=Array(SnMaxAtua)
If nTipo < 50 //Notas fiscais
	aRet[SlCtbilOL]:= .T.//lTela
	aRet[SlAtuEstq]:= .T.
	aRet[SlAtuFina]:= .T.
	aRet[SlAtuImp] := .T.
	aRet[SlAtuLF]  := .T.
	aRet[SlConsist]:= !(lTela)
Else //Remitos
	aRet[SlCtbilOL]:= .T.//lTela
	aRet[SlAtuEstq]:= .T.
	aRet[SlAtuFina]:= IIf(cPaisLoc == "EUA", .T., .F.) //Ajuste para permitir generacion de financiero provisional de remito
	aRet[SlAtuImp] := .F.
	aRet[SlAtuLF]  := .F.
	aRet[SlConsist]:= !(lTela)
Endif
Return(aRet)

/*
±±ºPrograma  ³NFRATEIOCC    º Leandro C.G. ³Microsiga º Data ³  21/01/02  º±±
±±ºDesc.     ³Grava rateios por centro de custo para um item de uma NF    º±±
±±ºUso       ³ GENERICO	                                                  º±±
Parametros
aRatCC		- array com os rateios de cada item
			  [1] - Item da NF
			  [2] - Itens de Rateios por centro de custo
nOpc		- indicador inclusao ou exclusao -- Default 1
  			  (1) - inclusao
  			  (2) - exclusao
aCusto		- Custo de todos os itens em todas as moedas
			  [1] - Custo moeda1
			  [2] - Custo moeda2
			  [3] - Custo moeda3
			  [4] - Custo moeda4
			  [5] - Custo moeda5
_lGeraLanc	- Indica se deve gerar lanç contabil
*/
Function NfRateioCC(aRatCC,nOpc,aCusto,nItem)
Local aArea  		:= GetArea()
//Local nI							//flag para loop's
Local aRecSDE		:= {}			//array com numero dos registros do SDE que devem ser excluidos
Local lRet			:= .T.			//Indica consistencia da funcao
Local aHeaderSDE	:= {}			//Aheader sobre o arquivo de rateios por NF
Local aPars	   		:= {}			//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Default nOpc 		:= 1


//³Esta variavel define se dentro da rotina Lxa103SD1AtuSDE, deve gerar os lanç. contabeis ou nao³
//³Neste caso, como na rotina de NF existe uma rotina que gera todos os lanç.					 ³
//³contabeis referentes a uma NF, nao pode ser gerado nenhum lanç em outra funcao     			 ³
//³Funcao que gera os lanç. contabeis : CtbilNF											 		 ³

Private lGeraLanc   := .F.


//³Consistindo Parametros³

Aadd(aPars, {"aRatCC"	, aRatCC	, SpEmpty})
lRet := LocxParam("NFRATEIOCC",aPars)
Aeval(aRatCC, { |x| Asize(x, 2) } )

If lRet //(1)

	//³ Montagem do aHeader para utilizacao na gravacao do SDE       ³

	DBSelectArea("SX3")
	DBSetOrder(1)
	MsSeek("SDE")
	While !EOF() .AND. (X3_ARQUIVO == "SDE")
		If X3uso(X3_USADO) .AND. cNivel >= X3_NIVEL
			AADD(aHeaderSDE,{ 	Trim(x3titulo())	,X3_CAMPO	,X3_PICTURE	,;
								X3_TAMANHO			,X3_DECIMAL	,X3_VALID	,;
								X3_USADO			,X3_TIPO	,X3_ARQUIVO	,;
								X3_CONTEXT 										} )
		EndIf
		DBSkip()
	End

	//³Verifica inclusao ou exclusao³

	Lxa103SD1AtuSDE(nOpc,aRatCC,aRecSDE,aHeaderSDE,aCusto)

EndIf //lRet (1)

RestArea(aArea)
Return

/*
±±ºPrograma  ³NfGravaCusto  º Leandro C.G. ³Microsiga º Data ³  21/01/02  º±±
±±ºDesc.     ³Busca custo para um item de uma NF			 		      º±±
Parametros
cAliasI		- Alias referente ao item da NF (SD1/SD2)
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
nItem		- Item da NF (n - linha do aCols) -- usado apenas quando cAliasI == "SD1"
oBS.:
Considera que os aqruivos de itens da NF e TES estao posicionados no registro correto
*/
Function NfGravaCusto(cAliasI,cTipDoc,nItem)
Local aCusto 	:= {}			//array com o custo do item nas moedas correntes
Local aEnvcus	:= {}
Local lRet 		:= .T.			//Indica consistencia da funcao
Local aPars	    := {}			//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local lTotal	:= SuperGetMV("MV_CUSDESP",.F.,.F.)
Local lParAuto:=.F.
Local lCalcCusto := .F.
Local lConoSur := (cPaisLoc $ "ARG|BOL|CHI|PAR|URU")
Local lCustoNC := FindFunction("LxCustoNC")
//- Utilizada na funcao a103Custo e precisava ser declarada,
// porém se utilizo a função MATA465N essa variavel já vem preenchida então não permite sobrescrever o valor
Private aDupl	:= Iif(Type("aDupl") <> "U", IIf(Type("aDupl") == "A" .And. (Len(aDupl)> 0),aDupl,{}) , {} )


//³Consistindo Parametros³

Aadd(aPars		, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars		, {"cTipDoc"	, cTipDoc	, SpEmpty					} )
If cAliasI == "SD1" .And. (Empty(nItem) .Or. nItem <= 0)
	Aadd(aPars	, {"nItem"		, nItem		, SpEmpty					} )
EndIf
lRet := LocxParam("NFGRAVACUSTO",aPars)
IF Type("aAutoItens") <> "U"
	IF Len(aAutoItens) > 0
		IF FunName() <> "MATA143" .and.  FunName() <> "MATA447"
			lParAuto:=.T.
		ENDIF
	ENDIF
ENDIF
If lRet //(1)

	//³Armazena o custo em todas as moedas e Grava Custo na NF ³

	If cAliasI == "SD1"
		nTaxa		:= SF1->F1_TXMOEDA
		nMoedaNF	:= SF1->F1_MOEDA
		If l103Auto .And. !lTotal .and. !lParAuto
			aCusto := {}
		Else
			aCusto := Lxa103Custo(nItem)
			If !GravaCusNF(cAliasI,aCusto)
				lRet := .F.
			EndIf
		EndIf
	Else
		nTaxa		:= SF2->F2_TXMOEDA
		nMoedaNF	:= SF2->F2_MOEDA
		If nMoedaNF <= 1
			nTaxa	:=	0
		Endif
		aEnvCus :=	{	SD2->D2_TOTAL		,;
						SD2->D2_VALIPI		,;
						SD2->D2_VALICM		,;
						SF4->F4_CREDIPI		,;
						SF4->F4_CREDICM		,;
						SD2->D2_NFORI		,;
						SD2->D2_SERIORI		,;
						SD2->D2_COD			,;
						SD2->D2_LOCAL		,;
						SD2->D2_QUANT		,;
						If(SF4->F4_IPI=='R',SD2->D2_VALIPI,0)		}

		//³Caso seja uma Nota de Credito/Debito com qtde Zerada, ³
		//|gravar somente o custo da nota.                       |
		If lConoSur .And. AllTrim(SD2->D2_ESPECIE) $ "NCP|NDI" .And. (QtdComp(SD2->D2_QUANT) == QtdComp(0) .Or. (Empty(SD2->D2_NFORI) .Or. Empty(SD2->D2_SERIORI)))
			lCalcCusto := .T.
		EndIf
		
		If (SD2->D2_TIPO == "D" .And. AllTrim(SD2->D2_ESPECIE) $ "NCP|NDI" .And. QtdComp(SD2->D2_QUANT) == QtdComp(0)) .Or. lCalcCusto
			If lCalcCusto .And. lCustoNC
				aCusto := LxCustoNC(nItem, aEnvCus)
			Else
				aCusto  := 	{	xMoeda(SD2->D2_TOTAL,nMoedaNF,1,SF2->F2_EMISSAO,,nTaxa),;
								xMoeda(SD2->D2_TOTAL,nMoedaNF,2,SF2->F2_EMISSAO,,nTaxa),;
								xMoeda(SD2->D2_TOTAL,nMoedaNF,3,SF2->F2_EMISSAO,,nTaxa),;
								xMoeda(SD2->D2_TOTAL,nMoedaNF,4,SF2->F2_EMISSAO,,nTaxa),;
								xMoeda(SD2->D2_TOTAL,nMoedaNF,5,SF2->F2_EMISSAO,,nTaxa) }
			EndIf
		Else
			aCusto  := PegaCMAtu(SD2->D2_COD,SD2->D2_LOCAL,If(SF4->F4_PODER3=="D","D",cTipDoc),aEnvCus,cTipDoc=="D")
		EndIf
		aCusto  := GravaCusD2(aCusto,If(SF4->F4_PODER3=="D","D",cTipDoc))
	EndIf

EndIf //lRet (1)
Return(aCusto)

/*
±±ºPrograma  ³ATUDIFCUSREM  º Leandro C.G. ³Microsiga º Data ³  24/01/02  º±±
±±ºDesc.     ³Quando for classificacao de remito, atualiza o custo 	      º±±
±±º			 ³original de acordo com o custo da movimentacao atual		  º±±
±±ºUso       ³ ATUSCMNF	                                                  º±±
±±ºParametros³ aCusto : Array com os custos da NF.              		  º±±
Obs.: Considera que os arquivos SF1 e SD1 do remito esta posicionado no registro correto
*/
Function AtuDifCusREM(aCusto,nQuant,nSigno,cAliasTmp)
Local nQtdMoeda := 5					//Numero de moedas utilizadas no sistemas
//Local aCM		:= Array(nQtdMoeda)		//Custo medio atualizado em todas as moedas para atualizacao do SB2
Local aCunitREM := Array(nQtdMoeda)		//Custo unitario na movimentacao original em todas as moedas
Local aValDif	:= Array(nQtdMoeda)
Local aAreaSB2  := SB2->(GetArea())
Local dData
Local lAtuCusRem:= .T.
Local nMoeda
Local nTxMoeda
local cIndex
local cChave

If cAliasTMP == Nil
	If Select("__LOCXSF1") == 0
		ChkFile("SF1",.F.,"__LOCXSF1")
	Else
		dbSelectArea("__LOCXSF1")
	Endif
	cAliasTMP	:=	"__LOCXSF1"
Endif

dbSelectArea(cAliasTmp)
cIndex := CriaTrab(Nil, .F.)
cChave := IndexKey()

IndRegua(cAliasTmp, cIndex, "F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO", , , "")

(cAliasTmp)->(DbSetOrder(1))
(cAliasTmp)->(MSSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO))

//Data da movimentacao original
dData	 := IIf(!Empty((cAliasTmp)->F1_DTDIGIT),(cAliasTmp)->F1_DTDIGIT,(cAliasTmp)->F1_EMISSAO)
//Moeda referente a movimentacao original
nMoeda   := IIf(!Empty((cAliasTmp)->F1_MOEDA).AND.(cAliasTmp)->F1_MOEDA>0,(cAliasTmp)->F1_MOEDA,1)
//Taxa da moeda da movimentacao original na data da movimentacao
nTxMoeda := IIf(nMoeda == 1 ,1,If(!Empty((cAliasTmp)->F1_TXMOEDA).AND.(cAliasTmp)->F1_TXMOEDA>0,(cAliasTmp)->F1_TXMOEDA,RecMoeda(dData,nMoeda)))

//³Buscando o custo original da movimentacao em todas as moedas³

Aeval(aCunitREM	, {|x,y| aCunitREM[y] := xMoeda(SD1->D1_CUSORI,1,y,dData,,,If(y=nMoeda,nTxMoeda,Nil)) / SD1->D1_QUANT } )

//³Verificando a diferenca do custo da movimentacao atual em relacao a movimentacao de origem³

AEval(aValDif	, {|x,y| aValDif[y] := (aCusto[y] - aCunitREM[y]) * nQuant 	} )

// Verificar se esta no periodo valido
If !(GetMV("MV_ULMES") >= dData)

	//³Ponto de Entrada p/ atualizacao do custo do remito³

	If ExistBlock( "LOCCUSREM" )
		lAtuCusRem  := ExecBlock("LOCCUSREM",.F.,.F.,{aCusto,nQuant,nSigno,cAliasTmp,aCunitREM,aValDif})
		If ValType(lAtuCusRem) <> "L"
		   lAtuCusRem := .T.
		EndIf
	EndIf
	If lAtuCusRem
		// Atualizando o valor do custo da movimentacao original
		RecLock("SD1", .F.)
		Aeval(aValDif, {|x,y| &("SD1->D1_CUSTO"+IIf(y==1,"",AllTrim(Str(y)))+" += "+AllTrim(Str(nSigno*aValDif[y])) ) } )
		MsUnlock()
		DbSelectArea("SB2")
		DbSetOrder(1)
		If MsSeek(xFilial("SB2")+SD1->D1_COD+SD1->D1_LOCAL)
			If SD1->D1_CUSTO > 0 .And. SD1->D1_QUANT > 0
		   		RecLock("SB2", .F.)
				Aeval(aValDif,{|x,y| &("SB2->B2_VATU" +AllTrim(Str(y))+" += "+AllTrim(Str(nSigno*aValDif[y])) ) } )
			   	Aeval(aValDif,{|x,y| &("SB2->B2_CM"   +AllTrim(Str(y))+" += "+AllTrim(Str(nSigno*(aValDif[y]/SD1->D1_QUANT))) ) } )
				MsUnlock()
			EndIf
		EndIf
	EndIf
EndIf
RestArea(aAreaSB2)
Return

/*
±±ºPrograma  ³RetValor  ºLeandro C.G. ³Microsiga     º Data ³  24/01/2002 º±±
±±ºDesc.     ³ Posiciona uma arquivo devolvendo o valor de acordo com a   º±±
±±º          ³formula enviada como parametro. Reposiciona os arquivos na  º±±
±±º			 ³saida da rotina											  º±±
±±ºUso       ³ GENERICO                                                   º±±
Parametros
cAlias		- Alias do arquivo que deve ser posiionado
nOrdem		- Indice do arquivo
cExpr		- Expressao para posicionar o arquivo
cFormula	- Formula que sera executada apos posicionamento do arquivo
cTipo		- Tipo do conteudo do resultado da formula. Se este parametro for passado mesmo que o resultado da formula seja nulo, retorna um valor valido segundo suas propriedades
			("C") - caractere
			("A") - Array
			("N") - Numerico
			("L") - Logico (boolean)
lTpSeek		- Se refere ao Seek realizado pelo parametro cExpr. MSSeek( ...., lTpSeek) Default .F.
*/
Function RetValor(aAlias,nOrdem,cExpr,cFormula,cTipo,lTpSeek)
Local aArea 		:= GetArea()
Local nRecno,nIndex,xRet

Default nOrdem  	:= 1
Default lTpSeek 	:= .F.

If !Empty(cAlias)
	DbSelectArea(cAlias)
	nRecno := Recno()
	nIndex := IndexOrd()

	DbSetOrder(nOrdem)
	If MsSeek(cExpr, lTpSeek)
		xRet := &(cFormula)
	EndIf

	IIf(nRecno>0,MSGoto(nRecno),)
	IIf(nIndex>0,DBSetOrder(nIndex),)
	RestArea(aArea)
EndIf

If Empty(xRet) .AND. !Empty(cTipo)
	Do Case
		Case cTipo == "A"
			xRet := {}
		Case cTipo == "C"
			xRet := ""
		Case cTipo == "N"
			xRet := 0
		Case cTipo = "L"
			xRet := .F.
	EndCase
EndIf
Return xRet

/*
±±ºPrograma  ³COMPENSANCC ºLeandro C.G. ³Microsiga   º Data ³  04/02/2002 º±±
±±ºDesc.     ³ Chama tela de compensacao de titulos financeiros para uma  º±±
±±º			 ³NCC            											  º±±
±±ºUso       ³ GRAVANFGERAL                                               º±±

Parametros
cAliasI		- Alias do arquivo de itens da NF
cTipoFin	- Tipo do titulo financeiro referente a NF
aPergs		- Array com o conteudo das perguntas feitas na tela de NF
			[SlAmarraca 1]	-   Incluir Amarraçäo  ? (Cli.xProd.) ou (For.xProd.)
			[SlGerCtbil 2]	-   lanç. On-Line?
			[SlVerCtbil 3]	- 	Mostra Lanç.Contab ?
			[SlAglutina 4]	-	Aglut Lançamentos  ?
			[SlQbraAliq 5]	-	Quebra do Rodap   ? Por Alíquota    /  Por Imposto
			[SlCtbEmiss 6]	-	Contabiliza por    ? Emissao         /  Data Base

Obs.: Considera que o arquivo de cabecalho da NF SF1 ja esta posicionado no registro correto

*/
Function CompensaNCC(cAliasI,cTipoFin,aPergs)
Local lRet  := .T.		//Retorno da funcao
Local aPars	:= {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local cX5Lote := ""

//³Consistindo parametros³

Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
lRet := LocxParam("COMPENSANCC",aPars)

Default aPergs   := {}
Default cTipoFin := ""

//³Posiciona SE1³

DBSelectArea("SE1")
DBSetOrder(2)
If lRet
	SX5->(DBSetOrder(1))
	SX5->(MsSeek(xFilial("SX5")+"09FAT"))
	cX5Lote := IIf(SX5->(Found()),Trim(X5Descri()),"FAT ")

	//³Declara variaveis necessarias e chama funcao. As variaveis a serem declaradas foram retiradas³
	//³do MATA465																					³

	PRIVATE cLote	:=""	// Utilizado para Contabilizacao
	PRIVATE VALOR 	:= 0 	// Utilizada para Contabilizacao
	PRIVATE nTamTit := TamSX3("E1_PREFIXO")[1]+TamSX3("E1_NUM")[1]+TamSX3("E1_PARCELA")[1]
	PRIVATE nTamTip := TamSX3("E1_TIPO")[1]
	PRIVATE nTamLoj := TamSX3("E1_LOJA")[1]
	Fa330Comp(cAliasI,,1,oMainWnd,cX5Lote,"COMPENSANCC")

	//³Restaura valores dos parametros com base no aPergs³

	Aeval(aPergs,{|x,y| &("MV_PAR"+StrZero(y,2)) := x })
Else
	lRet := .F.
EndIf
Return(lRet)

/*
±±ºPrograma  ³MONTAPE     ºLeandro C.G. ³Microsiga   º Data ³  14/02/2002 º±±
±±ºDesc.     ³ Carrega todos os pontos de entrada em suas devidas posicoesº±±
±±º			 ³ de acordo com o tipo de NF								  º±±
±±ºUso       ³ MONTACFGNF                                                 º±±


Parametros
nTipo    - tipo de NF
		    (1)  - NF ou fatura de Vendas
		    (2)  - NDC
		    (3)  - NCE
		    (4)  - NCC
		    (5)  - NDE
		    (6)  - ND1
		    (7)  - NCP
		    (8)  - NCI
		    (9)  - NDP
		    (10) - NF ou Fatura de Compras
		    (11) - Beneficiamento / Fornec.
		    (12) - Beneficiamento / Cliente
			(13) - Remito faturam. normal
			(14) - Remito faturam. Devolucao
			(15) - Remito compras normal
			(16) - Remito compras Devolucao
*/

Function MontaPE(nTipo)
Local nX	:= 0
Local aRet	:= Array(SnMaxPE,2)	//Retorno da funcao
/*								[1]	- No inicio da rotina da tela que cria a EnchoiceBar
								[2] 	- Antes de comecar a montagem da tela, aCols e aHeader
								[3]	- Apos o Ponto de entrada anterior
								[4]	- No inicio da Rotina de Gravacao
								[5] 	- Apos gravacao do Livro Fiscal
								[6]	- Permite alterar o valor da duplicata
								[7]	- Integracao com o Celerina, depois de gravar a NF
								[8]	- Apos gravacao do arquivo de cabecalho da Nota e todas as atualizacoes referentes a este arquivo
								[9]	- Apos gravacao do arquivo de cabecalho da Nota e antes das atualizacoes referentes a este arquivo
								[10]	- Apos atualizacoes do arquivo SB2
								[11]	- Apos a gravacao da NF fora da transacao
								[12]	- Na atualizacao do arquivo SC9
								[13]	- Retorna a qtde da segunda unidade de medida
								[14]	- Apos a gravacao do SD1 e todas as atualizacoes referentes a este arquivo
								[15]	- Apos a gravacao do SD1
								[16]	- Apos as validacoes da rotina TudOk
								[17]	- Apos as validacoes de cada item (LinOk)
								[18]	- Apos a gravacao do arquivo financeiro
								[19]	- Tecla F4 - Pedidos de Compra em Aberto
								[20]	- Permite alterar a condicao de pagamento
								[21]	- Altera os vencimentos da duplicata
								[22]	- Deixa alterar a data inicial da condicao de pagamento
								[23]	- Alteracao do numero e prefixos do aqruivo financeiro
								[24]	- Apos confirmar o numero da NF
								[25]	- Apos a geracao das comissoes
								[26]	- Num sei
								[27]	- Num sei
								[28]	- Num sei
								[29]	- Num sei
								[30]	- Depois de definir os campos obrigatorios (generico)
								.:sempre que for incluido um ponto de entrada sera preciso altera o "Define" no inicio do fonte de nome "SnMaxPE"
*/

Default nTipo := 0

For nX:=1	To SnMaxPE
	aRet[nX][1]	:=	""
	aRet[nX][2]	:=	"LOCXPE"+StrZero(nX,2)
Next

//³Montando os pontos de entrada de acordo com o tipo da Nota³

Do Case
	Case nTipo == 1 .Or. nTipo == 17 .OR. nTipo == 18 .OR. nTipo == 19 //Especifico EQUADOR - Nota Venta | Aus - RCTI | Mexico - Adiantamento
		aRet[04][1]	:= "M460PROC"	;	aRet[08][1]	:= "SF2460I"
		aRet[09][1]	:= "MTASF2"		;	aRet[10][1]	:= "GRVCOSB2"
		aRet[11][1]	:= "A467GRAV"	;	aRet[12][1]	:= "SC6460X"
		aRet[13][1]	:= "MSD2UM2"	;	aRet[14][1]	:= "MSD2460"
		aRet[21][1]	:= "ME4_COND"	;	aRet[22][1]	:= "M460COND"
		aRet[24][1]	:= "M460NUM"  	;	aRet[25][1]	:= "FA440COM"
		aRet[26][1]	:= "MS520VLD"	;	aRet[27][1]	:= "SF2520E"
		aRet[31][1]	:= "M467SQNF" 	;	aRet[32][1]	:= "M467FILT"
		aRet[36][1]	:= "A467VEN"
	Case nTipo == 2
		aRet[04][1]	:= "M460PROC"  ;	aRet[05][1]	:= "M465SF3D"
		aRet[08][1]	:= "M465SF2"   ;	aRet[09][1]	:= "MTASF2"
		aRet[10][1]	:= "GRVCOSB2"	;	aRet[11][1]	:= "A467GRAV"
		aRet[12][1]	:= "SC6460X"  	;	aRet[13][1]	:= "MSD2UM2"
		aRet[14][1]	:= "M465SD2"	;	aRet[16][1]	:= "M465BOK"
		aRet[21][1]	:= "ME4_COND"	;	aRet[22][1]	:= "M460COND"
		aRet[24][1]	:= "M460NUM"  	;	aRet[25][1]	:= "FA440COM"
		aRet[26][1]	:= "MS520VLD"	;	aRet[27][1]	:= "SF2520E"
		aRet[31][1] := "M465SQNF"	;	aRet[32][1] := "M465FILT"
		aRet[36][1]	:= "A467VEN"
	Case nTipo == 3
		aRet[04][1]	:= "M460PROC"  ;	aRet[05][1]	:= "M465SF3D"
		aRet[08][1]	:= "M465SF2"   ;	aRet[09][1]	:= "MTASF2"
		aRet[10][1]	:= "GRVCOSB2"	;	aRet[11][1]	:= "A467GRAV"
		aRet[12][1]	:= "SC6460X"  	;	aRet[13][1]	:= "MSD2UM2"
		aRet[14][1]	:= "M465SD2"	;	aRet[16][1]	:= "M465BOK"
		aRet[21][1]	:= "ME4_COND"	;	aRet[22][1]	:= "M460COND"
		aRet[24][1]	:= "M460NUM"  	;	aRet[25][1]	:= "FA440COM"
		aRet[26][1]	:= "MS520VLD"	;	aRet[27][1]	:= "SF2520E"
		aRet[31][1] := "M465SQNF"	;	aRet[32][1] := "M465FILT"
		aRet[36][1]	:= "A467VEN"
	Case nTipo == 4 .Or. nTipo == 24
		aRet[01][1] := "MT103BUT" 	;	aRet[02][1] := "MT103NFE"
		aRet[03][1] := "MT100F4"	;	aRet[04][1] := "MT100GRV"
		aRet[05][1] := "M465SF3"	;	aRet[06][1] := "A103VLR"
		aRet[07][1] := "GQREENTR"	;	aRet[08][1] := "M465SF1"
		aRet[11][1] := "MT100AGR" 	;	aRet[14][1] := "M465SD1"
		aRet[16][1] := "M465BOK"  	;	aRet[17][1] := "MT100LOK"
		aRet[18][1] := "MT100GE2"	;	aRet[19][1] := "A100F4CP"
		aRet[20][1] := "A103CND2" 	;	aRet[23][1] := "MT100DP"
		aRet[28][1] := "SD1100E"	;	aRet[29][1] := "SF1100E"
		aRet[31][1] := "M465SQNF"	;	aRet[32][1] := "M465FILT"
		aRet[33][1] := "M465CPO"
		aRet[47][1] := "M101SX5"
	Case nTipo == 5
		aRet[01][1] := "MT103BUT" 	;	aRet[02][1] := "MT103NFE"
		aRet[03][1] := "MT100F4"	;	aRet[04][1] := "MT100GRV"
		aRet[05][1] := "M465SF3"	;	aRet[06][1] := "A103VLR"
		aRet[07][1] := "GQREENTR"	;	aRet[08][1] := "M465SF1"
		aRet[11][1] := "MT100AGR" 	;	aRet[14][1] := "M465SD1"
		aRet[16][1] := "M465BOK"  	;	aRet[17][1] := "MT100LOK"
		aRet[18][1] := "MT100GE2"	;	aRet[19][1] := "A100F4CP"
		aRet[20][1] := "A103CND2" 	;	aRet[23][1] := "MT100DP"
		aRet[28][1] := "SD1100E"	;	aRet[29][1] := "SF1100E"
		aRet[31][1] := "M465SQNF"	;	aRet[32][1] := "M465FILT"
		aRet[33][1] := "M465CPO"
		aRet[47][1] := "M101SX5"
	Case nTipo == 6
		aRet[04][1]	:= "M460PROC" 	;	aRet[08][1]	:= "M466SF2"
		aRet[09][1]	:= "MTASF2"		;	aRet[10][1]	:= "GRVCOSB2"
		aRet[11][1]	:= "A466DBTO"	;	aRet[12][1]	:= "SC6460X"
		aRet[13][1]	:= "MSD2UM2"	;	aRet[14][1]	:= "M466SD2"
		aRet[21][1]	:= "ME4_COND"	;	aRet[22][1]	:= "M460COND"
		aRet[24][1]	:= "M460NUM"  	;	aRet[25][1]	:= "FA440COM"
		aRet[26][1]	:= "MS520VLD"	;	aRet[27][1]	:= "SF2520E"
		aRet[31][1]	:= "M466SQNF"	;	aRet[32][1]	:= "M466FILT"
		aRet[36][1]	:= "A467VEN"
	Case nTipo == 7 .Or. nTipo == 22
		aRet[04][1]	:= "M460PROC" 	;	aRet[08][1]	:= "M466SF2"
		aRet[09][1]	:= "MTASF2"		;	aRet[10][1]	:= "GRVCOSB2"
		aRet[11][1]	:= "A466DBTO"	;	aRet[12][1]	:= "SC6460X"
		aRet[13][1]	:= "MSD2UM2"	;	aRet[14][1]	:= "M466SD2"
		aRet[21][1]	:= "ME4_COND"	;	aRet[22][1]	:= "M460COND"
		aRet[24][1]	:= "M460NUM"  	;	aRet[25][1]	:= "FA440COM"
		aRet[26][1]	:= "MS520VLD"	;	aRet[27][1]	:= "SF2520E"
		aRet[31][1]	:= "M466SQNF"	;	aRet[32][1]	:= "M466FILT"
	Case nTipo == 8
		aRet[01][1] := "MT103BUT" 	;	aRet[02][1] := "MT103NFE"
		aRet[03][1] := "MT100F4"	;	aRet[04][1] := "MT100GRV"
		aRet[06][1] := "A103VLR"	;	aRet[07][1] := "GQREENTR"
		aRet[08][1] := "M466SF1"  	;	aRet[11][1] := "A466CRTO"
		aRet[14][1] := "M466SD1"	;	aRet[16][1] := "MT100TOK"
		aRet[17][1] := "MT100LOK"	;	aRet[18][1] := "MT100GE2"
		aRet[19][1] := "A100F4CP"	;	aRet[20][1] := "A103CND2"
		aRet[23][1] := "MT100DP"	;	aRet[28][1] := "SD1100E"
		aRet[29][1] := "SF1100E"	;	aRet[31][1] := "M466SQNF"
		aRet[32][1] := "M466FILT"
		aRet[47][1] := "M101SX5"
	Case nTipo == 9 .Or. nTipo == 23
		aRet[01][1] := "MT103BUT" 	;	aRet[02][1] := "MT103NFE"
		aRet[03][1] := "MT100F4"	;	aRet[04][1] := "MT100GRV"
		aRet[06][1] := "A103VLR"	;	aRet[07][1] := "GQREENTR"
		aRet[08][1] := "M466SF1"  	;	aRet[11][1] := "A466CRTO"
		aRet[14][1] := "M466SD1"  	;	aRet[16][1] := "MT100TOK"
		aRet[17][1] := "MT100LOK"	;	aRet[18][1] := "MT100GE2"
		aRet[19][1] := "A100F4CP"	;	aRet[20][1] := "A103CND2"
		aRet[23][1] := "MT100DP"	;	aRet[28][1] := "SD1100E"
		aRet[29][1] := "SF1100E"	;	aRet[31][1] := "M466SQNF"
		aRet[32][1] := "M466FILT"
		aRet[47][1] := "M101SX5"
	Case nTipo == 10
		aRet[01][1] := "MT103BUT" 	; aRet[02][1] 	:= "MT103NFE"
		aRet[03][1] := "MT100F4"	; aRet[04][1] 	:= "MT100GRV"
	 	aRet[06][1] := "A103VLR"	; aRet[07][1] 	:= "GQREENTR"
	 	aRet[08][1] := "SF1100I"	; aRet[11][1]	:= "MT100AGR"
		aRet[14][1] := "SD1100I"	; aRet[15][1] 	:= "M100GRAV"
		aRet[16][1] := "MT100TOK"	; aRet[17][1] 	:= "MT100LOK"
		aRet[18][1] := "MT100GE2"	; aRet[19][1] 	:= "A100F4CP"
		aRet[20][1] := "A103CND2"	; aRet[23][1] 	:= "MT100DP"
		aRet[28][1] := "SD1100E"	; aRet[29][1] 	:= "SF1100E"
		aRet[45][1] := "M101SER"
		aRet[47][1] := "M101SX5"
	Case nTipo == 11
		aRet[04][1]	:= "M460PROC"	; aRet[08][1] := "SF2460I"
		aRet[09][1]	:= "MTASF2"		; aRet[10][1] := "GRVCOSB2"
		aRet[11][1]	:= "A467GRAV"	; aRet[12][1] := "SC6460X"
		aRet[13][1]	:= "MSD2UM2"	; aRet[14][1] := "MSD2460"
		aRet[21][1]	:= "ME4_COND"	; aRet[22][1] := "M460COND"
		aRet[24][1]	:= "M460NUM"	; aRet[25][1] := "FA440COM"
		aRet[26][1]	:= "MS520VLD"	; aRet[27][1] := "SF2520E"
		aRet[31][1]	:= "M467SQNF"	; aRet[32][1] := "M467FILT"
		aRet[36][1]	:= "A467VEN"
	Case nTipo == 12
		aRet[01][1] := "MT103BUT" 	; aRet[02][1] := "MT103NFE"
		aRet[03][1] := "MT100F4"	; aRet[04][1] := "MT100GRV"
		aRet[06][1] := "A103VLR"	; aRet[07][1] := "GQREENTR"
		aRet[08][1] := "SF1100I"	; aRet[11][1] := "MT100AGR"
		aRet[14][1] := "SD1100I"	; aRet[15][1] := "M100GRAV"
		aRet[16][1] := "MT100TOK"	; aRet[17][1] := "MT100LOK"
		aRet[18][1] := "MT100GE2"	; aRet[19][1] := "A100F4CP"
		aRet[20][1] := "A103CND2" 	; aRet[23][1] := "MT100DP"
		aRet[28][1] := "SD1100E"	; aRet[29][1] := "SF1100E"
		aRet[47][1] := "M101SX5"
	Case nTipo == 13 .OR. nTipo == 14
		aRet[08][1] := "SF1100I"
	Case nTipo == 50
		aRet[11][1] := "RMT50FIM"
	Case cPaisLoc == "MEX" .And. nTipo == 54
		aRet[31][1] := "M462TSR"
	Case cPaisLoc == "ARG" .And. nTipo == 51
		aRet[17][1] := "MT100LOK"
	Case nTipo == 64 .And. If(Type("cEspecDoc")=="U",Alltrim(SF1->F1_ESPECIE),cEspecDoc) == "RTE" .AND. cPaisLoc == "ARG"
		aRet[07][1] := "GQREENTR"
EndCase
Aeval(aRet, { |x,y| IIf(Empty(x),aRet[y]:="",) } )
Return(aRet)

/*

±±ºPrograma  ³LOCXPARAM   ºLeandro C.G. ³Microsiga   º Data ³  19/02/2002 º±±

±±ºDesc.     ³ Efetua a consistencia dos parametros na entrada das funcoesº±±
±±º			 ³de acordo com o tipo de consistencia desejada				  º±±

Parametros
cProg		- 	nome da funcao de onde serao checados os param.
aPars		- 	dados sobre cada paramtero que deve ser consistido
				[1]	- nome do parametro
				[2] - conteudo do parametro
				[3] - tipo da validacao
				... qdo tipo de validacao for SpValor ([3] == SpValor)
					[4] valor minimo
					[5] valor maximo
				... qdo tipo de validacao for SpLenArray ([3] == SpLenArray)
					[4] Length minimo
					[5] Length maximo
				... qdo tipo de validacao for Sp2String ([3] == Sp2String)
					[4] String 1
					[5] String 2
				... qdo o tipo de validacao for Sp4String
					[4] String 1
					[5] String 2
					[6] String 3
					[7] String 4
lMensagem	-	indica se deve mostrar ou nao mensagem de erro (Default .T.)

-------------------------
-- TIPOS DE VALIDACOES --
-------------------------
SpEmpty		- verifica se o conteudo esta vazio
SpValor		- verifica se o valor numerico esta dentro de dois limites (maximo e minimo). Neste caso o parametro aPars
			possuira duas posicoes especiais ([4]-limite minimo / [5]-limite maximo
SpLenArray	- verifica se o Length do array esta dentro de dois limites (maximo e minimo). Neste caso o paramteros aPars
			possuira duas posicoes especiais ([4]-limite minimo / [5]-limite maximo
Sp2String	- verifica se o conteudo e igual a uma de duas string's. Neste caso o parametro aPars possuira duas posicoes
			especiais ([4]-string1 / [5]-string2)
Sp4String	- verifica se o conteudo e igual a uma de quatro string's. Neste caso o parametro aPars possuira quatro posicoes
			especiais ([4]-string1 / [5]-string2 / [6]-string3 / [7]-string4)
SpValType	- verifica o tipo do conteudo de um parametro. Neste caso o parametro aPars possuira uma pos. especial
			([4] - tipo desejado ("A";"C";"L";"N"...)
*/
Function LocxParam(cFunc,aPars,lMensagem)
Local lRet		  := .T.					//Indica inconsistencias
Local nI									//Flag para loop's

Default lmensagem := .T.
Default aPars     := {}
Default cFunc	  := ""

//³Verificando parametros da propria funcao³

If lRet
 	Aeval(aPars, { |x,y| IIf(ValType(aPars[y])!="A",aPars[y]:={},),IIf(Len(x)<3,Asize(x,3),), IIf(aPars[y][3]==NIL,aPars[y][3]:=0,), IIf(aPars[y][1]==NIL,aPars[y][1]:="",) } )

	//³Validando todos os param.³

	nI := 0
	For nI := 1 to Len(aPars)

		//³Validando parametros de acordo com o tipo selecionado³

		Do Case

			//³Verifica se o conteudo esta vazio³

			Case aPars[nI][3] == SpEmpty
				If aPars[nI][2] == NIL
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf

			//³Verifica se o valor numero se encontra dentro dos limites estabelecidos³

			Case aPars[nI][3] == SpValor
				Asize(aPars[nI],5)
				IIf(aPars[nI][4]==NIL,aPars[nI][4]:=0,)
				IIf(aPars[nI][5]==NIL,aPars[nI][5]:=0,)
				If aPars[nI][2] == NIL .OR. aPars[nI][2] < aPars[nI][4] .OR. aPars[nI][2] > aPars[nI][5]
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf
			//³Verifica o Lenght minimo de um array³

			Case aPars[nI][3] == SpLenArray
				Asize(aPars[nI],5)
				IIf(aPars[nI][4]==NIL,aPars[nI][4]:=0,)
			IIf(aPars[nI][5]==NIL,aPars[nI][5]:=0,)
				If ValType(aPars[nI][2]) != "A" .OR. ;
				   Len(aPars[nI][2]) < aPars[nI][4] .OR. Len(aPars[nI][2]) > aPars[nI][5]
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf

			//³Verifica se o contudo e igual a uma de duas strings      ³

			Case aPars[nI][3] == Sp2String
				Asize(aPars[nI],5)
				IIf(aPars[nI][4]==NIL,aPars[nI][4]:="",)
				IIf(aPars[nI][5]==NIL,aPars[nI][5]:="",)
				If aPars[nI][2] == NIL .OR. (aPars[nI][2] != aPars[nI][4] .AND. aPars[nI][2] != aPars[nI][5])
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf

			//³Verifica se o contudo e igual a uma de quatro strings      ³

			Case aPars[nI][3] == Sp4String
				Asize(aPars[nI],7)
				IIf(aPars[nI][4]==NIL,aPars[nI][4]:="",)
				IIf(aPars[nI][5]==NIL,aPars[nI][5]:="",)
				IIf(aPars[nI][6]==NIL,aPars[nI][6]:="",)
				IIf(aPars[nI][7]==NIL,aPars[nI][7]:="",)
				If aPars[nI][2] == NIL .OR. ;
				   (aPars[nI][2] != aPars[nI][4] .AND. aPars[nI][2] != aPars[nI][5] .AND. aPars[nI][2] != aPars[nI][6] .AND. aPars[nI][2] != aPars[nI][7])
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf

			//³Verifica se o tipo do contudo e do tipo desejado ³

			Case aPars[nI][3] == SpValType
				Asize(aPars[nI],4)
				IIf(aPars[nI][4]==NIL,aPars[nI][4]:="",)
				If ValType(aPars[nI][2]) != aPars[nI][4]
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf
		EndCase
	Next nI
EndIf
Return(lRet)

/*

±±ºPrograma  ³SCMToNF   º±±

±±ºDesc.     ³ Mostra os remitos que sera amarrados ao documento sendo di-º±±
±±º          ³gitado (devolucao ou NF de entrada)                         º±±
lActBrow - logico - Indica si deben realizarse las actualizaciones del browse. por default se realizan.
*/
Function SCMToNF(lActBrow)
Local aRecs    := {}
Local aRecCols := {}
Local aRecHeader:={}
Local aRet     := {}
Local aCpoExt  := {}
Local aCpoExtra:= {}
Local aAreaSD1 := GetArea()
Local nI       := 0
Local nDescri  := 0
Local nPorDesc	:= 0
Local nItemRem := 0
Local nUm      := 0
Local nSegum   := 0
Local nCod     := 0
Local nLocal   := 0
Local nQuant   := 0
Local nQtdACla := 0
Local nOrdProd := 0
Local nRemito  := 0
Local nItem    := 0
Local nTes     := 0
Local nCF      := 0
Local nSeriRem := 0
Local nLOTEFOR := 0
Local nLOTECTL := 0
Local nNUMLOTE := 0
Local nDTVALID := 0
Local nProvEnt := 0
Local nConcept := 0
Local nIPI     := 0
Local nQtSegUm := 0
Local nConta   := 0
Local nCCusto  := 0
Local nFDESC   := 0
Local nBsImp1M	:= 0
Local nVlImp1M	:= 0
Local nTotalM	:= 0
Local cTipoDoc := ""
Local cCliFor:= IIf(aCfgNF[SAliasHead]=="SF1",M->F1_FORNECE,M->F2_CLIENTE)
Local cLoja  := IIf(aCfgNF[SAliasHead]=="SF1",M->F1_LOJA,M->F2_LOJA)
//Local nPosSolici := 0
//Local cCampo := "" ,cItem	:=	""
Local cSeek  := "'" + xFilial('SD1')+cCliFor+cLoja + "'"
Local cCondUser := ""
Local nPedido	:= 0
Local nItemPC	:= 0

//Alteracao para buscar o remito de SD1
Local cWhile := "!EOF() .AND. SD1->D1_FILIAL+SD1->D1_FORNECE+SD1->D1_LOJA== " + cSeek
Local cCondicao2 := ""
Local cPe		:=	""
Local cPeT		:=	""
Local aCposF4	:= 	   {"D1_DOC",;
						"D1_FORNECE",;
						"D1_LOJA"   ,;
						"D1_ITEM"   ,;
						"D1_COD"	,;
						"D1_UM"     ,;
						"D1_QUANT"  ,;
						"D1_QTDACLA",;
						"D1_SEGUM"  ,;
						"D1_QTSEGUM",;
						"D1_LOCAL"  ,;
						"D1_PEDIDO" }

Local nFEPP    := 0
Local nIE	   := 0
Local cTipConv := GetNewPar("MV_ALTTXNF",'1')
Local nTaxaNf  := 0
Local nTaxaPed := 0
Local nSeguro  := 0
Local nFrete   := 0
Local nDescont := 0
Local nDespesa := 0
//Local nDesNTrb := 0
//Local nTara    := 0
Local nDifRem  := 0
Local nVlTotal := 0
Local cFilSC7		:= xFilial("SC7")
Local nT_TOTAL	:= TamSx3("D1_TOTAL")[2]
Local nT_VUNIT	:= TamSX3("D1_VUNIT")[2]
Local cFilSF1		:= xFilial("SF1")
Local cFilSB1		:= xFilial("SB1")
Local lCheckMoed	:= .T.
Local aChMoeda 	AS Array
Local aHeaderSDE	:= {}
//Local cCFO			:= ""
Local dMaxRem as Date
Local nVunit   := 0
Local nTotal   := 0
Local nDesc    := 0
Local nItConta := 0
Local nClValor := 0
Local lCondicao := .F.
Local cMVDescSai := SuperGetMV("MV_DESCSAI",.T.,'1')

Private aColsSD1 	:= aCols

Default lActBrow	:= .T.

If Type("cCondicao") <> "U"
	lCondicao := .T.
EndIf

cPet := LocxPEt(34)
If !Empty(cPet)
	cCondUser	:=	ExecTemplate(cPEt,.F.,.F.,)
EndIf
cPe	:=	LocxPE(34)
If !Empty(cPe)
	cCondUser	:=	IIf(Empty(cCondUser),""," .AND. ") + Execblock(cPE,.F.,.F.,)
EndIf
If Empty(cCliFor) .OR. Empty(cLoja)
	Aviso(cCadastro,STR0094,{STR0021}) //"Llene los datos del encabezado."###"OK"
	Return .F.
EndIf
If nModulo == 12 .AND. !nModulo == 72
	Aviso(cCadastro,STR0238,{STR0021})  //"Esta funcionalidade nao esta habilitada para o modulo SigaLoja."
	Return
EndIf
If FindFunction("LxCpRemito") .And. !LxCpRemito()//Valida campos usados
	Return
EndIf
For nI:=1 to Len(aHeader)
	Do Case
		Case  Alltrim(aHeader[nI][2]) == "D1_DESCRI"
			nDescri  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_FDESC"
			nFDESC  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DESC"
			nPorDesc	:= nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMREM"
			nItemRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_UM"
			nUm      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SEGUM"
			nSegum   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_COD"
			nCod     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOCAL"
			nLocal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QUANT"
			nQuant   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_REMITO"
			nRemito  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SERIREM"
			nSeriRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEM"
			nItem    := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TES"
			nTes     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CF"
			nCf      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTEFOR"
			nLoteFor := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTECTL"
			nLoteCtl := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_NUMLOTE"
			nNumLote := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DTVALID"
			nDtValid := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_IPI"
			nIpi     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VUNIT"
			nVunit   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TOTAL"
			nTotal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QTSEGUM"
			nQTSegum := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CONTA"
			nConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CC"
			nCCusto := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_OP"
			nOrdProd := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_FEPP"
			nFepp := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_IE"
			nIE   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VALDESC"
			nDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_PROVENT"
			nProvEnt := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CONCEPT"
			nConcept := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMCTA"
			nItConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CLVL"
			nClValor := nI
		Case Alltrim(aHeader[nI][2]) == "D1_BSIMP1M" .AND. cPaisloc == "RUS"
			nBsImp1M := nI
		Case Alltrim(aHeader[nI][2]) == "D1_VLIMP1M" .AND. cPaisloc == "RUS"
			nVlImp1M := nI
		Case Alltrim(aHeader[nI][2]) == "D1_TOTALM" .AND. cPaisloc == "RUS"
			nTotalM := nI
		Case Alltrim(aHeader[nI][2]) == "D1_PEDIDO"
			nPedido := nI
		Case Alltrim(aHeader[nI][2]) == "D1_ITEMPC"
			nItemPC := nI
	Endcase
Next nI
//verifica o tipo de documento.
If aCfgNF[SnTipo] == 4 .OR. aCfgNF[SnTipo] == 5
	cTipoDoc := "51/53"
ElseIf aCfgNF[SnTipo] == 10
	cTipoDoc := "60"
Else
	Return
EndIf
lFilData:=.T.
If ExistBlock("LOCFDTR")
	lFilData:=Execblock("LOCFDTR",.F.,.F.,)
EndIf
If nRemito * nSeriRem * nItemRem > 0
	If lFilData
		cCondicao2 	:= IIf(Empty(cCondicao2),""," .And. ") + "DTOS(SD1->D1_DTDIGIT)<='"+Dtos(dDataBase)+"' .And. SD1->D1_QTDACLA > 0 .And. AllTrim(SD1->D1_TIPO) == aCfgNF["+AllTrim(Str(ScTipoDoc))+"] .And. AllTrim(SD1->D1_TIPODOC) $ Alltrim('"+cTipoDoc+"')"
    Else
    	cCondicao2 	:= IIf(Empty(cCondicao2),""," .And. ") +" SD1->D1_QTDACLA > 0 .And. AllTrim(SD1->D1_TIPO) == aCfgNF["+AllTrim(Str(ScTipoDoc))+"] .And. AllTrim(SD1->D1_TIPODOC) $ Alltrim('"+cTipoDoc+"')"
    EndIf
	If aCfgNF[SnTipo] <> 10
		cCondicao2 +=  ".And. Iif(Ascan(aColsSD1,{ |X| X["+Alltrim(str(nRemito))+"]+ X["+Alltrim(Str(nSeriRem))+"] +X["+Alltrim(Str(nItemRem))+"] == SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_ITEM})==0,.T.,.F. )"
	EndIf
	If !Empty(cCondUser)
		cCondicao2 := "(" + cCondicao2 + ") .AND. (" + cCondUser + ")"
	EndIf
	If ExistBlock('LOCXCOND')
		cCondicao2 := Execblock('LOCXCOND',.F.,.F.,{cCondicao2,"I"})
	EndIf
	//³Ponto de entrada para adicao de campos ao gride de itens.³
	//³Deve retornar um array e cada item deve ter a seguinte   ³
	//³estrutura:                                               ³
	//³	                                                        ³
	//³[n,1] = Nome do Campo    (SX3)                           ³
	//³[n,2] = Formula para o conteudo do campo                 ³
	//³[n,3] = Coluna em que o campo sera visualizado           ³
	aCpoExt   := {}
	Aadd(aCpoExt,{AllTrim(FwX3Titulo("B1_DESC")),"D1_CODDESC",AllTrim(GetSx3Cache("B1_DESC", "X3_PICTURE")),GetSx3Cache("B1_DESC", "X3_TAMANHO"),,,,"C",,,'AllTrim(Posicione("SB1", 1, xFilial("SB1") + SD1->D1_COD, "B1_DESC"))',})
	aCpoExtra := {}
	cPe	:=	LocxPE(46)
	If !Empty(cPe)
		aCpoExtra := Execblock(cPE,.F.,.F.,)
		If (ValType(aCpoExtra) == "A")
			For nI := 1 To Len(aCpoExtra)
				If ValType(aCpoExtra[nI]) == "A"
					Aadd(aCpoExt,{,aCpoExtra[nI,1],,,,,,,,,aCpoExtra[nI,2],aCpoExtra[nI,3]})
				Endif
			Next
		Endif
	EndIf
	If cPaisLoc =="RUS"
		aRet := LocxF4("SD1",10,cWhile,cSeek,aCposF4,,DESCREM,cCondicao2,.T.,,aCpoExt,,"LockSCM(Agrid[6,oLBCli:nAt])",.F.,,.T.,.T.)  // Retorna os Recnos das linhas selecionadas
	Else
		aRet := LocxF4("SD1",10,cWhile,cSeek,aCposF4,,DESCREM,cCondicao2,.T.,,aCpoExt,,"LockSCM(Agrid[6,oLBCli:nAt])",.F.,,.T.)  // Retorna os Recnos das linhas selecionadas
	EndIf
	If lActBrow
		Eval( bFilBrw )
	EndIf
EndIf
If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs	  := aRet[3]
	aRecCols  := aRet[2]
	aRecHeader:= aRet[1]
EndIf
If ValType(aRecs)!="A" .OR. (ValType(aRecs)=="A" .AND. Len(aRecs)==0)
	Return .F.
EndIf
//check currency in selected recocds
If cPaisLoc == "RUS"
	If Len(aRecs) > 1
		aChMoeda	:= {}
		for nI:=1 to Len(aRecs)
			SD1->(MsGoto(aRecs[nI]))
			SF1->(DbSetOrder(1))
			If (SF1->(MsSeek(cFilSF1+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA)))	//F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO
				Aadd(aChMoeda,SF1->F1_MOEDA)
				dMaxRem := Iif( dMaxRem == Nil, SF1->F1_EMISSAO, max(dMaxRem, SF1->F1_EMISSAO) )
			Else
				lCheckMoed := .F.
			EndIf
		Next nI
		If lCheckMoed
			aSort(aChMoeda,,,{ |x, y| x < y })
			for nI:=1 to Len(aChMoeda)-1
				if aChMoeda[nI]<>aChMoeda[nI+1]
					lCheckMoed	:= .F.
					Exit
				EndIf
			next nI
		EndIf
	Else
		SD1->(MsGoto(aRecs[1]))
		SF1->(DbSetOrder(1))
		If (SF1->(MsSeek(cFilSF1+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA)))	//F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO
			dmaxRem := SF1->F1_EMISSAO
		Else
			lCheckMoed := .F.
		EndIf
	EndIf
EndIf
If !lCheckMoed
	Help("A100MOEDA",1,STR0403)	//Selected Records have different currency
EndIf
If lCheckMoed
	If Len(aCols)==0
		cItem	:=	StrZero(0,TamSx3('D1_ITEM')[1])
	Else
		If nItem>0
			If !Empty(aCOLS[Len(aCols)][nCod])
				cItem:=aCols[Len(aCols)][nItem]
			Else
				If Len(aCols)>1 
					cItem:=aCols[Len(aCols)-1][nItem]
				Else
					cItem	:=	StrZero(0,TamSx3('D1_ITEM')[1])
				EndIf
			EndIf
		EndIf
	EndIf
	nI:=0
	For nI := 1 To Len(aRecs)
		cItem	:=	Soma1(cItem)
		//Prorrateo por centro de costo
		If (FunName() == "MATA101N") .Or. ChkProp("ProrrateoDeRemito")
			aHeaderSDE:=HeaderSDE(aHeaderSDE)
			RateioRemFac(aHeaderSDE,@aRatCC,cItem,aRecs[nI])
		EndIf
		If ( nCod > 0  .AND.  !Empty(aCOLS[Len(aCols)][nCod]))
			AAdd(aCols,Array(Len(aHeader)+1))
		EndIf
		aCols[Len(aCols)][Len(aHeader)+1]:=.F.
		SD1->(MsGoto(aRecs[nI]))
		SB1->(MsSeek(cFilSB1+SD1->D1_COD))
		SC7->(dbSetOrder(1)) // C7_FILIAL+C7_NUM+C7_ITEM
		SC7->(MsSeek(cFilSC7+SD1->D1_PEDIDO+SD1->D1_ITEMPC))

		If (nOrdProd >  0  ,  aCOLS[Len(aCols)][nOrdProd] := SD1->D1_OP ,)
		If (nDescri  >  0  ,  aCOLS[Len(aCols)][nDescri ] := SD1->D1_DESCRI ,)
		If (nFDESC   >  0  ,  aCOLS[Len(aCols)][nFDESC  ] := SD1->D1_FDESC ,)
		If (nItemRem >  0  ,  aCOLS[Len(aCols)][nItemRem] := SD1->D1_ITEM   ,)
		If (nUm      >  0  ,  aCOLS[Len(aCols)][nUm     ] := SD1->D1_UM     ,)
		If (nSegum   >  0  ,  aCOLS[Len(aCols)][nSegum  ] := SD1->D1_SEGUM  ,)
		If (nCod     >  0  ,  aCOLS[Len(aCols)][nCod    ] := SD1->D1_COD	  ,)
		If (nSeriRem >  0  ,  aCOLS[Len(aCols)][nSeriRem] := SD1->D1_SERIE  ,)
		If (nLocal   >  0  ,  aCOLS[Len(aCols)][nLocal  ] := SD1->D1_LOCAL  ,)
		If nQuant   >  0
			If aCfgNF[SnTipo] == 10
				aCOLS[Len(aCols)][nQuant  ] := aRecCols[nI ,Ascan(aRecHeader,{|X| Alltrim(X) ==  "D1_QTDACLA" })]
			Else
				aCOLS[Len(aCols)][nQuant  ] := SD1->D1_QTDACLA
			EndIf
			nQtdACla := aCOLS[Len(aCols)][nQuant  ]
		EndIf
		If (nRemito  >  0  ,  aCOLS[Len(aCols)][nRemito ] := SD1->D1_DOC	  ,)
		If (nItem    >  0  ,  aCOLS[Len(aCols)][nItem   ] := cItem			  ,)
		If (nTes     >  0  ,  aCOLS[Len(aCols)][nTes    ] := SD1->D1_TES    ,)
		If (nCF      >  0  ,  aCOLS[Len(aCols)][nCF     ] := SD1->D1_CF     ,)
		If (nLOTEFOR >  0  ,  aCOLS[Len(aCols)][nLOTEFOR] := SD1->D1_LOTEFOR,)
		If (nLOTECTL >  0  ,  aCOLS[Len(aCols)][nLOTECTL] := SD1->D1_LOTECTL,)
		If (nNUMLOTE >  0  ,  aCOLS[Len(aCols)][nNUMLOTE] := SD1->D1_NUMLOTE,)
		If (nDTVALID >  0  ,  aCOLS[Len(aCols)][nDTVALID] := SD1->D1_DTVALID,)
		If (nProvEnt >  0  ,  aCOLS[Len(aCols)][nProvEnt] := SD1->D1_PROVENT,)
		If (nIPI     >  0  ,  aCOLS[Len(aCols)][nIPI    ] := SD1->D1_IPI    ,)
		If (nQtSegUm >  0  ,  aCOLS[Len(aCols)][nQtSegUm] := SD1->D1_QTSEGUM,)
		If (nConta   >  0  ,  aCOLS[Len(aCols)][nConta  ] := If(!Empty(SD1->D1_CONTA),SD1->D1_CONTA,SB1->B1_CONTA),)
		If (nCCusto  >  0  ,  aCOLS[Len(aCols)][nCCusto ] := If(!Empty(SD1->D1_CC),SD1->D1_CC,SB1->B1_CC),)
		If (nItConta >  0  ,  aCOLS[Len(aCols)][nItConta] := SD1->D1_ITEMCTA,)
		If (nClValor >  0  ,  aCOLS[Len(aCols)][nClValor] := SD1->D1_CLVL,)
		If (nPedido  >  0  ,  aCOLS[Len(aCols)][nPedido ] := SD1->D1_PEDIDO,)
		If (nItemPC  >  0  ,  aCOLS[Len(aCols)][nItemPC ] := SD1->D1_ITEMPC,)

		If cPaisLoc == "EQU" .OR. cPaisLoc == "VEN"
			If (nConcept > 0 , aCOLS[Len(aCols)][nConcept] := If(!Empty(SD1->D1_CONCEPT),SD1->D1_CONCEPT,SC7->C7_CONCEPT),)
		EndIf
		If cPaisLoc == "CHI"
			If (nFEPP    >  0  ,  aCOLS[Len(aCols)][nFEPP   ] := SD1->D1_FEPP   ,)
			If (nIE      >  0  ,  aCOLS[Len(aCols)][nIE     ] := SD1->D1_IE     ,)
		EndIf
		If Select("__LOCXSF1") == 0
			ChkFile("SF1",.F.,"__LOCXSF1")
		Else
			dbSelectArea("__LOCXSF1")
		Endif
		cIndex := CriaTrab(Nil, .F.)
		IndRegua("__LOCXSF1", cIndex, "F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO", , , "")

		__LOCXSF1->(DbSetOrder(1))
		__LOCXSF1->(MSSeek(cFilSF1+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO))
		IIF (lCondicao .And. !Empty(__LOCXSF1->F1_COND), cCondicao := __LOCXSF1->F1_COND,)
		//(18/07/18):Change moeda from remito invoice
		If cPaisloc == "RUS"
			M->F1_MOEDA := __LOCXSF1->F1_MOEDA
			M->F1_EMISSAO := dmaxRem
			dDEmissao := dmaxRem
			nMoedaNF := __LOCXSF1->F1_MOEDA
			nMoedaCor := nMoedaNF
			MaFisRef("NF_MOEDA","MT100",__LOCXSF1->F1_MOEDA)
			M->F1_TXMOEDA:=RecMoeda(M->F1_EMISSAO,nMoedaNF)
		EndIf
		nTaxaNF		:= Iif(MaFisRet(,'NF_TXMOEDA')==0,Recmoeda(dDatabase,M->F1_MOEDA),MaFisRet(,'NF_TXMOEDA'))
		nTaxaPed		:= Iif(cTipConv=='1',Iif(__LOCXSF1->F1_TXMOEDA=0,RecMoeda(__LOCXSF1->F1_EMISSAO,__LOCXSF1->F1_MOEDA),__LOCXSF1->F1_TXMOEDA),RecMoeda(dDatabase,__LOCXSF1->F1_MOEDA))
		If nVUnit   >  0
			If SD1->D1_VUNIT <> 0
				nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
			Else
				If ! Empty(SD1->D1_PEDIDO)
					nPrecio := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
				Else
					nPrecio := RetFldProd(SB1->B1_COD,"B1_UPRC")
					If M->F1_MOEDA<>1 .And. M->F1_TXMOEDA<>0
						nPrecio:=NoRound(nPrecio / M->F1_TXMOEDA,nT_VUNIT)
					EndIf
				EndIf
			EndIf
			If cPaisloc=="ARG" .AND. (cMVDescSai == '2') .and. Alltrim(aCfgNF[8]) == "NCC"
					nPrecio += (SD1->D1_VALDESC / SD1->D1_QUANT)
			EndIf
			aCOLS[Len(aCols)][nVunit] := nPrecio
		EndIf
		If nTotal > 0
			IF SD1->D1_VUNIT <> 0
				nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
			ELSE
				IF .NOT. EMPTY(SD1->D1_PEDIDO)
					nPrecio := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
				ELSE
					nPrecio := RetFldProd(SB1->B1_COD,"B1_UPRC")
					If M->F1_MOEDA<>1 .And. M->F1_TXMOEDA<>0
						nPrecio:=NoRound(nPrecio / M->F1_TXMOEDA,nT_VUNIT)
					EndIf
					aCOLS[Len(aCols)][nVunit] := nPrecio
				ENDIF
			ENDIF
			If cPaisloc=="ARG" .AND. (cMVDescSai == '2') .and. Alltrim(aCfgNF[8]) == "NCC"
				nPrecio += (SD1->D1_VALDESC / SD1->D1_QUANT)
			EndIf
			aCOLS[Len(aCols)][nTotal] := (nPrecio * nQtdACla)
			// Verificação para previnir diferença de centavos quando do retorno da função MaColsToFis
			If nT_TOTAL == 2
				nVlTotal := 0
				nDifRem  := 0.01
				nVlTotal := Round((nPrecio * SD1->D1_QTDACLA),2)
				If ABS(nVlTotal - SD1->D1_TOTAL) == nDifRem
					nVlTotal := SD1->D1_TOTAL
				EndIf
				aCOLS[Len(aCols)][nTotal] := nVlTotal
			EndIf
		Endif
		If nDesc > 0
			IF SD1->D1_VALDESC <> 0
				If nQtdACla == SD1->D1_QUANT
					aCols[Len(aCols)][nDesc] :=xMoeda(SD1->D1_VALDESC,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
				Else
					aCols[Len(aCols)][nDesc] :=xMoeda(SD1->D1_VALDESC*nQtdACla/SD1->D1_QUANT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
				Endif
			Else
				dbSelectArea("SC7")
				dbSetOrder(1)
				If SC7->(MsSeek(cFilSC7+SD1->D1_PEDIDO+SD1->D1_ITEMPC,.F.))
					If nQtdACla == SC7->C7_QUANT
						aCols[Len(aCols)][nDesc] :=xMoeda(SC7->C7_VLDESC,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
					Else
						aCols[Len(aCols)][nDesc] :=xMoeda(SC7->C7_VLDESC*SC7->C7_QUANT/nQtdAcla ,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
					Endif
				EndIf
			EndIf
		Endif
		If nPorDesc	 > 0
			If SD1->D1_DESC <> 0
				aCOLS[Len(aCols)][nPorDesc ] := SD1->D1_DESC
			Else
				dbSelectArea("SC7")
				dbSetOrder(1)
				If SC7->(MsSeek(cFilSC7+SD1->D1_PEDIDO+SD1->D1_ITEMPC,.F.))
					aCols[Len(aCols)][nPorDesc] := SC7->C7_DESC
				EndIf
			Endif
		Endif
		If lActBrow
			oGetDados:lNewLine:=.F.
		EndIf
		cPe	:=	LocxPE(35)
		If !Empty(cPe)
			Execblock(cPE,.F.,.F.,)
		EndIf
		AEval(aHeader,{|x,y| If( !(x[10] == "V") .and. aCols[Len(aCols)][y]==NIL,aCols[Len(aCols)][y]:=CriaVar(x[2]),) })
		If cPaisLoc == "COL" .And. nCF>0
			MaFisAlt("IT_CF", aCols[Len(aCols)][nCF], Len(aCols))
		EndIf
		If lActBrow
			MaColsToFis(aHeader,aCols,Len(aCols),"MT100",.T.)
			MafisAlt('IT_FRETE'		,SD1->D1_VALFRE		,Len(aCols))
			MafisAlt('IT_DESPESA'	,SD1->D1_DESPESA	,Len(aCols))
			MafisAlt('IT_DESCONTO'	,SD1->D1_VALDESC	,Len(aCols))
			MafisAlt('IT_SEGURO'	,SD1->D1_SEGURO		,Len(aCols))
		EndIf
		nFrete   += SD1->D1_VALFRE
		nDespesa += SD1->D1_DESPESA
		nDescont += SD1->D1_VALDESC
		nSeguro  += SD1->D1_SEGURO
		If cPaisloc == "RUS"	//(18/07/18): Value from items of remito invoice
			aCols[Len(aCols)][nBsImp1M] := SD1->D1_BSIMP1M
			MafisAlt('IT_BASEIV1_C1',	SD1->D1_BSIMP1M,	Len(aCols))
			aCols[Len(aCols)][nVlImp1M] := SD1->D1_VLIMP1M
			MafisAlt('IT_VALIV1_C1'	,	SD1->D1_VLIMP1M,	Len(aCols))
			aCols[Len(aCols)][nTotalM] := SD1->D1_TOTALM
		EndIF
	Next nI

	If cPaisLoc == "COL" .And. FunName() == "MATA101N" .And. SF1->(ColumnPos("F1_TPACTIV"))
		MaFisRef("NF_TPACTIV", "MT100", M->F1_TPACTIV)
	EndIf

	// Atualizar pasta Gastos com base nos itens do Remito
	If nFrete > 0 .And. ValType(F1_FRETE) == "N"
		M->F1_FRETE := SF1->F1_FRETE + nFrete
	EndIf
	If nSeguro > 0	.And. ValType(F1_SEGURO) == "N"
		M->F1_SEGURO := SF1->F1_SEGURO + nSeguro
	EndIf
	If nDespesa > 0	.And. ValType(F1_DESPESA) == "N"
		M->F1_DESPESA := SF1->F1_DESPESA + nDespesa
	EndIf
	If nDescont > 0 .And. ValType(F1_DESCONT) == "N"
		M->F1_DESCONT := SF1->F1_DESCONT + nDescont
	EndIf
	If lActBrow
		Eval(bDoRefresh)
		oGetDados:obrowse:refresh()
	EndIf
	/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Atualiza o browse de qtde de produtos.³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	AtuLoadQt(.T.)
EndIf
RestArea(aAreaSD1)
Return .T.

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
Function AtuDadosFin(cAliasFin,cAliasHead)
Local cPrefixo:= ""
Local cSeek   := ""
Local nInd    := 0
Local cWhile  :=""
If cAliasHead == "SF1"
	cCondicao    := SF1->F1_COND
	If cAliasFin == "SE2"
		nInd     := 6
		If !Empty(GetMV("MV_2DUPREF"))
			cPrefixo := &(GetMV("MV_2DUPREF"))
		Endif
		cPrefixo := If(Empty(cPrefixo),Criavar("SF1->F1_PREFIXO"),cPrefixo)
		cPrefixo := IIf(Empty(SF1->F1_PREFIXO),cPrefixo,SF1->F1_PREFIXO)
		cSeek    := "'" + xFilial(cAliasFin)+SF1->F1_FORNECE+SF1->F1_LOJA+cPrefixo+SF1->F1_DUPL + "'"
		cWhile   := "E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM=="+cSeek
    Else
		nInd     := 2
		If !Empty(GetMV("MV_2DUPREF"))
			cPrefixo := &(GetMV("MV_2DUPREF"))
		Endif
		cPrefixo := If(Empty(cPrefixo),Criavar("SF1->F1_PREFIXO"),cPrefixo)
		cPrefixo := IIf(Empty(SF1->F1_PREFIXO),cPrefixo,SF1->F1_PREFIXO)
		cSeek    := "'" + xFilial(cAliasFin)+SF1->F1_FORNECE+SF1->F1_LOJA+cPrefixo+SF1->F1_DUPL + "'"
		cWhile   := "E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM=="+cSeek
    EndIf
Else
	cCondicao    := SF2->F2_COND
	If cAliasFin == "SE2"
		nInd     := 6
		If !Empty(GetMV("MV_1DUPREF"))
			cPrefixo := &(GetMV("MV_1DUPREF"))
		Endif
		cPrefixo := If(Empty(cPrefixo),Criavar("SF2->F2_PREFIXO"),cPrefixo)
		cPrefixo := IIf(Empty(SF2->F2_PREFIXO),cPrefixo,SF2->F2_PREFIXO)
		cSeek    := "'" + xFilial(cAliasFin)+SF2->F2_CLIENTE+SF2->F2_LOJA+cPrefixo+SF2->F2_DUPL + "'"
		cWhile   := "E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM=="+cSeek
    Else
		nInd     := 2
		If !Empty(GetMV("MV_1DUPREF"))
			cPrefixo := &(GetMV("MV_1DUPREF"))
		Endif
		cPrefixo := If(Empty(cPrefixo),Criavar("SF2->F2_PREFIXO"),cPrefixo)
		cPrefixo := IIf(Empty(SF2->F2_PREFIXO),cPrefixo,SF2->F2_PREFIXO)
		cSeek    := "'" + xFilial(cAliasFin)+SF2->F2_CLIENTE+SF2->F2_LOJA+cPrefixo+SF2->F2_DUPL + "'"
		cWhile   := "E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM=="+cSeek
    EndIf
EndIf
If cAliasFin == "SE2"
	aRecSE2 := aClone(LocxGrid(cAliasFin,cWhile,,,,cSeek,nInd,,,,)[6])
	aRecSE1 := {}
Else
	aRecSE2 := {}
	aRecSE1 := aClone(LocxGrid(cAliasFin,cWhile,,,,cSeek,nInd,,,,)[6])
EndIf

Eval(bDoRefresh)
Return
/*
±±ºPrograma  ³ATUNUMNF  ºAutor  ³Leandro C. G.       º Data ³  28/02/2002   º±±
±±ºDesc.     ³ Atualiza a numeracao das notas fiscais no arquivo de tabelas º±±
±±ºUso       ³ GravaNfGeral                                                 º±±
Parametros
cNFiscal	- Numero da NF
cSerie		- Serie da NF
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cAliasCF	- Alias do cliente ou fornec. (SA1/SA2)
*/
Function AtuNumNF(cNFis,cSerie,cTipDoc,cAliasCF)
Local cTabela   := ""
Local cChave    := ""
Local cPe		:= ""
Local lRet 		:= .T.
Local lRetPE	:= .T.
Local lSeqEspecie  := SuperGetMV("MV_SEQESPE",,.F.)
Local cFilSX5 := xFilial("SX5")
IF Type("cLocxNFPV") == "U"
	cLocxNFPV:= ""
EndIf
IF Type("cIdPVArg") == "U"
	cIdPVArg:= ""
EndIf

//³Acertando formato da numeracao da NF ³

If cPaisLoc == 'PER'
	cNFis := Soma1(AllTrim(cNFiscal))
Else
	cNFis := Soma1(cNFiscal)
EndIf
cTabela := IIf(lSeqEspecie,"AC","01")
cChave  := IIf(lSeqEspecie,cEspecDoc+cSerie,cSerie)


//³Ponto de Entrada para permitir nao atualizar a numeracao da nota no SX5  ³

cPe	:= LocxPE(47)
If !Empty(cPE)
	If ValType(lRetPE := ExecBlock(cPe, .F., .F.,{cTabela,cChave}) ) == "L"
		lRet := lRetPE
	EndIf
EndIf

DBSelectArea("SX5")
DBSetOrder(1)

//³Efetua atualizacao da numeracao da nota³

If lRet
	If (cPaisLoc == "ARG") .And. !aCfgNF[SlRemito] .And. Empty(cIdPVArg)
		cIdPVArg := POSICIONE("CFH",1, xFilial("CFH")+cLocxNFPV,"CFH_IDPV")
	EndIf

	//Verifica si existe el número de documento en la tabla SF2, si existe, asigna el número siguiente.
	If cPaisLoc == "ARG" .And. !Empty(cSerie) .And. (Type("cFunName")<>"U" .And. cFunName $ "MATA467N") .And. FindFunction("ANumExis")
		While ANumExis(cSerie,cNFis,cLocxNFPV)
			cNFis:= Soma1(cNFis)
		EndDo
	EndIf

	If cPaisLoc == "PAR" .And. !lSeqEspecie .And. FindFunction("CHX5FILPAR") 
		cFilSX5 := CHX5FILPAR(cSerie)  
	Else 
		cFilSX5 := xFilial("SX5")
	Endif

	If DBSeek(cFilSX5+cTabela+AllTrim(cChave) + iif(cPaisLoc=="ARG",cIdPVArg,""))
		RecLock("SX5",.F.)
			Replace X5_DESCRI 	With cNFis
			Replace X5_DESCSPA	With cNFis
			Replace X5_DESCENG	With cNFis
		MsUnLock()
		IF cPaisLoc $ "EUA|PER|EQU|MEX|COL" .and. X5DESCRI() <> cNFis
			X5Descri(,,,,.F.)
		EndIf
	Else
		RecLock("SX5",.T.)
			Replace X5_FILIAL 	With xFilial("SX5")
			Replace X5_TABELA 	With cTabela
			if cPaisLoc == "ARG"
				Replace X5_CHAVE  	With AllTrim(cChave)+ cIdPVArg
			else
				Replace X5_CHAVE  	With cChave
			endif
			Replace X5_DESCRI 	With cNFis
			Replace X5_DESCSPA 	With cNFis
			Replace X5_DESCENG 	With cNFis
		MsUnLock()
	EndIf
	If (cPaisLoc == "RUS")
		FWPutSX5("TRANSL", "01", cSerie, cNFis, cNFis, cNFis, cNFis)
	Endif
EndIf
Return(lRet)
/*
±±³Funcao    ³NFNumNota ³ Autor ³Leandro C. G.          ³ Data ³05.03.2002³±±
±±³Descri‡…o ³Verifica qual a serie de Nota a ser considerada             ³±±
*/
Function NFNumNota()
Local nVezes    := 0
Local nTamNota  := Len(SF2->F2_DOC)
Local lContinua := .T.
Local nTimeOut  := GetNewPar("MV_NOTAOUT",20)*1000
Local nOpcA     := 0
Local aSerNF    := {}
Local cNumero   := ""
Local oDlg
Local oQual
Local oTimer
Local cCadastro  := OemToAnsi(STR0095) //"Notas"
Local cFilSx5	 := xFilial("SX5")
Local lSx5Nota := ExistBlock("SX5NOTA")

Default cSerie 	 := ""

IF Type("__lChgX5Fil") == "U" .OR. __lChgX5Fil == NIl
	__lChgX5FIL := ExistBlock("CHGX5FIL")
Endif

IF __lChgX5FIL
	cFilSx5 := ExecBlock("CHGX5FIL",.f.,.f.)
Endif

//³Trava o parametro do SX6 por seguranca
If ( GetMv("MV_NUMITEN",.T.) )
	If InTransact()
		If !RecLock("SX6",.F.)
			lContinua := .F.
        EndIf
    Else
		While ( lContinua .And. !SX6->(MsRLock()) )
			Inkey(1)
			nVezes++
			If ( nVezes > 200 )
				lContinua := .F.
			EndIf
		EndDo
    EndIf
Else
	lContinua := .F.
EndIf

cTabela := "01"


//³Verifica as series de notas fiscais validas  ³

If ( lContinua )

	//³Posiciona o cliente quando for Argentina³

	cAliasC		:= aCfgNf[SAliasHead]
	cPrefC		:= PrefixoCpo(aCfgNf[SAliasHead])
	cCliFor		:= IIf(cAliasC=="SF1","_FORNECE","_CLIENTE")

	DbSelectArea("SX5")
	dbSetOrder(1)
	MsSeek(cFilSX5+cTabela,.F.)

	While ( SX5->X5_FILIAL == cFilSX5 .AND. SX5->X5_TABELA == cTabela .AND. lContinua )

		//³ Se a S‚rie for CPF, n„o mostra no aChoice, pois ‚ utilizada ³
		//³ internamente para emissao de Cupom Fiscal.                  ³

		If ( AllTrim(SX5->X5_CHAVE) != "CPF" .AND. AllTrim(SX5->X5_CHAVE) != "CP" )
			If !cPaisLoc == "ARG" .OR. (aCfgNf[ScCliFor] == "SA1" .AND. Upper(Alltrim(SX5->X5_CHAVE)) == Upper(AllTrim(cSerie)) )
				nVezes := 0
				If InTransact()
					If !RecLock("SX5",.F.)
						aSerNF    := {}
						lContinua := .F.
                    EndIf
				Else
					While ( !SX5->(MsRLock()) .AND. lContinua )
						nVezes ++
						If ( nVezes > 20 )
							aSerNF    := {}
							lContinua := .F.
						EndIf
					EndDo
                EndIf

				AADD( aSerNF,{PadR(SX5->X5_CHAVE,3),LocConvNota(X5Descri(),nTamNota) })
				If lSx5Nota
					If !ExecBlock("SX5NOTA",.F.,.F.)
						aSize(aSerNF,Len(aSerNF)-1)
					EndIf
				EndIf
			EndIf
		EndIf
		dbSelectArea("SX5")
		dbSkip()
	End
EndIf

//³Montagem da janela de exibicao  ³

If ( Len(aSerNF) != 0 )
	DEFINE MSDIALOG oDlg TITLE cCadastro From 140,320 To 280,560 OF oMainWnd PIXEL
	oTimer:= TTimer():New(nTimeOut,{|| oDlg:End() },oDlg)
	oTimer:Activate()
	@ 001,010 LISTBOX oQual VAR cVarQ ;
		FIELDS HEADER OemToAnsi(STR0138),cCadastro ; //"Serie"
		SIZE 150,100 ;
		ON DBLCLICK (If(NFNumTroca(@aSerNF,oQual:nAt,@oTimer,nTimeOut),oQual:Refresh(),oDlg:End())) NOSCROLL PIXEL
	oQual:SetArray(aSerNF)
	oQual:bLine := { || {aSerNf[oQual:nAT,1],aSerNf[oQual:nAT,2]}}
	DEFINE SBUTTON FROM 051,058 TYPE 1 ACTION (nOpcA := oQual:nAt,oDlg:End()) ENABLE OF oDlg PIXEL
	If ( cModulo!="TMK" )
		DEFINE SBUTTON FROM 051,088 TYPE 2 ACTION (oDlg:End()) ENABLE OF oDlg
	EndIf
	ACTIVATE MSDIALOG oDlg VALID (oTimer:End(),.T.) CENTERED
	If ( lContinua .AND. nOpcA != 0 )
		cSerie := aSerNF[nOpcA][1]
		cNumero:= aSerNF[nOpcA][2]
	Else
		lContinua := .F.
	EndIf
Else
	Help(" ",1,"A460FLOCK")
EndIf

//³Trava o registro escolhido  ³

If ( lContinua )
	dbSelectArea("SX5")
	dbSetOrder(1)
	If ( MsSeek(cFilSX5+"01"+cSerie) )
		nVezes := 0

		If InTransact()
			If !RecLock("SX5",.F.)
				lContinua := .F.
			EndIf
		Else
			While ( !SX5->(MsRLock()) )
				nVezes ++
				If ( nVezes > 10 )
					Help(" ",1,"A460FLOCK")
					lContinua := .F.
				EndIf
			EndDo
        EndIf

		If ( lContinua )
			SX5->X5_DESCRI  := cNumero
			SX5->X5_DESCSPA := cNumero
			SX5->X5_DESCENG := cNumero
		EndIf
	EndIf
EndIf

//³Destrava os registro do SX5 ³

If !InTransact()
	SX5->(MsRUnLock())
EndIf

//³Destrava o parametro  ³

If ( GetMv("MV_NUMITEN",.T.) )
	If !InTransact()
		SX6->(MsRUnLock())
	EndIf
EndIf
Return lContinua

/*
±±ºPrograma  ³ATUNUMIT  ºAutor  ³Leandro C. G.       º Data ³  04/03/2002   º±±
±±ºDesc.     ³ Atualiza o numero e serie das Notas Fiscais nos itens quando º±±
±±º			 ³for alterado o numero ou serie no cabecalho					º±±
*/
Function AtuNumIt(cNumeroNF)
Local nNF,nSerie//,nI
Local cMnf		:= Iif(ValType(cNumeroNF)<> "C","M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC",cNuMeroNF)
Local cMserie	:= IIf(Type("aCfgNf")=="A","M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE","")
Local cNFiscal,cSerie

If Type("aHeader") == "A" .AND. Type("aCols") == "A" .AND. Type("aCfgNf") == "A" .AND. ;
   Type(cMnf) != "U" .AND. Type(cMserie) != "U"
	nNF			:= Ascan(aHeader, { |x| AllTrim(x[2])==PrefixoCpo(aCfgNf[SAliasCols])+"_DOC" })
	nSerie		:= Ascan(aHeader, { |x| AllTrim(x[2])==PrefixoCpo(aCfgNf[SAliasCols])+"_SERIE" })
	cNFiscal	:= &(cMnf)
	cSerie		:= &(cMserie)
	If nNF > 0 .AND. nSerie > 0
		Aeval(aCols, { |x,y| IIf(x[nNF]!=cNFiscal,aCols[y][nNF]:=cNFiscal,), IIf(x[nSerie]!=cSerie,aCols[y][nSerie]:=cSerie,) })
	EndIf
EndIf
Return(.T.)

/*
±±ºPrograma  ³NFCOMIS   ºAutor  ³Leandro C. G.       º Data ³  05/03/2002   º±±

±±ºDesc.     ³ Devolve o valor de comissao padrao referente ao vendedor     º±±
±±º			 ³desejado 														º±±
Parametros: nVend	- numero do vendedor
*/
Function NFComis(nVend)
Local nComis	:= 0			//Valor de comissao retornado pela funcao

/*
aDados		- Clone do aCols + campos de conteudo padrao e obrigatorio
aCpos		- Campos referentes aos itens da Nota
n			- Item atuzal do aCols ou aDados
*/


//³Verifica se todas as variaveis necessarias estao declaradas³

If nVend != NIL .AND. nVend > 0 .AND. Type("n") == "N" .AND. n > 0 .AND. Type("aDados") == "A" .AND.;
   Type("aCpos") == "A"


	//³pos. dos campos nos itens da Nota ³

	nPosProd	:= Ascan(aCpos, "D2_COD")
	nPosClie	:= Ascan(aCpos, "D2_CLIENTE")
	nPosLoja	:= Ascan(aCpos, "D2_LOJA")


	//³Verifica se o vendedor escolhido esta indicado no cabecalho³

	If Type("M->F2_VEND"+AllTrim(Str(nVend))) != "U" .AND. &("M->F2_VEND"+AllTrim(Str(nVend))) != NIL .AND. AllTrim(&("M->F2_VEND"+AllTrim(Str(nVend)))) != ""


		//³Busca comissao conforme indicado no produto³

		SB1->(DBSetOrder(1))
		If nPosProd > 0	.AND. SB1->(MSSeek(xFilial("SB1")+aDados[n][nPosProd]))
			If !Empty(SB1->B1_COMIS) .AND. SB1->B1_COMIS > 0
				nComis := SB1->B1_COMIS
			EndIf
		EndIf

		//³Busca comissao do cliente³

		SA1->(DBSetOrder(1))
		If !(nComis > 0) .AND. nPosClie > 0 .AND. nPosLoja > 0 .AND. SA1->(MSSeek(xFilial("SA1")+aDados[n][nPosClie]+aDados[n][nPosLoja]))
			If !Empty(SA1->A1_COMIS) .AND. SA1->A1_COMIS > 0
				nComis := SA1->A1_COMIS
			EndIf
		EndIf

		//³Busca comissao do vendedor³

		SA3->(DBSetOrder(1))
		If !(nComis > 0) .AND. SA3->(MSSeek(xFilial("SA3")+&("M->F2_VEND"+AllTrim(Str(nVend)))))
			nComis := SA3->A3_COMIS
		EndIf

	EndIf
EndIf
Return(nComis)

/*

±±ºPrograma  ³NFCOMISTOT ºAutor  ³Leandro C. G.       º Data ³  05/03/2002  º±±
±±ºDesc.     ³ Recalcula o valor de comissao padrao referente ao vendedor   º±±
±±º			 ³desejado em todos os itens da NF					   			º±±

±±ºObs       ³ GravaNfGeral                                                 º±±
Parametros: nVend	- numero do vendedor
*/
Function NFComisTot(nVend)
//Local nComis	:= 0			//Valor de comissao retornado pela funcao
Local nSavn		:= IIf(Type("n")=="N",n,0)
Local nI		:= 0

//³Variavel utilizada na funcao NFComis³

Private aDados	:= {}
Private aCpos	:= {}

//³Verifica se todas as variaveis necessarias estao declaradas³

If nVend != NIL .AND. nVend > 0 .AND. Type("aCols") == "A" .AND. Type("aHeader") == "A"

	//³Verifica se o vendedor escolhido esta indicado no cabecalho³

	If Type("M->F2_VEND"+AllTrim(Str(nVend))) != "U" .AND. &("M->F2_VEND"+AllTrim(Str(nVend))) != NIL


		//³pos. do campo de comissao nos itens da Nota |

		nPosComis	:= Ascan(aHeader,{ |x| AllTrim(x[2])=="D2_COMIS"+AllTrim(Str(nVend)) } )

		//³Alterando o valor de comissao em todos os itens³

		If nPosComis > 0
			aDados	:= aClone(aCols)
			aCpos	:= HeaderCpos()
			For nI := 1 to Len(aCols)
				n := nI
				aCols[nI][nPosComis] := NFComis(nVend)
			Next nI
		EndIf

	EndIf
EndIf

//³Restaura numeracao do aCols³

If nSavn > 0
	n := nSavn
EndIf
Return(.T.)

/*
±±ºPrograma  ³ATUCLIFOR  ºAutor  ³Leandro C. G.       º Data ³  06/03/2002  º±±
±±ºDesc.     ³ Atualiza codigo do cliente ou fornec. e da loja nos itens    º±±
±±º			 ³quando alterar o conteudo de cabecalho               			º±±
*/
Function AtuCliFor()
Local nPosCliFor	:= 0				//pos. do campo de cliente no aHeader
Local nPosLoja		:= 0				//pos. do campo de loja no aHeader
Local lCliFor		:= .F.				//Indica se deve atualizar cliente
Local lLoja			:= .F.				//Indica se deve atualizar loja
Local lAltCond		:= .F.
Local lAltNat		:= .F.
Local cCliForLoj	:= ""
Local nI			:= 1 				//#RES pos. do primeiro item do aCols
Local cForNew		:= ""	
Local cForSc7		:= ""   



If Type("lAtuFor") == "U"
	lAtuFor := .F.
Endif

//Se não houve alteracao do fornecedor não e necessario passar pela funcao
If READVAR() == "M->F1_FORNECE" .And. !lAtuFor
	Return .T.
EndIf

If Type("aCfgNf") == "A" .AND. Type("aCols") == "A" .AND. Type("aHeader") == "A" .AND. Len(aCols) > 0

	nPosCliFor 	:= Ascan(aHeader, { |x| AllTrim(x[2])==IIf(aCfgNf[SAliasCols]=="SD2","D2_CLIENTE","D1_FORNECE")	})
	nPosLoja 	:= Ascan(aHeader, { |x| AllTrim(x[2])==IIf(aCfgNf[SAliasCols]=="SD2","D2_LOJA"	,"D1_LOJA")	 	})

	lCliFor 	:= nPosCliFor > 0 .AND. Type(IIf(aCfgNf[SAliasHead]=="SF2","M->F2_CLIENTE","M->F1_FORNECE")) 	!= "U"
	lLoja		:= nPosLoja   > 0 .AND. Type(IIf(aCfgNf[SAliasHead]=="SF2","M->F2_LOJA","M->F1_LOJA")) 		!= "U"

	If cPaisLoc == "COL"  .And. (AllTrim(FunName()) $ "MATA101N|COMA222")
		cForSc7	:= aCols[nI][nPosCliFor]    //#RES pos. do campo fornecedor no Acols após importação pedido
	EndIf

	If cPaisLoc == "ARG"
		xCliForARG(Funname(), nPosCliFor, nPosLoja, aHeader, @aCols, bRefresh, aCfgNf, @_nTotOper_, @_aValItem_)
	EndIf

	If lCliFor .OR. lLoja
		Aeval(aCols, { |x,y| IIf(lCliFor,aCols[y][nPosCliFor]:=IIf(aCfgNf[SAliasHead]=="SF2",M->F2_CLIENTE,M->F1_FORNECE),),IIf(lLoja,aCols[y][nPosLoja]:=IIf(aCfgNf[SAliasHead]=="SF2",M->F2_LOJA,M->F1_LOJA),) })
	EndIf
	//Atualizacao da condicao de pagamento.
	If !Empty(aCfgNf[ScOpFin])
		If aCfgNf[SAliasHead] == "SF2"
			cCliForLoj := M->F2_CLIENTE+M->F2_LOJA
		Else
			cCliForLoj := M->F1_FORNECE+M->F1_LOJA
		EndIf
		If aCfgNf[ScCliFor]=="SA2"
			If SA2->A2_COD+SA2->A2_LOJA <> 	cCliForLoj
				Posicione('SA2',1,xFilial('SA2')+cCliForLoj,"A2_NATUREZ")
			EndIf
			If !Empty(SA2->A2_COND) .AND. (SA2->A2_COND <> cCondicao)
				If FunName() == "FINA100"
					cCondicao := GETMV("MV_FINCPGB", , "498")
				Else
					cCondicao := SA2->A2_COND
				EndIf
				lAltCond  := .T.
			Else
				If FunName() == "FINA100"
					cCondicao := GETMV("MV_FINCPGB", , "498")
					lAltCond := .T.
				EndIf
			EndIf
			If !Empty(SA2->A2_NATUREZ) .AND. (SA2->A2_NATUREZ <> cNatureza)
				cNatureza := SA2->A2_NATUREZ
				lAltNat   := .T.
			EndIf
		Else
			If SA1->A1_COD+SA1->A1_LOJA <> 	cCliForLoj
				Posicione('SA1',1,xFilial('SA1')+cCliForLoj,"A1_NATUREZ")
			EndIf
			If !Empty(SA1->A1_COND) .AND. (SA1->A1_COND <> cCondicao)
				cCondicao := SA1->A1_COND
				lAltCond  := .T.
			EndIf
			If !Empty(SA1->A1_NATUREZ) .AND. (SA1->A1_NATUREZ <> cNatureza)
				cNatureza := SA1->A1_NATUREZ
				lAltNat  := .T.
			EndIf
		EndIf

		//Atualiza dados do Folder Financeiro...
		If (lAltCond .Or. lAltNat) .And. (Type('lLocxAuto') == 'U' .Or. !lLocxAuto)
			Eval(bDoRefresh)
		EndIf
	EndIf

EndIf

If cPaisLoc == "EUA"
	xCliForEUA(aCfgNf)
EndIf

If cPaisLoc == "COL"
	xCliForCol(aCfgNf, @cTASARTF)

	If FunName() == "MATA101N"
		cForNew		:= M->F1_FORNECE 	//#RES variável de memória do proveedor em tempo de execução
		
		If !Empty(cForSc7) .And. cForNew <> cForSc7 .and. FINDFUNCTION('LocxAtuAcols')
			LocxAtuAcols(aHeader, @aCols) //#RES function que executa limpeza do aCols quando o proveedor do cabeçalho da factura é diferente do provedor do pedido importado
		EndIf
	EndIf
EndIf

If cPaisLoc == "PAR"
	xCliForPAR()
EndIf

Return(.T.)
/*
±±ºPrograma  ³LocXVal º±±
cVar - caracter - campo a ser validado.
lExResh - logico - Indica si debe ser realizado el refresh del objeto visual.
lModel - logico - Indica si la función está siendo llamada desde una rutina de mvc.
*/
Function LocXVal(cVar,lExResh, lModel)
Local cAux,lRet,aNF,lAltNota, dDataFec
Local lSeqEspecie := SuperGetMV("MV_SEQESPE",,.F.)
Local cChaveSX5   := ""
Local cCAEA		:= ""
Local dCAEAVENC	:= CTOD("\\")
Local aCFD        := {"",""}
Local aRetCF      := {}
Local aDados      := {"","",""}
Local lContrFol   := .F. // Controle de Folios - Uruguai
Local cNCF 		:= "" //Controle folios Numero NCF - Rep. Dom
Local lFunCAEE		:= .T.
Local lSF2CAEE		:= cPaisloc == "ARG"
Local lSF1CAEE		:= cPaisloc == "ARG"
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local cSerieAlt:= ""
Local lOpcQW   := .T.
Local nQtdItem := 0
Local lPermite := .T.
Local lChkNumNF	:= (FindFunction("LxChkNumNF") .And. cPaisLoc <> "MEX")
Local lValDupNF	:= FindFunction("LxValDupNF")
Local lDocSpNCP	:= FindFunction("LxDocSpNCP")
Local lLocXFat  := .F.
Local cFilSX5   := xFilial("SX5")
Local aPtoEmi	:= {}
Local lSX5MINU  := FindFunction("VldSX5MINU")
Local lfActNFis := (cPaisLoc=="CHI" .AND. FindFunction("fActNFis")  )

If Type("lDocSp") == "U"
	Private lDocSp := .F.
EndIf
DEFAULT lExResh:=.T.
If cPaisLoc $ "ARG|PAR|CHI" .and. IsInCallStack("MATA143") .Or. (cPaisLoc $ "ARG|PAR|CHI" .And. IsBlind())
	bRefresh := { || {|| Iif(Type("bDoRefresh") <> "B",{|| Nil},Eval(bDoRefresh))}}
	bDoRefresh := { || {||  LxA103Dupl(MaFisRet(,"NF_BASEDUP"),nMoedaCor,dDEmissao,cCondicao,@aTemp,oList,@oNatu,@oDescri,@oCond,@oMoeda,@cNatureza,@cDescri,oNew )}}
EndIF

IF Type("cLocxNFPV") == "U"
	cLocxNFPV:= ""
EndIf

Default cVar=ReadVar()
Default lModel := .F.
dDataFec := MVUlmes() // Verificar data do ultimo fechamento

// Controle de Folios - Bolivia
If cPaisLoc == "DOM" .AND. (cVar == Substr(cVar,1,3)+"DOC" .OR. cVar == Substr(cVar,1,3)+"SERIE") // Republica Dominicana
	lContrFol := GetNewPar("MV_CTRLFOL",.T.)
	If (!lContrFol) .AND. lInclui
		MsgAlert(STR0285)
	EndIf
ElseIf cPaisloc == "ARG"
	lContrFol     :=	aCfgNf[SlFormProp] .and. ((AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720|MATA462N|MATA462DN|MATA462R") .Or. ChkProp("ControlFolios")) .And. GetNewPar("MV_CTRLFOL",.F.)
ElseIf cPaisloc $ "EQU|VEN|PAR"
	lContrFol:=	((AllTrim(FunName())$"MATA468N|MATA467N|MATA462N|MATA465N|MATA466N|MATA101N") .Or. ChkProp("ControlFolios")) .And. GetNewPar("MV_CTRLFOL",.F.)
Else
	lContrFol     := cPaisLoc == "BOL" .And. ((AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720") .and. ChkProp("ControlFolios")) ;
	                 .And. GetNewPar("MV_CTRLFOL",.F.)
EndIf

lRet:=.T.
lAltNota := .F.

Do Case
	Case cVar=="F2_DOC"
		cNFiscal:= M->F2_DOC
		cSerie	:=M->F2_SERIE
		If lContrFol
			aDados[1] := cSerie
			aDados[2] := M->F2_ESPECIE
			aDados[3] := cNFiscal
			If !cPaisLoc$'ARG|EQU|VEN|PER|DOM|PAR'
				aRetCF := RetCF(aDados)
				M->F2_NUMAUT := aRetCF[1]
				M->F2_CODCTR := aRetCF[2]
				M->F2_LIMEMIS:= aRetCF[3]
			EndIf
		Endif
		If aCfgNf[SlFormProp] .OR. (cPaisLoc == "COL" .AND. cFunName == "MATA466N" .AND. aCfgNF[SnTipo] == 22)
			If lGerarCFD .and. cPaisLoc <> "PAR"
				lRet := (CFDChkFol(cFilAnt,cSerie,cNFiscal,@aCFD,.F.,.T.,M->F2_ESPECIE) < 2)
				M->F2_APROFOL := aCFD[1]
				M->F2_CERTFOL := aCFD[2]
			Endif
			If lContrFol .And. cPaisloc == "ARG"
				lRet := ChkFolARG(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE, M->F2_PV)
			ElseIf lContrFol .And. cPaisloc=="EQU"
				lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE)
			ElseIf lContrFol .And. cPaisLoc $ "VEN|PAR" //Correcao
				lRet := CtrFolios(cFilAnt,cSerie,M->F2_ESPECIE,cnFiscal)
			ElseIf lContrFol .And. cPaisloc=="DOM"
				If (Trim(M->F2_ESPECIE) $ "NF|NCI|NDI|NCC|NDC")
					cNCF := ChkFolDOM(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE)
					lRet := (cNCF!="")
					M->F2_NCF := cNCF
				EndIf
			ElseIf lContrFol .and. cPaisLoc == "URU"
				lRet := ChkFolURU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE)
			ElseIf lContrFol .And. cPaisLoc =="BOL" .and. FindFunction("CtrFolBol")
				lRet := CtrFolBol(cFilAnt,cSerie,M->F2_ESPECIE,cnFiscal)
			EndIf

			If lRet .And. AllTrim(M->F2_ESPECIE) $ "NF/NDC" .AND. IIf(Type("lFiscal")== "L" .And. lFiscal, (SuperGetMv("MV_CONTNFI",,"I") == "M"), .T. )
				If lUsaNewKey
					lRet := VldSX5Num(cNFiscal,SerieNfId("SF2",4,"F2_SERIE",M->F2_EMISSAO,M->F2_ESPECIE,cSerie))
				Else
					lRet := VldSX5Num(cNFiscal,cSerie)
				Endif
			EndIf
			If lRet .And. lValDupNF
				lRet := LxValDupNF(cSerie, cNFiscal, "SF2")	// Valida si existe número en cualquier sucursal, si SX5 es compartida 
			EndIf
			If cPaisLoc == "COL" .And. FunName() $ 'MATA466N' .And. lDocSpNCP
				lRet := LxDocSpNCP(cSerie, @cNFiscal)
				M->F2_DOC := cNFiscal
			EndIf
			If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF2CAEE
				lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F2_ESPECIE,M->F2_EMISSAO,@cCaea,@dCAEAVENC)
				M->F2_CAEE 	:= cCaea
				M->F2_EMCAEE 	:= dCAEAVENC
			Endif
		Endif
		LocxAtuFis(.T.,cNFiscal)
		MaFisAlt('NF_SERIENF',cSerie)
		If lExResh
		Eval(bRefresh)
		EndIf
	Case cVar=="F2_SERIE"
		cNFiscal:=M->F2_DOC
		If cPaisLoc=="ARG" .and. aCfgNf[SlFormProp] .and. Type("M->F2_PV")=="C" .and. !Empty(M->F2_PV)
		   cSerieAlt:=Subs(Alltrim(SX5->X5_CHAVE),1,Len(Alltrim(SX5->X5_CHAVE))- (TAMSX3("CFH_IDPV")[1]) )
		   If !Empty(cSerieAlt)
		   	M->F2_SERIE  :=cSerieAlt
		   EndIf
		EndIf

		cSerie  :=M->F2_SERIE
		If lContrFol
			aDados[1] := cSerie
			aDados[2] := M->F2_ESPECIE
			aDados[3] := cNFiscal
			If !cPaisLoc $'ARG|EQU|VEN|PER|DOM|PAR'
				aRetCF := RetCF(aDados)
				M->F2_NUMAUT := aRetCF[1]
				M->F2_CODCTR := aRetCF[2]
				M->F2_LIMEMIS:= aRetCF[3]
			EndIf
		Endif
		If (aCfgNf[SlFormProp] .And. FunName()<>"FISA828") .OR. (cPaisLoc == "COL" .AND. cFunName == "MATA466N" .AND. aCfgNF[SnTipo] == 22)
			If lGerarCFD .and. cPaisLoc <> "PAR"
				lRet := (CFDChkFol(cFilAnt,cSerie,cNFiscal,@aCFD,.T.,.F.,M->F2_ESPECIE,.T.) < 2)
				M->F2_APROFOL := aCFD[1]
				M->F2_CERTFOL := aCFD[2]
			Endif
			// Controle de Folios do Uruguai
			If lContrFol .And. cPaisloc=="EQU"
				lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE,@aPtoEmi,.T.)
			ElseIf lContrFol .And. cPaisLoc $ "VEN|PAR"
				lRet := CtrFolios(cFilAnt,cSerie,M->F2_ESPECIE,cnFiscal)
			ElseIf lContrFol .And. cPaisLoc $ "BOL"
				lRet := CtrFolBol(cFilAnt,cSerie,M->F2_ESPECIE,cnFiscal)
			EndIf

			If lRet
				SX5->(dbSetOrder(1))
				cChaveSX5  := IIf(lSeqEspecie,"AC"+cEspecDoc+cSerie,"01"+cSerie)
				If  cPaisLoc = "ARG" .And. !aCfgNf[SlRemito]
					cChaveSX5  :="01"+AllTrim(cSerie) + POSICIONE("CFH",1, xFilial("CFH")+cLocxNFPV,"CFH_IDPV")
				EndIf

				If cPaisLoc == "PAR" .And. !lSeqEspecie .And. FindFunction("CHX5FILPAR") 
					cFilSX5 := CHX5FILPAR(cSerie)  
				Else 
					cFilSX5 := xFilial("SX5")
				Endif
			
				If ! SX5->(dbSeek(cFilSX5+cChaveSX5))
					Help(" ",1,"A467SERIE")
					lRet:=.f.
				Else
					cNFiscal	:=	Alltrim(X5DESCRI())
					//Controle de Folios da Rep. Dom utiliza F2_DOC na geracao do NCF
					If lContrFol .And. cPaisloc=="DOM"
						If (Trim(M->F2_ESPECIE) $ "NF|NCI|NDI|NCC|NDC")
							cNCF := ChkFolDOM(cFilAnt,cSerie,cNFiscal,cNFiscal,lLocxAuto,M->F2_ESPECIE)
							lRet := (cNCF!="")
							M->F2_NCF := cNCF
						EndIf
					EndIf
					// Valida consecutivo
					If cPaisLoc == "COL" .And. cFunName $ 'MATA466N' .And. lDocSpNCP
						lRet := LxDocSpNCP(cSerie, @cNFiscal)
					EndIf
					If lRet .And. lChkNumNF
						cNFiscal := LxChkNumNF(cSerie, cNFiscal, "SF2")
					EndIf
				    M->F2_DOC := cNFiscal
				EndIf
			EndIf

			If lContrFol .And. cPaisloc == "ARG"
				If !Empty(cNFiscal)
					lRet := ChkFolARG(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE,M->F2_PV)
				EndIf
			EndIf
			If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF2CAEE
				lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F2_ESPECIE,M->F2_EMISSAO,@cCaea,@dCAEAVENC)
				M->F2_CAEE 	:= cCaea
				M->F2_EMCAEE 	:= dCAEAVENC
			Endif

		Endif
		LocxAtuFis(.F.,cNFiscal)
		If  cPaisloc == "ARG" .AND. FUNNAME() == "FINA096" .AND. lRet
			MaFisAlt('NF_SERIENF',cSerie)
		Endif
		Eval(bRefresh)
	Case cVar=="F1_DOC"
    	cNFiscal := M->F1_DOC
		If cPaisLoc =="EUA" .And. AllTrim(M->F1_ESPECIE) == "NCC" .And. cFunName =="MATA465N" .And. FindFunction("LxVlNDocEUA")
			lRet := LxVlNDocEUA(M->F1_DOC,M->F1_SERIE,.T.)
			cNFiscal:= M->F1_DOC
		EndIf
		cSerie	:=M->F1_SERIE
		If aCfgNf[SlFormProp]
			If lGerarCFD .and. cPaisLoc <> "PAR"
				lRet := (CFDChkFol(cFilAnt,cSerie,cNFiscal,@aCFD,.F.,.T.,M->F1_ESPECIE) < 2)
				M->F1_APROFOL := aCFD[1]
				M->F1_CERTFOL := aCFD[2]
			Endif
			If lContrFol .And. cPaisloc == "ARG"
				lRet := ChkFolARG(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE, M->F1_PV)
			ElseIf lContrFol .And. cPaisloc=="EQU"
				lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE)
			ElseIf lContrFol .And. cPaisLoc $ "VEN|PAR"
				lRet := CtrFolios(cFilAnt,cSerie,M->F1_ESPECIE,cnFiscal)
			ElseIf lContrFol .And. cPaisLoc $ "BOL"
				lRet := CtrFolBol(cFilAnt,cSerie,M->F1_ESPECIE,cnFiscal)
			ElseIf lContrFol .And. cPaisloc=="DOM"
				If (Trim(M->F1_ESPECIE) $ "NCC")
					cNCF := ChkFolDOM(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE)
					lRet := (cNCF!="")
					M->F1_NCF := cNCF
				EndIf
			ElseIf lContrFol .and. cPaisLoc == "URU"
				lRet := ChkFolURU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE)
			EndIf

			If lRet .And. AllTrim(M->F1_ESPECIE) $ "NF/NCC" .AND. IIf(Type("lFiscal")== "L" .And. lFiscal, (SuperGetMv("MV_CONTNFI",,"I") == "M"), .T. )
			IF lSX5MINU
					 lRet:=VldSX5MINU(cNFiscal,cSerie,M->F1_ESPECIE)
				ELSE
				If lUsaNewKey
					lRet := VldSX5Num(cNFiscal,SerieNfId("SF1",4,"F1_SERIE",M->F1_EMISSAO,M->F1_ESPECIE,cSerie))
				Else
					lRet := VldSX5Num(cNFiscal,cSerie)
				Endif
			ENDIF
			EndIf
			If lRet .And. lValDupNF
				lRet := LxValDupNF(cSerie, cNFiscal, "SF1",M->F1_ESPECIE)	// Valida si existe número en cualquier sucursal, si SX5 es compartida 
			EndIf
			If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF1CAEE
				lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F1_ESPECIE,M->F1_EMISSAO,@cCaea,@dCAEAVENC)
				M->F1_CAEE 	:= cCaea
				M->F1_EMCAEE 	:= dCAEAVENC
			Endif
		Endif
		IF (cPaisLoc=="PAR") .AND. lAutoFact .AND. (ALLTRIM(FunName())$"MATA101N" .Or. ChkProp("Autofactura")) .and. !EMPTY(M->F1_SERIE) .AND. !EMPTY(M->F1_DOC) .AND. FindFunction("CtrFolAutPAR")
			lRet:=CtrFolAutPAR(cFilAnt,M->F1_SERIE,"1",M->F1_DOC)
		ENDIF
		
		LocxAtuFis(.T.,cNFiscal)
		If (cPaisLoc <> "RUS")
			MaFisAlt('NF_SERIENF',cSerie)
		Endif
		If lExResh
			Eval(bRefresh)
		EndIf
	Case cVar=="F1_SERIE"
    	cNFiscal:=M->F1_DOC
		If cPaisLoc=="ARG"   .and. aCfgNf[SlFormProp]  .and. Type("M->F1_PV")=="C" .and. !Empty(M->F1_PV) .and. !lModel
			cSerieAlt:=Subs(Alltrim(SX5->X5_CHAVE),1,Len(Alltrim(SX5->X5_CHAVE))- (TAMSX3("CFH_IDPV")[1]) )
		   If !Empty(cSerieAlt)
		   	M->F1_SERIE  :=cSerieAlt
		   EndIf
		EndIf
		cSerie  :=M->F1_SERIE
		If aCfgNf[SlFormProp] .OR. (cPaisLoc == "COL" .AND. (lDocSp .OR. aCfgNF[SnTipo] == 23) .AND. ((cFunName $ "MATA101N|MATA466N") .Or. ChkProp("DocumentoSoporte"))  )
			If lGerarCFD .and. cPaisLoc <> "PAR"
				lRet:=(CFDChkFol(cFilAnt,cSerie,cNFiscal,@aCFD,.T.,.F.,M->F1_ESPECIE,.T.) < 2)
				M->F1_APROFOL := aCFD[1]
				M->F1_CERTFOL := aCFD[2]
			Endif

			// Controle de Folios
			If lContrFol .And. cPaisloc=="EQU" .And. !lModel
				lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE,@aPtoEmi,.T.)
			ElseIf lContrFol .And. cPaisLoc $ "VEN|PAR"
				lRet := CtrFolios(cFilAnt,cSerie,M->F1_ESPECIE,cnFiscal)
			ElseIf lContrFol .And. cPaisLoc $ "BOL"
				lRet := CtrFolBol(cFilAnt,cSerie,M->F1_ESPECIE,cnFiscal)
			EndIf

			If lRet
				SX5->(dbSetOrder(1))
				cChaveSX5  := IIf(lSeqEspecie,"AC"+cEspecDoc+cSerie,"01"+cSerie)
				If cPaisLoc = "ARG" .and. !aCfgNf[SlRemito]
					cChaveSX5  :="01"+AllTrim(cSerie) + POSICIONE("CFH",1, xFilial("CFH")+cLocxNFPV,"CFH_IDPV")
				EndIf

				If cPaisLoc == "PAR" .And. !lSeqEspecie .And. FindFunction("CHX5FILPAR") 
					cFilSX5 := CHX5FILPAR(cSerie)  
				Else 
					cFilSX5 := xFilial("SX5")
				Endif

				If ! SX5->(dbSeek(cFilSX5+cChaveSX5))
					Help(" ",1,"A467SERIE")
					lRet:=.f.
				Else
					cNFiscal	:=	Alltrim(X5DESCRI())
					// Valida consecutivo
					If lChkNumNF
						cNFiscal := LxChkNumNF(cSerie, cNFiscal, "SF1")
					EndIf
					If lModel .and. lGerarCFD .and. cPaisLoc <> "PAR"
						lRet := (CFDChkFol(cFilAnt,cSerie,cNFiscal,@aCFD,.T.,.F.,M->F1_ESPECIE) < 2)
						If lRet
							M->F1_APROFOL := aCFD[1]
							M->F1_CERTFOL := aCFD[2]
							M->F1_DOC:=	cNFiscal
						Endif
					ElseIf lContrFol .And. cPaisloc=="EQU" .And. lModel
						lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE,@aPtoEmi,.T.)
						If lRet 
							M->F1_DOC:=	cNFiscal
						EndIf	
					Else
						M->F1_DOC:=	cNFiscal
					Endif

					If Len(aPtoEmi) >= 2
						If SF1->(ColumnPos("F1_PTOEMIS")) > 0 
							M->F1_PTOEMIS  := aPtoEmi[1]
						EndIf
						If SF1->(ColumnPos("F1_ESTABL")) > 0 
							M->F1_ESTABL  := aPtoEmi[2]
						EndIf
					EndIf
					
					//Controle de Folios da Rep. Dom utiliza F1_DOC na geracao do NCF
					If lContrFol .And. cPaisloc=="DOM"
						If (Trim(M->F1_ESPECIE) $ "NCC")
							cNCF := ChkFolDOM(cFilAnt,cSerie,cNFiscal,cNFiscal,lLocxAuto,M->F1_ESPECIE)
							lRet := (cNCF!="")
							M->F1_NCF := cNCF
						EndIf
					EndIf
				EndIf
			EndIf
			If lContrFol .And. cPaisloc == "ARG"
				If !Empty(cNFiscal)
					lRet := ChkFolARG(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE, M->F1_PV)
				EndIf
			EndIf
			If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF1CAEE
				lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F1_ESPECIE,M->F1_EMISSAO,@cCaea,@dCAEAVENC)
				M->F1_CAEE 	:= cCaea
				M->F1_EMCAEE 	:= dCAEAVENC
			Endif
			If lRet .And. cPaisLoc == "COL" .And. cFunName == "MATA466N" .And. aCfgNF[SnTipo] == 23
				fSerDocCol() // Asegura consecutivo correcto
			EndIf
		Endif
		IF (cPaisLoc=="PAR") .AND. lAutoFact .AND. ((ALLTRIM(FunName())$"MATA101N") .Or. ChkProp("Autofactura")) .AND. FindFunction("CtrFolAutPAR")
			lRet:=CtrFolAutPAR(cFilAnt,M->F1_SERIE,"1",M->F1_DOC)
		ENDIF
		IF lfActNFis
			lRet:=	fActNFis(M->F1_SERIE,@M->F1_DOC,@cNFiscal,lAutoFact)
		ENDIF

		LocxAtuFis(.F.,cNFiscal)		
		If lExResh
			Eval(bRefresh)
		EndIf
	Case Right(cVar,6)=="_MOEDA"
		If cPaisLoc == "MEX" .And. (AllTrim(FunName()) $ "MATA101N|MATA102N")
			If nMoedaNF	<> &cVar.
				AEval(aCols, {|x,y| If(!Empty(aCols[y][3]), nQtdItem++,.T.)})
				If nQtdItem > 0
					lOpcQW := MsgYesNo(OemToAnsi(STR0415),OemToAnsi(STR0097)) //"Al modificar la moneda del documento los ítems serán limpiados. ¿Desea continuar?" //"Atención"
					If !(lOpcQW .And. nMoedaNF <> &cVar.)
						lRet := .F.
						lPermite := .F.
					EndIf
				EndIf
			Else
				lPermite := .F.
			EndIf
		EndIf
		If lPermite
			nMoedaNF	:=	&cVar.
			If cVar == "F1_MOEDA"
				If &cVar. <> M->F1_MOEDA
					nMoedaNF := M->F1_MOEDA
				EndIf
			EndIf
			If cPaisloc=="RUS" .AND. Left(cVar,2) == "F1"
				nTaxa	:=RecMoeda(M->F1_EMISSAO,nMoedaNF)
			Elseif cPaisloc=="RUS" .AND. Left(cVar,2) == "F2"
				nTaxa	:=RecMoeda(dDEmissao,nMoedaNF)
			Else
				nTaxa	:=RecMoeda(dDataBase,nMoedaNF)
			EndIf
			cAux		:="M->"+Left(cVar,2)+"_TXMOEDA"
			&cAux		:=nTaxa
			If cPaisLoc == "RUS"
				MaFisAlt("NF_TXMOEDA",nTaxa)
				If Left(cVar,2) == "F1"	//(29/05/18): For recalculation values in Main currency (in Rubles) when F1_MOEDA change F1_TXMOEDA
					ExcRt101N()
				ElseIf  Left(cVar,2) == "F2"	//(29/05/18): For recalculation values in Main currency (in Rubles) when F2_MOEDA change F2_TXMOEDA
					ExcRt467N()
				EndIf
			EndIf
			//Moeda para a duplicata
			nMoedaCor	:=	nMoedaNF
			MaFisAlt("NF_MOEDA",nMoedaNF)
			If cPaisLoc <> "RUS"
				If AllTrim(FunName()) $ "MATA101N|MATA102N|MATA102DN" .Or. (cPaisLoc $ "ARG|CHI|PAR|URU|BOL" .And. AllTrim(FunName()) $ "MATA465N|MATA466N")
					LocxAtuMoeda(aHeader,@aCols)
				EndIf
			EndIf
			If lExResh
				Eval(bRefresh)
			EndIf
		EndIf
	Case Right(cVar,8)=="_TXMOEDA"
		If  cPaisLoc != "RUS" .or. nTaxa != &cVar
			nTaxa		:=	&cVar
			MaFisAlt("NF_TXMOEDA",nTaxa)
			If cPaisLoc=="RUS".and. AllTrim(FunName()) == "MATA101N"
				ExcRt101N()
			EndIf
			If cPaisLoc=="RUS".and. AllTrim(FunName()) == "MATA467N"
				ExcRt467N()
			EndIf
			If lExResh
				Eval(bRefresh)
			EndIf
		EndIf
	Case cVar=="F2_LOJA"  .AND. aCfgNf[SlFormProp]
		If cPaisLoc == "ARG" .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
			If M->F2_ECF <> "S"
				aNF:=LocXFatAut()
			Else
				aNF    := {"",LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie])}
				aNF[1] := GetNumCFis(aNF[2],aCfgNf[ScEspecie])
			EndIf
			lAltNota := .T.
		Else
			lLocXFat := cPaisLoc == "COL" .And. aCfgNF[SnTipo] == 22
			If Empty(M->F2_DOC) .and. cPaisLoc <> "PAR" .And. !lLocXFat
				aNF := LocXFatAut()
				lAltNota := .T.
			EndIf
		EndIf
		If lAltNota
			If Len(aNF)==0
				lRet:=.F.
			Else
				cNFiscal	:=	aNF[1]
				cSerie := Padr(aNF[2],TAMSX3("F2_SERIE")[1])

				If lContrFol .And. cPaisloc=="EQU"
					lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE,@aPtoEmi,.T.)
				EndIF
				
				If lRet 
					M->F2_DOC	:=cNFiscal
					M->F2_SERIE	:=cSerie
					If lGerarCFD
						M->F2_APROFOL := aNF[3]
						M->F2_CERTFOL := aNF[4]
					Endif

					If SF2->(ColumnPos("F2_SERIE2")) > 0 .And. Len(aNF) >= 5
						M->F2_SERIE2  := aNF[5]
					EndIf

					If Len(aPtoEmi) >= 2
						If SF2->(ColumnPos("F2_PTOEMIS")) > 0 
							M->F2_PTOEMIS  := aPtoEmi[1]
						EndIf
						If SF2->(ColumnPos("F2_ESTABL")) > 0 
							M->F2_ESTABL  := aPtoEmi[2]
						EndIf
					EndIf

					MaFisAlt('NF_SERIENF',cSerie)
					Eval(bRefresh)
				EndIf
				
			Endif
		Endif
	Case cVar=="F2_LOJA" .AND. !aCfgNf[SlFormProp] .AND. cPaisLoc =="ARG"
		cSerie:= LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie]) // Trazer a serie automat.  para o documento
		MaFisAlt("NF_SERIENF",cSerie)
		M->F2_SERIE	:=	cSerie
	Case cVar=="F1_LOJA" .AND. aCfgNf[SlFormProp] .and. !lModel
		If cPaisLoc == "ARG" .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
			If M->F1_ECF <> "1"
				aNF:=LocXFatAut()
			Else
				aNF    := {"",LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie])}
				aNF[1] := GetNumCFis(aNF[2],aCfgNf[ScEspecie])
			EndIf
			lAltNota := .T.
		Else
			lLocXFat := cPaisLoc == "COL" .And. (aCfgNF[SnTipo] == 23 .Or. lDocSp)
			If Empty(M->F1_DOC) .And. !lLocXFat
				aNF := LocXFatAut()
				lAltNota := .T.
			EndIf
		EndIf
		If lAltNota
			If Len(aNF)==0
				lRet:=.F.
			Else
				cNFiscal	:=	aNF[1]
				cSerie		:=	Padr(aNF[2],TAMSX3("F1_SERIE")[1])

				If lContrFol .And. cPaisloc=="EQU"
					lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE,@aPtoEmi)
				EndIF
				
				If lRet 
					M->F1_DOC	:=	cNFiscal
					M->F1_SERIE	:=	cSerie
					If lGerarCFD
						M->F1_APROFOL := aNF[3]
						M->F1_CERTFOL := aNF[4]
					Endif

					If SF1->(ColumnPos("F1_SERIE2")) > 0 .And. Len(aNF) >= 5
						M->F1_SERIE2  := aNF[5]
					EndIf

					If Len(aPtoEmi) >= 2
						If SF1->(ColumnPos("F1_PTOEMIS")) > 0 
							M->F1_PTOEMIS  := aPtoEmi[1]
						EndIf
						If SF1->(ColumnPos("F1_ESTABL")) > 0 
							M->F1_ESTABL  := aPtoEmi[2]
						EndIf
					EndIf

					MaFisAlt('NF_SERIENF',cSerie)
					If lExResh
						Eval(bRefresh)
					EndIf
				EndIf				
				
			Endif
		Endif
	Case cVar=="F1_LOJA"  .AND. !aCfgNf[SlFormProp]	.AND. cPaisLoc =="ARG"
		cSerie:= LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie]) // Trazer a serie automat.  para o documento
		MaFisAlt("NF_SERIENF",cSerie)
		M->F1_SERIE	:=	cSerie
	Case cVar=="F1_ECF" .AND. aCfgNf[SlFormProp] .AND. cPaisLoc =="ARG" .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
		If M->F1_ECF == "1"
			cSerie:= LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie]) // Trazer a serie automat.  para o documento
			M->F1_SERIE	:=	cSerie
			cNFiscal := GetNumCFis(cSerie,aCfgNf[ScEspecie])
			M->F1_DOC := cNFiscal
			LocxAtuFis(.T.,cNFiscal)
			Eval(bRefresh)
		Else
			cSerie:= ""
			M->F1_SERIE	:=	cSerie
			cNFiscal := ""
			M->F1_DOC := cNFiscal
			LocxAtuFis(.T.,cNFiscal)
			Eval(bRefresh)
		EndIf
	Case cVar=="F2_ECF" .AND. aCfgNf[SlFormProp] .AND. cPaisLoc =="ARG" .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
		If M->F2_ECF == "S"
			cSerie:= LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie]) // Trazer a serie automat.  para o documento
			M->F2_SERIE	:=	cSerie
			cNFiscal := GetNumCFis(cSerie,aCfgNf[ScEspecie])
			M->F2_DOC := cNFiscal
			LocxAtuFis(.T.,cNFiscal)
			Eval(bRefresh)
		Else
			cSerie:= ""
			M->F2_SERIE	:=	cSerie
			cNFiscal := ""
			M->F2_DOC := cNFiscal
			LocxAtuFis(.T.,cNFiscal)
			Eval(bRefresh)
		Endif
	Case cVar=="F1_EMISSAO"
		If M->F1_EMISSAO > dDatabase
			Help("",1,"A100DATAM")
			lRet  := .F.
		Endif
		If lRet .And. cPaisloc=="ARG" .And. Upper(Alltrim(M->F1_SERIE))=="M"
			If !Empty(SA2->A2_DTINISM) .And. !Empty(SA2->A2_DTFIMSM) .And. (M->F1_EMISSAO < SA2->A2_DTINISM .or. M->F1_EMISSAO > SA2->A2_DTFIMSM)
				MsgAlert(STR0266,STR0018)
				lRet  := .F.
			EndIf
		EndIf
		If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF1CAEE
			lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F1_ESPECIE,M->F1_EMISSAO,@cCaea,@dCAEAVENC)
			M->F1_CAEE 	:= cCaea
			M->F1_EMCAEE 	:= dCAEAVENC
		Endif
		If cPaisLoc == "RUS" .And. !(cEspecie $ "NCC/NDP")	//(06/06/2018): Change Currency according to Date
			If &cVar. <> dMemoryDate .AND. ExcRt101N(.F.)
				cAux	:= "M->F1_TXMOEDA"
				&cAux	:= RecMoeda(M->F1_EMISSAO,M->F1_MOEDA)
				nTaxa	:= RecMoeda(M->F1_EMISSAO,nMoedaNF)
			EndIf
		EndIf
	Case cVar=="F2_EMISSAO"
		If M->F2_EMISSAO > dDatabase
			Help("",1,"A100DATAM")
			lRet  := .F.
		Endif
		If dDataFec >= M->F2_EMISSAO .And. cEspecie<>"NCP"
	   		Help( " ", 1, "FECHTO" )
			lRet  := .F.
		EndIf
		If lRet .And. cPaisloc=="ARG" .And. Upper(Alltrim(M->F2_SERIE))=="M"
			If !Empty(SA2->A2_DTINISM) .And. !Empty(SA2->A2_DTFIMSM) .And. (M->F2_EMISSAO < SA2->A2_DTINISM .or. M->F2_EMISSAO > SA2->A2_DTFIMSM)
				MsgAlert(STR0266,STR0018)
				lRet  := .F.
			EndIf
		EndIf
		If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF2CAEE
			lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F2_ESPECIE,M->F2_EMISSAO,@cCaea,@dCAEAVENC)
			M->F2_CAEE 	:= cCaea
			M->F2_EMCAEE 	:= dCAEAVENC
		Endif
	Case cVar=="F2_DTSAIDA"
		If cPaisLoc =="RUS" .AND. !Empty(&(cVar)) .AND. ValType(M->F2_DTSAIDA)== "D"
			dMemoryDate:=dDEmissao
			dDEmissao:=M->F2_DTSAIDA
			lRet := RU05X0005_(M->F2_EMISSAO,M->F2_DTSAIDA)

			If lRet .And. !(cEspecie $ "NDC/NCP") .And. M->F2_MOEDA != 1
				If dMemoryDate!=&cVar .AND. ExcRt467N(.F.)
					cAux	:="M->F2_TXMOEDA"
					&cAux	:=RecMoeda(M->F2_DTSAIDA,M->F2_MOEDA)
					nTaxa	:=RecMoeda(M->F2_DTSAIDA,nMoedaNF)
					Eval(bRefresh)
				EndIf
			EndIf
		EndIf
	Case Right(cVar,7)=="TASARFT"
		If cVar == "F1_TASARFT"
			If &cVar. <> cTASARTF
				cTASARTF := &cVar.
				If AllTrim(FunName()) == "MATA101N"
					LOCXATUBASE(aHeader,@aCols)
				EndIf
				Eval(bRefresh)
			EndIf
		EndIf
	Case cVar=="F2_NFREF" .and. cPaisLoc=="CHI" 
		IF cEspecie $ "NDC" .AND. FindFunction("fClearNDC")  .AND.  Type("oGetDados")=="O" .AND.  Type("oBSomaItens")=="O"
			fClearNDC(aHeader,@aCols,M->F2_NFREF,aCfgNF,oGetDados,oBSomaItens)
		ENDIF
EndCase
Return lRet
/*
±±³Funcao    ³NFNumTroca  ³ Autor ³Eduardo Riera        ³ Data ³14.03.2002³±±
±±³Descri‡…o ³Efetua a Troca do Numero da Nota                            ³±±
±±³Retorno   ³ExpA1: Series de NF de Saida.           			          ³±±
±±³Parametros³ExpA1: Array com as series da NF                  		  ³±±
±±³          ³ExpN2: Item da Nota de Saida                                ³±±
±±³          ³ExpO3: Objeto Timer                                         ³±±
±±³          ³ExpN4: Time Out.                                            ³±±

*/
Function NFNumTroca(aSerNf,nItem,oTimer,nTimeOut)
Local cCadastro := OemToAnsi(STR0139) //"Numero"
Local oTimer2
Local cNumero   := aSerNf[nItem][2]
Local lContinua := .T.

oTimer:Deactivate()

DEFINE MSDIALOG oDlg TITLE cCadastro From 12,60 To 15,77 OF oMainWnd
oTimer2 := TTimer():New(nTimeOut,{|| lContinua := .F.,oDlg:End() },oDlg)
oTimer2:Activate()
@ .8,.8 MSGET cNumero PICTURE "@!" WHEN Substr(cAcesso,50,1) == "S" VALID !Empty(cNumero)
DEFINE SBUTTON FROM 10,166  TYPE 1 ACTION oDlg:End() ENABLE OF oDlg
ACTIVATE MSDIALOG oDlg

oTimer:Activate()

aSerNf[nItem][2] := cNumero
Return(lContinua)
/*
Descri‡…o ³Tela/Gravação motivo de anulação na NF (Loc. Rep Dom)
*/
Function LocxMotAnu(cAlias)
Local oDlg
Local nRet := 0
Local aComboMot := {""}
Local oComboMot
Local cComboMot
Local oTButtonOk
Local oTButtonCc
Local lRet := .T.
Local aArea
Local cFilSX5	:= xFilial("SX5")
If cPaisloc=="DOM" .AND. (cAlias)->(FieldPos(PrefixoCpo(cAlias)+"_NCF")) > 0 .AND. Type("M->"+PrefixoCpo(cAlias)+"_NCF") == "C" .AND. Trim( &((cAlias)->(PrefixoCpo(cAlias)+"_NCF")) ) <> ""
	If !lAnulaSF3
		Aviso( STR0018,STR0283,{STR0021})	//ATENCAO#"Não é permitida a exclusão de notas fiscais"#OK
		lRet := .F.
	Else
		aArea := GetArea()
		DbSelectArea("SX5")
		DbSetOrder(1)
		If DbSeek(cFilSX5+"AV")
			While !Eof() .AND. X5_FILIAL == cFilSX5 .AND. X5_TABELA == "AV"
				AAdd(aComboMot,(TRIM(X5_CHAVE)+"="+X5Descri()))
				DbSkip()
			End
		EndIf
		oDlg := MSDialog():New(0,0,50,540,STR0284,,,,,,,,,.T.) // Motivo Anulacao
		oDlg:lEscClose := .F.
	    oComboMot := TComboBox():New(5,10,{|u|if(PCount()>0,cComboMot:=u,cComboMot)},;
	                         aComboMot,195,20,oDlg,,;
	                         ,,,,.T.,,,,,,,,,'cComboMot')
		oTButtonOk := TButton():New( 5, 210, STR0021 ,oDlg,{||iif(!Empty(cComboMot),(nRet:=1,oDlg:End()),)},25,10,,,.F.,.T.,.F.,,.F.,,,.F. ) // OK
		oTButtonCc := TButton():New( 5, 240, STR0189 ,oDlg,{||nRet:=1,lRet:=.F.,oDlg:End()},25,10,,,.F.,.T.,.F.,,.F.,,,.F. ) // Cancelar
		oDlg:Activate(,,,.T.,{||Iif(nRet==1,.T.,.F.)},,)

		If (lRet)
			//Gravado em matxfis
			LcSetTAnu(Val(cComboMot))
		EndIf
		RestArea(aArea)
	EndIf
EndIf
Return lRet
/*
±±³Funcao    ³LocxDelNF   ³ Autor ³Guilherme / Leandro C.G.³Data ³14.03.2002³±±
±±³Descri‡…o ³Chamada da Exclusao de Notas Fiscais                          ³±±
*/
Function LocxDelNF(cAlias,nRecno,lMostraCtb,lAglCtb,lContab,lCarteira,lTela,lPerg,lRSAuto,cFunName)
Local lRet       := .T.
Local lValido    := .T.
Local aRecSC5    := {}
Local aPedPV     := {}
Local cArquivo   := ""
Local aArea,aAreaItem,nQtdItem,cChaveItem
Local aAreaSalva, aCfgNFSalva, aCusto
Local nRegSF1    := 0
Local aItem      := {}
Local aItens     := {}
Local aCab       := {}
Local aRecnoI    := {}
Local aAreaSD2   := {}
Local nAuto      := 0
Local aStruSDB   := SDB->(DBSTRUCT())
Local nPosEstor  := Ascan(aStruSDB,{|x| x[1] == 'DB_ESTORNO'})
Local lRastro    := .F.
Local cLoteSDA   := ""
Local lContinua  := .T.
//Local aRecSF8    := {}
Local lVerPad695 := VerPadrao('695') //Exclusão dos Itens da Nota Entrada
Local lVerPad687 := VerPadrao('687') //Exclusão Total da Nota Entrada
Local lVerPad697 := VerPadrao('697') //Exclusão dos Itens da Nota Debito
Local lVerPad689 := VerPadrao('689') //Exclusão Total da Nota Debito
Local lVerPad698 := VerPadrao('698') //Exclusão dos Itens Remito de Entrada
Local lVerPad690 := VerPadrao('690') //Exclusão Total Remito de Entrada
Local lVerPad655 := VerPadrao('655')
Local lVerPad665 := VerPadrao('665')
Local lVerPad995 := VerPadrao('995')
Local lVerPad975 := VerPadrao('975')
Local lVerPad711 := VerPadrao('711')
Local lVerPad721 := VerPadrao('721')
Local cLoteCom   := IIf(Found(),Trim(X5DESCRI()),"COM ")
Local lAtuEstoq  := .T.
Local cDepTrf    := Padr(SuperGetMv("MV_DEPTRAN",.F.,"95"),TamSX3("D3_LOCAL")[1]) // Dep.transf.
Local lEICFinanc := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.) 	// Integracao SIGAEIC - Financeiro
Local cMyNumFor
Local cAliasImp
Local nPosRec
Local aTiposOrig := { {01,"MATA467N/MATA468A/MATA468N/MATA460/MATA461/MATA460B/ATFA036" },;
                       {02,"MATA465N"},{03,"MATA465N"},{04,"MATA465N"},;
                       {05,"MATA465N"},{06,"MATA466N"},{07,"MATA466N"},;
                       {08,"MATA466N/LOCXNCE/COMA224"},{09,"MATA466N/LOCXNDE/COMA223"},{10,"MATA101N/MATA100/MATA447/MATA143/LOCXNFE/COMA222"},;
                       {11,"MATA101N/MATA100"},{12,"MATA101N/MATA100"},;
                       {13,"MATA101N/MATA100/MATA119N/MATA447/MATA143/COMA222"},{14,"MATA101N/MATA100/MATA116N/MATA447/MATA143/COMA222"},;
                       {15,"MATA463N"},{17,"MATA467N"},{18,"MATA467N"},{19,"MATA467N"},;
                       {20,"MATA101N/MATA100/COMA222"},{22,"MATA466N"},{23,"MATA466N/COMA223"},{24,"MATA465N"}}
Local cFilOrig   := ""
Local cOrigFin   := ""
Local cCondIf    := ""
Local aRecIMP    := {}
Local nI         := 0
Local nX         := 0
Local uRet       := NIL
Local aCtbDia    := {}
Local cStatusDBA := "1"
Local cItemAtf   := ""
Local aPedsDesp  := {}
Local nForDesp   := 0
Local lAjustaNCD := SuperGetMV( "MV_ATFNCRD", .F., .F. )
Local nRecSD1AUT := 0
Local aDadSfe    := {}
Local aArea2     := GetArea()
Local cDoc       := SF1->F1_DOC
Local cSer       := SF1->F1_SERIE
Local lTX        := .T.
//Local lVer116    := .T.
Local cFilSB1    := xFilial("SB1")
Local cFilSC7    := xFilial("SC7")
Local cFilSD1    := xFilial("SD1")
Local cFilSD2    := xFilial("SD2")
Local cFilSD3    := xFilial("SD3")
Local cFilSDA    := xFilial("SDA")
Local cFilSDB    := xFilial("SDB")
Local cFilSF1    := xFilial("SF1")
Local cFilSF4    := xFilial("SF4")
Local cFilSWN    := xFilial("SWN")
Local cFilDBB    := xFilial("DBB")
Local lNGMNTES   := GetNewPar("MV_NGMNTES","N") == "S"
Local lIntACD    := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local cAuxPaisL  := ""
Local lRetCC     := .T.
Local dDataBloq  := GetNewPar("MV_ATFBLQM",CTOD("")) //Data de Bloqueio da Movimentação - MV_ATFBLQM
Local dDataRef   := CTOD("  /  /  ")
Local aAuxAGH    := {}
Local a711       := {}
Local a721       := {}
//Local cAliCampo	 := Right(cAlias, 2)
Local cLvroRetC  := SuperGetMV("MV_LVRORIC",,"") //Número de libro para ret. de IVA al % (Ecuador)
Local lF817NCC	 := .F.
Local cMotCan    := ""
Local cDocCan    := ""
Local cSerCan    := ""
Local cNomXml    := ""
Local cUUID      := ""
Local cCanEst	 := ""
Local cCanAcep	 := ""
Local cCodProvS  := ""
Local cLojaS     := ""
Local lShowHelp  := (FunName() == "MATA447" .And. IsInCallStack("MATA447") .And. IsInCallStack("MATA447B"))
Local cMVVeiculo := SuperGetMv("MV_VEICULO",.F.,"N")
Local lMvLocBac		:= SuperGetMv("MV_LOCBAC",.F.,.F.) //Integração com Módulo de Locações SIGALOC
Local lFcLOCM009	:= FindFunction("LOCM009") // Função de Integração Exclusão de Item Note de Entrada
Local lFcLOCM002    := FindFunction("LOCM002") // Função de Integração Exclusão da Nota (Fatura ou Remito)

Private nHdlPrv	:= 0	//Guarda a evolucao da funcao HeadProva
Private nTotalLcto 	:= 0

DEFAULT lTela		:=	.F.
DEFAULT lPerg		:=	.T.
DEFAULT lRSAuto  	:=	.F.
Default cFunName    := FunName()

If Type("aRatVei") == "U"
	aRatVei := {}
EndIf
If Type("aRatFro") == "U"
	aRatFro := {}
EndIf
If Type("aDupl") == "U"
	aDupl := {}
EndIf

lF817NCC := (cFunName$"FISA817" .And. ValType("nTipo") <> "U" .And. nTipo == 3) //Cancelar NCC desde FISA817

aCfgNF   := MontaCfgNf(Val(&(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead]) + "_TIPODOC")) ,aCfgNF[SaPergs],lTela)
NFSetPrv(aCfgNF)
cOrigFin :=	IIf(Ascan(aTiposOrig,{|x| x[1] == aCfgNf[SnTipo]})==0,"",aTiposOrig[Ascan(aTiposOrig,{|x| x[1] == aCfgNf[SnTipo]})][2])

Private lMSErroAuto	:=	.F.

//³Verifica se o usuario tem permissao de delecao. ³
aArea2 := GetArea()
SD1->(DbSeek(cFilSD1+cDoc+cSer))
While !SD1->(Eof()) .And. lRet .And. SD1->D1_DOC == cDoc .And. SD1->D1_SERIE == cSer
	If IsInCallStack("MATA102N") .Or. ChkProp("RemitoPermisoBorrado") // Remito de Entrada
		lRet := MaAvalPerm(1,{SD1->D1_COD,"MT102N",5})
	ElseIf IsInCallStack("MATA101N") .Or. ChkProp("FacturaPermisoBorrado") // Factura de Entrada
		lRet := MaAvalPerm(1,{SD1->D1_COD,"MT101N",5})
	EndIf
	SD1->(dbSkip())
End
RestArea(aArea2)
If !lRet
	Help(,,1,'SEMPERM')
EndIf

//Verifica se existe bloqueio contábil
If !(Empty(SF1->F1_EMISSAO))  .And. cAlias <> "SF2"
	dDataRef := SF1->F1_EMISSAO
ElseIf !(Empty(SF2->F2_EMISSAO)) .And. cAlias == "SF2"
	dDataRef := SF2->F2_EMISSAO
EndIf

If lRet .And. !(Empty(dDataRef)) .And. (lRet := CtbValiDt(Nil,dDataRef,/*.T.*/ ,Nil ,Nil ,{"COM001"}/*,"Data de apuração bloqueada pelo calendário contábil."*/))
	If!Empty(dDataBloq) .AND. (dDataRef <= dDataBloq)
		Help(" ",1,"ATFCTBBLQ") //P: Processo bloqueado pelo Calendário Contábil ou parâmetro de bloqueio nesta data ou período. S: Caso possível altere a data de referência do processo, verifique o parâmetro ou contate o responsável pelo Módulo Contábil.)
		lRet := .F.
	End
EndIf

If SIX->(MsSeek("SEU7")) .And. nNFTipo == 10
	DbSelectArea("SEU")
	DbSetOrder(7)
	If MsSeek(xFilial("SEU")+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_DOC+SF1->F1_SERIE)
		SET->(dbSetOrder(1))
		SET->(MsSeek(xFilial("SET")+SEU->EU_CAIXA))
		If SET->ET_SITUAC != "0" .Or. (cPaisLoc <> "ARG" .and. !Empty(SEU->EU_BAIXA)) //O registro de gasto gerado a partir da NF já vem baixado. - ARG
			Help(" ",1,"FA560BAIXA")
			lRetCC := .F.
		EndIf
	EndIf
EndIf

//³ Ponto de Entrada para permitir ou não a excluir facturas que possuam caixinha vinculadas.                                |

If lRet .And. ExistBlock("LOCCADEL")
	uRet := ExecBlock("LOCCADEL" , .F. , .F.)
	If valtype(uRet) == "L"
		lRet := uRet
		If !lRet
			Alert(STR0281)
			Return lRet
		EndIf
	EndIf
EndIf

If valtype(uRet) != "L" .And. !lRetCC
	lRet := .F.
EndIf

If cPaisLoc == "MEX" .And. cFunName == "MATA467N" .And. cAlias == "SF2" .And. SF2->(ColumnPos("F2_FLFTEX")) > 0 
	If SF2->F2_FLFTEX $ "7|8|9"
		MsgAlert( STR0455 ) //"Factura cancelada fuera de periodo. La factura no puede ser borrada "
		Return .F.
	EndIf
EndIf
If cPaisLoc == "MEX" .And. cFunName $ "MATA467N|MATA465N"
	If ( cAlias == "SF2" .And. SF2->(FieldPos("F2_UUID")) > 0 .And. !Empty(SF2->F2_UUID) ) .Or. ;
		( cAlias == "SF1" .And. SF1->(FieldPos("F1_UUID")) > 0 .And. !Empty(SF1->F1_UUID) )
		MsgAlert( STR0405 ) // "Para borrar/anular documentos timbrados utilice la rutina Cancelación de CFDI."
		Return .F.
	EndIf
EndIf

If cPaisLoc == "EQU" .And. FindFunction("LxCertEQU") 
	If ((cFunName == "MATA101N") .Or. ChkProp("ValidCertificadoBorrado"))
		If LxCertEQU(SF1->F1_FORNECE, SF1->F1_LOJA, SF1->F1_PREFIXO, SF1->F1_SERIE, SF1->F1_DOC)
			Return .F. //"Esta factura no puede ser borrada debido a que tiene un Certificado de Retención vigente. Primero, debe borrar el Certificado de Retención, a través de la rutina Certif. Retenc. (FISA015)."
		EndIf
	ElseIF cAlias== "SF2" .And. Alltrim(SF2->F2_ESPECIE) == "NF" .And. SF2->F2_TPVENT == "1"
		If FindFunction("ObtProvCli") 
			ObtProvCli(@cCodProvS, @cLojaS, SF2->F2_CLIENTE,SF2->F2_LOJA )
		Endif
		If LxCertEQU(cCodProvS,cLojaS, SF2->F2_PREFIXO, SF2->F2_SERIE, SF2->F2_DOC)
			Return .F. //"Esta factura no puede ser borrada debido a que tiene un Certificado de Retención vigente. Primero, debe borrar el Certificado de Retención, a través de la rutina Certif. Retenc. (FISA015)."
		EndIf
	Endif
EndIf

If lRet
	lRet:= Iif(cPaisLoc == "ARG".And. cFunName <> "MATA143" , ExcluiCCr(cAlias,nRecno) , lRet) //Chamada da função que verifica se a NF pode ser excluida depois de transmitir para a afip ## Valida C. Corrente
EndIf
If cPaisLoc == "RUS"
	If SuperGetMV("MV_WMSNEW",.F.,.F.) .and. lRet .And. cAlias =="SF1" .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE == "S" .And. FindFunction("WmsValEsMI") .And. IntWMS()
		If !WmsValEsMI()
			Return .F.
		EndIf
	EndIf
else
	If lRet .And. cAlias =="SF1" .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE == "S" .And. FindFunction("WmsValEsMI") .And. IntWMS()//Integração WMS - Validação do Estorno da Ordem de Serviço
		If !WmsValEsMI()
			Return .F.
		EndIf
	EndIf
EndIf
If lRet .And. (IIf(lPerg == .T. , MsgYesNo(OemToAnsi(STR0096),OemToAnsi(STR0097)), .T.))  //"Confirma estorno do documento ?"###"Aten‡„o"

	If cPaisLoc == "COL" .And. cFunName $ "MATA467N|MATA465N|"
	 	lRet := LxVldFact(cAlias)
	EndIf
	If cPaisLoc == "COL" .And. ((cFunName == "MATA466N") .Or. ChkProp("ValidaNotaAjusteBorrado")) .And. (aCfgNf[SnTipo] == 22 .Or. aCfgNf[SnTipo] == 23)
	 	lRet:=LxVldFact(cAlias, .T.)
	EndIf
	If cPaisLoc == "COL" .And. ((cFunName == "MATA101N") .Or. ChkProp("ValidFacturaBorrado"))
		lRet := LxVldFact(cAlias)
	EndIf
	//PE - Permite validar exclusao do documento
	If ExistBlock("LOCXVLDDEL") .And. lRet
		uRet := ExecBlock( "LOCXVLDDEL" , .F. , .F. , {cAlias} )
		If valtype(uRet) == "L"
			lRet := uRet
		EndIf
	EndIf
	If lRet .And. cPaisLoc = "MEX"
		lRet := LxDelNfMex(cAlias)
	EndIf
	If lRet .And. cPaisLoc == "PER"
		lRet := LxDelNFPer(cAlias, lLocxAuto, cFunName)
	EndIf
	If lRet .And. cPaisLoc == "EQU"
		lRet := LxDelNfEqu(aCfgNf, cAlias, lDeleta, cFunName)
	EndIf
	If lRet .And. cPaisLoc == "BOL"
		lRet := LxDelNfBol(cAlias, lLocxAuto, cFunName)
	EndIf
	If lRet .And. cPaisLoc == "URU"
		lRet := LxDelNfUru(cAlias, lDeleta)
	EndIf
	If lRet .And. cPaisLoc == "EUA"
		LxDelNfEUA(cFunName)
	EndIf
	If cPaisLoc == "DOM"
		If (lRet .AND. !LocxMotAnu(cAlias))
			lRet := .F.
		EndIf
	EndIf
	If lRet .And. cPaisLoc == "PAR" .And. FINDFUNCTION('LxDelNfPar')
		lRet := LxDelNfPar(aCfgNf, lDeleta, lAnulaSF3, cFunName)
	EndIf
	If lRet
		If cPaisLoc $ "VEN" .And. lDeleta
			aDadSFE:={}
			If cAlias == "SF1" .And. !Alltrim(SF1->F1_ESPECIE)$"NDE/NCC"
				aAdd(aDadSFE,{"",0,"",0,0,0,SF1->F1_DOC,SF1->F1_SERIE,"E",SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_ESPECIE,"",SF1->F1_NATUREZ})
			ElseIf cAlias == "SF2" .And. Alltrim(SF2->F2_ESPECIE)$"NDI/NCP/NF"
				aAdd(aDadSFE,{"",0,"",0,0,0,SF2->F2_DOC,SF2->F2_SERIE,"S",SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_ESPECIE,"",SF2->F2_NATUREZ})
		    Endif
			lRet:=FGrvSFE("5",aDadSfe)
			If !lRet
				Return lRet
			Endif
		Endif

		//Exclusão de ajuste do valor do bem por notas de Crédito ou Débito
		If lAjustaNCD .And. lDeleta
			If cEspecie $ "NCP|NDP|NCI|NDI"
				IF cPaisLoc!="ARG"
					If !A103ExAjNC( cAlias )
						lRet := .F.
						Return lRet
					EndIf
				Else
					aAreaSD2:= SD2->(GetArea())
					SD2->(dbSelectArea("SD2"))
					SD2->(dbSetOrder(3))
				    cChave := xFilial("SF2") + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA
					aAreaSF4:= SF4->(GetArea())
					IF (SD2->(MsSeek( cChave )) )

						While SD2->(!Eof()) .And.;
		      				cChave == xFilial("SF2") + SD2->D2_DOC + SD2->D2_SERIE + SD2->D2_CLIENTE + SD2->D2_LOJA

							If SF4->(MsSeek(xFilial("SF4")+SD2->D2_TES))

								IF SF4->F4_ATUATF=='S'
									If !A103ExAjNC( cAlias )
										lRet := .F.
										Return lRet
									EndIf
								End

							EndIf

							SD2->(dbSkip())
							EndDo

				 	ENDIF
					SF4->(RestArea(aAreaSF4))
					SD2->(RestArea(aAreaSD2))
				EndIf
		   	EndIf
		EndIf

		//³ Estorna o PR0 para quando o apontamento for gerado atraves do remito de entrada |
		lRet := MTEstornPR(SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA)
		Do Case
		Case cAlias == "SF2"
			aAreaSalva	:= GetArea()
			SD2->(dbSetOrder(3))
			If SD2->(MsSeek(cFilSD2+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA));
				.AND. (SD2->D2_TPDCENV == _RMCONS)
				SF1->(DbSetOrder(1))
				If SF1->(MsSeek(cFilSF1+SF2->F2_NFORI+SF2->F2_SERIORI+SF2->F2_CLIENTE+SF2->F2_LOJA+"B"))
					nRegSF1	:= SF1->(Recno())
				EndIf
			EndIf
			If !Empty(SF2->F2_DTLANC)
				lContab := .T.
			EndIf
			If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
				If (SF2->F2_TIPODOC == "54") .AND. (AllTrim(SF2->F2_ESPECIE) == "RTS") .AND. (SF2->F2_TIPORET == "1")
					SF1->(DbSetOrder(1))
					If SF1->(MsSeek(cFilSF1+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA+"N"))
						While !SF1->(Eof()) .AND. (cFilSF1+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA+"N" == ;
						      SF1->F1_FILIAL+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+"N")

							If (SF1->F1_TIPODOC == "64") .AND. (AllTrim(SF1->F1_ESPECIE) == "RTE")
	      						nRegSF1	:= SF1->(Recno())
								MsgInfo(STR0237)  //"O remito de entrada, correspondente ao remito de saida escolhido pelo usuario, sera excluido automat.mente."
						      	Exit
						 	Else
						    	SF1->(dbSkip())
							EndIf
						End
						// Caso tenha sido encontrado o remito de entrada, realiza a
						// exclusao do mesmo.
						If nRegSF1 > 0
							SF1->(MsGoto(nRegSF1))
							aCfgNFSalva	:= aClone(aCfgNF)
							aCfgNF 		:= MontaCfgNf(64,aCfgNF[SaPergs],.F.)
							lRet    := LocxDelNF("SF1",nRegSF1,lMostraCtb,lAglCtb,lContab,lCarteira,.F.,.F.,.T.)
							aCfgNF  := aClone(aCfgNFSalva)
							nRegSF1 := 0
						EndIf
						// Caso o usuario tenha optado em abortar o processo, eh necessario
						// tambem interromper a exclusao do remito de saida.
						If !lRet
							Return(lRet)
						EndIf
					EndIf
				EndIf
			EndIf
			RestArea(aAreaSalva)

			cPe	:=	LocxPE(26)
			If !Empty(cPE)
	 			If !ExecBlock(cPE,.F.,.F.)
					Return .F.
	 			Endif
	 		EndIf
			//³ Verifica se o estorno do documento de saida pode ser feito     ³
			aRegSD2 := {}
			aRegSE1 := {}
			aRegSE2 := {}
			If lValido .AND. MaCanDelF2(cAlias,SF2->(RecNo()),@aRegSD2,@aRegSE1,@aRegSE2,cOrigFin)
				If cPaisLoc == "COL" .AND. cFunName $ "MATA467N|MATA465N|" .and. SF2->(FieldPos("F2_FLFTEX"))>0
					If (Val(SF2->F2_FLFTEX) <> 0 .OR. !Empty(SF2->F2_FLFTEX))
						IF SF2->F2_FLFTEX == "6" .OR. !Empty(SF2->F2_UUID)
							MsgAlert(STR0401) // "El documento ya fue autorizado por la DIAN, utilice una Nota de Crédito para Anular Factura"
							Return .F.
						EndIf
					EndIf
				EndIf
				cPe	:=	LocxPE(27)
				If !Empty(cPE)
	 				ExecBlock(cPE,.F.,.F.)
				Else
					If __lPyme .And. ExistBlock( "LOCXS327" , .F. , .T. )
						Execblock( "LOCXS327" , .F. , .F. )
					EndIf
	 			EndIf

				//Integra?o com M?ulo de Loca?es SIGALOC
				If lMvLocBac .and. lFcLOCM002
					LOCM002()
				EndIf

				If cPaisLoc == "GUA"
	                //³Verificar se deve gerar NCC para anulacao de docs. do ERP ³
	                If AllTrim(aCfgNf[ScEspecie])=="NF"
	                	//"Deseja gerar Nota de Credito para esta operacao de cancelamento de NF?"
	                    //"Uma Nota de Credito nao deve ser gerada quando o pagamento nao foi efetuado ou "
	                    //"na ocorrencia de erro na impressao do documento."
	                    lGeraNCC  := MsgYesNo(STR0228+chr(13)+STR0229+chr(13)+STR0230)
	                EndIf
	                If lGeraNCC
	                	//³ Valida se o numero da Nota de Credito eh valido pela SAT - Loc. Guatemala³
	                	If !LocxSATNCC()
							Return .F.
	                	EndIf
	                 	//³ A gravacao do motivo da devolucao eh Obrigatoriedade fiscal - Loc. Guatemala³
	                 	If !LocxMotDev()
	                    	Return .F.
		              	EndIf
	                  	//³ Armazena os dados da NF em array para gravacao futura ³
	                  	//³ da Nota de Credito - Loc. Guatemala                   ³
			          	aDadosSF2  := {SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_MOEDA,SF2->F2_TXMOEDA,;
			                         SF2->F2_COND}

			          	aAreaItem  := SD2->(GetArea())
			          	aDadosSD2  := {}
			          	For nI:= 1 to Len(aRegSD2)
			            	SD2->(MsGoto(aRegSD2[nI]))
				         	Aadd(aDadosSD2,{SD2->D2_COD,SD2->D2_UM,SD2->D2_QUANT,SD2->D2_PRCVEN,SD2->D2_TOTAL,;
				                         SD2->D2_LOCAL,SD2->D2_TES})
			          	Next nI
			          	RestArea(aAreaItem)
			        EndIf
				EndIf

				If !aCfgNF[SlRemito]

					//³ Retorna o remito de saida ³

					aArea    :=GetArea()
					aAreaItem:=SD2->(GetArea())
					SD2->(DbSetOrder(3))
					For nI:= 1 to Len(aRegSD2)
						SD2->(MsGoto(aRegSD2[nI]))
						cChaveItem  := cFilSD2+SD2->D2_REMITO+SD2->D2_SERIREM+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMREM
						nQtdItem    := SD2->D2_QUANT
						If !Empty(SD2->D2_REMITO) .AND. SD2->(MsSeek(cChaveItem))
							NFAtuSCN(nQtdItem,-1)
						EndIf
					Next nI
					RestArea(aAreaItem)
					RestArea(aArea)
				EndIf
				
				//Executar somente se tipo de documento diferente de transferencia e Devolução fornecedor.
				If cPaisLoc == "ARG" .and. cTipo $ "N|D|B" .And. !(AllTrim(cEspecie) $ "RTS|RCD|NCP") .And. FindFunction("WmsEsIntM2")
					WmsEsIntM2()
				EndIf

				//³Cancela a baixa dos titulos com pagamento a vista.³

				CaBxAutSE1(aCfgNf[ScAliasFin],,cAlias)

				If lUsaCor .And. !Empty(SF2->F2_NUMCOR)//libera o numero correlativo
					CORR_EXCL(SF2->F2_DTDIGIT,SF2->F2_NUMCOR)
				Endif

				If aCfgNf[ScAliasFin]=="SE2"
					ApagTitImp(cAlias)
				EndIf

				//³Loop para guardar numero dos registros da tabela SD2 a serem eliminados e atualização da tabela-espelho ³

				For nx := 1 to Len(aRegSD2)
	   				AAdd( aRecnoI, { aRegSD2[nx] } )

				Next nx

				//Si es la anulación de un Remito de Salida, para Argentina y con los asientos configurados 711 Y 721, ejecuta la contabilidad.
				If lRet .And. lVerPad711 .And. lVerPad721 .And. cPaisLoc == "ARG" .And. AllTrim(aCfgNf[ScEspecie]) == "RTS"
					aAdd(a711, {"711"})
					aAdd(a721, {"721"})

					CtbilNF(aCfgNf[SAliasHead],aCfgNf[SAliasCols],SF2->(RecNo()),aRecnoI,a711[1],a721[1],lMostraCtb,lAglCtb)
				EndIf

				//³Lancto.PCO  	  ³

				For nx := 1 to Len(aRegSD2)
	   				AAdd( aRecnoI, { aRegSD2[nx] } )
				Next nx
				PcoLancto(aCfgNf[SAliasHead],aCfgNf[SAliasCols],nRecno,aRecnoI,aCfgNf[SaLancPCO][1],aCfgNf[SaLancPCO][2],aCfgNf[SaLancPCO][4],aCfgNf[SaLancPCO][3], .F./*lInclui*/, .T./*lDeleta*/)

				For nx := 1 to Len(aRegSD2)
					dbSelectArea('SD2')
					MsGoto(aRegSD2[nx])
	   				aAuxAGH := BuscaAGH()
					LxaSD2AtuSDE(2,aClone(aAuxAGH[3]),aClone(aAuxAGH[2]),aClone(aAuxAGH[1]),LxA103Custo(nx,aCfgNf[SlRemito]))
				Next nx


				//³ Estorna o documento de saida.                                  ³
				//³ Se for nota de consignacao forca o parametro MV_PDEVLOC como 1 ³
				//³ para devolver o produto na localizacao original.               ³

				If ( nRegSF1 > 0 ) // IF -> alteracao conforme BOPS 66.670
					cAuxPaisL := "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
					SF2->(MaDelNFS(aRegSD2,aRegSE1,aRegSE2,lMostraCtb,lAglCtb,lContab,lCarteira,,1	,IIf(cPaisLoc $ cAuxPaisL,SF2->F2_DIACTB,)))
				Else
					SF2->(MaDelNFS(aRegSD2,aRegSE1,aRegSE2,lMostraCtb,lAglCtb,lContab,lCarteira,,,IIf( cPaisLoc $ cAuxPaisL,SF2->F2_DIACTB,)))
				Endif

				If aCfgNf[SAliasHead]=="SF1"
					aDadSFE:={}
					If cPaisLoc $ "VEN"
						If (SF1->F1_VALIMP2+SF1->F1_VALIMP3+SF1->F1_VALIMP4)>0 .OR. SF1->F1_VALIMP6>0
						   	Aadd(aDadSFE,{.F.,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE})
					   		FGrvCrt(1,aDadSFE)
					   	EndIf
					ElseIf (cPaisLoc $ "EQU" .AND. cFunName <> "MATA143")
						If ((SF1->F1_BASIMP2 + SF1->F1_BASIMP3 + SF1->F1_BASIMP4 + IIf(!Empty(cLvroRetC) ;
							.And. !(AllTrim(cLvroRetC) $ "2|3|4"), SF1->&("F1_BASIMP" + AllTrim(cLvroRetC)),0)) > 0 .OR. SF1->F1_VALIMP6 >= 0) .And. !(AllTrim(Str(nNFTipo)) $ "60|61|64|54|07")
						   	Aadd(aDadSFE,{.F.,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE})
					   		FGrvCrt(1,aDadSFE)
					   	EndIf
					ElseIf cPaisloc == "CHI"
						If SF1->F1_VALIMP5 > 0 ///retencao de honorario
						   	Aadd(aDadSFE,{.F.,"",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,"RHO",0,0,0,SF1->F1_ESPECIE})
		   					GrvRetSFE(1,aDadSFE)
					   	Endif
					ElseIf cPaisloc == "COS"
						If SF1->F1_VALIMP5 > 0 ///retencao de IR
						   	Aadd(aDadSFE,{.F.,"",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,"RIR",0,0,0,SF1->F1_ESPECIE})
		   		   			GrvRetSFE(1,aDadSFE,.F.,.T.)
					   	Endif
					EndIf
				Endif

				If aCfgNf[SAliasHead]=="SF2"
					aDadSFE:={}
					If cPaisLoc $ "VEN" .And. Alltrim(SF2->F2_ESPECIE) == "NCP"
						If (SF2->F2_VALIMP2+SF2->F2_VALIMP3+SF2->F2_VALIMP4)>0 .OR. SF2->F2_VALIMP6>0
						   	Aadd(aDadSFE,{.F.,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE})
						   	FGrvCrt(2,aDadSFE)
					   	Endif
					EndIf
				Endif

				// Actualiza cantidad por clasificar en remitos
				If !aCfgNF[SlRemito] .And. aCfgNf[SAliasHead] == "SF2" .AND. SF2->F2_TIPO == "D" .AND. SF2->F2_TIPODOC == "07" .AND.;
					Alltrim(SF2->F2_ESPECIE) == "NCP" .And. !(cPaisLoc $ "ARG|URU|CHI|BOL|PAR")
					aArea := GetArea()
		          	aAreaItem := SD1->(GetArea())
					SD1->(dbSetOrder(1)) // D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
					For nI := 1 to Len(aRegSD2)
						SD2->(MsGoto(aRegSD2[nI]))
						cChaveItem	:=	cFilSD1+SD2->D2_NFORI+SD2->D2_SERIORI+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMORI
						If !Empty(SD2->D2_NFORI) .And. SD1->(MsSeek(cChaveItem)) // Item original de NF entrada
							cChaveItem	:=	cFilSD1+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMREM
							aCusto		:=	{SD1->D1_CUSTO/SD1->D1_QUANT,SD1->D1_CUSTO2/SD1->D1_QUANT,SD1->D1_CUSTO3/SD1->D1_QUANT,SD1->D1_CUSTO4/SD1->D1_QUANT,SD1->D1_CUSTO5/SD1->D1_QUANT}
							nQtdItem	:=	SD1->D1_QUANT
							If !Empty(SD1->D1_REMITO) .And. SD1->(MsSeek(cChaveItem)) // Item de remisión de entrada
								NFAtuSD1(nQtdItem,1,aCusto)
							EndIf
						EndIf
					Next nI
					SD1->(RestArea(aAreaItem))
					RestArea(aArea)
				EndIf

				//³Apaga o arquivo .xml criado na geracao da nota.   ³
				If cPaisLoc <> "MEX" .And. lGerarCFD .And. cFunName <> "MATA466N"
					CFDExcXML(SF2->F2_ESPECIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE,lAnulaSF3)
				Endif
				If cPaisLoc == "MEX" .And. FindFunction("LXDELEMEX")
					LXDELEMEX(SF2->F2_DOC,SF2->F2_SERIE,aCfgNf)
				EndIf
			EndIf
			MsUnLockAll()
			// Libera los registros bloqueados por la funcion FtMultLock-MATA521 DMICNS-13915/DSERFAT-21116
			If (cPaisLoc $ "ARG|BOL|CHI|PAR|URU" .Or. (cPaisLoc $ "MEX" .And. !IsInCallStack("FISA817"))) .AND. FindFunction("UNLOCSB2BO")
				UNLOCSB2BO(aRegSD2)
			EndIf
			//³Libera Faturas de Importacao ³

			If lRet .AND. aCfgNf[SAliasCols] == "SD1"
				If !Empty(SF1->F1_HAWB)
					If !lBloqImp
						   LibFatImp()
					EndIf
				EndIf
	        EndIf
			If SF2->F2_ESPECIE == "NCP" .AND. GetMV("MV_EASY") == "S" .AND. !Empty(SF2->F2_HAWB)
				DbSelectArea("SWN")
				DbSetOrder(2)
				If DbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
		   			While !Eof() .AND.;
						WN_FILIAL == cFilSWN .AND.;
					   	WN_DOC == SF2->F2_DOC .AND.;
					   	WN_SERIE == SF2->F2_SERIE

					   	SB1->(DbSetOrder(1))
	 					SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))

					   	SD2->(DbSetOrder(1))
	 					SD2->(DbSeek(cFilSD2+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA))

	 		   			If WN_TIPO_NF == "N"
					   		aCusto := PegaCMAtu(SWN->WN_PRODUTO,SWN->WN_LOCAL)

							//³ Achar Custo das Moedas 3,4 e 5 pela RecMoeda³

							If Len(aCusto)>0 .AND. Len(aCusto)<5
								For nX := 1 To (5-Len(aCusto))
									aAdd(aCusto, 0)
							Next nX
							ElseIf Len(aCusto) == 0
								aCusto := PegaCMD3()
							EndIf

							//³ Gravar no SD3 a 'DE8' para o Produto ³

							RecLock('SD3',.T.)
							Replace D3_FILIAL  With cFilSD3
							Replace D3_COD	   With SWN->WN_PRODUTO
							Replace D3_GRUPO   With SB1->B1_GRUPO
							Replace D3_TIPO    With SB1->B1_TIPO
							Replace D3_LOCAL   With SWN->WN_LOCAL
							Replace D3_UM	   With SB1->B1_UM
							Replace D3_CONTA   With SB1->B1_CONTA
							Replace D3_DOC	   With SWN->WN_DOC
							Replace D3_QUANT   With 0.00
							Replace D3_CF	   With 'DE8' 	//-- Identifica Movimentacao com Origem no SIGAEIC
							Replace D3_TM	   With '999'
							Replace D3_USUARIO With SubStr(cUsuario,7,15)
							Replace D3_NUMSEQ  With SWN->WN_NUMSEQ
							Replace D3_EMISSAO With SD2->D2_EMISSAO
							Replace D3_CHAVE   With 'E9' 	//-- N„o Alterar !!!
							Replace D3_QTSEGUM With SB1->B1_QTSEGUM
							Replace D3_SEGUM   With SB1->B1_SEGUM
							Replace D3_IDENT   With ""		//cNumSeqD1  //-- Diferencia as Movimentacoes
							Replace D3_CUSTO1  With aCusto[1]
							Replace D3_CUSTO2  With aCusto[2]
							Replace D3_CUSTO3  With aCusto[3]
							Replace D3_CUSTO4  With aCusto[4]
							Replace D3_CUSTO5  With aCusto[5]
							Replace D3_DOCSWN  With SWN->WN_PO_NUM
							Replace D3_ITEMSWN With SWN->WN_ITEM
							MsUnlock()
							aCM := aClone(aCusto)
							B2AtuComD3(aCM,,,,,,,,,,,,,,,,.F.)
						EndIf
				   		DbSelectArea("SWN")
						DbSkip()
					End
				EndIf

				DbSelectArea("SWN")
				DbSetOrder(1)
				If DbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
		   			While !Eof() .AND.;
						WN_FILIAL == cFilSWN .AND.;
					   	WN_DOC == SF2->F2_DOC .AND.;
					   	WN_SERIE == SF2->F2_SERIE

			   			If WN_TIPO_NF == "N"
							DbSelectArea("SD3")
							If DbSeek(cFilSD3+SWN->WN_DOC+SWN->WN_PRODUTO)
								RecLock('SD3',.F.)
								Replace D3_ESTORNO	With "S"
								MsUnlock()
							EndIf
						EndIf
				   		DbSelectArea("SWN")
						DbSkip()
					End
				EndIf
			EndIf

			//³Chama a mesma rotina para fazer a exclusao da nota de entrada ³
			//³associada a nota de consignacao.                              ³

			If nRegSF1 <> 0
				SF1->(MsGoto(nRegSF1))
				SD1->(dbSetOrder(1))
				If	SD1->(MsSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_lOJA))
					aCfgNFSalva	:= aClone(aCfgNF)
					aCfgNF 		:= MontaCfgNf(63,aCfgNF[SaPergs],.F.)
					Do While !SD1->(EOF()) .AND. cFilSD1+SF1->F1_DOC+SF1->F1_SERIE == SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE
						nRecSD1AUT:=SD1->(Recno())
						RecLock("SD1",.F.)
						Replace SD1->D1_QTDEDEV	With 0
						Replace SD1->D1_VALDEV	With 0
						MsUnlock()

						//³Fazer o estorno da distribuicao do material³

	        	       If Localiza(SD1->D1_COD) .AND. Alltrim(SF1->F1_PEDVEND) == "AUTO"
							aCAB  :={{"DA_PRODUTO",SD1->D1_COD   , nil},;
										{"DA_LOCAL"  ,SD1->D1_LOCAL  , nil},;
										{"DA_NUMSEQ" ,SD1->D1_NUMSEQ , nil},;
										{"DA_DOC"    ,SD1->D1_DOC    , nil}}
							cChave	:=	SD1->(D1_COD+D1_LOCAL+D1_NUMSEQ+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA)
							SDA->(DbSetOrder(1))
							SDA->(MsSeek(cFilSDA+cChave))
							cLoteSDA	:=	SDA->DA_LOTECTL
							lRastro	:=	Rastro(SDA->DA_PRODUTO)
							SDB->(DbsetOrder(1))
							SDB->(MsSeek(cFilSDB+cChave))
							aItens	:=	{}
							While !SDB->(EOF()) .AND. cFilSDB == SDB->DB_FILIAL .AND. cChave == ;
										SDB->(DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC+DB_SERIE+DB_CLIFOR+DB_LOJA)
								If SDB->DB_TM > "500" .OR. SDB->DB_TIPO # "D"
									SDB->(dbSkip())
									Loop
								EndIf
								If lRastro .AND. !(cLoteSDA==SDB->DB_LOTECTL)
									SDB->(dbSkip())
									Loop
								EndIf

								aItem	:=	{}
								For nAuto:= 1 To Len(aStruSDB)
									AAdd(aItem,{SDB->(Field(nAuto)),SDB->(FieldGet(nAuto)),Nil})
								Next
								aItem[nPosEstor][2]	:=	"S"
								Aadd(aItens,aClone(aItem))
								SDB->(DbSkip())
							End
							lMSErroAuto := .F.
							SX3->(DbSetOrder(1))
							msExecAuto({|x,y,z,w| mata265(x,y,z,w)},aCab,aItens,4,.T.)
							If lMsErroAuto
								DisarmTransaction()
								MostraErro()
							EndIf
							// Trecho abaixo reposiciona SD1 que se perde depois do msexecauto
							// que não executava para notas com mais de um item
							SD1->(Dbgotop())
							SD1->(dbSetOrder(1))
							SD1->(Msgoto(nRecSD1AUT))
						Endif
						SD1->(dbSkip())
					End
					LocxDelNF("SF1",nRegSF1,lMostraCtb,lAglCtb,lContab,lCarteira,.F.,.F.,.T.)
					aCfgNF		:=	aClone(aCfgNFSalva)
				EndIf
	   		EndIf
		/*
		  ³ Estorno da notas de importacao integracao Average.             ³
		  ³ Estornar Movimentos e apagar campo D1_TES para NF de Importação³
		*/
		Case  cAlias =="SF1"
			If lShowHelp
				HelpInDark(.F.)
			EndIf

			lDesclassif := (lIntegracao .AND. AllTrim(SF1->F1_TIPO_NF) $ "123456789AB" .AND. (aCfgNF[SnTipo]==10 .OR. aCfgNF[SnTipo]==13 .OR. aCfgNF[SnTipo]==60))

			cA100For:=SF1->F1_FORNECE
			cLoja   :=SF1->F1_LOJA
			If lEicFinanc
				If !(cTipo$'DIB')
					A103DelTX(aRecSE2)
					lTX := .F.
				EndIf
			EndIf
			If lDesclassif .AND. lFacImport
		  		cPe	:=	LocxPE(41)
				If !Empty(cPe)
					ExecBlock(cPe,.F.,.F.)
				EndIf
				DbSelectArea('SD1')
				DbSetOrder(1)
				MsSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)

				//³ Apaga os remitos internos para produtos importados SIGAEIC ³

				If LxMaCanDelF1(nRecno,@aRecSC5,aRecSE2,.F.,aCfgNf[SlConFrDp][2],aCfgNf[SlRemito],.F.,Nil,.F.,.T.)
					LxApagaREM(lMostraCtb,lAglCtb,lContab,lCarteira,lTela,lPerg,lRSAuto,@aRecImp)
				Else
					Help(" ",1,"SDAJADISTR")
					Return .F.
				EndIf

				//³ Apaga os titulos no Contas a Pagar SE2                   ³

				If lEicFinanc .and. lTX
					If !(cTipo$'DIB')
						LxA103SE2(2,aRecSE2)
					EndIf
				EndIf
	        EndIf
	        //Integração WMS - Estorno da Ordem de Serviço
			If cPaisLoc == "RUS"
				If SuperGetMV("MV_WMSNEW",.F.,.F.) .and. cTipo $ "N|D|B" .And. FindFunction("WmsEsIntMI") .And. IntWMS()
					WmsEsIntMI()
				EndIf
			else
				If cTipo $ "N|D|B" .And. FindFunction("WmsEsIntMI") .And. IntWMS()
					WmsEsIntMI()
				EndIf
			EndIf

			//³ Inicializa o cabecalho dos lanç. Contabeis OnLine  ³

			If ( lContab .AND. (!__TTSinUse .Or. cPaisLoc $ "PTG|RUS|")) .OR. !Empty(SF1->F1_DTLANC)
				lContab := .T.
				DBSelectArea("SX5")
				MsSeek(xFilial("SX5")+"09COM")
				cLoteCom := IIf(Found(),Trim(X5DESCRI()),"COM ")
				If Empty(nHdlPrv) .OR. nHdlPrv < 0
					nHdlPrv := HeadProva(cLoteCom,"MATA103",Subs(cUsuario,7,6),@cArquivo)
				Endif
				If nHdlPrv <= 0
					HELP(" ",1,"A100NOPRV")
					lContab := .F.
				EndIf
			EndIf

			If lVerPad975
				aAreaSalva	:=	GetArea()
				cAliasImp	:=	IIf(GetNewPar("MV_CUSTIMP","1") == "1",'SD3','SWN')
				nPosRec		:=	iF(cAliasImp == 'SD3',1,2)
				For nI := 1 to Len(aRecIMP)
					SWN->(	MSGoto(aRecIMP[nI][2]))
					SD3->(	MSGoto(aRecIMP[nI][1]))
					SB1->(DbSetOrder(1))
					SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))
					DbSelectArea(cAliasImp)
					//Confirma posicionamento do arquivo
					If Recno() == aRecIMP[nI][nPosRec]
						nTotalLcto	+= DetProva(nHdlPrv,'975','MATA103',cLoteCom)
					EndIf
				Next nI
				RestArea(aAreaSalva)
			EndIf
			/*
			Verifica se ha movimentos gerados para caja chica. */
			If cPaisLoc == "CHI"
				If !LxVerifCC(nRecno)
					Return(.F.)
				Endif
			Endif

			//³Cancela a baixa dos titulos com pagamento a vista.³

			CaBxAutSE1(aCfgNf[ScAliasFin],,cAlias)

			//³ Gera lanç contabil 665- Exclusao - Total ³

	 		If !lDesclassif .OR. lEICFinanc
		 		If !LxMaCanDelF1(nRecno,@aRecSC5,aRecSE2,aCfgNf[SlConFrDp][1],aCfgNf[SlConFrDp][2],aCfgNf[SlRemito],lRSAuto,cOrigFin,!(lDesclassif.AND.lEICFinanc))

					//³ Efetua a gravacao dos lanç. Contabeis  ³

					If lContab .AND. nHdlPrv > 0 .AND. nTotalLcto > 0
						RodaProva(nHdlPrv,nTotalLcto)
						If UsaSeqCor()
							If cAlias == "SF1"
								aCtbDia := {{"SF1",SF1->(RECNO()),SF1->F1_DIACTB,"F1_NODIA","F1_DIACTB"}}
							elseIf cAlias == "SF2"
								aCtbDia := {{"SF2",SF2->(RECNO()),SF2->F2_DIACTB,"F2_NODIA","F2_DIACTB"}}
							EndIf
						Else
	    					aCtbDia := {}
						EndIF
						lLctoOk	:= cA100Incl(cArquivo,nHdlPrv,3,cLoteCom,lMostraCtb,lAglCtb,,If(aCfgNf[SaPergs][SlCtbEmiss],&(cAlias+"->"+PrefixoCpo(cAlias)+"_EMISSAO"),dDataBase ),,,,aCtbDia)
						If lLctoOk .AND. !Empty(aRecIMP) .AND. lVerPad975
							For nI:= 1 To Len(aRecIMP)
								SD3->(MsGoTo(aRecIMP[nI][1]))
								If !SD3->(EOF()) .AND. SD3->(Recno()) == aRecIMP[nI][1] .AND. aRecIMP[nI][1]<>0
									RecLock('SD3',.F.)
									Replace D3_DTLANC With dDataBase
									MsUnLock()
								EndIf
							Next
						EndIf
					EndIf
					Return .F.
				EndIf
			EndIf

			//³ Realiza baja de Adientamentos     ³
			If cPaisLoc $ "MEX" .AND. AliasInDic("FR3") .AND. AliasInDic("FIE") .AND. A410UsaAdi(SF1->F1_COND)
				If !BaixaAdt()
					If IsBlind()
						Conout(STR0175)
					Else
						Aviso(STR0033,STR0175 + CRLF + STR0176,{STR0041}) //"Atenção"#"Não foi possível excluir a baixa do adiantamento associado ao Documento de Saída."#"Não será possível excluir o Documento de Saída."#OK
					EndIf
					DisarmTransaction()
					Return(.F.)
				Endif
			Endif
			cAliasGrid	:= "SD1"
			cSeekGrid 	:= "'" + cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA + "'"
			cWhileGrid	:= "SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA == " + cSeekGrid
			cCondIf     := "SD1->D1_ESPECIE == SF1->F1_ESPECIE"
			nIndGrid	:= 1
			aRecSD1		:= AClone(LocxGrid(cAliasGrid,cWhileGrid,cCondIf,,,cSeekGrid,nIndGrid,{"D1_DOC"},,,)[6])
			If !lDesclassif
				nRegSF1:=SF1->(Recno())

				//³ Apaga o pedido de vendas quando gerado pelo D1_GERAPV      ³

				a103GrvPV(2,,aRecSC5)

				//³ Apaga o arquivo de Livros Fiscais (SF3)³

				MaFisAtuSF3(2,"E",SF1->(RecNo()))

				If cPaisloc == "CHI"
					Aadd(aDadSFE,{.T.,"",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,"RHO",0,0,0,SF1->F1_ESPECIE})
		   			GrvRetSFE(1,aDadSFE)
				ElseIf cPaisloc == "COS"
					Aadd(aDadSFE,{.T.,"",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,"RIR",0,0,0,SF1->F1_ESPECIE})
		   			GrvRetSFE(1,aDadSFE)
				EndIf

				//³ Apaga as NFs de Despacho gravadas no SF3 ³

				If SF1->F1_TIPO_NF $ "9"
					MaFisF3Eic(2)
				EndIf

				//³ Gera os titulos no Contas a Pagar SE2  ³

				If !(cTipo$'DIB')
					LxA103SE2(2,aRecSE2)
				EndIf

				//³ Estorna Amarracao com SF8 de NF de frete ³

				If aCfgNF[SlConFrDp][1]
					A116Grava(.T.,Nil,Nil,A116GetSF8(lContinua),.F.)
					If !lContinua
						Return .F.
					Endif
				EndIf

				//³ Estorna Amarracao com SF8 de NF de despesas  ³

				If aCfgNF[SlConFrDp][2]
					A119Grava(.T.,Nil,Nil,A119GetSF8())
				EndIf

				//³ Estorna os titulos de NCC ao cliente  ³

				A103EstNCC()
			EndIf

			//³Lacto. PCO ³

			For nx := 1 to Len(aRecSD1)
   				AAdd( aRecnoI, { aRecSD1[nx] } )
			Next nx
			PcoLancto(aCfgNf[SAliasHead],aCfgNf[SAliasCols],nRecno,aRecnoI,aCfgNf[SaLancPCO][1],aCfgNf[SaLancPCO][2],aCfgNf[SaLancPCO][4],aCfgNf[SaLancPCO][3], .F./*lInclui*/, .T./*lDeleta*/)
			//SF1->(dbGoto(nRegSF1))
			SF1->(MsGoto(nRecno))

			For nx := 1 to Len(aRecSD1)
				dbSelectArea('SD1')
				MsGoto(aRecSD1[nx])
				dbSelectArea('SF4')
				dbSetOrder(1)
				MsSeek(cFilSF4+SD1->D1_TES)

				//Estorna os arquivos de Gerenciamento de Projetos - 2:Estorno,3:Exclusao ³
				If IntePMS() .AND. (!IsRemito(1,'SD1->D1_TIPODOC') .Or. (IsRemito(1,'SD1->D1_TIPODOC') .And. IsIntegTop(,.T.)))
					If !IsIntegTop(,.T.)
						PmsWriteNF(2,"SD1")
						PmsWriteNF(3,"SD1")
					Else
						If AllTrim(SD1->D1_TIPODOC) == "60" .Or. AllTrim(SD1->D1_TIPODOC) == "10"
							If !Empty(SD1->D1_PEDIDO)
								If !PMSNFSA(SD1->D1_PEDIDO,SD1->D1_ITEMPC)[1] //Não é S.A
									PmsWriteNF(2,"SD1")
									PmsWriteNF(3,"SD1")
								Endif
							Else
								If Empty(SD1->D1_REMITO)
									PmsWriteNF(2,"SD1")
									PmsWriteNF(3,"SD1")
								Endif
							Endif
						Else
							PmsWriteNF(2,"SD1")
							PmsWriteNF(3,"SD1")
						Endif
					Endif
	      		EndIf
				//Atualiza o arquivo de rateios por C.C.  ³
				aAux := BuscaSDE()
				Lxa103SD1AtuSDE(2,aClone(aAux[3]),aClone(aAux[2]),aClone(aAux[1]),LxA103Custo(nx,IsRemito(1,'SF1->F1_TIPODOC')))

				dbSelectArea('SD1')
				MsGoto(aRecSD1[nx])
				dbSelectArea('SF4')
				dbSetOrder(1)
				MsSeek(cFilSF4+SD1->D1_TES)

				//Estorna classificação dos remitos  ³
				If !aCfgNF[SlRemito]
					aArea		:=GetArea()
					aAreaItem	:=SD1->(GetArea())
					SD1->(DbSetOrder(1))
					cChaveItem	:=	cFilSD1+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMREM
					aCusto		:=	{SD1->D1_CUSTO/SD1->D1_QUANT,SD1->D1_CUSTO2/SD1->D1_QUANT,SD1->D1_CUSTO3/SD1->D1_QUANT,SD1->D1_CUSTO4/SD1->D1_QUANT,SD1->D1_CUSTO5/SD1->D1_QUANT}
					nQtdItem	:=	SD1->D1_QUANT
					If !Empty(SD1->D1_REMITO) .And. SD1->(MsSeek(cChaveItem))
						NFAtuSD1(nQtdItem,-1,aCusto)
					EndIf
					RestArea(aAreaItem)
					RestArea(aArea)
				EndIf

				//Apaga movimentacao no SD3 Qdo Documento de transf.  ³
				If SD1->D1_TIPODOC == '64'
					// Filial origem da transf.
					cFilOrig := IIF( !EMPTY(SF1->F1_FILORIG),SF1->F1_FILORIG,RetFilFor(SD1->D1_FORNECE,SD1->D1_LOJA) )
					SD3->(DbSetOrder(3))
					If SD3->(MsSeek(GetFilOri('SD3',cFilOrig)+SD1->D1_COD+cDepTrf+SD1->D1_NUMSEQ))
						If !LocTranSB2(1,cFilOrig)
							// Apaga transf. RE4
							RecLock("SD3",.F.)
							DbDelete()
							MsUnlock()
						EndIf
					EndIf
					SD2->(DbSetOrder(3))
					cMyNumFor := GetNumFor(cFilOrig)
					If !Empty(cMyNumFor) .AND. SD2->(MsSeek( GetFilOri('SD2',cFilOrig)+SD1->D1_DOC+SD1->D1_SERIE+cMyNumFor+SD1->D1_COD+SD1->D1_ITEMORI))
						Reclock("SD2",.F.)
						D2_QTDAFAT += SD1->D1_QUANT
						MsUnlock()
					EndIf
				EndIf

				//Gera lanç contabil 655-691-697-698 Exclusao - Itens   ³

					If ((cFunName$"MATA101N|MATA447|MATA462DN") .Or. ChkProp("CtbBorradoItemsFacturaCOM")) .or. (cPaisLoc == "ARG" .AND. cFunName == "FINA100") //Nota de Entrada | Pedimentos
						If lVerPad695
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'695','MATA103',cLoteCom)
							EndIf
						ElseIf lVerPad655
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom,,,,,,,,,,,,,,,,,lShowHelp)
							EndIf
						EndIf
					EndIf
					If cFunName$"MATA466N" .Or. ChkProp("CtbBorradoItemsNotaCOM") //Nota de Debito
						If lVerPad697
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'697','MATA103',cLoteCom)
							EndIf
						ElseIf lVerPad655
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
							EndIf
						EndIf
					EndIf
					If cFunName$"MATA465N" //Nota de Credito
						If VerPadrao("68N")
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'68N','MATA103',cLoteCom)
							EndIf
						ElseIf lVerPad655
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
							EndIf
						EndIf
					EndIf
					If lF817NCC//Nota de Credito desde FISA817
						If VerPadrao("68N")
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'68N','FISA817',cLoteCom)
							EndIf
						EndIf
					EndIf
					If cFunName$"MATA102N" .Or. ChkProp("CtbBorradoItemsRemitoCOM") //Remito de Entrada
						If lVerPad698
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'698','MATA103',cLoteCom)
							EndIf
						ElseIf lVerPad655
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
							EndIf
						EndIf
					EndIf

				lAtuEstoq  := SF4->F4_ESTOQUE == "S"
	         	If !lDesclassif
					If Empty(SD1->D1_REMITO)
				   		//Estorna a baixa do pedido de compras SC7  ³
				   		LxA103SC7(2,lAtuEstoq)
				   		If lAtuEstoq
					  		//Efetua estornos referentes a devolucao de mercadorias   ³
					  		LxA103SD2(2,nx,@aPedPV,IIf(aCfgNF[SnTipo] == 63 ,'D',Nil))
					  		//Estornar lanç no arquivo SD3  (RE5)  ³
					  		If !Empty(SD1->D1_OP)
						  		Lxa103EstRE5()
					  		EndIf
					  		//Estorna o controle de qualidade da Microsiga/Celerina   ³
					  		LxA103AtuQuali(SD1->D1_COD, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_ITEM, cTipo, .F., 2)
					  		//Estorna os saldos do arquivo SB2  ³
					  		LxA103SB2(2)
					  		//Estorna o arquivo de Saldo Em/De Poder de Terceiros  SB6 ³
					  		If SF4->F4_PODER3 $ "R|D"
						  		MaAtuSB6("SD1",2,.F.)
						  	EndIf
					  		//Estorna o Servico do WMS (DCF) ³
					  		A103EstDCF()
					  	Else
							aAreaSD2 := SD2->(GetArea())
							SD2->(DbSetOrder(3))
							If SD2->(MsSeek( cFilSD1+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMORI) )
								If SD2->D2_QTDEDEV > 0
									RecLock("SD2",.F.)
									Replace SD2->D2_QTDEDEV With SD2->D2_QTDEDEV - SD1->D1_QUANT
									Replace SD2->D2_VALDEV  With SD2->D2_VALDEV  - SD1->D1_TOTAL
									MsUnlock("SD2")
								EndIf
							EndIf
							RestArea(aAreaSD2)
				   		EndIf
					EndIf
					//Efetua o Estorno do Ativo Imobilizado  ³
		 			If ( !Empty(SD1->D1_CBASEAF))
						If SF4->(FieldPos("F4_BENSATF")) > 0 .And. SF4->F4_BENSATF == "1" .And. SD1->D1_QUANT >= 1
							For nI := 1 TO Int(SD1->D1_QUANT)
								cItemAtf	:= PadL( nI, Len( SN1->N1_ITEM ), "0" )
								a103GrvAtf(2,SubsTR(Trim(SD1->D1_CBASEAF),1,Len(Trim(SD1->D1_CBASEAF))-Len(cItemAtf))+cItemAtf)
							Next
						Else
				   			A103GrvAtf(2,SD1->D1_CBASEAF)
				  		EndIf
			   		EndIf
				EndIf
				//Estorna  Amarracao no cadastro ProdutoxFornec. SA5 SX5 ³
				LxA103AtuAmarr(2)
				//Apaga os dados referentes ao CIAP SF9 ³
				LxA103SF9(2)
				//Estorna o Movimento de Custo de Transporte - Integracao TMS  ³
				If IntTMS()  .And. ( ( Len(aRatVei) > 0 ) .Or. ( Len(aRatFro) > 0 ) )
					EstornaSDG("SD1")
				EndIf
				//Exclui o item da CBE quando utilizado ACD
				If lIntACD
					EstCBED1(SD1->D1_DOC,SD1->D1_SERIE,SD1->D1_FORNECE,SD1->D1_LOJA,SD1->D1_COD)
				EndIf
				//Exclui o item da NF SD1   ³
				If lNGMNTES
					NGSD1100E()
				EndIf
				cPe	:=	LocxPE(28)
				If !Empty(cPE)
					ExecBlock(cPE,.F.,.F.,aCfgNF[SlConFrDp])
				EndIf
				//Integração com Módulo de Locações SIGALOC
				If lMvLocBac .And. lFcLOCM009
					LOCM009(.T.)
				EndIf
				If !lDesclassif
					If !Empty(SD1->(D1_PEDIDO+D1_ITEMPC))
						aAdd(aPedsDesp,{SD1->(D1_PEDIDO+D1_ITEMPC),SD1->D1_QUANT})
					EndIf
					RecLock('SD1',.F.,.T.)
					dbDelete()
					MsUnlock()
				Endif
			Next nX
			dbSelectArea('SF1')
			MsGoto(nRecno)
			//Integração com ACD
			If lIntACD
				CBSF1EXC()
			Endif
			//Gera lanç contabil 665-687-689-690 Exclusao - Total ³
			If Type("cFunName")<>"U"
				If ((cFunName$"MATA101N|MATA447|MATA462DN") .Or. ChkProp("CtbBorradoFacuraCOM")) .or. (cPaisLoc == "ARG" .AND. cFunName == "FINA100") //Nota de Entrada | Pedimentos
					If lVerPad687
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'687','MATA103',cLoteCom)
						EndIf
					ElseIf lVerPad665
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom,,,,,,,,,,,,,,,,,lShowHelp)
						EndIf
					EndIf
				EndIf
				If cFunName$"MATA466N" .Or. ChkProp("CtbBorradoNotaCOM")//Nota de Debito
					If lVerPad689
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'689','MATA103',cLoteCom)
						EndIf
					ElseIf lVerPad665
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
						EndIf
					EndIf
				EndIf
				If cFunName$"MATA465N" //Nota de Credito
					If VerPadrao("68F")
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'68F','MATA103',cLoteCom)
						EndIf
					ElseIf lVerPad665
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
						EndIf
					EndIf
				EndIf
				If lF817NCC//Nota de Credito desde FISA817
					If VerPadrao("68F")
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'68F','FISA817',cLoteCom)
						EndIf
					EndIf
				EndIf
				If cFunName$"MATA102N" .Or. ChkProp("CtbBorradoRemitoCOM")//Remito de Entrada
					If lVerPad690
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'690','MATA103',cLoteCom)
						EndIf
					ElseIf lVerPad665
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
						EndIf
					EndIf
				EndIf
			EndIf
			//Gera Lancto Contabil 995- Exclusao - Total - EIC ³
			If lIntegracao .AND. lVerPad995 .AND. !Empty(SF1->F1_DTLANC)
				nTotalLcto	+= DetProva(nHdlPrv,'995','MATA103',cLoteCom)
			EndIf

			If !lDesclassif
				//O correlativo e excluido na LOCXDELREM()
				If lUsaCor //libera o numero correlativo
					If  !(cPaisLoc == "CHI" .And.  SF1->F1_RECHON=="1")  .And. !Empty(SF1->F1_NUMCOR)
						CORR_EXCL(SF1->F1_DTDIGIT,SF1->F1_NUMCOR)
					EndIf
				EndIf

				If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|POR|PTG|SAL|URU|VEN"
					//apaga o registro de movim. do caixinha
					LocXDelCC(SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE)
				EndIf

				RecLock('SF1',.F.,.T.)
				//Apaga os titulos de recolhimento de impostos ³
				If aCfgNf[ScAliasFin]=="SE2"
					ApagTitImp(cAlias)
				EndIf

				cPe	:=	LocxPE(29)
				If !Empty(cPE)
					ExecBlock(cPE,.F.,.F.)
				Else
					If __lPyme .And. ExistBlock( "LOCXS329" , .F. , .T. )
						Execblock( "LOCXS329" , .F. , .F. )
					EndIf
				EndIf

				//Reabre o Desembaraco do Compras Internacional se houver ³
				dbSelectArea("DBB")
				dbSetOrder(1)
				If MsSeek(cFilDBB+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA, .F. )

					RecLock("DBB", .F.)
					DBB->DBB_OK := " "
					MsUnlock()

   					cStatusDBA := "1" // Assume o Status que nenhuma NFE do desembaraco foi gerada
					dbSetOrder(2)
					DbSeek(cFilDBB+SF1->F1_HAWB , .F. )
					While !Eof() .And. cFilDBB == DBB->DBB_FILIAL .And. DBB->DBB_HAWB == SF1->F1_HAWB

                        If DBB->DBB_OK == "S"
                           cStatusDBA := "2" // Ao encontrar apenas 1 NFE gerada no desembaraco assume o Status de desembaraco parcialmente gerado
					       Exit
					    EndIf

						DBB->(dbSkip())
                    EndDo

					dbSelectArea("DBA")
					dbSetOrder(1)
					If MsSeek(xFilial("DBA")+SF1->F1_HAWB, .F. )
						//Status de Desembaraco com NFEs parcialmente geradas ³
						RecLock("DBA", .F.)
						DBA->DBA_OK := cStatusDBA
						MsUnlock()
	                EndIf

	                For nForDesp := 1 To Len(aPedsDesp)
	                	dbSelectArea("SC7")
	                	dbSetOrder(1)
	                	If dbSeek(cFilSC7+aPedsDesp[nForDesp,1])
	                		RecLock("SC7",.F.)
	                		SC7->C7_QTDACLA += aPedsDesp[nForDesp,2]
	                		MsUnLock()
	                	EndIf
	                Next nForDesp
                EndIf

				dbSelectArea("SF1")
				dbDelete()
				MsUnlock()

				//Apaga o arquivo .xml criado na geracao da nota ³
				If cPaisLoc <> "MEX" .And. lGerarCFD .And. cFunName <> "MATA466N"
					CFDExcXML(SF1->F1_ESPECIE,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE,lAnulaSF3)
				EndIf

			EndIf
			//Efetua a gravacao dos lanç. Contabeis  ³
			If lContab .AND. nHdlPrv > 0 .AND. nTotalLcto > 0
				RodaProva(nHdlPrv,nTotalLcto)
				If UsaSeqCor()
					If cAlias == "SF1"
						aCtbDia := {{"SF1",SF1->(RECNO()),SF1->F1_DIACTB,"F1_NODIA","F1_DIACTB"}}
					ElseIf cAlias == "SF2"
						aCtbDia := {{"SF2",SF2->(RECNO()),SF2->F2_DIACTB,"F2_NODIA","F2_DIACTB"}}
					EndIf
				Else
		    		aCtbDia := {}
				EndIF
				lLctoOk	:= cA100Incl(cArquivo,nHdlPrv,3,cLoteCom,lMostraCtb,lAglCtb,,If(aCfgNf[SaPergs][SlCtbEmiss],&(cAlias+"->"+PrefixoCpo(cAlias)+"_EMISSAO"),dDataBase ),,,,aCtbDia)
				If lLctoOk .AND. !Empty(aRecIMP) .AND. lVerPad975
					For nI:= 1 To Len(aRecIMP)
						SD3->(MsGoTo(aRecIMP[nI][1]))
						If !SD3->(EOF()) .AND. SD3->(Recno()) == aRecIMP[nI][1] .AND. aRecIMP[nI][1]<>0
							RecLock('SD3',.F.)
							Replace D3_DTLANC With dDataBase
							MsUnLock()
						EndIf
					Next
				EndIf
			EndIf
			If !lDesclassif .And. cPaisLoc $ "PER"
				//apaga o registro de movim. do caixinha
				LocXDelCC(SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE)
			EndIf
			If lShowHelp
				HelpInDark(.T.)
			EndIf

		EndCase
		If cPaisLoc $ "MEX" .And. cFunName == "FISA817"
			If &(cAlias+"->"+PrefixoCpo(cAlias)+"_TIPNOTA") == "01"
				cMotCan := &(cAlias+"->"+PrefixoCpo(cAlias)+"_TIPNOTA")
				cDocCan := &(cAlias+"->"+PrefixoCpo(cAlias)+"_DOC")
				cSerCan := &(cAlias+"->"+PrefixoCpo(cAlias)+"_SERIE")
				cNomXml := &(cAlias+"->"+PrefixoCpo(cAlias)+"_CODDOC")
				cUUID   := &(cAlias+"->"+PrefixoCpo(cAlias)+"_UUID")
				cCanEst := &(cAlias+"->"+PrefixoCpo(cAlias)+"_FLFTEX")
				cCanAcep:= &(cAlias+"->"+PrefixoCpo(cAlias)+"_ESCANC")

				LxActSF3(cMotCan,cDocCan,cSerCan,cNomXml,cUUID,cCanEst,cCanAcep)
			Endif
		EndIf
	EndIf
EndIf

If cPaisLoc == "ARG"
	lRet := ArgxDelNF(lRet, nRecno)
EndIf

If lRet
	// MODULO DMS ( 11 - VEICULOS )
	If cMVVeiculo == "S" .And. FindFunction("VA1810021_LocxDelNF")
		lRet := VA1810021_LocxDelNF( cAlias , nRecno )
	EndIf
EndIf

Return(lRet)


Static Function NfAtuSCN(nQuant,nSigno)
//Efetuar tratamento dos Remitos de Vendas ³
RecLock("SD2",.F.)
Replace D2_QTDAFAT With D2_QTDAFAT - (nQuant * nSigno)
Replace D2_QTDEFAT With D2_QTDEFAT + (nQuant * nSigno)
If D2_QTDEFAT < 0
	Replace D2_QTDEFAT With 0
EndIf
MsUnLock()
Return Nil

Static Function NfAtuSD1(nQuant,nSigno,aCusto)
//Atualiza Remito de entrada ³
RecLock("SD1",.F.)
Replace D1_QTDACLA With D1_QTDACLA - (nQuant * nSigno)
MsUnlock()

//Atualiza custo da movimentacao original de acordo com a movimentacao atual³
SF4->(DbSetOrder(1))
If SF4->(MsSeek(xFilial("SF4")+SD1->D1_TES)) .AND. SF4->F4_ESTOQUE == "S"
	ATUDIFCUSREM(aCusto,nQuant,nSigno)
Endif
Return NIL

/*

±±ºPrograma  ³BUSCASDE  ºAutor  ³Leandro C.G.        º Data ³  19/03/02   º±±
±±ºDesc.     ³Retorna dados referentes ao Rateio por Centro de Custo      º±±
±±º          ³relacionado a uma determinada NF             				  º±±
Obs.: Considera que o arquivo de Notas Fiscais ja esta posicionado no registro correto
aRet	- 	Retorno da funcao
			[1] - aHeader do SDE
			[2] - Recno's do SDE
			[3] - aRatCC
*/
Function BuscaSDE()
Local nItemSDE		:= 0
Local nUsadoSDE 	:= 0
Local aHeaderSDE	:= {}
Local aRecSDE		:= {}
Local aRatCC		:= {}
Local cItemSDE		:= ""
Local aRet			:= Array(3)
Local nY			:= 0
Local bWhile
Local nPosDoc		:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_REMITO"	})
Local nPosSerie		:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_SERIREM"})

If Type("aMemoSDE") == "U"
	aMemoSDE := {}
EndIf

DBSelectArea("SDE")

If (((FunName() == "MATA101N") .Or. ChkProp("ProrrateoDeRemito")) .And. !IsInCallStack("A103GRVATF")) .And. lInclui .And. !Empty(aCols[n,nPosDoc])
	MsSeek(xFilial("SDE")+aCols[n,nPosDoc]+aCols[n,nPosSerie])

	bWhile := { || !Eof() .AND.;
				   xFilial('SDE')	 	== SDE->DE_FILIAL 	.AND.;
				   aCols[n,nPosDoc] 	== SDE->DE_DOC		.AND.;
				   aCols[n,nPosSerie] 	== SDE->DE_SERIE	.AND.;
				   M->F1_FORNECE	 	== SDE->DE_FORNECE	.AND.;
				   M->F1_LOJA 	 	 	== SDE->DE_LOJA }
	lBuscaSDE := .F.
Else

	//³Posiciona arquivo SDE³

	MsSeek(xFilial("SDE")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)

	bWhile := { || !Eof() .AND.;
		xFilial('SDE')	== SDE->DE_FILIAL 		.AND.;
		SF1->F1_DOC 	== SDE->DE_DOC 			.AND.;
		SF1->F1_SERIE 	== SDE->DE_SERIE 		.AND.;
		SF1->F1_FORNECE	== SDE->DE_FORNECE		.AND.;
		SF1->F1_LOJA 	== SDE->DE_LOJA }
EndIf

While Eval(bWhile)

	//³ Montagem do aHeader ³

	If nUsadoSDE==0
		DBSelectArea("SX3")
		DBSetOrder(1)
		MsSeek("SDE")
		While	!EOF() .AND. SX3->X3_ARQUIVO == "SDE"
			If X3USO(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL
				nUsadoSDE++
				Aadd(aHeaderSDE,{ 	TRIM(X3Titulo())	,;
									SX3->X3_CAMPO		,;
									SX3->X3_PICTURE		,;
									SX3->X3_TAMANHO		,;
									SX3->X3_DECIMAL		,;
									SX3->X3_VALID		,;
									SX3->X3_USADO		,;
									SX3->X3_TIPO		,;
									SX3->X3_ARQUIVO		,;
									SX3->X3_CONTEXT 	})
			EndIf
			DBSelectArea("SX3")
			DBSkip()
		End
	EndIf

	Aadd(aRecSDE,SDE->(RecNo()))
	If cItemSDE <> 	SDE->DE_ITEMNF
		cItemSDE	:= SDE->DE_ITEMNF
		Aadd(aRatCC,{cItemSDE,{}})
		nItemSDE++
	EndIf
	Aadd(aRatCC[nItemSDE][2],Array(nUsadoSDE+1))

	For nY := 1 to Len(aHeaderSDE)
		If aHeaderSDE[nY][10] <> "V"
			aRatCC[nItemSDE][2][Len(aRatCC[nItemSDE][2])][nY] := SDE->(FieldGet(FieldPos(aHeaderSDE[nY][2])))
		Else
			aRatCC[nItemSDE][2][Len(aRatCC[nItemSDE][2])][nY] := SDE->(CriaVar(aHeaderSDE[nY][2]))
		EndIf

		//³ Lê campos Memos Virtuais da tabela SYP vinculado aos memos SDE ³

			If Len(aMemoSDE) > 0
				If (AllTrim(aHeaderSDE[nY][2])==AllTrim(aMemoSDE[1][2]))
					aRatCC[nItemSDE][2][Len(aRatCC[nItemSDE][2])][nY]:= MSMM(&("SDE->"+aMemoSDE[1][1]))
		    	EndIf
			EndIf

		aRatCC[nItemSDE][2][Len(aRatCC[nItemSDE][2])][nUsadoSDE+1] := .F.
	Next nY
	DBSelectArea("SDE")
	DBSkip()
End

aRet[1] := aClone(aHeaderSDE)
aRet[2] := aClone(aRecSDE)
aRet[3] := aClone(aRatCC)
Return(aRet)

/*

±±ºPrograma  ³MONTARATCCºAutor  ³Leandro C.G.        º Data ³  20/03/02   º±±
±±ºDesc.     ³Chama a tela que efetua o rateio por centro de custos       º±±

*/
Function MontaRatCC()
Local nPosItem		:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_ITEM"	 })
Local nPosCC		:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_CC"		 })
Local nPosConta		:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_CONTA"	 })
Local nPosItemCta	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_ITEMCTA" })
Local nPosCLVL		:= Ascan(aHeader,{|x| AllTrim(x[2]) == "D1_CLVL"	 })
Local nPosRateio	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_RATEIO"	 })
Local nPosRemito	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_REMITO"	 })
Local nPosItemRem	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_ITEMREM" })

If FindFunction("LxCpRateio") .And. !LxCpRateio()//Valida campos usados
	Return .F.
EndIf

If nPosItem > 0 .And. nPosCC > 0 .And. nPosConta > 0 .And. nPosItemCta > 0 .And. nPosClVl > 0 .And. nPosRateio > 0
    If !lInclui
		aRatCC := BuscaSDE()[3]

	ElseIf lInclui .And. ((FunName() == "MATA101N") .Or. ChkProp("ProrrateoDeRemito")) .And. aCols[n][nPosRateio] == "1";
			.And. !Empty(aCols[n][nPosRemito]) .And. !Empty(aCols[n][nPosItemRem]) .And. lLeSDE .And. Len(aRatCC) == 0
		aRatCC := BuscaSDE()[3]
		lLeSDE := .F.

    EndIf

	Lxa103RatCC()
EndIf
Return .T.
/*
±±ºPrograma  ³LocXFatAut ºº±±
*/
Function LocXFatAut()
Local aNumNF:={},aRet:={}
Local cFactAut := GetMV("MV_FACTAUT")

If (cFactAut == "N" .And. cPaisLoc <> "MEX") .Or. ;
	(cFactAut = "N" .And. cPaisLoc == "MEX" .And. (!lFuncAtual .Or. lAltSerie ) )
	If (Type("lLocxAuto") <> "U" .AND. lLocxAuto)
		aRet := LocXSx5NF(,lLocxAuto,aAutoCab)
	Else
		aRet := LocXSx5NF(IIf(Type("oDlgDocFis")=="O", oDlgDocFis, &(cNomeDlg)))
	Endif
Else
	If !Empty(aPE[31][1]) .AND.FindFunction("U_"+aPE[31][1])
		aNumNF := ExecBlock(aPe[31][1],.F.,.F.)
	ElseIf	FindFunction("U_"+aPE[31][2])
		aNumNF := ExecBlock(aPe[31][2],.F.,.F.)
	Else
		aNumNF := {"",space(TamSx3('F2_DOC')[1]),space(TamSx3('F2_SERIE')[1])}
	EndIf
	aRet := IIf(lGerarCFD, ValSFP(aNumNF),{AllTrim(aNumNF[1])+aNumNF[2],aNumNF[3]})

EndIf
Return(aRet)
/*
±±ºPrograma  ³LocXSx5NF  º±±
±±ºDesc.     ³Controle de numeracao dos documentos de formulario proprio    º±±
*/
Function LocXSx5NF(oDlgPae,lLocxAuto,aAutoCab,lNumNCC,lTransf, cFunName)
Local nTimes
Local aSerNF 	:= {}
Local nTamNota	:= TamSX3("F1_DOC")[1]
Local nTamSerie	:= TamSX3("F1_SERIE")[1]
Local oDlg,cCadastro := OemToAnsi(STR0099),cVarQ:="  ",oQual    //"Nr de Fatura"
Local nOpcA 	:= 0//, lDone := .F.
Local lAbandona := .F.//, lInterno := .T.
Local lSeqEspecie := SuperGetMV("MV_SEQESPE",,.F.)
//Local nCntErro  := 0
Local nTimeOut	:=	GetMv("MV_NOTAOUT")
Local nPosNum   := 0
Local nPosSer   := 0
Local cLabelSer := OemToAnsi(STR0100)  //"Serie Factura"
Local cLabelDoc := OemToAnsi(STR0101)  //"NR de Factura"
Local cPrefC    := ""
Local cChaveSX5 := xFilial("SX5")+IIf(lSeqEspecie,"AC","01")
Local cSerieChave := ""
Local cSerieSX5	  := ""
Local aRet        := {}
Local nPosIni     := 0
Local cCombo      := ""
Local cFilSFP	  := xFilial("SFP")
Local AreaSX3     := {}
local nCount      := 0
Local aFiltro     := {}
Local cSFPEsp	  := ""
Local lnoAtivo	  := .F.
Local lReutiliza  := GetMv("MV_USAMNUM",,.T.)
Local lDifNum	  := .F.
Local cNumSx5	  := ""
Local nx 		  := 0
Local lCrtlFol	  := .F.

PRIVATE lSX5Troca := .F.

//Se lNumNCC = .T. indica que foi chamado da rotina para geracao de Nota de Credito no cancelamento da NF - Loc. Guatemala
DEFAULT lNumNCC  := .F.

// Parametro utilizado para tranferencia de material
DEFAULT lTransf := .F.
Default cFunName := Funname()
Default oDlgPae := oMainWnd

cPrefC := IIf(lTransf,"",PrefixoCpo(aCfgNF[SAliasHead]))

If lNumNCC
   cLabelSer  := OemToAnsi(STR0233)  //"Serie Nota de Credito"
   cLabelDoc  := OemToAnsi(STR0232)  //"Num. Nota de Credito"
   cCadastro  := OemToAnsi(STR0232)  //"Num. Nota de Credito"
EndIf

vNumero   := ""
cFiltro   := ""
cEspecDoc := IIf(lTransf,"",aCfgNf[ScEspecie])

//³Busca as series correntes na tabela AB - Loc. Guatemala ³

If cPaisLoc == "GUA"
   dbSelectArea("SX5")
   dbSetOrder(1)
   If dbSeek(xFilial("SX5")+"AB"+cEspecDoc)
      cFiltro  := IIf(lSeqEspecie,cEspecDoc,"")+Padr(X5Descri(),nTamSerie)
   EndIf
EndIf

aSerNF := {}

// Leandro Prado - 24/02/2014 - Controle de Ponto de Venda p/ Argentina.
If (cPaisLoc =="ARG") .And. ((cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA101N|MATA462N|MATA462DN|MATA462TN|MATA102DN||MATA462R|OMSA320") .Or. ChkProp("PuntodeVenta"))
	If AllTrim(cEspecie) == "NF"
		cSFPEsp := "1"
	ElseIf AllTrim(cEspecie) == "NCI"
		cSFPEsp := "2"
	ElseIf AllTrim(cEspecie) == "NDI"
		cSFPEsp := "3"
	ElseIf AllTrim(cEspecie) == "NCC"
		cSFPEsp := "4"
	ElseIf AllTrim(cEspecie) == "NDC"
		cSFPEsp := "5"
	ElseIf AllTrim(cEspecie) == "RFN" .or. AllTrim(cEspecie) == "RTS" .or. AllTrim(cEspecie) == "RCD"
		cSFPEsp := "6"
	ElseIf AllTrim(cEspecie) == "RFD" .or. AllTrim(cEspecie) == "RTE"
		cSFPEsp := "7"
	ElseIf AllTrim(cEspecie) == "RET"
		cSFPEsp := "8"
	ElseIf AllTrim(cEspecie) == "RFB"
		cSFPEsp := "9"
	EndIf
	("SFP")->(DbSetOrder(9))
	If ("SFP")->(MsSeek(xFilial("SFP")+cLocxNFPV))
		If cPaisLoc == "ARG" .AND. cEspecDoc $ "RFD"
			AreaSX3 := GetArea()
				SX3->(dbSetOrder(2))
				SX3->(dbSeek("FP_ESPECIE"))
				nPosIni := At(AllTrim(cEspecie),AllTrim(SX3->X3_CBOX))
				cCombo := Substr(AllTrim(SX3->X3_CBOX),nPosIni-2,1)
			RestArea(AreaSX3)
			While (SFP->(!EOF())) .And. (SFP->FP_PV = cLocxNFPV)
				If AllTrim(SFP->FP_ESPECIE) == AllTrim(cCombo) .AND. dDataBase <= SFP->FP_DTAVAL
					If	cPaisLoc == "ARG" .and. Empty(cFiltro)
						AADD(aFiltro,AllTrim(SFP->FP_SERIE)+ cIdPVArg)
					Else
						cFiltro += "'" + AllTrim(SFP->FP_SERIE) + cIdPVArg + "|'"
					EndIF
					nCount++
				EndIf
				SFP->( DBSkip() )
			EndDo
		Else
			While (SFP->(!EOF())) .And. (SFP->FP_PV = cLocxNFPV)
				If	cPaisLoc == "ARG" .and. Empty(cFiltro)
					If (AllTrim(SFP->FP_ESPECIE) == cSFPEsp .or. AllTrim(SFP->FP_ESPECIE) == "" ) .And. SFP->FP_ATIVO <> "2"
						AADD(aFiltro,AllTrim(SFP->FP_SERIE)+ cIdPVArg)
					Else
						lnoAtivo := .T.
					EndIf
				Else
					cFiltro += "'" + AllTrim(SFP->FP_SERIE) + cIdPVArg + "|'"
				EndIf
				SFP->( DBSkip() )
			EndDo
		EndIf
	EndIf
EndIf
cPe	:=	LocxPE(32)
If !Empty(cPe)
	cFiltro := ExecBlock(cPe,.F.,.F.,{cFiltro})
EndIf
If Len(aFiltro) > 0 .and. ExistBlock('FILSERPV')
	aFiltro := Execblock('FILSERPV',.F.,.F.,{aFiltro})
EndIf


dbSelectArea("SX5")
dbSetOrder(1)
DbSeek( cChaveSX5 )
If (Iif(cPaisLoc == "RUS", ValType(lLocxAuto) == "U", Type("lLocxAuto") == "U") .OR. !lLocxAuto)
    While !Eof() .AND. X5_FILIAL+X5_TABELA == cChaveSX5

		//³ Filtrar as Serie a serem mostradas ³

		If ! Empty(cFiltro) .or. (cPaisLoc = "ARG" .and. Len(aFiltro) > 0)
	       cSerieChave  := IIf(lSeqEspecie,SX5->X5_CHAVE,Substr(SX5->X5_CHAVE,1,nTamSerie))
	       cSerieChave  := IIf(cPaisLoc = "ARG",AllTrim(X5_CHAVE),cSerieChave)
	       cSerieSX5    := IIf(lSeqEspecie,Substr(X5_CHAVE,4,nTamSerie),Padr(X5_CHAVE,nTamSerie))
	       cSerieSX5    := IIf(cPaisLoc = "ARG",RetSERNF(X5_CHAVE),cSerieSX5)
	       If (cPaisLoc = "ARG") .And. (Len(cSerieChave) > 3) .and. Empty(cFiltro)
	       		If aScan(aFiltro,{|x|x==cSerieChave}) > 0
	       			AADD( aSerNF,{ cSerieSX5, LocConvNota(X5Descri(),nTamNota) } )
	       		EndIf
			ElseIf (cPaisLoc <> "ARG")
				If cSerieChave $ cFiltro
					AADD( aSerNF,{ cSerieSX5, LocConvNota(X5Descri(),nTamNota) } )
				EndIf
			EndIf
        Else
           //Filtrar pela especie do documento. Retornar as series apenas do documento emitido
           If lSeqEspecie
              If Substr(X5_CHAVE,1,3) != cEspecDoc
                 DbSkip()
                 Loop
              EndIf
           EndIf
           If cPaisLoc <> "ARG" .AND. nCount <= 0
              cSerieSX5    := IIf(lSeqEspecie,Substr(X5_CHAVE,4,nTamSerie),Padr(X5_CHAVE,nTamSerie))
			  AADD( aSerNF,{ cSerieSX5, LocConvNota(X5Descri(),nTamNota) } )
	       EndIf
        EndIf
		dbSkip()
	EndDo
	If cPaisLoc == "ARG" .And. len(aSerNF) > 0 .And. lReutiliza
		For nx := 1 To Len(aSerNF)
			cNumSx5 := aSerNF[nx,2]
			lDifNum := AVldNum(aSerNF[nx,1],@cNumSx5,cEspecie,cLocxNFPV)
			//Verifica si existe el número de documento en la tabla SF2, si existe, asigna el número siguiente.
			If cPaisLoc == "ARG" .And. (cFunName $ "MATA467N") .And. FindFunction("ANumExis")
				While ANumExis(aSerNF[nx,1],@cNumSx5,cLocxNFPV)
					cNumSx5:= Soma1(cNumSx5)
				EndDo
			EndIf
			If !lDifNum .And. aSerNF[nx,2] <> cNumSx5
				aSerNF[nx,2] := cNumSx5
			Endif
		Next nx
	EndIf
	If (Len(aSerNF) == 0) .OR. lAbandona
		If cPaisLoc == "ARG" .AND. cEspecDoc $ "RFD"
			MsgAlert(STR0367 ,STR0366) //"Registrar series para Remitos de Devolucion (RFD) en Control de Formularios" //"¡Series vacias!"
		ElseIf cPaisLoc == "ARG" .AND. lnoAtivo
			MsgAlert(STR0426,STR0366)
		Else
			Help(" ",1,"A460FLOCK")
		endIf
	Endif

	If Len(aSerNF) > 1
		DEFINE MSDIALOG oDlg TITLE cCadastro FROM 0,0 TO 264,378 OF oDlgPae	PIXEL
		@ .5,.80 LISTBOX oQual VAR cVarQ Fields HEADER STR0100,STR0101 SIZE 180,100 ON DBLCLICK (aSerNF:=aSX5Troca(oQual:nAt,aSerNF,nTimeOut),oQual:Refresh()) NOSCROLL  //"Serie Factura"###"NR de Factura"
		oQual:SetArray(aSerNF)
		oQual:bLine := { || {aSerNf[oQual:nAT,1],aSerNf[oQual:nAT,2]}}
		DEFINE SBUTTON FROM 120,130  TYPE 1 ACTION (nOpca := 1,cNumero:=aSerNf[oQual:nAt,2],cSerie:=aSerNf[oQual:nAt,1],oDlg:End()) ENABLE OF oDlg
		DEFINE SBUTTON FROM 120,160 TYPE 2 ACTION (nOpcA := 3,oDlg:End()) ENABLE OF oDlg
		ACTIVATE MSDIALOG oDlg
	ElseIF !Len(aSerNF) == 0
		cNumero := aSerNf[1,2]
		cSerie  := aSerNf[1,1]
		nOpcA   := 1
	EndIf
	IF (nOpcA != 1)
		Return ( {} )
	Endif
	If !lSX5Troca
		vNumero := cNumero
	Endif

Else
    nPosNum  := Ascan(aAutoCab, { |x| Upper(AllTrim(x[1]))==cPrefC+"_DOC"   })
    nPosSer  := Ascan(aAutoCab, { |x| Upper(AllTrim(x[1]))==cPrefC+"_SERIE" })

	If nPosNum > 0
		cNumero := aAutoCab[nPosNum][2]
	Else
		cNumero := Space(nTamNota)
	Endif
	If nPosSer > 0
		cSerie	:= aAutoCab[nPosSer][2]
	Else
		cSerie	:= Space(nTamSerie)
	Endif
Endif

//Valida si la secuencia del número de documento está dentro del rango a la fecha emisión del documento anterior y posterior
If cPaisLoc == "ARG" .And. (cFunName $ "MATA467N") .And. FindFunction("AVldFecNf") .And. GetNewPar("MV_CTRLFOL",.F.)
	If !AVldFecNf(cSerie,cNumero,cLocxNFPV)
		HELP(" ",1,"FCHNOVLD",,STR0449 + Alltrim(cSerie)+"-"+cNumero, 2, 0,,,,,,{STR0450})
		Return ( {} )
	EndIf
EndIf

//³Valida se o numero esta homologado pela SAT ³

If cPaisLoc == "GUA"
	If !LocxNumSAT(cSerie,cNumero,lNumNCC)
    	Return ( {} )
	EndIf
EndIf
cSerieSX5  := IIf(lSeqEspecie,cEspecDoc+cSerie,cSerie)
If DbSeek( cChaveSX5+cSerieSX5,.F. )
	If (Iif(cPaisLoc == "RUS", ValType(lLocxAuto) != "U", Type("lLocxAuto") <> "U") .AND. lLocxAuto)
		cNumero := IIf(Empty(cNumero),X5Descri(),cNumero)
		//Caso o numero do documento nao tenha sido enviado no array do cabecalho
		If nPosNum == 0
		   AADD(aAutoCab,{IIf(lTransf,"F2",PrefixoCpo(aCfgNF[SAliasHead]))+"_DOC", cNumero, NIL})
		EndIf
	Endif
	cNumero := LocConvNota(cNumero,nTamNota)
	nTimes := 0

	If !InTransact()
		While !MsRLock() .AND. nTimes < 10
			nTimes++
			Inkey(.1)
			DbSeek( cChaveSX5+cSerieSX5,.F. )
		EndDo
	EndIf

	IF RecLock("SX5",.F.)
		Replace X5_DESCRI  With cNumero
		Replace X5_DESCENG With cNumero
		Replace X5_DESCSPA With cNumero
		MsUnlock()
	Else
		Return( {} )
	Endif
Else
	If !InTransact()
		SX5->(MsRUnLock())
	EndIf
	Return( {} )
EndIf

If !lTransf .AND. (lGerarCFD .or. (cPaisLoc = "PER" .And. SFP->(ColumnPos("FP_SERIE2")) > 0))
	// Busca pos. da descricao da especie da nota no combo da tabela SFP (1=NF;2=NCI;3=NDI;4=NCC;5=NDC)
	SX3->(dbSetOrder(2))
	SX3->(MsSeek("FP_ESPECIE"))
	nPosIni := At(AllTrim(cEspecie),AllTrim(SX3->X3_CBOX))
	cCombo := Substr(AllTrim(SX3->X3_CBOX),nPosIni-2,1)

	// Verifica se a nota selecionada esta dentro de algum range cadastrado
	// Necessario em caso de existir mais de um range com a mesma serie
	If nPosIni == 0 .And. cPaisLoc=="PER"
		aRet := { cNumero, cSerie }
	Else
		SFP->(DbSeek(cFilSFP + cFilAnt + cSerie))
		While SFP->FP_FILIAL+SFP->FP_FILUSO+SFP->FP_SERIE == cFilSFP+cFilAnt+cSerie
			If AllTrim(SFP->FP_ESPECIE) == AllTrim(cCombo)
				If Val(cNumero) >= Val(SFP->FP_NUMINI) .AND. Val(cNumero) <= Val(SFP->FP_NUMFIM)
					lCrtlFol := .T.
					Exit
				Endif
			EndIf
			SFP->(dbSkip())
		EndDo
		If cPaisLoc $ "COL|PER" .And. SFP->(ColumnPos("FP_SERIE2")) > 0
			If lCrtlFol
				aRet := {cNumero, cSerie, SFP->FP_CAI, IIF(SFP->(ColumnPos("FP_NRCERT")) > 0,SFP->FP_NRCERT,""),SFP->FP_SERIE2}
			Else
				MsgAlert(STR0461, STR0462) //"Esta serie no esta registrada en el control de formularios." - "Control de Formularios"
			EndIf
		Else
			aRet := {cNumero, cSerie, SFP->FP_CAI, IIF(SFP->(ColumnPos("FP_NRCERT")) > 0,SFP->FP_NRCERT,"")}
		EndIf
	EndIf	
Else
	aRet := { cNumero, cSerie }
Endif
Return( aRet )

/*/
±±³Funcao    ³LocXStock ³±±
±±³Descri‡…o ³Apresenta consulta de estoque pressionando F4               ³±±
/*/
Function LocXStock(cTipo,cVar)
Local lGrade	:= GetMv("MV_GRADE")
Local lRusDebit	:= cPaisLoc == "RUS" .And. cEspecie == "NDP"
Local nPProduto := aScan(aHeader,{|x| AllTrim(x[2])==Iif(lRusDebit, "D1_COD","D2_COD") 		})
Local nPTes		:= aScan(aHeader,{|x| AllTrim(x[2])==Iif(lRusDebit,"D1_TES","D2_TES")		})
Local nPLocal	:= aScan(aHeader,{|x| AllTrim(x[2])==Iif(lRusDebit,"D1_LOCAL","D2_LOCAL")	})
Local nPQuant 	:= aScan(aHeader,{|x| AllTrim(x[2])==Iif(lRusDebit,"D1_QUANT","D2_QUANT")	})
//Local nPPrcVen  := aScan(aHeader,{|x| AllTrim(x[2])==Iif(lRusDebit,"D1_VUNIT","D2_PRCVEN")	})
Local nPIdent 	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_IDENTB6"	})
Local nPSerie	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_SERIORI"	})
Local nPosNF	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_NFORI"	})
Local nPItemOri := aScan(aHeader,{|x| AllTrim(x[2])=="D2_ITEMORI"	})
Local nProvEnt  := aScan(aHeader,{|x| AllTrim(x[2])=="D2_PROVENT"	})
Local aTeclas	:= {}
Local cProduto  := ""
Local cLocal    := ""
Local cTes      := ""
Local nItem     := n
Local nRecnoSD1 := 0
//Local nRecnoSD2 := 0
Local aArea		:= {}
Local lAtuTots	:=	.F.
Local aSavCols	:= aCols
Local nSavN		:= n
Local nPosItem	:= aScan(aHeader,{|x| AllTrim(x[2]) == Iif(lRusDebit,"D1_ITEM","D2_ITEM")} )
Local aRatDevAFS:= {}
Local nT_EDT	:= TamSx3("AFS_EDT")[1]

If Alias() $ 'SF2||SF1' .AND. !Empty(dbFilter())
	aArea	:=	{Alias()}
Else
	aArea	:= { Alias() , IndexOrd() ,  RecNo() }
Endif

cProduto := aCols[n][nPProduto]
cLocal	 := aCols[n][nPLocal]
cTes	 := aCols[n][nPTes]

//Estas variaveis sao usadas dentro da F4Lote, por isto devem ser privates
Private	 nPosLote	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_NUMLOTE"})
Private	 nPosLotCtl	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_LOTECTL"})
Private	 nPosDValid	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_DTVALID"})
Private	 nPosPotenc	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_POTENCI"})

DEFAULT cVar	:=	READVAR()

//³Salva as taclas de atalhos para posterior restauracao
aTeclas := ContTeclas()

dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+cTes)

If FindFunction("LxCpDocOri") .And. cTipo == "2"//Valida campos usados
	If !LxCpDocOri()
		Return
	EndIf
EndIf

If ( lGrade )
	MatGrdPrrf(@cProduto)
EndIf

cCpoQtd := Iif(lRusDebit,"M->D1_QUANT","M->D2_QUANT")
cCpoPrc := Iif(lRusDebit,"M->D1_VUNIT","M->D2_PRCVEN")
Do Case

	//³F4 para NF original ³
	Case cTipo == "2" .AND. "D2_NFORI" $ cVar //Saida por devolucao
		If F4NfOri(,,cVar,M->F2_CLIENTE,M->F2_LOJA,cProduto,"A466",,,@nRecnoSD1,Iif(cPaisLoc == "RUS",M->F2_EMISSAO,))
			LxA103SD1ToaCols(nRecnoSD1,nItem)
      		lAtuTots	:=	.T.
		EndIf

	Case lRusDebit .And. cTipo == "2" .And. "D1_NFORI" $ cVar //Send Of inflow Invoice (Debit Note)
		If F4NfOri(,,cVar,M->F1_FORNECE,M->F1_LOJA,cProduto,"ARUS466",,,@nRecnoSD1,M->F1_EMISSAO)
			LxA103SD1ToaCols(nRecnoSD1,nItem)
      		lAtuTots	:=	.T.
		EndIf

	//³F4 para Localizacao Devolucao de poder de 3ros.  ³
	Case cTipo == "1" .AND. aCfgNF[ScTipoDoc] == "N" .AND. ( "D2_QUANT" $ cVar .AND. SF4->F4_PODER3=="D" )
		If nPIdent*nPItemOri*nPSerie*nPosNF > 0
			A440F4( "SB6",cProduto,cLocal,"B6_PRODUTO","D",M->F2_CLIENTE,M->F2_LOJA,.F.,.F.,,"C")
 	        If cPaisLoc == "ARG" .And. nProvEnt > 0
				MaFisAlt('IT_PROVENT'  ,aCols[n,nProvEnt],n)
			Endif
		Else
			Aviso(STR0018,STR0098+CRLF+"D2_IDENTB6"+CRLF+"D2_SERIORI"+CRLF+"D2_NFORI"+CRLF+"D2_ITEMORI",{"OK"})					 //"Esta nota esta sendo digitada por outra estacao"
		Endif

	//³F4 para Rastreabilidade ³
	Case cTipo == "3" .AND. ( "D2_NUMLOTE" $ cVar .OR. "D2_LOTECTL" $ cVar )

		//³Variaveis Privates utilizadas na  funcao  F4Lote  ³
		If F4Lote(,,,"A467",cProduto,cLocal)
			MaFisAlt('IT_QUANT'  ,aCols[n,nPQuant],n)
      		lAtuTots	:=	.T.
		Endif

	//³F4 para Localizacao Fisica ³
	Case cTipo == "3" .AND. "D2_LOCALIZ" $ cVar
      	If F4Localiz( ,,, "A467" )  //"A440"
			MaFisAlt('IT_QUANT'  ,aCols[n,nPQuant],n)
      		lAtuTots	:=	.T.
		Endif

	Case cTipo $ "12" .AND. (Empty(cVar) .OR. ( "D2_QUANT" $ cVar ) .OR. ( "D2_COD" $ cVar  ))
		If ( ExistBlock('A440STK') )
			ExecBlock('A440STK',.f.,.f.)
		Else
			A440Saldo(.F.)
		EndIf
EndCase
/*
  ³Atualiza o browse de qtde de produtos ³
  */
If lAtuTots
	AtuLoadQt(.T.)
Endif

dbSelectArea("SD1")
GoTo(nRecnoSD1)

dbSelectArea("AFN")
dbSetOrder(2)
If DbSeek(xFilial("AFN")+SD1->(D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_ITEM))
	While !EOF() .AND. (SD1->(D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_ITEM))==(AFN->(AFN_DOC+AFN_SERIE+AFN_FORNECE+AFN_LOJA+AFN_ITEM))
		Aadd(aRatDevAFS, {AFN->AFN_PROJET ,AFN->AFN_REVISA ,Space(nT_EDT),AFN->AFN_TAREFA ,AFN->AFN_QUANT, .F. })
		AFN->( dbSkip() )
	EndDo
	aADD(aRatAFS,{aSavCols[nSavN][nPosItem],aClone(aRatDevAFS)})
ENDIF

//³Restaura as teclas de atalhos. ³

ContTeclas(aTeclas)

//³Restaura a entrada da rotina ³

dbSelectArea(aArea[1])
If Len(aArea)>1
	dbSetOrder(aArea[2])
	MsGoto(aArea[3])
Endif
Return(.T.)
/*/
±±³Fun‡…o    ³ LocXAvStok³ ±±
±±³Descri‡…o ³ Valida o saldo em estoque                                  ³±±
±±³ Uso      ³ Faturam.                                                   ³±±
/*/
Function LocXAvStok(aCpItens,aCItens)
LOCAL lEstoque	:= .T.
LOCAL nx 		:= 0
LOCAL nQtd 		:= 0.00
LOCAL nPosLocal := 0, nPosQuant := 0.00,nPosPedido:=0
LOCAL nPosLotCtl:= 0, nPosNumLot := 0, nPosLocaliz := 0, nPosNumSer := 0
LOCAL nPosItemPV:= nPosSequen := 0
//LOCAL cCodProd	:= CriaVar("D2_COD")
LOCAL cLocal	:= CriaVar("D2_LOCAL")
LOCAL cLoteCtl	:= CriaVar("D2_LOTECTL")
LOCAL cNumLote	:= CriaVar("D2_NUMLOTE")
LOCAL cLocaliz	:= ""
LOCAL cPedido 	:= ""
LOCAL cNumSer	:= ""
LOCAL aProd		:= {}
LOCAL nCols		:= 0
LOCAL cAux		:= ""
LOCAL nPosProd	:= Ascan( aCpItens,{ |x| Alltrim(x) == "D2_COD" } )
LOCAL cItemPV   := ""
LOCAL cSequen   := ""
Local lTesPeRemi:=.F.
Local cFilSF4	:= xFilial("SF4")
Local cMvEstNeg := GetMV("MV_ESTNEG")
//Local cFilSDC	:= xFilial("SDC")

nPosTES    := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_TES" } )
If nPosTES == 0
	Help(" ",1,"A467NOTES")
	lEstoque:=.F.
Else
	nPosLocal  := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_LOCAL" } )
	nPosQuant  := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_QUANT" } )
	nPosLotCtl := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_LOTECTL" } )
	nPosNumLot := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_NUMLOTE" } )
	nPosLocaliz:= Ascan( aCpItens,{ |x| Alltrim(x) == "D2_LOCALIZ" } )
	nPosNumSer := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_NUMSERI" } )
	nPosRemito := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_REMITO" } )
	nPosTPDCENV:= Ascan( aCpItens,{ |x| Alltrim(x) == "D2_TPDCENV"} )
	nPosPedido := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_PEDIDO" } )
	nPosItemPV := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_ITEMPV" } )
	nPosSequen := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_SEQUEN" } )

	SF4->( dbSetOrder(1) )
	nCols:=Len(aCpItens)+1
	For nX:=1 to Len(aCols)

		If ( cMvEstNeg == "N").OR. Rastro(aCItens[nX][nPosProd]) .OR. Localiza(aCItens[nX][nPosProd])

			If !aCItens[nX][nCols]
				SF4->( MsSeek(cFilSF4+aCItens[nX,nPosTES]) )
				IF SF4->F4_ESTOQUE == "S" .AND.(aCfgNF[SlRemito] .OR. Empty(aCItens[nX][nPosRemito]).OR.nPosTPDCENV==0 .OR. aCItens[nX][nPosTPDCENV]=="1".OR. aCItens[nX][nPosTPDCENV]==_RMCONS )
					If nPosNumser>0
						cNumSer := aCItens[nX][nPosNumSer]
					Else
						cNumSer:= ""
					Endif
					If nPosPedido>0
						cPedido := aCItens[nX][nPosPedido]
					Else
						cPedido:= ""
					Endif
					If nPosProd > 0
						cCodPro := aCItens[nX][nPosProd]
					Else
						cCodPro	:= ""
					EndIf
					If nPosLocal > 0
						cLocal := aCItens[nX][nPosLocal]
					Else
						cLocal := ""
					EndIf
					If nPosQuant > 0
						nQtd := aCItens[nX][nPosQuant]
					Else
						nQtd := 0
					EndIf
					If nPosLotCtl > 0
						cLoteCtl := aCItens[nX][nPosLotCtl]
					Else
						cLoteCtl := ""
					EndIf
					If nPosNumLot > 0
						cNumLote := aCItens[nX][nPosNumLot]
					Else
						cNumLote := ""
					EndIf
					If nPosItemPV > 0
						cItemPV := aCItens[nX][nPosItemPV]
					Else
						cItemPV := ""
					EndIf
					If nPosSequen > 0
						cSequen := aCItens[nX][nPosSequen]
					Else
						cSequen := ""
					EndIf
					If nPosLocaliz > 0
						cLocaliz := aCItens[nX][nPosLocaliz]
					Else
						cLocaliz := ""
					EndIf
					If !Empty(cPedido+cItemPV+cSequen)
						dbSelectArea("SDC")
						dbSetOrder(1)
						MsSeek(xFilial("SDC")+cCodPro+cLocal+"SC6"+cPedido+cItemPV+cSequen)
						If Found() .And. QtdComp(nQtd) == QtdComp(1)
							cLocaliz := SDC->DC_LOCALIZ
							cNumSer  := SDC->DC_NUMSERI
						EndIf
					EndIf
					cAux:=cCodPro+cLocal+cLoteCtl+cNumLote+cLocaliz+cNumSer+If(Empty(cPedido),".F.",".T.")
					nPos:=Ascan(aProd,{|x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6]+x[7]==cAux})
					If nPos==0
						Aadd(aProd,{cCodPro,cLocal,cLoteCtl,cNumLote,cLocaliz,cNumSer,If(Empty(cPedido),".F.",".T."),nQtd,aCItens[nX,nPosTES]})
					Else
						aProd[nPos][8]+=nQtd
					Endif
				Endif
			Endif
		Endif
	Next
	nCols:=Len(aProd)
	If nCols>0
		nX:=0
		lEstoque:=.T.
		While nX<nCols .AND. lEstoque
			nX++
			If aCfgNf[SlRemito] .And. &(aProd[nX][7])
			    lTesPeRemi := Posicione('SF4',1,cFilSF4+aProd[nX][9],'F4_ESTOQUE') == "N"
			EndIf
			If !SaldoOk(aProd[nX][1],aProd[nX][2],aProd[nX][8],aProd[nX][3],aProd[nX][4],aProd[nX][5],aProd[nX][6],&(aProd[nX][7]),,,,,lTesPeRemi)
				Aviso(STR0018,STR0070,{STR0021})
				lEstoque := .F.
			EndIf
		End
	EndIf
Endif
Return lEstoque
/*/
±±³Fun‡…o    ³ LocXAvCred³ ±±
±±³Descri‡…o ³ Validar o Valor digitado e verificar o limite de Credito.  ³±±
±±³ Uso      ³ Faturam.                                                   ³±±
/*/
Function LocXAvCred(aCpItens,aCItens)
LOCAL lCredito  := .F.
Local lMTValAvC := ExistBlock("MTVALAVC")
Local nValAv	:= 0

LOCAL nVlrTotal := 0.00
LOCAL cBlCred   := ""
LOCAL aEmpenho  := {}

nVlrTotal	:=	MaFisRet(,"NF_BASEDUP")

//³ Efetuar a avaliacao do Cr‚dito  ³

If lMTValAvC
	nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'LOCXNF',nVlrTotal,Nil})
Else
	nValAv	:=	nVlrTotal
Endif

lCredito := MaAvalCred(SA1->A1_COD,SA1->A1_LOJA,nValAv,nMoedaNF,.T.,@cBlCred,@aEmpenho)

If ! lCredito
	If !Empty(cBlCred)
		If     cBlCred == "01"
			cMsg := STR0102 //"01-Sin Limite de Cr‚dito"
		ElseIf cBlCred == "04"
			cMsg := STR0103 //"04-Limite de Cr‚dito Vencido"
		Else
			cMsg := STR0104 //"99-Otros"
		EndIf
		If IsInCallStack("FA096Anula") .And. cBlCred == "04" .or. cBlCred == "01"
			lCredito := .T.
		Else
			Help(" ",1,"A467LC",,cMsg,4,5)
		EndIf
	EndIf
EndIf
Return( lCredito )

/*/

±±³Funcao    ³LocxPesq  ³ ±±
±±³Descri‡…o ³Tratamento do Filtro e simulacao de SoftSeek na pesquisa.   ³±±

/*/
Function LocxPesq(bFilBrow)
AxPesqui()
Eval(bFilBrw)
Return(.T.)
/*/

±±³Fun‡…o    ³LocxLegenda³ ±±
±±³Descri‡…o ³ Cria uma janela com a legenda da mBrowse            		  ³±±
/*/
Function LocxLegenda(cAlias,lFiltra,cDescGer)
Local aLegenda := { 	{"DISABLE"   ,STR0013,{"01","10"}}  ,;				//"NF Normal"
						{"BR_CINZA"  ,STR0015,{"11","12","52","62"}}  ,;	//"NF de Beneficiamento"
						{"BR_AMARELO",STR0016,{"04","05","06","07"}}  ,;	//"NF de Devolucao"
						{"BR_PINK"   ,STR0014,{"02","03","08","09"}}  ,;	//"NF de Compl. Preco"
						{"BR_MARROM" ,DESCREM,{"50","60"}}  ,;				//"Remito"
						{"BR_AZUL"	 ,DESCREM+STR0105,{"51","53","61"}} ,;	//"Remito de devolucao"
						{"BR_PRETO"	 ,DESCREM+STR0185,{"54","64"}},;		//"Remito de Transferencia"
						{"BR_VERDE"	 ,STR0385,{"21"}} ,;                 	// Traslado - Mex
						{"BR_BRANCO" ,Iif(cPaisLoc=="AUS",STR0322,Iif(cPaisLoc=="MEX", STR0264,Iif(cPaisLoc=="PER",STR0264,STR0321))),{"17","18","19"}}} //"Nota de venta" - EQU/RCTI - AUS/Adiantamento - Mex /Adiantamento - Peru

Local aLeg		:=	{}
Local nX,nY

DEFAULT cAlias	 :=	aCfgNf[SAliasHead]
DEFAULT lFiltra	 :=	Iif(Type("lFiLD1D2")=="L",lFiLD1D2,GetMv('MV_FLTD1D2'))
DEFAULT cDescGer :=	aCfgnf[ScDescGer]

If cPaisLoc == "MEX" .and. cAlias == "SF2"
	AAdd(aLegenda,{"BR_AZUL_CLARO" ,STR0454,{"01"}}) 		//Cancel. fuera de Periodo  
	AAdd(aLegenda,{"BR_VERDE_ESCURO" ,STR0457,{"01"}}) 		//Cancel. fuera de Periodo - Pendiente de acuse"
	AAdd(aLegenda,{"BR_VIOLETA" ,STR0463,{"01"}}) //Cancelado ante el SAT, pendiente cancelación en sistema"    
EndIf
If cAlias == "SF1"
	AAdd(aLegenda,	{"BR_LARANJA",STR0163,{"13"}})    		//"Desp.imp./Frete"
	If lIntegracao
		AAdd(aLegenda,	{"BR_PRETO", STR0159,{"10"}} ) 		//"NF import. (classificada)"
		AAdd(aLegenda,	{"BR_VERDE", STR0160,{"10"}} ) 		//"NF import. ( nao classif.)"
	Endif
	AAdd(aLegenda,	{"BR_BRANCO" ,DESCREM+STR0145,{"63"}}) //"Retorno simbolico"
Endif

If SuperGetMV("MV_CONFFIS",.F.,"N") == "S"
	aAdd(aLegenda,{"BR_VIOLETA",STR0350, {"08","09","10","51","53","60"}}) //"Docto. em processo de conferencia"
EndIf
If lFiltra
	For nX:=	1	To Len(aLegenda)
		For nY	:=	1 To Len(aLegenda[nX][3])
			If aLegenda[nX][3][nY] $ aCfgNf[ScFilRot]
				AAdd(aLeg, {aLegenda[nX][1], aLegenda[nX][2]})
				Exit
			Endif
		Next nY
	Next nX
Else
	For nX:=	1	To Len(aLegenda)
		AAdd(aLeg, {aLegenda[nX][1], aLegenda[nX][2]})
	Next
Endif

//³Ponto de entrada para inclusão de nova cor LOCXPE64	 ³

aLeg:=LocxLegCor(2,cAlias,aLeg)

BrwLegenda(cDescGer,STR0017 ,aLeg)
Return .T.
/*/

±±³Fun‡…o    ³NFSetPrv   ³ ±±
±±³Descri‡…o ³ Carrega os valores do array de configuracao em variaveis   ³±±
±±³          ³ necessarias cada vez que muda o aCfgNF.                    ³±±

/*/
Static Function NFSetPRV(aNF)
nNFTipo		:= aNF[SnTipo]
cNFTipo		:= aNF[ScTipoDoc]
cEspecie 	:= aNF[ScEspecie]
lCliente	:= aNF[ScCliFor]=="SA1"
cCadastro	:=	aNF[ScDescri]
Return

/*/

±±³Fun‡…o    ³NfAtuFlds  ³ Autor ³ Guilherme C.Leal     ³ Data ³ 24.05.02 ³±±
±±³Descri‡…o ³ Atualiza variaveis do MATXFIS relativas ao calculo de impos³±±
±±³          ³ tos                                                        ³±±

/*/
Function NfAtuFlds(cCampo)
Local nPosTotal := 0
Local aSX7
Local nX := 0
If aSX7_Total == Nil .OR. (IsInCallStack("FINA096") .AND. LEN(aSX7_Total)> 0 .AND. substr(aSX7_Total[1,1],1,at("_",aSX7_Total[1,1])) <> substr(cCampo,1,at("_",cCampo)))
	aSX7_Total := SetSX7Total()
Endif

aSX7	:=	aClone(aSX7_Total)

For nX:= 1 To Len(aSX7_TOTAL)
	If aSX7_TOTAL[nX][1]==cCampo
		nPosTotal := AScan(aHeader,{|x| AllTrim(x[2]) == aSX7[nX][2] })
		If nPosTotal > 0
			nPosRef := AT('MAFISREF("',Upper(aHeader[nPosTotal][6])) + 10
			cRefCols:=Upper(Substr(aHeader[nPosTotal][6],nPosRef,AT('","MT100",',aHeader[nPosTotal][6])-nPosRef ))
			If MaFisFound(Substr(cRefCols,1,2),n)
		  		If MaFisRet(n,cRefCols)   <> ACols[n][nPosTotal]
			 		MaFisAlt(cRefCols,aCols[n][nPosTotal],n)
					//Executar a validação do total
			  		&("M->"+aHeader[nPosTotal][2])	:=	aCols[n][nPosTotal]
			  		MaFisRef(cRefCols,"MT100",aCols[n][nPosTotal])
			 		ModxAtuObj()
	 			Endif
			ENDIF
		EndIf
	Endif
Next
Return .T.

/*/
±±³Fun‡…o    ³NFFldOk    ³ Autor ³ Guilherme C.Leal     ³ Data ³ 24.05.02 ³±±
±±³Descri‡…o ³ Set Bloco para atualizacao dos campos, apos gatilhos.      ³±±
/*/
Function NFFldOk()
Local lRet := .T.
Local cFieldEdit	:= SubStr(ReadVar(),4,Len(ReadVar()))

If !Inclui
	//Verifica se o usuario tem permissao de alteracao.
	If cFieldEdit $ "D1_COD"
		If IsInCallStack("MATA102N") // Remito de Entrada
			lRet := MaAvalPerm(1,{cCampo,"MT102N",5}) .And. MaAvalPerm(1,{SD1->D1_COD,"MT102N",3})
		ElseIf IsInCallStack("MATA101N") // Factura de Entrada
			lRet := MaAvalPerm(1,{cCampo,"MT101N",5}) .And. MaAvalPerm(1,{SD1->D1_COD,"MT101N",3})
		EndIf
	Else
		If IsInCallStack("MATA102N") // Remito de Entrada
			lRet := MaAvalPerm(1,{SD1->D1_COD,"MT102N",4})
		ElseIf IsInCallStack("MATA101N") // Factura de Entrada
			lRet := MaAvalPerm(1,{SD1->D1_COD,"MT101N",4})
		EndIf
	EndIf
	If !lRet
		Help(,,1,'SEMPERM')
	EndIf
EndIf
If cPaisLoc $ "MEX|PER" .AND. cFieldEdit $ "|D1_TES|D2_TES|"
	lRet := LxTesAdi(N)
EndIf
If lRet
	oGetDados:oBrowse:bEditCol := &("{|| NfAtuFlds('" + ReadVar() + "') }")
EndIf
Return lRet
/*/
±±³Fun‡…o    ³GetDescRem ³ ±±
±±³Descri‡…o ³ Pega a descricao do remito.                                ³±±

/*/
Function GetDescRem(nAbrev)
Local cDescRem	:=	""
Local lExecPe	:= Iif(lLxModPE,LxModPE(,"LOCXDREM"),.T.)
Local lLocxDRem := Existblock("LOCXDREM")	// Retorna descricao do Remito
Default nAbrev  := 0

cDescRem	:=	STR0107 //"Remito"
Do Case
	Case cPaisLoc == "CHI"
		cDescRem	:=	STR0109       //Guia de despacho
	Case cPaisLoc $ "PAR|COL|MEX|PER"
		cDescRem	:=	STR0108		  // Remision
	Case cPaisLoc $ "POR|EUA|DOM"
		cDescRem	:=	STR0110      // Conduce
	Case cPaisLoc == "GUA"
		cDescRem	:=	STR0234      //"Nota de Envio"
	Case cPaisLoc == "ANG"
		cDescRem	:=	STR0265      //"Guia de Recep"
	Case cPaisLoc == "VEN"
		cDescRem	:=	STR0287      //"Fatura" ou "Factura"
	//Case cPaisLoc == "PTG"
	//	cDescRem	:=	STR0292      //"Guia"
	Case cPaisLoc == "AUS"
		If nAbrev == 1
			cDescRem:= "Deliv. Note"  //Delivery Note
		Else
			cDescRem:= "Delivery Note"  //Delivery Note
		EndIf
EndCase

If lLocxDRem .and. lExecPe
	cDescRem :=	ExecBlock("LOCXDREM",.F.,.F.)
EndIf
Return cDescRem

/*/
±±³Fun‡…o    ³ LocxGrvPed   ³ ±±
±±³Descri‡…o ³ Criar um novo pedido em base a uma devolucao               ³±±
/*/
Static Function LocxGrvPed()
Local aHeadC6	:= {}
Local nUsado	:=	0,nACols:=0,nCntFor	:= 0,nI	:= 0
Local aHeadBkp	:=	aClone(aHeader)
Local aColsBkp	:=	aClone(aCols)
Local cCadAux	:=	""
Local aColsC6	:= {}
Local cFilSB1	:= xFilial("SB1")
Local cFilSD1	:= xFilial("SD1")
Local nTamItem	:= TamSX3("C6_ITEM")[1]
Local cSecItem	:= Replicate("0", nTamItem)

dbSelectArea("SX3")
dbSetOrder(1)
dbSeek("SC6",.T.)
While ( !Eof() .AND. (SX3->X3_ARQUIVO == "SC6") )
	If ((X3Uso(SX3->X3_USADO) .AND. ;
		!( Trim(SX3->X3_CAMPO) == "C6_NUM" ) .AND.;
		Trim(SX3->X3_CAMPO) #"C6_QTDEMP"  .AND.;
		Trim(SX3->X3_CAMPO) #"C6_QTDENT") .AND.;
		cNivel >= SX3->X3_NIVEL)
		Aadd(aHeadC6,{ Trim(X3Titulo()),;
		SX3->X3_CAMPO,;
		SX3->X3_PICTURE,;
		SX3->X3_TAMANHO,;
		SX3->X3_DECIMAL,;
		SX3->X3_VALID,;
		SX3->X3_USADO,;
		SX3->X3_TIPO,;
		SX3->X3_ARQUIVO,;
		SX3->X3_CONTEXT } )
	EndIf
	dbSelectArea("SX3")
	dbSkip()
End

ProcRegua(Len(aCols)+2)

SD1->(DbSetOrder(1))
SD1->(DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
While !SD1->(EOF()) .AND. SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA==;
									cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA
	If SF1->F1_TIPODOC == SD1->D1_TIPODOC
		IncProc()
		cSecItem := Soma1(cSecItem, nTamItem)
		nUsado := Len(aHeadC6)
		aadd(aColsC6,Array(nUsado+1))
		nAcols := Len(aColsC6)
		aColsC6[nAcols,nUsado+1] := .F.
		For nCntFor := 1 To nUsado
			Do Case
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_ITEM"   )
					aColsC6[nAcols,nCntFor] := cSecItem
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_QTDVEN"  )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_QUANT
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_PRCVEN"  )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_VUNIT
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_OP"      )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_OP
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_PRODUTO" )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_COD
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_UM"      )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_UM
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_SEGUM"   )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_SEGUM
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_UNSVEN"  )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_QTSEGUM
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_VALOR"   )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_QUANT  *  SD1->D1_VUNIT
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_LOCAL"   )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_LOCAL
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_TES"   )
					aColsC6[nAcols,nCntFor] :=   Posicione('SB1',1,cFilSB1+SD1->D1_COD,'B1_TS')
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_CF"   )
					aColsC6[nAcols,nCntFor] :=   Posicione('SF4',1,cFilSB1+Posicione('SB1',1,xFilial('SB1')+SD1->D1_COD,'B1_TS'),'F4_CF')
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_DESCRI"   )
					aColsC6[nAcols,nCntFor] := Posicione('SB1',1,cFilSB1+SD1->D1_COD,'B1_DESC')
				OtherWise
					aColsC6[nAcols,nCntFor] :=   Criavar(Alltrim(aHeadC6[nCntFor,2]))
			Endcase
		Next nCntFor
	Endif
	SD1->(DbSkip()	)
End
IncProc(STR0126)	//'Inicializando dados do cabecalho'
RegToMemory("SC5",.F.)
SA1->(DbSetOrder(1))
SA1->(MsSeek(xFilial("SA1")+SF1->F1_FORNECE+SF1->F1_LOJA))
DbSelectArea("SC5")
M->C5_NUM      :=  Criavar('C5_NUM',.T.)
M->C5_TIPOCLI  :=  SA1->A1_TIPO
M->C5_TABELA   :=  SA1->A1_TABELA
M->C5_MOEDA    :=  SF1->F1_MOEDA
M->C5_CLIENTE  :=  SA1->A1_COD
M->C5_LOJACLI  :=  SA1->A1_LOJA
M->C5_CLIENT   :=  SA1->A1_COD
M->C5_LOJAENT  :=  SA1->A1_LOJA
M->C5_TIPOREM  :=  '0'
M->C5_DOCGER   :=  '1'
M->C5_CONDPAG  :=  IIf(!Empty(SA1->A1_COND),SA1->A1_COND,M->C5_CONDPAG)
M->C5_EMISSAO  :=  dDatabase
M->C5_TIPO     :=  "N"
aCols    := aColsC6
aHeader  := aHeadC6
aColsC6  := {}
CurLen   := 70 - Len(aHeader)
nPosAtu  := 0
nPosAnt  := 9999
nColAnt  := 9999
Pergunte("MTA410",.F.)
dbSelectArea("SC5")
ALTERA := .F.
INCLUI := .T.
IncProc(STR0127)	//'Generando Pedido'
cCadAux  := cCadastro
cCadastro := OemToAnsi(STR0128) + DESCREM
If Type("aCfgNf[15]") == "A"
	For nI := 1 To Len(aCfgNf[15])
		SetKey(aCfgNf[15,nI,1],{||})
	Next nI
Endif
If a410Inclui(Alias(),Recno(),3,.T.) == 1
	Reclock('SF1',.F.)
	Replace F1_PEDVEND	With	SC5->C5_NUM
	MsUnLock()

	If ExistBlock('LOCXGRPV')
    	Execblock('LOCXGRPV',.F.,.F.,SC5->C5_NUM)
	EndIf
Endif
If Type("aCfgNf[15]") == "A"
	For nI := 1 To Len(aCfgNf[15])
		SetKey(aCfgNf[15,nI,1],aCfgNf[15,nI,2])
	Next nI
Endif
cCadastro:= cCadAux
aCols    := aClone(aColsBkp)
aHeader  := aClone(aHeadBkp)
Return

/*
±±ºPrograma  ³NFSetImps º±±
±±ºDesc.     ³Carrega os valores dos impostos na tela quando for visuali- º±±
±±º          ³zacao.                                                      º±±
*/
Function NfSetImps(cAliasI)
Local aArea		:=	GetArea()
Local aAreaSD1	:=	SD1->(GetArea())
Local aAuxRef ,nX,nY
Local lCarTudo	:=	!(cAliasI=="SD2" .AND. GetNewPar('MV_DESCSAI','1') =='2')
Local cDescSai	:= GetNewPar('MV_DESCSAI','1')
aAuxRef	:=	MaFisRelimp(Nil,{cAliasI})

//³ Inicializa a funcao fiscal  ³
For nY:=1	To Len(aRecnos)
	(cAliasI)->(MsGoTo(aRecnos[nY]))
	MaFisIniLoad(nY)
	For nX := 1 To Len(aAuxRef)
		If cPaisLoc $ "ARG|PER|MEX|VEN|PAR|BOL" .And. cDescSai == '2'
			If cPaisLoc $ "PAR|BOL" .And. cAliasI == "SD2".And. aAuxRef[nX][3] == "IT_VALMERC" .And. (cAliasI)->D2_DESCON > 0
				MaFisLoad(aAuxRef[nX][3],(cAliasI)->(FieldGet(FieldPos(aAuxRef[nX][2]))) + (cAliasI)->D2_DESCON,nY)
			Else
				MaFisLoad(aAuxRef[nX][3],(cAliasI)->(FieldGet(FieldPos(aAuxRef[nX][2]))),nY)
			Endif
		ElseIf lCarTudo .OR. !(aAuxRef[nX][3] $ "IT_VALMERC|IT_PRCUNI")
			MaFisLoad(aAuxRef[nX][3],(cAliasI)->(FieldGet(FieldPos(aAuxRef[nX][2]))),nY)
		EndIf
	Next nX
	MaFisEndLoad(nY,2)
Next nY

RestArea(aAreaSD1)
RestArea(aArea)
Return
/*
±±ºPrograma  ³LOCXTrava º±±
±±ºDesc.     ³ Tratamento de LOCK - Arquivo SB2                           º±±
*/
Static Function LocxTrava(aCPitens,aCItens)
Local nI     := 0
Local aTrava := {}
Local nPosPrd:= 0
Local nPosLoc:= 0
Local lTrava := .T.
Local cCliFor:= ""
Local cLoja  := ""
If !InTransact()
	If aCfgNF[SAliasHead]=="SF2"
		cCliFor	:=	M->F2_CLIENTE
		cLoja	:=	M->F2_LOJA
	Else
		cCliFor	:=	M->F1_FORNECE
		cLoja	:=	M->F1_LOJA
	Endif
	nPosPrd:=aScan(aCPItens,{|x| AllTrim(x) == "D1_COD" 	.OR.	AllTrim(x) == "D2_COD"  })
	nPosLoc:=aScan(aCPItens,{|x| AllTrim(x) == "D1_LOCAL"	.OR. 	AllTrim(x) == "D2_LOCAL"})
	For nI := 1 to Len(aCols)
		IF ( Len(aCItens[nI]) > Len(aCPItens) ) .AND. !(aCItens[ni][Len(aCItens[ni])])
			AADD(aTrava,aCItens[nI,nPosPrd]+aCItens[nI,nPosLoc])
		EndIf
	Next
	lTrava := MultLock("SB2",aTrava,1) .AND.	MultLock(aCfgNF[ScCliFor],{cCliFor+cLoja},1)
	If ( !lTrava )
		SB2->(MsUnLock())
		SA1->(MsUnLock())
		SA2->(MsUnLock())
	EndIf
Endif
Return(lTrava)

/*/
±±³Fun‡…o    ³ NFVldCxa  ³ ±±
±±³Descri‡…o ³ Valida o OK dos dados de integracao com caixinha.          ³±±
/*/
Function NFVldCxa(nOpca,cBenef,nValor,cCaixa,cAdia,cHistor,cNrRend)
Local lRet			:= .T.
Local lAdia			:= .F.
Local nRecAdia		:= 0
Local cArquivo		:= ""
Local aSEUReg		:= {}
Local aFlagCTB		:= {}
Local nTotal		:= 0
Local lUsaFlag		:= SuperGetMV("MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local lPad579		:= VerPadrao("579")
//Local lPad572		:= VerPadrao("572")
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local aTmpSEU       := {}
Local aAreaSEU        := {}
Local cNumAnt       := ""
Local aCtbDia := {}
Local nRecSEU		:= 0
Local cFunName		:= FunName()
Local nMoeCX		:= 1
Local lConvCx		:=.F.
Local cFilSEU 		:= xFilial("SEU")
Local nSaldAux		:= 0
Local nTxMoeda		:= 1
//Local aDiario		:= {}

Private nHdlPrv   	:= 0	//Guarda a evolucao da funcao HeadProva
Private cLote		:= ""  	//Lote utilizado nas rotinas contabeis

Default cAdia		:=	""
Default cNrRend	:=	""

If Empty(cBenef).OR.Empty(nValor).OR.Empty(cCaixa)
   Help("  ",1, "Obrigat" )
   Return .F.
Else
	If TamSX3("EU_NRCOMP")[1] <> TamSX3("F1_DOC")[1]
		Help("", 1, "Help",, STR0459, 2, 0,,,,,, {STR0460}) // "La longitud del campo Número de Comprobante (EU_NRCOMP) es incorrecta."#"Debe ajustarla a la longitud del campo Número de Documento (F1_DOC)."
		Return .F.
	EndIf
	If !Empty(cAdia)
		If  cPaisLoc == "BOL" .And. ALLTRIM(cEspecie) == "NF" .And. ((ALLTRIM(cFunName) == "MATA101N") .Or. ChkProp("ValidaCajaChica"))
			lRet := LxNfCxaBol(cAdia, cCxRendic, cCaixa, @nRecAdia, nValor, @lAdia)
		Else
			dbSelectArea("SEU")
			SEU->(dbSetOrder(6))
			If SEU->(dbSeek(xFilial("SEU") + cCaixa + "01" + IIF(!EMPTY(cAdia),cAdia,Space(Len(EU_NROADIA)))))
				If (nValor <= SEU->EU_SLDADIA)
					RecLock("SEU",.F.)
					Replace EU_SLDADIA	With EU_SLDADIA - nValor

					//³ Se sobrou saldo no registro de adiantamento,                ³
					//³ pergunta-se se deseja REPASSAR O REMANESCENTE para o saldo  ³
					//³ do caixinha e com isso o adiantamento ficara com saldo zero,³
					//³ o que permitira que o mesmo seja baixado/rendido.           ³

					If EU_SLDADIA > 0
						lAdia		:=	.T.
						nRecAdia	:=	RECNO()
					Else
						Replace EU_BAIXA With dDataBase
					Endif
					MsUnlock()

					IIf(cPaisLoc == "ARG", cNumAnt := SEU->EU_NUM, Nil)


					If cPaisLoc == "ARG" .And. !Empty(cNumAnt) .And. SEU->EU_SLDADIA <= 0
						aAreaSEU := SEU->(GetArea())
						SEU->(dbSetOrder(3))
						If SEU->(dbSeek(xFilial()+cNumAnt))
							While SEU->(!Eof()) .And. SEU->(EU_FILIAL+EU_NROADIA) == (xFilial("SEU")+cNumAnt)
								RecLock("SEU", .F.)
								SEU->EU_BAIXA := dDataBase
								SEU->(MsUnlock())
								SEU->(dbSkip())
							Enddo
						Endif
						SEU->(RestArea(aAreaSEU))
					EndIF

				Else
					Help(" ",1,"FA560SALDO")
					lRet	:=	.F.
				Endif
			Else
				Help(" ",1,"FA560NE") // Adiantamento informado nao encontrado
				lRet	:=	.F.
			Endif
		Endif
	Else

		SET->(dbSetOrder(1))
		If SET->(MsSeek(xFilial("SET")+cCaixa)) .AND. SET->ET_SALDO >= nValor
			dbSelectArea("SEU")
			SEU-> (DbsetOrder(6)) //EU_FILIAL+EU_CAIXA+EU_TIPO+EU_NROADIA+EU_NUM                                                                                                                    
			If SEU-> (MsSeek(cFilSEU+SET->ET_CODIGO+"10", .T.)) 
				dbSelectArea("SA6")
				SA6->(dbSetOrder(1))
				IF SA6->((MsSeek( xFilial("SA6")+SEU->EU_BCOREP+SEU->EU_AGEREP+SEU->EU_CTAREP)))
					nMoeCX	:=Max(nMoeCX,SA6->A6_MOEDA)
					lConvCx := Iif(nMoeCX == M->F1_MOEDA,.T.,.F.)
				EndIF
			EndIf 
			
			Reclock("SET",.F.)
			If cPaisLoc == "ARG"
				Replace ET_SALANT With SET->ET_SALDO
			EndIf
			If !lConvCx
				If nMoeCX == 1
					nSaldAux := SET->ET_SALDO - xMoeda(nValor,nMoedaNF,nMoeCX,dDataBase,,nTaxa)
					Replace SET->ET_SALDO	With nSaldAux
				ElseIF nMoeCX > 1 
					nTxMoeda := RecMoeda(dDataBase,nMoeCX)
					nSaldAux := xMoeda(SET->ET_SALDO,nMoeCX,nMoedaNF,dDataBase,,nTxMoeda) - nValor
					nSaldAux := xMoeda(nSaldAux,nMoedaNF,nMoeCX,dDataBase,,nTaxa)
					Replace SET->ET_SALDO	With nSaldAux
				EndIf 
			else	
				Replace SET->ET_SALDO	With SET->ET_SALDO - nValor
			EndIf

			SET->(MsUnLock())
		Else
			Help(" ",1,"FA560SALDO")
			lRet	:=	.F.
    	Endif
	Endif
	If lRet
		SA2->(DbSetOrder(1))
		SA2->(MsSeek(xFilial("SA2")+M->(F1_FORNECE+F1_LOJA)))

		//³ Insere ou altera comprovantes do adiantamento   ³

		RecLock("SEU",.T.)
		Replace EU_FILIAL  	With 	xFilial()
		Replace EU_NUM     	With 	GetSXENum("SEU","EU_NUM")
		Replace EU_CAIXA   	With 	SET->ET_CODIGO
		Replace EU_VALOR   	With 	nValor
		Replace EU_BENEF   	With 	cBenef
		Replace EU_HISTOR  	With 	cHistor
		Replace EU_DTDIGIT 	With 	dDataBase
		Replace EU_EMISSAO 	With    M->F1_EMISSAO
		Replace EU_TIPO    	With 	"00"         	// Reembolso
		Replace EU_NROADIA 	With 	cAdia     		// informa a que adiant. se refere
		Replace EU_SEQCXA  	With 	SET->ET_SEQCXA
		Replace	EU_FORNECE	With	M->F1_FORNECE
		Replace	EU_NOME     With    SA2->A2_NOME
		Replace	EU_LOJA		With	M->F1_LOJA
		Replace	EU_NRCOMP	With	M->F1_DOC
		Replace	EU_CGC		With	SA2->A2_CGC
		Replace	EU_MOEDA	With	M->F1_MOEDA
		Replace	EU_VLMOED2	With	M->F1_TXMOEDA
		nRecSEU := SEU->(Recno())
		If cPaisLoc == "MEX" .OR. cPaisLoc == "COL"
			Replace EU_BAIXA With dDataBase
		Endif
		If cPaisLoc == "CHI"
			Replace EU_TIPDEB	With "_NF_"
		Endif
		If cPaisLoc == "ARG" .And. !Empty(cAdia)
			Replace	EU_STATUS	With "03"
		EndIf
		If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
			SerieNfId("SEU",1,"EU_SERCOMP",M->F1_EMISSAO,M->F1_ESPECIE,M->F1_SERIE)//Projeto Chave Unica - Tiago Silva
		Endif
		If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
			Replace EU_NRREND	With	cNrRend
		Endif

		If __lSX8
			ConfirmSX8()
		EndIf

		If cPaisLoc == "CHI"
			BaixaCxChi(cAdia, lAdia)
		Endif
		If  cPaisLoc == "BOL"
			BaixaCxBol(cAdia)
		EndIf
		If cPaisLoc == "ARG"
			If !Empty(cAdia)
				aTmpSEU := SEU->(GetArea())
				SEU->(DbSetOrder(6))
				If SEU->(DbSeek(xFilial("SEU")+SET->ET_CODIGO+"00"+cAdia))
					While (SEU->(!Eof())) .And. (xFilial("SEU")+SET->ET_CODIGO+"00"+cAdia)== SEU->EU_FILIAL+SEU->EU_CAIXA+"00"+SEU->EU_NROADIA
						RecLock("SEU",.F.)
						Replace	EU_BAIXA With dDataBase
						MsUnlock()
						SEU->(DbSkip())
					Enddo
				Endif
				Restarea(aTmpSEU)
			Endif
		Endif
		nOpca := 1
		lRet	:=	.T.
	Endif
Endif
If lAdia .AND. (MsgYesNo(OemToAnsi(STR0131),OemToAnsi(STR0132))) //"¨Deseja transferir o saldo remanescente para o caixinha?"###"adiant. com saldo remanescente"
	SEU->(MsGoTo(nRecAdia))

	//³ Atualiza informacoes do registro de adiantamento            ³

	If cPaisLoc == "CHI"
		Fa560FcAdi(SEU->(Recno()),SEU->(EU_SLDADIA),,,,M->F1_FORNECE,M->F1_LOJA,M->F1_DOC,iif(lUsaNewKey,SerieNfId("SF1",4,"F1_SERIE",M->F1_EMISSAO,M->F1_ESPECIE,M->F1_SERIE),M->F1_SERIE)) //Projeto Chave Unica - Tiago Silva
	Else
		Fa560FcAdi(SEU->(Recno()),SEU->(EU_SLDADIA))
	Endif

	// Contabilizacao do movim. de caixinha gerado pela transf. do saldo remanescente
	If lPad579 .AND. mv_par02 == 1 .AND. SEU->(Recno()) # nRecAdia
		If lUsaFlag
			aAdd(aFlagCTB, {"EU_LA", "S", "SEU", SEU->(Recno()), 0, 0, 0})
		Endif
		If Empty(nHdlPrv) .OR. nHdlPrv <= 0
			nHdlPrv := HeadProva(cLote,FunName(),Subs(cUsuario,7,6),@cArquivo)
		Endif
		If  nHdlPrv > 0 .And. Empty(SEU->EU_LA)
			nTotal	+=	DetProva(nHdlPrv,"579",FunName(),cLote)
			AAdd(aSEUReg,SEU->(Recno()))
		Endif
		RodaProva(nHdlPrv,nTotal)

		If nTotal > 0
			If UsaSeqCor()
		 		aCtbDia := {{"SEU",SEU->(Recno()),SEU->EU_DIACTB,"EU_NODIA","EU_DIACTB"}}
			Else
				aCtbDia := {}
			EndIF
			If cA100Incl(	cArquivo                                     , nHdlPrv           , 3                 ,  cLote        ,;
							IIf(mv_par03 # 1, .F., .T.) /*Visualiza*/    , .F./*Aglutina*/   ,/*cOnLine*/        ,  /*dData*/    ,;
							/*dReproc*/                                  , @aFlagCTB         ,/*aDadosProva*/    , aCtbDia        )
					If !lUsaflag
						Reclock("SEU",.F.)
						SEU->EU_LA := "S"
						 MsUnLock()
					Endif
			Endif
		Endif
		aFlagCTB := {}
	Endif
Endif

If lRet .And. cPaisLoc == "PER"
	xVldCxaPer(lUsaFlag, nRecSEU, cUsuario, cFunName, (mv_par02 == 1), (mv_par03 == 1))
EndIf

Return lRet

Function LockSCM(nReg)
Local lMarca 	:= .F.
Local aAreaSD1	:= getArea()

SD1->(MsGoto(nReg))

If SD1->D1_QTDACLA > 0
	lMarca := .T.
Else
	Help(" ",1,"QUANTIMP")
EndIf

RestArea(aAreaSD1)
Return lMarca

/*

±±ºPrograma  ³SaldoOk   ºAutor  ³Bruno Sobieski      ºFecha ³  07/15/02   º±±
±±ºDesc.     ³Verifica se o saldo disponivel eh suficiente.               º±±
±±³Retorno   ³ExpL1: .T. se a qtde solicitada esta disponivel    		  ³±±
±±³          ³       .F. se a qtde solicitada NAO esta disponivel   	  ³±±
±±³Parametros³ExpC1: Codigo do Produto         - Obrigatorio              ³±±
±±³          ³ExpC2: Local                     - Obrigatorio              ³±±
±±³          ³ExpN3: Qtde                - Obrigatorio             		  ³±±
±±³          ³ExpC4: Lote de Controle          - Obrig. se Inf. Sub-Lote  ³±±
±±³          ³ExpC5: Sub-Lote                                             ³±±
±±³          ³ExpC6: Localizacao               - Obrig. se inf. Nr.Serie  ³±±
±±³          ³ExpC7: Numero de Serie                                      ³±±
±±³          ³ExpL8: Indica se considera saldo empenhado/reservado        ³±±
*/
Static Function SaldoOk(cCod,cLocal,nQuant,cLoteCtl,cNumLote,cLocaliz,cNumSer,lBaixaEmp, cPedido, cItemPV, cSequen, lSaldo, lTesPeRemi)
Local lRet	:=	.T.
Local aArea	:=	GetArea()

DEFAULT cPedido := ""
DEFAULT cItemPV := ""
DEFAULT cSequen := ""
DEFAULT lSaldo := Nil
DEFAULT lTesPeRemi := .F.

If GetMV("MV_ESTNEG") != "S" .AND. (!SB2->(MsSeek(xFilial("SB2")+cCod+cLocal)) .OR.SaldoSB2(,.F.) <  (nQuant  - Iif(lBaixaEmp,SB2->B2_RESERVA,0)))
	//O segundo parametro da funcao SaldoSB2 so trata empenhos, e nao reservas, por isto e que
	//o campo B2_RESERVA eh consultado aqui
	lRet	:=	.F.
Endif
If lBaixaEmp == .T.
	lSaldo  := .T.
EndIf
If lRet .AND. Rastro(cCod) .AND. SaldoLote(cCod,cLocal,cLoteCtl,cNumLote,lBaixaEmp,,,,,lSaldo) <  nQuant
	lRet	:=	.F.
Endif

If !Empty(cPedido+cItemPV+cSequen)
	dbSelectArea("SDC")
	dbSetOrder(1)
	MsSeek(xFilial("SDC")+cCod+cLocal+"SC6"+cPedido+cItemPV+cSequen)
	If Found() .And. QtdComp(nQuant) == QtdComp(1)
		cLocaliz := SDC->DC_LOCALIZ
		cNumSer  := SDC->DC_NUMSERI
	EndIf
EndIf

If lRet	.AND. Localiza(cCod) .AND. SaldoSBF(cLocal,cLocaliz,cCod,cNumSer,cLoteCtl,cNumLote,Iif(lTesPeRemi,.F.,lBaixaEmp)) <  nQuant
	lRet := .F.
Endif

RestArea(aArea)
Return  lRet

/*/
±±³Fun‡…o    ³LocxNfDesp ³ ±±
±±³Descri‡…o ³ Monta uma tela com as nota fiscais originais.              ³±±
±±³Uso       ³ LOCXNF	                                                  ³±±
lActBrow - logico - Indica si debe realizar la actualización de los valores en el browse.
/*/
Function LocxNFDesp(nTipNota, lActBrow)
Local aRecs		:= {}
Local aRet		:= {}
Local aAreaSA2	:= SA2->(GetArea())
Local aAreaSD1	:= SD1->(GetArea())
Local aAreaSF1	:= SF1->(GetArea())
Local nX := 0//,nI,nY
Local cWhile	:= ""
Local cCondicao := ""
//Local cQuery    := ""
Local aCposF4	:= {}
Local cPerg		:=	Iif(nTipNota == 1,'MT116A','MT119A')
//Local aCTemp	:= {}
Local aIndRem	:= {}
Local bFilRem	:=	{|| }
Local cFilRem	:= ""
Local cTitOrig	:= ""
Local cCondPE	:= ""
Local cPE		:= ""
Local lFltD1D2	:= GetMv('MV_FLTD1D2')
Local lLeRemito := SuperGetMv("MV_RMFREF1",.F.,"0") == "1"	// '1' = Enxerga Remitos para vincular na NF Conhec.Frete
Local lFilRemito:= .F.
Local nPosTesG	:= 2
//Local nTamSx1Grp:= Len(SX1->X1_GRUPO)
Local cFilSF4		:= xFilial("SF4")

Private oProcess

Default lActBrow	:= .T.

//³Verifica se os campos de cabeçalho obrigatorios  ³
//³para o calculo de impostos  estão preenchidos.   ³

SX3->(DBSetOrder(2))
If Empty(M->F1_FORNECE).OR.Empty(M->F1_LOJA).OR. Empty(M->F1_DOC).OR. Iif(cPaisLoc=="ARG",Empty(M->F1_SERIE),.F.)
	Aviso(STR0038,STR0075,{STR0021})				 //"ATENCAO!"###"Preencha o campo de cabecalho : "###"OK"
	Return .F.
EndIf


//³   01 -  Valor da nota        mv_par01            ³
//³   02 -  Fornec./Cliente      mv_par02            ³
//³   03 -  Loja                 mv_par03            ³
//³   04 -  TES                  mv_par04            ³
//³   05 -  Data Inicial         mv_par05            ³
//³   06 -  Data Final           mv_par06            ³
//³   07 -  Aglutina produtos    mv_par07 Sim x Nao  ³

If !Pergunte(cPerg,.T.)
	Return .F.
Endif

RestArea(aAreaSA2)

AFN->(dbSetOrder(2))
/**/
If mv_par01==0   //total igual a zero, abre tela para digitacao das despesas
	If !LocxGastos()
		Return .F.
	Endif
Else
	aCGastos:={{mv_par01,mv_par04,.F.}}
Endif
SF4->(DbSetOrder(1))
For nX:=1 To Len(aCGastos)
	If SF4->(MsSeek(cFilSF4+aCGastos[nX][nPosTesG]))
		If SF4->F4_ESTOQUE <> "S"
		   Aviso(STR0018,RetTitle("D1_TES")+" "+AcGastos[nX][nPosTesG]+" - "+STR0165, {"OK"},2)
		Endif
	Else
		aCGastos[nX][nPosTesG]:="   "
	Endif
Next

SX3->(DbSetOrder(1))
SX3->(DbSeek("SF1"))
While !SX3->(EOF()) .AND. SX3->X3_ARQUIVO == "SF1"
	If SX3->X3_BROWSE == "S" .AND. cNivel >= SX3->X3_NIVEL
		AAdd(aCposF4,SX3->X3_CAMPO)
	Endif
	SX3->(DbSkip())
End

cCondicao 	+= "DTOS(F1_DTDIGIT)>='"+DTOS(mv_par05)+"'.AND."
cCondicao 	+=	"DTOS(F1_DTDIGIT)<='"+DTOS(mv_par06)+"'.AND."
cCondicao	+= "F1_TIPO=='N'"
cSeek		:=	"xFilial('SF1')"
cWhile 		:=	"!EOF() .AND. F1_FILIAL== '" + xFilial("SF1")+"'"

//³Ponto de Entrada p/ alterar o filtro ³

cPe	:=	LocxPE(56)
If !Empty(cPe)
	cCondPE := Execblock(cPE,.F.,.F.,{cCondicao})
	If ValType(cCondPE) == "C"
		cCondicao:= cCondPE
	EndIf
EndIf
If !Empty(mv_par02).AND.!Empty(mv_par03)
	cWhile	+= " .AND. F1_FORNECE=='"+mv_par02+"'.AND.F1_LOJA=='"+mv_par03+"'"
	cSeek		+= "+'"+mv_par02+"'+'"+mv_par03+"'"
EndIf

// Notas de Frete: Novo filtro p/ enxergar tb remitos p/ vinculos, desligando temporariamente o filtro atual da mBrowse.
If lFltD1D2 .And. lLeRemito .And. nTipNota == 1
	EndFilBrw(aCfgNF[SAliasHead],aIndD1D2)
    cFilRem := PrefixoCpo(aCfgNF[SAliasHead]) + "_TIPODOC $ '60/" + aCfgNF[ScFilRot] + "'"
	bFilRem	:=	{|| FilBrowse(aCfgNF[SAliasHead],@aIndRem,@cFilRem)}
	Eval( bFilRem )
	lFilRemito := .T.
	cTitOrig :=STR0261	//"Facturas/Remitos Originales"
Else
	 // Notas de Frete/Gastos: Novo filtro p/ nao enxergar os remitos se parametro MV_RMFREF1 = 0, desligando temporariament
	 // e o filtro atual da mBrowse.
	If lFltD1D2 .And. !lLeRemito
		EndFilBrw(aCfgNF[SAliasHead],aIndD1D2)
	    cFilRem := PrefixoCpo(aCfgNF[SAliasHead]) + "_TIPODOC $ '" + aCfgNF[ScFilRot] + "'"
		bFilRem	:=	{|| FilBrowse(aCfgNF[SAliasHead],@aIndRem,@cFilRem)}
		Eval( bFilRem )
		lFilRemito := .T.
	EndIf

	cTitOrig :=STR0123	//"Facturas Originales"
EndIf
If cPaisLoc == "RUS"
	aRet 	:= LocxF4("SF1",2,cWhile,cSeek,aCposF4,,cTitOrig,cCondicao,.T.,,,,,,,,.T.)  // Retorna os Recnos das linhas selecionadas
Else
	aRet 	:= LocxF4("SF1",2,cWhile,cSeek,aCposF4,,cTitOrig,cCondicao,.T.)  // Retorna os Recnos das linhas selecionadas
Endif

// Volta filtro original da FilBrowse
If lFilRemito
	EndFilBrw(aCfgNF[SAliasHead],aIndRem)
	Eval( bFilBrw )
EndIf

If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs := aRet[3]
EndIf

If ValType(aRecs)=="A" .AND. ValType(aRecs)=="A" .AND. Len(aRecs) > 0
	oProcess:=	MsNewProcess():New({|lEnd| CarregaDesp(nTipNota,aRecs,oProcess,aCGastos,@lEnd, lActBrow)},STR0239,,.T.)//"Carregando as notas selecionadas..."
	oProcess:Activate()
Endif

AtuLoadQt()
RestArea(aAreaSF1)
RestArea(aAreaSD1)
Return .T.

/*
±±ºPrograma  ³CarregaDespºº±±
±±ºDesc.     ³Rotina para ser utilizada pela processa na carga de items   º±±
±±º          ³ nas notas de despesas e de frete                           º±±
lActBrow - logico - Indica si debe realizar la actualización de los valores en el browse.
*/
Static Function CarregaDesp(nTipNota,aRecs,oProcess,aCGastos,lEnd, lActBrow)
Local nPItem    :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_ITEM'})
Local nPProduto :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_COD'})
Local nPLocal	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_LOCAL'})
Local nPTes     :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_TES'})
Local nPCF	    :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_CF'})
Local nPNumCQ 	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_NUMCQ'})
Local nPSegum 	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_SEGUM'})
Local nPConta 	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_CONTA'})
Local nPItemCta :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_ITEMCTA'})
Local nPCCusto  :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_CC'})
Local nPPeso	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_PESO'})
Local nPUM    	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_UM'})
Local nPTotal	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_TOTAL'})
Local nPVlUnit	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_VUNIT'})
Local nNFOri	:= Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_NFORI'})
Local nITOri	:= Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_ITEMORI'})
Local nSerOri	:= Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_SERIORI'})
Local nPesoTotal:= 0
Local nVlrTotal	:= 0
Local nLenAcols	:= 0
Local nLin		:= 0
Local nW		:= 0
Local nI        := 0,nX,nY,nSF1
Local lDel		:= .F.
Local cRatDesp	:= SuperGetMV("MV_RATDESP")
Local nRatDesp  := Val(SubStr(cRatDesp,At("DESP=",cRatDesp)+5,1))
Local nRatFrete	:= Val(SubStr(cRatDesp,At("FR=",cRatDesp)+3,1))
//Local nRatSeg  	:= Val(SubStr(cRatDesp,At("SEG=",cRatDesp)+4,1))
Local cItem		:=	StrZero(0,TamSX3('D1_ITEM')[1])
Local nDifTotal	:=	0
Local nDecs		:=	MsDecimais(MAFISRET(,'NF_MOEDA'))
Local cAliasSD1	:=	"SD1"
Local nUsado	:=	Len(aHeader)
Local lQuery 	:= .F.
Local lAviso 	:= .T.
Local aSavaCols	:=	{}
Local aStruSD1	:=	{}
Local cFilSF4		:= xFilial("SF4")
Local cFilAFN		:= xFilial("AFN")
Local cFilSD1		:= xFilial("SD1")
//-- Verifica se utiliza custo fifo on-line
Local lFifoOnLine:= IsFifoOnLine()

Local cQuery	:=	""
Local cQueryPE	:=	""

Default lActBrow	:= .T.
lQuery	:=	TcSrvType()<>"AS/400"

oProcess:SetRegua1(2)
oProcess:IncRegua1(STR0240)
oProcess:SetRegua2(Len(aRecs))

aSavaCols	:=	aClone(aCols)

aCols	:=	{}
aAmarrAFN := {}
For nSF1:=1 To Len(aRecs)

	//³ Verifica os itens da nota de origem  ³

	SF1->(MsGoto(aRecs[nSF1]))
	oProcess:IncRegua2(STR0241+subStr(SF1->F1_SERIE,1,3)+"/"+SF1->F1_DOC)//"Lendo NF "  /Tiago Silva Projeto Chave Unica
	dbSelectArea("SD1")
	dbSetOrder(1)
	If Empty(aStruSD1)
		aStruSD1 := SD1->(dbStruct())
	EndIf
	If lQuery .And. aScan(aStruSD1,{|x| x[2]=="M"})==0
		cAliasSD1 := "SD1"
		cQuery := "SELECT * "
		cQuery += "FROM "+RetSqlName("SD1")+" SD1 "
		cQuery += "WHERE "
		cQuery += "SD1.D1_FILIAL='"+cFilSD1+"' AND "
		cQuery += "SD1.D1_DOC='"+SF1->F1_DOC+"' AND "
		cQuery += "SD1.D1_SERIE='"+SF1->F1_SERIE+"' AND "
		cQuery += "SD1.D1_FORNECE='"+SF1->F1_FORNECE+"' AND "
		cQuery += "SD1.D1_LOJA='"+SF1->F1_LOJA+"' AND "
		cQuery += "SD1.D1_FORMUL='"+SF1->F1_FORMUL+"' AND "
		cQuery += "SD1.D_E_L_E_T_=' ' "


		//³ PE para manipulacao da Query, permite filtragem dos itens da factura original selecionada  ³

		cPe	:=	LocxPE(51)
		If !Empty(cPe)
			cQueryPE := Execblock(cPe, .F., .F., {cQuery,nTipNota})
			cQuery   := If(ValType(cQueryPE)=='C', cQueryPE, cQuery)
		EndIf

		cQuery += " ORDER BY "+SqlOrder(SD1->(IndexKey()))
		cQuery := ChangeQuery(cQuery)

		dbSelectArea("SD1")
		dbCloseArea()
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD1,.T.,.T.)
		For nX := 1 To Len(aStruSD1)
			If aStruSD1[nX][2] <> "C"
				TcSetField(cAliasSD1,aStruSD1[nX][1],aStruSD1[nX][2],aStruSD1[nX][3],aStruSD1[nX][4])
			EndIf
		Next nX
	Else
		MsSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
	EndIf
	While !lEnd .And. !Eof() .And. (cAliasSD1)->D1_FILIAL==cFilSD1 .And.;
			(cAliasSD1)->D1_DOC 		== SF1->F1_DOC 		.And.;
			(cAliasSD1)->D1_SERIE 	== SF1->F1_SERIE 		.And.;
			(cAliasSD1)->D1_FORNECE	== SF1->F1_FORNECE 	.And.;
			(cAliasSD1)->D1_LOJA 	== SF1->F1_LOJA

		If SF1->F1_FORMUL==(cAliasSD1)->D1_FORMUL

			If (cAliasSD1)->D1_ORIGLAN $"FD|F | D" .And. lAviso
				Aviso("",STR0246,{"OK"},2)
	  			lAviso := .F.
	        EndIf

			//³ Verifica se deve aglutinar os itens da NF de entrada ³

			If mv_par07 <> 1 .Or. lFifoOnLine
				nX := 0
			Else
				nX	:= aScan(aCols, { |x| x[nPProduto] == (cAliasSD1)->D1_COD .And.;
					x[nPLocal] == (cAliasSD1)->D1_LOCAL .And. IIf(nPNumCQ > 0, x[nPNumCQ] == (cAliasSD1)->D1_NUMCQ, .T.) })
			EndIf
			If nX == 0

				//³ Faz a montagem de uma linha em branco no aCols ³

				Aadd(aCols,	Array(nUsado+1))
				Aadd(aAmarrAFN,{})
				nX	:= Len(aCols)
				For nY := 1 to Len(aHeader)
					If !Empty(GetSx3Cache(aHeader[nY][2], "X3_CAMPO"))
						aCols[nX][nY] := CriaVar(aHeader[nY][2])
					EndIf
				Next nY
				aCols[nX][nUsado+1] := .F.
				If nPItem > 0
					cItem	:=	Soma1(cItem)
					If nPItem 	<> 0	;	aCols[nX,nPItem]  := cItem	;	EndIf
				Endif
			EndIf

			//³ Preenche os campos com base nas notas originais  ³

			aCols[nX,nPProduto] := (cAliasSD1)->D1_COD
			aCols[nX,nPLocal]   := (cAliasSD1)->D1_LOCAL
			aCols[nX,nPTes]    	:= MV_PAR04
			If nPNumCQ 	 <> 0	;	aCols[nX,nPNumCQ]  	:= (cAliasSD1)->D1_NUMCQ	;	EndIf
			If nPSegum 	 <> 0	;	aCols[nX,nPSegum]  	:= (cAliasSD1)->D1_SEGUM	; 	EndIf
			If nPConta 	 >  0	;	aCols[nX,nPConta]	:= (cAliasSD1)->D1_CONTA	; 	Endif
			If nPItemCta >  0 	; 	aCols[nX,nPItemCta]	:= (cAliasSD1)->D1_ITEMCTA	; 	Endif
			If nPCCusto  >  0 	; 	aCols[nX,nPCCusto] 	:= (cAliasSD1)->D1_CC 		; 	Endif
				If nPCF		 >  0 	; 	aCols[nX,nPCF] 		:= Posicione("SF4",1,cFilSF4+MV_PAR04,"F4_CF")		; 	Endif
			If nPPeso	 <> 0	;	aCols[nX,nPPeso]  	+= (cAliasSD1)->D1_PESO		; 	EndIf

			If nNFOri  <>	0
				aCols[nX,nNFOri]  	:= (cAliasSD1)->D1_DOC
			EndIf
			If nITOri  <>	0
			   aCols[nX,nITOri]  	:= (cAliasSD1)->D1_ITEM
			EndIf
			If nSerOri <>	0
			   aCols[nX,nSerOri]  	:= (cAliasSD1)->D1_SERIE
			EndIf

			aCols[nX,nPUM]    := (cAliasSD1)->D1_UM
			aCols[nX,nPTotal] += xMoeda((cAliasSD1)->D1_TOTAL,SF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),dDataBase,,SF1->F1_TXMOEDA,MAFISRET(,'NF_TXMOEDA'))


			//³Ponto de entrada p/ atualizar item a item do aCols da factura original selecionada  |

	  		cPe	:=	LocxPE(44)
			If !Empty(cPe)
				ExecBlock(cPe,.F.,.F.,{nX})
			EndIf

			//³ Atualiza os acumuladores do rateio  ³

			nPesoTotal += (cAliasSD1)->D1_PESO
			nVlrTotal  += xMoeda((cAliasSD1)->D1_TOTAL,SF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),dDataBase,,SF1->F1_TXMOEDA,MAFISRET(,'NF_TXMOEDA'))


			//³ Verifica os itens apontados ao SIGAPMS  ³

			dbSelectArea("AFN")
			MsSeek(cFilAFN+(cAliasSD1)->D1_DOC+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_ITEM)
			While !Eof() .And. cFilAFN+(cAliasSD1)->D1_DOC+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_ITEM==;
								AFN_FILIAL+AFN_DOC+AFN_SERIE+AFN_FORNEC+AFN_LOJA+AFN_ITEM
				If AFN->AFN_REVISA==PmsAF8Ver(AFN->AFN_PROJET)
					aAdd(aAmarrAFN[nx],{AFN->AFN_PROJET,AFN->AFN_REVISA,AFN->AFN_TAREFA,(cAliasSD1)->D1_TOTAL*(AFN->AFN_QUANT/(cAliasSD1)->D1_QUANT),(cAliasSD1)->D1_PESO*(AFN->AFN_QUANT/(cAliasSD1)->D1_QUANT),0,0,"",(cAliasSD1)->D1_COD})
				EndIf
				dbSelectArea("AFN")
				dbSkip()
			Enddo
		EndIf
		dbSelectArea(cAliasSD1)
		dbSkip()
	EndDo
	If lQuery
		dbSelectArea(cAliasSD1)
		dbCloseArea()
		ChkFile("SD1")
		dbSelectArea("SD1")
	EndIf
	If lEnd
		Exit
	Endif
Next nSF1
If lEnd
   aCols	:=	aClone(aSavaCols)
	Return
Endif
If Len(aCols) == 0
	MsgAlert(STR0152 + " " + STR0153)
	aCols := aClone(aSavaCols)
	Return
Endif
aSecs := {}
oProcess:IncRegua1(STR0242)
oProcess:SetRegua2(Len(aCols)*Len(aCGastos))
oProcess:IncRegua2(STR0243)

If nTipNota	== 1 //Frete

	//³ Faz o rateio do frete nos itens  ³

	cItem 	:= StrZero(0,TamSX3('D1_ITEM')[1])
	nLenAcols:=(Len(aCols)*Len(aCGastos))
	aCols		:=	aSize(aCols,nLenAcols)
	aAmarrAFN:=	aSize(aAmarrAFN,nLenAcols)
	For nx := 1 to nLenAcols
		For nI:=1 To Len(aCGastos)
			If nI>1
		    	nX++
		    	AIns(aCols,nX)
		    	AIns(aAmarrAFN,nX)
		    	aCols[nX]		:=	aClone(aCTemp[1])
		    	aAmarrAFN[nX]	:=	aClone(aCTemp[2])
		   	Else
		    	aCTemp:={{},{}}
		    	aCTemp[1]:=aClone(aCols[nX])
		   		aCTemp[2]:=aClone(aAmarrAFN[nX])
		   	Endif
		   	cItem:=Soma1(cItem)
		   	aCols[nX,nPItem] 	:= cItem
			aCols[nX,nPTes] 	:= aCGastos[nI][2]
			If nPCF		 >  0 	; 	aCols[nX,nPCF]	:= Posicione("SF4",1,cFilSF4+aCGastos[nI][2],"F4_CF")		; 	Endif

			If nRatFrete == 2 .And. nPesoTotal > 0
				aCols[nx][nPTotal]	:= NoRound((aCols[nx][nPPeso]/nPesoTotal)*aCGastos[nI][1],nDecs,@nDifTotal)
				For nW := 1 to Len(aAmarrAFN[nx])
					aAmarrAFN[nX,nW][6] := NoRound((aAmarrAFN[nX,nW][5]/nPesoTotal)*aCGastos[nI][1],nDecs)
					aAmarrAFN[nx,nW][7] := aCols[nX][nPTotal]
				Next nW
				If NoRound(nDifTotal,nDecs) >= (1/(10**nDecs))
					aCols[nx][nPTotal]	+= NoRound(nDifTotal,nDecs)
					nDifTotal			-= NoRound(nDifTotal,nDecs)
				EndIf
				aCols[nx][nPVlUnit]	:= aCols[nx][nPTotal]
			Else
				aCols[nx][nPTotal]	:= NoRound((aCols[nx][nPTotal]/nVlrTotal)*aCGastos[nI][1],nDecs,@nDifTotal)
				For nW := 1 to Len(aAmarrAFN[nX])
					aAmarrAFN[nX,nW][6] := NoRound((aAmarrAFN[nX,nW][4]/nVlrTotal)*aCGastos[nI][1],nDecs)
					aAmarrAFN[nX,nW][7] := aCols[nX][nPTotal]
				Next nw
				If NoRound(nDifTotal,nDecs) >= (1/(10**nDecs))
					aCols[nx][nPTotal]	+= NoRound(nDifTotal,nDecs)
					nDifTotal			-= NoRound(nDifTotal,nDecs)
				EndIf
				aCols[nx][nPVlUnit]	:= aCols[nx][nPTotal]
			EndIf
		Next
		If !lEnd
			oProcess:IncRegua2(STR0244+Alltrim(STR(nX))+"/"+Alltrim(STR(nLenAcols)))
		Else
			Exit
		Endif
	Next nX
	MaColsToFis(aHeader,aCols,,"MT100",.T.,,,.T.)
Else //Despesa

	//³ Faz o rateio da despesa  (Gastos de Importacao) ³

	cItem := StrZero(0,TamSX3('D1_ITEM')[1])
	nLenAcols:=(Len(aCols)*Len(aCGastos))
	aCols:=aSize(aCols,nLenAcols)
	aAmarrAFN:=	aSize(aAmarrAFN,nLenAcols)
	For nx := 1 to nLenAcols
		For nI:=1 To Len(aCGastos)
		    If nI>1
		    	nX++
		    	Ains(aCols,nX)
		    	Ains(aAmarrAFN,nX)
		    	aCols[nX]:=aClone(aCTemp[1])
		    	aAmarrAFN[nX]:=aClone(aCTemp[2])
		    Else
		    	aCTemp:={{},{}}
		    	aCTemp[1]:=aClone(aCols[nX])
		    	aCTemp[2]:=aClone(aAmarrAFN[nX])
		    Endif
		    cItem:=Soma1(cItem)
		    aCols[nX,nPItem] := cItem
			aCols[nX,nPTes] := aCGastos[nI][2]
			If nPCF		 >  0 	; 	aCols[nX,nPCF]	:= Posicione("SF4",1,cFilSF4+aCGastos[nI][2],"F4_CF")		; 	Endif

			If nRatDesp == 2 .And. nPesoTotal > 0
				aCols[nX][nPTotal]	:= NoRound((aCols[nX][nPPeso]/nPesoTotal)*aCGastos[nI][1],nDecs,@nDifTotal)
				For nW := 1 to Len(aAmarrAFN[nx])
					aAmarrAFN[nX,nW][6] := NoRound((aAmarrAFN[nX,nW][5]/nPesoTotal)*aCGastos[nI][1],nDecs)
					aAmarrAFN[nx,nW][7] := aCols[nX][nPTotal]
				Next nW
				If NoRound(nDifTotal,nDecs) >=  (1/(10**nDecs))
					aCols[nX][nPTotal]	+= NoRound(nDifTotal,nDecs)
					nDifTotal 			-= NoRound(nDifTotal,nDecs)
				EndIf
				aCols[nX][nPVlUnit]	:= aCols[nX][nPTotal]
			Else
				aCols[nX][nPTotal]	:= NoRound((aCols[nX][nPTotal]/nVlrTotal)*aCGastos[nI][1],nDecs,@nDifTotal)
				For nW := 1 to Len(aAmarrAFN[nX])
					aAmarrAFN[nX,nW][6] := NoRound((aAmarrAFN[nX,nW][4]/nVlrTotal)*aCGastos[nI][1],nDecs)
					aAmarrAFN[nX,nW][7] := aCols[nX][nPTotal]
				Next nw
				If NoRound(nDifTotal,nDecs) >= (1/(10**nDecs))
					aCols[nX][nPTotal]	+= NoRound(nDifTotal,nDecs)
					nDifTotal 			-= NoRound(nDifTotal,nDecs)
				EndIf
				aCols[nX][nPVlUnit]	:= aCols[nX][nPTotal]
			EndIf
		Next
		If !lEnd
			oProcess:IncRegua2(STR0244+Alltrim(STR(nX))+"/"+Alltrim(STR(nLenAcols)))
		Else
			Exit
		Endif
	Next nX
	If cPaisLoc <> "ARG" .And. FindFunction("LxAjusPr")
		LxAjusPr(aCGastos, @aCols)
	EndIf
	MaColsToFis(aHeader,aCols,,"MT100",.T.,,,.T.)
Endif

aRecsSF1	:=	AClone(aRecs)

If !lEnd
	oProcess:IncRegua2(STR0245)
Else
	aSize(aCols,nX)
Endif

If lActBrow
	Eval(bDoRefresh) //Atualiza o folder financeiro.
	oGetDados:obrowse:refresh()
	/*
	³Atualiza o browse de qtde de produtos.³
	*/
	lDel := Iif(Len(oBSomaItens:AARRAY)>0,.T.,.F.)
	While lDel
		nLin:= Len(oBSomaItens:AARRAY)
		If Len(oBSomaItens:AARRAY) == 1
			oBSomaItens:AARRAY[nLin,1] := ''
			oBSomaItens:AARRAY[nLin,2] := 0
			lDel:=.F.
		Else
			Adel(oBSomaItens:AARRAY,nLin)
			ASize(oBSomaItens:AARRAY,Len(oBSomaItens:AARRAY)-1)
		EndIf
	EndDo
EndIf
Return
/*
±±³Fun‡…o    ³Locxgastos ³³±±
±±³Descri‡…o ³ Inclusao das despesas de uma nota de  frete                ³±±
±±³Uso       ³ LOCXNF	-  Notas de frete                                 ³±±
*/
Function LocxGastos()
Local aArea := GetArea()
Local aCpos := {}
Local nX := 0
//Local nTamAc := 0
Local nDel := 0
Local nOpc := 0
Local oDlg, oGetGastos
Local lRet := .F.

If Empty(aHGastos)
	aCpos:={"D1_TOTAL","D1_TES"}
	aHGastos:={}
	aCGastos:={}
	DbSelectArea("SX3")
	DbSetOrder(2)
	For nX:=1 To Len(aCpos)
		If MsSeek(aCpos[nX])
			If (X3USO(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL )
				Aadd(aHGastos,{AllTrim(X3Titulo()),;
								SX3->X3_CAMPO,;
								SX3->X3_PICTURE,;
								SX3->X3_TAMANHO,;
								SX3->X3_DECIMAL,;
								If(AllTrim(X3_CAMPO)=="D1_TES",'ExistCpo("SF4").AND.MaAvalTes("E",M->D1_TES)','M->D1_TOTAL>0'),;
								SX3->X3_USADO,;
								SX3->X3_TIPO,;
								SX3->X3_F3,;
								SX3->X3_CONTEXT,;
								X3CBOX(),;
								SX3->X3_RELACAO,;
								".T."})
			EndIf
		Endif
	Next
	Aadd(aCGastos,Array(Len(aHGastos)+1))
	For nX:=1 To Len(aHGastos)
		aCGastos[1][nX]:=Criavar(aHGastos[nX][2])
	Next
	aCGastos[1][Len(aCGastos[1])]:=.F.
Endif

DEFINE MSDIALOG oDlg TITLE STR0028 From 0,0 To 400,400 Of oMainWnd Pixel
	oGetGastos := MsNewGetDados():New(050,030,175,175,GD_INSERT+GD_UPDATE+GD_DELETE,,"AllwaysTrue()" ,,/*alteraveis*/,/*freeze*/,,/*fieldok*/,/*superdel*/,/*delok*/,oDlg,@aHGastos,@aCGastos)
ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||aCGastos:=oGetGastos:aCols,nOpc:=1,oDlg:End()},{||nOpc:=0,oDlg:End()}) CENTERED

lRet:=(nOpc==1)
If nOpc==1
	nOpc:=Len(aCGastos)
	nLenAc:=Len(aCGastos[1])
	nDel:=0
	For nX:=nOpc To 1 Step -1
		If aCGastos[nX][nLenAc]
			nDel++
			Adel(aCGastos,nX)
		Endif
	Next
	If nDel>0
		aCGastos:=aSize(aCGastos,nOpc-nDel)
	Endif
Endif

RestArea(aArea)
Return(lRet)
/*/
±±³Fun‡…o    ³LocxChePed ³³±±
±±³Descri‡…o ³ Checa se existe um pedido asocioado a N.F.                 ³±±
/*/
Function LocxChePed(cAlias,nRecNo)
Local aAreaSD2		:= SD2->(GetArea())
Local nRecnoSF2	:=	SF2->(Recno())
Local cSeek 		:= ""
Local lRet 			:= .F.
Local cAprPed	:=	GetNewPar('MV_APRPED','3')

If cAprPed=='1'
	lRet	:=	.T.
ElseIf cAprPed=='2'
	lRet	:=	.F.
Else
	SF2->(MsGoTo(nRecNo))
	cSeek := xFilial("SD2")+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA

	DbSelectArea("SD2")
	DbSetOrder(3)

	If MsSeek(cSeek)
		Do While !Eof() .AND. cSeek == D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA
	   	If !Empty(D2_PEDIDO)
			If cPaisLoc $ "ARG|URU|PAR|BOL|CHI" .and. IsBlind()
				lRet := .T.
			Else
				If !MsgYesNo(STR0133 , STR0018)
					lRet := .T.
				EndIf
			EndIf
	    	Exit
	    EndIf
	  		dbSkip()
	 	End
	EndIf
	RestArea(aAreaSD2)
	SF2->(MsGoTo(nRecnoSF2))
Endif
Return lRet
/*/
±±³Fun‡…o    ³VisualNfRem|³±±
±±³Descri‡…o ³ Monta uma tela visualizando a NF ou Remito.      		  ³±±
±±³Parametros³ExpC1: Alias do Arquivo          - Obrigatorio              ³±±
±±³          ³ExpC2: Posicao do Registro       - Obrigatorio              ³±±
±±³Uso       ³ AP7   	                                                  ³±±
/*/
Function VisualNfRem(cAlias,nReg)
Private aPE		:=	Array(SnMaxPE,2)
Private aCfgNF	:=	{}
Private aRotina := {{ "", "AxPesqui", 2 },{ "" ,"LOCXDLGNF", 0, 2}}
Private lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)    //Integracao SIGAEIC
Private lEICFinanc	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.) //Integracao SIGAEIC - Financeiro
Private lFacImport	:= .F.
Private l103Class	:= .F.
lLocxAuto 			:=	Iif(Type("lLocxAuto") <> "U", lLocxAuto, .F. )

DbSelectArea(cAlias)
MsGoTo(nReg)
aCfgNf := MontaCfgNf(Val(&(Substr(cAlias,2,2)+"_TIPODOC")),{},.T.)
NFSetPrv(aCfgNF)
LocxDlgNF(aCfgNf,2)
Return
/*/

±±³Fun‡…o    ³ValidVend  ³±±
±±³Descri‡…o ³ Valida o vendedor                                          ³±±

/*/
Static Function ValidVend()
Local cPe	:=	LocxPE(36)
Private lRetv := .T.

IF !EMPTY(cVendedor)
	SA3->(dbSetOrder(1))
	lRetV :=	SA3->(MsSeek(xFilial("SA3")+cVendedor))
Endif
If !Empty(cPe)
	Execblock(cPE,.F.,.F.)
EndIf
Return lRetV
/*
±±³Fun‡…o    ³LocxGerRem ³±±
±±³Descri‡…o ³ Gera remisiones para as notas de importacao.               ³±±
*/
Function LocxGerRem(aCab,aRecIMP)
Local lRet := .T.
DEFAULT aRecIMP	:=	{}

lFacImport := ( AllTrim(SF1->F1_TIPO_NF) $ "123456789AB" )
If lFacImport
    If SF1->F1_TIPO_NF $ "56789AB"
       	LocxGrvCusImp(SF1->F1_DOC,SF1->F1_SERIE,,,@aRecImp)
	EndIf
Else
	Aviso(STR0018,STR0155+CRLF+STR0156+cTitRem+STR0157,{STR0021}) //"Esta NF nao e de import.."###"A geracao de "###" e permitida somente para notas de import.."
Endif
Return(lRet)
/*/
±±³Fun‡…o    ³NFxInclui  ³±±
±±³Descri‡…o ³ Prepara tela de Inclusão para LocxNF                       ³±±
±±³Parametros³ExpC1: Tipo da NF                                           ³±±
/*/
Function NFxInclui(nTipo,bInit,lPerg)
Local nX := 0
Local aPerg := {}
Private aCfgNF	:=	{}
Private aRotina := {}
Private aPE		:=	Array(SnMaxPE,2)
Private lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)    //Integracao SIGAEIC
Private lEICFinanc	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.) //Integracao SIGAEIC - Financeiro
Private lFacImport	:= .F.
Private l103Class	:= .F.
Private aDupl		:= {}
Private cFunName	:= IIf(Type("cFuncName")!="C",Upper(Alltrim(FunName())),cFuncName)	//Funcao Origem
Private lGerarCFD := .F.
Private aGerarCFD := {}
Private nNFTipo  := 0
Private cEspecie 	:= ""

Default lPerg	:= .T.

For nX := 1 to 5
	AADD(aRotina,{"","",0,3})
Next


//³Chama o grupo de Perguntas e acerta o array de perguntas³

//O tipo da variavel aPergunta estah sendo modificado para que a funcao Pergunte nao
//restaure a pergunta anterior

If Type("aPergunta")=="A"
	aPergunta  := NIL
EndIf

If lPerg
	If !Pergunte("MATXNF",.T.)
		Return .F.
	Endif
Else
	Pergunte("MATXNF",.F.)
Endif
AEval(aPergunta,{|x,y| AAdd(aPerg,&("MV_PAR"+StrZero(y,2))==1)})

aCfgNF := MontaCfgNf(nTipo,aPerg,.T.)
aPE	   := aClone(aCfgNF[SaPE]) //fina096
NFSetPrv(aCfgNF)
bFunAuto := bInit

lGerarCFD := .F.
aGerarCFD := {}
If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
	aGerarCFD := CFDVerific()
	If aGerarCFD[1] <> "0"
		If Empty(aGerarCFD[2])
			lGerarCFD := .T.
		Endif
	Else
		lGerarCFD := .F.
	Endif
Endif
nNFTipo  := aCfgNf[SnTipo]
cespecie := aCfgNF[ScEspecie]

LocxDlgNF(aCfgNf,3)
Return

/*/
±±³Fun‡…o    ³NFxExclui  ³±±
±±³Descri‡…o ³ Prepara tela de Exclusão para LocxNF                       ³±±
±±³Parametros³ExpC1: Tipo da NF                                           ³±±
/*/
Function NFxExclui(cAlias,bInit,nRecno)
Local nX			 := 0
Local aPerg 		:= {}
Private aCfgNF		:=	{}
Private aRotina		:= {}
Private aPE			:=	Array(SnMaxPE,2)
Private lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)    //Integracao SIGAEIC
Private lEICFinanc	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.) //Integracao SIGAEIC - Financeiro
Private lFacImport	:= .F.
Private l103Class	:= .F.
Private lAnulaSF3   := .F.  //Determina se anula ou exclui o registro no Livro Fiscal(MaFisAtuSF3)
Private lGerarCFD 	:= .F.
Private aGerarCFD 	:= {}

For nX := 1 to 5
	AADD(aRotina,{"","",0,5})
Next

DbSelectArea(cAlias)
MsGoTo(nRecno)

//³Chama o grupo de Perguntas e acerta o array de perguntas³

If Type("aPergunta")=="A"
	aPergunta  := NIL
EndIf

If !Pergunte("MATXNF",.T.)
	Return .F.
Endif
AEval(aPergunta,{|x,y| AAdd(aPerg,&("MV_PAR"+StrZero(y,2))==1)})
//³Monta array de configuracao da NF ³

aCfgNF := MontaCfgNf(Val(&(Substr(cAlias,2,2)+"_TIPODOC")),aPerg,.T.)

NFSetPrv(aCfgNF)
bFunAuto := bInit

lGerarCFD := .F.
aGerarCFD := {}
If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
	aGerarCFD := CFDVerific()
	If aGerarCFD[1] <> "0"
		If Empty(aGerarCFD[2])
			lGerarCFD := .T.
		Endif
	Else
		lGerarCFD := .F.
	Endif
Endif

LocxDlgNF(aCfgNF,4)
Return
/*/
±±³Fun‡…o    ³ChkButtons  ³±±
±±³Descri‡…o ³ Retorna somente botoes utilizados pata a opcao do nopcx    ³±±
±±³Parametros³ExpA1: aRaay com os Botoes originalmente carregados         ³±±
±±³          ³ExpN1: nOpcx                                                ³±±
/*/
Static Function ChkButtons(aButtons,nOpc)
Local aBut := {}
AEval(aButtons, {|x,y| If(  Len(x)<5 .OR. Empty(x[5]) .OR. StrZero(nOpc,1)$x[5],AAdd(aBut,x),  ) } )
Return AClone(aBut)
/*/
±±³Fun‡…o    ³ChkTeclas ³±±
±±³Descri‡…o ³ Retorna somente Teclas utilizados pata a opcao do nopcx    ³±±
±±³Parametros³ExpA1: aRaay com os Teclas originalmente carregados         ³±±
±±³          ³ExpN1: nOpcx                                                ³±±
/*/
Static Function ChkTeclas(aTeclas,nOpc)
Local aTec := {}
AEval(aTeclas, {|x,y| If(  Len(x)<3 .OR. Empty(x[3]) .OR. StrZero(nOpc,1)$x[3],AAdd(aTec,x),  ) } )
Return AClone(aTec)

FUNCTION A467Lote()
Return .T.

FUNCTION A467LotCtl()
Return .T.

/*/
±±³Fun‡…o    ³NFGrpDep   ³±±
±±³Descri‡…o ³  Força validação da Filial quando digitada                 ³±±
/*/
Function ValFild (cTab)
  If cTab == "SF2"
	  if !Empty(M->F2_FILDEST)
		  NfFilDest(M->F2_FILDEST)
		  NFGrpDep(M->F2_CLIENTE,M->F2_LOJA)
		  LocXVal('F2_LOJA')
	  EndIf
  ElseIf Ctab == "SF1"
  	  If !Empty(M->F1_FILORIG)
  	  	 NfTrfOri(M->F1_FILORIG)
      Endif
  EndIf
  eval(bRefresh)
Return .T.

/*/
±±³Fun‡…o    ³NFGrpDep  ³±±
±±³Descri‡…o ³ Atualiza campo de Grupo de Depositos apos Digitar Fornec   ³±±
/*/
Function NFGrpDep(cFornece,cLoja)
Local 	aArea  := SA2->(GetArea())
SA2->(DbSetOrder(1))
If SA2->(MsSeek(xFilial("SA2")+cFornece+cLoja))
	M->F2_GRPDEP := SA2->A2_GRPDEP
EndIf
RestArea(aArea)
Return .T.

/*
±±³Fun‡…o    ³NfFilDest  ³±±
±±³Descri‡…o ³ Valida Filial destino para Remito de transf.      	      ³±±
*/
Function NfFilDest(cNumFil)
Local aArea    := GetArea()
Local aAreaSM0 := SM0->(GetArea())
Local aAreaSX5 := SX5->(GetArea()) //Correcao Alias
Local cChave   := ''
Local cX5Descri:= ''
Local nTamEmFil:= Len(cFilAnt+cEmpAnt+cNumFil)
Local nTamEmSA2:= nTamEmFil
Local nTamForLj:= TamSX3("A2_COD")[1] + TamSX3("A2_LOJA")[1]
Local lGestCorp:= nTamEmFil > Len(SX5->X5_CHAVE)
Local lRet	   := .F.

If lGestCorp
	nTamEmSA2 := Len(cFilAnt+cEmpAnt+cNumFil)
EndIf

If !SM0->(MsSeek(cEmpAnt+cNumFil))
	Return .F.
EndIf

If lGestCorp
	cChave := xFilial("SX5")+'75'
	SX5->(DbSeek(cChave,.T.))
	While cChave == SX5->(X5_FILIAL+X5_TABELA)
		If SubsTr(SX5->X5_DESCRI,1,nTamEmSA2) == SubsTr(cFilAnt+cEmpAnt+cNumFil,1,nTamEmSA2)
			lRet := .T.
			Exit
		EndIf
	    SX5->(DbSkip())
	EndDo
Else
	lRet := SX5->(MsSeek(xFilial("SX5")+'75'+cFilAnt+cEmpAnt+cNumFil))
EndIf

If !lRet
	If MsgYesNo(STR0175,STR0038)
		lRet := AddFilSA2(cNumFil)
	EndIf
EndIf
If lGestCorp
	cX5Descri := Substr(SX5->X5_DESCRI,nTamEmFil+1,nTamForLj)
Else
	cX5Descri := Substr(SX5->X5_DESCRI,1,nTamForLj)
EndIf
If lRet .AND. SA2->(MsSeek(xFilial('SA2')+cX5Descri))
	If aCfgNf[SAliasHead]=="SF2"
		M->F2_CLIENTE := SA2->A2_COD
		M->F2_LOJA    := SA2->A2_LOJA
	ElseIf aCfgNf[SAliasHead]=="SF1"
		M->F1_FORNECE := SA2->A2_COD
		M->F1_LOJA    := SA2->A2_LOJA
	EndIf
Else
	lRet := .F.
EndIf

RestArea(aAreaSX5)
RestArea(aAreaSM0)
RestArea(aArea)
Return lRet

/*
±±³Fun‡…o    ³AddFilSA2 ³±±
±±³Descri‡…o ³ Cria Filial do sistema como fornec. no SA2              	  ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                       		  ³±±
*/
Static Function AddFilSA2(cNewFil)
Local cChave	:= ''
Local cProvedor := ''
Local cLoja     := ''
Local nTamEmFil	:= Len(cNewFil+cEmpAnt+cFilAnt)
Local nTamProv  := TamSX3("A2_COD" )[1]
Local nTamLoja	:= TamSX3("A2_LOJA")[1]
Local lContinua := .F.
Local lGestCorp	:= nTamEmFil > Len(SX5->X5_CHAVE)
Local lMT462Vld := SuperGetMv("MT462VLD",.F.,.T.)
Local lRet		:= .F.
Local cChaveX5	:= ''
Local aDados := FWGetSX5("75")
Local nA := 0
Local lAddSA2Par := FindFunction("AddSA2PAR")
Local lMT462X5 := .F. //Nova regra de gravacao dos parametros na SX5 (75)

If cPaisLoc == "PAR"
	lMT462X5 := SuperGetMv("MV_MT462X5",.F.,.F.) 
EndiF

//Se SX5 (75) estiver vazio, então usa rotina padrão, que o primeiro registro grava certo e a rotina FWPUTSX5 nao incliui novo registro se tabela estiver vazia.
If cPaisLoc == "PAR" .And. lGestCorp .And. lMT462X5 .And. lAddSA2Par .And. Len(aDados) > 0
	lRet := AddSA2PAR(cNewFil)
	Return(lRet)
Endif

DbSelectArea("SA2")
DbSetOrder(1)
lRet := ConPad1(,,,"SA2")

//³MT462VLD - Parametro criado para nao permitir fornec.es diferentes nos    |
//|           documentos de entrada e saida da transf.. Vale ressaltar 		 |
//|           que se o parametro for desabilitado podem ocorrer problemas de |
//|           custos nos documentos de entrada.                              |

If lMT462Vld
	If lGestCorp
		If len(aDados) > 0
			For nA := 1 To Len(aDados)
				If Substr(aDados[nA][4],1,nTamEmFil) == cNewFil+cEmpAnt+cFilAnt
					lContinua := .T.
					Exit
				EndIf
				cChaveX5    := aDados[nA][3]
				cChaveX5 := Soma1(cChaveX5)
			Next
			If lContinua
				cProvedor := SubStr(aDados[nA][4],nTamEmFil+1,nTamProv)
				cLoja     := SubStr(aDados[nA][4],nTamEmFil+nTamProv+1,nTamLoja)
				If SA2->A2_COD <> cProvedor .Or. SA2->A2_LOJA <> cLoja
					Aviso(STR0018,STR0249 + AllTrim(cProvedor)+" - "+AllTrim(cLoja)+' '+STR0250,{"Ok"},,STR0251)
					lRet := .F.
				EndIf
			EndIf
		Else
			cChaveX5 := "000001" //Inicializa a chave com este numero quando não temos registro na tabela SX5 referente a tabela generica 75
		EndIf
	Else
		If SX5->(MsSeek(xFilial("SX5")+'75'+cNewFil+cEmpAnt+cFilAnt))
			cProvedor := SubStr(SX5->X5_DESCRI,1,nTamProv)
	    	cLoja     := SubStr(SX5->X5_DESCRI,nTamProv+1,nTamLoja)
			If SA2->A2_COD <> cProvedor .Or. SA2->A2_LOJA <> cLoja
				Aviso(STR0018,STR0249 + AllTrim(cProvedor)+" - "+AllTrim(cLoja)+' '+STR0250,{"Ok"},,STR0251)
				lRet := .F.
		    EndIf
		EndIf
	EndIf
EndIf

If lRet
	RecLock('SX5',.T.)
	X5_FILIAL  := xFilial('SX5')
	X5_TABELA  := '75'
	If !lGestCorp
		X5_CHAVE   := cFilAnt+cEmpAnt+cNewFil
		X5_DESCRI  := SA2->A2_COD+SA2->A2_LOJA
		X5_DESCSPA := SA2->A2_COD+SA2->A2_LOJA
		X5_DESCENG := SA2->A2_COD+SA2->A2_LOJA
	Else
		X5_CHAVE   := cChaveX5
		X5_DESCRI  := cFilAnt+cEmpAnt+cNewFil+SA2->A2_COD+SA2->A2_LOJA
		X5_DESCSPA := cFilAnt+cEmpAnt+cNewFil+SA2->A2_COD+SA2->A2_LOJA
		X5_DESCENG := cFilAnt+cEmpAnt+cNewFil+SA2->A2_COD+SA2->A2_LOJA
	EndIf
	MsUnlock()

EndIf
Return lRet

/*
±±³Fun‡…o    ³NfTrfOri  ³±±
±±³Descri‡…o ³ Busca Documentos de saida na filial original.              ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.     	                      ³±±
*/
Function NfTrfOri(cNumFil)
Local aRecOri	  := {}
Local aRetPE 	  := {}
Local cAlias,nIndex,cWhile,cSeek,aCpos,cCondicao,cMyNumFor
Local cCampo      := ""
Local nPosCOD     := 0
Local nPosUM      := 0
Local nPosLOCAL   := 0
Local nPosQUANT   := 0
Local nPosQtSeg   := 0
Local nPosVUNIT   := 0
Local nPosTOTAL   := 0
Local nPosTES     := 0
Local nPosCF      := 0
Local nPosItem    := 0
Local nPosIDENTB6 := 0
Local nPosLOTECTL := 0
Local nPosNUMLOTE := 0
Local nPosDTVALID := 0
Local nPosPOTENCI := 0
Local nPosNfOri   := 0
Local nPosItOri   := 0
Local nPosSeOri   := 0
Local nI		  := 0
Local lLocxD2D1   := ExistBlock('LOCXD2D1')
Local lLocxRemE   := ExistBlock('LOCXREME')
Local aAreaAnt	  := {}
Local cCodForTrf  := ""
Local cLojForTrf  := ""
Local cAliasQry   := ""
Local cQuery	  := ""
Local nT_ITEM		:= TamSX3("D1_ITEM")[1]
Local cFilSF4		:= xFilial("SF4")
Local lLocxM462   := ExistBlock('LOCXM462')
Local IntDl := GetMV('MV_INTDL') == 'S'
Local nPosServi:=0
Local nPosLocz:=0
Local nPosEnder := 0
Local lWmsNew   := SuperGetMV("MV_WMSNEW",.F.,.F.)

If Empty(cNumFil)
	Aviso(STR0018,OemToAnsi(STR0184),{STR0021}) //"Informe a Filial de Origem."
	Return .F.
EndIf
// Valida todos os dados da filial selecionada e preenche os campos de Fornec./Loja.
If !(NfFilDest(cNumFil) .AND. LocXVal('F1_LOJA') .AND. LxA103VFold('NF_CODCLIFOR',M->F1_FORNECE) .AND. LxA103VFold('NF_LOJA',M->F1_LOJA))
	Return .F.
EndIf

cMyNumFor := GetNumFor(cNumFil)
If Empty(cMyNumFor)
	Aviso(STR0018,OemToAnsi(STR0186),{STR0021}) //"Nao foram encontrados docs. de transf. para essa filial."
	Return .F.
EndIf

If Type("lLocxAuto") <> "U" .And. lLocxAuto
   Return .T.
Endif

// Melhoria de performance para trabalhar somente com os registros relevantes (D2_QTDAFAT > 0)

aAreaAnt := GetArea()
cCodForTrf := Substr(cMyNumFor,1,TamSX3("F2_CLIENTE")[1])
cLojForTrf := Substr(cMyNumFor,TamSX3("F2_CLIENTE")[1]+1,TamSX3("F2_LOJA")[1])
cAliasQry := "ANOTASTRF"
cQuery := "SELECT DISTINCT F2_DOC, F2_SERIE, F2_CLIENTE, F2_LOJA"
cQuery += "FROM "+RetSqlName("SF2")+" SF2 "
cQuery += "JOIN "+RetSqlName("SD2")+" SD2 "
cQuery += "ON SF2.F2_DOC = SD2.D2_DOC "
cQuery += "AND SF2.F2_SERIE = SD2.D2_SERIE "
cQuery += "AND SF2.F2_CLIENTE = SD2.D2_CLIENTE "
cQuery += "AND SF2.F2_LOJA = SD2.D2_LOJA "
cQuery += "AND SF2.F2_CLIENTE = '" + cCodForTrf + "' "
cQuery += "AND SF2.F2_LOJA = '" + cLojForTrf + "' "
cQuery += "AND SD2.D2_QTDAFAT > 0 "
cQuery += "AND SF2.D_E_L_E_T_ = '' "
cQuery += "AND SD2.D_E_L_E_T_ = '' "
cQuery := ChangeQuery(cQuery)

If lLocxM462
	cQuery :=	Execblock("LOCXM462",.F.,.F.,{cQuery,cCodForTrf,cLojForTrf,cNumFil} )
EndIf

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

DbSelectArea(cAliasQry)
(cAliasQry)->(DbGoTop())
While !Eof()
	AADD(aNotasTrf,F2_DOC)
	DbSelectArea(cAliasQry)
	dbSkip()
EndDo
(cAliasQry)->(dbCloseArea())
RestArea(aAreaAnt)

cAlias    := "SF2"
nIndex    := 2   //F2_FILIAL+F2_CLIENTE+F2_LOJA+F2_DOC+F2_SERIE
cSeek     := "'" + GetFilOri('SF2',cNumFil) + cMyNumFor + "'"
cWhile    := "!EOF() .AND. F2_FILIAL+F2_CLIENTE+F2_LOJA  == " + cSeek
If Len(aNotasTrf) > 0
	cCondicao := "Ascan(aNotasTrf,{|x| x == SF2->F2_DOC}) > 0 .AND. F2_TIPODOC == '54' .AND. NFHasSD2It(Recno()) .And. F2_FILDEST == cFilAnt"
Else
	cCondicao := "F2_TIPODOC == '54' .AND. NFHasSD2It(Recno()) .And. F2_FILDEST == cFilAnt"
EndIf
aCpos     := {'F2_DOC','F2_SERIE','F2_EMISSAO'}

//Ponto de entrada para incluir campos en Remitos de Entrada

If lLocxRemE
	aRetPE	:= ExecBlock("LOCXREME",.F.,.F.,{aCpos})
	If ValType(aRetPE) == "A"
		aCpos	:= aClone(aRetPE)
	End If
End If

aRecOri := LocxF4(cAlias,nIndex,cWhile,cSeek,aCpos,,,cCondicao,,,,,,,.F.)
If !(ValType(aRecOri)=="A" .AND. Len(aRecOri) >= 3 .AND. ValType(aRecOri[3])=="A" .AND. Len(aRecOri[3])> 0)
	Return .F.
EndIf

SF2->(MSGoto(aRecOri[3][1]))

cAlias    := "SD2"
nIndex    := 3   //D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM
cSeek     := "'" + SF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA) + "'"
cWhile    := "!EOF() .AND. D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA  == " + cSeek
cCondicao := "D2_TIPODOC == '54' .And. D2_QTDAFAT > 0 .And. D2_QTDAFAT == D2_QUANT .And. SD2->D2_ESPECIE == SF2->F2_ESPECIE"

aRecOri := LocxGrid(cAlias,cWhile,cCondicao,,,cSeek,nIndex,{'D2_COD'},,,,,,)
If !(ValType(aRecOri)=="A" .AND. Len(aRecOri) >= 6 .AND. ValType(aRecOri[6])=="A" .AND. Len(aRecOri[6]) > 0)
	Return .F.
EndIf

For nI := 1 To Len(aHeader)
	cCampo := Upper(AllTrim(aHeader[nI][2]))
	Do Case
		Case cCampo == "D1_COD"
			nPosCOD := nI
		Case cCampo == "D1_UM"
			nPosUM := nI
		Case cCampo == "D1_LOCAL"
			nPosLOCAL := nI
		Case cCampo == "D1_QUANT"
			nPosQUANT := nI
		Case cCampo == "D1_QTSEGUM"
			nPosQtSeg := nI
		Case cCampo == "D1_VUNIT"
			nPosVUNIT := nI
		Case cCampo == "D1_TOTAL"
			nPosTOTAL := nI
		Case cCampo == "D1_TES"
			nPosTES := nI
		Case cCampo == "D1_CF"
			nPosCF := nI
		Case cCampo == "D1_IDENTB6"
			nPosIDENTB6 := nI
		Case cCampo == "D1_LOTECTL"
			nPosLOTECTL := nI
		Case cCampo == "D1_NUMLOTE"
			nPosNUMLOTE := nI
		Case cCampo == "D1_DTVALID"
			nPosDTVALID := nI
		Case cCampo == "D1_POTENCI"
			nPosPOTENCI := nI
		Case cCampo == "D1_ITEM"
			nPosItem    := nI
		Case cCampo == "D1_NFORI"
			nPosNfOri   := nI
		Case cCampo == "D1_ITEMORI"
			nPosItOri   := nI
		Case cCampo == "D1_SERIORI"
			nPosSeOri   := nI
		Case cCampo == "D1_SERVIC"
			nPosServi   := nI
		Case cCampo == "D1_LOCALIZ"
			nPosLocz   := nI
		Case cCampo == "D1_ENDER"
			nPosEnder   := nI
	EndCase
Next nI

M->F1_DOC     := SF2->F2_DOC
M->F1_SERIE   := SF2->F2_SERIE
M->F1_EMISSAO := SF2->F2_EMISSAO
M->F1_NATUREZ := SF2->F2_NATUREZ
M->F1_DTDIGIT := dDataBase
M->F1_MOEDA   := SF2->F2_MOEDA
M->F1_TXMOEDA := SF2->F2_TXMOEDA

// Redefinir o numero maximo de itens do objeto de acordo
// com a qtde de registros obtidos em aRecOri[6]
oGetDados:nMax:=Len(aRecOri[6])

If valtype(nTotQtIte) <> NIL
   nTotQtIte:= 0
EndIf

aCols := {}
For nI := 1 To Len(aRecOri[6])
	SD2->(MsGoto(aRecOri[6][nI]))
	oGetDados:AddLine()

	//³Ponto de entrada utilizado para carregar campos da tabela SD2 para a tabela SD1 |

	If lLocxD2D1
		Execblock('LOCXD2D1',.F.,.F.)
	EndIf

	//³SD1 - Itens de Entrada³

	If(nPosCOD     > 0 ,aCols[Len(aCols)][nPosCOD]     := SD2->D2_COD    ,)
	If(nPosUM      > 0 ,aCols[Len(aCols)][nPosUM]      := SD2->D2_UM     ,)
	If(nPosLOCAL   > 0 ,aCols[Len(aCols)][nPosLOCAL]   := SD2->D2_LOCDEST,)
	If(nPosQUANT   > 0 ,aCols[Len(aCols)][nPosQUANT]   := SD2->D2_QTDAFAT,)
	If(nPosQtSeg   > 0 ,aCols[Len(aCols)][nPosQtSeg]   := ConvUm(SD2->D2_COD,SD2->D2_QTDAFAT,0,2),)
	If(nPosVUNIT   > 0 ,aCols[Len(aCols)][nPosVUNIT]   := SD2->D2_PRCVEN ,)
	If(nPosTOTAL   > 0 ,aCols[Len(aCols)][nPosTOTAL]   := SD2->D2_TOTAL  ,)
	If(nPosTES     > 0 ,aCols[Len(aCols)][nPosTES]     := SD2->D2_TESENT ,)
	If(nPosCF      > 0 ,aCols[Len(aCols)][nPosCF]      := Posicione("SF4",1,cFilSF4+SD2->D2_TESENT,"F4_CF") ,)
	If(nPosIDENTB6 > 0 ,aCols[Len(aCols)][nPosIDENTB6] := SD2->D2_NUMSEQ ,)
	If(nPosItem    > 0 ,aCols[Len(aCols)][nPosItem   ] := Padl(SD2->D2_ITEM,nT_ITEM,"0"),)
	If(nPosNfOri   > 0 ,aCols[Len(aCols)][nPosNfOri  ] := SD2->D2_DOC    ,)
	If(nPosItOri   > 0 ,aCols[Len(aCols)][nPosItOri  ] := SD2->D2_ITEM   ,)
	If(nPosSeOri   > 0 ,aCols[Len(aCols)][nPosSeOri  ] := SD2->D2_SERIE  ,)

	If Rastro(SD2->D2_COD)
		If(nPosLOTECTL > 0 ,aCols[Len(aCols)][nPosLOTECTL] := SD2->D2_LOTECTL ,)
		If(nPosNUMLOTE > 0 ,aCols[Len(aCols)][nPosNUMLOTE] := SD2->D2_NUMLOTE ,)
		If(nPosDTVALID > 0 ,aCols[Len(aCols)][nPosDTVALID] := SD2->D2_DTVALID ,)
		If(nPosPOTENCI > 0 ,aCols[Len(aCols)][nPosPOTENCI] := SD2->D2_POTENCI ,)
	EndIf
	If Valtype(nTotQtIte) <> NIL
		nTotQtIte += aCols[Len(aCols)][nPosQUANT]
	EndIf

	If IntDl .And. cPaisLoc== "ARG"
		SB5->(DBSetOrder(1))
		If SB5->(MSSeek(xFilial("SB5")+SD2->D2_COD, .F.)) .or. SB5->(MSSeek(GetFilOri('SB5',cNumFil)+SD2->D2_COD, .F.))
			If(nPosServi > 0 ,aCols[Len(aCols)][nPosServi] := SB5->B5_SERVENT ,)
			If(nPosLocz > 0 .And. Empty(SB5->B5_SERVENT) ,aCols[Len(aCols)][nPosLocz] := SB5->B5_LOCALIZ ,)
			If lWmsNew .And. Funname() == "MATA462TN"
				If(nPosEnder > 0 ,aCols[Len(aCols)][nPosEnder] := SB5->B5_ENDECD ,)
			EndIf
		EndIf
	EndIf
Next nI
oGetDados:lNewLine := .F.
aCols:=aSort(aCols,,,{|x,y| x[nPosItem]<y[nPosItem]})
MaFisClear()
MaColsToFis(aHeader,aCols,,"MT100",.T.)

//³Ponto de Entrada para Alterar o Acols ³
cPE := LOCXPE(65)
If !Empty(cPE)
	aRetPE:= ExecBlock(cPE,.F.,.F.,{aCfgNF[SnTipo],aCols})
	If ValType(aRetPE) == "A"
   		aCols := aClone(aRetPE)
	EndIf
EndIf

oGetDados:oBrowse:nAt := 1
oGetDados:oBrowse:Refresh()
Return .T.
/*
±±³Fun‡…o    ³GetFilOri ³±±
±±³Descri‡…o ³ Pega xfilial de um arquivo, para uma outra filial.         ³±±
*/
Static Function GetFilOri(cAlias,cNumFil)
Local cTamFil := ""
//Local nDif	:= 0
//Local nDif1	:= 0
//Local cLayout := ""
//Local lEmp	:= .F.
//Local lUnid := .F.
//Local lFil	:= .F.
//Local nAchou := 0
Local aAreaFil := GetArea()

DEFAULT cAlias  := Alias()
DEFAULT cNumFil := cFilAnt
If FWModeAccess(cAlias) == "E"
	cTamFil := cNumFil
Else
	If cPaisLoc == "BOL" .AND. FunName() == "MATA462TN" .AND. cAlias == "SF4"
		cTamFil := TamFilBol(cNumFil)
	ElseIf cPaisLoc == "ARG" .AND. FunName() == "MATA462TN" .AND. FwSizeFilial() >= 4 .And. FWModeAccess("SF4",3) == "E"
		cTamFil := cNumFil
	Else
		cTamFil := Space(FwSizeFilial())
	EndIf
EndIf
RestArea(aAreaFil)
Return cTamFil
/*
±±³Fun‡…o    ³GetNumfor  ³±±
±±³Descri‡…o ³ Retorna o numero de Fornec. DESTA filial em outra filial	  ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                       		  ³±±
*/
Static Function GetNumfor(cNumFil)
Local cChave	:= ''
Local cMyNum	:= ''
Local nTamEmFil	:= Len(cNumFil+cEmpAnt+cFilAnt)
Local nTamForLj	:= TamSX3("A2_COD")[1] + TamSX3("A2_LOJA")[1]
Local lContinua := .F.
Local lGestCorp	:= nTamEmFil > Len(SX5->X5_CHAVE)
Local cFilBus:=GetFilOri('SX5',cNumFil)
Local lGetSA2PAR := FindFunction("GetSA2PAR")
Local lMT462X5 := .F. //Nova regra de gravacao dos parametros na SX5 (75)

If cPaisLoc == "PAR"
	lMT462X5 := SuperGetMv("MV_MT462X5",.F.,.F.) 
EndiF

If cPaisLoc == "PAR" .And. lGestCorp .And. lMT462X5 .And. lGetSA2PAR
	cMyNum := GetSA2PAR(cNumFil)
	Return(cMyNum)
Endif

If cEmpAnt != NIL .AND. cNumFil != NIL
	If !SM0->(MsSeek(cEmpAnt+cNumFil))
		Return cMyNum
	EndIf
	If lGestCorp
		cChave := xFilial("SX5")+'75'
		SX5->(DbSeek(cChave,.T.))
		While cChave == SX5->(X5_FILIAL+X5_TABELA)
			If Substr(SX5->X5_DESCRI,1,nTamEmFil) == cFilAnt+cEmpAnt+cNumFil
				lContinua := .T.
				Exit
			EndIf
		    SX5->(DbSkip())
		EndDo
		If lContinua
			cMyNum := SubStr(SX5->X5_DESCRI,nTamEmFil+1,nTamForLj)
		EndIf
	ElseIf SX5->(MsSeek(cFilBus+'75'+cNumFil+cEmpAnt+cFilAnt))
    	cMyNum := SubStr(SX5->X5_DESCRI,1,nTamForLj)
	EndIf
EndIf
Return cMyNum

/*
±±³Fun‡…o    ³RetForFil ³±±
±±³Descri‡…o ³ Retorna o numero de Fornec. de OUTRA filial NESTA  	      ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                      		  ³±±

*/
Function RetForFil(cNumFil)
Local cChave	:= ''
Local cNumFor	:= ''
Local nTamEmFil	:= Len(cFilAnt+cEmpAnt+cNumFil)
Local nTamForLj	:= TamSX3("A2_COD")[1] + TamSX3("A2_LOJA")[1]
Local lContinua := .F.
Local lGestCorp	:= nTamEmFil > Len(SX5->X5_CHAVE)

If !SM0->(MsSeek(cEmpAnt+cNumFil))
	Return cNumFor
EndIf
If lGestCorp
	cChave := xFilial("SX5")+'75'
	SX5->(DbSeek(cChave,.T.))
	While cChave == SX5->(X5_FILIAL+X5_TABELA)
		If Substr(SX5->X5_DESCRI,1,nTamEmFil) == cFilAnt+cEmpAnt+cNumFil
			lContinua := .T.
			Exit
		EndIf
	    SX5->(DbSkip())
	EndDo
	If lContinua
	   	cNumFor := SubStr(SX5->X5_DESCRI,nTamEmFil+1,nTamForLj)
	EndIf
ElseIf SX5->(MsSeek(xFilial("SX5")+'75'+cFilAnt+cEmpAnt+cNumFil)) .And. ;
	SA2->(MsSeek(xFilial('SA2')+SubStr(SX5->X5_DESCRI,1,nTamForLj)))
   	cNumFor := SubStr(SX5->X5_DESCRI,1,nTamForLj)
EndIf
Return cNumFor

/*

±±³Fun‡…o    ³GerTrfRet ³±±
±±³Descri‡…o ³ Gera entrada por transf..                           		  ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                       		  ³±±

*/
Static Function GerTrfRet(nRecOri,cFilDest)
Local aCposSF1   := {{},{}}
Local aCposSD1   := {{},{}}
Local cNumFilFor := NIL
Local cFilOri    := cFilAnt
Local nPosItem   := 0
Local lRetAuto	 := .F.
Local aCposUsr	 := {}
Local lWmsNew   := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local lRastro    := IIF(SuperGetMV("MV_RASTRO")=="S",.T.,.F.)

Private aHeader := {}
Private aCols   := {}
cFilAnt := cFilDest

SF2->(MsGoto(nRecOri))

cNumFilFor := RetForFil(cFilOri)
If Empty(cNumFilFor)
	If MsgYesNo(STR0175,STR0038) .AND. AddFilSA2(cFilOri)
		cNumFilFor := SA2->A2_COD+SA2->A2_LOJA
	Else
		Return .F.
	EndIf
EndIf
If !SA2->(MsSeek(xFilial('SA2')+cNumFilFor))
	Return .F.
EndIf

//SF1 - Cabecalho de Entrada
AAdd(aCposSD1[1], "D1_ITEM"   ); AADD(aCposSD1[2], 'Padl(SD2->D2_ITEM,TamSX3("D1_ITEM")[1],"0")')
AADD(aCposSF1[1], "F1_FILORIG"); AADD(aCposSF1[2], cFilOri         )
AADD(aCposSF1[1], "F1_DOC"    ); AADD(aCposSF1[2], SF2->F2_DOC     )
AADD(aCposSF1[1], "F1_SERIE"  ); AADD(aCposSF1[2], SF2->F2_SERIE   )
AADD(aCposSF1[1], "F1_FORNECE"); AADD(aCposSF1[2], SA2->A2_COD     )
AADD(aCposSF1[1], "F1_LOJA"   ); AADD(aCposSF1[2], SA2->A2_LOJA    )
AADD(aCposSF1[1], "F1_EMISSAO"); AADD(aCposSF1[2], SF2->F2_EMISSAO )
AADD(aCposSF1[1], "F1_DTDIGIT"); AADD(aCposSF1[2], dDataBase       )
AADD(aCposSF1[1], "F1_MOEDA"  ); AADD(aCposSF1[2], SF2->F2_MOEDA   )
AADD(aCposSF1[1], "F1_TXMOEDA"); AADD(aCposSF1[2], SF2->F2_TXMOEDA )
AADD(aCposSF1[1], "F1_TIPO"   ); AADD(aCposSF1[2], 'N' )
AADD(aCposSF1[1], "F1_FORMUL" ); AADD(aCposSF1[2], 'N' )
AADD(aCposSF1[1], "F1_ESPECIE"); AADD(aCposSF1[2], GetSESNew('RTE'))
AADD(aCposSF1[1], "F1_TIPODOC"); AADD(aCposSF1[2], '64' )

//SD1 - Itens de Entrada
AADD(aCposSD1[1], "D1_FILIAL" ); AADD(aCposSD1[2], 'xFilial("SD1")')
AADD(aCposSD1[1], "D1_COD"    ); AADD(aCposSD1[2], 'SD2->D2_COD    ')
AADD(aCposSD1[1], "D1_UM"     ); AADD(aCposSD1[2], 'SD2->D2_UM     ')
AADD(aCposSD1[1], "D1_LOCAL"  ); AADD(aCposSD1[2], 'SD2->D2_LOCDEST')
AADD(aCposSD1[1], "D1_QUANT"  ); AADD(aCposSD1[2], 'SD2->D2_QUANT  ')
AADD(aCposSD1[1], "D1_VUNIT"  ); AADD(aCposSD1[2], 'SD2->D2_PRCVEN ')
AADD(aCposSD1[1], "D1_TOTAL"  ); AADD(aCposSD1[2], 'SD2->D2_TOTAL  ')
AADD(aCposSD1[1], "D1_TES"    ); AADD(aCposSD1[2], 'SD2->D2_TESENT ')
AADD(aCposSD1[1], "D1_CF"     ); AADD(aCposSD1[2], 'Posicione("SF4",1,xFilial("SF4")+SD2->D2_TESENT,"F4_CF") ')
AAdd(aCposSD1[1], "D1_IDENTB6"); AADD(aCposSD1[2], 'SD2->D2_NUMSEQ ')
AAdd(aCposSD1[1], "D1_ESPECIE"); AADD(aCposSD1[2], 'GetSESNew("RTE")')
AAdd(aCposSD1[1], "D1_TIPODOC"); AADD(aCposSD1[2], '"64"')
AAdd(aCposSD1[1], "D1_TIPO"   ); AADD(aCposSD1[2], '"N"')
AADD(aCposSD1[1], "D1_NFORI"  ); AADD(aCposSD1[2], 'SD2->D2_DOC')
AADD(aCposSD1[1], "D1_SERIORI"); AADD(aCposSD1[2], 'SD2->D2_SERIE')
AADD(aCposSD1[1], "D1_ITEMORI"); AADD(aCposSD1[2], 'SD2->D2_ITEM')
If lRastro
	AADD(aCposSD1[1], "D1_LOTECTL"); AADD(aCposSD1[2], 'SD2->D2_LOTECTL ')
	AADD(aCposSD1[1], "D1_NUMLOTE"); AADD(aCposSD1[2], 'SD2->D2_NUMLOTE ')
	AADD(aCposSD1[1], "D1_DTVALID"); AADD(aCposSD1[2], 'SD2->D2_DTVALID ')
	AADD(aCposSD1[1], "D1_POTENCI"); AADD(aCposSD1[2], 'SD2->D2_POTENCI ')
EndIf

If cPaisLoc == "ARG"
	ArgGRemTrf(@aCposSD1, lRastro, lWmsNew)
EndIf

If SF2->F2_TIPORET=="1"  // Retorno Automático
	lRetAuto = .T.
EndIf

//³ Ponto de entrada para adicionar campos do usuário da tabela SD2 na tabela SD1 ³
//³ Utilizado para Tipo de Retorno Automático                                     ³

If lRetAuto
	cPe	:= LocxPE(71)
	If !Empty(cPe)
		aCposUsr := Execblock(cPE,.F.,.F.,{aCposSD1})
		If ValType(aCposUsr)=="A"
			aCposSD1 := aClone(aCposUsr)
		EndIf
	EndIf
EndIf

nPosItem := AScan(aCposSD1[1],"D1_ITEM")
SD2->(DbSetOrder(3))
SD2->(MsSeek( GetFilOri("SD2",cFilOri)+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA))
While !Eof() .AND. SD2->D2_FILIAL == GetFilOri("SD2",cFilOri) .AND.;
		SD2->D2_DOC     == SF2->F2_DOC     .AND.;
		SD2->D2_SERIE   == SF2->F2_SERIE   .AND.;
		SD2->D2_CLIENTE == SF2->F2_CLIENTE .AND.;
		SD2->D2_LOJA    == SF2->F2_LOJA

		AAdd(aCols, Array( Len(aCposSD1[1])+1 ) )
		//SD1 - Itens de Entrada
		AEval(aCposSD1[1],{|x,y| aCols[Len(aCols)][y] := &(aCposSD1[2][y])  } )
		aCols[Len(aCols)][Len(aCposSD1[1])+1] := .F.
	dbSelectArea("SD2")
	dbSkip()
End
aCols:=aSort(aCols,,,{|x,y| x[nPosItem]<y[nPosItem]})
aHeader := CposToHead(aCposSD1[1])

MsAguarde( {|| lRetGravacao := GravaNfGeral(aCposSF1,aCols,aCposSD1[1],64,aCfgNf[SaPergs],,.F.,,)},,STR0179,)
cFilAnt := cFilOri
Return lRetGravacao

/*

±±³Fun‡…o    ³NfVldDes  ³±±
±±³Descri‡…o ³ Valida Local Destino digitado no Item.                     ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                       	      ³±±

*/
Function NfVldDes(cLocDest)
Local nPosLocal := AScan(aHeader,{ |x| UPPER(Alltrim(x[2]))=="D2_LOCAL" })
Local lRet := Vazio() .OR. Pertence(Posicione("SX5",1,xFilial("SX5")+'74'+M->F2_GRPDEP,"X5DESCRI()"))

DEFAULT cLocDest := &(ReadVar())

// Se a transf. for para a mesma filial, o depósito deve ser diferente.
IF (lRet .AND. M->F2_FILDEST == cFilAnt .AND. nPosLocal > 0 .AND. ACols[n][nPosLocal] == cLocDest)
	Aviso(STR0018,STR0181,{STR0021}) // "O deposito Destino nao pode ser o mesmo de origem."
	lRet := .F.
EndIf
Return lRet

/*
±±³Fun‡…o    ³NFVldDep  ³±±
±±³Descri‡…o ³ Valida o grupo de depositos digitado.                      ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                  		      ³±±

*/
Function NFVldDep()
Local lRet := (Empty(SA2->A2_GRPDEP) .OR. (M->F2_GRPDEP == SA2->A2_GRPDEP))
If !lRet
	Aviso(STR0018,STR0180,{STR0021}) // "O Grupo de Deposito deve ser o mesmo informado no cadastro do fornec.."
EndIf
Return lRet
/*
±±³Fun‡…o    ³NFVldTES ³±±
±±³Descri‡…o ³ Valida o TES do documento de retorno.                      ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                      		  ³±±
*/
Function NFVldTES(cTesDest)
Local lRet := .F.
Local aAreaSF4 := GetArea('SF4')
DEFAULT cTesDest := &(ReadVar())
SF4->(DbSetOrder(1))
lRet := (SF4->(MsSeek(GetFilOri('SF4',M->F2_FILDEST)+cTesDest)))
If !lRet
	Aviso(STR0018,STR0182,{STR0021})
EndIf

RestArea(aAreaSF4)
Return lRet

/*

±±³Fun‡…o    ³ GerSD3Trf ³±±
±±³Descri‡…o ³ Cria movimento no SD3 referente a Transferencia            ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de Transferencia                        ³±±

*/
Static Function GerSD3Trf(cAlias,nReg,nEvento,cFilOri)
Local nPosCpo  := 0
Local aCposSD3 := {}
Local cDepTrf  := Padr(SuperGetMv("MV_DEPTRAN",.F.,"95"),TamSX3("D3_LOCAL")[1])
Local lTranSB2 := SuperGetMv("MV_TRANSB2",.F.,.F.)	  // Atualiza saldos de transf.

Default cAlias	:= ""
Default nReg	:= 0
Default nEvento	:= 0
Default cFilOri	:= ""

DbSelectArea(cAlias)
MsGoto(nReg)
cPE := LOCXPE(75)

Do Case
	Case nEvento == 1 // Faz a entrada no Deposito de Transferencia.
		SB1->(DbSetOrder(1))
		SB1->(MsSeek(xFilial("SB1")+SD2->D2_COD))
		AAdd(aCposSD3, {"D3_FILIAL" , xFilial("SD3")		,NIL } )
		AAdd(aCposSD3, {"D3_USUARIO", SubStr(cUsuario,7,15),NIL } )
		AAdd(aCposSD3, {"D3_NUMSEQ" , SD2->D2_NUMSEQ 		,NIL } )
		AAdd(aCposSD3, {"D3_TM"     , '499'      		    ,NIL } )
		AAdd(aCposSD3, {"D3_CF"     , 'DE4'         		,NIL } )
		AAdd(aCposSD3, {"D3_COD"    , SD2->D2_COD    		,NIL } )
		AAdd(aCposSD3, {"D3_ITEM"   , SD2->D2_ITEM   		,NIL } )
		AAdd(aCposSD3, {"D3_QUANT"  , SD2->D2_QUANT  		,NIL } )
		AAdd(aCposSD3, {"D3_UM"     , SD2->D2_UM     		,NIL } )
		AAdd(aCposSD3, {"D3_QTSEGUM", SD2->D2_QTSEGUM		,NIL } )
		AAdd(aCposSD3, {"D3_SEGUM"  , SD2->D2_SEGUM  		,NIL } )
		AAdd(aCposSD3, {"D3_LOCAL"  , cDepTrf        		,NIL } )
		AAdd(aCposSD3, {"D3_GRUPO"  , SB1->B1_GRUPO  		,NIL } )
		AAdd(aCposSD3, {"D3_TIPO"   , SB1->B1_TIPO   		,NIL } )
		AAdd(aCposSD3, {"D3_EMISSAO", SD2->D2_EMISSAO		,NIL } )
		AAdd(aCposSD3, {"D3_DOC"    , SD2->D2_DOC    		,NIL } )
		AAdd(aCposSD3, {"D3_LOTECTL", SD2->D2_LOTECTL		,NIL } )
		AAdd(aCposSD3, {"D3_NUMLOTE", SD2->D2_NUMLOTE		,NIL } )
		AAdd(aCposSD3, {"D3_DTVALID", SD2->D2_DTVALID		,NIL } )
		AAdd(aCposSD3, {"D3_POTENCI", SD2->D2_POTENCI		,NIL } )
		AAdd(aCposSD3, {"D3_PROJPMS", SD2->D2_PROJPMS		,NIL } )
		AAdd(aCposSD3, {"D3_TASKPMS", SD2->D2_TASKPMS		,NIL } )
		AAdd(aCposSD3, {"D3_LOCALIZ", SD2->D2_LOCALIZ		,NIL } )
		AAdd(aCposSD3, {"D3_CHAVE"  , 'RTS'           		,NIL } )
		If lTranSb2
			AAdd(aCposSD3, {"D3_CUSTO1" , SD2->D2_CUSTO1   		,NIL } )
			AAdd(aCposSD3, {"D3_CUSTO2" , SD2->D2_CUSTO2   		,NIL } )
			AAdd(aCposSD3, {"D3_CUSTO3" , SD2->D2_CUSTO3  		,NIL } )
			AAdd(aCposSD3, {"D3_CUSTO4" , SD2->D2_CUSTO4   		,NIL } )
			AAdd(aCposSD3, {"D3_CUSTO5" , SD2->D2_CUSTO5   		,NIL } )
		EndIf
        If !Empty(cPE)
			aRetPE:= ExecBlock(cPE,.F.,.F.,{aCposSD3,nEvento})
			If ValType(aRetPE) == "A"
				aCposSD3 := aClone(aRetPE)
			EndIf
		EndIf
		// Grava SD3 de transferencia
		Reclock("SD3",.T.)
		AEval(aCposSD3,{|x,y| nPosCpo := ColumnPos(x[1]),If(nPosCpo>0,FieldPut(nPosCpo,x[2]),) } )
		MsUnlock()
		// Atualiza o saldo atual (SB2) com os dados do SD3
		If lTranSb2
			B2AtuComD3({SD2->D2_CUSTO1,SD2->D2_CUSTO2,SD2->D2_CUSTO3,SD2->D2_CUSTO4,SD2->D2_CUSTO5},Nil,Nil,.F.,Nil,.T.,.F.)
		EndIf
	Case nEvento == 2 // Faz a Saida do Deposito de Transferencia
	    SD2->(DbSetOrder(3))
		If Empty(RetForFil(cFilOri)) .OR. !SD2->(MsSeek( xFilial("SD2")+SD1->D1_DOC+SD1->D1_SERIE+RetForFil(cFilOri)+SD1->D1_COD+SD1->D1_ITEMORI))
			Return .F.
		EndIf
		Reclock("SD2",.F.)
		D2_QTDAFAT -= SD1->D1_QUANT
		MsUnlock()
		SD3->(DbSetOrder(3))
		If SD3->( MsSeek( xFilial("SD3")+SD2->( D2_COD+cDepTrf+D2_NUMSEQ ) ) )
			SB1->(DbSetOrder(1))
			SB1->( MsSeek( xFilial("SB1")+SD1->D1_COD ) )
			AAdd(aCposSD3, {"D3_FILIAL" ,  xFilial("SD3")			,NIL } )
			AAdd(aCposSD3, {"D3_USUARIO",  SubStr(cUsuario,7,15)	,NIL } )
			AAdd(aCposSD3, {"D3_NUMSEQ" ,  SD1->D1_NUMSEQ			,NIL } )
			AAdd(aCposSD3, {"D3_TM"     , '999'          			,NIL } )
			AAdd(aCposSD3, {"D3_CF"     , 'RE4'          			,NIL } )
			AAdd(aCposSD3, {"D3_COD"    , SD1->D1_COD    			,NIL } )
			AAdd(aCposSD3, {"D3_ITEM"   , SD1->D1_ITEM  			,NIL } )
			AAdd(aCposSD3, {"D3_QUANT"  , SD1->D1_QUANT  			,NIL } )
			AAdd(aCposSD3, {"D3_UM"     , SD1->D1_UM     			,NIL } )
			AAdd(aCposSD3, {"D3_QTSEGUM", SD1->D1_QTSEGUM			,NIL } )
			AAdd(aCposSD3, {"D3_SEGUM"  , SD1->D1_SEGUM  			,NIL } )
			AAdd(aCposSD3, {"D3_LOCAL"  , cDepTrf        			,NIL } )
			AAdd(aCposSD3, {"D3_GRUPO"  , SB1->B1_GRUPO  			,NIL } )
			AAdd(aCposSD3, {"D3_TIPO"   , SB1->B1_TIPO   			,NIL } )
			AAdd(aCposSD3, {"D3_EMISSAO", SD1->D1_DTDIGIT			,NIL } )
			AAdd(aCposSD3, {"D3_DOC"    , SD1->D1_DOC    			,NIL } )
			AAdd(aCposSD3, {"D3_LOTECTL", SD1->D1_LOTECTL			,NIL } )
			AAdd(aCposSD3, {"D3_NUMLOTE", SD1->D1_NUMLOTE			,NIL } )
			AAdd(aCposSD3, {"D3_DTVALID", SD1->D1_DTVALID			,NIL } )
			AAdd(aCposSD3, {"D3_POTENCI", SD1->D1_POTENCI			,NIL } )
			AAdd(aCposSD3, {"D3_LOCALIZ", SD3->D3_LOCALIZ			,NIL } )
			AAdd(aCposSD3, {"D3_CHAVE"  , 'RTE'	          			,NIL } )
			If lTranSb2
				AAdd(aCposSD3, {"D3_CUSTO1" , SD1->D1_CUSTO 	   		,NIL } )
				AAdd(aCposSD3, {"D3_CUSTO2" , SD1->D1_CUSTO2   			,NIL } )
				AAdd(aCposSD3, {"D3_CUSTO3" , SD1->D1_CUSTO3  			,NIL } )
				AAdd(aCposSD3, {"D3_CUSTO4" , SD1->D1_CUSTO4 	  		,NIL } )
				AAdd(aCposSD3, {"D3_CUSTO5" , SD1->D1_CUSTO5   			,NIL } )
			EndIf
		    If !Empty(cPE)
				aRetPE:= ExecBlock(cPE,.F.,.F.,{aCposSD3,nEvento})
				If ValType(aRetPE) == "A"
			   		aCposSD3 := aClone(aRetPE)
				EndIf
	        EndIf
			// Grava SD3 de transferencia
			Reclock("SD3",.T.)
			AEval(aCposSD3,{|x,y| nPosCpo := ColumnPos(x[1]),If(nPosCpo>0,FieldPut(nPosCpo,x[2]),) } )
			MsUnlock()
			// Atualiza o saldo atual (SB2) com os dados do SD3
			If lTranSb2
				B2AtuComD3({SD1->D1_CUSTO,SD1->D1_CUSTO2,SD1->D1_CUSTO3,SD1->D1_CUSTO4,SD1->D1_CUSTO5},Nil,Nil,.F.,Nil,.T.,.F.)
			EndIf
		EndIf
EndCase
Return .T.

/*
±±³Fun‡…o    ³ GerSD3Trf  ³±±
±±³Descri‡…o ³ Cria movimento no SD3 referente a transf.            	  ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                       		  ³±±
*/
Function NFHasSD2It(nReg)
Local cAlias,nIndex,cSeek,cWhile,cCondicao
Local aAreaSF2 := GetArea("SF2")
Local aAreaSD2 := GetArea("SD2")
Local aRecOri  := {}
Local lRet     := .F.

SF2->(MsGoto(nReg))
cAlias    := "SD2"
nIndex    := 3
cSeek     := "'" + SF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA) + "'"
cWhile    := "!EOF() .AND. D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA  == " + cSeek
cCondicao := "D2_TIPODOC == '54' .And. D2_QTDAFAT > 0 .And. D2_QTDAFAT == D2_QUANT .And. SD2->D2_ESPECIE == SF2->F2_ESPECIE"

aRecOri := LocxGrid(cAlias,cWhile,cCondicao,,,cSeek,nIndex,{'D2_COD'},,,,,,)
lRet    := (ValType(aRecOri)=="A" .AND. Len(aRecOri) >= 6 .AND. ValType(aRecOri[6])=="A" .AND. Len(aRecOri[6]) > 0)

RestArea(aAreaSF2)
RestArea(aAreaSD2)
Return lRet
/*
±±³Fun‡…o    ³RetFilFor ³±±
±±³Descri‡…o ³ Retorna o da filial de um fornec. X.       	              ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                 	          ³±±
*/
Static Function RetFilFor(cFornece,cLoja)
Local cFilFor	:= ''
Local cChave	:= ''
Local cCodForLj	:= ''
Local nTamEmFil	:= Len(cFilAnt+cEmpAnt+cFilAnt)
Local nTamFil	:= Len(cFilAnt+cEmpAnt)
Local nTamForLj	:= TamSX3("A2_COD")[1] + TamSX3("A2_LOJA")[1]
Local lGestCorp	:= nTamEmFil > Len(SX5->X5_CHAVE)

If lGestCorp
	cChave := xFilial("SX5")+'75'
	SX5->(DbSeek(cChave,.T.))
	While cChave == SX5->(X5_FILIAL+X5_TABELA)
		If Substr(SX5->X5_DESCRI,1,nTamFil) == cFilAnt+cEmpAnt
			cCodForLj := SubStr(SX5->X5_DESCRI,nTamEmFil+1,nTamForLj)
			If cFornece+cLoja == cCodForLj
				cFilFor := Substr(SX5->X5_DESCRI,nTamFil+1,Len(cFilAnt))
				Exit
			EndIf
		EndIf
	    SX5->(DbSkip())
	EndDo
Else
	cChave := xFilial("SX5")+'75'+cFilAnt+cEmpAnt
	If !SX5->(MsSeek(cChave))
		Return NIL
	EndIf
	While cChave == Left(SX5->(X5_FILIAL+X5_TABELA+X5_CHAVE),Len(cChave))
		cCodForLj := SubStr(SX5->X5_DESCRI,1,nTamForLj)
		If cFornece+cLoja == cCodForLj
			cFilFor := Substr(SX5->X5_CHAVE,5,2)
			Exit
		EndIf
	    SX5->(DbSkip())
	EndDo
EndIf
Return cFilFor

/*
±±ºPrograma  ³GravaSE2  º±±
±±ºDesc.     ³Gravacao do SE2                                             º±±
*/
Static Function GRAVASE2(aDupl,dDEmissao,aFin)
Local nX
Local cPref		:= ""
Local nValDup	:=	0
Local nTotCruz	:=	0
Local nVlCruz	:=	0
Local nDupTot	:=	0
Local aRecSE2	:=	{}
Local lMultNat  := SuperGetMv("MV_MULNATP")
Local cCodAprov := ""
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local cQuery	:= ""
Local cAliasSE2 := ""
Local cE2Num    := ""
Local cFilE2    := xFilial("SE2")
Local cFornece	:= ""
Local aDuplMCur :=	{}	//(20/04/18): Array Value in main currency if was manually changes
Local aDuplTB   := {} //Tax bases array according to payment terms
Local nTaxRate  := 0
Local nTotTBVl  := 0
Local nTotVATV  := 0
Local nVlBasI   := 0
Local nVlVatI   := 0
Local lFINXDETMP := FindFunction("FINXDETMP")

Private	nResIRRF := 0
Private	nResInss := 0
Private	nResIss  := 0

If cPaisLoc=="RUS"
	dDEmissao	:= Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_EMISSAO,SF2->F2_DTSAIDA)
	aDuplMCur	:= Condicao(Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_VLBRUTM,SF2->F2_VLBRUTM),cCondicao,,dDEmissao)
	aDuplTB		:= Condicao(Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_BASIMP1,SF2->F2_BASIMP1),cCondicao,,dDEmissao)
EndIf
//³ Inicializa a Natureza ³

DEFAULT cNatureza := ""
If !Empty(SuperGetMV("MV_2DUPREF"))
	cPref := &(SuperGetMV("MV_2DUPREF"))
Endif
cPref := If(Empty(cPref),CriaVar("SF1->F1_PREFIXO"),cPref)
cPref := IIf(aCfgNf[SAliasHead]=="SF1",cPref,cSerie)

If lUsaNewKey
	/*CHAVE UNICA - Alterado por Tiago Silva*/
	cE2Num:=Extrae(aDupl[1],2)
	cFilE2:=xFilial("SE2")
	cAliasSE2 := "ALOCXPRFX"
	cQuery := " SELECT MAX(E2_PREFIXO) E2PRFXMAX FROM " + RetSqlName("SE2")
	cQuery += " WHERE E2_FILIAL = '" + cFilE2 + "'"
	cQuery += " AND E2_NUM      = '" + cE2Num + "'"
	cQuery += " AND E2_FORNECE = '" + SA2->A2_COD + "'"
	cQuery += " AND E2_LOJA     = '" + SA2->A2_LOJA + "'"
	cQuery += " AND D_E_L_E_T_  = ''"
   	cQuery	  := ChangeQuery(cQuery)
	cAliasSE2 := CriaTrab(Nil,.F.)

	dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasSE2, .T., .T. )
	DbSelectArea(cAliasSE2)

	If !Empty( (cAliasSE2)->E2PRFXMAX )
		cPref:= Soma1( (cAliasSE2)->E2PRFXMAX , TamSX3("E2_PREFIXO")[1] )
		While .T.
			SE2->(dbSetOrder(1))
			If (SE2->(dbSeek(cFilE2+cPref+cE2Num)))
				cPref:= Soma1(cPref, TamSX3("E2_PREFIXO")[1])
			Else
				EXIT
			EndIf
		EndDo
	ElseIf Empty( (cAliasSE2)->E2PRFXMAX ) .AND. cPaisLoc == "PER" .AND. empty(substr(&(SuperGetMV("MV_2DUPREF")),1,TamSX3("E2_PREFIXO")[1]))
		cPref:= Soma1(" ")
	EndIf
	(cAliasSE2)->(DbCloseArea())
Endif


If Empty(cNatureza).AND. !Empty(SuperGetMV("MV_2DUPNAT"))
	cNatureza := &(SuperGetMV("MV_2DUPNAT"))
	cNatureza := If(Empty(cNatureza),Criavar(IIf(cPaisLoc == "RUS" .And. aCfgNf[SAliasHead]=="SF2","SF2->F2_NATUREZ","SF1->F1_NATUREZ")),cNatureza)
	MaFisAlt("NF_NATUREZA",cNatureza)
	aFin[ScNatureza] := cNatureza
EndIf
cPref+=Space(Len(SE2->E2_PREFIXO) - Len(cPref))

//³Obtem o codigo do aprovador atraves do parametro MV_FINAPXX ³
//³(onde XX é a moeda em questao)                              ³

cCodAprov := FA050Aprov(aFin[SnMoedaFin])
If cPaisLoc == "RUS"
	nTaxRate := RU09XFUN08(Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_VALIMP1,SF2->F2_VALIMP1)/*nTaxAmnt*/,;
									Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_BASIMP1,SF2->F2_BASIMP1)/*nTaxBase*/)  //LocxNF2.PRW 21 dec 2018
EndIf

For nX := 1 to Len(aDupl)
	If ! lFacImport
		nValDup := DesTrans(Extrae(aDupl[nx],5))
	Else
        nValDup := aDupl[nX][5]
    EndIf
	dbSelectArea("SE2")

		If AllTrim(cCodAprov) == ""
			cCodAprov := Fa006User( __cUserID, .F., 2, aFin[SnMoedaFin])
		EndIf

	RecLock("SE2",.T.)
	Replace E2_FILORIG With cFilAnt
	Replace	E2_FILIAL  With xFilial()
	Replace E2_PREFIXO With cPref
	Replace E2_EMISSAO With dDEmissao
	Replace E2_EMIS1   With dDataBase
	Replace	E2_FORNECE With SA2->A2_COD
	Replace	E2_LOJA    With SA2->A2_LOJA
	Replace	E2_NOMFOR  With SA2->A2_NREDUZ
	Replace	E2_TIPO    With aCfgNf[ScEspecie]
	Replace E2_MOEDA   With aFin[SnMoedaFin]
	Replace	E2_LA      With "S"

	If (cPaisLoc == "RUS")
		//start supplement wrided 18/07/2017
		cFornece:=SA2->A2_COD
		E2_CONUNI := Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_CONUNI,SF2->F2_CONUNI)
		E2_MOEDA  := Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_MOEDA,SF2->F2_MOEDA)
		E2_F5QCODE := Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_CNTID,SF2->F2_CNTID)
		E2_F5QUID := Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_F5QUID,SF2->F2_F5QUID)

		SA6->(DbSetOrder(5))
		If SA6->(DbSeek(xFilial("SA6")+"1"))
			Replace	E2_PORTADO With SA6->A6_COD
		Endif

		FIL->(dbSetOrder(1))
		If FIL->(dbSeek(xFilial('FIL') + cFornece))

			Replace	E2_FORBCO With FIL->FIL_BANCO
			Replace	E2_FORAGE With FIL->FIL_AGENCI
			Replace	E2_FORCTA With FIL->FIL_CONTA

		EndIf
		Replace	E2_ALQIMP1	With nTaxRate //18 dec 2018
		//end supplement wrided 18/07/2017
	Endif

	If !lFACImport
		Replace E2_NUM     With Iif(Extrae(aDupl[nx],2)<> cNFiscal,cNFiscal,Extrae(aDupl[nx],2))
		Replace	E2_PARCELA With AllTrim(Extrae(aDupl[nx],3))
		Replace	E2_VENCORI With Ctod(Extrae(aDupl[nx],4))
		Replace	E2_VENCTO  With Ctod(Extrae(aDupl[nx],4))
		Replace	E2_VENCREA With DataValida(Ctod(Extrae(aDupl[nx],4)),.T.)
	Else
		Replace E2_NUM     With cNFiscal
		Replace	E2_PARCELA With aDupl[nx][2]
		Replace	E2_VENCORI With aDupl[nx][4]
		Replace	E2_VENCTO  With aDupl[nx][4]
		Replace	E2_VENCREA With DataValida(aDupl[nx][4],.T.)
	EndIf
	Replace	E2_VALOR   With nValDup
	Replace	E2_SALDO   With nValDup
	Replace	E2_NATUREZ With aFin[ScNatureza]
	Replace	E2_ORIGEM  With cFunName
	if cPaisLoc == "RUS"
		nTaxa := Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_TXMOEDA,SF2->F2_TXMOEDA)
	EndIf
	Replace	E2_TXMOEDA With nTaxa
	if cPaisLoc == "COL"
		Replace E2_TRMPAC With If(aCfgNF[SAliasHead] == "SF1",CVALTOCHAR(SF1->F1_TRMPAC),CVALTOCHAR(SF2->F2_TRMPAC))
	endif
	If cPaisLoc == "CHI"
		Replace  E2_CGC	With SA2->A2_CGC
	EndIf
	Replace E2_CODAPRO With cCodAprov
	Replace E2_STATLIB With "01"
	If cPaisLoc == "RUS"
		nDupTot	+=	SE2->E2_VALOR
	EndIf
	If nX == Len(aDupl)
		If cPaisLoc	== "RUS"
			nVlCruz := Round((Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_VLBRUTM,SF2->F2_VLBRUTM) - nTotCruz),MsDecimais(1))
			nVlBasI := Round((Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_BASIMP1,SF2->F2_BASIMP1) - nTotTBVl),MsDecimais(1))
			nVlVatI := Round((nDupTot         - nTotTBVl - nVlBasI - nTotVATV),MsDecimais(1))
		Else
			nVlCruz := Round( Abs(xMoeda(MaFisRet(,'NF_BASEDUP'),nMoedaNF,1,dDataBase,MsDecimais(1)+1,nTaxa)) - Abs(nTotCruz), MsDecimais(1))
		EndIf
	Else
		If cPaisLoc	== "RUS"
			nVlCruz := aDuplMCur[nx][2]
			nVlBasI := aDuplTB[nx][2]
			nVlVatI := nValDup - nVlBasI
		Else
			If cPaisLoc	== "ARG"
				nVlCruz := ArgVlCruz("SE2", nMoedaNF, nTaxa)
			Else
				If nMoedaNF == 1 .Or. (nMoedaNF > 1 .and. nMoedaNF <> SE2->E2_MOEDA)
					nVlCruz := Round(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,0),MsDecimais(1))
				Else
					nVlCruz := Round(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,nTaxa),MsDecimais(1))
				EndIf
			EndIf
		EndIf
	Endif
	If cPaisLoc=="PER"
		If aCfgNf[SAliasHead]=="SF1"
			SerieNfId("SE2",1,"E2_SERORI",,,,SF1->F1_SERORI) //Projeto Chave Unica - Tiago Silva
	    Else
	    	SerieNfId("SE2",1,"E2_SERORI",,,,SF2->F2_SERORI) //Projeto Chave Unica - Tiago Silva
	    EndIf
	EndIf
	If cPaisLoc == "EUA"
		GrvSE2EUA(cFunname)
	EndIf
	nTotCruz += nVlCruz
	dbSelectArea("SE2")
	If cPaisLoc == "RUS"
			nTotTBVl += nVlBasI
			nTotVATV += nVlVatI
			SE2->E2_BASIMP1 := nVlBasI
			SE2->E2_VALIMP1 := nVlVatI
	EndIf

	If lMultNat
		//³ Verifica se foi gerada multinatureza para o titulo ³

		If GRAVASEV("SE2",nValDup)
			SE2->E2_MULTNAT := "1"
		EndIf
	EndIf

	a050DupPag(Iif(cFunName=="MATA101N","MATA100",cFunName),(nX==1),0)
	SE2->E2_VLCRUZ := nVlCruz
	If SE2->(ColumnPos('E2_CCR'))>0  .AND. aCfgNf[SAliasHead]=="SF1" .and. SF1->(ColumnPos("F1_CC")) > 0 .and. !Empty(SF1->F1_CC)
		SE2->E2_CCR :=SF1->F1_CC
	ElseIf SE2->(ColumnPos('E2_CCR'))>0 .AND. aCfgNf[SAliasHead]=="SF2" .and. SF2->(ColumnPos("F2_CC")) > 0 .and. !Empty(SF2->F2_CC)
		SE2->E2_CCR :=SF2->F2_CC
	EndIf
	If cPaisLoc <> "RUS"
		nDupTot	+=	SE2->E2_VALOR
	EndIf
	AAdd(aRecSE2,SE2->(Recno()))
Next nx
nDupTot	:=	xMoeda(nDupTot,aFin[SnMoedaFin],nMoedaNF,dDataBase,,,nTaxa)
If lMultNat .And. lFINXDETMP .And. Select("SEZTMP") > 0
	FINXDETMP() //Limpia tabla temporal de prorrateo por multi-naturaleza
EndIf
Return {aRecSE2,{nDupTot,cPref,SE2->E2_NUM}}
/*
±±ºPrograma  ³GravaSE1  º±±
±±ºDesc.     ³Gravacao do SE1                                             º±±
*/
Static Function GRAVASE1(aDupl,aRecnoI,aFin,aDuplAux)
Local nX,j,nY
Local cPref		:= ""
Local nValDup	:=	0
Local nTotCruz	:=	0
Local nVlCruz	:=	0
Local aVend 	:= {}
LOCAL bVend 	:= { |x| "SE1->E1_VEND"  + Str(x,1) }
LOCAL bVendF1 	:= { |x| If(SF1->(FieldPos("F1_VEND"+ Str(x,1)))>0,"SF1->F1_VEND"+ Str(x,1),"''") }
LOCAL bVendF2 	:= { |x| If(SF2->(FieldPos("F2_VEND"+ Str(x,1)))>0,"SF2->F2_VEND"+ Str(x,1),"''") }
LOCAL bPerComis:= { |x| "SE1->E1_COMIS" + Str(x,1) }
Local nQtdVend	:=	Fa440CntVen()
Local aRecSE1	:=	{}
Local nDupTot	:=	0
Local cVend		:=	""
Local lMultNat  := SuperGetMv("MV_MULNATR")
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local cQuery	:= ""
Local cAliasSE1 := ""
Local cE1Num    := ""
Local cFilE1    := xFilial("SE1")
Local aDuplMCur := {}	//(20/04/18): Array Value in main currency if was manually changes
Local aDuplTB   := {} //Tax bases array according to payment terms
Local TaxRate   := 0
Local nTotTBVl  := 0
Local nTotVATV  := 0
Local nVlBasI   := 0
Local nVlVatI   := 0
Local aVencPre   := {} //Tax bases array according to payment terms
Local aPreBase   := {} //Tax bases array according to payment terms
Local aPreBrutM  := {} //Tax bases array according to payment terms
//Local aDupl1 	:=	{}	//(20/04/18): Array Value in main currency if was manually changes
//Local lCpoPlaid := SE1->(ColumnPos("E1_SLPLAID")) > 0
Local cFunOrig   := ""
Local cFunName   := IIf(Type("cFunName")=="U", FunName(), cFunName)

Default aDuplAux     := {}

lLocxAuto 		 := Iif(Type("lLocxAuto") <> "U", lLocxAuto, .F. )

If lLocxAuto
	cFunOrig := cFunName
EndIf

If Type("lFina935") == "U"
	lFina935 := .F.
EndIf

DEFAULT cNatureza := ""
If !Empty(SuperGetMV("MV_1DUPREF"))
	cPref := &(SuperGetMV("MV_1DUPREF"))
Endif
cPref := If(Empty(cPref),CriaVar("SF2->F2_PREFIXO"),cPref)

//Ajsute para generar Financiero en emisión de Remito
If cPaisLoc == "EUA" .And. aCfgNf[8] == 'RFN'
	cPref := cSerie
	aCfgNf[ScEspecie] := 'PRE'
Else
	cPref := IIf(aCfgNf[SAliasHead]=="SF2",cPref,cSerie)
EndIf

If lUsaNewKey
	/*CHAVE UNICA - Alterado por Tiago Silva*/
	cE1Num:=Extrae(aDupl[1],2)
	cFilE1:=xFilial("SE1")
	cAliasSE1 := "ALOCXPRFX"
	cQuery := " SELECT MAX(E1_PREFIXO) E1PRFXMAX FROM " + RetSqlName("SE1")
	cQuery += " WHERE E1_FILIAL = '" + cFilE1 + "'"
	cQuery += " AND E1_NUM      = '" + cE1Num + "'"
	cQuery += " AND D_E_L_E_T_  = ''"
   	cQuery	  := ChangeQuery(cQuery)
	cAliasSE1 := CriaTrab(Nil,.F.)

	dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasSE1, .T., .T. )
	DbSelectArea(cAliasSE1)

	If !Empty( (cAliasSE1)->E1PRFXMAX )
		cPref:= Soma1( (cAliasSE1)->E1PRFXMAX , TamSX3("E1_PREFIXO")[1] )
		While .T.
			SE1->(dbSetOrder(1))
			If (SE1->(dbSeek(cFilE1+cPref+cE1Num)))
				cPref:= Soma1(cPref, TamSX3("E1_PREFIXO")[1])
			Else
				EXIT
			EndIf
		EndDo
	ElseIf Empty( (cAliasSE1)->E1PRFXMAX ) .AND. cPaisLoc == "PER" .AND. empty(substr(&(SuperGetMV("MV_1DUPREF")),1,TamSX3("E1_PREFIXO")[1]))
		cPref:= Soma1(" ")
	EndIf
	(cAliasSE1)->(DbCloseArea())
Endif

If Empty(cNatureza) .AND. !Empty(SuperGetMV("MV_1DUPNAT"))
	cNatureza := &(SuperGetMV("MV_1DUPNAT"))
	cNatureza := If(Empty(cNatureza),Criavar("SF2->F2_NATUREZ"),cNatureza)
	MaFisAlt("NF_NATUREZA",cNatureza)
	aFin[ScNatureza] := cNatureza
EndIf
cPref+=Space(Len(SE1->E1_PREFIXO) - Len(cPref))
//Determinar os vendedores quando se trata de uma devolucao
If aCfgNF[ScTipoDoc] == "D"
	For nY := 1	To Len(aRecnoI)
		SD1->(MsGoTo(aRecnoI[nY,1]))
		If !Empty(SD1->D1_NFORI) .AND. Len(aVend)<= nQtdVend
			For nX:= 1 to nQtdVend
				DbSelectArea ("SF2")
				DbSetOrder(1)
				MsSeek(xFilial("SF2")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA)
				//Para garantir que se nao se trata de uma nota de beneficiamento ou devolucao com a mesma numeracao
				While !Eof() .AND. xFilial("SF2")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA == ;
						F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA
					If !F2_TIPO $ 'DB'
						If !Empty(&("SF2->F2_VEND" + Str(nX,1)))
							If Ascan(aVend,{|x| x[1]==&("SF2->F2_VEND" + Str(nX,1))}) == 0
								dbSelectArea("SD2")
								dbSetOrder(3)
								MsSeek(xfilial("SD2")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD)
								While !Eof() .AND. xFilial("SD2")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD== ;
     									D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD
									//Para garantir que se trata do D2 relativo ao SF2
									If Alltrim(D2_ITEM)== Alltrim(SD1->D1_ITEMORI) .AND. D2_TIPO == SF2->F2_TIPO
										AAdd(aVend,{&("SF2->F2_VEND" + Str(nX,1)),&("SD2->D2_COMIS" + Str(nX,1))} )
										Exit
									Endif
									DbSkip()
								End
							EndIf
						Endif
						Exit
					Endif
					DbSelectArea('SF2')
					DbSkip()
				End
			Next
		Endif
	Next
	//³Pegar os vendedores que possam ter sido informados no cabecalho e ³
	If Len(aVend)<= nQtdVend
		For nX:=1 To nQtdVend
			cVend	:=	&(Eval(bVendF1,nX))
			If !Empty(cVend)
				DbSelectArea("SA3")
				DbSetOrder(1)
				If MsSeek(xFilial("SA3")+cVend)
					If Ascan(aVend,{|x| x[1] == cVend}) == 0
						Aadd(aVend,{SA3->A3_COD,SA3->A3_COMIS} )
					Endif
				Endif
			Endif
		Next
	EndIf
Else
	//³Pegar os vendedores informados no cabecalho  ³
	If Len(aVend)<= nQtdVend
		For nX:=1 To nQtdVend
			cVend	:=	&(Eval(bVendF2,nX))
			If !Empty(cVend)
				DbSelectArea("SA3")
				DbSetOrder(1)
				If MsSeek(xFilial("SA3")+cVend)
					If Ascan(aVend,{|x| x[1] == cVend}) == 0
						Aadd(aVend,{SA3->A3_COD,SA3->A3_COMIS} )
					Endif
				Endif
			Endif
		Next
	EndIf
Endif

if lLocxAuto .and. !Empty(cFunOrig)
	cFunName := cFunOrig
endif

If !(FunName() $ 'FINA074|FINA846' .Or.(cPaisLoc=="ARG" .And. IsInCallStack("FINA998") .AND. IsInCallStack("FINA074"))) .or.  (cPaisloc=="ARG" .And. lFina935    )
	SE4->(DbSeek(xFilial("SE4")+cCondicao))
	If cPaisLoc	== "RUS"
		TaxRate := RU09XFUN08(IIf(aCfgNf[SAliasHead]=="SF2",SF2->F2_VALIMP1,SF1->F1_VALIMP1)/*nTaxAmnt*/,;
										IIf(aCfgNf[SAliasHead]=="SF2",SF2->F2_BASIMP1,SF1->F1_BASIMP1)/*nTaxBase*/)  //LocxNF2.PRW
	EndIf
	For nX := 1 to Len(aDupl)
		If ValType(aDuplAux)=="A" .AND. Len(aDuplAux)>0 .AND. !Empty(aDuplAux[nx,5]) 
			nValDup := aDuplAux[nx,5]
		Else 
			nValDup := DesTrans(Extrae(aDupl[nx],5))
		EndIf 
		dbSelectArea("SE1")
		RecLock("SE1",.T.)
		Replace	E1_FILIAL  	With xFilial()
		Replace E1_PREFIXO 	With cPref
		Replace E1_EMISSAO 	With Iif(cPaisLoc <> "RUS",IIf(aCfgNf[SAliasHead]=="SF2", SF2->F2_EMISSAO, SF1->F1_EMISSAO), dDEmissao)
		Replace E1_EMIS1   	With dDataBase
		Replace	E1_CLIENTE 	With SA1->A1_COD
		Replace	E1_LOJA    	With SA1->A1_LOJA
		Replace	E1_NOMCLI  	With SA1->A1_NREDUZ
		Replace	E1_TIPO    	With aCfgNf[ScEspecie]
		Replace E1_MOEDA   	With aFin[SnMoedaFin]
		If cPaisloc == "RUS" .And. SF2->F2_MOEDA <> 1 .And. Len(aVencPre) >= 1 .and. nX <=len(aVencPre)
			Replace E1_TXMOEDA	With aVencPre[nX][3]
		Else
			Replace E1_TXMOEDA	With nTaxa
		EndIf
		Replace E1_LA   With "S"
		Replace E1_NUM     	With  IIf(Extrae(aDupl[nx],2)<> cNFiscal,cNFiscal,Extrae(aDupl[nx],2))
		SerieNfId("SE1",1,"E1_SERIE",,,,IIf(aCfgNF[SAliasHead] == "SF1",SF1->F1_SERIE,SF2->F2_SERIE)) // Projeto chave unica - Tiago Silva
		Replace	E1_PARCELA 	With AllTrim(Extrae(aDupl[nx],3))
		Replace	E1_VENCORI 	With Ctod(Extrae(aDupl[nx],4))
		Replace	E1_VENCTO  	With Iif(cPaisLoc <> "RUS",Ctod(Extrae(aDupl[nx],4)),aDuplMCur[nX][1])
		Replace	E1_VENCREA 	With DataValida(Iif(cPaisLoc <> "RUS",Ctod(Extrae(aDupl[nx],4)), aDuplMCur[nX][1]),.T.)
		Replace	E1_VALOR   	With nValDup
		Replace	E1_SALDO   	With nValDup
		Replace	E1_NATUREZ 	With aFin[ScNatureza]
		Replace E1_SITUACA 	With "0"
		Replace E1_STATUS	With "A"
		Replace E1_DESCFIN  With SE4->E4_DESCFIN
		Replace E1_DIADESC  With SE4->E4_DIADESC
		If cPaisLoc == "COL"
			Replace E1_TRMPAC   With If(aCfgNF[SAliasHead] == "SF1",CVALTOCHAR(SF1->F1_TRMPAC),CVALTOCHAR(SF2->F2_TRMPAC))
		EndIf
		If cPaisLoc == "CHI"
			Replace  E1_CGC	With SA1->A1_CGC
		EndIf
		If cPaisLoc == "RUS"
			E1_CONUNI  := Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_CONUNI,SF2->F2_CONUNI)
		    E1_MOEDA   := Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_MOEDA,SF2->F2_MOEDA)
			E1_ALQIMP1 := TaxRate
			E1_F5QCODE := Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_CNTID,SF2->F2_CNTID)
			E1_F5QUID := Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_F5QUID,SF2->F2_F5QUID)
			nDupTot	+=	SE1->E1_VALOR
			//saves the title x renco in advance
			If ColumnPos("E1_TXMOEDA") > 0 .And. SF2->F2_MOEDA > 1  .And. Len(aVencPre) >= 1 .And. nX <= Len(aVencPre)
				aadd( aRelAdv, {SE1->(Recno()), aVencPre[nX][5] , SE1->E1_VALOR } )
			EndIf
		EndIf
		If nX == Len(aDupl)
			If cPaisLoc	== "RUS"
				nVlCruz := Round((Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_VLBRUTM,SF2->F2_VLBRUTM) - nTotCruz),MsDecimais(1))
				nVlBasI := Round((Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_BASIMP1,SF2->F2_BASIMP1) - nTotTBVl),MsDecimais(1))
				nVlVatI := Round((nDupTot         - nTotTBVl - nVlBasI - nTotVATV),MsDecimais(1))
			Else
				nVlCruz := Round( Abs(xMoeda(MaFisRet(,'NF_BASEDUP'),nMoedaNF,1,dDataBase,MsDecimais(1)+1,nTaxa)) - Abs(nTotCruz), MsDecimais(1) )
			EndIf
		Else
			If cPaisLoc	== "RUS"
				nVlCruz := aDuplMCur[nx][2]
				nVlBasI := aDuplTB[nx][2]
				nVlVatI := nValDup	 - nVlBasI
			ElseIf cPaisLoc == "ARG"
				nVlCruz := ArgVlCruz("SE1", nMoedaNF, nTaxa)
			Else
				If nMoedaNF == 1 .Or. (nMoedaNF > 1 .and. nMoedaNF <> SE1->E1_MOEDA)
					nVlCruz := Round(xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,MsDecimais(1)+1,0),MsDecimais(1))
				Else 
					nVlCruz := Round(xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,MsDecimais(1)+1,nTaxa),MsDecimais(1))
				EndIf
			EndIf
		Endif
		If cPaisLoc == "EUA"
			GrvSE1EUA(cFunName)
		EndIf
		nTotCruz += nVlCruz
		If cPaisLoc == "RUS"
			nTotTBVl += nVlBasI
			nTotVATV += nVlVatI
		EndIf
		dbSelectArea("SE1")
		SE1->E1_VLCRUZ := nVlCruz
		If cPaisLoc == "RUS"
			SE1->E1_BASIMP1 := nVlBasI
			SE1->E1_VALIMP1 := nVlVatI
		EndIf
		dbSelectArea("SE1")
		If Len(aVend) >0
			For j:=1 To Len(aVend)
				Replace &(EVAL(bVend,j))      With aVend[j][1]
				Replace &(EVAL(bPerComis,j))  With aVend[j][2]
			Next j
		Endif
		If lMultNat
			If GRAVASEV("SE1",nValDup)
				SE1->E1_MULTNAT := "1"
			EndIf
		EndIf
		If lFina935
			cFunName:="MATA465N"
		EndIf
		MsUnLock()
		If SE1->E1_TIPO $ MV_CRNEG      // Resta
			dbSelectArea( "SA1" )
			AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,,SE1->E1_EMISSAO)
		EndIf
		a040DupRec(cFunName,(nX==1))
		If cPaisLoc <> "RUS"
			nDupTot	+=	SE1->E1_VALOR
		EndIf
		AAdd(aRecSE1,SE1->(Recno()))
	Next nx
	nDupTot	:=	xMoeda(nDupTot,aFin[SnMoedaFin],nMoedaNF,dDataBase,,,nTaxa)
EndIf
Return {aRecSE1,{nDupTot,cPref,SE1->E1_NUM}}

/*
±±ºPrograma  ³BaixAutSE1º±±
±±ºDesc.     ³Baixa dos titulos com pagamento a vista                     º±±
±±³Parametros³ cCond     = Condicao de pagamento                          ³±±
±±³          ³ aRecno    = Array com os numeros dos registros gravados no ³±±
±±³          ³             SE1                                            ³±±
±±³          ³ aCaixaFin = Array com o codigo do banco para a baixa       ³±±
±±³          ³             [1] = codigo do banco                          ³±±
±±³          ³             [2] = codigo da agencia                        ³±±
±±³          ³             [3] = codigo da conta                          ³±±
*/
Function BaixAutSE1(cCond,aRecno,aCaixaFin,cAlias,lVdaAst)
Local aArea	 :=	{}
Local nRecSE4:= 0
Local nRecSE :=	0
Local aBaixa :=	{}
Local cHist	 :=	""
Local cMotBx :=	""
Local cFunOrig := IIf(Type("cFunName")=="C",cFunName,Upper(FunName()))  //Funcao Origem
Local nRec	 :=	0
Local dVcto  := dDataBase
Local lNegociada  := ((nModulo == 12 .OR. nModulo == 23 .OR. nModulo == 5 .OR. nModulo == 72) .AND. AllTrim(cCond) == "CN")
Local lCaixinha	:= .F.
Local cMvLjbxPag := GetMV("MV_LJBXPAG",,"")

Default cAlias:="SE1"
Default lVdaAst  := .F.

nRecSE4:=SE4->(Recno())
If !lNegociada
	SE4->(DbSeek(xFilial("SE4")+cCond))
EndIf

If cAlias == "SE2" .And. cPaisLoc == "CHI"
	If Type("cCxCaixa")!="U" .And. Type("nCxValor")!="U" .And. !Empty(cCxCaixa) .And. !Empty(nCxValor)
		lCaixinha := .T.
	Endif
Endif
If lNegociada .OR. SE4->E4_BXTITAV == "1" .OR. lCaixinha
	aArea:=GetArea()
	cMotBx := If(lCaixinha,"DAC","NOR")
	cHist := If(lCaixinha,STR0130,STR0208)
    DbSelectArea(cAlias)
    nRecSE:=Recno()
	For nRec:=1 To Len(aRecno)
		MsGoto(aRecno[nRec])
		If IIf(lNegociada, !AllTrim(SE1->E1_TIPO) $ cMvLjbxPag,.F.)
		   Loop
		EndIf
		If cAlias=="SE1"
			dVcto:=SE1->E1_VENCORI
		Else
			dVcto:=SE2->E2_VENCORI
		Endif
		If (dVcto<=dDataBase) .Or. lCaixinha
			aBaixa:={}
			If cAlias=="SE1"
				AADD(aBaixa,{"E1_PREFIXO" 	,E1_PREFIXO			, Nil})	// 01
				AADD(aBaixa,{"E1_NUM"     	,E1_NUM				, Nil})	// 02
				AADD(aBaixa,{"E1_PARCELA" 	,E1_PARCELA			, Nil})	// 03
				AADD(aBaixa,{"E1_TIPO"    	,E1_TIPO			, Nil})	// 04
				AADD(aBaixa,{"E1_MOEDA"    	,E1_MOEDA			, Nil})	// 05
				AADD(aBaixa,{"E1_TXMOEDA"	,E1_TXMOEDA			, Nil})	// 06
				AADD(aBaixa,{"E1_ORIGEM"	,cFunOrig			, Nil})	// 07
				AADD(aBaixa,{"AUTVALREC"	,0         			, Nil})	// 06
				AADD(aBaixa,{"AUTMOTBX"  	,cMotBx				, Nil})	// 07
				AADD(aBaixa,{"AUTDTBAIXA"	,dDataBase			, Nil})	// 08
				AADD(aBaixa,{"AUTDTCREDITO"	,dDataBase			, Nil})	// 09
				AADD(aBaixa,{"AUTHIST"   	,cHist				, Nil})	// 10
				AADD(aBaixa,{"AUTBANCO"  	,aCaixaFin[1]		, Nil})	// 11
				AADD(aBaixa,{"AUTAGENCIA"  	,aCaixaFin[2]		, Nil})	// 12
				AADD(aBaixa,{"AUTCONTA"  	,aCaixaFin[3]		, Nil})	// 13
				MSExecAuto({|x,y| FINA070(x,y)},aBaixa,3)
			Else
				AADD( aBaixa, { "E2_PREFIXO" 	, E2_PREFIXO	, Nil } )	// 01
				AADD( aBaixa, { "E2_NUM"     	, E2_NUM		, Nil } )	// 02
				AADD( aBaixa, { "E2_PARCELA" 	, E2_PARCELA	, Nil } )	// 03
				AADD( aBaixa, { "E2_TIPO"    	, E2_TIPO		, Nil } )	// 04
				AADD( aBaixa, { "E2_FORNECE"	, E2_FORNECE	, Nil } )	// 05
				AADD( aBaixa, { "E2_LOJA"    	, E2_LOJA		, Nil } )	// 06
				AADD( aBaixa, { "E2_MOEDA"    	, E2_MOEDA		, Nil }	)	// 05
				AADD( aBaixa, { "E2_TXMOEDA"	, E2_TXMOEDA	, Nil } )	// 06
				AADD( aBaixa, { "E2_ORIGEM"		, cFunOrig		, Nil } )	// 07
				AADD( aBaixa, { "AUTMOTBX"  	, cMotBx		, Nil } )	// 08
				If lCaixinha
					AADD( aBaixa, { "AUTBANCO"  	, "   "	, Nil } )	// 09
					AADD( aBaixa, { "AUTAGENCIA"  	, "   "	, Nil } )	// 10
					AADD( aBaixa, { "AUTCONTA"  	, "   "	, Nil } )	// 11
				Else
					AADD( aBaixa, { "AUTBANCO"  	, aCaixaFin[1]	, Nil } )	// 09
					AADD( aBaixa, { "AUTAGENCIA"  	, aCaixaFin[2]	, Nil } )	// 10
					AADD( aBaixa, { "AUTCONTA"  	, aCaixaFin[3]	, Nil } )	// 11
				Endif
				AADD( aBaixa, { "AUTDTBAIXA"	, dDataBase		, Nil } )	// 12
				AADD( aBaixa, { "AUTHIST"   	, cHist			, Nil } )	// 13
				AADD( aBaixa, { "AUTDESCONT" 	, 0				, Nil } )	// 14
				AADD( aBaixa, { "AUTMULTA"	 	, 0				, Nil } )	// 15
				AADD( aBaixa, { "AUTJUROS" 		, 0				, Nil } )	// 16
				AADD( aBaixa, { "AUTOUTGAS" 	, 0				, Nil } )	// 17
				AADD( aBaixa, { "AUTVLRPG"  	, 0        		, Nil } )	// 18
				AADD( aBaixa, { "AUTVLRME"  	, 0				, Nil } )	// 19
				MSExecAuto({|x,y| Fina080(x,y)},aBaixa,3)
			Endif
		Endif
	Next
	MsGoto(nRecSE)
	RestArea(aArea)
Endif
SE4->(MsGoto(nrecSE4))
Return

/*
±±ºPrograma  ³CaBxAutSE1º±±
±±ºDesc.     ³Cancela a baixa dos titulos com pagamento a vista  para a   º±±
±±º          ³exclusao da NF.      			                              º±±
*/
Function CaBxAutSE1(cAlias,cCond,cAliasC)
Local aArea	:= {}
Local aSE1	:= {}
Local aTempSE := {}
Local aBaixa:= {}
Local lOk := .F.
Local cChSE:= ""
Local lNegociada  := Iif(ValType(cCond)#"U",((nModulo == 12 .OR. nModulo == 72 ) .AND. AllTrim(cCond) == "CN"),.F.)
Local lCaixinha	:= .F.

Default cAlias:="SE1"
Default cAliasC:=If(cAlias=="SE1","SF2","SF1")

If cAlias == "SE2" .And. cPaisLoc == "CHI"
	If Type("cCxCaixa")!="U" .And. Type("nCxValor")!="U" .And. !Empty(cCxCaixa) .And. !Empty(nCxValor)
		lCaixinha := .T.
	Endif
Endif

If IIf(lNegociada,.T.,SE4->E4_BXTITAV=="1") .Or. lCaixinha
	aArea:=GetArea()
	If cAlias=="SE1"
		DbSelectArea("SE1")
		aSE1:=GetArea()
		DbSetorder(2)
		If cAliasC=="SF2"
			cChSE:=xFilial("SE1")+SF2->F2_CLIENTE+SF2->F2_LOJA+SF2->F2_PREFIXO+SF2->F2_DUPL
		Else
			cChSE:=xFilial("SE1")+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_PREFIXO+SF1->F1_DUPL
		Endif
	Else
		DbSelectArea("SE2")
		aSE1:=GetArea()
		DbSetorder(6)
		If cAliasC=="SF2"
			cChSE:=xFilial("SE2")+SF2->F2_CLIENTE+SF2->F2_LOJA+SF2->F2_PREFIXO+SF2->F2_DUPL
		Else
			cChSE:=xFilial("SE2")+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_PREFIXO+SF1->F1_DUPL
		Endif
	Endif
	If DbSeek(cChSE)
		While If(cAlias=="SE1",(E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM),;
				(E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM))==cChSE
			If cAlias=="SE1"
				lOK:=E1_VENCORI==E1_EMISSAO .AND. !Empty(E1_BAIXA) .AND. !IsMoney(E1_TIPO)
			Else
				lOK:=(E2_VENCORI==E2_EMISSAO .OR. lCaixinha) .AND. !Empty(E2_BAIXA) .AND. !IsMoney(E2_TIPO)
			Endif
			If lOk
				aBaixa:={}
				aTempSE := (cAlias)->(GetArea())
				If cAlias=="SE1"
					AADD(aBaixa,{"E1_PREFIXO" 	,E1_PREFIXO			, Nil})	// 01
					AADD(aBaixa,{"E1_NUM"     	,E1_NUM				, Nil})	// 02
					AADD(aBaixa,{"E1_PARCELA" 	,E1_PARCELA			, Nil})	// 03
					AADD(aBaixa,{"E1_TIPO"    	,E1_TIPO			, Nil})	// 04
					AADD(aBaixa,{"E1_MOEDA"    	,E1_MOEDA			, Nil})	// 05
					AADD(aBaixa,{"E1_TXMOEDA"	,E1_TXMOEDA			, Nil})	// 06
					AADD(aBaixa,{"E1_CLIENTE"	,E1_CLIENTE			, Nil})	// 06
					AADD(aBaixa,{"E1_LOJA"		,E1_LOJA			, Nil})	// 06
					If SE4->E4_BXTITAV=="2"
					   MSExecAuto({|x,y| FINA070(x,y)},aBaixa,5)
					Else
					  MSExecAuto({|x,y| FINA070(x,y)},aBaixa,6)
					Endif
				Else
					AADD(aBaixa,{"E2_PREFIXO" 	,E2_PREFIXO			, Nil})	// 01
					AADD(aBaixa,{"E2_NUM"     	,E2_NUM				, Nil})	// 02
					AADD(aBaixa,{"E2_PARCELA" 	,E2_PARCELA			, Nil})	// 03
					AADD(aBaixa,{"E2_TIPO"    	,E2_TIPO			, Nil})	// 04
					AADD(aBaixa,{"E2_FORNECE"	,E2_FORNECE			, Nil})	// 05
					AADD(aBaixa,{"E2_LOJA"    	,E2_LOJA			, Nil})	// 06
					AADD(aBaixa,{"E2_MOEDA"    	,E2_MOEDA			, Nil})	// 07
					AADD(aBaixa,{"E2_TXMOEDA"	,E2_TXMOEDA			, Nil})	// 08
					MSExecAuto({|x,y| FINA080(x,y)},aBaixa,5)
				Endif
			Endif
			(cAlias)->(DbSkip())
		End
	Endif
	RestArea(aSE1)
	RestArea(aArea)
Endif
Return

/*
±±ºPrograma  ³GERATITIMPº±±
±±ºDesc.     ³Gera titulos de recolhimento de impostos                    º±±
*/
Static Function GeraTitImp(cArq,aRet)
Local aImp:={}
Local nY:=0,nG:=0,nValTit:=0
Local cPref	    :="",cImp:="",cTipoTit:="",cHist:=""
Local cParcela  :="",lOk
Local aArea	    :=GetArea()
Local aSA2	    :={},aSE2:={}
Local dVencto   := CTOD("  /  /  ")
Local clCliFor  := ""
Local clLoja    := ""
Local aDadosPai := {}
Local lTpDig := .F.
Local lFnTpDig := cPaisLoc == "PER" .and. FindFunction("LxPerTpDIG")
//Local nRecSE2	:= 0
//Local nX := 0

If cArq=="SF1"
	cHist:=SF1->F1_FORNECE+F1_LOJA
ElseIf cArq="SF2"
	cHist:=SF2->F2_CLIENTE+SF2->F2_LOJA
Endif
cTipoTit:=If(cPaisLoc=="ARG","RG ","TX ")
If cPaisLoc=="PER" .OR. cPaisLoc == "URU"
	If cArq=="SF1" .And. Subs(SF1->F1_ESPECIE,1,2)=="NC"
		cTipoTit:="TXA"
	ElseIf cArq="SF2" .And. Subs(SF2->F2_ESPECIE,1,2)=="NC"
		cTipoTit:="TXA"
	Endif
EndIf
If !Empty(GetMV("MV_2DUPREF"))
	cPref:=&(GetMV("MV_2DUPREF"))
Endif
cPref:=If(Empty(cPref),cSerie,cPref)
cPref:=IIf(aCfgNf[SAliasHead]=="SF1",cPref,cSerie)
aImp:=MaFisRet(,"NF_IMPOSTOS")
aImp:=ASort(aImp,,,{|x,y| x[1]<y[1]})
DbSelectArea("SA2")
aSA2:=GetArea()
dbSelectArea("SE2")
aSE2:=GetArea()
dbSetOrder(1)
nG:=Len(aImp)

IF cPaisLoc == "PER"
    // Recupera dos dados da primeira parcela gerada pela nota
    SE2->(SE2->(MsGoto(aRet[1][1])))
    AAdd(aDadosPai,{SE2->E2_FILIAL,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_EMISSAO,SE2->E2_VENCORI})
ENDIF

cParcela:=SuperGetMV("MV_1DUP",,"1")
For nY:=1 To nG
	nValTit:=0
	cImp:=aImp[nY][1]
	DbSelectArea("SFB")
	If DbSeek(xFilial("SFB")+cImp)
		If Iif(cPaisLoc $ "COS|PER|URU" ,SFB->FB_GERTIT$"1",.F.)
			While nY<=nG .AND. aImp[nY][1] == cImp
				nValTit+=aImp[nY][5]
				nY++
			End
			nY--
			If !Empty(FB_FORNECE) .and. !Empty(SFB->FB_LOJA)
				clCliFor := SFB->FB_FORNECE
				clLoja   := SFB->FB_LOJA
			Else
				clCliFor := SA2->A2_COD
				clLoja   := SA2->A2_LOJA
			EndIf
		EndIf
	EndIf
	DbSelectArea("SE2")
	If nValTit<>0
		lOk:=.F.
		While !lOk
			If !(lOk:=!(DbSeek(xFilial("SE2")+cPref+cNFiscal+cParcela+cTipoTit+clCliFor+clLoja)))
				cParcela:=Soma1(cParcela)
			EndIf
		End
		SA2->(dbSeek(xFilial("SA2")+clCliFor+clLoja))

		dVencto := LocVencImp(SFB->FB_DIAVENC,SFB->FB_PERIODO,aDadosPai)
		lTpDig := .F.
		If lFnTpDig .and. cTipoTit == "TX "   // verifica si el impuesto es una detracción Perú
			lTpDig := LxPerTpDIG(aImp[nY][1])
		EndIF

		RecLock("SE2",.T.)
		SE2->E2_FILORIG := cFilAnt
		Replace	E2_FILIAL  With xFilial("SE2")
		Replace E2_PREFIXO With cPref
		Replace E2_EMISSAO With dDEmissao
		Replace E2_EMIS1   With dDataBase
		Replace E2_HIST    With cHist+"/"+aImp[nY][1]
		Replace	E2_FORNECE With SA2->A2_COD
		Replace	E2_LOJA    With SA2->A2_LOJA
		Replace	E2_NOMFOR  With SA2->A2_NREDUZ
		Replace E2_TIPO    With cTipoTit
		Replace	E2_MOEDA   With nMoedaCor
		Replace E2_TXMOEDA With nTaxa
		Replace	E2_LA      With "S"
		Replace E2_NUM     With cNFiscal
		Replace	E2_PARCELA With cParcela
		Replace E2_VENCORI With dVencto
		Replace E2_VENCTO  With dVencto
		Replace E2_VENCREA With DataValida(dVencto)
		Replace	E2_VALOR   With nValTit
		Replace	E2_SALDO   With nValTit
		If cPaisLoc=="PER" .AND. (aImp[nY][1]== "DIG" .OR. lTpDig)   // Para esse imposto não pode existir casas decimais na moeda 1
			Replace E2_VLCRUZ  With Round(xMoeda(nValTit,nMoedaCor,1,dDataBase,,nTaxa),0)
        Else
			Replace E2_VLCRUZ  With xMoeda(nValTit,nMoedaCor,1,dDataBase,,nTaxa)
		EndIf
		If !Empty(SFB->FB_NATUREZ)
			Replace E2_NATUREZ With SFB->FB_NATUREZ
		Else
			Replace E2_NATUREZ With cNatureza
		Endif
		Replace	E2_ORIGEM  With cFunName
		If cPaisLoc == "CHI"
			Replace  E2_CGC	With SA2->A2_CGC
		EndIf
		if cPaisLoc == "COL"
			Replace E2_TRMPAC With If(cArq == "SF1",CVALTOCHAR(SF1->F1_TRMPAC),CVALTOCHAR(SF2->F2_TRMPAC))
		endif
		IF cPaisLoc == "PER"
		 	Replace E2_TITPAI With aDadosPai[1][2]+aDadosPai[1][3]+aDadosPai[1][4]+aDadosPai[1][5]+aDadosPai[1][6]+aDadosPai[1][7]
		Endif
		MsUnLock()

		If cPaisLoc == "PER"
			xUpdImpPer(SE2->(Recno()), aRet, Alltrim(SFB->FB_CPOLVRO), cParcela)
		Endif
		cParcimp:=Soma1(cParcela)

	Endif
Next
RestArea(aSA2)
RestArea(aSE2)
RestArea(aArea)
Return

/*
±±ºPrograma  ³APAGTITIMPº±±
±±ºDesc.     ³Gera titulos de recolhimento de impostos                    º±±
*/
Static Function ApagTitImp(cArq)
//Local nY:=0,nG:=0,nValTit:=0
Local cPref:="",cTipoTit:="",cHist:=""//cImp:="",
Local cFilSE2:=xFilial("SE2")//cParcela:="",
Local aArea:=GetArea()
Local aSE2:={}
Local cEspecie := "", cFornece := "", cLoja := ""

If cArq=="SF1"
	cHist:=SF1->F1_FORNECE+F1_LOJA
	cEspecie := SF1->F1_ESPECIE
	cFornece := SF1->F1_FORNECE
	cLoja    := SF1->F1_LOJA
ElseIf cArq="SF2"
	cHist:=SF2->F2_CLIENTE+SF2->F2_LOJA
	cEspecie := SF2->F2_ESPECIE
	cFornece := SF2->F2_CLIENTE
	cLoja    := SF2->F2_LOJA
Endif
cTipoTit:=If(cPaisLoc=="ARG","RG","TX")
If cPaisLoc=="PER" .OR. cPaisLoc == "URU"
	If cArq=="SF1" .And. Subs(SF1->F1_ESPECIE,1,2)=="NC"
			cTipoTit:="TXA"
	ElseIf cArq="SF2" .And. Subs(SF2->F2_ESPECIE,1,2)=="NC"
			cTipoTit:="TXA"
	Endif
EndIf
If !Empty(GetMV("MV_2DUPREF"))
	cPref:=&(GetMV("MV_2DUPREF"))
Endif
cPref:=If(Empty(cPref),Criavar("SF1->F1_PREFIXO"),cPref)
cPref:=IIf(aCfgNf[SAliasHead]=="SF1",cPref,cSerie)
dbSelectArea("SE2")
aSE2:=GetArea()
DbSetOrder(6) // Filial + Fornece + Loja + Prefixo + num
If DbSeek(cFilSE2+cFornece+cLoja+cPref+cNFiscal)
	While cFilSE2+cFornece+cLoja+cPref+cNFiscal == (E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM) .AND. !Eof() // fabio
		If cHist==Left(E2_HIST,Len(cHist))
			If Alltrim(E2_TIPO)==cTipoTit .AND. Empty(E2_BAIXA)
				RecLock("SE2",.F.)
				DbDelete()
				MsUnLock()
			Endif
		Else
			If Alltrim(cEspecie) == Alltrim(E2_TIPO)  .and. Alltrim(cHist) == Alltrim(E2_FORNECE) + Alltrim(E2_LOJA)
				RecLock("SE2",.F.)
					DbDelete()
				MsUnLock()
			Endif
		Endif
		DbSkip()
	EndDo
Endif
RestArea(aSE2)
RestArea(aArea)
Return

/*
±±ºPrograma  ³aNumNaoExisteº±±
±±ºDesc.     ³Verifica se a numeracao do documento ja esta sendo usada    º±±
*/
Function aNumNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cEspecie,cOrigem, nLenSerNF)
Local cAliasC2	 :=	""
Local cAliasTmp  :=	cAliasC
Local lRet		 :=.T.
Local lReutiliza := GetMv("MV_USAMNUM",,.T.)  //Determina se permite reutilizar o numero da NF
Local lFormProp  := .T.
Local lDocExiste := .T.
Local cSerieNf   := ""
Local cTipContNF := Iif (ValType(lFiscal)== "L" .AND. lFiscal ,GetMV("MV_CONTNFI",,"I"),GetMV("MV_CONTNF"))
Local cFiltroSF1 := SF1->(dbFilter())
Local cFiltroSF2 := SF2->(dbFilter())
Local cFilSF1    := xFilial("SF1")
Local cFilSF2    := xFilial("SF2")
Local cFilSF3    := xFilial("SF3")
Local lUsaNewKey := TamSX3("F1_SERIE")[1] == 14
Local nLenSerie  := TamSX3("F1_SERIE")[1]
Local aArea      := {}
Local lVerif	 :=.T.
Local lOrigem    := .F.

//³Limpa o conteudo do filtro das tabelas SF1/SF2 para evitar  ³
//|incompatibilidade com o parametro MV_FLTD1D2.			   |

SF1->(dbClearFilter())
SF2->(dbClearFilter())

If lUsaNewKey
	cSerie:= SerieNfId(cAliasTMP,4,PrefixoCpo(cAliasTMP)+"_SERIE",M->&(PrefixoCpo(cAliasTMP)+"_EMISSAO"),cEspecie,cSerie)
Endif

If Type("lLocxAuto") <> "U" .AND. lLocxAuto
	Return .T.
EndIf
cOrigem := IIf(cOrigem == NIL,"GEN",cOrigem)
nLenSerNF := IIf(nLenSerNF == NIL, nLenSerie, nLenSerNF)

lOrigem:= IIf(cOrigem == "GEN",aCfgNF[SlFormProp],.T.)
If Upper(Alltrim(cOrigem)) == "LOJ"
	lRet := aNumNaoLj(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cEspecie,cOrigem)
Else
	If cAliasC == "SF2"

		//³Verifica se a NF esta sendo digitada em outra estacao³

		cSerieNf :=	Padr(cSerie,Len(Criavar("F2_SERIE",.F.)))
		If lOrigem
			If cMayUse == NIL .OR. cMayUse!="SF2"+cFilSF2+cNFiscal+cSerieNf+'S'
				If cMayUse!=Nil
					UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				Endif
				cMayUse := cNFiscal+cSerieNf+'S'
			Endif
		Else
			If cMayUse!=NIL .OR. cMayUse!="SF2"+cFilSF2+cNFiscal+cSerieNf+cCliFor+cLoja
				If cMayUse!=NIL
					UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				Endif
				cMayUse := cNFiscal+cSerieNf+cTipo+cCliFor+cLoja
			EndIf
		Endif
		If (!Empty(cNFiscal) .AND. !(cEspecie $ "NDC|NDI") .AND. (FunName() != "MATA467N")) .Or. (cPaisLoc == "EQU" .And. !Empty(cNFiscal))
			If !LockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				lRet := .F.
			EndIf
		EndIf
		If lRet .AND. lOrigem .AND. cTipContNF == "M"
			If !Empty(cNFiscal) .AND. !LockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
				UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				lRet := .F.
			EndIf
		Endif
	Else

		//³Verifica se o controle de numeracao eh o mesmo   ³
		//³para todos os documentos ou se eh independente   ³

		cSerieNf := 	Padr(cSerie,Len(Criavar("F1_SERIE",.F.)))

		//³Verifica se a NF esta sendo digitada em outra estacao ³

		If lOrigem
			If cMayUse==NIL .OR. cMayUse!="SF1"+cFilSF1+cNFiscal+cSerieNf+'S'
				If cMayUse != NIL
					UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
				Endif
				cMayUse := cNFiscal+cSerieNf+'S'
			Endif
		Else
			If cMayUse==NIL .OR. cMayUse!="SF1"+cFilSF1+cNFiscal+cSerieNf+cCliFor+cLoja
				If cMayUse != NIL
					UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
				Endif
				cMayUse := cNFiscal+cSerieNf+cCliFor+cLoja
			EndIf
		Endif
		If !Empty(cNFiscal)	.AND. !LockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
			lRet := .F.
		EndIf
		If lRet .AND. lOrigem .AND. cTipContNF == "M"
			If !Empty(cNFiscal) .AND. !LockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
				lRet := .F.
			EndIf
		Endif

	EndIf
	If cPaisLoc == "ARG" .And. (AllTrim(cEspecie) == "RFN"  .OR. AllTrim(cEspecie) == "RTS" .OR. (FunName() $ "MATA467N|MATA466N" .And. !(AllTrim(cEspecie) $ "NDP|NCI") ))
		aArea := getArea()
		dbSelectArea("SF2")
		dbSetOrder(1) //F2_FILIAL+F2_DOC+F2_SERIE

		If !Empty(cSerie) .OR. !Empty(cnFiscal)
			If SF2->(DbSeek(xfilial("SF2") + cnFiscal + cSerie + IIf(AllTrim(cEspecie) == "NCP", cCliFor + cLoja, "")))
				Return .F.
			EndIf
		EndIf
		restArea(aArea)
	EndIf
	// Verifica se a NF existe nos arquivos
	If lRet.AND.GetMV('MV_FLTD1D2')
		If cAliasC == "SF1"
			cAliasC	:=	"__LOCXSF1"
		Else
			cAliasC	:=	"__LOCXSF2"
		Endif
		If Select(cAliasC) == 0
			If !ChkFile(cAliasTMP,.F.,cAliasC)
				cAliasC := cAliasTMP
			Endif
		Else
			dbSelectArea(cAliasC)
		Endif
	Endif

	cAliasC2	:=	Substr(cAliasTMP,1,2)+Iif(Substr(cAliasTMP,3,1)=='1','2','1')
	(cAliasC2)->(DbSetOrder(1))
	(cAliasC)->(DbSetOrder(1))
	If cPaisLoc $ "PAR|ARG|URU|CHI" .and. !lOrigem
		lVerif:=.F.
	EndIf
	If &(cAliasC+"->(MSSeek('"+xFilial(cAliasTMP)+cnFiscal+cSerie+IIF(lOrigem,"",cCliFor+cLoja)+"', .F.))")
		While lRet .AND. !(cAliasC)->(EOF()) .AND. &(cAliasC+'->("'+xFilial(cAliasTMP)+cnFiscal+cSerie+'")') ==;
			&(cAliasC+"->("+PrefixoCpo(cAliasTMP)+"_FILIAL+"+PrefixoCpo(cAliasTMP)+"_DOC+PadR(Substr("+PrefixoCpo(cAliasTMP)+"_SERIE,1,"+Str(nLenSerNF)+"),"+Str(nLenSerie)+"))")
			If lFormProp  := (&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_FORMUL") $ 'S ' .AND. lOrigem);
				.OR. lVerif .And. (!(&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_FORMUL") $ 'S ') .AND. !lOrigem)
				//Se o documento for Forumulario Proprio deve verificar o parametro MV_CONTNF
				If lFormProp
					If cTipContNF == "M"
						lDocExiste  := .T.
					ElseIf cTipContNF == "I"
						lDocExiste := AllTrim(&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_ESPECIE")) == AllTrim(cEspecie)
					EndIf
				EndIf
				If lDocExiste
					UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
					UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
					lRet := .F.
				EndIf
			Endif
			(cAliasC)->(DbSkip())
		End
		//³Verificar se o documento existe na outra tabela (SF1/SF2) quando é usado o ³
		//³mesmo numero de documento para todos os tipos de documento                 ³
	ElseIf (cTipContNF == "M" .AND.	&(cAliasC2+"->(MSSeek('"+xFilial(cAliasC2)+cnFiscal+cSerie+IIF(aCfgNF[SlFormProp],"",cCliFor+cLoja)+"', .F.))") )
		While lRet .AND. !(cAliasC2)->(EOF()) .AND. &(cAliasC2+'->("'+xFilial(cAliasC2)+cnFiscal+cSerie+'")') ==;
			&(cAliasC2+"->("+PrefixoCpo(cAliasC2)+"_FILIAL+"+PrefixoCpo(cAliasC2)+"_DOC+PadR(Substr("+PrefixoCpo(cAliasC2)+"_SERIE,1,"+Str(nLenSerNF)+"),"+Str(nLenSerie)+"))")
			If (&(cAliasC2+"->"+PrefixoCpo(cAliasC2)+"_FORMUL") $ 'S ' .AND. lOrigem);
				.OR. (lVerif .And. !(&(cAliasC2+"->"+PrefixoCpo(cAliasC2)+"_FORMUL") $ 'S ') .AND. !lOrigem)
				UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
				lRet := .F.
			Endif
			(cAliasC2)->(DbSkip())
		End
	Endif
	//³Validacoes de existencia da nota³
	(cAliasC)->(DbSetOrder(1))
	If lRet .AND. &(cAliasC+"->(MSSeek('"+xFilial(cAliasTmp)+cnFiscal+cSerie+cCliFor+cLoja+"', .F.))")
		If (&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_TIPO") $ 'C|N|D')
			UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
			UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
			lRet := .F.
		EndIf
	EndIf

	//³Validacoes de existencia da nota de Beneficiamento / NCC³
	If cPaisLoc == "ARG"
		lRet := ArgValDocT(lRet, cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cAliasTmp,cMayUse)
	EndIf
	//³Controla a a existencia da Nota no SF3³
	If lRet
		DbSelectArea( "SF3" )
		DbSetOrder( 5 )
		If DbSeek( cFilSF3+cSerie+cNFiscal,.F. )
			While !Eof() .AND. (cFilSF3+cSerie+cNFiscal) == (SF3->F3_FILIAL+SF3->F3_SERIE+SF3->F3_NFISCAL)
				//Devo controlar que a nota achada no SF3 seja de faturam., não esteja anulada,
				// e se a numeracao dos formularios e independente, que seja da mesma especie.
				If lOrigem
					If cTipContNF == "M"  .OR. (cTipContNF == "I" .AND. Alltrim(F3_ESPECIE)	==	Alltrim(cEspecie) )
						If (LocxFormP(SF3->F3_ESPECIE,SF3->F3_TIPOMOV,SF3->F3_TES,SF3->F3_FORMUL))
							If IIf(Empty(F3_DTCANC),.T.,!lReutiliza)
								lRet := .F.
							EndIf
						EndIf

					EndIf
				ElseIf  F3_TIPO ==	cTipo .AND. cCliFor+cLoja == F3_CLIEFOR+F3_LOJA .AND. Alltrim(F3_ESPECIE)	==	Alltrim(cEspecie) .AND. !(LocxFormP(SF3->F3_ESPECIE,SF3->F3_TIPOMOV,SF3->F3_TES,SF3->F3_FORMUL))
					If IIf(Empty(F3_DTCANC),.T.,!lReutiliza)
						lRet := .F.
					EndIf
				EndIf
				DbSkip()
			End
		EndIf
	Endif

	If lRet .and. Type("__aCodLocs") == "A"
		Aadd(__aCodLocs,"SF1"+xFilial("SF1")+cMayUse)
		Aadd(__aCodLocs,"SF2"+xFilial("SF2")+cMayUse)
	Endif
Endif
//³Restaura o conteudo do filtro das tabelas SF1/SF2  ³
If !Empty(cFiltroSF1)
	SF1->(dbSetFilter({||&cFiltroSF1},cFiltroSF1))
EndIF
If !Empty(cFiltroSF2)
	SF2->(dbSetFilter({||&cFiltroSF2},cFiltroSF2))
EndIf
Return (lRet)

/*
±±ºPrograma  ³aNumNaoLj    º±±
±±ºDesc.     ³Verifica se a numeracao do documento ja esta sendo usada    º±±
±±ºUso       ³ LOCXNF (SIGALOJA)                                          º±±
*/
Function aNumNaoLj(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cEspecie,cOrigem)
Local cAliasC2	 :=	""
Local cAliasTmp  :=	cAliasC
Local lRet		 :=.T.
Local lReutiliza := GetMv("MV_USAMNUM",,.T.)  //Determina se permite reutilizar o numero da NF
Local lFormProp  := .T.
Local lDocExiste := .T.
Local cSerieNf   :=""
Local cTipContNF := Iif (ValType(lFiscal)== "L" .AND. lFiscal ,GetMV("MV_CONTNFI",,"I"),GetMV("MV_CONTNF"))
Local cFilSF3		:= xFilial("SF3")
Local lOrigem:=.f.
If Type("lLocxAuto") <> "U" .AND. lLocxAuto
   Return .T.
EndIf
cOrigem := IIf(cOrigem == NIL,"GEN",cOrigem)
lOrigem:= IIf(cOrigem == "GEN",aCfgNF[SlFormProp],.T.)
If cAliasC == "SF2"

//³Verifica se a NF esta sendo digitada em outra estacao ³

   cSerieNf :=	Padr(cSerie,Len(Criavar("F2_SERIE",.F.)))
	If lOrigem
		If cMayUse == NIL .OR. cMayUse!=cNFiscal+cSerieNf+'S'
			FreeUsedCode()
			cMayUse := cNFiscal+cSerieNf+'S'
		Endif
	Else
		If cMayUse==NIL .OR. cMayUse!=cNFiscal+cSerieNf+cCliFor+cLoja
			FreeUsedCode()
			cMayUse := cNFiscal+cSerieNf+cTipo+cCliFor+cLoja
		EndIf
	Endif
	If !Empty(cNFiscal) .AND. !FreeForUse("SF2",cMayUse)
		lRet := .F.
	EndIf
	If lRet .AND. lOrigem .AND. cTipContNF == "M"
		If !Empty(cNFiscal) .AND. !FreeForUse("SF1",cMayUse)
			FreeUsedCode()
			lRet := .F.
		EndIf
	Endif
Else

	//³Verifica se o controle de numeracao eh o mesmo   ³
	//³para todos os documentos ou se eh independente   ³

    cSerieNf := 	Padr(cSerie,Len(Criavar("F1_SERIE",.F.)))

	//³Verifica se a NF esta sendo digitada em outra estacao³

	If lOrigem
		If cMayUse==NIL .OR. cMayUse!=cNFiscal+cSerieNf+'S'
			FreeUsedCode()
			cMayUse := cNFiscal+cSerieNf+'S'
		Endif
	Else
		If cMayUse==NIL .OR. cMayUse!=cNFiscal+cSerieNf+cCliFor+cLoja
			FreeUsedCode()
			cMayUse := cNFiscal+cSerieNf+cCliFor+cLoja
		EndIf
	Endif
	If !Empty(cNFiscal)	.AND. !FreeForUse("SF1",cMayUse)
		lRet := .F.
	EndIf
	If lRet .AND. lOrigem .AND. cTipContNF == "M"
		If !Empty(cNFiscal) .AND. !FreeForUse("SF2",cMayUse)
			FreeUsedCode()
			lRet := .F.
		EndIf
	Endif

EndIf

// Verifica se a NF existe nos arquivos
If lRet.AND.GetMV('MV_FLTD1D2')
	If cAliasC == "SF1"
		cAliasC	:=	"__LOCXSF1"
	Else
		cAliasC	:=	"__LOCXSF2"
	Endif
	If Select(cAliasC) == 0
		ChkFile(cAliasTMP,.F.,cAliasC)
	Else
		dbSelectArea(cAliasC)
	Endif
Endif

cAliasC2	:=	Substr(cAliasTMP,1,2)+Iif(Substr(cAliasTMP,3,1)=='1','2','1')
(cAliasC2)->(DbSetOrder(1))
(cAliasC)->(DbSetOrder(1))
If &(cAliasC+"->(MSSeek('"+xFilial(cAliasTMP)+cnFiscal+cSerie+IIF(lOrigem,"",cCliFor+cLoja)+"', .F.))")
	While lRet .AND. !(cAliasC)->(EOF()) .AND. &(cAliasC+'->("'+xFilial(cAliasTMP)+cnFiscal+cSerie+'")') ==;
		 &(cAliasC+"->("+PrefixoCpo(cAliasTMP)+"_FILIAL+"+PrefixoCpo(cAliasTMP)+"_DOC+"+PrefixoCpo(cAliasTMP)+"_SERIE)")
		If lFormProp  := (&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_FORMUL") $ 'S ' .AND. lOrigem);
			.OR.(!(&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_FORMUL") $ 'S ') .AND. !IIf(cOrigem == "GEN",aCfgNF[SlFormProp],.T.))
			//Se o documento for Forumulario Proprio deve verificar o parametro MV_CONTNF
			If lFormProp
			   If cTipContNF == "M"
			      lDocExiste  := .T.
			   ElseIf cTipContNF == "I"
			      lDocExiste := AllTrim(&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_ESPECIE")) == AllTrim(cEspecie)
			   EndIf
			EndIf
			If lDocExiste
			   FreeUsedCode()
			   lRet := .F.
			EndIf
		Endif
		(cAliasC)->(DbSkip())
	End

	//³Verificar se o documento existe na outra tabela (SF1/SF2) quando é usado o ³
	//³mesmo numero de documento para todos os tipos de documento                 ³

ElseIf (cTipContNF == "M" .AND.	&(cAliasC2+"->(MSSeek('"+xFilial(cAliasC2)+cnFiscal+cSerie+IIF(aCfgNF[SlFormProp],"",cCliFor+cLoja)+"', .F.))") )
	While lRet .AND. !(cAliasC2)->(EOF()) .AND. &(cAliasC2+'->("'+xFilial(cAliasC2)+cnFiscal+cSerie+'")') ==;
		 &(cAliasC2+"->("+PrefixoCpo(cAliasC2)+"_FILIAL+"+PrefixoCpo(cAliasC2)+"_DOC+"+PrefixoCpo(cAliasC2)+"_SERIE)")
	  	If (&(cAliasC2+"->"+PrefixoCpo(cAliasC2)+"_FORMUL") $ 'S ' .AND. lOrigem);
			.OR.(!(&(cAliasC2+"->"+PrefixoCpo(cAliasC2)+"_FORMUL") $ 'S ') .AND. !IIf(cOrigem == "GEN",aCfgNF[SlFormProp],.T.))
			FreeUsedCode()
			lRet := .F.
		Endif
		(cAliasC2)->(DbSkip())
	End
Endif

//³Validacoes de existencia da nota³

(cAliasC)->(DbSetOrder(1))
If lRet .AND. &(cAliasC+"->(MSSeek('"+xFilial(cAliasTmp)+cnFiscal+cSerie+cCliFor+cLoja+'N'+"', .F.))")
	FreeUsedCode()
	lRet := .F.
EndIf

//³Controla a a existencia da Nota no SF3³

If lRet
	DbSelectArea( "SF3" )
	DbSetOrder( 5 )
	If DbSeek( cFilSF3+cSerie+cNFiscal,.F. )
		While !Eof() .AND. (cFilSF3+cSerie+cNFiscal) == (SF3->F3_FILIAL+SF3->F3_SERIE+SF3->F3_NFISCAL)
			//Devo controlar que a nota achada no SF3 seja de faturam., não esteja anulada,
			// e se a numeracao dos formularios e independente, que seja da mesma especie.
			If lOrigem
				If cTipContNF == "M"  .OR. (cTipContNF == "I" .AND. Alltrim(F3_ESPECIE)	==	Alltrim(cEspecie) )
			   		If (LocxFormP(SF3->F3_ESPECIE,SF3->F3_TIPOMOV,SF3->F3_TES,SF3->F3_FORMUL))
			      		If IIf(Empty(F3_DTCANC),.T.,!lReutiliza)
				    		 lRet := .F.
				 		EndIf
				 	EndIf

			   	EndIf
			ElseIf  F3_TIPO ==	cTipo .AND. cCliFor+cLoja == F3_CLIEFOR+F3_LOJA .AND. Alltrim(F3_ESPECIE)	==	Alltrim(cEspecie) .AND. !(LocxFormP(SF3->F3_ESPECIE,SF3->F3_TIPOMOV,SF3->F3_TES,SF3->F3_FORMUL))
				If IIf(Empty(F3_DTCANC),.T.,!lReutiliza)
			    	lRet := .F.
			   	EndIf
          	EndIf
			DbSkip()
		End
	EndIf
Endif
Return (lRet)

/*/
±±ºPrograma  ³MontCabBrow º±±
±±ºDesc.     ³Cria array com os campos que devem ser exibidos no mBrowse  º±±
/*/
Function MontCabBrow(aCfg)
Local aCpos    := {}
Local aAreaSX3 := {}
Local aAreaAtu := GetArea()

dbSelectArea("SX3")
aAreaSX3 := GetArea()
dbSetOrder(1)
dbSeek(aCfg[SAliasHead])
While !Eof() .AND. (X3_ARQUIVO == aCfg[SAliasHead])
	If X3USO(X3_USADO) .AND. (X3_BROWSE == "S")
		If (aCfg[ScCliFor] == "SA2") .AND. (aCfg[SAliasHead] == "SF2") .AND.;
		   (Trim(X3_CAMPO) == "F2_CLIENTE")
			AADD(aCpos,{ STR0187, SX3->X3_CAMPO } )
		ElseIf (aCfg[ScCliFor] == "SA1") .AND. (aCfg[SAliasHead] == "SF1") .AND.;
		   (Trim(X3_CAMPO) == "F1_FORNECE")
			AADD(aCpos,{ STR0188, SX3->X3_CAMPO } )
		Else
			//Leandro Prado - 10/03/2014 - Mecanismo para mostrar PV (Argentina) somente se for formulário próprio.
			If SX3->X3_CONTEXT <>"V" .And. !((Trim(X3_CAMPO) $ "F1_PV|F2_PV|") .And. (!aCfg[SlFormProp]))
				AADD(aCpos,{ AllTrim(X3Titulo()), SX3->X3_CAMPO } )
			Endif
		EndIf
	EndIf
	dbSkip()
End
RestArea(aAreaSX3)
RestArea(aAreaAtu)
Return(aCpos)

/*
±±ºPrograma  ³LocxAnula º±±
±±ºDesc.     ³Permite anulacao das notas fiscais                          º±±
*/
Function LocxAnula(aCfgNF,__nOpcx,bFilBrw)
if (cPaisLoc == "RUS")
	If (( __nOpcX == 5 ) .Or. ( __nOpcX == 6 )) ;
		.And. ((SF2->F2_STATUSR == "2") .Or. (SF1->F1_STATUSR == "2"))
		Help("",1,"LocxAnula",,STR0383,1,0)	// "Delete VAT Invoice linked to this record first."
		Return .F.
	EndIf
EndIf
If cPaisLoc == "ARG" .and. FunName() == "MATA462N" .and. (!Empty(SF2->F2_COMCOT) .Or. !Empty(SF2->F2_AUTHCOT))
	HELP("",NIL,'Anular',,STR0409,1,0)	//O remito não pode ser anulado, pois ja foi transmitido
	Return .F.
EndiF
lAnulaSF3  := .T.
LocxDlgNF(aCfgNF,__nOpcx,bFilBrw)
lAnulaSF3  := .F.
Return
/*
±±ºProgram   ³ LocxShowNFImp º±±
±±ºDescrição ³ Mostra todas as facturas envolvidas no processo de importação  º±±
±±º          ³ e solicita ao Usuário a execução da geração dos Remitos.       º±±
±±º          ³ antiga A101ShowNfImp()                                         º±±
*/
Function LocxShowNFImp()
LOCAL aArea := GetArea()
//LOCAL lRet  := .T.
LOCAL aCab  := {}
LOCAL aPicture := {}
LOCAL aCampos  := {"FATURA","F1_DOC","F1_SERIE"}
LOCAL oLbx
LOCAL cProcesso := SF1->F1_HAWB
LOCAL cNFImp    := SF1->F1_DOC
LOCAL cSerieImp := SF1->F1_SERIE
LOCAL nOpc		:= 0
LOCAL nI		:= 0
LOCAL cFilSD1	:= xFilial("SD1")
If cPaisLoc == "CHI"

	aFaturas := {}

	DbSelectArea("SX3")
	DbSetOrder(2)
	For nI := 1 To Len(aCampos)
		If nI == 1
			AADD(aCab,"Tipo")
			AADD(aPicture,"@!")
		Else
			MsSeek(aCampos[nI])
			AADD(aCab,X3Titulo())
			AADD(aPicture,SX3->X3_PICTURE)
		EndIf
	Next nI
	DbSetOrder(1)

	DbSelectArea("SF1")
	DbSetOrder(5)
	If DbSeek(xFilial("SF1")+cProcesso)
		While !Eof() .AND. SF1->F1_HAWB == cProcesso
			SD1->(DbSetOrder(1))
			SD1->(DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
			If ! Empty(SD1->D1_TES)
				AADD(aFaturas,{TypeNFImp(SF1->F1_TIPO_NF),SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA})
			ElseIf SF1->F1_DOC == cNFImp .AND. SF1->F1_SERIE == cSerieImp
				AADD(aFaturas,{TypeNFImp(SF1->F1_TIPO_NF),SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA})
			EndIf
			DbSkip()
		End
	EndIf

	If Len(aFaturas) > 0

		DEFINE MSDIALOG oDlgShow TITLE Oemtoansi(STR0101);
		FROM 10,30 To 25,92 OF GetWndDefault()

		@ 8.9, 005 SAY OemToAnsi(STR0102) OF oDlgShow PIXEL
		@ 8.5, 035 GET cProcesso  OF oDlgShow PIXEL WHEN .F.

		oLbx := RDListBox(1.9, .5, 235 , 55.5, aFaturas, aCab,,aPicture,,  )  // {||DetDblclk("F")} ) se cancela por funcion DetDblclk no compilada

		@ 91, 085 SAY OemToAnsi(STR0103) OF oDlgShow PIXEL

		DEFINE SBUTTON oButton FROM 89.4 ,179 TYPE 1 ACTION (nOpc:=1,oDlgShow:End()) ENABLE OF oDlgShow
		DEFINE SBUTTON oButton FROM 89.4 ,212 TYPE 2 ACTION (nOpc:=2,oDlgShow:End()) ENABLE OF oDlgShow

		ACTIVATE MSDIALOG oDlgShow
	EndIf
EndIf
RestArea(aArea)
Return( If(nOpc==1,aFaturas,{}) )

/*
±±ºProgram   ³LocxAtuFis  º±±
±±ºDescrição ³ Faz a atuazalizacao do folder fiscal, quando for alterada a    º±±
±±º          ³ serie ou numero da NF.                               		  º±±
±±³Sintaxe   ³ LocxAtuFis(lAtuNumDoc,cNumDoc)                                 ³±±
±±³Parametros³lAtuNumDoc Indica se foi alterado o numero da nota, ou a serie  ³±±
±±³          ³cNumDoc Numero da Fatura						            	  ³±±
*/
Function LocxAtuFis(lAtuNumDoc,cNumDoc)
Local nPosDoc := 0
Local cDesDoc := ""
Local xLivro
Local nB	  := 0
Local nA	  := 0

If lAtuNumDoc
	xLivro := MaFisRet(,'NF_LIVRO')
	If Valtype(xLivro) == "A" .AND. Len(xLivro) > 0
		nPosDoc	:= aScan(xLivro[1],{|x|x=="F3_NFISCAL"})
		If nPosDoc != 0
			For nA := 2 To Len(xLivro)
				xLivro[nA][nPosDoc] := cNumDoc
			Next nA
			MaFisAlt("NF_LIVRO",xLivro)
		EndIf
	EndIf
EndIf
If ( Type("lLocxAuto") == "U" .OR. !lLocxAuto )
	If IsMemVar("oLstSF3")
		If Len(oLstSF3:AARRAY)>0
			cDesDoc  := Rtrim(RetTitle("F3_NFISCAL"))
			nPosDoc	:= aScan(oLstSF3:AHEADERS,{|x|RTrim(x)==cDesDoc})
			For nB := 1 to Len(oLstSF3:AARRAY)
				oLstSF3:AARRAY[nB,nPosDoc]:= cNumDoc
			Next nB
			oLstSF3:Refresh()
		EndIf
	EndIf
Endif
Return

/*
±±³Fun‡Æo    ³A100ValImp³±±
±±³Descri‡Æo ³ Validar a digita‡„o do valor do imposto.                   ³±±
*/
Function LocXValImp(cImpDigit,nImpCalc,cCodImp)
Local lRet	:=	.T.
Local nRnd	:=	MsDecimais(MaFisRet(,"NF_MOEDA"))
Local lModif :=	GetMv("MV_EDITIMP")
Local nDifer := 0, nDiferA := 0, nImpDigit
Local lVldValor:= .F.
Local aAreaAtu:={}
Local aAreaAtuSFB:={}
Local cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
Default cCodImp:=""

lVldValor:=  lModif .And. !Empty(cCodImp) .And. cPaisLoc $ cAuxPaisL

If Type("lIntegracao")!= "L"
	lIntegracao:=.F.
Endif
If Type("lFacImport")!= "L"
	lFacImport:=.F.
Endif

If lIntegracao .AND. lFacImport
	lRet:=.F.
Else
	nImpDigit	:= &cImpDigit

	aAreaAtu:=GetArea()
	aAreaAtuSFB:=SFB->(GetArea())
	SFB->(DbSetOrder(1))
	SFB->(Dbseek(xfilial("SFB")+Alltrim(cCodImp))  )
	nDiferA := !(ABS(nImpDigit - nImpCalc) <= (nImpCalc * (SFB->FB_PERCALT/100)) )
	If !(ABS(nImpDigit - nImpCalc) <= (nImpCalc * (SFB->FB_PERCALT/100)) ) .Or. !(ABS(nImpDigit - nImpCalc) <= SFB->FB_VLRALT)
		Aviso( STR0018,IIf(nDiferA, STR0267,STR0268),{STR0021})
		lRet  := .F.
	EndIf
	RestArea(aAreaAtu)
	SFB->(RestArea(aAreaAtuSFB))

Endif
Return( lRet )

Static Function BloqFatImp(lVerRes)
Local cSeek 	:= ""
Local nOrd  	:= 3
Local aArea 	:= GetArea()
Local aAreaSB2, aAreaSB8, aAreaSDA
Local aSB2		:=	{}
Local aSB8		:=	{}
Local aSDA		:=	{}
Local lRet  	:= .F.
Local lPedido   := .F.
Local cCondSB8  := ""
Local aRecnoSD1 :=	{}
Local nEmpenha	:=	0
Local nQtdEmp   :=	0
Local nEmpenha2 :=	0
Local nQtdEmp2	:=	0
Local nTotQtd2	:=	0
Local lB8_ITEM	:= .F.
Local cFilSB1		:= xFilial("SB1")
Local cFilSB2		:= xFilial("SB2")
Local cFilSB8		:= xFilial("SB8")
Local cFilSDA		:= xFilial("SDA")
Local cFilSD1		:= xFilial("SD1")
Local nX
DEFAULT lVerRes	:=	.F.

DbSelectArea("SB2")
aAreaSB2 := GetArea()
DbSelectArea("SB8")
aAreaSB8 := GetArea()
DbSelectArea("SDA")
aAreaSDA := GetArea()

If SF1->F1_TIPO_NF == "5" .AND. !Empty(SF1->F1_HAWB)
	lRet := .T.
EndIf

If lRet
	DbSelectArea("SD1")
	DbSetOrder(1)
	MsSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)

	WHILE ! SD1->(EOF()) .AND. SD1->D1_FILIAL==cFilCD1.AND. D1_DOC==SF1->F1_DOC .AND. D1_SERIE==SF1->F1_SERIE .AND.;
		 	SD1->D1_FORNECE==SF1->F1_FORNECE .AND. SD1->D1_LOJA==SF1->F1_LOJA .AND. SD1->D1_TIPO==SF1->F1_TIPO

      If ALLTRIM(SF1->F1_ESPECIE) == ALLTRIM(SD1->D1_ESPECIE) .AND. SF1->F1_TIPO == SD1->D1_TIPO
			Aadd(aRecnoSD1,SD1->(Recno()))
			DbSelectArea("SB2")
			MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL)

	      	If (nPosRec	:=	Ascan(aSB2,{|x| x[1]==RECNO()})) == 0
				AAdd(aSB2,{Recno(),SD1->D1_QUANT})
				nPosRec	:=	Len(aSB2)
			Else
			   	aSB2[nPosRec][2]	+=	SD1->D1_QUANT
			Endif

	      	If SaldoSB2(.T.) < aSB2[nPosRec][2]
	        	lRet	:=	.F.
			Endif
			If Rastro(SD1->D1_COD    ).AND.lRet
				If Rastro(SD1->D1_COD    ,"S")
					nOrd  := 2
					cSeek := (cFilSB8+SD1->D1_NUMLOTE+SD1->D1_LOTECTL+SD1->D1_COD+SD1->D1_LOCAL)
				Else
					nOrd  := 3
					cSeek := (cFilSB8+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL)
				EndIf

				DbSelectArea("SB8")
				DbSetOrder(nOrd)
				If DbSeek(cSeek)
	            	If (nPosRec	:=	Ascan(aSB8,{|x| x[1]==RECNO()})) == 0
						AAdd(aSB8,{Recno(),SD1->D1_QUANT})
						nPosRec	:=	Len(aSB8)
					Else
						aSB8[nPosRec][2]	+=	SD1->D1_QUANT
					Endif
					If SaldoLote(SB8->B8_PRODUTO,SB8->B8_LOCAL,SB8->B8_LOTECTL,If(nOrd==2,SB8->B8_NUMLOTE,Nil),,,.T.)<aSB8[nPosRec][2]
	    				lRet	:=	.F.
					Endif
				EndIf
			EndIf

			If Localiza(SD1->D1_COD) .AND. lRet
				DbSelectArea("SDA")
				DbSetOrder(1)
				If DbSeek(cFilSDA+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+SD1->D1_DOC)
	            	If (nPosRec	:=	Ascan(aSDA,{|x| x[1]==RECNO()})) == 0
						AAdd(aSDA,{Recno(),SD1->D1_QUANT})
						nPosRec	:=	Len(aSDA)
					Else
					   aSDA[nPosRec][2]	+=	SD1->D1_QUANT
					Endif
					If  (SDA->DA_SALDO-SDA->DA_EMPENHO) < aSDA[nPosRec][2]
	  		      		lRet	:=	.F.
					Endif
				EndIf
			EndIf
		eNDIF
		DbSelectArea("SD1")
		DbSkip()
	End
EndIf

If lRet
	lB8_ITEM	:= .T.
	For nX := 1 To Len(aRecnoSD1)
		SD1->(MsGoTo(aREcnoSD1[nX]))
		cTpOp := If(Empty(SD1->D1_OP),"F","P")

		SB1->(DbSetOrder(1))
		SB1->(MsSeek(cFilSB1+SD1->D1_COD))
		If Empty(SB1->B1_CONV) .AND. !Empty(SD1->D1_QTSEGUM)
			nTotQtd2 := SD1->D1_QTSEGUM
		ElseIf !Empty(SB1->B1_CONV)
			nTotQtd2 := SB1->(ConvUm(SB1->B1_COD,(SD1->D1_QUANT),SD1->D1_QTSEGUM,2))
		EndIf

		DbSelectArea("SB2")
		MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL)
		RecLock("SB2",.F.)
		If lPedido
			Replace B2_RESERVA With B2_RESERVA+SD1->D1_QUANT
			Replace B2_RESERV2 With B2_RESERV2+nTotQtd2
		Else
			If cTpOp  == "P"	// OP PREVISTA
				Replace B2_QEMPPRE With B2_QEMPPRE+SD1->D1_QUANT
				Replace B2_QEPRE2  With B2_QEPRE2 +nTotQtd2
			ElseIf cTpOp  == "F"	// OP FIRME
				Replace B2_QEMP  With B2_QEMP + SD1->D1_QUANT
				Replace B2_QEMP2 With B2_QEMP2+nTotQtd2
			EndIf
		EndIf
		MsUnlock()

		If Rastro(SD1->D1_COD)
			If Rastro(SD1->D1_COD,"S")
				nOrd  := 2
				cSeek := (cFilSB8+SD1->D1_NUMLOTE+SD1->D1_LOTECTL+SD1->D1_COD+SD1->D1_LOCAL)
				cCondSB8 := "B8_FILIAL+B8_NUMLOTE+B8_LOTECTL+B8_PRODUTO+B8_LOCAL=="
				cCondSB8 += "xFilial('SB8')+SD1->D1_NUMLOTE+SD1->D1_LOTECTL+SD1->D1_COD+SD1->D1_LOCAL"
			Else
				nOrd  := 3
				cSeek := (cFilSB8+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL)
				cCondSB8 := "B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL=="
				cCondSB8 +="xFilial('SB8')+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL"
			EndIf
      		nQtdEmp	:=	SD1->D1_QUANT
      		nQtdEmp2	:=	nTotQtd2

			DbSelectArea("SB8")
			DbSetOrder(nOrd)
			If DbSeek(cSeek)
				While !Eof() .AND. &(cCondSB8) .AND. nQtdEmp >	0
					If lB8_ITEM
						If B8_ITEM == SD1->D1_ITEM
	                 		nEmpenha	:=	IIf(nQtdEmp  > (SB8->B8_SALDO-SB8->B8_EMPENHO),(SB8->B8_SALDO-SB8->B8_EMPENHO),nQtdEmp)
	                 		nEmpenha2:=	IIf(nQtdEmp2 > (SB8->B8_SALDO2-SB8->B8_EMPENH2),(SB8->B8_SALDO2-SB8->B8_EMPENH2),nQtdEmp2)
							nQtdEmp	-=	nEmpenha
							nQtdEmp2	-=	nEmpenha2
							RecLock("SB8",.F.)
							Replace SB8->B8_EMPENHO With (SB8->B8_EMPENHO + nEmpenha)
							Replace SB8->B8_EMPENH2 With (SB8->B8_EMPENH2 + nEmpenha2)
							MsUnlock()
						EndIf
					Else
                 		nEmpenha	:=	IIf(nQtdEmp  > (SB8->B8_SALDO-SB8->B8_EMPENHO),(SB8->B8_SALDO-SB8->B8_EMPENHO),nQtdEmp)
                 		nEmpenha2:=	IIf(nQtdEmp2 > (SB8->B8_SALDO2-SB8->B8_EMPENH2),(SB8->B8_SALDO2-SB8->B8_EMPENH2),nQtdEmp2)
						nQtdEmp	-=	nEmpenha
						nQtdEmp2	-=	nEmpenha2
						RecLock("SB8",.F.)
						Replace SB8->B8_EMPENHO With (SB8->B8_EMPENHO + nEmpenha)
						Replace SB8->B8_EMPENH2 With (SB8->B8_EMPENH2 + nEmpenha2)
						MsUnlock()
					EndIf
					DbSkip()
				End
			EndIf
		EndIf

		If Localiza(SD1->D1_COD)
			DbSelectArea("SDA")
			DbSetOrder(1)
			If MsSeek(cFilSDA+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+SD1->D1_DOC)
				RecLock("SDA",.F.)
				Replace SDA->DA_EMPENHO With (SDA->DA_EMPENHO + SD1->D1_QUANT)
				Replace SDA->DA_EMP2 With (SDA->DA_EMP2 +nTotQtd2)
				MsUnlock()
			EndIf
		EndIf
	Next
EndIf
RestArea(aAreaSB2)
RestArea(aAreaSB8)
RestArea(aAreaSDA)
RestArea(aArea)
Return lRet

Static Function LibFatImp(lNaoForca)
Local aArea 	:= GetArea()
Local cSeek 	:= ""
Local nOrd  	:= 3
Local lEncerra  := .F.
Local aSWN, aSW6, aSD3, aSB8, aSDA, aSDB, aSB2
Local lRet 	    := .F.
Local lPedido   := .F.
Local cTpOp     := " "
Local cCondSB8  := ""
Local nEmpenha  := 0
Local nQtdEmp   := 0
Local nEmpenha2 := 0
Local nQtdEmp2	:= 0
Local nTotQtd2	:= 0
Local cFilSB1		:= xFilial("SB1")
Local cFilSB2		:= xFilial("SB2")
Local cFilSB8		:= xFilial("SB8")
Local cFilSD1		:= xFilial("SD1")
Local cFilSDA		:= xFilial("SDA")
Local cFilSDB		:= xFilial("SDB")
Local lB8_ITEM	:= .F.

DEFAULT lNaoForca	:=	.F.

dbSelectArea("SWN")
aSWN := GetArea()
dbSelectArea("SB2")
aSB2 := GetArea()
dbSelectArea("SW6")
aSW6 := GetArea()
dbSelectArea("SD3")
aSD3 := GetArea()
dbSelectArea("SB8")
aSB8 := GetArea()
dbSelectArea("SDA")
aSDA := GetArea()
dbSelectArea("SDB")
aSDB := GetArea()

If lNaoForca
	If SF1->F1_TIPO_NF $ "5" .AND. GetNewPar("MV_LIBIMP","S") == "S"
		lRet := .T.
	EndIf
Else
	If SF1->F1_TIPO_NF $ "9AB5" .AND. GetNewPar("MV_LIBIMP","S") == "S"
		lRet := .T.
	Endif
Endif
If lRet
	DbSelectArea("SD1")
	DbSetOrder(1)
	MsSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
	lB8_ITEM := .T.
	WHILE ! SD1->(EOF()) .AND. SD1->D1_FILIAL==cFilSD1.AND. D1_DOC==SF1->F1_DOC .AND. D1_SERIE==SF1->F1_SERIE .AND.;
		 	SD1->D1_FORNECE==SF1->F1_FORNECE .AND. SD1->D1_LOJA==SF1->F1_LOJA .AND. SD1->D1_TIPO==SF1->F1_TIPO

      If ALLTRIM(SF1->F1_ESPECIE) == ALLTRIM(SD1->D1_ESPECIE) .AND. SF1->F1_TIPO == SD1->D1_TIPO
			DbSelectArea("SB2")
			MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL)

			cTpOp := If(Empty(SD1->D1_OP),"F","P")
			cTpOp := "F"
			SB1->(DbSetOrder(1))
			SB1->(MsSeek(cFilSB1+SD1->D1_COD))
			If Empty(SB1->B1_CONV) .AND. !Empty(SD1->D1_QTSEGUM)
				nTotQtd2 := SD1->D1_QTSEGUM
			ElseIf !Empty(SB1->B1_CONV)
				nTotQtd2 := SB1->(ConvUm(SB1->B1_COD,(SD1->D1_QUANT),SD1->D1_QTSEGUM,2))
			EndIf

			If ! Empty(SD1->D1_QUANT)
				DbSelectArea("SB2")
				MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL)
				RecLock("SB2",.F.)
				If lPedido
					Replace B2_RESERVA With B2_RESERVA - SD1->D1_QUANT
					Replace B2_RESERV2 With B2_RESERV2 - nTotQtd2
				Else
					If cTpOp == "P"	// OP PREVISTA
						Replace B2_QEMPPRE With B2_QEMPPRE - SD1->D1_QUANT
						Replace B2_QEPRE2  With B2_QEPRE2 - nTotQtd2
					ElseIf cTpOp == "F"	// OP FIRME
						Replace B2_QEMP  With B2_QEMP - SD1->D1_QUANT
						Replace B2_QEMP2 With B2_QEMP2 - nTotQtd2
					EndIf
				EndIf
				MsUnlock()
			EndIf
			If Rastro(SD1->D1_COD)
				If Rastro(SD1->D1_COD,"S")
					nOrd  := 2
					cSeek := (cFilSB8+SD1->D1_NUMLOTE+SD1->D1_LOTECTL+SD1->D1_COD+SD1->D1_LOCAL)
					cCondSB8 := "B8_FILIAL+B8_NUMLOTE+B8_LOTECTL+B8_PRODUTO+B8_LOCAL=="
					cCondSB8 := "xFilial('SB8')+SD1->D1_NUMLOTE+SD1->D1_LOTECTL+SD1->D1_COD+SD1->D1_LOCAL"
				Else
					nOrd  := 3
					cSeek := (cFilSB8+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL)
					cCondSB8 := "B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL=="
					cCondSB8+="xFilial('SB8')+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL"
				EndIf
	      		nQtdEmp	:=	SD1->D1_QUANT
	      		nQtdEmp2	:=	nTotQtd2

				DbSelectArea("SB8")
				DbSetOrder(nOrd)
				If DbSeek(cSeek)
					While !Eof() .AND. &(cCondSB8) .AND. nQtdEmp >	0
						If lB8_ITEM
							If B8_ITEM == SD1->D1_ITEM
		                 		nEmpenha	:=	IIf(nQtdEmp  > (SB8->B8_EMPENHO),(SB8->B8_EMPENHO),nQtdEmp)
		                 		nEmpenha2:=	IIf(nQtdEmp2 > (SB8->B8_EMPENH2),(SB8->B8_EMPENH2),nQtdEmp2)
								nQtdEmp	-=	nEmpenha
								nQtdEmp2	-=	nEmpenha2
								RecLock("SB8",.F.)
								Replace SB8->B8_EMPENHO With SB8->B8_EMPENHO-nEmpenha
								Replace SB8->B8_EMPENH2 With SB8->B8_EMPENH2-nEmpenha2
								MsUnlock()
							EndIf
						Else
	                 		nEmpenha	:=	IIf(nQtdEmp  > (SB8->B8_EMPENHO),(SB8->B8_EMPENHO),nQtdEmp)
	                 		nEmpenha2:=	IIf(nQtdEmp2 > (SB8->B8_EMPENH2),(SB8->B8_EMPENH2),nQtdEmp2)
							nQtdEmp	-=	nEmpenha
							nQtdEmp2	-=	nEmpenha2
							RecLock("SB8",.F.)
							Replace SB8->B8_EMPENHO With SB8->B8_EMPENHO-nEmpenha
							Replace SB8->B8_EMPENH2 With SB8->B8_EMPENH2-nEmpenha2
							MsUnlock()
						EndIf
						DbSkip()
					End
				EndIf
			EndIf

			If Localiza(SD1->D1_COD)
				DbSelectArea("SDA")
				DbSetOrder(1)
				If DbSeek(cFilSDA+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+SD1->D1_DOC)
					RecLock("SDA",.F.)
					Replace SDA->DA_EMPENHO With 0
					Replace SDA->DA_EMP2    With 0
					MsUnlock()
				EndIf
				DbSelectArea("SDB")
				DbSetOrder(1)
				If DbSeek(cFilSDB+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+SD1->D1_DOC)
					RecLock("SDB",.F.)
					Replace SDB->DB_EMPENHO With 0
					Replace SDB->DB_EMP2    With 0
					MsUnlock()
				EndIf
			EndIf
		EndIf
		lEncerra := .T.
		DbSelectArea("SD1")
		DbSkip()
	End
EndIf

RestArea(aSWN)
RestArea(aSW6)
RestArea(aSB2)
RestArea(aSD3)
RestArea(aSB8)
RestArea(aSDA)
RestArea(aSDB)
RestArea(aArea)
Return(lEncerra)

/*
±±³Fun‡…o    ³ LocxGrvCusImp ³±±
±±³Descri‡…o ³ Grava o Custo dos itens de importacao e as suas DE6/RE6    ³±±
±±³ Uso      ³ MATA100 (Integracao com Modulo de Importacao)              ³±±
*/
Function LocxGrvCusImp(cDoc,cSerie,cNBM,aCustoEnt,aRecImp)
Local aArea        := GetArea()
Local aAreaSF1     := SF1->(GetArea())
Local aAreaSD1     := SD1->(GetArea())

Local aCusto	   := {}
//Local aCustoRem    := {}
Local aImpostos	   := {}
Local aTes         := {}
Local aMoeda       := {}
//Local aRemitos     := {}
Local aRecnoSD3	   := {}
Local aRemito	   := {}

Local nPosSWN	   := 0
//Local nQuant	   := 0
Local nPosTes      := 0
//Local nTotal	   := 0
Local nY,nE		   := 0
Local nPosCols	   := 0
Local nRegs		   := 0
Local nQtdItens	   := 0
Local nTxCusEIC    := 0
Local nMoedaOrig   := 0
//Local nX           := 0
Local nValImpX     := 0
Local nItem        := 1
Local nValorCus    := 0.00

Local cTipoNF	   := ""
Local cTesDespacho := ""
Local cNumRemito   := ""
Local cSerRemito   := ""
Local cCampo       := ""
Local cHawb        := ""
//Local cCodDespesa  := ""
Local cQuery	   := ""
Local cAliasQry	   := ""
Local cSeek        := ""

Local lQuery	   := .F.

Local dDtValid     := Nil

Local lSWNLote     := .T.
Local lAtuSegUM    := .T.
//Local nLenDoc      := TamSX3("F1_DOC")[1]
Local lMovtaSD3    := GetNewPar("MV_CUSTIMP","1") == "1"
Local nPosAColsTes := AScan(aHeader,{|x| Upper(Alltrim(x[2]))$"D1_TES"})
Local cFornece     := SF1->F1_FORNECE
Local cLoja        := SF1->F1_LOJA
Local cFornDes     := SF1->F1_FORNECE
Local cLojaDes     := SF1->F1_LOJA
Local cNFiscalDes  := SF1->F1_DOC
Local cSerieDes    := SF1->F1_SERIE
Local dDataTaxa

Local lB2AtuUnif	:= .T.
Local lWN_TES 	:= .F.
Local lWN_ITEMNF	:= .F.
Local lWN_LOCAL	:= .F.
Local lWN_DESPSUB:= .F.
Local cFilSB1		:= xFilial("SB1")
Local cFilSB2		:= xFilial("SB2")
Local cFilSB8		:= xFilial("SB8")
Local cFilSD1		:= xFilial("SD1")
Local cFilSF1		:= xFilial("SF1")
Local cFilSF4		:= xFilial("SF4")
Local cFilSYD		:= xFilial("SYD")
Local cFilSWD		:= xFilial("SWD")
Local cFilSWN		:= xFilial("SWN")
Local cFilSW6		:= xFilial("SW6")
Local cFilSW9		:= xFilial("SW9")
Local cFilSWW		:= xFilial("SWW")
Local nT_ITEM		:= TamSx3('D1_ITEM')[1]
Local cAuxPaisL     := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local lotext := Type('otext')=='O'

DEFAULT aRecImp    := {}

lQuery	:=	TcSrvType()<>"AS/400"

nMoedaCor := If(nMoedaCor==NIL,1,nMoedaCor)
If lMovtaSD3 .AND. SF1->F1_TIPO_NF == "5"
	Return
EndIf

If lMovtaSD3	 //Ingresos e Custeos por Movimentos o Remitos
	DbSelectArea("SWN")
	DbSetOrder(2)
	MsSeek(cFilSWN+cDoc+cSerie+cFornece+cLoja)
	//³ Grava o Custo e as DE6 / RE6 para os Itens da NBM.           ³

	nQtdItens:=	Len(aCols)
	nItem		:=	4
	nPosCols	:=	1
	nRegs		:=	0
	lWN_LOCAL	:= .T.
	cAuxPaisL   := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
	lWN_DESPSUB	:= IIf(cPaisLoc $ cAuxPaisL, .T. , .F. )
	While !Eof() .AND. WN_FILIAL==cFilSWN .AND. WN_DOC==cDoc .AND. WN_SERIE==cSerie .AND. WN_FORNECE==cFornece .AND. WN_LOJA==cLoja
		nRegs++
		//Cada vez que processa nQtdItens registros do SWN, significa que passou para a
		//proxima linha do acols
		If nRegs	> nQtdItens
			nRegs	:=	0
			nPosCols++
		Endif
		If lotext //Se foi chamada da MSAguarde()
			If Mod(nItem,nQtdItens)==0
		      	MsProcTxt(STR0004+SWN->WN_PRODUTO+" ("+StrZero((nItem/nQtdItens),4)+").")
  			EndIf
  			nItem++
		EndIf
		If	SWN->WN_TIPO_NF == "9" .OR. SWN->WN_TIPO_NF == "A"
			nValorCus := SWN->WN_DESPESA+SWN->WN_VALIMP5
		Else
			If lWN_DESPSUB
				nValorCus := Round(SWN->WN_VALOR-SWN->WN_DESPSUB,2)
			Else
				nValorCus := SWN->WN_VALOR
			EndIf
		EndIf
		If nValorCus >= 0.00

	    	SB1->(DbSetOrder(1))
    		SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))

			//³ Posicionar os arquivos TES e PRODUTOS ³
			aTES := {}
			cTesDespacho := Space(3)

			If SWN->WN_TIPO_NF $ "5678"
				SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))
				AADD(aTes,SYD->YD_TES)
			Else
			   If lQuery
			   		cQuery	:=	" Select WD_TES FROM "+RetSqlName('SWW')+" SWW, "+RetSqlName('SWD')+" SWD	"
			   		cQuery	+=	" WHERE  WW_FILIAL  = '"+cFilSWW+"' AND "
					cQuery	+=	" WW_NF_COMP = '"+SF1->F1_DOC+"' AND "
					cQuery	+=	" WW_SE_NFC  = '"+SF1->F1_SERIE+"' AND "
					cQuery	+=	" WW_FORNECE = '"+SF1->F1_FORNECE+"'   AND "
					cQuery	+=	" WW_LOJA    = '"+SF1->F1_LOJA+"' AND "
			   		cQuery	+=	" WD_FILIAL  = '"+cFilSWD+"' AND "
					If UPPER(TcGetDb()) == "INFORMIX"
						cQuery	+=	" WD_DESPESA = SUBSTR(SWW.WW_DESPESA,1,3) AND "
					Else
						cQuery	+=	" WD_DESPESA = Left(SWW.WW_DESPESA,3) AND "
					EndIf
					cQuery	+=	" WD_DOCTO 	 = '"+SF1->F1_DOC+"' AND "
					cQuery	+=	" WD_HAWB 	 =  SWW.WW_HAWB AND "
					cQuery	+=	" SWD.D_E_L_E_T_='' AND "
					cQuery	+=	" SWW.D_E_L_E_T_='' "
					cQuery	+=	" GROUP BY WD_TES "

	  				cQuery	:=	ChangeQuery(cQuery)
	  				cAliasQry	:=	CriaTrab(Nil,.F.)
					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
					DbSelectArea(cAliasQry)
					While !EOF()
	  	         	nPosTes := Ascan(aTes,(cAliasQry)->WD_TES)
	  	         	If nPosTes == 0
  		   				AADD(aTes,If(Empty((cAliasQry)->WD_TES),aCols[nPosCols][nPosAColsTes],(cAliasQry)->WD_TES))
  						EndIf
			   		DbSkip()
					End
					DbCloseArea()
				Else
					DbSelectArea("SWW")
					DbSetOrder(1)
					If DbSeek(cFilSWW+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
						While ! Eof().AND. WW_FILIAL==cFilSWW .AND.;
      							WW_NF_COMP == SF1->F1_DOC     .AND.;
	  		    				WW_SE_NFC  == SF1->F1_SERIE   .AND.;
								WW_FORNECE == SF1->F1_FORNECE .AND.;
								WW_LOJA    == SF1->F1_LOJA

							DbSelectArea("SWD")
							DbSetOrder(3)
		   	 				If MsSeek(cFilSWD+Left(SWW->WW_DESPESA,3)+SWW->WW_NF_COMP+SWW->WW_HAWB)
		  		  				While !Eof() .AND.;
		    							WD_DESPESA == Left(SWW->WW_DESPESA,3) .AND.;
		    							WD_DOCTO == SWW->WW_NF_COMP .AND.;
		    							WD_HAWB == SWW->WW_HAWB
                    	    		nPosTes := Ascan(aTes,SWD->WD_TES)
                     	  			If nPosTes == 0
              							AADD(aTes,If(Empty(SWD->WD_TES),aCols[nPosCols][nPosAColsTes],SWD->WD_TES))
		    						EndIf
				   					DbSkip()
		   						End
		   					EndIf
		   					DbSelectArea("SWW")
			   				DbSkip()
						End
					EndIf
				EndIf
				DbSelectArea("SWN")
            EndIf

			For nE := 1 To Len(aTes)
				SF4->(MsSeek(cFilSF4+aTes[nE]))

		   		If !SF4->(EOF()) .AND. SF4->F4_ESTOQUE == "S"
					aCusto := {}
					If lWN_DESPSUB
						AADD(aCusto,{WN_VALOR-WN_DESPSUB,{},0,"N","N","","",WN_PRODUTO,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),WN_QUANT})
					Else
						AADD(aCusto,{WN_VALOR,{},0,"N","N","","",WN_PRODUTO,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),WN_QUANT})
					EndIf

					aImpostos := DefImposto(aTes[nE])
					For nY:=1 to Len(aImpostos)
						nPosSWN := SWN->(FieldPos("WN_"+Substr(aImpostos[nY][2],1,7)))
						If nPosSWN > 0
							If ( aImpostos[nY][5] $ "S1" )
								aCusto[1][1] += SWN->(FieldGet(nPosSWN))
							EndIf
						EndIf
					Next nY

					If SWN->WN_TIPO_NF $ "9"
						SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))
						cTesDespacho := SYD->YD_TES
						// Compara se Tes do Despacho é diferente do Tes de gastos
						If cTesDespacho != aTes[nE]
							aImpostos := DefImposto(cTesDespacho)
							For nY:=1 to Len(aImpostos)
								nPosSWN := SWN->(FieldPos("WN_"+Substr(aImpostos[nY][2],1,7)))
								If nPosSWN > 0
									If ( aImpostos[nY][5] $ "S1" )
										aCusto[1][1] += SWN->(FieldGet(nPosSWN))
									EndIf
								EndIf
							Next nY
						EndIf
		       		EndIf

					//³ Calcula o Custo de Entrada de Cada Item NBM                     ³

					aCustoEnt := {}
					aCustoEnt := RetCusEnt(,aCusto)

					//³ Gera lanç no SD3 para cada item do SWN.                   ³

					If Empty(WN_NUMSEQ)
						RecLock("SWN",.F.)
						Replace WN_NUMSEQ	With ProxNum()
						MsUnLock()
					EndIf

					If lWN_LOCAL
						MSGravaD3(	WN_PRODUTO,;
									SubStr(WN_PO_NUM,1,6),;
									WN_ITEM,;
									WN_QUANT,;
									aCustoEnt[1],;
									,;
									If(lSWNLote,SWN->WN_LOTECTL,""),;
									If(lSWNLote,SWN->WN_DTVALID,;
									CtoD("  /  /  ")),;
									If(lAtuSegUM,SWN->WN_QTSEGUM,0),;
									If(lAtuSegUM,SWN->WN_SEGUM,"  "),;
									If(Empty(SWN->WN_LOCAL),RetFldProd(SB1->B1_COD,"B1_LOCPAD"),SWN->WN_LOCAL))
					Else
						MSGravaD3(	WN_PRODUTO,;
									SubStr(WN_PO_NUM,1,6),;
									WN_ITEM,;
									WN_QUANT,;
									aCustoEnt[1],;
									,;
									If(lSWNLote,SWN->WN_LOTECTL,""),;
									If(lSWNLote,SWN->WN_DTVALID,;
									CtoD("  /  /  ")),;
									If(lAtuSegUM,SWN->WN_QTSEGUM,0),;
									If(lAtuSegUM,SWN->WN_SEGUM,))
					EndIf
					AAdd(aRecnoSD3,{SD3->(Recno()),SWN->(RECNO())} )
					If Empty(WN_NUMSEQ)
						RecLock("SWN",.F.)
						Replace WN_NUMSEQ	With ProxNum()
						MsUnLock()
					EndIf
					cPe	:=	LocxPE(42)
					If !Empty(cPe)
						ExecBlock(cPe,.F.,.F.)
					EndIf

					Exit
				EndIf
			Next nE
		EndIf
		DbSelectArea("SWN")
		DbSkip()
	End
Else
	aAreaSF1 := SF1->(GetArea())
	aAreaSD1 := SD1->(GetArea())

	If GetMv('MV_FLTD1D2')
		SF1->(DbClearFilter())
	EndIf

	SB2->(DbSetOrder(1))
	DbSelectArea("SWN")
	DbSetOrder(1)
	DbSeek(cFilSWN+cDoc+cSerie)
	cTipoNF := SWN->WN_TIPO_NF
	cHawb   := SWN->WN_HAWB
	cFornece:= SWN->WN_FORNECE
	cLoja   := SWN->WN_LOJA
	cLoteCtl:= SWN->WN_LOTECTL

	//³ Se eh FOB so tem um remito

	If cTipoNf  == '5'
		aRemito    := LocxNrReIm(SWN->WN_HAWB,Substr(SWN->WN_INVOICE,1,Len(SF1->F1_DOC))) // Buscar o remito da invoice
		cSerRemito := aRemito[1]
		cNumRemito := aRemito[2]
		cFornece   := If(Empty(aRemito[3]),SF1->F1_FORNECE,aRemito[3])
		cLoja      := If(Empty(aRemito[4]),SF1->F1_LOJA   ,aRemito[4])
		RecLock("SF1",.F.)
		Replace SF1->F1_REMITO With cNumRemito
		SF1->(MsUnlock())
	EndIf

	//³ Grava Remitos para registrar Ingresos ³

	nItem   := 0
	cInvAnt	:=	''

	DbSelectArea("SWN")
	DbSetOrder(1)
	lWN_TES 		:= cPaisLoc == "ARG"
	lWN_ITEMNF		:= cPaisLoc == "ARG"
	lWN_LOCAL		:= .T.
	lWN_DESPSUB	    := cPaisLoc $ cAuxPaisL
	While !Eof() .AND. WN_FILIAL==cFilSWN .AND. WN_DOC==cDoc .AND. WN_SERIE==cSerie

		AAdd(aRecImp,{0,SWN->(RECNO())})

		If cTipoNf  <> '5'
			If SWN->WN_INVOICE <> cInvAnt
				aRemito		:= LocxNrReIm(SWN->WN_HAWB,Substr(SWN->WN_INVOICE,1,Len(SF1->F1_DOC))) //Buscar o remito da invoice
				cSerRemito  := aRemito[1]
				cNumRemito 	:= aRemito[2]
				cFornece 	:= If(Empty(aRemito[3]),SF1->F1_FORNECE,aRemito[3])
				cLoja 		:= If(Empty(aRemito[4]),SF1->F1_LOJA,aRemito[4])
				cInvAnt 	:= SWN->WN_INVOICE
			EndIf
        EndIf

		If lWN_DESPSUB
			nValorCus := Round(SWN->WN_VALOR-SWN->WN_DESPSUB,2)
		Else
			nValorCus := SWN->WN_VALOR
		EndIf

		If nValorCus > 0.00
	    	SB1->(DbSetOrder(1))
    		SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))

	    	SW6->(DbSetOrder(1))
    		SW6->(MsSeek(cFilSW6+SWN->WN_HAWB))

	    	SW9->(DbSetOrder(1))
    		SW9->(DbSeek(cFilSW9+SWN->WN_INVOICE+SWN->WN_FORNECE))

			//³ Posicionar os arquivos TES e PRODUTOS                           ³

			aTES         := {}
			cTesDespacho := Space(3)

			//³ Devido a gravacao das notas serem diferentes, o SWN sempre      |
			//³ mostrara os dados do produto importado e nas notas tipo 9/A as  |
			//| despesas usarao seu proprio TES (D1_TESDES).                    |

			If SWN->WN_TIPO_NF $ "5678"
				If lWN_TES
					AADD(aTes,SWN->WN_TES)
				Else
					SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))
					AADD(aTes,SYD->YD_TES)
				EndIf
			Else
    			DbSelectArea("SD1")
				DbSetOrder(2)
				MsSeek(cFilSD1+SWN->WN_PRODUTO+cNFiscalDes+cSerieDes+cFornDes+cLojaDes)

	           	nPosTes := Ascan(aTes,SD1->D1_TESDES)
               	If nPosTes == 0
   					AADD(aTes,SD1->D1_TESDES)
   				EndIf
  			EndIf

			//-- Posiciona TES
			SF4->(MsSeek(cFilSF4+aTes[1]))

        	//-- Posiciona Despesas/Gastos da import.
        	SWD->(DbSetOrder(1))
            SWD->(DbSeek(cSeek:=cFilSWD+SWN->WN_HAWB))
			Do While SWD->(!Eof()) .AND. cSeek == SWD->WD_FILIAL+SWD->WD_HAWB
			    If SWD->WD_DOCTO == SWN->WN_DOC .AND. SWD->WD_SE_DOC == SWN->WN_SERIE
			    	Exit
			    EndIf
				SWD->(dbSkip())
			End

			DbSelectArea("SWN")

			DbSelectArea("SF1")
			DbSetOrder(1)
			If lUsaNewKey
				cSerRemito:=SerieNfId("SF1",4,"F1_SERIE",SW9->W9_DT_EMIS,"RCN",cSerRemito)
			Endif
			DbSeek(cFilSF1+cNumRemito+cSerRemito+cFornece+cLoja)
			If !Found() .AND. SWN->WN_TIPO_NF == "5"
				RecLock("SF1",.T.)
				Replace F1_FILIAL		With cFilSF1
				Replace F1_DOC			With cNumRemito
				SerieNfId("SF1",1,"F1_SERIE",SW9->W9_DT_EMIS,"RCN",subStr(cSerRemito,1,3)) //Projeto Chave Unica - Tiago Silva
				Replace F1_FORNECE		With cFornece
				Replace F1_LOJA			With cLoja
				Replace F1_TIPODOC		With "10"
				Replace F1_MOEDA		With nMoedaCor
				Replace F1_TXMOEDA		With RecMoeda(dDataBase,nMoedaCor)
				Replace F1_ESPECIE		With "RCN"
				Replace F1_TIPO			With "N"
				Replace F1_STATUS		With "A"
				//Integracao com EIC, Lucas 12/08/2007
				Replace F1_EMISSAO		With SW9->W9_DT_EMIS
				Replace F1_DTDIGIT		With dDataBase
				Replace F1_HAWB     	With SWN->WN_HAWB
				Replace F1_TIPO_NF		With If(SWN->WN_TIPO_NF != "8","5",SWN->WN_TIPO_NF)
				MsUnLock()
			EndIf

			If SWN->WN_TIPO_NF == "5" //So gera SD1 para NF tipo FOB
				nItem++
				RecLock("SD1",.T.)
				Replace D1_FILIAL		With cFilSD1
				Replace D1_DOC			With cNumRemito
				SerieNfId("SD1",1,"D1_SERIE",SF1->F1_EMISSAO,"RCN",subStr(cSerRemito,1,3)) //Projeto Chave Unica - Tiago Silva
				Replace D1_FORNECE		With cFornece
				Replace D1_LOJA			With cLoja
				Replace D1_DTDIGIT		With dDataBase
				Replace D1_TIPO			With "N"
				Replace D1_ESPECIE		With "RCN"
				If cPaisLoc=="ARG"
				   Replace D1_ITEM		With STRZERO(VAL(SWN->WN_ITEMNF),TamSX3("D1_ITEM")[1] )//cItemRem
				Else
				   Replace D1_ITEM			With STRZERO(nItem,nT_ITEM)//cItemRem
				EndIf
				Replace D1_COD      	With SWN->WN_PRODUTO
				Replace D1_UM			With SB1->B1_UM
				Replace D1_SEGUM		With SB1->B1_SEGUM
				Replace D1_LOCAL		With SWN->WN_LOCAL
				Replace D1_LOTECTL		With SWN->WN_LOTECTL
				Replace D1_NUMLOTE		With SWN->WN_NUMLOTE
				Replace D1_DTVALID		With SWN->WN_DTVALID
				Replace D1_TIPODOC		With "64"
				Replace D1_QUANT		With SWN->WN_QUANT
				Replace D1_QTSEGUM		With SWN->WN_QTSEGUM
				Replace D1_TES			With aTes[1]
				Replace D1_CF			With SF4->F4_CF
				Replace D1_QTDACLA		With SD1->D1_QUANT
				Replace D1_TEC			With SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM
				Replace D1_CONHEC		With SWN->WN_HAWB
				Replace D1_TIPO_NF		With SF1->F1_TIPO_NF
				Replace D1_NUMSEQ		With ProxNum()
				Replace D1_EMISSAO		With SF1->F1_EMISSAO
				Replace D1_PEDIDO		With SWN->WN_PO_NUM
				Replace D1_ITEMPC		With SWN->WN_ITEM
                MsUnLock()
    		EndIf

			If lWN_ITEMNF
				DbSelectArea("SD1")
				DbSetOrder(1)
				MsSeek(cFilSD1+cNumRemito+cSerRemito+cFornece+cLoja+SWN->WN_PRODUTO+SWN->WN_ITEMNF)
			Else
				DbSelectArea('SD1')
				DbSetOrder(1)
				MsSeek(cFilSD1+cNumRemito+cSerRemito+cFornece+cLoja+SWN->WN_PRODUTO+If(SWN->WN_TIPO_NF=="5",STRZERO(nItem,nT_ITEM),""))
			EndIf

            If SD1->(Found())

				If SWN->WN_TIPO_NF == "9" .OR. SWN->WN_TIPO_NF == "A"	//Nota de Despesas do Despachante ou Nota Complementar de Custos

	    	      	//³ Pegar a taxa da Moeda do cabealho da fatura de Importacao  na tabela  |
            		//³ para pegar la moneda, tasa y TES.                                     ³

					nTxCusEIC  := SWD->WD_TX_MOE
					nMoedaOrig := SimbToMoeda(SWD->WD_MOEDA)
					nMoedaOrig := If(nMoedaOrig>0,nMoedaOrig,1)
					dDataTaxa  := If( Empty(SWD->WD_DT_EMIS),SWD->WD_DES_ADI,SWD->WD_DT_EMIS)

        		    //³ Gravar D1_TOTAL y D1_CUSTO ya convertido...      ³

					If nTxCusEIC == 0
						nTxCusEIC := 1
					EndIf

				    //³ Pesquisa TES do cadastro de NCM                  ³

					SYD->(dbSetOrder(1))
					SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))

					If lWN_TES .AND. !Empty(SWN->WN_TES)
						nValImpX  := LxSomaImp(SWN->WN_TES)
					Else
						nValImpX  := LxSomaImp(IIf(Found(),SYD->YD_TES,SD1->D1_TES))
					EndIf

					RecLock( 'SD1', .F. )
	    			Replace D1_TOTAL With D1_TOTAL + (SWN->WN_DESPESA+nValImpX)
			    	Replace D1_VUNIT With (D1_TOTAL/D1_QUANT)
    				Replace D1_CUSTO With D1_CUSTO + (SWN->WN_DESPESA+nValImpX)

					//³ Grava custo em moeda 2,3,4 y 5.                              ³

					aMoeda := {"","","","",""}
					For nY := 2 To 5
						cCampo := "SD1->D1_CUSTO"+Str(nY,1,0)
						If nMoedaOrig = nY
							Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
				        Else
							aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
        					Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
			    		EndIf
				    Next nY
					SD1->(MsUnLock())
					If SB2->(MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL))
		    	    	Reclock("SB2",.F.)
			    	    Replace SB2->B2_VATU1 With SB2->B2_VATU1 + xMoeda(SWN->WN_DESPESA+nValImpX,1,1,SF1->F1_EMISSAO,,,nTxCusEIC)
						aMoeda := {"","","","",""}
						For nY := 2 To 5
							cCampo := "SB2->B2_VATU"+Str(nY,1,0)
							If nMoedaOrig = nY
								Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
					        Else
								aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
								Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
				    		EndIf
					    Next nY
						SB2->(MsUnLock())
						If SB2->B2_QATU > 0
							RecLock("SB2",.F.)
							Replace SB2->B2_CM1		With SB2->B2_VATU1/SB2->B2_QATU
							Replace SB2->B2_CM2		With SB2->B2_VATU2/SB2->B2_QATU
							Replace SB2->B2_CM3		With SB2->B2_VATU3/SB2->B2_QATU
							Replace SB2->B2_CM4		With SB2->B2_VATU4/SB2->B2_QATU
							Replace SB2->B2_CM5		With SB2->B2_VATU5/SB2->B2_QATU
							SB2->(MsUnLock())
						EndIf

						//³Atualiza o custo unificado ON-LINE                     ³

						If lB2AtuUnif
							B2AtuUnif(SB2->B2_COD)
						EndIf
           	        EndIf

					//³ Acumular F1_VALMERC y F1_VALBRUT en SF1.    					|

					DbSelectArea('SF1')
					RecLock( 'SF1', .F. )
					Replace F1_VALMERC 	With F1_VALMERC + SWN->WN_DESPESA+nValImpX
					Replace F1_VALBRUT	With F1_VALBRUT + SWN->WN_DESPESA+nValImpX
					MsUnlock()

				ElseIf SWN->WN_TIPO_NF $ "5678" //FOB, Frete ou Seguro

           	    	//³  Pegar Moeda e Taxa do arquivo de Processos.        ³

	            	If 	SWN->WN_TIPO_NF $ "5|8"     //FOB ou CIF
	            		cMoedaEIC := SW9->W9_MOE_FOB
                 		nTxCusEIC := SW9->W9_TX_FOB
						dDataTaxa := SW9->W9_DT_EMIS
                 	ElseIf SWN->WN_TIPO_NF $ "6"	//Frete
	            		cMoedaEIC := SW6->W6_FREMOED
                   		nTxCusEIC := SW6->W6_TX_FRET
						dDataTaxa := SW6->W6_DTREG_D
                   	ElseIf SWN->WN_TIPO_NF $ "7"    //Seguro
		           		cMoedaEIC := SW6->W6_SEGMOED
    	           		nTxCusEIC := SW6->W6_TX_SEG
						dDataTaxa := SW6->W6_DTREG_D
    	           	EndIf

  	             	nMoedaOrig := SimbToMoeda(cMoedaEIC)
  	             	nMoedaOrig := If(nMoedaOrig>0,nMoedaOrig,1)

					RecLock( 'SD1', .F. )
	    			Replace D1_TOTAL 	With D1_TOTAL + (SWN->WN_VALOR - SWN->WN_DESPSUB)
			    	Replace D1_VUNIT  	With D1_TOTAL/D1_QUANT
   					Replace D1_CUSTO 	With D1_CUSTO + (SWN->WN_VALOR - SWN->WN_DESPSUB)


           			//³ Grava custo em moeda 2,3,4 y 5.  ³

					aMoeda := {"","","","",""}
					For nY := 2 To 5
						cCampo := "SD1->D1_CUSTO"+Str(nY,1,0)
						If nMoedaOrig = nY
			        		Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
				        Else
							aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
			        		Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
			    		EndIf
				    Next nY
					SD1->(MsUnLock())

					//³ Atualizar Saldos Fisico e Financeiro  |

					If SWN->WN_TIPO_NF $ "5|8"
						If ! SB2->(MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL))
							CriaSB2(SD1->D1_COD,D1_LOCAL)
						EndIf
						DbSelectArea("SB2")
						RecLock("SB2",.F.)
						Replace B2_QATU	With B2_QATU + SD1->D1_QUANT
						Replace B2_QTSEGUM	With B2_QTSEGUM + SD1->D1_QTSEGUM
						MsUnLock()

						//³ Movimenta Lotes/Sub-Lotes/Localizacao Fisica³

						If Rastro(SD1->D1_COD) .OR. Localiza(SD1->D1_COD)

							//³ Tratamento da gravacao do SD1 na Integridade Referencial  ³

							SD1->(FkCommit())
							dDtValid	:= SD1->D1_DTVALID
							If !Empty(SD1->D1_LOTECTL)
								SB8->(DbSetOrder(3))
								If SB8->(MsSeek(cFilSB8+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL))
									dDtValid	:=	SB8->B8_DTVALID
								EndIf
							EndIf

							//³ MovLote - Utilizada para gravacao da rastreabilidade do produto     ³

							cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
							MovLote("SD1",;					//1
									SD1->D1_COD,;			//2
									SD1->D1_LOCAL,;			//3
									If((cPaisLoc<>"BRA") .AND. cPaisLoc $ cAuxPaisL,SD1->D1_LOCALIZ,NIL),;	//4
									If((cPaisLoc<>"BRA") .AND. cPaisLoc $ cAuxPaisL,SD1->D1_NUMSERI,NIL),;	//5
									SD1->D1_LOTECTL,;		//6
									SD1->D1_NUMLOTE,;		//7
									SD1->D1_NUMSEQ,;		//8
									SD1->D1_TES,;         	//9
									SD1->D1_FORNECE,;		//10
									SD1->D1_LOJA,;			//11
									SD1->D1_LOTEFOR,;		//12
									"RCN",;					//13
									SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD,;	//14
									SD1->D1_DOC,;			//15
									SD1->D1_SERIE,;			//16
									SD1->D1_OP,;			//17
									NIL,;					//18
									NIL,;					//19
									NIL,;					//20
									NIL,;					//21
									SD1->D1_QUANT,;			//22
									SD1->D1_QTSEGUM,;		//23
									SD1->D1_DTDIGIT,;		//24
									dDtValid,;				//25
									NIL,;					//26
									NIL,;					//27
									SD1->D1_TES>"500",;   	//28
									.T.,;					//29
									SD1->D1_TES<="500",; 	//30
									NIL,;					//31
									NIL,;					//32
									NIL,;					//33
									NIL,;					//34
									NIL,;					//35
									NIL,;					//36
									NIL,;					//37
									NIL,;					//38
									NIL,;					//39
									NIL,;					//40
									NIL,;					//41
									NIL,;					//42
									NIL,;					//43
									NIL,;					//44
									NIL,;					//45
									NIL,;					//46
									NIL,;					//47
									NIL,;					//48
									NIL,;					//49
									SD1->D1_POTENCI) 		//50
							LogMov("SD1",,,,,,.F.,"SD1")
						EndIf
					EndIf

					//³ Atualizar Saldos Fisico e Financeiro |
					If SB2->(MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL))
		    	    	RecLock("SB2",.F.)
						Replace B2_VATU1 	With B2_VATU1 + xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,1,SF1->F1_EMISSAO,,,nTxCusEIC)
						aMoeda := {"","","","",""}
						For nY := 2 To 5
							cCampo := "SB2->B2_VATU"+Str(nY,1,0)
							If nMoedaOrig = nY
					    	    Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
					        Else
								aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
					    	    Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
				    		EndIf
					    Next nY
					    SB2->(MsUnLock())
						If SB2->B2_QATU > 0
						    RecLock("SB2",.F.)
							Replace SB2->B2_CM1		With SB2->B2_VATU1/SB2->B2_QATU
							Replace SB2->B2_CM2		With SB2->B2_VATU2/SB2->B2_QATU
							Replace SB2->B2_CM3		With SB2->B2_VATU3/SB2->B2_QATU
							Replace SB2->B2_CM4		With SB2->B2_VATU4/SB2->B2_QATU
							Replace SB2->B2_CM5		With SB2->B2_VATU5/SB2->B2_QATU
						EndIf
						SB2->(MsUnLock())

						//³Atualiza o custo unificado ON-LINE  ³

						If lB2AtuUnif
							B2AtuUnif(SB2->B2_COD)
						EndIf

           	        EndIf
					//³ Acumular F1_VALMERC y F1_VALBRUT en SF1.  |
					DbSelectArea('SF1')
					RecLock( 'SF1', .F. )
					Replace F1_VALMERC 	     With F1_VALMERC + ( SWN->WN_VALOR - SWN->WN_DESPSUB )
					Replace F1_VALBRUT		 With F1_VALBRUT + ( SWN->WN_VALOR - SWN->WN_DESPSUB )
					MsUnlock()
				EndIf
			EndIf
		EndIf
		DbSelectArea("SWN")
		DbSkip()
	End

	If GetMv('MV_FLTD1D2')
		Eval( bFilBrw )
	EndIf

EndIf

RestArea(aArea)
Return aRecnoSD3

Function LocxNCPEic(xAutoCab,xAutoItens,nOpc)
LOCAL aAutoCab	 := xAutoCab
LOCAL aAutoItens := xAutoItens
LOCAL nTxCusEic  := 0.00
LOCAL aTes 	:= {}
LOCAL lDupl := .F.
LOCAL nI	:= 0
LOCAL nJ	:= 0
LOCAL cFilSA2	:= xFilial("SA2")
LOCAL cFilSB1	:= xFilial("SB1")
LOCAL cFilSD2	:= xFilial("SD2")
LOCAL cFilSD3	:= xFilial("SD3")
LOCAL cFilSE2	:= xFilial("SE2")
LOCAL cFilSF4	:= xFilial("SF4")
LOCAL cFilSWD	:= xFilial("SWD")
LOCAL cFilSWN	:= xFilial("SWN")
LOCAL cAliasSE2	:= ""
LOCAL cQuery	:= ""
LOCAL lUsaNewKey:= TamSX3("F2_SERIE")[1] == 14
LOCAL cPref		:= ""

nPosDoc   := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_DOC"})
nPosSerie := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_SERIE"})
nPosForn  := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_CLIENTE"})
nPosLoja  := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_LOJA"})
nPosCond  := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_COND"})
nPosValor := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_VALBRUT"})
nPosHawb  := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_HAWB"})

If nPosDoc > 0
	cNFiscal := aAutoCab[nPosDoc][2]
EndIf
If nPosSerie > 0
	cSerie := aAutoCab[nPosSerie][2]
EndIf
If nPosForn > 0
	cFornece := aAutoCab[nPosForn][2]
EndIf
If nPosLoja > 0
	cLoja := aAutoCab[nPosLoja][2]
EndIf
If nPosCond > 0
	cCond := aAutoCab[nPosCond][2]
EndIf
If nPosValor > 0
   nValDup := aAutoCab[nPosValor][2]
EndIf
If nPosHawb > 0
   cHawb := aAutoCab[nPosHawb][2]
EndIf

If nOpc == 3 //Inclusao
	If lUsaNewKey

		cAliasSE2 := "ALxNCPEic"
		cQuery := " SELECT MAX(E2_PREFIXO) E2PRFXMAX FROM " + RetSqlName("SE2")
		cQuery += " WHERE E2_FILIAL = '" + cFilSE2 + "'"
		cQuery += " AND E2_NUM      = '" + cNFiscal + "'"
		cQuery += " AND E2_FORNECE  = '" + cFornece + "'"
		cQuery += " AND E2_LOJA     = '" + cLoja+ "'"
		cQuery += " AND D_E_L_E_T_  = ''"
	   	cQuery	  := ChangeQuery(cQuery)
		cAliasSE2 := CriaTrab(Nil,.F.)

		dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasSE2, .T., .T. )
		DbSelectArea(cAliasSE2)

		If !Empty( (cAliasSE2)->E2PRFXMAX )
			cPref:= Soma1( (cAliasSE2)->E2PRFXMAX , TamSX3("E2_PREFIXO")[1] )
			/*
			Devido ao projeto CHAVE ÚNICA, a consistência abaixo é necessária para
			garantir que o novo título a ser gerado não irá colidir com um título
			da base histórica do cliente criada antes do projeto chave única.
			*/
			While .T.
				SE2->(dbSetOrder(1))
				If (SE2->(dbSeek(cFilSE2+cPref+cNFiscal)))
					cPref:= Soma1(cPref, TamSX3("E2_PREFIXO")[1])
				Else
					EXIT
				EndIf
			EndDo
		EndIf
		(cAliasSE2)->(DbCloseArea())
	Endif

	DbSelectArea("SF2")
	DbSetOrder(1)
	MsSeek(xFilial("SF2")+cNFiscal+cSerie+cFornece+cLoja)
	If Found()
		MsgStop("Nota de Credito ya existe!!!","Atencion")
		Return(.F.)
	EndIf

	DbSelectArea("SF2")
	RecLock("SF2",.T.)
	For nI := 1 To Len(aAutoCab)
		SF2->(FieldPut(FieldPos(AllTrim(aAutoCab[nI][1])),aAutoCab[nI][2]))
	Next nI
	Replace F2_FILIAL   With xFilial("SF2")
	Replace F2_TIPODOC  With "07"
	If lUsaNewKey .AND. !empty(cPref)
		Replace F2_PREFIXO	With cPref
	Else
		Replace F2_PREFIXO	With F2_SERIE
	Endif
	Replace F2_HAWB		With cHawb
	MsUnLock()

	For nI := 1 To Len(aAutoItens)
		RecLock("SD2",.T.)
		For nJ := 1 To Len(aAutoItens[nI])
			SD2->(FieldPut(FieldPos(AllTrim(aAutoItens[nI][nJ][1])),aAutoItens[nI][nJ][2]))
		Next nJ
		Replace D2_FILIAL With cFilSD2

		SB1->(DbSetOrder(1))
		SB1->(MsSeek(cFilSB1+SD2->D2_COD))

		AADD(aTes,SD2->D2_TES)

		Replace D2_ITEM		With StrZero(nI,Len(D2_ITEM))
		Replace D2_TIPO		With SF2->F2_TIPO
		Replace D2_FORMUL	With SF2->F2_FORMUL
		Replace D2_ESPECIE	With SF2->F2_ESPECIE
		Replace D2_TIPODOC	With "07"
		Replace D2_NUMSEQ	With ProxNum()
		Replace D2_UM		With SB1->B1_UM
		Replace D2_EST		With SF2->F2_EST
		MsUnLock()
	Next nI

	For nI := 1 To Len(aTes)
		SF4->(DbSetOrder(1))
		SF4->(MsSeek(cFilSF4+aTes[nI]))
		lDupl := If(SF4->F4_DUPLIC=="S",.T.,.F.)
		If lDupl
			nI := Len(aTes)
		EndIf
	Next nI
	//³ Quando impostos variaveis acrescentar o Array de impostos Variaveis ³
	If SuperGetMV("MV_EASYFIN") == "N" .AND. lDupl
		nValDup := ValDuplic(nValDup)
		aVenc := Condicao(nValDup,cCond,0.00,dDataBase,0.00)
		nDup  := Len(aVenc)

		DbSelectArea("SE1")
		For nI := 1 To nDup

			//³ VerIfica moeda para deducao do arredondamento     ³

			nValor := aVenc[nI][2]

			If nDup == 1
				cParcela := " "
			EndIf

			DbSelectArea("SA2")
			DbSetOrder(1)
			MsSeek(cFilSA2+cFornece+cLoja)

			DbSelectArea("SE2")
			RecLock("SE2",.T.)
			Replace	E2_FILIAL  With cFilSE2
			If lUsaNewKey .AND. !empty(cPref)
				Replace E2_PREFIXO With cPref
			Else
				Replace E2_PREFIXO With cSerie
			Endif
			Replace E2_EMISSAO With dDataBase
			Replace E2_EMIS1   With dDataBase
			Replace	E2_FORNECE With SA2->A2_COD
			Replace	E2_LOJA    With SA2->A2_LOJA
			Replace	E2_NOMFOR  With SA2->A2_NREDUZ
			Replace	E2_TIPO    With "NCP"
			Replace E2_MOEDA   With SF2->F2_MOEDA
			Replace	E2_LA      With "S"
			Replace E2_NUM     With cNFiscal
			Replace	E2_PARCELA With cParcela
			Replace	E2_VENCORI With aVenc[nI][1]
			Replace	E2_VENCTO  With aVenc[nI][1]
			Replace	E2_VENCREA With DataValida(aVenc[nI][1])
			Replace	E2_VALOR   With nValor
			Replace	E2_SALDO   With nValor
			Replace	E2_NATUREZ With SF2->F2_NATUREZ
			Replace	E2_ORIGEM  With "MATA466N"
			If cPaisLoc=="PER"
				Iif(!empty(SF2->F2_SERORI),SerieNfid("SE2",1,"E2_SERORI",,,,SF2->F2_SERORI),) //Projeto Chave Unica - Tiago Silva
	      	EndIf
			A050DupPag("MATA466",(nI==1),0)
			Replace E2_VLCRUZ  With Round(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,,SF2->F2_TXMOEDA),MsDecimais(SF2->F2_TXMOEDA))
		Next nI
    EndIf

	lQtdZero  := .T.
	aCusto    := {}
	aCM       := {}
	cTesEIC   := ""
	nTxCusEIC := 0.00
	aImposto  := {}
	nPosSWN   := 0

	DbSelectArea("SWN")
	DbSetOrder(2)
	If DbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
	   While !Eof() .AND.;
			WN_FILIAL == cFilSWN .AND.;
	   		WN_DOC == SF2->F2_DOC .AND.;
	   		WN_SERIE == SF2->F2_SERIE

			SB1->(DbSetOrder(1))
			SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))

	   		If WN_TIPO_NF == "N"

		   		RecLock("SWN",.F.)
		   		Replace WN_NUMSEQ	With ProxNum()
		   		MsUnLock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Gravar no SD3 a 'DE8' para o Produto  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				RecLock('SD3',.T.)
				Replace D3_FILIAL  With cFilSD3
				Replace D3_COD	   With SWN->WN_PRODUTO
				Replace D3_GRUPO   With SB1->B1_GRUPO
				Replace D3_TIPO    With SB1->B1_TIPO
				Replace D3_LOCAL   With SWN->WN_LOCAL
				Replace D3_UM	   With SB1->B1_UM
				Replace D3_CONTA   With SB1->B1_CONTA
				Replace D3_DOC	   With SWN->WN_DOC
				Replace D3_QUANT   With 0.00
				Replace D3_CF	   With 'DE8' 	//-- Identifica Movimentacao com Origem no SIGAEIC
				Replace D3_TM	   With '999'
				Replace D3_USUARIO With SubStr(cUsuario,7,15)
				Replace D3_NUMSEQ  With SWN->WN_NUMSEQ
				Replace D3_EMISSAO With dDataBase
				Replace D3_CHAVE   With 'E9' 	//-- N„o Alterar !!!
				Replace D3_QTSEGUM With SWN->WN_QTSEGUM
				Replace D3_SEGUM   With SB1->B1_SEGUM
				Replace D3_IDENT   With ""		//cNumSeqD1  //-- Diferencia as Movimentacoes
				Replace D3_DOCSWN  With SWN->WN_PO_NUM
				Replace D3_ITEMSWN With SWN->WN_ITEM

				MsUnLock()

        	    aCusto := {SWN->WN_VALOR,0,0,0,0}

				//³ Pegar taxa das despesas para custeos em outras moedas.     ³

				SWD->(DbSetOrder(3))
       			If SWD->(MsSeek(cFilSWD+SWN->WN_CODESP+SWN->WN_DOC+SWN->WN_HAWB))
				   nTxCusEIC := SWD->WD_TX_MOE
     			EndIf

				aCM := AClone(aCusto)

				For nI := 1 To Len(aCusto)
					cMoeda := Str(nI,1)
					If nI > 1 .AND. !Empty(GetMV("MV_MOEDA"+cMoeda))
					    If Empty(nTxCusEic)
					    	nTxCusEic := RecMoeda(dDataBase,nI)
					    EndIf
					    aCM[nI] := aCM[1]/nTxCusEic
					EndIf
				Next nI

				aCusto := GravaCusD3(aCM,,,,lQtdZero)
				B2AtuComD3(aCusto,NIL,NIL,NIL,NIL,.T.)
			EndIf
		   	DbSelectArea("SWN")
			DbSkip()
		End
	EndIf
EndIf

If nOpc == 5	//Apagar
	lQtdZero  := .T.
	aCusto    := {}
	aCM       := {}
	cTesEIC   := ""
	nTxCusEIC := 0.00
	aImposto  := {}
	nPosSWN   := 0

	DbSelectArea("SF2")
	DbSetOrder(1)
	MsSeek(xFilial("SF2")+cNFiscal+cSerie+cFornece+cLoja)
	If !Found()
		MsgStop("Nota de Credito no existe!!!","Atencion")
		Return(.F.)
	EndIf

 	DbSelectArea("SWN")
	DbSetOrder(2)
	If DbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
		While !Eof() .AND.;
			WN_FILIAL == cFilSWN .AND.;
		   	WN_DOC == SF2->F2_DOC .AND.;
		   	WN_SERIE == SF2->F2_SERIE

		   	SB1->(DbSetOrder(1))
 			SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))

		   	SD2->(DbSetOrder(1))
 			SD2->(DbSeek(cFilSD2+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA))

 			If WN_TIPO_NF == "N"

				//³ Gravar no SD3 a 'DE8' para o Produto ³

				RecLock('SD3',.T.)
				Replace D3_FILIAL  With cFilSD3
				Replace D3_COD	   With SWN->WN_PRODUTO
				Replace D3_GRUPO   With SB1->B1_GRUPO
				Replace D3_TIPO    With SB1->B1_TIPO
				Replace D3_LOCAL   With SWN->WN_LOCAL
				Replace D3_UM	   With SB1->B1_UM
				Replace D3_CONTA   With SB1->B1_CONTA
				Replace D3_DOC	   With SWN->WN_DOC
				Replace D3_QUANT   With 0.00
				Replace D3_CF	   With 'RE8' 	//-- Identifica Movimentacao com Origem no SIGAEIC
				Replace D3_TM	   With '499'
				Replace D3_USUARIO With SubStr(cUsuario,7,15)
				Replace D3_NUMSEQ  With SWN->WN_NUMSEQ
				Replace D3_EMISSAO With SD2->D2_EMISSAO
				Replace D3_CHAVE   With 'E9' 	//-- N„o Alterar !!!
				Replace D3_SEGUM   With SB1->B1_SEGUM
				Replace D3_IDENT   With ""		//cNumSeqD1  //-- Diferencia as Movimentacoes
				Replace D3_EMISSAO With dDataBase
				MsUnlock()

			    aCusto := {SWN->WN_VALOR,0,0,0,0}

				//³ Pegar taxa das despesas para custeos em outras moedas.     ³

				SWD->(DbSetOrder(3))
       			If SWD->(MsSeek(cFilSWD+SWN->WN_CODESP+SWN->WN_DOC+SWN->WN_HAWB))
					nTxCusEIC := SWD->WD_TX_MOE
     			EndIf

				aCM := AClone(aCusto)

				For nI := 1 To Len(aCusto)
					cMoeda := Str(nI,1)
					If nI > 1 .AND. !Empty(GetMV("MV_MOEDA"+cMoeda))
					    If Empty(nTxCusEic)
					    	nTxCusEic := RecMoeda(dDataBase,nI)
					    EndIf
					    aCM[nI] := aCM[1]/nTxCusEic
					EndIf
				Next nI

				aCusto := GravaCusD3(aCM,,,,lQtdZero)

				B2AtuComD3(aCusto,NIL,NIL,NIL,NIL,.T.)

			EndIf
			DbSelectArea("SWN")
			DbSkip()
		End
	EndIf

	DbSelectArea("SWN")
	DbSetOrder(1)
	If DbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
		While !Eof() .AND.;
			WN_FILIAL == cFilSWN .AND.;
		   	WN_DOC == SF2->F2_DOC .AND.;
		   	WN_SERIE == SF2->F2_SERIE

			If WN_TIPO_NF == "N"
				DbSelectArea("SD3")
				If MsSeek(cFilSD3+SWN->WN_DOC+SWN->WN_PRODUTO)
					RecLock('SD3',.F.)
					Replace D3_ESTORNO	With "S"
					MsUnlock()
				EndIf
			EndIf
	   		DbSelectArea("SWN")
			DbSkip()
		End
	EndIf

	If SuperGetMV("MV_EASYFIN") == "N"
		DbSelectArea("SE2")
		DbSetOrder(1)
		DbSeek(xFilial("SE2")+SF2->F2_SERIE+SF2->F2_DOC)
		While !Eof() .AND. E2_PREFIXO == SF2->F2_SERIE .AND.;
			E2_NUM == SF2->F2_DOC

			If E2_FORNECE == SF2->F2_CLIENTE .AND. E2_LOJA == SF2->F2_LOJA
				RecLock("SE2",.F.)
				DbDelete()
				MsUnLock()
			EndIf
			DbSkip()
		End
	EndIf

	DbSelectArea("SD2")
    DbSetOrder(3)
    DbSeek(xFilial("SD2")+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA)
    While ! Eof() .AND.;
    	D2_DOC     == SF2->F2_DOC     .AND.;
    	D2_SERIE   == SF2->F2_SERIE   .AND.;
    	D2_CLIENTE == SF2->F2_CLIENTE .AND.;
    	D2_LOJA    == SF2->F2_LOJA
    	RecLock("SD2",.F.)
    	DbDelete()
    	MsUnLock()
    	DbSkip()
    End

	DbSelectArea("SF2")
	RecLock("SF2",.F.)
	DbDelete()
	MsUnLock()
EndIf
Return
/*
±±³Funcao    ³ SetSX7Total ³±±
±±³Descri‡…o ³ Devolver array com todos gatilhos que afetam o conteudo dos³±±
±±³          ³ campos de Totais (D1_TOTAL ou D2_TOTAL)...                 ³±±
±±³Sintaxe   ³ ExpA1 := SetSX7Total()                                     ³±±
*/
Static Function SetSX7Total()
LOCAL aCpos := {}
LOCAL cPrefixoCpo := PrefixoCpo(aCfgNf[SAliasCols])

SX3->(DbSetOrder(2))
SX7->(DbSetOrder(1))
SX7->(DbSeek(cPrefixoCpo))
While !SX7->(Eof()) .AND. Substr(SX7->X7_CAMPO,1,2) == cPrefixoCpo
	IF SX3->(MSSEEK(SX7->X7_CDOMIN)).AND. 'MAFISREF'$UPPER(SX3->X3_VALID)
        Aadd(aCpos,{Alltrim("M->"+SX7->X7_CAMPO),Alltrim(SX7->X7_CDOMIN)})
	Endif
    SX7->(DbSkip())
End
Return  aCpos

/*
±±³Funcao    ³LocxValNum() ³±±
±±³Descri‡…o ³ Validacao para verificar a existencia da nf no momento da 	 ³±±
±±³          ³ digitacao doc campos de numero /Serie                   	 	 ³±±
*/
Function LocxValNum()
Local aArea     := GetArea()
Local Alias 	:= aCfgNF[SAliasHead]
Local cSerieNF	:= M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE")
Local cNumNota	:= M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_DOC")
Local cCliForn	:= If (Alias== "SF2" ,M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_CLIENTE"),M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_FORNECE") )
Local cLoj 		:= M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA")
Local cEspec    := M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_ESPECIE")
Local dEmiss	:= M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_EMISSAO")
Local lExist	:= .F.
Local lReturn 	:= .T.
//Local lExisteFin:= .F.
Local cSerieOri:=cSerieNF
Local lVarSer2	:= (Type("M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2") == "C")
Local lSer2     := (((SF2->(FieldPos("F2_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (cEspec$"NCE|NCP")) .or. (cPaisLoc == "COL" .and. Alias == "SF2" .And. lVarSer2) ); // Determina o uso do campo F2_SERIE2 para o Peru
				.Or. ((SF1->(FieldPos("F1_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (Trim(cEspec)$"NF|NDP|NDE") .And. !aCfgNf[SlFormProp])
Local lJaexistD := .F.
Local nLenSerie := TamSX3("F1_SERIE")[1]
Local nLenSerNF := 0
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local nTamSer	:= TamSX3(SerieNfId("SF1",3,"F1_SERIE"))[1]
Local lDocSop	:= .F.

If cPaisLoc == "COL" .And. ( (Type("lDocSp") == "L" .And. lDocSp) .Or. aCfgNF[1] == 22 .Or. aCfgNF[1] == 23) .And. ((cFunName $ "MATA101N|MATA466N") .Or. ChkProp("DocumentoSoporte"))
	// COL: Documento soporte (NF Entrada) y Notas de ajuste (NDP/NCP) tienen asignación de consecutivo por el sistema
	lDocSop := .T.
EndIf

If lSer2 .And.  !Empty( M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2") )
	If cPaisLoc == "COL"
		cSerieNF := M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2")
	Else
		If TamSX3(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2")[1] == TamSX3(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE")[1];
			.OR. Len(M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2")) == TamSX3(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE")[1]
			cSerieNF := M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2")
		EndIf
	EndIf
EndIf

If lUsaNewKey
	cSerieNF:= SerieNfId(aCfgNF[SAliasHead],4,PrefixoCpo(aCfgNF[SAliasHead])+"_SERIE",dEmiss,cEspec,cSerieNF)
Endif

nLenSerNF := If(cPaisLoc=="ARG", Len(Trim(cSerieNF)), nLenSerie)
If !l103Class
	If !aCfgNf[SlFormProp]
		lExist := !aNumNaoExiste(Alias,cSerieNF,cNumNota,cCliForn,cLoj,cEspec,IIf(lDocSop,"DCS",Nil))
		If Alias== "SF2" .And. lExist
		    AliasSF2:=SF2->(GetArea())
		    SF2->(DbSetOrder(1))
		    lJaexist:=.F.

		    If SF2->(DbSeek(xFilial("SF2")+cNumNota+cSerieNF+cCliForn+cLoj) )
		    	While !Eof() .And. (xFilial("SF2")+cNumNota+cSerieNF+cCliForn+cLoj) ==(SF2->F2_FILIAL+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA)
		    		If Alltrim(SF2->F2_ESPECIE)==Alltrim(cEspec)
		    		    	lJaexistD:=.T.
		    		EndIf
		    		SF2->(DbSkip())
		    	EndDo
		    	If Eof() .And. Alltrim(SF2->F2_ESPECIE)==Alltrim(cEspec)
		  		  	lJaexistD:=.T.
		    	EndIf
		    EndIf
		    SF2->(RestArea( AliasSF2))

		ElseIf Alias== "SF1" .And. lExist
			AliasSF1:=SF1->(GetArea())
		    SF1->(DbSetOrder(1))
		    lJaexistD:=.F.
		    If SF1->(DbSeek(xFilial("SF1")+cNumNota+cSerieNF+cCliForn+cLoj) )
		    	While !Eof() .And. (xFilial("SF1")+cNumNota+cSerieNF+cCliForn+cLoj) ==(SF1->F1_FILIAL+SF1->F1_DOC+PadR(Substr(SF1->F1_SERIE,1,nLenSerNF),nLenSerie)+SF1->F1_FORNECE+SF1->F1_LOJA)
		    		If Alltrim(SF1->F1_ESPECIE)==Alltrim(cEspec)
		    		    lJaexistD:=.T.
		    		EndIf
		    		SF1->(DbSkip())
		    	EndDo
		    	If Eof() .And. Alltrim(SF1->F1_ESPECIE)==Alltrim(cEspec)
		  		  	lJaexistD:=.T.
		    	EndIf
		    EndIf
		    SF1->(RestArea( AliasSF1))
		EndIf

		If lExist .And. !lJaexistD
    		IF !(type("cEspecie") <> "U") .and. IsInCallStack("FINA096")
    			cEspecie := CEspec
    		EndIF
			If !lDocSop
				cSerieNF:= Subs((Alltrim(cSerieNF)+cEspecie),1,TamSX3("F1_SERIE")[1])
				cSerie:=cSerieNF
			Else
				cNumNota := Soma1(cNumNota)
			EndIf
			While lExist
				lExist    :=!aNumNaoExiste(Alias,cSerieNF,cNumNota,cCliForn,cLoj,cEspec,IIf(lDocSop,"DCS",Nil),nLenSerNF)
				If  lExist
					If !lDocSop
						cSerieNF := Soma1(cSerieNF)
						cSerie:=cSerieNF
					Else
						cNumNota := Soma1(cNumNota)
					EndIf
				EndIf
			EndDo
			If lDocSop
				M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_DOC") := cNumNota
			EndIf
		EndIf
	Else
		lExist := .F.
	Endif
	If  lExist
	   Aviso(STR0018,STR0092+"("+ Iif(cPaisLoc $ "PAR|URU|ARG|CHI" .Or. lDocSop,cNumNota,cnFiscal)+" / "+cSerie+") " +STR0068 ,{STR0021}) //"ATENCAO"###"Documento no."### "ja existe "###"OK"
	   lReturn 	:= .F.
	EndIf
	If  !lReturn .And. lDocSop .And. cFunName $ "MATA101N|MATA466N" .And. ReadVar() $ "M->F1_SERIE|M->F1_DOC"
		lReturn := .T. //si el número doc existe, se retorna .T. para que permita salir del campo F1_SERIE y permita modificar el número Doc F1_DOC
	EndIF
	If lReturn .AND. cPaisLoc == "GUA"
       //³Valida se o numero esta homologado pela SAT         ³
       lReturn  := LocxNumSAT(cSerieNF,cNumNota)
    EndIf
EndIf
RestArea( aArea )

If lReturn .AND. !Empty(cNumNota)
	If lSer2 .And. !Empty( M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2") )
		cSerieOri :=  M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2")
	EndIf

	If cPaisLoc=="PER"
		M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERORI")    :=  cSerieOri
	EndIf

	If padr(subStr(cSerieNF,1,nTamSer),nTamSer," ")<>padr(subStr(cSerieOri,1,nTamSer),nTamSer," ")
		M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE"):=cSerieNF
		If cPaisLoc <> "PER"
			MsgAlert(StrTran(STR0432, '###', cSerieOri) + cSerieNF) //"La Serie Original fue alterada de: ### para: "
		EndIf
		MaFisAlt("NF_SERIENF",cSerieNF)
	EndIf
EndIf

Return (lReturn)
/*
±±ºPrograma  ³LocxFormP º±±
±±ºDesc.     ³Determina se a factur ou nota foi impressa em formulario    º±±
±±º          ³proprio.                                                    º±±
*/
Function LocxFormP(cEspecie,cTipoMov,cTES,cFormul)
Local lRet := .F.

If Empty(cFormul)
	//Determina a especie da Factura ou Nota...
	cEspecie := GetSesNew(AllTrim(cEspecie),Iif(cTES >= "500","1","2"))

	If (cEspecie$"NCI|NDI|NCC|NDC|CF") .OR. (cTipoMov == "V" .AND. cEspecie == "NF")
		lRet := .T.
	EndIf
Else
	lRet := (AllTrim(cFormul) == "S")
EndIf
Return(lRet)
/*
±±³Fun‡…o    ³LocxDelRem³ ³±±
±±³Descri‡…o ³ Estornar as movimentacoes Internas-SD3 ou Remitos gerados  ³±±
±±³          ³ pelas Notas Fiscais de Importacao.                         ³±±
±±³ Uso      ³ MATA101N (Integracao com Modulo de Importacao)             ³±±
*/
Function LxApagaREM(lMostraCtb,lAglCtb,lContab,lCarteira,lTela,lPerg,lRSAuto,aRecImp,cFunName)
//Local aArea        := GetArea()
//Local lRet         := .T.
//Local lOutrasNF    := .F.
Local aAreaSF1     := {}
Local aAreaSD1     := {}
Local aTES         := {}
//Local aCusto       := {}
//Local aImpostos    := {}
//Local aCustoRem    := {}
Local aRemito      := {}
Local aRemitos     := {}
Local aMoeda       := {}
Local aRecImpSF1   := {}
Local aRecImpSD1   := {}
//Local aAreaSalva   := {}

Local nPosTes      := 0
//Local nPosSWN      := 0
Local nTxCusEIC    := 0
Local nMoedaOrig   := 0
Local nX           := 0
//Local nI           := 0
Local nValImpX     := 0
//Local nTotal       := 0
Local nTotalLcto   := 0
Local nHdlPrv      := 0

Local cNumRemito   := ""
Local cSerRemito   := ""
//Local cLote		   := ""
Local cArquivo	   := ""
Local cCampo       := ""
//Local cCodDespesa  := ""
Local cSeek        := ""

//Local nQuantTmp, nQtSegUMTmp
Local nY //nE,

Local cDoc         := SF1->F1_DOC
Local cFornece     := SF1->F1_FORNECE
Local cLoja        := SF1->F1_LOJA
Local cTipo        := SF1->F1_TIPO
Local cFornDes     := SF1->F1_FORNECE
Local cLojaDes     := SF1->F1_LOJA
Local cNFiscalDes  := SF1->F1_DOC
Local cSerieDes    := SF1->F1_SERIE
Local cSerie       := SF1->F1_SERIE
Local cTipoNF      := SF1->F1_TIPO_NF
//Local cHawb		   := SF1->F1_HAWB

Local cTesDespacho := CriaVar("F4_CODIGO")
Local lMovtaSD3    := GetNewPar("MV_CUSTIMP","1") == "1"
//Local nPosAColsTes := AScan(aHeader,{|x| Upper(Alltrim(x[2]))$"D1_TES"})
Local cLoteCom     := IIf(Found(),Trim(X5DESCRI()),"COM ")
Local dDtValid	   := Nil
Local lVerPad695:= VerPadrao('695')//Exclusão dos Itens da Nota Entrada
Local lVerPad687:= VerPadrao('687')//Exclusão Total da Nota Entrada
Local lVerPad697:= VerPadrao('697')//Exclusão dos Itens da Nota Debito
Local lVerPad689:= VerPadrao('689')//Exclusão Total da Nota Entrada
Local lVerPad698:= VerPadrao('698')//Exclusão dos Itens da Remito Entrada
Local lVerPad690:= VerPadrao('690')//Exclusão Total da Remito Entrada
Local lVerPad655   := VerPadrao('655')
Local lVerPad665   := VerPadrao('665')
Local aCtbDia	   := {}
Local dDataTaxa

Local cFilSB1	:= xFilial("SB1")
Local cFilSB2	:= xFilial("SB2")
Local cFilSB8	:= xFilial("SB8")
Local cFilSD1	:= xFilial("SD1")
Local cFilSF1	:= xFilial("SF1")
Local cFilSF3	:= xFilial("SF3")
Local cFilSF4	:= xFilial("SF4")
Local cFilSYD	:= xFilial("SYD")
Local cFilSW6	:= xFilial("SW6")
Local cFilSW9	:= xFilial("SW9")
Local cFilSWN	:= xFilial("SWN")
Local cFilSWD	:= xFilial("SWD")
Local lB2AtuUnif	:= .T.
Local lWN_TES := .F.
Local lWN_ITEMNF	:= .F.
Local lWN_DESPSUB := .F.
Local lWN_LOCAL	:= .F.
Local nT_ITEM	:= TamSX3("D1_ITEM")[1]

Private lUsaCor    :=.F.

Default cFunName := Funname()

aRecImp	 :=	{}

//Utilizacao do numero correlativo de compras
lUsaCor   :=.F.
lUsaCor   :=CORR_USO()
lUsaCor   :=lUsaCor .AND. Strzero(aCfgNF[SnTipo],2)$"07|09|10|12|13|14"  //ncp|ndp|nf|benef|import|frete
lGeraLanc :=.F.

//³ Inicializa o cabecalho dos lanç. Contabeis OnLine ³

If ( lContab .AND. (!__TTSinUse .Or. cPaisLoc $ "PTG|RUS|"))
	lContab := .T.
	dbSelectArea("SX5")
	MsSeek(xFilial("SX5")+"09COM")
	cLoteCom:=IIf(Found(),Trim(X5DESCRI()),"COM ")
	nHdlPrv:=HeadProva(cLoteCom,"MATA103",Subs(cUsuario,7,6),@cArquivo)
	If nHdlPrv <= 0
		HELP(" ",1,"A100NOPRV")
		lContab := .F.
	EndIf
EndIf

Begin Transaction

If lMovtaSD3	//Estornar Movimentacoes de SD3
	If SF1->F1_TIPO_NF != "5"
		DbSelectArea("SWN")
		DbSetOrder(2)
		If DbSeek(cFilSWN+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
			lWN_LOCAL := .T.
			While !EOF() .AND. WN_FILIAL==cFilSWN .AND.;
				WN_DOC==SF1->F1_DOC .AND. WN_SERIE == SF1->F1_SERIE .AND.;
				WN_FORNECE==SF1->F1_FORNECE .AND. WN_LOJA == SF1->F1_LOJA
				If lWN_LOCAL
					MSGravaD3(WN_PRODUTO,subs(WN_PO_NUM,1,6),WN_ITEM,WN_QUANT,,.T.,WN_LOTECTL,WN_DTVALID,WN_QTSEGUM,WN_SEGUM,WN_LOCAL)
				Else
					MSGravaD3(WN_PRODUTO,subs(WN_PO_NUM,1,6),WN_ITEM,WN_QUANT,,.T.,WN_LOTECTL,WN_DTVALID,WN_QTSEGUM,WN_SEGUM)
				EndIf
				AAdd(aRecIMP,{SD3->(RECNO()),SWN->(RECNO())})
				DbSelectArea("SWN")
				DbSkip()
			End
		EndIf
	EndIf
	LibFatImp(.T.)

Else //Estornar ou apagar Remitos gerados pelas Class. NF de import.

	aAreaSF1 := SF1->(GetArea())
	aAreaSD1 := SD1->(GetArea())

	If GetMv('MV_FLTD1D2')
		SF1->(DbClearFilter())
	Endif

	SB2->(DbSetOrder(1))
	DbSelectArea("SWN")
	DbSetOrder(1)
	DbSeek(cFilSWN+cDoc+cSerie)
	cTipoNF := SWN->WN_TIPO_NF
	//Se eh FOB so tem um remito por nota e este deve ser gravado no cabecalho
	If cTipoNf  == '5'
		aRemito		:= LocxNrReIm(SWN->WN_HAWB,Substr(SWN->WN_INVOICE,1,Len(SF1->F1_DOC))) //Buscar o remito da invoice
		cSerRemito	:= aRemito[1]
		cNumRemito	:= aRemito[2]
		cFornece	:= If(Empty(aRemito[3]),SF1->F1_FORNECE,aRemito[3])
		cLoja		:= If(Empty(aRemito[4]),SF1->F1_LOJA,aRemito[4])
	EndIf

	nItem   := 0
	cInvAnt	:=	''
	lWN_TES := cPaisLoc == "ARG"
	lWN_ITEMNF := cPaisLoc == "ARG"
	lWN_DESPSUB := cPaisLoc $ "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
	//³ Grava Remitos para registrar Ingresos e Custos para NF de Importacao ³
	While !Eof() .And. WN_FILIAL==cFilSWN .And. WN_DOC==cDoc .And. WN_SERIE==cSerie
		AAdd(aRecIMP,{0,SWN->(RECNO())})
		If cTipoNf <> '5'
			If cInvAnt <> SWN->WN_INVOICE
				aRemito	   := LocxNrReIm(SWN->WN_HAWB,Substr(SWN->WN_INVOICE,1,Len(SF1->F1_DOC))) //Buscar o remito da invoice
				cSerRemito := aRemito[1]
				cNumRemito := aRemito[2]
				cFornece   := If(Empty(aRemito[3]),SF1->F1_FORNECE,aRemito[3])
				cLoja      := If(Empty(aRemito[4]),SF1->F1_LOJA,aRemito[4])
				cInvAnt	   := SWN->WN_INVOICE
			EndIf
		EndIf

		If lWN_DESPSUB
			nValorCus := Round(SWN->WN_VALOR-SWN->WN_DESPSUB,2)
		Else
			nValorCus := SWN->WN_VALOR
		EndIf
		If nValorCus > 0.00

	    	SB1->(DbSetOrder(1))
    		SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))
	    	SW6->(DbSetOrder(1))
    		SW6->(MsSeek(cFilSW6+SWN->WN_HAWB))
	    	SW9->(DbSetOrder(1))
    		SW9->(DbSeek(cFilSW9+SWN->WN_INVOICE+SWN->WN_FORNECE))
			//³ Posicionar os arquivos TES e PRODUTOS  ³
			aTES         := {}
			cTesDespacho := Space(3)

			//³ Devido a gravacao das notas serem diferentes, o SWN sempre      |
			//³ mostrara os dados do produto importado e nas notas tipo 9/A as  |
			//| despesas usarao seu proprio TES (D1_TESDES).                    |

			If SWN->WN_TIPO_NF $ "5678"
				If lWN_TES
					AADD(aTes,SWN->WN_TES)
				Else
					SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))
					AADD(aTes,SYD->YD_TES)
				EndIf
			Else
    			DbSelectArea("SD1")
				DbSetOrder(2)
				DbSeek(cFilSD1+SWN->WN_PRODUTO+cNFiscalDes+cSerieDes+cFornDes+cLojaDes)
              	nPosTes := Ascan(aTes,SD1->D1_TESDES)
               	If nPosTes == 0
   					AADD(aTes,SD1->D1_TESDES)
   				EndIf
  			EndIf

			DbSelectArea("SWN")

			//-- Posiciona TES
			SF4->(MsSeek(cFilSF4+aTes[1]))

        	//-- Posiciona Despesas/Gastos da import.
        	SWD->(DbSetOrder(1))
            SWD->(DbSeek(cSeek:=cFilSWD+SWN->WN_HAWB))
			Do While SWD->(!Eof()) .AND. cSeek == SWD->WD_FILIAL+SWD->WD_HAWB
			    If SWD->WD_DOCTO == SWN->WN_DOC .AND. SWD->WD_SE_DOC == SWN->WN_SERIE
			    	Exit
			    EndIf
				SWD->(dbSkip())
			EndDo

   			SW6->(DbSetOrder(1))
   			SW6->(MsSeek(cFilSW6+SWN->WN_HAWB))

			DbSelectArea("SF1")
			DbSetOrder(1)
			MsSeek(cFilSF1+cNumRemito+cSerRemito+cFornece+cLoja)

			If Found()

				AADD(aRemitos,{SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE+SF1->F1_LOJA,SWN->WN_TIPO_NF})

				cItemRem:=StrZero(nItem,nT_ITEM)
				If lWN_ITEMNF
					DbSelectArea("SD1")
					DbSetOrder(1)
					MsSeek(cFilSD1+cNumRemito+cSerRemito+cFornece+cLoja+SWN->WN_PRODUTO+SWN->WN_ITEMNF)
				Else
					DbSelectArea('SD1')
					DbSetOrder(2)
					MsSeek(cFilSD1+SWN->WN_PRODUTO+cNumRemito+cSerRemito+cFornece+cLoja)
			   	EndIf

 				If SD1->(Found())

					If SWN->WN_TIPO_NF == "9" .OR. SWN->WN_TIPO_NF == "A"	//Nota de Despesas do Despachante ou Nota Complentar de Custos

						//³ Pegar a taxa da Moeda do cabealho da fatura de import.  na tabela  ³
						//³ para pegar la moneda, tasa y TES.                                  ³

						nTxCusEIC  := SWD->WD_TX_MOE
						dDataTaxa  := If( Empty(SWD->WD_DT_EMIS), SWD->WD_DES_ADI, SWD->WD_DT_EMIS )
						nMoedaOrig := SimbToMoeda(SWD->WD_MOEDA)
						nMoedaOrig := If(nMoedaOrig>0,nMoedaOrig,1)

						//³ Gravar D1_TOTAL y D1_CUSTO ya convertido ³

						If nTxCusEIC == 0
							nTxCusEIC := 1
						EndIf

	        		    //³ Pesquisa TES do cadastro de NCM  ³

						SYD->(dbSetOrder(1))
						SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))

						If lWN_TES .And. !Empty(SWN->WN_TES)
							nValImpX  := LxSomaImp(SWN->WN_TES)
						Else
							nValImpX  := LxSomaImp(IIf(Found(),SYD->YD_TES,SD1->D1_TES))
						EndIf

						RecLock( 'SD1', .F. )
	    				Replace D1_TOTAL With D1_TOTAL - (SWN->WN_DESPESA+nValImpX)
	    				Replace D1_VUNIT With D1_TOTAL/D1_QUANT
    					Replace D1_CUSTO With D1_CUSTO - (SWN->WN_DESPESA+nValImpX)

            			//³ Grava custo em moeda 2,3,4 y 5. ³

						aMoeda := {"","","","",""}
						For nY := 2 To 5
							cCampo := "SD1->D1_CUSTO"+Str(nY,1,0)
							If nMoedaOrig = nY
								Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
					        Else
								aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
								Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
				    		EndIf
					    Next nY
						SD1->(MsUnLock())

						//³ Atualizar Saldos Fisico e Financeiro |

						If SB2->(MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL))
			    	    	RecLock("SB2",.F.)
							Replace B2_VATU1 	With B2_VATU1 - xMoeda(SWN->WN_VALOR + nValImpX,1,1,SF1->F1_EMISSAO,,,nTxCusEIC)
							aMoeda := {"","","","",""}
							For nY := 2 To 5
								cCampo := "SB2->B2_VATU"+Str(nY,1,0)
								If nMoedaOrig = nY
									Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
						        Else
									aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
									Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
					    		EndIf
							Next nY
							SB2->(MsUnLock())
							If SB2->B2_QATU > 0
								Reclock("SB2",.F.)
								Replace SB2->B2_CM1	With SB2->B2_VATU1/SB2->B2_QATU
								Replace SB2->B2_CM2	With SB2->B2_VATU2/SB2->B2_QATU
								Replace SB2->B2_CM3	With SB2->B2_VATU3/SB2->B2_QATU
								Replace SB2->B2_CM4	With SB2->B2_VATU4/SB2->B2_QATU
								Replace SB2->B2_CM5	With SB2->B2_VATU5/SB2->B2_QATU
								SB2->(MsUnLock())
							EndIf

							//³Atualiza o custo unificado ON-LINE ³

							If lB2AtuUnif
								B2AtuUnif(SB2->B2_COD)
							EndIf
						EndIf

						//³ Acumular F1_VALMERC y F1_VALBRUT en SF1. |

						DbSelectArea('SF1')
						RecLock( 'SF1', .F. )
						Replace F1_VALMERC 	 With F1_VALMERC - ( SWN->WN_DESPESA+nValImpX )
						Replace F1_VALBRUT	 With F1_VALBRUT - ( SWN->WN_DESPESA+nValImpX )
						MsUnlock()

				ElseIf SWN->WN_TIPO_NF $ "5678" //FOB, Frete ou Seguro

						//³  Pegar Moeda e Taxa do arquivo de Processos ³

		            	If 	SWN->WN_TIPO_NF $ "5|8"     //FOB ou CIF
							cMoedaEIC := SW9->W9_MOE_FOB
							nTxCusEIC := SW9->W9_TX_FOB
							dDataTaxa := SW9->W9_DT_EMIS
						ElseIf SWN->WN_TIPO_NF $ "6"	//Frete
							cMoedaEIC := SW6->W6_FREMOED
							nTxCusEIC := SW6->W6_TX_FRET
							dDataTaxa := SW6->W6_DTREG_D
						ElseIf SWN->WN_TIPO_NF $ "7"    //Seguro
							cMoedaEIC := SW6->W6_SEGMOED
							nTxCusEIC := SW6->W6_TX_SEG
							dDataTaxa := SW6->W6_DTREG_D
						EndIf

						nMoedaOrig := SimbToMoeda(cMoedaEIC)
						nMoedaOrig := If(nMoedaOrig>0,nMoedaOrig,1)

						//³ Gera lanç contabil 655-695-697-698 Exclusao - Itens ³

						DbSelectArea("SD1")
						If lContab .AND. D1_TIPO_NF $ "7"
							If Ascan(aRecImpSD1,{|x| x[1] == SD1->(RECNO())})==0
								AAdd(aRecImpSD1,{RECNO()})

									If cFunName$"MATA101N" //Nota de Entrada
										If lVerPad695
											nTotalLcto	+= DetProva(nHdlPrv,'695','MATA103',cLoteCom)
										ElseIf lVerPad655
											nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
										EndIf
									EndIf
									If cFunName$"MATA466N" //Nota de Debito
										If lVerPad697
											nTotalLcto	+= DetProva(nHdlPrv,'697','MATA103',cLoteCom)
										ElseIf lVerPad655
											nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
										EndIf
									EndIf
									If cFunName$"MATA465N" //Nota de Credito
										If VerPadrao("68N")
											If !Empty(SF1->F1_DTLANC)
												nTotalLcto	+= DetProva(nHdlPrv,'68N','MATA103',cLoteCom)
											EndIf
										ElseIf lVerPad655
											If !Empty(SF1->F1_DTLANC)
												nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
											EndIf
										EndIf
									EndIf
									If cFunName$"MATA102N" //Remito de Entrada
										If lVerPad698
											nTotalLcto	+= DetProva(nHdlPrv,'698','MATA103',cLoteCom)
										ElseIf lVerPad655
											nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
										EndIf
									EndIf

							EndIf
						EndIf

						DbSelectArea("SD1")
						RecLock( 'SD1', .F. )
		    			Replace D1_TOTAL With D1_TOTAL - (SWN->WN_VALOR - SWN->WN_DESPSUB)
			    		Replace D1_VUNIT With D1_TOTAL/D1_QUANT
						Replace D1_CUSTO With D1_CUSTO - (SWN->WN_VALOR - SWN->WN_DESPSUB)

						aMoeda := {"","","","",""}
						For nY := 2 To 5
							cCampo := "SD1->D1_CUSTO"+Str(nY,1,0)
							If nMoedaOrig = nY
				        		Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
					        Else
								aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
			        			Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
				    		EndIf
					    Next nY
						SD1->(MsUnLock())

						//³ Atualizar Saldos Fisico e Financeiro |

						If SB2->(MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL))

							//³ Atualizar Saldos Fisico e Financeiro  |

							If SWN->WN_TIPO_NF $ "5|8"
								DbSelectArea("SB2")
			                    RecLock("SB2",.F.)
                		        Replace B2_QATU		With B2_QATU - SD1->D1_QUANT
								Replace B2_QTSEGUM	With B2_QTSEGUM - SD1->D1_QTSEGUM
								MsUnLock()

								//³ Armazenar dados para excluir o Remito |

								AADD(aRemitos,{SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA})


								//³ Estorna os Movimenta Lotes/Sub-Lotes/Localizacao Fisica ³

								If Rastro(SD1->D1_COD) .OR. Localiza(SD1->D1_COD)

									//³ Tratamento da gravacao do SD1 na Integridade Referencial ³

									SD1->(FkCommit())
									dDtValid	:= SD1->D1_DTVALID
									If !Empty(SD1->D1_LOTECTL)
										SB8->(DbSetOrder(3))
										If SB8->(MsSeek(cFilSB8+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL))
											dDtValid	:=	SB8->B8_DTVALID
										EndIf
									EndIf
									cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
								    MovLote("SD1",;					//1
											SD1->D1_COD,;			//2
											SD1->D1_LOCAL,;			//3
											If( cPaisLoc $ cAuxPaisl,SD1->D1_LOCALIZ,NIL),;	//4
											If( cPaisLoc $ cAuxPaisl,SD1->D1_NUMSERI,NIL),;	//5
											SD1->D1_LOTECTL,;		//6
											SD1->D1_NUMLOTE,;		//7
											SD1->D1_NUMSEQ,;		//8
											Soma1('5'+SubStr(SD1->D1_TES,2)),;         //9
											SD1->D1_FORNECE,;		//10
											SD1->D1_LOJA,;			//11
											SD1->D1_LOTEFOR,;		//12
											"RCN",;					//13
											SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD,;				//14
											SD1->D1_DOC,;			//15
											SD1->D1_SERIE,;			//16
											SD1->D1_OP,;			//17
											NIL,;					//18
											NIL,;					//19
											NIL,;					//20
											NIL,;					//21
											SD1->D1_QUANT,;			//22
											SD1->D1_QTSEGUM,;		//23
											SD1->D1_DTDIGIT,;		//24
											SD1->D1_DTVALID,;		//25
											NIL,;					//26
											NIL,;					//27
											Soma1('5'+SubStr(SD1->D1_TES,2))>"500",;   //28
											.T.,;					//29
											Soma1('5'+SubStr(SD1->D1_TES,2))<="500",; //30
											NIL,;					//31
											NIL,;					//32
											NIL,;					//33
											NIL,;					//34
											NIL,;					//35
											NIL,;					//36
											NIL,;					//37
											NIL,;					//38
											NIL,;					//39
											NIL,;					//40
											NIL,;					//41
											NIL,;					//42
											NIL,;					//43
											NIL,;					//44
											NIL,;					//45
											NIL,;					//46
											NIL,;					//47
											NIL,;					//48
											NIL,;					//49
											SD1->D1_POTENCI)		//50
									LogMov("SD1",,,,,,.T.,"SD1")
								EndIf
							EndIf
							RecLock("SB2",.F.)
    						Replace B2_VATU1	 	With B2_VATU1 - xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,1,SF1->F1_EMISSAO,,,nTxCusEIC)
							aMoeda := {"","","","",""}
							For nY := 2 To 5
								cCampo := "SB2->B2_VATU"+Str(nY,1,0)
								If nMoedaOrig = nY
						    	    Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
						        Else
									aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
						    	    Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],SF1->F1_EMISSAO,.T.,.F.))
					    		EndIf
						    Next nY
						    SB2->(MsUnLock())
						    If SB2->B2_QATU > 0
							    RecLock("SB2",.F.)
								Replace SB2->B2_CM1		With SB2->B2_VATU1/SB2->B2_QATU
								Replace SB2->B2_CM2		With SB2->B2_VATU2/SB2->B2_QATU
								Replace SB2->B2_CM3		With SB2->B2_VATU3/SB2->B2_QATU
								Replace SB2->B2_CM4		With SB2->B2_VATU4/SB2->B2_QATU
								Replace SB2->B2_CM5		With SB2->B2_VATU5/SB2->B2_QATU
								SB2->(MsUnLock())
							EndIf

							//³Atualiza o custo unificado ON-LINE ³

							If lB2AtuUnif
								B2AtuUnif(SB2->B2_COD)
							EndIf
						EndIf

						//³	Gera lanç contabil 665-687-689-690 Exclusao - Cabecalho ³

						DbSelectArea("SF1")
						If lContab .AND. F1_TIPO_NF $ "7"
							If Ascan(aRecImpSF1,{|x| x[1] == SF1->(RECNO())})==0
								AAdd(aRecImpSF1,{RECNO()})
								If cFunName$"MATA101N" //Nota de Entrada
									If lVerPad687
										nTotalLcto	+= DetProva(nHdlPrv,'687','MATA103',cLoteCom)
									ElseIf lVerPad665
										nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
									EndIf
								EndIf
								If cFunName$"MATA466N" //Nota de Debito
									If lVerPad689
										nTotalLcto	+= DetProva(nHdlPrv,'689','MATA103',cLoteCom)
									ElseIf lVerPad665
										nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
									EndIf
								EndIf
								If cFunName$"MATA465N" //Nota de Credito
									If VerPadrao("68F")
										If !Empty(SF1->F1_DTLANC)
											nTotalLcto	+= DetProva(nHdlPrv,'68N','MATA103',cLoteCom)
										EndIf
									ElseIf lVerPad655
										If !Empty(SF1->F1_DTLANC)
											nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
										EndIf
									EndIf
								EndIf
								If cFunName$"MATA102N" //Remito de Entrada
									If lVerPad690
										nTotalLcto	+= DetProva(nHdlPrv,'690','MATA103',cLoteCom)
									ElseIf lVerPad665
										nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
									EndIf
								EndIf
							EndIf
						EndIf

						//³ Acumular F1_VALMERC y F1_VALBRUT en SF1 |

						DbSelectArea("SF1")
						DbSetOrder(1)
						MsSeek(cFilSF1+cNumRemito+cSerRemito+cFornece+cLoja)
						If Found()
							DbSelectArea('SF1')
							RecLock( 'SF1', .F. )
							Replace F1_VALMERC 	With F1_VALMERC - (SWN->WN_VALOR - SWN->WN_DESPSUB)
							Replace F1_VALBRUT	With F1_VALBRUT - (SWN->WN_VALOR - SWN->WN_DESPSUB	)
							MsUnlock()
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		DbSelectArea("SWN")
		DbSkip()
	End

	If GetMv('MV_FLTD1D2')
		Eval( bFilBrw )
	EndIf

	//³gravacao dos lanç. Contabeis ³

	If lContab .AND. nHdlPrv > 0 .AND. nTotalLcto > 0
		RodaProva(nHdlPrv,nTotalLcto)
		If UsaSeqCor()
			aCtbDia := {{"SF1",SF1->(RECNO()),SF1->F1_DIACTB,"F1_NODIA","F1_DIACTB"}}
		Else
    		aCtbDia := {}
		EndIF
		lLctoOk	:= cA100Incl(cArquivo,nHdlPrv,3,cLoteCom,lMostraCtb,lAglCtb,,If(aCfgNf[SaPergs][SlCtbEmiss],&("SF1->"+PrefixoCpo("SF1")+"_EMISSAO"),dDataBase ),,,,aCtbDia)
	EndIf

	RestArea(aAreaSF1)
	RestArea(aAreaSD1)
EndIf
//³ Estornar ou apagar Livro Fiscal  ³

DbSelectArea("SF3")
DbSetOrder(4)
If DbSeek(cFilSF3+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_DOC+SF1->F1_SERIE)
	While !EOF() .AND. F3_FILIAL==cFilSF3 .AND.;
		F3_CLIEFOR==SF1->F1_FORNECE	.AND. F3_LOJA==SF1->F1_LOJA	.AND.;
		F3_NFISCAL==SF1->F1_DOC .AND. F3_SERIE == SF1->F1_SERIE
		RecLock("SF3",.F.)
		DbDelete()
		MsUnLock()
		DbSkip()
	End
EndIf

If SF1->F1_TIPO_NF $ "9"
	MaFisF3Eic(2)
EndIf

//³ Estornar ou apagar Livro Fiscal ³

DbSelectArea("SD1")
DbSetOrder(1)
If DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
	While !EOF() .AND. D1_FILIAL==cFilSD1 .AND.;
		D1_DOC==SF1->F1_DOC .AND. D1_SERIE == SF1->F1_SERIE .AND.;
		D1_FORNECE==SF1->F1_FORNECE	.AND. D1_LOJA==SF1->F1_LOJA
		//³ Estorna o pedido de compras ³
		LxA103SC7(2,.F.)
		//³ Estorna o Saldos de SB8, SD5 ³
		SF4->(DbSetOrder(1))
		SF4->(MsSeek(cFilSF4+SD1->D1_TES))

		If D1_TIPO_NF $ "5" .AND. lMovtaSD3
			LxA103SB2(2,SD1->D1_LOCAL)
		EndIf

		RecLock("SD1",.F.)
		Replace SD1->D1_TES	With " "
		Replace SD1->D1_CF	With " "
		MsUnLock()

		DbSelectArea("SD1")
		DbSkip()
	End
End

//³ Armazenar dados para excluir o Remito |

For nX := 1 To Len(aRemitos)
	DbSelectArea("SF1")
	DbSetOrder(1)
	If MsSeek(cFilSF1+aRemitos[nX][1]+aRemitos[nX][2]+aRemitos[nX][3]+aRemitos[nX][4])

		DbSelectArea("SD1")
		DbSetOrder(1)
		If DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
			While !EOF() .AND. D1_FILIAL==cFilSD1 .AND.;
					D1_DOC == aRemitos[nX][1] .AND. D1_SERIE == aRemitos[nX][2] .AND.;
					D1_FORNECE == aRemitos[nX][3] .AND. D1_LOJA == aRemitos[nX][4]

					RecLock("SD1",.F.)
					DbDelete()
					MsUnLock()

					DbSkip()
			End

			DbSelectArea("SF1")
			RecLock("SF1",.F.)
			DbDelete()
			MsUnLock()
    	EndIf
	EndIf
Next nX

If !lFacImport
	If lUsaCor .And. !Empty(SF1->F1_NUMCOR) //libera o numero correlativo
		CORR_EXCL(SF1->F1_DTDIGIT,SF1->F1_NUMCOR)
	EndIf
EndIf

//³ Limpar o Status no SF1 ³

DbSelectArea("SF1")
DbSetOrder(1)
If MsSeek(cFilSF1+cNFiscalDes+cSerieDes+cFornDes+cLojaDes+cTipo)
	RecLock("SF1",.F.)
	Replace SF1->F1_STATUS With " "
	If lUsaCor
		Replace SF1->F1_NUMCOR With " "
	EndIf
	MsUnLock()
EndIf
End Transaction
Return(.T.)
/*
±±³Fun‡…o    ³aDupNaoExiste ³±±
±±³Descri‡…o ³ Verifica se a numeracao da duplicata existe               ³±±
±±³ Uso      ³ MATA101N (Integracao com Modulo de Importacao)            ³±±
*/
Function aDupNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cTipoNf,aDuplicata,lMsg)
Local lRet := .T.
Local aArea := GetArea()
Local cSerieNf :=""
Local cFilSE2	:= xFilial("SE2")
Local cFilSE1	:= xFilial("SE1")
Local lfina998  := IsInCallStack("FINA887") .Or. IsInCallStack("FINA998")

Default lMsg := .T.

If ValType(aDuplicata) == "A" .AND. len(aDuplicata) >0

	//³Controla a a existencia da Duplicata  ³

	If cAliasC == "SF2"

		//³Verifica se a NF esta sendo digitada em outra estacao ³

	   	cSerieNf :=	Padr(cSerie,Len(Criavar("F2_SERIE",.F.)))
	Else

		//³Verifica se o controle de numeracao eh o mesmo   ³
		//³para todos os documentos ou se eh independente   ³

	   	cSerieNf := 	Padr(cSerie,Len(Criavar("F1_SERIE",.F.)))
	EndIf
	If aCfgNf[ScAliasFin] =="SE1" .And. !FunName()=='FINA074' .And. !(FunName()=='FINA846' .Or. (cPaisLoc== "ARG" .And. lfina998)) .And. !(cPaisLoc == "URU" .And. (FunName()=='FINA087A' .Or. lfina998))
		If cPaisLoc $ "ARG|RUS"
			DbSelectArea("SE1")
			DbSetOrder(1)
			If DbSeek( cFilSE1+cSerieNF +cNFiscal,.F. )//cCliFor+cLoja+
				While !Eof() .AND. lRet .AND. cFilSE1 + cSerieNF + cNFiscal == E1_FILIAL + E1_PREFIXO  + E1_NUM
		   			If cTipoNF == E1_TIPO
						lRet := .F.
					EndIf
				DbSkip()
				End
			EndIf
		Else
			DbSelectArea("SE1")
			DbSetOrder(2)
			If DbSeek( cFilSE1+cCliFor+cLoja+cSerieNF +cNFiscal,.F. )
				While !Eof() .AND. lRet .AND. cFilSE1+cCliFor+cLoja+cSerieNF +cNFiscal == ;
												E1_FILIAL + E1_CLIENTE + E1_LOJA + E1_PREFIXO  + E1_NUM
					If cTipoNF == E1_TIPO
						lRet := .F.
					EndIf

				DbSkip()
				End
			EndIf
		EndIf
	Else
		DbSelectArea("SE2")
		DbSetOrder( 6 )
		If DbSeek( cFilSE2+cCliFor+cLoja+cSerieNF +cNFiscal,.F. )
			While !Eof() .AND. lRet .AND. cFilSE2+cCliFor+cLoja+cSerieNF +cNFiscal == ;
											 E2_FILIAL + E2_FORNECE + E2_LOJA + E2_PREFIXO  + E2_NUM
				If cTipoNF == E2_TIPO
					lRet := .F.
				EndIf
				DbSkip()
			End
	    EndIf
	EndIf
	RestArea(aArea)
EndIf
If !lRet
	If lMsg
		Aviso(STR0018,STR0196+"("+cNFiscal+" / "+cSerieNF+") " +STR0068+ STR0197 +cTipoNF+"'" ,{STR0021}) //"ATENCAO"###"A Duplicata ."### "ja existe "###"OK"
	Endif
EndIF
Return (lRet)

Static Function SaveVar()
Static aStack:={}

aStack := IIf(aStack==Nil,{},aStack)

AAdd( aStack, { IIf(Type("n")=="N",N,Nil),;
	IIf(Type("F1_FORNECE") 	=="C",F1_FORNECE       			,Nil),;//caracter
	IIf(Type("F1_LOJA")  	=="C",F1_LOJA         			,Nil),;
	IIf(Type("CNOME")  		=="C",CNOME         			,Nil),;
	IIf(Type("F1_NUMTIM")  	=="C",F1_NUMTIM        			,Nil),;
	IIf(Type("F1_SERIE")  	=="C",F1_SERIE         			,Nil),;
	IIf(Type("F1_DOC")  	=="C",F1_DOC         			,Nil),;
	IIf(Type("F1_NATUREZ")  =="C",F1_NATUREZ         		,Nil),;
	IIf(Type("F1_ESPECIE")  =="C",F1_ESPECIE        		,Nil),;
	IIf(Type("F1_EMISSAO")  =="D",F1_EMISSAO         		,Nil),;//data
	IIf(Type("F1_DTDIGIT")  =="D",F1_DTDIGIT       			,Nil),;//data
	IIf(Type("F1_MOEDA")  	=="N",F1_MOEDA         			,Nil),;//numerico
	IIf(Type("F1_TXMOEDA")  =="N",F1_TXMOEDA         		,Nil),;//numerico
	IIf(Type("F1_VENCAI")  	=="D",F1_VENCAI        			,Nil),;//data
	IIf(Type("F1_CAI")  	=="C",F1_CAI         			,Nil),;
	IIf(Type("F1_QTDEFOL")  =="C",F1_QTDEFOL       			,Nil),;
	IIf(Type("F1_PROVENT")  =="C",F1_PROVENT        		,Nil),;
	IIf(Type("F1_ZONGEO")  	=="C",F1_ZONGEO         		,Nil),;
	IIf(Type("F1_CONCOBR")  =="C",F1_CONCOBR         		,Nil),;
	IIf(Type("F1_TPNFEXP")  =="C",F1_TPNFEXP         		,Nil),;
	IIf(Type("F1_TPVENT")  	=="C",F1_TPVENT         		,Nil),;
	IIf(Type("F1_FECDSE")  	=="D",F1_FECDSE         		,Nil),;//data
	IIf(Type("F1_FECHSE")  	=="D",F1_FECHSE         		,Nil),;//data
	IIf(Type("F1_CAE")  	=="C",F1_CAE	         		,Nil),;
	IIf(Type("F1_VCTOCAE") 	=="D",F1_VCTOCAE         		,Nil),;//data
	IIf(Type("F1_CVPCO")  	=="C",F1_CVPCO	         		,Nil),;
	IIf(Type("F1_DESPESA")  =="N",F1_DESPESA         		,Nil),;//numerico
	IIf(Type("F1_DESCONT")  =="N",F1_DESCONT         		,Nil),;//numerico
	IIf(Type("F1_FRETE")  	=="N",F1_FRETE	         		,Nil),;//numerico
	IIf(Type("F1_SEGURO")  	=="N",F1_SEGURO         		,Nil),;//n
	IIf(Type("F1_VALMERC")  =="N",F1_VALMERC         		,Nil),;//n
	IIf(Type("F1_VALBRUT")  =="N",F1_VALBRUT         		,Nil),;//n
	IIf(Type("A2_NOME")  	=="C",A2_NOME         			,Nil),;//c
	IIf(Type("A2_TEL")  	=="C",A2_TEL     	    		,Nil),;//c
	IIf(Type("A2_PRICOM")  	=="D",A2_PRICOM         		,Nil),;//d
	IIf(Type("A2_ULTCOM")  	=="D",A2_ULTCOM         		,Nil),;//d
	IIf(Type("A2_CGC")  	=="C",A2_CGC         			,Nil),;//c
	IIf(Type("A2_END")  	=="C",A2_END         			,Nil),;//c
	IIf(Type("A2_EST")  	=="C",A2_EST         			,Nil),;//c
	IIf(Type("LINCLUI")  	=="L",LINCLUI	         		,Nil),;//boolean
	IIf(Type("LDELETA")  	=="L",LDELETA	         		,Nil),;//b
	IIf(Type("LVISUALIZA")  =="L",LVISUALIZA	       		,Nil),})//b

	N := 1
Return(Nil)

Static Function RestVar()
Local lRet  := .F.
Local nSize

If ValType( aStack ) == "A" .And. !Empty( aStack )
    //³ Verifica se existe uma interface armazenada ( array valido )           ³
    nSize := Len( aStack )

	If aStack[ nSize, 1 ] <> Nil
	    n := aStack[ nSize, 1 ]
	EndIf

    If aStack[ nSize, 2 ] <> Nil
        F1_FORNECE:= aStack[ nSize, 2 ]
    EndIf

    If aStack[ nSize, 3 ] <> Nil
        F1_LOJA    := aStack[ nSize, 3 ]
    EndIf

    If aStack[ nSize, 4 ] <> Nil
        CNOME    := aStack[ nSize, 4 ]
    EndIf

	If aStack[ nSize, 5 ] <> Nil
		F1_NUMTIM:= aStack[ nSize, 5 ]
	EndIf

	If aStack[ nSize, 6 ] <> Nil
		F1_SERIE:= aStack[ nSize, 6 ]
	EndIf

	If aStack[ nSize, 7 ] <> Nil
	F1_DOC:= aStack[ nSize, 7 ]
	EndIf

	If aStack[ nSize, 8 ] <> Nil
	F1_NATUREZ:= aStack[ nSize, 8 ]
	EndIf

	If aStack[ nSize, 9 ] <> Nil
	F1_ESPECIE:= aStack[ nSize, 9 ]
	EndIf

	If aStack[ nSize, 10 ] <> Nil
	F1_EMISSAO:= aStack[ nSize, 10 ]
	EndIf

	If aStack[ nSize, 11 ] <> Nil
	F1_DTDIGIT:= aStack[ nSize, 11 ]
	EndIf

	If aStack[ nSize, 12 ] <> Nil
	F1_MOEDA:= aStack[ nSize, 12 ]
	EndIf

	If aStack[ nSize, 13 ] <> Nil
	F1_TXMOEDA:= aStack[ nSize, 13 ]
	EndIf

	If aStack[ nSize, 14 ] <> Nil
	F1_VENCAI:= aStack[ nSize, 14 ]
	EndIf

	If aStack[ nSize, 15 ] <> Nil
	F1_CAI:= aStack[ nSize, 15 ]
	EndIf

	If aStack[ nSize, 16 ] <> Nil
	F1_QTDEFOL:= aStack[ nSize, 16 ]
	EndIf

	If aStack[ nSize, 17 ] <> Nil
	F1_PROVENT:= aStack[ nSize, 17 ]
	EndIf

	If aStack[ nSize, 18 ] <> Nil
	F1_ZONGEO:= aStack[ nSize, 18 ]
	EndIf

	If aStack[ nSize, 19 ] <> Nil
	F1_CONCOBR:= aStack[ nSize, 19 ]
	EndIf

	If aStack[ nSize, 20 ] <> Nil
	F1_TPNFEXP:= aStack[ nSize, 20 ]
	EndIf

	If aStack[ nSize, 21 ] <> Nil
	F1_TPVENT:= aStack[ nSize, 21 ]
	EndIf

	If aStack[ nSize, 22 ] <> Nil
	F1_FECDSE:= aStack[ nSize, 22 ]
	EndIf

	If aStack[ nSize, 23 ] <> Nil
	F1_FECHSE:= aStack[ nSize, 23 ]
	EndIf

	If aStack[ nSize, 24 ] <> Nil
	F1_CAE:= aStack[ nSize, 24 ]
	EndIf

	If aStack[ nSize, 25 ] <> Nil
	F1_VCTOCAE:= aStack[ nSize, 25 ]
	EndIf

	If aStack[ nSize, 26 ] <> Nil
	F1_CVPCO:= aStack[ nSize, 26 ]
	EndIf

	If aStack[ nSize, 27 ] <> Nil
	F1_DESPESA:= aStack[ nSize, 27 ]
	EndIf

	If aStack[ nSize, 28 ] <> Nil
	F1_DESCONT:= aStack[ nSize, 28 ]
	EndIf

	If aStack[ nSize, 29 ] <> Nil
	F1_FRETE:= aStack[ nSize, 29 ]
	EndIf

	If aStack[ nSize, 30 ] <> Nil
	F1_SEGURO:= aStack[ nSize, 30 ]
	EndIf

	If aStack[ nSize, 31 ] <> Nil
	F1_VALMERC:= aStack[ nSize, 31 ]
	EndIf

	If aStack[ nSize, 32 ] <> Nil
	F1_VALBRUT:= aStack[ nSize, 32 ]
	EndIf

	If aStack[ nSize, 33 ] <> Nil
	A2_NOME:= aStack[ nSize, 33 ]
	EndIf

	If aStack[ nSize, 34 ] <> Nil
	A2_TEL:= aStack[ nSize, 34 ]
	EndIf

	If aStack[ nSize, 35 ] <> Nil
	A2_PRICOM:= aStack[ nSize, 35 ]
	EndIf

	If aStack[ nSize, 36 ] <> Nil
	A2_ULTCOM:= aStack[ nSize, 36 ]
	EndIf

	If aStack[ nSize, 37 ] <> Nil
	A2_CGC:= aStack[ nSize, 37 ]
	EndIf

	If aStack[ nSize, 38 ] <> Nil
	A2_END:= aStack[ nSize, 38 ]
	EndIf

	If aStack[ nSize, 39 ] <> Nil
	A2_EST:= aStack[ nSize, 39 ]
	EndIf

	If aStack[ nSize, 40 ] <> Nil
	LINCLUI:= aStack[ nSize, 40 ]
	EndIf

	If aStack[ nSize, 41 ] <> Nil
	LDELETA:= aStack[ nSize, 41 ]
	EndIf

	If aStack[ nSize, 42 ] <> Nil
	LVISUALIZA:= aStack[ nSize, 42 ]
	EndIf

    // Exclui o ultimo elemento da pilha
    ASize( aStack, nSize - 1 )
    lRet := .T.
EndIf
Return( lRet )

Function LocxTrack()
Local aEnt     := {}
Local cKey     := ""
Local nPosItem := 0
Local nPosCod  := 0
Local nLoop    := 0

MafisSave()
SaveVar()

If aCfgNF[SAliasCols]=="SD1"
	nPosItem := GDFieldPos("D1_ITEM")
	nPosCod  := GDFieldPos("D1_COD")
	cKey     := SF1->F1_DOC + SF1->F1_SERIE + SF1->F1_FORNECE + SF1->F1_LOJA
Else
	nPosItem := GDFieldPos("D2_ITEM")
	nPosCod  := GDFieldPos("D2_COD")
	cKey     := SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA
Endif
For nLoop:=1 To Len( aCols )
	AAdd(aEnt,{aCfgNF[SAliasCols],cKey+aCols[nLoop,nPosCod ]+aCols[nLoop,nPosItem]})
Next nLoop
MaTrkShow(aEnt)

MaFisRestore()
RestVar()
Return( .T. )

/*/

±±³Descri‡…o ³Validacao da tabela de precos na NF manual                  ³±±
±±³Usado em  ³MATA467N                                                    ³±±
±±³Retorno   ³ExpL1: Tabela valida                                        ³±±
±±³Parametros³ExpC1: Codigo da Tabela de Preco                            ³±±
±±³          ³ExpC2: Codigo da Condicao de Pagamento                      ³±±
±±³          ³ExpD3: Data de emissao da NF                                ³±±
/*/
Function FaVldTabPrc(cCodTab,dDataVld)
Local lVldTabPrc 	:= .T.
Local cCondPag		:= ""

//³Somente testa validacao qdo informado codigo da Tabela de Preco³

If ( Type("cFunName") == "C" ) .AND. ( cFunName == "MATA467N" ) .AND. ( !Empty(cCodTab) )

	//³Sempre testa conteudo da variavel cCondicao ( Condicao de Pagamento ) ³

	If ( Type("cCondicao") <> "U" )
		cCondPag := cCondicao
	Else
		cCondPag := ""
	Endif
	lVldTabPrc := MaVldTabPrc(cCodTab,cCondPag,,dDataVld)
Endif
Return( lVldTabPrc )

/*/
±±³Descri‡…o ³Esta funcao corrige os valores dos produtos quando e'       ³±±
±±³          ³informado a Tabela de Precos ou removida do cadastro        ³±±
±±³Retorno   ³ExpL1: Sempre .T.                                           ³±±
±±³Usado em: ³MATA467N                                                    ³±±
/*/
Function A467TrcVal()
Local aArea			:= GetArea()
Local aAreaSX3		:= SX3->(GetArea())
local lTabPrc		:= .T. // Indica se utiliza valores da Tabela de Preco (.T.) ou Cadastro SB1 (.F.)
Local aTabPrc		:= {}  // Array da Tabela de Preco (somente do cadastro)
Local nCntFor 		:= 0
Local nProdTab		:= 0 // pos. do produto no array da Tabela de Preco
Local nVlrTabela	:= 0 // Valor de venda pela Tabela de Preco
Local nPercDesc		:= 0 // Perc. de desc.
Local nMoeda		:= M->F2_MOEDA
Local nPProd		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_COD"   })
Local nPQuant		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_QUANT" })
Local nPPrcVen		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_PRCVEN"})
Local nPPrcTab		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_PRUNIT"})
Local nPPrcTot		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_TOTAL" })
Local nPPrcDes		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_DESC"  })
Local cFilSB1	:= xFilial("SB1")
Local cFilDA1	:= xFilial("DA1")
Local cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
Local lGetDados := Type("oGetDados") <> "U"

If cPaisLoc $ cAuxPaisL .And. Upper(FunName()) == "MATA467N"

	//³Nao faz nada para quando o valor de M->F2_TABELA       ³
	//³nao foi trocado, porem, ao trocar valor, verifica onde ³
	//³ira buscar o valor de produto, em seu cadastro (SB1) ou³
	//³na Tabela de Preco (DA1) informada                     ³

	If ( ReadVar() $ "M->D2_COD" ) .Or. ( ReadVar() $ "M->F2_TXMOEDA" ) .Or. ( Alltrim(cMTabPrc) <> Alltrim(M->F2_TABELA) )
		If Empty( M->F2_TABELA )
			lTabPrc := .F. // Precos de SB1
		Else
			lTabPrc := .T. // Precos de DA1
		Endif
	Else
		Return (.T.)
	Endif
	cMTabPrc := M->F2_TABELA

	//³Alimenta array com dados da Tabela de Preco informada ³
	//³ou entao com o preco no cadastro do produto           ³

	If lTabPrc
		//³TABELA DE PRECOS³

		dbSelectArea( "DA1" )
		DA1->( dbSetOrder( 1 ) )
		If DA1->( dbSeek( xFilial( "DA1" ) + M->F2_TABELA ) )
			While !DA1->( Eof() ) .AND. cFilDA1+M->F2_TABELA == DA1->DA1_FILIAL+DA1->DA1_CODTAB
				AAdd( aTabPrc, { DA1->DA1_CODPRO , DA1->DA1_PRCVEN , DA1->DA1_MOEDA } )
				DA1->( dbSkip() )
			End
		EndIf
	Else
		//³CADASTRO DE PRODUTOS ³
		dbSelectArea( "SB1" )
		SB1->( dbSetOrder( 1 ) )
		For nCntFor := 1 to Len(aCols)
			If ( nPProd > 0 )
				If SB1->( MsSeek( cFilSB1 + aCols[nCntFor][nPProd] ) )
					AAdd( aTabPrc, { SB1->B1_COD , SB1->B1_PRV1 , 1 } )
				EndIf
			Endif
		Next nCntFor
	Endif
	//³ Corrige o preco dos produtos inseridos no aCols conforme Tabela de preco informada ³
	If ( nPProd > 0 ) .AND. ( Len(aTabPrc) > 0 )
		For nCntFor := 1 to Len(aCols)

			nProdTab := aScan(aTabPrc,{|x| AllTrim(x[1])==Alltrim(aCols[nCntFor][nPProd])})

			If ( nProdTab > 0 )
				nVlrTabela := aTabPrc[nProdTab][2]
			Else
				nVlrTabela := -1 // Erro ( Nao encontrou )
			Endif

			If ( nVlrTabela <> -1 )
				//³Corrige dados da aCols³
				If ( nPPrcVen > 0 )
					If ( nMoeda == aTabPrc[nProdTab][3] )
						aCols[nCntFor][nPPrcVen] := nVlrTabela
					Else
						aCols[nCntFor][nPPrcVen] := xMoeda(nVlrTabela,aTabPrc[nProdTab][3],nMoeda,dDataBase,MsDecimais(aTabPrc[nProdTab][3]),,M->F2_TXMOEDA)
					Endif
				EndIf
	            If ( nPPrcDes > 0 ) .AND. ( aCols[nCntFor][nPPrcDes] > 0 )
	            	// Fator de multiplicacao para calculo do perc de desc.
	            	nPercDesc := (1-(aCols[nCntFor][nPPrcDes]/100))
	            Else
	            	nPercDesc := 0
	            Endif
	            If ( nPercDesc > 0 )
	            	aCols[nCntFor][nPPrcVen] := aCols[nCntFor][nPPrcVen]*nPercDesc
	            Endif
	            If ( nPPrcTab > 0 )
	            	aCols[nCntFor][nPPrcTab] := aCols[nCntFor][nPPrcVen]
	            Endif
	            If ( nPQuant > 0 ) .AND. ( nPPrcTot > 0 )
	            	aCols[nCntFor][nPPrcTot] := aCols[nCntFor][nPQuant] * aCols[nCntFor][nPPrcVen]
	            Endif
				//³Atualiza telas ³
				If lGetDados
					oGetDados:oBrowse:Refresh()
				Endif
				MaColsToFis(aHeader,aCols,,"MT100",.T.,.F.,.T.)
				Eval(bDoRefresh)
			Endif
		Next nCntFor
	Endif
EndIf
RestArea(aAreaSX3)
RestArea(aArea)
Return (.T.)

/*/
±±³Descri‡…o ³ Validar  4a. pergunta do grupo MT119A, objetivo validar o TES³±±
±±³			 | digitado considerando o preenchimento correcto dos campos na ³±±
±±³          ³ tablea SFC.    												³±±
±±³Usado em: ³ MATA101N                                                     ³±±
/*/
Function MT119Perg4()
LOCAL aArea := GetArea()
LOCAL cTes := &(ReadVar())
LOCAL lRet := .T.
LOCAL cFilSFC	:= xFilial("SFC")
If ExistCpo("SF4") .AND. cTes <= "500"
	DbSelectArea("SFC")
	DbSetOrder(1)
	If DbSeek(cFilSFC+cTes)
		While !Eof() .AND. FC_FILIAL == xFilial("SFC") .AND.;
			FC_TES == cTes
			If Empty(FC_INCDUPL) .OR. Empty(FC_INCNOTA) .OR. Empty(FC_CREDITA) .OR. Empty(FC_CALCULO)
				lRet := .F.
				Exit
			EndIf
			DbSkip()
		End
	EndIf
EndIf
RestArea(aArea)
If !lRet
	Help("","1","TESINV")
EndIf
Return( lRet )

/*
±±ºPrograma  ³LOCXINSDES±±
*/
Function LocxInsDes(ah,aC)
Local aArea			:= GetArea()
Local aAreaSB1		:= {}
Local aAreaSD1		:= {}
Local aImps			:= {}
Local nPosItem 		:= aScan(aH,{|x| Trim(x[2])=="D1_ITEM"})
Local nPosCod 		:= aScan(aH,{|x| Trim(x[2])=="D1_COD"})
Local nPosUM		:= aScan(aH,{|x| Trim(x[2])=="D1_UM"})
Local nPosSegUM		:= aScan(aH,{|x| Trim(x[2])=="D1_SEGUM"})
Local nPosQuant		:= aScan(aH,{|x| Trim(x[2])=="D1_QUANT"})
Local nPosQtSeg		:= aScan(aH,{|x| Trim(x[2])=="D1_QTSEGUM"})
//Local nPosLocal		:= aScan(aH,{|x| Trim(x[2])=="D1_LOCAL"})
Local nPosPrc		:= aScan(aH,{|x| Trim(x[2])=="D1_VUNIT"})
Local nPosTotal		:= aScan(aH,{|x| Trim(x[2])=="D1_TOTAL"})
Local nPosTes		:= aScan(aH,{|x| Trim(x[2])=="D1_TES"})
Local nPosCfo		:= aScan(aH,{|x| Trim(x[2])=="D1_CF"})
//Local nPosConh		:= aScan(aH,{|x| Trim(x[2])=="D1_CONHEC"})
Local nRegSD1		:= 0
Local cProdDes		:= ""
Local cItem			:= ""
Local cTes			:= ""
Local cCFO			:= ""
Local cCpoAux		:= ""
Local cFilSWN		:= ""
//Local nTamAH		:= 0
Local nTamAC		:= 0
Local nD			:= 0
Local nG			:= 0
Local nTotal		:= 0
Local nPosTESArr	:= 0
Local nY			:= 0
Local aImpostos		:= {}
Local aCusto		:= {}
Local aCustoDesp	:= {}
Local aTes			:= {}
Local lClasNF		:= (SuperGetMV("MV_CLASSNF") == "1")
Local cHawb			:= ""
//Local aSvAreaSF1	:= {}
//Local aSvAreaSD1	:= {}
Local cFilSD1		:= xFilial("SD1")
Local cFilSF4		:= xFilial("SF4")
Local cFilSYD		:= xFilial("SYD")
Local cFilSFC		:= xFilial("SFC")
Local cFilSFB		:= xFilial("SFB")
Local nT_COD		:= TamSX3("D1_COD")[1]
Local nP_TESDES	:= 0
Local nP_TES		:= 0
Local nP_CF		:= 0
Local nP_COD		:= 0
Local nP_UM		:= 0
Local nP_SEGUM	:= 0
Local nP_TP		:= 0
Local nP_GRUPO	:= 0
Local nP_DOC		:= 0
Local nP_SERIE	:= 0
Local nP_FORNECE	:= 0
Local nP_LOJA		:= 0
Local nP_ESPECIE	:= 0
Local nP_TIPO_NF	:= 0
Local nP_TIPO		:= 0
Local nP_EMISSAO	:= 0
Local nP_DTDIGIT	:= 0
Local nP_FORMUL	:= 0
Local nP_TIPODOC	:= 0

cProdDes:=SuperGetMV("MV_PRDDESP",,"")
If !Empty(cProdDes)
	DbSelectArea("SD1")
	aAreaSD1:=GetArea()
	nRegSD1:=Recno()
	DbSetOrder(1)
	nP_TESDES	:= FieldPos("D1_TESDES")
	nP_TES		:= 1 //FieldPos("D1_TES")
	nP_CF		:= 1 //FieldPos("D1_CF")
	nP_COD		:= 1 //FieldPos("D1_COD")
	nP_UM		:= 1 //FieldPos("D1_UM")
	nP_SEGUM	:= 1 //FieldPos("D1_SEGUM")
	nP_TP		:= 1 //FieldPos("D1_TP")
	nP_GRUPO	:= 1 //FieldPos("D1_GRUPO")
	nP_DOC		:= 1 //FieldPos("D1_DOC")
	nP_SERIE	:= 1 //FieldPos("D1_SERIE")
	nP_FORNECE	:= 1 //FieldPos("D1_FORNECE")
	nP_LOJA	    := 1 //FieldPos("D1_LOJA")
	nP_ESPECIE	:= 1 //FieldPos("D1_ESPECIE")
	nP_TIPO_NF	:= 1 //FieldPos("D1_TIPO_NF")
	nP_TIPO	    := 1 //FieldPos("D1_TIPO")
	nP_EMISSAO	:= 1 //FieldPos("D1_EMISSAO")
	nP_DTDIGIT	:= 1 //FieldPos("D1_DTDIGIT")
	nP_FORMUL	:= 1 //FieldPos("D1_FORMUL")
	nP_TIPODOC	:= 1 //FieldPos("D1_TIPODOC")

	If !DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+cProdDes)
		SD1->(MsGoto(nRegSD1))
		aAreaSB1:=SB1->(GetArea())
		SB1->(DbSetOrder(1))
		SB1->(MsSeek(xFilial("SB1")+cProdDes))
		dbSelectArea("SWN")
		dbSetOrder(3)
		nTotal	:= 0
		cHawb	:= SF1->F1_HAWB
		cFilSWN:= xFilial("SWN")
		aTes	:= {}
		If DbSeek(cFilSWN+SF1->F1_HAWB+SF1->F1_TIPO_NF)
			While WN_FILIAL==cFilSWN .And. WN_HAWB==SF1->F1_HAWB .And. WN_TIPO_NF==SF1->F1_TIPO_NF
				If SYD->(MsSeek(cFilSYD+SWN->(WN_TEC+WN_EX_NCM+WN_EX_NBM)))
					cTes:=SYD->YD_TES
					If (nPosTesArr := Ascan(aTes,{|x| x[1] == cTes })) == 0
						SFC->(DbSeek(cFilSFC+cTes))
						While !SFC->(Eof()) .And. SFC->FC_TES==cTes
							If SFB->(MsSeek(cFilSFB+SFC->FC_IMPOSTO))
								Aadd(aImps,{SFB->FB_CPOLVRO,0,0,0})
							Endif
							SFC->(DbSkip())
						EndDo
						AAdd(aTes,{WN_TES,WN_CIF,aClone(aImps)})
						nPosTesARR := Len(aTes)
					Else
						aTes[nPosTesARR,2] +=WN_CIF
					Endif
					For nG:=1 to Len(aTes[nPosTesARR,3])
						cCpoAux := "WN_BASIMP"+aTes[nPosTesARR,3,nG,1]
						aTes[nPosTesARR,3,nG,2]+= FieldGet(FieldPos(cCpoAux))
						cCpoAux := "WN_ALQIMP"+aTes[nPosTesARR,3,nG,1]
						aTes[nPosTesARR,3,nG,3]:= FieldGet(FieldPos(cCpoAux))
						cCpoAux := "WN_VALIMP"+aTes[nPosTesARR,3,nG,1]
						aTes[nPosTesARR,3,nG,4]+= FieldGet(FieldPos(cCpoAux))
					Next
				Endif
				DbSkip()
			EndDo
		Endif
		For nD:= 1 To Len(aTes)
			cTes	:= aTes[nD,1]
			nTotal	:= aTes[nD,2]
			aImps	:= aClone(aTes[nD,3])
			SF4->(MsSeek(cFilSF4+cTes))
			cCFO	:= SF4->F4_CF
			nTamAC	:= Len(aC)
			cItem	:= aC[nTamAC,nPosItem]
			cItem	:= Soma1(cItem)
			Aadd(aC,Array(Len(aH)+1))
			nTamAC	:= Len(aC)
			aC[nTamAC,Len(aC[nTamAC])]:=.F.

			Begin Transaction

			DbSelectArea("SD1")
			RecLock("SD1",.T.)
			Replace D1_FILIAL With cFilSD1
			For nG:=1 to Len(aH)
				Do Case
					Case nG==nPosItem
						aC[nTamAC,nPosItem]:=cItem
					Case nG==nPosCod
						aC[nTamAC,nPosCod]:=Padr(cProdDes,nT_COD)
					Case nG==nPosUM
						aC[nTamAC,nPosUM]:=SB1->B1_UM
					Case nG==nPosSegUM
						aC[nTamAC,nPosSegUM]:=SB1->B1_SEGUM
					Case nG==nPosTes
						aC[nTamAC,nPosTes]:=cTes
					Case nG==nPosCfo
						aC[nTamAC,nPosCfo]:=cCFO
					Case nG==nPosQuant
						aC[nTamAC,nPosQuant]:=1
					Case nG==nPosQtSeg
						If !Empty(SB1->B1_CONV)
							If SB1->B1_TIPCONV == "M"
						    	aC[nTamAC,nPosQtSeg]:= 1 * SB1->B1_CONV
						   	Else
						      	aC[nTamAC,nPosQtSeg]:= 1 / SB1->B1_CONV
						   	EndIf
						Else
							aC[nTamAC,nPosQtSeg]:=0
						EndIf
					Case nG==nPosPrc
						aC[nTamAC,nPosPrc]:=nTotal
					Case nG==nPosTotal
						aC[nTamAC,nPosTotal]:=nTotal
					OtherWise
						aC[nTamAC,nG]:=aC[1,nG]
				EndCase
				FieldPut(FieldPos(aH[nG,2]),aC[nTamAC,nG])
			Next
			FieldPut(nP_TESDES	,cTes)
			If lClasNF
				Replace D1_TES With cTes
				Replace D1_CF  With cCFO
			EndIf
			Replace D1_COD     With Padr(cProdDes,nT_COD)
			Replace	D1_UM	   With SB1->B1_UM
			Replace	D1_SEGUM   With SB1->B1_SEGUM
			Replace	D1_TP	   With SB1->B1_TIPO
			Replace	D1_GRUPO   With SB1->B1_GRUPO
			cAuxPaisL := "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
			If cPaisLoc $ cAuxPaisL
				Replace	D1_DOC	   With SF1->F1_DOC
				//Replace	D1_SERIE   With SF1->F1_SERIE
				SerieNfId("SD1",1,"D1_SERIE",,,,SF1->F1_SERIE ) //Projeto chave única - Tiago Silva
			EndIf

			Replace	D1_FORNECE With SF1->F1_FORNECE
			Replace	D1_LOJA    With SF1->F1_LOJA
			cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
			If cPaisLoc $ cAuxPaisL
				Replace	D1_ESPECIE With SF1->F1_ESPECIE
			EndIf
			Replace	D1_TIPO_NF With SF1->F1_TIPO_NF
			Replace	D1_TIPO	   With SF1->F1_TIPO
			Replace	D1_EMISSAO With SF1->F1_EMISSAO
			Replace	D1_DTDIGIT With SF1->F1_DTDIGIT
			Replace	D1_FORMUL  With SF1->F1_FORMUL
			Replace	D1_TIPODOC With SF1->F1_TIPODOC

			For nG:=1 To Len(aImps)
				cCpoAux:="D1_BASIMP"+aImps[nG][1]
				FieldPut(FieldPos(cCpoAux),Round(aImps[nG][2],MSDecimais(1)))
				cCpoAux:="D1_ALQIMP"+aImps[nG][1]
				FieldPut(FieldPos(cCpoAux),aImps[nG][3])
				cCpoAux:="D1_VALIMP"+aImps[nG][1]
				FieldPut(FieldPos(cCpoAux),Round(aImps[nG][4],MSDecimais(1)))
			Next
			aCusto := {}
			AADD(aCusto,{0.00,{},0,"N","N","","",SD1->D1_COD,RetFldProd(SD1->D1_COD,"B1_LOCPAD"),SD1->D1_QUANT})

			aImpostos:=TesImpInf(SD1->D1_TES)

			For nY:=1 to Len(aImpostos)
				nPosSD1 :=SD1->(FieldPos("D1_"+Substr(aImpostos[nY][2],4)))
				If nPosSD1 > 0
					If ( aImpostos[nY][5] == "1" )
						aCusto[1][1]+= SD1->(FieldGet(nPosSD1))
					EndIf
				Endif
			Next  nY

			//³ Pegar o Custo do Despacho
			aCustoDesp := RetCusEnt(,aCusto,"N")

			If Len(aCustoDesp) > 0
				//³ Grava custo em todas moedas
				Replace   D1_CUSTO  	With aCustoDesp[1][1]
				Replace 	D1_CUSTO2 	With aCustoDesp[1][2]
				Replace 	D1_CUSTO3 	With aCustoDesp[1][3]
				Replace 	D1_CUSTO4 	With aCustoDesp[1][4]
				Replace 	D1_CUSTO5 	With aCustoDesp[1][5]
			EndIf
			SD1->(MsUnlock())
			SD1->(DbCommit())

			End Transaction

		Next
		RestArea(aAreaSB1)
		RestArea(aAreaSD1)
	EndIf
	If lClasNF

		If DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)

			While !Eof() .AND. D1_FILIAL == cFilSD1;
						 .AND. D1_DOC == SF1->F1_DOC;
						 .AND. D1_SERIE == SF1->F1_SERIE;
						 .AND. D1_FORNECE == SF1->F1_FORNECE;
						 .AND. D1_LOJA == SF1->F1_LOJA

            	If SD1->D1_COD <> cProdDes

					SF4->(MsSeek(cFilSF4+SD1->D1_TESDES))
					cCFO:=SF4->F4_CF

					Begin Transaction
					RecLock("SD1",.F.)
			   		Replace D1_TES  With SD1->D1_TESDES
					Replace D1_CF   With cCFO

					aCusto := {}
					AADD(aCusto,{SD1->D1_TOTAL,{},0,"N","N","","",SD1->D1_COD,RetFldProd(SD1->D1_COD,"B1_LOCPAD"),SD1->D1_QUANT})

					aImpostos:=TesImpInf(SD1->D1_TES)

					For nY:=1 to Len(aImpostos)
						nPosSD1 :=SD1->(FieldPos("D1_"+Substr(aImpostos[nY][2],4)))
						If nPosSD1 > 0
  			              	FieldPut(nPosSD1,SD1->(FieldGet(nPosSD1))) //Lucas, 16/08/07
							If ( aImpostos[nY][5] == "1" )
								aCusto[1][1]+= SD1->(FieldGet(nPosSD1))
							EndIf
						Endif
					Next  nY

					//³ Pegar o Custo do Despacho                                                                     ³
					aCustoDesp := RetCusEnt(,aCusto,"N")

					If Len(aCustoDesp) > 0
						//³ Grava custo em todas moedas                                  ³
						Replace D1_CUSTO  	With aCustoDesp[1][1]
						Replace D1_CUSTO2 	With aCustoDesp[1][2]
						Replace D1_CUSTO3 	With aCustoDesp[1][3]
						Replace D1_CUSTO4 	With aCustoDesp[1][4]
						Replace D1_CUSTO5 	With aCustoDesp[1][5]
					EndIf

					SD1->(MsUnlock())
					SD1->(DbCommit())

					End Transaction

				EndIf
				SD1->(DbSkip())
			EndDO
		EndIf
	EndIf
Endif
RestArea(aArea)
Return

/*/
±±³Descri‡…o ³Compatibilizacao de variaveis utilizadas no FINC010         ³±±
/*/
Function LocxFc010()
Local aArea	:= GetArea()

dbselectarea(aCfgNF[SAliasHead])
dbclearfilter()

If Pergunte("FIC010",.T.)
	Fc010Con('SA1',SA1->(RecNo()),3)
EndIf

dbselectarea(aCfgNF[SAliasHead])
Eval( bFilBrw )

RestArea(aArea)
Return .T.

/*
±±ºPrograma  ³LOCXNF    ºAutor  ³Microsiga           ºFecha ³  08/18/04   º±±
±±ºDesc.     ³ Procura pelo remito de origem da nota de entrada           º±±
*/
Function LocxNrReIm(cHawb,cDocSer)
Local aArea   := GetArea()
Local aRet    := {"","","",""}
Local aSF1    := {}
Local cChSF1  := ""
Local lRemito := .F.

aRet[1]:="RI "
dbSelectArea("SF1")
aSF1:=GetArea()
dbSetOrder(5)
cChSF1:=xFilial("SF1")+cHawb+"5"
If DbSeek(cChSF1)
	While F1_FILIAL+F1_HAWB+F1_TIPO_NF==cChSF1 .AND. !lRemito
		If !Empty(F1_REMITO) .And. (Empty(cDocSer) .Or. (cDocSer == F1_DOC /*.And. Empty(F1_SERIE)*/ ) )
			lRemito:=.T.
			aRet[2]:=F1_REMITO
			aRet[3]:=F1_FORNECE
			aRet[4]:=F1_LOJA
		EndIf
		DbSkip()
	EndDo
EndIf
RestArea(aSF1)
If !lRemito
	If SX5->(MsSeek(xFilial("SX5")+"01"+aRet[1]))
		RecLock("SX5",.F.)
		aRet[2]:=Alltrim(X5DESCRI())
		Replace SX5->X5_DESCRI	With Soma1(aRet[2])
		Replace SX5->X5_DESCSPA	With SX5->X5_DESCRI
		Replace SX5->X5_DESCENG	With SX5->X5_DESCRI
		SX5->(MsUnlock())
	Else
		RecLock("SX5",.T.)
		aRet[2]:=Padl("1",TamSX3("F1_DOC")[1],"0")
		Replace SX5->X5_FILIAL	With xFilial("SX5")
		Replace SX5->X5_TABELA	With "01"
		Replace SX5->X5_CHAVE	With aRet[1]
		Replace SX5->X5_DESCRI	With Soma1(aRet[2])
		Replace SX5->X5_DESCSPA	With SX5->X5_DESCRI
		Replace SX5->X5_DESCENG	With SX5->X5_DESCRI
	EndIf
EndIf
RestArea(aArea)
Return aRet

Function LocXDelCC(cForn,cLoja,cDoc,cSerie)
Local lRet  := .F.
Local aArea := {}
Local aSEU  := {}
Local nRegSEU := 0
//Local nValDev := 0
//Local cCx := ""
Local cFilSEU	:= xFilial("SEU")
local cFilSET	:= xFilial("SET")
Local cNumAnt   :=""
Local aSldAtu   :={}

//Contabilidad online
//Local lPad579	:= VerPadrao("579")
Local lUsaFlag	:= SuperGetMV("MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
//Local aFlagCTB	:= {}
//Local aCtbDia	:= {}
//Local nTotal	:= 0
//Local cArquivo	:= ""
Local cFunName	:= FunName()

//Contabilidad online
Private nHdlPrv := 0
Private cLote	:= ""

If SIX->(MsSeek("SEU7"))
	aArea:=GetArea()
	aSEU:=SEU->(GetArea())
	DbSelectArea("SEU")
	DbSetOrder(7)
	cDoc:=Padr(cDoc,Len(EU_NRCOMP))
	If MsSeek(cFilSEU+cForn+cLoja+cDoc+cSerie)
		SET->(dbSetOrder(1))
		SET->(MsSeek(cFilSET+SEU->EU_CAIXA))
		If IIF(SET->ET_SITUAC == "0" , .F. , .T.)
			lRet := .F.
		Else
			If SEU->EU_TIPO == "01" // adiant.
				nRegSEU:=Recno()
				cNroAdia := SEU->EU_NUM
				cNumAnt  := SEU->EU_NUM
				dbSelectArea("SEU")
				dbSetOrder(3)  // filial + nroadia
				While dbSeek( cFilSEU + cNroAdia)
					RecLock(cAlias,.F.,.T.)
					dbDelete()
					MsUnlock()
				End
				MsGoto(nRegSEU)
			EndIf

			DbSelectArea("SEU")

	  		If cPaisLoc == "BOL" .And. !Empty(EU_BAIXA)
				nVlrDel  := EU_VALOR
				cNroAdia := EU_NROADIA
				dBaixa   := EU_BAIXA
				cNumAnt  := posicione("SEU",6,cFilSEU+SEU->EU_CAIXA+"01"+cNroAdia,"EU_NUM")
      			Fa560FcAdi( SEU->(Recno()), SEU->EU_VALOR, GetSx8Len(),, .T.)
			Else
				nVlrDel  := EU_VALOR
				cNroAdia := EU_NROADIA
				dBaixa   := EU_BAIXA
				If cPaisLoc == "ARG" .And. !Empty(EU_BAIXA)
					nRegSEU := Recno()
					cNumAnt  := posicione("SEU",6,cFilSEU+SEU->EU_CAIXA+"01"+cNroAdia,"EU_NUM")
					MsGoto(nRegSEU)
				EndIf
				If cPaisLoc == "PER"
					LxDelCCPer(lUsaFlag, (mv_par03 == 1), cFunName, cUsuario)
				EndIf
				RecLock("SEU",.F.,.t.)
				dbDelete()
				MsUnlock()
			EndIf
			If Empty(cNroAdia)
				If Empty(dBaixa)
					//³ Atualiza saldo do caixinha e niveis superiores, se houverem ³
					dbSelectArea("SET")
					dbSetOrder(1)
					MsSeek(cFilSET+SEU->EU_CAIXA)
					aSldAtu := Fa570AtuSld( ET_CODIGO)
					RecLock("SET",.F.)
					If cPaisLoc == "ARG"
						REPLACE ET_SALANT WITH SET->ET_SALDO
					EndIf
					REPLACE ET_SALDO WITH aSldAtu[1][1]
					MsUnlock()
				EndIf
			Else
				If cPaisLoc == "CHI"
					LxDelCCChi(cForn, cLoja, cDoc, cSerie, cNroAdia, @nVlrDel)
				Endif
				If cPaisLoc $ "BOL"
					LxDelCCBol(cFilSEU, cNroAdia, cNumAnt, nVlrDel)
				Else
					dbSelectArea("SEU")
					If cPaisLoc $ "ARG"
						SEU->(dbSetOrder(3))
					Else
						SEU->(dbSetOrder(1))
					Endif
					If SEU->(DbSeek(cFilSEU+cNroAdia+(Iif(cPaisLoc $ "ARG",cNumAnt,""))))
						RecLock("SEU",.F.)
						REPLACE EU_SLDADIA WITH EU_SLDADIA + nVlrDel
						If !Empty(EU_BAIXA)
							REPLACE EU_BAIXA WITH CTOD("//")
						Endif
						MsUnlock()
					EndIf
				EndIf
			EndIf
			lRet:=.T.
		Endif
	Endif
	RestArea(aSEU)
	RestArea(aArea)
Endif
Return(lRet)

/*
±±ºDesc.     ³ Funcao para calcular o vencimento do imposto.               º±±
±±º          ³ cDia  := Recebe o dia para o calculo de data valida         º±±
±±º          ³ cTipo := Tipo de calculo para data                          º±±
±±º          ³     1 -> Proximo dia valido, caso seja menor que o dia      º±±
±±º          ³          atual, fica valendo para o mes seguinte.           º±±
±±º          ³     2 -> Sera considerado o dia somente para o proxiomo mes.º±±
±±º          ³     3 -> E somado o valor na data corrente (DataBase+31)    º±±*/
Static Function LocVencImp(cDia,cTipo,aTitPai)
Local dVencto := CTOD("  /  /  ")
Local cMes    := ""
Local cAno    := ""

If cTipo == '1'  .OR. cTipo == '2'
	If (cTipo=='1' .AND. Val(cDia) < Day(dDataBase)) .OR. cTipo == '2'
		cMes	:=	StrZero(Mod(Month(dDataBase)+1,12),2)
		cAno	:=	StrZero(IIf(cMes=='01',Year(dDataBase)+1,Year(dDataBase)),4)
	Else
		cMes	:=	StrZero(Month(dDataBase),2)
		cAno	:=	StrZero(Year(dDataBase),4)
	Endif
	If cDia == "31"
		cDia	:=	StrZero(F_UltDia(CTOD('01/'+cMes+'/'+cAno,"dd/mm/yy")),2)
	Else
		cDia	:=	StrZero(MIN(VAL(ALLTRIM(STR(F_UltDia(Ctod('01/'+cMes+'/'+cAno,"dd/mm/yy"))))),Val(cDia)),2)
	Endif
	dVencto := CTOD(cDia+"/"+cMes+"/"+cAno,"dd/mm/yy")
ElseIf cTipo == '3'
	dVencto := (dDataBase + Val(cDia))
Else
	dVencto := dDataBase
Endif

If cPaisloc == "PER"
	dVencto := VencImpPer(dDatabase, aTitPai)
EndIf
Return dVencto

/*
±±ºDesc.     ³Validacao da Serie Informada X Serie do Codigo de Barra da NF.   º±±
±±ºParametros³ cAlias		- Alias do Arquivo (SF1/SF2)                       º±±
±±º          ³ cFieldCODBAR - (M->F1_CODBAR/M->F2_CODBAR)                      º±±
±±º          ³ cFieldSERIE  - (M->F1_SERIE/M->F2_SERIE)                        º±±
±±ºUso       ³ Validacao de: (M->F1_SERIE/M->F2_SERIE)                         º±±*/
Function LocxSERIE(cAlias,cFieldCODBAR, cFieldSERIE)
Local lValido:=.F.
Local aVTipoCompr := {}

DbSelectArea("SX3")
DbSetOrder(2)
If cAlias == "SF1"
	If !SX3->(MsSeek('F1_CODBAR'))
		Return .T.
	Else
		If Type("M->F1_CODBAR")=="U"
			Return .T.
		Endif
	Endif
Else
	If !SX3->(MsSeek('F2_CODBAR'))
		Return .T.
	Else
		If Type("M->F2_CODBAR")=="U"
			Return .T.
		Endif
	Endif
Endif

If Empty(IIf(cAlias=="SF1",M->F1_CODBAR,M->F2_CODBAR))
	lValido:=.T.
Else
	aVTipoCompr:=MT991SETpC(cAlias,SubStr(cFieldCODBAR,12,2))
	If Substr(AllTrim(aVTipoCompr[1]) ,1,1) == Substr(AllTrim(M->cFieldSERIE),1,1)
		lValido:=.T.
	Endif
Endif
If !lValido
	Help(" ",1,"LOCXNF0012")
Endif
Return lValido
/*
±±ºDesc.     ³Validacao dos Campos no Botao de Confirmacao                º±±
±±ºParametros³ cAlias        - Alias do Arquivo (SF1,SF2)                 º±±
±±º          ³ cTexto        - Codigo de Barras                           º±±
±±º          ³ lValidaDv     - Se valida o DV do Codigo de Barras         º±±
±±ºUso       ³ SX3->X3_VALID                                              º±±*/
Function LocxCODBOK(cAlias, cTexto, lValidaDv )
Local lValido		:= .F.//, lErro:=.F.
Local aAreaAtu		:= GetArea()
Local aVTipoCompr	:= {}
//Local aPHelpEsp		:= {}
//Local aPHelpPor		:= {}
//Local aPHelpEng		:= {}
//Local aSHelpEsp		:= {}
//Local aSHelpPor		:= {}
//Local aSHelpEng		:= {}
//Local lForneceOK	:= .F.
Local cEspecie		:= ""
Local cSerie		:= ""
//Local cCGC			:= ""
Local cFornece		:= ""
Local cLoja			:= ""
Local cCliente		:=IIf(aCfgNf[SAliasHead]=="SF1","_FORNECE","_CLIENTE")

If Type("M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_CODBAR")=="U" .or. IsIncallStack("Fina560")
	Return .T.
Endif

If Empty(cTexto)
	Return .T.
Endif

DEFAULT lValidaDV:= .T.

If Len(AllTrim(cTexto)) == 40
	If lValidaDv
		If LocXCMod10(SubStr(cTexto,1,39)) # SubStr(cTexto,40,1)
			Help(" ",1,"LOCXNF0013")
			Return lValido
		Endif
	Endif
	cEspecie:=&("M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_ESPECIE")
	cSerie	:=&("M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE")

	aVTipoCompr:=MT991SETpC(cAlias,SubStr(cTexto,12,2))
	RestArea(aAreaAtu)
	If Substr(aVTipoCompr[2],1,2)==Substr(cEspecie,1,2)
		If Substr(AllTrim(aVTipoCompr[1]),1,1) == Substr(AllTrim(cSerie),1,1)
			DbSelectArea(aCfgNf[ScCliFor])
			DbSetOrder(1)
			lFornece:=.F.
			cFornece:=&("M->"+PrefixoCpo(aCfgNf[SAliasHead])+cCliente)
			cLoja	:=&("M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA")
			If DbSeek(xFilial(aCfgNf[ScCliFor])+cFornece+cLoja)
				If !EOF()
					If Substr(Alltrim(&(aCfgNf[ScCliFor]+"->"+PrefixoCpo(aCfgNf[ScCliFor])+"_CGC")),1,11)==Substr(cTexto,1,11)
						lValido:=.T.
					Else
						Help(" ",1,"LOCXNF0006")
					Endif
				Else
					Help(" ",1,"LOCXNF0006")
				Endif
			Else
				RestArea(aAreaAtu)
				Help(" ",1,"LOCXNF0003")
			Endif
		Else
			Help(" ",1,"LOCXNF0012")
		Endif
	Else
		Help(" ",1,"LOCXNF0004")
	Endif
Else
	Help(" ",1,"LOCXNF0005")
Endif
Return lValido
/*
Programa  ³SCMToREM Fecha ³  09/02/05
Desc.     ³Selecao de remitos para NF de entrada
lActBrow - logico - Indica si deben realizarse las actualizaciones del browse. por default se realizan.
*/
Function SCMToREM(lActBrow)
Local aCposF4		:= {}
Local aRecs    		:= {}
Local aRet     		:= {}
Local aHeaderSDE	:= {}
Local aArea    		:= GetArea()
//Local cCampo 		:= ""
Local cCliFor		:= IIf(aCfgNF[SAliasHead]=="SF1",M->F1_FORNECE,M->F2_CLIENTE)
Local cCondicao2 	:= ""
Local cItem			:=	""
Local cLoja  		:= IIf(aCfgNF[SAliasHead]=="SF1",M->F1_LOJA,M->F2_LOJA)
Local cSeek  		:= "'" + xFilial('SF1')+cCliFor+cLoja + "'"
Local cTipoDoc 		:= ""
Local cWhile 		:= "!__LOCXSF1->(EOF()) .AND. __LOCXSF1->(F1_FILIAL+F1_FORNECE+F1_LOJA)== " + cSeek
Local cPosFilial	:= ""
Local cPosDoc		:= ""
Local cPosSerie		:= ""
Local cPosFornece	:= ""
Local nDescri  		:= 0
Local nOrdProd 		:= 0
Local nPorDesc		:= 0
Local nItemRem 		:= 0
Local nUm      		:= 0
Local nSegum   		:= 0
Local nCod     		:= 0
Local nLocal   		:= 0
Local nQuant   		:= 0
Local nRemito  		:= 0
Local nSeriRem 		:= 0
Local nItem    		:= 0
Local nTes     		:= 0
Local nCf      		:= 0
Local nLoteFor 		:= 0
Local nLoteCtl 		:= 0
Local nNumLote 		:= 0
Local nDtValid 		:= 0
Local nProvEnt		:= 0
Local nIpi     		:= 0
Local nVunit   		:= 0
Local nTotal   		:= 0
Local nQTSegum 		:= 0
Local nConta 		:= 0
Local nCCusto 		:= 0
Local nFepp 		:= 0
Local nIE   		:= 0
Local nDesc 		:= 0
//Local nDesNTrb		:= 0
//Local nTara			:= 0
Local nBsImp1M		:= 0
Local nVlImp1M		:= 0
Local nServic		:= 0
Local nUbica		:= 0
Local lWmsNew    	:= SuperGetMV("MV_WMSNEW",.F.,.F.)
Local nTotalM		:= 0
Local nI 			:= 0
Local nJ 			:= 0
//Local nK 			:= 0
Local cTipConv 		:= GetNewPar("MV_ALTTXNF",'1')
Local nTaxaNf		:= 0
Local nTaxaPed		:= 0
Local nItConta  	:= 0
Local nClValor  	:= 0
Local nSeguro       := 0
Local nFrete        := 0
Local nDescont      := 0
Local nDespesa      := 0
Local cPe			:=	""
Local cPeT			:=	""
Local cRetPe		:=  ""
Local lRetPE69		:= .T.
Local lZeraCols     := .T.
Local nRat			:= 0
Local nPedido		:= 0
Local nItemPC		:= 0
Local nFornece		:= 0
Local nLojaForn		:= 0
Local nDifRem		:= 0
Local nFDESC		:= 0
Local nVlTotal		:= 0
Local nTpActiv		:= 0
Local nCodMun		:= 0
Local lConfFis		:= SuperGetMV("MV_CONFFIS",.F.,"N") == "S"
Local lRemDiv		:= SuperGetMV("MV_REMDIV",.F.,.F.)
Local lCheckMoed	:= .T.
Local aFilTop		:= {.F.}
Local aChMoeda		AS Array
//Local cCFO			:= ""
Local lValDesc		:= cPaisLoc $ "PER|MEX|COL" .And. FunName() $ "MATA465N"
Local aRecSD1		:= {}		//OPTIMIZA...
Local lOtros		:= .F.		//...OPTIMIZA
Local dMaxRem		as Date
Local lCondicao     := .F.
Local cMvDescSai := SuperGetMV("MV_DESCSAI",.T.,'1')

If Type("cCondicao") <> "U"
	lCondicao := .T.
EndIf

Private aFiltro		:= {}
Private aColsSD1	:= aCols
Private oTmpRemito	:= Nil

Default lActBrow	:= .T.

If Empty(cCliFor) .OR. Empty(cLoja)
	Aviso(cCadastro,STR0094,{STR0021}) //"Llene encabezado."###"OK"
	Return .F.
EndIf
If FindFunction("LxCpRemito") .And. !LxCpRemito()//Valida campos usados
	Return
EndIf
For nI:=1 to Len(aHeader)
	Do Case
		Case  Alltrim(aHeader[nI][2]) == "D1_DESCRI"
			nDescri  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DESC"
			nPorDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMREM"
			nItemRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_UM"
			nUm      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SEGUM"
			nSegum   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_COD"
			nCod     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOCAL"
			nLocal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QUANT"
			nQuant   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_REMITO"
			nRemito  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SERIREM"
			nSeriRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEM"
			nItem    := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TES"
			nTes     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CF"
			nCf      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTEFOR"
			nLoteFor := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTECTL"
			nLoteCtl := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_NUMLOTE"
			nNumLote := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DTVALID"
			nDtValid := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_IPI"
			nIpi     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VUNIT"
			nVunit   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TOTAL"
			nTotal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QTSEGUM"
			nQTSegum := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CONTA"
			nConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CC"
			nCCusto := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_OP"
			nOrdProd := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_FEPP"
			nFepp := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_IE"
			nIE   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VALDESC"
			nDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMCTA"
			nItConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CLVL"
			nClValor := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_PROVENT"
			nProvEnt := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_RATEIO"
			nRat := nI
		Case Alltrim(aHeader[nI][2]) == "D1_PEDIDO"
			nPedido := nI
		Case Alltrim(aHeader[nI][2]) == "D1_ITEMPC"
			nItemPC := nI
		Case Alltrim(aHeader[nI][2]) == "D1_FORNECE"
			nFornece := nI
		Case Alltrim(aHeader[nI][2]) == "D1_LOJA"
			nLojaForn := nI
		Case Alltrim(aHeader[nI][2]) == "D1_FDESC"
			nFDESC := nI
		Case Alltrim(aHeader[nI][2]) == "D1_BSIMP1M" .AND. cPaisloc == "RUS"
			nBsImp1M := nI
		Case Alltrim(aHeader[nI][2]) == "D1_VLIMP1M" .AND. cPaisloc == "RUS"
			nVlImp1M := nI
		Case Alltrim(aHeader[nI][2]) == "D1_TOTALM" .AND. cPaisloc == "RUS"
			nTotalM := nI
		Case Alltrim(aHeader[nI][2]) == "D1_SERVIC" .AND. cPaisloc == "ARG"
			nServic := nI
		Case Alltrim(aHeader[nI][2]) == "D1_ENDER" .AND. cPaisloc == "ARG"
			nUbica := nI
		Case Alltrim(aHeader[nI][2]) == "D1_TPACTIV" .AND. cPaisloc == "COL"
			nTpActiv := nI
		Case Alltrim(aHeader[nI][2]) == "D1_CODMUN" .AND. cPaisloc == "COL"
			nCodMun := nI		
	Endcase
Next nI
If aCfgNF[SnTipo] == 4 .OR. aCfgNF[SnTipo] == 5
	cTipoDoc := "51/53"
ElseIf aCfgNF[SnTipo] == 10
	cTipoDoc := "60"
Else
	Return
EndIf
SX3->(DbSetOrder(1))
SX3->(DbSeek("SF1"))
While !SX3->(EOF()) .AND. SX3->X3_ARQUIVO == "SF1"
	If SX3->X3_BROWSE == "S" .AND. cNivel >= SX3->X3_NIVEL .AND. SX3->X3_TIPO != "M"
		AAdd(aCposF4,SX3->X3_CAMPO)
	Endif
	SX3->(DbSkip())
End
For nI:=1 to Len(aCposF4)
	Do Case
		Case  Alltrim(aCposF4[nI]) == "F1_FILIAL"
			cPosFilial := nI
		Case  Alltrim(aCposF4[nI]) == "F1_DOC"
			cPosDoc := nI
		Case  Alltrim(aCposF4[nI]) == "F1_SERIE"
			cPosSerie := nI
		Case  Alltrim(aCposF4[nI]) == "F1_FORNECE"
			cPosFornece := nI
	Endcase
Next nI
If nRemito * nSeriRem * nItemRem > 0
	If FindFunction("FilToRemTop")
		aFilTop := FilToRemTop(cCliFor,cLoja,aCfgNF[ScTipoDoc],Alltrim(cTipoDoc),nRemito,nSeriRem,nItemRem)
	EndIf
	If	!aFilTop[1]
		DbSelectArea("SD1")
		SD1->(DbSetOrder(10))
		SD1->(DbSeek(xFilial("SD1")+cCliFor+cLoja))
		lFilData:=.T.
		If ExistBlock("LOCFDTR")
			lFilData:=Execblock("LOCFDTR",.F.,.F.,)
		EndIf

		If lFilData
			cFilRem:="DToS(SD1->D1_DTDIGIT) <= DToS(dDataBase) .AND. SD1->D1_QTDACLA > 0 .AND. AllTrim(SD1->D1_TIPO) == aCfgNF[ScTipoDoc] .AND.	AllTrim(SD1->D1_TIPODOC) $ Alltrim(cTipoDoc)"
		Else
			cFilRem:="SD1->D1_QTDACLA > 0 .AND. AllTrim(SD1->D1_TIPO) == aCfgNF[ScTipoDoc] .AND. AllTrim(SD1->D1_TIPODOC) $ Alltrim(cTipoDoc)"
		EndIf
		While !SD1->(EOF()) .AND.SD1->D1_FILIAL+SD1->D1_FORNECE+SD1->D1_LOJA == xFilial("SD1")+cCliFor+cLoja
			If 	DToS(SD1->D1_DTDIGIT) <= DToS(dDataBase) .AND. SD1->D1_QTDACLA > 0 .AND. AllTrim(SD1->D1_TIPO) == aCfgNF[ScTipoDoc] .AND.	AllTrim(SD1->D1_TIPODOC) $ Alltrim(cTipoDoc)
				If Ascan(aColsSD1,{ |X| X[nRemito]+X[nSeriRem]+X[nItemRem] == SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_ITEM .and. !X[len(aHeader)+1]})==0
					dbSelectArea("SF1")
					SF1->(DbSetOrder(1))
					If !lConfFis .Or. (lConfFis .And. SF1->(dbSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA)) .And. ((SF1->F1_STATCON $ (Iif(lRemDiv,"1*2","1"))) .OR. EMPTY(SF1->F1_STATCON)))
						Aadd(aFiltro, {SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO, SD1->(Recno())})
					EndIf
				Endif
			Endif
			SD1->(DbSkip())
		End
	EndIf
	If !Empty(aFiltro)
		If Select("__LOCXSF1") == 0
			ChkFile("SF1",.F.,"__LOCXSF1")
		Endif
		cPe	:=	LocxPE(49)
		If !Empty(cPe)
			cRetPe := Execblock(cPE,.F.,.F.,{"__LOCXSF1"})
			If ValType(cRetPe) <> "C"
		   	  	cRetPe := " "
		  	EndIf
		EndIf
		cCondicao2	:= "Ascan(aFiltro,{ |X| X[1]==__LOCXSF1->(F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO)}) > 0"
		cCondicao2   += if(empty(cRetPe),""," .AND. " + cRetPe)
		If ExistBlock('LOCXCOND')
			cCondicao2 := Execblock('LOCXCOND',.F.,.F.,{cCondicao2,"R"})
		EndIf
		If cPaisLoc == "RUS"
			MsgRun(STR0356,DESCREM,{||aRet := LocxF4("__LOCXSF1",IIf(!aFilTop[1],2,1),cWhile,cSeek,aCposF4,,DESCREM,cCondicao2,.T.,,,,,.F.,,,.T.)})
		Else
			MsgRun(STR0356,DESCREM,{||aRet := LocxF4("__LOCXSF1",IIf(!aFilTop[1],2,1),cWhile,cSeek,aCposF4,,DESCREM,cCondicao2,.T.,,,,,.F.)})
		Endif
	Else
		Help(" ",1,"A103F4")
		Return .F.
	EndIf
EndIf
If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs := aRet[3]
EndIf

If ValType(aRecs)!="A" .OR. (ValType(aRecs)=="A" .AND. Len(aRecs)==0)
	Return .F.
EndIf
If cPaisLoc == "RUS"
	If Len(aRecs) > 1
		aChMoeda	:= {}
		for nI:=1 to Len(aRecs)
			__LOCXSF1->(MsGoto(aRecs[nI]))
				Aadd(aChMoeda,__LOCXSF1->F1_MOEDA)
				dMaxRem := Iif( dMaxRem == Nil, __LOCXSF1->F1_EMISSAO, max(dMaxRem, __LOCXSF1->F1_EMISSAO) )
		Next nI
		aSort(aChMoeda,,,{ |x, y| x < y })
		for nI:=1 to Len(aChMoeda)-1
			if aChMoeda[nI]<>aChMoeda[nI+1]
				lCheckMoed	:= .F.
				Exit
			EndIf
		next nI
	Else
		dmaxRem := __LOCXSF1->F1_EMISSAO
	EndIf
EndIf
If !lCheckMoed
	Help("A100MOEDAREMITO",1,STR0403)	//Selected Records have different currency
EndIf
If lCheckMoed
	cItem	:=	StrZero(0,TamSx3('D1_ITEM')[1])
	nI:=0
	//³ Ponto de Entrada utilizado para nao carregar o aCols com pedidos Remision ³
	//³ caso a validacao retorne Falso                                            |
	cPe	:=	LocxPE(69)
	If !Empty(cPe)
		lRetPE69 := Execblock(cPE,.F.,.F.)
		If ValType(lRetPE69) <> "L"
			lRetPE69 := .T.
		EndIf
	EndIf
	nMoedRec:=MAFISRET(,'NF_MOEDA')
	nTaxaNF		:= MaFisRet(,'NF_TXMOEDA')
	If nTaxaNF ==0
		 nTaxaNF:=Recmoeda(dDatabase,M->F1_MOEDA)
	EndIf
	If lRetPE69
		CursorWait()			//OPTIMIZA
		For nI := 1 To Len(aRecs)
			__LOCXSF1->(MsGoTo(aRecs[nI]))
			If cPaisloc == "RUS"		//(18/07/18):Change moeda from remito invoice
				M->F1_EMISSAO := dmaxRem
				dDEmissao := dmaxRem
				M->F1_MOEDA := __LOCXSF1->F1_MOEDA
				nMoedaNF := __LOCXSF1->F1_MOEDA
				nMoedaCor := nMoedaNF
				MaFisRef("NF_MOEDA","MT100",__LOCXSF1->F1_MOEDA)
				M->F1_TXMOEDA:=RecMoeda(M->F1_EMISSAO,nMoedaNF)
				M->F1_CNORSUP	:= __LOCXSF1->F1_CNORSUP
				M->F1_CNEEBUY	:= __LOCXSF1->F1_CNEEBUY
				M->F1_CNORCOD	:= __LOCXSF1->F1_CNORCOD
				M->F1_CNORBR	:= __LOCXSF1->F1_CNORBR
				M->F1_CNEECOD	:= __LOCXSF1->F1_CNEECOD
				M->F1_CNEEBR	:= __LOCXSF1->F1_CNEEBR
				M->F1_CONUNI	:= __LOCXSF1->F1_CONUNI
				M->F1_F5QUID    := __LOCXSF1->F1_F5QUID
				M->F1_CNTID		:= __LOCXSF1->F1_CNTID
				M->F1_F5QDESC   := Iif(!EMPTY(__LOCXSF1->F1_F5QUID),Posicione("F5Q",1,XFILIAL("F5Q")+__LOCXSF1->F1_F5QUID,"F5Q_DESCR"),"")
			EndIf
			nTaxaPed		:= Iif(cTipConv=='1',Iif(__LOCXSF1->F1_TXMOEDA=0,RecMoeda(__LOCXSF1->F1_EMISSAO,__LOCXSF1->F1_MOEDA),__LOCXSF1->F1_TXMOEDA),RecMoeda(dDatabase,__LOCXSF1->F1_MOEDA))
			lMoedaDif	:=	__LOCXSF1->F1_MOEDA<>nMoedRec
			For nJ := 1 to Len(aFiltro)
				If aFiltro[nJ][1] == __LOCXSF1->(F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO)
					If lZeraCols
						aCols		:= {}
						lZeraCols	:= .F.
						MaFisClear()
						AAdd(aCols,Array(Len(aHeader)+1))
					Else
						If ( nCod > 0  .AND.  !Empty(aCOLS[Len(aCols)][nCod]))
							AAdd(aCols,Array(Len(aHeader)+1))
						EndIf
					EndIf
			 		aCols[Len(aCols)][Len(aHeader)+1]:=.F.
			 		DBSelectArea("SD1")
					SD1->(MsGoto(aFiltro[nJ][2]))
					DBSelectArea("SB1")
					SB1->(MsSeek(xFilial("SB1")+SD1->D1_COD))
					lPedido := .F.
					DBSelectArea("SC7")
					SC7->(dbSetOrder(1)) // C7_FILIAL+C7_NUM+C7_ITEM
					If SC7->(MsSeek(xFilial("SC7")+SD1->D1_PEDIDO+SD1->D1_ITEMPC,.F.))
						lPedido:=.T.
					EndIf
					cItem	:=	Soma1(cItem)
					nValAcols:=Len(aCols)
					//.. Atualiza o aRatCC com rateio do PC
					aHeaderSDE:=HeaderSDE(aHeaderSDE)
					RateioRemFac(aHeaderSDE,@aRatCC,cItem,aFiltro[nJ][2])

					If (nDescri  >  0  ,  aCOLS[Len(aCols)][nDescri ] := SD1->D1_DESCRI ,)
					If (nItemRem >  0  ,  aCOLS[Len(aCols)][nItemRem] := SD1->D1_ITEM   ,)
					If (nUm      >  0  ,  aCOLS[Len(aCols)][nUm     ] := SD1->D1_UM     ,)
					If (nSegum   >  0  ,  aCOLS[Len(aCols)][nSegum  ] := SD1->D1_SEGUM  ,)
					If (nCod     >  0  ,  aCOLS[Len(aCols)][nCod    ] := SD1->D1_COD	  ,)
					If (nSeriRem >  0  ,  aCOLS[Len(aCols)][nSeriRem] := SD1->D1_SERIE  ,)
					If (nLocal   >  0  ,  aCOLS[Len(aCols)][nLocal  ] := SD1->D1_LOCAL  ,)
					If (nQuant   >  0  ,  aCOLS[Len(aCols)][nQuant  ] := SD1->D1_QTDACLA,)
					If (nRemito  >  0  ,  aCOLS[Len(aCols)][nRemito ] := SD1->D1_DOC	  ,)
					If (nItem    >  0  ,  aCOLS[Len(aCols)][nItem   ] := cItem ,)
					If (nTes     >  0  ,  aCOLS[Len(aCols)][nTes    ] := SD1->D1_TES    ,)
					If (nCF      >  0  ,  aCOLS[Len(aCols)][nCF     ] := SD1->D1_CF     ,)
					If (nLOTEFOR >  0  ,  aCOLS[Len(aCols)][nLOTEFOR] := SD1->D1_LOTEFOR,)
					If (nLOTECTL >  0  ,  aCOLS[Len(aCols)][nLOTECTL] := SD1->D1_LOTECTL,)
					If (nNUMLOTE >  0  ,  aCOLS[Len(aCols)][nNUMLOTE] := SD1->D1_NUMLOTE,)
					If (nDTVALID >  0  ,  aCOLS[Len(aCols)][nDTVALID] := SD1->D1_DTVALID,)
					If (nProvEnt >  0  ,  aCOLS[Len(aCols)][nProvEnt] := SD1->D1_PROVENT,)
					If (nIPI     >  0  ,  aCOLS[Len(aCols)][nIPI    ] := SD1->D1_IPI    ,)
					If (nQtSegUm >  0  ,  aCOLS[Len(aCols)][nQtSegUm] := SD1->D1_QTSEGUM,)
					If (nConta   >  0  ,  aCOLS[Len(aCols)][nConta  ] := If(!Empty(SD1->D1_CONTA),SD1->D1_CONTA,SB1->B1_CONTA),)
					If (nCCusto  >  0  ,  aCOLS[Len(aCols)][nCCusto ] := If(!Empty(SD1->D1_CC),SD1->D1_CC,SB1->B1_CC),)
					If (nItConta >  0  ,  aCOLS[Len(aCols)][nItConta] := SD1->D1_ITEMCTA,)
					If (nClValor >  0  ,  aCOLS[Len(aCols)][nClValor] := SD1->D1_CLVL,)
					If (nRat     >  0  ,  aCOLS[Len(aCols)][nRat    ] := SD1->D1_RATEIO,)
					If (nPedido  >  0  ,  aCOLS[Len(aCols)][nPedido ] := SD1->D1_PEDIDO,)
					If (nOrdProd >  0  ,  aCOLS[Len(aCols)][nOrdProd] := SD1->D1_OP,)
			 		If (nItemPC  >  0  ,  aCOLS[Len(aCols)][nItemPC ] := SD1->D1_ITEMPC,)
			    	If (nFornece >  0  ,  aCOLS[Len(aCols)][nFornece] := SD1->D1_FORNECE,)
					If (nLojaForn>  0  ,  aCOLS[Len(aCols)][nLojaForn] := SD1->D1_LOJA,)
					If (nFDESC   >  0  ,  aCOLS[Len(aCols)][nFDESC  ] := SD1->D1_FDESC,)
					If (lCondicao .And. !Empty(__LOCXSF1->F1_COND), cCondicao := __LOCXSF1->F1_COND,)

					If cPaisLoc == "CHI"
						If (nFEPP    >  0  ,  aCOLS[Len(aCols)][nFEPP   ] := SD1->D1_FEPP   ,)
						If (nIE      >  0  ,  aCOLS[Len(aCols)][nIE     ] := SD1->D1_IE     ,)
					EndIf
					If nTpActiv > 0
						aCOLS[Len(aCols)][nTpActiv ] := SD1->D1_TPACTIV
					EndIf
					If nCodMun > 0
						aCOLS[Len(aCols)][nCodMun ] := SD1->D1_CODMUN
					EndIf
					nTaxaNF		:= Iif(MaFisRet(,'NF_TXMOEDA')==0,Recmoeda(dDatabase,M->F1_MOEDA),MaFisRet(,'NF_TXMOEDA'))
					nTaxaPed		:= Iif(cTipConv=='1',Iif(__LOCXSF1->F1_TXMOEDA=0,RecMoeda(__LOCXSF1->F1_EMISSAO,__LOCXSF1->F1_MOEDA),__LOCXSF1->F1_TXMOEDA),RecMoeda(dDatabase,__LOCXSF1->F1_MOEDA))
					If nVUnit   >  0
						If SD1->D1_VUNIT <> 0
							If cPaisLoc == "BOL"
								nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,TAMSX3("D1_VUNIT")[2],nTaxaPed,nTaxaNF)
							ELSE
								nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
								If cPaisloc=="ARG" .AND. (cMvDescSai == '2') .and. Alltrim(aCfgNF[8]) == "NCC"
									nPrecio += (SD1->D1_VALDESC / SD1->D1_QUANT)
								EndIf
							endIf
						Else
							If ! Empty(SD1->D1_PEDIDO)
								nPrecio := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
							Else
								nPrecio := RetFldProd(SB1->B1_COD,"B1_UPRC")
								If M->F1_MOEDA<>1 .And. M->F1_TXMOEDA<>0
									nPrecio:=NoRound(nPrecio / M->F1_TXMOEDA,TamSX3("D1_VUNIT")[2])
								EndIf
							EndIf
						EndIf
						aCOLS[Len(aCols)][nVunit] := nPrecio
					EndIf
					If nTotal > 0
						IF SD1->D1_VUNIT <> 0
							If cPaisLoc == "BOL"
								nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,TAMSX3("D1_VUNIT")[2],nTaxaPed,nTaxaNF)
							Else
								nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
								If cPaisloc=="ARG" .AND. (cMvDescSai == '2') .and. Alltrim(aCfgNF[8]) == "NCC"
									nPrecio += (SD1->D1_VALDESC / SD1->D1_QUANT)
								EndIf
							EndIf
						ELSE
							IF .NOT. EMPTY(SD1->D1_PEDIDO)
								nPrecio := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
							ELSE
								nPrecio := RetFldProd(SB1->B1_COD,"B1_UPRC")
								If M->F1_MOEDA<>1 .And. M->F1_TXMOEDA<>0
									nPrecio:=NoRound(nPrecio / M->F1_TXMOEDA,TamSX3("D1_VUNIT")[2])
								EndIf
								aCOLS[Len(aCols)][nVunit] := nPrecio
							EndIf
						ENDIF
						aCOLS[Len(aCols)][nTotal] := (nPrecio * SD1->D1_QTDACLA)
						// Verificação para previnir diferença de centavos quando do retorno da função MaColsToFis
						If TamSx3("D1_TOTAL")[2] == 2
							nVlTotal := 0
							nDifRem := 0.01
							nVlTotal := Round((nPrecio * SD1->D1_QTDACLA),2)
							If ABS(nVlTotal - SD1->D1_TOTAL) == nDifRem
								nVlTotal := SD1->D1_TOTAL
							EndIf
							aCOLS[Len(aCols)][nTotal] := nVlTotal
						EndIf
					Endif
					If cPaisloc == "RUS"	//(19/07/18): value from items of remito invoice
						aCols[Len(aCols)][nBsImp1M] := SD1->D1_BSIMP1M
						aCols[Len(aCols)][nVlImp1M] := SD1->D1_VLIMP1M
						aCols[Len(aCols)][nTotalM] := SD1->D1_TOTALM
					EndIF
					IF cPaisloc == "ARG" .and. lWmsNew
						aCols[Len(aCols)][nServic] := SD1->D1_SERVIC
						aCols[Len(aCols)][nUbica] := SD1->D1_ENDER
					EndIF
					If nDesc > 0
						IF SD1->D1_VALDESC <> 0 .And. Iif(lValDesc, .T., !(SuperGetMv("MV_DESCSAI",,"1") == "1"))
							If SD1->D1_QTDACLA == SD1->D1_QUANT
								If lMoedaDif
									aCols[nValAcols][nDesc] :=xMoeda(SD1->D1_VALDESC,__LOCXSF1->F1_MOEDA,nMoedRec,M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
								Else
									aCols[nValAcols][nDesc] :=SD1->D1_VALDESC
								EndIf
							Else
								If lMoedaDif
									aCols[nValAcols][nDesc] :=xMoeda(SD1->D1_VALDESC*SD1->D1_QTDACLA/SD1->D1_QUANT,__LOCXSF1->F1_MOEDA,nMoedRec,M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
								Else
									aCols[nValAcols][nDesc] :=SD1->D1_VALDESC*SD1->D1_QTDACLA/SD1->D1_QUANT
								EndIf
							Endif
						Else
							If lPedido
								IF (cPaisLoc $ "ARG|PAR|URU|CHI|BOL")
									lMoedaDif := SC7->C7_MOEDA <> nMoedRec
									IF lMoedaDif
										nTaxaPed := iIF (SC7->C7_TXMOEDA <> 0 , SC7->C7_TXMOEDA, IIF(RecMoeda(SC7->C7_EMISSAO,SC7->C7_MOEDA) <> 0, RecMoeda(SC7->C7_EMISSAO,SC7->C7_MOEDA) , 1) )
									EndiF
								EndIf
								If SD1->D1_QTDACLA == SC7->C7_QUANT
									If lMoedaDif
										aCols[nValAcols][nDesc] :=xMoeda(SC7->C7_VLDESC,SC7->C7_MOEDA,nMoedRec,M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
									Else
								   		aCols[nValAcols][nDesc] :=SC7->C7_VLDESC
									EndIf
								Else
									If lMoedaDif
										If cPaisLoc == "ARG" .And. procname() == "SCMTOREM" .And.  Alltrim(SD1->D1_ESPECIE) == "RCN"
											aCols[nValAcols][nDesc] :=xMoeda((SC7->C7_VLDESC/SC7->C7_QUANT)*SD1->D1_QTDACLA ,SC7->C7_MOEDA,nMoedRec,M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
										Else
											aCols[nValAcols][nDesc] :=xMoeda(SC7->C7_VLDESC*SC7->C7_QUANT/SD1->D1_QTDACLA ,SC7->C7_MOEDA,nMoedRec,M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
										Endif
									Else
										If cPaisLoc $ "ARG|BOL" .And. procname() == "SCMTOREM" .And.  Alltrim(SD1->D1_ESPECIE) == "RCN"
											aCols[nValAcols][nDesc] :=(SC7->C7_VLDESC/SC7->C7_QUANT) * SD1->D1_QTDACLA
										Else
											aCols[nValAcols][nDesc] :=SC7->C7_VLDESC*SC7->C7_QUANT/SD1->D1_QTDACLA
										Endif
									EndIf
								Endif
							EndIf
						EndIf
					Endif
					If nPorDesc	 > 0
						If SD1->D1_DESC <> 0
							aCOLS[Len(aCols)][nPorDesc ] := SD1->D1_DESC
						Else
							dbSelectArea("SC7")
							dbSetOrder(1)
							If SC7->(MsSeek(xFilial("SC7")+SD1->D1_PEDIDO+SD1->D1_ITEMPC,.F.))
								aCols[Len(aCols)][nPorDesc] := SC7->C7_DESC
							EndIf
						Endif
					Endif
					cPet := LocxPEt(35)
					If !Empty(cPet)
						ExecTemplate(cPEt,.F.,.F.,)
					EndIf
					cPe	:=	LocxPE(35)
					If !Empty(cPe)
						Execblock(cPE,.F.,.F.,)
					EndIf
					AEval(aHeader,{|x,y| If(!(x[10] == "V") .and. aCols[nValAcols][y]==NIL,aCols[nValAcols][y]:=CriaVar(x[2]),) })	//OPTIMIZA...
					If cPaisLoc == "MEX"
						aAdd( aRecSD1 , SD1->(RecNo()) )
						lOtros := lOtros .Or. SD1->(D1_VALFRE + D1_DESPESA + D1_VALDESC + D1_SEGURO) <> 0
					Else		//...OPTIMIZA
						If lActBrow
							IIf(cPaisLoc == "COL" .And. nCF>0, cCFO := aCols[Len(aCols)][nCF],)
							MaColsToFis(aHeader,aCols,Len(aCols),"MT100",.T.)
							If cPaisLoc == "COL"
								LxVldCFCol(aCols, cCFO, Len(aCols), nCF)
							EndIf
							MafisAlt('IT_FRETE'		,SD1->D1_VALFRE		,Len(aCols))
							MafisAlt('IT_DESPESA'	,SD1->D1_DESPESA	,Len(aCols))
							MafisAlt('IT_DESCONTO'	,IIf(nDesc > 0,aCols[Len(aCols)][nDesc], SD1->D1_VALDESC)	,Len(aCols))
							MafisAlt('IT_SEGURO'	,SD1->D1_SEGURO		,Len(aCols))
						EndIf
					EndIf
					nFrete   += SD1->D1_VALFRE
					nDespesa += SD1->D1_DESPESA
					nDescont += SD1->D1_VALDESC
					nSeguro  += SD1->D1_SEGURO

					//(18/07/18):Value from items of remito invoice
					If cPaisloc == "RUS"
						aCols[Len(aCols)][nBsImp1M] := SD1->D1_BSIMP1M
						MafisAlt('IT_BASEIV1_C1',	SD1->D1_BSIMP1M,	Len(aCols))
						aCols[Len(aCols)][nVlImp1M] := SD1->D1_VLIMP1M
						MafisAlt('IT_VALIV1_C1'	,	SD1->D1_VLIMP1M,	Len(aCols))
						aCols[Len(aCols)][nTotalM] := SD1->D1_TOTALM
					EndIF
				EndIf
			Next nJ
		Next nI

		If cPaisLoc == "COL" .And. FunName() == "MATA101N" .And. SF1->(ColumnPos("F1_TPACTIV"))
			MaFisRef("NF_TPACTIV", "MT100", M->F1_TPACTIV)
		EndIf

		If MaFisFound() .and. Len(aRecSD1) > 0		//OPTIMIZA...
			MaColsToFis(aHeader,aCols,,"MT100",.T.)
			If lOtros
				For nI := 1 To Len(aRecSD1)
					SD1->(MsGoto(aRecSD1[nI]))
					MafisAlt('IT_FRETE'		,SD1->D1_VALFRE		,nI)
					MafisAlt('IT_DESPESA'	,SD1->D1_DESPESA	,nI)
					MafisAlt('IT_DESCONTO'	,IIf(nDesc > 0,aCols[nI][nDesc], SD1->D1_VALDESC)	,nI)
					MafisAlt('IT_SEGURO'	,SD1->D1_SEGURO		,nI)
				Next nI
			EndIf
		EndIf
		CursorArrow()			//...OPTIMIZA
	EndIf
	If cPaisLoc == "ARG" .and. lActBrow
		MaFisReprocess(2)
	EndIf
	// Atualizar pasta Gastos com base nos itens do Remito
	If nFrete > 0 .And. ValType(F1_FRETE) == "N"
		M->F1_FRETE := SF1->F1_FRETE + nFrete
	EndIf
	If nSeguro > 0	.And. ValType(F1_SEGURO) == "N"
		M->F1_SEGURO := SF1->F1_SEGURO + nSeguro
	EndIf
	If nDespesa > 0	.And. ValType(F1_DESPESA) == "N"
		M->F1_DESPESA := SF1->F1_DESPESA + nDespesa
	EndIf
	If nDescont > 0 .And. ValType(F1_DESCONT) == "N"
		M->F1_DESCONT := SF1->F1_DESCONT + nDescont
	EndIf

	If lActBrow
		Eval(bDoRefresh)
		oGetDados:obrowse:refresh()
	EndIf
	AtuLoadQt()
EndIf
If oTmpRemito <> Nil
	oTmpRemito:Delete()
	FreeObj(oTmpRemito)
	oTmpRemito := Nil
EndIf
RestArea(aArea)
Return .T.
/*
Programa  ³PcoLancto Data ³  11/07/05
Desc.     ³rotina para contabilizacao no modulo sigapco
*/
Static Function PcoLancto(cAliasCab, cAliasDet,nRecnoCab,aRecnoItens,cProcesso,aItemInclProc,aItemExclProc,cProgram, lInclui, lDeleta, lRet)
Local nX		:= 0
Local aAreaCab	:= (cAliasCab)->(GetArea())
Local aAreaDet	:= (cAliasDet)->(GetArea())
Local lPrcs 	:= cProcesso == "000307" .AND. cPaisLoc $ "MEX|COL|PER|EQU"
//Local nPos		:= 0
//Local nPosItem	:= aScan(aHeader,{|x| AllTrim(x[2]) == IIf(cAliasCab == "SF2", "D2_ITEM", "D1_ITEM")})

DEFAULT lInclui	:= .F.
DEFAULT lDeleta	:= .F.
Default lRet	:= .T.


	dbSelectArea(cAliasCab)
	MsGoto(nRecnoCab)
	//Inicializa a gravacao dos lanç. do SIGAPCO
	PcoIniLan(cProcesso)
	dbSelectArea(cAliasDet)

	If (cProcesso == "000306" .Or. lPrcs) .And. (aItemExclProc[1] == "02" .Or. aItemExclProc[2] == "04")
		For nX := 1 TO Len(aRecnoItens)
			MsGoto(aRecnoItens[nX,1])
			//por item (aItemInclProc[1])
			If !Empty(aItemInclProc[1])
				PcoDetLan(cProcesso,aItemInclProc[1],cProgram,lDeleta)
			EndIf
		Next nX
		dbSelectArea(cAliasCab)
		MsGoto(nRecnoCab)
		If !Empty(aItemInclProc[2])
			PcoDetLan(cProcesso,aItemInclProc[2],cProgram,lDeleta)
		EndIf
	Else
		If lInclui
			For nX := 1 TO Len(aRecnoItens)
				MsGoto(aRecnoItens[nX,1])
				//por item (aItemInclProc[1])
				If !Empty(aItemInclProc[1])
					PcoDetLan(cProcesso,aItemInclProc[1],cProgram)
				EndIf
			Next nX
			dbSelectArea(cAliasCab)
			MsGoto(nRecnoCab)
			//por total (aItemInclProc[2])
			If !Empty(aItemInclProc[2])
				PcoDetLan(cProcesso,aItemInclProc[2],cProgram)
			EndIf
		ElseIf lDeleta
			For nX := 1 TO Len(aRecnoItens)
				MsGoto(aRecnoItens[nX,1])
				//por item (aItemExclProc[1])
				If !Empty(aItemExclProc[1])
					PcoDetLan(cProcesso,aItemExclProc[1],cProgram, aItemExclProc[1]==aItemInclProc[1] )
				EndIf
			Next nX
			dbSelectArea(cAliasCab)
			MsGoto(nRecnoCab)
			//por total (aItemExclProc[2])
			If !Empty(aItemExclProc[2])
				PcoDetLan(cProcesso,aItemExclProc[2],cProgram, aItemExclProc[2]==aItemInclProc[2] )
			EndIf
		EndIf
	EndIf


//³ Finaliza a gravacao dos lanç. do SIGAPCO            ³
PcoFinLan(cProcesso)
RestArea(aAreaDet)
RestArea(aAreaCab)
Return
/*
Programa  ³PcoCarregaLancto Data ³ 06/07/05
Desc.     ³Carregar array com os lanç do modulo sigaPco para
          ³alimentar array acfgnf para posterior uso PcoLancto()
*/
Static Function PcoCarregaLancto(nTipo, nOpcx)
//Retorna array com 03 posicoes
//onde 1a. pos. = processo_pco (lancto padrao do pco)
//QUANDO ROTINA FOR INCLUSAO
//     2a. pos. = array com na pos. 1 - item processo (detalhe-item)
//                                     pos. 2 - item processo  (cabeca-total)
//     3a. pos. = nome do programa que gerou o lancto no pco
//QUANDO ROTINA FOR EXCLUSAO
//     4a. pos. = array com na pos. 1 - item processo (EXCLUSAO detalhe-item)
//                                     pos. 2 - item processo  (EXCLUSAO cabeca-total)
Local aPcoLanc := {NIL/*processo_pco*/, NIL /*Inclusao*/, NIL/*nome do programa*/, NIL/*Exclusao*/}
	Do Case
		//Nota de Venta - Especificos EQUADOR - RCTI - Australia - Adiantamento - Traslado - Mexico
		Case nTipo==1 .Or. nTipo == 17 .OR. nTipo == 18 .OR. nTipo == 19 .OR. nTipo == 21
			//mata467
		    aPcoLanc[1] := "000300"
		    aPcoLanc[3] := "MATA467N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==2
			//mata465
			aPcoLanc[1] := "000308"
		    aPcoLanc[3] := "MATA465N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==3
			//mata465
			aPcoLanc[1] := "000308"
		    aPcoLanc[3] := "MATA465N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==4 .Or. nTipo==24
			//mata465
			aPcoLanc[1] := "000309"
		    aPcoLanc[3] := "MATA465N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==5
			//mata465
			aPcoLanc[1] := "000309"
		    aPcoLanc[3] := "MATA465N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==6
			//mata466
			aPcoLanc[1] := "000310"
		    aPcoLanc[3] := "MATA466N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==7 .OR. nTipo==22
			//mata466
			aPcoLanc[1] := "000311"
		    aPcoLanc[3] := "MATA466N"
			aPcoLanc[2] := {"03", "04"}
			aPcoLanc[4] := {"03", "04"}
		Case nTipo==8
			//mata466
			aPcoLanc[1] := "000311"
		    aPcoLanc[3] := "MATA466N"
			aPcoLanc[2] := {"01", "02"}
			aPcoLanc[4] := {"01", "02"}
		Case nTipo==9 .OR. nTipo==23
			//mata466
			aPcoLanc[1] := "000310"
		    aPcoLanc[3] := "MATA466N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==10 .Or. nTipo == 20 //Adiantamento - Peru
			//mata101
			aPcoLanc[1] := "000306"
		    aPcoLanc[3] := "MATA101N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		//Beneficiamento
		Case nTipo == 11
			//Mata467
		    aPcoLanc[1] := "000300"
		    aPcoLanc[3] := "MATA467N"
			aPcoLanc[2] := {"05", "07"}
			aPcoLanc[4] := {"05", "07"}
		Case nTipo == 12
			//Mata101
			aPcoLanc[1] := "000306"
		    aPcoLanc[3] := "MATA101N"
			aPcoLanc[2] := {"05", "07"}
			aPcoLanc[4] := {"06", "08"}
		Case nTipo	==	13
			//MATA119
			aPcoLanc[1] := "000306"
		    aPcoLanc[3] := "MATA101N"
   			aPcoLanc[2] := {"09", "11"}
			aPcoLanc[4] := {"10", "12"}
		Case nTipo	==	14
			//MATA116
			aPcoLanc[1] := "000306"
		    aPcoLanc[3] := "MATA101N"
			aPcoLanc[2] := {"13", "15"}
			aPcoLanc[4] := {"14", "16"}
		Case nTipo==15
			//mata463
			aPcoLanc[1] := "000312"
		    aPcoLanc[3] := "MATA463N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
	     //Remitos (facturacion)
		Case nTipo == 50
			//Mata462
		    aPcoLanc[1] := "000301"
		    aPcoLanc[3] := "MATA462N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 51
			//Mata462D Proprio
			aPcoLanc[1] := "000302"
		    aPcoLanc[3] := "MATA462DN"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 52
			//Mata462
		    aPcoLanc[1] := "000301"
		    aPcoLanc[3] := "MATA462N"
			aPcoLanc[2] := {"05", "07"}
			aPcoLanc[4] := {"06", "08"}
		Case nTipo == 53
			//Mata462 Doc nao proprio
			aPcoLanc[1] := "000302"
		    aPcoLanc[3] := "MATA462DN"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 54 // Remito de transf. Saida
			//Mata462
			aPcoLanc[1] := "000304"
		    aPcoLanc[3] := "MATA462TN"
			aPcoLanc[2] := {"05", "07"}
			aPcoLanc[4] := {"06", "08"}
		Case nTipo==55
			//mata462G
		    aPcoLanc[1] := "000300"
		    aPcoLanc[3] := "MATA462G"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		 //Remitos (Compras)
		Case nTipo == 60
			//Mata102
			aPcoLanc[1] := "000307"
		    aPcoLanc[3] := "MATA102N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 61
			//Mata102
			aPcoLanc[1] := "000305"
		    aPcoLanc[3] := "MATA102DN"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 62
			//Mata102
			aPcoLanc[1] := "000307"
		    aPcoLanc[3] := "MATA102N"
			aPcoLanc[2] := {"05", "07"}
			aPcoLanc[4] := {"06", "08"}
		Case nTipo == 63
			//Retorno SIMBOLICO
			aPcoLanc[1] := "000303"
		    aPcoLanc[3] := "MATA462R"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 64
			aPcoLanc[1] := "000304"
		    aPcoLanc[3] := "MATA462TN"
	   		aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo==65
			//mata103N
			aPcoLanc[1] := "000306"
		    aPcoLanc[3] := "MATA103N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
	EndCase
Return aPcoLanc
/*
Descri‡…o ³ Utilizacao de menu Funcional
Retorno   ³Array com opcoes da rotina.
Parametros³Parametros do array a Rotina:
          ³1. Nome a aparecer no cabecalho
          ³2. Nome da Rotina associada
          ³3. Reservado
          ³4. Tipo de Transa‡„o a ser efetuada:
          ³	  1 - Pesquisa e Posiciona em um Banco de Dados
          ³    2 - Simplesmente Mostra os Campos
          ³    3 - Inclui registros no Bancos de Dados
          ³    4 - Altera o registro corrente
          ³    5 - Remove o registro corrente do Banco de Dados
          ³5. Nivel de acesso
          ³6. Habilita Menu Funcional
*/
Static Function MenuDef()
Local aAddOpc := {}
Local lCfgNf := .T.

cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(FunName())),cFunName)

Private aRotina := {}

If Type("aCfgNf") == "A"
	lCfgNf := (aCfgNf[SnTipo] <> 24) .Or. (cFunName $ "MATA465N|MATA467N" .And. lLocxAuto .And. aCfgNf[SnTipo] == 24)
EndIf

DBSELECTAREA("SF1")
aAdd(aRotina,{STR0022,"LocxPesq(bFilBrw,1)"	, 0 , 1 , 0 , .F. })  		  // "Pesquisar"
aAdd(aRotina,{STR0023,"LocxDlgNF(aCfgNF,2)"	, 0 , 2 , 0 , NIL })	      // "Visualizar"

If lCfgNf
	aAdd(aRotina,{STR0024,"LocxDlgNF(aCfgNF,3,bFilBrw)"	, 0 , 3 , 0 , NIL})  // "Incluir"
EndIf

If ((cFunName $ "MATA467N") .And. (cPaisLoc == "RUS"))
	aAddOpc := {{STR0368, "RU09T02Add(.T.)", 0, 4, 0, Nil},;
			{STR0369, "RU09T02act("+STR(MODEL_OPERATION_VIEW)+")", 0, 2, 0, Nil},;
			{STR0370, "RU09T02act("+STR(MODEL_OPERATION_UPDATE)+")", 0, 1, 0, Nil},;
			{STR0371, "RU09T02act("+STR(MODEL_OPERATION_DELETE)+")", 0, 1, 0, Nil}}

	aAdd(aRotina,{STR0373, aAddOpc, 0, MODEL_OPERATION_VIEW})
	aAdd(aRotina,;
		{STR0414, {;
        	{STR0368	, "RU05D01_17_CreateULCD(1,"+STR(MODEL_OPERATION_INSERT)+")", 0, 1}; // Add
        	, {STR0369	, "RU05D01_17_CreateULCD(1,"+STR(MODEL_OPERATION_VIEW)+")"	, 0, 1}; // View
        	, {STR0371	, "RU05D01_17_CreateULCD(1,"+STR(MODEL_OPERATION_DELETE)+")", 0, 1}; // Delete
        }, 0, MODEL_OPERATION_VIEW};
	)
	aAdd(aRotina,{STR0387, "RU05R01()", 0, 6, 0, NIL})
	aAdd(aRotina,{STR0391, "RU05R02()", 0, 7, 0, NIL})
Endif

If ((cFunName $ "MATA101N") .And. (cPaisLoc == "RUS"))
	aAddOpc := {{STR0368, "addF37ComInv(.T.)", 0, 4, 0, Nil},; //Add
			{STR0369, "RU09T03act("+STR(MODEL_OPERATION_VIEW)+")", 0, 2, 0, Nil},; 		//View
			{STR0370, "RU09T03act("+STR(MODEL_OPERATION_UPDATE)+")", 0, 1, 0, Nil},; 	//Change
			{STR0371, "RU09T03act("+STR(MODEL_OPERATION_DELETE)+")", 0, 1, 0, Nil}}		//Delete

	aAdd(aRotina,{STR0373, aAddOpc, 0, MODEL_OPERATION_VIEW})
Endif
Return(aRotina)
/*
Programa  ³LXDOCORI  Data ³ 04/10/2006
Desc.     ³Mostra as faturas que serao amarradas ao documento sendo di-
          ³gitado (devolucao)
Parametros³Parametros do array a Rotina:
          ³1. Si es Chile y se selecciono como doc ori NDC a la NCC.
*/
Function LxDocOri(lNDCChi)
Local aArea    		:= GetArea()
Local aSF2			:= SF2->(GetArea())
Local aSD2			:= SD2->(GetArea())
Local aCposF4		:= {}
Local aRecs    		:= {}
Local aRet     		:= {}
Local nI 			:= 0
//Local nJ 			:= 0
//Local nPosTotal		:= 0
//Local nPosTES		:= 0
//Local nPosQuant		:= 0
//Local nPosQtSegun	:= 0
//Local nPosValDesc	:= 0
Local nTaxaNf		:= 0
//Local nTaxaPed		:= 0
//Local nPorDesc		:= 0
Local nUm			:= 0
Local nSegUm		:= 0
Local nCod			:= 0
Local nLocal		:= 0
Local nQuant		:= 0
Local nNfOri		:= 0
Local nSeriOri		:= 0
Local nItemOri		:= 0
Local nItem			:= 0
Local nCodMun		:= 0
Local nTpActiv		:= 0
//Local Tes			:= 0
Local nCf			:= 0
Local nLoteCtl		:= 0
Local nNumLote		:= 0
Local nDtValid		:= 0
Local nVunit		:= 0
Local nTotal		:= 0
Local nQTSegum		:= 0
Local nConta		:= 0
Local nItemCta   	:= 0
Local nCCusto		:= 0
Local nDesc			:= 0
Local nValDesc		:= 0
Local nProvEnt 		:= 0
Local nClVl			:= 0
Local nForneD1		:= 0
Local nLojaD1		:= 0
Local nUniaduD1 	:= 0
Local nUsdaduD1 	:= 0
Local nValaduD1 	:= 0
Local nCanaduD1 	:= 0
Local nFraccaD1 	:= 0
Local nNICOD1	 	:= 0
//Local cCampo 		:= ""
Local cCondicao 	:= ""
Local cItem			:= ""
Local cTipoDoc 		:= ""
Local cCliFor		:= IIf(aCfgNF[SAliasHead]=="SF1",M->F1_FORNECE,M->F2_CLIENTE)
Local cLoja  		:= IIf(aCfgNF[SAliasHead]=="SF1",M->F1_LOJA,M->F2_LOJA)
Local cSeek  		:= ""
Local cWhile 		:= ""
Local cAliasCab		:= ""
Local cAliasItem	:= ""
Local cAliasTRB		:= ""
Local cQuery		:= ""
//Local cDoc			:= ""
//Local cSerDoc		:= ""
Local cFilSD		:= ""
//Local cTipConv		:= GetNewPar("MV_ALTTXNF",'1')
Local lLxDOrig		:= ExistBlock( "LXDORIG" )
Local lFiltroDoc	:= ExistBlock( "LxDocOri" )
Local lDescDVIt		:= .T.
Local lD2_PROVENT	:= .F.
Local cFilSB1		:= xFilial("SB1")
Local cFilSD2		:= xFilial("SD2")
Local cFilSF4		:= xFilial("SF4")
Local cDessai		:= SuperGetMV("MV_DESCSAI",.T.,'1')
Local cCFDUso		:= Alltrim(GetMv("MV_CFDUSO", .T., "1"))
Local aAreaSF4		:= {}
Local nCentavos		:= 0
//Local cCtrl			:= CHR(13) + CHR(10)
Local lUUID			:= cPaisLoc == "MEX" .and. aCfgNF[SnTipo] == 4 .and. funname()=="MATA465N" .And. cCFDUso <> "0"// Activa solo para México de lo contrario presentara comportamiento normal
//Local nPosUUID		:= 0
Local cFunName		:= FunName()
Local cCFO			:= ""
Local lAutTES		:= SuperGetMV("MV_AUTTES", .F., .T.) //Parametro que indica activacion de TES automatizada
Local aRecOri		:= {}
//Local cItemAux		:= ""
Local nItemAux		:= 0
Local nPosDocOri	:= 0
Local nTes          := 0
Local nLoteFor      := 0
Local oQrySD2 := Nil
Private aFiltro		:= {}
//Private aFilUUID   := {}
Private cCondUUID  := ""
If cPaisLoc == "ARG"
	Private aTESDcOri := {}
EndIf
Default lNDCChi := .F.

If nMoedaNF == 1
	nCentavos := SuperGetMV("MV_CENT",.F.,0)
Else
	nCentavos := SuperGetMV("MV_CENT"+AllTrim(Str(nMoedaNF)),.F.,0)
EndIf

If GetNewPar("MV_DESCDVI",.T.) == .F. .And. cPaisloc=="MEX" .And. AllTrim(cEspecie) <> "NDE"    // Soma o valor do desconto ao item
	lDescDVIt:=.F.
EndIf

If cPaisLoc == "COL"
	If !LxVldEncC(aCfgNF,cFunName)
		Return .F.
	EndIf
Else
	If Empty(cCliFor) .OR. Empty(cLoja)
		Aviso(cCadastro,STR0094,{STR0021}) //"Llene los datos del encabezado."###"OK"
		Return
	EndIf
EndIf

If FindFunction("LxCpDocOri") .And. !LxCpDocOri()//Valida campos usados
	Return
EndIf

For nI:=1 to Len(aHeader)
	Do Case
		Case  Alltrim(aHeader[nI][2]) == "D1_UM"
			nUm      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SEGUM"
			nSegUm   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_COD"
			nCod     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOCAL"
			nLocal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QUANT"
			nQuant   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_NFORI"
			nNfOri  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SERIORI"
			nSeriOri := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMORI"
			nItemOri := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEM"
			nItem    := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TES"
			nTes     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CF"
			nCf      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTEFOR"
			nLoteFor := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTECTL"
			nLoteCtl := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_NUMLOTE"
			nNumLote := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DTVALID"
			nDtValid := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VUNIT"
			nVunit   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TOTAL"
			nTotal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QTSEGUM"
			nQTSegum := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CONTA"
			nConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CC"
			nCCusto := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VALDESC"
			nValDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DESC"
			nDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_PROVENT"
			nProvEnt := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMCTA"
			nItemCta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CLVL"
			nClVl := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_FORNECE"
			nForneD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOJA"
			nLojaD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_UNIADU"
			nUniaduD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_USDADU"
			nUsdaduD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VALADU"
			nValaduD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CANADU"
			nCanaduD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_FRACCA"
			nFraccaD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_NICO"
			nNICOD1 := nI
		Case  cPaisLoc == "RUS" .And. Alltrim(aHeader[nI][2]) == "D1_TOTALM"
			nTotalM		:= nI
		Case cPaisLoc == "RUS" .And.  Alltrim(aHeader[nI][2]) == "D1_FDESC"
			nFdesc		:= nI
		Case cPaisLoc == "RUS" .And.  Alltrim(aHeader[nI][2]) == "D1_DESCRI"
			nDescri		:= nI
		Case cPaisLoc == "COL" .And.  Alltrim(aHeader[nI][2]) == "D1_CODMUN"
			nCodMun		:= nI
		Case cPaisLoc == "COL" .And.  Alltrim(aHeader[nI][2]) == "D1_TPACTIV"
			nTpActiv	:= nI		
	Endcase
Next nI
cAliasCab	:= "SF2"
cAliasItem	:= "SD2"
SX3->(DbSetOrder(1))
SX3->(DbSeek(cAliasCab))
While !SX3->(EOF()) .AND. SX3->X3_ARQUIVO == cAliasCab
	If SX3->X3_BROWSE == "S" .AND. cNivel >= SX3->X3_NIVEL
		AAdd(aCposF4,SX3->X3_CAMPO)
	Endif
	SX3->(DbSkip())
EndDo
If aCfgNF[SnTipo] == 4 .OR. aCfgNF[SnTipo] == 5 .OR. aCfgNF[SnTipo] == 53 .OR. aCfgNF[SnTipo] == 51
	// Se for Remito de devolucao (MATA462DN), seleciona apenas os remitos (F2_TIPODOC = "50"),
	//senao, seleciona as faturas (F2_TIPODOC = "01")
	If aCfgNF[SnTipo] == 53 .OR. aCfgNF[SnTipo] == 51		// Remito de Devolucao - MATA462DN (51=formulario proprio e 53=formulario nao proprio)
		cTipoDoc	:= '50'
	ElseIf lNDCChi
		cTipoDoc	:= '02'
	Else
		cTipoDoc	:= '01'
	EndIf

	cSeek  		:= "'" + xFilial(cAliasCab)+cCliFor+cLoja + "'"
	cWhile 		:= "SF2->(!EOF()) .AND. SF2->(F2_FILIAL+F2_CLIENTE+F2_LOJA)== " + cSeek
	cCondicao	:= "Ascan(aFiltro,SF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_TIPODOC)) > 0"
	cItem		:= aCols[Len(aCols),nItem]

	If !lUUID
		cQuery := "select distinct D2_FILIAL,D2_DOC,D2_SERIE,D2_CLIENTE,D2_LOJA,D2_TIPO,D2_TIPODOC,D2_ITEM"
		cQuery += " from " + RetSqlName("SD2") + " SD2 where "
		cQuery += " D2_FILIAL ='" + xFilial("SD2") + "'"
		cQuery += " and D2_CLIENTE = ? "
		cQuery += " and D2_LOJA = ? "
		cQuery += " and D2_TIPODOC in ( ? )"
		cQuery += " and D2_QUANT > D2_QTDEDEV"
		cQuery += " and SD2.D_E_L_E_T_ = ' ' "
		If cPaisLoc == "RUS"
			cQuery += " and SD2.D2_EMISSAO <=  '"+ DTOS(M->F1_EMISSAO) + "' "
		EndIf
	Else
		cQuery := " SELECT DISTINCT SD2.D2_FILIAL, SD2.D2_DOC, SD2.D2_SERIE, SD2.D2_CLIENTE, SD2.D2_LOJA, SD2.D2_TIPO, SD2.D2_TIPODOC, SD2.D2_ITEM,SF2.F2_UUID "
		cQuery += " FROM " + RetSqlName("SD2") + " SD2"
		cQuery += " JOIN "+RetSqlName("SF2")+" SF2"
		cQuery += " ON SF2.F2_DOC = SD2.D2_DOC"
		cQuery += " AND SF2.F2_SERIE = SD2.D2_SERIE"
		cQuery += " AND SF2.F2_CLIENTE = SD2.D2_CLIENTE"
		cQuery += " AND SF2.F2_LOJA = SD2.D2_LOJA"
		cQuery += " AND SF2.F2_CLIENTE = ? "
		cQuery += " AND SF2.F2_LOJA = ? "
		cQuery += " AND SD2.D2_QUANT > D2_QTDEDEV"
		cQuery += " AND SF2.F2_UUID <> ''"
		cQuery += " AND SD2.D2_FILIAL ='" + xFilial("SD2") + "'"
		cQuery += " AND SF2.D_E_L_E_T_ = ''"
		cQuery += " AND SD2.D_E_L_E_T_ = ''"
	EndIf

	oQrySD2 := FWPreparedStatement():New(cQuery)
	If !lUUID
		oQrySD2:SetString(1, cCliFor)
		oQrySD2:SetString(2, cLoja)
		oQrySD2:setIn(3, {cTipoDoc})
	Else
		oQrySD2:SetString(1, cCliFor)
		oQrySD2:SetString(2, cLoja)
	EndIf
	cQuery := oQrySD2:GetFixQuery()
	oQrySD2:Destroy()

	If lFiltroDoc
		cQuery := ExecBlock( "LxDocOri", .F., .F., { cQuery } )
	EndIf
	cQuery := ChangeQuery(cQuery)

	cAliasTRB := MpSysOpenQuery(cQuery)

	If lUUID
		LxUUIDRel(aCols, lUUID, @aFiltro, @aRet, nNFOri, nItemOri, cAliasTRB, cAliasCab, cWhile, cSeek, aCposF4, cTipoDoc, cCondicao)
    Else
		DbSelectArea(cAliasTRB)
		While (cAliasTRB)->(!Eof())
			nI := Ascan(aCols,{|x| x[nNFORI] == (cAliasTRB)->D2_DOC .AND. x[nItemOri] == (cAliasTRB)->D2_ITEM .AND. !x[Len(x)]})
			If nI == 0
				Aadd(aFiltro, (cAliasTRB)->D2_FILIAL + (cAliasTRB)->D2_DOC + (cAliasTRB)->D2_SERIE + (cAliasTRB)->D2_CLIENTE + (cAliasTRB)->D2_LOJA + (cAliasTRB)->D2_TIPODOC)
			Endif
			(cAliasTRB)->(DbSkip())
		EndDo
		(cAliasTRB)->(DbCloseArea())
	EndIf
Else
	Return
EndIf
If !Empty(aFiltro) .And. !lUUID
	aRet := LocxF4(cAliasCab,2,cWhile,cSeek,aCposF4,,IIf(cTipoDoc =='50',GetDescRem(),Iif(cTipoDoc =='02', STR0124, STR0223)),cCondicao,.T.,,,,,.F.)  // Retorn
ElseIf Empty(aFiltro)
	Help(" ",1,"A103F4")
	Return
EndIf
If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs := aRet[3]
EndIf
If ValType(aRecs)!="A" .OR. (ValType(aRecs)=="A" .AND. Len(aRecs)==0)
	Return
EndIf
SD2->(DbSetOrder(3))
cFilSD := cFilSD2
ProcRegua(Len(aRecs))

lD2_PROVENT	:=	cPaisLoc == "ARG"
For nI := 1 To Len(aRecs)
	SF2->(MsGoTo(aRecs[nI]))
	SD2->(DbSeek(cFilSD + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA))
	IncProc(STR0244 + "(" + SF2->F2_DOC + ")")
	While SD2->D2_FILIAL == cFilSD .AND. SD2->D2_DOC == SF2->F2_DOC .AND. SD2->D2_SERIE == SF2->F2_SERIE .AND. SD2->D2_CLIENTE == SF2->F2_CLIENTE .AND. SD2->D2_LOJA == SF2->F2_LOJA
		If SD2->D2_QUANT > SD2->D2_QTDEDEV
        	If Ascan(aCols,{|x| x[nNFORI] == SD2->D2_DOC .AND. x[nItemOri] == SD2->D2_ITEM .AND. !x[Len(x)]}) == 0
				nLenAcols := Len(aCols)
				If !Empty(aCols[nLenAcols,nCod])
					AAdd(aCols,Array(Len(aHeader)+1))
					nLenAcols := Len(aCols)
					cItem := Soma1(cItem)
				Endif
			 	aCols[nLenAcols][Len(aHeader)+1]:=.F.
				SB1->(MsSeek(cFilSB1+SD2->D2_COD))
				If (nUm      >  0  ,  aCOLS[nLenAcols][nUm     ] := SD2->D2_UM	,)
				If (nSegUm   >  0  ,  aCOLS[nLenAcols][nSegUm  ] := SB1->B1_SEGUM,)
				If (nCod     >  0  ,  aCOLS[nLenAcols][nCod    ] := SD2->D2_COD,)
				If cPaisLoc == "RUS"
					If (nDescri  >  0  ,  aCOLS[nLenAcols][nDescri ] := SD2->D2_DESCRI,)
					If (nFdesc   >  0  ,  aCOLS[nLenAcols][nFdesc  ] := SD2->D2_FDESC,)
				EndIf
				If (nLocal   >  0  ,  aCOLS[nLenAcols][nLocal  ] := SD2->D2_LOCAL,)
				If (nNfOri   >  0  ,  aCOLS[nLenAcols][nNfOri  ] := SD2->D2_DOC,)
				If (nSeriOri >  0  ,  aCOLS[nLenAcols][nSeriOri] := SD2->D2_SERIE,)
				If (nItemOri >  0  ,  aCOLS[nLenAcols][nItemOri] := SD2->D2_ITEM,)
				If (nItem    >  0  ,  aCOLS[nLenAcols][nItem   ] := cItem,)
				If (nConta   >  0  ,  aCOLS[nLenAcols][nConta  ] := SD2->D2_CONTA,)
	   			If (nCCusto  >  0  ,  aCOLS[nLenAcols][nCCusto ] := SD2->D2_CCUSTO,)
			   	If (nItemCta >  0  ,  aCOLS[nLenAcols][nItemCta] := SD2->D2_ITEMCC,)
			   	If (nClVl    >  0  ,  aCOLS[nLenAcols][nClVl]  	:= SD2->D2_CLVL,)
				If (nLoteCtl >  0  ,  aCOLS[nLenAcols][nLoteCtl] := SD2->D2_LOTECTL,)
				If (nNumLote >  0  ,  aCOLS[nLenAcols][nNumLote] := SD2->D2_NUMLOTE,)
				If (nDtValid >  0  ,  aCOLS[nLenAcols][nDtValid] := SD2->D2_DTVALID,)
				If (nQtSegUm >  0  ,  aCOLS[nLenAcols][nQtSegUm] := SD2->D2_QTSEGUM,)
				If (nForneD1 >  0  ,  aCOLS[nLenAcols][nForneD1] := SD2->D2_CLIENTE,)
				If (nLojaD1  >  0  ,  aCOLS[nLenAcols][nLojaD1]	 := SD2->D2_LOJA,)
				If (nUniaduD1 > 0  ,  aCOLS[nLenAcols][nUniaduD1]:= SD2->D2_UNIADU,)
				If (nUsdaduD1 > 0  ,  aCOLS[nLenAcols][nUsdaduD1]:= SD2->D2_USDADU,)
				If (nValaduD1 > 0  ,  aCOLS[nLenAcols][nValaduD1]:= SD2->D2_VALADU,)
				If (nCanaduD1 > 0  ,  aCOLS[nLenAcols][nCanaduD1]:= SD2->D2_CANADU,)
				If (nFraccaD1 > 0  ,  aCOLS[nLenAcols][nFraccaD1]:= SD2->D2_FRACCA,)
				If (nNICOD1 > 0    ,  aCOLS[nLenAcols][nNICOD1]	 := SD2->D2_NICO,)
				If (cPaisLoc == "COL" .And. nCodMun  >  0  ,  aCOLS[nLenAcols][nCodMun] := SD2->D2_CODMUN,)
				If (cPaisLoc == "COL" .And. nTpActiv >  0  ,  aCOLS[nLenAcols][nTpActiv]:= SD2->D2_TPACTIV,)
				//WMS - Gatilha os campos D1_SERVIC e D1_ENDER
				If nCod > 0 .And. FindFunction("WMSMT462DN") .And. IntWMS(aCols[nLenAcols][nCod])
					WMSMT462DN(aHeader, aCols, nLenAcols)
				EndIf

				nQtdeDev := SD2->D2_QUANT - SD2->D2_QTDEDEV
				If nQuant > 0
					aCols[nLenAcols,nQuant] := nQtdeDev
				Endif
				If nQtSegUm > 0
					aCols[nLenAcols,nQtSegUm] := ConvUm(SD2->D2_COD,nQtdeDev,0,2)
				Endif
				If cPaisLoc == "RUS"
					If Empty(cCondicao) .OR. RUXXTS05()
						M->F1_F5QUID	:= SF2->F2_F5QUID
						M->F1_CNTID 	:= SF2->F2_CNTID
						M->F1_F5QDESC   := Iif(!EMPTY(SF2->F2_F5QUID),Posicione("F5Q",1,XFILIAL("F5Q")+SF2->F2_F5QUID,"F5Q_DESCR"),"")
						M->F1_CNORSUP	:= SF2->F2_CNORVEN
						M->F1_CNEEBUY	:= SF2->F2_CNEECLI
						M->F1_CNORCOD	:= SF2->F2_CNORCOD
						M->F1_CNORBR	:= SF2->F2_CNORBR
						M->F1_CNEECOD	:= SF2->F2_CNEECOD
						M->F1_CNEEBR	:= SF2->F2_CNEEBR
						MaFisAlt("NF_MOEDA",SF2->F2_MOEDA)
						M->F1_MOEDA 	:= SF2->F2_MOEDA
						nMoedaNF		:= SF2->F2_MOEDA
						nMoedaCor		:= SF2->F2_MOEDA
						MaFisAlt("NF_TXMOEDA",SF2->F2_TXMOEDA)
						M->F1_TXMOEDA	:= SF2->F2_TXMOEDA
						M->F1_CONUNI	:= SF2->F2_CONUNI
						cCondicao	:= SF2->F2_COND
					EndIf
				EndIf
				If nTES <> 0
					SF4->(DbSetOrder(1))
					If SF4->(MsSeek(cFilSF4+SD2->D2_TES))
						If !Empty(SF4->F4_TESDV)
							aCols[nLenAcols][nTES] := SF4->F4_TESDV
							cCFO := Space(Len(SF4->F4_CF))
							If nCf > 0
								If cPaisLoc <> "COL"
									If cPaisLoc== "RUS"
										aCols[nLenAcols][nCf] :=SD2->D2_CF
									Else
										aAreaSF4 := SF4->(GetArea())
										cCFO := Posicione("SF4",1,xFilial("SF4")+SF4->F4_TESDV,"F4_CF")
										RestArea(aAreaSF4)
										aCols[nLenAcols][nCf] := cCFO
									EndIf
								Else
									cCFO := xObtCFOCol(lAutTES, cCliFor, cLoja, SD2->D2_COD, SF4->F4_TESDV, aHeader, aCols, nLenAcols, nCf, nTes, .F., cEspecie)
									EndIf
							EndIf
						EndIf
						If cPaisLoc == "ARG" .And. aScan(aTESDcOri,{|x| x == SF4->F4_TESDV }) == 0
							aAdd(aTESDcOri, SF4->F4_TESDV)
						EndIf
					Endif
				EndIf
				If cPaisloc == "RUS" .And. nCf > 0
					aCols[nLenAcols][nCf] := SD2->D2_CF
				Endif
				nTaxaNF := MaFisRet(,'NF_TXMOEDA')
				nTaxaNF := Iif(nTaxaNF == 0,Recmoeda(dDatabase,M->F1_MOEDA),nTaxaNF)
				If (SD2->D2_DESC > 0 .OR. SD2->D2_DESCON > 0) .AND. lDescDVIt
					If SD2->D2_PRUNIT <> SD2->D2_PRCVEN .And. SD2->D2_PRUNIT > 0
						If !(cPaisLoc $ "ARG|COL|PER|VEN|MEX|CHI") .OR. (cPaisLoc $ "COL|PER|VEN|MEX" .AND. cDessai == '2') //ARG|
							nPrecio := xMoeda(SD2->D2_PRUNIT,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
						ElseIf cPaisLoc $ "ARG" 	.AND. cDessai == '2'
							nPrecio := ( xMoeda(SD2->D2_PRCVEN,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF) + (SD2->D2_DESCON / SD2->D2_QUANT) )
						ElseIf cPaisLoc $ "ARG|COL|PER|VEN|MEX|CHI" .and. cDessai = '1'
							nPrecio := xMoeda(SD2->D2_PRCVEN,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
						Endif
					Else
	  				    If (cPaisLoc == "ARG" .and. cDessai == '2')
							nPrecio := Round(xMoeda(((SD2->D2_TOTAL + SD2->D2_DESCON)/nQtdeDev),SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF), nCentavos)
						Else
		  				    nPrecio := xMoeda(SD2->D2_PRCVEN,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
		  				    IF (cDessai == '2' .and. cPaisLoc $ "ARG|COL|PER|VEN|MEX") .or. !(cPaisLoc $ "ARG|PER|COL|VEN|MEX|EQU")
		  				    	If cPaisLoc <> "ARG"
		  				    		nPrecio += ((xMoeda(SD2->D2_DESCON,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF))/nQtdeDev)
		  				    	Else
		  				    		nPrecio += Round(((xMoeda(SD2->D2_DESCON,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF))/nQtdeDev), nCentavos)
		  				    	EndIf
		  				    Endif
						Endif
	  				EndIf
				Else
					nPrecio := xMoeda(SD2->D2_PRCVEN,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
				Endif
				If nVUnit > 0
					aCols[nLenAcols,nVUnit] := nPrecio
				EndIf
				If nTotal > 0
					If !(cPaisLoc $ "ARG|COL") .or. ((cPaisLoc $ "ARG|COL") .and. cDessai == '2')
						If (cPaisLoc $ "MEX|PER" .And. cDessai == '1') .And. cFunName $ "MATA465N"
							aCols[nLenAcols][nTotal] := SD2->D2_TOTAL
						Else
							If cPaisLoc $ "MEX|COL|PER"
								aCols[nLenAcols][nTotal] := NoRound(nPrecio, TamSX3("D2_TOTAL")[2]) * nQtdeDev
							Else
								aCols[nLenAcols][nTotal] := (nPrecio * nQtdeDev)
								If cPaisloc == "RUS"
									aCols[nLenAcols][nTotalM] := SD2->D2_TOTALM
								EndIf
							EndIf
						EndIf
					Else
						aCols[nLenAcols][nTotal] := xMoeda(SD2->D2_TOTAL ,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
					Endif
				Endif
				If nDesc > 0
					aCols[nLenAcols][nDesc] := SD2->D2_DESC
				Endif
				If nValDesc > 0
				    If nQtdeDev < SD2->D2_QUANT
						aCols[nLenAcols][nValDesc] := xMoeda((SD2->D2_DESCON/SD2->D2_QUANT)*nQtdeDev,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
					Else
						If nDesc > 0 .And. (cPaisLoc == "COL" .And. cDessai == '2')
							aCols[nLenAcols][nValDesc] := ((nPrecio * nQtdeDev)*SD2->D2_DESC)/100
						Else
							aCols[nLenAcols][nValDesc] := xMoeda(SD2->D2_DESCON,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
						Endif
					EndIf
				Endif
				If cPaisLoc == "ARG" .And. nProvEnt > 0 .And. lD2_PROVENT
					aCols[nLenAcols,nProvEnt] := SD2->D2_PROVENT
				Endif
				AEval(aHeader,{|x,y| If(aCols[nLenAcols][y]==NIL,aCols[nLenAcols][y]:=CriaVar(x[2]),) })
				If !(cPaisLoc == "ARG" .and. Len(aRecs) == 1)
					MaColsToFis(aHeader,aCols,nLenAcols,"MT100",.T.)
				EndIf
				If cPaisLoc == "COL" .And. cFunName <> "MATA462DN"
					LxVldCFCol(aCols, cCFO, nLenAcols, nCF)
				Else
					If !(cPaisLoc == "ARG" .and. Len(aRecs) == 1)
						MaFisAlt("IT_RECORI",SD2->(Recno()),nLenAcols)
					Else
						AADD(aRecOri,{aCols[nLenAcols][nNfOri], aCols[nLenAcols][nItemOri],SD2->(Recno())})
					EndIf
				EndIf
				//³ Dispara o ponto para cada item da NF        ³
				If lLxDOrig
					ExecBlock( "LXDORIG", .F., .F. )
				EndIf
			EndIf
		Endif
		SD2->(DbSkip())
	EndDo
Next nI
If cPaisLoc == "ARG"
	If (Len(aRecs) == 1)
		nItemAux := StrZero(0,Len(aCols[1][nItem]))
		aSort(aCols,,,{|x,y| x[nItemOri] < y[nItemOri] })
		aEval(aCols, {|x| nItemAux := soma1(nItemAux), x[nItem] := nItemAux })
		MaColsToFis(aHeader,aCols,,"MT100",.F.)
		For nItemAux := 1 To Len(aCols)
			nPosDocOri := Ascan(aRecOri,{|x| x[1] == aCols[nItemAux][nNfOri] .and. x[2] == aCols[nItemAux][nItemOri]})
			If nPosDocOri > 0
				MaFisAlt("IT_RECORI",aRecOri[nPosDocOri][3],nItemAux,,,,,.F.)
			EndIf
		Next nItemAux
	EndIf
	MaFisReprocess(2)
EndiF
oGetDados:lNewLine:=.F.
oGetDados:obrowse:refresh()
Eval(bDoRefresh)
AtuLoadQt()
RestArea(aSD2)
RestArea(aSF2)
RestArea(aArea)
Return
/*Funcao    ³LocTranSB2³  Data ³06.08.2007
Descri‡…o ³Atualiza o saldo da tabela SB2 - Armazem de transito
Parametros³nTipo    - 1 = Estorno RE4 / 2 = Estorno DE4
          ³cFilOrig - Codigo da Filial Origem*/
Function LocTranSB2(nTipo,cFilOrig)
Local cFilBack := cFilAnt
Local lRet     := .F.
Local lTranSB2 := SuperGetMv("MV_TRANSB2",.F.,.F.)
If lTranSB2
	If nTipo == 1
		lRet    := .T.
		// Altera filial corrente
		cFilAnt := cFilOrig
		// Gera movimento de estorno
		RecLock("SD3",.F.)
		Replace D3_TM			With "499"
		Replace D3_CF       	With "DE4"
		Replace D3_ESTORNO  	With "S"
		MsUnLock()
		// Atualiza o saldo atual (SB2) com os dados do SD3
		B2AtuComD3({D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5},Nil,Nil,.F.,Nil,.T.,.F.)
		// Apaga movimento de transferencia
		RecLock("SD3",.F.)
		DbDelete()
		MsUnlock()
		// Restaura filial Atual
		cFilAnt := cFilBack
	Else
		lRet    := .T.
		// Altera movimento para exclusao
		RecLock("SD3",.F.)
		Replace D3_TM			With "999"
		Replace D3_CF       	With "RE4"
		Replace D3_ESTORNO  	With "S"
		MsUnLock()
		// Atualiza o saldo atual (SB2) com os dados do SD3
		B2AtuComD3({D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5},Nil,Nil,.F.,Nil,.T.,.F.)
		// Apaga movimento de transferencia
		RecLock("SD3",.F.)
		DbDelete()
		MsUnlock()
	EndIf
EndIf
Return lRet

/*
Fun‡…o    ³IsLocTran  ³ Data ³06/08/07
Descri‡…o ³Verifica se o armazem passado como parametro e o armazem de
          ³transito utilizado na transferencia localizada.
Parametros³cArmazem - Codigo do Armazen
          ³lHelp    - Indica se deseja visualizar o help
 Retorno  ³lRet - Logico
*/
Function IsLocTran(cArmazem,lHelp)
Local lRet     := .F.
Local cDepTran := SuperGetMv("MV_DEPTRAN",.F.,"95")

Default cArmazem := ''
Default lHelp    := .T.

If cPaisLoc <> "BRA"
	If cDepTran == cArmazem
		If lHelp
			Help(" ",1,"DEPTRAN")
		EndIf
		lRet := .T.
	EndIf
EndIf
Return lRet
/*
Funcao    ³LxSomaImp ³ Data ³31/07/2007
Descri‡…o ³Prorateio de faturas tipo 9 e A:
          ³Cada pais pode gravar em um _VALIMP? diferente
Retorno   ³Somatoria dos campos D1_VALIMP1+D1_VALIMP2+...+D1_VALIMPN
*/
Static Function LxSomaImp(cTes)
Local aArea     := GetArea()
Local nValImpX  := 0
Local aImpostos := {}
Local nPosSWN   := 0
Local nY        := 0

Default cTes    := ""
aImpostos := DefImposto(cTes)
For nY:=1 to Len(aImpostos)
	nPosSWN := SWN->(FieldPos("WN_"+Substr(aImpostos[nY][2],1,7)))
	If nPosSWN > 0
		If ( aImpostos[nY][5] $ "S1" )
			nValImpX += SWN->(FieldGet(nPosSWN))
		EndIf
	EndIf
Next nY
RestArea(aArea)
Return(nValImpX)
/*
Fun‡„o    ³ LocConvNota³  Data ³ 18/04/08
Descri‡„o ³ Preenche o numero da NF com zeros a esquerda
          ³ mesmo quando o conteudo for alfanumerico
Sintaxe   ³ ExpC1 := LocConvNota(ExpC2,ExpC3)
Parametros³ ExpC2: Numero da nota
          ³ ExpC3: Tamanho do numero da nota
Retorno   ³ ExpC1 := N£mero da Moeda
*/
Function LocConvNota(cX5Descri,nTamNota)
Local cNumNota 	 := ""
Local cParcNum 	 := ""
DEFAULT nTamNota := Len( SF2->F2_DOC )

cParcNum := AllTrim( cX5Descri )
If cPaisLoc $ "PER|PAR"
	cNumNota := cParcNum
Else
	cNumNota := Replicate( "0",nTamNota - Len( cParcNum ) ) + cParcNum
EndIf


Return( cNumNota )

/*
Programa  ³axNFImpExpº
Desc.     ³Verifica se os campos de declaracao de export. e liquida-
          ³cao de importacao devem estar habilitados para digitacao.
*/
Function axNFImpExp(cTipo)
Local lRet := .F.

Do Case
//Validacao do SF1 e do SF2
Case cTipo == "1"
	//   Usa Cliente
	If aCfgNf[ScCliFor] == "SA1" .And. Alltrim(SA1->A1_EST) == "99"
		lRet := .T.
	Endif
	// Usa Fornec.
	If aCfgNf[ScCliFor] == "SA2" .And. Alltrim(SA2->A2_EST) == "99"
		lRet := .T.
	Endif
//Validacao do SC5
Case cTipo == "2"
	If 	M->C5_TIPO == 'N' .And. Alltrim(SA1->A1_EST) == "99" .Or. ;
		M->C5_TIPO == 'B' .And. Alltrim(SA2->A2_EST) == "99"
		lRet := .T.
	Endif
//Validacao do SC7
Case cTipo == "3"
	If 	Alltrim(SA2->A2_EST) == "99"
		lRet := .T.
	Endif
EndCase
Return lRet
/*
Programa  ³GRAVASEV  Data ³  07/08/08
Desc.     ³Efetua gravacao da multinatureza de acordo com os titulos fin
*/
Static Function GRAVASEV(cAliasFin,nValDUP)
//Local cPrefFin := IIf(!Empty(cAliasFin),cAliasFin+"->"+PrefixoCpo(cAliasFin),"")
Local nRateio  := 0
Local aArea    := GetArea()
Local lRet     := .F.
Local nY,nZ
Local nTEZ_PERC	:= TamSX3("EZ_PERC")[2]
Local aSEZ			:= {}
Local nPosSEZ		:= 0
Local nRateioSEZ	:= 0
Local cFilSEZ	:= xFilial("SEZ")
Local cFilSEV	:= xFilial("SEV")
Local lLxFunNatC := FindFunction("LxFunNatC")

If TYPE("aRatCC") == "U"
	 aRatCC := {}
ENDIF

if TYPE("AColsSEV") == "U"
	AColsSEV := {}
endif

If ( cAliasFin == "SE2" .and. !empty(aRatCC) )
	For nZ := 1 To Len(aRatCC[01,02])
		If ( nPosSEZ := aScan( aSEZ, { |x| x[01] == aRatCC[01,02,nZ,03] .and. x[02] == aRatCC[01,02,nZ,04] .and. x[03] == aRatCC[01,02,nZ,05] } ) ) == 0
			//C.C. - ItemClasse - Classe - Percentual - Valor
			aAdd( aSEZ, {aRatCC[ 01, 02, nZ, 03 ],aRatCC[ 01, 02, nZ, 04 ],aRatCC[ 01, 02, nZ, 05 ],aRatCC[ 01, 02, nZ, 02 ],0} )
		Else
			aSEZ[ nPosSEZ, 04 ] += aRatCC[ 01, 02, nZ, 02 ]
			aSEZ[ nPosSEZ, 05 ] += If ( !Empty(aRatCC[ 01, 02, nZ, 05 ]), aRatCC[ 01, 02, nZ, 05 ], 0 )
		EndIf
	Next
EndIf
dbSelectArea("SEV")
//Verifica multinatureza
For nY := 1 To Len(aColsSEV)
	If !aColsSEV[nY][Len(aColsSEV[1])] .And. !Empty(aColsSEV[nY][1])
		RecLock("SEV", .T. )
		For nZ := 1 To Len(aHeadSEV)
			If aHeadSEV[nZ][10]<>"V"
				SEV->(FieldPut(FieldPos(aHeadSEV[nZ][2]),aColsSEV[nY][nZ]))
			EndIf
		Next nZ
		SEV->EV_FILIAL   := cFilSEV
		If cAliasFin == "SE1"
			SEV->EV_PREFIXO  := SE1->E1_PREFIXO
			SEV->EV_NUM      := SE1->E1_NUM
			SEV->EV_PARCELA  := SE1->E1_PARCELA
			SEV->EV_CLIFOR   := SE1->E1_CLIENTE
			SEV->EV_LOJA     := SE1->E1_LOJA
			SEV->EV_TIPO     := SE1->E1_TIPO
		Else
			SEV->EV_PREFIXO  := SE2->E2_PREFIXO
			SEV->EV_NUM      := SE2->E2_NUM
			SEV->EV_PARCELA  := SE2->E2_PARCELA
			SEV->EV_CLIFOR   := SE2->E2_FORNECE
			SEV->EV_LOJA     := SE2->E2_LOJA
			SEV->EV_TIPO     := SE2->E2_TIPO
		EndIf
		SEV->EV_VALOR    := IIf(nY==Len(aColsSEV),nValDup-nRateio,NoRound(nValDup*SEV->EV_PERC/100,2))
		SEV->EV_PERC     := SEV->EV_PERC/100
		SEV->EV_RECPAG   := If(cAliasFin=="SE2","P","R")
		SEV->EV_LA       := ""
		SEV->EV_IDENT    := "1"
		nRateio += SEV->EV_VALOR
		If ( cAliasFin == "SE2" .OR. cAliasFin == "SE1" )
			If cPaisLoc <> "BRA" .AND. empty(aSEZ) .AND. lLxFunNatC
				if Select("SEZTMP") > 0 .And. aColsSev[nY][4] == "1"
					SEV->EV_RATEICC := "1"
					LxFunNatC(aColsSev[nY][1])
				Endif
			Else
				if !empty(aSEZ)
					For nZ := 1 To Len(aSEZ)
					SEV->EV_RATEICC := "1"
					RecLock("SEZ",.T.)
					SEZ->EZ_FILIAL := cFilSEZ
					SEZ->EZ_PREFIXO:= SEV->EV_PREFIXO
					SEZ->EZ_NUM    := SEV->EV_NUM
					SEZ->EZ_PARCELA:= SEV->EV_PARCELA
					SEZ->EZ_CLIFOR := SEV->EV_CLIFOR
					SEZ->EZ_LOJA   := SEV->EV_LOJA
					SEZ->EZ_TIPO   := SEV->EV_TIPO
					SEZ->EZ_PERC   := aSEZ[nZ][04]/100
					SEZ->EZ_VALOR  := NoRound(SEV->EV_VALOR*SEZ->EZ_PERC,nTEZ_PERC)
					SEZ->EZ_NATUREZ:= SEV->EV_NATUREZ
					SEZ->EZ_CCUSTO := aSEZ[nZ][01]
					SEZ->EZ_ITEMCTA:= aSEZ[nZ][02]
					SEZ->EZ_CLVL   := aSEZ[nZ][03]
					SEZ->EZ_RECPAG := SEV->EV_RECPAG
					SEZ->EZ_LA     := ""
					SEZ->EZ_IDENT  := SEV->EV_IDENT
					SEZ->EZ_SEQ    := SEV->EV_SEQ
					SEZ->EZ_SITUACA:= SEV->EV_SITUACA
					nRateioSEZ += SEZ->EZ_VALOR
					SEZ->(MsUnLock())
					Next nZ
				Endif
			Endif
		EndIf
		SEV->(MsUnlock())
		lRet := .T.
	EndIf
Next nY

RestArea(aArea)
Return lRet
//Programa  ³SCMToREM2   ºData  ³  23/10/08
//Desc.     ³Selecao de remitos para NF de Saida
Function SCMToREM2()
Local aCposF4		:= {}
Local aRecs    		:= {}
Local aRet     		:= {}
Local aArea    		:= GetArea()
//Local cCampo 		:= ""
Local cCliFor		:= IIf(aCfgNF[SAliasHead]=="SF2",M->F2_CLIENTE,M->F1_FORNECE)
Local cCondicao 	:= ""
Local cItem			:=	""
Local cLoja  		:= IIf(aCfgNF[SAliasHead]=="SF2",M->F2_LOJA,M->F1_LOJA)
Local cSeek  		:= "'" + xFilial('SF2')+cCliFor+cLoja + "'"
Local cTipoDoc 		:= ""
Local cWhile 		:= "!__LOCXSF2->(EOF()) .AND. __LOCXSF2->(F2_FILIAL+F2_CLIENTE+F2_LOJA)== " + cSeek
Local cPosFilial	:= ""
Local cPosDoc		:= ""
Local cPosSerie		:= ""
Local cPosCliente	:= ""
Local nPorDesc		:= 0
Local nItemRem 		:= 0
Local nUm      		:= 0
Local nSegum   		:= 0
Local nCod     		:= 0
Local nLocal   		:= 0
Local nQuant   		:= 0
Local nRemito  		:= 0
Local nSeriRem 		:= 0
Local nItem    		:= 0
Local nTes     		:= 0
Local nCf      		:= 0
Local nLoteCtl 		:= 0
Local nNumLote 		:= 0
Local nDtValid 		:= 0
Local nProvEnt		:= 0
Local nIpi     		:= 0
Local nVunit   		:= 0
Local nTotal   		:= 0
Local nQTSegum 		:= 0
Local nConta 		:= 0
Local nCCusto 		:= 0
Local nDesc 		:= 0
//Local nDesNTrb		:= 0
//Local nTara			:= 0
Local nI 			:= 0
Local nJ 			:= 0
//Local nK 			:= 0
Local cTipConv		:= GetNewPar("MV_ALTTXNF",'1')
Local nTaxaNf		:= 0
Local nTaxaPed		:= 0
Local nItConta  	:= 0
Local nClValor  	:= 0
Local nSeguro       := 0
Local nFrete        := 0
Local nDescont      := 0
Local nDespesa      := 0
Local cPe		    := ""
Local cRetPe        := ""
Local cFilSB1	:= xFilial("SB1")
Local cFilSC5	:= xFilial("SC5")
Local cFilSC6	:= xFilial("SC6")
Local cFilSD2	:= xFilial("SD2")
//Local cCFO			:= ""
Private aFiltro		:= {}
Private aColsSD2	:= aCols

If Empty(cCliFor) .OR. Empty(cLoja)
	Aviso(cCadastro,STR0094,{STR0021})
	Return
EndIf
If FindFunction("LxCpRemito") .And. !LxCpRemito()//Valida campos usados
	Return
EndIf
For nI:=1 to Len(aHeader)
	Do Case
		Case  Alltrim(aHeader[nI][2]) == "D2_DESC"
			nPorDesc	:= nI
		Case  Alltrim(aHeader[nI][2]) == "D2_ITEMREM"
			nItemRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_UM"
			nUm      := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_SEGUM"
			nSegum   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_COD"
			nCod     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_LOCAL"
			nLocal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_QUANT"
			nQuant   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_REMITO"
			nRemito  := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_SERIREM"
			nSeriRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_ITEM"
			nItem    := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_TES"
			nTes     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CF"
			nCf      := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_LOTECTL"
			nLoteCtl := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_NUMLOTE"
			nNumLote := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_DTVALID"
			nDtValid := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_IPI"
			nIpi     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_PRCVEN"
			nVunit   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_TOTAL"
			nTotal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_QTSEGUM"
			nQTSegum := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CONTA"
			nConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CCUSTO"
			nCCusto := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_DESCON"
			nDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_ITEMCC"
			nItConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CLVL"
			nClValor := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_PROVENT"
			nProvEnt := nI
	Endcase
Next nI

If aCfgNF[SnTipo] == 7 .Or. aCfgNF[SnTipo] == 6
	cTipoDoc := "61"
Else
	Return
EndIf

SX3->(DbSetOrder(1))
SX3->(DbSeek("SF2"))
While !SX3->(EOF()) .AND. SX3->X3_ARQUIVO == "SF2"
	If SX3->X3_BROWSE == "S" .AND. cNivel >= SX3->X3_NIVEL
		AAdd(aCposF4,SX3->X3_CAMPO)
	Endif
	SX3->(DbSkip())
EndDo

For nI:=1 to Len(aCposF4)
	Do Case
		Case  Alltrim(aCposF4[nI]) == "F2_FILIAL"
			cPosFilial := nI
		Case  Alltrim(aCposF4[nI]) == "F2_DOC"
			cPosDoc := nI
		Case  Alltrim(aCposF4[nI]) == "F2_SERIE"
			cPosSerie := nI
		Case  Alltrim(aCposF4[nI]) == "F2_CLIENTE"
			cPosCliente := nI
	Endcase
Next nI

If nRemito * nSeriRem * nItemRem > 0
	DbSelectArea("SD2")
	SD2->(DbSetOrder(9))
	SD2->(DbSeek(cFilSD2+cCliFor+cLoja))
	While !SD2->(EOF()) .And. SD2->D2_FILIAL+SD2->D2_CLIENTE+SD2->D2_LOJA == cFilSD2+cCliFor+cLoja
		If 	DToS(SD2->D2_EMISSAO) <= DToS(dDataBase) .And. (SD2->D2_QUANT - SD2->D2_QTDEFAT) > 0 .And. AllTrim(SD2->D2_TIPO) == aCfgNF[ScTipoDoc] .And.	AllTrim(SD2->D2_TIPODOC) $ Alltrim(cTipoDoc)
			If Ascan(aColsSD2,{ |X| X[nRemito]+X[nSeriRem]+X[nItemRem] == SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_ITEM})==0
				Aadd(aFiltro, {SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_TIPO, SD2->(Recno())})
			Endif
		Endif
		SD2->(DbSkip())
	EndDo
	If !Empty(aFiltro)
		If Select("__LOCXSF2") == 0
			ChkFile("SF2",.F.,"__LOCXSF2")
		Endif
		cPe	:=	LocxPE(57)
		If !Empty(cPe)
			cRetPe := Execblock(cPE,.F.,.F.,{"__LOCXSF2"})
			If ValType(cRetPe) <> "C"
		   	  	cRetPe := " "
		  	EndIf
		EndIf
		cCondicao	:= "Ascan(aFiltro,{ |X| X[1]==__LOCXSF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_TIPO)}) > 0"
	  	cCondicao   += if(empty(cRetPe),"",".AND." + cRetPe)
		aRet 		:= LocxF4("__LOCXSF2",2,cWhile,cSeek,aCposF4,,DESCREM,cCondicao,.T.,,,,,.F.)
	Else
		Help(" ",1,"A103F4")
		Return
	EndIf
EndIf

If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs := aRet[3]
EndIf

If ValType(aRecs)!="A" .OR. (ValType(aRecs)=="A" .AND. Len(aRecs)==0)
	Return
EndIf

cItem	:=	StrZero(0,TamSx3('D2_ITEM')[1])
nI:=0

For nI := 1 To Len(aRecs)
	__LOCXSF2->(MsGoTo(aRecs[nI]))
	For nJ := 1 to Len(aFiltro)
		If aFiltro[nJ][1] == __LOCXSF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_TIPO)
			If ( nCod > 0  .AND.  !Empty(aCOLS[Len(aCols)][nCod]))
				AAdd(aCols,Array(Len(aHeader)+1))
			EndIf
		 	aCols[Len(aCols)][Len(aHeader)+1]:=.F.
			SD2->(MsGoto(aFiltro[nJ][2]))
			SB1->(MsSeek(cFilSB1+SD2->D2_COD))
			SC5->(dbSetOrder(1))
			SC5->(MsSeek(cFilSC5+SD2->D2_PEDIDO))
			SC6->(dbSetOrder(1))
			SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV))
			cItem	:=	Soma1(cItem)
			If (nItemRem >  0  ,  aCOLS[Len(aCols)][nItemRem] := SD2->D2_ITEM   ,)
			If (nUm      >  0  ,  aCOLS[Len(aCols)][nUm     ] := SD2->D2_UM     ,)
			If (nSegum   >  0  ,  aCOLS[Len(aCols)][nSegum  ] := SD2->D2_SEGUM  ,)
			If (nCod     >  0  ,  aCOLS[Len(aCols)][nCod    ] := SD2->D2_COD	  ,)
			If (nSeriRem >  0  ,  aCOLS[Len(aCols)][nSeriRem] := SD2->D2_SERIE  ,)
			If (nLocal   >  0  ,  aCOLS[Len(aCols)][nLocal  ] := SD2->D2_LOCAL  ,)
			If (nQuant   >  0  ,  aCOLS[Len(aCols)][nQuant  ] := (SD2->D2_QUANT - SD2->D2_QTDEFAT),)
			If (nRemito  >  0  ,  aCOLS[Len(aCols)][nRemito ] := SD2->D2_DOC	  ,)
			If (nItem    >  0  ,  aCOLS[Len(aCols)][nItem   ] := cItem ,)
			If (nTes     >  0  ,  aCOLS[Len(aCols)][nTes    ] := SD2->D2_TES    ,)
			If (nCF      >  0  ,  aCOLS[Len(aCols)][nCF     ] := SD2->D2_CF     ,)
			If (nLOTECTL >  0  ,  aCOLS[Len(aCols)][nLOTECTL] := SD2->D2_LOTECTL,)
			If (nNUMLOTE >  0  ,  aCOLS[Len(aCols)][nNUMLOTE] := SD2->D2_NUMLOTE,)
			If (nDTVALID >  0  ,  aCOLS[Len(aCols)][nDTVALID] := SD2->D2_DTVALID,)
			If (nProvEnt >  0  ,  aCOLS[Len(aCols)][nProvEnt] := SD2->D2_PROVENT,)
			If (nIPI     >  0  ,  aCOLS[Len(aCols)][nIPI    ] := SD2->D2_IPI    ,)
			If (nQtSegUm >  0  ,  aCOLS[Len(aCols)][nQtSegUm] := SD2->D2_QTSEGUM,)
			If (nConta   >  0  ,  aCOLS[Len(aCols)][nConta  ] := If(!Empty(SD2->D2_CONTA),SD2->D2_CONTA,SB1->B1_CONTA),)
			If (nCCusto  >  0  ,  aCOLS[Len(aCols)][nCCusto ] := If(!Empty(SD2->D2_CCUSTO),SD2->D2_CCUSTO,SB1->B1_CC),)
			If (nItConta >  0  ,  aCOLS[Len(aCols)][nItConta] := SD2->D2_ITEMCC,)
			If (nClValor >  0  ,  aCOLS[Len(aCols)][nClValor] := SD2->D2_CLVL,)
			nTaxaNF		:= Iif(MaFisRet(,'NF_TXMOEDA')==0,Recmoeda(dDatabase,M->F2_MOEDA),MaFisRet(,'NF_TXMOEDA'))
			nTaxaPed	:= Iif(cTipConv=='1',Iif(__LOCXSF2->F2_TXMOEDA=0,RecMoeda(__LOCXSF2->F2_EMISSAO,__LOCXSF2->F2_MOEDA),__LOCXSF2->F2_TXMOEDA),RecMoeda(dDatabase,__LOCXSF2->F2_MOEDA))
			If nVUnit   >  0
				If SD2->D2_PRCVEN <> 0
					nPrecio := xMoeda(SD2->D2_PRCVEN,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
				Else
					If ! Empty(SD2->D2_PEDIDO)
						nPrecio := xMoeda(SC6->C6_PRCVEN,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
					Else
						nPrecio := RetFldProd(SB1->B1_COD,"B1_PRV1")
					EndIf
				EndIf
				aCOLS[Len(aCols)][nVunit] := nPrecio
			EndIf

			If nTotal > 0
				If SD2->D2_PRCVEN <> 0
					nPrecio := xMoeda(SD2->D2_PRCVEN,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
				Else
					If .Not. Empty(SD2->D2_PEDIDO)
						nPrecio := xMoeda(SC6->C6_PRCVEN,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
					Else
						nPrecio := RetFldProd(SB1->B1_COD,"B1_PRV1")
					EndIf
				EndIf
				aCOLS[Len(aCols)][nTotal] := (nPrecio * (SD2->D2_QUANT - SD2->D2_QTDEFAT))
			Endif

			If nDesc > 0
				If SD2->D2_DESCON <> 0
					If SD2->D2_QTDAFAT == SD2->D2_QUANT .Or. SD2->D2_QTDAFAT == 0
						aCols[Len(aCols)][nDesc] :=xMoeda(SD2->D2_DESCON,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
					Else
						aCols[Len(aCols)][nDesc] :=xMoeda(SD2->D2_DESCON*SD2->D2_QTDAFAT/SD2->D2_QUANT,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
					Endif
				Else
					dbSelectArea("SC6")
					dbSetOrder(1)
					If SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV,.F.))
						If SD2->D2_QTDAFAT == SC6->C6_QTDVEN .Or. SD2->D2_QTDAFAT == 0
							aCols[Len(aCols)][nDesc] :=xMoeda(SC6->C6_VALDESC,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
						Else
							aCols[Len(aCols)][nDesc] :=xMoeda(SC6->C6_VALDESC*SC6->C6_QTDVEN/SD2->D2_QTDAFAT ,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
						Endif
					EndIf
				EndIf
			Endif

		   If nPorDesc	 > 0
				If SD2->D2_DESC <> 0
					aCOLS[Len(aCols)][nPorDesc ] := SD2->D2_DESC
				Else
					dbSelectArea("SC6")
					dbSetOrder(1)
					If SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV,.F.))
						aCols[Len(aCols)][nPorDesc] := SC6->C6_DESCONT
					EndIf
				Endif
			Endif

			cPe := LocxPE(50)
			If !Empty(cPe)
				Execblock(cPE,.F.,.F.,)
			EndIf
			AEval(aHeader,{|x,y| If(aCols[Len(aCols)][y]==NIL,aCols[Len(aCols)][y]:=CriaVar(x[2]),) })
			IIf(cPaisLoc == "COL" .And. nCF>0, cCFO := aCols[Len(aCols)][nCF],)
			MaColsToFis(aHeader,aCols,Len(aCols),"MT100",.T.)
			If cPaisLoc == "COL"
				LxVldCFCol(aCols, cCFO, Len(aCols), nCF)
			EndIf
			MafisAlt('IT_FRETE'		,SD2->D2_VALFRE		,Len(aCols))
			MafisAlt('IT_DESPESA'	,SD2->D2_DESPESA	,Len(aCols))
			MafisAlt('IT_DESCONTO'	,SD2->D2_DESCON 	,Len(aCols))
			MafisAlt('IT_SEGURO'	,SD2->D2_SEGURO		,Len(aCols))

			nFrete   += SD2->D2_VALFRE
			nDespesa += SD2->D2_DESPESA
			nDescont += SD2->D2_DESCON
			nSeguro  += SD2->D2_SEGURO

		EndIf
	Next nJ
Next nI

// Atualizar pasta Gastos com base nos itens do Remito
If nFrete > 0 .And. ValType(F2_FRETE) == "N"
	F2_FRETE := F2_FRETE + nFrete
EndIf
If nSeguro > 0	.And. ValType(F2_SEGURO) == "N"
	F2_SEGURO := F2_SEGURO + nSeguro
EndIf
If nDespesa > 0	.And. ValType(F2_DESPESA) == "N"
	F2_DESPESA := F2_DESPESA + nDespesa
EndIf
If nDescont > 0 .And. ValType(F2_DESCONT) == "N"
	F2_DESCONT := F2_DESCONT + nDescont
EndIf
/*If cPaisLoc == "PTG"
	If nDesNTrb > 0 .And. ValType(F2_DESNTRB) == "N"
		F2_DESNTRB := F2_DESNTRB + nDesNTrb
	EndIf
	If nTara > 0 .And. ValType(F2_TARA) == "N"
		F2_TARA := F2_TARA + nTara
	EndIf
Endif*/

Eval(bDoRefresh)
oGetDados:obrowse:refresh()
AtuLoadQt()
RestArea(aArea)
Return
/*
±±ºPrograma  ³SCMToNF2  ºAutor  ³ Ricardo Berti      º Data ³  23/10/08   º±±
±±ºDesc.     ³ Mostra remitos que serao amarrados ao documento sendo 	  º±±
±±º          ³ digitado (devolucao ou NF de saida)                        º±±
±±ºUso       ³MATA466N                                                    º±±
*/
Function SCMToNF2()
Local aRecs    := {}
Local aRet     := {}
//Local aCpoExt  := {}
//Local aCpoExtra:= {}
Local aAreaSD2 := GetArea()
Local nI       := 0
Local nPorDesc := 0
Local nItemRem := 0
Local nUm      := 0
Local nSegum   := 0
Local nCod     := 0
Local nLocal   := 0
Local nQuant   := 0
Local nRemito  := 0
Local nItem    := 0
Local nTes     := 0
Local nCF      := 0
Local nSeriRem := 0
Local nLOTECTL := 0
Local nNUMLOTE := 0
Local nDTVALID := 0
Local nProvEnt := 0
Local nIPI     := 0
Local nQtSegUm := 0
Local nConta   := 0
Local nCCusto  := 0
Local cTipoDoc := ""
Local cCliFor:= IIf(aCfgNF[SAliasHead]=="SF2",M->F2_CLIENTE,M->F1_FORNECE)
Local cLoja  := IIf(aCfgNF[SAliasHead]=="SF2",M->F2_LOJA,M->F1_LOJA)
//Local nPosSolici := 0
//Local cCampo := "" ,cItem	:=	""
Local cSeek  := "'" + xFilial('SD2')+cCliFor+cLoja + "'"
Local cWhile := "!EOF() .AND. SD2->D2_FILIAL+SD2->D2_CLIENTE+SD2->D2_LOJA== " + cSeek
Local cCondicao := ""
Local aCposF4	:= 	   {"D2_DOC",;
						"D2_CLIENTE",;
						"D2_LOJA"   ,;
						"D2_ITEM"   ,;
						"D2_COD"	,;
						"D2_UM"     ,;
						"D2_QUANT"  ,;
						"D2_QTDEFAT",;
						"D2_SEGUM"  ,;
						"D2_QTSEGUM",;
						"D2_LOCAL"  ,;
						"D2_PEDIDO" }

Local cTipConv := GetNewPar("MV_ALTTXNF",'1')
Local nTaxaNf  := 0
Local nTaxaPed := 0
Local nSeguro  := 0
Local nFrete   := 0
Local nDescont := 0
Local nDespesa := 0
//Local nDesNTrb := 0
//Local nTara    := 0
Local cPe	   := ""
Local cCondUser:= ""
Local cFilSB1	:= xFilial("SB1")
Local cFilSC5	:= xFilial("SC5")
Local cFilSC6	:= xFilial("SC6")
Local cFilSF2	:= xFilial("SF2")
//Local cCFO		:= ""
Private aColsSD2 	:= aCols

cPe	:=	LocxPE(58)
If !Empty(cPe)
	cCondUser := Execblock(cPE,.F.,.F.,)
	If ValType(cCondUser) <> "C"
		cCondUser := " "
	EndIf
EndIf

If Empty(cCliFor) .OR. Empty(cLoja)
	Aviso(cCadastro,STR0094,{STR0021})
	Return
EndIf

If  nModulo == 12 .And. !nModulo == 72  // SIGALOJA //SIGAPHOTO
	Aviso(cCadastro,STR0238,{STR0021})
	Return
EndIf
If FindFunction("LxCpRemito") .And. !LxCpRemito()//Valida campos usados
	Return
EndIf
For nI:=1 to Len(aHeader)
	Do Case
		Case  Alltrim(aHeader[nI][2]) == "D2_DESC"
			nPorDesc	:= nI
		Case  Alltrim(aHeader[nI][2]) == "D2_ITEMREM"
			nItemRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_UM"
			nUm      := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_SEGUM"
			nSegum   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_COD"
			nCod     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_LOCAL"
			nLocal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_QUANT"
			nQuant   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_REMITO"
			nRemito  := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_SERIREM"
			nSeriRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_ITEM"
			nItem    := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_TES"
			nTes     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CF"
			nCf      := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_LOTECTL"
			nLoteCtl := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_NUMLOTE"
			nNumLote := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_DTVALID"
			nDtValid := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_IPI"
			nIpi     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_PRCVEN"
			nVunit   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_TOTAL"
			nTotal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_QTSEGUM"
			nQTSegum := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CONTA"
			nConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CCUSTO"
			nCCusto := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_DESCON"
			nDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_PROVENT"
			nProvEnt := nI
	Endcase
Next nI

If aCfgNF[SnTipo] == 7 .Or. aCfgNF[SnTipo] == 6
	cTipoDoc := "61"
Else
	Return
EndIf

If nRemito * nSeriRem * nItemRem > 0
	cCondicao 	:= IIf(Empty(cCondicao),""," .And. ") + "DTOS(SD2->D2_EMISSAO)<='"+Dtos(dDataBase)+"' .And. (SD2->D2_QUANT - SD2->D2_QTDEFAT) > 0 .And. AllTrim(SD2->D2_TIPO) == aCfgNF["+AllTrim(Str(ScTipoDoc))+"] .And. AllTrim(SD2->D2_TIPODOC) $ Alltrim('"+cTipoDoc+"').And. " +;
				   "Iif(Ascan(aColsSD2,{ |X| X["+Alltrim(str(nRemito))+"]+ X["+Alltrim(Str(nSeriRem))+"] +X["+Alltrim(Str(nItemRem))+"] == SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_ITEM})==0,.T.,.F. )"

	If !Empty(cCondUser)
		cCondicao := "(" + cCondicao + ") .And. (" + cCondUser + ")"
	EndIf

	aRet := LocxF4("SD2",9,cWhile,cSeek,aCposF4,,DESCREM,cCondicao,.T.,,,,,.F.)  // Retorna os Recnos das linhas selecionadas
	Eval( bFilBrw )
EndIf

If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs := aRet[3]
EndIf

If ValType(aRecs)!="A" .OR. (ValType(aRecs)=="A" .AND. Len(aRecs)==0)
	Return
EndIf

cItem	:=	StrZero(0,TamSx3('D2_ITEM')[1])
nI:=0
For nI := 1 To Len(aRecs)
	If ( nCod > 0  .AND.  !Empty(aCOLS[Len(aCols)][nCod]))
		AAdd(aCols,Array(Len(aHeader)+1))
	EndIf
 	aCols[Len(aCols)][Len(aHeader)+1]:=.F.
	SD2->(MsGoto(aRecs[nI]))
	SB1->(MsSeek(cFilSB1+SD2->D2_COD))
	SC5->(dbSetOrder(1))
	SC5->(MsSeek(cFilSC5+SD2->D2_PEDIDO))
	SC6->(dbSetOrder(1))
	SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV))
	cItem	:=	Soma1(cItem)

	If (nItemRem >  0  ,  aCOLS[Len(aCols)][nItemRem] := SD2->D2_ITEM   ,)
	If (nUm      >  0  ,  aCOLS[Len(aCols)][nUm     ] := SD2->D2_UM     ,)
	If (nSegum   >  0  ,  aCOLS[Len(aCols)][nSegum  ] := SD2->D2_SEGUM  ,)
	If (nCod     >  0  ,  aCOLS[Len(aCols)][nCod    ] := SD2->D2_COD	,)
	If (nSeriRem >  0  ,  aCOLS[Len(aCols)][nSeriRem] := SD2->D2_SERIE  ,)
	If (nLocal   >  0  ,  aCOLS[Len(aCols)][nLocal  ] := SD2->D2_LOCAL  ,)
	If (nQuant   >  0  ,  aCOLS[Len(aCols)][nQuant  ] := (SD2->D2_QUANT - SD2->D2_QTDEFAT),)
	If (nRemito  >  0  ,  aCOLS[Len(aCols)][nRemito ] := SD2->D2_DOC	,)
	If (nItem    >  0  ,  aCOLS[Len(aCols)][nItem   ] := cItem			,)
	If (nTes     >  0  ,  aCOLS[Len(aCols)][nTes    ] := SD2->D2_TES    ,)
	If (nCF      >  0  ,  aCOLS[Len(aCols)][nCF     ] := SD2->D2_CF     ,)
	If (nLOTECTL >  0  ,  aCOLS[Len(aCols)][nLOTECTL] := SD2->D2_LOTECTL,)
	If (nNUMLOTE >  0  ,  aCOLS[Len(aCols)][nNUMLOTE] := SD2->D2_NUMLOTE,)
	If (nDTVALID >  0  ,  aCOLS[Len(aCols)][nDTVALID] := SD2->D2_DTVALID,)
	If (nProvEnt >  0  ,  aCOLS[Len(aCols)][nProvEnt] := SD2->D2_PROVENT,)
	If (nIPI     >  0  ,  aCOLS[Len(aCols)][nIPI    ] := SD2->D2_IPI    ,)
	If (nQtSegUm >  0  ,  aCOLS[Len(aCols)][nQtSegUm] := SD2->D2_QTSEGUM,)
	If (nConta   >  0  ,  aCOLS[Len(aCols)][nConta  ] := If(!Empty(SD2->D2_CONTA),SD2->D2_CONTA,SB1->B1_CONTA),)
	If (nCCusto  >  0  ,  aCOLS[Len(aCols)][nCCusto ] := If(!Empty(SD2->D2_CCUSTO),SD2->D2_CCUSTO,SB1->B1_CC),)

	If Select("__LOCXSF2") == 0
		ChkFile("SF2",.F.,"__LOCXSF2")
	Else
		dbSelectArea("__LOCXSF2")
	Endif
	__LOCXSF2->(DbSetOrder(1))
	__LOCXSF2->(MSSeek(cFilSF2+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_TIPO))
	nTaxaNF		:= Iif(MaFisRet(,'NF_TXMOEDA')==0,Recmoeda(dDatabase,M->F2_MOEDA),MaFisRet(,'NF_TXMOEDA'))
	nTaxaPed		:= Iif(cTipConv=='1',Iif(__LOCXSF2->F2_TXMOEDA=0,RecMoeda(__LOCXSF2->F2_EMISSAO,__LOCXSF2->F2_MOEDA),__LOCXSF2->F2_TXMOEDA),RecMoeda(dDatabase,__LOCXSF2->F2_MOEDA))
	If nVUnit   >  0
		If SD2->D2_PRCVEN <> 0
			nPrecio := xMoeda(SD2->D2_PRCVEN,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
		Else
			If ! Empty(SD2->D2_PEDIDO)
				nPrecio := xMoeda(SC6->C6_PRCVEN,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
			Else
				nPrecio := RetFldProd(SB1->B1_COD,"B1_PRV1")
			EndIf
		EndIf
		aCOLS[Len(aCols)][nVunit] := nPrecio
	EndIf

	If nTotal > 0
		If SD2->D2_PRCVEN <> 0
			nPrecio := xMoeda(SD2->D2_PRCVEN,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
		Else
			If ! Empty(SD2->D2_PEDIDO)
				nPrecio := xMoeda(SC6->C6_PRCVEN,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
			Else
				nPrecio := RetFldProd(SB1->B1_COD,"B1_PRV1")
			EndIf
		EndIf
		aCOLS[Len(aCols)][nTotal] := (nPrecio * (SD2->D2_QUANT - SD2->D2_QTDEFAT))
	Endif

	If nDesc > 0
		If SD2->D2_DESCON <> 0
			If SD2->D2_QTDAFAT == SD2->D2_QUANT .Or. SD2->D2_QTDAFAT == 0
				aCols[Len(aCols)][nDesc] :=xMoeda(SD2->D2_DESCON,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
			Else
				aCols[Len(aCols)][nDesc] :=xMoeda(SD2->D2_DESCON*SD2->D2_QTDAFAT/SD2->D2_QUANT,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
			Endif
		Else
			dbSelectArea("SC6")
			dbSetOrder(1)
			If SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV,.F.))
				If SD2->D2_QTDAFAT == SC6->C6_QTDVEN .Or. SD2->D2_QTDAFAT == 0
					aCols[Len(aCols)][nDesc] :=xMoeda(SC6->C6_VALDESC,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
				Else
					aCols[Len(aCols)][nDesc] :=xMoeda(SC6->C6_VALDESC*SC6->C6_QTDVEN/SD2->D2_QTDAFAT ,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
				Endif
			EndIf
		EndIf
	Endif

   If nPorDesc	 > 0
		If SD2->D2_DESC <> 0
			aCOLS[Len(aCols)][nPorDesc ] := SD2->D2_DESC
		Else
			dbSelectArea("SC6")
			dbSetOrder(1)
			If SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV,.F.))
				aCols[Len(aCols)][nPorDesc] := SC6->C6_DESCONT
			EndIf
		Endif
	Endif
	oGetDados:lNewLine:=.F.
	//Ponto entrada para preencher campos no aCols
	cPe := LocxPE(50)
	If !Empty(cPe)
		Execblock(cPE,.F.,.F.,)
	EndIf
  	AEval(aHeader,{|x,y| If(aCols[Len(aCols)][y]==NIL,aCols[Len(aCols)][y]:=CriaVar(x[2]),) })
	IIf(cPaisLoc == "COL" .And. nCF>0, cCFO := aCols[Len(aCols)][nCF],)
 	MaColsToFis(aHeader,aCols,Len(aCols),"MT100",.T.)
	If cPaisLoc == "COL"
		LxVldCFCol(aCols, cCFO, Len(aCols), nCF)
	EndIf
	MafisAlt('IT_FRETE'		,SD2->D2_VALFRE		,Len(aCols))
	MafisAlt('IT_DESPESA'	,SD2->D2_DESPESA	,Len(aCols))
	MafisAlt('IT_DESCONTO'	,SD2->D2_DESCON		,Len(aCols))
	MafisAlt('IT_SEGURO'	,SD2->D2_SEGURO		,Len(aCols))

	nFrete   += SD2->D2_VALFRE
	nDespesa += SD2->D2_DESPESA
	nDescont += SD2->D2_DESCON
	nSeguro  += SD2->D2_SEGURO

Next nI
// Atualizar pasta Gastos com base nos itens do Remito
If nFrete > 0 .And. ValType(F2_FRETE) == "N"
	F2_FRETE := F2_FRETE + nFrete
EndIf
If nSeguro > 0	.And. ValType(F2_SEGURO) == "N"
	F2_SEGURO := F2_SEGURO + nSeguro
EndIf
If nDespesa > 0	.And. ValType(F2_DESPESA) == "N"
	F2_DESPESA := F2_DESPESA + nDespesa
EndIf
If nDescont > 0 .And. ValType(F2_DESCONT) == "N"
	F2_DESCONT := F2_DESCONT + nDescont
EndIf

Eval(bDoRefresh)
oGetDados:obrowse:refresh()

//Atualiza o browse de qtde de produtos.
AtuLoadQt(.T.)

RestArea(aAreaSD2)
Return
/*
±±³Fun‡„o    ³ALocPrdGrd³ ³±±
±±³Descricao ³ Interface de Grade de Produtos para Remito, Facturas de     ³±±
±±³          ³ de saida e nota de debito/credito (NDC e NCE no faturam.    ³±±
±±³          ³ NDI e NCP no Compras                                        ³±±
±±³Uso       ³Getdados das rotinas MATA462N, MATA465N e MATA467N disparada ³±±
±±³          ³pelo X3_VALID do D2_COD 									   ³±±
*/
Function ALocPrdGrd(lDo)
Local aArea	      := GetArea()
//Local aHlpPor     := {"Para incluir um produto com referência  ","de grade e necessário estar em uma nova ","linha do documento.          "}
//Local aHlpEng     := {"To include a product with bars reference"," and necessary to be in a new line of   ","the document.                  "}
//Local aHlpSpa     := {"Para incluir un producto con referencia ","de las barras y requisito estar en una  ","nueva línea del documento."}
//Local cDescri     := ""
Local cItem       := ""
Local cNewItem    := ""
Local cPrdOrig    := ""
Local cCpoName	  := StrTran(ReadVar(),"M->","")
Local cSaveReadVar:= __READVAR
Local nSaveN      := N
Local nNewItem    := Len(aCols)
Local nPosItem    := aScan(aHeader,{|x| AllTrim(x[2])=="D2_ITEM"})
Local nPosProd    := aScan(aHeader,{|x| AllTrim(x[2])=="D2_COD"})
Local nPosQuant   := aScan(aHeader,{|x| AllTrim(x[2])=="D2_QUANT"})
Local nPosQtSegum := aScan(aHeader,{|x| AllTrim(x[2])=="D2_QTSEGUM"})
Local nPosVUnit   := aScan(aHeader,{|x| AllTrim(x[2])=="D2_PRCVEN"})
Local nPosTotal   := aScan(aHeader,{|x| AllTrim(x[2])=="D2_TOTAL"})
Local nLinX       := 0
Local nColY       := 0
Local nY          := 0
Local lGrade	  := MaGrade()
Local lReferencia := .F.
Local lAadd       := .F.
Local lRet 		  := .T.
Local nTD2_TOTAL	:= TamSX3("D2_TOTAL")[2]
Local oDlg

Default lDo       := .T.

If lGrade .And. !Empty(&(ReadVar()))
	PRIVATE oGrade	  := MsMatGrade():New('oGrade',,"D2_QUANT",,"ALocVldGrd()",,;
	{{"D2_QUANT"  ,.T. , {{"D2_QTSEGUM",{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),aCols[nLinha][nColuna],0,2) } }} },;
	{"D2_PRCVEN"  ,NIL ,NIL},;
	{"D2_ITEM"	 ,NIL ,NIL},;
	{"D2_QTSEGUM",NIL , {{"D2_QUANT",{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),0,aCols[nLinha][nColuna],1) }}} };
	})

	cProdRef := &(ReadVar())
	lReferencia := MatGrdPrrf(@cProdRef)
	If lReferencia
		If N >= Len(aCols) .And. Empty(aCols[Len(aCols)][nPosProd])
			oGrade:MontaGrade(1,cProdRef,.T.,,lReferencia,.T.)
			oGrade:nPosLinO := 1
			oGrade:cProdRef	:= cProdRef
			oGrade:lShowMsgDiff := .F. // Desliga apresentacao do "A410QTDDIF"
			cItem    := aCols[nSaveN][nPosItem]
			nNewItem := Len(aCols)
			lAadd    := .F.

			DEFINE MSDIALOG oDlg TITLE STR0255 OF oMainWnd PIXEL FROM 000,000 TO 220,520  //"Interface para Grade de Produtos"

			@ 025,010 BUTTON STR0256 SIZE 70,15 FONT oDlg:oFont ACTION ;
			{|| __READVAR:="M->D2_QUANT"  ,M->D2_QUANT  := 0,cCpoName := StrTran(ReadVar(),"M->",""),oGrade:Show(cCpoName) } OF oDlg PIXEL //"Qtde"
			@ 045,010 BUTTON STR0257 SIZE 70,15 FONT oDlg:oFont ACTION ;
			{|| __READVAR:="M->D2_PRCVEN"  ,M->D2_PRCVEN  := 0,cCpoName := StrTran(ReadVar(),"M->",""),oGrade:Show(cCpoName) } OF oDlg PIXEL //"Valor Unitário"
			@ 065,010 BUTTON STR0258 SIZE 70,15 FONT oDlg:oFont ACTION ;
			{|| __READVAR:="M->D2_QTSEGUM",M->D2_QTSEGUM:= 0,cCpoName := StrTran(ReadVar(),"M->",""),oGrade:Show(cCpoName) } OF oDlg PIXEL //"Segunda Und Medida"

			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||oDlg:End()},{||oDlg:End()}) CENTERED
			//Somente realiza a carga do item para o aCols se pelo menos uma celula do D2_QUANT contiver valor.
			If oGrade:SomaGrade("D2_QUANT",oGrade:nPosLinO,oGrade:nQtdInformada) > 0
				For nLinX := 1 To Len(oGrade:aColsGrade[1])
					For nColY := 2 To Len(oGrade:aHeadGrade[1])
						If oGrade:aColsFieldByName("D2_QUANT",1,nLinX,nColY) <> 0
							//Faz a montagem de uma nova linha em branco no aCols para
							//adicionar novos itens vindos das celulas da Grade.
							If lAadd
								aadd(aCols,Array(Len(aHeader)+1))
								nNewItem := Len(aCols)
								cNewItem := StrZero(nNewItem,Len(SD2->D2_ITEM))
								For nY := 1 to Len(aHeader)
									If Trim(aHeader[nY][2]) == "D2_ITEM"
										aCols[nNewItem][nY] := cNewItem
									ElseIf IsHeadRec(aHeader[nY][2])
										aCols[nNewItem][nY] := 0
									ElseIf IsHeadAlias(aHeader[nY][2])
										aCols[nNewItem][nY] := "SD2"
									Else
										aCols[nNewItem][nY] := CriaVar(aHeader[nY][2])
									EndIf
									aCols[nNewItem][Len(aHeader)+1] := .F.
								Next nY
							EndIf

							N := nNewItem
							aCols[nNewItem][nPosProd]:= PadR(oGrade:GetNameProd(cProdRef,nLinX,nColY),Len(SD2->D2_COD))

							M->D2_COD := aCols[nNewItem][nPosProd]
							MaFisRef("IT_PRODUTO","MT100",M->D2_COD)
							A920IniCpo()

							aCols[nNewItem][nPosQuant]:= oGrade:aColsFieldByName("D2_QUANT",1,nLinX,nColY)
							M->D2_QUANT := oGrade:aColsFieldByName("D2_QUANT",1,nLinX,nColY)
							A100SegUm()
							MaFisRef("IT_QUANT","MT100",M->D2_QUANT)

							aCols[nNewItem][nPosQtSegum]:= oGrade:aColsFieldByName("D2_QTSEGUM",1,nLinX,nColY)
							M->D2_QTSEGUM := oGrade:aColsFieldByName("D2_QTSEGUM",1,nLinX,nColY)
							A100SegUm()

							aCols[nNewItem][nPosVUnit]:= oGrade:aColsFieldByName("D2_PRCVEN",1,nLinX,nColY)
							M->D2_PRCVEN := oGrade:aColsFieldByName("D2_PRCVEN",1,nLinX,nColY)
							MaFisRef("IT_PRCUNI","MT100",M->D2_PRCVEN)

							aCols[nNewItem][nPosTotal]:= NoRound(aCols[nNewItem][nPosQuant] * aCols[nNewItem][nPosVUnit],nTD2_TOTAL)
							M->D2_TOTAL := aCols[nNewItem][nPosTotal]
							A920Total(M->D2_TOTAL)
							MaFisRef("IT_VALMERC","MT100",M->D2_TOTAL)

							If !lAadd
                                cPrdOrig := aCols[nNewItem][nPosProd]
								lAadd := .T.
							Endif
						EndIf
					Next nColY
				Next nLinX
			Else
				lRet := .F.
			EndIf
			N := nSaveN
			__READVAR   := cSaveReadVar
            M->D2_COD   := cPrdOrig

			If cPaisLoc <> "BRA"
				AtuLoadQt(.T.)
			EndIf
		Else
			Help(" ",1,"AlocPRDGRD")
			lRet := .F.
		EndIf
	Else
		dbSelectArea("SB1")
		dbSetOrder(1)
		If !MsSeek(xFilial("SB1")+cProdRef,.F.)
			Help("  ",1,"REGNOIS")
			lRet := .F.
		EndIf
		If lRet
			MaFisRef("IT_PRODUTO","MT100",M->D2_COD)
			A920IniCpo()
		Endif
	EndIf
Else
	lRet := ExistCpo("SB1")
	If lRet
		MaFisRef("IT_PRODUTO","MT100",M->D2_COD)
		A920IniCpo(lDo)
	Endif
EndIf
RestArea(aArea)
Return(lRet)

Function LocProvEnt()
Local lRet:=.T.
lRet:=LocProvEn2t()
Return (lRet)

Function LocProEnIt()
Local lRet		:= .T.
lRet:=LocProEnI2t()
Return(lRet)

Function LocProvTes()
Local lRet		:= .T.
lRet:=LocProvTe2s()
Return lRet

Function VerProEnIt(cProv,cTes,lMsg,lVerPro)
Local lRet:=.T.
Default lMsg := .T.
Default lVerPro := .T.
lRet:=VerProEnI2t(cProv,cTes,lMsg,lVerPro)
Return(lRet)

Function LocEmisPro()
Local lRet:=.T.
lRet:=LocEmisPr2o()
Return(lRet)
/*Funcion LOCXATUBASE Funcao para limpar aCols en caso que el %BASE sea modificado.  º±±*/
Function LOCXATUBASE(aHeader,aCols)
Local cVarCont	:= Right(aCfgNF[5],2)+"_ITEM"   // aCfgNF[SAliasCols]
Local cItem		:= ""
Local nX		:= 0
Local lDel		:=.T.
Local nLin		:= 1
If Len(aCols) > 0 .and. !Empty(aCols[1][2])
	aCols := {}
	MaFisClear()
	aAdd(aCols,Array(Len(aHeader)+1))
	For nX := 1 to Len(aHeader)
		If Trim(aHeader[nX][2]) == cVarCont
			cVarCont := aCfgNF[5]+"->"+cVarCont  // aCfgNf[SAliasCols]
			aCols[Len(aCols)][nX] 	:= IIF(cItem<>Nil .AND. !Empty(cItem),cItem,StrZero(1,Len(&cVarCont)))
		Else//If ( aHeader[nX][10] <> "V")   // existem campos vituais que devem aparecer na tela exp. Tipo de Operacao
			aCols[Len(aCols)][nX] := CriaVar(aHeader[nX][2],.T.)
		EndIf
		aCols[Len(aCols)][Len(aHeader)+1] := .F.
	Next nX
	oGetDados:Refresh()
    // Limpa Tela de Qtd. Total dos Produtos
    lDel := Iif(Len(oBSomaItens:AARRAY)>0,.T.,.F.)
	While lDel
		nLin:= Len(oBSomaItens:AARRAY)
		If Len(oBSomaItens:AARRAY) == 1
			oBSomaItens:AARRAY[nLin,1] := ''
			oBSomaItens:AARRAY[nLin,2] := 0
			lDel:=.F.
		Else
			Adel(oBSomaItens:AARRAY,nLin)
			ASize(oBSomaItens:AARRAY,Len(oBSomaItens:AARRAY)-1)
		EndIf
	EndDo
	nTotQtIte:= 0
	oBSomaItens:Refresh()
	ModxAtuObj()
EndIf
Return

/*{Protheus.doc} RUXXTS01
@return character cRet
@description Returns counteragent atribute by alias, if it is some subdivision*/
Function RUXXTS01(cFieldName as character, cAliasP as character)
Return _RUXXTS01(cFieldName, cAliasP)
/*{Protheus.doc} RUXXTS02
@description Returns *_NREDUZ(short name) of Head Office if counteragent is a subdivision
*/
Function RUXXTS02(cAliasP as character,cNametab as character)
Return _RUXXTS02(cAliasP,cNametab)


/*{Protheus.doc} RUXXTS03
@return character cRet
@use RUXXTO03_FullAdrOffice()
@description Returns  postal address if flag 2,
                      legal address head office if flag 0 and A*_tipo = 3,
                      legal address if flag 0 and A*_tipo <> 3*/
Function RUXXTS03(cFlag as character,cAliasP as character,cNametab as character)
Return _RUXXTS03(cFlag ,cAliasP ,cNametab )

/*{Protheus.doc} ExcRt101N
@return lRet
@description called by validation in Currency Rate to update all the item lines and header when the end user changes currency rate (for Inflow Invoice)
*/
Function ExcRt101N(lCallRate, lAdvance)
return _ExcRt101N(lCallRate, lAdvance)

/*{Protheus.doc} ExcRt467N
@author Alexandra Menyashina
@since 23/04/2018
@version P12.1.20
@param lCallRate    Logical     Flag of mandatory recalculation
       nCurrLine    Numeric     grid line for which we run recalculation, if it is
                                Nil or 0, we recalculate values for all lines in grid
	   lAdvance     Logical     Flag about Select prepayments
@return lRet
@type function
@description called by validation in Currency Rate to update all the item lines and header when the end user changes currency rate (for Outflow Invoice)
*/
Function ExcRt467N(lCallRate, nCurrLine, lAdvance)
	Default lCallRate := .T.
	Default nCurrLine  := 0
	Default lAdvance := .F.	
return _ExcRt467N(lCallRate, nCurrLine, lAdvance)
// Russia_R5

/*Funcion UpdValImp usada para validacion de tamano de campos y actualizacion a usado*/
Function UpdValImp()
	If  FindFunction("Upd2ValImp")
		Upd2ValImp()
	Else
		Help("",1,"Upd2ValImp",,STR0430 + "Upd2ValImp()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return


Function ValCposRG3668()
Local lRet    := .T.
	If  FindFunction("ValCpoRG3668")
		lRet := ValCpoRG3668()
	Else
		Help("",1,"ValCpoRG3668",,STR0430 + "ValCpoRG3668()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return(lRet)

/*
±±ºDesc.     ³Validacao do Codigo de Barras da Nota Fical                 º±±
±±ºParametros³ cAlias        - Alias do Arquivo (SF1,SF2)                 º±±
±±º          ³ cTexto        - Codigo de Barras                           º±±
±±º          ³ lValidaDv     - Se valida o DV do Codigo de Barras         º±±
±±º          ³ cFieldSERIE   - Memoria do Campo SERIE                     º±±
±±º          ³ cFieldESPECIE - Memoria do Campo ESPECIE                   º±±
±±ºUso       ³ Validacao do codigo de barras X Campos da Tela             º±±*/
Function LocxChkCB(cTexto, lValidaDv, cFieldESPECIE)
Local lValido		:= .F.
DEFAULT lValidaDV	:= .T.
	If  FindFunction("LocxCh2kCB")
		lValido := LocxCh2kCB(cTexto, lValidaDv, cFieldESPECIE)
	Else
		Help("",1,"LocxCh2kCB",,STR0430 + "LocxCh2kCB()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return lValido

/*
±±ºDesc.     ³Rotina para buscar o numero do documento quando usa impressoº±±
±±º          ³ra fiscal Hasar (Loc. Argentina)                            º±±
*/
Function GetNumCFis(cSerie,cEspecie)
Local cNumNota := ""
	If  FindFunction("GetNum2CFis")
		cNumNota := GetNum2CFis(cSerie,cEspecie)
	Else
		Help("",1,"GetNum2CFis",,STR0430 + "GetNum2CFis()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return(cNumNota)

Function LocXTipSer(cAlias,cTipoDoc)
Local cCodSerie  := "   "
	If  FindFunction("LocX2TipSer")
		cCodSerie := LocX2TipSer(cAlias,cTipoDoc)
	Else
		Help("",1,"LocX2TipSer",,STR0430 + "LocX2TipSer()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return (cCodSerie)

/*
±±ºDesc.     ³Selecao do Fornec.                                             º±±
±±º          ³Todos os Fornec.es listados possuem o mesmo CGC.               º±±
±±ºUso       ³ Selecao de Fornec., caso exista mais de um fornec. com        º±±
±±º          ³ o mesmo CGC da NF.                                    		 º±±*/
Function LocxSELCLI( cCGC)
Local aCliente	:= {}
	If  FindFunction("Locx2SELCLI")
		aCliente := Locx2SELCLI( cCGC)
	Else
		Help("",1,"Locx2SELCLI",,STR0430 + "Locx2SELCLI()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return aCliente

/*/{Protheus.doc} ChkProp
	Función encargada de verificar las propiedades de los documentos fiscales.
	@type  Function
	@author raul.medina
	@since 06/2024
	@param
        cProperty - caracter - nombre de la propiedad consultada
	@return 
        lRet - logico - si la propiedad no existe regresa .F., si la propiedad existe regresa el valor de la propiedad.
	/*/
Static Function ChkProp(cProperty)
Local lRet		:= .F.

Default cProperty := ""

	lRet := lChkLxProp .and. ChkLxProp(cProperty)

Return lRet
