#INCLUDE "PROTHEUS.CH"
#INCLUDE "FISA812.CH"
#INCLUDE "HEADERGD.CH"

#define Confirma 1
#define Redigita 2
#define Abandona 3
 
/*


Ŀ
Funo     FISA812   Autor  Luis Samaniego                   Data  09/05/17  
Ĵ
Descrio  Definicion de Catalogos                                     			 
Ĵ
Sintaxe    FISA812()                                                  			 
Ĵ
 Uso       Generico ( DOS e Windows )                                 			 
Ĵ
               ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.                  
Ĵ
Programador  Data    BOPS                    Motivo da Alteracao               
Ĵ
MCamargo    04/09/17 DMINA-176      Replica 12.1.17 Mod. func MontaColsF3I     
    (MEX)   (12.117)                para mostrar todos los registros de F3I,   
                                    se uso tabla temp. en ValidF3I, se envia   
                                    msj si no existe reg.  y se agrega msj de  
                                    proceso al cargar registros de consulta.   
  Marco A.  19/02/18    DMINA-556   Se replican para V12.1.17, los issues:     
                                     DMINA-385, DMINA-602,  DMINA-723,         
                                     DMINA-814, DMINA-1171, DMINA-1223,        
                                     DMINA-1255, DMINA-1166 y DMINA-1093;      
                                     para Complemento de Pago - CFDI 3.3       
  Marco A.  06/03/18    DMINA-726   Se replican para V12.1.17, los issues:     
                                     DMINA-64, DMINA-445, DMINA-871, DMINA-817,
                                     DMINA-1082 y DMINA-1337; para Esquema CFDI
                                     3.3 (MEX)                                 
 Marco A.   25/04/18   DMINA-1521   Replica de DMINA-1215, que consiste en so- 
                                    lucionar suma de doble descuento al generar
                                    factura a partir de un pedido de venta. MEX
M.Camargo   06/04/18 DMINA-3465     En Func F812SXB se valida que la variable N
                                    __cLineOk y __nOpcx esten activas y se asig
                                    nan a las Varibles nResN, nRescLinOk y     
                                    nResnOpcx . (MEX).                         
Oscar Garcia03/09/18 DMINA-3912     En funcion ValidF3I se evita la eliminacin
                                    de la tabla temporal TRBF3I, ya que al rea-
                                    lizar esto provocaba un errorlog.          
LuisEnriquez12/11/19 DMINA-7694     En funcion ValidF3I se corrige el error.log
                                    presentado por execauto desde ws (MEX)     
ARodriguez  19/08/21DMINA-12690     Permite mantenimiento de Sxxx si es usuario
                                    del grupo administradores. (MEX)           
                                    Filtro variable en consultas. (MEX)        
                                    MontaColsF3I()->F812Tmp()->F812Filtro()    
ٱ


*/
Function FISA812()
Local aArea     := GetArea()
Local aAreaF3H  := F3H->(GetArea())

Private cFiltraF3H   := ""	//Variavel para filtro
Private aIndexF3H    := {}	//Variavel Para Filtro
Private bFiltraBrw   := {|| Nil}	//Variavel para Filtro
Private lF812Copy    := .F.
Private lManutence   := (cPaisLoc$"MEX|COL|PAR" .And. FwIsAdmin())
Private aRotina      := MenuDef()
Private cCadastro    := OemToAnsi(STR0001) + IIf(lManutence,STR0066,"") //"DEFINICAO DE TABELAS"##" - ADMINISTRADOR"

	If F812ModComp("F3H")

		FISA814()

		dbSelectArea("F3H")
		dbGotop()
		cFiltraF3H	:=	'F3H_ORDEM == "01"'

		bFiltraBrw 	:= {|| FilBrowse("F3H",@aIndexF3H,@cFiltraF3H) }
		Eval(bFiltraBrw)

		mBrowse(06,01,22,75,'F3H', , , , , , fUseCor(), , , ,)

		EndFilBrw("F3H",aIndexF3H)
	Endif

	RestArea( aArea )
	RestArea( aAreaF3H)

Return Nil

/*/


Ŀ
Funo     F812Alt   Autor  R.H - Natie            Data  13/06/02 
Ĵ
Descrio  Alteracao da Estrutura do Parametro                        
Ĵ
Sintaxe    ExpN1 := AxAltera(ExpC1,ExpN2,ExpN3,ExpA1,ExpA2)           
Ĵ
Parametros ExpN1 = Opcao devolvida pela funcao                        
           ExpC1 = Alias do arquivo                                   
           ExpN2 = Numero do registro                                 
           ExpN3 = Numero da opcao selecionada                        
           ExpA1 = Array contendo campos a serem mostrados            
           ExpA2 = Array limitando campos a serem aceitos com Get     
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function F812Alt(cAlias, nReg, nOpcx, aAcho, aCpos, nColMens, cMensagem, cTudoOk, lEnable)
//-- Variaveis dimensoes do objeto tela
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aArea			:= GetArea()
Local aAreaF3H		:= F3H->( GetArea() )
Local a310nField	:= {}
Local aColsRec		:= {}
Local aSvCols		:= {}
Local aKeys			:= GetKeys()
Local cProxNum		:= GetMV('MV_F3HNUM')
Local cCond			:= "", cChave:= ""
Local cCodCpy		:= ""
Local nOpca			:= 0
Local oFont
Local oDlgMain
Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }
Local aButtons		:= {}
Local nRecDel		:= 0
Local cFilF3I		:= xFilial("F3I")

Private cFilF3H		:= CriaVar("F3H_FILIAL")
Private cCodigo		:= CriaVar("F3H_CODIGO")
Private cDescF3H	:= CriaVar("F3H_DESC")
Private nOpcao		:= nOpcx
Private nCnt		:= 0
Private lCancel		:= .F.
Private oGeT
Private oCodigo, oDescri
Private oGroup1, oGroup2
Private aColsBkp	:= {}
Private nBkp		:= 0

DEFAULT lEnable		:= .T.

	cFilF3H   := F3H->F3H_FILIAL
	cCodigo   := If( nOpcx = 3, cCodigo , F3H->F3H_CODIGO )
	cDescF3H  := If( nOpcx = 3, cDescF3H, F3H->F3H_DESC   )

	EndFilBrw("F3H",aIndexF3H,.T.)
	aIndexF3H	:= {}

	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 000 , 026 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	Do while .T.

		/*
		Ŀ
		 Campos Nao editaveis                                              	   
		*/
		a310nField	:= {"F3H_CODIGO","F3H_DESC"}

		/*
		Ŀ
		 Verifica existencia de registro qdo for alteracao                     
		*/
		dbSelectArea("F3H")
		dbSetOrder(1)
		dbSeek( cFilF3H+cCodigo )
		If !eof()
			cCodCpy := F3H->F3H_CODIGO
		EndIf
		While !eof() .and. cFilF3H + cCodigo = F3H->F3H_FILIAL+F3H->F3H_CODIGO
			nCnt++
			dbSkip()
		Enddo
	    If nCnt > 0  .And. nOpcx = 3 //--Quando Inclusao e existir Registro
			Help(" ",1,"A310REG")
			Exit
		ElseIf nCnt = 0 .And. nOpcx # 3 //--Quando Nao for Inclusao e nao existir Registro
			Help(" ",1,"A310NREG")
			Exit
		Endif

		/*
		Ŀ
		 Verifica origem Parametro. Nao permite alt. origem Sistema   
		*/
		If ( nOpcx = 4 .or. nOpcx = 5 ) .and. !f812ChkUsr() .and. ( !lManutence ) .and. ( !lF812Copy )
			/*
			Ŀ
			 Se for uma Parametro Definido Pela Microsiga Altera a Opcao  
			 para Visualizacao											       
			*/
			MsgInfo( OemToAnsi(STR0015) , OemToAnsi(STR0014) )
			nOpcx	:= 2
		ElseIf lF812Copy
			nOpcx := 3
		Endif

		/*
		Ŀ
		 Verifica se as variavel esta sendo utilizada no F3I                    
		*/
		If !lManutence .And. !fUsePar(@nOpcx)
			Exit
		EndIf

		/*
		Ŀ
		 Proximo Numero sequencial do Codigo qdo inclusao                  	   
		*/
		If nOpcx == 3
			//-- Pegar e gravar o prximo numero
			If cProxNum  # Nil
				cProxNum1 := Soma1(cProxNum)
			Else
				Break
			EndIf
			IF !( lManutence )
				cCodigo	:=  cProxNum1
			EndIF
		Endif

		/*
		Ŀ
		 Monta a entrada de dados do arquivo                          
		*/
		cCond	:= "F3H_FILIAL+F3H_CODIGO"
		If lF812Copy
			nOpcX := 4
			cChave := xFilial("F3H") + cCodCpy
		Else
			cChave	:= xFilial("F3H") + cCodigo
		EndIf

		aHeader	:= F812aHead(a310nField,cAlias) // Array contendo header
		aCols	:= F812aCols(a310nField, cAlias, cCond, cChave, nOpcx, @aColsRec) // Array contendo aCols
		aSvCols := aClone( aCols )

		If lF812Copy
			nOpcX := 3
		EndIf

		DEFINE FONT oFont  NAME "Arial" SIZE 0,-11 BOLD

		SetaPilha()
		DEFINE MSDIALOG oDlgMain TITLE OemToAnsi( cCadastro ) FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL

			@ aObjSize[1,1], aObjSize[1,2] GROUP oGroup1 TO aObjSize[1,3], (aObjSize[1,4]*0,69) LABEL OemToAnsi(STR0011) OF oDlgMain PIXEL //-"Cod.Tabela"
			oGroup1:oFont:= oFont
			@ aObjSize[1,1], ((aObjSize[1,2])*0,70) GROUP oGroup2 TO aObjSize[1,3], aObjSize[1,4] LABEL OemToAnsi(STR0012) OF oDlgMain PIXEL //-"Descrio"
			oGroup2:oFont:= oFont

			If ( lManutence ) .and. nOpcx == 3
				@ aObjSize[1,1]+10, aObjSize[1,2]+10 MSGET cCodigo SIZE 050,10 OF oDlgMain PIXEL FONT oFont PICTURE "@! S999" VALID If( !lCancel, F812Codigo( cCodigo ), .T. )
			Else
				@ aObjSize[1,1]+12, aObjSize[1,2]+10 SAY cCodigo SIZE 050,10 OF oDlgMain PIXEL FONT oFont
			EndIf
			If nOpcx == 3 .OR. nOpcx == 4 //Se inclusao ou alterao
				@ aObjSize[1,1]+10, aObjSize[1,2]+76	MSGET cDescF3H SIZE 120,09 OF oDlgMain PIXEL FONT oFont PICT "@!"
			Else
			 	@ aObjSize[1,1]+12, aObjSize[1,2]+76 SAY cDescF3H  SIZE 120,10 OF oDlgMain PIXEL FONT oFont
			EndIf

			oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcX,"F812LinOk","F812TudOk","+F3H_ORDEM",If(nOpcx=2.Or.nOpcx=5,Nil,.T.),,,,,"F812CpoOk")
			bSet15 := { || nOpca := 1, If(oGet:TudoOk() .and. fVLdDesc(cDescF3H), oDlgMain:End(),nOpca:=0)}
			bSet24 := { || oDlgMain:End() }

		ACTIVATE MSDIALOG oDlgMain ON INIT EnchoiceBar(oDlgMain, bSet15 , bSet24 , Nil , aButtons ) CENTERED
		SetaPilha()

		IF nOpcA == Redigita
			Exit
		ElseIf nOpcA == Confirma
			If ( nOpcx == 3 .or. nOpcx == 4)
				Begin Transaction
					//--Gravacao
					F812Grava(cAlias, nOpcx, aColsRec, aSvCols)
					//--Processa Gatilhos
					EvalTrigger()
				End Transaction
				//-- Armazena ultimo numero  no SX6
				If nopcx == 3 .and. !( lManutence )
					PutMV('MV_F3HNUM',"U"+Substr(cCodigo,2))
				EndIf
			ElseIf nOpcx == 5
				If lManutence .And. !MsgYesNo(OemToAnsi(STR0067 + CRLF + CRLF + STR0068), OemToAnsi(STR0006))
					Exit
				EndIf

				Begin Transaction
					dbSelectArea( cAlias )
					dbGoto(nReg)
					nRecDel := 0
					While !Eof() .And. &cCond == cChave
						RecLock(cAlias,.F.,.T.)
						dbDelete()
						MsUnlock()
						nRecDel++
						DbSkip()
					EndDo
					If nRecDel > 0
						WRITESX2(cAlias,nRecDel)
					EndIf

					If lManutence
						dbSelectArea( "F3I" )
						dbSetOrder(1)
						nRecDel := 0
						If dbSeek( cFilF3I + cCodigo )
							While !Eof() .And. F3I->(F3I_FILIAL + F3I_CODIGO) == cFilF3I + cCodigo
								RecLock("F3I",.F.,.T.)
								dbDelete()
								MsUnlock()
								nRecDel++
								DbSkip()
							EndDo
							If nRecDel > 0
								WRITESX2("F3I",nRecDel)
							EndIf
						EndIf
					EndIf
				End Transaction
			Endif
		Endif
		Exit
	Enddo

	//--Restaura o Filtro de Browse
	Eval(bFiltraBrw)
	dbGoTo(nReg)

	/*
	Ŀ
	Restaura Area e Ordem de Entrada                              
	*/
	lF812Copy	:= .F.
	RestArea( aArea )
	RestArea( aAreaF3H )
	RestKeys( aKeys,.T. )

Return(Nil)

/*

Ŀ
Funo    F812Codigo   Autor  Mauricio T. Takakura Data  31/01/05 
Ĵ
Descrio  Validacao do campo Codigo                                  
Ĵ
 Uso       F812Codigo                                                 
ٱ

/*/
Static Function F812Codigo( cCodigo )
Local lRet := .T.

	lRet := NaoVazio() .and. ExistChav("F3H", cCodigo, 1) .and. FreeForUse( "F3H", cCodigo )

Return( lRet )

/*

Ŀ
Funo    F812Grava  Autor  Natie                  Data  27/06/02 
Ĵ
Descrio  Grava no arquivo de Parametros                             
Ĵ
 Uso       F812Grava                                                  
ٱ

/*/
Function F812Grava(cAlias,nOpcx,aColsRec, aSvCols)
Local ny        := 0
Local nX        := 0
Local nMaxArray := Len(aHeader)
Local aCampo    := {"F3H_CAMPOS"}
Local nOrdem    := 0
Local nTamVersao:= TamSx3("F3H_VERSAO")[1]

	nUsado := Len(aHeader)
	dbselectArea(cAlias)

	// Se alterao atualiza a descrio da tabela
	If nOpcx == 4
		For nX:=1 TO Len(aColsRec)
			F3H->( dbGoto(aColsRec[nX]) )
			F3H->( RecLock(cAlias,.F.,.T.) )
			F3H->F3H_DESC   := Upper(Alltrim(cDescF3H))
			F3H->( MsUnlock() )
		Next nX
	EndIf

	// Verifica se h necessidade de gravar os itens
	If fCompArray(aCols, aSvCols) .AND. !lF812Copy
		Return
	EndIf

	For nX:=1 TO Len(aCols)
		If nX <= Len(aColsRec) .and. nOpcx # 3
			//--Verifica se esta acols esta deletado
			F3H->( dbGoto(aColsRec[nX]) )
			F3H->( RecLock(cAlias,.F.,.T.) )
			If aCols[nX,nUsado+1]  # .F.
		        F3H->( DbDelete() )
		        Loop
			Endif
		Else
			If aCols[nX,nUsado+1]  = .F.
				F3H->( RecLock(cAlias,.T.,.T.) )
				F3H->F3H_FILIAL := xFilial(cAlias)
				F3H->F3H_CODIGO := cCodigo
				F3H->F3H_DESC   := Upper(Alltrim(cDescF3H))
			Else
				Loop
			Endif
		Endif
		nOrdem  ++
		For ny := 1 To nMaxArray
			cCampo    := Trim(aHeader[ny][2])
			If cCampo == "F3H_ORDEM"
				xConteudo	:= Strzero(nOrdem ,2) //-- Faz o Reordenacao da ordem  dos campos nos casos em  que haja delecao de algum  regitro na GetDados
			Else
				xConteudo := aCols[nX,ny]
			Endif
			If ( ASCAN(aCampo,{|x| x == cCampo }) ) > 0
				xConteudo := StrTran( aCols[nX,ny]," ","" ) //-- Nao permite gravar nome  campo com  espacos
			Endif

			If ( (ValType(&cCampo) == 'N') .AND. (ValType(aCols[nX,ny]) == 'C') )
				xConteudo	:= Val( aCols[nX,ny] )
			ElseIf ( (ValType(&cCampo) == 'C') .AND. (ValType(aCols[nX,ny]) == 'N') )
				xConteudo	:= AllTrim(Str(aCols[nX,ny]))
			EndIf
			&cCampo 	:= xConteudo
		Next ny

		/*
		Ŀ
		Alterar a Versao da Tabela - Apenas em Manutencao Gpea300M    
		*/
		IF ( lManutence )
			F3H->F3H_VERSAO := StrZero(Val(F3H->F3H_VERSAO)+1, nTamVersao)
		EndIF
		F3H->( MsUnlock() )
	Next nx

Return

/*/
Ŀ
Funo    F812Copy   Autor Mauricio T. Takakura    Data 03/12/2004
Ĵ
Descrio  Menu para copiar uma Tabela                                
Ĵ
Sintaxe   F812Copy( cAlias , nReg , nOpc )                            
Ĵ
ParametroscAlias = Alias do arquivo                                   
          nReg   = Numero do registro                                 
          nOpc   = Numero da opcao selecionada                        
Ĵ
 Uso      GPEA310()                                                   
/*/
Function F812Copy( cAlias , nReg , nOpc )

	lF812Copy := .T.

Return( F812Alt( cAlias , nReg , 4 ) )

/*


ͻ
Programa  F812aHead Autor  Natie                Data   17/05/01   
͹
Desc.      Funcao F812aHead() - Monta o array de header - SRB         
                                                                      
͹
Uso        AP6                                                        
ͼ


*/
Static Function F812aHead(aFields,cAlias)
Local aExclui  := { 'F3H_CODIGO','F3H_DESC'} 	// Array de exclusao de campos

Private aTELA[0][0],aGETS[0],aHeader[0],nUsado:=0

	aHeader := GdMontaHeader( NIL ,; //01 -> Por Referencia contera o numero de campos em Uso
					NIL ,; //02 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Virtuais
					NIL ,;	//03 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Visuais
					"F3H" ,; //04 -> Opcional, Alias do Arquivo Para Montagem do aHeader
					aExclui ,; //05 -> Opcional, Campos que nao Deverao constar no aHeader
					NIL ,; //06 -> Opcional, Carregar Todos os Campos
					.T. ,; //07 -> Nao Carrega os Campos Virtuais
					NIL ,; //08 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
					NIL ,; //09 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
					.T. ,; //10 -> Verifica se Deve Checar se o campo eh usado
					.T. ,; //11 -> Verifica se Deve Checar o nivel do usuario
					NIL ,; //12 -> Utiliza Numeracao na GhostCol
					.T. ) //13 -> Carrega os Campos de Usuario

	DbSelectArea( cAlias )
Return aHeader

/*


Ŀ
Funo    F812aCols  Autor  Natie                  Data  21/06/02 
Ĵ
Descrio Criar os Arrays do aCols dos arquivos                       
Ĵ
 Uso      Gpea310                                                     
ٱ

*/
Static Function F812aCols(aFields, cAlias, cCond, cChave, nOpcx, aColsRec)
Local nCntFor := 0
Local nAcols  := 0

Local aSX3      :={}
Local _i        := 0
Local cX3_NIVEL 
Local cX3_USADO
Local cX3_TIPO
Local cX3_TAMANHO
Local nUsado  := Len(aHeader)

	//--Quando for Inclusao criar com 1 elemento
	Private aCols
	If nOpcx = 3 //Inclusao
		nCnt := 1
		aCols := Array( nCnt , nUsado+1 )
	Else //Visualiza Altera
		aCols := {}
	Endif

	dbSelectArea(cAlias)

	If dbSeek(cCHAVE) .and. nOpcx # 3
		While !Eof() .And. &cCond == cChave
			aadd(aCols,Array(nUsado+If(nOpcx#1,1,0)))
			nAcols := Len(aCols)
			For nCntFor := 1 To Len(aHeader)
				If ( aHeader[nCntFor][10] != "V")
					aCols[nAcols][nCntFor] := FieldGet(FieldPos(aHeader[nCntFor][2]))
				Else
					aCols[nAcols][nCntFor] := CriaVar(aHeader[nCntFor][2],.T.)
				EndIf
			Next nCntFor
			If nOpcx # 1
				aCols[nAcols][nUsado+1] := .F.
			EndIf
			dbSelectArea(cAlias)
			Aadd(aColsRec,Recno())
			dbSkip()
		EndDo
	Else
		nUsado:=0
		aSX3 := FWSX3Util():GetAllFields(cAlias , .T.)
		for _i := 1 to len(aSX3)
			If ASCAN(aFields,{ |x| x == Trim(aSX3[_i]) } ) == 0
				cX3_NIVEL := GetSx3Cache(aSX3[_i], "X3_NIVEL")
				cX3_USADO := GetSx3Cache(aSX3[_i], "X3_USADO")
				if cNivel >= cX3_NIVEL .And. X3Uso(cX3_USADO)
					cX3_TIPO := GetSx3Cache(aSX3[_i], "X3_TIPO")
					cX3_TAMANHO := GetSx3Cache(aSX3[_i], "X3_TAMANHO")
					nUsado ++
					IF cX3_TIPO == "C"
						aCOLS[1][nUsado] := SPACE(cX3_TAMANHO)
					ELSEIF cX3_TIPO == "N"
						aCOLS[1][nUsado] := 0
					ELSEIF cX3_TIPO == "D"
						aCOLS[1][nUsado] := CTOD("  /  /  ")
					ELSE
						aCOLS[1][nUsado] := .F.
					Endif
				EndIf
			EndIf
		next _i 
        aCOLS[1][nUsado+1] := .F.
	Endif

	aCols[1][GdFieldPos("F3H_ORDEM")] := '01' //-- Inicia Ordem com 1
	aColsBkp := Aclone(aCols)
	nBkp     := Len(aColsBkp)
Return aCols

/*/


Ŀ
Funo    F812CpoOk  Autor  Natie                  Data  21/08/02 
Ĵ
Descrio Critica cpo digitado                                        
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function F812CpoOk(o)
Local lCpoOk     := .T.
Local cVar       := Alltrim(ReadVar())
Local aNaoValido := {"<",">","%",",","(","/","$","."} //Array caracteres nao validos para composicao do nome do campo
Local nY

	If cVar ="M->F3H_CAMPOS"
		For  nY:= 1 to Len(aNaoValido)
			If 	aNaovalido[nY] $  &cVar
				MsgAlert( OemToAnsi( STR0033 ) , OemToAnsi( STR0014 ) ) // caracter invalido na composicao no nome  do campo
				lCpoOk	:= .F.
			Endif
		Next
	Endif

Return lCpoOk

/*/


Ŀ
Funo    F812LinOk  Autor  Natie                  Data  01/07/02 
Ĵ
Descrio Critica linha digitada                                      
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function F812LinOk(o)
Local nPosTam  := GdFieldPos("F3H_TAMAN")
Local nPosCpo  := GdFieldPos("F3H_CAMPOS")
Local nPosDesc := GdFieldPos("F3H_DESCPO")
Local nUsado   := Len(aHeader)
Local lLinOk   := .T.
Local nTeste   := aScan(aCols,{|X| X[nPosDesc] == aCols[n][nPosDesc]})

	If  !( aCols[n,nUsado+1] )
		If ValType( aCols[n][nPosCpo] ) == 'N'
			aCols[n][nPosCpo]	:=	AllTrim(Str(aCols[n][nPosCpo]))
		EndIf
		If (IIF(Valtype(aCols[n][nPosCpo]) == "C", Empty(aCols[n][nPosCpo]), aCols[n][nPosCpo] == 0);
			 .or. IIF(ValType(aCols[n][nPosTam]) == "N", aCols[n][nPosTam] == 0 , Empty(aCols[n][nPosTam])) )
			If ( Empty(aCols[n][nPosCpo]) )
				MsgAlert( oEmtoAnsi(STR0031),oEmToAnsi(STR0014) ) //--"Nome,tipo e tamanho do campo devem ser informados"
				lLinOk	:= .F.
			Else
				MsgAlert( oEmtoAnsi(STR0016),oEmToAnsi(STR0014) ) //-- "O campo Tamanho deve ter valor maior que zero"
				lLinOk	:= .F.
			EndIf
		Else
			If nTeste <> n
				MsgAlert( oEmtoAnsi(STR0054),oEmToAnsi(STR0014) ) //--"A descrio do campo no pode ser repetida."
				lLinOk	:= .F.
			Endif
		EndIf
		fAtualizaBkp1()
	Else
		DbSelectArea("F3I")
		DbSetOrder(1)
		DbSeek( xFilial("F3H") + cCodigo, .F.)
		If ( F3I->( !Eof() ) ) .and. ( n <= nCnt)
			Help(" ",1,"A310DEL") // "Existem Registros desta Tabela sendo utilizados." ## "Exclua todos os registros na Manuteno Tabela"
			If !lManutence
				lLinOK := .F.
			EndIf
		EndIf
		fAtualizaBkp1()
	Endif
	oGet:oBrowse:nAt := n
	oGet:oBrowse:Refresh(.T.)

Return lLinOk

/*/


Ŀ
Funo    F812TudOk  Autor  Natie                  Data  01/07/02 
Ĵ
Descrio Critica linhas digitadas                                    
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function F812TudOk(o)
Local aString     := {}
Local bBlock      := ErrorBlock(),bErro := ErrorBlock( { |e| ChecErro(e) } )
Local cTipoVar
Local cString
Local cForm
Local lTudoOk     := .T.
Local nLin
Local nX          := 0
Local nTam        := 0
Local nUsado      := Len(AHEADER)
Local nPosCpo     := GdFieldPos("F3H_CAMPOS")
Local nPosPesq    := GdFieldPos("F3H_PESQ")
Local nPosValid
Local nPosTipo
Local nPosTam
Local nPosFun     := 0
Local uValor
Local lTpBusca    := .F.

	Begin  Sequence

		For nLin := 1 To Len(aCols)
			If aCols[nLin,nUsado+1]  = .T.
				Loop
			Endif
			cString := ""
			cString += cCodigo+aCols[nLin,nPosCpo]
			If Len(cString) > 0
				Aadd( aString,cString )
			Endif
			If nPosPesq > 0 .And. aCols[nLin,nPosPesq] == "1"
				lTpBusca := .T.
			Endif
		Next
	    If nPosPesq > 0 .And. !lTpBusca
			lTudoOk := .F.
			Alert(STR0056) //-"Deve existir pelo menos um campo 'Usado Pesq ?' preenchido como 'Sim' !!!"
			Break
		Endif

		ASORT(aString)
		cString := ""
		//-- verifica se ha chave duplicada
		For nLin := 1 To Len(aString)
			If cString = aString[nLin]
				lTudoOk := .F.
				Help(" ",1,"A310CHADUP") //-- Chave duplicada
				Break
			Endif
			cString := aString[nLin]
		Next

		//-- Valida o conteudo do Campo F3H_VALIDA - Validacao
		nPosValid := GdFieldPos( "F3H_VALID" )
		nPosTipo  := GdFieldPos( "F3H_TIPO" )
		nPosTam   := GdFieldPos( "F3H_TAMAN" )

		For nLin := 1 To Len(aCols)
			If nPosValid > 0
				cForm 	  := AllTrim(aCols[nLin, nPosValid])
			EndIf
			nPosForm := 0

			//-- Verifica se existe fc valida no repositorio
			If  !Empty( cForm )
				/*
				Ŀ
				Declarar a variavel do campo, para validacoes do Campo Valid  
				*/
				cTipoVar := AllTrim(aCols[nLin, nPosTipo])
				If cTipoVar == "C"
					uValor := "A"
				ElseIf cTipoVar == "N"
					uValor := 1
				ElseIf cTipoVar == "D"
					uValor := CTOD("01/01/2000")
				ElseIf cTipoVar == "L"
					uValor := .T.
				EndIf

				// Atribui o primeiro valor do conjunto para a funo PERTENCE()
				If "PERTENCE(" $ cForm
					nPosFun :=	At("PERTENCE(", cForm) + 10
					uValor := Substr(cForm,nPosFun,1)
	                // Inclui campo como segundo parmetro
					For nX := nPosFun To Len(cForm)
						If Substr(cForm, nX,1) == ")"
							// Quantidade de caracteres a serem eliminados.
							nTam := Len(AllTrim(aCols[nLin, nPosCpo])) + 6 // Os 6 a mais so ", " , "M->" e ")"
							// Substitui contedo
							cForm := STUFF(cForm, nX, nTam ,", " + "M->" + AllTrim(aCols[nLin, nPosCpo]) + ")"  )
							Exit
						EndIf
					Next nX
				EndIf
			    If "NAOVAZIO" $ cForm
			    	cForm := STRTRAN(cForm, "NAOVAZIO()", "NAOVAZIO(" + "M->" + AllTrim(aCols[nLin, nPosCpo]) + ")"  )
			    EndIf

				&("M->" + AllTrim(aCols[nLin, nPosCpo])) := uValor
				lTudoOk := CheckExecForm( cForm, .T. )

				If !lTudoOk
					Break
				EndIf
			EndIF
	    Next nLin

	End Sequence

Return lTudoOk

/*/


Ŀ
Funo    fUseCor    Autor  Natie                  Data  01/07/02 
Ĵ
Descrio Legenda de cores                                            
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Static Function fUsecor()
Local aMarks := {}

	aMarks	:=	{{ "Substr(F3H->F3H_CODIGO,1,1)=='U'" , "BR_VERDE"	} ,;
				 { "Substr(F3H->F3H_CODIGO,1,1)=='S'" , "BR_AZUL"	} }

Return( aClone( aMarks ) )

/*/


Ŀ
Funo    F812Leg    Autor  Natie                  Data  01/07/02 
Ĵ
Descrio Legenda de Cores                                            
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function F812Leg()
Local aLegenda	:= {}

	aLegenda := { { "BR_AZUL"  , OemToAnsi( STR0008 ) } ,; //"Formula Definida Pela Microsiga"
	              { "BR_VERDE" , OemToAnsi( STR0009 ) } }  ; //"Formula Definida Pelo Usuario"

	BrwLegenda(	cCadastro ,	oEmToAnsi(STR0010) , aLegenda ) //Legenda do Cadastro de Paramentros

Return( NIL )

/*

Ŀ
Funo    f812ChkUsr Autor  R.H. -  Natie          Data  23/05/02 
Ĵ
Descrio  Carrega as variaveis p/cadastro de Parametros              
Ĵ
Sintaxe    f812ChkUsr()                                               
Ĵ
Parmetros                                                            
                                                                      
                                                                      
Ĵ
Uso        Genrico                                                   
ٱ

*/
Function f812ChkUsr()
	Local lUsuario := If(Substr(cCodigo,1,1) = "U",.T.,.F.)
Return lUsuario

/*/


Ŀ
Funo    F812ChkTaman  Autor  Natie               Data  01/07/02 
Ĵ
Descrio Nao permite que tamanho F3H_CONTEU ultrapase tamanho de 250 
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function F812ChkTaman(nCampo)
Local nx
Local nMaxField	:= 250
Local nTamField	:= 0
Local nUsado 		:= Len(aHeader)
Local nPosTam		:= GdFieldPos("F3H_TAMAN")
Local nPosTipo	:= GdFieldPos("F3H_TIPO")
Local nPosDec 	:= GdFieldPos("F3H_DECIMA")

	//-- Valida tipo e tamanho do campo data
	If !( ValType(nCampo) == 'N' )
		nCampo	:= Val(nCampo)
	EndIf
	If aCols[n][nPosTipo]="D" .and. ;
		nCampo  # 8
		MsgInfo( oEmToAnsi(STR0028) , oEmToAnsi(STR0014) )
		aCols[n][nPostam]	:= 8
		aCols[n][nPosdec]	:= 0
		Return .F.
	Endif

	//-- Valida tamanho dos campos que serao armazenados no F3I_CONTEU
	nAcols:= If( Len(Acols)= 1 ,1, len(aCols)-1 )
	For nx:= 1 to naCols
		If aCols[nx][nUsado+1]=.F. .and. (aCols[nx] # aCols[n])
			nTamField 	+=  aCols[nx][nPosTam]
		Endif
	Next nx
	nTamField	+= nCampo //-- Somatoria do tamanho dos campos
	If  nTamField > nMaxField
		//--"Tamanho mximo de 250 excedido"
		MsgAlert( oEmToAnsi(STR0018),oEmToAnsi(STR0014) )
		Return .F.
	Endif

Return .T.

/*/


Ŀ
Funo    f812ChkDec Autor  Natie                  Data  01/07/02 
Ĵ
Descrio Critica Campo Decimal                                       
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function f812ChkDec(nDecimal)
Local nPosTipo	:= GdFieldPos("F3H_TIPO")
Local lCpoOk	:= .T.

	If	aCols[n][nPosTipo]	$"DC" .and.  nDecimal > 0 //-- Tipo data e caracter nao devem possuir casa decimal
		MsgAlert( oEmToAnsi(STR0017),oEmToAnsi(STR0014) )
		lCpoOk	:= .F.
	Endif

Return lCpoOK

/*/


Ŀ
Funo    f812ChkTipo Autor  Natie                  Data  01/07/02 
Ĵ
Descrio                                                             
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function  f812ChkTipo(cTipo)
Local nPosTam	:= GdFieldPos("F3H_TAMAN")
Local nPosDec 	:= GdFieldPos("F3H_DECIMA")

	If 	cTipo == "D"
		aCols[n][nPostam]	:= 8
		aCols[n][nPosdec]	:= 0
	ElseIf cTipo == "C"
		aCols[n][nPosdec]	:= 0
	EndIf

RETURN .T.

/*/


Ŀ
Funo    fUsePar    Autor  Natie                  Data  01/07/02 
Ĵ
Descrio  Verifica a existencia de tabela utilizando o parametro     
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Static function fUsePar(nOpcx)
Local aArea     := GetArea()
Local aAreaF3H  := F3H->( GetArea() )
Local lRet      := .T.	//#Variavel de retorno

	DbSelectArea("F3I")
	dbSetOrder(1)
	DbSeek(xFilial("F3I")+ cCodigo)
	If !eof() .and. nOpcx = 5
		//# "Excluso negada. existe um ou mais lanamentos fixos para esta tabela."
		MsgAlert(oEmToAnsi(STR0048),oEmToAnsi(STR0014))
		lRet := .F.
	Endif
	/*
	Ŀ
	Restaura Area e Ordem de Entrada                              
	*/
	RestArea( aArea )
	RestArea( aAreaF3H)

Return(lRet)

/*/

Ŀ
Funo    f812VerChav| Autor                        Data           
Ĵ
Descrio Validar campo chave                                         
Ĵ
 Uso       gpea310                                                    
ٱ
*/
Function  f812VerChav(cAlias,cAuxChave)
Local nPosCpo    := GdFieldPos("F3H_CAMPOS")
Local aString    := {}
Local nLin       := 0
Local cString    := ""
Local nUsado     := Len(aheader)
Local lChaveOk   := .T.

	For nLin := 1 To Len(aCols)
		If aCols[nLin,nUsado+1]  = .T.
			Loop
		Endif
		cString += cCodigo + aCols[nLin,nPosCpo]
		If Len(cString) > 0 //-- compara o campo digitado com  o armazenado no aCols
			Aadd(aString,cString)
		Endif
		cString := ""
	Next

	If Len(aString) > 0 .and.  ;
	   ( Ascan(aString,{|x|cCodigo + cAuxChave == x } ) )  > 0
		Help(" ",1,"A310CHADUP")
		lChaveOk	:= .F.
	Endif

Return lChaveOk

/*/

Ŀ
Funo    F812ModComp  | Autor                         Data           
Ĵ
Descrio Validar campo chave                                            
Ĵ
 Uso       gpea310                                                       
ٱ
*/
Function F812ModComp(cAlias)
Local lComp := (FWModeAccess(cAlias, 3) == "C")

	IF !lComp
		//"O Modo de Acesso ser COMPARTILHADO."
		MsgInfo( oEmToAnsi( STR0029 ) + CRLF + oEmToAnsi( STR0030 ) )
	EndIF

Return( lComp )

/*/


Ŀ
Funo    f812ConsPadAutor  Natie                  Data  21/08/02 
Ĵ
Descrio Seleciona alias na Consulta Padrao                          
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function f812ConsPad( )

	Help(,,"812ConsPad", ,STR0069, 1, 0)

Return .T.

/*/


Ŀ
Funo    fVLdDesc   Autor  Natie                  Data  17/02/04 
Ĵ
Descrio Valida Campo Descricao da Tabela                            
Ĵ
Uso        Generico                                                   
ٱ

/*/
Static Function  fVLdDesc(cDescF3H)

	If Empty(cDescF3H)
		MsgAlert( oemToAnsi(STR0034) ) //"Digite o nome da tabela"
		Return(.F.)
	Endif

Return(.T.)

/*

			F U N C O E S    U T I L I Z A D A S    P O R    S X 3
*/
Function F812Valid()
Local cCampo 	:= Substr(ReadVar(),4)
Local lRet		:= .T.

	If (cCampo == "F3H_TIPO") .Or. (cCampo == "F3H_TAMAN") .Or. (cCampo == "F3H_DECIMA")
		DbSelectArea("F3I")
		DbSetOrder(1)
		DbSeek( xFilial("F3H") + cCodigo, .F.)
		If ( F3I->( !Eof() ) ) .and. ( n <= nCnt)
			Help(" ",1,"A310DEL") // "Existem Registros desta Tabela sendo utilizados." ## "Exclua todos os registros na Manuteno Tabela"
			If lManutence
				lRet := .T.
			Else
				lRet := .F.
			EndIf
		EndIf
	EndIf

Return( lRet )

/*


Ŀ
Funo     fAtualizaBkp1   Autor: Kelly Soares      Data  30.11.05 
Ĵ
Descrio  Atualiza a array de bkp dp aCols.                          
Ĵ
 Uso       Generico                                                   
ٱ

*/

Static Function fAtualizaBkp1()
Local nX

	If nBkp < Len(aCols)
		aAdd(aColsBkp , Array(len(aCols[n])))
		For nX := 1 to len(aCols[n])
			aColsBkp[n,nX] := aCols[n,nX]
		Next nX
		nBkp ++
	Endif
Return

/*
Ŀ
Funo     MenuDef		Autor  Luiz Gustavo      Data 07/12/2006
Ĵ
Descrio Isola opcoes de menu para que as opcoes da rotina possam    
          ser lidas pelas bibliotecas Framework da Versao 9.12 .      
Ĵ
Sintaxe   < Vide Parametros Formais >									
Ĵ
 Uso      GPEA310                                                     
Ĵ
 Retorno  aRotina														
Ĵ
Parametros< Vide Parametros Formais >									
*/

Static Function MenuDef()

	Local aRotina := { { STR0002   , 'PesqBrw'   , 0 , 1,,.F.},; //'Pesquisar'
	                   { STR0003   , 'F812Alt'   , 0 , 2},; //'Visualizar'
	                   { STR0004   , 'F812Alt'   , 0 , 3},; //'Incluir'
	                   { STR0005   , 'F812Alt'   , 0 , 4},; //'Alterar'
	                   { STR0006   , 'F812Alt'   , 0 , 5},; //'Excluir'
	                   { STR0035   , 'F812Copy'  , 0 , 6},; //'Copiar'
	                   { STR0007   , 'F812Leg'   , 0 , 7, ,.F.} } //'Legenda'

Return aRotina

/*


ͻ
Programa   F812SXB   Autor  Ademar Fernandes    Data   29/10/08             
͹
Descricao  Exibe Tela de Pesquisa de tabelas do F3I                             
                                                                                
͹
Uso        Consulta Padrao Especifica - SXB                                     
ͼ


*/
Function F812SXB( cTabela, cCpoRet, cFiltro )
Local aArea			:= GetArea()
Local nOpca			:= 0, i,lAllOk
Local oDlg, cCampo, nX, nY, cCaption, cPict, cValid, cF3, cWhen, nLargSay, oSay, oGet
Local cBlkGet,cBlkWhen,cBlkVld, oSaveGetdad := Nil, aSvRot := Nil
Local oTop
Local aObject		:= {}
Local aSize			:= {}
Local nObject
Local aCordW		:= {125,0,400,635}
Local cSvField		:= IIF("M->"$ReadVar(),&(ReadVar()),"")
Local nCount		:= 0
Local cMyCpo		:= ""	// Al compilar indica como no usada... no quitar!
Local cLineOk		:= "AllwaysTrue()"
Local cAllOk		:= "AllwaysTrue()"
Local nOpcx			:= 7
Local aCGD			:= {}
Local lExist		:= .F.
Local nCpoRet		:= 0
Local cPesq			:= Space(30)
Local nCntCmb		:= 0
Local nMaxCmb		:= 5 //# Nr.Maximo de opcoes no Combo
Local nPos			:= At("+", cCpoRet )
Local cCpoAux		:= ""
Local cF3HCampo		:= ""
Local cF3HDescr		:= ""
Local nResN			:= IIF(IsMemVar('N'), N, 0)
Local nRescLinOk	:= IIF(IsMemVar("__cLineOk"), __cLineOk, 0)
Local nResnOpcx		:= IIF(IsMemVar('__nOpcx'), __nOpcx, 0)
Local nCmbLin       := 0
Local nPosCpo       := 0

Private cCombo		:= ""
Private aCombo		:= {}
Private aMyCombo	:= {}
Private aSXBCols	:= {}
Private aSXBHeader	:= {}
Private nUsado		:= 0
Private cFilF3H		:= ""
Private cFilF3I		:= ""
Private cDescF3I	:= ""
Private lPesqComp	:= .F. //Variavel que indica se a pesquisa esta sendo feita com mais de um campo
Private cReadVar	:= Alltrim(ReadVar()) // Se usa en la funcin F812ChkCampo() ya que se pierde al ejecutar MontaColsF3I() por CodeBlock
Default cFiltro		:= ""

	If cTabela == NIL .Or. cCpoRet == NIL
		MsgAlert(OemToAnsi(STR0049),OemToAnsi(STR0014)) // "No  possvel continuar pois faltam parametros nesta funo !!!"##"Ateno !"
		N := nResN
		__cLineOk := nRescLinOk
		__nOpcx := nResnOpcx
		Return(.F.)
	EndIf

	If nPos > 0
		lPesqComp := .T.
	EndIf

	//# Posiciona no F3H
	dbSelectArea("F3H")
	dbSetOrder(1)
	If !dbSeek(xFilial("F3H")+cTabela,.F.)
		MsgAlert(OemToAnsi(STR0050),OemToAnsi(STR0014)) // "A Tabela informada no existe !!!"##"Ateno !"
		N := nResN
		__cLineOk := nRescLinOk
		__nOpcx := nResnOpcx
		Return(.F.)
	EndIf

	cFilF3H  := xFilial("F3H")
	cDescF3I := Alltrim(F3H_DESC)
	//# Posiciona no F3I
	dbSelectArea("F3I")
	dbSetOrder(1)
	If !ExistR812Tab(cTabela) //!dbSeek(xFilial("F3I")+cTabela,.F.)
		MsgAlert(OemToAnsi(STR0051),OemToAnsi(STR0014)) // "No existe informaes cadastradas para Tabela !!!"##"Ateno !"
		N := nResN
		__cLineOk := nRescLinOk
		__nOpcx := nResnOpcx
		Return(.F.)
	EndIf

	cFilF3I := xFilial("F3I")
	fMontHeadF3I( cTabela, cCpoRet )
	Processa( {|| MontaColsF3I( cTabela, cCpoRet, , cFiltro )}, STR0014, STR0062, .F. )//"Cargando catlogo de Prod/Serv SAT.."	"Atencin!"

	//# Variaveis inicializadas no teste
	Private cTitulo := cTabela+" - "+cDescF3I //#"U014 - Teste"
	Private nMax := Len(aSXBCols)
	Private aC := {}
	Private aColsBkp := aClone(aSXBCols)

	//# Variaveis inicializadas no teste
	aAdd(aC,{"cMyCpo", {15,001},"",,,,.F.,})

	nCount++
	__cLineOk := cLineOK
	__nOpcx   := nOpcx
	If nCount > 1
		oSaveGetdad := oGetDad812
		oSaveGetdad:oBrowse:lDisablePaint := .t.
	EndIf

	oGets := {}
	If Type("aRotina") == "A"
		aSvRot := aClone(aRotina)
	EndIf

	aRotina := {}
	For nX := 1 to nOpcX
		AADD(aRotina,{"","",0,nOpcx})
	Next

	aCGD:=Iif(Len(aCGD)==0,{34,5,128,315},aCGD)

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(cTitulo) FROM aCordW[1],aCordW[2] TO aCordW[3],aCordW[4] PIXEL OF oMainWnd

	If Len(aC) > 0
		//# Monta o Combo a partir do Titulo do F3H
		dbSelectArea("F3H")
		dbSeek(xFilial("F3H")+cTabela,.F.)
		While !Eof() .And. F3H->(F3H_FILIAL+F3H_CODIGO) == (cFilF3H+cTabela)
			//# Verifica se o campo ja existe
			If !lExist .And. ValType("F3H->F3H_PESQ")<>"U"
				lExist := .T.
			EndIf
			//# Monta o aCombo e aMyCombo
			If !lExist .Or. (lExist .And. F3H->F3H_PESQ=="1")
				nCntCmb += 1
				If nCntCmb == 1
					cCombo := Alltrim(Capital(F3H_DESCPO))
				EndIf
				aAdd( aCombo, Alltrim(Capital(F3H_DESCPO)) )
				aAdd( aMyCombo, {Alltrim(Capital(F3H_DESCPO)),Alltrim(F3H_CAMPOS)} )
				If lPesqComp .And. At(Alltrim(F3H_CAMPOS), cCpoRet) > 0
					cF3HDescr += Alltrim(Substr(Capital(F3H_DESCPO),1,9)) + '+'
					cF3HCampo += Alltrim(F3H_CAMPOS) + '+'
				Endif
				If nCntCmb >= nMaxCmb
					Exit
				EndIf
			EndIf
			dbSkip()
		EndDo

		If lPesqComp
			cF3HDescr := Substr(cF3HDescr, 1, Len(cF3HDescr)-1)
			cF3HCampo := Substr(cF3HCampo, 1, Len(cF3HCampo)-1)
			nCntCmb += 1
			aAdd( aCombo, Alltrim(cF3HDescr) )
			aAdd( aMyCombo, {Alltrim(cF3HDescr),Alltrim(cF3HCampo)} )
		Endif

		//Ordena por primer opcin de filtrado
		If !Empty(cCombo)
			nCmbLin := aScan( aMyCombo, { |x| Alltrim(x[01]) == Alltrim(cCombo)} )
			nPosCpo := GdFieldPos(aMyCombo[nCmbLin,02],aSXBHEADER)
			If nPosCpo > 0
				CursorWait()
				ASort(@aSXBCols,,,{|x,y| x[nPosCpo] < y[nPosCpo]})
				CursorArrow()
			EndIf
		EndIf

		dbSelectArea("F3I")

		@ 000,000 SCROLLBOX oTop
		Aadd(aSize,aCGD[1]+13)
		Aadd(aObject,oTop)
		nObject := 2

		Private oCombo, oPesq, oBtn1, oCheckBox, lCheck

		@ 005,005 SAY OemToAnsi(STR0052) SIZE 35,07 OF oTop PIXEL // "Pesquisar por: "
  		@ 005,045 MSCOMBOBOX oCombo VAR cCombo ITEMS aCombo SIZE 080,013 OF oTop PIXEL
		oCombo:bChange := {||F812Ord()}
		@ 005,130 MSGET oPesq VAR cPesq PICTURE "@!" VALID Iif(!Empty(cCombo),Pesq812Dad(cPesq),f812ValPesq()) SIZE 80,10 OF oTop PIXEL
		@ 013,420 BTNBMP oBtn1 RESOURCE "btpesq" SIZE 025,025 OF oTop PIXEL ACTION ( Pesq812Dad(cPesq) )

		For i:=1 to Len(aC)
			cCampo:=aC[i,1]
			nX:=aC[i,2,1]-13
			nY:=aC[i,2,2]
			cCaption:=Iif(Empty(aC[i,3])," ",aC[i,3])
			cPict:=Iif(Empty(aC[i,4]),Nil,aC[i,4])
			cValid:=Iif(Empty(aC[i,5]),".t.",aC[i,5])
			cF3:=Iif(Empty(aC[i,6]),NIL,aC[i,6])
			cWhen    := Iif(aC[i,7]==NIL,".t.",Iif(aC[i,7],".t.",".f."))
			cWhen    := Iif(!(Str(nOpcx,1,0)$"346"),".f.",cWhen)
			cBlKSay  := "{|| OemToAnsi('"+cCaption+"')}"
			oSay     := TSay():New( nX+1, nY, &cBlkSay,oTop,,, .F., .F., .F., .T.,,,,, .F., .F., .F., .F., .F. )
			nLargSay := GetTextWidth(0,cCaption) / 1.8// estava 2.2
			cCaption := oSay:cCaption
			cBlkGet  := "{ | u | If( PCount() == 0, "+cCampo+","+cCampo+":= u ) }"
			cBlKVld  := "{|| "+cValid+"}"
			cBlKWhen := "{|| "+cWhen+"}"
			oGet := TGet():New( nX, nY+nLargSay,&cBlKGet,oTop,,,cPict, &(cBlkVld),,,, .F.,, .T.,, .F., &(cBlkWhen), .F., .F.,, .F., .F. ,cF3,(cCampo))
			AADD(oGets,oGet)
		Next
	EndIf

	oGetDad812 := MsNewGetDados():New(aCGD[1],;// nTop
	                             aCGD[2],; // nLelft
	                             aCGD[3],; // nBottom
	                             aCGD[4],; // nRright
									 nOPCX,; // controle do que podera ser realizado na GetDado - nstyle
									 "SXB812M2LOk()",; // funcao para validar a edicao da linha - ulinhaOK
									 "AllwaysTrue()",; // funcao para validar todas os registros da GetDados - uTudoOK
	  								 NIL,; // cIniCPOS
									 NIL,; // aAlter
									 0,; // nfreeze
									 nMax,; // nMax
									 NIL,; // cFieldOK
									 NIL,; // usuperdel
									 .F.,; // udelOK
									 @oDlg,; // objeto de dialogo - oWnd
									 @aSXBHeader,; // Vetor com Colunas - AparHeader
									 @aSXBCols) // Vetor com Header - AparCols

	Aadd(aObject,oGetDad812:oBrowse)
	Aadd(aSize,NIL)

	ACTIVATE MSDIALOG oDlg CENTERED ON INIT (EnchoiceBar(oDlg,{||nOpca:=1,lAllOk:=__812M2Ok(cAllOk),Iif(lAllOk,oDlg:End(),nOpca:=0)},{||oDlg:End()},,),;
									AlignObject(oDlg,aObject,1,nObject,aSize),oGetDad812:oBrowse:Refresh())

	nCount--
	If nCount > 0
		oGetDad812 := oSaveGetDad
		oGetDad812:oBrowse:lDisablePaint := .f.
	EndIf
	If ValType(aSvRot) == "A"
		aRotina := aClone(aSvRot)
	EndIf

	If nOpca == 1 .and. Len(aSXBCols)>0
		If !lPesqComp
			nCpoRet := GdFieldPos(cCpoRet, aSXBHeader)
			VAR_IXB  := aSXBCols[oGetDad812:nAt,nCpoRet]
		Else
			VAR_IXB := ""
			While lPesqComp
				cCpoAux := Substr(cCpoRet, 1, nPos - 1)
				cCpoRet := Substr(cCpoRet, nPos +1)
				nCpoRet := GdFieldPos(cCpoAux, aSXBHeader)
				VAR_IXB += aSXBCols[oGetDad812:nAt,nCpoRet]
				nPos := At("+", cCpoRet )
				lPesqComp := If (nPos > 0, .T., .F.)
				If nPos == 0
					nCpoRet := GdFieldPos(cCpoRet, aSXBHeader)
					VAR_IXB += aSXBCols[oGetDad812:nAt,nCpoRet]
				Endif
			EndDo
		Endif
	Else
		VAR_IXB := cSvField
		RestArea(aArea)
		N := nResN
		__cLineOk := nRescLinOk
		__nOpcx := nResnOpcx
		Return .T.
	EndIf

	RestArea( aArea )
	N := nResN
	__cLineOk := nRescLinOk
	__nOpcx := nResnOpcx

Return(nOpca == 1)

/*


ͻ
Programa             Autor  Ademar Fernandes    Data   31/10/08   
͹
Descricao  Ordena o aCols de acordo com o ComboBox escolhido pelo usu-
           ario, isso se o CheckBos for marcado                       
͹
Uso        F812SXB                                                    
ͼ


*/
Function F812Ord()
Local nCmbLin := aScan( aMyCombo, { |x| Alltrim(x[01]) == Alltrim(cCombo)} )
Local nPosCpo := 0
Local lCheck  := .T.
	CursorWait()
	nPosCpo := GdFieldPos(aMyCombo[nCmbLin,02],aSXBHEADER)
	If lCheck
		ASort(@aSXBCols,,,{|x,y| x[nPosCpo] < y[nPosCpo]})
		oGetDad812:aCols := aClone(aSXBCols)
	Else
		aSXBCols := aClone(aColsBkp)
	EndIf
	CursorArrow()
	oGetDad812:oBrowse:Refresh()

Return


Function SXB812M2LOk()
Local lRet:=.t. , ni

	If Str(__nOpcx,1,0)$"346"
		lRet := &__cLineOK
		For ni:= 1 to Len(oGets)
			oGets[ni]:Refresh()
		Next
	EndIf

Return lRet


Function __812M2Ok(cAllOK)
Local lRet

	lRet := SXB812M2LOk()
	If lRet
		lRet := &cAllOk
	EndIf

Return lRet

/*


ͻ
Programa             Autor  Ademar Fernandes    Data   30/10/08   
͹
Descricao  Monta o aHeader da Tela de Pesquisa de tabelas do F3I      
                                                                      
͹
Uso        F812SXB                                                    
ͼ


*/
Function fMontHeadF3I(cTabela, cPesqComp)
Local aArea   := GetArea()
Local nQtdCol := 99
Local nTamAux := 0

Default cPesqComp := ""

	dbSelectArea("F3H")
	nUsado:=0
	aSXBHeader:={}

	//# Cria campo F3I_SEQUEN
	nUsado += 1
	aAdd(aSXBHeader,{ "Seq", ; //# 01
					"F3I_SEQUEN", ; //# 02
					"@!", ; //# 03
					3, ; //# 04
					0, ; //# 05
					NIL, ; //# 06
					NIL, ; //# 07
					"C", ; //# 08
					NIL,  ; //# 09
					"R" } ) //# 10 Real ou Virtual

	While !Eof() .And. F3H->(F3H_FILIAL+F3H_CODIGO) == (cFilF3H+cTabela)
		//Alltrim(F3H_VALID), ; //# 06
		If nUsado > nQtdCol
			Exit
		Else
			nUsado += 1
			aAdd(aSXBHeader,{Alltrim(Capital(F3H_DESCPO)), ; //# 01
							Alltrim(F3H_CAMPOS), ; //# 02
							Alltrim(F3H_PICTUR), ; //# 03
							F3H_TAMAN, ; //# 04
							F3H_DECIMA, ; //# 05
							NIL, ; //# 06
							NIL, ; //# 07
							F3H_TIPO, ; //# 08
							NIL, ; //# 09
							"R", ; //# 10 Real ou Virtual
	 						NIL, ; //# 11 cbox
							NIL, ; //# 12 relacao
							NIL, ; //# 13 when
							"V" } ) //# 14 visual ou altera
			If lPesqComp .And. At(Alltrim(F3H_CAMPOS), cPesqComp) > 0
				nTamAux += F3H_TAMAN
			Endif
		Endif
		dbSkip()
	EndDo

	If lPesqComp
		nUsado += 1
		aAdd(aSXBHeader,{Alltrim(Capital(F3H_DESCPO)), ; //# 01
						Alltrim(cPesqComp), ; //# 02
						"!@", 				; //# 03
						nTamAux, ; //# 04
						NIL, ; //# 05
						NIL, ; //# 06
						NIL, ; //# 07
						NIL, ; //# 08
						NIL, ; //# 09
						"V", ; //# 10 Real ou Virtual
						NIL, ; //# 11 cbox
						NIL, ; //# 12 relacao
						NIL, ; //# 13 when
						"V" } ) //# 14 visual ou altera
	Endif

	RestArea( aArea )

Return

/*


ͻ
Programa             Autor  Ademar Fernandes    Data   30/10/08   
͹
Descricao  Monta o aCols da Tela de Pesquisa de tabelas do F3I        
                                                                      
͹
Uso        F812SXB                                                    
ͼ


*/
Function MontaColsF3I( cTabela, cCpoPesq, cCpoFiltro, cFiltro )
Local aArea			:= GetArea()
Local nCnt			:= 0
Local nQtdLin		:= 0
Local uValor
Local nCpoAux1		:= 1
Local nCpoAux2		:= 0
Local cTrb			:= ""
Local lTrb			:= .F.

Default cCpoPesq	:= ""
Default cCpoFiltro	:= ""
Default cFiltro		:= ""

	aSize(aSXBCols, 0)
	nCont := 0
	nCpo1 := 1
	nCpo2 := 0

	If !Empty( cCpoFiltro ) .And. !Empty( cFiltro )
		For nCnt := 1 to Len(aSXBHeader)
			If Alltrim(aSXBHeader[nCnt,02]) != "F3I_SEQUEN"
				nCpoAux2 := (aSXBHeader[nCnt,04] )
				If Alltrim(aSXBHeader[nCnt,02]) == cCpoFiltro
					Exit
				Else
					nCpoAux1 += nCpoAux2
				Endif
			Endif
	    Next nCnt
	Endif

	If cPaisLoc == "MEX" .And. cTabela $ "S004|S013|S015|S023|S024" .And. !Empty(F812ChkCampo())
		cTrb := F812Tmp(cTabela)	// "S004" Cdigo postal, "S015" Colonia, "S023" Localidad, "S024" Municipio
		lTrb := .T.
		dbSelectArea( cTrb )
		Count To nQtdLin
		dbGotop()

	Else
		nQtdLin := F812ConF3I(cTabela)
		dbSelectArea( "F3I" )
		F3I->(dbSetOrder(1))
		F3I->( dbSeek( xFilial( "F3I" ) + cTabela ) )
		cTrb := "F3I"

	EndIf

	ProcRegua(nQtdLin)

	While ! Eof() .And. F3I_FILIAL+F3I_CODIGO == ( cFilF3I + cTabela )
		If Empty( cFiltro ) .Or. Eval( cFiltro )
			AADD(aSXBCols,Array(Len(aSXBHeader)+1))
			For nCnt := 1 To Len(aSXBHeader)
				cCampo := Alltrim(aSXBHeader[nCnt,02])
				If aSXBHeader[nCnt,10] == "R" .And. cCampo == "F3I_SEQUEN"
					aSXBCols[Len(aSXBCols)][nCnt] := FieldGet(FieldPos(cCampo))
				ElseIf lPesqComp .And. At("+", cCampo) > 0
					aSXBCols[Len(aSXBCols)][nCnt] := cCpoPesq //cCpoAux
				Else
					nCpo2 := (aSXBHeader[nCnt,04] )
					If aSXBHeader[nCnt,08] == "N"
						uValor := Val( SubStr(F3I_CONTEU,nCpo1,nCpo2) )
					ElseIf aSXBHeader[nCnt,08] == "D"
						uValor := Ctod( SubStr(F3I_CONTEU,nCpo1,nCpo2) )
					Else
						uValor := SubStr(F3I_CONTEU,nCpo1,nCpo2)
					EndIf
					aSXBCols[Len(aSXBCols)][nCnt] := uValor
					nCpo1 += nCpo2
		  		EndIf
			Next nCnt
			aSXBCols[Len(aSXBCols)][nUsado+1] := .F.
			nCont += 1
			IncProc(STR0062 + alltrim(str(nCont)) + STR0063 + alltrim(str(nQtdLin))) //"Cargando catlogo de Prod/Serv SAT.." "de"
			If nCont > nQtdLin
				Exit
			EndIf
			nCpo1 := 1
		Endif
		dbSkip()
	EndDo

	If lTrb
		(cTrb)->(dbCloseArea())
	EndIf

	RestArea( aArea )

Return

/*


ͻ
Programa             Autor  Ademar Fernandes    Data   31/10/08   
͹
Descricao  Localiza a informacao digitada pelo usuario na Tela de Pes-
           quisa de tabelas do F3I                                    
͹
Uso        F812SXB                                                    
ͼ


*/
Function Pesq812Dad(cPesq)
Local nPosLin := 0
Local nPosCpo := 0
Local nLenCmb := Len(Alltrim(cPesq))
Local nCmbLin := aScan( aMyCombo, { |x| Alltrim(x[01]) == Alltrim(cCombo)} )

	nPosCpo := GdFieldPos(aMyCombo[nCmbLin,02],aSXBHeader)

	IF nPosCpo > 0
		nPosLin := aScan( aSXBCols, { |x| SubStr(Alltrim(UPPER(x[nPosCpo])),1,nLenCmb) == Alltrim(cPesq)} )
	endif
	If nPosLin >= 1
		oGetDad812:oBrowse:nAt := nPosLin
		n:= nPosLin
	EndIf
	oGetDad812:oBrowse:Refresh()

Return

/*


ͻ
Programa  f812ValPesqAutor   IP-RH Inovacao      Data   21/10/10  
͹
Desc.      Apresenta mensagem de alerta quando nao existir campo pra  
           pesquisa na tabela auxiliar.                               
͹
Uso        Protheus                                                   
ͼ


*/
Function f812ValPesq()

	Alert(STR0055) //-"O campo de pesquisa 'Busca por:' no pode ser vazio !!!"

Return(.F.)

/*


ͻ
Programa   ExistReg Autor   Adrianne Furtado    Data  17/11/2010  
͹
Desc.      Verifica se existem registros validos na consulta para essa
           filial                                                     
͹
Uso        P10                                                        
ͼ


*/
Function ExistR812Tab(cCodTab)
Local lRet     := .F.
Local cFOrigem := ""

	If __READVAR == "M->CODFOR" //CONSULTA F3 A PARTIR DE UMA TABELA SNNN
		cFOrigem := aCols[n][1]
	Else
		cFOrigem := xFilial("F3H")
	EndIf

	F3I->(dbSetOrder(1))
	If F3I->(dbSeek(xFilial("F3I")+cCodTab))
		lRet := .T.
	EndIf
	F3I->(DbGoTop())
	F3I->(dbSeek(xFilial("F3I")+cCodTab))

Return lRet

/*


ͻ
Programa  ValidF3I  Autor  Silvia Taguti        Data   17/12/04   
͹
Desc.      Verifica codigo no Cadastro de Tabelas                     
                                                                      
͹
Uso        AP8                                                        
ͼ


*/
Function ValidF3I(cCodigo,cConteudo,nPos1,nPos2)
	Local aArea		:= GetArea()
	Local cTrb		:= GetNextAlias()
	Local lGetDB	:= AllTrim(Upper(TCGetDB())) == "ORACLE"
	Local cQry		:= ""
	Local lRet		:= .F.

	Default nPos1	:= 1
	Default nPos2	:= Len(cConteudo)

	If cCodigo <> Nil .And. cConteudo <> Nil
		cQry := " SELECT F3I_CODIGO,F3I_SEQUEN,F3I_CONTEU "
		cQry += " FROM " + RetsqlName("F3I") + " F3I "
		cQry += " WHERE F3I_FILIAL = '" + xFilial("F3I") + "' "
		cQry += " AND F3I_CODIGO = '" + cCodigo + "' "
		If  lGetDB //Es Oracle
			cQry += " AND TRIM(TO_CHAR(SUBSTR(F3I_CONTEU," + Alltrim(Str(nPos1)) + "," + Alltrim(Str(nPos2)) + "))) = '" + Alltrim(cConteudo) + "'"
		Else
			cQry += " AND SUBSTRING(F3I_CONTEU," + Alltrim(Str(nPos1)) + "," + Alltrim(Str(nPos2)) + ") = '" + Alltrim(cConteudo) + "'"
		EndIf
		cQry += " AND F3I.D_E_L_E_T_='' "

		cQry := ChangeQuery(cQry)
		dbUseArea(.T., 'TOPCONN', TcGenQry( ,, cQry ), cTrb, .T., .F.)

		dbSelectArea(cTrb)
		(cTrb)->(dbGoTop())

		While (cTrb)->(!Eof())
			If Alltrim(Substr((cTrb)->F3I_CONTEU,nPos1,nPos2)) == Alltrim(cConteudo)
				lRet := .T.
				Exit
			EndIf
			(cTrb)->(dBSkip())
		EndDo

		(cTrb)->(dbCloseArea())

		If !lRet
			If AllTrim(substr(ReadVar(), 4, len(ReadVar()))) $ "F1_RELSAT|F2_RELSAT" .AND. Empty(cConteudo)
				lRet := .T.
			Else
				MsgAlert( OemToAnsi(STR0064) + Alltrim(cCodigo),OemToAnsi(STR0014) ) //"El valor no existe en catlogo: " "Atencin!"
			EndIf
		EndIf
	EndIf

	RestArea( aArea )

Return (lRet)

/*/


Ŀ
Funo     F812ConF3I  Autor  Luis Enriquez          Data  08.08.17 
Ĵ
Descrio  Obtiene cantidad de resgistros existentes de acuerdo a codigo
           de tabla (MEXICO)                                            
Ĵ
Sintaxe    F812ConF3I(cCodigo)                                          
Ĵ
Parametros cCodigo .- Cdigo de tabla                                   
Ĵ
Retorno    nTotReg .- Cant. de regitros existentes para codigo de tabla 
Ĵ
 Uso       FISA812                                                      
ٱ


/*/
Static Function F812ConF3I(cCodigo)
	Local cTRB := ""
	Local cQry := ""
	Local nTotReg := 0

	cQry := " SELECT COUNT(F3I_CODIGO) REGS "
	cQry += " FROM " + RetsqlName("F3I") + " F3I "
	cQry += " WHERE F3I_FILIAL = '" + xFilial("F3I") + "' "
	cQry += " AND F3I_CODIGO = '" + cCodigo + "' "
	cQry += " AND F3I.D_E_L_E_T_='' "
	cQry += " GROUP BY F3I_CODIGO "

	cTRB := ChangeQuery(cQry)
	dbUseArea(.T., 'TOPCONN', TcGenQry( ,, cTRB ) ,"TRBF3IC", .T., .F.)

	DbSelectArea("TRBF3IC")
	TRBF3IC->(dbGoTop())

	While TRBF3IC->(!Eof())
		nTotReg := TRBF3IC->REGS
		TRBF3IC->(dBSkip())
	EndDo

	TRBF3IC->(dbCloseArea())
Return nTotReg

/*/


Ŀ
Funo     ObtColSAT   Autor  Luis Enriquez          Data  27.10.17 
Ĵ
Descrio  Obtiene valor de mantenimiento de tablas del SAT de acuerdo  
           a posicin de busqueda y de valor a buscar. (MEXICO)         
Ĵ
Sintaxe    ObtColSAT(cCodigo,cConteudo,nPos1,nPos2,nPos1Ret,nPos2Ret)   
Ĵ
Parametros cCodigo .- Cdigo de tabla                                   
           cConteudo .- Valor de busqueda                               
           nPos1 .- Posicin inicial de valor a buscar                  
           nPos2 .- Posicin final de valor a buscar                    
           nPos1Ret .- Posicin inicial de valor a retornar             
           nPos2Ret .- Posicin inicial de valor a retornar             
Ĵ
Retorno    cValor .- Valor texto de acuerdo a valor de busqueda         
Ĵ
 Uso       FATSMEX.INI, FATEMEX.INI                                     
ٱ


/*/
Function ObtColSAT(cCodigo,cConteudo,nPos1,nPos2,nPos1Ret,nPos2Ret)
	Local aArea		:= GetArea()
	Local cTrb		:= GetNextAlias()
	Local lGetDB	:= AllTrim(Upper(TCGetDB())) == "ORACLE"  //.T. - Oracle, .F. - Otros manejadores
	Local cQry		:= ""
	Local cValor	:= ""

	Default nPos1	:= 1
	Default nPos2	:= Len(cConteudo)

	If cCodigo <> Nil .And. cConteudo <> Nil
		cQry := " SELECT F3I_CODIGO,F3I_SEQUEN,F3I_CONTEU "
		cQry += " FROM " + RetsqlName("F3I") + " F3I "
		cQry += " WHERE F3I_FILIAL = '" + xFilial("F3I") + "' "
		cQry += " AND F3I_CODIGO = '" + cCodigo + "' "
		If  lGetDB //Es Oracle
			cQry += " AND TRIM(TO_CHAR(SUBSTR(F3I_CONTEU," + Alltrim(Str(nPos1)) + "," + Alltrim(Str(nPos2)) + "))) = '" + Alltrim(cConteudo) + "'"
		Else
			cQry += " AND SUBSTRING(F3I_CONTEU," + Alltrim(Str(nPos1)) + "," + Alltrim(Str(nPos2)) + ") = '" + Alltrim(cConteudo) + "'"
		EndIf
		cQry += " AND F3I.D_E_L_E_T_='' "

		cQry := ChangeQuery(cQry)
		dbUseArea(.T., 'TOPCONN', TcGenQry( ,, cQry ) ,cTrb, .T., .F.)

		dbSelectArea( cTrb )
		(cTrb)->(dbGoTop())

		While (cTrb)->(!Eof())
			If Alltrim(Substr((cTrb)->F3I_CONTEU,nPos1,nPos2)) == Alltrim(cConteudo)
				cValor := Alltrim(Substr((cTrb)->F3I_CONTEU,nPos1Ret,nPos2Ret))
				Exit
			EndIf
			(cTrb)->(dBSkip())
		EndDo

		(cTrb)->(dbCloseArea())
	EndIf

	RestArea( aArea )

Return (cValor)

/*/{Protheus.doc} F812ChkCampo
Informa el campo a usar para filtro de consulta a catlogos del SAT - Mxico
Funciona para las tablas DA4, SA4, A1Y, A1Z y AE0
@type function
@version 1.0
@author arodriguez
@since 20/8/2021
@param nResp, numeric, Indica que campo regresar; 1-Estado (default) o 2-C.P.
@return cRet, variant, Valor del campo
/*/
Static Function F812ChkCampo(nResp)
	Local cCampo	:= cReadVar
	Local cKey1		:= ""
	Local cKey2		:= ""
	Local cRet		:= ""
	Local oModel    := Nil
	Local oModelDet := Nil
	Local lMVC      := .F.
	Local cLlave    := ""

	Default nResp	:= 1

	If cCampo $ "M->DA4_CEP|M->DA4_CODBAI|M->DA4_LOCAL|M->DA4_CODMUN"
		cKey1 := "M->DA4_EST"
		cKey2 := IIf(cCampo == "M->DA4_CODBAI", "M->DA4_CEP", "")
	ElseIf cCampo $ "M->A4_CEP|M->A4_CBAIRRO|M->A4_CLOCALI|M->A4_COD_MUN"
		cKey1 := "M->A4_EST"
		cKey2 := IIf(cCampo == "M->A4_CBAIRRO", "M->A4_CEP", "")
	ElseIf cCampo $ "M->A1Y_CPORI|M->A1Y_COLORI|M->A1Y_LOCORI|M->A1Y_MUNORI"
		cKey1 := "A1Y_EDOORI"
		cKey2 := IIf(cCampo == "M->A1Y_COLORI", "A1Y_CPORI", "")
		oModel := FWModelActivate()
		oModelDet := oModel:GetModel('A1YDETAIL')
		lMVC := .T.
	ElseIf cCampo $ "M->A1Y_CPDES|M->A1Y_COLDES|M->A1Y_LOCDES|M->A1Y_MUNDES"
		cKey1 := "A1Y_EDODES"
		cKey2 := IIf(cCampo == "M->A1Y_COLDES", "A1Y_CPDES", "")
		oModel := FWModelActivate()
		oModelDet := oModel:GetModel('A1YDETAIL')
		lMVC := .T.
	ElseIf cCampo $ "M->A1Z_CP|M->A1Z_COLON|M->A1Z_LOCAL|M->A1Z_MUNIC"
		cKey1 := "M->A1Z_ESTADO"
		cKey2 := IIf(cCampo == "M->A1Z_COLON", "M->A1Z_CP", "")
	ElseIf cCampo $ "M->AE0_CP|M->AE0_COLON|M->AE0_LOCAL|M->AE0_MUNIC"
		cKey1 := "M->AE0_ESTADO"
		cKey2 := IIf(cCampo == "M->AE0_COLON", "M->AE0_CP", "")
	ElseIf cCampo $ "M->F2_USOCFDI|M->F1_USOCFDI"
		cKey1 := "AI0->AI0_REGFIS"
		cLlave := IIf(cCampo == "M->F1_USOCFDI",M->F1_FORNECE + M->F1_LOJA,M->F2_CLIENTE + M->F2_LOJA)
		dbSelectArea("AI0")
		AI0->(dbSetOrder(1)) //AI0_FILIAL+AI0_CODCLI+AI0_LOJA
		AI0->(MsSeek(xFilial("AI0") + cLlave))
	EndIf

	If nResp == 1
		 
		If !Empty(cKey1) .And. Valtype(cKey1) == "C"
			If lMVC
				cRet := oModelDet:GetValue(cKey1)
			Else
				cRet := &(cKey1)
			EndIf
		EndIf
	Else
		If !Empty(cKey2) .And. Valtype(cKey2) == "C"
			If lMVC
				cRet := oModelDet:GetValue(cKey2)
			Else
				cRet := &(cKey2)
			EndIf
		EndIf
	EndIf

Return cRet

/*/{Protheus.doc} F812Tmp
Crea Query con filtro especial por Estado o C.P. para catlogos del SAT - Mxico
@type function
@version 1.0
@author arodriguez
@since 20/8/2021
@param cTabela, character, Cdigo de catlogo a consultar
@return cTrb, variant, Nombre de tabla temporal con query a F3I
/*/
Static Function F812Tmp(cTabela)
	Local cTrb		:= GetNextAlias()
	Local cKey		:= F812ChkCampo(IIf(cTabela=="S015",2,1))
	Local cFiltro	:= ""

	If cTabela == "S015" // Colonia
		If !Empty(cKey)
			// Filtra colonias del C.P. definido
			cFiltro := F812Filtro(cTabela, "CP", cKey)
		Else
			//Filtro de C.P. del Rango 00000 al 99999
			cFiltro := F812Filtro(cTabela, "CP", "00000", "99999")
		EndIf
	ElseIf cTabela == "S013" // Uso CFDI
		cFiltro := F812Filtro(cTabela, "Regimen", cKey,"",.T.)
	Else // "S004" Cdigo postal, "S023" Localidad, "S024" Municipio
		cFiltro := F812Filtro(cTabela, "Estado", cKey)

	EndIf

	BeginSql alias cTrb
		SELECT *
		FROM %table:F3I% F3I
		WHERE F3I.F3I_FILIAL = %xFilial:F3I% AND F3I.F3I_CODIGO = %exp:cTabela% AND %exp:cFiltro% AND F3I.%notDel%
		ORDER BY F3I.F3I_SEQUEN
	EndSql

Return cTrb

/*/{Protheus.doc} F812Filtro
Crea expresin para Query a catlogos de SAT - Mxico
@type function
@version 1.0
@author arodriguez
@since 20/8/2021
@param cTabela, character, Cdigo de catlogo
@param cCampo, character, Campo para el filtro
@param cKey1, character, Valor inicial o nico de filtro
@param cKey2, character, Valor final de filtro
@param cFiltro, variant, expresin para complementar WHERE
/*/
Static Function F812Filtro(cTabela, cCampo, cKey1, cKey2, llike)
	Local nPosTab	:= 0
	Local nPos1		:= 1
	Local nPos2		:= 0
	Local nFor		:= 0
	Local cFiltro	:= ""
	Local cFilF3H	:= xFilial("F3H")
	Local lGetDB	:= AllTrim(Upper(TCGetDB())) == "ORACLE"
	Local cCond     := ""

	Static aTabF3H	:= {}

	Default cKey2	:= ""
	Default llike   := .F.

	nPosTab := aScan( aTabF3H , { |x| x[1] == cTabela } )

	If nPosTab == 0
		aAdd( aTabF3H, { cTabela , {} } )
		nPosTab := Len(aTabF3H)

		F3H->( dbSeek( cFilF3H + cTabela, .T.) )
		While F3H->( !Eof() .And. F3H_FILIAL + F3H_CODIGO == cFilF3H + cTabela )
			F3H->( aAdd( aTabF3H[nPosTab,2], { Upper(Trim(F3H_CAMPOS)), F3H_TIPO, F3H_TAMAN, F3H_DECIMA } ) )
			F3H->( dbSkip() )
		End While
	EndIf

	cCampo := Upper(cCampo)

	For nFor := 1 to Len(aTabF3H[nPosTab,2])
		If aTabF3H[nPosTab,2,nFor,1] == cCampo
			nPos2 := aTabF3H[nPosTab,2,nFor,3]
			Exit
		Else
			nPos1 += aTabF3H[nPosTab,2,nFor,3]
		EndIf
	Next

	If nPos2 > 0
		If Empty(cKey2)
			If llike
				cCond := IIf(lGetDB,"TRIM(TO_CHAR(SUBSTR(F3I_CONTEU," + Alltrim(Str(nPos1)) + "," + Alltrim(Str(nPos2)) + ")))","SUBSTRING(F3I_CONTEU," + Alltrim(Str(nPos1)) + "," + Alltrim(Str(nPos2)) + ")")
				cFiltro := "%" + cCond + " LIKE '%" + Alltrim(Substr(cKey1,1,nPos2)) + "%' %"
			Else
				IF lGetDB
					cFiltro := "%" + "TRIM(TO_CHAR(SUBSTR(F3I_CONTEU," + Alltrim(Str(nPos1)) + "," + Alltrim(Str(nPos2)) + "))) = '" + Alltrim(Substr(cKey1,1,nPos2)) + "' %"
				ELSE
					cFiltro := "%" + "SUBSTRING(F3I_CONTEU," + Alltrim(Str(nPos1)) + "," + Alltrim(Str(nPos2)) + ") = '" + Alltrim(Substr(cKey1,1,nPos2)) + "' %"
				ENDIF
			EndIf
		Else
			IF lGetDB
				cFiltro := "%" + "TRIM(TO_CHAR(SUBSTR(F3I_CONTEU," + Alltrim(Str(nPos1)) + "," + Alltrim(Str(nPos2)) + "))) BETWEEN '" + Alltrim(Substr(cKey1,1,nPos2)) + "' AND '" + Alltrim(cKey2) +"' %"
			ELSE
				cFiltro := "%" + "SUBSTRING(F3I_CONTEU," + Alltrim(Str(nPos1)) + "," + Alltrim(Str(nPos2)) + ") BETWEEN '" + Alltrim(Substr(cKey1,1,nPos2)) + "' AND '" + Alltrim(cKey2) +"' %"
			ENDIF
		EndIf
	Else
		cFiltro := "% 1=1 %"
	EndIf

Return cFiltro
