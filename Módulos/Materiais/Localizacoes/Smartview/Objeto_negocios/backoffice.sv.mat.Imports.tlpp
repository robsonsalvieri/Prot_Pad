#INCLUDE 'tlpp-core.th'
#INCLUDE "totvs.ch"
#INCLUDE "tlpp-rest.th"
#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.mat.Imports.ch'

//-------------------------------------------------------------------------------
/*{Protheus.doc} ImportacionesTReportsBusinessObject
Classe para criação do Objeto de Negocio de compras para SmartView
@author Leonardo Pereira
@since 27/07/2023
@version 1.0
*/  
//-------------------------------------------------------------------------------
namespace custom.compras.Importaciones.integratedprovider

// Annotation
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGACOM', tables='DBA,SB1,SD1,SF1,SB2', name='Importaciones', country='ALL', initialRelease='12.1.2310', customTables='ALL' )
class ImportacionesTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} NEW
Método de instância da classe: Define a lista de importações que serão acessados no objeto de negocios
@return object: self
@author Leonardo Pereira
@since 27/07/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method new() class ImportacionesTReportsBusinessObject

	Local aCpos := {} as array

	_Super:new()

	// Define a Área
	self:appendArea( STR0001 ) // 'Compras'

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0014 ) // 'Importaciones'

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0015 ) // 'Lista detallada de importaciones'

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'MATSV143' ) // Indica o pergunte que será utilizado
		IIf(!self:setErrorStatus( 400, STR0002, STR0003 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0004,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0005 ,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// Adiciona os campos virtuais/calculados
	aAdd( aCpos, { 'F1_DESMOE'  , STR0006 , 'string', STR0007 } ) // 'Descripción de la moneda' # 'Desc. Moneda'
	aAdd( aCpos, { 'F1_TXDIA'   , STR0008 , 'number', STR0009 } ) // 'Tasa Moneda Dia ' #  'Tasa Dia'
	aAdd( aCpos, { 'D1_CUSTO2'  , STR0010 , 'number', STR0011 } ) // 'Conversion Tx Movimento' # 'Conv. Tx. Movimento'
	aAdd( aCpos, { 'D1_CUSTO3'  , STR0012 , 'number', STR0013 } ) // 'Conversion Tx Dia' #  'Conv. Tx. Dia'
	aAdd( aCpos, { 'DBA_DTHAWB_', STR0019 , 'date'  , STR0019 } ) // 'Fecha proceso'
	aAdd( aCpos, { 'DBA_FAT_DE_', STR0020 , 'string', STR0020 } ) // 'No. de importación'
	aAdd( aCpos, { 'DBC_UM_'    , STR0021 , 'string', STR0021 } ) // 'UM'
	aAdd( aCpos, { 'DBC_COSTUNI', STR0022 , 'number', STR0022 } ) // 'Costo Uni (mon1)'
	aAdd( aCpos, { 'B2_VATU1_'  , STR0023 , 'number', STR0023 } ) // 'Costo Total (mon)'
	aAdd( aCpos, { 'DBC_COSTOES', STR0024 , 'number', STR0024 } ) // 'Costo estándar total'
	aAdd( aCpos, { 'DBC_TOTALU' , STR0025 , 'number', STR0025 } ) // 'FOB usd'
	aAdd( aCpos, { 'DBC_TOTALE' , STR0026 , 'number', STR0026 } ) // 'FOB Eur'
	aAdd( aCpos, { 'DBB_TXMOED_', STR0027 , 'number', STR0027 } ) // 'TRM'
	aAdd( aCpos, { 'DBC_TOTAL_' , STR0028 , 'number', STR0028 } ) // 'FOB'

	// Define os campos que serão retornados no objeto de negocios
	self:aFields := {'DBA_HAWB','DBA_OK','DBA_DTRECD','DBA_DT_ETD','DBA_DT_ETA','DBA_PRVDES','DBA_DT_DTA','DBA_DT_EMB','DBA_DT_AVE','DBA_DT_ENC','DBA_VIA_TR','DBA_CHEG','DBA_ORIGEM','DBA_DEST','DBA_PAISPR','DBA_CONEV1','DBA_VIAGEM','DBA_MT3','DBA_PESOTT','D1_COD','B1_DESC','D1_QUANT','B1_MCUSTD','B1_CUSTD','F1_MOEDA','F1_DESMOE','F1_TXMOEDA','F1_TXDIA','D1_CUSTO','D1_CUSTO2','D1_CUSTO3','D1_DESPESA','D1_SEGURO','D1_VALFRE','D1_VALIMP1','D1_ALQIMP1','B2_QATU','DBC_QUANT','DBC_CODPRO','DBA_DTHAWB_','DBA_FAT_DE_','DBC_UM_','DBC_COSTUNI','B2_VATU1_','DBC_COSTOES','DBC_TOTALU','DBC_TOTALE','DBB_TXMOED_','DBC_TOTAL_'}

	self:aStruct := getStrutObj( self:aFields, aCpos , .T. )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os datos do objeto de negócios
@param nPage, numérico, indica a pagina atual
@param oFilter, objeto, contém o filtro do SmartView
@return object: self:oData
@author Leonardo Pereira
@since 27/07/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class ImportacionesTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery 	as character
	Local cAliasA := GetNextAlias() as character
	Local cDescMon 	as character

	Local nPosMon 	as numeric
	Local nPosExp 	as numeric
	Local nX 		as numeric
	Local nQtMoedas as numeric
	Local nMoedaCor as numeric
	Local nDecs	 	as numeric
	Local nTxMoeCor as numeric
	Local nStatus 	as numeric
	Local n1 		as numeric
	Local nSeq     as numeric

	Local jItems 	as json
	Local jParams 	as json

	Local aPDFields as array
	Local aNomeMoed as array
	Local aFiltro 	as array
	Local aParam 	as array

	Local lObfuscated as logical

	Local oQueryA as object

	cDescMon 	:= ''

	nPosMon 	:= 0
	nPosExp 	:= 0
	nMoedaCor 	:= 0
	nTxMoeda 	:= 0
	nTxMoeCor 	:= 0
	nQtMoedas 	:= Moedfin()
	nStatus 	:= 0
	n1 			:= 0

	aNomeMoed	:= { }
	aFiltro 	:= { }
	aParam 		:= { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Lista as moedas e suas descrições
	For nX := 1 To nQtMoedas
		aAdd( aNomeMoed, { AllTrim( Str( nX ) ), SuperGetMv( 'MV_MOEDA' + AllTrim( Str( nX ) ) ) } )
	Next

	// Coleta os dados dos parametros de perguntas
	jParams := oFilter:getParameters( )

	// Agrega os filtros do SmartView na Query
	If oFilter:hasFilter()
		cFiltro := oFilter:getSQLExpression( )

		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )
	EndIf

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	// Define os dados para conversão de moedas
	nMoedaCor := IIf( ValType( jParams['MV_PAR06'][1] ) == "C", Val( jParams['MV_PAR06'][1] ), jParams['MV_PAR06'][1] )
	nDecs := MsDecimais( nMoedaCor )

	// Coleta os campos personalizados pra agregar na query
	cCpoDBA := getCpoUser( aCustomFields, 'DBA', 'DBA', ',' )
	cCpoSB1 := getCpoUser( aCustomFields, 'SB1', 'B1' , ',' )
	cCpoSF1 := getCpoUser( aCustomFields, 'SF1', 'F1' , ',' )
	cCpoSD1 := getCpoUser( aCustomFields, 'SD1', 'D1' , ',' )

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQuery := "SELECT DBA.DBA_DTHAWB DBA_DTHAWB_, DBA.DBA_HAWB, DBA.DBA_OK, DBA.DBA_DTRECD, DBA.DBA_DT_ETD, DBA.DBA_DT_ETA, DBA.DBA_PRVDES, DBA.DBA_DT_DTA, DBA.DBA_DT_EMB, DBA.DBA_DT_AVE, "
	cQuery += " DBA.DBA_DT_ENC, DBA.DBA_VIA_TR, DBA.DBA_CHEG, DBA.DBA_ORIGEM, DBA.DBA_DEST, DBA.DBA_PAISPR, DBA.DBA_CONEV1, DBA.DBA_VIAGEM, DBA.DBA_MT3, DBA.DBA_PESOTT, "
	cQuery += " SB2.B2_VATU1 B2_VATU1_, SB2.B2_QATU, DBC.DBC_TOTAL DBC_TOTAL_, DBB.DBB_TXMOED DBB_TXMOED_, DBC.DBC_QUANT, DBC.DBC_UM, DBC.DBC_CODPRO, DBA.DBA_FAT_DE DBA_FAT_DE_, "
	cQuery += " SB1.B1_DESC, SB1.B1_CUSTD, SB1.B1_MCUSTD, " 
	cQuery += " SF1.F1_MOEDA, '' F1_DESMOE, SF1.F1_TXMOEDA, 0 F1_TXDIA, "
	cQuery += " SD1.D1_CUSTO, SD1.D1_CUSTO2, SD1.D1_CUSTO3, SD1.D1_DESPESA, "
	cQuery += " SD1.D1_COD, SD1.D1_UM DBC_UM_, SD1.D1_QUANT, "
	cQuery += " ?"
	cQuery += " ?"
	cQuery += " ?"
	cQuery += " ?"
	cQuery += " SD1.D1_SEGURO, SD1.D1_VALFRE, SD1.D1_VALIMP1, SD1.D1_ALQIMP1, "
	cQuery += " 0 DBC_COSTUNI, SB1.B1_CUSTD*SB2.B2_QATU DBC_COSTOES, DBC_TOTAL DBC_TOTALU, DBC_TOTAL DBC_TOTALE"
	cQuery += " FROM " + RetSQLName( "DBA" ) + " DBA "
	cQuery += " LEFT JOIN " + RetSQLName( "DBB" ) + " DBB ON DBB.DBB_FILIAL = ? AND DBB.DBB_HAWB = DBA.DBA_HAWB AND DBB.D_E_L_E_T_ = ? "
	cQuery += " LEFT JOIN " + RetSQLName( "DBC" ) + " DBC ON DBC.DBC_FILIAL = ? AND DBC.DBC_HAWB = DBA.DBA_HAWB AND DBC.DBC_ITDOC = DBB.DBB_ITEM AND DBC.D_E_L_E_T_ = ? "
	cQuery += " LEFT JOIN " + RetSQLName( "SB1" ) + " SB1 ON SB1.B1_FILIAL = ? AND SB1.B1_COD = DBC.DBC_CODPRO AND SB1.D_E_L_E_T_ = ? "
	cQuery += " LEFT JOIN " + RetSQLName( "SB2" ) + " SB2 ON SB2.B2_FILIAL = ? AND SB2.B2_COD = DBC.DBC_CODPRO AND SB2.B2_LOCAL = DBC.DBC_LOCAL AND SB1.D_E_L_E_T_ = ? "
	cQuery += " LEFT JOIN " + RetSQLName( "SF1" ) + " SF1 ON SF1.F1_FILIAL = ? AND SF1.F1_DOC = DBB.DBB_DOC AND SF1.F1_SERIE = DBB.DBB_SERIE AND SF1.F1_FORNECE = DBB.DBB_FORNEC AND SF1.F1_LOJA = DBB.DBB_LOJA AND SF1.D_E_L_E_T_ = ? "
	cQuery += " LEFT JOIN " + RetSQLName( "SD1" ) + " SD1 ON SD1.D1_FILIAL = ? AND SD1.D1_DOC = DBB.DBB_DOC AND SD1.D1_SERIE = DBB.DBB_SERIE AND SD1.D1_FORNECE = DBB.DBB_FORNEC AND SD1.D1_LOJA = DBB.DBB_LOJA AND SD1.D1_ITEM = DBC.DBC_ITEM AND SD1.D_E_L_E_T_ = ? "

	cQuery += " WHERE DBA.DBA_FILIAL = ? "
	cQuery += " AND DBA.DBA_HAWB BETWEEN ? AND ? "

	nFecha := IIf( ValType( jParams['MV_PAR07'][1] ) == "C", Val( jParams['MV_PAR07'][1] ), jParams['MV_PAR07'][1] )
	If nFecha == 1 .Or. nFecha == 3
		cQuery += " AND DBA.DBA_DTHAWB BETWEEN ? AND ? "
	Endif
	If nFecha == 2 .Or. nFecha == 3
		cQuery += " AND DBA.DBA_DT_ENC BETWEEN ? AND ? "
	Endif

	nStatus := IIf( ValType( jParams['MV_PAR05'][1] ) == "C", Val( jParams['MV_PAR05'][1] ), jParams['MV_PAR05'][1] )
	If nStatus <> 4
		cQuery += " AND DBA.DBA_OK = ? "
	Endif

	// Agrega os filtros do SMARTVIEW na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += " AND ? ? ? "
	Next

	cQuery += " AND DBA.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY ? "

	cQuery := ChangeQuery( cQuery )

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	oQueryA := FwExecStatement():New()

	//Define a consulta e os parâmetros
	oQueryA:SetQuery( cQuery )
	nSeq := 0

	oQueryA:SetUnsafe( ( nSeq += 1 ), cCpoDBA )
	oQueryA:SetUnsafe( ( nSeq += 1 ), cCpoSB1 )
	oQueryA:SetUnsafe( ( nSeq += 1 ), cCpoSF1 )
	oQueryA:SetUnsafe( ( nSeq += 1 ), cCpoSD1 )
	oQueryA:SetString( ( nSeq += 1 ), FwxFilial( 'DBB' ) )
	oQueryA:SetString( ( nSeq += 1 ), ' ' )
	oQueryA:SetString( ( nSeq += 1 ), FwxFilial( 'DBC' ) )
	oQueryA:SetString( ( nSeq += 1 ), ' ' )
	oQueryA:SetString( ( nSeq += 1 ), FwxFilial( 'SB1' ) )
	oQueryA:SetString( ( nSeq += 1 ), ' ' )
	oQueryA:SetString( ( nSeq += 1 ), FwxFilial( 'SB2' ) )
	oQueryA:SetString( ( nSeq += 1 ), ' ' )
	oQueryA:SetString( ( nSeq += 1 ), FwxFilial( 'SF1' ) )
	oQueryA:SetString( ( nSeq += 1 ), ' ' )
	oQueryA:SetString( ( nSeq += 1 ), FwxFilial( 'SD1' ) )
	oQueryA:SetString( ( nSeq += 1 ), ' ' )
	oQueryA:SetString( ( nSeq += 1 ), FwxFilial( 'DBA' ) )
	oQueryA:SetString( ( nSeq += 1 ), jParams['MV_PAR01'][1] )
	oQueryA:SetString( ( nSeq += 1 ), jParams['MV_PAR02'][1] )
	If nFecha == 1 .Or. nFecha == 3
		oQueryA:SetString( ( nSeq += 1 ), DtoS( FwDateTimeToLocal( jParams['MV_PAR03'][1] )[1] ) )
		oQueryA:SetString( ( nSeq += 1 ), DtoS( FwDateTimeToLocal( jParams['MV_PAR04'][1] )[1] ) )
	Endif
	If nFecha == 2 .Or. nFecha == 3
		oQueryA:SetString( ( nSeq += 1 ), DtoS( FwDateTimeToLocal( jParams['MV_PAR08'][1] )[1] ) )
		oQueryA:SetString( ( nSeq += 1 ), DtoS( FwDateTimeToLocal( jParams['MV_PAR09'][1] )[1] ) )
	Endif

	If ( nStatus <> 4 )
		oQueryA:SetString( ( nSeq += 1 ), AllTrim(Str(nStatus)))
	EndIf

	// Agrega os filtros do SMARTVIEW na QUERY
	For nX := 1 To Len( aFiltro )
		oQueryA:SetUnsafe( ( nSeq += 1 ), aFiltro[nX, 1])
		oQueryA:SetUnsafe( ( nSeq += 1 ), aFiltro[nX, 2])
		oQueryA:SetUnsafe( ( nSeq += 1 ), aFiltro[nX, 3])
	Next

	oQueryA:SetString( ( nSeq += 1 ), ' ' )
	oQueryA:SetUnsafe( ( nSeq += 1 ), 'DBA.DBA_HAWB, SD1.D1_COD' )

	// cria alias
	oQueryA:OpenAlias( cAliasA )

	// Pesquisa a taxa do dia
	If ( nMoedaCor > 0 )
		DbSelectArea( 'SM2' )
		SM2->( DbSetOrder( 1 ) )
		If SM2->( DbSeek( DtoS( dDataBase ) ) ) // M2_DATA
			nTxMoeCor := Round( SM2->&( ( 'M2_MOEDA' + StrZero( nMoedaCor, 1 ) ) ), nDecs )
		EndIf
	EndIf

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( cAliasA )->( EOF( ) )
		jItems := JsonObject():new()

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf ( self:aStruct[nX][3] == 'date' )
				jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
			Else
				If ( self:aStruct[nx][5] == 'F1_DESMOE' )
					// Moneda
					nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAliasA )->F1_MOEDA ) ) } )
					cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )

					jItems[self:aStruct[nX][1]] := cDescMon
				ElseIf ( self:aStruct[nx][5] == 'F1_TXDIA' )
					jItems[self:aStruct[nX][1]] := nTxMoeCor
				ElseIf ( self:aStruct[nx][5] == 'DBC_COSTUNI' )
					jItems[self:aStruct[nX][1]] := ( cAliasA )->B2_VATU1_/( cAliasA )->B2_QATU
				ElseIf ( self:aStruct[nx][5] == 'DBC_TOTALU' )
					jItems[self:aStruct[nX][1]] := Round( xMoeda( ( cAliasA )->DBC_TOTAL_, 1, 2,,,, ( cAliasA )->F1_TXMOEDA, ), nDecs )
				ElseIf ( self:aStruct[nx][5] == 'DBC_TOTALE' )
					jItems[self:aStruct[nX][1]] := Round( xMoeda( ( cAliasA )->DBC_TOTAL_, 1, 4,,,, ( cAliasA )->F1_TXMOEDA, ), nDecs )

				ElseIf ( self:aStruct[nx][5] == 'D1_CUSTO3' )
					If ( nTxMoeCor > 0 )
						jItems[self:aStruct[nX][1]] := Round( xMoeda( ( cAliasA )->D1_CUSTO, 1, nMoedaCor, dDataBase,,,, ), nDecs )
					Else
						jItems[self:aStruct[nX][1]] := Round( 0, nDecs )
					EndIf
				ElseIf ( self:aStruct[nx][5] == 'DBA_OK' )
					If (cAliasA)->DBA_OK == "1"
						jItems[self:aStruct[nX][1]] := STR0016 // "Abierto"
					ElseIf (cAliasA)->DBA_OK == "2"
						jItems[self:aStruct[nX][1]] := STR0017 // "En Proceso"
					ElseIf (cAliasA)->DBA_OK == "3"
						jItems[self:aStruct[nX][1]] := STR0018 // "Cerrado"
					EndIf
				Else
					jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
				EndIf
			EndIf
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		self:oData:appendData( jItems )

		( cAliasA )->( DbSkip( ) )
	End

	( cAliasA )->( DbCloseArea( ) )

	// fecha objeto
	If ( oQueryA <> Nil )
		oQueryA:Destroy( )
		oQueryA := Nil
		FwFreeObj( oQueryA )
	Endif

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura de campos 
@return object: self:oSchema 
@author Laura Medina
@since 20/04/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema() as object class ImportacionesTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTVIEW
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )


