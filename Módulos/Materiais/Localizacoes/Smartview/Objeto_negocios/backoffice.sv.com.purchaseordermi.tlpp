#INCLUDE 'msobject.ch'
#INCLUDE 'tlpp-core.th'
#INCLUDE 'tlpp-rest.th'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.com.purchaseordermi.ch'

//-------------------------------------------------------------------------------
/*{Protheus.doc} purchaseordermiTReportsBusinessObject
Classe para criação do Objeto de Negocio de faturamento para SmartView
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
namespace custom.faturamento.purchaseordermi.integratedprovider

// Annotation
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGACOM', tables='SA2,SB1,SC7,SD1', name='Orden de Compras', country='ALL', initialRelease='12.1.2310', customTables='ALL' )
class purchaseordermiTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} NEW
Método de instância da classe: Define a lista de importações que serão acessados no objeto de negocios
@return object: self
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method new() class purchaseordermiTReportsBusinessObject

	Local aCpos as array

	aCpos := { }

	_Super:new()

	// Define a Área
	self:appendArea( STR0023 ) // 'Compras'

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 ) // 'Orden de Compras'

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 ) // 'Orden de Compras'

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'MATSV171' ) // Indica o pergunte que será utilizado
		IIf(!self:setErrorStatus( 400, STR0002, STR0003 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0004,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0005 ,,, ) //'¡Grupo de preguntas no encontrado!'
	EndIf

	// Adiciona os campos virtuais/calculados
	aAdd( aCpos, { 'C7_TOTPED' , STR0006, 'number', STR0007 } ) // 'Total de Pedido de Venta' ## 'Total Pedido'
	aAdd( aCpos, { 'C7_EMISSAO', STR0008, 'date'  , STR0009 } ) // 'Fecha Emisión Pedido' ## 'Fch. Emisión Pedido'
	aAdd( aCpos, { 'D1_EMISSAO', STR0010, 'date'  , STR0011 } ) // 'Fecha Emisión Factura' ## 'Fch. Emisión Factura'
	aAdd( aCpos, { 'D1_TOTDOC' , STR0012, 'number', STR0013 } ) // 'Total de la Factura' ## 'Total Factura'
	aAdd( aCpos, { 'D1_DTDIGIT', STR0014, 'date'  , STR0015 } ) // 'Fecha Entrega Remito' ## 'Fch. Entrega Remito'
	aAdd( aCpos, { 'D1_SERIE_1', STR0016, 'string', STR0016 } ) // 'Serie'
	aAdd( aCpos, { 'C7_PRECO'  , STR0017, 'number', STR0017 } ) // 'Precio Pedido'
	aAdd( aCpos, { 'D1_VUNIT'  , STR0018, 'number', STR0018 } ) // 'Precio Factura'
	aAdd( aCpos, { 'D1_ITEM_1' , STR0019, 'string', STR0019 } ) // 'Artículo'
	aAdd( aCpos, { 'C7_QUANT'  , STR0020, 'number', STR0020 } ) // 'Cantidad Pedido'
	aAdd( aCpos, { 'D1_QUANT_1', STR0021, 'number', STR0021 } ) // 'Cantidad Factura'
	aAdd( aCpos, { 'D1_QUANT_2', STR0022, 'number', STR0022 } ) // 'Cantidad Remito'
	aAdd( aCpos, { 'D1_QUANT'  , STR0021, 'number', STR0021 } ) // 'Cantidad Factura'
	aAdd( aCpos, { 'D1_DIV01'  , STR0024, 'number', STR0024 } ) // 'Div. Cantidad'
	aAdd( aCpos, { 'D1_DIV02'  , STR0025, 'number', STR0025 } ) // 'Div. Precio'
	aAdd( aCpos, { 'D1_DIV03'  , STR0026, 'number', STR0026 } ) // 'Div. Entrega'

	// Define os campos que serão retornados no objeto de negocios
	self:aFields := { 'C7_FILIAL', 'C7_EMISSAO', 'C7_FORNECE', 'C7_LOJA', 'A2_NOME', 'C7_NUM', 'C7_ITEM', 'C7_PRODUTO', 'B1_DESC', 'B1_GRUPO', 'C7_UM', 'C7_QUANT', 'C7_PRECO', 'C7_TOTAL', 'C7_TOTPED', 'C7_DATPRF', 'D1_REMITO', 'D1_SERIE', 'D1_ITEM', 'D1_QUANT_2', 'D1_QTSEGUM', 'D1_EMISSAO', 'D1_DOC', 'D1_SERIE_1', 'D1_ITEM_1', 'D1_QUANT_1', 'D1_VUNIT', 'D1_TOTAL', 'D1_TOTDOC', 'D1_DTDIGIT', 'D1_TES', 'D1_CONTA', 'D1_CC', 'D1_CUSTO', 'D1_DIV01', 'D1_DIV02', 'D1_DIV03', 'D1_QUANT' }

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura de campos 
@return object: self:oSchema 
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema( ) as object class purchaseordermiTReportsBusinessObject

	Local n1 as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTVIEW
	For n1 := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[n1][1], self:aStruct[n1][2], self:aStruct[n1][3], self:aStruct[n1][4], self:aStruct[n1][5] )
	Next

Return( self:oSchema )


//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os datos do objeto de negócios
@param oFilter, objeto, contém o filtro do SmartView
@return object: self:oData
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class purchaseordermiTReportsBusinessObject

	// Declaracao de variaveis
	Local jParams as json
	Local jItems as json

	Local cQuery 	as character
	Local cAliasA := GetNextAlias() as character
	Local cAliasB := GetNextAlias() as character
	Local cAliasC := GetNextAlias() as character
	Local cFiltro 	as character
	Local cExp 		as character
	Local cFilSA2 	as character
	Local cFilSB1 	as character
	Local cFilSBM 	as character
	Local cFilSC7 	as character
	Local cFilSD1 	as character
	Local cCpoSA2 	as character
	Local cCpoSB1 	as character
	Local cCpoSC7 	as character
	Local cCpoSD1 	as character
	Local cCpoFil01	as character
	Local cCpoFil02	as character

	Local nCount as numeric
	Local nX as numeric
	Local n1 as numeric
	Local nDecs as numeric
	Local nPosExp as numeric
	Local nTOTPed as numeric
	Local nTOTDoc as numeric
	Local nSQL as numeric

	Local aPDFields as array
	Local aFiltro as array
	Local aCustomFields as array

	Local lObfuscated as logical

	Local oQueryA as object
	Local oQueryB as object
	Local oQueryC as object

	cFiltro := ''
	cExp := ''
	cFilSA2 := FWxFilial( 'SA2' )
	cFilSB1 := FWxFilial( 'SB1' )
	cFilSBM := FWxFilial( 'SBM' )
	cFilSC7 := FWxFilial( 'SC7' )
	cFilSD1 := FWxFilial( 'SD1' )
	cCpoSA2 := ''
	cCpoSB1 := ''
	cCpoSC7 := ''
	cCpoSD1 := ''
	cCpoFil01 := ''
	cCpoFil02 := ''

	nX := 0
	n1 := 0
	nCount := 0
	nPosExp := 0
	nDecs := MsDecimais( 1 )
	nTOTPed := 0
	nTOTDoc := 0
	nSQL := 0

	aPDFields := { }
	aFiltro := { }
	aCustomFields := { }

	lObfuscated := .F.

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	nMVPAR01 := IIf( ValType( jParams['MV_PAR01'][1] ) == 'C', Val( jParams['MV_PAR01'][1] ), jParams['MV_PAR01'][1] )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { StrTran( aCustomFields[n1, 1], '_', '' ), aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	cCpoFil01 := '|' + getCpoUser( aCustomFields, '', 'A2', '|' ) + getCpoUser( aCustomFields, '', 'B1', '|' ) + getCpoUser( aCustomFields, '', 'C7', '|' )
	cCpoFil02 := '|' + getCpoUser( aCustomFields, '', 'D1', '|' )

	If oFilter:hasFilter()
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )

		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )
	EndIf

	// Coleta os campos personalizados pra agregar na query
	cCpoSA2 := getCpoUser( aCustomFields, 'SA2', 'A2', ',' )
	cCpoSB1 := getCpoUser( aCustomFields, 'SB1', 'B1', ',' )
	cCpoSC7 := getCpoUser( aCustomFields, 'SC7', 'C7', ',' )
	cCpoSD1 := getCpoUser( aCustomFields, 'SD1', 'D1', ',' )

	// Coleta os campos personalizados pra agregar no filtro de preenchimento dos campos
	If ( nMVPAR01 == 1 )
		// Realiza a montagem da QUERY que será enviada para o banco de dados
		cQuery := "SELECT SC7.C7_FILIAL, SC7.C7_EMISSAO, SC7.C7_NUM, SC7.C7_FORNECE, SC7.C7_LOJA, SC7.C7_ITEM, SC7.C7_PRODUTO, SC7.C7_UM, SC7.C7_QUANT, SC7.C7_PRECO, SC7.C7_TOTAL, SC7.C7_DATPRF, " + cCpoSC7
		cQuery += " SA2.A2_NOME, " + cCpoSA2
		cQuery += " SB1.B1_DESC, " + cCpoSB1 + " SB1.B1_GRUPO||' '||SBM.BM_DESC B1_GRUPO "
		cQuery += "FROM " + RetSQLName( 'SC7' ) + " SC7 "
		cQuery += "INNER JOIN " + RetSQLName( 'SA2' ) + " SA2 "
		cQuery += "   ON SA2.A2_FILIAL = ? "
		cQuery += "      AND SA2.A2_COD = SC7.C7_FORNECE "
		cQuery += "      AND SA2.A2_LOJA = SC7.C7_LOJA "
		cQuery += "      AND SA2.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN " + RetSQLName( 'SB1' ) + " SB1 "
		cQuery += "   ON SB1.B1_FILIAL = ? "
		cQuery += "      AND SB1.B1_COD = SC7.C7_PRODUTO "
		cQuery += "      AND SB1.D_E_L_E_T_ = ? "
		cQuery += "LEFT JOIN " + RetSQLName( 'SBM' ) + " SBM "
		cQuery += "   ON SBM.BM_FILIAL = ? "
		cQuery += "      AND SBM.BM_GRUPO = SB1.B1_GRUPO "
		cQuery += "      AND SBM.D_E_L_E_T_ = ? "
		cQuery += "WHERE SC7.C7_FILIAL = ? "
		cQuery += "   AND SC7.C7_NUM BETWEEN ? AND ? "
		cQuery += "   AND SC7.C7_EMISSAO BETWEEN ? AND ? "
		cQuery += "   AND SC7.C7_FORNECE BETWEEN ? AND ? "
		cQuery += "   AND SC7.C7_PRODUTO BETWEEN ? AND ? "

		// Agrega os filtros do SMARTVIEW na QUERY
		For nX := 1 To Len( aFiltro )
			cQuery += "AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
		Next

		cQuery += "AND SC7.D_E_L_E_T_ = ? "

		cQuery := ChangeQuery( cQuery )

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		oQueryA := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQueryA:SetQuery( cQuery )
		
		oQueryA:SetString( 1, cFilSA2 )
		oQueryA:SetString( 2, ' ' )
		oQueryA:SetString( 3, cFilSB1 )
		oQueryA:SetString( 4, ' ' )
		oQueryA:SetString( 5, cFilSBM )
		oQueryA:SetString( 6, ' ' )
		oQueryA:SetString( 7, cFilSC7 )
		oQueryA:SetString( 8, jParams['MV_PAR02'][1] )
		oQueryA:SetString( 9, jParams['MV_PAR03'][1] )
		oQueryA:SetString( 10, DtoS( FwDateTimeToLocal( jParams['MV_PAR08'][1] )[1] ) )
		oQueryA:SetString( 11, DtoS( FwDateTimeToLocal( jParams['MV_PAR09'][1] )[1] ) )
		oQueryA:SetString( 12, jParams['MV_PAR04'][1] )
		oQueryA:SetString( 13, jParams['MV_PAR05'][1] )
		oQueryA:SetString( 14, jParams['MV_PAR06'][1] )
		oQueryA:SetString( 15, jParams['MV_PAR07'][1] )
		oQueryA:SetString( 16, ' ' )

		// cria alias
		oQueryA:OpenAlias( cAliasA )
		
		// Alimenta o objeto de dados da classe para retornar ao SmartView
		DbSelectArea( cAliasA )
		While !( cAliasA )->( EOF( ) )
			jItems := JsonObject():new()
			nTOTPed := calcTotDoc( 1, cAliasA,, cFilSB1 )
			nSQL := 0

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SD11.D1_FILIAL, SD11.D1_DOC D1_REMITO, SD11.D1_SERIE, SD11.D1_ITEM, SD11.D1_QUANT D1_QUANT_2, D1_QUANT, SD11.D1_QTSEGUM, " + cCpoSD1 + " SD11.D1_DTDIGIT "
			cQuery += "FROM " + RetSQLName( 'SD1' ) + " SD11 "
			cQuery += "WHERE SD11.D1_FILIAL = ? "
			cQuery += "   AND SD11.D1_PEDIDO = ? "
			cQuery += "   AND SD11.D1_ITEMPC = ? "
			cQuery += "   AND SD11.D1_FORNECE = ? "
			cQuery += "   AND SD11.D1_LOJA = ? "
			cQuery += "   AND SD11.D1_TIPODOC >= ? "
			cQuery += "   AND SD11.D_E_L_E_T_ = ? "
			
			cQuery := ChangeQuery( cQuery )

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			oQueryB := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryB:SetQuery( cQuery )

			oQueryB:SetString( 1, cFilSD1 )
			oQueryB:SetString( 2, ( cAliasA )->C7_NUM )
			oQueryB:SetString( 3, ( cAliasA )->C7_ITEM )
			oQueryB:SetString( 4, ( cAliasA )->C7_FORNECE )
			oQueryB:SetString( 5, ( cAliasA )->C7_LOJA )
			oQueryB:SetString( 6, '50' )
			oQueryB:SetString( 7, ' ' )

			// cria alias
			oQueryB:OpenAlias( cAliasB )

			nSQL := 0

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SD12.D1_FILIAL, SD12.D1_EMISSAO, SD12.D1_DOC, SD12.D1_SERIE D1_SERIE_1, SD12.D1_ITEM D1_ITEM_1, SD12.D1_QUANT D1_QUANT_1, SD12.D1_VUNIT, SD12.D1_TOTAL, SD12.D1_DTDIGIT, SD12.D1_TES, SD12.D1_CONTA, SD12.D1_CC, " + cCpoSD1 + " SD12.D1_CUSTO, D1_QUANT "
			cQuery += "FROM " + RetSQLName( 'SD1' ) + " SD12 "
			cQuery += "WHERE SD12.D1_FILIAL = ? "
			cQuery += "   AND SD12.D1_PEDIDO = ? "
			cQuery += "   AND SD12.D1_ITEMPC = ? "
			cQuery += "   AND SD12.D1_FORNECE = ? "
			cQuery += "   AND SD12.D1_LOJA = ? "
			cQuery += "   AND SD12.D1_TIPODOC < ? "
			cQuery += "   AND SD12.D_E_L_E_T_ = ? "
			
			cQuery := ChangeQuery( cQuery )

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			oQueryC := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryC:SetQuery( cQuery )
			
			oQueryC:SetString( 1, cFilSD1 )
			oQueryC:SetString( 2, ( cAliasA )->C7_NUM )
			oQueryC:SetString( 3, ( cAliasA )->C7_ITEM )
			oQueryC:SetString( 4, ( cAliasA )->C7_FORNECE )
			oQueryC:SetString( 5, ( cAliasA )->C7_LOJA )
			oQueryC:SetString( 6, '50' )
			oQueryC:SetString( 7, ' ' )
			
			// cria alias
			oQueryC:OpenAlias( cAliasC )

			DbSelectArea( cAliasC )
			If !( cAliasC )->( EOF( ) )
				nTOTDoc := calcTotDoc( 2, cAliasA, cAliasC, cFilSB1 )
			EndIf

			// Alimenta o objeto de dados da classe para retornar ao SmartView
			For nX := 1 To Len( self:aStruct )
				If ( AllTrim( self:aStruct[nx][5] ) $ 'C7_EMISSAO|C7_NUM|C7_FORNECE|C7_LOJA|A2_NOME|C7_ITEM|C7_PRODUTO|B1_DESC|C7_UM|B1_GRUPO|C7_QUANT|C7_PRECO|C7_TOTAL|C7_TOTPED|C7_DATPRF' + cCpoFil01 )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'C7_TOTPED' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPed, nDecs )
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D1_REMITO|D1_SERIE|D1_ITEM|D1_QUANT_2|D1_QTSEGUM|D1_DTDIGIT' + cCpoFil02 )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D1_EMISSAO|D1_DOC|D1_SERIE_1|D1_ITEM_1|D1_QUANT_1|D1_VUNIT|D1_TOTAL|D1_TOTDOC|D1_TES|D1_CONTA|D1_CC|D1_CUSTO|D1_DIV01|D1_DIV02|D1_DIV03' + cCpoFil02 )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasC )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasC )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'D1_TOTDOC' )
						jItems[self:aStruct[nX][1]] := Round( nTOTDoc, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'D1_DIV01' )
						jItems[self:aStruct[nX][1]] := 0
						If !Empty( ( cAliasC )->D1_DOC ) .And. !Empty( ( cAliasA )->C7_NUM )
							If ( ( cAliasA )->C7_QUANT != ( cAliasC )->D1_QUANT_1 )
								jItems[self:aStruct[nX][1]] := ( ( ( cAliasA )->C7_QUANT - ( cAliasC )->D1_QUANT_1 ) * -1 )
							EndIf
						EndIf
					ElseIf ( self:aStruct[nx][5] == 'D1_DIV02' )
						jItems[self:aStruct[nX][1]] := 0
						If !Empty( ( cAliasC )->D1_DOC ) .And. !Empty( ( cAliasA )->C7_NUM )
							If ( ( cAliasA )->C7_PRECO != ( cAliasC )->D1_VUNIT )
								jItems[self:aStruct[nX][1]] := ( ( ( cAliasA )->C7_PRECO - ( cAliasC )->D1_VUNIT ) * -1 )
							EndIf
						EndIf
					ElseIf ( self:aStruct[nx][5] == 'D1_DIV03' )
						jItems[self:aStruct[nX][1]] := 0
						If !Empty( ( cAliasC )->D1_DOC ) .And. !Empty( ( cAliasA )->C7_NUM )
							If ( ( cAliasA )->C7_DATPRF != ( cAliasC )->D1_DTDIGIT )
								jItems[self:aStruct[nX][1]] := ( ( StoD( ( cAliasA )->C7_DATPRF ) - IIf( Empty( ( cAliasC )->D1_DTDIGIT ), dDataBase, StoD( ( cAliasC )->D1_DTDIGIT ) ) ) * -1 )
							EndIf
						EndIf
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasC )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) == 'C7_FILIAL' )
					jItems[self:aStruct[nX][1]] := IIf(!Empty((cAliasA)->C7_FILIAL ),( cAliasA )->C7_FILIAL,IIF(!Empty( ( cAliasB )->D1_FILIAL ),( cAliasB )->D1_FILIAL,( cAliasC )->D1_FILIAL))
				EndIf
			Next

			// Inclui os dados no objeto paea retorno ao SmartView
			self:oData:appendData( jItems )

			( cAliasB )->( DbCloseArea( ) )
			( cAliasC )->( DbCloseArea( ) )

			( cAliasA )->( DbSkip( ) )
			nCount++

			nTOTPed := 0
			nTOTDoc := 0
		End
		( cAliasA )->( DbCloseArea( ) )
	ElseIf ( nMVPAR01 == 2 )
		// Realiza a montagem da QUERY que será enviada para o banco de dados
		cQuery := "SELECT SD11.D1_FILIAL, SD11.D1_DOC D1_REMITO, SD11.D1_SERIE, SD11.D1_ITEM, SD11.D1_COD C7_PRODUTO, SD11.D1_QUANT D1_QUANT_2, SD11.D1_UM C7_UM, SD11.D1_QTSEGUM, SD11.D1_DTDIGIT, SD11.D1_PEDIDO, SD11.D1_ITEMPC, SD11.D1_TES, SD11.D1_CONTA, SD11.D1_CC, " + cCpoSD1 + " SD11.D1_CUSTO, SD11.D1_FORNECE C7_FORNECE, SD11.D1_LOJA C7_LOJA, D1_QUANT,"
		cQuery += " SA2.A2_NOME, " + cCpoSA2
		cQuery += " SB1.B1_DESC, " + cCpoSB1 + " SB1.B1_GRUPO||' '||SBM.BM_DESC B1_GRUPO "
		cQuery += "FROM " + RetSQLName( 'SD1' ) + " SD11 "
		cQuery += "INNER JOIN " + RetSQLName( 'SA2' ) + " SA2 "
		cQuery += "   ON SA2.A2_FILIAL = ? "
		cQuery += "      AND SA2.A2_COD = SD11.D1_FORNECE "
		cQuery += "      AND SA2.A2_LOJA = SD11.D1_LOJA "
		cQuery += "      AND SA2.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN " + RetSQLName( 'SB1' ) + " SB1 "
		cQuery += "   ON SB1.B1_FILIAL = ? "
		cQuery += "      AND SB1.B1_COD = SD11.D1_COD "
		cQuery += "      AND SB1.D_E_L_E_T_ = ? "
		cQuery += "LEFT JOIN " + RetSQLName( 'SBM' ) + " SBM "
		cQuery += "   ON SBM.BM_FILIAL = ? "
		cQuery += "      AND SBM.BM_GRUPO = SB1.B1_GRUPO "
		cQuery += "      AND SBM.D_E_L_E_T_ = ? "
		cQuery += "WHERE SD11.D1_FILIAL = ? "
		cQuery += "   AND SD11.D1_DOC BETWEEN ? AND ? "
		cQuery += "   AND SD11.D1_EMISSAO BETWEEN ? AND ? "
		cQuery += "   AND SD11.D1_FORNECE BETWEEN ? AND ? "
		cQuery += "   AND SD11.D1_COD BETWEEN ? AND ? "
		cQuery += "   AND SD11.D1_TIPODOC >= ? "
		cQuery += "   AND SD11.D_E_L_E_T_ = ? "
		
		// Agrega os filtros do SMARTVIEW na QUERY
		For nX := 1 To Len( aFiltro )
			cQuery += "   AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
		Next
		
		cQuery := ChangeQuery( cQuery )

		nSQL := 0

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		oQueryB := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQueryB:SetQuery( cQuery )

		oQueryB:SetString( 1, cFilSA2 )
		oQueryB:SetString( 2, ' ' )
		oQueryB:SetString( 3, cFilSB1 )
		oQueryB:SetString( 4, ' ' )
		oQueryB:SetString( 5, cFilSBM )
		oQueryB:SetString( 6, ' ' )
		oQueryB:SetString( 7, cFilSD1 )
		oQueryB:SetString( 8, jParams['MV_PAR02'][1] )
		oQueryB:SetString( 9, jParams['MV_PAR03'][1] )
		oQueryB:SetString( 10, DtoS( FwDateTimeToLocal( jParams['MV_PAR08'][1] )[1] ) )
		oQueryB:SetString( 11, DtoS( FwDateTimeToLocal( jParams['MV_PAR09'][1] )[1] ) )
		oQueryB:SetString( 12, jParams['MV_PAR04'][1] )
		oQueryB:SetString( 13, jParams['MV_PAR05'][1] )
		oQueryB:SetString( 14, jParams['MV_PAR06'][1] )
		oQueryB:SetString( 15, jParams['MV_PAR07'][1] )
		oQueryB:SetString( 16, '50' )
		oQueryB:SetString( 17, ' ' )

		// cria alias
		oQueryB:OpenAlias( cAliasB )

		// Alimenta o objeto de dados da classe para retornar ao SmartView
		DbSelectArea( cAliasB )
		While !( cAliasB )->( EOF( ) )
			jItems := JsonObject():new()

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SD12.D1_FILIAL, SD12.D1_EMISSAO, SD12.D1_DOC, SD12.D1_SERIE D1_SERIE_1, SD12.D1_ITEM D1_ITEM_1, SD12.D1_QUANT D1_QUANT_1, SD12.D1_VUNIT, SD12.D1_TOTAL, SD12.D1_DTDIGIT, SD12.D1_TES, SD12.D1_CONTA, SD12.D1_CC, " + cCpoSD1 + " SD12.D1_CUSTO,  D1_QUANT "
			cQuery += "FROM " + RetSQLName( 'SD1' ) +  " SD12 "
			cQuery += "WHERE SD12.D1_FILIAL = ? "
			cQuery += "   AND SD12.D1_REMITO = ? "
			cQuery += "   AND SD12.D1_SERIREM = ? "
			cQuery += "   AND SD12.D1_ITEMREM = ? "
			cQuery += "   AND SD12.D1_FORNECE = ? "
			cQuery += "   AND SD12.D1_LOJA = ? "
			cQuery += "   AND SD12.D1_TIPODOC < ? "
			cQuery += "   AND SD12.D_E_L_E_T_ = ? "
			
			cQuery := ChangeQuery( cQuery )

			nSQL := 0

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			oQueryC := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryC:SetQuery( cQuery )

			oQueryC:SetString( 1, cFilSD1 )
			oQueryC:SetString( 2, ( cAliasB )->D1_REMITO )
			oQueryC:SetString( 3, ( cAliasB )->D1_SERIE )
			oQueryC:SetString( 4, ( cAliasB )->D1_ITEM )
			oQueryC:SetString( 5, ( cAliasB )->C7_FORNECE )
			oQueryC:SetString( 6, ( cAliasB )->C7_LOJA )
			oQueryC:SetString( 7, '50' )
			oQueryC:SetString( 8, ' ' )

			// cria alias
			oQueryC:OpenAlias( cAliasC )

			DbSelectArea( cAliasC )
			If !( cAliasC )->( EOF( ) )
				nTOTDoc := calcTotDoc( 2,, cAliasC, cFilSB1 )
			EndIf

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SC7.C7_FILIAL, SC7.C7_EMISSAO, SC7.C7_NUM, SC7.C7_FORNECE, SC7.C7_LOJA, SC7.C7_ITEM, SC7.C7_PRODUTO, SC7.C7_UM, SC7.C7_QUANT, SC7.C7_PRECO, SC7.C7_TOTAL, SC7.C7_DATPRF, " + cCpoSC7
			cQuery += " SA2.A2_NOME, " + cCpoSA2
			cQuery += " SB1.B1_DESC, " + cCpoSB1 + " SB1.B1_GRUPO "
			cQuery += "FROM " + RetSQLName( 'SC7' ) + " SC7 "
			cQuery += "INNER JOIN " + RetSQLName( 'SA2' ) + " SA2 "
			cQuery += "   ON SA2.A2_FILIAL = ? "
			cQuery += "      AND SA2.A2_COD = SC7.C7_FORNECE "
			cQuery += "      AND SA2.A2_LOJA = SC7.C7_LOJA "
			cQuery += "      AND SA2.D_E_L_E_T_ = ? "
			cQuery += "INNER JOIN " + RetSQLName( 'SB1' ) + " SB1 "
			cQuery += "   ON SB1.B1_FILIAL = ? "
			cQuery += "      AND SB1.B1_COD = SC7.C7_PRODUTO "
			cQuery += "      AND SB1.D_E_L_E_T_ = ? "
			cQuery += "WHERE SC7.C7_FILIAL = ? "
			cQuery += "   AND SC7.C7_NUM = ? "
			cQuery += "   AND SC7.C7_FORNECE = ? "
			cQuery += "   AND SC7.C7_LOJA = ? "
			cQuery += "   AND SC7.C7_ITEM = ? "
			cQuery += "   AND SC7.D_E_L_E_T_ = ? "
		
			// Agrega os filtros do SMARTVIEW na QUERY
			For nX := 1 To Len( aFiltro )
				cQuery += "   AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
			Next

			cQuery := ChangeQuery( cQuery )

			nSQL := 0

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			oQueryA := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryA:SetQuery( cQuery )
			
			oQueryA:SetString( 1, cFilSA2 )
			oQueryA:SetString( 2, ' ' )
			oQueryA:SetString( 3, cFilSB1 )
			oQueryA:SetString( 4, ' ' )
			oQueryA:SetString( 5, cFilSC7 )
			oQueryA:SetString( 6, ( cAliasB )->D1_PEDIDO )
			oQueryA:SetString( 7, ( cAliasB )->C7_FORNECE )
			oQueryA:SetString( 8, ( cAliasB )->C7_LOJA )
			oQueryA:SetString( 9, ( cAliasB )->D1_ITEMPC )
			oQueryA:SetString( 10, ' ' )

			// cria alias
			oQueryA:OpenAlias( cAliasA )

			If !( cAliasA )->( EOF( ) )
				nTOTPed := calcTotDoc( 1, cAliasA,, cFilSB1 )
			EndIf

			// Alimenta o objeto de dados da classe para retornar ao SmartView
			For nX := 1 To Len( self:aStruct )
				If ( AllTrim( self:aStruct[nx][5] ) $ 'C7_EMISSAO|C7_NUM|C7_ITEM|C7_QUANT|C7_PRECO|C7_TOTAL|C7_TOTPED|C7_DATPRF' + cCpoFil01 )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'C7_TOTPED' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPed, nDecs )
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D1_REMITO|D1_SERIE|D1_ITEM|D1_QUANT_2|D1_QTSEGUM|D1_DTDIGIT|A2_NOME|B1_DESC|B1_GRUPO|C7_FORNECE|C7_LOJA|C7_PRODUTO|C7_UM|D1_TES|D1_CONTA|D1_CC|D1_CUSTO|D1_DIV01|D1_DIV02|D1_DIV03' + cCpoFil02 )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'D1_DIV01' )
						jItems[self:aStruct[nX][1]] := 0
						If !Empty( ( cAliasC )->D1_DOC ) .And. !Empty( ( cAliasA )->C7_NUM )
							If ( ( cAliasA )->C7_QUANT != ( cAliasC )->D1_QUANT_1 )
								jItems[self:aStruct[nX][1]] := ( ( ( cAliasA )->C7_QUANT - ( cAliasC )->D1_QUANT_1 ) * -1 )
							EndIf
						EndIf
					ElseIf ( self:aStruct[nx][5] == 'D1_DIV02' )
						jItems[self:aStruct[nX][1]] := 0
						If !Empty( ( cAliasC )->D1_DOC ) .And. !Empty( ( cAliasA )->C7_NUM )
							If ( ( cAliasA )->C7_PRECO != ( cAliasC )->D1_VUNIT )
								jItems[self:aStruct[nX][1]] := ( ( ( cAliasA )->C7_PRECO - ( cAliasC )->D1_VUNIT ) * -1 )
							EndIf
						EndIf
					ElseIf ( self:aStruct[nx][5] == 'D1_DIV03' )
						jItems[self:aStruct[nX][1]] := 0
						If !Empty( ( cAliasC )->D1_DOC ) .And. !Empty( ( cAliasA )->C7_NUM )
							If ( ( cAliasA )->C7_DATPRF != ( cAliasC )->D1_DTDIGIT )
								jItems[self:aStruct[nX][1]] := ( ( StoD( ( cAliasA )->C7_DATPRF ) - IIf( Empty( ( cAliasC )->D1_DTDIGIT ), dDataBase, StoD( ( cAliasC )->D1_DTDIGIT ) ) ) * -1 )
							EndIf
						EndIf
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D1_EMISSAO|D1_DOC|D1_SERIE_1|D1_ITEM_1|D1_QUANT_1|D1_VUNIT|D1_TOTAL|D1_TOTDOC' + cCpoFil02 )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasC )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasC )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'D1_TOTDOC' )
						jItems[self:aStruct[nX][1]] := Round( nTOTDoc, nDecs )
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasC )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) == 'C7_FILIAL' )
					jItems[self:aStruct[nX][1]] := IIf(!Empty((cAliasA)->C7_FILIAL ),( cAliasA )->C7_FILIAL,IIF(!Empty( ( cAliasB )->D1_FILIAL ),( cAliasB )->D1_FILIAL,( cAliasC )->D1_FILIAL))
				EndIf
			Next

			// Inclui os dados no objeto paea retorno ao SmartView
			self:oData:appendData( jItems )

			( cAliasA )->( DbCloseArea( ) )
			( cAliasC )->( DbCloseArea( ) )

			( cAliasB )->( DbSkip( ) )
			nCount++

			nTOTPed := 0
			nTOTDoc := 0
		End
		( cAliasB )->( DbCloseArea( ) )
	ElseIf ( nMVPAR01 == 3 )
		// Realiza a montagem da QUERY que será enviada para o banco de dados
		cQuery := "SELECT SD12.D1_FILIAL, SD12.D1_EMISSAO, SD12.D1_DOC, SD12.D1_SERIE D1_SERIE_1, SD12.D1_ITEM D1_ITEM_1, SD12.D1_COD C7_PRODUTO, SD12.D1_QUANT D1_QUANT_1, SD12.D1_UM C7_UM, SD12.D1_VUNIT, SD12.D1_TOTAL, SD12.D1_DTDIGIT, SD12.D1_TES, SD12.D1_CONTA, SD12.D1_CC, SD12.D1_CUSTO, SD12.D1_REMITO, SD12.D1_SERIREM, SD12.D1_ITEMREM, SD12.D1_PEDIDO, SD12.D1_ITEMPC, " + cCpoSD1 + " SD12.D1_FORNECE C7_FORNECE, SD12.D1_LOJA C7_LOJA, D1_QUANT,"
		cQuery += " SA2.A2_NOME, " + cCpoSA2
		cQuery += " SB1.B1_DESC, " + cCpoSB1 + "  SB1.B1_GRUPO||' '||SBM.BM_DESC B1_GRUPO "
		cQuery += "FROM " + RetSQLName( 'SD1' ) + " SD12 "
		cQuery += "INNER JOIN " + RetSQLName( 'SA2' ) + " SA2 "
		cQuery += "   ON SA2.A2_FILIAL = ? "
		cQuery += "      AND SA2.A2_COD = SD12.D1_FORNECE "
		cQuery += "      AND SA2.A2_LOJA = SD12.D1_LOJA 
		cQuery += "      AND SA2.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN " + RetSQLName( 'SB1' ) + " SB1 "
		cQuery += "   ON SB1.B1_FILIAL = ? "
		cQuery += "      AND SB1.B1_COD = SD12.D1_COD "
		cQuery += "      AND SB1.D_E_L_E_T_ = ? "
		cQuery += "LEFT JOIN " + RetSQLName( 'SBM' ) + " SBM "
		cQuery += "   ON SBM.BM_FILIAL = ? "
		cQuery += "      AND SBM.BM_GRUPO = SB1.B1_GRUPO "
		cQuery += "      AND SBM.D_E_L_E_T_ = ? "
		cQuery += "WHERE SD12.D1_FILIAL = ? "
		cQuery += "   AND SD12.D1_DOC BETWEEN ? AND ? "
		cQuery += "   AND SD12.D1_EMISSAO BETWEEN ? AND ? "
		cQuery += "   AND SD12.D1_FORNECE BETWEEN ? AND ? "
		cQuery += "   AND SD12.D1_COD BETWEEN ? AND ? "
		cQuery += "   AND SD12.D1_TIPODOC < ? "
		cQuery += "   AND SD12.D_E_L_E_T_ = ? "
		
		// Agrega os filtros do SMARTVIEW na QUERY
		For nX := 1 To Len( aFiltro )
			cQuery += "   AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
		Next
		
		cQuery := ChangeQuery( cQuery )

		nSQL := 0

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		oQueryC := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQueryC:SetQuery( cQuery )

		oQueryC:SetString( 1, cFilSA2 )
		oQueryC:SetString( 2, ' ' )
		oQueryC:SetString( 3, cFilSB1 )
		oQueryC:SetString( 4, ' ')
		oQueryC:SetString( 5, cFilSBM )
		oQueryC:SetString( 6, ' ')
		oQueryC:SetString( 7, cFilSD1 )
		oQueryC:SetString( 8, jParams['MV_PAR02'][1] )
		oQueryC:SetString( 9, jParams['MV_PAR03'][1] )
		oQueryC:SetString( 10, DtoS( FwDateTimeToLocal( jParams['MV_PAR08'][1] )[1] ) )
		oQueryC:SetString( 11, DtoS( FwDateTimeToLocal( jParams['MV_PAR09'][1] )[1] ) )
		oQueryC:SetString( 12, jParams['MV_PAR04'][1] )
		oQueryC:SetString( 13, jParams['MV_PAR05'][1] )
		oQueryC:SetString( 14, jParams['MV_PAR06'][1] )
		oQueryC:SetString( 15, jParams['MV_PAR07'][1] )
		oQueryC:SetString( 16, '50' )
		oQueryC:SetString( 17, ' ' )

		// cria alias
		oQueryC:OpenAlias( cAliasC )

		// Alimenta o objeto de dados da classe para retornar ao SmartView
		DbSelectArea( cAliasC )
		While !( cAliasC )->( EOF( ) )
			jItems := JsonObject():new()

			If !( cAliasC )->( EOF( ) )
				nTOTDoc := calcTotDoc( 2,, cAliasC, cFilSB1 )
			EndIf

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SC7.C7_FILIAL,  SC7.C7_EMISSAO,  SC7.C7_NUM, SC7.C7_FORNECE, SC7.C7_LOJA, SC7.C7_ITEM, SC7.C7_PRODUTO, SC7.C7_UM, SC7.C7_QUANT, SC7.C7_PRECO, SC7.C7_TOTAL, SC7.C7_DATPRF, " + cCpoSC7
			cQuery += " SA2.A2_NOME, " + cCpoSA2
			cQuery += " SB1.B1_DESC, " + cCpoSB1 + " SB1.B1_GRUPO "
			cQuery += "FROM " + RetSQLName( 'SC7' ) + " SC7 "
			cQuery += "INNER JOIN " + RetSQLName( 'SA2' ) + " SA2 "
			cQuery += "   ON SA2.A2_FILIAL = ? "
			cQuery += "      AND SA2.A2_COD = SC7.C7_FORNECE "
			cQuery += "      AND SA2.A2_LOJA = SC7.C7_LOJA "
			cQuery += "     AND SA2.D_E_L_E_T_ = ? "
	  		cQuery += "INNER JOIN "+ RetSQLName( 'SB1' ) + " SB1 "
			cQuery += "   ON SB1.B1_FILIAL = ? "
			cQuery += "      AND SB1.B1_COD = SC7.C7_PRODUTO "
			cQuery += "     AND SB1.D_E_L_E_T_ = ? "
			cQuery += "WHERE SC7.C7_FILIAL = ? "
			cQuery += "   AND SC7.C7_NUM = ? "
			cQuery += "   AND SC7.C7_FORNECE = ? "
			cQuery += "   AND SC7.C7_LOJA = ? "
			cQuery += "   AND SC7.C7_ITEM = ? "
			cQuery += "   AND SC7.D_E_L_E_T_ = ? "
			
			// Agrega os filtros do SMARTVIEW na QUERY
			For nX := 1 To Len( aFiltro )
				cQuery += "AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
			Next

			cQuery := ChangeQuery( cQuery )

			nSQL := 0

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			oQueryA := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryA:SetQuery( cQuery )
			
			oQueryA:SetString( 1, cFilSA2 )
			oQueryA:SetString( 2, ' ' )
			oQueryA:SetString( 3, cFilSB1 )
			oQueryA:SetString( 4, ' ' )
			oQueryA:SetString( 5, cFilSC7 )
			oQueryA:SetString( 6, ( cAliasC )->D1_PEDIDO )
			oQueryA:SetString( 7, ( cAliasC )->C7_FORNECE )
			oQueryA:SetString( 8, ( cAliasC )->C7_LOJA )
			oQueryA:SetString( 9, ( cAliasC )->D1_ITEMPC )
			oQueryA:SetString( 10, ' ' )
			
			// cria alias
			oQueryA:OpenAlias( cAliasA )

			If !( cAliasA )->( EOF( ) )
				nTOTPed := calcTotDoc( 1, cAliasA,, cFilSB1 )
			EndIf

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SD11.D1_FILIAL, SD11.D1_DOC D1_REMITO, SD11.D1_SERIE, SD11.D1_ITEM, SD11.D1_QUANT D1_QUANT_2, SD11.D1_QTSEGUM, " + cCpoSD1 + " SD11.D1_DTDIGIT "
			cQuery += "FROM " + RetSQLName( 'SD1' ) + " SD11 "
			cQuery += "WHERE SD11.D1_FILIAL = ? "
			cQuery += "   AND SD11.D1_DOC = ? "
			cQuery += "   AND SD11.D1_SERIE = ? "
			cQuery += "   AND SD11.D1_ITEM = ? "
			cQuery += "   AND SD11.D1_FORNECE = ? "
			cQuery += "   AND SD11.D1_LOJA = ? "
			cQuery += "   AND SD11.D_E_L_E_T_ = ? "
			
			cQuery := ChangeQuery( cQuery )
			
			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			oQueryB := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryB:SetQuery( cQuery )

			oQueryB:SetString( 1, cFilSD1 )
			oQueryB:SetString( 2, ( cAliasC )->D1_REMITO )
			oQueryB:SetString( 3, ( cAliasC )->D1_SERIREM )
			oQueryB:SetString( 4, ( cAliasC )->D1_ITEMREM )
			oQueryB:SetString( 5, ( cAliasC )->C7_FORNECE )
			oQueryB:SetString( 6, ( cAliasC )->C7_LOJA )
			oQueryB:SetString( 7, ' ' )
			
			// cria alias
			oQueryB:OpenAlias( cAliasB )

			// Alimenta o objeto de dados da classe para retornar ao SmartView
			For nX := 1 To Len( self:aStruct )
				If ( AllTrim( self:aStruct[nx][5] ) $ 'C7_EMISSAO|C7_NUM|C7_ITEM|C7_QUANT|C7_PRECO|C7_TOTAL|C7_TOTPED|C7_DATPRF' + cCpoFil01 )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'C7_TOTPED' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPed, nDecs )
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D1_QUANT')
					jItems[self:aStruct[nX][1]] := ( cAliasC )->&( self:aStruct[nX][5] )
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D1_REMITO|D1_SERIE|D1_ITEM|D1_QUANT_2|D1_QTSEGUM|D1_DTDIGIT' + cCpoFil02 )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D1_EMISSAO|D1_DOC|D1_SERIE_1|D1_ITEM_1|D1_QUANT_1|D1_VUNIT|D1_TOTAL|D1_TOTDOC|D1_TES|D1_CONTA|D1_CC|D1_CUSTO|D1_DIV01|D1_DIV02|D1_DIV03|A2_NOME|B1_DESC|B1_GRUPO|C7_FORNECE|C7_LOJA|C7_PRODUTO|C7_UM' + cCpoFil02 )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasC )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasC )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'D1_TOTDOC' )
						jItems[self:aStruct[nX][1]] := Round( nTOTDoc, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'D1_DIV01' )
						jItems[self:aStruct[nX][1]] := 0
						If !Empty( ( cAliasC )->D1_DOC ) .And. !Empty( ( cAliasA )->C7_NUM )
							If ( ( cAliasA )->C7_QUANT != ( cAliasC )->D1_QUANT_1 )
								jItems[self:aStruct[nX][1]] := ( ( ( cAliasA )->C7_QUANT - ( cAliasC )->D1_QUANT_1 ) * -1 )
							EndIf
						EndIf
					ElseIf ( self:aStruct[nx][5] == 'D1_DIV02' )
						jItems[self:aStruct[nX][1]] := 0
						If !Empty( ( cAliasC )->D1_DOC ) .And. !Empty( ( cAliasA )->C7_NUM )
							If ( ( cAliasA )->C7_PRECO != ( cAliasC )->D1_VUNIT )
								jItems[self:aStruct[nX][1]] := ( ( ( cAliasA )->C7_PRECO - ( cAliasC )->D1_VUNIT ) * -1 )
							EndIf
						EndIf
					ElseIf ( self:aStruct[nx][5] == 'D1_DIV03' )
						jItems[self:aStruct[nX][1]] := 0
						If !Empty( ( cAliasC )->D1_DOC ) .And. !Empty( ( cAliasA )->C7_NUM )
							If ( ( cAliasA )->C7_DATPRF != ( cAliasC )->D1_DTDIGIT )
								jItems[self:aStruct[nX][1]] := ( ( StoD( ( cAliasA )->C7_DATPRF ) - IIf( Empty( ( cAliasC )->D1_DTDIGIT ), dDataBase, StoD( ( cAliasC )->D1_DTDIGIT ) ) ) * -1 )
							EndIf
						EndIf
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasC )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) == 'C7_FILIAL' )
					jItems[self:aStruct[nX][1]] := IIf(!Empty((cAliasA)->C7_FILIAL ),( cAliasA )->C7_FILIAL,IIF(!Empty( ( cAliasB )->D1_FILIAL ),( cAliasB )->D1_FILIAL,( cAliasC )->D1_FILIAL))
				EndIf
			Next

			// Inclui os dados no objeto paea retorno ao SmartView
			self:oData:appendData( jItems )

			( cAliasA )->( DbCloseArea( ) )
			( cAliasB )->( DbCloseArea( ) )

			( cAliasC )->( DbSkip( ) )
			nCount++

			nTOTPed := 0
			nTOTDoc := 0
		End
		( cAliasC )->( DbCloseArea( ) )
	EndIf

	// fecha objeto
	If oQueryA <> Nil
		oQueryA:Destroy()
		oQueryA := NIL
		FwFreeObj(oQueryA)
	EndIf
	If oQueryB <> Nil
		oQueryB:Destroy()
		oQueryB := NIL
		FwFreeObj(oQueryB)
	EndIf
	If oQueryC <> Nil
		oQueryC:Destroy()
		oQueryC := NIL
		FwFreeObj(oQueryC)
	EndIf

Return( self:oData )

//-------------------------------------------------------------------------------
/*{Protheus.doc} calcTotDoc
@description Rotina para retornar o $ total do documento ou o peso total
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
Static Function calcTotDoc( nTipoDoc, cAliasA, cAliasC, cFilSB1 )

	Local nRet as numeric
	Local cQry as character
	Local cAliasD := GetNextAlias() as character
	Local oQueryD as object

	Default nTipoDoc := 0
	Default cAliasA := ''
	Default cAliasC := ''
	Default cFilSB1 := ''

	nRet := 0
	cQry := ''

	If ( nTipoDoc == 1 ) .And. !Empty( cAliasA )
		cQry := "SELECT SUM( SC7.C7_TOTAL) TOTAL "
		cQry += "FROM " + RetSQlName( 'SC7' ) + " SC7 "
		cQry += "WHERE SC7.C7_FILIAL = ? "
		cQry += "   AND SC7.C7_NUM = ? "
		cQry += "   AND SC7.C7_FORNECE = ? "
		cQry += "   AND SC7.C7_LOJA = ? "
		cQry += "   AND SC7.D_E_L_E_T_ = ? "
	ElseIf ( nTipoDoc == 2 ) .And. !Empty( cAliasC )
		If !Empty( ( cAliasC )->D1_DOC )
			cQry := "SELECT SUM( SD1.D1_TOTAL) TOTAL "
			cQry += "FROM " + RetSQlName( 'SD1' ) + " SD1 "
			cQry += "WHERE SD1.D1_FILIAL = ? "
			cQry += "   AND SD1.D1_DOC = ? "
			cQry += "   AND SD1.D1_SERIE = ? "
			cQry += "   AND SD1.D_E_L_E_T_ = ? "
		EndIf
	EndIf

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	If !Empty( cQry )
		cQry := ChangeQuery( cQry )

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		oQueryD := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQueryD:SetQuery( cQry )

		If ( nTipoDoc == 1 ) .And. !Empty( cAliasA )
			oQueryD:SetString( 1, ( cAliasA )->C7_FILIAL )
			oQueryD:SetString( 2, ( cAliasA )->C7_NUM )
			oQueryD:SetString( 3, ( cAliasA )->C7_FORNECE )
			oQueryD:SetString( 4, ( cAliasA )->C7_LOJA )
			oQueryD:SetString( 5, ' ' )
		ElseIf ( nTipoDoc == 2 ) .And. !Empty( cAliasC )
			If !Empty( ( cAliasC )->D1_DOC )
				oQueryD:SetString( 1, ( cAliasc )->D1_FILIAL )
				oQueryD:SetString( 2, ( cAliasC )->D1_DOC )
				oQueryD:SetString( 3, ( cAliasC )->D1_SERIE_1 )
				oQueryD:SetString( 4, ' ' )
			EndIf
		EndIf

		// cria alias
		oQueryD:OpenAlias( cAliasD )

		DbSelectArea( cAliasD )
		If !( cAliasD )->( EOF( ) )
			nRet := ( cAliasD )->TOTAL
		EndIf
		( cAliasD )->( DbCloseArea( ) )
	EndIf

	If oQueryD <> Nil
		oQueryD:Destroy()
		oQueryD := NIL
		FwFreeObj(oQueryD)
	EndIf

Return( nRet )
