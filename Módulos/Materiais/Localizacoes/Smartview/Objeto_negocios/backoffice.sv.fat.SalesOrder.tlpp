#INCLUDE 'msobject.ch'
#INCLUDE 'tlpp-core.th'
#INCLUDE 'tlpp-rest.th'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fat.SalesOrder.ch'

//-------------------------------------------------------------------------------
/*{Protheus.doc} salesorderTReportsBusinessObject
Classe para criação do Objeto de Negocio de faturamento para SmartView
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
namespace custom.faturamento.salesorder.integratedprovider

// Annotation
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFAT', tables='SC5,SC6,SA1,SB1,SC9,SD2', name='Pedido de Ventas', country='ALL', initialRelease='12.1.2310', customTables='ALL' )
class salesorderTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} NEW
Método de instância da classe: Define a lista de importações que serão acessados no objeto de negocios
@return object: self
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method new() class salesorderTReportsBusinessObject

	Local aCpos as array

	aCpos := { }

	_Super:new()

	// Define a Área
	self:appendArea( STR0039 ) // 'Faturamento'

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 ) // 'Pedido de Ventas'

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 ) // 'Pedido de Ventas'

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'MATSV898' ) // Indica o pergunte que será utilizado
		IIf(!self:setErrorStatus( 400, STR0002, STR0003 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0004,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0005 ,,, ) //'¡Grupo de preguntas no encontrado!'
	EndIf

	// Adiciona os campos virtuais/calculados
	aAdd( aCpos, { 'C5_DESMOE' , STR0006, 'string', STR0007 } ) // 'Descripción de la moneda Pedido' ## 'Desc. Moneda Pedido'
	aAdd( aCpos, { 'C5_DETALHE', STR0008, 'string', STR0009 } ) // 'Detalle del Pedido' ## 'Detalle Pedido'
	aAdd( aCpos, { 'C5_TAXADIA', STR0010, 'number', STR0010 } ) // 'Tasa del Día' ## 'Tasa del Día'
	aAdd( aCpos, { 'C5_TOTPED' , STR0011, 'number', STR0012 } ) // 'Total de Pedido de Venta' ## 'Total Pedido'
	aAdd( aCpos, { 'C5_TOTCON1', STR0013, 'number', STR0014 } ) // 'Total del Pedido en Moneda 1' ## 'Total Pedido Moneda 1'
	aAdd( aCpos, { 'C5_TOTCON2', STR0015, 'number', STR0016 } ) // 'Total del Pedido Convertido Tx. Dia' ## 'Total Pedido Convertido Tx. Dia'
	aAdd( aCpos, { 'C5_TOTPES1', STR0017, 'number', STR0018 } ) // 'Peso del Item' ## 'Peso ítem'
	aAdd( aCpos, { 'C5_TOTPES2', STR0019, 'number', STR0020 } ) // 'Peso del Pedido' ## 'Peso Pedido'
	aAdd( aCpos, { 'C5_STATUS' , STR0021, 'string', STR0021 } ) // 'Estado'
	aAdd( aCpos, { 'D2_TOTDOC' , STR0022, 'number', STR0023 } ) // 'Total de la Factura' ## 'Total Factura'
	aAdd( aCpos, { 'D2_TOTCON1', STR0024, 'number', STR0025 } ) // 'Total de Factura en Moneda 1' ## 'Total Factura Moneda 1'
	aAdd( aCpos, { 'D2_TOTCON2', STR0026, 'number', STR0026 } ) // 'Total Factura Convertido  Tx. Dia'
	aAdd( aCpos, { 'D2_EMISS_1', STR0027, 'date'  , STR0028 } ) // 'Fecha de Emisión de la Factura' ## 'Emisión Factura'
	aAdd( aCpos, { 'D2_DOC'    , STR0029, 'string', STR0029 } ) // 'Factura'
	aAdd( aCpos, { 'D2_SERIE_1', STR0030, 'string', STR0030 } ) // 'Serie'
	aAdd( aCpos, { 'D2_ITEM_1' , STR0031, 'string', STR0031 } ) // 'Artículo'
	aAdd( aCpos, { 'D2_QUANT_1', STR0032, 'number', STR0032 } ) // 'Cantidad'
	aAdd( aCpos, { 'F2_DESMOE' , STR0033, 'string', STR0034 } ) // 'Descripción de la moneda factura' ## 'Desc. Moneda Factura'
	aAdd( aCpos, { 'F2_TAXADIA', STR0010, 'number', STR0010 } ) // 'Tasa del Día' ## 'Tasa del Día'

	// Define os campos que serão retornados no objeto de negocios
	self:aFields := { 'C5_FILIAL', 'C5_EMISSAO', 'C5_CATPV', 'C5_NUM', 'C5_CLIENTE', 'C5_LOJACLI', 'A1_NOME', 'C6_ITEM', 'C6_PRODUTO', 'B1_DESC', 'C6_UM', 'B1_GRUPO', 'C6_QTDVEN', 'C5_TOTPES1', 'C5_TOTPES2', 'C5_MOEDA', 'C5_DESMOE', 'C5_TXMOEDA', 'C5_TAXADIA', 'C6_VALOR', 'C5_TOTPED', 'C5_TOTCON1', 'C5_TOTCON2','C6_ENTREG', 'C5_STATUS', 'C5_DETALHE', 'D2_EMISSAO', 'D2_REMITO', 'D2_SERIE', 'D2_ITEM', 'D2_QUANT', 'D2_EMISS_1', 'D2_DOC', 'D2_SERIE_1', 'D2_ITEM_1', 'D2_QUANT_1', 'F2_MOEDA', 'F2_DESMOE', 'F2_TXMOEDA', 'F2_TAXADIA', 'D2_TOTAL', 'D2_TOTDOC', 'D2_TOTCON1', 'D2_TOTCON2' }

	self:aStruct := getStrutObj( self:aFields, aCpos, .T. )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura de campos 
@return object: self:oSchema 
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema( ) as object class salesorderTReportsBusinessObject

	Local n1 as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTVIEW
	For n1 := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[n1][1], self:aStruct[n1][2], self:aStruct[n1][3], self:aStruct[n1][4], self:aStruct[n1][5] )
	Next

Return( self:oSchema )


//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os datos do objeto de negócios
@param oFilter, objeto, contém o filtro do SmartView
@return object: self:oData
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object ) as object class salesorderTReportsBusinessObject

	// Declaracao de variaveis
	Local jParams as json
	Local jItems as json

	Local cQuery as character
	Local cAliasA := GetNextAlias() as character
	Local cAliasB := GetNextAlias() as character
	Local cAliasC := GetNextAlias() as character
	Local cDescMon as character
	Local cFiltro as character
	Local cExp as character
	Local cFilSA1 as character
	Local cFilSB1 as character
	Local cFilAGR as character
	Local cFilSBM as character
	Local cFilSC5 as character
	Local cFilSC6 as character
	Local cFilSD2 as character
	Local cFilSF2 as character

	Local nX as numeric
	Local nDecs as numeric
	Local nMoeda as numeric
	Local n1 as numeric
	Local nPosMon as numeric
	Local nPosExp as numeric
	Local nQtMoedas as numeric
	Local nTxMoeConv as numeric
	Local nTOTCon1 as numeric
	Local nTOTPed as numeric
	Local nTOTDoc as numeric
	Local nTOTPes1 as numeric
	Local nTOTPes2 as numeric
	Local nParMoe as numeric
	Local nParOpc as numeric

	Local aPDFields as array
	Local aNomeMoed as array
	Local aStatusPed as array
	Local aFiltro as array

	Local lObfuscated as logical

	Local oQueryA		as object
	Local oQueryB		as object
	Local oQueryC		as object

	cDescMon := ''
	cFiltro := ''
	cExp := ''
	cFilSA1 := xFilial( 'SA1' )
	cFilSB1 := xFilial( 'SB1' )
	cFilAGR := xFilial( 'AGR' )
	cFilSBM := xFilial( 'SBM' )
	cFilSC5 := xFilial( 'SC5' )
	cFilSC6 := xFilial( 'SC6' )
	cFilSD2 := xFilial( 'SD2' )
	cFilSF2 := xFilial( 'SF2' )

	nPosMon := 0
	nPosExp := 0
	nDecs := MsDecimais( 1 )
	nQtMoedas := Moedfin( )
	nMoeda := 1
	n1 := 0
	nTxMoeConv := 0
	nTOTCon1 := 0
	nTOTPed := 0
	nTOTDoc := 0
	nTOTPes1 := 0
	nTOTPes2 := 0

	aPDFields := { }
	aNomeMoed := { }
	aStatusPed := { '', '' }
	aFiltro := { }

	lObfuscated := .F.

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Lista as moedas e suas descrições
	For nX := 1 To nQtMoedas
		aAdd( aNomeMoed, { AllTrim( Str( nX ) ), SuperGetMv( 'MV_MOEDA' + AllTrim( Str( nX ) ) ) } )
	Next

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	If oFilter:hasFilter()
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )

		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )
	EndIf

	nParMoe := IIf(ValType(jParams['MV_PAR12'][1])=="C",Val(jParams['MV_PAR12'][1]),jParams['MV_PAR12'][1])
	nParOpc := IIf(ValType(jParams['MV_PAR01'][1])=="C",Val(jParams['MV_PAR01'][1]),jParams['MV_PAR01'][1])

	// Pesquisa a taxa do dia
	If ( nParMoe > 0 )
		DbSelectArea( 'SM2' )
		SM2->( DbSetOrder( 1 ) )
		If SM2->( DbSeek( DtoS( dDataBase ) ) ) // M2_DATA
			nTxMoeConv := SM2->&( ( 'M2_MOEDA' + StrZero( nParMoe, 1 ) ) )
		EndIf
	EndIf

	If ( nParOpc == 1 )
		// Realiza a montagem da QUERY que será enviada para o banco de dados
		cQuery := "SELECT SC5.C5_FILIAL, SC5.C5_NOTA, SC5.C5_EMISSAO, SC5.C5_CATPV||' '||AGR.AGR_DESCRI C5_CATPV, SC5.C5_NUM, SC5.C5_CLIENTE, SC5.C5_LOJACLI, SC5.C5_MOEDA, SC5.C5_TXMOEDA, SA1.A1_NOME, SA1.A1_RISCO, SC6.C6_ITEM, SC6.C6_PRODUTO, SB1.B1_DESC, SC6.C6_UM, SB1.B1_GRUPO||' '||SBM.BM_DESC B1_GRUPO, SB1.B1_PESO, SC6.C6_QTDVEN, SC6.C6_VALOR, SC6.C6_ENTREG "
		cQuery += "FROM " + RetSQLName( 'SC5' ) + " SC5 "
		cQuery += "INNER JOIN " + RetSQLName( 'SC6' ) + " SC6 "
		cQuery += "   ON SC6.C6_FILIAL = ? "
		cQuery += "      AND SC6.C6_NUM = SC5.C5_NUM "
		cQuery += "      AND SC6.C6_CLI = SC5.C5_CLIENTE "
		cQuery += "      AND SC6.C6_PRODUTO BETWEEN ? AND ? "
		cQuery += "      AND SC6.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN " + RetSQLName( 'SA1' ) + " SA1 "
		cQuery += "   ON SA1.A1_FILIAL = ? "
		cQuery += "      AND SA1.A1_COD = SC5.C5_CLIENTE "
		cQuery += "      AND SA1.A1_LOJA = SC5.C5_LOJACLI "
		cQuery += "      AND SA1.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN " + RetSQLName( 'SB1' ) + " SB1 "
		cQuery += "   ON SB1.B1_FILIAL = ? "
		cQuery += "      AND SB1.B1_COD = SC6.C6_PRODUTO "
		cQuery += "      AND SB1.D_E_L_E_T_ = ? "
		cQuery += "LEFT JOIN  " + RetSQLName( 'AGR' ) + " AGR "
		cQuery += "   ON AGR.AGR_FILIAL = ? "
		cQuery += "      AND AGR.AGR_COD = SC5.C5_CATPV "
		cQuery += "      AND AGR.D_E_L_E_T_ = ? "
		cQuery += "LEFT JOIN  " + RetSQLName( 'SBM' ) + " SBM "
		cQuery += "   ON SBM.BM_FILIAL = ? "
		cQuery += "      AND SBM.BM_GRUPO = SB1.B1_GRUPO "
		cQuery += "      AND SBM.D_E_L_E_T_ = ? "
		cQuery += "WHERE SC5.C5_FILIAL = ? "
		cQuery += "   AND SC5.C5_NUM BETWEEN ? AND ? "
		cQuery += "   AND SC5.C5_EMISSAO BETWEEN ? AND ? "
		cQuery += "   AND SC5.C5_CLIENTE BETWEEN ? AND ? "
		cQuery += "   AND SC5.C5_LOJACLI BETWEEN ? AND ? "
		cQuery += "   AND SC5.D_E_L_E_T_ = ? "

		// Agrega os filtros do SMARTVIEW na QUERY
		For nX := 1 To Len( aFiltro )
			cQuery += "AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
		Next

		cQuery += "ORDER BY ? "

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		cQuery := ChangeQuery( cQuery )

		oQueryA := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQueryA:SetQuery( cQuery )

		oQueryA:SetString( 1, FwxFilial( 'SC6' ) )
		oQueryA:SetString( 2, jParams['MV_PAR08'][1] )
		oQueryA:SetString( 3, jParams['MV_PAR09'][1] )
		oQueryA:SetString( 4, ' ' )
		oQueryA:SetString( 5, FwxFilial( 'SA1' ) )
		oQueryA:SetString( 6, ' ' )
		oQueryA:SetString( 7, FwxFilial( 'SB1' ) )
		oQueryA:SetString( 8, ' ' )
		oQueryA:SetString( 9, FwxFilial( 'AGR' ) )
		oQueryA:SetString( 10, ' ' )
		oQueryA:SetString( 11, FwxFilial( 'SBM' ) )
		oQueryA:SetString( 12, ' ' )
		oQueryA:SetString( 13, FwxFilial( 'SC5' ) )
		oQueryA:SetString( 14, jParams['MV_PAR02'][1] )
		oQueryA:SetString( 15, jParams['MV_PAR03'][1] )
		oQueryA:SetString( 16, DtoS( FwDateTimeToLocal( jParams['MV_PAR10'][1] )[1] ) )
		oQueryA:SetString( 17, DtoS( FwDateTimeToLocal( jParams['MV_PAR11'][1] )[1] ) )
		oQueryA:SetString( 18, jParams['MV_PAR04'][1] )
		oQueryA:SetString( 19, jParams['MV_PAR06'][1] )
		oQueryA:SetString( 20, jParams['MV_PAR05'][1] )
		oQueryA:SetString( 21, jParams['MV_PAR07'][1] )
		oQueryA:SetString( 22, ' ' )
		oQueryA:SetUnsafe( 23, 'SC5.C5_FILIAL, SC5.C5_NUM' )

		// cria alias
		oQueryA:OpenAlias( cAliasA )

		// Alimenta o objeto de dados da classe para retornar ao SmartView
		DbSelectArea( cAliasA )
		While !( cAliasA )->( EOF( ) )
			jItems := JsonObject():new()

			aStatusPed := getStatus( cAliasA )

			nTOTPed := calcTotDoc( 1, cAliasA,, cFilSB1 )
			nTOTPes1 := calcTotDoc( 3, cAliasA,, cFilSB1 )
			nTOTPes2 := calcTotDoc( 4, cAliasA,, cFilSB1 )

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SD21.D2_FILIAL, SD21.D2_EMISSAO, SD21.D2_DOC D2_REMITO, SD21.D2_SERIE, SD21.D2_ITEM, SD21.D2_QUANT "
			cQuery += "FROM " + RetSQLName( 'SD2' ) + " SD21 "
			cQuery += "WHERE SD21.D2_FILIAL = ? "
			cQuery += "   AND SD21.D2_PEDIDO = ? "
			cQuery += "   AND SD21.D2_ITEMPV = ? "
			cQuery += "   AND SD21.D2_CLIENTE = ? "
			cQuery += "   AND SD21.D2_LOJA = ? "
			cQuery += "   AND SD21.D2_TIPODOC >= ? "
			cQuery += "   AND SD21.D_E_L_E_T_ = ? "

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			cQuery := ChangeQuery( cQuery )

			oQueryB := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryB:SetQuery( cQuery )

			oQueryB:SetString( 1, FwxFilial( 'SD2' ) )
			oQueryB:SetString( 2, ( cAliasA )->C5_NUM )
			oQueryB:SetString( 3, ( cAliasA )->C6_ITEM )
			oQueryB:SetString( 4, ( cAliasA )->C5_CLIENTE )
			oQueryB:SetString( 5, ( cAliasA )->C5_LOJACLI )
			oQueryB:SetString( 6, '50' )
			oQueryB:SetString( 7, ' ' )

			// cria alias
			oQueryB:OpenAlias( cAliasB )

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SD22.D2_FILIAL, SD22.D2_EMISSAO D2_EMISS_1, SD22.D2_DOC, SD22.D2_SERIE D2_SERIE_1, SD22.D2_ITEM D2_ITEM_1, SD22.D2_QUANT D2_QUANT_1, SF22.F2_MOEDA, SF22.F2_TXMOEDA, SD22.D2_TOTAL "
			cQuery += "FROM " + RetSQLName( 'SD2' ) + " SD22 "
			cQuery += "INNER JOIN " + RetSQLName( 'SF2' ) + " SF22 "
			cQuery += "   ON SF22.F2_FILIAL = ? "
			cQuery += "      AND SF22.F2_DOC = SD22.D2_DOC "
			cQuery += "      AND SF22.F2_SERIE = SD22.D2_SERIE "
			cQuery += "      AND SF22.F2_SERIE <> ? "
			cQuery += "      AND SF22.F2_CLIENTE = SD22.D2_CLIENTE "
			cQuery += "      AND SF22.F2_LOJA = SD22.D2_LOJA "
			cQuery += "      AND SF22.D_E_L_E_T_ = ? "
			cQuery += "WHERE SD22.D2_FILIAL =  ? "
			cQuery += "   AND SD22.D2_PEDIDO = ? "
			cQuery += "   AND SD22.D2_ITEMPV = ? "
			cQuery += "   AND SD22.D2_CLIENTE = ? "
			cQuery += "   AND SD22.D2_LOJA = ? "
			cQuery += "   AND SD22.D2_TIPODOC < ? "
			cQuery += "   AND SD22.D_E_L_E_T_ = ? "

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			cQuery := ChangeQuery( cQuery )

			oQueryC := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryC:SetQuery( cQuery )

			oQueryC:SetString( 1, FwxFilial( 'SF2' ) )
			oQueryC:SetString( 2, 'R' )
			oQueryC:SetString( 3, ' ' )
			oQueryC:SetString( 4, cFilSD2 )
			oQueryC:SetString( 5, ( cAliasA )->C5_NUM )
			oQueryC:SetString( 6, ( cAliasA )->C6_ITEM )
			oQueryC:SetString( 7, ( cAliasA )->C5_CLIENTE )
			oQueryC:SetString( 8, ( cAliasA )->C5_LOJACLI )
			oQueryC:SetString( 9, '50' )
			oQueryC:SetString( 10, ' ' )

			// cria alias
			oQueryC:OpenAlias( cAliasC )

			DbSelectArea( cAliasC )
			If !( cAliasC )->( EOF( ) )
				nTOTDoc := calcTotDoc( 2, cAliasA, cAliasC, cFilSB1 )
			EndIf

			// Alimenta o objeto de dados da classe para retornar ao SmartView
			For nX := 1 To Len( self:aStruct )
				If ( AllTrim( self:aStruct[nx][5] ) $ 'C5_EMISSAO|C5_CATPV|C5_NUM|C5_CLIENTE|C5_LOJACLI|A1_NOME|C6_ITEM|C6_PRODUTO|B1_DESC|C6_UM|B1_GRUPO|C6_QTDVEN|C5_TOTPES1|C5_TOTPES2|C5_MOEDA|C5_DESMOE|C5_TXMOEDA|C5_TAXADIA|C6_VALOR|C5_TOTPED|C5_TOTCON1|C5_TOTCON2|C6_ENTREG|C5_STATUS|C5_DETALHE' )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'C5_DESMOE' )
						// Moneda Orden
						nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAliasA )->C5_MOEDA ) ) } )
						cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
						jItems[self:aStruct[nX][1]] := cDescMon
					ElseIf ( self:aStruct[nx][5] == 'C5_TAXADIA' )
						jItems[self:aStruct[nX][1]] := nTxMoeConv
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTPED' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPed, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTCON1' )
						nTOTCon1 := Round( xMoeda( nTOTPed, ( cAliasA )->C5_MOEDA, nMoeda, dDataBase, nDecs, ( cAliasA )->C5_TXMOEDA, 1, ), nDecs )
						jItems[self:aStruct[nX][1]] := nTOTCon1
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTCON2' )
						jItems[self:aStruct[nX][1]] := IIF(nTxMoeConv > 0,Round( xMoeda( nTOTCon1, 1, nParMoe, dDataBase,,,, ), nDecs ),0)
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTPES1' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPes1, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTPES2' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPes2, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'C5_STATUS' )
						jItems[self:aStruct[nX][1]] := aStatusPed[1]
					ElseIf ( self:aStruct[nx][5] == 'C5_DETALHE' )
						jItems[self:aStruct[nX][1]] := aStatusPed[2]
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D2_EMISSAO|D2_REMITO|D2_SERIE|D2_ITEM|D2_QUANT' )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D2_EMISS_1|D2_DOC|D2_SERIE_1|D2_ITEM_1|D2_QUANT_1|F2_MOEDA|F2_DESMOE|F2_TXMOEDA|F2_TAXADIA|D2_TOTAL|D2_TOTDOC|D2_TOTCON1|D2_TOTCON2' )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasC )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasC )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'F2_DESMOE' )
						// Moneda Factura
						nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAliasC )->F2_MOEDA ) ) } )
						cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
						jItems[self:aStruct[nX][1]] := cDescMon
					ElseIf ( self:aStruct[nx][5] == 'F2_TAXADIA' )
						jItems[self:aStruct[nX][1]] := nTxMoeConv
					ElseIf ( self:aStruct[nx][5] == 'D2_TOTDOC' )
						jItems[self:aStruct[nX][1]] := Round( nTOTDoc, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'D2_TOTCON1' )
						nTOTCon1 := Round( xMoeda( nTOTDoc, ( cAliasC )->F2_MOEDA, nMoeda, dDataBase, nDecs, ( cAliasC )->F2_TXMOEDA, 1, ), nDecs )
						jItems[self:aStruct[nX][1]] := nTOTCon1
					ElseIf ( self:aStruct[nx][5] == 'D2_TOTCON2' )
						jItems[self:aStruct[nX][1]] := IIF(nTxMoeConv > 0,Round( xMoeda( nTOTCon1, 1, nParMoe, dDataBase,,,, ), nDecs ),0)
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasC )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) == 'C5_FILIAL' )
					jItems[self:aStruct[nX][1]] := IIF(!Empty( ( cAliasA )->C5_FILIAL ),( cAliasA )->C5_FILIAL,IIF(!Empty( ( cAliasB )->D2_FILIAL ),( cAliasB )->D2_FILIAL,IIF(!Empty( ( cAliasC )->D2_FILIAL ),( cAliasC )->D2_FILIAL,"")))
				EndIf
			Next

			// Inclui os dados no objeto paea retorno ao SmartView
			self:oData:appendData( jItems )

			( cAliasB )->( DbCloseArea( ) )
			( cAliasC )->( DbCloseArea( ) )
			( cAliasA )->( DbSkip( ) )

			nTOTCon1 := 0
			nTOTPed := 0
			nTOTDoc := 0
			nTOTPes1 := 0
			nTOTPes2 := 0
		End
		( cAliasA )->( DbCloseArea( ) )
	ElseIf ( nParOpc == 2 )
		// Realiza a montagem da QUERY que será enviada para o banco de dados
		cQuery := "SELECT SD21.D2_FILIAL, SD21.D2_EMISSAO, SD21.D2_DOC D2_REMITO, SD21.D2_SERIE, SD21.D2_ITEM, SD21.D2_QUANT, SD21.D2_PEDIDO, SD21.D2_ITEMPV, SD21.D2_CLIENTE, SD21.D2_LOJA "
		cQuery += "FROM " + RetSQLName( 'SD2' ) + " SD21 "
		cQuery += "INNER JOIN " + RetSQLName( 'SA1' ) + " SA1 "
		cQuery += "   ON SA1.A1_FILIAL = ? "
		cQuery += "      AND SA1.A1_COD = SD21.D2_CLIENTE "
		cQuery += "      AND SA1.A1_LOJA = SD21.D2_LOJA "
		cQuery += "      AND SA1.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN " + RetSQLName( 'SB1' ) + " SB1 "
		cQuery += "   ON SB1.B1_FILIAL = ? "
		cQuery += "      AND SB1.B1_COD = SD21.D2_COD "
		cQuery += "      AND SB1.D_E_L_E_T_ = ? "
		cQuery += "WHERE SD21.D2_FILIAL = ? "
		cQuery += "   AND SD21.D2_DOC BETWEEN ? AND ? "
		cQuery += "   AND SD21.D2_EMISSAO BETWEEN ? AND ? "
		cQuery += "   AND SD21.D2_CLIENTE BETWEEN ? AND ? "
		cQuery += "   AND SD21.D2_LOJA BETWEEN ? AND ? "
		cQuery += "   AND SD21.D2_COD BETWEEN ? AND ? "
		cQuery += "   AND SD21.D2_TIPODOC >= ? "
		cQuery += "   AND SD21.D_E_L_E_T_ = ? "
		cQuery += "ORDER BY ? "

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		cQuery := ChangeQuery( cQuery )

		oQueryB := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQueryB:SetQuery( cQuery )

		oQueryB:SetString( 1, FwxFilial( 'SA1' ) )
		oQueryB:SetString( 2, ' ' )
		oQueryB:SetString( 3, FwxFilial( 'SB1' ) )
		oQueryB:SetString( 4, ' ' )
		oQueryB:SetString( 5, FwxFilial( 'SD2' ) )
		oQueryB:SetString( 6, jParams['MV_PAR02'][1] )
		oQueryB:SetString( 7, jParams['MV_PAR03'][1] )
		oQueryB:SetString( 8, DtoS( FwDateTimeToLocal( jParams['MV_PAR10'][1] )[1] ) )
		oQueryB:SetString( 9, DtoS( FwDateTimeToLocal( jParams['MV_PAR11'][1] )[1] ) )
		oQueryB:SetString( 10, jParams['MV_PAR04'][1] )
		oQueryB:SetString( 11, jParams['MV_PAR06'][1] )
		oQueryB:SetString( 12, jParams['MV_PAR05'][1] )
		oQueryB:SetString( 13, jParams['MV_PAR07'][1] )
		oQueryB:SetString( 14, jParams['MV_PAR08'][1] )
		oQueryB:SetString( 15, jParams['MV_PAR09'][1] )
		oQueryB:SetString( 16, ' ' )
		oQueryB:SetString( 17, ' ' )
		oQueryB:SetUnsafe( 18, 'SD21.D2_FILIAL,SD21.D2_DOC, SD21.D2_SERIE,SD21.D2_ITEM' )

		// cria alias
		oQueryB:OpenAlias( cAliasB )

		// Alimenta o objeto de dados da classe para retornar ao SmartView
		DbSelectArea( cAliasB )
		While !( cAliasB )->( EOF( ) )
			jItems := JsonObject():new()

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SD22.D2_FILIAL, SD22.D2_EMISSAO D2_EMISS_1, SD22.D2_DOC, SD22.D2_SERIE D2_SERIE_1, SD22.D2_ITEM D2_ITEM_1, SD22.D2_QUANT D2_QUANT_1, SF22.F2_MOEDA, SF22.F2_TXMOEDA, SD22.D2_TOTAL "
			cQuery += "FROM  " + RetSQLName( 'SD2' ) +  " SD22 "
			cQuery += "INNER JOIN " + RetSQLName( 'SF2' ) + " SF22 "
			cQuery += "   ON SF22.F2_FILIAL = ? "
			cQuery += "      AND SF22.F2_DOC = SD22.D2_DOC "
			cQuery += "      AND SF22.F2_SERIE = SD22.D2_SERIE "
			cQuery += "      AND SF22.F2_CLIENTE = SD22.D2_CLIENTE "
			cQuery += "      AND SF22.F2_LOJA = SD22.D2_LOJA "
			cQuery += "      AND SF22.D_E_L_E_T_ = ? "
			cQuery += "WHERE SD22.D2_FILIAL = ? "
			cQuery += "   AND SD22.D2_REMITO = ? "
			cQuery += "   AND SD22.D2_ITEMREM = ? "
			cQuery += "   AND SD22.D2_CLIENTE = ? "
			cQuery += "   AND SD22.D2_LOJA = ? "
			cQuery += "   AND SD22.D2_TIPODOC < ? "
			cQuery += "   AND SD22.D_E_L_E_T_ = ? "

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			cQuery := ChangeQuery( cQuery )

			oQueryC := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryC:SetQuery( cQuery )

			oQueryC:SetString( 1, FwxFilial( 'SF2' ) )
			oQueryC:SetString( 2, ' ' )
			oQueryC:SetString( 3, FwxFilial( 'SD2' ) )
			oQueryC:SetString( 4, ( cAliasB )->D2_REMITO )
			oQueryC:SetString( 5, ( cAliasB )->D2_ITEM )
			oQueryC:SetString( 6, ( cAliasB )->D2_CLIENTE )
			oQueryC:SetString( 7, ( cAliasB )->D2_LOJA )
			oQueryC:SetString( 8, '50' )
			oQueryC:SetString( 9, ' ' )

			// cria alias
			oQueryC:OpenAlias( cAliasC )

			DbSelectArea( cAliasC )
			If !( cAliasC )->( EOF( ) )
				nTOTDoc := calcTotDoc( 2,, cAliasC, cFilSB1 )
			EndIf

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SC5.C5_FILIAL, SC5.C5_NOTA, SC5.C5_EMISSAO, SC5.C5_CATPV||' '||AGR.AGR_DESCRI C5_CATPV, SC5.C5_NUM, SC5.C5_CLIENTE, SC5.C5_LOJACLI, SC5.C5_MOEDA, SC5.C5_TXMOEDA, SA1.A1_NOME, SA1.A1_RISCO, SC6.C6_ITEM, SC6.C6_PRODUTO, SB1.B1_DESC, SC6.C6_UM, SB1.B1_GRUPO||' '||SBM.BM_DESC B1_GRUPO, SB1.B1_PESO, SC6.C6_QTDVEN, SC6.C6_VALOR, SC6.C6_ENTREG "
			cQuery += "FROM " + RetSQLName( 'SC5' ) + " SC5 "
			cQuery += "INNER JOIN " + RetSQLName( 'SC6' ) + " SC6 "
			cQuery += "   ON SC6.C6_FILIAL = ? "
			cQuery += "      AND SC6.C6_NUM = SC5.C5_NUM "
			cQuery += "      AND SC6.C6_CLI = SC5.C5_CLIENTE "
			cQuery += "      AND SC6.C6_ITEM = ? "
			cQuery += "      AND SC6.D_E_L_E_T_ = ? "
			cQuery += "INNER JOIN " + RetSQLName( 'SA1' ) + " SA1 "
			cQuery += "   ON SA1.A1_FILIAL = ? "
			cQuery += "      AND SA1.A1_COD = SC5.C5_CLIENTE "
			cQuery += "      AND SA1.A1_LOJA = SC5.C5_LOJACLI "
			cQuery += "      AND SA1.D_E_L_E_T_ = ? "
			cQuery += "INNER JOIN " + RetSQLName( 'SB1' ) + " SB1 "
			cQuery += "   ON SB1.B1_FILIAL = ? "
			cQuery += "      AND SB1.B1_COD = SC6.C6_PRODUTO "
			cQuery += "      AND SB1.D_E_L_E_T_ = ? "
			cQuery += "LEFT JOIN " + RetSQLName( 'AGR' ) + " AGR "
			cQuery += "   ON AGR.AGR_FILIAL = ? "
			cQuery += "      AND AGR.AGR_COD = SC5.C5_CATPV "
			cQuery += "      AND AGR.D_E_L_E_T_ = ? "
			cQuery += "LEFT JOIN " + RetSQLName( 'SBM' ) + " SBM "
			cQuery += "   ON SBM.BM_FILIAL = ? "
			cQuery += "      AND SBM.BM_GRUPO = SB1.B1_GRUPO "
			cQuery += "      AND SBM.D_E_L_E_T_ = ? "
			cQuery += "WHERE SC5.C5_FILIAL = ? "
			cQuery += "   AND SC5.C5_NUM = ? "
			cQuery += "   AND SC5.C5_CLIENTE = ? "
			cQuery += "   AND SC5.C5_LOJACLI = ? "
			cQuery += "   AND SC5.D_E_L_E_T_ = ? "

			// Agrega os filtros do SMARTVIEW na QUERY
			For nX := 1 To Len( aFiltro )
				cQuery += "AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
			Next

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			cQuery := ChangeQuery( cQuery )

			oQueryA := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryA:SetQuery( cQuery )

			
			oQueryA:SetString( 1, FwxFilial( 'SC6' ) )
			oQueryA:SetString( 2, ( cAliasB )->D2_ITEMPV )
			oQueryA:SetString( 3, ' ' )
			oQueryA:SetString( 4, FwxFilial( 'SA1' ) )
			oQueryA:SetString( 5, ' ' )
			oQueryA:SetString( 6, FwxFilial( 'SB1' ) )
			oQueryA:SetString( 7, ' ' )
			oQueryA:SetString( 8, FwxFilial( 'AGR' ) )
			oQueryA:SetString( 9, ' ' )
			oQueryA:SetString( 10, FwxFilial( 'SBM' ) )
			oQueryA:SetString( 11, ' ' )
			oQueryA:SetString( 12, FwxFilial( 'SC5' ) )
			oQueryA:SetString( 13, ( cAliasB )->D2_PEDIDO )
			oQueryA:SetString( 14, ( cAliasB )->D2_CLIENTE )
			oQueryA:SetString( 15, ( cAliasB )->D2_LOJA )
			oQueryA:SetString( 16, ' ' )

			// cria alias
			oQueryA:OpenAlias(cAliasA)

			If !( cAliasA )->( EOF( ) )
				aStatusPed := getStatus( cAliasA )

				nTOTPed := calcTotDoc( 1, cAliasA,, cFilSB1 )
				nTOTPes1 := calcTotDoc( 3, cAliasA,, cFilSB1 )
				nTOTPes2 := calcTotDoc( 4, cAliasA,, cFilSB1 )
			EndIf

			// Alimenta o objeto de dados da classe para retornar ao SmartView
			For nX := 1 To Len( self:aStruct )
				If ( AllTrim( self:aStruct[nx][5] ) $ 'C5_EMISSAO|C5_CATPV|C5_NUM|C5_CLIENTE|C5_LOJACLI|A1_NOME|C6_ITEM|C6_PRODUTO|B1_DESC|C6_UM|B1_GRUPO|C6_QTDVEN|C5_TOTPES1|C5_TOTPES2|C5_MOEDA|C5_DESMOE|C5_TXMOEDA|C5_TAXADIA|C6_VALOR|C5_TOTPED|C5_TOTCON1|C5_TOTCON2|C6_ENTREG|C5_STATUS|C5_DETALHE' )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'C5_DESMOE' )
						// Moneda Orden
						nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAliasA )->C5_MOEDA ) ) } )
						cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
						jItems[self:aStruct[nX][1]] := cDescMon
					ElseIf ( self:aStruct[nx][5] == 'C5_TAXADIA' )
						jItems[self:aStruct[nX][1]] := nTxMoeConv
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTPED' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPed, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTCON1' )
						nTOTCon1 := Round( xMoeda( nTOTPed, ( cAliasA )->C5_MOEDA, nMoeda, dDataBase, nDecs, ( cAliasA )->C5_TXMOEDA, 1, ), nDecs )
						jItems[self:aStruct[nX][1]] := nTOTCon1
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTCON2' )
						jItems[self:aStruct[nX][1]] := IIF( nTxMoeConv > 0 ,Round( xMoeda( nTOTCon1, 1, nParMoe, dDataBase,,,, ), nDecs ),0)
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTPES1' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPes1, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTPES2' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPes2, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'C5_STATUS' )
						jItems[self:aStruct[nX][1]] := aStatusPed[1]
					ElseIf ( self:aStruct[nx][5] == 'C5_DETALHE' )
						jItems[self:aStruct[nX][1]] := aStatusPed[2]
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D2_EMISSAO|D2_REMITO|D2_SERIE|D2_ITEM|D2_QUANT' )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D2_EMISS_1|D2_DOC|D2_SERIE_1|D2_ITEM_1|D2_QUANT_1|F2_MOEDA|F2_DESMOE|F2_TXMOEDA|F2_TAXADIA|D2_TOTAL|D2_TOTDOC|D2_TOTCON1|D2_TOTCON2' )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasC )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasC )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'F2_DESMOE' )
						// Moneda Factura
						nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAliasC )->F2_MOEDA ) ) } )
						cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
						jItems[self:aStruct[nX][1]] := cDescMon
					ElseIf ( self:aStruct[nx][5] == 'F2_TAXADIA' )
						jItems[self:aStruct[nX][1]] := nTxMoeConv
					ElseIf ( self:aStruct[nx][5] == 'D2_TOTDOC' )
						jItems[self:aStruct[nX][1]] := Round( nTOTDoc, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'D2_TOTCON1' )
						nTOTCon1 := Round( xMoeda( nTOTDoc, ( cAliasC )->F2_MOEDA, nMoeda, dDataBase, nDecs, ( cAliasC )->F2_TXMOEDA, 1, ), nDecs )
						jItems[self:aStruct[nX][1]] := nTOTCon1
					ElseIf ( self:aStruct[nx][5] == 'D2_TOTCON2' )
						jItems[self:aStruct[nX][1]] := IIF(nTxMoeConv > 0,Round( xMoeda( nTOTCon1, 1, nParMoe, dDataBase,,,, ), nDecs ),0)
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasC )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) == 'C5_FILIAL' )
					jItems[self:aStruct[nX][1]] := IIF(!Empty( ( cAliasA )->C5_FILIAL ),( cAliasA )->C5_FILIAL,IIF(!Empty( ( cAliasB )->D2_FILIAL ),( cAliasB )->D2_FILIAL,IIF(!Empty( ( cAliasC )->D2_FILIAL ),( cAliasC )->D2_FILIAL,"")))
				EndIf
			Next

			// Inclui os dados no objeto paea retorno ao SmartView
			self:oData:appendData( jItems )

			( cAliasA )->( DbCloseArea( ) )
			( cAliasC )->( DbCloseArea( ) )
			( cAliasB )->( DbSkip( ) )

			nTOTCon1 := 0
			nTOTPed := 0
			nTOTDoc := 0
			nTOTPes1 := 0
			nTOTPes2 := 0
		End
		( cAliasB )->( DbCloseArea( ) )
	ElseIf ( nParOpc == 3 )
		// Realiza a montagem da QUERY que será enviada para o banco de dados
		cQuery := "SELECT SD22.D2_FILIAL, SD22.D2_EMISSAO D2_EMISS_1, SD22.D2_DOC, SD22.D2_SERIE D2_SERIE_1, SD22.D2_ITEM D2_ITEM_1, SD22.D2_QUANT D2_QUANT_1, SF22.F2_MOEDA, SF22.F2_TXMOEDA, SD22.D2_TOTAL, SD22.D2_REMITO, SD22.D2_SERIREM, SD22.D2_ITEMREM, SD22.D2_PEDIDO, SD22.D2_ITEMPV, SD22.D2_CLIENTE, SD22.D2_LOJA "
		cQuery += "FROM " + RetSQLName( 'SD2' ) + " SD22 "
		cQuery += "INNER JOIN " + RetSQLName( 'SF2' ) + " SF22 "
		cQuery += "   ON SF22.F2_FILIAL = ? "
		cQuery += "      AND SF22.F2_DOC = SD22.D2_DOC "
		cQuery += "      AND SF22.F2_SERIE = SD22.D2_SERIE "
		cQuery += "      AND SF22.F2_CLIENTE = SD22.D2_CLIENTE "
		cQuery += "      AND SF22.F2_LOJA = SD22.D2_LOJA "
		cQuery += "      AND SF22.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN " + RetSQLName( 'SA1' ) + " SA1 "
		cQuery += "   ON SA1.A1_FILIAL = ? "
		cQuery += "      AND SA1.A1_COD = SD22.D2_CLIENTE "
		cQuery += "      AND SA1.A1_LOJA = SD22.D2_LOJA "
		cQuery += "      AND SA1.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN " + RetSQLName( 'SB1' ) + " SB1 "
		cQuery += "   ON SB1.B1_FILIAL = ? "
		cQuery += "      AND SB1.B1_COD = SD22.D2_COD "
		cQuery += "      AND SB1.D_E_L_E_T_ = ? "
		cQuery += "WHERE SD22.D2_FILIAL = ? "
		cQuery += "   AND SD22.D2_DOC BETWEEN ? AND ? "
		cQuery += "   AND SD22.D2_EMISSAO BETWEEN ? AND ? "
		cQuery += "   AND SD22.D2_CLIENTE BETWEEN ? AND ? "
		cQuery += "   AND SD22.D2_LOJA BETWEEN ? AND ? "
		cQuery += "   AND SD22.D2_COD BETWEEN ? AND ? "
		cQuery += "   AND SD22.D2_TIPODOC < ? "
		cQuery += "   AND SD22.D_E_L_E_T_ = ? "

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		cQuery := ChangeQuery( cQuery )

		oQueryC := FwExecStatement():New()

		// Define a consulta e os parâmetros
		oQueryC:SetQuery( cQuery )

		oQueryC:SetString( 1, FwxFilial( 'SF2' ) )
		oQueryC:SetString( 2, ' ' )
		oQueryC:SetString( 3, FwxFilial( 'SA1' ) )
		oQueryC:SetString( 4, ' ' )
		oQueryC:SetString( 5, FwxFilial( 'SB1' ) )
		oQueryC:SetString( 6, ' ' )
		oQueryC:SetString( 7, FwxFilial( 'SD2' ) )
		oQueryC:SetString( 8, jParams['MV_PAR02'][1] )
		oQueryC:SetString( 9, jParams['MV_PAR03'][1] )
		oQueryC:SetString( 10, DtoS( FwDateTimeToLocal( jParams['MV_PAR10'][1] )[1] ) )
		oQueryC:SetString( 11, DtoS( FwDateTimeToLocal( jParams['MV_PAR11'][1] )[1] ) )
		oQueryC:SetString( 12, jParams['MV_PAR04'][1] )
		oQueryC:SetString( 13, jParams['MV_PAR06'][1] )
		oQueryC:SetString( 14, jParams['MV_PAR05'][1] )
		oQueryC:SetString( 15, jParams['MV_PAR07'][1] )
		oQueryC:SetString( 16, jParams['MV_PAR08'][1] )
		oQueryC:SetString( 17, jParams['MV_PAR09'][1] )
		oQueryC:SetString( 18, '50' )
		oQueryC:SetString( 19, ' ' )

		// cria alias
		oQueryC:OpenAlias(cAliasC)

		// Alimenta o objeto de dados da classe para retornar ao SmartView
		DbSelectArea( cAliasC )
		While !( cAliasC )->( EOF( ) )
			jItems := JsonObject():new()

			If !( cAliasC )->( EOF( ) )
				nTOTDoc := calcTotDoc( 2,, cAliasC, cFilSB1 )
			EndIf

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SC5.C5_FILIAL, SC5.C5_NOTA, SC5.C5_EMISSAO, SC5.C5_CATPV||' '||AGR.AGR_DESCRI C5_CATPV, SC5.C5_NUM, SC5.C5_CLIENTE, SC5.C5_LOJACLI, SC5.C5_MOEDA, SC5.C5_TXMOEDA, SA1.A1_NOME, SA1.A1_RISCO, SC6.C6_ITEM, SC6.C6_PRODUTO, SB1.B1_DESC, SC6.C6_UM, SB1.B1_GRUPO||' '||SBM.BM_DESC B1_GRUPO, SB1.B1_PESO, SC6.C6_QTDVEN, SC6.C6_VALOR, SC6.C6_ENTREG "
			cQuery += "FROM " + RetSQLName( 'SC5' ) + " SC5 "
			cQuery += "INNER JOIN " + RetSQLName( 'SC6' ) + " SC6 "
			cQuery += "   ON SC6.C6_FILIAL = ? "
			cQuery += "      AND SC6.C6_NUM = SC5.C5_NUM "
			cQuery += "      AND SC6.C6_CLI = SC5.C5_CLIENTE "
			cQuery += "      AND SC6.C6_ITEM = ? "
			cQuery += "      AND SC6.D_E_L_E_T_ = ? "
			cQuery += "INNER JOIN " + RetSQLName( 'SA1' ) + " SA1 "
			cQuery += "   ON SA1.A1_FILIAL = ? "
			cQuery += "      AND SA1.A1_COD = SC5.C5_CLIENTE "
			cQuery += "      AND SA1.A1_LOJA = SC5.C5_LOJACLI "
			cQuery += "      AND SA1.D_E_L_E_T_ = ? "
			cQuery += "INNER JOIN " + RetSQLName( 'SB1' ) + " SB1 "
			cQuery += "   ON SB1.B1_FILIAL = ? "
			cQuery += "      AND SB1.B1_COD = SC6.C6_PRODUTO "
			cQuery += "      AND SB1.D_E_L_E_T_ = ? "
			cQuery += "LEFT JOIN " + RetSQLName( 'AGR' ) + " AGR "
			cQuery += "   ON AGR.AGR_FILIAL = ? "
			cQuery += "      AND AGR.AGR_COD = SC5.C5_CATPV "
			cQuery += "      AND AGR.D_E_L_E_T_ = ? "
			cQuery += "LEFT JOIN " + RetSQLName( 'SBM' ) + " SBM "
			cQuery += "   ON SBM.BM_FILIAL = ? "
			cQuery += "      AND SBM.BM_GRUPO = SB1.B1_GRUPO "
			cQuery += "      AND SBM.D_E_L_E_T_ = ? "
			cQuery += "WHERE SC5.C5_FILIAL = ? "
			cQuery += "   AND SC5.C5_NUM = ? "
			cQuery += "   AND SC5.C5_CLIENTE = ? "
			cQuery += "   AND SC5.C5_LOJACLI = ? "
			cQuery += "   AND SC5.D_E_L_E_T_ = ? "

			// Agrega os filtros do SMARTVIEW na QUERY
			For nX := 1 To Len( aFiltro )
				cQuery += "AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
			Next

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			cQuery := ChangeQuery( cQuery )

			oQueryA := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryA:SetQuery( cQuery )

			oQueryA:SetString( 1, FwxFilial( 'SC6' ) )
			oQueryA:SetString( 2, ( cAliasC )->D2_ITEMPV )
			oQueryA:SetString( 3, ' ' )
			oQueryA:SetString( 4, FwxFilial( 'SA1' ) )
			oQueryA:SetString( 5, ' ' )
			oQueryA:SetString( 6, FwxFilial( 'SB1' ) )
			oQueryA:SetString( 7, ' ' )
			oQueryA:SetString( 8, FwxFilial( 'AGR' ) )
			oQueryA:SetString( 9, ' ' )
			oQueryA:SetString( 10, FwxFilial( 'SBM' ) )
			oQueryA:SetString( 11, ' ' )
			oQueryA:SetString( 12, FwxFilial( 'SC5' ) )
			oQueryA:SetString( 13, ( cAliasC )->D2_PEDIDO )
			oQueryA:SetString( 14, ( cAliasC )->D2_CLIENTE )
			oQueryA:SetString( 15, ( cAliasC )->D2_LOJA )
			oQueryA:SetString( 16, ' ' )

			// cria alias
			oQueryA:OpenAlias( cAliasA )

			If !( cAliasA )->( EOF( ) )
				aStatusPed := getStatus( cAliasA )

				nTOTPed := calcTotDoc( 1, cAliasA,, cFilSB1 )
				nTOTPes1 := calcTotDoc( 3, cAliasA,, cFilSB1 )
				nTOTPes2 := calcTotDoc( 4, cAliasA,, cFilSB1 )
			EndIf

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT SD21.D2_FILIAL, SD21.D2_EMISSAO, SD21.D2_DOC D2_REMITO, SD21.D2_SERIE, SD21.D2_ITEM, SD21.D2_QUANT "
			cQuery += "FROM " + RetSQLName( 'SD2' ) + " SD21 "
			cQuery += "WHERE SD21.D2_FILIAL = ? "
			cQuery += "   AND SD21.D2_DOC = ? "
			cQuery += "   AND SD21.D2_SERIE = ? "
			cQuery += "   AND SD21.D2_ITEM = ? "
			cQuery += "   AND SD21.D2_CLIENTE = ? "
			cQuery += "   AND SD21.D2_LOJA = ? "
			cQuery += "   AND SD21.D2_TIPODOC >= ? "
			cQuery += "   AND SD21.D_E_L_E_T_ = ? "

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			cQuery := ChangeQuery( cQuery )

			oQueryB := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryB:SetQuery( cQuery )

			oQueryB:SetString( 1, cFilSD2 )
			oQueryB:SetString( 2, ( cAliasC )->D2_REMITO )
			oQueryB:SetString( 3, ( cAliasC )->D2_SERIREM )
			oQueryB:SetString( 4, ( cAliasC )->D2_ITEMREM )
			oQueryB:SetString( 5, ( cAliasC )->D2_CLIENTE )
			oQueryB:SetString( 6, ( cAliasC )->D2_LOJA )
			oQueryB:SetString( 7, '50' )
			oQueryB:SetString( 8, ' ' )

			// cria alias
			oQueryB:OpenAlias( cAliasB )

			// Alimenta o objeto de dados da classe para retornar ao SmartView
			For nX := 1 To Len( self:aStruct )
				If ( AllTrim( self:aStruct[nx][5] ) $ 'C5_EMISSAO|C5_CATPV|C5_NUM|C5_CLIENTE|C5_LOJACLI|A1_NOME|C6_ITEM|C6_PRODUTO|B1_DESC|C6_UM|B1_GRUPO|C6_QTDVEN|C5_TOTPES1|C5_TOTPES2|C5_MOEDA|C5_DESMOE|C5_TXMOEDA|C5_TAXADIA|C6_VALOR|C5_TOTPED|C5_TOTCON1|C5_TOTCON2|C6_ENTREG|C5_STATUS|C5_DETALHE' )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'C5_DESMOE' )
						// Moneda Orden
						nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAliasA )->C5_MOEDA ) ) } )
						cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
						jItems[self:aStruct[nX][1]] := cDescMon
					ElseIf ( self:aStruct[nx][5] == 'C5_TAXADIA' )
						jItems[self:aStruct[nX][1]] := nTxMoeConv
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTPED' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPed, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTCON1' )
						nTOTCon1 := Round( xMoeda( nTOTPed, ( cAliasA )->C5_MOEDA, nMoeda, dDataBase, nDecs, ( cAliasA )->C5_TXMOEDA, 1, ), nDecs )
						jItems[self:aStruct[nX][1]] := nTOTCon1
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTCON2' )
						jItems[self:aStruct[nX][1]] := IIF(nTxMoeConv > 0,Round( xMoeda( nTOTCon1, 1, nParMoe, dDataBase,,,, ), nDecs ),0)
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTPES1' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPes1, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'C5_TOTPES2' )
						jItems[self:aStruct[nX][1]] := Round( nTOTPes2, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'C5_STATUS' )
						jItems[self:aStruct[nX][1]] := aStatusPed[1]
					ElseIf ( self:aStruct[nx][5] == 'C5_DETALHE' )
						jItems[self:aStruct[nX][1]] := aStatusPed[2]
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D2_EMISSAO|D2_REMITO|D2_SERIE|D2_ITEM|D2_QUANT' )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) $ 'D2_EMISS_1|D2_DOC|D2_SERIE_1|D2_ITEM_1|D2_QUANT_1|F2_MOEDA|F2_DESMOE|F2_TXMOEDA|F2_TAXADIA|D2_TOTAL|D2_TOTDOC|D2_TOTCON1|D2_TOTCON2' )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasC )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasC )->&( self:aStruct[nX][5] ) ) )
					ElseIf ( self:aStruct[nx][5] == 'F2_DESMOE' )
						// Moneda Factura
						nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAliasC )->F2_MOEDA ) ) } )
						cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
						jItems[self:aStruct[nX][1]] := cDescMon
					ElseIf ( self:aStruct[nx][5] == 'F2_TAXADIA' )
						jItems[self:aStruct[nX][1]] := nTxMoeConv
					ElseIf ( self:aStruct[nx][5] == 'D2_TOTDOC' )
						jItems[self:aStruct[nX][1]] := Round( nTOTDoc, nDecs )
					ElseIf ( self:aStruct[nx][5] == 'D2_TOTCON1' )
						nTOTCon1 := Round( xMoeda( nTOTDoc, ( cAliasC )->F2_MOEDA, nMoeda, dDataBase, nDecs, ( cAliasC )->F2_TXMOEDA, 1, ), nDecs )
						jItems[self:aStruct[nX][1]] := nTOTCon1
					ElseIf ( self:aStruct[nx][5] == 'D2_TOTCON2' )
						jItems[self:aStruct[nX][1]] := IIF(nTxMoeConv > 0,Round( xMoeda( nTOTCon1, 1, nParMoe, dDataBase,,,, ), nDecs ),0)
					Else
						jItems[self:aStruct[nX][1]] := ( cAliasC )->&( self:aStruct[nX][5] )
					EndIf
				ElseIf ( AllTrim( self:aStruct[nx][5] ) == 'C5_FILIAL' )
					jItems[self:aStruct[nX][1]] := IIF(!Empty( ( cAliasA )->C5_FILIAL ),( cAliasA )->C5_FILIAL,IIF(!Empty( ( cAliasB )->D2_FILIAL ),( cAliasB )->D2_FILIAL,IIF(!Empty( ( cAliasC )->D2_FILIAL ),( cAliasC )->D2_FILIAL,"")))
				EndIf
			Next

			// Inclui os dados no objeto paea retorno ao SmartView
			self:oData:appendData( jItems )

			( cAliasA )->( DbCloseArea( ) )
			( cAliasB )->( DbCloseArea( ) )
			( cAliasC )->( DbSkip( ) )

			nTOTCon1 := 0
			nTOTPed := 0
			nTOTDoc := 0
			nTOTPes1 := 0
			nTOTPes2 := 0
		End
		( cAliasC )->( DbCloseArea( ) )
	EndIf

	// fecha objeto
	If oQueryA <> Nil
		oQueryA:Destroy()
		oQueryA := NIL
		FwFreeObj(oQueryA)
	EndIf
	If oQueryB <> Nil
		oQueryB:Destroy()
		oQueryB := NIL
		FwFreeObj(oQueryB)
	EndIf
	If oQueryC <> Nil
		oQueryC:Destroy()
		oQueryC := NIL
		FwFreeObj(oQueryC)
	EndIf

Return( self:oData )

//-------------------------------------------------------------------------------
/*{Protheus.doc} getStatus
@description Rotina para retornar o status do pedido de venda
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
Static Function getStatus( cAliasA )

	Local cStatus as character
	Local cDetalhe as character
	Local cQuery as character
	Local cAliasD as character
	Local oQueryE as object

	Local aRet as array

	cStatus := ''
	cDetalhe := ''
	cQuery := ''
	cAliasD := GetNextAlias( )

	aRet := { }

	If !Empty( cAliasA )
		cQuery := "SELECT SC9.C9_REMITO, SC9.C9_NFISCAL, SC9.C9_BLCRED, SC9.C9_BLEST "
		cQuery += "FROM " + RetSQlName( 'SC9' ) + " SC9 "
		cQuery += "WHERE SC9.C9_FILIAL = ? "
		cQuery += "   AND SC9.C9_PEDIDO = ? "
		cQuery += "   AND SC9.C9_ITEM = ? "
		cQuery += "   AND SC9.C9_CLIENTE = ? "
		cQuery += "   AND SC9.C9_LOJA = ? "
		cQuery += "   AND SC9.D_E_L_E_T_ = ? "

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		cQuery := ChangeQuery( cQuery )

		oQueryE := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQueryE:SetQuery( cQuery )

		oQueryE:SetString( 1, ( cAliasA )->C5_FILIAL )
		oQueryE:SetString( 2, ( cAliasA )->C5_NUM )
		oQueryE:SetString( 3, ( cAliasA )->C6_ITEM )
		oQueryE:SetString( 4, ( cAliasA )->C5_CLIENTE )
		oQueryE:SetString( 5, ( cAliasA )->C5_LOJACLI )
		oQueryE:SetString( 6, ' ' )

		// cria alias
		oQueryE:OpenAlias( cAliasD )

		If !( cAliasD )->( EOF( ) )
			If ( ( cAliasD )->C9_BLCRED == "09" )
				cEstatus := STR0035 // "Rechazado"
				If ( ( cAliasA )->A1_RISCO == "E" )
					cDetalhe := STR0036 // "MANUAL"
				Else
					cDetalhe := STR0037 //"Excede el límite de crédito"
				EndIf
			ElseIf ( !Empty( ( cAliasD )->C9_BLCRED ) .And. ( ( cAliasD )->C9_BLCRED != "10" ) ) .And. ( ( cAliasA )->A1_RISCO != "E" )
				cEstatus := STR0038 // "Análise"
				cDetalhe := STR0037 // "Excede el límite de crédito"
			ElseIf ( !Empty( ( cAliasD )->C9_BLCRED ) .And. ( ( cAliasD )->C9_BLCRED != "10" ) ) .And. ( ( cAliasA )->A1_RISCO == "E" )
				cEstatus := STR0036 // "MANUAL"
				cDetalhe := STR0040 // "Bloquear para análisis"
			ElseIf ( ( cAliasD )->C9_BLCRED == "10" )
				If !Empty( ( cAliasD )->C9_NFISCAL )
					cStatus := STR0041 // "Facturado"
				ElseIf !Empty( ( cAliasD )->C9_REMITO )
					cEstatus := STR0042 // "Facturacion"
				EndIf
				If ( ( cAliasA )->A1_RISCO == "A" )
					cDetalhe := STR0043 // "Autorizar siempre"
				ElseIf ( ( cAliasA )->A1_RISCO == "E" )
					cDetalhe := STR0036 // "MANUAL"
				Else
					cDetalhe := STR0044 // "Riesgo no definido"
				EndIf
				// Control de status "Despacho"
			ElseIf Empty( ( cAliasD )->C9_BLCRED ) .And. Empty( ( cAliasD )->C9_BLEST )
				If Empty( ( cAliasD )->C9_REMITO ) .And. Empty( ( cAliasD )->C9_NFISCAL )
					cStatus := STR0045 // "Aprobado"
				ElseIf !Empty( ( cAliasD )->C9_NFISCAL )
					cStatus := STR0042 // "Facturacion"
				ElseIf !Empty( ( cAliasD )->C9_REMITO )
					cStatus := STR0046 // "Remitido"
				EndIf

				If ( ( cAliasA )->A1_RISCO == "A" )
					cDetalhe := STR0043 // "Autorizar siempre"
				ElseIf ( ( cAliasA )->A1_RISCO == "E" )
					cDetalhe := STR0036 // "MANUAL"
				Else
					cDetalhe := STR0044 // "Riesgo no definido"
				EndIf
			ElseIf Empty( ( cAliasD )->C9_BLCRED ) .And. !Empty( ( cAliasD )->C9_BLEST )
				cStatus := STR0047 // "Bloqueado por Estoque"
				If ( ( cAliasA )->A1_RISCO == "A" )
					cDetalhe := STR0043 // "Autorizar siempre"
				ElseIf ( ( cAliasA )->A1_RISCO == "E" )
					cDetalhe := STR0036 // "MANUAL"
				Else
					cDetalhe := STR0044 // "Riesgo no definido"
				EndIf
			EndIf
			// Não existe na SC9
		Else
			If Empty( ( cAliasA )->C5_NOTA )
				cStatus	:= STR0048 // "En cartera"
				cDetalhe := STR0049 // "Orden en cartera"
			Else
				cStatus	:= STR0050 // "Residuo"
				cDetalhe := STR0051 // "Orden 100% Eliminado por residuo"
			EndIf
		EndIf

		aAdd( aRet, cStatus )
		aAdd( aRet, cDetalhe )

		( cAliasD )->( DbCloseArea( ) )
	EndIf

	If ( oQueryE != Nil )
		oQueryE:Destroy( )
		oQueryE := Nil
		FwFreeObj( oQueryE )
	EndIf

Return( aRet )

//-------------------------------------------------------------------------------
/*{Protheus.doc} calcTotDoc
@description Rotina para retornar o $ total do documento ou o peso total
@author Leonardo Pereira
@since 27/09/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
Static Function calcTotDoc( nTipoDoc, cAliasA, cAliasC, cFilSB1 )

	Local nRet as numeric
	Local cQuery as character
	Local cAliasE as character
	Local oQueryF as object

	Default nTipoDoc := 0
	Default cFilSB1 := ''

	nRet := 0
	cQuery := ''
	cAliasE := GetNextAlias( )

	If ( nTipoDoc == 1 ) .And. !Empty( cAliasA )
		cQuery := "SELECT SUM( SC6.C6_VALOR) TOTAL "
		cQuery += "FROM " + RetSQlName( 'SC6' ) + " SC6 "
		cQuery += "WHERE SC6.C6_FILIAL = ? "
		cQuery += "   AND SC6.C6_NUM = ? "
		cQuery += "   AND SC6.C6_CLI = ? "
		cQuery += "   AND SC6.C6_LOJA = ? "
		cQuery += "   AND SC6.D_E_L_E_T_ = ? "
	ElseIf ( nTipoDoc == 2 ) .And. !Empty( cAliasC )
		If !Empty( ( cAliasC )->D2_DOC )
			cQuery := "SELECT SUM( SD2.D2_TOTAL) TOTAL "
			cQuery += "FROM " + RetSQlName( 'SD2' ) + " SD2 "
			cQuery += "WHERE SD2.D2_FILIAL = ? "
			cQuery += "   AND SD2.D2_DOC = ? "
			cQuery += "   AND SD2.D2_SERIE = ? "
			cQuery += "   AND SD2.D_E_L_E_T_ = ? "
		EndIf
	ElseIf ( ( nTipoDoc == 3 ) .Or. ( nTipoDoc == 4 ) ) .And. !Empty( cAliasA )
		cQuery := "SELECT SUM(SB1.B1_PESO * SC6.C6_QTDVEN) TOTAL "
		cQuery += "FROM " + RetSQlName( 'SB1' ) + " SB1 "
		cQuery += "INNER JOIN " + RetSQlName( 'SC6' ) + " SC6 "
		cQuery += "   ON SC6.C6_FILIAL = ? "
		cQuery += "      AND SC6.C6_NUM = ? "
		cQuery += "      AND SC6.C6_CLI = ? "
		cQuery += "      AND SC6.C6_LOJA = ? "
		If ( nTipoDoc == 3 )
			cQuery += "      AND SC6.C6_ITEM = ? "
		EndIf
		cQuery += "      AND SC6.D_E_L_E_T_ = ? "
		cQuery += "WHERE SB1.B1_FILIAL = ? "
		cQuery += "   AND SB1.B1_COD = SC6.C6_PRODUTO "
		cQuery += "   AND SB1.D_E_L_E_T_ = ? "
	EndIf

	If !Empty( cQuery )
		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		cQuery := ChangeQuery( cQuery )

		oQueryF := FwExecStatement():New()

		//Define a consulta e os parâmetros
		oQueryF:SetQuery( cQuery )

		If ( nTipoDoc == 1 ) .And. !Empty( cAliasA )
			oQueryF:SetString( 1, ( cAliasA )->C5_FILIAL )
			oQueryF:SetString( 2, ( cAliasA )->C5_NUM )
			oQueryF:SetString( 3, ( cAliasA )->C5_CLIENTE )
			oQueryF:SetString( 4, ( cAliasA )->C5_LOJACLI )
			oQueryF:SetString( 5, ' ' )
		ElseIf ( nTipoDoc == 2 ) .And. !Empty( cAliasC )
			If !Empty( ( cAliasC )->D2_DOC )
				oQueryF:SetString( 1, ( cAliasC )->D2_FILIAL )
				oQueryF:SetString( 2, ( cAliasC )->D2_DOC )
				oQueryF:SetString( 3, ( cAliasC )->D2_SERIE_1 )
				oQueryF:SetString( 4, ' ' )
			EndIf
		ElseIf ( ( nTipoDoc == 3 ) .Or. ( nTipoDoc == 4 ) ) .And. !Empty( cAliasA )
			oQueryF:SetString( 1, ( cAliasA )->C5_FILIAL )
			oQueryF:SetString( 2, ( cAliasA )->C5_NUM )
			oQueryF:SetString( 3, ( cAliasA )->C5_CLIENTE )
			oQueryF:SetString( 4, ( cAliasA )->C5_LOJACLI )
			If ( nTipoDoc == 3 )
				oQueryF:SetString( 5, ( cAliasA )->C6_ITEM )
				oQueryF:SetString( 6, ' ' )
				oQueryF:SetString( 7, cFilSB1 )
				oQueryF:SetString( 8, ' ' )
			Else
				oQueryF:SetString( 5, ' ' )
				oQueryF:SetString( 6, cFilSB1 )
				oQueryF:SetString( 7, ' ' )
			EndIf
		EndIf

		// cria alias
		oQueryF:OpenAlias( cAliasE )

		If !( cAliasE )->( EOF( ) )
			nRet := ( cAliasE )->TOTAL
		EndIf
		( cAliasE )->( DbCloseArea( ) )
	EndIf

	If ( oQueryF != Nil )
		oQueryF:Destroy( )
		oQueryF := Nil
		FwFreeObj( oQueryF )
	EndIf

Return( nRet )
