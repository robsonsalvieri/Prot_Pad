#include "tlpp-object.th"
#INCLUDE 'FWMVCDEF.CH'
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWBROWSE.CH"
#INCLUDE "MODXFUN.CH"

static oModFunc := Nil
Static oModPE   := Nil

/*/{Protheus.doc} LxSelecMod
Selección del modelo de acuerdo al número de documento
@author 	raul.medina
@return		cName - nombre del modelo para el numero de documento
@since 		03/2023
@version	12.1.2210 / Superior
Parametros
    nNumDoc - numerico - número del documento.
/*/
Function LxSelecMod(nNumDoc as numeric)
Local oJsonMod          As json
Local cName             As character

Default nNumDoc     := 0

    oJsonMod := RetModJson()
    If oJsonMod:HasProperty(AllTrim(STR(nNumDoc)))
        cName := oJsonMod[AllTrim(STR(nNumDoc))]
    EndIf    

Return cName

/*/{Protheus.doc} LoadMdData
Función utilizada para realizar la carga de los datos al model seleccionado.
@author 	raul.medina
@since 		03/2023
@version	12.1.2210 / Superior
Parametros
    nNumDoc - numerico - número del documento.
    aCabHead - array - Campos del encabezado
    aCab - array - Datos del encabezado
    aColsHead - array - Campos de los items
    aCols - array - Datos de los items.
    cEspecie - caracter - Especie del documento.
    nBaseDup - numerico -  monto de la base de los titulos
    cPais -  caracter - país para el cual está siendo realizado el proceso
    aDup - array - Arreglo con las informaciones de los títulos
    lAuto - logico - indica si el proceso está siendo realizado por rutina automatica
@Return 
    oModel - object - Modelo con los datos recibos.
/*/
Function LoadMdData(nNumDoc as numeric, aCabHead as array, aCab as array, aColsHead as array, aCols as array, cEspecie as character, nBaseDup as numeric, cPais as character, aDup As array, lAuto As logical, nMoedaFin as numeric, cNatureza as character)
Local oModel        := Nil
Local cModel        := ""
Local cModelHd      := ""
Local cModelIt      := ""
Local oCampos	    := Nil
Local oStruCab      := Nil
Local cCpoMoeFin    := ""
Local cCpoNatFin    := ""

Default nNumDoc     := 0
Default aCabHead    := {}
Default aCab        := {}
Default aColsHead   := {}
Default aCols       := {}
Default cEspecie    := ""
Default nBaseDup    := 0
Default cPais       := ""
Default aDup        := {}
Default lAuto       := .F.
Default nMoedaFin   := Iif(Type("nMoedaCor") == "N", nMoedaCor, 1)
Default cNatureza   := ""


    //Obetención del modelo para el documento recibido.
    cModel := LxSelecMod(nNumDoc)
    //Carga del modelo.
    oModel := FwLoadModel(cModel)

    If oModel:GetId() == "LOCXIN"
        cModelHd      := "SF1_MASTER"
        cModelIt      := "SD1_DETAIL"
        cCpoMoeFin    := "F1_MOEFIN"
        cCpoNatFin    := "F1_NATFIN"
        oCampos := InputFields(cPais,.T., .F., .F., .T., .F., .F., cEspecie)
    Else
        cModelHd      := "SF2_MASTER"
        cModelIt      := "SD2_DETAIL"
        oCampos := OutputFields(cPais,.T., .F., .T., .T., .F., .F., cEspecie)
        cCpoMoeFin    := "F2_MOEFIN"
    EndIf

	oStruCab := oModel:GetModel(cModelHd):GetStruct()
    
    oCampos:SetModel(oStruCab)
    oCampos:AddModelProperties(nNumDoc)
    oStruCab := oCampos:getModel()
    
    oModel:GetModel(cModelHd):GetStruct() := oStruCab

    //Se retiran listas de combos para recibir los valores provenientes de los documentos fiscales.
    oModel:GetModel(cModelHd):GetStruct():SetProperty( '*'  , MODEL_FIELD_VALUES  , {})
    oModel:GetModel(cModelIt):GetStruct():SetProperty( '*'  , MODEL_FIELD_VALUES  , {})
    //Se retiran los obligatorios de los campos en encabezado y items por las validaciones.
    oModel:GetModel(cModelHd):GetStruct():SetProperty( '*'  , MODEL_FIELD_OBRIGAT , .F.)
    oModel:GetModel(cModelIt):GetStruct():SetProperty( '*'  , MODEL_FIELD_OBRIGAT , .F.)

    oModel:SetOperation(MODEL_OPERATION_INSERT)
	oModel:Activate()


    //Llenado del encabezado del documento.
    MdFillSub(@oModel, cModelHd ,aCabHead, aCab)
    oModel:GetModel(cModelHd):LoadValue("BASEDUP", nBaseDup)
    If oModel:GetModel(cModelHd):HasField("AUTO")
        oModel:GetModel(cModelHd):LoadValue("AUTO", lAuto)
    EndIf
    If oModel:GetModel(cModelHd):HasField(cCpoMoeFin)
        oModel:GetModel(cModelHd):LoadValue(cCpoMoeFin, nMoedaFin)
    EndIf
    If oModel:GetModel(cModelHd):HasField(cCpoNatFin)
        oModel:GetModel(cModelHd):LoadValue(cCpoNatFin, cNatureza)
    EndIf
    //Llenado de los items.
    MdFillItems(@oModel, cModelIt, aColsHead, aCols)
    //Llenado de duplicatas
    MdFillDup(@oModel, "DUP_DETAIL" ,{"DUP"}, aDup)

Return oModel

/*/{Protheus.doc} vldModel
Función utilizada para realizar las validaciones de los datos del model recibido.
@author 	raul.medina
@since 		04/2023
@version	12.1.2210 / Superior
Parametros
    oModel - object - Modelo con los datos recibos.
@Return 
    lRet - logico - retorno de las validaciones
/*/
Function vldModel(oModel)
Local lRet      := .T.  as logical
Local aError    := {}   as array

Default oModel  := NIL

    If !oModel:VldData()
        aError := oModel:GetErrorMessage()
        Help(" ", 1, aError[5], , aError[6], 2, 0,,,,,, {aError[7]})
        lRet := .F.
    EndIf

Return lRet

/*/{Protheus.doc} vlLndModel
Función utilizada para realizar las validaciones de línea del modelo.
@author 	raul.medina
@since 		04/2023
@version	12.1.2210 / Superior
Parametros
    oModel - object - Modelo con los datos recibos.
    aHeader - array - Campos del submodelo
    aColsAux - array - arrar correspondiente a aAux
    aColsOri- array - arrar correspondiente a aCols
    nItem - numerico - item que está siendo procesado
    laCols - logico - indica si debe ser realizada la actualización de datos en el acols.
@Return 
    lRet - logico - retorno de las validaciones
/*/
Function VldModLn(oModel, aHeader, aColsAux, aColsOri, nItem, laCols)
Local lRet      := .T.  as logical
Local aError    := {}   as array
Local cSubModel := ""   as character

Default oModel      := NIL
Default aHeader     := {}
Default aColsAux    := {}
Default aColsOri    := {}
Default nItem       := 1
Default laCols      := .F.

    cSubModel := Iif(oModel:GetId() == "LOCXIN", "SD1_DETAIL", "SD2_DETAIL")

    If !oModel:GetModel(cSubModel):VldLineData() //Validacion de linea
        aError := oModel:GetErrorMessage()
        Help(" ", 1, aError[5], , aError[6], 2, 0,,,,,, {aError[7]})
        lRet := .F.
    EndIf

    If laCols
        ModToaCols(oModel, cSubModel, aHeader, @aColsAux, @aColsOri, nItem)
    EndIf

Return lRet

/*/{Protheus.doc} MdFillSub
Función utilizada para realizar la carga de los datos al submodelo recibido en la función
@author 	raul.medina
@since 		03/2023
@version	12.1.2210 / Superior
Parametros
    oModel - object - modelo utilizado para la actualización de datos
    cModel - caracter - nombre del submodelo que será actualizado
    aHead - array - Campos del submodelo
    aData - array - Datos del submodelo
/*/
Function MdFillSub(oModel, cModel as character, aHead as array, aData as array)
Local nX        := 0
Local oStruct   := NIL
Local xValue    := ""
Local cField    := ""

Default cModel      := ""
Default aHead       := {}
Default aData       := {}

    oStruct := oModel:GetModel(cModel):GetStruct()
    For nX := 1 to Len(aHead)
        cField := AllTrim(aHead[nX])
        If oModel:GetModel(cModel):HasField(cField) .and. !Empty(aData[nX])
            xValue := TypeData(oStruct, cField, aData[nX])
            oModel:GetModel(cModel):LoadValue(cField, xValue)
        EndIf
    Next

Return

/*/{Protheus.doc} MdFillItems
Función utilizada para realizar la carga de los datos al submodelo cuando se tiene un arreglo con varios items.
@author 	raul.medina
@since 		03/2023
@version	12.1.2210 / Superior
Parametros
    oModel - object - modelo utilizado para la actualización de datos
    cModelIt - caracter - nombre del submodelo que será actualizado
    aColsHead - array - Campos del submodelo
    aCols - array - con los items del submodelo
/*/
Function MdFillItems(oModel, cModelIt as character, aColsHead as array, aCols As array)
Local nX        := 0
Local nPosDel   := 0
Local nItem     := 0

Default cModelIt    := ""
Default aColsHead   := {}
Default aCols       := {}

    nPosDel := Len(aColsHead) + 1
    For nX := 1 to Len(aCols)
        If !aCols[nX][nPosDel]
            nItem += 1
            If nItem > 1
                oModel:GetModel(cModelIt):AddLine()
            EndIf
            MdFillSub(@oModel, cModelIt, aColsHead, aCols[nX])
        EndIf
    Next

Return

/*/{Protheus.doc} MdFillDup
Función utilizada para realizar la carga de los datos al submodelo para los titulos.
@author 	raul.medina
@since 		04/2023
@version	12.1.2210 / Superior
Parametros
    oModel - object - modelo utilizado para la actualización de datos
    cModelIt - caracter - nombre del submodelo que será actualizado
    aColsHead - array - Campos del submodelo
    aCols - array - con los items del submodelo
/*/
Function MdFillDup(oModel, cModelIt as character, aColsHead as array, aCols As array)
Local nX        :=  0

Default cModelIt    := ""
Default aColsHead   := {}
Default aCols       := {}

    For nX := 1 to Len(aCols)
        If nX > 1
            oModel:GetModel(cModelIt):AddLine()
        EndIf
        MdFillSub(@oModel, cModelIt, aColsHead, {aCols[nX]})
    Next

Return

/*/{Protheus.doc} MdFillNat
Función utilizada para realizar la carga de los datos al submodelo para las multinaturalezas.
@author 	raul.medina
@since 		04/2023
@version	12.1.2210 / Superior
Parametros
    oModel - object - modelo utilizado para la actualización de datos
    cModelIt - caracter - nombre del submodelo que será actualizado
    aColsHead - array - Campos del submodelo
    aCols - array - con los items del submodelo
/*/
Function MdFillNat(oModel, cModelIt as character, aColsHead as array, aCols As array)
Local nX        :=  0
Local aSEVAux   := {}
Local nPosDel   := 0

Default cModelIt    := ""
Default aColsHead   := {}
Default aCols       := {}

    For nX := 1 to Len(aColsHead)
        aAdd(aSEVAux, aColsHead[nX][2])
    Next

    nPosDel := Len(aSEVAux) + 1
    For nX := 1 to Len(aCols)
        If !aCols[nX][nPosDel]
            If nX > 1
                oModel:GetModel(cModelIt):AddLine()
            EndIf
            MdFillSub(@oModel, cModelIt, aSEVAux, aCols[nX])
        EndIf
    Next

Return

/*/{Protheus.doc} MdFillAFN
Función utilizada para realizar la carga de los datos al submodelo para las multinaturalezas.
@author 	raul.medina
@since 		06/2023
@version	12.1.2210 / Superior
Parametros
    oModel - object - modelo utilizado para la actualización de datos
    cModelIt - caracter - nombre del submodelo que será actualizado
    aColsHead - array - Campos del submodelo
    aColsAFN - array - con los items del submodelo
    aColItems- array - items del documento
/*/
Function MdFillAFN(oModel, cModelIt as character, aColsHead as array, aColsAFN As array, aColItems As Array)
Local nX        :=  0
Local nY        :=  0
Local nZ        :=  0
Local nI        :=  0
Local nReg      :=  0
Local nPosAFN   :=  0
Local oStruct   := NIL
Local xValue    := ""
Local cField    := ""

Default cModelIt    := ""
Default aColsHead   := {}
Default aColsAFN    := {}
Default aColItems   := {}

    If IntePms() .and. Len(aColsAFN) > 0 .and. oModel:GetId() == "LOCXIN"
        If !Empty(aColItems) //Elimina la información de los items borrados, solamente se realiza al confirmar el documento.
            For nI := 1 To Len(aColItems)
                If aColItems[nI][Len(aColItems[nI])] // Item Deletado
                    nPosAFN  := Ascan(aColsAFN,{|x|x[1]==(StrZero(nI,4))})
                    If nPosAFN >  0
                        aDel( aColsAFN, nPosAFN )
                        aSize( aColsAFN, Len(aColsAFN)-1)
                    Endif
                Endif
            Next nI
        EndIf
        
        //Si no se tiene la información del encabezado de AFN se obtiene.
        If Empty(aColsHead) 
            aColsHead := GetaHeader("AFN",,,,{"AFN_QUANT"})
        EndIf 

        oStruct := oModel:GetModel(cModelIt):GetStruct()
        For nX := 1 to Len(aColsAFN) //Arreglo de los items del documento
            For nZ := 1 To Len(aColsAFN[nX][2]) //Prorrateos del item.
                nReg ++
                If nReg > 1
                    oModel:GetModel(cModelIt):AddLine()
                EndIf
                
                oModel:GetModel(cModelIt):LoadValue("AFN_ITEM", aColsAFN[nX][1])
                For nY := 1 to Len(aColsHead) //Campos del encabezado de AFN
                    cField := AllTrim(aColsHead[nY][2])
                    xValue := aColsAFN[nX][2][nZ][nY]
                    If oModel:GetModel(cModelIt):HasField(cField) .and. !Empty(xValue)
                        xValue := TypeData(oStruct, cField, xValue)
                        oModel:GetModel(cModelIt):LoadValue(cField, xValue)
                    EndIf
                Next
            Next
        Next
    EndIf

Return

/*/{Protheus.doc} MFillCaixa
Función utilizada para informar los datos de caja chica.
@author 	raul.medina
@return		
@since 		10/2023
@version	12.1.2210 / Superior
Parametros
    oModel - object - modelo utilizado para la actualización de datos
    cCxBenef - caracter - Beneficiado.
    nCxValor - numerico - Valor a ser utilizado en la caja chica.
    cCxCaixa - caracter - Codigo de caja chica.
    cCxAdian - caracter - Número de anticipo.
    cCxHistor - caracter - Historial para el movimiento de caja chica.
    cCxRendic - caracter - Numero de rendición.

/*/
Function MFillCaixa(oModel, cCxBenef as character, nCxValor as numeric, cCxCaixa as character, cCxAdian as character, cCxHistor as character, cCxRendic as character)

Default cCxBenef    := ""
Default nCxValor    := 0
Default cCxCaixa    := ""
Default cCxAdian    := ""
Default cCxHistor   := ""
Default cCxRendic   := ""

    If !Empty(cCxBenef)
        oModel:GetModel("SEU_DETAIL"):LoadValue("EU_BENEF", cCxBenef)
    EndIf
    If nCxValor > 0
        oModel:GetModel("SEU_DETAIL"):LoadValue("EU_VALOR", nCxValor)
    EndIf
    If !Empty(cCxCaixa)
        oModel:GetModel("SEU_DETAIL"):LoadValue("EU_CAIXA", cCxCaixa)
    EndIf
    If !Empty(cCxAdian)
        oModel:GetModel("SEU_DETAIL"):LoadValue("EU_NROADIA", cCxAdian)
    EndIf
    If !Empty(cCxHistor)
        oModel:GetModel("SEU_DETAIL"):LoadValue("EU_HISTOR", cCxHistor)
    EndIf
    If oModel:GetModel("SEU_DETAIL"):HasField("EU_NRREND") .and. !Empty(cCxRendic)
        oModel:GetModel("SEU_DETAIL"):LoadValue("EU_NRREND", cCxRendic)
    EndIf

Return

/*/{Protheus.doc} RetModJson
Función utilizada para realizar la carga de los datos al submodelo cuando se tiene un arreglo con varios items.
@author 	raul.medina
@return		ojson con los numeros de documentos y sus modelos.
@since 		03/2023
@version	12.1.2210 / Superior
Parametros

/*/
Function RetModJson()
Local ojson             As json

    ojson := JsonObject():new()
    //Entradas
    //Facturas
    oJson['10'] := "LOCXNFE"
    oJson['12'] := "LOCXNFE"
    oJson['13'] := "LOCXNFE"
    oJson['14'] := "LOCXNFE"
    oJson['20'] := "LOCXNFE"
    //Notas de crédito
    oJson['4'] := "LOCXNCE"
    oJson['8'] := "LOCXNCE"
    //Notas de débito
    oJson['5'] := "LOCXNDE"
    oJson['9'] := "LOCXNDE"
    oJson['23']:= "LOCXNDE"
    //Remitos
    oJson['64'] := "LOCXREN"
    oJson['53'] := "LOCXREN"
    oJson['51'] := "LOCXREN"
    oJson['60'] := "LOCXREN"
    oJson['62'] := "LOCXREN"
    oJson['63'] := "LOCXREN"

    //Salidas
    //Facturas
    oJson['1'] := "LOCXNFS"
    oJson['11'] := "LOCXNFS"
    oJson['17'] := "LOCXNFS"
    oJson['19'] := "LOCXNFS"
    oJson['21'] := "LOCXNFS"
    //Notas de crédito
    oJson['3'] := "LOCXNCS"
    oJson['7'] := "LOCXNCS"
    oJson['22']:= "LOCXNCS"
    //Notas de débito
    oJson['2'] := "LOCXNDS"
    oJson['6'] := "LOCXNDS"
    //Remitos
    oJson['61'] := "LOCXRES"
    oJson['50'] := "LOCXRES"
    oJson['52'] := "LOCXRES"
    oJson['54'] := "LOCXRES"

Return oJson

/*/{Protheus.doc} FindString
Función utilizada para generar un obteto de comparación de valores.
Si el dato está contenido dentro del arreglo retornará verdadero.
@author 	raul.medina
@return		lRet - logico - indica el dato está contenido.
@since 		03/2023
@version	12.1.2210 / Superior
Parametros
    cString - caracter - dato a ser comparado.
    aStrings - array - arreglo con los datos contenidos para comparación.
/*/
Function FindString(cString as character, aStrings as array)
Local lRet      := .F.  as logical
Local nX        := 0    as numeric
Local oJson             as json

Default cString     := ''
Default aStrings    := {}

    oJson := JsonObject():new()

    For nX := 1 To Len(aStrings)
        oJson[aStrings[nX]] := aStrings[nX]
    Next

    lRet := oJson:HasProperty(cString)

    FreeObj(oJson)

Return lRet

/*/{Protheus.doc} TypeData
Función utilizada para validar que el dato sea correcto de acuerdo al tipo de dato y tipo de campo.
@author 	raul.medina
@return		xValue -  - retorna el campo con el valor correcto.
@since 		04/2023
@version	12.1.2210 / Superior
Parametros
    oStruct - - estructura de campos de la tabla usada.
    cField - caracter - nombre del campo.
    xValue -  - valor de retorno.
/*/
Function TypeData(oStruct, cField as character, xValue as variant)
Local cTipo     := ""

Default cField  := ""
Default xValue  := ""

    cTipo := oStruct:GetProperty(cField, MODEL_FIELD_TIPO)
    If cTipo <> ValType(xValue)
        If cTipo == "C"
            xValue := AllTrim(STR(xValue))
        ElseIf cTipo == "N"
            xValue := Val(xValue)
        EndIf
    EndIf
    If cTipo == "C"
        xValue := PadR(xValue, oStruct:GetProperty(cField, MODEL_FIELD_TAMANHO))
    EndIf

Return xValue

/*/{Protheus.doc} ModUpdDoc
Función utilizada para actualizar los valores del documento en los arreglos correspondientes y variable de memoria.
@author 	raul.medina
@since 		04/2023
@version	12.1.2210 / Superior
Parametros
    oModel - - modelo utilizado para documentos de locxnf.
    aCabNotaOri - array - arreglo de valores del encabezado de documentos.
    aGetsTela - array - arreglo de valores del encabezado de documentos.
/*/
Function ModUpdDoc(oModel, aCabNotaOri as array, aGetsTela as array, aColsHead as array, aCitensOri as array)
Local cId           := oModel:GetId()
Local cSubModelF    := ""
Local cSubModelD    := ""
Local cCampoDoc     := ""
Local cModelDoc     := ""
Local cCampoTpDoc   := ""
Local nPosDoc       := 0
Local oTipodoc      := TipoDoc():New()
Local cCampoDocIt   := ""

Default aCabNotaOri := {}
Default aGetsTela   := {}
Default aColsHead   := {}
Default aCitensOri  := {}

    If cId == "LOCXIN"
        cSubModelF := "SF1_MASTER"
        cSubModelD := "SD1_DETAIL"
        cCampoDoc  := "F1_DOC"
        cCampoTpDoc:= "F1_TIPODOC"
        cCampoDocIt := "D1_DOC"
    Else
        cSubModelF := "SF2_MASTER"
        cSubModelD := "SD2_DETAIL"
        cCampoDoc  := "F2_DOC"
        cCampoTpDoc:= "F2_TIPODOC"
        cCampoDocIt := "D2_DOC"
    EndIf

    oTipoDoc:SetTipoDoc(oModel:GetModel(cSubModelF):GetValue(cCampoTpDoc))

    If oTipoDoc:UpdateNumberDoc()
        cModelDoc  := oModel:GetModel(cSubModelF):GetValue(cCampoDoc)

        If Len(aCabNotaOri) > 0
            nPosDoc := aScan(aCabNotaOri[1], {|x| AllTrim(x) == cCampoDoc})
            If nPosDoc > 0
                If !(aCabNotaOri[2][nPosDoc] == cModelDoc)
                    aCabNotaOri[2][nPosDoc] := cModelDoc
                    &("M->"+cCampoDoc) := cModelDoc

                    If Len(aCitensOri) > 0 .And. Len(aColsHead) > 0
                        nPosDoc := aScan(aColsHead, {|x| Alltrim(x) == cCampoDocIt})
                        If nPosDoc > 0
                            Aeval(aCitensOri, { |x,y| aCitensOri[y][nPosDoc] := cModelDoc })
                        EndIf
                    EndIf
                EndIf
            EndIf
        EndIf

        If Len(aGetsTela) > 0
            nPosDoc := aScan(aGetsTela, {|x| AllTrim(x[1]) == cCampoDoc})
            If nPosDoc > 0
                If !(aGetsTela[nPosDoc][2] == cModelDoc)
                    aGetsTela[nPosDoc][2] := cModelDoc
                EndIf
            EndIf
        EndIf
    EndIf

Return

/*/{Protheus.doc} ModToaCols
Función utilizada para actualizar los valores modificado en el model sobre los arreglo aAux y acols de la locxnf.
@author 	raul.medina
@since 		07/2023
@version	12.1.2210 / Superior
Parametros
    oModel - object - modelo utilizado para la actualización de datos
    cModeId - caracter - nombre del submodelo a partir del cual será actualizado
    aHeader - array - Campos del submodelo
    aColsAux - array - arrar correspondiente a aAux
    aColsOri- array - arrar correspondiente a aCols
    nItem - numerico - item que está siendo procesado
/*/
Function ModToaCols(oModel, cModeId, aHeader, aColsAux, aColsOri, nItem)
Local nX        := 0
Local oModelSD  := Nil
Local cCpoItem  := Iif(cModeId == "SD1_DETAIL", "D1_ITEM", "D2_ITEM")
Local nPosItem  := 0
Local cItem     := ""
Local cCpo      := ""
Local cTipoCpo  := ""

Default oModel      := Nil
Default cModeId     := ""
Default aHeader     := {}
Default aColsAux    := {}
Default aColsOri    := {}
Default nItem       := 1


    nPosItem := aScan(aHeader, {|x| Alltrim(x) == cCpoItem} )
    cItem   := aColsAux[nItem][nPosItem]

    oModelSD := oModel:GetModel(cModeId)

    If cItem == oModelSD:GetValue(cCpoItem) //Verificación de item procesado.
        For nX := 1 To Len(aHeader)
            cCpo := AllTrim(aHeader[nX])
            If oModelSD:IsFieldUpdated(cCpo) //Verifica si el campo fue modificado.
                xValor := oModelSD:GetValue(cCpo) //Valor del campo en el model.
                cTipoCpo := oModelSD:GetStruct():GetProperty(cCpo, MODEL_FIELD_TIPO) //Tipo de campo.
                If Iif(cTipoCpo == "C", !(AllTrim(aColsAux[nItem][nX]) == AllTrim(xValor)),!(aColsAux[nItem][nX] == xValor)) //Se verifica que el campo tenga información diferente, si no no se realiza actualización.
                    aColsAux[nItem][nX] := xValor
                    aColsOri[nItem][nX] := xValor
                EndIf
            EndIF
        Next
    EndIf

Return

/*/{Protheus.doc} GetCfgNF
	Función de generar el array aCfgNf a partir del documento obtenido a partir de FwFldGet("F1_TIPODOC").
	@type  Function
	@author raul.medina
	@since 
	@param
        cTipoDoc - caracter - numero de documento.
	@return 
		aCfgNfAux - array - Arreglo correspondiente a la información de MontaCfgNf.
	/*/
Static aCfgNfAux   := {}
Function GetCfgNF(cTipoDoc)
Local nTipoDoc	:= 0	As numeric
Local lCarga	:= .F. 	As logical

Default cTipoDoc := ""

    nTipoDoc := Iif(!Empty(cTipoDoc), Val(cTipoDoc), 0)
	If Empty(aCfgNfAux)
		lCarga := .T.
	Else
		If nTipoDoc > 0 .and. !(nTipoDoc == aCfgNfAux[1])
			lCarga := .T.
		EndIf
	EndIf
	If lCarga
		aCfgNfAux  := MontaCfgNf(nTipoDoc,{},.F.)
	EndIf

Return aCfgNfAux

/*/{Protheus.doc} CalImpxMod
	Función utilizada para realizar el calculo de impuestos desde los modelos.
	@type  Function
	@author raul.medina
	@since 
	@param
        cCliFor - caracter - Código del cliente/proveedor.
        cLoja - caracter - Loja del cliente/proveedor.
        cTipoCF - caracter - Cliente - C/Proveedor - F.
        cTipo - caracter - Tipo del documento N|B|D|C.
        cAliasProd - caracter - Alias de la tabla de productos.
        cTipoDoc - caracter - Tipo del documento .
        cEspecie - caracter - Especie del documento.
        cSerie - caracter - Serie del documento.
        nNFMoeda - numerico - Moneda del documento.
        nTxMoeda - numerico - Tasa de la moneda usada en el documento.
        aHeaderA - array - Arreglo con los campos de SD1/SD2.
        aColsA - array - Arreglo con los valores de los items del documento.
        lCalcImp - logico - Indica si realiza calculo impuestos.
        nFlete - numerico - Valor de flete del documento
        nGastos - numerico - Valor de gastos del documento
        nSeguro - numerico - valor de seguro del documento
        nDescuento - numerico - valor de descuento del documento
		dFechaIni - date - Fecha utilizada para identificar los registros vigentes en SFH, para el cálculo de impuestos.
	@return 
		ojson - JsonObject - Json con la información de totales y valores por item.
	/*/
Function CalImpxMod(cCliFor, cLoja, cTipoCF, cTipo, cAliasProd, cTipoDoc, cEspeci, cSerie, nNFMoeda, nTxMoeda, aHeaderA, aColsA, lCalcImp, nFlete, nGastos, nSeguro, nDescuento, dFechaIni)
Local ojson             As json
Local nTotDesc      := 0

Private aImpCCO		:= {}
Private aImpSFC		:= {}
Private aImpSFF		:= {}
Private aImpSFH		:= {}
Private aImpLivr	:= {}
Private aImpIB2     := {}
Private aTesMXF		:= {}
Private aHeader     := {}
Private aCols       := {}
Private nMoedaNf    := 1
Private nTaxa       := 1
Private cEspecie    := ""
Private cFunName    := "" //Declarada apenas para no generar error logs.
Private nMoedaCor   := 1
Private dDEmissao   := dDataBase

Default cCliFor     := ""
Default cLoja       := ""
Default cTipoCF     := ""
Default cTipo       := ""
Default cAliasProd  := "SB1"
Default cTipoDoc    := ""
Default cEspeci     := ""
Default cSerie      := ""
Default nNFMoeda    := 1
Default nTxMoeda    := 0
Default aHeaderA    := {}
Default aColsA      := {}
Default lCalcImp    := .F.
Default nFlete      := 0 
Default nGastos     := 0
Default nSeguro     := 0
Default nDescuento  := 0
Default dFechaIni   := dDataBase
   
     If !Empty(dFechaIni) .and. (dFechaIni != dDataBase)
        dDEmissao := dFechaIni
    EndIf
	aHeader := aClone(aHeaderA)
    aCols := aClone(aColsA)
    nMoedaNf := nNFMoeda
    nTaxa := nTxMoeda
    cEspecie := cEspeci
    nMoedaCor := nNFMoeda
    
    MaFisIni(cCliFor, cLoja, cTipoCF, cTipo, Nil, , , .F., cAliasProd, , cTipoDoc, cEspecie)

    MaFisAlt("NF_SERIENF", cSerie)
    MaFisAlt("NF_MOEDA"  , nNFMoeda)
    MaFisAlt("NF_TXMOEDA", nTxMoeda)

    MaColsToFis(aHeader, aCols, , "MT100", .F., .T., .T., , .F.)

    aEval(aCols, {|x,y| nTotDesc += Iif(!MaFisRet( y,"IT_DELETED"), MaFisRet( y,"IT_DESCONTO"), 0)})

    MaFisReprocess(2)

    If nFlete >= 0
        MaFisAlt("NF_FRETE"  , nFlete)
    EndIf
    If nGastos >= 0
        MaFisAlt("NF_DESPESA", nGastos)
    EndIf
    If nSeguro >= 0
        MaFisAlt("NF_SEGURO" , nSeguro)
    EndIf

    If nDescuento > 0 .and. nTotDesc == 0
        MaFisAlt("NF_DESCONTO" , nDescuento) 
    EndIf

    ojson := GetCalxFis(aCols, lCalcImp)
    
    MaFisSave()
    MaFisEnd()

Return ojson

/*/{Protheus.doc} UpdCposImp
	Función utilizada para realizar el la actualización los valores de impuestos.
	@type  Function
	@author raul.medina
	@since 
	@param
        lEntrada - logico - Indica el documento es de entrada para usar SF1.
        oValJson - JsonObject - Json con la información de totales y valores por item.
        oModel -  - oModel utilizado por el model que llama las funciones de calculo.
	@return 
	/*/
Function UpdCposImp(lEntrada, oValJson, oModel)
Local cFBasImp  := Iif(lEntrada, "F1_BASIMP", "F2_BASIMP")
Local cFValImp  := Iif(lEntrada, "F1_VALIMP", "F2_VALIMP")
Local cDAlqImp  := Iif(lEntrada, "D1_ALQIMP", "D2_ALQIMP")
Local cDBasImp  := Iif(lEntrada, "D1_BASIMP", "D2_BASIMP")
Local cDValImp  := Iif(lEntrada, "D1_VALIMP", "D2_VALIMP")
Local cModelCab := Iif(lEntrada, "SF1_MASTER", "SF2_MASTER")
Local cSubModel := Iif(lEntrada, "SD1_DETAIL", "SD2_DETAIL")

Default lEntrada    := .T.
Default oValJson    := JsonObject():new()

    MUpdCabImp(oValJson, cModelCab, cFBasImp, cFValImp, @oModel)
    If oValJson:HasProperty("ITEMS")
        MUpdItmImp(oValJson["ITEMS"], cSubModel, cDAlqImp, cDBasImp, cDValImp, @oModel)
    EndIf

Return

/*/{Protheus.doc} MUpdCabImp
	Función utilizada para realizar el la actualización los valores de impuestos en el encabezado (Base y Valor del impuesto) por campo libro.
	@type  Function
	@author raul.medina
	@since 
	@param
        oValJson - JsonObject - Json con la información necesaria para realizar la actualización de campos del encabezado.
        cModelCab - caracter - "SF1_MASTER", "SF2_MASTER".
        cCpoBasImp - caracter - "F1_BASIMP", "F2_BASIMP"
        cCpoValImp - caracter - "F1_VALIMP", "F2_VALIMP"
        oModel -  - oModel utilizado por el model que llama las funciones de calculo.
	@return 
	/*/
Function MUpdCabImp(oValJson, cModelCab, cCpoBasImp, cCpoValImp, oModel)
Local aBasImp   := Iif(oValJson:HasProperty("NF_BASEIMP"), oValJson["NF_BASEIMP"], {})
Local aValImp   := Iif(oValJson:HasProperty("NF_VALIMP"), oValJson["NF_VALIMP"], {})
Local oSubModel := oModel:GetModel(cModelCab)

Default oValJson    := JsonObject():new()
Default cModelCab   := ""
Default cCpoBasImp  := ""
Default cCpoValImp  := ""

    MUpdFldImp(@oSubModel, aBasImp, cCpoBasImp)
    MUpdFldImp(@oSubModel, aValImp, cCpoValImp)
    
Return

/*/{Protheus.doc} MUpdItmImp
	Función utilizada para realizar el la actualización los valores de impuestos en los items (Base, alicuota y Valor del impuesto) por campo libro.
	@type  Function
	@author raul.medina
	@since 
	@param
        aItem - Array - Arreglo con objetos json por item con información de los calculos de impuestos.
        cSubModel - caracter - "SD1_DETAIL", "SD2_DETAIL".
        cDAlqImp - caracter - "D1_ALQIMP", "D2_ALQIMP"
        cDBasImp - caracter - "D1_BASIMP", "D2_BASIMP"
        cDValImp - caracter - "D1_VALIMP", "D2_VALIMP"
        oModel -  - oModel utilizado por el model que llama las funciones de calculo.
	@return 
	/*/
Function MUpdItmImp(aItem, cSubModel, cDAlqImp, cDBasImp, cDValImp, oModel)
Local nX        := 0
Local oSubModel := oModel:GetModel(cSubModel)
Local nLine     := oSubModel:GetLine()
Local aBasImp   := {}
Local aValImp   := {} 
Local aAlqImp   := {}

Default aItem       := {}
Default cSubModel   := ""
Default cDAlqImp    := ""
Default cDBasImp    := ""
Default cDValImp    := ""

    For nX := 1 To Len(aItem)
        aBasImp := Iif(aItem[nX]:HasProperty("IT_BASEIMP"), aItem[nX]["IT_BASEIMP"], {})
        aAlqImp := Iif(aItem[nX]:HasProperty("IT_ALIQIMP"), aItem[nX]["IT_ALIQIMP"], {})
        aValImp := Iif(aItem[nX]:HasProperty("IT_VALIMP"), aItem[nX]["IT_VALIMP"], {})
        
        oSubModel:GoLine(nX)
        If !oSubModel:IsDeleted()
            MUpdFldImp(@oSubModel, aBasImp, cDBasImp)
            MUpdFldImp(@oSubModel, aAlqImp, cDAlqImp)
            MUpdFldImp(@oSubModel, aValImp, cDValImp)
        EndIf
    Next
    oSubModel:GoLine(nLine)

Return

/*/{Protheus.doc} MUpdFldImp
	Función utilizada para realizar el la actualización los valores de impuestos en los items (Base, alicuota y Valor del impuesto) por campo libro.
	@type  Function
	@author raul.medina
	@since 
	@param
        oSubModel -  - oModel utilizado por el model que llama las funciones de calculo.
        aValores - Array - Arreglo con los valores con información de los calculos de impuestos por campo libro.
        cCampo - caracter - Campo a ser actualizado de base/alicuota/valor impuesto.
	@return 
	/*/
Function MUpdFldImp(oSubModel, aValores, cCampo)
Local nX        := 0
Local cCampoAux := ""

Default aValores    := {}
Default cCampo      := ""

    For nX := 1 To Len(aValores)
        cCampoAux := cCampo + NumCpoImpVar(nX)
        If oSubmodel:HasField(cCampoAux) .and. aValores[nX] >= 0
            oSubModel:LoadValue(cCampoAux, aValores[nX])
        EndIf
    Next

Return

/*/{Protheus.doc} MPaymntCon
	Función utilizada para realizar el calculo de los títulos.
	@type  Function
	@author raul.medina
	@since 
	@param
        oModel -  - Model que está siendo procesado.
        nBaseDup - numerico - Valor a ser utilizado para los títulos.
        nMoneda - numerico - Moneda del documento.
        dDataEmis - data - Fecha de emisión.
        cCondition - caracter - Código de la condición de pago.
        cNatureza - caracter - Naturaleza del documento.
        nTaxa - numerico - Tasa de la moneda usada en el documento.
        cDocument - caracter - Número del documento.
        cSerieDoc - numerico - Serie del documento.
        nMoedaFin - numerico - Moneda para los títulos financieros.
	@return 
	/*/
Function MPaymntCon(oModel, nBaseDup, nMoneda, dDataEmis, cCondition, cNatureza, nTaxa, cDocument, cSerieDoc, nMoedaFin)
Local aTemp     := {}
Local aDup      := {}
Local nX        := 0
Local cDescri   := ""
Local oView     := FWViewActive()
Local lxFisRes  := .F.

Private cNFiscal    := ""
Private cSerie      := ""
Private aDupl       := {}

Default nBaseDup    := 0
Default nMoneda     := 1
Default dDataEmis   := dDatabase
Default cCondition  := ""
Default cNatureza   := ""
Default nTaxa       := 1
Default cDocument   := ""
Default cSerieDoc   := ""
Default nMoedaFin   := 1

    If !(Type("dDEmissao") == "D")
		dDEmissao  := dDataEmis
	EndIf
    cNFiscal    := cDocument
    cSerie      := cSerieDoc

    If !MaFisFound()
		lxFisRes := MaFisRestore()
	EndIf

    //Llamada de función de calculo de títulos.
    aDup := LxA103Dupl(nBaseDup, nMoneda, dDataEmis, cCondition, @aTemp,,,,,, @cNatureza, @cDescri, nTaxa, .F., nMoedaFin)

    //Activación del model de titulos para recibir datos.
    oModel:GetModel("DUP_DETAIL"):SetNoInsertLine(.F.)
    oModel:GetModel("DUP_DETAIL"):SetNoDeleteLine(.F.)

    oModel:GetModel("DUP_DETAIL"):ClearData(.F., .T.) //Limpia de datos en el model.
    //Llenado de datos en el model de títutlos.
    MdFillDup(@oModel, "DUP_DETAIL" ,{"DUP"}, aDupl)    
    For nX := 1 To Len(aDup)
        oModel:GetModel("DUP_DETAIL"):GoLine(nX)
        oModel:GetModel("DUP_DETAIL"):LoadValue('DUP_NUM', aDup[nX][1])
        oModel:GetModel("DUP_DETAIL"):LoadValue('DUP_PREFIX', aDup[nX][2])
        oModel:GetModel("DUP_DETAIL"):LoadValue('DUP_PARCEL', aDup[nX][3])
        oModel:GetModel("DUP_DETAIL"):LoadValue('DUP_VENCTO', aDup[nX][4])
        oModel:GetModel("DUP_DETAIL"):LoadValue('DUP_VALOR', aDup[nX][5])
    Next
    oModel:GetModel("DUP_DETAIL"):GoLine(1)

    //Desactivación del model de titulos para recibir datos.
    oModel:GetModel("DUP_DETAIL"):SetNoInsertLine()
    oModel:GetModel("DUP_DETAIL"):SetNoDeleteLine()

    If ValType(oView) == "O"
        oView:Refresh("oStruFIN")
        oView:Refresh("oStruDUP")
    EndIf

    If lxFisRes
		MaFisSave()
    	MaFisEnd()
	EndIf

Return

/*/{Protheus.doc} GetDupFin
	Función utilizada para realizar la busqueda de la información de los títulos de un documento.
	@type  Function
	@author raul.medina
	@since 
	@param
        cTable - caracter - Tabla del documento donde fueron guardados los titulos (SE1/SE2)
        cDoc - caracter - Numero del documento.
        cSerie - caracter - Serie del documento.
        cFornece - caracter - Código del cliente/proveedor.
        cLoja - caracter - Loja del cliente/proveedor.
        cEspecie - caracter - Especie del documento.
	@return 
        aDup - array - Arreglo con la información de los títulos. {numero, serie, parcela, vencimiento, valor}
*/
Function GetDupFin(cTable, cDoc, cSerie, cFornece, cLoja, cEspecie)
Local aDup      := {}

Default cTable      := ""
Default cDoc        := ""
Default cSerie      := ""
Default cFornece    := ""
Default cLoja       := ""
Default cEspecie    := ""

    If cTable == "SE2"
        aDup := GetDupSE2(cDoc, cSerie, cFornece, cLoja, cEspecie)
    EndIf

Return aDup

/*/{Protheus.doc} GetDupSE2
	Función utilizada para realizar la busqueda de la información de los títulos de un documento.
	@type  Function
	@author raul.medina
	@since 
	@param
        cDoc - caracter - Numero del documento.
        cSerie - caracter - Serie del documento.
        cFornece - caracter - Código del cliente/proveedor.
        cLoja - caracter - Loja del cliente/proveedor.
        cEspecie - caracter - Especie del documento.
	@return 
        aDup - array - Arreglo con la información de los títulos. {numero, serie, parcela, vencimiento, valor}
*/
Function GetDupSE2(cDoc, cSerie, cFornece, cLoja, cEspecie)
Local aDup      := {}
Local aArea     := GetArea()
Local nX        := 0

Default cDoc        := ""
Default cSerie      := ""
Default cFornece    := ""
Default cLoja       := ""
Default cEspecie    := ""

    cFornece := PADR(cFornece, GetSX3Cache("E2_FORNECE", "X3_TAMANHO"))
    cLoja    := PADR(cLoja, GetSX3Cache("E2_LOJA", "X3_TAMANHO"))
    cSerie   := PADR(cSerie, GetSX3Cache("E2_PREFIXO", "X3_TAMANHO"))
    cDoc     := PADR(cDoc, GetSX3Cache("E2_NUM", "X3_TAMANHO"))
    cEspecie := PADR(cEspecie, GetSX3Cache("E2_TIPO", "X3_TAMANHO"))

    DbSelectArea("SE2")
    DbSetOrder(6)
    If SE2->(MsSeek(xFilial("SE2") + cFornece + cLoja + cSerie + cDoc))
        While SE2->(!Eof()) .and. SE2->E2_FILIAL + SE2->E2_FORNECE + SE2->E2_LOJA + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_TIPO == xFilial("SE2") + cFornece + cLoja + cSerie + cDoc + cEspecie
            aAdd(aDup,{nX,{"", SE2->E2_NUM, SE2->E2_PREFIXO, SE2->E2_PARCELA, SE2->E2_VENCTO, SE2->E2_VALOR}})
            nX += 1
            SE2->(DbSkip())
        EndDo
    EndIf
    RestArea(aArea)
    
Return aDup

/*/{Protheus.doc} GInfoTesD1
	Función utilizada para generar un json con la información de las TES de un documento.
	@type  Function
	@author raul.medina
	@since 
	@param
        cDoc - caracter - Numero del documento.
        cSerie - caracter - Serie del documento.
        cFornece - caracter - Código del cliente/proveedor.
        cLoja - caracter - Loja del cliente/proveedor.
        cEspecie - caracter - Especie del documento.
	@return 
        oTes - json - json con la información de las TES de un documento.
*/
Function GInfoTesD1(cDoc, cSerie, cFornece, cLoja, cEspecie)
Local cAliasTmp     := getNextAlias()
Local cCampos       := ""
Local cTablas       := ""
Local cCond         := ""
Local cGroup        := ""
Local cOrder        := ""
Local oTes          := JsonObject():new()

Default cDoc        := ""
Default cSerie      := ""
Default cFornece    := ""
Default cLoja       := ""
Default cEspecie    := ""

    //Impuestos de documento
    cCampos	:= "% SD1.D1_TES, SFB.FB_CODIGO, SFB.FB_CPOLVRO, SFB.FB_DESCR %"
    cTablas	:= "% " + RetSqlName("SD1") + " SD1, "  + RetSqlName("SFC") + " SFC, "  + RetSqlName("SFB") + " SFB %"

    cCond	:= "% SD1.D1_DOC = '" + cDoc + "' AND SD1.D1_SERIE = '" + cSerie + "'"
    cCond  	+= " AND SD1.D1_FORNECE = '" + cFornece + "' AND SD1.D1_LOJA = '" + cLoja + "'"
    cCond   += " AND SD1.D1_ESPECIE = '" + cEspecie + "'"
    cCond  	+= " AND SD1.D1_TES = SFC.FC_TES "

    cCond 	+= " AND SFC.FC_IMPOSTO = SFB.FB_CODIGO"
    cCond	+= " AND SD1.D1_FILIAL = '" + xFilial("SD1") + "'"
    cCond	+= " AND SFC.FC_FILIAL = '" + xFilial("SFC") + "'"
    cCond	+= " AND SFB.FB_FILIAL = '" + xFilial("SFB") + "'"
    cCond	+= " AND SD1.D_E_L_E_T_  = ' ' "
    cCond	+= " AND SFC.D_E_L_E_T_  = ' ' "
    cCond	+= " AND SFB.D_E_L_E_T_  = ' ' %"
    cGroup 	:= "% SD1.D1_TES, SFB.FB_CODIGO, SFB.FB_CPOLVRO, SFB.FB_DESCR %"
    cOrder 	:= "% SD1.D1_TES, SFB.FB_CODIGO, SFB.FB_CPOLVRO, SFB.FB_DESCR %"

    BeginSql alias cAliasTmp
        SELECT %exp:cCampos%
        FROM  %exp:cTablas%
        WHERE %exp:cCond%
        GROUP BY %exp:cGroup%
        ORDER BY %exp:cOrder%
    EndSql

    dbSelectArea(cAliasTmp)
    (cAliasTmp)->(DbGoTop())
    While (cAliasTmp )->(!Eof())
        If !oTes:HasProperty((cAliasTmp)->D1_TES)
            oTes[(cAliasTmp)->D1_TES] := {}
        EndIf
        aAdd(oTes[(cAliasTmp)->D1_TES], {(cAliasTmp)->FB_CODIGO,(cAliasTmp)->FB_CPOLVRO,(cAliasTmp)->FB_DESCR})
        (cAliasTmp)->(dbskip())
    EndDo
    (cAliasTmp)->(DBCloseArea())  

Return oTes

/*/{Protheus.doc} GImpostosD1
	Función utilizada para generar un array con la información de los impuestos de un documento.
	@type  Function
	@author raul.medina
	@since 
	@param
        cDoc - caracter - Numero del documento.
        cSerie - caracter - Serie del documento.
        cFornece - caracter - Código del cliente/proveedor.
        cLoja - caracter - Loja del cliente/proveedor.
        cEspecie - caracter - Especie del documento.
	@return 
        aRetImp - array - array con la información de los impuestos de un documento.
*/
Function GImpostosD1(cDoc, cSerie, cFornece, cLoja, cEspecie)
Local cAliasSD1     := getNextAlias()
Local cCampos       := ""
Local cTablas       := ""
Local cCond         := ""
Local cOrder        := ""
Local nX            := 0
Local nBasImp       := 0
Local nAlqImp       := 0
Local nValImp       := 0
Local aCposImpD1    := Nil
Local oTes
Local aTes
Local oImpuestos    := JsonObject():new()
Local aRetImp       := {}
Local aJsonImp      := {}

Default cDoc        := ""
Default cSerie      := ""
Default cFornece    := ""
Default cLoja       := ""
Default cEspecie    := ""

    oTes := GInfoTesD1(cDoc, cSerie, cFornece, cLoja, cEspecie)

    aCposImpD1 := FWFormStruct( 1, 'SD1',{|cCampo| "D1_VALIMP" $ cCampo .Or. "D1_ALQIMP" $ cCampo .Or. "D1_BASIMP" $ cCampo}, .F.):GetFields()

    cCampos	:= "% SD1.D1_TES"
    cGroup  := "% SD1.D1_TES"
    For nX := 1 To Len(aCposImpD1)
        If "D1_ALQIMP" $ aCposImpD1[nX][MODEL_FIELD_IDFIELD]
            cCampos += ", SD1." + aCposImpD1[nX][MODEL_FIELD_IDFIELD]
            cGroup  += ", SD1." + aCposImpD1[nX][MODEL_FIELD_IDFIELD]
        Else
             cCampos += ", SUM(SD1." + aCposImpD1[nX][MODEL_FIELD_IDFIELD] + ") AS " + aCposImpD1[nX][MODEL_FIELD_IDFIELD]
        EndIf
    Next
    cCampos += " %"
    cGroup  += " %"
    cTablas	:= "% " + RetSqlName("SD1") + " SD1 %"

    cCond	:= "% SD1.D1_DOC = '" + cDoc + "' AND SD1.D1_SERIE = '" + cSerie + "'"
    cCond  	+= " AND SD1.D1_FORNECE = '" + cFornece + "' AND SD1.D1_LOJA = '" + cLoja + "'"
    cCond   += " AND SD1.D1_ESPECIE = '" + cEspecie + "'"
    cCond	+= " AND SD1.D1_FILIAL = '" + xFilial("SD1") + "'"
    cCond	+= " AND SD1.D_E_L_E_T_  = ' ' %"
    cOrder 	:= "% SD1.D1_TES %"

    BeginSql alias cAliasSD1
        SELECT %exp:cCampos%
        FROM  %exp:cTablas%
        WHERE %exp:cCond%
        GROUP BY %exp:cGroup%
        ORDER BY %exp:cOrder%
    EndSql

    dbSelectArea(cAliasSD1)
    (cAliasSD1)->(DbGoTop())
    While (cAliasSD1 )->(!Eof())
        aTes := Iif(oTes:HasProperty((cAliasSD1)->D1_TES), oTes[(cAliasSD1)->D1_TES], {})
        For nX := 1 To Len(aTes)
            nBasImp := (cAliasSD1 )->&("D1_BASIMP"+aTes[nX][2])
            nAlqImp := (cAliasSD1 )->&("D1_ALQIMP"+aTes[nX][2])
            nValImp := (cAliasSD1 )->&("D1_VALIMP"+aTes[nX][2])
            If nBasImp > 0
                GroupImp(@oImpuestos, aTes[nX][1], aTes[nX][3], nBasImp, nAlqImp, nValImp)
            EndIf
        Next
        (cAliasSD1)->(dbskip())
    EndDo
    (cAliasSD1)->(DBCloseArea())
    
    aJsonImp := oImpuestos:GetNames()
    For nX := 1 To Len(aJsonImp)
        aAdd(aRetImp, {nX-1, oImpuestos[aJsonImp[nX]]})
    Next

Return aRetImp

/*/{Protheus.doc} GroupImp
	Función utilizada para generar un array con la información de los impuestos de un documento.
	@type  Function
	@author raul.medina
	@since 
	@param
        oImpuestos - json - Json con los impuestos.
        cImpuesto - caracter - Código del impuesto.
        cDescImp - caracter - Descripción del impuesto.
        nBasImp - numerico - Base del impuesto.
        nAlqImp - numerico - Alicuota del impuesto.
        nValImp - numerico - Valor del impuesto.
	@return 
*/
Function GroupImp(oImpuestos, cImpuesto, cDescImp, nBasImp, nAlqImp, nValImp)
Local cLlave := ""

Default oImpuestos  := JsonObject():new()
Default cImpuesto   := ""
Default cDescImp    := ""
Default nBasImp     := 0
Default nAlqImp     := 0
Default nValImp     := 0

    cLlave := cImpuesto + cValToChar(nAlqImp)
    
    If oImpuestos:HasProperty(cLlave)
        oImpuestos[cLlave][4] += nBasImp
        oImpuestos[cLlave][5] += nValImp
    Else
        oImpuestos[cLlave] := {cImpuesto, cDescImp, nAlqImp, nBasImp, nValImp}
    EndIf

Return

/*/{Protheus.doc} ActModSDE
Función utilizada para informar en el model la información del prorrateo de SDE.
@author 	raul.medina
@since 		09/2023
@version	12.1.2210 / Superior
Parametros
    oModelSDE -  - submodelo de la tabla SDE.
    aHeader - array - arreglo con la información de los campos de SDE.
    aDatCC - array - arreglo con la información de los prorratos de los items.
@Return 
/*/
Function ActModSDE(oModelSDE, aHeader, aDatCC)
Local nX        := 0
Local nY        := 0
Local nLine     := 1
Local nLenHead  := 0

    oModelSDE:ClearData(.F., .T.)
    nLenHead := Len(aHeader) + 1
    For nX := 1 To Len(aDatCC)
        For nY := 1 To Len(aDatCC[nX][2])
            If !aDatCC[nX][2][nY][nLenHead]
                If oModelSDE:Length() < nLine
                    oModelSDE:LVALID := .T. //Actualización x campo
                    oModelSDE:AddLine()
                EndIf
                oModelSDE:LoadValue("DE_ITEMNF", aDatCC[nX][1])
                AEval(aHeader, {|x,y| oModelSDE:LoadValue(x[2], aDatCC[nX][2][nY][y])})
                nLine++
            EndIf
        Next
    Next

Return

/*/{Protheus.doc} GetModSDE
Función utilizada para obtener del model la información del prorrateo de SDE.
@author 	raul.medina
@since 		09/2023
@version	12.1.2210 / Superior
Parametros
    oModelSDE -  - submodelo de la tabla SDE.
    aHeader - array - arreglo con la información de los campos de SDE.
@Return 
    aDatCC - array - arreglo con la información de los prorratos de los items.
/*/
Function GetModSDE(oModelSDE, aHeader)
Local nX        := 0
Local nPos      := 0
Local aDatCC    := {}
Local nLenHead  := 0
Local cItem     := ""
Local nPosIt    := 0

    nLenHead := Len(aHeader) + 1
    For nX := 1 To oModelSDE:Length()
        cItem := oModelSDE:GetValue("DE_ITEMNF", nX)
        If !Empty(cItem)
            nPos := aScan(aDatCC, {|x| x[1] == cItem})
            If nPos == 0
                aadd(aDatCC,{cItem,{Array(nLenHead)}})
                nPos := Len(aDatCC)
            Else
                aadd(aDatCC[nPos][2],Array(nLenHead))
            EndIf
            nPosIt := Len(aDatCC[nPos][2])
            AEval(aHeader, {|x,y| aDatCC[nPos][2][nPosIt][y] := oModelSDE:GetValue(x[2], nX)})
            aDatCC[nPos][2][nPosIt][nLenHead] := .F.
        EndIf
    Next

Return aDatCC

/*/{Protheus.doc} GetCposSDE
Función utilizada para obtener los campos de SDE para la ventana de prorrateo.
@author 	raul.medina
@since 		09/2023
@version	12.1.2210 / Superior
Parametros
    oSubModel -  - submodelo de la tabla SDE.
@Return 
    aHeader - array - arreglo con la información de los campos de SDE.
/*/
Function GetCposSDE(oSubModel)
Local aCposSDE  := oSubModel:aHeader
Local nX        := 0
Local aHeader   := {}
Local cUsado    := ""
Local nNivel    := 1

    If ValType(cNivel) == "N"
        nNivel := cNivel
    EndIf
    For nX := 1 To Len(aCposSDE)
        cUsado := GetSX3Cache(aCposSDE[nX][2], "X3_USADO")
        If X3USO(cUsado) .and. nNivel >= GetSX3Cache(aCposSDE[nX][2], "X3_NIVEL")
            AADD(aHeader,{ TRIM(aCposSDE[nX][1]), aCposSDE[nX][2], GetSX3Cache(aCposSDE[nX][2], "X3_PICTURE"),;
                    aCposSDE[nX][4], aCposSDE[nX][5], aCposSDE[nX][6],;
                    cUsado, aCposSDE[nX][8], "SDE", aCposSDE[nX][10] } )
        EndIf
    Next

Return aHeader

/*/{Protheus.doc} LxModImp
	Función utilizada para realizar la llamada de las funciones de calculo.
	@type  Function
	@author raul.medina
	@since 09/2023
	@param
        cTipEdit - caracter - Tipo de edición I - por impuesto, T - por total.
        oModel -  - Model que está siendo procesado.
        cModelID - caracter - Nombre de modelo utilizado para el encabezado.
        cModelIT - caracter - Nombre de modelo utilizado para los items.
	@return 
	/*/
Function LxModImp(cTipEdit, oModel, cModelID, cModelIT)
Local oImpostos     := Impostos():New()
Local ojson                 As json
Local oModelSD
Local aOldData
Local cCpoDoc       := Iif(cModelID == "SF1_MASTER", "F1_DOC", "")
Local cSerieDoc     := Iif(cModelID == "SF1_MASTER", "F1_SERIE", "")
Local cCpoEmis      := Iif(cModelID == "SF1_MASTER", "F1_EMISSAO", "")
Local cCpoTPDoc     := Iif(cModelID == "SF1_MASTER", "F1_TIPODOC", "")
Local cCpoCond      := Iif(cModelID == "SF1_MASTER", "F1_COND", "")
Local cTipoDoc      := ""
Local cPaymntCnd    := ""
Private aHeader     := {}
Private aCols       := {}
Private cNFIscal    := ""
Private cSerie      := ""
Private dDEmissao   := CToD("//")

Default cTipEdit    := "I"
Default cModelID    := ""
Default cModelIT    := ""


    cNFIscal := oModel:GetModel(cModelID):GetValue(cCpoDoc)
    cSerie   := oModel:GetModel(cModelID):GetValue(cSerieDoc)
    dDEmissao:= oModel:GetModel(cModelID):GetValue(cCpoEmis)
    cTipoDoc := oModel:GetModel(cModelID):GetValue(cCpoTPDoc)
    cPaymntCnd := oModel:GetModel(cModelID):GetValue(cCpoCond)

    oModelSD     := oModel:GetModel(cModelIT)
    oImpostos:GetModImp(oModel:GetModel("IMP_DETAIL"))
    aOldData := oModelSD:GetOldData()
    aHeader := aOldData[1]
    aCols  := aClone(aOldData[2])

    aCfgNf := GetCfgNF(cTipoDoc)
    MaFisRestore() //Se restauran los datos de la matfis.
    If Iif(cTipEdit == "I", FISA081(oImpostos, .F.), FISA084(oImpostos, .F.))
        //Se obtienen los valores de la matxfis.
        ojson := GetCalxFis(aCols, .T.)
        //Actualización de los valores en el model.
        ActCalcFis(oModel, ojson, .T., cModelID)
        If oModel:GetModel(cModelID):HasField("ALTIMP")
            oModel:GetModel(cModelID):LoadValue("ALTIMP", .T.) //Cambia flag para indicar que los impuestos fueron modificados.
        EndIf
    EndIf
    //Se respaldan los valores de la matxfis y se cierra la conexión.
    MaFisSave()
    MaFisEnd()

    //Se actualizan los datos de los títulos.
    If !Empty(cPaymntCnd)
        If cModelID == "SF1_MASTER"
            F1PaymntCn(cPaymntCnd)
        EndIf
    EndIf

Return

/*/{Protheus.doc} GetCalxFis
	Función utilizada para obtener los valores de la matxfis.
	@type  Function
	@author raul.medina
	@since 09/2023
	@param
        aCols - array - array con la información de los items.
        lCalcImp - logico - Se indica si deben ser considerados los calculos de los impuestos.
	@return 
        ojson - JsonObject - Json con la información de totales y valores por item.
	/*/
Function GetCalxFis(aCols, lCalcImp)
Local ojson                 As json
Local aLivroAux     := {}
Local aImpostos     := {}
Local nX            := 0

Default aCols       := {}
Default lCalcImp    := .F.

    ojson := JsonObject():new()
    //Descuento del encabezado
    oJson['NF_DESCONTO']    := 0
    //Valor Brutoo
    oJson['NF_TOTAL']       := 0
    //Valor Mercadoria
    oJson['NF_VALMERC']     := 0
    //Flete del encabezado
    oJson['NF_FRETE']       := 0
    //Valor Brutoo
    oJson['NF_DESPESA']     := 0
    //Valor Mercadoria
    oJson['NF_SEGURO']      := 0
    //Valor Anticipo
    oJson['NF_ADIANT']      := 0
    //Libros fiscales
    oJson['NF_LIVRO']       := {}
    //Impuestos para mostrar en pantalla.
    oJson['NF_IMPOSTOS']    := {}
    //Bases de calculo del encabezado
    oJson['NF_BASEIMP']     := {}
    //Valores del calculo de impuestos del encabezado
    oJson['NF_VALIMP']      := {}
    //Valores de items
    oJson['ITEMS']          := {}

    oJson['NF_DESCONTO']    := MaFisRet( ,"NF_DESCONTO")
    oJson['NF_TOTAL']       := MaFisRet( ,"NF_TOTAL")
    oJson['NF_VALMERC']     := MaFisRet( ,"NF_VALMERC")
    oJson['NF_BASEDUP']     := MaFisRet( ,"NF_BASEDUP")
    oJson['NF_FRETE']       := MaFisRet( ,"NF_FRETE")
    oJson['NF_DESPESA']     := MaFisRet( ,"NF_DESPESA")
    oJson['NF_SEGURO']      := MaFisRet( ,"NF_SEGURO")
    oJson['NF_ADIANT']      := MafisRet( ,"NF_ADIANT")
    If lCalcImp
        //Libros fiscales
        aLivroAux    := MaFisRet( ,"NF_LIVRO")
        oJson['NF_LIVRO']       := {{}, {}}
        If Len(aLivroAux) > 0
            oJson['NF_LIVRO'][1] := aLivroAux[1]
            For nX := 2 To Len(aLivroAux)
                aAdd(oJson['NF_LIVRO'][2], aLivroAux[nX])
            Next
        EndIf
        //Impuestos
        aImpostos    := MaFisRet( ,"NF_IMPOSTOS")
        oJson['NF_IMPOSTOS']:= {{}, {}}
        If Len(aImpostos) > 0
            oJson['NF_IMPOSTOS'][1] := {'IMP_COD', 'IMP_DESC', 'IMP_ALQIMP', 'IMP_BASIMP', 'IMP_VALIMP'}
            For nX := 1 To Len(aImpostos)
                aAdd(oJson['NF_IMPOSTOS'][2], {aImpostos[nX][1], aImpostos[nX][2], aImpostos[nX][4], aImpostos[nX][3], aImpostos[nX][5]})
            Next
        EndIf
    
        oJson['NF_BASEIMP']     := MaFisRet( ,"NF_BASEIMP")
        oJson['NF_VALIMP']      := MaFisRet( ,"NF_VALIMP")
    EndIf

    For nX := 1 To Len(aCols)
        aAdd(oJson['ITEMS'], JsonObject():new())
        If MaFisFound("IT", nX)
            If lCalcImp
                //Bases de calculo de impuestos en los items.
                oJson['ITEMS'][nX]['IT_BASEIMP']    := MaFisRet(nX, "IT_BASEIMP")
                //Alicuota de calculo de impuestos en los items.
                oJson['ITEMS'][nX]['IT_ALIQIMP']    := MaFisRet(nX, "IT_ALIQIMP")
                //Valor de calculo de impuestos en los items.
                oJson['ITEMS'][nX]['IT_VALIMP']     := MaFisRet(nX, "IT_VALIMP")
            EndIf
            //Valor del descuento en los items.
            oJson['ITEMS'][nX]['IT_DESCONTO']   := MaFisRet(nX, "IT_DESCONTO")
            oJson['ITEMS'][nX]['IT_FRETE']      := MaFisRet(nX, "IT_FRETE")
            oJson['ITEMS'][nX]['IT_DESPESA']    := MaFisRet(nX, "IT_DESPESA")
            oJson['ITEMS'][nX]['IT_SEGURO']     := MaFisRet(nX, "IT_SEGURO")
        EndIf
    Next

Return oJson

/*/{Protheus.doc} GetCalxFis
	Función utilizada para actualizar los valores dentro del model.
	@type  Function
	@author raul.medina
	@since 09/2023
	@param
        oModel -  - Model que está siendo procesado.
        ojson - JsonObject - Json con la información de totales y valores por item.
        lCalcImp - logico - Se indica si deben ser considerados los calculos de los impuestos.
        cModelID - caracter - Nombre de modelo utilizado para el encabezado.
	@return 
	/*/
Function ActCalcFis(oModel, ojson, lCalcImp, cModelID)
Local nX            := 0
Local lEntrada      := cModelID == "SF1_MASTER"
Local cCpoValMer    := Iif(cModelID == "SF1_MASTER", "F1_VALMERC", "")
Local cCpoDescon    := Iif(cModelID == "SF1_MASTER", "F1_DESCONT", "")
Local cCpoValBrt    := Iif(cModelID == "SF1_MASTER", "F1_VALBRUT", "")
Local cCpoTipDoc    := Iif(cModelID == "SF1_MASTER", "F1_TIPODOC", "")
Local cCpoValAdi    := Iif(cModelID == "SF1_MASTER", "F1_VALADI" , "")
Local oTipoDoc      := TipoDoc():New()

Default ojson       := JsonObject():new()
Default lCalcImp    := .F.
Default cModelID    := ""

    oTipoDoc:SetTipoDoc(oModel:GetModel(cModelID):GetValue(cCpoTipDoc))
    oModel:GetModel(cModelID):LoadValue(cCpoValMer, oJson['NF_VALMERC'])
    oModel:GetModel(cModelID):LoadValue(cCpoDescon, oJson['NF_DESCONTO'])
    If oTipoDoc:SumDescTot(cPaisLoc)
        oModel:GetModel(cModelID):LoadValue(cCpoValBrt, oJson['NF_TOTAL'] + oJson['NF_DESCONTO'])
    Else
        oModel:GetModel(cModelID):LoadValue(cCpoValBrt, oJson['NF_TOTAL'])
    EndIf
    oModel:GetModel(cModelID):LoadValue('BASEDUP' , oJson['NF_BASEDUP'])
    If oModel:GetModel(cModelID):HasField(cCpoValAdi)
        oModel:GetModel(cModelID):LoadValue(cCpoValAdi, oJson['NF_ADIANT'])
    EndIf

    If lCalcImp //Indica si el documento hace calculo de impuestos, para llenar los valores en los modelos.

        //Activación del model de libros fiscales para recibir datos.
        oModel:GetModel("SF3_DETAIL"):SetNoInsertLine(.F.)
        oModel:GetModel("SF3_DETAIL"):SetNoUpdateLine(.F.)
        oModel:GetModel("SF3_DETAIL"):SetNoDeleteLine(.F.)

        //Activación del model de impuestos para recibir datos.
        oModel:GetModel("IMP_DETAIL"):SetNoInsertLine(.F.)
        oModel:GetModel("IMP_DETAIL"):SetNoUpdateLine(.F.)
        oModel:GetModel("IMP_DETAIL"):SetNoDeleteLine(.F.)

        //Llenado los libros fiscales.
        oModel:GetModel("SF3_DETAIL"):ClearData(.F., .T.)
        LxF3Round(@ojson['NF_LIVRO']) //Realiza el redondeo a los campos de impuestos a los decimales de moneda 1.
        For nX := 1 To Len(oJson['NF_LIVRO'][2])
            If oModel:GetModel("SF3_DETAIL"):Length() < nX
                oModel:GetModel("SF3_DETAIL"):LVALID := .T. //Actualización x campo
                oModel:GetModel("SF3_DETAIL"):AddLine()
            EndIf
            MdFillSub(@oModel, 'SF3_DETAIL', ojson['NF_LIVRO'][1], ojson['NF_LIVRO'][2][nX])
        Next

        //Llenado de impuestos con descripción.
        oModel:GetModel("IMP_DETAIL"):ClearData(.F., .T.)
        For nX := 1 To Len(oJson['NF_IMPOSTOS'][2])
            If oModel:GetModel("IMP_DETAIL"):Length() < nX
                oModel:GetModel("IMP_DETAIL"):LVALID := .T. //Actualización x campo
                oModel:GetModel("IMP_DETAIL"):AddLine()
            EndIf
            MdFillSub(@oModel, 'IMP_DETAIL', ojson['NF_IMPOSTOS'][1], ojson['NF_IMPOSTOS'][2][nX])
        Next

        //Llamada a funciones de llenado de datos en el model.
        UpdCposImp(lEntrada, ojson, @oModel)

        //Desactivación del model de libros fiscales para recibir datos.
        oModel:GetModel("SF3_DETAIL"):SetNoInsertLine()
        oModel:GetModel("SF3_DETAIL"):SetNoUpdateLine()
        oModel:GetModel("SF3_DETAIL"):SetNoDeleteLine()

        //Desactivación del model de impuestos para recibir datos.
        oModel:GetModel("IMP_DETAIL"):SetNoInsertLine()
        oModel:GetModel("IMP_DETAIL"):SetNoUpdateLine()
        oModel:GetModel("IMP_DETAIL"):SetNoDeleteLine()
    EndIf

Return

/*/{Protheus.doc} DispProven
	Función utilizada para actualizar el valor de la provincia de entrega.
	@type  Function
	@author raul.medina
	@since 10/2023
	@param
        cCpoCliFor - caracter - Campo de cliente/proveedor (F1_FORNECE|F2_CLIENTE).
        cCpoLoja - caracter - Campo de loja del cliente/proveedor (F1_LOJA|F2_LOJA).
        cCpoTpoDoc - caracter - Campo de numero de documento (F1_TIPODOC|F2_TIPODOC).
	@return 
        cProvent - caracter - Contenido de la provincia de entrega.
	/*/
Function DispProven(cCpoCliFor, cCpoLoja, cCpoTpoDoc)
Local cCliFor   := ""
Local cLoja     := ""
Local cTipoDoc  := ""
Local cProvent  := ""
Local cTable    := ""
Local oTipoDoc  := TipoDoc():New()

Default cCpoCliFor  := ""
Default cCpoLoja    := ""
Default cCpoTpoDoc  := ""

    cCliFor   := FwFldGet(cCpoCliFor)
    cLoja     := FwFldGet(cCpoLoja)
    cTipoDoc  := FwFldGet(cCpoTpoDoc)

    If !Empty(cCliFor) .and. !Empty(cLoja) .and. !Empty(cTipoDoc)
        oTipoDoc:SetTipoDoc(cTipoDoc)
        cTable := oTipoDoc:GetTableOrig()
        cProvent := Posicione(cTable,1,xFilial(cTable)+cCliFor+cLoja,Iif(cTable=="SA1", "A1_EST", "A2_EST"))
    EndIf

Return cProvent

/*/{Protheus.doc} DispCond
	Función utilizada para actualizar el valor de la condición de pago de acuerdo a la información del cliente/proveedor.
	@type  Function
	@author raul.medina
	@since 10/2023
	@param
        cCpoCliFor - caracter - Campo de cliente/proveedor (F1_FORNECE|F2_CLIENTE).
        cCpoLoja - caracter - Campo de loja del cliente/proveedor (F1_LOJA|F2_LOJA).
        cCpoTpoDoc - caracter - Campo de numero de documento (F1_TIPODOC|F2_TIPODOC).
	@return 
        cCond - Caracter - Valor de la condición de pago.
	/*/
Function DispCond(cCpoCliFor, cCpoLoja, cCpoTpoDoc)
Local cCliFor   := ""
Local cLoja     := ""
Local cTipoDoc  := ""
Local cCond     := ""
Local cTable    := ""
Local oTipoDoc  := TipoDoc():New()

Default cCpoCliFor  := ""
Default cCpoLoja    := ""
Default cCpoTpoDoc  := ""

    cCliFor   := FwFldGet(cCpoCliFor)
    cLoja     := FwFldGet(cCpoLoja)
    cTipoDoc  := FwFldGet(cCpoTpoDoc)

    If !Empty(cCliFor) .and. !Empty(cLoja) .and. !Empty(cTipoDoc)
        oTipoDoc:SetTipoDoc(cTipoDoc)
        If oTipoDoc:ValidConditionPayment()
            cTable := oTipoDoc:GetTableOrig()
            cCond := Iif(cTable == "SA2" .and. FunName() == "FINA100", SuperGetMv("MV_FINCPGB", , "498"), Posicione(cTable,1,xFilial(cTable)+cCliFor+cLoja,Iif(cTable=="SA1", "A1_COND", "A2_COND"))) 
        EndIf
    EndIf

Return cCond

/*/{Protheus.doc} DispNatFin
	Función utilizada para actualizar el valor de la naturaleza de acuerdo a la información del cliente/proveedor
	@type  Function
	@author raul.medina
	@since 10/2023
	@param
        cCpoCliFor - caracter - Campo de cliente/proveedor (F1_FORNECE|F2_CLIENTE).
        cCpoLoja - caracter - Campo de loja del cliente/proveedor (F1_LOJA|F2_LOJA).
        cCpoTpoDoc - caracter - Campo de numero de documento (F1_TIPODOC|F2_TIPODOC).
	@return 
        cNatFin - Caracter - Valor de la naturaleza.
	/*/
Function DispNatFin(cCpoCliFor, cCpoLoja, cCpoTpoDoc)
Local cCliFor   := ""
Local cLoja     := ""
Local cTipoDoc  := ""
Local cNatFin   := ""
Local cTable    := ""
Local oTipoDoc  := TipoDoc():New()

Default cCpoCliFor  := ""
Default cCpoLoja    := ""
Default cCpoTpoDoc  := ""

    cCliFor   := FwFldGet(cCpoCliFor)
    cLoja     := FwFldGet(cCpoLoja)
    cTipoDoc  := FwFldGet(cCpoTpoDoc)

    If !Empty(cCliFor) .and. !Empty(cLoja) .and. !Empty(cTipoDoc)
        oTipoDoc:SetTipoDoc(cTipoDoc)
        cTable := oTipoDoc:GetTableOrig()
        cNatFin := Posicione(cTable,1,xFilial(cTable)+cCliFor+cLoja,Iif(cTable=="SA1", "A1_NATUREZ", "A2_NATUREZ"))
    EndIf

Return cNatFin

/*/{Protheus.doc} GetNatFin
	Función utilizada para obtener el valor del campo E2_NATUREZ de un documento y también la descripción
	@type  Function
	@author raul.medina
	@since 10/2023
	@param
        nOpc - numerico - opción 1 regresa código, opción 2 regresa descripción.
        cCliFor - caracter - Código del cliente/proveedor.
        cLoja - caracter - Código de la loja.
        cNumDoc - carater - numero del documento.
        cSerie - caracter - serie del documento.
        cCpoTpoDoc - caracter - Campo de numero de documento.
	@return 
        cNatFin - Caracter - Valor de la naturaleza o descripción.
	/*/
Function GetNatFin(nOpc, cCliFor, cLoja, cNumDoc, cSerie, cEspecie, cTipoDoc)
Local cRet      := ""
Local cTable    := ""
Local oTipoDoc  := TipoDoc():New()
Local aArea     := GetArea()

Default nOpc    := 1
Default cCliFor := ""
Default cLoja   := ""
Default cNumDoc := ""
Default cSerie  := ""
Default cEspecie:= ""
Default cTipoDoc:= ""

    If !Empty(cCliFor) .and. !Empty(cLoja) .and. !Empty(cNumDoc) .and. !Empty(cSerie) .and. !Empty(cTipoDoc)
        oTipoDoc:SetTipoDoc(cTipoDoc)
        cTable := oTipoDoc:GetTableFinDoc()
        If !Empty(cTable)
            DbSelectArea(cTable)
            If cTable == "SE2"
                SE2->(DbSetOrder(6)) //E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO
                If SE2->(MsSeek(xFilial("SE2") + cCliFor + cLoja + cSerie + cNumDoc)) .and. AllTrim(cEspecie) == AllTrim(SE2->E2_TIPO)
                    cRet := SE2->E2_NATUREZ
                EndIf
            EndIf
            If nOpc == 2 .and. !Empty(cRet)
                cRet := AllTrim(Posicione("SED", 1, xFilial("SED") + cRet,"ED_DESCRIC"))
            EndIf
        EndIf
    EndIf

    RestArea(aArea)

Return cRet

/*/{Protheus.doc} GetMoeFin
	Función utilizada para obtener el valor del campo E2_NATUREZ de un documento y también la descripción
	@type  Function
	@author raul.medina
	@since 11/2023
	@param
        cCliFor - caracter - Código del cliente/proveedor.
        cLoja - caracter - Código de la loja.
        cNumDoc - carater - numero del documento.
        cSerie - caracter - serie del documento.
        cEspecie - Caracter - Especie del documento
        cCpoTpoDoc - caracter - Campo de numero de documento.
	@return 
        nRet - numerico - Valor de la moneda.
	/*/
Function GetMoeFin(cCliFor, cLoja, cNumDoc, cSerie, cEspecie, cTipoDoc)
Local nRet      := 0
Local cTable    := ""
Local oTipoDoc  := TipoDoc():New()
Local aArea     := GetArea()

Default cCliFor := ""
Default cLoja   := ""
Default cNumDoc := ""
Default cSerie  := ""
Default cEspecie:= ""
Default cTipoDoc:= ""

    If !Empty(cCliFor) .and. !Empty(cLoja) .and. !Empty(cNumDoc) .and. !Empty(cSerie) .and. !Empty(cEspecie) .and. !Empty(cTipoDoc)
        oTipoDoc:SetTipoDoc(cTipoDoc)
        cTable := oTipoDoc:GetTableFinDoc()
        If !Empty(cTable)
            DbSelectArea(cTable)
            If cTable == "SE2"
                SE2->(DbSetOrder(6)) //E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO
                If SE2->(MsSeek(xFilial("SE2") + cCliFor + cLoja + cSerie + cNumDoc)) .and. AllTrim(cEspecie) == AllTrim(SE2->E2_TIPO)
                    nRet := SE2->E2_MOEDA
                EndIf
            EndIf
        EndIf
    EndIf

    RestArea(aArea)

Return nRet

/*/{Protheus.doc} ViewRfresh
	Función utilizada para actualizar los valores de una view.
	@type  Function
	@author raul.medina
	@since 10/2023
	@param
        oView -  - View que está siendo procesada.
        cView - caracter - nombre de la view a ser actualizada.
	@return 
	/*/
Function ViewRfresh(oView, cView)
Local nFocus        := GetFocus()

    oView:Refresh(cView)
    SetFocus(nFocus)

Return

/*/{Protheus.doc} RatMulTiNat
	Función utilizada para crear la pantalla de prorrateo de Multi Naturaleza.
	@type  Function
	@author raul.medina
	@since 10/2023
	@param
        oModelSEV -  - submodelo correspondiente a la tabla SEV.
        nOperation - numerico - Indica la operación que está siendo utilizada en el model.
        nValor - numerico - Valor de la base a ser prorrateada.
        oModelSDE -  - submodelo correspondiente a la tabla SDE.
	@return 
	/*/
Function RatMulTiNat(oModelSEV, nOperation, nValor, oModelSDE)
Local oDlg      
Local oSize
Local nOpc          := 0
Local nX            := 0
Local aCampos       := {"EV_NATUREZ", "EV_VALOR", "EV_PERC", "EV_RATEICC"}
Local aCposSDE      := {}
Local lEdit         := .F.
Local nLine         := 1
Local nPos          := 0
Local nPosPer       := 0
Local nPosNat       := 0
Local nPosVlr       := 0
Local lMsgTit       := .F.

Private aItems      := {}
Private aCols       := {}
Private aHeader     := {}
Private aRotina     := {}
Private aRatCC      := {}
Private nValDist    := 0
Private nValFal	    := 0
Private nPerFal	    := 0
Private oMultNat
Private oValDist
Private oValFal
Private oPerFal
Private nVlTit      := 0

Default nOperation  := 2
Default nValor      := 0

    lEdit := nOperation == MODEL_OPERATION_INSERT

    If lEdit
        aCposSDE := GetCposSDE(oModelSDE)
        aRatCC := GetModSDE(oModelSDE, aCposSDE)
        CTB105MVC(.T.)
    EndIf

	//Monta Dialog
    oDlg := FwDialogModal():New()

    oDlg:SetTitle(STR0001)//"Prorrateo Multi Naturaleza"
    oDlg:SetEscClose(.F.)
    oDlg:SetSize(220, 400)
    oDlg:CreateDialog()

    oDlg:EnableFormBar(.T.)
    oDlg:CreateFormBar()
    aRotina := {{"","",0,1},{"","",0,2},{"","",0,3},{"","",0,4},{"","",0,5}}

    nVlTit := nValor

    For nX := 1 To Len(aCampos)
        AADD(aHeader,{ Alltrim(FwX3Titulo(aCampos[nX])), aCampos[nX], GetSx3Cache(aCampos[nX], "X3_PICTURE"),;
					GetSx3Cache(aCampos[nX], "X3_TAMANHO"), GetSx3Cache(aCampos[nX], "X3_DECIMAL"), GetSx3Cache(aCampos[nX], "X3_VALID"),;
					GetSx3Cache(aCampos[nX], "X3_USADO"), GetSx3Cache(aCampos[nX], "X3_TIPO"), GetSx3Cache(aCampos[nX], "X3_ARQUIVO"), GetSx3Cache(aCampos[nX], "X3_CONTEXT") } )
        If aCampos[nX] == "EV_PERC"
            aHeader[Len(aHeader)][6] := "Positivo() .and. MNatCalcV()"
            nPosPer := Len(aHeader)
        ElseIf aCampos[nX] == "EV_VALOR"
            aHeader[Len(aHeader)][6] := "Positivo() .and. MNatCalcP()"
            nPosVlr := Len(aHeader)
        ElseIf aCampos[nX] == "EV_RATEICC"
		    aHeader[Len(aHeader)][6] := 'Pertence("12") .And. IIf(EV_RATEICC =="1",VldRatC(),.T.)'
        ElseIf aCampos[nX] == "EV_NATUREZ"
            nPosNat := Len(aHeader)
        EndIf
    Next

    For nX := 1 To oModelSEV:Length()
        If !lEdit
            nPos := aScan(aCols, {|x| x[nPosNat] == oModelSEV:GetValue("EV_NATUREZ", nX) .and. x[nPosPer] == oModelSEV:GetValue("EV_PERC", nX)*100})
        Else
            nPos := 0
        EndIf
        If nPos == 0
            aAdd(aCols, { oModelSEV:GetValue("EV_NATUREZ", nX), oModelSEV:GetValue("EV_VALOR", nX), oModelSEV:GetValue("EV_PERC", nX), oModelSEV:GetValue("EV_RATEICC", nX), .F. })
            nPerFal += oModelSEV:GetValue("EV_PERC", nX)
            If !lEdit
                aCols[Len(aCols)][nPosPer] *= 100
            EndIf
        Else
            aCols[nPos][nPosVlr] += oModelSEV:GetValue("EV_VALOR", nX)
            lMsgTit := .T.
        EndIf
        nValDist += oModelSEV:GetValue("EV_VALOR", nX)
    Next
    If !lEdit
        nVlTit := nValDist
        nPerFal *= 100
    EndIf
    nValFal	:= nVlTit - nValDist

	nPerFal	:= 100 - nPerFal

    ///Calcula dimensiones
    oSize := FwDefSize():New(.T.,,,oDlg:GetPanelMain())
    oSize:AddObject( "CABECALHO",  100, 10, .T., .T. ) // Totalmente dimensionable
    oSize:AddObject( "GETDADOS" ,  100, 80, .T., .T. ) // Totalmente dimensionable
    oSize:AddObject( "RODAPE"   ,  100, 10, .T., .T. ) // Totalmente dimensionable

    oSize:lProp 	:= .T. // Proporcional
    oSize:aMargins 	:= { 3, 3, 3, 3 } // Margenes

    oSize:Process() // Dispara los calculos

    If lMsgTit
        @ oSize:GetDimension("CABECALHO","LININI"),oSize:GetDimension("CABECALHO","COLINI")     Say OemToAnsi(STR0007) FONT oDlg:GetPanelMain():oFont OF oDlg:GetPanelMain() PIXEL	 // "Los valores prorrateados en títulos con más de una cuota pueden presentar diferencias en decimales."
    EndIf
    
    @ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")     Say OemToAnsi(STR0002) FONT oDlg:GetPanelMain():oFont OF oDlg:GetPanelMain() PIXEL	 // "Valor distribuido: "
	@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+45  Say oValDist VAR nValDist Picture GetSx3Cache("EV_VALOR", "X3_PICTURE") FONT oDlg:GetPanelMain():oFont COLOR CLR_HBLUE OF oDlg:GetPanelMain() PIXEL
	@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+100  Say OemToAnsi(STR0003) FONT oDlg:GetPanelMain():oFont OF oDlg:GetPanelMain() PIXEL	 // "Valor a distribuir: "
	@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+150 Say oValFal VAR nValFal Picture GetSx3Cache("EV_VALOR", "X3_PICTURE") FONT oDlg:GetPanelMain():oFont COLOR CLR_HBLUE OF oDlg:GetPanelMain() PIXEL
    @ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+200  Say OemToAnsi(STR0004) FONT oDlg:GetPanelMain():oFont OF oDlg:GetPanelMain() PIXEL	 // "% a distribuir: "
	@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+240 Say oPerFal VAR nPerFal Picture GetSx3Cache("EV_PERC", "X3_PICTURE") FONT oDlg:GetPanelMain():oFont COLOR CLR_HBLUE OF oDlg:GetPanelMain() PIXEL

    oMultNat := MSGetDados():New(oSize:GetDimension("GETDADOS","LININI"),oSize:GetDimension("GETDADOS","COLINI"),;
	     							   oSize:GetDimension("GETDADOS","LINEND"),oSize:GetDimension("GETDADOS","COLEND"),;
										IIF(!lEdit,2,3),"MIChkCols(aHeader,aCols,N)","MLxTOkSEV(aHeader, aCols)",/*'+DE_ITEM'*/,.T.,,,,100,,,,)

    oDlg:AddOkButton({||IIF(oMultNat:TudoOk(),(nOpc:=1,oDlg:DeActivate()),(nOpc:=0))}, STR0021) //"Grabar"
    oDlg:AddCloseButton({||oDlg:DeActivate()}, STR0022) //"Anular"

    oDlg:Activate()

    If nOpc == 1 .and. lEdit 
        oModelSEV:ClearData(.F., .T.)
        For nX := 1 To Len(aCols)
            If !aCols[nX][Len(aCols[nX])]
                If oModelSEV:Length() < nLine
                    oModelSEV:LVALID := .T. //Actualización x campo
                    oModelSEV:AddLine()
                EndIf
                AEval(aHeader, {|x,y| oModelSEV:LoadValue(x[2], aCols[nX][y])})
                nLine ++
            EndIf
        Next
        oModelSEV:LVALID := .T.
    EndIf

Return

/*/{Protheus.doc} MIChkCols
	Función utilizada para realizar la validación de prorrateo de Multi Naturaleza.
	@type  Function
	@author raul.medina
	@since 10/2023
	@param
        aHeaderChk - array - Campos del encabezado.
        aColsChk - array - Items del prorreteo.
        nCheck - numerico - linea a ser verificada
	@return 
	/*/
Function MIChkCols(aHeaderChk, aColsChk, nCheck)
Local aArea		:= GetArea()
Local lRet		:= .T.
Local nY        := 0
Local cMsg      := ""

Default aHeaderChk 	:= {}
Default aColsChk 	:= {}
Default nCheck      := 1


For nY := 1 to Len(aHeaderChk)
	If X3Obrigat(aHeaderChk[nY,2]) .And. !aColsChk[nCheck,Len(aColsChk[nCheck])] .And. Empty(aColsChk[nCheck,nY])
        cMsg += STR0009 + STR0011 + CRLF //"Problema: " "Uno o algunos campos obligatorios no se completaron en el objeto Grilla."
        cMsg += FwSX2Util():GetX2Name(GetSx3Cache(aHeaderChk[nY,2], "X3_ARQUIVO")) + CRLF
        cMsg += STR0012 + AllTrim(FwX3Titulo(aHeaderChk[nY,2])) + CRLF //"Campo: "
        cMsg += STR0013 + AllTrim(Str(nCheck)) //"Linea: "
        cMsg += CRLF
        cMsg += STR0010 +  STR0014 //"Solucion: "  "Complete los campos cuyos títulos fueron indicados."

		MsgInfo(cMsg, STR0015) //"Obligatorio"
        lRet := .F.
		Exit
	EndIf
Next nY

RestArea(aArea)
Return lRet

/*/{Protheus.doc} MLxTOkSEV
	Función utilizada para realizar la validación de prorrateo de Multi Naturaleza.
	@type  Function
	@author raul.medina
	@since 10/2023
	@param
        aHeader - array - Campos del encabezado.
        aCols - array - Items del prorreteo.
	@return 
	/*/
Function MLxTOkSEV(aHeader, aCols)
Local lRet      := .T.
Local nX        := 0
Local nUsadoSEV := Len(aHeader)
Local nPPerc    := aScan(aHeader,{|x| AllTrim(x[2])=="EV_PERC"})
Local nSoma     := 0

Default aHeader := {}
Default aCols   := {}

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//Verifica si l suma de los porcentajes es 100%
	For nX := 1 To Len(aCols)
		If !aCols[nX][nUsadoSEV+1]
			If aCols[nX][nPPerc]<>0
				nSoma += aCols[nX][nPPerc]
			EndIf
		EndIf
	Next nX
	If nSoma <> 100 .And. nSoma <> 0
        MsgInfo(STR0006+TransForm(nSoma,"@E 999.99%"),STR0005)//Porcentaje alcanzado == >   Multi naturaleza
		lRet := .F.
	EndIf

Return lRet

/*/{Protheus.doc} RatMulTiNat
	Función utilizada para realizar la actualización de los valores del prorrateo de Multi Naturaleza.
	@type  Function
	@author raul.medina
	@since 10/2023
	@param
        oModelSEV -  - submodelo correspondiente a la tabla SEV.
        cTipoDoc - caracter - numero de documento que está siendo procesado.
        nBaseDup - numerico - Valor de la base a ser prorrateada.
	@return 
	/*/
Function MActValSEV(oModelSEV, cTipoDoc, nBaseDup)
Local nX            := 0
Local nVal          := 0
Local nValDist      := 0
Local nUlt          := 0
Local nDec	        := GetSx3Cache("EV_VALOR","X3_DECIMAL")
Local oTipoDoc      := TipoDoc():New()

Default cTipoDoc    := ""
Default nBaseDup    := 0

    
    oTipoDoc:SetTipoDoc(cTipoDoc)
    If oTipoDoc:ValidMultiNatureSE1() .or. oTipoDoc:ValidMultiNatureSE2() .and. nBaseDup > 0
        If oModelSEV:IsUpdated()
            nUlt := oModelSEV:Length()
            For nX := 1 To nUlt
                oModelSEV:GoLine(nX)
                If !oModelSEV:IsDeleted()
                    If nX == nUlt
                        nVal := nBaseDup - nValDist
                    Else
                        nVal := ((oModelSEV:GetValue("EV_PERC") / 100) * nBaseDup)
                        nVal := Round(NoRound(nVal,nDec+1),nDec)
                    EndIf
                    nValDist += nVal
                    oModelSEV:LoadValue("EV_VALOR", nVal)
                EndIf
            Next
            If !IsBlind()
                MsgInfo(STR0008,STR0005)//"Los valores del prorrateo de multi naturalezas fueron actualizados."   Multi naturaleza
            EndIf
        EndIf
    EndIf

Return

/*/{Protheus.doc} UpdTitMod
	Función utilizada para actualizar los valores de los títulos.
	@type  Function
	@author raul.medina
	@since 11/2023
	@param
        oModel -  - Model que está siendo procesado.
        cModel - caracter - Nombre de modelo utilizado para el encabezado.
	@return 
	/*/
Function UpdTitMod(oModel, cModel)
Local cDup      := ""
Local nX        := 0
Local nBaseDup  := 0

Default cModel  := ""

    cDup := oModel:GetModel("DUP_DETAIL"):GetValue("DUP_PREFIX") + "³"
    cDup += oModel:GetModel("DUP_DETAIL"):GetValue("DUP_NUM") + "³ "
    cDup += Left(oModel:GetModel("DUP_DETAIL"):GetValue("DUP_PARCEL"), 1) + " ³"
    cDup += DTOC(oModel:GetModel("DUP_DETAIL"):GetValue("DUP_VENCTO")) + "³ "
    cDup += Transform(oModel:GetModel("DUP_DETAIL"):GetValue("DUP_VALOR"),PesqPict("SE2","E2_VALOR"))

    oModel:GetModel("DUP_DETAIL"):LoadValue("DUP", cDup)

    For nX := 1 To oModel:GetModel("DUP_DETAIL"):Length()
        nBaseDup += oModel:GetModel("DUP_DETAIL"):GetValue("DUP_VALOR", nX)
    Next

Return 

/*/{Protheus.doc} UpdTrigger
	Función utilizada para actualizar los disparadores 
	@type  Function
	@author raul.medina
	@since 12/2023
	@param
        oSubModel -  - submodelo que está siendo procesado.
	@return 
	/*/
Function UpdTrigger(oSubModel)
Local nX        := 0
Local cBloc     := ""

    For nX := 1 To Len(oSubModel:GetTriggers())
        cBloc := GetCbSource(oSubModel:GetTriggers()[nX][4])
        If "A103Trigger" $ cBloc
            cBloc := StrTran( cBloc, "A103Trigger", "LxTrigger" )
            oSubModel:GetTriggers()[nX][4] := &(cBloc)
        ElseIf oSubModel:GetTriggers()[nX][1] == "D1_VALDESC" .and. "M->D1_DESC := 0" $ cBloc
            cBloc := StrTran( cBloc, "M->D1_DESC := 0", "LxValDesc()" )
            oSubModel:GetTriggers()[nX][4] := &(cBloc)
        ElseIf oSubModel:GetTriggers()[nX][1] == "D1_DESC" .and. 'M->D1_VALDESC := Round(M->D1_TOTAL*M->D1_DESC/100,TamSx3("D1_VALDESC")[2])' $ cBloc
            cBloc := StrTran( cBloc, 'M->D1_VALDESC := Round(M->D1_TOTAL*M->D1_DESC/100,TamSx3("D1_VALDESC")[2])', "LxDesc()" )
            oSubModel:GetTriggers()[nX][4] := &(cBloc)
        ElseIf oSubModel:GetTriggers()[nX][1] == "D1_DESC" .and. 'M->D1_VALDESC := NoRound(M->D1_TOTAL*M->D1_DESC/100,TamSx3("D1_VALDESC")[2])' $ cBloc
            cBloc := StrTran( cBloc, 'M->D1_VALDESC := NoRound(M->D1_TOTAL*M->D1_DESC/100,TamSx3("D1_VALDESC")[2])', "LxDesc(.F.)" )
            oSubModel:GetTriggers()[nX][4] := &(cBloc)
        EndIf
    Next

Return

/*/{Protheus.doc} LxTrigger
	Función utilizada para realizar la llamada de la función A103Trigger
	@type  Function
	@author raul.medina
	@since 12/2023
	@param
        cCampo - caracter - campo que será validado en la función A103Trigger.
	@return 
        lRet - logico - retorno de la función A103Trigger
	/*/
Function LxTrigger(cCampo)
Local lRet      := .F.

Private bRefresh    := {||}

Default cCampo      := ""

    lRet := A103Trigger(cCampo)

Return lRet

/*/{Protheus.doc} LxUpdItems
Función responsabe por actualizar campos del encabezado en todos los items (Documento/Serie).
@type 		Function
@param 		oModel	    ,       	,Model que está siendo procesado.
@param 		cModelID	,caracter	,Identificador do sub-modelo.
@param 		cField     	,caracter	,Identificador del campo a actualizar.
@param 		xValue  	,       	,Valor recibido del campo.
@Return     
@author 	raul.medina	
@version	12.2.2210 / Superior
@since		12/2023
/*/
Function LxUpdItems(oModel, cModelID, cField, xValue)
Local nX        := 0
Local nline     := 0
Local oSubModel 

Default cModelID    := ""
Default cField      := ""
Default xValue      := ""

    oSubModel := oModel:GetModel(cModelID)
    nline := oSubModel:GetLine()
    For nX := 1 To oSubModel:Length()
        oSubModel:GoLine(nX)
        If !oSubModel:IsDeleted()
            oSubModel:LoadValue(cField, xValue)
        EndIf
    Next
    oSubModel:GoLine(nline)

Return

/*/{Protheus.doc} LxModPE
Función responsabe para verificar si deben de ser ejectados los PE.
@type 		Function
@param 		cFunname	,caracter	,Nombre de la rutina ejecutada.
@param 		cPE     	,caracter	,Nombre del PE que está siendo verificado.
@Return     lRet        ,logico     ,Retorno logico para la ejecución de los PE.
@author 	raul.medina	
@version	12.2.2210 / Superior
@since		02/2024
/*/
Function LxModPE(cFunname, cPE)
Local lRet      := .T.

Default cFunname    := Funname()
Default cPe         := ""

    If oModFunc == Nil
        oModFunc := LxGetMFunc()
    EndIf

    If oModPE == Nil
        oModPE := LxGetMPE()
    EndIf

    //Si la rutina se encuentra en el json oModFunc no será ejecutado, a menos que el PE de encuentre dentro del json oModPE (Excepciones)
    If oModFunc:HasProperty(cFunname) .and. !(oModPE:HasProperty(cPE))
        lRet := .F.
    EndIf

Return lRet

/*/{Protheus.doc} LxGetMFunc
Función responsabe de realizar el llenado de documentos en modelos.
@type 		Function
@Return     oJson, Json, Json con el nombre de los fuentes.
@author 	raul.medina	
@version	12.2.2210 / Superior
@since		02/2024
/*/
Function LxGetMFunc()
Local oJson
Local aFuncMod  := {"COMA221", "COMA222", "COMA223", "COMA224", "LOCXNFE", "LOCXNCE", "LOCXNDE", "LOCXREN"}

    oJson := LxGenJson(aFuncMod)

Return oJson

/*/{Protheus.doc} LxGetMPE
Función responsabe de realizar el llenado de los PE's que si deben de ser ejecutados.
@type 		Function
@Return     oJson, Json, Json con el nombre de los PE's.
@author 	raul.medina	
@version	12.2.2210 / Superior
@since		02/2024
/*/
Function LxGetMPE()
Local oJson
Local aFuncMod  := {"LOCXPE35"}

    oJson := LxGenJson(aFuncMod)

Return oJson

/*/{Protheus.doc} LxGenJson
Función responsabe de realizar el llenado de los PE's que si deben de ser ejecutados.
@type 		Function
@param 		aElements, array, Array con los elementos que serán incluidos en el json.
@Return     oJson, Json, Json con los elementos recibidos.
@author 	raul.medina	
@version	12.2.2210 / Superior
@since		02/2024
/*/
Function LxGenJson(aElements)
Local nX        := 0
Local oJson

Default aElements   := {}

    oJson := JsonObject():new()

    For nX := 1 To Len(aElements)
        oJson[aElements[nX]] := aElements[nX]
    Next

Return oJson

/*/{Protheus.doc} MxChkPE
Función responsable de verificar los PE que están siendo utilizados por el usuario y notificar que no serán considerados.
@type 		Function
@author 	raul.medina	
@version	12.2.2210 / Superior
@since		02/2024
/*/
Function MxChkPE(cProgram)
Local nX        := 0
Local nPauseDays:= 30
Local aPE       := {}
Local aLoad     := {}
Local cPEComp   := ""
Local cTask     := ""
Local cShow     := ""
Local lCheck    := .F.
Local lChkMsg   := .F.
Local lFwIsAdm  := FwIsAdmin()
Local oButton
Local oCheckBox
Local oGroup
Local oPanel
Local oSay1
Local oSay2
Local oDlg
Local oProfile

Default cProgram    := Funname()

    cTask := cProgram + "PE"

    If !lFwIsAdm
        oProfile  := FWProfile():New()
        oProfile:SetUser( RetCodUsr() )
        oProfile:SetProgram( cProgram )
        oProfile:SetTask( cTask )
        aLoad := oProfile:Load()
        cShow := Iif(Empty(aLoad), "00000000", aLoad[1])
    EndIf

    // restablece el control de nPauseDays días y vuelve a mostrar la pantalla de advertencia
    If cShow <> "00000000" .and. STOD(cShow) + nPauseDays <= dDatabase
        cShow := "00000000"
        If !lFwIsAdm
            oProfile:SetProfile({cShow})
            oProfile:Save()
        EndIf
    ENDIF
    
    lChkMsg := cShow == "00000000"

    If lChkMsg

        aPE :=  {"LOCXPE04", "LOCXPE05", "LOCXPE06", "LOCXPE07", "LOCXPE08", "LOCXPE09", "LOCXPE11", "LOCXPE13", "LOCXPE14", "LOCXPE15",;
                    "LOCXPE16", "LOCXPE17", "LOCXPE19", "LOCXPE24", "LOCXPE30", "LOCXPE37", "LOCXPE38", "LOCXPE45", "LOCXPE62", "LOCXPE68",;
                    "LOCXPE72", "LOCXPE74", "A103CND2", "LXHORANFIS", "LOCXDREM", "M100L001", "MAGENTE", "MT100GRV", "A103VLR", "GQREENTR",;
                    "M466SF1", "A466CRTO", "M466SD1", "MT100TOK", "MT100LOK", "A100F4CP", "M460NUM", "M101SER", "LOCXPDV", "LOCXPERG", "LOCXOKPG",;
                    "DESAPV", "LOCXPE73", "MT462MNU", "LOCXFILT", "LOCXPE61", "LOCXPE33", "LOCXPE01", "LOCXPE02", "LOCXPE03", "NFCPOSRODPE",;
                    "LOCXS333", "LOCXPE48", "LOCXPE43", "LOCXPE4", "LOCXPE9", "LOCXPE7", "LOCXPE28", "LOCXPE29", "LOCXPE49", "LOCXPE34", "LOCXPE46",;
                    "LOCXPE6","LOCXPE5", "LOCXPE8", "LOCXPE54", "LOCXPE66", "LOCXPE47", "LOCXPE10", "LOCXPE76"}

        For nX := 1 to Len(aPE)
            If ExistBlock(aPE[nX])
                cPEComp += Iif(!Empty(cPEComp),", ", "") + aPE[nX]
            EndIf
        Next nX
    
        If !Empty(cPEComp)
            DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0016) FROM 000, 000  TO 250, 500 COLORS 0, 16777215 PIXEL //"Puntos de Entrada"

                @ 000, 000 MSPANEL oPanel SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
                @ 005, 012 GROUP oGroup TO 080, 237 PROMPT OemToAnsi(STR0018) OF oPanel COLOR 0, 16777215 PIXEL //"Atención"
                @ 017, 017 SAY oSay1 PROMPT OemToAnsi(STR0017 + cPEComp) SIZE 215, 060 OF oPanel COLORS 0, 16777215 PIXEL //"Los siguientes puntos de entrada no serán considerados: "
                @ 090, 012 SAY oSay2 PROMPT OemToAnsi(STR0019) SIZE 100, 007 OF oPanel COLORS 0, 16777215 PIXEL //"Documentación puntos de entrada"
                If !lFwIsAdm
                    @ 100, 012 CHECKBOX oCheckBox VAR lCheck PROMPT OEMToAnsi(STR0020) SIZE 120, 008 OF oPanel COLORS 0, 16777215 PIXEL //"No exhibir nuvamente"
                EndIf
                @ 095, 200 BUTTON oButton PROMPT "OK" SIZE 037, 012 OF oPanel PIXEL

                oSay2:bLClicked := {|| ShellExecute("open", "https://tdn.totvs.com/x/7tJaM", "", "", 1) }
                oButton:bLClicked := {|| oDlg:End() }

            ACTIVATE MSDIALOG oDlg CENTERED

            If !lFwIsAdm .and. lCheck		
                cShow := dtos(dDataBase)	
                oProfile:SetProfile({cShow, cPEComp})
                oProfile:Save()
            EndIf
        EndIf
    EndIf

Return

/*/{Protheus.doc} LxF3Round
Función responsable de realizar el redondeo de los campos de impuestos para el libro fiscal.
@type 		Function
@param 		aNfLibro, array, Array con los el encabezado y los items del libro fiscal [[Encabezado][[Linea1],[Linea2],...]]
@Return     
@author 	raul.medina	
@version	12.2.2210 / Superior
@since		06/2025
/*/
Static Function LxF3Round(aNfLibro)
Local nX        := 0
Local nY        := 0
Local nLen      := 0
Local nLenIt    := 0

Default aNfLibro := {{},{}}

    nLen := Len(aNfLibro[1])
    nLenIt := Len(aNfLibro[2])
    For nX := 1 To nLen
        If Subs(aNfLibro[1][nX],1,6) $ "F3_VAL|F3_BAS|F3_RET|F3_DES"
            For nY := 1 To nLenIt
                aNfLibro[2][nY][nX] := Round(aNfLibro[2][nY][nX],MsDecimais(1))
            Next nY
        EndIf
    Next nX

Return

/*/{Protheus.doc} Impostos
	Realiza la cración de un objeto para informar los impuestos..
	@type  Class
	@author raul.medina
	@since 
	@param 
	@return 
	/*/
Class Impostos

    public DATA aArray As array

    public Method New() Constructor
    public Method GetModImp()

EndClass

/*/{Protheus.doc} New
	Realiza la declaración de un nuevo objeto con sus atributos.
	@type  Method
	@author raul.medina
	@since 
	@param 
	@return 
	/*/
Method New() Class Impostos

    self:aArray := {}

Return self

/*/{Protheus.doc} GetModImp
	Realiza la asignación de propiedades de los campos.
	@type  Method
	@author raul.medina
	@since 
	@param oImpMod - - Submodelo correspondiente al calculo de impuestos..
	@return 
	/*/
Method GetModImp(oImpMod) Class Impostos
Local nX        := 0
Local nPos      := 0

    For nX := 1 To oImpMod:Length()
        nPos := aScan(self:aArray, {|x| x[1] == oImpMod:GetValue("IMP_COD", nX)})
        If nPos == 0
            aadd(self:aArray,{oImpMod:GetValue("IMP_COD", nX), oImpMod:GetValue("IMP_DESC", nX), oImpMod:GetValue("IMP_BASIMP", nX), oImpMod:GetValue("IMP_VALIMP", nX)})
        Else
            self:aArray[nPos][3] += oImpMod:GetValue("IMP_BASIMP", nX)
            self:aArray[nPos][4] += oImpMod:GetValue("IMP_VALIMP", nX)
        EndIf
    Next

Return

