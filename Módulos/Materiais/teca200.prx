#INCLUDE "PROTHEUS.CH"
#INCLUDE "TECA200.CH"
#INCLUDE "TBICONN.CH"


Static oGSTmpTb 
/*/


Ŀ
Funo     TECA200   Autor  Eduardo Riera          Data  17/09/98 
Ĵ
Descrio  Contrato Manutencao                                        
Ĵ
 Uso       TECA200                                                    
ٱ


/*/

Function TECA200( cRotina, xAutoCab, xAutoItens, nOpcAuto, xAutoGrupo )

//Ŀ
// Receber os dados das cores do Ponto de Entrada               
//
Local aCores	:= {}

//Ŀ
// Define Variaveis                                     
//
Private cCadastro	:= STR0006	//"Contrato de Manutencao"
Private aRotina	:= MenuDef()


//Ŀ
// Endereca a funcao de BROWSE                                  
//

Private bFiltraBrw 	:= {|| Nil}
Private aAutoCab	:= {}				// Cabealho da rotina automtico
Private aAutoItens	:= {}				// Itens da rotina automtica
Private aAutoGrupo	:= {}				// Itens da rotina automtica
Private lAt200Auto	:= .F.

//Ŀ
//Se existir o ponto de entrada ele armazena no aCores as cores
//
If ExistBlock('AT200legen')
	aCores := ExecBlock('AT200Legen', .F., .F., {})
EndIf

If	xAutoCab <> Nil .AND. xAutoItens <> NIL

	lAt200Auto := .T.

	aAutoCab   := xAutoCab
	aAutoItens := xAutoItens
	aAutoGrupo := xAutoGrupo

	MBrowseAuto(nOpcAuto,Aclone(aAutoCab),"AAH")
Else
	//Ŀ
	// Se a variavel aCores for utilizada se existir o ponto       
	// Ele ira criar a coluna de cores caso contrario ira ser normal
	//
	If len(aCores) > 0
		mBrowse( 6, 1,22,75,"AAH",,,,,, aCores)
	 Else
		mBrowse( 6, 1,22,75,"AAH")
	EndIf
EndIf

AAH->( DbSetOrder(1) )
AAH->( DbClearFilter() )

If VALTYPE(oGSTmpTb) == 'O'
	oGSTmpTb:Close()
	TecDestroy(oGSTmpTb)
EndIf



Return

/*/

Ŀ
Funo     MenuDef   Autor  Conrado Q. Gomes       Data  08.12.06 
Ĵ
Descrio  Definio do aRotina (Menu funcional)                      
Ĵ
Sintaxe    MenuDef()                                                  
Ĵ
Parametros                                                            
Ĵ
 Uso       TECA200                                                    
ٱ


/*/
Static Function MenuDef()
	//Ŀ
	// Define Array contendo as Rotinas a executar do programa      
	// ----------- Elementos contidos por dimensao ------------     
	// 1. Nome a aparecer no cabecalho                              
	// 2. Nome da Rotina associada                                  
	// 3. Usado pela rotina                                         
	// 4. Tipo de Transao a ser efetuada                          
	//    1 - Pesquisa e Posiciona em um Banco de Dados             
	//    2 - Simplesmente Mostra os Campos                         
	//    3 - Inclui registros no Bancos de Dados                   
	//    4 - Altera o registro corrente                            
	//    5 - Remove o registro corrente do Banco de Dados          
	//    6 - Alteracao sem inclusao de registro                    
	//

	Local aRotina := {	{STR0001	,"AxPesqui"		,0	,1	,0	,.F.	}	,;	//"Pesquisar"
						{STR0002	,"At200Manut"	,0	,2	,0	,.T.	}	,;	//"Visualizar"
						{STR0003	,"At200Manut"	,0	,3	,0	,.T.	}	,;	//"Incluir"
						{STR0004	,"At200Manut"	,0	,4	,0	,.T.	}	,;	//"Alterar"
						{STR0005	,"At200Manut"	,0	,5	,0	,.T.	}	,;	//"Excluir"
						{STR0007	,"At200ProcR"	,0	,6	,0	,.T.	}	,;	//"Reajuste"
						{STR0011	,"MsDocument"	,0	,4	,0	,.T.	}	}	//"Conhecimento"

	//Ŀ
	//Se existir o ponto de entrada ele cria no browse a tag legenda
	//
	If ExistBlock('At200Legen')
		AADD(aRotina, {STR0034, "U_At200Legen",0,6,0,.T. }) //Legenda
	EndIf

Return(aRotina)


/*


Ŀ
Funo    At200Manut Autor  Sergio Silveira        Data 04/05/2011
Ĵ
Descrio  Programa de manutencao de Contrato Manutencao              
Ĵ
Sintaxe e  Void At200Manut(ExpC1,ExpN1,ExpN2)                         
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
 Uso       TECA200                                                    
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                   
Ĵ
ٱ


*/
Function At200Manut(cAlias,nReg,nOpc)

static aIndexAA3 :={}
static cFilAA3 	 := ""

Local aObjects	 := {} 					// Contm os tamanhos dos objetos da tela
Local aPosObj	 := {} 					// Posio dos objetos
Local aSizeAut	 := MsAdvSize()			// Array para auto ajuste de tamanho
Local aTravas    := {}					// Lista de registros travados
Local aSavaRot   := {}		// Backup da aRotina
Local aMarcados	 := {}					// Registros inicialmente marcados
Local aColsCob	 := {}					// Registros da tabela quantidade x cont. manut x cobertura
Local aHeadCob	 := {}					// Contem os nomes dos campos do aHeader
Local aButtons   := {}
Local aHeader    := {}
Local aCols      := {}

Local cIndAA3 	 := CriaTrab(,.F.)		// Tabela temporria do MarkBrowser
Local cMarca     := GetMark(,'AA3','AA3_OK')	// String utilizada para marcar um item
Local cAbrangOld := Nil					// Backup da abragncia do contrato

Local bFiltraBRW := { || .t. }

Local lInverte   := .F.					// Se a marcao deve aparecer invertida
Local lTravas    := .T.					// Se todos os registros requeridos foram travados
Local lInclui    := .F.
Local lAltera    := .F.
Local lExclui    := .F.
Local lVisual    := .F.
Local lMarca     := .F.

Local nLinIni    := 0
Local nColIni    := 0
Local nSaveSX8 	 := GetSX8Len()
Local nOpcA 	 := 0					// Opo selecionada no Dialog
Local nOpcx      := 0
Local nLoop      := 0
Local nPosFab    := 0
Local nPosLoja   := 0
Local nPosProd   := 0
Local nPosNSer   := 0
Local nPosMark   := 0
Local lAtuGrpC   := .F.
Local oHeaderLn  := Nil
Local oItnLn     := Nil
Local oLayer    := Nil
Local aFilTmp	:= {}

Local oDlg		 := Nil					// Objeto Dialog
Local oEnchoice  := Nil
Local oGetd      := NIL
Local oMarkAll   := Nil

Local aStruField := {}
Local cField     := ""
Local nC         := 0

private oMark    := NIL
Private aTela    := {}				// Array da tela
Private aGets    := {}				// Array dos gets
Private aAA3TMP	:= {}
Private aStruAA3    := {}
Private aColumns    := {}
Private oCheck	:= Nil
Private lMarkAll	:= .F.


FATLOGUTIL()
If aRotina == Nil
	aRotina := MenuDef()
EndIf
aSavaRot:= aClone(aRotina)		// Backup da aRotina

nOpcx      := aRotina[ nOpc, 4 ]
aRotina := Nil

lVisual := ( nOpcx == 2 )
lInclui := ( nOpcx == 3 )
lAltera := ( nOpcx == 4 )
lExclui := ( nOpcx == 5 )

If lAltera .or. lExclui
	//Ŀ
	//Trava o registro corrente                            
	//
	If ( !AtTravaReg(cAlias, aTravas) )
		lTravas := .F.
	Endif

Else
	lTravas := .T.
EndIf

//Ŀ
// Cria Variaveis de Memoria da Enchoice                
//
aStruField := FWSX3Util():GetAllFields("AAH")
If Len(aStruField) > 0
	For nC := 1 to Len(aStruField)
		cField := AllTrim(aStruField[nC])
		If lInclui
			M->&(cField) := CriaVar(cField)
		Else
			If GetSX3Cache(cField,"X3_CONTEXT") == "V"
				M->&(cField) := CriaVar(cField)
			Else
				M->&(cField) := AAH->(FieldGet(FieldPos(cField)))
			EndIf
		EndIf
	Next nC
EndIf

If !lInclui
	SA1->( DbSetOrder( 1 ) )
	SA1->( MsSeek( xFilial("SA1")+M->AAH_CODCLI+M->AAH_LOJA ) )
	M->AAH_NOMCLI := SA1->A1_NOME
EndIf

If lInclui .Or. lAltera

	//Ŀ
	//Faz selecao para markbrowse                                             
	//
	FATLOGUTIL()
	aAA3TMP := At200MBFil(.F., If( lAltera, 1, 2 ), @aFilTmp )
	FATLOGUTIL()

	If lAltera
		#IFDEF TOP
			AA3->( DbSetOrder(2) )
			AA3->( DbSeek(M->AAH_CONTRT) )
		#ELSE
			AA3->( DbGotop() )
		#ENDIF
		(aAA3TMP[1])->( DbGotop() )
		While !(aAA3TMP[1])->( Eof() ) //IndRegua
			If ( AtTravaReg("AA3", aTravas) )
				If ( (aAA3TMP[1])->AA3_CONTRT == M->AAH_CONTRT )
					RecLock(aAA3TMP[1])
					(aAA3TMP[1])->AA3_OK := cMarca
					aAdd( aMarcados, (aAA3TMP[1])->(RECNO()) )
				EndIf
			Else
				lTravas := .F.
			Endif

			(aAA3TMP[1])->( DbSkip() )
		EndDo

	EndIf

Else

	//Ŀ
	//Montagem aHeader, aCols
	//

	If Len(aHeader) == 0 .AND. Len(aCols) == 0
		cSeek := xFilial("AA3")+M->AAH_CONTRT
		cWhile:= "AA3->AA3_FILIAL+AA3->AA3_CONTRT"

		FillGetDados(	nOpc			,"AA3"		,2				,cSeek			,;
						{|| &cWhile }	,{|| .T. }	,/*aNoFields*/	,/*aYesFields*/	,;
						/*lOnlyYes*/	,/*cQuery*/	,/*bMontCols*/	,/*lEmpty*/, aHeader, aCols	)
	Endif

EndIf

AAH->(DbGoTo(nReg))
cAbrangOld    := M->AAH_ABRANG

If ( lTravas )

	DbSelectArea("AAH")

	If Type("lAt200Auto")=="U" .OR. !lAt200Auto

		// Determina o tamanho dos objetos dentro da Dialog

		aObjects := {}

		AAdd( aObjects	, { 100, 100, .T., .T. } )
		AAdd( aObjects	, { 100, 100, .T., .T. } )

		aInfo  	:= { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 }
		aPosObj	:= MsObjSize( aInfo, aObjects )

		//Ŀ
		//Monta a Enchoice                                                        
		//
		DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSizeAut[7],0 TO aSizeAut[6],aSizeAut[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME

		oLayer := FwLayer():New()

		oLayer:init(oDlg,.F.)

		oLayer:addLine("HEADER", 45, .F.)
		oLayer:addLine("ITENS", 45, .F.)
		oLayer:addLine("MARCA", 5, .F.)

		oHeaderLn 	:= oLayer:getLinePanel("HEADER")
		oItnLn    	:= oLayer:getLinePanel("ITENS")
		oMarkAll	:= oLayer:GetLinePanel("MARCA")

		//Ŀ
		// Montagem da enchoice                                         
		//
		oEnchoice := MsMGet():New( "AAH" ,nReg,nOpc,,,,,aPosObj[1],,3,,,,oDlg,,.T.,, /*"aTela"*/ )

		If lInclui .Or. lAltera

			//Ŀ
			//Monta a MarkBrowse                                                      
			//
			oMark := FwMarkBrowse():New()
			oMark:SetFieldMark( "AA3_OK" )
			oMark:SetOwner(oItnLn)
			oMark:SetDataQuery(.F.)
			oMark:SetDataTable(.T.)
			oMark:SetAlias( aAA3TMP[1] )
			oMark:SetDescription("")
			oMark:SetMenuDef("")
			oMark:SetColumns(aColumns)
			oMark:AddButton(STR0002, {|| At200VisBs((oMark:Alias())->RECNO)},,1)
			oMark:SetMark(cMarca, aAA3TMP[1], "AA3_OK" )
			oMark:SetCustomMarkRec({|| At200CMkB1(oMark) })
			oMark:SetInvert(.F.)
			oMark:SetTemporary(.T.)
			oMark:oBrowse:SetDBFFilter(.T.)
			oMark:oBrowse:SetUseFilter(.T.) //Habilita a utilizao do filtro no Browse
			oMark:oBrowse:SetFilterDefault("") //Indica o filtro padro do Browse
			oMark:oBrowse:SetFieldFilter(aFilTmp)
			oMark:Activate()

			//Monta o Objeto para a Marcao de Todos os Itens
			oCheck        	:= TCHECKBOX():Create(oMarkAll)
			oCheck:cName    	:= 'oCheck'
			oCheck:cCaption 	:= STR0033
			oCheck:nLeft  	:= 05
			oCheck:nTop     	:= 010
			oCheck:nWidth  	:= 300
			oCheck:nHeight  	:= 17
			oCheck:lShowHint	:= .T.
			oCheck:lReadOnly 	:= .F.
			oCheck:cVariable 	:= 'lMarkAll'
			oCheck:bSetGet  	:= {|u| If(PCount()>0, lMarkAll:=u, lMarkAll) }
			oCheck:bChange 	:= {|oSelf| At200MkAll(oMark,lMarkAll,oSelf) }
			oCheck:lVisibleControl := .T.
			oCheck:Align := CONTROL_ALIGN_LEFT

		Else
			//Ŀ
			//Monta a getdados                                                        
			//
			oGetd := MsNewGetDados():New( aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpcx,/*linhaok*/,/*tudook*/,/*inicpos*/,/*aalter*/,/*freeze*/,300,nil,/*superdel*/, /*DelOk()*/,oDlg,aHeader,aCols)
		EndIf

		aRotina := aSavaRot
		ACTIVATE MSDIALOG oDlg ON INIT AT200Bar(oDlg,{||nOpcA:=1,If(Obrigatorio( oEnchoice:aGets,oEnchoice:aTela) .And. Iif(Inclui .Or. Altera, Tec200TdOk(cMarca,oMark), .T.),oDlg:End(),nOpcA:=0)},{||nOpcA:=0,oDlg:End()},nOpcx) VALID At200Valid()

	Else

		cAlias := 'AAH'

		If lInclui .Or. lAltera

			If Len(aGets) == 0 .AND. Len(aTela) == 0
				EnchAuto(cAlias,aAutoCab,{|| Obrigatorio( aGets,aTela)})
			EndIf

			If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio( aGets,aTela)})

				//Ŀ
				// Varre os itens a serem associados. Verifica se o cliente / loja e compativel 
				//

				AA3->( dbSetOrder( 4 ) )

				For nLoop := 1 to Len( aAutoItens )

					aLinha := aAutoItens[nLoop]

					nPosFab  := AScan( aLinha, { |x| x[1] == "AA3_CODFAB" } )
					nPosLoja := AScan( aLinha, { |x| x[1] == "AA3_LOJAFA" } )
					nPosProd := AScan( aLinha, { |x| x[1] == "AA3_CODPRO" } )
					nPosNSer := AScan( aLinha, { |x| x[1] == "AA3_NUMSER" } )
					nPosMark := AScan( aLinha, { |x| x[1] == "M_A_R_K_" } )

					If AA3->( dbSeek( xFilial( "AA3" )+aAutoItens[nLoop,nPosFab,2]+aAutoItens[nLoop,nPosLoja,2]+aAutoItens[nLoop,nPosProd,2]+aAutoItens[nLoop,nPosNSer,2]))

						If ( M->AAH_ABRANG =="1" .And. M->AAH_CODCLI == AA3->AA3_CODCLI .And. M->AAH_LOJA == AA3->AA3_LOJA ) .Or. ;
							( M->AAH_ABRANG =="2" .And. M->AAH_CODCLI == AA3->AA3_CODCLI )

							//Ŀ
							// Marca o item do AA3 ( simula markbrowse ) 
							//

							Reclock( "AA3", .F. )

							AA3->AA3_OK := If( aAutoItens[nLoop,nPosMark,2], cMarca, "" )

							If lAltera .And. aAutoItens[nLoop,nPosMark,2]
								aAdd( aMarcados, AA3->( Recno() ) )
							EndIf

							AA3->( Msunlock() )

							nOpca := 1

					    EndIf

					EndIf

		        Next nLoop

		        lMarca := .T.

			EndIf

		ElseIf lExclui .or. lVisual

			If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio( aGets,aTela)})
				nOpcA := 1
			EndIf

		EndIf

	EndIf

	If !lVisual
		If ( nOpcA == 1 )
			IF (M->AAH_CODGRP <> AAH->AAH_CODGRP) .AND. !Empty(M->AAH_CODGRP)
				If (Type("lAt200Auto")=="U" .OR. !lAt200Auto)
					If (lAtuGrpC := MsgYesNo(STR0019,STR0006))
						aColsCob := AT200AjuAc(nOpcx,M->AAH_CODGRP,M->AAH_GRPDES,@aHeadCob)
					EndIf
				Else
					If aAutoGrupo <> NIL
				   		aColsCob := AT200AjuAc(nOpcx,M->AAH_CODGRP,M->AAH_GRPDES,@aHeadCob)
					EndIf
				EndIf
			EndIf

		EndIf
		If ( nOpcA == 1 )
			Begin Transaction

				lExec := .F.

				If lInclui
					lExec := ( aT200Grava(1, NIL       ,aColsCob ,aHeadCob, NIL     ,NIL   , If( lMarca, cMarca, nIL ),lAtuGrpC ) )
				ElseIf lAltera
					lExec := ( aT200Grava(2, aMarcados ,aColsCob ,aHeadCob, NIL     ,NIL   , If( lMarca, cMarca, nIL ),lAtuGrpC ) )
				Else
					lExec := ( aT200Grava(3, NIL       ,NIL      ,nil     , aHeader , aCols, If( lMarca, cMarca, nIL ),lAtuGrpC ) )
				EndIf

				If lExec
					EvalTrigger()
					While ( GetSX8Len() > nSaveSx8 )
						ConfirmSx8()
					EndDo
				EndIf
			End Transaction
		Endif
	EndIf

EndIf

While ( GetSX8Len() > nSaveSx8 )
	RollBackSx8()
EndDo

If lInclui .Or. lAltera
	//Ŀ
	// Finaliza o uso da funcao FilBrowse e retorna os indices padroes.       
	//
	#IFNDEF TOP
		EndFilBrw("AA3",aIndexAA3)
	#EndIf
EndIf

If !lVisual
	//Ŀ
	//Destrava os Registros                                                   
	//
	AtDestravaReg( aTravas )
EndIf

If VALTYPE(oGSTmpTb) == 'O'
 	oGSTmpTb:Close()
 	TecDestroy(oGSTmpTb)
EndIf

DbSelectArea("AAH")
aRotina := aSavaRot


Return(nOpcA)


/*/


Ŀ
Funcao    AT200Grava Autor  Eduardo Riera          Data  17.09.98 
Ĵ
Descrio  Atualizar o Arquivo de Contratos e as amarracoes           
Ĵ
Retorno    ExpL1 : Indica se foi possivel gravar                      
Ĵ
Parametros ExpN1 : 1 - Incluir , 2 - Alterar , 3 - Excluir            
           ExpA2 : Registros marcados antes da alterao pelo usurio 
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                   
Ĵ
Conrado Q.    14/03/07119088 Adicionado PE para manuseio dos itens  
                             da base instalada excludos do contrato
ٱ


/*/
Static Function AT200Grava(nOpcao, aMarcados, aColsCob, aHeadCob, aHeader, aCols, cMarca, lAtuGrpC)

Local aRecAA3	:= {}									// Lista de itens da base instalada marcados como parte do contrato
Local nCntFor	:= Nil									// Contador
Local bCampo	:= {|x| FieldName(x) }					// Pega o nome do campo
Local lGravou	:= .F.									// Se h itens da base instalada no contrato
Local nUsado	:= 0									// Quantidade de campos no aHeader
Local nPProd	:= 0									// Posio do campo cdigo do produto
Local nPNumSer	:= 0									// Posio do campo nmero de srie
Local nPCodFab	:= 0									// Posio do campo cdigo do fabricante
Local nPLojaFa	:= 0									// Posio do campo loja do fabricante
Local nPQtdLib  := 0									// Posio do campo quantidade liberada
Local nPModLib  := 0									// Posio do campo modo de liberacao
Local nLoop		:= 0									// Contador
Local lAltCobe	:= (M->AAH_CODGRP <> AAH->AAH_CODGRP)	// Se o grupo de cobertura for alterado atualiza o controle de saldo
Local lMarca    := .f.
Local cAliasAA3	:= ''
Local lDefTop    := .T.
Local lAT200AA3 := ExistBlock("AT200AA3")
Local lAT200DES := ExistBlock("AT200DES")

#IFDEF TOP
	lDefTop := .T.
#ELSE
 	lDefTop := .F.
#EndIf

Default aMarcados := {}
Default aColsCob  := {}
Default aHeadCob  := {}
Default lAtuGrpC  := (Len(aColsCob) > 0)

Private lMsErroAuto := .F.
FATLOGUTIL()
Do Case
	//Ŀ
	//A Inclusao e alteracao e efetuada com MarkBrowse                        
	//
	Case nOpcao <> 3

		aRecAA3 := {}

		If lDefTop .AND. (Type("lAt200Auto")=="U" .OR. !lAt200Auto)
			cAliasAA3 := Iif( nOpcao <> 3, aAA3TMP[1], "")
		   (cAliasAA3)->( dbGoTop() )
			While !(cAliasAA3)->( EOF() )
				If oMark:IsMark()
					lGravou := .T.
					aAdd(aRecAA3,(cAliasAA3)->RECNO)
					AA3->(dbGoto((cAliasAA3)->RECNO))
					RecLock( "AA3", .F. )
					AA3->AA3_OK := oMark:cMark
					AA3->( MsUnlock() )
				Else
					AA3->(dbGoto((cAliasAA3)->RECNO))
					RecLock( "AA3", .F. )
					AA3->AA3_CONTRT := ""
					AA3->( MsUnlock() )
				EndIf
				(cAliasAA3)->( dbSkip() )
			End
			AA3->(FKCommit())
		Else
			DbSelectArea("AA3")
			DbGotop() // IndRegua()
			While ( !AA3->( Eof() ) )

				If cMarca == NIL
					lMarca := ( IsMark("AA3_OK",ThisMark(),ThisInv()) )
				Else
					lMarca := ( IsMark("AA3_OK", cMarca, .f.  ) )
				EndIf

				If lMarca
					lGravou := .T.
					Aadd( aRecAA3, AA3->( Recno() ) )
				Else
					If !Empty(AA3->AA3_CONTRT) .And. AA3->AA3_CONTRT = M->AAH_CONTRT 
						RecLock( "AA3", .F. )
						AA3->AA3_CONTRT := ""
						AA3->( MsUnlock() )
					EndIf	
				EndIf
				AA3->( DbSkip() )
			EndDo

			AA3->(FKCommit())
		EndIf

		DbSelectArea("AAH")
		DbSetOrder(1)
		DbSeek(xFilial("AAH")+M->AAH_CONTRT)
		If TECAAHReco() .AND. M->AAH_NUMREC > 0
			If nOpcao == 1
				AT200Prov()
			ElseIf nOpcao == 2
				If M->AAH_VALOR <> AAH->AAH_VALOR .OR. M->AAH_CPAGPV <> AAH->AAH_CPAGPV .OR. M->AAH_CONPAG <> AAH->AAH_CONPAG;
					.OR. M->AAH_INICOB <> AAH->AAH_INICOB .OR. M->AAH_FIMCOB <> AAH->AAH_FIMCOB
					At210TiPr(M->AAH_VALOR, M->AAH_INICOB, M->AAH_FILIAL, M->AAH_CONTRT, M->AAH_CPAGPV)
					AT200Prov()
				EndIf
			EndIf
		EndIf
		RecLock("AAH",INCLUI)
		If ( lGravou )
			For nCntFor := 1 To FCount()
				If ( "FILIAL"$Field(nCntFor) )
					FieldPut(nCntFor,xFilial("AAH"))
				Else
					FieldPut(nCntFor,M->&(EVAL(bCampo,nCntFor)))
				EndIf
			Next nCntFor
		EndIf

		AAH->(FkCommit())

		For nLoop := 1 to Len( aRecAA3 )

			AA3->( dbGoto( aRecAA3[nLoop] ) )

			RecLock( "AA3", .F. )
			If ( Empty(AA3->AA3_CONTRT) .Or.;
					AA3->AA3_CONTRT <> M->AAH_CONTRT )
				AA3->AA3_DTCTAM := dDataBase
			EndIf
			AA3->AA3_CONTRT := M->AAH_CONTRT

			//Ŀ
			// Execblock AT200AA3 aps Conf.da Inclusao/Alterao 
			//
			If lAT200AA3
				ExecBlock("AT200AA3",.F.,.F.,{nOpcao})
			EndIf

		Next nLoop

		//Ŀ
		//Inclusao efetuada na tabela Quantidade X Cont. Manut x Cobertura 
		//
 		If lGravou .AND. (Len(aColsCob) > 0 .OR. lAtuGrpC)
			AAQ->(dbSetOrder(1))
			// Apaga os registros da tabela de quantidade x contrato x cobertura
			If AAQ->(DbSeek(xFilial("AAQ")+M->AAH_CONTRT)) .And. lAltCobe
				Do While AAQ->(!EOF()) .And. AAQ->(AAQ_FILIAL+AAQ_CONTRT) == xFilial("AAQ")+M->AAH_CONTRT
					RecLock("AAQ")
					DbDelete()
					AAQ->(dbSkip())
				EndDo
			EndIf
			// Apaga os registros da tabela de saldos x contrato x cobertura
			AAR->(dbSetOrder(1))
			If AAR->(DbSeek(xFilial("AAR")+M->AAH_CONTRT)) .And. lAltCobe
				Do While AAR->(!EOF()) .And. AAR->(AAR_FILIAL+AAR_CONTRT) == xFilial("AAR")+M->AAH_CONTRT
					RecLock("AAR")
					DbDelete()
					AAR->(dbSkip())
				EndDo
			EndIf
			If AAQ->(!DbSeek(xFilial("AAQ")+M->AAH_CONTRT))
				nPProd   := aScan(aHeadCob,{|x| AllTrim(x[2])=="AAQ_CODPRO"})
				nPQtdLib := aScan(aHeadCob,{|x| AllTrim(x[2])=="AAQ_QTDLIB"})
				nPModLib := aScan(aHeadCob,{|x| AllTrim(x[2])=="AAQ_MODLIB"})
				For nLoop := 1 to Len(aColsCob)
					If !Empty(aColsCob[nLoop][nPProd]) .AND. aColsCob[nLoop][nPQtdLib] > 0
						RecLock("AAQ",.T.)
						Replace AAQ_FILIAL With xFilial("AAQ")
						Replace AAQ_CONTRT With M->AAH_CONTRT
						Replace AAQ_CODPRO With aColsCob[nLoop][nPProd]
						Replace AAQ_QTDLIB With aColsCob[nLoop][nPQtdLib]
						Replace AAQ_MODLIB With aColsCob[nLoop][nPModLib]
						MsUnlock()
					EndIf
				Next nLoop
			EndIf
			AAQ->(FKCommit())
		EndIf

		//Ŀ
		//Executa o PE para cada item da base instalada excludo 
		//do contrato.                                           
		//
		If nOpcao == 2
			For nLoop := 1 To Len( aMarcados )
				If ( aScan( aRecAA3, {|x| x == aMarcados[nLoop] } ) == 0 )
					AA3->( dbGoto( aMarcados[nLoop] ) )

					If lAT200DES
						ExecBlock("AT200DES",.F.,.F.,{nOpcao})
					EndIf
				EndIf
			Next nLoop
		EndIf

		//Ŀ
		// A excluso   efetuada com getdados                                    
		//
	Case nOpcao == 3
		nUsado   := Len(aHeader)
		nPProd   := aScan(aHeader,{|x| AllTrim(x[2])=="AA3_CODPRO"})
		nPNumSer := aScan(aHeader,{|x| AllTrim(x[2])=="AA3_NUMSER"})
		nPCodFab := aScan(aHeader,{|x| AllTrim(x[2])=="AA3_CODFAB"})
		nPLojaFa := aScan(aHeader,{|x| AllTrim(x[2])=="AA3_LOJAFA"})

		For nCntFor := 1 To Len(aCols)
			DbSelectArea("AA3")

			AA3->( DbSetOrder(4) )
			If (DbSeek(xFilial("AA3")+aCols[nCntFor,nPCodFab]+aCols[nCntFor,nPLojaFa]+aCols[nCntFor,nPProd]+aCols[nCntFor,nPNumSer]) )
				RecLock("AA3")
				AA3->AA3_CONTRT := ""
				lGravou := .T.

				//Ŀ
				// Execblock AT200AA3 aps confirmao da excluso 
				//
				If  lAT200AA3
					ExecBlock("AT200AA3",.F.,.F.,{nOpcao})
				EndIf

			EndIf

		Next nCntFor

		AA3->(FKCommit())

		DbSelectArea("AAH")
		DbSetOrder(1)
		If ( DbSeek(xFilial("AAH")+M->AAH_CONTRT) )
			//Ŀ
			// Exclui a amarracao de conhecimentos                                    
			//
			If TECAAHReco() .AND. AAH->AAH_NUMREC > 0
				At210TiPr(AAH->AAH_VALOR, AAH->AAH_INICOB,AAH->AAH_FILIAL,AAH->AAH_CONTRT,AAH->AAH_CPAGPV)
			EndIf
			MsDocument( "AAH", AAH->( Recno() ), 2, , 3 )

			RecLock("AAH")
			DbDelete()
		EndIf

		//Ŀ
		// Exclui o controle de saldo 
		//
		AAQ->(dbSetOrder(1))
		If AAQ->(DbSeek(xFilial("AAQ")+M->AAH_CONTRT))
			Do While AAQ->(!EOF()) .And. AAQ->(AAQ_FILIAL+AAQ_CONTRT) == xFilial("AAQ")+M->AAH_CONTRT
				RecLock("AAQ")
				DbDelete()
				AAQ->(dbSkip())
			EndDo
		EndIf
		AAR->(dbSetOrder(1))
		If AAR->(DbSeek(xFilial("AAR")+M->AAH_CONTRT))
			Do While AAR->(!EOF()) .And. AAR->(AAR_FILIAL+AAR_CONTRT) == xFilial("AAR")+M->AAH_CONTRT
				RecLock("AAR")
				DbDelete()
				AAR->(dbSkip())
			EndDo
		EndIf

EndCase
FATLOGUTIL()
Return(lGravou)

/*/


Ŀ
Funo    At200SkCli Autor  Eduardo Riera          Data  17/09/98 
Ĵ
Descrio  Busca Nome do cliente                                      
Ĵ
Sintaxe    Void At200SkCli()                                          
Ĵ
 Uso       TECA200                                                    
ٱ


/*/

Function At200SkCli()

Local lRet    := .T.
Local cCampo  := ReadVar()
FATLOGUTIL()
Do Case
	Case ( cCampo == "M->AAH_LOJA" )
		DbSelectArea("SA1")
		DbSetOrder(1)
		If DbSeek(xFilial("SA1")+M->AAH_CODCLI+&(ReadVar()))
			lRet := RegistroOk("SA1")
			M->AAH_NOMCLI := SA1->A1_NOME
		Else
			HELP(" ", 1,"REGNOIS")
			lRet := .F.
		EndIf
	Case cCampo == "M->AAH_CODCLI"
		DbSelectArea("SA1")
		DbSetOrder(1)
		If ( xFilial("SA1")+&(ReadVar())<>SA1->A1_FILIAL+SA1->A1_COD )
			DbSeek(xFilial("SA1")+&(ReadVar()))
			lRet := RegistroOk("SA1")
		EndIf
		If lRet
			If ( xFilial("SA1")+&(ReadVar())==SA1->A1_FILIAL+SA1->A1_COD )
				lRet := RegistroOk("SA1")
				M->AAH_NOMCLI := SA1->A1_NOME
			Else
				HELP(" ", 1,"REGNOIS")
				lRet := .F.
			EndIf
		EndIf
EndCase


//Ŀ
// Atualiza o filtro da markbrowse                 
//

If lRet
	At200MbFil(.T., 1)
EndIf
FATLOGUTIL()
Return(lRet)

/*/


Ŀ
Funo    At200ProcR Autor  Eduardo Riera          Data 26.03.2000
Ĵ
Descrio Programa de processamento do reajuste do contrato de Manut. 
Ĵ
Retorno    ExpL1 = Sempre .T.                                         
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
 Uso       TECA200                                                    
ٱ


/*/
Function At200ProcR()

Local aArea		:= GetArea()
Local aSays		:= {}
Local aButtons	:= {}
Local cCadastro := STR0008
Local nOpcA		:= 0

//Ŀ
//Parametros da Rotina                                  
//                                                      
//MV_PAR01: Contrato de                                 
//MV_PAR02: Contrato ate                                
//MV_PAR03: Cliente  de                                 
//MV_PAR04: Cliente ate                                 
//MV_PAR05: Classificacao de                            
//MV_PAR06: Classificacao ate                           
//MV_PAR07: Multiplicador                               
//

Pergunte("ATA200",.F.)
AADD(aSays,STR0009)
AADD(aSays,STR0010)

AADD(aButtons, { 5,.T.,{|| Pergunte("ATA200",.T.)} })
AADD(aButtons, { 1,.T.,{|o| nOpcA:= 1,o:oWnd:End()} })
AADD(aButtons, { 2,.T.,{|o| o:oWnd:End()} })

FormBatch( cCadastro, aSays, aButtons,,200,405 )

If ( nOpcA == 1 )
	Processa({|lEnd| At200Proc()})
EndIf

RestArea(aArea)

Return(.T.)

/*/


Ŀ
Funo    At200Proc  Autor  Eduardo Riera          Data 26.03.2000
Ĵ
Descrio Programa de processamento do reajuste do contrato de Manut. 
Ĵ
Retorno    ExpL1 = Sempre .T.                                         
Ĵ
Parametros Nenhum                                                     
Ĵ
 Uso       TECA200                                                    
ٱ


/*/
Static Function At200Proc()

Local cCursor	:= "AAH"
Local lQuery	:= .F.

#IFDEF TOP
	Local cQuery	:= ""
#ENDIF


DbSelectArea("AAH")
DbSetOrder(1)
#IFDEF TOP
	If ( TcSrvType()<>"AS/400" )
		lQuery := .T.
		cCursor:= "AT200PROC"
		cQuery := "SELECT AAH.*,AAH.R_E_C_N_O_ AAHRECNO "
		cQuery += "FROM "+RetSqlName("AAH")+" AAH "
		cQuery += "WHERE AAH.AAH_FILIAL = '"+xFilial("AAH")+"' AND "
		cQuery += "AAH.AAH_CONTRT >= '"+MV_PAR01+"' AND "
		cQuery += "AAH.AAH_CONTRT <= '"+MV_PAR02+"' AND "
		cQuery += "AAH.AAH_CODCLI >= '"+MV_PAR03+"' AND "
		cQuery += "AAH.AAH_CODCLI <= '"+MV_PAR04+"' AND "
		cQuery += "AAH.AAH_CLASSI >= '"+MV_PAR05+"' AND "
		cQuery += "AAH.AAH_CLASSI <= '"+MV_PAR06+"' AND "
		cQuery += "AAH.D_E_L_E_T_=' ' "
		cQuery += "ORDER BY "+SqlOrder(AAH->(IndexKey()))

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor,.T.,.T.)

	Else
#ENDIF
	DbSeek(xFilial("AAH")+MV_PAR01,.T.)
	#IFDEF TOP
	EndIf
	#ENDIF

DbSelectArea(cCursor)
While ( !Eof() .And. xFilial("AAH") == (cCursor)->AAH_FILIAL .And.;
		(cCursor)->AAH_CONTRT >= MV_PAR01 .And.;
		(cCursor)->AAH_CONTRT <= MV_PAR02 )

	If ( (cCursor)->AAH_CODCLI >= MV_PAR03 .And. ;
			(cCursor)->AAH_CODCLI <= MV_PAR04 .And. ;
			(cCursor)->AAH_CLASSI >= MV_PAR05 .And. ;
			(cCursor)->AAH_CLASSI <= MV_PAR06 )
		If ( lQuery )
			AAH->(dbGoto((cCursor)->AAHRECNO))
		EndIf
		Begin Transaction
			AtReajCtr(MV_PAR07)
		End Transaction
	EndIf
	IncProc()
	DbSelectArea(cCursor)
	DbSkip()
EndDo

If ( lQuery )
	DbSelectArea(cCursor)
	DbCloseArea()
	DbSelectArea("AAH")
EndIf
Return(.T.)

/*


Ŀ
Funo    At200ValAb Autor  Sergio Silveira        Data 27/04/2000
Ĵ
Descrio  Validacao da digitacao da abrangencia                      
Ĵ
Sintaxe    ExpL1 := At200ValAb()                                      
Ĵ
Retorno    ExpL1 -> Validacao                                         
Ĵ
Parametros Nenhum                                                     
Ĵ
 Uso       TECA200                                                    
ٱ


*/

Function At200ValAb()

Local cConteudo := &( ReadVar() )
Local lRet      := .T.

If ( Altera )
	If ( cConteudo == "1" )
		//Ŀ
		// Nao permite alterar para Cliente/Loja se estava em Cliente   
		//
		If ( AAH->AAH_ABRANG == "2" )
			Help( " ", 1, "AT200ABRAN" ) // Nao e possivel alterar a abrangencia de cliente para cliente / loja
			lRet := .F.
		EndIf
	Else
		//Ŀ
		// Nao permite alterar para Cliente se estava em Cliente/Loja   
		//
		If ( AAH->AAH_ABRANG == "1" )
			Help( " ", 1, "AT200ABRAN01" ) // Nao e possivel alterar a abrangencia de cliente/Loja para cliente
			lRet := .F.
		EndIf
	EndIf

ElseIf ( Inclui )
	//Limpa o campo de cliente e loja quando altera o valor do campo abrangencia
	If !Empty(M->AAH_CODCLI) .And. !Empty(M->AAH_LOJA)
		M->AAH_CODCLI	:= Space(TamSx3("AAH_CODCLI")[1])
		M->AAH_LOJA	:= Space(TamSx3("AAH_LOJA")[1])
	EndIf

EndIf

Return( lRet )



/*


Ŀ
Funo    At200Valid Autor  Sergio Silveira        Data 07/09/2001
Ĵ
Descrio  Validacao da dialog                                        
Ĵ
Sintaxe    ExpL1 := At200Valid()                                      
Ĵ
Retorno    ExpL1 -> Validacao                                         
Ĵ
Parametros Nenhum                                                     
Ĵ
 Uso       TECA200                                                    
ٱ


*/

Function At200Valid()

Local lRetorno := .T.

If ( M->AAH_TPCONT == "2" )
	lRetorno := ( M->AAH_FIMVLD > M->AAH_INIVLD ) .And. !Empty( M->AAH_FIMVLD )
EndIf

If ( !lRetorno )
	Help(" ", 1, "AT200VALID")
EndIf

Return( lRetorno )

/*


Ŀ
Funo     At200Fil  Autor  Vendas e CRM            Data  21/09/10 
Ĵ
Descrio  Implementa Filtro sobre AA3, Base Instalada, com relacao a  
           VIGENCIA do Contrato corrente, se existir.                  
Ĵ
Sintaxe    ExpL1 := At200Fil()                                         
Ĵ
Retorno    ExpL1 -> Validacao                                          
Ĵ
Parametros Nenhum                                                      
Ĵ
 Uso       TECA200                                                     
ٱ


*/

Function At200Fil()

Local lRet := .T.

Local cFilAAH   := xFilial("AAH")
Local cTipContr := " "
Local dValidade := CTOD("")

If !Empty( AA3->AA3_CONTRT )

   cTipContr := Posicione( "AAH", 1, cFilAAH + AA3->AA3_CONTRT, "AAH_TPCONT" )

   If cTipContr == '1'  // Contrato Vitalicio

      lRet := .F.

   ElseIf cTipContr == '2'  // Contrato de Tempo Determinado

      dValidade := Posicione( "AAH", 1, cFilAAH + AA3->AA3_CONTRT, "AAH_FIMVLD" )

      If !Empty( dValidade )

         lRet := ( DtoS( dValidade ) < DtoS( dDataBase ) )

      EndIf

   EndIf

EndIf

Return( lRet )

/*


Ŀ
Program    AT200Bar  Autor  Caio Sergio Ferreira   Data 14/12/2010
Ĵ
Descrio  Mostra a EnchoiceBar na tela                               
Ĵ
Uso        TECA200	                                                  
ٱ


*/
Static Function AT200Bar(oDlg,bOk,bCancel,nOpcx)

Local aButtons   := {}
Local aUsButtons := {}

//Ŀ
// Coloca o banco de conhecimento apenas para alteracao e visualizacao    
//
If nOpcx == 2 .Or. nOpcx == 4
	aAdd( aButtons, { "MsDocument",	{ || MsDocument( "AAH", AAH->( RecNo() ), 4 ) }, STR0011, STR0011 } ) //"Conhecimento"
	aAdd( aButtons, { "bmpord1",	{ || TecTracker( AAH->AAH_PROPOS ) }, STR0025, STR0025 } ) //"Tracker"
	aAdd( aButtons, { "bmpord1",	{ || At200VisPV( AAH->AAH_CONTRT ) }, STR0042, STR0042 } ) //"Visualizar PV"
EndIf
	aAdd( aButtons, { "PESQUISA", 	{ || At200Pesquisa(nOpcx) }, STR0018, STR0018 } ) //"Pesquisar"



//Ŀ
// Adiciona botoes do usuario na EnchoiceBar                              
//
If ExistBlock( "AT200BUT" )
	aUsButtons := ExecBlock( "AT200BUT", .F., .F., { nOpcx } )
	aEval( aUsButtons, { |x| aAdd( aButtons, x ) } )
EndIf


Return (EnchoiceBar(oDlg,bOK,bcancel,,aButtons))


/*


ͻ
Programa  AT200AjuAcAutor  Rodrigo Toledo       Data   07/04/11   
͹
Desc.      Ajusta o acols para que o usuario possa informar o limite  
           dos produtos que fazem parte do grupo de cobertura.		  
͹
Sintaxe    AT200AjuAc(nOpcA,cNumCont,cCodGrp,cDescGrp)                
ͼ
Return     Retorna o conteudo do aCols                                
ͼ
Parametros ExpN1 = Opcao selecionada                                  
           ExpC1 = Codigo do grupo de cobertura                       
           ExpC2 = Descricao do grupo de cobertura                    
           ExpA1 = Guarda o nome dos campos do aHeader                
ͼ
Uso        TECA200                                                    
ͼ


*/
Static Function AT200AjuAc(nOpcA,cCodGrp,cDescGrp,aHeadCob)

Local aArea		:= GetArea()
Local nLinCols	:= 1
Local lConf		:= .F.
Local oDlg		:= Nil
Local oGetDados	:= Nil
Local nPosCod	:= 0
Local nPosDesc	:= 0
Local nPosQtd	:= 0
Local nPosMod	:= 0
Local nX		:= 0

Default aHeadCob := {}

SaveInter()

//Ŀ
// Sintaxe da FillGetDados(/*nOpcX*/,/*Alias*/,/*nOrdem*/,/*cSeek*/,/*bSeekWhile*/,/*uSeekFor*/,/*aNoFields*/,/*aYesFields*/,/*lOnlyYes*/,/*cQuery*/,/*bMontCols*/,/*lEmpty*/,/*aHeaderAux*/,/*aColsAux*/,/*bAfterCols*/) |
//
FillGetDados(nOpcA,"AAQ",1,,,,,,,,,.T.,,,)
aHeadCob := aClone(aHeader)

nPosCod	:= GDFieldPos("AAQ_CODPRO")
nPosDesc:= GDFieldPos("AAQ_DESCRI")
nPosQtd	:= GDFieldPos("AAQ_QTDLIB")
nPosMod	:= GDFieldPos("AAQ_MODLIB")

AAB->(dbSetOrder(1))
AAB->(dbSeek(xFilial("AAB")+cCodGrp))
While !AAB->(Eof()) .And. AAB->AAB_FILIAL+AAB->AAB_CODGRP == xFilial("AAB")+cCodGrp
	If nLinCols > 1 .Or. !Empty(aCols[nLinCols,Len(aHeader)])
	  aAdd(aCols,Array(Len(aHeader)+1))
	  nLinCols := Len(aCols)
	EndIf
	aCols[nLinCols][nPosCod]	:= AAB->AAB_CODPRO
	aCols[nLinCols][nPosDesc]	:= Posicione("SB1",1,xFilial("SB1")+AAB->AAB_CODPRO,"B1_DESC")
	aCols[nLinCols][nPosQtd]	:= 0
	aCols[nLinCols][nPosMod]	:= "1"
	nLinCols++
	AAB->(dbSkip())
EndDo
nLinCols := nLinCols - 1

If (Type("lAt200Auto")=="U" .OR. !lAt200Auto)
	DEFINE MSDIALOG oDlg FROM 000,000 TO 400,800 TITLE STR0020 PIXEL STYLE WS_DLGFRAME    // "Limites de Cobertura"
	@ 001,003  TO 020,400 LABEL "" OF oDlg PIXEL
	@ 007,005 SAY STR0021 PIXEL  //Grupo
	@ 005,025 MSGET cCodGrp PICTURE PesqPict("AAH","AAH_CODGRP")  WHEN .F. OF oDlg PIXEL SIZE 30,10 RIGHT
	@ 007,070 SAY STR0022 PIXEL //Descricao
	@ 005,103 MSGET cDescGrp PICTURE PesqPict("AAH","AAH_GRPDES") WHEN .F. OF oDlg PIXEL SIZE 200,10 RIGHT

	@ 185,320 BUTTON STR0023 SIZE 040,011 FONT oDlg:oFont ACTION ( lConf:= .T., oDlg:End() )  OF oDlg PIXEL // "Confirmar "
	@ 185,360 BUTTON STR0024 SIZE 040,011 FONT oDlg:oFont ACTION oDlg:End()  OF oDlg PIXEL // "Cancelar  "
	oGetDados := MSGetDados():New(25,3,180,400,3,,,,,,,,nLinCols)
	ACTIVATE MSDIALOG oDlg CENTERED

	If !lConf
		aCols := {}
	EndIf
Else
	For nX :=1 to Len(aAutoGrupo)

		nLinCols := aScan(aCols,{|x| x[nPosCod] == aAutoGrupo[nX][aScan(aAutoGrupo[nX],{|x| AllTrim(x[1]) == "AAQ_CODPRO"})][2] })

		If nLinCols > 0
	   		aCols[nLinCols][nPosQtd] := aAutoGrupo[nX][aScan(aAutoGrupo[nX],{|x| AllTrim(x[1]) == "AAQ_QTDLIB"})][2]
	   		aCols[nLinCols][nPosMod] := aAutoGrupo[nX][aScan(aAutoGrupo[nX],{|x| AllTrim(x[1]) == "AAQ_MODLIB"})][2]
   		EndIf

	Next nX
EndIf

RestInter()

RestArea(aArea)
Return (aCols)

//------------------------------------------------------------------------------
/*/{Protheus.doc} At200MbFil
Montagem do filtro da markbrowse

@since		09/05/2011
@author	Sergio Silveira
@param		lRefresh, bool, indica se faz refresh na mark
@param		nType, numeric, Abrangencia
/*/
//------------------------------------------------------------------------------

Function At200MBFil(lRefresh, nType, aFilTmp)
Local cQuery		:= ""
Local cAliasAux		:= GetNextAlias()		//Alias
Local nX			:= 0					//Contador total de campos
Local nTamCont   := TamSx3("AA3_CONTRT")[1]
Local cContrato	:= Iif(!lRefresh .And. nType == 1, M->AAH_CONTRT, Space(nTamCont))
Local nRecCount	:=	0
Local cCmpQry     := ''
Local aStruct := {}
Local aRet     := {}
Local aCols    := {}
Local cTempTab := ''
Local lAuto := .F.
Local aInsert
Local aTmpStruct
Local xValue
Local lOK	:= .T.


DEFAULT lRefresh	:= .F.
DEFAULT aFilTmp := {}

If Type('lAt200Auto') == 'L'
	lAuto := lAt200Auto
EndIf

If Type('aAA3TMP') == 'A' .AND. Len(aAA3TMP) > 0
	cTempTab := aAA3TMP[1]
EndIf

If ( (!Empty(M->AAH_CODCLI) .AND. !Empty(M->AAH_LOJA)) ;
		.OR. (Empty(M->AAH_CODCLI) .AND. Empty(M->AAH_LOJA)) .AND. M->AAH_ABRANG == "1") ;
		.OR. ( !Empty(M->AAH_CODCLI) .AND. M->AAH_ABRANG == "2");
		.OR. (M->AAH_ABRANG == "2" .AND. nType == 2)

	If Type('aStruAA3') == 'A' .AND. Type('aColumns') == 'A' 

		If Len(aStruAA3) == 0 .OR. Len(aColumns) == 0 
			aRet := At200MtAA3()
			aStruAA3 := aRet[1]
			aColumns := aRet[2]
			aFilTmp	 := aRet[3]
		EndIf

		aCols   := aColumns
		aStruct := aStruAA3

	Else

		aRet := At200MtAA3()
		aStruct := aRet[1]
		aCols   := aRet[2]
		aFilTmp	 := aRet[3]
	EndIf
	

	For nX := 1 To Len(aStruct)
		If nX <> 1
			cCmpQry += ' , '
		EndIf
		cCmpQry += aStruct[nX][1]
	Next nX

	cCmpQry += ' , AA3_OK, AA3.R_E_C_N_O_ RECNO'

	cQuery := "SELECT "
	cQuery += cCmpQry
	cQuery +=" FROM " + RetSqlName("AA3") + " AA3 LEFT  JOIN "
	cQuery +=RetSqlName("AAH") + " AAH ON AA3.AA3_FILIAL = AAH.AAH_FILIAL AND AA3.AA3_CODCLI = AAH.AAH_CODCLI "
	cQuery +="AND AA3.AA3_LOJA = AAH.AAH_LOJA	AND AA3.AA3_CONTRT = AAH.AAH_CONTRT"
	cQuery +=" WHERE AA3.AA3_CODCLI = '"+M->AAH_CODCLI+"'"
	If M->AAH_ABRANG == "1"
		cQuery +=" AND AA3.AA3_LOJA = '"+M->AAH_LOJA+"'"
	EndIf
	cQuery +=" AND AA3.D_E_L_E_T_=' ' AND AA3_FILIAL ='"+xFilial("AA3")+"'"
	cQuery +=" AND ((AA3.AA3_CONTRT ='"+Space(nTamCont)+"' )"
	cQuery +="OR (AAH.AAH_TPCONT <> '2' AND AA3.AA3_CONTRT = '"+cContrato+"') "
	cQuery +="OR ((AAH.AAH_TPCONT = '2' AND AAH.AAH_FIMVLD < '"+DtoS(dDataBase)+"') OR AA3.AA3_CONTRT = '"+cContrato+"') ) "
	If AA3->( ColumnPos('AA3_MSBLQL')) > 0
		cQuery +="AND AA3.AA3_MSBLQL <> '1'"
	EndIf
	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasAux,.F.,.T.)

	For nX := 1 To Len(aStruct)
		If	!aStruct[nX][1] == "AA3_OK" .And. !aStruct[nX][1] == "AA3_FILIAL"
			If aStruct[nX][2] <> "C"
				TcSetField(cAliasAux,aStruct[nX][1],aStruct[nX][2],aStruct[nX][3],aStruct[nX][4])
			EndIf
		EndIf
	Next nX

	//----------------------------------------------------------------------
	// Cria arquivo de dados temporrio
	//----------------------------------------------------------------------
	/*Tratamento realizado , pois a rotina foi feita para trabalhar com um alias*/
	
	If VALTYPE(oGSTmpTb) == 'O'
		lOK := oGSTmpTb:Close()
		If lOK
			TecDestroy(oGSTmpTb)
		Else
			oGSTmpTb:ShowErro()
		EndIf
	EndIf
	
	If lOK
		DbSelectArea(cAliasAux)
		aTmpStruct := ACLONE(aStruct)
		AADD(aTmpStruct, {"RECNO","N",8,0})
		oGSTmpTb := GSTmpTable():New("AT200",aTmpStruct,,{})
		
		If !oGSTmpTb:CreateTMPTable()
			oGSTmpTb:ShowErro()
		Else
			DbSelectArea(cAliasAux)
			While (cAliasAux)->(!EOF())
				aInsert :={}
				For nX := 1 to LEN(aStruct)
					xValue := (&("(cAliasAux)->" + aStruct[nX][1]))
					Aadd(aInsert, {aStruAA3[nX][1], xValue })
				Next
				AAdd(aInsert, {"RECNO", (cAliasAux)->RECNO})
				oGSTmpTb:Insert(aInsert)
				oGSTmpTb:Commit()
	
				(cAliasAux)->(DbSkip())
			End
			
	
			If ( Select( cAliasAux ) > 0 )
				DbSelectArea(cAliasAux)
				(cAliasAux)->(DbCloseArea())
			EndIf
		EndIf
	EndIf
	
	If lRefresh .AND. !lAuto .AND. Type('oMark') <> 'U'

		aAA3TMP[1] := oGSTmpTb:cAliasTmp
		oMark:SetAlias( oGSTmpTb:cAliasTmp )
		oMark:Refresh(.T.)	
		
	EndIf
		
EndIf

return({oGSTmpTb:cAliasTmp, aCols})



/*


Ŀ
Funo    At200GpCan Autor  Vendas CRM             Data 01/02/2012
Ĵ
Descrio  Valida se o grupo de cobertura esta cancelado.  			  
Ĵ
Sintaxe    At200VGrp()                                                
Ĵ
Retorno    ExpL: Verdadeiro / Falso                                   
Ĵ
 Uso       TECA200                                                    
ٱ


*/

Function At200GpCan()

Local cConteudo := &(ReadVar())   		// Variavel corrente que esta sendo editada.
Local aAreaAAA  := AAA->(GetArea())	// Guarda a area da tabela AAA.
Local lRet      := .T.					// Retorno da validacao.

DbSelectArea("AAA")
DbSetOrder(1)

If DbSeek(xFilial("AAA")+cConteudo)

	If ( AAA->AAA_STATUS == '2'	)
		//Ŀ
		//	 Problema: O grupo de cobertura selecionado esta cancelado. 
		//	 Solucao: Selecione um grupo de cobertura ativo.         	
		//
		Help("",1,"GPOCANC")
		lRet := .F.

	EndIf

EndIf

RestArea(aAreaAAA)

Return ( lRet )

/*


Ŀ
Funo    At200AtCrt Autor  Vendas CRM             Data 01/02/2012
Ĵ
Descrio  No permite ativacao do contrato cancelado.                
Ĵ
Sintaxe    At200AtCtr()                             		          
Ĵ
Retorno    ExpL: Verdadeiro / Falso                                   
Ĵ
 Uso       TECA200                                                    
ٱ


*/

Function At200AtCrt()

Local cConteudo	:= &(ReadVar())		// Variavel corrente que esta sendo editada.
Local lRet		:= .T. 				// Retorno da validacao.

If Altera

	Do Case
		Case ( AAH->AAH_STATUS == '2' .AND. cConteudo == '1' )

			//Ŀ
			//	 Problema: No ser possvel ativar um contrato cancelado. 
			//	 Solucao: Inclua um novo contrato.                    	   
			//
			Help("",1,"CONTRCAN")
			lRet := .F.

   		Case ( AAH->AAH_STATUS == '2' .AND. cConteudo <> '2' )

			//Ŀ
			//	 Problema: No ser possvel alterar o status de um contrato cancelado. 
			//	 Solucao: Inclua um novo contrato.									    
			//
			Help("",1,"STSCONTR")
			lRet := .F.

	EndCase

EndIf

Return ( lRet )
//------------------------------------------------------------------------------
/*/{Protheus.doc} Tec200TdOk
Validao do TudoOk

@sample 	Tec200TdOk()

@param		Nenhum

@return	ExpL	Verdadeiro / Falso

@author	Paulo Figueira
@since		24/04/2014
@version	P11
/*/
//------------------------------------------------------------------------------

Static Function Tec200TdOk(cMarca,oMark)
Local aAreaAll	:= GetArea()
Local aArea  		:= (aAA3TMP[1])->(GetArea())
Local lMarca 		:= .F.
Local lRet			:= .F.

DbSelectArea(aAA3TMP[1])
DbGotop() // IndRegua()
While !Eof() .And. (aAA3TMP[1])->AA3_FILIAL == xFilial("AA3")
	If oMark:ClassName() == "FWMARKBROWSE"
		lMarca := oMark:IsMark()
	Else
		lMarca := ((aAA3TMP[1])->AA3_OK== cMarca)
	EndIf

	If lMarca
		lRet:= .T.
		Exit
	EndIf

	DbSkip()
EndDo

If !lRet
	Help (" ", 1, "BASEAT",,STR0032, 3, 0) //"Selecione uma base de atendimento, antes de confirmar a gravao."
EndIf

If lRet .AND. (TECAAHReco() .AND. M->AAH_NUMREC > 0)
	If M->AAH_FIMCOB < MonthSum( M->AAH_INICOB, M->AAH_NUMREC -1 ) //Necessario subtrair, pois o mes de inicio da cobrana  considerado na gerao do provisorio
		lRet := .F.
		Help (" ", 1, "TUDOOK",,STR0037 + cValToChar(M->AAH_NUMREC) + STR0038 + DToC(M->AAH_FIMCOB) + STR0039, 3, 0) //"O numero de meses recorrentes (" ## ") passa a data limite de cobrana do contrato (" ## "), por favor edite a recorrencia ou a data fim da cobrana."
	EndIf
EndIf
RestArea(aArea)
RestArea(aAreaAll)

Return lRet

//------------------------------------------------------------------------------
/*/{Protheus.doc} At200FimVd
Validao do fim da data de validade para contrato vitalcio

@sample 	At200FimVd()

@param		Nenhum

@return	Nil

@author	Paulo Figueira
@since		05/06/2014
@version	P11
/*/
//------------------------------------------------------------------------------
Function At200FimVd()
Local CTpCont		:= ""
Local dTpCont		:= Stod("")

cTpCont := M->AAH_TPCONT
dTpCont := M->AAH_FIMVLD

If CTpCont == "1" .And. !Empty(dTpCont)
	M->AAH_FIMVLD := Stod("")
EndIf

Return Nil

/*/{Protheus.doc} At200Pesquisa
Funao de pesquisa da rotina teca200
@author Vendas/CRM
@since 08/08/2014
@version 1.0
/*/
Static Function At200Pesquisa(nOpcx)

Local lPesq := .F.

#IFDEF TOP
	lPesq := .T.
#EndIf

If lPesq .AND. (nOpcx == 3 .OR. nOpcx == 4 )
	At200Pesq()
Else
	DbSelectArea("AA3")
	PesqBrw()
EndIf

return

/*/{Protheus.doc} At200Pesq
Funcao de criacao do panel de busca conforme os indices passados
@author Vendas/CRM
@since 08/08/2014
@version 1.0
/*/
Static Function At200Pesq()
LOCAL oCbx, nOpt1:=1,oDlg
Local cOrd, oBigGet
Local nSavReg, cAlias, ni, nj
Local cCpofil, dCampo
Local nOrd    := 1
Local lSeek   := .F.
Local aLista  := {}
Local bSav12  := SetKey(VK_F12)
Local cCampo  := Space(60)

Local lDetail := .F.
Local lUseDetail := .F.
Local aAllLista
Local oDetail
Local aMyOrd	:= {}
Local aScroll	:= {}
Local lSeeAll   := GetBrwSeeMode()
Local aPesqVar  := {}
Local cVar
Local bBloco
Local cMsg := ""
Local oPPreview
Local oList
Local aList    := {}
Local lMenuDef := ( ProcName(1) == "MBRBLIND" ) .Or. RunInMenuDef()
Local lPreview := .F.
Local nRet     := 0
Local cAliasTemp := Alias()

Private aOrd     := {}

SetKey(VK_F12,{|| NIL})

If Eof()
	If lMenuDef
		Help(" ",1,"ARQVAZIO")
	Else
		Help(" ",1,"A000FI")
	EndIf
	SetKey(VK_F12,bSav12)
	Return
EndIf

AxPesqOrd('AA3',@aMyOrd,@lUseDetail,lSeeAll)

nOrd := 1
cOrd := aOrd[1]
For nI := 1 To Len(aOrd)
	aOrd[nI] := OemToAnsi(aOrd[nI])
Next

If IndexOrd() > Len(aOrd)
	cOrd := 1 //aOrd[Len(aOrd)]
	nOrd := 1 //Len(aOrd)
ElseIf IndexOrd() <= 1
	cOrd := aOrd[1]
	nOrd := 1
Else
	cOrd := aOrd[IndexOrd()]
	nOrd := IndexOrd()
EndIf

PesqList('AA3',lSeeAll,@aPesqVar,@aAllLista,@cMsg)

DEFINE MSDIALOG oDlg FROM 00,00 TO 100,490 PIXEL TITLE OemToAnsi(STR0001) //"Pesquisa"

@05,05 COMBOBOX oCBX VAR cOrd ITEMS aOrd SIZE 206,36 PIXEL OF oDlg FONT oDlg:oFont

@22,05 MSGET oBigGet VAR cCampo SIZE 206,10 PIXEL

DEFINE SBUTTON FROM 05,215 TYPE 1 OF oDlg ENABLE ACTION (lSeek := .T.,oDlg:End())
DEFINE SBUTTON FROM 20,215 TYPE 2 OF oDlg ENABLE ACTION oDlg:End()

If ( lUseDetail )
	@22,05 MSPANEL oPPreview SIZE 205,84 OF oDlg
	oPPreview:Hide()
	DEFINE SBUTTON oDetail FROM 35,215 TYPE 5 OF oDlg ENABLE ONSTOP STR0032 ACTION (lDetail := PesqDetail(lDetail,@oDlg,@aScroll,@oBigGet,nOrd,oPPreview),;
																					If(lMenuDef,(lPreview:= .F.,oPPreview:Hide()),)) //"Detalhes"

	For ni := 1 To Len(aAllLista)
		Aadd(aScroll,NIL)
		@22,05 SCROLLBOX aScroll[ni] VERTICAL SIZE 84,205 BORDER
		aScroll[ni]:Hide()

		For nj := 1 To Len(aAllLista[ni])
			cVar := "aPesqVar["+StrZero(ni,2)+"]["+StrZero(nj,2)+"]"
			bBloco  := &("{ | u | If( PCount() == 0, "+cVar+","+cVar+" := u)}")
			PesqInit(aAllLista[ni],aScroll[ni],nj,bBloco,cVar)
		Next
	Next

	oCbx:bChange := {|| PesqChange(@nOrd,oCbx:nAt,@aLista,cAlias,@aAllLista,@aScroll,@lDetail,@oDetail,@oDlg,@oBigGet) }
	aLista := Aclone(aAllLista[nOrd])
Else
	oCbx:bChange := {|| nOrd := oCbx:nAt}
EndIf

ACTIVATE MSDIALOG oDlg CENTERED

If ( lSeek )
	nRet := 1
	At200Buscar(lDetail, aPesqVar,cCampo,nOrd,cAliasTemp,aLista)
	SetKey(VK_F12,bSav12)
Else
	SetKey(VK_F12,bSav12)
EndIf

Return .T.

/*/{Protheus.doc} At200Buscar
Funo de busca na tabela temporria conforme indice passado da AA3
@author Vendas/CRM
@since 08/08/2014
@version 1.0
@param lDetail, ${param_type}, (Descrio do parmetro)
@param aPesqVar, array, (Descrio do parmetro)
@param cCampo, character, (Descrio do parmetro)
@param nOrd, numrico, (Descrio do parmetro)
@param cAliasTemp, character, (Descrio do parmetro)
@param aLista, array, (Descrio do parmetro)
/*/
Static Function At200Buscar(lDetail, aPesqVar, cCampo, nOrd,cAliasTemp,aLista)
Local cAlias		:= ''
Local cKeyInd		:= ''
Local nI			:= 0

DbSelectArea('AA3')
DbSetOrder(nOrd)
cKeyInd := IndexKey()
DbCloseArea()

cAlias := cAliasTemp
cCampo := ALLTRIM(cCampo)

If ( lDetail )
	cCampo :=  ("AA3")
	For nI := 1 To Len(aPesqVar[nOrd])
		If( aLista[nI][2] == "C" .And. (Len(cCampo) <> aLista[nI][3]) )
			cCampo += Substr(aPesqVar[nOrd][nI],1,aLista[nI][3])
		ElseIf ( aLista[nI][2] == "D" )
			cCampo += Dtos(aPesqVar[nOrd][nI])
		ElseIf ( aLista[nI][2] == "N" )
			cCampo += Str(aPesqVar[nOrd][nI],aLista[nI][3],aLista[nI][4])
		Else
			cCampo += aPesqVar[nOrd][nI]
		EndIf
	Next
EndIf

DbSelectArea(cAlias)
IndRegua(cAlias,cAlias,cKeyInd,,,) //"Ordenando por "

If (cAlias)->(DbSeek(FWxFilial("AA3")+cCampo))
	oMark:Goto((cAlias)->(Recno()),.T.)
	oMark:oBrowse:SetFocus()
Else
	(cAlias)->(DbGoTop())
EndIf

Return

/*/{Protheus.doc} At200MtAA3
Funao que ira carregar a estrutura do SX3 da tabela AA3 para realizar a query e ira montar as colunas da markbrowse
@author Vendas/CRM
@since 14/08/2014
@version 1.0
/*/
Static Function At200MtAA3()

Local nY    := 0
Local aStruct  := {}
Local aCols    := {}
Local aCpos := {}
Local nC 	:= 0
Local cTipo := ""
Local aFilter := {}


aCpos := FWSX3Util():GetAllFields("AA3" , .F.) //Ignora os campos virtuais


For nC := 1 to Len(aCpos)
	If (cTipo := GetSx3Cache(aCpos[nC],"X3_TIPO" )) <> "M" .and. (cTipo := GetSx3Cache(aCpos[nC],"X3_TIPO")) <> 'L'
		AADD(aStruct,{GetSx3Cache(aCpos[nC],"X3_CAMPO" ), GetSx3Cache(aCpos[nC],"X3_TIPO"), GetSx3Cache(aCpos[nC],"X3_TAMANHO"),GetSx3Cache(aCpos[nC],"X3_DECIMAL")})

		If aCpos[nC] <>  "AA3_OK" .And. aCpos[nC] <> "AA3_FILIAL"

			nY++
			AAdd(aCols,FWBrwColumn():New())
			aCols[nY]:SetData( &("{||"+aCpos[nC]+"}") )
			aCols[nY]:SetTitle(RetTitle(aCpos[nC]))
			aCols[nY]:SetSize(aTail(aStruct)[3])
			aCols[nY]:SetDecimal(aTail(aStruct)[4])
			aCols[nY]:SetType(cTipo)
			
			
			aAdd(aFilter, {aCpos[nC], RetTitle(aCpos[nC]), cTipo,  aTail(aStruct)[3], aTail(aStruct)[4], GetSx3Cache(aCpos[nC],"X3_PICTURE") })
		EndIf
	EndIf

Next nC

Return {aStruct,aCols, aFilter}

/*/{Protheus.doc} At200CMkB1
Funao para controlar a marcao ou desmarcao do registro
@author Servios
@since 28/10/2014
@version 1.0
/*/
Static Function At200CMkB1(oMark)
Local lRetorno	:= .T.			// Retorno da rotina.
Local nRecno		:= (aAA3TMP[1])->(RecCount())

If ( !oMark:IsMark() ) .And. nRecno > 0
	RecLock(oMark:Alias(),.F.)
	(oMark:Alias())->AA3_OK  := oMark:Mark()
	(oMark:Alias())->(MsUnLock())

ElseIf nRecno > 0
	RecLock(oMark:Alias(),.F.)
	(oMark:Alias())->AA3_OK  := ""
	(oMark:Alias())->(MsUnLock())
EndIf

Return( lRetorno )

//------------------------------------------------------------------------------
/*/{Protheus.doc} At200MkAll
Marca / Desmarca todos os atendentes no browse.

@sample 	At200MkAll(oMark,lMarkAll)

@param		ExpA1 	Objeto FwMarkBrowse Base de Atendimento

@return		ExpL 	Verdadeiro

@author	Servios
@since		06/11/2014
@version	P118
/*/
//------------------------------------------------------------------------------
Static Function At200MkAll(oMark,lMarkAll, oCheckAct)   								// Retorno da rotina.
Local aAreaTmp	:= (oMark:Alias())->(GetArea())		// Guarda a area do browse.
Local lGoTop 	:= .T.										// Posiciona no primeiro registro.

oMark:SetInvert(.F.)

(oMark:Alias())->(DbGoTop())

While (oMark:Alias())->(!Eof())
	If lMarkAll
		If ( !oMark:IsMark() )
			RecLock(oMark:Alias(),.F.)
			(oMark:Alias())->AA3_OK  := oMark:Mark()
			(oMark:Alias())->(MsUnLock())
		EndIf
	Else
		If (oMark:IsMark())
			RecLock(oMark:Alias(),.F.)
			(oMark:Alias())->AA3_OK  := ""
			(oMark:Alias())->(MsUnLock())
		EndIf
	EndIf
	(oMark:Alias())->(DbSkip())
End

RestArea(aAreaTmp)
oMark:Refresh(lGoTop)
oCheckAct:Refresh()

Return( lMarkAll )

//------------------------------------------------------------------------------
/*/{Protheus.doc} At200VisBs
Boto visualizar no grid inferior

@param nRecno, int, Recno da AA3
@return true
@author Mateus Boiani
@since 25/07/2018
/*/
//------------------------------------------------------------------------------
Function At200VisBs(nRecno)
Local aArea := GetArea()
Local aAreaAA3
If VALTYPE(nRecno) == 'N' .AND. nRecno > 0
	aAreaAA3 := AA3->(GetArea())
	AA3->(DbGoTo(nRecno))
	AxVisual( "AA3", nRecno, 2 )
	RestArea(aAreaAA3)
EndIf

RestArea(aArea)
Return .T.

//------------------------------------------------------------------------------
/*/{Protheus.doc} At210TiPr

@description MSGRun do processo de excluso dos titulos provisorios.
@author	Augusto Albuquerque
@since	06/05/2020
/*/
//------------------------------------------------------------------------------
Static Function At210TiPr(nValor,dProcesso,cFilAAH,cContr,cCondPV)

Return FwMsgRun(Nil,{|| At210TiPr2(nValor,dProcesso,cFilAAH,cContr,cCondPV)}, Nil, STR0035) //"Fazendo a excluso dos Titulos"

//------------------------------------------------------------------------------
/*/{Protheus.doc} At210TitPr

@description Funo para recuperar e deletar os titulos provisorios

@param nValor - Valor do pedido de venda
@param dProcesso - Data de processamento
@param cFilial - Filial do contrato
@param cContr - Codigo do Contrato
@param cCondPV - Condio de pagamento do PV

@author Luiz Gabriel
@since  04/05/2020
/*/
//------------------------------------------------------------------------------
Static Function At210TiPr2(nValor,dProcesso,cFilAAH,cContr,cCondPV)
Local cAliasTXJ := GetNextAlias()
    
BeginSQL Alias cAliasTXJ    
    SELECT 
        TXJ.R_E_C_N_O_ TXJ_RECNO,
        SE1.R_E_C_N_O_ SE1_RECNO
    FROM
        %Table:TXJ% TXJ
    INNER JOIN %Table:SE1% SE1 ON E1_FILIAL = TXJ.TXJ_FILE1
                            AND SE1.E1_NUM = TXJ.TXJ_NUM
                            AND SE1.E1_PREFIXO = TXJ.TXJ_PREFIX
                            AND SE1.E1_PARCELA = TXJ.TXJ_PARCEL
                            AND SE1.E1_TIPO    = 'PR'   
    WHERE 
        TXJ.TXJ_FILIAL = %xFilial:TXJ% AND 
        TXJ.TXJ_CTRMNT = %exp:cContr% AND 
        TXJ.TXJ_FILAAH = %exp:cFilAAH% AND 
        TXJ.%NotDel% AND 
		SE1.%NotDel%

EndSQL

While !( cAliasTXJ )->( EOF() )
    // Posiciona nos itens que sero deletados
    TXJ->( DbGoTo( (cAliasTXJ)->TXJ_RECNO ) )
    TXJ->(RecLock("TXJ",.F.))
        TXJ->(DbDelete()) 
    TXJ->(MsUnlock())

    SE1->( DbGoTo( (cAliasTXJ)->SE1_RECNO ) )
    SE1->(RecLock("SE1",.F.))
        SE1->(DbDelete()) 
    SE1->(MsUnlock())

    ( cAliasTXJ )->( DbSkip() )
EndDo
( cAliasTXJ )->( DbCloseArea() )

Return .T.

//------------------------------------------------------------------------------
/*/{Protheus.doc} AT200Prov

@description MSGRun do processo de gerao dos titulos provisorios.
@author	Augusto Albuquerque
@since	06/05/2020
/*/
//------------------------------------------------------------------------------
Static Function AT200Prov()

Return Iif(!IsBlind(),FwMsgRun(Nil,{|| AT200Prov2()}, Nil, STR0036),AT200Prov2()) //"Gerando os titulos provisorios" 

//------------------------------------------------------------------------------
/*/{Protheus.doc} AT200Prov2

@description Processo de preenchimento do array com os titulos e gravao
@author	Augusto Albuquerque
@since	06/05/2020
/*/
//------------------------------------------------------------------------------
Static Function AT200Prov2()
Local aTotalPR	:= {}

aTotalPR := AT200IncPr()

If Len(aTotalPR) > 0
	At200IncE1(aTotalPR,M->AAH_CODCLI,M->AAH_LOJA,M->AAH_CONTRT)
EndIf

Return 

//------------------------------------------------------------------------------
/*/{Protheus.doc} AT200IncPr

@description Funo para preencher o array com a condio de pagamento
@author	Augusto Albuquerque
@since	06/05/2020
/*/
//------------------------------------------------------------------------------
Static Function AT200IncPr(dDataIni)
Local aCondPag	:= {}
Local aCondCtr	:= {}
Local aTotalPR	:= {}
Local lVitalic	:= M->AAH_TPCONT=="1"	 //Indica se o contrato  vitalicio
Local nX		:= 0
Local nY		:= 0
Local nZ		:= 0

Default dDataIni	:= M->AAH_INICOB-Day(M->AAH_INICOB)+1

DbSelectArea("TXJ")

For nX := 1 To M->AAH_NUMREC
	If nX == 1
		aCondPag := Condicao(M->AAH_VALOR,M->AAH_CONPAG,0,dDataIni)
	Else
		aCondPag := Condicao(M->AAH_VALOR,M->AAH_CONPAG,0,MonthSum( dDataIni, nX - 1 ))
	EndIf
	For nY := 1 To Len(aCondPag)
		aCondCtr := Condicao(aCondPag[nY][2],M->AAH_CPAGPV,0,aCondPag[nY][1])
		For nZ := 1 To Len(aCondCtr)
			If aCondCtr[nZ][1] >= M->AAH_INICOB .AND. (lVitalic .Or. aCondCtr[nZ][1] <= M->AAH_FIMCOB) 
				AADD( aTotalPR, {aCondCtr[nZ][1],;
								aCondCtr[nZ][2]})
			EndIf					
		Next nZ
	Next nY
Next nX

Return aTotalPR

//------------------------------------------------------------------------------
/*/{Protheus.doc} At200IncE1

@description gravao do titulo provisorio no FINA040 e na tabela TXJ
@author	Augusto Albuquerque
@since	06/05/2020
/*/
//------------------------------------------------------------------------------
Static Function At200IncE1(aTotalPR,cCodCli,cCodLj,cCodCtr, cFilAAH)
Local aRotAuto	:= {}
Local cNatu		:= SuperGetMV("MV_TECXNAT",,"TEC")
Local cRetPrf	:= "TEC"
Local cNumTit	:= ""
Local cParcela	:= StrZero(1,Len(SE1->E1_PARCELA))
Local cAliasSE1	:= GetNextAlias()
Local nX

Default cFilAAH := xFilial("AAH")
Private lMsErroAuto := .F.

If Len(aTotalPR) > 0
	If IsInCallStack("At200RecPr")
		BeginSQL Alias cAliasSE1
			SELECT 
				MAX(TXJ.TXJ_NUM) AS TXJ_NUM, 
				MAX(TXJ.TXJ_PARCEL) AS TXJ_PARCEL
			FROM
				%Table:TXJ% TXJ  
			WHERE 
				TXJ.TXJ_FILIAL = %xFilial:TXJ% AND 
				TXJ.TXJ_CTRMNT = %exp:cCodCtr% AND 
				TXJ.TXJ_FILAAH = %exp:cFilAAH% AND 
				TXJ.%NotDel%
		EndSQL
		cNumTit := (cAliasSE1)->TXJ_NUM
		cParcela := Soma1((cAliasSE1)->TXJ_PARCEL)
		(cAliasSE1)->(dbCloseArea())
	Else
		BeginSql Alias cAliasSE1
			SELECT MAX(SE1.E1_NUM) AS E1_NUM
			FROM %Table:SE1% SE1
			WHERE SE1.E1_FILIAL  = %xFilial:SE1%
				AND SE1.E1_PREFIXO =%Exp:cRetPrf%
				AND SE1.%NotDel%
		EndSql

		cNumTit := Soma1((cAliasSE1)->E1_NUM)
		(cAliasSE1)->(dbCloseArea())
		SE1->(dbSetOrder(1))

		While SE1->(dbSeek(xFilial("SE1")+cRetPrf+cNumTit))
			cNumTit := Soma1(cNumTit)
		End
	EndIf

	For nX := 1 To Len(aTotalPR)
		If nX == 1
			aRotAuto :={{"E1_CLIENTE"	,	cCodCli			, NIL},; // Cliente
						{"E1_LOJA"		,	cCodLj			, NIL},; // Loja do Cliente
						{"E1_ORIGEM"	,	"TECA200"		, NIL},; // Origem
						{"E1_VENCTO" 	,	M->AAH_FIMVLD	, NIL},; // Vencimento
						{"E1_VENCREA"	,	M->AAH_FIMVLD	, NIL},; // Vencimento Real
						{"E1_VENCORI"	,	M->AAH_FIMVLD	, NIL},; // Vencimento Origem
						{"E1_FILORIG"	, 	cFilAnt			, NIL},;
						{"E1_TIPO"		, 	"PR"			, Nil},;
						{"E1_PARCELA"	,	cParcela		, Nil},;
						{"E1_NATUREZ"	,	cNatu			, Nil},;
						{"E1_PREFIXO"	,	cRetPrf			, Nil},;
						{"E1_NUM"		,	cNumTit			, Nil},;
						{"E1_VALOR"		,	aTotalPR[nX,2]	,Nil}}	// Numero da Parcela
		Else
			aRotAuto[9,2] := cParcela
		EndIf
		aRotAuto[4,2] := aTotalPR[nX,1]
		aRotAuto[5,2] := DataValida(aTotalPR[nX,1],.T.)
		aRotAuto[6,2] := aTotalPR[nX,1]
		aRotAuto[13,2] := aTotalPR[nX,2]

		MSExecAuto({|x,y| FINA040(x,y)},aRotAuto,3)

		If lMsErroAuto
			If !IsBlind()
				MostraErro()
			EndIf
			Exit
		Else
			RecLock("TXJ",.T.)
				REPLACE TXJ_FILIAL 	With xFilial("TXJ")
				REPLACE TXJ_PREFIX 	With cRetPrf
				REPLACE TXJ_NUM 	With SE1->E1_NUM	
				REPLACE TXJ_PARCEL 	With SE1->E1_PARCELA
				REPLACE TXJ_TIPO 	With "PR"
				REPLACE TXJ_CLIENT	With cCodCli
				REPLACE TXJ_LOJA 	With cCodLj
				REPLACE TXJ_VENCTO 	With SE1->E1_VENCTO	
				REPLACE TXJ_VENCTR 	With SE1->E1_VENCREA	
				REPLACE TXJ_VALOR 	With SE1->E1_VALOR
				REPLACE TXJ_FILE1 	With SE1->E1_FILIAL
				REPLACE TXJ_CTRMNT 	With cCodCtr
				REPLACE TXJ_FILAAH	With xFilial("AAH")
			MsUnlock()
		EndIf

		cParcela := Soma1(cParcela)
	Next nX
EndIf

Return 

//------------------------------------------------------------------------------
/*/{Protheus.doc} At200RecPr

@description Funo para recriar sempre a parcela de acordo com a recorrencia
@author	Luiz Gabriel
@since	06/05/2020
/*/
//------------------------------------------------------------------------------
Function At200RecPr(aCondPV,dProcesso)
Local aCondPag	:= {}
Local aCondCtr	:= {}
Local aTotalPR	:= {}
Local aDtVld	:= {}
Local dDTRecor	:= MonthSum(  dProcesso,  AAH->AAH_NUMREC )   
Local dDataIni	:= dDTRecor-Day(dDTRecor)+1
Local lVitalic	:= M->AAH_TPCONT=="1"	 //Indica se o contrato  vitalicio
Local nCntFor	:= 0
Local nPos		:= 0
Local nY		:= 0
Local nZ		:= 0

If dDTRecor <= AAH->AAH_FIMCOB
	aCondPag := Condicao(AAH->AAH_VALOR,AAH->AAH_CONPAG,0,dDataIni)

	For nY := 1 To Len(aCondPag)
		aCondCtr := Condicao(aCondPag[nY][2],AAH->AAH_CPAGPV,0,aCondPag[nY][1])
		For nZ := 1 To Len(aCondCtr)
			If aCondCtr[nZ][1] >= AAH->AAH_INICOB .AND. (lVitalic .Or. aCondCtr[nZ][1] <= AAH->AAH_FIMCOB) 
				AADD( aTotalPR, {aCondCtr[nZ][1],;
								aCondCtr[nZ][2]})
			EndIf					
		Next nZ
	Next nY


	If Len(aTotalPR) > 0

		For nCntFor := 1 To Len(aCondPV)
			nPos := aScan(aTotalPR,{|x| Day(x[1]) == Day(aCondPV[nCntFor][1]) })
			If nPos > 0
				AADD( aDtVld, {aTotalPR[nPos][1],aTotalPR[nPos][2]})
			EndIf 
		Next nCntFor	
		
		At200IncE1(aDtVld,AAH->AAH_CODCLI,AAH->AAH_LOJA,AAH->AAH_CONTRT)
	EndIf 
EndIf

Return 

//------------------------------------------------------------------------------
/*/{Protheus.doc} At200VisPV

@description Funo para visualizar os pedidos de venda do contrato
@author	Luiz Gabriel
@since	01/09/2023
/*/
//------------------------------------------------------------------------------
Function At200VisPV(cContrato)
Local oPanel	:= Nil
Local oBrowse	:= Nil
Local aBckp		:= aClone(aRotina)

aRotina	:= {}

DEFINE MSDIALOG oPanel TITLE STR0040 FROM 050,050 TO 500,800 PIXEL //"Pedidos de Venda - Contrato"

oBrowse:= FWmBrowse():New()
oBrowse:SetOwner( oPanel )   
oBrowse:SetDescription( STR0041 ) //"Lista de Movimentaes" 
oBrowse:SetAlias( "AAW" ) 
oBrowse:DisableDetails() 
oBrowse:SetWalkThru(.F.)
oBrowse:SetAmbiente(.F.)
oBrowse:SetProfileID("14")
oBrowse:SetMenuDef( "  " )
oBrowse:SetFilterDefault( "AAW_CONTRA = '" + cContrato + "' " ) 

oBrowse:Activate() 
oBrowse:Refresh()

ACTIVATE MSDIALOG oPanel CENTERED

aRotina := aBckp
aBckp := {}

Return
