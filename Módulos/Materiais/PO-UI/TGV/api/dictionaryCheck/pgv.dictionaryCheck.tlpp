#include 'protheus.ch'
#include 'tlpp-core.th'
#include 'tlpp-rest.th'
#include 'tgv.util.data.ch'

namespace totvs.protheus.backoffice.pgvDictionaryCheck
using namespace tgv.util

//----------------------------------------------------------------------------------------
/*/{Protheus.doc} pgvDictionaryCheck
    API para consultar propriedades dos campos utilizado no portal Gestão de vendas
    @type       class
    @version    12.1.2210
    @author     Gabriel Oliveira dos Santos / Squad CRM & Faturamento
    @since      30/08/2023
/*/
//----------------------------------------------------------------------------------------
Class pgvDictionaryCheck
    
    @Get("/api/pgv/dictionarycheck/:properties/:table/:fields")
    Public Method getFieldProperty()         as logical
    Public Method new()                   as object

EndClass

//------------------------------------------------------------------------------
/*/{Protheus.doc} pgvDictionaryCheck::new() as object
    obtem uma nova instancia da classe pgvDictionaryCheck
    @type       method
    @version    12.1.2210
    @author     Gabriel Oliveira dos Santos / Squad CRM & Faturamento
    @since      30/08/2023
    @return object, nova instancia da classe pgvDictionaryCheck
/*/
//------------------------------------------------------------------------------
Method New() as object class pgvDictionaryCheck
    
Return self

//------------------------------------------------------------------------------
/*/{Protheus.doc} pgvDictionaryCheck::getFieldProperty() as logical
  Obtem o resultado das propriedades de um campo
    @type       method
    @version    12.1.2210
    @author     Gabriel Oliveira dos Santos / Squad CRM & Faturamento
    @since      30/08/2023
    @return     Logical, retorna sempre verdadeiro
    @Exemple    http://localhost:8089/rest/api/pgv/dictionarycheck/X3_INIBRW+X3_VALID+X3_RELACAO+X3_WHEN/SA1/A1_COD?indice=1&ichave=D MG 0100000101&isnew=true
/*/
//------------------------------------------------------------------------------
Method getFieldProperty() as Logical class pgvDictionaryCheck  

	Local jResponse	   := JsonObject():New()                                        as json
	Local cFields 	   := getPathParams("fields")                                   as character
    Local cProperties  := getPathParams("properties")                               as character
    Local cTable       := getPathParams("table")                                    as character
    Local aProperties  := {}                                                        as array
    Local aFields      := {}                                                        as array
    Local cSeparador   := " "                                                       as character
    Local cChave       := oRest:getQueryRequest():GetJsonText('chave')              as character
    Local nIndice      := Val(oRest:getQueryRequest():GetJsonText('indice'))        as numeric
    Local cIsNew       := oRest:getQueryRequest():GetJsonText('isnew')              as character
    Local cError       := ""                                                        as character
    Local bError       := ErrorBlock({|oError| cError += oError:Description+CRLF})  as variant
    Local nProperties  := 0                                                         as numeric 
    Local nFields      := 0                                                         as numeric 
    Local lSeek        := !Empty(nIndice) .AND. !Empty(cTable) .AND. !Empty(cChave) as logical
    Local cExec        := "X3_VALID|X3_WHEN|X3_VLDUSER|X3_RELACAO|X3_INIBRW"        as character

    aProperties := StrTokArr(cProperties, cSeparador) 
    aFields     := StrTokArr(cFields, cSeparador) 

    If lSeek
        DBSelectArea(cTable)
        (cTable)->(DBSetOrder(nIndice))
        (cTable)->(DbSeek(cChave))
    EndIf

    For nFields := 1 to len(aFields)
        jResponse[aFields[nFields]] := jsonObject():new()
        For nProperties := 1 to len(aProperties)
            cStruct := getSX3Cache(aFields[nFields], aProperties[nProperties])
            If !Empty(aFields[nFields]) 
                If !Empty(cStruct) .AND. aProperties[nProperties] $ cExec
                    BEGIN SEQUENCE
                        If !Empty(cIsNew) .And. cIsNew == "true" .And. 'INCLUI' $ cStruct
                            INCLUI := .T.
                        EndIf
                        jResponse[aFields[nFields]][aProperties[nProperties]] := &(cStruct)
                    END SEQUENCE
                ElseIf !Empty(cStruct)
                    jResponse[aFields[nFields]][aProperties[nProperties]] := Alltrim(cStruct)
                EndIf
            EndIf 
        Next
    Next

    ErrorBlock(bError)

    If lSeek
        (cTable)->(DbCloseArea())
    EndIf

    If !Empty(cError)     
        SetRestFault(400, FWHttpEncode(cError))
    Else  
        oRest:setKeyHeaderResponse('Content-Type','application/json; charset=utf-8')
        oRest:setStatusCode(200)
        oRest:setResponse(FWHttpEncode(jResponse:toJson()))
    EndIf 

    FreeObj(jResponse)
    
Return .T.
 