STATIC nLinhasAtu := 0
STATIC aRecnosMVC := {}     // guarda os Recnos utilizados quando usado MVC
STATIC xRetConPad := Nil    // guarda temporariamente o retorno da Consulta Padrão do Campo C0_DOCRES
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ DATA   ³ BOPS ³Prograd.³ALTERACAO                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³03.10.98³      ³Eduardo ³Inclusao de Tratamento para Depuracao de Reser³±±
±±³        ³      ³        ³va automatica.                                ³±±
±±³15.06.98³      ³Edson   ³Inclusao do PE MSC0430A                       ³±±
±±³25.06.98³      ³Edson   ³Ajuste da Ordem qdo. ret. da funcao A430F4.   ³±±
±±³10.08.98³      ³Eduardo ³Revisao da Rotina de Reserva - Meta 2.07      ³±±
±±³01/02/99³META  ³Rodrigo ³Acerto na verificacao da qtd empenhada        ³±±
±±ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
#Include "MATA430.CH"
#Include "PROTHEUS.CH"
#Include "FWMVCDEF.CH"

PUBLISH MODEL REST NAME MATA430 SOURCE MATA430

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Mata430  ³ Autor ³ Eveli Morasco         ³ Data ³ 08/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Manutencao de Reservas                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MatA430()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Array contendo os campos do arquivo que sempre deverao³
//³ aparecer no browse. (funcao mBrouse)                         ³
//³ ----------- Elementos contidos por dimensao ---------------- ³
//³ 1. Titulo do campo (Este nao pode ter mais de 12 caracteres) ³
//³ 2. Nome do campo a ser editado                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LOCAL aFixe := { 	{ OemToAnsi(STR0001),"C0_NUM    " },;		//"N£mero      "
				{ OemToAnsi(STR0002),"C0_TIPO   " },;		//"Tipo"
				{ OemToAnsi(STR0003),"C0_DOCRES " },;		//"Documento   "
				{ OemToAnsi(STR0004),"C0_SOLICIT" },;		//"Solicitante "
				{ OemToAnsi(STR0005),"C0_FILRES " },;		//"Fil.Reserva "
				{ OemToAnsi(STR0006),"C0_EMISSAO" } }		//"Emiss„o"

Local aCores     := {} 
Local aIndexSC0  := {}
Local cFiltraSC0 := ""

Local oBrowse    := Nil   // Browse criada para o MVC
Local nX		 := 0
Local aTmp		 := {}

Private lPyme    := If( Type( "__lPyme" ) <> "U", __lPyme, .F. )

Private aRotina  := {}

Private cCadastro  := OemToAnsi(STR0013)		//"Controle de Reservas"
Private bFiltraBrw := {|| Nil}
Private __lKeyF4Loc	:= .F.	//Tecla F4 do campo de endereço

Aadd( aCores, { "C0_QUANT=C0_QTDORIG"                 , "RED"   , STR0052} ) // Reserva nao baixada
Aadd( aCores, { "C0_QUANT<>0.AND.C0_QUANT<>C0_QTDORIG", "YELLOW", STR0054} ) // Reserva parcialmente baixada
Aadd( aCores, { "C0_QTDELIM<>0"                       , "BLUE"  , STR0055} ) // Reserva com residuo eliminado
Aadd( aCores, { "C0_QUANT=0.AND.C0_QTDELIM=0"         , "GREEN" , STR0053} ) // Reserva totalmente baixada

If ExistBlock( "M430COR" )
	aTmp := ExecBlock( "M430COR", .F., .F., { aCores } )
	If ValType(aTmp) == "A" .And. Len(aTmp) > 0 .And. Len(aTmp[1]) == 3
		aCores := aClone(aTmp)
	EndIf
	aTmp := Nil
EndIf 

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ajustes para o Protheus 10 Express³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If FindFunction( "Pyme_Dic_Ajust" )
	Pyme_Dic_Ajust("SC0", .T.)
EndIf

aRotina := MenuDef()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa o filtro de usuario utilizando a funcao FilBrowse           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC0")
dbSetOrder(1)  // FILIAL + NUMERO + PRODUTO + Local

If ExistBlock( "M430FIL" )
	cFiltraSC0	:= ExecBlock( "M430FIL", .F., .F. )
	bFiltraBrw 	:= {|| FilBrowse("SC0",@aIndexSC0,@cFiltraSC0) }
EndIf 	

oBrowse := FWMBrowse():New()
oBrowse:SetAlias('SC0')
oBrowse:SetDescription( cCadastro )
oBrowse:DisableDetails()

For nX := 1 to Len(aCores)
	oBrowse:AddLegend(aCores[nX,1],aCores[nX,2],aCores[nX,3])
Next nX
	
If ValType(cFiltraSC0)=='C' .And. !Empty( cFiltraSC0 )
	oBrowse:SetFilterDefault( cFiltraSC0 )
EndIf
	
oBrowse:Activate()

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430Visual³ Autor ³ Eveli Morasco         ³ Data ³ 08/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de visualizacao de uma Reserva                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void A430Visual(ExpC1,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Numero da opcao selecionada                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION A430Visual(cAlias,nReg,nOpcx)

FWExecView(,'MATA430')

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430Inclui³ Autor ³ Eveli Morasco         ³ Data ³ 08/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de inclusao de Reservas                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void A430Inclui(ExpC1,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION A430Inclui(cAlias,nReg,nOpcx)

FWExecView(,'MATA430',MODEL_OPERATION_INSERT)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430Altera³ Autor ³ Eveli Morasco         ³ Data ³ 10/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de alteracao de uma Reserva                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void A430Altera(ExpC1,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada no menu                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION A430Altera(cAlias,nReg,nOpcx)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se nao e LB/LW                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( SC0->C0_TIPO =="LW" )
	Help(" ",1,"A430LB")
	Return .T.
Else
	FWExecView(,'MATA430',MODEL_OPERATION_UPDATE)
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430Deleta³ Autor ³ Eveli Morasco         ³ Data ³ 10/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de exclusao de Reservas                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void A430Deleta(ExpC1,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Numero da opcao selecionada                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION A430Deleta(cAlias,nReg,nOpcx)

FWExecView(,'MATA430',MODEL_OPERATION_DELETE)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430Depura³ Autor ³ Claudinei M. Benzi    ³ Data ³ 05/11/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de depuracao de Reservas                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void A430Depura(ExpC1,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Numero da opcao selecionada                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A430Depura(cAlias,nReg,nOpcx)

LOCAL nOpcA		:=0
Local oDlg
Local lFiltro   := .F.

If !Empty(SC0->(dbFilter()))
	SC0->(dbClearFilter())
	lFiltro := .T.
Endif	

dbSelectArea(cAlias)
While .T.
	DEFINE MSDIALOG oDlg FROM  96,   9 TO 240,592 TITLE OemToAnsi(STR0018) PIXEL		//"Rec lculo dos Saldos"
	@ 11, 6 TO 52, 287 LABEL "" OF oDlg  PIXEL
	@ 24, 15 SAY STR0019 SIZE 268, 8 OF oDlg PIXEL		//"Este programa tem como objetivo eliminar automaticamente as reservas  com prazo de validade vencida.  "
	DEFINE SBUTTON FROM 55, 224 TYPE 1 ACTION (oDlg:End(),nOpca:=1) ENABLE OF oDlg
	DEFINE SBUTTON FROM 55, 254 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg
	If nOpca == 1
		Processa({|lEnd| FA430Process(@lEnd,cAlias)},OemToAnsi(STR0020),OemToAnsi(STR0021),.F.)		//"Depura‡„o de Reservas"###"Depurando reservas ..."
	EndIf

	Exit
EndDo

If Type("bFiltraBrw") == "B" .And. lFiltro
	Eval(bFiltraBrw)
Endif

Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ A430F4   ³ Autor ³ Eveli Morasco         ³ Data ³ 09/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consulta produtos reservados com informacoes adicionais    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430F4(a,b,c,ExpC1)                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ a,b,c = parametros padroes quando utiliza-se o SetKey()    ³±±
±±³          ³ ExpC1 = Alias do arquivo a ser consultado                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION A430F4(a,b,c,cAlias)
LOCAL aArrayF4	:={},nX,cVar
LOCAL nPosQuant,nPosLote,cPict, oDlg, oQual,nPosCod,nPosOrig
LOCAL cLoc , nQuant, nOpca := 0, nList := 0
LOCAL nAcho
LOCAL nOrd 		:= IndexOrd()
LOCAL cSavCad 	:= cCadastro
LOCAL cProduto	:= "" 
LOCAL nPosLoc 	:= 0 
LOCAL cLoteCt, nPosLoteCt, nQuantLt, nSaldoLt
LOCAL nY 		:= 0 
LOCAL lEmpPrev 	:= If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local oModel 	:= FwModelActive()
Local oModelGrid := oModel:GetModel('SC0GRID')

//Alteração para compatibilidade do MVC
Local aAuxRet		:= {}

If oModel:GetId()=='MATA430'
	aAuxRet   := oModel:GetModel('SC0GRID'):GetOldData()
		
	//--------------------------------------------
	// quando for MVC inicializa as variáveis em modo Private
	// para não ter que alterar a referência nas funções dependentes/encadeadas 
	aHeader   := aClone(aAuxRet[1])
	aCols     := aClone(aAuxRet[2])
	n := oModel:GetModel('SC0GRID'):GetLine()
EndIf

cProduto	:= aCols[ n, AScan( aHeader, { |x| x[ 2 ] == "C0_PRODUTO" } ) ]
nPosLoc 	:= AScan( aHeader, { |x| AllTrim(x[2]) == "C0_LOCAL" } ) 

If (ReadVar() $ "M->C0_NUMLOTE/M->C0_LOTECTL" .And. Rastro(cProduto)) .Or. ;
		"C0_QUANT" $ ReadVar()

	For ny:=1 to Len(aHeader)
		If aHeader[ny][2] == "C0_PRODUTO"
			Exit
		EndIf
	Next ny
	cPict:=PesqpictQt("B8_SALDO",TamSX3("B8_SALDO")[1])
	If Rastro(aCols[n][ny])

		cProduto := oModelGrid:GetValue('C0_PRODUTO')
		nPosCod := aScan( aHeader, { |x| AllTrim(x[2]) == "C0_PRODUTO" } )

		cLocal := oModelGrid:GetValue('C0_LOCAL')
		cLote := oModelGrid:GetValue('C0_NUMLOTE')
		nPosLote := aScan( aHeader, { |x| Alltrim(x[2]) == "C0_NUMLOTE" } )
		
		cLoteCt := oModelGrid:GetValue('C0_LOTECTL')
		nPosLoteCt := aScan( aHeader, { |x| Alltrim(x[2]) == "C0_LOTECTL" } )
		
		nQuant := oModelGrid:GetValue('C0_QUANT')
		nPosQuant := aScan( aHeader, { |x| Alltrim(x[2]) == "C0_QUANT" } )
		
		nPosOrig := aScan( aHeader, { |x| Alltrim(x[2]) == "C0_QTDORIG" } )
		
		If "C0_QUANT" $ ReadVar()
			M->C0_QUANT := aCols[n][nPosQuant]
			nQuant := M->C0_QUANT
		EndIf
		cAlias:=Alias()
		dbSelectArea("SB8")
		dbSetOrder(1)
		nSaldo := 0
		MsSeek(xFilial()+cProduto+cLocal)

		While !EOF() .And. B8_FILIAL+B8_PRODUTO+B8_LOCAL == xFilial()+cProduto+cLocal
			If SB8SALDO(,,,,,lEmpPrev,,,.T.)-(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1)) <= 0
				DbSkip()
				Loop
			EndIf

			If Rastro( cProduto, "S" )
				AADD(aArrayF4, { B8_NUMLOTE,B8_PRODUTO,Dtoc(B8_DATA),;
					Dtoc(B8_DTVALID),Transform(SB8SALDO(,,,,,lEmpPrev,,,.T.)-(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1)),cPict),B8_LOTECTL })
			Else

				nScan := AScan( aArrayF4, { |x| x[6] == B8_LOTECTL } )

				If nScan == 0
					AADD(aArrayF4, { B8_NUMLOTE,B8_PRODUTO,Dtoc(B8_DATA),;
						Dtoc(B8_DTVALID),Transform(SB8SALDO(,,,,,lEmpPrev,,,.T.)-(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1)),cPict),B8_LOTECTL })
				Else
					nSaldoLt := Val( aArrayF4[ nScan, 5 ] )
					nSaldoLt += SB8SALDO(,,,,,lEmpPrev,,,.T.) - (SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1))
					aArrayF4[ nScan ] := { B8_NUMLOTE,B8_PRODUTO,Dtoc(B8_DATA),;
						Dtoc(B8_DTVALID),Transform(nSaldoLt,cPict),B8_LOTECTL }
				EndIf
			EndIf

			nSaldo += SB8SALDO(,,,,,lEmpPrev,,,.T.)-(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1))

			cLtAnt := B8_LOTECTL

			dbSkip()
		EndDo

		If Len(aArrayF4) > 0
			nOpcA := 0
			cCadastro := OemToAnsi(STR0022)		//"Saldos por Lote"		  
			
			DEFINE MSDIALOG oDlg TITLE cCadastro From 09,0 To 40,110 OF oMainWnd		
			@ 0.5,  0 TO 15, 54.0 OF oDlg
			@ 1,  .7  Say OemToAnsi(STR0023)		//"Saldo Dispon¡vel  "		
			@ 1, 7  Say Transform(nSaldo,cPict)
			@ 2,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0024),OemToAnsi(STR0025),OemToAnsi(STR0026),OemToAnsi(STR0027),OemToAnsi(STR0028),OemToAnsi(STR0037) SIZE 420,180 ON DBLCLICK (nList:= oQual:nAt, nOpca := 1,oDlg:End())		//"Sub.Lote"###"Produto"###"Data"###"Dt.Valid."###"Saldo"###"Lote"
			oQual:SetArray(aArrayF4)
			oQual:bLine := { ||{aArrayF4[oQual:nAT,1],aArrayF4[oQual:nAT,2],;
				aArrayF4[oQual:nAT,3],aArrayF4[oQual:nAT,4],;
				aArrayF4[oQual:nAT,5],aArrayF4[oQual:nAT,6]}}
		   
			DEFINE SBUTTON FROM 215, 375  TYPE 1 ACTION (nList:= oQual:nAt, nOpca := 1,oDlg:End()) ENABLE OF oDlg
			DEFINE SBUTTON FROM 215, 405  TYPE 2 ACTION (nList:= oQual:nAt, oDlg:End()) ENABLE OF oDlg
			
			ACTIVATE MSDIALOG oDlg
			If nOpca == 1

				cLote:=aArrayF4[nList][1]
				cProduto:=aArrayF4[nList][2]

				cLoteCt := aArrayF4[nList][6]

				If Rastro( cProduto, "S" )
					If "C0_NUMLOTE" $ ReadVar()
						aCols[ n, nPosLoteCt ] := cLoteCt
					EndIf
					If "C0_LOTECTL" $ ReadVar()
						aCols[ n, nPosLote ]   := cLote
					EndIf
				Else
					aCols[ n, nPosLote ] := cLote := CriaVar( "C0_NUMLOTE" )
				EndIf

				dbSetOrder(2)

				If Rastro( cProduto, "S" )
					dbSetOrder( 2 )
					cChave := xFilial("SB8") + cLote + cLoteCt  + cProduto + ;
						cLocal
				Else
					dbSetOrder( 3 )
					cChave := xFilial("SB8") + cProduto + cLocal + cLoteCt
				EndIf

				MsSeek(cChave)

				If Rastro( cProduto, "L" )

					nQuantLt := SaldoLote( cProduto, cLocal, cLoteCt )

					If nQuant > nQuantLt .OR. nQuant == 0
						nQuant:= nQuantLt
					EndIf
					dbSetOrder(1)
				Else

					If nQuant > SB8SALDO(,,,,,lEmpPrev,,,.T.)-(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1)) .OR. nQuant == 0
					   nQuant:= SB8SALDO(,,,,,lEmpPrev,,,.T.)-(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1))
					EndIf
				EndIf

				dbSetOrder(1)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Devolve areas , indices e posicoes anteriores                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea( cAlias )
				If "C0_NUMLOTE" $ ReadVar()
					&(ReadVar()) := cLote
				ElseIf  "C0_LOTECTL" $ ReadVar()
					&(ReadVar()) := cLoteCt
				ElseIf  "C0_QUANT" $ ReadVar()
					&(ReadVar()) := nQuant
				EndIf
				nAcho:=ASCAN(aCols,{|x| x[nPosCod] == cProduto .And. x[nPosLote]	== cLote})
				// N„o, as linhas abaixo n„o est„o invertidas:

				If  "C0_NUMLOTE" $ ReadVar()
					If nAcho > 0 .And. nAcho != n
						aCols[n][nPosQuant] := CriaVar("C0_QUANT")
						aCols[n][nPosLote]  := CriaVar("C0_NUMLOTE")
						aCols[n][nPosOrig]  := CriaVar("C0_QTDORIG")
					Else
						aCols[n][nPosQuant]:=nQuant
						aCols[n][nPosOrig] :=nQuant
					EndIf
				ElseIf  "C0_QUANT" $ ReadVar()
					If nAcho > 0 .And. nAcho != n
						aCols[n][nPosQuant] := CriaVar("C0_QUANT")
						aCols[n][nPosLote]  := CriaVar("C0_NUMLOTE")
						aCols[n][nPosOrig]  := CriaVar("C0_QTDORIG")
					Else
						aCols[n][nPosLote]:=cLote
					EndIf
				EndIf
			EndIf
		Else
			Help(" ",1,"A440NAOLOTE")
		Endif

	Else
		For ny:=1 to Len(aHeader)
			If Rtrim(aHeader[ny][2]) == "C0_PRODUTO"
				cVar   := Acols[n][ny]
			ElseIf Rtrim(aHeader[ny][2]) == "C0_LOCAL"
				cLoc   := Acols[n][ny]
			EndIf
		Next ny
		cAlias:=Alias()
		dbSelectArea("SC0")
		dbSetOrder(2)    // Ordem por produto
		MsSeek(xFilial()+cVar+cLoc)
		While !EOF() .And. C0_FILIAL+C0_PRODUTO+C0_LOCAL == xFilial()+cVar+aCols[n][nPosLoc]
			AADD(aArrayF4,{ C0_TIPO,C0_SOLICIT,C0_FILRES,Dtoc(C0_EMISSAO),Dtoc(C0_VALIDA),Str(C0_QUANT,10,3) } )
			dbSkip()
		End
		dbSelectArea("SB2")
		dbSetOrder(1)
		MsSeek(xFilial("SB2")+cVar+aCols[n][nPosLoc])
		cCadastro := OemToAnsi(STR0029)		//"Reservas"
		DEFINE MSDIALOG oDlg TITLE cCadastro From 09,0 To 20.3,60 OF oMainWnd
		@ 0.6,  0.5 TO 5.8, 29.6 LABEL cCadastro OF oDlg
		@ 0.5,  0.2 TO 6, 29.9 OF oDlg
		@ 1.2, 01  Say OemToAnsi(STR0030)		//"Estoque: "
		@ 1.2, 04  Say Transform((SB2->B2_QATU-SB2->B2_QEMPN),cPict)
		@ 1.7, 01  Say OemToAnsi(STR0031)	//"Saldo: "
		@ 1.7, 04 Say Transform(SaldoMov(),cPict)
		If Len(aArrayF4) > 0
			@ 2.6,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0002),OemToAnsi(STR0016),OemToAnsi(STR0017),OemToAnsi(STR0006),OemToAnsi(STR0032),OemToAnsi(STR0033) SIZE 230,44		//"Tipo"###"Solicit"###"Filial"###"Emiss„o"###"Validade"###"Qtd.Reservada"
			oQual:SetArray(aArrayF4)
			oQual:bLine := { || {aArrayF4[oQual:nAT][1],aArrayF4[oQual:nAT][2],aArrayF4[oQual:nAT][3],aArrayF4[oQual:nAT][4],aArrayF4[oQual:nAT][5],aArrayF4[oQual:nAT][6]}}
		Else
			@ 2.5,01 Say OemToAnsi(STR0034)		//"N„o existe reserva"
		EndIf
		DEFINE SBUTTON FROM 12  ,208  TYPE 1 ACTION (nOpca := 1,oDlg:End()) ENABLE OF oDlg
		DEFINE SBUTTON FROM 24 ,208  TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
		ACTIVATE MSDIALOG oDlg
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Devolve areas , indices e posicoes anteriores                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea(cAlias)
	dbSetOrder(nOrd)
End
cCadastro := cSavCad
Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430Local ³ Autor ³ Eveli Morasco         ³ Data ³ 10/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o local informado esta' cadastrado             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430Local()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A430Local()
LOCAL cLocal  := &(ReadVar()),lRetorna := .T.,nx
Local cProduto:= ""
Local oModel  := Nil
Local nPosPro := aScan(aHeader,{|x| AllTrim(x[2]) == "C0_PRODUTO" })
Local nPosLoc := aScan(aHeader,{|x| AllTrim(x[2]) == "C0_LOCAL"   }) 
Local nPRecno := aScan(aHeader,{|x| AllTrim(x[2]) == "C0_REC_WT"  })

oModel := FwModelActive()
If oModel:GetId()=='MATA430'
	If oModel:GetModel('SC0GRID'):IsInserted(oModel:GetModel('SC0GRID'):GetLine()) .Or. oModel:GetOperation() <> MODEL_OPERATION_UPDATE .Or. oModel:GetModel('SC0GRID'):GetOperation() <> MODEL_OPERATION_UPDATE .Or. ;
		cLocal == oModel:GetModel('SC0GRID'):GetValue('C0_LOCAL')
			
		cProduto := oModel:GetModel('SC0GRID'):GetValue('C0_PRODUTO')
		oModel:GetModel('SC0GRID'):LoadValue('C0_NUMLOTE', CriaVar('C0_NUMLOTE') )
		oModel:GetModel('SC0GRID'):LoadValue('C0_LOTECTL', CriaVar('C0_LOTECTL') )
		oModel:GetModel('SC0GRID'):LoadValue('C0_NUMSERI', CriaVar('C0_NUMSERI') )
		oModel:GetModel('SC0GRID'):LoadValue('C0_LOCALIZ', CriaVar('C0_LOCALIZ') )
	EndIf
EndIf

If lRetorna
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(xFilial()+cProduto+cLocal) )
		Help(" ",1,"A430LOCAL")
		lRetorna := .F.
	Endif
EndIf

Return lRetorna

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430Quant ³ Autor ³ Eveli Morasco         ³ Data ³ 09/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica a quantidade informada                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430Quant()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A430Quant()
LOCAL nQuant		:= &(ReadVar())
Local lRetorna	:= .T.
Local nQuantAnt	:= 0
LOCAL cProduto	:=""
Local cLocal		:= ""
LOCAL nPosQuant	:=0
Local nPosQtdOri	:= 0
LOCAL cLocaliza	:= Space(TamSX3("C0_LOCALIZ")[1])
LOCAL cNumSerie	:= Space(TamSX3("C0_NUMSERI")[1])
LOCAL nX			:= 0 
Local oMdlAct		:= FwModelActive()
Local cNumRes		:= If( Type('cNum')=='C', cNum, ' ' )
Local nQtdOri		:= 0
Local lAltera430	:= oMdlAct:GetOperation() == MODEL_OPERATION_UPDATE
Local lTpSldRes 	:= (SuperGetMV("MV_TPSALDO",.F.,"Q") == "S" .And. SuperGetMV("MV_SLDRESE",.F.,"N") == "N")

cNumRes   := oMdlAct:GetValue( 'MASTER',  'C0_NUM' )
cProduto  := oMdlAct:GetValue( 'SC0GRID', 'C0_PRODUTO' )
cLocal    := oMdlAct:GetValue( 'SC0GRID', 'C0_LOCAL' )
cLote     := oMdlAct:GetValue( 'SC0GRID', 'C0_NUMLOTE' )
cLocaliza := oMdlAct:GetValue( 'SC0GRID', 'C0_LOCALIZ' )
cNumSerie := oMdlAct:GetValue( 'SC0GRID', 'C0_NUMSERI' )
cLoteDigi := oMdlAct:GetValue( 'SC0GRID', 'C0_LOTECTL' )
nQtdOri   := oMdlAct:GetValue( 'SC0GRID', 'C0_QTDORIG' )

lRetorna := Positivo(nQuant)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Quando for alteracao nao deve-se permitir a alteracao da quantidade.    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAltera430
	dbSelectArea("SC0")
	dbSetOrder(1)
	If MsSeek(xFilial("SC0")+cNumRes+cProduto+cLocal)
		nQuantAnt := SC0->C0_QUANT
		If (cLote <> SC0->C0_NUMLOTE .Or. cLocaliza <> SC0->C0_LOCALIZ .Or. cLoteDigi <> SC0->C0_LOTECTL .Or. cNumSerie <> SC0->C0_NUMSERI) .And. (nQtdOri != M->C0_QUANT)
			Help(" ",1,"A430QUANT2")
			lRetorna := .F.
		EndIf
	EndIf
EndIf

If lRetorna
	lRetorna := NaoVazio(nQuant)
EndIf
If lRetorna
	dbSelectArea("SB2")
	dbSetOrder(1)
	MsSeek(xFilial("SB2")+cProduto+cLocal)
	If (!lTpSldRes .And. nQuant <> nQuantAnt .And. nQuant > SaldoMov()+nQuantAnt) .Or.;
		(lTpSldRes .And. nQuant <> nQuantAnt .And. nQuant > SaldoMov())
		Help(" ",1,"A430QUANT")
		If Rastro(cProduto) .Or. Localiza(cProduto)
			lRetorna := .F.
		Else
			lRetorna := .F.
		EndIf
	EndIf
	If lRetorna
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Consiste se a localizacao possui saldo  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Localiza( cProduto )
			If IntDl(cProduto) .And. SaldoSBF(cLocal, cLocaliza, cProduto, cNumSerie, cLoteDigi, cLote)+nQuantAnt < nQuant
				Help(" ",1,"SALDOLOCLZ")
				lRetorna := .F.		
			ElseIf !Empty(cLocaliza) .And. SaldoSBF(cLocal, cLocaliza, cProduto, cNumSerie, cLoteDigi, cLote)+nQuantAnt < nQuant
				Help(" ",1,"SALDOLOCLZ")
				lRetorna := .F.
			EndIf
		EndIf
	EndIf
	If lRetorna
		oMdlAct:LoadValue( 'SC0GRID', 'C0_QUANT', nQuant )
	Else
		oMdlAct:LoadValue( 'SC0GRID', 'C0_QUANT', 0 )
	Endif
EndIf
Return lRetorna

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430LinOk ³ Autor ³ Eveli Morasco         ³ Data ³ 09/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Critica se a linha digitada esta' Ok                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430LinOk(ExpO1)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 = Objeto a ser verificado.                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MatA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A430LinOk(o)

Local aArea			:= GetArea()
Local aAreaSC0		:= SC0->(GetArea())

Local cProduto		:= ""
Local cLocal			:= ""
Local cNumLote		:= ""
Local cLoteCt			:= ""
LOCAL cLocaliz		:= Space(TamSX3("C0_LOCALIZ")[1])
LOCAL cNumSeri		:= Space(TamSX3("C0_NUMSERI")[1])
Local cChave			:= ""
Local dValida			:= ""

Local nX			:= 0
Local nQuant		:= 0
Local nQuant1		:= 0
Local nPosQuant		:= 0
Local nPosProd		:= 0
Local nPosDel		:= 0

Local lLocalizLote	:= .F.
Local lRetorna		:= .T.
Local lExist		:= .F.
Local lEmpPrev		:= If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)

Local oMdlGrl		:= FwModelActive()
Local cNumRes		:= oMdlGrl:GetValue( 'MASTER', 'C0_NUM' )
Local lInclui430    := oMdlGrl:GetOperation() == MODEL_OPERATION_INSERT
Local lAltera430	:= oMdlGrl:GetOperation() == MODEL_OPERATION_UPDATE
Local cFilSB8		:= xFilial("SB8")
Local lWmsNew 		:= SuperGetMV("MV_WMSNEW",.F.,.F.)
Local lTpSldRes 	:= (SuperGetMV("MV_TPSALDO",.F.,"Q") == "S" .And. SuperGetMV("MV_SLDRESE",.F.,"N") == "N")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ verifica se item esta' deletado                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !aCols[n][Len(aCols[n])]
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ verifica se algum campo importante ficou em branco           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 To Len(aHeader)
		If Trim(aHeader[nx][2]) == "C0_PRODUTO"
			cProduto := aCols[n][nx]
			nPosProd := nX
			If Empty(cProduto) .And. n == Len(aCols)
				Help(" ",1,"A43002")
				lRetorna := .F.
				Exit
			EndIf
		ElseIF Trim(aHeader[nx][2]) == "C0_LOCAL"
			cLocal := aCols[n][nx]
		ElseIF Trim(aHeader[nx][2]) == "C0_QUANT"
			nQuant1 := aCols[n][nx]
			nPosQuant:=nx
		ElseIF Trim(aHeader[nx][2]) == "C0_NUMLOTE"
			cNumLote:= aCols[n][nx]
		ElseIf Trim(aHeader[nx][2]) == "C0_LOTECTL"
			cLoteCt  := aCols[n][nx]
		ElseIf Trim(aHeader[nx][2]) == "C0_LOCALIZ"
			cLocaliz := aCols[n][nx]
		ElseIf Trim(aHeader[nx][2]) == "C0_NUMSERI"
			cNumSeri := aCols[n][nx]
		ElseIf Trim(aHeader[nx][2]) == "C0_VALIDA"
			dValida := aCols[n][nx]
		EndIf
	Next nX

	If !lInclui430
		dbSelectArea("SC0")
		dbSetOrder(1)
		If MsSeek(xFilial("SC0")+cNumRes+cProduto+cLocal)
			If (cNumLote <> SC0->C0_NUMLOTE .Or. cLocaliz <> SC0->C0_LOCALIZ .Or. cLoteCt <> SC0->C0_LOTECTL .Or. cNumSeri <> SC0->C0_NUMSERI) .And. (nQuant1 != SC0->C0_QUANT)
				Help(" ",1,"A430QUANT2")
				lRetorna := .F.
			EndIf
		EndIf
	EndIf

	If ( lRetorna .And. nQuant1 == 0 .And. !lAltera430 )
		Help(" ",1,"A43002")
		lRetorna := .F.
	EndIf
	
		//Valida o Lote e o numero de serie
	If lRetorna
		If !Empty(cLocaliz) .And. !VldLocaliz("A430",.T.,cLocaliz)
			Help(" ",1,"A430LOCALIZ")
			lRetorna := .F.
		EndIf
	EndIf
	
	If lRetorna
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Checa se ja' incluiu este produto ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPosDel := Len( aHeader ) + 1
		AEval(aCols, {|x,y| lExist := If(lExist, .T., (x[nPosProd] == cProduto .And. n <> y .And. !x[nPosDel]))})
		If lExist
			lRetorna := .F.
			Help( " ", 1, "A430RESPRD" )
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se usa rastreabilidade e o numero do Lote esta vazio, mostra ³
	//³ help e impede inclusao da linha.                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !IntDL(cProduto)
		If ( lRetorna .And. Rastro(cProduto) )
			If	( Rastro( cProduto, "S" ) .And. Empty(cNumLote) ) .Or. ;
				( Rastro( cProduto, "L" ) .And. Empty(cLoteCt) )
				Help(" ",1,"LOTEVAZIO")
				lRetorna:=.F.
			EndIf
		EndIf
	EndIf

	//Não efetua reserva para produto com controle de WMS e rastreabilidade, sem o lote preenchido.
	If lRetorna .And. lWmsNew .And. IntWMS(cProduto) .And. Rastro(cProduto) .And. Empty(cNumLote) .And. Empty(cLoteCt)
		Help(" ",1,"LOTEVAZIO")
		lRetorna := .F.
	EndIf

	//Se WMS ATUAL ativado deve obrigar endereco quando tem lote/sublote preenchido DLOGWMSMSP-16122
	If lRetorna .And. IntDL(cProduto) .And. !lWmsNew .And.;
		((Rastro(cProduto,"S") .And. !Empty(cNumLote)) .Or. (Rastro(cProduto,"L") .And. !Empty(cLoteCt))) .And.;
		Localiza(cProduto) .And. Empty(cLocaliz)					//'Endereço vazio' #### '
		Help( " ", 1, "A430WMSLOTE", , STR0067,1,1,,,,,,{STR0068} ) //Ao informar o lote/sublote para produtos com controle WMS, o endereço torna-se obrigatório. 
		lRetorna := .F.												//Favor realizar o preenchimento do campo endereço ou remover o lote/sublote definido.'
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Checa se o saldo do estoque e' suficiente para reserva       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorna
		nQuant := 0
		If !lInclui430
			dbSelectArea("SC0")
			dbSetOrder(1)
			MsSeek(xFilial("SC0")+cNumRes+cProduto+cLocal)
			nQuant := SC0->C0_QUANT
		EndIf
		dbSelectArea("SB2")
		dbSetOrder(1)
		If ( !MsSeek(xFilial("SB2")+cProduto+cLocal) )
			Help(" ",1,"A430LOCAL")
			lRetorna := .F.
		ElseIf (!lTpSldRes .And. nQuant1 <> nQuant .And. nQuant1 > SaldoMov()+nQuant) .Or.;
			(lTpSldRes .And. nQuant1 <> nQuant .And. nQuant1 > SaldoMov())
			Help(" ",1,"A430QUANT")
			lRetorna := .F.
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Checa se o saldo do lote eh suficiente para a reserva        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !IntDL(cProduto)
			If ( lRetorna .And. Rastro(cProduto) )
				If Rastro( cProduto, "S" )
					lLocalizLote	:= .F.
					dbSelectArea("SB8")
					dbSetOrder( 2 )
					MsSeek(cFilSB8 + cNumLote + cLoteCt + cProduto + cLocal)
					While SB8->(! Eof()) .AND. SB8->B8_FILIAL == cFilSB8 .AND. SB8->B8_NUMLOTE == cNumLote .AND. SB8->B8_LOTECTL == cLoteCt .AND. SB8->B8_PRODUTO == cProduto .AND. SB8->B8_LOCAL == cLocal
						If	SB8->B8_DTVALID >= dValida
							lLocalizLote	:= .T.
							EXIT
						EndIf
						SB8->(DbSkip())
					EndDo
					If	lLocalizLote
						If ( nQuant1 > (SB8SALDO(,,,,,lEmpPrev,,,.T.)-((SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)-nQuant)+AvalQtdPre("SB8",1))) )				
							Help( " ", 1, "A430LinOk", , STR0059,1,1,,,,,,{STR0060} ) // 'Saldo não encontrado!' ##### 'Verifique os dados de número do lote/sublote, produto, local e validade'
							lRetorna := .F.
						EndIf
					Else
						Help( " ", 1, "A430LinOk", , STR0063,1,1,,,,,,{STR0060} ) // "Lote/Sublote não encontrado ou fora do prazo de validade da reserva." ##### 'Verifique os dados de número do lote/sublote, produto, local e validade'
						lRetorna := .F.
					EndIf
				Else
					If ( nQuant1 > SaldoLote(cProduto,cLocal,cLoteCt)+nQuant )
						Help( " ", 1, "A430LinOk", , STR0061,1,1,,,,,,{STR0061} ) //'Sem saldo!' #### 'Quantidade de saldo do lote insuficiente!'
						lRetorna := .F.
					EndIf
				EndIf
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Checa se o saldo da Localizacao e suficiente                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( lRetorna .And. Localiza( cProduto ) )
			If IntDL(cProduto) .Or. ! Empty( cLocaliz )
				If SaldoSBF(cLocal, cLocaliz, cProduto, cNumSeri, cLoteCt, cNumLote) + nQuant < nQuant1
					Help(" ",1,"SALDOLOCLZ")
					lRetorna := .F.
				EndIf
			ElseIf Empty( cLocaliz )
				SBF->( dbSetOrder( 1 ) )
				cChave := xFilial("SBF") + cLocal + Space(Len(SBF->BF_LOCALIZ)) + cProduto + cNumSeri + cLoteCt + cNumLote

				SBF->( MsSeek( cChave ) )
				nSaldoLcz := 0

				While SBF->(! Eof()) .AND. cChave == SBF->BF_FILIAL + SBF->BF_LOCAL + SBF->BF_LOCALIZ + SBF->BF_PRODUTO + SBF->BF_NUMSERI + SBF->BF_LOTECTL + SBF->BF_NUMLOTE
					nSaldoLcz += SBF->BF_QUANT - (SBF->BF_EMPENHO+AvalQtdPre("SBF",1))
					SBF->( dbSkip() )
				EndDo
				If nSaldoLcz + nQuant < nQuant1
					Help(" ",1,"A430QUANT")
					lRetorna := .F.
				EndIf
			EndIf
		EndIf
	EndIf
Else
	For nX := 1 To Len(aHeader)
		IF Trim(aHeader[nx][2]) == "C0_QUANT"
			nQuant1 := aCols[n][nx]
		ElseIf Trim(aHeader[nx][2]) == "C0_QTDORIG"
			nQuant := aCols[n][nx]
		Endif
	Next nX
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Nao permitir delecao de reservas utilizadas.                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nQuant1 != nQuant .And. nQuant != 0 )
		Help(" ",1,"A430DELETA")
		lRetorna := .F.
	EndIf
EndIf  

If lRetorna .And. ExistBlock("M430LIOK")
	lRetorna := ExecBlock("M430LIOK",.F.,.F.)
EndIf 

RestArea(aAreaSC0)
RestArea(aArea)
Return lRetorna

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430TudOk ³ Autor ³ Eveli Morasco         ³ Data ³ 09/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Critica se todas as linhas estao Ok                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430TudOk(ExpO1)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 = Objeto a ser verificado.                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MatA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A430TudOk(o)
Local nMaxArray     := 0 
Local lTudoOk       := ExistBlock("M430TOK") //Ponto de entrada para validar inclusão ou alteração de reservas 
Local lRet          := .T.
Local oMdlGrd       := o:GetModel('SC0GRID')
Local aFieldsGrd    := {}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ verifica quantos elementos validos existem no array          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If lTudoOk
	lRet:= ExecBlock('M430TOK',.F.,.F.)
EndIf

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430Grava ³ Autor ³ Eveli Morasco         ³ Data ³ 09/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava todos os dados digitados                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430Grava(ExpC1,ExpL1,ExpC2,ExpC3,ExpC4,ExpC5,ExpC6)       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo principal a ser atualizado        ³±±
±±³          ³ ExpL1 = .T. se for inclusao , .F. se for alteracao         ³±±
±±³          ³ ExpC2 = Numero da reserva                                  ³±±
±±³          ³ ExpC3 = Tipo da reserva                                    ³±±
±±³          ³ ExpC4 = Documento gerador da reserva                       ³±±
±±³          ³ ExpC5 = Solicitante                                        ³±±
±±³          ³ ExpC6 = Filial que esta' solicitando a reserva             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MatA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A430Grava(cAlias,lInclui,cNum,cTipoRes,cDocRes,cSolicit,cFilRes,aRecno)

Local lShowHelp 	:= .F.
Local nCntFor   	:= 0
Local nMaxFor		:= 0
Local nPosProduto 	:= 0
Local nPosLocal		:= 0
Local nPosQuant		:= 0
Local nPosLote		:= 0
Local nPosLoteCtl	:= 0
Local nPosLocaliz	:= 0
Local nPosNumSer	:= 0
Local nQuantElim	:= Nil
Local nPosQtElim	:= 0
Local lMsc0430A		:= ExistBlock("MSC0430A")
Local lInclui430    := .F.

Local oModel		:= Nil
Local aAuxRet		:= {}

oModel := FwModelActive()
If oModel:GetId()=='MATA430'
	aAuxRet   := oModel:GetModel('SC0GRID'):GetOldData()
	lInclui430    := oModel:GetOperation() == MODEL_OPERATION_INSERT

	//--------------------------------------------
	// quando for MVC inicializa as variáveis em modo Private
	// para não ter que alterar a referência nas funções dependentes/encadeadas 
	aHeader   := aClone(aAuxRet[1])
	aCols     := aClone(aAuxRet[2])
EndIf

nPosQtElim  := GDFieldPos( "C0_QTDELIM" )

For nCntFor := 1 To Len(aHeader)
	Do Case
	Case AllTrim(aHeader[nCntFor,2])=="C0_PRODUTO"
		nPosProduto := nCntFor
	Case AllTrim(aHeader[nCntFor,2])=="C0_LOCAL"
		nPosLocal 	:= nCntFor
	Case AllTrim(aHeader[nCntFor,2])=="C0_QUANT"
		nPosQuant 	:= nCntFor
	Case Alltrim(aHeader[nCntFor,2])=="C0_NUMLOTE"
		nPosLote 	:= nCntFor
	Case AllTrim(aHeader[nCntFor,2])=="C0_LOTECTL"
		nPosLoteCtl	:= nCntFor
	Case AllTrim(aHeader[nCntFor,2])=="C0_LOCALIZ"
		nPosLocaliz := nCntFor
	Case AllTrim(aHeader[nCntFor,2])=="C0_NUMSERI"
		nPosNumSeri := nCntFor
	EndCase
Next nCntFor
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se for inclusao ele verifica se o numero da reserva ja' existe. ³
//³ Se existir ele somara' 1 ate' encontrar um numero nao utilizado.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC0")
dbSetOrder(1)
MsSeek(xFilial("SC0")+cNum)
If ( lInclui430 )
	While Found()
		lShowHelp := .T.
		If ( __lSx8 )
			ConfirmSx8()
		EndIf
		cNum := GetSx8Num("SC0","C0_QUANT")
		MsSeek(xFilial("SC0")+cNum)
	EndDo
EndIf
nMaxFor := Len(aCols)
For nCntFor := 1 To nMaxFor
	If ( aCols[nCntFor][Len(aCols[nCntFor])] )  // Deletada?
		If !lInclui430
			If nCntFor <= Len(aRecno)   	
				a430Reserv({3,cTipoRes,cDocRes,cSolicit,cFilRes},;
					cNum,;
					aCols[nCntFor,nPosProduto],;
					aCols[nCntFor,nPosLocal],;
					aCols[nCntFor,nPosQuant],;
					{ IIF(nPosLote == 0,"", aCols[nCntFor,nPosLote]),;
					IIF(nPosLoteCtl == 0,"", aCols[nCntFor,nPosLoteCtl]),;
					IIF(lPyme .Or. nPosLocaliz == 0,"",aCols[nCntFor,nPosLocaliz]),;
					IIF(nPosNumSer == 0,"", aCols[nCntFor,nPosNumSer])},aHeader,aCols[nCntFor])
			Endif	
		EndIf
	Else
		If ( !Empty(aCols[nCntFor][nPosProduto]) )

			If !Empty( nPosQtElim )
				nQuantElim := aCols[ nCntFor, nPosQtElim ]
			Else
				nQuantElim := NIL 	
			EndIf		

			a430Reserv({If(lInclui430,1,2),cTipoRes,cDocRes,cSolicit,cFilRes},;
				cNum,;
				aCols[nCntFor,nPosProduto],;
				aCols[nCntFor,nPosLocal],;
				aCols[nCntFor,nPosQuant],;
				{ IIF(nPosLote == 0,"",	aCols[nCntFor,nPosLote]),;
				IIF(nPosLoteCtl == 0,"", aCols[nCntFor,nPosLoteCtl]),;
				IIF(lPyme .Or. nPosLocaliz == 0,"", aCols[nCntFor,nPosLocaliz]),;
				IIF(nPosNumSer == 0,"", aCols[nCntFor,nPosNumSer])},aHeader,aCols[nCntFor],nQuantElim)
		EndIf
	EndIf
	IF lMsc0430A
		ExecBlock("MSC0430A",.f.,.f.)
	Endif
Next nX
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ verifica se deve mostrar o help por mudanca do numero    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lShowHelp
	Help(" ",1,"A430MUDOU")
EndIf
If ( __lSx8 )
	ConfirmSx8()
EndIf
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A430LOTQTD³ Autor ³ Luiz Claudio Barbosa  ³ Data ³ 12.05.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz verifica‡„o se for digitado o Nro. do Lote verifica  a ³±±
±±³          ³quantidade, senao apresenta um Choice para a escolha do Lote³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430LOTQTD()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A430LOTQTD()
Local aArea 	:= { Alias() , IndexOrd() , Recno() }
Local cProduto	:= ""
Local cLocal	:= ""
Local cLoteCtl  := ""
Local cNumLote	:= ""
Local nQuant	:= 0
Local nY		:= 0
Local nQuantOri := 0
Local lEmpPrev  := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)

Local oMdlAct   := FwModelActive()
Local lOpc		:= oMdlAct:GetOperation() <> MODEL_OPERATION_INSERT
Local cNumRes   := oMdlAct:GetValue( 'MASTER', 'C0_NUM' )

cProduto := oMdlAct:GetValue( 'SC0GRID', 'C0_PRODUTO' )

If lOpc
	dbSelectArea("SC0")
	dbSetOrder(1)
	MsSeek(xFilial("SC0")+cNumRes+cProduto+cLocal)
	nQuantOri := C0_QUANT
EndIf


If ( Rastro(cProduto) )
	
	cNumLote := oMdlAct:GetValue( 'SC0GRID', 'C0_NUMLOTE' )
	cLoteCtl := oMdlAct:GetValue( 'SC0GRID', 'C0_LOTECTL' )
	cLocal   := oMdlAct:GetValue( 'SC0GRID', 'C0_LOCAL' )
	
	nQuant:=&(Readvar())
	If Rastro( cProduto, "S" )
		If !Empty(cNumLote)
			dbSelectArea("SB8")
			dbSetOrder(2)
			MsSeek(xFilial()+cNumLote)
			While xFilial("SB8") + cNumLote == B8_FILIAL + B8_NUMLOTE
				If cProduto == B8_PRODUTO
					Exit
				EndIf
				dbSkip()
			EndDo
			dbSetOrder(1)
			If ( nQuant > (SB8SALDO(,,,,,lEmpPrev,,,.T.)-((SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)-nQuantOri)+AvalQtdPre("SB8",1))) .Or. nQuant == 0 )				
				a430f4(,,,Alias())
			EndIf
		EndIf
	Else
		If !Empty( cLoteCtl )
			If nQuant > (SaldoLote( cProduto, cLocal, cLoteCtl ) + nQuantOri)
				a430f4(,,,aArea[1])
			EndIf
		EndIf
	EndIf
EndIf
dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
MsGoto(aArea[3])
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430IniCpo³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 17/05/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Zera campos se mudado o produto                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION A430IniCpo(oMdlSC0,cField,cValue,nLinGrd,cOldValue)
LOCAL cNewCod, cProduto
Local cAlias	:= Alias()
Local nX
Local lRetorno	:= .T.
Local aAuxRet     := {}
Local lOpc := oMdlSC0:GetOperation() == MODEL_OPERATION_INSERT

If oMdlSC0:GetModel():GetId()=='MATA430'
	aAuxRet   := oMdlSC0:GetOldData()
		
	//--------------------------------------------
	// quando for MVC inicializa as variáveis em modo Private
	// para não ter que alterar a referência nas funções dependentes/encadeadas 
	aHeader   := aClone(aAuxRet[1])
	aCols     := aClone(aAuxRet[2])
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Funcao utilizada para verificar a ultima versao dos fontes      ³
//³ SIGACUS.PRW, SIGACUSA.PRX e SIGACUSB.PRX, aplicados no rpo do   |
//| cliente, assim verificando a necessidade de uma atualizacao     |
//| nestes fontes. NAO REMOVER !!!							        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF !(FindFunction("SIGACUS_V") .and. SIGACUS_V() >= 20050512)
    Final("Atualizar SIGACUS.PRW !!!")
Endif
IF !(FindFunction("SIGACUSA_V") .and. SIGACUSA_V() >= 20050512)
    Final("Atualizar SIGACUSA.PRX !!!")
Endif
IF !(FindFunction("SIGACUSB_V") .and. SIGACUSB_V() >= 20050512)
    Final("Atualizar SIGACUSB.PRX !!!")
Endif

cNewCod	:= &(ReadVar())

If ValType(cField) <> "U" .And. ValType(cOldValue) <> "U" .And. cField == "C0_PRODUTO"
	cProduto := cOldValue
Else
	dbSelectArea("SC0")
	For nx:= 1 To Len(aHeader)
		If Trim(aHeader[nx][2]) == "C0_PRODUTO"
			cProduto := aCols[n][nx]
		ElseIf Trim(aHeader[nx][2]) == "C0_LOCAL"
			nPosLoja := nx
		EndIf
	Next nx
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o produto foi alterado                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cProduto <> cNewCod

	If lOpc .Or. n > nLinhasAtu

		oMdlSC0:LoadValue('C0_NUMLOTE', CriaVar("C0_NUMLOTE") )
		oMdlSC0:LoadValue('C0_QUANT'  , CriaVar("C0_QUANT") )
		oMdlSC0:LoadValue('C0_QTDORIG', CriaVar("C0_QTDORIG") )
		oMdlSC0:LoadValue('C0_LOTECTL', CriaVar("C0_LOTECTL") )
		oMdlSC0:LoadValue('C0_LOCALIZ', CriaVar("C0_LOCALIZ") )
		oMdlSC0:LoadValue('C0_NUMSERI', CriaVar("C0_NUMSERI") )

	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ So permite alterar o produto caso seja inclusao ou uma nova linha na alteracao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Help( " ", 1, "A430PROD" )	 // "Nao e permitido alterar o produto de um item previamente cadastrado !"

		lRetorno := .F.

	EndIf 	

EndIf 		

If lRetorno
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o local padrao                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB1")
	dbSetOrder(1)
	If MsSeek(xFilial()+cNewCod)
		oMdlSC0:LoadValue('C0_LOCAL', RetFldProd(SB1->B1_COD,"B1_LOCPAD") )
	EndIf
EndIf 	

dbSelectArea(cAlias)

Return( lRetorno )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A430VldLot³ Autor ³ Sergio Silveira       ³ Data ³ 19.11.97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida os lotes digitados pelo usuario. ( Lote e SubLote ) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := A430VldLot()                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 -> Valida ( .T. ou .F. )                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function A430VldLot()

LOCAL cVar 		:= ReadVar()
LOCAL cProduto
LOCAL cLocal
LOCAL cLoteCtl
LOCAL cNumLote
LOCAL nPosQuant
LOCAL nPosNumSer
LOCAL nDtValid  := 0    
LOCAL nX        := 0 
LOCAL lRet      := .T.
LOCAL lEmpPrev  := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)

Local oModel    := FwModelActive()
Local oModelGrid := oModel:GetModel('SC0GRID')
Local aAuxRet   := {}

If oModel:GetId()=='MATA430'
	aAuxRet   := oModel:GetModel('SC0GRID'):GetOldData()
		
	//--------------------------------------------
	// quando for MVC inicializa as variáveis em modo Private
	// para não ter que alterar a referência nas funções dependentes/encadeadas 
	aHeader   := aClone(aAuxRet[1])
	aCols     := aClone(aAuxRet[2])
EndIf

cProduto   := oModelGrid:GetValue('C0_PRODUTO')
cLocal     := oModelGrid:GetValue('C0_LOCAL')
nPosLotCt  := aScan( aHeader, { |x| AllTrim(x[2]) == "C0_LOTECTL" } )
nPosLote   := aScan( aHeader, { |x| AllTrim(x[2]) == "C0_NUMLOTE" } )
nQuant     := oModelGrid:GetValue('C0_QUANT')
nPosQuant  := aScan( aHeader, { |x| AllTrim(x[2]) == "C0_QUANT" } )
nPosNumSer := aScan( aHeader, { |x| AllTrim(x[2]) == "C0_NUMSERI" } )
nDtValid   := aScan( aHeader, { |x| AllTrim(x[2]) == "C0_VALIDA" } )

If Rastro( cProduto )
	dbSelectArea( "SB8" )
	If ( "C0_LOTECTL" $ cVar )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se digitou lote  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cLoteCtl := &( ReadVar() )
		cNumLote := aCols[ n, nPosLote ]
		If Rastro( cProduto, "S" )
			dbSetOrder( 3 )
			If !MsSeek( xFilial("SB8")+cProduto+cLocal+cLoteCtl+cNumLote )
				lRet := .F.
				Help( " ", 1, "A240LOTERR" )
			EndIf
		Else
			dbSetOrder( 3 )
			If MsSeek( xFilial("SB8")+cProduto+cLocal+cLoteCtl )
				aCols[ n, nPosLote ] := CriaVar( "C0_NUMLOTE" )
				M->C0_NUMLOTE        := CriaVar( "C0_NUMLOTE" )
				aCols[ n, nPosNumSer]:= CriaVar( "C0_NUMSERI" )
			Else
				lRet := .F.
				Help( " ", 1, "A240LOTERR" )
			EndIf
		EndIf
	ElseIf ( "C0_NUMLOTE" $ cVar )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se digitou SubLote ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cLoteCtl := aCols[ n, nPosLote ]
		cNumLote := &( ReadVar() )
		If Rastro( cProduto, "S" )
			dbSetOrder( 2 )
			If MsSeek( xFilial("SB8") + cNumLote )
				If (! cProduto == SB8->B8_PRODUTO )
					Help(" ",1,"A240LOTERR")
					lRet := .F.
				Else
					lRet := .T.
					aCols[ n, nPosLotCt ] := SB8->B8_LOTECTL
				EndIf
			Else
				lRet := .F.
				Help( " ", 1, "A240LOTERR" )
			EndIf
		Else
			aCols[ n, nPosLote ] := CriaVar( "C0_NUMLOTE" )
			M->C0_NUMLOTE        := CriaVar( "C0_NUMLOTE" )
			aCols[ n, nPosNumSer]:= CriaVar( "C0_NUMSERI" )
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe saldo suficiente nos lotes ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet
		If Rastro( cProduto, "S" )
			dbSetOrder( 2 )
			MsSeek( xFilial("SB8") + cNumLote )
			lRet := .T.
			If ( nQuant > SB8SALDO(,,,,,lEmpPrev,,,.T.) - (SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1)))
				aCols[ n, nPosQuant ] := SB8SALDO(,,,,,lEmpPrev,,,.T.) - (SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1))
			EndIf
		Else
			If nQuant > SaldoLote( cProduto, cLocal, cLoteCtl )
				aCols[ n, nPosQuant ] := SaldoLote( cProduto, cLocal, cLoteCtl )
			EndIf
		EndIf
		If ( aCols[n,nDtValid] > SB8->B8_DTVALID )
			aCols[n,nDtValid] := SB8->B8_DTVALID
			M->C0_VALIDA      := SB8->B8_DTVALID
		EndIf
	EndIf
Else
	If ( "C0_NUMLOTE" $ ReadVar() )
		aCols[ n, nPosLote   ] := CriaVar( "C0_NUMLOTE" )
		M->C0_NUMLOTE          := CriaVar( "C0_NUMLOTE" )
		aCols[ n, nPosNumSer]  := CriaVar( "C0_NUMSERI" )
	ElseIf ( "C0_LOTECTL" $ ReadVar() )
		aCols[ n, nPosLotCt ]  := CriaVar( "C0_LOTECTL" )
		M->C0_LOTECTL          := CriaVar( "C0_LOTECTL" )
		aCols[ n, nPosNumSer]:= CriaVar( "C0_NUMSERI" )
	EndIf
EndIf

//-----------------------------------------------
//  Mantém o processamento da rotina sem o MVC 
// e quando for MVC assume as alterações do aCols Clone para o Grid
oModel:GetModel('SC0GRID'):LoadValue( 'C0_NUMLOTE', aCols[ n, nPosLote] )
oModel:GetModel('SC0GRID'):LoadValue( 'C0_NUMSERI', aCols[ n, nPosNumSer] )
oModel:GetModel('SC0GRID'):LoadValue( 'C0_LOTECTL', aCols[ n, nPosLotCt] )
oModel:GetModel('SC0GRID'):LoadValue( 'C0_VALIDA' , aCols[ n, nDtValid] )

Return( lRet )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430NumSer³ Autor ³Sergio Silveira        ³ Data ³ 24/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa que verifica o numero de serie digitado           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A430NumSer

LOCAL cConteudo := &( ReadVar() )
LOCAL cAlias  	:= Alias(), nRecno := Recno(), nOrdem := IndexOrd()
LOCAL lRet    	:= .T.
LOCAL cProduto, cLocal, cLote, cLoteDigi, nQuant, cLocaliza
Local nX

Local oModel      := FwModelActive()
Local oModelGrid  := oModel:GetModel('SC0GRID')
Local aAuxRet     := {}

If oModel:GetId()=='MATA430'
	aAuxRet   := oModel:GetModel('SC0GRID'):GetOldData()
		
	//--------------------------------------------
	// quando for MVC inicializa as variáveis em modo Private
	// para não ter que alterar a referência nas funções dependentes/encadeadas 
	aHeader   := aClone(aAuxRet[1])
	aCols     := aClone(aAuxRet[2])
EndIf

cProduto  := oModelGrid:GetValue('C0_PRODUTO')
cLocal    := oModelGrid:GetValue('C0_LOCAL')
nQuant    := oModelGrid:GetValue('C0_QUANT')
cLote     := oModelGrid:GetValue('C0_NUMLOTE')
cLocaliza := oModelGrid:GetValue('C0_LOCALIZ')
cLoteDigi := oModelGrid:GetValue('C0_LOTECTL')

If !Empty(cConteudo) .And. Localiza(cProduto) .And. nQuant > 0
	If SaldoSBF(cLocal,cLocaliza,cProduto,cConteudo,cLoteDigi,cLote) < nQuant
		Help(" ",1,"SALDOLOCLZ")
		lRet:=.F.
	EndIf
EndIf
dbSelectArea(cAlias)
dbSetOrder(nOrdem)
MsGoto(nRecno)
Return lRet


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ A430ChF4 ³ Autor ³ Sergio Silveira       ³ Data ³ 26/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Faz a chamada do F4 correspondente ao campo                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430ChF4( a, b, c, ExpC1, ExpC2 )                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ a, b, c -> Parametros default do Set Key                   ³±±
±±³          ³ ExpC1 -> Alias do arquivo, ExpC2 -> Programa de chamada    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/

Static Function A430ChF4( a, b, c, cAlias2 )

Local nPosLocaliz := 0
Local nPosNumSeri := 0

If "C0_LOTECTL"$ReadVar() .Or. "C0_NUMLOTE"$ReadVar() .Or. "C0_QUANT" $ ;
		ReadVar()
	A430F4( a, b, c, cAlias2 )
ElseIf "C0_LOCALIZ" $ ReadVar()
	oModel := FwModelActive()
	If oModel:GetId()=='MATA430'
		aAuxRet   := oModel:GetModel('SC0GRID'):GetOldData()
			
		//--------------------------------------------
		// quando for MVC inicializa as variáveis em modo Private
		// para não ter que alterar a referência nas funções dependentes/encadeadas 
		aHeader   := aClone(aAuxRet[1])
		aCols     := aClone(aAuxRet[2])
		n := oModel:GetModel('SC0GRID'):GetLine()

		F4Localiz( a, b, c, "A430" )
			
		nPosLocaliz	:= AScan( aHeader, { |x| AllTrim(x[2]) == "C0_LOCALIZ" } )
		If nPosLocaliz > 0 
			oModel:GetModel('SC0GRID'):SetValue('C0_LOCALIZ', aCols[n,nPosLocaliz] )
		EndIf
		nPosNumSeri	:= AScan( aHeader, { |x| AllTrim(x[2]) == "C0_NUMSERI" } ) 
		If nPosNumSeri > 0
			oModel:GetModel('SC0GRID'):SetValue('C0_NUMSERI', aCols[n,nPosNumSeri] )
		EndIf
		__lKeyF4Loc := .T.
	EndIf
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³a430Vld   ³ Autor ³Eduardo Riera          ³ Data ³ 10.08.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida a Digitacao do Lote e Localizacao                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function A430Vld()

Local lRetorno 	:= .F.
Local oMdlAct		:= FwModelActive()
Local nPosQtd		:= 0
Local nPosQtdOri	:= 0 
Local nQtd			:= 0
Local nQtdOri		:= 0
Local lAltera430	:= oMdlAct:GetOperation() == MODEL_OPERATION_UPDATE
Local lInclui430    := oMdlAct:GetOperation() == MODEL_OPERATION_INSERT

If lInclui430
	lRetorno := .T.	
ElseIf lAltera430

nQtd		:= oMdlAct:GetValue('SC0GRID','C0_QUANT')		//FwFldGet('C0_QUANT')  
nQtdOri	:= oMdlAct:GetValue('SC0GRID','C0_QTDORIG')	//FwFldGet('C0_QTDORIG')	

If (nQtd == nQtdOri .Or. nQtdOri ==0 )
	lRetorno := .T.
EndIf
	
EndIf

Return(lRetorno)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A430Reserv³ Autor ³Eduardo Riera          ³ Data ³11.08.98  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Reserva um determinado Produto                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 := Indica se o Produto foi reservado                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aReserva: [Operacao : 1 Inclui,2 Altera,3 Exclui]          ³±±
±±³          ³           [Tipo da Reserva]                                ³±±
±±³          ³           [Documento que originou a Reserva]               ³±±
±±³          ³           [Solicitante]                                    ³±±
±±³          ³           [Filial da Reserva]                              ³±±
±±³          ³           [Observacao]                                     ³±±
±±³          ³ cNumero : Numero da Reserva                                ³±±
±±³          ³ cProduto: Produto da Reserva                               ³±±
±±³          ³ cLocal  : Local                                            ³±±
±±³          ³ nQuant  : Quantidade a ser reservada                       ³±±
±±³          ³ aLote   : [Numero do Lote]                                 ³±±
±±³          ³           [Lote de Controle]                               ³±±
±±³          ³           [Localizacao]                                    ³±±
±±³          ³           [Numero de Serie]                                ³±±
±±³          ³ cTipoRes: Tipo da Reserva                                  ³±±
±±³          ³ cDocRes : Documento que originou a reserva                 ³±±
±±³          ³ cSolicit: Solicitante                                      ³±±
±±³          ³ cFilRes : Filial de Reserva                                ³±±
±±³          ³ aheader : Qdo for MATA430                                  ³±±
±±³          ³ aCols   : Qdo for MATA430 -> Item do acols Ex. aCols[1]    ³±± 
±±³          ³ nQuantElim :				                                  ³±±
±±³          ³ lLoja   : Se Foi chamado a apartir do loja				  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function a430Reserv(aOperacao,cNumero,cProduto,cLocal,nQuant,aLote,aHeader,aCols,nQuantElim,lLoja)

Local aArea 	:= GetArea()
Local nCntFor	:= 0
Local cNumLote  := aLote[1]
Local cLoteCtl  := aLote[2]
Local cLocaliz  := aLote[3]
Local cNumSer   := aLote[4]
Local nOpcx		:= aOperacao[1]
Local cTipoRes	:= aOperacao[2]
Local cDocRes	:= aOperacao[3]
Local cSolicit	:= aOperacao[4]
Local cFilRes	:= aOperacao[5]
Local lRetorna  := .F.
Local lNovo     := .F.
Local aSldLote  := {}
Local nQtdLote  := 0
Local cObs		:= If(Len(aOperacao)>=6,aOperacao[6]," ")
Local cMvLjGerSC:= cValToChar( SuperGetMv("MV_LJGERSC",,1) )
Local lTpSldRes := (!lLoja .And. nOpcx == 2 .And. SuperGetMV("MV_TPSALDO",.F.,"Q") == "S" .And. FunName() == "MATA430")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para e-Commerce      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lECommerce := SuperGetMV("MV_LJECOMM",,.F.) .And. LJ862ECAuto()

Default nQuantElim := 0
Default lLoja	:= .F.    //Indica se foi chamado do Loja 
                                    
	BEGIN TRANSACTION

		If Empty(cNumero) .And. (nOpcx <> 3)
			cNumero := GetSx8Num("SC0","C0_NUM")
			ConfirmSx8()
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se a reserva ja existe e estorna valores anteriores            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SC0")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC0")+cNumero+cProduto+cLocal) )
			GravaEmp(SC0->C0_PRODUTO,; //-- 1
				SC0->C0_LOCAL,; //-- 2
				SC0->C0_QUANT,; //-- 3
				NIL,; //-- 4
				SC0->C0_LOTECTL,; //-- 5
				SC0->C0_NUMLOTE,; //-- 6
				SC0->C0_LOCALIZ,; //-- 7
				SC0->C0_NUMSERI,; //-- 8
				Nil,; //-- 9
				Nil,; //-- 10
				SC0->C0_NUM,; //-- 11
				Nil,; //-- 12
				"SC0",; //-- 13
				Nil,; //-- 14
				Nil,; //-- 15
				Nil,; //-- 16
				.T.,; //-- 17
				.F.,; //-- 18
				.T.,; //-- 19
				.F.,; //-- 20
				Nil,; //-- 21
				If(!IntDL(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza( cProduto ),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI)))  //-- 22
		Else
			lNovo := .T.
		EndIf
		If ( nOpcx != 3 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se o Produto pode ser Reservado                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(xFilial("SB2")+cProduto+cLocal)
		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se usa reserva sem estoque                   ³
			//³ Para eCommerce deve gerar SC se nao houver estoque    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lLoja .AND. (cMvLjGerSC $ "2|3|4" .OR. lECommerce)
				If (!RecLock("SB2"))
					lRetorna := .F.
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Permite reservar produtos sem estoque  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
					lRetorna := .T.
				EndIf
			Else 	
				If ( !RecLock("SB2") .Or. (!lTpSldRes .And. SaldoMov() < nQuant) )
					lRetorna := .F.
				Else
					lRetorna := .T.
				EndIf
			Endif
			
			If lRetorna

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica os lotes                                                       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aSldLote := GravaEmp(cProduto,; //-- 1
					cLocal,; //-- 2
					nQuant,; //-- 3
					NIL,; //-- 4
					aLote[2],; //-- 5
					aLote[1],; //-- 6
					aLote[3],; //-- 7
					aLote[4],; //-- 8
					Nil,; //-- 9
					Nil,; //-- 10
					cNumero,; //-- 11
					Nil,; //-- 12
					"SC0",; //-- 13
					Nil,; //-- 14
					Nil,; //-- 15
					Nil,; //-- 16
					.F.,; //-- 17
					.F.,; //-- 18
					.T.,; //-- 19
					.F.,; //-- 20
					Nil,; //-- 21
					If(!IntDL(cProduto),!Empty(aLote[2]+aLote[1]).Or.Localiza(cProduto),!Empty(aLote[2]+aLote[1]+aLote[3]+aLote[4]))) //-- 22

				For nCntFor := 1 To Len(aSldLote)
					nQtdLote += aSldLote[nCntFor][5]
				Next nCntFor

				If nQtdLote <> nQuant
					If lLOJA .AND. cMvLjGerSC $ "2|3|4"
						lRetorna := .T.
					ElseIf Rastro(cProduto) .OR. Localiza(cProduto)
						lRetorna := .F.						
					EndIf
				EndIf
				If lRetorna
					
					If nModulo == 12 .AND. Len(aSldLote) > 0 .AND. (Empty(cNumLote) .OR. Empty(cLoteCtl) .OR. Empty(cLocaliz) .OR. Empty(cNumSer))
						cLoteCtl := aSldLote[1][1]
						cNumLote := aSldLote[1][2] 
						cLocaliz := aSldLote[1][3]
						cNumSer  := aSldLote[1][4]
					Endif
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza dados padroes                                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !lNovo
						RecLock("SC0",.F.)
					Else
						RecLock("SC0",.T.)
					EndIf
					SC0->C0_FILIAL	:= xFilial("SC0")
					SC0->C0_NUM    := cNumero
					SC0->C0_PRODUTO:= cProduto
					SC0->C0_LOCAL  := cLocal
					SC0->C0_QUANT	:= nQuant
					SC0->C0_NUMLOTE:= cNumLote
					SC0->C0_LOTECTL:= cLoteCtl
					SC0->C0_LOCALIZ:= cLocaliz
					SC0->C0_NUMSERI:= cNumSer
					SC0->C0_TIPO   := cTipoRes
					SC0->C0_DOCRES := cDocRes
					SC0->C0_SOLICIT:= cSolicit
					SC0->C0_FILRES := cFilRes
					SC0->C0_EMISSAO:= dDataBase
					If Upper(FunName()) $ "MATA410|MATA440|AGRA900|AGRA870A|"
						SC0->C0_VALIDA := dDatabase + GetMv("MV_PZRESER")
					Else 
						SC0->C0_VALIDA := dDatabase
					EndIf
					SC0->C0_QTDORIG:= If(SC0->C0_QTDORIG==0,SC0->C0_QUANT,SC0->C0_QTDORIG)
					If SC0->(FieldPos("C0_OBS")) > 0
						SC0->C0_OBS := cObs
					Endif

					If ValType( nQuantElim ) == "N" .And. !Empty( SC0->( FieldPos( "C0_QTDELIM" ) ) )
						SC0->C0_QTDELIM := nQuantElim
					EndIf 			

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza dados do corpo                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( !Empty(aHeader) )
						For nCntFor := 1 To Len(aHeader)
							If aHeader[nCntFor,10] != "V" .And. aHeader[nCntFor,2] <> "C0_NUM"
								FieldPut(FieldPos(aHeader[nCntFor,2]),aCols[nCntFor])
							Endif
						Next nCntFor
					EndIf
				EndIf		
			EndIf

			Do Case
				Case !lNovo .And. !lRetorna
			
					GravaEmp(SC0->C0_PRODUTO,; //-- 1
						SC0->C0_LOCAL,; //-- 2
						SC0->C0_QUANT,; //-- 3
						NIL,; //-- 4
						SC0->C0_LOTECTL,; //-- 5
						SC0->C0_NUMLOTE,; //-- 6
						SC0->C0_LOCALIZ,; //-- 7
						SC0->C0_NUMSERI,; //-- 8
						Nil,; //-- 9
						Nil,; //-- 10
						SC0->C0_NUM,; //-- 11
						Nil,; //-- 12
						"SC0",; //-- 13
						Nil,; //-- 14
						Nil,; //-- 15
						Nil,; //-- 16
						.T.,; //-- 17
						.F.,; //-- 18
						.T.,; //-- 19
						.F.,; //-- 20
						Nil,; //-- 21
						If(!IntDL(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza(cProduto),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI))) //-- 22

				Case lNovo .And. !lRetorna
					aSldLote := GravaEmp(cProduto,; //-- 1
						cLocal,; //-- 2
						nQtdLote,; //-- 3
						NIL,; //-- 4
						aLote[2],; //-- 5
						aLote[1],; //-- 6
						aLote[3],; //-- 7
						aLote[4],; //-- 8
						Nil,; //-- 9
						Nil,; //-- 10
						cNumero,; //-- 11
						Nil,; //-- 12
						"SC0",; //-- 13
						Nil,; //-- 14
						Nil,; //-- 15
						Nil,; //-- 16
						.T.,; //-- 17
						.F.,; //-- 18
						.T.,; //-- 19
						.F.,; //-- 20
						Nil,;	//-- 21
						If(!IntDL(cProduto),!Empty(aLote[2]+aLote[1]).Or.Localiza(cProduto),!Empty(aLote[2]+aLote[1]+aLote[3]+aLote[4]))) //-- 22	

			EndCase
			
			If lRetorna
				SC0->(MsUnlock())
			EndIf
		Else
			lRetorna := .T.
			If SC0->( Found() )
				RecLock("SC0")
				dbDelete()
				MsUnLock()
			EndIf 	
		EndIf

		If !lRetorna
			DisarmTransaction()
		EndIF		
	
	END TRANSACTION	

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Retorna o Alias de Entrada                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea(aArea)

Return(lRetorna)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A430VlBox ³ Autor ³ Sergio Silveira       ³ Data ³24/09/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validacao do cambobox de tipo                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintexe   ³ A430VlBox(ExpC1,ExpC2,ExpA1,ExpO1,ExpO2,ExpO3,ExpL1 )      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1   : Tipo de reserva                                  ³±±
±±³          ³ ExpC2   : Documento de reserva                             ³±±
±±³          ³ ExpA1   : Array de tipos                                   ³±±
±±³          ³ ExpO1   : Objeto Get 1                                     ³±±
±±³          ³ ExpO2   : Objeto Get 2                                     ³±±
±±³          ³ ExpO3   : Objeto Get 3                                     ³±±
±±³          ³ ExpL1   : Indica se zera o numero do documento             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function A430VlBox( cTipoRes, cDocRes, aTipoRes, oGet1, oGet2, oGet3, lZera )

Local lRetorno := .T.

DEFAULT lZera  := .T.

cTipoRes := aTipoRes[oCbx:nAt]

If lZera
	cDocRes	:= CriaVar("C0_DOCRES",.F.)
EndIf	

oGet1:Hide()
oGet2:Hide()
oGet3:Hide()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Habilita o Get correspondente conforme o tipo                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Do Case
Case cTipoRes == "PD"
	oGet1:Show()
Case cTipoRes == "CL"
	oGet2:Show()
Case cTipoRes == "VD"
	oGet3:Show()
EndCase 	

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ponto de entrada para validacao especial do campo ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MT430VLD")
	lRetorno := ExecBlock("MT430VLD",.F.,.F.,{cTipoRes,cDocRes})
EndIf

Return(lRetorno)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A430ZeraQt³ Autor ³ Sergio Silveira       ³ Data ³09/09/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Zera a quantidade na rotina de alteracao                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430ZeraQt()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function A430ZeraQt()

Local nQuant   := 0
Local nQtdElim := 0
Local nQtdOrig := 0

Local oMdlGrd  := FwModelActive()

oMdlGrd  := oMdlGrd:GetModel( 'SC0GRID' )
nQuant   := oMdlGrd:GetValue( 'C0_QUANT'   )
nQtdElim := oMdlGrd:GetValue( 'C0_QTDELIM' )
nQtdOrig := oMdlGrd:GetValue( 'C0_QTDORIG' )

If Aviso( STR0045 , STR0043,;
		{ STR0046, STR0047 }, 2 ) == 1 // "Atencao" / "Deseja zerar a quantidade deste item para baixar o saldo da reserva ?"
	If nQuant == nQtdOrig
		Help( "", 1, "A430QTORI" ) // "Os campos quantidade e quantidade original estao iguais. Utilize a rotina de exclusao ou efetue a exclusao da linha."
	ElseIf Empty( nQuant )
		Help( "", 1, "A430ZERO" ) // "A quantidade ja esta zerada. Nao e possivel continuar" 
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Zera a reserva                                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		oMdlGrd:LoadValue( 'C0_QTDELIM', nQtdElim + nQuant )
		oMdlGrd:LoadValue( 'C0_QUANT' , 0 )
	EndIf
EndIf

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A430Bar   ³ Autor ³ Sergio Silveira       ³ Data ³10/09/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Mostra a EnchoiceBar na tela                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430Bar( ExpO1, ExpB2, ExpB3, ExpN4 )                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpO1 -> Objeto Dialog                                     ³±±
±±³          ³ ExpB2 -> Code block de confirmacao                         ³±±
±±³          ³ ExpB3 -> Code block de nao confirmacao                     ³±±
±±³          ³ ExpN4 -> Numero da opcao                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Mostra a EnchoiceBar na tela                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A430Bar(oDlg,bOk,bCancel,nOpc )

Local aButtons   := {}
Local aUsButtons := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Botao para eliminacao de saldo                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpc == 4
	AAdd( aButtons, { "S4WB004N", { || A430ZeraQt() }, STR0050, STR0051 } ) // "Zera saldo remanescente"
EndIf 	

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Adiciona botoes do usuario na EnchoiceBar                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock( "MA430BUT" )
	If ValType( aUsButtons := ExecBlock( "MA430BUT", .F., .F., { nOpc } ) ) == "A"
		AEval( aUsButtons, { |x| AAdd( aButtons, x ) } ) 	 	
	EndIf 	
EndIf 	

Return (EnchoiceBar(oDlg,bOK,bcancel,,aButtons))


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A430Legend³Autor  ³ Sergio Silveira       ³ Data ³09/01/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Demonstra a legenda das cores da mbrowse                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina monta uma dialog com a descricao das cores da    ³±±
±±³          ³Mbrowse.                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function A430Legend()            

Local aCores := {	{"BR_VERMELHO",STR0052 },;  //"Reserva nao baixada"
		{"BR_VERDE"   ,STR0053 },;    //"Reserva totalmente baixada"
		{"BR_AMARELO" ,STR0054},;  //"Reserva parcialmente baixada"
		{"BR_AZUL"    ,STR0055}	} //"Reserva com residuo eliminado"
Local aTmp	:= {}
Local nX	:= 0
Local aTmp1	:= {}

If ExistBlock( "M430LEG" )
	aTmp1 := {}
	aTmp := ExecBlock( "M430LEG", .F., .F., { aCores } )
	If ValType(aTmp) == "A"
		For nX := 1 to len(aTmp)
			If len(aTmp[nx]) == 2
				If ascan( aCores, {|x| Alltrim(Upper(x[1])) == Alltrim(Upper(aTmp[nX][1])) } ) == 0
					aadd( aTmp1, aClone(aTmp[nX]) )
				Endif
			Endif
		Next nX
		aTmp := {}
		For nX := 1 to len(aCores)
			If len(aCores[nx]) == 2
				aadd( aTmp1, aClone(aCores[nX]) )
			Endif
		Next nX
		aCores := aClone(aTmp1)
		aTmp1 := Nil
		aTmp := Nil
	Endif
EndIf 

BrwLegenda(cCadastro,Capital( STR0056 ), aCores) 

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430Resid ³ Autor ³ Eduardo Riera         ³ Data ³ 03/11/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de eliminação de residuos de uma reserva          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void A430Resid (ExpC1,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Numero da opcao selecionada                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A430Resid(cAlias,nReg,nOpcx)

Local aArea := GetArea()
Local cNum  := SC0->C0_NUM
local lContinua := .T.
Local lMt430Elim 	:= ExistBlock("MT430ELIM")

If a430Visual(cAlias,nReg,nOpcx) .And. MsgYesNo(STR0066,"A430Resid")
	If ExistBlock("MT430ELV")
       lContinua :=ExecBlock("MT430ELV",.F.,.F.,{cNum})
       If !ValType(lContinua) == "L"
			lContinua := .T.
       Endif
    EndIf
                
    If lContinua
		dbSelectArea("SC0")
		dbSetOrder(1)
		MsSeek(xFilial("SC0")+cNum)
		While !Eof() .And. xFilial("SC0") == SC0->C0_FILIAL .And. cNum == SC0->C0_NUM
				Begin Transaction
					If SC0->C0_QUANT <> 0 .And. SC0->C0_QUANT<>SC0->C0_QTDORIG
						a430Reserv({2,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
								SC0->C0_NUM,;
								SC0->C0_PRODUTO,;
								SC0->C0_LOCAL,;
								0,;
								{	SC0->C0_NUMLOTE,;
								SC0->C0_LOTECTL,;
								SC0->C0_LOCALIZ,;
								SC0->C0_NUMSERI},,,SC0->C0_QUANT)
					EndIf
				End Transaction

				If lMt430Elim
					ExecBlock("MT430ELIM",.F.,.F.,{SC0->C0_NUM})
				EndIf
				
			dbSelectArea("SC0")
			dbSkip()
		EndDo
	EndIf	
EndIf
RestArea(aArea)
Return(Nil)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Marco Bianchi         ³ Data ³01/09/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±³          ³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transa‡„o a ser efetuada:                        ³±±
±±³          ³		1 - Pesquisa e Posiciona em um Banco de Dados           ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function MenuDef()
     
Private aRotina := {}

aRotina := {	{ STR0007,"VIEWDEF.MATA430"	, 0 , 1,0,.F.},;		// "Pesq."
			{ STR0008,"VIEWDEF.MATA430"	, 0 , 2,0,NIL},;			// "Visualizar"
			{ STR0009,"VIEWDEF.MATA430"	, 0 , 3,0,NIL},;			// "Incluir"
			{ STR0010,"VIEWDEF.MATA430"	, 0 , 4,0,NIL},;			// "Alterar"
			{ STR0011,"VIEWDEF.MATA430"	, 0 , 5,0,NIL},;			// "Excluir"
			{ STR0012,"A430Depura"		, 0 , 5,0,NIL},;    		// "Depurar"
			{ STR0057,"A430Resid" 		, 0 , 2,0,NIL},; 			// "Elim.Residuo"	
			{ STR0056,"A430Legend"		, 0 , 2,0,.F.} }			// "Legenda"

If ExistBlock("MA430MNU")
	ExecBlock("MA430MNU",.F.,.F.)
EndIf

Return(aRotina)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³a430RecAlt³ Autor ³ Marco Bianchi         ³ Data ³ 11/12/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Preenche array com numero do registro utiulizado na        ³±±
±±³          ³ confirmacao da alteracao.                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ a430RecAlt()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function a430RecAlt(aRecNo)
           
aadd(aRecno,Recno())

Return(.T.)

//-------------------------------------------------------------------
/*/{Protheus.doc} Modeldef
Cria o modelo de dados para uso na view

@since 29/08/2012
@version P11
@return    oModel   Objeto com o modelo de dados da tabela SC0 (Modelo 2)
/*/
//-------------------------------------------------------------------
Static Function Modeldef()

Local oModel   := Nil	// Modelo com a estrutura dos campos, validações, gatilhos e consultas

Local aAuxTrg  := {}	// variável auxiliar na construção de gatilhos
Local oStruCab := FWFormStruct( 1, 'SC0', {|cCpo| CompStru(cCpo) .Or. Alltrim(cCpo)$ "C0_NUM|C0_FILIAL|" },.F. )	// Estrutura para compor o cabeçalho
Local oStruSC0 := FWFormStruct( 1, 'SC0', {|cCpo| !CompStru(cCpo)},.F.)  // estrutura para compor o grid

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Adiciona campo de legenda na estrutura da Evolucao da Venda. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
oStruCab:AddField(	AllTrim(STR0064)								,;  	// [01] C Titulo do campo
						AllTrim(STR0065)							,;   	// [02] C ToolTip do campo 
		     			"C0_DESCTP" 								,;    	// [03] C identificador (ID) do Field
		         		"C" 										,;    	// [04] C Tipo do campo
		            	20 											,;    	// [05] N Tamanho do campo
		              	0 											,;    	// [06] N Decimal do campo
		                Nil 										,;    	// [07] B Code-block de validação do campo
		                Nil											,;     	// [08] B Code-block de validação When do campo
		                Nil 										,;    	// [09] A Lista de valores permitido do campo
		                Nil 										,;  	// [10] L Indica se o campo tem preenchimento obrigatório
		                {||A430DescTp(oModel:GetValue('MASTER', 'C0_TIPO'))} ,;	// [11] B Code-block de inicializacao do campo
		                Nil 										,;  	// [12] L Indica se trata de um campo chave
		                Nil 										,;     	// [13] L Indica se o campo pode receber valor em uma operação de update.
		                .T. )              									// [14] L Indica se o campo é virtual
	 
oModel := MPFormModel():New('MATA430',/*bPreValidacao*/,{|oModel| A430TudOk(oModel)},{|oModel| A430GrvMVC(oModel)},/*bCancel*/)

aAuxTrg := FwStruTrigger(	'C0_TIPO' 		,;         // domínio//
							'C0_DESCTP' 	,;         // contra domínio
							'A430DescTp(FwFldGet("C0_TIPO"))'	)  // regra
oStruCab:AddTrigger( aAuxTrg[1], aAuxTrg[2], aAuxTrg[3], aAuxTrg[4] )

aAuxTrg := FwStruTrigger(	'C0_TIPO' 		,;         // domínio
							'C0_DOCRES' 	,;         // contra domínio
							'A430TrgTp( FwFldGet("C0_TIPO"), FwFldGet("C0_DOCRES") )'	)  // regra
oStruCab:AddTrigger( aAuxTrg[1], aAuxTrg[2], aAuxTrg[3], aAuxTrg[4] )

//----------------------------------------------------
//  Ajustes no modelo do cabaçalho para comportamento
// idêntico ao anterior na rotina
oStruCab:SetProperty( 'C0_TIPO'   , MODEL_FIELD_INIT	, FwBuildFeature( STRUCT_FEATURE_INIPAD	,"'VD'" ) )
oStruCab:SetProperty( 'C0_DOCRES' , MODEL_FIELD_OBRIGAT	,.F. )
oStruCab:SetProperty( 'C0_DOCRES' , MODEL_FIELD_WHEN	,FwBuildFeature(STRUCT_FEATURE_WHEN," FwFldGet('C0_TIPO') $ 'PD|VD|CL' "))
oStruCab:SetProperty( 'C0_FILRES' , MODEL_FIELD_VALID	,FwBuildFeature(STRUCT_FEATURE_VALID," FwFilExist(cEmpAnt,FwFldGet('C0_FILRES')) "))

//---------------------------------------------------------
//  Ajutes no modelo do grid
oStruSC0:SetProperty( 'C0_FILIAL' , MODEL_FIELD_INIT   	, FwBuildFeature( STRUCT_FEATURE_INIPAD,"xFilial('SC0')" ) ) 
oStruSC0:SetProperty( 'C0_NUM'    , MODEL_FIELD_OBRIGAT	, .F. )
oStruSC0:SetProperty( 'C0_NUM'    , MODEL_FIELD_INIT   	, FwBuildFeature( STRUCT_FEATURE_INIPAD	,"Space(TamSX3('C0_NUM')[1])" ) )
oStruSC0:SetProperty( 'C0_NUM'    , MODEL_FIELD_WHEN   	, FwBuildFeature( STRUCT_FEATURE_WHEN	,".F."))
oStruSC0:SetProperty( 'C0_QTDORIG', MODEL_FIELD_OBRIGAT	, .F. )
oStruSC0:SetProperty( 'C0_QTDELIM', MODEL_FIELD_OBRIGAT	, .F. )
oStruSC0:SetProperty( 'C0_NUMSERI', MODEL_FIELD_OBRIGAT	, .F. )
oStruSC0:SetProperty( 'C0_QUANT'  , MODEL_FIELD_OBRIGAT	, .F. )

oStruSC0:SetProperty( 'C0_PRODUTO', MODEL_FIELD_VALID, A430BlcVld('SC0','C0_PRODUTO','Vazio().Or.ExistCpo("SB1") .And. A430Inicpo(a,b,c,d,e)',.F.,.F.) )
//A função de validação do endereço será executada através da função MT430LocAct() e não mais pelo X3_VALID.
oStruSC0:SetProperty( 'C0_LOCALIZ', MODEL_FIELD_VALID, A430BlcVld('SC0','C0_LOCALIZ','.T.',.F.,.T.) )

aAuxTrg := FwStruTrigger(	'C0_QUANT' 	,;         // domínio
						'C0_QTDORIG' 	,;         // contra domínio
						'FwFldGet("C0_QUANT")'	)  // regra
oStruSC0:AddTrigger( aAuxTrg[1], aAuxTrg[2], aAuxTrg[3], aAuxTrg[4] )

oModel:AddFields( 'MASTER', , oStruCab )

oModel:AddGrid( 'SC0GRID', 'MASTER', oStruSC0,{|oMdlGrd,nLinha,cAction,cField,xValue,xOldValue| A430LPre(oMdlGrd,nLinha,cAction,cField,xValue,xOldValue)} , {|oMdlGrd| A430LinOk( oMdlGrd ) }, , , {|oMdl| SelecSC0( oMdl ) } )

oModel:SetRelation( 'SC0GRID', { { 'C0_FILIAL', 'C0_FILIAL'}, {'C0_NUM', 'C0_NUM' } }, SC0->( IndexKey( 1 ) ) )
oModel:SetPrimaryKey( { 'C0_FILIAL', 'C0_NUM', 'C0_PRODUTO', 'C0_LOCAL' } )
oModel:GetModel( 'SC0GRID' ):SetUniqueLine( { 'C0_FILIAL', 'C0_NUM', 'C0_PRODUTO', 'C0_LOCAL' } )

oModel:SetDescription( STR0013 ) // "Controle de Reservas"
oModel:GetModel( 'MASTER' ):SetDescription( STR0013 ) // "Controle de Reservas"
oModel:GetModel( 'SC0GRID' ):SetDescription( STR0013 ) // "Controle de Reservas"

oModel:GetModel('SC0GRID'):SetUseOldGrid()

//------------------------------------------------------------
//  Para uso do MVC como rotina automática é preciso alterar
// a identificação do modo da rotina, para isso a indicação
// logo após a construção do modelo
oModel:SetActivate( {|oModel| InitModel(oModel), A430IniVar()} )

Return oModel

//-------------------------------------------------------------------
/*/{Protheus.doc} Viewdef
Cria a interface para uso pela rotina

@since 29/08/2012
@version P11
@return    oView   Objeto com o modelo e interface
/*/
//-------------------------------------------------------------------
Static Function Viewdef()

Local oView		:= Nil  // objeto de interface do cadastro

Local oStruCab	 := FWFormStruct( 2, 'SC0', {|cCpo| CompStru(cCpo) .Or. Alltrim(cCpo) == "C0_NUM" },.F.)  // Estrutura dos dados para a interface de cabeçalho
Local oStruSC0	 := FWFormStruct( 2, 'SC0', {|cCpo| !CompStru(cCpo)} )  // estrutura dos dados para a interface do grid

Local oMdlView	 := FwLoadModel( 'MATA430')  // Modelo de dados para uso pela view

// Ajustes visualização do cabaçalho para comportamento
// idêntico ao anterior na rotina
oStruCab:SetProperty("C0_TIPO",MVC_VIEW_COMBOBOX,{"VD","CL","PD","LB","NF","LJ"})

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Adiciona campo de legenda na estrutura da Evolucao da Venda. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
oStruCab:AddField(	"C0_DESCTP" 									,;	// [01] C Nome do Campo
						"04" 										,; 	// [02] C Ordem
						STR0064										,; 	// [03] C Titulo do campo
	     				STR0065										,; 	// [04] C Descrição do campo 
	         			{}											,; 	// [05] A Array com Help
	            		"C" 										,; 	// [06] C Tipo do campo
	            		"@!" 										,; 	// [07] C Picture
	              		Nil 										,; 	// [08] B Bloco de Picture Var
	                	"" 											,; 	// [09] C Consulta F3
	                 	.F. 										,;	// [10] L Indica se o campo é evitável
	                  	Nil 										,; 	// [11] C Pasta do campo
	                   	Nil 										,;	// [12] C Agrupamento do campo
	                    Nil 										,; 	// [13] A Lista de valores permitido do campo (Combo)
	                    Nil 										,;	// [14] N Tamanho Maximo da maior opção do combo
	                    Nil 										,;	// [15] C Inicializador de Browse
	                    .T. 										,;	// [16] L Indica se o campo é virtual
	                    Nil )                 							// [17] C Picture Variável  

oView := FWFormView():New()
oView:SetModel( oMdlView )

//------------------------------------------------------------
// Ajustes modelo do grid
oStruSC0:RemoveField( 'C0_NUM' )

oView:AddField( 'VIEW_CAB', oStruCab, 'MASTER' )
oView:AddGrid(  'VIEW_GRD', oStruSC0, 'SC0GRID' )

oView:CreateHorizontalBox( 'CIMA' , 25 )
oView:CreateHorizontalBox( 'BAIXO', 75 )

oView:SetOwnerView( 'VIEW_CAB', 'CIMA' )
oView:SetOwnerView( 'VIEW_GRD', 'BAIXO' )

oView:SetFieldAction('C0_LOCALIZ', {|oView| MT430LocAct(oView)})

oView:SetAfterViewActivate({|oView| A430AftVie( oView ) }) 

Return oView

//-------------------------------------------------------------------
/*/{Protheus.doc} MT430LocAct
Executa ações do campo de endereço.

@since 		06/03/2017
@version 	P12
@param		oView   Objeto com o modelo e interface	
@return	Nil
/*/
//-------------------------------------------------------------------
Static Function MT430LocAct(oView)

Local oModel  := oView:GetModel()
Local oMldSC0 := oModel:GetModel("SC0GRID")
Local aAuxRet := oModel:GetModel('SC0GRID'):GetOldData()
			
aHeader   := aClone(aAuxRet[1])
aCols     := aClone(aAuxRet[2])
n := oModel:GetModel('SC0GRID'):GetLine()
			
If !__lKeyF4Loc
	If !VldLocaliz("A430")
		M->C0_LOCALIZ := CriaVar("C0_LOCALIZ")
		If !Empty(FwFldGet('C0_NUMSERI'))
			oMldSC0:SetValue('C0_NUMSERI', CriaVar("C0_NUMSERI"))
		EndIf
	EndIf
	oMldSC0:SetValue('C0_LOCALIZ', M->C0_LOCALIZ)
EndIf

oView:Refresh('VIEW_GRD')
__lKeyF4Loc := .F.

Return Nil


//-------------------------------------------------------------------
/*/{Protheus.doc} InitModel
Inicializar campos do cabeçalho

@since 		28/04/2015
@version 	P12
@param		oModel - Objeto do modelo de dados atual	
@return	.T.
/*/
//-------------------------------------------------------------------
Static Function  InitModel(oModel)

If oModel <> Nil .And. oModel:GetOperation() == MODEL_OPERATION_INSERT
	oModel:GetModel("MASTER"):SetValue("C0_FILIAL",xFilial('SC0'))
	oModel:GetModel("MASTER"):SetValue("C0_SOLICIT",AllTrim(cUserName))
	oModel:GetModel("MASTER"):SetValue("C0_FILRES",cFilAnt)
EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} CompStru
Seleciona os campos para montar o cabeçalho

@since 31/08/2012
@version P11
@param	cCampo Campo a ser avaliado
@return	lRet   Utiliza ou não o campo
/*/
//-------------------------------------------------------------------
Static Function CompStru( cCampo )

Local lRet := ( Alltrim(cCampo) $ "C0_TIPO|C0_DOCRES|C0_SOLICIT|C0_FILRES|" )  // Filtro dos campos a exibir no Cabeçalho

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} SelecSC0
Seleção dos registros para exibição

@since 31/08/2012
@version P11
@param	oMdl      Modelo de dados completo para carga
@return	aResult   Array no formato para utilização no grid
/*/
//-------------------------------------------------------------------
Static Function SelecSC0( oMdl )

Local aResult  := {}	// Será preenchido com os dados para uso no grid
Local cSqlTemp := GetNextAlias()	// nome da tabela temporária gerada com os dados
Local cNum     := SC0->C0_NUM		// Numero da Reserva
Local nX := 0

BeginSql alias cSqlTemp
	
	SELECT * 
	FROM %table:SC0%
	WHERE D_E_L_E_T_ = ' ' AND C0_FILIAL = %xFilial:SC0% AND C0_NUM = %exp:cNum%

EndSql

For nX := 1 To Len(oMdl:aHeader)
	If oMdl:aHeader[nX][8]<>"C"
		TcSetField(cSqlTemp,oMdl:aHeader[nX][2],oMdl:aHeader[nX][8],oMdl:aHeader[nX][4],oMdl:aHeader[nX][5])
	EndIf
Next nX

//----------------------------------------------------------------
//  Adiciona ao array de alteração os recnos dos registros filtrados
aRecnosMVC := {} 
(cSqlTemp)->(DbEval( {|| aAdd( aRecnosMVC, (cSqlTemp)->R_E_C_N_O_ ) } ) )

aResult := FwLoadByAlias( oMdl, cSqlTemp )

(cSqlTemp)->(DbCloseArea())

Return aResult

//-------------------------------------------------------------------
/*/{Protheus.doc} A430AftVie
Inclusão da ação de set key após a construção da interface

@since 03/09/2012
@version P11
@param	oView     View para inclusão de dados extras
/*/
//-------------------------------------------------------------------
Static Function A430AftVie( oView )

Local aUsButtons := {}  // Array com botões de usuários

__lKeyF4Loc := .F.
Set Key VK_F4 To A430ChF4()

oView:aUserButtons := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Botao para eliminacao de saldo                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If oView:GetModel():GetOperation() == MODEL_OPERATION_UPDATE
	oView:AddUserButton( STR0050, "S4WB004N", { || A430ZeraQt() } )  // "Zera saldo remanescente"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Adiciona botoes do usuario na View                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock( "MA430BUT" )
	If ValType( aUsButtons := ExecBlock( "MA430BUT", .F., .F., { oView:GetModel():GetOperation() } ) ) == "A"
		AEval( aUsButtons, { |x| oView:AddUserButton( x[3], x[1], x[2] ) } )
	EndIf
EndIf 	

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A430TrgTp
Valida e limpa o conteúdo do campo C0_DOCRES, conforme o tipo selecionado

@since 04/09/2012
@version P11
@param
	cTipoSelec    ==> CHAR - tipo selecionado
	cDocRes       ==> CHAR - valor do campo documento
/*/
//-------------------------------------------------------------------
Function A430TrgTp( cTipoSelec, cDocRes )

Local cRet     := ' '		// Conteúdo a ser retornado
Local aSaveSA3 := {}		// salvando area da tabela de Vendedor
Local aSaveSA1 := {}		// salvando area da tabela de Clientes
Local aSaveSC5 := {}		// salvando area da tabela de Pedidos

If cTipoSelec $'VD*CL*PD'

	// ------------------------------------------------------
	//  Caso não encontre o valor inserido nas tabelas 
	// de referência, elimina o conteúdo 
	If cTipoSelec == 'VD'
		aSaveSA3 := SA3->( GetArea() )
		SA3->( DbSetOrder(1) )
		If SA3->( DbSeek( xFilial('SA3')+cDocRes ) )
			cRet := cDocRes
		EndIf
		RestArea( aSaveSA3 )

	ElseIf cTipoSelec == 'CL'
		aSaveSA1 := SA1->( GetArea() )
		SA1->( DbSetOrder(1) )
		If SA1->( DbSeek( xFilial('SA1')+cDocRes ) )
			cRet := cDocRes
		EndIf
		RestArea( aSaveSA1 )
		
	ElseIf cTipoSelec == 'PD'
		aSaveSC5 := SC5->( GetArea() )
		SC5->( DbSetOrder( 1 ) )
		If SC5->( DbSeek( xFilial('SC5')+cDocRes ) )
			cRet := cDocRes
		EndIf
		RestArea( aSaveSC5 )

	EndIf
EndIf

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} M430F3MVC
Montagem dinâmica da consulta padrão para o campo C0_DOCRES

@since 05/09/2012
@version P11
@return
/*/
//-------------------------------------------------------------------
Function M430F3MVC() 
Local lRet		:= .F.  // indicação do status de retorno do F3

Local oModel	:= FwModelActive()  // Pega o modelo ativo no momento da chamada do F3
Local oModelCab	:= oModel:GetModel('MASTER')  // Identifica o modelo exclusivo do Cabeçalho

Local aArea		:= GetArea()  // guarda a área ativa
Local cTpRegra	:= oModelCab:GetValue("C0_TIPO") // código do tipo de documento selecionado
Local cF3		:= Space(06)     // tamanho do campo XB_ALIAS 
Local cTabela	:= ""  // Tabela para consulta do F3
Local cVal		:= ""  // Valor selecionado no F3

DbSelectArea("ADI")
DbSetOrder(1)

If cTpRegra=='VD'
	cF3 := 'SA3   '
ElseIf cTpRegra=='CL'
	cF3 := 'CLI   '
ElseIf cTpRegra=='PD'
	cF3 := 'SC5   '
EndIf

// ------------------------------------------------
//  Realiza a consulta conforme o tipo de documento 
// selecionado
If !Trim(cF3) == ""
	DbSelectArea("SXB")
	SXB->(dbSetOrder(1))
	If SXB->(dbSeek(cF3+"1"))
		If Trim(SXB->XB_CONTEM) != "admi"
			cTabela := Trim(SXB->XB_CONTEM)
		EndIf
	EndIf
	If SXB->(dbSeek(cF3+"5"))
		If Trim(SXB->XB_CONTEM) != ""
			cVal := Trim(SXB->XB_CONTEM)
		EndIf 			
		SXB->(DbSkip())
	EndIf
	
	If cVal <> "" .AND. cTabela <> "" 
		lRet := Conpad1( NIL,NIL,NIL,cF3)
		If lRet 
			xRetConPad := &(cVal)
		EndIf			
	//Se nao achou na sxb tenta na sx5 
	ElseIf Len(Trim(cF3)) == 2 .AND. cVal== "" .AND. cTabela == "" 
		lRet := Conpad1( NIL,NIL,NIL,cF3)
		If lRet
			xRetConPad := SX5->X5_CHAVE
		EndIf
	EndIf		
EndIf

RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} M430RETF3
Retorna o conteúdo da variável static xRetConPad no retorno da 
consulta padrão

@since 11/09/2012
@version P11
@return
/*/
//-------------------------------------------------------------------
Function M430RETF3() 

Return xRetConPad

//-------------------------------------------------------------------
/*/{Protheus.doc} A430GrvMVC
Substitui a gravação do MVC por uma própria da rotina

@since 06/09/2012
@version P11
@return
/*/
//-------------------------------------------------------------------
Static Function A430GrvMVC( oModel )

Local lRet    := .T.  // indica o status de retorno da gravação
Local aRecno  := If( oModel:GetOperation()==MODEL_OPERATION_INSERT, {}, aRecnosMVC )  // conjunto de recnos 
Local nX      := 0    // iterador para as linhas do grid
Local aPosGrd := FwSaveRows()  // guarda o estado das linhas no grid

//-------------------------------------------------------------------
//  Executa neste ponto em função das rotinas automáticas de MVC
lPyme := If( Type("lPyme")<>"U", lPyme, If(Type("__lPyme")<>"U", __lPyme, .F. ) )  // verifica se é Pyme

//------------------------------------------
//  Remove a instrução de Set Key inserida ao 
// final da construção da View
Set Key VK_F4 To

If oModel:GetOperation()==MODEL_OPERATION_DELETE 
	If ExistBlock("MA430PEX")
		If !(ExecBlock("MA430PEX"))
			lRet := .F.
		EndIf
	EndIf
	//---------------------------------------
	//   Construir chamada para deleção
	
	If lRet
		A430DelMvc( oModel:GetValue('MASTER', 'C0_NUM')	, ;
			oModel:GetValue('MASTER', 'C0_TIPO')       	, ;
			oModel:GetValue('MASTER', 'C0_DOCRES')    	, ;
			oModel:GetValue('MASTER', 'C0_SOLICIT')   	, ;
			oModel:GetValue('MASTER', 'C0_FILRES') )
	EndIf
	
Else

	For nX := 1 To oModel:GetModel('SC0GRID'):Length()
	
		oModel:GetModel('SC0GRID'):GoLine( nX )
		oModel:GetModel('SC0GRID'):LoadValue('C0_NUM', oModel:GetValue('MASTER', 'C0_NUM') )
	
	Next nX
	
	FwRestRows( aPosGrd )
	
	A430Grava('SC0', ;
			oModel:GetOperation()==MODEL_OPERATION_INSERT, ;
			oModel:GetValue( 'MASTER', 'C0_NUM' ), ;
			oModel:GetValue( 'MASTER', 'C0_TIPO' ), ;
			oModel:GetValue( 'MASTER', 'C0_DOCRES' ), ;
			oModel:GetValue( 'MASTER', 'C0_SOLICIT' ), ;
			oModel:GetValue( 'MASTER', 'C0_FILRES' ), ;
			aRecno)

EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A430VldCbx
Substitui a gravação do MVC por uma própria da rotina

@since 06/09/2012
@version P11
@return
@param 
	cTipoSelec == Tipo do documento selecionado
	cDocRes    == codigo para o documento selecionado
/*/
//-------------------------------------------------------------------
Function A430VldCbx( cTipoSelec, cDocRes )

Local lRet := .T.  // valor de retorno da validação

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ponto de entrada para validacao especial do campo ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MT430VLD")
	lRet := ExecBlock("MT430VLD",.F.,.F.,{ cTipoSelec, cDocRes } )
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A430DelMVC
Deleta os registros das reservas 

@since 06/09/2012
@version P11
@params
	cNum 		-> Numero da reserva
	cTipoRes 	-> Tipo da Reserva
	cDocRes		-> Código do documento
	cSolicit	-> Código do Solicitante
	cFilRes		-> código da filial para reserva
/*/
//-------------------------------------------------------------------
Static Function A430DelMvc( cNum, cTipoRes, cDocRes, cSolicit, cFilRes )

Begin Transaction
	DbSelectArea('SC0')
	DbSetOrder(1)  // FILIAL+NUM+PRODUTO+LOCAL
	MsSeek(xFilial("SC0")+cNum)
	While ( !Eof() .And. SC0->C0_FILIAL	== xFilial("SC0") .And.;
			SC0->C0_NUM 	== cNum )
		a430Reserv({3,cTipoRes,cDocRes,cSolicit,cFilRes},;
			cNum,;
			SC0->C0_PRODUTO,;
			SC0->C0_LOCAL,;
			SC0->C0_QUANT,;
			{	SC0->C0_NUMLOTE,;
			SC0->C0_LOTECTL,;
			SC0->C0_LOCALIZ,;
			SC0->C0_NUMSERI})
		MsUnLock()
		SC0->( DbSkip() )
	EndDo
End Transaction

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A430IniVar
  Reforça a inicialização de variáveis para as situações de rotinas
automáticas, garantindo que elas existam na validações e gravações

@since 02/10/2012
@version P11
/*/
//-------------------------------------------------------------------
Function A430IniVar()

Return Nil

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A430LPre  ³ Autor ³ Vendas/CRM         	³ Data ³ 04/07/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Função para pré-validações da Grid.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A430LPre()		                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MatA430                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A430LPre(oModelGrid,nLinha,cAcao,cField,xValue,xOldValue)

Local lRetorno 	:= .T.
Local lA430MVC	:= .T.
Local nOperacao	:= 0
Local oModel    := oModelGrid:GetModel()

nOperacao := oModel:GetOperation()
If !(cAcao == 'DELETE' .AND. (nOperacao == MODEL_OPERATION_INSERT .OR. nOperacao == MODEL_OPERATION_UPDATE))
	lA430MVC := .F.
EndIf	
If cAcao == 'SETVALUE'
	If cField == "C0_LOCAL"
		If !oModelGrid:IsInserted(nLinha) .And. nOperacao == MODEL_OPERATION_UPDATE .And. oModel:GetModel('SC0GRID'):GetOperation() == MODEL_OPERATION_UPDATE .And. ;
			xValue <> xOldValue			

			Help(" ",1,"A430ALTLOC")
			lRetorno := .F.
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ponto de Entrada para validar a exclusão da Linha.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno .And. lA430MVC .And. ExistBlock("M430DOK")
	lRetorno := ExecBlock("M430DOK",.F.,.F.)
EndIf
                          
Return(lRetorno)

//-------------------------------------------------------------------
/*/{Protheus.doc} A430BlcVld(cAlias,cField,cValid,lbefore)
Função para montar valid customizado em MVC
@author Serviços
@since 06/03/2017
@version 1.0
@return bRet

/*/
//-------------------------------------------------------------------
Static Function A430BlcVld(cAlias,cField,cValid,lBefore,lOnlyVld)

Local cBloco 	:= ""
Local cVldUser 	:= ""
Local aAreaSX3	:= SX3->(GetArea())
Local bRet

Default cValid := AllTrim(Posicione("SX3",2,cField,"X3_VALID"))
Default lBefore	:= .F.
Default lOnlyVld	:= .F.

cVldUser := AllTrim(Posicione("SX3",2,cField,"X3_VLDUSER"))
If !(Empty(cVldUser))
	If lBefore
		cVldUser := cVldUser + " .And. "
	Else
		cVldUser := " .And. " + cVldUser
	EndIf
EndIf

cBloco := "{|a,b,c,d,e| "

If lOnlyVld
	cBloco += " lRet := "
Else
	cBloco += " FWInitCpo(a,b,c,d),lRet := "
EndIf

If lBefore
	cBloco += cVldUser
	cBloco += cValid
Else
	cBloco += cValid
	cBloco += cVldUser
EndIf

If lOnlyVld
	cBloco	+= ",lRet}"
Else
	cBloco += ",FWCloseCpo(a,b,c,lRet),lRet}"
EndIf

bRet := &(cBloco)

RestArea(aAreaSX3)

Return bRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A430DescTp(cTipo)
Função para retornar a descrição do tipo de reserva selecionada
@author Vendas & CRM
@since 08/06/2018
@version P12_17
@return cTpDesc - Descrição do tipo da reserva
/*/
//-------------------------------------------------------------------
Function A430DescTp(cTipo)
Local cTpDesc := ""

If !Empty(cTipo)
	Do Case	
		Case AllTrim(cTipo) == "VD"
			cTpDesc := STR0038
		Case AllTrim(cTipo) == "CL"
			cTpDesc := STR0039
		Case AllTrim(cTipo) == "PD"
			cTpDesc := STR0040
		Case AllTrim(cTipo) == "LB"
			cTpDesc := STR0041
		Case AllTrim(cTipo) == "NF"
			cTpDesc := STR0042
		Case AllTrim(cTipo) == "LJ"
			cTpDesc := STR0058
		OtherWise
			cTpDesc := Space(20)	
	EndCase

EndIf
Return cTpDesc
