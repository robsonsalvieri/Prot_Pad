#INCLUDE "PROTHEUS.CH"
#INCLUDE "TBICONN.CH"
#INCLUDE "TECA470.CH"

#DEFINE CADASTRO STR0008	//"Requisicoes da OS"
#DEFINE  NUMITENS 999
/*/


Ŀ
Funo     TECA470   Autor          Eduardo Riera  Data 05.03.2000
Ĵ
Descrio Programa de Controle do Repair Center                       
Ĵ
 Uso      SIGATEC                                                     
ٱ


/*/
Function TECA470( xAutoCab, xAutoItens, nOpcAuto )

Local cAt470Brw	:= ""		// Filtro fornecido pelo ponto de entrada
Local bFiltraBrw	:= {||}		// Bloco de cdigo para execuo do filtro
Local aIndexABF	:= {}		// Indice do ABF
Local cFiltraABF	:= ""		// Filtro utilizado no bloco de cdigo executado para ativar o filtro

Private aRotina := MenuDef()

Private cCadastro	:= CADASTRO
Private aAutoCab	:= {}
Private aAutoItens	:= {}
Private oGetDReq
Private cLocalAux := ""

If	xAutoCab <> Nil .And. xAutoItens <> NIL
	PRIVATE lAt470Auto := .T.

	aAutoCab  := xAutoCab
	aAutoItens:= xAutoItens

	MBrowseAuto(nOpcAuto,Aclone(aAutoCab),"ABF")
Else
	//Ŀ
	// Verifica a existencia de Filtros na mBrowse                  
	//
	ABF->(DbSetOrder(1))			
	If (ExistBlock("AT470Brw"))
		cAt4F0Brw := ExecBlock("AT470BRW",.F.,.F.)
		If ( ValType(cAt470Brw) == "C" ) .And. !Empty(cAt470Brw)
			cFiltraABF := cAt470Brw
		EndIf
		bFiltraBrw 	:= {|| FilBrowse("ABF",@aIndexABF,@cFiltraABF) }
		Eval(bFiltraBrw)
	EndIf

	mBrowse( 6, 1,22,75,"ABF")
EndIf                                

dbSelectArea("ABF")
dbSetOrder(1)
Return .T.

/*/

Ŀ
Funo    MenuDef    Autor  Conrado Q. Gomes       Data  08.12.06 
Ĵ
Descrio  Definio do aRotina (Menu funcional)                      
Ĵ
Sintaxe    MenuDef()                                                  
Ĵ
Parametros                                                            
Ĵ
 Uso       TECA470                                                    
ٱ


/*/
Static Function MenuDef()
	//Ŀ
	// Define Array contendo as Rotinas a executar do programa      
	// ----------- Elementos contidos por dimensao ------------     
	// 1. Nome a aparecer no cabecalho                              
	// 2. Nome da Rotina associada                                  
	// 3. Usado pela rotina                                         
	// 4. Tipo de Transao a ser efetuada                          
	//    1 - Pesquisa e Posiciona em um Banco de Dados             
	//    2 - Simplesmente Mostra os Campos                         
	//    3 - Inclui registros no Bancos de Dados                   
	//    4 - Altera o registro corrente                            
	//    5 - Remove o registro corrente do Banco de Dados          
	//
	Local aRotina := {	{ STR0001	,"AxPesqui"		,0	,	1	,0	,.F.	}	,;	//"Pesquisar"
						{ STR0002	,"At470Visua"	,0	,	2	,0	,.T.	}	,;	//"Visualizar"
						{ STR0003	,"At470Inclu"	,0	,	3	,0	,.T.	}	,;	//"Incluir"
						{ STR0004	,"At470Alter"	,0	,	4	,0	,.T.	}	,;	//"Alterar"
						{ STR0005	,"At470Exclu"	,0	,	5	,0	,.T.	}	}	//"Excluir"
Return(aRotina)

/*/

Ŀ
Funo    At470Inclu Autor Eduardo Riera           Data 05.03.2000
Ĵ
Descrio  Rotina de Inclusao do Repair Center                        
Ĵ
Sintaxe    At470Inclu(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       TECA470                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
02/01/2007 Conrado Q.    Bops 115751: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
ٱ


/*/
Function At470Inclu(cAlias,nReg,nOpc)

Local aArea		:= GetArea()  
Local aPosObj	:= {} 
Local aObjects	:= {}                        
Local aSize		:= {}
Local oDlg		:= Nil
Local uCampo	:= Nil
Local nCntFor	:= 0
Local nOpcA		:= 0
Local oGetD		:= Nil
Local nSaveSX8	:= GetSX8Len()    

Private aTela	:= {}
Private aGets	:= {}
Private aHeader	:= {}
Private aCols	:= {}

SetKey( VK_F4, { || At470Saldo() } ) 

//Ŀ
// Cria Variaveis de Memoria da Enchoice                
//
dbSelectArea("ABF")
For nCntFor := 1 To FCount()
	uCampo := FieldName(nCntFor)
	M->&(uCampo) := CriaVar(FieldName(nCntFor))
Next nCntFor

//Ŀ
//Montagem aHeader, aCols
//
If Len(aHeader) == 0 .AND. Len(aCols) == 0
	FillGetDados(	nOpc			,"ABG"		,1				,/*cSeek*/		,;
					/*{||cWhile}*/	,{|| .T. }	,/*aNoFields*/	,/*aYesFields*/	,; 
					/*lOnlyYes*/	,/*cQuery*/	,/*bMontCols*/	,.T.			)
Endif

aCols[1][GdFieldPos("ABG_ITEM")] := "01"

If Type("lAt470Auto")=="U" .Or. !lAt470Auto
	aSize    := MsAdvSize()                                                                             
	aObjects := {} 
	AAdd( aObjects, { 100,  60, .t., .t. } )
	AAdd( aObjects, { 100, 100, .t., .t. } )
	
	aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 } 
	aPosObj := MsObjSize( aInfo, aObjects, .T. ) 
	
	//Ŀ
	//Monta tela de entrada                                                   
	//
	DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME 
	EnChoice( cAlias, nReg, nOpc, , , , , aPosObj[1], , 3 )
	oGetd:=MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"At470LinOk","At470TudOk","+ABG_ITEM",.T.,,,,NUMITENS)
	oGetdReq := oGetD		
	ACTIVATE MSDIALOG oDlg ;
		ON INIT At470Bar(oDlg,{||nOpcA:=1,If(Obrigatorio(aGets,aTela).And.oGetd:TudoOk(),oDlg:End(),nOpcA:=0)},{||nOpcA:=0,oDlg:End()},nOpc,oGetD)
Else
	If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)}) .And.;
		MsGetDAuto(aAutoItens,"AT470LinOk",{|| AT470TudOk() },aAutoCab,aRotina[nOpc][4])
		nOpcA := 1
	EndIf
EndIf
		
If ( nOpcA == 1 )
	Begin Transaction
		If ( aT470Grava(1) )
			EvalTrigger()
			While ( GetSX8Len() > nSaveSx8 )
				ConfirmSx8()
			EndDo
		EndIf
	End Transaction
EndIf
//Ŀ
//Restaura a entrada da rotina                                            
//
While ( GetSX8Len() > nSaveSx8 )
	RollBackSx8()
EndDo
RestArea(aArea)     

SetKey( VK_F4,  ) 

Return .T.

/*/

Ŀ
Funo    At470Visua Autor Eduardo Riera           Data 25.03.2000
Ĵ
Descrio  Rotina de Visualizacao do Repair Center                    
Ĵ
Sintaxe    At470Visua(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       TECA470                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
02/01/2007 Conrado Q.    Bops 115751: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
ٱ


/*/
Function At470Visua(cAlias,nReg,nOpc)

Local aArea		:= GetArea()
Local aPosObj	:= {} 
Local aObjects	:= {}                        
Local aSize		:= MsAdvSize() 
Local oDlg		:= Nil
Local uCampo	:= Nil
Local nCntFor	:= 0
Local nOpcA		:= 0
Local oGetD		:= Nil
Local cSeek		:= ""			// Seek para montagem da aCols
Local cWhile	:= ""			// While para montagem da aHeader

Private aTela		:= {}
Private aGets		:= {}
Private aHeader 	:= {}
Private aCols   	:= {}

SetKey( VK_F4, { || At470Saldo() } ) 

//Ŀ
// Cria Variaveis de Memoria da Enchoice                
//
dbSelectArea("ABF")
For nCntFor := 1 To FCount()
	uCampo := FieldName(nCntFor)
	M->&(uCampo) := FieldGet(nCntFor)
Next nCntFor

//Ŀ
//Montagem aHeader, aCols
//
cSeek	:= xFilial("ABG")+ABF->ABF_NUMOS+ABF->ABF_ITEMOS+ABF->ABF_SEQRC
cWhile	:= "ABG->ABG_FILIAL+ABG->ABG_NUMOS+ABG->ABG_ITEMOS+ABG->ABG_SEQRC"

If Len(aHeader) == 0 .AND. Len(aCols) == 0
	FillGetDados(	nOpc			,"ABG"		,1				,cSeek			,;
					{|| &cWhile }	,{|| .T. }	,/*aNoFields*/	,/*aYesFields*/	,; 
					/*lOnlyYes*/	,/*cQuery*/	,/*bMontCols*/	,/*lEmpty*/		)
Endif

//Ŀ
//Monta tela de entrada                                                   
//

aObjects := {} 
AAdd( aObjects, { 100,  60, .t., .t. } )
AAdd( aObjects, { 100, 100, .t., .t. } )

aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 } 
aPosObj := MsObjSize( aInfo, aObjects, .T. ) 

If !IsBlind()
	DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME
		EnChoice( cAlias, nReg, nOpc, , , , , aPosObj[1], , 3 )
		oGetd:=MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"At470LinOk","At470TudOk","+ABG_ITEM",.F.,,,,NUMITENS)
		oGetdReq := oGetD			
	ACTIVATE MSDIALOG oDlg ;
		ON INIT At470Bar(oDlg,{||nOpcA:=1,If(Obrigatorio(aGets,aTela).And.oGetd:TudoOk(),oDlg:End(),nOpcA:=0)},{||nOpcA:=0,oDlg:End()},nOpc,oGetD)
EndIf 
	
//Ŀ
//Restaura a entrada da rotina                                            
//
RestArea(aArea)                      

SetKey( VK_F4,  ) 

Return .T.

/*/

Ŀ
Funo    At470Alter Autor Eduardo Riera           Data 25.03.2000
Ĵ
Descrio  Rotina de Alteracao do Repair Center                       
Ĵ
Sintaxe    At470Alter(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       TECA470                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
02/01/2007 Conrado Q.    Bops 115751: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
ٱ


/*/
Function At470Alter(cAlias,nReg,nOpc)

Local aArea		:= GetArea()
Local aPosObj	:= {} 
Local aObjects	:= {}                        
Local aSize		:= {}
Local oDlg		:= Nil
Local uCampo	:= Nil
Local nCntFor	:= 0
Local nOpcA		:= 0
Local oGetD		:= Nil
Local lAltera	:= .T.
Local nSaveSX8	:= GetSX8Len()
Local cSeek		:= ""			// Seek para montagem da aCols
Local cWhile	:= ""			// While para montagem da aHeader
Local aTravas	:= {}			// Campos que foram travados

Private aTela		:= {}
Private aGets		:= {}
Private aHeader 	:= {}
Private aCols   	:= {}

SetKey( VK_F4, { || At470Saldo() } ) 

//Ŀ
// Cria Variaveis de Memoria da Enchoice                
//
dbSelectArea("ABF")

If !AtTravaReg("ABF", aTravas)
	lAltera := .F.
Endif

For nCntFor := 1 To FCount()
	uCampo := FieldName(nCntFor)
	M->&(uCampo) := FieldGet(nCntFor)
Next nCntFor

If ( lAltera )

	//Ŀ
	//Montagem aHeader, aCols
	//
	cSeek	:= xFilial("ABG")+ABF->ABF_NUMOS+ABF->ABF_ITEMOS+ABF->ABF_SEQRC
	cWhile	:= "ABG->ABG_FILIAL+ABG->ABG_NUMOS+ABG->ABG_ITEMOS+ABG->ABG_SEQRC"
	
	If Len(aHeader) == 0 .AND. Len(aCols) == 0
		FillGetDados(	nOpc			,"ABG"			,1				,cSeek								,;
		  				{|| &cWhile }	,{|| .T. }		,/*aNoFields*/	,/*aYesFields*/						,; 
						/*lOnlyYes*/	,/*cQuery*/		,/*bMontCols*/	,/*lEmpty*/							,;
						/*aHeaderAux*/	,/*aColsAux*/	,/*bAfterCols*/	,{|| AtTravaReg("ABG", aTravas) }	)
	Endif
	
	If Empty(aCols[1][GdFieldPos("ABG_ITEM")])
		aCols[1][GdFieldPos("ABG_ITEM")] := "01"
	Endif
	
	//Ŀ
	//Verifica se  possvel alterar a solicitao do almoxarifado.
	//
	DbSelectArea("ABG")
	DbSetOrder(1)
	If ABG->(DbSeek(cSeek))
		While ABG->(!EOF()) .And. cSeek == (&cWhile)
			DbSelectArea("SCP")
			DbSetOrder(1)
			If ( SCP->(DbSeek(xFilial("SCP")+ABG->ABG_NUMSA+ABG->ABG_ITEMSA)) )
				If ( !MaCanAltSA(.F.) )
					Help(" ",1,"AT470ALT01")
					lAltera := .F.
					Exit
				EndIf
			EndIf
			ABG->(DbSkip())
		End
	EndIf
Endif

//Ŀ
//Monta tela de entrada                                                   
//
If ( lAltera )
	If Type("lAt470Auto")=="U" .Or. !lAt470Auto
		aSize    := MsAdvSize() 
		aObjects := {} 
		AAdd( aObjects, { 100,  60, .t., .t. } )
		AAdd( aObjects, { 100, 100, .t., .t. } )
		
		aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 } 
		aPosObj := MsObjSize( aInfo, aObjects, .T. ) 
	
		DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME
			EnChoice( cAlias, nReg, nOpc, , , , , aPosObj[1], , 3 )
			oGetd:=MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"At470LinOk","At470TudOk","+ABG_ITEM",.T.,,,,NUMITENS)
			oGetdReq := oGetD			
		ACTIVATE MSDIALOG oDlg ;
			ON INIT At470Bar(oDlg,{||nOpcA:=1,If(Obrigatorio(aGets,aTela).And.oGetd:TudoOk(),oDlg:End(),nOpcA:=0)},{||nOpcA:=0,oDlg:End()},nOpc,oGetD)
	Else
		If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)}) .And.;
			MsGetDAuto(aAutoItens,"AT470LinOk",{|| AT470TudOk() },aAutoCab,aRotina[nOpc][4])
			nOpcA := 1
		EndIf
	EndIf
		
	If ( nOpcA == 1 )
		Begin Transaction
			If ( aT470Grava(2) )
				EvalTrigger()
				While ( GetSX8Len() > nSaveSx8 )
					ConfirmSx8()
				EndDo
			EndIf
		End Transaction	
	EndIf
EndIf

//Ŀ
//Restaura a entrada da rotina                                            
//
RestArea(aArea)                       

//Ŀ
//Efetua o destravamento dos registros travados.
//
AtDestravaReg( aTravas )

SetKey( VK_F4,  ) 

Return .T.

/*/

Ŀ
Funo    At470Exclu Autor Eduardo Riera           Data 25.03.2000
Ĵ
Descrio  Rotina de Exclusao do Repair Center                        
Ĵ
Sintaxe    At470Exclu(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       TECA470                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
02/01/2007 Conrado Q.    Bops 115751: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
ٱ


/*/
Function At470Exclu(cAlias,nReg,nOpc)

Local aArea		:= GetArea()
Local aPosObj	:= {} 
Local aObjects	:= {}                        
Local aSize		:= {}
Local oDlg		:= Nil
Local uCampo	:= Nil
Local nUsado	:= 0
Local nCntFor	:= 0
Local nOpcA		:= 0
Local nPosItem	:= 0
Local oGetD		:= Nil
Local lExclui	:= .T.
Local nSaveSX8	:= GetSX8Len()
Local cSeek		:= ""			// Seek para montagem da aCols
Local cWhile	:= ""			// While para montagem da aHeader
Local aTravas	:= {}			// Campos que foram travados

Private aTela		:= {}
Private aGets		:= {}
Private aHeader 	:= {}
Private aCols   	:= {}

SetKey( VK_F4, { || At470Saldo() } ) 


//Ŀ
// Cria Variaveis de Memoria da Enchoice                
//
dbSelectArea("ABF")

If !AtTravaReg("ABF", aTravas)
	lExclui := .F.
Endif

For nCntFor := 1 To FCount()
	uCampo := FieldName(nCntFor)
	M->&(uCampo) := FieldGet(nCntFor)
Next nCntFor

If ( lExclui )
	//Ŀ
	//Montagem aHeader, aCols
	//
	cSeek	:= xFilial("ABG")+ABF->ABF_NUMOS+ABF->ABF_ITEMOS+ABF->ABF_SEQRC
	cWhile	:= "ABG->ABG_FILIAL+ABG->ABG_NUMOS+ABG->ABG_ITEMOS+ABG->ABG_SEQRC"
	
	If Len(aHeader) == 0 .AND. Len(aCols) == 0
		FillGetDados(	nOpc			,"ABG"			,1				,cSeek								,;
		  				{|| &cWhile }	,{|| .T. }		,/*aNoFields*/	,/*aYesFields*/						,; 
						/*lOnlyYes*/	,/*cQuery*/		,/*bMontCols*/	,/*lEmpty*/							,;
						/*aHeaderAux*/	,/*aColsAux*/	,/*bAfterCols*/	,{|| AtTravaReg("ABG", aTravas) }	)
	Endif
	
	If Empty(aCols[1][GdFieldPos("ABG_ITEM")])
		aCols[1][GdFieldPos("ABG_ITEM")] := "01"
	Endif
	
	//Ŀ
	//Verifica se  possvel excluir a solicitao do almoxarifado.
	//
	DbSelectArea("ABG")
	DbSetOrder(1)
	If ABG->(DbSeek(cSeek))
		While ABG->(!EOF()) .And. cSeek == (&cWhile)
			DbSelectArea("SCP")
			DbSetOrder(1)
			If ( SCP->(DbSeek(xFilial("SCP")+ABG->ABG_NUMSA+ABG->ABG_ITEMSA)) )
				If ( !MaCanDelSA(.F.) )
					Help(" ",1,"AT470EXC01")
					lExclui := .F.
					Exit
				EndIf
			EndIf
			ABG->(DbSkip())
		End
	EndIf
EndIf

//Ŀ
//Monta tela de entrada                                                   
//
If ( lExclui )
	If Type("lAt470Auto")=="U" .Or. !lAt470Auto
		aSize    := MsAdvSize() 
		aObjects := {} 
		AAdd( aObjects, { 100,  60, .t., .t. } )
		AAdd( aObjects, { 100, 100, .t., .t. } )
		
		aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 } 
		aPosObj := MsObjSize( aInfo, aObjects, .T. ) 
	
		DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME
			EnChoice( cAlias, nReg, nOpc, , , , , aPosObj[1], , 3 )
			oGetd:=MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"At470LinOk","At470TudOk","+ABG_ITEM",.T.,,,,NUMITENS)
			oGetdReq := oGetD				
		ACTIVATE MSDIALOG oDlg ;
			ON INIT At470Bar(oDlg,{||nOpcA:=1,If(Obrigatorio(aGets,aTela).And.oGetd:TudoOk(),oDlg:End(),nOpcA:=0)},{||nOpcA:=0,oDlg:End()},nOpc,oGetD)
	Else
		If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)}) .And.;
			MsGetDAuto(aAutoItens,"AT470LinOk",{|| AT470TudOk() },aAutoCab,aRotina[nOpc][4])
			nOpcA := 1
		EndIf
	EndIf
			
	If ( nOpcA == 1 )
		Begin Transaction
			If ( aT470Grava(3) )
				EvalTrigger()
				While ( GetSX8Len() > nSaveSx8 )
					ConfirmSx8()
				EndDo
			EndIf
		End Transaction	
	EndIf
EndIf

//Ŀ
//Efetua o destravamento dos registros travados.
//
AtDestravaReg( aTravas )

//Ŀ
//Restaura a entrada da rotina                                            
//
RestArea(aArea)                       

SetKey( VK_F4,  ) 

Return .T.

/*/


Ŀ
Funcao    At470LinOk Autor  Eduardo Riera          Data 05.03.2000
Ĵ
Descrio  Valicao da LinhaOk                                         
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function At470LinOk(oGetD)

Local lRetorno 	:= .T.
Local nUsado   	:= Len(aHeader)
Local nPosProd 	:= aScan(aHeader,{|x| Alltrim(x[2])=="ABG_CODPRO"})
Local nPosQuant	:= aScan(aHeader,{|x| Alltrim(x[2])=="ABG_QUANT"})
Local nPosSer  	:= aScan(aHeader,{|x| Alltrim(x[2])=="ABG_CODSER"})

If ( !aCols[n][nUsado+1] .And. ( Len(aCols) > 1.Or.!Empty(aCols[n][nPosProd])) )
	If ( 	Empty(aCols[n][nPosProd]) .Or.;
			Empty(aCols[n][nPosQuant]) .Or.;
			Empty(aCols[n][nPosSer]) )
		Help(" ",1,"AT470LINOK")
		lRetorno := .F.
	Else
		dbSelectArea("AA5")
		dbSetOrder(1)
		If ( dbSeek(xFilial("AA5")+aCols[n][nPosSer]) )
			If ( AA5->AA5_ATUEST=="S" )
				Help(" ",1,"AT470LIN01")
				lRetorno := .F.
			Else
				dbSelectArea("SF4")
				dbSetOrder(1)
				If ( dbSeek(xFilial("SF4")+AA5->AA5_TES) .And. SF4->F4_ESTOQUE=="S" )
					Help(" ",1,"AT470LIN01")
					lRetorno := .F.
				EndIf
			EndIf
		EndIf	
	EndIf
EndIf
Return(lRetorno)

/*/


Ŀ
Funcao    At470TudOk Autor  Eduardo Riera          Data 05.03.2000
Ĵ
Descrio  Valicao da TudoOk                                          
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At470TudOk()

Local lRetorno := At470VldItem(aCols, aHeader)


Return(lRetorno)

/*/


Ŀ
Funcao    At470Grava Autor  Eduardo Riera          Data 05.03.2000
Ĵ
Descrio  Efetua a Gravacao do Atendimento da OSs                    
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros nOpcao    : [3] Exclusao [1] Inclusao [2] Alteracao        
                                                                      
Ĵ
Observacao                                                            
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
07/07/05  Henry          Bops-83663 - Protecao da gravacao do arqui  
                         vo SCP na hora da geracao da requisicao     
21/05/07  Conrado Q.     Bops-125408 - Adicionado PE AT470GRI, execu 
                         tado antes da gravao da requisio.       
ٱ


/*/
Static Function At470Grava(nOpcao)

Local aArea		:= GetArea()												// Salva a rea atual
Local nCntFor		:= 0														// Contador temporrio
Local nCntFor2	:= 0														// Contador temporrio
Local nPosProd	:= aScan(aHeader,{|x| AllTrim(x[2])=="ABG_CODPRO" })	// Posio do campo ABG_CODPRO na varivel aHeader
Local nPosItem	:= aScan(aHeader,{|x| AllTrim(x[2])=="ABG_ITEM" })	// Posio do campo ABG_ITEM na varivel aHeader
Local nUsado		:= Len(aHeader)											// Quantidade de campos no aHeader
Local bCampo		:= {|x| FieldName(x) }									// Bloco que retorna o nome do campo
Local lGravou		:= .F.														// Indica se j aconteceu a gravao dos dados 
Local cNumSA		:= ""														// Nmero da requisio da OS
Local cItemSA		:= ""														// Nmero do item da requisio da OS
Local lAT470GRI	:= ExistBlock( "AT470GRI", .F., .F. )					// PE para verificaes antes da gravao da requisio da OS
Local lBlockRet	:= .T.														// Retorno do PE, informando se o processamento deve ou no continuar
Local lContinua	:= .T.
Local aCabec		:= {}
Local aItens	   	:= {}
Local nOpc105		:= 0
Local aArrSolic		:= {}
Local lLocPad		:= ABG->(FieldPos( "ABG_LOCPAD"  )) > 0			// Verifica se campo existe

PRIVATE lMsErroAuto := .F. 														// Se deve executar os procedimentos para a requisio da O.S.

If lAT470GRI
	lBlockRet := ExecBlock( "AT470GRI", .F., .F., {nOpcao} )
	If ValType( lBlockRet ) == "L"
		lContinua := lBlockRet
	EndIf
EndIf		

If lContinua
	Do Case
	Case nOpcao <> 3
		//Ŀ
		//Grava os Itens                                                          
		//
		dbSelectArea("ABG")
		For nCntFor := 1 To Len(aCols)
			//Ŀ
			//Posiciona Registro                                                      
			//
			If ( !aCols[nCntFor][nUsado+1] .AND. !Empty(aCols[nCntFor][nPosProd]) )
				dbSelectArea("ABG")
				dbSetOrder(1)		
				If ( !DbSeek(xFilial("ABG")+M->ABF_NUMOS+M->ABF_ITEMOS+M->ABF_SEQRC+;
						aCols[nCntFor][nPosItem]) )
					RecLock("ABG",.T.)
				Else
					RecLock("ABG",.F.)
				EndIf
				For nCntFor2 := 1 To nUsado
					If ( aHeader[nCntFor2][10] <> "V" )
						ABG->(FieldPut(FieldPos(aHeader[nCntFor2][2]),aCols[nCntFor][nCntFor2]))
					EndIf
				Next nCntFor2
				//Ŀ
				// Grava os campos fixos                                    
				//
				ABG->ABG_FILIAL  	:= xFilial("ABG")
				ABG->ABG_NUMOS	    := M->ABF_NUMOS
				ABG->ABG_ITEMOS     := M->ABF_ITEMOS		 
				ABG->ABG_SEQRC      := M->ABF_SEQRC 		 				
				lGravou := .T.
				//Ŀ
				//Grava as SA                                               
				//
				dbSelectArea("SB1")
				dbSetOrder(1)
				dbSeek(xFilial("SB1")+ABG->ABG_CODPRO)
	
				If ( Empty(cNumSA) )
					cNumSA := ABG->ABG_NUMSA
					
					If ( Empty(cNumSA) )
						cNumSA := CriaVar("CP_NUM")		
						
						If Empty(cNumSA)
							cNumSA := NextNumero("SCP",1,"CP_NUM",.T.)
						Else
	
							SCP->( dbSetOrder( 1 ) )					
							While SCP->( dbSeek(xFilial("SCP")+ cNumSa ) )
								ConfirmSX8()
								cNumSA := CriaVar("CP_NUM")									
							EndDo
						Endif
							
					EndIf                
					
				EndIf
				cItemSA := ABG->ABG_ITEM
				If Type("cLocalAux") != "U"
					If cLocalAux  != ""
						cLocalAux := cLocalAux
					Else
						cLocalAux := RetFldProd(SB1->B1_COD,"B1_LOCPAD")
					EndIf
				Else
					cLocalAux := RetFldProd(SB1->B1_COD,"B1_LOCPAD")
				EndIf
				
				If lLocPad .And. !Empty(ABG->ABG_LOCPAD)
					cLocalAux := ABG->ABG_LOCPAD
				EndIf
				
				Aadd(aItens , 	{ {"CP_ITEM" 	, cItemSA						, },;
				 				{"CP_PRODUTO"	, ABG->ABG_CODPRO				, },;
				 				{"CP_UM"		, ABG->ABG_UM					, },;
				 				{"CP_QUANT"		, ABG->ABG_QUANT				, },;
				 				{"CP_DATPRF"	, M->ABF_EMISSA					, },;
				 				{"CP_CC"		, SB1->B1_CC					, },;
				 				{"CP_LOCAL"		, cLocalAux						, },;
				 				{"CP_DESCRI"	, SB1->B1_DESC					, },;
				 				{"CP_QTSEGUM"	, ABG->ABG_QSEGUM				, },;
				 				{"CP_SEGUM"		, ABG->ABG_SEGUM				, },;
				 				{"CP_NUMOS"		, M->ABF_NUMOS+M->ABF_ITEMOS	, },;
				 				{"CP_SEQRC"		, M->ABF_SEQRC					, } } ) 

				dbSelectArea("SCP")
				dbSetOrder(1)		
				
				If nOpc105 == 0	
					If ( SCP->(dbSeek(xFilial("SCP")+cNumSA+cItemSA)) )
						nOpc105 := 4
					Else
						nOpc105 := 3
					EndIf	
				EndIf
				
				ABG->ABG_NUMSA	:= cNumSA
				ABG->ABG_ITEMSA	:= cItemSA
				ABG->(MsUnLock())
				If Type("cLocalAux") != "U"
					cLocalAux := ""
				EndIf
			Else
				dbSelectArea("ABG")
				dbSetOrder(1)		
				If ( DbSeek(xFilial("ABG")+M->ABF_NUMOS+M->ABF_ITEMOS+M->ABF_SEQRC+;
						aCols[nCntFor][nPosItem]) )
					//Ŀ
					//Exclui as SA's                                            
					//
					dbSelectArea("SCP")
					dbSetOrder(1)
					If ( dbSeek(xFilial("SCP")+ABG->ABG_NUMSA+ABG->ABG_ITEMSA) )
						RecLock("SCP")
						If ( MaCanDelSA(.F.) )
							dbDelete()
							RecLock("ABG",.F.)
							dbDelete()
							MsUnLock()
						EndIf
						SCP->(MsUnLock())
					EndIf
				EndIf
			EndIf			
		Next nCntFor
		//Ŀ
		//Rotina automatica da Solicitao ao Armazem                                                       
		//
		If lGravou
			aCabec := {	{"CP_NUM"    	, cNumSA   						, Nil},;
							{"CP_SOLICIT"	, M->ABF_SOLIC					, Nil},;
							{"CP_EMISSAO"	, M->ABF_EMISSA					, Nil} } 
			
			lMsErroAuto := .F.

			If ExistBlock( "AT470CPO" )
				aArrSolic := ExecBlock("AT470CPO",.F.,.F.,{aCabec,aItens,nOpc105})
				MSExecAuto({|x,y,z| mata105(x,y,z)},aArrSolic[1],aArrSolic[2],nOpc105) 
			Else
				MSExecAuto({|x,y,z| mata105(x,y,z)},aCabec,aItens,nOpc105) 
			EndIf	

			If lMsErroAuto
				If !IsBlind()
					MostraErro()
					lGravou := .F.
				EndIf
			EndIf
		EndIf
		//Ŀ
		//Grava o Cabecalho                                                       
		//
		dbSelectArea("ABF")
		dbSetOrder(1)
		DbSeek(xFilial("ABF")+M->ABF_NUMOS+M->ABF_ITEMOS+M->ABF_SEQRC)
		RecLock("ABF",!Found())
		If ( lGravou )
			For nCntFor := 1 To FCount()
				If ( "FILIAL"$Field(nCntFor) )
					ABF->(FieldPut(nCntFor,xFilial("ABF")))
				Else
					ABF->(FieldPut(nCntFor,M->&(EVAL(bCampo,nCntFor))))
				EndIf
			Next nCntFor
		Else
			dbDelete()		
		EndIf
		MsUnLock()
	OtherWise
		//Ŀ
		//Exclui os itens                                                         
		//
		dbSelectArea("ABG")
		dbSetOrder(1)
		DbSeek(xFilial("ABG")+ABF->ABF_NUMOS+ABF->ABF_ITEMOS+ABF->ABF_SEQRC)
		While ( !Eof() .AND. xFilial("ABG") == ABG->ABG_FILIAL .AND.;
				ABF->ABF_NUMOS   == ABG->ABG_NUMOS  .AND.;
				ABF->ABF_ITEMOS  == ABG->ABG_ITEMOS .AND.;
				ABF->ABF_SEQRC   == ABG->ABG_SEQRC )
	
			//Ŀ
			//Exclui as SA's                                            
			//
			dbSelectArea("SCP")
			dbSetOrder(1)
			If ( dbSeek(xFilial("SCP")+ABG->ABG_NUMSA+ABG->ABG_ITEMSA) )
				RecLock("SCP")
				If ( MaCanDelSA(.F.) )
					dbDelete()
					RecLock("ABG",.F.)
					dbDelete()
					MsUnLock()
				EndIf
				SCP->(MsUnLock())
			EndIf
	
			dbSelectArea("ABG")
			dbSkip()
		EndDo
		//Ŀ
		//Deleta o Cabecalho                                                      
		//
		RecLock("ABF")
		dbDelete()
		MsUnLock()
	EndCase
EndIf

If ExistBlock( "AT470GRV" )
	ExecBlock( "AT470GRV", .F., .F., {nOpcao} )
EndIf

RestArea(aArea)
Return(.T.)

/*/


Ŀ
Funcao    At470OS    Autor  Eduardo Riera          Data 25.03.2000
Ĵ
Descrio  Efetua a validacao do Numero da OS.                        
Ĵ
Retorno   ExpL1: indica se a OS eh valida                             
Ĵ
Parametros Nenhum                                                     
                                                                      
Ĵ
Observacao                                                            
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function At470OS()

Local aArea		:= GetArea()
Local cReadVar	:= ReadVar()
Local lRet		:= .F.

dbSelectArea("AB7")
dbSetOrder(1)
If ( "ABF_NUMOS"$cReadVar )
	If Empty(M->ABF_ITEMOS)
		If DbSeek(xFilial("AB7")+&cReadVar)
			lRet := .T.
		EndIf
	Else
		If DbSeek(xFilial("AB7")+&cReadVar+M->ABF_ITEMOS) .And. AB7->AB7_TIPO$"13"
			lRet := .T.
		EndIf
	EndIf
Else
	If	DbSeek(xFilial("AB7")+M->ABF_NUMOS+&cReadVar) .And. AB7->AB7_TIPO$"13"
		lRet := .T.
	EndIf
EndIf

RestArea(aArea)

Return(lRet)

/*/


Ŀ
Funcao    At470QtPri Autor  Eduardo Riera          Data 25.03.2000
Ĵ
Descrio  Efetua a validacao da quantidade na 1.Unidade de Medida    
Ĵ
Retorno   ExpL1: indica se a quantidade eh valida                     
Ĵ
Parametros Nenhum                                                     
                                                                      
Ĵ
Observacao                                                            
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function At470QtPri()

Local aArea		:= GetArea()
Local nPCodPro  := aScan(aHeader,{|x| AllTrim(x[2])=="ABG_CODPRO"})
Local nPQtSeg	:= aScan(aHeader,{|x| AllTrim(x[2])=="ABG_QSEGUM"})
Local nQtdPri	:= &(ReadVar())
Local nQtdSeg	:= 0
Local cCodPro	:= ""

//Ŀ
//Converte a quantidade da Primeira para a Segunda                        
//
If ( nPQtSeg <> 0 .And. nPCodPro <> 0 )
	cCodPro := aCols[n][nPCodPro]
	nQtdSeg := aCols[n][nPQtSeg]
	aCols[n][nPQtSeg] := ConvUM(cCodPro,nQtdPri,nQtdSeg,2)
EndIf

RestArea(aArea)
Return(.T.)

/*/


Ŀ
Funcao    At470QtSeg Autor  Eduardo Riera          Data 25.03.2000
Ĵ
Descrio  Efetua a validacao da quantidade na 2.Unidade de Medida    
Ĵ
Retorno   ExpL1: indica se a quantidade eh valida                     
Ĵ
Parametros Nenhum                                                     
                                                                      
Ĵ
Observacao                                                            
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function At470QtSeg()

Local aArea		:= GetArea()
Local nPCodPro  := aScan(aHeader,{|x| AllTrim(x[2])=="ABG_CODPRO"})
Local nPQtPri	:= aScan(aHeader,{|x| AllTrim(x[2])=="ABG_QUANT"})
Local nQtdPri	:= 0
Local nQtdSeg	:= &(ReadVar())
Local cCodPro	:= ""

//Ŀ
//Converte a quantidade da Primeira para a Segunda                        
//
If ( nPQtPri <> 0 .And. nPCodPro <>0 )
	cCodPro := aCols[n][nPCodPro]
	nQtdPri := aCols[n][nPQtPri]
	aCols[n][nPQtPri] := ConvUM(cCodPro,nQtdPri,nQtdSeg,1)
EndIf

RestArea(aArea)
Return(.T.)     

 
/*/


Ŀ
Funcao    At470Saldo Autor  Sergio Silveira        Data 05/12/2000
Ĵ
Descrio  Efetua a consulta de almoxarifados                         
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
Ĵ
Observacao                                                            
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
   
Function At470Saldo() 
              
Local aItems	:= {}     
Local aArea		:= GetArea() 
Local cQuery	:= ""
Local cProduto	:= GDFieldGet( "ABG_CODPRO" )   
Local cVar		:= ""
Local cSeekSB2	:= ""
Local nOpca		:= 0 
Local oDlg		:= Nil
Local oBmp		:= Nil
Local oCombo	:= Nil
Local oBold		:= Nil
Local oBut1		:= Nil
Local oBut2		:= Nil

SetKey( VK_F4,  ) 

#IFDEF TOP 

	If TcSrvType() <> "AS/400"

		cQuery += "SELECT B2_LOCAL FROM " + RetSqlName( "SB2" ) + " WHERE " 
		cQuery += "B2_FILIAL='" + xFilial( "SB2" ) + "' AND B2_COD='" + cProduto + "' AND "
		cQuery += "D_E_L_E_T_=' ' ORDER BY B2_LOCAL"                                      
		
		cQuery := ChangeQuery( cQuery ) 
		
		dbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), "QUERY1", .F., .T. ) 
		
		If Alias() == "QUERY1"
			While !QUERY1->( Eof() ) 
				AAdd( aItems, B2_LOCAL ) 	
				QUERY1->( dbSkip() ) 
		    EndDo 
		    dbSelectArea("QUERY1")
		    dbCloseArea()
		    dbSelectArea( "SB2" ) 
		EndIf                  
		
	Else	
		
#ENDIF 		
        cSeekSB2 := xFilial( "SB2" ) + cProduto  
 		SB2->( dbSetOrder( 1 ) ) 
 		If SB2->( dbSeek( cSeekSB2 ) )        
			While !SB2->( Eof() ) .And. cSeekSB2 == SB2->B2_FILIAL + SB2->B2_COD  		
				AAdd( aItems, SB2->B2_LOCAL ) 	 		
				SB2->( dbSkip() ) 			 		
 		    EndDo 
        EndIf 
#IFDEF TOP
	EndIf 
#ENDIF 
                                          
If !Empty( aItems ) 

	DEFINE MSDIALOG oDlg TITLE STR0007 FROM 09,0 TO 21.2,43.5 OF oMainWnd //"Consulta posicao de estoque"
	
	DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD
	@   0, 0 BITMAP oBmp RESNAME "LOGIN" oF oDlg SIZE 30, 120 NOBORDER WHEN .F. PIXEL
	
	@ 03, 40 SAY AllTrim( RetTitle( "B2_COD" ) ) + ":" + cProduto FONT oBold PIXEL  
	
	@ 14, 30 TO 16 ,400 LABEL '' OF oDlg   PIXEL
	
	@ 23, 40 SAY RetTitle( "B2_LOCAL" ) SIZE 40, 09 PIXEL 
	@ 23, 80 COMBOBOX oCombo VAR cVar ITEMS aItems SIZE 80, 10 OF oDlg PIXEL 
	
	DEFINE SBUTTON oBut1 FROM 67,  99  TYPE 1 ACTION ( nOpca := 1, nCombo := oCombo:nAt,;
			oDlg:End() ) ENABLE of oDlg
	
	DEFINE SBUTTON oBut2 FROM 67, 132   TYPE 2 ACTION ( nOpca := 0,;
			oDlg:End() ) ENABLE of oDlg
	
	ACTIVATE MSDIALOG oDlg CENTERED  
	
	If nOpca == 1 
		F4Saldo( cProduto, aItems[ nCombo ] ) 
		If Type("cLocalAux") != "U"
			cLocalAux := aItems[nCombo]
		EndIf
	EndIf 
	
EndIf 	
	
RestArea( aArea ) 

SetKey( VK_F4, { || At470Saldo() } ) 

Return( Nil ) 

/*

Ŀ
Funo    AT470Bar   Autor  Sergio Silveira        Data 12/02/2001
Ĵ
Descrio  Mostra a EnchoiceBar na tela                               
Ĵ
 Uso       TECA470                                                    
ٱ


*/

Static Function AT470Bar(oDlg,bOk,bCancel,nOpc,oGetD)

Local aButtons   := {}
Local aUsButtons := {} 

//Ŀ
// Adiciona botoes do usuario na EnchoiceBar                              
//
If ExistBlock( "AT470BUT" ) 
	aUsButtons := ExecBlock( "AT470BUT", .F., .F. )
	AEval( aUsButtons, { |x| AAdd( aButtons, x ) } ) 	 
EndIf 	

Return (EnchoiceBar(oDlg,bOK,bcancel,,aButtons))
//-------------------------------------------------------------------
/*/{Protheus.doc} At470VldItem()
Valida a incluso de requisies da O.S. verificando se existe ao menos 1 item vlido na Grade de Itens.

@author Servios
@since 26/01/2015
@version 12
@param [ARRAY] Representando o aCols dos Itens ds Ordem de Servio
@param [ARRAY]] Representando o aHeader dos Ttulos relativos s colunas do aCols
@return [LOGIC] Retorna Verdadeiro se o aCols dos Itens tiver ao menos 1 retistro com cdigo preenchido e no deletado.  
/*/
//-------------------------------------------------------------------
Static Function At470VldItem(aCols_, aHeader_)
Local lRet       := .F.
Local nI         := 0
Local nPosCodPro := 0
Local nPosCodSer := 0
Local nPosQuant  := 0

Default aCols_   := {}
Default aHeader_ := {}

nPosCodPro := AScan(aHeader,{|x| x[2] == 'ABG_CODPRO'})
nPosQuant  := AScan(aHeader,{|x| x[2] == 'ABG_QUANT '})
nPosCodSer := AScan(aHeader,{|x| x[2] == 'ABG_CODSER'})

If !Empty(aCols_) .and. (nPosCodPro > 0) .and. (nPosCodSer > 0) .and. (nPosQuant > 0)  
	For nI := 1 To Len(aCols_)
 		If lRet := (!aCols_[nI][Len(aCols_[nI])] .AND. !Empty(aCols_[nI][nPosCodPro]) .AND. !Empty(aCols_[nI][nPosCodSer]) .AND. !Empty(aCols_[nI][nPosQuant]))
			Exit
		EndIf
	Next nI
	If !lRet
		Help('',1,'NOINCREQOS',nil,STR0009,2,0) // 'Para confirmar a incluso/alterao  necessrio ter ao menos 1 item na Grade de Dados. Verifique!'
	EndIf
EndIf

Return lRet
