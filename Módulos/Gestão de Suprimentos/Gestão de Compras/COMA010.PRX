#INCLUDE "COMA010.ch"
#INCLUDE "PROTHEUS.CH"
#DEFINE MAXGETDAD 99999
#DEFINE MAXSAVERESULT 999

/*/


Ŀ
Funo     COMA010   Autor  Eduardo Riera          Data  30/09/2003 
Ĵ
Descrio  Rotina de Manutencao da Tabela de Preco                      
Ĵ
Sintaxe    COMA010(ExpN1,ExpA1,ExpA2)                                   
Ĵ
Parametros ExpN1 = opcional - Numero da opcao selecionada               
           ExpA1 = opcional - array cabec.p/ uso na rotina autom.       
           ExpA1 = opcional - array itens p/ uso na rotina autom.       
ٱ


/*/
Function COMA010(nOpcAuto,xAutoCab,xAutoItens)

Local aCores     := {}
Local aRetPE	 := {}
//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
//
PRIVATE aAutoCab
PRIVATE aAutoItens
Private lAuto := .F.
Private aRotina := MenuDef()

cCadastro := STR0009 //"Manutencao da Tabela de Precos"
//Ŀ
//Verifica as cores da MBrowse                                            
//
Aadd(aCores,{"Dtos(AIA_DATATE) < Dtos(dDataBase).And. !Empty(Dtos(AIA_DATATE))","DISABLE"}) //inativa
Aadd(aCores,{"(Dtos(AIA_DATATE) >= Dtos(dDataBase) .Or. Empty(Dtos(AIA_DATATE)))","ENABLE"})    //Ativa

// Validacao para impedir acesso de usuarios que nao possuam acesso a "Tabela de preos" no Configurador
If !versenha(32) // 32 - "Acesso a Tabela de Preos"
	Help(" ",1,"SEMPERM")
	Return
Endif

//Ponto de entrada para manipular as cores
If ExistBlock("CM010COR")
	aRetPE:= ExecBlock("CM010COR",.F.,.F.,{aCores})
	If ( ValType(aRetPE) == "A" .And. Len(aRetPE) > 0 )
		aCores := aClone(aRetPE)
	EndIf
EndIf  

//Ŀ
//Endereca para a funcao MBrowse                                          
//
dbSelectArea("AIA")
dbSetOrder(1)
DbSeek(xFilial("AIA"))
If xAutoCab <> Nil
	aAutoCab   := xAutoCab
	aAutoItens := xAutoItens
	lAuto := .T.
	DEFAULT nOpcAuto := 3
	MBrowseAuto(nOpcAuto,Aclone(aAutoCab),"AIA")
Else
	mBrowse(06,01,22,75,"AIA",,,,,,aCores,,,,,,.F.,.F.)
EndIF
//Ŀ
//Restaura a Integridade da Rotina                                        
//
dbSelectArea("AIA")
dbSetOrder(1)
dbClearFilter()
Return(Nil)


/*/

Ŀ
Funo     MenuDef   Autor  Fernando Amorim        Data  09.02.07 
Ĵ
Descrio  Definio do aRotina (Menu funcional)                      
Ĵ
Sintaxe    MenuDef()                                                  
Ĵ
Parametros                                                            
Ĵ
 Uso       COMA010                                                    
ٱ


/*/
Static Function MenuDef()     
Local aCM010MNU := {}
Local aRotina := {	{ STR0001	,"AxPesqui"		,0,1,0,.F.},; //"Pesquisar"
	{ STR0002	,"Com010Tab"	,0,2,,.T.},;  //"Visualizar"
	{ STR0003	,"Com010Tab"	,0,3,,.T.},;  //"Incluir"
	{ STR0004	,"Com010Tab"	,0,4,,.T.},;  //"Alterar"
	{ STR0005	,"Com010Tab"	,0,5,,.T.},;  //"Excluir"
	{ STR0006	,"Com010Tab"	,0,3,,.T.},;  //"Copiar"
	{ STR0007	,"Com010Rej"	,0,5,,.T.},;  //"Reajuste"
	{ STR0008	,"Com010Leg"	,0,2,,.T.} }  //"Legenda"

If ExistBlock("CM010MNU")
	If ValType( aCM010MNU:= ExecBlock("CM010MNU",.F.,.F.,{aRotina}) ) == "A"
   		aRotina  := aClone(aCM010MNU)
	EndIf    
EndIf
	
Return(aRotina)
/*/


Ŀ
Funo    Com010Tab  Autor  Eduardo Riera          Data  30/09/2003 
Ĵ
Descrio Rotina de Manutencao da Tabela de Preco                       
Ĵ
Sintaxe   Com010Tab()                                                   
Ĵ
ParametrosExpC1: Alias do Arquivo                                       
          ExpN1: Numero do Registro                                     
          ExpN2: Opcao do aRotina                                       
          ExpL1: Comanda visualiz.:se por outra rotina atraves do produto
Ĵ
Uso        Materiais                                                    
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/
Function Com010Tab(cAlias,nReg,nOpc,lConsulta)

Local aPosObj   := {}
Local aObjects  := {}
Local aSize     := {}
Local aInfo     := {}
Local aButtons  := { {"PESQUISA",{|| GdSeek(oGetDad,OemtoAnsi(STR0019),,,.T.) }, OemtoAnsi(STR0019), OemtoAnsi(STR0020) } } //"Busca Produto"
Local aStruAIB  := {}

Local nStyle    := 0
Local nOpcA     := 0
Local nSaveSx8  := GetSx8Len()

Local cCadastro := STR0009 //"Manutencao da Tabela de Precos"
Local cQuery    := ""
Local cQuery1   := ""
Local cSeek     := ""
Local cWhile    := ""
Local cAliasAIB := "AIB"
Local lInclui	:= .F.
Local lCopia    := nOpc==6
Local lAltera   := .F.            // Somente a Alteracao pode ser feita atraves do F12 por produto
Local lContinua := .T.
Local lQuery    := .F.

Local oDlg
Local oGetD
local oQuery 
Local aUsButtons:={}
Local lValMemo := .F.

Private aTELA[0][0]
Private aGETS[0]
Private oGetDad    
Private aHeader := {}
Private aCols   := {}


DEFAULT nOpc      := 2
DEFAULT INCLUI    := .F.
DEFAULT ALTERA    := .F.
DEFAULT lConsulta := .F.
//Ŀ
//Se outro programa estiver consultando a tabela de precos a visualizacao podera ser feita atraves do produto
//
If lConsulta 
	lInclui := INCLUI
	INCLUI  := .F.
	lAltera := ALTERA
	ALTERA  := .F.
EndIf
//Ŀ
//Verifica a Operacao                                                     
//
Do Case
Case INCLUI .Or. lCopia
	nStyle := GD_INSERT+GD_UPDATE+GD_DELETE
Case ALTERA
	nStyle := GD_INSERT+GD_UPDATE+GD_DELETE
OtherWise
	nStyle := 0
EndCase

//Ŀ
//Verifica se a tabela AIA esta Eof() quando chamada pela consulta SXB    
//
lContinua := If( nOpc == 2 .And. AIA->(Eof()), .F. , .T.)

If lContinua

	//Ŀ
	//Inicializa as variaveis da Enchoice                                     
	//
	If INCLUI .Or. lCopia
		RegToMemory( "AIA", .T., .F. )
	EndIf

	If !INCLUI .Or. lCopia		

		If lCopia .Or. nOpc == 2 .Or. SoftLock("AIA")

			If !lCopia
				RegToMemory( "AIA", .F., .F. )
			EndIf

			dbSelectArea("AIB")
			dbSetOrder(1)
			
			lValMemo := ReTMemoAIB()
			
			If !lValMemo
				aStruAIB := AIB->(dbStruct())

				cAliasAIB := "TAB"
				lQuery    := .T.
   				cQuery := "SELECT AIB.*,SB1.B1_DESC FROM "	
				cQuery += RetSqlName("AIB")+ " AIB ,"+RetSqlName("SB1")+" SB1 "
				cQuery += "WHERE "
				cQuery += "AIB.AIB_FILIAL = ? AND "
				cQuery += "AIB.AIB_CODFOR = ? AND "
				cQuery += "AIB.AIB_LOJFOR = ? AND "
				cQuery += "AIB.AIB_CODTAB = ? AND "
				cQuery += "AIB.D_E_L_E_T_ = ? AND "
				cQuery += "SB1.B1_FILIAL  = ? AND "
				cQuery += "SB1.B1_COD     = AIB.AIB_CODPRO AND "
				cQuery += "SB1.D_E_L_E_T_ = ? "


				oQuery := FWPreparedStatement():New(ChangeQuery(cQuery))
				oQuery:SetString(1, xFilial("AIB"))
				oQuery:SetString(2, AIA->AIA_CODFOR)
				oQuery:SetString(3, AIA->AIA_LOJFOR)
				oQuery:SetString(4, AIA->AIA_CODTAB)
				oQuery:SetString(5, ' ')				
				oQuery:SetString(6, xFilial("SB1"))
				oQuery:SetString(7, ' ')

				cQuery := oQuery:GetFixQuery()

				//Ŀ
				// Ponto de Entrada: CM010FIL - Aplicado somente a ambiente TOP 
				//
				If ExistBlock("CM010FIL")
					cQuery1 := ExecBlock("CM010FIL",.F.,.F.,{nOpc})
					If ValType(cQuery1) == "C"
						cQuery +=  cQuery1
					EndIf
				EndIf	

				cQuery += " ORDER BY  " + SqlOrder(AIB->(IndexKey()))
			
				TAB->(dbCloseArea())
		  	 Else
				cWhile:="AIB_FILIAL+AIB_CODFOR+AIB_LOJFOR+AIB_CODTAB"
				cSeek:= (xFilial("AIB")+(AIA->(AIA_CODFOR+AIA_LOJFOR+AIA->AIA_CODTAB)))
			EndIf
          
			//Ŀ
			// Monta aHeader e aCols utilizando a funcao FillGetDados.      
			//
			If !INCLUI .Or. lCopia
		
				//Ŀ
				// Sintaxe da FillGetDados(nOpcX,Alias,nOrdem,cSeek,bSeekWhile,uSeekFor,aNoFields,aYesFields,lOnlyYes,cQuery,bMontCols,lEmpty,aHeaderAux,aColsAux,bAfterCols,bBeforeCols,bAfterHeader,cAliasQry |
				//	
				FillGetDados(nOpc,"AIB",1,cSeek,{|| &cWhile },,,,,cQuery,,,aHeader,aCols, {|aColsX| C010AfterC(aColsX,lCopia,cAliasAIB)} ,,,"TAB")

				If lQuery
					dbSelectArea(cAliasAIB)
					dbCloseArea()
					ChkFile("AIB",.F.)
					dbSelectArea("AIA")
				EndIf	
			EndIf	
		Else
			lContinua := .F.
		EndIf
	Else
		If Empty(aCols)
			//Ŀ
			// Sintaxe da FillGetDados(nOpcX,Alias,nOrdem,cSeek,bSeekWhile,uSeekFor,aNoFields,aYesFields,lOnlyYes,cQuery,bMontCols,lEmpty,aHeaderAux,aColsAux,bAfterCols,bBeforeCols,bAfterHeader,cAliasQry |
			//
			FillGetDados(nOpc,"AIB",1,,,,,,,,,.T.,aHeader,aCols,,,)
			aCols[1][aScan(aHeader,{|x| Trim(x[2])=="AIB_ITEM"})] := StrZero(1,Len(AIB->AIB_ITEM))
		EndIf	
	EndIf
Else
	If nOpc == 2
		Help(" ",1,"REGNOIS")
	EndIf
EndIf

If lContinua
	//Ŀ
	// Avalia botoes do usuario                                     
	//
	If ExistBlock( "CM010BUT" )
		If ValType( aUsButtons := ExecBlock( "CM010BUT", .F., .F. ) ) == "A"
			AEval( aUsButtons, { |x| AAdd( aButtons, x ) } ) 	 	
		EndIf 	
	EndIf 	

	dbSelectArea("AIA")
	AIB->(dbGoto(0))
	If Type("aAutoCab")=="U" .Or. aAutoCab == Nil .Or. IsInCallStack("CONPAD1")
		//Ŀ
		// Faz o calculo automatico de dimensoes de objetos     
		//
		aSize := MsAdvSize()
		AAdd( aObjects, { 100, 100, .T., .T. } )
		AAdd( aObjects, { 200, 200, .T., .T. } )
		aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 5, 5 }
		aPosObj 	:= MsObjSize( aInfo, aObjects,.T.)

		DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 To aSize[6],aSize[5] of oMainWnd PIXEL
		EnChoice( "AIA", nReg, nOpc,,,,,aPosObj[1], , 3, , , , , ,.F. )	
		oGetD := MsNewGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nStyle,"Com010LOk","Com010Tok","+AIB_ITEM",/*acpos*/,/*freeze*/,MAXGETDAD,/*fieldok*/,/*superdel*/,/*delok*/,oDlg,@aHeader,@aCols)
		oGetDad := oGetD
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||aCols:=oGetD:Acols,nOpcA := 1,If(oGetd:TudoOk(),If(!Obrigatorio(aGets,aTela),nOpcA := 0,oDlg:End()),nOpcA := 0)},{||oDlg:End()},,aButtons )
	Else
		//Ŀ
		// validando dados pela rotina automatica                       
		//
		If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)}) .and. MsGetDAuto(aAutoItens,"Com010LOk",{|| Com010Tok() },aAutoCab,aRotina[nOpc][4])
			nOpcA := 1
		EndIf		
	EndIf
	//Ŀ
	//Rotina de Gravacao da Tabela de preco                         
	//
	If nOpcA == 1 .And. nOpc <> 2
		Com010Grv(nOpc-2,aHeader,aCols)
		While (GetSx8Len() > nSaveSx8 )
			ConfirmSx8()
		EndDo
		EvalTrigger()
	Else
		If nOpc <> 2
			While (GetSx8Len() > nSaveSx8 )		
				RollBackSx8()
			EndDo
		EndIf
	EndIf
EndIf
If lConsulta
	INCLUI  := lInclui
	ALTERA  := lAltera
EndIf
//Ŀ
//Restaura a entrada da Rotina                                  
//
MsUnLockAll()
FreeUsedCode()
Return(nOpcA)

/*/


Ŀ
Funo    C010AfterC  Autor Alexandre Inacio LemesData  28/12/2006
Ĵ
Descrio A funcao trata a excecao na montagem do aCols pela FillGetDa
          dos tratando os campos que deverao ser alterados.           
Ĵ
ParametrosExpA1: aCols de Referencia para uso da funcao.              
          ExpA2: Array contendo as referencias de Impostos da Tabela  
          ExpL1: Logica indicando a opcao de Alteracao                
          ExpL2: Logica indicando a opcao de Exclusao                 
          ExpL3: Logica indicando a opcao de Copia                    
          ExpL4: Logica condicional para continuar o processo.        
Ĵ
Retorno   ExpL1: lContinua .T. ou .F.                            	  
ٱ


/*/
Static Function C010AfterC(aColsX,lCopia,cAliasAIB)

Local nPosRecno := aScan(aHeader,{|x| Trim(x[2]) == "AIB_REC_WT"})
Local nPosDescr := aScan(aHeader,{|x| Trim(x[2]) == "AIB_DESCRI"}) 
Local nPosB1Desc := aScan((cAliasAIB)->(DbStruct()),{|x| Trim(x[1]) == "B1_DESC"})   

//Ŀ
//Opcao copia nao deve carregar o Recno() da tabela para o aCols 
//
If lCopia
	aColsX[Len(aColsX)][nPosRecno] := 0
	    If nPosB1Desc >0                         
   		    aColsX[Len(aColsX)][nPosDescr] := (cAliasAIB)->B1_DESC
   		EndIf
EndIf

Return .T.

/*/


Ŀ
Funo    Com010Grv  Autor  Eduardo Riera          Data  30/09/2003 
Ĵ
Descrio Rotina de Gravacao da Tabela de Preco                         
Ĵ
Sintaxe   Com010Grv                                                     
Ĵ
ParametrosExpN1: Opcao da Gravacao sendo:                               
                 [1] Inclusao                                           
                 [2] Alteracao                                          
                 [3] Exclusao                                           
          ExpA1: aHeader                                                
          ExpA2: aCols                                                  
Ĵ
Uso        Materiais                                                    
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/
Function Com010Grv(nOpcao,aHeader,aCols)

Local lGravou   := .F.
Local lTravou   := .T.
Local nX        := 0
Local nY        := 0
Local nCntfor   := 0
Local bCampo 	:= {|nCPO| Field(nCPO) }
Local cItem     := Repl("0",Len(AIB->AIB_ITEM))   
Local nCol		:= 0
Local cAliaAIB	:= GetNextAlias()
Local nFor		:= ASCAN(aAutoCab,{|x| Alltrim(x[1]) == "AIA_CODFOR" })
Local nLoj		:= ASCAN(aAutoCab,{|x| Alltrim(x[1]) == "AIA_LOJFOR" })
Local nCtb		:= ASCAN(aAutoCab,{|x| Alltrim(x[1]) == "AIA_CODTAB" })	
Local cFornece	:= ""
Local cLoja		:= "" 
Local cTabPreco	:= ""
Local lGrv 		:= .T. 
Local lExcl   	:= .F.
Local nPosDel   := 0
Local nPosLin	:= ""
Local cQuery    := ""
local oQuery 	:= Nil
	
//Ŀ
// Ordena o aCols pela ordem de itens
//
	nCol := ASCAN(aHeader, {|x| Alltrim(x[2]) == "AIB_ITEM" })	
	aSort(aCols,,,{ |x,y| x[nCol] <= y[nCol] })

Do Case
	//Ŀ
	// Atualizacao por Tabela                                       
	//
Case nOpcao <> 3
	dbSelectArea("AIB")
	dbSetOrder(1)

	For nX := 1 To Len(aCols)
		Begin Transaction

			If nX == 1
				dbSelectArea("AIA")
				dbSetOrder(1)
				If DbSeek(xFilial("AIA")+M->AIA_CODFOR+M->AIA_LOJFOR+M->AIA_CODTAB)
					RecLock("AIA",.F.)
				Else
					RecLock("AIA",.T.)
				EndIf
				For nCntFor := 1 TO FCount()
					FieldPut(nCntFor,M->&(EVAL(bCampo,nCntFor)))
				Next nCntFor
				AIA->AIA_FILIAL := xFilial("AIA")
				MsUnLock()
			EndIf		

			lTravou := .F.             
			
			dbSelectArea("AIB")		
			dbSetOrder(1)
			If lAuto
				cFornece	:= aAutoCab[nFor][2]
			   	cLoja		:= aAutoCab[nLoj][2]
			   	cTabPreco	:= aAutoCab[nCtb][2]
				lGrv := .T.
				lExcl := .F. 

				If nOpcao == 2
					cItem := aCols[nX,nCol]

					For nY := 1 To Len(aAutoItens) 
						nPosLin := aScan(aAutoItens[nY],{|x| AllTrim(x[1])=="LINPOS"})
						nPosDel := aScan(aAutoItens[nY],{|x| AllTrim(x[1])=="AUTDELETA"})

						If nPosLin > 0 .And. nPosDel > 0 .And. aAutoItens[nY,nPosLin,3] == cItem .And. aAutoItens[nY,nPosDel,2] == "S"
							lExcl := .T.  
						EndIf 
					Next nY

					dbSelectArea("AIB")		
					dbSetOrder(1)
					If DbSeek(xFilial("AIB")+M->AIA_CODFOR+M->AIA_LOJFOR+M->AIA_CODTAB+cItem)
						lGrv := .F.
					Else 
						lGrv := .T. 
					EndIf 	 
				EndIf 
			   		If lGrv //Se no for alterao de um registro, realiza a incluso. 
					   If DbSeek(xFilial("AIB")+M->AIA_CODFOR+M->AIA_LOJFOR+M->AIA_CODTAB)

							cAliaAIB	:= GetNextAlias()

							cQuery := "SELECT	MAX(AIB_ITEM) AS MAXIMO"
							cQuery += "FROM	"+ RetSqlName("AIB") +" AIB"
							cQuery += "WHERE	AIB.AIB_FILIAL = ?"
							cQuery += "AND		AIB.AIB_CODFOR = ?"
							cQuery += "AND 		AIB.AIB_LOJFOR = ?"
							cQuery += "AND		AIB.AIB_CODTAB = ?"
							cQuery += "AND		AIB.D_E_L_E_T_ = ?"

							oQuery := FWPreparedStatement():New(ChangeQuery(cQuery))
							oQuery:SetString(1, xFilial("AIB"))
							oQuery:SetString(2, cFornece)
							oQuery:SetString(3, cLoja)	
							oQuery:SetString(4, cTabPreco)
							oQuery:SetString(5, ' ')				

							cQuery := oQuery:GetFixQuery()

							MpSysOpenQuery(cQuery,cAliaAIB)				

							If	!(cAliaAIB)->(EOF()) 
								cItem := (cAliaAIB)->MAXIMO
							Endif
							(cAliaAIB)->(DbCloseArea())
						EndIf

						cItem := Soma1(cItem,Len(AIB->AIB_ITEM))
					EndIf 
					dbSelectArea("AIB")		
					dbSetOrder(1)
					RecLock("AIB",lGrv)
					lTravou := .T.					
			Else
				If DbSeek(xFilial("AIB")+M->AIA_CODFOR+M->AIA_LOJFOR+M->AIA_CODTAB+aCols[nX][nCol])
					RecLock("AIB",.F.)
					lTravou := .T.
					cItem	:= aCols[nX][nCol]
				Else
					cItem := Soma1(cItem,Len(AIB->AIB_ITEM))
					If DbSeek(xFilial("AIB")+M->AIA_CODFOR+M->AIA_LOJFOR+M->AIA_CODTAB+cItem)
						RecLock("AIB",.F.)
						lTravou := .T.
					EndIf
				EndIf
			EndIf

			If !aCols[nX,Len(aCols[nX])]
				If !lExcl 
					If !lTravou
						RecLock("AIB",.T.)			
					EndIf
					For nY := 1 to Len(aHeader)
						If aHeader[nY][10] <> "V"
							AIB->(FieldPut(FieldPos(aHeader[nY][2]),aCols[nX][nY]))
						EndIf
					Next nY
					AIB->AIB_FILIAL := xFilial("AIB")
					AIB->AIB_CODFOR := AIA->AIA_CODFOR
					AIB->AIB_LOJFOR := AIA->AIA_LOJFOR
					AIB->AIB_CODTAB := AIA->AIA_CODTAB
					AIB->AIB_ITEM   := cItem
					AIB->AIB_INDLOT := StrZero(AIB->AIB_QTDLOT,18,2)
					MsUnLock()
					lGravou := .T.
				Else
					AIB->(dbDelete())
					lGravou := .T.
				EndIf		
			Else
				If lTravou
					RecLock("AIB")
					AIB->(dbDelete())
				EndIf
			EndIf
			MsUnLock()
		End Transaction 		
	Next nX	
	If !lGravou
		dbSelectArea("AIA")
		dbSetOrder(1)
		If DbSeek(xFilial("AIA")+M->AIA_CODFOR+M->AIA_LOJFOR+M->AIA_CODTAB)
			RecLock("AIA")
			dbDelete()
			MsUnLock()
		EndIf
	EndIf
	//Ŀ
	// Exclusao por Tabela                                          
	//
Case  nOpcao == 3

	Begin Transaction

		dbSelectArea("AIB")
		dbSetOrder(1)
		DbSeek(xFilial("AIB")+M->AIA_CODFOR+M->AIA_LOJFOR+M->AIA_CODTAB)

		While ( !Eof() .And. xFilial("AIB") == AIB->AIB_FILIAL .And.;
				M->AIA_CODFOR == AIB->AIB_CODFOR .And.;
				M->AIA_LOJFOR == AIB->AIB_LOJFOR .And.;		
				M->AIA_CODTAB == AIB->AIB_CODTAB )

			RecLock("AIB")
			dbDelete()
			MsUnLock()

			dbSelectArea("AIB")
			dbSkip()
		EndDo

		AIB->(FkCommit())

		dbSelectArea("AIA")
		dbSetOrder(1)
		If DbSeek(xFilial("AIA")+M->AIA_CODFOR+M->AIA_LOJFOR+M->AIA_CODTAB)
			RecLock("AIA",.F.)
			dbDelete()
			MsUnLock()
		EndIf
	End Transaction	
EndCase

If ExistBlock("MT010GRV")
	ExecBlock("MT010GRV",.F.,.F.,{nOpcao,aHeader,aCols})
EndIf

Return(lGravou)


/*/


Ŀ
Funo    Com010LOk  Autor  Eduardo Riera          Data  30/09/2003 
Ĵ
Descrio Rotina de Validacao da linha Ok                               
Ĵ
Sintaxe   Com010Lok())                                                  
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais                                                    
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/
Function Com010Lok()

Local aArea     := GetArea()
Local lRetorno  := .T.
Local nPosProd  := aScan(aHeader,{|x| AllTrim(x[2])=="AIB_CODPRO"})
Local nPosFaixa := aScan(aHeader,{|x| AllTrim(x[2])=="AIB_QTDLOT"})
Local nPosDtVig := aScan(aHeader,{|x| AllTrim(x[2])=="AIB_DATVIG"})
Local nUsado    := Len(aHeader)
Local nX        := 0
Local nY        := 0
Local aCpoObrig	:= Com010Obrig()

//Ŀ
//Verifica os campos obrigatorios                                         
//
If CheckCols(n,aCols)
	//Ŀ
	//Verifica se nao ha valores duplicados                                   
	//
	If lRetorno .And. !aCols[n][nUsado+1]
		For nX := 1 To Len(aCols)
			If lRetorno .And. nX <> N .And. !aCols[nX][nUsado+1]		
				If ( nPosProd == 0 .Or. aCols[nX][nPosProd] == aCols[N][nPosProd]) .And.;
						aCols[nX][nPosFaixa] == aCols[N][nPosFaixa] .And.;
						Iif(nPosDtVig<>0,aCols[nX][nPosDtVig] == aCols[N][nPosDtVig],.F.)
					lRetorno := .F.
					Help(" ",1,"JAGRAVADO")
				EndIf
			EndIf
			If lRetorno .And. lAuto
				For nY := 1 To Len( aCpoObrig )
					If lRetorno .And. Empty(aCols[nX,aCpoObrig[nY,2]])
						Help(" ",1,"OBRIGAT")
						lRetorno := .F.
						Exit
					EndIf
				Next nY
			Endif
		Next nX
		If lRetorno .And. (Empty(aCols[n,nPosProd]) .Or. Empty(aCols[n,nPosFaixa])) .Or. Empty(aCols[n,nPosDtVig])
			Help(" ",1,"OBRIGAT")
			lRetorno := .F.
		EndIf
	EndIF	
EndIf

If lRetorno .And. (ExistBlock("CM010LOK"))
	lRetorno := ExecBlock("CM010LOK",.F.,.F.,{lRetorno})
	If ValType(lRetorno) <> "L"
		lRetorno := .T.
	EndIf
EndIf

RestArea(aArea)
Return(lRetorno)

/*/


Ŀ
Funcao    Com010Obrig   Autor Alexandre Lemes       Data 15/07/2005
Ĵ
Descrio Verifica campos obrigatorios                                
ٱ


/*/

Function Com010Obrig()

Local nI 		:= 0
Local nPos		:= 0
Local aAIBObrig	:= {{"AIB_CODPRO",GdFieldPos("AIB_CODPRO",aHeader)},{"AIB_QTDLOT",GdFieldPos("AIB_QTDLOT",aHeader)},{"AIB_DATVIG",GdFieldPos("AIB_DATVIG",aHeader)}}

For nI := 1 To Len(aHeader)
	nPos 	:= aScan(aAIBObrig,{|x| AllTrim(x[1]) == AllTrim(aHeader[nI][2]) })
	
	If nPos == 0 .And. !(AllTrim( aHeader[nI][2] ) $ "AIB_ITEM|" ) .And. X3Obrigat( aHeader[nI][2] )
		aAdd(aAIBObrig,{AllTrim(aHeader[nI][2]),nI})
	Endif
Next nI

Return aAIBObrig


/*/


Ŀ
Funcao    Com010Tok   Autor Alexandre Lemes        Data 15/07/2005
Ĵ
Descrio Rotina de Validacao da Tudok                                
ٱ


/*/
Function Com010Tok()

Local aArea     := GetArea()
Local lRetorno  := .T.

If !Empty( M->AIA_DATDE ) .And. !Empty( M->AIA_DATATE ) .And. ( M->AIA_DATDE > M->AIA_DATATE )
	Help(" ",1,"DATA2INVAL")
	lRetorno := .F.
Endif

If lRetorno .And. (ExistBlock("CM010TOK"))
	lRetorno := ExecBlock("CM010TOK",.F.,.F.,{lRetorno})
	If ValType(lRetorno) <> "L"
		lRetorno := .T.
	EndIf
EndIf

RestArea(aArea)
Return(lRetorno)


/*/


Ŀ
Funo    Com010Pk   Autor  Eduardo Riera          Data  03/10/2003 
Ĵ
Descrio Rotina de Validacao da chave primaria                         
Ĵ
Sintaxe   Com010PK()                                                    
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais                                                    
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/
Function Com010Pk()

Local aArea    := GetArea()
Local lRetorno := .T.
Local cReadVar := ReadVar()
Local cChave   := ""
Local cConteudo:= &(ReadVar())

//Ŀ
//Trava a chave informada para no ser utilizada por outro usuario        
//
If !Empty(cConteudo) .And. !Empty(M->AIA_CODFOR) .And. !Empty(M->AIA_LOJFOR) .And. !Empty(M->AIA_CODTAB)
	Leave1Code( "AIA"+xFilial("AIA")+M->AIA_CODFOR+M->AIA_LOJFOR+M->AIA_CODTAB )
	Do Case
	Case "AIA_CODFOR"$cReadVar
		cChave += cConteudo+M->AIA_LOJFOR+M->AIA_CODTAB
	Case "AIA_LOJFOR"$cReadVar
		cChave += M->AIA_CODFOR+cConteudo+M->AIA_CODTAB
	Case "AIA_CODTAB"$cReadVar
		cChave += M->AIA_CODFOR+M->AIA_LOJFOR+cConteudo
	EndCase	
	If !MayIUseCode("AIA"+xFilial("AIA")+cChave)
		Help(" ",1,"JAGRAVADO")
		lRetorno := .F.
	EndIf
	//Ŀ
	//Verifica se a chave esta duplicada                                      
	//
	dbSelectArea("AIA")
	dbSetOrder(1)
	If DbSeek(xFilial("AIA")+cChave)
		Help(" ",1,"JAGRAVADO")
		lRetorno := .F.	
	EndIf
EndIf
RestArea(aArea)
Return(lRetorno)


/*/


Ŀ
Funcao    Com010Rej   Autor Eduardo Riera           Data 02.10.03 
Ĵ
Descrio Reajuste das tabelas de precos                              
Ĵ
Retorno    Nenhum                                                     
Ĵ
ParametrosExpC1: Alias do Arquivo                                     
          ExpN1: Numero do Registro                                   
          ExpN2: Opcao do aRotina                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function Com010Rej(cAlias,nReg,nOpc)

Local aArea := GetArea()
Local nOpcA := 0        
Local lRet  := .T.   

//Ŀ
// Ponto de Entrada para execuo do Reajuste da Tabela de Preos 
//
If ExistBlock("CM010RJS")
	lRet := Execblock("CM010RJS",.F.,.F.)
	If ValType(lRet) <> "L"
		lRet := .T.
	EndIf
EndIf
//Ŀ
// Define variaveis de parametrizacao de lancamentos    
//                                                      
// MV_PAR01 Produto inicial?                            
// MV_PAR02 Produto final  ?                            
// MV_PAR03 Grupo inicial  ?                            
// MV_PAR04 Grupo final    ?                            
// MV_PAR05 Tipo inicial   ?                            
// MV_PAR06 Tipo final     ?                            
// MV_PAR07 Tabela inicial ?                            
// MV_PAR08 Tabela final   ?                            
// MV_PAR09 Fornecedor     ?                            
// MV_PAR10 Loja           ?                            
// MV_PAR11 Fator          ?                            
// MV_PAR12 Numero decimais?                            
//  
If lRet
	Pergunte("COM010",.F.)
	FormBatch(STR0010,{STR0011,STR0012},; //"Reajuste da Tabela de precos"###"Esta rotina efetuara o reajuste das tabelas de preco, conforme os parametros "###"solicitados."
		{{5,.T.,{|o| Pergunte("COM010",.T.) }},;
		{1,.T.,{|o| nOpcA:=1,o:oWnd:End()}  },;
		{2,.T.,{|o| o:oWnd:End() }}})
	If ( nOpcA == 1 )
		Processa({|| Com010Proc()})
	EndIf
EndIf
	
RestArea(aArea)
Return(.F.)


/*/


Ŀ
Funcao    Com010Proc  Autor Eduardo Riera           Data 03.05.02 
Ĵ
Descrio Processamento da tabela de preco                            
Ĵ
Retorno    Nenhum                                                     
Ĵ
ParametrosNenhum                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function Com010Proc()

Local aArea     := GetArea()
Local cQuery    := ""
Local cArqInd   := ""
Local cCursor   := "AIB"
Local cUltProc  := ""
Local lQuery    := .F.
Local lContinua := .F.
Local oQuery

//Ŀ
// Define variaveis de parametrizacao de lancamentos    
//                                                      
// MV_PAR01 Produto inicial?                            
// MV_PAR02 Produto final  ?                            
// MV_PAR03 Grupo inicial  ?                            
// MV_PAR04 Grupo final    ?                            
// MV_PAR05 Tipo inicial   ?                            
// MV_PAR06 Tipo final     ?                            
// MV_PAR07 Tabela inicial ?                            
// MV_PAR08 Tabela final   ?                            
// MV_PAR09 Fornecedor     ?                            
// MV_PAR10 Loja           ?                            
// MV_PAR11 Fator          ?                            
// MV_PAR12 Numero decimais?                            
//
//Ŀ
//Processa a atualizacao da tabela de preco             
//
dbSelectArea("AIB")
dbSetOrder(1)

		cCursor:= "Com010Rej"
		lQuery := .T.
		cQuery := "SELECT AIB.AIB_FILIAL, AIB.AIB_CODFOR, AIB.AIB_LOJFOR, AIB.AIB_CODTAB, AIB.AIB_ITEM, AIB.AIB_CODPRO, "
		cQuery += "AIB.AIB_PRCCOM, AIB.AIB_QTDLOT, AIB.AIB_INDLOT, AIB.AIB_MOEDA, AIB.AIB_DATVIG, AIB.AIB_FRETE, SB1.B1_DESC "
		cQuery += "FROM "+RetSqlName("AIB")+" AIB,"
		cQuery += RetSqlName("SB1")+" SB1 "
		cQuery += "WHERE AIB.AIB_FILIAL= ? AND "
		cQuery += "AIB.AIB_CODFOR  = ? AND "
		cQuery += "AIB.AIB_LOJFOR  = ? AND "
		cQuery += "AIB.AIB_CODTAB >= ? AND "
		cQuery += "AIB.AIB_CODTAB <= ? AND "
		cQuery += "AIB.AIB_CODPRO >= ? AND "
		cQuery += "AIB.AIB_CODPRO <= ? AND "
		cQuery += "AIB.D_E_L_E_T_  = ? AND "
		cQuery += "SB1.B1_FILIAL   = ? AND "
		cQuery += "SB1.B1_COD      = AIB.AIB_CODPRO AND "
		cQuery += "SB1.B1_TIPO    >= ? AND "
		cQuery += "SB1.B1_TIPO    <= ? AND "
		cQuery += "SB1.B1_GRUPO   >= ? AND "
		cQuery += "SB1.B1_GRUPO   <= ? AND "
		cQuery += "SB1.D_E_L_E_T_  = ? "
        cQuery += "ORDER BY AIB.AIB_FILIAL,AIB.AIB_CODFOR,AIB.AIB_LOJFOR,AIB.AIB_CODTAB"

		oQuery := FWPreparedStatement():New(ChangeQuery(cQuery))
		oQuery:SetString(1, xFilial("AIB"))
		oQuery:SetString(2, MV_PAR09)
		oQuery:SetString(3, MV_PAR10)
		oQuery:SetString(4, MV_PAR07)
		oQuery:SetString(5, MV_PAR08)				
		oQuery:SetString(6, MV_PAR01)				
		oQuery:SetString(7, MV_PAR02)				
		oQuery:SetString(8, ' ')
		oQuery:SetString(9, xFilial("SB1"))
		oQuery:SetString(10, MV_PAR05)
		oQuery:SetString(11, MV_PAR06)
		oQuery:SetString(12, MV_PAR03)
		oQuery:SetString(13, MV_PAR04)
		oQuery:SetString(14, ' ')

		cQuery := oQuery:GetFixQuery()

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor,.T.,.T.)

ProcRegua(AIB->(LastRec()))

dbSelectArea(cCursor)
While ( !Eof() )
	lContinua := .F.
	If !lQuery
		dbSelectArea("SB1")
		dbSetOrder(1)
		If DbSeek(xFilial("SB1")+(cCursor)->AIB_CODPRO)
			If 	SB1->B1_GRUPO >= MV_PAR03 .And. ;
					SB1->B1_GRUPO <= MV_PAR04 .And. ;
					SB1->B1_TIPO >= MV_PAR05 .And. ;
					SB1->B1_TIPO <= MV_PAR06

				lContinua := .T.

			EndIf
		EndIf		
	Else
		lContinua := .T.
	EndIf
	If lContinua
		If (cCursor)->AIB_CODFOR+(cCursor)->AIB_LOJFOR+(cCursor)->AIB_CODTAB+(cCursor)->AIB_CODPRO==cUltProc
			lContinua := .F.
		EndIf
	EndIf
	If lContinua
		MaRejTabCom((cCursor)->AIB_CODFOR,(cCursor)->AIB_LOJFOR,(cCursor)->AIB_CODTAB,(cCursor)->AIB_CODPRO,MV_PAR11,MV_PAR12)
	EndIf	
	cUltProc := (cCursor)->AIB_CODFOR+(cCursor)->AIB_LOJFOR+(cCursor)->AIB_CODTAB+(cCursor)->AIB_CODPRO
	dbSelectArea(cCursor)
	dbSkip()
	IncProc(STR0013+" : "+cUltProc) //"Reajustando"
EndDo
If lQuery
	dbSelectarea(cCursor)
	dbCloseArea()
	dbSelectArea("AIB")
Else
	dbSelectArea("AIB")
	RetIndex("AIB")
	Ferase(cArqInd+OrdBagExt())
EndIf
RestArea(aArea)
Return(.T.)


/*/


Ŀ
Funcao    MaRejTabCom Autor  Eduardo Riera          Data 03.10.03 
Ĵ
Descrio Rotina de reajuste da tabela de preco                       
Ĵ
Retorno   ExpN1: Numerico (Preco de Compra)                           
Ĵ
ParametrosExpC1: Fornecedor                                           
          ExpC2: Loja                                                 
          ExpC3: Tabela de Preco                                      
          ExpC4: Codigo do Produto                                    
          ExpN1: Fator                                                
          ExpN2: Decimais a serem consideradas                        
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaRejTabCom(cCodFor,cLoja,cCodTab,cCodPro,nFator,nDecimais)

Local aArea    := GetArea()
Local aAreaAIA := AIA->(GetArea())
Local aAreaAIB := AIB->(GetArea())
Local nBase    := 0
Local lCM010REJ:= ExistBlock("CM010REJ")

DEFAULT nDecimais := TamSx3("AIB_PRCVEN")[2]

dbSelectArea("AIB")
dbSetOrder(2)
If DbSeek(xFilial("AIB")+cCodFor+cLoja+cCodTab+cCodPro)
	While !Eof() .And. AIB->AIB_FILIAL == xFilial("AIB") .And.;
			AIB->AIB_CODFOR == cCodFor .And.;
			AIB->AIB_LOJFOR == cLoja .And.;
			AIB->AIB_CODTAB == cCodTab .And.;
			AIB->AIB_CODPRO == cCodPro

		Begin Transaction

			RecLock("AIB")

			nBase   := AIB->AIB_PRCCOM

			AIB->AIB_PRCCOM := If(nFator > 0, NoRound(nBase * nFator,nDecimais), nBase )
			MsUnLock()

		End Transaction 
		
		//Ŀ
		//Ponto de entrada para atualizacao de precos            
		//
		If lCM010REJ
			ExecBlock("CM010REJ",.F.,.F.,{nBase, AIB->AIB_PRCCOM})
		Endif	

		dbSelectArea("AIB")
		dbSkip()
	EndDo
EndIf
RestArea(aAreaAIB)
RestArea(aAreaAIA)
RestArea(aArea)
Return(.T.)


/*/


Ŀ
Funcao    MATABPRCOM  Autor  Eduardo Riera          Data 02.10.03 
Ĵ
Descrio Funcao para trazer preco de compra de acordo com a qtde     
Ĵ
Retorno   ExpN1: Numerico (Preco de Compra)                           
Ĵ
ParametrosExpC1: Tabela de Preco                                      
          ExpC2: Codigo do Produto                                    
          ExpN1: Quantidade                                           
          ExpC3: Codigo do Fornecedor                                 
          ExpC4: Loja                                                 
          ExpN2: Moeda a ser retornada                                
          ExpD1: Data de Validade                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaTabPrCom(cTabPreco,cProduto,nQtde,cFornece,cLoja,nMoeda,dDataVld,nTxMoeda,nValFrete)

Local aArea     := GetArea()
Local aUltResult:= {}
Local cQuery    := ""
Local cAliasAIB := "AIB"
Local nPrcCom   := 0
Local nResult   := 0
Local nQtdLote  := 0
Local nMoedaTab := 1
Local nScan     := 0
Local nY        := 0  
Local nCM010PCL := 0
Local lUltResult:= .T.
Local lQuery    := .F.
Local lProcessa := .F.
Local lPrcAIB   := .F.
Local dDtVig    := CTOD("  /  /  ")
Local lMoedaAIB := .F.
local oQuery

DEFAULT nMoeda    := 1
DEFAULT dDataVld  := dDataBase
DEFAULT nTxMoeda  := Nil     
DEFAULT nValFrete := 0  

nScan := aScan(aUltResult,{|x| x[1] == cTabPreco .And.;
	x[2] == cProduto .And.;
	x[3] == nQtde .And.;
	x[4] == cFornece .And.;
	x[5] == cLoja .And.;
	x[6] == nMoeda .And.;
	x[7] == cFilAnt.And.;
	x[9] == nTxMoeda })

If nScan == 0
	dbSelectarea("AIB")
	dbSetOrder(1)
			lQuery    := .T.
			cAliasAIB := "QRYAIB"
			aStruAIB  := AIB->(dbStruct())

			cQuery := "SELECT * "
			cQuery += "FROM "+RetSqlName("AIB")+ " AIB "
			cQuery += "WHERE "
			cQuery += "AIB_FILIAL 	   = ? AND "
			cQuery += "AIB_CODFOR 	   = ? AND "
			cQuery += "AIB_LOJFOR 	   = ? AND "
			cQuery += "AIB_CODTAB 	   = ? AND "
			cQuery += "AIB_CODPRO 	   = ? AND "
			cQuery += "AIB_QTDLOT 	  >= ? AND "
			cQuery += "AIB.D_E_L_E_T_  = ? "
			cQuery += "ORDER BY AIB_QTDLOT,AIB.AIB_FILIAL,AIB.AIB_CODFOR,AIB.AIB_LOJFOR,AIB.AIB_CODTAB"			

	  		oQuery := FWPreparedStatement():New(ChangeQuery(cQuery))
			oQuery:SetString(1, xFilial("AIB"))
			oQuery:SetString(2, cFornece)
			oQuery:SetString(3, cLoja)
			oQuery:SetString(4, cTabPreco)
			oQuery:SetString(5, cProduto)				
			oQuery:SetString(6, Str(nQtde,18,8))
			oQuery:SetString(7, ' ')

			cQuery := oQuery:GetFixQuery()

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasAIB,.T.,.T.)

			For nY := 1 To Len(aStruAIB)
				If aStruAIB[nY][2]<>"C"
					TcSetField(cAliasAIB,aStruAIB[nY][1],aStruAIB[nY][2],aStruAIB[nY][3],aStruAIB[nY][4])
				EndIf
			Next nY
			If (cAliasAIB)->(!Eof())
				lProcessa := .T.
			EndIf
	If lProcessa	
		If nQtde == 0 .And. Empty(cFornece)
			nPrcCom   := (cAliasAIB)->AIB_PRCCOM
			nMoedaTab := (cAliasAIB)->AIB_MOEDA			
			nValFrete := (cAliasAIB)->AIB_FRETE
			lPrcAIB   := .T.
		Else
			//Ŀ
			//Busco o preco e analiso a qtde de acordo com a faixa
			//
			dbSelectArea(cAliasAIB)
			While (cAliasAIB)->(!Eof()) .And. (cAliasAIB)->AIB_FILIAL == xFilial("AIB") .And.;
					(cAliasAIB)->AIB_CODFOR == cFornece  .And.;
					(cAliasAIB)->AIB_LOJFOR == cLoja     .And.;								
					(cAliasAIB)->AIB_CODTAB == cTabPreco .And.;
					(cAliasAIB)->AIB_CODPRO ==  cProduto
					
				If (cAliasAIB)->AIB_MOEDA == nMoeda
					lMoedaAIB := .T.
				Endif
				(cAliasAIB)->(DbSkip())
			Enddo
			
			(cAliasAIB)->(DbGotop())
			While (cAliasAIB)->(!Eof()) .And. (cAliasAIB)->AIB_FILIAL == xFilial("AIB") .And.;
					(cAliasAIB)->AIB_CODFOR == cFornece  .And.;
					(cAliasAIB)->AIB_LOJFOR == cLoja     .And.;								
					(cAliasAIB)->AIB_CODTAB == cTabPreco .And.;
					(cAliasAIB)->AIB_CODPRO ==  cProduto
				If nQtde <= (cAliasAIB)->AIB_QTDLOT .And. Iif(lMoedaAIB,nMoeda == (cAliasAIB)->AIB_MOEDA,.T.)									
					//Ŀ
					//Verifica a vigencia do item                                   
					//				
					nQtdLote := (cAliasAIB)->AIB_QTDLOT

					While (cAliasAIB)->(!Eof()) .And. (cAliasAIB)->AIB_FILIAL == xFilial("AIB") .And.;
							(cAliasAIB)->AIB_CODFOR == cFornece  .And.;
							(cAliasAIB)->AIB_LOJFOR == cLoja     .And.;								
							(cAliasAIB)->AIB_CODTAB == cTabPreco .And.;
							(cAliasAIB)->AIB_CODPRO ==  cProduto .And.;
							(cAliasAIB)->AIB_QTDLOT == nQtdLote .And.;
							(cAliasAIB)->AIB_DATVIG <= dDataVld

						If nQtde <= (cAliasAIB)->AIB_QTDLOT .And. (Empty(dDtVig) .Or. (cAliasAIB)->AIB_DATVIG > dDtVig) .And. Iif(lMoedaAIB,nMoeda == (cAliasAIB)->AIB_MOEDA,.T.)

							nPrcCom   := (cAliasAIB)->AIB_PRCCOM
							nMoedaTab := (cAliasAIB)->AIB_MOEDA  
							nValFrete := (cAliasAIB)->AIB_FRETE  
							dDtVig    := (cAliasAIB)->AIB_DATVIG

							lPrcAIB   := .T.
						EndIf

						dbSelectArea(cAliasAIB)
						dbSkip()
					EndDo				
					If lPrcAIB
						Exit
					EndIf						
				EndIf
				dbSelectArea(cAliasAIB)
				dbSkip()
			EndDo			
		EndIf
	EndIf
	//Ŀ
	//Guarda os ultimos resultados                                            
	//
	nResult  := xMoeda(nPrcCom,nMoedaTab,nMoeda,,TamSx3("D1_VUNIT")[2],,nTxMoeda)	
	nValFrete:= xMoeda(nValFrete,nMoedaTab,nMoeda,,TamSx3("D1_VUNIT")[2],,nTxMoeda)
	If lUltResult
		aadd(aUltResult,{cTabPreco,cProduto,nQtde,cFornece,cLoja,nMoeda,cFilAnt,nResult,nTxMoeda,nValFrete})
		If Len(aUltResult) > MAXSAVERESULT
			aUltResult := aDel(aUltResult,1)
			aUltResult := aSize(aUltResult,MAXSAVERESULT)
		EndIf
	EndIf
Else
	nResult := aUltResult[nScan][8] 
	If Len(aUltResult[nScan])>9 
		nValFrete := aUltResult[nScan][10]
	EndIf
EndIf  

//Ŀ
//Ponto de Entrada: CM010PCL  
//   
If ExistBlock("CM010PCL")
	nCM010PCL:=ExecBlock("CM010PCL",.T.,.T.,{cFornece,cLoja,cTabPreco,cProduto,cAliasAIB,nResult})
	If ValType(nCM010PCL)=="N" 
		nResult:=nCM010PCL
	EndIf
EndIF

If lQuery
	dbSelectArea(cAliasAIB)
	dbCloseArea()
	dbSelectArea("AIB")
EndIf
RestArea(aArea)
Return(nResult)


/*/


Ŀ
Funcao    MaVldTabCom Autor Eduardo Riera           Data 02.10.03 
Ĵ
Descrio Validacao da tabela de precos de Compras                    
Ĵ
Retorno   ExpL1: Tabela valida                                        
Ĵ
ParametrosExpC1: Fornecedor                                           
          ExpC2: Loja                                                 
          ExpC3: Tabela de Preco                                      
          ExpC4: Condicao de Pagamento                                
          ExpN5: Help                                                 
          ExpD6: Data de Validade da tabela de preco                  
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaVldTabCom(cCodFor,cLojaFor,cCodTab,cCondPag,cHelp,dDataVld)

Local aArea   := GetArea()
Local AIArea  := AIA->(GetArea())
Local lValido := .T.

DEFAULT dDataVld := dDataBase

DbSelectArea("AIA")
AIA->(DbSetOrder(1))

If !Empty(cCodTab)
    //-- Verifica a vigencia da tabela de precos
	lValido := ExistCpo("AIA", cCodFor + cLojaFor + cCodTab, 1)
EndIf	

If lValido
	If AIA->(DbSeek(xFilial("AIA")+cCodFor+cLojaFor+cCodTab))
	    If dDataVld < AIA->AIA_DATDE .Or. dDataVld > IIF(!Empty(AIA->AIA_DATATE),AIA->AIA_DATATE,dDataVld )
	        If Empty(cHelp)
	            Aviso(STR0016,STR0017,{STR0018})//"A data de emissao do pedido nao encontra-se dentro da data de validade desta tabela de precos, altere a data de validade da tabela ou escolha outra"
	        Else
	            cHelp := "COMTABPRC"
	        EndIf
	        lValido := .F.
	    Else
	        If !Empty(cCondPag) .And. !Empty(AIA->AIA_CONDPG) .And. cCondPag <> AIA->AIA_CONDPG
	            If Empty(cHelp)
	                Help(" ",1,"COMTABPRC")
	            Else
	                cHelp := "COMTABPRC"
	            EndIf
	            lValido := .F.
	        EndIf
	    EndIf
	Endif
EndIf

RestArea(AIArea)
RestArea(aArea)

Return lValido


/*/


Ŀ
Funcao    Com010Leg   Autor Henry Fila              Data 02.10.03 
Ĵ
Descrio Legenda das tabelas                                         
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosNenhum                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function Com010Leg()

Local aRetPE  := {}
Local aLegenda := { { "BR_VERMELHO",STR0014 },;  //"Inativa"
					{ "BR_VERDE",STR0015	}}	  //"Ativa"
//Ponto de entrada para manipular a legenda
If ExistBlock("CM010LEG")
	aRetPE:= ExecBlock("CM010LEG",.F.,.F.,{aLegenda})
	If ( ValType(aRetPE) == "A" .And. Len(aRetPE) > 0 )
		aLegenda := aClone(aRetPE)
	EndIf
EndIf

BrwLegenda( cCadastro, STR0021, aLegenda  ) //"Status"
Return(.T.)

/*/


Ŀ
Funcao    Com010Data  Autor Nereu Humberto Junior   Data 20.08.07 
Ĵ
Descrio Validacao das data iniciais e finais da tabela de precos    
Ĵ
Retorno   .T. ou .F.                                                  
Ĵ
ParametrosNenhum                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function Com010Data()

Local lRet := .T.

If !Empty( M->AIA_DATDE ) .And. !Empty( M->AIA_DATATE ) .And. ( M->AIA_DATDE > M->AIA_DATATE )
	Help(" ",1,"DATA2INVAL")
	lRet := .F.
Endif

Return(lRet)

/*/


Ŀ
Programa   Com010Sxb   Autor  Nereu Humberto Junior Data  06.09.2007 
Ĵ
Descrio  Funcao generica para filtro tipo 6 via SXB                    
ٱ


/*/
Function Com010Sxb()

Local lRet := .T.
Local cFunName := UPPER(AllTrim(FunName()))

If cFunName = "MATA060"
	lRet := AIA->AIA_FILIAL==xFilial("AIA") .AND. AIA->AIA_CODFOR == M->A5_FORNECE .AND. AIA->AIA_LOJFOR == M->A5_LOJA
ElseIf cFunName = "MATA065"
	lRet := AIA_FILIAL==xFilial("AIA") .AND. AIA_CODFOR == M->AD_FORNECE .AND. AIA_LOJFOR == M->AD_LOJA
ElseIf cFunName = "MATA121" .Or. cFunName = "MATA122"
	lRet := AIA_FILIAL==xFilial("AIA") .AND. AIA_CODFOR == cA120Forn .AND. AIA_LOJFOR == cA120Loj
ElseIf cFunName = "MATA150"
	lRet := AIA_FILIAL==xFilial("AIA") .AND. AIA_CODFOR == cA150Forn .AND. AIA_LOJFOR == cA150Loj
Endif

Return(lRet)      

/*/


Ŀ
Programa   ReTMemoAIB  Autor  Suprimentos           Data  13/08/2018 
Ĵ
Descrio  Verifica se existe um MEMO de Usuario na tabela AIB           
ٱ


/*/
Static Function ReTMemoAIB()

Local aStru := FWFormStruct(3,"AIB")[1]
Local nX
Local lRet	:= .F.

// Retorno da FWFormStruct = 3
//[01][03] ExpC:idField
//[01][04] ExpC:Tipo
//[01][14] ExpL:Campo virtual?

For nX := 1 To Len(aStru)
	If aStru[nX][4] == "M" .And. !(aStru[nX][14])
		lRet := .T.
	EndIf
Next nX

Return lRet
