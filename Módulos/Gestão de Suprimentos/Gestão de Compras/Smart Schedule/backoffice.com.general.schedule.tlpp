#include "msobject.ch"
#include "protheus.ch"
#include "fwlibversion.ch"
#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "fw-tlpp-core.th"
#include "backoffice.com.general.schedule.ch" 

namespace totvs.protheus.backoffice.com.general

//-------------------------------------------------------------------
/*/{Protheus.doc} schedule
    Classe para controle das ações do novo Schedule para as rotinas
	da Squad de Compras.
	Através desta classe, basta intanciá-la e processar a rotina de
	criação de tarefas ou novo agendamento.

@author Everton Fregonezi Diniz
@since 04/04/2024
@version 12.1.2310
*/
//-------------------------------------------------------------------
class schedule

	public data cMsgError	as character
	public data lInsert		as logical
	public data lSchedExec	as logical
	public data lLibVersion	as logical
	public data lUsrAdmin	as logical
	public data lSmartSched as logical

	public method new()
	public method createTask()
	public method createSched()
	
	protected method validEnvironment() 

endclass


//-------------------------------------------------------------------
/*/{Protheus.doc} new
    Método para iniciar e instanciar o novo objeto do Smart Schedule

@author Everton Fregonezi Diniz
@since 04/04/2024
@version 12.1.2310
*/
//-------------------------------------------------------------------
method new() class schedule
	
	self:cMsgError		:= ""
	self:lInsert		:= .F.
	self:lSchedExec		:= .T.
	self:lLibVersion	:= .T.
	self:lUsrAdmin		:= .T.
	self:lSmartSched	:= .F.
	self:validEnvironment("20240408")
	
return self

/*/{Protheus.doc} createTask()
	Encapsula a criação de task executando uma pergunta se deve ou não executar em segundo plano.

@author Everton Fregonezi Diniz
@since 04/04/2024
@version 12.1.2310
@link https://tdn.totvs.com/pages/releaseview.action?pageId=794392560
/*/
method createTask(cRoutine as character, lInterface as logical) class Schedule

local aGrpSX1		:= {}	as array
local aMvPar		:= {}	as array
local nX					as numeric
local oTask					as object
local lImpTraTool	:= .F.	as logical

default cRoutine 	:= ''
default lInterface	:= .T.

	lImpTraTool := FwIsInCallStack("IMPTRATOOL")

	if self:lSchedExec .and. !empty(cRoutine)
		aGrpSX1 := totvs.framework.schedule.utils.getParamsMV(cRoutine)
		aMvPar := Array(len(aGrpSX1), "")

		for nX := 1 To len(aGrpSX1)
			aMvPar[nX] := &('MV_PAR' + strZero(nX,2) )
		next nX
	endif

	oTask := totvs.framework.schedule.utils.createTask(getEnvServer(), cEmpAnt, cFilAnt, cRoutine, nModulo, retCodUsr(), , aMvPar, .T., lInterface)
	
	if !empty(oTask:cID) 
		self:lInsert := .T.
		cMsg := STR0001 + CRLF + CRLF				// 'Rotina inserida na fila de processamento com sucesso!'
		cMsg += STR0002 + oTask:cFunction + CRLF	// 'Nome da Rotina: '
		cMsg += STR0003 + oTask:cID + CRLF + CRLF	// 'ID Tarefa: '
		If !lImpTraTool
			cMsg += STR0004							// 'Acompanhe no Visualizador de Eventos a evolução do processamento da sua rotina'
		Else
			cMsg += STR0021							//"Ao finalizar processamento em segundo plano, visualizar log gerado atraves do 'Consultar log'"
		Endif
		fwAlertSuccess(cMsg, STR0005)				// 'TOTVS' 
	endif

	fwFreeArray(aGrpSX1)
	fwFreeArray(aMvPar)
	FreeObj(oTask)

return


/*/{Protheus.doc} createTask()
	Encapsula a criação de task executando uma pergunta se deve ou não executar em segundo plano.

@author Everton Fregonezi Diniz
@since 04/04/2024
@version 12.1.2310
@link https://tdn.totvs.com/display/public/FRAMESPSQDS/Classe+Automatic
/*/
method createSched(aRegs as array) class Schedule

local clibVersion		as character
local oSchedule			as object

default aRegs := {}

	cLibVersion		:= FwLibVersion()

	oSchedule := totvs.framework.schedule.automatic():new()										// Método para instanciar a classe (construtor).
	oSchedule:setRoutine(aRegs[1])																// Método para definir a rotina/função de execução do agendamento.
	oSchedule:setFirstExecution(aRegs[11,1],aRegs[11,2])										// Método para definir data e hora da primeira execução do agendamento.
	oSchedule:setEnvironment(getEnvServer(), aRegs[10] )										// Método para definir ambiente, empresas e filiais de execução do agendamento.
	oSchedule:setModule(aRegs[2])																// Método para definir o módulo de execução do agendamento.
	oSchedule:setUser(aRegs[3])																	// Método para definir o usuário de execução.
	oSchedule:setDescription(aRegs[4])															// Método para definir a descrição do agendamento.
	oSchedule:setRecurrence(aRegs[5])															// Método para definir a recorrência do agendamento.
	oSchedule:setManageable(aRegs[9])															// Método para definir a permissão de manutenção via App SmartSchedule.
	if oSchedule:setPeriod(aRegs[6,1], aRegs[6,2], aRegs[6,3], aRegs[6,4], aRegs[6,5])			// Método para definição da periodicidade do agendamento.
		if oSchedule:setFrequency(aRegs[7,1], aRegs[7,2], aRegs[7,3], aRegs[7,4], aRegs[7,5]);	// Método para definição da frequência do agendamento.
			.or. aRegs[6,1] == 'U'
			if oSchedule:createSchedule()														// Método para inclusão do agendamento com base nas informações pré-definidas.
				self:lInsert := .T.
				conout("[SUCCESS][SMARTSCHEDULE] " + STR0006 + ' ' + STR0007 + aRegs[1] + STR0008)	// ">> Programa agendado com sucesso" # " " Agendamento da função " " # " cadastrada com sucesso"
			endif
		endif
	endif

return


/*/{Protheus.doc} validEnvironment()
	Faz a validação da versão minima da Lib utilizada no ambiente.

@author Everton Fregonezi Diniz
@since 04/04/2024
@version 12.1.2310
/*/
method validEnvironment(cMinimumLibLabel as character) class schedule

local cLibVersion	as character

default cMinimumLibLabel := "20240408"

	cLibVersion	:= FwLibVersion()

	if !(FwIsAdmin())
		self:lUsrAdmin := .F.
		self:cMsgError += "[ERROR].......... " + STR0017 + CRLF + CRLF + CRLF + CRLF	// "Usuário não possui privilégios de administrador do sistema."
		conout("[ERROR][SMARTSCHEDULE] " + STR0017)	// "Usuário não possui privilégios de administrador do sistema."
	else
		self:cMsgError += "[OK].......... " + STR0018 + CRLF + CRLF + CRLF + CRLF	// "Usuário com privilégios de administrador do sistema."
	endif

	if cLibVersion < cMinimumLibLabel
		self:lLibVersion := .F.
		self:cMsgError += "[ERROR].......... " + STR0012 + cMinimumLibLabel + CRLF + CRLF + CRLF + CRLF // "Necessário Lib Label igual ou superior a "
		conout("[ERROR][SMARTSCHEDULE] " + STR0012 + cMinimumLibLabel)	// "Necessário Lib Label igual ou superior a "
	else
		self:cMsgError += "[OK].......... " + STR0019 + cMinimumLibLabel + CRLF + CRLF + CRLF + CRLF // "LIB superior a versão "

		If totvs.framework.smartschedule.startSchedule.smartSchedIsEnabled() .And.; //smart schedule esta habilitado?
			totvs.framework.smartschedule.startSchedule.smartSchedIsRunning()    //smart schedule em execução?
			self:lSmartSched := .T.
		Endif 
	endif

return
