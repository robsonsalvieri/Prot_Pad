//includes
#include "protheus.ch"
#include "msobject.ch"
#include "backoffice.sv.est.costComparison.ch"
#include "totvs.framework.treports.integratedprovider.th"
//Grupo de perguntas  
#define SX1GRUPO "ESTT024"

//NAMESPACE
namespace totvs.protheus.backoffice.est.costComparison.integratedprovider
using namespace totvs.protheus.backoffice.est.smartView.integratedProvider
//ANNOTATION
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAEST", tables="SB2,SB1", customTables="SB1,SB2" ,name="Comparativo de Custos", country="ALL")

//-------------------------------------------------------------------
/*{Protheus.doc} costComparisonSmartViewBusinessObject
	Classe para criação do Objeto de Negócio do Comparativo de Custos
 	@author Rodrigo Lombardi
	@since 10/2023
	@version 1.0
*/
//-------------------------------------------------------------------  
Class costComparisonSmartViewBusinessObject From totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider

	Public Method new() as object
	Public Method getData() as object
	Public Method getCalc() as array
 
	Protected Method oNGetSchema()
	Protected data aFields			as array
	Protected data jItems			as json
	Protected data cWhere			as character
	Protected data lExistPergunte	as logical

EndClass
 
//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
 	@return object: self
 	@author BackOffice
	@since 10/2023
	@version 1.0
*/
//-------------------------------------------------------------------   
Method new() Class costComparisonSmartViewBusinessObject

	_Super:new()
	
	//Define a Área
	self:appendArea( STR0001 )//Estoque/Custos

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0002 )//Comparativo de Custos

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 )//Esta Objeto de Negócio ira trazer o Comparativo de Custos entre dois periodos especificados

	//Define o conjunto de perguntas e faz o teste se existe
	self:lExistPergunte := self:setPergunte( SX1GRUPO )
	If !self:lExistPergunte
		self:setErrorStatus(400,STR0004,i18n(STR0005,{SX1GRUPO}))//Grupo de pergunte não existe		
		FWLogMsg('WARN', , 'SmartView', , , , i18n(STR0005,{SX1GRUPO}), , , )//O Grupo de perguntas #1 não existe
	EndIf
	
	//Indica que o LookUp será do tipo padrão LookUp
	self:setIsLookUp(.T.)

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getData
	Retorna os dados do objeto de negócio
	@param nPage, numérico, indica a página atual do relatório
	@param oFilter, objeto, contém o filtro do TReports
	@return object: self:oData
	@author BackOffice
	@since 04/2023
	@version 1.0
*/
//-------------------------------------------------------------------   
Method getData( nPage as Numeric, oFilter as object) as object Class costComparisonSmartViewBusinessObject

	Local aInicial  as Array
	Local aFinal    as Array
	Local aCustom   as Array
	Local cQuery	as Character
	Local cFields	as Character
	Local cCustom	as Character
	Local cAlias	as Character
	Local cFiltro      as Character
	Local dDtIni	as Date
	Local dDtFim	as Date
	Local jParams	as Json	
	Local nMoeda    as Numeric	
	Local nX	    as Numeric	
	Local nVlrDif	as Numeric
	Local nFil      as Numeric
	Local oQuery    	

	//Valida o pergunte
	If !self:lExistPergunte
		return self:oData
	Endif

	jParams := oFilter:getParameters() //metodo para retorno do json dos parâmetros

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'])

	//Já realizo a correção das datas
	dDtIni := FwDateTimeToLocal(jParams['MV_PAR03'][1])[1]
	dDtFim := FwDateTimeToLocal(jParams['MV_PAR04'][1])[1]
	nMoeda := jParams['MV_PAR07'][1]
	cFiltro := " AND "
	//Se tiver custom
	cCustom := self:getSQLFields(.f.,nil,.t.)
	if !empty(cCustom)	
		aCustom := StrTokArr(cCustom,",")
		For nX := 1 to len(aCustom)
			aadd(self:aFields,aCustom[nX])		
		Next
	EndIf
	
	cFields := StrTran(ArrTokStr(self:aFields),"|",",")	
		
	cQuery := " SELECT ? "//1
	cQuery += " FROM " + RetSQLName("SB2") + " SB2 "
	cQuery += " INNER JOIN " + RetSQLName("SB1") + " SB1 ON B1_FILIAL = ? " //2
	cQuery += " AND SB1.B1_COD = SB2.B2_COD AND SB1.D_E_L_E_T_ = ? "//3
	cQuery += " WHERE SB2.B2_FILIAL = ? " //4
	cQuery += " AND SB2.B2_COD >= ? AND SB2.B2_COD <= ? "//5 //6
	cQuery += " AND SB2.B2_LOCAL >= ? AND SB2.B2_LOCAL <= ? "//7 //8
	cQuery += " AND SB2.D_E_L_E_T_ = ? "//9
		
	//Os filtros serão setados na interface do novo TReports
	If !(oFilter:hasFilter())
		cFiltro := " "  
	Endif 
	//Internacionalização
	cQuery += self:cWhere
	cQuery += " ? "//10
	cQuery := changeQuery(cQuery)
	oQuery := FwExecStatement():New(cQuery)				
	
	cBkpFil := cFilant 

	//Colocar while ou for de filiais aqui 
	For nFil :=1 to len(self:aFils)

		cFilAnt     := self:aFils[nFil]

		//Defino os bindings
		oQuery:setUnsafe(1,cFields)
		oQuery:SetString(2,FwXfilial("SB1"))
		oQuery:SetString(3,' ')
		oQuery:SetString(4,FwXfilial("SB2"))	
		oQuery:SetString(5,jParams['MV_PAR05'][1])	
		oQuery:SetString(6,jParams['MV_PAR06'][1])
		oQuery:SetString(7,jParams['MV_PAR01'][1])
		oQuery:SetString(8,jParams['MV_PAR02'][1])
		oQuery:SetString(9,' ')
		oQuery:SetUnsafe(10, cFiltro + oFilter:getSQLExpression())		
			
		cAlias := oQuery:OpenAlias()
		
		While !(cAlias)->(Eof())
			self:jItems := JsonObject():New()		

			For nX := 1 To Len(self:aFields)			
				if FWSX3Util():GetFieldType(self:aFields[nX]) == "D" //Campo tipo data tem um tratamento diferente para envio
					If !Empty( (cAlias)->&(self:aFields[nX]) )
						self:jItems[self:aFields[nX]] := totvs.framework.treports.date.dateToTimeStamp(StoD((cAlias)->&(self:aFields[nX])))
					EndIf
				Else
					self:jItems[self:aFields[nX]] := (cAlias)->&(self:aFields[nX])
				EndIf
			Next nX		
			
			//Saldo Inicial
			aInicial := self:getCalc((cAlias)->&("B1_COD"),(cAlias)->&("B2_LOCAL"),dDtIni,nMoeda)
			self:jItems["QtdInicial"] := aInicial[1]//Quantidade
			self:jItems["ValInicial"] := aInicial[2]//Unitario
			self:jItems["TotInicial"] := aInicial[3]//Total
			//Saldo Final
			aFinal := self:getCalc((cAlias)->&("B1_COD"),(cAlias)->&("B2_LOCAL"),dDtFim,nMoeda)
			self:jItems["QtdFinal"] := aFinal[1]//Quantidade
			self:jItems["ValFinal"] := aFinal[2]//Unitario
			self:jItems["TotFinal"] := aFinal[3]//Total
						
			//Porcentagem
			If !(aInicial[2] == 0)
				nVlrDif := (aFinal[2]-aInicial[2])
				if  nVlrDif < 0
					self:jItems["Variacao"] := ((abs(nVlrDif)/aInicial[2])*100)*-1
				else
					self:jItems["Variacao"] := ((abs(nVlrDif)/aInicial[2])*100)
				EndIf			
			else
				self:jItems["Variacao"] := 0
			Endif  					
			
			self:processData()
			self:oData:appendData(self:jItems)
		
			(cAlias)->(DBSkip())	
			
		EndDo 
				
		(cAlias)->(DBCloseArea())

	Next

	cFilant := cBkpFil

    oQuery:Destroy()
 	
return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} oNGetSchema
	Retorna a estrutura dos campos
	@return object: self:oSchema
	@author BackOffice
	@since 04/2023
	@version 1.0
*/
//-------------------------------------------------------------------   
Method oNGetSchema() Class costComparisonSmartViewBusinessObject

	Local aFldSB1 as Array
	Local aFldSB2 as Array
	self:aFields := {"B1_COD","B1_DESC","B1_TIPO","B1_UM","B2_LOCAL","B2_QATU","B2_FILIAL"}
	
	aFldSB1 := {"B1_COD","B1_DESC","B1_TIPO","B1_UM"}
	aFldSB2 := {"B2_LOCAL","B2_QATU","B2_FILIAL"}	

	self:AliasToSchema("SB1", aFldSB1)
	self:AliasToSchema("SB2", aFldSB2)
		
	//Custom
	self:addProperty("QtdInicial", STR0012, "number", STR0012,"QtdInicial")//"Quantidade Dt. Inicial"
	self:addProperty("ValInicial", STR0013, "number", STR0013,"ValInicial")//Valor Unit Dt. Inicial
	self:addProperty("TotInicial", STR0014, "number", STR0014,"TotInicial")//Total Dt. Inicial
	self:addProperty("QtdFinal", STR0015, "number", STR0015,"QtdFinal")//Quantidade Dt. Final	
	self:addProperty("ValFinal", STR0016, "number", STR0016,"ValFinal")//Valor Unit Dt. Final
	self:addProperty("TotFinal", STR0017, "number", STR0017,"TotFinal")//Total Dt. Final
	self:addProperty("Variacao", STR0018+"(%)", "number", STR0018+"(%)","Variacao")//Variação
	
Return self:oSchema


/*{Protheus.doc} getCalc
	Calcula e torna a quantidade, valor total e valor unitario de um determinado produto	
	@return array
	@author rodrigo.lombardi
	@since 10/2023
	@version 1.0
*/

Method getCalc( cProd as Character, cLocal as Character, dDta as date,nMoeda as numeric) as Array Class costComparisonSmartViewBusinessObject
Local aCalc 	as Array
Local nQtd		as Numeric
Local nUnit		as Numeric
Local nTotal	as Numeric

aCalc := CalcEst(cProd,cLocal,dDta)
nQtd   := aCalc[1]
nTotal := aCalc[nMoeda+1]
nUnit  := nTotal / nQtd

Return {nQtd,nUnit,nTotal} 
