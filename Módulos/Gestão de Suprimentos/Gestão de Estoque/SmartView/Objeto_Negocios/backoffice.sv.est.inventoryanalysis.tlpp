#include "msobject.ch"
#include "backoffice.sv.est.inventoryanalysis.ch"
#include "totvs.framework.treports.integratedprovider.th"

#DEFINE SX1GRUPO "MTR290"

namespace totvs.protheus.backoffice.est.inventoryanalysis.integratedprovider
using namespace totvs.protheus.backoffice.est.smartView.integratedProvider

@totvsFrameworkTReportsIntegratedProvider(active=.T.,team="SIGAEST",tables="SB1,SB2,SB3",name="Análise de Estoque",country="ALL",customTables="SB1,SB3")

class InventoryAnalysisSmartViewBusinessObject from totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider
    public method new() as object
    public method getData() as object

	Protected Method oNGetSchema()

    Protected data cAlias       as character
    Protected data cWhere       as character
    Protected data aFieldsSB1   as array
    Protected data aAllFields   as array
    Protected data jItens       as json
    Protected data lExistDic    as logical

endclass

/*/{Protheus.doc} New
Metodo de instancia da classe.
@type  Metodo
@author Squad Entradas
@since  Abril 19,2023
/*/
method new() class InventoryAnalysisSmartViewBusinessObject
    _Super:new()

    //Define a Área
    self:appendArea(STR0001) // Estoque/Custos
    
    //Define o nome do Objeto de Negócio
    self:setDisplayName(STR0002) // Relação para Análise do Estoque

    //Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 )//Demonstra a situação de cada item em relação ao seu saldo, empenho e entradas previstas

    //Indica o pergunte que será utilizado no relatório
    self:lExistDic := .T.
	If !self:setPergunte(SX1GRUPO)
		self:setErrorStatus(400,STR0014,i18n(STR0015,{SX1GRUPO}))//Grupo de pergunte não existe		
		FWLogMsg('WARN', , 'SmartView', , , , i18n(STR0015,{SX1GRUPO}), , , )//O Grupo de perguntas #1 não existe
		self:lExistDic := .F.
	EndIf

    //Indica que o LookUp será do tipo padrão LookUp
    self:setIsLookUp(.T.)

return self

/*/{Protheus.doc} getData
Metodo que retorna o Objeto de dados.
@type  Metodo
@author Squad Entradas
@since  Abril 19,2023
/*/
method getData(nPage as numeric, oFilter as object) as object class InventoryAnalysisSmartViewBusinessObject
    local oQuery   as object
    local jParams  as json
    local cLocDe   as character
    local cLocAte  as character
    local cQuery   as character
    local cCodProd as character
    local cFields  as character
    Local dDataRef as character
    local nEmpenho as numeric
    local nEmin    as numeric
    local nSCPro   as numeric
    local nPCPro   as numeric
    local nPVPro   as numeric
    local nOPPro   as numeric
    local nSaldo   as numeric
    Local nEstMes  as numeric
    local nConsOP  as numeric
    local nDbPar   as numeric
    local nX       as numeric
    local nFil     as numeric
    local lConsRes as logical
    local lTesAtuEst as logical    
    local nDecs    := TamSX3("C2_QUANT")[2] as numeric
    local lPerdInf := GetMV('MV_PERDINF',.F.,.F.) as logical
    local lVeic    := GetMV("MV_VEICULO") == "S" as logical
    local cLocProc := GetMV("MV_LOCPROC") as character
    local cPicSB2  := X3Picture("B2_QATU") as character
    local aCustom  := {} as Array
    local cCustom as character
    Local cFiltro as character
    Local cFilterParam as character

    private _oStatSC1 as object
    private _oStatSC2 as object
    private _oStatSC9 as object
    private _oStatSC6 as object
    private _oStatSC7 as object

    private cCurFil as character

    If !self:lExistDic
	   Return self:oData 
	EndIf 

    //Metodo para retorno do json dos parâmetros
    jParams := oFilter:getParameters()

    //Metodo para retorno do filtro em expressão SQL
    cFilterParam := oFilter:getSQLExpression()

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'])

    nConsOP    := jParams['MV_PAR16'][1]
    lTesAtuEst := jParams['MV_PAR14'][1] == 1
    lConsRes   := jParams['MV_PAR19'][1] == 2
    cLocDe     := jParams['MV_PAR17'][1]
    cLocAte    := jParams['MV_PAR18'][1]
    dDataRef   := FwDateTimeToLocal(jParams['MV_PAR12'][1])[1]
    cFiltro    := " AND "    
    self:cAlias := GetNextAlias()

    //Campos que farão parte do select da query
    cFields := self:getSQLFields(.F.)
    cFields += ", B1_EMIN, B1_LE, B1_PE, MAX(B2_LOCAL) B2_LOCAL, SUM(B2_QATU) B2_QATU, SUM(B2_QEMP) B2_QEMP, SUM(B2_QEMPPRE) B2_QEMPPRE, "
    cFields += "SUM(B2_QEMPPRJ) B2_QEMPPRJ, SUM(B2_RESERVA) B2_RESERVA, SUM(B2_QEMPSA) B2_QEMPSA, MAX(B2_USAI) B2_USAI "

    //Montagem da Query
    cQuery := "SELECT ? "
    cQuery += "FROM " + RetSqlName("SB1") + " SB1 "
    cQuery += "LEFT JOIN " + RetSqlName("SB3") + " SB3 "
    cQuery += "ON SB3.B3_FILIAL = ? AND "
    cQuery += "SB3.B3_COD = SB1.B1_COD "
    cQuery += "AND SB3.D_E_L_E_T_ = ? "
    cQuery += "LEFT JOIN " + RetSqlName("SB2") + " SB2 "
    cQuery += "ON SB2.B2_FILIAL = ? AND "
    cQuery += "SB2.B2_COD = SB1.B1_COD AND "
    cQuery += "SB2.B2_LOCAL >= ? AND "
    cQuery += "SB2.B2_LOCAL <= ? AND "
    If jParams['MV_PAR13'][1] == 2
        cQuery += "SB2.B2_LOCAL <> ? AND "
    EndIf
    cQuery += "SB2.D_E_L_E_T_ = ? "

    //Montagem do Where da Query
    cQuery += "WHERE SB1.B1_FILIAL = ? AND "
    cQuery += "SB1.B1_GRUPO >= ? AND "
    cQuery += "SB1.B1_GRUPO <= ? AND "
    If lVeic
        cQuery += "SB1.B1_CODITE >= ? AND "
        cQuery += "SB1.B1_CODITE <= ? AND "
    Else
        cQuery += "SB1.B1_COD >= ? AND "
        cQuery += "SB1.B1_COD <= ? AND "
    Endif
    cQuery += "SB1.B1_TIPO >= ? AND "
    cQuery += "SB1.B1_TIPO <= ? AND "
    cQuery += "SB1.B1_DESC >= ? AND "
    cQuery += "SB1.B1_DESC <= ? AND "
    cQuery += "SB1.D_E_L_E_T_ = ? "
    //Os filtros serão setados na interface do novo SmartView
	If !(oFilter:hasFilter())
		cFiltro := " "  
	Endif 
	cQuery += self:cWhere
	cQuery += " ? "//19

    // Montagem do order by da query
    cQuery += " GROUP BY B1_FILIAL, B1_COD, B1_LOCPAD, B1_CODITE, B1_DESC, B1_TIPO, B1_GRUPO, B1_UM, B1_EMIN, B1_LE, B1_PE, B3_MEDIA, B3_CLASSE"
    cQuery := ChangeQuery(cQuery)

    // Caso tenha campo customizado preciso adicionar no Group By
    If Len(self:getCustomFields()) > 0 
        For nX = 1 to len(self:getCustomFields())
            AAdd(aCustom,self:getCustomFields()[nX][1])
        next nX
        cCustom :="," + ArrTokStr(aCustom,",")
    EndIf
    cQuery += cCustom 

    oQuery := FwExecStatement():New(cQuery)

	//Colocar while ou for de filiais aqui
	For nFil :=1 to len(self:aFils)
		cCurFil := self:aFils[nFil]
        nDbPar  := 1

        oQuery:SetUnsafe(nDbPar++, cFields)
        oQuery:SetString(nDbPar++, FWxFilial('SB3', cCurFil))
        oQuery:SetString(nDbPar++, " ")
        oQuery:SetString(nDbPar++, FWxFilial('SB2', cCurFil))
        oQuery:SetString(nDbPar++, cLocDe)
        oQuery:SetString(nDbPar++, cLocAte)
        If jParams['MV_PAR13'][1] == 2
            oQuery:SetString(nDbPar++, cLocProc)
        EndIf
        oQuery:SetString(nDbPar++, " ")
        oQuery:SetString(nDbPar++, FWxFilial('SB1', cCurFil))
        oQuery:SetString(nDbPar++, jParams['MV_PAR05'][1])
        oQuery:SetString(nDbPar++, jParams['MV_PAR06'][1])
        oQuery:SetString(nDbPar++, jParams['MV_PAR01'][1])
        oQuery:SetString(nDbPar++, jParams['MV_PAR02'][1])
        oQuery:SetString(nDbPar++, jParams['MV_PAR03'][1])
        oQuery:SetString(nDbPar++, jParams['MV_PAR04'][1])
        oQuery:SetString(nDbPar++, jParams['MV_PAR07'][1])
        oQuery:SetString(nDbPar++, jParams['MV_PAR08'][1])
        oQuery:SetString(nDbPar++, " ")
        oQuery:SetUnsafe(nDbPar++, cFiltro + cFilterParam)

        oQuery:OpenAlias(self:cAlias)

        (self:cAlias)->( DBGoTop() )
        Do While !(self:cAlias)->(Eof())
            cCodProd := (self:cAlias)->B1_COD
            nEstMes  := 0

            If Empty((self:cAlias)->B2_LOCAL)
                If jParams['MV_PAR09'][1] == 2 .And. jParams['MV_PAR11'][1] == 2
                    (self:cAlias)->( dbSkip() )
                    Loop
                EndIf

                If !(self:cAlias)->B1_LOCPAD >= jParams['MV_PAR17'][1] .And. (self:cAlias)->B1_LOCPAD <= jParams['MV_PAR18'][1]
                    (self:cAlias)->( dbSkip() )
                    Loop
                EndIf
            EndIf

            If jParams['MV_PAR11'][1] == 1
                If !Empty((self:cAlias)->B2_LOCAL) .And. ((Empty((self:cAlias)->B2_USAI) .Or. (self:cAlias)->B2_USAI > DTOS(dDataRef)))
                    (self:cAlias)->( dbSkip() )
                    Loop
                EndIf
            EndIf

            //Calcula o empenho do Produto
            nEmpenho := calcEmp(nConsOP,(self:cAlias)->B2_QEMP,(self:cAlias)->B2_QEMPPRE,jParams['MV_PAR20'][1] == 1,(self:cAlias)->B2_QEMPPRJ,(self:cAlias)->B2_RESERVA,(self:cAlias)->B2_QEMPSA)        
            //Calcula o saldo das SC's
            nSCPro   := calcSC1(cCodProd,nConsOP,cLocDe,cLocAte)
            //Calcula o saldo das ordens de produções colocadas
            nOPPro   := calcSC2(cCodProd,cLocDe,cLocAte,nConsOP,lPerdInf,nDecs)
            //Calcula o saldo dos pedidos de venda liberados
            calcSC9()
            //Calcula o saldo dos pedidos de venda
            nPVPro   := calcSC6(cCodProd,cLocDe,cLocAte,lTesAtuEst,lConsRes)
            //Calcula o saldo dos pedidos de compra
            nPCPro   := calcSC7(cCodProd,cLocDe,cLocAte,nConsOP)
        
            //Calcula o saldo do produto
            nSaldo := (self:cAlias)->B2_QATU

            If jParams['MV_PAR10'][1] == 1
                nSaldo -= nEmpenho
            EndIf

            If jParams['MV_PAR09'][1] == 2
                nSaldo := nSaldo + nSCPro + nPCPro + nOPPro
                nEmin  := RetFldProd(cCodProd,"B1_EMIN",self:cAlias)
                If nSaldo > nEmin .Or. (nEmin == 0 .And. nSaldo == 0)
                    (self:cAlias)->( dbSkip() )
                    Loop
                EndIf
            EndIf

            If jParams['MV_PAR15'][1] == 2 .And. nSaldo == 0
                (self:cAlias)->( dbSkip() )
                Loop
            EndIf

            If (self:cAlias)->B3_MEDIA > 0
                nEstMes := nSaldo / (self:cAlias)->B3_MEDIA
            EndIf

            self:jItens := JsonObject():New()

            For nX := 1 To Len(self:aAllFields)
                if FWSX3Util():GetFieldType(self:aAllFields[nX]:getName()) == "D" //Campo tipo data tem um tratamento diferente para envio
                    If !Empty( (self:cAlias)->&(self:aAllFields[nX]:GetName()) )
                        self:jItens[self:aAllFields[nX]:getName()] := totvs.framework.treports.date.dateToTimeStamp(StoD((self:cAlias)->&(self:aAllFields[nX]:getRealName())))
                    EndIf
                Else
                    self:jItens[self:aAllFields[nX]:getName()]  := (self:cAlias)->&(self:aAllFields[nX]:getRealName())
                EndIf            			
            Next nX

            self:jItens["CODEMP"]     := cEmpAnt
            self:jItens["DESCEMP"]    := FWGrpName()
            self:jItens["FILIAL"]     := cCurFil
            self:jItens["DESCFIL"]    := FwFilialName(cEmpAnt,cCurFil)
            self:jItens["SALDOATUAL"] := nSaldo
            self:jItens["EMPENHO"]    := nEmpenho
            self:jItens["SCCOLOCADA"] := nSCPro
            self:jItens["PCCOLOCADO"] := nPCPro
            self:jItens["OPCOLOCADO"] := nOPPro
            self:jItens["PVCOLOCADO"] := nPVPro
            self:jItens["B1_EMIN"]    := RetFldProd(cCodProd,"B1_EMIN",self:cAlias)
            self:jItens["B1_LE"]      := RetFldProd(cCodProd,"B1_LE",self:cAlias)
            self:jItens["B1_PE"]      := RetFldProd(cCodProd,"B1_PE",self:cAlias)
            If !Empty((self:cAlias)->B2_USAI)
                self:jItens["DTULTSAI"] := totvs.framework.treports.date.dateToTimeStamp(StoD((self:cAlias)->B2_USAI))
            EndIf
            self:jItens["ESTMES"]     := nEstMes    
            
            self:processData()
            self:oData:appendData(self:jItens)

            (self:cAlias)->( dbSkip() )
        EndDo
    Next

    (self:cAlias)->( DBCloseArea() )
 
    oQuery:Destroy()
    If _oStatSC1 <> NIL
        _oStatSC1:Destroy()
    EndIf
    If _oStatSC2 <> NIL
        _oStatSC2:Destroy()
    EndIf
    If _oStatSC9 <> NIL
        _oStatSC9:Destroy()
    EndIf
    If _oStatSC6 <> NIL
        _oStatSC6:Destroy()
    EndIf
    If _oStatSC7 <> NIL
        _oStatSC7:Destroy()
    EndIf

return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} oNGetSchema
    Metodo que retorna a Estrutura de dados.
    @type  Metodo
    @author Squad Entradas
	@since 09/2024
	@version 1.0
*/
//-------------------------------------------------------------------   
Method oNGetSchema() Class InventoryAnalysisSmartViewBusinessObject
    local aFieldsSB1 as array
    local aFieldsSB3 as array

    aFieldsSB1 := {"B1_COD","B1_LOCPAD","B1_CODITE","B1_DESC","B1_TIPO","B1_GRUPO","B1_UM"}
    aFieldsSB3 := {"B3_MEDIA","B3_CLASSE"}

    self:AliasToSchema("SB1",aFieldsSB1)
    self:AliasToSchema("SB3",aFieldsSB3)

    self:aAllFields := self:getStructFields()

    self:addProperty("CODEMP"    , STR0016, "string", STR0016, "CODEMP")//Empresa
    self:addProperty("DESCEMP"   , STR0017, "string", STR0017, "DESCEMP")//Desc.Empresa
    self:addProperty("FILIAL"    , STR0018, "string", STR0018, "FILIAL")//Filial
    self:addProperty("DESCFIL"   , STR0019, "string", STR0019, "DESCFIL")//Desc.Filial
    self:addProperty("EMPENHO"   , STR0006, "number", STR0006, "EMPENHO")//Empenho
    self:addProperty("SCCOLOCADA", STR0007, "number", STR0007, "SCCOLOCADA")//SCs Colocadas
    self:addProperty("PCCOLOCADO", STR0008, "number", STR0008, "PCCOLOCADO")//PCs Colocados
    self:addProperty("OPCOLOCADO", STR0009, "number", STR0009, "OPCOLOCADO")//OPs Colocados
    self:addProperty("PVCOLOCADO", STR0010, "number", STR0010, "PVCOLOCADO")//PVs Colocados
    self:addProperty("SALDOATUAL", STR0011, "number", STR0011, "SALDOATUAL")//Saldo Atual
    self:addProperty("DTULTSAI"  , STR0012, "date"  , STR0012, "DTULTSAI")//DT.Ult.Saida
    self:addProperty("ESTMES"    , STR0013, "number", STR0013, "ESTMES")// Estoque em Meses

return

/*/{Protheus.doc} calcSC1
Calcula o saldo das solicitações de compra
@type  Função
@author Squad Entradas
@since  Abril 28,2023
/*/
Static Function calcSC1(cProduto as character,nTpop as numeric,cLocDe as character,cLocAte as character)
    local cQuery as character
    local cAliasSC1 := GetNextAlias() as character
    local nSCPro as numeric
    Local aTpop as array
    local nSetPar := 6 as numeric
    // Query responsável por retornar as solicitações de compras da SC1
    If _oStatSC1 == NIL
        cQuery := "SELECT SUM(C1_QUANT) QUANT, SUM(C1_QUJE) QUJE "
        cQuery += "FROM " +RetSQLName("SC1")+ " SC1 "
        cQuery += "WHERE SC1.C1_FILIAL = ? "
        cQuery += "AND SC1.C1_PRODUTO = ? "
        cQuery += "AND SC1.C1_LOCAL >= ? "
        cQuery += "AND SC1.C1_LOCAL <= ? "
        cQuery += "AND SC1.C1_RESIDUO <> ? "
        cQuery += "AND SC1.C1_QUJE < SC1.C1_QUANT "
        If nTpop == 1 .Or. nTpop == 2
            cQuery += "AND SC1.C1_TPOP IN (?) "
        EndIf
        cQuery += "AND SC1.D_E_L_E_T_ = ? "
        cQuery := ChangeQuery(cQuery)

        _oStatSC1 := FwExecStatement():New(cQuery)
    EndIf

    If nTpop == 1
        aTpop := {'F',' '}
    ElseIf nTpop == 2
        aTpop := {'P'}
    EndIf

    _oStatSC1:SetString(1, FWXFilial("SC1", cCurFil))
    _oStatSC1:SetString(2, cProduto)
    _oStatSC1:SetString(3, cLocDe)
    _oStatSC1:SetString(4, cLocAte)
    _oStatSC1:SetString(5, "S")
    If nTpop == 1 .Or. nTpop == 2
        _oStatSC1:SetIn(6, aTpop)
        nSetPar := 7
    EndIf
    _oStatSC1:SetString(nSetPar, " ")

    _oStatSC1:OpenAlias(cAliasSC1)

    If (cAliasSC1)->(!Eof())
	    nSCPro := ((cAliasSC1)->QUANT - (cAliasSC1)->QUJE)
    EndIf

	(cAliasSC1)->(dbCloseArea())

    FwFreeArray(aTpop)

Return nSCPro

/*/{Protheus.doc} calcEmp
Calcula o empenho do produto
@type  Função
@author Squad Entradas
@since  Abril 28,2023
/*/
Static Function calcEmp(nConsOP as numeric,nEmpFirme as numeric, nEmpPre as numeric,lConsProj as logical,nEmpPrj as numeric,nReserva as numeric, nQEmpSa as numeric)
    local nEmpenho as numeric

    If nConsOP == 1
        nEmpenho := nEmpFirme
    Elseif nConsOP == 2
        nEmpenho := nEmpPre
    Else
        nEmpenho := nEmpFirme + nEmpPre
    EndIf

    If lConsProj
        nEmpenho += nEmpPrj
    EndIf

    nEmpenho += nReserva + nQEmpSa

Return nEmpenho

/*/{Protheus.doc} calcSC2
Calcula o saldo das ordens de produções
@type  Função
@author Squad Entradas
@since  Abril 28,2023
/*/
Static Function calcSC2(cProduto as character,cLocDe as character,cLocAte as character,nConsOP as numeric,lPerdInf as logical,nDecs as numeric)
    local cAliasSC2 := GetNextAlias() as character
    local cQuery as character
    local nOPPro as numeric
    local nSalOP as numeric
    Local aConsOP as array
    local nSetPar := 6 as numeric
    If _oStatSC2 == NIL
        cQuery := "SELECT C2_QUANT, C2_QUJE, C2_PERDA "
        cQuery += "FROM " + RetSQLName("SC2") + " SC2 "
        cQuery += "WHERE SC2.C2_FILIAL = ? AND "
        cQuery += "SC2.C2_PRODUTO = ? AND "
        cQuery += "SC2.C2_DATRF = ? AND "
        cQuery += "SC2.C2_LOCAL >= ? AND "
        cQuery += "SC2.C2_LOCAL <= ? "
        If nConsOP == 1 .Or. nConsOP == 2
            cQuery += "AND SC2.C2_TPOP IN (?) "
        EndIf
        cQuery += "AND SC2.D_E_L_E_T_ = ? "
        cQuery := ChangeQuery(cQuery)
        
        _oStatSC2 := FwExecStatement():New(cQuery)
    EndIf

    If nConsOP == 1
        aConsOP := {'F',' '}
    Elseif nConsOP == 2
        aConsOP := {'P'}
    EndIf

    _oStatSC2:SetString(1, FwXfilial("SC2", cCurFil))
    _oStatSC2:SetString(2, cProduto)
    _oStatSC2:SetString(3, " ")
    _oStatSC2:SetString(4, cLocDe)
    _oStatSC2:SetString(5, cLocAte)
    If nConsOP == 1 .Or. nConsOP == 2
        _oStatSC2:SetIn(6, aConsOP)
        nSetPar := 7
    EndIf
    _oStatSC2:SetString(nSetPar, " ")

    _oStatSC2:OpenAlias(cAliasSC2)

    Do While (cAliasSC2)->(!Eof())
        nSalOP := Max(0,NoRound((cAliasSC2)->C2_QUANT - (cAliasSC2)->C2_QUJE - If(lPerdInf,0,(cAliasSC2)->C2_PERDA), nDecs))
        If nSalOP > 0
            nOPPro += nSalOP
        EndIf
        (cAliasSC2)->(DbSkip())
    EndDo

    (cAliasSC2)->(dbCloseArea())

    FwFreeArray(aConsOP)

Return nOPPro

/*/{Protheus.doc} calcSC9
Calcula o saldo das reservas de pedido de venda
@type  Função
@author Squad Entradas
@since  Abril 28,2023
/*/
Static Function calcSC9()
    local cQuery as character

    If _oStatSC9 == NIL
        cQuery := "SELECT SUM(SC9.C9_QTDLIB) C9_QTDLIB "
        cQuery += "FROM " +RetSQLName("SC9")+ " SC9 "
        cQuery += "WHERE SC9.C9_FILIAL = ? "//1
        cQuery += "AND SC9.C9_PEDIDO = ? "//2
        cQuery += "AND SC9.C9_ITEM = ? "//3
        cQuery += "AND SC9.C9_PRODUTO = ? "//4
        cQuery += "AND SC9.C9_LOCAL = ? "//5
        cQuery += "AND (SC9.C9_BLEST = ? "//6
        cQuery += "OR ( SC9.C9_BLEST = ? "//7
        cQuery += "AND SC9.C9_BLCRED = ? )) "//8
        cQuery += "AND SC9.D_E_L_E_T_ = ? "//9
        cQuery := ChangeQuery(cQuery)

        _oStatSC9 := FwExecStatement():New(cQuery)
    EndIf

Return _oStatSC9

/*/{Protheus.doc} calcSC6
Calcula o saldo dos pedidos de venda
@type  Função
@author Squad Entradas
@since  Abril 28,2023
/*/
Static Function calcSC6(cProduto as character,cLocDe as character,cLocAte as character, lTesAtuEst as logical, lConsRes as logical)
    local cQuery     as character
    local nPVPro     as numeric
    local nC9_QTDLIB as numeric
    local cAliasSC6 := GetNextAlias() as character
    Local aTesAtuEst := {" "," "," "," "," "} as Array
    local nSetPar := 10 as numeric
    If _oStatSC6 == NIL
        cQuery := "SELECT C6_NUM, C6_ITEM, C6_LOCAL, C6_QTDVEN QTDVEN "
        cQuery += "FROM " +RetSqlName("SC6")+ " SC6 "
    
        If lTesAtuEst
            aTesAtuEst[1] := "INNER JOIN " +RetSqlName("SF4")+ " SF4 "
            aTesAtuEst[2] := "ON SF4.F4_FILIAL = '"+FwXFilial("SF4", cCurFil)+"' "
            aTesAtuEst[3] := "AND SF4.F4_CODIGO = SC6.C6_TES "
            aTesAtuEst[4] := "AND SF4.F4_ESTOQUE = 'S' "
            aTesAtuEst[5] := "AND SF4.D_E_L_E_T_ = ' ' "
        EndIf
        cQuery += " ? ? ? ? ? "
        cQuery += "WHERE SC6.C6_FILIAL = ? "
        cQuery += "AND SC6.C6_PRODUTO = ? "
        cQuery += "AND SC6.C6_LOCAL >= ? "
        cQuery += "AND SC6.C6_LOCAL <= ? "

        If lConsRes
            cQuery += "AND SC6.C6_BLQ <> ? "
        EndIf
        cQuery += "AND SC6.D_E_L_E_T_ = ? "
        cQuery := ChangeQuery(cQuery)

        _oStatSC6 := FwExecStatement():New(cQuery)
    EndIf

    _oStatSC6:SetUnsafe(1, aTesAtuEst[1] )//1
    _oStatSC6:SetUnsafe(2, aTesAtuEst[2] )
    _oStatSC6:SetUnsafe(3, aTesAtuEst[3] )
    _oStatSC6:SetUnsafe(4, aTesAtuEst[4] )
    _oStatSC6:SetUnsafe(5, aTesAtuEst[5] )
    _oStatSC6:SetString(6, FwXFilial("SC6", cCurFil))
    _oStatSC6:SetString(7, cProduto)
    _oStatSC6:SetString(8, cLocDe)
    _oStatSC6:SetString(9, cLocAte)
    If lConsRes
        _oStatSC6:SetString(10, 'R')
        nSetPar := 11
    EndIf
    _oStatSC6:SetString(nSetPar, " ")

    _oStatSC6:OpenAlias(cAliasSC6)

    Do While (cAliasSC6)->(!Eof())
	    nPVPro += (cAliasSC6)->QTDVEN

        _oStatSC9:SetString(1, FwXFilial("SC9", cCurFil))
        _oStatSC9:SetString(2, (cAliasSC6)->C6_NUM)
        _oStatSC9:SetString(3, (cAliasSC6)->C6_ITEM)
        _oStatSC9:SetString(4, cProduto)
        _oStatSC9:SetString(5, (cAliasSC6)->C6_LOCAL)
        _oStatSC9:SetString(6, "10")
        _oStatSC9:SetString(7, space(len(SC9->C9_BLEST)))
        _oStatSC9:SetString(8, space(len(SC9->C9_BLCRED)))
        _oStatSC9:SetString(9, " ")        

        nC9_QTDLIB := _oStatSC9:ExecScalar("C9_QTDLIB")

        nPvPro -= nC9_QTDLIB
        nPVPro := Max(0,nPVPro)

        (cAliasSC6)->(DbSkip())
    EndDo

	(cAliasSC6)->(dbCloseArea())

Return nPVPro

/*/{Protheus.doc} calcSC7
Calcula o saldo dos pedidos de compra
@type  Função
@author Squad Entradas
@since  Abril 28,2023
/*/
Static Function calcSC7(cCod as character,cLocDe as character,cLocAte as character,nConsOP as numeric)
    local cQuery as character
    local nPCPro as numeric
    local cAliasSC7 := GetNextAlias() as character
    Local aConsOP as array
    local nSetPar := 7 as numeric
    If _oStatSC7 == NIL
        cQuery := "SELECT SUM(C7_QUANT) QUANT, SUM(C7_QUJE) QUJE "
        cQuery += "FROM " +RetSQLName("SC7")+ " SC7 "
        cQuery += "WHERE SC7.C7_FILIAL = ? "
        cQuery += "AND SC7.C7_PRODUTO = ? "
        cQuery += "AND SC7.C7_LOCAL >= ? "
        cQuery += "AND SC7.C7_LOCAL <= ? "
        cQuery += "AND SC7.C7_RESIDUO = ? "
        cQuery += "AND (SC7.C7_QUANT-SC7.C7_QUJE) > ? "
        If nConsOP == 1 .Or. nConsOP == 2
            cQuery += "AND SC7.C7_TPOP IN (?) " //7
        EndIf
        cQuery += "AND SC7.D_E_L_E_T_ = ? "//8
        cQuery := ChangeQuery(cQuery)
        
        _oStatSC7 := FwExecStatement():New(cQuery)
    EndIf

    If nConsOP == 1
        aConsOP := {'F',' '}
    Elseif nConsOP == 2
        aConsOP := {'P'}
    EndIf

    _oStatSC7:SetString(1, FwXFilial("SC7", cCurFil))
    _oStatSC7:SetString(2, cCod)
    _oStatSC7:SetString(3, cLocDe)
    _oStatSC7:SetString(4, cLocAte)
    _oStatSC7:SetString(5, space(len(SC7->C7_RESIDUO)))
    _oStatSC7:SetNumeric(6, 0)
    If nConsOP == 1 .Or. nConsOP == 2
        _oStatSC7:SetIn(7, aConsOP)
        nSetPar := 8
    EndIf
    _oStatSC7:SetString(nSetPar, " ")

    _oStatSC7:OpenAlias(cAliasSC7)

    If (cAliasSC7)->(!Eof())
        nPCPro := ((cAliasSC7)->QUANT-(cAliasSC7)->QUJE)
    EndIf

    (cAliasSC7)->(DbCloseArea())

    FwFreeArray(aConsOP)

Return nPCPro
