#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#INCLUDE "backoffice.sv.est.relxstdconsumption.ch"

#DEFINE SX1GRUPO "ESTT029"

using namespace totvs.protheus.backoffice.est.smartView.integratedProvider
namespace totvs.protheus.backoffice.est.relxstdconsumption.integratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAEST", tables="SB1,SD3",name="Consumo Real x Standard", country="ALL",customTables="SB1,SD3")

//-------------------------------------------------------------------
/*{Protheus.doc} RelxStdConsumptionSmartViewBusinessObject  
Classe para criação do Objeto de Negócio do Consumo Real x Standard 
 
@author BackOffice
@since 09/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Class RelxStdConsumptionSmartViewBusinessObject From totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider

	Public Method new() as object
    Public method getDescription() as character
	Public Method getData() as object
 
 	Protected Method oNGetSchema()
	Protected data jItens		as json
	Protected data cWhere		as character
    Protected data cAlias   	as character
	Protected data aFields      as array
	Protected data aAllFields   as array
	Protected data lExistDic    as logical

EndClass
 
//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
 
@return object: self
@author BackOffice
@since 09/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method new() Class RelxStdConsumptionSmartViewBusinessObject

	_Super:new()
	
	//Define a Área
	self:appendArea( STR0001 ) //"Estoque/Custos"

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0002 ) // "Consumo Real x Standard"

    //Indica o pergunte que será utilizado no relatório
    self:setPergunte(SX1GRUPO)

	//Indica o pergunte que será utilizado no relatório
    self:lExistDic := .T.
	If !self:setPergunte(SX1GRUPO)
		self:setErrorStatus(400,STR0017,i18n(STR0018,{SX1GRUPO}))//Grupo de pergunte não existe		
		FWLogMsg('WARN', , 'SmartView', , , , i18n(STR0018,{SX1GRUPO}), , , )//O Grupo de perguntas #1 não existe
		self:lExistDic := .F.
	EndIf

Return self

/*/{Protheus.doc} getDescription
Metodo que retorna a descrição do objeto de negócio.
@type  Metodo
@author Squad Entradas
@since  Maio 15,2023
/*/
method getDescription() as character class RelxStdConsumptionSmartViewBusinessObject
return ( STR0003 ) // Consumo Real x Standard

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio
 
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do TReports
 
@return object: self:oData
 
@author BackOffice
@since 09/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method getData( nPage as Numeric, oFilter as object) as object Class RelxStdConsumptionSmartViewBusinessObject
    local oQuery        as object
    local oQrySG1       as object
    local oQrySG1Trt    as object
    local oQrySD3       as object
    local oLstTrb1J := JsonObject():New() as json
    local oExplEstr := JsonObject():New() as json
	local jParams		as json
    local aAreaSG1  := {} as array
    local aRetSD3   := {} as array
    local aRecnoD4  := {} as array
	local nX			as numeric
	local nI			as numeric
	local nCountRec		as numeric
    local nPosTrb1      as numeric
    local nPosTrb2      as numeric
    local nQuantG1      as numeric
    local nRecno        as numeric
    local nQtdBase      as numeric
	local cQuery		as character
    local cQrySG1       as character
    local cKeyScan      as character
    local cProduto      as character
    local cAliasOpc     as character
    local cChvExEst     as character
    local cTipoDec      as character
    local cOpAnt        as character
	local cDataBase     as character
	local cFields		as character
	local cAliasSG1	 	as character
	local cFilSBZ    	:= FWxFilial("SBZ") as character
	local cFilSB1	 	:= FWxFilial("SB1") as character
    local cFilSG1    	:= FWxFilial("SG1") as character
    local cMVARQPROD 	:= GetMV("MV_ARQPROD",.F.,"SB1") as character
    local lContinua  	as logical
    local lOpConf    	as logical
	local dDataDe		as date
	local dDataAte		as date
	local nFil          as numeric 
	Local cCustom       as character
	Local aCustom       as Array

	private oQryretTRT  as object 
	private nTamDecQtd := TamSX3("D3_QUANT")[2]
	private nTamDecCus := TamSX3("D3_CUSTO1")[2]
	private aLstTrb1   := {}
	private aLstTrb2   := {}

	If !self:lExistDic
	   Return self:oData 
	EndIf 

	jParams 		:= oFilter:getParameters() //metodo para retorno do json dos parâmetros
	
    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'])

	cAliasSG1	 	:= "SG1MATR450"
    self:cAlias 	:= GetNextAlias()
	self:aAllFields := estGetCpo(self:getArrayFields())

	//Inicializa as variáveis utilizadas no processamento
	aCustom    := {}
	cCustom    := ""
    dDataDe    := FwDateTimeToLocal( jParams[ 'MV_PAR05' ][1] ) [1]
	dDataAte   := FwDateTimeToLocal( jParams[ 'MV_PAR06' ][1] ) [1]
	cDataBase  := DtoS(dDataBase)

	cFields  := self:getSQLFields(.T.)
	cFields  += ",SD3.D3_FILIAL,SD3.D3_COD,SD3.D3_UM,SD3.D3_CF,SD3.D3_QUANT,SD3.D3_OP,SD3.D3_NUMSEQ,"
	cFields  += "SD3.D3_CHAVE,SD3.D3_EMISSAO,SD3.D3_TRT,SD3.D3_ESTORNO,SD3.D3_CUSTO1,SD3.D3_CUSTO2,"
	cFields  += "SD3.D3_PARCTOT,SD3.D3_CUSTO3,SD3.D3_CUSTO4,SD3.D3_CUSTO5,SD3.R_E_C_N_O_ D3REC "

    cQuery := "SELECT ? " // 1
    cQuery += "FROM " + RetSqlName("SD3") + " SD3 "
	cQuery += "INNER JOIN " + RetSqlName("SB1") + " SB1 ON "
	cQuery += "SB1.B1_FILIAL = ? AND " // 2 
    cQuery += "SB1.B1_COD = SD3.D3_COD AND "
    cQuery += "SB1.D_E_L_E_T_ = ? "  // 3
    cQuery += "WHERE SD3.D3_FILIAL = ? AND "  // 4 
	cQuery += "SD3.D3_OP >= ? AND "   // 5
	cQuery += "SD3.D3_OP <= ? AND "   // 6
    cQuery += "SD3.D3_OP <> ? AND "   // 7
	cQuery += "SD3.D3_COD >= ? AND "  // 8
	cQuery += "SD3.D3_COD <= ? AND "  // 9
	cQuery += "SD3.D3_EMISSAO >= ? AND "  // 10
	cQuery += "SD3.D3_EMISSAO <= ? AND "  // 11
	cQuery += "( SD3.D3_CF <> ? AND "   // 12
	cQuery += "  SD3.D3_CF <> ? ) "   // 13 
	cQuery += " AND SD3.D3_ESTORNO <> ? "    // 14
    cQuery += " AND SD3.D_E_L_E_T_ = ? " //15

    //Os filtros serão setados na interface do novo Smart View
    If oFilter:hasFilter()
        cQuery += " AND " + oFilter:getSQLExpression()
    Endif

    If !Empty(self:cWhere)
   		cQuery += self:cWhere
	EndIf

    cQuery += " ORDER BY D3_FILIAL, D3_EMISSAO, D3_NUMSEQ, D3_CHAVE, D3_COD"
	cQuery := ChangeQuery(cQuery)
	oQuery := FwExecStatement():New(cQuery)

	cBkpFil := cFilant 

	//Colocar while ou for de filiais aqui 
	For nFil :=1 to len(self:aFils)
	
	  	aLstTrb1    := {}
        aLstTrb2    := {}
        cKeyScan    := ""
        cProduto    := ""

		cFilAnt     := self:aFils[nFil]
		cFilSBZ    	:= FWxFilial("SBZ")
		cFilSB1	 	:= FWxFilial("SB1")
		cFilSG1    	:= FWxFilial("SG1")

		oQuery:SetUnsafe(1, cFields)
		oQuery:SetString(2, cFilSB1)
		oQuery:SetString(3,' ')
		oQuery:SetString(4, FWxFilial('SD3'))
		oQuery:SetString(5, jParams["MV_PAR03"][1])
		oQuery:SetString(6, jParams["MV_PAR04"][1])
		oQuery:SetString(7,' ')
		oQuery:SetString(8, jParams["MV_PAR01"][1])
		oQuery:SetString(9, jParams["MV_PAR02"][1])
		oQuery:SetString(10, DtoS(dDataDe))
		oQuery:SetString(11, DtoS(dDataAte))
		oQuery:SetString(12, 'ER0')
		oQuery:SetString(13, 'ER1')
		oQuery:SetString(14, 'S')
		oQuery:SetString(15,' ')
		oQuery:OpenAlias(self:cAlias)
		
		While !(self:cAlias)->(Eof())
		
			If SC2->(C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) # ((self:cAlias)->D3_FILIAL+(self:cAlias)->D3_OP)
				SC2->(MsSeek((self:cAlias)->D3_FILIAL+(self:cAlias)->D3_OP))
			EndIf

			// Le requisicoes e devolucoes SD3 e grava no aLstTrb1 para gravacao do REAL
			If SubStr((self:cAlias)->D3_CF,2,1) $ "E"

				// Ordem de Producao
				cKeyScan := (self:cAlias)->D3_FILIAL+(self:cAlias)->D3_OP+(self:cAlias)->D3_COD

				If oLstTrb1J[cKeyScan] != NIL
					nPosTrb1 	 := oLstTrb1J[cKeyScan]
				Else
					nPosTrb1 	 := 0
				EndIf

				If Empty(nPosTrb1)
					aAdd(aLstTrb1,{	(self:cAlias)->D3_COD,		;	  		//01 - PRODUTO
									(self:cAlias)->D3_OP,		; 			//02 - OP
									(self:cAlias)->D3_NUMSEQ,	; 			//03 - NUMSEQ
									retTRT("RE",,self:cAlias),	; 			//04 - TRT
									(self:cAlias)->D3_CHAVE,	; 			//05 - CHAVE
									(self:cAlias)->D3_EMISSAO,	; 			//06 - EMISSAO
									SC2->C2_PRODUTO,			; 			//07 - PAI
									"",							;	 		//08 - FIXVAR
									retQtd(self:cAlias),	; 				//09 - QTDREAL
									0,							; 			//10 - QTDSTD
									0,							; 			//11 - QTDVAR
									0,							; 			//12 - CUSTOSTD
									retCus('R', jParams["MV_PAR07"][1],,self:cAlias),;		//13 - CUSTOREAL
									0,							;  			//14 - CUSTOVAR
									(self:cAlias)->D3_FILIAL	})	  		//15 - FILIAL
					oLstTrb1J[cKeyScan] := Len(aLstTrb1)
				Else
					aLstTrb1[nPosTrb1,03] := (self:cAlias)->D3_NUMSEQ		//03 - NUMSEQ
					aLstTrb1[nPosTrb1,04] := retTRT("RE",,self:cAlias)		//04 - TRT
					aLstTrb1[nPosTrb1,05] := (self:cAlias)->D3_CHAVE		//05 - CHAVE
					aLstTrb1[nPosTrb1,06] := (self:cAlias)->D3_EMISSAO		//06 - EMISSAO
					aLstTrb1[nPosTrb1,09] += retQtd(self:cAlias)			//09 - QTDREAL
					aLstTrb1[nPosTrb1,13] += retCus('R', jParams["MV_PAR07"][1],,self:cAlias)	//13 - CUSTOREAL
					aLstTrb1[nPosTrb1,15] := (self:cAlias)->D3_FILIAL		//15 - FILIAL
				EndIf
			EndIf

			// Le producoes e gravar TRB. para gravacao do STANDARD
			If SubStr((self:cAlias)->D3_CF,1,2)$"PR"

				// Lista por Ordem de Producao
				nPosTrb2 := aScan(aLstTrb2,{|x|x[2]==(self:cAlias)->D3_OP})

				If Empty(nPosTrb2)
					aAdd(aLstTrb2,Array(4))
					nPosTrb2 := Len(aLstTrb2)
					aLstTrb2[nPosTrb2,4] := 0
				EndIf
				aLstTrb2[nPosTrb2,1] := (self:cAlias)->D3_COD
				aLstTrb2[nPosTrb2,2] := (self:cAlias)->D3_OP
				aLstTrb2[nPosTrb2,3] := (self:cAlias)->D3_UM
				aLstTrb2[nPosTrb2,4] += (self:cAlias)->D3_QUANT

				cProduto := (self:cAlias)->D3_COD

				// Calcular pela Estrutura
				If jParams["MV_PAR09"][1] == 1

					cQuery 	  := ""
					lContinua := .F.
					nCountRec := 0
	
					If oQrySG1 == NIL
						cQrySG1 := "SELECT "
						cQrySG1 += "SG1.G1_FILIAL, SG1.G1_COD, SG1.G1_COMP, "
						cQrySG1 += "SG1.G1_QUANT, SG1.G1_INI, SG1.G1_FIM, "
						cQrySG1 += "SG1.G1_GROPC, SG1.G1_OPC, SG1.G1_TRT, "
						If cMVARQPROD == "SBZ"
							cQrySG1 += MatIsNull()+"(SBZ1.BZ_FANTASM,SB11.B1_FANTASM) FANTASM_COD, "
							cQrySG1 += MatIsNull()+"(SBZ2.BZ_FANTASM,SB12.B1_FANTASM) FANTASM_COMP, "
						Else
							cQrySG1 += "SB11.B1_FANTASM FANTASM_COD, " 
							cQrySG1 += "SB12.B1_FANTASM FANTASM_COMP, "
						EndIf
						cQrySG1 += "SG1.G1_FIXVAR, SG1.R_E_C_N_O_ SG1RECNO " 
						cQrySG1 += "FROM "+RetSqlName("SG1")+" SG1 "
						cQrySG1 += "LEFT JOIN "+RetSqlName("SB1")+" SB11 ON SB11.B1_FILIAL = ? " //1
						cQrySG1 += "AND SB11.B1_COD = SG1.G1_COD "
						cQrySG1 += "AND SB11.D_E_L_E_T_= ? " //2
						cQrySG1 += "LEFT JOIN "+RetSqlName("SB1")+" SB12 ON SB12.B1_FILIAL = ? " //3
						cQrySG1 += "AND SB12.B1_COD = SG1.G1_COMP "
						cQrySG1 += "AND SB12.D_E_L_E_T_= ? " //4
						If cMVARQPROD == "SBZ"
							cQrySG1 += "LEFT JOIN "+RetSqlName("SBZ")+" SBZ1 ON SBZ1.BZ_FILIAL = ? " //5
							cQrySG1 += "AND SBZ1.BZ_COD = SB11.B1_COD "
							cQrySG1 += "AND SBZ1.D_E_L_E_T_= ? " //6
							cQrySG1 += "LEFT JOIN "+RetSqlName("SBZ")+" SBZ2 ON SBZ2.BZ_FILIAL = ? " //7
							cQrySG1 += "AND SBZ2.BZ_COD = SB12.B1_COD "
							cQrySG1 += "AND SBZ2.D_E_L_E_T_= ? " //8
						EndIf
						cQrySG1 += "WHERE SG1.G1_FILIAL = ? "   //9
						cQrySG1 += "AND SG1.G1_COD = ? "        //10
						cQrySG1 += "AND SG1.D_E_L_E_T_= ? "     //11
						cQrySG1 := ChangeQuery(cQrySG1) 

						//Montagem da query para execução
						oQrySG1 := FwExecStatement():New(cQrySG1)
					EndIf

					oQrySG1:SetString(1, cFilSB1)
					oQrySG1:SetString(2, ' ')
					oQrySG1:SetString(3, cFilSB1)
					oQrySG1:SetString(4, ' ')

					If cMVARQPROD == "SBZ"
						oQrySG1:SetString(5, cFilSBZ)
						oQrySG1:SetString(6, ' ')
						oQrySG1:SetString(7, cFilSBZ)
						oQrySG1:SetString(8, ' ')
						oQrySG1:SetString(9, cFilSG1)
						oQrySG1:SetString(10, cProduto)
						oQrySG1:SetString(11, ' ')
					Else 
						oQrySG1:SetString(5, cFilSG1)
						oQrySG1:SetString(6, cProduto)
						oQrySG1:SetString(7, ' ')
					EndIf 

					oQrySG1:OpenAlias(cAliasSG1)

					While (cAliasSG1)->(!Eof()) .And. cFilSG1+cProduto == (cAliasSG1)->(G1_FILIAL+G1_COD)
						If cDataBase < (cAliasSG1)->G1_INI .Or. cDataBase > (cAliasSG1)->G1_FIM
							(cAliasSG1)->(dbSkip())
							Loop
						EndIf

						If !Empty( (cAliasSG1)->G1_GROPC ) .AND. !Empty( (cAliasSG1)->G1_OPC )

							If Empty((cAliasSG1)->G1_TRT)
								// se existir sequencia deste componente na estrutura
								// com opcionais entao devo verificar os movimentos internos
								If oQrySG1Trt == NIL
									cQuery := "SELECT COUNT(R_E_C_N_O_) NREC FROM " + RetSqlName("SG1")
									cQuery += " WHERE "
									cQuery += " G1_FILIAL = ? "
									cQuery += " AND G1_COMP = ? "
									cQuery += " AND G1_TRT > ? "
									cQuery += " AND G1_GROPC = ? "
									cQuery += " AND G1_OPC = ? "
									cQuery += " AND G1_INI >= ? "
									cQuery += " AND G1_FIM <= ? "
									cQuery += " AND D_E_L_E_T_ = ? "

									oQrySG1Trt := FwExecStatement():New(cQuery)
								EndIf

								oQrySG1Trt:SetString(1, FWxFilial("SG1"))
								oQrySG1Trt:SetString(2, (cAliasSG1)->G1_COMP)
								oQrySG1Trt:SetString(3, space(len((cAliasSG1)->G1_TRT)))
								oQrySG1Trt:SetString(4, (cAliasSG1)->G1_GROPC)
								oQrySG1Trt:SetString(5, (cAliasSG1)->G1_OPC)
								oQrySG1Trt:SetString(6, (cAliasSG1)->G1_INI)
								oQrySG1Trt:SetString(7, (cAliasSG1)->G1_FIM)
								oQrySG1Trt:SetString(8, ' ')

								nCountRec := oQrySG1Trt:ExecScalar("NREC")
								lContinua := nCountRec > 0

							EndIf

							If lContinua
								cAliasOpc := GetNextAlias()
								If oQrySD3 == NIL
									cQuery := "SELECT SD3.D3_OP, SD3.D3_COD, SD3.D3_TRT, SD3.R_E_C_N_O_ D3REC "
									cQuery += "FROM " + RetSqlName("SD3") + " SD3 "
									cQuery += "WHERE SD3.D3_FILIAL = ? "
									cQuery += "AND SD3.D3_OP =  ? "
									cQuery += "AND SD3.D3_COD = ? "
									cQuery += "AND SD3.D3_TRT <> ? "
									cQuery += "AND SD3.D_E_L_E_T_ = ? "
									cQuery := ChangeQuery(cQuery)
									oQrySD3 := FwExecStatement():New(cQuery)
								EndIf

								oQrySD3:SetString(1, (self:cAlias)->D3_FILIAL)
								oQrySD3:SetString(2, (self:cAlias)->D3_OP)
								oQrySD3:SetString(3, (cAliasSG1)->G1_COMP)
								oQrySD3:SetString(4, ' ')
								oQrySD3:SetString(5, ' ')
								oQrySD3:OpenAlias(cAliasOpc)

								If ( cAliasOpc )->( !Eof() )
									If ( cAliasOpc )->D3_TRT <> (cAliasSG1)->G1_TRT

										( cAliasOpc )->( dbCloseArea() )
										(cAliasSG1)->(dbSkip())
										Loop
									EndIf
								EndIf
								( cAliasOpc )->( dbCloseArea() )

							EndIf

						EndIf

						nQuantG1 := 0
						nRecno	 := (cAliasSG1)->SG1RECNO
						If (cAliasSG1)->G1_FIXVAR == "F"
							nQuantG1 := (cAliasSG1)->G1_QUANT
							If (self:cAlias)->D3_PARCTOT == 'P'
								If SC2->(C2_QUJE==C2_QUANT)
									nQuantG1 := Round(nQuantG1 * 1,nTamDecQtd)
								Else
									nQuantG1 := Round(nQuantG1 * SC2->(C2_QUJE/C2_QUANT),nTamDecQtd)
								EndIf
							EndIf
						Else
							aAreaSG1 := GetArea()
							dbSelectArea('SG1')
							MsGoto(nRecno)
							
							cChvExEst := SG1->(G1_FILIAL+G1_COD+G1_COMP+G1_TRT+DTOS(G1_INI)+DTOS(G1_FIM)+G1_REVINI+G1_REVFIM)
							cChvExEst += SC2->(C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)

							cTipoDec := Posicione('SB1',1,FWxFilial('SB1')+SG1->G1_COMP,'B1_TIPODEC')
							If oExplEstr[cChvExEst] == Nil
								nQtdBase := ExplEstr(1,SC2->C2_DATPRI,SC2->C2_OPC,SC2->C2_REVISAO,,,.F.)
								oExplEstr[cChvExEst] := {nQtdBase, cTipoDec}
							Else
								nQtdBase := oExplEstr[cChvExEst][1]
								cTipoDec := oExplEstr[cChvExEst][2]
							EndIf

							nQuantG1 := nQtdBase * (self:cAlias)->D3_QUANT
							Do Case
								Case cTipoDec == "A"
									nQuantG1 := Round( nQuantG1,0 )
								Case cTipoDec == "I"
									If ((nQuantG1-Int(nQuantG1)) > 0)
										nQuantG1 := Int(nQuantG1)+1
									Else
										nQuantG1 := Int(nQuantG1)
									EndIf
								Case cTipoDec == "T"
									nQuantG1 := Int( nQuantG1 )
								OtherWise
									nQuantG1 := nQuantG1
							EndCase

						EndIf

						// Se Produto for FANTASMA gravar so os componentes.
						If (cAliasSG1)->FANTASM_COD == "S" // Projeto Implementacao de campos MRP e FANTASM no SBZ
							retFant(nQuantG1,self:cAlias,jParams['MV_PAR08'][1],(cAliasSG1)->G1_COMP)
						Else
							// Gravar Valores da Producao no array aLstTrb1
							cKeyScan := (self:cAlias)->D3_FILIAL+(self:cAlias)->D3_OP+(cAliasSG1)->G1_COMP

							If oLstTrb1J[cKeyScan] != NIL
								nPosTrb1 := oLstTrb1J[cKeyScan]
							Else
								nPosTrb1 := 0
							EndIf

							// Valida Requesicoes de mesmo componente para a mesma estrutura
							If !Empty(nPosTrb1) .And. !Empty(aLstTrb1[nPosTrb1,4])
								aRetSD3 := retTRT("PR",nPosTrb1,self:cAlias)
							Else
								aRetSD3 := {"",0,.F.}
							EndIf

							If Empty(nPosTrb1)
								aAdd(aLstTrb1,Array(15))
								nPosTrb1 := Len(aLstTrb1)
								aLstTrb1[nPosTrb1,01] := (cAliasSG1)->G1_COMP
								aLstTrb1[nPosTrb1,02] := (self:cAlias)->D3_OP
								aLstTrb1[nPosTrb1,09] := 0
								aLstTrb1[nPosTrb1,10] := 0
								aLstTrb1[nPosTrb1,11] := 0
								aLstTrb1[nPosTrb1,12] := 0
								aLstTrb1[nPosTrb1,13] := 0
								aLstTrb1[nPosTrb1,14] := 0
								aLstTrb1[nPosTrb1,15] := (self:cAlias)->D3_FILIAL
							
								oLstTrb1J[cKeyScan] := Len(aLstTrb1)
							EndIf
							aLstTrb1[nPosTrb1,04] := aRetSD3[1]
							aLstTrb1[nPosTrb1,07] := cProduto
							aLstTrb1[nPosTrb1,08] := (cAliasSG1)->G1_FIXVAR
							aLstTrb1[nPosTrb1,10] += Round(nQuantG1,nTamDecQtd)
							aLstTrb1[nPosTrb1,12] += retCus("S",jParams["MV_PAR08"][1],Round(nQuantG1,nTamDecCus))
							aLstTrb1[nPosTrb1,15] := (self:cAlias)->D3_FILIAL
						EndIf
						(cAliasSG1)->(dbSkip())
					EndDo
					(cAliasSG1)->(dbCloseArea())
					RestArea(aAreaSG1)

				// Calcular pelo Empenho
				Else
					dbSelectArea("SD4")
					dbSetOrder(2)
					dbSeek(xFilial("SD4")+(self:cAlias)->D3_OP)
					If (self:cAlias)->D3_OP # cOpAnt
						lOpConf:=.T.
					Else
						lOpConf:=.F.
					EndIf

					While SD4->(!Eof() .And. D4_FILIAL + D4_OP == FWxFilial("SD4")+(self:cAlias)->D3_OP ) .And. cOpAnt # (self:cAlias)->D3_OP .And. lOpConf

						If aScan(aRecnoD4, SD4->(RecNo())) > 0
							dbSkip()
							Loop
						EndIf

						aAdd(aRecnoD4, SD4->(RecNo()))

						// Gravar Valores da Producao no array aLstTrb1
						dbSelectArea("SB1")
						MsSeek(cFilSB1+SD4->D4_COD)
						nPosTrb1 := aScan(aLstTrb1,{|x|x[2]+x[1]==(self:cAlias)->D3_OP+SD4->D4_COD})

						If Empty(nPosTrb1)
							aAdd(aLstTrb1,Array(15))
							nPosTrb1 := Len(aLstTrb1)
							aLstTrb1[nPosTrb1,01] := SD4->D4_COD
							aLstTrb1[nPosTrb1,02] := (self:cAlias)->D3_OP
							aLstTrb1[nPosTrb1,09] := 0
							aLstTrb1[nPosTrb1,10] := 0
							aLstTrb1[nPosTrb1,11] := 0
							aLstTrb1[nPosTrb1,12] := 0
							aLstTrb1[nPosTrb1,13] := 0
							aLstTrb1[nPosTrb1,14] := 0
							aLstTrb1[nPosTrb1,15] := (self:cAlias)->D3_FILIAL
						EndIf
						aLstTrb1[nPosTrb1,07] := cProduto
						aLstTrb1[nPosTrb1,08] := ""
						aLstTrb1[nPosTrb1,10] += Round(SD4->D4_QTDEORI * SC2->(C2_QUJE/C2_QUANT), nTamDecQtd)
						aLstTrb1[nPosTrb1,12] += retCus("S",jParams["MV_PAR08"][1],Round(SD4->D4_QTDEORI * SC2->(C2_QUJE/C2_QUANT),nTamDecCus))
						aLstTrb1[nPosTrb1,15] := (self:cAlias)->D3_FILIAL

						dbSelectArea("SD4")
						dbSkip()
					EndDo

					cOpAnt := (self:cAlias)->D3_OP
				EndIf
				dbSelectArea(self:cAlias)
			EndIf

			(self:cAlias)->(dbSkip())

		EndDo

		aLstTrb1 := ASort(aLstTrb1,,, { | x,y | x[2]+x[1] < y[2]+y[1] })

		nQuantOp := 0.00

		For nI:=1 To Len(aLstTrb1)

			// Impressao por OP
			nPosTrb2 := aScan(aLstTrb2,{|x| x[2]==aLstTrb1[nI,2]})

			If Empty(nPosTrb2)
				Loop
			EndIf

			nQuantOp := aLstTrb2[nPosTrb2,4]

			cAnt := aLstTrb1[nI,02]

			While nI <= Len(aLstTrb1) .And. aLstTrb1[nI,2] == cAnt
				nTotalVar  := aLstTrb1[nI,13]-aLstTrb1[nI,12]   //	CUSTOREAL-CUSTOSTD
				nQtdVar    := aLstTrb1[nI,09]-aLstTrb1[nI,10]	//	QTDREAL-QTDSTD
				nPercent   := (nQtdVar/aLstTrb1[nI,10])*100		//	((QTDREAL-QTDSTD)/QTDSTD)*100
				If Empty(aLstTrb1[nI,09])
					nCusUnit := aLstTrb1[nI,13]
				Else
					nCusUnit := Round(aLstTrb1[nI,13]/aLstTrb1[nI,09],nTamDecCus)
				EndIf
				If Empty(aLstTrb1[nI,10])
					nCusUStd := aLstTrb1[nI,12]
				Else
					nCusUStd := Round(aLstTrb1[nI,12]/aLstTrb1[nI,10],nTamDecCus)
				EndIf
				nSValor    := Round(nCusUnit*nQtdVar,nTamDecCus)
				nSQuant    := Round(nTotalVar-nSValor,nTamDecCus)

				// Posiciona na tabela de PRODUTOS
				SB1->(DbSetOrder(1))
				SB1->(dbSeek(xFilial("SB1")+aLstTrb1[nI,01]))
				If (jParams["MV_PAR09"][1] == 1 .Or. (QtdComp(aLstTrb1[nI,09],.T.) # QtdComp(0,.T.)))
					self:jItens := JsonObject():New()

					self:jItens["CFILIAL"]		:= aLstTrb1[nI,15]
					self:jItens["CPRODOP"]		:= aLstTrb2[nPosTrb2,1]
					self:jItens["CCODOP"]		:= aLstTrb2[nPosTrb2,2]
					self:jItens["NQUANT"]	 	:= aLstTrb2[nPosTrb2,4]

					self:jItens["REALQTD"]		:= aLstTrb1[nI,09]
					self:jItens["REALCUSTUN"]	:= nCusUnit
					self:jItens["REALCUSTTOT"]	:= aLstTrb1[nI,13]

					self:jItens["STDQTD"]		:= aLstTrb1[nI,10]
					self:jItens["STDCUSTUN"	]	:= nCusUStd
					self:jItens["STDCUSTTOT"]	:= aLstTrb1[nI,12]

					self:jItens["VARQTD"	]	:= nQtdVar
					self:jItens["VARCUSTTOT"]	:= nTotalVar
					self:jItens["PVARCUSTTOT"]	:= nSQuant
					self:jItens["PVARQTD"	]	:= nSValor
					self:jItens["PERCENT"	]	:= nPercent

					For nX := 1 To Len(self:aAllFields)
						If self:aAllFields[nX][2] == "date"
							If !Empty(SB1->&(self:aAllFields[nX][1]))
								self:jItens[self:aAllFields[nX][1]] := totvs.framework.treports.date.dateToTimeStamp(SB1->&(self:aAllFields[nX][1]))
							EndIf
						Else
							self:jItens[self:aAllFields[nX][1]] := SB1->&(self:aAllFields[nX][1])
						EndIf
					Next nX

					self:processData()
					self:oData:appendData(self:jItens)
				EndIf
				nI++

				If nI > Len(aLstTrb1) .Or. aLstTrb1[nI,2] # cAnt
					nI--
					Exit
				EndIf
			EndDo
		Next
	
	Next 

	cFilAnt := cBkpFil

    //Se não for o último registro indica que terá próxima página
    oQuery:Destroy()
    (self:cAlias)->( DBCloseArea() )
	
return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema
 
@author BackOffice
@since 09/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method oNGetSchema() Class RelxStdConsumptionSmartViewBusinessObject

    local aFieldsSB1 as array

	aFieldsSB1 := {"B1_COD","B1_UM","B1_DESC"}
	
    self:AliasToSchema( "SB1" , aFieldsSB1 )

	self:oSchema:addProperty("CFILIAL"	  , STR0019 ,"string"  , STR0019, "CFILIAL") 	// Filial
	self:oSchema:addProperty("CPRODOP"	  , STR0004 ,"string"  , STR0004, "NQUANT") 	// Produto Ord. Prod
	self:oSchema:addProperty("CCODOP"	  , STR0020 ,"string"  , STR0020, "CCODOP")  	// Ordem de Produção
	self:oSchema:addProperty("NQUANT" 	  , STR0005 , "number" , STR0005, "NQUANT")  	// Quantidade
	self:oSchema:addProperty("REALQTD"	  , STR0006 , "number" , STR0006, "REALQTD")	//Consumo Real - Quantidade
	self:oSchema:addProperty("REALCUSTUN" , STR0007 , "number" , STR0007, "REALCUSTUN") // Consumo Real - Custo Unitário
	self:oSchema:addProperty("REALCUSTTOT", STR0008 , "number" , STR0008, "REALCUSTTOT")// Consumo Real - Custo Total
	self:oSchema:addProperty("STDQTD"	  , STR0009 , "number" , STR0009, "STDQTD")		// Consumo Standard - Quantidade
	self:oSchema:addProperty("STDCUSTUN"  , STR0010 , "number" , STR0010, "STDCUSTUN")	// Consumo Standard - Custo Unitário
	self:oSchema:addProperty("STDCUSTTOT" , STR0011 , "number" , STR0011, "STDCUSTTOT") // Consumo Standard - Custo Total
	self:oSchema:addProperty("VARQTD"	  , STR0012 , "number" , STR0012, "VARQTD")		// Variação - Quantidade
	self:oSchema:addProperty("VARCUSTTOT" , STR0013 , "number" , STR0013, "VARCUSTTOT") // Variação - Custo Total
	self:oSchema:addProperty("PVARQTD"	  , STR0014 , "number" , STR0014, "PVARQTD")	// % Variação - Quantidade
	self:oSchema:addProperty("PVARCUSTTOT", STR0015 , "number" , STR0015, "PVARCUSTTOT")// % Variação - Custo Total
	self:oSchema:addProperty("PERCENT"	  , STR0016 , "number" , STR0016, "PERCENT")	// %

Return

//-------------------------------------------------------------------
/*{Protheus.doc} retQtd
Retorna a Quantidade
 
@return object: self:oSchema
 
@author BackOffice
@since 09/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Static Function retQtd(cAliasSD3 as character)
    local nRet  	  as numeric
	local nMult := -1 as numeric

	If SubStr((cAliasSD3)->D3_CF, 1, 1) == 'R'
		nMult := 1
	EndIf

    nRet := (cAliasSD3)->D3_QUANT * nMult

Return (nRet)

//-------------------------------------------------------------------
/*{Protheus.doc} retCus
Retorna o custo
 
@return object: self:oSchema
 
@author BackOffice
@since 09/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Static Function retCus(cTipo as character,nMoeda as numeric,nQtd,cAliasSD3)
    local nRet 		  as numeric
	local nMult := -1 as numeric

    Default cAliasSD3 := "SD3"
    Default nQtd      := 0

	If SubStr((cAliasSD3)->D3_CF, 1, 1) == 'R'
		nMult := 1
	EndIf

    If cTipo = "R" 	// Custo Real
        nRet := (cAliasSD3)->( &("D3_CUSTO"+ Str(nMoeda,1)) ) * nMult
    Else  // Custo Standard
        dbSelectArea("SB1")
        nRet := (nQtd*xMoeda(RetFldProd(SB1->B1_COD,"B1_CUSTD"),Val(RetFldProd(SB1->B1_COD,"B1_MCUSTD")), nMoeda, RetFldProd(SB1->B1_COD,"B1_DATREF") ))
    EndIf

Return (nRet)

//-------------------------------------------------------------------
/*{Protheus.doc} retTRT
Funcao para tratar duas ou mais requisicoes de um mesmo
componente utilizados dentro da mesma estrutura.
 
@return object: self:oSchema
 
@author BackOffice
@since 09/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Static Function retTRT(cTipoMov as character,nLin as numeric,cAliasNew as character)
	Local cConteudo 	  as character
	Local cQuery    	  as character
	Local cAliasSD3 	  as character
	Local cTRTCorte		  as character
	Local cRetorno  	  as character
	Local nPosCorte 	  as numeric
	
	If !Empty(nLin)
		cConteudo := RTrim(aLstTrb1[nLin,4])
	EndIf

	If cTipoMov == "RE"
		// Chamado a partir da leitura das REQUISICOES para compor o REAL
		If !Empty((cAliasNew)->D3_TRT)
			cRetorno := "   /" + (cAliasNew)->D3_TRT
		EndIf
	Else
		// Chamado a partir da leitura das PRODUCOES para compor o STANDARD
		cAliasSD3   := GetNextAlias()
		nPosCorte	:= At("/",cConteudo)
		If nPosCorte <> 0
			cTRTCorte	:= SubStr(cConteudo,1,nPosCorte-1)
			cConteudo	:= Substr(cConteudo,nPosCorte+1,Len(cConteudo))
		EndIf

		If oQryretTRT == NIL
			cQuery    := "SELECT SD3.R_E_C_N_O_ SD3RECNO "
			cQuery    += "FROM " + RetSqlName("SD3") + " SD3 "
			cQuery    += "WHERE SD3.D3_FILIAL  = ? "
			cQuery    += "AND SD3.D3_EMISSAO = ? "
			cQuery    += "AND SD3.D3_NUMSEQ  = ? "
			cQuery    += "AND SD3.D3_CHAVE   = ? "
			cQuery    += "AND SD3.D3_COD     = ? "
			cQuery    += "AND SD3.D_E_L_E_T_ = ? "

			oQryretTRT := FwExecStatement():New(cQuery)
		EndIf

		oQryretTRT:SetString(1, FWxFilial("SD3"))
		oQryretTRT:SetString(2, aLstTrb1[nLin,06])
		oQryretTRT:SetString(3, aLstTrb1[nLin,03])
		oQryretTRT:SetString(4, aLstTrb1[nLin,05])
		oQryretTRT:SetString(5, aLstTrb1[nLin,01])
		oQryretTRT:SetString(6, ' ')

		oQryretTRT:OpenAlias(cAliasSD3)

		If (cAliasSD3)->(!Eof())
			cRetorno := {cConteudo,(cAliasSD3)->SD3RECNO,.T.}
		EndIf
		(cAliasSD3)->(dbCloseArea())
		oQryretTRT:Destroy()
	EndIf

Return (cRetorno)

//-------------------------------------------------------------------
/*{Protheus.doc} retFant
Retorna a Estrutura de Produto Fantasma funcao Recursiva.
 
@return object: self:oSchema
 
@author BackOffice
@since 11/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Static Function retFant(nQuantPai as numeric,cAliasNew as character,nMoeda as numeric,cComponen)
	local nPosTrb1  as numeric
	local aAreaSB1  := SB1->(GetArea()) as array
	local aAreaSG1  := SG1->(GetArea()) as array

	Default cComponen := SG1->G1_COMP

	dbSelectArea("SG1")
	If dbSeek(xFilial("SG1")+cComponen,.F.)
		Do While !Eof() .And. G1_FILIAL+G1_COD == xFilial("SG1")+cComponen
			If G1_INI > dDataBase .Or. G1_FIM < dDataBase
				dbSkip()
				Loop
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gravar Valores da Producao em TRB do componente.             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB1")
			If MsSeek(xFilial("SB1")+SG1->G1_COMP)
				If SG1->G1_FIXVAR == "F"
					nQuantG1 := SG1->G1_QUANT
				Else
					nQuantG1 := ExplEstr(nQuantPai,SC2->C2_DATPRI,SC2->C2_OPC,SC2->C2_REVISAO)
				EndIf
				
				nPosTrb1 := aScan(aLstTrb1,{|x| x[2]+x[1]==(cAliasNew)->D3_OP+SG1->G1_COMP})

				If RetFldProd(SB1->B1_COD,"B1_FANTASM") == "S" // Projeto Implementeacao de campos MRP e FANTASM no SBZ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Se Produto for FANTASMA gravar so os componentes.            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					retFant(nQuantG1,cAliasNew,nMoeda)
				Else
					If !Empty(nPosTrb1) .And. !Empty(aLstTrb1[nPosTrb1,04])
						aRetSD3 := retTRT("PR",nPosTrb1)
					Else
						aRetSD3 := {"",0,.F.}
					EndIF

					If Empty(nPosTrb1)
						aAdd(aLstTrb1,Array(15))
						nPosTrb1 := Len(aLstTrb1)
						aLstTrb1[nPosTrb1,01] := SG1->G1_COMP
						aLstTrb1[nPosTrb1,02] := (cAliasNew)->D3_OP
						aLstTrb1[nPosTrb1,09] := 0
						aLstTrb1[nPosTrb1,10] := 0
						aLstTrb1[nPosTrb1,12] := 0
						aLstTrb1[nPosTrb1,13] := 0
						aLstTrb1[nPosTrb1,14] := 0
						aLstTrb1[nPosTrb1,15] := (cAliasNew)->D3_FILIAL
					EndIf
					aLstTrb1[nPosTrb1,04] := aRetSD3[1]
					aLstTrb1[nPosTrb1,07] := (cAliasNew)->D3_COD
					aLstTrb1[nPosTrb1,08] := SG1->G1_FIXVAR
					aLstTrb1[nPosTrb1,10] += Round(nQuantG1,nTamDecQtd)
					aLstTrb1[nPosTrb1,12] += retCus("S",nMoeda,Round(nQuantG1,nTamDecCus))
					aLstTrb1[nPosTrb1,15] := (cAliasNew)->D3_FILIAL
				EndIf
			EndIf
			dbSelectArea("SG1")
			dbSkip()
		EndDo
	EndIf

	RestArea(aAreaSB1)
	RestArea(aAreaSG1)
Return

/*/{Protheus.doc} estGetCpo
Prepara a estrutura dos campos
@type  Função
@author Squad Entradas
@since  Dezembro 06,2023
/*/
Static Function estGetCpo(aFields as array)
	local aDeParaCpo 	as array
	local aCpoTmp := {} as array
	local cTipR 		as character
	local cTipo 		as character
	local nPos 			as numeric
	local nX 			as numeric

	aDeParaCpo := {{"C", "string"}, {"D", "date"}, {"N", "number"}, {"L", "boolean"}}

	For nX := 1 To Len(aFields)
		cTipo := FWSX3Util():GetFieldType( aFields[nX] )
		cTipR := "string"
		If (nPos := aScan( aDeParaCpo, {|c| c[01] = cTipo } ) ) > 0
			cTipR := aDeParaCpo[nPos, 02]
		EndIf
		AAdd( aCpoTmp,;
			{aFields[nX],;
			cTipR})
	Next nX

Return (aCpoTmp)
