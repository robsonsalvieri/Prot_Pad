#include "msobject.ch"
#include "backoffice.sv.est.checkingofstockbalance.ch"
#include "totvs.framework.treports.integratedprovider.th"
#define SX1GRUPO "ESTT012"

namespace totvs.protheus.backoffice.est.checkingofstockbalance.integratedprovider
using namespace totvs.protheus.backoffice.est.smartView.integratedProvider

@totvsFrameworkTReportsIntegratedProvider(active=.T.,team="SIGAEST",tables="SB1,SB2",name="Conferência de Saldos",country="ALL")

class CheckingOfStockBalanceSmartViewBusinessObject from totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider
    public method new() as object
    public method getData() as object

    Protected Method oNGetSchema()

    Protected data cAlias       as character
    Protected data cWhere       as character
    Protected data aFieldsSB1   as array
    Protected data aFieldsSB2   as array
    Protected data jItens       as json
    Protected data lContinua	as logical
endclass

/*/ {Protheus.doc} New
Metodo de instancia da classe.
@type  Metodo
@author Squad Entradas
@since  Maio 15,2023
/*/
method new() class CheckingOfStockBalanceSmartViewBusinessObject
    _Super:new()

    //Define a Área
    self:appendArea(STR0001) // Estoque/Custos
    
    //Define o nome do Objeto de Negócio
    self:setDisplayName(STR0002) // "Conferência de Saldos"

    //Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 ) // Emite uma relação de produtos que utilizam o controle de Lote/SubLote e/ou Localização fisica, assim como o status de balanceamento entre os saldos.

    //Define o conjunto de perguntas e faz o teste se existe
	self:lContinua := self:setPergunte( SX1GRUPO )
	If !self:lContinua
		self:setErrorStatus(400,STR0022,i18n(STR0023,{SX1GRUPO}))//O Grupo de perguntas #1 não existe		
		FWLogMsg('WARN', , 'SmartView', , , , i18n(STR0023,{SX1GRUPO}), , , )//O Grupo de perguntas #1 não existe
	EndIf

	//Indica que o LookUp será do tipo padrão LookUp
	self:setIsLookUp(.T.)

return self

/*/{Protheus.doc} getData
Metodo que retorna o Objeto de dados.
@type  Metodo
@author Squad Entradas
@since  Maio 15,2023
/*/
method getData(nPage as numeric, oFilter as object) as object class CheckingOfStockBalanceSmartViewBusinessObject

    local oQuerySB2 as object
    local oQuerySB8 as object
    local oQuerySBF as object
    local oQuerySDA as object
    local oQueryTRK as object
    local oQueryTRJ as object
    local oQuery1   as object
    local oQuery2   as object
    local cQuery as character
    local cEmpExec as character
    local cFilExec as character
    local cFields as character
    local cStatus as character
    local cCtrEnd as character
    local cCtrLote as character
    local cData as character
    local cSPMAT036 as character
    local cSPMAT037 as character
    local cArqProd as character
    local cRastro as character
    local cWmsNew := '0' as character
    local cNomeTab := "0_SP" as character
    Local cFiltro  as character
    local lRastro as logical
    Local lLocaliza as logical
    local nQtdSB2  as numeric
    local nQtdSBK as numeric
    local nQtdSBJ as numeric
    local nQtdSDA as numeric
    local nX as numeric
    local jParams  as json
    local aNewSBK as array
    local aNewSBJ as array
    local aResult as array
    local dData as date
    local lExistProc as logical
    local lExProc36  as logical
    local lExProc37  as logical
    local l300SalNeg as logical
    local dUlMes     as date
	local nFil		 as numeric
	local cBkpFil	 as Character

    private oQuerySDB as object
    private oQuerySDAB as object

    //Variável com o nome do Grupo de Empresa
    cEmpExec := AllTrim(FWEmpName(cEmpAnt))
    cFiltro := " AND "

    //Metodo para retorno do json dos parâmetros
    jParams  := oFilter:getParameters()

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'])

    //Atualiza a variável cFields com os campos utilizados no select
    cFields := ArrTokStr(self:aFieldsSB1,",") + ","
    cFields += ArrTokStr(self:aFieldsSB2,",") + ",SB2.R_E_C_N_O_ RECNOSB2"

    //Inicializa as variáveis utilizadas no processamento
    dData := FwDateTimeToLocal( jParams['MV_PAR06'][1] )[1]
    cData := DtoS(dData)
    
    self:cAlias := GetNextAlias()
    lExistProc  := ExistProc(GetSPName("MAT038","17"),VerIDProc()) .And. TCCanOpen( "TRJ"+cEmpAnt+cNomeTab ).And. TCCanOpen( "TRK"+cEmpAnt+cNomeTab )
    lExProc36   := ExistProc(GetSPName("MAT036","17"),VerIDProc())
    lExProc37   := ExistProc(GetSPName("MAT037","17"),VerIDProc())

    cBkpFil := cFilAnt

    //Montagem do From da Query
    cQuery := "SELECT ? "
	cQuery += "FROM " + RetSqlName("SB2") + " SB2 "
    cQuery += "INNER JOIN " + RetSqlName("SB1") + " SB1 ON "
    cQuery += "SB1.B1_FILIAL = ? AND "
    cQuery += "SB1.B1_COD = SB2.B2_COD AND "
    cQuery += "SB1.D_E_L_E_T_ = ? "
	cQuery += "WHERE SB2.B2_FILIAL = ? AND "
	cQuery += "SB2.B2_COD >= ? AND "
	cQuery += "SB2.B2_COD <= ? AND "
	cQuery += "SB2.B2_LOCAL >= ? AND "
	cQuery += "SB2.B2_LOCAL <= ? AND "
	cQuery += "SB2.D_E_L_E_T_ = ? "

    //Os filtros serão setados na interface do novo Smart View
    If !(oFilter:hasFilter())
		cFiltro := ""  
	Endif

    cQuery += " ? "
	cQuery += self:cWhere
    cQuery := ChangeQuery(cQuery)

    //Montagem da query para execução
    oQuerySB2 := FwExecStatement():New(cQuery)

	//Colocar while ou for de filiais aqui
	For nFil :=1 to len(self:aFils)
		cFilAnt := self:aFils[nFil]

        // Nao permitir que a execução do objeto em uma filial em processamento
        self:lContinua := lockObj(@self)

        If self:lContinua
            dUlMes  := SuperGetMV("MV_ULMES")

            //Variável com o nome da Filial
            cFilExec := AllTrim(FWFilialName())

            If lExistProc
                cArqProd  := SuperGetMv("MV_ARQPROD",.F.,.F.)
                If SuperGetMV("MV_WMSNEW",.F.,.F.)
                    cWmsNew := '1'
                EndIf
                l300SalNeg:= SuperGetMV("MV_MT300NG",.F.,.F.)
                cRastro   := SuperGetMv("MV_RASTRO",.F.,'N')

                If oQuery1 == Nil .And. oQuery2 == Nil
                    cSPMAT036 := GetSPName("MAT036","17")
                    cSPMAT037 := GetSPName("MAT037","17")

                    // Tabela temporaria TRJ
                    cQuery := "DELETE FROM ? WHERE BJ_FILIAL = ? AND D_E_L_E_T_  = ?"
                    oQuery1 := FwExecStatement():New(cQuery)

                    // Tabela temporaria TRK
                    cQuery := "DELETE FROM ? WHERE BK_FILIAL = ? AND D_E_L_E_T_  = ?"
                    oQuery2 := FwExecStatement():New(cQuery)
                EndIf

                // Realiza a limpeza na tabela temporaria TRJ
                oQuery1:SetUnsafe(1, "TRJ"+cEmpAnt+cNomeTab)
                oQuery1:SetString(2, FWxFilial('SBJ'))
                oQuery1:SetString(3, ' ')
                cQuery := oQuery1:getFixQuery()
                TcSqlExec(cQuery)

                // Realiza a limpeza na tabela temporaria TRK
                oQuery2:SetUnsafe(1, "TRK"+cEmpAnt+cNomeTab)
                oQuery2:SetString(2, FWxFilial('SBK'))
                oQuery2:SetString(3, ' ')
                cQuery := oQuery2:getFixQuery()
                TcSqlExec(cQuery)
            EndIf

            oQuerySB2:SetUnsafe(1, cFields)
            oQuerySB2:SetString(2, FWxFilial('SB1'))
            oQuerySB2:SetString(3, ' ')
            oQuerySB2:SetString(4, FWxFilial('SB2'))
            oQuerySB2:SetString(5, jParams["MV_PAR01"][1])
            oQuerySB2:SetString(6, jParams['MV_PAR02'][1])
            oQuerySB2:SetString(7, jParams['MV_PAR03'][1])
            oQuerySB2:SetString(8, jParams['MV_PAR04'][1])
            oQuerySB2:SetString(9, ' ')
            oQuerySB2:SetUnsafe(10, cFiltro + oFilter:getSQLExpression())

            oQuerySB2:OpenAlias(self:cAlias)

            (self:cAlias)->( DBGoTop() )

            Do While !(self:cAlias)->(Eof())

                //Verifica se o produto possui controle de rastro ou localizacao
                lRastro   := Rastro((self:cAlias)->B2_COD)
                lLocaliza := Localiza((self:cAlias)->B2_COD)
                cCtrLote  := STR0004 // NAO
                cCtrEnd   := STR0004 // NAO

                //Processa somente se o produto possuir controle de endereco ou lote
                If !lLocaliza .And. !lRastro
                    (self:cAlias)->(dbSkip())
                    Loop
                EndIf

                //Inicializa variaveis de controle
                cStatus := ''
                nQtdSB2 := 0
                nQtdSBK := 0
                nQtdSBJ := 0
                nQtdSDA := 0
                aNewSBK := {}
                aNewSBJ := {}
                self:jItens := JsonObject():New()

                // Impressao baseada no saldo atual
                If jParams["MV_PAR05"][1] == 1
                    nQtdSB2 :=  (self:cAlias)->B2_QATU
                    If lRastro
                        If (self:cAlias)->B1_RASTRO == "L"
                            cCtrLote := STR0006 // LOTE
                        Else
                            cCtrLote := STR0007 // SUBLOTE
                        EndIf

                        If oQuerySB8 == NIL
                            cQuery := "SELECT SUM(B8_SALDO) B8_SALDO "
                            cQuery += "FROM " + RetSqlName("SB8") + " SB8 "
                            cQuery += "WHERE SB8.B8_FILIAL = ? AND "
                            cQuery += "SB8.B8_PRODUTO = ? AND "
                            cQuery += "SB8.B8_LOCAL = ? AND "
                            cQuery += "SB8.D_E_L_E_T_ = ? "
                            cQuery := ChangeQuery(cQuery)

                            //Montagem da query para execução
                            oQuerySB8 := FwExecStatement():New(cQuery)
                        EndIf

                        oQuerySB8:SetString(1, FWxFilial('SB8'))
                        oQuerySB8:SetString(2, (self:cAlias)->B2_COD)
                        oQuerySB8:SetString(3, (self:cAlias)->B2_LOCAL)
                        oQuerySB8:SetString(4, ' ')

                        nQtdSBJ := oQuerySB8:ExecScalar("B8_SALDO")
                    EndIf

                    If lLocaliza
                        cCtrEnd := STR0005 // SIM
                        If oQuerySBF == NIL
                            cQuery := "SELECT SUM(BF_QUANT) BF_QUANT "
                            cQuery += "FROM " + RetSqlName("SBF") + " SBF "
                            cQuery += "WHERE SBF.BF_FILIAL = ? AND "
                            cQuery += "SBF.BF_PRODUTO = ? AND "
                            cQuery += "SBF.BF_LOCAL = ? AND "
                            cQuery += "SBF.D_E_L_E_T_ = ? "
                            cQuery := ChangeQuery(cQuery)

                            //Montagem da query para execução
                            oQuerySBF := FwExecStatement():New(cQuery)
                        EndIf

                        oQuerySBF:SetString(1, FWxFilial('SBF'))
                        oQuerySBF:SetString(2, (self:cAlias)->B2_COD)
                        oQuerySBF:SetString(3, (self:cAlias)->B2_LOCAL)
                        oQuerySBF:SetString(4, ' ')

                        nQtdSBK := oQuerySBF:ExecScalar("BF_QUANT")

                        If oQuerySDA == NIL
                            cQuery := "SELECT SUM(DA_SALDO) DA_SALDO "
                            cQuery += "FROM " + RetSqlName("SDA") + " SDA "
                            cQuery += "WHERE SDA.DA_FILIAL = ? AND "
                            cQuery += "SDA.DA_PRODUTO = ? AND "
                            cQuery += "SDA.DA_LOCAL = ? AND "
                            cQuery += "SDA.D_E_L_E_T_ = ? "
                            cQuery := ChangeQuery(cQuery)

                            //Montagem da query para execução
                            oQuerySDA := FwExecStatement():New(cQuery)
                        EndIf

                        oQuerySDA:SetString(1, FWxFilial('SDA'))
                        oQuerySDA:SetString(2, (self:cAlias)->B2_COD)
                        oQuerySDA:SetString(3, (self:cAlias)->B2_LOCAL)
                        oQuerySDA:SetString(4, ' ')

                        nQtdSDA := oQuerySDA:ExecScalar("DA_SALDO")
                    EndIf
                // Impressao baseada no saldo por movimento ou pelo saldo de fechamento
                Else
                    // Analisa o tipo de saldos
                    If jParams["MV_PAR05"][1] == 2
                        nQtdSB2 := CalcEst((self:cAlias)->B2_COD,(self:cAlias)->B2_LOCAL,dData+1)[1]
                    Else
                        nQtdSB2 := (self:cAlias)->B2_QFIM
                    EndIf

                    //Processa saldo por Endereco (Utiliza SB2 Posicionada)
                    If lLocaliza
                        cCtrEnd := STR0005 // SIM
                        If lExistProc .And. lExProc37
                            atuTRK(cFilAnt,cData,(self:cAlias)->B2_COD,(self:cAlias)->B2_LOCAL,DTOS(dUlMes),If( l300SalNeg, '1', '0' ),'1',@aResult,lRastro,cWmsNew,cSPMAT037,cArqProd)
                            // Realiza a abertura da tabela temporaria TRK
                            If oQueryTRK == NIL
                                cQuery := "SELECT SUM(BK_QINI) BK_QINI FROM TRK? "
                                cQuery += "WHERE BK_FILIAL = ? AND "
                                cQuery += "BK_COD = ? AND "
                                cQuery += "BK_LOCAL = ? AND "
                                cQuery += "D_E_L_E_T_ = ? "
                                cQuery := ChangeQuery(cQuery)
                                
                                //Montagem da query para execução
                                oQueryTRK := FwExecStatement():New(cQuery)
                            EndIf

                            oQueryTRK:SetUnsafe(1, cEmpAnt+cNomeTab)
                            oQueryTRK:SetString(2, FWxFilial("SBK"))
                            oQueryTRK:SetString(3, (self:cAlias)->B2_COD)
                            oQueryTRK:SetString(4, (self:cAlias)->B2_LOCAL)
                            oQueryTRK:SetString(5, ' ')

                            nQtdSBK := oQueryTRK:ExecScalar("BK_QINI")
                        Else
                            SB2->(MsGoto((self:cAlias)->RECNOSB2))
                            nQtdSBK:=BKAtuComB2(dData, .F., Nil, .T., @aNewSBK)
                            If Len(aNewSBK)>0
                                nQtdSBK:=0
                                For nX := 1 to Len(aNewSBK)
                                    nQtdSBK += aNewSBK[nX,9]
                                Next nX
                            EndIf
                        EndIf
                        nQtdSDA := saldoSDA((self:cAlias)->B2_COD,(self:cAlias)->B2_LOCAL,cData,dUlMes)
                    EndIf

                    //Processa saldo por Lote/SubLote (Utiliza SB2 Posicionada)
                    If lRastro
                        If (self:cAlias)->B1_RASTRO == "L"
                            cCtrLote := STR0006 // LOTE
                        Else
                            cCtrLote := STR0007 // SUBLOTE
                        EndIf
                        If lExistProc .And. lExProc36
                            atuTRJ(cFilAnt,cData,(self:cAlias)->B2_COD,(self:cAlias)->B2_LOCAL,cRastro,DTOS(dUlMes),If( l300SalNeg, '1', '0' ),'1',@aResult,cWmsNew,cSPMAT036)
                            // Realiza a abertura da tabela temporaria TRJ
                            If oQueryTRJ == NIL
                                cQuery := "SELECT SUM(BJ_QINI) BJ_QINI FROM TRJ? "
                                cQuery += "WHERE BJ_FILIAL = ? AND "
                                cQuery += "BJ_COD = ? AND "
                                cQuery += "BJ_LOCAL = ? AND "
                                cQuery += "D_E_L_E_T_ = ? "
                                cQuery := ChangeQuery(cQuery)
                            
                                //Montagem da query para execução
                                oQueryTRJ := FwExecStatement():New(cQuery)
                            EndIf

                            oQueryTRJ:SetUnsafe(1, cEmpAnt+cNomeTab)
                            oQueryTRJ:SetString(2, FWxFilial("SBJ"))
                            oQueryTRJ:SetString(3, (self:cAlias)->B2_COD)
                            oQueryTRJ:SetString(4, (self:cAlias)->B2_LOCAL)
                            oQueryTRJ:SetString(5, ' ')

                            nQtdSBJ := oQueryTRJ:ExecScalar("BJ_QINI")
                        Else
                            SB2->(MsGoto((self:cAlias)->RECNOSB2))
                            nQtdSBJ:=BJAtuComB2(dData, .F., Nil, .T., @aNewSBJ)
                            If Len(aNewSBJ) > 0
                                nQtdSBJ := 0
                                For nX := 1 to Len(aNewSBJ)
                                    nQtdSBJ += aNewSBJ[nX,7]
                                Next nX
                            EndIf
                        EndIf
                    EndIf
                EndIf

                // Verifica o Status da Conferencia de Saldos
                If lLocaliza .And. lRastro
                    If QtdComp(nQtdSB2)==QtdComp(nQtdSBK) .And. QtdComp(nQtdSB2)==QtdComp(nQtdSBJ) .And. QtdComp(nQtdSDA)==QtdComp(0)
                        cStatus := STR0018 //'OK'
                    ElseIf QtdComp(nQtdSDA) > QtdComp(0)
                        cStatus := STR0017 //'SDA=PENDENTE'
                    ElseIf QtdComp(nQtdSB2)<>QtdComp(nQtdSBK) .And. QtdComp(nQtdSB2)<>QtdComp(nQtdSBJ)
                        cStatus := STR0019 //'SB2xSBFxSB8'
                    ElseIf QtdComp(nQtdSB2)<>QtdComp(nQtdSBK)
                        cStatus := STR0020 //'SB2xSBF'
                    ElseIf QtdComp(nQtdSB2)<>QtdComp(nQtdSBJ)
                        cStatus := STR0021 //'SB2xSB8'
                    EndIf
                ElseIf lLocaliza
                    If QtdComp(nQtdSB2)==QtdComp(nQtdSBK) .And. QtdComp(nQtdSDA)==QtdComp(0)
                        cStatus := STR0018 //'OK'
                    ElseIf QtdComp(nQtdSDA) > 0
                        cStatus := STR0017 //'SDA=PENDENTE'
                    Else
                        cStatus := STR0020 //'SB2xSBF'
                    EndIf
                ElseIf lRastro
                    If nQtdSB2 == nQtdSBJ
                        cStatus := STR0018 //'OK'
                    Else
                        cStatus := STR0021 //'SB2xSB8'
                    EndIf
                EndIf

                For nX := 1 To Len(self:aFieldsSB1)            
                        self:jItens[self:aFieldsSB1[nX]] := (self:cAlias)->&(self:aFieldsSB1[nX])            
                Next nX

                For nX := 1 To Len(self:aFieldsSB2)           
                        self:jItens[self:aFieldsSB2[nX]] := (self:cAlias)->&(self:aFieldsSB2[nX])            
                Next nX

                self:jItens["EMPNOME"] := cEmpExec
                self:jItens["FILNOME"] := cFilExec
                self:jItens["QTDSB2"]  := nQtdSB2
                self:jItens["QTDSBK"]  := nQtdSBK
                self:jItens["QTDSDA"]  := nQtdSDA
                self:jItens["QTDSBJ"]  := nQtdSBJ
                self:jItens["STATUS"]  := cStatus
                self:jItens["CTREND"]  := cCtrEnd
                self:jItens["CTRLOTE"] := cCtrLote

                self:processData()
                self:appendData(self:jItens)

                (self:cAlias)->( dbSkip() )
            EndDo

            //Desbloqueio de Filial para processamento do objeto
            unlockObj()

            (self:cAlias)->( DBCloseArea() )
        EndIf
    Next

    cFilAnt := cBkpFil

    oQuerySB2:Destroy()
    If oQuery1 <> NIL
        oQuery1:Destroy()
    EndIf
    If oQuery2 <> NIL
        oQuery2:Destroy()
    EndIf
    If oQuerySB8 <> NIL
        oQuerySB8:Destroy()
    EndIf
    If oQuerySBF <> NIL
        oQuerySBF:Destroy()
    EndIf
    If oQuerySDA <> NIL
        oQuerySDA:Destroy()
    EndIf
    If oQueryTRK <> NIL
        oQueryTRK:Destroy()
    EndIf
    If oQueryTRJ <> NIL
        oQueryTRJ:Destroy()
    EndIf
    If oQuerySDAB <> NIL
        oQuerySDAB:Destroy()
    EndIf
    If oQuerySDB <> NIL
        oQuerySDB:Destroy()
    EndIf

return self:oData

/*/{Protheus.doc} oNGetSchema
Metodo que retorna a Estrutura de dados.
@type  Metodo
@author Squad Entradas
@since  Maio 15,2023
/*/
method oNGetSchema() class CheckingOfStockBalanceSmartViewBusinessObject

    self:aFieldsSB1 := {"B1_COD","B1_DESC","B1_TIPO","B1_UM","B1_LOCPAD","B1_GRUPO","B1_CONTA","B1_CC","B1_ITEMCC","B1_RASTRO"}
    self:aFieldsSB2 := {"B2_FILIAL","B2_COD","B2_LOCAL","B2_QATU","B2_QFIM"}

    self:aliasToSchema("SB1",self:aFieldsSB1)
    self:aliasToSchema("SB2",self:aFieldsSB2)

    self:addProperty("EMPNOME", STR0008, "string", STR0008, "EMPNOME") // Empresa
    self:addProperty("FILNOME", STR0009, "string", STR0009, "FILNOME") // Filial
    self:addProperty("CTREND" , STR0010, "string", STR0010, "CTREND")  // Controle Endereço
    self:addProperty("CTRLOTE", STR0011, "string", STR0011, "CTREND")  // Controle Rastro
    self:addProperty("QTDSB2" , STR0012, "number", STR0012, "QTDSB2")  // Quantidade Física
    self:addProperty("QTDSBK" , STR0013, "number", STR0013, "QTDSBK")  // Quantidade Por Endereço
    self:addProperty("QTDSDA" , STR0014, "number", STR0014, "QTDSDA")  // Quantidade a Endereçar
    self:addProperty("QTDSBJ" , STR0015, "number", STR0015, "QTDSBJ")  // Quantidade por Lote/Sublote
    self:addProperty("STATUS" , STR0016, "string", STR0016, "STATUS")  // Status

return

/*/{Protheus.doc} saldoSDA
Retorna o saldo a endereçar em aberto
@type  Função
@author Squad Entradas
@since  Agosto 03,2023
/*/
Static Function saldoSDA(cProduto as character,cLocal as character,cDtFech as character,dUlMes as date)
    Local nQuantSDA as numeric
    Local cQuery as character

    //-- Query responsável por retornar o saldo a endereçar em aberto
    If oQuerySDAB == NIL
        cQuery := "SELECT SUM(DA_SALDO) DA_SALDO "
        cQuery += "FROM " + RetSqlName("SDA") + " SDA "
        cQuery += "WHERE SDA.DA_FILIAL = ? AND "
        cQuery += "SDA.DA_PRODUTO = ? AND "
        cQuery += "SDA.DA_LOCAL = ? AND "
        cQuery += "SDA.DA_DATA <= ? AND "
        cQuery += "SDA.DA_SALDO > ? AND "
        cQuery += "SDA.D_E_L_E_T_ = ? "
        cQuery := ChangeQuery(cQuery)

        oQuerySDAB := FwExecStatement():New(cQuery)
    EndIf
    
    oQuerySDAB:SetString(1, FWxFilial('SDA'))
    oQuerySDAB:SetString(2, cProduto)
    oQuerySDAB:SetString(3, cLocal)
    oQuerySDAB:SetString(4, cDtFech)
    oQuerySDAB:SetNumeric(5, 0)
    oQuerySDAB:SetString(6, ' ')

    nQuantSDA := oQuerySDAB:ExecScalar("DA_SALDO")

    //-- Query responsável por retornar o saldo endereçado após o período informado
    If oQuerySDB == NIL
        cQuery := "SELECT SUM(DB_QUANT) DB_QUANT "
        cQuery += "FROM " + RetSqlName("SDB") + " SDB "
        cQuery += "INNER JOIN " + RetSqlName("SDA") + " SDA ON "
        cQuery += "SDA.DA_FILIAL = ? AND "
        cQuery += "SDA.DA_PRODUTO = SDB.DB_PRODUTO AND "
        cQuery += "SDA.DA_LOCAL = SDB.DB_LOCAL AND "
        cQuery += "SDA.DA_NUMSEQ = SDB.DB_NUMSEQ AND "
        cQuery += "SDA.DA_DATA <= ? AND "
        cQuery += "SDA.D_E_L_E_T_ = ? "
        cQuery += "WHERE SDB.DB_FILIAL = ? AND "
        cQuery += "SDB.DB_PRODUTO = ? AND "
        cQuery += "SDB.DB_LOCAL = ? AND "
        cQuery += "SDB.DB_DATA > ? AND "
        cQuery += "SDB.DB_ESTORNO = ? AND "
        cQuery += "SDB.D_E_L_E_T_ = ? "
        cQuery := ChangeQuery(cQuery)

        oQuerySDB := FwExecStatement():New(cQuery)
    EndIf
    
    oQuerySDB:SetString(1, FWxFilial('SDA'))
    oQuerySDB:SetString(2, cDtFech)
    oQuerySDB:SetString(3, ' ')
    oQuerySDB:SetString(4, FWxFilial('SDB'))
    oQuerySDB:SetString(5, cProduto)
    oQuerySDB:SetString(6, cLocal)
    oQuerySDB:SetString(7, cDtFech)
    oQuerySDB:SetString(8, ' ')
    oQuerySDB:SetString(9, ' ')

    nQuantSDA += oQuerySDB:ExecScalar("DB_QUANT")

Return nQuantSDA

/*/{Protheus.doc} atuTRK
Processa a stored procedure MAT037 referente ao saldo por
endereco a ser gerado no fechamento (SBK)  
@type  Função
@author Squad Entradas
@since  Agosto 03,2023
/*/
Static Function atuTRK(cCodFil as character,cDataFec as character,cProduto as character,cLocal as character,cUlMes as character,c300SalNeg as character,cConsulta as character,aResult as array,lRastro as logical,cWmsNew as character,cSPMAT037 as character,cArqProd as character)
    local cInTransact   := '1' as character
    local cRastro       := '0' as character

    If lRastro
        cRastro := '1'
    EndIf
    
    if !InTransact()
        cInTransact := '0'
    EndIf

    aResult:= TCSPEXEC( xProcedures(cSPMAT037),cCodFil,cDataFec,cProduto,cLocal,cUlMes,c300SalNeg,0,cConsulta,100,cWmsNew,cArqProd,cRastro,cInTransact)

Return aResult

/*/{Protheus.doc} atuTRJ
Processa a stored procedure MAT036 referente ao saldo por
lote/sublote a ser gerado no fechamento (SBJ)
@type  Função
@author Squad Entradas
@since  Agosto 03,2023
/*/
Static Function atuTRJ(cCodFil as character,cDataFec as character,cProduto as character,cLocal as character,cRastro as character,cUlMes as character,c300SalNeg as character,cConsulta as character,aResult as array,cWmsNew as character,cSPMAT036 as character)
    local cInTransact := "1" as character
    
    if !InTransact()
        cInTransact :='0'
    EndIf

    aResult:= TCSPEXEC( xProcedures( cSPMAT036 ),cCodFil,cDataFec,cProduto,cLocal,cRastro,cUlMes,c300SalNeg,0,0,cConsulta,100,cWmsNew,cInTransact )   

Return aResult

/*/{Protheus.doc} VerIDProc
Identifica a sequencia de controle do fonte ADVPL com a stored procedure
@type  Função
@author Squad Entradas
@since  Agosto 03,2023
/*/
Static Function VerIDProc()
Return EngSPS17Signature()

/*/{Protheus.doc} lockObj
Bloqueio de Filial para processamento do objeto   
@type  Função
@author Squad Entradas
@since  Dezembro 14,2023
/*/
Static Function lockObj(self as object)
    local lRet       := .T. as logical
    local nTentativa := 0   as numeric
    local cFilProb   := ""  as character

    // Variavel de controle de tentativas
    nTentativa := 0
    
    // Trava arquivo para somente este usuario utilizar rotina
    While !LockByName("MR282"+cEmpAnt+cFilAnt,.T.,.F.,.T.) .And. nTentativa <= 50
        nTentativa++
        Sleep(100)
    End
   
    // Tenta travar somente 50 vezes, e se nao conseguir coloca na lista de filiais com concorrencia
    If nTentativa > 50
        cFilProb := cFilAnt
    EndIf

    // Nao permite processamento concorrente
    If !Empty(cFilProb)
        lRet := .F.
        self:setErrorStatus(400,STR0024,i18n(STR0025,{cFilProb})) //##"Concorrência"##" A filial ## da empresa corrente já esta sendo utilizada na impressão do objeto ou do relatório Conferência de Saldos (MATR282)."
		FWLogMsg('WARN', , 'SmartView', , , , i18n(STR0025,{cFilProb}), , , )// A filial ## da empresa corrente já esta sendo utilizada na impressão do objeto ou do relatório Conferência de Saldos (MATR282)."
    EndIf

Return lRet

/*/{Protheus.doc} unlockObj()
Desbloqueio de Filial para processamento do objeto 
@type  Função
@author Squad Entradas
@since  Dezembro 14,2023
/*/
Static Function unlockObj()
    // Destrava o bloqueio de filiais
    UnLockByName("MR282"+cEmpAnt+cFilAnt,.T.,.F.,.T.)
Return
