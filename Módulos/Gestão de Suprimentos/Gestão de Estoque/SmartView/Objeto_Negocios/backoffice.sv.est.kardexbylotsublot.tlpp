#include "msobject.ch"
#include "protheus.ch"
#include "backoffice.sv.est.kardexbylotsublot.ch"
#include "totvs.framework.treports.integratedprovider.th"

#DEFINE SX1GRUPO "ESTT006"

using namespace totvs.protheus.backoffice.est.smartView.integratedProvider
namespace totvs.protheus.backoffice.est.kardexbylotsublot.integratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAEST", tables="SB8,SD5",name="Kardex por Lote/Sublote", country="ALL")

//-------------------------------------------------------------------
/*{Protheus.doc} KardexPorLoteSubLoteSmartViewBusinessObject 
Classe para criação do Objeto de Negócio de Kardex por Lote/Sub-Lote 

@author Squad Entradas
@since 06/2023
@Review Michel Sander em 18/10/2023
@version 1.0
*/
//-------------------------------------------------------------------
Class KardexPorLoteSubLoteSmartViewBusinessObject From totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider

	Public Method new() as object
	Public Method getData() as object

	Protected Method oNGetSchema()
	Protected data aFieldsSB8 as Array
	Protected data aFieldsSD5 as Array
	Protected data jItems	  as Json
	Protected data cWhere	  as Character
	Protected data lExistPergunte as logical

EndClass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe

@return object: self

@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method new() Class KardexPorLoteSubLoteSmartViewBusinessObject

	LOCAL cMsgSX1 := ""

	_Super:new()

	//Define a Área
	self:appendArea( STR0001 ) //"Estoque/Custos"

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0002 ) //"Kardex por Lote/Sublote"

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 ) //"Este programa emitira um Kardex com todas as movimentações do estoque por Lote/Sublote, diariamente. Observação: o primeiro movimento de cada Lote/Sublote se refere a criação do mesmo."

	//Grupo de Perguntas
	self:lExistPergunte := self:SetPergunte(SX1GRUPO)
	If !self:lExistPergunte
		cMsgSX1 := OemToAnsi(I18N(STR0009,{SX1GRUPO})) //#Grupo de perguntas #1[SX1GRUPO]# nao encontrado. Verifique na tabela SX1, o grupo de perguntas informado
		self:setErrorStatus(400,STR0010,cMsgSX1)		//#Sem Pergunte
		FwLogMsg("WARN",, "SmartView ESTSV010",,,,cMsgSX1,,,)
	EndIf

	//Indica que o LookUp será do tipo padrão LookUp
	self:setIsLookUp(.T.)
	self:aFieldsSB8 := poestGetCpo( "SB8" )
	self:aFieldsSD5 := poestGetCpo( "SD5" )

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio

@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do Smart View

@return object: self:oData

@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getData( nPage as Numeric, oFilter as object) as object Class KardexPorLoteSubLoteSmartViewBusinessObject

	Local dDataDe		as Date
	Local dDataAte		as Date
	Local jParams		as Json
	Local aSaldo		as Array
	Local nX			as Numeric
	Local nF			as Numeric
	Local nSaldo		as Numeric
	Local nSaida		as Numeric
	Local nEntrada		as Numeric
	Local nSldLote		as Numeric
	Local nSD5Quant		as Numeric
	Local nSD5Quan2		as Numeric
	Local lProd			as Logical
	Local lLote			as Logical
	Local lMovSD5		as Logical
	Local lLoteZera		as Logical
	Local cLocal		as Character
	Local cQuery		as Character
	Local cLote			as Character
	Local cFields		as Character
	Local cSubLote		as Character
	Local cFilExec		as character
	Local cEmpExec		as character
	Local cProdAnt		as Character
	Local cLoteAnt		as Character
	Local cProduto		as Character
	Local cAliasTmp		as Character
	Local nFil          as Numeric 
	Local cBkpFil       as Character
	Local oQuery        as Object

	//Variáveis com o nome da Filial e Grupo de Empresa
	cFilExec := AllTrim(FWFilialName())
	cEmpExec := AllTrim(FWEmpName(cEmpAnt))

	// Define nome do alias disponível
	cAliasTmp := getNextAlias()

	If !self:lExistPergunte
		Return self:oData
	EndIf

	//Define a quantidade máxima por página (Default 100)
	self:setPageSize(100)

	For nF := 1 To Len( self:aFieldsSB8 )
		cFields += self:aFieldsSB8[ nF ][ 01 ] + ","
	Next nF

	For nF := 1 To Len( self:aFieldsSD5 )
		cFields += self:aFieldsSD5[ nF ][ 01 ] + ","
	Next nF

	cFields := SubStr( cFields , 1 , Len( cFields ) -1 )

	//--------------------------------------------------------------------------
	// Variaveis utilizadas para parametros no grupo de pergunta ESTT006
	//--------------------------------------------------------------------------
	//
	// MV_PAR01 - De  Produto
	// MV_PAR02 - Até Produto
	// MV_PAR03 - De  Lote
	// MV_PAR04 - Até Lote
	// MV_PAR05 - De  Sub-Lote
	// MV_PAR06 - Ate Sub-Lote
	// MV_PAR07 - Do Armazem
	// MV_PAR08 - Até o Armazem
	// MV_PAR09 - De  Data
	// MV_PAR10 - Até Data
	// MV_PAR11 - Lote/Sub S/ Movimen
	// MV_PAR12 - Lote/Sub Sld Zerado
	//--------------------------------------------------------------------------
	jParams := oFilter:getParameters() //metodo para retorno do json dos parâmetros

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'])

	dDataDe  := FwDateTimeToLocal(jParams["MV_PAR09"][1])[1]
	dDataAte := FwDateTimeToLocal(jParams["MV_PAR10"][1])[1]
	//D5_FILIAL, D5_PRODUTO, D5_LOCAL, D5_LOTECTL, D5_NUMLOTE, D5_NUMSEQ, R_E_C_N_O_, D_E_L_E_T_
	cQuery := " SELECT ? "
	cQuery += " FROM	      " + RetSQLName( 'SB8' ) + " SB8 "
	cQuery += " LEFT	JOIN  " + RetSQLName( 'SD5' ) + " SD5 "
	cQuery += " ON		D5_FILIAL		=  ? "
	cQuery += " AND		D5_PRODUTO		= B8_PRODUTO "
	cQuery += " AND		D5_LOCAL		= B8_LOCAL "
	cQuery += " AND		D5_LOTECTL		= B8_LOTECTL "
	cQuery += " AND		D5_NUMLOTE		= B8_NUMLOTE "
	cQuery += " AND		D5_DATA			>= ? "
	cQuery += " AND		D5_DATA			<= ? "
	cQuery += " AND		SD5.D_E_L_E_T_ 	=  ? "
	cQuery += " WHERE	B8_FILIAL		=  ? "
	cQuery += " AND		B8_PRODUTO		>= ? "
	cQuery += " AND		B8_PRODUTO		<= ? "
	cQuery += " AND		B8_LOCAL    	>= ? "
	cQuery += " AND		B8_LOCAL    	<= ? "
	cQuery += " AND		B8_LOTECTL		>= ? "
	cQuery += " AND		B8_LOTECTL		<= ? "
	cQuery += " AND		B8_NUMLOTE		>= ? "
	cQuery += " AND		B8_NUMLOTE		<= ? "

	//Os filtros serão setados na interface do novo Smart View
	If oFilter:hasFilter()
		cQuery += " AND " + oFilter:getSQLExpression()
	Endif

	cQuery += " AND	SB8.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY B8_FILIAL, B8_PRODUTO, B8_LOCAL, B8_LOTECTL, B8_NUMLOTE, "
	cQuery += " D5_PRODUTO, D5_LOCAL, D5_LOTECTL, D5_DATA, D5_NUMLOTE, D5_NUMSEQ "

	cQuery := changeQuery(cQuery)
	oQuery := FwExecStatement():New(cQuery)

	cBkpFil := cFilant 

	//Colocar while ou for de filiais aqui 
	For nFil :=1 to len(self:aFils)

		cFilAnt  := self:aFils[nFil]
		cFilExec := AllTrim(FWFilialName())

		//Seta os campos
		oQuery:SetUnsafe( 1,cFields)
		//Seta um parâmetro na query via String
		oQuery:SetString( 2, FWxFilial("SD5"))
		//Seta um parâmetro na query do tipo Data do Protheus
		oQuery:setDate(   3,dDataDe)
		oQuery:setDate(   4,dDataAte)
		oQuery:SetString( 5, ' ')
		oQuery:SetString( 6, FWxFilial("SB8"))
		oQuery:SetString( 7,jParams['MV_PAR01'][1])
		oQuery:SetString( 8,jParams['MV_PAR02'][1])
		oQuery:SetString( 9,jParams['MV_PAR07'][1])
		oQuery:SetString( 10,jParams['MV_PAR08'][1])
		oQuery:SetString( 11,jParams['MV_PAR03'][1])
		oQuery:SetString( 12,jParams['MV_PAR04'][1])
		oQuery:SetString( 13,jParams['MV_PAR05'][1])
		oQuery:SetString( 14,jParams['MV_PAR06'][1])
		oQuery:SetString( 15, ' ')

		cAliasTmp := oQuery:OpenAlias()

		cProdAnt  := ""
		cLoteAnt  := ""
		nEntrada  := 0
		nSaida    := 0
		nSaldo    := 0
		nSD5Quant := 0
		nSD5Quan2 := 0

		While !(cAliasTmp)->(Eof())

			cProduto := (cAliasTmp)->B8_PRODUTO
			cLote    := (cAliasTmp)->B8_LOTECTL
			cSubLote := (cAliasTmp)->B8_NUMLOTE
			cLocal   := (cAliasTmp)->B8_LOCAL
			nEntrada := 0
			nSaida	 := 0
			nSldLote := CalcEstL(cProduto,cLocal, dDataAte + 1 ,(cAliasTmp)->B8_LOTECTL,If(Rastro(cProduto,"S"),(cAliasTmp)->B8_NUMLOTE,NIL))[1]

			If jParams['MV_PAR12'][1] == 2 .AND. nSldLote <= 0
				(cAliasTmp)->(dbSkip())
				Loop
			EndIf

			lLoteZera:= If( jParams['MV_PAR12'][1] == 1 , .T. , If( nSldLote == 0 , .F. , .T. ) )
			lProd    := AllTrim( cProdAnt) <> AllTrim( (cAliasTmp)->B8_PRODUTO )
			lLote 	 := .T.
			lMovSD5  := .T.

			If Empty( (cAliasTmp)->D5_PRODUTO )

				//-----------------------------------------------
				//³ Verifica se Lista Lote/Sub Sem Movimentos
				//³ 1 = Lista          2 = Nao Lista
				//-----------------------------------------------
				lLote   := If( jParams['MV_PAR11'][1] == 1 , .T. , .F. )
				lMovSD5 := If( jParams['MV_PAR12'][1] == 1 .And. lLote , .T. , .F. )

				If jParams['MV_PAR11'][1] == 2
					(cAliasTmp)->(dbSkip())
					Loop
				EndIf

			ElseIf Rastro(cProduto,"S")

				lLote   := If(jParams['MV_PAR11'][1] == 1, .T. , .F. )
				lMovSD5 := If(jParams['MV_PAR12'][1] == 1 .And. lLote , .T. , .F. )

			EndIf

			If !Empty( (cAliasTmp)->D5_PRODUTO ) .Or. lLote

				SB1->(dbSetOrder(1))
				SB1->(dbSeek(xFilial("SB1")+cProduto))

				If lLote .And. lLoteZera .And. (cProdAnt + cLoteAnt != (cAliasTmp)->D5_PRODUTO + (cAliasTmp)->D5_LOTECTL )
					cProdAnt := (cAliasTmp)->D5_PRODUTO
					cLoteAnt := (cAliasTmp)->D5_LOTECTL
					aSaldo   := CalcEstL(cProduto,cLocal, dDataDe ,(cAliasTmp)->B8_LOTECTL,IF(Rastro(cProduto,"S"),(cAliasTmp)->B8_NUMLOTE,NIL))
					nSaldo   := aSaldo[1]
				EndIf

				//-----------------------------------------
				//³ Impressao dos Movimentos do Lote/Sub
				//-----------------------------------------
				If !Empty( (cAliasTmp)->D5_PRODUTO ) .And. lLoteZera

					nSD5Quant := (cAliasTmp)->D5_QUANT
					nSD5Quan2 := (cAliasTmp)->D5_QTSEGUM

					If (cAliasTmp)->D5_ORIGLAN <= "500" .Or. Substr( (cAliasTmp)->D5_ORIGLAN,1,2) $ "DE/PR" .Or. (cAliasTmp)->D5_ORIGLAN == "MAN"
						nEntrada := nSD5Quant
						nSaldo   += nSD5Quant
					Elseif (cAliasTmp)->D5_ORIGLAN > "500" .Or. Substr((cAliasTmp)->D5_ORIGLAN,1,2) == "RE"
						nSaida  := nSD5Quant
						nSaldo  -= nSD5Quant
					EndIf

				EndIf

			EndIf

			self:jItems := JsonObject():New()

			//Carrega campos da SB8
			For nX := 1 To Len(self:aFieldsSB8)

				If self:aFieldsSB8[nX][ 02 ] == "D" //Campo tipo data tem um tratamento diferente para envio
					If !Empty( (cAliasTmp)->&(self:aFieldsSB8[nX][ 01 ]) )
						self:jItems[self:aFieldsSB8[nX][ 01 ]] := totvs.framework.treports.date.dateToTimeStamp(StoD((cAliasTmp)->&(self:aFieldsSB8[nX][01])))
					EndIf
				Else
					self:jItems[self:aFieldsSB8[nX][ 01 ]] := (cAliasTmp)->&(self:aFieldsSB8[nX][ 01 ])
				EndIf

			Next nX

			//Carrega campos da SD5
			For nX := 1 To Len(self:aFieldsSD5)

				If self:aFieldsSD5[nX][ 02 ] == "D" //Campo tipo data tem um tratamento diferente para envio
					If !Empty( (cAliasTmp)->&(self:aFieldsSD5[nX][ 01 ]) )
						self:jItems[self:aFieldsSD5[nX][ 01 ]] := totvs.framework.treports.date.dateToTimeStamp(StoD((cAliasTmp)->&(self:aFieldsSD5[nX][01])))
					EndIf
				Else
					self:jItems[self:aFieldsSD5[nX][ 01 ]] := (cAliasTmp)->&(self:aFieldsSD5[nX][ 01 ])
				EndIf

			Next nX

			self:jItems[ "ENTRADA"	] := nEntrada
			self:jItems[ "SAIDA"	] := nSaida
			self:jItems[ "SALDO"	] := nSaldo
			self:jItems[ "EMPNOME"	] := cEmpExec
			self:jItems[ "FILNOME"	] := cFilExec
			self:jItems[ "B1_COD"	] := SB1->B1_COD
			self:jItems[ "B1_DESC"	] := SB1->B1_DESC
			self:jItems[ "B1_TIPO"	] := SB1->B1_TIPO
			self:jItems[ "B1_UM"	] := SB1->B1_UM
			self:jItems[ "B1_GRUPO"	] := SB1->B1_GRUPO
			self:jItems[ "B1_RASTRO"] := SB1->B1_RASTRO

			self:processData()
			self:oData:appendData(self:jItems)

			(cAliasTmp)->(DBSkip())

		EndDo

		(cAliasTmp)->( DBCloseArea() )

	Next 

	cFilAnt := cBkpFil
	oQuery:Destroy()

Return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura dos campos

@return object: self:oSchema

@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method oNGetSchema() Class KardexPorLoteSubLoteSmartViewBusinessObject

	Local aFields as Array
	Local nF	  as Numeric

	aFields := {}
	For nF := 1 To Len( self:aFieldsSB8 )
		aAdd( aFields , self:aFieldsSB8[ nF , 1 ] )
	Next nF
	self:AliasToSchema("SB8", aFields )

	aFields := {}
	For nF := 1 To Len( self:aFieldsSD5 )
		aAdd( aFields , self:aFieldsSD5[ nF , 1 ] )
	Next nF
	self:AliasToSchema("SD5", aFields )

	aFields := {}
	aAdd( aFields , "B1_COD"		)
	aAdd( aFields , "B1_DESC"		)
	aAdd( aFields , "B1_TIPO"		)
	aAdd( aFields , "B1_UM"			)
	aAdd( aFields , "B1_GRUPO"		)
	aAdd( aFields , "B1_RASTRO"		)

	self:AliasToSchema("SB1", aFields)

	self:addProperty( "ENTRADA"	, STR0004	, "number", STR0004	, "ENTRADA"	) //"ENTRADA"
	self:addProperty( "SAIDA"	, STR0005	, "number", STR0005	, "SAIDA"	) //"SAIDA"
	self:addProperty( "SALDO"	, STR0006	, "number", STR0006	, "SALDO" 	) //"SALDO"
	self:addProperty( "EMPNOME"	, STR0007	, "string", STR0007	, "EMPNOME"	) //"Nome Empresa"
	self:addProperty( "FILNOME"	, STR0008	, "string", STR0008	, "FILNOME" ) //"Nome Filial"


Return

//-------------------------------------------------------------------
/*{Protheus.doc} GetCpo
Prepara a estrutura dos campos

@param aCpos array: Array com os campos do relatório
@return array: Array com a estrutura dos campos
@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------
Static Function poestGetCpo( cTab )

	Local aFields	as Array

	aFields := {}

	If cTab == "SB8"

		aAdd( aFields , {  "B8_FILIAL"	, "C" } )
		aAdd( aFields , {  "B8_PRODUTO"	, "C" } )
		aAdd( aFields , {  "B8_LOCAL"	, "C" } )
		aAdd( aFields , {  "B8_DATA"	, "D" } )
		aAdd( aFields , {  "B8_DTVALID"	, "D" } )
		aAdd( aFields , {  "B8_SALDO"	, "N" } )
		aAdd( aFields , {  "B8_EMPENHO"	, "N" } )
		aAdd( aFields , {  "B8_ORIGLAN"	, "C" } )
		aAdd( aFields , {  "B8_LOTECTL"	, "C" } )
		aAdd( aFields , {  "B8_NUMLOTE"	, "C" } )
		aAdd( aFields , {  "B8_SALDO2"	, "N" } )
		aAdd( aFields , {  "B8_QTDORI2"	, "N" } )
		aAdd( aFields , {  "B8_DOC"		, "C" } )
		aAdd( aFields , {  "B8_SERIE"	, "C" } )
		aAdd( aFields , {  "B8_CLIFOR"	, "C" } )
		aAdd( aFields , {  "B8_LOJA"	, "C" } )
		aAdd( aFields , {  "B8_LOTEFOR"	, "C" } )

	ElseIf cTab == "SD5"

		aAdd( aFields , {  "D5_FILIAL"	, "C" } )
		aAdd( aFields , {  "D5_PRODUTO"	, "C" } )
		aAdd( aFields , {  "D5_LOCAL"	, "C" } )
		aAdd( aFields , {  "D5_DOC"		, "C" } )
		aAdd( aFields , {  "D5_SERIE"	, "C" } )
		aAdd( aFields , {  "D5_OP"		, "C" } )
		aAdd( aFields , {  "D5_DATA"	, "D" } )
		aAdd( aFields , {  "D5_ORIGLAN"	, "C" } )
		aAdd( aFields , {  "D5_CLIFOR"	, "C" } )
		aAdd( aFields , {  "D5_LOJA"	, "C" } )
		aAdd( aFields , {  "D5_QUANT"	, "N" } )
		aAdd( aFields , {  "D5_LOTECTL"	, "C" } )
		aAdd( aFields , {  "D5_NUMLOTE"	, "C" } )
		aAdd( aFields , {  "D5_DTVALID"	, "D" } )
		aAdd( aFields , {  "D5_QTSEGUM"	, "N" } )
		aAdd( aFields , {  "D5_ESTORNO"	, "C" } )

	EndIf

Return	 aClone( aFields )
