#include "msobject.ch"
#include "protheus.ch"
#include "backoffice.sv.est.inventorieditemsreport.ch"
#include "totvs.framework.treports.integratedprovider.th"

//Grupo de perguntas
#define SX1GRUPO "ESTT003"

namespace totvs.protheus.backoffice.est.inventorieditemsreport.integratedprovider
using namespace totvs.protheus.backoffice.est.smartView.integratedProvider
  
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAEST", tables="SB1,SB7",name="Listagem dos Itens Inventariados", country="ALL",customTables="SB1,SB7")

//-------------------------------------------------------------------
/*{Protheus.doc} ListagemItensInventariadosTreportsBusinessObject
Classe para criação do Objeto de Negócio de Listagem dos Itens Inventariados

@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Class ListagemItensInventariadosTreportsBusinessObject From totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider

	Public Method new() as object
	Public Method getData() as object

	Protected Method oNGetSchema()

	Protected data jItems		as Json
	Protected data cWhere		as Character
	Protected data lExistPerg	as Logical

EndClass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe

@return object: self
 
@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method new() Class ListagemItensInventariadosTreportsBusinessObject

	_Super:new()

	//Define a Área
	self:appendArea( STR0001 ) //"Estoque/Custos"

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0002 ) //"Listagem dos Itens Inventariados"

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 ) //"Emite uma relacao que mostra o saldo em estoque e todas as contagens efetuadas no inventario. Baseado nestas duas informacoes ele calcula a diferenca encontrada."

	//Indica que o LookUp será do tipo padrão LookUp
    self:setIsLookUp(.T.)

    //Indica o pergunte que será utilizado no relatório
	self:lExistPerg := self:setPergunte( SX1GRUPO )
	If !self:lExistPerg
		self:setErrorStatus(400,STR0008,i18n(STR0009,{SX1GRUPO})) //"Sem Pergunte" -- "Grupo de perguntas #1[SX1GRUPO]# nao encontrado. Verifique na tabela SX1, o grupo de perguntas informado"
		FWLogMsg('WARN', , 'SmartView', , , , i18n(STR0009,{SX1GRUPO}), , , ) //"Grupo de perguntas #1[SX1GRUPO]# nao encontrado. Verifique na tabela SX1, o grupo de perguntas informado"
	EndIf

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio
 
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do TReports
 
@return object: self:oData
 
@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method getData( nPage as Numeric, oFilter as object) as object Class ListagemItensInventariadosTreportsBusinessObject

	Local dDataRef		as Date
	Local jParams		as Json
	Local aSaldo		as Array
	Local aSalQtd		as Array
	Local aCM			as Array
	Local aAllFields	as Array
	Local aSX3Fields	as Array
	Local aPrepared		as Array
	Local nY			as Numeric
	Local nX			as Numeric
	Local nTotal		as Numeric
	Local nSaldo		as Numeric
	Local nFil			as numeric
	Local nDbPar		as numeric
	Local nPosPrepared	as numeric
	Local nHSeek		as numeric
	Local lVeic			as Logical
	Local lSB7Cnt		as Logical
	Local lWmsNew		as Logical
	Local lImprime		as Logical
	Local lContagem		as Logical
	Local lEmAberto		as Logical
	Local lSaldo0		as Logical
	Local cId			as Character
	Local cSeek			as Character
	Local cTipo			as Character
	Local cLocal		as Character
	Local cGrupo		as Character
	Local cQuery		as Character
	Local cLocaliz		as Character
	Local cNumSeri		as Character
	Local cLoteCtl		as Character
	Local cNumLote		as Character
	Local cProduto		as Character
	Local cAliasTmp		as Character
	Local cRealName		as Character
	Local cBkpFil		as Character
	Local cMD5			as Character
	Local oSaldoWMS		as object
	Local oHSeek		as object 

	//Valida o pergunte
	If !self:lExistPerg
		return self:oData
	Endif

	aPrepared := {}

	nY		:= 0
	nHSeek	:= 0
	oHSeek	:= THashMap():New()

	//--------------------------------------------------------------------------
	// Variaveis utilizadas para parametros no grupo de pergunta ESTT003
	//--------------------------------------------------------------------------
	//
	// MV_PAR01 - Produto de
	// MV_PAR02 - Produto ate
	// MV_PAR03 - De  Tipo  
	// MV_PAR04 - Ate Tipo  
	// MV_PAR05 - De  Grupo 
	// MV_PAR06 - Ate Grupo 
	// MV_PAR07 - Do Armazem
	// MV_PAR08 - Ate Armazem
	// MV_PAR09 - Data de Selecao
	// MV_PAR10 - Qual Moeda (1 a 5)
	// MV_PAR11 - Listar Produtos
	// MV_PAR12 - Custo Medio Atual/Ultimo Fechamento
	//--------------------------------------------------------------------------
	jParams := oFilter:getParameters() //metodo para retorno do json dos parâmetros

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'], oFilter)

	dDataRef := FwDateTimeToLocal( jParams['MV_PAR09'][1] )[1]

	cBkpFil := cFilAnt
	
	lContagem	:= SuperGetMv('MV_CONTINV',.F.,.F.)
	lVeic		:= Upper(SuperGetMV( 'MV_VEICULO' ,.F., 'N' ) ) == "S"
	lWmsNew		:= SuperGetMV("MV_WMSNEW",.F.,.F.)

	For nFil :=1 to len(self:aFils)

		cFilAnt := self:aFils[nFil]
		lEmAberto	:= .F.

		//--------------------------------------------------------------------------
		//Montagem da Query - Utilizada no For pois existem parâmetros
		//da SX6 que podem alterar a estrutura da consulta
		//--------------------------------------------------------------------------
		cQuery := "SELECT ? "

		cQuery += " FROM	" + RetSQLName( 'SB7' ) + " SB7 "
		cQuery += " INNER	JOIN " + RetSQLName( 'SB1' ) + " SB1 "
		cQuery += " ON	SB1.B1_FILIAL =  ? "
		cQuery += " AND SB1.B1_GRUPO >= ? " 
		cQuery += " AND SB1.B1_GRUPO <= ? "
		cQuery += " AND	SB1.B1_COD = SB7.B7_COD "
		cQuery += " AND SB1.B1_TIPO >= ? " 
		cQuery += " AND SB1.B1_TIPO <= ? "
		cQuery += " AND SB1.D_E_L_E_T_ = ? "
		cQuery += " WHERE "
		cQuery += " SB7.B7_FILIAL = ? "
		cQuery += " AND SB7.B7_DATA = ? "
		If lVeic
			cQuery   += " AND SB1.B1_CODITE >= ? "
			cQuery   += " AND SB1.B1_CODITE <= ? " 
		Else
			cQuery   += " AND SB7.B7_COD >= ? "
			cQuery   += " AND SB7.B7_COD <= ? "
		EndIf
		cQuery += " AND SB7.B7_LOCAL >= ? " 
		cQuery += " AND SB7.B7_LOCAL <= ? " 
		If lContagem
			cQuery   += " AND SB7.B7_ESCOLHA = ? "
		EndIf
		cQuery += self:cWhereFiltroSV
		cQuery += self:cWhere
		cQuery += " AND SB7.D_E_L_E_T_ = ? "
		cQuery += " ORDER BY B1_FILIAL, B1_COD, B7_DOC, B7_STATUS, B7_LOTECTL, B7_NUMLOTE, B7_LOCALIZ "

		cQuery := changeQuery(cQuery)

		cMD5 := MD5(cQuery)
		If (nPosPrepared := Ascan(aPrepared,{|x| x[2] == cMD5})) == 0
			cQuery := changeQuery(cQuery)
			Aadd(aPrepared,{FwExecStatement():New(cQuery),cMD5})
			nPosPrepared := Len(aPrepared)
		Endif

		//Binding
		nDbPar := 1
		aPrepared[nPosPrepared][1]:setUnsafe(nDbPar++,self:getSQLFields())
		aPrepared[nPosPrepared][1]:setString(nDbPar++,FWxFilial("SB1"))	
		aPrepared[nPosPrepared][1]:setString(nDbPar++,jParams['MV_PAR05'][1])
		aPrepared[nPosPrepared][1]:setString(nDbPar++,jParams['MV_PAR06'][1])
		aPrepared[nPosPrepared][1]:setString(nDbPar++,jParams['MV_PAR03'][1])
		aPrepared[nPosPrepared][1]:setString(nDbPar++,jParams['MV_PAR04'][1])
		aPrepared[nPosPrepared][1]:setString(nDbPar++,' ')	
		aPrepared[nPosPrepared][1]:setString(nDbPar++,FWxFilial("SB7"))
		aPrepared[nPosPrepared][1]:setString(nDbPar++,Dtos(dDataRef))
		aPrepared[nPosPrepared][1]:setString(nDbPar++,jParams['MV_PAR01'][1])	
		aPrepared[nPosPrepared][1]:setString(nDbPar++,jParams['MV_PAR02'][1])
		aPrepared[nPosPrepared][1]:setString(nDbPar++,jParams['MV_PAR07'][1])	
		aPrepared[nPosPrepared][1]:setString(nDbPar++,jParams['MV_PAR08'][1])		
		If lContagem
			aPrepared[nPosPrepared][1]:setString(nDbPar++,'S')
		EndIf
		aPrepared[nPosPrepared][1]:setString(nDbPar++,' ')

		cAliasTmp := aPrepared[nPosPrepared][1]:OpenAlias()

		(cAliasTmp)->(dbGoTop())
		
		While !(cAliasTmp)->(Eof())

			cSeek := xFilial('SB7') + DTOS( dDataRef ) + (cAliasTmp)->(B7_COD + B7_LOCAL + B7_LOCALIZ + B7_NUMSERI + B7_LOTECTL + B7_NUMLOTE)

			if !(oHSeek:get(cSeek, @nHSeek))

				nY			+= 1
				nTotal     	:= 0
				lSB7Cnt    	:= .T.
				lImprime   	:= .T.
				lSaldo0		:= .F.
				cProduto   	:= (cAliasTmp)->B7_COD
				cLocal     	:= (cAliasTmp)->B7_LOCAL
				cLocaliz   	:= (cAliasTmp)->B7_LOCALIZ
				cNumSeri   	:= (cAliasTmp)->B7_NUMSERI
				cLoteCtl   	:= (cAliasTmp)->B7_LOTECTL
				cNumLote   	:= (cAliasTmp)->B7_NUMLOTE
				cTipo      	:= (cAliasTmp)->B1_TIPO
				cGrupo     	:= (cAliasTmp)->B1_GRUPO
				lEmAberto  	:= .F.
				nTotal     	:= A285Total(cAliasTmp,lContagem,@lEmAberto,@lSB7Cnt)

				oHSeek:Set(cSeek, nY)

				//--------------------------------------------------------------------------
				// Verifica a Quantidade Disponivel/Custo Medio
				//--------------------------------------------------------------------------
				If SB2->(DbSeek(xFilial("SB2")+cProduto+cLocal))
					If (Localiza(cProduto,.T.) .And. !Empty(cLocaliz+cNumSeri)) .Or. (Rastro(cProduto) .And. !Empty(cLotectl+cNumLote))
						If IntDl(cProduto) .and. lWmsNew
							oSaldoWMS 	:= WMSDTCEstoqueEndereco():New()
							aSalQtd   := oSaldoWMS:SldPrdData(cProduto,cLocal,dDataRef,cLoteCtl,cNumLote,cLocaliz,cNumSeri)
						Else
							aSalQtd   := CalcEstL(cProduto,cLocal,dDataRef+1,cLoteCtl,cNumLote,cLocaliz,cNumSeri)
						EndIf
						aSaldo    := CalcEst(cProduto,cLocal,dDataRef+1)
						aSaldo[2] := (aSaldo[2] / aSaldo[1]) * aSalQtd[1]
						aSaldo[3] := (aSaldo[3] / aSaldo[1]) * aSalQtd[1]
						aSaldo[4] := (aSaldo[4] / aSaldo[1]) * aSalQtd[1]
						aSaldo[5] := (aSaldo[5] / aSaldo[1]) * aSalQtd[1]
						aSaldo[6] := (aSaldo[6] / aSaldo[1]) * aSalQtd[1]
						aSaldo[7] := aSalQtd[7]
						aSaldo[1] := aSalQtd[1]
					Else
						aSaldo := CalcEst(cProduto,cLocal,dDataRef+1)
					EndIf
					If cValtoChar( jParams['MV_PAR12'][1])  == "1"
						aCM:={}
						If QtdComp(aSaldo[1]) > QtdComp(0)
							For nX:=2 to Len(aSaldo)
								aAdd(aCM,aSaldo[nX]/aSaldo[1])
							Next nX
						Else
							aCM := PegaCmAtu(cProduto,cLocal)
						EndIf
					Else
						aCM := PegaCMFim(cProduto,cLocal)
					EndIf
				Else
					aSaldo := {0,0}
					aCM    := {0,0,0,0,0}
				EndIf
				
				//--------------------------------------------------------------------------
				// lImprime - Variavel utilizada para verificar se o usuario deseja
				// Listar Produto: 1-Com Diferencas / 2-Sem Diferencas / 3-Todos
				//--------------------------------------------------------------------------
				If nTotal-aSaldo[1] == 0
					If cValToChar(jParams['MV_PAR11'][1]) == "1"
						lImprime := .F.
					EndIf
				Else
					If cValToChar(jParams['MV_PAR11'][1]) == "2"
						lImprime := .F.
					EndIf
				EndIf
			Else
				lSaldo0	:= .T.
				nTotal  := A285Total(cAliasTmp,lContagem,@lEmAberto,@lSB7Cnt)
			EndIF

			//--------------------------------------------------------------------------
			// Impressao do Inventario
			//--------------------------------------------------------------------------
			If lSB7Cnt .AND.(lImprime .Or. cValToChar(jParams['MV_PAR11'][1]) == "3")

				if lSaldo0
					nSaldo := 0
				else
					nSaldo := aSaldo[1]
				endif

				aAllFields	:= self:getStructFields()
				aSX3Fields	:= self:getArrayFields()
				self:jItems	:= JsonObject():New()
			
				For nX := 1 To Len(aAllFields)

					cId := aAllFields[nX]:getName()
					cRealName := aAllFields[nX]:getRealName()

					If aScan( aSX3Fields , { | x | x ==  cRealName } ) > 0
						If aAllFields[nX]:getType() == "date" //Campo tipo data tem um tratamento diferente para envio

							self:jItems[cId] := totvs.framework.treports.date.stringToTimeStamp((cAliasTmp)->&(cRealName))

						Else

							self:jItems[cId] := (cAliasTmp)->&(cRealName)

						EndIf
					EndIf
				Next nX

				self:jItems[ "B7QUANT"	] := nTotal
				self:jItems[ "QUANTDATA"] := nSaldo
				self:jItems[ "DIFQUANT"	] := (nTotal - nSaldo)
				self:jItems[ "DIFVALOR"	] := (nTotal - nSaldo)*aCM[ Val(cValToChar(jParams['MV_PAR10'][1])) ]

				self:processData()
				self:oData:appendData(self:jItems)

			EndIf
		
			(cAliasTmp)->(DBSkip())
		EndDo
		
		(cAliasTmp)->( DBCloseArea() )
	Next

	cFilAnt := cBkpFil

	For nX := 1 To Len(aPrepared)
		aPrepared[nX][1]:Destroy()
	Next
	
	FreeObj(oHSeek)
	FWFreeArray(aPrepared)

return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} oNGetSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema
 
@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method oNGetSchema() Class ListagemItensInventariadosTreportsBusinessObject

	Local aFields as Array

	self:AliasToSchema("SB7")

	aFields := {}
	aAdd( aFields , "B1_COD"		)
	aAdd( aFields , "B1_DESC"		)
	aAdd( aFields , "B1_TIPO"		)
	aAdd( aFields , "B1_UM"			)
	aAdd( aFields , "B1_GRUPO"		)
	aAdd( aFields , "B1_CODITE"		)

	self:AliasToSchema("SB1", aFields)

	self:addProperty( "B7QUANT"		, STR0004	, "number", STR0004	,	"B7QUANT"	) //"QUANTIDADE INVENTARIADA"
	self:addProperty( "QUANTDATA"	, STR0005	, "number", STR0005	,	"QUANTDATA"	) //"QTD NA DATA DO INVENTARIO"
	self:addProperty( "DIFQUANT"	, STR0006	, "number", STR0006	,	"DIFQUANT"	) //"DIFERENCA QUANTIDADE"
	self:addProperty( "DIFVALOR"	, STR0007	, "number", STR0007	,	"DIFVALOR"	) //"DIFERENCA VALOR"

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A285Total
Função responsável por calcular a quantidade inventariada, identificando
lançamentos processados e não processados

@author Squad Entradas
@param cAliasTmp  Alias temporário com registros da tabela SB7
@param lContagem  Informa se o inventário por contagem está habilitado 
@param lEmAberto  Variável responsável por informar se existe lançamentos
				  de inventário em aberto para o produto
@param lSB7Cnt    Informa se a linha do produto deve ou não ser impressa

@since 20/01/2023
@version P12
@return
/*/
//-------------------------------------------------------------------
Static Function A285Total(cAliasTmp,lContagem,lEmAberto,lSB7Cnt)

	Local nTotal as Numeric

	nTotal := 0

	If lContagem
		nTotal += (cAliasTmp)->B7_QUANT
	Else
		If (cAliasTmp)->B7_STATUS == "1"
			nTotal 	   := (cAliasTmp)->B7_QUANT
			lEmAberto  := .T.
		Else
			If !lEmAberto
				nTotal += (cAliasTmp)->B7_QUANT
			Else
				lSB7Cnt := .F.
			EndIf
		EndIf
	EndIf

Return nTotal
