#include "msobject.ch"
#include "protheus.ch"
#include "backoffice.sv.est.balanceinprocess.ch"
#include "totvs.framework.treports.integratedprovider.th"

#DEFINE SX1GRUPO "ESTT022"

using namespace totvs.protheus.backoffice.est.smartView.integratedProvider
namespace totvs.protheus.backoffice.est.balanceinprocess.integratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAEST", tables="SB1,SD3",name="Saldo em Processo", country="ALL")

//-------------------------------------------------------------------
/*{Protheus.doc} balanceinprocessSmartViewBusinessObject
Classe para criação do Objeto de Negócio de Prodotos
 
@author  Michel Sander
@since   09/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Class balanceinprocessSmartViewBusinessObject From totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider

	Public Method new() as object
	Public Method getData() as object

	Protected Method oNGetSchema()
	Protected data aFields as array
	Protected data jItems  as json
	Protected data cWhere  as character
	Protected data lExistPergunte as Logical

EndClass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
 
@return object: self
 
@author Michel Sander
@since  09/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method new() Class balanceinprocessSmartViewBusinessObject

	_Super:new()

	//Define a Área
	self:appendArea( STR0001 )			//#Estoque Custos

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0002 )		//#Saldo em Processo

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 )		//#Tabela Dinâmica e Visão de Dados para demonstrar os saldos de produtos em processo.

	//Grupo de Perguntas
	self:lExistPergunte := self:SetPergunte(SX1GRUPO)
	If !self:lExistPergunte
		cMsgSX1 := OemToAnsi(I18N(STR0004,{SX1GRUPO})) //#Grupo de perguntas #1[SX1GRUPO]# nao encontrado. Verifique na tabela SX1, o grupo de perguntas informado
		self:setErrorStatus(400,STR0005,cMsgSX1)		//#Sem Pergunte
		FwLogMsg("WARN",, "SmartView ESTSV039",,,,cMsgSX1,,,)
	EndIf

	//Indica que o LookUp será do tipo padrão LookUp
	self:setIsLookUp(.T.)
	self:aFields := {}

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio
 
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do TReports
 
@return object: self:oData
 
@author Michel Sander
@since 09/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method getData( nPage as Numeric, oFilter as object) as object Class balanceinprocessSmartViewBusinessObject

	Local cQuery	   as Character
	Local cFields	   as Character
	Local cProdMNT 	   as Character
	Local cLocProc     as Character
	Local dDataRef     as Character
	Local cChaveAnt    as Character
	Local cChave 	   as Character
	Local cSB1Alias    as Character
	Local nQTotal      as Numeric
	Local nCusTotal    as Numeric 
	Local nFifTotal    as Numeric
	Local nCusFF 	   as Numeric
	Local nQtdMedia    as Numeric
	Local nQtNeces     as Numeric
	Local nQtde        as Numeric
	Local nCusto       as Numeric
	Local nCustFF      as Numeric
	Local nQtdAcum     as Numeric
	Local nProdPR0     as Numeric 
	Local nQtdOrigem   as Numeric
	Local nQtdProduz   as Numeric 
	Local nProporcao   as Numeric
	Local nFil         as Numeric
	local nPosPrepared as numeric
	Local nX           as numeric
	local aPrepared    as array
	Local aSald 	   as Array
	Local aProd   	   as Array
	Local aProc   	   as Array
	Local jParams	   as Json
	Local lImprime     as Logical
	Local cFiltro      as Character
	Local cBkpFil      as Character
	local cMD5		   as Character
	Local cFilExec     as Character
	Local cEmpExec     as Character

	Local lMT460EP     as Logical 

	Private cAliasNew  as Character
	Private cNumOP 	   as Character
	Private cItemOP    as Character
	Private cSeqOP     as Character
	Private cItGrdOP   as Character
	Private cDatPrf    as Character
	Private cD3op      as Character

	If !self:lExistPergunte
		Return self:oData
	EndIf

	//Variaveis
	jParams   := oFilter:getParameters() //metodo para retorno do json dos parâmetros
	aPrepared := {}

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'], oFilter)

	//Variáveis com o nome da Filial e Grupo de Empresa
	cFilExec := AllTrim(FWFilialName())
	cEmpExec := AllTrim(FWEmpName(cEmpAnt))
	dDataRef := FwDateTimeToLocal( jParams['MV_PAR06'][1] )[1]
	cFields	 := "D3_FILIAL," + self:getSqlFields(.F.) + ",D3_QUANT,D3_CUSTO1,D3_CUSFF1"
	cBkpFil  := cFilAnt

	//Colocar while ou for de filiais aqui 
	For nFil :=1 to len(self:aFils)

		cFilAnt   := self:aFils[nFil]
		cFilExec  := AllTrim(FWFilialName())

		nBind     := 1
		nQTotal   := 0
		nCusTotal := 0
		nFifTotal := 0
		nQtdAcum  := 0
		cLocProc  := AllTrim(GetMV("MV_LOCPROC"))
		cProdMNT  := SuperGetMv("MV_PRODMNT",.F., 'MANUTENCAO' )
		nProdPR0  := SuperGetMv("MV_PRODPR0",.F.,1)
		lMT460EP  := SuperGetMv("MV_MT460EP",.F.,.F.)
		cFiltro   := " AND "
		
		//Inicializa as variáveis Private
		bpIniVar()

		//Montagem da query
		cQuery := " SELECT ?,B1_TIPO,B1_UM,D3_TM,D3_PERDA,D3_RATEIO,D3_TRT,C2_QUANT,C2_PERDA "//1
		cQuery += " FROM " +RetSQLName("SD3")+ " SD3 "
		cQuery += " INNER JOIN " + RetSqlName("SB1") + " SB1 "
		cQuery += " ON SB1.B1_FILIAL = ? "//2
		cQuery += " AND SB1.B1_COD = SD3.D3_COD "
		cQuery += " AND SB1.D_E_L_E_T_ = ? "//3
		cQuery += " INNER JOIN " + RetSqlName("SC2") + " SC2 "
		cQuery += " ON SC2.C2_FILIAL   = ? "//4
		cQuery += " AND SC2.C2_NUM     = ? "//5
		cQuery += " AND SC2.C2_ITEM    = ? "//6
		cQuery += " AND SC2.C2_SEQUEN  = ? "//7
		cQuery += " AND SC2.C2_ITEMGRD = ? "//8
		cQuery += " AND SC2.C2_PRODUTO <> ? "//9
		cQuery += " AND (SC2.C2_DATRF  = ? " //10 
		cQuery += " OR SC2.C2_DATRF    > ? ) " //11 
		cQuery += " AND SC2.D_E_L_E_T_ = ? "//12
		cQuery += " WHERE SD3.D3_FILIAL = ? "//13
		cQuery += " AND SD3.D3_COD   >= ? "//15
		cQuery += " AND SD3.D3_COD   <= ? "//16
		cQuery += " AND SD3.D3_LOCAL >= ? "//17
		cQuery += " AND SD3.D3_LOCAL <= ? "//18
		cQuery += " AND SD3.D3_EMISSAO <= ? "//20
		cQuery += " AND SD3.D3_CF NOT IN (?) "//19
		cQuery += " AND SD3.D3_ESTORNO = ? "//21 
		cQuery += " AND SD3.D3_OP    <> ? " //14 
		cQuery += " AND SD3.D_E_L_E_T_ = ? "//22
		
		//Os filtros serão setados na interface do novo TReports
		cQuery += self:cWhereFiltroSV
		cQuery += self:cWhere
		
		//Ordem de impressão dos Saldos
		If jParams["MV_PAR07"][1] == 1
			cQuery += " ORDER BY D3_FILIAL, D3_COD, D3_OP,D3_EMISSAO,SD3.R_E_C_N_O_"
		Else
			cQuery += " ORDER BY D3_FILIAL, D3_COD, D3_OP,D3_SEQCALC,SD3.R_E_C_N_O_"
		EndIf

		cQuery := ChangeQuery(cQuery)

		cMD5 := MD5(cQuery)
		If (nPosPrepared := Ascan(aPrepared,{|x| x[2] == cMD5})) == 0
			cQuery := ChangeQuery(cQuery)
			Aadd(aPrepared,{FwExecStatement():New(cQuery),cMD5})
			nPosPrepared := Len(aPrepared)
		Endif

		//Binding
		aPrepared[nPosPrepared][1]:SetUnsafe(nBind++, cFields)
		aPrepared[nPosPrepared][1]:SetString(nBind++, FwxFilial("SB1"))
		aPrepared[nPosPrepared][1]:SetString(nBind++, ' ')
		aPrepared[nPosPrepared][1]:SetString(nBind++, FwxFilial("SC2"))
		aPrepared[nPosPrepared][1]:SetUnsafe(nBind++, cNumOP)
		aPrepared[nPosPrepared][1]:SetUnsafe(nBind++, cItemOp)
		aPrepared[nPosPrepared][1]:SetUnsafe(nBind++, cSeqOP)
		aPrepared[nPosPrepared][1]:SetUnsafe(nBind++, cItGrdOP)
		aPrepared[nPosPrepared][1]:SetString(nBind++, cProdMNT)
		aPrepared[nPosPrepared][1]:SetString(nBind++, cDatPrf)
		aPrepared[nPosPrepared][1]:SetString(nBind++, Dtos(dDataRef))
		aPrepared[nPosPrepared][1]:SetString(nBind++, ' ')
		aPrepared[nPosPrepared][1]:SetString(nBind++, FwxFilial("SD3"))
		aPrepared[nPosPrepared][1]:SetString(nBind++, jParams["MV_PAR01"][1])
		aPrepared[nPosPrepared][1]:SetString(nBind++, jParams["MV_PAR02"][1])
		aPrepared[nPosPrepared][1]:SetString(nBind++, jParams["MV_PAR03"][1])
		aPrepared[nPosPrepared][1]:SetString(nBind++, jParams["MV_PAR04"][1])
		aPrepared[nPosPrepared][1]:SetString(nBind++, Dtos(dDataRef))
		aPrepared[nPosPrepared][1]:SetIn(nBind++, {'ER0','ER1'})
		aPrepared[nPosPrepared][1]:SetString(nBind++, ' ')	
		aPrepared[nPosPrepared][1]:SetString(nBind++, cD3op)
		aPrepared[nPosPrepared][1]:SetString(nBind++, ' ')
		
		//Executa Query
		cAliasNew := aPrepared[nPosPrepared][1]:OpenAlias()

		While (cAliasNew)->(!Eof())
			//Zera variaveis		
			nQTotal    := 0
			nCusTotal  := 0
			nFifTotal  := 0
			nCusto     := 0
			nCustFF    := 0
			nQtdOrigem := 0
			nQtdProduz := 0
			nProporcao := 0
			
			cChave := (cAliasNew)->(D3_FILIAL+D3_COD+D3_OP)
			aProd  := getProd((cAliasNew)->D3_OP,dDataRef,jParams)
			
			//Considera Mão de Obra
			If jParams["MV_PAR05"][1] == 2
				If IsProdMod((cAliasNew)->D3_COD)					
					(cAliasNew)->(dbSkip())
					Loop					
				EndIf
			EndIf
		
			While (cAliasNew)->(!Eof()) .And. cChave == (cAliasNew)->(D3_FILIAL+D3_COD+D3_OP)
				if aProd[1] == 0 .and. SubStr(AllTrim((cAliasNew)->D3_CF),1,2) <> "PR"
					lImprime  := .t.
					nQtde 	  := (cAliasNew)->D3_QUANT
					nCusto 	  := (cAliasNew)->D3_CUSTO1
					nCustFF	  := (cAliasNew)->D3_CUSFF1
				else
					//MT460EP
					if lMT460EP
						If nProdPR0 == 1
							nProporcao := 0 
						ElseIf nProdPR0 == 2
							nProporcao := 1 - (aProd[3] / 100)
						ElseIf nProdPR0 == 3
							nQtdOrigem := (cAliasNew)->C2_QUANT - (cAliasNew)->C2_PERDA
							nQtdProduz := aProd[1] - aProd[2] 
							nProporcao := 1 - ( nQtdProduz / nQtdOrigem )
						EndIf
					EndIf
					
					if cChaveAnt != (cAliasNew)->(D3_OP+D3_COD+D3_LOCAL+D3_TRT)
						cChaveAnt := (cAliasNew)->(D3_OP+D3_COD+D3_LOCAL+D3_TRT)
						nQTotal := 0
						nCusTotal:= 0
						nFifTotal := 0
						nQtde := 0
						nQtdAcum := 0
					EndIf

					aProc := checkReq((cAliasNew)->D3_OP,(cAliasNew)->D3_COD,(cAliasNew)->D3_LOCAL,(cAliasNew)->D3_TRT,(cAliasNew)->C2_QUANT)

					If aProc[1]
						nQtdMedia := aProc[2]
					Else
						nQtdMedia := (cAliasNew)->D3_QUANT / ((cAliasNew)->C2_QUANT - (cAliasNew)->C2_PERDA)
					endIf
					lImprime := .f.
					
					if lMT460EP
						nQtNeces  := (aProd[1]+aProd[2]) * nQtdMedia
					else
						nQtNeces  := aProd[1] * nQtdMedia
					EndIf
					
					If SubStr(AllTrim((cAliasNew)->D3_CF),1,2) == "RE"
						if aProc[1]
							nQTotal   += (cAliasNew)->D3_QUANT
							nCusTotal += (cAliasNew)->D3_CUSTO1
							nFifTotal += (cAliasNew)->D3_CUSFF1						
						else
							nQTotal   := (cAliasNew)->D3_QUANT
							nCusTotal := (cAliasNew)->D3_CUSTO1
							nFifTotal := (cAliasNew)->D3_CUSFF1						
						EndIf
					else
						nQTotal   := -(cAliasNew)->D3_QUANT
						nCusTotal := -(cAliasNew)->D3_CUSTO1
						nFifTotal := -(cAliasNew)->D3_CUSFF1
					EndIf
					If SubStr(AllTrim((cAliasNew)->D3_CF),1,2) == "DE"	
						If lMT460EP .and. nProdPR0 == 1
							lImprime := .F.
						Else		  
							lImprime := .t.				
							nQtdAcum  += nQtde					
							nQtde 	  := -(cAliasNew)->D3_QUANT
							nCusto 	  := -(cAliasNew)->D3_CUSTO1
							nCustFF	  := -(cAliasNew)->D3_CUSFF1			
						EndIf
					elseif nQTotal > nQtNeces .and. SubStr(AllTrim((cAliasNew)->D3_CF),1,2) <> "PR"
						if lMT460EP .and. nProdPR0 == 1
							lImprime := .f.
						Else
							lImprime := .t.				
							nQtdAcum  += nQtde
							if aProc[1]
								nQtde      := nQTotal - (nQtNeces + nQtdAcum)
							else
								nQtde      := nQTotal - nQtNeces
							EndIf
							if lMT460EP
								nCusto     := nCusTotal * nProporcao
								nCustFF    := nFifTotal * nProporcao
							else
								nCusto     := (nCusTotal / nQTotal) * nQtde
								nCustFF    := (nFifTotal / nQTotal) * nQtde
							EndIf
						EndIf
					endIf				
				EndIf

				if lImprime 
					cFilExec    := AllTrim(FWFilialName())
					self:jItems := JsonObject():New()
					self:jItems["D3_COD"]     := (cAliasNew)->D3_COD
					self:jItems["B1_DESC"]    := (cAliasNew)->B1_DESC
					self:jItems["D3_UM"]      := (cAliasNew)->B1_UM
					self:jItems["D3_OP"]      := (cAliasNew)->D3_OP
					self:jItems["D3_LOCAL"]   := (cAliasNew)->D3_LOCAL
					self:jItems["D3_CF"]      := (cAliasNew)->D3_CF
					if (cAliasNew)->D3_TM > '500'
						self:jItems["QTDTOTAL"]   := nQtde
						self:jItems["CUSTOTAL"]   := nCusto
						self:jItems["FIFTOTAL"]   := nCustFF
					else
						if lMT460EP
							self:jItems["QTDTOTAL"]   := -nQtde
							self:jItems["CUSTOTAL"]   := -nCusto
							self:jItems["FIFTOTAL"]   := -nCustFF						
						else
							self:jItems["QTDTOTAL"]   := -abs(nQtde)
							self:jItems["CUSTOTAL"]   := -abs(nCusto)
							self:jItems["FIFTOTAL"]   := -abs(nCustFF)
						EndIf
					EndIf				
					self:jItems["FILNOME"] := cFilExec
					self:jItems["EMPNOME"] := cEmpExec
					self:processData()
					self:oData:appendData(self:jItems)
				EndIf

				(cAliasNew)->(dbSkip())
				
			EndDo							

		EndDo

		//Se for para exibir os itens do armazem de processo 
		If jParams["MV_PAR08"][1] == 1 
			cSB1Alias := armProc(jParams)
			While (cSB1Alias)->(!Eof())	
				aSald := CalcEst((cSB1Alias)->B1_COD,cLocProc,daySum(dDataRef,1),nil)
				nCusFF := CalcEstFF((cSB1Alias)->B1_COD,cLocProc,daysum(dDataRef,1),nil)[1]
				self:jItems := JsonObject():New()
				self:jItems["D3_COD"]   := (cSB1Alias)->B1_COD
				self:jItems["B1_DESC"]  := (cSB1Alias)->B1_DESC
				self:jItems["D3_UM"]    := (cSB1Alias)->B1_UM
				self:jItems["D3_OP"]    := ' '
				self:jItems["D3_LOCAL"] := cLocProc
				self:jItems["D3_CF"]    := ' '
				self:jItems["QTDTOTAL"] := aSald[1]
				self:jItems["CUSTOTAL"] := aSald[2]
				self:jItems["FIFTOTAL"] := nCusFF
				self:jItems["FILNOME"]  := cFilExec
				self:jItems["EMPNOME"]  := cEmpExec
				self:processData()
				self:oData:appendData(self:jItems)
				(cSB1Alias)->(dbSkip())
			EndDo
			(cSB1Alias)->(DBCloseArea())
		EndIf

		(cAliasNew)->(DBCloseArea())

	Next 

	cFilAnt := cBkpFil 
	For nX := 1 To Len(aPrepared)
		aPrepared[nX][1]:Destroy()
	Next
	FWFreeArray(aPrepared)

Return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema
 
@author Michel Sander
@since 09/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method oNGetSchema() Class balanceinprocessSmartViewBusinessObject

	Local aFieldsSD3 as Array
	Local aFieldsSB1 as Array

	aFieldsSD3 := {"D3_COD", "D3_OP", "D3_LOCAL", "D3_UM", "D3_CF" }
	aFieldsSB1 := {"B1_DESC"}

	self:AliasToSchema("SD3",aFieldsSD3)
	self:AliasToSchema("SB1",aFieldsSB1)

	self:oSchema:addProperty("QTDTOTAL"     , STR0006, "number", STR0006, "QTDTOTAL")		//#"Soma de Qtde  em Processo"
	self:oSchema:addProperty("CUSTOTAL"     , STR0007, "number", STR0007, "CUSTOTAL")		//#"Soma de Valor em Processo"
	self:oSchema:addProperty("FIFTOTAL"     , STR0008, "number", STR0008, "FIFTOTAL")		//#"Soma de Valor FIFO em Processo"
	self:oSchema:addProperty("FILNOME"       , STR0009, "string", STR0009, "FILNOME")
	self:oSchema:addProperty("EMPNOME"       , STR0010, "string", STR0010, "EMPNOME")

Return

/*/{Protheus.doc} bpIniVar
Função responsável por inicializar as variáveis privates
@author Squad Entradas
@since 06/04/2022
/*/
Static Function bpIniVar()
Local nNumOP   := TamSX3("C2_NUM")[1] as numeric
Local nItemOP  := TamSX3("C2_ITEM")[1] as numeric
Local nSeqOP   := TamSX3("C2_SEQUEN")[1] as numeric
Local nItGrdOP := TamSX3("C2_ITEMGRD")[1] as numeric
Local nD3Op    := TamSX3("D3_OP")[1] as numeric
Local nDatPrf  := TamSX3("C2_DATPRF")[1] as numeric
Local cDbType  := TCGetDB()

If cDbType $ "DB2|POSTGRES|ORACLE|INFORMIX"
	cNumOP   := "SUBSTR(D3_OP,1," + cValToChar(nNumOP) + ")"
	cItemOP  := "SUBSTR(D3_OP," + cValToChar(nNumOP + 1) + "," + cValToChar(nItemOP) + ")"
	cSeqOP   := "SUBSTR(D3_OP," + cValToChar(nNumOP + nItemOP + 1) + "," + cValToChar(nSeqOP) + ")"
	cItGrdOP := "SUBSTR(D3_OP," + cValToChar(nNumOP + nItemOP + nSeqOP + 1) + "," + cValToChar(nItGrdOP) + ")"
Else
	cNumOP   := "SUBSTRING(D3_OP,1," + cValToChar(nNumOP) + ")"
	cItemOP  := "SUBSTRING(D3_OP," + cValToChar(nNumOP + 1) + "," + cValToChar(nItemOP) + ")"
	cSeqOP   := "SUBSTRING(D3_OP," + cValToChar(nNumOP + nItemOP + 1) + "," + cValToChar(nSeqOP) + ")"
	cItGrdOP := "SUBSTRING(D3_OP," + cValToChar(nNumOP + nItemOP + nSeqOP + 1) + "," + cValToChar(nItGrdOP) + ")"
EndIf

cD3op    := space(nD3Op)
cDatPrf  := space(nDatPrf)

Return

/*/{Protheus.doc} armProc
Traz os produtos do armazem de processo
@author Rodrigo Lombardi
@since 13/08/2024
@version 1.0
/*/
Static Function armProc(jParams) 
Local oQuery as object
Local cQuery as Character
Local cSB1Alias as Character
Local lM460PRC as Logical
Local nX := 1  as Numeric
lM460PRC := SuperGetMv("MV_M460PRC",.F.,.F.)

cQuery := " SELECT B1_FILIAL, B1_COD, B1_DESC,B1_UM "
cQuery += " FROM "+RetSQLName('SB1')+" SB1 "
cQuery += " WHERE SB1.B1_FILIAL = ? "//1
cQuery += " AND SB1.B1_COD >= ? "//2 
cQuery += " AND SB1.B1_COD <= ? "//3
//Considero somente os indiretos
if !lM460PRC
	cQuery += "AND SB1.B1_APROPRI = ? "//4
EndIf
cQuery += " AND SB1.D_E_L_E_T_ = ? "//5

cQuery := changeQuery(cQuery)
oQuery := FwExecStatement():New(cQuery)
oQuery:setString(nX++,FwXfilial('SB1'))//Filial
oQuery:setString(nX++,jParams["MV_PAR01"][1])//Produto de
oQuery:setString(nX++,jParams["MV_PAR02"][1])//Produto Ate
if !lM460PRC
	oQuery:setString(nX++,'I')//Apenas o que for indireto
EndIf
oQuery:setString(nX++,' ')//D_E_L_E_T_ = ' '
cSB1Alias := oQuery:OpenAlias()

return cSB1Alias

/*/{Protheus.doc} CheckReq
Confere as requisições daquela OP
@author Rodrigo Lombardi
@since 14/08/2024
@version version
/*/

Static Function checkReq(cOp,cCod,cLocal,cTrt,nQtd)
Local oQuery2 as object
Local cQuery as Character
Local cSD4Alias as Character
Local nQtMedia := 0 as Numeric
Local aProc := {} as Array
Local lProc := .f. as Logical

cQuery := " SELECT D4_FILIAL, D4_COD,D4_OP,D4_LOCAL,D4_TRT,D4_QTDEORI "
cQuery += " FROM "+RetSQLName('SD4')+" SD4 "
cQuery += " WHERE SD4.D4_FILIAL = ? "//1
cQuery += " AND SD4.D4_OP = ? " //2
cQuery += " AND SD4.D4_COD = ? "//3
cQuery += " AND SD4.D4_LOCAL = ? "//4
cQuery += " AND SD4.D4_TRT = ? "//5
cQuery += " AND SD4.D_E_L_E_T_ = ? "//6
cQuery := changeQuery(cQuery)

oQuery2 := FwExecStatement():New(cQuery)
oQuery2:setString(1,FwXFilial('SD4'))
oQuery2:setString(2,cOp)//OP
oQuery2:setString(3,cCod)//Produto
oQuery2:setString(4,cLocal)//Armazem
oQuery2:setString(5,cTrt)//Estrutura
oQuery2:setString(6,' ')//D_E_L_E_T_ = ' '

cSD4Alias := oQuery2:OpenAlias()

While(cSD4Alias)->(!Eof())
	lProc := .t.
	If Rastro(cCod)
		nQtMedia  := M460MdPrc((cSD4Alias)->D4_COD,(cSD4Alias)->D4_OP,(cSD4Alias)->D4_LOCAL,nQtd,(cSD4Alias)->D4_TRT)
	Else
		nQtMedia  := (cSD4Alias)->D4_QTDEORI / nQtd
	EndIf	
	(cSD4Alias)->(dbSkip())
EndDo
(cSD4Alias)->(DBCloseArea())
oQuery2:Destroy()
aAdd(aProc,lProc)
aAdd(aProc,nQtMedia)

Return aProc

/*/{Protheus.doc} getProd
Traz os valores PR0 e PR1 da OP
@author Rodrigo Lombardi
@since 15/08/2024
@version version
/*/

Static Function getProd(cOp,dDataRef,jParams)
Local oQuery3 as object
Local cQuery as Character
Local cOpalias as Character
Local aProd := {} as Array
cQuery := " SELECT SUM(D3_QUANT) AS QUANT,SUM(D3_PERDA) AS PERDA,SUM(D3_RATEIO) AS RATEIO "
cQuery += " FROM "+RetSQLName('SD3')+" SD3 "
cQuery += " WHERE SD3.D3_FILIAL = ? "//1
cQuery += " AND SD3.D3_OP = ? " //2
cQuery += " AND SD3.D3_LOCAL >= ? "//3
cQuery += " AND SD3.D3_LOCAL <= ? "//4
cQuery += " AND SD3.D3_ESTORNO = ? "//5
cQuery += " AND SD3.D3_CF IN (?) "//6
cQuery += " AND SD3.D3_EMISSAO <= ? "//7
cQuery += " AND SD3.D_E_L_E_T_ = ? " //8

cQuery := changeQuery(cQuery)

oQuery3 := FwExecStatement():New(cQuery)
oQuery3:setString(1,FwXFilial('SD3'))//Filial
oQuery3:setString(2,cOp)//OP
oQuery3:setString(3,jParams["MV_PAR03"][1])//Produto
oQuery3:setString(4,jParams["MV_PAR04"][1])//Produto
oQuery3:setString(5,' ')//Estorno
oQuery3:setIn(6,{'PR1','PR0'})//CF
oQuery3:setString(7,DTOS(dDataRef))//dataref)
oQuery3:setString(8,' ')//D_E_L_E_T_ = ' '

cOpalias := oQuery3:OpenAlias()
aAdd(aProd,oQuery3:ExecScalar('QUANT'))
aAdd(aProd,oQuery3:ExecScalar('PERDA'))
aAdd(aProd,oQuery3:ExecScalar('RATEIO'))
(cOpalias)->(DBCloseArea())
oQuery3:Destroy()

Return aProd
