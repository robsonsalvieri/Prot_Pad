#include "TOTVS.ch"
#include "backoffice.sv.est.differencesinmultiplecountings.ch"
#include "totvs.framework.treports.integratedprovider.th"

#DEFINE SX1GRUPO "ESTT019"

namespace totvs.protheus.backoffice.est.differencesinmultiplecountings.integratedprovider
using namespace totvs.protheus.backoffice.est.smartView.integratedProvider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAEST", tables="SB1,SB7", name="Divergencias em Multiplas Contagens", country="ALL", customTables="SB1,SB7")

//-------------------------------------------------------------------
/*{Protheus.doc} DifferencesinMultipleCountingsSmartViewBusinessObject 
Classe para criação do Objeto de Negócio de Divergencias em Multiplas Contagens
@type Class 
@author Breno Nogueira 
@since 08/2023
@version 1.0
*/
//-------------------------------------------------------------------
Class DifferencesinMultipleCountingsSmartViewBusinessObject From totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider

	Public Method new() as object
	Public Method getData() as object
	
	Protected Method oNGetSchema()
	Protected data cAlias 		  as character
	Protected data cWhere		  as character
	Protected data aFieldsSB1	  as array
	Protected data aFieldsSB7	  as array
	Protected data lExistDic 	  as logical

	Public data jItems as json

EndClass

//-------------------------------------------------------------------
/*{Protheus.doc} DifferencesinMultipleCountingsSmartViewBusinessObject
Método de instáncia da classe

@return object: self
@author Breno Nogueira
@since 08/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method new() Class DifferencesinMultipleCountingsSmartViewBusinessObject

	_Super:new()

	//Define a area
	self:appendArea( STR0001 )// "Estoque/Custos"

	//Define o nome do Objeto de Negocio
	self:setDisplayName( STR0002 ) // "Divergencias em Multiplas Contagens"

	//Define a descrição do Objeto de Negocio
	self:setDescription( STR0003 + STR0004 + STR0005 ) 	// "Emite uma relacao que mostra os produtos que tem contagens 
	//divergentes, em quantidade, efetuadas no inventario em uma data."

	//Indica o pergunte que será utilizado no relatório
	self:setPergunte(SX1GRUPO)

	self:lExistDic := .T.

	//Grupo de Perguntas
	If !self:setPergunte(SX1GRUPO)
		self:setErrorStatus(400,STR0006,i18n(STR0007,{SX1GRUPO}))//Grupo de pergunte não existe		
		FWLogMsg('WARN', , 'SmartView', , , , i18n(STR0007,{SX1GRUPO}), , , )//O Grupo de perguntas #1 não existe
		self:lExistDic := .F.
	EndIf

	//Validação de multiplas contagens
	If self:lExistDic
		If !GetMv('MV_CONTINV',.F.,.F.)
			self:setErrorStatus(400,STR0008,STR0009)// Múltiplas Contagens	
			FWLogMsg('WARN', , 'SmartView', , , , STR0009, , , )// O objeto de negócio poderá ser utilizado apenas;
			//com o controle de contagens de inventário habilitado (MV_CONTINV).
			self:lExistDic := .F.
		EndIf
	EndIf 

	//Indica que o LookUp será do tipo padrão LookUp
 	self:setIsLookUp(.T.)

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negocio

@param nPage, numerico, indica a pagina atual do relatorio
@param oFilter, objeto, contém o filtro do TReports

@return object: self:oData

@author Breno Nogueira
@since 08/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getData( nPage as Numeric, oFilter as object) as object Class DifferencesinMultipleCountingsSmartViewBusinessObject
	local oQuery as object
	local cQuery     as character
	local cDataCon   as character
	local cSeek		 as character
	local cSeekAnt	 as character
	local cSeekReg	 as character
	local jParams    as json
	local lVeiculo   as logical
	local lFirstLoop := .T. as logical
	local aAllFields as array
	local aReg := {} as array
	local nFil       as numeric
	local cBkpFil    as Character

	If !self:lExistDic
	   Return self:oData 
	EndIf 

	self:cAlias := GetNextAlias()
	jParams  	:= oFilter:getParameters()

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'])

	lVeiculo 	:= GetMV("MV_VEICULO", .F., "N") == "S"
	cDataCon 	:= SubStr(StrTran(jParams['MV_PAR09'][1],"-",""),1,8)

	//--------------------------------------------------------------------------
	// Variaveis utilizadas para parametros no grupo de pergunta ESTT019 
	//--------------------------------------------------------------------------
	//
	//X1_ORDEM X1_PERGUNT                     X1_VARIAVL X1_TAMANHO             X1_F3  X1_GRPSXG
	//-------- ------------------------------ ---------- ---------------------- ------ ---------
	//01       Produto de ?                   MV_CH1     30                     SB1    030
	//02       Produto ate ?                  MV_CH2     30                     SB1    030
	//03       De Tipo ?                      MV_CH3     2                      02
	//04       Ate Tipo ?                     MV_CH4     2                      02
	//05       Do Armazem ?                   MV_CH5     2                      NNR    024
	//06       Ate Armazem ?                  MV_CH6     2                      NNR    024
	//07       De Grupo ?                     MV_CH7     4                      SBM	   162
	//08       Ate Grupo ?                    MV_CH8     4                      SBM    162
	//09       Data de Contagem ?             MV_CH9     8

	cQuery := " SELECT ? " //1
	cQuery += " FROM " + RetSQLName("SB7") + " SB7"
	cQuery += " JOIN " + RetSQLName("SB1") + " SB1"
	cQuery += " ON SB1.B1_FILIAL = ?"	//2
	cQuery += " AND SB1.B1_COD = SB7.B7_COD"
	cQuery += " AND SB1.D_E_L_E_T_ = ?"	//3
	cQuery += " WHERE SB7.B7_FILIAL = ? "	//4
	cQuery += " AND SB7.B7_DATA = ? " //5

	If !lVeiculo
		cQuery += " AND SB1.B1_COD BETWEEN ? AND ?"	//6 e 7
	Else
		cQuery += " AND SB1.B1_CODITE BETWEEN ? AND ?" //6 e 7
	EndIf

	cQuery += " AND SB7.B7_LOCAL BETWEEN   ? AND ?" //8 e 9
	cQuery += " AND SB1.B1_TIPO BETWEEN    ? AND ?" //10 e 11
	cQuery += " AND SB1.B1_GRUPO BETWEEN   ? AND ?" //12 e 13

	//Os filtros serao setados na interface do novo TReports
	If oFilter:hasFilter()
		cQuery += " AND " + oFilter:getSQLExpression()
	Endif

	cQuery += self:cWhere
	cQuery += " AND SB7.D_E_L_E_T_ = ? " //14

	If !lVeiculo
		cQuery += " ORDER BY SB7.B7_FILIAL, SB7.B7_DATA, SB1.B1_COD, SB7.B7_LOCAL, SB7.B7_LOCALIZ, SB7.B7_NUMSERI, SB7.B7_LOTECTL, SB7.B7_NUMLOTE, B7_CONTAGE"
	Else
		cQuery += " ORDER BY SB7.B7_FILIAL, SB7.B7_DATA, SB1.B1_CODITE, SB7.B7_LOCAL, SB7.B7_LOCALIZ, SB7.B7_NUMSERI, SB7.B7_LOTECTL, SB7.B7_NUMLOTE, B7_CONTAGE"
	EndIf

	oQuery := FwExecStatement():New(cQuery)

	cBkpFil := cFilant 

	//Colocar while ou for de filiais aqui 
	For nFil :=1 to len(self:aFils)

		cFilAnt     := self:aFils[nFil]
		cSeekAnt    := ""
		cSeekReg    := ""
		cSeek       := ""

		oQuery:SetUnsafe(1, self:getSQLFields(.T.))
		oQuery:SetString(2, FWxFilial("SB1"))
		oQuery:SetString(3, ' ')
		oQuery:SetString(4, FWxFilial("SB7"))
		oQuery:SetString(5, cDataCon)
		oQuery:SetString(6, jParams['MV_PAR01'][1])
		oQuery:SetString(7, jParams['MV_PAR02'][1])
		oQuery:SetString(8, jParams['MV_PAR05'][1])
		oQuery:SetString(9, jParams['MV_PAR06'][1])
		oQuery:SetString(10, jParams['MV_PAR03'][1])
		oQuery:SetString(11, jParams["MV_PAR04"][1])
		oQuery:SetString(12, jParams['MV_PAR07'][1])
		oQuery:SetString(13, jParams['MV_PAR08'][1])
		oQuery:SetString(14, ' ')
		oQuery:OpenAlias(self:cAlias)

		aAllFields := self:getStructFields()

		While !(self:cAlias)->(Eof())

			cSeek := (self:cAlias)->B7_FILIAL + (self:cAlias)->B7_DATA + (self:cAlias)->B1_COD + (self:cAlias)->B7_LOCAL + (self:cAlias)->B7_LOCALIZ + (self:cAlias)->B7_NUMSERI + (self:cAlias)->B7_LOTECTL + (self:cAlias)->B7_NUMLOTE
			
			If cSeek <> cSeekAnt

				If lFirstLoop
					lFirstLoop := .F.
				Else
					printLine(aReg, self, aAllFields, self:cAlias)
					aReg := {}
				EndIf

				cSeekAnt := cSeek

			EndIf
			
			aAdd(aReg, {(self:cAlias)->B1_COD,;	//aReg[x][1] = Codigo do Produto	
					(self:cAlias)->B1_DESC,;			//aReg[x][2] = Descricao
					(self:cAlias)->B1_TIPO,;			//aReg[x][3] = Tipo
					(self:cAlias)->B1_GRUPO,;			//aReg[x][4] = Grupo
					(self:cAlias)->B1_UM,;				//aReg[x][5] = Unidade Medida
					(self:cAlias)->B1_CODITE,;			//aReg[x][6] = Codigo do Item
					(self:cAlias)->B7_FILIAL,;			//aReg[x][7] = Filial do Inventário
					(self:cAlias)->B7_DATA,;			//aReg[x][8] = Data do Inventário
					(self:cAlias)->B7_LOCAL,;			//aReg[x][9] = Local
					(self:cAlias)->B7_LOCALIZ,;			//aReg[x][10] = Endereco
					(self:cAlias)->B7_NUMSERI,;			//aReg[x][11] = Serie
					(self:cAlias)->B7_LOTECTL,;			//aReg[x][12] = Lote
					(self:cAlias)->B7_NUMLOTE,;			//aReg[x][13] = SubLote
					(self:cAlias)->B7_CONTAGE,;			//aReg[x][14] = Contagem
					(self:cAlias)->B7_QUANT,;			//aReg[x][15] = Quantidade
					(self:cAlias)->B7_DOC,;				//aReg[x][16] = Documento
					(self:cAlias)->B7_ESCOLHA,;			//aReg[x][17] = Escolha
					(self:cAlias)->B7_STATUS} )			//aReg[x][18] = Status de Processamento de Inventário

			(self:cAlias)->(DbSkip())

		EndDo

		PrintLine(aReg, self, aAllFields, self:cAlias)
		aReg := {}
		(self:cAlias)->(DBCloseArea())

	Next 

	cFilAnt := cBkpFil 
	oQuery:Destroy()

return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura dos campos

@return object: self:oSchema
@author Breno Nogueira
@since 08/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method oNGetSchema() Class DifferencesinMultipleCountingsSmartViewBusinessObject

	self:aFieldsSB1 := {"B1_COD","B1_DESC","B1_TIPO","B1_GRUPO","B1_UM","B1_CODITE"}
	self:aFieldsSB7 := {"B7_FILIAL","B7_DATA","B7_LOCAL","B7_LOCALIZ","B7_NUMSERI","B7_LOTECTL","B7_NUMLOTE","B7_CONTAGE","B7_QUANT","B7_DOC","B7_ESCOLHA","B7_STATUS"}
	
	self:AliasToSchema("SB1",self:aFieldsSB1)
	self:AliasToSchema("SB7",self:aFieldsSB7)

Return

//-------------------------------------------------------------------
/*{Protheus.doc} printLine
Função responsável por validar a existência de contagens divergentes e impressão dos registros

@author Squad Entradas
@since 11/2023
@version 1.0
*/
//-------------------------------------------------------------------
Static Function printLine(aReg as array, self as object, aAllFields as array, cAlias as character)

    local lContDiv as logical
    local nY as numeric
	local nX as numeric
	
	If Len(aReg) > 1 //Controle de múltipla contagem

		lContDiv := .F.	//Reset do controle de contagens divergentes a cada novo produto

		For nY := 1 To Len(aReg)					
			If nY > 1 .And. !lContDiv //A partir da segunda contagem, se nao tiver inventário processado, compara as contagens para encontrar divergencias
				lContDiv := aReg[nY][15] <> aReg[nY-1][15] 
			EndIf
            
            If lContDiv // Se houver ao menos 1 divergência, a impressão ocorrerá independente do número de registros.
                Exit
            EndIf
		Next nY

		If lContDiv //Habilita a impressão somente de produtos que tenham contagem com quantidades divergentes

			For nX := 1 to Len(aReg)
				self:jItems := JsonObject():New()
				For nY := 1 To Len(aAllFields)
					If aAllFields[nY]:getType() == "date"
						self:jItems[aAllFields[nY]:getName()] := totvs.framework.treports.date.stringToTimeStamp(aReg[nX][nY])
					Else
						self:jItems[aAllFields[nY]:getName()] := aReg[nX][nY]
					EndIf
				Next nY

				self:processData()
				self:appendData(self:jItems)

			Next nX
		EndIf
	EndIf

Return
