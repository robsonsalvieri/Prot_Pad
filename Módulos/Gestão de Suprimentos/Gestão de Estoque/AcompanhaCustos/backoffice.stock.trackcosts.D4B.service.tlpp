#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "backoffice.stock.trackcosts.d4b.ch"

namespace totvs.protheus.backoffice.stock.trackcosts.d4b.service
using namespace totvs.protheus.backoffice.stock.trackcosts.d4b.repository
using namespace totvs.protheus.backoffice.stock.trackcosts.model.D4B

/*/{Protheus.doc} D4BService()
    Classe responsavel pelas regras de negocio das requisicoes POST/PUT/PATCH/GET na tabela D4B
    @type Class
    @author Adriano Vieira
    @since 20/01/2023
    @version 1.0
/*/
Class D4BService

    public data oD4BRepository as object
    public data oModelD4B      as object
    public data cError         as character
    public data cEmpty         as character
    public data cId            as character

    public method New()
    public method IsBodyValidD4B()
    public method postInsertD4B()
    public method putUpdateD4B()
    public method patchValidD4B()
    public method getQueryD4B()
    public method deleteQueryD4B()
    public method montaGet()
    public method montaStruct()
    public method getListD4B()
    public method getColumns()
    public method getQuery()
    public method getWhere()
    public method deactivateFilter()
    public method version()

EndClass

/*/{Protheus.doc} New()
    Metodo responsavel por instanciar a classe e iniciar variaveis
    @type Method
    @author Adriano Vieira
    @since 20/01/2023
    @version 1.0
/*/
Method New() Class D4BService
    ::oD4BRepository := totvs.protheus.backoffice.stock.trackcosts.d4b.repository.D4BRepository():new()
    ::oModelD4B      := totvs.protheus.backoffice.stock.trackcosts.model.D4B.D4B():new()
    ::cId := ""
    ::cError := ""
Return Self

/*/{Protheus.doc} postInsertD4B()
    Recebe os dados da requisicao POST e executa as validacoes necessarias
    Caso nao encontrar divergencias, envia para repository
    @type  Metodo
    @author Adriano Vieira
    @since  20/01/2023
    @version 1.0
/*/
Method postInsertD4B(aParameters as array, aBranches, nOperation as numeric) class D4BService

Local lBodyValid    as Logical
Local cUser         as Character
Local dDate         as Date
Local cHora         as Character
Local cId           as Character

::cError := ""
cUser := AllTrim(RetCodUsr())
dDate := MsDate()
cHora := SubStr(Time(),1,TamSx3("D4B_HREXEC")[1])
cId   := Upper(SUBSTR(FWUUIDV1(), 0, 16))

lBodyValid := ::IsBodyValidD4B(aParameters,aBranches)

If lBodyValid
    ::oD4BRepository:setModelD4B(aParameters,cUser,dDate,cHora,cId,aBranches,nOperation) 
    ::cId := cId
EndIf

Return

/*/{Protheus.doc} putUpdateD4B()
    Recebe os dados da requisicao PUT/PATCH e executa as validacoes necessarias
    Caso nao encontrar divergencias, envia para repository
    @type  Metodo
    @author Adriano Vieira
    @since  20/01/2023
    @version 1.0
/*/
Method putUpdateD4B(cId as character, aParameters as array, aBranches, nOperation as numeric) class D4BService

Local lBodyValid    as Logical
Local lIdValid      as Logical
Local lPatchValid   as Logical
Local cUser         as Character
Local cHora         as Character
Local cFilOri       as Character
Local dDate         as Date
Local oObjD4B       as Object

Default cId := ""
lIdValid := .F.
lPatchValid := .F.
oObjD4B := JsonObject():New()
oObjD4B := ::oModelD4B:getById(cId)
cFilOri := oObjD4B["D4B_FILIAL"]

If !Empty(cId) .And. !Empty(cFilOri)
    lIdValid := ::oModelD4B:SEEK(cId, cFilOri)
EndIf

If lIdValid

    lBodyValid := self:patchValidD4B(aParameters,aBranches)

    If lBodyValid
        ::cError := ""
        cUser := AllTrim(RetCodUsr())
        dDate := MsDate()
        cHora := SubStr(Time(),1,TamSx3("D4B_HREXEC")[1])

        ::oD4BRepository:setModelD4B(aParameters,cUser,dDate,cHora,,aBranches,nOperation) 
        ::cId := cId
    EndIf
Else    
    ::cError := STR0002 + cId + STR0003
EndIf

Return


/*/{Protheus.doc} patchValidD4B()
    Recebe os dados da requisicao PUT/PATCH e verifica os tipos
    Caso nao encontrar divergencias, envia para repository
    @type  Metodo
    @author Adriano Vieira
    @since  20/01/2023
    @version 1.0
/*/
Method patchValidD4B(aParameters as array, aBranches) class D4BService

Local lPatchValid   as Logical
Local nX            as Numeric
Local nY            as Numeric

lPatchValid := .T.

For nX  := 1 to Len(aParameters)
    If !Empty(aParameters[nX]["value"]) .AND. lPatchValid
            Do Case
            Case aParameters[nX]["parameter"] == "mv_par01"
                If ValType(aParameters[nX]["value"]) <> "A"
                    lPatchValid := .F.
                    ::cError := STR0004 //"Propriedade de 'produto' (mv_par01) deve ser informada no formato array no corpo da requisição."
                EndIf
            Case aParameters[nX]["parameter"] == "mv_par02"    
                If ValType(aParameters[nX]["value"]) <> "A"
                    lPatchValid := .F.
                    ::cError := STR0005 //"Propriedade de 'tipo' (mv_par02) deve ser informada no formato array no corpo da requisição."
                EndIf
            Case aParameters[nX]["parameter"] == "mv_par03"    
                If ValType(aParameters[nX]["value"]) <> "C"
                    lPatchValid := .F.
                    ::cError := STR0006 //"Propriedade de 'data de' (mv_par03) deve ser informada no formato YYYYMMDD do tipo caractere no corpo da requisição."
                EndIf
            Case aParameters[nX]["parameter"] == "mv_par04"    
                If ValType(aParameters[nX]["value"]) <> "C"
                    lPatchValid := .F.
                    ::cError := STR0007 //"Propriedade de 'data até' (mv_par04) deve ser informada no formato  YYYYMMDD do tipo caractere no corpo da requisição."
                EndIf
            Case aParameters[nX]["parameter"] == "mv_par05"    
                If ValType(aParameters[nX]["value"]) <> "N"
                    lPatchValid := .F.
                    ::cError := STR0008 //"Propriedade de 'Lista Produtos s/ Movimento' (mv_par05) deve ser informada no formato numérico no corpo da requisição."
                EndIf
            Case aParameters[nX]["parameter"] == "mv_par06"    
                If ValType(aParameters[nX]["value"]) <> "A"
                    lPatchValid := .F.
                    ::cError := STR0009 //"Propriedade de 'armazém' (mv_par06) deve ser informada no formato array no corpo da requisição."
                EndIf
            Case aParameters[nX]["parameter"] == "mv_par07"    
                If ValType(aParameters[nX]["value"]) <> "N"
                    lPatchValid := .F.
                    ::cError := STR0010 //"Propriedade de 'moeda' (mv_par07) deve ser informada no formato numérico no corpo da requisição."
                EndIf
            Case aParameters[nX]["parameter"] == "mv_par08"    
                If ValType(aParameters[nX]["value"]) <> "N"
                    lPatchValid := .F.
                    ::cError := STR0011 //"Propriedade de 'Seq.de Digitacao/Calculo' (mv_par08) deve ser informada no formato numérico no corpo da requisição."
                EndIf
            Case aParameters[nX]["parameter"] == "mv_par09"    
                If ValType(aParameters[nX]["value"]) <> "N"
                    lPatchValid := .F.
                    ::cError := STR0012
                EndIf
            Case aParameters[nX]["parameter"] == "mv_par10"    
                If ValType(aParameters[nX]["value"]) <> "A"
                    lPatchValid := .F.
                    ::cError := STR0013
                EndIf
            Case aParameters[nX]["parameter"] == "mv_par11"    
                If ValType(aParameters[nX]["value"]) <> "N"
                    lPatchValid := .F.
                    ::cError := STR0014
                EndIf
        EndCase
    EndIf
Next

If lPatchValid .AND. aBranches <> NIL
    If ValType(aBranches) == "A"
        For nY := 1 to Len(aBranches)
            If aBranches[nY]:HasProperty("Code") .AND. aBranches[nY]:HasProperty("Cgc") .AND. aBranches[nY]:HasProperty("Description")
                If  Empty(aBranches[nY]:GetJsonText("Code")) .OR. ;
                    Empty(aBranches[nY]:GetJsonText("Description")) .OR.;
                    (cPaisLoc <> 'RUS' .And. Empty(aBranches[nY]:GetJsonText("Cgc")) )
                    lPatchValid := .F.
                    ::cError := STR0015
                EndIf
            Else
                lPatchValid := .F.
                ::cError := STR0016
            EndIf
        Next
    Else
        lPatchValid := .F.
        ::cError := STR0017
    EndIf
EndIf

Return lPatchValid


/*/{Protheus.doc} IsBodyValidD4B()
    Recebe os dados da requisicao POST e verifica os tipos, vazio ou obrigatorios
    Caso nao encontrar divergencias, envia para repository
    @type  Metodo
    @author Adriano Vieira
    @since  20/01/2023
    @version 1.0
/*/
Method IsBodyValidD4B(aParameters as array, aBranches) class D4BService

Local lBodyValid    as Logical
Local nY            as Numeric

lBodyValid := .F.

If !(aParameters == NIL)
        If ValType(aParameters[1]["value"]) == "A"
            lBodyValid := .T.
        Else
            ::cError := STR0004
            lBodyValid := .F. 
        EndIf

        If lBodyValid
            If ValType(aParameters[2]["value"]) == "A" 
                lBodyValid := .T.
            Else
                ::cError := STR0005
                lBodyValid := .F. 
            EndIf
        EndIf

        If lBodyValid
            If !Empty(aParameters[3]["value"]) .And. ValType(aParameters[3]["value"]) == 'C'
                If !Empty(STOD(aParameters[3]["value"]))
                    lBodyValid := .T.
                Else
                    ::cError := STR0018 //"Propriedade Data De (mv_par03) deve ser informada no formato data no corpo da requisição."
                    lBodyValid := .F.
                EndIf
            Else
                ::cError := STR0019 //"É obrigatorio o envio da propriedade Data De (mv_par03) no formato data no corpo da requisição."
                lBodyValid := .F.
            EndIf
        EndIf

        If lBodyValid
            If !Empty(aParameters[4]["value"])  .And. ValType(aParameters[4]["value"]) == 'C'
                If  !Empty(STOD(aParameters[4]["value"]))
                    lBodyValid := .T.
                Else
                    ::cError := STR0020 //"Propriedade Data Ate (mv_par04) deve ser informada no formato data no corpo da requisição."
                    lBodyValid := .F.
                EndIf
            Else
                ::cError := STR0021 //"É obrigatorio o envio da propriedade Data Ate (mv_par04) no formato data no corpo da requisição."
                lBodyValid := .F.
            EndIf
        EndIf

        If lBodyValid .And. !Empty(aParameters[5]["value"])
            If ValType(aParameters[5]["value"]) == "N"
                lBodyValid := .T.
            Else
                ::cError := STR0008 //"Propriedade de 'Lista Produtos s/ Movimento' (mv_par05) deve ser informada no formato numérico no corpo da requisição."
                lBodyValid := .F.
            EndIf
        EndIf

        If lBodyValid
            If ValType(aParameters[6]["value"]) == "A"
                lBodyValid := .T.
            Else
                ::cError := STR0022
                lBodyValid := .F.
            EndIf
        EndIf

        If lBodyValid .And. !Empty(aParameters[7]["value"])
            If ValType(aParameters[7]["value"]) == "N"
                lBodyValid := .T.
            Else
                ::cError := STR0010
                lBodyValid := .F.
            EndIf
        EndIf

        If lBodyValid .And. !Empty(aParameters[8]["value"])
            If ValType(aParameters[8]["value"]) == "N"
                lBodyValid := .T.
            Else
                ::cError := STR0011
                lBodyValid := .F.
            EndIf
        EndIf

        If lBodyValid .And. !Empty(aParameters[9]["value"])
            If ValType(aParameters[9]["value"]) == "N"
                lBodyValid := .T.
            Else
                ::cError := STR0012
                lBodyValid := .F.
            EndIf
        EndIf

        If lBodyValid
            If ValType(aParameters[10]["value"]) == "A"
                lBodyValid := .T.
            Else
                ::cError := STR0013
                lBodyValid := .F.
            EndIf
        EndIf

        If lBodyValid .And. !Empty(aParameters[11]["value"])
            If ValType(aParameters[11]["value"]) == "N"
                lBodyValid := .T.
            Else
                ::cError := STR0014
                lBodyValid := .F.
            EndIf
        EndIf
    Endif 

    If lBodyValid .AND. !(aBranches == NIL)
        If ValType(aBranches) == "A"
            For nY := 1 to Len(aBranches)
                If aBranches[nY]:HasProperty("Code") .AND. aBranches[nY]:HasProperty("Cgc") .AND. aBranches[nY]:HasProperty("Description")
                    If  Empty(aBranches[nY]:GetJsonText("Code")) .OR. ;
                        Empty(aBranches[nY]:GetJsonText("Description")) .OR.;
                        (cPaisLoc <> 'RUS' .And. Empty(aBranches[nY]:GetJsonText("Cgc")) )
                        lBodyValid := .F.
                        ::cError := STR0015
                    EndIf
                Else
                    lBodyValid := .F.
                    ::cError := STR0016
                EndIf
            Next
        Else
            lBodyValid := .F.
            ::cError := STR0017
        EndIf
    EndIf

Return lBodyValid


/*/{Protheus.doc} getQueryD4B()
    Recebe o ID que sera realizado o GET no banco
    @type  Metodo
    @author Adriano Vieira
    @since  26/01/2023
    @version 1.0
/*/
Method getQueryD4B(cId as character) class D4BService

Local lIdValid      as Logical
Local oAux          as Object
Local oStructJson   as Object
Local oObjD4B       as Object
Local cFilOri       as Character

Default cId := ""
lIdValid := .F.

::cEmpty := ""
::cError := ""
oObjD4B  := JsonObject():New()
oObjD4B  := ::oModelD4B:getById(cId)
cFilOri  := oObjD4B["D4B_FILIAL"]

If !Empty(cId) .And. !Empty(cFilOri)
    lIdValid := ::oModelD4B:SEEK(cId, cFilOri)
EndIf

If lIdValid
   oAux := ::oD4BRepository:getQueryD4B(cId)
   oStructJson := oAux:ToJson()
Else
   ::cError := STR0023
EndIf

Return oAux

/*/{Protheus.doc} deleteQueryD4B()
    Recebe os dados da requisicao PUT/PATCH e executa as validacoes necessarias
    Caso nao encontrar divergencias, envia para repository
    @type  Metodo
    @author Adriano Vieira
    @since  20/01/2023
    @version 1.0
/*/
Method deleteQueryD4B(cId as character, lAdvPR as Logical) class D4BService

Local lIdValid := .F.     as Logical
Local lRet                as Logical
Local oObjD4B             as Object
Local cFilOri             as Character

Default cId := ""
Default lAdvPR := .F.

oObjD4B  := JsonObject():New()
oObjD4B  := ::oModelD4B:getById(cId)
cFilOri  := oObjD4B["D4B_FILIAL"]

If !Empty(cId) .And. !Empty(cFilOri)
    lIdValid := ::oModelD4B:SEEK(cId, cFilOri)
EndIf

If lIdValid

    ::cError := ""
    lRet := ::oD4BRepository:deleteQueryD4B(cId)
    If !lRet .Or. lAdvPR
        ::cError := STR0026 + cId + STR0027
    EndIf
Else    
    ::cError := STR0028 + cId + STR0029
EndIf

Return

/*/{Protheus.doc} montaGet()
    Recebe o Get e monta a estrutura a ser devolvida no Response
    @type  Metodo
    @author Adriano Vieira
    @since  01/02/2023
    @version 1.0
/*/
Method montaGet(jBodyGetResponse as json) class D4BService

Local oObj       := JsonObject():New()   as Object
Local oAux       := JsonObject():New()   as Object
Local oBranch    := JsonObject():New()   as Object
Local aStruct    := {}                   as Array
Local aParameter := {}                   as Array
Local nX                                 as Numeric
Local cAux                               as Character

aStruct := ::montaStruct(jBodyGetResponse)

For nX := 1 to Len(aStruct)
    
    Aadd(aParameter, JsonObject():New())
    cAux := ("mv_par"+StrZero(nX,2))
    aParameter[nX]["parameter"] := cAux
    
    Do Case
        Case aStruct[nX] == "D4B_PRODUT"
            oAux:FromJson(jBodyGetResponse:GetJsonObject("D4B_PRODUT"))
            aParameter[nX]["value"]    := ACLONE( oAux["products"] )        
        
        Case aStruct[nX] == "D4B_TIPO"
            oAux:FromJson(jBodyGetResponse:GetJsonObject("D4B_TIPO"))
            aParameter[nX]["value"]    := ACLONE( oAux["types"] ) 
        
        Case aStruct[nX] == "D4B_DATAIN"
            aParameter[nX]["value"]    := jBodyGetResponse:GetJsonText("D4B_DATAIN")
        
        Case aStruct[nX] == "D4B_DATAFN"
            aParameter[nX]["value"]    := jBodyGetResponse["D4B_DATAFN"]

        Case aStruct[nX] == "D4B_PRODMO"
            aParameter[nX]["value"]    := jBodyGetResponse["D4B_PRODMO"]

        Case aStruct[nX] == "D4B_LOCAL"
            oAux:FromJson(jBodyGetResponse:GetJsonObject("D4B_LOCAL"))
            aParameter[nX]["value"]    := ACLONE( oAux["warehouses"] ) 

        Case aStruct[nX] == "D4B_MOEDA"
            aParameter[nX]["value"]    := jBodyGetResponse["D4B_MOEDA"]

        Case aStruct[nX] == "D4B_SEQDIG"
            aParameter[nX]["value"]    := jBodyGetResponse["D4B_SEQDIG"]

        Case aStruct[nX] == "D4B_TRANSL"
            aParameter[nX]["value"]    := jBodyGetResponse["D4B_TRANSL"]

        Case aStruct[nX] == "D4B_GRUPO"
            oAux:FromJson(jBodyGetResponse:GetJsonObject("D4B_GRUPO"))
            aParameter[nX]["value"]    := ACLONE( oAux["groups"] ) 

        Case aStruct[nX] == "D4B_TCUSTO"
            aParameter[nX]["value"]    := jBodyGetResponse:GetJsonObject("D4B_TCUSTO")
    EndCase
Next

oBranch:FromJson(jBodyGetResponse:GetJsonObject("D4B_BRANCH"))

oObj["parameters"] := aParameter
oObj["branches"]   := oBranch["branches"]

Return oObj

/*/{Protheus.doc} montaStruct()
    Monta a estrutura a ser devolvida no Responsa apenas com os onze campos pertinentes
    @type  Metodo
    @author Adriano Vieira
    @since  01/02/2023
    @version 1.0
/*/
Method montaStruct(jBodyGetResponse as json) class D4BService

Local aStructAux:= {}                   as Array

Aadd(aStructAux, jBodyGetResponse:GetNames()[2])
Aadd(aStructAux, jBodyGetResponse:GetNames()[3])
Aadd(aStructAux, jBodyGetResponse:GetNames()[4])
Aadd(aStructAux, jBodyGetResponse:GetNames()[5])
Aadd(aStructAux, jBodyGetResponse:GetNames()[6])
Aadd(aStructAux, jBodyGetResponse:GetNames()[7])
Aadd(aStructAux, jBodyGetResponse:GetNames()[8])
Aadd(aStructAux, jBodyGetResponse:GetNames()[9])
Aadd(aStructAux, jBodyGetResponse:GetNames()[10])
Aadd(aStructAux, jBodyGetResponse:GetNames()[11])
Aadd(aStructAux, jBodyGetResponse:GetNames()[12])
Aadd(aStructAux, jBodyGetResponse:GetNames()[13])

Return aStructAux

/*/{Protheus.doc} getListD4B()
    Monta a estrutura a ser devolvida no Responsa apenas com os onze campos pertinentes
    @type  Metodo
    @author Adriano Vieira
    @since  01/02/2023
    @version 1.0
/*/
Method getListD4B(jParams) class D4BService

Local cOrder    := ""
Local aFilter   := {}
Local nPage     := 1
Local nPageSize := 10
Local oRep      := totvs.protheus.backoffice.stock.trackcosts.d4b.repository.D4BRepository():new()

If jParams:HasProperty("page") .and. !Empty(jParams:getJsonText("page"))
    nPage := VAL( jParams:getJsonText("page"))
Endif

If jParams:HasProperty("pageSize") .and. !Empty(jParams:getJsonText("pageSize"))
    nPageSize := VAL( jParams:getJsonText("pageSize"))
Endif

If jParams:HasProperty("filter")
    aFilter := {{"FILTER", jParams:getJsonText("filter")}}
Else 
    aFilter := {{"FILTER", ''}}
Endif

If jParams:HasProperty("order") .and. !Empty(jParams:getJsonText("order"))
    cOrder := jParams:getJsonText("order")
Else 
    cOrder := " ORDER BY " + SqlOrder("D4B_USER+D4B_DTEXEC+D4B_HREXEC")
Endif

return oRep:getListD4B(::getColumns(), ::getQuery(), ::getWhere(), nPage, nPageSize, aFilter, cOrder)

/*/{Protheus.doc} acResultsAnalysisRepository:getFullFields()
    Metodo responsavel por verificar se existe uma tabela com o Id informado
    @type  Metodo
    @author andre.maximo
    @since  Jan 29, 2021
    @version 12.1.27
/*/
Method getColumns() CLASS D4BService

Local aColumns      := {}

Local a_FILIAL := TamSX3("D4B_FILIAL")
Local a_ID     := TamSX3("D4B_ID")
Local a_PRODUT := TamSX3("D4B_PRODUT")
//Local a_PROD   := TamSX3("D4B_PROD")
Local a_TIPO   := TamSX3("D4B_TIPO")
Local a_DATAIN := TamSX3("D4B_DATAIN")
Local a_DATAFN := TamSX3("D4B_DATAFN")
Local a_PRODMO := TamSX3("D4B_PRODMO")
Local a_LOCAL  := TamSX3("D4B_LOCAL")
Local a_MOEDA  := TamSX3("D4B_MOEDA")
Local a_SEQDIG := TamSX3("D4B_SEQDIG")
Local a_TRANSL := TamSX3("D4B_TRANSL")
Local a_LOCTRA := TamSX3("D4B_ACTIVE")
Local a_TCUSTO := TamSX3("D4B_TCUSTO")
Local a_GRUPO  := TamSX3("D4B_GRUPO")
Local a_DTEXEC := TamSX3("D4B_DTEXEC")
Local a_HREXEC := TamSX3("D4B_HREXEC")
Local a_USER   := TamSX3("D4B_USER")
Local a_BRANCH := TamSX3("D4B_BRANCH")

aAdd(aColumns, {"startedAt"                         , "D4B_FILIAL"  , a_FILIAL[3] , a_FILIAL[1] , a_FILIAL[2]})
aAdd(aColumns, {"configuration"                     , "D4B_ID"      , a_ID[3]     , a_ID[1]     , a_ID[2]})
aAdd(aColumns, {"products"                          , "D4B_PRODUT"  , a_PRODUT[3] , a_PRODUT[1] , a_PRODUT[2]})

//CAMPO DUPLICADO
//aAdd(aColumns, {"currentActive"                     , "D4B_PROD"    , a_PROD[3]   , a_PROD[1]   , a_PROD[2]})
aAdd(aColumns, {"types"                             , "D4B_TIPO"    , a_TIPO[3]   , a_TIPO[1]   , a_TIPO[2]})
aAdd(aColumns, {"initialDate"                       , "D4B_DATAIN"  , a_DATAIN[3] , a_DATAIN[1] , a_DATAIN[2]})
aAdd(aColumns, {"finalDate"                         , "D4B_DATAFN"  , a_DATAFN[3] , a_DATAFN[1] , a_DATAFN[2]})
aAdd(aColumns, {"productsWithoutMovements"          , "D4B_PRODMO"  , a_PRODMO[3] , a_PRODMO[1] , a_PRODMO[2]})
aAdd(aColumns, {"warehouses"                        , "D4B_LOCAL"   , a_LOCAL[3]  , a_LOCAL[1]  , a_LOCAL[2]})
aAdd(aColumns, {"currency"                          , "D4B_MOEDA"   , a_MOEDA[3]  , a_MOEDA[1]  , a_MOEDA[2]})
aAdd(aColumns, {"sequence"                          , "D4B_SEQDIG"  , a_SEQDIG[3] , a_SEQDIG[1] , a_SEQDIG[2]})
aAdd(aColumns, {"productsWithAddressTransferences"  , "D4B_TRANSL"  , a_TRANSL[3] , a_TRANSL[1] , a_TRANSL[2]})

//CAMPO QUE INDICARA SE O FILTRO ESTÁ ATIVO OU NÃO
aAdd(aColumns, {"isActive"                          , "D4B_ACTIVE"  , 'C' , a_LOCTRA[1] , a_LOCTRA[2]})

aAdd(aColumns, {"costType"                          , "D4B_TCUSTO"  , a_TCUSTO[3] , a_TCUSTO[1] , a_TCUSTO[2]})
aAdd(aColumns, {"groups"                            , "D4B_GRUPO"   , a_GRUPO[3]  , a_GRUPO[1]  , a_GRUPO[2]})
aAdd(aColumns, {"executionDate"                     , "D4B_DTEXEC"  , a_DTEXEC[3] , a_DTEXEC[1] , a_DTEXEC[2]})
aAdd(aColumns, {"executionHour"                     , "D4B_HREXEC"  , a_HREXEC[3] , a_HREXEC[1] , a_HREXEC[2]})
aAdd(aColumns, {"user"                              , "D4B_USER"    , a_USER[3]   , a_USER[1]   , a_USER[2]})
aAdd(aColumns, {"branches"                          , "D4B_BRANCH"  , a_BRANCH[3] , a_BRANCH[1] , a_BRANCH[2]})

Return aColumns

/*/{Protheus.doc} acResultsAnalysisRepository:getFullFields()
    Metodo responsavel por verificar se existe uma tabela com o Id informado
    @type  Metodo
    @author andre.maximo
    @since  Jan 29, 2021
    @version 12.1.27
/*/
Method getQuery() CLASS D4BService

Local cQuery := ""

cQuery += " SELECT #QueryFields# "
cQuery += " FROM " + RetSqlName("D4B") + " D4B "
cQuery += " WHERE #QueryWhere#"

Return cQuery

/*/{Protheus.doc} acResultsAnalysisRepository:getFullFields()
    Metodo responsavel por verificar se existe uma tabela com o Id informado
    @type  Metodo
    @author andre.maximo
    @since  Jan 29, 2021
    @version 12.1.27
/*/
Method getWhere() CLASS D4BService

Local cWhere := ""

cWhere += "D_E_L_E_T_ =  ' '"

Return cWhere

/*/{Protheus.doc} putUpdateD4B()
    Recebe os dados da requisicao PUT/PATCH e executa as validacoes necessarias
    Caso nao encontrar divergencias, envia para repository
    @type  Metodo
    @author Adriano Vieira
    @since  20/01/2023
    @version 1.0
/*/
Method deactivateFilter(jParams) class D4BService

Local cId     := Alltrim(jParams:getJsonText("configuration"))
Local cFilOri := ""
Local oTemp   := ac.TableTempory.Repository.acTableTemporyRepository():new()
Local oObjD4B := JsonObject():New()
Local lIdValid:= .F.

oObjD4B := ::oModelD4B:getById(cId)
cFilOri := oObjD4B["D4B_FILIAL"]

If !Empty(cId) .And. !Empty(cFilOri)
    lIdValid := ::oModelD4B:SEEK(cId, cFilOri)
EndIf

If lIdValid
    ::oModelD4B:PATCH('D4B_ACTIVE', .F.)

    If oTemp:doesTableIdExist('A' + cId + '_01')
        oTemp:deletedTableId('A' + cId + '_01')
    Endif

    If oTemp:doesTableIdExist('A' + cId + '_02')
        oTemp:deletedTableId('A' + cId + '_02')
    Endif

    If oTemp:doesTableIdExist('A' + cId + '_03')
        oTemp:deletedTableId('A' + cId + '_03')
    Endif

    If oTemp:doesTableIdExist('A' + cId + '_04')
        oTemp:deletedTableId('A' + cId + '_04')
    Endif

Else    
    ::cError := STR0030 + cId + STR0031
EndIf

Return

/*/{Protheus.doc} version
    Metodo responsavel por indicar a versao da classe
    @type  Method
    @author Adriano Vieira
    @since  15/02/2024
    @version 12.1.23.10
/*/
Method version() class D4BService
    Local nVersion := 200
Return nVersion
