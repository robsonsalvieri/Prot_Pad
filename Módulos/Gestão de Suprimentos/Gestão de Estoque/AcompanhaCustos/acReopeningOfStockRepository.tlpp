#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "acReopeningOfStock.ch"

namespace ac.Reopening.OfStock.Repository
using namespace ac.Reopening.OfStock.Service


Class acReopeningOfStockRep
    public data     dFecAnt         as date
    public data     dMVULMES        as date
    public data     lRet            as Logical
    Public data     lDefaultDate    as Logical 
    public data     lMoti           as Logical
    public data     lRetLastClosing as Logical 
    public data     lClosingNotFound as Logical
    public data     dFecDefault     as Character 
    public data     cMsgErro        as Character
    public data     cNull           as Character 
    public data     cSubstr         as Character
    public data     cConcat         as Character  
    public data     cMoeda330       as Character 
    public data     cFilSD3         as Character 
    public data     cFilSC2         as Character 
    public data     cIdReopen       as Character
    public data     oService        as Object
    public data     oJourneyLog     as Object 
    public data     lCusFIFO	    as logical
	public data     lCusLIFO	    as logical
    public data     isTypeDBOracle  as logical
    public Method   New()
    Public Method   RecSX6()
    public Method   DeletaRegs()
    public Method   ReopeningLog()
    Public Method   RebuildTheStartOfSc2() 
    public Method   getPenultimateClosing()
    public Method   DeleteClosingRecTables()
    public Method   validatesTheClosingDate()
    public Method   eventStarReopen()
    public Method   getLastClosing()
    public Method   logErrorProc()
    public Method   ChangeCCStatus()
    public Method   eventStarRepair()
    public Method   conditionalValue()
    public method   SQLExecStatement()

endClass


/*/{Protheus.doc} acResultsAnalysis:New()
    Metodo responsavel por instanciar e iniciar as variaveis da Class acList
    @type  Metodo
    @author Andre Maximo
    @since  Dezembro  28, 2020
    @version 12.1.27
/*/
Method new() Class acReopeningOfStockRep
    ::dMVULMES     := GetMV("MV_ULMES")
    ::cMsgErro     := " "
    ::lRet         := .T.
    ::cSubstr      := MatiSubStr()
    ::lCusFIFO 	   := SuperGetMV("MV_CUSFIFO",.F.,.F.)
	::lCusLIFO 	   := SuperGetMv('MV_CUSLIFO',.F.,.F.)
    ::cConcat      := MatiConcat()
    ::cNull        := MatIsNull()
    ::cFilSD3      := xFilial("SD3") 
    ::cFilSC2      := xFilial("SC2")
    ::cMoeda330    := SuperGetMv('MV_MOEDACM',.F.,"2345")
    ::oJourneyLog  := acJourneyLog():new()   
    ::lRetLastClosing := .T.
    ::lClosingNotFound:= .F.
    ::lDefaultDate    := .F.
    ::dFecDefault     := cTOD('//')   
    ::isTypeDBOracle :=  Upper( TcGetDb() ) == "ORACLE"
    ::cIdReopen     := " "

return Self


/*/{Protheus.doc} acResultsAnalysis:getResultsAnalysis()
    Metodo responsavel por realizar analise do custo do 
    ultimo fechamento comparado com custo pós recalculo 
    @type  Metodo
    @author andre.oliveira
    @since  Dezembro  28, 2020
    @version 12.1.27
/*/

Method getPenultimateClosing(dMVULMES) Class acReopeningOfStockRep
    Local cQuery as Character
    Local cAlias := "TMP" as Character
    Local cStateMemoryInQuery as Character
    Local dFecAnt as date
    Local nX := 0 as Numeric
    local oQuery as Object
    Local oJson  as Object
    
    //-- Recupera data do penultimo fechamento
    cQuery := " SELECT MAX(B9_DATA) FECANT "
    cQuery += " FROM "+RetSQLName('SB9')+" SB9 "
    cQuery += " WHERE SB9.B9_FILIAL = ? "
    cQuery += " AND SB9.B9_DATA < ? "
    cQuery += " AND SB9.D_E_L_E_T_ = ? "
    cQuery := ChangeQuery(cQuery)
    
    oQuery := FwExecStatement():New(cQuery)
    oQuery:SetString(1, xFilial('SB9'))
    oQuery:SetString(2, DTOS(dMVULMES))
	oQuery:SetString(3, ' ')
    oQuery:openAlias(cAlias)     
    dFecAnt := SToD(oQuery:execScalar('FECANT'))    
    (cAlias)->(dbCloseArea())
    //Caso não encontre o fechamento anterior, trago o que foi passado no MV_ULMES do fechamento
    if empty(DTOS(dFecAnt))
        ::lDefaultDate := .T.
        dFecAnt := SToD("19970101")       
        cStateMemoryInQuery := TCConfig('GETMEMOINQUERY')
        If (cStateMemoryInQuery == 'OFF')               
            TCConfig('SETMEMOINQUERY=ON')
        EndIf
        cQuery := " SELECT D3Y_PARAMS AS PARAMS"
        cQuery += " FROM "+RetSQLName('D3Y')+" D3Y "
        cQuery += " WHERE D3Y.D3Y_IDEXEC = ? "
        cQuery += " AND D3Y.D3Y_DTFECH = ? "
        cQuery += " AND D3Y.D_E_L_E_T_ = ? "
        cQuery :=ChangeQuery(cQuery)
        oQuery := FwExecStatement():New(cQuery)
        oQuery:SetString(1, ::cIdReopen)
        oQuery:SetString(2, DTOS(dMVULMES))
	    oQuery:SetString(3, ' ')
        oQuery:openAlias(cAlias)            
        oJson := JsonObject():New()
        oJson:fromJson((cAlias)->PARAMS)
        //Verifico se o Json é valido
        if oJson:hasproperty('branches')  
            for nX:=1 to len(oJson["branches"])
                if oJson["branches"][nX]["Code"] == cFilAnt
                    dFecAnt := stod(strtran(oJson["branches"][nX]["parameters"][1]["value"],"/",""))
                    ::lDefaultDate := .F.
                 EndIf
            Next 
        EndIf
        //Retorno para não trazer memo nas queries
        TCConfig('SETMEMOINQUERY=OFF')            
        (cAlias)->(dbCloseArea())        
        FreeObj(oJson)
    EndIf
    //Limpo as variaveis
    oQuery:Destroy()

return dFecAnt


/*/{Protheus.doc} acReopeningOfStockRep:
    Metodo responsavel por Recupera data do último fechamento
    @type  Metodo
    @author andre.oliveira
    @since  Dezembro  28, 2020
    @version 12.1.27
/*/

Method getLastClosing(dMVULMES, aFilsOk) Class acReopeningOfStockRep
    
    Local dFecAnt:= cTOd('//')
        BeginSQL Alias "TMP"
            SELECT MAX(B9_DATA) FECANT
            FROM %Table:SB9%
            WHERE %NotDel% AND
                B9_FILIAL = %xFilial:SB9%
        EndSQL
        If !TMP->(EOF()) .And. !Empty(TMP->FECANT)
            dFecAnt := SToD(TMP->FECANT)
            If  dFecAnt > dMVULMES
                ::lRetLastClosing:= .F.
                ::cMsgErro := STR0020 +' : '+ DToS(dFecAnt)  //'Encontrado data maior de fechamento '
            ElseIf !(dMVULMES == dFecAnt)
                ::lRetLastClosing:= .F.
                ::cMsgErro := STR0021 +' : '+ DToS(dMVULMES) //  'Não encontramos fechamento da data '
            EndIF
        Else
            // Array aFilsOk vem do front dizendo que a filial ja foi validada para reabertura
            nPosFilOk := aScan(aFilsOk,{|x| AllTrim(x[1]) == AllTrim(cEmpAnt) .And. AllTrim(x[2]) == AllTrim(cFilAnt)})
            If nPosFilOk == 0
                ::cMsgErro := STR0012 // "Não foi localizado registro de fechamento na tabela SB9 - Saldos Iniciais. O período atual será reaberto e os parâmetros MV_ULMES e MV_DBLQMOV (caso utilize) serão atualizados com o default 01/01/1997"
                ::lRetLastClosing := .F.
                ::lClosingNotFound:= .T.
            EndIf
        EndIf
        TMP->(dbCloseArea())

Return dFecAnt

/*/{Protheus.doc} DeleteClosingRecTables
	Função para processar exclusão de registros das tabelas de fechamento
	@type  Function
	@author andre.oliveira
	@since 12/09/2020
	@version 1.0
	@param cAlias, caracter, Alias da tabela cujos registros serao excluidos
	@param dMVULMES, date, data do fechamento que está sendo desfeito
/*/
Method  DeleteClosingRecTables(cAlias,dMVULMES) Class acReopeningOfStockRep
    Local cQuery    := ""
    Local nTotReg   := 0
    Local lRet      := .T.

    ::oService:= ac.Reopening.OfStock.Service.acReopeningOfStockServ():new()
    ::oService:literature(cAlias)
    
    cQuery := "SELECT COUNT(*) TOTREG FROM " +RetSQLName(cAlias) +" WHERE D_E_L_E_T_ = ' ' AND "
    cQuery += Substr(cAlias,2,2) +"_FILIAL = '" +xFilial(cAlias) +"' AND "
    cQuery += Substr(cAlias,2,2) +"_DATA = '" +DToS(dMVULMES) +"'"
    dbUseArea(.T.,"TOPCONN",TCGenQry(,,cQuery),"TMP",.F.,.T.)
    nTotReg := TMP->TOTREG
    TMP->(dbCloseArea())

    ::ReopeningLog("MENSAGEM", STR0006  + cFilAnt +" - "+  STR0013  + cAlias + ": " + ::oService:cNomeTab, AllTrim(Str(nTotReg)) + STR0014 ,'4'+::oService:cNameStep  ) //"Filial "   // Iníci+o da exclusão  //  registros a processar.
    
    cQuery := "DELETE FROM " +RetSQLName(cAlias) +" WHERE D_E_L_E_T_ = ' ' AND "
    cQuery += Substr(cAlias,2,2) +"_FILIAL = '" +xFilial(cAlias) +"' AND "
    cQuery += Substr(cAlias,2,2) +"_DATA = '" +DToS(dMVULMES) +"'"
	Iif(TCSQLExec(cQuery) < 0, lRet := .F., lRet)

    ::ReopeningLog("MENSAGEM",STR0006 +cFilAnt +" - "+ STR0016 +cAlias +": " +::oService:cNomeTab,AllTrim(Str(nTotReg)) +" registros processados.", '5'+::oService:cNameStep ,  ) // FILIAL Término de exclusão

Return lRet


/*/{Protheus.doc} RebuildTheStartOfSc2
	Função para processar exclusão de registros das tabelas de fechamento
	@type  Function
	@author andre.oliveira
	@since 12/09/2020
	@version 1.0
    @param ::dFecAnt, date, Data do fechamento anterior
	@param cMsgErro, caracter, Variavel para receber detalhes de erros de processamento
/*/
Method RebuildTheStartOfSc2(dFecAnt,cMsgErro) Class acReopeningOfStockRep
    Local lRet      := .T.
    Local lCusRep   := SuperGetMv("MV_CUSREP",.F.,.F.) .And. MA330AvRep()
    Local lCstPart  := .F.
    Local aRegraCP  := {}
    Local cSQLComm  := ""
    Local nMoeda    := 0
    Local nParte    := 0
    Local cWhere    := ""

    //-- Preenche array com as regras do custo em partes e verifica se os campos do custo em partes estao Ok
    If ExistBlock("MA330CP") .And. ValType(aRegraCP := ExecBlock("MA330CP",.F.,.F.)) == "A"
        lCstPart := MA330AvlCp(aRegracp,{})
    EndIf
    
    //-- Filtro da OPs que serão atualizadas: emitidas antes do ultimo fechamento e (em aberto ou encerradas após fechamento)
    if !::isTypeDBOracle
        cWhere := "WHERE D_E_L_E_T_ = ' ' AND "
        cWhere += "   C2_FILIAL = '" +::cFilSC2 +"' AND "
        cWhere += "   (C2_DATRF = ' ' OR C2_DATRF > '" +DToS(dFecAnt) +"') "
        cWhere += " AND tabela_soma.D3_OP = C2_NUM" + ::cConcat + "C2_ITEM" + ::cConcat + "C2_SEQUEN" + ::cConcat + "C2_ITEMGRD "
    else
         cWhere :=" WHERE SC2UPD.D_E_L_E_T_ = ' ' "
		 cWhere +="	AND SC2UPD.C2_FILIAL = '" + ::cFilSC2 + "' AND "
		 cWhere +=" (SC2UPD.C2_DATRF = ' ' OR SC2UPD.C2_DATRF > '" +DToS(dFecAnt) +"') "
    EndIf
    //-- Tratamento para custo de reposição (MV_CUSREP)
    If lCusRep
        For nMoeda := 1 To 5
            If nMoeda # 1 .And. !(Str(nMoeda,1,0) $ ::cMoeda330)
                Loop
            EndIf

            cSQLComm := ""

            if !::isTypeDBOracle
                cSQLComm := " WITH tabela_soma AS ( "
            Else 
                cSQLComm := "MERGE INTO " + RetSQLName("SC2") + " SC2UPD USING ( " 
            EndIf
            cSQLComm += " SELECT "
            cSQLComm += " D3_OP, "
            cSQLComm += " SUM(CASE "
            cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'RE' AND " +::cSubstr +"(D3_CF, 3, 1) <> '9' THEN D3_CUSRP" +Str(nMoeda,1,0) +"  "
            cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'DE' AND " +::cSubstr +"(D3_CF, 3, 1) <> '9' THEN - D3_CUSRP" +Str(nMoeda,1,0) +"  "
            cSQLComm += "        ELSE 0 "
            cSQLComm += "     END) AS SOMA_RE_DE, "
            cSQLComm += " SUM(CASE "
            cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'PR' THEN D3_CUSRP" +Str(nMoeda,1,0) +" " 
            cSQLComm += "         ELSE 0 "
            cSQLComm += "     END) AS SOMA_PR "
            cSQLComm += "FROM  "+RetSQLName("SD3") +" "
            cSQLComm += "WHERE "
            cSQLComm += " D_E_L_E_T_ = ' ' "
            cSQLComm += " AND D3_FILIAL = '"+::cFilSD3 +"' "
            cSQLComm += " AND D3_ESTORNO <> 'S' "
            cSQLComm += " AND D3_EMISSAO <= '" +DToS(dFecAnt) +"' "
            cSQLComm += " AND D3_OP <> ' ' "
            cSQLComm += " GROUP BY D3_OP "
            cSQLComm += " UNION "
            cSQLComm += " SELECT SC2.C2_NUM" +::cConcat + "SC2.C2_ITEM" + ::cConcat + "SC2.C2_SEQUEN" + ::cConcat + "SC2.C2_ITEMGRD D3_OP,"
            cSQLComm += " 0 AS SOMA_RE_DE,"
            cSQLComm += " 0 AS SOMA_PR "
            cSQLComm += " FROM " +RetSQLName("SC2") + " SC2 "  
            cSQLComm += " LEFT JOIN " + RetSQLName("SD3") + " SD3 "
            cSQLComm += " ON SD3.D3_OP = SC2.C2_NUM" + ::cConcat + "SC2.C2_ITEM" + ::cConcat + "SC2.C2_SEQUEN" + ::cConcat + "SC2.C2_ITEMGRD"
            cSQLComm += "  AND SD3.D_E_L_E_T_ = ' ' "
            cSQLComm += "  AND SD3.D3_FILIAL = '"+::cFilSD3 +"' "
            cSQLComm += "  AND SD3.D3_ESTORNO <> 'S' "
            cSQLComm += "  AND SD3.D3_EMISSAO <= '" +DToS(dFecAnt) +"' "
            cSQLComm += "  WHERE SC2.D_E_L_E_T_ = ' ' "
            cSQLComm += "  AND SC2.C2_FILIAL = '" + ::cFilSC2 + "' "
            cSQLComm += "  AND (SC2.C2_DATRF = ' ' OR SC2.C2_DATRF > '" +DToS(dFecAnt) +"') "
            cSQLComm += "  AND SD3.D3_OP IS NULL "
            cSQLComm += ") "
            if ::isTypeDBOracle
                cSQLComm += " SD3WithSC2 ON (SD3WithSC2.D3_OP = SC2UPD.C2_NUM " + ::cConcat + " SC2UPD.C2_ITEM " + ::cConcat + " SC2UPD.C2_SEQUEN " + ::cConcat + " SC2UPD.C2_ITEMGRD) "
                cSQLComm += "   WHEN MATCHED THEN "
            EndIf
            if !::isTypeDBOracle
                cSQLComm += "UPDATE " +RetSQLName("SC2") +" "
                cSQLComm += "SET "
                cSQLComm += "C2_VINIRP" +Str(nMoeda,1,0) +" = " +::cNull +"(tabela_soma.SOMA_RE_DE - tabela_soma.SOMA_PR, 0), "
                cSQLComm += "C2_APRIRP" +Str(nMoeda,1,0) +" = " +::cNull +"(tabela_soma.SOMA_PR, 0)  "
                cSQLComm += "FROM tabela_soma "
            else
                cSQLComm += "UPDATE 
                cSQLComm += "SET "
                cSQLComm += " SC2UPD.C2_VINIRP" +Str(nMoeda,1,0) +" = " +::cNull +"(SD3WithSC2.SOMA_RE_DE - SD3WithSC2.SOMA_PR, 0), "
                cSQLComm += " SC2UPD.C2_APRIRP"+Str(nMoeda,1,0)+ " = " +::cNull +" (SD3WithSC2.SOMA_PR, 0) "
            EndIf

            If !::SQLExecStatement(cSQLComm + cWhere)
                lRet := .F.
                Exit
            Endif
        Next nMoeda
    EndIf
    If lRet
        For nMoeda := 1 To 5
            If nMoeda # 1 .And. !(Str(nMoeda,1,0) $ ::cMoeda330)
                Loop
            EndIf

            cSQLComm := ""

            if !::isTypeDBOracle
                cSQLComm := " WITH tabela_soma AS ( "
            Else 
                cSQLComm := "MERGE INTO " + RetSQLName("SC2") + " SC2UPD USING ( " 
            Endif
            cSQLComm += " SELECT "
            cSQLComm += " D3_OP, "
            cSQLComm += " SUM(CASE "
            cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'RE' AND " +::cSubstr +"(D3_CF, 3, 1) <> '9' THEN D3_CUSTO"+Str(nMoeda,1,0)+"  "
            cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'DE' AND " +::cSubstr +"(D3_CF, 3, 1) <> '9' THEN - D3_CUSTO"+Str(nMoeda,1,0)+"  "
            cSQLComm += "        ELSE 0 "
            cSQLComm += "     END) AS SOMA_RE_DE, "
            cSQLComm += " SUM(CASE "
            cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'PR' THEN D3_CUSTO"+Str(nMoeda,1,0)+ " " 
            cSQLComm += "         ELSE 0 "
            cSQLComm += "     END) AS SOMA_PR "
            If (::lCusFIFO .Or. ::lCusLIFO)
                cSQLComm += " , SUM(CASE "
                cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'RE' AND " +::cSubstr +"(D3_CF, 3, 1) <> '9' THEN D3_CUSFF" +Str(nMoeda,1,0) +" " 
                cSQLComm += "         ELSE 0 "
                cSQLComm += "     END) AS SOMA_INIFF, "
                cSQLComm += " SUM(CASE "
                cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'PR' THEN D3_CUSFF" +Str(nMoeda,1,0) +" " 
                cSQLComm += "         ELSE 0 "
                cSQLComm += "     END) AS SOMA_PRAPINFF "
            EndIf
            cSQLComm += "FROM  " + RetSQLName("SD3") + " "
            cSQLComm += "WHERE "
            cSQLComm += " D_E_L_E_T_ = ' ' "
            cSQLComm += " AND D3_FILIAL = '"+::cFilSD3 +"' "
            cSQLComm += " AND D3_ESTORNO <> 'S' "
            cSQLComm += " AND D3_EMISSAO <= '" +DToS(dFecAnt) +"' "
            cSQLComm += " AND D3_OP <> ' ' "
            cSQLComm += " GROUP BY D3_OP "
            cSQLComm += " UNION "
            cSQLComm += " SELECT SC2.C2_NUM" +::cConcat + "SC2.C2_ITEM" + ::cConcat + "SC2.C2_SEQUEN" + ::cConcat + "SC2.C2_ITEMGRD D3_OP,"
            cSQLComm += " 0 AS SOMA_RE_DE,"
            cSQLComm += " 0 AS SOMA_PR "
            If (::lCusFIFO .Or. ::lCusLIFO)
                cSQLComm += " , 0 AS SOMA_INIFF"
                cSQLComm += " , 0 AS SOMA_PRAPINFF "
            EndIf
            cSQLComm += " FROM " +RetSQLName("SC2") + " SC2 "  
            cSQLComm += " LEFT JOIN " + RetSQLName("SD3") + " SD3 "
            cSQLComm += " ON SD3.D3_OP = SC2.C2_NUM" + ::cConcat + "SC2.C2_ITEM" + ::cConcat + "SC2.C2_SEQUEN" + ::cConcat + "SC2.C2_ITEMGRD"
            cSQLComm += "  AND SD3.D_E_L_E_T_ = ' ' "
            cSQLComm += "  AND SD3.D3_FILIAL = '"+::cFilSD3 +"' "
            cSQLComm += "  AND SD3.D3_ESTORNO <> 'S' "
            cSQLComm += "  AND SD3.D3_EMISSAO <= '" +DToS(dFecAnt) +"' "
            cSQLComm += "  WHERE SC2.D_E_L_E_T_ = ' ' "
            cSQLComm += "  AND SC2.C2_FILIAL = '" + ::cFilSC2 + "' "
            cSQLComm += "  AND (SC2.C2_DATRF = ' ' OR SC2.C2_DATRF > '" +DToS(dFecAnt) +"') "
            cSQLComm += "  AND SD3.D3_OP IS NULL "
            cSQLComm += ") "
            if ::isTypeDBOracle
                cSQLComm += " SD3WithSC2 ON (SD3WithSC2.D3_OP = SC2UPD.C2_NUM " + ::cConcat + " SC2UPD.C2_ITEM " + ::cConcat + " SC2UPD.C2_SEQUEN " + ::cConcat + " SC2UPD.C2_ITEMGRD) "
                cSQLComm += "   WHEN MATCHED THEN "
            EndIf
            if !::isTypeDBOracle
                cSQLComm += "UPDATE " +RetSQLName("SC2") +" "
                cSQLComm += "SET "
                cSQLComm += "C2_VINI" +Str(nMoeda,1,0) +" = " +::cNull +"(tabela_soma.SOMA_RE_DE - tabela_soma.SOMA_PR, 0), "
                cSQLComm += "C2_APRINI" +Str(nMoeda,1,0) +" = " +::cNull +"(tabela_soma.SOMA_PR, 0)  "
                If (::lCusFIFO .Or. ::lCusLIFO)
                    cSQLComm += ", C2_VINIFF" +Str(nMoeda,1,0) +" = " +::cNull +"(tabela_soma.SOMA_INIFF, 0), "
                    cSQLComm += "C2_APINFF" +Str(nMoeda,1,0) +" = " +::cNull +"(tabela_soma.SOMA_PRAPINFF, 0)  "
                EndIf
                cSQLComm += "FROM tabela_soma "
            else
                cSQLComm += "UPDATE 
                cSQLComm += "SET "
                cSQLComm += " SC2UPD.C2_VINI" +Str(nMoeda,1,0) +" = " +::cNull +"(SD3WithSC2.SOMA_RE_DE - SD3WithSC2.SOMA_PR, 0), "
                cSQLComm += " SC2UPD.C2_APRINI"+Str(nMoeda,1,0)+" = " +::cNull +"(SD3WithSC2.SOMA_PR, 0) "
            EndIf
            
            If !::SQLExecStatement(cSQLComm + cWhere)
                lRet := .F.
                Exit
            EndIf
            
            //-- Tratamento para custo em partes
            If lCstPart
                For nParte := 1 To Len(aRegraCP)+1
                    
                    cSQLComm := ""

                    If !::isTypeDBOracle
                        cSQLComm := " WITH tabela_soma AS ( "
                    Else 
                        cSQLComm := "MERGE INTO " + RetSQLName("SC2") + " SC2UPD USING ( " 
                    EndIf
                    cSQLComm += " SELECT "
                    cSQLComm += " D3_OP, "
                    cSQLComm += " SUM(CASE "
                    cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'RE' AND " +::cSubstr +"(D3_CF, 3, 1) <> '9' THEN D3_CP" +Strzero(nParte,2,0)+Strzero(nMoeda,2,0) +"  "
                    cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'DE' AND " +::cSubstr +"(D3_CF, 3, 1) <> '9' THEN - D3_CP" +Strzero(nParte,2,0)+Strzero(nMoeda,2,0) +" "
                    cSQLComm += "        ELSE 0 "
                    cSQLComm += "     END) AS SOMA_RE_DE, "
                    cSQLComm += " SUM(CASE "
                    cSQLComm += "         WHEN " +::cSubstr +"(D3_CF, 1, 2) = 'PR' THEN D3_CP" +Strzero(nParte,2,0)+Strzero(nMoeda,2,0) +" " 
                    cSQLComm += "         ELSE 0 "
                    cSQLComm += "     END) AS SOMA_PR "
                    cSQLComm += "FROM  "+RetSQLName("SD3") +" "
                    cSQLComm += "WHERE "
                    cSQLComm += " D_E_L_E_T_ = ' ' "
                    cSQLComm += " AND D3_FILIAL = '"+::cFilSD3 +"' "
                    cSQLComm += " AND D3_ESTORNO <> 'S' "
                    cSQLComm += " AND D3_EMISSAO <= '" +DToS(dFecAnt) +"' "
                    cSQLComm += " AND D3_OP <> ' ' "
                    cSQLComm += " GROUP BY D3_OP "
                    cSQLComm += " UNION "
                    cSQLComm += " SELECT SC2.C2_NUM" +::cConcat + "SC2.C2_ITEM" + ::cConcat + "SC2.C2_SEQUEN" + ::cConcat + "SC2.C2_ITEMGRD D3_OP,"
                    cSQLComm += " 0 AS SOMA_RE_DE,"
                    cSQLComm += " 0 AS SOMA_PR "
                    cSQLComm += " FROM " +RetSQLName("SC2") + " SC2 "  
                    cSQLComm += " LEFT JOIN " + RetSQLName("SD3") + " SD3 "
                    cSQLComm += " ON SD3.D3_OP = SC2.C2_NUM" + ::cConcat + "SC2.C2_ITEM" + ::cConcat + "SC2.C2_SEQUEN" + ::cConcat + "SC2.C2_ITEMGRD"
                    cSQLComm += "  AND SD3.D_E_L_E_T_ = ' ' "
                    cSQLComm += "  AND SD3.D3_FILIAL = '"+::cFilSD3 +"' "
                    cSQLComm += "  AND SD3.D3_ESTORNO <> 'S' "
                    cSQLComm += "  AND SD3.D3_EMISSAO <= '" +DToS(dFecAnt) +"' "
                    cSQLComm += "  WHERE SC2.D_E_L_E_T_ = ' ' "
                    cSQLComm += "  AND SC2.C2_FILIAL = '" + ::cFilSC2 + "' "
                    cSQLComm += "  AND (SC2.C2_DATRF = ' ' OR SC2.C2_DATRF > '" +DToS(dFecAnt) +"') "
                    cSQLComm += "  AND SD3.D3_OP IS NULL "
                    cSQLComm += ") "
                    if ::isTypeDBOracle
                        cSQLComm += " SD3WithSC2 ON (SD3WithSC2.D3_OP = SC2UPD.C2_NUM " + ::cConcat + " SC2UPD.C2_ITEM " + ::cConcat + " SC2UPD.C2_SEQUEN " + ::cConcat + " SC2UPD.C2_ITEMGRD) "
                        cSQLComm += "   WHEN MATCHED THEN "
                    EndIf
                     if !::isTypeDBOracle
                        cSQLComm += "UPDATE " +RetSQLName("SC2") +" "
                        cSQLComm += "SET "
                        cSQLComm += "C2_CPI" + Strzero(nParte,2,0)+Strzero(nMoeda,2,0) +" = " +::cNull +"(tabela_soma.SOMA_RE_DE - tabela_soma.SOMA_PR, 0), "
                        cSQLComm += "C2_API" + Strzero(nParte,2,0)+Strzero(nMoeda,2,0) +" = " +::cNull +"(tabela_soma.SOMA_PR, 0)  "
                        cSQLComm += "FROM tabela_soma "
                    else
                        cSQLComm += "UPDATE 
                        cSQLComm += "SET "
                        cSQLComm += " SC2UPD.C2_CPI" + Strzero(nParte,2,0)+Strzero(nMoeda,2,0) +" = " +::cNull +"(SD3WithSC2.SOMA_RE_DE - SD3WithSC2.SOMA_PR, 0), "
                        cSQLComm += " SC2UPD.C2_API" + Strzero(nParte,2,0)+Strzero(nMoeda,2,0) +" = " +::cNull +"(SD3WithSC2.SOMA_PR, 0) "  
                    EndIF

                    If !::SQLExecStatement(cSQLComm + cWhere)
                        lRet := .F.
                        Exit
                    EndIf

                Next nParte
            EndIf        
            //-- Em caso de erro na atualização dos custos em partes
            If !lRet
                Exit
            EndIf
        Next nMoeda
    EndIf

Return lRet

/*/{Protheus.doc} RecSX6
    Atualiza parametros do fechamento 
    @type  Metodo
    @author Samuel Macedo
    @since  Fevereiro 05,2021
    @version 12.1.27
/*/

Method RecSX6(dFecAnt, lCMDBLQV) Class acReopeningOfStockRep
  PutMV("MV_ULMES",dFecAnt)
  If lCMDBLQV 
    PutMV("MV_DBLQMOV",dFecAnt)
  ENDIf 
return 



/*/{Protheus.doc} M330PrcLog
	Encapsula chamada da ReopeningLog para garantir gravação da filial da D3X com a filial
	que está executando o processo.
	@type  Function
	@author andre.oliveira
	@since 04/09/2020
	@version 1.0
	@param cTipo, caracter, tipo do log a ser gerado
	@param cTexto, caracter, mensagem a ser gravada no log gerado
	@param cDetalhe, caracter, detalhe a ser gravado para o log gerado
/*/
Method ReopeningLog(cTipo,cTexto,cDetalhe, cStatus, cFilInfo) Class acReopeningOfStockRep

    Default cFilInfo := ''
    cFilAnt := ::conditionalValue(!empty(cFilInfo), cFilInfo, cFilAnt)
    If Empty(::oJourneyLog:nCondition) 
        ::oJourneyLog:envValid(.T.)
    EndIF
    ::oJourneyLog:LogProAtu(cTipo,cTexto,cDetalhe,         ,cStatus,dDataBase,cFilAnt, .T., .T.)

Return


/*/{Protheus.doc} eventStarReopen
    Metodo responsavel por abrir o startJob para processamento do recalculo
    @type  Metodo
    @author André Maximo 
    @since  Novembro 26,2020
    @version 12.1.27
/*/
Method  eventStarReopen(cBranch,cCompany,oFilsProcAux, cId, ltotal, cIdProccess, lReopeningSb9, ddataClosing, aFilsProc, oFilsProc) class  acReopeningOfStockRep
Local cFilsProc := oFilsProcAux:toJson()
Local oJourney  := acJourneyLog():New()
Default cId := oJourney:cIdParent
Default cIdProccess:= oJourney:cIdChild

cId := ::conditionalValue((Empty(cId) .Or. cId == 'null'), oJourney:cIdParent, cId)
cIdProccess := ::conditionalValue((Empty(cIdProccess) .Or. cIdProccess == 'null'), oJourney:cIdChild, cIdProccess)

oJourney:logIni()
oJourney:envValid(.T.)
oJourney:idMovD3X()
oJourney:setThreadId( Strzero(ThreadID(),15))
oJourney:cIdParent := cId

oJourney:LogProAtu('INIJOB', STR0023, '' , cFilAnt, , StoD(ddataClosing), cFilAnt, .T.) //'Tentativa de subida de thread para o processamento da rotina EST282'

StartJob('IniProc282',GetEnvServer(),.F.,cBranch,cCompany,cFilsProc, cId, oJourney:cIdChild, ltotal,cIdProccess, lReopeningSb9, ddataClosing, cUserName, aFilsProc)

oFilsProc['idParent'] := cId
oFilsProc['idChild'] := oJourney:cIdChild

return oFilsProc

/*/{Protheus.doc} ChangeCCStatus
    Metodo responsavel por reabrir saldos do penultimo periodo por FIFO/LIFO
    @type  Metodo
    @author Pedro Missaglia
    @since  Novembro 26,2020
    @version 12.1.27
/*/
Method  ChangeCCStatus() class  acReopeningOfStockRep

Local cQuery := ''
Local lRet  := .T.
    
    cQuery := "UPDATE " +RetSQLName('SCC') +" SET CC_STATUS = 'A' WHERE CC_FILIAL = '" + xFilial('SCC') + "' AND CC_DATA  = (SELECT MAX(CC_DATA) FROM " 
    cQuery += RetSQLName('SCC')+ " WHERE CC_FILIAL = '"+ xFilial("SCC")+ "')"

	Iif(TCSQLExec(cQuery) < 0, lRet :=.F., lRet)

return lRet

/*/{Protheus.doc} eventStarReopen
    Metodo responsavel por abrir o startJob para processamento do recalculo
    @type  Metodo
    @author André Maximo 
    @since  Novembro 26,2020
    @version 12.1.27
/*/
Method  eventStarRepair(aParansfil, dDateClosin, cId, cidProccess,cUserNameJ) class  acReopeningOfStockRep

Local oJourney  := acJourneyLog():New()
Local oFilsProc :=  JsonObject():New()

StartJob('IniProcRep',GetEnvServer(),.F.,aParansfil, dDateClosin, cId, cidProccess, oJourney:cIdChild , cUserNameJ, cfilant,FWGrpCompany())

oFilsProc['idParent'] := cidProccess
oFilsProc['idChild'] := oJourney:cIdChild

return oFilsProc


/*/{Protheus.doc} condition
    Retorno condicional
    @author Squad.Entradas
    @since 24/04/2023
    @version 1.0
    @param lCondition, logical, condicao
            cRet1, character, primeiro retorno
            cRet2, character, segundo retorno
    @return cRet, character, retorno
    /*/
Method conditionalValue(lCondition, cRet1, cRet2) class acReopeningOfStockRep

    local cRet := ""

    if lCondition
        cRet := cRet1
    else
        cRet := cRet2
    endif

Return cRet


/*/{Protheus.doc} SQLExecStatement
    Metodo responsavel por executar comando SQL
    @author pedro.missaglia
    @since 24/04/2023
    @version 1.0
    @param cStatement
    @return lRet, logical, retorno
    /*/
Method SQLExecStatement(cStatement) class acReopeningOfStockRep

    Local lRet := .T.

    If TCSQLExec(cStatement) < 0
        cMsgErro := STR0007+'(D3X).' //"Um erro na recomposição de custos iniciais de produção abortou o processo. Detalhes do erro estão disponíveis no log de processamento (D3X)."
        ::ReopeningLog("ERRO",STR0006 +cFilAnt +" - "+ STR0018 ,TCSQLError(),'ER', )// FILIAL //Erro na recomposição de custos iniciais de produção"
        lRet := .F.
    EndIf

Return lRet
