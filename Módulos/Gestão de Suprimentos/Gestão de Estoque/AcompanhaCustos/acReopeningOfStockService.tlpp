#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "acReopeningOfStock.ch"
#INCLUDE "Fwlibversion.ch"

namespace ac.Reopening.OfStock.Service
using namespace ac.Reopening.OfStock.Repository
using namespace ac.branchesList.Serv
using namespace ac.Log.Service

class acReopeningOfStockServ
    public data aFilsProc       as Array
    public data aInfo           as Array
    public data dMVULMES        as date
    public data dFecAnt         as date 
    public data dFecAntEmp      as date 
    public data cNomeTab        as Character
    public data cNameStep       as Character
    public data cMsgErro        as Character
    public data oRepository     as Object
    public data oRepositoryWMS  as Object
    public data oContabService  as Object
    public data oAux3BranchFixed as Object
    public data obranchesMont2       as Object
    public data oAux4BranchFixed     as Object
    public data obranchesMont        as Object
    public data oControllerVariables as Object 
    public data lFIFOLIFO            as logical 
    public data lNotFoundCount       as logical
    public data lNotFoundBranch      as logical
    public data lcusfilemp           as logical
    public data lCalendInvalid       as logical
    public data lWmsNew	             as logical
    public data lEstWms              as logical
    public Method New()
    public Method literature()
    public Method IniReopenBran()
    public Method logErrorProc()
    public Method eventInitialProces()
    public Method deletingRecIntable()
    public Method OpenOfStockBranches()
    public Method ParcialReopeningLog()
    public Method BranchFixed()
    public Method validatesTheClosingDate()
    public Method ParamsFixedForUpdate()
    public Method ReopeningLogSb9()
    public method ReopeningMetrics()
    public method AnalyzeRepairBranches()
    public method eventInitialProcesRepair()
    public method EstDevFIFO()
    public method PrepareBranchesOk()
endclass

/*/{Protheus.doc} acResultsAnalysis:New()
    Metodo responsavel por instanciar e iniciar as variaveis da class acList
    @type  Metodo
    @author Andre Maximo
    @since  Dezembro  28, 2020
    @version 12.1.27
/*/
method new() class acReopeningOfStockServ
     ::oAux3BranchFixed := JsonObject():new()
     ::oAux4BranchFixed := JsonObject():new()
     ::obranchesMont    := JsonObject():new()
     ::obranchesMont2   := JsonObject():new()
     ::aFilsProc        := {}
     ::aInfo            := GetApoInfo('distribution.WMS.FechamentoEst.tlpp')
     ::lNotFoundBranch  := .F.
     ::lNotFoundCount   := .F.
     ::lCalendInvalid   := .F.
     ::cMsgErro         := ''  
     ::cNomeTab         := ''
     ::cNameStep        := ''
     ::lcusfilemp       := Alltrim(SuperGetMv("MV_CUSFIL",.F.,"A")) == "E"
     ::lWmsNew          := SuperGetMv("MV_WMSNEW",.F.,.F.)
     ::lEstWms          := !Empty(::aInfo)
     ::dFecAntEmp       := CtoD('')
     ::lFIFOLIFO        := (SuperGetMv("MV_CUSFIFO",.F.,.F.) .Or. SuperGetMv('MV_CUSLIFO',.F.,.F.)) .And. IsFechFifo()
     ::oRepository      := ac.Reopening.OfStock.Repository.acReopeningOfStockRep():new()
     ::oContabService   := ac.acContab.Service.acContabServ():new()
return Self

/*/{Protheus.doc} ReopenBran
	Função para processar exclusão de registros das tabelas de fechamento para filiais selecionadas
	@type  Function
	@author andre.oliveira
	@since 12/09/2020
	@version 1.0
    @param lBat, logic, Sinaliza processamento sem tela
	@param aFilsCalc, array, Array com filiais selecionadas
    @param dFecAnt, date, Data do fechamento anterior (opcional)
	@param oSay, object, Objeto para atualização de mensagens em tela (opcional)
/*/
Method IniReopenBran(cBranch,cCompany,aFilsCalc,ddataClosing,cId, ltotal,cIdProccess, lReopeningSb9, aFilsOk) class acReopeningOfStockServ
    Local aFilsProc     :=  {}
    Local aFilsProcAux  :=  {}
    Local lRet          := .T.
    Local lRetEmp       := .T.
    Local lCalendInv    := .F.
    Local nX            :=  0
    local nY            :=  0
    Local cFilBack      :=  cFilAnt
    Local dMVULMES      :=  dDataBase
    Local dFecAnt       := CtoD('')
    Local nCount        :=  0 
    Local nCountErr     :=  0
    Local oJCheck       :=  JsonObject():New()
    Local oJCheckAux    :=  JsonObject():New()
    Default ltotal      := .F.
    Default aFilsOk     := {}
    ::oRepository:cIdReopen := cId
    For nX := 1 To Len(aFilsCalc)
        If aFilsCalc[nX,1]
            cFilAnt := aFilsCalc[nX,2]
            dMVULMES  := GetMV("MV_ULMES") 
            If dMVULMES == sToD(ddataClosing)
                dFecAnt   := ::oRepository:getPenultimateClosing(dMVULMES)  
                ::oRepository:getLastClosing(dMVULMES, aFilsOk)
                lRet := ::oRepository:lRetLastClosing
                if ::lcusfilemp
                    if empty(::dFecAntEmp) .Or. (!Empty(dFecAnt) .and.  dFecAnt > ::dFecAntEmp)
                        ::dFecAntEmp := dFecAnt 
                    EndIf    
                EndIf
            Else    
                ::oRepository:cMsgErro :=  STR0019 //'Não encontramos fechamento para data solicitada, existindo fechamento SB9 (saldo iniciais ) SBJ(Saldos Iniciais por Lote) ou SBK(Saldos Iniciais por Endereço ) verifique o parâmetro MV_ULMES se está com a data correta para a filial seleciona, 
                                                  //se o parâmetro for compartilhado entre filiais verificar se não foi realizado outra reabertura ou alteração de data que possa ter deixado a data de incompatível com fechamento solicitado.'
                lRet := .F.
                lRetEmp:= .F.   
            EndIF

            //--criar um json com o Data anterior 
            aAdd( aFilsProc, JsonObject():New() )
            aAdd( aFilsProcAux, JsonObject():New() )
            nCount++

            If lRet .And. !empty(a330ParamZX) .and. ::oContabService:isCalendarInvalid((dFecAnt + 1), sToD(ddataClosing))
                lRet := .F.
                lCalendInv := .T.
                ::oRepository:cMsgErro := STR0022//'Verifique as configurações do calendário contábil .'
            EndIf

            aFilsProc[nCount]["branch"]     := cFilAnt
            aFilsProc[nCount]["mv_ulmes"]   := dMVULMES
            aFilsProc[nCount]["dataOld"]    := dFecAnt
            aFilsProc[nCount]["mensagem"]   := ::oRepository:cMsgErro 
            aFilsProc[nCount]["processa"]   := lRet
            aFilsProc[nCount]["closingNotFound"] := ::oRepository:lClosingNotFound
            
            aFilsProcAux[nCount]["branch"]     := cFilAnt
            aFilsProcAux[nCount]["mv_ulmes"]   := DTOS(dMVULMES)
            aFilsProcAux[nCount]["dataOld"]    := DTOS(dFecAnt)
            aFilsProcAux[nCount]["mensagem"]   := ::oRepository:cMsgErro 
            aFilsProcAux[nCount]["processa"]   := lRet
            aFilsProcAux[nCount]["closingNotFound"] := ::oRepository:lClosingNotFound

            Iif(!lRet, nCountErr++ ,nCountErr)
        EndIf
        ::oRepository:cMsgErro := " "
        ::oRepository:lRetLastClosing := .T.
        ::oRepository:lClosingNotFound := .F.
        dFecAnt := CtoD('')
        lRet := .F.
    Next nX
    if ::lcusfilemp .And. lRetEmp
        for nY := 1 to len(aFilsProc)
            aFilsProc[nY]["mensagem"] := ''
            aFilsProcAux[nY]["mensagem"] := ''

            aFilsProc[nY]["dataOld"]:= DTOS(::dFecAntEmp)
            aFilsProcAux[nY]["dataOld"]:= DTOS(::dFecAntEmp)
    
            nCountErr := 0
        next nY 
    EndIf
    If len(aFilsProc)>0  
	    oJCheck["branchProcess"] := aFilsProc
        oJCheckAux["branchProcess"] := aFilsProcAux
        If nCountErr == 0
            ::oRepository:eventStarReopen(cBranch,cCompany,oJCheckAux, cId, ltotal, cIdProccess, lReopeningSb9, ddataClosing, aFilsCalc, @oJCheck)
        else
            If lCalendInv
                ::lCalendInvalid := .T.
            Else
                ::lNotFoundCount := .T.
            EndIf
        EndIf
    else
        ::lNotFoundBranch := .T.
    EndIf 

    cFilAnt := cFilBack
Return oJCheck


/*/{Protheus.doc} deletingRecIntable
	Função para processar exclusão de registros das tabelas de fechamento
	@type  Function
	@author andre.oliveira
	@since 12/09/2020
	@version 1.0
	@param lBat, logic, Sinaliza processamento sem tela
	@param dMVULMES, date, Data do fechamento que estÃ¡ sendo desfeito (opcional)
    @param dFecAnt, date, Data do fechamento anterior (opcional)
    @param oSay, object, Objeto para atualização de mensagens em tela (opcional)
/*/
Method deletingRecIntable(dMVULMES,dFecAnt, cIdParent, cIdChild, lRepair) class acReopeningOfStockServ
    Local lRet      := .T.
    Local cMsgErro  := ''
    Local lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)
    Local aInfo     := GetApoInfo('distribution.WMS.FechamentoEst.tlpp')
    Local lEstWms   := !Empty(aInfo)
    
    Default lRepair := .F.

    if !lRepair
        ::oRepository:ReopeningLog("MENSAGEM",STR0006 +cFilAnt +" - "+ STR0003,, '2')  // FILIAL // "Início da recomposição dos custos iniciais de produção" 
        //-- Reconstitui campos de controle de custos na SC2     
        lRet := ::oRepository:RebuildTheStartOfSc2(dFecAnt,@cMsgErro)     
        ::oRepository:ReopeningLog("MENSAGEM",STR0006 +cFilAnt +" - "+ STR0004,, '3')  // FILIAL // ""Término da recomposição dos custos iniciais de produção  
    EndIf         

    If lRet
        //-- Deleta fechamentos da SCC - Saldos iniciais por FIFO/LIFO
        lRet := ::oRepository:DeleteClosingRecTables("SCC",dMVULMES)
        //-- Reabre saldos do penultimo periodo por FIFO/LIFO
        Iif( lRet, lRet := ::oRepository:ChangeCCStatus(), lRet)
        //-- Deleta fechamentos da SBK - Saldos iniciais por endereÃ§os e números de série
        Iif( lRet, lRet := ::oRepository:DeleteClosingRecTables("SBK",dMVULMES),lRet)
        //-- Deleta fechamentos da SBJ - Saldos iniciais por lotes e sublotes
        Iif( lRet, lRet := ::oRepository:DeleteClosingRecTables("SBJ",dMVULMES),lRet)
        //-- Deleta fechamentos da SB9 - Saldos iniciais por local de estoque
        Iif( lRet, lRet := ::oRepository:DeleteClosingRecTables("SB9",dMVULMES),lRet)
        //Chamada da função para estornar os valores da D8 em caso de notas de devolução com custo FIFO
        If ::lFIFOLIFO 
            ::oRepository:conditionalValue(lRet, lRet := ::EstDevFIFO(dMVULMES), lRet)
        EndIf
        ::oRepository:ReopeningLog("MENSAGEM",STR0006 +cFilAnt,IiF(!lRepair,STR0005,'Excluido tabela de fechamento')+DToC(dFecAnt) + STR0007 +DToC(dMVULMES)+".",'6', ) //"Reaberto o período de  //a
        //--Deleta fechamento da D15 - Saldo Iniciais WMS
        If lWmsNew .And. lEstWms
            ::oRepositoryWMS := distribution.WMS.FechamentoEst.DistributionWmsFechEst():new()
            lRet := ::oRepositoryWMS:DeleteWmsFechEst("D15",dMVULMES,@::oRepository,@cMsgErro)
        EndIf
    EndIf

    If !lRet
        ProcLogAtu("MENSAGEM",STR0006 +cFilAnt + cMsgErro) //FILIAL
        ::oRepository:ReopeningLog("ERRO",STR0006 +cFilAnt + cMsgErro, ,'ER',) //FILIAL
    EndIf
    
    IIF(lRepair .And. !lRet, DisarmTransaction(), NIL)

Return lRet



/*/{Protheus.doc} MATA282Prc
	Função para processar exclusão de registros das tabelas de fechamento
	@type  Function
	@author andre.oliveira
	@since 12/09/2020
	@version 1.0
	@param lBat, logic, Sinaliza processamento sem tela
	@param dMVULMES, date, Data do fechamento que estÃ¡ sendo desfeito (opcional)
    @param dFecAnt, date, Data do fechamento anterior (opcional)
    @param oSay, object, Objeto para atualização de mensagens em tela (opcional)
/*/

Method literature(cAlias) class acReopeningOfStockServ
 Do Case
        Case cAlias == "SBJ"
            ::cNomeTab := STR0008 //"saldos iniciais de lotes e sublotes"
            ::cNameStep:= "J"
        Case cAlias == "SBK"
            ::cNomeTab := STR0009 //"saldos iniciais de endereços e números de série"      
            ::cNameStep:= "K"     
        Case cAlias == "SB9"
            ::cNomeTab := STR0010 //"saldos iniciais por local de estoque"
            ::cNameStep:= "A"
        Case cAlias == "SCC"
            ::cNomeTab := STR0011 //"saldos iniciais FIFO/LIFO"
            ::cNameStep:= "C"
        Case ::lWmsNew .And. ::lEstWms .And. cAlias == "D15"
            ::cNomeTab := STR0024 //"Saldos iniciais WMS"
            ::cNameStep:= "D"
    EndCase
Return 


/*/{Protheus.doc} eventInitialProces
    Metodo responsavel por iniciar processamento do MATA330 por job
    @type  Metodo
    @author André Maximo 
    @since  Novembro 26,2020
    @version 12.1.27
/*/
Method eventInitialProces(cBranch,cCompany,cFilsProc, cIdParent, cIdChild, ltotal, cIdProccess, lReopeningSb9, ddataClosing, cUserNamek, aFilsProc,lAdvpr) Class acReopeningOfStockServ
Local oFilsProc :=JsonObject():new()
Local cFilBack  := cFilant
Local nX        := 0
Local lCMDBLQV  := .T.
Local lRet      := .F.
Local cProcess  := 'EST282'
Local oError    := ErrorBlock({|e| ::logErrorProc(e:Description, e:ErrorStack, ::oRepository:oJourneyLog,lAdvpr)})

Default lAdvpr := .F.

If Empty(cUserName)
    cUserName := cUserNamek
EndIf

oFilsProc:fromJson(cFilsProc) 

::oRepository:oJourneyLog:logIni(,.T.)
::oRepository:oJourneyLog:idMovD3X()
::oRepository:oJourneyLog:setThreadId( Strzero(ThreadID(),15))
::oRepository:oJourneyLog:cIdParent := cIdParent
::oRepository:oJourneyLog:cIdChild  := cIdChild


::ReopeningMetrics()

LockByName(cProcess + '_' +  cIdChild, .F. , .F.)

Begin Sequence

::oRepository:ReopeningLog("INICIO")
::oRepository:ReopeningLog("AMBIENTE")

If lReopeningSb9 
    ::ReopeningLogSb9(cIdParent, cIdChild, aFilsProc, ddataClosing) 
ElseIf ltotal 
    ::oRepository:oJourneyLog:updateD3YPositi('EST282', .T., ltotal)
else  
   ::ParcialReopeningLog(cIdParent, cIdChild, oFilsProc)  
EndIf 

If ::oRepository:oJourneyLog:processHasStarted(cIdParent, cIdChild, 'EST282')
	::oRepository:oJourneyLog:attStatus('PROCESSING', .T.)
Endif

BEGIN TRANSACTION
    For nX := 1 To len(oFilsProc['branchProcess']) 
        If oFilsProc['branchProcess'][nX]['processa'] 
            cFilant := oFilsProc['branchProcess'][nX]['branch']
            ::oRepository:cFilSD3 := xFilial("SD3") 
            ::oRepository:cFilSC2 := xFilial("SC2")
            lRet := ::deletingRecIntable(STOD(oFilsProc['branchProcess'][nX]['mv_ulmes']),STOD(oFilsProc['branchProcess'][nX]['dataOld']), cIdParent, cIdChild)
        EndIf 
       If !lRet
            DisarmTransaction()
            Exit
       EndIf
    next nX
END TRANSACTION



If lRet
    //-- Atualiza MV_ULMES e MV_DBLQMOV
    For nX := 1 To len(oFilsProc['branchProcess']) 
        cFilant := oFilsProc['branchProcess'][nX]['branch']
        lCMDBLQV := GetMv("MV_CMDBLQV",.F.,.F.) ==  .T.
        ::oRepository:RecSX6(STOD(oFilsProc['branchProcess'][nX]['dataOld']), lCMDBLQV)
    Next nX

    cFilant := cFilBack
    ::oRepository:ReopeningLog("FIM") //FILIAL
    ::oRepository:oJourneyLog:updateD3YPositi('EST282',,.T.)
    ::oRepository:oJourneyLog:attStatus('FINISHED', .F.)
Endif

End Sequence

UnLockByName(cProcess + '_' +  cIdChild, .F., .F.)

ErrorBlock(oError)

return 
/*/{Protheus.doc} eventStarReopen
    Metodo responsavel por abrir o startJob para processamento do recalculo
    @type  Metodo
    @author André Maximo 
    @since  julho 02,2021
    @version 12.1.27
/*/
method logErrorProc(errorMessage, errorStack,JourneyLog,lAdvpr) class acReopeningOfStockServ

Local cProcess := 'EST282'

Default lAdvpr := .F.

If Empty(JourneyLog:cProcess)
    JourneyLog:cProcess := cProcess
Endif

DisarmTransaction()

JourneyLog:LogProAtu('ERRO', errorMessage, errorMessage + errorStack, cFilAnt, 'ER', dDataBase, cFilAnt, .T.)

UnLockByName(cProcess + '_' +  JourneyLog:cIdChild, .F., .F.)
If !lAdvpr
    UserException( errorMessage )
Endif

Return 




/*/{Protheus.doc} eventInitialProces
    Metodo responsavel por iniciar processamento do MATA330 por job
    @type  Metodo
    @author Maximo 
    @since  junho 21,2021
    @version 12.1.27
/*/

Method ReopeningLogSb9(cIdParent, cIdChild, aFilsProc, ddataClosing) Class acReopeningOfStockServ
    Local oFilsProc := JsonObject():new()
    Local cStruct      := '{"closing":{"mta280":[]},"contabilization":{"mta331":[]},"recalculation":{"mta330":[]}}'
    Local oBranchesSer :=  ac.branchesList.Serv.acBranchesListServ():new()

    oFilsProc["branches"]:=   oBranchesSer:listBranchesinformated(aFilsProc)
    oFilsProc["params"]  :=  '{"params": [], "branches": []}'
    ::oRepository:oJourneyLog:InsertD3y( cIdParent,;
    'RE1'                                ,; 
    'P'                                  ,; 
    ' '                                  ,;
    cStruct                              ,; 
    "SB9"                                ,; 
    oFilsProc:GetJsonText("params")      ,; 
    cIdChild                             ,;
    oFilsProc:GetJsonText("branches")    ,;
   DtoC(STOD(ddataClosing)) )

       
return 
/*/{Protheus.doc} eventInitialProces
    Metodo responsavel por iniciar processamento do MATA330 por job
    @type  Metodo
    @author Maximo 
    @since  junho 21,2021
    @version 12.1.27
/*/

Method ParcialReopeningLog(cIdParent, cIdChild, jBrancheSelectReopening) Class acReopeningOfStockServ

    ::oRepository:oJourneyLog:CopyInformationD3Y(cIdParent)
    ::BranchFixed(::oRepository:oJourneyLog:jBranches, jBrancheSelectReopening)
    ::ParamsFixedForUpdate(::oRepository:oJourneyLog:cParams,jBrancheSelectReopening)
   

    ::oRepository:oJourneyLog:InsertD3y( cIdParent,;
    'RE1'                                ,; 
    'P'                                  ,; 
    ' '                                  ,;
    ::oRepository:oJourneyLog:cStruct    ,; 
    ::oRepository:oJourneyLog:cType      ,; 
    (::obranchesMont2:toJson())          ,; 
                              cIdChild   ,;
    (::oAux4BranchFixed:toJson())        ,;
     DToC(::oRepository:oJourneyLog:dD3yDTFECH))

    
    ::oRepository:oJourneyLog:PatchD3Y(::oRepository:oJourneyLog:cIdParentCopy,,,,,,(::obranchesMont:toJson()),::oRepository:oJourneyLog:cIdChildCopy,(::oAux3BranchFixed:toJson()))
    
   
return 

/*/{Protheus.doc} eventInitialProces
    Metodo responsavel por iniciar processamento do MATA330 por job
    @type  Metodo
    @author Maximo 
    @since  junho 21,2021
    @version 12.1.27
/*/

Method BranchFixed(jbranches, jBrancheSelectReopening) Class acReopeningOfStockServ
Local nX    := 0 
Local nY    := 0
Local nZ    := 0
local nW    := 0
Local lNotTag := .F.      as logical
Local nCountposition := 0 as numeric
Local aFil           := {} as Array
Local aFilNew        := {} as Array
Local oAux           := JsonObject():new()

oAux:FromJson(jBranches)
::oAux3BranchFixed:FromJson(jBranches)
::oAux4BranchFixed:FromJson(jBranches)
if Len(oAux) > 0 .And. !::oAux3BranchFixed[Len(oAux)]:hasproperty("Tag")
    lNotTag := .T.
EndIF
         //--------------------------------------------------------------//
        // IF                                                           // 
        //  Localiza as branches e retiro para colocar na D3Y antiga    // 
        // no Else                                                      //
        //  Deleto tudo que não esta contemplano na reabertura para nova// 
        //  D3Y de reabertura                                           //
        //--------------------------------------------------------------//

        For nY := 1 To Len(oAux) 
            For nX := 1 To len(jBrancheSelectReopening['branchProcess'])
                If Alltrim(jBrancheSelectReopening["branchProcess"][nX]["branch"]) == AllTrim(oAux[nY]['Code'])
                    ::oAux3BranchFixed[nY]:delName('Code')
                    ::oAux3BranchFixed[nY]:delName('Description')
                    ::oAux3BranchFixed[nY]:delName('Cgc')
                    ::oAux3BranchFixed[nY]:delName('Tag')
                else
                    ::oAux4BranchFixed[nY]:delName('Code')
                    ::oAux4BranchFixed[nY]:delName('Description')
                    ::oAux4BranchFixed[nY]:delName('Cgc')
                    ::oAux4BranchFixed[nY]:delName('Tag')
                EndIf
            next nX
        next nY

        For nZ := 1 to len(::oAux3BranchFixed)
            If  !Empty(::oAux3BranchFixed[nZ]["Code"]) 
                aAdd( aFil,  JsonObject():New() )
                nCountposition++
                aFil[nCountposition]["Code"]        := ::oAux3BranchFixed[nZ]["Code"] 
                aFil[nCountposition]["Cgc"]	        := ::oAux3BranchFixed[nZ]["Cgc"]
                aFil[nCountposition]["Description"]	:= ::oAux3BranchFixed[nZ]["Description"]
                if!lNotTag
                    aFil[nCountposition]["Tag"]	:= ::oAux3BranchFixed[nZ]["Tag"]
                EndIf
            EndIf
        next nZ
        nCountposition := 0
        ::oAux3BranchFixed:set(afil)

         For nW := 1 to len(::oAux4BranchFixed)
            If  !Empty(::oAux4BranchFixed[nW]["Code"]) 
                aAdd( aFilNew,  JsonObject():New() )
                nCountposition++
                aFilNew[nCountposition]["Code"]         := ::oAux4BranchFixed[nW]["Code"] 
                aFilNew[nCountposition]["Cgc"]	        := ::oAux4BranchFixed[nW]["Cgc"]
                aFilNew[nCountposition]["Description"]	:= ::oAux4BranchFixed[nW]["Description"]
                if !lNotTag
                    aFilNew[nCountposition]["Tag"]	:= ::oAux4BranchFixed[nW]["Tag"]
                EndIf
            EndIf
        next nW
        nCountposition := 0
        ::oAux4BranchFixed:set(aFilNew)

::oAux3BranchFixed:toJson()
::oAux4BranchFixed:toJson()


return 

/*/{Protheus.doc} eventInitialProces
    Metodo responsavel por iniciar processamento do MATA330 por job
    @type  Metodo
    @author Maximo 
    @since  junho 21,2021
    @version 12.1.27
/*/

Method ParamsFixedForUpdate(jParams, jBrancheSelectReopening) Class acReopeningOfStockServ
Local nX    := 0 
Local nY    := 0
Local nZ    := 0
local nW    := 0
Local nCountposition  := 0  as numeric
Local aFil            := {} as Array
Local aFilNew         := {} as Array
Local oAux            := JsonObject():new()
Local oAux3ParamsFixed:= JsonObject():new()
Local oAux4ParamsFixed:= JsonObject():new()

oAux:FromJson(jParams)
oAux3ParamsFixed:FromJson(jParams)
oAux4ParamsFixed:FromJson(jParams)

        //--------------------------------------------------------------//
        // IF                                                           // 
        //  Localiza as branches e retiro para colocar na D3Y antiga    // 
        // no Else                                                      //
        //  Deleto tudo que não esta contemplano na reabertura para nova// 
        //  D3Y de reabertura                                           //
        //--------------------------------------------------------------//
        For nY := 1 To len(oAux["branches"]) 
            For nX := 1 To len(jBrancheSelectReopening['branchProcess'])
                If Alltrim(jBrancheSelectReopening["branchProcess"][nX]["branch"]) == AllTrim(oAux["branches"][nY]["Code"])
                    oAux3ParamsFixed["branches"][nY]:delName('Code')
                    oAux3ParamsFixed["branches"][nY]:delName('Cgc')
                    oAux3ParamsFixed["branches"][nY]:delName('Description')
                    oAux3ParamsFixed["branches"][nY]:delName('parameters')
                    oAux3ParamsFixed["branches"][nY]:delName('Tag')
                else
                    oAux4ParamsFixed["branches"][nY]:delName('Code')
                    oAux4ParamsFixed["branches"][nY]:delName('Cgc')
                    oAux4ParamsFixed["branches"][nY]:delName('Description')
                    oAux4ParamsFixed["branches"][nY]:delName('parameters')
                    oAux4ParamsFixed["branches"][nY]:delName('Tag')
                EndIf
            next nX
        next nY

        For nZ := 1 to len(oAux3ParamsFixed["branches"])
            If  !Empty(oAux3ParamsFixed["branches"][nZ]["Code"]) 
                aAdd( aFil,  JsonObject():New() )
                nCountposition++
                aFil[nCountposition]["Code"]        := oAux3ParamsFixed["branches"][nz]["Code"]
                aFil[nCountposition]["Cgc"]	        := oAux3ParamsFixed["branches"][nz]["Cgc"]
                aFil[nCountposition]["Description"]	:= oAux3ParamsFixed["branches"][nz]["Description"]
                aFil[nCountposition]["parameters"]  := oAux3ParamsFixed["branches"][nz]["parameters"]
                aFil[nCountposition]["Tag"]	        := oAux3ParamsFixed["branches"][nz]["Tag"]
            EndIf
        next nZ 
        ::obranchesMont["branches"]:= aFil
        ::obranchesMont["params"]  := oAux3ParamsFixed["params"]
        nCountposition := 0
    
         For nW := 1 to len(oAux4ParamsFixed["branches"])
            If  !Empty(oAux4ParamsFixed["branches"][nW]["Code"]) 
                aAdd( aFilNew,  JsonObject():New() )
                nCountposition++
                aFilNew[nCountposition]["Code"]         := oAux4ParamsFixed["branches"][nW]["Code"]
                aFilNew[nCountposition]["Cgc"]	        := oAux4ParamsFixed["branches"][nW]["Cgc"]
                aFilNew[nCountposition]["Description"]	:= oAux4ParamsFixed["branches"][nW]["Description"]
                aFilNew[nCountposition]["parameters"]   := oAux4ParamsFixed["branches"][nW]["parameters"]
                aFilNew[nCountposition]["Tag"]	    := oAux4ParamsFixed["branches"][nW]["Tag"]
            EndIf
        next nW
        ::obranchesMont2["branches"]:= aFilNew
        ::obranchesMont2["params"]  := oAux4ParamsFixed["params"]




return 

Method ReopeningMetrics() Class acReopeningOfStockServ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
// Telemetria - Uso da classe FwCustomMetrics                    //
// Metrica - setAverageMetric                                    //
// Grava se utiliza o processo de reabertura de estoque         //
//?ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
If FWLibVersion() >= "20210628"
    FWCustomMetrics():setAverageMetric(	"REABERTURA"/*cSubRoutine*/,;
                                        "estoque/custos-protheus_reabertura-de-estoque_count" /*cIdMetric*/,;
                                        1 /*nValue*/,;
                                        /*dDateSend*/,;
                                        /*nLapTime*/,;
                                        "EST282"/*cRotina*/)
EndIf

Return


/*/{Protheus.doc} eventInitialProces
    Metodo responsavel por iniciar processamento do MATA330 por job
    @type  Metodo
    @author Maximo 
    @since  junho 21,2021
    @version 12.1.27
/*/

Method AnalyzeRepairBranches(aParansfil, dDateClosin, cId, cidProccess) Class acReopeningOfStockServ
Local ORetValid := JsonObject():new()
    
    ORetValid := ::oRepository:eventStarRepair(aParansfil, dDateClosin, cId, cidProccess, cUserName)

Return ORetValid

/*/{Protheus.doc} eventInitialProcesRepair
    Metodo responsavel por iniciar processamento de reparo MATA280
    @type  Metodo
    @author Maximo 
    @since  junho 21,2021
    @version 12.1.27
/*/

Method eventInitialProcesRepair(aParansfil, dDateClosin, cId, cidProccess, cIdChildNew,cUserNameJ, lAdvpr ) Class acReopeningOfStockServ
Local cFilBack as character
Local oStatus as Object
Local nY := 0 as numeric
local lRet:= .F.  as logical
Local oError    := ErrorBlock({|e| ::logErrorProc(e:Description, e:ErrorStack, ::oRepository:oJourneyLog,lAdvpr)})
Local oLogRepository := ac.Log.Repository.acLogRepository():new()

Default lAdvpr := .F.

cUserName:= cUserNameJ
::oRepository:oJourneyLog:logIni(,,.T.)
::oRepository:oJourneyLog:idMovD3X()
::oRepository:oJourneyLog:setThreadId( Strzero(ThreadID(),15))
::oRepository:oJourneyLog:cIdParent := cId
::oRepository:oJourneyLog:cIdChild  := cidProccess
::oRepository:oJourneyLog:updateD3YPositi('REPAIR', , , .F.)

oStatus := oLogRepository:GetStatusD3X(cId, 'MATA280', cIdProccess)
cFilBack:=  cFilant

::oRepository:oJourneyLog:cIdParent := cidProccess
::oRepository:oJourneyLog:cIdChild  := cIdChildNew
::oRepository:cIdReopen := cId

If ::oRepository:oJourneyLog:processHasStarted(cidProccess, cIdChildNew, 'REPAIR')
	::oRepository:oJourneyLog:attStatus('PROCESSING', .T.)
Endif

cFilBack:=  cFilant
begin Sequence

If Alltrim(oStatus["status"]) == "ER" 
    for nY := 1 to len(aParansfil)
        ::oRepository:ReopeningLog("INICIO")
        ::oRepository:ReopeningLog("AMBIENTE")
        cFilAnt := aParansfil[nY,2]
        dMVULMES  := GetMV("MV_ULMES") 
        dFecAnt   := ::oRepository:getPenultimateClosing(StoD(dDateClosin))
        BEGIN TRANSACTION
            lRet := ::deletingRecIntable(StoD(dDateClosin),dFecAnt, cId, cidProccess, .T.)
        END TRANSACTION
        If lRet .and. dMVULMES == StoD(dDateClosin)
            ::oRepository:RecSX6(dFecAnt, .F.)
            //::oRepository:ReopeningLog("MENSAGEM",STR0006 +cFilAnt,'Excluido tabela de fechamento',  +DToC(dFecAnt) + STR0007 +DToC(dMVULMES)+".",'6', )
        EndIf
        ::oRepository:ReopeningLog("FIM") //FILIAL
    next nY
EndIf

cFilant := cFilBack
::oRepository:oJourneyLog:attStatus('FINISHED', .F.)

::oRepository:oJourneyLog:cIdParent := cId
::oRepository:oJourneyLog:cIdChild  := cidProccess

::oRepository:oJourneyLog:updateD3YPositi('REPAIR',,,.T.)

End Sequence

ErrorBlock(oError)
       
return


/*/{Protheus.doc} EstDevFIFO
    Metodo para estornar a quantidade de itens devolvidos com saldo FIFO em aberto <> Z
    As devoluções apenas do período que está sendo reaberto o estoque
    @type  Function
    @author rodrigo.carvalheiro
    @since 11/01/2023
    @version 1.0
    @param dDatames = MV_ULMES
    @return .T.
/*/
Method EstDevFIFO(dDataMes) Class acReopeningOfStockServ

Local cKey
Local nQuantDev := 0
Local cAlias    := ""
Local cQuery    := ""
Local cNotaOri  := ""
Local cNumSeqD2 := ""

Local aAreaSD8  := SD8->(GetArea())
Local aAreaSD1  := SD1->(GetArea())
Local aAreaSD2  := SD2->(GetArea())
Local aAreaSBD  := SBD->(GetArea())

cAlias  := GetNextAlias()

cQuery := "SELECT BD_PRODUTO, BD_LOCAL, BD_SEQ, D8_NUMSEQ "
cQuery += " FROM " + RetSQLName("SBD") +" SBD "
cQuery += " JOIN " + RetSQLName("SD8") +" SD8 ON SD8.D8_FILIAL = '" + xFilial("SD8") + "' AND D8_PRODUTO = BD_PRODUTO AND D8_LOCAL = BD_LOCAL AND D8_SEQ =
cQuery += " BD_SEQ AND D8_TIPONF = 'D' AND D8_DTPROC = '" + DTOS(dDataMes) + "' AND D8_ITEM <> ' ' AND SD8.D_E_L_E_T_ = ' ' "
cQuery += " WHERE SBD.BD_FILIAL = '" + xFilial("SBD") + "' "
cQuery += " AND SBD.BD_STATUS <> 'Z' "
cQuery += " AND SBD.D_E_L_E_T_ = ' ' "

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias)

SD1->(dbSetOrder(5))
SD2->(dbSetOrder(3))
SD8->(dbSetOrder(5))

While (calias)->(!Eof())
   
    nQuantDev := 0
    cKey := ""
    cNotaOri := ""
    cNumSeqD2 := ""

    //Posiciona na SD1 para buscar os dados da nota origem
    If SD1->(dbSeek(xFilial("SD1")+(cAlias)->(BD_PRODUTO+BD_LOCAL+D8_NUMSEQ)))
        nQuantDev := SD1->D1_QUANT
        cNotaOri := SD1->(D1_NFORI+D1_SERIORI+D1_FORNECE+D1_LOJA+D1_COD+AllTrim(D1_ITEMORI))  
 
        //Posiciona na SD2 para buscar o D2_NUMSEQ da nota de origem para ajustar na SD8
        If !Empty(cNotaOri) .and. SD2->(dbSeek(xFilial("SD2")+AllTrim(cNotaOri)))
            cNumSeqD2 := SD2->(D2_COD+D2_LOCAL+D2_NUMSEQ)
       
            // Posiciona na SD8 na sequência da nota origem para devolver os movimentos do custo FIFO  
             If nQuantDev <> 0 .and. SD8->(dbSeek(xFilial("SD8")+cNumSeqD2)) .And. SD8->D8_TM > "500" .And. !Empty(SD8->D8_ITEM)
                RecLock("SD8",.F.)
                SD8->D8_SD1DEV  := SD8->D8_SD1DEV - nQuantDev
                SD8->D8_QFIMDEV := 0
                SD8->(MsUnlock())
            EndIf      
        EndIf                                                                      
    EndIf
 
(cAlias)->(dbSkip())

EndDo

(cAlias)->(dbCloseArea())

RestArea(aAreaSD8)
RestArea(aAreaSD1)
RestArea(aAreaSD2)
RestArea(aAreaSBD)

Return(.T.)

/*/{Protheus.doc} PrepareBranchesOk
    Monta array de filiais que ja foram validadas no front e nao necessitam nova validacao
    @author Squad.Entradas
    @since 14/03/2024
    @version 1.0
    @param oJsonParams, object, parametros recebidos
    @return aFilsOk, array, array com filiais validadas
    /*/
Method PrepareBranchesOk(oJsonParams) Class acReopeningOfStockServ

    Local aFilsOk := {}
    Local nX      := 0

    If ValType(oJsonParams['branchesWithoutSB9']) != "U"
        For nX := 1 To Len(oJsonParams['branchesWithoutSB9'])
            aAdd(aFilsOk, {oJsonParams['branchesWithoutSB9'][nX]['company'], oJsonParams['branchesWithoutSB9'][nX]['branch']})
        Next nX
    EndIf

Return aFilsOk
