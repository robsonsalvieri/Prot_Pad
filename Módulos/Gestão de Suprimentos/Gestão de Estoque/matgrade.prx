#INCLUDE "MATGRADE.ch"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "MSOBJECT.CH"
Static __oGrade		:= NIL
Static __cOrigGrd	:= NIL // SBQ= CONFIGURADOR DE PRODUTOS; SB4 = GRADES DE PRODUTOS
Static __cCodBase	:= NIL
Static __nTamBase	:= NIL
Static __nTamLinSB4	:= NIL
Static __nTamColSB4	:= NIL
Static __nTamRefSB4	:= NIL
Static __aInfCodRefs:= NIL	//Array com as informacoes do codigo referencia 
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MsMatGradeºAutor  ³Erike Yuri da Silva º Data ³  08/22/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Programa / Classe de objeto de interface de digitacao de    º±±
±±º          ³grade que unificou todas as informacoes de programas ja     º±±
±±º          ³existentes que utilizam os recursos de grade de produtos    º±±
±±º          ³mantendo o legado das caracteristicas particulares de cada  º±±
±±º          ³um, incluindo novos recursos e funcionalidades.             º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATERIAIS/CRM/                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                       
Function MsMatGrade()
Return          

CLASS MsMatGrade  
	data cObj
	data cProdRef       
	data cCpo        
	data cTudoOk            
	data cVldCpoGrd
	data lShowGrd   
	data lShowButtonRepl
	data lShowMsgDiff
	data aSetKey 
	data cMainCpo // campo controlador da grade
	
	data cMascara  
	data nPosLinO
	data nQtdGrade
	data nQtdInformada
	           
	data IsGrade  
	data lGradeOrdenada
	data lOk

	data aRecNo
	data aHeadGrade
	data aColsGrade        
	data aHeadAux
	data aColsAux 
	data aCposCtrlGrd	//Campos que serao criados como referencia na grade exe: Qtd.Vendida, Qtd. Liberada, ItemSC6
	data oGetDados
   
	data aBkpMult //Para backup do aHeader e aCols da grade multicampo
	data aSumCpos
	data nCposTela
    
	Method New(cObj,cProdRef,cCpo,cTudoOk,cVldCpoGrd,aSetKey,aCposCtrlGrd,lShowGrd)
	Method MontaGrade(nCnt,cProdGrd,lAlterou,lBloqueados,lReFer)
	Method Show(aCpos,aCposTot)
	Method SomaGrade(cCpo,nLinAcols,nQtdInf)         
	Method GetFieldMC(cCpo,nLinha,nColuna)
	Method aColsFieldByName(cCpo,nLinAcols,nLinha,nColuna,lPesqTela)
	Method GetNameLinha(nLinha)
	Method GetNameColuna(nColuna)
	Method GetNameProd(cProdRef,nLinha,nColuna)      
	Method GetDescProd(cProdRef)    
	Method GetDescrGrd(cCodTabela,cCodChave,lMostraChave,nPosArray,cTpGrade) 
	Method GetFieldGrdPos(cCpo)
	Method GetTitTabG(cCodTabela,lColuna)
	Method EmptyGrd(cCpo)
	Method TamLin(nAColsPos)
	Method TamCol(nAColsPos)
	Method TamRef(nAColsPos)      
	Method RetPosLin(nACols,cCpo)
	Method RetPosCol(nACols,cCpo)	
	Method SetRecNo(nACols,nLin,nCol,nRecno)
	Method GetRecNo(nACols,nLin,nCol)
	Method ReplicaItens(cCampo,nValRep)
	Method ZeraGrade(cCampo,nLinPos)
	Method GetTitGrd(cCodTabela,lColuna)
ENDCLASS

Method New(cObj,cProdRef,cCpo,cTudoOk,cVldCpoGrd,aSetKey,aCposCtrlGrd,lShowGrd)  CLASS MsMatGrade          

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa os Parametros com seus valores default                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT cProdRef 	:= ""
DEFAULT cTudoOk		:= "AllwaysTrue"
DEFAULT cVldCpoGrd	:= " .T. "   
DEFAULT lShowGrd	:= .T.   
DEFAULT	aCposCtrlGrd:= {}

If Empty(cObj)
	Final(STR0001) //"A passagem de parametro (cObj) é obrigatoria"
EndIf
                              
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa variaveis do objeto                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
::cObj				:= cObj
::cProdRef			:= cProdRef   
::cCpo				:= UPPER( AllTrim(cCpo) )  
::cTudoOk			:= cTudoOk
::cVldCpoGrd		:= cVldCpoGrd
::lShowGrd			:= lShowGrd
::lShowButtonRepl	:= .T.
::lOk				:= .F.
::aSetKey			:= aClone(aSetKey)
::aHeadGrade		:= {}
::aColsGrade		:= {}
::aHeadAux			:= {}
::aColsAux			:= {}   
::aRecNo			:= {}
::aCposCtrlGrd		:= aClone(aCposCtrlGrd)
::IsGrade			:= SuperGetMv("MV_GRADE",.F.,.F.) 
::lGradeOrdenada	:= SuperGetMv("MV_ORDGRDP",.F.,.T.)
::cMascara			:= SuperGetMv("MV_MASCGRD",.F.,"11,02,02")
::nPosLinO			:= 1
::nQtdGrade			:= 0
::nQtdInformada		:= 0 
::oGetDados			:= NIL                                                     
::cMainCpo			:= ::cCpo
::lShowMsgDiff      := .T.
::aBkpMult			:= Array(2)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa variaveis Static                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
__nTamLinSB4	:= Val(Substr(::cMascara,4,2))
__nTamColSB4	:= Val(Substr(::cMascara,7,2))
__nTamRefSB4	:= Val(Substr(::cMascara,1,2))
__aInfCodRefs	:= {}	//Array com as informacoes do codigo referencia 
__oGrade 		:= Self
Return Self        
                  
//-------------------------------------------------------------------
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Observacao³Estrutura dos Array's de Grade                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³- aHeadGrade               				                              ³±±
±±³  [xx]             Referencia a Linha do Acols Principal    			  ³±±
±±³  [xx][01]         Indica se eh uma (R)Referencia ou (N)Nao 			  ³±±
±±³  [xx][yy]         Colunas da Grade                         			  ³±±
±±³- aColsGrade                                                			  ³±±
±±³  [xx]             Referencia a Linha do Acols Principal    			  ³±±
±±³  [xx][yy]         Referencia a Linha da Grade              			  ³±±
±±³  [xx][yy][01]     Codigo da Linha da Grade                 			  ³±±
±±³  [xx][yy][zz]     Referencia a Coluna da Grade             			  ³±±
±±³  [xx][yy][zz][aa] Campos que a grade ira controlar (Qtd,Lib,item, etc)³±±
±±³                   definido pelo array aCposCtrlGrd do objeto          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Method MontaGrade(nCnt,cProdGrd,lAlterou,lBloqueados,lReFer,lFAtu) CLASS MsMatGrade
Local aArea       := GetArea()
Local aAreaSB1    := SB1->(GetArea())
Local aTam        := {}    
Local aColuna     := {}
Local aLinha      := {}
Local aTemp		  := {}
Local aCposCtrl	  := {}
Local nCntFor     := 0
Local nCntFor2    := 0  
Local nLinhas	  := 0
Local cNameLin    := 0  
Local cNameCol    := ""
Local cChave	  := ""
Local cSx3Cpo	  := Nil
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa os Parametros com seus valores default                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT nCnt		:= 1
DEFAULT	cProdGrd 	:= ""
DEFAULT lAlterou 	:= .F.
DEFAULT lBloqueados := .F.
DEFAULT lReFer		:= If(Empty(cProdGrd),.F.,MatGrdPrrf(@cProdGrd,.T.))    
DEFAULT lFAtu		:= .F.
                           

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se deve ou nao forcar a atualizacao dos itens de linha/coluna  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lFAtu .And. lRefer .And. (!Empty(::cProdRef).or.(!Empty(cProdGrd))) .And. Len(__aInfCodRefs)>=nCnt .And. Empty(__aInfCodRefs[nCnt,1]) // Se nao atualizar e se prod. contr. grade e nao seja primeira utilizacao da grade e array maior ou igual a possicao e produto anterior nao referencia de grade
	lFAtu := .T.			
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa variaveis de controle                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
::cProdRef	:= cProdGrd     
::nPosLinO	:= nCnt

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento da Grade de Produtos                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( !lRefer )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Produto que nao possuem controle de grade.                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( Len(::aHeadGrade) >= nCnt )
		::aHeadGrade[nCnt]  := {}
		Aadd(::aHeadGrade[nCnt],"N")
		::aColsGrade[nCnt]	:= {}       
		While Len(__aInfCodRefs) < nCnt
			Aadd(__aInfCodRefs	,{"",0})		
		EndDo
		__aInfCodRefs[nCnt]	:= {"",0}
	Else
		While Len(::aHeadGrade) < nCnt
			Aadd(::aHeadGrade	,{})
			Aadd(::aHeadGrade[Len(::aHeadGrade)],"N")
			Aadd(::aColsGrade	,{})
			Aadd(__aInfCodRefs	,{"",0})
		EndDo
	EndIf
Else                   	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Produto que possue controle por grade                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty(::cCpo)
		Final(STR0002) //"A passagem de parametro do campo (cCpo) é obrigatoria"
	EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Definicao do sub-array de controle da grade para os campos guardados    ³
	//³Onde:                                                                   ³
	//³aCposCtrlGrd[x,1y]:Nome do campo que sera armazenado as quantidades     ³	
	//³                   informadas na grade.                                 ³ 
	//³aCposCtrlGrd[x,2y]:Logico que permite ou nao chamar a curva de caract.  ³							
	//³aCposCtrlGrd[x,3y]:Array de campos/funcoes para alimentar de forma      ³	
	//³                   generica os campos vinculado ao campo informado.     ³
	//³		aCposCtrlGrd[3y,1]:Campo a ser atualizado.                         ³	
	//³		aCposCtrlGrd[3y,2]:Bloco de codigo para atualizar o campo  		   ³	
	//³aCposCtrlGrd[x,4y]:Array de campos/funcoes para alimentar de forma      ³	
	//³                   generica os campos vinculado ao campo informado na   |
	//³                   interface multicampo.								   | 
	//³aCposCtrlGrd[x,5y]:Define se o campo e obrigatorio para validar na multi| 
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ					
	For nCntFor:=1 To Len(::aCposCtrlGrd)
		aTam := TamSX3( Upper(AllTrim(::aCposCtrlGrd[nCntFor,1])) )
		Aadd(aCposCtrl,If(aTam[3]=="N",0,If(aTam[3]=="D",CTOD(""),Space(aTam[1]))))
	Next nCntFor
	        
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza as informacoes do codigo referencia                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    
	SetInfCodRefs(::cProdRef,nCnt,lFAtu)
	cNameLin := __aInfCodRefs[nCnt][3,1]
	cNameCol := __aInfCodRefs[nCnt][4,1]
		
	If ( Len(::aHeadGrade) >= nCnt )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Quando existe, verifica se o array era de um produto     ³
		//³ referencia, se ja era ok, se nao deve criar o array de   ³
		//³ novo                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( ::aHeadGrade[nCnt][1] == "N" .Or. lAlterou )
			::aHeadGrade[nCnt]		:= {}
			Aadd(::aHeadGrade[nCnt],{})
			::aHeadGrade[nCnt][1]	:= "R"
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza array de Recno para a linha do aCols                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			While nCnt > Len(::aRecNo)
				Aadd(::aRecNo,{} )
			EndDo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica as Linhas e Colunas da Grade pelo produto                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistBlock("PVORDGRL") .And. ExistBlock("PVORDGRC")
				aLinha  := ExecBlock("PVORDGRL",.F.,.F.,{::cProdRef})
				aColuna := ExecBlock("PVORDGRC",.F.,.F.,{::cProdRef})
			Else       
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Checa a origem dos dados e alimenta as variaveis                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    
				DO CASE
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³A origem eh grade de produtos³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
					CASE MatOrigGrd() == "SB4"
						dbSelectArea("SB1")
						dbSetOrder(1)
						cChave	:= xFilial("SB1")+::cProdRef 
						MsSeek(cChave)
						While SB1->( !Eof() .And. B1_FILIAL+SubStr(B1_COD,1,::TamRef()) == cChave )
							If SB1->B1_GRADE # "S" .And. ( !RegistroOk("SB1",.F.) .Or. lbloqueados )
								dbSkip()
								Loop
							EndIf
							dbSelectArea("SBV")
							dbSetOrder(1)
							If ( aScan(aColuna, {|x| x[1] == SubStr(SB1->B1_COD,::TamRef()+::TamLin()+1,::TamCol())} )==0 ) 
								dbSeek(xFilial("SBV")+SB4->B4_COLUNA+SubStr(SB1->B1_COD,::TamRef()+::TamLin()+1,::TamCol()))
								Aadd(aColuna,{SubStr(SB1->B1_COD,::TamRef()+::TamLin()+1,::TamCol()),SBV->(Recno())})
							EndIf
							If ( aScan(aLinha, {|x| x[1] == SubStr(SB1->B1_COD,::TamRef()+1,::TamLin())} )==0 )
								dbSeek(xFilial("SBV")+SB4->B4_LINHA+SubStr(SB1->B1_COD,::TamRef()+1,::TamLin()))
								Aadd(aLinha,{SubStr(SB1->B1_COD,::TamRef()+1,::TamLin()),SBV->(Recno())})
							EndIf
							SB1->( dbSkip() )
						EndDo
				
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³A origem eh codigo inteligente³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ						
					CASE MatOrigGrd() == "SBQ"         
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Definicao das Linhas³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						DbSelectArea("SBQ")
						SBQ->( DbGoto(__aInfCodRefs[nCnt][3,4]) )
				
						If SBQ->BQ_TIPDEF == "1"
							DbSelectArea("SBS")
							DbSetOrder(1)
							//-- Carrega interface de grade linha
							cChave := xFilial("SBS")+GetCodBase()+cNameLin
							MsSeek(cChave)
							While SBS->( !Eof() .And. BS_FILIAL+BS_BASE+BS_ID == cChave )
								Aadd(aLinha,SubStr(SBS->BS_CODIGO,1,::TamLin()))
								SBS->( DbSkip() )
							EndDo 
						ElseIf SBQ->BQ_TIPDEF == "2"
							DbSelectArea("SBX")
							DbSetOrder(1)   
							//-- Carrega interface de grade linha def. conjunto
							cChave := xFilial("SBX")+SBQ->BQ_CONJUNT
							MsSeek(cChave)
							While SBX->( !Eof() .And. BX_FILIAL+BX_CONJUN == cChave )
								Aadd(aLinha,SubStr(SBX->BX_CODOP,1,::TamLin()))
								SBX->( DbSkip() )
							EndDo 
						ElseIf SBQ->BQ_TIPDEF == "3"
							For nCntFor := SBQ->BQ_INTDE TO SBQ->BQ_INTATE STEP SBQ->BQ_INTSTEP
								Aadd(aLinha,StrZero(nCntFor, SBQ->BQ_TAMANHO))
							Next nCntFor						
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Definicao das Colunas³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	                    
						DbSelectArea("SBQ")
						SBQ->( DbGoto(__aInfCodRefs[nCnt][4,4]) )
						If SBQ->BQ_TIPDEF == "1"
							DbSelectArea("SBS")
							DbSetOrder(1)
							//-- Carrega interface de grade Coluna
							cChave := xFilial("SBS")+GetCodBase()+cNameCol
							MsSeek(cChave)
							While SBS->( !Eof() .And. BS_FILIAL+BS_BASE+BS_ID == cChave )
								Aadd(aColuna,SubStr(SBS->BS_CODIGO,1,::TamCol()))
								SBS->( DbSkip() )
							EndDo						
						ElseIf SBQ->BQ_TIPDEF == "2"
							DbSelectArea("SBX")
							DbSetOrder(1)
							//--Carrega interface de grade Coluna def. conjunto
							cChave := xFilial("SBX")+SBQ->BQ_CONJUNT
							MsSeek(cChave)
							While SBX->( !Eof() .And. BX_FILIAL+BX_CONJUN == cChave )
								Aadd(aColuna,SubStr(SBX->BX_CODOP,1,::TamCol()))
								SBX->( DbSkip() )
							EndDo
						ElseIf SBQ->BQ_TIPDEF == "3"
							For nCntFor := SBQ->BQ_INTDE TO SBQ->BQ_INTATE STEP SBQ->BQ_INTSTEP
								Aadd(aColuna,StrZero(nCntFor, SBQ->BQ_TAMANHO))
							Next nCntFor						
							
						EndIf						
				ENDCASE			
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se deve ordenar as linhas e colunas da grade                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
			If ::lGradeOrdenada .And. MatOrigGrd() <> "SB4" 
				aColuna  := aSort(aColuna)
				aLinha   := aSort(aLinha)
			ElseIf ::lGradeOrdenada .And. MatOrigGrd() == "SB4" 
				aColuna  := aSort(aColuna,,,{|x,y| x[1] < y[1]})
				aLinha   := aSort(aLinha,,,{|x,y| x[1] < y[1]})
			ElseIF !(::lGradeOrdenada) .And. MatOrigGrd() == "SB4" 
				aColuna  := aSort(aColuna,,,{|x,y| x[2] < y[2]})
				aLinha   := aSort(aLinha,,,{|x,y| x[2] < y[2]})
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Retorna os arrays aColuna e aLinha para 1 dimensao		               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
			If MatOrigGrd() == "SB4" 
				aEval(aColuna,{|x| aAdd(aTemp,x[1])})
				aColuna := aClone(aTemp)
				aTemp := {}
				aEval(aLinha,{|x| aAdd(aTemp,x[1])})
				aLinha := aClone(aTemp)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Guarda codigo das linhas e colunas da grade para ser usado em funcoes   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ				    
			__aInfCodRefs[nCnt][3,3]	:= aClone(aLinha)
			__aInfCodRefs[nCnt][4,3]	:= aClone(aColuna)  
								                                                                                
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Posiciona no SX3 X3_CAMPO desejado                                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cSx3Cpo := StrTran( Self:cCpo,"M->","" )
			If Empty( ESTFwSX3Util():xGetDescription( cSx3Cpo ) )
				Final(STR0003+cCpo+STR0004)			 //"O campo '"###"' nao foi localizado no dicionario de campos SX3"
			EndIf			
		 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica a Coluna da Grade                                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
			For nCntFor := 1 To Len(aColuna)
				Aadd(::aHeadGrade[nCnt],{ AllTrim(::GetDescrGrd(cNameCol,aColuna[nCntFor],.T.,nCnt,"C")),;
					"_"+A550RemoveSinal(aColuna[nCntFor]),;
					X3Picture( cSx3Cpo ),;
					TamSx3( cSx3Cpo )[ 1 ],;
					TamSx3( cSx3Cpo )[ 2 ],;
					'MatVldGGrd() .And. ' + Self:cVldCpoGrd,;
					"û",;
					TamSx3( cSx3Cpo )[ 3 ],;
					CpoRetF3( cSx3Cpo ),;
					" " })
			Next nCntFor    
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica a Linha da Grade                                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::aColsGrade[nCnt]  := {}
			For nCntFor := 1 To Len(aLinha)
				//-- Inicializa linha para controle de Recno
				Aadd(::aRecNo[nCnt],{})
				nLinhas++               
				For nCntFor2 := 1 To Len(::aHeadGrade[nCnt])
					If ( nCntFor2 == 1 )
						Aadd(::aColsGrade[nCnt],{})
						Aadd(::aColsGrade[nCnt][nLinhas],::GetDescrGrd(cNameLin,aLinha[nCntFor],.T.,nCnt,"L"))
					Else
						Aadd(::aColsGrade[nCnt][nLinhas],aClone(aCposCtrl))
						//-- Inicializa Array do Recno para coluna
						Aadd(::aRecNo[nCnt][nLinhas],0)
					EndIf
				Next nCntFor2
				Aadd(::aColsGrade[nCnt][nLinhas],.F.)
			Next nCntFor
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Inicializa aHeader da Linha do aCols principal                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Aadd(::aHeadGrade,{})
		Aadd(::aHeadGrade[nCnt],"R")
	    
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza array de Recno para a linha do aCols                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		While nCnt > Len(::aRecNo)
			Aadd(::aRecNo,{} )
		EndDo
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica as Linhas e Colunas da Grade pelo produto                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("PVORDGRL") .And. ExistBlock("PVORDGRC")
			aLinha  := ExecBlock("PVORDGRL",.F.,.F.,{::cProdRef})
			aColuna := ExecBlock("PVORDGRC",.F.,.F.,{::cProdRef})
		Else	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Checa a origem dos dados e alimenta as variaveis                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    
			DO CASE
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³A origem eh grade de produtos³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
				CASE MatOrigGrd() == "SB4" 
					dbSelectArea("SB1")
					dbSetOrder(1)
					MsSeek(xFilial("SB1")+::cProdRef)
					While ( !Eof() .And. SB1->B1_FILIAL == xFilial("SB1") .And.;
							SubStr(SB1->B1_COD,1,::TamRef()) == ::cProdRef )
						If RegistroOk("SB1",.F.) .Or. lBloqueados
							dbSelectArea("SBV")
							dbSetOrder(1)
							If ( aScan(aColuna,{|x| x[1] == SubStr(SB1->B1_COD,::TamRef()+::TamLin()+1,::TamCol())} )==0 )
								dbSeek(xFilial("SBV")+SB4->B4_COLUNA+SubStr(SB1->B1_COD,::TamRef()+::TamLin()+1,::TamCol()))
								Aadd(aColuna,{SubStr(SB1->B1_COD,::TamRef()+::TamLin()+1,::TamCol()),SBV->(Recno())})
							EndIf
					   		If ( aScan(aLinha,{|x| x[1] == SubStr(SB1->B1_COD,::TamRef()+1,::TamLin())} )==0 )
								dbSeek(xFilial("SBV")+SB4->B4_LINHA+SubStr(SB1->B1_COD,::TamRef()+1,::TamLin()))
								Aadd(aLinha,{SubStr(SB1->B1_COD,::TamRef()+1,::TamLin()),SBV->(Recno())})
							EndIf
						EndIf
						dbSelectArea("SB1")
						dbSkip()
					EndDo
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³A origem eh codigo inteligente³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ						
					CASE MatOrigGrd() == "SBQ"         
						DbSelectArea("SBQ")
						SBQ->( DbGoto(__aInfCodRefs[nCnt][3,4]) )
						If SBQ->BQ_TIPDEF == "1"
							DbSelectArea("SBS")
							DbSetOrder(1)
							//-- Carrega interface de grade linha
							cChave := xFilial("SBS")+GetCodBase()+cNameLin
							MsSeek(cChave)
							While SBS->( !Eof() .And. BS_FILIAL+BS_BASE+BS_ID == cChave )
								Aadd(aLinha,SubStr(SBS->BS_CODIGO,1,::TamLin()))
								SBS->( DbSkip() )
							EndDo 
						ElseIf SBQ->BQ_TIPDEF == "2"
							DbSelectArea("SBX")
							DbSetOrder(1)   
							//-- Carrega interface de grade linha def. conjunto
							cChave := xFilial("SBX")+SBQ->BQ_CONJUNT
							MsSeek(cChave)
							While SBX->( !Eof() .And. BX_FILIAL+BX_CONJUN == cChave )
								Aadd(aLinha,SubStr(SBX->BX_CODOP,1,::TamLin()))
								SBX->( DbSkip() )
							EndDo 
						ElseIf SBQ->BQ_TIPDEF == "3"
							For nCntFor := SBQ->BQ_INTDE TO SBQ->BQ_INTATE STEP SBQ->BQ_INTSTEP
								Aadd(aLinha,StrZero(nCntFor, SBQ->BQ_TAMANHO))
							Next nCntFor						
						EndIf						
						
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Definicao das Colunas³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	                    
						DbSelectArea("SBQ")
						SBQ->( DbGoto(__aInfCodRefs[nCnt][4,4]) )
						If SBQ->BQ_TIPDEF == "1"
							DbSelectArea("SBS")
							DbSetOrder(1)
							//-- Carrega interface de grade Coluna
							cChave := xFilial("SBS")+GetCodBase()+cNameCol
							MsSeek(cChave)
							While SBS->( !Eof() .And. BS_FILIAL+BS_BASE+BS_ID == cChave )
								Aadd(aColuna,SubStr(SBS->BS_CODIGO,1,::TamCol()))
								SBS->( DbSkip() )
							EndDo 
						ElseIf SBQ->BQ_TIPDEF == "2"
							DbSelectArea("SBX")
							DbSetOrder(1)
							//-- Carrega interface de grade Coluna def. conjunto
							cChave := xFilial("SBX")+SBQ->BQ_CONJUNT
							MsSeek(cChave)
							While SBX->( !Eof() .And. BX_FILIAL+BX_CONJUN == cChave )
								Aadd(aColuna,SubStr(SBX->BX_CODOP,1,::TamCol()))
								SBX->( DbSkip() )
							EndDo												
						ElseIf SBQ->BQ_TIPDEF == "3"
							For nCntFor := SBQ->BQ_INTDE TO SBQ->BQ_INTATE STEP SBQ->BQ_INTSTEP
								Aadd(aColuna,StrZero(nCntFor, SBQ->BQ_TAMANHO))
							Next nCntFor						
						EndIf
			ENDCASE			
		EndIf         
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se deve ordenar as linhas e colunas da grade                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ				
		If ::lGradeOrdenada .And. MatOrigGrd() <> "SB4" 
			aColuna  := aSort(aColuna)
			aLinha   := aSort(aLinha)
		ElseIf ::lGradeOrdenada .And. MatOrigGrd() == "SB4" 
			aColuna  := aSort(aColuna,,,{|x,y| x[1] < y[1]})
			aLinha   := aSort(aLinha,,,{|x,y| x[1] < y[1]})
		ElseIF !(::lGradeOrdenada) .And. MatOrigGrd() == "SB4" 
			aColuna  := aSort(aColuna,,,{|x,y| x[2] < y[2]})
			aLinha   := aSort(aLinha,,,{|x,y| x[2] < y[2]})
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retorna os arrays aColuna e aLinha para 1 dimensao		                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
		If MatOrigGrd() == "SB4" 
			aEval(aColuna,{|x| aAdd(aTemp,x[1])})
			aColuna := aClone(aTemp)
			aTemp := {}
			aEval(aLinha,{|x| aAdd(aTemp,x[1])})
			aLinha := aClone(aTemp)	
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Guarda codigo das linhas e colunas da grade para ser usado em funcoes   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ				    
		__aInfCodRefs[nCnt][3,3]	:= aClone(aLinha)
		__aInfCodRefs[nCnt][4,3]	:= aClone(aColuna)  

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona no SX3 X3_CAMPO desejado                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cSx3Cpo := StrTran( Self:cCpo,"M->","" )
		If Empty( ESTFwSX3Util():xGetDescription( cSx3Cpo ) )
			Final(STR0003+cCpo+STR0004)			 //"O campo '"###"' nao foi localizado no dicionario de campos SX3"
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica a Coluna da Grade                                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nCntFor := 1 To Len(aColuna)
			Aadd(::aHeadGrade[nCnt],{ AllTrim(::GetDescrGrd(cNameCol,aColuna[nCntFor],.T.,nCnt,"C")),;
				"_"+A550RemoveSinal(aColuna[nCntFor]),;
				X3Picture( cSx3Cpo ),;
				TamSx3( cSx3Cpo )[ 1 ],;
				TamSx3( cSx3Cpo )[ 2 ],;
				'MatVldGGrd() .And. ' + Self:cVldCpoGrd,;
				"û",;
				TamSx3( cSx3Cpo )[ 3 ],;
				CpoRetF3( cSx3Cpo ),;
				" " })
		Next nCntFor
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica as Linhas                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Aadd(::aColsGrade,{})
		For nCntFor := 1 To Len(aLinha)
			//-- Inicializa linha para controle de Recno
			Aadd(::aRecNo[nCnt],{})
			nLinhas++
			For nCntFor2 := 1 To Len(::aHeadGrade[nCnt])
				If ( nCntFor2 == 1 )
					Aadd(::aColsGrade[nCnt],{})
					Aadd(::aColsGrade[nCnt][nLinhas],::GetDescrGrd(cNameLin,aLinha[nCntFor],.T.,nCnt,"L"))
				Else
					Aadd(::aColsGrade[nCnt][nLinhas],aClone(aCposCtrl))
					//-- Inicializa Array do Recno para coluna
					Aadd(::aRecNo[nCnt][nLinhas],0)
				EndIf	
			Next nCntFor2			
		Next nCntFor
	EndIf
EndIf

//-- Restaura ambiente
RestArea(aAreaSB1)
RestArea(aArea)

Return(lRefer)

//-------------------------------------------------------------------
Method Show(aCpos,aCposTot) CLASS MsMatGrade

Local oDlg,oPanel,oGet,oOpc,nOpc,oOpc1,nOpc1
Local oFont    	:= TFont():New('Arial',,-16,.T.,.T.)
Local oFont1	:= TFont():New('Arial',,-16,.T.,.T.)
Local aSize		:= MsAdvSize()
Local aInfo    	:= {aSize[1],aSize[2],aSize[3],aSize[4],3,3}
Local aObjects 	:= {{200,100,.T.,.T.,.F.}}
Local aPosObj  	:= MsObjSize(aInfo,aObjects)
Local nI,nJ,nX,nPos,nColuna,nLinha
Local lPergunte 	:= INCLUI .Or. ALTERA
Local lRet			:= MatGrdPrRf(@::cProdRef)     
Local aAltGr		:= {}     
Local aBSetKeys		:= {}
Local aButtons		:= {}
Local aSavGrade 	:= {}
Local aConteudo		:= {}
Local aPosColQtd 	:= {}
Local aSetSx3		:= {}
Local aAtuCpos      := {}
Local aTotais       := {}
Local aBackRot		:= If(Type("aRotina")=='A',aClone(aRotina),NIL)
Local aHeadTot		:= {}           
Local nPosColQtd 	:= 0
Local nOpcA		  	:= 0
Local nPColReal		:= 0
Local cBusca		:= ""
Local cVar		  	:= ""
Local cNameLin		:= ""
Local cNameCol		:= ""
Local cLine		:= ""
Local cLinha		:= Space(14)
Local cColuna		:= Space(14)
Local cPesquisa 	:= Space(15)
Local lGrdBtTot		:= .T.
Local lGrdViTot		:= .T.
Local nPValDesc 	:= 0
Local nDescGrd  	:= 0
Default aCposTot := {}

If ValType(aCpos) # "A"
	::cCpo := aCpos
	aCpos := {}
	aAdd(aCpos,::cCpo)
EndIf

If Empty(aCpos)
	aEval(::aCposCtrlGrd, {|x| aAdd(aCpos, x[1])} )
EndIf

If (::nCposTela := Len(aCpos)) > 1
	If Upper(::cTudoOk) == "ALLWAYSTRUE"
		::cTudoOk := "MtGrdLinOK()"
	Else
		::cTudoOk += ".And. MtGrdLinOK()"
	EndIf
EndIf

If ( lRet )                                       
	//-- Ponto de entrada que permite inibir o botao de totais da grade
	If ExistBlock("GRDBTTOT")
		lGrdBtTot := ExecBlock("GRDBTTOT",.F.,.F.)
		If ValType(lGrdBtTot) # "L"
			lGrdBtTot := .T.
		End
	EndIf
	
	//-- Ponto de entrada que permite trazer os totais da grade ja exibidos
	If ExistBlock("GRDVITOT")
		lGrdViTot := ExecBlock("GRDVITOT",.F.,.F.)
		If ValType(lGrdViTot) # "L"
			lGrdViTot := .T.
		End
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Salva ambiente                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
	aSavGrade := aClone(::aColsGrade[::nPosLinO])                                 
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona no SX3 X3_CAMPO desejado e atualiza array                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	For nI := 1 To Len( aCpos )
		If Empty( ESTFwSX3Util():xGetDescription( aCpos[ nI ] ) )
			Final( STR0003 + aCpos[ nI ] + STR0004 )			 //"O campo '"###"' nao foi localizado no dicionario de campos SX3"
		EndIf
		Aadd( aAltGr , aCpos[ nI ] )
		Aadd( aSetSX3, Array( 6 ) )
		aSetSx3[nI,1] := ESTFwSX3Util():xGetDescription( aCpos[ nI ] )
		aSetSx3[nI,2] := X3Picture( aCpos[ nI ] )
		aSetSx3[nI,3] := TamSx3( aCpos[ nI ] )[ 1 ]
		aSetSx3[nI,4] := TamSx3( aCpos[ nI ] )[ 2 ]
		aSetSx3[nI,5] := TamSx3( aCpos[ nI ] )[ 3 ]
		aSetSx3[nI,6] := CpoRetF3( aCpos[ nI ] )

		aAdd(aPosColQtd, aScan(::aCposCtrlGrd,{|x| x[1] == aCpos[nI] }))
		aAdd(aConteudo, CriaVar(aCpos[nI]))
	Next nI

	Self:aHeadAux		:= {}
	Self:aColsAux		:= {}
	Self:nQtdInformada	:= IIf( TamSx3( Substr(ReadVar(),4) )[ 3 ] == "N", &( ReadVar() ), 0 ) //So informo se for numerico
	Self:oGetDados		:= NIL
	Self:aSumCpos  		:= {}

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Muda o valor do aRotina para nao incluir linha na GetDados   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE aRotina := {{"","",0,1},{"","",0,1},{"","",0,6}}    
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Definicao das teclas de atalho da tela de grade              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	If ValType(::aSetKey)=='A'      
		For nI:=1 To Len(::aSetKey)  
			Aadd(aBSetKeys,{ SetKey(::aSetKey[nI,1],::aSetKey[nI,2]) })
		Next nI			
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Arrays auxiliares para armazenar a getdados principal³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   	If Type("aHeader")=="A"
		::aHeadAux := aClone(aHeader)
		aHeader := {}
	EndIf
	nPValDesc:=	aScan( Self:aHeadAux,{ |x| AllTrim(x[2]) == "C6_VALDESC" } )
	If Type("aCols")=="A"
		::aColsAux := aClone(aCols)			
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checa a origem dos dados e alimenta as variaveis                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    
	DO CASE
		CASE MatOrigGrd() == "SB4" // A origem eh grade de produtos
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Posiciona  no SB4 alimentar variaveis com nome de linha e coluna        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB4")
			dbSetOrder(1)
			MsSeek(xFilial("SB4")+::cProdRef) 
			cNameLin	:= GetTitTabG(SB4->B4_LINHA)
			cNameCol	:= GetTitTabG(SB4->B4_COLUNA)			      
		CASE MatOrigGrd() == "SBQ" // A origem eh codigo inteligente		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Posiciona  no SBQ alimentar variaveis com nome de linha e coluna        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cNameLin	:= GetTitTabG(,.F.)
			cNameCol	:= GetTitTabG(,.T.)		
	ENDCASE
			
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Monta aHeader e aCols                                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
	If Type("aHeader")=='U'
		Private aHeader := {}
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Monta aHeader do getdados com as novas caracteristicas de aCpos        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAdd(aHeader,{cNameLin+"\"+cNameCol+Space(3),"R","@!",4,0,"","","C","","V"})
	For nJ := 2 To Len(::aHeadGrade[::nPosLinO])
		For nI := 1 To Len(aCpos)
			aAdd(aHeader,Array(11))
			If Len(aCpos) == 1
				aTail(aHeader)[01] := ::aHeadGrade[::nPosLinO,nJ,1]
			Else
				aTail(aHeader)[01] := Substr(::aHeadGrade[::nPosLinO,nJ,1],1,At("]",::aHeadGrade[::nPosLinO,nJ,1])) +" " +RetTitle(aCpos[nI])
			EndIf
			aTail(aHeader)[02] := ::aHeadGrade[::nPosLinO,nJ,2]
			aAdd(aAltGr,aTail(aHeader)[02])
			aTail(aHeader)[03] := aSetSx3[nI,2] 							// PICTURE
			aTail(aHeader)[04] := aSetSx3[nI,3] 							// TAMANHO
			aTail(aHeader)[05] := aSetSx3[nI,4] 							// DECIMAL
			If Len(aCpos) == 1
				aTail(aHeader)[06] := 'MatVldGGrd() .And. '+::cVldCpoGrd 	// VALIDACAO
			Else
				aTail(aHeader)[06] := 'MatGrMFake("MatVldGGrd() .And. '+::cVldCpoGrd+'")' 	// VALIDACAO
			EndIf
			aTail(aHeader)[07] := ::aHeadGrade[::nPosLinO,nJ,7]
			aTail(aHeader)[08] := aSetSx3[nI,5] 							// TIPO
			aTail(aHeader)[09] := aSetSx3[nI,6] 							// F3
			aTail(aHeader)[10] := ::aHeadGrade[::nPosLinO,nJ,10]
			aTail(aHeader)[11] := aCpos[nI]
		Next nI
	Next nJ

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Montagem do ACols                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aCols := {}   
	For nLinha :=  1 To Len( Self:aColsGrade[ Self:nPosLinO ] )
		aadd(aCols,Array(Len(aHeader)+1))
		aCols[nLinha][Len(aHeader)+1] := .F.

		For nI := 1 To Len( aCpos )
			If nLinha == 1 .And. ( TamSx3( aCpos[ nI ] )[ 3 ] == "N" )
				Aadd( Self:aSumCpos,{ aCpos[nI], 0 } )
			EndIf

			For nColuna := 1 To Len(aHeader)
				If nColuna ==  1
					aCols[nLinha][nColuna] := ::aColsGrade[::nPosLinO][nLinha][nColuna]
					if Len( acols[nlinha][nColuna] ) > Len( aHeader[1][1] )
					   aHeader[1][1]:= aHeader[1][1] + Space( len( aCols[nLinha][nColuna] ) - Len( aHeader[1][1] ) )
					EndIf
				ElseIf aCpos[nI] == aHeader[nColuna,11]
					nJ := aScan(::aHeadGrade[::nPosLinO],{|x| ValType(x) # "C" .And. aHeader[nColuna,2] == x[2] })
					aCols[nLinha][nColuna] := ::aColsGrade[::nPosLinO][nLinha][nJ][aScan(::aCposCtrlGrd,{|x| x[1] == aHeader[nColuna,11] })]
					If ( TamSx3( aCpos[ nI ] )[ 3 ] == "N" )
						Self:aSumCpos[nI,2] += aCols[nLinha][nColuna]
					EndIf
				EndIf
			Next nColuna

		Next nI

	Next nLinha
	aHeader[1][1]:= aHeader[1][1] + CHR(13) // ajusta o tamanho da celula para visualizar todo o contexto de descrição.

	N := 1

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada antes da exibicao da janela de grade                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock( "A410GRDW" )
		//Manter Legado para minimizar impacto de customizacoes
		If Type('aHeadGrade')<> 'A' .And. Type('aColsGrade') <> 'A'
			Private aHeadGrade := {}
			Private aColsGrade := {}
		EndIf                       
		
		aHeadGrade := aClone(::aHeadGrade)
		aColsGrade := aClone(::aColsGrade)
		
		ExecBlock( "A410GRDW", .F., .F. , { ::aHeadAux,::aColsAux,::nPosLinO })
		::lShowGrd := (SuperGetMv("MV_SHOWGRD",.F.,"1") == "1")   

		If Type('aHeadGrade')=='A' .And. Type('aColsGrade') == 'A'
			::aHeadGrade := aClone(aHeadGrade)
	  		::aColsGrade := aClone(aColsGrade)
		EndIf                       		
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria variaveis de memoria para validacoes das rotinas dos modulos       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    
	For nI:=1 To Len(aCols)
		For nJ:=2 To Len(aHeader)	
			cVar := 'M->'+aHeader[nJ,2]
			If ValType( cVar ) == 'U'
				PRIVATE &cVar := aCols[nI,nJ]		
			EndIf
		Next nJ
	Next nI
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Mostra tela da grade                                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	If ::lShowGrd                       
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Definicao de Botoes                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AAdd(aButtons,{"PESQUISA"	,{||oPanel:lVisible := !oPanel:lVisible },STR0005,STR0006} )  		    //"Pesquisar..."###"Pesq"
		If lGrdBtTot
			AAdd(aButtons,{"FORM"	,{||oPanel3:lVisible := !oPanel3:lVisible },STR0039,STR0040} )	//"Totais da Grade"###"Totais"
		EndIf
		//-- Verifica se eh inclusao ou alteracao
		If lPergunte .And. ::lShowButtonRepl
			AAdd(aButtons,{"SDUCOPYTO"	,{|| (::ReplicaItens(,aCpos)),(oTotais:Refresh())},STR0036,STR0037} )  //"Replicar dados" ### "Replicar"
		EndIf
		//-- Verifica se deve ou nao mostrar a curva de caracteristicas
		If aScan(::aCposCtrlGrd,{|x| x[2] # NIL .And. x[2] }) > 0
			AAdd(aButtons,{"CTBREPLA"	,{||If(	MatGrMFake("A552Show('"+::cProdRef+"','"+::GetDescProd(::cProdRef)+"',.T.)",.T.),;
											::oGetDados:oBrowse:Refresh(),NIL)},STR0007,STR0008} ) //"Curva de Caracteristicas"###"Curva"
		EndIf               
		If nPValDesc > 0 .And. !Empty(oGrade:aColsAux[oGrade:nPosLinO,nPValDesc]) .And. "MATA410" $ SuperGetMV("MV_GRDMULT",.F.,"")
			nDescGrd:= oGrade:aColsAux[oGrade:nPosLinO,nPValDesc] 
			oGrade:aColsAux[oGrade:nPosLinO,nPValDesc]:= 0
		EndIf
		
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Montagem da tela.                                                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DEFINE MSDIALOG oDlg TITLE cCadastro +" - " +If(Len(aCpos)==1,aSetSx3[1,1],"Grade") Pixel From 0,0 To aSize[6]-160,aSize[5]-265 OF oMainWnd

		//Pesquisar ---------------------------------------------------------------------------------
		oPanel 			 := TPanel():New(00,00,"",oDlg,NIL,.T.,.F.,NIL,NIL,100,1,.T.,.F. ) 
		oPanel:Align 	 := CONTROL_ALIGN_LEFT
		oPanel:lVisible := .F. 

		TSay():New( 001, 002, {||STR0009},oPanel, ,TFont():New('Arial',, -12, .T., .T.), , , ,.T., , , 40, 12) //"Pesquisar:"

		TSay():New( 010, 002, {||STR0010},oPanel, , , , , ,.T., , , 80, 12) //"Informar a Linha:"
		@ 017,002 GET oGet  VAR cLinha  SIZE 95, 9 OF oPanel PIXEL		

		TSay():New( 030, 002, {||STR0011},oPanel, , , , , ,.T., , , 80, 12) //"Informar a Coluna:"
		@ 037,002 GET oGet  VAR cColuna  SIZE 95, 9 OF oPanel PIXEL		
				
		TSay():New( 050, 002, {||STR0012},oPanel, , , , , ,.T., , , 80, 12) //"Conteúdo:"
		@ 057,002 GET oGet  VAR cPesquisa  SIZE 95, 9 OF oPanel PIXEL		

		TButton():New(070,002, STR0013	, oPanel, {|| PesqInGrade(cLinha,cColuna,nOpc,cPesquisa,nOpc1,@::oGetDados) }, 40, 13, , , .F., .T., , , .T.) 	//"&Procurar"
		TButton():New(070,045, STR0014	, oPanel, {|| (cLinha:=Space(14),cColuna:=Space(14),oGet:Refresh()) }, 40, 13, , , .F., .T., , , .T.) 			//"&Limpar"

		@ 095,002 TO 120,095 LABEL OemToAnsi(STR0015) PIXEL OF oPanel	 				//"Tipo de Pesquisa:"
		@ 100,005 RADIO oOpc VAR nOpc ITEMS STR0016,STR0017 SIZE 70,10 PIXEL OF oPanel	//"Por Caracteristica"###"Por Descricao"


		@ 125,002 TO 175,095 LABEL OemToAnsi(STR0018) PIXEL OF oPanel				//"Objetivo da Pesquisa:"
		@ 130,005 RADIO oOpc1 VAR nOpc1 ITEMS 	STR0019, ; 							//"Posicionar Linha/Coluna"
												STR0020, ; 							//"Localizar Conteúdo em Tudo"
												STR0021,; 							//"Localizar Conteúdo em Linha"
												STR0022 SIZE 85,10 PIXEL OF oPanel 	//"Localizar Conteúdo em Coluna"

		//Fim Pesquisar -----------------------------------------------------------------------------
	
		//Painel da grade e totais --------------------------------------------------------------
		oPanel1 := TPanel():New( ,,,oDlg,,,,,,,035,,)   
		oPanel1:Align := CONTROL_ALIGN_ALLCLIENT
		//Fim Painel da grade e totais ----------------------------------------------------------
			
		//Grade ---------------------------------------------------------------------------------
		oPanel2 := TPanel():New(1,1,,oPanel1,,,,,,0,aPosObj[1,4]-415,,)   
		oPanel2:Align := CONTROL_ALIGN_ALLCLIENT
	
		::oGetDados := MSGetDados():New(1,1,10,10,3,,::cTudoOk,,.F.,aAltGr,1,,,If(aSetSx3[1,5]=="N","oTotais:Refresh()==NIL",NIL),,,,oPanel2,.T.)
		::oGetDados:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
		::oGetDados:lF3Header:=.T.                              
		//Fim Grade ---------------------------------------------------------------------------------
		
		//Totais da Grade ---------------------------------------------------------------------------------
		oPanel3 := TPanel():New(3,1,"",oPanel1,,,,,,0,60,,)  //Totais da grade
		oPanel3:Align := CONTROL_ALIGN_BOTTOM	
		oPanel3:lVisible := lGrdViTot
	   	
		//--Prepara array com campos do totalizador
		aTotais := aClone(aCpos)
		If !Empty(aCposTot)
			aEval(aCposTot,{|x| aAdd(aTotais,x)})
		EndIf
		
		aEval(aTotais,{|x| aAdd(aHeadTot,RetTitle(x))})
	   
		@02,01 SAY STR0039 SIZE 100,30 FONT oFont1 OF oPanel3 PIXEL // Totais da Grade
		oTotais := TWBrowse():New(1,1,0,40,,aHeadTot,,oPanel3,,,,,,,,,,,,,,.T.)
	
		cLine := "{|| {"
		For nI := 1 To Len(aTotais)
			If nI > 1
				cLine +=","
			EndIf
			cLine += "GrdSumTela(aTotais[" +StrZero(nI,2) +"]," +StrZero(nI,2)+")"
		Next nI
		cLine += "}}"
				
		oTotais:SetArray({1})
		oTotais:bLine := &(cLine)
		oTotais:Align := CONTROL_ALIGN_BOTTOM
		//Fim Totais da Grade ---------------------------------------------------------------------------------
		
		ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar(oDlg,{|| If(::oGetDados:TudoOk(),( nOpcA := If(lPergunte,1,0),oDlg:End() ),nOpca:=0)},{||oDlg:End()},,aButtons)
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Restauracao das teclas de atalho da tela de grade            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	If !Empty(aBSetKeys)      
		For nI:=1 To Len(aBSetKeys)  
			SetKey(::aSetKey[nI,1],aBSetKeys[nI,1])
		Next nI			
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Efetua a Atualizacao no aColsGrade  Corrente                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nOpcA == 1 )
		For nX := 1 to Len(aCpos)
			nPosColQtd := aScan(::aCposCtrlGrd, {|x| x[1] == aCpos[nX]} )
			For nColuna := 2 To Len(aHeader)
				For nLinha :=  1 To Len(::aColsGrade[::nPosLinO])
					If aCpos[nX] == aHeader[nColuna,11]
						nPColReal := aScan(::aHeadGrade[::nPosLinO], {|x| ValType(x) # "C" .And. x[2] == aHeader[nColuna,2]})
						::aColsGrade[::nPosLinO][nLinha][nPColReal][nPosColQtd ] := aCols[nLinha][nColuna]
						If !Empty(aCols[nLinha][nColuna])
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Definicao do sub-array de controle da grade para os campos guardados    ³
							//³Onde:                                                                   ³
							//³aCposCtrlGrd[x,1y]:Nome do campo que sera armazenado as quantidades     ³	
							//³                   informadas na grade.                                 ³ 
							//³aCposCtrlGrd[x,2y]:Logico que permite ou nao chamar a curva de caract.  ³							
							//³aCposCtrlGrd[x,3y]:Array de campos/funcoes para alimentar de forma      ³	
							//³                   generica os campos vinculado ao campo informado.     ³
							//³		aCposCtrlGrd[3y,1]:Campo a ser atualizado.                         ³	
							//³		aCposCtrlGrd[3y,2]:Bloco de codigo para atualizar o campo  		   ³	
							//³aCposCtrlGrd[x,4y]:Array de campos/funcoes para alimentar de forma      ³	
							//³                   generica os campos vinculado ao campo informado na   |
							//³                   interface multicampo.								   | 
							//³aCposCtrlGrd[x,5y]:Define se o campo e obrigatorio para validar na multi| 
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ					
							If ::aCposCtrlGrd[nPosColQtd,3]# NIL
								For nI:=1 To Len(::aCposCtrlGrd[nPosColQtd,3])
									//Guarda o campo a ser usado na pesquisa
									cCpoAux := ::aCposCtrlGrd[nPosColQtd,3][nI,1]
									
									//Verifica se o campo pode ser atualizado
									If Empty(cCpoAux) .Or. Empty(::aCposCtrlGrd[nPosColQtd,3][nI,2])
										Loop
									EndIf
									
									//Verifica se o campo informado esta na lista de contrucao do sub-array
									If (nPos := aScan(::aCposCtrlGrd,{|x| x[1]==cCpoAux })) > 0 .And. aScan(aCpos,{|x| x == cCpoAux}) == 0
										aAdd(aAtuCpos,{nLinha,nColuna,nPColReal,nPos,nPosColQtd,nI})
									EndIf							
								Next nI					
							EndIf		                      
						EndIf
					EndIf
				Next nLinha
			Next nColuna
				
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualizacao da quantidade da grade                                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( TamSx3( aCpos[ nX ] )[ 3 ] == "N" )
				If Substr(ReadVar(),4) == aCpos[nX]
					::lShowMsgDiff := .T.
					::nQtdInformada := Self:SomaGrade(aCpos[nX],::nPosLinO,::nQtdInformada)
				ElseIf (nJ := aScan(::aHeadAux,{|x| AllTrim(x[2]) == aCpos[nX]})) > 0
					::lShowMsgDiff := .F.
					::aColsAux[::nPosLinO,nJ] := Self:SomaGrade(aCpos[nX],::nPosLinO,::aColsAux[::nPosLinO,nJ])
				EndIf
			EndIf
		Next nX

		::lShowMsgDiff := .F.
		For nX := 1 To Len(aCposTot)
			If (nJ := aScan(::aHeadAux,{|x| AllTrim(x[2]) == aCposTot[nX]})) > 0
				::aColsAux[::nPosLinO,nJ] := Self:SomaGrade(aCposTot[nX],::nPosLinO,::aColsAux[::nPosLinO,nJ])
			EndIf
		Next nX		
		::lShowMsgDiff := .T.		

		//-- Atualiza campo no aColsGrade
		For nI := 1 To Len(aAtuCpos)
			nLinha  := aAtuCpos[nI,1]
			nColuna := aAtuCpos[nI,3]
			::aColsGrade[::nPosLinO][nLinha][nColuna][aAtuCpos[nI,4]] := Eval(::aCposCtrlGrd[aAtuCpos[nI,5],3][aAtuCpos[nI,6],2])
		Next nI
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de Entrada para manipulacao dos dados digitados na grade          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock( "MTPOSGRD" )
			ExecBlock( "MTPOSGRD",.F.,.F.)		
		Endif		
	Else
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso Cancelado e utilizando multgrade, retorna o valor de desconto³
		//³que foi zerado antes da criação da dialog                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If IsInCallStack("MATA410") .And. "MATA410" $ SuperGetMV("MV_GRDMULT",.F.,"")
			oGrade:aColsAux[oGrade:nPosLinO,nPValDesc]:= nDescGrd
		EndIf	
		::aColsGrade[::nPosLinO] := aClone(aSavGrade)
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura ambiente                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If aBackRot <> Nil
		aRotina := aClone(aBackRot)
	EndIf
	
	If !Empty(::aHeadAux)
		aHeader := aClone(::aHeadAux) 
	EndIf       
	
	If !Empty(::aColsAux)
		aCols	:= aClone(::aColsAux)	
	EndIf

	N 			:= ::nPosLinO
    ::oGetDados := NIL                               
EndIf
::lOk := ( nOpcA == 1 )
Return ( lRet )
                                                                     


//-------------------------------------------------------------------
Method SetRecNo(nACols,nLin,nCol,nRecno) CLASS MsMatGrade

::aRecNo[nACols,nLin,--nCol] := nRecno

Return 
                   


//-------------------------------------------------------------------
Method GetRecNo(nACols,nLin,nCol) CLASS MsMatGrade
Local nRecNo := 0

nCol--

If ValType(::aRecNo[nACols,nLin,nCol]) == 'N'
	nRecNo := ::aRecNo[nACols,nLin,nCol]
EndIf

Return nRecNo



//-------------------------------------------------------------------
Method SomaGrade(cCpo,nLinAcols,nQtdInf) CLASS MsMatGrade

Local nColunas	:= 0
Local nLinhas	:= 0
Local nSoma		:= 0               
Local nColQtd	:= 0

DEFAULT cCpo	:= ::cCpo                   
DEFAULT nQtdInf := ::nQtdInformada

nColQtd := AsCan(::aCposCtrlGrd,{|x| x[1]==cCpo })
If !Empty(nColQtd)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Soma a Quantidade digitada na grade                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nColunas:=2 to Len(::aHeadGrade[nLinAcols])
		For nLinhas:=1 to Len(::aColsGrade[nLinAcols])
			nSoma+=::aColsGrade[nLinAcols][nLinhas][nColunas][nColQtd]
		Next nLinhas
	Next nColunas
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se ha divergencias                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ::lShowMsgDiff .And. ( nSoma <> nQtdInf .And. nQtdInf <> 0 )
	Help(" ",1,"A410QTDDIF")
EndIf

Return(::nQtdGrade := nSoma)

//--------------------------------------------------------                
Method GetFieldMC(cCpo,nLinha,nColuna) CLASS MsMatGrade
Local cVar	:= ""
LOcal xRet	:= NIL

Default nLinha := n

If IsInCallStack("A552Show")
	xRet := ::aColsFieldByName(cCpo,,nLinha,nColReplic,,.T.)
Else
	If Empty(nColuna)
		nColuna := If(Type("nColReplic") == "N",nColReplic,::oGetDados:oBrowse:nColPos)
		cVar := aHeader[nColuna,2]
		If Len(aHeader[nColuna]) == 11
			nColuna := aScan(aHeader,{|x| x[2] == cVar .And. x[11] == cCpo})
		EndIf
	EndIf
	
	If nColuna > 0
		If nColuna == If(Type("nColReplic") == "N",nColReplic,::oGetDados:oBrowse:nColPos) .And. nLinha == n
			xRet := &(ReadVar())
		Else
			xRet := aCols[nLinha,nColuna]
		EndIf
	EndIf
EndIf

Return xRet                

//-------------------------------------------------------------------
Method aColsFieldByName(cCpo,nLinAcols,nLinha,nColGr,lPesqTela) CLASS MsMatGrade
Local nPosCpo	:= 0     
Local cVar		:= ""
Local nMultC	:= 0
Local xRet		:= NIL

DEFAULT cCpo		:= StrTran(::cCpo,"M->","")      
DEFAULT nLinAcols	:= ::nPosLinO
DEFAULT lPesqTela   := .F.

nPosCpo	:= Self:GetFieldGrdPos(cCpo)
If Empty(nPosCpo)
	Final(STR0003+cCpo+STR0023) //"O campo '"###"' nao foi informado no metodo da grade."
EndIf

If Len(::aColsGrade[nLinAcols]) >= nLinha .And. Len(::aColsGrade[nLinAcols,nLinha]) >= nColGr
	xRet := ::aColsGrade[nLinAcols,nLinha,nColGr][nPosCpo]
EndIf

If !Empty(::aBkpMult[1]) .And. !Empty(::aBkpMult[2])//-- Caso multicampo e nao chamada pela fake
	If IsInCallStack("A552Show")
		cVar := ::aBkpMult[1][((nColGr - 1) * ::nCposTela), 2]
		nPosCpo := aScan(::aBkpMult[1],{|x| x[2] == cVar .And. x[10] == cCpo})
		If nPosCpo > 0
			xRet := ::aBkpMult[2,nLinha,nPosCpo]
		EndIf
	Else
		If IsInCallStack("MatGrMFake") .And. ::cCpo == cCpo
			cVar := aHeader[nColGr,2]
			nPosCpo := aScan(If(lPesqTela,aHeader,::aBkpMult[1]),{|x| x[2] == cVar}) 
		Else
			cVar := aHeader[((nColGr - 1) * ::nCposTela) + 1,2]
			nPosCpo := aScan(If(lPesqTela,aHeader,::aBkpMult[1]),{|x| x[2] == cVar .And. x[11] == cCpo})
		EndIf
		If nPosCpo > 0
			xRet := If(lPesqTela,aCols[nLinha,nPosCpo],::aBkpMult[2,nLinha,nPosCpo])
		EndIf
	EndIf
EndIf

Return(xRet)


//-------------------------------------------------------------------
//Retorna o nome chave da grada da coluna (CABECALHO)
Method GetNameColuna(nColuna) CLASS MsMatGrade  
Local nCol := --nColuna
Local cRet := ""
If Len(__aInfCodRefs[::nPosLinO][4,3]) >= nCol
	cRet := __aInfCodRefs[::nPosLinO][4,3][nCol]
EndIf
Return ( cRet )
                                                                     

//-------------------------------------------------------------------
//Retorna o nome chave da grada da Linha 
Method GetNameLinha(nLinha) CLASS MsMatGrade   
Local cRet := ""
If Len(__aInfCodRefs[::nPosLinO][3,3]) >= nLinha
	cRet := __aInfCodRefs[::nPosLinO][3,3][nLinha]
EndIf
Return ( cRet )
 

//-------------------------------------------------------------------
//Retorna o codigo do produto de grade
Method GetNameProd(cProdRef,nLinha,nColuna) CLASS MsMatGrade 
DEFAULT cProdRef := ::cProdRef
IF MatOrigGrd() == "SB4"
	cProdRef := PadR(cProdRef,__nTamRefSB4)
EndIf
Return PadR(cProdRef+Self:GetNameLinha(nLinha)+Self:GetNameColuna(nColuna),TamSX3("B1_COD")[1])

//-------------------------------------------------------------------
//Retorna a descricao do produto de grade
Method GetDescProd(cProdRef) CLASS MsMatGrade
DEFAULT cProdRef := ::cProdRef 
Return ( MaGetDescGrd(cProdRef) )

//-------------------------------------------------------------------
//Retorna o tamanho do codigo da coluna da grade do produto selecionado 
Method TamCol(nAColsPos) CLASS MsMatGrade 
DEFAULT nAColsPos := ::nPosLinO
Return ( __aInfCodRefs[nAColsPos][4,2] )

//-------------------------------------------------------------------
//Retorna o tamanho do codigo da linha da grade    
Method TamLin(nAColsPos) CLASS MsMatGrade   
DEFAULT nAColsPos := ::nPosLinO
Return ( __aInfCodRefs[nAColsPos][3,2]  )

//-------------------------------------------------------------------
//Retorna o tamanho do codigo referencia da grade
Method TamRef(nAColsPos) CLASS MsMatGrade   
DEFAULT nAColsPos := ::nPosLinO
Return (  __aInfCodRefs[nAColsPos][2] )


//-------------------------------------------------------------------
//Retorna a posicao de um campo no array de campos
Method GetFieldGrdPos(cCpo) CLASS MsMatGrade 
Return AsCan(::aCposCtrlGrd,{|x| x[1]==cCpo })


//-------------------------------------------------------------------
//Checa se esta vazio a informacao do campo
Method EmptyGrd(cCpo) CLASS MsMatGrade 
Local lRet := .T.
Local nLinha,nColuna 
If !Empty(cCpo) .And. !Empty(::aColsGrade)
	For nLinha := 1 To Len(::aColsGrade[::nPosLinO])
		For nColuna := 2 To Len(oGrade:aHeadGrade[::nPosLinO])
			If !Empty(oGrade:aColsFieldByName(cCpo,::nPosLinO,nLinha,nColuna))
				lRet := .F.
				Exit	
			EndIf
		Next nColuna
	Next nLinha
EndIf
Return ( lRet )



//-------------------------------------------------------------------
//Retorna a posicao do codigo da linha de grade na possicao informada do aCols
Method RetPosLin(nACols,cCpo) CLASS MsMatGrade 
DEFAULT nACols := ::nPosLinO
Return ( AsCan(__aInfCodRefs[nACols,3,3],{|x| AllTrim(x) == cCpo}) )
                                                 

//-------------------------------------------------------------------
//Retorna a posicao do codigo da coluna de grade na possicao informada do aCols
Method RetPosCol(nACols,cCpo) CLASS MsMatGrade 
DEFAULT nACols := ::nPosLinO
Return ( AsCan(__aInfCodRefs[nACols,4,3],{|x| AllTrim(x) == cCpo}) )

//-------------------------------------------------------------------
//Retorna a posicao do codigo da coluna de grade na possicao informada do aCols
Method GetTitGrd(cCodTabela,lColuna) CLASS MsMatGrade 
Return GetTitTabG(cCodTabela,lColuna)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³GetDescrGr³ Autor ³Erike Yuri da Silva    ³ Data ³18.07.06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Retorna a descricao da grade conforme seu tipo              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo da tabela da grade                            ³±±  
±±³          ³ExpC2: Chave do item da grade                               ³±±
±±³          ³ExpL1: Indica se deve monstra                               ³±±
±±³          ³ExpN1: Indica a linha do array de controle                  ³±±
±±³          ³ExpC3: Tipo da grade : L (linha) ou C (coluna)              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpC1: Descricao do Item da grade                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico grade                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Method GetDescrGrd(cCodTabela,cCodChave,lMostraChave,nPosArray,cTpGrade) CLASS MsMatGrade
Local aArea		:= GetArea() 
Local nRecSBQ	:= 0
Local cRet		:= "["+cCodChave+"] "     
DEFAULT lMostraChave 	:= .F.

DO CASE
	CASE MatOrigGrd() == "SB4"
		DbSelectArea("SBV")
		DbSetOrder(1)
		If DbSeek(xFilial("SBV")+cCodTabela+cCodChave)
			If !lMostraChave
				cRet := AllTrim(SBV->BV_DESCRI)+Space(3)
			Else
				cRet += AllTrim(SBV->BV_DESCRI)+Space(3)
			EndIf
		EndIf 
	CASE MatOrigGrd() == "SBQ"                  
		If nPosArray == NIL
			DbSelectArea("SBQ")
			DbSetOrder(2)
			If MsSeek(xFilial("SBQ")+GetCodBase()+cCodTabela)
				nRecSBQ := SBQ->( RecNo() )	
			EndIf    
		Else           
			If cTpGrade == "L"
				nRecSBQ := __aInfCodRefs[nPosArray,3,4]
			Else
				nRecSBQ := __aInfCodRefs[nPosArray,4,4]
			EndIf
		EndIf        
		      
		If !Empty(nRecSBQ)    
			DbSelectArea("SBQ")
			DbGoto(nRecSBQ)
			If SBQ->BQ_TIPDEF == "1"
				DbSelectArea("SBS")
				DbSetOrder(1)   
				If SBS->( DbSeek(xFilial("SBS")+SBQ->BQ_BASE+cCodTabela+cCodChave) )
					If !lMostraChave
						cRet := AllTrim(SBS->BS_DESCR)+Space(3)
					Else
						cRet += AllTrim(SBS->BS_DESCR)+Space(3)
					EndIf
				EndIf 	
			ElseIf SBQ->BQ_TIPDEF == "2" 
				DbSelectArea("SBX")
				DbSetOrder(1)
			    If SBX->( MsSeek(xFilial("SBX")+SBQ->BQ_CONJUNT+cCodChave) )
					If !lMostraChave
						cRet := AllTrim(SBX->BX_DESCPR)+Space(3)
					Else
						cRet += AllTrim(SBX->BX_DESCPR)+Space(3)
					EndIf			    
			    EndIf
			ElseIf SBQ->BQ_TIPDEF == "3"           
				cCodChave := ' '+cCodChave
				If !lMostraChave
					cRet := AllTrim(SBQ->BQ_DESCR)+cCodChave+Space(3)
				Else
					cRet += AllTrim(SBQ->BQ_DESCR)+cCodChave+Space(3)
				EndIf					
			EndIf       
		EndIf
ENDCASE
RestArea(aArea)
Return cRet       



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A552Repli ºAutor  ³Patricia D.Aguiar   º Data ³  24/04/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Função para Replicar os dados na acolsgrade. (preenchimentoº±±
±±º          ³ automático)                                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpC1- Nome do campo para tratamento                       º±±
±±º          | ExpN1- Valor a ser replicado sem exibir a tela			  º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³27/04/07  ³Erike Yuri     ³Compatibilizacao para uso das caracteristi- ³±±
±±³          ³               ³cas de objeto, a funcao foi convertida para ³±±
±±³          ³               ³Metodo e as variaveis foram compatibilizadas³±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Method ReplicaItens(cCampo,aCpos) CLASS MsMatGrade

Local aObj			:= {}
Local xConteudo	:= NIL
Local xContAnt		:= NIL
Local cReadBkp		:= __READVAR  
Local nPosCCpo		:= 0
Local nPosMain		:= aScan(::aCposCtrlGrd,{|x| x[1]==::cMainCpo }) 
Local nCpo			:= 0
Local nI			:= 0
Local nLinha		:= 10
Local nColuna		:= 0
Local nColReal		:= 0
Local nColBkp		:= 0
Local nOldN		:= If(Type('N')=='N',N,1)
Local lOk			:= .F. 
Local lRet			:= .T.
Local bPreenche	:= NIL

Private lMsHelpAuto := .T.
Private nColReplic  := 0

DEFAULT cCampo := StrTran(::cCpo,"M->","")
DEFAULT aCpos  := {cCampo}

DEFINE MSDIALOG oDlg TITLE STR0033 FROM 178, 181 TO 240 + ( 30 * Len(aCpos) ), 445 PIXEL 

For nCpo := 1 To Len(aCpos)
	aAdd(aObj,{NIL,NIL, CriaVar( aCpos[ nCpo ] ), X3Picture( aCpos[ nCpo ] ), RetTitle( aCpos[ nCpo ] ) } )

	&("GET_"+StrZero(nCpo,2)) := aTail(aObj)[3]
	&("CHECK_"+StrZero(nCpo,2)) := .T.
	@nLinha+2, 10 Say aTail(aObj)[1] Prompt "" Size 80,10 Pixel Of oDlg
	aTail(aObj)[2] := TGet():New(nLinha,50,&("{|u| If(PCount()==0,GET_"+StrZero(nCpo,2)+",GET_"+StrZero(nCpo,2)+" := u)}"),;
		oDlg,66,10,aTail(aObj)[4],,,,,.F.,,.T.,,.F.,,.F.,.F.,,.F., .F.,,"G_"+StrZero(nCpo,2))
	If Len(aCpos) > 1
		TCheckBox():Create(oDlg,&("{|u| If(PCount()==0,CHECK_" +StrZero(nCpo,2)+",CHECK_" +StrZero(nCpo,2) +":=u)}"),nLinha+2,120,"",50,10,,,,,,,,.T.,STR0047)
	EndIf
	nLinha += 15
Next nCpo

aEval(aObj,{|x| x[1]:SetText(x[5])})

@ nLinha + 5, 40 Button STR0034 Size 037,012 Pixel Of oDlg Action (lOK :=.T.,oDlg:End())
@ nLinha + 5, 80 Button STR0035 Size 037,012 Pixel Of oDlg Action oDlg:End() 
	
ACTIVATE MSDIALOG oDlg CENTERED

If ( lOk )
	If Len(aCpos) == 1
		//						eh o campo principal 				campo principal preenchido
		bPreenche := {|| ::cMainCpo == ::cCpo .Or. !Empty(::aColsGrade[::nPosLinO][nLinha][nColReal][nPosMain])}
	Else
		//							campo posicionado 								eh o campo principal 				campo principal preenchido
		bPreenche := {|| aCpos[nCpo] == aHeader[nColuna,11] .And. (::cMainCpo == aCpos[nCpo] .Or. !Empty(aCols[nLinha,nColBkp]) .Or. Empty(xConteudo)) }
	EndIf
	For nCpo := 1 To Len(aCpos)
		If !&("CHECK_"+StrZero(nCpo,2))
			Loop
		EndIf
		
		nPoscCpo  := aScan(::aCposCtrlGrd,{|x| x[1] == aCpos[nCpo]})  
		xConteudo := &("GET_"+StrZero(nCpo,2))
		
		For nLinha :=  1 To Len(::aColsGrade[::nPosLinO])
			n := nLinha
			For nColuna := 2 To Len(aHeader) 
				//-- Preenche variaveis de controle
				If Len(aCpos) > 1
					nColBkp := aScan(aHeader,{|x| x[2] == Upper(AllTrim(aHeader[nColuna,2])) .And. x[11] == ::cMainCpo})
				EndIf
				nColReal := aScan(::aHeadGrade[::nPosLinO],{|x| ValType(x) # "C" .And. aHeader[nColuna,2] == x[2] })
				
				If Eval(bPreenche)
				  	xContAnt := aCols[nLinha][nColuna]
					
					__READVAR	:= "M->"+Upper(AllTrim(aHeader[nColuna,2]))
					&__READVAR	:= xConteudo
					
					nColReplic := nColuna
									
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Verifica se tem validacao do campo, se tiver executa validacao e se nao ³
					//³for valido zera campo.                                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !( Empty(aHeader[nColuna,6]) .Or. &(aHeader[nColuna,6]) )
						&__READVAR	:= xContAnt
						aCols[nLinha,nColuna] := xContAnt
					Else
						aCols[nLinha][nColuna] := &__READVAR
						If ( TamSx3( aCpos[ nCpo ] )[ 3 ] == "N" )
							Self:aSumCpos[nCpo,2] += &__READVAR - xContAnt
						EndIf
					EndIf
				EndIf
	
				If aCpos[nCpo] == aHeader[nColuna,11] .And. (!Empty(aCols[nLinha,nColuna]) .Or. Empty(xConteudo))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Definicao do sub-array de controle da grade para os campos guardados    ³
					//³Onde:                                                                   ³
					//³aCposCtrlGrd[x,1y]:Nome do campo que sera armazenado as quantidades     ³	
					//³                   informadas na grade.                                 ³ 
					//³aCposCtrlGrd[x,2y]:Logico que permite ou nao chamar a curva de caract.  ³							
					//³aCposCtrlGrd[x,3y]:Array de campos/funcoes para alimentar de forma      ³	
					//³                   generica os campos vinculado ao campo informado.     ³
					//³		aCposCtrlGrd[3y,1]:Campo a ser atualizado.                         ³	
					//³		aCposCtrlGrd[3y,2]:Bloco de codigo para atualizar o campo  		   ³	
					//³aCposCtrlGrd[x,4y]:Array de campos/funcoes para alimentar de forma      ³	
					//³                   generica os campos vinculado ao campo informado na   |
					//³                   interface multicampo.								   | 
					//³aCposCtrlGrd[x,5y]:Define se o campo e obrigatorio para validar na multi| 
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ					
					nColBkp := nColuna
					nColuna := nColReal
					If ::aCposCtrlGrd[nPoscCpo,3]# NIL
						For nI:=1 To Len(::aCposCtrlGrd[nPoscCpo,3])
							//Guarda o campo a ser usado na pesquisa
							cCpoAux := ::aCposCtrlGrd[nPoscCpo,3][nI,1]
							
							//Verifica se o campo pode ser atualizado
							If Empty(cCpoAux) .Or. Empty(::aCposCtrlGrd[nPoscCpo,3][nI,2])
								Loop
							EndIf
							
							//Verifica se o campo informado esta na lista de contrucao do sub-array
							If (nPos := AsCan(::aCposCtrlGrd,{|x| x[1]==cCpoAux })) > 0
								::aColsGrade[::nPosLinO][nLinha][nColReal][nPos] := Eval(::aCposCtrlGrd[nPoscCpo,3][nI,2])
							EndIf
						Next nI
					EndIf
					nColuna := nColBkp
				EndIf
			Next nColuna
		Next nLinha		
	Next nCpo
EndIf

//-- Restaura ambiente
N := nOldN
__READVAR := cReadBkp 

::oGetDados:oBrowse:Refresh()
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ZeraGrade ºAutor  ³Andre Anjos         º Data ³  13/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Metodo que zera toda uma grade para determinado campo      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cCampo: Campo que tera sua grade zerada					  º±±
±±º		     ³ nLisPos: Linha de referencia								  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Method ZeraGrade(cCampo,nLinPos)  CLASS MsMatGrade
Local nLinha  := 0
Local nColuna := 0
Local nCampo  := ::GetFieldGrdPos(cCampo)

Default nLinPos := ::nPosLinO

For nLinha := 1 To Len(::aColsGrade[nLinPos])
		For nColuna := 2 To Len(::aHeadGrade[nLinPos])
		::aColsGrade[nLinPos,nLinha,nColuna,nCampo] := CriaVar(cCampo)
	Next nColuna
Next nLinha

Return

//////////////////////////////////////////////
//Funcoes                           

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaGetDescG³ Autor ³Erike Yuri da Silva    ³ Data ³06.04.07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Retorna a descricao do produto referencia de grade          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto Referencia de Grade                ³±±
±±³          ³ExpL1: Pesquisa o produto a partir Tamanho de referencia    ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Caractere                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/      
Function MaGetDescGrd(cProdRef)      
Local aArea := GetArea()
Local cDescProd := "" 
Local cBase,cCodBS 
Local nTam 
Local lContinua	:= .T.      
Local aAreaSB1	:= SB1->(GetArea())

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa a origem dos dados e alimenta as variaveis                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    
DO CASE
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³A origem eh grade de produtos³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
	CASE MatOrigGrd() == "SB4"
		dbSelectArea("SB4")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SB4")+cProdRef) )
			cDescProd := SB4->B4_DESC
		EndIf 
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³A origem eh codigo inteligente³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			
	CASE MatOrigGrd() == "SBQ"
		cBase	:= GetCodBase(cProdRef) 
		nTam	:= Len(AllTrim(cBase))+1  
		dbSelectArea("SBP")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SBP")+cBase)  ) 
			dbSelectArea("SBQ")
			dbSetOrder(1)
			MsSeek(xFilial("SBQ")+cBase)  
			While lContinua .And. SBQ->(!Eof() .And. BQ_FILIAL+BQ_BASE==xFilial("SBQ")+cBase .And. !BQ_TPGRD$"12")
				If SBP->BP_CODPAD == "2"	
					cCodBS  := Substr(cProdRef, SBQ->BQ_INICIO, SBQ->BQ_TAMANHO)
				Else
					cCodBS  := SubStr(cProdRef, nTam, SBQ->BQ_TAMANHO)
					nTam 	+= SBQ->BQ_TAMANHO
				EndIf
				If SBQ->BQ_TIPDEF == "1"                
					If (! SBS->(dbSeek(xFilial("SBS") + SBQ->(BQ_BASE + BQ_ID) + cCodBS))) .Or. SBS->BS_ATIVO == "0"
						cCodBS := Space(SBQ->BQ_TAMANHO)
						lContinua := .F.
					Else
						cDescProd += AllTrim(SBS->BS_DESCPRD)+" "
					EndIf   
				ElseIf SBQ->BQ_TIPDEF == "2"
					If (! SBX->(dbSeek(xFilial("SBX") + SBQ->BQ_CONJUNT + cCodBS))) .Or. SBX->BX_ATIVO == "0"
						cCodBS := Space(SBQ->BQ_TAMANHO)
						lContinua := .F.
					Else
						cDescProd += AllTrim(SBX->BX_DESCPR)+" "
					EndIf
				ElseIf SBQ->BQ_TIPDEF == "3"
					cDescProd += Padl(AllTrim(cCodBS), SBQ->BQ_TAMANHO, "0")+" "
				Endif
		
				SBQ->( DbSkip() )
			EndDo    
			DbSelectArea("SBR")
			DbSetOrder(1)
			If MsSeek(xFilial("SBR")+cBase)
				cDescProd := AllTrim(SBR->BR_DESCPRD)+ " "+cDescProd
			EndIf        
			cDescProd := StrTran(cDescProd,Space(2),Space(1))
	    EndIf
ENDCASE

//-- Restaura area do SB1
SB1->(RestArea(aAreaSB1))
RestArea(aArea)
Return ( cDescProd )    

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Observacao³Estrutura dos Array's de informacao da grade                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³- __aInfCodRefs             				                              ³±±
±±³  [xx]             Referencia a Linha do Acols Principal    			  ³±±
±±³  [xx][yy]         Informacoes do codigo referencia (Array) 			  ³±±
±±³  [xx][yy][01]     Codigo Referencia                        			  ³±±
±±³  [xx][yy][02]     Tamanho do codigo referencia             			  ³±±
±±³  [xx][yy][03]     Informacao da linha (Array)              			  ³±±
±±³  [xx][yy][03,01]  Codigo da linha                          			  ³±±
±±³  [xx][yy][03,02]  Tamanho do codigo da linha               			  ³±±
±±³  [xx][yy][03,03]  Array com os codigos(itens) que compoem a linha	  ³±±
±±³  [xx][yy][03,04]  Definicao do recno do SBQ    para Cod.Int.		  ³±±
±±³  [xx][yy][04]     Informacao da coluna (Array)             			  ³±±
±±³  [xx][yy][04,01]  Codigo da Coluna                         			  ³±±
±±³  [xx][yy][04,02]  Tamanho do codigo da coluna              			  ³±±
±±³  [xx][yy][04,03]  Array com os codigos(itens) que compoem as colunas  ³±±
±±³  [xx][yy][04,04]  Definicao do recno do SBQ    para Cod.Int.		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Usado para ter um controle efetivo da grade de produtos principalmente ³±±
±±³para aplicacoes com gedados e que se tenha um Mix de produtos grade SB4³±±
±±³e configurador de produtos SBQ, onde as tamanhos podem variar.         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function SetInfCodRefs(cCodRef,nACols,lFAtu)
Local cBase,cNameLin,cNameCol	
Local nPos,nLen,nLin,nCol
Local nRecLin := 0     	// Usado somente para Config. Produtos
Local nRecCol := 0		// Usado somente para Config. Produtos
Local aSavAre            

DEFAULT cCodRef 	:= ::cProdRef      
DEFAULT nACols		:= ::nPosLinO             
DEFAULT lFAtu		:= .F.

DO CASE                                     

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³A origem eh grade de produtos³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			
 	CASE MatOrigGrd() == "SB4"

        nPos := AsCan(__aInfCodRefs,{|x| x[1]==cCodRef})

        If lFAtu .Or. Empty(nPos)        
			dbSelectArea("SB4")
			dbSetOrder(1)
			MsSeek(xFilial("SB4")+cCodRef) //Nao necessita chegar a existencia pois acima foi checado se o produto eh referencia ou nao
			cNameLin		:= SB4->B4_LINHA
			cNameCol		:= SB4->B4_COLUNA
            If lFAtu .And. Len(__aInfCodRefs)>=nACols
            	nLen := nACols  
            Else
        		Aadd(__aInfCodRefs,{})
        		nLen := Len(__aInfCodRefs)
   			EndIf
        	__aInfCodRefs[nLen]		:= Array(4)
        	__aInfCodRefs[nLen,1]	:= cCodRef
        	__aInfCodRefs[nLen,2]	:= __nTamRefSB4
        	__aInfCodRefs[nLen,3]	:= Array(4)
        	__aInfCodRefs[nLen,3,1]	:= cNameLin
        	__aInfCodRefs[nLen,3,2]	:= __nTamLinSB4

        	//-- (__aInfCodRefs[nLen,3,3]	- nesta possicao sera gravado um array de linhas)
        	__aInfCodRefs[nLen,3,4]	:= nRecLin
        	__aInfCodRefs[nLen,4]	:= Array(4)
        	__aInfCodRefs[nLen,4,1]	:= cNameCol
        	__aInfCodRefs[nLen,4,2]	:= __nTamColSB4

        	//-- (__aInfCodRefs[nLen,4,3]	- nesta possicao sera gravado um array de colunas )
        	__aInfCodRefs[nLen,4,4]	:= nRecCol        	

        ElseIf nPos < nACols
    	    If Len(__aInfCodRefs) < nACols
	        	Aadd(__aInfCodRefs , aClone(__aInfCodRefs[nPos]) )
        	Else
        		__aInfCodRefs[nACols] := aClone(__aInfCodRefs[nPos])
        	EndIf
        EndIf		

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³A origem eh codigo inteligente³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ						
	CASE MatOrigGrd() == "SBQ"                             
	
        nPos := AsCan(__aInfCodRefs,{|x| x[1]==cCodRef})
    
        If lFAtu .Or. Empty(nPos)
			aSavAre := SaveArea1({"SBQ"})
			cBase	:= GetCodBase(cCodRef)
		    
			DbSelectArea("SBQ")
			DbSetOrder(3)
	
			If MsSeek(xFilial("SBQ")+cBase+"1")
				cNameLin	:= SBQ->BQ_ID
				nLin 		:= SBQ->BQ_TAMANHO    
				nRecLin		:= SBQ->( RecNo() )

				SBQ->(DbSkip())
				cNameCol	:= SBQ->BQ_ID
				nCol		:= SBQ->BQ_TAMANHO 
				nRecCol		:= SBQ->( RecNo() )
			EndIf
	
            If lFAtu .And. Len(__aInfCodRefs)>=nACols
            	nLen := nACols  
            Else
        		Aadd(__aInfCodRefs,{})
        		nLen := Len(__aInfCodRefs)
   			EndIf
    
        	__aInfCodRefs[nLen]		:= Array(4)
        	__aInfCodRefs[nLen,1]	:= cCodRef
        	__aInfCodRefs[nLen,2]	:= Len(cCodRef)
        	__aInfCodRefs[nLen,3]	:= Array(4)
        	__aInfCodRefs[nLen,3,1]	:= cNameLin
        	__aInfCodRefs[nLen,3,2]	:= nLin   
    
        	//-- (__aInfCodRefs[nLen,3,3]	- nesta possicao sera gravado um array de linhas )
        	__aInfCodRefs[nLen,3,4]	:= nRecLin
        	__aInfCodRefs[nLen,4]	:= Array(4)
        	__aInfCodRefs[nLen,4,1]	:= cNameCol
        	__aInfCodRefs[nLen,4,2]	:= nCol

        	//-- (__aInfCodRefs[nLen,4,3]	- nesta possicao sera gravado um array de colunas )
        	__aInfCodRefs[nLen,4,4]	:= nRecCol
        	        					
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Define o tamanho correto para o codigo de referencia³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ				
			RestArea1(aSavAre)				

        ElseIf nPos < nACols
			If Len(__aInfCodRefs) < nACols
	        	Aadd(__aInfCodRefs , aClone(__aInfCodRefs[nPos]) )
        	Else
        		__aInfCodRefs[nACols] := aClone(__aInfCodRefs[nPos])
        	EndIf
        EndIf					

	ENDCASE	                                                  
	
Return
                                                                     


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MatVldGGrd³ Autor ³Erike Yuri da Silva    ³ Data ³17.07.06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Validacao generica dos valores informados na Grade.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Logico                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico grade                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MatVldGGrd()
Local lRet  	:= MatGrdPrrf(@__oGrade:cProdRef) //Verifica se eh referencia de Grade --> Esta redundante mas eh teste (by erike)
Local nColuna	:= aScan(__oGrade:aHeadGrade[__oGrade:nPosLinO],{|x| ValType(x) # "C" .And. AllTrim(x[2]) == AllTrim(Substr(Readvar(),4))})
Local cProdGrd	:= ""
Local lRetVldGrd:= .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³P.E. Para validar a celula posicionada da grade                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. ExistBlock("MTVLDGRD") 
	lRetVldGrd := ExecBlock("MTVLDGRD",.F.,.F.,{ __oGrade:GetNameProd(NIL,n,nColuna)} )
	If Valtype( lRetVldGrd ) == "L"
		lRet := lRetVldGrd
	EndIf
EndIf

If lRet 
	cProdGrd := __oGrade:GetNameProd(NIL,n,nColuna) 
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o Produto Existe                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB1")
	dbSetOrder(1)
	If ( !MsSeek(xFilial("SB1")+cProdGrd,.F.) )
		DO CASE
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³A origem eh grade de produtos³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
			CASE MatOrigGrd() == "SB4"
				HELP(" ",1,"NAOEXISTE")
				lRet := .F.                 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³A origem eh codigo inteligente³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
			CASE MatOrigGrd() == "SBQ"
				lRet := A093VldCod(cProdGrd,.T.,,,.T.,.T.)
				If lRet .And. ( !MsSeek(xFilial("SB1")+cProdGrd,.F.) )
					lRet := .F.
				Endif
		ENDCASE
	EndIf
	
	If lRet .And. ! (SB1->B1_GRADE == "S")
		Help(" ",1,"A650NGRADE",, cProdGrd, 3, 0)
		lRet := .F.
	Endif	
EndIf                                                     
Return(lRet)                                        


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MatOrigGrd³ Autor ³Erike Yuri da Silva    ³ Data ³27.07.06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Seta e Retorna a origem da Grade de Produtos                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 : Origem (SB4=Grades Produtos; SBQ=Itens config. Prod ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpC1: Origem                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico grade                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MatOrigGrd(cOrigem)
If cOrigem <> NIL
	__cOrigGrd := cOrigem
EndIf
Return(__cOrigGrd)                                        


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaReadGrd ³ Autor ³Erike Yuri da Silva    ³ Data ³27.07.06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Retorna nome do objeto de grade ativo                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpC1: Nome do objeto de grade ativo                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico grade                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaReadGrd()
Return ( If(__oGrade == NIL, NIL,__oGrade:cObj) )




/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³GetTitTabG³ Autor ³Erike Yuri da Silva    ³ Data ³18.07.06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Retorna a descricao da caracteristica da tabela da grade    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo da tabela da grade                            ³±±  
±±³          ³ExpL1: Indica se retornara o titulo da linha ou coluna, va- ³±±
±±³          ³       lido apenas para configurador de produtos            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpC1: Descricao do Item da grade                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico grade                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function GetTitTabG(cCodTabela,lColuna)
Local aArea := GetArea() 
Local cRet	:= cCodTabela   
Local cFilt := ""
DEFAULT lColuna := .T.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa a origem dos dados e alimenta as variaveis                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    
DO CASE                       
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³A origem eh grade de produtos³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	CASE MatOrigGrd() == "SB4"
		cFilt := "BV_FILIAL=='"+xFilial("SBV")+"'.And.BV_TABELA=='"+cCodTabela+"'.And.!Empty(BV_DESCTAB)"
		DbSelectArea("SBV")
		DbSetOrder(1)
		SBV->(dbSetFilter({|| &cFilt}, cFilt))
		dbGoTop()
		If !EOF()
			cRet := AllTrim(SBV->BV_DESCTAB)
		EndIf
		SBV->(dbClearFilter())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³A origem eh codigo inteligente³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	CASE MatOrigGrd() == "SBQ"					
		dbSelectArea("SBQ")
		dbSetOrder(3)
		If MsSeek(xFilial("SBQ")+GetCodBase(,.T.)+If(lColuna,"2","1"))
			cRet := AllTrim(SBQ->BQ_CARACT)		
		EndIf					
ENDCASE

RestArea(aArea)
Return cRet
   

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³PesqInGrad³ Autor ³Erike Yuri da Silva    ³ Data ³21.07.06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Realiza pesquisa na grade de produtos                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo da Linha                                      ³±±  
±±³          ³ExpC2: Codigo da Coluna                                     ³±±
±±³          ³ExpN1: Opcao de pesquisa (1-Por Caracteristica;2-Por Descr) ³±±
±±³          ³ExpO1: Objeto GetDados para posicionamento.                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Se pesquisa foi realizada com sucesso ou nao.        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Method Show                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function PesqInGrade(cLinha,cColuna,nOpc,cConteudo,nOpc1,oGetD)
Local nI,nJ
Local nLinha	:= 0
Local nColuna	:= 0
Local lRet		:= .F.      

DO CASE
	CASE nOpc1 == 1 .And. !(Empty(cLinha) .Or. Empty(cColuna)) //Posicionar                            
		
		If nOpc == 1 // Por Caracteristica
			nLinha := AsCan(__aInfCodRefs[__oGrade:nPosLinO][3,3]	,{|x| Upper(x) == Upper(AllTrim(cLinha))	})
			nColuna:= AsCan(__aInfCodRefs[__oGrade:nPosLinO][4,3]	,{|x| Upper(x) == Upper(AllTrim(cColuna))	})   
			//Ajusta posicionamento de coluna com o aHeader
			nColuna:= If(nColuna>0,++nColuna,nColuna)
		ElseIf nOpc == 2//Por Descricao
			nLinha := AsCan(aCols	,{|x| Upper(AllTrim(SubStr(x[1],__oGrade:TamLin()+3,Len(x[1])) )) == Upper(AllTrim(cLinha))	})
			nColuna:= AsCan(aHeader	,{|x| Upper(AllTrim(SubStr(x[1],__oGrade:TamCol()+3,Len(x[1])) )) == Upper(AllTrim(cColuna))	})   	
		EndIf
		lRet	:= .T.	 
		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Localizar conteudo geral³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	CASE nOpc1 == 2
		
		For nI:=1 To Len(aCols)	  
			For nJ:=2 To Len(aHeader)			    
				If aHeader[nJ,8] == "C" .Or. (aHeader[nJ,8] = "N" .And. IsDigit(cConteudo))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Comparo e so permito se for exatamente igual³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If AllTrim(cConteudo) == AllTrim(If(aHeader[nJ,8] == "C",aCols[nI,nJ],StrTran(Str(aCols[nI,nJ],aHeader[nJ,4],aHeader[nJ,5]),".",",")))
						nLinha 	:= nI
						nColuna	:= nJ
						lRet	:= .T.
						Exit				
					EndIf
				EndIf
			Next nJ                    
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se encontrou sai do loop                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lRet
				Exit
			EndIf		
		Next nI
		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Localizar conteudo na linha   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	CASE nOpc1 == 3 .And. !Empty(cLinha) 
		If nOpc == 1 // Por Caracteristica
			nLinha := AsCan(__aInfCodRefs[__oGrade:nPosLinO][3,3]	,{|x| Upper(x) == Upper(AllTrim(cLinha))	})
		ElseIf nOpc == 2//Por Descricao
			nLinha := AsCan(aCols	,{|x| Upper(AllTrim(SubStr(x[1],__oGrade:TamLin()+3,Len(x[1])) )) == Upper(AllTrim(cLinha))	})
		EndIf
        
        If Empty(nLinha)
        	Help(" ",1,"PESQINGRD") 
        Else
			For nJ:=2 To Len(aHeader)
				If aHeader[nJ,8] == "C" .Or. (aHeader[nJ,8] = "N" .And. IsDigit(cConteudo))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Comparo e so permito se for exatamente igual³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If AllTrim(cConteudo) == AllTrim(If(aHeader[nJ,8] == "C",aCols[nLinha,nJ],StrTran(Str(aCols[nLinha,nJ],aHeader[nJ,4],aHeader[nJ,5]),".",",")))
						nColuna := nJ
						lRet := .T.
						Exit				
					EndIf
				EndIf
			Next nJ                    
		EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Localizar conteudo na coluna  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	CASE nOpc1 == 4 .And. !Empty(cColuna)
		If nOpc == 1 // Por Caracteristica
			nColuna:= AsCan(__aInfCodRefs[__oGrade:nPosLinO][4,3]	,{|x| Upper(x) == Upper(AllTrim(cColuna))	})   
			//Ajusta posicionamento de coluna com o aHeader
			nColuna:= If(nColuna>0,++nColuna,nColuna)
		ElseIf nOpc == 2//Por Descricao
			nColuna:= AsCan(aHeader	,{|x| Upper(AllTrim(SubStr(x[1],__oGrade:TamCol()+3,Len(x[1])) )) == Upper(AllTrim(cColuna))	})   	
		EndIf
        
		If Empty(nColuna)
			Help(" ",1,"PESQINGRD") 
		Else
			For nI:=1 To Len(aCols)
				If aHeader[nJ,8] == "C" .Or. (aHeader[nJ,8] = "N" .And. IsDigit(cConteudo))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Comparo e so permito se for exatamente igual³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aHeader[nColuna,8] $ "NC" .And. AllTrim(cConteudo) == AllTrim(If(aHeader[nColuna,8] == "C",aCols[nI,nColuna],StrTran(Str(aCols[nI,nColuna],aHeader[nColuna,4],aHeader[nColuna,5]),".",",")))
						nLinha := nI
						lRet := .T.
						Exit				
					EndIf
				EndIf
			Next nI 
		EndIf                   
		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Localizar linha e coluna da curva de caracteristica ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	CASE nOpc1 == 10 .And. !(Empty(cLinha) .Or. Empty(cColuna)) //Posicionar                            
		
		If nOpc == 1 // Por Caracteristica
			nLinha	:= AsCan(__aInfCodRefs[__oGrade:nPosLinO][3,3]	,{|x| Upper(x) == Upper(AllTrim(cLinha))	})
			nColuna	:= AsCan(__aInfCodRefs[__oGrade:nPosLinO][4,3]	,{|x| Upper(x) == Upper(AllTrim(cColuna))	})   

			//Ajusta posicionamento da coluna para curva de caracteristicas
			nColuna	:= If(nColuna>0,(nColuna+2),nColuna)
		ElseIf nOpc == 2//Por Descricao
			nLinha := AsCan(aCols	,{|x| Upper(AllTrim(SubStr(x[2],__oGrade:TamLin()+3,Len(x[2])) )) == Upper(AllTrim(cLinha))	})
			nColuna:= AsCan(aHeader	,{|x| Upper(AllTrim(SubStr(x[1],__oGrade:TamCol(),Len(x[1])) )) $ Upper(AllTrim(cColuna))	})
			If Empty(nColuna)
				nColuna:= AsCan(aHeader	,{|x| Upper(AllTrim(SubStr(x[1],__oGrade:TamCol()+3,Len(x[1])) )) == Upper(AllTrim(cColuna))	})			
			EndIf   	
		EndIf
		lRet	:= .T.	 		

	OTHERWISE        
		Help(" ",1,"PESQINGRD") 
ENDCASE 	

If lRet .And. nLinha <> 0 .And. nColuna <> 0
	oGetD:oBrowse:nAt 		:= nLinha
	oGetD:oBrowse:nColPos 	:= nColuna
	oGetD:oBrowse:SetFocus()
	oGetD:oBrowse:Refresh()
	lRet := .T.
Else          
	lRet:= .F.
EndIf

Return ( lRet )



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³GetCodBase³ Autor ³Erike Yuri da Silva    ³ Data ³21.07.06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Retorna o codigo base de produtos gerados pelo cod. intelig.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do produto                                    ³±±  
±±³          ³ExpL1: Logico que indica se forca ou nao nova validacao do  ³±±  
±±³          ³       codigo base do produto.                              ³±±  
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Caractere com codigo base do produto.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function GetCodBase(cBase,lForcaVldBase)    
DEFAULT lForcaVldBase := .F.

If lForcaVldBase
	cBase := __oGrade:cProdRef
ElseIf cBase == NIL .And. Select("SBQ") > 0 .And. AllTrim(SBQ->BQ_BASE) != AllTrim(__cCodBase)
	cBase := SBQ->BQ_BASE
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa variavel considerando que interface de grade necessita de    ³
//³linha e coluna.                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
__nTamBase := If(__nTamBase==NIL,TamSx3("BQ_BASE")[1]-1,__nTamBase) 

If (cBase <> NIL) .And. (Substr(cBase,1,__nTamBase) <> __cCodBase)
	__cCodBase := A093VldBase(cBase)
	__nTamBase := Len(RTrim(__cCodBase))
EndIf
Return (__cCodBase)                                                

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³A552Show  ³ Autor ³Erike Yuri da Silva    ³ Data ³04.08.2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do produto referencia de grade                 ³±±
±±³          ³ExpC2: Descricao do produto referencia de grade              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Mostra tela para manipulacao dos valores de interface de grade±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A552Show(cProdRef,cDescrRef,lMulticpo)
Static __cCurva	:= ""
Local oDlg,oPanel,oPnl0,oPnl1,oPnl2,oPnl3,oPnl4,oCurva
Local oGet,oOpc,nOpc
Local oFont1	:= TFont():New('Arial',, -14, .T., .T.)
Local oFont2	:= TFont():New('Arial',, -16, .T., .T.)
Local cLinha	:= Space(14)
Local cColuna	:= Space(14)
Local cReadBkp	:= __READVAR              
Local nAux		:= __oGrade:nPosLinO    
Local nOpcA	:= 0        
Local nQtdCur	:= 0
Local nPosHead	:= 0
Local nBkp		:= n 
Local nI,nJ,nZ     
Local lRet		:= .F.
Local aTam		:= TamSx3("AT_QTDCOL")               
Local aButtons	:= {}
Local aDbLst	:= {}
Local aBackup	:= Array(2) 
Local xGrade	:= __oGrade //apenas para usar em aScan

Private aObjs			:= Array(4)
Private aInfLst		:= {}
Private nColReplic	:= 0  

DEFAULT lMulticpo := .F.

//Força campo que tenha curva de caracteristica
__oGrade:cCpo := __oGrade:aCposCtrlGrd[aScan(__oGrade:aCposCtrlGrd,{|x| x[1] == xGrade:cCpo}),1]

DbSelectArea("SAS")
DbSetOrder(1)                   
__cCurva := ""
If MsSeek(xFilial("SAS")+cProdRef)  
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Salva Ambiente		 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aBackup[1]	:= aClone(aHeader)
	aBackup[2]	:= aClone(aCols)  

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Inicializa variavel	 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		 
	cProdRef	:= SAS->AS_CODREF
	M->AS_CODREF:= SAS->AS_CODREF 
	M->AS_CURVA	:= SAS->AS_CURVA   
	aHeader 	:= {}
	aCols  		:= {}  
	aObjs[3]	:= Array(2)
	aObjs[4]	:= Array(2)
 	
	Aadd(aHeader, {	STR0024,"_CURVA",PesqPict("SAT","AT_QTDCOL"),aTam[1],aTam[2],"","",aTam[3],"","A"})  //"Curvas"
	For nI:=1 To Len(aBackup[1])
		Aadd(aHeader,aBackup[1][nI])
	Next nI
	Aadd(aHeader, {	STR0025,"_TOTAL",PesqPict("SAT","AT_QTDCOL"),aTam[1],aTam[2],"","",aTam[3],"","V"})  //"Total"
	
    AtuTelaCurva(cProdRef,M->AS_CURVA,aBackup,aObjs,aInfLst)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Definicao de Botoes                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	AAdd(aButtons,{"PESQUISA"	,{|| oPnl0:lVisible := !oPnl0:lVisible },STR0005,STR0006} )  //"Pesquisar..."###"Pesq"
    
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0007) From 0,0 TO 410,800 OF oMainWnd  PIXEL //"Curva de Caracteristicas"
	oPnl0 			:= TPanel():New(00,00,"",oDlg,NIL,.T.,.F.,NIL,NIL,100,1,.T.,.F. ) 
	oPnl0:Align 	:= CONTROL_ALIGN_LEFT
	oPnl0:lVisible	:= .F. 

	//Pesquisar ---------------------------------------------------------------------------------
	TSay():New( 001, 002, {||STR0009},oPnl0, ,TFont():New('Arial',, -12, .T., .T.), , , ,.T., , , 40, 12) //"Pesquisar:"

	TSay():New( 010, 002, {||STR0010},oPnl0, , , , , ,.T., , , 80, 12) //"Informar a Linha:"
	@ 017,002 GET oGet  VAR cLinha  SIZE 95, 9 OF oPnl0 PIXEL		

	TSay():New( 030, 002, {||STR0011},oPnl0, , , , , ,.T., , , 80, 12) //"Informar a Coluna:"
	@ 037,002 GET oGet  VAR cColuna  SIZE 95, 9 OF oPnl0 PIXEL		

	TButton():New(050,002, STR0013	, oPnl0, {|| PesqInGrade(cLinha,cColuna,nOpc,,10,@aObjs[2]) }, 40, 13, , , .F., .T., , , .T.) //"&Procurar"
	TButton():New(050,045, STR0014	, oPnl0, {|| (cLinha:=Space(14),cColuna:=Space(14),oGet:Refresh()) }, 40, 13, , , .F., .T., , , .T.) //"&Limpar"

	@ 070,002 TO 100,095 LABEL OemToAnsi(STR0015) PIXEL OF oPnl0				 //"Tipo de Pesquisa:"
	@ 075,005 RADIO oOpc VAR nOpc ITEMS STR0016,STR0017 SIZE 70,10 PIXEL OF oPnl0 //"Por Caracteristica"###"Por Descricao"

	//Fim Pesquisar -----------------------------------------------------------------------------


	oPanel := TPanel():New( ,,,oPanel,,,,,,,035,,)   
	oPanel:Align := CONTROL_ALIGN_ALLCLIENT     

	oPnl1  := TPanel():New( ,,,oPanel,,,,,,,035,,)   
	oPnl1 :Align := CONTROL_ALIGN_TOP   

	TSay():New( 005, 005,{||STR0026 },oPnl1, ,oFont1, , , ,.T.,,,70,20, , , , , , )  //"Codigo:"
	TSay():New( 004, 040,{||cProdRef  },oPnl1, ,oFont2, , , ,.T.,CLR_HBLUE,,200,20, , , , , , ) 

	TSay():New( 005, 205,{||RetTitle("AS_PRDDESC")+":"}	,oPnl1, ,oFont1, , , ,.T.,,,70,20, , , , , , ) 
	TSay():New( 004, 255,{||cDescrRef	}	,oPnl1, ,oFont2, , , ,.T.,CLR_HBLUE,,200,20, , , , , , ) 
	
	TSay():New( 020, 005, {||RetTitle("AS_CURVA")+":" },oPnl1, , , , , ,.T., , ,40,20, , , , , , ) 
	@ 018, 040 MSGET oCurva VAR M->AS_CURVA PICTURE PesqPict("SAS","AS_CURVA") SIZE 025,008 VALID A552CurPr(cProdRef) .And. AtuTelaCurva(cProdRef,M->AS_CURVA,aBackup,aObjs,aInfLst) F3 "SAS" OF oPnl1 PIXEL
	
	TSay():New( 020, 130, {||STR0027},oPnl1, , , , , ,.T., , ,70,20, , , , , , )  //"Quantidade da Curva:"
	@ 018, 185 MSGET aObjs[3,1] VAR aObjs[3,2] OF oPnl1 PICTURE PesqPict("SAT","AT_QTDCOL") SIZE 030,008 PIXEL WHEN .F. 

	oPnl2:= TPanel():New( 1, 1, ,oPanel,oFont1,.F., , , , 300,10,.T.,.T.)   
    oPnl2:cCaption 	:= STR0028+If(MatOrigGrd() == "SB4",GetTitTabG(SB4->B4_COLUNA),GetTitTabG(,.T.)) //"COLUNAS DA CARACTERISTICA "
	oPnl2:Align		:= CONTROL_ALIGN_TOP              

	aObjs[1] := TwBrowse():New(000,000,800,30,,aInfLst[1],aInfLst[2],oPanel,,,,,,,,,,,,.F.,,.T.,,.F.,,,)
	aObjs[1]:SetArray( aInfLst[3] )          
	aObjs[1]:bLine	:= &(aInfLst[4])	
	aObjs[1]:align 	:= CONTROL_ALIGN_TOP

	oPnl3:= TPanel():New( 1, 1, STR0029,oPanel, oFont1,.F., , , , 300,10,.T.,.T.)    //"DETALHAMENTO DAS QUANTIDADES"
	oPnl3:Align := CONTROL_ALIGN_TOP              
    
 	aObjs[2] := MSGetDados():New(20,8,107,222,3,"AllwaysTrue","AllwaysTrue",,.F.,{"_CURVA"},1,,Len(aCols),"MaSumCurva()",,,,oPanel)
	aObjs[2]:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT     

	oPnl4 := TPanel():New( ,,,oDlg,,,,,,,015,,)   
	oPnl4:Align := CONTROL_ALIGN_BOTTOM   
	
	TSay():New( 005, 260, {|| AllTrim(RetTitle(__oGrade:cCpo)) + STR0038},oPnl4, ,oFont1 , , , ,.T., , ,70,20, , , , , , )  //"Quantidade Total"
	@ 002, 325 MSGET aObjs[4,1] VAR aObjs[4,2] OF oPnl4 PICTURE PesqPict("SAT","AT_QTDCOL") SIZE 070,010 FONT oFont1 PIXEL WHEN .F. 

	ACTIVATE MSDIALOG oDlg CENTERED ON INIT ( EnchoiceBar(oDlg,{||nOpcA:=1, oDlg:End()},{||oDlg:End()},,aButtons))   
	
	If ( nOpcA == 1 )
		If !lMulticpo
			For nI:=1 To Len(aBackup[2])  //ACOLS da Grade
				For nJ:=2 To Len(aBackup[1]) //AHEADER da Grade    
			   		aBackup[2][nI,nJ] :=  aCols[nI,nJ+1]   //Incrementa 1 na coluna para ajuste de posicoes.  
				Next nJ
			Next nI 
		Else
			For nI:=1 To Len(__oGrade:aBkpMult[2])  //ACOLS da Grade
				For nJ:=2 To Len(__oGrade:aBkpMult[1]) //AHEADER da Grade    
					If __oGrade:aBkpMult[1,nJ,11] == __oGrade:cCpo
						nPoscCpo := aScan(__oGrade:aCposCtrlGrd,{|x| x[1] == __oGrade:cCpo})
						nPosHead := aScan(__oGrade:aHeadGrade[__oGrade:nPosLinO],{|x| ValType(x) # "C" .And. x[2] == __oGrade:aBkpMult[1,nJ,2]})
						
						//-- Simula entrada de dados para execução do valid 
						__READVAR	:= "M->"+Upper(AllTrim(__oGrade:aBkpMult[1,nJ,2]))     		
						&__READVAR	:= aCols[nI,aScan(aHeader,{|x| x[2] == xGrade:aBkpMult[1,nJ,2]})]						
						nColReplic := aScan(__oGrade:aHeadGrade[__oGrade:nPosLinO],{|x| ValType(x) # "C" .And. __oGrade:aBkpMult[1,nJ,2] == x[2] })
						n		:= nI 					
						nLinha	:= nI
						nColuna:= nColReplic  
						
						//-- Se possui validação, executa valid. Se não válido, pula  											
						If !(Empty(__oGrade:aHeadGrade[__oGrade:nPosLinO,nPosHead,6]) .Or. &(__oGrade:aHeadGrade[__oGrade:nPosLinO,nPosHead,6]))
							Loop 
						EndIf
											
						//-- Atualiza total da grade
						If ( TamSx3( __oGrade:cCpo )[ 3 ] == "N" )
							nCpo := aScan(__oGrade:aSumCpos, {|x| x[1] == __oGrade:cCpo})
							//-- Subtrai valor antigo e soma valor novo
							__oGrade:aSumCpos[nCpo,2] += aCols[nI,aScan(aHeader,{|x| x[2] == xGrade:aBkpMult[1][nJ,2]})] - __oGrade:aBkpMult[2][nI,nJ]
						EndIf
						//-- Atualiza valor na grade
						__oGrade:aBkpMult[2][nI,nJ] := aCols[nI,aScan(aHeader,{|x| x[2] == xGrade:aBkpMult[1][nJ,2]})]
						
						//-- Atualiza campos relacionados
						If __oGrade:aCposCtrlGrd[nPoscCpo,3]# NIL
							For nZ:=1 To Len(__oGrade:aCposCtrlGrd[nPoscCpo,3])
								//-- Guarda o campo a ser usado na pesquisa
								cCpoAux := __oGrade:aCposCtrlGrd[nPoscCpo,3,nZ,1]
								
								//-- Verifica se o campo pode ser atualizado
								If Empty(cCpoAux) .Or. Empty(__oGrade:aCposCtrlGrd[nPoscCpo,3,nZ,2])
									Loop
								EndIf
								
								//-- Verifica se o campo informado esta na lista de contrucao do sub-array
								If (nPos := aScan(__oGrade:aCposCtrlGrd,{|x| x[1] == cCpoAux })) > 0
									__oGrade:aColsGrade[__oGrade:nPosLinO,nI,nColReplic,nPos] := Eval(__oGrade:aCposCtrlGrd[nPoscCpo,3,nZ,2])
								EndIf
							Next nZ
						EndIf
						If len(__oGrade:aCposCtrlGrd[nPoscCpo]) > 3 .and. __oGrade:aCposCtrlGrd[nPoscCpo,3] # NIL
							For nZ :=1 To Len(__oGrade:aCposCtrlGrd[nPoscCpo,3])
								//-- Guarda o campo a ser usado na pesquisa
								cCpoAux := __oGrade:aCposCtrlGrd[nPoscCpo,3,nZ,1]
								
								//-- Verifica se o campo pode ser atualizado
								If Empty(cCpoAux) .Or. Empty(__oGrade:aCposCtrlGrd[nPoscCpo,3,nZ,2])
									Loop
								EndIf
								
								//-- Verifica se o campo informado esta na lista de contrucao do sub-array
								If (nColMul := aScan(__oGrade:aBkpMult[1],{|x| x[2] == Substr(ReadVar(),4) .And. x[11] == cCpoAux})) > 0
									nVlrOld := __oGrade:aBkpMult[2,nLinha,nColMul]
									__oGrade:aBkpMult[2,nLinha,nColMul] := Eval(__oGrade:aCposCtrlGrd[nPoscCpo,3,nZ,2])	
									If ( TamSx3( cCpoAux )[ 3 ] == "N" )
										nPosAux := aScan(__oGrade:aSumCpos,{|x| x[1] == cCpoAux})
										__oGrade:aSumCpos[nPosAux,2] += __oGrade:aBkpMult[2,nLinha,nColMul] - nVlrOld
									EndIf
								Else
									nPosAux := aScan(__oGrade:aCposCtrlGrd, {|x| x[1] == cCpoAux})
									If Empty(__READVAR)
										__READVAR := "M->" +__oGrade:aHeadGrade[__oGrade:nPosLinO,n,2]
										&(__READVAR) := __oGrade:aColsGrade[__oGrade:nPosLinO,n,nColuna,nPoscCpo]
									EndIf
									__oGrade:aColsGrade[__oGrade:nPosLinO,n,nColuna,nPosAux] := Eval(__oGrade:aCposCtrlGrd[nPoscCpo,3,nZ,2])
								EndIf
							Next nZ
						EndIf
					EndIf
				Next nJ
			Next nI
			__READVAR := cReadBkp
			n := nBkp 
		EndIf
		lRet := .T.
	EndIf
	    
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura Ambiente	 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		 
	aHeader	:= aClone(aBackup[1])
	aCols		:= aClone(aBackup[2])  
Else
	//Nao existe curva de caracteristica para esta referencia de grade
	Help(" ",1,"A552NCURV")
	lRet := .F. 	
EndIf

If !lMulticpo
	//-- Executa valid zerando campos que não podem ser preenchidos
	ReVldGra()
EndIf
                                             
Return ( lRet )  


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³A552CurPr ³ Autor ³Erike Yuri da Silva    ³ Data ³04.08.2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico - indica se o codigo informado eh valido              ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Rotina de validacao  e montagem da susgestao de caracateris- ³±±
±±³          ³tica reference ao codigo da curva informado.                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function A552CurPr(cCodRef)
Local aArea 	:= GetArea()
Local lRet		:= .T.

If Empty(M->AS_CURVA)
	Help(" ",1,"VAZIO")
	lRet := .F.
Else
	dbSelectArea("SAS")
	dbSetOrder(1)
	If !MsSeek( xFilial("SAS")+cCodRef+M->AS_CURVA)
		//Nao existe curva de caracteristica para esta referencia de grade
		Help(" ",1,"A552NCURV")
		lRet := .F.
	EndIf
EndIf       
    
RestArea(aArea)
Return lRet                    
                        

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³GetLista  ³ Autor ³Erike Yuri da Silva    ³ Data ³04.08.2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: chave de pesquisa                                     ³±±
±±³          ³ExpA1: Array com aHeader original (interf. Grade)            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array contendo lista das caracteristicas das colunas e suas  ³±±
±±³          ³quantidades.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Retorna lista de caracteristicas das coluna da curva.        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function GetLista(cChave,aHeadOrig)
Local cCampo	:= ""
Local aRet 		:= Array(4)         
Local aAux		:= {}
Local nI		:= 0   
Local nPos
 
aRet[1] := {}  
aRet[2] := {}
aRet[3]	:= Array(1)                        
aRet[4]	:= '{|| {' 
aRet[3,1] := {}  

aAux 		:= Array(2)  
aAux[1]		:= {}  
aAux[2]		:= Array(1)
aAux[2,1]	:= {}                                                    

DbSelectArea("SAT")
DbSetOrder(1)
MsSeek(xFilial("SAT")+cChave) 
SAT->( DbEval(	{|| Aadd(aAux[1],a550RemoveSinal(AT_COLUNA)), Aadd(aAux[2,1],AT_QTDCOL)}, , ;
				{|| ! Eof() .And. AT_FILIAL+AT_CODREF+AT_CURVA == xFilial("SAT")+cChave} ) )   		  

//Ajusta valores com o Header Origem da tela de grade
For nI := 2 To Len(aHeadOrig)    
	cCampo := SubStr(aHeadOrig[nI][2],2,Len(aHeadOrig[nI][2]))
	nPos := AsCan(aAux[1],{|x| AllTrim(x) == AllTrim(cCampo) }) 
	If Empty(nPos)    
		Aadd(aRet[3,1]	,0)	
	Else
		Aadd(aRet[3,1]	,aAux[2,1][nPos])		
	EndIf
	Aadd(aRet[1],aHeadOrig[nI][1])
	Aadd(aRet[2],20)    
	aRet[4]+='Transform(aInfLst[3][aObjs[1]:nAT,'+StrZero(nI-1,2)+'],"@E 999,999,999.99"),'
Next

aRet[4] := SubStr(aRet[4],1,Len(aRet[4])-1)
aRet[4]	+='}}'         

Return aClone(aRet)  
                      



/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³AtuTelaCur³ Autor ³Erike Yuri da Silva    ³ Data ³04.08.2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo referencia de grade                            ³±±
±±³          ³ExpC2: Codigo da curva                                       ³±±
±±³          ³ExpA1: Array com backup do aHeader e aCols da interf. Grade  ³±±
±±³          ³ExpA2: Array com os objetos de tela para atualizacao         ³±±
±±³          ³ExpA3: Array com lista de informacoes das caracteristicas    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Rotina de atualizacao da tela de geracao de curva de caracte-³±±
±±³          ³risticas                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function AtuTelaCurva(cCodRef,cCurva,aDb,aObjs,aInfLst) 
Local nI,nJ,nTot 
Local nUsado := Len(aHeader)       
	If __cCurva  <> cCurva 
	aInfLst := GetLista(cCodRef+cCurva,aDb[1]) 
	If ValType(aObjs[1])=='O'                               
		aObjs[1]:SetArray( aInfLst[3] )  
		aObjs[1]:bLine	:= &(aInfLst[4])	   
		aObjs[1]:Refresh()
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza aCols      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	aCols := {}
	For nI:=1 To Len(aDb[2])  
		Aadd(aCols,Array(nUsado+1)) 
		For nJ:=1 To nUsado  
			If nJ == 2  
            	aCols[nI,nJ] := aDb[2][nI,1]
            Else
           		aCols[nI,nJ] := 0
            EndIf		
		Next nJ   
		aCols[nI,nUsado+1] := .F.
	Next nI
	
	If ValType(aObjs[2])=='O'                               
		aObjs[2]:oBrowse:Refresh()  	
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza Totalizador das colunas		 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aObjs[3,2] := 0
	aEval(aInfLst[3,1],{|x| aObjs[3,2] += x})   
	If ValType(aObjs[3,1]) == 'O'
		aObjs[3,1]:Refresh()	
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza Totalizador geral³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	aObjs[4,2] := 0
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Set nova curva³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	__cCurva := cCurva     
EndIf
Return .T.                                




/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³A552SumCur³ Autor ³Erike Yuri da Silva    ³ Data ³05.08.2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico - indica se o codigo informado eh valido              ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Soma as colunas de quantidade do acols atualizando objeto de ³±±
±±³          ³tela com valor do resultado da soma.                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaSumCurva()   
Local nI		:= 0 
Local nJ		:= 0
Local nQtdTot	:= 0  
Local nQtdLin	:= 0
Local nPosQtd 	:= Len(aHeader)    
Local cCpo 		:= ReadVar() 
Local lRet		:= .T.           

If AllTrim(cCpo) == "M->_CURVA" .And. &cCpo < 0
	lRet := .F.	
Else
	For nI:=1 To Len(aCols)  
		If nI == n .And. AllTrim(cCpo) == "M->_CURVA" 
			nQtdLin := 0
			For nJ:=1 To Len(aInfLst[3,1])        
				If Empty(&cCpo)
					aCols[nI,nJ+2] := 0
				Else
					aCols[nI,nJ+2] := aInfLst[3,1][nJ]*&cCpo 
				EndIf
				nQtdLin +=aCols[nI,nJ+2]				
			Next nJ        
			aCols[nI,nPosQtd]	:= nQtdLin
			nQtdTot 			+= nQtdLin
		Else
	   		nQtdTot += aCols[nI,nPosQtd]
	 	EndIf
	Next nI
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza Objetos             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
	aObjs[2]:oBrowse:Refresh() 
	aObjs[4,2] := nQtdTot
	aObjs[4,1]:Refresh()
EndIf	 		 
Return ( lRet )              


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ReVldGra  ³ Autor ³Erike Yuri da Silva    ³ Data ³07.08.2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Rotina que revalida todo o conteudo do aCols a partir da vali³±±
±±³          ³dacao do aHeader, necessario quando atualiza o aCols a partir³±±         
±±³          ³de curva de caracteristicas. Lembrando que na rotina de curva³±±    
±±³          ³nao eh possivel fazer tal analise pois nao eh individual.    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ReVldGra()
Local nI,nJ
For nI:=1 To Len(aCols)
	N := nI //Variavel utilizada nas validacoes
	For nJ:=2 To Len(aHeader)     
		If Empty( aCols[nI,nJ] )
			Loop                         	
		EndIf 
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Simulo entrada de dados pelo Get para alimentar o ReadVar(), usado nas  ³
		//³validacoes dos modulos chamadores.                                      ³ 
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
		__READVAR	:= "M->"+Upper(AllTrim(aHeader[nJ,2]))     		
		&__READVAR	:= aCols[nI,nJ]  
	
		//Atualiza Posicoes de Browse
		__oGrade:oGetdados:oBrowse:nAt		:= nI
		__oGrade:oGetdados:oBrowse:nColPos	:= nJ
				
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se tem validacao do campo, se tiver executa validacao e se nao ³
		//³for valido zera campo.                                                  ³ 
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  											
		If !( Empty(aHeader[nJ,6]) .Or. &(aHeader[nJ,6]) ) 
			aCols[nI,nJ] := 0    
		EndIf
	Next nJ
Next nI
Return




/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³IsAtNewGrd³ Autor ³Erike Yuri da Silva    ³ Data ³24.08.2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Rotina verifica se o cliente esta com o R4 para grade atuali-³±±
±±³          ³zado em seu ambiente, checando a existencia de algumas tabelas±±         
±±³          ³de curva de caracteristicas. Isso para garantir que o cliente³±±    
±±³          ³nao receba patch deste programa e tenha problemas com grade. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais/CRM                                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/                       
STATIC __lAtNwGrd := NIL

Function IsAtNewGrd()     
Local aArea := {}

If __lAtNwGrd == NIL  
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Salva Ambiente   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
	aArea := GetArea()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se existe chave do R4 no SX2³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea("SX2")
	DbSetOrder(1)
	__lAtNwGrd := MsSeek("SAS") .And. MsSeek("SAT")      
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura Ambiente³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea(aArea)	
EndIf	
Return __lAtNwGrd



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaGrade   ³ Autor ³Eduardo Riera          ³ Data ³13.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Rotina de verificacao da interface de grade.                ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a interface de grade foi habilitada        ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Esta rotina verifica se a interface de grade foi habilitada ³±±
±±³          ³atraves do parametro MV_GRADE.                              ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaGrade()
Static lGrade
DEFAULT lGrade := IIF(!__lPyme,SuperGetMv("MV_GRADE"),.F.)
Return(lGrade)



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MatGrdPrrf³ Autor ³Eduardo Riera          ³ Data ³21.02.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Verifica se o Produto Digitado eh uma referencia de grade   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indicativo de Referencia de Grade                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto                                    ³±±
±±³          ³ExpL1: Pesquisa o produto a partir Tamanho de referencia    ³±±
±±³          ³ExpL2: Verifica se a chamada da função vem do cadastro      ³±±
±±³          ³       de Curva de Característica							    ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³27/07/2006³Erike Yuri     ³Tratamento de grade para codigo inteligente ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MatGrdPrrf(cProdRef,lChkTamRef,lCurvCarac)

Local aArea   
Local aAreaSB1	:= SB1->(GetArea())
Local cMascara    := SuperGetMv("MV_MASCGRD")
Local nTamRef     := Val(Substr(cMascara,1,2))
Local lRetorno
Local cProduto    := cProdRef
DEFAULT lChkTamRef:= .F.
DEFAULT lCurvCarac:= .F.

lRetorno := IIF(!lCurvCarac,MaGrade(),.T.)

If lRetorno
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³So salva ambiente se o parametro MV_GRADE estiver habilitado            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aArea := GetArea()

	If lChkTamRef
		cProduto := Substr(cProduto,1,nTamRef)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se codigo eh grade padrao (Atencao: Esta verificacao eh efetua-³
	//³da primeiro para nao existir nenhum problema de performance de utiliza- ³
	//³cao para clientes que ja utilizam este conceito)                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB4")
	dbSetOrder(1)
	If ( MsSeek(xFilial("SB4")+cProduto,.F.) .And. !Empty(cProduto) .And. ;
		 AllTrim(SubStr(cProduto,nTamRef+1)) == "" )
		dbSelectArea("SB1")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SB1")+cProdRef,.F.) ) .And. ( SB1->B1_GRADE <> "S" )
			Help(" ",1,"A410REF")
			lRetorno := .F.
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Acerta o codigo do Produto para pesquisa no SB1                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( lRetorno )
			cProdRef := SubStr(cProdRef,1,nTamRef)
			SB4->(MsSeek(xFilial("SB4")+cProdRef))
			//-- Seta a Origem da Grade
			MatOrigGrd("SB4")
		EndIf

	Else
		dbSelectArea("SB1")
		dbSetOrder(1)
		If !lChkTamRef .And. MsSeek(xFilial("SB1")+PadR(cProdRef,Len(SB1->B1_COD)) )
			lRetorno := .F.
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se eh codigo inteligente (Configurador de Produtos) se nao for ³
			//³verifica se eh grade padrao.                                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lRetorno := A093IsGrade(@cProdRef)
			If (lRetorno)
				//-- Seta a Origem da Grade
				MatOrigGrd("SBQ")
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura a entrada da Rotina                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea(aArea)
EndIf 

SB1->(RestArea(aAreaSB1))

Return(lRetorno)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaConsRefG³ Autor ³Erike Yuri da Silva    ³ Data ³06.04.07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Verifica se devera considerar o completo do produto ou o    ³±±
±±³          ³codigo de referencia de grade de produto                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/      
Function MaConsRefG()
Static lConsRefG
DEFAULT lConsRefG := MaGrade() .And. SuperGetMv("MV_CONSGRD",,"2") == "2"
Return(lConsRefG)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaGetGrdRe³ Autor ³Erike Yuri da Silva    ³ Data ³06.04.07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Retorna codigo referencia de grade, caso exista a referencia³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto                                    ³±±
±±³          ³ExpN1: Tamanho do codigo do produto que sera truncado        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Caractere contendo o codigo de referencia de grade ou o     ³±±
±±³          ³codigo original.                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/      
Function MaGetGrdRef(cCodigo,nTamTrunc)
Local cCodRef := cCodigo
DEFAULT nTamTrunc := TamSX3("G2_REFGRD")[1]

If MatGrdPrrf(@cCodRef)
	cCodigo := PadR(cCodRef,nTamTrunc)
EndIf                                  

Return ( cCodigo )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ VldPVGrd ³ Autor ³Andre Anjos	        ³ Data ³28/08/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Verifica se ha algum item no documento que a referencia    ³±±
±±³   		 ³ esteja incorreta de acordo com o parametro MV_MASCGRD	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ VldPVGrd(nRot,cDoc)->lRet								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ lRet: Indica se ha itens inconsistentes					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nRot: Numero que identifica a rotina chamadora			  ³±±
±±³			 ³ 	1- Pedido de venda										  ³±±
±±³			 ³ 	2- Solicitacao de compras								  ³±±
±±³			 ³ 	3- Pedido de Compras									  ³±±
±±³			 ³ 	4- Documento de entrada									  ³±±
±±³			 ³ cDoc: Numero do documento que deve ser verificado		  ³±±
±±³			 ³ cSerie: Serie da nota fiscal								  ³±±
±±³			 ³ cFornec: Fornecedor do documento de entrada				  ³±±
±±³			 ³ cLoja: Loja do fornecedor do documento de entrada		  ³±±
±±³			 ³ lShowHlp: Indica se exibe help do problema na config. 	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function VldDocGrd(nRot,cDoc,cSerie,cFornece,cLoja,lShowHlp)
Local lRet := .T.
Local aArea := GetArea()
Local cFiltro := ""
Local cAlias := ""
Local nTamRefer := Val(Substr(SuperGetMV("MV_MASCGRD",.F.,"11,02,02"),1,2))
Default lShowHlp := .T.

Do Case
	//----------------------|
	// PEDIDO DE VENDA		|
	//----------------------|
	Case nRot == 1		
		cAlias := "C6GRD"
		cFiltro := "SELECT C6_FILIAL, C6_NUM, C6_PRODUTO FROM " +RetSQLName("SC6") +" WHERE D_E_L_E_T_ = '' AND "
		cFiltro += "C6_FILIAL = '" +xFilial("SC6") +"' AND C6_NUM = '" +cDoc +"' AND C6_GRADE = 'S' AND "
		cFiltro += "(C6_ITEMGRD = '01' OR C6_ITEMGRD = '001')"
		cFiltro := ChangeQuery(cFiltro)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cFiltro),cAlias,.T.,.T.)          

		While !(cAlias)->(EOF()) .And. (cAlias)->(C6_FILIAL+C6_NUM) == xFilial("SC6")+cDoc
			dbSelectArea("SB4")
			dbSetOrder(1)
			dbSeek(xFilial("SB4")+Substr((cAlias)->C6_PRODUTO,1,nTamRefer)) 
			If EOF() .Or. AllTrim(B4_COD) # AllTrim(Substr((cAlias)->C6_PRODUTO,1,nTamRefer))
				lRet := .F.
				Exit
			EndIf
			
			(cAlias)->(dbSkip())
		End
		(cAlias)->(dbCloseArea())
	
	//------------------------------|
	// SOLICITACAO DE COMPRAS		|
	//------------------------------|
	Case nRot == 2	
		cAlias := "C1GRD"
		cFiltro := "SELECT C1_FILIAL, C1_NUM, C1_PRODUTO FROM " +RetSQLName("SC1") +" WHERE D_E_L_E_T_ = '' AND "
		cFiltro += "C1_FILIAL = '" +xFilial("SC1") +"' AND C1_NUM = '" +cDoc +"' AND C1_GRADE = 'S' AND "
		cFiltro += "C1_ITEMGRD = '001'"
		cFiltro := ChangeQuery(cFiltro)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cFiltro),cAlias,.T.,.T.)
		
		While !(cAlias)->(EOF()) .And. (cAlias)->(C1_FILIAL+C1_NUM) == xFilial("SC1")+cDoc
			dbSelectArea("SB4")
			dbSetOrder(1)
			dbSeek(xFilial("SB4")+Substr((cAlias)->C1_PRODUTO,1,nTamRefer)) 
			If EOF() .Or. AllTrim(B4_COD) # AllTrim(Substr((cAlias)->C1_PRODUTO,1,nTamRefer))
				lRet := .F.
				Exit
			EndIf
			
			(cAlias)->(dbSkip())
		End
		(cAlias)->(dbCloseArea())
		
	//----------------------|
	// PEDIDO DE COMPRA		|
	//----------------------|
	Case nRot == 3	
		cAlias := "C7GRD"
		cFiltro := "SELECT C7_FILIAL, C7_NUM, C7_PRODUTO FROM " +RetSQLName("SC7") +" WHERE D_E_L_E_T_ = '' AND "
		cFiltro += "C7_FILIAL = '" +xFilial("SC7") +"' AND C7_NUM = '" +cDoc +"' AND C7_GRADE = 'S' AND "
		cFiltro += "C7_ITEMGRD = '001'"
		cFiltro := ChangeQuery(cFiltro)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cFiltro),cAlias,.T.,.T.)
		
		While !(cAlias)->(EOF()) .And. (cAlias)->(C7_FILIAL+C7_NUM) == xFilial("SC7")+cDoc
			dbSelectArea("SB4")
			dbSetOrder(1)
			dbSeek(xFilial("SB4")+Substr((cAlias)->C7_PRODUTO,1,nTamRefer)) 
			If EOF() .Or. AllTrim(B4_COD) # AllTrim(Substr((cAlias)->C7_PRODUTO,1,nTamRefer))
				lRet := .F.
				Exit
			EndIf
			
			(cAlias)->(dbSkip())
		End		
		(cAlias)->(dbCloseArea())
	
	//------------------------------|
	// DOCUMENTO DE ENTRADA			|
	//------------------------------|
	Case nRot == 4
		cAlias := "D1GRD"
		cFiltro := "SELECT D1_FILIAL, D1_DOC, D1_COD FROM " +RetSQLName("SD1") +" WHERE D_E_L_E_T_ = '' AND "
		cFiltro += "D1_FILIAL = '" +xFilial("SD1") +"' AND D1_DOC = '" +cDoc +"' AND D1_SERIE = '" +cSerie +"' AND "
		cFiltro += "D1_FORNECE = '" +cFornece +"' AND D1_LOJA = '" +cLoja +"' AND D1_GRADE = 'S' AND "
		cFiltro += "D1_ITEMGRD = '001'"
		cFiltro := ChangeQuery(cFiltro)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cFiltro),cAlias,.T.,.T.)		
		
		While !(cAlias)->(EOF()) .And. (cAlias)->(D1_FILIAL+D1_DOC) == xFilial("SD1")+cDoc
			dbSelectArea("SB4")                  
			dbSetOrder(1)
			dbSeek(xFilial("SB4")+Substr((cAlias)->D1_COD,1,nTamRefer)) 
			If EOF() .Or. AllTrim(B4_COD) # AllTrim(Substr((cAlias)->D1_COD,1,nTamRefer))
				lRet := .F.
				Exit
			EndIf
			
			(cAlias)->(dbSkip())
		End
		(cAlias)->(dbCloseArea())
	
EndCase

If !lRet .And. lShowHlp
	Help(" ",1,"NOREFGRD")
EndIf

RestArea(aArea)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MatGrMFakeºAutor  ³Andre Anjos         º Data ³  26/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ A chamada das validacoes e encapsulada nesta funcao pois e º±±
±±º          ³ necessario realizar ajustes no aHeader e aCols. Esta funcaoº±±
±±º          ³ tambem executa o preenchimento de campos relacionados na   º±±
±±º          ³ multicampo.												  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cValid: Funcoes de validacao								  º±±
±±			   ³ lCurva: Indica se foi chamada para executar curva de carac.º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATGRADE                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MatGrMFake(cValid,lCurva)
Local lRet		:= .T.
Local nColuna	:= 0
Local nLinha	:= N
Local nCol		:= 2
Local nLin		:= 1
Local nPos		:= 0
Local nPosAux	:= 0
Local nVlrOld	:= 0
Local cCpoAux	:= ""
Local nColMul	:= If(Type("nColReplic") == "N",nColReplic,__oGrade:oGetDados:oBrowse:nColPos)
Local cBusca	:= aHeader[nColMul,2]
Local cCampo	:= aHeader[nColMul,11]
Local cCpoBkp	:= __oGrade:cCpo

Default lCurva := .F.

__oGrade:aBkpMult[1] := aClone(aHeader)
__oGrade:aBkpMult[2] := aClone(aCols)
If !lCurva
	__oGrade:cCpo := aHeader[nColMul,11]
EndIf

While nCol <= Len(aHeader)
	If aHeader[nCol,11] # cCampo
		aDel(aHeader,nCol)
		aSize(aHeader,Len(aHeader)-1)
		
		For nLin := 1 To Len(aCols)
			aDel(aCols[nLin],nCol)
			aSize(aCols[nLin],Len(aCols[nLin])-1)
		Next nLin
	Else
		aHeader[nCol,1] := __oGrade:aHeadGrade[__oGrade:nPosLinO,nCol,1]
		nCol++
	EndIf
End

nColuna := aScan(aHeader,{|x| AllTrim(x[2]) == cBusca})
aCols[n,nColuna] := __oGrade:aBkpMult[2,n,nColMul]

lRet := &(cValid)

aHeader := aClone(__oGrade:aBkpMult[1])
aCols	:= aClone(__oGrade:aBkpMult[2])

//-- Preenche campos relacionados na multicampo
If !lCurva .And. lRet .And. Len(__oGrade:aSumCpos) > 1
	nPos := aScan(__oGrade:aCposCtrlGrd, {|x| x[1] == cCampo})
	If Len(__oGrade:aCposCtrlGrd[nPos]) > 3 .And. __oGrade:aCposCtrlGrd[nPos,4] # NIL
		For nLin :=1 To Len(__oGrade:aCposCtrlGrd[nPos,4])
			//-- Guarda o campo a ser usado na pesquisa
			cCpoAux := __oGrade:aCposCtrlGrd[nPos,4,nLin,1]
			
			//-- Verifica se o campo pode ser atualizado
			If Empty(cCpoAux) .Or. Empty(__oGrade:aCposCtrlGrd[nPos,4,nLin,2])
				Loop
			EndIf
			
			//-- Verifica se o campo informado esta na lista de contrucao do sub-array
			If (nColMul := aScan(aHeader,{|x| x[2] == Substr(ReadVar(),4) .And. x[11] == cCpoAux})) > 0
				nVlrOld := aCols[n,nColMul]
				aCols[n,nColMul] := Eval(__oGrade:aCposCtrlGrd[nPos,4,nLin,2])	
				If ( TamSx3( cCpoAux )[ 3 ] == "N" )
					nPosAux := aScan(__oGrade:aSumCpos,{|x| x[1] == cCpoAux})
					__oGrade:aSumCpos[nPosAux,2] += aCols[n,nColMul] - nVlrOld
				EndIf
			Else
				nPosAux := aScan(__oGrade:aCposCtrlGrd, {|x| x[1] == cCpoAux})
				If Empty(__READVAR)
					__READVAR := "M->" +__oGrade:aHeadGrade[__oGrade:nPosLinO,n,2]
					&(__READVAR) := __oGrade:aColsGrade[__oGrade:nPosLinO,n,nColuna,nPos]
				EndIf
				__oGrade:aColsGrade[__oGrade:nPosLinO,n,nColuna,nPosAux] := Eval(__oGrade:aCposCtrlGrd[nPos,4,nLin,2])
			EndIf
		Next nI					
	EndIf
EndIf

__oGrade:aBkpMult := Array(2)
If !lCurva
	__oGrade:cCpo := cCpoBkp
EndIf
         
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrdSumTelaºAutor  ³Andre Anjos         º Data ³  01/29/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao que realiza a soma da tela de grade para um 		  º±±
±±º          ³ determinado campo.                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cCpo: Campo a ser somado.						 		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno 	 ³ cRet: Quantidade somada em formato string.				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATGRADE                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrdSumTela(cCpo,nPos)
Local cRet  	:= STR0043 //Nao ha totalizador.
Local aSX3  	:= TamSX3(cCpo)
Local nColPos  := __oGrade:oGetDados:oBrowse:nColPos
Local lCpoPos  := Substr(ReadVar(),4) == aHeader[nColPos,2] .And. If(Len(aHeader[nColPos]) > 10,aHeader[nColPos,11] == cCpo,.T.)

If ( TamSx3( cCpo )[ 3 ] == "N" )
	If lCpoPos
		__oGrade:aSumCpos[nPos,2] += &(ReadVar()) - aCols[n,nColPos]
	EndIf
	If aScan(__oGrade:aSumCpos,{|x| x[1] == cCpo}) == 0
		__oGrade:lShowMsgDiff := .F.
		cRet := PadL(Str(__oGrade:SomaGrade(cCpo,__oGrade:nPosLinO),aSX3[1],aSX3[2]),20)
		__oGrade:lShowMsgDiff := .T.
	Else
		cRet := PadL(Str(__oGrade:aSumCpos[nPos,2],aSX3[1],aSX3[2]),20)
	EndIf
EndIf
   
Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ MtGrdMCOKºAutor  ³Andre Anjos         º Data ³  04/03/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Valida campos obrigatorios em grade multicampo             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATGRADE                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MtGrdLinOK()
Local lRet     := .T.
Local aObrigat := {}
Local cVar	   := ""
Local nColReal := 1
Local nCpo     := 0
Local nX	   := 0
Local nLinha   := 0

For nLinha := 1 To Len(aCols)
	For nX := 2 To Len(aHeader)
		cVar     := aHeader[nX,2]
		aObrigat := {}
		nColReal := aScan(__oGrade:aHeadGrade[__oGrade:nPosLinO],{|x| ValType(x) # "C" .And. aHeader[nX,2] == x[2] })
	
		While nX <= Len(aHeader) .And. cVar == aHeader[nX,2]
			nCpo := aScan(__oGrade:aCposCtrlGrd,{|x| x[1] == aHeader[nX,11]})		
			If Len(__oGrade:aCposCtrlGrd[nCpo]) > 4 .And. ValType(__oGrade:aCposCtrlGrd[nCpo,5]) == "L" .And. __oGrade:aCposCtrlGrd[nCpo,5]
				aAdd(aObrigat,!Empty(aCols[nLinha,nX]))		
			EndIf
			nX++
		End
		
		If !Empty(aObrigat) .And. aScan(aObrigat,{|x| x}) > 0 .And. (nCpo := aScan(aObrigat,{|x| !x})) > 0  
			Aviso(STR0044,STR0045 +AllTrim(RetTitle(aHeader[nCpo+1,11])) +STR0046 +__oGrade:GetNameLinha(nLinha) +; //O campo ### '" é obrigatório e não foi preenchido para a combinação ###
						'\' +__oGrade:GetNameColuna(nColReal) +'.',{'Ok'})
			lRet := .F.
			Exit
		Else
			nX --
		EndIf
	Next nX
	If !lRet
		Exit
	EndIf
Next nLinha

Return lRet

//------------------------------------------------------------------------------
/*/	{Protheus.doc} RestMaGrade

Restaura variável estática para correto funcionamento do robô de testes.

@sample	RestMaGrade()

@return	Nil

@author	Thamara Villa Jacomo
@since		28/10/2016
@version	12.1.7
/*/
//------------------------------------------------------------------------------
Function RestMaGrad()
	lGrade := Nil
Return

Function PrgMascGRD()

Local cQuery    := ""
Local cAliasSB1 := ""
Local cMascGrd	:= superGetMV("MV_MASCGRD",,"")
Local cNewMasc	:= ""
Local lGrade	:= superGetMV("MV_GRADE",,.F.)
Local oQry		:= Nil

	if !empty(M->X6_CONTEUD) .and. alltrim(cMascGrd) <> alltrim(M->X6_CONTEUD)
		cNewMasc := M->X6_CONTEUD
	elseif !empty(M->X6_CONTENG) .and. alltrim(cMascGrd) <> alltrim(M->X6_CONTENG)
		cNewMasc := M->X6_CONTENG
	elseif !empty(M->X6_CONTSPA)  .and. alltrim(cMascGrd) <> alltrim(M->X6_CONTSPA)
		cNewMasc := M->X6_CONTSPA
	endif

	if lGrade .and. !empty(cNewMasc) .and. !empty(cMascGrd) .and. alltrim(cMascGrd) <> alltrim(cNewMasc)

		cQuery := "SELECT COUNT(SB1.B1_COD) PRODUTO " 
		cQuery += "FROM "+RetSqlName("SB1")+" SB1 "
		cQuery += "WHERE B1_MSBLQL 		<> ? "
		cQuery += "AND B1_GRADE 		= ? "
		cQuery += "AND SB1.D_E_L_E_T_	= ? "

		cQuery := ChangeQuery(cQuery)
		oQry := FwExecStatement():New(cQuery)

		oQry:SetString(1,'1')
		oQry:SetString(2,'S')
		oQry:SetString(3,' ')

		cAliasSB1 := oQry:OpenAlias()

		oQry:Destroy()

		while (cAliasSB1)->(!EOF())
			if (cAliasSB1)->PRODUTO > 0
				Help(,,STR0048,,STR0049,1,0, , , , , , {STR0050})
			endif
			(cAliasSB1)->(DbSkip())
		enddo

		(cAliasSB1)->(DbCloseArea())
	
	endif

Return .T.
