#Include 'TMSAE60.ch'
#Include 'Protheus.ch'

Static lRestRepom := SuperGetMV( 'MV_VSREPOM',, '1' ) == '2.2'
/*


Ŀ
Funo     TMSAE60   Autor  Vitor Raspa            Data  09.Jun.06
Ĵ
Descrio  Cadastro de Gerenciadores de Frota (Operadoras)            
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                    
ٱ


*/
Function TMSAE60()

Private cCadastro := STR0001 //'Gerenciadores de Frota'
Private aRotina   := MenuDef()

mBrowse( ,,,,'DEG')

RetIndex('DEG')
Return NIL

/*


Ŀ
Funo    TMSAE60Mnt Autor  Vitor Raspa            Data  09.Jun.06
Ĵ
Descrio  Manutencao de Gerenciadores de Frota (Operadoras)          
Ĵ
Sintaxe    TMSAE60Mnt(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                    
ٱ


*/
Function TMSAE60Mnt( cAlias, nReg, nOpc ) 

//-- EnchoiceBar
Local oEnchoice
Local lOk        := .F.

//-- Dialog
Local oDlg
Local aButtons   := {}

//-- GetDados
Local aNoFields  := {'DEH_CODOPE', 'DEH_NOMOPE'}
Local aYesFields := {}

//-- Controle de dimensoes de objetos
Local aObjects   := {}
Local aInfo      := {}

//-- EnchoiceBar
Private aTela[0][0]
Private aGets[0]

//-- GetDados
Private oGetDados
Private aHeader    := {}
Private aCols      := {}
Private aPosObj    := {}

//--Operacoes X Operadoras
Private aHeaderDEJ := {}
Private aColsDEJ   := {}
Private aOperac    := {}

//--Municipios X Operadoras
Private aHeaderDEI := {}
Private aColsDEI   := {}

DEFAULT cAlias := 'DEG'
DEFAULT nReg   := 1
DEFAULT nOpc   := 2

AAdd(aButtons, {"PEDIDO",{|| TMSAE60Ope(nOpc)}, STR0008, STR0007 } ) //"Operac."###"Operacoes da Operadora"
AAdd(aButtons, {"NORMAS",{|| TMSAE60Mun(nOpc)}, STR0010, STR0009 } ) //"MunXOper"###"Municipios X Operadores"

//Ŀ
//Configura variaveis da Enchoice
//
RegToMemory( cAlias, nOpc==3 )

//Ŀ
//Configura variaveis da GetDados Principal
//
TMSFillGetDados( 	nOpc, 'DEH', 1, xFilial( 'DEH' ) + M->DEG_CODOPE ,; 
						{ ||  DEH->(DEH_FILIAL + DEH_CODOPE ) },;
					 	{ || .T. }, aNoFields,	aYesFields )

//Ŀ
//Preenche o Numero do Item
//
If Empty(GDFieldGet("DEH_ITEM",1))
	GDFieldPut("DEH_ITEM",StrZero(1,Len(DEH->DEH_ITEM)),1)
EndIf

//Ŀ
// Atualiza Dados do aCols e aHeader - DEJ 
// Operadores X Produtos                   
//
TMSAE60DEJ(nOpc)

//Ŀ
// Atualiza Dados do aCols e aHeader - DEI 
// Operadores X Municipios                 
//
TMSAE60DEI(nOpc)

//-- Dimensoes padroes
aSize := MsAdvSize()
AAdd( aObjects, { 65, 100, .T., .T. } )
AAdd( aObjects, { 235, 110, .T., .T. } )
aInfo   := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 5, 5 }
aPosObj := MsObjSize( aInfo, aObjects,.T.)

DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],00 TO aSize[6],aSize[5] PIXEL

//-- Enchoice
oEnchoice := MsMGet():New( cAlias, nReg, nOpc,,,,, aPosObj[1],, 3,,,,,,.T. )

//--GetDados
oGetDados := MSGetDados():New(	aPosObj[ 2, 1 ], aPosObj[ 2, 2 ],aPosObj[ 2, 3 ], aPosObj[ 2, 4 ],; 
											nOpc, 'TMSAE60LOk','TMSAE60TOk','+DEH_ITEM',;
											IIf(nOpc == 3 .Or. nOpc == 4,.T.,Nil),,,,99)

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg,	{|| If(TMSAE60TOk(), ( lOk := .T.,oDlg:End()), lOk := .F. )} ,;
													{|| lOk := .F., oDlg:End()},,aButtons )

If nOpc != 2 .And. lOk
	TMSAE60Grv( M->DEG_CODOPE, nOpc )
EndIf

Return

/*


Ŀ
Funo    TMSAE60LOk Autor  Vitor Raspa            Data  09.Jun.06
Ĵ
Descrio  Validacoes da linha da GetDados                            
Ĵ
Sintaxe    TMSAE60LOk()                                               
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                    
ٱ


*/
Function TMSAE60LOk()
Local lRet      := .T.
Local aCpoCheck := {'DEH_CODPRO'}

If !GDDeleted(n) .And. (lRet:=MaCheckCols(aHeader,aCols,n))
	//-- Analisa se ha itens duplicados na GetDados.
	lRet := GDCheckKey(aCpoCheck,4)
EndIf

Return(lRet)

/*


Ŀ
Funo    TMSAE60TOk Autor  Vitor Raspa            Data  09.Jun.06
Ĵ
Descrio  Tudo Ok da GetDados                                        
Ĵ
Sintaxe   TMSAE60TOk()                                                
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                    
ٱ


*/
Function TMSAE60TOk()
Local lRet := .T.
Local nAux                                              
Local nDel := 0

/*Variveis para quebra do Arquivo .PFX*/ 
Local cRet 			:= ""
Local cDirectory 	:= GetSrvProfString("Startpath","")
Local cBarra		:= If(IsSrvUnix(), "/", "\")
Local aFilial 		:= FWArrFilAtu(cEmpAnt, cFilAnt)
Local cArqCERT 		:= cDirectory+AllTrim(aFilial[18])+"_certif_cert"
Local cArqKEY 		:= cDirectory+AllTrim(aFilial[18])+"_certif_key"
Local cCERTDig		:= ""

cDirectory := GetSrvProfString("StartPath","") + If(Right(GetSrvProfString("StartPath",""),1) == cBarra,"",cBarra)
If	SubStr(cDirectory, Len(cDirectory), 1 ) != '\' .And. SubStr(cDirectory, Len(cDirectory), 1 ) != '/'
	cDirectory := cDirectory + '\'
EndIf


//Ŀ
//Verifica a Enchoice
//
lRet := Obrigatorio( aGets, aTela )

//Ŀ
//Verifica a GetDados Principal
//
If lRet
	lRet := TAE60OpLOk()
EndIf

//Ŀ
//Verifica se as linhas estao Ativas
//GetDados Principal                
//
If lRet .And. M->DEG_CODOPE <> "02" .And. !lRestRepom //Projeto Pamcard
	nDel := 0
	For nAux := 1 To Len(aCols)
		If aCols[nAux,Len(aHeader)+1]
			nDel++
		EndIf
	Next
	If Len(aCols) == nDel
		Help('',1,'TMSAE6001') //--'Produto no Informado!'
		lRet := .F.
	EndIf
EndIf

//Ŀ
//Verifica se as linhas estao Ativas
//GetDados - Operacoes X Operadoras 
//
If lRet .And. M->DEG_CODOPE == "01" .And. !lRestRepom //Projeto Pamcard
	If Empty(aColsDEJ)	
		Help('',1,'TMSAE6002') //-- 'Operaes no Informadas!'
		lRet := .F.
	Else
		nDel := 0
		For nAux := 1 To Len(aColsDEJ)
			If aColsDEJ[nAux,Len(aHeaderDEJ)+1]
				nDel++
			EndIf
		Next
		If Len(aColsDEJ) == nDel
			Help('',1,'TMSAE6002') //-- 'Operaes no Informadas!'
			lRet := .F.
		EndIf
	EndIf
ElseIf lRet 
	cCERTDig := AllTrim(M->DEG_CERTDG)
	
	If Len(AllTrim(cCERTDig)) == TamSx3("DEG_CERTDG")[1] .AND. Upper( SubStr( cCERTDig, Len(cCERTDig) - 2, 3 ) ) <> 'PFX'
		lRet := .F.
		Help( "", 1, "TMSAE60TOk", , STR0024, 1, 0, , , , , , { STR0025 } ) //"O campo Certificado Digital excedeu o limite de caracteres." - //"Verifique o conteudo do campo Certif. Dig. (DEG_CERTDG)."
	EndIf
	
	If lRet .AND. Upper(SubStr(cCERTDig,Len(cCERTDig) - 2,3)) == 'PFX'
		If Empty(M->DEG_CODACE)
			Help('',1,'TMSAE6009') //-- 'Chave de acesso do certificado no Informada!'
			lRet := .F.
		Else		
			lRet:= TMAE60CCer(M->DEG_CERTDG,M->DEG_CODACE,cArqCERT,cArqKey, @cRet)
			If !lRet 
				Help(Nil,Nil,'HELP',Nil, cRet , 1, 0) 
			EndIf
		EndIf
	EndIf
EndIf

Return( lRet )

/*


Ŀ
Funo     TMSAE60Grv Autor  Vitor Raspa           Data  09.Jun.06
Ĵ
Descrio  Gravar dados                                               
Ĵ
Sintaxe    TMSAE60Grv( ExpC1, ExpN1 )                                 
Ĵ
Parametros ExpC1: Codigo da Operadora                                 
           ExpN1: Opcao Selecionada                                   
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                    
ٱ


*/
Static Function TMSAE60Grv( cCodOpe, nOpc )
Local nAux  := 0
Local nAux2 := 0

Local aArea    := GetArea()
Local aAreaDEG := DEG->(Getarea())
Local aAreaDEH := DEH->(Getarea())
Local aAreaDEJ := DEJ->(GetArea())
Local aAreaDEI := DEI->(GetArea())

Local nItemDEJ := Ascan(aHeaderDEJ, {|x| AllTrim(x[2]) == 'DEJ_ITEM'})
Local nItemDEI := Ascan(aHeaderDEI, {|x| AllTrim(x[2]) == 'DEI_ITEM'})

If	nOpc == 5
	//Ŀ
	// EXCLUSAO 
	//
	Begin Transaction

		//Ŀ
		//CABECALHO
		//
		RecLock('DEG', .F.)
		DbDelete()
		MsUnLock()

		//Ŀ
		//OPERADORES x PRODUTOS
		//
		DEH->(DbSetOrder(1))
		While DEH->( MsSeek( xFilial('DEH') + cCodOpe, .F. ) )
			RecLock('DEH', .F.)
			DbDelete()
			MsUnLock()
		EndDo

		//Ŀ
		//OPERADORES x OPERACOES
		//
		DEJ->(DbSetOrder(2))
		While DEJ->( MsSeek( xFilial('DEJ') + cCodOpe, .F. ) )
			RecLock('DEJ',.F.)
			DbDelete()
			MsUnLock()
		EndDo

		//Ŀ
		//OPEARDORES x MUNICIPIOS
		//
		DEI->( DbSetOrder(1))
		While DEI->( MsSeek( xFilial('DEI') + cCodOpe, .F. ) )
			RecLock('DEI',.F.)
			DbDelete()
			MsUnLock()
		EndDo

	End Transaction

Else

	//Ŀ
	// INCLUSAO/ALTERACAO 
	//
	Begin Transaction

		//-- Cabecalho
		RecLock("DEG",(nOpc == 3))
		Aeval( dbStruct(),{|aFieldName,nI| FieldPut( nI, If('FILIAL' $ aFieldName[1],;
													   xFilial( "DEG" ), M->&(aFieldName[1]) ) ) } )

		//Ŀ
		//OPERADORES x PRODUTOS
		//
		For nAux := 1 To Len( aCols )
			If	!GDDeleted( nAux )
				DEH->(dbSetOrder(1))
				If	DEH->( MsSeek( xFilial('DEH') + cCodOpe + GDFieldGet( 'DEH_ITEM', nAux ), .F. ) )
					RecLock('DEH', .F.)
				Else
					RecLock('DEH', .T.)
					DEH->DEH_FILIAL := xFilial('DEH')
					DEH->DEH_CODOPE := cCodOpe
				EndIf

				For nAux2 := 1 To Len(aHeader)
					If	aHeader[nAux2,10] != 'V'
						FieldPut(FieldPos(aHeader[nAux2,2]), aCols[nAux,nAux2])
					EndIf
				Next
				MsUnLock()
			Else
				If	DEH->( MsSeek( xFilial('DEH') + cCodOpe + GDFieldGet( 'DEH_ITEM', nAux ), .F. ) )
					RecLock('DEH',.F.)
					DbDelete()
					MsUnLock()
				EndIf
			EndIf
		Next
		
		//Ŀ
		//OPERADORES x OPERACOES
		//
		For nAux := 1 To Len(aColsDEJ)
			If !aColsDEJ[nAux,Len(aHeaderDEJ)+1]
				DEJ->(DbSetOrder(1))
				If DEJ->(MsSeek( xFilial('DEJ') + cCodOpe + aColsDEJ[nAux,nItemDEJ], .F. ) )
					RecLock('DEJ',.F.)
				Else
					RecLock('DEJ',.T.)
					DEJ->DEJ_FILIAL := xFilial('DEJ')
					DEJ->DEJ_CODOPE := cCodOpe
				EndIf
				For nAux2 := 1 To Len(aHeaderDEJ)
					If aHeaderDEJ[nAux2,10] != 'V'
						FieldPut(FieldPos(aHeaderDEJ[nAux2,2]), aColsDEJ[nAux,nAux2])
					EndIf
				Next
				MsUnLock()
			Else
				DEJ->(DbSetOrder(1))
				If	DEJ->( MsSeek( xFilial('DEJ') + cCodOpe + aColsDEJ[nAux,nItemDEJ], .F. ) )
					RecLock('DEJ', .F.)
					DbDelete()
					MsUnLock()
				EndIf
			EndIf
		Next

		//Ŀ
		//OPERADORES x MUNICIPIOS
		//
		For nAux := 1 To Len(aColsDEI)
			If !aColsDEI[nAux,Len(aHeaderDEI)+1]
				DEI->(DbSetOrder(1))
				If DEI->(MsSeek( xFilial('DEI') + cCodOpe + aColsDEI[nAux,nItemDEI], .F. ) )
					RecLock('DEI',.F.)
				Else
					RecLock('DEI',.T.)
					DEI->DEI_FILIAL := xFilial('DEI')
					DEI->DEI_CODOPE := cCodOpe
				EndIf
				For nAux2 := 1 To Len(aHeaderDEI)
					If aHeaderDEI[nAux2,10] != 'V'
						FieldPut(FieldPos(aHeaderDEI[nAux2,2]), aColsDEI[nAux,nAux2])
					EndIf
				Next 
				MsUnLock()
			Else
				DEI->(DbSetOrder(1))
				If	DEI->( MsSeek( xFilial('DEI') + cCodOpe + aColsDEI[nAux,nItemDEI], .F. ) )
					RecLock('DEI', .F.)
					DbDelete()
					MsUnLock()
				EndIf
			EndIf
		Next

	End Transaction

EndIf

RestArea(aAreaDEG)
RestArea(aAreaDEH)
RestArea(aAreaDEJ)
RestArea(aAreaDEI)
RestArea(aArea)

Return NIL

/*


Ŀ
Funo    TMSAE60Vld Autor  Vitor Raspa            Data  09.Jun.06
Ĵ
Descrio  Validacoes                                                 
Ĵ
Sintaxe    TMSAE60Vld()                                               
Ĵ
 Uso       TMSAE60                                                    
ٱ


*/
Function TMSAE60Vld()

Local lRet   := .T.
Local nAchou := 0
Local cCampo := ReadVar()

If !TmsNewOper()
	If cCampo $ 'M->DEJ_SERTMS'
		If GDFieldPos('DEJ_DESSVT') > 0
			GDFieldPut('DEJ_DESSVT', TMSValField("M->DEJ_SERTMS",.F.,"DEJ_DESSVT"),n)
		EndIf
	
	ElseIf cCampo $ 'M->DEJ_TIPTRA'
		If GDFieldPos('DEJ_DESTPT') > 0
			GDFieldPut('DEJ_DESTPT', TMSValField('M->DEJ_TIPTRA',.F.,'DEJ_DESTPT'),n)
		EndIf
	
	ElseIf cCampo $ 'M->DEJ_OPERAC'
		If Empty(aOperac) .And. !Empty(M->DEJ_OPERAC)
			TMSOper(.F., M->DEG_CODOPE)
		EndIf
	
		If !Empty(aOperac)
			nAchou := AScan(aOperac, {|x| AllTrim( x[1] ) == AllTrim( M->DEJ_OPERAC )})
			If nAchou > 0 
				If GDFieldPos('DEJ_DESOPE') > 0
					GDFieldPut('DEJ_DESOPE', aOperac[nAchou,2],n)
				EndIf
			Else
				Help('',1,'TMSAE6003') //-- 'Operao Invlida!'
				lRet := .F.
			EndIf
		Else
			Help('',1,'TMSAE6004') //-- "Problemas na Comunicao com a Operadora impedem a Validao do Campo!"
		EndIf
	
	ElseIf cCampo $ 'M->DEI_REGORI'
		If GDFieldPos('DEI_REGORI') > 0
			GDFieldPut('DEI_REGORI', Posicione('DUY',1,xFilial('DUY')+GDFieldGet('DEI_CDRORI',n),'DUY_DESCRI') )
		EndIf
	
	ElseIf cCampo $ 'M->DEH_CODPRO'
		SB1->(DbSetOrder(1))
		If SB1->(MsSeek(xFilial('SB1')+M->DEH_CODPRO)) 
			If IsProdMod(SB1->B1_COD) .Or. (SB1->B1_TIPO == "BN" .Or. (SB1->B1_TIPO == "BN" .And. !MatBuyBN()))
				lRet := .F.
				Help('',1,'TMSAE6008') //-- 'Produto invalido!'
			EndIf
		Else
			lRet := .F.
		EndIf
	ElseIf cCampo $ 'M->DEG_FILCTR'
		M->DEG_NOMCTR := Posicione('SM0',1,cEmpAnt+M->DEG_FILCTR,'M0_FILIAL')      
	
	ElseIf cCampo $ 'M->DEG_TMPESP'
		If Empty(M->DEG_TMPESP) 
			If lRestRepom .And. M->DEG_CODOPE == '01'
				Help('',1,"OBRIGAT2",,RetTitle('DEG_TMPESP'),04,01)
				lRet:= .F.
			EndIf
		Else
			lRet:= IsNumeric(M->DEG_TMPESP)
		EndIf
		
	ElseIf cCampo $ "M->DEG_GERCTC"
		If Empty(M->DEG_GERCTC) 
			If lRestRepom .And. M->DEG_CODOPE == '01'
				Help('',1,"OBRIGAT2",,RetTitle('DEG_GERCTC'),04,01)
				lRet:= .F.
			EndIf
		EndIf
	
	ElseIf cCampo $ "M->DEG_USAAGE"
		If M->DEG_USAAGE == "1" .And. M->DEG_AUTPAG == "1"
			Help("",1,"TMSAE6010") //-- "No  possvel que o uso do agendamento e a autorizao de pagamento estejam ativos ao mesmo tempo."
			lRet := .F.
		EndIf
	
	ElseIf cCampo $ "M->DEG_AUTPAG"
		If M->DEG_AUTPAG == "1" .And. M->DEG_USAAGE == "1"
			Help("",1,"TMSAE6010") //-- "No  possvel que o uso do agendamento e a autorizao de pagamento estejam ativos ao mesmo tempo."
			lRet := .F.
		EndIf
	
	EndIf
EndIf

Return( lRet )

/*


Ŀ
Funo    TMSAE60Ope Autor Vitor Raspa             Data  12.Jun.06
Ĵ
Descrio  Operacoes da Operadora                                     
Ĵ
Sintaxe   TMSAE60Ope( ExpN1 )                                         
Ĵ
ParametrosExpN1 - Opcao Selecionada                                   
Ĵ
Retorno   .T.                                                         
Ĵ
 Uso      TMSAE60                                                     
ٱ


*/
Function TMSAE60Ope(nOpc)
Local oDlg
Local oGetDEJ
Local nAux := 0
Local lOk  := .F.

If  M->DEG_CODOPE <> "02" //Projeto Pamcard
	//Ŀ
	// Salva as variaveis utilizadas na GetDados Anterior.    
	//
	SaveInter()

	n       := 1
	aHeader := aClone(aHeaderDEJ)
	aCols   := {}

	If Len(aColsDEJ)  > 0
		aCols	:= aClone(aColsDEJ)
		Aeval( aCols, {|x| x[Len(x)] := .F. }) // Os Itens do aCols	nao poderao estar deletados 
	Else
		//Ŀ
		// Faz a montagem de uma linha em branco no aCols.              
		//
		AAdd(aCols,Array(Len(aHeader)+1))
		For nAux := 1 to Len(aHeader)
			aCols[1][nAux] := CriaVar(aHeader[nAux][2])
			aCols[1][Len(aHeader)+1] := .F.
		Next

		GDFieldPut('DEJ_ITEM',StrZero(1,Len(DEJ->DEJ_ITEM)),1)	
	EndIf

	DEFINE MSDIALOG oDlg FROM 94 ,104 TO 310,650 TITLE STR0008 Of oMainWnd PIXEL //"Operacoes do Gerenciador de Frotas"
	oGetDEJ := MSGetDados():New(30,2,105,270,nOpc,'TAE60OpLOk','AllwaysTrue()','+DEJ_ITEM',;
											IIf(nOpc == 3 .Or. nOpc == 4,.T.,Nil))

	@ 18,03 SAY STR0011 Of oDlg PIXEL SIZE 80 ,9 //"Gerenciador de Frotas (Operador):"
	@ 18,90 SAY M->DEG_CODOPE + '/' + M->DEG_NOMOPE Of oDlg PIXEL SIZE 100,9

	//-- Esta Funcao corrige uma falha da GetDados ao mostrar os itens deletados
	TMSA011AjuMin(aColsDEJ, aCols)

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| If(oGetDEJ:TudoOk(), ( lOk := .T., oDlg:End()), (lOk := .F.))},;
													{|| oDlg:End()} ) CENTERED

	If lOk
		aColsDEJ := aClone(aCols)
	EndIf

	//Ŀ
	// Restaura as Variaveis da GetDados Anterior                   
	//
	RestInter()
Else
	Help('',1,'TMSAE6007') //Opo no disponvel para","essa operadora."
EndIf

Return .T.

/*


Ŀ
Funo    TAE60OpLOk Autor  Vitor Raspa            Data  09.Jun.06
Ĵ
Descrio  Validacoes da linha da GetDados                            
Ĵ
Sintaxe    TAE60OpLOk()                                               
Ĵ
Parametros                                                            
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                    
ٱ


*/
Function TAE60OpLOk()
Local lRet      := .T.
Local aCpoCheck := {'DEJ_SERTMS','DEJ_TIPTRA','DEJ_OPERAC'}

DbSelectArea('DEJ')

//-- Nao avalia linhas deletadas.
If M->DEG_CODOPE == "01" //-- Repom
	If !GDdeleted(n) .And. (lRet:=MaCheckCols(aHeader,aCols,n))
		//-- Analisa se ha itens duplicados na GetDados.
		lRet := GDCheckKey(aCpoCheck,4)
	EndIf
EndIf

Return(lRet)

/*


Ŀ
Funo    TMSAE60DEJ Autor  Vitor Raspa            Data  12.Jun.06
Ĵ
Descrio  Atualiza o aCols e aHeader do DEJ (Operacoes da Operadora) 
Ĵ
Retorno    .T.                                                        
Ĵ
Uso        TMSAE60                                                    
ٱ


*/
Function TMSAE60DEJ( nOpc )
Local nAux 		:= 0
Local cTmsRepom := SuperGetMV( 'MV_VSREPOM',, '1' )

//Ŀ
// Montagem do aHeader                                          
//
aHeaderDEJ := ApBuildHeader("DEJ", {"DEJ_CODOPE", "DEJ_NOMOPE"})

//-- Tratamento para as Operacoes da Operadora
If nOpc <> 3 .And. DEG->DEG_CODOPE == "01" //Projeto Pamcard
	DEJ->(DbSetOrder(1))
	DEJ->(MsSeek(xFilial('DEJ')+DEG->DEG_CODOPE))
	While DEJ->(!Eof() .And. DEJ_FILIAL+DEJ_CODOPE == xFilial('DEJ') + DEG->DEG_CODOPE)
		Aadd(aColsDEJ,Array(Len(aHeaderDEJ)+1))
		For nAux := 1 To Len(aHeaderDEJ)
			If	aHeaderDEJ[nAux,10] != "V"
				aColsDEJ[Len(aColsDEJ),nAux] := DEJ->(FieldGet(FieldPos(aHeaderDEJ[nAux,2])))
			Else
				aColsDEJ[Len(aColsDEJ),nAux] := CriaVar(aHeaderDEJ[nAux,2])
			EndIf
		Next

		aColsDEJ[Len(aColsDEJ),Len(aHeaderDEJ)+1] := .F.

		DEJ->(dbSkip())
	EndDo

	For nAux := 1 To Len(aColsDEJ)
		If Empty(aOperac)
			TMSOper(.F., M->DEG_CODOPE)
		EndIf

		If !Empty(aOperac)
			If AScan(aOperac,{|x| AllTrim(x[1]) == AllTrim(aColsDEJ[nAux, AScan(aHeaderDEJ,{|x| AllTrim(x[2]) == "DEJ_OPERAC"})])}) > 0
				If AScan(aHeaderDEJ, {|x| AllTrim(x[2]) == "DEJ_DESOPE"}) > 0
					aColsDEJ[nAux,AScan(aHeaderDEJ,{|x| AllTrim(x[2]) == "DEJ_DESOPE"})] := aOperac[ AScan(aOperac,{|x| AllTrim(x[1]) == AllTrim(aColsDEJ[nAux,AScan(aHeaderDEJ,{|x| AllTrim(x[2]) == "DEJ_OPERAC"})])}),2]
				EndIf
			EndIf
		Else
			If AllTrim(cTmsRepom) <> '2.2'
				Help('',1,'TMSAE6004') //-- "Problemas na Comunicao com a Operadora impedem a Validao do Campo!"
			EndIf
		EndIf
	Next
EndIf

Return(.T.)

/*


Ŀ
Funo    TMSAE60Mun  Autor Vitor Raspa            Data  12.Jun.06
Ĵ
Descrio  Muncipios da Operadora                                     
Ĵ
Sintaxe   TMSAE60Oper( ExpN1 )                                        
Ĵ
ParametrosExpN1 - Opcao Selecionada                                   
Ĵ
Retorno   .T.                                                         
Ĵ
 Uso      TMSAE60                                                     
ٱ

*/
Function TMSAE60Mun(nOpc)
Local oDlg
Local oGetDEI
Local nAux
Local lOk := .F.

If M->DEG_CODOPE <> "02" //Projeto Pamcard
	//Ŀ
	// Salva as variaveis utilizadas na GetDados Anterior.    
	//
	SaveInter()

	n       := 1
	aHeader := aClone(aHeaderDEI)
	aCols	  := {}

	If Len(aColsDEI)  > 0
		aCols	:= aClone(aColsDEI)
		Aeval( aCols, {|x| x[Len(x)] := .F. }) // Os Itens do aCols	nao poderao estar deletados 
	Else
		//Ŀ
		// Faz a montagem de uma linha em branco no aCols.              
		//
		AAdd(aCols,Array(Len(aHeader)+1))
		For nAux := 1 to Len(aHeader)
			aCols[1][nAux] := CriaVar(aHeader[nAux][2])
			aCols[1][Len(aHeader)+1] := .F.
		Next

		GDFieldPut('DEI_ITEM',StrZero(1,Len(DEI->DEI_ITEM)),1)	
	EndIf

	DEFINE MSDIALOG oDlg FROM 94 ,104 TO 310,650 TITLE STR0010 Of oMainWnd PIXEL //"Municipios X Operadores"

	oGetDEI := MSGetDados():New(30,2,105,270,nOpc,'TAE60MuLOk','AllwaysTrue()','+DEI_ITEM',;
											IIf(nOpc == 3 .Or. nOpc == 4,.T.,Nil))

	@ 18,03 SAY STR0011 Of oDlg PIXEL SIZE 80 ,9 //"Gerenciador de Frotas (Operador):"
	@ 18,90 SAY M->DEG_CODOPE + '/' + M->DEG_NOMOPE Of oDlg PIXEL SIZE 100,9

	//-- Esta Funcao corrige uma falha da GetDados ao mostrar os itens deletados
	TMSA011AjuMin(aColsDEI, aCols)

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| If( oGetDEI:TudoOk(),( lOk := .T., oDlg:End()),(lOk := .F.))},;
													{|| oDlg:End()} ) CENTERED

	If lOk
		aColsDEI := aClone(aCols)
	EndIf

	//Ŀ
	// Restaura as Variaveis da GetDados Anterior                   
	//
	RestInter()

Else
	Help('',1,'TMSAE6007')   //Opo no disponvel para","essa operadora."
EndIf

Return .T.

/*


Ŀ
Funo    TMSAE60DEI Autor  Vitor Raspa            Data  12.Jun.06
Ĵ
Descrio  Atualiza o aCols e aHeader do DEI (Municipios da Operadora)
Ĵ
Retorno    .T.                                                        
Ĵ
Uso        TMSAE60                                                    
ٱ


*/
Static Function TMSAE60DEI(nOpc)
Local nAux

//Ŀ
// Montagem do aHeader                                          
//
aHeaderDEI := ApBuildHeader("DEI", {"DEI_CODOPE", "DEI_NOMOPE"})

//-- Tratamento para as Operacoes da Operadora
If nOpc <> 3 .And. DEG->DEG_CODOPE <> "02" //Projeto Pamcard
	DEI->(DbSetOrder(1))
	DEI->(MsSeek(xFilial('DEI')+DEG->DEG_CODOPE))
	While DEI->(DEI_FILIAL+DEI_CODOPE) == xFilial('DEI') + DEG->DEG_CODOPE
		Aadd(aColsDEI,Array(Len(aHeaderDEI)+1))
		For nAux := 1 To Len(aHeaderDEI)
			If	aHeaderDEI[nAux,10] != "V"
				aColsDEI[Len(aColsDEI),nAux] := DEI->(FieldGet(FieldPos(aHeaderDEI[nAux,2])))
			Else
				aColsDEI[Len(aColsDEI),nAux] := CriaVar(aHeaderDEI[nAux,2])
			EndIf
		Next

		aColsDEI[Len(aColsDEI),Len(aHeaderDEI)+1] := .F.

		DEI->(dbSkip())
	EndDo
EndIf

Return(.T.)

/*


Ŀ
Funo    TAE60MuLOk Autor  Vitor Raspa            Data  09.Jun.06
Ĵ
Descrio  Validacoes da linha da GetDados                            
Ĵ
Sintaxe    TAE60MuLOk()                                               
Ĵ
Parametros                                                            
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                    
ٱ


*/
Function TAE60MuLOk()
Local lRet      := .T.
Local aCpoCheck := {'DEI_CDRORI'}

//-- Nao avalia linhas deletadas.
If !GDdeleted(n) .And. (lRet:=MaCheckCols(aHeader,aCols,n))
	//-- Analisa se ha itens duplicados na GetDados.
	lRet := GDCheckKey(aCpoCheck,4)
EndIf

Return(lRet)

/*


Ŀ
Funo     TMSOper   Autor  Vitor Raspa            Data  12.Jun.06
Ĵ
Descrio  Consulta F3( DEJ ) para visualizar as Operacoes da Operado_
           ra (Gerenciador de Frotas)                                 
Ĵ
Retorno    Logico                                                     
Ĵ
Uso        TMSAE60                                                    
ٱ


*/
Function TMSOper(lF3, cCodOpe)
Local lRet := .T.
Local cTitulo
Local nTMSItem

Default lF3     := .T.
Default cCodOpe := M->DEG_CODOPE

If Empty( aOperac )
	If TmsNewOper()
		If !lRestRepom
			MsgRun( STR0013 , STR0012 , {|| CursorWait(), aOperac := TMSE60BOpe(cCodOpe,@lRet), CursorArrow()}) //"Realizando comunicao com a Operadora..." ### "Aguarde..."
		Else
			MsgRun( STR0013 , STR0012 , {|| CursorWait(), aOperac := TMSE60BGet(cCodOpe,@lRet), CursorArrow()}) //"Realizando comunicao com a Operadora..." ### "Aguarde..."
		EndIf
	Else
		If !lRestRepom
			MsgRun( STR0013 , STR0012 , {|| CursorWait(), aOperac := F3TMSOper(cCodOpe), CursorArrow()}) //"Realizando comunicao com a Operadora..." ### "Aguarde..."
		Else
			MsgRun( STR0013 , STR0012 , {|| CursorWait(), aOperac := F3GETOper(cCodOpe), CursorArrow()}) //"Realizando comunicao com a Operadora..." ### "Aguarde..."
		EndIf
	EndIf
EndIf

If !Empty( aOperac ) .And. lF3
	//-- Apresenta a tela para selecao do item.
	cTitulo		:= Posicione('SX3', 2, 'DEG_CODOPE', 'X3Titulo()')
	nTMSItem	:= TMSF3Array( {STR0014,STR0015}, aOperac, cTitulo ) //"Codigo"###"Descricao"
	If	nTMSItem > 0
		//-- VAR_IXB eh utilizada como retorno da consulta F3 DEJ.
		VAR_IXB := aOperac[ nTMSItem, 1 ]
	EndIf
EndIf

Return lRet

/*


Ŀ
Funo     F3TMSOper Autor  Vitor Raspa            Data  12.Jun.06
Ĵ
Descrio  Acessa o WebService para obter as operacoes da Operadora   
Ĵ
Retorno    Array contendo o Codigo e Descricao da Operacao            
Ĵ
Uso        TMSAE60                                                    
ٱ


*/
Static Function F3TMSOper( cCodOpe )
Local oObj
Local cError   := ""
Local cWarning := ""
Local oXML
Local nAux
Local aMsgErr  := {}
Local lTMSXML  := GetMV( 'MV_TMSXML',, .F. )
Local lRet     := .T.

If cCodOpe == '01' .And. AllTrim( SuperGetMV( 'MV_VSREPOM',, '1' ) ) <> '2.2'
	//Ŀ
	//PREPARACAO PARA CONECTAR AO WS - REPOM
	//
	oObj := WSIntegracao():New()
	oObj:cStrCliente           := AllTrim(M->DEG_IDOPE)
	oObj:cstrAssinaturaDigital := AllTrim(M->DEG_CODACE)
	oObj:_URL                  := M->DEG_URLWS //-- Seta a URL para acesso aos servicos da Operadora

	If oObj:ConsultaOperacoes()
		If oObj:lConsultaOperacoesResult

			//-- Remove acentos e caracteres especiais
			oObj:cStrXMLOut := TMSNoAcento( oObj:cStrXMLOut )

			//-- Gera XML em disco
			If lTMSXML
				TMSLogXML( oObj:cStrXMLOut, 'ConsultaOperacoesResult.XML' )
			EndIf

			//Gera o Objeto XML ref. ao script
			oXML := XmlParser( oObj:cStrXMLOut, "_", @cError, @cWarning )

			If XMLChildCount( oXML:_Operacoes ) > 0
				If ValType( oXML:_Operacoes:_Operacao ) == 'A'
					For nAux := 1 To Len(oXML:_OPERACOES:_OPERACAO)
						AAdd(aOperac, { oXML:_OPERACOES:_OPERACAO[nAux]:_OPERACAO_CODIGO:Text,;
										 oXML:_OPERACOES:_OPERACAO[nAux]:_OPERACAO_DESCRICAO:Text } )
					Next
					ASort( aOperac,,, {|x,y| Val(x[1]) < Val(y[1])} )
				Else
					AAdd(aOperac, { oXML:_OPERACOES:_OPERACAO:_OPERACAO_CODIGO:Text,;
									 oXML:_OPERACOES:_OPERACAO:_OPERACAO_DESCRICAO:Text } )
				EndIf
			EndIf
		Else
			aMsgErr := TMSErrOper(cCodOpe, oObj:cStrXMLErr, '1')
			lRet := .F.
		EndIf
	Else
		aMsgErr := TMSErrOper(cCodOpe,, '2')
		lRet := .F.
	EndIf
EndIf

//-- Trata os erros ocorridos na comunicacao com a Operadora
If !lRet .And. !Empty(aMsgErr)
	TmsMsgErr( aMsgErr )
EndIf

Return(aOperac)

/*/


Ŀ
Programa  MenuDef    Autor  Marco Bianchi          Data 01/09/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
              1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static Function MenuDef()

Private aRotina	:= {	{ STR0002, 'AxPesqui',		0, 1, 0, .F. },; //'Pesquisar'
						{ STR0003, 'TMSAE60Mnt',	0, 2, 0, NIL },; //'Visualizar'
						{ STR0004, 'TMSAE60Mnt',	0, 3, 0, NIL },; //'Incluir'
						{ STR0005, 'TMSAE60Mnt',	0, 4, 0, NIL },; //'Alterar'
						{ STR0006, 'TMSAE60Mnt',	0, 5, 0, NIL } } //'Excluir'

If FindFunction("TMS15TstR")
	AAdd( aRotina, { STR0023, 'TMS15TstR', 0, 6, 0, NIL } ) //"Teste Comunicao"
EndIf

If ExistBlock("TME60MNU")
	ExecBlock("TME60MNU",.F.,.F.)
EndIf

Return(aRotina)


/*/{Protheus.doc} TMAE60CCer
Funo que converte o certificado em 3 arquivos .PEM, sendo eles:
Certificado de Autorizao, Certificado de Cliente e Chave Privada.90

@param cArquivo, Caminho do arquivo .PFX do certificado
@param cPsw, Senha de autorizao do certificado
@param cArqCA, Caminho do arquivo CA que ser criado
@param cArqCERT, Caminho do arquivo CERT que ser criado
@param cArqKEY, Caminho do arquivo KEY que ser criado 
@param cRet, Mensagem de retorno, em caso de erro

@author Leandro Paulino	
@since 02/04/2018
@version 12.1.17
/*/
Static Function TMAE60CCer( cCamArq, cPsw, cArqCERT,cArqKey, cRet )	

	Local cError 		:= ""
	Local cDirectory 	:= GetSrvProfString("Startpath","")
	Local aChvExt		:= {}
	Local nTamArq		:= 0
	Local cArquivo 		:= ""
	Local lRet			:= .T.	
	Local cBarra		:= If(IsSrvUnix(), "/", "\")
	Local aFilial 		:= FWArrFilAtu(cEmpAnt, cFilAnt)
	Local cContent      := ""
	Local cArqCA 	    := aFilial[18]+"_certif_ca"
	Local cArqCLCERT 	:= aFilial[18]+"_certif_cl"

	Default cCamArq 	:= ""	
	Default cPsw 		:= ""	
	Default cArqCERT 	:= aFilial[18]+"_certif_cert"
	Default cArqKEY 	:= aFilial[18]+"_certif_key"
	Default cRet 		:= ""
	
	cCamArq	:= AllTrim( cCamArq )
	
	If !Empty(cCamArq)

		If IsSrvUnix()
			If At("\", cCamArq) > 0
				cBarra := "\"
			EndIf 
		EndIf 
	
		aChvExt 	:= Str2Arr(Upper(cCamArq), cBarra)  
		nTamArq 	:= Len(aChvExt[Len(aChvExt)])
		cArquivo	:= Lower(AllTrim(aChvExt[Len(aChvExt)]))
		
		cPsw 		:= AllTrim( cPsw )
		
		//Garante que os arquivos sero gerados com a extenso correta
		If Right( Upper( cArqCERT ), 4 ) != ".PEM"			
			cArqCERT += ".pem"
		Endif
		If Right( Upper( cArqCLCERT ), 4 ) != ".PEM"			
			cArqCLCERT += ".pem"
		Endif
		If Right( Upper( cArqKEY ), 4 ) != ".PEM"
			cArqKEY += ".pem"
		EndIf
		If Right( Upper( cArqCA ), 4 ) != ".PEM"
			cArqCA += ".pem"
		EndIf
		
		If IsSrvUnix()
			Copy File &(cCamArq) To &(cDirectory+ "/"+ cArquivo)
		Else 
			Copy File &(cCamArq) To &(cDirectory+cArquivo)
		EndIf 

		//Gera o arquivo de Chave Privada
		If ! PFXCA2PEM( cArquivo, cArqCA, @cError, cPsw )
			cRet := OemToAnsi(STR0020) + cError //"Erro ao extrair a chave privada. "
			lRet := .F.
		Endif

		//Gera o arquivo de Certificado de Cliente
		If PFXCert2PEM( cArquivo, cArqCLCERT, @cError, cPsw )
			//Gera o arquivo de Chave Privada
			If ! PFXKey2PEM( cArquivo, cArqKEY, @cError, cPsw )
				cRet := OemToAnsi(STR0020) + cError //"Erro ao extrair a chave privada. "
				lRet := .F.
			Endif
		Else
			cRet := OemToAnsi(STR0021) + cError //"Erro ao extrair o Certificado de Cliente. "
			lRet := .F.
		Endif		
	EndIf
	
	    // l certificados do cliente + CA 
    cContent := MemoRead( cArqCLCERT )
    cContent += MemoRead( cArqCA )

    // grava novo certificado no formato PEM contendo certificados do cliente + CA
    MemoWrite( cArqCERT , cContent )


Return lRet

//-----------------------------------------------------------------
/*/{Protheus.doc} F3GETOper()
Consulta Operao na Repom - Versao 2.2  (GET /Operation)
@author Katia
@since 20/11/2020
@version 12.1.31
/*/
//--------------------------------------------------------------------
Static Function F3GETOper( cCodOpe )
Local aMsgErr  := {}
Local lRet     := .T.
Local aOperac  := {}
Local aRet     := {}
Local nX       := 0

If cCodOpe == '01'	
	aRet:= TM15GetOpe()  

	For nX:= 1 To Len(aRet)
		AAdd(aOperac,{aRet[nx][1],aRet[nx][2]})
	Next nX

	If Len(aOperac) == 0
		aMsgErr := TMSErrOper(cCodOpe,'', '1')
		lRet := .F.
	EndIf

EndIf

//-- Trata os erros ocorridos na comunicacao com a Operadora
If !lRet .And. !Empty(aMsgErr)
	TmsMsgErr( aMsgErr )
EndIf

FWFreeArray(aRet)
Return(aOperac)

//-----------------------------------------------------------------
/*/{Protheus.doc} 	TMSAE60Whe()
Validacoes p/ edicao do campo (X3_WHEN)
@author Katia
@since 24/11/2020
@version 12.1.31
/*/
//--------------------------------------------------------------------
Function TMSAE60Whe(cCampo)
Local lRet     := .F.

Default cCampo := ReadVar()

If cCampo $ 'DEG_TMPESP|DEG_REPQUI|DEG_GERCTC' 
	If lRestRepom .And. M->DEG_CODOPE == "01"
		lRet:= .T.
	EndIf
EndIf

Return lRet

