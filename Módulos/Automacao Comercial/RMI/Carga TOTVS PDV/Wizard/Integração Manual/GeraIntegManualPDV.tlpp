#INCLUDE "PROTHEUS.CH"
#INCLUDE "tlpp-core.th"
#INCLUDE "msobject.ch"
#INCLUDE "RMIENVIAOBJ.CH"
#INCLUDE "DBSTRUCT.CH"
#INCLUDE "TRYEXCEPTION.CH"


Class GeraIntegManualPDV From RmiEnvTotvsPdv

    Data cTipoInteg                     as Character
    Data oJInfoIntegManual              as Object
    Data cCamposQuery                   as Character
    Data oQuery                         as Object
    Data aJPontoInteg                   as Array
    Data aJFiliais                      as Array
    Data cTabMiq                        as Character
    Data cPorcesso                      as Character
    Data aJParamInteg                   as Array
    Data aJTabelasSX5                   as Array
    Data cFilIntegQry                   as Character
    Data cAliasQryIntegTab              as Character
    Data cAliasIntegManual              as Character
    Data aMHQUUID                       as Array
    Data nRange                         as Numeric
    Data cUltRecno                      as Character
    Data lContinua                      as Logical
    
    Public Method New()                 as Object
    Public Method Consulta()            as Variant
    Public Method Processa()            as Variant
    Public Method SetaProcesso()        as Variant
    Public Method SetupTipoInteg()      as Variant
    Public Method IntegraParam()        as Variant
    Public Method IntegraSX5()          as Variant

    Private Method Grava()              as Logical
    Private Method getMiq()             as Variant
    Private Method FiltraParam()        as Variant
    Private Method FiltraSX5()          as Variant
    Private Method MontaJsonPubli()     as Object
    Private Method PublicaIntegManual() as Variant
    Private Method DistribuiIntegManual() as Variant
    Private Method EnviaIntegManual()   as Variant
    Private Method GeraJsonReg()        as Character
    Private Method ValidReg()           as Logical
    Private Method ValidFilPtInteg()    as Logical

EndClass

/*/{Protheus.doc} New
Metodo construtor da classe
@author joao.marcos
@since  22/03/2024
/*/
Method New(cAssinante as Character, cProcesso as Character, oJRetWiz as Json, nRange as Numeric) as Object Class GeraIntegManualPDV

    Default nRange := 5000
   
    Self:cTipoInteg         := ""
    Self:cFilIntegQry       := ""  
    Self:cCamposQuery       := ""    
    Self:oQuery             := Nil
    Self:aJPontoInteg       := {}
    Self:aJParamInteg       := {}
    Self:cProcesso          := cProcesso
    Self:cAssinante         := cAssinante
    Self:cTabMiq            := ""
    Self:aMHQUUID           := {}
    Self:cAliasIntegManual  := ""
    Self:nRange             := nRange
    Self:cUltRecno          := "0"
    Self:lContinua          := .T.

    Self:SetupTipoInteg(oJRetWiz)
    _Super:New(cProcesso,cAssinante) 
    (Self:cTabMiq)->(dbCloseArea())
Return Self

/*/{Protheus.doc} SetupTipoInteg
Faz o setup inicial para cada do tipo de Integração
@author joao.marcos
@since 01/04/2024
@version 1.0
@param oJRetWiz, object, Retorno do Wizard
/*/
Method SetupTipoInteg(oJRetWiz as Json) Class GeraIntegManualPDV
Local nX    := 0 as Numeric 

Self:cTipoInteg := oJRetWiz['CodigoRetornoWiz']
Self:aJFiliais  := oJRetWiz['Filiais']

For nX := 1 To Len(Self:aJFiliais)
    Self:cFilIntegQry += "'" + Self:aJFiliais[nX] + "',"
Next 

Self:cFilIntegQry := SubStr(Self:cFilIntegQry,1,Len(Self:cFilIntegQry)-1)

If oJRetWiz['CodigoRetornoWiz'] == "1" // Integração de Grupo de Tabelas
    Self:aJPontoInteg       := oJRetWiz['PontoInteg'] 
ElseIf oJRetWiz['CodigoRetornoWiz'] == "2" // CIntegraçãoarga de Parametros
    Self:aJParamInteg       := oJRetWiz['Parametros']
    Self:cProcesso          := "999SX6"
ElseIf oJRetWiz['CodigoRetornoWiz'] == "3" // Integração SX5
    Self:aJTabelasSX5       := oJRetWiz['TabelasSX5']
    Self:cProcesso          := "999SX5"  
EndIf
    
Return

/*/{Protheus.doc} Processa
Metodo que ira controlar o processamento dos envios
@author joao.marcos
@since  26/03/2024
/*/
Method Processa() Class GeraIntegManualPDV

LjGrvLog(" GeraIntegManualPDV ", "Method Processa | Inicio | ", FWTimeStamp(2) )

LjGrvLog(" GeraIntegManualPDV ", "Method Processa | Chama metodo SetaProcesso | ", FWTimeStamp(2) )
self:SetaProcesso( self:cProcesso )
//Carrega a distribuições que devem ser enviadas
LjGrvLog(" GeraIntegManualPDV ", "Method Processa | Chama metodo Consulta | ", FWTimeStamp(2) )

While Self:lContinua
    self:Consulta()

    LjGrvLog(" GeraIntegManualPDV ", "Method Processa | Apos executar a query do metodo Consulta ", Empty(self:cAliasQryIntegTab))

    If !Empty(self:cAliasQryIntegTab)

        (self:cAliasQryIntegTab)->(dbGoTop())

        If !(self:cAliasQryIntegTab)->( EOF() )            

            While !(self:cAliasQryIntegTab)->( Eof() )

                //Posiciona na publicação
                MHQ->( DbSetOrder(1) )  //MHQ_FILIAL + MHQ_ORIGEM + MHQ_CPROCE
                MHQ->( DbGoTo( (self:cAliasQryIntegTab)->RECNO_PUB ) )                                     
                
                If !MHQ->( EOF() )

                    self:Grava()                        

                EndIf

                Self:cUltRecno := Alltrim(STR((self:cAliasQryIntegTab)->RECNO_PUB))
                (self:cAliasQryIntegTab)->( DbSkip() )

            EndDo

        EndIf
        
        (self:cAliasQryIntegTab)->( DbCloseArea() )

    EndIf
EndDo

self:Destroi()

LjGrvLog(" GeraIntegManualPDV ", "Method Processa | Fim | ", FWTimeStamp(2) )

Return Nil


/*/{Protheus.doc} Consulta
Metodo que efetua consulta das ultimas distribuições a enviar
1 - Grupo de Tabelas
2 - Parametros
@author joao.marcos
@since  25/03/2024
/*/
Method Consulta() Class GeraIntegManualPDV

    Local nContParam := 0

    LjGrvLog(" GeraIntegManualPDV ", "Method Consulta() Inicio ", FWTimeStamp(2) )

    Self:cCamposQuery := " MHQ1.MHQ_CPROCE, MHQ1.MHQ_CHVUNI, "  + CRLF
    Self:cCamposQuery += " MHQ1.MHQ_MENSAG, MHQ1.MHQ_DATPRO, "  + CRLF
    Self:cCamposQuery += " MHQ1.MHQ_HORPRO, MHQ1.MHQ_UUID, "    + CRLF
    Self:cCamposQuery += " MHQ1.R_E_C_N_O_ AS RECNO_PUB, "      + CRLF
    Self:cCamposQuery += " MHQ1.MHQ_IDEXT "

    self:cQuery := " SELECT TOP " + Str(Self:nRange) + Self:cCamposQuery + " "                                                 + CRLF
    self:cQuery += " FROM " + RetSqlName("MHQ") + " MHQ1 "                                              + CRLF
    self:cQuery += " INNER JOIN "                                                                       + CRLF
    self:cQuery += " (SELECT MAX(MHQ.MHQ_DATPRO + ' ' + MHQ.MHQ_HORPRO) AS MHQ_ULTIMO, MHQ_CHVUNI "     + CRLF
    self:cQuery += " FROM " + RetSqlName("MHQ") + " MHQ "                                               + CRLF
    self:cQuery += " WHERE MHQ.MHQ_FILIAL = '" + xFilial("MHQ") + "' "                                  + CRLF
    self:cQuery += " AND SUBSTRING(MHQ.MHQ_CPROCE,4,6) = ? "                                            + CRLF  // #1
    self:cQuery += " AND MHQ.D_E_L_E_T_ = ' ' "                                                         + CRLF
    self:cQuery += " GROUP BY MHQ.MHQ_CHVUNI) MHQ2 "                                                    + CRLF
    self:cQuery += " ON MHQ1.MHQ_DATPRO + ' ' + MHQ1.MHQ_HORPRO = MHQ2.MHQ_ULTIMO "                     + CRLF
    self:cQuery += " AND MHQ1.MHQ_CHVUNI = MHQ2.MHQ_CHVUNI "                                            + CRLF
    self:cQuery += " WHERE MHQ1.MHQ_FILIAL = '" + xFilial("MHQ") + "' "                                 + CRLF
    self:cQuery += " AND SUBSTRING(MHQ1.MHQ_CPROCE,4,6) = ? "                                           + CRLF  // #2
    self:cQuery += " AND MHQ1.R_E_C_N_O_ > ? "                                                          + CRLF  // 3
    self:cQuery += " AND MHQ1.D_E_L_E_T_ = ' ' "                                                        + CRLF
    self:cQuery += " ORDER BY MHQ1.R_E_C_N_O_ "
    //self:cQuery += " ORDER BY MHQ1.MHQ_CPROCE, MHQ1.MHQ_DATGER, MHQ1.MHQ_HORGER "

    self:cQuery := ChangeQuery(self:cQuery)
    Self:oQuery := FwExecStatement():New(self:cQuery)
    nContParam++

    Self:oQuery:SetString(nContParam++, SubStr(AllTrim(Self:cProcesso),4,6) )   // #1
    Self:oQuery:SetString(nContParam++, SubStr(AllTrim(Self:cProcesso),4,6) )   // #2
    Self:oQuery:SetString(nContParam++, AllTrim(Self:cUltRecno) )               // #3

    self:cAliasQryIntegTab := Self:oQuery:OpenAlias()

    If (self:cAliasQryIntegTab)->(EOF())
        Self:lContinua := .F.
    Else
        Self:lContinua := .T.
    EndIf

    LjGrvLog(" GeraIntegManualPDV ", "Method Consulta() cQuery => "    , self:cQuery )
    LjGrvLog(" GeraIntegManualPDV ", "Method Consulta() Campos => "    , self:cCamposQuery )
    LjGrvLog(" GeraIntegManualPDV ", "Method Consulta() Processo => "  , self:cPorcesso )

    LjGrvLog(" GeraIntegManualPDV ", "Method Consulta() Fim ", FWTimeStamp(2) )

Return Nil

/*/{Protheus.doc} SetaProcesso
Metodo responsavel por carregar as informações referente ao processo que será enviado
@author joao.marcos
@since  26/03/2024
@param cProcesso, character, Codigo do Processo
/*/
Method SetaProcesso(cProcesso) Class GeraIntegManualPDV
    
    //Limpa configurações anteriores
    self:cProcesso  := ""
    self:cLayoutEnv := ""
    self:cTabela    := ""
    
    MHP->( DbSetOrder(1) )  //MHP_FILIAL + MHP_CASSIN + MHP_CPROCE + MHP_TIPO
    If MHP->( DbSeek( xFilial("MHP") + Padr(self:cAssinante, TamSx3("MHP_CASSIN")[1] ) + Padr(cProcesso, TamSx3("MHP_CPROCE")[1] ) + self:cTipo ) ) .And. MHP->MHP_ATIVO == "1"

        self:cProcesso  := AllTrim(MHP->MHP_CPROCE)
        self:cLayoutEnv := AllTrim(MHP->MHP_LAYENV)
        self:cTabela    := Posicione("MHN", 1, xFilial("MHN") + self:cProcesso, "MHN_TABELA")     //MHN_FILIAL + MHN_COD
        self:lSucesso   := .T. 
    EndIf

Return Nil

/*/{Protheus.doc} getMiq
Consulta os ponto de integraçao selecionados
@author joao.marcos
@since  26/03/2024
/*/
Method getMiq() Class GeraIntegManualPDV

Local cQuery            := "" 
Local cPontoInteg       := ""
Local nX                := 0

LjGrvLog("GeraIntegManualPDV", "Method getMiq | Inicio ", FWTimeStamp(2) )

If !Empty(Self:aJPontoInteg)
    For nX := 1 To Len(Self:aJPontoInteg)
        cPontoInteg += "'" + Self:aJPontoInteg[nX] + "',"
    Next

    cPontoInteg := SubStr(cPontoInteg,1,Len(cPontoInteg)-1)
EndIf

LjGrvLog("GeraIntegManualPDV", "Method getMiq | Pontos de Integraçao ", cPontoInteg )

LjGrvLog("GeraIntegManualPDV", "Method getMiq | Filiais dos Pontos de Integraçao ", Self:cFilIntegQry )

self:cTabMiq := GetNextAlias()

cQuery := "SELECT R_E_C_N_O_ REC"                               + CRLF
cQuery += " FROM " + RetSqlName("MIQ") + " "                    + CRLF
cQuery += " WHERE MIQ_FILIAL = '" + xFilial("MIQ") + "' "       + CRLF
If !Empty(cPontoInteg)
    cQuery += " AND MIQ_COD IN( " + cPontoInteg + "  ) "            + CRLF
EndIf
cQuery += " AND MIQ_FILPC IN( " + Self:cFilIntegQry + "  ) "    + CRLF
cQuery += " AND D_E_L_E_T_ = ' ' "                              + CRLF

cQuery := ChangeQuery(cQuery)
DbUseArea(.T., "TOPCONN", TcGenQry( , , cQuery), self:cTabMiq, .T., .F.)

LjGrvLog("GeraIntegManualPDV", "Method getMiq | Fim ", FWTimeStamp(2) )

Return

/*/{Protheus.doc} IntegraParam
Dispara os metodos para geraçao da integraçao dos parametros
@author joao.marcos
@since 01/04/2024
@version 1.0
/*/
Method IntegraParam() Class GeraIntegManualPDV
LjGrvLog(" GeraIntegManualPDV ", "Method IntegraParam | Inicio | ", FWTimeStamp(2) )

Self:FiltraParam()
Self:PublicaIntegManual("SX6")
Self:EnviaIntegManual()

LjGrvLog(" GeraIntegManualPDV ", "Method IntegraParam | Fim | ", FWTimeStamp(2) )
Return

/*/{Protheus.doc} FiltraParam
Efetua a Query filtrando os parâmetros da Integração
@author joao.marcos
@since 01/04/2024
@version 1.0
/*/
Method FiltraParam() Class GeraIntegManualPDV
Local cQuery        := ""   as Character
Local oQuery        := Nil  as Object
Local cParametros   := ""   as Character
Local nX            := 0    as Numeric

Self:cFilIntegQry += ",''"

For nX := 1 To Len(Self:aJParamInteg)
    cParametros += "'" + Self:aJParamInteg[nX] + "',"
Next 

cParametros := SubStr(cParametros,1,Len(cParametros)-1)

cQuery += " SELECT X6_FIL AS TABFILIAL, X6_FIL + X6_VAR AS CHAVE, " + CRLF
cQuery += " R_E_C_N_O_ AS TABRECNO"                                 + CRLF
cQuery += " FROM " + RetSQLName("SX6") + " "                        + CRLF
cQuery += " WHERE X6_FIL IN ( " + Self:cFilIntegQry + ") "          + CRLF
cQuery += " AND X6_VAR IN (" + cParametros + ") "                   + CRLF

LjGrvLog(" GeraIntegManualPDV ", "Method FiltraParam | cQuery | ", cQuery )

cQuery := ChangeQuery(cQuery)
oQuery := FwExecStatement():New(cQuery)
self:cAliasIntegManual := oQuery:OpenAlias()

Return

/*/{Protheus.doc} IntegraSX5
Dispara os metodos para geraçao da integraçao das tabelas da SX5
@author joao.marcos
@since 01/04/2024
@version 1.0
/*/
Method IntegraSX5() Class GeraIntegManualPDV
LjGrvLog(" GeraIntegManualPDV ", "Method IntegraSX5 | Inicio | ", FWTimeStamp(2) )

Self:FiltraSX5()
Self:PublicaIntegManual("SX5")
Self:EnviaIntegManual()

LjGrvLog(" GeraIntegManualPDV ", "Method IntegraSX5 | Fim | ", FWTimeStamp(2) )
Return

/*/{Protheus.doc} FiltraSX5
Efetua a Query filtrando as tabelas da sx5 para Integração
@author joao.marcos
@since 01/04/2024
@version 1.0
/*/
Method FiltraSX5() Class GeraIntegManualPDV
Local cQuery        := ""   as Character
Local oQuery        := Nil  as Object
Local cTabelasSX5   := ""   as Character
Local nX            := 0    as Numeric

Self:cFilIntegQry += ",''"

For nX := 1 To Len(Self:aJTabelasSX5)
    cTabelasSX5 += "'" + Self:aJTabelasSX5[nX] + "',"
Next 

cTabelasSX5 := SubStr(cTabelasSX5,1,Len(cTabelasSX5)-1)

cQuery += " SELECT X5_FILIAL AS TABFILIAL, "                    + CRLF
cQuery += " X5_FILIAL + X5_TABELA + X5_CHAVE AS CHAVE, "        + CRLF
cQuery += " R_E_C_N_O_ AS TABRECNO,  X5_TABELA, X5_CHAVE "      + CRLF
cQuery += " FROM " + RetSQLName("SX5") + " "                    + CRLF
cQuery += " WHERE X5_FILIAL IN (" + Self:cFilIntegQry + ") "    + CRLF
cQuery += " AND X5_TABELA IN (" + cTabelasSX5 + ") "

LjGrvLog(" GeraIntegManualPDV ", "Method FiltraSX5 | cQuery | ", cQuery )

cQuery := ChangeQuery(cQuery)
oQuery := FwExecStatement():New(cQuery)
self:cAliasIntegManual := oQuery:OpenAlias()

Return

/*/{Protheus.doc} PublicaIntegManual
Gerao publicaçao na MHQ para Integração Manual
@author joao.marcos
@since 01/04/2024
@version 1.0
@param cTabela, character, nome da tabela
/*/
Method PublicaIntegManual(cTabela as Character) Class GeraIntegManualPDV
Local cJson         := ""                   as Character
Local cProcesso     := ""                   as Character

LjGrvLog(" GeraIntegManualPDV ", "Method PublicaIntegManual | Inicio | ", FWTimeStamp(2) )
LjGrvLog(" GeraIntegManualPDV ", "Method PublicaIntegManual | Tipo de integraçao: | ", Self:cTipoInteg )

If Self:cTipoInteg == "2" .OR. Self:cTipoInteg == "3" // Integraçao Parametros ou SX5
    If Self:cTipoInteg == "2"
        cProcesso := "999SX6"
    Else
        cProcesso := "999SX5"
    EndIf

    (Self:cAliasIntegManual)->(dbGoTop())    

    While (Self:cAliasIntegManual)->( !Eof() )

        (cTabela)->( dbGoTo( (Self:cAliasIntegManual)->TABRECNO ) )

        cJson := Self:GeraJsonReg(cTabela)
        
        cJson := SubStr(cJson,1,Len(cJson) - 1) + CRLF + '}' 
            LjGrvLog(" GeraIntegManualPDV ", "Method PublicaIntegManual | cJson | ", cJson )
            Begin Transaction

                    RecLock("MHQ", .T.)

                        MHQ->MHQ_FILIAL := xFilial("MHQ")
                        MHQ->MHQ_ORIGEM := "PROTHEUS"
                        MHQ->MHQ_CPROCE := AllTrim(cProcesso)
                        MHQ->MHQ_EVENTO := IIF( (cTabela)->( Deleted() ), "2", "1")     //1=Atualização;2=Exclusão
                        MHQ->MHQ_CHVUNI := (Self:cAliasIntegManual)->CHAVE 
                        MHQ->MHQ_MENSAG := cJson
                        MHQ->MHQ_DATGER := Date()
                        MHQ->MHQ_HORGER := Time()
                        MHQ->MHQ_STATUS := "1"
                        MHQ->MHQ_IDEXT  :=(self:cAliasIntegManual)->TABFILIAL
                        MHQ->MHQ_UUID   := FwUUID("PUBLICA" + StrTran(FwTimeUf()[1]+TimeFull(),':',''))  //Gera chave unica

                        LjGrvLog(" GeraIntegManualPDV ", "Method PublicaIntegManual | MHQ_UUID | ", MHQ->MHQ_UUID )

                        AADD(Self:aMHQUUID, {MHQ->MHQ_UUID,AllTrim((Self:cAliasIntegManual)->CHAVE)})
                    MHQ->( MsUnLock() )                        

            End Transaction

        (self:cAliasIntegManual)->( dbSkip() )
    EndDo

EndIf

LjGrvLog(" GeraIntegManualPDV ", "Method PublicaIntegManual | Fim | ", FWTimeStamp(2) )

Return

/*/{Protheus.doc} EnviaIntegManual
Grava registros da integraçao manual na MIP
@author joao.marcos
@since 01/04/2024
@version 1.0
/*/
Method EnviaIntegManual() Class GeraIntegManualPDV
Local nX        := 0    as Numeric
Local cQueryMIQ := ""   as Character
Local oQueryMIQ := Nil  as Object
Local cAliasQryMIQ := ""    as Character
Local aAreaMHQ     := MHQ->(GetArea()) as Array
Local aAreaMIP     := MIP->(GetArea()) as Array
Local lRegNovo     := .T.   as Logical

LjGrvLog(" GeraIntegManualPDV ", "Method EnviaIntegManual | Inicio | ", FWTimeStamp(2) )

cQueryMIQ += " SELECT MIQ_COD, MIQ_FILPC, R_E_C_N_O_ "              + CRLF
cQueryMIQ += " FROM " + RetSqlName("MIQ") + " "                     + CRLF
cQueryMIQ += " WHERE MIQ_FILPC IN ( " + Self:cFilIntegQry + " ) "   + CRLF
cQueryMIQ += " AND MIQ_ATIVO = '1' "                                + CRLF
cQueryMIQ += " AND D_E_L_E_T_ = ' ' "

cQueryMIQ := ChangeQuery(cQueryMIQ)
oQueryMIQ := FwExecStatement():New(cQueryMIQ)
cAliasQryMIQ := oQueryMIQ:OpenAlias()

MIP->(dbSetOrder(1)) //MIP_FILIAL+MIP_CPROCE+MIP_CHVUNI+MIP_PDV

MHQ->(dbSetOrder(7)) //MHQ_FILIAL+MHQ_UUID

For nX := 1 To Len(Self:aMHQUUID)

    If MHQ->( dbSeek(xFilial("MHQ") + Self:aMHQUUID[nX][1]) ) 

        (cAliasQryMIQ)->(dbGoTop())

        While (cAliasQryMIQ)->(!EOF())
            If ( Self:cProcesso == "999SX6" .AND. Self:ValidFilPtInteg(1, cAliasQryMIQ, Self:aMHQUUID[nX][1]) ) .OR. Self:cProcesso <> "999SX6"

                If MIP->(dbSeek( Padr((cAliasQryMIQ)->MIQ_FILPC, TamSx3("MIP_FILIAL")[1]) + Padr(AllTrim(self:cProcesso), TamSx3("MIP_CPROCE")[1]) + Padr(AllTrim(Self:aMHQUUID[nX][2]), TamSx3("MIP_CHVUNI")[1]) + Padr(AllTrim( (cAliasQryMIQ)->MIQ_COD ), TamSx3("MIP_PDV")[1]) ) )
                    lRegNovo := .F.
                Else
                    lRegNovo := .T.
                EndIf    

                RecLock("MIP", lRegNovo)
                    MIP->MIP_FILIAL := (cAliasQryMIQ)->MIQ_FILPC
                    MIP->MIP_CPROCE := AllTrim(self:cProcesso)
                    MIP->MIP_CHVUNI := AllTrim(Self:aMHQUUID[nX][2])
                    MIP->MIP_LOTE   := ""
                    MIP->MIP_DATGER := Date()
                    MIP->MIP_HORGER := TimeFull()
                    MIP->MIP_DATPRO := CtoD("")
                    MIP->MIP_HORPRO := ""
                    MIP->MIP_STATUS := "1"
                    MIP->MIP_UUID   := FwUUID("MIP" + StrTran(FwTimeUf()[1]+TimeFull(),':',''))
                    MIP->MIP_UIDORI := MHQ->MHQ_UUID
                    MIP->MIP_PDV    := AllTrim( (cAliasQryMIQ)->MIQ_COD )
                    MIP->MIP_TENTAT := "0"
                MIP->( MsUnLock() )
            EndIf

            (cAliasQryMIQ)->(dbSkip())
        EndDo

        //Atualiza publicação
        RecLock("MHQ", .F.)
            MHQ->MHQ_STATUS := "2"              //1=A Processar;2=Processada;3=Erro
            MHQ->MHQ_DATPRO := Date()
            MHQ->MHQ_HORPRO := Time()
        MHQ->( MsUnLock() )

    EndIf
Next

RestArea(aAreaMIP)
RestArea(aAreaMHQ)
FwFreeArray(Self:aMHQUUID)
Self:aMHQUUID := {}
(cAliasQryMIQ)->(dbCloseArea())

LjGrvLog(" GeraIntegManualPDV ", "Method EnviaIntegManual | Fim | ", FWTimeStamp(2) )

Return

/*/{Protheus.doc} GeraJsonReg
Gerao o Json com os dados do registro
@author joao.marcos
@since 01/04/2024
@version 1.0
/*/
Method GeraJsonReg(cTabela as Character) as Character Class GeraIntegManualPDV
Local cRetorno := "" as Character
Local aStructExp:= (cTabela)->( DbStruct() ) //Bruno - Acho que não precisa pegar toda hora o Struct se for a mesma tabela
Local nCont     := 0
Local oJson     := JSonObject():New()

For nCont := 1 To Len(aStructExp)  
    oJson[aStructExp[nCont][1]] := (cTabela)->&( aStructExp[nCont][1] )
Next nCont

cRetorno := oJson:ToJson()

aSize(aStructExp, 0)

Return cRetorno

/*/{Protheus.doc} Grava
Metodo que ira atualizar a situação da distribuição e gravar a tabela MIP
@author  Bruno Almeida
@version 1.0
/*/
Method Grava() as Logical Class GeraIntegManualPDV

Local lInclui       := .T.
Local cRegExclus    := ""

Begin Transaction

    Self:getMiq()

    If !(self:cTabMiq)->( Eof() )

        cRegExclus := Self:ValidFil()

        While !(self:cTabMiq)->( Eof() )

            If (cRegExclus == "COMPARTILHADA") .OR. (cRegExclus == "EXCLUSIVA" .AND. AllTrim(MIQ->MIQ_FILPC) == AllTrim(SubStr(MHQ->MHQ_CHVUNI,1,TamSx3("MHQ_FILIAL")[1]))) .OR.;
                (AllTrim(cRegExclus) $ AllTrim(SubStr(MHQ->MHQ_CHVUNI,1,TamSx3("MHQ_FILIAL")[1])))

                // Se tiver registro mais recente retorna falso e ignora o registro
                If !Self:ValidReg( (self:cAliasQryIntegTab)->MHQ_UUID )

                    MIQ->(dbGoTo((self:cTabMiq)->REC))

                    MIP->(dbSetOrder(1)) //MIP_FILIAL+MIP_CPROCE+MIP_CHVUNI+MIP_PDV
                    lInclui := !MIP->( DbSeek(Padr(MIQ->MIQ_FILPC, TamSx3("MIP_FILIAL")[1] ) + Padr((self:cAliasQryIntegTab)->MHQ_CPROCE, TamSx3("MIP_CPROCE")[1] ) + Padr((self:cAliasQryIntegTab)->MHQ_CHVUNI, TamSx3("MIP_CHVUNI")[1] ) + Padr( MIQ->MIQ_COD, TamSx3("MIQ_COD")[1] )) )

                    RecLock("MIP", lInclui)
                    MIP->MIP_FILIAL := MIQ->MIQ_FILPC
                    MIP->MIP_CPROCE := (self:cAliasQryIntegTab)->MHQ_CPROCE
                    MIP->MIP_CHVUNI := (self:cAliasQryIntegTab)->MHQ_CHVUNI
                    MIP->MIP_LOTE   := ""
                    MIP->MIP_DATGER := Date()
                    MIP->MIP_HORGER := TimeFull()
                    MIP->MIP_DATPRO := CtoD("")
                    MIP->MIP_HORPRO := ""
                    MIP->MIP_STATUS := "1"
                    MIP->MIP_UUID   := FwUUID("MIP" + DtoS(MIP->MIP_DATGER) + MIP->MIP_HORGER)
                    MIP->MIP_UIDORI := (self:cAliasQryIntegTab)->MHQ_UUID
                    MIP->MIP_PDV    := MIQ->MIQ_COD
                    MIP->MIP_TENTAT := "0"
                    MIP->( MsUnLock() )
                EndIF
            EndIf

            (self:cTabMiq)->( DbSkip() )
        EndDo
    EndIf

    (self:cTabMiq)->( DbCloseArea() )

End Transaction

Return .T.

/*/{Protheus.doc} ValidReg
Valida se tem alguma alteraçao no registro posterior a query
@author joao.marcos
@version 1.0
@param cMhqUid, Character, UUID do registro na MHQ
/*/
Method ValidReg(cMhqUid as Character) as Logical Class GeraIntegManualPDV
Local lRet          := .T.              as Logical
Local aAreaMHQ      := MHQ->(GetArea()) as Array
Local cChaveUnica   := ""               as Character
Local cOrigem       := ""               as Character
Local cDataHoraGer  := ""               as Character
Local cQuery        := ""               as Character
Local cAliasQry     := ""               as Character

MHQ->(dbSetOrder(7)) // MHQ_FILIAL+MHQ_UUID

MHQ->( dbSeek( xFilial("MHQ") + cMhqUid ) )
cChaveUnica     := AllTrim(MHQ->MHQ_CHVUNI)
cOrigem         := AllTrim(MHQ->MHQ_ORIGEM)
cDataHoraGer    := AllTrim(DtoS(MHQ->MHQ_DATGER)) + AllTrim(MHQ->MHQ_HORGER)

// Verifico se existe algum registro mais recente NHQ com a mesma chave
cQuery += " SELECT TOP 1 MHQ.MHQ_UUID "                         + CRLF
cQuery += " FROM " + RetSqlName("MHQ") + " MHQ "                + CRLF
cQuery += " WHERE MHQ_FILIAL = '" + xFilial("MHQ") + "'  "      + CRLF
cQuery += " AND MHQ_CHVUNI = '" + cChaveUnica + "' "            + CRLF
cQuery += " AND MHQ_CPROCE = '" + Self:cProcesso + "' "         + CRLF
cQuery += " AND MHQ_ORIGEM = 'PROTHEUS' "                       + CRLF
cQuery += " AND MHQ_DATGER+MHQ_HORGER > '" + cDataHoraGer + "'" + CRLF
cQuery += " AND MHQ_STATUS = '2' "                              + CRLF
cQuery += " AND MHQ.D_E_L_E_T_ = ' ' "                          + CRLF
cQuery += " ORDER BY MHQ_DATGER, MHQ_HORGER DESC "

cQuery := ChangeQuery(cQuery)
cAliasQry := MPSysOpenQuery(cQuery)

(cAliasQry)->(dbGoTop())

// Se tiver registro mais recente retorna falso e ignora o registro
If (cAliasQry)->(EOF())
    lRet := .F.
EndIf

RestArea(aAreaMHQ)
(cAliasQry)->(dbCloseArea())

Return lRet

/*/{Protheus.doc} ValidFilPtInteg
Valida seo registro pertence a filial do Ponto de Integraçao
@author joao.marcos
@version 1.0
@param nOp, Numeric, opção que deseja validar a filial
        cAliasQryMIQ, character, Alias da quary na MIQ
/*/
Method ValidFilPtInteg(nOp as Numeric, cAliasQryMIQ as Character, cUIDMDQ as Character) as Logical Class GeraIntegManualPDV
Local lRet      := .T.              as Logical
Local aAreaMHQ  := MHQ->(GetArea()) as Array
Local cParam    := ""               as Character
Local cFilParam := ""               as Character
Local cFilPtInteg := AllTrim((cAliasQryMIQ)->MIQ_FILPC)  as Character
Local oJMhqMensag := JsonObject():New() as Json
Local nSx6TamFil    := Len(SX6->X6_FIL)

MHQ->(dbSetOrder(7)) //MHQ_FILIAL+MHQ_UUID

If nOp == 1 // Parametros SX6
    MHQ->(dbSeek( xFilial("MHQ") + cUIDMDQ ))
    oJMhqMensag:FromJson(MHQ->MHQ_MENSAG)
    cParam      := oJMhqMensag['X6_VAR']
    cFilParam   := oJMhqMensag['X6_FIL']

    If ( Empty(cFilParam) .AND. !Empty(cFilPtInteg) .AND. SX6->(dbSeek( PadR(cFilPtInteg,nSx6TamFil) + cParam )) ) .OR.;
        ( !Empty(cFilParam) .AND. Upper(AllTrim(cFilParam)) <> Upper(cFilPtInteg) )
        // Valida se existe este parâmetro exclusivo para a filial do Ponto de integraçao
        lRet := .F.
    ElseIf Upper(AllTrim(cFilParam)) == Upper(cFilPtInteg)
        lRet := .T.	
    EndIf
    
EndIf

RestArea(aAreaMHQ)

Return lRet
