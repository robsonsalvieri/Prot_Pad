#INCLUDE "PROTHEUS.CH"
#INCLUDE "CRDA220.CH"

Function CRDA220()

//Ŀ
// Define o menu da gestao de acervos                                      
//
Private aCols 	:= {}													// Campos da GetDados
Private aHeader	:= {}												 	// Array com Cabecalho dos campos
Private aRotina := MenuDef()
					
//Ŀ
// Define o cabealho da tela de atualizaoes                              
//
Private cCadastro	:= STR0008 //"Regras de Pontuao"

mBrowse( 6, 1,22,75,"MAS" )

Return Nil

/*/

Ŀ
Funo     MenuDef   Autor  Conrado Q. Gomes       Data  13.12.06 
Ĵ
Descrio  Definio do aRotina (Menu funcional)                      
Ĵ
Sintaxe    MenuDef()                                                  
Ĵ
Parametros                                                            
Ĵ
 Uso       CRDA220                                                    
ٱ


/*/
Static Function MenuDef()
	Local aRotina := {	{STR0001	,"AxPesqui"		,0	,1	,0	,.F.	}	,;	 	//"Pesquisar"
					 	{STR0002	,"Crd220Man"	,0	,2	,0	,.T.	}	,;	 	//"Visualizar"
						{STR0003	,"Crd220Man"	,0	,3	,0	,.T.	}	,;	 	//"Incluir"
						{STR0004	,"Crd220Man"	,0	,4	,0	,.T.	}	,;	 	//"Alterar"
						{STR0005	,"Crd220Man"	,0	,5	,0	,.T.	}	} 	 	//"Excluir"
Return aRotina


/*


ͻ
Programa  CRDA220ManAutor  Marcos R. Andrade    Data   29/11/05   
͹
Desc.     Funcao para manutencao no cadastro de campanha              
                                                                      
͹
Uso       SIGACRD                                                     
ͼ


*/
Function Crd220Man( cAlias, nReg, nOpc )

Local lProcessa		:= .T.						// Valida se exite o processamento ou nao
Local nSaveSx8		:= GetSx8Len()				// Controle de semaforo
Local aCamposEnc	:= {}						// Relacao dos campos que estao na enchoice para gravacao do
Local nX			:= 0                     	// Contador
Local aRecno		:= {}						// Array com a posicao do Registro
Local lRet			:= .F.						// Variavel de retorno	
Local cOperacao		:= ""						// Opercao clicada pelo usuario (Inclusao, Alteracao,...)

Do Case
	Case nOpc == 2
		cOperacao := STR0002 //"Visualizar"
	Case nOpc == 3
		cOperacao := STR0003 //"Incluir"
	Case nOpc == 4
		cOperacao := STR0004 //"Alterar"
	Case nOpc == 5
		cOperacao := STR0005 //"Excluir"
EndCase

//Ŀ
//Valida se for exclusao e se pode excluir
//
If nOpc == 5
	lProcessa := Crd220CanDel()
Endif

//Ŀ
// Forca a abertura dos arquivos                                           
//

If lProcessa
	
	DbSelectArea("MAS")
	//Ŀ
	// Inicializacao das variaveis da Enchoice                                 
	//
	RegToMemory( "MAS", (nOpc==3), (nOpc==3) )
	
	DbSelectArea( "SX3" )
	SX3->(DbSetOrder(1))	// X3_ARQUIVO+X3_ORDEM
	SX3->(DbSeek( "MAS" ))
	While !SX3->(Eof()) .AND. SX3->X3_ARQUIVO == "MAS"
		If X3Uso(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL
			aAdd( aCamposEnc, SX3->X3_CAMPO )
		Endif
		SX3->(DbSkip())
	End
	
	//Ŀ
	// Cria aHeader e aCols da GetDados 
	//
	nUsado	:=0
	DbSelectArea("SX3")
	SX3->(DbSeek("MAT"))
	aHeader	:={}
	
	While !SX3->(Eof()) .AND. (X3_ARQUIVO == "MAT" )
		If X3Uso(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL
			Aadd(aHeader,{ 	TRIM( SX3->X3_TITULO )	,;  //01 - Titulo
							SX3->X3_CAMPO			,;	//02 - campo
							SX3->X3_PICTURE			,;	//03 - Picture
							SX3->X3_TAMANHO			,;	//04 - Tamanho
							SX3->X3_DECIMAL			,;	//05 - Decimal
							SX3->X3_VALID			,;	//06 - Valid do campo (Sistema)
							SX3->X3_USADO			,;	//07 - Usado ou nao
							SX3->X3_TIPO			,;	//08 - Tipo
							SX3->X3_ARQUIVO			,;	//09 - Arquivo
							SX3->X3_CONTEXT } )			//10 - Contexto
		Endif
		SX3->(DbSkip())
	End
	
	aCols:={}
	DbSelectArea("MAT")
	MAT->(DbSetOrder(1))
	nUsado	:= Len( aHeader )
	
	If !INCLUI
		If MAT->(DbSeek( xFilial( "MAT" ) + M->MAS_CODCAM ))
			
			While 	!MAT->(EOF())							.AND.;
					MAT->MAT_FILIAL == xFilial( "MAT" ) 	.AND.;
					MAT->MAT_CODCAM == M->MAS_CODCAM
				
				//Ŀ
				// Nao acrescenta recno caso for copia
				//
				AAdd( aCols, Array( nUsado + 1 ) )
				AAdd( aRecno, MAT->( Recno() ) )
				
				//Ŀ
				// Acrescenta acols de regras
				//
				For nX := 1 To nUsado
					If ( aHeader[nX][10] <>  "V" )
						aCols[Len( aCols )][nX] := MAT->( FieldGet( FieldPos( aHeader[nX][2] ) ) )
					Else
						aCols[Len( aCols )][nX] := CriaVar( aHeader[nX][2], .T. )
					Endif
				Next nX
				
				aCols[Len( aCols )][ nUsado + 1 ] := .F.
				
				MAT->( DbSkip() )
			End
		Endif
		
	Else
		//Ŀ
		// Se for uma inclusao inicializa o acols     
		//
		AAdd( aCols, Array( nUsado + 1 ) )
		For nX := 1 To nUsado
			If AllTrim( aHeader[ nX][2] ) == "MAT_ITEM"
				aCols[Len( aCols )][nX] := StrZero( 1, Len( MAT->MAT_ITEM ) )
			Else
				aCols[Len( aCols )][nX] := CriaVar( aHeader[nX][2], .T. )
			Endif
			aCols[Len( aCols )][ nUsado + 1 ] := .F.
			
		Next nX
		
	Endif
	
	If Len( aCols ) >= 0
		
		//Ŀ
		// Executa a Modelo 3 
		//
		cTitulo			:= STR0008 + " - " + cOperacao // Regras de pontuacao
		cLinOk			:= "CRD220LOK()"
		cTudOk			:= "CRD220TOK()"
		cFieldOk		:= "AllwaysTrue()"
		lRet 			:=CRD220Tela(	cTitulo,	"MAS",	"MAT",	aCamposEnc,;
										cLinOk,		cTudOk,	nOpc,	nOpc,;
										cFieldOk )
		
		//Ŀ
		// Executar processamento 
		//
		If lRet
			
			//Ŀ
			// Chama a funcao de gravacao - PONTOS DA CAMPANHA                         
			//
			lGravou := Crd220Grv(	nOpc,	aCamposEnc, aHeader, aCols,;
									aRecno )
			
			//Ŀ
			// Controle do semaforo                                                    
			//
			If lGravou
				If nOpc == 3
					While ( GetSx8Len() > nSaveSx8 )
						ConfirmSx8()
					End
				Endif
			Else
				While ( GetSx8Len() > nSaveSx8 )
					RollBackSx8()
				End
			Endif
			
		Else
			//Ŀ
			// Controle do semaforo                                                    
			//
			While (GetSx8Len() > nSaveSx8)
				RollBackSx8()
			End
		Endif
	Endif
Else
	Help(" ",1,"NODELETA")
Endif

Return Nil

/*/


Ŀ
Funo    Crd220Grv  Autor  Henry Fila             Data  17/02/2005 
Ĵ
Descrio Rotina de Gravacao da campanha                                
Ĵ
Sintaxe   Crd220Grv                                                     
Ĵ
ParametrosExpN1: Opcao da Gravacao sendo:                               
                 [1] Inclusao                                           
                 [2] Alteracao                                          
                 [3] Exclusao                                           
          ExpA2: Array de registros                                     
Ĵ
Uso        Pesquisa e Resultado                                         
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/
Static Function Crd220Grv(	nOpc,		aCamposEnc, 	aHeader,	aCols,;
							aRecno )

Local aArea     := GetArea()						// Salva a area atual
Local bCampo 	:= {|nCPO| Field(nCPO) }    		// Nome do campo	
Local cItem     := Repl("0",Len( MAT->MAT_ITEM ))	// Numero do Item
Local nX        := 0								// Contador 
Local nField    := 0								// Contador
Local nLinha    := 0								// Contador de linhas do Acols
Local nPos		:= 0								// Posicao do campo MAT_VALOR
Local lTravou   := .F.								// Flag para garantir o lock de registro

DbSelectArea( "MAS" )
DbSelectArea( "MAT" )

//Ŀ
//Se  for INCLUSAO ou ALTERACAO  
//
If ( nOpc == 3 ) .OR. ( nOpc == 4) 
	
	//Ŀ
	//Grava a pesquisa e as regras da pesquisa                           
	//
	BEGIN TRANSACTION
	
		//Ŀ
		//Grava os dados da Campanha
		//
		MAS->(DbSetOrder(1))
		If MAS->(DbSeek( xFilial( "MAS" ) + M->MAS_CODCAM ))
			RecLock("MAS",.F.)
		Else
			RecLock("MAS",.T.)
		Endif       
		        
		For nField := 1 To MAS->( FCount() )	  				
  			FieldPut(nField, M->&(EVAL( bCampo, nField ) ) )
		Next nField       
		
		Replace MAS->MAS_FILIAL With xFilial("MAS")                         
		
		MAS->(MsUnLock())

		//Ŀ
		//Grava os dados  do MAT (Pontos da Campanha) - itens do cadastro 
		//

		bCampo := {|nCPO| Field(nCPO) }
		
		For nX := 1 To Len( aCols )
			
			// Flag para garantir o lock de registro
			lTravou := .F.
			
			// Se a linha atual for menor que o total de registros
			If nX <= Len( aRecNo )
				DbSelectArea( "MAT" )
				MAT->(DbGoTo( aRecNo[nX] ))
				RecLock("MAT",.F.)
				
				// Lock do regsitro que sera alterado
				lTravou := .T.
			Endif
			
			// Se a linha atual nao foi DELETADA
			If ( !aCols[nX][nUsado+1] )

				//Se nao fez o LOCK significa que e uma nova Linha
				If !lTravou
					RecLock("MAT",.T.)
				Endif

				cItem := Soma1(cItem,Len(MAT->MAT_ITEM))
				Replace MAT->MAT_FILIAL With xFilial("MAT")
				Replace MAT->MAT_CODCAM With MAS->MAS_CODCAM
				Replace MAT->MAT_ITEM   With cItem
				
				bCampo := {|nCPO| Field(nCPO) }
					
				For nLinha := 1 To MAT->(FCount())
				
					If !(EVAL(bCampo,nLinha) == "MAT_FILIAL") 
						nPos:= Ascan(aHeader,{|x| ALLTRIM(EVAL(bCampo,nLinha)) == ALLTRIM(x[2])})
						If (nPos > 0)
							If (aHeader[nPos][10] <> "V" .AND. aHeader[nPos][08] <> "M")
								Replace MAT->&(EVAL(bCampo,nLinha)) With aCols[nX][nPos]
							Endif
						Endif
					Endif
						
				Next nLinha
				
				lGravou := .T.
			Else
				If lTravou
					RecLock("MAT",.F.)
					MAT->(DbDelete())
				Endif
			Endif
			MAT->(MsUnLock())
			
		Next nX
		
	END TRANSACTION
	
ElseIf !nOpc == 2
	
	//Ŀ
	//Deleta MAT (Pontos da Campanha)            
	//
	DbSelectArea("MAT")
	MAT->(DbSetOrder(1))
	If MAT->(DbSeek(xFilial("MAT")+M->MAS_CODCAM))
		RecLock("MAT",.F.)
		MAT->(DbDelete())
		MAT->(MsUnlock())
	EndIf
	
	//Ŀ
	//Deleta MAS (Campanha)                      
	//
	DbSelectArea("MAS")
	RecLock("MAS", .F.)
	MAS->(DbDelete())
	MAS->(MsUnlock())

Endif

RestArea(aArea)

Return .T.

/*/


Ŀ
Programa  CRD220CanDel Autor Marcos R. Andrade     Data 30.11.2003
Ĵ
Descrio Validacao da exclusao da Campanha                           
Ĵ
Uso       Campanha de Fidelizacao             					      
Ĵ
                Alteracoes desde sua criacao                           
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function Crd220CanDel()

Local lRet 		:= .T.						// Retorno da funcao
Local cAliasMAX	:= "MAX"					// Alias da relacao pontos x campanha x cliente
Local aArea		:= GetArea()				// Salva area

#IFDEF TOP
	Local cQuery	:= ""
	Local lQuery	:= .F.
#ENDIF

#IFDEF TOP
	
	lQuery := .T.
	
	//Ŀ
	//Verifica se tem algum registro na tabela MAX (Cliente X Total de pontos da campanha)
	//
	
	cAliasMAX := "QRYMAX"
	
	cQuery := "SELECT COUNT(*) QTDMAX "
	cQuery += " FROM "
	cQuery += RetSqlName("MAX")+ " MAX "
	cQuery += " WHERE "
	
	cQuery += "MAX_FILIAL = '" + xFilial( "MAX" ) +"' AND "
	cQuery += "MAX_CODCAM = '" + MAS->MAS_CODCAM +"' AND "
	cQuery += "MAX.D_E_L_E_T_ = ' ' "
	
	cQuery := ChangeQuery(cQuery)
	DbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasMAX,.F.,.T.)
	
	If (cAliasMAX)->QTDMAX > 0
		lRet := .F.
	Endif
	
	DbCloseArea()
	
	DbSelectArea("MAS")
	
#ELSE
	cAliasMAX := "MAX"
	DbSelectArea( "MAX" )
	DbSetOrder( 2 )
	
	If MAX->( DbSeek(xFilial("MAX")+ MAS->MAS_CODCAM ) )
		lRet := .F.
	Endif
	
#ENDIF

RestArea( aArea )

Return(lRet)

/*


ͻ
Programa  CRDProcCam Autor  Marcos Roberto Andrade Data  30/11/05 
͹
Desc.      Verifica se existe alguma campanha ativa.                  
                                                                      
͹
Uso        CRDA220                                                    
͹
  DATA   BOPS Program. ALTERACAO                                    
Ĵ
                                                                    
                                                                    
                                                                    
ͼ


*/
Function CRD220ProcCam()
Local lRet 		:= .T.
Local aArea		:= GetArea()
Local cAliasMAS	:= "MAS"

#IFDEF TOP
	Local cQuery	:= ""
	Local lQuery	:= .F.
#ELSE
	Local cIndMAS	:= ""
	Local cKey		:= ""
	Local nIndMAS	:= 0
#ENDIF

#IFDEF TOP
	
	lQuery := .T.
	
	cAliasMAS := "QRYMAS"
	
	cQuery := "SELECT COUNT(*) QTDMAS "
	cQuery += " FROM "
	cQuery += RetSqlName("MAS")+ " MAS "
	cQuery += " WHERE "
	
	cQuery += "MAS_FILIAL = '" + xFilial( "MAS" ) +"' AND "
	cQuery += "MAS_CODCAM <> '" + M->MAS_CODCAM + "' AND "
	cQuery += "MAS_STATUS = '1'  AND "
	cQuery += "MAS.D_E_L_E_T_ = ' ' "
	
	cQuery := ChangeQuery(cQuery)
	DbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasMAS,.F.,.T.)
	
	If (cAliasMAS)->QTDMAS > 0
		lRet := .F.
	Endif
	
	DbCloseArea()
	
	DbSelectArea("MAS")
	
#ELSE
	cAliasMAS := "MAS"
	DbSelectArea( "MAS" )
	DbSetOrder( 1 )
	cIndMAS := CriaTrab( NIL, .F.)
	
	cKey      := "MAS_FILIAL+MAS_STATUS"
	
	IndRegua( "MAS", cIndMAS, cKey)
	nIndMAS := RetIndex( "MAS" )
	DbSetIndex( cIndMAS + OrDbagExT() )
	DbSetOrder( nIndMAS + 1 )
	
	If MAS->( DbSeek(xFilial("MAS")+'1' ) )
		If MAS->MAS_CODCAM <> M->MAS_CODCAM
			lRet := .F.
		EndIf
	Endif
	
	DbSelectArea("MAS")
	DbClearFilter()
	RetIndex("MAS")
	Ferase(cIndMAS+OrDbagExt())
	
#ENDIF

If !lRet
	Aviso(STR0006, STR0007, {STR0009 } )  // Para ativar esta campanha ser necessrio inativar a campanha que esta ativa no momento, OK
EndIf


RestArea( aArea )

Return lRet

/*


ͻ
Programa  CRD220LOK Autor  Hanna C. Inglez      Data   27/02/06   
͹
Desc.     Funcao para validacao do linkok. Valida se o valor foi      
          preenchido.                                                 
͹
Uso        AP                                                         
ͼ


*/
Function CRD220LOK()
Local lRet	:= .F.		// Retorno da funcao

If !aCols[n,Len(aHeader)+1]
	If 	(aScan(aHeader,{|x| Alltrim( x[2] ) == "MAT_VALOR"}) ) 	>  0 	.Or.;
		(aScan(aHeader,{|x| Alltrim( x[2] ) == "MAT_PRODUTO"}) ) 	<> "" 	.Or.;
		(aScan(aHeader,{|x| Alltrim( x[2] ) == "MAT_GRUPO"}) ) 	<> ""
		
		lRet	:= .T.
	Endif
Else
	lRet := .T.
EndIf

Return (lRet)

/*


ͻ
Programa  CRD220TOK Autor  Hanna C. Inglez      Data   27/02/06   
͹
Desc.     Funcao para validacao do TudoOK. Valida se o valor foi      
          preenchido.                                                 
͹
Uso        AP                                                         
ͼ


*/
Function CRD220TOK()
Local lRet	:= .F.				// Retorno da funcao
If !Empty( M->MAS_PONTOS )
	lRet	:= .T.
Endif
Return (lRet)
/*


Ŀ
Funo	 Modelo3	   Autor  Wilson				 Data  17/03/97 
Ĵ
Descrio Enchoice e GetDados									  	  
Ĵ
ParametroslRet:=Modelo3(cTitulo,cAlias1,cAlias2,aMyEncho,cLinOk, 	  
			  cTudoOk,nOpcE,nOpcG,cFieldOk,lVirtual,nLinhas,aAltEnchoice)
			 lRet=Retorno .T. Confirma / .F. Abandona					  
			 cTitulo=Titulo da Janela 									  
			 cAlias1=Alias da Enchoice									  
			 cAlias2=Alias da GetDados									  
			 aMyEncho=Array com campos da Enchoice						  
			 cLinOk=LinOk 												  
			 cTudOk=TudOk 												  
			 nOpcE=nOpc da Enchoice									  
			 nOpcG=nOpc da GetDados									  
			 cFieldOk=validacao para todos os campos da GetDados 		  
			 lVirtual=Permite visualizar campos virtuais na enchoice	  
			 nLinhas=Numero Maximo de linhas na getdados				  
			 aAltEnchoice=Array com campos da Enchoice Alteraveis		  
			 nFreeze=Congelamento das colunas.                           
Ĵ
 Uso		 RdMake 													  
ٱ


/*/
Static Function CRD220Tela(	cTitulo,	cAlias1,	cAlias2,	aMyEncho,;
							cLinOk,		cTudoOk,	nOpcE,		nOpcG,;
							cFieldOk,	lVirtual,	nLinhas,	aAltEnchoice,;
							nFreeze,	aButtons )

Local lRet
Local nOpca 	 := 0
Local nReg		 :=(cAlias1)->(Recno())
Local oDlg
Local oEnchoice
Local aSize      := MsAdvSize( .T., .F., 400 )		// Size da Dialog
Local aObjects   := {} 
Local aInfo      := {}
Local aPosObj    := {}

Private aTELA:=Array(0,0)
Private aGets:=Array(0)
Private bCampo:={|nCPO|Field(nCPO)}

nOpcE := If(nOpcE==Nil,3,nOpcE)
nOpcG := If(nOpcG==Nil,3,nOpcG)
lVirtual := Iif(lVirtual==Nil,.F.,lVirtual)
nLinhas:=Iif(nLinhas==Nil,99,nLinhas)
	
//Ŀ
// Divide a tela horizontalmente para os objetos enchoice e getdados   
//
aObjects := {}

AAdd( aObjects, { 100, 100, .T., .T. } )
AAdd( aObjects, { 100, 100, .T., .T. } )

aInfo       := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 0, 0 }
aPosObj     := MsObjSize( aInfo, aObjects,  , .F. )


DEFINE MSDIALOG oDlg TITLE cTitulo From aSize[7],0 TO aSize[6],aSize[5] PIXEL OF oMainWnd //"Configurao"

oEnchoice := Msmget():New(cAlias1,nReg,nOpcE,,,,aMyEncho, aPosObj[1], aAltEnchoice,3,,,,,,lVirtual,,,,,,,,.T.)
oGetDados := MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpcG,cLinOk,cTudoOk,"+MAT_ITEM",.T.,,nFreeze,,nLinhas,cFieldOk)

ACTIVATE MSDIALOG oDlg ON INIT (EnchoiceBar(oDlg,{||nOpca:=1,If(oGetDados:TudoOk(),If(!obrigatorio(aGets,aTela),nOpca := 0,oDlg:End()),nOpca := 0)},{||oDlg:End()},,aButtons),;
AlignObject(oDlg,{oEnchoice:oBox,oGetDados:oBrowse},1,,{110}))

lRet:=(nOpca==1)
Return lRet
