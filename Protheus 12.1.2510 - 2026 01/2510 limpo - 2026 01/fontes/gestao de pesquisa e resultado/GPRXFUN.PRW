#INCLUDE "GPRDEF.CH"
#INCLUDE "GPRXFUN.CH"
#INCLUDE "PROTHEUS.CH"

/*


Ŀ
Funo    GprxHead   Autora  Solange Zanardi       Data  06/11/03 
Ĵ
Descrio  Criacao do aHeader para utilizao na GetDados             
Ĵ
Sintaxe    GprxHead(Expc1,Expn2,Expc3)                                
          | Expc1 - Alias para criacao                                 |
Ĵ
 Uso       GPRA030                                                    
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                         
Ĵ
Marcelo K 30/05/068.11  -Bops: 100117 - Revisao do fonte            
                                                                    
                                                                    
ٱ


*/
Function GprxHead(cAlias)

Local cHead  := "aHead"+cAlias   	// Nome do aHeader

DbSelectArea("SX3")
DbSetOrder(1)
MsSeek(cAlias)

While (!Eof()) .AND. (X3_ARQUIVO == cAlias)
	
	If 	X3USO(X3_USADO) .AND. cNivel >= X3_NIVEL

		Aadd(&(cHead),{Trim(X3_TITULO)	,;          // 01 - titulo
		              AllTrim(X3_CAMPO)	,;			// 02 - campo
					  X3_PICTURE		,;			// 03 - picture
					  X3_TAMANHO		,;			// 04 - tamanho
					  X3_DECIMAL		,;			// 05 - decimal
					  X3_VALID			,;			// 06 - valid
					  X3_USADO			,;			// 07 - usado
					  X3_TIPO			,;			// 08 - tipo 
					  X3_ARQUIVO		,;			// 09 - arquivo
					  X3_CONTEXT} )					// 10 - contexto
	Endif

	SX3 -> ( DbSkip() )
End

Return( .T. )

/*


Ŀ
Funo    GprxCols   Autora  Solange Zanardi       Data  06/11/03 
Ĵ
Descrio  Prepara o aCols de trabalho                                
Ĵ
Sintaxe    GprxCols(ExpN1,ExpC2)                                      
          | ExpN1 - Opcao do aRotina                                   |
          | ExpC2 - Nome do campo com utilizacao de Seq. Automtico    |
Ĵ
 Uso       GPRA030                                                    
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                         
Ĵ
Marcelo K 30/05/068.11  -Bops: 100117 - Revisao do fonte            
                                                                    
                                                                    
ٱ


*/
Function GprxCols(cAlias,nOpc)

Local nCntFor	:= 0    			 	// Contador de Lao do For
Local cCampo 	:= ""  			 		// Auxiliar para criacao das colunas do aCols
Local nUsado    := 0             		// Qtde de campos da tabela
Local cWhile    := ""            		// Variavel para controle do laco de restauracao de dados
Local cCpoAut   := ""            		// Nome do campo com calculo automatico
Local cHead     := "aHead"+cAlias   	// Nome do aHeader
Local cCols     := "aCols"+cAlias   	// Nome do aCols
Local nInd		:= 0 
	
// Qtde de Campos Utilizados na Tabela
nUsado := Len(&(cHead))

If cAlias == "SKH"
   cCpoAut := "KH_CODALT"
Else
   cCpoAut := "KI_CODCOL"
Endif

If nOpc == 3
	
	//Ŀ
	// INCLUSAO                                                                
	//
	&(cCols) := {}
	Aadd(&(cCols),Array(nUsado+1))
	For nCntFor:=1 to nUsado
		If !Empty(cCpoAut) .AND. AllTrim(&(cHead)[nCntFor][2]) == cCpoAut
			&(cCols)[1][nCntFor] := '01'
		Else
			&(cCols)[1][nCntFor] := Criavar(&(cHead)[nCntFor][2])
		Endif
	Next nCntFor

	//Ŀ
	//Atribui .F. para a coluna que determina se alinha do aCols esta deletada 
	//
	&(cCols)[1][nUsado+1] := .F.
	
Else
	
	//Ŀ
	// VISUALIZACAO, ALTERACAO E EXCLUSAO                                      
	//

	DbSelectArea(cAlias)
	DbSetOrder(1)
	If MsSeek(xFilial(cAlias) + M->KG_CODQT + M->KG_CODQST)
		
		If cAlias == "SKH"
			cWhile := "SKH->KH_FILIAL + SKH->KH_CODQT + SKH->KH_CODQST"
		Else
			cWhile := "SKI->KI_FILIAL + SKI->KI_CODQT + SKI->KI_CODQST"
		Endif
		
		While &(cWhile) == xFilial(cAlias) + M->KG_CODQT + M->KG_CODQST
			//Ŀ
			//Funcao para carregar os dados na aCols                                   
			//
			Aadd(&(cCols),Array(nUsado+1))
			For nInd:=1 To nUsado
				cCampo := Alltrim(&(cHead)[nInd,2])
				If &(cHead)[nInd,10] # "V"
					&(cCols)[Len(&(cCols))][nInd] := FieldGet(FieldPos(cCampo))
				Else
					&(cCols)[Len(&(cCols))][nInd] := CriaVar(cCampo)
				Endif
			Next nInd
			
			//Ŀ
			// Atribui .F. p/ a coluna que determina se a linha do aCols esta deletada.
			//
			&(cCols)[Len(&(cCols))][nUsado + 1] := .F.
			
			DbSelectArea(cAlias)
			DbSkip()
		End
		
	Endif
	
Endif

Return( .T. )

/*


Ŀ
Funo    GRPXPATH   Autora  Solange Zanardi       Data  20/10/03 
Ĵ
Descrio  Chamada da tela de Diretorios, usado no SX3                
Ĵ
Sintaxe    GRPXPATH()                                                 
Ĵ
 Uso       SIGAGPR                                                    
ٱ


*/
Function GprxPath()

Local cArquivo := ""
Local cType    := ""
Local cUnidade := ""
Local cCampo   := ReadVar()

cType  := STR0003 //"Arquivos Doc       (*.DOC)     | *.DOC | "
cType  += STR0004 //"Arquivos Texto     (*.TXT)     | *.TXT | "
cType  += STR0005 //"Planilhas          (*.XLS)     | *.XLS | "
cType  += STR0006 //"Todos os Arquivos  (*.*)       | *.* |   "

cArquivo := cGetFile (cType,STR0001,1,cUnidade,.T.,GETF_LOCALFLOPPY+GETF_LOCALHARD+GETF_NETWORKDRIVE) //Selecione o Anexo
cArquivo := alltrim(cArquivo)

If !empty(cArquivo) .AND. file(cArquivo) 
    &(cCampo) := cArquivo
Else
    MsgStop(STR0002 ) // "Arquivo no encontrado"
Endif

Return(.T.)

/*


Ŀ
Funo    GRPXFILE   Autora  Solange Zanardi       Data  20/10/03 
Ĵ
Descrio  Verifica se o arquivo existe, usado no SX3                 
Ĵ
Sintaxe    GRPXFILE()                                                 
Ĵ
 Uso       SIGAGPR                                                    
ٱ


*/
Function GprxFile()

Local lRet     := .T.
Local cCampArq := Readvar()  

// Se o campo no estiver em braco e no for nulo
If !Empty(Alltrim(&(cCampArq))) .AND. &(cCampArq) <> NIL 

   // Verifico a existncia do Arquivo
   If !File(&(cCampArq)) 
      MsgStop(STR0002 ) // "Arquivo no encontrado"
      lRet := .F.
   Endif    

Endif

Return( lRet )

/*


Ŀ
Funo    GprVldPesq Autor   Marcelo Kotaki        Data  10/08/04 
Ĵ
Descrio Verifica se ja existem Respostas para a pesquisa informada  
Ĵ
Sintaxe    GprxVldPesq(ExpC1,ExpC2)	                                  
          | ExpC1 - Opcao da Rotina (Inclusao,Alteracao,etc)           
          | ExpC2 - Codigo da Pesquisa                                 
Ĵ
 Uso       Pesquisa e Resultado                                       
ٱ


*/
Function GprVldPesq(nOpc,cCodPq)

Local aArea		:= GetArea() 	// Area de Trabalho
Local lRet		:= .T. 			// Retorno da Funcao

If !Empty(cCodPq)

	//Ŀ
	//Verifica se a Pesquisa esta Ativa
	//
	DbSelectArea("SKC")
	DbSetOrder(1)
	If MsSeek(xFilial("SKC") + cCodPq)
		If VAL(SKC->KC_STATUS) == ATIVA  // Se a pesquisa estiver Ativa
            // Se a operacao for diferente de Exclusao
			If nOpc <> 5
				MsgAlert(STR0008) //"A Pesquisa encontra-se Ativa por isso nao podera ser alterada"
				
			// Se a operacao for de exclusao				
			ElseIf nOpc == 5
				MsgAlert(STR0009) //"A Pesquisa encontra-se Ativa por isso nao podera ser excluida"
			Endif	
			lRet := .F.
		Endif
	Endif
	
	If lRet
		//
		//Verifica se existe Resposta para esse Questionario
		//
		DbSelectArea("SKS")
		DbSetOrder(1)	//KJ_FILIAL + KJ_CODPQ + KJ_RESPID
		If MsSeek( xFilial("SKS") + cCodPq )
			MsgAlert(STR0007) //"Ja existem Respostas relacionadas a essa Pesquisa nao e possivel modifica-la"
			lRet := .F.
		Endif
	Endif
Endif
	
// Restaura a area anterior
RestArea(aArea)
Return( lRet )

/*


Ŀ
Funo    GprVldQues Autor   Marcelo Kotaki        Data  10/08/04 
Ĵ
Descrio Verifica se existe Questionario para a Pesquisa informada   
Ĵ
Sintaxe    GprVldQues(ExpC1)		                                  
          | ExpC1 - Codigo do Questionario                             
Ĵ
 Uso       Pesquisa e Resultado                                       
ٱ


*/

Function GprVldQues(cCodQt)

Local aArea		:= GetArea() 	// Area de Trabalho
Local lRet		:= .T. 			// Retorno da Funcao

If !Empty(cCodQt)
	
	//Ŀ
	//Verifica se existe Pesquisa para esse Questionario 
	//
	DbSelectArea("SKD")
	DbSetOrder(3) 		//KD_FILIAL+KD_CODQT
	If MsSeek(xFilial("SKD") + cCodQt)
		cCodPq := SKD->KD_CODPQ
	
		//
		//Verifica se existe Resposta para essa Pesquisa 
		//
		DbSelectArea("SKJ")
		DbSetOrder(1) 						//KJ_FILIAL + KJ_CODPQ + KJ_RESPID
		If MsSeek(xFilial("SKJ") + cCodPq)
			MsgAlert(STR0007) // "Ja existem respostas relacionadas a essa Pesquisa portanto, ela nao podera ser alterada"
			lRet := .F.
		Endif

	Endif
Endif

// Restaura a area anterior
RestArea(aArea)
Return( lRet )


/*


Ŀ
Funo    GprxFQst   Autor   Henry Fila            Data  23/02/05 
Ĵ
Descrio  Monta o filtro de questoes baseados no grupo/subgrupo      
           do questionario                                            
Ĵ
Sintaxe    Gpr060FQst()                                               
Ĵ
 Uso       SIGAGPR - CONSULTA PADRAO - Consulta SXB - SKG2            
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                         
Ĵ
Marcelo K 30/05/068.11  -Bops: 100117 - Revisao do fonte            
                                                                    
                                                                    
ٱ


*/
Function GprxFQst()

Local lRet     := .F.                                               // Retorno da funcao
Local nPosGru  := AScan(aHeader,{|x| AllTrim(x[2])=="KR_CODGRU"})  	//Posicao do grupo no aCols de Questionarios
Local nPosSgr  := AScan(aHeader,{|x| AllTrim(x[2])=="KR_CODSGR"})  	//Posicao do grupo no aCols de Questionarios

If nPosGru > 0 .AND. nPosSgr > 0
	//Ŀ
	// Verifica se o subgrupo pertence ao grupo                     
	//

	Do Case
	
		//Ŀ
		// Verifica se somente o grupo esta preenchido                  
		//
	
		Case !Empty( aCols[n][nPosGru] ) .AND. Empty(	aCols[n][nPosSgr] )

			If aCols[n][nPosGru] == SKG->KG_CODGRP
				//Ŀ
				// Valida o registro a ser exibido na consulta                  
				//
				lRet := .T.
			Endif	

		//Ŀ
		// Verifica se grupo e o subgrupo estao preenchidos             
		//
		Case !Empty( aCols[n][nPosGru] ) .AND. !Empty(	aCols[n][nPosSgr] )

			If aCols[n][nPosGru] == SKG->KG_CODGRP .AND. aCols[n][nPosSgr] == SKG->KG_CODSUBG
				//Ŀ
				// Valida o registro a ser exibido na consulta                  
				//
				lRet := .T.
			Endif	
			
		OtherWise
			//Ŀ
			// Valida o registro a ser exibido na consulta                  
			//
			lRet := .T.
	EndCase
	
Endif                                                


Return( lRet ) // Retorno um valor logico esperado pela funcao


/*


Ŀ
Funo    GprxPEntr  Autor   Henry Fila            Data  23/02/05 
Ĵ
Descrio Retorna array de pesquisas ativas de um determinado pesquisa
          dor                                                         
Ĵ
Sintaxe    GprxPEntr()                                                
Ĵ
 Uso       Consultas e entrevista ativa                               
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                         
Ĵ
Henry F   29/08/07      FNC 002630/2005 - Validacao da exclusao do  
                        entrevistador                               
                                                                    
ٱ


*/
Function GprxPEntr( cPesquisador, lAtivo )

Local aArea     := GetArea()	// Armazena a area atual
Local aInfo     := {}        	// Array de retorno

#IFDEF TOP
	Local cQuery    := ""     //String da query
	Local cAliasSKC := "SKC"
	Local lQuery    := .F.    //Indica se foi executada uma query	
#ELSE
	Local cIndSKO   := "SKO"  //Alias da indregua
	Local cCondicao := ""     //Condicao da indregua
	Local cKey      := ""     //Chave de indice da indregua
	Local nIndSKO   := 0	  //Numeracao de indice da indregua
#ENDIF

DEFAULT lAtivo := .T.

//Ŀ
// Busca todas as pesquisas ativas de um pesquisador            
//
#IFDEF TOP
    lQuery := .T.
    
    cAliasSKC := "QRYSKC"
    
    cQuery := "SELECT KO_CODPQ,KC_DESC,KC_STATUS "
    cQuery += " FROM "
    cQuery += RetSqlName("SKO")+ " SKO, "
    cQuery += RetSqlName("SKC")+ " SKC "    
    cQuery += " WHERE "
    
    cQuery += "KO_FILIAL = '" + xFilial( "SKO" ) +"' AND "
    cQuery += "KO_CODPSQ = '" + cPesquisador +"' AND "    
    cQuery += "SKO.D_E_L_E_T_ = ' ' AND "    
    
    cQuery += "KC_FILIAL = '" + xFilial( "SKC" ) +"' AND "
    cQuery += "KC_CODPQ = KO_CODPQ AND "    

	//Ŀ
	//Indica se ira trazer somente pesquisas ativas
	//
    If lAtivo
	    cQuery += "KC_STATUS = '1' AND "
	Endif	    
	
    cQuery += "SKC.D_E_L_E_T_ = ' ' "
    
	cQuery := ChangeQuery(cQuery)
	DbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasSKC,.F.,.T.)
                                                                       
	While ( cAliasSKC )->( !Eof() )
	
		//Ŀ
		// Armazena no array todas as pesquisas                         
		//
		Aadd(aInfo,{( cAliasSKC )->KO_CODPQ, ( cAliasSKC )->KC_DESC})
		
	    ( cAliasSKC )->( DbSkip() )
	End

	If Empty( aInfo )
		Aadd( aInfo, { "","" } )
	Endif	

	DbSelectArea( cAliasSKC )
	DbCloseArea()
	
#ELSE              

	//Ŀ
	// Filtra todas as pesquisas em que um pesquisador esta alocado 
	//

	DbSelectArea( "SKO" )
	DbSetOrder( 1 )
	cIndSKO := CriaTrab( NIL, .F.)

	cKey      := IndexKey()
	cCondicao := 'KO_FILIAL == "'+xFilial("SKO")+'" .And.'
	cCondicao += 'KO_CODPSQ == "'+cPesquisador+'"

	IndRegua( "SKO", cIndSKO, cKey,, cCondicao, STR0010 ) //"Selecionando Registros ..."
	nIndSKO := RetIndex( "SKO" )
	DbSetIndex( cIndSKO + OrDbagExT() )
	DbSetOrder( nIndSKO + 1 )	
	
	While !Eof()

		//Ŀ
		// Posiciona no cadastro de pesquisas para buscar informacoes   
		//
		SKC->(DbSetOrder(1))
		If SKC->( MsSeek( xFilial( "SKC" ) + SKO->KO_CODPQ ) )
		
			While SKC->( !Eof() ) .AND. SKC->KC_FILIAL == xFilial( "SKC" ) .AND. ;
										SKC->KC_CODPQ == SKO->KO_CODPQ

					//Ŀ
					// Armazena no array todas as pesquisas                         
					//
					Aadd(aInfo,{ SKC->KC_CODPQ, SKC->KC_DESC} )
					
				SKC->( DbSkip() )		
			End
		
		Endif
				
		SKO->( DbSkip() )	
		
	End

	If Empty( aInfo )
		Aadd( aInfo, { "","" } )
	Endif	
                         
	DbSelectArea("SK0")
	DbClearFilter()
	RetIndex("SK0")
	Ferase(cIndSKO+OrDbagExt())

#ENDIF

//Ŀ
// Restaura a area atual                                        
//

RestArea( aArea )

Return( aInfo )   	


/*


Ŀ
Funo    GprAvalSKC Autor   Henry Fila            Data  23/02/05 
Ĵ
Descrio Rotina de avaliacao de processos da pesquisa                
                                                                      
Ĵ
Sintaxe    GprAvalSKC()                                               
Ĵ
Parametros ExpC1:Alias da tabela SKC                                  
           ExpN1:Evento da pesquisa                                   
                 [1]-Ativacao da pesquisa                             
                 [2]-Desativacao da pesquisa                          
Ĵ
 Uso       Consultas e entrevista ativa                               
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                         
Ĵ
                                                                    
                                                                    
                                                                    
ٱ


*/
Function GprAvalSKC( cAliasSKC, nEvento )

Local aArea := GetArea() //Area atual

//Ŀ
// Verifica o status atual para realizar o processo correto     
//

Do Case
	Case nEvento == 1                  

		//Ŀ
		// Verifica se existe questionario para ativacao                
		//

		If GprCanAtv( SKC->KC_CODPQ, .T. )
			RecLock( "SKC" ) 
				SKC->KC_STATUS := "1"
			MsUnlock()	
		Endif	
	
	Case nEvento == 2
		RecLock( "SKC" ) 
			SKC->KC_STATUS := "2"
		MsUnlock()	
EndCase	

//Ŀ
// Restaura a area atual                                        
//
RestArea( aArea ) 

Return( .T. )

/*


Ŀ
Funo    GprCanAtv  Autor   Henry Fila            Data  23/02/05 
Ĵ
Descrio Rotina de avaliacao de ativacao da pesquisa                 
                                                                      
Ĵ
Sintaxe    GprCanAtv( cPesquisa )                                     
Ĵ
Parametros ExpC1:Pesquisa                                             
Ĵ
 Uso       Consultas e entrevista ativa                               
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                         
Ĵ
                                                                    
                                                                    
                                                                    
ٱ


*/
Function GprCanAtv( cPesquisa, lHelp )

Local aArea    := GetArea() //Area atual
Local lCanAtv  := .T.

DEFAULT lHelp  := .F.

//Ŀ
// Verifica se existe questionarios para a pesquisa             
//
	       
SKD->( DbSetOrder( 1 ) )
If SKD->( !MsSeek( xFilial( "SKD" ) + SKC->KC_CODPQ ) )

	//Ŀ
	// Se eh para exbir o help                                      
	//
	If lHelp
		Help( " ", 1, "GPRXQUEST" )		
	Endif	
	
	lCanAtv := .F.
Endif

//Ŀ
// Restaura a area atual                                        
//
RestArea( aArea ) 

Return( lCanAtv )


/*


Ŀ
Funo    GprxLink   Autor   Henry Fila            Data  20/10/03 
Ĵ
Descrio  Gera o link oficial da pesquisa                            
Ĵ
Sintaxe    GprxLink()                                                 
Ĵ
 Uso       SIGAGPR                                                    
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                         
Ĵ
          09/08/04710                                               
                                                                    
                                                                    
ٱ


*/
Function GprxLink(cCodPesq)

Local cParam := "" 
Local cLink  := "" 

cParam := fPesq2URL( cCodPesq + "000000000000000000000000100" )
cLink  := GetSrvProfString("UrlGpr","")+"w_pgpr000.apw?cID="+cParam

Return( cLink )

/*


Ŀ
Funo    Gprtrue    Autor   Henry Fila            Data  20/10/03 
Ĵ
Descrio  Funcao de retorno verdadeiro para regra padrao             
Ĵ
Sintaxe    Gprtrue()                                                  
Ĵ
 Uso       SIGAGPR                                                    
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                         
Ĵ
          09/08/04710                                               
                                                                    
                                                                    
ٱ


*/
Function GprTrue(cCampo)

Return( .T. )

/*/


Ŀ
Funo     GprxAvalFun  Autor  Henry Fila          Data 30.03.2005
Ĵ
Descrio  Avalia se a funcao digitada e valida                       
Ĵ
Sintaxe    GprxAvalFun(ExpC1)                                         
Ĵ
Parametros ExpC1 = Funcao que sera avaliada                           
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                    
ٱ

/*/
Function GprxAvalFun(cFor)
Local lRet := .T.
//-- Variaveis Locais

If !FindFunction(cFor)
	Help(" ",1,"GPRFNCINV")
	lRet := .F.
Endif	

Return lRet


/*


Ŀ
Funo    GprPesqQuestao Autor   Henry Fila        Data  20/10/03 
Ĵ
Descrio  Busca as questoes dissertativas da pesquisa                
Ĵ
Sintaxe    GprPesqQuestao( cPesquisa )                                
Ĵ
Parametros ExpC1: Codigo da pesquisa                                  
           ExpN2: Tipo da questao a ser pesquisada                    
                  1 - Unica escolha                                   
                  2 - Multipla escolha                                
                  3 - Dissertativa                                    
           ExpN3: Tipo de exibicao                                    
                  1 - Sequencial                                      
                  2 - Colunas                                         
                  3 - Linhas                                          
Ĵ
 Uso       SIGAGPR                                                    
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                         
Ĵ
                                                                    
                                                                    
                                                                    
ٱ


*/

Function GprPesqQuestao( cPesquisa, nTipoQst, nTipoExib )

Local aArea     := GetArea()
Local aQuestoes := {}
Local cTipoQst  := ""
Local cTipoExib := ""                      

DEFAULT nTipoQst := 3
DEFAULT nTipoExib:= 1

//Ŀ
// Compatiliza a busca conforme o dicionario de dados                  
//
cTipoQst  := Alltrim( Str( nTipoQst  ) )
cTipoExib := Alltrim( Str( nTipoExib ) )

//Ŀ
// Busca os questionarios da pesquisa                                  
//
DbSelectarea("SKD")
SKD->( DbSetOrder( 1 ) )
If SKD->( MsSeek( xFilial( "SKD" ) + cPesquisa ) )
	
	While 	SKD->( !Eof() ) 					.AND.;
		SKD->KD_FILIAL == xFilial( "SKD" ) 	.AND.;
		SKD->KD_CODPQ == cPesquisa
		
		//Ŀ
		// Busca as questoes por questionario                                  
		//
		DbSelectarea("SKR")
		SKR->( DbSetOrder( 1 ) )
		If SKR->( MsSeek( xFilial( "SKR" ) + SKD->KD_CODQT ) )
			
			While 	SKR->( !Eof() ) 					.AND.;
					SKR->KR_FILIAL == xFilial( "SKR" ) 	.AND.;
					SKR->KR_CODQUE == SKD->KD_CODQT
				
				//Ŀ
				// Analisa a combinacao das questoes x questionarios                   
				//
				Do Case
					Case !Empty( SKR->KR_CODQST )
						
						//Ŀ
						// Busca dados da questao e inclui no array                            
						//
						DbSelectarea("SKG")
						SKG-> ( DbSetOrder( 1 ) )
						If SKG->( MsSeek( xFilial( "SKG" ) + SKR->KR_CODQST ) )
							
							Do Case
								
								Case cTipoQst == "0" .AND. cTipoExib == "0"
									AAdd( aQuestoes ,{-1, SKG->KG_CODQST, SKG->KG_DESC, Alltrim( Str( SKG->KG_PONTO ) ) } )
									
								Case SKG->KG_TIPOQST == cTipoQst .AND. cTipoQst == "3"
									AAdd( aQuestoes ,{-1, SKG->KG_CODQST, SKG->KG_DESC, Alltrim( Str( SKG->KG_PONTO ) ) } )
									
								Case SKG->KG_TIPOQST == cTipoQst .AND. SKG->KG_TIPEXIB == cTipoExib
									AAdd( aQuestoes ,{-1, SKG->KG_CODQST, SKG->KG_DESC, Alltrim( Str( SKG->KG_PONTO ) ) } )
									
							EndCase
						Endif
						
					Case !Empty( SKR->KR_CODGRU ) .AND. !Empty( SKR->KR_CODSGR )
						
						//Ŀ
						// Busca dados da questao e inclui no array                            
						//
						DbSelectarea("SKG")
						SKG-> ( DbSetOrder( 2 ) )
						If SKG->( MsSeek( xFilial( "SKG" ) + SKR->KR_CODGRU + SKR->KR_CODSGR ) )
							
							While 	SKG->( !Eof() ) 					.AND.;
								SKG->KG_FILIAL == xFilial( "SKG" ) 	.AND.;
								SKG->KG_CODGRP == SKD->KR_CODGRU 	.AND.;
								SKG->KG_CODSUBG == SKD->KR_CODSGR
								
								Do Case
									Case cTipoQst == "0" .AND. cTipoExib == "0"
										AAdd( aQuestoes ,{-1, SKG->KG_CODQST, SKG->KG_DESC, Alltrim( Str( SKG->KG_PONTO ) ) } )
										
									Case SKG->KG_TIPOQST == cTipoQst .AND. cTipoQst == "3"
										AAdd( aQuestoes ,{-1, SKG->KG_CODQST, SKG->KG_DESC, Alltrim( Str( SKG->KG_PONTO ) ) } )
										
									Case SKG->KG_TIPOQST == cTipoQst .AND. SKG->KG_TIPEXIB == cTipoExib
										AAdd( aQuestoes ,{-1, SKG->KG_CODQST, SKG->KG_DESC, Alltrim( Str( SKG->KG_PONTO ) ) } )
								EndCase
								
								SKG->( DbSkip() )
							End
							
						Endif
						
					Case !Empty( SKR->KR_CODGRU ) .AND. Empty( SKR->KR_CODSGR )
						
						//Ŀ
						// Busca dados da questao e inclui no array                            
						//
						DbSelectarea("SKG")
						SKG-> ( DbSetOrder( 2 ) )
						If SKG->( MsSeek( xFilial( "SKG" ) + SKR->KR_CODGRU ) )
							
							While 	SKG->( !Eof() ) 					.AND.;
								SKG->KG_FILIAL == xFilial( "SKG" ) 	.AND.;
								SKG->KG_CODGRP == SKR->KR_CODGRU
								
								Do Case
									
									Case cTipoQst == "0" .AND. cTipoExib == "0"
										AAdd( aQuestoes ,{-1, SKG->KG_CODQST, SKG->KG_DESC, Alltrim( Str( SKG->KG_PONTO ) ) } )
										
									Case SKG->KG_TIPOQST == cTipoQst .AND. cTipoQst == "3"
										AAdd( aQuestoes ,{-1, SKG->KG_CODQST, SKG->KG_DESC, Alltrim( Str( SKG->KG_PONTO ) ) } )
										
									Case SKG->KG_TIPOQST == cTipoQst .AND. SKG->KG_TIPEXIB == cTipoExib
										AAdd( aQuestoes ,{-1, SKG->KG_CODQST, SKG->KG_DESC, Alltrim( Str( SKG->KG_PONTO ) ) } )
								Endcase
								
								SKG->( DbSkip() )
							End
							
						Endif
						
				EndCase
				
				SKR->( DbSkip() )
			End
		Endif
		
		SKD->( DbSkip() )
	End
	
Endif

//Ŀ
// Restaura a area de trabalho                                         
//

RestArea( aArea )

Return( aQuestoes )

/*


Ŀ
Funo    GprTabAnalyser Autor   Henry Fila        Data  20/10/03 
Ĵ
Descrio  Busca os respondentes da pesquisa                          
Ĵ
Sintaxe    GprTabAnalyser( nEvento, cPesquisa )                       
Ĵ
Parametros ExpN1: Evento                                              
                  1 - Quantidade de respostas                         
           ExpC2: Codigo da pesquisa                                  
Ĵ
 Uso       SIGAGPR                                                    
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                         
Ĵ
                                                                    
                                                                    
                                                                    
ٱ


*/

Function GprTabAnalyser( nEvento, cCodPesq )   

Local aArea  := GetArea()
Local aRet   := {}
Local bWhile := { || (cAliasSKS)->( !Eof() ) }

#IFDEF TOP
	Local cQuery    := ""     //String da query
	Local cAliasSKS := "SKS"
	Local lQuery    := .F.    //Indica se foi executada uma query	
#ENDIF

//Ŀ
//Estrutura do array de retorno   
//                                
//  [1]-Quantidade de respondentes
//

Do Case
	Case nEvento == 1
		
		#IFDEF TOP
		
		    lQuery := .T.
		    
		    cAliasSKS := "QRYSKS"
		    
		    cQuery := "SELECT * "
		    cQuery += " FROM "
		    cQuery += RetSqlName("SKS")+ " SKS "
		    cQuery += " WHERE "
		    
		    cQuery += "KS_FILIAL = '" + xFilial( "SKS" ) +"' AND "
		    cQuery += "KS_CODPESQ = '" + cCodPesq +"' AND "    
		    cQuery += "SKS.D_E_L_E_T_ = ' ' "
		    
			cQuery := ChangeQuery(cQuery)
			DbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasSKS,.F.,.T.)

			aEval(SKS->(DbStruct()), {|x| If(x[2] <> "C", TcSetField(cAliasSKS ,x[1],x[2],x[3],x[4]),Nil)})
		
	
		#ELSE                              
			
			SKS->( DbSetOrder( 1 ) )
			SKS->( MsSeek( xFilial( "SKS" ) + cCodResp ) )
            
			bWhile := { SKS->( !Eof() ) .AND. SKS->KS_FILIAL == xFilial( "SKS" ) .AND. SKS->KS_CODPESQ == cCodResp }

		#ENDIF
			
		While Eval( bWhile )		

			Aadd( aRet, {	( cAliasSKS )->KS_CODRESP	,;
							( cAliasSKS )->KS_DATINI	,;
							( cAliasSKS )->KS_DATFIM	,;
							( cAliasSKS )->KS_HORAINI	,;
							( cAliasSKS )->KS_HORAFIM } )

			(cAliasSKS)->( DbSkip()	 )
		End

EndCase	

If lQuery
	(cAliasSKS)->( DbCloseArea() )
Endif

DbSelectArea( "SKS" )

RestArea( aArea )

Return( aRet )



