#include "totvs.ch"
#include 'tlpp-core.th'
#include 'AGD.DTA.TOKEN.SERVICE.CH'

namespace agd.dtaTokenService

using namespace agd.utilsService

/*/{Protheus.doc} agdTCOservice
Classe de serviços do TCO
@type class
@version 12
@author claudineia.reinert
@since 18/11/2025
/*/
class agdDTATokenService FROM agdUtilsService
	private Data cParametroToken As Character
	private Data cTokenParametro As Character

	public method new()
	public method registrarToken() 
	public method existeToken() as Logical
	public method descriptografarToken() as Character

    private method validarTokenHttp() as Logical
    private method criptografarToken() as Character
	
endClass

/*/{Protheus.doc} new
Construtor
@type method
@version 12
@author claudineia.reinert
@since 18/11/2025
@return object, Instancia da classe
/*/
method new() class agdDTATokenService
	Self:cParametroToken := "MV_AGD0005"
	Self:cTokenParametro := SuperGetMV(Self:cParametroToken, .F., "")
	_Super:New()
return Self


/*/{Protheus.doc} agdDTATokenService::registrarToken
Valida se o token é valido, criptografa e registra no parâmetro
@type method
@version P12
@author claudineia.reinert
@since 18/11/2025
@param jCmdRegistrar, json, dados para registro do token
*/
method registrarToken(jCmdRegistrar as Json)  class agdDTATokenService
	Local cToken := ""
	Local cTokenCriptografado := ""
	Local lGravouParam := .F.
	
	// Valida se o JSON contém a chave 'token'
	If !jCmdRegistrar:hasProperty("token")
		Self:setError(STR0001) //"Token não informado!"
		Return nil
	EndIf
	
	// Obtém o valor do token
	cToken := jCmdRegistrar["token"]
	
	// Valida se o token é uma string válida
	If ValType(cToken) != "C" .Or. Empty(AllTrim(cToken))
		Self:setError(STR0002) //"Tipo do Token inválido!"
		Return nil
	EndIf

	if self:validarTokenHttp(cToken) == .F.
		// O erro já foi definido no método validarTokenHttp
		Return nil
	EndIf
	
	// Criptografa o token
	cTokenCriptografado := Self:criptografarToken(cToken)
	
	// Grava o token criptografado no parâmetro
	lGravouParam := PutMV(Self:cParametroToken, cTokenCriptografado)
	
	If !lGravouParam
		Self:setError(STR0003) //"Erro ao gravar o token!"
	Else
		Self:setSuccess()
		self:cTokenParametro := cTokenCriptografado
	EndIf

return nil

/*/{Protheus.doc} criptografarToken
Criptografa uma string de token usando WebEncript
@type method
@version 12
@author claudineia.reinert
@since 18/11/2025
@param cToken, character, Token a ser criptografado
@return character, Token criptografado
/*/
method criptografarToken(cToken as Character) as Character class agdDTATokenService
	Local cTokenCriptografado := ""
	
	// Criptografa o token usando WebEncript
	cTokenCriptografado := Encode64( WebEncript( cToken ) )
	
Return cTokenCriptografado

/*/{Protheus.doc} descriptografarToken
Descriptografa o token criptografado armazenado no parâmetro MV_AGD0005
@type method
@version 12
@author claudineia.reinert
@since 18/11/2025
@param cTokenCriptografado, character, Token criptografado a ser descriptografado
@return character, Token descriptografado
*/
method descriptografarToken() as Character class agdDTATokenService
	Local cTokenDescriptografado := ""
	
	Local cTokenCriptografado := self:cTokenParametro
	
	// Valida se o token criptografado foi informado
	If Empty(cTokenCriptografado)
		Self:setError(STR0001) //"Token não informado!"
        Return ""
	EndIf
	
	// Descriptografa o token usando WebEncript 
	cTokenDescriptografado := WebEncript( Decode64( cTokenCriptografado ), .T. )
	
Return cTokenDescriptografado

/*/{Protheus.doc} existeToken
Verifica se existe token gravado no parâmetro
@type method
@version 12
@author claudineia.reinert
@since 18/11/2025
@return logical, .T. se existe token válido, .F. caso contrário
*/
method existeToken() as Logical class agdDTATokenService
	Local cTokenParam := ""
	Local lTokenExiste := .F.
	Local jResponse  := JsonObject():New()
	
	jResponse['existToken']   := "false"
	// Obtém o valor do parâmetro
	cTokenParam := Self:cTokenParametro
	
	// Verifica se o parâmetro existe e não está vazio
	If !Empty(AllTrim(cTokenParam))
		lTokenExiste := .T.
		jResponse['existToken']   := "true"
	EndIf

	Self:setSuccess(jResponse)
	
Return lTokenExiste

/*/{Protheus.doc} validarTokenHttp
Valida o token fazendo requisição direta usando HttpPost() na API do DTA
@type method
@version 12
@author claudineia.reinert
@since 18/11/2025
@return logical, .T. se o token é válido, .F. caso contrário
*/
method validarTokenHttp(cToken as Character) as Logical class agdDTATokenService
	Local lValid := .F. as Logical
	Local cURL := "https://proxy.dta.totvs.ai/v1/chat/completions" as Character
	Local cHeaderRet := "" as Character
	Local cPostRet := "" as Character
	Local nTimeOut := 60 as Numeric
	Local aHeadStr := {} as Array
	Local cPostParms := "" as Character
	Local nHTTPCode := 0 as Numeric

	// Prepara os headers
	Aadd(aHeadStr, "Accept: application/json")
	Aadd(aHeadStr, "Content-Type: application/json")
	Aadd(aHeadStr, "Authorization: Bearer " + cToken)

	// Prepara o JSON de teste baseado na especificação
	cPostParms := '{'
	cPostParms += '"model": "gpt-4.1-mini",'
	cPostParms += '"messages": ['
	cPostParms += '{'
	cPostParms += '"role": "user",'
	cPostParms += '"content": "Hello!"'
	cPostParms += '}'
	cPostParms += ']'
	cPostParms += '}'

	// Executa a requisição HTTP POST
	cPostRet := HttpPost(cURL, "", cPostParms, nTimeOut, aHeadStr, @cHeaderRet)

	// Obtém o código de status HTTP do header de retorno
	If "HTTP/" $ cHeaderRet
		nHTTPCode := Val(SubStr(cHeaderRet, At(" ", cHeaderRet) + 1, 3))
	EndIf

	// Verifica se a requisição foi bem-sucedida
	If nHTTPCode == 200
		lValid := .T.
	Else
		lValid := .F.
		Self:setError(STR0004 + cValToChar(nHTTPCode) ) //"Ocorreu um erro na validação do token informado. Contacte o administrador do sistema. Status: "
	EndIf

Return lValid

