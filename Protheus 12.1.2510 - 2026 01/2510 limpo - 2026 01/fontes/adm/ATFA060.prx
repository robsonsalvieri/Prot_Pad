#Include 'Protheus.ch'
#Include 'FWMVCDEF.ch'
#Include 'ATFA060.CH'
#Include "FWLIBVERSION.CH"


//AVP
Static aAvpCtbO		:= {}
Static aAvpCtbD		:= {}
Static lA060robo	:= .F.
//Taxa da moeda
Static nTaxaDepr	:= 0

//Se é execauto
Static lAuto		:= .T.

// Controle de multiplas moedas
Static lMultMoed	:= .T.

//Variavel de Controle do Rateio
Static __lExisEnt	:= .T.

Static lFN9			:= .T.

Static aCamposAlt	:= {}

//Variavel para de visualização
Static lVisu	:= .F.

//Variavel para Controlar a exibição da mensagem de Grupo
Static lMsgGrupo	:= .F.

Static __cProcPrinc :="ATFA060"

//Static aFN9CpoUsr   := NIL
Static aFN9CpoUsr   := {} // Alterado por Edu da FSW EM 19/06/16 p/ oModel ser utilizado de outro PRW

Static lPeAF060GRP  := ExistBlock("AF060GRP")

//Objeto para a classe FwTemporaryTable (Cria tabela temporária no banco de dados)
Static _oATFA0601

Static __nAtuGrp	:= 2 //1-Atualiza/2-Espelha (considera campos em branco na SNG)/3-Nao Atualiza
Static __lEspGrp	:= .T.

STATIC lIsRussia	:= If(cPaisLoc$"RUS",.T.,.F.) // CAZARINI - Flag to indicate if is Russia location
STATIC _lAtEntAd	:= .F.
STATIC _lShowMsg    := .T.

Static __lMetric	:= FwLibVersion() >= "20210517" .And. GetSrvVersion() >= "19.3.0.6" //Metricas apenas em Lib a partir de 20210517 e Binario 19.3.0.6

Static __aCTBEnt 	:= {}
Static __lEntAdd    := .F. //Vejo apenas nesse campo para identificar se o wizard dos campos foi executado

Static __aLockSN5   := {}

/*{Protheus.doc} ATFA060.prw
Transferencia de Ativos
@author José Augusto Ribeiro
@since 08/05/2015
@version P12
@menu SIGATF->Atualizações ->Movimentos
*/
Function ATFA060(xAtivo As Array, nOpcAuto As Numeric, xParam As Array, lEspelha As Logical) As Logical
Local lRet			As Logical
Local oBrowse		As Object
Local nI			As Numeric
Local aRet			As Array
Local aParam		As Array
Local lAF060BRW		As Logical
Local cFiltro		As Character

Private aRotina		As Array
Private cCadastro	As Character
Private cBaseAuto	As Character
Private cItemAuto	As Character
Private cTipoAuto	As Character
Private aParamAuto	As Array
Private cN4_HORA	As Character
Private lAtfAuto	As Logical

Private aFlagCTB	As Array

Private aEmp	as array
Private cUsrRul	as character
Private lUsrAdm	as logical
Private lAllEmp	as logical

DEFAULT xAtivo		:= {}
DEFAULT nOpcAuto	:= 0
DEFAULT xParam		:= {}
DEFAULT lEspelha	:= .T.

lRet        := .T.
oBrowse     := NIL
nI          := 0
aRet        := {}
aParam      := {}
lAF060BRW   := ExistBlock("AF060BRW")
cFiltro     := ""

aRotina     := MenuDef()
cCadastro	:= STR0005	// "Transferência de Ativos para chamar a função  da legenda
cBaseAuto	:= ""
cItemAuto	:= ""
cTipoAuto	:= ""
aParamAuto	:= {}
cN4_HORA	:= SubStr(Time(),1,5)
lAtfAuto	:= .F.      //Variável para saber se a rotina e de ExecAuto

aFlagCTB	:= {} //Flag para contabilizaç?o Ativo

__aCTBEnt   := CTBEntArr()

__lEspGrp	:= lEspelha

AF060UsInf()

If(Len(xAtivo) > 0 .And. nOpcAuto != 0)

	lAtfAuto := .T.

EndIf

//If aFN9CpoUsr == NIL
If aFN9CpoUsr == NIL .OR. Len(aFN9CpoUsr) == 0 // Alterado por Edu da FSW EM 19/06/16 p/ oModel ser utilizado de outro PRW
	aFN9CpoUsr := AF060CpUsr("FN9")
EndIf

If(!lAtfAuto)

	oBrowse := FWMBrowse():New()
	oBrowse:SetAlias("SN3")
	oBrowse:SetDescription(STR0005)//"Transferência de Ativos"
	oBrowse:AddLegend( "N3_BAIXA == '0' .AND. !AfxLegTran()"							,"GREEN"	,STR0114) //"Ativo Fixo Vigente"
	oBrowse:AddLegend( "N3_BAIXA > '0' .And. !Empty(N3_DTBAIXA) .AND. !AfxLegTran()"	,"RED"		,STR0115)//"Ativo Fixo Baixado"
	oBrowse:AddLegend( "AfxLegTran()"													,"PINK"		,STR0116)//"Ativo Transferido de Filial"
	If(lAF060BRW)
		cFiltro := ExecBlock("AF060BRW",.F.,.F.)
		oBrowse:SetFilterDefault(cFiltro)
	EndIf
	oBrowse:Activate()
	lRet := .T.
Else
	SN3->(DbSetOrder(1))

	aParamAuto := xParam
	For nI := 1 To Len(xAtivo)

		If(xAtivo[nI][1] == "N3_CBASE")

			cBaseAuto := xAtivo[nI][2]

		ElseIf(xAtivo[nI][1] == "N3_ITEM")

			cItemAuto := xAtivo[nI][2]

		ElseIf(xAtivo[nI][1] == "N3_TIPO")

			cTipoAuto := xAtivo[nI][2]

		ElseIf(!Empty(cTipoAuto) .And. !Empty(cItemAuto) .And. !Empty(cBaseAuto))

			Exit

		ElseIf(xAtivo[nI][1] == "N4_HORA")

			cN4_HORA := xAtivo[nI][2]

		EndIf
	Next nI
	If(SN3->(DbSeek(xFilial("SN3")+cBaseAuto+cItemAuto+cTipoAuto)))

		If !nOpcAuto == 7
			lRet := AF060AutRot(xAtivo,nOpcAuto,aParam)
		Else
			AF060CaTra("SN3",SN3->(RECNO()),7,.T.)

		EndIf

	Else

		lRet := .F.

	EndIf
EndIf

aFN9CpoUsr := {} // Alterado por Edu da FSW EM 19/06/16 p/ oModel ser utilizado de outro PRW

Return lRet

/*{Protheus.doc}MenuDef
Cria os Menus para visualizar
@author Jose Augusto Ribeiro
@since 08/05/2015
@version P12
@return aRotina , Vetor,Vetor com as opções da Rotina do Vetor
*/
Static Function MenuDef()
	Local aRot			:= {}
	Local aRotNew		:= {}
	Local nX			:= 0

	ADD OPTION aRot Title STR0003		ACTION 'ATF060TRAN'			OPERATION 4 ACCESS 0 //'Transferir'
	ADD OPTION aRot Title STR0004		ACTION 'AF060Auto'			OPERATION 3 ACCESS 0 //"Automatico" 'Transferir em Lote'
	ADD OPTION aRot Title STR0046		ACTION 'AF190Trans(1)'		OPERATION 7 ACCESS 0 //'Transf.Resp.'
	ADD OPTION aRot Title STR0089		ACTION 'CTBC662'			OPERATION 8 ACCESS 0 //'Tracker Contábil'
	ADD OPTION aRot Title STR0002		ACTION 'ATFA060Vis'			OPERATION 2 ACCESS 0 //'Visualizar'
	ADD OPTION aRot Title STR0157		ACTION 'ATF060VTR'			OPERATION 2 ACCESS 0 //'Visualizar Transferencia'

	// Adiciona a opção de cancelamento da transferencia entre filiais ou  transferência contábil
	If SuperGetMv("MV_ATFCATR",.F.,'2') == '1'
		// Foi definida a opcao 3 pois a filial é posicionada corretamente, diferente
		// das outras opcoes, em que a posicao do browse define a filial para query
		Aadd(aRot, {STR0090,"AF060CaTra",0,3})	// "Canc. Transf."
	EndIf

	ADD OPTION aRot Title STR0217		ACTION 'AFA060LOG'				OPERATION 8 ACCESS 0 //"Log Proc."

	//Ponto de entrada para inclusao de botao no arotina
	If ExistBlock("AF060BUT")
		aRotNew := ExecBlock("AF060BUT",.F.,.F.,{aRot})
		For nX := 1 To len(aRotNew)
			aAdd(aRot,aRotNew[nX])
		Next
	Endif

Return aRot

/*{Protheus.doc} ModelDef
Model da Rotina da Transferencia de Ativo
@author Jose Augusto Ribeiro
@since 08/05/2015
@version P12
@return oModel ,Objeto , Modelo da Rotina Transferencia de Ativo
*/
Static Function ModelDef() As Object
//Criando a Estrutura do Model
Local oStruFn9	  As Object
Local oStruFns	  As Object
Local oStruFnr	  As Object
Local oModel	  As Object
Local lCmpDesp 	  As Logical
Local nQtdVol     As Numeric
Local nM          As Numeric
Local cMVATFCPMN  As Character
Local aCpoMarFN9  As Array
Local cCpoMarFN9  As Character
Local cCpoNumFN9  As Character
Local nContEnt	  As Numeric
Local lVldNewInv  As Logical

oStruFn9	:= FWFormStruct( 1, 'FN9', /*bAvalCampo*/,/*lViewUsado*/ )
oStruFns	:= FWFormStruct( 1, 'FNS', /*bAvalCampo*/,/*lViewUsado*/ )
oStruFnr	:= FWFormStruct( 1, 'FNR', /*bAvalCampo*/,/*lViewUsado*/ )
oModel	  	:= NIL
lCmpDesp 	:= FNS->(FieldPos("FNS_ITDESD")) > 0 // campo item despesa e classe de valor despesa no mesmo pacote 012450
nQtdVol     := QTDVOLNF()
nM          := 0
cMVATFCPMN  := AllTrim(SuperGetMV('MV_ATFCPMN',, ''))
aCpoMarFN9  := {}
cCpoMarFN9  := ''
cCpoNumFN9  := ''
nContEnt	:= 0
lVldNewInv	:= If(FindFunction("ATFVldNInv"),ATFVldNInv(),.F.)

__lEntAdd 	:= oStruFns:HasField("FNS_EC05DO")

If !Empty(cMVATFCPMN)
	aCpoMarFN9 := StrTokArr2(cMVATFCPMN, ";", .T.)
EndIf

If Len(aCpoMarFN9) >= 4
	cCpoMarFN9 := AllTrim(aCpoMarFN9[3])
	cCpoNumFN9 := AllTrim(aCpoMarFN9[4])
EndIf

// Alterado por Edu da FSW EM 19/06/16 p/ oModel ser utilizado de outro PRW
If aFN9CpoUsr == NIL .OR. Len(aFN9CpoUsr) == 0
	aFN9CpoUsr := AF060CpUsr("FN9")
EndIf

//Adicionando o Campo Check
oStruFnr:AddField(STR0170,STR0171 , 'OK', 'L', 1, 0, {||AF060VLATF(oModel:GetModel('GridFNR'):GetValue('FNR_FILDES'),oModel:GetModel('GridFNR'):GetValue('FNR_CBAORI'), oModel:GetModel('GridFNR'):GetValue('FNR_ITEORI'), .F.)} ,{||FWIsInCallStack('AF060Auto') } , {}	, .F.	, , .F., .F., .F., , )//'Transfere?'#//'Seleção'
oStruFns:AddField(' ',' ' , 'OK', 'L', 1, 0,{|| VldMarkFNS(oModel) }	,{||.T. } , {}	, .F.	, , .F., .F., .F., , )//'Baixa?'#//'Seleção'
oStruFn9:AddField(STR0172,STR0172 , 'TOTBEM', 'N', 10, 0, /*bValid*/	,{||.F. } , {}	, .F.	, , .F., .F., .F., , )//'Total de Bens'#//'Total de Bens'

//Gatilhos FN9 - Dados Gerais
oStruFn9:AddTrigger('FN9_FILDES','FN9_FILDES',{|| .T. },{||AF060TRG("FN9_FILDES" )})
oStruFn9:AddTrigger('FN9_DATA'  ,'FN9_DATA'  ,{|| .T. },{||AF060TRG("FN9_DATA"   )})
oStruFn9:AddTrigger('FN9_GRPDES','FN9_GRPDES',{|| .T. },{||AF060TRG("FN9_GRPDES" )})
oStruFn9:AddTrigger('FN9_LOCDES','FN9_LOCDES',{|| .T. },{||AF060TRG("FN9_LOCDES" )})
oStruFn9:AddTrigger('FN9_TXPADD','FN9_TXPADD',{|| .T. },{||AF060TRG("FN9_TXPADD" )})
oStruFn9:AddTrigger('FN9_CCDESD','FN9_CCDESD',{|| .T. },{||AF060TRG("FN9_CCDESD" )})
oStruFn9:AddTrigger('FN9_QTDDES','FN9_QTDDES',{|| .T. },{||AF060TRG("FN9_QTDDES" )})
If lCmpDesp
	oStruFn9:AddTrigger('FN9_ITDESD','FN9_ITDESD',{|| .T. },{||AF060TRG("FN9_ITDESD" )})
	oStruFn9:AddTrigger('FN9_CVDSPD','FN9_CVDSPD',{|| .T. },{||AF060TRG("FN9_CVDSPD" )})
EndIf

//Gatilhos FN9 - Conta Contabil
oStruFn9:AddTrigger('FN9_CONTAD','FN9_CONTAD',{|| .T. },{||AF060TRG("FN9_CONTAD" )})
oStruFn9:AddTrigger('FN9_CONCOD','FN9_CONCOD',{|| .T. },{||AF060TRG("FN9_CONCOD" )})
oStruFn9:AddTrigger('FN9_CONDDD','FN9_CONDDD',{|| .T. },{||AF060TRG("FN9_CONDDD" )})
oStruFn9:AddTrigger('FN9_CONDAD','FN9_CONDAD',{|| .T. },{||AF060TRG("FN9_CONDAD" )})
oStruFn9:AddTrigger('FN9_CONCDD','FN9_CONCDD',{|| .T. },{||AF060TRG("FN9_CONCDD" )})

//Gatilhos FN9 - Centro de custo
oStruFn9:AddTrigger('FN9_CCBEMD','FN9_CCBEMD',{|| .T. },{||AF060TRG("FN9_CCBEMD" )})
oStruFn9:AddTrigger('FN9_CCCORD','FN9_CCCORD',{|| .T. },{||AF060TRG("FN9_CCCORD" )})
oStruFn9:AddTrigger('FN9_CCDDD' ,'FN9_CCDDD' ,{|| .T. },{||AF060TRG("FN9_CCDDD"  )})
oStruFn9:AddTrigger('FN9_CCDAD' ,'FN9_CCDAD' ,{|| .T. },{||AF060TRG("FN9_CCDAD"  )})
oStruFn9:AddTrigger('FN9_CCCDD' ,'FN9_CCCDD' ,{|| .T. },{||AF060TRG("FN9_CCCDD"  )})

//Gatilhos FN9 - Item Contabil
oStruFn9:AddTrigger('FN9_ITBEMD','FN9_ITBEMD',{|| .T. },{||AF060TRG("FN9_ITBEMD" )})
oStruFn9:AddTrigger('FN9_ITCORD','FN9_ITCORD',{|| .T. },{||AF060TRG("FN9_ITCORD" )})
oStruFn9:AddTrigger('FN9_ITDEDD','FN9_ITDEDD',{|| .T. },{||AF060TRG("FN9_ITDEDD" )})
oStruFn9:AddTrigger('FN9_ITDEAD','FN9_ITDEAD',{|| .T. },{||AF060TRG("FN9_ITDEAD" )})
oStruFn9:AddTrigger('FN9_ITCDED','FN9_ITCDED',{|| .T. },{||AF060TRG("FN9_ITCDED" )})

//Gatilhos FN9 - Classe de Valor
oStruFn9:AddTrigger('FN9_CVBEMD','FN9_CVBEMD',{|| .T. },{||AF060TRG("FN9_CVBEMD" )})
oStruFn9:AddTrigger('FN9_CVCORD','FN9_CVCORD',{|| .T. },{||AF060TRG("FN9_CVCORD" )})
oStruFn9:AddTrigger('FN9_CVDEPD','FN9_CVDEPD',{|| .T. },{||AF060TRG("FN9_CVDEPD" )})
oStruFn9:AddTrigger('FN9_CVCDED','FN9_CVCDED',{|| .T. },{||AF060TRG("FN9_CVCDED" )})
oStruFn9:AddTrigger('FN9_CVDESD','FN9_CVDESD',{|| .T. },{||AF060TRG("FN9_CVDESD" )})

//Gatilhos FN9 - Entidades adicionais
If Len(__aCTBEnt) > 0 .AND. __lEntAdd
	For nContEnt := 1 to Len(__aCTBEnt)
		oStruFn9:AddTrigger('FN9_EC'+__aCTBEnt[nContEnt]+'DD','FN9_EC'+__aCTBEnt[nContEnt]+'DD',{|| .T. },{|oModel, cField, cValue|GATTRANSP(oModel, cField, cValue) })
		oStruFn9:AddTrigger('FN9_EC'+__aCTBEnt[nContEnt]+'CD','FN9_EC'+__aCTBEnt[nContEnt]+'CD',{|| .T. },{|oModel, cField, cValue|GATTRANSP(oModel, cField, cValue) })
	Next nContEnt
EndIf

//Gatilhos FN9 - Nota Fiscal
oStruFn9:AddTrigger('FN9_GERNF' ,'FN9_GERNF' ,{|| .T. },{||AF060TRG("FN9_GERNF"  )})
oStruFn9:AddTrigger('FN9_SERIE' ,'FN9_SERIE' ,{|| .T. },{||AF060TRG("FN9_SERIE"  )})
oStruFn9:AddTrigger('FN9_CLSNF' ,'FN9_CLSNF' ,{|| .T. },{||AF060TRG("FN9_CLSNF"  )})
oStruFn9:AddTrigger('FN9_TESSAI','FN9_TESSAI',{|| .T. },{||AF060TRG("FN9_TESSAI" )})
oStruFn9:AddTrigger('FN9_TESENT','FN9_TESENT',{|| .T. },{||AF060TRG("FN9_TESENT" )})
oStruFn9:AddTrigger('FN9_VALNF' ,'FN9_VALNF' ,{|| .T. },{||AF060TRG("FN9_VALNF"  )})

If oStruFN9:HasField("FN9_ESPECI")
	oStruFn9:AddTrigger('FN9_ESPECI' ,'FN9_ESPECI' ,{|| .T. },{||AF060TRG("FN9_ESPECI"  )})
EndIf

If oStruFN9:HasField("FN9_ARMAZE")
	oStruFn9:AddTrigger('FN9_ARMAZE' ,'FN9_ARMAZE' ,{|| .T. },{||AF060TRG("FN9_ARMAZE"  )})
EndIf

// Gatilhos FN9 - Dados do Transporte.
If oStruFN9:HasField("FN9_TRANSP")
	oStruFn9:AddTrigger('FN9_TRANSP' ,'FN9_TRANSP' ,{|| .T. },{||AF060TRG("FN9_TRANSP"  )})
EndIf
If oStruFN9:HasField("FN9_TPFRET")
	oStruFn9:AddTrigger('FN9_TPFRET' ,'FN9_TPFRET' ,{|| .T. },{||AF060TRG("FN9_TPFRET"  )})
EndIf
If oStruFN9:HasField("FN9_PESOL")
	oStruFn9:AddTrigger('FN9_PESOL' ,'FN9_PESOL' ,{|| .T. },{||AF060TRG("FN9_PESOL"  )})
EndIf
If oStruFN9:HasField("FN9_PBRUTO")
	oStruFn9:AddTrigger('FN9_PBRUTO' ,'FN9_PBRUTO' ,{|| .T. },{||AF060TRG("FN9_PBRUTO"  )})
EndIf
For nM := 1 To nQtdVol // Tratamento para até 9 volumes.
	If oStruFN9:HasField("FN9_VOLUM" + AllTrim(Str(nM)))
		oStruFn9:AddTrigger('FN9_VOLUM' + AllTrim(Str(nM)) ,'FN9_VOLUM' + AllTrim(Str(nM)) ,{|| .T. },{|oModel, cField, cValue|GATTRANSP(oModel, cField, cValue)  })
	EndIf
	If oStruFN9:HasField("FN9_ESPEC" + AllTrim(Str(nM)))
		oStruFn9:AddTrigger('FN9_ESPEC' + AllTrim(Str(nM)) ,'FN9_ESPEC' + AllTrim(Str(nM)) ,{|| .T. },{|oModel, cField, cValue|GATTRANSP(oModel, cField, cValue)  })
	EndIf
	If oStruFN9:HasField("FN9_VEICU" + AllTrim(Str(nM)))
		oStruFn9:AddTrigger('FN9_VEICU' + AllTrim(Str(nM)) ,'FN9_VEICU' + AllTrim(Str(nM)) ,{|| .T. },{|oModel, cField, cValue|GATTRANSP(oModel, cField, cValue)  })
	EndIf
	If oStruFN9:HasField(cCpoMarFN9 + AllTrim(Str(nM)))
		oStruFn9:AddTrigger(cCpoMarFN9 + AllTrim(Str(nM)) ,cCpoMarFN9 + AllTrim(Str(nM)) ,{|| .T. },{|oModel, cField, cValue|GATTRANSP(oModel, cField, cValue)  })
	EndIf
	If oStruFN9:HasField(cCpoNumFN9 + AllTrim(Str(nM)))
		oStruFn9:AddTrigger(cCpoNumFN9 + AllTrim(Str(nM)) ,cCpoNumFN9 + AllTrim(Str(nM)) ,{|| .T. },{|oModel, cField, cValue|GATTRANSP(oModel, cField, cValue)  })
	EndIf
Next nM

//Gatilhos FNR
oStruFnR:AddTrigger('FNR_GRPDES','FNR_GRPDES',{|| .T. },{||Af060Grupo(FWFldGet("FNR_GRPDES"), 'FNR'), FWFldGet('FNR_GRPDES') })

//Gatilhos FNS
oStruFnS:AddTrigger("FNS_CCDESD","FNS_CCDDD" ,{|| SuperGetMv("MV_ATFCCDP",.F.,.F.) },{||FWFldGet('FNS_CCDESD')})

//Gatilhos da FNS
// Conta Contabil
oStruFnS:AddTrigger("FNS_CONTAD","FNS_CONTAD",{|| .T. },{||AF060PE("FNS_CONTAD" )})
oStruFnS:AddTrigger("FNS_CONCOD","FNS_CONCOD",{|| .T. },{||AF060PE("FNS_CONCOD" )})
oStruFnS:AddTrigger("FNS_CONDDD","FNS_CONDDD",{|| .T. },{||AF060PE("FNS_CONDDD" )})
oStruFnS:AddTrigger("FNS_CONDAD","FNS_CONDAD",{|| .T. },{||AF060PE("FNS_CONDAD" )})
oStruFnS:AddTrigger("FNS_CONCDD","FNS_CONCDD",{|| .T. },{||AF060PE("FNS_CONCDD" )})

//CENTRO DE CUSTO
oStruFnS:AddTrigger("FNS_CCBEMD","FNS_CCBEMD",{|| .T. },{||AF060PE("FNS_CCBEMD" )})
oStruFnS:AddTrigger("FNS_CCCORD","FNS_CCCORD",{|| .T. },{||AF060PE("FNS_CCCORD" )})
oStruFnS:AddTrigger("FNS_CCDAD" ,"FNS_CCDAD" ,{|| .T. },{||AF060PE("FNS_CCDAD"  )})
oStruFnS:AddTrigger("FNS_CCCDD" ,"FNS_CCCDD" ,{|| .T. },{||AF060PE("FNS_CCCDD"  )})
oStruFnS:AddTrigger("FNS_CCDDD" ,"FNS_CCDDD" ,{|| .T. },{||AF060PE("FNS_CCDDD"  )})

//ITEM CONTABIL
oStruFnS:AddTrigger("FNS_ITBEMD","FNS_ITBEMD",{|| .T. },{||AF060PE("FNS_ITBEMD" )})
oStruFnS:AddTrigger("FNS_ITCORD","FNS_ITCORD",{|| .T. },{||AF060PE("FNS_ITCORD" )})
oStruFnS:AddTrigger("FNS_ITDEDD","FNS_ITDEDD",{|| .T. },{||AF060PE("FNS_ITDEDD" )})
oStruFnS:AddTrigger("FNS_ITDEAD","FNS_ITDEAD",{|| .T. },{||AF060PE("FNS_ITDEAD" )})
oStruFnS:AddTrigger("FNS_ITCDED","FNS_ITCDED",{|| .T. },{||AF060PE("FNS_ITCDED" )})
If lCmpDesp
	oStruFnS:AddTrigger("FNS_ITDESD","FNS_ITDESD",{|| .T. },{||AF060PE("FNS_ITDESD" )}) //ITEM CONTABIL
	oStruFnS:AddTrigger("FNS_CVDSPD","FNS_CVDSPD",{|| .T. },{||AF060PE("FNS_CVDSPD" )}) //CLASSE DE VALOR
EndIf

//CLASSE DE VALOR
oStruFnS:AddTrigger("FNS_CVBEMD","FNS_CVBEMD",{|| .T. },{||AF060PE("FNS_CVBEMD" )})
oStruFnS:AddTrigger("FNS_CVCORD","FNS_CVCORD",{|| .T. },{||AF060PE("FNS_CVCORD" )})
oStruFnS:AddTrigger("FNS_CVDEPD","FNS_CVDEPD",{|| .T. },{||AF060PE("FNS_CVDEPD" )})
oStruFnS:AddTrigger("FNS_CVCDED","FNS_CVCDED",{|| .T. },{||AF060PE("FNS_CVCDED" )})
oStruFnS:AddTrigger("FNS_CVDESD","FNS_CVDESD",{|| .T. },{||AF060PE("FNS_CVDESD" )})

//CAMPOS NAO EDITAVEIS  - editáqvel somente na FN9
oStruFnR:SetProperty('FNR_DATA'   ,MODEL_FIELD_NOUPD, .T.)
oStruFns:SetProperty('FNS_DATA'   ,MODEL_FIELD_NOUPD, .T.)

//Fazendo a validação de data
oStruFn9:SetProperty('FN9_DATA',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060Data(FWFldGet('FN9_DATA'))"))
oStruFnr:SetProperty('FNR_DATA',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060Data(FWFldGet('FNR_DATA'))"))
oStruFns:SetProperty('FNS_DATA',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060Data(FWFldGet('FNS_DATA'))"))

//Fazendo a Validação do Grupo de Bem
oStruFnr:SetProperty('FNR_GRPDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060VLGRP(FWFldGet('FNR_GRPDES'),FWFldGet('FNR_FILDES'),'FNR')"))
oStruFn9:SetProperty('FN9_GRPDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060VLGRP(FWFldGet('FN9_GRPDES'),FWFldGet('FN9_FILDES'),'FN9')"))

//Validação da Filial de Destino
oStruFn9:SetProperty('FN9_FILDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AFA060FIL(FWFldGet('FN9_FILDES'),FWFldGet('FN9_GERNF') == '1')"))
oStruFnr:SetProperty('FNR_FILDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AFA060FIL(FWFldGet('FNR_FILDES'),FWFldGet('FNR_GERNF') == '1')"))

oStruFn9:SetProperty('FN9_GERNF',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AFA060FIL(FWFldGet('FN9_FILDES'),FWFldGet('FN9_GERNF') == '1')"))
oStruFnr:SetProperty('FNR_GERNF',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AFA060FIL(FWFldGet('FNR_FILDES'),FWFldGet('FNR_GERNF') == '1')"))

//Validacao do Local
oStruFn9:SetProperty('FN9_LOCDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060VLLOC(FWFldGet('FN9_FILDES'),FWFldGet('FNR_FILORI'),FWFldGet('FNR_LOCORI'),FWFldGet('FN9_LOCDES'))"))
oStruFnr:SetProperty('FNR_LOCDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060VLLOC(FWFldGet('FNR_FILDES'),FWFldGet('FNR_FILORI'),FWFldGet('FNR_LOCORI'),FWFldGet('FNR_LOCDES'))"))

//Validacao da transferencia parcial
oStruFNR:SetProperty('FNR_QTDDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"FWFldGet('FNR_QTDDES') > 0 .And. FWFldGet('FNR_QTDDES') <=  FWFldGet('FNR_QTDORI')"))

If lVisu
	oStruFNR:SetProperty("FNR_DESCRI",MODEL_FIELD_INIT,FWBuildFeature(STRUCT_FEATURE_INIPAD,'POSICIONE("SN1",1,XFilial("SN1",FNR->FNR_FILORI)+FNR->(FNR_CBAORI+FNR_ITEORI),"N1_DESCRIC","")'))
	oStruFNS:SetProperty("FNS_HISTOR",MODEL_FIELD_INIT,FWBuildFeature(STRUCT_FEATURE_INIPAD,'POSICIONE("SN3",12,XFilial("SN3",FWFldGet("FNR_FILORI"))+FWFldGet("FNR_CBAORI")+FWFldGet("FNR_ITEORI")+FNS->(FNS_TIPO+FNS_SEQ),"N3_HISTOR","")'))
EndIf

//Validacao da taxa padrão
oStruFnr:SetProperty('FNR_TXPADD',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"A060TXRVLD(FWFldGet('FNR_TXPADD'),FWFldGet('FNR_FILDES'))"))
oStruFn9:SetProperty('FN9_TXPADD',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"A060TXRVLD(FWFldGet('FN9_TXPADD'),FWFldGet('FN9_FILDES'))"))

If oStruFN9:HasField("FN9_ESPECI")
    IF !lVldNewInv
		oStruFn9:SetProperty('FN9_ESPECI',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"ExistCpo('SX5','42'+FWFldGet('FN9_ESPECI'))"))
	Else 
		oStruFn9:SetProperty('FN9_ESPECI',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"EXISTCPO('AZZ',PadR(FWFldGet('FN9_ESPECI'),TamSX3('AZZ_ESPECI')[1]))"))
		oStruFn9:SetProperty('FN9_SERIE', MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"EXISTCPO('AZZ',PadR(FWFldGet('FN9_ESPECI'),TamSX3('AZZ_ESPECI')[1])+PadR(FWFldGet('FN9_SERIE'),TamSX3('AZZ_SERIE')[1]))"))
		oStruFnr:SetProperty('FNR_ESPECI',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"EXISTCPO('AZZ',PadR(FWFldGet('FNR_ESPECI'),TamSX3('AZZ_ESPECI')[1]))"))
		oStruFnr:SetProperty('FNR_SERIE', MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"EXISTCPO('AZZ',PadR(FWFldGet('FNR_ESPECI'),TamSX3('AZZ_ESPECI')[1])+PadR(FWFldGet('FNR_SERIE'),TamSX3('AZZ_SERIE')[1]))"))
	EndIf
EndIf

If oStruFN9:HasField("FN9_ARMAZE")
    oStruFn9:SetProperty('FN9_ARMAZE',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"ATFVALNNR(FWFldGet('FN9_ARMAZE'),FWFldGet('FN9_ARMAZE'),FWFldGet('FN9_FILDES')) "))
EndIf

//Adicionando o When na FN9
oStruFn9:SetProperty('FN9_GRPDES',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFn9:SetProperty('FN9_FILDES',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFn9:SetProperty('FN9_GERNF' ,MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFn9:SetProperty('FN9_TXPADD',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"A060TXRALT(FWFldGet('FN9_GRPDES')) .And. AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFn9:SetProperty('FN9_TESENT',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"If(FWFldGet('FN9_CLSNF') == '2', .T.,.F.)"))
oStruFn9:SetProperty('FN9_ARMAZE',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"If(FWFldGet('FN9_CLSNF') == '2', .T.,.F.)"))

If oStruFN9:HasField("FN9_ESPECI")
    oStruFn9:SetProperty('FN9_ESPECI',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"If(FWFldGet('FN9_CLSNF') == '2', .T.,.F.)"))
EndIf

//Adicionando o When na FNR
oStruFnr:SetProperty('FNR_GRPDES',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFnr:SetProperty('FNR_FILDES',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFnr:SetProperty('FNR_GERNF' ,MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFnr:SetProperty('FNR_TXPADD',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"A060TXRALT(FWFldGet('FNR_GRPDES')) .And. AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFnr:SetProperty('FNR_TESENT',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"If(FWFldGet('FNR_CLSNF') == '2', .T.,.F.)"))

If oStruFnr:HasField("FNR_ESPECI")
    oStruFnr:SetProperty('FNR_ESPECI',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"If(FWFldGet('FNR_CLSNF') == '2', .T.,.F.)"))
EndIf

If oStruFnr:HasField("FNR_ARMAZE")
    oStruFnr:SetProperty('FNR_ARMAZE',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"If(FWFldGet('FNR_CLSNF') == '2', .T.,.F.)"))
EndIf


oModel := MPFormModel():New('ATFA060',/*preValid */,{|oModel|AF060TDOK(oModel)}/*bPosValidacao*/,{ |oModel| af060Commit( oModel ) }, /*bCancel*/ )

//Criando os AddFields e AddGrid
If(lVisu)

	oModel:AddFields("FieldFN9",		,oStruFn9, /*bPreVld*/	, /*bPost*/									,/*{||LoadFN9(oModel)}*/)
	oModel:AddGrid("GridFNR","FieldFN9",oStruFnr, /*bLinePre*/	, /*bLinePost*/	, /*bPreVal*/, /*bPosVal*/	,/*{|oModel| LoadFNR(oModel)}*/)
	oModel:AddGrid("GridFNS","GridFNR"	,oStruFns, /*bLinePre*/	, /*bLinePost*/	, /*bPreVal*/, /*bPosVal*/	,/*{|oModel|LoadFNS(oModel)}*/)

Else

	oModel:AddFields("FieldFN9",		,oStruFn9, /*bPreVld*/	, /*bPost*/									,{||LoadFN9(oModel)})
	oModel:AddGrid("GridFNR","FieldFN9",oStruFnr, /*bLinePre*/	, /*bLinePost*/	, /*bPreVal*/, /*bPosVal*/	,{|oModel| LoadFNR(oModel)})
	oModel:AddGrid("GridFNS","GridFNR"	,oStruFns, /*bLinePre*/	, /*bLinePost*/	, /*bPreVal*/, /*bPosVal*/	,{|oModel|LoadFNS(oModel)})

EndIf

//Efetuando o SetRelation
oModel:SetRelation('GridFNR',{{'FNR_FILIAL','XFilial("FNR")'},{'FNR_IDMOV','FN9_IDMOV'}},FNR->(IndexKey(1)))
oModel:SetRelation('GridFNS',{{'FNS_FILIAL','XFilial("FNS")'},{'FNS_IDMOV','FNR_IDMOV'},{'FNS_CODREL','FNR_CODREL'}},FNS->(IndexKey(1)))

If lIsRussia
	oModel:SetDescription(STR0005) //"Transferencia de Ativos"
Endif

oModel:GetModel("FieldFN9"):SetDescription(STR0005) //"Transferencia de Ativos"
oModel:GetModel("GridFNS") :SetDescription(STR0117) //"Ativos"
oModel:GetModel("GridFNR") :SetDescription(STR0118) //"Tipo de Ativos"

oModel:SetVldActivate({||AF060VLD()})
oModel:SetActivate( {|oModel| AF060Activ(oModel) } )

Return oModel

/*{Protheus.doc} ViewDef
View da Rotina da Transferencia de Ativo
@author Jose Augusto Ribeiro
@since 08/05/2015
@version P12
@return oView ,Objeto ,View da Rotina de Transferencia de Ativo
*/
Static Function ViewDef()
Local oModel		:= FwLoadModel("ATFA060")
Local oView			:= FwFormView():New()
//Criando a Estrutura
Local oStruFn9		:= FWFormStruct( 2, 'FN9', /*bAvalCampo*/,/*lViewUsado*/ )
Local oStruFns		:= FWFormStruct( 2, 'FNS', /*bAvalCampo*/,/*lViewUsado*/ )
Local oStruFnr		:= FWFormStruct( 2, 'FNR', /*bAvalCampo*/,/*lViewUsado*/ )
Local lTransf		:= FwIsInCallStack("ATF060TRAN")
Local lTransfAut	:= FwIsInCallStack("AF060Auto")
Local aCposFN9		:= {}
Local nX			:= 0
Local cOrdFN9Esp	as Character
Local cOrdFN9Ser	as Character
Local cOrdFNREsp	as Character
Local cOrdFNRSer	as Character
Local lVldNewInv	as Logical

cOrdFN9Esp	:= GetSx3Cache('FN9_ESPECI','X3_ORDEM')
cOrdFN9Ser	:= GetSx3Cache('FN9_SERIE','X3_ORDEM') 
cOrdFNREsp	:= GetSx3Cache('FNR_ESPECI','X3_ORDEM')
cOrdFNRSer	:= GetSx3Cache('FNR_SERIE','X3_ORDEM')
lVldNewInv	:= If(FindFunction("ATFVldNInv"),ATFVldNInv(),.F.)

oView:SetModel(oModel)

//Campos virtuais
If !lVisu
	oStruFnr:AddField( 'OK' ,'01',' ',' ',, 'Check' ,,,,,,,,,,,, ) //'Baixa?'#//'Baixa?'
	oStruFns:AddField( 'OK' ,'01',' ',' ',, 'Check' ,,,,,,,,,,,, ) //'Baixa?'#//'Baixa?'
EndIf

If lTransfAut

	//AddField(	cIdField	,cOrdem	,cTitulo	,cDescric	,aHelp		,cType	,cPicture	,bPictVar	,cLookUp	,lCanChange	,cFolder	,cGroup	,aComboValues	,nMaxLenCombo	,cIniBrow	,lVirtual	,cPictVar, lInsertLine )
	oStruFn9:AddField(	'TOTBEM'	,'10'	,STR0153		, STR0153	,{STR0153}	,'N'	,NIL		,NIL		,NIL		,.T.		,'1'		,'1'	,NIL			,NIL			,nil		,.T.		,NIL ) //"Total de Bens"##"Exercício Contábil"

	oView:AddUserButton(STR0194,"",{|| MSGRUN(STR0193,STR0160,{|| A060InvSel() }) }) //"Inverte Seleção Ativos"###"Aguarde, invertendo a seleção dos ativos..."###"Processando"

EndIf

//---------------------------------------------------------------------------------
// Remove os campos que não precisam ser exibidos na visualização da transferencia
//---------------------------------------------------------------------------------
If lVisu

	aCposFN9 :=	AClone(oStruFn9:GetFields())

	For nX := 1 To Len(aCposFN9)
		If oStruFN9:GetProperty(aCposFN9[nX][MVC_VIEW_IDFIELD],MVC_VIEW_VIRTUAL)
			oStruFN9:RemoveField(aCposFN9[nX][MVC_VIEW_IDFIELD])
		EndIf
	Next nX

	Asize(aCposFN9,0)
	aCposFN9 := Nil

EndIf

//Remove campos que nao precisam ser exibidos na Transferencia e Transferencia Automatica
If lTransf .Or. lTransfAut .Or. lVisu
	//FNR
	oStruFnr:RemoveField("FNR_IDMOV")
	oStruFnr:RemoveField("FNR_STATUS")
	oStruFnr:RemoveField("FNR_CBADES")
	oStruFnr:RemoveField("FNR_ITEDES")
	oStruFnr:RemoveField("FNR_CODREL")
	//FNS
	oStruFns:RemoveField("FNS_IDMOV")
	oStruFns:RemoveField("FNS_CODREL")
EndIf

//Adicionando o Componente
oView:AddField('View_FN9',oStruFn9,"FieldFN9")
oView:AddGrid ('View_FNR' ,oStruFnr,"GridFNR")
oView:AddGrid ('View_FNS' ,oStruFns,"GridFNS")

//Criando o a Estrutura do Pai , Filho e Neto
oView:CreateHorizontalBox('Pai',If(lVisu,20,40))
oView:CreateHorizontalBox('Filho',If(lVisu,40,35))
oView:CreateHorizontalBox('Neto',If(lVisu,40,25))

//Não permite apagar linha
oView:SetNoDeleteLine('View_FNR')
oView:SetNoDeleteLine('View_FNS')

//Não permite inluir linha
oView:SetNoInsertLine('View_FNR')
oView:SetNoInsertLine('View_FNS')

//Amarrando as Estruturas com as grids
oView:SetOwnerView('View_FN9','Pai')
oView:SetOwnerView('View_FNR','Filho')
oView:SetOwnerView('View_FNS','Neto')

oView:EnableTitleView('GridFNS'	, STR0118 ) //'Tipos de Ativos'
oView:EnableTitleView('GridFNR'	, STR0117) //'Ativos'

oView:lModify			:= .F.
oView:oModel:lModify	:= .F.

//Inverte a ordem de exibição do titulo
If 	!FwIsInCallStack("ATF060VTR") .AND. lVldNewInv
	oStruFn9:SetProperty('FN9_ESPECI',MVC_VIEW_ORDEM, cOrdFN9Ser )
	oStruFn9:SetProperty('FN9_SERIE' ,MVC_VIEW_ORDEM, cOrdFN9Esp)
	oStruFnr:SetProperty('FNR_ESPECI',MVC_VIEW_ORDEM, cOrdFNRSer )
	oStruFnr:SetProperty('FNR_SERIE' ,MVC_VIEW_ORDEM, cOrdFNREsp)
EndIf

Return oView

/*{Protheus.doc} AF060Auto
Transferencia em lote
@author Mayara Alves
@since 18/05/2015
@version P12
*/
//Todo verificar o filto, para trazar os itens selecionados.
Function AF060Auto()

local aArea		as array
local lRet		as logical

Private cPerg	as character

	aArea	:= GetArea()
	cPerg	:= "AFA060A"
	lRet	:= .F.
	lFN9	:= .T.

	//Zero arrays de contabilizacao AVP
	aAvpCtbO := {}
	aAvpCtbD := {}
	
	//Valida data
	If !af060data( dDataBase )
		Return
	Endif

	lRet := AF060Trans(.T.)

	If lRet
		//Chama a tela
		//"Transferencia em Lote" - Alterada a opção para 9, pois ao bloquear o acesso para
		//opcao "Transferir" também bloqueava a automatica na execucao do FWExecView
		MSGRUN(STR0159,STR0160,{|| FWExecView(STR0119, "ATFA060", 9/*MODEL_OPERATION_UPDATE*/, /*oDlg*/, { || .T. } )})//"Aguarde, Carregando os Registros"##"  Processando"
	EndIf

	//--------------------------------------------------------------------
	// Desabilita a reabertura da tela na conclusão do processo, pois foi
	// utilizada a opção 3 no menu para possibilitar a seleção da filial
	//--------------------------------------------------------------------
	MBrChgLoop(.F.)

	RestArea(aArea)

	//metrica para objetivo de verificar quantos clientes utilizam a transferencia em lote e o numero de acessos aglutinados
	If __lMetric .And. lRet
		ATF060Metrics("01" /*cEvent*/,/*nStart*/, "001" /*cSubEvent*/, Alltrim(ProcName()) /*cSubRoutine*/, /*nQtdReg*/)
	Endif

Return

/*{Protheus.doc} ATF060TRAN
Chama a tela de Transferencia
@author Mayara Alves
@since 18/05/2015
@version P12
*/
Function ATF060TRAN()
	Local lRet := .T.

	lAuto			:= .T.
	lAtfAuto	:= IsBlind()
	//Chama a tela
	lRet := AF060Trans(.F.)
	If(lRet)
		If	!lAtfAuto
		MSGRUN(STR0177,STR0178,{|| FWExecView (STR0120, "ATFA060", MODEL_OPERATION_UPDATE, /*oDlg*/, { || .T. } ) })//"Aguarde, Carregando os Registros... "##"  Processando ..."
		Endif
	EndIf

Return lRet

/*{Protheus.doc} LOADFN9
Faz o Load na FN9 para abrir a tela.
@author Mayara Alves
@since 18/05/2015
@param oModel
@return aDados
@version P12
*/
Static Function LOADFN9(oModel)
Local aDados		:= {}
Local oModelFN9		:= oModel:GetModel('FieldFN9')
Local aCposVlr		:= oModelFN9:GetStruct():GetFields()
Local aFilCpos		:= {}
Local nContCpo		:= 0
Local cIDMOV		:= ""
Local cAliasTRAN	:= QryFNR(.T.) //Retorna o numero de linhas da FNR

dbSelectArea("FN9")
FN9->(dbSetOrder(1)) //FN9_FILIAL+FN9_IDMOV

dbSelectArea("FNR")
FNR->(dbSetOrder(1)) //FNR_FILIAL+FNR_IDMOV

dbSelectArea("FNS")
FNS->(dbSetOrder(1)) //FNS_FILIAL+FNS_IDMOV+FNS_CODREL+FNS_TIPO+FNS_SEQ

While .T.
	cIDMOV := GetSxENum("FN9", "FN9_IDMOV")
	ConfirmSx8()
	If FN9->(!DBSeek(xFilial("FN9") + cIDMOV)) .AND. FNR->(!DBSeek(xFilial("FNR") + cIDMOV)) .AND. FNS->(!DBSeek(xFilial("FNS") + cIDMOV))
		Exit
	EndIf
EndDo

For nContCpo := 1 To Len(aCposVlr)
	If aCposVlr[nContCpo][3] == "FN9_FILIAL"
		AADD(aFilCpos,xFilial("FN9"))
	ElseIf aCposVlr[nContCpo][3] == "FN9_IDMOV"
		AADD(aFilCpos,cIDMOV)
	ElseIf aCposVlr[nContCpo][3] == "FN9_DATA"
		AADD(aFilCpos,DDATABASE)
	ElseIf aCposVlr[nContCpo][3] == "TOTBEM"
		AADD(aFilCpos, (cAliasTRAN)->NLINHA)
	ElseIf aCposVlr[nContCpo][3] == "FN9_FILDES"
		AADD(aFilCpos, cFilAnt)
	Else
		AADD(aFilCpos,CriaVar(aCposVlr[nContCpo][3],.T.))
	EndIf
Next nContCpo

aDados := {aFilCpos,0}

If Select(cAliasTRAN) > 0
	(cAliasTRAN)->(DbCloseArea())
EndIf

Return aDados

/*{Protheus.doc} LoadFNR
Faz o Load na FNR para abrir a tela.
@author Mayara Alves
@since 18/05/2015
@param oModel
@return aDados
@version P12
*/
Static Function LoadFNR(oModel,cAliasFNR)
Local aDados		:= {}
Local oFNRStruct	:= oModel:GetStruct()
Local oModelFN9	:= oModel:GetModel('FieldFN9')
Local aCposVlr	:= {}
Local aFilCpos	:= {}
Local aArea		:= GetArea()
Local nContCpo	:= 0
Local cAliasFNR	:= QryFNR(.F.) //Query SN1
Local nItem		:= 0
Local cExpFiltro	:= ""
Local cFiltro		:= ""
Local lAF060FIL	:= ExistBlock("AF060FIL")
Local lLote		:= FwIsInCallStack("AF060Auto")
Local cIdMov		:= oModelFN9:GetValue('FieldFN9','FN9_IDMOV')
Local cChavAux	:= ""
Local nBem			:= 0
Local lAmbComp		:= .F.
Local lCall126		:= IsInCallStack("ATFA126")
Local lAgrBens      := FindFunction("A036AgrBens")

aCposVlr := oFNRStruct:GetFields()
If(lLote)
	If(MV_PAR04 == 1)
		cExpFiltro := BuildExpr("SN3")
		If(lAF060FIL)
			cFiltro := ExecBlock("AF060FIL",.F.,.F.)
			If !Empty(cFiltro)
				If !Empty(cExpFiltro)
					cExpFiltro += " .AND. " + cFiltro
				Else
					cExpFiltro := cFiltro
				Endif
			EndIf
		EndIf
	EndIf
Endif

lAmbComp := (FWModeAccess('SN1',3) == "C") //Apenas ambientes compartilhados no minimo a filial Filiai.

While (cAliasFNR)->(!Eof())

	If(lLote)
		SN3->(DbGoto((cAliasFNR)->(RECNO)))

		//Aplica filtro personalizado do usuario
		If !Empty(cExpFiltro) .And. (!SN3->&(cExpFiltro))
			(cAliasFNR)->(DbSkip())
			Loop
		EndIf

		//Tratamento para não repetir o ativo na tela
		If Empty(cChavAux) .Or. cChavAux != (cAliasFNR)->N1_CBASE+(cAliasFNR)->N1_ITEM
			cChavAux := (cAliasFNR)->N1_CBASE+(cAliasFNR)->N1_ITEM
		Else
			(cAliasFNR)->(DbSkip())
			Loop
		EndIf

		nItem++
		For nContCpo := 1 To Len(aCposVlr)
			If aCposVlr[nContCpo][3] == "FNR_FILIAL"
				Aadd(aFilCpos,xFilial("FNR"))
			ElseIf aCposVlr[nContCpo][3] == "FNR_DATA"
				Aadd(aFilCpos,dDatabase)
			ElseIf aCposVlr[nContCpo][3] $ "FNR_QTDORI|FNR_QTDDES"
				If aCposVlr[nContCpo][3] == "FNR_QTDDES" .And. lAgrBens .And. !Empty(MV_PAR10)
					//Tratamento quantidade pelo Agrupador de Bens
					cCodAgrup := PadR(MV_PAR10, TamSX3("FM3_CODIGO")[1])
					nQtdeDes  := Posicione("FM4",2,xFilial("FM4")+cCodAgrup+(cAliasFNR)->N1_CBASE+(cAliasFNR)->N1_ITEM,"FM4_QUANTD")
					nQtdeDes  := IIf(nQtdeDes <= (cAliasFNR)->N1_QUANTD, nQtdeDes, (cAliasFNR)->N1_QUANTD)
					Aadd(aFilCpos,nQtdeDes)
				Else
					Aadd(aFilCpos,(cAliasFNR)->N1_QUANTD)
				EndIf
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILORI|FNR_FILDES"
				If lAmbComp
					If AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILORI"
						Aadd(aFilCpos,(cAliasFNR)->N3_FILORIG)
					ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILDES"
						Aadd(aFilCpos,Iif(lCall126,SNM->NM_FILDEST,cFilAnt))
					EndIf
				Else
					Aadd(aFilCpos,(cAliasFNR)->N1_FILIAL)
				EndIf
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_GRPORI"	//Grupo
				Aadd(aFilCpos,(cAliasFNR)->N1_GRUPO)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_LOCORI|FNR_LOCDES"	//Local
				Aadd(aFilCpos,(cAliasFNR)->N1_LOCAL)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_CBAORI|FNR_CBADES"	//C Base Ori
				Aadd(aFilCpos,(cAliasFNR)->N1_CBASE)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_ITEORI|FNR_ITEDES"
				Aadd(aFilCpos,(cAliasFNR)->N1_ITEM)
			ElseIf aCposVlr[nContCpo][3] == "FNR_CODREL"
				Aadd(aFilCpos,cvaltochar(nItem))
			ElseIf aCposVlr[nContCpo][3] == "FNR_IDMOV"
				Aadd(aFilCpos,cIdMov)
			ElseIf aCposVlr[nContCpo][3] == "FNR_DESCRI"
				Aadd(aFilCpos,(cAliasFNR)->N1_DESCRIC)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_TXPADO|FNR_TXPADD"
				Aadd(aFilCpos,(cAliasFNR)->N1_TAXAPAD)
			ElseIf aCposVlr[nContCpo][3] == "OK"
				Aadd(aFilCpos,.T.)
			ElseIf aCposVlr[nContCpo][3] == "FNR_STATUS"
				Aadd(aFilCpos,1)
			Else
				Aadd(aFilCpos,CriaVar(aCposVlr[nContCpo][3],.T.))
			EndIf
		Next nContCpo
	Else

		nItem++
		For nContCpo := 1 To Len(aCposVlr)
			If aCposVlr[nContCpo][3] == "FNR_FILIAL"
				Aadd(aFilCpos,xFilial("FNR"))
			ElseIf aCposVlr[nContCpo][3] == "FNR_DATA"
				Aadd(aFilCpos,dDatabase)
			ElseIf aCposVlr[nContCpo][3] $ "FNR_QTDORI|FNR_QTDDES"
				Aadd(aFilCpos,(cAliasFNR)->N1_QUANTD)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILORI|FNR_FILDES"
				If lAmbComp
					If AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILORI"
						Aadd(aFilCpos,(cAliasFNR)->N3_FILORIG)
					ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILDES"
						Aadd(aFilCpos,Iif(lCall126,SNM->NM_FILDEST,cFilAnt))
					EndIf
				Else
					Aadd(aFilCpos,cFilAnt)
				EndIf
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_GRPORI"	//Grupo
				Aadd(aFilCpos,(cAliasFNR)->N1_GRUPO)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_LOCORI|FNR_LOCDES"	//Local
				Aadd(aFilCpos,(cAliasFNR)->N1_LOCAL)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_CBAORI|FNR_CBADES"	//C Base Ori
				Aadd(aFilCpos,(cAliasFNR)->N1_CBASE)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_ITEORI|FNR_ITEDES"
				Aadd(aFilCpos,(cAliasFNR)->N1_ITEM)
			ElseIf aCposVlr[nContCpo][3] == "FNR_CODREL"
				Aadd(aFilCpos,cvaltochar(nItem))
			ElseIf aCposVlr[nContCpo][3] == "FNR_IDMOV"
				Aadd(aFilCpos,cIdMov)
			ElseIf aCposVlr[nContCpo][3] == "FNR_DESCRI"
				Aadd(aFilCpos,(cAliasFNR)->N1_DESCRIC)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_TXPADO|FNR_TXPADD"
				Aadd(aFilCpos,(cAliasFNR)->N1_TAXAPAD)
			ElseIf aCposVlr[nContCpo][3] == "OK"
				Aadd(aFilCpos,.T.)
			ElseIf aCposVlr[nContCpo][3] == "FNR_STATUS"
				Aadd(aFilCpos,1)
			Else
				Aadd(aFilCpos,CriaVar(aCposVlr[nContCpo][3],.T.))
			EndIf
		Next nContCpo
	EndIf

	Aadd(aFilCpos,.T.)
	Aadd(aDados,{0,aFilCpos})

	aFilCpos := {}
	nBem ++
	(cAliasFNR)->(DbSkip())
EndDo

If Select(cAliasFNR) > 0
	(cAliasFNR)->(DbCloseArea())
EndIf

If(lLote)
	oModelFN9:GetModel('FieldFN9'):LoadValue('TOTBEM',nBem)
EndIf
RestArea(aArea)

Return aDados

/*{Protheus.doc} AT060QryFNR
Query para carregar FNR com base na SN1
@author Mayara Alves
@since 18/05/2015
@return cAliasTRAN
@version P12
*/
Static Function QryFNR(lLinha)
Local cQry			:= ""
Local lLote			:= FWIsInCallStack('AF060Auto')
Local cAliasTRAN	:= ''
Local lAmbComp 		:= (FWModeAccess('SN1',3) == "C") //IIF(Empty(SN1->N1_FILIAL), .T., .F.)
Local lAgrBens      := FindFunction("A036AgrBens")
Local cAtivAgrup    := ""
Local lRet			:= .T.

If lLote .And. lAgrBens .And. !Empty(MV_PAR10)
	cAtivAgrup := A036AgrBens(MV_PAR10)
	If cAtivAgrup == "-1"
		FWAlertWarning(STR0221 + MV_PAR10 + STR0222, STR0205) // "O agrupador selecionado " // " está inativo ou fora da validade." // "Atenção"
		lRet := .F.
	ElseIf cAtivAgrup == "-2"
		FWAlertWarning(STR0221 + MV_PAR10 + STR0231, STR0205) // "O agrupador selecionado" // " não foi encontrado na base de dados." // Atenção"
		lRet := .F.
	EndIf
EndIf

If(lAtfAuto)

	lLote := .F.

EndIF

If lRet
	cAliasTRAN := GetNextAlias()
	If lLinha
		cQry := "SELECT COUNT(N1_CBASE) NLINHA" +CRLF
	Else
		cQry := "SELECT N1_FILIAL,N1_GRUPO,N1_LOCAL,N1_CBASE,N1_QUANTD,N1_ITEM,N1_DESCRIC,N1_TAXAPAD " +CRLF

		If lLote

			cQry += ",SN3.R_E_C_N_O_ RECNO " +CRLF

		EndIf
	EndIf

	If lAmbComp .and. !lLinha
		cQry += ", SN3.N3_FILORIG " +CRLF
	EndIf

	cQry += " FROM " + RetSqlName("SN1") + " SN1 " +CRLF
	If (lAmbComp .Or. lLote) .and. !lLinha
		cQry += " INNER JOIN " + RetSqlName("SN3") + " SN3 " +CRLF
		cQry += " ON N3_FILIAL = '" + xFilial("SN3") + "' AND " +CRLF
		cQry += " N3_CBASE = N1_CBASE AND N3_ITEM = N1_ITEM "  +CRLF
		cQry += " AND SN3.D_E_L_E_T_ = ' ' " +CRLF
	EndIf
	cQry += "WHERE N1_FILIAL = '" + FWXFilial("SN1") + "' "+CRLF

	If lLote
		If !Empty(cAtivAgrup)
		//Agrupador patrimonial não funcionará multi Filial necessário tratamento na rotina padrão para que a baixa em lote seje feita multifilial
		cQry += "AND EXISTS (" + ;
				cAtivAgrup + ;
				" AND FM4_FILORI = N1_FILIAL " + ;
				" AND FM4_CBASE = N1_CBASE " + ;
				" AND FM4_ITEM = N1_ITEM)"
		//mesmo trazendo de filiais diferentes será filtrado no trecho: ON N3_FILIAL = '" + xFilial("SN3")
		Else
		cQry += "AND N1_CBASE BETWEEN '" + MV_PAR05 + "' AND '" + MV_PAR06 + "' "  +CRLF
		cQry += "AND N1_ITEM BETWEEN  '" + MV_PAR07 + "' AND '"  + MV_PAR08 +"' "  +CRLF
		EndIf
	Else
		cQry += "AND N1_CBASE = '" + SN3->N3_CBASE	+ "' "  +CRLF //Até Bem
		cQry += "AND N1_ITEM =  '" + SN3->N3_ITEM	+ "' "  +CRLF //Do Item
	EndIf
	cQry += "AND N1_STATUS = '1' "  +CRLF //Bem em uso
	cQry += "AND N1_BAIXA = ' ' "  +CRLF //Bem em uso
	cQry += "AND SN1.D_E_L_E_T_ = ' ' "  +CRLF

	if lAmbComp .and. !lLinha
		If lLote
			cQry += " GROUP BY N1_FILIAL,N1_GRUPO,N1_LOCAL,N1_CBASE,N1_QUANTD,N1_ITEM,N1_DESCRIC,N1_TAXAPAD,N3_FILORIG,SN3.R_E_C_N_O_"  +CRLF
			cQry += " ORDER BY SN3.R_E_C_N_O_ " +CRLF
		Else
			cQry += " GROUP BY N1_FILIAL,N1_GRUPO,N1_LOCAL,N1_CBASE,N1_QUANTD,N1_ITEM,N1_DESCRIC,N1_TAXAPAD,N3_FILORIG "  +CRLF
		EndIf
	endIf

	cQry := ChangeQuery( cQry )

	dbUseArea( .T. , "TOPCONN" , TcGenQry(,,cQry) , cAliasTRAN , .T. , .F.)

	dbSelectArea(cAliasTRAN)

EndIf

Return cAliasTRAN

/*{Protheus.doc} AF060Activ
Executa após a validação.
@author Alvaro Camillo
@since 24/06/2015
@version P12
@project Inovação Controladoria
*/
Static Function AF060Activ(oModel)
Local oView := FWViewActive()

If oView <> Nil
	oView:lModify 		:= .F.
	oView:oModel:lModify	:= .F.
EndIf

Return .T.

/*{Protheus.doc} AF060VLD
Efetua a Validação para saber se carrega a tela ou não
@author Jose Augusto Ribeiro
@since 24/06/2015
@version P12
@return lRet,logico, Retorna  .T. para verdadeiro e .F. para nao validado
@project Inovação Controladoria
*/
Static Function AF060VLD()

Local lRet			:= .T.
Local cAliasFNR	:= QryFNR(.F.) //Query SN1


If Empty(cAliasFNR) 
	lRet := .F. //Somente quando agrupador não existir ou estiver vencido retorno será vazio
Else
	If (((cAliasFNR)->(EOF())) .And. !FwIsInCallStack("ATF060VTR"))

		(cAliasFNR)->(DbCloseArea())
		HELP(" ",1,"AF060VLD",,STR0121 ,1,0) //"Não Foi Localizado o Bem na SN1"
		lRet := .F.
	EndIf

	If Select(cAliasFNR) > 0
		(cAliasFNR)->(DbCloseArea())
	EndIf
EndIf

Return lRet

/*{Protheus.doc} LoadFNS
Faz o Load na FNS para abrir a tela.
@author Mayara Alves
@since 18/05/2015
@param oModel
@return aDados
@version P12
*/
Static Function LoadFNS(oModel As Object, cAliasFNS As Character) As Array

Local aDados		As Array
Local oFNSStruct	As Object
Local oModelFN9		As Object
Local oModelFNR		As Object
Local aCposVlr		As Array
Local aFilCpos		As Array
Local nItem			As Numeric
Local cIDMOV		As Character
Local cAliasFNS		As Character
Local nContCpo		As Numeric
Local nContEnt 		As Numeric

aDados		:= {}
oFNSStruct	:= oModel:GetStruct()
oModelFN9		:= oModel:GetModel()
oModelFNR		:= oModelFN9:GetModel("GridFNR")
aCposVlr		:= {}
aFilCpos		:= {}
nItem			:= 0
cIDMOV			:= oModelFNR:GetValue("FNR_IDMOV")
cAliasFNS		:= ""
nContCpo		:= 0
nContEnt 		:= 0

aCposVlr := oFNSStruct:GetFields()

If (Type("cBaseAuto") <> "U" .Or. Type("cItemAuto") <> "U") .and. !empty(cBaseAuto +cItemAuto)
	cAliasFNS := QryFNS(cBaseAuto,cItemAuto)
Else
	cAliasFNS := QryFNS(oModelFNR:GetValue("FNR_CBAORI"),oModelFNR:GetValue("FNR_ITEORI"))
EndIf

While (cAliasFNS)->(!Eof())

	nItem++
	For nContCpo := 1 To Len(aCposVlr)
		If aCposVlr[nContCpo][3] == "FNS_FILIAL"
			AADD(aFilCpos,xFilial("FNS"))
		ElseIf aCposVlr[nContCpo][3] == "FNS_DATA"
			AADD(aFilCpos,oModelFNR:GetValue("FNR_DATA"))
		ElseIf aCposVlr[nContCpo][3] == "FNS_TIPO"
			AADD(aFilCpos,(cAliasFNS)->N3_TIPO)
		ElseIf aCposVlr[nContCpo][3] == "FNS_SEQ"
			AADD(aFilCpos,(cAliasFNS)->N3_SEQ)
		ElseIf aCposVlr[nContCpo][3] == "FNS_HISTOR"
			AADD(aFilCpos,(cAliasFNS)->N3_HISTOR)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CONTAO|FNS_CONTAD"	//Conta Contabil
			AADD(aFilCpos,(cAliasFNS)->N3_CCONTAB)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCBEMO|FNS_CCBEMD"	//C Custo da Conta do Bem
			AADD(aFilCpos,(cAliasFNS)->N3_CUSTBEM)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CONDDO|FNS_CONDDD"	//Conta Despesa Depreciacao
			AADD(aFilCpos,(cAliasFNS)->N3_CDEPREC)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCDESO|FNS_CCDESD"	//Centro de Custo Despesa
			AADD(aFilCpos,(cAliasFNS)->N3_CCUSTO)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CONDAO|FNS_CONDAD"	//Conta Deprec. Acumulada
			AADD(aFilCpos,(cAliasFNS)->N3_CCDEPR)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CONCDO|FNS_CONCDD"	//Cta Correcao Depreciacao
			AADD(aFilCpos,(cAliasFNS)->N3_CDESP)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CONCOO|FNS_CONCOD"	//Conta Correcao Bem
			AADD(aFilCpos,(cAliasFNS)->N3_CCORREC)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCDDO|FNS_CCDDD"	//Centro Custo Desp Depr.
			AADD(aFilCpos,(cAliasFNS)->N3_CCDESP)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCDAO|FNS_CCDAD"	//Centro Custo Dep. Acumul.
			AADD(aFilCpos,(cAliasFNS)->N3_CCCDEP)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCCDO|FNS_CCCDD"	//Centro Custo Corr. Depr.
			AADD(aFilCpos,(cAliasFNS)->N3_CCCDES)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCCORO|FNS_CCCORD"	//Centro Custo Corr. Monet.
			AADD(aFilCpos,(cAliasFNS)->N3_CCCORR)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITBEMO|FNS_ITBEMD"	//Item Conta do Bem
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCCON)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITDEDO|FNS_ITDEDD"	//Item Despesa Depreciacao
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCDEP)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITDEAO|FNS_ITDEAD"	//Item Depreciacao Acm
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCCDE)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITCDEO|FNS_ITCDED"	//Item Cor.Des. Depreciacao
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCDES)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITCORO|FNS_ITCORD"	//Item Correcao Monetaria
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCCOR)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITDESO|FNS_ITDESD"	//Item Despesa
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCTA)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVBEMO|FNS_CVBEMD"	//Classe de Valor do Bem
			AADD(aFilCpos,(cAliasFNS)->N3_CLVLCON)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVDEPO|FNS_CVDEPD"	//Classe Vlr Despesa Dep.
			AADD(aFilCpos,(cAliasFNS)->N3_CLVLDEP)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVCDEO|FNS_CVCDED"	//Classe de Vlr Dep. Acum.
			AADD(aFilCpos,(cAliasFNS)->N3_CLVLCDE)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVDESO|FNS_CVDESD"	//Classe de Vlr Cor. Depr.
			AADD(aFilCpos,(cAliasFNS)->N3_CLVLDES)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVCORO|FNS_CVCORD"	//Classe de Vlr Correc Bem
			AADD(aFilCpos,(cAliasFNS)->N3_CLVLCOR)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVDSPO|FNS_CVDSPD"	//Classe de Vlr Despesa
			AADD(aFilCpos,(cAliasFNS)->N3_CLVL)
		ElseIf aCposVlr[nContCpo][3] == "FNS_IDMOV"
			AADD(aFilCpos,cIDMOV)
		ElseIf aCposVlr[nContCpo][3] == "FNS_CODREL"
			AADD(aFilCpos,oModelFNR:GetValue("FNR_CODREL"))
		ElseIf aCposVlr[nContCpo][3] == "OK"
			AADD(aFilCpos,.T.)
		Else
			AADD(aFilCpos,CriaVar(aCposVlr[nContCpo][3],.T.))
		EndIf

		If Len(__aCTBEnt) > 0 .AND. __lEntAdd
			For nContEnt := 1 to Len(__aCTBEnt)
				If AllTrim(aCposVlr[nContCpo][3]) $ "FNS_EC"+__aCTBEnt[nContEnt]+"DO|FNS_EC"+__aCTBEnt[nContEnt]+"DD" //Entidade Adicional a Débito
					aFilCpos[nContCpo] := (cAliasFNS)->&("N3_EC"+__aCTBEnt[nContEnt]+"DB") //Adiciono na posição já existente, pois o for de cima preenche como branco.
				ElseIF AllTrim(aCposVlr[nContCpo][3]) $ "FNS_EC"+__aCTBEnt[nContEnt]+"CO|FNS_EC"+__aCTBEnt[nContEnt]+"CD" //Entidade Adicional a Crédito
					aFilCpos[nContCpo] := (cAliasFNS)->&("N3_EC"+__aCTBEnt[nContEnt]+"CR")
				EndIf
			Next nContEnt
		EndIf

	Next nContCpo

	AADD(aFilCpos,.T.)
	AADD(aDados,{0,aFilCpos})

	aFilCpos := {}

	(cAliasFNS)->(DbSkip())
EndDo

If Select(cAliasFNS) > 0
	(cAliasFNS)->(DbCloseArea())
EndIf

Return aDados

/*{Protheus.doc} AT060QryFNS
Query para carregar FNS com base na SN3
@author Mayara Alves
@since 18/05/2015
@return cAliasFNS
@version P12
*/
Static Function QryFNS(cBase As Character,cItem As Character) As Character

	Local cQry		As Character
	Local cAliasFNS	As Character
	Local lTransf	As Logical
	Local nContEnt  As Numeric

	Default cBase	:= ""
	Default cItem	:= ""

	cQry		:= ""
	cAliasFNS	:= GetNextAlias()
	lTransf		:=  FWIsInCallStack("AF126TRANS") .And. !(xFilial("SN1",SNM->NM_FILDEST) !=  xFilial("SN1")) // Transferência de Filial não se considera TIPO
	nContEnt := 0

	cQry := "SELECT N3_ITEM,N3_TIPO,N3_SEQ,N3_HISTOR,N3_CCUSTO,N3_CCONTAB,N3_CCORREC,N3_CDESP," +CRLF
	cQry += "N3_CCDEPR,N3_CDEPREC,N3_CUSTBEM,N3_CCCORR,N3_CCDESP,N3_CCCDEP,N3_CCCDES," +CRLF
	cQry += "N3_SUBCCON,N3_SUBCCOR,N3_SUBCDEP,N3_SUBCCDE,N3_SUBCDES,N3_SUBCTA,N3_CLVLCON,N3_CLVLCOR," +CRLF
	cQry += "N3_CLVLDEP,N3_CLVLCDE,N3_CLVLDES,N3_CLVL " +CRLF
	If Len(__aCTBEnt) > 0 .AND. __lEntAdd
		For nContEnt := 1 to Len(__aCTBEnt)
			cQry += ",N3_EC"+__aCTBEnt[nContEnt]+"DB, N3_EC"+__aCTBEnt[nContEnt]+"CR "
		Next nContEnt
	EndIf
	cQry += "FROM " + RetSqlName("SN3") + " SN3 " +CRLF
	cQry += "WHERE N3_FILIAL = '" + FWXFilial("SN3") + "' "+CRLF
	cQry += "AND N3_CBASE = '" + cBase	+ "' " +CRLF //Até Bem
	cQry += "AND N3_ITEM =  '" + cItem+ "' " +CRLF //Do Item
	cQry += "AND N3_BAIXA <> '1' " +CRLF //Nao transfere tipo baixado
	If lTransf
		cQry += "AND N3_TIPO =  '" + cTipoAuto+ "' " +CRLF
	EndIf
	cQry += "AND SN3.D_E_L_E_T_ = ' ' " +CRLF

	cQry := ChangeQuery( cQry )

	dbUseArea( .T. , "TOPCONN" , TcGenQry(,,cQry) , cAliasFNS , .T. , .F.)

	dbSelectArea(cAliasFNS)

Return cAliasFNS

/*{Protheus.doc}AF060TRG
Função de Gatilho , para gatilhar os campos da FN9 para FNR
@author Jose Augusto Ribeiro
@since 11/05/2015
@version P12
@param cCampo, Caracter, Nome do Campo que ira ser gatilhado
@return cRet,Caracter ,Retorno do Conteudo que deve ser gatilhado
*/
Function AF060TRG(cCampo As Character) As Character

	Local aArea			As Array
	Local oModel		As Object
	Local oModelFN9		As Object
	Local cRet			As Character
	Local oModelFNR		As Object
	Local oModelFNS		As Object
	Local nI			As Numeric
	Local nFNs			As Numeric
	Local oView			As Object
	Local aSaveLines	As Array
	Local lSCDP			As Logical
	Local lCVDP			As Logical
	Local nQtdVol       As Numeric
	Local nC            As Numeric
	Local cMVATFCPMN    As Character
	Local aCpoMarFN9    As Array
	Local aCpoMarFNR    As Array
	Local cCpoMarFN9    As Character
	Local cCpoNumFN9    As Character
	Local cCpoMarFNR    As Character
	Local cCpoNumFNR    As Character
	Local nContEnt 		As Numeric

	aArea			:= GetArea()
	oModel			:= FwModelActive()
	oModelFN9		:= oModel:GetModel('FieldFN9')
	cRet			:= ""
	oModelFNR		:= oModel:GetModel('GridFNR')
	oModelFNS		:= oModel:GetModel('GridFNS')
	nI				:= 0
	nFNs			:= 0
	oView			:= FWViewActive()
	aSaveLines		:= FWSaveRows()
	lSCDP			:= SuperGetMV("MV_ATFSCDP",.F.,.F.)
	lCVDP			:= SuperGetMV("MV_ATFCVDP",.F.,.F.)
	nQtdVol         := QTDVOLNF()
	nC            	:= 0
	cMVATFCPMN    	:= AllTrim(SuperGetMV('MV_ATFCPMN',, ''))
	aCpoMarFN9    	:= {}
	aCpoMarFNR   	:= {}
	cCpoMarFN9   	:= ''
	cCpoNumFN9   	:= ''
	cCpoMarFNR   	:= ''
	cCpoNumFNR  	:= ''

	nContEnt := 0

	If !Empty(cMVATFCPMN)
		aCpoMarFN9 := StrTokArr2(cMVATFCPMN, ";", .T.)
		aCpoMarFNR := StrTokArr2(cMVATFCPMN, ";", .T.)
	EndIf

	If Len(aCpoMarFN9) >= 4
		cCpoMarFN9 := AllTrim(aCpoMarFN9[3])
		cCpoNumFN9 := AllTrim(aCpoMarFN9[4])
	EndIf

	If Len(aCpoMarFNR) >= 6
		cCpoMarFNR := AllTrim(aCpoMarFNR[5])
		cCpoNumFNR := AllTrim(aCpoMarFNR[6])
	EndIf

	_lShowMsg := .T.

	If "FN9" $ cCampo
		cRet := oModelFN9:GetValue(cCampo)
	ElseIf "FNR" $ cCampo
		cRet := oModelFNR:GetValue(cCampo)
	EndIf
	//Realizar Alltrim apenas se o campo for do tipo caractere, campos numéricos não realizar
	If  ValType(cRet) == 'C'
		cRet := Alltrim(cRet)
	EndIf

	For nI := 1 To oModelFNR:Length()
		oModelFNR:GoLine(nI)

		//------------------------------
		// Campos da pasta Dados Gerais
		//------------------------------
		If(cCampo == "FN9_FILDES")
			oModelFNR:SetValue('FNR_FILDES',cRet)

		ElseIf(cCampo == "FN9_DATA")
			oModelFNR:LoadValue('FNR_DATA',cRet)
			oModelFNS:LoadValue('FNS_DATA',cRet)

		ElseIf(cCampo == "FN9_GRPDES")
			If ReadVar() == "M->FN9_GRPDES"
				If oModelFNR:LoadValue("FNR_GRPDES", If(cRet == '*', " ", cRet) )
					Af060Grupo( If(cRet == '*', oModelFNR:GetValue("FNR_GRPORI"), cRet) )
				EndIf
			Else
				If oModelFNR:SetValue("FNR_GRPDES", If(cRet == '*', " ", cRet) )
					Af060Grupo( If(cRet == '*', oModelFNR:GetValue("FNR_GRPORI"), cRet) )
				EndIf
			EndIf

		ElseIf(cCampo == "FN9_LOCDES")
			oModelFNR:SetValue("FNR_LOCDES", If(cRet == '*', oModelFNR:GetValue("FNR_LOCORI"), cRet) )

		ElseIf(cCampo == "FN9_TXPADD")
			oModelFNR:SetValue("FNR_TXPADD", If(cRet == '*', oModelFNR:GetValue("FNR_TXPADO"), cRet) )

		ElseIf(cCampo == "FN9_QTDDES")
			oModelFNR:SetValue("FNR_QTDDES", If(cRet == 0, oModelFNR:GetValue("FNR_QTDORI"), cRet) )

		ElseIf(cCampo == "FN9_CCDESD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCDESD", If(cRet == '*', oModelFNS:GetValue("FNS_CCDESO"), cRet) )
			Next nFNs

		//--------------------------------
		// Campos da pasta Conta Contabil
		//--------------------------------
		ElseIf(cCampo == "FN9_CONTAD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CONTAD", If(cRet == '*', oModelFNS:GetValue("FNS_CONTAO"), cRet) )
			Next nFNs

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CONCOD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CONCOD", If(cRet == '*', oModelFNS:GetValue("FNS_CONCOO"), cRet) )
			Next nFNs

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CONDDD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CONDDD", If(cRet == '*', oModelFNS:GetValue("FNS_CONDDO"), cRet) )
			Next nFns

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CONDAD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CONDAD", If(cRet == '*', oModelFNS:GetValue("FNS_CONDAO"), cRet) )
			Next nFNs

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CONCDD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CONCDD", If(cRet == '*', oModelFNS:GetValue("FNS_CONCDO"), cRet) )
			Next nFNs

			oModelFNS:GoLine(1)

		//---------------------------------
		// Campos da pasta Centro de Custo
		//---------------------------------
		ElseIf(cCampo == "FN9_CCBEMD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCBEMD", If(cRet == '*', oModelFNS:GetValue("FNS_CCBEMO"), cRet) )
			Next nFns

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CCCORD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCCORD", If(cRet == '*', oModelFNS:GetValue("FNS_CCCORO"), cRet) )
			Next nFns

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CCDDD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCDDD", If(cRet == '*', oModelFNS:GetValue("FNS_CCDDO"), cRet) )
			Next nFns

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CCDAD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCDAD", If(cRet == '*', oModelFNS:GetValue("FNS_CCDAO"), cRet) )
			Next nFns

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_CCCDD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCCDD", If(cRet == '*', oModelFNS:GetValue("FNS_CCCDO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		//-------------------------------
		// Campos da pasta Item Contabil
		//-------------------------------
		ElseIf(cCampo =="FN9_ITBEMD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_ITBEMD", If(cRet == '*', oModelFNS:GetValue("FNS_ITBEMO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_ITCORD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_ITCORD", If(cRet == '*', oModelFNS:GetValue("FNS_ITCORO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_ITDEDD")
			If lSCDP .and. oModelFNS:HasField("FNS_ITDESD")
				If  cRet != '*' .and. !isBlind()
					MsgInfo(STR0218)//"Conteúdo do parâmetro MV_ATFSCDP = T será considerado valor do campo: IT Desp Dest"
				EndIf
				For nFNs := 1 To oModelFNS:Length()
					oModelFNS:GoLine(nFns)
					oModelFNS:SetValue("FNS_ITDEDD", If(cRet == '*', oModelFNS:GetValue("FNS_ITDEDO"), oModelFNS:GetValue("FNS_ITDESD")))
				Next nFNs
				oModelFN9:LoadValue("FN9_ITDEDD", If(cRet == '*', "", oModelFNS:GetValue("FNS_ITDESD")))
			Else
				For nFNs := 1 To oModelFNS:Length()
					oModelFNS:GoLine(nFns)
					oModelFNS:SetValue("FNS_ITDEDD", If(cRet == '*', oModelFNS:GetValue("FNS_ITDEDO"), cRet) )
				Next nFNS
			EndIf

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_ITDEAD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_ITDEAD", If(cRet == '*', oModelFNS:GetValue("FNS_ITDEAO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_ITCDED")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_ITCDED", If(cRet == '*', oModelFNS:GetValue("FNS_ITCDEO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		//---------------------------------
		// Campos da pasta Classe de Valor
		//---------------------------------
		ElseIf(cCampo =="FN9_CVBEMD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CVBEMD", If(cRet == '*', oModelFNS:GetValue("FNS_CVBEMO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_CVCORD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CVCORD", If(cRet == '*', oModelFNS:GetValue("FNS_CVCORO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_CVDEPD")
			If lCVDP .and. oModelFNS:HasField("FNS_CVDSPD")
				If  cRet != '*' .and. !isBlind()
					MsgInfo(STR0219)//"Conteúdo do parâmetro MV_ATFCVDP = T será considerado valor do campo: CV Desp Dest"
				EndIf
				For nFNs := 1 To oModelFNS:Length()
					oModelFNS:GoLine(nFns)
					oModelFNS:SetValue("FNS_CVDEPD", If(cRet == '*', oModelFNS:GetValue("FNS_CVDEPO"), oModelFNS:GetValue("FNS_CVDSPD")))
				Next nFNs
				oModelFN9:LoadValue("FN9_CVDEPD", If(cRet == '*', "", oModelFNS:GetValue("FNS_CVDSPD")))
			Else
				For nFNs := 1 To oModelFNS:Length()
					oModelFNS:GoLine(nFns)
					oModelFNS:SetValue("FNS_CVDEPD", If(cRet == '*', oModelFNS:GetValue("FNS_CVDEPO"), cRet) )
				Next nFNS
			EndIf

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_CVCDED")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CVCDED", If(cRet == '*', oModelFNS:GetValue("FNS_CVCDEO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_CVDESD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CVDESD", If(cRet == '*', oModelFNS:GetValue("FNS_CVDESO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		//-----------------------------
		// Campos da pasta Nota Fiscal
		//-----------------------------
		ElseIf(cCampo == "FN9_GERNF")
			oModelFNR:SetValue("FNR_GERNF",cRet)

		ElseIf(cCampo == "FN9_SERIE")
			oModelFNR:SetValue("FNR_SERIE",cRet)

		ElseIf(cCampo == "FN9_CLSNF")
			oModelFNR:SetValue("FNR_CLSNF",cRet)
			If cRet == "1"
				If oModelFN9:HasField("FN9_ARMAZE")  //Nota Fiscal a Classificar não deve ser preenchido armazem
					oModelFN9:LoadValue("FN9_ARMAZE","")
					oModelFNR:LoadValue("FNR_ARMAZE","")
				EndIf
			EndIf
		ElseIf(cCampo == "FN9_TESSAI")
			oModelFNR:SetValue("FNR_TESSAI",cRet)

		ElseIf(cCampo == "FN9_TESENT")
			oModelFNR:SetValue("FNR_TESENT",cRet)

		ElseIf(cCampo == "FN9_VALNF")
			oModelFNR:SetValue("FNR_VALNF",cRet)

		ElseIf(cCampo == "FN9_ESPECI")
			if oModelFN9:HasField("FN9_ESPECI")
				oModelFNR:SetValue("FNR_ESPECI",cRet)
				If !Empty(FWfldGet("FN9_SERIE")) 
					oModelFN9:LoadValue("FN9_SERIE","")
					oModelFNR:LoadValue("FNR_SERIE","")
				EndIf
			EndIf
		ElseIf(cCampo == "FN9_ARMAZE")
			if oModelFN9:HasField("FN9_ARMAZE")
				oModelFNR:SetValue("FNR_ARMAZE",cRet)
			EndIf
		ElseIf(cCampo == "FN9_ITDESD")
			if oModelFN9:HasField("FN9_ITDESD")
				For nFNs := 1 To oModelFNS:Length()
					oModelFNS:GoLine(nFns)
					oModelFNS:SetValue("FNS_ITDESD", If(cRet == '*', oModelFNS:GetValue("FNS_ITDESO"), cRet))
				Next nFNs
			EndIf
		ElseIf(cCampo == "FN9_CVDSPD")
			if oModelFN9:HasField("FN9_CVDSPD")
				For nFNs := 1 To oModelFNS:Length()
					oModelFNS:GoLine(nFns)
					oModelFNS:SetValue("FNS_CVDSPD", If(cRet == '*', oModelFNS:GetValue("FNS_CVDSPO"), cRet))
				Next nFNs
			EndIf
		ElseIf(cCampo == "FN9_TRANSP")
			If oModelFNR:HasField("FNR_TRANSP")
				oModelFNR:SetValue("FNR_TRANSP",cRet)
			EndIf
		ElseIf(cCampo == "FN9_TPFRET")
			If oModelFNR:HasField("FNR_TPFRET")
				oModelFNR:SetValue("FNR_TPFRET",cRet)
			EndIf
		ElseIf(cCampo == "FN9_PESOL")
			If oModelFNR:HasField("FNR_PESOL")
				oModelFNR:SetValue("FNR_PESOL",cRet)
			EndIf
		ElseIf(cCampo == "FN9_PBRUTO")
			If oModelFNR:HasField("FNR_PBRUTO")
				oModelFNR:SetValue("FNR_PBRUTO",cRet)
			EndIf
		EndIf

		If ("FN9_VOLUM" $ cCampo) .Or. ("FN9_ESPEC" $ cCampo) .Or. ("FN9_VEICU" $ cCampo) .Or. (cCpoMarFN9 $ cCampo) .Or. (cCpoNumFN9 $ cCampo)
			For nC := 1 To nQtdVol // Tratamento para até 9 volumes.
				If(cCampo == "FN9_VOLUM" + AllTrim(Str(nC)))
					If oModelFNR:HasField("FNR_VOLUM" + AllTrim(Str(nC)))
						oModelFNR:SetValue("FNR_VOLUM" + AllTrim(Str(nC)),cRet)
					EndIf
				ElseIf(cCampo == "FN9_ESPEC" + AllTrim(Str(nC)))
					If oModelFNR:HasField("FNR_ESPEC" + AllTrim(Str(nC)))
						oModelFNR:SetValue("FNR_ESPEC" + AllTrim(Str(nC)),cRet)
					EndIf
				ElseIf(cCampo == "FN9_VEICU" + AllTrim(Str(nC)))
					If oModelFNR:HasField("FNR_VEICU" + AllTrim(Str(nC)))
						oModelFNR:SetValue("FNR_VEICU" + AllTrim(Str(nC)),cRet)
					EndIf
				ElseIf(cCampo == cCpoMarFN9 + AllTrim(Str(nC)))
					If oModelFNR:HasField(cCpoMarFNR + AllTrim(Str(nC)))
						oModelFNR:SetValue(cCpoMarFNR + AllTrim(Str(nC)),cRet)
					EndIf
				ElseIf(cCampo == cCpoNumFN9 + AllTrim(Str(nC)))
					If oModelFNR:HasField(cCpoNumFNR + AllTrim(Str(nC)))
						oModelFNR:SetValue(cCpoNumFNR + AllTrim(Str(nC)),cRet)
					EndIf
				EndIf
			Next nC
		EndIf

		//-----------------------------
		// Campos Entidades Adicionais
		//-----------------------------

		If Len(__aCTBEnt) > 0 .AND. __lEntAdd
			For nContEnt := 1 to Len(__aCTBEnt)
				If(cCampo =="FN9_EC"+__aCTBEnt[nContEnt]+"DD")
					For nFNs := 1 To oModelFNS:Length()
						oModelFNS:GoLine(nFns)
						oModelFNS:SetValue("FNS_EC"+__aCTBEnt[nContEnt]+"DD", If(cRet == '*', oModelFNS:GetValue("FNS_EC"+__aCTBEnt[nContEnt]+"DO"), cRet) )
					Next nFNS
				ElseIf (cCampo =="FN9_EC"+__aCTBEnt[nContEnt]+"CD")
					For nFNs := 1 To oModelFNS:Length()
						oModelFNS:GoLine(nFns)
						oModelFNS:SetValue("FNS_EC"+__aCTBEnt[nContEnt]+"CD", If(cRet == '*', oModelFNS:GetValue("FNS_EC"+__aCTBEnt[nContEnt]+"CO"), cRet) )
					Next nFNS
				EndIf
			oModelFNS:GoLine(1)
			Next nContEnt
		Endif
	Next nI

	FWRestRows(aSaveLines)

	//--------------------------------------------------------------------------------
	// Restaura o valor da variavel que define a forma de atualização com base na SNG
	//--------------------------------------------------------------------------------
	If cCampo == "FN9_GRPDES"
		__nAtuGrp	:= 2
	EndIf

	If oView != Nil
		oView:Refresh('View_FNR')
		oView:Refresh('View_FNS')
	EndIf

	RestArea(aArea)

Return cRet

/*{Protheus.doc} AF060DATA
Função de Validação da Data de Tansferencia
@author Jose Augusto Ribeiro
@since 18/05/2015
@version P12
@param dData, data , Data da Transferencia
@param lAuto,Logico, (Descrição do parâmetro)
@return lRet,Logico, Retorno .T. validado  ou .F. não validado
*/
Function AF060Data(dData)
Local lRet			:= .T.
Local dUltDepr		:= GetMV("MV_ULTDEPR")
Local lGspInUseM	:= IIf(Type('lGspInUse')=='L', lGspInUse, .F.)
Local cCalcDep		:= GetMV("MV_CALCDEP",.F.,"0")
Local dDataBloq		:= GetNewPar("MV_ATFBLQM",CTOD("")) //Data de Bloqueio da Movimentação - MV_ATFBLQM
Local cTipDepr		:= GetMv("MV_TIPDEPR")
Default dData		:= dDatabase

dbSelectArea("SN1")
SN1->(dbSetOrder(1))
SN1->(dbSeek(SN3->N3_FILIAL+SN3->N3_CBASE+SN3->N3_ITEM)) //Posiciona na SN1 conforme SN3 usada para usar na validação

If lGspInUseM
	dUltDepr := MsSomaMes(dUltDepr,-1,.T.)//Se for GSP, pega o ultimo dia do mes anterior
Endif

If !Empty(dData) .AND. (dData <= dDataBloq)
	HELP(" ",1,"AF060BLQM",,STR0061 + DTOC(dDataBloq) ,1,0) //"A data de aquisição do bem é igual ou menor que a data de bloqueio de movimentação : "
	lRet := .F.
ElseIf cCalcDep == "0" // Depreciação Mensal
	If dData <= dUltDepr .Or. dData > LastDay(dUltDepr+1)
		//Tipo Depreciacao diferente 02-Mes Subsequente
		If cTipDepr <> "2"
			Help(" ",1,"AFDTTRANS") //A transferência só pode ocorrer no mês  imediatamente posterior ao último cálculo mensal de correção e depreciação.
			lRet := .F.
		ElseIf dData < (FirstDay(dUltDepr))
			Help(" ",1,"AfA060DFIL",,STR0049+DTOC(dUltDepr),1,0) //"A Database do sistema deve ter o mês igual ao parâmetro MV_ULTDEPR = "
			lRet := .F.
		Endif
	End
Else
	If Year(dDataBase) <= Year(dUltDepr) .Or. (Year(dDataBase) > Year(dUltDepr) + 1)
		Help(" ",1,"AFDTTRANS") //A transferência só pode ocorrer no mês  imediatamente posterior ao último cálculo mensal de correção e depreciação.
		lRet := .F.
	Endif
EndIf

//Validacao para o bloqueio do proceco
If lRet .And. !CtbValiDt(,dData  ,,,,{"ATF001"},)
	lRet := .F.
EndIf

If lRet .And. dData < SN1->N1_AQUISIC
	Help(" ",1,"A060DTAQUI") //A data da transferência não pode ser    anterior a data de aquisição do bem.
	lRet := .F.
End

If lRet .And. FwIsInCallStack("ATFA126") .And. dData < SNM->NM_DATSOL
	Help('',1,'A060DTINF',,STR0203,1,0)
	lRet := .F.
End

Return lRet

/*{Protheus.doc} AFA060FIL
Verifica as Filiais de Destino
@author Jose Augusto Ribeiro
@since 18/05/2015
@version P12
@param cFildes,caracter,Codigo da Filial Destino
@return lRet,Logico,Retorno .T. validado  ou .F. não validado
*/
Function AFA060FIL(cFilDes,lGerNF)
Local lRet			:= .T.
Local aArea			:= GetArea()
Local cEmpAtu		:= SM0->M0_CODIGO
Local cFilOri		:= cFilAnt
Local cTipoDepr		:= GetMv("MV_TIPDEPR")
Local dUltDeprOr	:= GetMv("MV_ULTDEPR")
Local dUltDeprDs	:= ""
Local nRecEmp		:= 0
Local cCNPJCli		:= ""
Local cCNPJFor		:= SM0->M0_CGC
Local lAF060DES		:= ExistBlock("AF060DES")

DbSelectArea("SM0")
nRecEmp := Recno()

If(!DbSeek(cEmpAtu+cFilDes))

	Help(" ",1,"AFA060FIL") // Esta filial nao existe
	lRet := .F.

ElseIf lAF060DES
	lRet := ExecBlock("AF060DES",.F.,.F.,{cFilDes,dUltDeprOr,dUltDeprDs})

ElseIf !A060VLDFil(cFilDes) .And. (IIf(FindFunction("ADMTabExc"), ADMTabExc("SN3"), !Empty(xFilial("SN3"))))//Valida a filial somente para situação de tabela exclusiva
	lRet := .F.
	Help('',1,'AFA060VLD',,STR0113,1,0) //"Usuario não possui acesso a filial destino"

ElseIf(cTipoDepr == '2' .And. ( cFilOri <> cFilDes )) //Tipo Depreciacao = 02(Mes Subsequente)

	DbGoto(nRecEmp)
	cFilAnt := cFilDes
	dUltDeprDs	:= GetMv("MV_ULTDEPR")
	If( dUltDeprOr <> dUltDeprDs )//Compara data da ultima depreciacao (filiais origem e destino)

		Help(" ",1,"AfA060Fil",,STR0050+CRLF+STR0051+DTOC(dUltDeprOr)+CRLF+STR0052+DTOC(dUltDeprDs)+CRLF+CRLF+STR0053,1,0) //"A Data do último cálculo de depreciação da Filial Origem está diferente da Filial Destino"##"Filial Origem = "##"Filial Destino = "##"A transferência não poderá ser realizada para esta Filial"
		lRet := .F.

	EndIf
EndIf

DbGoto(nRecEmp)
cFilAnt := cFilOri
dUltDeprDs := GetMv("MV_ULTDEPR")
If(lRet)
	If( cFilOri <> cFilDes )
		If ( SN1->N1_TPCTRAT == "3")

			Help(" ",1,"AfA060TERC",,STR0068 ,1,0)//"Bens em controle de terceiro não podem ser transferidos"
			lRet := .F.

		EndIf
	EndIf
EndIf

//---------------------------------------------------------------------
// Verifica se a filial destino possui CNPJ informado na geracao de NF
//---------------------------------------------------------------------
If lRet .And. (lGerNF .and. !FwIsInCallStack("ATFA126") .and. !FwIsInCallStack("MNTA550") ) .And. Empty( cCNPJCli := GetAdvFVal("SM0","M0_CGC",cEmpAnt+cFilDes,1,""))
	lRet := .F.
	Help( "", 1, "AFA060FIL", , STR0122 ,1, 0 )//"A filial de destino não possui CNPJ cadastrado, impossibilitando a geração da NF."
EndIf

//---------------------------------------------------------------------------------------------------
// Verifica se a filial de destino esta cadastrada como cliente na filial de origem na geracao de NF
//---------------------------------------------------------------------------------------------------
If lRet .And. (lGerNF .and. !FwIsInCallStack("ATFA126") .and. !FwIsInCallStack("MNTA550") )   .And. Empty(GetAdvFVal("SA1","A1_COD",XFilial("SA1") + PadR(cCNPJCli,TamSX3("A1_CGC")[1]),3,""))
	lRet := .F.
	Help( "", 1, "AFA060FIL", , STR0123 ,1, 0 )//"A filial de destino não está cadastrada como cliente na filial de origem, impossibilitando a geração da NF. Efetue o cadastro utilizando o CNPJ da filial de destino."
EndIf

//------------------------------------------------------------------------------------------------------
// Verifica se a filial de origem esta cadastrada como fornecedor na filial de destino na geracao de NF
//------------------------------------------------------------------------------------------------------
If lRet .And. (lGerNF .and. !FwIsInCallStack("ATFA126") .and. !FwIsInCallStack("MNTA550") )  .And. Empty(GetAdvFVal("SA2","A2_COD",XFilial("SA2",cFilDes) + PadR(cCNPJFor,TamSX3("A2_CGC")[1]),3,""))
	Help( "", 1, "AFA060FIL", , STR0124 ,1, 0 ) //"A filial de origem não está cadastrada como fornecedor na filial de destino, impossibilitando a geração da NF. Efetue o cadastro utilizando o CNPJ da filial de origem."
	lRet :=.F.
EndIf

RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060VLGRP
Valida o Grupo de Transferencia do Bem
@author Jose Augusto Ribeiro
@since 18/05/2015
@version P12
@param  cGrupo,Caracter,Codigo do Grupo
@param  cFilDest,Caracter,Codigo da Filial Destino
@return lRet,Logico,Retorno .T. validado  ou .F. não validado
*/
Function AF060VLGRP( cGrupo , cFilDest , cTabela )
Local lRet		:= .T.
Local aArea		:= GetArea()
Local aAreaSNG	:= SNG->(GetArea())

Default cGrupo := ""
Default cFilDest := ""
Default cTabela	:= SUBSTR(ReadVar(),4,3)

If lRet .And. !Empty(cGrupo) .And. AllTrim(cGrupo) <> "*"
	DbSelectArea("SNG")
	SNG->(DbSetOrder(1))
	lRet := SNG->(DbSeek(xFilial("SNG",cFilDest)+cGrupo))
EndIf



If lRet .And. (("FN9" $ cTabela) .Or. "FNR" $ cTabela .And. !FWIsInCallStack("AF060TRG"))

	//----------------------------------------------------------------------------------------------------
	// Caso o grupo seja informado, apresenta para o usuário a opção de espelhar ou complementar os dados
	// __nAtuGrp == 1 - Atualizar - Campos em branco na SNG serão desconsiderados
	// __nAtuGrp == 2 - Espelhar - Campos em branco na SNG serão considerados
	// __nAtuGrp == 3 - Cancelado pelo usuário
	//----------------------------------------------------------------------------------------------------
	If !Empty(cGrupo)

		If IsBlind()
			__nAtuGrp := iIf( __lEspGrp , 2 , 1 ) //Considerar Parâmetro lEspelha Informado via Execauto
		Else

			__nAtuGrp := AVISO( "AF060VLGRP",				;
								STR0187 + CRLF + CRLF +		;	//"Grupo de Bens alterado, defina a forma de atualização dos dados:"
								STR0188 + CRLF + CRLF +		;	//"Espelhar - Considera os campos do cadastro do Grupo de Bens (inclusive campos em branco)."
								STR0189 + CRLF + CRLF +		;	//"Atualizar - Considera somente os campos preenchidos no cadastro de Grupo de Bens (desconsidera campos em branco)."
								STR0202 + CRLF + CRLF +     ;	//"Obs: Na alteracao de grupo de bens nao serao incluídos novos tipos."
								STR0232 + "https://tdn.totvs.com/x/FKnSHg",;	//"Para saber quais campos são atualizados, acesse a página: "				
								{STR0190,STR0191,STR0192},	;	//"Atualizar"###"Espelhar"###"Cancelar"
								3 )
		EndIf

		If __nAtuGrp == 3 //Cancelado pelo Usuário
			HELP(" ",1,"AF060VLGRP",,STR0201 ,1,0) //"Grupo nao confirmado. Verifique!"
			lRet := .F.
		EndIf

	//-------------------------------------------------------------------------------
	// Caso o grupo seja limpo, apresenta a opção de limpar todos os dados contábeis
	//-------------------------------------------------------------------------------
	Else

		If IsBlind()
			__nAtuGrp := 2 //Caso não tenha tela, mantém a opção de espelhar
		Else

			If MsgYesNo(STR0107,STR0106) //"Grupo de Bens alterado, alterar dados contabeis?" ,"Confirma?"
				__nAtuGrp := 2 //Espelhar - Considera campos em branco da SNG
			Else
				lRet := .F.
				HELP(" ",1,"AF060VLGRP",,STR0201 ,1,0) //"Grupo nao confirmado. Verifique!"
			EndIf

		EndIf

	EndIf

EndIf

RestArea( aAreaSNG )
RestArea( aArea    )

Return lRet

/*{Protheus.doc} AFTemTp14
Valida se existe Tipo 14 - AVP para o Ativo
@author Jose Augusto Ribeiro
@since 18/05/2015
@version P12
@param  cTipo ,Caracter,Tipo do Bem
@param  cCbase,Caracter,Codigo do Bem
@param  cItem,Caracter,Codigo do Item do Bem
@return lRet,Logico,Retorno .T. validado  ou .F. não validado
*/
Function AFTemTp14(cTipo , cCbase, cItem)
Local aArea		:= GetArea()
Local aAreaSN3	:= SN3->(GetArea())
Local lRet		:= .F.

DEFAULT cCbase	:= ""
DEFAULT cTipo	:= ""
DEFAULT cItem	:= ""

If cTipo == '14'
	lRet := .T.
Else
	DbSelectArea("SN3")
	SN3->(DbSetOrder(11))//N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO
	If(SN3->(MsSeek(xFilial("SN3") + cCbase + cItem + "14")))
		lRet := .T.
	EndIf
EndIf

RestArea(aAreaSN3)
RestArea(aArea)

Return lRet

/*{Protheus.doc} A060TXRALT
Não permite alterar a taxa caso ela seja preenchida pelo grupo de bens

@author Jose Augusto Ribeiro
@since 18/05/2015
@version P12
@param  cCbase,Caracter,Codigo do Grupo do Bem
@return lRet,Logico,Retorno .T. validado  ou .F. não validado
*/
Function A060TXRALT(cGrupo)
Local lRet		:= .T.
Local aArea		:= GetArea()
Local aAreaSNG	:= SNG->(GetArea())

If !FWIsInCallStack("Af060Grupo") //Tratamento para permitir o preenchimento quando feito pelo Grupo de Bens

	If !Empty( cGrupo )
		DbSelectArea("SNG")
		SNG->( DbSetOrder(1) )

		If SNG->( DbSeek( xFilial( "SNG" ) + cGrupo ) )
			lRet := Empty(SNG->NG_TAXAPAD)
		EndIf
	EndIf

EndIf

RestArea(aAreaSNG)
RestArea(aArea)

Return lRet

/*{Protheus.doc} A060TXRVLD
Validação do cadastro de taxa
@author Daniel Mendes
@since 20/10/2016
@version P12
@param  cTaxa, cFilDest
@return lRet,Logico,Retorno .T. validado  ou .F. não validado
*/
Function A060TXRVLD(cTaxa,cFilDest)
Local lRet			:= .T.
Local aArea			:= GetArea()
Local aAreaSNH		:= SNH->( GetArea() )

Default cTaxa		:= ""
Default cFilDest	:= XFilial("SNH")

If !Empty(cTaxa) .And. AllTrim(cTaxa) <> "*"
	SNH->(DBSetOrder(1)) //NH_FILIAL+NH_CODIGO
	lRet := SNH->(MsSeek(xFilial("SNH",cFilDest)+cTaxa))
EndIf

RestArea(aAreaSNH)
RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060MOEDA
Verifica se tem data cadastrada na data informada
@author Jose Augusto Ribeiro
@since 20/05/2015
@version P12
@param dData, data, data a ser verificada
@return lRet, Logico, Retorno .T. validado  ou .F. não validado
*/
Function AF060MOEDA(dData,nTaxaDepr)
Local aArea			:= GetArea()
Local aAreaSM2		:= SM2->(GetArea())
Local lRet			:= .T.

Default nTaxaDepr		:= 0

Private cAtfMoeda	:= GETMV("MV_ATFMOED")

DbSelectArea("SM2")
DbSetOrder(1)
If SM2->(MsSeek(dData))
	nTaxaDepr := &("SM2->M2_MOEDA"+cAtfMoeda)
EndIf

RestArea(aAreaSM2)
RestArea(aArea)

Return lRet

/*{Protheus.doc} A060BLQLOC
Bloqueia e Desbloqueia o bem dependendo do local
@author Jose Augusto Ribeiro
@since 20/05/2015
@version P12
@param cLocalAtf, caracter, Codigo do Local do Ativo
@param cBase, caracter, Codigo base o Bem
@param cItem, caracter, Codigo do Item do Bem
*/
Static Function A060BLQLOC(cLocalAtf As Character, cBase As Character, cItem As Character)
	Local aArea		As Array
	Local aAreaSN1	As Array
	Local aAreaSNL	As Array
	Local cStatus	As Character

	aArea		:= GetArea()
	aAreaSN1	:= SN1->(GetArea())
	aAreaSNL	:= SNL->(GetArea())
	cStatus		:= "1"

	DbSelectArea("SNL")
	SNL->(DbSetOrder(1))
	SN1->(DbSetOrder(1))

	If(SNL->(DbSeek(xFilial("SNL")+cLocalAtf)))
		If(SNL->NL_BLOQ == '1')
			cStatus := "3"
		EndIf
	EndIf
	If(SN1->(DbSeek(xFilial("SN1")+cBase+cItem)) .And. SN1->N1_STATUS $ "1|3")
		RecLock("SN1",.F.)
		SN1->N1_STATUS := cStatus
		SN1->(MsUnlock()) 
	EndIf

	RestArea(aAreaSN1)
	RestArea(aAreaSNL)
	RestArea(aArea)

Return

/*{Protheus.doc} A060VERIND
Verifica se ha um indicie de depreciação na filial destino
@author Jose Augusto Ribeiro
@since 20/05/2015
@version P12
@param nRecnoSN3, numérico , (Descrição do parâmetro)
@param cFilDest , caracter, (Descrição do parâmetro)
@return lRet    , Logico   , Retorno .T. validado  ou .F. não validado
*/
Static Function A060VERIND(nRecnoSN3,cFilDest)
	Local aArea		:= GetArea()
	Local aAreaSN3	:= SN3->(GetArea())
	Local cFilAux	:= ""
	Local cBaseAux	:= ""
	Local cItemAux	:= ""
	Local cTipoInd	:= ""
	Local lRet		:= .T.

	SN3->(DbSetOrder(1))
	SN3->(DbGoto(nRecnoSN3))

	cFilAux		:= SN3->N3_FILIAL
	cBaseAux	:= SN3->N3_CBASE
	cItemAux	:= SN3->N3_ITEM

	While(SN3->(!EOF()) .And. cFilAux+cBaseAux+cItemAux == SN3->(N3_FILIAL+N3_CBASE+N3_ITEM))
		If(SN3->N3_TPDEPR == "A")
			If(FNI->(MsSeek(xFilial("FNI")+SN3->N3_CODIND)))

				cTipoInd := FNI->FNI_TIPO

			EndIf
			If(!(FNI->(MsSeek(xFilial("FNI"+cFilDest)+SN3->N3_CODIND))) .Or.FNI->FNI_TIPO != cTipoInd)

				Help( ,, "AF060FNI",, STR0078 + SN3->N3_CODIND + STR0079  , 1, 0 ) //"A ficha de ativo possui o método de depreciação por índice, e o índice "##" não existe na filial de destino, ou o tipo é diferente."
				lRet := .F.
				Exit

			EndIf
		EndIf
		SN3->(DbSkip())
	EndDo

	RestArea(aAreaSN3)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060VLLOC
Valida o Status do Local do Ativo Origem e Destino
@author Jose Augusto Ribeiro
@since 20/05/2015
@version P12
@param cFilDest, caracter, Codigo da Filial do Destino
@param cFilOrig, caracter, Codigo da Filial de Origem
@param cLocOri , caracter, Codigo de Local de Origem
@param cLocDest, caracter, Codigo de Local de Destino
@return lRet   , Logico  , Retorno .T. validado  ou .F. não validado
*/
Function AF060VLLOC(cFilDest,cFilOrig,cLocOri,cLocDest)
Local lRet     := .T.
Local aArea    := GetArea()
Local aAreaSNL := SNL->(GetArea())
Local cFilSNL  := Nil

If !Empty( cLocDest ) .And. AllTrim( cLocDest ) <> "*"
	If cFilDest == cFilOrig .Or. Empty( cFilDest ) .Or. Empty( FwxFilial( "SNL" ) )
		cFilSNL := xFilial( "SNL" )
	Else
		cFilSNL := xFilial( "SNL" , IIf( Empty( cFilDest ) , Nil , cFilDest ) )
	EndIf

	If !SNL->( MsSeek( cFilSNL + cLocDest ) )
		Help( " ", 1, "ATFBLQLOC", , STR0182, 1, 0 )		// 'Cadastro de Locais inválido!'	//-- JRJ 20170828-A
		lRet := .F.
	EndIf
EndIf

If lRet .And. cLocOri != cLocDest
	If Posicione("SNL",1,xFilial("SNL")+cLocDest,"NL_BLOQ") == '1'
		Help( " ", 1, "ATFBLQLOC", , STR0071, 1, 0 ) //"Endereços de origem e destino bloqueados. Não é possivel tranferir entre endereços bloqueados."
		lRet := .F.
	EndIf
EndIf

RestArea( aAreaSNL )
RestArea( aArea    )
Return lRet

/*{Protheus.doc} AF060VLATF
Verifica se o Bem exite na Filial de Destino
@author Jose Augusto Ribeiro
@since 20/05/2015
@version P12
@param cFilDest, caracter, Codigo da Filial de Destino
@param cCodigo , caracter,  Codigo do Bem , parametro apenas ser chamado no TUDOOK
@param cItem   , caracter, Codigo do Item do Bem , parametro apenas ser chamado no TUDOOK
@param lTudoOk , Logico  , Parametro para saber ser foi chamado no tudook ou no valid do check , passar .T. no TUDOOK
@return lRet   , Logico  , Retorno .T. validado  ou .F. não validado
@Obs Foi contemplada nesta função a AF060ValATF
*/
Static Function AF060VLATF(cFilDest,cCodigo,cItem,lTudoOk)
	Local lRet		:= .T.
	Local aArea		:= GetArea()
	Local aAreaSN1	:= SN1->(GetArea())
	Local oModel	:= FWModelActive()
	Local oModelFNR	:= oModel:GetModel("GridFNR")
	Local nCont		:= 0
	Local aItem 		:= {}

	//conta o numero de bens
	lRet := Af060FunSk(oModel)

	//Desmarca e Marca Grid FNS
	lRet := FDesFNS(oModel)

	If(!lTudoOk)
		If(oModelFNR:GetValue("OK"))

			lRet := AF060Valid(cFilDest,cCodigo,cItem,0,oModelFNR:Length(),{})

		EndIf

	Else
		For nCont := 1 to oModelFNR:Length()
			oModelFNR:GoLine(nCont)
			If(oModelFNR:GetValue("OK"))
				aAdd(aItem,{oModelFNR:GetValue("FNR_CBAORI"),oModelFNR:GetValue("FNR_ITEORI")})
				lRet := AF060Valid(cFilDest,oModelFNR:GetValue("FNR_CBAORI"),oModelFNR:GetValue("FNR_ITEORI"),nCont,oModelFNR:Length(),aItem)

			EndIf
		Next nCont
	EndIf

	RestArea(aAreaSN1)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060Valid
Função de Validação do Bem
@author Jose Augusto Ribeiro
@since 22/05/2015
@version P12
@param cFilDest, caracter, Codigo da Filial de Destino
@param cCodigo , caracter, Codigo do Bem , parametro apenas ser chamado no TUDOOK
@param cItem   , caracter, Codigo do Item do Bem , parametro apenas ser chamado no TUDOOK
@param nCont   , numerico, Numero do Contador do Loop quando for transferencia em lote
@param nLinhas , numerico, Numero de Bens a ser transferido
@param aItens  , Array   , Array com o numero de  Base e Item dos Ativos
@return lRet   , Logico  , Retorno .T. validado  ou .F. não validado
@Obs Foi contemplada nesta função a AF060ValATF
*/
Static Function AF060Valid(cFilDest,cCodigo,cItem,nCont,nLinhas,aItens)
	Local oModel	:= FWModelActive()
	Local lRet		:= .T.
	Local aArea		:= GetArea()
	Local aAreaSN1	:= SN1->(GetArea())
	Local lAF060Val	:= ExistBlock("AF060Val")
	Local nAux 		:= 0
	Local cTexto		:= ""

	SN1->(DbSetOrder(1))
	If(xFilial("SN1",cFilDest) != xFilial("SN1"))
		If(SN1->(MsSeek(xFilial("SN1",cFilDest)+cCodigo+cItem)))
			If(lAF060Val)

				lRet := ExecBlock("AF060Val",.F.,.F.)

			Else
				If(!lAtfAuto)
					If(nCont == 0 )
						If Aviso(STR0084,STR0085,{STR0086, STR0087}) == 1  //"Atencao"##"Bem ja Existente na Filial Destino. Para ser transferido temos que incrementar o item mantendo o codigo Base. Prossegue ?"##"Sim"##"Nao"

							lRet := .T. //prossegue a transferencia e incrementa o item do bem

						Else

							lRet := .F.

						EndIf
					ElseIf(nCont == nLinhas)
							For nAux := 1 To Len(aItens)
								If(nAux == 1)
									cTexto := STR0125 //"Há bens já existentes na Filial de Destino."
									cTexto += CRLF
									cTexto += STR0126 //"Deseja incrementar o item dos seguintes bens ?"
								EndIf
								cTexto += CRLF
								cTexto += aItens[nAux][1]
								cTexto += "- " + aItens[nAux][2]

							Next nAux
							If MsgYesNo(STR0084,cTexto) //"Atencao"

								lRet := .T.

							Else

								lRet := .F.
								oModel:SetErrorMessage("",,,"","AF060Valid",STR0156) //"Operação cancelada"

							EndIf
					EndIf
				Else

					lRet := .T.

				EndIf
			EndIf
		EndIf
	EndIf

	If lIsRussia
		If lRet
			If SN3->N3_OPER <> '1' // CAZARINI - 20.01.2017 - Asset Into Operation?
				Help(" ",1,"SN3NOOPER") // This asset is not in operation. Put it into operation
				lRet := .F.
			Endif
		Endif
	Endif

	RestArea(aArea)
	RestArea(aAreaSN1)

Return lRet

/*{Protheus.doc} AF060EXIFI
Verifica se Ctas/CCustos transfer. existem na filial Destino e Valida a Conta
para qual os valores estao sendo transferidos ou entidades gerencial (Centro de custo, item e classe Valor)
@author Jose Augusto Ribeiro
@since 21/05/2015
@version P12
@param cAlias   , caracter, Alias da tabela a ser posicionada
@param cEntOrig , caracter, Conta de Origem caso a de Destino estiver preenchida com '*'
@param cTabela  , caracter, Informa de qual tabela o campo pertence , pois para carregar o Modelo
@param cCamp    , caracter, Informa o campo a ser validado
@return lRet    , Logico  , Retorno .T. validado  ou .F. não validado
@Obs  Esta Função esta validando o que a função AF060Conta e AF060EXIFIL
@Obs Função tambem contempla a Validação da Função AF060CCusto
*/
Function AF060EXIFIL(cAlias,cEntOrig,cTabela,cCamp,cFilDest,nRecnoSN3)

	Local lRet			:= .T.
	Local aArea		:= GetArea()
	Local aAreaSN3	:= SN3->(GetArea())
	Local aAlias		:= IIf(!lGspInUse .And. CtbInUse(), { "CT1", "CTT" }, IIf(lGspInUse,{ "NI1", "NI3" }, { "SI1", "SI3" } ))
	Local cContAux	:= A060MExec(ReadVar())
	Local cFilAux		:= cFilAnt
	Local aAreaCT1	:= CT1->(GetArea())
	Local aAreaCTT	:= CTT->(GetArea())
	Local aAreaCTH	:= CTH->(GetArea())
	Local aAreaCTD	:= CTD->(GetArea())

	Default nRecnoSN3	:= SN3->(RECNO())
	Default cFilDest	:= M->FN9_FILDES

	lRet := A060VERIND(nRecnoSN3, cFilDest) //Verificando a taxa de Depreciação da filial destino

	cFilAnt := cFilDest

	If lRet .And. (cContAux != '*' .Or. cTabela != "FN9") .And. !Empty(cContAux)
	//------------------------------------
	//Valdida as contas contabeis destinos
	//------------------------------------
		If (cCamp $ "CONTAD|CONCOD|CONDDD|CONDAD|CONCDD")
			dbSelectArea(aAlias[1])
			(aAlias[1])->(dbSetOrder(1))
			lRet := &(aAlias[1])->(DbSeek(xFilial(aAlias[1])+cContAux))
			If(lRet .And. cAlias $ "SI1,CT1")
				lRet := Ctb105Cta(@cContAux)
			Else
				HELP(" ",1,"AF060EXIFIL",,STR0127 ,1,0) //"Não existe esta conta contabil na filial de destino"
			EndIf
		EndIf
	EndIf
	//-----------------------------------
	//Valdida os centro de custo destino
	//-----------------------------------
	If (cContAux != '*' .Or. cTabela != "FN9")	.And. !Empty(cContAux)
		If (cCamp $ "CCDESD|CCBEMD|CCCORD|CCDDD|CCDAD|CCCDD")
			dbSelectArea(aAlias[2])
			(aAlias[2])->(dbSetOrder(1))
			lRet := &(aAlias[2])->(DbSeek(xFilial(aAlias[2])+cContAux))

			If(lRet .And. cAlias $ "SI3,CTT")
				lRet := Ctb105Cc(@cContAux)
			Else
				HELP(" ",1,"AF060EXIFIL",,STR0128,1,0) //"Não existe esta centro de custo na filial de destino"
			EndIf
		EndIf
	EndIf
	//-----------------------------------
	// Valida os Itens Contabeis Destino
	//-----------------------------------
	If (cContAux != '*' .Or. cTabela != "FN9") .And. !Empty(cContAux)
		If (cCamp $ "ITBEMD|ITCORD|ITDEDD|ITDEAD|ITCDED|ITDESD")
		dbSelectArea("CTD")
			CTD->(dbSetOrder(1))
			lRet := (cAlias)->(DbSeek(xFilial(cAlias)+cContAux))

			If(lRet .And. cAlias $ "CTD")
				lRet := Ctb105Item(@cContAux)
			Else
				HELP(" ",1,"AF060EXIFIL",,STR0129,1,0) //"Não existe esta item contabil na filial de destino"
			EndIf
		EndIf
	EndIf
	//------------------------------------
	// Valida as Classes de Valor Destino
	//------------------------------------
	If (cContAux != '*' .Or. cTabela != "FN9")	.And. !Empty(cContAux)
		If (cCamp $ "CVBEMD|CVCORD|CVDEPD|CVCDED|CVDESD|CVDSPD")
		dbSelectArea("CTH")
			CTH->(dbSetOrder(1))
			lRet := (cAlias)->(DbSeek(xFilial(cAlias)+cContAux))

			If(lRet .And. cAlias $ "CTH")
				lRet := Ctb105Clvl(@cContAux)
			Else
				HELP(" ",1,"AF060EXIFIL",,STR0130,1,0) //"Não existe esta classe de valor na filial de destino"
			EndIf
		EndIf
	EndIf

	cFilAnt := cFilAux

	RestArea(aAreaCTD)
	RestArea(aAreaCTH)
	RestArea(aAreaCTT)
	RestArea(aAreaCT1)
	RestArea(aAreaSN3)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060LibCpo
Verifica se deve bloquear o campo dependendo do bem, função para ser chamada no When
@author Jose Augusto Ribeiro
@since 25/05/2015
@version P12
@param cBase, caracter, Codigo do Bem
@param cItem, caracter, Codigo do Item do Bem
@return lRet, Logico  , Retorno .T. validado  ou .F. não validado
*/
Function AF060LibCpo(cBase,cItem)
	Local lRet		:= .T.
	Local aArea		:= GetArea()
	Local aAreaSN1	:= SN1->(GetArea())

	SN1->(DbSetOrder(1))
	If(SN1->(MsSeek(xFilial("SN1")+ cBase+cItem)))
		If ATFXVerPrj(cBase,cItem)

			lRet := .F.

		EndIf

		If(lRet)
			If(SN1->N1_STATUS $ "2|3") //Bloqueio ou Bloqueio Provisorio

				lRet := .F.

			EndIf
		EndIf

		//Imobilizado nao gerado por projeto mas relacionado a projeto para execucao do mesmo
		//Exemplo: bem vindo de classificacao de compras ou por inclusao manual de bem
		If(lRet .and. !Empty(SN1->N1_PROJETO) .and. Empty(SN1->N1_PROJREV))
			lRet := .F.
		EndIf
	EndIf

	RestArea(aAreaSN1)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} Af060FunSk
Função para contar numeros de bens na transferencia em lote.
transferencia de ativos
@author Mayara Alves
@since 22/05/2015
@version P12
*/
Static Function Af060FunSk(oModel)
	Local aSaveLines	:= FWSaveRows()
	Local oModelFNR		:= oModel:GetModel('GridFNR')
	Local oModelFN9		:= oModel:GetModel('FieldFN9')
	Local nLinha		:= 0

	If oModelFNR:GetValue("OK")
		nLinha := FWFLDGET("TOTBEM")
		nLinha++
		oModelFN9:LoadValue("TOTBEM",nLinha)
	Else
		nLinha := FWFLDGET("TOTBEM")
		nLinha--
		oModelFN9:LoadValue("TOTBEM",nLinha)
	EndIf

	FWRestRows(aSaveLines)

Return(.T.)

/*{Protheus.doc} FDesFNS
Desmaca grid FNS
transferencia de ativos
@param oModel
@author Mayara Alves
@since 22/05/2015
@version P12
*/
Static Function FDesFNS(oModel)
	Local oModelFNR		:= oModel:GetModel('GridFNR')
	Local oModelFNS		:= oModel:GetModel('GridFNS')
	Local aSaveLines	:= FWSaveRows()
	Local oView			:= FWViewActive()
	Local nX			:= 0
	Local nZ			:= 0

	For nZ := 1 to oModelFNR:Length()
		oModelFNR:GoLine(nZ)
		If oModelFNR:GetValue("FNR_FILDES") <> oModelFNR:GetValue("FNR_FILORI")
			For nX := 1 to oModelFNS:Length()
				oModelFNS:GoLine(nX)
				oModelFNS:LoadValue("OK",oModelFNR:GetValue("OK"))
			Next nX
		Endif
	Next nZ

	FWRestRows(aSaveLines)

	oModelFNS:GoLine(1)

	If !IsBlind() .And. oView != Nil
		oView:Refresh('View_FNS')
	EndIf

Return(.T.)

/*{Protheus.doc} VldMarkFNS
Valid check da FNS, não permite se o check do grid da FNS não estiver ativo.
transferencia de ativos
@param oModel
@author Mayara Alves
@since 22/05/2015
@version P12
*/
Static Function VldMarkFNS(oModel)
	Local lRet			:= .T.
	Local oModelFNR		:= oModel:GetModel('GridFNR')
	Local oModelFNS		:= oModel:GetModel('GridFNS')
	Local aSaveLines	:= FWSaveRows()
	//Local lCheck		:= oModelCli:GetValue("FJY_OK")

	If oModelFNR:SeekLine( { {"FNR_CODREL", oModelFNS:GetValue("FNS_CODREL") } } )

		If !oModelFNR:GetValue("OK")
			lRet := .F.
			oModel:SetErrorMessage("",,oModel:GetId(),"","VLDMARKFNS",STR0131) //"Ativo não selecionado, verifique." ## "O processo de baixa foi interrompido, pois não foi possível criar a nota fiscal de venda."
		EndIf
		If(oModelFNR:GetValue("FNR_FILDES") <> oModelFNR:GetValue("FNR_FILORI"))

				HELP(" ",1,"AF060VLATF",,STR0132,1,0) //"Em transferencia de filal , todos os tipos do bem são obrigatoriamente levado"
				lRet := .F.

		EndIf
	EndIf

	FWRestRows(aSaveLines)

Return lRet

/*{Protheus.doc} AF060F3DES
Função chamada da consulta especifica A060F3, para subistituir a função
AF060codigo do antidgo ATFA060.
Troca o cFilant antes de abrir a consulta padrão dos campos de destino.
@author Mayara Alves
@since 26/05/2015
@version P12
@return lRet
*/
Function AF060F3DES()
	Local aArea		:= GetArea()
	Local _cFilOri	:= cFilAnt
	Local _cFilDest	:= ""
	Local lRet		:= .T.
	Local _cAlias	:= ""
	Local cTabCpo	:= SubStr(ReadVar(),4,3)
	Local cCampo	:= AllTrim(SubStr(ReadVar(),7))
	Local oModel	:= FwModelActive()
	Local oModelFNR	:= oModel:GetModel('GridFNR')
	Local cRetF3	:= ""

	If cTabCpo == "FN9" .And. !Empty(FWFLDGET('FN9_FILDES'))
		_cFilDest := FWFLDGET('FN9_FILDES')
	ElseIf  cTabCpo $ "FNR|FNS" .And. !Empty(oModelFNR:GetValue('FNR_FILDES'))
		_cFilDest := oModelFNR:GetValue('FNR_FILDES')
	Else
		lRet := .F.
		HELP(" ",1,"AF060FILDEST",,STR0133 ,1,0) //"Preencha a filial de destino"

	EndIf

	If lRet
		//ATENCAO! alteracao do valor da variavel publica cFilAnt
		If _cFilDest != cFilAnt
			cFilAnt := _cFilDest
		EndIf

		Do Case
			//
			Case cCampo $ "_GRPDES" //Grupo - FN9 e FNR
				_cAlias	:= "SNG"
				cRetF3	:= "SNG->NG_GRUPO"

			Case cCampo $ "_LOCDES" //Local - FN9 e FNR
				_cAlias	:= "SNL"
				cRetF3	:= "SNL->NL_CODIGO"

			Case cCampo $ "_TESENT" //TES Entrada FN9 e FNR
				_cAlias	:= "SF4"
				cRetF3	:= "SF4->F4_CODIGO"

			Case cCampo $ "_TXPADD" //Taxa padrao na filial destino FN9 e FNR
				_cAlias	:= "SNH"
				cRetF3	:= "SNH->NH_CODIGO"

			Case cCampo $ "_CONTAD|_CONCOD|_CONDDD|_CONDAD|_CONCDD" //CONTA FN9 e FNS
				_cAlias := "CT1"
				cRetF3	:= "CT1->CT1_CONTA"

			Case cCampo $ "_CCDESD|_CCBEMD|_CCCORD|_CCDDD|_CCDAD|_CCCDD" //Centro de Custo FN9 e FNS
				_cAlias	:= "CTT"
				cRetF3	:= "CTT->CTT_CUSTO"

			Case cCampo $ "_ITBEMD|_ITCORD|_ITDEDD|_ITDEAD|_ITCDED|_ITDESD" //Item Contabeil FN9 e FNS
				_cAlias	:= "CTD"
				cRetF3	:= "CTD->CTD_ITEM"

			Case cCampo $ "_CVBEMD|_CVCORD|_CVDEPD|_CVCDED|_CVDESD|_CVDSPD" //CLASSE DE VALOR - FN9 e FNS
				_cAlias	:= "CTH"
				cRetF3	:= "CTH->CTH_CLVL"
			Case cCampo $ "_ARMAZE" //CLASSE DE VALOR - FN9 e FNS
				_cAlias	:= "NNR"
				cRetF3	:= "NNR->NNR_CODIGO"
			OtherWise
				Help( " ", 1, "ATFBLQLOC", , STR0182, 1, 0 )		// 'Cadastro de Locais inválido!'	//-- JRJ 20170828-A

		EndCase

		If Conpad1( , , , _cAlias )
			VAR_IXB := &(cRetF3)
		Else
			lRet := .F.
		EndIf

		//ATENCAO! retorno do valor da variavel publica cFilAnt
		If cFilAnt	!= _cFilOri
			cFilAnt	:= _cFilOri
		EndIf

	EndIf

	RestArea( aArea )

Return lRet

/*{Protheus.doc} Af060Grupo
Preenche as entidades contabeis de acordo com o grupo
@author Mayara Alves
@since 27/05/2015
@param cGrupo - codigo de grupo
@version P12
@return lRet
*/
Static Function Af060Grupo( cGrupo As Character, cTabela As Character) As Logical

Local lRet			As Logical
Local lAltera		As Logical
Local oModel		As Object
Local oModelFNR		As Object
Local oModelFNS		As Object
Local aArea			As Array
Local aAreaSN1		As Array
Local aAreaSNG		As Array
Local cFilDest		As Character
Local aSaveLines	As Array
Local nCont			As Numeric
Local oView			As Object
Local lExstCad		As Logical

Local aTipoFNG		As Array
Local nPos			As Numeric
Local cTipoFNS		As Character
Local lCmpDesp 		As Logical
Local lSCDP			As Logical
Local lCVDP			As Logical
Local nContEnt 		As Numeric
Local lCusto		As Logical 
Local lItem			As Logical
Local lCLVL			As Logical

Default cTabela := SUBSTR(ReadVar(),4 ,3 )

lRet			:= .T.
lAltera			:= .T.
oModel			:= FwModelActive()
oModelFNR		:= oModel:GetModel('GridFNR')
oModelFNS		:= oModel:GetModel('GridFNS')
aArea			:= GetArea()
aAreaSN1		:= SN1->(GetArea())
aAreaSNG		:= SNG->(GetArea())
cFilDest		:= ""
aSaveLines		:= FWSaveRows()
nCont			:= 0
oView			:= FWViewActive()
lExstCad		:= .F.

aTipoFNG		:= {}
nPos			:= 0
cTipoFNS		:= ""
lCmpDesp 		:= FNS->(FieldPos("FNS_ITDESD")) > 0 // campo item despesa e classe de valor despesa no mesmo pacote 012450
lSCDP			:= SuperGetMV("MV_ATFSCDP",.F.,.F.)
lCVDP			:= SuperGetMV("MV_ATFCVDP",.F.,.F.)
lCusto			:= CtbMovSaldo("CTT")
lItem			:= CtbMovSaldo("CTD")
lCLVL			:= CtbMovSaldo("CTH")

nContEnt := 0

If "FN9" $ cTabela
	cFilDest	:= FWFLDGET('FN9_FILDES')
ElseIf("FNR" $ cTabela)
	cFilDest 	:= oModelFNR:GetValue('FNR_FILDES')
EndIf

dbSelectArea("SN1")
SN1->(dbSetOrder(1))
SN1->(dbSeek(xFilial("SN1")+SN3->N3_CBASE+SN3->N3_ITEM))

If lPeAF060GRP
	ExecBlock("AF060GRP",.F.,.F.,{SN1->N1_GRUPO,cGrupo})
EndIf

lExstCad := SNG->( MsSeek( xFilial( "SNG" , cFilDest ) + cGrupo ) )

If !Empty(cGrupo)

	If lAltera
		If SNG->(MsSeek(xFilial("SNG",cFilDest)+cGrupo))

			If FWIsInCallStack('ATFA126') .or. FWIsInCallStack('WFSTAPROV')

				Iif(Empty(oModelFNR:GetValue("FNR_TXPADD")), oModelFNR:SetValue("FNR_TXPADD", SNG->NG_TAXAPAD ), Nil) // Taxa Regulamentada (SNH)

				For nCont := 1 to oModelFNS:Length()

					oModelFNS:GoLine(nCont)

					If( Empty(oModelFNS:GetValue("FNS_CONCOD")), oModelFNS:SetValue("FNS_CONCOD", SNG->NG_CCORREC ), Nil) // Conta Correc
					If( Empty(oModelFNS:GetValue("FNS_CONTAD")), oModelFNS:SetValue("FNS_CONTAD", SNG->NG_CCONTAB ), Nil) // Conta Des
					If( Empty(oModelFNS:GetValue("FNS_CONDDD")), oModelFNS:SetValue("FNS_CONDDD", SNG->NG_CDEPREC ), Nil) // Cta Desp Dep
					If( Empty(oModelFNS:GetValue("FNS_CONDAD")), oModelFNS:SetValue("FNS_CONDAD", SNG->NG_CCDEPR  ), Nil) // Cta Dep Acum
					If( Empty(oModelFNS:GetValue("FNS_CONCDD")), oModelFNS:SetValue("FNS_CONCDD", SNG->NG_CDESP   ), Nil) // Cta Cor Depr

					If lCusto
						If( Empty(oModelFNS:GetValue("FNS_CCDESD")), oModelFNS:SetValue("FNS_CCDESD", SNG->NG_CCUSTO ), Nil) // CC Despesa Depreciação
						If( Empty(oModelFNS:GetValue("FNS_CCBEMD")), oModelFNS:SetValue("FNS_CCBEMD", SNG->NG_CUSTBEM), Nil) // CC do Bem Origem
						If( Empty(oModelFNS:GetValue("FNS_CCCORD")), oModelFNS:SetValue("FNS_CCCORD", SNG->NG_CCCORR ), Nil) // CC Correcao monetaria
						If( Empty(oModelFNS:GetValue("FNS_CCDDD" )), oModelFNS:SetValue("FNS_CCDDD" , SNG->NG_CCDESP ), Nil) // CC Desp Depreciacao
						If( Empty(oModelFNS:GetValue("FNS_CCDAD" )), oModelFNS:SetValue("FNS_CCDAD" , SNG->NG_CCCDEP ), Nil) // CC da Depr Acumulada
						If( Empty(oModelFNS:GetValue("FNS_CCCDD" )), oModelFNS:SetValue("FNS_CCCDD" , SNG->NG_CCCDES ), Nil) // CC Cor Depreciacao
					EndIf
					If lItem
						If( Empty(oModelFNS:GetValue("FNS_ITBEMD")), oModelFNS:SetValue("FNS_ITBEMD", SNG->NG_SUBCCON), Nil) // Item do Bem
						If( Empty(oModelFNS:GetValue("FNS_ITCORD")), oModelFNS:SetValue("FNS_ITCORD", SNG->NG_SUBCCOR), Nil) // Item Correcao Monet.
						If( Empty(oModelFNS:GetValue("FNS_ITDEDD")), oModelFNS:SetValue("FNS_ITDEDD", SNG->NG_SUBCDEP), Nil) // Item Desp. Depreciacao
						If( Empty(oModelFNS:GetValue("FNS_ITDEAD")), oModelFNS:SetValue("FNS_ITDEAD", SNG->NG_SUBCCDE), Nil) // Item Depre Acumulada
						If( Empty(oModelFNS:GetValue("FNS_ITCDED")), oModelFNS:SetValue("FNS_ITCDED", SNG->NG_SUBCDES), Nil) // Item da corr. Depreciacao
					EndIf
					If lCLVL
						If( Empty(oModelFNS:GetValue("FNS_CVBEMD")), oModelFNS:SetValue("FNS_CVBEMD", SNG->NG_CLVLCON), Nil) // Classe de Valor bem
						If( Empty(oModelFNS:GetValue("FNS_CVCORD")), oModelFNS:SetValue("FNS_CVCORD", SNG->NG_CLVLCOR), Nil) // Cl Vlr da corr. Monetaria
						If( Empty(oModelFNS:GetValue("FNS_CVDEPD")), oModelFNS:SetValue("FNS_CVDEPD", SNG->NG_CLVLDEP), Nil) // Cl Vl desp de depreciacao
						If( Empty(oModelFNS:GetValue("FNS_CVCDED")), oModelFNS:SetValue("FNS_CVCDED", SNG->NG_CLVLCDE), Nil) // Cl Vl deprec. acumulada O
						If( Empty(oModelFNS:GetValue("FNS_CVDESD")), oModelFNS:SetValue("FNS_CVDESD", SNG->NG_CLVLDES), Nil) // Cl Vl corr da depreciacao
					EndIf				
				Next nCont

				oModelFNS:GoLine(1)

			Else


				If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_TAXAPAD), oModelFNR:SetValue("FNR_TXPADD", SNG->NG_TAXAPAD ), Nil) // Taxa Regulamentada (SNH)

					// Carregar todos os TIPOS que contém no cadastro do GRUPO DESTINO
					dbSelectArea("FNG")  // tabela do grupo destino
					dbSetOrder(1)
					If dbSeek(SNG->NG_FILIAL + SNG->NG_GRUPO)
						While !Eof()  .And. FNG->FNG_FILIAL == SNG->NG_FILIAL .And. FNG->FNG_GRUPO == SNG->NG_GRUPO
							Aadd(aTipoFNG, FNG->FNG_TIPO )
							dbSkip()
						ENDDO
					ENDIF

				If len(__aCTBEnt) > 0 .AND. __lEntAdd .And. _lShowMsg
					If IsBlind()
						_lAtEntAd := .T.
					Else
						_lAtEntAd := MSGYESNO( STR0204, STR0205 ) // texto//Deseja atualizar as Entidades Adcionais de acordo com o grupo no destino? //	titulo//Atenção
					EndIf
					_lShowMsg := .F. //Não mostra mensagem na próxima execução
				EndIF

				For nCont := 1 to oModelFNS:Length()

					oModelFNS:GoLine(nCont)

					// Verificando se no aCols do MVC - FNS, contém o tipo no aArray (aTipoFNG)
					cTipoFNS := oModelFNS:GetValue("FNS_TIPO")
 					IF !oModelFNS:IsDeleted()
						nPos	:= Ascan( aTipoFNG, {|x| Alltrim(x) ==  cTipoFNS  })
						If nPos == 0
							LOOP
						ENDIF
					ENDIF

					If( VldExec060("N3_CCORREC") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCORREC)), oModelFNS:SetValue("FNS_CONCOD", SNG->NG_CCORREC ), Nil) // Conta Correc
					If( VldExec060("N3_CCONTAB") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCONTAB)), oModelFNS:SetValue("FNS_CONTAD", SNG->NG_CCONTAB ), Nil) // Conta Des
					If( VldExec060("N3_CDEPREC") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CDEPREC)), oModelFNS:SetValue("FNS_CONDDD", SNG->NG_CDEPREC ), Nil) // Cta Desp Dep
					If( VldExec060("N3_CCDEPR") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCDEPR)) , oModelFNS:SetValue("FNS_CONDAD", SNG->NG_CCDEPR  ), Nil) // Cta Dep Acum
					If( VldExec060("N3_CDESP") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CDESP))  , oModelFNS:SetValue("FNS_CONCDD", SNG->NG_CDESP   ), Nil) // Cta Cor Depr
					If lCusto
						If( VldExec060("N3_CCUSTO") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCUSTO)) , oModelFNS:SetValue("FNS_CCDESD", SNG->NG_CCUSTO ), Nil) // CC Despesa Depreciação
						If( VldExec060("N3_CUSTBEM") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CUSTBEM)), oModelFNS:SetValue("FNS_CCBEMD", SNG->NG_CUSTBEM), Nil) // CC do Bem Origem
						If( VldExec060("N3_CCCORR") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCCORR)) , oModelFNS:SetValue("FNS_CCCORD", SNG->NG_CCCORR ), Nil) // CC Correcao monetaria
						If( VldExec060("N3_CCDESP") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCDESP)) , oModelFNS:SetValue("FNS_CCDDD" , SNG->NG_CCDESP ), Nil) // CC Desp Depreciacao
						If( VldExec060("N3_CCCDEP") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCCDEP)) , oModelFNS:SetValue("FNS_CCDAD" , SNG->NG_CCCDEP ), Nil) // CC da Depr Acumulada
						If( VldExec060("N3_CCCDES") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCCDES)) , oModelFNS:SetValue("FNS_CCCDD" , SNG->NG_CCCDES ), Nil) // CC Cor Depreciacao
					EndIf
					If lItem
						If( VldExec060("N3_SUBCCON") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCCON)), oModelFNS:SetValue("FNS_ITBEMD", SNG->NG_SUBCCON), Nil) // Item do Bem
						If( VldExec060("N3_SUBCCOR") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCCOR)), oModelFNS:SetValue("FNS_ITCORD", SNG->NG_SUBCCOR), Nil) // Item Correcao Monet.
						If( VldExec060("N3_SUBCDEP") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCDEP)), oModelFNS:SetValue("FNS_ITDEDD", SNG->NG_SUBCDEP), Nil) // Item Desp. Depreciacao
						If( VldExec060("N3_SUBCCDE") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCCDE)), oModelFNS:SetValue("FNS_ITDEAD", SNG->NG_SUBCCDE), Nil) // Item Depre Acumulada
						If( VldExec060("N3_SUBCDES") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCDES)), oModelFNS:SetValue("FNS_ITCDED", SNG->NG_SUBCDES), Nil) // Item da corr. Depreciacao
					EndIf
					If lCLVL	
						If( VldExec060("N3_CLVLDEP") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVLDEP)), oModelFNS:SetValue("FNS_CVDEPD", SNG->NG_CLVLDEP), Nil) // Cl Vl desp de depreciacao
					EndIf
					If lCmpDesp
						//campos despesa para item e classe de valor 
						If lItem
							If( VldExec060("N3_SUBCTA") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCTA)) , oModelFNS:SetValue("FNS_ITDESD", SNG->NG_SUBCTA), Nil) // Item Despesa
							If lSCDP
								If( VldExec060("N3_SUBCTA") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCTA)), oModelFNS:SetValue("FNS_ITDEDD", SNG->NG_SUBCTA), Nil) // Item Desp. Depreciacao
							EndIf 
						EndIf
						If lCLVL
							If( VldExec060("N3_CLVL") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVL))   , oModelFNS:SetValue("FNS_CVDSPD", SNG->NG_CLVL)   , Nil) // Cl Vl Despesa
							If lCVDP
								If( VldExec060("N3_CLVL") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVL)), oModelFNS:SetValue("FNS_CVDEPD", SNG->NG_CLVL), Nil) // Cl Vl desp de depreciacao
							EndIf
						EndIf
					EndIf
					If lCLVL
						If( VldExec060("N3_CLVLCON") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVLCON)), oModelFNS:SetValue("FNS_CVBEMD", SNG->NG_CLVLCON), Nil) // Classe de Valor bem
						If( VldExec060("N3_CLVLCOR") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVLCOR)), oModelFNS:SetValue("FNS_CVCORD", SNG->NG_CLVLCOR), Nil) // Cl Vlr da corr. Monetaria
						
						If( VldExec060("N3_CLVLCDE") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVLCDE)), oModelFNS:SetValue("FNS_CVCDED", SNG->NG_CLVLCDE), Nil) // Cl Vl deprec. acumulada O
						If(VldExec060("N3_CLVLDES") .AND. ( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVLDES)), oModelFNS:SetValue("FNS_CVDESD", SNG->NG_CLVLDES), Nil) // Cl Vl corr da depreciacao
					EndIf
					If _lAtEntAd
						For nContEnt := 1 to Len(__aCTBEnt)
							If( __nAtuGrp == 2 .Or. !Empty(SNG->&("NG_EC"+__aCTBEnt[nContEnt]+"DB")), oModelFNS:SetValue("FNS_EC"+__aCTBEnt[nContEnt]+"DD", SNG->&("NG_EC"+__aCTBEnt[nContEnt]+"DB")), Nil) //Atualiza Entidade Adicional Debito
							If( __nAtuGrp == 2 .Or. !Empty(SNG->&("NG_EC"+__aCTBEnt[nContEnt]+"CR")), oModelFNS:SetValue("FNS_EC"+__aCTBEnt[nContEnt]+"CD", SNG->&("NG_EC"+__aCTBEnt[nContEnt]+"CR")), Nil) //Atualiza Entidade Adicional Crédito
						Next nContEnt
					EndIF
				Next nCont

				oModelFNS:GoLine(1)
			Endif
		EndIf
	EndIf

Else
	For nCont := 1 to oModelFNS:Length()

		oModelFNS:GoLine(nCont)

		oModelFNS:SetValue("FNS_CONCOD"		, Space(len(FNS->FNS_CONCOD)))	// Conta Correc
		oModelFNS:SetValue("FNS_CONTAD"		, Space(len(FNS->FNS_CONTAD)))	// Conta Des
		oModelFNS:SetValue("FNS_CONDDD"		, Space(len(FNS->FNS_CONDDD)))	// Cta Desp Dep
		oModelFNS:SetValue("FNS_CONDAD"		, Space(len(FNS->FNS_CONDAD)))	// Cta Dep Acum
		oModelFNS:SetValue("FNS_CONCDD"		, Space(len(FNS->FNS_CONCDD)))	// Cta Cor Depr

		oModelFNS:SetValue("FNS_CCDESD"		, Space(len(FNS->FNS_CCDESD)))	// CC Despesa Depreciação
		oModelFNS:SetValue("FNS_CCBEMD"		, Space(len(FNS->FNS_CCBEMD)))	// CC do Bem Origem
		oModelFNS:SetValue("FNS_CCCORD"		, Space(len(FNS->FNS_CCCORD)))	// CC Correcao monetaria
		oModelFNS:SetValue("FNS_CCDDD"		, Space(len(FNS->FNS_CCDDD)))	// CC Desp Depreciacao
		oModelFNS:SetValue("FNS_CCDAD"		, Space(len(FNS->FNS_CCDAD)))	// CC da Depr Acumulada
		oModelFNS:SetValue("FNS_CCCDD"		, Space(len(FNS->FNS_CCCDD)))	// CC Cor Depreciacao

		oModelFNS:SetValue("FNS_ITBEMD"		, Space(len(FNS->FNS_ITBEMD)))	// Item do Bem
		oModelFNS:SetValue("FNS_ITCORD"		, Space(len(FNS->FNS_ITCORD)))	// Item Correcao Monet.
		oModelFNS:SetValue("FNS_ITDEDD"		, Space(len(FNS->FNS_ITDEDD)))	// Item Desp. Depreciacao
		oModelFNS:SetValue("FNS_ITDEAD"		, Space(len(FNS->FNS_ITDEAD)))	// Item Depre Acumulada
		oModelFNS:SetValue("FNS_ITCDED"		, Space(len(FNS->FNS_ITCDED)))	// Item da corr. Depreciacao

		oModelFNS:SetValue("FNS_CVBEMD"		, Space(len(FNS->FNS_CVBEMD)))	// Classe de Valor bem
		oModelFNS:SetValue("FNS_CVCORD"		, Space(len(FNS->FNS_CVCORD)))	// Cl Vlr da corr. Monetaria
		oModelFNS:SetValue("FNS_CVCORD"		, Space(len(FNS->FNS_CVCORD)))	// Cl Vl desp de depreciacao
		oModelFNS:SetValue("FNS_CVCDED"		, Space(len(FNS->FNS_CVCDED)))	// Cl Vl deprec. acumulada O
		oModelFNS:SetValue("FNS_CVDESD"		, Space(len(FNS->FNS_CVDESD)))	// Cl Vl corr da depreciacao
		If lCmpDesp
			oModelFNS:SetValue("FNS_ITDESD"		, Space(len(FNS->FNS_ITDESD)))	// Item Despesa
			oModelFNS:SetValue("FNS_CVDSPD"		, Space(len(FNS->FNS_CVDSPD)))	// Cl Vl Despesa
		EndIf
	Next nCont

	oModelFNS:GoLine(1)
EndIf

//------------------------------------------------------------------------------------------------
// Caso a rotina tenha sido chamada diretamente pelo preenchimento da FNR_GRPDES e não FN9_GRPDES
//------------------------------------------------------------------------------------------------
If !FWIsInCallStack("AF060TRG")
	__nAtuGrp := 2
EndIf

If !IsBlind() .And. oView != Nil
	oView:Refresh('View_FNS')
EndIf

FWRestRows( aSaveLines )
RestArea( aAreaSNG )
RestArea( aAreaSN1 )
RestArea( aArea    )
Return lRet

/*{Protheus.doc} AF060TDOK
Faz a validacao do modelo
@author Jose Augusto Ribeiro
@since 27/05/2015
@version P12
@return lRet, Logico , Retorno .T. validado  ou .F. não validado
*/
Static Function AF060TDOK(oModel)
Local lRet			:= .T.
Local lAF060TOK		:= ExistBlock("AF060TOK")
Local aArea			:= GetArea()
Local aAreaSNG		:= SNG->(GetArea())
Local aAreaSNH		:= SNH->(GetArea())
Local aAreaSN1		:= SN1->(GetArea())
Local aAreaSN3		:= SN3->(GetArea())
Local cFilBkp		:= cFilAnt
Local lAux			:= .T.
Local oModFNR		:= oModel:GetModel("GridFNR")
Local oModFNS		:= oModel:GetModel("GridFNS")
Local cFilOrig		:= ""
Local dDataTrans	:= CtoD("  /  /    ")
Local nFNR			:= 0
Local nFNS			:= 0
Local aSaveRows		:= FWSaveRows()
Local lMVTECATF		:= GetNewPar("MV_TECATF","N") == "S"
Local cFilDest   	:= oModFNR:GetValue("FNR_FILDES")
Local cTransp		:= ""
Private cMensNF		:= ""

Default lMVTECATF:= .F.

If oModFNR:HasField('FNR_TRANSP') // Código da transportadora.
	cTransp := oModFNR:GetValue('FNR_TRANSP') // Código da transportadora.
EndIf

//Validação das contas  na Filial de Origem e Destino

cFilAnt := cFilDest

//Se for transferencia compara os modelos para não deixar salvar sem alteracao
If !IsBlind()
	lRet := CompareDif(oModel)
EndIf

//Fazendo a Validação de data
If (lRet)
	lRet := AF060Data(oModFNS:GetValue("FNS_DATA"))
EndIf

//Fazendo a Validação da Moeda
If(lRet)
	lRet := AF060MOEDA(oModFNS:GetValue("FNS_DATA"),0)
EndIf

//Valida o Bem na Filial de Destino
If(lRet)
	lRet := AF060VLATF(oModFNR:GetValue("FNR_FILDES"), oModFNR:GetValue("FNR_CBADES"), oModFNR:GetValue("FNR_ITEDES"), .T.)
EndIf

cFilOrig   := oModFNR:GetValue("FNR_FILIAL")
dDataTrans := oModFNR:GetValue("FNR_DATA")

cFilAnt := cFilBkp

//Ponto de Entrada
If (lRet .AND. lAF060TOK)
	lAux := ExecBlock("AF060TOK",.F.,.F.,{oModel})
	If ValType(lAux) == "L"
		lRet := lAux
	EndIf
Endif

dbSelectArea("SNG")
SNG->(dbSetOrder(1))

If lRet

	For nFNR := 1 To oModFNR:Length(.T.)

		oModFNR:GoLine(nFNR)

		If oModFNR:GetValue("OK")

			//----------------------------------------------------------
			// Valida se o Ativo possui transferência em data posterior
			//----------------------------------------------------------
			If lRet
				lRet := AF060VldDt(oModFNR:GetValue("FNR_CBAORI"),oModFNR:GetValue("FNR_ITEORI"))
			EndIf

			If lRet .And. !Empty(oModFNR:GetValue("FNR_GRPDES"))
				SNG->(DBSetOrder(1))
				If !SNG->(MsSeek(xFilial("SNG",cFilDest)+oModFNR:GetValue("FNR_GRPDES")))
					lRet := .F.
					Help("",1,"AF060TDOK", ,STR0200,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} ) //"O grupo informado não existe na filial destino."
				EndIf
			EndIf

			//-------------------------------
			// Validacoes para geracao da NF
			//-------------------------------
			If lRet .And. oModFNR:GetValue("FNR_GERNF") == "1" .and. !FwIsInCallStack("ATFA126") .and. !FwIsInCallStack("MNTA550")
				If Empty(oModFNR:GetValue("FNR_CLSNF"))
					lRet:= .F.
					Help( "", 1, "AF060TDOK", ,STR0173,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} ) //"O campo classificacao da NF esta em branco"###'Verifique os dados no painel "Ativo", Código + Item:'

				ElseIf Empty(oModFNR:GetValue("FNR_SERIE"))
					lRet:= .F.
					Help( "", 1, "AF060TDOK", ,STR0174,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} ) //"O campo serie da NF esta em branco"###'Verifique os dados no painel "Ativo", Código + Item:'

				ElseIf oModFNR:GetValue("FNR_VALNF") == 0
					lRet:= .F.
					Help( "", 1, "AF060TDOK", ,STR0176,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} ) //"O campo valor da NF esta em branco"###'Verifique os dados no painel "Ativo", Código + Item:'
				EndIf
			EndIf

		//------------------------------------------------------
		// Verifica os dados da transportadora
		//------------------------------------------------------
			If lRet .And. oModFNR:GetValue("FNR_GERNF") == "1" .And. oModFNR:HasField('FNR_TRANSP')
				If ( Empty(cTransp) .AND. Empty(oModFNR:GetValue("FNR_TPFRET")) ) .OR. ;// Código da transportadora e Tipo de Frete.
				   ( Empty(cTransp) .AND. (oModFNR:GetValue("FNR_TPFRET") == "C" .OR. oModFNR:GetValue("FNR_TPFRET") == "R" ) )
					lRet := .F.
					oModel:SetErrorMessage("",,oModel:GetId(),"","TRANSPNF",STR0220) // "Informe a transportadora e/ou o Tipo de Frete."
				EndIf
			EndIf

			//----------------------------------------------------
			// Validacao para transferencia parcial entre filiais
			//----------------------------------------------------
			If lRet .And. oModFNR:GetValue("FNR_QTDORI") <> oModFNR:GetValue("FNR_QTDDES") .And. oModFNR:GetValue("FNR_FILORI") == oModFNR:GetValue("FNR_FILDES")
				Help("",1,"AF060TDOK",,STR0179,1,0,,,,,,{STR0180 + AllTrim(Str(nFNR)) + "."}) //"A transferência parcial só pode ser realizada entre filiais."###"Confira a filial de destino ou a quantidade para transferência. Linha: "
				lRet:= .F.
			EndIf

			//----------------------------------------------------
			// Validacao do Gestao de Servicos - Equipe Materiais
			//----------------------------------------------------
			If lRet .And. lMVTECATF
				lRet := TcAtfVldMov(oModFNR:GetValue("FNR_FILORI"),oModFNR:GetValue("FNR_CBAORI"),oModFNR:GetValue("FNR_QTDORI"))
			EndIf

			//Valida a existencia da Taxa na filial destino
			If lRet .And. !Empty(oModFNR:GetValue("FNR_TXPADD"))
				SNH->(DbSetOrder(1))
				If !SNH->(MsSeek(xFilial("SNH",cFilDest)+oModFNR:GetValue("FNR_TXPADD")))
					lRet := .F.
					Help(" ",1,"ATFNOTXR",, STR0069,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} )//"Taxa regulamentadora não cadastrada na filial destino"###'Verifique os dados no painel "Ativo", Código + Item:'
				EndIf
			EndIf

			// Nao transfere ativo com AVP
			If lRet .And. AFTemTp14(oModFNS:GetValue("FNS_TIPO"),oModFNR:GetValue("FNR_CBAORI"),oModFNR:GetValue("FNR_ITEORI"))
				lRet := .F.
				Help(" ",1,"AF060AVPX",,STR0080+AllTrim(oModFNR:GetValue("FNR_CBAORI"))+STR0081+AllTrim(oModFNR:GetValue("FNR_ITEORI"))+STR0083,1,0) //"O ativo base: "//" item: "//" possui cálculo de AVP, e não poderá ser transferido."
			EndIf

			// Avalia se o bem está pendente de classificação
			If lRet
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If !Af240JaClas()
						lRet := .F.
						Help(" ",1,"AF060CLASS")
					EndIf
				EndIf
			EndIf

			//Nao transferir bens de provisao que sejam filhos de bem de Orcamento
			If lRet
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If SN1->N1_PATRIM == 'V' .And. !(Empty(SN1->N1_BASESUP))
						lRet := .F.
						Help(" ",1,"AF060NOCPR",,STR0073+CRLF+STR0074+SN1->N1_BASESUP +"-"+SN1->N1_ITEMSUP,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))}) //'Este ativo foi gerado a partir do processo de constituição de provisão. Este tipo de ativo não poderá ser selecionado diretamente. Selecione o ativo superior (PAI) para que a tranferencia deste ocorra.'###"C.Base-Item: "###'Verifique os dados no painel "Ativo", Código + Item:'
					EndIf
				EndIf
			EndIf

			//Caso o bem pertença a um projeto, não pode ser transferido.
			If lRet .And. ATFXVerPrj(oModFNR:GetValue("FNR_CBAORI"),oModFNR:GetValue("FNR_ITEORI"), .T. )
				lRet := .F.
			EndIf

			//PRV
			//Imobilizado nao gerado por projeto mas relacionado a projeto para execucao do mesmo
			//Exemplo: bem vindo de classificacao de compras ou por inclusao manual de bem
			If lRet
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If !Empty(SN1->N1_PROVIS)
						Help(" ",1,"AF060NOPRV",,STR0077,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))}) //'Este ativo está relacionado a realização de um controle de provisão. Este tipo de ativo não poderá ser selecionado para transferência entre filiais.'###'Verifique os dados no painel "Ativo", Código + Item:'
						lRet := .F.
					EndIf
				EndIf
			EndIf

			//BPI
			//Nao marcar bens de de realizacao realacionados a projeto
			If lRet .And. oModFNR:GetValue("FNR_FILORI") != oModFNR:GetValue("FNR_FILDES")
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If !(Empty(SN1->N1_PROJETO)) .And. Empty(SN1->N1_PROJREV)
						lRet := .F.
						Help(" ",1,"AF060NOBPI",,STR0076,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))}) //'Este ativo está relacionado a realização de um projeto (baixa de provisão). Este tipo de ativo não poderá ser selecionado para transferência entre filiais.###'Verifique os dados no painel "Ativo", Código + Item:'
					Endif
				Endif
			Endif

			//Bens em controle de terceiro não podem ser transferidos
			If lRet .And. oModFNR:GetValue("FNR_FILORI") != oModFNR:GetValue("FNR_FILDES")
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If SN1->N1_TPCTRAT == "3"
						lRet := .F.
						Help(" ",1,"AfA060TERC",,STR0068,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))})//"Bens em controle de terceiro não podem ser transferidos"###'Verifique os dados no painel "Ativo", Código + Item:'
					EndIf
				EndIf
			EndIf

			//Bens bloqueados não podem ser transferidos entre filiais
			If lRet .And. oModFNR:GetValue("FNR_FILORI") != oModFNR:GetValue("FNR_FILDES")
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If(SN1->N1_STATUS $ "2|3")
						Help(" ",1,"A060BLOQ")   //Este bem esta bloqueado, nao pode ser transferido.
						lRet := .F.
					EndIf
				EndIf
			EndIf

			If lRet
				//----------------------
				// Avalia dados da FNS
				//----------------------
				For nFNS := 1 To oModFNS:Length()

					oModFNS:GoLine(nFNS)

					If oModFNS:GetValue("OK")

						//VALIDA A CONTA DO ATIVO
						If lRet .and. Empty(oModFNS:GetValue("FNS_CONTAD"))
							lRet := .F.
							Help(" ",1,"AF060TDOK",,STR0197,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))})
							Exit
						EndIf
						SN3->(DBSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
						If SN3->(MSSeek(XFilial("SN3",oModFNR:GetValue("FNR_FILORI")) + oModFNR:GetValue("FNR_CBAORI") + oModFNR:GetValue("FNR_ITEORI") + oModFNS:GetValue("FNS_TIPO") + "0" + oModFNS:GetValue("FNS_SEQ") ))
							If lRet .And. !Empty(SN3->N3_CDEPREC) .AND. Empty(oModFNS:GetValue("FNS_CONDDD"))
								lRet := .F.
								Help(" ",1,"AF060TDOK",,STR0185,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))}) //"A Conta Contábil de Despesa de Depreciação (FNS_CONDD), não pode ficar em branco no destino, pois possui informação na origem (N3_CDEPREC)."###'Verifique os dados no painel "Ativo", Código + Item:'
								Exit
							EndIf

							If lRet .And. !Empty(SN3->N3_CCDEPR) .AND. Empty(oModFNS:GetValue("FNS_CONDAD"))
								lRet := .F.
								Help(" ",1,"AF060TDOK",,STR0186,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))}) //"A Conta Contábil de de Depreciação Acumulada (FNS_CONDAD), não pode ficar em branco no destino, pois possui informação na origem (N3_CCDEPR)."###'Verifique os dados no painel "Ativo", Código + Item:'
								Exit
							EndIf

							//Valida/bloqueia contas utilizadas na SN5 somente na transferência em lote
							If lRet .AND. FwIsInCallStack("AF060Auto") .AND. !FwIsInCallStack("AF060CaTra")
								lRet := AF060VlN5(oModFNR, oModFNS, SN3->N3_TPSALDO, oModel)
								If !lRet
									Exit
								EndIf
							EndIf	
						EndIf

					EndIf
				Next nFNS
			EndIf

		EndIf

		If !lRet
			Exit
		EndIf

	Next nFNR

EndIf

FWRestRows(aSaveRows)

RestArea(aAreaSN3)
RestArea(aAreaSN1)
RestArea(aAreaSNH)
RestArea(aAreaSNG)
RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060Trans
Efetua a Validação antes do FWExecView
@author Jose Augusto Ribeiro
@since 29/05/2015
@version P12
@param lAuto - se é tranferencia automatica
@return lRet,Logico,Retorna .T. para validado e .F. para nao validado
*/
Static Function AF060Trans(lLote)

	Local cN1TipoNeg	:= Alltrim(SuperGetMv("MV_N1TPNEG",.F.,"")) // Tipos de N1_PATRIM que aceitam Valor originais negativos
	Local cN3TipoNeg	:= Alltrim(SuperGetMv("MV_N3TPNEG",.F.,"")) // Tipos de N3_TIPO que aceitam Valor originais negativos
	Local lAF060CHA		:= ExistBlock("AF060CHA")
	Local lRet			:= .T.
	Local aAreaSN3		:= SN3->(GetArea())
	Local aAreaSN1		:= SN1->(GetArea())
	Local aArea			:= GetArea()
	Local cVarParam		:= ""
	Local nX			:= 0
	Local lTransfAut	:= FwIsInCallStack("AF060Auto")			//-- JRJ 20170828-C

	// VARIAVEIS PARA CONTABILIZACAO CONTA
	Private CTABEM		:= ""
	Private DESPDEPR	:= ""
	Private DEPREACUM	:= ""
	Private CORREDEPR	:= ""
	Private CORREBEM	:= ""
	// Variaveis para contabilizacao Centro de custo, item e classe de valor
	Private Custo 		:= ""
	Private CUSTBEMCTB	:= ""
	Private CCCORRCTB	:= ""
	Private CCDESPCTB	:= ""
	Private CCCDESCTB	:= ""
	Private CCCDEPCTB	:= ""

	Private SUBCCONCTB	:= ""
	Private SUBCCORCTB	:= ""
	Private SUBCDESCTB	:= ""
	Private SUBCDEPCTB	:= ""
	Private SUBCCDECTB	:= ""
	//Variavel de Classe de Valor
	Private CLVLCONCTB	:= ""
	Private CLVLCORCTB	:= ""
	Private CLVLDESCTB	:= ""
	Private CLVLDEPCTB	:= ""
	Private CLVLCDECTB	:= ""

	//³Verifica se o controle de solicitações está ativado, se sim encerra baixa³
	If (( SuperGetMv( "MV_ATFSOLD", .F. ,"2" ) == "1" ) .And. !lTransfAut .And. Alltrim(FunName()) == "ATFA060")		//-- JRJ 20170828-C
		HELP(" ",1,"AF060SOLD",,STR0065 ,1,0)    //"Utilize a opção Solic. Baixa/Transf, parâmetro de controle de solicitações (MV_ATFSOLD) ativado."
		lRet := .F.
	EndIf

	//Tipo Depreciacao diferente 02-Mes Subsequente
	If (GetMv("MV_TIPDEPR") == "2" .And. dDatabase < (FirstDay(GetMv("MV_ULTDEPR"))))
		Help(" ",1,"AfA060ULDP",,STR0049+DTOC(SuperGetMv("MV_ULTDEPR")) ,1,0) //"A Database do sistema deve ter o mês igual ao parâmetro MV_ULTDEPR = "
		lRet := .F.
	Endif

	If lIsRussia
		If SN3->N3_OPER <> '1' // CAZARINI - 21.01.2017 - Asset Into Operation?
			Help(" ",1,"SN3NOOPER") // This asset is not in operation. Put it into operation
			lRet := .F.
		Endif
	Endif

	//³Posiciona no SN3 caso seja chamado por rotina automatica³
	If (lAtfAuto)
		SN3->(dbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
		 If Type("aAutoTrans") == 'A'
		nPosBase	:= aScan(aAutoTrans,{|x| AllTrim(x[1]) == "N3_CBASE"})
		nPosItem	:= aScan(aAutoTrans,{|x| AllTrim(x[1]) == "N3_ITEM"})
		nPosTipo	:= aScan(aAutoTrans,{|x| AllTrim(x[1]) == "N3_TIPO"})
		nPosBaixa	:= aScan(aAutoTrans,{|x| AllTrim(x[1]) == "N3_BAIXA"})
		nPosSeq		:= aScan(aAutoTrans,{|x| AllTrim(x[1]) == "N3_SEQ"})

		cBaseAut	:= IIF( nPosBase > 0 , aAutoTrans[nPosBase][2], "" )
		cItemAut	:= IIF( nPosItem > 0 , aAutoTrans[nPosItem][2], "" )
		cTipoAut	:= IIF( nPosTipo > 0 , aAutoTrans[nPosTipo][2], "" )
		cBxAut		:= IIF( nPosBaixa > 0 , aAutoTrans[nPosBaixa][2], "" )
		cSeqAut		:= IIF( nPosSeq > 0 , aAutoTrans[nPosSeq][2], "" )

		SN3->(MsSeek( xFilial("SN3") + cBaseAut + cItemAut + cTipoAut + cBxAut + cSeqAut ))
		 EndIf
	EndIf

	If(!lAtfAuto .And. lLote)
		lRet := pergunte(cPerg,.T.)
	EndIf

	If (lAtfAuto) .And. !lLote
		Pergunte("AFA060", .F.)
		lCtbInTran := CTBINTRAN(0,.F.)

		MV_PAR01 := IIF(lCtbInTran,MV_PAR01,2)
		MV_PAR02 := 2
		If(Type("aParamAuto") == "A")
			For nX := 1 to Len(aParamAuto)
				cVarParam := Alltrim(Upper(aParamAuto[nX][1]))
				If("MV_PAR" $ cVarParam)
					&(cVarParam) := aParamAuto[nX][2]
				EndIf
			Next nX
		EndIf
	ElseIf !lLote .And. lRet					//-- JRJ 20170828-B

		lRet := Pergunte("AFA060", .T.)

	EndIf

	If (!lAuto .Or. lAtfAuto)
		// Recebe codigo do ativo
		cBase := SN3->N3_CBASE
		cItem := SN3->N3_ITEM

		// Verifica existencia do Ativo
		dbSelectArea("SN1")
		dbSetOrder(1)

		If(!dbSeek(XFilial("SN1",cFilial)+cBase+cItem))
			Help(" ",1,"020ATIVO") //"Não foi localizado no  SN1  (Cadastro deAtivo Imobilizado)"
			lRet := .F.
		End

		// Verifica se ativo nao esta' baixado
		If (Val( SN3->N3_BAIXA ) # 0)
			Help(" ",1,"060BAIXADO",,STR0110,1,0) //"Não é possivel transferir um bem já baixado."
			lRet := .F.
		EndIf

		If(! SoftLock("SN3"))
			lRet := .T.
		EndIf
	EndIf

	// No caso de contas de Capital, não vai a correção monetaria
	cPatrim		:= SN1->N1_PATRIM
	nValor		:= Iif( cPatrim # "C" , SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1, SN3->N3_VORIG1+SN3->N3_AMPLIA1 )
	nQtdeSn		:= IIf(SN1->N1_QUANTD == 0, 1, SN1->N1_QUANTD)
	nQtdOrig	:= nQtdeSn
	nQuant		:= nQtdeSn
	nCustAtu	:= nValor

	If (SN3->N3_TIPO = "05" .Or. (SN1->N1_PATRIM $ cN1TipoNeg) .Or. (SN3->N3_TIPO $ cN3TipoNeg))
		nValResid:= nValor + Abs( (SN3->N3_VRDACM1 + SN3->N3_VRCDA1) )
	Else
		nValResid:= nValor - ( SN3->N3_VRDACM1 + SN3->N3_VRCDA1 )
	Endif

	If(!lAtfAuto .And. lAF060CHA .And. lRet )

		Execblock("AF060CHA",.F.,.F.)

	Endif

	//  Libera o softlock instalado acima do while.
	dbSelectArea("SN3")
	MsUnlock()
	MsUnlock()

	RestArea(aAreaSN3)
	RestArea(aAreaSN1)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} af060Commit
Função chamada para gravação da transferencia e tranferencia em lote
@author Mayara Alves
@since 03/06/2015
@version P12
@param oModel
@return lRet - Se o resgistro foi gravado
@Obs a função AF060LESN3 foi implementando nessa função, agora a
gravação da transferencia e da transferencia em lote estão sendo chamada no mesmo lugar
*/
Static Function af060Commit(oModel as Object)
Local aArea			as Array
Local aAreaSN3		as Array
Local oModelFN9		as Object
Local oModelFNR		as Object
Local oModelFNS		as Object
Local aSaveLines	as Array
Local nFNR			as Numeric
Local nFNS			as Numeric
Local lCont			as Logical
Local cIDMOVFNR		as Character
Local cIDMOV		as Character
Local cCodRel		as Character
Local cSeq			as Character
Local cCodBase		as Character
Local cCodBDes		as Character
Local cLocDes		as Character
Local cItem			as Character
Local cTpBem		as Character
Local nQtdBens		as Numeric
Local lGspInUseM	as Logical
Local dUltDepr		as Date
Local lMult			as logical
Local aAux			as Array
Local aSavRowsLine	as Array
Local nPosSN1		as Numeric
Local cNewItem		as Character
Local cFilDest		as Character
Local cLocAtivo		as Character
Local nX			as Numeric
Local cLoteAtf		as Character
Local aCentro		as Array
Local nHdlPrv		as Numeric
Local lPrim			as Logical
Local nTotal		as Numeric
Local nTaxaMedia	as Numeric
Local cLocOrig 		as Character
Local nQtdTransf	as Numeric
Local lGeraNF		as Logical
Local cSubProc		as Character
Local cIdCV8		as Character
Local cMensNF		as Character
Local cNotaFeita	as Character
Local cSerie		as Character
Local aCposFN9		as Array
Local nContCpo		as Numeric
Local lNgmntat		as Logical
Local lContabOn		as Logical
Local cFornNE		as Character
Local cLojaNE		as Character
Local cEspNE		as Character
Local cFilF9NE		as Character
Local dDataNE		as Date
Local nRecnoSm0		as Numeric

Private cArquivo	as Character
Private cFilOrig	as Character

Default oModel 		:= Nil

aArea				:= GetArea()
aAreaSN3			:= SN3->(GetArea())
oModelFN9			:= oModel:GetModel("FieldFN9")
oModelFNR			:= oModel:GetModel("GridFNR")
oModelFNS			:= oModel:GetModel("GridFNS")
aSaveLines			:= FWSaveRows()
nFNR				:= 0
nFNS				:= 0
lCont				:= .T. //Continua o processo
cIDMOVFNR			:= ""	//Id do movimento
cIDMOV				:= ""
cCodRel				:= ""	//cod de relacionamento FNR - FNS
cSeq				:= ""
cCodBase			:= ""
cCodBDes			:= ""
cLocDes				:= ""
cItem				:= ""
cTpBem				:= ""
nQtdBens			:= 0 //Quantidade de bens marcado
lGspInUseM			:= If(Type('lGspInUse')=='L', lGspInUse, .F.)
dUltDepr			:= SuperGetMV("MV_ULTDEPR",.F. ,STOD("19800101"))
lMult				:= .T.
aAux				:= {}
aSavRowsLine		:= FwSaveRows()
nPosSN1				:= 0
cNewItem			:= ""
cFilDest			:= ""
cLocAtivo			:= ""
nX					:= 0
cLoteAtf			:= LoteCont("ATF")
aCentro				:= {}
nHdlPrv				:= 0
lPrim				:= .T.
nTotal				:= 0
nTaxaMedia			:= 0
cLocOrig 			:=SN1->N1_LOCAL
nQtdTransf			:= 0
lGeraNF				:= .F.
cSubProc			:= "ATFA060NFS"
cIdCV8				:= ""
cMensNF				:= ""
cNotaFeita			:= ""
cSerie				:= ""
aCposFN9			:= oModelFN9:GetStruct():GetFields()
nContCpo			:= 0
lNgmntat			:= SuperGetMv("MV_NGMNTAT",.F.,"4") $ "1#3"
lContabOn			:= mv_par01==1
cFornNE				:= ""
cLojaNE				:= ""
cEspNE				:= ""
cFilF9NE			:= ""
dDataNE				:= StoD("")
nRecnoSm0			:= SM0->(RECNO())

// PRIVATES
cArquivo			:= ""
cFilOrig			:= cFilAnt //Augusto : Declarado como private para a Integração para o SIGAMNT

//Aqui estou criando um vetor com as filiais e as ordenandos da FNR
For nFNR := 1 To oModelFNR:Length(.T.)
	oModelFNR:GoLine(nFNR)
	If oModelFNR:Getvalue("OK") //Transferencia de dados com diferentes filiais Origem e Destino
		Aadd(aAux,{oModelFNR:GetValue("FNR_FILDES"),nFNR})
	EndIf
Next nFNR

aSort(aAux, , , { | x,y | x[1]+Str(x[2]) < y[1]+Str(y[2])} )

FWRestRows(aSavRowsLine)

// Cria as tabelas temporarias antes do controle de transação
// devido ao Oracle dar commit dentro do controle ao receber instrução de create table (FwTenporaryTable)
If FindFunction("fNgCrtTemp") .And. SuperGetMv("MV_NGMNTAT",.F., "4") $ "1#3" .And. nModulo != 19 .And. nModulo != 95
	Private oTmpTblSTZ //Tabela temporaria (STZ) - Movimentacao de Bens
	Private oTmpTblSTC //Tabela temporaria (STC) - Estrutura
	Private oTmpTblIn  //Tabela de Inconsistencias
	Private oTmpTblx   //Tabela de STC do NGESTRUTRB
	fNgCrtTemp(@oTmpTblSTZ,@oTmpTblSTC,@oTmpTblIn, @oTmpTblx)
EndIf

If SuperGetMv("MV_NGMNTAT",.F., "4") $ "1#3" .And. nModulo != 19 .And. nModulo != 95
	cN4_HORA    := SubStr(Time(),1,5)   // Esta variavel será utilizada para gravar a hora da transferencia na funçãop ATFXMOV
EndIf

BEGIN TRANSACTION

	//---------------------------------
	// Grava FN9 - ID da transferencia
	//---------------------------------
	Reclock( "FN9",.T. )
		For nContCpo := 1 To Len(aCposFN9)
			If aCposFN9[nContCpo][3] == "FN9_FILIAL"
				FN9->FN9_FILIAL := xFilial("FN9")
			ElseIf aCposFN9[nContCpo][3] == "FN9_IDMOV" .Or. aCposFN9[nContCpo][3] == "FN9_DATA"
				&("FN9->"+(aCposFN9[nContCpo][3])) := oModelFN9:Getvalue(aCposFN9[nContCpo][3])
			Else
				If Len(aFN9CpoUsr) > 0 .And. aScan(aFN9CpoUsr, aCposFN9[nContCpo][3]) > 0
					&("FN9->"+(aCposFN9[nContCpo][3])) := oModelFN9:Getvalue(aCposFN9[nContCpo][3])
				EndIf
			EndIf
		Next nContCpo
	FN9->(MsUnlock())

	//---------------------------------------------------------
	// Laço dos ativos para Transferência (Filial ou Contábil)
	//---------------------------------------------------------
	For nX:= 1 TO Len(aAux)

		oModelFNR:GoLine(aAux[nX][2])

		//Verifico se é diferentes filiais
		lMult := oModelFNR:GetValue("FNR_FILORI") != oModelFNR:GetValue("FNR_FILDES")

		//Criação do Arquivo na Origem
		If(nHdlPrv <= 0 .And. nx == 1 .And. !lMult )
			nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
		Endif

		//-------------------------------------------------------------------------------------------------------------------------------------
		// Zera a variavel pois na transferencia automatica de mais de um ativo, o N4_IDMOV do segundo ativo não segue ordem crescente, devido
		// o movimento de baixa (N4_OCORR=01 N4_MOTIVO=18), prejudicando o cancelamento da transferencia de somente um dos ativos
		//-------------------------------------------------------------------------------------------------------------------------------------
		cIDMOV := ""

		//-----------------------------------
		// Transferencia para a mesma filial
		//-----------------------------------
		If !lMult .And. oModelFNR:Getvalue("OK")
			cLocDes		:= oModelFNR:Getvalue("FNR_LOCDES")
			cCodBase	:= oModelFNR:Getvalue("FNR_CBAORI")
			cItem		:= oModelFNR:Getvalue("FNR_ITEORI")
			cLocAtivo := oModelFNR:GetValue("FNR_LOCDES")
			cFilDest	:= oModelFNR:Getvalue("FNR_FILDES")
			nQtdBens++
			DbSelectArea("SN1")
			SN1->(DbSetOrder(1))
			SN1->(DbSeek(xFilial("SN1")+cCodBase+cItem))
			cLocOrig 	:=SN1->N1_LOCAL

			If (!Empty(cLocAtivo) .Or.!Empty(SN1->N1_LOCAL)) .And. SN1->N1_LOCAL != cLocAtivo
				Reclock( "SN1",.F. )
				SN1->N1_LOCAL := cLocAtivo
				SN1->(msUnlock())
				A060BLQLOC(cLocAtivo,SN1->N1_CBASE,SN1->N1_ITEM)
			Endif

			If SN1->N1_GRUPO != oModelFNR:Getvalue("FNR_GRPDES")
				Reclock( "SN1",.F. )
				SN1->N1_GRUPO 	:= oModelFNR:Getvalue("FNR_GRPDES")
				SN1->(msUnlock())
			Endif

			If SN1->N1_TAXAPAD != oModelFNR:Getvalue("FNR_TXPADD")
				Reclock( "SN1",.F. )
					SN1->N1_TAXAPAD := oModelFNR:Getvalue("FNR_TXPADD")
				SN1->(msUnlock())
			EndIf

			//---------------------------------
			// Grava FNR - Ativos Transferidos
			//---------------------------------
			GravaFNR(oModelFNR)

			For nFNS:= 1 TO oModelFNS:Length()
				oModelFNS:GoLine(nFNS)
				If oModelFNS:Getvalue("OK")

					//-----------------------------------------
					// Grava FNS - Tipos de Saldo Transferidos
					//-----------------------------------------
					GravaFNS(oModelFNS)

					//////////////////////////////////////////////////////////////////////////////////////////////////////
					//Neste If foi adicionado por que a integração com o SIGAMNT deve ser feita apenas 1 vez por ativo. //
					//e foi adicionado no Laço da FNS para , pegar o centro de custo do bem 								  //
					//////////////////////////////////////////////////////////////////////////////////////////////////////
					If(nFNS == 1 )
						aAdd(aCentro,{oModelFNS:GetValue("FNS_CCBEMD"),oModelFNS:GetValue("FNS_CCCORD"),oModelFNS:GetValue("FNS_CCDDD"),;
							oModelFNS:GetValue("FNS_CCDAD"),oModelFNS:GetValue("FNS_CCCDD")})

						//Transfere o Bem se houver integracao, com a mesma filial
						If lNGMNTAT .And. !Empty( SN1->N1_CODBEM )

							lCont := IIf( !lAtfAuto, MNTXATF( SN1->N1_CODBEM, SN1->N1_LOCAL, { cFilDest, oModelFN9:GetValue('FN9_DATA'), aCentro[1], cN4_HORA, '' } ),;
									MNTXATF( SN1->N1_CODBEM, SN1->N1_LOCAL, { cFilDest, oModelFN9:GetValue('FN9_DATA'), aCentro[1], cN4_HORA, '' }, aFieldsMNT ) )

							If !lCont

								// A Transferencia do Bem , com o Modulo SIGAMNT foi abortada
								oModel:SetErrorMessage( '', '', '', '', 'AF060CoMMIT', STR0134, '' )
								DisarmTransaction()
								Break
								Exit

							EndIf

						EndIf
					EndIf

					cIDMOVFNR 	:= oModelFNS:Getvalue("FNS_IDMOV")		//Id do movimento
					cCodRel		:= oModelFNS:Getvalue("FNS_CODREL")	//cod de relacionamento FNR - FNS
					cSeq		:= oModelFNS:Getvalue("FNS_SEQ")
					cTpBem		:= oModelFNS:Getvalue("FNS_TIPO")

					cNewItem  :=SN1->N1_ITEM
					//Chama função de gravação
					lCont := af060Grava( oModel, @cIDMOV, cCodRel,cSeq, cLocDes,cCodBase, cItem,lMult,nFNS,nX,cNewItem,cTpBem,cIDMOVFNR, @cLoteAtf, @nHdlPrv, @cArquivo, @lPrim, @nTotal,,cLocOrig)

					If !lCont
						Exit
					EndIf
				EndIf
			Next nFNS

		//-----------------------------
		// Transferencia entre filiais
		//-----------------------------
		ElseIf oModelFNR:Getvalue("OK")

			Af060moeda(IIf(lGspInUseM,MsSomaMes(dUltDepr,-1,.T.),dUltDepr),nTaxaMedia)

			cLocDes		:= oModelFNR:Getvalue("FNR_LOCDES")
			cCodBase	:= oModelFNR:Getvalue("FNR_CBAORI")
			cCodBDes	:= oModelFNR:Getvalue("FNR_CBADES")
			cItem		:= oModelFNR:Getvalue("FNR_ITEORI")
			cNewItem	:= oModelFNR:Getvalue("FNR_ITEORI")
			cFilDest	:= oModelFNR:Getvalue("FNR_FILDES")
			cFilOrig	:= oModelFNR:Getvalue("FNR_FILORI")
			nQtdTransf	:= oModelFNR:Getvalue("FNR_QTDDES")
			lGeraNF		:= oModelFNR:GetValue("FNR_GERNF") == "1"
			cSerie		:= oModelFNR:Getvalue("FNR_SERIE")

			nQtdBens++

			//Caso o codigo + item do bem exista na filial destino incrementa o item
				While SN1->(MsSeek(xFilial("SN1",cFilDest)+cCodBDes+cNewItem)) .Or.	!(MayIUseCode(xFilial("SN1",cFilDest)+cCodBDes+cNewItem))
					FreeUsedCode(.T.)
					cNewItem := ATFXProxIt(cFilDest, cCodBDes,cNewItem)
					//Atualiza os campos da FNR
					oModelFNR:Setvalue("FNR_ITEDES",cNewItem)
				EndDo

			//------------------------
			// Geracao da Nota fiscal
			//------------------------
			If lCont .And. lGeraNF .and. !FwIsInCallStack("ATFA126") .and. !FwIsInCallStack("MNTA550")

				ProcLogIni( {},__cProcPrinc ,cSubProc,@cIdCV8 )

				//--------------------------------
				// Nota de saida na filial origem
				//--------------------------------
				If AFA060NFS(oModel)

					cNotaFeita := oModelFNR:GetValue('FNR_NOTA')

					cMensNF		+= "------------------------------------------"+CRLF
					cMensNF		+=  STR0161 + cNotaFeita	+ CRLF//"Nota de Saida Gerada: "
					cMensNF		+=  STR0162 + cSerie		+ CRLF	//"Série: "
					cMensNF		+=  STR0163 + cFilOrig	+ CRLF	//"Filial: "
					cMensNF		+=  STR0164 + cCodBase	+ CRLF	//"Bem: "
					cMensNF		+=  STR0165 + cItem		+ CRLF	//"Item: "

				Else
					lCont := .F.
				EndIf

				//-----------------------------------
				// Nota de entrada na filial destino
				//-----------------------------------
				If AFA060NFE(oModel,cNotaFeita,@cFornNE,@cLojaNE,@cEspNE,@dDataNE,@cFilF9NE)

					cMensNF	+= "------------------------------------------" + CRLF
					cMensNF	+=  STR0166 + cNotaFeita	+ CRLF	//"Nota de Entrada Gerada "
					cMensNF	+=  STR0162 + cSerie		+ CRLF	//"Série: "
					cMensNF	+=  STR0163 + cFilDest	+ CRLF	//"Filial: "
					cMensNF	+=  STR0164 + cCodBase	+ CRLF	//"Bem: "
					cMensNF	+=  STR0165 + cItem		+ CRLF	//"Item: "
					cMensNF	+= "------------------------------------------" + CRLF

				Else
					lCont := .F.
				EndIf

			EndIf

			//----------------------------------------------------
			// Validacao do Gestao de Servicos
			// Se nao tiver saldo livre para movimentar entao breca a operacao
			//----------------------------------------------------
			If lCont .And. GetNewPar("MV_TECATF","N") == "S"
				lCont := TcAtfVldMov(cFilOrig,cCodBase,nQtdTransf,cItem)
			EndIf

			//---------------------------------
			// Cria o SN1 na Filial de destino
			//---------------------------------
			If lCont
				DbSelectArea("SN1")
				SN1->(DbSetOrder(1))
				nPosSN1 := Iif(SN1->(DbSeek(xFilial("SN1")+cCodBase+cItem)),SN1->(RECNO()),0)

				SN1->(DbGoTo(nPosSN1))
				cFilOrig := oModelFNR:GetValue("FNR_FILORI")
				Aadd(aCamposAlt,{"N1_LOCAL"		,oModelFNR:Getvalue("FNR_LOCDES")})
				Aadd(aCamposAlt,{"N1_GRUPO"		,oModelFNR:Getvalue("FNR_GRPDES")})
				Aadd(aCamposAlt,{"N1_TAXAPAD"	,oModelFNR:Getvalue("FNR_TXPADD")})
				Aadd(aCamposAlt,{"N1_ITEMSUP"	,SN1->N1_ITEMSUP})
				Aadd(aCamposAlt,{"N1_ITEM"		,cNewItem})
				Aadd(aCamposAlt,{"N1_QUANTD"	,nQtdTransf})

				If lGeraNF .and. !FwIsInCallStack("MNTA550")
					Aadd(aCamposAlt,{"N1_NFISCAL",cNotaFeita})
					Aadd(aCamposAlt,{"N1_NSERIE"  ,cSerie})
					Aadd(aCamposAlt,{"N1_FORNEC" ,cFornNE})
					Aadd(aCamposAlt,{"N1_LOJA"   ,cLojaNE})
					Aadd(aCamposAlt,{"N1_NFESPEC",cEspNE})
					SF9->(dbSetOrder(2))
					If SF9->(dbSeek(cFilF9NE+DtoS(dDataNE)+cNotaFeita+cSerie+cFornNE+cLojaNE))
						Aadd(aCamposAlt,{"N1_CODCIAP",SF9->F9_CODIGO})
						//Aproveito que está posicionado e atualizo o SF9 no destino
						//Como será feito uma cópia, posso utilizar o SN1_ICMSAPR posicionado
						If SN1->N1_ICMSAPR+SF9->F9_ICMIMOB <= SF9->F9_VALICMS
							SF9->(RecLock("SF9",.F.))
								SF9->F9_ICMIMOB := SN1->N1_ICMSAPR
							SF9->(MsUnLock())
						EndIf
					EndIf
				EndIf

				AFA060COPY("SN1",nPosSN1,cFilDest,aCamposAlt)

				aCamposAlt := {}

				FreeUsedCode(.T.)
			EndIf

			If lCont
				//---------------------------------
				// Grava FNR - Ativos Transferidos
				//---------------------------------
				GravaFNR(oModelFNR)
			EndIf

			//-------------------------------------
			// Cria o SN3/SN4 na Filial de destino
			//-------------------------------------
			If lCont
				For nFNS := 1 To oModelFNS:Length()
					oModelFNS:GoLine(nFNS)
					If oModelFNS:GetValue("OK")

						//-----------------------------------------
						// Grava FNS - Tipos de Saldo Transferidos
						//-----------------------------------------
						GravaFNS(oModelFNS)


						//////////////////////////////////////////////////////////////////////////////////////////////////////
						//Neste If foi adicionado por que a integração com o SIGAMNT deve ser feita apenas 1 vez por ativo. //
						//e foi adicionado no Laço da FNS para , pegar o centro de custo do bem 								  //
						//////////////////////////////////////////////////////////////////////////////////////////////////////
						cIDMOVFNR 	:= oModelFNS:Getvalue("FNS_IDMOV")	//Id do movimento
						cCodRel		:= oModelFNS:Getvalue("FNS_CODREL")	//cod de relacionamento FNR - FNS
						cSeq		:= oModelFNS:Getvalue("FNS_SEQ")
						cTpBem		:= oModelFNS:Getvalue("FNS_TIPO")
						cFilDest	:= oModelFNR:GetValue("FNR_FILDES")
						cFilOrig	:= oModelFNR:GetValue("FNR_FILORI")
						If(nFNS == 1)

							aAdd(aCentro,{oModelFNS:Getvalue("FNS_CCBEMD"),oModelFNS:Getvalue("FNS_CCCORD"),oModelFNS:Getvalue("FNS_CCDDD"),;
								oModelFNS:Getvalue("FNS_CCDAD"),oModelFNS:Getvalue("FNS_CCCDD")})
							//Transfere o Bem se houver integracao  com o modulo SIGAMNT, com filiais diferentes
							If lNGMNTAT .And. !Empty( SN1->N1_CODBEM ) .And. nModulo != 19 .And. nModulo != 95

								lCont := IIf( !lAtfAuto, MNTXATF( SN1->N1_CODBEM, SN1->N1_LOCAL, { cFilDest, oModelFN9:GetValue('FN9_DATA'), aCentro[1], cN4_HORA, cFilOrig } ),;
									MNTXATF( SN1->N1_CODBEM, SN1->N1_LOCAL, { cFilDest, oModelFN9:GetValue('FN9_DATA'), aCentro[1], cN4_HORA, cFilOrig }, aFieldsMNT ) )

								If !lCont

									// A Transferencia do Bem , com o Modulo SIGAMNT foi abortada
									oModel:SetErrorMessage( '', '', '', '', 'AF060CoMMIT', STR0134, '' )
									Exit

								EndIf

							EndIf
						EndIf

						If (lCont)
							lCont	:= AF060Grava(oModel, @cIDMOV, cCodRel, cSeq, cLocDes, cCodBase, cItem, lMult,nFns,nX,cNewItem,cTpBem,cIDMOVFNR, @cLoteAtf, @nHdlPrv, @cArquivo, @lPrim, @nTotal,cFilDest)
						EndIF

						//AVP2
						//se tipo for bem classificado como O = orcamento
						//Transfere filhos do bem principal de Orçamento com AVP por parcela
						If SN1->N1_PATRIM == 'O' .AND. SN1->N1_TPAVP == '2'
							Af060GrvOrc(oModel, cIDMOV, cCodRel, cSeq, cLocDes, cCodBase, cItem, lMult)
							cNewItemSup := ""
						Endif

						If(!lCont)
							Exit
						EndIf
					EndIf
				Next nFNS
			EndIf

			//-----------------------------------
			// Integracao com Gestao de Servicos
			// Comita a movumentação no lado do Gestao de Serviços
			//-----------------------------------
			If lCont .And. GetNewPar("MV_TECATF","N") == "S"
				lCont := TcTransAtf(cFilOrig,cCodBase,cItem,cFilDest,nQtdTransf,lGeraNF,cNewItem)
			EndIf

		EndIf

		If lCont .And. nHdlPrv > 0 .And. nX == Len(aAux) .And. !lMult .And. lContabOn
			RodaProva(nHdlPrv,nTotal)
			cA100Incl(cArquivo,nHdlPrv,3,cLoteAtf,Iif(mv_par02==1,.T.,.F.),Iif(mv_par03==1,.T.,.F.),,,,aFlagCTB)
		EndIf

		If !lCont
			Exit
		EndIf

	Next nX

	If lCont .And. lMult
		//Função para efetuar a Contabilização entre Filiais
		AF060CTB(oModel)
	EndIf

	If lCont .And. ExistBlock ("ATF060GRV")
		ExecBlock("ATF060GRV",.F.,.F.,{oModel})
	EndIf

	//-----------------------------------------
	// Apresenta mensagem com as notas geradas
	//-----------------------------------------
	If lCont .And. !Empty(cMensNF)
		ProcLogAtu(STR0167,STR0168,cMensNF,,.T.)	//"MENSAGEM"## "Geração de Notas Fiscais"
		If !(lAtfAuto)
			ProcLogView(cFilAnt,__cProcPrinc,cSubProc,cIdCV8)
		EndIF
	EndIf

	//---------------------------------
	// Em caso de erro efetua Rollback
	//---------------------------------
	If !lCont
		DisarmTransaction()
		Break
	EndIf

END TRANSACTION

If FwIsInCallStack("AF060Auto") .AND. !FwIsInCallStack("AF060CaTra")
	AF60ClrN5()
EndIf

// Deleta as tabelas temporarias depois do controle de transação
// devido ao Oracle dar commit dentro do controle ao receber instrução de create table (FwTenporaryTable)
If FindFunction("fNgDelTemp") .And. SuperGetMv("MV_NGMNTAT",.F., "4") $ "1#3" .And. nModulo != 19 .And. nModulo != 95
	fNgDelTemp()
EndIf

// Ponto de Entrada após realizar a transação (transferencia do ativo)
If lCont .And. ExistBlock ("ATF060END")
	ExecBlock("ATF060END",.F.,.F.,{oModel})
EndIf

lFN9 := .T.

FWRestRows(aSaveLines)

RestArea(aAreaSN3)
RestArea(aArea)

SM0->(dbGoto(nRecnoSm0)) // reposicionamento da SM0 para retornar a filial logada para a tela
Return lCont

/*{Protheus.doc} af060Grava
Função de gravacao de transferencia na propria filial
@author Mayara Alves
@since 03/06/2015
@version P12
@param oModel
@param cIDMOV	 ,caracter,Id do movimento
@param cCodRel ,caracter,Codigo de relacionamento
@param cSeq	 ,caracter,Sequencia
@param cLocDest,caracter,Local de destino
@param cCodBase,caracter,Codigo base do bem
@param cItem	 ,caracter,Item do bem
@param nFNS	 ,Quantidade de Linha da FNS
@return lRet	 ,Logico  ,Se o resgistro foi gravado
@Obs	Implementando tambem a Função Af060CtbFil
*/
Static Function af060Grava( oModel As Object, cIDMOV As Character, cCodRel As Character,cSeq As Character,;
							cLocDest As Character, cCodBase As Character,cItem As Character,lMult As Logical,;
							nFNS As Numeric,nFNR As Numeric,cNewItem As Character,cTpbem As Character,cIDMOVFNR As Character,;
							cLoteAtf As Character, nHdlPrv As Numeric, cArquivo As Character, lPrim As Logical, nTotal As Numeric,cFilDest As Character,cLocOrig As Character) As Logical

Local lRet			As Logical
Local lProcura		As Logical
Local lAchou		As Logical
Local cPatrim		As Character
Local lBem			As Logical
Local lCorrecao		As Logical
Local lDepAcum		As Logical
Local lCorMDep		As Logical
Local lDespDep		As Logical
Local lLocal		As Logical
Local lTaxaPad		As Logical
Local lSCDP			As Logical
Local lCVDP			As Logical
Local oModelFNS		As Object
Local oModelFNR		As Object
Local oModelFN9 	As Object
Local nTaxaMedia	As Numeric
Local cOcorren		As Character
Local cSN3Atu		As Character
Local aRecSn2		As Array
Local nPosSN3		As Numeric
Local aCamposAlt	As Array
Local cFilOrig		As Character
Local cFilDest		As Character
Local nX			As Numeric
Local n1			As Numeric
Local DDATATRANS	As Date
Local cFilSN2		As Character
Local nY			As Numeric
Local aTiposReav	As Array
Local cTypes10		As Character
Local cTypesNM		As Character
Local aTypes10		As Array
Local nTypes10		As Numeric
Local cUltSeq		As Character
Local cTpSal		As Character
Local cSeqReav		As Character
Local nTaxaSNH		As Numeric
Local cTipoDepr		As Character
Local cTpdpbx		As Character
Local lCmpDesp 		As Logical
Local nContEnt 		As Numeric

Private lUsaMntAt	As Logical
Private cMotivo		As Character

DEFAULT cLocOrig	:= ""
DEFAULT cFilDest	:= ""

lRet		:= .T.
lProcura	:= .F.
lAchou		:= .F.
cPatrim		:= SN1->N1_PATRIM //No caso de contas de Capital, não vai a correção monetaria
lBem		:= .F.
lCorrecao	:= .F.
lDepAcum	:= .F.
lCorMDep	:= .F.
lDespDep	:= .F.
lLocal		:= .F.
lTaxaPad	:= .F.
lSCDP		:= SuperGetMV("MV_ATFSCDP",.F.,.F.)
lCVDP		:= SuperGetMV("MV_ATFCVDP",.F.,.F.)
oModelFNS	:= oModel:GetModel("GridFNS")
oModelFNR	:= oModel:GetModel("GridFNR")
oModelFN9 	:= oModel:GetModel("FieldFN9")
nTaxaMedia	:= nTaxaDepr
cOcorren	:= ""
cSN3Atu		:= ""
aRecSn2		:= {}
nPosSN3		:= 0
aCamposAlt	:= {}
cFilOrig	:= ""
cFilDest	:= ""
nX			:= 0
n1			:= 0
DDATATRANS 	:= dDatabase  //Adic. por Edu em 14/06/16
cFilSN2		:= ""
nY			:= 0
aTiposReav	:= {}
cTypes10	:= IIF(lIsRussia,AtfNValMod({1}, "*"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - main models
cTypesNM	:= IIF(lIsRussia,AtfNValMod({3,4}, "*"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - 17 and 16 models
aTypes10	:= {}
nTypes10	:= 0
cUltSeq		:= ""
cTpSal		:= ''
cSeqReav	:= ''
nTaxaSNH	:= 0
cTipoDepr	:= SuperGetMV("MV_TIPDEPR")
cTpdpbx		:= Iif(SUPERGETMV('MV_ATFDPBX')=="1", "1", "0")
lCmpDesp 	:= FNS->(FieldPos("FNS_ITDESD")) > 0 // campo item despesa e classe de valor despesa no mesmo pacote 012450

nContEnt 	:= 0

lUsaMntAt	:= .F. //Utilizada no SIGAMNT
cMotivo		:= "08" //Utilizada no SIGAMNT

DbSelectArea("SN1")
SN1->(DbSetOrder(1)) //N1_FILIAL+N1_CBASE+N1_ITEM
SN1->(DbSeek(XFilial("SN1")+cCodBase+cItem))

DbSelectArea("SN3")
SN3->(DbSetOrder(12))	//N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
SN3->(DbSeek(XFilial("SN3")+cCodBase+cItem+cTpBem+cSeq))

cTpSal		:= SN3->N3_TPSALDO
cSeqReav	:= SN3->N3_SEQREAV


If(!lMult)
	cCContab	:= oModelFNS:Getvalue("FNS_CONTAD")
	cCCorrec	:= oModelFNS:GetValue("FNS_CONCOD")
	cCDeprec	:= oModelFNS:Getvalue("FNS_CONDDD")
	cCCDepr		:= oModelFNS:Getvalue("FNS_CONTAD")
	cCDesp		:= oModelFNS:Getvalue("FNS_CONDAD")
	cCusto		:= oModelFNS:Getvalue("FNS_CCDESD")
	cLocAtivo	:= oModelFNR:Getvalue("FNR_LOCDES")
	cFilOrig	:= oModelFNR:GetValue("FNR_FILORI")
	cFilDest	:= oModelFNR:GetValue("FNR_FILDES")

	Af060VarCtb(oModel)

	nValor		:= Iif( cPatrim # "C" , SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1, SN3->N3_VORIG1+SN3->N3_AMPLIA1 )
	cCContab	:= IIF(cCContab == SN3->N3_CCONTAB, " " , cCContab)
	cCCorrec	:= IIF(cCCorrec == SN3->N3_CCORREC, " " , cCCorrec)
	cCDeprec	:= IIF(cCDeprec == SN3->N3_CDEPREC, " " , cCDeprec)
	cCDesp		:= IIF(cCDesp	== SN3->N3_CDESP  , " " , cCDesp  )
	cCCDepr		:= IIF(cCCDepr  == SN3->N3_CCDEPR , " " , cCCDepr )

	// Qdo da transf de local verifico se existem os tipos 02 ou 04. O local  gravado no SN1 e nao posso atualizar na transf desses tipos.
	// O local deve ser o mesmo para todos os tipos ( 01 02 04 )
	If !Empty(cLocAtivo)
		nPosSN3	:= SN3->(RECNO())
		nOrder	:= SN3->(IndexOrd())
		cBase	:= SN3->N3_CBASE
		cItem	:= SN3->N3_ITEM
		cTipo	:= SN3->N3_TIPO

		dbSelectArea("SN3")
		dbSetorder(1)

		//Tipos de reavaliação
		AAdd(aTiposReav,"02") // Reavaliacao
		AAdd(aTiposReav,"04") // Lei 8.200
		AAdd(aTiposReav,"41") // Reavaliação anual de bens não totalmente depreciados
		AAdd(aTiposReav,"42") // Reavaliação anual de bens totalmente depreciados
		AAdd(aTiposReav,"50") // Colombia: Depreciacao gerencial "metodo linear"
		AAdd(aTiposReav,"51") // Colombia: Depreciacao gerencial "soma dos digitos"
		AAdd(aTiposReav,"52") // Colombia: Depreciacao gerencial "reducao de saldos"
		AAdd(aTiposReav,"53") // Colombia: Depreciacao gerencial "soma dos anos"
		AAdd(aTiposReav,"54") // Colombia: Depreciacao gerencial "unidades produzidas"

		// Verifica se o bem tem filhos
		If cTipo $ ("01*10*16*17" + "*" + cTypes10 + "*" + cTypesNM)
			For nX := 1 to Len(aTiposReav)
				If SN3->( MSSeek(xFilial("SN3")+cBase+ cItem+aTiposReav[nX]) )
					lProcura := .T.
					Exit
				Endif
			Next nX
		ElseIf cTipo $ "02/04/41/42"
			lProcura := SN3->( MSSeek( xFilial("SN3")+ cBase + cItem + "01" ) ) .OR. SN3->( MSSeek( xFilial("SN3")+ cBase + cItem + "10" ) )
			If !lProcura
				aTypes10 := Separa(cTypes10, '*', .f.)
				For nTypes10 := 1 to len(aTypes10)
					lProcura := SN3->( MSSeek( xFilial("SN3")+ cBase + cItem + aTypes10[nTypes10] ) )
					If lProcura
						Exit
					Endif
				Next nTypes10
			Endif
		Else
			lProcura:= .F.
		EndIf
		If lProcura
			dbSelectArea("SN4")
			dbSetOrder(1)
			If (MsSeek(xFilial("SN4")+cBase+cItem))
				cChave := xFilial("SN4")+cBase+cItem
				While !Eof() .And. SN4->N4_FILIAL+SN4->N4_CBASE+SN4->N4_ITEM == cChave
					If SN4->N4_DATA == dDataTrans .And. SN4->N4_OCORR == "03"
						lAchou := .T.
						Exit
					Endif
					SN4->(DbSkip())
				EndDo
			Endif
		Endif

		dbSelectArea("SN3")
		dbSetorder(nOrder)
		dbGoto(nPosSN3)
	Endif
	// cOcorrencia 03 - transferência de
	//             04 - transferência para

	cOcorren := "03"
	For nX := 1 To 2

		// Verifica se ocorreu alteracao na conta do bem
		//DbSelectArea("SN3")
		lBem		:= nX == 2 .And. lBem
		lLocal		:= nX == 2 .And. lLocal
		lTaxaPad	:= nX == 2 .And. lTaxaPad
		lCorrecao	:= nX == 2 .And. lCorrecao
		lDepAcum	:= nX == 2 .And. lDepAcum
		lCorMDep	:= nX == 2 .And. lCorMDep
		lDespDep	:= nX == 2 .And. lDespDep

		If !lLocal .And. (cLocDest <> cLocOrig)
			lLocal := .T.
		ElseIf(oModelFNS:Getvalue("FNS_CCDDO") <> oModelFNS:Getvalue("FNS_CCDDD"))
			lLocal := .T.
		Endif

		If !lTaxaPad .And. (oModelFNR:GetValue("FNR_TXPADO") <> oModelFNR:GetValue("FNR_TXPADD"))
			lTaxaPad := .T.
		Endif

		If !lBem	.And. (	oModelFNS:Getvalue("FNS_CONTAO") <> oModelFNS:Getvalue("FNS_CONTAD");
					.Or.	oModelFNS:Getvalue("FNS_CCBEMO") <> oModelFNS:Getvalue("FNS_CCBEMD");
					.Or.	oModelFNS:Getvalue("FNS_ITBEMO") <> oModelFNS:Getvalue("FNS_ITBEMD");
					.Or.	oModelFNS:Getvalue("FNS_CVBEMO") <> oModelFNS:Getvalue("FNS_CVBEMD"))
			lBem := .T.
		ElseIf Len(__aCTBEnt) > 0 .AND. __lEntAdd .AND. !lBem //Tratamento para gerar SN4 das entidades adicionais.
			For nContEnt := 1 to Len(__aCTBEnt)
				If 		 oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"DO") <> oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"DD");
					.Or. oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"CO") <> oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"CD")
					lBem := .T.
				EndIf
			Next nContEnt
		Endif

		// Verifica se ocorreu alteracao na conta da correcao monetaria
		If			(oModelFNS:Getvalue("FNS_CONCOO") <> oModelFNS:Getvalue("FNS_CONCOD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CCCORO") <> oModelFNS:Getvalue("FNS_CCCORD"));
			.Or. 	(oModelFNS:Getvalue("FNS_ITCORO") <> oModelFNS:Getvalue("FNS_ITCORD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CVCORO") <> oModelFNS:Getvalue("FNS_CVCORD"))
			lCorrecao := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da depreciacao acumulada
		If			(oModelFNS:Getvalue("FNS_CONDAO")	<> oModelFNS:Getvalue("FNS_CONDAD"));
			.Or.	(oModelFNS:Getvalue("FNS_CCDAO")	<> oModelFNS:Getvalue("FNS_CCDAD"));
			.Or.	(oModelFNS:Getvalue("FNS_ITDEAO")	<> oModelFNS:Getvalue("FNS_ITDEAD"));
			.Or.	(oModelFNS:Getvalue("FNS_CVCDEO")	<> oModelFNS:Getvalue("FNS_CVCDED"))
			lDepAcum := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da corr. monet. da deprec.
		If			(oModelFNS:Getvalue("FNS_CONCDO")	<> oModelFNS:Getvalue("FNS_CONCDD"));
			.Or.	(oModelFNS:Getvalue("FNS_CCCDO")	<> oModelFNS:Getvalue("FNS_CCCDD"));
			.Or.	(oModelFNS:Getvalue("FNS_ITCDEO")	<> oModelFNS:Getvalue("FNS_ITCDED"));
			.Or.	(oModelFNS:Getvalue("FNS_CVDESO")	<> oModelFNS:Getvalue("FNS_CVDESD"))
			lCorMDep := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da Despesa Depreciacao
		If			(oModelFNS:Getvalue("FNS_CONDDO")	<> oModelFNS:Getvalue("FNS_CONDDD"));
			.Or.	(oModelFNS:Getvalue("FNS_CCDDO")	<> oModelFNS:Getvalue("FNS_CCDDD"));
			.Or.	(oModelFNS:Getvalue("FNS_ITDEDO")	<> oModelFNS:Getvalue("FNS_ITDEDD"));
			.Or.	(oModelFNS:Getvalue("FNS_CVDEPO")	<> oModelFNS:Getvalue("FNS_CVDEPD"))
			lDespDep := .T.
		Endif

		If lCmpDesp
			If	(oModelFNS:Getvalue("FNS_ITDESO")	<> oModelFNS:Getvalue("FNS_ITDESD")) .Or. (oModelFNS:Getvalue("FNS_CVDSPO")	<> oModelFNS:Getvalue("FNS_CVDSPD"))
				lDespDep := .T.
			EndIf
		EndIf

		//-----------------------------------------------------------------------------------------------------
		// ADAPTACAO PROVISORIA (A rotina precisa ser revisada para usar a FNR e FNS ao invés da SN4)
		//-----------------------------------------------------------------------------------------------------
		// Como na SN4 não há N4_TIPOCNT que registre transferencia somente do campo N3_CCUSTO será gerado o
		// N4_TIPOCNT = 3 (Despesa de Depreciacao), para que o canelamento da transferencia contábil funcione.
		// O cancelamento da transferencia já foi adequado para resgatar os dados da FNS.
		//-----------------------------------------------------------------------------------------------------
		If oModelFNS:Getvalue("FNS_CCDESO") <> oModelFNS:Getvalue("FNS_CCDESD")
			lDespDep := .T.
		EndIf

		Af060Mov(nX,cOcorren,nTaxaMedia,{lBem,lCorrecao,lDepAcum,lCorMDep,lDespDep,lLocal,lTaxaPad},@cIDMOV,, @cLoteAtf, @nHdlPrv, @cArquivo, @lPrim, @nTotal, oModel)

		If nX == 1

			If !(SN1->N1_STATUS $ "2|3")
				DbSelectArea("SN3")
				If RecLock("SN3",.F.)

					//Conta
					SN3->N3_CCONTAB	:= oModelFNS:Getvalue("FNS_CONTAD")
					SN3->N3_CCORREC	:= oModelFNS:Getvalue("FNS_CONCOD")
					SN3->N3_CDEPREC	:= oModelFNS:Getvalue("FNS_CONDDD")
					SN3->N3_CCDEPR	:= oModelFNS:Getvalue("FNS_CONDAD")
					SN3->N3_CDESP	:= oModelFNS:Getvalue("FNS_CONCDD")

					//Centro de Custo
					SN3->N3_CCUSTO	:= oModelFNS:Getvalue("FNS_CCDESD")
					SN3->N3_CUSTBEM	:= oModelFNS:Getvalue("FNS_CCBEMD")
					SN3->N3_CCCORR	:= oModelFNS:Getvalue("FNS_CCCORD")
					SN3->N3_CCDESP	:= oModelFNS:Getvalue("FNS_CCDDD")
					SN3->N3_CCCDEP	:= oModelFNS:Getvalue("FNS_CCDAD")
					SN3->N3_CCCDES	:= oModelFNS:Getvalue("FNS_CCCDD")

					//Item
					SN3->N3_SUBCCON := oModelFNS:Getvalue("FNS_ITBEMD")
					SN3->N3_SUBCDEP := oModelFNS:Getvalue("FNS_ITDEDD")
					SN3->N3_SUBCCDE := oModelFNS:Getvalue("FNS_ITDEAD")
					SN3->N3_SUBCDES := oModelFNS:Getvalue("FNS_ITCDED")
					SN3->N3_SUBCCOR := oModelFNS:Getvalue("FNS_ITCORD")

					If lSCDP
						If lCmpDesp
							SN3->N3_SUBCDEP	:= oModelFNS:Getvalue("FNS_ITDESD")
							SN3->N3_SUBCTA:= oModelFNS:Getvalue("FNS_ITDESD")
						Else
							SN3->N3_SUBCTA:= oModelFNS:Getvalue("FNS_ITDEDD")
						EndIf
					Else
						If lCmpDesp
							SN3->N3_SUBCTA:= oModelFNS:Getvalue("FNS_ITDESD")
						EndIf
					EndIf

					//Classe de Valor
					SN3->N3_CLVLCON := oModelFNS:Getvalue("FNS_CVBEMD")
					SN3->N3_CLVLDEP := oModelFNS:Getvalue("FNS_CVDEPD")
					SN3->N3_CLVLCDE := oModelFNS:Getvalue("FNS_CVCDED")
					SN3->N3_CLVLDES := oModelFNS:Getvalue("FNS_CVDESD")
					SN3->N3_CLVLCOR := oModelFNS:Getvalue("FNS_CVCORD")

					If lCVDP
						If lCmpDesp
							SN3->N3_CLVL := oModelFNS:Getvalue("FNS_CVDSPD")
							SN3->N3_CLVLDEP := oModelFNS:Getvalue("FNS_CVDSPD")
						Else
							SN3->N3_CLVL := oModelFNS:Getvalue("FNS_CVDEPD")
						EndIf
					Else
						If lCmpDesp
							SN3->N3_CLVL := oModelFNS:Getvalue("FNS_CVDSPD")
						EndIf
					EndIf

					//Entidades Adicionais
					If Len(__aCTBEnt) > 0 .AND. __lEntAdd
						For nContEnt := 1 to Len(__aCTBEnt)
							SN3->&("N3_EC"+__aCTBEnt[nContEnt]+"DB") := oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"DD")
							SN3->&("N3_EC"+__aCTBEnt[nContEnt]+"CR") := oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"CD")
						Next nContEnt
					EndIf

					//Local
					SN3->N3_LOCAL	:= oModelFNR:Getvalue("FNR_LOCDES")

					SN3->(MsUnlock())
				EndIf

				If !Empty(oModelFNR:Getvalue("FNR_TXPADD")) .And. oModelFNR:Getvalue("FNR_TXPADO") != oModelFNR:Getvalue("FNR_TXPADD")
					nTaxaSNH := GetAdvFval("SNH","NH_TAXA",xFilial("SNH")+oModelFNR:Getvalue("FNR_TXPADD"),1,SN3->N3_TXDEPR1)
					RecLock("SN3",.F.)
						AtfMultMoe("SN3","N3_TXDEPR",{|x| nTaxaSNH})
					SN3->(MSUnlock())
				EndIf

			EndIf

		EndIf
		//Ajusta parametros para a segunda passagem
		cOcorren := "04"

	Next

Else
	cCContab	:= oModelFNS:Getvalue("FNS_CONTAD")
	cCCorrec	:= oModelFNS:GetValue("FNS_CONCOD")
	cCDeprec	:= oModelFNS:Getvalue("FNS_CONDDD")
	cCCDepr		:= oModelFNS:Getvalue("FNS_CONTAD")
	cCDesp		:= oModelFNS:Getvalue("FNS_CONDAD")
	cCusto		:= oModelFNS:Getvalue("FNS_CCDESD")
	cFilDest	:= oModelFNR:GetValue("FNR_FILDES")
	cLocAtivo	:= oModelFNR:Getvalue("FNR_LOCDES")
	nQtdOri		:= oModelFNR:GetValue("FNR_QTDORI")
	nQtdDes		:= oModelFNR:GetValue("FNR_QTDDES")
	nValor		:= Iif( cPatrim # "C" , SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1, SN3->N3_VORIG1+SN3->N3_AMPLIA1 )
	cCContab	:= IIf(cCContab == SN3->N3_CCONTAB, " " , cCContab)
	cCCorrec	:= IIf(cCCorrec == SN3->N3_CCORREC, " " , cCCorrec)
	cCDeprec	:= IIf(cCDeprec == SN3->N3_CDEPREC, " " , cCDeprec)
	cCDesp		:= IIf(cCDesp	== SN3->N3_CDESP  , " " , cCDesp  )
	cCCDepr		:= IIf(cCCDepr  == SN3->N3_CCDEPR , " " , cCCDepr )
	cFilOrig	:= oModelFNR:GetValue("FNR_FILORI")
	nPosSN3		:= SN3->(RECNO())

	nOrder	:= SN3->(IndexOrd())

	If(!Empty(cLocAtivo))
		dbSelectArea("SN3")
		dbSetorder(1)
		If cTpBem $ ("01*10*16*17" + "*" + cTypes10 + "*" + cTypesNM)		//	JRJ 20170828-D
			If (SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"02")) .Or. SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"04")))
				lProcura := .T.
			Endif
		ElseIf cTpBem == "02"
			If (SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"01")) .Or. SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"04")))
				lProcura := .T.
			Endif
		ElseIf cTpBem == "04"
			If (SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"01")) .Or. SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"01")))
				lProcura := .T.
			Endif
		Endif
		If lProcura
			dbSelectArea("SN4")
			dbSetOrder(1)
			If (SN4->(dbSeek(xFilial("SN4")+cCodBase+cItem)))
				cChave     := xFilial("SN4")+cCodBase+cItem
				While SN4->(!Eof()) .And. SN4->N4_FILIAL+SN4->N4_CBASE+SN4->N4_ITEM == cChave
					If SN4->N4_DATA == dDataTrans .Or. SN4->N4_OCORR == "03"
						SN4->(DbSkip())
						cChave :=SN4->N4_FILIAL+SN4->N4_CBASE+SN4->N4_ITEM
						Loop
					Else
						lAchou := .T.
						Exit
					Endif
				EndDo
			Endif
		Endif
		dbSelectArea("SN3")
		dbSetorder(nOrder)
		dbGoto(nPosSN3)
	EndIf

	//----------------------------------------------------------------------------------------------------------------------------------------
	// Primeiro baixo o ativo na Filial de Origem para obter o N3_SEQ que sera utilizado na geracao dos N3_OCORR 03(origem) e 04(destino)
	// Caso a baixa seja parcial (quantidade) é gerado SN3 proporcionalizado (valores) que utilizo para gerar o novo bem na filial de destino
	//----------------------------------------------------------------------------------------------------------------------------------------
	If nFNS == 1
		lRet := AFA060BX(oModel)
	EndIf

	//Esta validação foi efetuada pois a sequência a ser posicionada na baixa parcial e total precisam ser diferentes.
	//Na baixa parcial utiliza o último N3_SEQ (gerado na baixa), para ser usado nos movimentos de origem e destino na SN4
	//Na baixa total utiliza o N3_SEQ posicionado
	If nQtdOri <> nQtdDes

		//------------------------------------------------------------------------------------------------------------
		// Posiciona na ultima sequencia da SN3 gerada pela baixa para criar:
		// - SN3 na filial destino
		// - SN4 - 03 na filial origem
		// - SN4 - 04 na filial destino
		// Importante considerar que a baixa pode ser:
		//  - Parcial (quantidade)
		//  - Bem com dois tipos iguais (N3_TIPO) e tipo de saldo diferentes (N3_TPSALDO)
		//  - Bem com tipo (N3_TIPO) e tipo de saldo (N3_TPSALDO) iguais e N3_SEQREAV diferente - ex. duas ampliações
		//------------------------------------------------------------------------------------------------------------
		cUltSeq := A060UltSeq(xFilial("SN3"), cCodBase, cItem, cTpBem, cTpSal, cSeqReav)
	Else
		cUltSeq	:= SN3->N3_SEQ
	Endif

	DBSelectArea("SN3")
	SN3->(DBSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
	SN3->(DBSeek(XFilial("SN3")+cCodBase+cItem+cTpBem+"1"+cUltSeq))

	cSN3Atu := SN3->(N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO)
	cOcorren := "03"
	For nX := 1 To 2
		// Verifica se ocorreu alteracao na conta do bem
		DbSelectArea("SN3")
		lBem		:= nX == 2 .And. lBem
		lLocal		:= nX == 2 .And. lLocal
		lTaxaPad	:= nX == 2 .And. lTaxaPad
		lCorrecao	:= nX == 2 .And. lCorrecao
		lDepAcum	:= nX == 2 .And. lDepAcum
		lCorMDep	:= nX == 2 .And. lCorMDep
		lDespDep	:= nX == 2 .And. lDespDep

		If !lBem 	.And. (	oModelFNS:Getvalue("FNS_CONTAO") <> oModelFNS:Getvalue("FNS_CONTAD");
					.Or. 	oModelFNS:Getvalue("FNS_CCBEMO") <> oModelFNS:Getvalue("FNS_CCBEMD");
					.Or. 	oModelFNS:Getvalue("FNS_ITBEMO") <> oModelFNS:Getvalue("FNS_ITBEMD");
					.Or. 	oModelFNS:Getvalue("FNS_CVBEMO") <> oModelFNS:Getvalue("FNS_CVBEMD"))
			lBem := .T.
		ElseIf Len(__aCTBEnt) > 0 .AND. __lEntAdd .AND. !lBem //Tratamento para gerar SN4 das entidades adicionais.
			For nContEnt := 1 to Len(__aCTBEnt)
				If 		 oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"DO") <> oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"DD");
					.Or. oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"CO") <> oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"CD")
					lBem := .T.
				EndIf
			Next nContEnt
		Endif

		// Verifica se ocorreu alteracao na conta da correcao monetaria
		If			(oModelFNS:Getvalue("FNS_CONCOO") <> oModelFNS:Getvalue("FNS_CONCOD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CCCORO") <> oModelFNS:Getvalue("FNS_CCCORD"));
			.Or. 	(oModelFNS:Getvalue("FNS_ITCORO") <> oModelFNS:Getvalue("FNS_ITCORD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CVCORO") <> oModelFNS:Getvalue("FNS_CVCORD"))
			lCorrecao := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da depreciacao acumulada
		// Depreciacao acumulada
		If			(oModelFNS:Getvalue("FNS_CONDAO") 	<> oModelFNS:Getvalue("FNS_CONDAD"));
			.Or.	(oModelFNS:Getvalue("FNS_CCDAO") 	<> oModelFNS:Getvalue("FNS_CCDAD"));
			.Or.	(oModelFNS:Getvalue("FNS_ITDEAO")	<> oModelFNS:Getvalue("FNS_ITDEAD"));
			.Or.	(oModelFNS:Getvalue("FNS_CVCDEO") 	<> oModelFNS:Getvalue("FNS_CVCDED"))
			lDepAcum := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da corr. monet. da deprec.
		If 			(oModelFNS:Getvalue("FNS_CONCDO") 	<> oModelFNS:Getvalue("FNS_CONCDD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CCCDO") 	<> oModelFNS:Getvalue("FNS_CCCDD"));
			.Or. 	(oModelFNS:Getvalue("FNS_ITCDEO") 	<> oModelFNS:Getvalue("FNS_ITCDED"));
			.Or. 	(oModelFNS:Getvalue("FNS_CVDESO") 	<> oModelFNS:Getvalue("FNS_CVDESD"))
			lCorMDep := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da Despesa Depreciacao
		If 			(oModelFNS:Getvalue("FNS_CONDDO") 	<> oModelFNS:Getvalue("FNS_CONDDD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CCDDO") 	<> oModelFNS:Getvalue("FNS_CCDDD"));
			.Or. 	(oModelFNS:Getvalue("FNS_ITDEDO") 	<> oModelFNS:Getvalue("FNS_ITDEDD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CVDEPO") 	<> oModelFNS:Getvalue("FNS_CVDEPD"))
			lDespDep := .T.
		Endif

		If lCmpDesp
			If	(oModelFNS:Getvalue("FNS_ITDESO")	<> oModelFNS:Getvalue("FNS_ITDESD")) .Or. (oModelFNS:Getvalue("FNS_CVDSPO")	<> oModelFNS:Getvalue("FNS_CVDSPD"))
				lDespDep := .T.
			EndIf
		EndIf

		If(nX == 1)
			dbSelectArea("ST9")
			dbSetOrder(1)
			If dbSeek( xFilial("ST9",cFilDest)+SN1->N1_CODBEM )
				If !Empty(cNewItem)
					RecLock("ST9", .F.)
					ST9->T9_CODIMOB := SN1->N1_CBASE+cNewItem
					MsUnlock("ST9")
				EndIf
			EndIf
			PcoIniLan("000368")
			aAdd(aCamposAlt,{"N3_ITEM"		,cNewItem})
			aAdd(aCamposAlt,{"N3_FILORIG"	,oModelFNR:Getvalue("FNR_FILORI")})
			aAdd(aCamposAlt,{"N3_TIPO"		,oModelFNS:Getvalue("FNS_TIPO")})
			aAdd(aCamposAlt,{"N3_ATVORIG"	,AllTrim(oModelFNR:GetValue("FNR_CBAORI")) + "|" + AllTrim(oModelFNR:GetValue("FNR_ITEORI"))})
			aAdd(aCamposAlt,{"N3_CBASE"		,oModelFNR:GetValue("FNR_CBAORI")})

			//---------------------- CONTA ---------------------------------
			aAdd(aCamposAlt,{"N3_CCONTAB"	,oModelFNS:Getvalue("FNS_CONTAD")})
			aAdd(aCamposAlt,{"N3_CCORREC"	,oModelFNS:Getvalue("FNS_CONCOD")})
			aAdd(aCamposAlt,{"N3_CDEPREC"	,oModelFNS:Getvalue("FNS_CONDDD")})
			aAdd(aCamposAlt,{"N3_CCDEPR"	,oModelFNS:Getvalue("FNS_CONDAD")})
			aAdd(aCamposAlt,{"N3_CDESP"		,oModelFNS:Getvalue("FNS_CONCDD")})

			//----------------------- Centro de Custo ----------------------
			aAdd(aCamposAlt,{"N3_CCUSTO"	,oModelFNS:Getvalue("FNS_CCDESD")})
			aAdd(aCamposAlt,{"N3_CUSTBEM"	,oModelFNS:Getvalue("FNS_CCBEMD")})
			aAdd(aCamposAlt,{"N3_CCCORR"	,oModelFNS:Getvalue("FNS_CCCORD")})
			aAdd(aCamposAlt,{"N3_CCDESP"	,oModelFNS:Getvalue("FNS_CCDDD")})
			aAdd(aCamposAlt,{"N3_CCCDEP"	,oModelFNS:Getvalue("FNS_CCDAD")})
			aAdd(aCamposAlt,{"N3_CCCDES"	,oModelFNS:Getvalue("FNS_CCCDD")})

			//------------------ITEM--------------------------------------
			aAdd(aCamposAlt,{"N3_SUBCCON"	,oModelFNS:Getvalue("FNS_ITBEMD")})
			aAdd(aCamposAlt,{"N3_SUBCDEP"	,oModelFNS:Getvalue("FNS_ITDEDD")})
			aAdd(aCamposAlt,{"N3_SUBCCDE"	,oModelFNS:Getvalue("FNS_ITDEAD")})
			aAdd(aCamposAlt,{"N3_SUBCDES"	,oModelFNS:Getvalue("FNS_ITCDED")})
			aAdd(aCamposAlt,{"N3_SUBCCOR"	,oModelFNS:Getvalue("FNS_ITCORD")})

			If lSCDP
				If lCmpDesp
					aAdd(aCamposAlt,{"N3_SUBCDEP"	,oModelFNS:Getvalue("FNS_ITDESD")})
					aAdd(aCamposAlt,{"N3_SUBCTA"	,oModelFNS:Getvalue("FNS_ITDESD")})
				Else
					aAdd(aCamposAlt,{"N3_SUBCTA",oModelFNS:Getvalue("FNS_ITDEDD")})
				EndIf
			Else
				If lCmpDesp
					aAdd(aCamposAlt,{"N3_SUBCTA"	,oModelFNS:Getvalue("FNS_ITDESD")})
				EndIf
			EndIf

			//---------------------- classe de valor -----------------------
			aAdd(aCamposAlt,{"N3_CLVLCON"	,oModelFNS:Getvalue("FNS_CVBEMD")})
			aAdd(aCamposAlt,{"N3_CLVLDEP"	,oModelFNS:Getvalue("FNS_CVDEPD")})
			aAdd(aCamposAlt,{"N3_CLVLCDE"	,oModelFNS:Getvalue("FNS_CVCDED")})
			aAdd(aCamposAlt,{"N3_CLVLDES"	,oModelFNS:Getvalue("FNS_CVDESD")})
			aAdd(aCamposAlt,{"N3_CLVLCOR"	,oModelFNS:Getvalue("FNS_CVCORD")})

			If lCVDP
				If lCmpDesp
					aAdd(aCamposAlt,{"N3_CLVLDEP"	,oModelFNS:Getvalue("FNS_CVDSPD")})
					aAdd(aCamposAlt,{"N3_CLVL"	,oModelFNS:Getvalue("FNS_CVDSPD")})
				Else
					aAdd(aCamposAlt,{"N3_CLVL"	,oModelFNS:Getvalue("FNS_CVDEPD")})
				EndIf
			Else
				If lCmpDesp
					aAdd(aCamposAlt,{"N3_CLVL"	,oModelFNS:Getvalue("FNS_CVDSPD")})
				EndIf
			EndIf

			//Entidades Adicionais
			If Len(__aCTBEnt) > 0 .AND. __lEntAdd
				For nContEnt := 1 to Len(__aCTBEnt)
					aAdd(aCamposAlt,{"N3_EC"+__aCTBEnt[nContEnt]+"DB", oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"DD")})
					aAdd(aCamposAlt,{"N3_EC"+__aCTBEnt[nContEnt]+"CR", oModelFNS:Getvalue("FNS_EC"+__aCTBEnt[nContEnt]+"CD")})
				Next nContEnt
			EndIf

			//--------------------------------------------------------------------------------------------------
			// Como o novo SN3 tem como base o que foi baixado, ajusta os campos para que ele esteja disponivel
			//--------------------------------------------------------------------------------------------------
			Aadd(aCamposAlt,{"N3_BAIXA"		,"0"})
			Aadd(aCamposAlt,{"N3_IDBAIXA"	,""})
			Aadd(aCamposAlt,{"N3_DTBAIXA"	,SToD("")})
			Aadd(aCamposAlt,{"N3_FILORIG"	,cFilDest}) //Necessario alterar para depois de gerado, poder baixa-lo e cancelar a baixa do bem gerado na filial de destino
			Aadd(aCamposAlt,{"N3_LOCAL"		,cLocAtivo})

            //Altera data de inicio de depreciação para a data da movimentação + 1
            If cTipoDepr == "0" .Or. cTpdpbx == "1"
				Aadd(aCamposAlt,{"N3_DINDEPR", (oModelFN9:Getvalue("FN9_DATA")+1)})
			EndIf

			If(cOcorren == "03")
				AFA060COPY("SN3", SN3->(Recno()),cFilDest, aCamposAlt)
			EndIf

			DbSelectArea("SN2")

			cFilSN2	:= xFilial("SN2")

			If(SN2->(MsSeek(cFilSN2+SN3->(N3_CBASE+N3_ITEM+N3_TIPO))))
				While SN2->(!Eof()) .And. SN2->(N2_FILIAL+N2_CBASE+N2_ITEM+N2_TIPO)==cSN3Atu
					If SN3->N3_SEQ == SN2->N2_SEQ
						Aadd(aRecSn2, SN2->(Recno()))
					EndIf
					SN2->(DbSkip())
				EndDo
			EndIf
			For nY := 1 To Len(aRecSn2)
				aAdd(aCamposAlt,{"N2_ITEM",cNewItem})
				AFA060COPY("SN2",aRecSn2[nY],cFilDest,aCamposAlt)
				aCamposAlt := {}
			Next nY
			If AFXVerRat()

				AF060Rat(SN3->N3_CODRAT, cFilOrig, cFilDest)

			EndIf
		EndIf

		//----------------------------------------------------------------------------------
		// Posiciona no ativo transferido para correta geracao dos dados na funcao AF060Mov
		//----------------------------------------------------------------------------------
		If cOcorren == "04"
			SN3->(DbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
			SN3->(DbSeek(XFilial("SN3",cFilDest)+cCodBase+cNewItem+cTpBem+"0"+cUltSeq))

			If !Empty(oModelFNR:Getvalue("FNR_TXPADD")) .And. oModelFNR:Getvalue("FNR_TXPADO") != oModelFNR:Getvalue("FNR_TXPADD")
				nTaxaSNH := GetAdvFval("SNH","NH_TAXA",xFilial("SNH")+oModelFNR:Getvalue("FNR_TXPADD"),1,SN3->N3_TXDEPR1)
				RecLock("SN3",.F.)
					AtfMultMoe("SN3","N3_TXDEPR",{|x| nTaxaSNH})
				SN3->(MSUnlock())
			EndIf
		EndIf

		Af060Mov(nX, cOcorren, nTaxaMedia,{lBem,lCorrecao,lDepAcum,lCorMDep,lDespDep,lLocal,lTaxaPad},@cIDMOV, cNewItem,nil, nil, nil, nil, nil,oModel)
		cOcorren := "04"

	Next nX

	//Restaura a posicao da SN3
	DBSelectArea("SN3")
	DBSetorder(nOrder)
	SN3->(DBGoto(nPosSN3))

EndIf

Return lRet

/*{Protheus.doc} GravaFNR
Função para incluir FNR
@author Mayara Alves
@since 03/06/2015
@version P12
@param oModelFNR - Modelo de dados da tabela FNR
*/
Static Function GravaFNR(oModelFNR)
Local aArea		:= GetArea()
Local aCposFNR	:= oModelFNR:GetStruct():GetFields()
Local nContCpo	:= 0
Local lIncReg		:= .T.

lIncReg := FNR->(DbSeek(oModelFNR:GetValue("FNR_FILIAL")+oModelFNR:GetValue("FNR_IDMOV")+oModelFNR:GetValue("FNR_CBAORI")+oModelFNR:GetValue("FNR_ITEORI")))

Reclock( "FNR",!lIncReg )
	For nContCpo := 1 To Len(aCposFNR)
		If aCposFNR[nContCpo][3] == "FNR_FILIAL"
			FNR->FNR_FILIAL := xFilial("FNR")
		ElseIf Alltrim(aCposFNR[nContCpo][3]) == "FNR_STATUS"
			FNR->FNR_STATUS := "1"
		ElseIf !Alltrim(aCposFNR[nContCpo][3]) $ ("FNR_DESCRI|OK")
			&("FNR->"+(aCposFNR[nContCpo][3])) := oModelFNR:Getvalue(aCposFNR[nContCpo][3])
		EndIf
	Next nContCpo
FNR->(MsUnlock())

RestArea(aArea)

Return

/*{Protheus.doc} GravaFNS
Função para incluir FNS
@author Mayara Alves
@since 03/06/2015
@version P12
@param oModelFNS - Modelo de dados da tabela FNS
*/
Static Function GravaFNS(oModelFNS)
Local aArea		:= GetArea()
Local aCposFNS	:= oModelFNS:GetStruct():GetFields()
Local nContCpo	:= 0

Reclock("FNS",.T.)
	For nContCpo := 1 To Len(aCposFNS)
		If aCposFNS[nContCpo][3] == "FNS_FILIAL"
			FNS->FNS_FILIAL := xFilial("FNS")
		ElseIf !Alltrim(aCposFNS[nContCpo][3]) $("FNS_HISTOR|OK")
			&("FNS->"+(aCposFNS[nContCpo][3])) := oModelFNS:Getvalue(aCposFNS[nContCpo][3])
		EndIf
	Next nContCpo
FNS->(MsUnlock())

RestArea(aArea)

Return

/*{Protheus.doc} Af060Mov
Grava movimentacao de transferencia de acordo com o tipo de mudancas efetuadas
@author Jose Augusto Ribeiro
@since 02/06/2015
@version P12
@param nX        , Numérico , Idenfifica o tipo de registro a gravar de/para
@param cOcorren  , Caracter, Codigo de ocorrencia para gravacao no SN4
@param nTaxaMedia, Numérico , Taxa media para calculo de depreciacao
@param aGrava    , Array    , Array com logicos indicando tipos de transferencias efetuadas
@param cIDMOV    , Caracter, Identificação do movimento, passar como referencia na primeira sequencia do processo e passar o ID
@param cIDMOV    , Caracter, criado nas proximas movimentações do processo
@param cNewItem  , Caracter, Codigo do novo Item do Ativo
*/
Static Function Af060Mov(nX As Numeric, cOcorren As Character, nTaxaMedia As Numeric, aGrava As Array,cIDMOV As Character,cNewItem As Character,;
						cLoteAtf As Character, nHdlPrv As Numeric, cArquivo As Character, lPrim As Logical, nTotal As Numeric,oModel As Object)

Local lAtClDepr		As Logical
Local lExclusivo	As Logical
Local lNgmntat		As Logical
Local aValorMoed	As Array
Local aValores		As Array
Local aDadosComp	As Array
Local __nQuantas	As Numeric
Local aAtuSal		As Array
Local nI			As Numeric
Local cItemPco		As Character
Local aArea			As Array
Local aEntidades	As Array
Local cPadrao		As Character
Local lAF060GSN4	As Logical
Local lFilDif		As Logical
Local cMoed			As Character
Local lBem			As Logical
Local lLocal		As Logical
Local lTaxaPad		As Logical
Local cTipoTrDe		As Character
Local cTipoTrPara	As Character
Local cAliasCTB		As Character
Local oModFNS		As Object
Local oModFNR		As Object
Local cNota			As Character
Local cSerie		As Character
Local cFilOrig		As Character
Local cFilDest		As Character
Local dDataTrans	As Date
Local cLocOrig		As Character
Local nQtdDest		As Numeric
Local lContabOn 	As Logical

Local lUsaFlag		As Logical
Local nRecnoSN4		As Numeric

Local nContEnt 		As Numeric
Local aEntAdic		As Array

Default cIDMOV		:= ""
Default cNewItem	:= "001"
Default oModel      := FwModelActive()
Default nHdlPrv		:= 0
Default cArquivo	:= ''
Default cLoteAtf	:= LoteCont("ATF")

// Verificação da classificação de Ativo se sofre depreciação
lAtClDepr		:= .F.
lExclusivo		:= ADMTabExc("SN4")	 //Analisa se a tabela esta exclusiva
lNgmntat		:= SuperGetMV("MV_NGMNTAT") $ "1#3"
// Controle de multiplas moedas
aValorMoed		:= {}
aValores		:= {}
aDadosComp		:= {}
__nQuantas		:= IIf(lMultMoed,AtfMoedas(),5)
aAtuSal			:= IIf(lMultMoed,AtfMultMoe(,,{|x| 0}), {0,0,0,0,0} )
nI				:= 0
cItemPco		:= "01"
aArea			:= GetArea()
aEntidades		:= {'','','',''}
cPadrao			:= ""
lAF060GSN4		:= ExistBlock("AF060GSN4")
lFilDif			:= .F.
cMoed			:= ""
lBem			:= .T.
lLocal			:= .T.
lTaxaPad		:= .T.
cTipoTrDe		:= ""
cTipoTrPara		:= ""
cAliasCTB		:= ""
oModFNS			:= Nil
oModFNR			:= Nil
cNota			:= ""
cSerie			:= ""
cFilOrig		:= ""
cFilDest		:= ""
dDataTrans		:= CTOD("")
cLocOrig		:= ""
nQtdDest		:= 0
lContabOn 		:= MV_PAR01==1

lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
nRecnoSN4		:= 0

nContEnt 		:= 0
aEntAdic 		:= {}

// Verificação da classificação de Ativo se sofre depreciação
lAtClDepr	:= AtClssVer(SN1->N1_PATRIM)

oModFNS			:= oModel:GetModel("GridFNS")
oModFNR			:= oModel:GetModel("GridFNR")
cNota			:= oModFNR:GetValue("FNR_NOTA")
cSerie			:= oModFNR:GetValue("FNR_SERIE")
cFilOrig		:= oModFNR:GetValue("FNR_FILORI")
cFilDest		:= oModFNR:GetValue("FNR_FILDES")
dDataTrans		:= oModFNR:GetValue("FNR_DATA")
cLocOrig		:= oModFNR:GetValue("FNR_LOCORI")
nQtdDest		:= oModFNR:GetValue("FNR_QTDDES")

// Para Filial destino bem esta baixado na filial origem e podendo ainda ter novo codigo de item
If(xFilial("SN1",cFilDest) != xFilial("SN1",cFilOrig)) .or. ( !lExclusivo .and. cFilDest != cFilOrig )
	cN3Item 	:= IiF(nX == 1 ,SN3->N3_ITEM	,cNewItem)
	cN3Baixa	:= IiF(nX == 1 ,SN3->N3_BAIXA	,"0")
Else
	cN3Item 	:= SN3->N3_ITEM
	cN3Baixa	:= SN3->N3_BAIXA
EndIf

// Transferencia Contábil grava n4_lp = '833'
If (xFilial("SN1",cFilDest) == xFilial("SN1",cFilOrig))
	cPadrao := "833"
Else
	// Transferencia Fisica DE   (ORIGEM) grava n4_lp = '831'
	// Transferencia Fisica PARA (DESTINO) grava n4_lp = '832'
	If NX == 1
		cPadrao := "831"
	Else
		cPadrao := "832"
	EndIf
EndIf

// Trata contas patrimoniais
If(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM))
	cTipoTrDe  := "8"
	cTipoTrPara:= "9"
ElseIf(SN1->N1_PATRIM $ "CAS")
	cTipoTrDe  := "G"
	cTipoTrPara:= "I"
Else
	cTipotrDe  := "H"
	cTipotrPara:= "J"
EndIf

If(xFilial("SN1",cFilDest) <> xFilial("SN1",cFilOrig)) .or. ( !lExclusivo .and. cFilDest != cFilOrig )

	lFilDif := .T.
EndIf

lBem		:= aGrava[1] .Or. lFilDif
lCorrecao	:= aGrava[2] .Or. lFilDif
lDepAcum	:= aGrava[3] .Or. lFilDif
lCorMDep	:= aGrava[4] .Or. lFilDif
lDespDep	:= aGrava[5] .and. !lFilDif // Conta de despesa de depreciação so deve ser transferida se a transferencia for contabil
lLocal		:= aGrava[6]
lTaxaPad	:= aGrava[7]

dbSelectArea("SN4")
cFilSN4	:= xFilial("SN4")
If(lFilDif .And. nX = 2)		// Mudo a filial atual para gravacao
	cFilAnt := cFilDest			// na filial de destino
	If(!Empty(cFilDest) .and. lExclusivo)
		cFilSN4	:= xFilial("SN4",cFilDest)
	EndIf
Endif

// Utilizo as variaveis de contabilizacao pois caso nao seja alterada o conteudo
// estara em branco
cTpSaldo := SN3->N3_TPSALDO
If(lNgmntat)
	If(!Empty(SN1->N1_CODBEM))
		dbSelectArea("SN1")
		dbSetOrder(1)
		If(SN1->(dbSeek(cFilSN4 + SN3->N3_CBASE + cN3Item )))
			If(lCorrecao .Or. lDespDep)
				If(!Empty(SN1->N1_CODBEM))
					DbSelectArea("TQ2")
					dbSetOrder(1)
					If(TQ2->(DbSeek(xFilial("TQ2")+SN1->N1_CODBEM+DtoS(dDataTrans))))
						cHora := TQ2->TQ2_HORATR
					EndIf
				Else
					dbSelectArea("TPN")
					dbSetOrder(1)
					If(TPN->(DbSeek(xFilial("TPN")+SN1->N1_CODBEM+DtoS(dDataTrans))))
						While(SN1->N1_CODBEM == TPN->TPN_CODBEM)
						cHora := TPN->TPN_HRINIC
						dbSelectArea("TPN")
						dbSkip()
					End While
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
EndIf

cTpSaldo := SN3->N3_TPSALDO

aDadosComp := ATFXCompl(nTaxaMedia,SN3->N3_TXDEPR1/*nTxDepre*/,/*cMotivo*/,/*cBaixa*/,cFilOrig,cSerie,cNota,/*nVenda*/,Iif(nX == 1, cLocOrig, cLocAtivo), SN3->N3_PRODMES )

If (lCorrecao .Or. lDespDep)

	aValores   := IIf(lMultMoed, AtfMultMoe(,,{|x| 0}) , {0,0,0,0,0} )
	If(lCorrecao)

		If nHdlPrv <= 0
			nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
		Endif

		aValores[1] := Round(SN3->N3_VRCACM1 , X3Decimal("N4_VLROC1") )

		If(cOcorren == "03")// Origem
			aEntidades[1] := oModFNS:GetValue("FNS_CONCOO")
			aEntidades[2] := oModFNS:GetValue("FNS_CCCORO")
			aEntidades[3] := oModFNS:GetValue("FNS_ITCORO")
			aEntidades[4] := oModFNS:GetValue("FNS_CVCORO")

		Else // Destino
			aEntidades[1] := IIf(oModFNS:GetValue("FNS_CONCOD") == "*", oModFNS:GetValue("FNS_CONCOO"), oModFNS:GetValue("FNS_CONCOD") ) /// SE DESTINO = * DESTINO=ORIGEM
			aEntidades[2] := IIf(oModFNS:GetValue("FNS_CCCORD") == "*", oModFNS:GetValue("FNS_CCCORO"), oModFNS:GetValue("FNS_CCCORD") ) /// SE DESTINO = * DESTINO=ORIGEM
			aEntidades[3] := IIf(oModFNS:GetValue("FNS_ITCORD") == "*", oModFNS:GetValue("FNS_ITCORO"), oModFNS:GetValue("FNS_ITCORD") ) /// SE DESTINO = * DESTINO=ORIGEM
			aEntidades[4] := IIf(oModFNS:GetValue("FNS_CVCORD") == "*", oModFNS:GetValue("FNS_CVCORO"), oModFNS:GetValue("FNS_CVCORD") ) /// SE DESTINO = * DESTINO=ORIGEM
		EndIf

		nRecnoSN4:= ATFXMOV(cFilSN4,@cIDMOV,dDataTrans,cOcorren,SN3->N3_CBASE,cN3Item,SN3->N3_TIPO,cN3Baixa,SN3->N3_SEQ,SN3->N3_SEQREAV,'2',nQtdDest,cTpSaldo,aEntidades,aValores,aDadosComp,/*nRecnoSN4*/,/*lComple*/,.F.,,lContabOn,cPadrao)

		//Adiciona Flag para contabilizaç?o
		If lUsaFlag
			aAdd(aFlagCTB, {"N4_LA", "S", "SN4", nRecnoSN4, 0, 0, 0})
		EndIf


		If cFilOrig == cFilDest	//Comparação Entre a filial cheia do destino e da origem.
			If(VerPadrao("833")) .And. lContabOn
				If( lPrim .And. (nHdlPrv <= 0))
					nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
					lPrim := .f.
				Endif
				nTotal += DetProva( nHdlPrv,"833","ATFA060",cLoteAtf,,,,,,,,@aFlagCTB)
			Endif
		Endif

	EndIf

	If(lDespDep)

		aValores   := AtfMultMoe(,,{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x)))+ IIf(x==1,SN3->N3_VRCDA1,0) })

		If(cOcorren == "03") // Origem
			aEntidades[1] := oModFNS:GetValue("FNS_CONDDO")
			aEntidades[2] := oModFNS:GetValue("FNS_CCDDO")
			aEntidades[3] := oModFNS:GetValue("FNS_ITDEDO")
			aEntidades[4] := oModFNS:GetValue("FNS_CVDEPO")
		Else // Destino
			aEntidades[1] := IIf(oModFNS:GetValue("FNS_CONDDD") == "*", oModFNS:GetValue("FNS_CONDDO"), oModFNS:GetValue("FNS_CONDDD"))
			aEntidades[2] := IIf(oModFNS:GetValue("FNS_CCDDD")  == "*", oModFNS:GetValue("FNS_CCDDO") , oModFNS:GetValue("FNS_CCDDD"))
			aEntidades[3] := IIf(oModFNS:GetValue("FNS_ITDEDD") == "*", oModFNS:GetValue("FNS_ITDEDO"), oModFNS:GetValue("FNS_ITDEDD"))
			aEntidades[4] := IIf(oModFNS:GetValue("FNS_CVDEPD") == "*", oModFNS:GetValue("FNS_CVDEPO"), oModFNS:GetValue("FNS_CVDEPD"))
		Endif

		nRecnoSN4	:= ATFXMOV(cFilSN4,@cIDMOV,dDataTrans,cOcorren,SN3->N3_CBASE,cN3Item,SN3->N3_TIPO,cN3Baixa,SN3->N3_SEQ,SN3->N3_SEQREAV,'3',nQtdDest,cTpSaldo,aEntidades,aValores,aDadosComp,/*nRecnoSN4*/,/*lComple*/,.F.,,lContabOn,cPadrao)

		//Adiciona Flag para contabilizaç?o
		If lUsaFlag
			aAdd(aFlagCTB, {"N4_LA", "S", "SN4", nRecnoSN4, 0, 0, 0})
		EndIf


		If cFilOrig == cFilDest	//Comparação Entre a filial cheia do destino e da origem.
			If(VerPadrao("833")) .And. lContabOn
				If( lPrim .And. (nHdlPrv <= 0))
					nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
					lPrim := .f.
				Endif
				nTotal += DetProva( nHdlPrv,"833","ATFA060",cLoteAtf,,,,,,,,@aFlagCTB)
			Endif
		Endif

	EndIf
EndIf

If(lBem .Or. lLocal .Or. lTaxaPad )

	aValores   := AtfMultMoe(,,{|x| SN3->&("N3_VORIG"+Alltrim(Str(x)))+SN3->&(IIf(x>9,"N3_AMPLI","N3_AMPLIA")+Alltrim(Str(x))) })

	If(cOcorren == "03")// Origem
		aEntidades[1] := oModFNS:GetValue("FNS_CONTAO")
		aEntidades[2] := oModFNS:GetValue("FNS_CCBEMO")
		aEntidades[3] := oModFNS:GetValue("FNS_ITBEMO")
		aEntidades[4] := oModFNS:GetValue("FNS_CVBEMO")
		If Len(__aCTBEnt) > 0 .AND. __lEntAdd//Tratamento para entidades adicionais
			For nContEnt := 1 to Len(__aCTBEnt)
				AADD( aEntAdic, oModFNS:GetValue("FNS_EC"+__aCTBEnt[nContEnt]+"DO") )
				AADD( aEntAdic, oModFNS:GetValue("FNS_EC"+__aCTBEnt[nContEnt]+"CO") )
			Next nContEnt
		EndIf
	Else // Destino
		aEntidades[1] := IIf(oModFNS:GetValue("FNS_CONTAD") == "*", oModFNS:GetValue("FNS_CONTAO"), oModFNS:GetValue("FNS_CONTAD")) /// SE DESTINO = * DESTINO=ORIGEM
		aEntidades[2] := IIf(oModFNS:GetValue("FNS_CCBEMD") == "*", oModFNS:GetValue("FNS_CCBEMO"), oModFNS:GetValue("FNS_CCBEMD")) /// SE DESTINO = * DESTINO=ORIGEM
		aEntidades[3] := IIf(oModFNS:GetValue("FNS_ITBEMD") == "*", oModFNS:GetValue("FNS_ITBEMO"), oModFNS:GetValue("FNS_ITBEMD")) /// SE DESTINO = * DESTINO=ORIGEM
		aEntidades[4] := IIf(oModFNS:GetValue("FNS_CVBEMD") == "*", oModFNS:GetValue("FNS_CVBEMO"), oModFNS:GetValue("FNS_CVBEMD")) /// SE DESTINO = * DESTINO=ORIGEM
		If Len(__aCTBEnt) > 0 .AND. __lEntAdd//Tratamento para entidades adicionais
			For nContEnt := 1 to Len(__aCTBEnt)
				AADD( aEntAdic, IIf(oModFNS:GetValue("FNS_EC"+__aCTBEnt[nContEnt]+"DD") == "*", oModFNS:GetValue("FNS_EC"+__aCTBEnt[nContEnt]+"DO"), oModFNS:GetValue("FNS_EC"+__aCTBEnt[nContEnt]+"DD")) )
				AADD( aEntAdic, IIf(oModFNS:GetValue("FNS_EC"+__aCTBEnt[nContEnt]+"CD") == "*", oModFNS:GetValue("FNS_EC"+__aCTBEnt[nContEnt]+"CO"), oModFNS:GetValue("FNS_EC"+__aCTBEnt[nContEnt]+"CD")) )
			Next nContEnt
		EndIf
	EndIf

	nRecnoSN4	:= ATFXMOV(cFilSN4,@cIDMOV,dDataTrans,cOcorren,SN3->N3_CBASE,cN3Item,SN3->N3_TIPO,cN3Baixa,SN3->N3_SEQ,SN3->N3_SEQREAV,'1',nQtdDest,cTpSaldo,aEntidades,aValores,aDadosComp,/*nRecnoSN4*/,/*lComple*/,.F.,,lContabOn,cPadrao,,,aEntAdic)

	//Adiciona Flag para contabilizaç?o
	If lUsaFlag
		aAdd(aFlagCTB, {"N4_LA", "S", "SN4", nRecnoSN4, 0, 0, 0})
	EndIf


	If cFilOrig == cFilDest	//Comparação Entre a filial cheia do destino e da origem.
		If(VerPadrao("833")) .And. lContabOn
			If( lPrim .And. (nHdlPrv <= 0))
				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
				lPrim := .f.
			Endif
			nTotal += DetProva( nHdlPrv,"833","ATFA060",cLoteAtf,,,,,,,,@aFlagCTB)
		Endif
	Endif

EndIf

If(lDepAcum)

	aValores   := AtfMultMoe(,,{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x)))+ IIf(x==1,SN3->N3_VRCDA1,0) })

	If(cOcorren == "03") // Origem
		aEntidades[1] := oModFNS:GetValue("FNS_CONDAO")
		aEntidades[2] := oModFNS:GetValue("FNS_CCDAO")
		aEntidades[3] := oModFNS:GetValue("FNS_ITDEAO")
		aEntidades[4] := oModFNS:GetValue("FNS_CVCDEO")
	Else // Destino
		aEntidades[1] := IIf(oModFNS:GetValue("FNS_CONDAD") == "*", oModFNS:GetValue("FNS_CONDAO"), oModFNS:GetValue("FNS_CONDAD"))
		aEntidades[2] := IIf(oModFNS:GetValue("FNS_CCDAD")  == "*", oModFNS:GetValue("FNS_CCDAO") , oModFNS:GetValue("FNS_CCDAD"))
		aEntidades[3] := IIf(oModFNS:GetValue("FNS_ITDEAD") == "*", oModFNS:GetValue("FNS_ITDEAO"), oModFNS:GetValue("FNS_ITDEAD"))
		aEntidades[4] := IIf(oModFNS:GetValue("FNS_CVCDED") == "*", oModFNS:GetValue("FNS_CVCDEO"), oModFNS:GetValue("FNS_CVCDED"))
	Endif

	nRecnoSN4	:= ATFXMOV(cFilSN4,@cIDMOV,dDataTrans,cOcorren,SN3->N3_CBASE,cN3Item,SN3->N3_TIPO,cN3Baixa,SN3->N3_SEQ,SN3->N3_SEQREAV,'4',nQtdDest,cTpSaldo,aEntidades,aValores,aDadosComp,/*nRecnoSN4*/,/*lComple*/,.F.,,lContabOn,cPadrao)

	//Adiciona Flag para contabilizaç?o
	If lUsaFlag
		aAdd(aFlagCTB, {"N4_LA", "S", "SN4", nRecnoSN4, 0, 0, 0})
	EndIf

	If cFilOrig == cFilDest	//Comparação Entre a filial cheia do destino e da origem.
		If(VerPadrao("833")) .And. lContabOn
			If( lPrim .And. (nHdlPrv <= 0))
				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
				lPrim := .f.
			Endif
			nTotal += DetProva( nHdlPrv,"833","ATFA060",cLoteAtf,,,,,,,,@aFlagCTB)
		Endif
	Endif

EndIf

If(lCorMDep)
	aValores   := IIf(lMultMoed, AtfMultMoe(,,{|x| 0}) , {0,0,0,0,0} )
	aValores[1] := Round(SN3->N3_VRCACM1 , X3Decimal("N4_VLROC1") )

	If(cOcorren == "03") // Origem
		aEntidades[1] := oModFNS:GetValue("FNS_CONCDO")
		aEntidades[2] := oModFNS:GetValue("FNS_CCCDO")
		aEntidades[3] := oModFNS:GetValue("FNS_ITCDEO")
		aEntidades[4] := oModFNS:GetValue("FNS_CVDESO")
	Else // Destino
		aEntidades[1] := IIf(oModFNS:GetValue("FNS_CONCDD") == "*", oModFNS:GetValue("FNS_CONCDO"), oModFNS:GetValue("FNS_CONCDD"))
		aEntidades[2] := IIf(oModFNS:GetValue("FNS_CCCDD")  == "*", oModFNS:GetValue("FNS_CCCDO") , oModFNS:GetValue("FNS_CCCDD"))
		aEntidades[3] := IIf(oModFNS:GetValue("FNS_ITCDED") == "*", oModFNS:GetValue("FNS_ITCDEO"), oModFNS:GetValue("FNS_ITCDED"))
		aEntidades[4] := IIf(oModFNS:GetValue("FNS_CVDESD") == "*", oModFNS:GetValue("FNS_CVDESO"), oModFNS:GetValue("FNS_CVDESD"))
	EndIf

	nRecnoSN4	:= ATFXMOV(cFilSN4,@cIDMOV,dDataTrans,cOcorren,SN3->N3_CBASE,cN3Item,SN3->N3_TIPO,cN3Baixa,SN3->N3_SEQ,SN3->N3_SEQREAV,'5',nQtdDest,cTpSaldo,aEntidades,aValores,aDadosComp,/*nRecnoSN4*/,/*lComple*/,.F.,,lContabOn,cPadrao)

	//Adiciona Flag para contabilizaç?o
	If lUsaFlag
		aAdd(aFlagCTB, {"N4_LA", "S", "SN4", nRecnoSN4, 0, 0, 0})
	EndIf


	If cFilOrig == cFilDest	//Comparação Entre a filial cheia do destino e da origem.
		If(VerPadrao("833")) .And. lContabOn
			If( lPrim .And. (nHdlPrv <= 0))
				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
				lPrim := .f.
			Endif
			nTotal += DetProva( nHdlPrv,"833","ATFA060",cLoteAtf,,,,,,,,@aFlagCTB)
		Endif
	Endif

Endif

//Posiciono nas tabelas apenas para fazer o lançamento caso for transferencia para mesma filial
If(cFilOrig == cFilDest)
	//Chamado do TDI para posicionar nas Tabelas FNR e FNS para ter a filial de destino e origem nos LP's
	FNR->(DbSetOrder(1))
	FNS->(DbSetOrder(1))
	FNR->(DbSeek(xFilial("FNR",cFilOrig)+oModFnr:GetValue("FNR_IDMOV")+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEDES")))
	FNS->(DbSeek(xFilial("FNS",cFilOrig)+oModFns:GetValue("FNS_IDMOV")+oModFns:GetValue("FNS_CODREL")+oModFns:GetValue("FNS_TIPO")+oModFns:GetValue("FNS_SEQ")))
EndIf

If(lCorrecao)
	If(lMultMoed)
		aValorMoed := AtfMultMoe(,,{|x| IIf(x==1,SN3->N3_VRCACM1,0) })
	EndIf

	ATFXSLDCTB(SN3->N3_CCORREC, dDataTrans, IIf(nX == 1, cTipoTrDe, cTipoTrPara),SN3->N3_VRCACM1,0,0,0,0 ,"+",nTaxaMedia,SN3->N3_SUBCCOR,,SN3->N3_CLVLCOR,SN3->N3_CCCORR,"2", aValorMoed)
EndIf

If(lBem .Or. lLocal)		// Atualizar contas na transf de contas. Controle de multiplas moedas
	aAtuSal[1] := SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1

	For nI := 2 to __nQuantas
		cMoed := Alltrim(Str(nI))
		aAtuSal[nI]	:= SN3->&("N3_VORIG"+cMoed)+SN3->&(IIf(nI > 9,"N3_AMPLI","N3_AMPLIA")+cMoed)
	Next nI

	ATFXSLDCTB(SN3->N3_CCONTAB, dDataTrans, IIf(nX = 1, cTipoTrDe, cTipoTrPara),aAtuSal[1],aAtuSal[2],aAtuSal[3],aAtuSal[4],aAtuSal[5],"+",;
					nTaxaMedia,SN3->N3_SUBCCON,,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1", aAtuSal,,,,,, aEntAdic )
EndIf
/*Conta desp dep SN3->N3_CDEPREC*/
If lDespDep	//se tem desp deprec e somente na origem, pois no destino ele entra no IF DO valor acumulado
	If(lMultMoed)  // Controle de multiplas moedas
		aValorMoed := AtfMultMoe(,,{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x))) + IIf(x=1,SN3->N3_VRCDA1,0) })
	EndIf
	ATFXSLDCTB(SN3->N3_CDEPREC , dDataTrans, IIf(nX = 1, cTipoTrDe, cTipoTrPara),SN3->(N3_VRDACM1+N3_VRCDA1),SN3->N3_VRDACM2,;
			SN3->N3_VRDACM3,SN3->N3_VRDACM4,SN3->N3_VRDACM5,"+", nTaxaMedia,SN3->N3_SUBCCDE,,SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"3",aValorMoed )

EndIf
/*Conta desp dep*/

If(lDepAcum)		// Controle de multiplas moedas
	If(lMultMoed)
		aValorMoed := AtfMultMoe(,,{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x))) + IIf(x=1,SN3->N3_VRCDA1,0) })
	EndIf
	ATFXSLDCTB(SN3->N3_CCDEPR , dDataTrans, IIf(nX = 1, cTipoTrDe, cTipoTrPara),SN3->(N3_VRDACM1+N3_VRCDA1),SN3->N3_VRDACM2,;
			SN3->N3_VRDACM3,SN3->N3_VRDACM4,SN3->N3_VRDACM5,"+", nTaxaMedia,SN3->N3_SUBCCDE,,SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"4",aValorMoed )
EndIf

If(lCorMDep) // Controle de multiplas moedas  *
	If(lMultMoed)
		aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,SN3->N3_VRCDA1,0) })
	EndIf

	ATFXSLDCTB(SN3->N3_CDESP  , dDataTrans, IIf(nX = 1, cTipoTrDe, cTipoTrPara),SN3->N3_VRCDA1,0,0,0,0 ,"+",nTaxaMedia,	SN3->N3_SUBCDES,,SN3->N3_CLVLDES,SN3->N3_CCCDES,"5", aValorMoed )
EndIf

// Lançamento no Módulo SigaPCO
lLancPco := .T.
If cFilOrig == cFilDest
	If(nX == 1)
		cItemPco := "01" // Transferencia Contábil
	Else
		lLancPco := .F.
	EndIf
ElseIf(nX == 1)
	cItemPco := "02" // Transferencia Filial - Origem
Else
	cItemPco := "03" // Transferencia  Filial - Destino
Endif

If(lLancPco)
	PcoIniLan("000368")
	PcoDetLan("000368",cItemPco,"ATFA060")
	PcoFinLan("000368")
EndIf

If(xFilial("SN1",cFilDest) <> xFilial("SN1",cFilOrig))
	cFilAnt := cFilOrig
Endif

If lContabOn //Contabiliza
	If cFilOrig == cFilDest
		If(NX = 1 .And. VerPadrao("830"))
			cAliasCTB := Alias()
			dbSelectArea( "SN4" )
			Af060VarCtb(oModel)
			If (lPrim .And. (nHdlPrv <= 0))
				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
				lPrim := .f.
			Endif
			nTotal += DetProva( nHdlPrv,"830","ATFA060",cLoteAtf)
			dbSelectArea( cAliasCTB )
		Endif
	ElseIf(nX = 1)
		If(VerPadrao("831"))
			Af060VarCtb(oModel)
		Endif

		cFilAnt := cFilDest
		If(VerPadrao("832"))// FIL DESTINO
			Af060VarCtb(oModel)
		Endif
		//		cFilAnt := cFilOrig
	Endif
Endif

If(lAF060GSN4)
	ExecBlock("AF060GSN4",.F.,.F.)
EndIf

RestArea(aArea)

Return

/*{Protheus.doc} AF060CTBFIL
Função de Contabilização de Filiais Diferentes
@author Jose Augusto Ribeiro
@since 04/06/2015
@version P12
@param cLoteAtf, Caracter, Lote para contabilização do bem
@param nHdlPrv , Numérico, Handle de Contabilização
@param cArquivo, Caracter, Nome do Arquivo para contabilização
@param cOcorren, Caracter, Numero da Ocorrencia
*/
Static Function AF060CTBFIL(cLoteAtf,cArquivo,cFilOrig,cFilDest,cOcorren,nFNS,nFNR,oModel,nTotal,nHdlPrv)
Local aArea			:= GetArea()
Local nAtual		:= 0
Local lPad86A		:= VerPadrao("86A")  //Contabiliza AVP da Filial de Origem (Baixa por Transferencia)
Local lPad86B		:= VerPadrao("86B")  //Contabiliza AVP da Filial de Destino(Constituicao por Transferencia)
Local LanceiCtb		:= If(Type("LanceiCtb") != "L",.F.,LanceiCtb)//Controle de lancamento - Detprova]
Local oModFns		:= oModel:GetModel("GridFNS")
Local oModFnr		:= oModel:GetModel("GridFNR")
Local dDataTrans	:= oModFnr:GetValue("FNR_DATA")
Local nPosSN3  		:= 0
Local nRecnoSN3		:= 0
Local nRecnoSN4		:= 0
Local cUltSeq		:= ""


	If(cOcorren == "03")
		oModFnr:GoLine(nFNR)
		oModFns:GoLine(nFNS)
		//Chamado do TDI para posicionar nas Tabelas FNR e FNS para ter a filial de destino e origem nos LP's
		FNR->(DbSetOrder(1))
		FNS->(DbSetOrder(1))
		SN1->(DbSetOrder(1))
		SN3->(DbSetOrder(1))
		SN4->(DbSetOrder(1))
		FNR->(DbSeek(xFilial("FNR",cFilOrig)+oModFnr:GetValue("FNR_IDMOV")+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEORI")))
		FNS->(DbSeek(xFilial("FNS",cFilOrig)+oModFns:GetValue("FNS_IDMOV")+oModFns:GetValue("FNS_CODREL")+oModFns:GetValue("FNS_TIPO")+oModFns:GetValue("FNS_SEQ")))
		SN1->(Dbseek(xFilial("SN1",cFilOrig)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEORI")))
		//Posicionamento diferente caso transferencia seja parcial
		If FNR->FNR_QTDORI == FNR->FNR_QTDDES
			SN3->(DbSeek(xFilial("SN3",cFilOrig)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEORI")+oModFns:GetValue("FNS_TIPO")+ "1" +oModFns:GetValue("FNS_SEQ")))
		Else
			SN3->(DbSeek(xFilial("SN3",cFilOrig)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEORI")+oModFns:GetValue("FNS_TIPO")+ "0" +oModFns:GetValue("FNS_SEQ")))
		EndIf

		nRecnoSN4	:=	A060RECN4(@cUltSeq,dDataTrans, cOcorren,"1")

		If nRecnoSN4 > 0
			SN4->(DbGoTo(nRecnoSN4))
		EndIf

		//Tratamento acumulado depreciaç?o - transferencia parcial
		If FNR->FNR_QTDORI <> FNR->FNR_QTDDES
			nRecnoSN3 := SN3->(Recno()) //Salva SN3 original

			//Posiciono no SN3 da baixa para contabilizaç?o 831
			SN3->(dbSetOrder(1))//N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
			SN3->(DbSeek(SN3->N3_FILIAL+SN3->N3_CBASE+SN3->N3_ITEM+SN3->N3_TIPO+"1"+cUltSeq))

			nTotal += DetProva( nHdlPrv,"831","ATFA060",cLoteAtf)

			SN3->(DbGoTo(nRecnoSN3)) //Restaura SN3 original
		Else
			nTotal += DetProva( nHdlPrv,"831","ATFA060",cLoteAtf)
		EndIf

		If SN3->N3_TPDEPR $ "4|5|8|9|"
			//Apontamento inicial de estimativa de produção - P0
			nPosSn3 := SN3->(Recno())
			AF110GrvAp(nPosSn3,"P0")
			cPadrao := "870"		//Apontamento de estimativa de produção
			lPadrao := VerPadrao(cPadrao)
			If ValType(nHdlPrv) == "N" .And. nHdlPrv > 0 .And. lPadrao
				nTotal += DetProva(nHdlPrv,cPadrao,"ATFA060",cLoteAtf)
			EndIf
			If (SN3->N3_PRODACM > 0) .And. (SN3->N3_VRDACM1 > 0)
				//Apontamento de produção acumulada - P5
				AF110GrvAp(nPosSn3,"P5")
			EndIf
		EndIf

		//AVP
		//Contabiliza AVP - Filial de Origem
		If lPad86A
			For nAtual := 1 to Len(aAvpCtbO)
				If(nAtual = 1 .And. (nHdlPrv <= 0))
					nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
				Endif

				//Posiciono no SN1
				SN1->(dbSetOrder(1))
				SN1->(MsSeek(xFilial("SN1")+FNF->(FNF_CBASE+FNF_ITEM)))

				//Posiciono no SN3
				SN3->(dbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
				SN3->(MsSeek(xFilial("SN1")+FNF->(FNF_CBASE+FNF_ITEM)+"14"+"1"+FNF->FNF_SEQ))

				//Posiciono no FNF
				FNF->(DbSetOrder(1))
				FNF->(DbSeek(xFilial("FNF")+SN3->N3_CBASE+SN3->N3_ITEM+SN3->N3_TIPO+SN3->N3_SEQ+SN3->N3_TPSALDO))

				nTotal += DetProva( nHdlPrv,"86A","ATFA060",cLoteAtf)

				//Gravo flag de contabilizacao
				If(LanceiCtb)
					RecLock("FNF")
					FNF->FNF_DTCONT  := dDatabase
					MsUnlock( )
				Endif
			Next
		Endif

	ElseIf(cOcorren == "04")
		oModFnr:GoLine(nFNR)
		oModFns:GoLine(nFNS)
		FNR->(DbSetOrder(1))
		FNS->(DbSetOrder(1))
		SN1->(DbSetOrder(1))
		SN3->(DbSetOrder(1))
		SN4->(DbSetOrder(1))
		FNR->(DbSeek(xFilial("FNR",cFilOrig)+oModFnr:GetValue("FNR_IDMOV")+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEDES")))
		FNS->(DbSeek(xFilial("FNS",cFilOrig)+oModFns:GetValue("FNS_IDMOV") + PadR(oModFns:GetValue("FNS_CODREL"),TamSx3("FNS_CODREL")[1]) + oModFns:GetValue("FNS_TIPO")+oModFns:GetValue("FNS_SEQ")))
		SN1->(Dbseek(xFilial("SN1",cFilDest)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEDES")))
		SN3->(DbSeek(xFilial("SN3",cFilDest)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEDES")+oModFns:GetValue("FNS_TIPO")+ "0" + oModFns:GetValue("FNS_SEQ")))

		//Tratativa para posicionar na sequencia exata quando transferencia parcial
		If FNR->FNR_QTDORI <> FNR->FNR_QTDDES
			SN3->(DbSeek(xFilial("SN3",cFilorig)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEDES")+oModFns:GetValue("FNS_TIPO")+ "0" + oModFns:GetValue("FNS_SEQ")))
			cUltSeq   := A060UltSeq(cFilDest, SN3->N3_CBASE, SN3->N3_ITEM, SN3->N3_TIPO, SN3->N3_TPSALDO, SN3->N3_SEQREAV)
			SN3->(DbSeek(xFilial("SN3",cFilDest)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEDES")+oModFns:GetValue("FNS_TIPO")+"0"+cUltSeq))
		EndIF

		nRecnoSN4	:=	A060RECN4(@cUltSeq,dDataTrans, cOcorren,"1")

		If nRecnoSN4 > 0
			SN4->(DbGoTo(nRecnoSN4))
		EndIf

		Af060VarCtb(oModel)
		nTotal += DetProva( nHdlPrv,"832","ATFA060",cLoteAtf)

		//Contabiliza AVP - Filial de Destino
		If lPad86B
			If(nAtual = 1 .And. (nHdlPrv <= 0))
				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
			Endif

			//Posiciono no SN1
			SN1->(dbSetOrder(1))
			SN1->(MsSeek(xFilial("SN1")+FNF->(FNF_CBASE+FNF_ITEM)))

			//Posiciono no SN3
			SN3->(dbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_TPSALDO
			SN3->(MsSeek(xFilial("SN1")+FNF->(FNF_CBASE+FNF_ITEM)+"14"+"0"+FNF->FNF_SEQ))

			FNF->(DbSetOrder(1))
			FNF->(DbSeek(xFilial("FNF")+SN3->N3_CBASE+SN3->N3_ITEM+SN3->N3_TIPO+SN3->N3_SEQ+SN3->N3_TPSALDO))

			nTotal += DetProva( nHdlPrv,"86B","ATFA060",cLoteAtf)
			//Gravo flag de contabilizacao
			If(LanceiCtb)
				RecLock("FNF")
				FNF->FNF_DTCONT  := dDatabase
				MsUnlock( )
			Endif

		Endif
	EndIf
restArea(aArea)
Return

/*{Protheus.doc} AF060RAT
Função que Realiza a Transferencia de Rateio
@author Jose Augusto Ribeiro
@since 04/06/2015
@version P12
@param cRateio , caracter, Codigo de Rateio
*/
Static Function AF060Rat(cRateio,cFilOrig,cFilDest)
	Local aArea		:= GetArea()
	Local aAreaSN3	:= SN3->(GetArea())
	Local aAreaSNV	:= SNV->(GetArea())
	Local aAreaCT1	:= CT1->(GetArea())
	Local aAreaCTT	:= CTT->(GetArea())
	Local aAreaCTD	:= CTD->(GetArea())
	Local aAreaCTH	:= CTH->(GetArea())
	Local cFilAux	:= cFilAnt
	Local cFilRat	:= ""
	Local aNewRat	:= {}

	CT1->(dbSetOrder(1)) //CT1_FILIAL+CT1_CONTA
	CTT->(dbSetOrder(1)) //CTT_FILIAL+CTT_CUSTO
	CTD->(dbSetOrder(1)) //CTD_FILIAL+CTD_ITEM
	CTH->(dbSetOrder(1)) //CTH_FILIAL+CTH_CLVL
	SN3->(DbOrderNickName("RATEIO"))
	SNV->(DbSetOrder(1))		//NV_FILIAL+NV_CODRAT+NV_NV_REVISAO+NV_SEQUEN

	If !Empty(cRateio) .AND. SN3->(DbSeek(xFilial("SN3",cFilDest)+cRateio))

		cFilRat := cFilAnt
		cFilAnt := cFilOrig
		cRevAtu := Af011GetRev(SN3->N3_CODRAT)

		If SNV->(DbSeek(xFilial("SNV")+PadR(SN3->N3_CODRAT,TamSx3("NV_CODRAT")[1]) + PadR(cRevAtu,TamSx3("NV_REVISAO")[1])))

			aNewRat	:= Eval({|x| cFilAnt := cFilRat,x:= AF011COD(),cFilAnt := cFilOrig,x})
			aCamposAlt := {{"NV_CODRAT",aNewRat[1]},{"NV_REVISAO",aNewRat[2]}}
			While SNV->(!Eof()) .AND. xFilial("SNV") == SNV->NV_FILIAL .AND. Alltrim(SN3->N3_CODRAT+cRevAtu) == Alltrim(SNV->(NV_CODRAT+NV_REVISAO))
				AFA060COPY("SNV",SNV->(Recno()),cFilDest,aCamposAlt)
				SNV->(DbSkip())
			EndDo

			//Atualizar o status do rateio da filial antiga para baixado
			Af011AtuStatus(SN3->N3_CODRAT,cRevAtu,"4")
			cFilAnt := cFilRat

			//Verifica se as entidades do novo rateio existem na filial destino
			If SNV->(MsSeek(xFilial("SNV",cFilDest)+aNewRat[1]+aNewRat[2]))		//NV_FILIAL+NV_CODRAT+NV_REVISAO+NV_SEQUEN
				While SNV->(!EoF()) .And. (SNV->(NV_FILIAL+NV_CODRAT+NV_REVISAO) == xFilial("SNV",cFilDest)+aNewRat[1]+aNewRat[2])

					If !Empty(SNV->NV_CONTA)
						If !CT1->(MsSeek(xFilial("CT1",cFilDest)+SNV->NV_CONTA))
							__lExisEnt := .F.
							Exit
						EndIf
					EndIf
					If !Empty(SNV->NV_CC)
						If !CTT->(MsSeek(xFilial("CTT",cFilDest)+SNV->NV_CC))
							__lExisEnt := .F.
							Exit
						EndIf
					EndIf
					If !Empty(SNV->NV_ITEMCTA)
						If !CTD->(MsSeek(xFilial("CTD",cFilDest)+SNV->NV_ITEMCTA))
							__lExisEnt := .F.
							Exit
						EndIf
					EndIf
					If !Empty(SNV->NV_CLVL)
						If !CTH->(MsSeek(xFilial("CTH",cFilDest)+SNV->NV_CLVL))
							__lExisEnt := .F.
							Exit
						EndIf
					EndIf

					SNV->(dbSkip())
				EndDo
			EndIf

			//Atualizar o codigo do rateio do bem para o codigo novo do rateio para a filial nova
			RecLock("SN3",.F.)
			SN3->N3_CODRAT := aNewRat[1]
			SN3->(MsUnlock())

			If !__lExisEnt
				If SNV->(MsSeek(xFilial("SNV",cFilDest)+aNewRat[1]+aNewRat[2]))
					While SNV->(!EoF()) .And. SNV->(NV_FILIAL+NV_CODRAT+NV_REVISAO) == xFilial("SNV",cFilDest)+aNewRat[1]+aNewRat[2]
						RecLock("SNV", .F.)
						SNV->NV_MSBLQL := "1"
						MsUnlock()
						SNV->(dbSkip())
					EndDo
				EndIf
			EndIf
		Endif
	Endif

	cFilAnt := cFilAux
	RestArea(aAreaCTH)
	RestArea(aAreaCTD)
	RestArea(aAreaCTT)
	RestArea(aAreaCT1)
	RestArea(aAreaSNV)
	RestArea(aAreaSN3)
	RestArea(aArea)

Return

/*{Protheus.doc} AFA060COPY
Função que copia os dados da tabela para diferentes filiais
@author $Jose Augusto Ribeiro
@since 04/06/2015
@version P12
@param cAlias    , caracter, Tabela para ser gravado
@param nRecno    , numérico, Numero do registro a ser copiado
@param aCamposAlt, array   , Array com os campos e o conteudo para ser salvo
*/
Static Function AFA060COPY(cAlias,nRecno,cFilDest,aCamposAlt)
	Local aSaveArea	:= GetArea()
	Local cFilOrig	:= cFilAnt
	Local aArea		:= {}
	Local aCampos	:= {}
	Local nI		:= 0
	Local nJ		:= 0
	Local nY		:= 0
	Local lAlterFil	:= .F.

	Default aCamposAlt	:= {}
	Default cAlias		:= ""
	Default nRecno		:= 0

	lAlterFil := !Empty(cFilDest)

	If !Empty(cAlias) .and.  nRecno != 0
		aArea:= (cAlias)->(GetArea())
		(cAlias)->(DbGoto(nRecno))
		aAdd(aCampos,Array((cAlias)->(FCount())))

		For nI := 1 To &(cAlias)->(FCount())
			aCampos[Len(aCampos),nI] := (cAlias)->&(FieldName(nI))
		Next nI

		If lAlterFil
			cFilAnt := cFilDest
		EndIf
		For nJ := 1 to len(aCampos)
			RecLock(cAlias,.T.)
			For nI := 1 to len(aCampos[nJ])

				If "FILIAL" $ (cAlias)->(FieldName(nI))
					(cAlias)->&(FieldName(nI)) := xFilial(cAlias)
				Else
					(cAlias)->&(FieldName(nI)) := aCampos[nJ,nI]
				EndIf
			Next nI
			If !Empty(aCamposAlt)
				For nY := 1 To Len(aCamposAlt)
					If ColumnPos(aCamposAlt[nY,1])>0
						(cAlias)->&(aCamposAlt[nY,1]) := aCamposAlt[nY,2]
					EndIf
				Next nY
			EndIf
			(cAlias)->(MSunlock())
		Next nJ
		(cAlias)->(RestArea(aArea))
		If lAlterFil
			cFilAnt := cFilOrig
		EndIf
	EndIf

	RestArea(aSaveArea)

Return

/*{Protheus.doc} AF060SELORC
Transfere os bens de provisao filhos do bem de orcamento
@author Jose Augusto Ribeiro
@since 05/06/2015
@version P12
@param cBaseSup, Caracter, Codigo Base do bem Superior
@param cItemSup, Caracter, Codigo Item do bem Superior
@return aRecnos, Array   , Array com os RENCNOS da SN3
*/
Static Function AF060SELORC(cBaseSup,cItemSup)
	Local cQuery		:= ""
	Local aRecnos		:= {}
	Local aArea			:= GetArea()
	Local aAreaSN1		:= SN1->(GetArea())
	Local cNextAlias	:= GetNextAlias()

	//Selecao de bens constituidos para apuracao do AVP
	//- Bens com constituicao ativa e
	//- que nao possuam movimentos posteriores a data de processamento
	cQuery := "SELECT SN3.R_E_C_N_O_ RECSN3, N3_FILIAL, N3_CBASE, N3_ITEM FROM "+RetSQLNAME("SN3") + " SN3"

	cQuery += "INNER JOIN " + RetSQLNAME('SN1') + " SN1"
	cQuery += "  ON  SN3.N3_FILIAL = SN1.N1_FILIAL AND "
	cQuery += "      SN3.N3_CBASE  = SN1.N1_CBASE  AND "
	cQuery += "      SN3.N3_ITEM   = SN1.N1_ITEM       "
	cQuery += "WHERE "
	cQuery += " SN3.N3_FILIAL = '"+xFilial("SN3")+"' AND "
	cQuery += " SN1.N1_FILIAL = '"+xFilial("SN1")+"' AND "
	cQuery += " SN1.N1_PATRIM = 'V' AND  "
	cQuery += " SN1.N1_BASESUP = '"+cBaseSup+"' AND "
	cQuery += " SN1.N1_ITEMSUP = '"+cItemSup+"' AND "
	cQuery += " SN1.N1_BAIXA = ' ' AND "
	cQuery += " SN3.N3_BAIXA = '0' AND "
	cQuery += " SN3.N3_TIPO = '14' AND "
	cQuery += " SN1.D_E_L_E_T_ = ' ' AND "
	cQuery += " SN3.D_E_L_E_T_ = ' ' "
	cQuery += " ORDER BY N3_FILIAL, N3_CBASE, N3_ITEM "

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cNextAlias,.T.,.T.)

	While(!(cNextAlias)->(Eof()))

		aAdd(aRecnos,(cNextAlias)->RECSN3)

		(cNextAlias)->(dbSkip())

	EndDo

	//Fecho o temporario
	(cNextAlias)->(dbCloseArea())

	RestArea(aAreaSN1)
	RestArea(aArea)

Return aRecnos

/*{Protheus.doc} AF060VARCTB
Função para Carregar as variaveis privadas para contabilização
@author Jose Augusto Ribeiro
@since 09/06/2015
@version P12
*/
Static Function Af060VarCtb(oModel)
	Local oGRIDFNS	:= oModel:GetModel("GridFNS")

	//----------------
	// Conta Contabil
	//----------------
	CTABEM    := oGRIDFNS:Getvalue("FNS_CONTAD") //N3_CCONTAB - Bem
	CORREBEM  := oGRIDFNS:Getvalue("FNS_CONCOD") //N3_CCORREC - Correcao do Bem
	DESPDEPR  := oGRIDFNS:Getvalue("FNS_CONDDD") //N3_CDEPREC - Despesa de Depreciacao
	DEPREACUM := oGRIDFNS:Getvalue("FNS_CONDAD") //N3_CCDEPR  - Deprecicao Acumulada
	CORREDEPR := oGRIDFNS:Getvalue("FNS_CONCDD") //N3_CDESP   - Correcao de Depreciacao

	//-----------------
	// Centro de Custo
	//-----------------
	CUSTO      := oGRIDFNS:Getvalue("FNS_CCDESD") //N3_CCUSTO  - Despesa
	CUSTBEMCTB := oGRIDFNS:GetValue("FNS_CCBEMD") //N3_CUSTBEM - Bem
	CCCORRCTB  := oGRIDFNS:GetValue("FNS_CCCORD") //N3_CCCORR  - Correção monetária
	CCDESPCTB  := oGRIDFNS:GetValue("FNS_CCDDD")  //N3_CCDESP  - Despesa de Depreciacao
	CCCDEPCTB  := oGRIDFNS:GetValue("FNS_CCDAD")  //N3_CCCDEP  - Depreciação Acumulada
	CCCDESCTB  := oGRIDFNS:GetValue("FNS_CCCDD")  //N3_CCCDES  - Correção da Depreciação

	//---------------
	// Item Contábil
	//---------------
	SUBCCONCTB := oGRIDFNS:GetValue("FNS_ITBEMD") //N3_SUBCCON - Bem
	SUBCCORCTB := oGRIDFNS:GetValue("FNS_ITCORD") //N3_SUBCCOR - Correcao Monetaria
	SUBCDEPCTB := oGRIDFNS:GetValue("FNS_ITDEDD") //N3_SUBCDEP - Despesa Depreciacao
	SUBCCDECTB := oGRIDFNS:GetValue("FNS_ITDEAD") //N3_SUBCCDE - Depreciacao Acumulada
	SUBCDESCTB := oGRIDFNS:GetValue("FNS_ITCDED") //N3_SUBCDES - Correcao Depreciacao
	// SUBCDESCTA := oGRIDFNS:GetValue("FNS_ITDESD") //N3_SUBCTA  - Despesa

	//-----------------
	// Classe de Valor
	//-----------------
	CLVLCONCTB := oGRIDFNS:GetValue("FNS_CVBEMD") //N3_CLVLCON - Bem
	CLVLCORCTB := oGRIDFNS:GetValue("FNS_CVCORD") //N3_CLVLCOR - Correção Monetaria
	CLVLDEPCTB := oGRIDFNS:GetValue("FNS_CVDEPD") //N3_CLVLDEP - Despesa de Depreciacao
	CLVLCDECTB := oGRIDFNS:GetValue("FNS_CVCDED") //N3_CLVLCDE - Depreciacao Acumulada
	CLVLDESCTB := oGRIDFNS:GetValue("FNS_CVDESD") //N3_CLVLDES - Correcao Depreciacao
	// CLVLDDECTB := oGRIDFNS:GetValue("FNS_CVDSPD") //N3_CLVLDES - Despesa

Return

/*{Protheus.doc} Af060GrvOrc
Transfere os bens de provisao filhos do bem de orcamento
@author Mayara Alves
@since 08/06/2015
@version P12
@param oModel		- modelo
@param cIDMOV		- Id do movimento
@param cCodRel	- Codigo do relacionamento
@param cSeq		- Sequencia
@param cLocDes	- Local de Destino
@param cCodBase	- Codigo base
@param cItem		- Item
@param lAutomatico-Lote
@return aRecnos, Array   , Array com os RENCNOS da SN3
*/
Function Af060GrvOrc(oModel, cIDMOV, cCodRel, cSeq, cLocDes, cCodBase, cItem,lAutomatico)
	Local aRecnoSN3	:= {}
	Local nX		:= 0
	Local aArea		:= GetArea()
	Local oModel	:= FwModelActive()

	//Seleciono os registros filho do bem classificado como Orcamento
	aRecnoSN3 := Af060SelOrc(cCodBase,cItem)

	//Transfiro os Filhos
	For nX := 1 to Len(aRecnoSN3)

		dbselectArea('SN3')
		SN3->(dbSetOrder(1))
		SN3->(DBGoTo(aRecnoSn3[nX]))

		Af060VarCtb(oModel)
		If lAutomatico
			//A função Af060GrvFil virou AF060Grava
			AF060Grava(oModel, @cIDMOV, cCodRel, cSeq, cLocDes, cBaseSup, cItemSuP, lAutomatico)
		Else
			//A função Af060GrvFil virou AF060Grava
			AF060Grava(oModel, @cIDMOV, cCodRel, cSeq, cLocDes, cCodBase, cItem, lAutomatico)
		Endif

	Next

	RestArea(aArea)

Return

/*{Protheus.doc} AFA060BX
Chama o execauto do ATF036
@author Mayara Alves
@since 08/06/2015
@version P12
@param oModel		- modelo
@param cIDMOV		- Id do movimento
@param cCodRel	- Codigo do relacionamento
@param cSeq		- Sequencia
@param cLocDes	- Local de Destino
@param cCodBase	- Codigo base
@param cItem		- Item
@param lAutomatico-Lote
@return aRecnos, Array   , Array com os RENCNOS da SN3
*/
Static Function AFA060BX(oModel)
	Local aArea			:= GetArea()
	Local aAreaSN1		:= SN1->(GetArea())
	Local aAreaSN3		:= SN3->(GetArea())
	Local xAtivo		:= {}
	Local xCab			:= {}
	Local aParam		:= {}
	Local lRet			:= .T.
	Local oModelFNR 	:= oModel:GetModel('GridFNR')
	Local cATFDPBX		:= SUPERGETMV('MV_ATFDPBX')
	Local cPropbx		:= ""
	Local cFilOri		:= oModelFNR:GetValue("FNR_FILORI")
	Local nQtdOri		:= oModelFNR:GetValue("FNR_QTDORI")
	Local nQtdDes		:= oModelFNR:GetValue("FNR_QTDDES")
	Local nPerTransf	:= (nQtdDes/nQtdOri)*100
	local aErro			:= {}
	Local cMsg			:= ""
	Local nX			:= 0
	Local cFileLog		:= ""
	Local cNota			:= ""
	Local cSerie		:= ""

	Private lMsErroAuto	:= .F.

	Do Case
		Case cATFDPBX == "1"
			cPropbx := "1"
		Case cATFDPBX == "3"
			cPropbx := "3"
		Otherwise
			//Quando for mês cheio = '2' o cálculo deprec. ocorre pela ATFA050 no destino.
			cPropbx := "0"
	End Case

	SaveInter()

	cFilAnt := cFilOri

	SN3->(DbSetOrder(1))
	SN1->(DbSetOrder(1))

	aAdd( aParam, {"MV_PAR01", 2} )
	aAdd( aParam, {"MV_PAR02", 2} )
	aAdd( aParam, {"MV_PAR03", 2} )

	If SN3->(DBSeek(xFilial("SN3",cFilOri)+oModelFNR:GetValue("FNR_CBAORI")+oModelFNR:GetValue("FNR_ITEORI")))

		If SN1->(DBSeek( xFilial("SN1",cFilOri) + SN3->N3_CBASE + SN3->N3_ITEM ))

			//-------------------------------------------------------------------
			// So altera o status caso a quantidade total do bem for transferida
			//-------------------------------------------------------------------
			If nPerTransf == 100
				If !Empty(SN1->N1_FILIAL)
					RecLock("SN1",.F.)
					SN1->N1_STATUS := '4' // Transferencia entre filiais
					MsUnLock()
				Else
					RecLock("SN1",.F.)
					SN1->N1_STATUS := '1' // Transferencia entre filiais
					MsUnLock()
				EndIf
			EndIf

			dDinDepr := SN3->N3_DINDEPR
			// Posicionar e efetuar a baixa.

			dBaixa030 := oModelFNR:GetValue("FNR_DATA")
			cNota  	  := oModelFNR:GetValue("FNR_NOTA")
			cSerie    := oModelFNR:GetValue("FNR_SERIE")

			xCab := {	{"FN6_FILIAL"	,xFilial("SN3",cFilOri)	,NIL},;
						{"FN6_CBASE"	,SN3->N3_CBASE			,NIL},;
						{"FN6_CITEM"	,SN3->N3_ITEM			,NIL},;
						{"FN6_MOTIVO"	,"18"					,NIL},;
						{"FN6_QTDATU"	,SN1->N1_QUANTD			,NIL},;
						{"FN6_BAIXA"	,nPerTransf				,NIL},;
						{"FN6_QTDBX"	,nQtdDes				,NIL},;
						{"FN6_DTBAIX"	,dBaixa030				,NIL},;
						{"FN6_PERCBX"	,nPerTransf				,NIL},;
						{"FN6_FILORI"	,SN3->N3_FILORIG		,NIL},;
						{"FN6_DEPREC"	,cPropbx				,NIL},;
						{"FN6_NUMNF"    ,cNota					,NIL},;
						{"FN6_SERIE"	,cSerie					,NIL}}

			xAtivo := {	{"N3_FILIAL"	, xFilial("SN3")	,NIL},;
						{"N3_CBASE"		, SN3->N3_CBASE		,NIL},;
						{"N3_ITEM"		, SN3->N3_ITEM		,NIL},;
						{"N3_TIPO"		, SN3->N3_TIPO		,NIL},;
						{"N3_BAIXA"		, SN3->N3_BAIXA		,NIL},;
						{"N3_TPSALDO"	, SN3->N3_TPSALDO	,NIL} }

			MsExecAuto({|a,b,c,d|ATFA036(a,b,c,,,d)},xCab,xAtivo,3,aParam)
			If lMsErroAuto
				If IsBlind()

					aErro	:= GetAutoGRLog()
					If Len(aErro) > 0
						For nX := 1 To Len(aErro)
							cMsg += aErro[nX] + CRLF
						Next nX
						If !empty(cMsg)
							ConOut(cMsg)
						Endif
					Else
						cFileLog := NomeAutoLog()
						cMsg 	 :=	MemoRead(cFileLog)
						If !empty(cMsg)
							ConOut(cMsg)
						Endif
					EndIf
				Else
					MostraErro()
				Endif
				lRet := .F.
			Endif

		EndIf
	EndIf

	RestInter()
	RestArea(aAreaSN3)
	RestArea(aAreaSN1)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060AutRot
Função que executa a Rotina da ExecAuto
@author Jose Augusto Ribeiro
@since 17/06/2015
@version P12
@param xAtivo, variável, Com o conteudo da ExecAuto
@param nOpcAuto, numérico, Numero da Opção desejada
@param aParam, array, Array com o conteudo do pergunte
@return lRet, Logico, ${return_description}
*/
Static Function AF060AutRot(xAtivo As Array,nOpcAuto As Numeric,aParam As Array) As Logical

Local aAreaSN3	As Array
Local aAreaSN1	As Array
Local aAreaFNS	As Array
Local aAreaFNR	As Array
Local aAreaFN9	As Array
Local aArea		As Array
Local oModel	As Object
Local oModlFNS	As Object
Local oModlFNR	As Object
Local oModlFN9	As Object
Local nFNR		As Numeric
Local nFNS		As Numeric
Local aCampsFNR	As Array
Local oHash		As Object
Local aRet		As Array
Local lEncontro	As Logical
Local lRet		As Logical
Local nX		As Numeric
Local cVarParam	As Character
Local nPosField As Numeric

Local lCmpDesp 		As Logical
Local nQtdVol       As Numeric
Local nM            As Numeric
Local cMRCVLMSF2	As Character
Local cMVATFCPMN    As Character
Local aCpoMarSF2    As Array
Local aCpoMarFN9    As Array
Local aCpoMarFNR    As Array
Local cCpoMarSF2    As Character
Local cCpoNumSF2    As Character
Local cCpoMarFN9    As Character
Local cCpoNumFN9    As Character
Local cCpoMarFNR    As Character
Local cCpoNumFNR    As Character
Local nContEnt 		As Numeric

Private aArrAut 	:= aClone(xAtivo)
Private aFieldsMNT  As Array

aAreaSN3	  := SN3->(GetArea())
aAreaSN1	  := SN1->(GetArea())
aAreaFNS	  := FNS->(GetArea())
aAreaFNR	  := FNR->(GetArea())
aAreaFN9	  := FN9->(GetArea())
aArea		  := GetArea()
oModel		  := FwLoadModel("ATFA060")
oModlFNS	  := oModel:GetModel("GridFNS")
oModlFNR	  := oModel:GetModel("GridFNR")
oModlFN9	  := oModel:GetModel("FieldFN9")
nFNR		  := 0
nFNS		  := 0
aCampsFNR	  := {}
oHash		  := tHashMap():New()//Cria o Objeto do Hash Map
aRet		  := {}
lEncontro	  := .T.
lRet		  := .T.
nX			  := 0
cVarParam	  := ""
nPosField 	  := 0
lCmpDesp 	  := FNS->(FieldPos("FNS_ITDESD")) > 0 // campo item despesa e classe de valor despesa no mesmo pacote 012450
nQtdVol       := QTDVOLNF()
nM            := 0
cMRCVLMSF2	  := AllTrim(SuperGetMV("MV_MRCVLM2",, ""))
cMVATFCPMN    := AllTrim(SuperGetMV('MV_ATFCPMN',, ''))
aCpoMarSF2    := {}
aCpoMarFN9    := {}
aCpoMarFNR    := {}
cCpoMarSF2    := ''
cCpoNumSF2    := ''
cCpoMarFN9    := ''
cCpoNumFN9    := ''
cCpoMarFNR    := ''
cCpoNumFNR    := ''
nContEnt 	  := 0

	If !Empty(cMRCVLMSF2)
		aCpoMarSF2 := StrTokArr2(cMRCVLMSF2, ";", .T.)
	EndIf

	If Len(aCpoMarSF2) >= 2
		cCpoMarSF2 := AllTrim(aCpoMarSF2[1])
		cCpoNumSF2 := AllTrim(aCpoMarSF2[2])
	EndIf

	If !Empty(cMVATFCPMN)
		aCpoMarFN9 := StrTokArr2(cMVATFCPMN, ";", .T.)
	EndIf

	If Len(aCpoMarFN9) >= 4
		cCpoMarFN9 := AllTrim(aCpoMarFN9[3])
		cCpoNumFN9 := AllTrim(aCpoMarFN9[4])
	EndIf

	If !Empty(cMVATFCPMN)
		aCpoMarFNR := StrTokArr2(cMVATFCPMN, ";", .T.)
	EndIf

	If Len(aCpoMarFNR) >= 6
		cCpoMarFNR := AllTrim(aCpoMarFNR[5])
		cCpoNumFNR := AllTrim(aCpoMarFNR[6])
	EndIf

	aAdd(aCampsFNR,{"N1_FILIAL"		,"FNR_FILDES"})
	aAdd(aCampsFNR,{"N3_CBASE"		,"FNR_CBADES"})
	aAdd(aCampsFNR,{"N1_ITEM"		,"FNR_ITEDES"})
	aAdd(aCampsFNR,{"N1_GRUPO"		,"FNR_GRPDES"})
	aAdd(aCampsFNR,{"N1_LOCAL"		,"FNR_LOCDES"})
	aAdd(aCampsFNR,{"N1_TAXAPAD"	,"FNR_TXPADD"})
	aAdd(aCampsFNR,{"N1_NFISCAL"	,"FNR_NOTA"})
	aAdd(aCampsFNR,{"N4_DATA"		,"FNS_DATA"})
	aAdd(aCampsFNR,{"N1_NSERIE"		,"FNR_SERIE"})
	aAdd(aCampsFNR,{"N3_ITEM"		,"FNR_ITEDES"})
	aAdd(aCampsFNR,{"N3_TIPO"		,"FNS_TIPO"})
	aAdd(aCampsFNR,{"N3_CCONTAB"	,"FNS_CONTAD"})
	aAdd(aCampsFNR,{"N3_CCORREC"	,"FNS_CONCOD"})
	aAdd(aCampsFNR,{"N3_CDEPREC"	,"FNS_CONDDD"})
	aAdd(aCampsFNR,{"N3_CCDEPR"		,"FNS_CONDAD"})
	aAdd(aCampsFNR,{"N3_CDESP"		,"FNS_CONCDD"})
	aAdd(aCampsFNR,{"N3_CCUSTO"		,"FNS_CCDESD"})
	aAdd(aCampsFNR,{"N3_CUSTBEM"	,"FNS_CCBEMD"})
	aAdd(aCampsFNR,{"N3_CCCORR"		,"FNS_CCCORD"})
	aAdd(aCampsFNR,{"N3_CCDESP"		,"FNS_CCDDD"})
	aAdd(aCampsFNR,{"N3_CCCDEP"		,"FNS_CCDAD"})
	aAdd(aCampsFNR,{"N3_CCCDES"		,"FNS_CCCDD"})
	aAdd(aCampsFNR,{"N3_SUBCCON"	,"FNS_ITBEMD"})
	aAdd(aCampsFNR,{"N3_SUBCDEP"	,"FNS_ITDEDD"})
	aAdd(aCampsFNR,{"N3_SUBCCDE"	,"FNS_ITDEAD"})
	aAdd(aCampsFNR,{"N3_SUBCDES"	,"FNS_ITCDED"})
	aAdd(aCampsFNR,{"N3_SUBCCOR"	,"FNS_ITCORD"})
	aAdd(aCampsFNR,{"N3_CLVLCON"	,"FNS_CVBEMD"})
	aAdd(aCampsFNR,{"N3_CLVLDEP"	,"FNS_CVDEPD"})
	aAdd(aCampsFNR,{"N3_CLVLCDE"	,"FNS_CVCDED"})
	aAdd(aCampsFNR,{"N3_CLVLDES"	,"FNS_CVDESD"})
	aAdd(aCampsFNR,{"N3_CLVLCOR"	,"FNS_CVCORD"})
	If lCmpDesp
		aAdd(aCampsFNR,{"N3_SUBCTA"		,"FNS_ITDESD"})
		aAdd(aCampsFNR,{"N3_CLVL"		,"FNS_CVDSPD"})
	EndIf

	If Len(__aCTBEnt) > 0 .AND. __lEntAdd//Entidades Adicionais
		For nContEnt := 1 to Len(__aCTBEnt)
			aAdd(aCampsFNR,{"N3_EC"+__aCTBEnt[nContEnt]+"DB"	,"FNS_EC"+__aCTBEnt[nContEnt]+"DD"})
			aAdd(aCampsFNR,{"N3_EC"+__aCTBEnt[nContEnt]+"CR"	,"FNS_EC"+__aCTBEnt[nContEnt]+"CD"})
		Next nContEnt
	EndIf

	aAdd(aCampsFNR,{"N1_QUANTD"		,"FNR_QTDDES"})

	aAdd(aCampsFNR,{"FNR_GERNF"		,"FNR_GERNF"})
	aAdd(aCampsFNR,{"FN9_CLSNF"		,"FNR_CLSNF"})
	aAdd(aCampsFNR,{"FN9_VALNF"		,"FNR_VALNF"})
	aAdd(aCampsFNR,{"FN9_TESSAI"	,"FNR_TESSAI"})
	aAdd(aCampsFNR,{"FN9_TESENT"	,"FNR_TESENT"})
	aAdd(aCampsFNR,{"FN9_ARMAZE"	,"FNR_ARMAZE"})
	aAdd(aCampsFNR,{"FN9_TRANSP"	,"FNR_TRANSP"})
	aAdd(aCampsFNR,{"FN9_TPFRET"	,"FNR_TPFRET"})
	aAdd(aCampsFNR,{"FN9_PESOL"		,"FNR_PESOL"})
	aAdd(aCampsFNR,{"FN9_PBRUTO"	,"FNR_PBRUTO"})

	For nM := 1 To nQtdVol
		If SF2->(ColumnPos("F2_VOLUME" + AllTrim(Str(nM)))) > 0 .And. oModlFN9:HasField("FN9_VOLUM" + AllTrim(Str(nM))) .And. FNR->(ColumnPos("FNR_VOLUM" + AllTrim(Str(nM)))) > 0
			aAdd(aCampsFNR,{"FN9_VOLUM" + AllTrim(Str(nM))	,"FNR_VOLUM" + AllTrim(Str(nM))})
		EndIf
		If SF2->(ColumnPos("F2_ESPECI" + AllTrim(Str(nM)))) > 0 .And. oModlFN9:HasField("FN9_ESPEC" + AllTrim(Str(nM))) .And. FNR->(ColumnPos("FNR_ESPEC" + AllTrim(Str(nM)))) > 0
			aAdd(aCampsFNR,{"FN9_ESPEC" + AllTrim(Str(nM))	,"FNR_ESPEC" + AllTrim(Str(nM))})
		EndIf
		If SF2->(ColumnPos("F2_VEICUL" + AllTrim(Str(nM)))) > 0 .And. oModlFN9:HasField("FN9_VEICU" + AllTrim(Str(nM))) .And. FNR->(ColumnPos("FNR_VEICU" + AllTrim(Str(nM)))) > 0
			aAdd(aCampsFNR,{"FN9_VEICU" + AllTrim(Str(nM))	,"FNR_VEICU" + AllTrim(Str(nM))})
		EndIf
		If SF2->(ColumnPos(cCpoMarSF2 + AllTrim(Str(nM)))) > 0 .And. !Empty(cCpoMarFN9) .And. oModlFN9:HasField(cCpoMarFN9 + AllTrim(Str(nM))) .And. FNR->(ColumnPos(cCpoMarFNR + AllTrim(Str(nM)))) > 0
			aAdd(aCampsFNR,{cCpoMarFN9 + AllTrim(Str(nM))	,cCpoMarFNR + AllTrim(Str(nM))})
		EndIf
		If SF2->(ColumnPos(cCpoNumSF2 + AllTrim(Str(nM)))) > 0 .And. !Empty(cCpoNumFN9) .And. oModlFN9:HasField(cCpoNumFN9 + AllTrim(Str(nM))) .And. FNR->(ColumnPos(cCpoNumFNR + AllTrim(Str(nM)))) > 0
			aAdd(aCampsFNR,{cCpoNumFN9 + AllTrim(Str(nM))	,cCpoNumFNR + AllTrim(Str(nM))})
		EndIf
	Next nM

	If(nOpcAuto == 3 .Or. nOpcAuto == 4 .or. nOpcAuto == 7)

		If GetMV( 'MV_NGMNTAT' ) $ '1#3'

			// Campos necessários para transferencia de centro de custo de um bem
			aFieldsMNT := {}

			nPosField  := aScan( xAtivo, { |x| x[ 1 ] == 'TPN_CTRAB' } )

			If nPosField > 0
				aAdd( aFieldsMNT, { xAtivo[ nPosField, 2 ] } )
			EndIf

			nPosField  := aScan( xAtivo, { |x| x[ 1 ] == 'TPN_POSCON' } )

			If nPosField > 0
				aAdd( aFieldsMNT, { xAtivo[ nPosField, 2 ] } )
			EndIf

			nPosField  := aScan( xAtivo, { |x| x[ 1 ] == 'TPN_POSCO2' } )

			If nPosField > 0
				aAdd( aFieldsMNT, { xAtivo[ nPosField, 2 ] } )
			EndIf

		EndIf
		//---------------------
		// Atribuicao do Pergunte
		//---------------------
		Pergunte("AFA060", .F.)

		MV_PAR01 := If(CTBINTRAN(0,.F.),MV_PAR01,2)
		MV_PAR02 := 2

		If(aParamAuto != Nil)
			For nX := 1 to Len(aParamAuto)
				cVarParam := Alltrim(Upper(aParamAuto[nX][1]))
				If("MV_PAR" $ cVarParam)
					&(cVarParam) := aParamAuto[nX][2]
				EndIf
			Next nX
		EndIf

		//-----------------
		// Carga do modelo
		//-----------------
		oModel:SetOperation(MODEL_OPERATION_UPDATE)
		If(oModel:Activate())
			//na transferencia, posiciona no item correto do model FNS, caso tenha sido enviado o campo N3_TIPO no execauto
			If nOpcAuto == 4 .And. (nPosTipo := aScan(xAtivo, {|x|  x[1] == "N3_TIPO"})) > 0
				oModlFNS:SeekLine({{"FNS_TIPO", xAtivo[nPosTipo][2]}})
			EndIf
			oHash :=  AToHM(aCampsFNR,1)//Converto o Vetor no Objeto Hash e indico qual sera a chave para a busca
			For nFNR := 1 To Len(xAtivo)
				lEncontro := HMGet(oHash,xAtivo[nFnr][1],@aRet)//Faz a busca da chave dentro do Objeto, ele vai retornar o logico e o vetor com a linha encontrada
				If(lEncontro)
					If(!Empty(xAtivo[nFnr][2]))
						If("N3_" $ xAtivo[nFNR][1])
							If("FNR_" $ aRet[1][2])

								oModlFNR:SetValue(aRet[1][2],xAtivo[nFNR][2])
							Else

								If FwIsInCallStack("ATFA126") .And. nPosTipo == 0
									For nFNS := 1 To oModlFNS:Length(.T.)
										oModlFNS:GoLine(nFNS)
										oModlFNS:SetValue(aRet[1][2],xAtivo[nFNR][2])
									Next nFNS
									oModlFNS:GoLine(1)
								Else
									oModlFNS:SetValue(aRet[1][2],xAtivo[nFNR][2])
								EndIf

							EndIf
						ElseIf("N1_" $ xAtivo[nFNR][1])
							If aRet[1][2] == "FNR_SERIE" .And. ( FwIsInCallStack("ATFA126") .or. FWIsInCallStack('WFSTAPROV')  .or. lA060robo )
								oModlFNR:LoadValue(aRet[1][2],xAtivo[nFNR][2])
							Else
								oModlFNR:SetValue(aRet[1][2],xAtivo[nFNR][2])
							EndIf
							If xAtivo[nFNR][1] $ "N1_NFISCAL" .and. !(Empty(xAtivo[nFNR][2])) .and. FwIsInCallStack("ATFA126")
								oModlFNR:SetValue("FNR_GERNF","1")
							Endif

							If FwIsInCallStack("MNTA550")
								If SuperGetMV("MV_NGMNTAT") $ "1#3" .and. ( xAtivo[nFNR][1] $ "N1_NSERIE" .or. xAtivo[nFNR][1] $ "N1_NFISCAL" )	.and. !(Empty(xAtivo[nFNR][2]))
									oModlFNR:SetValue("FNR_GERNF","1")
								EndIf
							EndIf
						ElseIf("N4_" $ xAtivo[nFNR][1])

							oModlFNS:LoadValue(aRet[1][2],xAtivo[nFNR][2])
							oModlFNR:LoadValue("FNR_DATA",xAtivo[nFNR][2])
							oModlFN9:LoadValue("FN9_DATA",xAtivo[nFNR][2])

						ElseIf(xAtivo[nFNR][1] == "FNR_GERNF")
							If lA060robo
								oModlFNR:LoadValue(aRet[1][2],xAtivo[nFNR][2])
							Else
								oModlFNR:SetValue(xAtivo[nFNR][1],xAtivo[nFNR][2])
							EndIF
						ElseIf("FN9_" $ xAtivo[nFNR][1])
							oModlFNR:SetValue(aRet[1][2],xAtivo[nFNR][2])
						EndIf
					EndIf
				EndIf
			Next nFNR
		EndIf
		If(oModel:VldData())
			If!(oModel:CommitData())
				cLog := STR0213 //"Processo não realizado, necessário verificar as inconsistências informadas."
				lMsErroAuto := .T.
				AutoGRLog(cLog)
				lRet := .F.
			EndIf
		Else
			cLog := oModel:GetErrorMessage()[3]
			cLog += '--' + oModel:GetErrorMessage()[5]
			cLog += '--' + oModel:GetErrorMessage()[6]
			cLog += '--' + oModel:GetErrorMessage()[7]
			lMsErroAuto := .T.
			AutoGRLog(cLog)
			lRet := .F.
		EndIf
		oModel:DeActivate()
		oModel:Destroy()
		oModel := Nil
		oHash:Clean()

	EndIf
	RestArea(aAreaSN3)
	RestArea(aAreaSN1)
	RestArea(aAreaFN9)
	RestArea(aAreaFNR)
	RestArea(aAreaFNS)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060VldNF
Valida as premissas para geração da NF
@author Totvs
@since 18/06/2015
@version P12
@param lGerNF		,Logico, parametro para saber se valida a nota
@return lRet		,Logico, .T. para validado e .F. para nao validado
*/
Function AF060VldNF()
	Local aArea		:= GetArea()
	Local lRet		:= .T.
	Local cProduto	:= ""
	Local cFilDes	:= ""
	Local cBase		:= ""
	Local cItem		:= ""
	Local cCampo	:= ReadVar()
	Local lFN9		:= "FN9" $ cCampo
	Local lFNR		:=	"FNR" $ cCampo
	Local lGerNF	:= &(cCampo) == "1"

	If lGerNF
		//----------------------------------------------------
		// Verifica se a filial origem possui CNPJ informado
		//----------------------------------------------------
		If lRet .And. Empty(SM0->M0_CGC)
			lRet := .F.
			Help( "", 1, "AF060VldNF", , STR0135,1, 0 ) //"A filial de origem não possui CNPJ cadastrado, impossibilitando a geração da NF."
		EndIf

		//-------------------------------------------------------
		// Valida se a de filial origem e destino sao diferentes
		//-------------------------------------------------------
		If lRet
			If lFN9 .And. cFilAnt == M->FN9_FILDES
				lRet := .F.
			ElseIf lFNR .And. FWFldGet('FNR_FILORI') == FWFldGet('FNR_FILDES')
				lRet := .F.
			EndIf

			If !lRet
				lRet := .F.
				Help( "", 1, "AF060VldNF", ,STR0155,1, 0 ) //"A filial de destino deve ser alterada para geracao da Nota Fiscal"
			EndIf

		EndIf
		If lRet

			cBase := FWFldGet('FNR_CBAORI')
			cItem := FWFldGet('FNR_ITEORI')

			//---------------------------------------------------
			// Verifica se o ativo esta relacionado a um produto
			//---------------------------------------------------
			If lRet .And. Empty(cProduto := GetAdvFVal("SN1","N1_PRODUTO",XFilial("SN1")+cBase+cItem,1,"") )
				lRet := .F.
				Help( "", 1, "AF060VldNF", , STR0136,1, 0 )//"O ativo não possui produto relacionado no seu cadastro, impossibilitando a geração da NF."
			EndIf

			//-----------------------------------------------------------------------
			// Verifica se o produto relacionado ao ativo existe na filial de origem
			//-----------------------------------------------------------------------
			If lRet .And. Empty(GetAdvFVal("SB1","B1_COD",XFilial("SB1")+cProduto,1,""))
				lRet := .F.
				Help( "", 1, "AF060VldNF", , STR0137,1, 0 ) //"O produto relacionado ao ativo não existe na filial de origem, impossibilitando a geração da NF."
			EndIf

			//-----------------------------------------------------------------------
			// Verifica se o produto relacionado ao ativo existe na filial de destino
			//-----------------------------------------------------------------------
			If lRet
				cFilDes := FWFldGet('FNR_FILDES')
				If Empty(GetAdvFVal("SB1","B1_COD",XFilial("SB1",cFilDes)+cProduto,1,""))
					lRet := .F.
					Help( "", 1, "AF060VldNF", , STR0138,1, 0 )//"O produto relacionado ao ativo não existe na filial de destino, impossibilitando a geração da NF."
				EndIf
			EndIf

		EndIf
	EndIf

	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060VTES
Valida a TES de entrada na filial destino
@author Totvs
@since 18/06/2015
@version P12
@return lRet		,Logico, .T. para validado e .F. para nao validado
*/
Function AF060VTES()
	Local aArea		:= GetArea()
	Local aAreaSF4	:= SF4->(GetArea())
	Local lRet		:= .T.
	Local cCampo	:= ReadVar()
	Local cTes		:= &(cCampo)
	Local cFilDes	:= If("FN9"$cCampo,M->FN9_FILDES,FWFldGet("FNR_FILDES"))

	//-----------------------------------------------
	// Verifica se a TES existe na filial de destino
	//-----------------------------------------------
	If !Empty(cTes)
		If "TESSAI" $ cCampo
			DbSelectArea("SF4")
			SF4->(DbSetOrder(1))
			If SF4->(DbSeek(XFilial("SF4")+cTes))

				If lRet .And. SF4->F4_DUPLIC != "N"
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0140,1,0) //"A TES de saida informada esta com a propriedade de atualização de duplicata  como 'SIM'."

				ElseIf lRet .And. SF4->F4_ATUATF != "N"
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0141,1,0)//"A TES de saida informada esta com a propriedade de atualização de atualiza ativo fixo  como 'SIM'."

				ElseIf lRet .And. SF4->F4_TIPO $ 'E'
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0142,1,0) //"A TES informada é de entrada, por favor informar a TES de saída."

				EndIf
			Else
				lRet := .F.
				Help(" ",1, "AF060VTES",,STR0143,1,0) //"A TES de saida informada não existe na filial de origem."
			EndIf

		ElseIf "TESENT" $ cCampo
			DbSelectArea("SF4")
			SF4->(DbSetOrder(1))
			If SF4->(DbSeek(XFilial("SF4",cFilDes)+cTes))

				If lRet .And. SF4->F4_DUPLIC != "N"
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0145,1,0) //"A TES de entrada informada esta com a propriedade de atualização de duplicata  como SIM"

				ElseIf lRet .And.SF4->F4_ATUATF != "N"
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0146,1,0) //"A TES de entrada informada esta com a propriedade de atualização de atualiza ativo fixo  como SIM"

				ElseIf lRet .And. Val(SF4->F4_CODIGO) >= 501
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0147,1,0) //"A TES informada é de saída, por favor informar a TES de entrada."

				EndIf

			Else
				lRet := .F.
				Help(" ",1, "AF060VTES",,STR0148,1,0) //"A TES de entrada informada não existe na filial de destino."
			EndIf

		EndIf
	Endif

	RestArea(aAreaSF4)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AFA060NFS
Gera a Nota Fiscal de Saida na filial de origem
@author TOTVS
@since 18/06/2015
@version P12
@return cNotaFeita,Caracter, Numero da Nota Criada
*/
Static Function AFA060NFS(oModel)
	Local aArea			:= GetArea()
	Local aAreaSA1		:= SA1->(GetArea())
	Local aAreaSB1		:= SB1->(GetArea())
	Local aAreaSF4		:= SF4->(GetArea())
	Local cFilDes		:= oModel:GetValue("GridFNR","FNR_FILDES")
	Local cSerie		:= oModel:GetValue("GridFNR","FNR_SERIE")
	Local cTESSaida		:= oModel:GetValue("GridFNR","FNR_TESSAI")
	Local cCNPJ			:= GetAdvFVal("SM0","M0_CGC",cEmpAnt + cFilDes)
	Local cInscEstad	:= GetAdvFVal("SM0","M0_INSC",cEmpAnt + cFilDes)
	Local aCliente		:= AF60CNPJCLI(cCNPJ, cInscEstad) //VALIDA QUAL CLIENTE CORRETO - FAZER UM WHILE NOS CNPJS COMPARANDO A INSCRICAO SE FOR IGUAL A DA SM0_INSC
	Local cCliente		:= IIF(!Empty(aCliente), aCliente[1], GetAdvFVal("SA1","A1_COD",XFilial("SA1")+cCNPJ,3) ) //A1_FILIAL+A1_CGC
	Local cLoja			:= IIF(!Empty(aCliente), aCliente[2], GetAdvFVal("SA1","A1_LOJA",XFilial("SA1")+cCNPJ,3) )  //A1_FILIAL+A1_CGC
	Local cBase			:= oModel:GetValue("GridFNR","FNR_CBAORI")
	Local cItem			:= oModel:GetValue("GridFNR","FNR_ITEORI")
	Local cProduto		:= GetAdvFVal("SN1","N1_PRODUTO",XFilial("SN1")+cBase+cItem,1) //N1_FILIAL+N1_CBASE+N1_ITEM
	Local nQtdBx		:= oModel:GetValue("GridFNR","FNR_QTDDES")
	Local nValNF		:= oModel:GetValue("GridFNR","FNR_VALNF")
	Local dBaixa		:= oModel:GetValue('FieldFN9','FN9_DATA')
	Local cContaO		:= AtfRetCta(oModel,"O")
	Local cNotaFeita	:= ""
	Local aCabec		:= {}
	Local aItens		:= {}
	Local nI			:= 0
	Local aStruSD2		:= {}
	Local aStruSF2		:= {}
	Local aSF2RecNo		:= {}
	Local lContabOn		:= .T.
	Local lMostraLan	:= .T.
	Local lAglutLan		:= .T.
	Local lRet			:= .T.
    Local cUFOrig		:= ""
    Local cUFDest		:= ""
	Local cTransp		:= ""
	Local cTpFrete		:= ""
	Local nPesoLiq		:= 0
	Local nPesoBru		:= 0
	Local aVol			:= {} // Volume.
	Local aEsp			:= {} // Especie.
	Local aMarca		:= {} // Marca.
	Local aNumer		:= {} // Numeração.
	Local aVeicul		:= {} // Veiculo.
	Local nM			:= 0
	Local cMRCVLMSF2	:= AllTrim(SuperGetMV("MV_MRCVLM2",, ""))
	Local cMVATFCPMN    := AllTrim(SuperGetMV('MV_ATFCPMN',, ''))
	Local aCpoMarSF2    := {}
	Local aCpoMarFNR    := {}
	Local cCpoMarSF2    := ''
	Local cCpoNumSF2    := ''
	Local cCpoMarFNR    := ''
	Local cCpoNumFNR    := ''
	Local nQtdVol       := QTDVOLNF()
	Local nPosSF2		:= 0

	Local cEspecie 		as Character
	Local lVldNewInv	as Logical

	cEspecie			:= ""
	lVldNewInv			:= If(FindFunction("ATFVldNInv"),ATFVldNInv(),.F.)

	cEspecie := IF(lVldNewInv,oModel:GetValue("GridFNR","FNR_ESPECI"),cEspecie)

	SaveInter()

	Pergunte("AFA060",.F.)

	//Variaveis para contabilizacao
	lContabOn	:= MV_PAR01 == 1
	lMostraLan	:= MV_PAR02 == 1
	lAglutLan	:= MV_PAR03 == 1

	If QtdComp( nValNF, .T. ) == QtdComp( 0, .T. )
		nValNF := 1
	EndIf

	If !Empty(cMRCVLMSF2)
		aCpoMarSF2 := StrTokArr2(cMRCVLMSF2, ";", .T.)
	EndIf

	If Len(aCpoMarSF2) >= 2
		cCpoMarSF2 := AllTrim(aCpoMarSF2[1])
		cCpoNumSF2 := AllTrim(aCpoMarSF2[2])
	EndIf

	If !Empty(cMVATFCPMN)
		aCpoMarFNR := StrTokArr2(cMVATFCPMN, ";", .T.)
	EndIf

	If Len(aCpoMarFNR) >= 6
		cCpoMarFNR := AllTrim(aCpoMarFNR[5])
		cCpoNumFNR := AllTrim(aCpoMarFNR[6])
	EndIf

	If oModel:HasField('GridFNR', 'FNR_TRANSP') // Código da transportadora.
		cTransp := oModel:GetValue('GridFNR', 'FNR_TRANSP') // Código da transportadora.
	EndIf
	If oModel:HasField('GridFNR', 'FNR_TPFRET') // Tipo de frete.
		cTpFrete := oModel:GetValue('GridFNR', 'FNR_TPFRET') // Tipo de frete.
	EndIf
	If oModel:HasField('GridFNR', 'FNR_PESOL') // Peso liquido.
		nPesoLiq := oModel:GetValue('GridFNR', 'FNR_PESOL') // Peso liquido.
	EndIf
	If oModel:HasField('GridFNR', 'FNR_PBRUTO') // Peso bruto.
		nPesoBru := oModel:GetValue('GridFNR', 'FNR_PBRUTO') // Peso bruto.
	EndIf

	// Tratamento para até 9 volumes.
	For nM := 1 To nQtdVol
		If SF2->(ColumnPos("F2_VOLUME" + AllTrim(Str(nM)))) > 0 .And. FNR->(ColumnPos("FNR_VOLUM" + AllTrim(Str(nM)))) > 0
			AAdd(aVol, oModel:GetValue('GridFNR', 'FNR_VOLUM' + AllTrim(Str(nM))))
		EndIf
		If SF2->(ColumnPos("F2_ESPECI" + AllTrim(Str(nM)))) > 0 .And. FNR->(ColumnPos("FNR_ESPEC" + AllTrim(Str(nM)))) > 0
			AAdd(aEsp, oModel:GetValue('GridFNR', 'FNR_ESPEC' + AllTrim(Str(nM))))
		EndIf
		If SF2->(ColumnPos(cCpoMarSF2 + AllTrim(Str(nM)))) > 0 .And. !Empty(cCpoMarFNR) .And. FNR->(ColumnPos(cCpoMarFNR + AllTrim(Str(nM)))) > 0
			AAdd(aMarca, oModel:GetValue('GridFNR', cCpoMarFNR + AllTrim(Str(nM))))
		EndIf
		If SF2->(ColumnPos(cCpoNumSF2 + AllTrim(Str(nM)))) > 0 .And. !Empty(cCpoNumFNR) .And. FNR->(ColumnPos(cCpoNumFNR + AllTrim(Str(nM)))) > 0
			AAdd(aNumer, oModel:GetValue('GridFNR', cCpoNumFNR + AllTrim(Str(nM))))
		EndIf
		If SF2->(ColumnPos("F2_VEICUL" + AllTrim(Str(nM)))) > 0 .And. FNR->(ColumnPos("FNR_VEICU" + AllTrim(Str(nM)))) > 0
			AAdd(aVeicul, oModel:GetValue('GridFNR', 'FNR_VEICU' + AllTrim(Str(nM))))
		EndIf
	Next nM

	aStruSD2 := SD2->(dbStruct())
	aStruSF2 := SF2->(dbStruct())
	aItens := {{}}
	aCabec := {}

    //Inicializa variáveis fiscais do cliente
	MaFisIni(cCliente, cLoja, "C", "N", SA1->A1_TIPO,,,,, "MATA461",,,,,, cCliente, cLoja)
	cUFOrig := MaFisRet(,"NF_UFORIGEM")
	cUFDest := MaFisRet(,"NF_UFDEST")
	MaFisEnd()

	SA1->(MsSeek(xFilial("SA1") + cCliente + cLoja))
	For nI := 1 to len(aStruSF2)
		Do Case
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_FILIAL'
			Aadd(aCabec,xFilial("SF2"))					// Filial
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_CLIENTE'
			Aadd(aCabec,cCliente)						// Cliente
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_LOJA'
			Aadd(aCabec,cLoja)							// Loja
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_CLIENT'
			Aadd(aCabec,cCliente)						// Cliente
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_LOJENT'
			Aadd(aCabec,cLoja)							// Loja
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_TIPO'
			Aadd(aCabec,"N")							// Tipo (Normal)
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_TIPOCLI'

			//quando o imposto for IR ou INSS utilizamos A1_PESSOA
			//quando o importo for ICMS ( ATIVO FIXO ) utilizamos A1_TIPO

			Aadd(aCabec,SA1->A1_TIPO)					// Tipo de cliente (F=Pessoa Fisica; J=Pessoa Juridica)
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_EMISSAO'
			Aadd(aCabec,dBaixa)							// Data de emissao
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_HORA'
			Aadd(aCabec,SubStr(Time(),1,5))				// Hora do processamento
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_EST'
			Aadd(aCabec,SA1->A1_EST)					// Estado
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_NEXTDOC'
			Aadd(aCabec,"      ")						// Proximo docto
        Case ALLTRIM(aStruSF2[nI,1]) == 'F2_UFORIG'
			Aadd(aCabec,cUFOrig)						    	// UF Origem
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_UFDEST'
			Aadd(aCabec,cUFDest)								// UF Destino
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_DTLANC'		// Flag de Contabiliza??o
			Aadd(aCabec,StoD(""))
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_TRANSP' .And. FNR->(ColumnPos('FNR_TRANSP')) > 0
			Aadd(aCabec,cTransp)								// Código da transportadora
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_TPFRETE' .And. FNR->(ColumnPos('FNR_TPFRET')) > 0
			Aadd(aCabec,cTpFrete)								// Tipo de frete
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_PLIQUI' .And. FNR->(ColumnPos('FNR_PESOL')) > 0
			Aadd(aCabec,nPesoLiq)								// Peso liquido
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_PBRUTO' .And. FNR->(ColumnPos('FNR_PBRUTO')) > 0
			Aadd(aCabec,nPesoBru)								// Peso bruto
		Otherwise
			Aadd( aCabec, CriaVar(aStruSF2[nI,1]) )
		EndCase
	Next

	For nM := 1 To nQtdVol // Tratamento para até 9 volumes.
		nPosSF2 := AScan(aStruSF2, {|c| AllTrim(c[1]) == 'F2_VOLUME' + AllTrim(Str(nM)) })
		If nPosSF2 > 0 .And. Len(aVol) > 0 .And. FNR->(ColumnPos('FNR_VOLUM' + AllTrim(Str(nM)))) > 0
			aCabec[nPosSF2] := aVol[nM]
		EndIf

		nPosSF2 := AScan(aStruSF2, {|c| AllTrim(c[1]) == 'F2_ESPECI' + AllTrim(Str(nM)) })
		If nPosSF2 > 0 .And. Len(aEsp) > 0 .And. FNR->(ColumnPos('FNR_ESPEC' + AllTrim(Str(nM)))) > 0
			aCabec[nPosSF2] := aEsp[nM]
		EndIf

		nPosSF2 := AScan(aStruSF2, {|c| AllTrim(c[1]) == cCpoMarSF2 + AllTrim(Str(nM)) })
		If nPosSF2 > 0 .And. Len(aMarca) > 0 .And. FNR->(ColumnPos(cCpoMarFNR + AllTrim(Str(nM)))) > 0
			aCabec[nPosSF2] := aMarca[nM]
		EndIf

		nPosSF2 := AScan(aStruSF2, {|c| AllTrim(c[1]) == cCpoNumSF2 + AllTrim(Str(nM)) })
		If nPosSF2 > 0 .And. Len(aNumer) > 0 .And. FNR->(ColumnPos(cCpoNumFNR + AllTrim(Str(nM)))) > 0
			aCabec[nPosSF2] := aNumer[nM]
		EndIf

		nPosSF2 := AScan(aStruSF2, {|c| AllTrim(c[1]) == 'F2_VEICUL' + AllTrim(Str(nM)) })
		If nPosSF2 > 0 .And. Len(aVeicul) > 0 .And. FNR->(ColumnPos('FNR_VEICU' + AllTrim(Str(nM)))) > 0
			aCabec[nPosSF2] := aVeicul[nM]
		EndIf
	Next nM

	SB1->(MsSeek(xFilial("SB1") + cProduto))
	SF4->(MsSeek(xFilial("SF4") + cTESSaida))
	For nI := 1 to Len(aStruSD2)
		Do Case
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_FILIAL'
			Aadd( aItens[1],xFilial("SD2"))						// Filial
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_ITEM'
			Aadd( aItens[1],StrZero(1,TamSX3("D2_ITEM")[1]))	// Item
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_COD'
			Aadd( aItens[1],cProduto)							// Produto
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_UM'
			Aadd( aItens[1],SB1->B1_UM)							// Unidade de medida
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_QUANT'
			Aadd( aItens[1],nQtdBx)								// Quantidade
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_PRCVEN'
			Aadd( aItens[1],nValNF/nQtdBx) 						// Preco unitario
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_TOTAL'
			Aadd( aItens[1], nValNF)			 				// Valor total do item
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_TES'
			Aadd( aItens[1],cTESSaida)							// TES
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_CF'
			Aadd( aItens[1], SF4->F4_CF)						// Codigo Fiscal
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_DESCON'
			Aadd( aItens[1],0)									// Desconto
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_PEDIDO'
			Aadd( aItens[1],' ')								// Pedido de Venda
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_CLIENTE'
			Aadd( aItens[1],cCliente)							// Cliente
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_LOJA'
			Aadd(aItens[1],cLoja)								// Loja
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_TP'
			Aadd(aItens[1],SB1->B1_TIPO)						// Tp Produto
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_EMISSAO'
			Aadd(aItens[1],dBaixa)								// Emissao
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_PRUNIT'
			Aadd( aItens[1], nValNF/nQtdBx)	 					// Valor unitario do item
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_TIPO'
			Aadd(aItens[1],"N")									// Tipo
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_LOCAL'
			Aadd(aItens[1],SB1->B1_LOCPAD)
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_CONTA'
			Aadd(aItens[1],cContaO)
		Otherwise
			Aadd(aItens[1],CriaVar(aStruSD2[nI,1]) ) 				// demais campo da estrutura da tabela SD2 necessarios na criacao da nota fiscal sem pedido de vendas
		EndCase
	Next nI

	aSF2RecNo	:= {0}
	cNotaFeita	:= MaNfs2Nfs(,,cCliente,cLoja,cSerie,lMostraLan,lAglutLan,lContabOn,,,,,,,,,,{|| .T.},aSF2RecNo,aItens,aCabec,.F.,{|| .T.},,{|| .T.},;
							/*cNumNFS*/,/*lVerSE1*/,/*lGTPSub*/,/*cTpOper*/,cEspecie ) 

	If !Empty(cNotaFeita)
		oModel:SetValue("GridFNR","FNR_NOTA",cNotaFeita)
	Else
		lRet := .F.

		oModel:SetErrorMessage("","","","","AFA060NFS",STR0149 + cBase + STR0165 + cItem,"") //"Não foi possível gerar a Nota Fiscal de Saída para o bem: "###"Item: "

	EndIf

	RestInter()

	RestArea(aAreaSF4)
	RestArea(aAreaSB1)
	RestArea(aAreaSA1)
	RestArea(aArea)

Return(lRet)

/*{Protheus.doc} AFA060NFE
Gera a Nota Fiscal de Entrada na filial de destino
@author TOTVS
@type Function
@since 18/06/2015
@version P12
@param cNFSaida, caracter, Numero da Nota Fisca de Saida
*/
Static Function AFA060NFE(oModel As Object,cNFSaida As Character,cFornNE As Character,cLojaNE As Character,cEspNE As Character,dDataNE As Date,cFilF9NE As Character) As Logical
	Local aArea			As Array
	Local oModelFNR		As Object
	Local oModelFN9		As Object
	Local aCabec		As Array
	Local aItens		As Array
	Local cFilOri		As Character
	Local cFilDes		As Character
	Local cTESEntrad	As Character
	Local cBase			As Character
	Local cItem			As Character
	Local dMovimento	As Date
	Local cCNPJCli		As Character
	Local cInscEstad	As Character
	Local aCliente		As Array
	Local cCliente		As Character
	Local cLoja			As Character
	Local cCNPJFor		As Character
	Local cInscFor 		As Character
	Local aFornece		As Array
	Local cFornece		As Character
	Local cLojaFornece	As Character
	Local cEstado		As Character
	Local nClasNF		As Numeric
	Local cEspecie      As Character
	Local cArmazem		As Character
	Local cContaD		As Character
	Local lMostraErro	As Logical
	Local aParam103		As Array
	Local nItem			As Numeric
	Local cSerie		As Character
	Local lRet			As Logical
	Local aAreaSM0		As Array
	Local cForm         As Character
	Local lExistEspec	As Logical
	Local cUfDestCiap	As Character
	Local n				As Numeric
	Local cTransp		As Character
	Local cTpFrete		As Character
	Local nPesoLiq		As Numeric
	Local nPesoBru		As Numeric
	Local aVol			As Array
	Local aEsp			As Array
	Local aMarca		As Array
	Local aNumer		As Array
	Local aVeicul		As Array
	Local nM			As Numeric
	Local cMRCVLMSF1	As Character
	Local cMVATFCPMN    As Character
	Local aCpoMarSF1    As Array
	Local aCpoMarFNR    As Array
	Local cCpoMarSF1    As Character
	Local cCpoNumSF1    As Character
	Local cCpoMarFNR    As Character
	Local cCpoNumFNR    As Character
	Local nQtdVol       As Numeric
	Local cMascara      As Character

	Private lMsErroAuto	:= .F.
	// Variavel utilizada para verificar 1se o numero da nota foi alterado pelo usuario (notas de saida e entrada
	// com formulario proprio).
	Private lMudouNum	:= .F.
	// Variavel utilizada para tratamento especifico para poder de terceiros
	Private l310PODER3	:= .F. //Utilizado no MATA103

	DEFAULT cFornNE	:= ""
	DEFAULT cLojaNE := ""
	DEFAULT cEspNE  := ""
	DEFAULT cFilF9NE:= ""
	DEFAULT dDataNE := StoD("")
	DEFAULT oModel  := NIL
	DEFAULT cNFSaida  := ""

	aArea			:= GetArea()
	oModelFNR		:= oModel:GetModel("GridFNR")
	oModelFN9		:= oModel:GetModel("FieldFN9")
	aCabec		    := {}
	aItens		    := {}
	cFilOri		    := oModel:GetValue("GridFNR","FNR_FILORI")
	cFilDes		    := oModel:GetValue("GridFNR","FNR_FILDES")
	cTESEntrad	    := oModel:GetValue("GridFNR","FNR_TESENT")
	cBase			:= oModel:GetValue("GridFNR","FNR_CBAORI")
	cItem			:= oModel:GetValue("GridFNR","FNR_ITEDES")
	dMovimento	    := oModel:GetValue('FieldFN9','FN9_DATA')
	cCNPJCli		:= GetAdvFVal("SM0","M0_CGC",cEmpAnt + cFilDes)
	cInscEstad	    := GetAdvFVal("SM0","M0_INSC",cEmpAnt + cFilDes)
	aCliente		:= AF60CNPJCLI(cCNPJCli, cInscEstad) //VALIDA QUAL CLIENTE CORRETO - FAZER UM WHILE NOS CNPJS COMPARANDO A INSCRICAO SE FOR IGUAL A DA SM0_INSC
	cCliente		:= IIF(!Empty(aCliente), aCliente[1], GetAdvFVal("SA1","A1_COD",XFilial("SA1")+cCNPJCli,3) ) //A1_FILIAL+A1_CGC
	cLoja			:= IIF(!Empty(aCliente), aCliente[2], GetAdvFVal("SA1","A1_LOJA",XFilial("SA1")+cCNPJCli,3) ) //A1_FILIAL+A1_CGC
	cCNPJFor		:= GetAdvFVal("SM0","M0_CGC",cEmpAnt + cFilOri)
	cInscFor 		:= GetAdvFVal("SM0","M0_INSC",cEmpAnt + cFilOri)
	aFornece		:= AF60CNPJFOR(cFilDes, cCNPJFor, cInscFor) //VALIDA QUAL CLIENTE CORRETO - FAZER UM WHILE NOS CNPJS COMPARANDO A INSCRICAO SE FOR IGUAL A DA SM0_INSC
	nClasNF		    := oModel:GetValue("GridFNR","FNR_CLSNF")
	cEspecie        := ""
	cArmazem		:= ""
	cContaD		    := AtfRetCta(oModel,"D")
	lMostraErro	    := .F.
	aParam103		:= {}
	nItem			:= 0
	cSerie		    := oModel:GetValue("GridFNR","FNR_SERIE")
	lRet			:= .T.
	aAreaSM0		:= SM0->(GetArea())
	cForm           := ""
	lExistEspec	    := ExistBlock("EXISTESPEC")
	cUfDestCiap	    := SuperGetMV("MV_UFDCIAP", .F., "")
	n				:= 0
	cTransp		    := '' // Código da transportadora.
	cTpFrete		:= '' // Tipo de frete.
	nPesoLiq		:= 0 // Peso liquido.
	nPesoBru		:= 0 // Peso bruto.
	aVol			:= {} // Volume.
	aEsp			:= {} // Especie.
	aMarca		    := {} // Marca.
	aNumer		    := {} // Numeração.
	aVeicul		    := {} // Veiculo.
	nM			    := 0
	cMRCVLMSF1	    := AllTrim(SuperGetMV("MV_MRCVLM1",,""))
	cMVATFCPMN      := AllTrim(SuperGetMV('MV_ATFCPMN',, ''))
	aCpoMarSF1      := {}
	aCpoMarFNR      := {}
	cCpoMarSF1      := ''
	cCpoNumSF1      := ''
	cCpoMarFNR      := ''
	cCpoNumFNR      := ''
	nQtdVol         := QTDVOLNF()
	cMascara        := iif(len(cCNPJFor)==14,"@R! NN.NNN.NNN/NNNN-99","@R 999.999.999-99")
	cFornece		:= GetAdvFVal("SA2","A2_COD",XFilial("SA2")+cCNPJCli,3) //A1_FILIAL+A1_CGC
	cLojaFornece	:= GetAdvFVal("SA2","A2_LOJA",XFilial("SA2")+cCNPJCli,3)  //A1_FILIAL+A1_CGC
	cEstado		    := GetAdvFVal("SA2","A2_EST",XFilial("SA2")+cCNPJCli,3)  //A1_FILIAL+A1_CGC

	If !Empty(aFornece)
		cFornece		:= aFornece[1]
		cLojaFornece	:= aFornece[2]
		cEstado		    := aFornece[3]
	ElseIf !IsBlind()
		If !MsgYesno(STR0223+Alltrim(Transform(cCNPJFor,cMascara))+IIf(!Empty(cInscFor),STR0224+cInscFor,"")+STR0225+cFilDes+"."+CRLF+; //Não foi localizado o cadastrado do fornecedor com CNPJ/CPF: ##### , Inscrição Estadual
													STR0226+Alltrim(Transform(cCNPJCli, cMascara))+STR0227+CRLF+; //Deseja continuar e utilizar o fornecedor com CNPJ/CPF: ### 	na NF de entrada?
													STR0228) //Selecione não para cancelar a operação.
			lRet := .F.
			oModel:SetErrorMessage("","","","","AFA060NFE",STR0181 + cBase + STR0165 + cItem,"") //"Não foi possível gerar a Nota Fiscal de Entrada para o bem: "###"Item: "
		EndIf
	EndIf

	If lRet
		If oModelFNR:HasField("FNR_ARMAZE")
			cArmazem := oModel:GetValue("GridFNR","FNR_ARMAZE")
		EndIf

		If oModelFNR:HasField("FNR_ESPECI")
			cEspecie := oModel:GetValue("GridFNR","FNR_ESPECI")
		EndIf

		If !Empty(cMRCVLMSF1)
			aCpoMarSF1 := StrTokArr2(cMRCVLMSF1, ";", .T.)
		EndIf

		If Len(aCpoMarSF1) >= 2
			cCpoMarSF1 := AllTrim(aCpoMarSF1[1])
			cCpoNumSF1 := AllTrim(aCpoMarSF1[2])
		EndIf

		If !Empty(cMVATFCPMN)
			aCpoMarFNR := StrTokArr2(cMVATFCPMN, ";", .T.)
		EndIf

		If Len(aCpoMarFNR) >= 6
			cCpoMarFNR := AllTrim(aCpoMarFNR[5])
			cCpoNumFNR := AllTrim(aCpoMarFNR[6])
		EndIf

		// Dados da transportadora.
		If oModelFNR:HasField("FNR_TRANSP")
			cTransp := oModel:GetValue("GridFNR","FNR_TRANSP")
		EndIf
		If oModelFNR:HasField("FNR_TPFRET")
			cTpFrete := oModel:GetValue("GridFNR","FNR_TPFRET")
		EndIf
		If oModelFNR:HasField("FNR_PESOL")
			nPesoLiq := oModel:GetValue("GridFNR","FNR_PESOL")
		EndIf
		If oModelFNR:HasField("FNR_PBRUTO")
			nPesoBru := oModel:GetValue("GridFNR","FNR_PBRUTO")
		EndIf

		For nM := 1 To nQtdVol // Tratamento para até 9 volumes.

			If oModelFNR:HasField("FNR_VOLUM" + AllTrim(Str(nM)))
				AAdd(aVol, oModel:GetValue("GridFNR","FNR_VOLUM" + AllTrim(Str(nM))))
			EndIf
			If oModelFNR:HasField("FNR_ESPEC" + AllTrim(Str(nM)))
				AAdd(aEsp, oModel:GetValue("GridFNR","FNR_ESPEC" + AllTrim(Str(nM))))
			EndIf
			If oModelFNR:HasField("FNR_VEICU" + AllTrim(Str(nM)))
				AAdd(aVeicul, oModel:GetValue("GridFNR","FNR_VEICU" + AllTrim(Str(nM))))
			EndIf
			If oModelFNR:HasField(cCpoMarFNR + AllTrim(Str(nM)))
				AAdd(aMarca, oModel:GetValue("GridFNR",cCpoMarFNR + AllTrim(Str(nM))))
			EndIf
			If oModelFNR:HasField(cCpoNumFNR + AllTrim(Str(nM)))
				AAdd(aNumer, oModel:GetValue("GridFNR",cCpoNumFNR + AllTrim(Str(nM))))
			EndIf

		Next nM

		SaveInter()

		Aadd(aParam103,{"MV_PAR01",2,Nil})

		DbSelectArea("SD2")
		SD2->(DbSetOrder(3))
		If SD2->( DbSeek( xFilial("SD2") + PadR( cNFSaida, TamSX3("D2_DOC")[1] ) + cSerie + cCliente + cLoja ) )
			// Cabecalho da nota fiscal de entrada
			cForm:= "N"

			if Empty(Alltrim(cEspecie))

				If lExistEspec
					cEspecie := Execblock("EXISTESPEC",.F.,.F.)
				Else
					cEspecie:="NFE"
				Endif
			EndIF

			cEspNE  := cEspecie
			cFornNE := cFornece
			cLojaNE := cLojaFornece
			dDataNE := dMovimento

			Aadd(aCabec,{"F1_TIPO"		,"N"})
			Aadd(aCabec,{"F1_FORMUL"	,cForm})
			Aadd(aCabec,{"F1_DOC"		,cNFSaida})
			Aadd(aCabec,{"F1_SERIE"		,cSerie})
			Aadd(aCabec,{"F1_EMISSAO"	,dMovimento})
			Aadd(aCabec,{"F1_FORNECE"	,cFornece})
			Aadd(aCabec,{"F1_LOJA"	 	,cLojaFornece})
			Aadd(aCabec,{"F1_ESPECIE"	,cEspecie})
			Aadd(aCabec,{"F1_EST"		,cEstado})
			Aadd(aCabec,{"F1_ORIGEM","ATFA060"})
			If !Empty(cTransp) .And. FNR->(ColumnPos('FNR_TRANSP')) > 0
				Aadd(aCabec,{"F1_TRANSP",cTransp}) // Transportadora.
			EndIf
			If !Empty(cTpFrete) .And. FNR->(ColumnPos('FNR_TPFRET')) > 0
				Aadd(aCabec,{"F1_TPFRETE",cTpFrete}) // Tipo de frete.
			EndIf
			If nPesoLiq > 0 .And. FNR->(ColumnPos('FNR_PESOL')) > 0
				Aadd(aCabec,{"F1_PLIQUI",nPesoLiq}) // Peso liquido.
			EndIf
			If nPesoBru > 0 .And. FNR->(ColumnPos('FNR_PBRUTO')) > 0
				Aadd(aCabec,{"F1_PBRUTO",nPesoBru}) // Peso bruto.
			EndIf
			For nM := 1 To Len(aEsp)
				If !Empty(aEsp[nM]) .And. SF1->(ColumnPos("F1_ESPECI" + AllTrim(Str(nM)))) > 0 .And. FNR->(ColumnPos('FNR_ESPEC' + AllTrim(Str(nM)))) > 0
					Aadd(aCabec,{"F1_ESPECI" + AllTrim(Str(nM)),aEsp[nM]}) // Especie de 1 a 4.
				EndIf
			Next nM
			For nM := 1 To Len(aVol)
				If !Empty(aVol[nM]) .And. SF1->(ColumnPos("F1_VOLUME" + AllTrim(Str(nM)))) > 0 .And. FNR->(ColumnPos('FNR_VOLUM' + AllTrim(Str(nM)))) > 0
					Aadd(aCabec,{"F1_VOLUME" + AllTrim(Str(nM)),aVol[nM]}) // Volume de 1 a 4.
				EndIf
			Next nM
			For nM := 1 To Len(aVeicul)
				If !Empty(aVeicul[nM]) .And. SF1->(ColumnPos("F1_VEICUL" + AllTrim(Str(nM)))) > 0 .And. FNR->(ColumnPos('FNR_VEICU' + AllTrim(Str(nM)))) > 0
					Aadd(aCabec,{"F1_VEICUL" + AllTrim(Str(nM)),aVeicul[nM]}) // Veiculo de 1 a 4.
				EndIf
			Next nM
			If !Empty(cCpoMarSF1)
				For nM := 1 To Len(aMarca)
					If !Empty(aMarca[nM]) .And. SF1->(ColumnPos(cCpoMarSF1 + AllTrim(Str(nM)))) > 0 .And. FNR->(ColumnPos(cCpoMarFNR + AllTrim(Str(nM)))) > 0
						Aadd(aCabec,{cCpoMarSF1 + AllTrim(Str(nM)),aMarca[nM]}) // Marca de 1 a 4.
					EndIf
				Next nM
			EndIf
			If !Empty(cCpoNumSF1)
				For nM := 1 To Len(aNumer)
					If !Empty(aNumer[nM]) .And. SF1->(ColumnPos(cCpoNumSF1 + AllTrim(Str(nM)))) > 0 .And. FNR->(ColumnPos(cCpoNumFNR + AllTrim(Str(nM)))) > 0
						Aadd(aCabec,{cCpoNumSF1 + AllTrim(Str(nM)),aNumer[nM]}) // Numeração de 1 a 4.
					EndIf
				Next nM
			EndIf

			// Itens da nota fiscal de entrada
			While SD2->(!Eof()) .And. xFilial("SD2") + PadR( cNFSaida, TamSX3("D2_DOC")[1] ) + cSerie + cCliente + cLoja == SD2->(D2_FILIAL + D2_DOC + D2_SERIE + D2_CLIENTE + D2_LOJA)
				aLinha   := {}
				cProdRef := SD2->D2_COD
				nItem++
				Aadd(aLinha,{"D1_ITEM"	,StrZero(nItem,4)	,Nil})
				Aadd(aLinha,{"D1_COD"	,SD2->D2_COD		,Nil})
				Aadd(aLinha,{"D1_QUANT"	,SD2->D2_QUANT		,Nil})
				Aadd(aLinha,{"D1_VUNIT"	,SD2->D2_PRCVEN		,Nil})
				Aadd(aLinha,{"D1_TOTAL"	,SD2->D2_TOTAL		,Nil})
				Aadd(aLinha,{"D1_TES"	,cTESEntrad			,Nil})

				// Checa geracao de documento
				If nClasNF == "2"
					// Checa se utiliza rastreabilidade
					If Rastro(SD2->D2_COD,"L")
						Aadd(aLinha,{"D1_LOTECTL", SD2->D2_LOTECTL, Nil})
						Aadd(aLinha,{"D1_DTVALID", SD2->D2_DTVALID, Nil})
					EndIf
					If Rastro(SD2->D2_COD,"S")
						Aadd(aLinha,{"D1_NUMLOTE", SD2->D2_NUMLOTE, Nil})
						Aadd(aLinha,{"D1_DTVALID", SD2->D2_DTVALID, Nil})
					EndIf
				EndIf
				Aadd(aLinha,{"D1_CONTA" , cContaD   , Nil})
				If !Empty(cArmazem)
					Aadd(aLinha,{"D1_LOCAL" , cArmazem , Nil})
				EndIf
				Aadd(aLinha,{"D1_ORIGEM", "ATFA060", Nil})

				If oModelFN9:HasField("FN9_GERNF") .And. !Empty(cUfDestCiap)
					If cEstado $ cUfDestCiap // Se a UF do fornecedor de destino estiver contida no parâmetro.
						If oModel:GetValue('FieldFN9','FN9_GERNF') == '1' // Se a transferência gerar nota fiscal.
							SN1->(DBSetOrder(1))
							If SN1->(MsSeek(FWxFilial("SN1")+cBase+cItem))
								Aadd(aLinha,{"FIL_CIAP", FWxFilial('SN1'), Nil})
								Aadd(aLinha,{"COD_CIAP", SN1->N1_CODCIAP, Nil})
							EndIf
						EndIf
					EndIf
				EndIf

				Aadd(aItens,aLinha)
			SD2->(DbSkip())
			EndDo
			// Caso tenha itens e cabecalho definidos
			If Len(aItens) > 0 .And. Len(aCabec) > 0
				// Atualiza para a filial destino
				cFilant := cFilDes
				// Reinicializa ambiente para o fiscal
				If MaFisFound()
					MaFisEnd()
				EndIf

				cFilF9NE := xFilial("SF9") // Pego a filial da SF9 no destino

				// Checa geracao de documento
				lMsErroAuto := .F.
				If nClasNF == "2"
					MSExecAuto( { |x, y, z, p| MATA103(x, y, z,,,,p) }, aCabec,aItens,3,aParam103 ) //Inclusao
				Else
					// Inclui pre-nota
					MSExecAuto( { |x, y, z| MATA140(x, y, z) }, aCabec,aItens,3 ) //Inclusao
				EndIf
				// Checa erro de rotina automatica
				If lMsErroAuto
					lMostraErro	:=.T.
					lRet		:= .F.
				else

					//Atualizo o código do Ativo nos itens NF-e de entrada no destino
					DBSelectArea("SD1")
					SD1->(DBSetOrder(2))
					For n := 1 to Len(aItens)
						If(SD1->(DBSeek( xFilial("SD2") + aItens[n][2][2] + cNFSaida + cSerie + cFornece + cLojaFornece )))
							If cBase + cItem != SD1->D1_CBASEAF //apenas se for diferente
								RecLock("SD1", .F.)
									SD1->D1_CBASEAF := cBase + cItem
								SD1->(MsUnlock())
							Endif
						EndIf
					Next n

					//Atualizo informações na NF de Saída com dados da NF de Entrada para gravação da CHAVE também na SF1 após Comunicação da SEFAZ  - DSERCTR1-43284
					DBSelectArea("SF2")
					SF2->(DBSetOrder(1)) //F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_FORMUL+F2_TIPO
					If(SF2->(DBSeek(cFilOri + PadR( cNFSaida, TamSX3("F2_DOC")[1] ) + cSerie + cCliente + cLoja )))
						If RecLock("SF2",.F.)
							SF2->F2_FILDEST:=cFilDes
							SF2->F2_FORDES :=cFornece
							SF2->F2_LOJADES:=cLojaFornece
							SF2->F2_FORMDES:=cForm
							SF2->(MsUnlock())
						EndIf
					EndIf
				EndIf

				cFilant := cFilOri // Retorna backup da cFilAnt.

			EndIf
		EndIf

		// Mostra erro em rotina automatica
		If lMostraErro

			oModel:SetErrorMessage("","","","","AFA060NFE",STR0181 + cBase + STR0165 + cItem,"") //"Não foi possível gerar a Nota Fiscal de Entrada para o bem: "###"Item: "

			Mostraerro()

		EndIf
	EndIf
	RestInter()

	RestArea(aArea)
RestArea(aAreaSM0)

Return(lRet)

/*{Protheus.doc} AF060PE
Função de Ponto de Entrada que efetua o Gatilho
@author Jose Augusto Ribeiro
@since 17/06/2015
@version P12
@param cCampo, caracter,Campo que foi chamada a Função
*/
Static Function AF060PE(cCampo)
Local lAF060GAT	:= ExistBlock("AF060GAT")
Local aValue	:= {}
Local nI		:= 0
Local oModel	:= FwModelActivete()
Local oModelFNS	:= oModel:GetModel("GridFNS")
Local aCposFNS	:= oModelFNS:GetStruct():GetFields()
Local oHash		:= tHashMap():New()//Cria o Objeto do Hash Map
Local aVetPE	:= {}
Local aRet		:= {}
Local nFns 		:= 0
Local nAvet		:= 0

If(lAF060GAT)
	For nI := 1 to Len(aCposFNS)
		If(aCposFNS[nI][3] = "FNS_CONTAD,FNS_CONCOD,FNS_CONDDD,FNS_CONDAD,FNS_CONCDD,FNS_CCBEMD,FNS_CCCORD,FNS_CCDAD,FNS_CCCDD,FNS_CCDDD" + ;
								"FNS_ITBEMD,FNS_ITCORD,FNS_ITDEDD,FNS_ITDEAD,FNS_ITCDED,FNS_CVBEMD,FNS_CVCORD,FNS_CVDEPD,FNS_CVCDED,FNS_CVDESD,FNS_ITDESD,FNS_CVDSPD")

			aAdd(aVetPE,{aCposFNS[nI][3],oModelFNS:GetValue(aCposFNS[nI][3])})

		EndIf
	Next nI
	aValue := Execblock("AF060GAT",.F.,.F., {cCampo,oModelFNS:GetValue(cCampo),aVetPE})
	If(ValType(aValue) == "A") .AND. !Empty(aValue)
		For nAvet := 1 To Len(aValue)
			For nFns := 1 To Len(aCposFNS)
				If aValue[nAvet][1] == aCposFNS[nFns][3]
					oModelFNS:SetValue(aCposFNS[nFns][3],aValue[nAvet][2])
					Exit
				Endif
			Next
		Next
	EndIf
EndIf

Return

/*{Protheus.doc} AF060CaTra
Realiza o cancelamento da transferencia entre filiais
@Totvs
@since 08/07/2014
@version 1.0
*/
Function AF060CaTra(cAlias as Character, nReg as Numeric, nOpc as Numeric,lAutomato as Logical)
Local aArea		as Array
Local aAlias	as Array
Local oDlgMrk	as Object
Local aColumns	as Array
Local aRotOld	as Array
Local lRet		as Logical
Local dUltDepr	as Date

Default cAlias 	  := ""
Default nReg	  := 0
Default nOpc	  := 0
Default lAutomato := .F.

aArea		:= GetArea()
aAlias		:= {}
oDlgMrk		:= Nil
aColumns	:= {}
aRotOld		:= aClone(aRotina)
lRet		:= .T.
dUltDepr	:= SuperGetMv("MV_ULTDEPR")

If dDatabase <= dUltDepr
	Help(" ",1,"AF060DEPR",,STR0229,1,0,,,,,,{STR0230})//Problema: Depreciação já processada em posterior à data base atual {Solução: Verifique se a transferência foi efetuada depois da última depreciação}
	lRet := .F.
EndIf

SetFunName('ATFA060C')

aRotina := {}

If lRet
	If Pergunte("AFA060C",Iif(IsBlind(),.F.,.T.))
		//Retorna as colunas para o preenchimento da FWMarkBrowse
		aAlias		:= AF060ExcQr()
		cAliasMrk	:= aAlias[1]
		aColumns 	:= aAlias[2]
		If aAlias[3] // verifico primeiramente se existem ativos com os parâmetros informados

			If !(cAliasMrk)->(Eof()) // se não for final de arquivo monta a tela para marcação de quais serão cancelados

				//Criação da MarkBrowse no Layer LISTA_DAC
				oMrkBrowse:= FWMarkBrowse():New()
				oMrkBrowse:SetFieldMark("N3_OK")
				oMrkBrowse:SetOwner(oDlgMrk)
				oMrkBrowse:SetAlias(cAliasMrk)
				oMrkBrowse:bMark    := {|| AF060Mark(cAliasMrk )}
				oMrkBrowse:bAllMark := {|| AF060Inverte(cAliasMrk) }
				oMrkBrowse:SetDescription(STR0005 + " - " + STR0169) //"Transferencia de Ativos"###"Cancelar"
				oMrkBrowse:SetColumns(aColumns)
				oMrkBrowse:SetMenuDef("")
				oMrkBrowse:AddButton(STR0091, {||AF060ExeCa(1)},0, 3) //"Canc. Transf."

				If  !lAutomato
					If aAlias[4] // se alguns dos ativos de acordo com os parâmetros informados possuir movimentação, informo ao usuário
						MsgInfo(STR0214)//'Um ou mais ativos no range informado possuem movimentação e não serão passíveis de cancelamento de transferência'
					EndIf
					oMrkBrowse:Activate()
				Else
					//---------------------------------------------------------------------------
					// Reposiciona o índice, pois ele perde a referencia na execução automática
					//---------------------------------------------------------------------------
					( cAliasMrk )->( DbSetOrder( 1 ) )

					//posiciona na SN3
					oMrkBrowse:cMark := GetMark()

					AF060Mark( cAliasMrk, lAutomato )

					AF060ExeCa(1,lAutomato)

				EndIf

			Else

				Help(" ",1,"AF060MOV",,STR0215,1,0 ) //'O(s) ativo(s) encontrado(s) possui(em) movimentação(ões)  ' || 'Para cancelar a transferência primeiramente cancele as movimentações'

			EndIf
		Else
			Help(" ",1,"AF060RECNO",,STR0111,1,0,,,,,,{STR0216}) //'Não foram localizados ativos passiveis de cancelamento da transferência' ||  "Verifique se a transferência foi efetuada no mesmo mês que a database do sistema, se os códigos do ativo estão corretos ou se os ativos sofreram baixas"
		EndIf
		If(!Empty (cAliasMrk))
			dbSelectArea(cAliasMrk)
			(cAliasMrk)->(dbCloseArea())
			cAliasMrk := ""
			dbSelectArea("SN3")
			SN3->(dBSetOrder(1))
		EndIf

		//Deleta tabela temporaria criada no banco de dados
		If _oATFA0601 <> Nil
			_oATFA0601:Delete()
			_oATFA0601 := Nil
		Endif

	EndIf
Endif

SetFunName('ATFA060')

RestArea(aArea)
aRotina := aClone(aRotOld)
cCadastro	:= STR0005	// "Transferência de Ativos para chamar a função da legenda

Return Nil

/*{Protheus.doc} AF060Mark
Marcacao de um registro
@author Totvs
@since 28/10/2013
@version 1.0
*/
Function AF060Mark(cAliasTRB, lAutomato)
Local lRet		:= .F.
Local cMarca	:= oMrkBrowse:cMark
Local nLinha	:= oMrkBrowse:At()
Local cChvSN1
Local aSN1Area	:= SN1->(GetArea())
Local aSN3Area	:= SN3->(GetArea())
Local nAliasRec	:= (cAliasTRB)->RECNOSN3

Default lAutomato	 := .F.

If lAutomato
 	cMarca :=  oMrkBrowse:cMark
 	(cAliasTRB)->N3_OK := cMarca

EndIf

SN1->(DbGoto((cAliasTRB)->RECNOSN1))
SN3->(DbGoto((cAliasTRB)->RECNOSN3))

cChvSN1 := SN1->(N1_FILIAL+N1_CBASE+N1_ITEM)

If SN3->(MsRLock()) .AND. (cAliasTRB)->(MsRLock())

	//Verifica se pode deletar
	lRet := AF060VExc(.T.)

	//A FWMarkBrowse() ja traz o registro com a marca quando bMark
	//Caso a exclusao não seja permitida, desmarca registro
	IF	!lRet .and. (cAliasTRB)->N3_OK == cMarca
		(cAliasTRB)->N3_OK := "  "
		(cAliasTRB)->(MsUnlock())
		SN3->(MsUnlock())

		//Caso tenha desmarcado registro selecionado anteriormente
		//a FWMarkBrowse() ja traz o registro sem a marca quando bMark.
		//Entao destravamos o mesmo para uso de outro terminal
	ElseIf Empty( (cAliasTRB)->N3_OK )

		If (cAliasTRB)->(dbSeek(cChvSN1))
			While cChvSN1 == (cAliasTRB)->(N3_FILIAL+N3_CBASE+N3_ITEM) .And. (cAliasTRB)->(!Eof())
				RecLock(cAliasTRB, .F.)
				(cAliasTRB)->N3_OK := "  "
				MsUnlock()
				(cAliasTRB)->(DbSkip())
			End
		EndIf
		(cAliasTRB)->(DbGoTo(nAliasRec))

	EndIf

	If lRet

		//No cancelamento realizo a marcação automática dos outros itens referentes ao ativo.Uma vez que, o cancelamento
		//deve ser realizado sempre em sua totalidade. (Marcando todos os itens)
		If !Empty((cAliasTRB)->N3_OK)
			If (cAliasTRB)->(dbSeek(cChvSN1))
				While cChvSN1 == (cAliasTRB)->(N3_FILIAL+N3_CBASE+N3_ITEM) .And. (cAliasTRB)->(!Eof())
					RecLock(cAliasTRB, .F.)
					(cAliasTRB)->N3_OK := cMarca
					MsUnlock()
					(cAliasTRB)->(DbSkip())
				End
			EndIf
		EndIf
		(cAliasTRB)->(DbGoTo(nAliasRec))

	EndIf

Else
	lRet := .F.
EndIf

RestArea(aSN1Area)
RestArea(aSN3Area)

If !lAutomato
	oMrkBrowse:Goto(nLinha,.T.)
EndIf

Return lRet

/*{Protheus.doc} AF060Inverte
Marcacao de vários registros
@author Totvs
@since 08/07/2014
@version 1.0
*/
Function AF060Inverte(cAliasTRB)
Local nReg		:= (cAliasTRB)->(Recno())
Local cMarca	:= oMrkBrowse:cMark

DbSelectArea(cAliasTRB)
DbGoTop()

While !(cAliasTRB)->(Eof())
	SN1->(dbGoto((cAliasTRB)->RECNOSN1))
	SN3->(dbGoto((cAliasTRB)->RECNOSN3))
	If SN3->(MsRLock()) .AND. (cAliasTRB)->(MsRLock())
		If AF060VExc(.F.)
			IF	(cAliasTRB)->N3_OK == cMarca
				(cAliasTRB)->N3_OK := "  "
				(cAliasTRB)->(MsUnlock())
				SN3->(MsUnlock())
			Else
				(cAliasTRB)->N3_OK := cMarca
			Endif
	    Endif
	Endif
	(cAliasTRB)->(dbSkip())
Enddo

(cAliasTRB)->(dbGoto(nReg))

oMrkBrowse:oBrowse:Refresh(.t.)

Return .T.

/*{Protheus.doc} AF060ExcQr
@author Jose Augusto Ribeiro
@since 18/06/2015
@version P12
@return ,Array, Array contendo o Alias temporario do arquivo e as colunas do Browse
*/
Static Function AF060ExcQr()
	Local aArea			as Array
	Local aStru			as Array
	Local aColumns		as Array
	Local nX			as Numeric
	Local cArqTrab		as Character
	Local cCodFim		as Character
	Local cItemIni		as Character
	Local cItemFim		as Character
	Local cGrupoIni		as Character
	Local cGrupoFim		as Character
	Local cDataIni		as Character
	Local cDataFim		as Character
	Local cQuery		as Character
	Local nTamEmp	 	as Numeric
	Local nTamUnNeg		as Numeric
	Local lOracle		as Logical
	Local cQFindBem		as Character
	Local cQueryMov		as Character
	Local lMov  		as Logical
	Local lEncontrou 	as Logical
	Local cAliasSQL   	as Character
	Local lAtfFilCom  	as Logical

	aArea		:= GetArea()
	aStru		:= SN3->(DbStruct())
	aColumns	:= {} //Array com as colunas a serem apresentadas
	nX			:= 0
	cArqTrab	:= ""
	cCodIni		:= MV_PAR01
	cCodFim		:= MV_PAR03
	cItemIni	:= MV_PAR02
	cItemFim	:= MV_PAR04
	cGrupoIni	:= MV_PAR05
	cGrupoFim	:= MV_PAR06
	cDataIni	:= DToS(FirstDay(dDataBase))
	cDataFim	:= DToS(LastDay(dDataBase))
	cQuery		:= ""
	nTamEmp 	:= Len(FWSM0LayOut(,1))
	nTamUnNeg	:= Len(FWSM0LayOut(,2))
	lOracle		:= Upper(TcGetDb()) $ "ORACLE"
	cQFindBem 	:=""
	cQueryMov 	:=""
	lMov  		:= .F.
	lEncontrou 	:= .F.
	cAliasSQL   := GetNextAlias()
	lAtfFilCom 	:= FWModeAccess("SN1",3) == "C" .AND. FWModeAccess("SN3",3) == "C" .AND. FWModeAccess("SN4",3) == "C" .AND.;
				   FWModeAccess("FN6",3) == "C" .AND. FWModeAccess("FN7",3) == "C" .AND.;
				   FWModeAccess("FNR",3) == "C" .AND. FWModeAccess("FNS",3) == "C"

	cQuery += "SELECT "
	cQuery += " SN3.N3_FILIAL,SN3.N3_CBASE,SN3.N3_ITEM,SN3.N3_TIPO,SN3.N3_SEQ,SN3.N3_AQUISIC,SN3.N3_HISTOR,SN3.N3_OK, SN3.R_E_C_N_O_ RECNOSN3 , "
	cQuery += " SN1.N1_FILIAL, SN1.N1_GRUPO, SN1.N1_PATRIM, SN1.N1_CBASE, SN1.N1_ITEM, SN1.N1_QUANTD, SN1.N1_AQUISIC, SN1.N1_BAIXA, SN1.N1_OK, SN1.R_E_C_N_O_ RECNOSN1 "
	cQuery += " FROM " +	RetSqlName("SN1") + " SN1 "
	cQuery +=			" INNER JOIN "+RetSQLName("SN3")+" SN3 ON "
	cQuery +=			" SN3.N3_FILIAL  = SN1.N1_FILIAL AND "
	cQuery +=			" SN3.N3_CBASE   = SN1.N1_CBASE  AND "
	cQuery +=			" SN3.N3_ITEM    = SN1.N1_ITEM  "
	cQuery +=			" INNER JOIN "+RetSQLName("SN4")+" SN4 ON "
	cQuery +=			" SN4.N4_FILIAL  = SN3.N3_FILIAL AND "
	cQuery +=			" SN4.N4_CBASE   = SN3.N3_CBASE  AND "
	If !lAtfFilCom
		cQuery +=			" SN4.N4_ITEM    = SN3.N3_ITEM AND "
	Endif
	cQuery +=			" SN4.N4_TIPO    = SN3.N3_TIPO AND "
	cQuery +=			" SN4.N4_SEQ    = SN3.N3_SEQ AND "
	cQuery +=			" SN4.N4_SEQREAV = SN3.N3_SEQREAV AND "
	cQuery +=			" SN4.N4_TPSALDO = SN3.N3_TPSALDO "
	cQuery += " WHERE SN1.N1_FILIAL = '" + XFilial("SN1")	+ "' "
	cQuery += " AND SN1.N1_CBASE	Between '"	+ cCodIni  	+ "' AND '" + cCodFim	+ "' "
	cQuery += " AND SN1.N1_ITEM		Between '"	+ cItemIni 	+ "' AND '" + cItemFim	+ "' "
	cQuery += " AND SN1.N1_GRUPO	Between '"	+ cGrupoIni	+ "' AND '" + cGrupoFim	+ "' "
	cQuery += " AND SN1.N1_BAIXA	= ' ' "
	cQuery += " AND SN1.N1_STATUS	= '1' "
	cQuery += " AND SN4.N4_DATA	Between '"	+ cDataIni		+ "' AND '" + cDataFim	+ "' "
	If lAtfFilCom
		cQuery += " AND SN4.N4_OCORR IN ('01','04')  "
	Else
		cQuery += " AND SN4.N4_OCORR = '04'  "
	Endif
	If MV_PAR09 == 1 //Cancelamento de transferencia entre filiais
		If FWModeAccess("SN4",3) == "E" // Totalmente exclusivo, premissa N1, N3, N4 ter o mesmo compartilhamento
			cQuery += 	" AND SN4.N4_FILORIG <> SN4.N4_FILIAL   " //Tratamento para cancelamento do último tipo de transferencia Fiscal/Contabil
		Else
			If FWModeAccess("SN4",2) == "E" .And. FWModeAccess("SN4",3) == "C" // Compartilhado somente segmento filial, premissa N1, N3, N4 ter o mesmo compartilhamento
				If lOracle
					cQuery += " AND SUBSTR(SN4.N4_FILORIG,1," + alltrim(str(nTamEmp + nTamUnNeg)) + ") <> SUBSTR(SN4.N4_FILIAL,1," + alltrim(str(nTamEmp + nTamUnNeg)) + ")   " //Tratamento para cancelamento do último tipo de transferencia Fiscal/Contabil
				Else
					cQuery += " AND SUBSTRING(SN4.N4_FILORIG,1," + alltrim(str(nTamEmp + nTamUnNeg)) + ") <> SUBSTRING(SN4.N4_FILIAL,1," + alltrim(str(nTamEmp + nTamUnNeg)) + ")   " //Tratamento para cancelamento do último tipo de transferencia Fiscal/Contabil
				Endif
			Elseif FWModeAccess("SN4",1) == "E" .And. FWModeAccess("SN4",2) == "C" // Compartilhado Unidade de Negocio/Filial, premissa N1, N3, N4 ter o mesmo compartilhamento
				If lOracle
					cQuery += " AND SUBSTR(SN4.N4_FILORIG,1," + alltrim(str(nTamEmp)) + ") <> SUBSTR(SN4.N4_FILIAL,1," + alltrim(str(nTamEmp)) + ")   " //Tratamento para cancelamento do último tipo de transferencia Fiscal/Contabil
				Else
					cQuery += " AND SUBSTRING(SN4.N4_FILORIG,1," + alltrim(str(nTamEmp)) + ") <> SUBSTRING(SN4.N4_FILIAL,1," + alltrim(str(nTamEmp)) + ")   " //Tratamento para cancelamento do último tipo de transferencia Fiscal/Contabil
				Endif
			Else
				cQuery += 	" AND SN4.N4_FILORIG <> SN4.N4_FILIAL   " //Compartilhado sempre será diferente, pois N4_FILORIG é filial cheia e N4_FILIAL é vazio
			Endif
		Endif
	ElseIf MV_PAR09 == 2 //Cancelamento de transferencia contabil
		cQuery += 	" AND SN4.N4_FILORIG =  SN3.N3_FILORIG" //Tratamento para cancelamento do último tipo de transferencia Fiscal/Contabil
	EndIF
	If lIsRussia
		cFiltro += " AND SN3.N3_OPER = '1' " // CAZARINI - 21.01.2017 - Asset Into Operation?
	Endif
	cQuery += " AND SN1.D_E_L_E_T_	= ' ' "
	cQuery += " AND SN3.D_E_L_E_T_	= ' ' "
	cQuery += " AND SN4.D_E_L_E_T_	= ' ' "

	cQFindBem := ChangeQuery(cQuery)
	MPSysOpenQuery(cQFindBem,cAliasSQL)

	If (cAliasSQL)->(!EoF())
		lEncontrou := .T.
	EndIf
	(cAliasSQL)->(DbCloseArea())

	If lEncontrou

		//Ignora ativos que possuam movimento diferentes da aquisição e transferência
		cQuery += " AND NOT EXISTS ( SELECT N4_CBASE FROM " + RetSqlName("SN4") + " SN42 "
		cQuery +=                  " WHERE SN42.N4_FILIAL = '" + XFilial("SN4")+ "' "
		cQuery +=                        " AND SN42.N4_CBASE = SN1.N1_CBASE "
		cQuery +=                        " AND SN42.N4_ITEM  = SN1.N1_ITEM "
		If MV_PAR09 == 1 //Cancelamento de transferencia entre filiais
			cQuery +=                    " AND SN42.N4_OCORR NOT IN ('04','05') "
		ElseIf MV_PAR09 == 2 //Cancelamento de transferencia contabil
			cQuery +=                    " AND SN42.N4_DATA	Between '" + cDataIni + "' AND '" + cDataFim + "' "
			cQuery +=                    " AND SN42.N4_OCORR NOT IN ('03','04','05','13') "
			//Permite o cancelamento qndo tiver depreciação acumulada na data da inclusão do ativo
			cQuery +=                    " AND (SN42.N4_ORIGEM <> 'ATFA012' "
			cQuery +=                    " AND SN42.N4_DATA =  SN1.N1_AQUISIC )"
		EndIf
		cQuery +=                        " AND SN42.D_E_L_E_T_ = ' ' )"

		cQuery += " GROUP BY SN3.N3_FILIAL,SN3.N3_CBASE,SN3.N3_ITEM,SN3.N3_TIPO,SN3.N3_SEQ,SN3.N3_AQUISIC,SN3.N3_HISTOR,SN3.N3_OK, SN3.R_E_C_N_O_ , SN1.N1_FILIAL, SN1.N1_GRUPO, SN1.N1_PATRIM, SN1.N1_CBASE, SN1.N1_ITEM, SN1.N1_QUANTD, SN1.N1_AQUISIC, SN1.N1_BAIXA, SN1.N1_OK, SN1.R_E_C_N_O_ "
		cQuery += " ORDER BY SN3.N3_FILIAL,SN3.N3_CBASE,SN3.N3_ITEM,SN3.N3_TIPO, SN3.N3_SEQ "

		cQueryMov := STRTRAN(cQuery, "NOT EXISTS", "EXISTS") //inverte a query para buscar os ativos que possuem movimentação
		cQueryMov := ChangeQuery(cQueryMov)

		cAliasSQL   := GetNextAlias()
		MPSysOpenQuery(cQueryMov,cAliasSQL)

		If (cAliasSQL)->(!EoF())
			lMov := .T.
		EndIf
		(cAliasSQL)->(DbCloseArea())

		cQuery := ChangeQuery(cQuery)

		cChave		:= SN3->(IndexKey())
		Aadd(aStru, {"RECNOSN1","N",10,0})
		Aadd(aStru, {"RECNOSN3","N",10,0})

		If _oATFA0601 <> Nil
			_oATFA0601:Delete()
			_oATFA0601 := Nil
		Endif

		cArqTrab := GetNextAlias()

		_oATFA0601 := FWTemporaryTable():New( cArqTrab )
		_oATFA0601:SetFields(aStru)
		_oATFA0601:AddIndex("1", {"N3_FILIAL","N3_CBASE","N3_ITEM","N3_TIPO","N3_BAIXA","N3_SEQ"})

		//------------------
		//Criação da tabela temporaria
		//------------------
		_oATFA0601:Create()

		Processa({||SqlToTrb(cQuery, aStru, cArqTrab)})	// Cria arquivo temporario

		DbSetOrder(0) // Fica na ordem da query

		//Define as colunas a serem apresentadas na markbrowse
		For nX := 1 To Len(aStru)
			If	aStru[nX][1] $ "N3_CBASE|N3_ITEM|N3_TIPO|N3_AQUISIC|N3_HISTOR"
				AAdd(aColumns,FWBrwColumn():New())
				aColumns[Len(aColumns)]:SetData( &("{||"+aStru[nX][1]+"}") )
				aColumns[Len(aColumns)]:SetTitle(RetTitle(aStru[nX][1]))
				aColumns[Len(aColumns)]:SetSize(aStru[nX][3])
				aColumns[Len(aColumns)]:SetDecimal(aStru[nX][4])
				aColumns[Len(aColumns)]:SetPicture(PesqPict("SN3",aStru[nX][1]))
			EndIf
		Next nX
	EndIf

	RestArea(aArea)

Return({cArqTrab,aColumns,lEncontrou,lMov})

//-------------------------------------------------------------------
/*/{Protheus.doc} AF060ExeCa
Executa o cancelamento de transferência (filial ou contábil) dos
imobilizados selecionados
@author Totvs
@since 08/07/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function AF060ExeCa(nOpcao, lAutomato)
Local aArea			:= GetArea()
Local cXFil_FNR		:= ""
Local cFilDes		:= cFilAnt
Local cCodBemOri	:= ""
Local cCodItOri		:= ""
Local cSubProc		:= "ATFA060"+ "CANTRF"
Local cIdCV8			:= ""
Local cMensIni		:= ""
Local nTipTransf	:= 0 //1=Filial/2=Contabil
Local cBase			:= ""
Local cItem			:= ""
Local lLP8A1		:= VerPadrao("8A1")
Local lLP83A		:= VerPadrao("83A")
Local lLP83B		:= VerPadrao("83B")
Local lMostrLanc	:= .F.
Local lAglutLanc	:= .F.
Local cLogErro		:= ""
Local cArquivo		:= ""
Local cLoteAtf		:= LoteCont("ATF")
Local lPrim			:= .T.
Local nHdlPrv		:= 0
Local nTotal		:= 0
Local aDadosMnt		:= {}
Local cIdMovFNR	:= ""
Local lExistNF	:= .F.
Local cFilOrig	:= ""
Local cNota		:= ""
Local cSerie		:= ""
Local lAf060Vlc := ExistBlock("AF060VLC")
Local lCont     := .T.
Local cChavAux	:= ""
Local lDtCAnt		:= .T.

//Acrescentado em 15/08/2018 - DSERCTR1-13130
Local lCanceled 	:= .t.
Local lAF060CAC		:= ExistBlock("AF060CAC")

Local cMensIniPE	:= ""
Local cLogErroPE	:= ""
Local cSeqAux := Space(Len(SN3->N3_SEQ))

Local lFoundFNR 	:= .F.

Default lAutomato := .F.

If lAf060Vlc
	lCont := ExecBlock("AF060VLC",.F.,.F.,{nOpcao, cLoteAtf})
EndIf

If lCont .And. nOpcao == 1

	Pergunte("AFA060C",.F.)

	lMostrLanc	:= MV_PAR07 == 1
	lAglutLanc	:= MV_PAR08 == 1
	nTipTransf	:= MV_PAR09

	(cAliasMrk)->(dbGoTop())

	cSubProc	:= STR0090  //"Canc. Transf."
	ProcLogIni( {},__cProcPrinc,cSubProc,@cIdCV8 )

	While (cAliasMrk)->(!Eof())

		If ((cAliasMrk)->N3_OK == oMrkBrowse:cMark) .And. ( nTipTransf == 2 .Or. (cAliasMrk)->(N3_CBASE+N3_ITEM) <> cBase + cItem )

			cBase	:= (cAliasMrk)->(N3_CBASE)
			cItem	:= (cAliasMrk)->(N3_ITEM)

			SN1->(DbGoto((cAliasMrk)->RECNOSN1))
			SN3->(DbGoto((cAliasMrk)->RECNOSN3))
			cSeqAux := SN3->N3_SEQ

			lDtCAnt := AF060VldDt(cBase,cItem,.F.)

			cMensIni:= STR0093 + AllTrim(SN3->N3_CBASE) + STR0081 + AllTrim(SN3->N3_ITEM) + "." //"Canc. Transf. Bem:"###" item: "

			ProcLogAtu( STR0094 , cMensIni ,,,.T. ) //"INICIO"

			BEGIN TRANSACTION

				//---------------------------------------------
				// Cancelamento da transferencia entre filiais
				//---------------------------------------------
				If nTipTransf == 1

					If !lDtCAnt

						cLogErro += STR0195 // Localizada transferência com data posterior a data base do sistema.
						DisarmTransaction()

						lCanceled := .F.

						Break

					EndIf

					//Obtem o ID da ultima transferencia do bem, possibilitando obter os dados da NF, se gerada
					If cChavAux <> SN1->(N1_CBASE+N1_ITEM)
						cIdMovFNR  := AF060IDFNR(SN1->(N1_CBASE), SN1->(N1_ITEM), @cXFil_FNR, nTipTransf)
						cChavAux := SN1->(N1_CBASE+N1_ITEM)
					EndIf

					DbSelectArea("FNR")
					FNR->(DbSetOrder(2)) //FNR_FILIAL+FNR_IDMOV+FNR_CBADES+FNR_ITEDES
					If lFoundFNR := FNR->(DbSeek(iIf (!Empty(cXFil_FNR),cXFil_FNR,FwXFilial("FNR"))+ cIdMovFNR + SN1->(N1_CBASE)+ SN1->(N1_ITEM)))
						lExistNF	:= FNR->FNR_GERNF == "1"
						cFilOrig	:= FNR->FNR_FILORI
						cNota		:= FNR->FNR_NOTA
						cSerie		:= FNR->FNR_SERIE
						cCodBemOri	:= FNR->FNR_CBAORI
						cCodItOri	:= FNR->FNR_ITEORI
					EndIf

					//-----------------------------------------------------------
					// Realiza a contabilização do cancelamento da transferência
					// Exclui a Nota Fiscal de Entrada (se houver)
					// Exclui o ativo na filial destino
					//-----------------------------------------------------------
					If lFoundFNR .And. AF060ExcAu(SN1->N1_CBASE, SN1->N1_ITEM,lMostrLanc,lAglutLanc,lLP8A1,lExistNF,cFilOrig,cNota,cSerie)

						//-------------------------------------------
						// Cancela a baixa do ativo na filial origem
						//-------------------------------------------
						cFilAnt := cFilOrig

						If !AF060Canc(cCodBemOri,cCodItOri,lMostrLanc,lAglutLanc,@cLogErro,lExistNF,cNota,cSerie, cSeqAux)

							cLogErro += STR0097 //"Não foi possivel cancelar a baixa na filial origem."
							DisarmTransaction()

							lCanceled := .F.

							Break

						EndIf

						cFilAnt := cFilDes

					Else

						cLogErro := STR0099 //"Não foi possivel excluir o bem na filial destino."
						DisarmTransaction()

						lCanceled := .F.

						Break

					EndIf

				//----------------------------------------
				// Cancelamento da transferencia contabil
				//----------------------------------------
				ElseIf nTipTransf == 2

					If !lDtCAnt
						cLogErro += STR0195 // Localizada transferência com data posterior a data base do sistema.
						DisarmTransaction()

						lCanceled := .F.

						Break

					EndIf

					//Obtem o ID da ultima transferencia do bem, possibilitando obter os dados da NF, se gerada
					If cChavAux <> SN1->(N1_CBASE+N1_ITEM)
						cIdMovFNR := AF060IDFNR(SN1->(N1_CBASE), SN1->(N1_ITEM),,nTipTransf )
						cChavAux  := SN1->(N1_CBASE+N1_ITEM)

						//-----------------------
						// Restaura dados da SN1
						//-----------------------
						DBSelectArea("FNR")
						FNR->(DBSetOrder(1))
						If !Empty(cIdMovFNR) .And. FNR->(DBSeek(XFilial("FNR")+cIdMovFNR+(cAliasMrk)->(N3_CBASE+N3_ITEM)))
							RecLock("SN1",.F.)
								SN1->N1_GRUPO	:= FNR->FNR_GRPORI
								SN1->N1_TAXAPAD	:= FNR->FNR_TXPADO
								SN1->N1_LOCAL	:= FNR->FNR_LOCORI
							SN1->(MSUnlock())

							If FNR->FNR_LOCORI <> FNR->FNR_LOCDES
								A060BLQLOC(FNR->FNR_LOCORI,SN1->N1_CBASE,SN1->N1_ITEM)
							EndIf

						EndIf
					EndIf

					A060CanCtb(lLP83A,@cArquivo,@cLoteAtf,@lPrim,@nHdlPrv,@nTotal,,lLP83B,cIdMovFNR)

				EndIf

				//---------------------------------
				// Atualiza o status da tabela FNR
				//---------------------------------
				DbSelectArea("FNR")
				FNR->(DbSetOrder(2))
				If lFoundFNR := FNR->(DbSeek(iIf (!Empty(cXFil_FNR),cXFil_FNR,FwXFilial("FNR"))+ cIdMovFNR + SN1->(N1_CBASE)+ SN1->(N1_ITEM)))
					RecLock("FNR")
					FNR->FNR_STATUS := '2' //Transferêcia Cancelada
					FNR->(MsUnlock())
				Else
					Help(" ",1, "AF060VCA",,STR0212,1,0) //"Não foi possivel gravar o status da transferência cancelada."
				EndIf

			END TRANSACTION

			//Ponto de Entrada após a efetivação do cancelamento da Transferência
			//Acrescentado em 15/08/2018 - DSERCTR1-13130
			If ( lCanceled .And. lAF060CAC )

				cLogErroPE := Execblock("AF060CAC",.F.,.F.,{cIdMovFNR})

				If ( !Empty(cLogErroPE) )
					cMensIniPE := STR0035	//"Cancel. Efetuado. Mas há erros na execução do P.E AF060CAC."
					ProcLogAtu("ALERTA",cMensIniPE,cLogErroPE,,.T. )
				EndIf

			EndIf

			//----------------------------------------
			// Gera o Log de erro fora da transaction
			//----------------------------------------
			If !Empty(cLogErro)
				ProcLogAtu(STR0095,cMensIni,cLogErro,,.T. ) //"ERRO"
			EndIf

			ProcLogAtu(STR0100,cMensIni,,,.T.) //"FIM"

		EndIf

	(cAliasMrk)->(DbSkip())
	EndDo

	//------------------------------------------------
	// Contabilização da Transferência Contabil (83A)
	//------------------------------------------------
	If nHdlPrv > 0 .And. nTotal > 0
		RodaProva(nHdlPrv,nTotal)
		cA100Incl(cArquivo,nHdlPrv,3,cLoteAtf,lMostrLanc,lAglutLanc,,,,aFlagCTB )
	Endif

	If !lAutomato
		ProcLogView(cFilAnt,__cProcPrinc,cSubProc,cIdCV8)
	EndIf
EndIf

MBrChgLoop(.F.) //Desabilita a chamada da tela de inclusão novamente.

If !lAutomato
	oMrkBrowse:GetOwner():End()
EndIf
RestArea(aArea)

Return .T.

/*{Protheus.doc} AF060VExc
Valida a possibilidade de se excluir um imobilizado
@author Totvs
@since 08/07/2014
@version 1.0
*/
Function AF060VExc(lHelp,lLote)
Local aArea		:= GetArea()
Local lRet		:= .T.
Local cXFil_FNR	:= ""

Default lHelp	:= .T.
Default lLote	:= .T.

If MV_PAR09 == 1
	cXFil_FNR := xFilial('FNR',cFilAnt)
EndIf

//Não Altera bens Bloqueados
If SN1->N1_STATUS $ '2/3'
	Help(" ",1,"AF010BLOQ") //"Este bem está bloqueado. Bens bloqueados não podem ser alterados/excluidos."
	lRet := .F.
EndIf

If lRet .and. SN1->N1_FILIAL != xFilial("SN1")
	If lHelp
		HELP(" ",1,"A000FI") //"Código da Filial não esta correto."
	Endif
	lRet  := .F.
	xRet := .T.
Endif

//Verificacao de possibilidade de deleção
If lRet
	//Obtem o ID da ultima transferencia do bem
	cIdMovFNR  := AF060IDFNR(SN1->(N1_CBASE), SN1->(N1_ITEM), @cXFil_FNR, MV_PAR09)
	DbSelectArea("FNR")
	FNR->(DbSetOrder(2)) //FNR_FILIAL+FNR_IDMOV+FNR_CBADES+FNR_ITEDES
	If FNR->(DbSeek(iIf (!Empty(cXFil_FNR),cXFil_FNR,FwXFilial("FNR"))+ cIdMovFNR + SN1->(N1_CBASE)+ SN1->(N1_ITEM)))
		lRet  := AF012AVLDL("SN3",,lHelp, FNR->FNR_DATA)
	Else
		lRet  := AF012AVLDL("SN3",,lHelp)
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060ExcAu
Rotina automatica para exclusao dos imobilizados selecionados
@author Totvs
@since 08/07/2014
@version 1.0
*/
Function AF060ExcAu(cCBase,cItem,lMostrLanc,lAglutLanc,lLP8A1,lExistNF,cFilOrig,cNota,cSerie)
Local aArea		:= GetArea()
Local aCab		:= {}
Local aItens	:= {}
Local aParam	:= {}
Local lRet		:= .T.
Local aLog		:= {}

//Variaveis para contabilizacao
Local cArquivo	:= ""
Local cLoteAtf	:= LoteCont("ATF")
Local lPrim		:= .T.
Local nHdlPrv	:= 0
Local nTotal	:= 0

//Controle de rotina automatica
Private lMsErroAuto		:= .F. //Determina se houve algum tipo de erro durante a execucao do ExecAuto
Private lMsHelpAuto		:= .T. //Define se mostra ou não os erros na tela (T= Nao mostra; F=Mostra)
Private lAutoErrNoFile	:= .F. //Habilita a gravacao de erro da rotina automatica

Default lMostrLanc	:= .F.
Default lAglutLanc	:= .F.
Default lLP8A1		:= .F.
Default lExistNF		:= .F.
Default cFilOrig		:= ""
Default cNota			:= ""
Default cSerie		:= ""

//------------------------------------
// Exclusao da Nota Fiscal de Entrada
//------------------------------------
If lExistNF
	lRet := AF060ExNFE(cFilOrig,cNota,cSerie)
EndIf

If lRet
	//--------------------------------------------------------------------------------------
	// Inserido tratamento na rotina (AF010ADLAT) para nao contabilizar a exclusao quando o
	// processo for chamado e contabilizado pelo cancelamento da transferencia - Destino(8A1)
	//---------------------------------------------------------------------------------------
	Aadd( aParam, {"MV_PAR01", 2} ) //Mostra Lanc Contab
	Aadd( aParam, {"MV_PAR02", 2} ) //Repete Chapa
	Aadd( aParam, {"MV_PAR03", 2} ) //Descrição Estendida

	Aadd(aCab,{"N1_CBASE"	,cCBase	,NIL})
	Aadd(aCab,{"N1_ITEM"	,cItem	,NIL})

	//---------------------------------------------------------------------
	// Posiciona nos registros da tabela SN3 para contabilização dos dados
	//---------------------------------------------------------------------
	DbSelectArea("SN3")
	SN3->(DbSetOrder(1))
	If lLP8A1 .And. SN3->(DbSeek(XFilial("SN3")+cCBase+cItem))
		While XFilial("SN3")+cCBase+cItem == SN3->(N3_FILIAL+N3_CBASE+N3_ITEM)

			If lPrim .And. (nHdlPrv <= 0)
				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
				lPrim := .F.
			Endif

			nTotal += DetProva( nHdlPrv,"8A1","ATFA060",cLoteAtf)

		SN3->(DbSkip())
		EndDo
	EndIf

	MSExecAuto({|x,y,z,w| Atfa012(x,y,z,w)},aCab,aItens,5,aParam)

	If lMsErroAuto
		lMsErroAuto := .F.
		DisarmTransaction()
		lRet := .F.

		cFileLog := NomeAutoLog()
		cPath := ""
		If !Empty(cFileLog) .And. !lRet
			MostraErro(cPath,cFileLog)
		EndIf
	Else
		//-------------------------------------------------------------------------------
		// Contabilização do Cancelamento Transferência Destino (8A1)
		//-------------------------------------------------------------------------------
		If nHdlPrv > 0 .And. nTotal > 0
			RodaProva(nHdlPrv,nTotal)
			cA100Incl(cArquivo,nHdlPrv,3,cLoteAtf,lMostrLanc,lAglutLanc,,,,aFlagCTB )
		Endif
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060Canc
Processa o cancelamento da baixa por transferência na filial de origem
@Totvs
@since 08/07/2014
@version 1.0
*/
Function AF060Canc(cBaseSup, cItemSup,lMostrLanc,lAglutLanc,cLogErro,lExistNF,cNota,cSerie,cSeqAux)
Local aArea		:= GetArea()
Local aAreaSN1	:= SN1->(GetArea())
Local aAreaSN3	:= SN3->(GetArea())
Local aAreaSN4	:= SN4->(GetArea())
Local lRet		:= .T.
Local aRecnos	:= {}
Local aParam036	:= {}
Local aLog		:= {}
Local aCab		:= {}
Local cRotBaixa	:= AllTrim(GetNewPar("MV_ATFRTBX", "ATFA030"))
Local cModAnt	:= .F.
Local aBaixa	:={}

//Variaveis para contabilizacao
Local cArquivo	:= ""
Local cLoteAtf	:= LoteCont("ATF")
Local lPrim		:= .T.
Local nHdlPrv	:= 0
Local nTotal	:= 0
Local lLP8A0	:= VerPadrao("8A0")
Local nRecFN6 := 0

//Controle de rotina automatica
Private lMsErroAuto		:= .F. //Determina se houve algum tipo de erro durante a execucao do ExecAuto
Private lMsHelpAuto		:= .T. //Define se mostra ou não os erros na tela (T= Nao mostra; F=Mostra)
Private lAutoErrNoFile	:= .F. //Habilita a gravacao de erro da rotina automatica

Default cBaseSup	:= ""
Default cItemSup	:= ""
Default lMostrLanc	:= .F.
Default lAglutLanc	:= .F.
Default cLogErro	:= ""
Default cSeqAux := SN3->N3_SEQ


//--------------------------------------------------------
// Exclusao da Nota Fiscal de Saida na Filial Originadora
//--------------------------------------------------------
If lExistNF
	lRet := AF060ExNFS(cNota,cSerie)
EndIf

If lRet
	//--------------------------------------------------------------
	// Inserido tratamento para nao contabilizar o cancelamento.
	// Será contabilizado o cancelamento da transferencia - Origem (8A0)
	//--------------------------------------------------------------
	Aadd( aParam036, {"MV_PAR01", 3}) //Mostra lancamentos contabeis (1=Sim;2=Nao;3=Nao Contabiliza)
	Aadd( aParam036, {"MV_PAR02", 2}) //Aglutina (1=Sim;2=Nao)
	Aadd( aParam036, {"MV_PAR03", 2}) //Online (1=Sim;2=Nao)
	Aadd( aParam036, {"MV_PAR04", 1}) //Visualização (1=Baixas;2=Tipos de Ativo)

	If Empty(cBaseSup) .Or. Empty(cItemSup)
		lRet := .F.
		cLogErro := STR0101//"Erro na obtenção dos dados do ativo a ser cancelado."
	Endif

	If lRet

		If SN1->(MsSeek( XFilial("SN1") + cBaseSup + cItemSup )) .And. SN3->(MsSeek( xFilial("SN3") + cBaseSup + cItemSup ))
			lRet := .F.
			While SN3->(!Eof() .And. N3_FILIAL+N3_CBASE+N3_ITEM == xFilial("SN3") + cBaseSup + cItemSup )
				If SN3->N3_BAIXA == '1' .And. SN3->N3_SEQ == cSeqAux
					lRet := .T.
					Exit  //para cancelar somente itens baixados interessa
				EndIf
				SN3->( dbSkip() )
			EndDo
			If lRet
				aCab :={	{"FN6_FILIAL"	,xFilial("FN6",SN3->N3_FILORIG),NIL},;
							{"FN6_CBASE"	,SN3->N3_CBASE	,NIL},;
							{"FN6_CITEM"	,SN3->N3_ITEM	,NIL},;
							{"FN6_MOTIVO"	,"08"			,NIL},;
							{"FN6_DEPREC"	,'0'			,NIL} }

				aAtivo :={	{"N3_FILIAL"	,xFilial("SN3",SN3->N3_FILORIG),NIL},;
							{"N3_FILORIG"	,SN3->N3_FILORIG	,NIL},;
							{"N3_CBASE"	,SN3->N3_CBASE		,NIL},;
							{"N3_ITEM"		,SN3->N3_ITEM	,NIL},;
							{"N3_TIPO"		,SN3->N3_TIPO	,NIL},;
							{"N3_BAIXA"   ,SN3->N3_BAIXA	,NIL},;
							{"N3_TPSALDO"	,SN3->N3_TPSALDO,NIL},;
							{"N3_SEQREAV"	,SN3->N3_SEQREAV,NIL},;
							{"N3_SEQ"		,SN3->N3_SEQ	,NIL} }
			EndIf
			//-------------------------------------------------------------
			//Verifica a existencia de dados nas tabelas novas do módulo
			// Caso negativo chama as rotina ATFA030 e ATFA035 para cancelamento
			//-------------------------------------------------------------
			FN6->(DbSetOrder(2))//posiciono pois na execAuto estava deposicionada a Tabela
			If FN6->(!MsSeek(SN3->N3_FILIAL + SN3->N3_FILORIG + SN3->N3_CBASE + SN3->N3_ITEM))
				cModAnt := .T.
			Else
				//posicionar na ultima FN6 se encontrou FN6
				While FN6->(!Eof() .And. FN6_FILIAL+FN6_FILORI+FN6_CBASE+FN6_CITEM == SN3->N3_FILIAL+SN3->N3_FILORIG+SN3->N3_CBASE+SN3->N3_ITEM)
					nRecFN6 := FN6->( Recno() )
					FN6->( dbSkip() )
				EndDo
				If nRecFN6 > 0
					FN6->( dbGoto(nRecFN6) )
				EndIf
			EndIf

			If cModAnt
				While SN3->(N3_FILIAL + N3_CBASE + N3_ITEM) == SN1->(N1_FILIAL + N1_CBASE + N1_ITEM)
					aBaixa := {}
					AADD(aBaixa, {"N3_CBASE"	,SN1->N1_CBASE	,NIL })
					AADD(aBaixa, {"N3_ITEM"		,SN1->N1_ITEM	,NIL })
					AADD(aBaixa, {"N3_TIPO"		,SN3->N3_TIPO	,NIL })
					AADD(aBaixa, {"N3_BAIXA"	,SN3->N3_BAIXA	,NIL })
					AADD(aBaixa, {"AUTVLRVENDA"	,SN3->N3_VORIG1	,NIL })
					AADD(aBaixa, {"AUTQUANT"	,SN1->N1_QUANTD	,NIL })
					AADD(aBaixa, {"AUTMOTBX"	,"08"			,Nil })
					AADD(aBaixa, {"AUTBXFILHOS"	,.T.			,Nil })

					//------------------------------------------
					// Contabilização do cancelamento na origem
					//------------------------------------------
					If lLP8A0

						If lPrim .And. (nHdlPrv <= 0)
							nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
							lPrim := .F.
						Endif

						nTotal += DetProva( nHdlPrv,"8A0","ATFA060",cLoteAtf)
					Endif

					//³Executa a Baixa do Bem ³
					If cRotBaixa == "ATFA030"
						MSExecAuto( { |x, y,w| Atfa030( x, y, w ) }, aBaixa, 5 , aParam036 )
					Else
						MSExecAuto( { |x, y,w| Atfa035( x, y, w ) }, aBaixa, 5 , aParam036 )
					EndIf
					If SN1->N1_STATUS == '4' .and.  empty(SN1->N1_BAIXA)
						Reclock("SN1",.F.)
						SN1->N1_STATUS := '1'
						SN1->(MSUNLOCK())
					Endif
					SN3->(DBSkip())
				EndDo
			Else
				//------------------------------------------
				// Contabilização do cancelamento na origem
				//------------------------------------------
			 	While SN3->(N3_FILIAL + N3_CBASE + N3_ITEM) == SN1->(N1_FILIAL + N1_CBASE + N1_ITEM)
					If lLP8A0

						If lPrim .And. (nHdlPrv <= 0)
							nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
							lPrim := .F.
						Endif

						nTotal += DetProva( nHdlPrv,"8A0","ATFA060",cLoteAtf)
					Endif
					SN3->(DBSkip())
				EndDo

				//-----------------------
				// Cancelamento da baixa
				//-----------------------
				FN6->(DbSetOrder(1))//posiciono pois na execAuto estava deposicionada a Tabela
				MsExecAuto( { |a,b,c,d,e|ATFA036(a,b,c,,d,e)},aCab,aAtivo,5,.F.,aParam036)
			EndIf

			If lMsErroAuto
				cFileLog := NomeAutoLog()
				cPath := ""
				If !Empty(cFileLog)
					MostraErro(cPath,cFileLog)
				Endif
				lMsErroAuto := .F.
				lRet := .F.
				DisarmTransaction()
				cLogErro := STR0109 //"Bem possui restrições para a realização do cancelamento."
			Endif

		Else
			lRet := .F.
			ProcLogAtu(STR0095,STR0096,STR0102,,.T. ) //"ERRO"###"Cancelamento da baixa na filial origem"###"Bem não localizado na filial de origem."
		Endif

		//-----------------------------------------------------------------------
		// Contabilização do cancelamento da Transferência Contabil Origem (8A0)
		//-----------------------------------------------------------------------
		If lRet .And. lLP8A0
			If nHdlPrv > 0 .And. nTotal > 0
				RodaProva(nHdlPrv,nTotal)
				cA100Incl(cArquivo,nHdlPrv,3,cLoteAtf,lMostrLanc,lAglutLanc,,,,aFlagCTB )
			Endif
		EndIf

	Endif

EndIf

RestArea(aAreaSN4)
RestArea(aAreaSN3)
RestArea(aAreaSN1)
RestArea(aArea)

Return lRet

/*
{Protheus.doc} A060CanCtb
Função para o cancelamento de transferência Contábil

@param   aDadosMNT - Esta váriavel esta obsoleta e esta sendo mantida devido a compatibilidade.

@author Totvs
@since 15/10/2014
@version 12.0
*/
Function A060CanCtb(lLP83A As Logical, cArquivo As Character, cLoteAtf As Character, lPrim As Logical,;
					nHdlPrv As Numeric, nTotal As Numeric, aDadosMNT As Array,lLP83B As Logical, cIdMovFNR As Character)

Local aArea			As Array
Local aAreaSN3		As Array
Local aAreaSN4		As Array
Local aAreaSNG		As Array
Local __nQuantas	As Numeric
Local aAtuSal		As Array
Local nI			As Numeric
Local cMoed			As Character
Local dDataTrans	As Date
Local lAtClDepr		As Logical
Local cTipoTrDe		As Character
Local cTipoTrPara	As Character
Local nRecNoSN4 	As Numeric
Local dUltDepr		As Date
Local lGspInUseM	As Logical
Local nTaxaMedia	As Numeric
Local nUltIdMov		As Character //Essa variável começa com n, mas é tratada sempre como caractere desde anteriormente.
Local lAF060CCTB 	As Logical
Local lUsaFNS		As Logical
Local nTxDepr		As Numeric
Local nN4_TXDEPR	As Numeric
Local lSCDP			As Logical
Local lCVDP			As Logical
Local lIntMnt		As Logical
Local cBase			As Character
Local lCmpDesp 		As Logical
Local nContEnt 		As Numeric

Default lLP83B		:= .F.
Default lLP83A		:= .F.
Default cArquivo	:= ""
Default cLoteAtf	:= ""
Default lPrim		:= .F.
Default nHdlPrv		:= 0
Default nTotal		:= 0
Default cIdMovFNR	:= ""

aArea			:= GetArea()
aAreaSN3		:= SN3->(GetArea())
aAreaSN4		:= SN4->(GetArea())
aAreaSNG		:= SNG->(GetArea())
__nQuantas		:= If(lMultMoed,AtfMoedas(),5)
aAtuSal			:= If(lMultMoed,AtfMultMoe(,,{|x| 0}), {0,0,0,0,0} )
nI				:= 0
cMoed			:= ""
dDataTrans		:= dDataBase
lAtClDepr		:= .F.
cTipoTrDe		:= ""
cTipoTrPara		:= ""
nRecNoSN4 		:= 0
dUltDepr		:= SuperGetMv("MV_ULTDEPR")
lGspInUseM		:= If(Type('lGspInUse')=='L', lGspInUse, .F.)
nTaxaMedia		:= Af060moeda(If(lGspInUseM,MsSomaMes(dUltDepr,-1,.T.),dUltDepr))
nUltIdMov		:= ""
lAF060CCTB 		:= ExistBlock("AF060CCTB")
lUsaFNS			:= .F.
nTxDepr			:= 0
nN4_TXDEPR		:= 0
lSCDP			:= SuperGetMV("MV_ATFSCDP",.F.,.F.)
lCVDP			:= SuperGetMV("MV_ATFCVDP",.F.,.F.)
lIntMnt			:= GetMv("MV_NGMNTAT") $ "1#3"
cBase			:= ""
lCmpDesp 		:= FNS->(FieldPos("FNS_ITDESD")) > 0 // campo item despesa e classe de valor despesa no mesmo pacote 012450
nContEnt        := 0

DbSelectArea("SN3")
SN3->(DbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
SN3->(DbGoto((cAliasMrk)->RECNOSN3))

If FNS->(FieldPos("FNS_EC05DO")) > 0 .And. !__lEntAdd //Se não passar pelo MVC é necessário verificar se tem entidade adicional pelo FieldPos
	__lEntAdd := .T.
EndIf

//--------------------------------------------------------------------
// Caso exista, utiliza a FNS para obter as contas transferidas, pois
// a SN4 não possui todas a contas necessarias para o estorno
//--------------------------------------------------------------------
If !Empty(cIdMovFNR)

	DBSelectArea("FNR")
	FNR->(DBSetOrder(1)) //FNR_FILIAL+FNR_IDMOV+FNR_CBAORI+FNR_ITEORI
	If FNR->(DBSeek(XFilial("FNR")+cIdMovFNR+SN3->N3_CBASE+SN3->N3_ITEM))

		DBSelectArea("FNS")
		FNS->(DBSetOrder(1)) //FNS_FILIAL+FNS_IDMOV+FNS_CODREL+FNS_TIPO+FNS_SEQ
		If FNS->(DBSeek(XFilial("FNS")+FNR->(FNR_IDMOV+FNR_CODREL)+SN3->(N3_TIPO+N3_SEQ)))
			lUsaFNS := .T.
		EndIf

	EndIf

EndIf

nUltIdMov := AF060IdMov(SN3->N3_CBASE,SN3->N3_ITEM)//Obtem o ultimo N4_IDMOV da transferencia contábil

//-------------------------------
// Busca a transferencia destino
//-------------------------------
DbSelectArea("SN4")
SN4->(DbSetOrder(6)) //N4_FILIAL+N4_IDMOV+N4_OCORR
If SN4->(DbSeek(XFilial("SN4")+nUltIdMov+"04"))

	//---------------------------------------------------------------------
	// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
	// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
	//---------------------------------------------------------------------
	While SN4->(!EOF()) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "04"

		//------------------------------------------------------------------------
		// Tratamento necessario para quando houver dois tipos iguais.
		// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
		// Na transferencia automatica (mais de um ativo) o IDMOV fica o mesmo
		//------------------------------------------------------------------------
		If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
			SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
			SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
			SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.;
			SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
			SN4->N4_SEQREAV	<> SN3->N3_SEQREAV  .Or.;
			(!lUsaFNS .And. !Empty(cIdMovFNR)) //Caso não encontre FNS e esteja usando FNR, dá looping pois o tipo item foi transferido em outro movimento

			SN4->(DBSkip())
			Loop
		Else
			Exit
		EndIf

	SN4->(DBSkip())
	EndDo

	If lPrim .And. (nHdlPrv <= 0)
		nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
		lPrim := .F.
	Endif


	//-------------------------------------------------------------
	// Contabilização antes de estornar os dados - (N4_OCORR = 04)
	//-------------------------------------------------------------
	If lLP83A

		CUSTO		:= "" //Centro de Custo de Despesa (N3_CCUSTO)

		//-----------------------------------
		// Bem
		//-----------------------------------
		CTABEM		:= ""	//Conta Contábil do Bem (N3_CCONTAB)
		CUSTBEMCTB	:= ""	//Centro de Custo do Bem (N3_CUSTBEM)
		SUBCCONCTB	:= ""	//Item Contábil do Bem (N3_SUBCCON)
		CLVLCONCTB	:= ""	//Classe de Valor do Bem (N3_CLVLCON)

		//-----------------------------------
		// Correcao Monetaria
		//-----------------------------------
		CORREBEM	:= ""	//Conta Contábil de Correcao do Bem (N3_CCORREC)
		CCCORRCTB	:= ""	//Centro de Custo de Correção monetária (N3_CCCORR)
		SUBCCORCTB	:= ""	//Item Contábil de Correcao Monetaria (N3_SUBCCOR)
		CLVLCORCTB	:= ""	//Classe de Valor de Correção Monetaria (N3_CLVLCOR)

		//-----------------------------------
		// Despesa Depreciação
		//-----------------------------------
		DESPDEPR	:= ""	//Conta Contábil de Despesa de Depreciacao (N3_CDEPREC)
		CCDESPCTB	:= ""	//Centro de Custo de Despesa de Depreciacao (N3_CCDESP)
		SUBCDEPCTB	:= ""	//Item Contábil de Despesa Depreciacao (N3_SUBCDEP)
		CLVLDEPCTB	:= ""	//Classe de Valor de Despesa de Depreciacao (N3_CLVLDEP)

		//-----------------------------------
		// Depreciação Acumulada
		//-----------------------------------
		DEPREACUM	:= ""	//Conta Contábil de Deprecicao Acumulada (N3_CCDEPR)
		CCCDEPCTB	:= ""	//Centro de Custo de Depreciação Acumulada (N3_CCCDEP)
		SUBCCDECTB	:= ""	//Item Contábil de Depreciacao Acumulada (N3_SUBCCDE)
		CLVLCDECTB	:= ""	//Classe de Valor de Depreciacao Acumulada (N3_CLVLCDE)

		//-----------------------------------
		// Depreciação de Correção Monetária
		//-----------------------------------
		CORREDEPR	:= ""	//Conta Contábil de Correcao de Depreciacao (N3_CDESP)
		CCCDESCTB	:= ""	//Centro de Custo de Correção da Depreciação (N3_CCCDES)
		SUBCDESCTB	:= ""	//Item Contábil de Correcao Depreciacao (N3_SUBCDES)
		CLVLDESCTB	:= ""	//Classe de Valor de Correcao Depreciacao (N3_CLVLDES)

		If lUsaFNS

			//-------------------------------------------------------------------------------------------------------------
			// Neste ponto implementaram a carga das variaveis privates os dados de origem, quando o certo seria o cliente
			// utilizar o LP 83B, este trecho foi preservado para não gerar colateral nos clientes orientados desta forma
			//-------------------------------------------------------------------------------------------------------------

			If !Empty(FNR->FNR_GRPORI)
				SNG->( DBSeek( XFilial( "SNG",FNR->FNR_FILORI) + FNR->FNR_GRPORI ) )
			EndIf

			//----------------
			// Conta Contabil
			//----------------
			CTABEM    := FNS->FNS_CONTAO //Bem (N3_CCONTAB)
			CORREBEM  := FNS->FNS_CONCOO //Correcao do Bem (N3_CCORREC)
			DESPDEPR  := FNS->FNS_CONDDO //Despesa de Depreciacao (N3_CDEPREC)
			DEPREACUM := FNS->FNS_CONDAO //Deprecicao Acumulada (N3_CCDEPR)
			CORREDEPR := FNS->FNS_CONCDO //Correcao de Depreciacao (N3_CDESP)

			//-----------------
			// Centro de Custo
			//-----------------
			CUSTO      := FNS->FNS_CCDESO //Despesa (N3_CCUSTO)
			CUSTBEMCTB := FNS->FNS_CCBEMO //Bem (N3_CUSTBEM)
			CCCORRCTB  := FNS->FNS_CCCORO //Correção monetária (N3_CCCORR)
			CCDESPCTB  := FNS->FNS_CCDDO  //Despesa de Depreciacao (N3_CCDESP)
			CCCDEPCTB  := FNS->FNS_CCDAO  //Depreciação Acumulada (N3_CCCDEP)
			CCCDESCTB  := FNS->FNS_CCCDO  //Correção da Depreciação (N3_CCCDES)

			//---------------
			// Item Contábil
			//---------------
			SUBCCONCTB := FNS->FNS_ITBEMO //Bem (N3_SUBCCON)
			SUBCCORCTB := FNS->FNS_ITCORO //Correcao Monetaria (N3_SUBCCOR)
			SUBCDEPCTB := FNS->FNS_ITDEDO //Despesa Depreciacao (N3_SUBCDEP)
			SUBCCDECTB := FNS->FNS_ITDEAO //Depreciacao Acumulada (N3_SUBCCDE)
			SUBCDESCTB := FNS->FNS_ITCDEO //Correcao Depreciacao (N3_SUBCDES)

			//-----------------
			// Classe de Valor
			//-----------------
			CLVLCONCTB := FNS->FNS_CVBEMO //Bem (N3_CLVLCON)
			CLVLCORCTB := FNS->FNS_CVCORO //Correção Monetaria (N3_CLVLCOR)
			CLVLDEPCTB := FNS->FNS_CVDEPO //Despesa de Depreciacao (N3_CLVLDEP)
			CLVLCDECTB := FNS->FNS_CVCDEO //Depreciacao Acumulada (N3_CLVLCDE)
			CLVLDESCTB := FNS->FNS_CVDESO //Correcao Depreciacao (N3_CLVLDES)

		Else

			//----------------------------------------------------------------------------------------------------
			// Este trecho deverá ser retirado futuramente, pois os clientes migrados (P11 para P12) já possuirão
			// os ultimos movimentos na FNR e FNS, não sendo necessário utilizar a SN4. Sabendo-se que após as
			// depreciações não é possivel cancelar transferencia contábil ou fisica.
			//----------------------------------------------------------------------------------------------------

			nRecNoSN4 := SN4->( RecNo() )

			//-------------------------------------------------------------------------------------------------------------------------------
			// Neste ponto implementaram um posicionamento na origem para carregar nas variaveis privates os dados de origem, quando o certo
			// seria o cliente utilizar o LP 83B, este trecho foi preservado para não gerar colateral nos clientes orientados desta forma...
			//-------------------------------------------------------------------------------------------------------------------------------
			If SN4->( DbSeek( xFilial("SN4") + nUltIdMov + "03" ) )

				CUSTO := SN3->N3_CCUSTO

				//Popula as variáveis de contabilização antes do cancelamento ser efetuado
				//---------------------------------------------------------------------
				// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
				// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
				//---------------------------------------------------------------------
				While !SN4->( Eof() ) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "03"

					//------------------------------------------------------------------------
					// Tratamento necessario para quando houver dois tipos iguais.
					// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
					//------------------------------------------------------------------------
					If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
						SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
						SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
						SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.;
						SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
						SN4->N4_SEQREAV	<> SN3->N3_SEQREAV

						SN4->(DBSkip())
						Loop

					EndIf

					Do Case

						Case SN4->N4_TIPOCNT == "1" //Bem
							CTABEM		:= SN4->N4_CONTA	//Conta Contábil do Bem (N3_CCONTAB)
							CUSTBEMCTB	:= SN4->N4_CCUSTO	//Centro de Custo do Bem (N3_CUSTBEM)
							SUBCCONCTB	:= SN4->N4_SUBCTA	//Item Contábil do Bem (N3_SUBCCON)
							CLVLCONCTB	:= SN4->N4_CLVL		//Classe de Valor do Bem (N3_CLVLCON)

						Case SN4->N4_TIPOCNT == "2" //Correcao Monetaria
							CORREBEM	:= SN4->N4_CONTA	//Conta Contábil de Correcao do Bem (N3_CCORREC)
							CCCORRCTB	:= SN4->N4_CCUSTO	//Centro de Custo de Correção monetária (N3_CCCORR)
							SUBCCORCTB	:= SN4->N4_SUBCTA	//Item Contábil de Correcao Monetaria (N3_SUBCCOR)
							CLVLCORCTB	:= SN4->N4_CLVL		//Classe de Valor de Correção Monetaria (N3_CLVLCOR)

						Case SN4->N4_TIPOCNT == "3" //Despesa Depreciação
							DESPDEPR	:= SN4->N4_CONTA	//Conta Contábil de Despesa de Depreciacao (N3_CDEPREC)
							CCDESPCTB	:= SN4->N4_CCUSTO	//Centro de Custo de Despesa de Depreciacao (N3_CCDESP)
							SUBCDEPCTB	:= SN4->N4_SUBCTA	//Item Contábil de Despesa Depreciacao (N3_SUBCDEP)
							CLVLDEPCTB	:= SN4->N4_CLVL		//Classe de Valor de Despesa de Depreciacao (N3_CLVLDEP)

						Case SN4->N4_TIPOCNT == "4" //Depreciação Acumulada
							DEPREACUM	:= SN4->N4_CONTA	//Conta Contábil de Deprecicao Acumulada (N3_CCDEPR)
							CCCDEPCTB	:= SN4->N4_CCUSTO	//Centro de Custo de Depreciação Acumulada (N3_CCCDEP)
							SUBCCDECTB	:= SN4->N4_SUBCTA	//Item Contábil de Depreciacao Acumulada (N3_SUBCCDE)
							CLVLCDECTB	:= SN4->N4_CLVL		//Classe de Valor de Depreciacao Acumulada (N3_CLVLCDE)

						Case SN4->N4_TIPOCNT == "5" //Depreciação de Correção Monetária
							CORREDEPR	:= SN4->N4_CONTA	//Conta Contábil de Correcao de Depreciacao (N3_CDESP)
							CCCDESCTB	:= SN4->N4_CCUSTO	//Centro de Custo de Correção da Depreciação (N3_CCCDES)
							SUBCDESCTB	:= SN4->N4_SUBCTA	//Item Contábil de Correcao Depreciacao (N3_SUBCDES)
							CLVLDESCTB	:= SN4->N4_CLVL		//Classe de Valor de Correcao Depreciacao (N3_CLVLDES)

					EndCase

				SN4->(DbSkip())
				EndDo
			EndIf

			SN4->( DbGoTo( nRecNoSN4 ) )

		EndIf
		//ARMAZENO O RECNO DO PRIMEIRO REGISTRO
		nRecNoSN4 := SN4->( RecNo() )
		While !SN4->( Eof() ) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "04"
			//LAÇO PARA CONTABILIZAÇÃO DE TODAS AS CONTAS ANTES DA DELEÇÃO
			nTotal += DetProva( nHdlPrv,"83A","ATFA060",cLoteAtf)
			SN4->(DbSkip())
		EndDo
		SN4->( DbGoTo(nRecNoSN4))

	Endif

	//---------------------------------------------------------------------
	// Deleta os movimentos no destino N4_OCORR = 04
	//---------------------------------------------------------------------
	// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
	// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
	//---------------------------------------------------------------------
	While SN4->(!EOF()) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "04"

		//------------------------------------------------------------------------
		// Tratamento necessario para quando houver dois tipos iguais .
		// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
		//------------------------------------------------------------------------
		If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
			SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
			SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
			SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.;
			SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
			SN4->N4_SEQREAV	<> SN3->N3_SEQREAV

			SN4->(DBSkip())
			Loop

		EndIf

		If lIntMnt .And. FindFunction("A550VLDCAN") .And. SN4->N4_OCORR == '04' .And. SN4->N4_TIPOCNT == '1'  .And. !Empty(SN1->N1_CODBEM)
			nRecno := SN4->(Recno())
			If SN3->N3_CBASE <> cBase
				aRet := A550VLDCAN(SN1->N1_CODBEM, SN1->N1_CBASE, SN4->N4_DATA, SN4->N4_HORA,/*FilOri*/,/*FilDest*/,.T.)
				If !aRet[1]
					cLogErro := aRet[2]
					DisarmTransaction()
					Break
				EndIf
				cBase := SN3->N3_CBASE
			EndIf
			SN4->(DbGoTo(nRecno))
		EndIf
		RecLock("SN4",.F.,.T.)
		SN4->(DBDelete())
		SN4->(MSUnlock())

	SN4->(DbSkip())
	EndDo

	// Verificação da classificação de Ativo se sofre depreciação
	lAtClDepr := AtClssVer(SN1->N1_PATRIM)

	//----------------------------
	// Trata contas patrimoniais
	//----------------------------
	If lAtClDepr .OR. EMPTY(SN1->N1_PATRIM)
		cTipoTrDe  := "8"
		cTipoTrPara:= "9"
	ElseIf SN1->N1_PATRIM $ "CAS"
		cTipoTrDe  := "G"
		cTipoTrPara:= "I"
	Else
		cTipotrDe  := "H"
		cTipotrPara:= "J"
	EndIf

	//---------------------------------------------------------------------
	// Atualiza conta no cancelamento da transferencia de contas - Origem
	// Controle de multiplas moedas
	//---------------------------------------------------------------------

	If ! EMPTY(SN3->N3_CCORREC)
		If(lMultMoed)
			aValorMoed := AtfMultMoe(,,{|x| IIf(x==1,SN3->N3_VRCACM1,0) })
		EndIf

		ATFSaldo(SN3->N3_CCORREC, dDataTrans, cTipoTrDe,SN3->N3_VRCACM1,0,0,0,0 ,"+",nTaxaMedia,SN3->N3_SUBCCOR,,SN3->N3_CLVLCOR,SN3->N3_CCCORR,"2", aValorMoed)
	EndIf

	aAtuSal[1] := SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1
	For nI := 2 To __nQuantas
		cMoed := Alltrim(Str(nI))
		aAtuSal[nI] := SN3->&("N3_VORIG"+cMoed)+SN3->&(If(nI>9,"N3_AMPLI","N3_AMPLIA")+cMoed)
	Next nI

	ATFSaldo(SN3->N3_CCONTAB, dDataTrans, cTipoTrDe,aAtuSal[1],aAtuSal[2],aAtuSal[3],;
	aAtuSal[4],aAtuSal[5],"+", nTaxaMedia,SN3->N3_SUBCCON,,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1", aAtuSal )

	/*Conta desp dep SN3->N3_CDEPREC*/
	If ! Empty(SN3->N3_CDEPREC)	//se tem desp deprec e somente na origem, pois no destino ele entra no IF DO valor acumulado
		If(lMultMoed)  // Controle de multiplas moedas
			aValorMoed := AtfMultMoe(,,{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x))) + IIf(x=1,SN3->N3_VRCDA1,0) })
		EndIf
		ATFSaldo(SN3->N3_CDEPREC , dDataTrans, cTipoTrDe,SN3->(N3_VRDACM1+N3_VRCDA1),SN3->N3_VRDACM2,;
				SN3->N3_VRDACM3,SN3->N3_VRDACM4,SN3->N3_VRDACM5,"+", nTaxaMedia,SN3->N3_SUBCCDE,,SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"3",aValorMoed )

	EndIf

	If ! Empty(SN3->N3_CCDEPR)		// Controle de multiplas moedas
		If(lMultMoed)
			aValorMoed := AtfMultMoe(,,{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x))) + IIf(x=1,SN3->N3_VRCDA1,0) })
		EndIf

		ATFSaldo(SN3->N3_CCDEPR , dDataTrans, cTipoTrDe,SN3->(N3_VRDACM1+N3_VRCDA1),SN3->N3_VRDACM2,;
				SN3->N3_VRDACM3,SN3->N3_VRDACM4,SN3->N3_VRDACM5,"+", nTaxaMedia,SN3->N3_SUBCCDE,,SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"4",aValorMoed )

	EndIf

	If ! Empty(SN3->N3_CDESP) // Controle de multiplas moedas  *
		If(lMultMoed)
			aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,SN3->N3_VRCDA1,0) })
		EndIf

		ATFSaldo(SN3->N3_CDESP  , dDataTrans, cTipoTrDe,SN3->N3_VRCDA1,0,0,0,0 ,"+",nTaxaMedia,	SN3->N3_SUBCDES,,SN3->N3_CLVLDES,SN3->N3_CCCDES,"5", aValorMoed )
	EndIf

EndIf

	//------------------------------------------------------------
	// Restaura e contabiliza os dados na Origem - N4_OCORR = 03
	//------------------------------------------------------------

	//-------------------------------------------------------------------------------------------
	// Utiliza a FNS para retornar os dados pois a SN4 além de depender da geração do N4_TIPOCNT
	// não possui o centro de custo de despesa (N3_CCUSTO)
	//-------------------------------------------------------------------------------------------
	If lUsaFNS

		RecLock("SN3",.F.)

			//Conta
			SN3->N3_CCONTAB	:= FNS->FNS_CONTAO
			SN3->N3_CCORREC	:= FNS->FNS_CONCOO
			SN3->N3_CDEPREC	:= FNS->FNS_CONDDO
			SN3->N3_CCDEPR	:= FNS->FNS_CONDAO
			SN3->N3_CDESP	:= FNS->FNS_CONCDO

			//Centro de Custo
			SN3->N3_CCUSTO	:= FNS->FNS_CCDESO
			SN3->N3_CUSTBEM	:= FNS->FNS_CCBEMO
			SN3->N3_CCCORR	:= FNS->FNS_CCCORO
			SN3->N3_CCDESP	:= FNS->FNS_CCDDO
			SN3->N3_CCCDEP	:= FNS->FNS_CCDAO
			SN3->N3_CCCDES	:= FNS->FNS_CCCDO

			//Item Contabil
			SN3->N3_SUBCCON	:= FNS->FNS_ITBEMO
			SN3->N3_SUBCDEP	:= FNS->FNS_ITDEDO
			SN3->N3_SUBCCDE	:= FNS->FNS_ITDEAO
			SN3->N3_SUBCDES	:= FNS->FNS_ITCDEO
			SN3->N3_SUBCCOR	:= FNS->FNS_ITCORO
			If lSCDP
				If lCmpDesp
					SN3->N3_SUBCTA	:= FNS->FNS_ITDESO
					SN3->N3_SUBCDEP	:= FNS->FNS_ITDESO
				Else
					SN3->N3_SUBCTA	:= FNS->FNS_ITDEDO
				EndIf
			Else
				If lCmpDesp
					SN3->N3_SUBCTA	:= FNS->FNS_ITDESO
				EndIf
			EndIf

			//Classe de Valor
			SN3->N3_CLVLCON	:= FNS->FNS_CVBEMO
			SN3->N3_CLVLDEP	:= FNS->FNS_CVDEPO
			SN3->N3_CLVLCDE	:= FNS->FNS_CVCDEO
			SN3->N3_CLVLDES	:= FNS->FNS_CVDESO
			SN3->N3_CLVLCOR	:= FNS->FNS_CVCORO

			If lCVDP
				If lCmpDesp
					SN3->N3_CLVLDEP	:= FNS->FNS_CVDSPO
					SN3->N3_CLVL := FNS->FNS_CVDSPO
				Else
					SN3->N3_CLVL := FNS->FNS_CVDEPO
				EndIf
			Else
				If lCmpDesp
					SN3->N3_CLVL := FNS->FNS_CVDSPO
				EndIf
			EndIf

			//Entidades Adicionais
			If Len(__aCTBEnt) > 0 .AND. __lEntAdd
				For nContEnt := 1 to Len(__aCTBEnt)
					SN3->&("N3_EC"+__aCTBEnt[nContEnt]+"DB") := FNS->&("FNS_EC"+__aCTBEnt[nContEnt]+"DO")
					SN3->&("N3_EC"+__aCTBEnt[nContEnt]+"CR") := FNS->&("FNS_EC"+__aCTBEnt[nContEnt]+"CO")
				Next nContEnt
			EndIf

		SN3->(MsUnlock())

		//--------------------------------
		// Estorno da taxa de depreciacao
		//--------------------------------
		If !Empty(FNR->FNR_TXPADD) .And. FNR->FNR_TXPADO != FNR->FNR_TXPADD

			DbSelectArea("SN4")
			SN4->(DbSetOrder(6)) //N4_FILIAL+N4_IDMOV+N4_OCORR
			If SN4->(DbSeek(XFilial("SN4")+nUltIdMov+"03"))

				//---------------------------------------------------------------------
				// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
				// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
				//---------------------------------------------------------------------
				While SN4->(!EOF()) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "03"

					//------------------------------------------------------------------------
					// Tratamento necessario para quando houver dois tipos iguais.
					// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
					//------------------------------------------------------------------------
					If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
						SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
						SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
						SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.;
						SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
						SN4->N4_SEQREAV	<> SN3->N3_SEQREAV

						SN4->(DBSkip())
						Loop

					Else
						nN4_TXDEPR := SN4->N4_TXDEPR
						Exit
					EndIf

				SN4->(DBSkip())
				EndDo

			EndIf

			If !Empty(nN4_TXDEPR)
				nTxDepr := nN4_TXDEPR
			ElseIf !Empty(FNR->FNR_TXPADO)
				nTxDepr := GetAdvFval("SNH","NH_TAXA",xFilial("SNH")+FNR->FNR_TXPADO,1,SN3->N3_TXDEPR1)
			EndIf

			If nTxDepr <> SN3->N3_TXDEPR1
				Reclock("SN3",.F.)
					AtfMultMoe("SN3","N3_TXDEPR",{|x| nTxDepr})
				SN3->(MSUnlock())
			EndIf

		EndIf

	Else

		//----------------------------------------------------------------------------------------------------
		// Este trecho deverá ser retirado futuramente, pois os clientes migrados (P11 para P12) já possuirão
		// os ultimos movimentos na FNR e FNS, não sendo necessário utilizar a SN4. Sabendo-se que após as
		// depreciações não é possivel cancelar transferencia contábil ou fisica.
		//----------------------------------------------------------------------------------------------------

		DbSelectArea("SN4")
		SN4->(DbSetOrder(6)) //N4_FILIAL+N4_IDMOV+N4_OCORR
		If SN4->(DbSeek(XFilial("SN4")+nUltIdMov+"03"))

			//---------------------------------------------------------------------
			// Restabelece as contas originais do registro da SN3
			//---------------------------------------------------------------------
			// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
			// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
			//---------------------------------------------------------------------
			While SN4->(!EOF()) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "03"

				//------------------------------------------------------------------------
				// Tratamento necessario para quando houver dois tipos iguais .
				// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
				//------------------------------------------------------------------------
				If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
					SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
					SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
					SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.;
					SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
					SN4->N4_SEQREAV	<> SN3->N3_SEQREAV

					SN4->(DBSkip())
					Loop

				EndIf

				RecLock("SN3",.F.)

					Do Case

						Case SN4->N4_TIPOCNT == "1" //Bem
							SN3->N3_CCONTAB	:= SN4->N4_CONTA
							SN3->N3_CUSTBEM	:= SN4->N4_CCUSTO
							SN3->N3_SUBCCON	:= SN4->N4_SUBCTA
							SN3->N3_CLVLCON	:= SN4->N4_CLVL

						Case SN4->N4_TIPOCNT == "2" //Correcao Monetaria
							SN3->N3_CCORREC	:= SN4->N4_CONTA
							SN3->N3_CCCORR	:= SN4->N4_CCUSTO
							SN3->N3_CCUSTO	:= SN4->N4_CCUSTO
							SN3->N3_SUBCCOR	:= SN4->N4_SUBCTA
							SN3->N3_CLVLCOR	:= SN4->N4_CLVL

						Case SN4->N4_TIPOCNT == "3" //Despesa Depreciação
							SN3->N3_CDEPREC	:= SN4->N4_CONTA
							SN3->N3_CCDESP	:= SN4->N4_CCUSTO
							SN3->N3_CCUSTO	:= SN4->N4_CCUSTO
							SN3->N3_SUBCDEP	:= SN4->N4_SUBCTA
							SN3->N3_CLVLDEP	:= SN4->N4_CLVL

						Case SN4->N4_TIPOCNT == "4" //Depreciação Acumulada
							SN3->N3_CCDEPR	:= SN4->N4_CONTA
							SN3->N3_CCCDEP	:= SN4->N4_CCUSTO
							SN3->N3_SUBCCDE	:= SN4->N4_SUBCTA
							SN3->N3_CLVLCDE	:= SN4->N4_CLVL

						Case SN4->N4_TIPOCNT == "5" //Depreciação de Correção Monetária
							SN3->N3_CDESP	:= SN4->N4_CONTA
							SN3->N3_CCCDES	:= SN4->N4_CCUSTO
							SN3->N3_SUBCDES	:= SN4->N4_SUBCTA
							SN3->N3_CLVLDES	:= SN4->N4_CLVL

					EndCase

				SN3->(MsUnlock())

			SN4->(DbSkip())
			EndDo

		EndIf

	EndIf

	If lAF060CCTB
		Execblock("AF060CCTB",.F.,.F.)
	EndIf

	//--------------------------------------------------------------------
	// Posiciona na SN4 para contabilização antes de deletar os registros
	//--------------------------------------------------------------------
	DbSelectArea("SN4")
	SN4->(DbSetOrder(6)) //N4_FILIAL+N4_IDMOV+N4_OCORR
	If SN4->(DbSeek(XFilial("SN4")+nUltIdMov+"03"))

		//---------------------------------------------------------------------
		// Deleta o movimento origem 03
		//---------------------------------------------------------------------
		// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
		// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
		//---------------------------------------------------------------------
		While SN4->(!EOF()) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "03"

			//------------------------------------------------------------------------
			// Tratamento necessario para quando houver dois tipos iguais .
			// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
			//------------------------------------------------------------------------
			If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
				SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
				SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
				SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.;
				SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
				SN4->N4_SEQREAV	<> SN3->N3_SEQREAV  .Or.;
				(!lUsaFNS .And. !Empty(cIdMovFNR)) //Caso não encontre FNS e esteja usando FNR, dá looping pois o tipo item foi transferido em outro movimento

				SN4->(DBSkip())
				Loop

			EndIf

			//---------------------------
			// Contabilização da origem
			//---------------------------
			If lLP83B
				nTotal += DetProva( nHdlPrv,"83B","ATFA060",cLoteAtf)
			Endif

			RecLock("SN4",.F.,.T.)
			SN4->(DbDelete())
			SN4->(MsUnlock())
		SN4->(DbSkip())
		EndDo
	EndIf

	If ! EMPTY(SN3->N3_CCORREC)
		If(lMultMoed)
			aValorMoed := AtfMultMoe(,,{|x| IIf(x==1,SN3->N3_VRCACM1,0) })
		EndIf

		ATFSaldo(SN3->N3_CCORREC, dDataTrans, cTipoTrPara,SN3->N3_VRCACM1,0,0,0,0 ,"+",nTaxaMedia,SN3->N3_SUBCCOR,,SN3->N3_CLVLCOR,SN3->N3_CCCORR,"2", aValorMoed)
	EndIf

	//---------------------------------------------------------------------
	// Atualiza conta no cancelamento da transferencia de contas - Destino
	// Controle de multiplas moedas
	//---------------------------------------------------------------------
	aAtuSal[1] := SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1
	For nI := 2 To __nQuantas
		cMoed := Alltrim(Str(nI))
		aAtuSal[nI] := SN3->&("N3_VORIG"+cMoed)+SN3->&(If(nI>9,"N3_AMPLI","N3_AMPLIA")+cMoed)
	Next nI

	ATFSaldo(SN3->N3_CCONTAB, dDataTrans, cTipoTrPara,aAtuSal[1],aAtuSal[2],aAtuSal[3],;
	aAtuSal[4],aAtuSal[5],"+", nTaxaMedia,SN3->N3_SUBCCON,,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1", aAtuSal )

	/*Conta desp dep SN3->N3_CDEPREC*/
	If ! Empty(SN3->N3_CDEPREC)	//se tem desp deprec e somente na origem, pois no destino ele entra no IF DO valor acumulado
		If(lMultMoed)  // Controle de multiplas moedas
			aValorMoed := AtfMultMoe(,,{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x))) + IIf(x=1,SN3->N3_VRCDA1,0) })
		EndIf
		ATFSaldo(SN3->N3_CDEPREC , dDataTrans, cTipoTrPara,SN3->(N3_VRDACM1+N3_VRCDA1),SN3->N3_VRDACM2,;
				SN3->N3_VRDACM3,SN3->N3_VRDACM4,SN3->N3_VRDACM5,"+", nTaxaMedia,SN3->N3_SUBCCDE,,SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"3",aValorMoed )

	EndIf

	If ! Empty(SN3->N3_CCDEPR)		// Controle de multiplas moedas
		If(lMultMoed)
			aValorMoed := AtfMultMoe(,,{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x))) + IIf(x=1,SN3->N3_VRCDA1,0) })
		EndIf

		ATFSaldo(SN3->N3_CCDEPR , dDataTrans, cTipoTrPara,SN3->(N3_VRDACM1+N3_VRCDA1),SN3->N3_VRDACM2,;
				SN3->N3_VRDACM3,SN3->N3_VRDACM4,SN3->N3_VRDACM5,"+", nTaxaMedia,SN3->N3_SUBCCDE,,SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"4",aValorMoed )

	EndIf

	If ! Empty(SN3->N3_CDESP) // Controle de multiplas moedas  *
		If(lMultMoed)
			aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,SN3->N3_VRCDA1,0) })
		EndIf

		ATFSaldo(SN3->N3_CDESP  , dDataTrans, cTipoTrPara,SN3->N3_VRCDA1,0,0,0,0 ,"+",nTaxaMedia,	SN3->N3_SUBCDES,,SN3->N3_CLVLDES,SN3->N3_CCCDES,"5", aValorMoed )
	EndIf

RestArea(aAreaSNG)
RestArea(aAreaSN4)
RestArea(aAreaSN3)
RestArea(aArea)

Return Nil

/*{Protheus.doc} AF060IdMov
Query para obter o ultimo movimento de transferencia que ocorreu para o bem
é considerado somente os campos N4_CBASE e N4_ITEM pois a última transferencia
pode ter ocorrido para somente um dos tipos de saldo do bem (ex transf contabil).

@author Totvs
@since 15/10/2014
@version 12.0
*/
Static Function AF060IdMov(cBase,cItem)
Local aArea		:= GetArea()
Local cUltIdMov	:= ""
Local cQuery	:= ""
Local cAliasQry	:= GetNextAlias()

Default cBase	:= ""
Default cItem	:= ""

If Select(cAliasQry) > 0
	(cAliasQry)->(dbCloseArea())
EndIf

cQuery := " SELECT "												+CRLF
cQuery +=		" MAX(N4_IDMOV) N4_IDMOV "							+CRLF
cQuery += " FROM " + RetSqlName("SN4") + " SN4 "					+CRLF
cQuery += " WHERE "													+CRLF
cQuery +=		" SN4.N4_FILIAL  = '" + xFilial("SN4")+"' "			+CRLF
cQuery +=		" AND SN4.N4_CBASE   = '" + cBase    + "' "			+CRLF
cQuery +=		" AND SN4.N4_ITEM    = '" + cItem    + "' "			+CRLF
cQuery +=		" AND SN4.N4_OCORR   = '04' "						+CRLF
cQuery +=		" AND SN4.N4_FILORIG = '" + SN3->N3_FILORIG + "' "	+CRLF
cQuery +=		" AND SN4.D_E_L_E_T_ = '' "							+CRLF
cQuery := ChangeQuery(cQuery)

DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

If (cAliasQry)->(!EOF())
	cUltIdMov := (cAliasQry)->N4_IDMOV
EndIf

(cAliasQry)->(DbCloseArea())

RestArea(aArea)

Return cUltIdMov

/*{Protheus.doc} ATF060VTR
Visualização da Transferencia do Ativo
@author José Augusto Ribeiro
@since 014/09/2015
@version P12
*/
Function ATF060VTR()
Local aArea		:= GetArea()
Local cTMPFNR	:= GetNextAlias()
Local cAux		:= ""
Local cFilAux	:= ""
Local cFilBkp	:= cFilAnt

//--------------------------------------------------------------------
// Query pra buscar o ultimo movimento do bem posicionado como Origem
//--------------------------------------------------------------------
BeginSql Alias cTMPFNR
	SELECT MAX(FNR_IDMOV) FNR_IDMOV, FNR_FILORI
	FROM %Table:FNR%
	WHERE	FNR_FILORI = %Exp:cFilAnt%
			AND FNR_CBAORI = %Exp:SN3->N3_CBASE%
			AND FNR_ITEORI = %Exp:SN3->N3_ITEM%
			AND FNR_STATUS = '1'
			AND %NotDel%
	GROUP BY FNR_FILORI
EndSql

If (cTMPFNR)->(!EOF())
   cAux		:= (cTMPFNR)->FNR_IDMOV
   cFilAux	:= (cTMPFNR)->FNR_FILORI
EndIf

//--------------------------------------------------------------
// Caso não encontre como origem, procura como destino, pois o
// cliente pode ter posicionado no resultado da transferencia
//--------------------------------------------------------------
If Empty(cAux)

	If Select(cTMPFNR) > 0
		(cTMPFNR)->(DBCloseArea())
	EndIf

	cTMPFNR := GetNextAlias()

	BeginSql Alias cTMPFNR
		SELECT MAX(FNR_IDMOV) FNR_IDMOV, FNR_FILORI
		FROM %Table:FNR%
		WHERE	FNR_FILDES = %Exp:cFilAnt%
				AND FNR_CBADES = %Exp:SN3->N3_CBASE%
				AND FNR_ITEDES = %Exp:SN3->N3_ITEM%
				AND FNR_STATUS = '1'
				AND %NotDel%
		GROUP BY FNR_FILORI
	EndSql

	If (cTMPFNR)->(!EOF())
		cAux	:= (cTMPFNR)->FNR_IDMOV
		cFilAux	:= (cTMPFNR)->FNR_FILORI
	EndIf

EndIf

(cTMPFNR)->(DBCloseArea())

If !Empty(cAux)

	DBSelectArea("FN9")
	FN9->(DBSetOrder(1))

	DBSelectArea("FNR")
	FNR->(DBSetOrder(1))

	DBSelectArea("FNS")
	FNS->(DBSetOrder(1))

	If	FN9->(DBSeek(XFilial("FN9",cFilAux)+cAux)) .And.;
		FNR->(DBSeek(XFilial("FNR",cFilAux)+cAux)) .And.;
		FNS->(DBSeek(XFilial("FNS",cFilAux)+cAux))

		lVisu := .T.

		//-------------------------------------------------------------------------------------------------------------------
		// A manipulação do cFilAnt é necessaria devido o FWExecView não exibir os dados mesmo com os registros posicionados
		// (FN9, FNR e FNS exclusivos), na transferencia entre filiais ao visualiar a transferencia do ativo no destino
		//-------------------------------------------------------------------------------------------------------------------
		cFilAnt := cFilAux

		FWExecView("Visualização da Transferencia" ,'ATFA060',	MODEL_OPERATION_VIEW,/*oDlg*/,{ || .T. })

		cFilAnt := cFilBkp

		lVisu := .F.

	Else
		Help(" ",1, "AF060VTR",,STR0158,1,0) //"Não foi locazida nenhuma transferência do Bem."
	EndIf

Else
	Help(" ",1, "AF060VTR",,STR0158,1,0) //"Não foi locazida nenhuma transferência do Bem."
EndIf

RestArea(aArea)

Return

/*{Protheus.doc}ATFA060Vis
Abre a visualizacao do cadastro do bem - ATFA012
@author Totvs
@since 26/06/2015
@version P12
*/
Function ATFA060Vis()
Local aArea := GetArea()

DbSelectArea("SN1")
SN1->(DbSetOrder(1)) //Filial + Código Base + Item
SN1->(DbSeek( FWxFilial("SN1") + SN3->N3_CBASE + SN3->N3_ITEM ) )

SaveInter() //Necessario pois a abertura da ATFA012 muda os valores dos parametros

FWExecView(STR0151,'ATFA012',MODEL_OPERATION_VIEW,/*oDlg*/,{||.T.}) //"Visualização da Ficha de Ativo"

RestInter()

RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} AF060ExNFE

Exclusao da Nota Fiscal de Entrada

@author Totvs
@since 05/07/2015
@version 12
/*/
//-------------------------------------------------------------------
Function AF060ExNFE(cFilOrig As Character, cNota As Character, cSerie As Character) As Logical

Local aArea		As Array	
Local aAreaSF1	As Array
Local cCNPJFor	As Character
Local cF1_DOC	As Character
Local cF1_SERIE	As Character
Local cF1_FORN	As Character
Local cF1_LOJA	As Character
Local cF1_TIPO	As Character
Local lRet		As Logical		
Local cChaveSF1	As Character
Local aCabNFE	As Array
Local aIteNFE	As Array
Local lPreNota	As Logical
Local aErro		As Array	
Local nX		As Numeric
Local cMsg		As Character
Local aAreaSN1 	As Array			

aArea				:= GetArea()
aAreaSF1			:= SF1->(GetArea())
cCNPJFor			:= GetAdvFVal("SM0","M0_CGC",cEmpAnt+cFilOrig,1,"")
cF1_DOC				:= PadR(cNota,TamSx3("F1_DOC")[1])
cF1_SERIE			:= PadR(cSerie,TamSX3("F1_SERIE")[1])
cF1_FORN			:= GetAdvFVal("SA2","A2_COD",XFilial("SA2") + PadR(cCNPJFor,TamSX3("A2_CGC")[1]),3,"")
cF1_LOJA			:= GetAdvFVal("SA2","A2_LOJA",XFilial("SA2") + PadR(cCNPJFor,TamSX3("A2_CGC")[1]),3,"")
cF1_TIPO			:= "N"
lRet				:= .T.
cChaveSF1			:= ""
aCabNFE				:= {}
aIteNFE				:= {}
lPreNota			:= .T.
aErro				:= {}
nX					:= 0
cMsg				:= ""
aAreaSN1    		:= SN1->(GetArea())

If !Empty(SN1->N1_FORNEC) .and. !Empty(SN1->N1_LOJA) //Pego os valores de fornecedor e loja do ativo gravados no momento da transferência
	cF1_FORN	:= SN1->N1_FORNEC
	cF1_LOJA    := SN1->N1_LOJA
Endif

//Controle de rotina automatica
Private lMsErroAuto		:= .F. //Determina se houve algum tipo de erro durante a execucao do ExecAuto
Private lMsHelpAuto		:= .T. //Define se mostra ou não os erros na tela (T= Nao mostra; F=Mostra)
Private lAutoErrNoFile	:= .F. //Habilita a gravacao de erro da rotina automatica

cChaveSF1 := XFilial("SF1") + cF1_DOC + cF1_SERIE + cF1_FORN + cF1_LOJA + cF1_TIPO

DbSelectArea("SF1")
SF1->(DbSetOrder(1)) //F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO
If SF1->(DbSeek(cChaveSF1))

	//Cabeçalho do Documento de Entrada
	Aadd(aCabNFE, {"F1_DOC"		,SF1->F1_DOC		,Nil})
	Aadd(aCabNFE, {"F1_SERIE"	,SF1->F1_SERIE		,Nil})
	Aadd(aCabNFE, {"F1_FORNECE"	,SF1->F1_FORNECE	,Nil})
	Aadd(aCabNFE, {"F1_LOJA"	,SF1->F1_LOJA		,Nil})
	Aadd(aCabNFE, {"F1_TIPO"	,SF1->F1_TIPO		,Nil})

	lPreNota := Empty(SF1->F1_STATUS) //Documento nao classificado, excluir pelo MATA140

Else
	lRet := .F.
	cMsg := STR0152 //"O documento de entrada não foi localizado para exclusão."
EndIf

If lRet

	If lPreNota	// Pré Nota - Exclusão do Documento de Entrada no MATA140
		MSExecAuto( { |x,y,z| MATA140(x,y,z) }, aCabNFE,aIteNFE,5 )
	Else // Documento Fiscal - Exclusão do Documento de Entrada no MATA103
		MSExecAuto( { |x,y,z| MATA103(x,y,z) }, aCabNFE,aIteNFE,5 )
	EndIf

	If lMsErroAuto
		aErro := GetAutoGrLog()
		cMsg := ""

		For nX := 1 To Len(aErro)
			cMsg += aErro[nX] + CRLF
		Next nX

		lRet := .F.
	EndIf
EndIf

RestArea(aAreaSN1)
RestArea(aAreaSF1)
RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} AF060ExNFS

Exclusao da Nota Fiscal de Saida

@author Totvs
@since 05/07/2015
@version 12
/*/
//-------------------------------------------------------------------
Function AF060ExNFS(cNumNFS,cSerie)
Local aAreaSF2	:= SF2->(GetArea())
Local aRegSD2		:= {}
Local aRegSE1		:= {}
Local aRegSE2		:= {}
Local lRet			:= .T.
Local lAglutCtb	:= .F.
Local lCtbOnLine	:= .F.

lAglutCtb		:= .F.//MV_PAR02 == 1
lCtbOnLine		:= .F.//MV_PAR03 == 1

SF2->(DbSetOrder(1))
If	SF2->(MsSeek(xFilial("SF2") + cNumNFS + cSerie, .F.))
	//-- Verifica se o estorno do documento de saida pode ser feito.
	If MaCanDelF2("SF2",SF2->(RecNo()),@aRegSD2,@aRegSE1,@aRegSE2)
		//-- Estorna o documento de saida.
		SF2->(MaDelNFS(aRegSD2,aRegSE1,aRegSE2,.F.,lAglutCtb,lCtbOnLine,.T.,,1))
	Else
		lRet := .F.
		Help(" ",1, "AF060ExNFS",,STR0153,1,0) //"Não é possivel cancelar a Nota Fiscal."
	EndIf
Else
	If !MsgYesNo(;
	STR0208 + xFilial("SF2") + STR0209 + cNumNFS + STR0210 + cSerie + STR0211 + CRLF + CRLF + ; //#Nota fiscal de saída: (Filial: "+xFilial("SF2")+", NF: "+cNumNFS+", Serie: "+cSerie+") não encontrada.
	STR0206 + CRLF + CRLF +;																	//#Deseja continuar com o cancelamento da transferência ?#
	STR0207, ;																					//#Após a confirmação, este processo não poderá ser desfeito.#
	STR0205)																					//#Atenção#
		lRet := .F.
		Help(" ",1, "AF060ExNFS",,STR0154,1,0) //"Nota Fiscal não localizada."
	Endif
EndIf

RestArea(aAreaSF2)

Return lRet

/*{Protheus.doc} AF060IDFNR
Query para obter o ultimo ID de Movimento do bem na FNR
@author Totvs
@since 05/07/2015
@version 12.0
*/
Function AF060IDFNR(cBase as Character,cItem as Character, cXFil_FNR as Character, nTpTransf as Numeric, lItemOri As Logical) as Character
Local aArea			as Array
Local cUltIdMov		as Character
Local cQuery		as Character
Local cAliasQry		as Character
Local nParam  := 1  as numeric
Local oQryExec      as Object

Default cBase	:= ""
Default cItem	:= ""
Default cXFil_FNR := ""
Default nTpTransf := 0
Default lItemOri  := .F.

aArea		:= GetArea()
cUltIdMov	:= ""
cQuery		:= ""
cAliasQry	:= GetNextAlias()

If Select(cAliasQry) > 0
	(cAliasQry)->(dbCloseArea())
EndIf

cQuery := " SELECT "													+CRLF
cQuery += 		" FNR_FILIAL FNR_FILIAL, " 								+CRLF
cQuery +=		" MAX(FNR_IDMOV) FNR_IDMOV "							+CRLF
cQuery += " FROM " + RetSqlName("FNR") + " FNR "						+CRLF
cQuery += " WHERE "														+CRLF

If(!FwIsInCallStack("ATF060VTR")) .and. nTpTransf == 1 //If para que seja possivel visualizar a transferencia na filial de origem
	cQuery +=	" FNR.FNR_FILDES  = ?  "	+CRLF
ELSE
	cQuery +=	" FNR.FNR_FILIAL  = ?  "	+CRLF
EndIf

cQuery +=		" AND FNR.FNR_CBADES  = ? "	+CRLF
If !lItemOri
	cQuery +=	" AND FNR.FNR_ITEDES = ? "	+CRLF
Else
	cQuery +=	" AND FNR.FNR_ITEORI = ? "  +CRLF
EndIf
cQuery +=		" AND FNR.FNR_STATUS = ? "  +CRLF
cQuery +=		" AND FNR.D_E_L_E_T_ = ? "	+CRLF

cQuery += 		" GROUP BY FNR_FILIAL "
cQuery := ChangeQuery(cQuery)

oQryExec := FWExecStatement():New(cQuery)

If(!FwIsInCallStack("ATF060VTR")) .and. nTpTransf == 1	
	oQryExec:SetString(nParam++, cFilAnt)
Else
	oQryExec:SetString(nParam++, FwxFilial("FNR"))
EndIf
oQryExec:SetString(nParam++, cBase)
oQryExec:SetString(nParam++, cItem)
oQryExec:SetString(nParam++, '1')
oQryExec:SetString(nParam++, Space(1))

cAliasQry := oQryExec:OpenAlias(GetNextAlias())

If (cAliasQry)->(!EOF())
   cUltIdMov := (cAliasQry)->FNR_IDMOV
   iIf (nTpTransf  == 1 ,cXFil_FNR := (cAliasQry)->FNR_FILIAL , cXFil_FNR := "") //PREMISSA FNR deve ter o mesmo compartilhamento das tabelas SN1, SN3, SN4.
EndIf

(cAliasQry)->(DbCloseArea())

RestArea(aArea)

FreeObj(oQryExec)

Return cUltIdMov

//--------------------------------------------------
/*/{Protheus.doc} A060Mexec
Macro Execução
@author Totvs
@since 10/07/2015
@version 12.1.6
/*/
//--------------------------------------------------
Function A060Mexec(cVar)


Return &cVar


//-------------------------------------------------------------------
/*/
{Protheus.doc} A060VLDFil
Valida restrição de filiais para usuario

@author Igor S. Nascimento

@since 07/04/2015
@version 12.0
/*/
//-------------------------------------------------------------------

Static Function A060VLDFil(cFil)

local cCodEmp := ""	as character
local lRet	  := .F. as Logical

default cFil := ""

lRet := IIf(IsBlind() .Or. lUsrAdm .Or. lAllEmp,.T.,.F.)

If !lRet .and. len(aEmp) > 0 
	cCodEmp	:= AllTrim(cEmpAnt + cFil)
	lRet := (aScan(aEmp, {|row| ( nCol := aScan(row, {|x| AllTrim(x) == cCodEmp}) ) > 0 })) > 0 
EndIf

return	lRet

/*{Protheus.doc} AF060CTB
Função para fazer a contabilização da transferencia entre filiais
@author Jose Augusto Ribeiro
@since 11/08/2015
@version P12
@param oModel, Objeto , Modelo Ativo no Commit
*/
Static Function AF060CTB(oModel)
Local oModFNR 	:= oModel:GetModel("GridFNR")
Local oModFNS 	:= oModel:GetModel("GridFNS")
Local cFilBkp 	:= cFilAnt
Local cFilDest 	:= oModFNR:GetValue("FNR_FILDES")
Local cFilOrig	:= oModFNR:GetValue("FNR_FILORI")
Local cArquivo	:= ""
Local nHdlPrv 	:= 0
Local nFNR			:= 0
Local nFNS			:= 0
Local aAux			:= {}
Local nX			:= 0
Local nTotal		:= 0
Local cLoteAtf	:= LoteCont("ATF")
Local lAglutina 	:= .T.
Local lMostra		:= .T.
Local lLanc831	:= VerPadrao("831")
Local lLanc832	:= .T.
Local cFilAux		:= ""
Local lContabOn		:= MV_PAR01 == 1
Local nLineFNS		:= 0
Local nLineFNR		:= 0

	//Verificando se Foi a Transferencia automatica ou normal para carregar o seu devido pergunte
	If(FwIsInCallStack("ATF060TRAN"))

		Pergunte("AFA060", .F.)

	Else

		Pergunte("AFA060A", .F.)

	EndIf
	lMostra   := Iif(mv_par02==1,.T.,.F.)
	lAglutina := Iif(mv_par03==1,.T.,.F.)

	//Aqui estou criando um vetor com as filiais e as ordenandos da FNR
	For nFNR := 1 To oModFNR:Length(.T.)
		oModFNR:GoLine(nFNR)
		If oModFNR:Getvalue("OK") //Transferencia de dados com diferentes filiais Origem e Destino
			Aadd(aAux,{oModFNR:GetValue("FNR_FILDES"),nFNR})
		EndIf
	Next nFNR

	aSort(aAux, , , { | x,y | x[1]+Str(x[2]) < y[1]+Str(y[2])} )
	If(lLanc831 .And. lContabOn)
		//Criacao do Arquivo de Contabilização da Filial de Origem
		If(nHdlPrv <= 0)

			nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)

		Endif

		For nX := 1 To Len(aAux)
			oModFNR:GoLine(aAux[nx][2])
			If(oModFNR:GetValue("OK"))
				nLineFNR := oModFNR:GetLine()
				For nFNS := 1 To oModFNS:Length(.T.)
					If(oModFNS:GetValue("OK"))
						nLineFNS := oModFNS:GetLine()
						//Chamando a Função para fazer o DetProva
						AF060CTBFIL(@cLoteAtf,@cArquivo, cFilOrig, cFilDest, "03", nFNS, nLineFNR, oModel,@nTotal,@nHdlPrv)

					EndIf
				Next nFNS
			EndIf
		Next nX
		//Fechamento do Arquivo de Contabilização da Filial de Origem
		If nHdlPrv > 0 .And. nTotal > 0

			RodaProva(nHdlPrv,nTotal)
			cA100Incl(cArquivo,nHdlPrv,3,cLoteAtf,lMostra,lAglutina,,,,aFlagCTB )

		EndIf
	EndIf
		nTotal  := 0
		nHdlPrv := 0
		//Filial de Destino
		cFilAnt := cFilDest
		lLanc832 := VerPadrao("832")
	If(lLanc832 .And. lContabOn)
		cFilAux := oModFNR:GetValue("FNR_FILDES")
		For nX := 1 To Len(aAux)
			oModFNR:GoLine(aAux[nx][2])
			//Criação do Arquivo por Filiais diferentes
			If(nHdlPrv <= 0 .And. (nX == 1 .Or. cFilAux <> oModFNR:GetValue("FNR_FILDES")))

				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)

			Endif
			If(oModFNR:GetValue("OK"))
				nLineFNR := oModFNR:GetLine()
				For nFNS := 1 To oModFNS:Length(.T.)
					If(oModFNS:GetValue("OK"))
						nLineFNS := oModFNS:GetLine()
						//Chamando a Função para fazer o DetProva
						AF060CTBFIL(@cLoteAtf,@cArquivo, cFilOrig, cFilDest, "04", nFNS, nLineFNR, oModel,@nTotal,@nHdlPrv)

					EndIf
				Next nNFS
			EndIf
			//Fechamento do Arquivo por diferentes Filiais
			If nHdlPrv > 0 .And. nTotal > 0 .And. ( nX == Len(aAux) .Or. oModFNR:GetValue("FNR_FILDES") <> Iif(Len(aAux) >= nx+1,aAux[nx+1][1],aAux[nx][1]))

				RodaProva(nHdlPrv,nTotal)
				cA100Incl(cArquivo,nHdlPrv,3,cLoteAtf,lMostra,lAglutina,,,,aFlagCTB )
				nTotal  := 0
				nHdlPrv := 0
			EndIf
		Next nX
	EndIf
	//Restaurar variável cFilAnt (manipulada na função) após toda operação
	cFilAnt := cFilBkp
Return

//-------------------------------------------------------------------
/*/
{Protheus.doc} AFA060LOG
Exibe log do ATFA060

@author Simone Mie Sato Kakinoana

@since 11/12/2015
@version 12.0
/*/
//-------------------------------------------------------------------

Function AFA060LOG()

ProcLogView(,__cProcPrinc)

Return

//-------------------------------------------------------------------
/*/
{Protheus.doc} AF060CpUsr
AF060CpUsr-Carrega campos de usuarios para gravacao FN9/FNR/FNS

@author Paulo Carnelossi

@since 17/03/2016
@version 12.0
/*/
//-------------------------------------------------------------------

Static Function AF060CpUsr(cAliasAux)
Local aRetorno := {}
Local aArea    := GetArea()
Local aStruSX3 := {}
Local cCampo   := ""
Local nI

aStruSX3 := &(cAliasAux)->(DbStruct())

For nI := 1 to Len(aStruSX3)
	cCampo := AllTrim(aStruSX3[nI,1])

	If GetSX3Cache(cCampo, "X3_PROPRI")== "U" .And. GetSX3Cache(cCampo, "X3_CONTEXT") != "V" .And. GetSX3Cache(cCampo,"X3_TIPO") <> 'M'
		aAdd( aRetorno, cCampo)
	EndIf

Next nI

RestArea(aArea)

Return(aRetorno)

//-------------------------------------------------------------------
/*/
{Protheus.doc} A060InvSel
Inverte a seleção dos ativos na transferência Automatica

@author TOTVS

@since 21/04/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function A060InvSel()
Local oModel	:= FWModelActive()
Local oFNR		:= oModel:GetModel("GridFNR")
Local nFNR		:= 0
Local aSaveRows	:= FWSaveRows()

For nFNR := 1 To oFNR:Length()

	oFNR:GoLine(nFNR)

	oFNR:SetValue("OK",!(oFNR:GetValue("OK")))

Next nFNR

FWRestRows(aSaveRows)

Return

//-------------------------------------------------------------------
/*/
{Protheus.doc} AF060VldDt
Valida se a transferia nao esta ocorrendo em data anterior a ultima

@author TOTVS

@since 17/05/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function AF060VldDt(cCodBase,cItem,lHelp)
Local aSaveArea	:= GetArea()
Local lRet		:= .T.
Local cTMPFNR	:= GetNextAlias()

Default lHelp := .T.

BeginSql Alias cTMPFNR
	SELECT FNR_IDMOV
	FROM %Table:FNR%
	WHERE	FNR_FILDES = %Exp:cFilAnt%
			AND FNR_CBADES = %Exp:cCodBase%
			AND FNR_ITEDES = %Exp:cItem%
			AND FNR_STATUS = '1'
			AND FNR_DATA > %Exp:dDataBase%
			AND %NotDel%
EndSql

If (cTMPFNR)->(!EOF())
	lRet := .F.
	If lHelp
		Help(" ",1,"AF060VldDt",,STR0195,1,0,,,,,,{STR0196 + Alltrim(cCodBase) + " " + AllTrim(cItem) + "."}) //"Localizada transferência com data posterior a data base do sistema."###"Confira a data da última transferência ocorrida para o ativo: "
	EndIf
EndIf

(cTMPFNR)->(DBCloseArea())

RestArea(aSaveArea)

Return lRet

//-------------------------------------------------------------------
/*/
{Protheus.doc} CompareDif
Validação para verificar se houve alteração de dados na trasferecia

Obs.:
A Função foi escrita deste modo pois os metodos IsFieldUpdated e Compare do modelo não atendem
IsFieldUpdated - quando vc edita o campo e não altera o contudo ele retorna que o campo foi alterado
Compare - o array de retorno de modificação não é possivel identificar pai e filho (FNS e FNR)

@author TOTVS

@since 28/06/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function CompareDif(oModel As Object) As Logical

Local lRet		As Logical
Local lAlt		As Logical
Local nFNR		As Numeric
Local nFNS		As Numeric
Local oModFNR	As Object
Local oModFNS	As Object
Local nCposFNR	As Numeric
Local nCposFNS	As Numeric
Local aFNROri	As Array
Local aFNRDest	As Array
Local aFNSOri	As Array
Local aFNSDest	As Array
Local aLinha	As Array
Local nContEnt 	As Numeric

lRet	:= .T. //Retorna se houve alteração nos ativos selecionado
lAlt	:= .F.
nFNR		:= 0
nFNS		:= 0
oModFNR		:= oModel:GetModel('GridFNR')
oModFNS		:= oModel:GetModel('GridFNS')
nCposFNR		:= 0
nCposFNS		:= 0
aFNROri	:= {"FNR_QTDORI","FNR_FILORI","FNR_GRPORI","FNR_LOCORI","FNR_CBAORI","FNR_ITEORI","FNR_TXPADO"}
aFNRDest	:= {"FNR_QTDDES","FNR_FILDES","FNR_GRPDES","FNR_LOCDES","FNR_CBADES","FNR_ITEDES","FNR_TXPADD"}
aFNSOri	:= {"FNS_CONTAO","FNS_CCBEMO","FNS_CONDDO","FNS_CCDESO","FNS_CONDAO","FNS_CONCDO","FNS_CONCOO","FNS_CCDDO","FNS_CCDAO","FNS_CCCDO","FNS_CCCORO","FNS_ITBEMO","FNS_ITDEDO","FNS_ITDEAO","FNS_ITCDEO","FNS_ITCORO","FNS_CVBEMO","FNS_CVDEPO","FNS_CVCDEO","FNS_CVDESO","FNS_CVCORO" }
aFNSDest	:= {"FNS_CONTAD","FNS_CCBEMD","FNS_CONDDD","FNS_CCDESD","FNS_CONDAD","FNS_CONCDD","FNS_CONCOD","FNS_CCDDD","FNS_CCDAD","FNS_CCCDD","FNS_CCCORD","FNS_ITBEMD","FNS_ITDEDD","FNS_ITDEAD","FNS_ITCDED","FNS_ITCORD","FNS_CVBEMD","FNS_CVDEPD","FNS_CVCDED","FNS_CVDESD","FNS_CVCORD" }
aLinha	:= FWSaveRows()

nContEnt := 0

If FNS->(FieldPos("FNS_ITDESD")) > 0 // campo item despesa e classe de valor despesa no mesmo pacote 012450
	Aadd(aFNSOri,"FNS_ITDESO")
	Aadd(aFNSOri,"FNS_CVDSPO")
	Aadd(aFNSDest,"FNS_ITDESD")
	Aadd(aFNSDest,"FNS_CVDSPD")
EndIf

If Len(__aCTBEnt) > 0 .AND. __lEntAdd
	For nContEnt := 1 to Len(__aCTBEnt)
		Aadd(aFNSOri,"FNS_EC"+__aCTBEnt[nContEnt]+"DO")
		Aadd(aFNSOri,"FNS_EC"+__aCTBEnt[nContEnt]+"CO")
		Aadd(aFNSDest,"FNS_EC"+__aCTBEnt[nContEnt]+"DD")
		Aadd(aFNSDest,"FNS_EC"+__aCTBEnt[nContEnt]+"CD")
	Next nContEnt
EndIf

For nFNR := 1 To oModFNR:Length() //Percorre grid FNR
	oModFNR:goline(nFNR)
	If oModFNR:getvalue("OK") //Se o campo OK estiver flagdo
		For nCposFNR := 1 To Len(aFNROri) //Percorre Campos da strutura FNR
			IF oModFNR:getValue(aFNROri[nCposFNR]) <> oModFNR:getValue(aFNRDest[nCposFNR])
				lAlt:= .T.
				Exit
			EndIf
		Next nCposFNR

		If 	!lAlt
		//percorre filhos FNS
			For nFNS := 1 To oModFNS:Length() //Percorre grid FNs
				oModFNS:goline(nFNS)
				If oModFNS:getvalue("OK") //Se o campo OK estiver flagdo
					For nCposFNS := 1 To Len(aFNSOri) //Percorre Campos da strutura FNS
						If	oModFNS:getValue(aFNSOri[nCposFNS]) <> oModFNS:getValue(aFNSDest[nCposFNS])
							lAlt:= .T.
							Exit
						EndIf
					Next nCposFNS
				EndIF
			Next nFNS
		EndIF
		//Se o ativo estiver marcado para transferencia e não sofreu alteração mostra a msg
		If !lAlt
			Help( "", 1, "AF060TDOK", ,STR0199,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} ) //"O campo classificacao da NF esta em branco"###'Verifique os dados no painel "Ativo", Código + Item:'
			lRet := .F.
			Exit
		EndIf
	EndIf
	lAlt:= .F. //Volta valor da variavel
Next nFNR

FWRestRows(aLinha)

aSize(aFNROri,0)
aFNROri := nil
aSize(aFNRDest,0)
aFNRDest := nil
aSize(aFNSOri,0)
aFNSOri := nil
aSize(aFNSDest,0)
aFNSDest := nil
Return lRet

//-------------------------------------------------------------------
/*/
{Protheus.doc} A060UltSeq
Retorna último sequencial SN3 na transferencia parcial

@author TOTVS

@since 20/08/2019
@version 12
/*/
//-------------------------------------------------------------------

Static Function A060UltSeq(cFilSN3, cCodBase, cItem, cTpBem, cTpSal, cSeqReav)

Local cRet		:= ""
Local cAliasQry := GetNextAlias()

BeginSql Alias cAliasQry
SELECT MAX(N3_SEQ) N3_SEQ
FROM %table:SN3% SN3
WHERE 	SN3.N3_FILIAL	= %Exp:cFilSN3% AND
		SN3.N3_CBASE	= %Exp:cCodBase% AND
		SN3.N3_ITEM		= %Exp:cItem% AND
		SN3.N3_TIPO		= %Exp:cTpBem% AND
		SN3.N3_TPSALDO	= %Exp:cTpSal% AND
		SN3.N3_SEQREAV	= %Exp:cSeqReav% AND
		SN3.%notDel%
EndSql

If (cAliasQry)->(!Eof())
	cRet := (cAliasQry)->N3_SEQ
EndIf

(cAliasQry)->(DbCloseArea())

Return cRet
/*/
{Protheus.doc} AtfRetCta
Retorna a conta contábil para gravação da NF

@author TOTVS

@since 16/10/2019
@version 12
/*/
Static Function AtfRetCta(oModel,cTipo)
Local nI 		:= 0
Local oModelFNS	:= oModel:GetModel('GridFNS')
Local cContaRet := oModelFNS:GetValue("FNS_CONTA"+cTipo) // Atribui um valor default caso não encontre o tipo 01

DEFAULT cTipo := ""
DEFAULT oModel:= FwModelActive()

For nI := 1 To oModelFNS:Length()
	oModelFNS:GoLine(nI)
	If oModelFNS:GetValue("FNS_TIPO") == "01"
		cContaRet := oModelFNS:GetValue("FNS_CONTA"+cTipo)
	EndIf
Next nI

Return AllTrim(cContaRet)

/*
Funcao para verificar quando o CNPJ for igual no cliente/fornecedor utiliza a inscrição estadual para diferenciacao.
*/
Static Function AF60CNPJCLI(cCNPJ,cInscEstad)

Local aArea	:=	getarea()
Local aCliente	:= {}

Default cInscEstad := ""
SA1->(DbSetOrder(3))


If SA1->(MsSeek(xFilial("SA1") +cCNPJ))

	While SA1->(!EOF()) .And. cCNPJ == SA1->A1_CGC
		If AllTrim(SA1->A1_INSCR) == AllTrim(cInscEstad) .And. SA1->A1_MSBLQL != "1"
			aADD(aCliente,SA1->A1_COD)
			aADD(aCliente,SA1->A1_LOJA)
			Exit
		ElseIf AllTrim(SA1->A1_INSCR) != AllTrim(cInscEstad) .And. SA1->A1_MSBLQL != "1"
			aADD(aCliente,SA1->A1_COD)
			aADD(aCliente,SA1->A1_LOJA)
			Exit
		Endif
		SA1->(Dbskip())
		Loop
	ENDDO

Endif

RestArea(aArea)

Return (aCliente)

/*/{Protheus.doc} ATF060Metrics

	ATF060Metrics - Funcao utilizada para metricas no CTBR400

	@type  Static Function
	@author user
	@since date
	@version version
	@param param, param_type, param_descr
	@return return, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function ATF060Metrics(cEvent, nStart, cSubEvent, cSubRoutine, nQtdReg)

Local cFunBkp	:= ""
Local cFunMet	:= ""

// Local nFim := 0

Local cIdMetric  := ""
Local dDateSend := CtoD("")
Local nLapTime := 0
Local nTotal := 0

Default cEvent := ""
Default nStart := Seconds() //Caso futuramente exista metrica de tempo medio
Default cSubEvent := ""
Default cSubRoutine := Alltrim(ProcName(1))
Default nQtdReg := 0 //Deixando variavel caso posteriormente necessite de metricas de qtd registros

//Só capturar metricas se a versao da lib for superior a 20210517
If __lMetric .And. !Empty(cEvent)

	//grava funname atual na variavel cFunBkp
	cFunBkp := FunName()

	If cEvent == "01" //Evento 01 -

		//Evento 01 - Metrica de quantidade de acessos por cliente - Transferencia em lote - AF060Auto
		//Vale ressaltar que essa metrica com summetrics aglutina por filial(FederalId) a quantidade de transferencias realizada pelo cliente em suas filiais
		If cEvent == "01"

			If cSubEvent == '001'

				cFunMet := Iif(AllTrim(cFunBkp)=='RPC',"RPCATFA060",cFunBkp)
				SetFunName(cFunMet)

				//atribuicao das variaveis que serao utilizadas pelo FwCustomMetrics
				cSubRoutine := Alltrim(cSubRoutine)
				cIdMetric  	:= "ativo-fixo-protheus_transferencia_de_ativos_em_lote_total"
				dDateSend 	:= LastDay( Date() )
				nTotal 		:= 1
				FWCustomMetrics():SetSumMetric(cSubRoutine, cIdMetric, nTotal, dDateSend, nLapTime)
			EndIf
		EndIf
	EndIf

	//Restaura setfunname a partir da variavel salva cFunBkp
	SetFunName(cFunBkp)
EndIf

Return

Function A60ROBO()

	lA060robo := .T.

Return

Function ATF060Reset()

	lA060robo := .F.

Return

/*/{Protheus.doc} A060RECN4
	A060RECN4 - Funcao utilizada para posicionar corretamente no registro da SN4, tanto em transferencias parciais quanto totais.

	@type  Static Function
	@author Gustavo Campos
	@since 14/12/2021
	@version P12
	@param cUltSeq(C) Sequencia ,dDataTrans(D) data da transferencia, cOcorren(C) ocorrencia, cTipoCNT(C) Tipo Conta
	@return nRecnoSn4(N)
/*/
Static Function A060RECN4(cUltSeq,dDataTrans, cOcorren,cTipoCNT)
	Local nRecnoSN4	:= 0
	Local aArea 	:= getArea()
	Local cQuery    := " "

	Default cTipoCNT	:= "1" //Posteriormente pode ser analisado se iremos incluir os outros tipos N4_TIPOCNT para consulta via LP's

	If Select("TMPN4") > 0
		DbSelectArea("TMPN4")
		TMPN4->(DbCloseArea())
	Endif

	cQuery:=" SELECT  R_E_C_N_O_ RECNO "		 	     	 +CRLF
	cQuery+=" FROM "+retSqlName("SN4")+" SN4 "			 	 +CRLF
	cQuery+=" WHERE	SN4.N4_FILIAL = '"+SN3->N3_FILIAL+"'"	 +CRLF
	cQuery+=" AND SN4.N4_CBASE   = '"+SN3->N3_CBASE+"'"		 +CRLF
	cQuery+=" AND SN4.N4_ITEM    = '"+SN3->N3_ITEM+"'"		 +CRLF
	cQuery+=" AND SN4.N4_TIPO    = '"+SN3->N3_TIPO+"'"		 +CRLF
	cQuery+=" AND SN4.N4_DATA = '"+DTOS(dDataTrans)+"'"      +CRLF
	If FNR->FNR_QTDORI == FNR->FNR_QTDDES //se transferencia total
		cQuery+=" AND SN4.N4_SEQ = '"+SN3->N3_SEQ+"'"		 +CRLF
	Elseif cOcorren == "04" //se parcial e ocorrencia 04 - Lp 832
		cQuery+=" AND SN4.N4_SEQ = '"+cUltSeq+"'"			 +CRLF
	Else // se parcial e ocorrencia 03 - Lp 831
		cUltSeq   := A060UltSeq(SN3->N3_FILIAL, SN3->N3_CBASE, SN3->N3_ITEM, SN3->N3_TIPO, SN3->N3_TPSALDO, SN3->N3_SEQREAV)
		cQuery+=" AND SN4.N4_SEQ = '"+cUltSeq+"'"		     +CRLF
	EndIf
	cQuery+=" AND SN4.N4_SEQREAV = '"+SN3->N3_SEQREAV+"'"	 +CRLF
	cQuery+=" AND SN4.N4_OCORR  = '" + cOcorren + "'"     	 +CRLF
	cQuery+=" AND SN4.N4_TIPOCNT ='" + cTipoCNT + "'"      	 +CRLF
	cQuery+=" AND SN4.D_E_L_E_T_=' '" 						 +CRLF
	cQuery+=" ORDER BY  R_E_C_N_O_ DESC "					 +CRLF

	cQuery:= ChangeQuery( cQuery )

	dbUseArea( .T. , "TOPCONN" , TcGenQry(,,cQuery) , "TMPN4" , .T. , .F.)

	dbSelectArea("TMPN4")

	If TMPN4->(!EOF())
		nRecnoSN4:=TMPN4->RECNO
	EndIf
	TMPN4->(DbCloseArea())

	restArea(aArea)

Return nRecnoSN4

/*
Funcao para verificar quando o CNPJ for igual no cliente/fornecedor utiliza a inscrição estadual para diferenciacao.
*/
Static Function AF60CNPJFOR(cFilDes As Character, cCNPJ As Character, cInscEstad As Character) As Array

Local aArea	    As Array
Local aFornece	As Array
Local cA2IncEst	As Character

Default cInscEstad := ""

aArea	:=	getarea()
aFornece	:= {}
cA2IncEst	:= ""

SA2->(DbSelectArea("SA2"))
SA2->(DbSetOrder(3))

If SA2->(MsSeek( xFilial("SA1",cFilDes) + cCNPJ))

	While SA2->(!EOF()) .And. cCNPJ == SA2->A2_CGC
		cInscEstad := StrTran(StrTran(StrTran(cInscEstad, ".", ""), "/", ""), "-", "")
		cA2IncEst  := StrTran(StrTran(StrTran(SA2->A2_INSCR, ".", ""), "/", ""), "-", "")

		If AllTrim(cA2IncEst) == AllTrim(cInscEstad) .And. SA2->A2_MSBLQL <> "1"
			aADD(aFornece,SA2->A2_COD)
			aADD(aFornece,SA2->A2_LOJA)
			aADD(aFornece,SA2->A2_EST)
			Exit
		Endif
		SA2->(Dbskip())
		Loop
	ENDDO

Endif

RestArea(aArea)

Return (aFornece)

/*/{Protheus.doc} QTDVOLNF
Verifica quantos volumes serão tratados no dicionário de dados do cliente.
Máximo de 9 volumes.
@type function
@version 12.1.2210
@author Ciro Pedreira
@since 18/9/2023
@return numeric, quantidade de volumes
/*/
Static Function QTDVOLNF()

Local nQtdVol := 1

If FNR->(ColumnPos('FNR_VOLUM' + AllTrim(Str(nQtdVol)))) > 0 .And. nQtdVol <= 9
	While FNR->(ColumnPos('FNR_VOLUM' + AllTrim(Str(nQtdVol)))) > 0 .And. nQtdVol <= 9
		nQtdVol++
	EndDo

	nQtdVol--
EndIf

Return nQtdVol

/*/{Protheus.doc} GATTRANSP
Tratamento para o gatilho dos campos referentes aos Dados de Transporte.
@type function
@version 12.1.2210
@author Ciro Pedreira
@since 16/10/2023
@return logical, .T. para continuar ou .F. para bloquear
/*/
Static Function GATTRANSP(oModel, cField, cValue)

Return AF060TRG(cField)

/*/{Protheus.doc} VldExec060
Valida o campo da tabela SN3 se existe na chamada do execauto
@type Staticfunction
@version 12.1.2210
@author TOTVS
@since 26/12/2023
@return logical, .T. para continuar com o grupo ou .F. para continuar com execauto
/*/
Static Function VldExec060(cCampo as Character) as Logical

Local lRet as Logical

lRet := .T.

If lAtfAuto
	lRet := ( aScan(aArrAut, {|x| x[1] == cCampo}) == 0 )
EndIf

Return lRet

/*/{Protheus.doc} AF060UsInf
	Função para carregar os acessos de empresas e filiais vinculadas
	ao usuário logado.
@type  Static Function
@author Everton Fregonezi Diniz
@since 24/06/2025
/*/
Static Function AF060UsInf()

local aEmpAux	:= {}	as array
local aGrpUsr	:= {}	as array
local aUsrEmp	:= {}	as array

	aEmp	:= {}
	aGrpUsr := FWSFUsrGrps( __cUserID )
	
	cUsrRul	:= FWUsrGrpRule( __cUserID )
	
	lUsrAdm	:= FWIsAdmin( __cUserID )
	lAllEmp	:= .F.

	PswSeek( __cUserID, .T. )
	aUsrEmp := PswRet()[2][6]

	if !(lUsrAdm) .and. cUsrRul == "1"	// Prioriza SOMENTE os acessos estabelecidos no grupo de usuários
		
		if len(aGrpUsr) > 0
			aEval(aGrpUsr,{|x| aAdd(aEmp, FWGrpEmp(x)) }, 1, 1)
		endif

		if aScan(aEmp, { |x| alltrim(x[1]) == "@@@@" }) > 0
			lAllEmp := .T.
		endif
	
	elseif !(lUsrAdm) .and. cUsrRul == "2"	// Considera somente os acessos concedidos no cadastro do usuário
		
		if len(aUsrEmp) > 0
			aAdd(aEmp, aClone(aUsrEmp))
			if aScan(aEmp, { |x| alltrim(x[1]) == "@@@@" }) > 0
				lAllEmp := .T.
			endif
		endif
	
	elseif !(lUsrAdm) .and. cUsrRul == "3"	// Soma os acessos, combinando o que o usuário possui com o que os grupos possuem. 

		if len(aGrpUsr) > 0
			aEval(aGrpUsr,{|x| ( aEmpAux := FWGrpEmp(x), Iif( len(aEmpAux) > 0, aAdd(aEmp, FWGrpEmp(x)), Nil ) ) })
		endif

		if len(aUsrEmp) > 0
			aAdd(aEmp, aClone(aUsrEmp))
		endif

		if aScan(aEmp, { |x| alltrim(x[1]) == "@@@@" }) > 0
			lAllEmp := .T.
		endif

	endif

	fwFreeArray(aEmpAux)
	fwFreeArray(aGrpUsr)
	fwFreeArray(aUsrEmp)

Return

/*/{Protheus.doc} AF060VlN5
	Função para valida/lockar registros da SN5 na transferência em lote.
@type  Static Function
@author pierre.nascimento
@since 18/08/2025
/*/
Static Function AF060VlN5(oModFNR As Object,oModFNS As Object, cTpSaldo As Character, oModel As Object) As Logical

Local lRet 	     As Logical
Local cCtBemOri  As Character
Local cCtBemDes  As Character
Local cCtCorDepO As Character
Local cCtCorDepD As Character
Local cCtCorMonO As Character
Local cCtCorMonD As Character
Local cCtDepMesO As Character
Local cCtDepMesD As Character
Local cCtDepAcmO As Character
Local cCtDepAcmD As Character
Local cFilOri    As Character
Local cFilDes    As Character
Local dDataFNS   As Date
Local cTipoFNS   As Character
Local aChavesCt  As Array
Local lTranFil   As Logical
Local nI		 As Numeric

lRet		:= .T.
aChavesCt  	:= {}
nI          := 0

cFilOri		:= oModFNR:GetValue("FNR_FILORI")
cFilDes  	:= oModFNR:GetValue("FNR_FILDES")
lTranFil 	:= cFilOri <> cFilDes

cCtBemOri  := oModFNS:GetValue("FNS_CONTAO")//Ct Bem Orig 
cCtBemDes  := oModFNS:GetValue("FNS_CONTAD")//Ct Bem Dest 
cCtCorDepO := oModFNS:GetValue("FNS_CONCDO")//Ct Cor Dep O
cCtCorDepD := oModFNS:GetValue("FNS_CONCDD")//Ct Cor Dep D
cCtCorMonO := oModFNS:GetValue("FNS_CONCOO")//Ct Cor Mon O
cCtCorMonD := oModFNS:GetValue("FNS_CONCOD")//Ct Cor Mon D
cCtDepAcmO := oModFNS:GetValue("FNS_CONDAO")//Ct Dep Acu O
cCtDepAcmD := oModFNS:GetValue("FNS_CONDAD")//Ct Dep Acu D
cCtDepMesO := oModFNS:GetValue("FNS_CONDDO")//Ct Des Dep O
cCtDepMesD := oModFNS:GetValue("FNS_CONDDD")//Ct Des Dep D
dDataFNS   := oModFNS:GetValue("FNS_DATA")  //Data Mov
cTipoFNS   := oModFNS:GetValue("FNS_TIPO")  //Tipo Ativo

If  cCtBemOri <> cCtBemDes .Or. lTranFil
	AADD( aChavesCt, cFilOri+cCtBemOri+Dtos(dDataFNS)+"8"+cTipoFNS+cTpSaldo)  //Ct Bem Orig 
	AADD( aChavesCt, cFilDes+cCtBemDes+Dtos(dDataFNS)+"9"+cTipoFNS+cTpSaldo)  //Ct Bem Dest 
EndIf
If cCtCorDepO <> cCtCorDepD .Or. lTranFil
	If !Empty(cCtCorDepO)
		AADD( aChavesCt, cFilOri+cCtCorDepO+Dtos(dDataFNS)+"8"+cTipoFNS+cTpSaldo) //Ct Cor Dep O
	EndIf
	If !Empty(cCtCorDepD)
		AADD( aChavesCt, cFilDes+cCtCorDepD+Dtos(dDataFNS)+"9"+cTipoFNS+cTpSaldo) //Ct Cor Dep D
	EndIf	
EndIf
If cCtCorMonO <> cCtCorMonD .Or. lTranFil
	If !Empty(cCtCorMonO)
		AADD( aChavesCt, cFilOri+cCtCorMonO+Dtos(dDataFNS)+"8"+cTipoFNS+cTpSaldo) //Ct Cor Mon O
	EndIf
	If !Empty(cCtCorMonD)
		AADD( aChavesCt, cFilDes+cCtCorMonD+Dtos(dDataFNS)+"9"+cTipoFNS+cTpSaldo) //Ct Cor Mon D
	EndIf	
EndIf
If cCtDepMesO <> cCtDepMesD .Or. lTranFil
	If !Empty(cCtDepMesO)
		AADD( aChavesCt, cFilOri+cCtDepMesO+Dtos(dDataFNS)+"8"+cTipoFNS+cTpSaldo) //Ct Des Dep O
	EndIf
	If !Empty(cCtDepMesD)
		AADD( aChavesCt, cFilDes+cCtDepMesD+Dtos(dDataFNS)+"9"+cTipoFNS+cTpSaldo) //Ct Des Dep D
	EndIf	
EndIf
If cCtDepAcmO <> cCtDepAcmD .Or. lTranFil
	If !Empty(cCtDepAcmO)
		AADD( aChavesCt, cFilOri+cCtDepAcmO+Dtos(dDataFNS)+"8"+cTipoFNS+cTpSaldo) //Ct Dep Acu O
	EndIf
	If !Empty(cCtDepAcmD)
		AADD( aChavesCt, cFilDes+cCtDepAcmD+Dtos(dDataFNS)+"9"+cTipoFNS+cTpSaldo) //Ct Dep Acu D
	EndIf	
EndIf

For nI := 1 to Len(aChavesCt)
	If aScan(__aLockSN5, aChavesCt[nI]) <= 0 
		If !LockByName("ATFA060SN5"+aChavesCt[nI],.T.,.F.,.T.)
			AF60ClrN5()
			oModel:SetErrorMessage("",,,,"AF060BLQTRAN",STR0233,STR0234) //"A Conta Contábil está sendo utilizada em uma transferencia de ativos por outro usuário."##"Tente novamente mais tarde."
			lRet := .F.
			exit
		Else
			AADD(__aLockSN5, aChavesCt[nI])	
		EndIf
	EndIf
Next

Return lRet

/*/{Protheus.doc} AF60ClrN5
	Função para liberar registros da SN5 lockados na transferência em lote.
@type  Static Function
@author pierre.nascimento
@since 18/08/2025
/*/
Static Function AF60ClrN5()
Local nJ As Numeric
nJ := 0

For nJ := 1 to Len(__aLockSN5)
	UnLockByName("ATFA060SN5"+__aLockSN5[nJ],.T.,.F.,.T.)
Next
__aLockSN5 := {}

Return
