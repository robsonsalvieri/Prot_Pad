#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "finxinc.ch"
#INCLUDE "FWLIBVERSION.CH"

Static __dLastPcc := CTOD("22/06/2015")
Static __lIsIssBx := FindFunction("IsIssBx")
Static __lF050ATP := ExistBlock("F050ATP")
Static __lLocBRA  := cPaisLoc == 'BRA'
Static __lBtrISS  := NIL
Static __lF50FCTC := NIL
Static __lTemMR   := (FindFunction("FTemMotor") .and. FTemMotor())
Static __lDicSimpl  As Logical
Static __nDedSimpl 	As Numeric
Static __lCachQry   As Logical

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINXINC

Funções  genéricas relacionadas as inclusões CR e CP.

@Author Vários
@version 12
@since   09/12/2014

/*/
//-----------------------------------------------------------------------------------------------------


/*
=============================================================================
-----------------------------------------------------------------------------

	            Funcoes retiradas do arquivo FINXATU.PRX

-----------------------------------------------------------------------------
=============================================================================
*/

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA050GERPA

Faz a geracao do registro na tabela SE5 ou SEF (para  geracao de cheque, de acordo com perguntas).
Arquivo anterior: FINXATU.PRX

@Author	Wagner Mobile Costa
@since	13/06/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa050GerPa(cBancoCx,lPadrao,lPccMR,lIrfMR,lInsMR,lIssMR,lCidMR,lSestMR,aRatIRF,cUuidBs,aTitCalc)

Local nRecSE2 As Numeric
Local nRecSE5 As Numeric
Local lLibCheq As Logical
Local cModRetPIS As Character
Local cNccRet As Character
Local nDiferImp As Numeric
Local nVlMinImp As Numeric
Local lIRPFBaixa As Logical
Local nLoop As Numeric
Local nMoedaBco As Numeric
Local lPCCBaixa As Logical
Local lContrRet As Logical
Local lRetParc As Logical
Local cLog As Character
Local oModel As Object
Local aAreaAnt As Array
Local cOrig As Character
Local oSubFKA As Object
Local oSubFK3 As Object
Local oSubFK4 As Object
Local oSubFK5 As Object
Local cChaveCH As Character
Local cCamposE5 As Character
Local cIdDoc As Character
Local cIdFK4 As Character
Local aImpostos As Array
Local nImp As Numeric
Local cIdFk4IR As Character
Local cCamposIR As Character
Local nBaseRet As Numeric
Local lMoedBco As Logical
Local lCalcIssBx As Logical
Local lAplMinP As Logical
Local lEmpPub As Logical
Local nVlMPub As Numeric
Local lEmpGImp As Logical
Local cSeqCheque As Character
Local nTamSeq As Numeric
Local nVlrCheque As Numeric
Local lNoBcoCx As Logical
Local lCond1 As Logical
Local lCond2 As Logical
Local lCond3 As Logical
Local lCond4 As Logical
Local lMovBanco As Logical
Local nVlrRet As Numeric
Local nX As Numeric
Local lTemMR As Logical
Local nTaxaMov As Numeric
Local lRet As Logical
Local nRecSA6 As Numeric
Local cChaveCHT As Character
Local nCentMd1 As Numeric
Local nVlrRetIRF As Numeric
Local lFKCodRet	As Logical
Local cCodRet	As Character
Local aCodRet	As Array
Local lSimpIRAlu	As Logical

Private dBaixa	 := SE2->(CriaVar("E2_BAIXA"))

Default lPadrao  := .F.
Default cBancoCx := ""
Default lPccMR   := .F.
Default lIrfMR   := .F.
Default lInsMR   := .F.
Default lIssMR   := .F.
Default lCidMR   := .F.
Default lSestMR  := .F.
Default aRatIRF  := {}
Default cUuidBs  := ""
Default aTitCalc := {}

nRecSE2    := SE2->(Recno())
nRecSE5    := 0
lLibCheq   := IIf(GetMv("MV_LIBCHEQ") == "S", .T.,.F.)
cModRetPIS := GetNewPar( "MV_RT10925", "1" )

//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
//3-Nao Controla
cNccRet     := SuperGetMv("MV_NCCRET",.F.,"1")
nDiferImp   := If (Type("nDiferImp") != "N",0,nDiferImp)
nVlMinImp   := GetNewPar("MV_VL10925",5000)
lIRPFBaixa  := Iif(__lLocBRA,SA2->A2_CALCIRF == "2",.F.)
nLoop		:= 0
//Controla o Pis Cofins e Csll na baixa
lPCCBaixa   := IIF(__lLocBRA,SuperGetMv("MV_BX10925",.T.,"2") == "1",.F.)
lContrRet   := .T.
lRetParc    := .T.
//Reestruturação SE5
cLog        := ""
oModel      := Nil
aAreaAnt := GetArea()
cOrig       := FunName()
oSubFKA     := Nil
oSubFK3     := Nil
oSubFK4     := Nil
oSubFK5     := Nil
cChaveCH    := ""
cCamposE5   := ""
cIdDoc      := ""
cIdFK4      := ""
aImpostos   := {}
nImp        := 1
cIdFk4IR    :=""
cCamposIR   := ""
nBaseRet    := 0  //Base de retencao
lMoedBco    := SuperGetMv("MV_MOEDBCO",,.F.)
lCalcIssBx  := IsIssBx("P")
lAplMinP    := IIf( SA2->A2_MINPUB == "2",.T., .F.)
lEmpPub     := IsEmpPub() .And. lIRPFBaixa .And. lAplMinP
nVlMPub     := SuperGetMv("MV_VLMPUB" ,.T.,10)
lEmpGImp    := .T.
cSeqCheque  := ''
nTamSeq     := TamSX3("EF_SEQUENC")[1]
nVlrCheque  := 0
lNoBcoCx    := SubStr(cBancoAdt,1,2) != "CX"
lCond1      := .F.
lCond2      := .F.
lCond3      := .F.
lCond4      := .F.
lMovBanco   := .T.
nVlrRet     := 0
nX          := 0
lTemMR      := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
lRet        := .T.
cChaveCHT   := ""
nCentMd1    := MsDecimais(1)
lFKCodRet	:= (cPaisLoc == "BRA" .and. FK3->(FieldPos("FK3_CODRET")) > 0 .and. FK4->(FieldPos("FK4_CODRET")) > 0)
cCodRet		:= ""
aCodRet		:= {}
lSimpIRAlu	:= .F.

nIrfBaseR   := If (Type("nIrfBaseR") != "N",0,nIrfBaseR)
nPisBaseR   := If (Type("nPisBaseR") != "N",0,nPisBaseR)
nCofBaseR   := If (Type("nCofBaseR") != "N",0,nCofBaseR)
nCslBaseR   := If (Type("nCslBaseR") != "N",0,nCslBaseR)
nIrfBaseC   := If (Type("nIrfBaseC") != "N",0,nIrfBaseC)
nPisBaseC   := If (Type("nPisBaseC") != "N",0,nPisBaseC)
nCofBaseC   := If (Type("nCofBaseC") != "N",0,nCofBaseC)
nCslBaseC   := If (Type("nCslBaseC") != "N",0,nCslBaseC)

If SE2->E2_EMISSAO >= __dLastPcc .And. !lEmpPub
	nVlMinImp := 0
EndIf

If __nDedSimpl == Nil
    __nDedSimpl  := SuperGetMV("MV_FVL1171",.F.,528) //Valor do desconto simplificado do IRPF
EndIf

If __lDicSimpl == NIL
    __lDicSimpl := (AliasInDic("DKE") .And. DKE->(FieldPos("DKE_IRSIMP")) > 0) .And. FK4->(FieldPos("FK4_DEDIRS")) > 0
Endif

SA6->(DbSetOrder(1))
SA6->(MsSeek(xFilial()+cBancoAdt+cAgenciaAdt+cNumCon))
nRecSA6 := SA6->(Recno())
//Regra de gravacao da taxa de conversao da moeda
nMoedaBco := Max(IF(!__lLocBRA, SA6->A6_MOEDAP, SA6->A6_MOEDA), 1)
If SE2->E2_TXMOEDA > 0
    nTaxaMov := SE2->E2_TXMOEDA
Elseif nMoedaBco > 1
    nTaxaMov := RecMoeda(SE2->E2_EMISSAO, nMoedaBco)
Elseif nMoedaBco == 1 .and. SE2->E2_MOEDA > 1 
    nTaxaMov := RecMoeda(SE2->E2_EMISSAO, SE2->E2_MOEDA)
Endif
If cPaisLoc == "RUS" .AND. SE2->E2_CONUNI == "1" //case for conventional units
    nTaxaMov := nMoedaBco
Endif       

If SE2->E2_TIPO $ MVPAGANT .And. lNoBcoCx .And. !(cBancoAdt $ cBancoCx)
	//Gera cheque a pagar se: 1. Banco nao for CX (Carteira) e docto for um PA e
	//2. Caso pergunta "Gera Chq p/Adiant.?" == 1 (Sim) ou Nro do Cheque for preenchido
	If mv_par05 == 1 .or. !Empty(cChequeAdt) .Or. cPaisLoc $ "ARG|ANG|COL|MEX"
		cChaveCHT	:= FWUUIDV4()
		cSeqCheque	:= PadL("1",nTamSeq,"0")

		If cPaisLoc $ "ARG|BOL|ANG|COL|MEX|BRA"

			If __lLocBRA .AND. (SE2->E2_MOEDA != nMoedaBco)
				If lMoedBco .And. M->E2_MOEDA > 1
					nVlrCheque	:= xmoeda(M->E2_VALOR, M->E2_MOEDA, SA6->A6_MOEDA,,,M->E2_TXMOEDA)
				Else
					nVlrCheque	:= SE2->E2_VLCRUZ
				EndIf
			Else
				nVlrCheque	:= SE2->E2_VALOR
			EndIf
		Else
			nVlrCheque	:= SE2->E2_VLCRUZ - SE2->E2_DECRESC + SE2->E2_ACRESC
		EndIf

		Reclock("SEF",.T.)
		SEF->EF_FILIAL		:= xFilial('SEF')
		SEF->EF_BANCO		:= cBancoAdt
		SEF->EF_AGENCIA		:= cAgenciaAdt
		SEF->EF_CONTA		:= cNumCon
		SEF->EF_NUM 		:= cChequeAdt
		SEF->EF_VALOR		:= nVlrCheque
		SEF->EF_DATA		:= SE2->E2_EMISSAO
		SEF->EF_BENEF		:= Iif(Empty(cBenef),SA2->A2_NOME,cBenef)
		SEF->EF_HIST		:= Iif(Empty(cHistor),SE2->E2_HIST,cHistor)
		SEF->EF_PREFIXO		:= SE2->E2_PREFIXO
		SEF->EF_TITULO 		:= SE2->E2_NUM
		SEF->EF_PARCELA		:= SE2->E2_PARCELA
		SEF->EF_FORNECE		:= SE2->E2_FORNECE
		SEF->EF_LOJA		:= SE2->E2_LOJA
		SEF->EF_TIPO		:= SE2->E2_TIPO
		SEF->EF_SEQUENC		:= cSeqCheque
		SEF->EF_ORIGEM    	:= "FINA050"
		SEF->EF_LIBER     	:= GetMv("MV_LIBCHEQ")
		SEF->EF_IMPRESS     := If(!Empty(cChequeAdt),"A"," ")

		If cPaisLoc $ "ARG|ANG|COL|MEX"
			SEF->EF_VENCTO	:=	SE2->E2_VENCTO
			SEF->EF_LA		:=	"S"
			SEF->EF_CART	:=	"P"
		Endif

		SEF->EF_IDSEF		:= cChaveCHT
		SEF->EF_FILORIG		:=  SE2->E2_FILORIG
		MsUnlock()

		If !Empty(cChequeAdt)
			//Para cheque com * no numero, nao sera gerado registro de rastreio (FKA) pois nao tem movto bancario.
           //Pois o rastreio somente sera gerado na impressao do cheque Gera cheque
			cSeqCheque	:= Soma1(cSeqCheque,nTamSeq)
			cChaveCH	:= FWUUIDV4()

			RecLock("SEF",.T.)
			SEF->EF_FILIAL 	:= xFilial()
			SEF->EF_BANCO	:= cBancoAdt
			SEF->EF_AGENCIA	:= cAgenciaAdt
			SEF->EF_CONTA	:= cNumCon
			SEF->EF_NUM 	:= cChequeAdt
			SEF->EF_VALOR	:= nVlrCheque
			SEF->EF_DATA	:= SE2->E2_EMISSAO
			SEF->EF_BENEF	:= Iif(Empty(cBenef),SA2->A2_NOME,cBenef)
			SEF->EF_HIST	:= Iif(Empty(cHistor),SE2->E2_HIST,cHistor)
			SEF->EF_SEQUENC	:= cSeqCheque
			SEF->EF_ORIGEM	:= "FINA050"
			SEF->EF_FILORIG := SE2->E2_FILORIG
            SEF->EF_IDSEF	:= cChaveCH
            SEF->EF_FORNECE	:= SE2->E2_FORNECE //gsa
			SEF->EF_LOJA	:= SE2->E2_LOJA //gsa
			SEF->EF_VENCTO	:= SE2->E2_VENCTO//gsa
			SEF->EF_TIPO	:= SE2->E2_TIPO //gsa
			SEF->EF_PREFIXO	:= SE2->E2_PREFIXO //gsa
			SEF->EF_TITULO 	:= SE2->E2_NUM //gsa
			SEF->EF_PARCELA	:= SE2->E2_PARCELA //gsa
			MsUnlock()
		EndIf

		FKCOMMIT()
	Endif
EndIf

//Para a Versao argentina gerara um titulo CH no SE2 e nao gerara
//movimentaçao bancaria ate que nao se consolide com o extrato.
If !(cPaisLoc $ "ARG|ANG|COL|MEX") .Or. Subs(cBancoAdt,1,2) == "CX" .or. cBancoAdt $ cBancoCx
	//Se for PA, gera movimentaçãoo bancária
	If SE2->E2_TIPO $ MVPAGANT

        lEmpGImp := !(lEmpPub .And. lAplMinP .And. SE2->(E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF) < nVlMPub )

        cCamposE5:="{"
        cCamposE5+= " {'E5_BENEF'  , '"+Iif(Empty(cBenef),SA2->A2_NOME,cBenef)+"'   }"
        cCamposE5+= ",{'E5_PREFIXO', '"+SE2->E2_PREFIXO+"'  }"
        cCamposE5+= ",{'E5_NUMERO' , '"+SE2->E2_NUM+"'  }"
        cCamposE5+= ",{'E5_PARCELA', '"+SE2->E2_PARCELA+"'  }"
        cCamposE5+= ",{'E5_TIPO'   , '"+SE2->E2_TIPO+"'  }"
        cCamposE5+= ",{'E5_CLIFOR' , '"+SE2->E2_FORNECE+"'  }"
        cCamposE5+= ",{'E5_FORNECE', '"+SE2->E2_FORNECE+"'  }"
        cCamposE5+= ",{'E5_LOJA'   , '"+SE2->E2_LOJA+"'  }"
        cCamposE5+= ",{'E5_DTDIGIT', dDataBase  }"
        cCamposE5+= ",{'E5_MOTBX'  , 'NOR'  }"

        //------------------------------------------------------
        //Reestruturacao SE5
        //aImpostos[1] = codigo imposto
        //aImpostos[2] = imposto calculado
        //aImpostos[3] = natureza
        //aImpostos[4] = cIdFK4
        //aImpostos[5] = imposto retido
        //aImpostos[6] = base calculado
        //aImpostos[7] = base retencao
        //aImpostos[8] = CPF/CNPJ de retenção
        //aImpostos[9] = Codigo de retenção
        //aImpostos[10] = Dedução IR Aluguel Simp. 
        //------------------------------------------------------

        //PCC
        //Se controla retencao, se eh PA e se mv_bx10925 = 1 (baixa), forca gerar tx's na emissao
        If !lPccMR .and. lContrRet .and. lPccBaixa .and. (nPisCalc + nCofCalc + nCslCalc) > 0
            //Recompoe a base do titulo corrente
            nBaseRet := SE2->(E2_VALOR+E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF+E2_INSS+E2_ISS)+ SE2->E2_SEST
            aCodRet := getCodRet()
            
            If nPisCalc > 0
                //Grava campos auxiliares do movimento de PA com referencia a rentecao e valor de retencao
                If (lEmpPub .and. !lEmpGImp) .Or. (SE2->E2_PIS <= 0)
                    cPRet:= "1"
                Else
                    cPRet:= " "
                EndIf
                cCamposE5+= ",{'E5_PRETPIS', '"+cPRet+"'  }"
                aadd(aImpostos,{"PIS",nPisCalc,SuperGetMV("MV_PISNAT"),"",SE2->E2_PIS,nPisBaseC,nPisBaseR,SA2->A2_CGC, aCodRet[1]})
            Endif 

            If nCofCalc > 0
                If (lEmpPub .and. !lEmpGImp) .Or. (SE2->E2_COFINS <= 0)
                    cPRet:= "1"
                Else
                    cPRet:= " "
                EndIf
                cCamposE5+= ",{'E5_PRETCOF', '"+cPRet+"'  }"
                aadd(aImpostos,{"COF",nCofCalc,SuperGetMV("MV_COFINS"),"",SE2->E2_COFINS,nCofBaseC,nCofBaseR,SA2->A2_CGC, aCodRet[2]})
            Endif

            If nCslCalc > 0
                If (lEmpPub .and. !lEmpGImp) .Or. (SE2->E2_CSLL <= 0)
                    cPRet:= "1"
                Else
                    cPRet:= " "
                EndIf
                cCamposE5+= ",{'E5_PRETCSL', '"+cPRet+"'  }"
                aadd(aImpostos,{"CSL",nCslCalc,SuperGetMV("MV_CSLL"),"",SE2->E2_CSLL,nCslBaseC,nCslBaseR,SA2->A2_CGC, aCodRet[3]})
            Endif            

            cCamposE5+= ",{'E5_VRETPIS',  " + cValToChar(SE2->E2_VRETPIS) + "}"
            cCamposE5+= ",{'E5_VRETCOF', " + cValToChar(SE2->E2_VRETCOF) + "}"
            cCamposE5+= ",{'E5_VRETCSL',  " + cValToChar(SE2->E2_VRETCSL) + "}"
        Endif

        //IRRF
        If !lIrfMR .and. lIRPFBaixa .and. ( nVCalIRF > 0  .or. Len(aRatIRF) > 0 )
            If (lEmpPub .and. !lEmpGImp) .Or. (SE2->E2_IRRF <= 0)
                cPRet:= "1"
            Else
                cPRet:= " "
            EndIf
            If !lEmpPub  .or. (lEmpPub .And. SE2->(E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF) > nVlMPub)
                nVlrRetIRF:= SE2->E2_IRRF
            Else 
                nVlrRetIRF:= 0
            EndIf
            If lFKCodRet
                cCodRet := SE2->E2_CODRET
            Else 
                cCodRet := ""
            Endif
            If __lLocBRA .and. !Empty(aRatIRF)  
                For nX := 1 to Len(aRatIRF)
                    lSimpIRAlu := If(len(aRatIRF[nX])>10, aRatIRF[nX][11], .F.)
                    aadd(aImpostos,{"IRF",aRatIRF[nX][6],&(SuperGetMV("MV_IRF")),"", aRatIRF[nX][6], aRatIRF[nX][5], aRatIRF[nX][5], aRatIRF[nX][3], cCodRet, lSimpIRAlu})       
                Next nX
            Else
                If FindFunction("fBxIRSimp") .And. FindFunction("f050IRSimp")
                    lSimpIRAlu := fBxIRSimp() .Or. f050IRSimp()
                EndIf
                aadd(aImpostos,{"IRF",nVCalIRF,&(SuperGetMV("MV_IRF")),"", nVlrRetIRF, nBCalIRF, nIrfBaseR,SA2->A2_CGC, cCodRet, lSimpIRAlu})        
            EndIf    
            
            cCamposE5 += ",{'E5_VRETIRF',  " + cValToChar(SE2->E2_VRETIRF) + "}"
            cCamposE5 += ",{'E5_PRETIRF', '" + cPRet + "'}"
            cCamposE5 += ",{'E5_BASEIRF', " + cValToChar(SE2->E2_BASEIRF) + "}"
        Endif
        cCodRet := ""
        //ISS
        If !lIssMR .and. FwIsInCallStack("FINA050") .And. (!lCalcIssBx .Or. (lCalcIssBx .And. SE2->E2_TIPO $ MVPAGANT)) .and. SE2->E2_ISS > 0
            cCamposE5+= ",{'E5_VRETISS',  "+cValToChar(SE2->E2_ISS)+"  }"
            aadd(aImpostos,{"ISS",SE2->E2_ISS,&(SuperGetMV("MV_ISS")),"", SE2->E2_ISS, SE2->E2_BASEISS, SE2->E2_BASEISS,SA2->A2_CGC, cCodRet})
        EndIf

		//Parametros:
		//  lLibCheq = MV_LIBCHEQ -> Opcao para liberacao de saldo bancario quando da geracao de cheques antes da baixa.
		//  cBancoCX = MV_CARTEIR -> Define os codigos dos bancos que operam em carteira.

		//Perguntas:
		//  MV_PAR05   -> Gera Cheque p/Titulos de Adiantamento
		//  MV_PAR09   -> Gera Movimento s/ Num. Cheque

		//Interface aValidGets -> FINA050
		// cChequeAdt  -> Num. do Cheque Digitado pelo Usuario
		// cBancoAdt   -> Codigo do Banco Digitado pelo Usuario

		lCond1 := lLibCheq .And. !Empty(AllTrim(cChequeAdt)) .And. Substr(cChequeAdt,1,1) != "*"
		lCond2 := Substr(cBancoAdt,1,2) == "CX"
		lCond3 := cBancoAdt $ cBancoCx
		lCond4 := mv_par05 == 2 .and. mv_par09 == 1
		lMovBanco := If((Empty(cBancoAdt) .Or. Empty(cAgenciaAdt) .Or. Empty(cNumCon)) .And. FwIsInCallStack("CD040CtPag"), .F., lMovBanco)

        cChaveTit := xFilial("SE2") + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM     + "|" + SE2->E2_PARCELA + "|" + ;
                                    SE2->E2_TIPO    + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
        cIdDoc	  := FWUUIDV4()
        cChaveFK7 := FINGRVFK7("SE2", cChaveTit)

		If (lCond1 .Or. lCond2 .Or. lCond3 .Or. lCond4) .And. lMovBanco

	        //  Regras para execucao
	        //   ----------------------------------------------------------------------------------------------
	        //    MV_LIBCHEQ | MV_PAR05 | MV_PAR09 | cBancoAdt(V)        | cChequeAdt(V)
	        //   ------------|----------|----------|---------------------|-------------------------------------
	        // 1     SIM     |          |          |                     | !Empty(V) .and. Substr(V,1,1) != "*"
	        // 2             |          |          | Substr(V,1,2)=="CX" |
	        // 3             |          |          | (V $ cBancoCx)      |
	        // 4     SIM     |   SIM    |   SIM    | !Empty(V)           |
	        // 4     SIM     |   NAO    |   SIM    | Empty(V)            |
	        // 5             |   NAO    |   SIM    | Empty(V)            |

            //-----------------------------------
            //PA DIRETO SEM CHEQUE
            //-----------------------------------
            If Empty(cChequeAdt)
                oModel :=  FWLoadModel('FINM050') // Mov. PA
                oModel:SetOperation( MODEL_OPERATION_INSERT ) // Inclusao
                oModel:Activate()
                oModel:SetValue( "MASTER", "E5_GRV", .T. )
                oModel:SetValue( "MASTER", "NOVOPROC", .T. )
                oSubFKA := oModel:GetModel( "FKADETAIL" )
                oSubFK3 := oModel:GetModel( "FK3DETAIL" )
                oSubFK4 := oModel:GetModel( "FK4DETAIL" )
                oSubFK5 := oModel:GetModel( "FK5DETAIL" )

                If Len(aImpostos)

                    //Dados do movimento dos impostos
                    If !oSubFKA:IsEmpty()
                        oSubFKA:AddLine()
                        oSubFKA:GoLine( oSubFKA:Length() )
                    Endif

                    oSubFKA:SetValue( "FKA_IDORIG", cChaveFK7 )
                    oSubFKA:SetValue( "FKA_TABORI", "SE2" )
                    //------------------------------------------------------
                    // Grava os valores agregados ao titulo no totalizador
                    //------------------------------------------------------
                    //Grava Imposto
                    For nImp:= 1 to Len(aImpostos)

                        If !oSubFK3:IsEmpty()
                            oSubFK3:AddLine()
                            oSubFK3:GoLine( oSubFK3:Length() )
                        Endif

                        oSubFK3:SetValue( "FK3_IDFK3" , GetSx8Num('FK3', 'FK3_IDFK3'))
                        oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
                        oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
                        oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nImp][1] )
                        oSubFK3:SetValue( "FK3_RECPAG", "P" )
                        oSubFK3:SetValue( "FK3_MOEDA" , "01" )
                        oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nImp][2]  )
                        oSubFK3:SetValue( "FK3_NATURE", aImpostos[nImp][3] )
                        oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG  )
                        oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nImp,6] )
                        oSubFK3:SetValue( "FK3_IDORIG", cChaveFK7 )
                        oSubFK3:SetValue( "FK3_TABORI", "SE2")
                      	If lFKCodRet 
		                    oSubFK3:SetValue( "FK3_CODRET" , aImpostos[nImp,9] )
	                    EndIf
                        
                        If lTemMR
                            oSubFK3:SetValue( "FK3_CLIFOR", SA2->A2_COD )
                            oSubFK3:SetValue( "FK3_LOJA"  , SA2->A2_LOJA )
                            oSubFK3:SetValue( "FK3_CGC"   , aImpostos[nImp][8] )
                            oSubFK3:SetValue( "FK3_RAICGC", Substr(aImpostos[nImp][8], 1, 8) )

                            If SE2->E2_MOEDA > 1
                                oSubFK3:SetValue("FK3_VLMOE2", Round(xMoeda(aImpostos[nImp][2],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTaxaMov),2))
                            Else
                                oSubFK3:SetValue("FK3_VLMOE2", aImpostos[nImp][2])
                            EndIf
                        Endif

                        If aImpostos[nImp,5] == 0
                            Loop
                        EndIf

                        cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
                        aImpostos[nImp,4] := cIdFK4

                        //Guardo o identificador de retencao do IR para atualizar a retencao de outros titulos retidos no atual
                        If aImpostos[nImp,1] == "IRF"
                            cIdFk4IR := cIdFK4
                        Endif

                        oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nImp,4]  )

                        If !oSubFK4:IsEmpty()
                            oSubFK4:AddLine()
                            oSubFK4:GoLine( oSubFK4:Length() )
                        EndIf

                        oSubFK4:SetValue( "FK4_IDFK4" ,aImpostos[nImp,4] )
                        oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
                        oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
                        oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nImp,1] )
                        oSubFK4:SetValue( "FK4_RECPAG", "P" )
                        oSubFK4:SetValue( "FK4_MOEDA" , "01" )
                        oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nImp,5] )
                        oSubFK4:SetValue( "FK4_NATURE", aImpostos[nImp,3] )
                        oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
                        oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nImp,7]  )
                        If lFKCodRet
		                    oSubFK4:SetValue( "FK4_CODRET" , aImpostos[nImp,9] )
	                    EndIf
                        If Len(aImpostos[nImp])> 9 .And. aImpostos[nImp][10]
                            If __lDicSimpl
                                oSubFK4:SetValue("FK4_DEDIRS", __nDedSimpl )
                            EndIf
                        Endif
                        
                        If lTemMR
                            oSubFK4:SetValue( "FK4_CLIFOR", SE2->E2_FORNECE )
                            oSubFK4:SetValue( "FK4_LOJA"  , SE2->E2_LOJA )
                            oSubFK4:SetValue( "FK4_CGC"   , aImpostos[nImp][8] )
                            oSubFK4:SetValue( "FK4_RAICGC", Substr(aImpostos[nImp][8], 1, 8) )

    						If SE2->E2_MOEDA > 1
								oSubFK4:SetValue("FK4_VLMOE2", Round(xMoeda(aImpostos[nImp,5],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTaxaMov),2))
							Else
								oSubFK4:SetValue("FK4_VLMOE2", aImpostos[nImp,5])
							EndIf
                        Endif
                    Next nImp
                Endif
                
                //MOVIMENTO BANCARIO DO PA
                If !oSubFKA:IsEmpty()
                    oSubFKA:AddLine()
                    oSubFKA:GoLine( oSubFKA:Length() )
                Endif

                oSubFKA:SetValue( "FKA_IDORIG", cIdDoc )
                oSubFKA:SetValue( "FKA_TABORI", "FK5" )

                oSubFK5:SetValue( "FK5_IDDOC"  , cChaveFK7 )
                oSubFK5:SetValue( "FK5_ORIGEM" , cOrig )
                oSubFK5:SetValue( "FK5_BANCO"  , cBancoAdt )
                oSubFK5:SetValue( "FK5_AGENCI" , cAgenciaAdt )
                oSubFK5:SetValue( "FK5_CONTA"  , cNumCon )
                oSubFK5:SetValue( "FK5_NUMCH"  , cChequeAdt )
                oSubFK5:SetValue( "FK5_DATA"   , SE2->E2_EMISSAO )
                oSubFK5:SetValue( "FK5_NATURE" , SE2->E2_NATUREZ )
                oSubFK5:SetValue( "FK5_TPDOC"  , 'PA')
                oSubFK5:SetValue( "FK5_HISTOR" , Iif(Empty(cHistor),SE2->E2_HIST,SubStr(cHistor,1,TAMSX3("FK5_HISTOR")[1])))
                oSubFK5:SetValue( "FK5_DTDISP" , SE2->E2_EMISSAO )
                oSubFK5:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO)
                oSubFK5:SetValue( "FK5_FILORI" , If(Empty(SE5->E5_FILORIG),cFilAnt,SE5->E5_FILORIG))
                oSubFK5:SetValue( "FK5_RECPAG" , "P" )
                oSubFK5:SetValue( "FK5_TXMOED" , nTaxaMov )               
                oSubFK5:SetValue( "FK5_RATEIO", If(SE2->E2_RATEIO == "S", "1", "2" ))

                If cPaisLoc == "RUS" .AND. !Empty(cUuidBs)
                    oSubFK5:SetValue("FK5_IDBS", cUuidBs)
                EndIf

                //Se a contabilizacao estiver sendo processada online, marcar o flag, senao continuar com a regra anterior discriminada logo abaixo
                If mv_par04 == 1
                    oSubFK5:SetValue( "FK5_LA", "S")
                EndIf

                If !__lLocBRA
                    If( Max(IIf(Type("SA6->A6_MOEDAP")=="U",SA6->A6_MOEDA,SA6->A6_MOEDAP),1) )== 1
                        oSubFK5:SetValue( "FK5_VALOR", SE2->E2_VLCRUZ)
                        If cPaisLoc == "RUS"
                            If SE2->E2_CONUNI == "1"
                                oSubFK5:SetValue( "FK5_VLMOE2", SE2->E2_VALOR)
                            Else
                                oSubFK5:SetValue( "FK5_VLMOE2",SE2->E2_VLCRUZ)
                            EndIf
                        Else
                            oSubFK5:SetValue( "FK5_VLMOE2", SE2->E2_VALOR)
                        EndIf
                        oSubFK5:SetValue( "FK5_MOEDA", Strzero(Max(IIf(Type('SA6->A6_MOEDAP')=='U',SA6->A6_MOEDA,SA6->A6_MOEDAP),1),2) )
                    Else
                        oSubFK5:SetValue( "FK5_VALOR", SE2->E2_VALOR)
                        oSubFK5:SetValue( "FK5_VLMOE2", SE2->E2_VLCRUZ  )
                        oSubFK5:SetValue( "FK5_MOEDA", Strzero(Max(IIf(Type('SA6->A6_MOEDAP')=='U',SA6->A6_MOEDA,SA6->A6_MOEDAP),1),2) )
                    EndIf
                Else
                    nVlrRet := SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL+E2_VRETIRF)
                    If nMoedaBco == 1 .and. (mv_par09 == 2 .and. mv_par05 == 2) .And. nVlrRet > 0
                        oSubFK5:SetValue( "FK5_VALOR", nVlrRet)
                        oSubFK5:SetValue( "FK5_VLMOE2", nVlrRet)
                        oSubFK5:SetValue( "FK5_MOEDA", '01' )
                    Else
                        oSubFK5:SetValue( "FK5_VALOR", Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,nMoedaBco,M->E2_EMISSAO,3,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1)))
                        oSubFK5:SetValue( "FK5_VLMOE2", SE2->E2_VALOR )
                        oSubFK5:SetValue( "FK5_MOEDA", Strzero(nMoedaBco,2)   )
                    EndIf
                EndIf

                cCamposE5+="}"
                oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

                If oModel:VldData()
                    oModel:CommitData()
                Else
                    cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
                    cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
                    cLog += cValToChar(oModel:GetErrorMessage()[6])

                    Help( ,,"M050VALID",,cLog, 1, 0 )
                Endif
                oModel:DeActivate()
                oModel:Destroy()
                oModel:= Nil

            //--------------------------------------------------
            //PA COM CHEQUE INFORMADO
            //--------------------------------------------------
            Else        
                If Len(aImpostos)
                    //Processo do SE2/SEF 
                    oModel :=  FWLoadModel('FINM050') // Mov. PA
                    oModel:SetOperation( MODEL_OPERATION_INSERT ) // Inclusao
                    oModel:Activate()
                    oModel:SetValue( "MASTER", "E5_GRV", .T. )
                    oModel:SetValue( "MASTER", "NOVOPROC", .T. )
                    oSubFKA := oModel:GetModel( "FKADETAIL" )
                    oSubFK3 := oModel:GetModel( "FK3DETAIL" )
                    oSubFK4 := oModel:GetModel( "FK4DETAIL" )
                    oSubFK5 := oModel:GetModel( "FK5DETAIL" )

                    If !Empty(cChaveCHT)            
                        oSubFKA:SetValue( "FKA_IDORIG", cChaveCHT )
                        oSubFKA:SetValue( "FKA_TABORI", "SEF" )
                    Endif    

                    //Dados do movimento dos impostos
                    If !oSubFKA:IsEmpty()
                        oSubFKA:AddLine()
                        oSubFKA:GoLine( oSubFKA:Length() )
                    Endif

                    oSubFKA:SetValue( "FKA_IDORIG", cChaveFK7 )
                    oSubFKA:SetValue( "FKA_TABORI", "SE2" )

                    //------------------------------------------------------
                    // Grava os valores agregados ao titulo no totalizador
                    //------------------------------------------------------
                    //Grava Imposto
                    For nImp:= 1 to Len(aImpostos)

                        If !oSubFK3:IsEmpty()
                            oSubFK3:AddLine()
                            oSubFK3:GoLine( oSubFK3:Length() )
                        Endif

                        oSubFK3:SetValue( "FK3_IDFK3" , FINFKSID('FK3', 'FK3_IDFK3'))
                        oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
                        oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
                        oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nImp][1] )
                        oSubFK3:SetValue( "FK3_RECPAG", "P" )
                        oSubFK3:SetValue( "FK3_MOEDA" , "01" )
                        oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nImp][2]  )
                        oSubFK3:SetValue( "FK3_NATURE", aImpostos[nImp][3] )
                        oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG  )
                        oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nImp,6] )
                        oSubFK3:SetValue( "FK3_IDORIG", cChaveFK7 )
                        oSubFK3:SetValue( "FK3_TABORI", "SE2")
                        If lFKCodRet
		                    oSubFK3:SetValue( "FK3_CODRET" , aImpostos[nImp,9] )
	                    EndIf
                        
                        If lTemMR
                            oSubFK3:SetValue( "FK3_CLIFOR", SE2->E2_FORNECE )
                            oSubFK3:SetValue( "FK3_LOJA"  , SE2->E2_LOJA )
                            oSubFK3:SetValue( "FK3_CGC"   , aImpostos[nImp][8] )
                            oSubFK3:SetValue( "FK3_RAICGC", Substr(aImpostos[nImp][8], 1, 8) )
                            If SE2->E2_MOEDA > 1
                                oSubFK3:SetValue("FK3_VLMOE2", Round(xMoeda(aImpostos[nImp][2],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTaxaMov),2))
                            Else
                                oSubFK3:SetValue("FK3_VLMOE2", aImpostos[nImp][2])
                            EndIf
                        Endif
                        
                        If aImpostos[nImp,5] == 0
                            Loop
                        EndIf

                        cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
                        aImpostos[nImp,4] := cIdFK4

                        //Guardo o identificador de retencao do IR para atualizar a retencao de outros titulos retidos no atual
                        If aImpostos[nImp,1] == "IRF"
                            cIdFk4IR := cIdFK4
                        Endif

                        oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nImp,4]  )

                        If !oSubFK4:IsEmpty()
                            oSubFK4:AddLine()
                        EndIf

                        oSubFK4:GoLine( oSubFK4:Length() )

                        oSubFK4:SetValue( "FK4_IDFK4" ,aImpostos[nImp,4] )
                        oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
                        oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
                        oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nImp,1] )
                        oSubFK4:SetValue( "FK4_RECPAG", "P" )
                        oSubFK4:SetValue( "FK4_MOEDA" , "01" )
                        oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nImp,5] )
                        oSubFK4:SetValue( "FK4_NATURE", aImpostos[nImp,3] )
                        oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
                        oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nImp,7]  )
                        If lFKCodRet
		                    oSubFK4:SetValue( "FK4_CODRET" , aImpostos[nImp,9] )
	                    EndIf
                        If lTemMR
                            oSubFK4:SetValue( "FK4_CLIFOR", SE2->E2_FORNECE )
                            oSubFK4:SetValue( "FK4_LOJA"  , SE2->E2_LOJA )
                            oSubFK4:SetValue( "FK4_CGC"   , aImpostos[nImp][8] )
                            oSubFK4:SetValue( "FK4_RAICGC", Substr(aImpostos[nImp][8], 1, 8) )

    						If SE2->E2_MOEDA > 1
								oSubFK4:SetValue("FK4_VLMOE2", Round(xMoeda(aImpostos[nImp,5],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTaxaMov),2))
							Else
								oSubFK4:SetValue("FK4_VLMOE2", aImpostos[nImp,5])
							EndIf
                        Endif

                        If Len(aImpostos[nImp])> 9 .And. aImpostos[nImp][10]
                            If __lDicSimpl
                                oSubFK4:SetValue("FK4_DEDIRS", __nDedSimpl )
                            EndIf
                        Endif

                    Next nImp

                    cCamposE5+="}"
                    oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

                    If oModel:VldData()
                        oModel:CommitData()
                    Else
                        cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
                        cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
                        cLog += cValToChar(oModel:GetErrorMessage()[6])
                        lRet := .F.
                        Help( ,,"M050VALID",,cLog, 1, 0 )
                    Endif
                    oModel:DeActivate()
                    oModel:Destroy()
                    oModel:= Nil

                Endif

                //Processo do movimento bancário com cheque (FK5/SEF)
                oModel :=  FWLoadModel('FINM050') // Mov. PA
                oModel:SetOperation( MODEL_OPERATION_INSERT ) // Inclusao
                oModel:Activate()
                oModel:SetValue( "MASTER", "E5_GRV", .T. )
                oModel:SetValue( "MASTER", "NOVOPROC", .F. )
                oSubFKA := oModel:GetModel( "FKADETAIL" )
                oSubFK5 := oModel:GetModel( "FK5DETAIL" )

                //Registro do cheque na FKA no processo do movimento bancário
                If !Empty(cChequeAdt)
                    oModel:SetValue( "MASTER", "NOVOPROC", .T. )
                    oSubFKA:SetValue( "FKA_IDORIG", cChaveCH )
                    oSubFKA:SetValue( "FKA_TABORI", "SEF" )
                Endif

                cIdDoc	  := FWUUIDV4()
                //Dados do movimento dos impostos
                If !oSubFKA:IsEmpty()
                    oSubFKA:AddLine()
                    oSubFKA:GoLine( oSubFKA:Length() )
                Endif

                oSubFKA:SetValue( "FKA_IDORIG", cIdDoc )
                oSubFKA:SetValue( "FKA_TABORI", "FK5" )

                oSubFK5:SetValue( "FK5_IDDOC"  , cChaveFK7 )
                oSubFK5:SetValue( "FK5_ORIGEM" , cOrig )
                oSubFK5:SetValue( "FK5_BANCO"  , cBancoAdt )
                oSubFK5:SetValue( "FK5_AGENCI" , cAgenciaAdt )
                oSubFK5:SetValue( "FK5_CONTA"  , cNumCon )
                oSubFK5:SetValue( "FK5_NUMCH"  , cChequeAdt )
                oSubFK5:SetValue( "FK5_DATA"   , SE2->E2_EMISSAO )
                oSubFK5:SetValue( "FK5_NATURE" , SE2->E2_NATUREZ )
                oSubFK5:SetValue( "FK5_TPDOC"  , 'PA')
                oSubFK5:SetValue( "FK5_HISTOR" , Iif(Empty(cHistor),SE2->E2_HIST,SubStr(cHistor,1,TAMSX3("FK5_HISTOR")[1])))
                oSubFK5:SetValue( "FK5_DTDISP" , SE2->E2_EMISSAO )
                oSubFK5:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO)
                oSubFK5:SetValue( "FK5_FILORI" , If(Empty(SE5->E5_FILORIG),cFilAnt,SE5->E5_FILORIG))
                oSubFK5:SetValue( "FK5_RECPAG" ,"P" )
                oSubFK5:SetValue( "FK5_TXMOED" , nTaxaMov )               

                If cPaisLoc == "RUS" .AND. !Empty(cUuidBs)
                    oSubFK5:SetValue("FK5_IDBS", cUuidBs)
                EndIf

                If SE2->E2_RATEIO == "S"
                    oSubFK5:SetValue( "FK5_RATEIO",  "1" )
                Else
                    oSubFK5:SetValue( "FK5_RATEIO",  "2" )
                EndIf

                //Se a contabilizacao estiver sendo processada online, marcar o flag, senao continuar com a regra anterior discriminada logo abaixo
                If mv_par04 == 1
                    oSubFK5:SetValue( "FK5_LA", "S")
                EndIf

                If !__lLocBRA
                    If nMoedaBco == 1
                        oSubFK5:SetValue( "FK5_VALOR", SE2->E2_VLCRUZ)
                        If cPaisLoc == "RUS"
                            If SE2->E2_CONUNI == "1"
                        oSubFK5:SetValue( "FK5_VLMOE2", SE2->E2_VALOR)
                            Else
                                oSubFK5:SetValue( "FK5_VLMOE2",SE2->E2_VLCRUZ)
                            EndIf
                        Else
                            oSubFK5:SetValue( "FK5_VLMOE2", SE2->E2_VALOR)
                        EndIf
                    Else
                        oSubFK5:SetValue( "FK5_VALOR", SE2->E2_VALOR)
                        oSubFK5:SetValue( "FK5_VLMOE2", SE2->E2_VLCRUZ  )
                    EndIf
                    oSubFK5:SetValue( "FK5_MOEDA", Strzero(nMoedaBco,2) )
                Else
                    nVlrRet := SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL+E2_VRETIRF)
                    If nMoedaBco == 1 .and. (mv_par09 == 2 .and. mv_par05 == 2) .And. nVlrRet > 0
                        oSubFK5:SetValue( "FK5_VALOR", nVlrRet)
                        oSubFK5:SetValue( "FK5_VLMOE2", nVlrRet)
                        oSubFK5:SetValue( "FK5_MOEDA", '01' )
                    Else
                        oSubFK5:SetValue( "FK5_VALOR", Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,nMoedaBco,M->E2_EMISSAO,3,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1)))
                        oSubFK5:SetValue( "FK5_VLMOE2", SE2->E2_VALOR )
                        oSubFK5:SetValue( "FK5_MOEDA", Strzero(nMoedaBco,2)   )
                    EndIf
                EndIf

                cCamposE5+="}"
                oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

                If oModel:VldData()
                    oModel:CommitData()
                Else
                    cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
                    cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
                    cLog += cValToChar(oModel:GetErrorMessage()[6])
                    lRet  := .F.
                    Help( ,,"M050VALID",,cLog, 1, 0 )
                Endif

                oModel:DeActivate()
                oModel:Destroy()
                oModel:= Nil
            Endif

            If lRet
			    AtuSalBco( cBancoAdt,cAgenciaAdt,cNumCon,SE2->E2_EMISSAO,FK5->FK5_VALOR,"-" )
            Endif
		Else
            //-----------------------------------------------------------
            // PA SEM MOVIMENTO (CHEQUE NÃO LIBERADO OU NÃO INFORMADO) 
            //-----------------------------------------------------------
			If mv_par05 == 1 .and.; // Gera Cheque p/Titulos de Adiantamento
			   (mv_par09 == 1 .or. mv_par09 == 2) .and.; // Gera Movimento s/ Num. Cheque
			   (Empty(cChequeAdt) .or.; // Num. do Cheque não Digitado pelo Usuario
			   !Empty(cChequeAdt) .And. !lLibCheq) // Necessaria Liberação do Cheque
			    //-------------------------------------------------------------------------
			    // Obs.: Mantida a gravação com Reclock SE5 porque essa rotina não deverá
                //       gerar FK5 de acordo com os parametros acima, porque estaremos
			    //       gerando a FK5 no rotina de geração de cheques.
			    //-------------------------------------------------------------------------
			   	RecLock("SE5",.T.)
                SE5->E5_FILIAL	:= xFilial()
                SE5->E5_BANCO	:= cBancoAdt
                SE5->E5_AGENCIA	:= cAgenciaAdt
                SE5->E5_CONTA	:= cNumCon
                SE5->E5_NUMCHEQ	:= cChequeAdt
                SE5->E5_DATA	:= SE2->E2_EMISSAO
                SE5->E5_NATUREZ	:= SE2->E2_NATUREZ
                SE5->E5_RECPAG	:= "P"
                SE5->E5_TIPO	:= MVPAGANT
                SE5->E5_ORIGEM  := cOrig
				SE5->E5_HISTOR	:= Iif(Empty(cHistor),SE2->E2_HIST,cHistor)
				SE5->E5_BENEF	:= Iif(Empty(cBenef),SA2->A2_NOME,cBenef)
				SE5->E5_PREFIXO	:= SE2->E2_PREFIXO
				SE5->E5_NUMERO	:= SE2->E2_NUM
				SE5->E5_PARCELA	:= SE2->E2_PARCELA
				SE5->E5_CLIFOR	:= SE2->E2_FORNECE
				SE5->E5_FORNECE	:= SE2->E2_FORNECE
				SE5->E5_LOJA	:= SE2->E2_LOJA
				SE5->E5_DTDIGIT	:= dDataBase
				SE5->E5_MOTBX	:= "NOR"
				SE5->E5_DTDISPO	:= SE5->E5_DATA
				SE5->E5_VLDESCO	:= SE2->E2_DECRESC
				SE5->E5_VLJUROS	:= SE2->E2_ACRESC
				SE5->E5_VLACRES	:= SE2->E2_ACRESC
				SE5->E5_VLDECRE	:= SE2->E2_DECRESC
				SE5->E5_CCUSTO	:= SE2->E2_CCUSTO
				SE5->E5_MOVFKS	:= "S"
				SE5->E5_IDORIG	:= cChaveFK7
				SE5->E5_TABORI	:= "SE2"
				SE5->E5_FILORIG  := If(Empty(SE5->E5_FILORIG),cFilAnt,SE5->E5_FILORIG)

				If mv_par04 == 1
					SE5->E5_LA	:= "S"
				EndIf
				If cPaisLoc $ "EUA"
					SE5->E5_TIPODOC	:= "PA"
				Else
					SE5->E5_TIPODOC	:= "BA"
				EndIF

				If __lLocBRA
					SE5->E5_MOEDA	:= Strzero(Max(IIf(Type("SA6->A6_MOEDAP")=="U",SA6->A6_MOEDA,SA6->A6_MOEDAP),1),2)
					SE5->E5_VALOR	:= SE2->E2_VLCRUZ
					SE5->E5_VLMOED2	:= SE2->E2_VALOR
				Else
					SE5->E5_VALOR	:= SE2->E2_VALOR
					SE5->E5_VLMOED2	:= SE2->E2_VLCRUZ
				Endif

                If !lIrfMR .and. lIRPFBaixa .and. nVCalIRF > 0  
                    If (lEmpPub .and. !lEmpGImp) .Or. (SE2->E2_IRRF <= 0)
                        cPRet:= "1"
                    Else
                        cPRet:= " "
                    EndIf
					SE5->E5_VRETIRF := 	SE2->E2_VRETIRF
					SE5->E5_BASEIRF := 	SE2->E2_BASEIRF
                    SE5->E5_PRETIRF := 	cPRet
				Endif
			
                SE5->(MsUnlock())

                //Gravação dos impostos e o processo de inclusão do título na FKA
                oModel :=  FWLoadModel('FINM050') // Mov. PA
                oModel:SetOperation( MODEL_OPERATION_INSERT ) // Inclusao
                oModel:Activate()
                oModel:SetValue( "MASTER", "E5_GRV", .T. )
                oModel:SetValue( "MASTER", "NOVOPROC", .T. )
                oSubFKA := oModel:GetModel( "FKADETAIL" )
                oSubFK3 := oModel:GetModel( "FK3DETAIL" )
                oSubFK4 := oModel:GetModel( "FK4DETAIL" )

                If !Empty(cChaveCHT)            
                    oSubFKA:SetValue( "FKA_IDORIG", cChaveCHT )
                    oSubFKA:SetValue( "FKA_TABORI", "SEF" )
                Endif    

                //Dados do movimento dos impostos
                If !oSubFKA:IsEmpty()
                    oSubFKA:AddLine()
                    oSubFKA:GoLine( oSubFKA:Length() )
                Endif

                oSubFKA:SetValue( "FKA_IDORIG", cChaveFK7 )
                oSubFKA:SetValue( "FKA_TABORI", "SE2" )

                If Len(aImpostos)
                    //Grava Imposto
                    For nImp:= 1 to Len(aImpostos)

                        If !oSubFK3:IsEmpty()
                            //Inclui a quantidade de linhas necessárias
                            oSubFK3:AddLine()

                            //Vai para linha criada
                            oSubFK3:GoLine( oSubFK3:Length() )
                        Endif

                        oSubFK3:SetValue( "FK3_IDFK3" , FINFKSID('FK3', 'FK3_IDFK3'))
                        oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
                        oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
                        oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nImp][1] )
                        oSubFK3:SetValue( "FK3_RECPAG", "P" )
                        oSubFK3:SetValue( "FK3_MOEDA" , "01" )
                        oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nImp][2]  )
                        oSubFK3:SetValue( "FK3_NATURE", aImpostos[nImp][3] )
                        oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG  )
                        oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nImp,6] )
                        oSubFK3:SetValue( "FK3_IDORIG", cChaveFK7 )
                        oSubFK3:SetValue( "FK3_TABORI", "SE2")
                        If lFKCodRet
		                    oSubFK3:SetValue( "FK3_CODRET" , aImpostos[nImp,9] )
	                    EndIf
                        
                        If lTemMR
                            oSubFK3:SetValue( "FK3_CLIFOR", SE2->E2_FORNECE )
                            oSubFK3:SetValue( "FK3_LOJA"  , SE2->E2_LOJA )
                            oSubFK3:SetValue( "FK3_CGC"   , aImpostos[nImp][8] )
                            oSubFK3:SetValue( "FK3_RAICGC", Substr(aImpostos[nImp][8], 1, 8) )
                            If SE2->E2_MOEDA > 1
                                oSubFK3:SetValue("FK3_VLMOE2", Round(xMoeda(aImpostos[nImp][2],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTaxaMov),2))
                            Else
                                oSubFK3:SetValue("FK3_VLMOE2", aImpostos[nImp][2])
                            EndIf
                        Endif
                        
                        If aImpostos[nImp,5] == 0
                            Loop
                        EndIf

                        cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
                        aImpostos[nImp,4] := cIdFK4

                        //Guardo o identificador de retencao do IR para atualizar a retencao de outros titulos retidos no atual
                        If aImpostos[nImp,1] == "IRF"
                            cIdFk4IR := cIdFK4
                        Endif

                        oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nImp,4]  )

                        If !oSubFK4:IsEmpty()
                            oSubFK4:AddLine()
                        EndIf

                        oSubFK4:GoLine( oSubFK4:Length() )

                        oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nImp,4] )
                        oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
                        oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
                        oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nImp,1] )
                        oSubFK4:SetValue( "FK4_RECPAG", "P" )
                        oSubFK4:SetValue( "FK4_MOEDA" , "01" )
                        oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nImp,5] )
                        oSubFK4:SetValue( "FK4_NATURE", aImpostos[nImp,3] )
                        oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
                        oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nImp,7]  )
                        If lFKCodRet
		                    oSubFK4:SetValue( "FK4_CODRET" , aImpostos[nImp,9] )
	                    EndIf
                        If Len(aImpostos[nImp])> 9 .And. aImpostos[nImp][10]
                            If __lDicSimpl
                                oSubFK4:SetValue("FK4_DEDIRS", __nDedSimpl )
                            EndIf
                        Endif
                        If lTemMR
                            oSubFK4:SetValue( "FK4_CLIFOR", SE2->E2_FORNECE )
                            oSubFK4:SetValue( "FK4_LOJA"  , SE2->E2_LOJA )
                            oSubFK4:SetValue( "FK4_CGC"   , aImpostos[nImp][8] )
                            oSubFK4:SetValue( "FK4_RAICGC", Substr(aImpostos[nImp][8], 1, 8) )
    
    						If SE2->E2_MOEDA > 1
								oSubFK4:SetValue("FK4_VLMOE2", Round(xMoeda(aImpostos[nImp,5],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTaxaMov),2))
							Else
								oSubFK4:SetValue("FK4_VLMOE2", aImpostos[nImp,5])
							EndIf

                        Endif
                    Next nImp
                Endif

                If oModel:VldData()
                    oModel:CommitData()
                Else
                    cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
                    cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
                    cLog += cValToChar(oModel:GetErrorMessage()[6])
                    lRet  := .F.
                    Help( ,,"M050VALID",,cLog, 1, 0 )
                Endif

                oModel:DeActivate()
                oModel:Destroy()
                oModel:= Nil

            //PA CNAB 
        	ElseIf __lLocBRA .AND. lPccBaixa .AND. ( mv_par05 == 2 .AND. mv_par09 == 2 )

                If Len(aImpostos)

                    //Gravação dos impostos e o processo de inclusão do título na FKA
                    oModel :=  FWLoadModel('FINM050') // Mov. PA
                    oModel:SetOperation( MODEL_OPERATION_INSERT ) // Inclusao
                    oModel:Activate()
                    oModel:SetValue( "MASTER", "E5_GRV", .T. )
                    oModel:SetValue( "MASTER", "NOVOPROC", .T. )
                    oSubFKA := oModel:GetModel( "FKADETAIL" )
                    oSubFK3 := oModel:GetModel( "FK3DETAIL" )
                    oSubFK4 := oModel:GetModel( "FK4DETAIL" )

                    oSubFKA:SetValue( "FKA_IDORIG", cChaveFK7 )
                    oSubFKA:SetValue( "FKA_TABORI", "SE2" )

                    //Grava Imposto
                    For nImp:= 1 to Len(aImpostos)

                        If !oSubFK3:IsEmpty()
                            //Inclui a quantidade de linhas necessárias
                            oSubFK3:AddLine()

                            //Vai para linha criada
                            oSubFK3:GoLine( oSubFK3:Length() )
                        Endif

                        oSubFK3:SetValue( "FK3_IDFK3" , FINFKSID('FK3', 'FK3_IDFK3'))
                        oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
                        oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
                        oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nImp][1] )
                        oSubFK3:SetValue( "FK3_RECPAG", "P" )
                        oSubFK3:SetValue( "FK3_MOEDA" , "01" )
                        oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nImp][2]  )
                        oSubFK3:SetValue( "FK3_NATURE", aImpostos[nImp][3] )
                        oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG  )
                        oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nImp,6] )
                        oSubFK3:SetValue( "FK3_IDORIG", cChaveFK7 )
                        oSubFK3:SetValue( "FK3_TABORI", "SE2")
                        If lFKCodRet
		                    oSubFK3:SetValue( "FK3_CODRET" , aImpostos[nImp,9] )
	                    EndIf
                        If lTemMR
                            oSubFK3:SetValue( "FK3_CLIFOR", SE2->E2_FORNECE )
                            oSubFK3:SetValue( "FK3_LOJA"  , SE2->E2_LOJA )
                            oSubFK3:SetValue( "FK3_CGC"   , aImpostos[nImp][8] )
                            oSubFK3:SetValue( "FK3_RAICGC", Substr(aImpostos[nImp][8], 1, 8) )
                            If SE2->E2_MOEDA > 1
                                oSubFK3:SetValue("FK3_VLMOE2", Round(xMoeda(aImpostos[nImp][2],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTaxaMov),2))
                            Else
                                oSubFK3:SetValue("FK3_VLMOE2", aImpostos[nImp][2])
                            EndIf
                        Endif
                        
                        If aImpostos[nImp,5] == 0
                            Loop
                        EndIf

                        cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
                        aImpostos[nImp,4] := cIdFK4

                        //Guardo o identificador de retencao do IR para atualizar a retencao de outros titulos retidos no atual
                        If aImpostos[nImp,1] == "IRF"
                            cIdFk4IR := cIdFK4
                        Endif

                        oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nImp,4]  )

                        If !oSubFK4:IsEmpty()
                            oSubFK4:AddLine()
                        EndIf

                        oSubFK4:GoLine( oSubFK4:Length() )

                        oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nImp,4] )
                        oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
                        oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
                        oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nImp,1] )
                        oSubFK4:SetValue( "FK4_RECPAG", "P" )
                        oSubFK4:SetValue( "FK4_MOEDA" , "01" )
                        oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nImp,5] )
                        oSubFK4:SetValue( "FK4_NATURE", aImpostos[nImp,3] )
                        oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
                        oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nImp,7]  )
                        If lFKCodRet 
		                    oSubFK4:SetValue( "FK4_CODRET" , aImpostos[nImp,9] )
	                    EndIf
                        If Len(aImpostos[nImp])> 9 .And. aImpostos[nImp][10]
                            If __lDicSimpl
                                oSubFK4:SetValue("FK4_DEDIRS", __nDedSimpl )
                            EndIf
                        Endif
                        If lTemMR
                            oSubFK4:SetValue( "FK4_CLIFOR", SE2->E2_FORNECE )
                            oSubFK4:SetValue( "FK4_LOJA"  , SE2->E2_LOJA )
                            oSubFK4:SetValue( "FK4_CGC"   , aImpostos[nImp][8] )
                            oSubFK4:SetValue( "FK4_RAICGC", Substr(aImpostos[nImp][8], 1, 8) )
    
    						If SE2->E2_MOEDA > 1
								oSubFK4:SetValue("FK4_VLMOE2", Round(xMoeda(aImpostos[nImp,5],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTaxaMov),2))
							Else
								oSubFK4:SetValue("FK4_VLMOE2", aImpostos[nImp,5])
							EndIf

                        Endif
                    Next nImp

                    If oModel:VldData()
                        oModel:CommitData()
                    Else
                        cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
                        cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
                        cLog += cValToChar(oModel:GetErrorMessage()[6])
                        lRet  := .F.
                        Help( ,,"M050VALID",,cLog, 1, 0 )
                    Endif

                    oModel:DeActivate()
                    oModel:Destroy()
                    oModel:= Nil

                Endif
            Endif
        Endif

        //Relacionamento de cumulatividade de impostos
        If Len(aImpostos) > 0

            RestArea(aAreaAnt)

            For nX:= 1 to len(aTitCalc)
                FINGFK3BOR(2,aTitCalc[nX,1],aTitCalc[nX,2],aImpostos,.F.)
            Next

            If !lIrfMR .and. lIRPFBaixa
                //IRRF - BAIXA
                FGRVSFQIR(SE2->E2_VRETIRF,SE2->E2_BASEIRF,aDadosIr,/*cSequencia*/,@cCamposIR,cIdFk4IR)
            EndIf

            If !lPccMR
                Do Case
                    Case cModRetPIS == "1"
                        //Calcula a base total do fornecedor pendente para verificar
                        If aDadosRet[ 1 ] + nBaseRet > nVlMinImp .And. lEmpGImp
                            lRetParc := .T.
                            //Rotina para gerar titulo de adiantamento
                            If cNCCRet == "1" .and. nDiferImp < 0
                                FGerCredRt(Abs(nDiferImp),SE2->E2_MOEDA,SE5->E5_SEQ)
                            Endif

                            nRecSE5 := SE5->( Recno() )

                            //Exclui a Marca de "pendente recolhimento" dos demais registros
                            If aDadosRet[1] > 0
                                aRecnos   := If( Len(aDadosRet) >= 6 , aClone( aDadosRet[ 6 ] ), aClone( aDadosRet[ 5 ] ) )
                                cPrefOri  := SE5->E5_PREFIXO
                                cNumOri   := SE5->E5_NUMERO
                                cParcOri  := SE5->E5_PARCELA
                                cTipoOri  := SE5->E5_TIPO
                                cCfOri    := SE5->E5_CLIFOR
                                cLojaOri  := SE5->E5_LOJA

                                For nLoop := 1 to Len( aRecnos )
                                    SE5->( dbGoto( aRecnos[ nLoop ] ) )
                                    aAreaAnt := GetArea()

                                    cCamposE5:="{"
                                    cCamposE5+= "{'E5_PRETPIS', '2' }"
                                    cCamposE5+= ",{'E5_PRETCOF', '2' }"
                                    cCamposE5+= ",{'E5_PRETCSL', '2' }"
                                    cCamposE5+="}"

                                    oModel :=  FWLoadModel('FINM030')//Movimentos Bancarios
                                    oModel:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
                                    oModel:Activate()
                                    oSubFKA := oModel:GetModel( "FKADETAIL" )

                                    If oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
                                        oSubFK3:= oModel:GetModel( "FK3DETAIL" )

                                        For nImp := 1 to Len(aImpostos)

                                            If aImpostos[nImp,1] <> "IRF" .And. oSubFK3:SeekLine({{"FK3_IMPOS", aImpostos[nImp,1]}}) .AND. Empty(oSubFK3:GetValue("FK3_IDRET"))			//Nome do imposto
                                                oSubFK3:SetValue( "FK3_IDRET",  aImpostos[nImp,4] )		//cIdFk4
                                            Endif

                                        Next nImp
                                    EndIf

                                    oModel:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
                                    oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5

                                    If oModel:VldData()
                                        oModel:CommitData()
                                    Else
                                        cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
                                        cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
                                        cLog += cValToChar(oModel:GetErrorMessage()[6])
                                        Help( ,,"M050VALID",,cLog, 1, 0 )
                                    Endif

                                    oModel:DeActivate()
                                    oModel:Destroy()
                                    oModel:= Nil

                                    RestArea(aAreaAnt)

                                    If nRecSE5 <> aRecnos[ nLoop ]
                                        dbSelectArea("SFQ")
                                        RecLock("SFQ",.T.)
                                        SFQ->FQ_FILIAL  := xFilial("SFQ")
                                        SFQ->FQ_ENTORI  := "SE5"
                                        SFQ->FQ_PREFORI := cPrefOri
                                        SFQ->FQ_NUMORI  := cNumOri
                                        SFQ->FQ_PARCORI := cParcOri
                                        SFQ->FQ_TIPOORI := cTipoOri
                                        SFQ->FQ_CFORI   := cCfOri
                                        SFQ->FQ_LOJAORI := cLojaOri
                                        SFQ->FQ_SEQORI  := Space(TamSX3("FQ_SEQORI")[1])
                                        SFQ->FQ_ENTDES  := "SE5"
                                        SFQ->FQ_PREFDES := SE5->E5_PREFIXO
                                        SFQ->FQ_NUMDES  := SE5->E5_NUMERO
                                        SFQ->FQ_PARCDES := SE5->E5_PARCELA
                                        SFQ->FQ_TIPODES := SE5->E5_TIPO
                                        SFQ->FQ_CFDES   := SE5->E5_CLIFOR
                                        SFQ->FQ_LOJADES := SE5->E5_LOJA
                                        SFQ->FQ_SEQDES  := SE5->E5_SEQ
                                        //Grava a filial de destino caso o campo exista
                                        SFQ->FQ_FILDES := SE5->E5_FILIAL
                                        MsUnlock()
                                    Endif
                                Next nLoop
                            Endif

                            //Retorna do ponteiro do SE2 para a parcela
                            SE5->( MsGoto( nRecSE5 ) )
                        Else
                            lRetParc := .F.
                        EndIf
                    Case cModRetPIS == "2"
                        //Efetua a retencao
                        nRecSE5 := SE5->( Recno() )

                        //Exclui a Marca de "pendente recolhimento" dos demais registros
                        If aDadosRet[1] > 0
                            aRecnos := If( Len(aDadosRet) >= 6 , aClone( aDadosRet[ 6 ] ), aClone( aDadosRet[ 5 ] ) )
                            cPrefOri  := SE5->E5_PREFIXO
                            cNumOri   := SE5->E5_NUMERO
                            cParcOri  := SE5->E5_PARCELA
                            cTipoOri  := SE5->E5_TIPO
                            cCfOri    := SE5->E5_CLIFOR
                            cLojaOri  := SE5->E5_LOJA

                            For nLoop := 1 to Len( aRecnos )
                                SE5->( dbGoto( aRecnos[ nLoop ] ) )
                                cCamposE5:="{"
                                cCamposE5+= "{'E5_PRETPIS', '2' }"
                                cCamposE5+= ",{'E5_PRETCOF', '2' }"
                                cCamposE5+= ",{'E5_PRETCSL', '2' }"
                                cCamposE5+="}"

                                oModel :=  FWLoadModel('FINM030')//Movimentos Bancarios
                                oModel:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
                                oModel:Activate()
                                oSubFKA := oModel:GetModel( "FKADETAIL" )

                                If oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
                                    oSubFK3:= oModel:GetModel( "FK3DETAIL" )

                                    For nImp := 1 to Len(aImpostos)

                                        If aImpostos[nImp,1] <> "IRF" .And. oSubFK3:SeekLine({{"FK3_IMPOS", aImpostos[nImp,1]}})			//Nome do imposto
                                            oSubFK3:SetValue( "FK3_IDRET",  aImpostos[nImp,4] )		//cIdFk4
                                        Endif

                                    Next nImp
                                EndIf

                                oModel:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
                                oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5

                                If oModel:VldData()
                                    oModel:CommitData()
                                Else
                                    cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
                                    cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
                                    cLog += cValToChar(oModel:GetErrorMessage()[6])
                                    Help( ,,"M050VALID",,cLog, 1, 0 )
                                Endif

                                oModel:DeActivate()
                                oModel:Destroy()
                                oModel:= Nil

                                dbSelectArea("SFQ")
                                RecLock("SFQ",.T.)
                                SFQ->FQ_FILIAL  := xFilial("SFQ")
                                SFQ->FQ_ENTORI  := "SE5"
                                SFQ->FQ_PREFORI := cPrefOri
                                SFQ->FQ_NUMORI  := cNumOri
                                SFQ->FQ_PARCORI := cParcOri
                                SFQ->FQ_TIPOORI := cTipoOri
                                SFQ->FQ_CFORI   := cCfOri
                                SFQ->FQ_LOJAORI := cLojaOri
                                SFQ->FQ_SEQORI  := cSequencia
                                SFQ->FQ_ENTDES  := "SE5"
                                SFQ->FQ_PREFDES := SE5->E5_PREFIXO
                                SFQ->FQ_NUMDES  := SE5->E5_NUMERO
                                SFQ->FQ_PARCDES := SE5->E5_PARCELA
                                SFQ->FQ_TIPODES := SE5->E5_TIPO
                                SFQ->FQ_CFDES   := SE5->E5_CLIFOR
                                SFQ->FQ_LOJADES := SE5->E5_LOJA
                                SFQ->FQ_SEQDES  := SE5->E5_SEQ
                                //Grava a filial de destino caso o campo exista
                                SFQ->FQ_FILDES := SE5->E5_FILIAL
                                MsUnlock()
                            Next nLoop
                        Endif

                        //Retorna do ponteiro do SE1 para a parcela
                        SE5->( MsGoto( nRecSE5 ) )
                        Reclock( "SE2", .F. )
                        lRetParc := .T.
                    Case cModRetPIS == "3"
                        //Grava a Marca de "pendente recolhimento" dos demais registros
                        If SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL + SE2->E2_IRRF > 0
                            //Grava Imposto calculado - PIS/COFINS/CSLL
                            cCamposE5:="{"
                            cCamposE5+= "{'E5_VRETPIS', "+cValToChar(SE2->E2_PIS)+" }"
                            cCamposE5+= ",{'E5_VRETCOF', "+cValToChar(SE2->E2_COFINS)+" }"
                            cCamposE5+= ",{'E5_VRETCSL', "+cValToChar(SE2->E2_CSLL)+" }"
                            cCamposE5+= ",{'E5_PRETPIS', '1' }"
                            cCamposE5+= ",{'E5_PRETCOF', '1' }"
                            cCamposE5+= ",{'E5_PRETCSL', '1' }"
                            cCamposE5+="}"

                            oModel :=  FWLoadModel('FINM030')//Movimentos Bancarios
                            oModel:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
                            oModel:Activate()
                            oSubFKA := oModel:GetModel( "FKADETAIL" )

                            If oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
                                oSubFK3:= oModel:GetModel( "FK3DETAIL" )

                                For nImp := 1 to Len(aImpostos)

                                    If aImpostos[nImp,1] <> "IRF" .And. oSubFK3:SeekLine({{"FK3_IMPOS", aImpostos[nImp,1]}})			//Nome do imposto
                                        oSubFK3:SetValue( "FK3_IDRET",  aImpostos[nImp,4] )		//cIdFk4
                                    Endif

                                Next nImp
                            EndIf

                            oModel:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
                            oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5

                            If oModel:VldData()
                                oModel:CommitData()
                            Else
                                cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
                                cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
                                cLog += cValToChar(oModel:GetErrorMessage()[6])
                                Help( ,,"M050VALID",,cLog, 1, 0 )
                            Endif

                            oModel:DeActivate()
                            oModel:Destroy()
                            oModel:= Nil
                        EndIf

                        lRetParc := .F.
                EndCase

                //Gravo os titulos de impostos Pis Cofins Csll quando controlados pela baixa
                If __lLocBRA .and. lContrRet .and. lPccBaixa .and. lRetParc .And. lEmpGImp
                    FGrvImpPcc(SE2->E2_PIS,SE2->E2_COFINS,SE2->E2_CSLL,SE2->(Recno()),.F.,lRetParc,"  ","FINA080",SE2->E2_MOEDA,,0,,,,,lPccMR,lIrfMR,lInsMR,lIssMR,lCidMR,lSestMR)
                Endif

                //Caso controle retencao e a geracao dos tx's seja na baixa, inverto a gravacao dos campos do SE2
                If __lLocBRA .and. lContrRet .and. lPccBaixa
                    Reclock("SE2",.F.)
                    //Salva os valores originais dos tx's para efetuar a inversao
                    SE2->E2_PIS     := SE2->E2_VRETPIS		//Valor do Pis do Titulo
                    SE2->E2_COFINS  := SE2->E2_VRETCOF		//Valor do Cofins do Titulo
                    SE2->E2_CSLL    := SE2->E2_VRETCSL		//Valor do Csll do Titulo
                    //Se o "Vlr pendente retencao" + "Vlr Titulo" ultrapassar o "Vlr. Min. Imp.", não limpo o campo E2_VRET???.
                    If aDadosRet[ 1 ] + nBaseRet	< nVlMinImp .Or. !lEmpGImp
                        SE2->E2_VRETPIS := 0      		//Valor Retido do Pis no Titulo
                        SE2->E2_VRETCOF := 0      		//Valor Retido do Cofins no Titulo
                        SE2->E2_VRETCSL := 0				//Valor Retido do Csll no Titulo
                        If SE2->(E2_PIS+E2_COFINS+E2_CSLL) > 0
                            SE2->E2_PRETCSL := SE2->E2_PRETCOF := SE2->E2_PRETPIS := "1"
                        EndIf
                    Endif
                    SE2->(MsUnlock())
                Endif
            Endif    
		Endif
	Endif
Endif

//Ponto de entrada do FA050MD5, serve p/ tratar dados após estarem gravados
IF (ExistBlock("FA050MD5"))
	ExecBlock("FA050MD5",.f.,.f.)
Endif

dbSelectArea("SE2")
dbGoto( nRecSE2 )

If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
	//Atualiza saldo do fornecedor. PA/NDF
	RecLock("SA2")
	SA2->A2_SALDUP -=Round(NoRound(xMoeda(SE2->E2_SALDO, SE2->E2_MOEDA, 1, SE2->E2_EMISSAO, 3, SE2->E2_TXMOEDA), 3), 2)
	SA2->A2_SALDUPM-=Round(NoRound(xMoeda(SE2->E2_SALDO, SE2->E2_MOEDA, nMoeda, SE2->E2_EMISSAO, 3, SE2->E2_TXMOEDA), 3), 2)
EndIf

Return .T.


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RETBCOMOED

Retorna a moeda do banco passado como parâmetro.
Arquivo anterior: FINXATU.PRX

@Author	Pedro Pereira Lima
@since	30/12/2010
/*/
//-----------------------------------------------------------------------------------------------------
Function RetBcoMoed(cBanco,cAgencia,cConta)

Local aArea     := GetArea()
Local aAreaSA6  := SA6->(GetArea())
Local aAreaSE8  := SE8->(GetArea())
Local nMoedaBco := 1

dbSelectArea("SA6")
dbSetOrder(1)
If dbSeek(xFilial("SA6") + cBanco + cAgencia + cConta)
	nMoedaBco := Max(SA6->A6_MOEDA,1)
Else
	nMoedaBco := 1
EndIf

RestArea(aAreaSE8)
RestArea(aAreaSA6)
RestArea(aArea)

Return nMoedaBco



/*
=============================================================================
-----------------------------------------------------------------------------

              Funcoes retiradas do arquivo FINXFUN.PRX

-----------------------------------------------------------------------------
=============================================================================
*/

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA050DIGPA

Abre tela com dados para geracao do PA de cheque (de acordo com perguntas).
Arquivo anterior: FINXFUN.PRX

@Author	Wagner Mobile Costa
@since	13/06/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa050DigPa(cTitulo,nMoeda,lProvis)

Local oBcoAdt	:= Nil
Local oChqAdt	:= Nil
Local oBenef    := Nil
Local bAction	:= Nil
Local lFA050PA 	:= ExistBlock("FA050PA")
Local nMoedAux	:= 0 
Local lJFilBco  := SuperGetMv( "MV_JFILBCO", .F., .F. ) .And. FindFunction("JURF3SA6") .And. FindFunction("JurVldSA6") //Indica se filtra as contas correntes vinculadas ao escritório logado - SIGAPFS.
Local cBancoF3  := Iif(lJFilBco, "SA6JUR", "SA6")
Local cMV_CARTE := GEtMV("MV_CARTEIR")

DEFAULT cTitulo := ""
DEFAULT nMoeda  := 1
Default lProvis := .F.  //Ao substituir um PR por um PA nao permitir que a moeda do primeiro titulo seja substituida qdo fornecido o banco.

nMoedAux := nMoeda

If cPictHist = Nil
	//---------------------------------------------------------------
	// Recupera a Picture no SX3 para campo historico
	//---------------------------------------------------------------
	cPictHist := PesqPict("SEF","EF_HIST", TamSX3("EF_HIST"))
Endif

While .T.
	//---------------------------------------------------------------
	// Mostra Get do Banco de Entrada
	//---------------------------------------------------------------
	nOpca := 0
	DEFINE MSDIALOG oDlg FROM 10, 5 TO 27, 60 TITLE STR0001 + cTitulo //"Local de Entrada"
	@	.3,1 TO 07.3,26 OF oDlg
	// BANCO
	@	1.0,2 	Say STR0002 //"Banco : "

	If __lLocBRA
		@	1.0,8  	MSGET oBcoAdt 			VAR cBancoAdt F3 cBancoF3 	Valid CarregaSa6(@cBancoAdt,,,,,,, @nMoedAux ) .And. FaPrNumChq(cBancoAdt,cAgenciaAdt,cNumCon,@oChqAdt,@cChequeAdt) HASBUTTON
	Else
		@	1.0,8  	MSGET oBcoAdt 			VAR cBancoAdt F3 cBancoF3 	Valid CarregaSa6(@cBancoAdt) .And. FaPrNumChq(cBancoAdt,cAgenciaAdt,cNumCon,@oChqAdt,@cChequeAdt) HASBUTTON
	EndIf

	// AGENCIA
	@	2.0,2 	Say STR0003 //"Agência : "
	@	2.0,8 	MSGET cAgenciaAdt 								Valid CarregaSa6(@cBancoAdt,@cAgenciaAdt) .And. FaPrNumChq(cBancoAdt,cAgenciaAdt,cNumCon,@oChqAdt,@cChequeAdt)
	// CONTA
	@	3.0,2 	Say STR0004 //"Conta : "
	@	3.0,8 	MSGET cNumCon 									Valid If(CarregaSa6(@cBancoAdt,@cAgenciaAdt,@cNumCon,,,.T.),FaPrNumChq(cBancoAdt,cAgenciaAdt,cNumCon,@oChqAdt,@cChequeAdt),oBcoAdt:SetFocus())
	// NUMERO CHEQUE
	@	4.0,2 	Say STR0005 //"Núm Cheque:"
	@	4.0,8 	MSGET oChqAdt 			VAR cChequeAdt 			When (	mv_par05 == 1 .And. !RetGlbLGPD("EF_NUM") .And. substr(cBancoAdt,1,2)!="CX" .And. !(cBancoAdt $ cMV_CARTE) .And. cPaisLoc <> "EQU") ;
                                                                Valid fa050Cheque(cBancoAdt,cAgenciaAdt,cNumCon,cChequeAdt,Iif(cPaisLoc $ "ARG",.F.,.T.)) OBFUSCATED RetGlbLGPD("EF_NUM")
	// HISTORICO
	@	5.0,2 	Say STR0006 //"Historico :    "
	@	5.0,8 	MSGET cHistor		Picture cPictHist	SIZE 135, 10 OF oDlg
	// BENEFICIARIO
	@	6.0,2 	Say STR0007 //"Beneficiario : "
	@	6.0,8 	MSGET oBenef VAR cBenef		Picture "@S40"		SIZE 135, 10 OF oDlg When !RetGlbLGPD("EF_BENEF")

   bAction := {||	nOpca:=1,;
   					Iif(!Empty(cBancoAdt).And.;
   					CarregaSa6(@cBancoAdt,@cAgenciaAdt,@cNumCon,,,.T.).And.;
                    fa050Cheque(cBancoAdt,cAgenciaAdt,cNumCon,cChequeAdt,Iif(cPaisLoc $ "ARG",.F.,.T.)) .and.;
   					Fa050VlPFS(cBancoAdt,cAgenciaAdt,cNumCon).And.;
   					Iif(lFA050PA,;
   						ExecBlock("FA050PA",.F.,.F.,{cBancoAdt,cAgenciaAdt,cNumCon,cChequeAdt,cHistor,cBenef}),;
   						.T.),;
   					oDlg:End(),;
   					nOpca:=0)}

	DEFINE SBUTTON FROM 105,180.1 TYPE 1 ACTION ( Eval(bAction) ) ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg CENTERED

	IF nOpca != 0
		If !__lLocBRA
            nMoeda   := Max(IIf(Type("SA6->A6_MOEDAP")=="U",SA6->A6_MOEDA,If(SA6->A6_MOEDAP>0,SA6->A6_MOEDAP,SA6->A6_MOEDA)),1)
            If cPaisLoc == "RUS"
                M->E2_MOEDES:=Posicione("CTO",1,xFilial("CTO")+StrZero(M->E2_MOEDA,TamSX3("CTO_MOEDA")[1]),"CTO_SIMB")
                M->E2_PORTADO:=   SA6->A6_COD 
                M->E2_TXMOEDA   := RecMoeda(M->E2_EMISSAO,M->E2_MOEDA)
            EndIf        
		Endif

		//Coloca no campo Moeda a moeda referente ao banco escolhido
		SA6->(DBSETORDER(1))
		IF SA6->(DBSEEK(xFILIAL("SA6") + cBancoAdt + cAgenciaAdt + cNumCon))
			nMoedAux := IIf(SA6->A6_MOEDA <> 0, SA6->A6_MOEDA, 1)
		ENDIF

		If __lLocBRA .And. !lProvis
			M->E2_MOEDA := nMoedAux
		EndIf

		Exit
	EndIf
EndDo

Return .T.


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA050EXIBE

Exibe Totais de titulos selecionados  (FINA050).
Arquivo anterior: FINXFUN.PRX

@Author	Pilar S. Albaladejo
@since	07/11/1995
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa050Exibe(nValor,nQtdTit,oValor,oQtdTit,nMoeda)

If E2_OK == cMarca
	nValor += Round(NoRound(xMoeda(E2_SALDO+E2_ACRESC-E2_DECRESC,E2_MOEDA,nMoeda,,3),3),2)
	nQtdTit++
Else
	nValor -= Round(NoRound(xMoeda(E2_SALDO+E2_ACRESC-E2_DECRESC,E2_MOEDA,nMoeda,,3),3),2)
	nQtdTit--
	nValor := Iif(nValor<0,0,nValor)
	nQtdTit:= Iif(nQtdTit<0,0,nQtdTit)
EndIf

oValor:Refresh()
oQtdTit:Refresh()

Return


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA050NATUR

Função de validação da natureza e calculo dos impostos na emissão de CP (FINA050).
Arquivo anterior: FINXFUN.PRX


@Author	Wagner Xavier
@since	28/04/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FA050Natur( aBases,  aImpostos, lButMenu)

LOCAL lRetorna		:= .T.
LOCAL lCalcImp		:= .T.
LOCAL nValor		:= 0
LOCAL nValInss  	:= 0
LOCAL nValSEST  	:= 0
LOCAL nValFrete 	:= 0
LOCAL cSEST     	:= GetMv("MV_SEST",,"")
LOCAL nPercIss  	:= 0
LOCAL nValIRRF  	:= 0
LOCAL dDatMes   	:= Ctod("")
LOCAL lAplicaTP 	:= .T.
LOCAL lCalcPis		:= .T.
LOCAL lCalcCof		:= .T.
LOCAL lCalcCsll 	:= .T.
LOCAL lRndVlIss		:= GetNewPar("MV_RNDISS",.F.)
LOCAL nBaseIrrf		:= 0
LOCAL nBaseCof		:= 0
LOCAL nBaseIss		:= 0
LOCAL nBaseCsll		:= 0
LOCAL nBasePis		:= 0
LOCAL nBaseInss		:= 0
LOCAL nBaseDep		:= GetMV("MV_TMSVDEP",,0)
LOCAL nValDep		:= 0
LOCAL lFA050Imp		:= Existblock("FA050IMP")
LOCAL lImpostos		:= .T.
LOCAL nInss			:= Noround(M->E2_INSS,2)
LOCAL nRegSED		:= SED->(Recno())
//Controla o Pis Cofins e Csll na baixa
LOCAL lPCCBaixa 	:= IIF(__lLocBRA,SuperGetMv("MV_BX10925",.T.,"2") == "1",.F.)
LOCAL lIRPFBaixa	:= IIF(__lLocBRA, SA2->A2_CALCIRF == "2", .F.)
//Base IRPF na baixa
LOCAL lBaseIRPF		:= F050BIRPF()
LOCAL nLimInss		:= GetMv("MV_LIMINSS",.F.,0)
LOCAL lSimples		:= IIF(__lLocBRA, SA2->A2_CALCIRF == "3", .F.)
Local lCalcIssBx	:= IsIssBx("P")
LOCAL lCriei		:= .F.
LOCAL lAplVlMin		:= .T.
LOCAL lCpoVlMin		:= .T.
LOCAL lCIDE 		:= __lLocBRA .And. SuperGetMv("MV_FGCIDE",.T.,"2") == "2" // Define o fato gerador do imposto CIDE. 1 = Baixa ou 2 = Emissão
LOCAL nBaseCide     := 0
LOCAL lPaBruto		:= GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor
LOCAL lFreteEmb		:= .T.
LOCAL cTipUso		:= IIf(nModulo==43,"1","2")
LOCAL lCpoInsR		:= .T.
LOCAL nRetInss		:= 0
LOCAL aAreaDTY		:= {}
LOCAL aAreaDAK		:= {}
LOCAL aAreaDAS		:= {}
LOCAL nIrfInss		:= 0
LOCAL nCalcInss		:= 0
LOCAL nINSSTot		:= 0
Local lTemMR		:= If(FindFunction("FTemMotor"), FTemMotor(), .F.)
Local lPccMR    	:= .F.
Local lIrfMR    	:= .F.
Local lInsMR    	:= .F.
Local lIssMR    	:= .F.
Local lCidMR    	:= .F.
Local lSestMR   	:= .F.
Local lOutImpMR 	:= .F.
Local aImpConf  	:= {}
Local nImpConf  	:= 0
Local nY 			:= 0
Local cRtInsPA		:= ""
//Variavel indica se irá provisionar os impostos de INSS e ISS na inclusão da PA, deduzindo-os do valor de adiantamento.
Local lPrImPA		:= !lPaBruto .And. SuperGetMv("MV_PAPRIME",.T.,"2") == "1"
//Base de imposto Variavel
LOCAL lBaseImp		:= F050BSIMP(2)	//Verifica a existência dos campos e o calculo de impostos
LOCAL lCpoValor		:= "E1_VALOR" $ Upper(AllTrim(ReadVar()))
Local lFinVldIns	:= Existblock("FinVldIns")
Local cTpPrAbt		:= MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA"+"/"+"CID"
// Bitributacao ISS
Local aISSCPOM		:= {}
Local lBtrISS		:= SE2->(ColumnPos("E2_BTRISS")) > 0 .and. SE2->(ColumnPos("E2_VRETBIS")) > 0 .and. SE2->(ColumnPos("E2_CODSERV")) > 0

Local lDedIns	    := (SuperGetMv("MV_INSIRF",.F.,"2") == "1")  //Controle para a dedução de INSS da base do IR
Local nLoop         := 0
Local cAglImPJ	    := SuperGetMv("MV_AGLIMPJ",.T.,"1")
Local cTipCTC       := Padr( SuperGetMv("MV_TPTCTC",.T.,""), Len( SE2->E2_TIPO ) ) // Tipo Contrato de Carreteiro
Local aRet          := {}
Local aFilial       := {}
Local aCliFor       := {}
Local cArqTMP       := ""
Local lEmprInd      := __lLocBRA .and. SA2->A2_CALCIRF == "4" //-- Empresa Individual
Local cQuery        := ""
Local cAliasQry     := ""
Local lFina050  	:= FUNNAME()=="FINA050"
Local cVenctoPF     := SuperGetMv("MV_ACMIRPF",.T.,"2")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Local lParcela      := .F.
Local nINSSRet      := 0 //--Valor do INSS retido no periodo
Local lF050CIRF 	:= ExistBlock("F050CIRF")
Local lAplMinIR     := .F.      // Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local lPisCal       := .F.
Local lCOFCal       := .F.
Local lCSLCal       := .F.
Local nVencto 	    := SuperGetMv("MV_VCPCCP",.T.,1)
Local dRef          := dDataBase
Local nVlMPub       := SuperGetMv("MV_VLMPUB" ,.T.,10)
Local lEmpPub       := IsEmpPub()
Local lIrfRetAnt	:= .F.

//--- Tratamento Gestao Corporativa
Local cLayout       := FWSM0Layout()
Local lGestao	    := "E" $ cLayout .Or. "U" $ cLayout
Local cFilFwSE2     := IIF( lGestao , FwFilial("SE2") , xFilial("SE2") )
Local cFilFwSA2     := IIF( lGestao , FwFilial("SA2") , xFilial("SA2") )

// Complemento de Imposto
Local nDedBsPis	    As Numeric
Local nDedBsCSL	 	As Numeric
Local nDedBsCOF  	As Numeric
Local lDeduzInss	As Logical
Local lSRefSE2      As Logical

//IRPF simplificado (MP 1.171/23)
Local dVigMP1171    As Date
Local nBasOrig      As Numeric
Local nVrIrDedS     As Numeric   
Local lIrTabSimp    As Logical

// Caso nao esteja sendo chamado atraves da enchoicebar na tela de inclusao
Default lButMenu	:= .F.

nDedBsPis	:= 0
nDedBsCSL	:= 0
nDedBsCOF  	:= 0
lDeduzInss	:= .T.  //Controle para a dedução de INSS do valor do titulo
lSRefSE2:= .T.

nBasOrig   := 0
nVrIrDedS  := 0
lIrTabSimp := Iif(FindFunction("FVerMP1171"),FVerMP1171(SA2->A2_COD, SA2->A2_LOJA), SuperGetMV("MV_FMP1171",.F.,.F.)) //Habilita calculo do IRPF pela tabela simplificada
dVigMP1171 := CTOD("01/05/2023") //Inicio da vigencia da MP 1.171/23

If __lF50FCTC == NIL
     __lF50FCTC := ExistBlock('F050FCTC')
Endif

If Type("lAltera")=="U"
	lAltera := .F.
EndIf

If __lLocBRA .and. FindFunction("f050LRatIR")
    f050LRatIR(.F.)
EndIf    
//Bitributação de ISS
If __lBtrISS == NIL
    __lBtrISS := SE2->(ColumnPos("E2_BTRISS")) > 0 .And. SE2->(ColumnPos("E2_VRETBIS")) > 0 .And.;
                    SE2->(ColumnPos("E2_CODSERV")) > 0 .And. FindFunction("ISSCPOM") .And. FindFunction("BtrISSMun")
Endif

// Pré-Validações
//-----------------------------------------------------------------
If Empty(M->E2_NATUREZ) .or. PrinDesdobr() .or. (lIRPFBaixa .and. Upper(AllTrim(ReadVar())) $ "M->E2_CODRET" .and. !M->E2_TIPO $ MVPAGANT)
	lCalcImp := .F.

ElseIf M->E2_VALOR == 0
	lCalcImp := .F.

//Validações para a alteração
ElseIf lAltera
	//---------------------------------------------------------------------
	// Caso tenha contabilizado, nao posso alterar valores no titulo. 
	//---------------------------------------------------------------------
	If !Empty(SE2->E2_BAIXA)
		Help(" ",1,"FA050BAIXA")
		lRetorna := .F.
	Endif

	If  lRetorna .and. lCalcImp .and. SE2->E2_LA == "S" .and.  Upper(AllTrim(ReadVar())) $ "M->E2_NATUREZ|M->E2_VALOR"  .and. !EMPTY(SE2->E2_NATUREZ)
	   	//Se não houve alteração da natureza e valor do título, deixa prosseguir sem percorrer a função
		If SE2->E2_VALOR == M->E2_VALOR .AND. SE2->E2_NATUREZ = M->E2_NATUREZ
			lCalcImp := .F.
		Else
		   Help(" ",1,"TITCONTAB")		//"Não é possivel a alteração da natureza pois o titulo ja se encontra contabilizado"
			lRetorna := .F.
		Endif
	Endif
	If lRetorna .and. lCalcImp .and. cPaisLoc $ "DOM|COS"
		If 	SUBSTR(SE2->E2_ORIGEM,1,4) <> "FINA"
	   		Help(STR0008,1,"FA050ORIG") //"Não é possivel a alteração. Titulo não foi gerado pelo Financeiro"
			lRetorna := .F.
		Endif
	EndIf
	//---------------------------------------------------------------------
	// Caso tenha impostos, nao permite a alteraçao de valor
	//---------------------------------------------------------------------
	If lRetorna .and. lCalcImp .and. (SE2->E2_IRRF + SE2->E2_ISS + SE2->E2_INSS+SE2->E2_SEST+SE2->E2_PIS+SE2->E2_COFINS+SE2->E2_CSLL) > 0 .and. F050BxImp()
		Help(" ",1,"NAOVALOR")
		lRetorna := .F.
	Endif

	//---------------------------------------------------------------------
	// Não permite alterar o valor de um pagamento antecipado, pois já
	// gerou um registro no SE5 com a natureza original.
	//---------------------------------------------------------------------
	If SE2->E2_TIPO $ MVPAGANT
		Help( " ",1,"FA040ADTO")
		lRetorna := .F.
	Endif
Endif

If lRetorna
    //------------------------------------------------
    //Valida natureza e seu bloqueio
    //------------------------------------------------
	dbSelectArea("SED")
	dbSetOrder(1)
	//Verifico a existencia do codigo de natureza e se está bloqueado.
	//RegistroOk verifica o bloqueio (LIB)
	//ExistCpo() não funcionava neste caso pois nao posiciona no registro do codigo digitado,
	//voltando para ultimo posicionamento do SED antes da execucao da rotina.
    If !Empty(M->E2_NATUREZ)
        If !(MsSeek(xFilial("SED")+M->E2_NATUREZ)) 
            Help(" ",1,"E2_NATUREZ")
            lRetorna := .F.
        ElseIf !(ExistCpo("SED",M->E2_NATUREZ))
            lRetorna := .F.        
        //Verifico se a natureza pode ser utilizada
        ElseIf	SED->ED_MSBLQL	== '1'
            Help(STR0009,1," ") //"Natureza Bloqueada"
        Endif
    Endif

    //------------------------------------------------
    //Calculo dos impostos
    //------------------------------------------------
    If __lLocBRA .and. lRetorna .and. lCalcImp 

		//Recompõe o valor na alteração do título, somando os valores de impostos
		If FwIsInCallStack("FA050Alter")
            if AllTrim(ReadVar()) <> "M->E2_NATUREZ" //Para E2_NATUREZ, a recomposição dos valores ira ocorrer em F050VldImp()
			    RecompoeVl(lIRPFBaixa, lCalcIssBx, lPCCBaixa)
            endif
		EndIf
		
		If Type("cOldNaturez") <> "C"
			If lAltera
				cOldNaturez := SE2->E2_NATUREZ
			Else
				cOldNaturez := M->E2_NATUREZ
			Endif
		Endif

		//Limpa os complementos de impostos, caso a natureza seja alterada
		If cOldNaturez <> M->E2_NATUREZ .And. !FwIsInCallStack("FINA986") .And. FindFunction("F986ExcFKG")
			F986ExcFKG("SE2")
		EndIf
		
		//Motor de retençoes
		If lTemMR
			//Cálculo dos impostos
			F050VldImp(.F.)

			//Retorna os impostos configurados
			aImpConf := FinImpConf("1", cFilAnt, M->E2_FORNECE, M->E2_LOJA, M->E2_NATUREZ)
			nImpConf := Len(aImpConf)

			For nY := 1 To nImpConf
				Do Case
					Case aImpConf[nY,1] $ "PIS|COF|CSL"
						lPccMR := .T.
					Case aImpConf[nY,1] == "IRF"
						lIrfMR := .T.
					Case aImpConf[nY,1] == "INSS"
						lInsMR := .T.
					Case aImpConf[nY,1] == "ISS"
						lIssMR := .T.
					Case aImpConf[nY,1] == "CIDE"
						lCidMR := .T.
					Case aImpConf[nY,1] == "SEST"
						lSestMR := .T.
					OtherWise
						lOutImpMR := .T.
				EndCase
			Next nY

			nPis := 0
			nCofins := 0
			nCsll := 0
			nInss := 0
			nIrrf := 0
			nIss := 0
			nSest := 0
		EndIf

		//Verificar ou nao o limite de 5000 para Pis cofins Csll
		// 1 = Verifica o valor minimo de retencao
		// 2 = Nao verifica o valor minimo de retencao
		If lCpoVlMin .and. M->E2_APLVLMN == "2"
			lAplVlMin := .F.
		Endif

		If aBases == Nil
			If !lIrfMR
				nBaseIrrf   := M->E2_VALOR
			EndIf
			If !lPccMR
				nBaseCof 	:= M->E2_VALOR
				nBaseCsll   := M->E2_VALOR
				nBasePis    := M->E2_VALOR
			EndIf
			If !lIssMR
				nBaseIss    := M->E2_VALOR
			EndIf
			If !lInsMR
				nBaseInss	:= M->E2_VALOR
			EndIf
		Else
			If !lIrfMR
				nBaseIrrf   := aBases[1]			// Base IRRF
			EndIf
			If !lPccMR
				nBaseCof 	:= aBases[2]            // Base Cofins
				nBaseCsll   := aBases[4]			// Base Csll
				nBasePis    := aBases[5]            // Base Pis
			EndIf
			If !lIssMR
				nBaseIss    := aBases[3]            // Base Iss
			EndIf
			If !lInsMR
				nBaseInss   := aBases[6]            // Base Inss
			EndIf
		Endif

		If aImpostos != Nil
			If !lIrfMR
				M->E2_IRRF  := aImpostos[1]			// IRRF
			EndIf
			If !lPccMR
				m->e2_cofins:= aImpostos[2]         // Cofins
				m->e2_csll  := aImpostos[4]			// Csll
				M->E2_PIS   := aImpostos[5]         // Pis
			EndIf
			If !lInsMR
				M->E2_INSS  := aImpostos[6]         // Inss
				nInss := M->E2_INSS
			EndIf
			If !lIssMR
				m->e2_iss   := aImpostos[3]         // Iss
			EndIf

			lImpostos := .F.
		Endif

		//Protecao para chamada desta funcao pelo SIGATMS
		//------------------------------------------------
		aDadosRef := If (Type("aDadosRef") != "A",(lCriei := .T.,Array(7)),aDadosRef)
		aDadosRet := If (Type("aDadosRet") != "A",(lCriei := .T.,Array(7)),aDadosRet)
		aDadosImp := If (Type("aDadosImp") != "A",(lCriei := .T.,Array(3)),aDadosImp)

		If lCriei
			AFill( aDadosRef, 0 )
			AFill( aDadosImp, 0 )
			AFill( aDadosRet, 0 )
		Endif
		//------------------------------------------------

		lCalcIR   := .T.
		lCalcIS	  := .T.
		lCalcIN	  := .T.
		lCalcSE   := .T.
		lCalcPis  := .T.
		lCalcCof  := .T.
		lCalcCsll := .T.
		//Titulos Provisorios ou Antecipados nao geram IR 
		If (M->E2_TIPO $ cTpPrAbt) .Or. (M->E2_TIPO $ MVPAGANT .and. GetMv("MV_IMPADT") != "S")
			If !lIRPFBaixa .And. M->E2_IRRF > 0 .and. !lIrfMR 
				M->E2_VALOR += Round(xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
			EndIf

			If !lPCCBaixa .And. M->(E2_PIS+E2_COFINS+E2_CSLL) > 0 .and. !lPccMR 
				M->E2_VALOR += Round(xMoeda((M->E2_PIS + M->E2_COFINS + M->E2_CSLL),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
			EndIf

			If lImpostos
				If !lIrfMR
					M->E2_IRRF	:= 0
				EndIf
				If !lPccMR
					M->E2_PIS	:= 0
					m->e2_cofins := 0
					m->e2_csll	:= 0
				EndIf
			Endif

			nOldIrr		:= 0
			nOldPis		:= 0
			nOldCofins	:= 0
			nOldCsll	:= 0
			lCalcIR		:= lCalcPis	:= lCalcCof := lCalcCsll := .F.
		EndIf

		// Calcula ISS caso o Fornecedor recolha
		If SA2->A2_RECISS == "S" .OR. M->E2_TIPO $ cTpPrAbt .or. (M->E2_TIPO $ MVPAGANT .and. GetMv("MV_IMPADT") != "S")  .or.;
					(!lCalcIssBx .and. M->E2_TIPO $ MVPAGANT .and. SA2->A2_RECISS == "S")
            If lRndVlIss   //Se arredonda o valor do ISS
                M->E2_VALOR += Round(xMoeda(M->E2_ISS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
            Else
                M->E2_VALOR += NoRound(xMoeda(M->E2_ISS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
            Endif
			If lImpostos
				m->e2_iss	:= 0
				If lBtrISS
					m->e2_btriss := 0
				EndIf
			Endif
			If lPrImPA .and.  !lCalcIssBx .and. M->E2_TIPO $ MVPAGANT
				M->E2_VALOR += xMoeda(M->E2_PRISS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA)
				M->E2_PRISS := 0
			Endif
			nOldIss		:= 0
			lCalcIS		:= .F.
		EndIf

		//---------------------------------------------------------------------
		// Titulos Provisorios ou Antecipados nao geram INSS
		//---------------------------------------------------------------------
		//verifico se a natureza anterior descontava o INSS do principal
		If lAltera  .or. (M->E2_NATUREZ != cOldNaturez)
			nRegSED := SED->(Recno())
			cRtInsPA := SED->ED_RINSSPA
			SED->(dbSeek(xFilial("SED")+cOldNaturez))
		Endif

		IF !lInsMR .And. SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			lDeduzInss := .F.
		Endif

		//Recompõe o valor do titulo para a base
		If M->E2_TIPO $ MVPAGANT .and. lPaBruto .and. lPccBaixa
			nValor := M->E2_VALOR
		Else
            If FwIsInCallStack('Fa050Subst') .AND. nValDig == 0
                nValDig := M->E2_VALOR
            EndIF
			//Refaz a valor de inclusão
			nValor := nValDig
		Endif

		//Nao desconta o INSS do principal
		If !lInsMR
			If SED->ED_DEDINSS == "2"  
				nInss := 0
			ElseIf lPrImPA .and. M->E2_TIPO $ MVPAGANT .and. SED->ED_RINSSPA <> "1"
				M->E2_VALOR += M->E2_PRINSS
				M->E2_PRINSS := 0
			ElseIf SA2->A2_RECINSS <> "S" .or. M->E2_TIPO $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"INA" +"/"+"SES"+"/"+MV_CPNEG .or. ;
					(M->E2_TIPO $ MVPAGANT .and. GetMv("MV_IMPADT") != "S")
				M->E2_VALOR += NoRound(xMoeda(nInss,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
				nInss := 0
				If lImpostos
					M->E2_INSS	:= 0
				Endif
				nOldIns		:= 0
				lCalcIN		:= .F.
			Else
				If M->E2_TIPO $ MVPAGANT .And. ( (cRtInsPA == "1" .And. lPrImPA))
					M->E2_VALOR += NoRound(xMoeda(nInss,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
					nInss := 0
				EndIf
				If lImpostos
					M->E2_INSS	:= 0
				Endif
			EndIf
		EndIf

		//Reposiciono na natureza do titulo
		If lAltera .or. (M->E2_NATUREZ != cOldNaturez)
			SED->(dbGoTo(nRegSED))
		Endif

		// Monta valor base para recalculo - ISS
		If !lIssMR
			If lRndVlIss
				m->e2_iss := round(m->e2_iss,2)
			Else
				m->e2_iss := NoRound(m->e2_iss,2)
			Endif
		EndIf

		//Base nao enviada
		If aBases == Nil
			If !lIrfMR
				nBaseIrrf   := nValor
			EndIf
			If !lPccMR
				nBaseCof 	:= nValor
				nBaseCsll   := nValor
				nBasePis    := nValor
			EndIf
			If !lIssMR
				nBaseIss    := nValor
			EndIf
			If !lInsMR
				nBaseInss   := nValor
			EndIf

			//Base Impostos diferenciada
			If lBaseImp
				If !lIrfMR .And. M->E2_BASEIRF == 0 .or. lCpoValor
					M->E2_BASEIRF :=	M->E2_VALOR
				Elseif !lIrfMR .And. M->E2_BASEIRF < M->E2_VALOR //Essa situação irá ocorrer quando IR de carreteiro com base diferenciada
						M->E2_BASEIRF:= nValor
				ElseIf !lIrfMR .And. (M->E2_BASEIRF > nValor .and. M->E2_MOEDA == 1 )
					If SE2->E2_DESDOBR <> 'S'  // Se for alteração de um titulo originado de desdobramento manter os valores originais  
						nValor := M->E2_BASEIRF

						If !lPccMR .And. !lIrfMR .And. !lInsMR .And. !lIssMR .And. !lCidMR .And. !lSestMR .And. !lOutImpMR
							M->E2_VALOR := M->E2_BASEIRF
						EndIf
					Endif
				Endif
				nBaseIrrf   := M->E2_BASEIRF

				//Caso tenha base diferenciada atualizo o valor de cada base
				If M->E2_BASEPIS > 0
					nBasePis 	:= M->E2_BASEPIS
				Endif

				If M->E2_BASECOF > 0
					nBaseCof	:= M->E2_BASECOF
				Endif

				If M->E2_BASECSL > 0
					nBaseCsll	:= M->E2_BASECSL
				Endif

				If M->E2_BASEINS > 0
					nBaseInss	:= M->E2_BASEINS
				Endif

				If M->E2_BASEISS > 0
					nBaseIss	:= M->E2_BASEISS
				Endif
			Endif

			//Se controla base reduzida de IRRF
			//Se % base maior que 0
			//Se Fornecedor for pessoa fisica
			If !lIrfMR .And. __lLocBRA
				If lImpostos
					M->E2_IRRF := 0
				EndIF
				If lIRPFBaixa
					//Recomponho a base do IRRF
					If SA2->A2_TIPO <> "J"
						nBaseIrrf += NoRound(xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
					EndIF
					M->E2_IRRF := 0

					//Verificar Base de IRPF
					If lBaseIRPF
						If SED->ED_BASEIRF > 0
							M->E2_BASEIRF := M->E2_BASEIRF * (SED->ED_BASEIRF/100)
						Elseif SED->ED_BASEIRC > 0
							M->E2_BASEIRF := M->E2_BASEIRF * (SED->ED_BASEIRC/100)
						EndIf

					ElseIf M->E2_BASEIRF > 0  .and. SA2->A2_TIPO <> "J"
						M->E2_BASEIRF := 0
					Endif

				ElseIf M->E2_BASEIRF <= M->E2_VALOR
					If SED->ED_BASEIRF > 0
						M->E2_BASEIRF := nBaseIrrf := M->E2_BASEIRF * (SED->ED_BASEIRF/100)
					Elseif SED->ED_BASEIRC > 0
						M->E2_BASEIRF := nBaseIrrf := M->E2_BASEIRF * (SED->ED_BASEIRC/100)
					Endif
				Endif
			EndIf
		EndIf

		If !lIssMR .And. lCalcIS .and. lImpostos
			//---------------------------------------------------------------------
			// se natureza pede calculo do ISS (fornecedor nao recolhe!!)
			//---------------------------------------------------------------------
			If SED->ED_CALCISS == "S" .and. SA2->A2_RECISS != "S"
				nPercIss := GetMV("MV_ALIQISS")
				If ExistBlock("F050PISS")
					nPercIss := ExecBlock("F050PISS",.F.,.F.)
				Endif
				If SA2->A2_RECISS == "N"
					If lRndVlIss
						m->e2_iss := Round(((nBaseIss) * nPercIss / 100),2)
					Else
						m->e2_iss := NoRound(((nBaseIss) * nPercIss / 100),2)
					Endif
				EndIf
				If lBtrISS	// Bitributacao
					aISSCPOM := ISSCPOM("T",SA2->(A2_COD+A2_LOJA),M->E2_CODSERV)	
					If !Empty(aISSCPOM)
						If lRndVlIss
							m->e2_btriss := Round(((nBaseIss) * aISSCPOM[3] / 100),2)
						Else
							m->e2_btriss := NoRound(((nBaseIss) * aISSCPOM[3] / 100),2)
						EndIf
					EndIf
				EndIf
                If M->E2_TIPO $ MVPAGANT
                    If !lCalcIssBx
                        If lPrImPA
                            M->E2_PRISS := m->e2_iss
                            nValor -= M->E2_PRISS
                        EndIf
                        m->e2_iss := 0
                        nOldIss	  := 0
                        If lBtrISS
                            m->e2_btriss := 0
                            nOldBtrISS 	 := 0
                        EndIf
                    EndIf
				Elseif lPrImPA .and. !lCalcIssBx
					nValor += M->E2_PRISS
					M->E2_PRISS := 0
				ElseIf FwIsInCallStack("FINA050") .And. !lCalcIssBx .And. M->E2_ISS > 0 .and. M->E2_TIPO $ MVPAGANT
					nValor -= If(lBtrISS,M->E2_ISS+M->E2_BTRISS,M->E2_ISS)
				EndIf
			Else
				m->e2_iss := 0
				m->e2_vretiss := 0
				nOldIss	 := 0
				If lBtrISS
					m->e2_btriss := 0
					m->e2_vretbis:= 0
					nOldBtrISS 	 := 0
				EndIf
				If lPrImPA .and.  !lCalcIssBx  .and. M->E2_TIPO $ MVPAGANT
					nValor += M->E2_PRISS
					M->E2_PRISS := 0
				EndIf
			EndIf
			M->E2_BASEISS := nBaseIss
		EndIf

		//------------------------------
		// INSS
		If !lInsMR .And. lCalcIN  .and.  lImpostos
			//---------------------------------------------------------------------
			// Se natureza pede calculo do INSS (Fornecedor nao Recolhe)
			// e se não for titulo Provisorio ou Adiantamento ou Abatimento
			//---------------------------------------------------------------------
			If !(M->E2_TIPO $ MVPAGANT+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVTAXA+"/"+MV_CPNEG+"/"+MVABATIM+"/"+"SES"+"/"+"INA") .And.;
				SED->ED_CALCINS == "S" .And. SA2->A2_RECINSS == "S"
				nIrfInss := 0
				
				If !Empty(SED->ED_BASEINS)
					nValInss := Round((M->E2_VALOR * (SED->ED_BASEINS/100)),2)
				Else
					nValInss := nBaseInss
				EndIf

				nValInss := xMoeda(nValInss,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA)

				//Para pessoa fisica verifico o limite de deducao no mes
				If SA2->A2_TIPO == "F"
					nValInss	:= FCalcInsPF(nValInss, @nCalcInss,@nINSSTot)
				Else
					nValInss 	:= FCalcInsPJ(nValInss)
				Endif
				M->E2_INSS := Max(nINSSTot,nValInss)

				If lPrImPA
					M->E2_PRINSS := 0
				EndIf
				If __lLocBRA
					// se os campos da cumulatividade de INSS tiverem sido criados
					M->E2_VRETINS := Iif(SA2->A2_TIPO == "F", nCalcInss, nValInss)
					M->E2_PRETINS := Iif(nCalcInss >= 0," ","1")
				EndIf

				nInss := M->E2_INSS

				// Somar todos os valores de Inss do fornecedor (Carreteiro)
				If __lLocBRA .And. SED->ED_INSSCAR == "S"

					// Verifica se Pessoa Fisica ou Juridica, para fins de calculo do INSS
					If SA2->A2_TIPO == "F"

						// Armazena o INSS retido, informado na Viagem Atual.
						nRetInss := DTR->DTR_INSRET
						aAreaDTR := DTR->(GetArea())
						aAreaDTY := DTY->(GetArea())
						dDatMes  := Ctod("01/"+Str(Month(dDataBase),2,0)+"/"+Str(Year(dDataBase),4,0))
						cNumCTC:= IIf(Type("cNumCTC") == "U",CriaVar('DTY_NUMCTC',.F.),cNumCTC) // Variavel declarada no TMSA250

						// Armazena Valor do INSS e INSS Retido no mes.
						DTY->(dbSetOrder(3))
						DTY->(MsSeek(xFilial("DTY")+SA2->A2_COD+SA2->A2_LOJA+DTOS(dDatMes),.T.))
						While !DTY->(Eof()) .And. DTY->DTY_FILIAL+DTY->DTY_CODFOR+DTY->DTY_LOJFOR+StrZero(Month(DTY->DTY_DATCTC),2)+StrZero(Year(DTY->DTY_DATCTC),2) == ;
								xFilial('DTY')+SA2->A2_COD+SA2->A2_LOJA+StrZero(Month(dDataBase),2)+StrZero(Year(dDataBase),2)
							If DTY->DTY_NUMCTC == cNumCTC //-- Desconsidera o contrato Atual
								DTY->(dbSkip())
								Loop
							EndIf
							nValInss += DTY->DTY_INSS

							If lFreteEmb
								If !lCpoInsR
									If cTipUso == "1" //--Viagem
										aAreaDTQ := DTQ->(GetArea())
										aAreaDTR := DTR->(GetArea())
										DTQ->(dbSetOrder(6))
										DTQ->(dbSeek(xFilial("DTQ")+DTY->DTY_IDENT))
										DTR->(dbSetOrder(3))
										If DTR->(dbSeek(xFilial("DTR")+DTY->DTY_FILORI+DTQ->DTQ_VIAGEM+DTY->DTY_CODVEI))
											If DTR->DTR_INSRET > 0
												nRetInss += DTR->DTR_INSRET
											EndIf
										EndIf
										RestArea(aAreaDTQ)
										RestArea(aAreaDTR)
									ElseIf cTipUso == "2" //--Carga
										aAreaDAK := DAK->(GetArea())
										aAreaDAS := DAS->(GetArea())
										DAK->(dbSetOrder(4))
										DAK->(dbSeek(xFilial("DAK")+DTY->DTY_IDENT))
										DAS->(dbSetOrder(1))
										If DAS->(dbSeek(xFilial("DAS")+DAK->DAK_COD+DAK->DAK_SEQCAR))
											If DAS->DAS_INSRET > 0
												nRetInss += DAS->DAS_INSRET
											EndIf
										EndIf
										RestArea(aAreaDAK)
										RestArea(aAreaDAS)
									EndIf
								Else //--Viagem
									aAreaDTR := DTR->(GetArea())
									DTR->(dbSetOrder(3))
									If DTR->(dbSeek(xFilial("DTR")+DTY->DTY_FILORI+DTY->DTY_VIAGEM+DTY->DTY_CODVEI))
										If DTR->DTR_INSRET > 0
											nRetInss += DTR->DTR_INSRET
										EndIf
									EndIf
									RestArea(aAreaDTR)
								EndIf
							Else
								nRetInss += Posicione("DTR",3,xFilial("DTR")+DTY->DTY_FILORI+DTY->DTY_VIAGEM+DTY->DTY_CODVEI,"DTR_INSRET")
							EndIf
							DTY->(dbSkip())
						EndDo

						RestArea ( aAreaDTR )
						RestArea ( aAreaDTY )

						// Verifica se o valor do INSS ultrapassou o valor limite.
						If (nLimInss > 0) .And. (M->E2_INSS + nRetInss > nLimInss)
							M->E2_INSS := Max(0,(nLimInss - nRetInss))
							nIrfInss   := nLimInss
						Else
							nIrfInss := nValInss + nRetInss
						EndIf
						M->E2_INSS := nValInss
					EndIf
				EndIf

				// Ponto de entrada para calculo de INSS com base reduzida
				IF ExistBlock("F050INBR")
					M->E2_INSS := ExecBlock("F050INBR",.f.,.f.,nBaseInss)
				Endif
			Else
				M->E2_INSS := 0
				m->e2_vretins := 0
				nOldInss  := 0
				If M->E2_TIPO $ MVPAGANT.And. SED->ED_CALCINS == "S" .And. SA2->A2_RECINSS == "S" .and. lPrImPA
					
					If !Empty(SED->ED_BASEINS)
						nValInss := Round((nBaseInss * (SED->ED_BASEINS/100)),2)
					Else
						nValInss := nBaseInss
					EndIf
					
					nValInss := xMoeda(nBaseInss,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA)

					//Para pessoa fisica verifico o limite de deducao no mes
					If SA2->A2_TIPO == "F"
						nValInss	:= FCalcInsPF(nValInss, @nCalcInss,@nINSSTot)
					Else
						nValInss 	:= FCalcInsPJ(nValInss)
					Endif

					If (SED->ED_RINSSPA == "1")		//retem o valor no INSS em titulo tipo INA
						M->E2_INSS := Max(nINSSTot,nValInss)
					Else
						M->E2_PRINSS := Max(nINSSTot,nValInss)
						nVALOR -= M->E2_PRINSS
					EndIf
				Else
					If lPrImPA .and.  M->E2_TIPO $ MVPAGANT
						If SED->ED_RINSSPA == "1" //retem o valor no INSS em titulo tipo INA
							nVALOR += M->E2_INSS
							M->E2_INSS := 0
						Else
							nVALOR += M->E2_PRINSS
							M->E2_PRINSS := 0
						EndIf
					ElseIf M->E2_TIPO $ MVPAGANT
						nVALOR += M->E2_INSS
						M->E2_INSS := 0
					EndIf
				EndIf
			EndIf
			nVCalINS := M->E2_INSS
			nBCalINS := M->E2_VALOR
			M->E2_BASEINS := nBaseInss

			// Tratamento de Dispensa de Ret. de Inss. caso nao seja pessoa fisica
			If Left(FunName(),7) <> 'TMSA250'
				If ( M->E2_INSS < GetMv("MV_VLRETIN") ) .And. SA2->A2_TIPO <> "F" .AND. (IIF(lFinVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. ))
					M->E2_INSS:= 0
					nOldInss  := 0
				EndIf
			EndIf

			nVlAltInss := M->E2_INSS
			lFirstAlt := .F.
		EndIf

		//------------------------------
		//IRRF
		If !lIrfMR .And. lCalcIR

			If SED->ED_CALCIRF == "S" .and. lImpostos .and. SA2->A2_CALCIRF <> " "

				// Integracao com o Modulo de Transporte (TMS) 
				// Calculo do IR do Carreteiro
                If SED->ED_IRRFCAR == "S" .And. IIf(nModulo != 43,!lIRPFBaixa,.T.)
                    //Verifico a combinacao de filiais (SM0) e lojas de fornecedores a serem considerados
                    //na montagem da base do IRRF
                    If cAglImPJ != "1"
                        aRet := FLOJASIRRF("2")
                        aFilial := aClone(aRet[1])
                        aCliFor := aClone(aRet[2])
                        cArqTMP := aRet[3]
                    Endif
                    // Verifica se Pessoa Fisica ou Juridica, para fins de calculo do irrf                                    	
                    If __lF050ATP
                        lAplicaTP := ExecBlock("F050ATP",.F.,.F.)
                    Endif
                    //-- Se o parametro MV_TPTCTC nao estiver preenchido
                    If Empty(cTipCTC)
                        cTipCTC := Padr( "C" + cFilAnt, Len( SE2->E2_TIPO ) ) // Tipo Contrato de Carreteiro
                    EndIf
                    // Verifica se o fornecedor trata o valor minimo de retencao. 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
                    If __lLocBRA .and. SA2->A2_MINIRF == "2"
                        lAplMinIR := .T.
                    Endif

                    If (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1")) .AND. !lEmprInd .AND. lAplicaTP

                        //--Regra para calculo do imposto de renda - Pessoa Fisica:

                        //--Devem ser somados -TODOS- os titulos que com data de vencimento
                        //--no mes corrente.
                        //--Apos isto, deve-se aplicar a reducao de base de calculo do IR (Se houver) e
                        //--deduzir o valor acumulado de INSS retido.
                        //--Em seguida, verificar em qual faixa da tabela progressiva do IRRF se enquadra o
                        //--valor obtido.
                        //--Aplicar a aliquota do imposto, deduzir o valor referente a faixa
                        //--da tabela progressiva e abater os impostos retidos (IRRF) anteriores.

                        //--Exemplo:

                        //--Tabela Progressiva do IRRF (Exemplo):
                        //--  Ate(R$)   Aliq.    Val. Deduzir
                        //-- 1.434,59	  0,0	         0,00
                        //-- 2.150,00	  7,5	       107,59
                        //-- 2.866,70	 15,0	       268,84
                        //-- 3.582,00	 22,5	       483,84
                        //-- 9.999,99	 27,5	       662,94

                        //-- Titulo c/       Valor          Base     Valor
                        //-- Vencto. em:     Titulo      Calculo      IRRF
                        //--    01/08/09   1.000,00     1.000,00      0,00 (Alcancou a 1.a Faixa)
                        //--    15/08/09   2.000,00     3.000,00    191,16 (Alcancou a 4.a Faixa) Formula: ((3000 * 22.5)/100)-483.84)
                        //--    31/08/09   2.000,00     5.000,00    520,90 (Alcancou a 5.a Faixa) Formula: ((5000 * 27,5)/100)-(662,94+191,16)
                        //--    31/08/09   1.000,00     6.000,00    275,00 (Alcancou a 5.a Faixa) Formula: ((6000 * 27,5)/100)-(662,94+191,16+520,90)

                        //-- Se houver reducao de base de calculo (40% de reducao):
                        //-- Titulo c/       Valor         Valor        Base     Valor
                        //-- Vencto. em:     Titulo    Acumulado     Calculo      IRRF
                        //--    01/08/09   1.000,00     1.000,00      400,00       0,00 (Alcancou a 1.a Faixa)
                        //--    15/08/09   2.000,00     3.000,00    1.600,00      12,41 (Alcancou a 2.a Faixa) Formula: ((1600 * 7,5)/100)-107,59)
                        //--    31/08/09   2.000,00     5.000,00    2.000,00      30,00 (Alcancou a 2.a Faixa) Formula: ((2000 * 7,5)/100)-(107,59+12,41)
                        //--    31/08/09   1.000,00     6.000,00    2.400,00      48,75 (Alcancou a 3.a Faixa) Fomrula: ((2400 * 15)/100)-(268,84+12,41+30)

                        //--Obtem os titulos com vencimento no periodo:
                        cAliasQry := GetNextAlias()
                        cQuery := "SELECT SE2.E2_FILIAL, SE2.E2_PREFIXO, SE2.E2_NUM, SE2.E2_PARCELA, "
                        cQuery += "SE2.E2_TIPO, SE2.E2_FORNECE, SE2.E2_LOJA, SE2.E2_IRRF, "
                        cQuery += "SE2.E2_INSS, SE2.E2_VENCREA, SE2.E2_VALOR, SE2.E2_BAIXA, "
                        cQuery += "SE2.E2_FATURA, SE2.E2_SEST, SE2.E2_BASEIRF, SE2.E2_ORIGEM, SE2.E2_NATUREZ,SE2.E2_ISS, "
                        cQuery += "SE2.E2_VRETIRF, SE2.E2_STATUS, SE2.E2_FILORIG "

                        If __lBtrISS
                            cQuery += " ,SE2.E2_BTRISS "
                        EndIf

                        cQuery += "FROM " + RetSQLTab('SE2')

                        cQuery += "JOIN " + RetSQLTab('SED')
                        cQuery += "ON  SED.ED_FILIAL  = '" + xFilial('SED') + "' AND "
                        cQuery += "SED.ED_CODIGO  = SE2.E2_NATUREZ AND "
                        cQuery += "SED.ED_CALCIRF = 'S' AND "
                        If !lFina050
                            cQuery += "SED.ED_IRRFCAR = 'S' AND "
                        Endif
                        cQuery += "SED.D_E_L_E_T_ = ' ' "

                        cQuery += " WHERE "

                        //Se verifica base apenas na filial corrente e fornecedor corrente
                        If cAglImPJ == "1" .Or. Empty( cFilFwSE2 )
                            cQuery += "SE2.E2_FILIAL = '"+ xFilial("SE2") + "' AND "

                            If cAglImPJ == "1" 				//Verificar apenas fornecedor corrente
                                cQuery += "SE2.E2_FORNECE = '"+ SA2->A2_COD +"' AND "
                                cQuery += "SE2.E2_LOJA = '"+ SA2->A2_LOJA +"' AND "
                            Else									//Verificar determinados fornecedores (raiz do CNPJ)
                                cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM " + cArqTMP + ")) AND "
                            Endif

                        ElseIf Len(aFilial) > 0  //Mais de uma filial SM0

                            If Empty( cFilFwSA2 )  //Se cadastro de Clientes compartilhado
                                cQuery += "SE2.E2_FILIAL IN ( "
                                For nLoop := 1 to Len(aFilial)
                                    cQuery += "'"  + aFilial[nLoop] + "',"
                                Next
                                //Retiro a ultima virgula
                                cQuery := Left( cQuery, Len( cQuery ) - 1 )
                                cQuery += ") AND "

                                //Verificar determinados fornecedores (raiz do CNPJ)
                                cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM "+cArqTMP+")) AND "
                            Else							//Se cadastro de Clientes EXCLUSIVO
                                cQuery += " (E2_FILIAL||E2_FORNECE||E2_LOJA IN (SELECT FILIALX||CODIGO||LOJA FROM "+cArqTMP+")) AND "
                            Endif
                        Endif

                        // Para Pessoa fisica totaliza os titulos emitidos no mes
                        If cVenctoPF == "2"
                            cQuery += "  SE2.E2_VENCREA  BETWEEN '" + Dtos(FirstDay(M->E2_VENCREA)) + "' AND '" + Dtos(LastDay(M->E2_VENCREA))+ "' AND "
                        ElseIf cVenctoPF == "1"
                            cQuery += "  SE2.E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(M->E2_EMISSAO)) + "' AND '" + Dtos(LastDay(M->E2_EMISSAO))+ "' AND "
                        ElseIf cVenctoPF == "3"
                            cQuery += "  SE2.E2_EMIS1  BETWEEN '" + Dtos(FirstDay(dDataBase)) + "' AND '" + Dtos(LastDay(dDataBase))+ "' AND "
                        Endif
                        cQuery += " SE2.E2_TIPO NOT IN " + F050TipoIN( ,.T.) 	  + " AND "  
                        cQuery += " SE2.E2_FATURA NOT IN('NOTFAT') AND "
                        cQuery += " SE2.E2_STATUS <> 'D' AND "  //Desconsidera os titulos geradores de desdobramento
                        cQuery += " SE2.D_E_L_E_T_ = ' ' "

                        cQuery := ChangeQuery(cQuery)

                        //--Processa a query e adequa os campos
                        DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

                        //--Confronta os titulos obtidos com os contratos:
                        If !(cAliasQry)->( Eof() )

                            TcSetField(cAliasQry,"E2_IRRF","N",TamSX3("E2_IRRF")[1],TamSX3("E2_IRRF")[2])
                            TcSetField(cAliasQry,"E2_INSS","N",TamSX3("E2_INSS")[1],TamSX3("E2_INSS")[2])
                            TcSetField(cAliasQry,"E2_VALOR","N",TamSX3("E2_VALOR")[1],TamSX3("E2_VALOR")[2])
                            TcSetField(cAliasQry,"E2_VENCREA","D",TamSX3("E2_VENCREA")[1],TamSX3("E2_VENCREA")[2])

                            While !(cAliasQry)->( Eof() )
                                //--Titulo gerado a partir de outra origem, exemplo:
                                //--Pedagio, Adiantamentos, inclusao manual, etc...
                                If lFina050 .AND.  "FINA" $ (cAliasQry)->E2_ORIGEM
                                    nValFrete += (cAliasQry)->E2_BASEIRF
                                Else
                                    nValFrete += (cAliasQry)->E2_VALOR + (cAliasQry)->E2_IRRF + (cAliasQry)->E2_INSS +;
                                        (cAliasQry)->E2_ISS + If(__lBtrISS,(cAliasQry)->E2_BTRISS,0) + (cAliasQry)->E2_SEST //Recompoe o valor
                                Endif

                                //Valida se esta alterando contas a pagar
                                If M->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) != ;
                                   (cAliasQry)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_FORNECE+E2_LOJA)
                                    nValIRRF  += (cAliasQry)->E2_IRRF
                                Endif

                                If lFina050
                                    aAreaSED := SED->(GetArea())
                                    dbSelectArea("SED")
                                    dbSeek(XFILIAL("SED")+(cAliasQry)->E2_NATUREZ)

                                    If !lDedIns .and. SED-> ED_IRRFCAR== "S"
                                        nINSSRet += (cAliasQry)->E2_INSS
                                    Elseif lDedIns
                                        nINSSRet += (cAliasQry)->E2_INSS
                                    Endif
                                    RestArea(aAreaSED)
                                Else
                                    nINSSRet  += (cAliasQry)->E2_INSS
                                Endif
                                (cAliasQry)->( DbSkip() )
                            EndDo
                        EndIf
                        (cAliasQry)->(DbCloseArea())

                        //Fecha arquivo temporario
                        If cAglImPJ != "1"
                            If InTransact()
                                StartJob( "DELTRBIR" , GetEnvServer() , .T. , SM0->M0_CODIGO, FWGETCODFILIAL,.T.,ThreadID(),cArqTmp)
                            Else
                                DELTRBIR(SM0->M0_CODIGO, FWGETCODFILIAL,.F.,0,cArqTmp)
                            Endif
                        Endif

                        dbSelectArea("SE2")

                        //--Agrega o valor do titulo que
                        //--esta sendo gerado no momento:
                        If __lLocBRA .AND. lFina050 .and. lBaseImp .and. SED->ED_BASEIRC > 0
                            nValFrete += ((M->E2_VALOR * SED->ED_BASEIRC) / 100)
                        ElseIf !lParcela
                            nValFrete  += M->E2_VALOR
                        Endif
                        // Aplica a reducao de base de calculo (Se houver)     
                        If __lLocBRA .and. SED->ED_BASEIRC > 0 .and. !lFina050
                            nValFrete := ((nValFrete * SED->ED_BASEIRC) / 100)
                        EndIf

                        nBasOrig := nValFrete //Guarda a base sem as deduções legais (para o calculo do IRPF simplificado)

                        // Deduz o INSS do IRRF (Carreteiro)                   
                        nINSSRet += M->E2_INSS
                        If nLimInss > 0 .And. nINSSRet > nLimInss //Verifica se o valor do INSS ultrapassou o valor limite.
                            nINSSRet := nLimInss
                        EndIf

                        If lDedIns
                            nValFrete := nValFrete - nINSSRet
                        EndIf

                        // Deduz os Dependentes                                
                        nValDep := nBaseDep * SA2->A2_NUMDEP
                        nValFrete -= nValDep

                        If !(ALLTRIM(M->E2_ORIGEM) == "FINA290" .AND. (Alltrim(M->E2_FATURA) == "NOTFAT"))
                            //Calculo IRPF considerando deduções legais
                            nCalcIr := NoRound(FA050TabIR(nValFrete) - nValIRRF,2)
                            
                            //Calculo do IRPF considerando dedução simplificada (MP 1.171/23)
                            If cPaisLoc=="BRA" .And. lIrTabSimp .And. M->E2_EMISSAO >= dVigMP1171 .And. nCalcIr > 0
                                nVrIrDedS := NoRound(FA050TabIR(nBasOrig,,lIrTabSimp) - nValIRRF,2)
                                If nCalcIr > nVrIrDedS 
                                    nCalcIr := nVrIrDedS //Considera o IRRF c/ dedução simplificada por ser mais vantajoso
                                EndIf
                            EndIf

                            //Calculo do desconto no IRPF conforme lei nº 15.270/25
                            If nCalcIr > 0 .And. FindFunction("FIrfRedIse")
                                nCalcIr := NoRound(FIrfRedIse(nBasOrig, nCalcIr, M->E2_EMISSAO),2)
                            EndIf     

                            M->E2_IRRF := nCalcIr
                        EndIf

                        IF lF050CIRF
                            M->E2_IRRF := ExecBlock("F050CIRF",.f.,.f.,nBaseIrrf)
                        Endif

                    Else
                        If GetNewPar("MV_RNDIRF",.F.)
                            M->E2_IRRF := Round(((xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1, M->E2_TXMOEDA),MsDecimais(1)) * IF(SED->ED_PERCIRF > 0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100)-nValIRRF,2)
                        Else
                            M->E2_IRRF := NoRound(((xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1, M->E2_TXMOEDA),MsDecimais(1)) * IF(SED->ED_PERCIRF > 0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100)-nValIRRF,2)
                        Endif
                    EndIf

                    //-- Valor do titulo nao pode ser menor que o valor do IRRF
                    If m->e2_valor < m->e2_irrf
                        m->e2_irrf  := m->e2_valor - 0.01
                    EndIf

                    // Regras para retenção do IRRF de Carreteiro.
                    If lAplMinIR .AND.;                     // Fornecedor avalia parâmetro SA2->A2_MINIRF == "2"
                        EMPTY(nValIRRF) .AND.;              // Ainda Não possui retenção no período atual
                        (M->E2_IRRF <= GetMv("MV_VLRETIR")) // O valor apurado eh menor que o parametrizado
                        M->E2_IRRF := 0
                    EndIf
				Else

					If ExistBlock("F050ATP")
						lAplicaTP := ExecBlock("F050ATP",.F.,.F.)
					Endif
                    
					IF (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1")) .AND. lAplicaTP 
						If !lIRPFBaixa
                            lSRefSE2 := SED->ED_JURCAP <> "1"
                            M->E2_IRRF := FCalcIr(nBaseIrrf,"F",.T.,.T.,lSRefSE2)
                        Elseif lIRPFBaixa .and. M->E2_TIPO $ MVPAGANT
                            //Converto para moeda corrente para calcular o IRRF na baixa
                            nBaseIrrf     := Round(NoRound(xMoeda(nBaseIrrf,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1),MsDecimais(1)+1, M->E2_TXMOEDA),MsDecimais(1))
                            M->E2_IRRF    := FCalcIRBx(nBaseIrrf,SA2->A2_TIPO)
                            M->E2_VRETIRF := M->E2_IRRF                           
                        Endif
					ElseIf !lSimples
                        If lIRPFBaixa
                            IF SED->ED_CALCIRF == "S"
                                //Converto para moeda corrente para calcular o IRRF na baixa
                                nBaseIrrf     := Round(NoRound(xMoeda(nBaseIrrf,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1, M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
                                If M->E2_TIPO $ MVPAGANT
                                    M->E2_IRRF    := FCalcIRBx(nBaseIrrf,SA2->A2_TIPO)
                                    M->E2_VRETIRF := M->E2_IRRF
                                Else
                                    M->E2_IRRF := FCalcIr(nBaseIrrf,"J",.T.,.T.)
                                EndIf
                                 
                            EndIf
						ElseIf !(ALLTRIM(M->E2_ORIGEM) == "FINA290" .AND. (Alltrim(M->E2_FATURA) == "NOTFAT"))
							M->E2_IRRF := FCalcIr(nBaseIrrf,"J",.T.,@lIrfRetAnt)
						EndIf
					EndIF

					IF ExistBlock("F050CIRF")
						M->E2_IRRF := ExecBlock("F050CIRF",.f.,.f.,nBaseIrrf)
						nVCalIRF := M->E2_IRRF
						nBCalIRF := nBaseIrrf
					Endif

					IF __lLocBRA
						IF (SA2->A2_TIPO == "F" .OR. SA2->A2_TIPO == "J") .AND. SED->ED_CALCCID == "S" .AND. SA2->A2_RECCIDE == "1"
							M->E2_IRRF := Round(((nBaseIrrf * Iif(AllTrim(Str(m->e2_moeda,2)) $ "01", 1, If(M->E2_MOEDA > 1 .And. M->E2_TXMOEDA > 0, M->E2_TXMOEDA,;
									RecMoeda(m->e2_emissao,m->e2_moeda)))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100)-nValIRRF,2)
						Endif
					EndIf
				EndIf
			Else
				If lImpostos
					M->E2_IRRF	:= 0
					m->e2_vretirf := 0 //Quando alteramos uma natureza com retenção para outra sem retenção, devo zerar os valores para não calcular impostos.
				Endif
				nOldIrr		:= 0
			EndIf
		EndIf

		//se natureza pede calculo do SEST (Fornecedor nao Recolhe)
		If !lSestMR
			If SED->ED_CALCSES == 'S' .And. SA2->A2_RECSEST == "1" .and. lImpostos
				If !Empty(SED->ED_BASESES)
					nValSEST := Round((nValor * (SED->ED_BASESES/100)),2)
				Else
					nValSEST := nValor
				EndIf
				M->E2_SEST := Round((nValSEST * (SED->ED_PERCSES/100)),2)
				nValSEST := M->E2_SEST
			Else
				M->E2_SEST := 0
				nOldSEST    := 0
			EndIf

			nVlAltSEST := M->E2_SEST
		EndIf

		  //CIDE
		If lCIDE .And. !lCidMR .And. !(M->E2_TIPO $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA")

            nBaseCide := M->E2_VALOR

            If M->E2_MOEDA > 1
                nBaseCide := Round(xMoeda(nBaseCide,M->E2_MOEDA,1,M->E2_EMISSAO,TamSX3("E2_TXMOEDA")[2],M->E2_TXMOEDA,1),2)
            EndIf

            M->E2_CIDE := FCalcCIDE(nBaseCide, M->E2_NATUREZ, M->E2_FORNECE, M->E2_LOJA)
        Else
            M->E2_CIDE := 0
        EndIf

		lFirstAlt := .F.

        If cPaisLoc=="BRA"			
			nDedBsPis := Fa986Regra("SE2", "PIS", "1")			
			nDedBsCSL := Fa986Regra("SE2", "CSL", "1")			
			nDedBsCOF := Fa986Regra("SE2", "COF", "1")	
		EndIf

        //PCC
        lPisCal := SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS == "2" .and. SA2->A2_TIPO <> "F"
        lCOFCal := SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2" .and. SA2->A2_TIPO <> "F"
        lCSLCal := SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL == "2" .and. SA2->A2_TIPO <> "F"

		If !lPccMR .AND. lPccBaixa
			If lCalcPIS  .and. lImpostos    // PIS
				//se natureza pede calculo do PIS
				If lPisCal

					nPisCalc := ((xMoeda(nBasePis,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA) + nDedBsPis) * (SED->ED_PERCPIS / 100) )
					If ! GetNewPar("MV_RNDPIS",.F.)
						M->E2_PIS := NoRound(nPisCalc,2)
					Else
						M->E2_PIS := Round(nPisCalc,2)
					Endif

					nPisCalc := M->E2_PIS
					nPisBaseC := nBasePis
				Else
					M->E2_PIS := 0
					m->e2_vretpis := 0 //Quando alteramos uma natureza com retenção para outra sem retenção, devo zerar os valores para não calcular impostos.
					nOldPis	 := 0

					If TYPE("nVlRetPis") <> "U"
						nVlRetPis := 0
					EndIf

				Endif
			EndIf
			M->E2_BASEPIS := nBasePis

			If lCalcCOF .and. lImpostos	// COFINS
					//se natureza pede calculo do COFINS
				If lCOFCal

					nCofCalc := ((xMoeda(nBaseCof,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA) + nDedBsCOF) * (SED->ED_PERCCOF / 100) )
			
					If ! GetNewPar("MV_RNDCOF",.F.)
						m->e2_cofins := NoRound(nCofCalc ,2)
					Else
						m->e2_cofins := Round(nCofCalc ,2)
					Endif
					nCofCalc := m->e2_cofins
					nCofBaseC := nBaseCof
				Else
					M->E2_COFINS := 0
					M->E2_VRETCOF := 0 //Quando alteramos uma natureza com retenção para outra sem retenção, devo zerar os valores para não calcular impostos.
					nOldCofins	 := 0

					If TYPE("nVlRetCof") <> "U"
						nVlRetCof := 0
					EndIf
			
				EndIf
				M->E2_BASECOF:= nBaseCof
			EndIf

			If lCalcCsll .and. lImpostos		// CSLL
					//se natureza pede calculo do CSLL
				If lCSLCal

					nCslCalc := ((xMoeda(nBaseCsll,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA) +nDedBsCSL) * (SED->ED_PERCCSL / 100) )

					If ! GetNewPar("MV_RNDCSL",.F.)
						m->e2_csll := NoRound(nCslCalc,2)
					Else
						m->e2_csll := Round(nCslCalc,2)
					Endif

					nCslCalc := m->e2_csll
					nCslBaseC := nBaseCsll
				Else				    
                    M->E2_CSLL      := 0
					M->E2_VRETCSL   := 0 //Quando alteramos uma natureza com retenção para outra sem retenção, devo zerar os valores para não calcular impostos.
					nOldCsll        := 0

					If TYPE("nVlRetCsl") <> "U"
						nVlRetCsl := 0
					EndIf

				EndIf
				M->E2_BASECSL := nBaseCsll
			EndIf

			// Tratamento de Dispensa de Ret. de PIS, Cofins e Csll
            If !lButMenu .AND. lAplVlMin .AND. M->E2_EMISSAO < __dLastPcc
                FVerMinImp(nBasePis)
            EndIf

        ElseIf !lPccMR .AND. !lPccBaixa .AND. M->E2_EMISSAO >= __dLastPcc
        
            If (lCalcCsll .OR. lCalcCOF .OR. lCalcPIS) .AND. lImpostos


                If lPisCal .OR. lCOFCal .OR. lCSLCal

                    If nVencto == 2
                        dRef := M->E2_VENCREA
                    ElseIf nVencto == 1 .OR. EMPTY(nVencto)
                        dRef := M->E2_EMISSAO
                    ElseIf nVencto == 3
                        dRef := If( Type("M->E2_EMIS1") # "U", If( !Empty(M->E2_EMIS1), M->E2_EMIS1, dDataBase), dDataBase )
                    Endif

                    aRetPCC := NewMinPcc( dRef, nBasePis, SED->ED_CODIGO, "P", SA2->A2_COD + SA2->A2_LOJA )// Cálculo do PCC(Pis, Cofins, Csll) de acordo com a Lei 13.137 (FINXIMP)

                    If lEmpPub
                        aRetPCC := CalcEmpP(nBasePis,nBaseCof,nBaseCsll )                   
                    Endif

                    // PIS
                    nPisCalc := aRetPCC[2]

					If !GetNewPar("MV_RNDPIS",.F.)
						M->E2_PIS := NoRound(nPisCalc,2)
					Else
						M->E2_PIS := Round(nPisCalc,2)
					Endif

					nPisCalc := M->E2_PIS
					nPisBaseC := nBasePis

                    // COFINS
                    nCofCalc := aRetPCC[3]

					If !GetNewPar("MV_RNDCOF",.F.)
						M->E2_COFINS := NoRound(nCofCalc ,2)
					Else
						M->E2_COFINS := Round(nCofCalc ,2)
					Endif

					nCofCalc    := M->E2_COFINS
					nCofBaseC   := nBaseCof

                    // CSLL
                    nCslCalc    := aRetPCC[4]

                    If ! GetNewPar("MV_RNDCSL",.F.)
						M->E2_CSLL := NoRound(nCslCalc,2)
					Else
						M->E2_CSLL := Round(nCslCalc,2)
					Endif

					nCslCalc    := M->E2_CSLL
					nCslBaseC   := nBaseCsll

                Else

                    M->E2_PIS       := 0
					M->E2_VRETPIS   := 0 //Quando alteramos uma natureza com retenção para outra sem retenção, devo zerar os valores para não calcular impostos.
					nOldPis         := 0

                    M->E2_COFINS    := 0
					M->E2_VRETCOF   := 0 //Quando alteramos uma natureza com retenção para outra sem retenção, devo zerar os valores para não calcular impostos.
					nOldCofins      := 0

                    M->E2_CSLL      := 0
					M->E2_VRETCSL   := 0 //Quando alteramos uma natureza com retenção para outra sem retenção, devo zerar os valores para não calcular impostos.
					nOldCsll        := 0

					//Variaveis que tambem sao zeradas caso a nova natureza informada nao tenha retencao
					If TYPE("nVlRetPis") <> "U"
						nVlRetPis := 0
					EndIf
					If TYPE("nVlRetCof") <> "U"
						nVlRetCof := 0
					EndIf
					If TYPE("nVlRetCsl") <> "U"
						nVlRetCsl := 0
					EndIf

                EndIf
                
                If lEmpPub                   
                    FVerMinImp(nBasePis,,lIrfRetAnt)
                    If SA2->A2_MINPUB == "2" .And. M->E2_PIS+M->E2_COFINS+M->E2_CSLL+M->E2_IRRF < nVlMPub .And. !lIrfRetAnt 	
                        nPis := nCoFins := nCsll := nIrrf := 0
                        M->E2_PIS := M->E2_COFINS := M->E2_CSLL := M->E2_IRRF := 0
                        nVlRetPis := nVlRetCof := nVlRetCsl := 0
                    Endif    
                Endif


                M->E2_BASEPIS   := nBasePis
                M->E2_BASECOF   := nBaseCof
                M->E2_BASECSL   := nBaseCsll
            EndIf

        EndIf
		// Se existir os campos de impostos a pagar, PIS, COFINS, CSLL - MP 135
		If !lPccBaixa
			If !lOutImpMR
				M->E2_VALOR := nValor
			EndIf
			If !lIrfMR .And. (!lIRPFBaixa .or. (lIRPFBaixa .and. M->E2_TIPO $ MVPAGANT))
				M->E2_VALOR -= xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA)
			EndIf
			If !lIssMR .And. !lCalcIssBx
				M->E2_VALOR -= xMoeda(If(lBtrISS,M->E2_ISS+M->E2_BTRISS,M->E2_ISS), 1, M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA)
			EndIf
			If !lInsMR 
				M->E2_VALOR -= xMoeda(M->E2_INSS,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA)
			EndIf			
			If !lSestMR 
				M->E2_VALOR -= xMoeda(M->E2_SEST,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA)
			EndIf			
			If !lPccMR 
				M->E2_VALOR -= xMoeda((M->E2_PIS + M->E2_COFINS + M->E2_CSLL),1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA) 
			EndIf			
		Else
			If M->E2_TIPO $ MVPAGANT .and. lPaBruto
				M->E2_VALOR := nValor

			ElseIf M->E2_TIPO $ MVPAGANT .and. !lPaBruto
				M->E2_VALOR := nValor
				If !lIrfMR
					M->E2_VALOR -= xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA)
				EndIf
				If (!lIssMR .And. !lIrfMR .And. !lCalcIssBx .And. lIRPFBaixa) .Or.;
					(!lIssMR .And. lCalcIssBx)
					M->E2_VALOR -=  xMoeda(M->E2_ISS,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA) 
				EndIf
				If !lInsMR
					M->E2_VALOR -= xMoeda(M->E2_INSS,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA) 
				EndIf
				If !lSestMR
					M->E2_VALOR -= xMoeda(M->E2_SEST,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA) 
				EndIf
				If !lPccMR
					M->E2_VALOR -= xMoeda((M->E2_PIS + M->E2_COFINS + M->E2_CSLL),1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA) 				
				EndIf
			Else
				If !lPccMR .And. !lIrfMR .And. !lInsMR .And. !lIssMR .And. !lCidMR .And. !lSestMR .And. !lOutImpMR
					M->E2_VALOR := nValor
				EndIf

				If !lIrfMR .and. !lIRPFBaixa
					M->E2_VALOR -= xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA)
				EndIf
				If !lIssMR .and. !lCalcIssBx
					M->E2_VALOR -= xMoeda(If(lBtrISS,M->E2_ISS+M->E2_BTRISS,M->E2_ISS), 1, M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA)
				EndIf
				If !lInsMR 
					M->E2_VALOR -= xMoeda(M->E2_INSS,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA)
				EndIf			
				If !lSestMR 
					M->E2_VALOR -= xMoeda(M->E2_SEST,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA)
				EndIf			
			Endif
		Endif

		If !lInsMR .And. __lLocBRA .and. SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
			M->E2_VALOR += xMoeda(M->E2_INSS,1,M->E2_MOEDA,M->E2_EMISSAO,MsDecimais(1)+1,,M->E2_TXMOEDA)
		Endif

		// Inicializa o valor em Real como sugestao
		M->E2_VLCRUZ := xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,,M->E2_TXMOEDA)

		// Inicializa o Tipo do titulo TX
		If Empty(M->E2_TIPO)
			If SA2->A2_RECISS != "S"      // Fornecedor nao recolhe ISS
				If AllTrim(M->E2_NATUREZ) $ AllTrim(&(GetMv("MV_ISS"))) .or. ;
					AllTrim(M->E2_NATUREZ) $ AllTrim(&(GetMv("MV_IRF"))) .or. ;
					AllTrim(M->E2_NATUREZ) $ AllTrim(&(GetMv("MV_INSS")))
					M->E2_TIPO	:= MVTAXA
				EndIf
			ElseIf SA2->A2_RECINSS == "S"      // Gero titulo de INSS
				If AllTrim(M->E2_NATUREZ) $ AllTrim(&(GetMv("MV_ISS"))) .or. ;
					AllTrim(M->E2_NATUREZ) $ AllTrim(&(GetMv("MV_IRF"))) .or. ;
					AllTrim(M->E2_NATUREZ) $ AllTrim(&(GetMv("MV_INSS")))
					M->E2_TIPO	:= MVTAXA
				EndIf
			ElseIf SA2->A2_RECSEST == "1"  // Gero titulo de SEST
				If AllTrim(M->E2_NATUREZ) $ AllTrim(&(GetMv("MV_ISS"))) .or. ;
					AllTrim(M->E2_NATUREZ) $ AllTrim(&(GetMv("MV_IRF"))) .or. ;
					AllTrim(M->E2_NATUREZ) $ AllTrim(&(GetMv("MV_INSS"))) .or. 	AllTrim(M->E2_NATUREZ) $ AllTrim(cSEST)
					M->E2_TIPO	:= MVTAXA
				EndIf
			Else
				If AllTrim(M->E2_NATUREZ) $ AllTrim(&(GetMv("MV_IRF")))
					M->E2_TIPO	:= MVTAXA
				EndIf
			EndIf
		Endif
	
		nOldValor 	:= M->E2_VALOR
		nOldIrr		:= M->E2_IRRF
		nOldIss		:= M->E2_ISS
		nOldInss	:= M->E2_INSS
		nOldSEST	:= M->E2_SEST
		nOldPis		:= M->E2_PIS
		nOldCofins	:= M->E2_COFINS
		nOldCsll	:= M->E2_CSLL
		If lBtrISS
			nOldBtrISS := M->E2_BTRISS
		EndIf
	Endif
EndIf

M->E2_SALDO := M->E2_VALOR

// Ponto de Entrada que possibilitara o canculo ou nao PIS/CONFINS/CSLL
If lFA050Imp
	Execblock("FA050IMP",.F.,.F.)
Endif

cOldNaturez := M->E2_NATUREZ
lRefresh  	:= .T.

Return lRetorna


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} IMPCTAPG

Funcao que retorna uma matriz com os titulos TXs gerados a partir do titulo principal que estiver selecionado (FINA050).
Arquivo anterior: FINXFUN.PRX

@Param cImposto, Caractere, Define o imposto que sera retornado no array pela natureza (E2_NATUREZ)
@param lSeek - define se vai realizar a busca dos impostos pelo DbSeek
@Return - Array

aImpGer[1] E2_PREFIXO
aImpGer[2] E2_NUM
aImpGer[3] E2_PARCELA
aImpGer[4] E2_TIPO
aImpGer[5] E2_NATUREZ
aImpGer[6] E2_VALOR
aImpGer[7] E2_SALDO
aImpGer[8] E2_NUMBOR
aImpGer[9] R_E_C_N_O_
aImpGer[10] E2_CNPJRET

@Author	Nilton Pereira
@since	28/07/2005
/*/
//-----------------------------------------------------------------------------------------------------
Function ImpCtaPg(cImposto as character, lSeek as logical) as array

Local aArea      as array
Local aImpGer    as array
Local cPrefixo   as character
Local cNum       as character
Local cParcIR    as character
Local cParcISS   as character
Local cParcINS   as character
Local cParcCSS   as character
Local cParcSES   as character
Local cParcPIS   as character
Local cParcCOF   as character
Local cParCSLL   as character
Local cParcCID   as character
Local lPagAnt    as logical
Local lPCCBaixa  as logical
Local cQuery     as character
Local cAliasQry  as character
Local cTipoImp   as character
Local nTamTitPai as numeric
Local cParcINP   as character
Local lGetParINP as logical
Local cChaveTit  as character
Local cIdFK7     as character
Local nParam     as numeric
Local oQryCtaPg  as object
Local lUseBilRel as logical

Default cImposto := ""
Default lSeek    := .T.

aArea      := GetArea()
aImpGer    := {}
cPrefixo   := ""
cNum       := ""
cParcIR    := ""
cParcISS   := ""
cParcINS   := ""
cParcCSS   := ""
cParcSES   := ""
cParcPIS   := ""
cParcCOF   := ""
cParCSLL   := ""
cParcCID   := ""
lPagAnt    := .F.
lPCCBaixa  := IIF(__lLocBRA,SuperGetMv("MV_BX10925",.T.,"2") == "1",.F.)
cQuery     := ""
cAliasQry  := ""
cTipoImp   := ""
nTamTitPai := TamSx3("E2_TITPAI")[1]
cParcINP   := " "
lGetParINP := FindFunction("GetParcINP")
cChaveTit  := ""
cIdFK7     := ""
nParam     := 1
oQryCtaPg  := Nil
lUseBilRel := .F.

// Soh efetua a varredura, caso não seja Tx.
If (SE2->E2_TIPO $ MVTXA+"/"+MVTAXA)
	Return aImpGer
ElseIf (SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG) // Sendo PA
	lPagAnt := .T.
Endif

//Verifica se a base ja passou pelo fix, permitindo o uso do FK7_IDPAI na query
If FindFunction("UsaBillRel")
	lUseBilRel := UsaBillRel() <> Nil
EndIf

// Carrega as variaveis para pesquisa dos titulos de impostos.
cPrefixo := SE2->E2_PREFIXO
cNum     := SE2->E2_NUM
cParcIR  := SE2->E2_PARCIR
cParcISS := SE2->E2_PARCISS
cParcINS := SE2->E2_PARCINS
cParcCSS := SE2->E2_PARCCSS
cParcSES := SE2->E2_PARCSES
cParcPIS := SE2->E2_PARCPIS
cParcCOF := SE2->E2_PARCCOF
cParCSLL := SE2->E2_PARCSLL

If __lLocBRA
    cParcCID := SE2->E2_PARCCID
Endif

cChaveTit := SE2->E2_FILIAL  + "|" +;
			 SE2->E2_PREFIXO + "|" +;
			 SE2->E2_NUM     + "|" +;
			 SE2->E2_PARCELA + "|" +;
			 SE2->E2_TIPO	 + "|" +;
			 SE2->E2_FORNECE + "|" +;
			 SE2->E2_LOJA

cIdFK7 := FINBuscaFK7(cChaveTit, "SE2")

cQuery := " SELECT E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_NUMBOR, SE2.R_E_C_N_O_ RECNO,E2_CNPJRET "
cQuery += " FROM " + RetSqlName("SE2") + " SE2 "
If lUseBilRel
    cQuery += " INNER JOIN " + RetSqlName("FK7") + " FK7 ON "
    cQuery += " FK7.FK7_FILTIT = SE2.E2_FILIAL    AND "
    cQuery += " FK7.FK7_PREFIX = SE2.E2_PREFIXO   AND "
    cQuery += " FK7.FK7_NUM    = SE2.E2_NUM       AND "
    cQuery += " FK7.FK7_PARCEL = SE2.E2_PARCELA   AND "
    cQuery += " FK7.FK7_TIPO   = SE2.E2_TIPO      AND "
    cQuery += " FK7.FK7_CLIFOR = SE2.E2_FORNECE   AND "
    cQuery += " FK7.FK7_LOJA   = SE2.E2_LOJA      AND "
    cQuery += " FK7.D_E_L_E_T_ = SE2.D_E_L_E_T_ "
EndIf
cQuery += " WHERE E2_FILIAL = ? AND "
If lUseBilRel
    cQuery += " FK7.FK7_IDPAI  = ? AND "
    cQuery += " FK7.FK7_ALIAS  = ? AND "    
Else
    cQuery += " E2_TITPAI = ? AND "
EndIf
If !Empty(cImposto)
    cQuery += " E2_NATUREZ = ? AND "
Endif
cQuery += " SE2.D_E_L_E_T_ = ?"

cQuery := ChangeQuery(cQuery)
oQryCtaPg := FwExecStatement():New(cQuery)

oQryCtaPg:SetString(nParam++, FWxFilial("SE2"))
If lUseBilRel
    oQryCtaPg:SetString(nParam++, cIdFK7)
    oQryCtaPg:SetString(nParam++, 'SE2')
Else
    oQryCtaPg:SetString(nParam++, Substr(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),1, nTamTitPai))
EndIf
If !Empty(cImposto)
    oQryCtaPg:SetString(nParam++, cImposto)
Endif
oQryCtaPg:SetString(nParam++, Space(1)) 

cAliasQry := oQryCtaPg:OpenAlias()

If (cAliasQry)->(!Eof())

	cTipoImp := If(lPagAnt,MVTAXA+"/"+MVTXA,MVTAXA)+"/"+MVISS+"/"+MVINSS+"/"+"SES"+"/"+"CID"+"/"+"INA"+"/"+"INP"

	While (cAliasQry)->(!Eof())
		If (cAliasQry)->E2_TIPO $  cTipoImp
			Aadd(aImpGer,{(cAliasQry)->E2_PREFIXO,(cAliasQry)->E2_NUM,(cAliasQry)->E2_PARCELA,(cAliasQry)->E2_TIPO,(cAliasQry)->E2_NATUREZ,(cAliasQry)->E2_VALOR,(cAliasQry)->E2_SALDO,(cAliasQry)->E2_NUMBOR, (cAliasQry)->RECNO, (cAliasQry)->E2_CNPJRET})
		EndIf

		(cAliasQry)->(DbSkip())
	EndDo
ElseIf lSeek
    // INSS Patronal
    If lGetParINP
        GetParcINP(@cParcINP)
    EndIf

	// Seleciono SE2 com outro alias para efetuar a varredura dos impostos
	If Select("__SE2") == 0
		ChkFile("SE2",.F.,"__SE2")
	Else
		DbSelectArea("__SE2")
	EndIf

	dbSetOrder(1)

	// IR - Caso exista o campo de parcela, verifica se seu conteudo nao eh branco e LOCALiza o titulo de impostos.
	If !Empty(cParcIR)
		If (dbSeek(xFilial("SE2") + cPrefixo + cNum + cParcIR + If(lPCCBaixa.And.lPagAnt,MVTXA,MVTAXA)))
			Aadd(aImpGer,{E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_NUMBOR,__SE2->(Recno()),E2_CNPJRET})
		Endif
	Endif

	// ISS - Caso exista o campo de parcela, verifica se seu conteudo nao eh branco e LOCALiza o titulo de impostos.
	If !Empty(cParcISS)
		If (dbSeek(xFilial("SE2") + cPrefixo + cNum + cParcISS + "ISS"))
			Aadd(aImpGer,{E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_NUMBOR,__SE2->(Recno()),E2_CNPJRET})
		Endif
	Endif

	// INSS - Caso exista o campo de parcela, verifica se seu conteudo nao eh branco e LOCALiza o titulo de impostos.
	If !Empty(cParcINS)
		If (dbSeek(xFilial("SE2") + cPrefixo + cNum + cParcINS + If(lPCCBaixa.And.lPagAnt,MVTXA,MVTAXA)))
			Aadd(aImpGer,{E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_NUMBOR,__SE2->(Recno()),E2_CNPJRET})
		Endif
	Endif

	// CSS - Caso exista o campo de parcela, verifica se seu conteudo nao eh branco e LOCALiza o titulo de impostos.
	If !Empty(cParcCSS)
		If (dbSeek(xFilial("SE2") + cPrefixo + cNum + cParcCSS + If(lPCCBaixa.And.lPagAnt,MVTXA,MVTAXA)))
			Aadd(aImpGer,{E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_NUMBOR,__SE2->(Recno()),E2_CNPJRET})
		Endif
	Endif

	// SEST - Caso exista o campo de parcela, verifica se seu conteudo nao eh branco e LOCALiza o titulo de impostos.
	If !Empty(cParcSES)
		If (dbSeek(xFilial("SE2") + cPrefixo + cNum + cParcSES + If(lPCCBaixa.And.lPagAnt,MVTXA,MVTAXA)))
			Aadd(aImpGer,{E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_NUMBOR,__SE2->(Recno()),E2_CNPJRET})
		Endif
	Endif

	// PIS - Caso exista o campo de parcela, verifica se seu conteudo nao eh branco e LOCALiza o titulo de impostos.
	If !Empty(cParcPIS)
		If (dbSeek(xFilial("SE2") + cPrefixo + cNum + cParcPIS + If(lPCCBaixa .And. lPagAnt,MVTXA,MVTAXA)))
			Aadd(aImpGer,{E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_NUMBOR,__SE2->(Recno()),E2_CNPJRET})
		Endif
	Endif

	// COFINS - Caso exista o campo de parcela, verifica se seu conteudo nao eh branco e LOCALiza o titulo de impostos.
	If !Empty(cParcCOF)
		If (dbSeek(xFilial("SE2") + cPrefixo + cNum + cParcCOF + If(lPCCBaixa .And. lPagAnt,MVTXA,MVTAXA)))
			Aadd(aImpGer,{E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_NUMBOR,__SE2->(Recno()),E2_CNPJRET})
		Endif
	Endif

	// CSLL - Caso exista o campo de parcela, verifica se seu conteudo nao eh branco e LOCALiza o titulo de impostos.
	If !Empty(cParCSLL)
		If (dbSeek(xFilial("SE2") + cPrefixo + cNum + cParCSLL + If(lPCCBaixa .And. lPagAnt,MVTXA,MVTAXA)))
			Aadd(aImpGer,{E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_NUMBOR,__SE2->(Recno()),E2_CNPJRET})
		Endif
	Endif

	// CIDE - Caso exista o campo de parcela, verifica se seu conteudo nao eh branco e LOCALiza o titulo de impostos.
	If !Empty(cParcCID)
		If SE2->(dbSeek(xFilial("SE2") + cPrefixo + cNum + cParcCID + "CID"))
			Aadd(aImpGer,{E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_NUMBOR,__SE2->(Recno()),E2_CNPJRET})
		Endif
	Endif

    // INSS PATRONAL - Caso exista o campo de parcela, verifica se seu conteudo nao eh branco e LOCALiza o titulo de impostos.
    If !Empty(cParcINP)
        If __SE2->(dbSeek(xFilial("SE2") + cPrefixo + cNum + cParcINP + "INP"))
            Aadd(aImpGer,{__SE2->E2_PREFIXO,__SE2->E2_NUM,__SE2->E2_PARCELA,__SE2->E2_TIPO,__SE2->E2_NATUREZ,__SE2->E2_VALOR,__SE2->E2_SALDO,__SE2->E2_NUMBOR,__SE2->(Recno()),__SE2->E2_CNPJRET})
        Endif
    Endif

EndIf

(cAliasQry)->(DbCloseArea())
FwFreeObj(oQryCtaPg)
RestArea(aArea)

Return aImpGer


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RETORDTAB

Retorna qual a ordem de indice atende a uma determinada chave (FINA050).
Arquivo anterior: FINXFUN.PRX

@Author	Marcelo Celi Marques
@since	17/09/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function RetOrdTab(cTabela,cCampos)
LOCAL nOrdPTransf := 1
LOCAL aArea := GetArea()
LOCAL cRetorno := ""

dbSelectarea(cTabela)
dbSelectArea("SIX")
dbSeek(cTabela,.T.)

While SIX->INDICE == cTabela .And. !Eof()
	If Upper(cCampos) $ Upper(SIX->CHAVE)
		Exit
	Endif
	nOrdPTransf++
    dbSkip()
EndDo

RestArea(aArea)
If Upper(cCampos)	$ Upper(SIX->CHAVE)
	cRetorno := nOrdPTransf
Else
	cRetorno := 0
Endif

Return cRetorno


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA050DELPA

Retorna qual a ordem de indice atende a uma determinada chave (FINA050).
Arquivo anterior: FINXFUN.PRX

@Author	Wagner Mobile Costa
@since	13/06/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa050DelPa(lVerifica, lTemCheq, nRecSef)

LOCAL lCheqSE5	 := .F.
LOCAL lEstPaSe5  := .T.
LOCAL lBxConc    := SuperGetMv("MV_BXCONC",.T.,.F.) == "1"
Local aAreaAnt	 := {}
Local lRet       := .T.
Local cChavSE2   := ""
Local lEstCheq   := .F.
Local aAreaSE5   := {}
Local lPAMovBA   := .F.
Local lPAVeio    := .F.

If lVerifica
	dbSelectArea("SE5")
	dbSetOrder(2)

	If dbSeek(xFilial("SE5")+"PA"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+Dtos(SE2->E2_EMISSAO)+SE2->E2_FORNECE+SE2->E2_LOJA)
		//Se configurado para nao deletar caso conciliado conforme o parametro MV_BXCONC ³
		If !lBxConc .And. !Empty(SE5->E5_RECONC)
			Help( " ", 1, "EXCPARECONC" ) // Pagamento Antecipado não pode ser excluido pois este se encontra conciliado/reconciliado - Verificar parametro MV_BXCONC
			lRet := .F.
		Endif

		dbSelectArea( "SA6" )
		SA6->(dbSeek( cFilial+SE5->E5_BANCO+SE5->E5_AGENCIA+SE5->E5_CONTA ))
	EndIf

	//RETIRAR ESTE BLOCO DE DENTRO DO IF DO SE5, VERIFICAR SE EXISTE CHEQUE
	//AGLUTINADO, APAGAR O REGISTRO REFERENTE AO PA E ATUALIZAR O SALDO DO REGISTRO TOTALIZADOR
	If lRet .AND. cPaisLoc != 'RUS'
		dbSelectArea("SEF")
		SEF->( dbSetOrder( 3 ) )
		lTemCheq := .F.
		lPaChqImp := .F.

		If SEF->(dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO))
			cChavSE2 := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)

			While !Eof() .and. EF_FILIAL == cFilial .and. cChavSE2 == SEF->(EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO)
				If SEF->EF_FORNECE == SE2->E2_FORNECE
					If SEF->EF_IMPRESS == "A"
						HELP(" ",1,"FA050DELPA")
						lRet := .F.
					Endif

					If SEF->EF_IMPRESS == "S"
						lPAChqImp := .T.
						RecLock("SEF")
						SEF->EF_IMPRESS := "C"
						MsUnlock()
					Endif

					lTemCheq := .T.
					nRecSef	:= RecNo()
				Endif
				SEF->( dbSkip() )
			Enddo

			dbSelectArea( "SEF" )
			SEF->( dbSkip( ) )
		EndIf
	EndIf
Else
	dbSelectArea("SE5")
	dbSetOrder(2)

	If (dbSeek(xFilial("SE5")+"PA"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO))
		cChavSE2 := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)

		While !Eof() .and. xFilial("SE5") == SE5->E5_FILIAL .and. SE5->E5_TIPODOC == "PA" .and. cChavSE2 == SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)
			If SE2->(E2_FORNECE+E2_LOJA) == SE5->(E5_CLIFOR+E5_LOJA)
				lCheqSE5 := .T.
				Exit
			Else
				dbSkip()
			EndIf
		Enddo

		//Valida se houve cancelamento do cheque
		aAreaSE5 := SE5->(GetArea())
		If (dbSeek(xFilial("SE5")+"ES"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO))
			While !Eof() .and. xFilial("SE5") == SE5->E5_FILIAL .and. SE5->E5_TIPODOC == "ES" .and. cChavSE2 == SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)
				If SE2->(E2_FORNECE+E2_LOJA) == SE5->(E5_CLIFOR+E5_LOJA) .and. !empty(SE5->E5_NUMCHEQ)
					lEstCheq := .T.
					Exit
				Else
					dbSkip()
				EndIf
			Enddo
		EndIf
		SE5->(RestArea(aAreaSE5))

	//Caso cheque tenha sido liberado posteriormente a inclusÆo do PA deve-se buscar no SE5 o cheque gerado para o PA
	Elseif lTemCheq
		dbSelectArea("SEF")
		dbGoTo(nRecSef)
		
		// Este ponto de entrada serve para LOCALização do cheque do PA quando o mesmo foi informado na emissao 
		// e o cheque liberado posteriormente. Para que funcione corretamente é necessaria a criacao 
		// no sindex do indice para SE5 c/ a chave FILIAL+BANCO+AGENCIA+CONTA+NRO DO CHEQUE. 
		// Ideal para bases grandes.
		If ExistBlock("F050CHPA")
			lCheqSE5 := ExecBlock("F050CHPA",.F.,.F.)
		Else
			// Localiza movimentacao de CH somente se o campo do mesmo estiver preenchido.
			If !Empty( SEF->EF_NUM )
				dbSelectArea("SE5")
				dbSetOrder(11)
				If dbSeek(xFilial()+SEF->(EF_BANCO+EF_AGENCIA+EF_CONTA+EF_NUM))
					While !Eof() .and. xFilial("SE5") == SE5->E5_FILIAL .and. ;
						SE5->(E5_BANCO+E5_AGENCIA+E5_CONTA+E5_NUMCHEQ) == ;
						SEF->(EF_BANCO+EF_AGENCIA+EF_CONTA+EF_NUM)
						If !Empty(SEF->EF_NUM) .And. SE5->E5_NUMCHEQ == SEF->EF_NUM .AND. SE5->E5_TIPODOC == 'CH'
                            If SEF->EF_IMPRESS <> "C"
							    lCheqSE5 := .T.
                            Endif    
							Exit
						Else
							dbSkip()
						Endif
					Enddo
				Endif
			EndIf
		Endif
	Endif
    
    If lCheqSE5
		If Substr(SE2->E2_NUMBCO,1,1) != "*"
			AtuSalBco( SE5->E5_BANCO,SE5->E5_AGENCIA,SE5->E5_CONTA,ddatabase,SE5->E5_VALOR,"+")
		Endif

		If ExistBlock("F050DLPA")
			lEstPaSe5 := ExecBlock("F050DLPA",.F.,.F.)
		Endif

        //PA COM MOVIMENTO DIRETO
		If lEstPaSe5 .and. !lEstCheq
			//Obtem os dados do registro tipo PA para gerar um registro de estorno apenas quando nao for gerado cheque na inclusao do PA
			dbSetOrder( 1 )
			aAreaAnt := GetArea()

            lRet := FEstPaFK(lTemCheq, lPAMovBA, lCheqSE5, lEstCheq )   

            RestArea(aAreaAnt)

            //Ponto de Entrada para manipular os campos do E5 que acabaram de ser gravados no estorno da exclusão do PA
            If lRet .And. ExistBlock("F050EXCPA")
                ExecBlock("F050EXCPA",.F.,.F.)
            EndIf

			If !lRet .And. Substr(SE2->E2_NUMBCO,1,1) != "*"
				AtuSalBco(SE5->E5_BANCO,SE5->E5_AGENCIA,SE5->E5_CONTA,ddatabase,SE5->E5_VALOR,"-")
			Endif
		Endif
	Else 
        
   		dbSelectArea("SE5")
		dbSetOrder(2)
        
        //PA COM MOVIMENTO COM CHEQUE MAS CHEQUE INFORMADO POSTERIORMENTE 
		If (dbSeek(xFilial("SE5")+"BA"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO))
			cChavSE2 := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO)

			While !Eof() .and. xFilial("SE5") == SE5->E5_FILIAL .and. SE5->E5_TIPODOC == "BA" .And. cChavSE2 == SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)
				If SE2->(E2_FORNECE+E2_LOJA) == SE5->(E5_CLIFOR+E5_LOJA)
					aAreaAnt:= GetArea()
					// Obs.: Mantido gravação com Reclock SE5 porque essa rotina não deverá gerar nenhuma FK5 na inclusão do PA sem cheque.
			    	If SE5->E5_TIPO $ MVPAGANT .And. SE5->E5_TIPODOC == "BA"
                        lPAMovBA := .T.
                        //PAs com cheque Legado
                        If Empty(SE5->E5_IDORIG)
                            lPAVeio := .T.
                            RecLock("SE5") 
                            dbDelete()
                            MsUnLock()
                        Endif
    					Exit
                    Endif
				EndIf
				SE5->(dbSkip())
			Enddo
		Endif
       
        //PA COM CHEQUE ou PA CNAB
		//Ajustar relacionamentos entre SE2/SEF/FK3/FK4
        If lEstPaSe5 .and. !lEstCheq

            If !lPAVeio
                //Obtem os dados do registro tipo PA para gerar um registro de estorno apenas quando nao for gerado cheque na inclusao do PA
                dbSelectArea("SE2")
                dbSetOrder( 1 )
                aAreaAnt := GetArea()

                lPaCNAB := !lTemCheq

                lRet := FEstPaFK(lTemCheq, lPAMovBA, lCheqSE5, lEstCheq, lPaCNAB )

                RestArea(aAreaAnt)

            Endif

            If lTemCheq
                dbSelectArea("SEF")
                dbGoTo(nRecSef)
                If SEF->EF_IMPRESS != "C"
                    Reclock("SEF",.F.,.T.)
                    dbDelete()
                Else
                    RecLock("SEF")
                    Replace EF_KEY with EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO
                    Replace EF_PREFIXO With ""
                    Replace EF_TITULO With ""
                    Replace EF_PARCELA With ""
                    Replace EF_TIPO With ""
                    MsUnlock()
                    FKCOMMIT()
                Endif
            Endif
		Endif
	EndIf
Endif

Return lRet


//----------------------------------------------------------------------------------
/*/{Protheus.doc} FEstPaFK
Gravacao de registros excluidos da tabela SE2 e SE1}

@author Mauricio Pequim Jr
@since 02/03/2021
@version P12
/*/
//----------------------------------------------------------------------------------
Function FEstPaFK(lTemCheq, lPAMovBA, lCheqSE5, lEstCheq, lPaCNAB )

    Local oModel	:= Nil
    Local oSubFK5	:= Nil	
    Local oSubFKA	:= Nil
    Local cLog      := ""
    Local cCamposE5 := ""
    Local lRet      := .T.
    Local cChave    := ""
    Local cTabOri   := ""
    Local nOper     := 0
    Local cModelMov := "FINM050"
    Local lGrvAnt   := .F.

    DEFAULT lTemCheq := .F.
    DEFAULT lPAMovBA := .F.
    DEFAULT lCheqSE5 := .F.
    DEFAULT lEstCheq := .F.
    DEFAULT lPaCNAB  := .F.

    If lTemCheq .or. lPaCNAB     //PA com cheque ou PA CNAB
        cChave  := xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+;
                                      SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA                                        
        cChave  := FINBuscaFK7(cChave, "SE2")
        cTabOri := "SE2"
    Else                        //PA com movimento sem cheque
        cChave  := SE5->E5_IDORIG
        cTabOri := SE5->E5_TABORI
        cModelMov := If (FIsPaVeio(cChave,cTabori),"FINM030",cModelMov)
        If AllTrim(cModelMov) != "FINM050" //No modelo FINM050 não há a função FINProcFKs para exclusão de PA
            BxGerMovPA(.T.)
        EndIf
    Endif

    nOper := If(lPAMovBA, 3, 2) 

    FKA->(DbSetOrder(3))    //FKA_FILIAL, FKA_TABORI, FKA_IDORIG
    If FKA->(dbSeek(xFilial("FKA")+ cTabOri + cChave )) 
        FinSetAPrc(cTabOri)

        If !lTemCheq .and. !lPaCNAB
            cCamposE5:="{"
            cCamposE5+="{'E5_KEY','"+SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_FORNECE+E5_LOJA)+"' } "
            cCamposE5+= ",{'E5_PREFIXO',  ''  }"
            cCamposE5+= ",{'E5_NUMERO',  ''  }"
            cCamposE5+= ",{'E5_PARCELA',  ''  }"
            cCamposE5+= ",{'E5_TIPO',  ''  }"
            cCamposE5+="}"
        Endif

        oModel :=  FWLoadModel(cModelMov)//Mov. Bancarios
        oModel:SetOperation( 4 ) //Alteração
        oModel:Activate()
        oSubFKA  := oModel:GetModel("FKADETAIL")
        oSubFK5  := oModel:GetModel("FK5DETAIL")

        oSubFKA:SeekLine({{"FKA_IDORIG",cChave}})

        oModel:SetValue( "MASTER", "E5_GRV", lCheqSE5 ) //habilita gravação de SE5
        oModel:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
        oModel:SetValue( "MASTER", "E5_OPERACAO", nOper) //Estorno
        oModel:SetValue( "MASTER", "HISTMOV", STR0010 ) //"Exclusao de Titulo PA"

        lGrvAnt:= oSubFKA:Length() == 1 .AND. cTabOri == "FK5"

        //Dados do movimento
        If lCheqSE5
            If cModelMov == "FINM030"
                oSubFK5:SetValue( "FK5_LA", "S" )
            Else
                oModel:SetValue( "MASTER", "E5_LA", "S")
            EndIf
        Endif

        If oModel:VldData()
            oModel:CommitData()
            FKCOMMIT()
        Else
            cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
            cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
            cLog += cValToChar(oModel:GetErrorMessage()[6])
            Help( ,,"M050VALID",,cLog, 1, 0 )
            lRet := .F.
        Endif
        oModel:DeActivate()
        oModel:Destroy()
        oModel:= Nil
        FinSetAPrc()

        If lGrvAnt //Indica forma de gravação antiga 

            If __lTemMR 
                cChave  := xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+;
                                            SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA                                        
                cChave  := FINBuscaFK7(cChave, "SE2")

                FMRDelImp( "SE2", cChave, 2 )
            EndIf
        EndIf
    Endif

Return lRet

//----------------------------------------------------------------------------------
/*/{Protheus.doc} FIsPaVeio
Verifica se o PA cancelado está com modo de gravação antiga

@author Mauricio Pequim Jr
@since 10/03/2021
@version P12
/*/
//----------------------------------------------------------------------------------
Function FIsPaVeio(cChave,cTabori)

    Local lRet := .F.

    FK3->(DbSetOrder(2))
    If FK3->(MsSeek(xFilial("FK3") + cTabori + cChave))
        lRet := .T.
    EndIf
    
Return lRet



//----------------------------------------------------------------------------------
/*/{Protheus.doc} FinGrvEx
Gravacao de registros excluidos da tabela SE2 e SE1}

@author Jose.Gavetti 
@since 15/07/2014
@version P12
/*/
//----------------------------------------------------------------------------------
Function FinGrvEx(cCart,cFilPai,cPrefPai,cNumPai,cParcPai,cTipoPai,cForCliPai,cLojaPai,nRecPai)

Local nTamCart := TamSx3("FJU_CART")[1]
Local aAreaGrv		:= GetArea()
	Local cChaveFJU		:= ""

Default cCart:= ""
Default cFilPai:= ""
Default cPrefPai:= ""
Default cNumPai:= ""
Default cParcPai:= ""
Default cTipoPai:= ""
Default cForCliPai:= ""
Default cLojaPai:= ""
Default nRecPai:= 0


	dbSelectArea("FJU")
	dbSetOrder(1)

	If cCart == "P"

		cChaveFJU := FJU->(xFilial("FJU")+Padr(cCart,nTamCart)+STR(SE2->(RECNO()),10)+STR(nRecPai,10))

		If FJU->(!dbSeek(cChaveFJU))

			RecLock("FJU",.T.)
		  	FJU->FJU_FILIAL	:=	xFilial("FJU")
			FJU->FJU_PREFIX	:=	SE2->E2_PREFIXO
			FJU->FJU_NUM		:=	SE2->E2_NUM
			FJU->FJU_PARCEL	:=	SE2->E2_PARCELA
			FJU->FJU_CLIFOR	:=	SE2->E2_FORNECE
			FJU->FJU_LOJA		:=	SE2->E2_LOJA
			FJU->FJU_CART		:=	'P'
			FJU->FJU_EMIS		:=	SE2->E2_EMISSAO
			FJU->FJU_EMIS1	:= 	SE2->E2_EMIS1
			FJU->FJU_DTEXCL	:= 	ddatabase
			FJU->FJU_VALOR	:=	SE2->E2_VALOR
			FJU->FJU_TIPO    	:= 	SE2->E2_TIPO
			FJU->FJU_VENREA 	:= 	SE2->E2_VENCREA
			FJU->FJU_LA      	:= 	SE2->E2_LA
			FJU->FJU_VLCRUZ	:= 	SE2->E2_VLCRUZ
			FJU->FJU_MOEDA   	:= 	SE2->E2_MOEDA
			FJU->FJU_HIST    	:= 	SE2->E2_HIST
			If __lLocBRA
		   		FJU->FJU_TITPAI	:= SE2->E2_TITPAI
		   	Endif
			FJU->FJU_RECORI	:= SE2->(RECNO())
			FJU->FJU_FILPAI	:= cFilPai
			FJU->FJU_PREPAI	:= cPrefPai
			FJU->FJU_NUMPAI	:= cNumPai
			FJU->FJU_PARPAI	:= cParcPai
			FJU->FJU_TIPPAI	:= cTipoPai
			FJU->FJU_FORPAI	:= cForCliPai
			FJU->FJU_LOJPAI 	:= cLojaPai
			FJU->FJU_RECPAI	:= nRecPai
			FJU->(MsUnlock())
		EndIf
	Else

		cChaveFJU := FJU->(xFilial("FJU")+Padr(cCart,nTamCart)+STR(SE1->(RECNO()),10)+STR(nRecPai,10))

		If FJU->(!dbSeek(cChaveFJU))

	 	 	RecLock("FJU",.T.)
		  	FJU->FJU_FILIAL	:=	xFilial("FJU")
			FJU->FJU_PREFIX	:=	SE1->E1_PREFIXO
			FJU->FJU_NUM	:=	SE1->E1_NUM
			FJU->FJU_PARCEL	:=	SE1->E1_PARCELA
			FJU->FJU_CLIFOR	:=	SE1->E1_CLIENTE
			FJU->FJU_LOJA	:=	SE1->E1_LOJA
			FJU->FJU_CART	:=	'R'
			FJU->FJU_EMIS	:=	SE1->E1_EMISSAO
			FJU->FJU_EMIS1	:= 	SE1->E1_EMIS1
			FJU->FJU_DTEXCL	:= 	ddatabase
			FJU->FJU_VALOR	:=	SE1->E1_VALOR
			FJU->FJU_TIPO   := 	SE1->E1_TIPO
			FJU->FJU_VENREA := 	SE1->E1_VENCREA
			FJU->FJU_LA     := 	SE1->E1_LA
			FJU->FJU_VLCRUZ	:= 	SE1->E1_VLCRUZ
			FJU->FJU_MOEDA  := 	SE1->E1_MOEDA
			FJU->FJU_HIST   := 	SE1->E1_HIST
			FJU->FJU_TITPAI	:= SE1->E1_TITPAI
			FJU->FJU_RECORI	:= SE1->(RECNO())
			FJU->FJU_FILPAI	:= cFilPai
			FJU->FJU_PREPAI	:= cPrefPai
			FJU->FJU_NUMPAI	:= cNumPai
			FJU->FJU_PARPAI	:= cParcPai
			If __lLocBRA
				FJU->FJU_TIPPAI	:= cTipoPai
			Endif
			FJU->FJU_FORPAI	:= cForCliPai
			FJU->FJU_LOJPAI := cLojaPai
			FJU->FJU_RECPAI	:= nRecPai
            If FJU->(ColumnPos("FJU_DOCTEF")) .AND. !EMPTY(SE1->E1_DOCTEF)
			    FJU->FJU_DOCTEF	:= SE1->E1_DOCTEF
            EndIf

			FJU->(MsUnlock())
		Endif
	 Endif

RestArea(aAreaGrv)

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} PrinDesdobr
Função que verifica se o titulo desdobrado é o titulo originador ou o gerado pelo desdobramento
@return lDesdobrPrin .T. se for o titulo originador. F se for o gerado pelo desdobramento

@author Karen Honda
@version P12
/*/
//-------------------------------------------------------------------
Function PrinDesdobr()

Local lDesdobrPrin := .F.

If Type("Inclui")=="U"
	Inclui:=.F.
EndIf

//Desconsiderar titulo originador de desdobramento
If Inclui
	lDesdobrPrin := M->E2_DESDOBR == "S"
Else
	dbSelectArea("FI8")
	FI8->(DbSetOrder(1)) //FI8_FILIAL, FI8_PRFORI, FI8_NUMORI, FI8_PARORI, FI8_TIPORI, FI8_FORORI, FI8_LOJORI, R_E_C_N_O_, D_E_L_E_T_
	If dbSeek(xFilial("FI8")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
		lDesdobrPrin := .T.
	Endif
Endif

Return lDesdobrPrin


//-------------------------------------------------------
/*/{Protheus.doc} Fa050VlPFS
Valida o banco selecionando quando integração SIGAPFS x SIGAFIN está ativa.

@param cBancoAdt, Código do banco selecionado para o PA
@param cAgenciaAdt, Agência do banco selecionado para o PA
@param cNumCon, Conta do banco selecionado para o PA

@author Bruno Ritter
@since 25/07/2018
@version P12
/*/
//-------------------------------------------------------
Static Function Fa050VlPFS(cBancoAdt, cAgenciaAdt, cNumCon)
	
Local lRet     := .T.
Local lIntPFS  := SuperGetMV("MV_JURXFIN",,.F.) // Integração SIGAPFS x SIGAFIN
Local lJFilBco := SuperGetMv( "MV_JFILBCO", .F., .F. ) .And. FindFunction("JURF3SA6") .And. FindFunction("JurVldSA6") //Indica se filtra as contas correntes vinculadas ao escritório logado - SIGAPFS.
Local cEscrit  := ""

	If lJFilBco .And. FindFunction("JurVldSA6")
		cEscrit := JurGetDados("NS7", 4, xFilial("NS7") + cFilant + cEmpAnt, "NS7_COD")
		lRet    := JurVldSA6("3", {cEscrit, cBancoAdt, cAgenciaAdt, cNumCon})

	ElseIf lIntPFS .And.  FindFunction("JurBnkNat")
		lRet := JurBnkNat(cBancoAdt, cAgenciaAdt, cNumCon)
	EndIf

Return lRet


/*
=============================================================================
-----------------------------------------------------------------------------

	    Funcoes retiradas do arquivo FINA050.PRX (Revitalização)

-----------------------------------------------------------------------------
=============================================================================
*/

//-------------------------------------------------------------------
/*/{Protheus.doc} FA050Aprov
Retorna o código do aprovador para o campo E2_CODAPRO

@author Marcos R. Pires
@since 04/10/11
/*/
//-------------------------------------------------------------------
Function FA050Aprov(nMoeda)

    Local aSaveArea	:= GetArea()
    Local aSaveFRP	:= {}
    Local cRet		:= CriaVar("E2_CODAPRO",.F.)
    Local cMoedaTit	:= ""

    Default nMoeda	:= CriaVar("E2_MOEDA",.F.)

    //Verifica a existencia da tabela

    aSaveFRP := FRP->(GetArea())

    If nMoeda > 0

        cMoedaTit := StrZero(nMoeda,TamSx3("E2_MOEDA")[1])

        //Verifica se o parametro contem o codigo do aprovador ou comando a ser executado
        cRet := &(SuperGetMv(("MV_FINAP"+cMoedaTit),.F.,""))

        If Empty(cRet) .Or. ValType(cRet) != "C" .Or. Len(AllTrim(cRet)) > TAMSX3("E2_CODAPRO")[1]
            cRet := SuperGetMv(("MV_FINAP"+cMoedaTit),.F.,"")
        EndIf

        //Verifica se o registro existe na tabela FRP
        If !Empty(cRet) .And. Len(AllTrim(cRet)) <= TAMSX3("E2_CODAPRO")[1]
            dbSelectArea("FRP")
            dbSetOrder(1) //FRP_FILIAL+FRP_COD+FRP_MOEDA
            If !(dbSeek(xFilial("FRP")+cRet+cMoedaTit))
                cRet := CriaVar("E2_CODAPRO",.F.)
                Help(" ",1,"MV_FINAP"+cMoedaTit)
            EndIf
        Else
            cRet := CriaVar("E2_CODAPRO",.F.)
        EndIf

    EndIf

    RestArea(aSaveFRP)
    RestArea(aSaveArea)

Return(cRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} FA050VldAp
Valida se o aprovador informado no campo E2_CODAPROD condiz
com a moeda do titulo. (X3_VALID)    

@author Marcos R. Pires
@since 04/10/11
/*/
//-------------------------------------------------------------------
Function FA050VldAp(cAprov, nMoeda)

    Local aSaveArea	:= GetArea()
    Local aSaveFRP	:= {}
    Local lRet		:= .T.
    Local cCtAl 	:= SuperGetMV( "MV_FINCTAL", .T., "1" )

	Default cAprov := ""
	Default nMoeda := 1

    dbSelectArea("FRP")
    aSaveFRP := FRP->(GetArea())
    dbSetOrder(1)

	If cCtAl == "2"
		If Empty(cAprov)
			Help(" ",1,"F050VldApr",, STR0017, 1, 0 )	//"O campo 'Cod. Aprov.' é obrigatório quando controle de alçadas está ativo."
			lRet := .F.
		ElseIf !(dbSeek(xFilial("FRP")+cAprov+StrZero(nMoeda,TamSX3("E2_MOEDA")[1])))
			Help(" ",1,"CODAPRO")
			lRet := .F.
		ElseIf FRP->FRP_MSBLQL = '1'
			Help(" ",1,"APROBLQ" ,, STR0012, 1, 0 )		//"Aprovador Bloqueado."
			lRet := .F.
		EndIf
    EndIf

    RestArea(aSaveFRP)
    RestArea(aSaveArea)

Return lRet


//-------------------------------------------------------
/*/{Protheus.doc} Fa050PIS
Atualiza o PIS do título.

@author Claudio D. de Souza
@since 11/12/03
@version P12
/*/
//-------------------------------------------------------
Function Fa050PIS()

    Local nValor := 0
    Local nSaldo := 0
	Local lRet := .T.
    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	Local nVlrPISMT := Round(xMoeda(M->E2_PIS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)

	//Valida se permite a atualização do imposto
	lRet := F050VlAlt()

    If lRet .And. nOldPis != M->E2_PIS
        lAltValor := .T.

		// Guarda valor anterior do PIS para reconstituir valor original apenas se for alteracao. 
		// Verifica também se foi alterada a natureza, pois essa alteracao causava problemas na 
		// reconstituição do valor original.
		If SE2->E2_PIS != 0 .and. M->E2_PIS == 0 .and. SE2->E2_NATUREZ == M->E2_NATUREZ .and. lAltera
			nOldPis := Round(xMoeda( SE2->E2_PIS ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Else
			nOldPis := Round(xMoeda( nOldPis ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Endif

		dbSelectArea("SED")
		dbSeek(cFilial+M->E2_NATUREZ)

		// Somente compoe o valor original, caso a geracao dos impostos
		// nao sejam pela baixa ou caso seja pagamento antecipado
		If !lPccBaixa .Or. M->E2_TIPO $ MVPAGANT
			nValor := M->E2_VALOR + nOldPis
			M->E2_VALOR := nValor - nVlrPISMT
			nSaldo := M->E2_SALDO + nOldPis
			M->E2_SALDO := nSaldo - nVlrPISMT
		Endif
		
		M->E2_VLCRUZ := Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA,1),MsDecimais(1)+1),MsDecimais(1))

		nOldValor 	:= M->E2_VALOR
		nOldSaldo 	:= M->E2_SALDO
		nOldPis		:= M->E2_PIS
		nVlRetPis	:= M->E2_PIS
		lRefresh 	:= .T.

	Endif

Return lRet


//-------------------------------------------------------
/*/{Protheus.doc} Fa050Cofins
Atualiza o COFINS do título.

@author Claudio D. de Souza
@since 11/12/03
@version P12
/*/
//-------------------------------------------------------
Function Fa050Cofins()

    Local nValor := 0
    Local nSaldo := 0
	Local lRet	 := .T.
    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	Local nVlrCofMT := Round(xMoeda(M->E2_COFINS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)

	//Valida se permite a atualização do imposto
	lRet := F050VlAlt()

    If lRet .And. nOldCofins != M->E2_COFINS
        lAltValor := .T.

		// Guarda valor anterior do COFINS p/reconstituir valor original Apenas se for alteracao. 
		// Verifica também se foi alterada a natureza, pois essa alteracao causava problemas na reconstituição
		// do valor original.
		If SE2->E2_COFINS != 0 .and. M->E2_COFINS == 0 .and. SE2->E2_NATUREZ == M->E2_NATUREZ .and. lAltera
			nOldCofins := Round(xMoeda(SE2->E2_COFINS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Else
			nOldCofins := Round(xMoeda( nOldCofins ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Endif

		dbSelectArea("SED")
		dbSeek(xFilial("SED") + M->E2_NATUREZ)

		// Somente compoe o valor original, caso a geracao dos impostos nao sejam pela baixa ou caso seja pagamento antecipado
		If !lPccBaixa .Or. M->E2_TIPO $ MVPAGANT
			nValor		:= M->E2_VALOR + nOldCofins
			M->E2_VALOR := nValor - nVlrCofMT
			nSaldo		:= M->E2_SALDO + nOldCofins
			M->E2_SALDO := nSaldo - nVlrCofMT
		Endif

		M->E2_VLCRUZ := Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA,1),MsDecimais(1)+1),MsDecimais(1))

		nOldValor 	:= M->E2_VALOR
		nOldSaldo 	:= M->E2_SALDO
		nOldCofins	:= M->E2_COFINS
		nVlRetCof	:= M->E2_COFINS
		lRefresh 	:= .T.
	Endif	

Return lRet

//-------------------------------------------------------
/*/{Protheus.doc} Fa050CSLL
Atualiza o CSLL do título.

@author Claudio D. de Souza
@since 11/12/03
@version P12
/*/
//-------------------------------------------------------
Function Fa050CSLL()

    Local nValor := 0
    Local nSaldo := 0
	Local lRet	 := .T.
    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	Local nVlrCslMT := Round(xMoeda(M->E2_CSLL,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)

	//Valida se permite a atualização do imposto
	lRet := F050VlAlt()

    If lRet .And. nOldCsll != M->E2_CSLL
        lAltValor := .T.

		// Guarda valor anterior do CSLL p/reconstituir valor original Apenas se for alteracao. 
		// Verifica também se foi alterada a natureza, pois essa alteracao causava problemas na reconstituição
		// do valor original.
		If SE2->E2_CSLL != 0 .and. M->E2_CSLL == 0 .and. SE2->E2_NATUREZ == M->E2_NATUREZ .and. lAltera
			nOldCsll := Round(xMoeda(SE2->E2_CSLL,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Else
			nOldCsll := Round(xMoeda( nOldCsll ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Endif

		dbSelectArea("SED")
		dbSeek(xFilial("SED") + M->E2_NATUREZ)

		// Somente compoe o valor original, caso a geracao dos impostos nao sejam pela baixa ou caso seja pagamento antecipado
		If !lPccBaixa .Or. M->E2_TIPO $ MVPAGANT
			nValor := M->E2_VALOR + nOldCsll
			M->E2_VALOR := nValor - nVlrCslMT

			nSaldo := M->E2_SALDO + nOldCsll
			M->E2_SALDO := nSaldo - nVlrCslMT
		Endif

		M->E2_VLCRUZ := Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA,1),MsDecimais(1)+1),MsDecimais(1))

		nOldValor 	:= M->E2_VALOR
		nOldSaldo 	:= M->E2_SALDO
		nOldCsll	:= M->E2_CSLL
		nVlRetCsl	:= M->E2_CSLL
		lRefresh 	:= .T.
	Endif

Return lRet

//-------------------------------------------------------
/*/{Protheus.doc} Fa050CIDE

Atualiza o CIDE do título.

@author Patricia A. Salomao
@since 10/05/02
@version P12
/*/
//-------------------------------------------------------
Function Fa050CIDE()

    Local lContrRet := .T.
	Local lRet := .T.
    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

	//Valida se permite a atualização do imposto
	lRet := F050VlAlt()

    If lRet .And. nOldCID != M->E2_CIDE
		lFirstAlt := .F.
		// Inicializa o valor em Real como sugestao
		M->E2_VLCRUZ := Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA,1),MsDecimais(1)+1),MsDecimais(1))

		nOldValor 	:= M->E2_VALOR
		nOldSaldo 	:= M->E2_SALDO
		nOldCID    := m->e2_cide
		lRefresh 	:= .T.

		//Caso controle retencao (lei 10925) e seja pela baixa
		If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
			FA050NAT2(.T.)
		Endif
	Endif

Return lRet

//-------------------------------------------------------
/*/{Protheus.doc} Fa050IRR

Atualiza o IRR do título.

@author Pilar S. Albaladejo
@since 07/11/95
@version P12
/*/
//-------------------------------------------------------
Function Fa050IRR()

    Local nValor := 0
	Local lRet := .T.
    // Controla IRPF na Baixa
    Local lIRPFBaixa := IIf( __lLocBRA, SA2->A2_CALCIRF == "2", .F.)
	Local nVlrIrfMT := Round(xMoeda(M->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)

	//Valida se permite a atualização do imposto
	lRet := F050VlAlt()

    If lRet .And. nOldIRR <> M->E2_IRRF
        lAltValor := .T.

	    If ( SA2->A2_TIPO == "F" .and. SA2->A2_CALCIRF == "2" )
    	    If !( M->E2_IRRF == 0 )
        	    MsgAlert(OemToAnsi(STR0013),OemToAnsi(STR0014)) // 'Para Fornecedores do tipo Pessoa Física com retenção na baixa de IRRF não é possível informar valores neste campo.'###Atencão
            	lRet := .F.
        	EndIf
    	EndIf

		If lRet
			// Guarda valor anterior do CSLL p/reconstituir valor original Apenas se for alteracao. 
			// Verifica também se foi alterada a natureza, pois essa alteracao causava problemas na reconstituição
			// do valor original.
			If SE2->E2_IRRF != 0 .and. M->E2_IRRF == 0 .and. SE2->E2_NATUREZ == M->E2_NATUREZ .and. lAltera
				nOldIRR := Round(xMoeda(SE2->E2_IRRF,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
			Else
				nOldIRR := Round(xMoeda( nOldIRR ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
			Endif

			dbSelectArea("SED")
			dbSeek(xFilial("SED") + M->E2_NATUREZ)

			nValor := M->E2_VALOR + Iif(lIRPFBaixa,0,nOldIRR)
			M->E2_VALOR := nValor - nVlrIrfMT
			M->E2_SALDO := M->E2_VALOR

			If !lIRPFBaixa
				M->E2_VRETIRF := M->E2_IRRF
			EndIf

			// Atualiza valores na tela
			// Inicializa o valor em Real como sugestao
			M->E2_VLCRUZ := Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA,1),MsDecimais(1)+1),MsDecimais(1))

			nOldValor 	:= M->E2_VALOR
			nOldSaldo 	:= M->E2_SALDO
			nOldIRR		:= M->E2_IRRF
			lRefresh 	:= .T.

		Endif
	Endif

Return .t.

//-------------------------------------------------------
/*/{Protheus.doc} Fa050INSS

Atualiza o INSS do título.

@author Mauricio Pequim Jr.
@since 21/01/99
@version P12
/*/
//-------------------------------------------------------
Function Fa050INSS()

    Local nValor := 0
	Local lRet := .T.
	Local nVlrInsMT := Round(xMoeda(M->E2_INSS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)

	//Valida se permite a atualização do imposto
	lRet := F050VlAlt()

    If lRet .And. nOldInss != M->E2_INSS
        lAltValor := .T.
		lFirstAlt := .F.

		// Guarda valor anterior do INSS para reconstituir valor original apenas se for alteracao. 
		// Verifica também se foi alterada a natueza, pois essa alteracao causava problemas na reconstituição
		// do valor original.
		If SE2->E2_INSS != 0 .and. M->E2_INSS == 0 .and. SE2->E2_NATUREZ == M->E2_NATUREZ .and. lAltera
			nOldInss := Round(xMoeda(IF(lFirstAlt , SE2->E2_INSS , nVlAltInss ),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Else
			nOldInss := Round(xMoeda( nOldInss ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Endif

		dbSelectArea("SED")
		dbSeek(cFilial + M->E2_NATUREZ)

		If !INCLUI .Or. M->E2_DESDOBR == "N" //Ajuste para que não recomponha o valor do título no desdobramento
			IF SED->ED_DEDINSS $ "1 "  //desconta o INSS do principal
				nValor := M->E2_VALOR + nOldInss
				M->E2_VALOR := nValor - nVlrInsMT
			Endif
		Endif

		nVlaltInss := M->E2_INSS
		M->E2_VRETINS := M->E2_INSS

		//Inicializa o valor em Real como sugestao
		M->E2_VLCRUZ := Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA,1),MsDecimais(1)+1),MsDecimais(1))
        
		M->E2_SALDO := M->E2_VALOR
		nOldValor 	:= M->E2_VALOR
		nOldSaldo 	:= M->E2_SALDO
		nOldInss	:= M->E2_INSS
		lRefresh 	:= .T.

	EndIF

Return lRet

//-------------------------------------------------------
/*/{Protheus.doc} Fa050SEST

Atualiza o SEST do título.

@author Patricia A. Salomao
@since 10/05/02
@version P12
/*/
//-------------------------------------------------------
Function Fa050SEST()

    Local nValor := 0
	Local lRet := .T.
	Local nVlrSesMT := Round(xMoeda(M->E2_SEST,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)

	//Valida se permite a atualização do imposto
	lRet := F050VlAlt()

    If lRet .And. nOldSEST != M->E2_SEST

		// Guarda valor anterior do SEST para reconstituir valor original apenas se for alteracao. 
		// Verifica também se foi alterada a natureza, pois essa alteracao causava problemas na reconstituição
		// do valor original.
		If lAltera .and. SE2->E2_SEST != 0 .and. M->E2_SEST == 0 .and. SE2->E2_NATUREZ == M->E2_NATUREZ 
			nOldSEST := Round(xMoeda(IF(lFirstAlt , SE2->E2_SEST , nVlAltSEST ),1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Else
			nOldSEST := Round(xMoeda( nOldSEST ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		Endif

		dbSelectArea("SED")
		dbSeek(cFilial+M->E2_NATUREZ)

		nValor := M->E2_VALOR + nOldSEST
		M->E2_VALOR := nValor - nVlrSesMT
		nVlaltSEST := M->E2_SEST
		lFirstAlt := .F.

		// Inicializa o valor em Real como sugestao	
		M->E2_VLCRUZ := Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA,1),MsDecimais(1)+1),MsDecimais(1))

		nOldValor 	:= M->E2_VALOR
		nOldSaldo 	:= M->E2_SALDO
		nOldSEST	:= M->E2_SEST
		lRefresh 	:= .T.

	Endif

Return lRet

//-------------------------------------------------------
/*/{Protheus.doc} Fa050ISS

Atualiza o ISS do título.

@author Pilar S. Albaladejo
@since 07/11/95
@version P12
/*/
//-------------------------------------------------------
Function Fa050ISS()

    Local nValor := 0
    Local lContrRet := .T.
	Local lRet := .T.
    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
    Local lCalcIssBx := IIF(__lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
    Local lF050AISS := ExistBlock("F050AISS")
	Local nVlrIssMT := Round(xMoeda(M->E2_ISS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
	Local nVlrBIssMT := 0
	Local lBtrISS := SE2->(ColumnPos("E2_BTRISS")) > 0 .and. SE2->(ColumnPos("E2_VRETBIS")) > 0 .and. SE2->(ColumnPos("E2_CODSERV")) > 0

    If __lLocBRA

		If lBtrISS
			nVlrBIssMT := Round(xMoeda(M->E2_BTRISS,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
		EndIf

		//Valida se permite a atualização do imposto
		lRet := F050VlAlt()

		If lRet .And. nOldISS != m->e2_iss 
			lAltValor := .T.

			// Guarda valor anterior do ISS para reconstituir valor original apenas se for alteracao. 
			// Verifica tambÉm se foi alterada a natureza, pois essa alteracao causava problemas na reconstituição
			// do valor original.
			If SE2->E2_ISS != 0 .and. m->e2_iss == 0 .and. SE2->E2_NATUREZ == M->E2_NATUREZ .and. lAltera
				nOldISS := Round(xMoeda( SE2->E2_ISS ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
			Else
				nOldISS := Round(xMoeda( nOldISS ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
			Endif

			If lBtrISS .and. lAltera .and. SE2->E2_BTRISS != 0 .and. m->e2_btriss == 0 .and. SE2->E2_NATUREZ == M->E2_NATUREZ
				nOldBtrISS := Round(xMoeda( SE2->E2_BTRISS ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
			Else
				nOldBtrISS := Round(xMoeda( nOldBtrISS ,1,M->E2_MOEDA,M->E2_EMISSAO,3,1,M->E2_TXMOEDA), 2)
			EndIf

			If (!lCalcIssBx) .OR. ( lCalcIssBx .AND. M->E2_TIPO $ MVPAGANT )
				nValor := M->E2_VALOR + nOldISS + nOldBtrISS
				M->E2_VALOR := nValor - nVlrIssMT - If(lBtrISS,nVlrBIssMT,0)
				M->E2_VRETISS := M->E2_ISS
				If lBtrISS
					M->E2_VRETBIS := M->E2_BTRISS
				EndIf
			Endif

			//Inicializa o valor em reais como sugestao
			M->E2_VLCRUZ := Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA,1),MsDecimais(1)+1),MsDecimais(1))
            
			M->E2_SALDO := M->E2_VALOR
			nOldValor 	:= M->E2_VALOR
			nOldSaldo 	:= M->E2_SALDO
			nOldISS		:= M->E2_ISS
			If lBtrISS
				nOldBtrISS := m->e2_btriss
			EndIf
			lRefresh := .T.

			//Caso controle retencao (lei 10925) e seja pela baixa
			If lContrRet .And. lPccBaixa .And. !(M->E2_TIPO $ MVPAGANT)
				FA050NAT2(.T.)
			Endif

			If lF050AISS
				ExecBlock("F050AISS",.F.,.F.)
			EndIf
		Endif
	Endif	

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} FClcIRPJ
Cálculo do IRRF de Pessoa Juridica

@nBaseIRRF : Base Irrf
@lFinanceiro : Ambiente do Módulo do Financeiro
@lSRefSE2 : Utiliza o alias do SE2, senão utiliza a memória
@aTitBord : Títulos já processados no borderô (Processamento)
@cBordero : Número de identificação do Borderô (FINA241)

@author Marylly A. Silva
@since  02/05/11
/*/
//-------------------------------------------------------------------
Function FClcIRPJ(nBaseIRRF,lFinanceiro,lSRefSE2,aTitBord,cBordero,lRegra)

    Local aArea			:= GetArea()
    Local aAreaSED  	:= SED->(GetArea())
    Local aAreaSE2  	:= SE2->(GetArea())
    Local aAreaSE5  	:= SE5->(GetArea())
    Local nTotTit		:= 0
    Local nTotInss		:= 0
    Local nTotIrrf		:= 0
    Local nValor		:= 0
    Local lSest			:= __lLocBRA //Verifica campo de SEST
    Local lAplMinIR 	:= .F. // Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
    Local nVenctoPJ 	:= SuperGetMv("MV_ACMIRPJ",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
    Local lCalcIr		:= .F.
    Local lNatIr		:= .F.
    Local lContrRet 	:= .T.

    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa		:= 	SuperGetMv("MV_BX10925",.T.,"2") == "1"

    // Bandeira de cálculo de Imposto de Renda na Baixa
    Local lIRPFBaixa 	:=	IIf(__lLocBRA, SA2->A2_CALCIRF == "2", .F.)

    Local lCalcIssBx :=  IIF(__lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

    Local lVretIrf		:= .T.
    Local nTotRtIr		:= 0
    Local nRecAtual		:= SE2->(RECNO())
    Local cAglImPJ 		:= SuperGetMv("MV_AGLIMPJ",.T.,"1")
    Local aFilial  		:= {}
    Local aCliFor  		:= {}
    Local cQuery   		:= ""
    Local nLoop    		:= 0
    Local nBaseSED		:= 1
    Local cArqTmp 		:= ""
    Local nVlTitBor		:= 0
    Local lRotBorder	:= FwIsInCallStack("FINA241") .OR. FwIsInCallStack("FINA590")
    Local nNotRet		:= 0
    Local nValAcum		:= 0
    Local lBaseDif 		:= cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|PAD|PAN|PAR|PER|POR|PTG|SAL|TRI|URU|VEN"
    Local cLayout       := FWSM0Layout()
    Local lGestao	    := "E" $ cLayout .Or. "U" $ cLayout
    Local cFilFwSA2     := IIF( lGestao , FwFilial("SA2") , xFilial("SA2") )
    Local cFilFwSED     := IIF( lGestao , FwFilial("SED") , xFilial("SED") )
    Local lDelTrbIR	:= .T.
    Local aStru		:= SE2->(dbStruct())
    Local cSepNeg	:= If("|"$MV_CPNEG,"|",",")
    Local cSepProv	:= If("|"$MVPROVIS,"|",",")
    Local cSepRec	:= If("|"$MVPAGANT,"|",",")
    Local nX 		:= 0
    Local cDbMs		:= UPPER(TcGetDb())
    Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
    Local cAcmIrrf 	:= SuperGetMv("MV_ACMIRRF",.T.,"1")  //1 = Acumula    2= Não acumula
    Local nNroFil := 0
    Local lE2FilComp := FwModeAccess("SE2",3) == "C"
    Local nDedBase 	 := 0
	
    DEFAULT nBaseIRRF		:= 0
    DEFAULT lFinanceiro		:= .F.//Indica que o calculo foi chamado pelo modulo Financeiro
    DEFAULT lSRefSE2		:= .F.//Define se a pesquisa deve acontecer sem a referencia de um titulo na SE2 (Variável de Memória)
    DEFAULT aTitBord		:= {}
    DEFAULT cBordero		:= ""
	DEFAULT lRegra          := .T. //Define se ao calcular o IR, se irá considerar as regras da rotina Complemento de Impostos
	
    INCLUI:= IIF(Type("INCLUI") == "U", .T., INCLUI)
    ALTERA:= IIF(Type("ALTERA") == "U", .F., ALTERA)

    If !lIRPFBaixa
        Help("Ambiente necessita atualização.",1,"")
    EndIf

    //Ponto de entrada para verificar se Acumula ou não os valores de IR no calculo
    //Alteracao efetuada para atender a Pinheiro Neto Advogados (Replicado da Função FcalcIR)
    If lAcumIr
        lCalcIr := ExecBlock("F050CALIR",.F.,.F.)
    EndIf

    // Verifica se o fornecedor trata o valor minimo de retencao.
    // 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
    If __lLocBRA .and. SA2->A2_MINIRF == "2"
        lAplMinIR := .T.
    EndIf

    If !lFinanceiro .AND. !lSRefSE2
        RegToMemory("SE2",.F.,.F.)
    EndIf

    If lFinanceiro
        If IsBlind()
            RegToMemory("SE2",.F.,.F.)
        Else
            RegToMemory("SE2",.F.,.F.,,Funname())
        EndIf

        nLastDay := Day(LastDay(M->E2_EMISSAO))
        nTamData := Iif(Len(Dtoc(M->E2_EMISSAO)) == 10, 7, 5)
        dDataImp := M->E2_EMISSAO
    EndIf

    //Valida se a natureza corrente calcula IR
    //Se não, desconsidera retenção de pendências (Caso não seja do Financeiro)
    If !lFinanceiro
        dbSelectArea("SED")
        aAreaSED := SED->(GetArea())
        SED->(dbSetOrder(1))
        If SED->(dbSeek(xFilial("SED")+M->E2_NATUREZ))
            If SED->ED_CALCIRF == "S"
                lNatIr := .T.
            EndIf
        EndIf
        RestArea(aAreaSED)
    Else
        //natureza do Financeiro é validada antes da chamada desta função
        lNatIr := .T.
    EndIf

    //No caso de novo calculo de IRRF Baixa, efetuo o calculo apenas do imposto do titulo
	lCalcIr := If (lIrpfBaixa, .T., lCalcIr )

    If __lLocBRA
		nDedBase  := Fa986Regra("SE2","IRF","1" )
    EndIf
	
    nBaseIrrf := nBaseIrrf + nDedBase
    If nBaseIrrf < 0
		nBaseIrrf := 0
	EndIf
	
    If lNatIr
        //Verifico a combinacao de filiais (SM0) e lojas de fornecedores a serem considerados
        //na montagem da base do IRRF
        If cAglImPJ != "1"
            aRet 	:= FLOJASIRRF("2")
            aFilial := aClone(aRet[1])
            aCliFor := aClone(aRet[2])
            cArqTMP := aRet[3]
        EndIf

        If cAcmIrrf	==	"1" .And. (!lAcumIr .Or.  (lAcumIr .And. lCalcIr))

            cQuery := "SELECT "
            cQuery += "DISTINCT SE2.E2_FILIAL,SE2.E2_PREFIXO,SE2.E2_NUM,SE2.E2_PARCELA,SE2.E2_TIPO,SE2.E2_FORNECE,SE2.E2_LOJA, "
            cQuery += "SE2.E2_EMIS1,SE2.E2_VENCREA,SE2.E2_EMISSAO,SE2.E2_NATUREZ,SE2.E2_VALOR,SE2.E2_IRRF,SE2.E2_INSS,SE2.E2_ISS "
            cQuery += ",SE2.E2_MOEDA, SED.ED_PERCIRF, SE2.E2_BAIXA, SE2.E2_NUMBOR, SE2.E2_SALDO, SE2.R_E_C_N_O_ SE2_RECNO "
            cQuery += ", SE2.E2_NUMLIQ, SE2.E2_FATURA "

            If lSest
                cQuery += ",E2_SEST"
            EndIf

            If lContrRet
                cQuery += ",E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,E2_VRETPIS,E2_VRETCOF,E2_VRETCSL "
            EndIf

            IF lVRetIrf
                cQuery += ",E2_VRETIRF "
            EndIf

            cQuery += " FROM " + RetSQLname("SE2") + " SE2 "
            cQuery += " INNER JOIN " + RetSQLname("SED") + " SED ON SE2.E2_NATUREZ = SED.ED_CODIGO"
            cQuery += " WHERE "

            If lVretIrf
                nNroFil := Len(aFilial)

                //Se verifica base apenas na filial corrente e fornecedor corrente
                If cAglImPJ == "1"
                    If lE2FilComp
                        cQuery += "SE2.E2_FILORIG = '" + cFilAnt + "' AND "
                    Else
                        cQuery += "SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "
                    EndIf

                    cQuery += "SE2.E2_FORNECE = '" + SA2->A2_COD + "' AND "
                    cQuery += "SE2.E2_LOJA = '" + SA2->A2_LOJA + "' AND "
                ElseIf nNroFil > 0
                    If Empty( cFilFwSA2 )
                        cQuery += If(lE2FilComp, "SE2.E2_FILORIG IN( ", "SE2.E2_FILIAL IN ( ")

                        For nLoop := 1 to nNroFil
                            cQuery += "'" + aFilial[nLoop] + "',"
                        Next nLoop

                        //Retiro a ultima virgula
                        cQuery := Left(cQuery, Len(cQuery) - 1)
                        cQuery += ") AND "

                        //Verificar determinados fornecedores (raiz do CNPJ)
                        If "MSSQL" $ cDbMs
                            cQuery += " (E2_FORNECE+E2_LOJA IN (SELECT CODIGO+LOJA FROM " + cArqTMP + ")) AND "
                        Else
                            cQuery += " (E2_FORNECE||E2_LOJA IN (SELECT CODIGO||LOJA FROM " + cArqTMP + ")) AND "
                        Endif
                    Else//Se cadastro de Clientes EXCLUSIVO
                        If "MSSQL" $ cDbMs
                            cQuery += " (E2_FILIAL+E2_FORNECE+E2_LOJA IN (SELECT FILIALX+CODIGO+LOJA FROM "+ cArqTMP + ")) AND "
                        Else
                            cQuery += " (E2_FILIAL||E2_FORNECE||E2_LOJA IN (SELECT FILIALX||CODIGO||LOJA FROM " + cArqTMP + ")) AND "
                        Endif
                    Endif
                Endif
            Else
                cQuery += "SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "
                cQuery += "SE2.E2_FORNECE = '"+ SA2->A2_COD + "' AND "
                cQuery += "SE2.E2_LOJA = '" + SA2->A2_LOJA + "' AND "
            Endif

            // Para Pessoa juridica totaliza os titulos emitidos no dia
            If nVenctoPJ == "2"
                If Type("M->E2_VENCREA")=="U"
                    cQuery += " SE2.E2_VENCREA  = '" + Dtos(SE2->E2_VENCREA)+ "' AND "	//Totaliza pelo vencimento real
                Else
                    cQuery += " SE2.E2_VENCREA  = '" + Dtos(M->E2_VENCREA) 	+ "' AND "	//Totaliza pelo vencimento real
                EndIf
            ElseIf nVenctoPJ == "1"
                If Type("M->E2_EMISSAO")=="U"
                    cQuery += " SE2.E2_EMISSAO  = '" + Dtos(SE2->E2_EMISSAO)	+ "' AND "
                Else
                    cQuery += " SE2.E2_EMISSAO  = '" + Dtos(M->E2_EMISSAO)		+ "' AND "
                EndIf
            ElseIf nVenctoPJ == "3" .OR. EMPTY(nVenctoPJ)
                cQuery += "SE2.E2_EMIS1  = '" + Dtos(dDataBase) + "' AND "
            EndIf

            cQuery += " E2_DESDOBR <> 'S' AND "
            cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MVABATIM,"|") 		+ " AND "
            cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)	+ " AND "
            cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)	+ " AND "
            cQuery += " SE2.E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)	+ " AND "
            cQuery += " SE2.D_E_L_E_T_ = ' ' AND "

            //Verifico a filial do SED
            If cAglImPJ == "1" .OR. Empty( cFilFwSED )
                cQuery += " SED.ED_FILIAL = '"+ xFilial("SED") + "' AND "
            ElseIf Len(aFilial) > 0
                cQuery += " SED.ED_FILIAL IN ( "
                For nLoop := 1 to Len(aFilial)
                    If nLoop == 1
                        cQuery += "'"  + aFilial[nLoop] + "' "
                    Else
                        cQuery += ",'" + aFilial[nLoop] + "'"
                    EndIf
                Next
                cQuery += ") AND "
            EndIf

            cQuery += " SE2.E2_NATUREZ = SED.ED_CODIGO AND "
            cQuery += " SED.ED_CALCIRF = 'S' AND "
            cQuery += " SED.D_E_L_E_T_ = ' ' "
            cQuery := ChangeQuery(cQuery)

            dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBIRF", .F., .T.)

            For nX := 1 to Len(aStru)
                If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
                    TCSetField('TRBIRF', aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
                Endif
            Next

            dbSelectArea("TRBIRF")
            While !(TRBIRF->(Eof()))
                //Se for inclusao, somo todos os titulos
                //Se for alteração, somo todos os titulos exceto o que esta sendo alterado.
                If (INCLUI .AND. lFinanceiro) .OR.;
                ((ALTERA .OR. !lFinanceiro) .AND.;
                SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) != TRBIRF->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) .AND.;
                EMPTY(TRBIRF->E2_FATURA) .AND. EMPTY(TRBIRF->E2_NUMLIQ))
                    If (Len(aTitBord) > 0 .AND. aScan(aTitBord,{|aArrBor| aArrBor[1] == TRBIRF->SE2_RECNO}) > 0) .OR.;
                    ((!EMPTY(cBordero) .AND. TRBIRF->E2_NUMBOR != cBordero .AND.  !EMPTY(TRBIRF->E2_BAIXA)) .OR.;
                    (!EMPTY(TRBIRF->E2_BAIXA) .AND. TRBIRF->E2_SALDO < TRBIRF->E2_VALOR))

                        nTotTit := TRBIRF->E2_VALOR + If(!lInssBx,TRBIRF->E2_INSS,0)

                        If !lCalcIssBx
                            nTotTit += TRBIRF->E2_ISS
                        EndIf

                        If lSest
                            nTotTit += TRBIRF->E2_SEST
                        EndIf

                        If lContrRet .AND. !lPccBaixa .AND. TRBIRF->(E2_PRETPIS == " " .AND. E2_PRETCOF == " " .AND. E2_PRETCSL == " ")
                            nTotTit	+= TRBIRF->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
                        EndIf

                        nVlTitBor	:= NoRound(((nTotTit * Iif(AllTrim(Str(TRBIRF->E2_MOEDA,2)) $ "01",1,RecMoeda(TRBIRF->E2_EMISSAO,TRBIRF->E2_MOEDA))) * IIF(TRBIRF->ED_PERCIRF>0,TRBIRF->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
                        nTotIRRF	+= nVlTitBor
                        nTotInss	+= If(!lInssBx,TRBIRF->E2_INSS,0)

                        //Soma os valores que deveriam ter sido retidos
                        //Retidos e os pendentes (menor que valor minimo)
                        If lVRetIrf
                            nTotRtIr += TRBIRF->E2_VRETIRF
                        Endif
                        If (lAcumIr .and. !lCalcIr) .Or. cAcmIrrf	==	"2"
                            nTotRtIr := 0
                        Endif
                    EndIf
                EndIf
                TRBIRF->(dbSkip())
            EndDo
        EndIf

        If Select("TRBIRF") > 0
            dbSelectArea("TRBIRF")
            dbCloseArea()
        Endif

        //Quando a rotina for utilizada pelo Financeiro, tenho a necessidade de calcular o IRRF do titulo presente
        //Nao ocorre com o Compras pois o mesmo já efetuou calculos
        If lFinanceiro
            If nBaseIRRF == 0
                If Type("M->E2_VALOR")=="U"
                    nTotTit += SE2->E2_VALOR
                Else
                    nTotTit += M->E2_VALOR
                EndIf
            Else
                If !lSRefSE2
                    nTotTit := nBaseIRRF
                EndIf
            EndIf

            If !lInssBx
                If Type("M->E2_INSS")=="U"
                    nTotInss += SE2->E2_INSS
                Else
                    nTotInss += M->E2_INSS
                EndIf
            Endif

            If lBaseDif.and. SED->ED_BASEIRF > 0
                nBaseSED := SED->ED_BASEIRF/100
            EndIf

            If lVRetIrf .and. nBaseIRRF == 0
                If !lSRefSE2
                    If Type("M->E2_VALOR")=="U"
                        nBaseIRRF := SE2->E2_VALOR * nBaseSED
                    Else
                        nBaseIRRF := M->E2_VALOR * nBaseSED
                    EndIf
                Else
                    nBaseIRRF := nTotTit * nBaseSED
                EndIf
            Else
                nBaseIRRF := nBaseIRRF * nBaseSED
            EndIf
        EndIf

        //Fecha arquivo temporario
        If cAglImPJ != "1" .and. lDelTrbIR .and. (UPPER(Alltrim(TCGetDb()))!="POSTGRES")
            If InTransact()
                StartJob( "DELTRBIR" , GetEnvServer() , .T. , SM0->M0_CODIGO, FWGETCODFILIAL,.T.,ThreadID(),cArqTmp,TCGetDb())
            Else
                DELTRBIR(SM0->M0_CODIGO, FWGETCODFILIAL,.F.,0,cArqTmp,TCGetDb())
            EndIf
        EndIf
        dbSelectArea("SE2")
    Else
        If lFinanceiro
            If nBaseIRRF == 0
                nTotTit := If( Type("M->E2_VALOR")=="U" , SE2->E2_VALOR , M->E2_VALOR )
            Else
                If !lSRefSE2
                    nTotTit := nBaseIRRF
                Else
                    nTotTit += nBaseIRRF
                EndIf
            EndIf

            nTotInss  := If( Type("M->E2_INSS")=="U" , If(!lInssBx,SE2->E2_INSS,0) , If(!lInssBx,M->E2_INSS,0) )

            If lBaseDif .and. SED->ED_BASEIRF > 0
                nBaseSED := SED->ED_BASEIRF / 100
            EndIf
            nBaseIRRF := nBaseIRRF * nBaseSED
        EndIf
    EndIf

    If lFinanceiro
        //Ponto de entrada para manipulacao da base de calculo.
        //Deve ser utilizado para tratamento de reducao da base por numero de dependentes
        //Retornar Base de Calculo
        IF lF50CIRFF
            nBaseIRRF := ExecBlock("F50CIRFF",.f.,.f.,nBaseIRRF)
        EndIf

        If !GetNewPar("MV_RNDIRF",.F.)
            If !lSRefSE2
                If Type("M->E2_MOEDA")=="U"
                    nValor := NoRound(((nBaseIRRF * Iif(AllTrim(Str(SE2->E2_MOEDA,2)) $ "01",1,RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
                Else
                    nValor := NoRound(((nBaseIRRF * Iif(AllTrim(Str(M->E2_MOEDA,2)) $ "01",1,RecMoeda(M->E2_EMISSAO,M->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
                EndIf
            Else
                nValor := NoRound((nBaseIRRF  * IIF(SED->ED_PERCIRF > 0, SED->ED_PERCIRF, GetMV("MV_ALIQIRF")) / 100),2)
            EndIf
        Else
            If !lSRefSE2
                If Type("M->E2_MOEDA")=="U"
                    nValor := Round(((nBaseIRRF * Iif(AllTrim(Str(SE2->E2_MOEDA,2)) $ "01",1,RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
                Else
                    nValor := Round(((nBaseIRRF * Iif(AllTrim(Str(M->E2_MOEDA,2)) $ "01",1,RecMoeda(M->E2_EMISSAO,M->E2_MOEDA))) * IIF(SED->ED_PERCIRF>0,SED->ED_PERCIRF,GetMV("MV_ALIQIRF"))/100),2)
                EndIf
            Else
                nValor := Round((nBaseIRRF * IIF(SED->ED_PERCIRF > 0, SED->ED_PERCIRF, GetMV("MV_ALIQIRF")) / 100),2)
            EndIf
        EndIf
    Else
        dbSelectArea("SE2")
        SE2->(dbGoto(nRecAtual))
        nValor := SE2->E2_IRRF
    Endif

    If nTotIRRF < GetMv("MV_VLRETIR")
        nValAcum	:= nTotIrrf
        nNotRet		:= nValor
    EndIf

    //Se verifico a retencao atraves de campo
    //Guardo o valor que deveria ser retido
    //Atualizo o valor pendente de retencao mais o IRRF do titulo
    If lVRetIrf
        If nTotIRRF < GetMv("MV_VLRETIR")
            If nTotIrrf > nValor
                nTotIrrf -= nValor
            EndIf
            nValor += nTotIrrf
        EndIf
        nTotIrrf += nValor
    Else
        nValor -= nTotIrrf  //Diminuo do valor calculado, o IRRF já retido
    EndIf
	
    //Controle de retencao anterior no mesmo periodo
    lIrfRetAnt := IIF(nTotIrrf > 0, .T., .F.)

    //No novo calculo de IR pela baixa, nao se aplica valor minimo de retencao quando IR
    lAplMinIr := IIF(lIRPFBaixa, .F., lAplMinIr)

    // Verifica se o fornecedor trata o valor minimo de retencao.- FINANCEIRO
    If (lFinanceiro .and. lAplMinIR .And. (nValor <= GetMv("MV_VLRETIR") .and. !lIrfRetAnt)) .OR. nValor < 0
        nValor := 0
    EndIf

    If lRotBorder
        aAdd(aTitBord,{SE2->(Recno()),nBaseIRRF,nValor,nNotRet,nValAcum,cBordero})
    EndIf

    RestArea(aArea)
    RestArea(aAreaSED)
    RestArea(aAreaSE2)
    RestArea(aAreaSE5)

Return(nValor)



//-------------------------------------------------------------------
/*/{Protheus.doc} FA050Irf

Calcula Irf em reais

(VERIFICAR POSSIVEL RETIRADA - NÃO É CHAMADA POR NINGUÉM)

@author Antonio Maniero Jr.
@since  11/04/94
@version 12  
/*/
//-------------------------------------------------------------------
Function FA050Irf()

    Local lAplicaTP := .T.
    Local nBaseIrrf := M->E2_VALOR

    //-- Optante pelo simples
    Local lSimples := __lLocBRA .and. SA2->A2_CALCIRF == "3"

    //-- Empresa Individual
    Local lEmprInd := __lLocBRA .and. SA2->A2_CALCIRF == "4"

    // Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
    Local lAplMinIR := .F.

    //Base Impostos diferenciada
    Local lBaseImp := F050BSIMP(2)

    //Valor retido
    Local lVretIrf := .T.
    // ignora recalculo de impostos  | Usado pelo TMS com Operadora de Frota
    Local lRefImp	:= SuperGetMv('MV_REFIMP',,.F.)
    Local lTmsOper	:= SuperGetMv('MV_VSREPOM',,'1')  == '2' .And. SuperGetMv('MV_TMSOPDG',,'1')  == '2'
    Local aCalcIRPF := {}
    Local lF050CIRF := ExistBlock("F050CIRF")

    If lRefImp  .And. lTmsOper .And. (FwIsInCallStack('TMSQUITAC') .Or. FwIsInCallStack('TMA250SE2'))
        lBaseImp := .F.
    EndIf

    M->E2_IRRF	:= 0
    nOldIrr		:= 0

    If SED->ED_CALCIRF == "S" .And. M->E2_MULTNAT != "1"

        If __lF050ATP
            lAplicaTP := ExecBlock("F050ATP",.F.,.F.)
        Endif

        //Base Impostos diferenciada
        If lBaseImp .and. M->E2_BASEIRF > 0
            nBaseIrrf   := M->E2_BASEIRF
        Endif

        IF (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIrProg == "1")) .AND. lAplicaTP .AND. !lEmprInd
            If lIRPFBaixa
                If M->E2_TIPO $ MVPAGANT
                    // Busca base de cálculo para o  IRPF caso não tenha sido calculada
                    aCalcIRPF := F241BsIRPF(,"SE2",M->E2_VALOR,,M->E2_FORNECE,M->E2_LOJA)

                    //³Calcula IRPF e deduz os valores retidos anteriormente³
                    M->E2_IRRF := Fa050TabIR(aCalcIRPF[1]) - aCalcIRPF[2]
                    M->E2_IRRF := IIF(M->E2_IRRF <= GetMv("MV_VLRETIR",,0),0,M->E2_IRRF)

                    If M->E2_TIPO $ MVPAGANT .And. lVretIrf
                        M->E2_VRETIRF := M->E2_IRRF
                    EndIf
                    
                    FwFreeArray(aCalcIRPF)
                EndIf
            Else
                M->E2_IRRF := FCalcIr(nBaseIrrf,"F",.T.)
            EndIf
        ElseIf !lSimples
            If lIRPFBaixa
                M->E2_IRRF := FCalcIr(nBaseIrrf,"J",.T.,.T.)
                If M->E2_TIPO $ MVPAGANT .And. lVretIrf
                    M->E2_VRETIRF := M->E2_IRRF
                EndIf
            Else
                M->E2_IRRF := FCalcIr(nBaseIrrf,"J",.T.)
            EndIf
        EndiF
        IF lF050CIRF
            M->E2_IRRF := ExecBlock("F050CIRF",.f.,.f.,nBaseIrrf)
        Endif
    EndIf

    // Verifica se o fornecedor trata o valor minimo de retencao.
    // 1 - Não considera  2 - Considera o parâmetro MV_VLRETIR
    If __lLocBRA .and. SA2->A2_MINIRF == "2"
        lAplMinIR := .T.
    Endif

    If !(lIRPFBaixa .And. M->E2_TIPO $ MVPAGANT) .And. If(lAplMinIR,(M->E2_IRRF <= GetMv("MV_VLRETIR")),.F.)
        nIrrfAnt := M->E2_IRRF
        M->E2_IRRF := 0
    EndIf

    lRefresh:=.t.

Return .t.

//-------------------------------------------------------
/*/{Protheus.doc} Fa050MultNat
	Recalcular o valor do titulo e zerar os impostos

@author Claudio D. de Souza
@since 16/08/2001
@version P12
/*/
//-------------------------------------------------------
Function Fa050MultNat()

    //Verifico se permite rateios de desdobramento no mesmo titulo
	Local lRatDsd := IIF(GetMv("MV_RATDESD",,"2") == "1", .T., .F.)

    // Retirar X3_WHEN dos campos - E2_ISS, E2_IRRF, E2_INSS
    // Passa a ser permitido rateio de multiplas naturezas usando a pergunta 06
    // Rateio de Liquido/Bruto
    If !MV_MULNATP .And. M->E2_MULTNAT == "1"
        HELP(' ',1,'MULNATP' ,,STR0015,2,0,,,,,,{STR0016})	//"Parâmetro MV_MULNATP está desativado. Com isto este campo não terá efeito para a geração do rateio multinatureza."###"Para efetuar rateios multinatureza  é necessário ativar o parâmetro MV_MULNATP."        
		M->E2_MULTNAT := "2"
    ElseIf !lRatDsd
        M->E2_DESDOBR := "N"
    EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} F050CvtMoe
Ajusta valor do titulo em reais (gatilho campo E2_TXMOEDA)

@author Totvs SA
@since  26/07/10
/*/
//-------------------------------------------------------------------
Function F050CvtMoe()

    Local nValor := 0
    
	lAltTxMoeda	:= .F.

    If M->E2_MOEDA > 1 .And. nOldTxMoeda != M->E2_TXMOEDA
        lAltTxMoeda := .T.
        //recalcula conversao de moeda conforme taxa	
        Fa050Nat2()
        FA050VALOR()
    EndIf

    If ( cPaisLoc == "CHI" )
        nValor := Round( xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA), MsDecimais(1) )
    Else
        nValor := Round(NoRound(xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,3,M->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
    Endif

    nOldTxMoeda := M->E2_TXMOEDA
    lAltTxMoeda := .F.

Return nValor

//----------------------------------------------------------------------------------
/*/{Protheus.doc} FIN050RET
Função chamada do gatilho do fornecedor para gatilhar o campo de retenão do inss 
(E2_RETINS)

@author TOTVS S/A
@since 25/06/2015
@version P12.1.6
@return Retorno Caracter com o conteudo que ira ser gatilhado
/*/
//----------------------------------------------------------------------------------
Function FIN050RET

    Local cRet  := ""
    Local aArea := GetArea()
    Local cTpFor := GetAdvFval("SA2","A2_TIPO",xFilial("SA2")+M->E2_FORNECE+M->E2_LOJA,1,"")

    //Tipo do fornecedor
    IF ( cTpFor == "J" )
        cRet := SuperGetmv("MV_RETINPJ")
    Else
        cRet:= SuperGetmv("MV_RETINPF")
    EndIF

    RestArea(aArea)

Return cRet


//----------------------------------------------------------------------------------
/*/{Protheus.doc} F050VlAlt
Validação de permissão de alterar o valor dos impostos

@author Mauricio Pequim Jr
@since 15/05/2019
@version P12
/*/
//----------------------------------------------------------------------------------
Function F050VlAlt()

    Local lRet := .T.

	If Type("lAltera")=="U"
		lAltera := .F.
	EndIf

	If lAltera
        // Caso tenha contabilizado, nao posso alterar valores no titulo. 
        IF SE2->E2_LA == "S"
            Help(" ",1,"NAOVALOR")
            lRet	 := .F.
        // Caso seja do tipo adiantamento, nao posso alterar valores no titulo. 
		ElseIf SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
            Help( " ",1,"FA040ADTO")
            lRet	 := .F.
        Endif
    Endif

    If lRet .and. M->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG .and. GetMv("MV_IMPADT") != "S"
        Help( " ",1,"FA040ADTO")
        lRet := .F.
    Endif
    
    // Caso seja do tipo imposto, nao posso alterar valores no titulo. 
	If lRet .and. M->E2_TIPO $ MVTAXA+"|"+MVINSS+"|"+MVISS+"|"+MVTXA+"|CID|INA|SES"
		Help( " ",1,"F050IMPOST")
		lRet := .F.
	Endif

Return lRet

//-------------------------------------------------------
/*/{Protheus.doc} Fa050Perg5
Validação pergunta 5 para não permitir gerar (SX1 FIN050)
Cheque p/Anticipo para o Equador, funcionalidade é usada
No Controle de Cheques.

@author José Lucas

@since 20/08/10
@version P12
/*/
//-------------------------------------------------------
Function Fa050Perg5()
    Local aArea := GetArea()
    Local lRet  := .T.

    If cPaisLoc == "EQU"
        If mv_par05 == 1  //Gera Cheque para Adiantamento (mv_par05 == Sim)
            MsgAlert("Los cheques de anticipo son generados solamente en  el controle de cheques.","Atención")
            lRet := .F.
        EndIf
    EndIf

    RestArea(aArea)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050GrvRtr
Trata Ajuste na Alteração de Titulo que Reteve os Impostos PCC
juntamente com os seus, e, agora, sofreu alteração na base de calculo
Alteração a partir do Titulo Retentor

@author Totvs SA
@since  05/11/09
/*/
//-------------------------------------------------------------------
Function F050GrvRtr()

    Local aArea 		:= GetArea()
    Local aAreaSE2 		:= SE2->(GetArea())
    Local aAreaSFQ 		:= SFQ->(GetArea())
    Local aDados		:= {}
    Local lRet			:= .T.
    Local lHelpOld
    Local lErroOld
    Local dDataFim  	:= E2_EMISSAO

    //Titulo Retentor
    Local cFil_Rtr      := E2_FILIAL
    Local cPre_Rtr      := E2_PREFIXO
    Local cNum_Rtr     	:= E2_NUM
    Local cPar_Rtr     	:= E2_PARCELA
    Local cTip_Rtr     	:= E2_TIPO
    Local cFor_Rtr     	:= E2_FORNECE
    Local cLoj_Rtr      := E2_LOJA
    Local nVlr_Rtr   	:= 0
    Local nSdo_Rtr   	:= 0
    Local nPIS_Rtr   	:= 0
    Local nCOF_Rtr   	:= 0
    Local nCSL_Rtr		:= 0
    Local nVRPIS_Rtr 	:= 0
    Local nVRCOF_Rtr 	:= 0
    Local nVRCSL_Rtr	:= 0
    Local cTitPai_Rtr   := E2_TITPAI
    Local nPosForn		:= 0
    Local nPosLoja		:= 0
    Local nPosNat		:= 0
    Local nPosPis		:= 0
    Local nPosCsll		:= 0
    Local nPosCof		:= 0
    Local lCalcIssBx    := IIF(__lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

    Local cMV_PISNAT    := AllTrim(GetMv("MV_PISNAT"))
    Local cMV_COFINS    := AllTrim(GetMv("MV_COFINS"))
    Local cMV_CSLL      := AllTrim(GetMv("MV_CSLL"))

    dDataFim  := LastDay( ddatabase )

    If Type("lMsHelpAuto") == "L"
        lHelpOld 	:= lMsHelpAuto
        lMsHelpAuto := .F. // Nao exibe erro
    Else
        Private lMsHelpAuto := .F.
    EndIf

    If Type("lMsErroAuto") == "L"
        lErroOld := lMsErroAuto
    Else
        Private lMsErroAuto := .F.
    EndIf

    //-- Salva dados do Titulo Retentor Antes de Excluí-lo
    cFil_Rtr    	:= SE2->E2_FILIAL
    cPre_Rtr    	:= SE2->E2_PREFIXO
    cNum_Rtr    	:= SE2->E2_NUM
    cPar_Rtr    	:= SE2->E2_PARCELA
    cTip_Rtr    	:= SE2->E2_TIPO
    cFor_Rtr    	:= SE2->E2_FORNECE
    cLoj_Rtr    	:= SE2->E2_LOJA
    nVlr_Rtr   		:= SE2->E2_VALOR
    nSdo_Rtr   		:= SE2->E2_SALDO
    nPIS_Rtr   		:= SE2->E2_PIS
    nCOF_Rtr   		:= SE2->E2_COFINS
    nCSL_Rtr		:= SE2->E2_CSLL
    nVRPIS_Rtr 		:= SE2->E2_VRETPIS
    nVRCOF_Rtr 		:= SE2->E2_VRETCOF
    nVRCSL_Rtr		:= SE2->E2_VRETCSL
    cTitPai_Rtr 	:= Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

    M->E2_VENCREA 		:= SE2->E2_VENCREA
    M->E2_PIS 			:= SE2->E2_PIS
    M->E2_COFINS 		:= SE2->E2_COFINS
    M->E2_CSLL 			:= SE2->E2_CSLL
    M->E2_APLVLMN 		:=	SE2->E2_APLVLMN
    M->E2_TIPO  		:=	SE2->E2_TIPO
    M->E2_FORNECE 		:=	SE2->E2_FORNECE
    M->E2_LOJA 			:=	SE2->E2_LOJA
    M->E2_NATUREZ 		:=	SE2->E2_NATUREZ
    M->E2_VLCRUZ 		:=	SE2->E2_VLCRUZ
    M->E2_MOEDA 		:=	SE2->E2_MOEDA
    M->E2_EMISSAO 		:=	SE2->E2_EMISSAO
    M->E2_TXMOEDA		:=	SE2->E2_TXMOEDA

    //-- Monta Array para ExecAuto do Titulo Retentor
    aEval(SE2->(DbStruct()), {|x| aAdd(aDados,{x[1],SE2->&(x[1]),NIL})})

    nPosForn := aScan(aDados,{|x| x[1]== "E2_FORNECE"})
    nPosLoja := aScan(aDados,{|x| x[1]== "E2_LOJA"})
    nPosNat	 := aScan(aDados,{|x| x[1]== "E2_NATUREZ"})
    nPosPis	 := aScan(aDados,{|x| x[1]== "E2_PIS"})
    nPosCsll := aScan(aDados,{|x| x[1]== "E2_CSLL"})
    nPosCof	 := aScan(aDados,{|x| x[1]== "E2_COFINS"})

    If !(SE2->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
    (SE2->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"))

        If SE2->E2_TIPO $ MVPAGANT
            If __lLocBRA .And. !Empty(SE2->E2_BASEPIS)
                nBasePCC := SE2->E2_BASEPIS
            Else
                nBasePCC := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
            Endif
        Else
            nBasePCC := nVlr_Rtr + SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + SE2->E2_INSS + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
        Endif
        SA2->(dbSeek(xFilial("SA2") + aDados[nPosForn,2] + aDados[nPosLoja,2]))
        SED->(dbSeek(xFilial("SED") + aDados[nPosNat,2]))
        If !SE2->E2_TIPO $ MVPAGANT
            //PIS
            //³ se natureza pede calculo do PIS      ³
            If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
                If ! GetNewPar("MV_RNDPIS",.F.)
                    aDados[nPosPis,2] 	:= NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
                Else
                    aDados[nPosPis,2] 	:= Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
                Endif
            Else
                aDados[nPosPis,2] 		:= 0
                nOldPis	 			:= 0
            EndIf
            // COFINS
            //³ se natureza pede calculo do COFINS	  ³
            If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
                If ! GetNewPar("MV_RNDCOF",.F.)
                    aDados[nPosCof,2] 	:= NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
                Else
                    aDados[nPosCof,2] 	:= Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
                EndIf
            Else
                aDados[nPosCof,2] 		:= 0
                nOldCofins	 		:= 0
            EndIf
            // CSLL
            //³ se natureza pede calculo do CSLL ³
            If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
                If ! GetNewPar("MV_RNDCSL",.F.)
                    aDados[nPosCsll,2] 	:= NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
                Else
                    aDados[nPosCsll,2] 	:= Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
                EndIf
            Else
                aDados[nPosCsll,2] 		:= 0
                nOldCsll	  			:= 0
            Endif
        EndIf
    EndIf
    //Ajusta Valor pcc do titulo retentor
    If !(SE2->E2_TIPO $ MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA+"/"+"SES"+"/"+"INA")
        RecLock("SE2")
        Replace E2_PIS 	With aDados[nPosPis,2]
        Replace E2_COFINS With aDados[nPosCof,2]
        Replace E2_CSLL 	With aDados[nPosCsll,2]
        MsUnlock()
        FKCOMMIT()
    Else
        FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
        SE2->(RecLock("SE2"))
        SE2->(dbDelete())
        SE2->(MsUnlock())
    EndIf
    //³ Ajusta tambem os registros de impostos-Pcc ³
    dbSelectArea("SE2")
    SE2->(DbSetOrder(1))
    dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
    While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == ;
    cFil_Rtr+cPre_Rtr+cNum_Rtr
        If AllTrim(E2_NATUREZ) == cMV_PISNAT .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
            RecLock("SE2")
            Replace E2_VALOR 	With nPIS_Rtr
            Replace E2_SALDO 	With nPIS_Rtr
            Replace E2_TITPAI   With cTitPai_Rtr
            Replace E2_ORIGEM	With "FINA050"
            MsUnlock()
            FKCOMMIT()
        EndIf
        If AllTrim(E2_NATUREZ) == cMV_COFINS .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
            RecLock("SE2")
            Replace E2_VALOR 	With nCOF_Rtr
            Replace E2_SALDO 	With nCOF_Rtr
            Replace E2_TITPAI   With cTitPai_Rtr
            Replace E2_ORIGEM	With "FINA050"
            MsUnlock()
            FKCOMMIT()
        EndIf
        If AllTrim(E2_NATUREZ) == cMV_CSLL .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
            RecLock("SE2")
            Replace E2_VALOR 	With nCSL_Rtr
            Replace E2_SALDO 	With nCSL_Rtr
            Replace E2_TITPAI   With cTitPai_Rtr
            Replace E2_ORIGEM	With "FINA050"
            MsUnlock()
            FKCOMMIT()
        EndIf
        dbSkip()
    Enddo

    If ValType(lHelpOld ) == "L"
        lMsHelpAuto := lHelpOld
    EndIf
    If ValType(lErroOld) == "L"
        lMsErroAuto	:= lErroOld
    EndIf

    RestArea(aAreaSE2)
    RestArea(aAreaSFQ)
    RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050GrRtr2
Trata Ajuste na Alteração de: 
Titulo que Reteve os Impostos PCC de outro juntamente com
os seus, e, agora, sofreu alteração na base de calculo.
Alteração do periodo de referencia do Titulo Retentor

@author Totvs SA
@since  05/11/09
/*/
//-------------------------------------------------------------------
Function F050GrRtr2(lAtuPCCRet)

    Local aArea 		:= GetArea()
    Local aAreaSE2 		:= SE2->(GetArea())
    Local aAreaSFQ      := SFQ->(GetArea())
    Local lRet			:= .T.
    Local lHelpOld
    Local lErroOld
    Local dDataFim 		:= E2_EMISSAO
    Local dDataIni 		:= E2_EMISSAO
    //Titulo Retido
    Local nRecRtd  		:= 0
    Local cFil_Rtd     	:= E2_FILIAL
    Local cPre_Rtd     	:= E2_PREFIXO
    Local cNum_Rtd     	:= E2_NUM
    Local cPar_Rtd     	:= E2_PARCELA
    Local nVRPIS_Rtd	:= 0
    Local nVRCOF_Rtd	:= 0
    Local nVRCSL_Rtd    := 0

    //Titulo Retentor
    Local nRecRtR   	:= SE2->(RECNO())
    Local cFil_Rtr      := E2_FILIAL
    Local cPre_Rtr      := E2_PREFIXO
    Local cNum_Rtr     	:= E2_NUM
    Local cPar_Rtr     	:= E2_PARCELA
    Local nVlr_Rtr_Tot	:= 0
    Local cTip_Rtr     	:= E2_TIPO
    Local cFor_Rtr     	:= E2_FORNECE
    Local cLoj_Rtr      := E2_LOJA
    Local nVlr_Rtr   	:= 0
    Local nSdo_Rtr   	:= 0
    Local nPIS_Rtr   	:= 0
    Local nCOF_Rtr   	:= 0
    Local nCSL_Rtr		:= 0
    Local nVRPIS_Rtr 	:= 0
    Local nVRCOF_Rtr 	:= 0
    Local nVRCSL_Rtr	:= 0
    Local cTitPai_Rtr   := E2_TITPAI
    Local nVlMinImp 	:= GetNewPar("MV_VL10925",5000)

    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"

    /*
    Chamado TRGZT8
    Os impostos do titulo retentor nao devem sofre alteracoes, quando ele ou os titulos que reteve forem alterados.
    Este parametro define se o titulo retentor deve ter os impostos alterados. */
    Default lAtuPCCRet	:= .T.

    dDataFim  := LastDay( SE2->E2_VENCREA  )
    dDataIni  := FirstDay( SE2->E2_VENCREA  )

    If Type("lMsHelpAuto") == "L"
        lHelpOld 	:= lMsHelpAuto
        lMsHelpAuto := .F. // Nao exibe erro
    Else
        Private lMsHelpAuto := .F.
    EndIf

    If Type("lMsErroAuto") == "L"
        lErroOld := lMsErroAuto
    Else
        Private lMsErroAuto := .F.
    EndIf

    cPREFORI    :=	SE2->E2_PREFIXO
    nNUMORI     :=	SE2->E2_NUM
    nPARCORI  	:=	SE2->E2_PARCELA
    cTIPOORI  	:=	SE2->E2_TIPO
    nCFORI    	:=	SE2->E2_FORNECE
    nLOJAORI 	:=	SE2->E2_LOJA
    //-- Salva dados do Titulo Retentor
    //-- Titulo Retentor
    nRecRtR   	:=	SE2->(RECNO())
    cFil_Rtr    := SE2->E2_FILIAL
    cPre_Rtr    := SE2->E2_PREFIXO
    cNum_Rtr    := SE2->E2_NUM
    cPar_Rtr    := SE2->E2_PARCELA
    cTip_Rtr    := SE2->E2_TIPO
    cFor_Rtr    := SE2->E2_FORNECE
    cLoj_Rtr    := SE2->E2_LOJA
    nVlr_Rtr   	:= SE2->E2_VALOR
    nSdo_Rtr   	:= SE2->E2_SALDO
    nPIS_Rtr   	:= SE2->E2_PIS
    nCOF_Rtr   	:= SE2->E2_COFINS
    nCSL_Rtr	:= SE2->E2_CSLL
    nVRPIS_Rtr 	:= SE2->E2_VRETPIS
    nVRCOF_Rtr 	:= SE2->E2_VRETCOF
    nVRCSL_Rtr	:= SE2->E2_VRETCSL
    cTitPai_Rtr := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
    //-- Prepara campos para a função: F050TotMes
    M->E2_VENCREA   := SE2->E2_VENCREA
    M->E2_PIS       := SE2->E2_PIS
    M->E2_COFINS 	:= SE2->E2_COFINS
    M->E2_CSLL 		:= SE2->E2_CSLL
    M->E2_APLVLMN 	:= SE2->E2_APLVLMN
    M->E2_TIPO  	:= SE2->E2_TIPO
    M->E2_FORNECE 	:= SE2->E2_FORNECE
    M->E2_LOJA 		:= SE2->E2_LOJA
    M->E2_NATUREZ 	:= SE2->E2_NATUREZ
    M->E2_VLCRUZ 	:= SE2->E2_VLCRUZ
    M->E2_MOEDA 	:= SE2->E2_MOEDA
    M->E2_EMISSAO 	:= SE2->E2_EMISSAO
    M->E2_TXMOEDA	:= SE2->E2_TXMOEDA
    ///Totaliza Titulos do Fornecedor Data de referencia é a do Retentor
    aDadosRet 		:= F050TotMes(M->E2_VENCREA)
    nVlr_Rtr_Tot 	:= aDadosRet[1] // + (SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL)

    SFQ->(dbSetOrder(1))
    ///Pesquisa Todos Titulos Retidos neste Titulo Retentor, para o fornecedor e periodo
    If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
        While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
        SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI
            cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
            //-- Localiza Titulos Retidos
            SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
            If		SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))
                //Salva chaves de Ultimo retido e totais de valores retidos
                nRecRtd   	:= SE2->(RECNO())
                cFil_Rtd    := SE2->E2_FILIAL
                cPre_Rtd    := SE2->E2_PREFIXO
                cNum_Rtd    := SE2->E2_NUM
                cPar_Rtd    := SE2->E2_PARCELA
                nVRPIS_Rtd 	+= SE2->E2_PIS
                nVRCOF_Rtd 	+= SE2->E2_COFINS
                nVRCSL_Rtd	+= SE2->E2_CSLL

                //Atualiza Situação de Retenção do titulo Retido
                RecLock("SE2")
                Replace E2_PRETPIS 	With '1'
                Replace E2_PRETCOF 	With '1'
                Replace E2_PRETCSL 	With '1'
                MsUnlock()
                FKCOMMIT()

                //Exclui Relacionamento do titulo Retido com seu Retentor
                RecLock("SFQ")
                dbDelete()
                MsUnlock()
                FKCOMMIT()
            EndIf
            SFQ->(dbSkip())
        EndDo
    EndIf

    //-- Ajusta Titulo Alterado (periodo)
    SE2->(dbGoto(nRecRtr))
    If lAtuPCCRet
        If !(lAltera .And. !lPCCBaixa .And. SE2->E2_VALOR == SE2->E2_BASEPIS - SE2->(E2_VRETPIS + E2_VRETCOF + SE2->E2_VRETCSL))
            SE2->E2_VALOR	+= SE2->(E2_VRETPIS + E2_VRETCOF + SE2->E2_VRETCSL)
            SE2->E2_SALDO	+= SE2->(E2_VRETPIS + E2_VRETCOF + SE2->E2_VRETCSL)
        EndIf

        RecLock("SE2")

        If nVlr_Rtr_Tot > nVlMinImp
            //Pesquisar titulos pendentes de retenção para Fornecedor periodo(E2_PRETPIS ="1")
            //se encontrar gravar relacionamento(SFQ) entre o pendente e este
            F050GrvSFQ()
            Replace E2_VALOR	With SE2->(E2_VALOR - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)
            Replace E2_SALDO	With SE2->(E2_SALDO - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)
            Replace E2_VLCRUZ 	With IF(SE2->E2_MOEDA == 1,SE2->E2_VALOR,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1)))
            Replace E2_VRETPIS 	With SE2->E2_VRETPIS
            Replace E2_VRETCOF 	With SE2->E2_VRETCOF
            Replace E2_VRETCSL 	With SE2->E2_VRETCSL
            Replace E2_PRETPIS 	With ' '
            Replace E2_PRETCOF 	With ' '
            Replace E2_PRETCSL 	With ' '
            // Exclui Impostos PCC periodo anterior
            F050DelPCC()

            // Grava Impostos PCC
            F050TXPCC()
        Else
            Replace E2_VALOR	With SE2->E2_VALOR
            Replace E2_SALDO	With SE2->E2_SALDO
            Replace E2_VRETPIS 	With 0
            Replace E2_VRETCOF 	With 0
            Replace E2_VRETCSL 	With 0
            Replace E2_PRETPIS 	With '1'
            Replace E2_PRETCOF 	With '1'
            Replace E2_PRETCSL 	With '1'
        Endif

        ///Totaliza Titulos do Fornecedor Data de referencia é a Anterior a Alteração do Retentor
        aDadosRet 		:= F050TotMes(dOldVencRe)
        nVlr_Rtr_Tot 	:= aDadosRet[1]
        // Caso o valor total dos titulos remanescentes seja superior ao minimo, gerar novo retentor
        If nVlr_Rtr_Tot > nVlMinImp
            If nRecRtd		<>	0
                SE2->(dbGoto(nRecRtd))
                Replace E2_VALOR 	With SE2->(E2_VALOR - nVRPIS_Rtd - nVRCOF_Rtd - nVRCSL_Rtd)
                Replace E2_SALDO 	With SE2->(E2_SALDO - nVRPIS_Rtd - nVRCOF_Rtd - nVRCSL_Rtd)
                Replace E2_VRETPIS 	With nVRPIS_Rtd
                Replace E2_VRETCOF 	With nVRCOF_Rtd
                Replace E2_VRETCSL 	With nVRCSL_Rtd
                Replace E2_PRETPIS 	With ' '
                Replace E2_PRETCOF 	With ' '
                Replace E2_PRETCSL 	With ' '

                //Pesquisar titulos pendentes de retenção para Fornecedor periodo(E2_PRETPIS ="1")
                //se encontrar gravar relacionamento(SFQ) entre o pendente e este
                If F050GrvSFQ()
                    // Exclui Impostos PCC periodo anterior
                    F050DelPCC()
                    // Grava Impostos PCC
                    F050TXPCC()
                Endif
            EndIf
        Else
            //Pesquisa titulos Retidos no periodo anterior a alteração, altera a situação para pendente de rentenção e exclui os impostos pcc respectivos
            F050AltPCC()
        EndIf
        MsUnlock()
        FKCOMMIT()
    Endif

    If ValType(lHelpOld ) == "L"
        lMsHelpAuto := lHelpOld
    EndIf
    If ValType(lErroOld) == "L"
        lMsErroAuto	:= lErroOld
    EndIf

    RestArea(aAreaSE2)
    RestArea(aAreaSFQ)
    RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050AltRtd
Trata Ajuste na Alteração de Titulo teve seus Impostos PCC
retidos em outro, e, agora, sofreu alteração na base de calculo. 
Alteração a partir do Titulo Retido

@author Totvs SA
@since  05/11/09
/*/
//-------------------------------------------------------------------
Function F050AltRtd()

    Local aArea 	    := GetArea()
    Local aAreaSE2   	:= SE2->(GetArea())
    Local aAreaSFQ   	:= SFQ->(GetArea())
    Local aDados	    := {}
    Local lRet		    := .T.
    Local lHelpOld
    Local lErroOld
    Local dDataFim  	:= E2_EMISSAO
    Local dDataIni		:= E2_EMISSAO

    //Titulos Retidos
    Local nRecRtd   	:= SE2->(RECNO())
    Local cFil_Rtd      := E2_FILIAL
    Local cPre_Rtd      := E2_PREFIXO
    Local cNum_Rtd      := E2_NUM
    Local cPar_Rtd     	:= E2_PARCELA
    Local nVlr_Rtd_Tot	:= 0
    Local nVlr_Rtd   	:= 0
    Local nPIS_Rtd 		:= 0
    Local nCOF_Rtd		:= 0
    Local nCSL_Rtd  	:= 0
    //Titulo Retentor
    Local cFil_Rtr      := E2_FILIAL
    Local cPre_Rtr      := E2_PREFIXO
    Local cNum_Rtr      := E2_NUM
    Local cPar_Rtr   	:= E2_PARCELA
    Local nVlr_Rtr_Tot	:= 0
    Local cTip_Rtr     	:= E2_TIPO
    Local cFor_Rtr     	:= E2_FORNECE
    Local cLoj_Rtr      := E2_LOJA
    Local nVlr_Rtr   	:= 0
    Local nSdo_Rtr   	:= 0
    Local nPIS_Rtr   	:= 0
    Local nCOF_Rtr   	:= 0
    Local nCSL_Rtr		:= 0
    Local nVRPIS_Rtr 	:= 0
    Local nVRCOF_Rtr 	:= 0
    Local nVRCSL_Rtr	:= 0
    Local cTitPai_Rtr   := E2_TITPAI
    Local nVlMinImp 	:= GetNewPar("MV_VL10925",5000)
    Local lCalcIssBx    := IIF(__lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

    Local cMV_PISNAT    := AllTrim(GetMv("MV_PISNAT"))
    Local cMV_COFINS    := AllTrim(GetMv("MV_COFINS"))
    Local cMV_CSLL      := AllTrim(GetMv("MV_CSLL"))

    dDataFim  := LastDay( SE2->E2_VENCREA  )
    dDataIni  := FirstDay( SE2->E2_VENCREA  )

    If Type("lMsHelpAuto") == "L"
        lHelpOld 	:= lMsHelpAuto
        lMsHelpAuto := .F. // Nao exibe erro
    Else
        Private lMsHelpAuto := .F.
    EndIf

    If Type("lMsErroAuto") == "L"
        lErroOld := lMsErroAuto
    Else
        Private lMsErroAuto := .F.
    EndIf
    //-- Prepara campos para a função: F050TotMes
    M->E2_VENCREA 		:= SE2->E2_VENCREA
    M->E2_PIS 			:= SE2->E2_PIS
    M->E2_COFINS 		:= SE2->E2_COFINS
    M->E2_CSLL 			:= SE2->E2_CSLL
    M->E2_APLVLMN 		:= SE2->E2_APLVLMN
    M->E2_TIPO  		:= SE2->E2_TIPO
    M->E2_FORNECE 		:= SE2->E2_FORNECE
    M->E2_LOJA 			:= SE2->E2_LOJA
    M->E2_NATUREZ 		:= SE2->E2_NATUREZ
    M->E2_VLCRUZ 		:= SE2->E2_VLCRUZ
    M->E2_MOEDA 		:= SE2->E2_MOEDA
    M->E2_EMISSAO 		:= SE2->E2_EMISSAO
    M->E2_TXMOEDA		:= SE2->E2_TXMOEDA
    ///Totaliza Titulos do Fornecedor Data de referencia é a do retido
    aDadosRet 			:= F050TotMes(M->E2_VENCREA)
    nVlr_Rtd_Tot 		:= aDadosRet[1]

    SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
    If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
        nRecRtd   :=	SE2->(RECNO())
        cPREFORI  :=	SFQ->FQ_PREFORI
        nNUMORI   :=	SFQ->FQ_NUMORI
        nPARCORI  :=	SFQ->FQ_PARCORI
        cTIPOORI  :=	SFQ->FQ_TIPOORI
        nCFORI    :=	SFQ->FQ_CFORI
        nLOJAORI  :=	SFQ->FQ_LOJAORI
        //-- Localiza Tit Retentor
        SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
        If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))
            SFQ->(dbSetOrder(1))
            SE2->E2_PREFIXO	:= cPREFORI
            SE2->E2_NUM		:=	nNUMORI
            SE2->E2_PARCELA	:=	nPARCORI
            SE2->E2_TIPO	:=	cTIPOORI
            SE2->E2_FORNECE	:=	nCFORI
            SE2->E2_LOJA	:=	nLOJAORI
            //-- Prepara campos para a função: F050TotMes
            M->E2_VENCREA 	:= SE2->E2_VENCREA
            M->E2_PIS 		:= SE2->E2_PIS
            M->E2_COFINS 	:= SE2->E2_COFINS
            M->E2_CSLL 		:= SE2->E2_CSLL
            M->E2_APLVLMN 	:=	SE2->E2_APLVLMN
            M->E2_TIPO  	:=	SE2->E2_TIPO
            M->E2_FORNECE 	:=	SE2->E2_FORNECE
            M->E2_LOJA 		:=	SE2->E2_LOJA
            M->E2_NATUREZ 	:=	SE2->E2_NATUREZ
            M->E2_VLCRUZ 	:=	SE2->E2_VLCRUZ
            M->E2_MOEDA 	:=	SE2->E2_MOEDA
            M->E2_EMISSAO 	:=	SE2->E2_EMISSAO
            M->E2_TXMOEDA	:=	SE2->E2_TXMOEDA
            ///Totaliza Titulos do Fornecedor Data de referencia é a do retentor
            aDadosRet 		:= F050TotMes(M->E2_VENCREA)
            nVlr_Rtr_Tot 	:= aDadosRet[1]

            ///Pesquisa Todos Titulos Retidos neste Titulos Retentor, para o fornecedor e periodo
            If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
                RecRtR   :=	SE2->(RECNO())
                While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
                    SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI

                    cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
                    //-- Localiza Titulos Retidos
                    SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
                    If 	SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))
                        If nRecRtd == SE2->(RECNO())
                            cFil_Rtd := SE2->E2_FILIAL
                            cPre_Rtd := SE2->E2_PREFIXO
                            cNum_Rtd := SE2->E2_NUM
                            cPar_Rtd := SE2->E2_PARCELA
                            nVlr_Rtd += SE2->E2_VALOR + SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL
                            nPIS_Rtd += SE2->E2_PIS
                            nCOF_Rtd += SE2->E2_COFINS
                            nCSL_Rtd += SE2->E2_CSLL
                        
                        ElseIf (SE2->E2_PRETPIS == '2')
                            nVlr_Rtd += SE2->E2_VALOR
                            nPIS_Rtd += SE2->E2_PIS
                            nCOF_Rtd += SE2->E2_COFINS
                            nCSL_Rtd += SE2->E2_CSLL
                        EndIf

                        If nVlr_Rtr_Tot <= 	nVlMinImp
                            //Atualiza Situação de Retenção do titulo Retido
                            RecLock("SE2")
                            Replace E2_PRETPIS 	With '1'
                            Replace E2_PRETCOF 	With '1'
                            Replace E2_PRETCSL 	With '1'
                            MsUnlock()
                            FKCOMMIT()
                            //Exclui Relacionamento do titulo Retido com seu Retentor
                            RecLock("SFQ")
                            dbDelete()
                            MsUnlock()
                            FKCOMMIT()
                        EndIf
                        
                        If nVlr_Rtr_Tot > nVlMinImp
                            If	nRecRtd == SE2->(RECNO())
                                //Atualiza Situação de Retenção do titulo Retido
                                RecLock("SE2")
                                Replace E2_VALOR 	With SE2->(E2_VALOR + E2_VRETPIS + 	E2_VRETCOF + E2_VRETCSL)
                                Replace E2_SALDO 	With SE2->E2_VALOR
                                Replace E2_PRETPIS 	With '2'
                                Replace E2_PRETCOF 	With '2'
                                Replace E2_PRETCSL 	With '2'
                                Replace E2_VRETPIS 	With  0
                                Replace E2_VRETCOF 	With  0
                                Replace E2_VRETCSL 	With  0
                                MsUnlock()
                                FKCOMMIT()
                            Endif
                        EndIf
                    EndIf
                    SFQ->(dbSkip())
                EndDo
            EndIf
            //³ Exclui registros indevidos de impostos-Pcc ³
            dbSelectArea("SE2")
            SE2->(DbSetOrder(1))
            dbSeek(cFil_Rtd+cPre_Rtd+cNum_Rtd+cPar_Rtd)
            While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == cFil_Rtd+cPre_Rtd+cNum_Rtd

                If AllTrim(E2_NATUREZ) == cMV_PISNAT .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                    FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                    RecLock("SE2")
                    dbDelete()
                    MsUnlock()
                    FKCOMMIT()
                EndIf

                If AllTrim(E2_NATUREZ) == cMV_COFINS .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                    FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                    RecLock("SE2")
                    dbDelete()
                    MsUnlock()
                    FKCOMMIT()
                EndIf

                If AllTrim(E2_NATUREZ) == cMV_CSLL .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                    FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                    RecLock("SE2")
                    dbDelete()
                    MsUnlock()
                    FKCOMMIT()
                EndIf
                dbSkip()
            Enddo

            //-- Salva dados do Titulo Retentor Antes de Excluí-lo
            SE2->(dbGoto(RecRtR))
            cFil_Rtr    	:= SE2->E2_FILIAL
            cPre_Rtr    	:= SE2->E2_PREFIXO
            cNum_Rtr    	:= SE2->E2_NUM
            cPar_Rtr    	:= SE2->E2_PARCELA
            cTip_Rtr    	:= SE2->E2_TIPO
            cFor_Rtr    	:= SE2->E2_FORNECE
            cLoj_Rtr    	:= SE2->E2_LOJA
            nVlr_Rtr   		:= SE2->E2_VALOR
            nSdo_Rtr   		:= SE2->E2_SALDO
            nPIS_Rtr   		:= SE2->E2_PIS
            nCOF_Rtr   		:= SE2->E2_COFINS
            nCSL_Rtr		:= SE2->E2_CSLL
            nVRPIS_Rtr 		:= SE2->E2_VRETPIS
            nVRCOF_Rtr 		:= SE2->E2_VRETCOF
            nVRCSL_Rtr		:= SE2->E2_VRETCSL
            cTitPai_Rtr 	:= Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

            //-- Monta Array para ExecAuto do Titulo Retentor
            aEval(SE2->(DbStruct()), {|x| aAdd(aDados,{x[1],SE2->&(x[1]),NIL})})

            If !(SE2->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
            (SE2->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"))

                If SE2->E2_TIPO $ MVPAGANT
                    If __lLocBRA .And. !Empty(SE2->E2_BASEPIS)
                        nBasePCC := SE2->E2_BASEPIS
                    Else
                        nBasePCC := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                    Endif
                Else
                    nBasePCC := nVlr_Rtr + SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + SE2->E2_INSS + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                Endif
                SA2->(DbSeek(xFilial("SA2") + aDados[aScan(aDados,{|x|x[1]=="E2_FORNECE"}),2] + aDados[aScan(aDados,{|x|x[1]=="E2_LOJA"}),2]))
                SED->(DbSeek(xFilial("SED") + aDados[aScan(aDados,{|x|x[1]=="E2_NATUREZ"}),2]))
                If !SE2->E2_TIPO $ MVPAGANT
                    // PIS
                    // se natureza pede calculo do PIS
                    If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
                        If ! GetNewPar("MV_RNDPIS",.F.)
                            aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
                        Else
                            aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
                        Endif
                    Else
                        aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := 0
                        nOldPis	 := 0
                    EndIf
                    // COFINS
                    // se natureza pede calculo do COFINS
                    If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
                        If ! GetNewPar("MV_RNDCOF",.F.)
                            aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
                        Else
                            aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
                        Endif
                    Else
                        aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := 0
                        nOldCofins	 		:= 0
                    EndIf
                    // CSLL
                    // se natureza pede calculo do CSLL
                    If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
                        If ! GetNewPar("MV_RNDCSL",.F.)
                            aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
                        Else
                            aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
                        Endif
                    Else
                        aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := 0
                        nOldCsll	  			:= 0
                    Endif
                EndIf
            EndIf
            //-- Calculo pelo sistema qdo o Valor Total dos titulos do fornecedor para o periodo menor que o valor minimo
            If	((cModRetPIS = "1") .And. (nVlr_Rtr_Tot 	<= 	nVlMinImp))
                aDados[aScan(aDados,{|x|x[1]=="E2_VALOR"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                aDados[aScan(aDados,{|x|x[1]=="E2_SALDO"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                aDados[aScan(aDados,{|x|x[1]=="E2_VRETPIS"}),2] := 0
                aDados[aScan(aDados,{|x|x[1]=="E2_VRETCOF"}),2] := 0
                aDados[aScan(aDados,{|x|x[1]=="E2_VRETCSL"}),2] := 0
                aDados[aScan(aDados,{|x|x[1]=="E2_PRETPIS"}),2] := "1"
                aDados[aScan(aDados,{|x|x[1]=="E2_PRETCOF"}),2] := "1"
                aDados[aScan(aDados,{|x|x[1]=="E2_PRETCSL"}),2] := "1"
            EndIf
            //-- Ajusta Titulo Retido Alterado
            SE2->(dbGoto(nRecRtd))
            If  ((nVlr_Rtr_Tot > nVlMinImp)  .And. (SE2->E2_PRETPIS = '1'))
                If E2_VENCREA == aDados[aScan(aDados,{|x|x[1]=="E2_VENCREA"}),2]
                    RecLock("SE2")
                    Replace E2_PRETPIS 	With '2'
                    Replace E2_PRETCOF 	With '2'
                    Replace E2_PRETCSL 	With '2'
                    MsUnlock()
                    FKCOMMIT()
                EndIf
            EndIf
            //³Gera o titulo no contas a pagar³

            //-- Ajusta Titulo Retentor
            SE2->(dbGoto(RecRtR))
            RecLock("SE2")
            Replace E2_VALOR 		With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
            Replace E2_SALDO   		With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
            
            If nVlr_Rtr_Tot > nVlMinImp
                Replace E2_VALOR 	With E2_VALOR - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
                Replace E2_SALDO 	With E2_SALDO - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
                Replace E2_VRETPIS 	With nPIS_Rtr + nPIS_Rtd
                Replace E2_VRETCOF 	With nCOF_Rtr + nCOF_Rtd
                Replace E2_VRETCSL 	With nCSL_Rtr + nCSL_Rtd
                Replace E2_PIS 		With nPIS_Rtr
                Replace E2_COFINS 	With nCOF_Rtr
                Replace E2_CSLL 	With nCSL_Rtr
            Else
                Replace E2_VRETPIS 	With 0
                Replace E2_VRETCOF 	With 0
                Replace E2_VRETCSL 	With 0
                Replace E2_PRETPIS 	With '1'
                Replace E2_PRETCOF 	With '1'
                Replace E2_PRETCSL 	With '1'
                Replace E2_PIS 		With nPIS_Rtr
                Replace E2_COFINS 	With nCOF_Rtr
                Replace E2_CSLL 	With nCSL_Rtr
            EndIf
            MsUnlock()
            FKCOMMIT()
            If nVlr_Rtr_Tot > nVlMinImp
                //³ Ajusta tambem os registros de impostos-Pcc ³
                dbSelectArea("SE2")
                SE2->(DbSetOrder(1))
                dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
                While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == cFil_Rtr+cPre_Rtr+cNum_Rtr
                    If AllTrim(E2_NATUREZ) == cMV_PISNAT .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                        RecLock("SE2")
                        Replace E2_VALOR 	With nPIS_Rtr + nPIS_Rtd
                        Replace E2_SALDO 	With nPIS_Rtr + nPIS_Rtd
                        Replace E2_TITPAI   With cTitPai_Rtr
                        Replace E2_ORIGEM	With "FINA050"
                        MsUnlock()
                        FKCOMMIT()
                    EndIf
                    If AllTrim(E2_NATUREZ) == cMV_COFINS .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                        RecLock("SE2")
                        Replace E2_VALOR 	With nCOF_Rtr + nCOF_Rtd
                        Replace E2_SALDO 	With nCOF_Rtr + nCOF_Rtd
                        Replace E2_TITPAI  	With cTitPai_Rtr
                        Replace E2_ORIGEM	With "FINA050"
                        MsUnlock()
                        FKCOMMIT()
                    EndIf
                    If AllTrim(E2_NATUREZ) == cMV_CSLL .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA)  .And. SE2->E2_SALDO != 0
                        RecLock("SE2")
                        Replace E2_VALOR 	With nCSL_Rtr + nCSL_Rtd
                        Replace E2_SALDO 	With nCSL_Rtr + nCSL_Rtd
                        Replace E2_TITPAI  	With cTitPai_Rtr
                        Replace E2_ORIGEM	With "FINA050"
                        MsUnlock()
                        FKCOMMIT()
                    EndIf
                    dbSkip()
                Enddo
            Else
                //³ Exclui registros indevidos de impostos-Pcc ³
                dbSelectArea("SE2")
                SE2->(DbSetOrder(1))
                dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
                While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == cFil_Rtr+cPre_Rtr+cNum_Rtr

                    If AllTrim(E2_NATUREZ) == cMV_PISNAT .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO == SE2->E2_VALOR
                        FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                        RecLock("SE2")
                        dbDelete()
                        MsUnlock()
                        FKCOMMIT()
                    EndIf

                    If AllTrim(E2_NATUREZ) == cMV_COFINS .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO == SE2->E2_VALOR
                        FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                        RecLock("SE2")
                        dbDelete()
                        MsUnlock()
                        FKCOMMIT()
                    EndIf

                    If AllTrim(E2_NATUREZ) == cMV_CSLL .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO == SE2->E2_VALOR
                        FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                        RecLock("SE2")
                        dbDelete()
                        MsUnlock()
                        FKCOMMIT()
                    EndIf
                    dbSkip()
                Enddo
            EndIf
        Else
            lRet := .F.
        EndIf
    Else
        lRet := .F.
    EndIf

    If !lRet
        Help(" ",1,"NOATUARET" ,, STR0011 + cPre_Rtr + cNum_Rtr , 1,0)  //"Titulo Retentor - Não Atualizado: "
    Endif

    If ValType(lHelpOld ) == "L"
        lMsHelpAuto := lHelpOld
    EndIf
    If ValType(lErroOld) == "L"
        lMsErroAuto	:= lErroOld
    EndIf

    RestArea(aAreaSE2)
    RestArea(aAreaSFQ)
    RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050AlRtd2
Trata Ajuste na Alteração, com valores atualizados de 
Titulo que Reteve os Impostos PCC de outro juntamente com
os seus, e, agora, sofreu alteração na base de calculo
Alteração da data de referencia do titulo Retido

@author Totvs SA
@since  05/11/09
/*/
//-------------------------------------------------------------------
Function F050AlRtd2(lAtuPCCRet)

    Local aArea 		:= GetArea()
    Local aAreaSE2 		:= SE2->(GetArea())
    Local aAreaSFQ 		:= SFQ->(GetArea())
    Local lRet			:= .T.
    Local lHelpOld
    Local lErroOld
    Local dDataFim 		:= E2_EMISSAO
    Local dDataIni 		:= E2_EMISSAO

    //Titulos Retidos
    Local nRecRtd  		:= SE2->(RECNO())
    Local cFil_Rtd     	:= E2_FILIAL
    Local cPre_Rtd     	:= E2_PREFIXO
    Local cNum_Rtd     	:= E2_NUM
    Local cPar_Rtd     	:= E2_PARCELA
    Local nVlr_Rtd_Tot	:= 0
    Local nVlr_Rtd 		:= 0
    Local nPIS_Rtd 		:= 0
    Local nCOF_Rtd		:= 0
    Local nCSL_Rtd 		:= 0
    Local nPIS_Rt1 		:= 0
    Local nCOF_Rt1		:= 0
    Local nCSL_Rt1 		:= 0
    //Titulo Retentor
    Local nRecRtR  		:= SE2->(RECNO())
    Local cFil_Rtr     	:= E2_FILIAL
    Local cPre_Rtr     	:= E2_PREFIXO
    Local cNum_Rtr     	:= E2_NUM
    Local cPar_Rtr     	:= E2_PARCELA
    Local nVlr_Rtr_Tot	:= 0
    Local cTip_Rtr     	:= E2_TIPO
    Local cFor_Rtr     	:= E2_FORNECE
    Local cLoj_Rtr     	:= E2_LOJA
    Local nVlr_Rtr 		:= 0
    Local nSdo_Rtr 		:= 0
    Local nPIS_Rtr		:= 0
    Local nCOF_Rtr 		:= 0
    Local nCSL_Rtr		:= 0
    Local nVRPIS_Rtr	:= 0
    Local nVRCOF_Rtr	:= 0
    Local nVRCSL_Rtr    := 0
    Local cTitPai_Rtr   := E2_TITPAI
    Local nVlMinImp 	:= GetNewPar("MV_VL10925",5000)

    Local cMV_PISNAT    := AllTrim(GetMv("MV_PISNAT"))
    Local cMV_COFINS    := AllTrim(GetMv("MV_COFINS"))
    Local cMV_CSLL      := AllTrim(GetMv("MV_CSLL"))

    /*
    Chamado TRGZT8
    Os impostos do titulo retentor nao devem sofre alteracoes, quando ele ou os titulos que reteve forem alterados.
    Este parametro define se o titulo retentor deve ter os impostos alterados. */
    Default lAtuPCCRet		:= .T.

    dDataFim  := LastDay( SE2->E2_VENCREA  )
    dDataIni  := FirstDay( SE2->E2_VENCREA  )

    If Type("lMsHelpAuto") == "L"
        lHelpOld 	:= lMsHelpAuto
        lMsHelpAuto := .F. // Nao exibe erro
    Else
        Private lMsHelpAuto := .F.
    EndIf

    If Type("lMsErroAuto") == "L"
        lErroOld := lMsErroAuto
    Else
        Private lMsErroAuto := .F.
    Endif
    //-- Prepara campos para a função: F050TotMes
    M->E2_VENCREA 		:= SE2->E2_VENCREA
    M->E2_PIS 			:= SE2->E2_PIS
    M->E2_COFINS 		:= SE2->E2_COFINS
    M->E2_CSLL 			:= SE2->E2_CSLL
    M->E2_APLVLMN 		:= SE2->E2_APLVLMN
    M->E2_TIPO  		:= SE2->E2_TIPO
    M->E2_FORNECE 		:= SE2->E2_FORNECE
    M->E2_LOJA 			:= SE2->E2_LOJA
    M->E2_NATUREZ 		:= SE2->E2_NATUREZ
    M->E2_VLCRUZ 		:= SE2->E2_VLCRUZ
    M->E2_MOEDA 		:= SE2->E2_MOEDA
    M->E2_EMISSAO 		:= SE2->E2_EMISSAO
    M->E2_TXMOEDA		:= SE2->E2_TXMOEDA
    ///Totaliza Titulos do Fornecedor Data de referencia é a do retido
    aDadosRet 			:= F050TotMes(M->E2_VENCREA)
    nVlr_Rtd_Tot 		:= aDadosRet[1]

    SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
    If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
        nRecRtd   := SE2->(RECNO())
        cPREFORI  := SFQ->FQ_PREFORI
        nNUMORI   := SFQ->FQ_NUMORI
        nPARCORI  := SFQ->FQ_PARCORI
        cTIPOORI  := SFQ->FQ_TIPOORI
        nCFORI    := SFQ->FQ_CFORI
        nLOJAORI  := SFQ->FQ_LOJAORI
        //-- Localiza Tit Retentor
        SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
        If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))
            nRecRtR  		:=	SE2->(RECNO())
            SE2->E2_PREFIXO	:= cPREFORI
            SE2->E2_NUM		:=	nNUMORI
            SE2->E2_PARCELA	:=	nPARCORI
            SE2->E2_TIPO	:=	cTIPOORI
            SE2->E2_FORNECE	:=	nCFORI
            SE2->E2_LOJA	:=	nLOJAORI
            //-- Prepara campos para a função: F050TotMes
            M->E2_VENCREA	:= SE2->E2_VENCREA
            M->E2_PIS 		:= SE2->E2_PIS
            M->E2_COFINS	:= SE2->E2_COFINS
            M->E2_CSLL 		:= SE2->E2_CSLL
            M->E2_APLVLMN	:=	SE2->E2_APLVLMN
            M->E2_TIPO  	:=	SE2->E2_TIPO
            M->E2_FORNECE	:=	SE2->E2_FORNECE
            M->E2_LOJA 		:=	SE2->E2_LOJA
            M->E2_NATUREZ	:=	SE2->E2_NATUREZ
            M->E2_VLCRUZ 	:=	SE2->E2_VLCRUZ
            M->E2_MOEDA 	:=	SE2->E2_MOEDA
            M->E2_EMISSAO 	:=	SE2->E2_EMISSAO
            M->E2_TXMOEDA	:=	SE2->E2_TXMOEDA
            ///Totaliza Titulos do Fornecedor Data de referencia é a do Retentor
            aDadosRet 		:= F050TotMes(M->E2_VENCREA)
            nVlr_Rtr_Tot 	:= aDadosRet[1]

            SFQ->(dbSetOrder(1))
            ///Pesquisa Todos Titulos Retidos neste Titulo Retentor, para o fornecedor e periodo
            If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
                While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
                    SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI
                    
                    cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
                    //-- Localiza Titulos Retidos
                    SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
                    If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))
                        If nRecRtd == SE2->(RECNO())
                            cFil_Rtd := SE2->E2_FILIAL
                            cPre_Rtd := SE2->E2_PREFIXO
                            cNum_Rtd := SE2->E2_NUM
                            cPar_Rtd := SE2->E2_PARCELA
                            nVlr_Rtd := SE2->E2_VALOR + SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL
                            nPIS_Rtd := SE2->E2_PIS
                            nCOF_Rtd := SE2->E2_COFINS
                            nCSL_Rtd := SE2->E2_CSLL
                            //Exclui Relacionamento do titulo Retido com seu Retentor
                            RecLock("SFQ")
                            dbDelete()
                            MsUnlock()
                            FKCOMMIT()
                        Else
                            nPIS_Rt1 += SE2->E2_PIS
                            nCOF_Rt1 += SE2->E2_COFINS
                            nCSL_Rt1 += SE2->E2_CSLL
                        EndIf

                        If nVlr_Rtr_Tot <= 	nVlMinImp
                            //Atualiza Situação de Retenção do titulo Retido
                            RecLock("SE2")
                            Replace E2_PRETPIS 	With '1'
                            Replace E2_PRETCOF 	With '1'
                            Replace E2_PRETCSL 	With '1'
                            MsUnlock()
                            FKCOMMIT()
                            //Exclui Relacionamento do titulo Retido com seu Retentor
                            RecLock("SFQ")
                            dbDelete()
                            MsUnlock()
                            FKCOMMIT()
                        EndIf
                    EndIf
                    SFQ->(dbSkip())
                Enddo
            Endif

            //-- Salva dados do Titulo Retentor
            SE2->(dbGoto(nRecRtR))
            cFil_Rtr    := SE2->E2_FILIAL
            cPre_Rtr    := SE2->E2_PREFIXO
            cNum_Rtr    := SE2->E2_NUM
            cPar_Rtr    := SE2->E2_PARCELA
            cTip_Rtr    := SE2->E2_TIPO
            cFor_Rtr    := SE2->E2_FORNECE
            cLoj_Rtr    := SE2->E2_LOJA
            nVlr_Rtr   	:= SE2->E2_VALOR
            nSdo_Rtr   	:= SE2->E2_SALDO
            nPIS_Rtr   	:= SE2->E2_PIS
            nCOF_Rtr   	:= SE2->E2_COFINS
            nCSL_Rtr	:= SE2->E2_CSLL
            nVRPIS_Rtr 	:= SE2->E2_VRETPIS
            nVRCOF_Rtr 	:= SE2->E2_VRETCOF
            nVRCSL_Rtr	:= SE2->E2_VRETCSL
            cTitPai_Rtr := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

            //-- Ajusta Titulo Retido Alterado (periodo)
            SE2->(dbGoto(nRecRtd))
            RecLock("SE2")

            If nVlr_Rtd_Tot > nVlMinImp
                //Pesquisar titulos pendentes de retenção para o Fornecedor periodo(E2_PRETPIS ="1")
                //se encontrar gravar relacionamento(SFQ) entre o pendente e este
                F050GrvSFQ()
                Replace E2_VALOR 	With SE2->(E2_VALOR - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)
                Replace E2_SALDO 	With SE2->(E2_SALDO - E2_VRETPIS - E2_VRETCOF - E2_VRETCSL)
                Replace E2_VRETPIS 	With SE2->E2_VRETPIS
                Replace E2_VRETCOF 	With SE2->E2_VRETCOF
                Replace E2_VRETCSL 	With SE2->E2_VRETCSL
                Replace E2_PRETPIS 	With ' '
                Replace E2_PRETCOF 	With ' '
                Replace E2_PRETCSL 	With ' '
                // Grava Impostos PCC
                F050TXPCC()
            Else
                Replace E2_PRETPIS 	With '1'
                Replace E2_PRETCOF 	With '1'
                Replace E2_PRETCSL 	With '1'
            EndIf
            MsUnlock()
            FKCOMMIT()

            //-- Ajusta Titulo Retentor
            SE2->(dbGoto(nRecRtr))
            If lAtuPCCRet
                RecLock("SE2")

                If nVlr_Rtr_Tot > nVlMinImp
                    Replace E2_VALOR 	With (nVlr_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
                    Replace E2_SALDO 	With (nVlr_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
                    Replace E2_VRETPIS 	With nPIS_Rtr + nPIS_Rt1
                    Replace E2_VRETCOF 	With nCOF_Rtr + nCOF_Rt1
                    Replace E2_VRETCSL 	With nCSL_Rtr + nCSL_Rt1
                    Replace E2_PIS 		With nPIS_Rtr
                    Replace E2_COFINS 	With nCOF_Rtr
                    Replace E2_CSLL 	With nCSL_Rtr
                Else
                    Replace E2_VALOR 	With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                    Replace E2_SALDO   	With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                    Replace E2_VRETPIS 	With 0
                    Replace E2_VRETCOF 	With 0
                    Replace E2_VRETCSL 	With 0
                    Replace E2_PRETPIS 	With '1'
                    Replace E2_PRETCOF 	With '1'
                    Replace E2_PRETCSL 	With '1'
                    Replace E2_PIS 		With nPIS_Rtr
                    Replace E2_COFINS 	With nCOF_Rtr
                    Replace E2_CSLL 	With nCSL_Rtr
                EndIf
                MsUnlock()
                FKCOMMIT()
                If nVlr_Rtr_Tot > nVlMinImp
                    //³ Ajusta tambem os registros de impostos-Pcc ³
                    dbSelectArea("SE2")
                    SE2->(DbSetOrder(1))
                    dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
                    While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == cFil_Rtr+cPre_Rtr+cNum_Rtr

                        If AllTrim(E2_NATUREZ) == cMV_PISNAT .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                            RecLock("SE2")
                            Replace E2_VALOR 	With nPIS_Rtr +	nPIS_Rt1
                            Replace E2_SALDO    With nPIS_Rtr + nPIS_Rt1
                            Replace E2_TITPAI   With cTitPai_Rtr
                            Replace E2_ORIGEM	With "FINA050"
                            MsUnlock()
                            FKCOMMIT()
                        EndIf
                        If AllTrim(E2_NATUREZ) == cMV_COFINS .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                            RecLock("SE2")
                            Replace E2_VALOR 	With nCOF_Rtr + nCOF_Rt1
                            Replace E2_SALDO 	With nCOF_Rtr + nCOF_Rt1
                            Replace E2_TITPAI   With cTitPai_Rtr
                            Replace E2_ORIGEM	With "FINA050"
                            MsUnlock()
                            FKCOMMIT()
                        EndIf
                        If AllTrim(E2_NATUREZ) == cMV_CSLL .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                            RecLock("SE2")
                            Replace E2_VALOR 	With nCSL_Rtr + nCSL_Rt1
                            Replace E2_SALDO 	With nCSL_Rtr + nCSL_Rt1
                            Replace E2_TITPAI   With cTitPai_Rtr
                            Replace E2_ORIGEM	With "FINA050"
                            MsUnlock()
                            FKCOMMIT()
                        EndIf
                        dbSkip()
                    Enddo
                Else
                    F050DelPCC()
                EndIf
            Endif
        Else
            lRet := .F.
        EndIf
    Else
        lRet := .F.
    EndIf

    If !lRet
        Help(" ",1,"NOATUARET",, STR0011  + cPre_Rtr + cNum_Rtr , 1,0)  //"Titulo Retentor - Não Atualizado: "
    Endif

    If ValType(lHelpOld ) == "L"
        lMsHelpAuto := lHelpOld
    EndIf
    If ValType(lErroOld) == "L"
        lMsErroAuto	:= lErroOld
    Endif

    RestArea(aAreaSE2)
    RestArea(aAreaSFQ)
    RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050DelRtd
Trata Exclusão , com valores atualizados de Titulo que Reteve
os Impostos PCC de outro juntamente com os seus, e, agora, sofreu 
alteração na base de calculo Deleção do Titulo Retido

@author Totvs SA
@since  05/11/09
/*/
//-------------------------------------------------------------------
Function F050DelRtd()

    Local aArea 		:= GetArea()
    Local aAreaSE2 		:= SE2->(GetArea())
    Local aAreaSFQ 		:= SFQ->(GetArea())
    Local aDados		:= {}
    Local lRet			:= .T.
    Local lHelpOld
    Local lErroOld
    Local dDataFim  	:= E2_EMISSAO
    //Titulos Retidos
    Local nRecRtd   	:= SE2->(RECNO())
    Local nVlr_Rtd_Tot	:= 0
    Local nVlr_Rtd   	:= 0
    Local nPIS_Rtd 		:= 0
    Local nCOF_Rtd		:= 0
    Local nCSL_Rtd  	:= 0
    //Titulo Retentor
    Local cFil_Rtr      := E2_FILIAL
    Local cPre_Rtr      := E2_PREFIXO
    Local cNum_Rtr     	:= E2_NUM
    Local cPar_Rtr     	:= E2_PARCELA
    Local cTip_Rtr     	:= E2_TIPO
    Local cFor_Rtr     	:= E2_FORNECE
    Local cLoj_Rtr      := E2_LOJA
    Local nVlr_Rtr   	:= 0
    Local nSdo_Rtr   	:= 0
    Local nPIS_Rtr   	:= 0
    Local nCOF_Rtr   	:= 0
    Local nCSL_Rtr		:= 0
    Local nVRPIS_Rtr 	:= 0
    Local nVRCOF_Rtr 	:= 0
    Local nVRCSL_Rtr	:= 0
    Local cTitPai_Rtr   := E2_TITPAI
    Local nVlMinImp 	:= GetNewPar("MV_VL10925",5000)
    Local lCalcIssBx    := IIF(__lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )

    Local cMV_PISNAT    := AllTrim(GetMv("MV_PISNAT"))
    Local cMV_COFINS    := AllTrim(GetMv("MV_COFINS"))
    Local cMV_CSLL      := AllTrim(GetMv("MV_CSLL"))

    dDataFim  := LastDay( ddatabase )

    If Type("lMsHelpAuto") == "L"
        lHelpOld 	:= lMsHelpAuto
        lMsHelpAuto := .F. // Nao exibe erro
    Else
        Private lMsHelpAuto := .F.
    EndIf

    If Type("lMsErroAuto") == "L"
        lErroOld := lMsErroAuto
    Else
        Private lMsErroAuto := .F.
    EndIf

    SFQ->(DbSetOrder(2)) //-- FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
    If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
        nRecRtd   :=	SE2->(RECNO())
        cPREFORI  :=	SFQ->FQ_PREFORI
        nNUMORI   :=	SFQ->FQ_NUMORI
        nPARCORI  :=	SFQ->FQ_PARCORI
        cTIPOORI  :=	SFQ->FQ_TIPOORI
        nCFORI    :=	SFQ->FQ_CFORI
        nLOJAORI  :=	SFQ->FQ_LOJAORI
        //-- Localiza Tit Retentor
        SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
        If SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI)))
            SFQ->(dbSetOrder(1))
            SE2->E2_PREFIXO	:= cPREFORI
            SE2->E2_NUM		:=	nNUMORI
            SE2->E2_PARCELA	:=	nPARCORI
            SE2->E2_TIPO	:=	cTIPOORI
            SE2->E2_FORNECE	:=	nCFORI
            SE2->E2_LOJA	:=	nLOJAORI
            //-- Prepara campos para a função: F050TotMes
            M->E2_VENCREA 	:= SE2->E2_VENCREA
            M->E2_PIS 		:= SE2->E2_PIS
            M->E2_COFINS 	:= SE2->E2_COFINS
            M->E2_CSLL 		:= SE2->E2_CSLL
            M->E2_APLVLMN 	:= SE2->E2_APLVLMN
            M->E2_TIPO  	:= SE2->E2_TIPO
            M->E2_FORNECE 	:= SE2->E2_FORNECE
            M->E2_LOJA 		:= SE2->E2_LOJA
            M->E2_NATUREZ 	:= SE2->E2_NATUREZ
            M->E2_VLCRUZ 	:= SE2->E2_VLCRUZ
            M->E2_MOEDA 	:= SE2->E2_MOEDA
            M->E2_EMISSAO 	:= SE2->E2_EMISSAO
            M->E2_TXMOEDA	:= SE2->E2_TXMOEDA
            ///Totaliza Titulos do Fornecedor
            aDadosRet 		:= F050TotMes(M->E2_VENCREA)
            nVlr_Rtd_Tot 	:= aDadosRet[1]

            ///Pesquisa Todos Titulos Retidos neste Titulos Retentor, para o fornecedor e periodo
            If SFQ->(DbSeek(xFilial("SFQ")+"SE2"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
                RecRtR   :=	SE2->(RECNO())
                While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
                    SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cPREFORI+nNUMORI+nPARCORI+cTIPOORI+nCFORI+nLOJAORI

                    cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
                    //-- Localiza Titulos Retidos
                    SE2->(DbSetOrder(1)) //-- E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
                    If 	SE2->(DbSeek(xFilial("SE2")+SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)))
                        If nRecRtd  == 	SE2->(RECNO())
                            nVlr_Rtd += SE2->E2_VALOR + SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL
                        ElseIf 	(E2_PRETPIS == 	'2')
                            nVlr_Rtd += SE2->E2_VALOR
                            nPIS_Rtd += SE2->E2_PIS
                            nCOF_Rtd += SE2->E2_COFINS
                            nCSL_Rtd += SE2->E2_CSLL
                        EndIf
                        If  ((cModRetPIS = "1") .And. (nVlr_Rtd_Tot 	<= 	nVlMinImp) .And.(SE2->E2_PRETPIS <> "1"))
                            RecLock("SE2")
                            Replace E2_PRETPIS 	With '1'
                            Replace E2_PRETCOF 	With '1'
                            Replace E2_PRETCSL 	With '1'
                            MsUnlock()
                            FKCOMMIT()
                        EndIf
                    EndIf
                    SFQ->(dbSkip())
                EndDo
            EndIf
            //-- Salva dados do Titulo Retentor Antes de Excluí-lo
            SE2->(dbGoto(RecRtR))
            cFil_Rtr    := SE2->E2_FILIAL
            cPre_Rtr    := E2_PREFIXO
            cNum_Rtr    := E2_NUM
            cPar_Rtr    := E2_PARCELA
            cTip_Rtr    := E2_TIPO
            cFor_Rtr    := E2_FORNECE
            cLoj_Rtr    := E2_LOJA
            nVlr_Rtr   	:= SE2->E2_VALOR
            nSdo_Rtr   	:= SE2->E2_SALDO
            nPIS_Rtr   	:= SE2->E2_PIS
            nCOF_Rtr   	:= SE2->E2_COFINS
            nCSL_Rtr	:= SE2->E2_CSLL
            nVRPIS_Rtr 	:= SE2->E2_VRETPIS
            nVRCOF_Rtr 	:= SE2->E2_VRETCOF
            nVRCSL_Rtr	:= SE2->E2_VRETCSL
            cTitPai_Rtr := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

            //-- Monta Array para ExecAuto do Titulo Retentor
            aEval(SE2->(DbStruct()), {|x| aAdd(aDados,{x[1],SE2->&(x[1]),NIL})})

            If !(SE2->e2_tipo $ MVABATIM+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVISS+"/"+MVTXA +"/"+"SES"+"/"+MV_CPNEG+"/"+"INA" .or. ;
            (SE2->e2_tipo $ MVPAGANT .and. GetMv("MV_IMPADT") != "S"))
                If SE2->E2_TIPO $ MVPAGANT
                    If __lLocBRA .And. !Empty(SE2->E2_BASEPIS)
                        nBasePCC := SE2->E2_BASEPIS
                    Else
                        nBasePCC := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                    Endif
                Else
                    nBasePCC := nVlr_Rtr + SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + SE2->E2_INSS + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                Endif
                SA2->(DbSeek(xFilial("SA2") + aDados[aScan(aDados,{|x|x[1]=="E2_FORNECE"}),2] + aDados[aScan(aDados,{|x|x[1]=="E2_LOJA"}),2]))
                SED->(DbSeek(xFilial("SED") + aDados[aScan(aDados,{|x|x[1]=="E2_NATUREZ"}),2]))
                If !SE2->E2_TIPO $ MVPAGANT

                    aDados[aScan(aDados,{|x|x[1]=="E2_VALOR"}),2]	+= (SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + SE2->E2_INSS)
                    aDados[aScan(aDados,{|x|x[1]=="E2_SALDO"}),2]	+= (SE2->E2_IRRF + If(!lCalcIssBx,SE2->E2_ISS,0) + SE2->E2_INSS)
                    aDados[aScan(aDados,{|x|x[1]=="E2_IRRF"}),2]	:= 0
                    aDados[aScan(aDados,{|x|x[1]=="E2_ISS"}),2]		:= 0
                    aDados[aScan(aDados,{|x|x[1]=="E2_INSS"}),2]	:= 0

                    //PIS
                    //³ se natureza pede calculo do PIS      ³
                    If SED->ED_CALCPIS == "S"  .and. SA2->A2_RECPIS == "2"
                        If ! GetNewPar("MV_RNDPIS",.F.)
                            aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := NoRound((nBasePCC * (SED->ED_PERCPIS / 100)),2)
                        Else
                            aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := Round((nBasePCC * (SED->ED_PERCPIS / 100)),2)
                        Endif
                    Else
                        aDados[aScan(aDados,{|x|x[1]=="E2_PIS"}),2] := 0
                        nOldPis	 			:= 0
                    EndIf
                    // COFINS
                    //³ se natureza pede calculo do COFINS	  ³
                    If SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2"
                        If ! GetNewPar("MV_RNDCOF",.F.)
                            aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := NoRound((nBasePCC * (SED->ED_PERCCOF / 100)),2)
                        Else
                            aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := Round((nBasePCC * (SED->ED_PERCCOF / 100)),2)
                        Endif
                    Else
                        aDados[aScan(aDados,{|x|x[1]=="E2_COFINS"}),2] := 0
                        nOldCofins := 0
                    EndIf
                    // CSLL
                    //³ se natureza pede calculo do CSLL ³
                    If SED->ED_CALCCSL == "S"  .and. SA2->A2_RECCSLL == "2"
                        If ! GetNewPar("MV_RNDCSL",.F.)
                            aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := NoRound((nBasePCC * (SED->ED_PERCCSL / 100)),2)
                        Else
                            aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := Round((nBasePCC * (SED->ED_PERCCSL / 100)),2)
                        Endif
                    Else
                        aDados[aScan(aDados,{|x|x[1]=="E2_CSLL"}),2] := 0
                        nOldCsll	  			:= 0
                    Endif
                EndIf
            EndIf
            //-- Calculo pelo sistema qdo o Valor Total dos titulos do fornecedor para o periodo menor que o valor minimo
            If	((cModRetPIS = "1") .And. (nVlr_Rtd_Tot 	<= 	nVlMinImp))
                aDados[aScan(aDados,{|x|x[1]=="E2_VALOR"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                aDados[aScan(aDados,{|x|x[1]=="E2_SALDO"}),2]  := nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                aDados[aScan(aDados,{|x|x[1]=="E2_VRETPIS"}),2] := 0
                aDados[aScan(aDados,{|x|x[1]=="E2_VRETCOF"}),2] := 0
                aDados[aScan(aDados,{|x|x[1]=="E2_VRETCSL"}),2] := 0
                aDados[aScan(aDados,{|x|x[1]=="E2_PRETPIS"}),2] := "1"
                aDados[aScan(aDados,{|x|x[1]=="E2_PRETCOF"}),2] := "1"
                aDados[aScan(aDados,{|x|x[1]=="E2_PRETCSL"}),2] := "1"
            EndIf
            //³Exclui o titulo no contas a pagar³
            MSExecAuto({|x, y, z| FINA050(x, y, z)}, aClone(aDados),5,5)

            If lMsErroAuto
                Help(" ",1,"NOATUARET",, STR0011 + cPre_Rtr + cNum_Rtr, 1,0)  //"Titulo Retentor - Não Atualizado: "
                lRet := .F.
            Else
                //-- Ajusta Titulo Retido Alterado
                SE2->(dbGoto(nRecRtd))
                If  ((nVlr_Rtd_Tot > nVlMinImp)  .And. (SE2->E2_PRETPIS = '1'))
                    If E2_VENCREA == aDados[aScan(aDados,{|x|x[1]=="E2_VENCREA"}),2]
                        RecLock("SE2")
                        Replace E2_PRETPIS 	With ' '
                        Replace E2_PRETCOF 	With ' '
                        Replace E2_PRETCSL 	With ' '
                        MsUnlock()
                        FKCOMMIT()
                    EndIf
                EndIf
                //³Gera o titulo no contas a pagar³
                lMsErroAuto := .F.

                MSExecAuto(	{ |a,b,c| FINA050(a,b,c) },aDados,,3)
                If lMsErroAuto
                    Help(" ",1,"NOATUARET",, STR0011 + cPre_Rtr + cNum_Rtr, 1,0)  //"Titulo Retentor - Não Atualizado: "
                    lRet := .F.
                Else
                    //-- Ajusta Titulo Retentor
                    RecLock("SE2")
                    Replace E2_VALOR With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr
                    Replace E2_SALDO With nVlr_Rtr + nVRPIS_Rtr + nVRCOF_Rtr + nVRCSL_Rtr

                    If nVlr_Rtd_Tot > nVlMinImp
                        Replace E2_VALOR 	With E2_VALOR - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
                        Replace E2_SALDO 	With E2_SALDO - (nPIS_Rtr + nCOF_Rtr + nCSL_Rtr + nPIS_Rtd + nCOF_Rtd + nCSL_Rtd)
                        Replace E2_VRETPIS 	With nPIS_Rtr + nPIS_Rtd
                        Replace E2_VRETCOF 	With nCOF_Rtr + nCOF_Rtd
                        Replace E2_VRETCSL 	With nCSL_Rtr + nCSL_Rtd
                        Replace E2_PIS 		With nPIS_Rtr
                        Replace E2_COFINS 	With nCOF_Rtr
                        Replace E2_CSLL 	With nCSL_Rtr
                    Else
                        Replace E2_VRETPIS 	With 0
                        Replace E2_VRETCOF 	With 0
                        Replace E2_VRETCSL 	With 0
                        Replace E2_PRETPIS 	With '1'
                        Replace E2_PRETCOF 	With '1'
                        Replace E2_PRETCSL 	With '1'
                        Replace E2_PIS 		With nPIS_Rtr
                        Replace E2_COFINS 	With nCOF_Rtr
                        Replace E2_CSLL 	With nCSL_Rtr
                    EndIf
                    Replace E2_VLCRUZ With IF(SE2->E2_MOEDA == 1,SE2->E2_VALOR,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1)))
                    MsUnlock()
                    FKCOMMIT()
                    If nVlr_Rtd_Tot > nVlMinImp
                        //³ Ajusta tambem os registros de impostos-Pcc ³
                        dbSelectArea("SE2")
                        SE2->(DbSetOrder(1))
                        dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
                        While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == cFil_Rtr+cPre_Rtr+cNum_Rtr

                            If AllTrim(E2_NATUREZ) == cMV_PISNAT .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                                RecLock("SE2")
                                Replace E2_VALOR 	With nPIS_Rtr 		+ 	nPIS_Rtd
                                Replace E2_SALDO 	With nPIS_Rtr 		+ 	nPIS_Rtd
                                Replace E2_TITPAI With cTitPai_Rtr
                                Replace E2_ORIGEM	With "FINA050"
                                MsUnlock()
                                FKCOMMIT()
                            EndIf
                            If AllTrim(E2_NATUREZ) == cMV_COFINS .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                                RecLock("SE2")
                                Replace E2_VALOR 	With nCOF_Rtr 		+ 	nCOF_Rtd
                                Replace E2_SALDO 	With nCOF_Rtr 		+ 	nCOF_Rtd
                                Replace E2_TITPAI With cTitPai_Rtr
                                Replace E2_ORIGEM	With "FINA050"
                                MsUnlock()
                                FKCOMMIT()
                            EndIf
                            If AllTrim(E2_NATUREZ) 	== cMV_CSLL .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                                RecLock("SE2")
                                Replace E2_VALOR 	With nCSL_Rtr 		+ 	nCSL_Rtd
                                Replace E2_SALDO 	With nCSL_Rtr 		+ 	nCSL_Rtd
                                Replace E2_TITPAI With cTitPai_Rtr
                                Replace E2_ORIGEM	With "FINA050"
                                MsUnlock()
                                FKCOMMIT()
                            EndIf
                            dbSkip()
                        Enddo
                    Else
                        //³ Exclui registros indevidos de impostos-Pcc ³
                        dbSelectArea("SE2")
                        SE2->(DbSetOrder(1))
                        dbSeek(cFil_Rtr+cPre_Rtr+cNum_Rtr+cPar_Rtr)
                        While !Eof( ) .And. E2_FILIAL+E2_PREFIXO+E2_NUM == cFil_Rtr+cPre_Rtr+cNum_Rtr

                            If AllTrim(E2_NATUREZ) == cMV_PISNAT .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                                FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                                RecLock("SE2")
                                dbDelete()
                                MsUnlock()
                                FKCOMMIT()
                            EndIf
                   
                            If AllTrim(E2_NATUREZ) == cMV_COFINS .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                                FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                                RecLock("SE2")
                                dbDelete()
                                MsUnlock()
                                FKCOMMIT()
                            EndIf

                            If AllTrim(E2_NATUREZ) == cMV_CSLL .And. AllTrim(E2_TIPO) == AllTrim(MVTAXA) .And. SE2->E2_SALDO != 0
                                FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                                RecLock("SE2")
                                dbDelete()
                                MsUnlock()
                                FKCOMMIT()
                            EndIf
                            dbSkip()
                        Enddo
                    EndIf
                EndIf
            EndIf
        Else
            Help(" ",1,"NOATUARET"     ,, STR0011  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "
            lRet := .F.
        EndIf
    Else
        Help(" ",1,"NOATUARET"     ,, STR0011  + cPre_Rtr + cNum_Rtr      , 1,0)  //"Titulo Retentor - Não Atualizado: "
        lRet := .F.
    EndIf

    If ValType(lHelpOld ) == "L"
        lMsHelpAuto := lHelpOld
    EndIf
    If ValType(lErroOld) == "L"
        lMsErroAuto	:= lErroOld
    EndIf

    RestArea(aAreaSE2)
    RestArea(aAreaSFQ)
    RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050GrvSFQ
Pesquisar titulos pendentes de retenção paa Fornecedor 
periodo(ex.E2_PRETPIS ="1"), gravar o relacionamento(SFQ)
entre o novo retentor eos titulos pendentes de retenção,
atualizar para retido em outro titulo(ex.E2_PRETPIS ="2")

@author Totvs SA
@since  05/11/09
/*/
//-------------------------------------------------------------------
Function F050GrvSFQ()

    Local lRet 	  		:= .F.
    Local aAreaSE2 	:= SE2->(GetArea())
    Local aArea   		:= GetArea()
    Local nRegSe2     := SE2->(RECNO())
    Local cNomeFor    := SE2->E2_NOMFOR
    Local cFornece    := SE2->E2_FORNECE
    Local nValPisT  	:= nPisOri//SE2->E2_PIS
    Local nValCofinsT := nCofOri//SE2->E2_COFINS
    Local nValCsllT   := nCslOri//SE2->E2_CSLL
    Local cPrefOri		:=	SE2->E2_PREFIXO
    Local cNumOri		:=	SE2->E2_NUM
    Local cParcOri		:=	SE2->E2_PARCELA
    Local cTipoOri		:=	SE2->E2_TIPO
    Local cCfOri		:=	SE2->E2_FORNECE
    Local cLojaOri   	:= SE2->E2_LOJA
    Local	dDtSeek		:=	SE2->E2_VENCREA
    Local dDataAcm		:=	SE2->E2_VENCREA
    Local dFirstDay 	:= FirstDay(dDataAcm)
    Local dLastDay   	:= LastDay(dDataAcm)
    Local nLastDay   	:=	0
    Local nX          := 0
    Local nTamData    := 0

    dbGoTop()
    dbSetOrder(3)  //Filial+Dt.VENCREA+NomeForn
    nLastDay := Day(LastDay(SE2->E2_VENCREA))
    nTamData := Iif(Len(Dtoc(SE2->E2_VENCREA)) == 10, 7, 5)

    For nX := 1 to nLastDay
        dDtSeek := DTOS(CTOD(STRZERO(nX)+"/"+Subs(DTOC(dDataAcm),4,nTamData)))
        ///Pesquisa todos titulos pendentes de retenção(ex.E2_PRETPIS='1') para o novo periodo deste titulo e seu fornecedor
        If dbSeek(xFilial("SE2")+dDtSeek+cNomeFor,.T.)
            //Encontrou a primeira ocorrencia de titulo para o fornecedor
            //A partir deste titulo ele vai acumulando todos os que tiverem dentro do range de datas
            While !Eof() .and. xFilial("SE2") == E2_FILIAL .and.	E2_NOMFOR == cNomeFor .and. ;
            (E2_VENCREA >= dFirstDay .and. E2_VENCREA <= dLastDay)


                If E2_FORNECE+E2_LOJA 	== 	cFornece+cLojaOri  	.And. ;
                SE2->E2_PRETPIS   	== 	'1' 						.And. ;
                nRegSe2					<>		SE2->(RECNO())
                    nValPisT 		  		+= 	SE2->E2_PIS
                    nValCofinsT				+= 	SE2->E2_COFINS
                    nValCsllT  				+= 	SE2->E2_CSLL
                    //Atualiza Situação de Retenção do titulo Retido
                    RecLock("SE2")
                    Replace E2_PRETPIS 	With 	'2'
                    Replace E2_PRETCOF 	With 	'2'
                    Replace E2_PRETCSL 	With 	'2'
                    MsUnLock()
                    FKCOMMIT()
                    //Grava Relacionamento(SFQ)
                    dbSelectArea("SFQ")
                    RecLock("SFQ",.T.)
                    SFQ->FQ_FILIAL  		:= 	xFilial("SFQ")
                    SFQ->FQ_ENTORI  		:= 	"SE2"
                    SFQ->FQ_PREFORI 		:= 	cPrefOri
                    SFQ->FQ_NUMORI  		:= 	cNumOri
                    SFQ->FQ_PARCORI 		:= 	cParcOri
                    SFQ->FQ_TIPOORI 		:= 	cTipoOri
                    SFQ->FQ_CFORI   		:= 	cCfOri
                    SFQ->FQ_LOJAORI 		:= 	cLojaOri
                    SFQ->FQ_FILDES			:=  SE2->E2_FILIAL
                    SFQ->FQ_ENTDES  		:= 	"SE2"
                    SFQ->FQ_PREFDES 		:= 	SE2->E2_PREFIXO
                    SFQ->FQ_NUMDES  		:= 	SE2->E2_NUM
                    SFQ->FQ_PARCDES 		:= 	SE2->E2_PARCELA
                    SFQ->FQ_TIPODES 		:= 	SE2->E2_TIPO
                    SFQ->FQ_CFDES   		:= 	SE2->E2_FORNECE
                    SFQ->FQ_LOJADES 		:= 	SE2->E2_LOJA
                    Msunlock()
                    lRet 	  					:= 	.T.
                EndIf
                SE2->(dbSkip())
            Enddo
        EndIf
    Next

    RestArea(aAreaSE2)
    RestArea(aArea)

    SE2->E2_VRETPIS	:=		nValPisT
    SE2->E2_VRETCOF	:=		nValCofinsT
    SE2->E2_VRETCSL	:=		nValCsllT

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050CpXml
Complementa o Xml recebido pelo EAI para preenchimento das
chaves primaria do protheus  

@author Jefferson Lima
@since 25/11/11
/*/
//-------------------------------------------------------------------
Function F050CpXml(  )

    Local cRet    	:= PARAMIXB[1]
    Local aArea		:= GetArea()
    Local oXml	 	:= Nil
    Local lRet      := .F.
    Local cCGC		:= ""
    Local nTotReg 	:= 0
    Local nRegAtu 	:= 1
    Local lIntGFE   := SuperGetMv('MV_INTGFE',,.F.)

    If lIntGFE
        oXml := tXmlManager():New()

        lRet := oXml:Parse(cRet)

        If lRet
            lRet := oXml:XPathHasNode("//FINA050/FINA050_SE2/E2_CGCFOR/value")
            If lRet
                cCgc := AllTrim( oXml:XPathGetNodeValue("//FINA050/FINA050_SE2/E2_CGCFOR", "value") )
                SA2->(DbSetOrder(3))
                If SA2->(MsSeek(xFilial("SA2") + cCgc))
                    While SA2->(!Eof()) .And. AllTrim( SA2->A2_CGC ) == cCgc
                        If SA2->A2_MSBLQL <> '1'
                            If oXml:XPathAddNode("//FINA050/FINA050_SE2","E2_FORNECE", '')
                                If oXml:XPathAddAtt("//FINA050/FINA050_SE2/E2_FORNECE","order","98")
                                    If oXml:XPathAddNode("//FINA050/FINA050_SE2","E2_LOJA"   , '')
                                        If oXml:XPathAddAtt("//FINA050/FINA050_SE2/E2_LOJA","order","99")
                                            If oXml:XPathAddNode("//FINA050/FINA050_SE2/E2_FORNECE","value", SA2->A2_COD)
                                                If oXml:XPathAddNode("//FINA050/FINA050_SE2/E2_LOJA"   ,"value", SA2->A2_LOJA)
                                                    cRet := oXml:Save2String()
                                                    If oXml:xPathHasNode("//FINA050/FINA050_SE2/FINA050_PRVSE2/items")
                                                        nTotReg := oXml:XPathChildCount("//FINA050/FINA050_SE2/FINA050_PRVSE2/items")
                                                        nRegAtu := 1
                                                        While nRegAtu <= nTotReg
                                                            If oXml:XPathAddNode("//FINA050/FINA050_SE2/FINA050_PRVSE2/items/item["+(AllTrim(Str(nRegAtu)))+"]","E2_FORNECE",SA2->A2_COD)
                                                                If oXml:XPathAddNode("//FINA050/FINA050_SE2/FINA050_PRVSE2/items/item["+(AllTrim(Str(nRegAtu)))+"]","E2_LOJA",SA2->A2_LOJA)
                                                                EndIf
                                                            EndIf
                                                            nRegAtu++
                                                        EndDo
                                                        cRet := oXml:Save2String()
                                                    EndIf
                                                EndIf
                                            EndIf
                                        EndIf
                                    EndIf
                                EndIf
                            EndIf
                            Exit
                        EndIf
                        SA2->(dbSkip())
                    EndDo
                EndIf
            EndIf
        EndIf
    EndIf

    RestArea(aArea)

Return cRet

//-------------------------------------------------------------------------------------------------------------
// Revitalização FINA050
// Funções exclusivas da localização EQU - Movidas por não ter cobertura da automação para essa localização
//-------------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050GetCC
Obter os dados do Cartão de Credito.	

@author Lucas
@since  18/08/10
/*/
//-------------------------------------------------------------------
Function Fa050GetCC(lSE2)

    Local aArea  	 := GetArea()
    Local nOpca  	 := 0
    Local aSizeTela  := MSADVSIZE()
    Local cCodAdm 	 := CriaVar("FRC_CODADM")
    Local cNumCartao := CriaVar("FRC_NUMCAR")
    Local cNomeAdm   := CriaVar("AE_DESC")
    Local cValidade  := Space(4)
    Local cCodSeg 	 := CriaVar("FRC_CODSEG")
    Local aParcelas  := {"01"} //,"02","03","04","05","06","07","08","09","10","11","12"}
    Local cParcela   := "01"
    Local aPicture   := Array(4)
    Local oCbxParc
    Local oDlgCC
    Local aTitulos   := {}

    aPicture[1] := PesqPict("FRC","FRC_CODADM", TamSX3("FRC_CODADM"))
    aPicture[2] := PesqPict("FRC","FRC_NUMCAR", TamSX3("FRC_NUMCAR"))
    aPicture[3] := PesqPict("SAE","AE_DESC"   , TamSX3("AE_DESC"))
    aPicture[4] := PesqPict("FRC","FRC_CODSEG", TamSX3("FRC_CODSEG"))

    dbSelectArea("FRC")

    DEFINE MSDIALOG oDlgCC TITLE STR0018 From aSizeTela[7],0 To aSizeTela[6],aSizeTela[5] OF oMainWnd PIXEL // "Informe Dados do Cartão de Credito"

    @ 027,010 SAY STR0019	PIXEL OF oDlgCC COLOR CLR_HBLUE // "Administradora"
    @ 025,060 MSGET cCodAdm F3 "SAE" Picture aPicture[1] SIZE 40,08		Valid Fa050CodAdm(cCodAdm,@cNomeAdm)		PIXEL OF oDlgCC
    @ 025,120 MSGET cNomeAdm         Picture aPicture[3] SIZE 170,08		PIXEL OF oDlgCC WHEN .F.

    @ 042,010 SAY STR0020	PIXEL OF oDlgCC COLOR CLR_HBLUE // "Numero do Cartão"
    @ 040,060 MSGET cNumCartao		 Picture aPicture[2] SIZE 120,08 	Valid Fa050NumCart(cNumCartao)	PIXEL OF oDlgCC

    @ 057,010 SAY STR0021	PIXEL OF oDlgCC COLOR CLR_HBLUE // "Validade"
    @ 055,060 MSGET cValidade		 Picture "@R 99/99"	 SIZE 30,08 	Valid Fa050Valid(cValidade)		PIXEL OF oDlgCC

    @ 072,010 SAY STR0022	PIXEL OF oDlgCC					//"Código Segurança"
    @ 070,060 MSGET cCodSeg			 Picture aPicture[4] SIZE 30,08 Valid Fa050CodSeg()					PIXEL OF oDlgCC
    @ 070,100 SAY STR0023	PIXEL OF oDlgCC

    @ 087,010 SAY STR0024 	 PIXEL OF oDlgCC
    @ 085,060 MSCOMBOBOX oCbxParc  VAR cParcela		ITEMS aParcelas SIZE 60, 54 WHEN !lSE2	PIXEL OF oDlgCC	//ON CHANGE (nMoedSubs := Val(Substr(cMoeda,1,2)))

    ACTIVATE MSDIALOG oDlgCC ON INIT EnchoiceBar(oDlgCC,{|| (nOpca := 1,oDlgCC:End())},{|| nOpca := 2,oDlgCC:End()})

    //Gravar titulos em um array para posterior substituição.
    If nOpca == 1
        If lSE2
            nPosicao := Ascan(aTitulos, { |x| x[1]+x[2]+x[3]+[4] == SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO })
            If nPosicao == 0
                AADD(aTitulos,{SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,cCodAdm,cNumCartao,cValidade,cCodSeg,cParcela})
            Else
                aTitulos[nPosicao][1]:= SE2->E2_PREFIXO
                aTitulos[nPosicao][2]:= SE2->E2_NUM
                aTitulos[nPosicao][3]:= SE2->E2_PARCELA
                aTitulos[nPosicao][4]:= SE2->E2_TIPO
                aTitulos[nPosicao][5]:= cCodAdm
                aTitulos[nPosicao][6]:= cNumCartao
                aTitulos[nPosicao][7]:= cValidade
                aTitulos[nPosicao][8]:= cCodSeg
                aTitulos[nPosicao][9]:= cParcela
            EndIf
        Else
            nPosicao := Ascan(aTitulo2CC, { |x| x[1]+x[2]+x[3]+[4] == __SUBS->E2_PREFIXO+__SUBS->E2_NUM+__SUBS->E2_PARCELA+__SUBS->E2_TIPO })
            If nPosicao == 0
                AADD(aTitulo2CC,{__SUBS->E2_PREFIXO,__SUBS->E2_NUM,__SUBS->E2_PARCELA,__SUBS->E2_TIPO,cCodAdm,cNumCartao,cValidade,cCodSeg,cParcela})
            Else
                aTitulo2CC[nPosicao][1]:= __SUBS->E2_PREFIXO
                aTitulo2CC[nPosicao][2]:= __SUBS->E2_NUM
                aTitulo2CC[nPosicao][3]:= __SUBS->E2_PARCELA
                aTitulo2CC[nPosicao][4]:= __SUBS->E2_TIPO
                aTitulo2CC[nPosicao][5]:= cCodAdm
                aTitulo2CC[nPosicao][6]:= cNumCartao
                aTitulo2CC[nPosicao][7]:= cValidade
                aTitulo2CC[nPosicao][8]:= cCodSeg
                aTitulo2CC[nPosicao][9]:= cParcela
            EndIf
        EndIf
    Else
        aTitulo2CC := {}
    EndIf

    RestArea(aArea)

Return( If(lSE2,aTitulos,) )

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050CodAdm
Validar Codigo da Administradora de Cartão de Credito.

@author José Lucas
@since  20/08/10
/*/
//-------------------------------------------------------------------
Function Fa050CodAdm( cCodAdm, cNomeAdm )

    Local lResult := .T.

    If Empty(cCodAdm)
        MsgAlert(STR0025,STR0014)	//"Informe o Codigo da Administradora !" ### Atenção
        lResult := .F.
    EndIf
    If lResult
        SAE->(dbSetOrder(1))
        If ! SAE->(dbSeek(xFilial("SAE")+cCodAdm))
            MsgAlert(STR0026,STR0014)	//"Administradora de Cartões Invalida !" ### Atenção
            lResult := .F.
        Else
            cNomeAdm := SAE->AE_DESC
        EndIf
    EndIf

Return (lResult)

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050NumCart
Verifica se o número do cartão digitado é válido.

@author José Lucas
@since  20/08/10
/*/
//-------------------------------------------------------------------
Function Fa050NumCart( cNumCartao )
    Local lResult := .T.
    If Empty(cNumCartao)
        MsgAlert(STR0027,STR0014)	//"É obrigatório o preenchimento do número do cartão !" ### Atenção
        lResult := .F.
    ElseIf Len(AllTrim(cNumCartao))>19
        MsgAlert(STR0028,STR0014)	//"Número do Cartão maior que 19 dígitos !" ### Atenção
        lResult := .F.
    EndIf
Return (lResult)

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050Valid
Verifica se a validade do cartão do cartão digitado é válido. 

@author José Lucas
@since  20/08/10
/*/
//-------------------------------------------------------------------
Function Fa050Valid( cValid )
    Local lResult := .T.
    Local dValid  := CTOD("")

    If Empty(cValid)
        MsgAlert(STR0029,STR0014)	//"É obrigatório o preenchimento do validade do cartão !" ### Atenção
        lResult := .F.
    EndIf
    If lResult
        //Consistir mes e ano de validade do cartão.
        If Subs(cValid,1,2) < "01" .or. Subs(cValid,1,2) > "12"
            MsgAlert(STR0030,STR0014)	//"Mes Informado invalido !" ### Atenção
            lResult := .F.
        EndIf
        If "20"+Subs(cValid,3,2) < StrZero(Year(dDataBase),4)
            MsgAlert(STR0031,STR0014)	//"Ano Informado invalido !" ### Atenção
            lResult := .F.
        EndIf
    EndIf
    If lResult
        //Consitir mes no mesmo ano da dDataBase.
        If Subs(cValid,1,2) < StrZero(Month(dDatabase),2) .and. "20"+Subs(cValid,3,2) == StrZero(Year(dDataBase),4)
            MsgAlert(STR0032,STR0014)	//"Cartão com validade vencida !" ### Atenção
            lResult := .F.
        EndIf
        //Consitir último dia de validade do cartão, quando mes igual a dDataBase.
        If Subs(cValid,1,2) == StrZero(Month(dDatabase),2)
            dValid := Subs(DTOC(LastDay(dDataBase)),1,2)
            dValid += "/"+Subs(cValid,1,2)+"/"+Subs(cValid,3,2)
            dValid := CTOD(dValid)
            If dValid < dDataBase
                MsgAlert(STR0032,STR0014)	//"Cartão com validade vencida !" ### Atenção
                lResult := .F.
            EndIf
        EndIf
    EndIf
Return (lResult)

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050CodSeg
Verifica se o código de segurança do cartão digitado é válido.

@author José Lucas
@since  20/08/10
/*/
//-------------------------------------------------------------------
Function Fa050CodSeg( cCodSeg )
    Local lResult := .T.

    If Empty(cCodSeg)
        lResult := .T.
    EndIf
Return (lResult)

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050Tit2CC
Substituir títulos por títulos contra a Administradora de Cartão de Credito
mantendo o titulo original baixado. 

@author José Lucas
@since  20/08/10
/*/
//-------------------------------------------------------------------
Function Fa050Tit2CC()

    Local aArea 	:= GetArea()
    Local lDivide   := GetNewPar("MV_DIVTCC","1") == "1"
    Local lEdita    := GetNewPar("MV_EDITCC","1") == "2"
    LOCAL cIndex 		:= ""
    Local lPadrao   := .F.
    Local cPadrao   := "533"
    Local cArquivo  := ""
    Local nHdlPrv   := 0
    Local nTotal    := 0
    Local nRecSubs  := 0
    Local nRecSE2 := SE2->(RECNO())
    Local nTotalParc := 0.00
    Local nValTotal  := SE2->E2_VALOR
    Local nParcela   := 1
    Local nValorSE2  := 0.00
    Local nCount     := 0
    Local nReg       := SE2->(RecNo())
    Local lSubsSuces := .F.
    Local nC         := 0
    Local aCampos    := {}
    Local lAtuSldNat := .T.
    Local cParcela 	 := GetMV("MV_1DUP")

    VALOR 		:= 0
    VLRINSTR 	:= 0

    If Len(aTitulo2CC) > 0

        For nCount := 1 To Len(aTitulo2CC)

            dbSelectArea("SE2")
            dbSetOrder(1)
            dbSeek(xFilial("SE2")+aTitulo2CC[nCount][1]+aTitulo2CC[nCount][2]+aTitulo2CC[nCount][3]+aTitulo2CC[nCount][4])

            If lDivide .and. aTitulo2CC[nCount][09] <> "01"
                nTotalParc := Val(aTitulo2CC[nCount][09])
            Else
                nTotalParc := 1
            EndIf

            nValTotal  := SE2->E2_VALOR
            nValorSE2  := nValTotal/nTotalParc

            For nParcela := 1 To nTotalParc
                nOpc:=3			 //Inclusao
                lSubst:=.T.
                lSubsSuces := .F.
                If lEdita    	//Abre Enchoice para editar os títulos a Substituir...
                    lSubsSuces := FA050Inclu("SE2",nReg,nOpc,,,lSubst) == 1
                    //Ajustar Tipo do Título.
                    RecLock("SE2",.F.)
                    E2_TIPO    := "CC"
                    MsUnLock()
                Else
                    aCampos := {}
                    For nC := 1 To SE2->(FCount())
                        If SE2->(FieldName(nC)) == "E2_PARCELA"
                            AADD(aCampos,{SE2->(FieldName(nC)),cParcela})
                        ElseIf SE2->(FieldName(nC)) == "E2_TIPO"
                            AADD(aCampos,{SE2->(FieldName(nC)),"CC"})
                        Else
                            AADD(aCampos,{SE2->(FieldName(nC)),SE2->(FieldGet(nC))})
                        EndIf
                    Next nC
                    RecLock("SE2",.T.)
                    For nC := 1 To Len(aCampos)
                        FieldPut(nC,aCampos[nC,2])
                    Next nC
                    E2_VALOR 	:= nValorSe2
                    E2_SALDO 	:= E2_VALOR
                    E2_VALLIQ   := E2_VALOR
                    If nParcela > 1
                        E2_PARCELA := Soma1(cParcela)
                    EndIf
                    If nParcela == nTotalParc
                        E2_VALOR  += (nValTotal-(E2_VALOR*nTotalParc))
                        E2_SALDO  := E2_VALOR
                        E2_VALLIQ := E2_VALOR
                    EndIf
                    MsUnLock()
                    lSubsSuces := .T.
                EndIf
                If lSubsSuces
                    //Incluir registros na tabela de Controle de Títulos a pagar por Cartão de Credito
                    dbSelectArea("FRC")
                    RecLock("FRC",.T.)
                    FRC_FILIAL := xFilial("FRC")
                    FRC_DATTEF := dDataBase
                    FRC_HORTEF := Subs(Time(),1,5)
                    FRC_DOCTEF := "" //Reservado para implementação futura quando localizar e integrar o SigaLoja no Equador
                    FRC_AUTORI := "" //Idem.
                    FRC_NSUTEF := "" //Idem.
                    FRC_STATUS := "01"
                    FRC_MOTIVO := ""
                    FRC_TIPCAR := "CC"
                    FRC_PREFIX := SE2->E2_PREFIXO
                    FRC_NUM	   := SE2->E2_NUM
                    FRC_PARCEL := SE2->E2_PARCELA
                    FRC_TIPO   := SE2->E2_TIPO
                    FRC_CODADM := aTitulo2CC[nCount][5]
                    FRC_NUMCAR := aTitulo2CC[nCount][6]
                    FRC_DATVAL := aTitulo2CC[nCount][7]
                    FRC_CODSEG := aTitulo2CC[nCount][8]
                    FRC_NUMPAR := nParcela
                    FRC_SEQOPE := "1"
                    FRC_FORMA  := "CC"	//Substituir por SE4->E4_FORMA
                    FRC_VALOR  := SE2->E2_VALOR
                    FRC_FORNEC := SE2->E2_FORNECE
                    FRC_LOJA   := SE2->E2_LOJA
                    If cPaisLoc == "EQU"
                        FRC->FRC_PREORI := aTitulo2CC[nCount][1]
                        FRC->FRC_NUMORI := aTitulo2CC[nCount][2]
                        FRC->FRC_PARORI := aTitulo2CC[nCount][3]
                        FRC->FRC_TIPORI := aTitulo2CC[nCount][4]
                    EndIf
                    MsUnLock()
                EndIf
                lSubst:=.F.
                //Só contabilizar após a gravação da última parcela do Cartão de Credito.
                If nParcela <> nTotalParc
                    Loop
                EndIf
                If ( lPadrao )
                    // Inicializa Lancamento Contabil                                  
                    nHdlPrv := HeadProva( cLote,;
                    "FINA050" /*cPrograma*/,;
                    Substr(cUsuario,7,6),;
                    @cArquivo )
                EndIf

                // Inicializa a gravacao dos lancamentos do SIGAPCO         
                PcoIniLan("000002")

                If ! lF050Auto
                    dbSelectArea("__SUBS")
                    dbGoTop()
                    While !Eof()
                        If E2_OK == cMarca
                            nRecSubs := RecNo()
                            dbSelectArea("SE2")
                            dbGoto(nRecSubs)
                            If ( lPadrao )
                                // Prepara Lancamento Contabil                                     
                                If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
                                    aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
                                Endif
                                nTotal += DetProva( nHdlPrv,;
                                cPadrao,;
                                "FINA050" /*cPrograma*/,;
                                cLote,;
                                /*nLinha*/,;
                                /*lExecuta*/,;
                                /*cCriterio*/,;
                                /*lRateio*/,;
                                /*cChaveBusca*/,;
                                /*aCT5*/,;
                                /*lPosiciona*/,;
                                @aFlagCTB,;
                                /*aTabRecOri*/,;
                                /*aDadosProva*/ )
                            EndIf

                            dbSelectArea("SE2")
                            dbSetOrder(1)
                            If dbSeek(xFilial("SE2")+aTitulo2CC[nCount][1]+aTitulo2CC[nCount][2]+aTitulo2CC[nCount][3]+aTitulo2CC[nCount][4])

                                // Atualizacao dos dados do Modulo SIGAPMS   
                                If IntePms().AND. !__lPmsInt
                                    PmsWriteFI(2,"SE2")	//Estorno
                                    PmsWriteFI(3,"SE2")	//Exclusao
                                EndIF

                                // Chama a integracao com o SIGAPCO antes de apagar o titulo
                                PcoDetLan("000002","01","FINA050",.T.)

                                If __lF50PROV
                                    ExecBlock("F050PROV",.F.,.F.)
                                Endif
                                If lAtuSldNat  .And. SE2->E2_FLUXO == 'S'
                                    AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),nOpc)
                                Endif

                                FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                                Reclock("SE2",.F.,.T.)
                                dbDelete()
                                MsUnlock()
                            EndIf
                        Endif
                        dbSelectArea("__SUBS")
                        dbSkip()
                    Enddo
                Else
                    If ( lPadrao )
                        // Prepara Lancamento Contabil                                     
                        If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
                            aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
                        Endif
                        nTotal += DetProva( nHdlPrv,;
                        cPadrao,;
                        "FINA050" /*cPrograma*/,;
                        cLote,;
                        /*nLinha*/,;
                        /*lExecuta*/,;
                        /*cCriterio*/,;
                        /*lRateio*/,;
                        /*cChaveBusca*/,;
                        /*aCT5*/,;
                        /*lPosiciona*/,;
                        @aFlagCTB,;
                        /*aTabRecOri*/,;
                        /*aDadosProva*/ )
                    EndIf

                    dbSelectArea("SE2")
                    dbSetOrder(1)
                    If dbSeek(xFilial("SE2")+aTitulo2CC[nCount][1]+aTitulo2CC[nCount][2]+aTitulo2CC[nCount][3]+aTitulo2CC[nCount][4])

                        If IntePms().AND. !__lPmsInt
                            // Atualizacao dos dados do Modulo SIGAPMS   

                            PmsWriteFI(2,"SE2")	//Estorno
                            PmsWriteFI(3,"SE2")	//Exclusao
                        EndIf

                        // Chama a integracao com o SIGAPCO antes de apagar o titulo
                        PcoDetLan("000002","01","FINA050",.T.)
                        If lAtuSldNat   .And. SE2->E2_FLUXO == 'S'
                            AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, S2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, "-",,FunName(),"SE2",SE2->(Recno()),3)
                        Endif

                        FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                        Reclock("SE2",.F.,.T.)
                        dbDelete()
                        MsUnlock()
                    Endif
                EndIf

                // Finaliza a gravacao dos lancamentos do SIGAPCO         
                PcoFinLan("000002")

                // Contabiliza a diferenca               				 
                dbSelectArea("SE2")
                nRecSE2 := Recno()
                dbGoBottom()
                dbSkip()
                VALOR := (nValorS - nValorSe2)
                VLRINSTR := VALOR
                If nTotal > 0
                    // Prepara Lancamento Contabil                                     
                    //Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
                    nTotal += DetProva( nHdlPrv,;
                    cPadrao,;
                    "FINA050" /*cPrograma*/,;
                    cLote,;
                    /*nLinha*/,;
                    /*lExecuta*/,;
                    /*cCriterio*/,;
                    /*lRateio*/,;
                    /*cChaveBusca*/,;
                    /*aCT5*/,;
                    /*lPosiciona*/,;
                    /*@aFlagCTB*/,;
                    /*aTabRecOri*/,;
                    /*aDadosProva*/ )
                Endif
                dbSelectArea("SE2")
                dbGoTo(nRecSE2)
                If nTotal > 0
                    // Envia para Lancamento Contabil							 
                    If  UsaSeqCor()
                        aDiario := {}
                        aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
                    Else
                        aDiario := {}
                    EndIf
					// Efetiva Lancamento Contabil                                     
                    RodaProva( nHdlPrv,;
                    nTotal )
                    cA100Incl( cArquivo,;
                    nHdlPrv,;
                    3 /*nOpcx*/,;
                    cLote,;
                    ( mv_par01 == 1 ) /*lDigita*/,;
                    ( mv_par07 == 1 ) /*lAglut*/,;
                    /*cOnLine*/,;
                    /*dData*/,;
                    /*dReproc*/,;
                    @aFlagCTB,;
                    /*aDadosProva*/,;
                    aDiario )
                    aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
                EndIf
            Next nParcela
        Next nCount

        If !Empty(aChaveLbn)
            aEval(aChaveLbn, {|e| UnLockByName(e,.T.,.F.) } ) // Libera Lock
        Endif
        VALOR    := 0
        VLSINSTR := 0
        If Select("__SUBS") > 0
            dbSelectArea("__SUBS")
            dbCloseArea()
            Ferase(cIndex+OrdBagExt())
        Endif
        dbSelectArea("SE2")
        If ! lF050Auto
            RetIndex("SE2")
            dbGoto(nReg)
        EndIf
    EndIf

    RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050GrvFRC
Substituir títulos por títulos contra a Administradora de
Cartão de Credito, mantendo o titulo original baixado.

@author José Lucas
@since  20/08/10
/*/
//-------------------------------------------------------------------
Function Fa050GrvFRC(aTituloCC)

    Local aArea   := GetArea()
    Local lAppend := .F.

    If Len(aTituloCC) > 0
        //Incluir ou alterar registros na tabela de Controle de Títulos a pagar por Cartão de Credito
        dbSelectArea("FRC")
        dbSetOrder(1)
        If !dbSeek(xFilial("FRC")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)
            lAppend := .T.
        Else
            lAppend := .F.
        EndIf
        RecLock("FRC",lAppend)
        FRC_FILIAL := xFilial("FRC")
        FRC_DATTEF := dDataBase
        FRC_HORTEF := Subs(Time(),1,5)
        FRC_DOCTEF := "" //Reservado para implementação futura quando localizar e integrar o SigaLoja no Equador
        FRC_AUTORI := "" //Idem.
        FRC_NSUTEF := "" //Idem.
        FRC_STATUS := "01"
        FRC_MOTIVO := ""
        FRC_TIPCAR := "CC"
        FRC_PREFIX := SE2->E2_PREFIXO
        FRC_NUM	   := SE2->E2_NUM
        FRC_PARCEL := SE2->E2_PARCELA
        FRC_TIPO   := SE2->E2_TIPO
        FRC_CODADM := aTituloCC[Len(aTituloCC)][5]
        FRC_NUMCAR := aTituloCC[Len(aTituloCC)][6]
        FRC_DATVAL := aTituloCC[Len(aTituloCC)][7]
        FRC_CODSEG := aTituloCC[Len(aTituloCC)][8]
        FRC_NUMPAR := 1
        FRC_SEQOPE := "1"
        FRC_FORMA  := "CC"	//Substituir por SE4->E4_FORMA
        FRC_VALOR  := SE2->E2_VALOR
        FRC_FORNEC := SE2->E2_FORNECE
        FRC_LOJA   := SE2->E2_LOJA
        If cPaisLoc == "EQU"
            FRC->FRC_PREORI := aTitulo2CC[nCount][1]
            FRC->FRC_NUMORI := aTitulo2CC[nCount][2]
            FRC->FRC_PARORI := aTitulo2CC[nCount][3]
            FRC->FRC_TIPORI := aTitulo2CC[nCount][4]
        EndIf
        MsUnLock()
    EndIf

    RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050DelFRC
Apagar titulos do Tipo "CC" na tabela FRC para controle
das operações a receber através de Cartão de Credito.

@author José Lucas
@since  20/08/10
/*/
//-------------------------------------------------------------------
Function Fa050DelFRC(aTituloCC)
    Local aArea   := GetArea()

    //Excluir registros na tabela de Controle de Títulos a pagar por Cartão de Credito
    FRC->(dbSetOrder(1))
    If FRC->(dbSeek(xFilial("FRC")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA))
        If FRC->FRC_STATUS == "01"	//Em analise
            RecLock("FRC",.F.)
            dbDelete()
            MsUnLock()
        EndIf
    EndIf

    RestArea(aArea)
Return


/*/{Protheus.doc} VldRasDsd
    Função responsavel por validar o conteudo do parametro 
    MV_NRASDSD, sera utilizada no when dos campos E2_VALOR 
    E1_VALOR (DSERFINP-28959)
    @type  Function
    @author Vitor Duca
    @since 05/02/2020
    @version 1.0
    @param param, param_type, param_descr
    @return lRet, Booleano, When do campo E2_VALOR/E1_VALOR
    @see (links_or_references)
/*/
Function VldRasDsd(cTemDsd As Character) As Logical
    Local lNRastDSD As Logical
    Local lRet      As Logical
    Local lBlVlDes  As Logical 

    Default cTemDsd := "N"

    lRet       := .T.
    lNRastDSD  := SuperGetMV("MV_NRASDSD",.T.,.F.)
    lBlVlDes   := SuperGetMv("MV_BLVLDES",.T.,.T.)

    If AllTrim(cTemDsd) $ 'S|1' .And. (!lNRastDSD .And. lBlVlDes)
        lRet := .F.
    Endif    

Return lRet

//-------------------------------------------------------------------------
/*/{Protheus.doc} f050AltCmp
Verifica se os campos informados via ExecAuto estão liberados para alteração.

@type  Function
@author Vinicius do Prado
@since  30/06/2020
@version 1.0

@param aCposLiber, array, contém os campos que podem ser alterados.
@param aAutoCab, array, contém os campos informados através da ExecAuto.
@return lRet, lógico, .T. se todos os campos informados podem ser alterados .F. caso contrario.
/*/
//-------------------------------------------------------------------------
Function F050AltCmp(aCposLiber As Array, aAutoCab As Array) As Logical
    Local lRet As Logical
    Local cCmpBloq As Character
    Local oHash As Object
    Local nX As Numeric
    Local aRet As Array
    Local nY As Numeric
    Local cChavePK As Character
    Local nPosE2Val As Numeric

    Default aCposLiber := {}
    Default aAutoCab   := {}

    cChavePK := StrTran(SE2->(IndexKey()),"+","|")
    lRet := .T.
    nX := 0
    nY := 0
    oHash := THashMap():New()
    cCmpBloq := ""
    nPosE2Val := 0

    If FwIsInCallStack("MATA984")
        For nX := 1 To len(aCposLiber)
            oHash:Set(aCposLiber[nX],aCposLiber[nX])
        Next nX

        For nY := 1 To len(aAutoCab)    
            aRet := {}
            If !oHash:Get(aAutoCab[nY,1],@aRet) .and. !aAutoCab[nY,1] $ cChavePK
                cCmpBloq := aAutoCab[nY,1]
                Exit  
            Endif    
        Next nY
    Else
        nPosE2Val := ASCAN( aAutoCab, {|x| UPPER( AllTrim( x[1] ) ) == "E2_VALOR"} ) 
        If nPosE2Val > 0
            If aAutoCab[nPosE2Val,2] <> SE2->E2_VALOR .And. ASCAN(aCposLiber, "E2_VALOR") == 0
                cCmpBloq := "E2_VALOR"
            EndIf
        EndIf
    Endif    
    
    If !Empty(cCmpBloq)
        lRet := .F.
        Help(,, "NOALTCAMPO",, STR0041 + cCmpBloq + STR0042, 1, 0) //"O campo " ## " não está liberado para alteração."
    EndIf

    oHash:Clean()
    FwFreeObj(oHash)

Return lRet

//-------------------------------------------------------------------------
/*/{Protheus.doc} CalcEmpP
Calcula os valores de Pis, cofins e Csll para empresa publica

@type  Function
@author Rene Julian
@since  24/03/2021
@version 1.0

@param nBasePis, Numerico, Base do Pis
@param nBaseCof, Numerico, Base do Cofins
@param nBaseCsl, Numerico, Base do Csll
@return aRet, Array, Retorna os valores do PCC pelo porcentagem da natureza.
/*/
//-------------------------------------------------------------------------
Function CalcEmpP( nBasePis As Numeric, nBaseCof As Numeric , nBaseCsl As Numeric) As Array
    Local aRet      As Array

    Default nBasePis := 0
    Default nBaseCof := 0
    Default nBaseCsl := 0

    aRet := Array(5)


    aRet[1] := .T.

    aRet[2] := (xMoeda(nBasePis,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA) * (SED->ED_PERCPIS / 100) )

    aRet[3] := (xMoeda(nBaseCof,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA) * (SED->ED_PERCCOF / 100) )

    aRet[4] := (xMoeda(nBaseCsl,M->E2_MOEDA,1,M->E2_EMISSAO,MsDecimais(1)+1,M->E2_TXMOEDA) * (SED->ED_PERCCSL / 100) )

    aRet[5] := {}

Return aRet 

/*/{Protheus.doc} FinWizFac
    Facilitador de alteração nos titulos 
    @type  Function
    @author Vitor Duca
    @param, cAlias, Character, Alias da tabela que sera verificado os campos serão usado no facilitador
    @since 25/05/2021
    @version 1.0
/*/
Function FinWizFac(cAlias)
    Local cCmps As Character
    Local cExplog As character

    Default cAlias := 'SE2'

    cCmps	:= "E2_VENCTO/E2_VENCREA/E2_HIST/"
    cExplog := "E2_PREFIXO + '-' + E2_NUM + '-' + E2_PARCELA + '-' + E2_TIPO + '-' + E2_FORNECE + '-' + E2_LOJA"

    If cAlias == "SE1"
        cCmps	:= "E1_VENCTO/E1_VENCREA/E1_HIST/"
        cExplog := "E1_PREFIXO + '-' + E1_NUM + '-' + E1_PARCELA + '-' + E1_TIPO + '-' + E1_CLIENTE + '-' + E1_LOJA"
    Endif

    MATA984(cAlias,/*cExpFim*/,cCmps,/*aTxtApre*/,cExplog)

Return .T.
//-------------------------------------------------------------------
/*/{Protheus.doc} VldNatRen
Verifica se a Natureza de Rendimento pode ser utilizada, 
de acordo com as regras estabelecidas na tabela 01 da EFD-REINF (bloco 40).

@param cNatRen - char - Natureza de rendimento a ser validada
@param cCart   - char - Carteira (1=Pagar/2=Receber)
@param cForCli - char - Código do fornecedor/cliente
@param cLoja   - char - Código da loja do fornecedor/cliente

@return lRet Retorna .T. se a natureza de rendimento pode ser utilizada

@author Fabio Casagrande Lima
@since 18/10/2022
@version P12
/*/
//-------------------------------------------------------------------
Function VldNatRen(cNatRen As Character, cCart As Character, cForCli As Character, cLoja As Character, cNatTit As Character, lHelp As Logical) As Logical

	Local aArea 	 As Array
	Local cMsg       As Character
    Local cCpo       As Character
    Local cNatDecl   As Character
    Local lCallStack As Logical
	Local lRet 		 As Logical
    Local nTipoSM0   As Numeric
	
    Default cCart   := ""
    Default cForCli := ""
    Default cLoja   := ""
    Default cNatRen := ""
    Default cNatTit := ""
    Default lHelp   := .T.

	aArea 	    := GetArea()
	lRet 	    := .T.
	cMsg        := ""
    cCpo        := AllTrim(ReadVar())
    lCallStack  := FwIsInCallStack("A410LinOk") .Or. FwIsInCallStack("Tk273EvaLi")

	dbSelectArea("FKX")
    FKX->(dbSetOrder(1)) //FKX_FILIAL+FKX_CODIGO
    FKX->(MsSeek(xFilial('FKX')+cNatRen))

    //Valida se a natureza de rendimento pode ser usada na filial de acordo com o tipo de inscrição do SIGAMAT (CPF/CNPJ) 
    nTipoSM0 := FWSM0Util():GetSM0Data(cEmpAnt,cFilAnt,{'M0_TPINSC'})[1][2] //1=CEI|2=CNPJ|3=CPF|4=INCRA
	cNatDecl := FKX->FKX_TPDECL

    If (nTipoSM0 == 2 .or. Empty(nTipoSM0)) .and. cNatDecl == "1" 
 	    lRet := .F.
        cMsg := STR0043 //"A natureza de rendimento selecionada deve ser usada em uma filial inscrita sobre um CPF (campo M0_TPINSC)."
    Elseif nTipoSM0 == 3 .and. cNatDecl == "2" 
 	    lRet := .F.
        cMsg := STR0044 //"A natureza de rendimento selecionada deve ser usada em uma filial inscrita sobre um CNPJ (campo M0_TPINSC)."
    Endif   

	If lRet .and. cCart == "1" //Validações exclusivas da carteira a pagar
        dbSelectArea("SA2")
        SA2->(dbSetOrder(1))
        SA2->(MsSeek(xFilial('SA2')+cForCli+cLoja))

        //Valida se pode usar a natureza de rendimento com fornecedor do exterior
        If SA2->A2_TIPO == "X" .and. SA2->A2_EST=="EX" .and. !Empty(cNatRen) .And. !(FKX->FKX_EXTPF$"1|2" .OR. FKX->FKX_EXTPJ$"1|2") 
 	        lRet := .F.
		    cMsg := STR0045	//"A natureza de rendimento selecionada não pode ser utilizada para fornecedores do exterior."
        Endif
	Elseif lRet .and. cCart == "2" //Validações exclusivas da carteira a receber
        dbSelectArea("SA1")
        SA1->(dbSetOrder(1))
        SA1->(MsSeek(xFilial('SA1')+cForCli+cLoja))  

         //Valida se pode usar a natureza de rendimento com cliente do exterior
        If SA1->A1_TIPO == "X" .and. SA1->A1_EST=="EX" .and. !Empty(cNatRen) .And. !(FKX->FKX_EXTPF$"1|2" .OR. FKX->FKX_EXTPJ$"1|2") 
			lRet := .F.
		    cMsg := STR0046	//"A natureza de rendimento selecionada não pode ser utilizada para clientes do exterior."
        Endif       

        If lRet .and. !Substr(cNatRen,1,2) $ "20|  " //Grupo 20 da "tabela 01" possui as naturezas de rendimento de recebimento
 	        lRet := .F.
		    cMsg := STR0047 	//"A natureza de rendimento selecionada não pode ser utilizada para recebimentos."
            
            //Validação para pedido de venda e televendas
            If lCallStack .Or. cCpo $ "M->C6_NATREN|M->UB_NATREN"
                cMsg := STR0049
            EndIf
        Endif

	EndIf

	If Existblock("VldNatRen",)
		aRet := ExecBlock("VldNatRen", .F., .F., {cNatRen, cCart, cForCli, cLoja, cNatTit})
        If Len(aRet)==2
            lRet := aRet[1] //Retorna .F. se a natureza de rendimento não é valida
            cMsg := aRet[2] //Retorna a mensagem com o problema a ser exibido ao usuário
        Endif
	EndIf    

	If !lRet .and. !Empty(cMsg) .and. lHelp .and. !(lCallStack .Or. cCpo $ "M->C6_NATREN|M->UB_NATREN")
        Help(" ",, "NATREN",, cMsg, 2, 0,,,,,,{STR0048})
    ElseIf !lRet .and. !Empty(cMsg) .and. lHelp 
        Help(" ",, "NATREN",, cMsg, 2, 0,,,,,,{STR0050})
	EndIf

	RestArea(aArea)

Return lRet

//-------------------------------------------------------------------------
/*/{Protheus.doc} FSubCpoObg
Função para verificar campos que possuam conteúdo para rotinas automáticas.

@author Victor Azevedo
@since  12/07/2023
@param aCposAuto, Array, Matriz contendo os campos que serão enviados na execauto.
@param cTabOri, Character, Tabela que será feita a leitura dos campos obrigatórios.
@version 12
/*/
//-------------------------------------------------------------------------
Function FSubCpoObg(aCposAuto as Array, cTabOri As Character) As Array
   
    Local aArea     As Array
    Local oFields   As Object
    Local nPosCpo   As Numeric
    Local nSubPos   As Numeric
    Local nX        As Numeric
    Local cCampos   As Character
    Local cGetCpo   As Character

    Default aCposAuto   := {}
    Default cTabOri     := "SE2"    

    aArea       := GetArea()
    oFields     := FWSX3Util():GetAllFields(cTabOri)
    nPosCpo     := 0
    nSubPos     := 0
    nX          := 0
    cCampos     := ""
    cGetCpo     := ""
    
	For nX := 1 to Len(oFields)
		cCampos	:= AllTrim(Upper(oFields[nX]))
		nPosCpo := ASCAN(aCposAuto,{|x|AllTrim(Upper(x[1])) == cCampos })
		If !("_MSUID" $ cCampos) .and. nPosCpo == 0 .And. X3Uso(GetSX3Cache(cCampos,"X3_USADO")); 
		.And. GetSx3Cache(cCampos,"X3_CONTEXT") != "V" .And. GetSx3Cache(cCampos,"X3_TIPO") != "M"
			nSubPos := (cTabOri)->(FieldPos(cCampos))
            cGetCpo := (cTabOri)->(FieldGet(nSubPos))
			If nSubPos > 0 .And. !Empty(cGetCpo)
				Aadd(aCposAuto, {cCampos, cGetCpo, NIL })
			EndIf
		EndIf
	Next

    RestArea(aArea)
    FwFreeArray(aArea)
    FreeObj(oFields)

Return (aCposAuto)

//--------------------------------------------------
/*/{Protheus.doc} Fin040Num
Validacao complementar do numero do título a receber digitado,
verificando se a chave do título já não está sendo usada em outra
sessão do sistema.

Observações: 
    1) A função é chamada no X3_VALID do campo E1_NUM.
    2) Essa função substitui a chamama do FREEFORUSE direto do SX3;
    3) Há outras validações do E1_NUM na função FA040Num (FINXFIN).

@author fabio.casagrande
@since 31/01/2024
@version P12.1.2310

@return lRet, Retorna se o numero pode ser usado
/*/
//--------------------------------------------------
Function F40NumUse() As Logical

    Local cChave As Char
    Local lRet As Logical

    lRet := .F.
    cChave := M->E1_NUM //Validação do legado

    If FWIsInCallStack("FINA040") .Or. FWIsInCallStack("FINA740")
        cChave := M->E1_PREFIXO+M->E1_NUM+M->E1_PARCELA+M->E1_TIPO //Nova chave de validação
    EndIf

    If FREEFORUSE("SE1", cChave) 
        lRet := .T.
    EndIf

Return lRet

//-------------------------------------------------------------------------
/*/{Protheus.doc} VldEntAmar
Função para validar a amarração das entidades contábeis

@author simone.mie
@since  27/05/2024
@param cConta, Character , código da conta contabil
@param cCusto, Character , código do centro de custo
@param cItem, Character , código do item
@param cClVl, Character , código da classe de valor

@version 12
/*/
//-------------------------------------------------------------------------
Function VldEntAmar( cConta As Character, cCusto As Character, cItem As Character, cClVl As Character)

	Local lRet := .T.

	Default cConta := ""
    Default cCusto := ""
    Default cItem  := ""
    Default cClVl  := ""

	If (!Empty(cConta) .Or. !Empty(cCusto) .Or. !Empty(cItem) .Or. !Empty(cClVl))
		lRet := CtbAmarra(cConta,cCusto,cItem,cClVl)
	EndIf

Return(lRet)

/*/{Protheus.doc} FinIRRet
	Retorna o valor retido do IR.

	@param lConfTrib, logical, indica se foi utilizado o configurador de tributos
	@param oQry, object, utilizado na query para processamento da consulta quando 
	lConfTrib == .T. a rotina chamadora deve destruir o objeto na conclusao do uso.

	@return nValRet, numeric, valor retido de IR

	@type  Function
	@author Marcos Pires
	@since 01/10/2025
	/*/
Function FinIRRet(lConfTrib as logical, oQry as Object)
Local nValRet  as Numeric
Local cIDTit   as Character
Local cChavTit as Character
Local cQuery   as Character

nValRet   := 0
cIDTit    := ""
cChavTit  := ""
cQuery    := ""

Default lConfTrib := .F.
Default oQry      := Nil

If lConfTrib
	cChavTit := SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA)
	cIDTit := FINBuscaFK7(cChavTit, "SE1")

	If __lCachQry == Nil
		__lCachQry := FwLibVersion() >= "20211116"
	EndIf

	If !Empty(cIDTit)
		If oQry == Nil
			cQuery += " SELECT ISNULL(SUM(FK4_VALOR),0) VALOR"
			cQuery += " FROM " + RetSqlName("FK4")
			cQuery += " WHERE FK4_FILIAL = ?"
			cQuery += " AND FK4_IDORIG = ?"
			cQuery += " AND FK4_IMPOS = ?"
			cQuery += " AND FK4_STATUS = ?"
			cQuery += " AND D_E_L_E_T_ = ? "

			cQuery := ChangeQuery(cQuery)

			oQry := IIf(__lCachQry,FWExecStatement():New(cQuery),FWPreparedStatement():New(cQuery))
		EndIf

		oQry:SetString(1, FWXFilial("FK4",SE1->E1_FILORIG))
		oQry:SetString(2, cIDTit)
		oQry:SetString(3, "IRF")
		oQry:SetString(4, "1")
		oQry:SetString(5, Space(1))

		nValRet := IIf(__lCachQry, oQry:ExecScalar("VALOR","600","15"), oQry:MpSysExecScalar(oQry:GetFixQuery(),"VALOR") )
	EndIf
Else
	nValRet := SE1->E1_IRRF
EndIf

Return nValRet
