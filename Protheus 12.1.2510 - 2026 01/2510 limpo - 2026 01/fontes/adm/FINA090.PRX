#INCLUDE "PROTHEUS.CH"
#INCLUDE "FILEIO.CH"
#INCLUDE "FINA090.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "SIGAWIN.CH"

STATIC __lBcoOk		:= NIL
STATIC __lDescont	:= NIL
STATIC __dLastPcc	:= NIL
STATIC __oPrepare 	:= NIL
STATIC __lMVJURFI 	:= NIL
STATIC __lExtUSLG 	:= NIL
STATIC __lF090TIT	:= NIL
STATIC __lSOLNCP 	:= NIL
STATIC __lCtLIPag 	:= NIL
STATIC __lFinVDoc	:= NIL
STATIC __lUsaPCO	:= NIL
STATIC __nTamHist	:= NIL
STATIC __oFIN0901	:= NIL
STATIC __oFIN0902	:= NIL
STATIC __cLstImp	:= NIL
STATIC __nIdxE2OK	:= 2
STATIC __lPOSTIT    := NIL
STATIC __lFKDBx		:= NIL
STATIC __lQFILTRO   := NIL
STATIC __lF090FIL	:= NIL
STATIC __F090VLEX	:= NIL
STATIC __lFK7Cpos	:= NIL
//--- Tratamento Gestao Corporativa
STATIC __cLayout  	:= NIL
STATIC __lGestao	:= NIL
STATIC __cFilSE2	:= NIL
STATIC __cFilSE5	:= NIL
STATIC __cFilSEA	:= NIL
STATIC __cFilSEF	:= NIL
STATIC __cFilSA6	:= NIL
STATIC __cFilSEK	:= NIL
STATIC __cFilSED	:= NIL
STATIC __cFilSFQ	:= NIL
STATIC __cFilSA2	:= NIL
//Motor de Retencoes
STATIC __aImpMR		:= {}
STATIC __lPccMR 	:= .F.
STATIC __lIrfMR 	:= .F.
STATIC __lInsMR 	:= .F.
STATIC __lIssMR 	:= .F.
STATIC __lCidMR 	:= .F.
STATIC __lSesMR 	:= .F.
STATIC __nPisMR 	:= 0
STATIC __nCofMR 	:= 0
STATIC __nCslMR 	:= 0
STATIC __nIrfMR 	:= 0
STATIC __nInsMR 	:= 0
STATIC __nIssMR 	:= 0
STATIC __nCidMR 	:= 0
STATIC __nSesMR 	:= 0
STATIC __nImpMR 	:= 0
STATIC __lPccBxMR	:= .F.
STATIC __lTemMR		:= NIL
STATIC __nBasLeg	:= 0
STATIC __nTamMD2	:= NIL
STATIC __lJFilBco	:= NIL
STATIC __lADDBTN	:= NIL
STATIC __lANTBROW	:= NIL
STATIC __lFINA095	:= NIL
STATIC __cPerg		:= "FIN090A"
STATIC __aTab23		:= NIL
STATIC __cMVCARTE	:= NIL
STATIC __cMVBXDTF	:= NIL
STATIC __nMVMCUST	:= NIL
STATIC __lMVVENDO   := NIL
STATIC __cMRetPIS	:= NIL
STATIC __oTemINA	:= NIL
STATIC __lFILTABT	:= NIL
STATIC __lPAsBX 	:= NIL
Static __oRatIRF 	:= Nil		// Rateio IR Progressivo
STATIC __lFILTBRO 	:= NIL
STATIC __lFILTDAD	:= NIL
Static __lDicSimpl  As Logical
Static __nDedSimpl 	As Numeric
Static __lBordeImp   As Logical
Static __oBillRel	As Object
//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} function FinA090
Baixa Automática de Titulos a Pagar 

@Param nPosArotin	, Numeric, Posição a aRotina que deseja ser executada
@Param aTitulos		, Array  , array utilizado para rotina automatizada

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function FinA090(nPosArotin,aTitulos)

	Local bBlock
	Local oObj 		 := FWSX1Util():New()
	Local aPergunte	 := {}
	Local cFilCxCtr  := F090IsCaixa(.T.)
	Local lMvCheques := Type('MVCHEQUES')=='C'
	Local cMvCheques := F90FORMATIN( IIF(lMvCheques,MVCHEQUES,MVCHEQUE) )
	Local cStrTipos	 := F90FORMATIN( MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVENVBCOR )
	Local cFilLogada := cFilAnt  // Salva a Filial corrente, porque na chamada da função "fA091Aut" o sistema perde a filial.
	Local lBlind     := IsBlind()

	Private aIndices	:= {} //Array necessario para a funcao FilBrowse
	Private bFilBrw		:= {|| }
	Private cFilter		:=	Nil
	Private aRotina		:= MenuDef()
	Private nIndTemp	:= 1
	Private dDataLanc	:= dDataBase
	Private cBordero	:= CriaVar("E2_NUMBOR")
	Private cBcoDe		:= CriaVar("E2_PORTADO")
	Private cBcoAte		:= CriaVar("E2_PORTADO")
	Private cPortado	:= CriaVar("E2_PORTADO")
	Private dVencIni	:= dDataBase
	Private dVencFim	:= dDataBase
	Private dBaixa		:= dDataBase
	Private dDebito		:= dDataBase
	Private nJuros		:= 0
	Private nVA			:= 0	// VALORES ACESSORIOS
	Private nCorrec		:= 0
	Private cCtBaixa	:= GetMv("MV_CTBAIXA")
	Private cMarca		:= GetMark()
	Private cKey1		:= ""
	Private cIndexNew	:= ""
	Private nAcresc		:= 0
	Private nDecresc	:= 0
	Private cNatMov		:= ''
	Private cCadastro	:= STR0003 // "Baixa de Titulos"
	Private cCodDiario	:= ""
	Private cMoedBco	:= CriaVar( "E2_MOEDA" )
	Private cLote

	LoteCont( "FIN" )

	DEFAULT nPosArotin  := 0
	DEFAULT aTitulos 	:= {}
	DEFAULT __lADDBTN   := ExistBlock("F090ADDB")
	DEFAULT __lFILTBRO  := ExistBlock("F090FLBR")
	DEFAULT __lFILTDAD  := ExistBlock("F090FILB")
	DEFAULT __lANTBROW  := ExistBlock("F090BROW")
	DEFAULT __lCtLIPag 	:= GetMv("MV_CTLIPAG")

	NUMCHEQUE 	:= ""		//para contabilizar o numero do cheque

	//Ponto de entrada para adicionar rotinas e botoes na aRotina
	If __lADDBTN
		aRotina := ExecBlock( "F090ADDB",.F.,.F.,{aRotina})
	EndIf

	//Verificação do processo que está configurado para ser utilizado no Módulo Financeiro (Argentina)
	If !FinModProc()
		Return()
	EndIf

	//Verificar se o novo grupo de perguntas existe
	oObj:AddGroup("FIN090A")
	oObj:SearchGroup()
	If Len(aPergunte := oObj:GetGroup("FIN090A")[2]) == 0
		cText := STR0186 + CRLF + STR0187 + CRLF + CRLF //"Seu dicionário encontra-se desatualizado. "###"Com isso NÃO será possível a seleção de filiais para a baixa automática."
		cText += STR0188	//"Deseja continuar mesmo assim?"
		cTitle := STR0189 	//"Dicionário desatualizado."
		If !lBlind
			If MsgYesNo(cText, cTitle)
				__cPerg := "FIN090"
			Else
				Return()
			Endif
		Else
			__cPerg := "FIN090"
		Endif
	Endif

	//--------------------------------------------------------------
	// Variaveis utilizadas para parametros
	// mv_par01	Mostra Lan‡ Contabil
	// mv_par02 Aglutina Lancamentos
	// mv_par03 Contabiliza On-Line
	// mv_par04 Gera Cheque automaticamente
	// mv_par05 Ctb Bordero - Total/Por Bordero
	// mv_par06 Tipo de Desconto - 1 Condicional, 2 Incondicional
	// mv_par07 Seleciona Filiais
	// mv_par08 Contabiliza na Filial logada
	// mv_par09 Considera Bco Borderô
	//--------------------------------------------------------------
	//Carrega função Pergunte
	SetKey (VK_F12,{|a,b| AcessaPerg(__cPerg,.T.)})
	Pergunte(__cPerg,.F.)

	AjustaPerg()

	lDigita	:= IIF(mv_par01==1,.T.,.F.)
	lAglut	:= IIF(mv_par02==1,.T.,.F.)

	//POR MAIS ESTRANHO QUE PAREÇA, ESTA FUNCAO DEVE SER CHAMADA AQUI!
	//A função SomaAbat reabre o SE2 com outro nome pela ChkFile para
	//efeito de performance. Se o alias auxiliar para a SumAbat() não
	//estiver aberto antes da IndRegua, ocorre Erro de & na ChkFile,
	//pois o Filtro do SE2 ultrapassa 255 Caracteres.
	SomaAbat("","","","P")

	If nPosArotin > 0 // Sera executada uma opcao diretamento de aRotina, sem passar pela mBrowse
		dbSelectArea("SE2")
		bBlock := &( "{ |a,b,c,d,e| " + aRotina[ nPosArotin,2 ] + "(a,b,c,d,e) }" )
		Eval( bBlock, Alias(), (Alias())->(Recno()),nPosArotin,,aTitulos)
	Else
		//Cria indice condicianal para a Localizacoes
		If cPaisLoc <> "BRA"
			cFiltro :=	"E2_TIPO IN "+ cMvCheques +" AND "
			cFiltro +=	"E2_TIPO NOT IN "+ cStrTipos +" "
			If cPaisLoc $ "PER|DOM|ARG"
				cFiltro += " AND E2_PORTADO NOT IN " + cFilCxCtr + " "
			Endif
			cFiltro:= StrTran(cFiltro,",''","")
			If __lFILTBRO
				cFiltro := ExecBlock( "F090FLBR",.F.,.F.,{cFiltro})
			EndIf

			cFilter := cFiltro
		Else
			If !__lCtLIPag
				dbSelectArea("SE2")
				dbSetOrder(3)
				dbSeek( xFilial("SE2") )
				cKey1 := INDEXKEY()
			Else
				dbSelectArea("SE2")
				dbSetOrder(3)  //"E2_FILIAL+DTOS(E2_VENCREA)+E2_NOMFOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO"
				cFilter := "E2_FILIAL = '"+xFilial("SE2")+"' AND (E2_DATALIB <> '        ' OR (E2_SALDO+E2_SDACRES-E2_SDDECRE) <= "+Alltrim(Str(GetMv('MV_VLMINPG'),15,7))+")"
				If __lFILTDAD
					cFilter := ExecBlock( "F090FILB",.F.,.F.,{cFilter})
				EndIf
			Endif
		Endif

		//Ponto de entrada para ser utilizado antes do Browse
		If __lANTBROW
			ExecBlock( "F090BROW",.F.,.F.)
		EndIf

		//Endereca a função de BROWSE
		mBrowse( 6, 1,22,75,"SE2",,,,,, Fa040Legenda("SE2"),,,,,,,,cFilter)
	Endif

	//Recupera a Integridade dos dados
	RetIndex("SE2")
	dbSetOrder(1)
	Set Filter to

	If nPosArotin = 0
		dbSeek(xFilial())
		If cPaisLoc != "BRA"
			EndFilBrw("SE2",@aIndices)
		EndIf
	Endif

	cFilAnt := cFilLogada

Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} function fA090Aut
Baixa Automática de Titulos a Pagar 

@author  Wagner Xavier
@since   26/05/1992
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function fA090Aut(cAlias as Character, nRecno as Numeric, nOpcE as Numeric, aM as Array, aTitulos as Array)

	Local nOpca			as Numeric
	Local nX 			as Numeric
	Local nI 			as Numeric
	Local nRec			as Numeric
	Local nTotAger  	as Numeric
	Local nTipoBx 		as Numeric
	Local nSalvRec		as Numeric
	Local nTotCpos		as Numeric
	Local nTamaTit		as Numeric
	Local nTimeOut  	as Numeric
	Local nTimeMsg  	as Numeric
	Local lInverte		as Logical
	Local lCheque		as Logical
	Local lPadrao		as Logical
	Local lRet 			as Logical
	Local lTEMP			as Logical
	Local lContinua     as Logical
	Local lGerTotal 	as Logical
	Local lBaixa    	as Logical
	Local lMovBcoBx 	as Logical
	Local lF90TotGrv 	as Logical
	Local lMultNat		as Logical
	Local lF090Auto		as Logical
	Local lF090Fil		as Logical
	Local lSpbInUse 	as Logical
	Local lF090CPOS 	as Logical
	Local lPeAddBtn		as Logical
	Local lF090MTBX		as Logical
	Local lF090GAVE 	as Logical
	Local lFA090POS 	as Logical
	Local lF091FBX		as Logical
	Local lF090NatLot	as Logical
	Local lAtuSldBco 	as Logical
	Local lUsaFlag		as Logical
	Local lAutoARG		as Logical
	Local lPCCBaixa 	as Logical
	Local lPanelFin 	as Logical
	Local lBcoExcl		as Logical
	Local lConfirma		as Logical

	Local cFilLogada 	as Character
	Local cFilCxCtr 	as Character
	Local cDescrMo		as Character
	Local cLog			as Character
	Local cCamposE5 	as Character
	Local cFilBaixa     as Character
	Local cBancoF3      as Character
	Local cBord090I 	as Character
	Local cBord090F 	as Character
	Local cCheq090		as Character
	Local cBenef090		as Character
	Local cNatur090		as Character
	Local cHistor090	as Character
	Local cPadrao 		as Character

	Local aDescMotbx 	as Array
	Local aMotBx		as Array
	Local aCampos		as Array
	Local aEstruct		as Array
	Local aButtons		as Array
	Local aSize 		as Array
	Local aRetAdBtn		as Array
	Local aVars			as Array
	Local aVarsOld		as Array
	Local aAreaSE2		as Array
	Local aSelFil		as Array
	Local aTMPFil		as Array
	Local aFilAux		as Array
	Local aVendor		as Array

	Local oDlg			as Object
	Local oDlg1			as Object
	Local oQtda			as Object
	Local oCbx			as Object
	Local oRadio		as Object
	Local oBcoDe		as Object
	Local oBco090		as Object
	Local oTimer		as Object
	Local oValor		as Object
	Local oCheq090		as Object
	Local bOk1			as Block
	Local bOk2			as Block
	Local bOk3			as Block
	Local bOk4			as Block
	Local bActWhen		as Block
	Local bValNumChq	as Block
	Local bMovBanco		as Block
	Local oMultNat		as Object
	Local oModelMov		as Object
	Local oSubFKAM		as Object
	Local oSubFK5M		as Object
	Local oPanel		as Object
	Local dAtuDtBase	as Date
	Local oObj 			as Object
	Local aPergunte	 	as Array

	nOpca       := 0
	nX          := 0
	nI          := 0
	nRec        := 0
	nTotAger    := 0
	nTipoBx     := 1
	nSalvRec    := SE2->(Recno())
	nTotCpos    := 0
	nTamaTit    := 0
	nTimeOut    := SuperGetMv("MV_FATOUT",,900)*1000 // Estabelece 15 minutos para que o usuarios selecione
	nTimeMsg    := SuperGetMv("MV_MSGTIME",,120)*1000 // Estabelece 02 minutos para exibir a mensagem para o usuário informando que a tela fechará automaticamente em XX minutos
	lInverte    := .F.
	lCheque     := .F.
	lPadrao     := .F.
	lRet        := .T.
	lTEMP       := .F.
	lContinua   := .T.
	lGerTotal   := .F. // Gera mov.bancário totalizador nas baixas de borderos
	lBaixa      := .T.
	lMovBcoBx   := .F.
	lF90TotGrv  := ExistBlock("F90TOTGRV") // PE para gravacoes complementares no registro totalizador da baixa
	lMultNat    := .F.
	lF090Auto   := .F. // Controle de Chamada Automatizada
	lF090Fil    := .F.
	lSpbInUse   := SpbInUse()
	lF090CPOS   := ExistBlock("F090CPOS")
	lPeAddBtn   := ExistBlock("F090AdBtn")
	lF090MTBX   := ExistBlock("F090MTBX") // F090MTBX - Altera motivo de baixa autom.
	lF090GAVE   := ExistBlock("F090GAVE") // F090GAVE - Manipula filtro para montagem de baixa automática
	lFA090POS   := ExistBlock("FA090POS")
	lF091FBX    := ExistBlock("F091FBX")
	lF090NatLot := IF(ExistBlock("F090NATLOT"),ExecBlock("F090NATLOT",.f.,.f.),.F.)
	lAtuSldBco  := SuperGetMv("MV_ATUSLBC",.F.,.T.)
	lUsaFlag    := SuperGetMV("MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	lAutoARG    := Iif (cPaisloc == "ARG", IsBlind(), .F.) //Variable para verificar que se esta llegando a la función desde script de automatización
	lPCCBaixa   := (cPaisLoc == "BRA") .And. (SuperGetMv("MV_BX10925",.T.,"2") == "1") //Controla o Pis Cofins e Csll na baixa
	lPanelFin   := IsPanelFin()
	lBcoExcl    := Alltrim(FWModeAccess("SA6",1)) == "E" .Or. Alltrim(FWModeAccess("SA6",2)) == "E" .Or. Alltrim(FWModeAccess("SA6",3)) == "E"
	lConfirma   := .F.

	cFilLogada  := cFilAnt // Salva a Filial corrente, porque na chamada da função "fA091Aut" o sistema perde a filial.
	cFilCxCtr   := F090IsCaixa()
	cDescrMo    := " "
	cLog        := ""
	cCamposE5   := ""
	cFilBaixa   := cFilAnt
	cBancoF3    := "SA6"
	cBord090I   := CRIAVAR("EA_NUMBOR")
	cBord090F   := CRIAVAR("EA_NUMBOR")
	cCheq090    := CRIAVAR("E5_NUMCHEQ")
	cBenef090   := CRIAVAR("EF_BENEF")
	cNatur090   := CRIAVAR("E2_NATUREZ")
	cHistor090  := CRIAVAR("E5_HISTOR")
	cPadrao     := "530"

	aDescMotbx  := {}
	aMotBx      := ReadMotBx()
	aCampos     := {}
	aEstruct    := {}
	aButtons    := {}
	aSize       := {}
	aRetAdBtn   := {}
	aVars       := {}
	aVarsOld    := {}
	aAreaSE2    := SE2->(GetArea())

	aSelFil     := {}
	aTMPFil     := {}
	aFilAux     := {}
	aVendor     := {}

	dAtuDtBase  := dDataBase // Backup para database

	oObj        := FWSX1Util():New()
	aPergunte   := {}

	Private cAliasSE2 	as Character
	Private oGetLote	as Object
	Private lVldAD		as Logical
	Private cMotBx		as Character
	Private nMulta   	as Numeric
	Private nDescont 	as Numeric
	Private cLoteFin 	as Character
	Private nPis 		as Numeric
	Private nCofins   	as Numeric
	Private nCsll		as Numeric
	Private aDadosRef 	as Array
	Private aDadosRet 	as Array
	Private nVlRetPis	as Numeric
	Private nVlRetCof	as Numeric
	Private nVlRetCsl	as Numeric
	Private nDiferImp	as Numeric
	Private nValPgto	as Numeric
	Private nOldValPgto as Numeric
	Private nTotAbat	as Numeric
	Private nVlRetIrf	as Numeric
	Private nIrrf		as Numeric
	Private nValAcres	as Numeric
	Private nIss 		as Numeric
	Private nValor    	as Numeric
	Private nValImp		as Numeric
	Private lBxCnab 	as Logical
	Private lHabCampos	as Logical
	Private nBaseIrpf 	as Numeric
	Private nBaseITF	as Numeric
	//Baixa Automatizada
	Private nMoedaBco	as Numeric
	Private aDadosIR 	as Array
	Private cBco090 	as Character
	Private cAge090 	as Character
	Private cCta090 	as Character
	Private dDebito		as Date
	Private nInss		as Numeric
	//Reestruturacao SE5
	Private nDescCalc 	as Numeric
	Private nJurosCalc 	as Numeric
	Private nVACalc		as Numeric
	Private nMultaCalc 	as Numeric
	Private nCorrCalc	as Numeric
	Private nDifCamCalc	as Numeric
	Private nImpSubCalc	as Numeric
	Private nPisCalc	as Numeric
	Private nCofCalc	as Numeric
	Private nCslCalc	as Numeric
	Private nIrfCalc	as Numeric
	Private nIssCalc	as Numeric
	Private nPisBaseR 	as Numeric
	Private nCofBaseR	as Numeric
	Private nCslBaseR 	as Numeric
	Private nIrfBaseR 	as Numeric
	Private nIssBaseR 	as Numeric
	Private nPisBaseC 	as Numeric
	Private nCofBaseC 	as Numeric
	Private nCslBaseC 	as Numeric
	Private nIrfBaseC 	as Numeric
	Private nIssBaseC 	as Numeric
	Private lAplMinP 	as Logical
	Private lEmpPub 	as Logical
	Private nVlMPub 	as Numeric
	Private dDtDigit	as Date
	Private LanceiCTB 	as Logical

	cAliasSE2   := GetNextAlias()
	lVldAD      := .F.
	cMotBx      := CriaVar("E5_MOTBX")
	nMulta      := 0
	nDescont    := 0
	cLoteFin    := Space(TamSX3("E2_LOTE")[1])
	nPis        := 0
	nCofins     := 0
	nCsll       := 0
	aDadosRef   := Array(7)
	aDadosRet   := Array(7)
	nVlRetPis   := 0
	nVlRetCof   := 0
	nVlRetCsl   := 0
	nDiferImp   := 0
	nValPgto    := 0
	nOldValPgto := 0
	nTotAbat    := 0
	nVlRetIrf   := 0
	nIrrf       := 0
	nValAcres   := 0
	nIss        := 0
	nValor      := 0
	nValImp     := 0
	lBxCnab     := IIf(GETMV("MV_BXCNAB")== "S",.T.,.F.)
	lHabCampos  := .T.
	nBaseIrpf   := 0
	nBaseITF    := 0
	//Baixa Automatizada
	nMoedaBco   := 1
	aDadosIR    := Array(3)
	cBco090     := ""
	cAge090     := ""
	cCta090     := ""
	dDebito     := dDataBase
	nInss       := 0
	//Reestruturacao SE5
	nDescCalc   := 0
	nJurosCalc  := 0
	nVACalc     := 0
	nMultaCalc  := 0
	nCorrCalc   := 0
	nDifCamCalc := 0
	nImpSubCalc := 0
	nPisCalc    := 0
	nCofCalc    := 0
	nCslCalc    := 0
	nIrfCalc    := 0
	nIssCalc    := 0
	nPisBaseR   := 0
	nCofBaseR   := 0
	nCslBaseR   := 0
	nIrfBaseR   := 0
	nIssBaseR   := 0
	nPisBaseC   := 0
	nCofBaseC   := 0
	nCslBaseC   := 0
	nIrfBaseC   := 0
	nIssBaseC   := 0
	lAplMinP    := .F.
	lEmpPub     := IsEmpPub()
	nVlMPub     := SuperGetMv("MV_VLMPUB" ,.T.,10)
	dDtDigit    := dDatabase
	LanceiCTB   := .F.

	Default aTitulos	:= {}
	Default __lDescont	:= ExistBlock("F090DESC")
	Default __lPOSTIT  := ExistBlock("F090POSTIT")
	Default __lCtLIPag	:= GetMv("MV_CTLIPAG")
	Default __cMVCARTE  := GetMv("MV_CARTEIR")
	Default __cMVBXDTF  := SuperGetMv("MV_BXDTFIN",,"1")
	Default __lUsaPCO	:= SuperGetMV("MV_PCOINTE",.F.,"2") =="1"
	Default __lMVVENDO  := SuperGetMv("MV_BXAUTVE",.F.,.F.)
	Default __lJFilBco 	:= SuperGetMv( "MV_JFILBCO", .F., .F. ) .And. FindFunction("JURF3SA6") .And. FindFunction("JurVldSA6") //Indica se filtra as contas correntes vinculadas ao escritório logado - SIGAPFS.
	Default __lFINA095	:= IsInCallStack("FINA095")

	//Verifica se data do movimento ‚ menor que data limite de movimentacao no financeiro
	If SuperGetMv("MV_BXDTFIN",,"1") == "2" .and. !DtMovFin(,,"1")
		Return
	Endif

	//Caso não tenha o novo grupo de perguntas, seto Considera Filiais = Não
	//Verificar se o novo grupo de perguntas existe
	oObj:AddGroup("FIN090A")
	oObj:SearchGroup()
	If Len(aPergunte := oObj:GetGroup("FIN090A")[2]) == 0
		__cPerg := "FIN090"
	Endif
	//Carrega função Pergunte
	SetKey (VK_F12,{|a,b| AcessaPerg(__cPerg,.T.)})
	Pergunte(__cPerg,.F.)

	AjustaPerg()

	f090LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

	cBco090  := If((cPaisloc == "BRA"),CRIAVAR("A6_COD")    ,IIF( lAutoARG,CRIAVAR("A6_COD")    ,If(__lFINA095,cBco380,CRIAVAR("A6_COD"))))
	cAge090	 := If((cPaisloc == "BRA"),CRIAVAR("A6_AGENCIA"),IIF( lAutoARG,CRIAVAR("A6_AGENCIA"),If(__lFINA095,cAge380,CRIAVAR("A6_AGENCIA"))))
	cCta090	 := If((cPaisloc == "BRA"),CRIAVAR("A6_NUMCON") ,IIF( lAutoARG,CRIAVAR("A6_NUMCON") ,If(__lFINA095,cCta380,CRIAVAR("A6_NUMCON"))))
	cBancoF3 := Iif(__lJFilBco, "SA6JUR", "SA6")

	If __lFINA095
		IF lAutoARG
			dVencIni	:= SEF->EF_DATA
			dVencFim	:= SEF->EF_VENCTO
			dDebito  := dDataBase
			dBaixa   := dDataBase
		Else
			dVencIni	:= dIniDt380
			dVencFim	:= dFimDt380
		Endif
	EndIf
	//As variaveis cBenef090/cHistor090 não estavam sendo alimentadas quando a rotina de origem era a FINA095
	If __lFINA095 .OR. lAutoARG
		cBenef090  := SEF->EF_BENEF
		cHistor090 := SEF->EF_HIST
		cHistAux   := cHistor090
	EndIf

	aFill(aDadosRef,0)
	aFill(aDadosRet,0)
	aFill(aDadosIR ,0)

	//Verifico se houve chamada Automatizada
	If !Empty(aTitulos)
		//Composição de aTitulos
		//aTitulos [1] := aRecnos		(array contendo os Recnos dos registros a serem baixados)
		//aTitulos [2] := cBanco 		(Banco da baixa)
		//aTitulos [3] := cAgencia		(Agencia da baixa)
		//aTitulos [4] := cConta		(Conta da baixa)
		//aTitulos [5] := cCheque		(Cheque da Baixa - apenas Contas a Pagar)
		//aTitulos [6] := cLoteFin		(Lote Financeiro da baixa)
		//aTitulos [7] := cNatureza		(Natureza do movimento bancario - apenas Contas a Pagar)
		//aTitulos [8] := dBaixa		(Data da baixa)
		//aTitulos [9] := nTipoBx		(1 = Baixa somente titulos que não estao em bordero ou nTipoBx -> 2 = Baixa somente titulos em bordero)
		//aTitulos [10]:= cBcoDe 		(Portador de)
		//aTitulos [11]:= cBcoAte		(Portador Até)
		//aTitulos [12]:= dVencIni		(Vencimento Inicial)
		//aTitulos [13]:= dVencFim		(Vencimento Final)
		//aTitulos [14]:= cBord090I		(Borderô Inicial)
		//aTitulos [15]:= cBord090F		(Borderô  Final)
		//aTitulos [16]:= cBenef090		(Beneficiário do Cheque)
		//aTitulos [17]:= cHistor090	(Historico do Cheque)
		//aTitulos [18]:= lMultNat		(Rateio Multiplas naturezas)
		//aTitulos [19]:= aFilBx		(Array com filiais para a baixa)
		//aTitulos [20]:= aVendor		(Array para a baixa de vendor)

		lF090Auto := .T.	// Chamada Automatizada

		//Caso a contabilizacao seja online
		//E a tela de contabilizacao possa ser mostrada em caso de erro no lancamento
		//(falta de conta, debito/credito nao batem, etc)
		//A baixa automatica em lote nao podera ser utilizada.
		//Somente sera processada se:
		//MV_PRELAN = S
		//MV_CT105MS = N
		//MV_ALTLCTO = N
		If mv_par03 == 1 .and. !CTBINTRAN(1,.F.)
			Return
		Endif
	Endif

	VAR_IXB    := .F.
	STRLCTPAD  := " "
	cBord090F  := IIf(Empty(cBord090F),Replicate("Z",Len(cBord090F)),cBord090F)

	If !__lFINA095
		cBcoAte    := IIf(Empty(cBcoAte),Replicate("Z",Len(cBcoAte)),cBcoAte)
	Endif

	//Retorna o Array aDescMotBx contendo apenas a descricao do motivo das Baixas
	For nI := 1 to len( aMotBx )
		If substr(aMotBx[nI],34,01) == "A" .or. substr(aMotBx[nI],34,01) =="P"
			If !(substr(aMotBx[nI],01,03) $ "FAT|LOJ|LIQ|CEC|CMP")
				AADD( aDescMotbx,substr(aMotBx[nI],07,10))
			Endif
		EndIf
	Next

 	cMotBx := aDescMotbx[1]

	If GetNewPar("MV_VLTITAD",.F.)
		Aadd( aButtons, { 'PENDENTE', { || F090VlMark(.T.,cAliasSE2,cMarca,oValor,oQtda,oMark,nValor)}, STR0074, STR0075 } ) //"Verifica se ha Titulos com Adiantamento ou Devolucao"###"Validador"
	Endif

	If lPeAddBtn
		aRetAdBtn := Execblock("F090AdBtn",.F.,.F., {aButtons})
		If Valtype(aRetAdBtn)=="A"
			aButtons := aClone(aRetAdBtn)
		Endif
	Endif

	If ExistBlock("F090MNAT") .and. !lF090Auto	 // Verifica presença do PE e Chamada Automatizada
		lMultNat := ExecBlock("F090MNAT",.F.,.F.)	// F090MNAT - Opção de múltiplas Naturezas
	Endif

	//Inicia processo de integracao com o SIGAPCO
	If __lUsaPCO
		PCOIniLan("000006")
	Endif

	While .T.
		nRec      := SE2->( RecNo() )
		nOpca     := 0
		cMotBx    := aDescMotbx[1]
		lTEMP  	  := .F.
		lConfirma := .F.

		//Permite alterar o motivo de baixa inicial por outro motivo disponivel para selecao
		If lF090MTBX
			cMotBx := ExecBlock( "F090MTBX", .F., .F., { aDescMotBx } )
			//Restaura motivo de baixa original se foi informado um motivo nao permitido
			If AScan( aDescMotBx, cMotBx ) == 0
				cMotBx := aDescMotbx[1]
			EndIf
		EndIf

		UltiLote()

		//PONTO DE ENTRADA FA090POS
		//Permite tratamento das variáveis (CBCO090, CAGE090, CTA090, CCHEQ090)
		//apos carga de dados do titulo a ser baixado, antes das informacoes serem mostradas na tela
		If lFA090POS
			aDados   := ExecBlock("FA090POS",.F.,.F.,{cBco090, cAge090, cCta090, cCheq090})
			cBco090  := aDados[1]
			cAge090  := aDados[2]
			cCta090  := aDados[3]
			cCheq090 := aDados[4]
			SE2->(dbGoTo(nSalvRec))
		Endif

		If !lF090Auto	// Chamada Automatizada
			IF !lF090GAVE	// F090GAVE - Manipula filtro para montagem de baixa automática
				aSize := MSADVSIZE()

				If lPanelFin  //Chamado pelo Painel Financeiro
					dbSelectArea(cAlias)
					oPanelDados := FinWindow:GetVisPanel()
					oPanelDados:FreeChildren()
					aDim := DLGinPANEL(oPanelDados)
					DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )
					nEspLarg := (((DlgWidthPanel(oPanelDados)/2) - 270) /2)-5
					nEspLin  := 0
					oDlg:lMaximized := .F.
					oPanel:= TScrollBox():New(oDlg,0,0,0,0)
					oPanel:Align := CONTROL_ALIGN_ALLCLIENT
				Else
					DEFINE MSDIALOG oDlg FROM 30,16 To 340,566  TITLE  STR0021 PIXEL //"Baixa Autom tica"
					nEspLarg := 0
					nEspLin  := 0
					oDlg:lMaximized := .F.
					oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
					oPanel:Align := CONTROL_ALIGN_ALLCLIENT
				EndIf

				If cPaisloc != "BRA" .AND. __lFINA095
					cBcoDe  := Criavar("EF_BANCO")
					cBcoAte := cBcoDe

					@ 000+nEspLin, 005+nEspLarg TO 029+nEspLin, 060+nEspLarg LABEL  STR0065	PIXEL OF oPanel	// "Baixar"
					@ 000+nEspLin, 065+nEspLarg TO 025+nEspLin, 165+nEspLarg LABEL  STR0009	PIXEL OF oPanel	// "Portador"
					@ 000+nEspLin, 170+nEspLarg TO 025+nEspLin, 270+nEspLarg LABEL  STR0011	PIXEL OF oPanel	// "Vencimento"
					@ 026+nEspLin, 170+nEspLarg TO 052+nEspLin, 270+nEspLarg LABEL  STR0012	PIXEL OF oPanel	// "Mot.Baixa"
					@ 007+nEspLin,007+nEspLarg Radio oRadio VAR nTipoBx ITEMS STR0066 3D ON CHANGE oBcoDe:SetFocus() SIZE 50,10 PIXEL OF oPanel 	//"Títulos"###"Borderôs"

					If UsaSeqCor()
						cCodDiario	:= Criavar("E5_DIACTB",.T.)
						cTitDiar	:= Alltrim(GetSx3Cache("E5_DIACTB","X3_TITULO"))
						@ 031+nEspLin,007+nEspLarg SAY cTitDiar PIXEL of oPanel   // "Codigo Diario"
						@ 039+nEspLin,007+nEspLarg MSGET cCodDiario F3 "CVL" SIZE 37,10 PIXEL of oPanel Valid VldCodSeq( cCodDiario ) When CtbWdia()
					Endif

					@ 009+nEspLin,070+nEspLarg MSGET oBcoDe VAR cBcoDe	F3 "BCO" When Empty(cBcoDe) VALID If(!Empty(cBcoDe),Eval({||cBcoAte:=cBcoDe, If(!cBcoDe $ cFilCxCtr ,.T.,Eval({||MsgAlert(STR0096, STR0072),.F.})) }),.F.) SIZE 37,10 PIXEL of oPanel HASBUTTON
					@ 009+nEspLin,110+nEspLarg SAY	 STR0010 SIZE 10,10 PIXEL of oPanel   // "at‚ "
					@ 009+nEspLin,122+nEspLarg MSGET cBcoAte	F3 "BCO" When .F. SIZE 37,10 PIXEL of oPanel HASBUTTON

					@ 009+nEspLin,175+nEspLarg MSGET dVencIni When nTipoBx == 1 SIZE 45,10 PIXEL of oPanel HASBUTTON
					@ 009+nEspLin,220+nEspLarg SAY	STR0010 SIZE 10,10 PIXEL of oPanel // "at‚ "
					@ 009+nEspLin,226+nEspLarg MSGET dVencFim When nTipoBx == 1 Valid dVencFim >= dVencIni SIZE 45,10 PIXEL of oPanel HASBUTTON
					@ 034+nEspLin,210+nEspLarg COMBOBOX oCbx VAR cMotBx ITEMS aDescMotBx SIZE 56, 47 PIXEL OF oPanel Valid (ShowMotBx("P",.T.))
				Else
					@ 000+nEspLin, 005+nEspLarg TO 029+nEspLin, 060+nEspLarg LABEL  STR0065	PIXEL OF oPanel	// "Baixar"
					@ 000+nEspLin, 065+nEspLarg TO 025+nEspLin, 165+nEspLarg LABEL  STR0009	PIXEL OF oPanel	// "Portador"
					@ 000+nEspLin, 170+nEspLarg TO 025+nEspLin, 270+nEspLarg LABEL  STR0011	PIXEL OF oPanel	// "Vencimento"
					@ 026+nEspLin, 065+nEspLarg TO 052+nEspLin, 165+nEspLarg LABEL  STR0013	PIXEL OF oPanel	// "Border“"
					@ 026+nEspLin, 170+nEspLarg TO 052+nEspLin, 270+nEspLarg LABEL  STR0012	PIXEL OF oPanel	// "Mot.Baixa"

					@ 007+nEspLin,007+nEspLarg Radio oRadio VAR nTipoBx ITEMS STR0066,STR0067 3D ON CHANGE (oBcoDe:SetFocus(),F090NLOTE(nTipoBx,cBord090I,cBord090F),oGetLote:refresh()) SIZE 50,10 PIXEL OF oPanel 	//"Títulos"###"Borderôs"

					If UsaSeqCor()
						cCodDiario	:= Criavar("E5_DIACTB",.T.)
						cTitDiar	:= Alltrim(GetSx3Cache("E5_DIACTB","X3_TITULO"))
						@ 031+nEspLin,007+nEspLarg SAY cTitDiar PIXEL of oPanel   // "Codigo Diario"
						@ 039+nEspLin,007+nEspLarg MSGET cCodDiario F3 "CVL" SIZE 37,10 PIXEL of oPanel Valid VldCodSeq( cCodDiario ) When CtbWdia()
					Endif

					@ 009+nEspLin,070+nEspLarg MSGET oBcoDe VAR cBcoDe F3 "BCO"  VALID If(cPaisLoc=="PER",If(!cBcoDe $ cFilCxCtr ,.T.,Eval({||MsgAlert(STR0096, STR0072),.F.})),.T.) SIZE 37,10 PIXEL of oPanel HASBUTTON
					@ 009+nEspLin,110+nEspLarg SAY	 STR0010 SIZE 10,10 PIXEL of oPanel   // "at‚ "
					@ 009+nEspLin,122+nEspLarg MSGET cBcoAte F3 "BCO" VALID If(cPaisLoc=="PER",If(!cBcoAte $ cFilCxCtr ,.T.,Eval({||MsgAlert(STR0096, STR0072),.F.})),.T.) SIZE 37,10 PIXEL of oPanel HASBUTTON

					@ 009+nEspLin,174+nEspLarg MSGET dVencIni When nTipoBx == 1 SIZE 45,10 PIXEL of oPanel HASBUTTON
					@ 009+nEspLin,217+nEspLarg SAY	STR0010 SIZE 10,8 PIXEL of oPanel // "a"
					@ 009+nEspLin,226+nEspLarg MSGET dVencFim When nTipoBx == 1 Valid dVencFim >= dVencIni SIZE 45,10 PIXEL of oPanel HASBUTTON

					@ 035+nEspLin,070+nEspLarg MSGET cBord090I When nTipoBx == 2 Picture "@S6" SIZE 37,10 PIXEL of oPanel
					@ 035+nEspLin,110+nEspLarg SAY	STR0010 SIZE 10,10 PIXEL of oPanel // "at‚ "
					@ 035+nEspLin,122+nEspLarg MSGET cBord090F When nTipoBx == 2 Picture "@S6" SIZE 37,10 PIXEL of oPanel
					@ 034+nEspLin,174+nEspLarg COMBOBOX oCbx VAR cMotBx ITEMS aDescMotBx SIZE 95, 13 PIXEL OF oPanel Valid (ShowMotBx("P",.T.))
				Endif

				bActWhen 	:= {|| MovBcoBx(cMotBx,.T.) .and. ChqMotBx(cMotBx) .and. mv_par04 == 1 .and. fa090CX(cBco090, nTipoBx==2) }
				bValNumChq 	:= {|| If( Eval(bActWhen), FaPrNumChq(cBco090,cAge090,cCta090,@oCheq090,@cCheq090), .T. ) }
				bMovBanco	:= {|| ( lHabCampos := VldBanco( cMotBx, @cBco090, @cAge090, @cCta090 ) ) }

				If __lFINA095
					@ 052+nEspLin,065+nEspLarg	SAY  STR0034 PIXEL of oPanel	//"Banco"
					If cPaisLoc=="ARG"
						@ 059+nEspLin,065+nEspLarg	MSGET oBco090 VAR cBco090 F3 cBancoF3  WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,,,.T.) .And. Eval(bValNumChq) .and. fa090BcoCx(cBco090, cAge090, cCta090, cCheq090) .and. If(!cBco090 $ cFilCxCtr  ,.T.,Eval({||MsgAlert(STR0097, STR0072),.F.}))SIZE 10,08 PIXEL of oPanel HASBUTTON
					Else
						@ 059+nEspLin,065+nEspLarg	MSGET oBco090 VAR cBco090 F3 cBancoF3  WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,,,.T.) .And. Eval(bValNumChq) .and. fa090BcoCx(cBco090, cAge090, cCta090, cCheq090) .and. If(!cBco090 $ cFilCxCtr .and. cBco090 == cBcoDe ,.T.,Eval({||MsgAlert(STR0097, STR0072),.F.})) .And. fa090BnkVl("1",cBco090,cAge090,cCta090) SIZE 10,08 PIXEL of oPanel HASBUTTON
					EndIf
					@ 052+nEspLin,105+nEspLarg	SAY  STR0035 PIXEL of oPanel	// "Agência"
					@ 059+nEspLin,105+nEspLarg	MSGET cAge090   WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,@cAge090,,.T.) .And. Eval(bValNumChq) .And. fa090BnkVl("2",cBco090,cAge090,cCta090) SIZE 15,08 PIXEL of oPanel
					@ 052+nEspLin,150+nEspLarg	SAY  STR0036 PIXEL of oPanel	//"Conta"
					@ 059+nEspLin,150+nEspLarg	MSGET cCta090   WHEN Eval(bMovBanco) Valid If(CarregaSa6(@cBco090,@cAge090,@cCta090,.T.,,.T.),Eval(bValNumChq),oBco090:SetFocus()) .And. fa090BnkVl("3",cBco090,cAge090,cCta090) SIZE 50,08 PIXEL of oPanel
					@ 052+nEspLin,215+nEspLarg	SAY  STR0064 PIXEL of oPanel //"Cheque"
				Else
					@ 052+nEspLin,065+nEspLarg	SAY  STR0034 PIXEL of oPanel	//"Banco"
					@ 059+nEspLin,065+nEspLarg	MSGET oBco090 VAR cBco090 F3 cBancoF3  WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,,,.T.) .And. Eval(bValNumChq) .and. fa090BcoCx(cBco090, cAge090, cCta090, cCheq090) .AND. If(cPaisLoc=="PER",If(!cBco090 $ cFilCxCtr ,.T.,Eval({||MsgAlert(STR0097, STR0072),.F.})),.T.) .And. fa090BnkVl("1",cBco090,cAge090,cCta090) SIZE 10,08 PIXEL of oPanel HASBUTTON
					@ 052+nEspLin,105+nEspLarg	SAY STR0035  PIXEL of oPanel	//"Agência"
					@ 059+nEspLin,105+nEspLarg	MSGET cAge090   WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,@cAge090,,.T.) .And. Eval(bValNumChq) .And. fa090BnkVl("2",cBco090,cAge090,cCta090) SIZE 15,08 PIXEL of oPanel
					@ 052+nEspLin,150+nEspLarg	SAY  STR0036 PIXEL of oPanel	//"Conta"
					@ 059+nEspLin,150+nEspLarg	MSGET cCta090   WHEN Eval(bMovBanco) Valid If(CarregaSa6(@cBco090,@cAge090,@cCta090,.T.,,.T.),Eval(bValNumChq),oBco090:SetFocus()) .And. fa090BnkVl("3",cBco090,cAge090,cCta090) SIZE 50,08 PIXEL of oPanel
				Endif

				@ 052+nEspLin,215+nEspLarg	SAY  STR0064 PIXEL of oPanel //"Cheque"
				@ 059+nEspLin,215+nEspLarg	MSGET oCheq090 VAR cCheq090 When !RetGlbLGPD("EF_BENEF") .and. Eval(bActWhen) ;
					Valid (IIF(AllTrim(cCheq090)<>"" .and. AllTrim(cHistor090)=="",cHistor090 := STR0070,If(AllTrim(cCheq090)=="",cHistor090 := "", )),FA090Cheq(cBco090,cAge090,cCta090,cCheq090)) SIZE 53,08 PIXEL of oPanel

				@ 071+nEspLin,066+nEspLarg SAY STR0068 PIXEL of oPanel //"Beneficiario"
				@ 078+nEspLin,066+nEspLarg MSGET oBenef090 VAR cBenef090 Picture "@!" When (!RetGlbLGPD("EF_BENEF") .and. !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*") SIZE 80,08 PIXEL of oPanel OBFUSCATED RetGlbLGPD("EF_BENEF")
				@ 071+nEspLin,150+nEspLarg SAY STR0069 PIXEL of oPanel //"Natureza do Movto"
				@ 078+nEspLin,150+nEspLarg MSGET cNatur090 F3 "SED" When lF090NatLot .or. (!Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*") .or. (lBxCnab) VALID FinVldNat( .T., cNatur090 ) SIZE 50,08 PIXEL of oPanel HASBUTTON
				@ 071+nEspLin,215+nEspLarg SAY STR0063 PIXEL of oPanel //"Lote"
				@ 078+nEspLin,215+nEspLarg GET oGetLote VAR cLoteFin Picture "@!" When lF090NatLot .or. lBxCnab .and.;
					((nTipoBx == 2) .or. ;
					((SubStr(cBco090,1,2) == "CX" .or. cBco090 $ __cMVCARTE).and. eval(bMovBanco))) ;
					Valid (!lBxCnab .Or. !Empty(cLoteFin)) .And. CheckLote("P") SIZE 53,08 PIXEL of oPanel

				@ 090+nEspLin,066+nEspLarg SAY STR0088 PIXEL of oPanel //"Historico do Cheque"
				@ 097+nEspLin,066+nEspLarg MSGET cHistor090 Picture "@!" When (!Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*" ) SIZE 203,08 PIXEL of oPanel

				@ 112+nEspLin,066+nEspLarg SAY STR0160  PIXEL of oPanel  //"Dt Baixa"
				@ 119+nEspLin,066+nEspLarg  MSGET DBAIXA When .T. 	SIZE 45,10 OF oPanel PIXEL HASBUTTON ;
					Valid ( !Empty(DBAIXA) .AND. Iif(__cMVBXDTF == "2", DtMovFin(DBAIXA,,"1"), .T.))

				//Somente exibe a opcao Rateio Multiplas Naturezas se parametro MV_MULNATP = .T.
				If MV_MULNATP
					@ 115+nEspLin,159+nEspLarg SAY STR0093 PIXEL of oPanel  //"Rateio Mult.Naturezas"
					@ 114+nEspLin,150+nEspLarg  CHECKBOX oMultNat VAR lMultNat PROMPT "" SIZE 203,08 OF oPanel PIXEL
				Endif

				If lPanelFin  //Chamado pelo Painel Financeiro
					oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])
					ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
						{||nOpca := 1,If(F090VldBx(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,oRadio),oDlg:End(),nOpca:=0)}, {||oDlg:End()})
					FinVisual(cAlias,FinWindow,(cAlias)->(Recno()),.T.)
				Else
					@ 133, 000 TO 134, 340 PIXEL OF oPanel

					DEFINE SBUTTON FROM 138,210 TYPE 1 ACTION ( lConfirma := .T., nOpca := 1, Iif( F090vLDbX(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,,lBcoExcl), oDlg:End(), nOpca:=0 ) ) ENABLE OF oDlg
					DEFINE SBUTTON FROM 138,240 TYPE 2 ACTION ( lConfirma := .F., oDlg:End() ) ENABLE OF oDlg

					If !lAutoARG
						ACTIVATE MSDIALOG oDlg CENTERED
					Else
						If FindFunction("GetParAuto")
							aRetAuto 	:= GetParAuto("FINA095TESTCASE")
							cBco090 	:= aRetAuto[1]
							cAge090 	:= aRetAuto[2]
							cCta090 	:= aRetAuto[3]
							cCheq090	:= aRetAuto[4]
							dBaixa		:= aRetAuto[5]
							cBcoDe		:= aRetAuto[6]
							cBcoAte		:= aRetAuto[7]
						Endif
						nOpca := 1
					EndIF
				Endif
			ELSE
				If UsaSeqCor()
					AADD(aVars,cCodDiario)
					nTotCpos := 17
				Endif

				AADD(aVars,nTipoBx)
				AADD(aVars,cBcoDe)
				AADD(aVars,cBcoAte)
				AADD(aVars,dVencIni)
				AADD(aVars,dVencFim)
				AADD(aVars,cBord090I)
				AADD(aVars,cBord090F)
				AADD(aVars,cMotBx)
				AADD(aVars,cBco090)
				AADD(aVars,cAge090)
				AADD(aVars,cCta090)
				AADD(aVars,cCheq090)
				AADD(aVars,cBenef090)
				AADD(aVars,cNatur090)
				AADD(aVars,cLoteFin)
				AADD(aVars,cHistor090)

				If MV_MULNATP
					AADD(aVars,lMultNat)
					nTotCpos := 19
				Endif

				AADD(aVars,nOpca)
				aVarsOld := aVars
				aVars := Execblock("F090GAVE",.F.,.F.,aVars)

				//Valida retorno do PE F240GAVE
				If ValType(aVars) != "A" .OR. Len(aVars) < nTotCpos
					aVars := aVarsOld
				Endif

				If UsaSeqCor()
					cCodDiario 	:= aVars[1]
					nTipoBx 	:= aVars[2]	//nTipoBx -> 1 = Baixa somente titulos que não estao em bordero  //nTipoBx -> 2 = Baixa somente titulos em bordero
					cBcoDe 		:= aVars[3]
					cBcoAte 	:= aVars[4]
					dVencIni 	:= aVars[5]
					dVencFim 	:= aVars[6]
					cBord090I 	:= aVars[7]
					cBord090F 	:= aVars[8]
					cMotBx 		:= aVars[9]
					cBco090 	:= aVars[10]
					cAge090 	:= aVars[11]
					cCta090 	:= aVars[12]
					cCheq090 	:= aVars[13]
					cBenef090 	:= aVars[14]
					cNatur090 	:= aVars[15]
					cLoteFin  	:= aVars[16]
					cHistor090 	:= aVars[17]

					If MV_MULNATP
						lMultNat := aVars[18]
					Endif

					nOpca      := aVars[19]
				Else
					nTipoBx 	:= aVars[1]	//nTipoBx -> 1 = Baixa somente titulos que não estao em bordero  //nTipoBx -> 2 = Baixa somente titulos em bordero
					cBcoDe 		:= aVars[2]
					cBcoAte 	:= aVars[3]
					dVencIni 	:= aVars[4]
					dVencFim 	:= aVars[5]
					cBord090I 	:= aVars[6]
					cBord090F 	:= aVars[7]
					cMotBx 		:= aVars[8]
					cBco090 	:= aVars[9]
					cAge090 	:= aVars[10]
					cCta090 	:= aVars[11]
					cCheq090 	:= aVars[12]
					cBenef090 	:= aVars[13]
					cNatur090 	:= aVars[14]
					cLoteFin  	:= aVars[15]
					cHistor090 	:= aVars[16]

					If MV_MULNATP
						lMultNat := aVars[17]
						nOpca    := aVars[18]
					Else
						nOpca 	:= aVars[17]
					Endif
				Endif
			ENDIF
		Else
			//-----------------------------------
			//Rotina Automatizada
			//-----------------------------------
			nOpca		:= 0
			nTamaTit	:= Len(aTitulos)
			nRec		:= SE2->( RecNo() )
			lGerTotal	:= lBxCnab
			cBco090		:= aTitulos[2]		// Banco
			cAge090		:= aTitulos[3]		// Agência
			cCta090		:= aTitulos[4]		// Conta Corrente
			cCheq090	:= aTitulos[5]		// Cheque
			cLoteFin	:= aTitulos[6]		// Lote
			cNatur090	:= aTitulos[7]		// Natureza do Movto
			nMoedaBco	:= Max(MoedaBco(cBco090,cAge090,cCta090),1)

			If nTamaTit > 7
				dBaixa	:= aTitulos[8]		//Data da Baixa
				dDebito := aTitulos[8]		//Data de Débito
			Endif
			If nTamaTit > 8
				nTipoBx := aTitulos[9]		// 1 = Baixa somente titulos que não estao em bordero ou nTipoBx -> 2 = Baixa somente titulos em bordero
			Endif
			If nTamaTit > 9
				cBcoDe := aTitulos[10]		// Portador de
			Endif
			If nTamaTit > 10
				cBcoAte := aTitulos[11]		// Portador Até
			Endif
			If nTamaTit > 11
				dVencIni := aTitulos[12]	// Vencimento Inicial
			Endif
			If nTamaTit > 12
				dVencFim := aTitulos[13]	// Vencimento Final
			Endif
			If nTamaTit > 13
				cBord090I := aTitulos[14]	// Borderô Inicial
			Endif
			If nTamaTit > 14
				cBord090F := aTitulos[15]	// Borderô  Final
			Endif
			If nTamaTit > 15
				cBenef090 := aTitulos[16]	// Beneficiário do Cheque
			Endif
			If nTamaTit > 16
				cHistor090 := aTitulos[17]	// Historico do Cheque
			Endif
			If nTamaTit > 17 .and. MV_MULNATP
				lMultNat := aTitulos[18]	// Rateio Multiplas naturezas
			Endif
			If nTamaTit > 18 .and. !Empty(aTitulos[19])
				aFilAux := aTitulos[19]	// Array contendo dados das filiais as serem consideradas para o processo
			Endif
			If nTamaTit > 19 .and. TrazCodMot(cMotBx) == "VEN"  .and. __lMVVENDO
				aVendor := aTitulos[20]	// Array contendo dados para o Vendor
			Endif

			If F090VldBx(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,oRadio,lBcoExcl,lF090Auto,aVendor)
				nOpca	:= 1
			Endif

		Endif

		If nOpca == 0
			Exit
		EndIf

		nRec		:= SE2->( RecNo() )
		lMovBcoBx	:= MovBcoBx(cMotBx, .T.)
		dbSelectArea( cAlias )
		F090GetCampos(aCampos,aEstruct)

		If mv_par07 == 1 .and. !lF090GAVE		//Seleciona Filiais
			If !lF090Auto
				// Seleção de filiais
				aFilAux := AdmGetFil(.F.,.T.,"SE2")
				If Len( aFilAux ) <= 0
					nOpca := 0
					Exit
				EndIf
			Else
				If Empty(aFilAux)
					aFilAux := AdmGetFil(.F.,.T.,"SE2",,,.F.)
					For nI := 1 to len( aFilAux )
						AADD(aSelFil, aFilAux[nI][1] )
					Next nI
					aFilAux := aSelFil
				Endif
			EndIf
		Else
			aFilAux := {cFilAnt}
		Endif

		If lF091FBX		//PE transferido do FINA091
			lF090Fil := EXECBLOCK("F091FBX",.F.,.F.,)
			If !Valtype(lF090Fil) == "L"
				lF090Fil := .F.
			EndIf
		EndIf

		//Se o cadastro de bancos for exclusivo e motivo de baixa movimenta banco, filtra as filiais que possuam os mesmos códigos de banco + agência + conta
		cChaveBco := cBco090 + cAge090 + cCta090
		If lBcoExcl .And. lMovBcoBx .And. !lF090Fil
			aSelFil := FiltFilBco(aFilAux, cChaveBco)
			FwFreeArray(aFilAux)
		Else
			aSelFil := aFilAux
		EndIf

		//Monta expressao do Filtro para seleção
		nMoedaBco	:= Max(MoedaBco(cBco090,cAge090,cCta090),1)

		//Funcao para montar e processar a query
		lTEMP		:= .T.
		nMoedaBco	:= Max(MoedaBco(cBco090,cAge090,cCta090),1)
		cArqNew		:= f090QryA(aSelFil,aTMPFil,aCampos,aEstruct,nTipoBx,cBord090I,cBord090F,@cBco090,@cAge090,@cCta090)

		//Altera Database
		dDatabase 	:= dBaixa

		If cArqNew == "NOACESS"  // Caso o usuario não tenha nenhuma permissão aborta o processo do bordero
			Help(" ",1,"RECNO")
			F090Clean()
			lTEMP := .F.
			Exit
		EndIf

		If !Empty( cArqNew )
			dbselectarea(cAliasSE2)
			dbGoTop()
		EndIf

		If (cAliasSE2)->(Bof()) .And. (cAliasSE2)->(Eof())
			Help(" ",1,"RECNO")
			If lTEMP
				F090Clean()
			EndIf
			lTEMP := .F.
			Exit
		EndIf

		nValor	:= 0    // valor total dos titulos mostrado no cabecalho do browse
		nQtdTit	:= 0    // quantidade de titulos mostrado no cabecalho do browse
		nOpcA	:= 0

		//Ponto de entrada para tratamento dos campos a serem demonstrados na tela de selecao dos titulos
		If lF090CPOS
			aCampos := EXECBLOCK("F090CPOS",.F.,.F.,aCampos)
		Endif

		If __lDescont
			nDescont := EXECBLOCK("F090DESC",.F.,.F.)
		Endif

		If lF090Auto	// Chamada Automatizada
			nOpcA		:= 1
			Fa090Marca(cAliasSE2,cMarca,aTitulos[1],@nTipoBx)
			nI := Ascan(aMotBx, {|x| Substr(x,1,3) == TrazCodMot(cMotBx) })
			cDescrMo := if( nI > 0,Substr(aMotBx[nI],07,10),"" )
		Else
			dbSelectArea(cAliasSE2)
			Processa( {|| Fa090Marca(cAliasSE2,cMarca) }, STR0163, STR0164,.F.) //"Aguarde..."#"Selecionando registros..."
			(cAliasSE2)->(DbGoTop())

			oSize := FwDefSize():New(.T.)
			oSize:lLateral := .F.
			oSize:lProp	:= .T. // Proporcional
			oSize:AddObject( "1STROW" ,  100, 12, .T., .T. ) // Totalmente dimensionavel
			oSize:AddObject( "2NDROW" ,  100, 88, .T., .T. ) // Totalmente dimensionavel
			oSize:aMargins := { 2, 2, 1, 2 } // Espaco ao lado dos objetos 0, entre eles 3
			oSize:Process() // Dispara os calculos
			a1stRow := {oSize:GetDimension("1STROW","LININI"), oSize:GetDimension("1STROW","COLINI"), oSize:GetDimension("1STROW","LINEND"), oSize:GetDimension("1STROW","COLEND")}
			a2ndRow := {oSize:GetDimension("2NDROW","LININI"), oSize:GetDimension("2NDROW","COLINI"), oSize:GetDimension("2NDROW","LINEND"), oSize:GetDimension("2NDROW","COLEND")}

			DEFINE MSDIALOG oDlg1 TITLE STR0008 From oSize:aWindSize[1],oSize:aWindSize[2] to oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL //"Bordero de Cobran‡a"
			oTimer:= TTimer():New((nTimeOut-nTimeMsg),{|| MsgTimer(nTimeMsg,oDlg1) },oDlg1) // Ativa timer
			oTimer:Activate()
			oDlg1:lMaximized := .T.

			@ a1stRow[1] + 001, a1stRow[2] + 001  To a1stRow[3],a1stRow[4] PIXEL OF oDlg1
			@ a1stRow[1] + 003, a1stRow[2] + 005 SAY STR0026 SIZE 50,10 PIXEL Of oDlg1  // "Valor Total:"
			@ a1stRow[1] + 003, a1stRow[2] + 060 SAY oValor VAR nValor PICTURE  PesqPict("SE2","E2_SALDO",TamSx3("E2_SALDO")[1]) SIZE 50,10  PIXEL Of oDlg1
			@ a1stRow[1] + 012, a1stRow[2] + 005 SAY STR0027 SIZE 50,10  PIXEL Of oDlg1 // "Quantidade:"
			@ a1stRow[1] + 012, a1stRow[2] + 083 SAY oQtda VAR nQtdTit PICTURE "@E 99999" 	SIZE 50,10  PIXEL Of oDlg1

			oMark	:= MsSelect():New(cAliasSE2, "E2_OK", "!E2_SALDO", aCampos, @lInverte, @cMarca, {a2ndRow[1], a2ndRow[2], a2ndRow[3], a2ndRow[4]})
			oMark:bMark	:= {||FA090Display(cAliasSE2,cMarca,lInverte,oValor,oQtda,"P",lBaixa)}
			oMark:bAval	:= {||Fa090bAval(cAliasSE2, cMarca, oValor, oQtda, oMark)}
			oMark:oBrowse:lhasMark		:= .T.
			oMark:oBrowse:lCanAllmark	:= .T.
			oMark:oBrowse:bAllMark		:= { || FWMsgRun(, {|| Fa090Inverte(cAliasSE2,cMarca,oValor,oQtda,.T.,oMark)}, STR0163, STR0164) }


			bOk1 := {|| If( !GetNewPar("MV_VLTITAD",.F.), lVldAD := .T., Nil ) }
			bOk2 := {|| If( FA090PcoLan(cMarca), (nOpca := 1,oDlg1:End()), Nil ) }
			bOk3 := {|| MsgInfo(STR0076, STR0072) }
			bOk4 := {|| IF( F090CHQOK(), Nil , (nOpca := 0)) }

			If __lPOSTIT
				ExecBlock("F090POSTIT", .F., .F., { cAliasSE2 } )
			Endif

			If lPanelFin  //Chamado pelo Painel Financeiro
				ACTIVATE MSDIALOG oDlg1 ON INIT FaMyBar( oDlg1,	{|| ( Eval(bOk1), If(lVldAD,Eval(bOk2),Eval(bOk3)) ) }, {|| nOpca := 0,ODlg1:End()}, aButtons )
			Else
				ACTIVATE MSDIALOG oDlg1 ON INIT EnchoiceBar( oDlg1, {|| ( Eval(bOk1),If(lVldAD,Eval(bOk2),Eval(bOk3)),Eval(bOk4),If(UsaSeqCor(),CTBvldDiario(cCodDiario,dDataBase),) ) },{|| nOpca := 0,ODlg1:End()},, aButtons ) //VALID (oTimer:End(),.T.)
			Endif

			ddatabase := dBaixa
			dDebito	  := dBaixa

			If nOpca != 1
				dbSelectArea(cAliasSE2)
				(cAliasSE2)->(dbGoTop())

				While (cAliasSE2)->(!EOF())
					SE2->(dbGoto((cAliasSE2)->NUM_REG))
					SE2->(MsUnlock())
					(cAliasSE2)->(MsUnlock())
					(cAliasSE2)->(dbSkip())
				Enddo

				If Select(cAliasSE2) > 0
					F090Clean()
					lTEMP := .F.
				Endif

				DbSelectArea("SE2")
				SE2->(RestArea(aAreaSE2))

				//Zera os Arrays de Estruturas e Campos utilizados na contrução da MSSELECT
				aCampos := {}
				aEstruct := {}

				If __lSX8
					RollBackSX8()
				Endif

				Loop
			EndIf

			dbSelectArea("SE2")

			IF nValor == 0
				Exit
			EndIf

			nI       :=  Ascan(aMotBx, {|x| Substr(x,1,3) == TrazCodMot(cMotBx) })
			cDescrMo := If(nI > 0, Substr(aMotBx[nI],07,10), "")

		Endif

		If nOpca == 1
			cPadrao   := ""
			lPadrao   := .F.
			lContinua := F090Baixa(lF090Auto,nTipoBx,lPCCBaixa,lMovBcoBx,cPadrao, lPadrao, cCheq090, cBenef090, cNatur090, ;
				cHistor090, lUsaFlag, lSpbInUse, lAtuSldBco, lMultNat, cFilBaixa, @lCheque,cDescrMo, @nTotAger, @lGerTotal, aVendor )
		Endif

		Exit
	Enddo

	//-------------------------------------------------------------------------------------------------------------
	// Caso nao confirme a baixa ou confirme sem selecionar nenhum titulo/bordero, forca finalizacao do processo
	// de validacao de bloqueio (PcoVldLan) do SIGAPCO
	//-------------------------------------------------------------------------------------------------------------
	If lContinua
		If __lUsaPCO
			If nOpca # 1 .Or. (nOpca == 1 .And. nValor == 0)
				PCOFinLan("000006")
			EndIf
		EndIf

		If __lSX8
			RollBackSX8()
		Endif

		//Grava no SE5 o numero do último lote recebido e gera movimentacao bancaria
		If nTotAger > 0 .and. lGerTotal
			If Empty(cNatur090)
				cNatur090 := FINNATMOV("P")
			Endif

			//Model de Movimento bancario
			oModelMov := FWLoadModel("FINM030")
			oModelMov:SetOperation(MODEL_OPERATION_INSERT) //Inclusao
			oModelMov:Activate()
			oSubFK5M  := oModelMov:GetModel("FK5DETAIL")
			oSubFKAM  := oModelMov:GetModel("FKADETAIL" )

			oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
			oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo

			// Inclui registro no SE5 para a geracao do cheque
			cCamposE5 := "{"
			cCamposE5 += " {'E5_DTDIGIT' , dDtDigit }"
			cCamposE5 += ",{'E5_BENEF'   , '"+StrTran(cBenef090,"'","")+"' } "
			cCamposE5 += ",{'E5_LOTE'    , '"+cLoteFin +"' }}"

			//Dados do movimento bancario do Cheque
			If !oSubFKAM:IsEmpty()
				//Inclui a quantidade de linhas necessárias
				oSubFKAM:AddLine()
				//Vai para linha criada
				oSubFKAM:GoLine( oSubFKAM:Length() )
			Endif

			oSubFKAM:SetValue( 'FKA_IDORIG', FWUUIDV4() )
			oSubFKAM:SetValue( 'FKA_TABORI', 'FK5' )

			oSubFK5M:SetValue( "FK5_RECPAG" , "P" )
			oSubFK5M:SetValue( "FK5_HISTOR" , STR0062+ cLoteFin) //"Baixa Automatica / Lote : "
			oSubFK5M:SetValue( "FK5_DATA"   , dDataBase )
			oSubFK5M:SetValue( "FK5_DTDISP" , dDataBase )
			oSubFK5M:SetValue( "FK5_NATURE" , cNatur090 )
			oSubFK5M:SetValue( "FK5_BANCO"  , cBco090 )
			oSubFK5M:SetValue( "FK5_AGENCI" , cAge090 )
			oSubFK5M:SetValue( "FK5_CONTA"  , cCta090 )
			oSubFK5M:SetValue( "FK5_VALOR"  , nTotAger )
			oSubFK5M:SetValue( "FK5_ORIGEM" , FunName() )

			If lCheque .And. mv_par04 == 1
				oSubFK5M:SetValue("FK5_TPDOC", "CH")
			Else
				oSubFK5M:SetValue("FK5_TPDOC"  , IF(!Empty(cLoteFin), "BL", "VL"))
			EndIf

			oSubFK5M:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
			oSubFK5M:SetValue( "FK5_FILORI" , cFilAnt )
			oSubFK5M:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
			oSubFK5M:SetValue( "FK5_LA"     , Iif(mv_par04==1 .and. lPadrao .and. !lUsaFlag .and. cCtBaixa$"AC","S"," ") )
			oSubFK5M:SetValue( "FK5_LOTE"   , cLoteFin )

			If lSpbInUse
				oSubFK5M:SetValue( "FK5_MODSPB" , "1" )
			Endif

			oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

			If oModelMov:VldData()
				oModelMov:CommitData()
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])

				Help( ,,"M020VLDI6",,cLog, 1, 0 )
			Endif

			oModelMov:DeActivate()
			oModelMov:Destroy()
			oModelMov := Nil

			//Atualiza saldo bancario.
			If lAtuSldBco
				AtuSalBco(cBco090,cAge090,cCta090,SE5->E5_DATA,SE5->E5_VALOR,"-")
			EndIf

			// Ponto de Entrada para manipular o registro totalizador da baixa automatica por lote
			If lF90TotGrv
				ExecBlock("F90TOTGRV")
			EndIf
		EndIf
	Endif

	dbSelectArea("SE2")
	RetIndex("SE2")

	If cPaisLoc =="BRA"
		If !__lCtLIPag
			dbSelectArea("SE2")
			dbSetOrder(3)
			dbSeek( cFilial )
			cKey1 := INDEXKEY()
		Else
			dbSelectArea("SE2")
			dbSetOrder(3)  //"E2_FILIAL+DTOS(E2_VENCREA)+E2_NOMFOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO"
			cFilter := "E2_FILIAL = '"+xFilial("SE2")+"' .AND. (DTOS(E2_DATALIB) <> '        ' .OR. E2_SALDO+E2_SDACRES-E2_SDDECRE <= "+Alltrim(Str(GetMv('MV_VLMINPG'),15,7))+")"
			Set Filter to &cFilter
			dbGotop()
		Endif
	Else
		Eval(bFilBrw)
		dbGoTo(nSalvRec)
	Endif

	//Libera os registros
	If lTEMP
		dbSelectArea(cAliasSE2)
		(cAliasSE2)->(dbGoTop())

		While (cAliasSE2)->(!EOF())
			SE2->(dbGoto((cAliasSE2)->NUM_REG))
			SE2->(MsUnlock())
			(cAliasSE2)->(MsUnlock())
			dbSkip()
		Enddo

		If Select(cAliasSE2) > 0
			F090Clean()
		Endif
		SE2->(RestArea(aAreaSE2))
	Endif

	//Restaura Variaveis
	dDataBase := dAtuDtBase
	dBaixa 	  := dDataBase

	//Ponto de entrada apos a restauracao dos indices
	If ExistBlock("F090REST")
		ExecBlock( "F090REST",.F.,.F.)
	EndIf

	If nOpca == 1 .And. GetNewPar( "MV_NGMNTFI","N" ) == 'S'
		// Função que atualiza a TRX  - Multa (Integração SIGAFIN - SIGAMNT).
		If FindFunction( "NGBAIXASE2" ) //Verifica se a função está disponível no rpo ou no binário, do Application Server, para ser executada.
			NGBAIXASE2( 1 )
		Endif

		//Função que gera uma apropriação de débito da multa, (Integração SIGAFIN - SIGAMNT).
		If FindFunction( "MNT765CONF" ) //Se for executado a baixa automática de pagaento da multa;
				lPagAutFin := .F. //Variável utilizada em fonte especifico do SIGAMNT;
				MNT765CONF( 3 ) 	//Executa a função que gera APD;
			EndIf
	EndIf

	If __oPrepare != NIL
		__oPrepare:Destroy()
		__oPrepare := NIL
	Endif

	IF lF090Auto
		MBrChgLoop(.F.)
	ElseIf !lF090Auto .And. INCLUI
		MBrChgLoop(.F.) // Evita que a opera‡?o seja reiniciada pela mBrowse
	EndIf

	cFilAnt := Iif( lConfirma == .T., cFilBaixa, cFilLogada )

	For nX := 1 TO Len(aTmpFil)
		CtbTmpErase(aTmpFil[nX])
	Next

	f090LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

Return (.T.)

//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090Baixa
Funcao para efetivar as baixas 

@Param lF090Auto  , Logical	  , Indica chamada automatizada da rotina
@Param nTipoBx	  , Numeric	  , Tipo de Baix: 1 = Título ou 2 = Borderô
@Param lPCCBaixa  , Logical	  , Indica cálculo de PCC na baixa
@Param nValorTotal, Numeric   , Valor total selecionado
@Param lMovBcoBx  , Logical   , Indica se o motivo de baixa gera movimento bancário
@Param cPadrao    , Character , Código do LP utilizado na contabilização
@Param lPadrao	  , Logical   , Indica se o LP utilizado está ativo
@Param cCheq090   , Character , Número do cheque informado
@Param cBenef090  , Character , Beneficiário do pagamento
@Param cNatur090  , Character , Natureza do pagamento
@Param cHistor090 , Character , Histórico do pagamento
@Param lUsaFlag	  , Logical   , Indica o uso de Flag Contábil
@Param lSpbInUse  , Logical   , Indica o uso do SPB
@Param lAtuSldBco , Logical   , Indica se o saldo bancário será atualizado
@Param lMultNat	  , Logical   , Indica o uso de rateio multinatureza
@Param cFilBaixa  , Character , Filial da Baixa
@Param lCheque	  , Logical   , Indica se o LP utilizado está ativo

@return lContinua , Logical   , Indica o funcionamento ou falha do processo

@author  Mauricio Pequim Jr
@since   08/11/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function F090Baixa(lF090Auto As Logical,nTipoBx As Numeric, lPCCBaixa As Logical, lMovBcoBx As Logical,;
		cPadrao As Character, lPadrao As Logical, cCheq090 As Character, cBenef090 As Character, cNatur090 As Character,;
		cHistor090 As Character, lUsaFlag As Logical, lSpbInUse As Logical, lAtuSldBco As Logical, lMultNat As Logical,;
		cFilBaixa As Character, lCheque As Logical, cDescrMo As Character, nTotAger As Numeric, lGerTotal As Logical, aVendor As Array )

	Local nX 			As Numeric
	Local nY 			As Numeric
	Local nZ			As Numeric
	Local nI 			As Numeric
	Local nTotal		As Numeric
	Local nHdlPrv		As Numeric
	Local nSaldo		As Numeric
	Local nSaldoCru		As Numeric
	Local nSalDup		As Numeric
	Local nRegAtu		As Numeric
	Local nTotAbtF 		As Numeric
	Local nValorCheq	As Numeric
	Local nRegPrinc 	As Numeric
	Local nLen 			As Numeric
	Local nOldRetPis	As Numeric
	Local nOldRetCof	As Numeric
	Local nOldRetCsl	As Numeric
	Local nTotLtEZ		As Numeric	//Totalizador da Bx Lote Mult Nat CC
	Local nValorTotal	As Numeric
	Local nRecNoSE5		As Numeric
	Local nRecNoSE2		As Numeric
	Local nRecNoFK2		As Numeric
	Local nRecnSE5		As Numeric
	Local nOrderSEF		As Numeric
	Local nValorSE5		As Numeric
	Local nLstRecSE5 	As Numeric
	Local nSalTit 		As Numeric
	Local nGerPAMov 	As Numeric
	Local nTotARet		As Numeric
	Local nTamTitPai	As Numeric
	Local nRecPAInc 	As Numeric
	Local nCentMd1		As Numeric
	Local nVA			As Numeric
	Local nTxMoedBx		As Numeric
	Local nValorSEF		As Numeric
	Local nRecSE2		As Numeric
	Local nDtContOn		As Numeric // Data para contabilização Online baixas pagar 1- Data Digitação; 2- Data Disponibilidade; 3- Data Pagamento
	Local nVlMinImp 	As Numeric
	Local nQtdBD        As Numeric
	Local nImposMR 	    As Numeric

	Local lPadAux 		As Logical
	Local lRetParc 		As Logical
	Local lBaixaPA		As Logical
	Local lIsTitPA		As Logical
	Local lAchouFor		As Logical
	Local lGerPAMov		As Logical
	Local lCtbIncPA 	As Logical
	Local lPAMov		As Logical
	Local lNewProc		As Logical
	Local lRetBor		As Logical
	Local lCalcPccBx 	As Logical
	Local lIRPFBaixa 	As Logical
	Local lCalcIssBx 	As Logical
	Local lVendor		As Logical
	Local lPadraoVd		As Logical
	Local lAplVlMin 	As Logical
	Local lBord241 		As Logical
	Local lBord240		As Logical
	Local lIsCaixa		As Logical
	Local lTotPorBord	As Logical
	Local lOk			As Logical	//Controla se foi confirmada a distribuicao
	Local lSetAuto		As Logical
	Local lSetHelp		As Logical
	Local lDtBaixa		As Logical
	Local lPCC241		As Logical
	Local lRet 			As Logical
	Local lDigita		As Logical
	Local lAglut		As Logical
	Local lFa080Sef 	As Logical
	Local lFa090Se5 	As Logical
	Local lF90Se5Grv 	As Logical // PE para gravacoes complementares da baixa
	Local lFa090Desc	As Logical
	Local lFa090Juros	As Logical
	Local lFa090Mult	As Logical
	Local lFina090  	As Logical
	Local lFa090Tx    	As Logical
	Local lFa090Tit		As Logical
	Local lFa090Corr	As Logical
	Local lF090SE5		As Logical
	Local lF091Natur    As Logical
	Local lAtuForn		As Logical
	Local lCtMovPa		As Logical // Indica se a Contabilizacao do LP513 ocorrer  pelo T¡tulo(SE2) ou Mov.Bancario(SE5) do Pagamento Antecipado. 1="SE2" / 2="SE5"
	Local lBxTxa 		As Logical
	Local lExistFJU 	As Logical
	Local lJGrvBxPag 	As Logical 	//Integração SIGAPFS x SIGAFIN
	Local lBaixaMnt		As Logical
	Local lFKCodRet		As Logical
	Local lContrRet		As Logical
	Local lEAIF080		As Logical
	Local lMvCheques    As Logical
	Local lChqMotBx		As Logical
	Local lContinua		As Logical
	Local llOpc			As Logical
	Local lExistASCC    As Logical

	Local cMvCheques	As Character
	Local cArquivo		As Character
	Local cNumero		As Character
	Local cPrefixo		As Character
	Local cParcela		As Character
	Local cFornece		As Character
	Local cSeqFRF		As Character
	Local cChaveFK7 	As Character
	Local cCamposIR		As Character
	Local cCamposPCC	As Character
	Local cChaveCH		As Character
	Local cIdFK4		As Character
	Local cIdFk4IR		As Character
	Local cBanco 		As Character
	Local cAgencia		As Character
	Local cConta		As Character
	Local cTpDesc		As Character
	Local cTpDescSE5	As Character
	Local cModSpb		As Character
	Local cTitOrig		As Character
	Local cChaveSE5		As Character
	Local cRecPag		As Character
	Local cChavePai		As Character
	Local cChaveTit 	As Character	//Dados da tabela auxiliar com o código do título a pagar
	Local cNatIss		As Character
	Local cE5TABORI		As Character
	LOCAL cE5IDORIG		As Character
	Local cCodRet		As Character
	Local cSequencia 	As Character
	Local cE5_Histor 	As Character // Historico retornado pelo PE FA090SE5
	Local cBcoTit		As Character
	Local cAgeTit		As Character
	Local cCtaTit		As Character
	Local cChqTit		As Character
	Local cCheque		As Character
	Local cBordAnt 		As Character
	Local cFilCorr 		As Character
	Local cLiberado		As Character

	Local aSE5Baixado	As Array
	Local aTitBaixado	As Array
	Local aSE2Pagant	As Array
	Local aRegCtBor		As Array	// Array com os recnos de Fornecedor e Banco para contabilizacao Bordero/Bordero
	Local aDiario		As Array
	Local aColsSEV		As Array
	Local aGrvLctPco 	As Array
	Local aFlagCTB		As Array
	Local aRecSE2		As Array
	Local aArea			As Array
	Local aAreaSEA		As Array
	Local aRec090Se5	As Array
	Local aTitCalc		As Array
	Local aImpostos		As Array
	Local aPCC      	As Array
	Local aAreaSE52		As Array
	Local aCodRet		As Array
	Local aOutImp		As Array
	Local aEaiRet 		As Array

	Local oModelBxP		As Object 	//Model de baixas a pagar
	Local oSubFK2		As Object 	//BAIXAS A PAGAR - Model Baixa
	Local oSubFK3		As Object 	//IMPOSTOS CALCULADOS - Model Baixa
	Local oSubFK4		As Object 	//IMPOSTOS RETIDOS - Model Baixa
	Local oSubFK5		As Object 	//MOVTO BANCARIO - Model Baixa
	Local oSubFK6		As Object 	//VALORES COMPLEMENTARES - Model Baixa
	Local oSubFKA		As Object 	//TABELA DE RASTREIO - Model Baixa
	Local oModelMov		As Object  	//Model de Movimento bancario
	Local oSubFKAM		As Object 	//TABELA DE RASTREIO - Model de Movimento bancario
	Local oSubFK5M		As Object 	//MOVTO BANCARIO - Model Movimento Bancario

	Local dDtLanc		As Date
	Local lFK4CLIFOR	As Logical
	Local cMV_PISNAT 	As Character
	Local cMV_COFINS	As Character
	Local cMV_CSLL		As Character
	Local cMV_ISS		As Character
	Local cFilOriCtb	As Character
	Local cAliasQRY     As Character
	Local cTblName      As Character
	Local lSimpIRAlu	As Logical
	Local lPaisMI		As Logical
	Local jTitFilho     As Json
	Local nLiObFilho 	As Numeric
	Local bWhile		As Codeblock

	PRIVATE cMFilial	As Character

	DEFAULT lF090Auto	:= .F.
	DEFAULT nTipoBx		:= 1
	DEFAULT lPCCBaixa	:= .F.
	DEFAULT lMovBcoBx	:= .F.
	DEFAULT cPadrao		:= "530"
	DEFAULT lPadrao		:= .F.
	DEFAULT cCheq090	:= ""
	DEFAULT cBenef090	:= ""
	DEFAULT cNatur090	:= ""
	DEFAULT cHistor090	:= ""
	DEFAULT lUsaFlag	:= SuperGetMV("MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	DEFAULT lSpbInUse	:= SpbInUse()
	DEFAULT lAtuSldBco	:= SuperGetMv("MV_ATUSLBC",.F.,.T.)
	DEFAULT lMultNat	:= .F.
	DEFAULT cFilBaixa	:= cFilAnt
	DEFAULT lCheque		:= .F.
	DEFAULT cDescrMo	:= ""
	DEFAULT nTotAger	:= 0
	DEFAULT lGerTotal 	:= .F.
	DEFAULT aVendor		:= {}
	DEFAULT __dLastPcc	:= CTOD("22/06/2015")
	DEFAULT __lFinVDoc	:= GetNewPar("MV_FINVDOC","2") == "1" //Controle de validacao de documentos obrigatorios
	DEFAULT __cMVCARTE  := GetMv("MV_CARTEIR")
	DEFAULT __lUsaPCO	:= SuperGetMV("MV_PCOINTE",.F.,"2") =="1"
	DEFAULT __nMVMCUST 	:= Val(GetMv("MV_MCUSTO"))
	DEFAULT __lMVVENDO  := SuperGetMv("MV_BXAUTVE",.F.,.F.)
	DEFAULT __nTamHist	:= TamSx3("E5_HISTOR")[1]
	DEFAULT __lTemMR	:= FTemMotor()
	DEFAULT __lFKDBx	:= ExistFunc("FAtuFKDBx")
	DEFAULT __lFINA095	:= IsInCallStack("FINA095")
	DEFAULT __cLayout	:= FWSM0Layout()
	DEFAULT __lGestao	:= "E" $ __cLayout .Or. "U" $ __cLayout
	DEFAULT __cFilSE2	:= IIF( __lGestao , FwFilial("SE2") , xFilial("SE2") )
	DEFAULT __cFilSEA	:= IIF( __lGestao , FwFilial("SEA") , xFilial("SEA") )
	DEFAULT __cFilSE5	:= IIF( __lGestao , FwFilial("SE5") , xFilial("SE5") )
	DEFAULT __cFilSEF	:= IIF( __lGestao , FwFilial("SEF") , xFilial("SEF") )
	DEFAULT __cFilSA6	:= IIF( __lGestao , FwFilial("SA6") , xFilial("SA6") )
	DEFAULT __cFilSEK	:= IIF( __lGestao , FwFilial("SEK") , xFilial("SEK") )
	DEFAULT __cFilSED	:= IIF( __lGestao , FwFilial("SED") , xFilial("SED") )
	DEFAULT __cFilSA2	:= IIF( __lGestao , FwFilial("SA2") , xFilial("SA2") )

	nX 				:= 0
	nY 				:= 0
	nZ				:= 0
	nI 				:= 0
	nTotal			:= 0
	nHdlPrv			:= 0
	nSaldo			:= 0
	nSaldoCru		:= 0
	nSalDup			:= 0
	nRegAtu			:= 0
	nTotAbtF 		:= 0
	nValorCheq		:= 0
	nRegPrinc 		:= 0
	nLen 			:= 0
	nOldRetPis		:= 0
	nOldRetCof		:= 0
	nOldRetCsl		:= 0
	nTotLtEZ		:= 0	//Totalizador da Bx Lote Mult Nat CC
	nValorTotal		:= 0
	nRecNoSE5		:= 0
	nRecNoSE2		:= 0
	nRecNoFK2		:= 0
	nRecnSE5		:= 0
	nOrderSEF		:= 0
	nValorSE5		:= 0
	nLstRecSE5 		:= 0
	nSalTit 		:= 0
	nGerPAMov 		:= 0
	nTotARet		:= 0
	nTamTitPai		:= TAMSX3("E2_TITPAI")[1]
	nRecPAInc 		:= 0
	nCentMd1		:= (MsDecimais(1) + 1)
	nVA				:= 0
	nTxMoedBx		:= 0
	nValorSEF		:= 0
	nRecSE2			:= 0
	nImposMR	 	:= 0
	nDtContOn		:= SuperGetMv("MV_DTCNBXP",.F.,3) // Data para contabilização Online baixas pagar 1- Data Digitação; 2- Data Disponibilidade; 3- Data Pagamento
	nVlMinImp 		:= GetNewPar("MV_VL10925",5000)
	nQtdBD       	:= 0
	lPadAux 		:= .F.
	lPadrao532 		:= VerPadrao("532") .And. MV_PAR03 == 1
	lPadrao530 		:= VerPadrao("530") .And. MV_PAR03 == 1
	lPadrao513 		:= VerPadrao("513") .And. MV_PAR03 == 1
	lRetParc 		:= .T.
	lBaixaPA		:= .F.
	lIsTitPA		:= .F.
	lAchouFor		:= .F.
	lGerPAMov		:= .F.
	lCtbIncPA 		:= .F.
	lPAMov			:= .F.
	lNewProc		:= .T.
	lRetBor			:= .T.
	lCalcPccBx 		:= .F.
	lIRPFBaixa 		:= .F.
	lCalcIssBx 		:= .F.
	lVendor			:= .F.
	lPadraoVd		:= .F.
	lAplVlMin 		:= .T.
	lBord241 		:= .F.
	lBord240		:= .F.
	lIsCaixa		:= .F.
	lTotPorBord		:= .F.
	lOk				:= .F.	//Controla se foi confirmada a distribuicao
	lSetAuto		:= .F.
	lSetHelp		:= .F.
	lDtBaixa		:= .F.
	lPCC241			:= .F.
	lRet 			:= .T.
	lDigita			:= IIF(mv_par01==1,.T.,.F.)
	lAglut			:= IIF(mv_par02==1,.T.,.F.)
	lFa080Sef 		:= ExistBlock("FA080SEF")
	lFa090Se5 		:= ExistBlock("FA090SE5")
	lF90Se5Grv 		:= ExistBlock("F90SE5GRV") // PE para gravacoes complementares da baixa
	lFa090Desc		:= ExistBlock("FA090DES")
	lFa090Juros		:= ExistBlock("FA090JUR")
	lFa090Mult		:= ExistBlock("FA090MUL")
	lFina090  		:= ExistBlock("FINA090" )
	lFa090Tx    	:= ExistBlock("FA090TX" )
	lFa090Tit		:= ExistBlock("FA090TIT")
	lFa090Corr		:= ExistBlock("FA090COR")
	lF090SE5		:= Existblock("F090SE5")
	lF091Natur   	:= Existblock("F091NATUR")
	lAtuForn		:= SuperGetMv("MV_ATUFORN",.F.,.T.)
	lCtMovPa		:= SuperGetMv("MV_CTMOVPA",.T.,"1") == "2" // Indica se a Contabilizacao do LP513 ocorrer  pelo T¡tulo(SE2) ou Mov.Bancario(SE5) do Pagamento Antecipado. 1="SE2" / 2="SE5"
	lBxTxa 			:= SuperGetMv("MV_BXTXA",.F.,"1") == "1"
	lExistFJU 		:= FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")
	lJGrvBxPag 		:= FindFunction("JGrvBxPag")	//Integração SIGAPFS x SIGAFIN
	lBaixaMnt		:= SuperGetMv("MV_NGMNTFI",,"N") == 'S' .And. FindFunction( "NGBAIXASE2" )	//Integração Manutenção de Ativos
	lFKCodRet		:= (cPaisLoc == "BRA" .and. FK3->(FieldPos("FK3_CODRET")) > 0 .and. FK4->(FieldPos("FK4_CODRET")) > 0)
	lContrRet		:= (cPaisLoc == "BRA")
	lEAIF080		:= FWHasEAI("FINA080",.T.,,.T.)
	lMvCheques    	:= Type('MVCHEQUES')=='C'
	lChqMotBx		:= ChqMotBx(cMotBx)
	lContinua		:= .T.
	llOpc			:= .F.
	lExistASCC      := Findfunction("AtuSldCC")
	lSimpIRAlu		:= .F.
	cMvCheques		:= IIF(lMvCheques,MVCHEQUES,MVCHEQUE)
	cArquivo		:= ""
	cNumero			:= ""
	cPrefixo		:= ""
	cParcela		:= ""
	cFornece		:= ""
	cSeqFRF			:= ""
	cChaveFK7 		:= ""
	cCamposIR		:= ""
	cCamposPCC		:= ""
	cChaveCH		:= ""
	cIdFK4			:= ""
	cIdFk4IR		:= ""
	cBanco 			:= ""
	cAgencia		:= ""
	cConta			:= ""
	cTpDesc			:= "2"
	cTpDescSE5		:= "I"
	cModSpb			:= "1"
	cTitOrig		:= ""
	cChaveSE5		:= ""
	cRecPag			:= "P"
	cChavePai		:= ""
	cChaveTit 		:= ""	//Dados da tabela auxiliar com o código do título a pagar
	cNatIss			:= ""
	cE5TABORI		:= ''
	cE5IDORIG		:= ''
	cCodRet			:= ""
	cSequencia 		:= Replicate("0",TamSX3("E5_SEQ")[1])
	cE5_Histor 		:= CRIAVAR("E5_HISTOR") // Historico retornado pelo PE FA090SE5
	cBcoTit			:= CRIAVAR("E5_BANCO")
	cAgeTit			:= CRIAVAR("E5_AGENCIA")
	cCtaTit			:= CRIAVAR("E5_CONTA")
	cChqTit			:= CRIAVAR("E5_NUMCHEQ")
	cCheque			:= CRIAVAR("E5_NUMCHEQ")
	cBordAnt 		:= Space(6)
	cFilCorr 		:= cFilAnt
	cLiberado		:= IIf(SuperGetMv("MV_LIBCHEQ")=="S","S"," ")

	aSE5Baixado		:= {}
	aTitBaixado		:= {}
	aSE2Pagant		:= {}
	aRegCtBor		:= {}	// Array com os recnos de Fornecedor e Banco para contabilizacao Bordero/Bordero
	aDiario			:= {}
	aColsSEV		:= {}
	aGrvLctPco 		:= {{"000006","02","FINA090"}, {"000006","03","FINA090"}}
	aFlagCTB		:= {}
	aRecSE2			:= {}
	aArea			:= {}
	aAreaSEA		:= {}
	aRec090Se5		:= {}
	aTitCalc		:= {}
	aImpostos		:= {}
	aPCC      		:= {}
	aAreaSE52		:= {}
	aCodRet			:= {}
	aOutImp			:= {}
	aEaiRet 		:= {}

	oModelBxP		:= Nil	//Model de baixas a pagar
	oSubFK2			:= NIL	//BAIXAS A PAGAR - Model Baixa
	oSubFK3			:= NIL	//IMPOSTOS CALCULADOS - Model Baixa
	oSubFK4			:= NIL	//IMPOSTOS RETIDOS - Model Baixa
	oSubFK5			:= NIL	//MOVTO BANCARIO - Model Baixa
	oSubFK6			:= NIL	//VALORES COMPLEMENTARES - Model Baixa
	oSubFKA			:= NIL	//TABELA DE RASTREIO - Model Baixa
	oModelMov		:= Nil 	//Model de Movimento bancario
	oSubFKAM		:= NIL	//TABELA DE RASTREIO - Model de Movimento bancario
	oSubFK5M		:= NIL	//MOVTO BANCARIO - Model Movimento Ban

	dDtLanc			:= dDataBase
	lFK4CLIFOR		:= FK4->(FieldPos("FK4_CLIFOR")) > 0
	cMV_PISNAT 		:= SuperGetMV("MV_PISNAT")
	cMV_COFINS		:= SuperGetMV("MV_COFINS")
	cMV_CSLL		:= SuperGetMV("MV_CSLL")
	cMV_ISS			:= &(GetMv("MV_ISS"))
	cFilOriCtb		:= ""
	cAliasQRY     	:= GetNextAlias()
	cTblName      	:= ""

	cMFilial		:= ""
	If __lSX8
		ConfirmSX8()
	Endif

	If lPCCBaixa .and. dBaixa >= __dLastPcc .And. !lEmpPub
		nVlMinImp	:= 0
	EndIf

	If __nDedSimpl == Nil
		__nDedSimpl  := SuperGetMV("MV_FVL1171",.F.,528) //Valor do desconto simplificado do IRPF
	EndIf
	
	If __lDicSimpl == NIL
	    __lDicSimpl := (AliasInDic("DKE") .And. DKE->(FieldPos("DKE_IRSIMP")) > 0) .And. FK4->(FieldPos("FK4_DEDIRS")) > 0
    Endif

	If __lBordeImp == Nil
		__lBordeImp := FindFunction("BorderoImp")
	EndIf
	
	cTpDescSE5 := If( mv_par06 == 1 , "C" , "I")
	cTpDesc	   := cValToChar(mv_par06)

	dbSelectArea(cAliasSE2)
	(cAliasSE2)->(dbGoTop())

	Valor      := 0		//TOTAL DAS BAIXAS
	Valor2     := 0		//TOTAL DOS ABATIMENTOS (por titulo)
	ABATIMENTO := 0

	dbSelectArea("SE2")
	nTotAGer := 0
	cBordAnt := Space(6)
	nValorCheq	:= 0
	nQtdBD := 0

	lPaisMI := (FindFunction("FA080MI") .And. FA080MI())

	If __oBillRel == Nil
		If FindFunction("UsaBillRel")
			__oBillRel := UsaBillRel()
		EndIf
	EndIf
	jTitFilho  := JsonObject():New()
	nLiObFilho := 0
	bWhile     := {|| .F. }

	//-- Verificação de quantos borderôs foram selecionados para controlar
	cTblName := "%"+__oFIN0901:GetRealName()+"%"
	BEGINSQL ALIAS cAliasQRY
            SELECT COUNT(*) QTBORDERO 
            FROM (  SELECT E2_FILIAL,E2_NUMBOR 
                    FROM %exp:cTblName% 
                    WHERE E2_OK <> ' ' GROUP BY E2_FILIAL,E2_NUMBOR
            ) SUBQRY
	ENDSQL
	If (cAliasQry)->(!Eof())
		nQtdBD := (cAliasQry)->QTBORDERO
	EndIf
	(cAliasQry)->(DbCloseArea())

	BEGIN TRANSACTION
		(cAliasSE2)->(dbSetOrder(__nIdxE2OK))

		(cAliasSE2)->(dbSeek(cMarca))
		SE2->(dbGoto((cAliasSE2)->NUM_REG))

		While (cAliasSE2)->(!Eof()) .And. (cAliasSE2)->E2_OK == cMarca
			SE2->(dbGoto((cAliasSE2)->NUM_REG))

			//Se for Totalmente exclusiva deve gravar o SE5 com a filial do E2_FILORIG
			If !EMPTY(__cFilSE2) .And. !EMPTY(__cFilSEA) .AND. !EMPTY(__cFilSE5) .And. !EMPTY(__cFilSA6)
				cFilant := SE2->E2_FILORIG
			else
				//A gravação da E5_FILIAL = se a SA6 EXCLUSIVA gravar a Filial do BANCO, se SA6 Compartilhada gravar a Filial do TÍTULO
				cFilant := IIF(!EMPTY(__cFilSA6),cFilAnt,SE2->E2_FILORIG)
			EndIf
			cFilOriCtb := SE2->E2_FILORIG

			//Restaura o valor padrao
			lIRPFBaixa	:= .F.
			lBord240	:= (nTipoBx==2 .And. cBordAnt==SE2->E2_NUMBOR)

			If SE2->E2_MOEDA > 1
				nTxMoedBx := If(SE2->E2_TXMOEDA > 0, SE2->E2_TXMOEDA,RecMoeda(dBaixa, SE2->E2_MOEDA))
			Else
				nTxMoedBx := 0
			EndIf

			If SE2->E2_OK == cMarca
				IF nTipoBx == 2 .and. cBordAnt != SE2->E2_NUMBOR   //Baixas de bordero
					cBordAnt := SE2->E2_NUMBOR
					SEA->(dbSetOrder(4))

					If SEA->(dbSeek(SE2->E2_FILORIG + SE2->(E2_NUMBOR+"P"+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA), .F.))

						lBord240:=(Alltrim(SEA->EA_ORIGEM)=='FINA240')

						SA6->(dbSetOrder(1))

						If Empty( __cFilSA6 )
							cMFilial := xFilial("SA6")
						Else
							If Empty( __cFilSE2 )
								cMFilial := xFilial("SA6")
							Else
								cMFilial := SE2->E2_FILIAL
							EndIf
						EndIf

						SA6->(dbSeek(cMFilial+SEA->EA_PORTADO+SEA->EA_AGEDEP+SEA->EA_NUMCON))
					Else
						Help(" ",1,"BORDERO",,STR0119 + cBordAnt + STR0120,1,0) //"Nao é possivel realizar a baixa de pagamento antecipado sem movimentação bancária."
						aAreaBKPSE2 := GETAREA()
						dbSelectArea("SE2")
						SE2->(dbSetOrder(2))
						RESTAREA(aAreaBKPSE2)
						DisarmTransaction()
						lContinua := .F.
						EXIT
					Endif
					dbSelectArea(cAliasSE2)
				EndIf

				If lContinua
					If cPaisLoc != 'BRA' .And. !Empty(SE2->E2_ORDPAGO) .And. SE2->E2_TIPO $ cMvCheques .And. !(SE2->E2_TIPO $ MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVENVBCOR)
						SEK->(DbSetOrder(1))

						If Empty( __cFilSEK )
							cMFilial := xFilial("SEK")
						Else
							If Empty( __cFilSE2 )
								cMFilial := xFilial("SEK")
							Else
								cMFilial := SE2->E2_FILIAL
							EndIf
						EndIf

						If SEK->(DbSeek(cMFilial+SE2->E2_ORDPAGO+"CP"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)) .And. (IIF(cPaisLoc != 'BRA',.F.,Empty(SEK->EK_DOCREC)))
							(cAliasSE2)->(DbSkip())
							Loop
						Endif
					Endif

					//Ponto de Entrada - para confirmacao da baixa
					If lFa090Tit
						lRet	:= ExecBlock("FA090TIT",.F.,.F.,{cBco090,cAge090,cCta090,cCheq090})
						If !lRet
							(cAliasSE2)->(dbSkip())
							nY++		//Controle da baixa automatizada
							Loop
						EndIf
					Endif

					//Posiciona no Cadastro de Naturezas
					SED->(dbSetOrder(1))
					SED->(dbSeek(xFilial("SED",SE2->E2_FILORIG)+SE2->E2_NATUREZ))
					SA2->(dbSetOrder(1))
					SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))

					If Empty( __cFilSED )
						cMFilial := xFilial("SED")
					Else
						If Empty( __cFilSE2 )
							cMFilial := xFilial("SED")
						Else
							cMFilial := SE2->E2_FILIAL
						EndIf
					EndIf

					__nBasLeg := 0

					//Motor de retenções
					If __lTemMR
						F090VldImp(.F.)
					EndIf

					lCalcPccBx := .F.
					lIRPFBaixa := .F.
					lAplMinP := .F.
					lCalcIssBx := .F.
					lIsTitPA := SE2->E2_TIPO $ MVPAGANT

					If !__lPccMR .And. lPccBaixa .And. cPaisLoc == "BRA"
						//Verifico se a combinacao Cliente x Natureza calcula PCC
						If SA2->A2_TIPO == 'J'.and. ;
								((SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL == "2") .or. ;
								(SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2") .or. ;
								(SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS  == "2") )

							lCalcPccBx := .T.
						EndIf
					EndIf

					lIRPFBaixa := !__lIrfMR .And. cPaisLoc == "BRA" .And. SA2->A2_CALCIRF == "2" .and. SED->ED_CALCIRF == "S" .and. !lIsTitPA

					lAplMinP := SA2->(ColumnPos('A2_MINPUB')) > 0 .And. SA2->A2_MINPUB == "2"

					lCalcIssBx := !__lIssMR .AND. IsIssBx("P")

					dbSelectArea("SE2")
					nRegAtu     := SE2->(RecNo())
					nSaldo		:= SE2->E2_SALDO
					nSaldoCru	:= Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoedaBco,,3,If(cPaisLoc == "BRA",SE2->E2_TXMOEDA,0)),3),2)
					nValorTotal += nSaldoCru
					cNumero		:= SE2->E2_NUM
					cPrefixo	:= SE2->E2_PREFIXO
					cParcela	:= SE2->E2_PARCELA
					cFornece	:= SE2->E2_FORNECE
					nTotAbat	:= 0
					nTotAbtF	:= 0   // Abatimento na moeda do titulo
					nMoeda		:= 2
					nJuros		:= 0
					nDescont	:= 0
					nVA			:= 0
					nMulta   	:= 0

					fa080Juros(nMoedaBco)

					nVA := FValAcess( SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NATUREZ, .T. ,, "P", dDatabase, , SE2->E2_MOEDA )

					nCorrec		:= fa090Correc( )
					nAcresc     := Round(NoRound(xMoeda(SE2->E2_SDACRES,SE2->E2_MOEDA,nMoedaBco,,3,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)),3),2)
					nDecresc    := Round(NoRound(xMoeda(SE2->E2_SDDECRE,SE2->E2_MOEDA,nMoedaBco,,3,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)),3),2)
					nPis		:= 0
					nCofins		:= 0
					nCsll		:= 0
					nValPgto	:= 0
					nIrrf		:= 0
					lAplVlMin	:= .T.
					nIss		:= 0
					nBaseIrpf	:= 0
					lBaixaPA    := SE2->E2_TIPO $ MVPAGANT
					lCtbIncPA   := lBaixaPA .And. AllTrim(SE2->E2_LA) == "S"
					lGerPAMov	:= .F.
					nInss		:= 0
					nDescCalc 	:= 0
					nJurosCalc 	:= 0
					nVACalc		:= 0
					nMultaCalc 	:= 0
					nCorrCalc	:= 0
					nDifCboCalc	:= 0
					nImpSubCalc	:= 0
					nPisCalc	:= 0
					nCofCalc	:= 0
					nCslCalc	:= 0
					nIrfCalc	:= 0
					nIssCalc	:= 0
					nPisBaseR 	:= 0
					nCofBaseR	:= 0
					nCslBaseR 	:= 0
					nIrfBaseR 	:= 0
					nIssBaseR 	:= 0
					nPisBaseC 	:= 0
					nCofBaseC 	:= 0
					nCslBaseC 	:= 0
					nIrfBaseC 	:= 0
					nIssBaseC 	:= 0
					nRecSE2		:= SE2->(RecNo())
					//Dados da tabela auxiliar com o código do título a pagar
					cChaveTit := xFilial("SE2",SE2->E2_FILORIG) + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" + SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
					cChaveFK7 := FINGRVFK7("SE2", cChaveTit, SE2->E2_FILORIG)
					lRetBor   := .T.

					f090LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

					If (ALLTRIM(SE2->E2_ORIGEM) $ "FINA667|FINA677")
						FINATURES(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),.T.,SE2->E2_ORIGEM,"P")
					Endif

					If SE2->E2_APLVLMN == "2"
						lAplVlMin := .F.
					Endif

					If nTipoBx = 1
						If lPadrao530
							lPadrao := (cCtBaixa $ "BA" .Or. !lMovBcoBx .Or.(lMovBcoBx .And. !lChqMotBx))

							If !lPadrao .And. cCtBaixa $ "C" .And. !Empty(cCheq090) .And. SubStr(cCheq090, 1, 1 ) != "*" .And. SE2->E2_IMPCHEQ != "S"
								lPadrao := .T.
							Endif
						EndIf
						cPadrao	:= "530"
					Else
						lPadrao := lPadrao532
						cPadrao	:= "532"					
					Endif

					lPadAux := lPadrao

					If lFa090Desc
						nDescont := Execblock("FA090DES",.F.,.F.)
					Endif

					If lFa090Juros
						nJuros := Execblock("FA090JUR",.F.,.F.)
					Endif

					If lFa090Mult
						nMulta := Execblock("FA090MUL",.F.,.F.)
					Endif

					If lFa090Corr
						nCorrec := Execblock("FA090COR",.F.,.F.)
					Endif

					//Verifica se existe cheque sobre titulo e busca os dados do cheque para gravacao no SE5
					If SE2->E2_IMPCHEQ == "S" .AND. !(cPaisloc != "BRA" .and. __lFINA095)
						SEF->(dbSetOrder(3))

						If Empty( __cFilSEF )
							cMFilial := xFilial("SEF")
						Else
							If Empty( __cFilSE2 )
								cMFilial := xFilial("SEF")
							Else
								cMFilial := SE2->E2_FILIAL
							EndIf
						EndIf

						If DbSeek(cMFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)
							WHILE !(SEF->(EOF())) .And. (cMFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO ==  SEF->EF_FILIAL + SEF->EF_PREFIXO+SEF->EF_TITULO+SEF->EF_PARCELA+SEF->EF_TIPO)
								IF Empty(SEF->EF_SEQUENC) .and. SEF->EF_FORNECE+SEF->EF_LOJA == SE2->E2_FORNECE+SE2->E2_LOJA
									cBcoTit	:=SEF->EF_BANCO
									cAgeTit	:=SEF->EF_AGENCIA
									cCtaTit	:=SEF->EF_CONTA
									cChqTit	:=SEF->EF_NUM
									EXIT
								Endif
								SEF->(DbSkip())
							ENDDO
						Endif
					EndIf

					//Baixar titulos de abatimento se for baixa total
					If Select("__SE2") == 0
						ChkFile("SE2",.F.,"__SE2")
					Else
						DbSelectArea("__SE2")
					EndIf

					__SE2->(dbSetOrder(1))
					__SE2->(dbSeek(xFilial("SE2")+cPrefixo+cNumero+cParcela))

					While !__SE2->(EOF()) .And. __SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA) == (xFilial("SE2") + cPrefixo+cNumero+cParcela)
						If __SE2->E2_TIPO $ MVABATIM .And. __SE2->E2_FORNECE == cFornece
							nTotAbat += Round(NoRound(xMoeda(__SE2->E2_SALDO, __SE2->E2_MOEDA, nMoedaBco, Nil, 3, If(cPaisLoc == "BRA", __SE2->E2_TXMOEDA,0)), 3), 2)
							nTotAbtF += __SE2->E2_SALDO
							nValorTotal -= nTotAbat

							RecLock("__SE2")
							Replace E2_SALDO	With 0
							Replace E2_BCOPAG	With cBco090
							Replace E2_BAIXA	With dBaixa
							Replace E2_LOTE		With cLoteFin
							Replace E2_MOVIMEN	With dBaixa
							Replace E2_SDACRES	With 0
							Replace E2_SDDECRE	With 0
						Endif

						__SE2->(dbSkip())
					Enddo

					dbSelectArea("SE2")
					SE2->(dbGoto(nRegAtu))

					If !Empty(SE2->E2_NUMBOR) .And. !SE2->E2_TIPO $ MVPAGANT+"|"+MVPROVIS+"|"+MV_CPNEG
						If __lBordeImp
							lRetBor := !BorderoImp(SE2->E2_FILORIG, SE2->E2_NUMBOR, "P", SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA)
						EndIf
						
						lRetBor := IIf(__lBordeImp, lRetBor, VLDBOR(SE2->E2_NUMBOR, "P", SE2->E2_FILORIG))
					Endif

					nValPgto	:= nSaldoCru - nTotAbat + nJuros + nVa + nMulta - nDescont + nAcresc - nDecresc - __nImpMR
					nValPgto	-= If(!__lPccMR .AND. lPccBaixa  .AND. nTipoBx == 1,(nPis+nCofins+nCsll),0)
					nValPgto	-= If(!__lIrfMR .AND. lIRPFBaixa .AND. nTipoBx == 1,nIrrf,0)
					nValPgto	-= If(!__lIssMR .AND. lCalcIssBx .AND. nTipoBx == 1,nIss ,0)
					nOldValPgto	:= nValPgto

					//--------------------------------------------------------------------
					// ISS
					//--------------------------------------------------------------------
					If !__lIssMR .and. lCalcIssBx .and. !lIsTitPA .and. (Empty(SE2->E2_NUMBOR) .or. (!Empty(SE2->E2_NUMBOR) .AND. lRetBor))
						F080IssBx()
					Endif

					//--------------------------------------------------------------------
					// IRRF
					//--------------------------------------------------------------------
					nOldValPgto := nValPgto
					nIRRF       := 0

					If !__lIrfMR .And. lIRPFBaixa .And. (nTipoBx == 1 .or. (nTipoBx == 2 .And. "FINA240" $ SEA->EA_ORIGEM)) .And. !( "MATA100" $ SE2->E2_ORIGEM .And. Empty( SE2->E2_BASEIRF ) .And. Empty( SE2->E2_IRRF ) )
						//----------------------------------------------------------------------------------------
						// Calculo do IR para baixa de títulos ou baixa de borderô sem impostos (FINA240)
						//----------------------------------------------------------------------------------------
						nIRRF := FCalcIRBx(0,SA2->A2_TIPO,dBaixa,dDebito,/*lAltValor*/,/*nTxmoeda*/,cMotBx)

					ElseIf !__lIrfMR .And. lIRPFBaixa .And. nTipoBx == 2 .And. ("FINA241" $ SEA->EA_ORIGEM) .And. !Empty( SE2->E2_BASEIRF )
						//------------------------------------------------------------------------------------------------------------------------------------
						// O bordero de impostos controla a retenção, mas no momento da baixa precisa gravar o campo E5_BASEIRF para cenários de cumulatividade
						// Gravação ocorrerá na montagem dos campos do SE5 dentro de FGRVSFQIR()
						//------------------------------------------------------------------------------------------------------------------------------------
						nBaseIrpf := SE2->E2_BASEIRF
					EndIf
					//--------------------------------------------------------------------
					// PCC
					//--------------------------------------------------------------------
					nVlRetPis := 0
					nVlRetCof := 0
					nVlRetCsl := 0

					If SE2->E2_PIS <> 0 .AND. SE2->E2_COFINS <> 0.AND. SE2->E2_CSLL <> 0 .AND. nVlRetPis==0 .AND. nVlRetCof==0 .AND. nVlRetCsl==0 .AND. !Empty(SE2->E2_NUMBOR)
						nVlRetPis := SE2->E2_PIS
						nVlRetCof := SE2->E2_COFINS
						nVlRetCsl := SE2->E2_CSLL
					Endif
					aAreaSEA := SEA->(GetArea())

					//Valida se já houve retenção no borderô.
					lBord241 := If(__lPccMR, __lPccBxMR, lPCCBaixa) .And. lContrRet .And.;
						!Empty(SE2->E2_NUMBOR) .And. ( SE2->E2_PRETPIS == '4' .OR. SE2->E2_PRETCOF == '4' .OR. SE2->E2_PRETCSL == '4')


					aTitCalc := {}

					If !__lPccMR .And. !lBord241 .And. cPaisLoc == "BRA" .And. lPccBaixa .And. lCalcPccBx .And. !lIsTitPA .And. VLDBOR(SE2->E2_NUMBOR,"P",cFilAnt)
						If (dBaixa < __dLastPcc .Or. lEmpPub)
							f080TotMes(dBaixa,.T.,,.F.)
						Else
							If Empty(__nBasLeg)
								nSalTit := salRefPag(SE2->E2_FORNECE+SE2->E2_LOJA)
							Else
								nSalTit := __nBasLeg
							EndIf

							nSalTit  += F080JuMuDe()

							aPCC := newMinPcc(dBaixa, nSalTit, SE2->E2_NATUREZ, "P", SE2->(E2_FORNECE + E2_LOJA),nIss,nInss,nIRRF, /*lMin*/, /*lIgnrOrg*/, cMotBx )

							If aPCC[1]
								nPis 	:= aPCC[2]
								nCofins := aPCC[3]
								nCsll   := aPCC[4]
								If len(aPCC)>4
									aTitCalc := aPCC[5]
								Endif
							Endif
						EndIf
					Endif

					If !lEmpPub
						nTotARet := If(!__lPccMR, (nPis+nCofins+nCsll), 0) + If(!__lIrfMR, nIrrf, 0)
					Endif

					nDiferImp := nValPgto - nTotARet
					If nDiferImp < 0
						aOutImp := {}

						If !__lPccMR
							aAdd(aOutImp, {"PIS", nPis })
							aAdd(aOutImp, {"COF", nCofins })
							aAdd(aOutImp, {"CSL", nCsll })
						EndIf

						If !__lIrfMR .And. lIRPFBaixa
							aAdd(aOutImp, {"IRF", nIrrf })
						EndIf

						If !__lIssMR .And. lCalcIssBx .And. nIss == 0
							aAdd(aOutImp, {"ISS", (SE2->E2_ISS - SE2->E2_VRETISS) })
						EndIf

						aDadosPar := verVrAR(nValPgto, aOutImp )
						If !__lPccMR
							nPis    := aDadosPar[1]
							nCofins := aDadosPar[2]
							nCsll   := aDadosPar[3]
						EndIf
					Endif
					RestArea(aAreaSEA)

					If !!__lIrfMR .And. lEmpPub .And. lAplMinP .And. lIRPFBaixa .And. (nPis+nCoFins+nCsll+nIrrf+aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] < nVlMPub .And.;
							!(aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] == 0 .And. aDadosRet[1] > 0))
						nPis := nCoFins := nCsll := nIrrf := 0
					EndIf

					nValPgto	:= nSaldoCru - nTotAbat + nJuros + nVa + nMulta - nDescont + nAcresc - nDecresc - __nImpMR
					nValPgto	-=  If(!__lPccMR .AND. lPccBaixa .AND. !lBord241,(nPis+nCofins+nCsll),0)
					nValPgto	-=  If(!__lIrfMR .AND. lIRPFBaixa .AND. !lBord241,nIrrf,0)
					nValPgto	-=  If(!__lIssMR .AND. lCalcIssBx .AND. lRetBor,nIss ,0)
					nOldValPgto := nValPgto

					If !__lInsMR
						nInss	:= SE2->E2_INSS
					Endif

					If !__lIssMR .AND. !lIRPFBaixa .And. SA2->A2_TIPO == "J" .And. !lIsTitPA
						If nIrrf == 0
							nIrrf	:= SE2->E2_IRRF
						Endif
					Endif

					dbSelectArea( "SE2" )

					If !__lPccMR .And. !__lIrfMR .And. !lPccBaixa .And. !lIRPFBaixa .and. !lIsTitPA
						//Atualiza a data de vencimento dos titulos de impostos
						AltVencImp(dDataBase)

						//Altera valor dos impostos
						F080Impost(SE2->(RECNO()),.F.,nJuros,nMulta,nDescont,nSaldoCru - nTotAbat + nJuros + nVA + nMulta - nDescont + nAcresc - nDecresc, nVA)
					Endif

					nJuros   := nJuros   + nAcresc
					nDescont := nDescont + nDecresc

					//caso o titulo de PA nao tenha movimento, não deve baixar
					IF lBaixaPA
						aAreaSE52:= getarea()
						SE5->(DbSetOrder(7))
						cChaveSE5 := SE2->(E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA) + SPACE(TAMSX3("E5_SEQ")[1])

						//verifica se PA possui movimentacao bancaria
						nRecPAInc := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

						If nRecPAInc == 0
							lBaixaPA := .F.
							lGerPAMov := .T.
						Endif

						If lGerPAMov
							cPadrao := "513"
							lPadrao := !lCtbIncPA .And. lCtMovPa .And. lPadrao513
						EndIf

						RestArea(aAreaSE52)
					EndIf

					If lGerPAMov
						nGerPAMov++
					EndIf

					//Atualiza a Baixa do Titulo
					If !lGerPAMov .and. (!(SE2->E2_TIPO $ MVTXA+"#"+MVPAGANT+"#"+"INA") .Or. (SE2->E2_TIPO $ MVTXA+"#"+MVPAGANT .and. lBxTxa) .or. lBaixaPA)
						RecLock("SE2")
						SE2->E2_OK	:= "  "

						//Verifico se existe data baixa indicando alguma baixa no título a pagar
						lDtBaixa := .T.

						If EMPTY(SE2->E2_BAIXA)
							lDtBaixa := .F.
						EndIf

						SE2-> E2_BAIXA	 := iif(SE2->E2_BAIXA <= dDatabase, dDatabase, SE2->E2_BAIXA)
						SE2-> E2_VALLIQ	 := nValPgto
						SE2-> E2_SALDO	 := 0
						SE2-> E2_MOVIMEN := SE2->E2_BAIXA
						SE2-> E2_BCOPAG	 := cBco090
						If lBxCnab
							SE2-> E2_LOTE := cLoteFin
						EndIF
						If !Empty(SE2->E2_PORTADO)
							SE2-> E2_BCOPAG	:= E2_PORTADO
						EndIf

						SE2-> E2_JUROS		:= nJuros
						SE2-> E2_CORREC		:= nCorrec
						SE2-> E2_DESCONT	:= nDescont
						SE2-> E2_MULTA		:= nMulta
						SE2-> E2_SDACRES	:= 0
						SE2-> E2_SDDECRE	:= 0

						If Empty(SE2->E2_NUMBCO) .And. !Empty(cCheq090)
							SE2->E2_NUMBCO   := cCheq090
						Endif

						If lContrRet .And. !__lPccMR .AND. lPCCBaixa .And. lBord241
							nOldRetPis := SE2->E2_VRETPIS
							nOldRetCof := SE2->E2_VRETCOF
							nOldRetCsl := SE2->E2_VRETCSL
						EndIf

						//Marco que o titulo tem os impostos calculados pela baixa (Pis, Cofins e Csll)
						If lContrRet .And. !__lPccMR .AND. lPCCBaixa
							//Nao alterar o valor dos PRET do PCC caso o mesmo tenha sido retido pelo FINA241
							If (SE2->E2_PRETPIS == "4" .OR. SE2->E2_PRETCOF == "4" .OR. SE2->E2_PRETCSL == "4")  .Or. (nPis+nCofins+nCsll>0)
								SE2->E2_PRETPIS := "3"
								SE2->E2_PRETCOF := "3"
								SE2->E2_PRETCSL := "3"
							EndIf
							//Gravo os valores de impostos retidos neste titulo
							SE2->E2_VRETPIS += nPis
							SE2->E2_VRETCOF += nCofins
							SE2->E2_VRETCSL += nCsll
						Endif

						// Atualiza o saldo da natureza. O valor jah esth liquido dos abatimentos, desta forma nao precisa atualizar na baixa dos abatimentos
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_BAIXA, SE2->E2_MOEDA, "3", "P", nValPgto, xMoeda(nValPgto,SE2->E2_MOEDA,1,SE2->E2_BAIXA,,,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)), If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"-","+"),,FunName(),"SE2",SE2->(Recno()),0)

						//Na baixa de títulos em bordero, os campos de controle de retenção de IR não precisam ser alterados.
						If !__lIrfMR .AND. lIRPFBaixa .And. nTipoBx == 1
							If !Empty( SE2->E2_PRETIRF ) .And. nIrrf > 0
								SE2->E2_PRETIRF := " "
							EndIf

							If SA2->A2_TIPO == "F"
								SE2->E2_IRRF += nIRRF
							EndIf

							SE2->E2_VRETIRF += nIrrf
						EndIf

						//Array para Vendor ou Contabilizar bordero totalizando por bordero
						If Ascan(aTitBaixado,{|X| x[1] == SE2->(Recno())}) = 0
							Aadd(aTitBaixado, {SE2->(Recno()),SE2->E2_NUMBOR} )
						Endif

						//Verifica se existe solicitacao de NCP e caso exista atualiza o campo CU_DTBAIXA...
						If cPaisLoc <> "BRA"
							A055AtuDtBx("1",SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NUM,SE2->E2_PREFIXO,SE2->E2_BAIXA)
							If Upper(Left(SE2->E2_NUMBCO,5))=="CJCC_"
								Fa550CJCC(Substr(SE2->E2_NUMBCO,6),"A")
							Endif
						EndIf

						//PE para controlar novas taxas financeiras
						If lFa090Tx
							Execblock("FA090TX",.F.,.F.)
						Endif

						MsUnlock()
						FA373Bx(.T.)
					ElseIf !lBxTxa .and. SE2->E2_OK <> 'TA'
						RecLock("SE2")
						SE2->E2_OK = 'TA'
						MsUnlock()
					Endif

					If lExistASCC .and. cPaisloc == "ARG" .and. Upper(Left(SE2->E2_NUMBCO,5))=="CJCC_"
						AtuSldCC(cNumero, dbaixa)
					Endif

					If cPaisLoc =="BRA"

						//Processo Normal (nao automatizado)
						If !lF090Auto

							If nTipoBx == 1  //Baixa Titulos
								lCheque := ChqMotBx(cMotBx)
							Else //Bordero
								lCheque := (nTipoBx == 2 .and. ChqMotBx(cMotBx))
							Endif

							//--------------------------------------------------------------
							// Caso gere movimento de baixa aglutinadora igual a Bx Lote
							//--------------------------------------------------------------
							//nTipoBx = 2 -> Bordero
							//lBxCnab -> Gera totalizador quando baixa CNAB
							//mv_par04 = 2 -> Gera cheque automaticamente
							//lMovBcoBx .and. !ChqMotBx(cMotBx) -> Movimenta banco sem cheque
							lGerTotal := IIf((nTipoBx == 2 .and. lBxCnab .and. lMovBcoBx .and. (mv_par04 == 2 .or. !ChqMotBx(cMotBx)) ), .T.,.F.)

							// Caso banco seja Caixa, nao deve gerar cheque
							If	nTipoBx == 2 .and. ((Substr(SEA->EA_PORTADO,1,2) == "CX" .and. lMovBcoBx) .or. (SEA->EA_PORTADO $ __cMVCARTE .and. lMovBcoBx))
								lCheque := .F.
								lIsCaixa := .T.
							Endif

							//Baixa de titulos em banco caixa deve gerar movimento bancario sem cheque
							//ainda que o motivo de baixa exija
							If	nTipoBx == 1 .and. ((Substr(cBco090,1,2) == "CX" .and. lMovBcoBx) .or. (cBco090 $ __cMVCARTE .and. lMovBcoBx))
								lCheque := .F.
								lGerTotal := IIf(lBxCnab,.T.,.F.)
								lIsCaixa := .T.
							Endif
						Else
							//Processo automatizado
							lCheque := IIF((!Empty(cCheq090) .and. ChqMotBx(cMotBx)),.T., IIF( ChqMotBx(cMotBx),.T.,.F.))

							//Caso gere cheque, o totalizador sera o cheque Caso não gere cheque e MV_BXCNAB = S, gera totalizador
							lGerTotal := lBxCnab .and. !lCheque .and. lMovBcoBx

							If !Empty(cCheq090) .and. ((Substr(cBco090,1,2) == "CX" .and. lMovBcoBx) .or.;
									(cBco090 $ __cMVCARTE .and. lMovBcoBx))
								lCheque := .F.
								lIsCaixa := .T.
							Endif
						Endif

						VAR_IXB := lCheque
					Endif

					lNewProc  := .T.

					//Baixa de PA ou geração de Mov do mesmo não gera novo processo, utiliza o processo criado na inclusão
					If lIsTitPA .AND. lGerPAMov
						FKA->(dbSetOrder(3))
						If FKA->(MsSeek(xFilial("FKA") + "SE2" + cChaveFK7))
							lNewProc := .F.
							BxGerMovPA(.T.)
							cE5TABORI := "SE2"
							cE5IDORIG := cChaveFK7
							FinSetAPrc("SE2")
						EndIf
					EndIf
					//Dados da tabela auxiliar com o código do título a pagar
					cIdFK2 	  := FWUUIDV4()
					cCamposE5 := ""
					aImpostos := {}
					//aImpostos[1] = codigo imposto
					//aImpostos[2] = imposto calculado
					//aImpostos[3] = natureza
					//aImpostos[4] = cIdFK4
					//aImpostos[5] = imposto retido
					//aImpostos[6] = base calculado
					//aImpostos[7] = base retencao
					//aImpostos[8] = Código tipo de retenção (FKM)
					//aImpostos[9] = Codigo Fornecedor
					//aImpostos[10] = Loja fornecedor
					//aImpostos[11] = CNPJ/CPF de rentenção
					//aImpostos[12] = Codigo de retenção. 
					//aImpostos[13] = Dedução IR Aluguel Simp. 

					//REESTRUTURACAO SE5
					//Carrego model de Bx Pagar
					If !lGerPaMov
						oModelBxP	:= FWLoadModel("FINM020")	//Model de baixas a pagar
						oModelBxP:SetOperation(MODEL_OPERATION_INSERT) //Inclusao
						oModelBxP:Activate()
						oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
						oModelBxP:SetValue( "MASTER", "NOVOPROC", lNewProc) //Novo processo
						oSubFK2  := oModelBxP:GetModel("FK2DETAIL")
						oSubFK3  := oModelBxP:GetModel("FK3DETAIL")
						oSubFK4  := oModelBxP:GetModel("FK4DETAIL")
						oSubFK5  := oModelBxP:GetModel("FK5DETAIL")
						oSubFK6  := oModelBxP:GetModel("FK6DETAIL")
						oSubFKA  := oModelBxP:GetModel("FKADETAIL")
						//Para numerar as sequencias o sistema precisa procurar os registros com  tipodoc igual a VL, BA ou CP.
						cSequencia := FaNxtSeqBx("SE2", .T.)
						nValorTotal -= __nImpMR
						nValorTotal -= If(!__lPccMR .And. lPccBaixa, nPis + nCofins + nCsll, 0)
						nValorTotal -= If(!__lIrfMR .And. lIRPFBaixa, nIrrf, 0)
						nValorTotal -= If(!__lIssMR .And. lCalcIssBx, nIss, 0)
						nValorTotal += nJuros
						nValorTotal += nMulta
						nValorTotal += nVA
						nValorTotal -= nDescont
						nValorSEF	:= SE2->E2_VALLIQ
					Else
						oModelBxP	:= FWLoadModel("FINM050")	//Model de gravação do PA
						oModelBxP:SetOperation(MODEL_OPERATION_INSERT) //Inclusao
						oModelBxP:Activate()
						oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
						oModelBxP:SetValue( "MASTER", "NOVOPROC", lNewProc) //Novo processo
						oSubFK5  := oModelBxP:GetModel("FK5DETAIL")
						oSubFKA  := oModelBxP:GetModel("FKADETAIL")
						cSequencia := ""
						nValorTotal -= nSaldoCru
						nValorSEF	:= IIF(SE2->E2_MOEDA > 1 .And. nMoedaBco == 1, SE2->E2_VLCRUZ, SE2->E2_VALOR)
					Endif

					If cPaisLoc=="BRA"
						IF !lIsTitPA .and. lCheque .and. lMovBcoBx .and. SE2->E2_IMPCHEQ != "S" .and. !lGerTotal
							cChaveCH := FWUUIDV4()
							SA2->(dbSetOrder(1))
							SA2->(MSSeek(xFilial("SA2", SE2->E2_FILORIG) + SE2->E2_FORNECE + SE2->E2_LOJA))

							//Gravacao do cheque do titulo
							RecLock("SEF",.T.)
							SEF->EF_FILIAL		:= xFilial("SEF",cFilAnt)
							SEF->EF_PORTADO 	:= SE2->E2_PORTADO
							SEF->EF_VALOR		:= nValorSEF
							SEF->EF_DATA		:= dDataBase
							SEF->EF_HIST		:= IIF((!Empty(cCheq090) .And. Substr(cCheq090,1,1) != "*" ),IIF(AllTrim(cHistor090) != "",cHistor090,SE2->E2_HIST), SE2->E2_HIST) //"Cheque por Bx. Automatica"
							SEF->EF_PREFIXO		:= SE2->E2_PREFIXO
							SEF->EF_TITULO		:= SE2->E2_NUM
							SEF->EF_PARCELA		:= SE2->E2_PARCELA
							SEF->EF_TIPO		:= SE2->E2_TIPO
							SEF->EF_FORNECE		:= SE2->E2_FORNECE
							SEF->EF_LOJA		:= SE2->E2_LOJA
							SEF->EF_ORIGEM		:= "FINA090"
							SEF->EF_SEQUENC		:= cSequencia
							SEF->EF_BANCO		:= cBco090
							SEF->EF_AGENCIA		:= cAge090
							SEF->EF_CONTA		:= cCta090
							SEF->EF_BENEF		:= SA2->A2_NOME
							SEF->EF_LIBER		:= cLiberado

							If !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
								SEF->EF_NUM		:= cCheq090
								SEF->EF_LA      := Iif(mv_par04==1 .and. mv_par01==1 .and. lPadrao .and. ( cCtBaixa $ "BA") .and. !lUsaFlag,"S"," ")
								SEF->EF_IMPRESS := "A"
							Endif

							SEF->EF_FILORIG := SE2->E2_FILORIG
							SEF->EF_FILCHQ	:= cFilCorr
							SEF->EF_IDSEF	:= cChaveCH		//ID do cheque

							If !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
								SEF->EF_NUM		:= cCheq090
								SEF->EF_LA      := Iif(mv_par03==1 .and. mv_par04==1 .and. lPadrao .and. ( cCtBaixa $ "BA") .and. !lUsaFlag,"S"," ")
								SEF->EF_IMPRESS := "A"
							Endif

							//Dados do movimento bancario do Cheque
							If !oSubFKA:IsEmpty()
								//Inclui a quantidade de linhas necessárias
								oSubFKA:AddLine()
								//Vai para linha criada
								oSubFKA:GoLine( oSubFKA:Length() )
							Endif

							//Dados do Cheque  //revisar
							oSubFKA:SetValue( 'FKA_IDORIG', cChaveCH )
							oSubFKA:SetValue( 'FKA_TABORI', 'SEF' )

							If lFa080Sef
								Execblock("FA080SEF",.f.,.f.)
							Endif

							MsUnlock()
						Endif
					Endif

					If !lIsTitPA
						nTotaGer    += SE2->E2_VALLIQ
						nValorCheq  += IIF(SE2->E2_IMPCHEQ == "S",0,SE2->E2_VALLIQ)
					EndIf

					//Reestruturacao SE5
					nDescCalc 	:= nDescont
					nJurosCalc 	:= nJuros
					nVACalc	 	:= nVA
					nMultaCalc 	:= nMulta
					nCorrCalc	:= nCorrec

					//Grava registro referente a movimentação bancaria
					For nZ := 1 To 6
						//Atualiza a Movimentação Bancaria
						If nZ == 1
							nCpoTp  := SE2->E2_VALLIQ
							cTpDoc  := IIF(lCheque .or. lGerTotal	.Or. SE2->E2_IMPCHEQ == "S" .or. !lMovBcoBx ,"BA"	,"VL"	)

							//Se for baixa de um TXA e o mesmo nao deve zerar o saldo
							If (!lBxTxa .and. SE2->E2_TIPO $ MVTXA ) .or. SE2->E2_TIPO $ "INA"
								nCpoTp  := SE2->E2_VALOR
							Endif

							IF lGerPaMov
								nCpoTp  := IIF(SE2->E2_MOEDA > 1 .And. nMoedaBco == 1, SE2->E2_VLCRUZ, SE2->E2_VALOR)
								cTpDoc  := "PA"
							Else
								If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
									cTpDoc := Iif(MovBcoBx(cMotBx, .T.),"VL","BA")
								EndIf
							EndIf
							cHistMov	:= IIF(lMovBcoBx,STR0029,cDescrMo) // "Valor pago s /Titulo"
						Elseif nZ == 2
							nCpoTp   := nDescont
							cTpDoc   := "DC"
							cHistMov := STR0032 //"Desconto s/Receb.Titulo"
							nCpoCalc := nDescCalc
						Elseif nZ == 3
							nCpoTp   := nJuros
							cTpDoc   := "JR"
							cHistMov := STR0030 //"Juros s/Receb.Titulo"
							nCpoCalc := nJurosCalc
						Elseif nZ == 4
							nCpoTp   := nMulta
							cTpDoc   := "MT"
							cHistMov := STR0033 //"Multa s/Receb.Titulo"
							nCpoCalc := nMultaCalc
						Elseif nZ == 5
							nCpoTp   := nCorrec
							cTpDoc   := "CM"
							cHistMov := STR0031 //"Correcao Monet s/Receb.Titulo"
							nCpoCalc := nCorrCalc
						Elseif nZ == 6 				// VALORES ACESSÓRIOS
							nCpoTp	 := nVA
							cTpDoc	 := "VA"
							cHistMov := ""			//Valores Acessórios (histórico virá da FKD)
							nCpoCalc := nVACalc
						Endif

						If nCpoTp != 0 .or. nZ == 1

							If lF091Natur
								cNatur090 := ExecBlock("F091Natur",.F.,.F.)
							EndIf

							aArea := SED->(GetArea())
							If !Empty(cNatur090)
								dbselectArea("SED")
								dbsetorder(1)
								If !DbSeek(xFilial("SED")+cNatur090)
									cNatur090 := FINNATMOV("P")
								Endif
							Else
								cNatur090 := FINNATMOV("P")
							EndIf
							RestArea(aArea)

							If !Empty(SE2->E2_NUMBOR)
								lPCC241 := RetPCC241( cSequencia, SE2->E2_NUMBOR)
							Endif

							cPrefixo := SE2->E2_PREFIXO

							If cPaisloc != "BRA" .AND. __lFINA095
								cNumChq	 :=	SE2->E2_NUMBCO
								cPrefixo :=	SE2->E2_PREFIXO
							Endif

							cRecPag := Iif( lBaixaPA , "R" , "P" )

							//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
							If !Empty(cCamposE5)
								cCamposE5 += "|"
							Endif
							cCamposE5 += "{"
							cCamposE5 += " {'E5_DTDIGIT' , dDtDigit  }"
							cCamposE5 += ",{'E5_PREFIXO' , '"+cPrefixo +"'}"
							cCamposE5 += ",{'E5_NUMERO'  , '"+SE2->E2_NUM+"'}"
							cCamposE5 += ",{'E5_PARCELA' , '"+SE2->E2_PARCELA+"'}"
							cCamposE5 += ",{'E5_TIPO'    , '"+SE2->E2_TIPO+"'}"
							cCamposE5 += ",{'E5_FORNECE' , '"+SE2->E2_FORNECE+"'}"
							cCamposE5 += ",{'E5_CLIFOR'  , '"+SE2->E2_FORNECE+"'}"
							cCamposE5 += ",{'E5_LOJA'    , '"+SE2->E2_LOJA+"'}"
							cCamposE5 += ",{'E5_BENEF'   , '"+RemoveAsp(SE2->E2_NOMFOR)+"' }"
							cCamposE5 += ",{'E5_TPDESC'  , '"+ cTpDescSE5 +"' }"
							cCamposE5 += ",{'E5_RECPAG'  , '"+ cRecPag +"' }"
							cCamposE5 += ",{'E5_DOCUMEN' , '"+ SE2->E2_NUMBOR +"' }"

							If (__lIssMR .Or. lCalcIssBx)
								cCamposE5 += ",{'E5_VRETISS' , " + cValToChar(If(__lIssMR, __nIssMR, nIss)) + " }"
							Endif

							If cPaisLoc = "MEX"
								cCamposE5 += ",{'E5_BANCO' , '"+SE2->E2_BCOCHQ +"'}"
								cCamposE5 += ",{'E5_AGENCIA' , '"+SE2->E2_AGECHQ +"'}"
								cCamposE5 += ",{'E5_CONTA' , '"+SE2->E2_CTACHQ +"'}"
							EndIF

							//Movimento principal (baixa e banco)
							If nZ == 1
								//Valores acessorios no registro principal da baixa
								cCamposE5 += ",{'E5_VLJUROS' , "+cValToChar(nJuros)+" }"
								cCamposE5 += ",{'E5_VLMULTA' , "+cValToChar(nMulta)+" }"
								cCamposE5 += ",{'E5_VLCORRE' , "+cValToChar(nCorrec)+" }"
								cCamposE5 += ",{'E5_VLDESCO' , "+cValToChar(nDescont)+" }"
								cCamposE5 += ",{'E5_VLACRES' , "+cValToChar(nAcresc)+" }"
								cCamposE5 += ",{'E5_VLDECRE' , "+cValToChar(nDecresc)+" }"
								nValorSE5	:= nCpoTp
								dDataSE5	:= dBaixa

								If !(cPaisLoc $ "BRA|ARG") .Or. (cPaisLoc == "ARG" .And. (__lFINA095 .Or. SE5->E5_TIPODOC == "VL"))

									SA6->(DbSetOrder(1))

									If Empty( __cFilSA6 )
										cMFilial := xFilial("SA6")
									Else
										If Empty( __cFilSE2 )
											cMFilial := xFilial("SA6")
										Else
											cMFilial := SE2->E2_FILIAL
										EndIf
									EndIf

									SA6->(dbSetOrder(1))
									If !Empty(SE2->E2_BCOCHQ) .And. !Empty(SE2->E2_AGECHQ) .And. !Empty(SE2->E2_CTACHQ)
										SA6->(DbSeek(cMFilial+SE2->E2_BCOCHQ+SE2->E2_AGECHQ+SE2->E2_CTACHQ))
										nMoedaBco   := Max(IIf(SA6->A6_MOEDAP > 0,SA6->A6_MOEDAP,SA6->A6_MOEDA),1)
										nValorSE5	:= If(nMoedaBco	<>	SE2->E2_MOEDA,xMoeda(E5_VALOR,1,nMoedaBco),nSaldo )
										cBanco 		:= SE2->E2_BCOCHQ
										cAgencia	:= SE2->E2_AGECHQ
										cConta		:= SE2->E2_CTACHQ
									Else
										SA6->(DbSeek(cMFilial+cBco090+cAge090+cCta090))
										nMoedaBco   := Max(IIf(SA6->A6_MOEDAP > 0,SA6->A6_MOEDAP,SA6->A6_MOEDA),1)
										nValorSE5	:= If(nMoedaBco <>	SE2->E2_MOEDA,xMoeda(E5_VALOR,1,nMoedaBco),nSaldo )
										cBanco 		:= cBco090
										cAgencia	:= cAge090
										cConta		:= cCta090
									Endif
								Endif

								If lGerTotal
									cBanco   := cBco090
									cAgencia := cAge090
									cConta	 := cCta090
								Endif

								If (nTipoBx == 2) .AND. (MV_PAR09 == 1) .AND. !Empty(SEA->(EA_PORTADO+EA_AGEDEP+EA_NUMCON)) .AND.;
										((lGerTotal .AND. nQtdBD == 1) .OR. !lGerTotal)
									cBanco   := cBco090 := SEA->EA_PORTADO
									cAgencia := cAge090 := SEA->EA_AGEDEP
									cConta	 := cCta090 := SEA->EA_NUMCON
								EndIf

								If lFa090Se5
									cE5_HISTOR := Execblock("FA090SE5",.F.,.F., {cE5_Histor})
									If ValType(cE5_HISTOR) == "C"
										cHistor090 := Left(cE5_HISTOR,__nTamHist)
									EndIf
								Endif

								If cPaisLoc == "BRA"
									If !lCheque .and. lMovBcoBx .and. SE2->E2_IMPCHEQ != "S" .and. !lGerTotal
										cBanco   := cBco090
										cAgencia := cAge090
										cConta   := cCta090
									ElseIf SE2->E2_IMPCHEQ == "S"
										cBanco		:= cBcoTit
										cAgencia	:= cAgeTit
										cConta		:= cCtaTit
										cCheque		:= cChqTit
									ElseIf lCheque
										cBanco		:= cBco090
										cAgencia	:= cAge090
										cConta		:= cCta090
										If !(lIsTitPA .and. lGerPaMov) .and. !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
											cCheque := cCheq090
										Endif
									Endif
								Endif

								If cPaisLoc != "BRA"
									cCamposE5 += ",{'E5_FILORIG', '" + SE2->E2_FILORIG  + "'}"
								EndIf

								cCamposE5 += ",{'E5_BANCO'   , '" + cBanco + "'}"
								cCamposE5 += ",{'E5_AGENCIA' , '" + cAgencia + "'}"
								cCamposE5 += ",{'E5_CONTA'   , '" + cConta + "'}"
								cCamposE5 += ",{'E5_DTDISPO' , STOD('" + DTOS(dDebito) + "')}"

								If lPaisMI // cPaisLoc == "CHI"
									cCamposE5 += ",{'E5_ORDREC'   , '" + SE2->E2_ORDPAGO + "'}"
								Endif

								//Relacionamento FKA X FK2
								If !oSubFKA:IsEmpty()
									//Inclui a quantidade de linhas necessárias
									oSubFKA:AddLine()
									//Vai para linha criada
									oSubFKA:GoLine( oSubFKA:Length() )
								Endif

								If !lGerPaMov
									oSubFKA:SetValue( 'FKA_IDORIG', cIdFK2 )
									oSubFKA:SetValue( 'FKA_TABORI', "FK2" )
									//Dados da baixa a pagar
									oSubFK2:SetValue( "FK2_DATA"   , dDataSE5 )
									oSubFK2:LoadValue( "FK2_NATURE" , SE2->E2_NATUREZ )
									oSubFK2:SetValue( "FK2_RECPAG" , cRecPag )
									oSubFK2:SetValue( "FK2_HISTOR" , If(!Empty(cHistor090) .and. !(lIsTitPA .and. lGerPAMov) ,cHistor090,cHistMov) )
									oSubFK2:SetValue( "FK2_MOTBX"  , If(Empty(cMotBx),"NOR", TrazCodMot( cMotBx )) )
									oSubFK2:SetValue( "FK2_ORIGEM" , FunName() )
									oSubFK2:SetValue( "FK2_SEQ"    , cSequencia )
									oSubFK2:SetValue( "FK2_IDDOC"  , cChaveFK7 )
									oSubFK2:SetValue( "FK2_LOTE"   , cLoteFin )
									oSubFK2:SetValue( "FK2_TPDOC"  , cTpDoc )
									oSubFK2:SetValue( "FK2_CCUSTO" , SE2->E2_CCUSTO )
									oSubFK2:SetValue( "FK2_DOC"    , SE2->E2_NUMBOR )	// Vem do Fina240()

									If lGerTotal
										oSubFK2:SetValue( "FK2_ARCNAB" , Iif(lMovBcoBx,"FINA090","") )
									Endif

									oSubFK2:SetValue( "FK2_FILORI" ,SE2->E2_FILORIG )
									oSubFK2:SetValue( "FK2_AUTBCO" ,"" )
									oSubFK2:SetValue( "FK2_MOEDA"  ,StrZero(nMoedaBco, 2))
									oSubFK2:SetValue( "FK2_VLMOE2" ,Round(xMoeda(nCpoTp, nMoedaBco,SE2->E2_MOEDA,SE2->E2_BAIXA,4,,nTxMoedBx),2))
									oSubFK2:SetValue( "FK2_VALOR"  ,nValorSE5 )
									oSubFK2:SetValue( "FK2_TXMOED" ,nTxMoedBx )
									oSubFK2:SetValue( "FK2_LOTE"   , cLoteFin )
									oSubFK2:SetValue( "FK2_LA"     , If( lPadrao .and. mv_par03 == 1 .and. !lUsaFlag, "S", "N" ) )

									//Gravo Marca da MultNat
									If SE2->E2_MULTNAT == "1" .and. lMultNat
										oSubFK2:SetValue( "FK2_MULNAT" , "1" )
									Else
										oSubFK2:SetValue( "FK2_MULNAT" , "2" )
									EndIf

									If __lTemMR
										nImpos := Len(__aImpMR)
										For nX := 1 To nImpos
											If lFKCodRet .and. Len(__aImpMR[nX])>=23
												cCodRet :=  __aImpMR[nX,23]
											Else
												cCodRet := ""
											EndIf
											aAdd(aImpostos,{__aImpMR[nX,8], __aImpMR[nX,3], __aImpMR[nX,10], "", __aImpMR[nX,5], __aImpMR[nX,2], __aImpMR[nX,4], __aImpMR[nX,1],SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, cCodRet})
										Next nX
									EndIf

									If !__lIrfMR .And. lIRPFBaixa .And. nIrfBaseC > 0
										If lFKCodRet
											cCodRet := SE2->E2_CODRET
										Else
											cCodRet := ""
										Endif
										//Rateio IRPF progressivo
										If __oRatIRF == Nil .OR. Empty(__oRatIRF:aRatIRF)
											aAdd(aImpostos,{"IRF", nIrfCalc, &(SuperGetMV("MV_IRF")), "", nIrrf, nIrfBaseC, nIrfBaseR, "", SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, cCodRet})
										Else
											For nX := 1 To Len(__oRatIRF:aRatIRF)
												If __oRatIRF:aRatIRF[nX][6] != 0
													lSimpIRAlu := If(len(__oRatIRF:aRatIRF[nX])>10, __oRatIRF:aRatIRF[nX][11], .F.)	
													aAdd(aImpostos,{"IRF", __oRatIRF:aRatIRF[nX][6], &(SuperGetMV("MV_IRF")), "", __oRatIRF:aRatIRF[nX][6], __oRatIRF:aRatIRF[nX][5], __oRatIRF:aRatIRF[nX][5], "", SA2->A2_COD, SA2->A2_LOJA, __oRatIRF:aRatIRF[nX][3], cCodRet, lSimpIRAlu})
												EndIf
											Next nX
										EndIf
									EndIf

									If !__lPccMR .And. lContrRet .and. lPccBaixa .And. (nPisCalc+nCofCalc+nCslcalc) > 0
										aCodRet := getCodRet()
										If nPisCalc > 0 .And. nPisBaseC > 0
											aadd(aImpostos,{"PIS", nPisCalc ,cMV_PISNAT,"", nPis, nPisBaseC, nPisBaseR, '', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[1]})
										EndIf

										If nCofCalc > 0 .And. nCofBaseC > 0
											aadd(aImpostos,{"COF", nCofCalc ,cMV_COFINS,"", nCofins, nCofBaseC, nCofBaseR, '', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[2]})
										EndIf

										If nCslcalc > 0 .And. nCslBaseC > 0
											aadd(aImpostos,{"CSL", nCslcalc ,cMV_CSLL  ,"", nCsll, nCslBaseC, nCslBaseR, '', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[3]})
										EndIf
									EndIf
									cCodRet := ""
									If !__lIssMR .And. lCalcIssBx .And. nIssBaseC > 0 .And. nIssCalc > 0
										aadd(aImpostos,{"ISS",nIssCalc,cMV_ISS,"", nIss, nIssBaseC, nIssBaseR,'', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, cCodRet})
									EndIf

									//Grava FK3 E/OU FK4
									For nX := 1 to Len(aImpostos)
										//Gravar FK4 se os valores de PCC forem maiores que zero
										If aImpostos[nX][2] > 0 .OR. (lIRPFBaixa .AND. aImpostos[nX,1] == "IRF")
											cIdFK4 := ""

											If aImpostos[nX][5] > 0   //Houve retencao
												cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
												aImpostos[nX,4] := cIdFK4

												If __lTemMR .And. nX <= nImpos
													__aImpMR[nX,6] := cIdFK4
												EndIF

												//Guardo o IDFK4 do IRF para usar posteriormente
												If aImpostos[nX,1] == "IRF"
													cIdFk4IR := cIdFK4
												Endif
											Endif

											If !oSubFK3:IsEmpty()
												oSubFK3:AddLine()
												oSubFK3:GoLine( oSubFK3:Length() )
											Endif

											// Grava Imposto calculado
											oSubFK3:SetValue( "FK3_IDFK3" , GetSx8Num('FK3', 'FK3_IDFK3'))
											oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
											oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
											oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nX,1] )
											oSubFK3:SetValue( "FK3_RECPAG", cRecPag )
											oSubFK3:SetValue( "FK3_MOEDA" , "01" )
											oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nX,2] )
											oSubFK3:LoadValue( "FK3_NATURE", aImpostos[nX,3] )
											oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG  )
											oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nX,6] )
											oSubFK3:SetValue( "FK3_IDORIG", cIdFK2 )
											oSubFK3:SetValue( "FK3_TABORI", "FK2")
											oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nx,4] )

											If lFKCodRet
												oSubFK3:SetValue( "FK3_CODRET" , aImpostos[nX,12] )
											EndIf

											If __lTemMR
												oSubFK3:SetValue( "FK3_CODFKM", aImpostos[nX,8] )
												oSubFK3:SetValue( "FK3_CLIFOR", aImpostos[nX,9] )
												oSubFK3:SetValue( "FK3_LOJA"  , aImpostos[nX,10] )
												oSubFK3:SetValue( "FK3_CGC"   , aImpostos[nX,11] )
												oSubFK3:SetValue( "FK3_RAICGC", Substr(aImpostos[nX,11], 1, 8) )

												If SE2->E2_MOEDA > 1
													oSubFK3:SetValue("FK3_VLMOE2", Round(xMoeda(aImpostos[nX][2],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1,If(cPaisLoc == "BRA", SE2->E2_TXMOEDA, 0)),2))
												Else
													oSubFK3:SetValue("FK3_VLMOE2", aImpostos[nX][2])
												EndIf
											Endif

											// Grava Imposto Retido
											If aImpostos[nX][5] > 0   //Houve retencao
												If !oSubFK4:IsEmpty()
													oSubFK4:AddLine()
													oSubFK4:GoLine( oSubFK4:Length() )
												Endif

												oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nx,4])
												oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
												oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
												oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nx,1] )
												oSubFK4:SetValue( "FK4_RECPAG", cRecPag )
												oSubFK4:SetValue( "FK4_MOEDA" , "01" )
												oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nX,5] )
												oSubFK4:LoadValue( "FK4_NATURE", aImpostos[nX,3])
												oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
												oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX,7] )
												If lFK4CLIFOR
													oSubFK4:SetValue( "FK4_CLIFOR", aImpostos[nX,9] )
													oSubFK4:SetValue( "FK4_LOJA"  , aImpostos[nX,10] )
												EndIf
												If lFKCodRet
													oSubFK4:SetValue( "FK4_CODRET" , aImpostos[nx,12] )
												EndIf
												If Len(aImpostos[nX])> 12 .And. aImpostos[nX][13]
													If __lDicSimpl
														oSubFK4:SetValue("FK4_DEDIRS", __nDedSimpl )
													EndIf
												Endif
												If __lTemMR
													oSubFK4:SetValue( "FK4_CODFKM", aImpostos[nX,8] )
													oSubFK4:SetValue( "FK4_CGC"   , aImpostos[nX,11] )
													oSubFK4:SetValue( "FK4_RAICGC", Substr(aImpostos[nX,11], 1, 8) )
													If SE2->E2_MOEDA > 1
														oSubFK4:SetValue("FK4_VLMOE2", Round(xMoeda(aImpostos[nX,5],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1,If(cPaisLoc == "BRA", SE2->E2_TXMOEDA, 0)),2))
													Else
														oSubFK4:SetValue("FK4_VLMOE2", aImpostos[nX,5])
													EndIf

													If nX <= nImpos .And. Len(__aImpMR[nX,7]) > 0 .And. __aImpMR[nX,7,1] > 0
														FK3->(DbGoTo(__aImpMR[nX,7,1]))
														RecLock("FK3")
														FK3->FK3_IDRET := __aImpMR[nX,6]
														FK3->(MsUnlock())
													EndIf
												Endif
											Endif
										Endif
									Next

									For nx:= 1 to len(aTitCalc)
										FINGFK3BOR(2,aTitCalc[nx,1],aTitCalc[nx,2],aImpostos,.F.)
									Next

									If lRetBor .And. !__lIrfMR .AND. lIRPFBaixa
										FGRVSFQIR(nIrrf,nBaseIrpf,aDadosIr,cSequencia,@cCamposIR,cIdFk4IR)
										cCamposE5 += cCamposIr
									Endif
									
									If ((!__lPccMR .And. lContrRet .And. lPccBaixa) .Or. __lPccBxMR)
										If (dBaixa < __dLastPCC  .Or. lEmpPub)
											FGRVSFQPCC(aImpostos,aDadosRet,cSequencia,@cCamposPCC, @lRetParc, lIRPFBaixa, lAplVlMin, nVlMinImp, lPCC241)
											cCamposE5 += cCamposPCC
										Else
											cCamposE5 += ",{'E5_VRETPIS' , " + cValToChar(If(__lPccMR, __nPisMR, nPis)) + " }"
											cCamposE5 += ",{'E5_VRETCOF' , " + cValToChar(If(__lPccMR, __nCofMR, nCofins)) + " }"
											cCamposE5 += ",{'E5_VRETCSL' , " + cValToChar(If(__lPccMR, __nCslMR, nCsll)) + " }"
										Endif
									EndIf

									//Gravo os titulos de impostos Pis Cofins Csll quando controlados pela baixa - EXCETO PA
									If !lIsTitPA .AND. ((lContrRet .and. lPccBaixa .and. lRetParc) .or. (lCalcIssBx .and. nIss > 0) .OR. (lIRPFBaixa .AND. nIrrf > 0))
										If !(lRet := FGrvImpPcc(@nPis,@nCofins,@nCsll,nRegAtu,.F.,lRetParc,cSequencia,"FINA090",SE2->E2_MOEDA,,nIrrf,nIss,,,,,,,,,,IIF(__oRatIRF <> Nil,__oRatIRF:aRatIRF,Nil)))
											lContinua := .F.
											DisarmTransaction()
											Break
										EndIf
									Endif
								Endif

								If cTpDoc $ "VL|PA"	//Se movimenta banco
									//Relacionamento FKA X FK5
									If !oSubFKA:IsEmpty()
										oSubFKA:AddLine()
										oSubFKA:GoLine( oSubFKA:Length() )
									Endif

									oSubFKA:SetValue( 'FKA_IDORIG', FWUUIDV4() )
									oSubFKA:SetValue( 'FKA_TABORI', "FK5" )

									//MOVIMENTO BANCARIO
									oSubFK5:SetValue( "FK5_RECPAG" , cRecPag )
									oSubFK5:SetValue( "FK5_HISTOR" , If(!Empty(cHistor090) .and. !(lIsTitPA.and. lGerPAMov) ,cHistor090,cHistMov) )
									oSubFK5:SetValue( "FK5_DATA"   , dDataSE5 )
									oSubFK5:SetValue( "FK5_DTDISP" , dDataSE5 )
									oSubFK5:LoadValue( "FK5_NATURE" , SE2->E2_NATUREZ )
									oSubFK5:SetValue( "FK5_BANCO"  , cBanco )
									oSubFK5:SetValue( "FK5_AGENCI" , cAgencia )
									oSubFK5:SetValue( "FK5_CONTA"  , cConta )
									oSubFK5:SetValue( "FK5_NUMCH"  , If(!lIsTitPA,cCheque,"") )
									oSubFK5:SetValue( "FK5_SEQ"    , cSequencia )
									oSubFK5:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
									oSubFK5:SetValue( "FK5_VALOR"  , nValorSE5 )
									oSubFK5:SetValue( "FK5_VLMOE2" , Round(xMoeda(nValorSE5,nMoedaBco,SE2->E2_MOEDA,SE2->E2_BAIXA,4,,nTxMoedBx),2))
									oSubFK5:SetValue( "FK5_ORIGEM" , FunName() )
									oSubFK5:SetValue( "FK5_TPDOC"  , cTpDoc )
									oSubFK5:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
									oSubFK5:SetValue( "FK5_FILORI" , SE2->E2_FILORIG )
									oSubFK5:SetValue( "FK5_TXMOED" , If(SE2->E2_MOEDA > 1,nTxMoedBx, 0)  )
									oSubFK5:SetValue( "FK5_LA"     , If( lPadrao .and. mv_par03 == 1 .and. !lUsaFlag, "S", "N" ) )
									oSubFK5:SetValue( "FK5_LOTE"   , cLoteFin )
									oSubFK5:SetValue( "FK5_IDDOC"  , If(lIsTitPA,cChaveFK7,"") )
									oSubFK5:SetValue( "FK5_MODSPB" , If(lSpbInUse, cModSpb, "" ) )
									oSubFK5:SetValue( "FK5_DOC"    , SE2->E2_NUMBOR )	// Vem do Fina240()

									If lGerPaMov
										cCamposE5 += ",{'E5_MOTBX'  , '"+ If(Empty(cMotBx),"NOR", TrazCodMot( cMotBx )) +"'}"
									EndIf

								Else
									cCamposE5 += ",{'E5_BANCO'   , '"+cBanco   +"' }"
									cCamposE5 += ",{'E5_AGENCIA' , '"+cAgencia +"' }"
									cCamposE5 += ",{'E5_CONTA'   , '"+cConta   +"' }"
									cCamposE5 += ",{'E5_NUMCHEQ' , '"+cCheque  +"' }"
									cCamposE5 += ",{'E5_DTDISPO' , STOD('" + DTOS(dDebito) + "')}"
								Endif

							Else	// Valores acessorios

								If	oSubFKA:SeekLine({{'FKA_TABORI',"FK2"}})
									If cTpDoc == "VA" .and. nVA != 0
										FSetFK6FKD(oSubFK6,cChaveFK7,cIdFK2)
									Else

										If !oSubFK6:IsEmpty()
											oSubFK6:AddLine()
											oSubFK6:GoLine( oSubFK6:Length() )
										Endif

										//Grava Valores acessórios (juros, multas, descontos etc)
										oSubFK6:SetValue( "FK6_VALMOV" , nCpoTp )
										oSubFK6:SetValue( "FK6_VALCAL" , nCpoCalc )
										oSubFK6:SetValue( "FK6_TPDESC" , cTpDesc )
										oSubFK6:SetValue( "FK6_TPDOC"  , cTpDoc )
										oSubFK6:SetValue( "FK6_RECPAG" , cRecPag )
										oSubFK6:SetValue( "FK6_IDORIG" , cIdFK2 )
										oSubFK6:SetValue( "FK6_TABORI" , "FK2" )
										oSubFK6:SetValue( "FK6_HISTOR" , cHistMov )
									Endif
								Endif
							Endif

							If __lFINA095
								nOrderSEF:=SEF->(IndexOrd())
								SEF->(DbSetOrder(6))
								If SEF->(DbSeek(xFilial("SEF")+"P"+SE2->E2_BCOCHQ+SE2->E2_AGECHQ+SE2->E2_CTACHQ+SUBSTR(IIf(Alltrim(SE2->E2_ORIGEM) == "FINA550", SE2->E2_NUM,SE2->E2_NUMBCO),1,TamSX3("EF_NUM")[1])+SE2->E2_PREFIXO))
									RecLock("SEF",.F.)
									SEF->EF_DATAPAG	:= dDataBase
									SEF->EF_REFTIP	:= "LP"
									SEF->EF_STATUS	:= "04"
									SEF->EF_BENEF	:=	SE2->E2_NOMFOR
									If !(cPaisLoc=="ARG")
										SEF->EF_HIST	:=	cHistor090
									Endif
									SEF->(MsUnLock())
									DbSelectArea("FRF")
									cSeqFRF := GetSx8Num("FRF","FRF_SEQ")
									RecLock("FRF",.T.)
									FRF->FRF_FILIAL	 := xFilial("FRF")
									FRF->FRF_BANCO	 := SEF->EF_BANCO
									FRF->FRF_AGENCIA := SEF->EF_AGENCIA
									FRF->FRF_CONTA	 := SEF->EF_CONTA
									FRF->FRF_NUM	 := SEF->EF_NUM
									FRF->FRF_PREFIX	 := SEF->EF_PREFIXO
									FRF->FRF_CART	 := "P"
									FRF->FRF_DATPAG	 :=	dDataBase
									FRF->FRF_MOTIVO	 := "10"
									FRF->FRF_DESCRI	 := "CHEQUE LIQUIDADO"
									FRF->FRF_SEQ	 := cSeqFRF
									FRF->FRF_FORNEC	 := SEF->EF_FORNECE
									FRF->FRF_LOJA	 := SEF->EF_LOJA
									FRF->FRF_NUMDOC	 := SEF->EF_ORDPAGO
									FRF->(MsUnLock())
									ConfirmSX8()
									SEF->(DbSetOrder(nOrderSEF))
								Endif
							Endif

							If !Empty(cCamposE5)
								cCamposE5 += "}"
							Endif

						Endif
					Next nZ
					//Encerro a gravacao da Baixa (oModelBxP)
					If lRet
						FWModelActive(oModelBxP)
						oModelBxP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

						//Grava os dados
						If oModelBxP:VldData()
							oModelBxP:CommitData()

							//Obtenho o recno do SE5 - Movimento principal (VL/BA)
							nRegPrinc := oModelBxP:GetValue("MASTER","E5_RECNO")
							SE5->(dbGoTo(nRegPrinc))
							AADD(aSE5Baixado,nRegPrinc)
							AADD(aRec090Se5,nRegPrinc)

							If lNewProc
								cE5TABORI := SE5->E5_TABORI
								cE5IDORIG := SE5->E5_IDORIG
							EndIf

							If !lBaixaPA .And. lGerPAMov
								AADD(aSE2Pagant,nRegAtu)
							Endif

							//Grava o lançamento de integração com o SIGAPCO
							If __lUsaPCO
								PcoDetLan("000006","01","FINA090")
							Endif

							If lF90Se5Grv
								ExecBlock("F90SE5GRV")
							Endif

							//Atualiza o saldo bancario quando movimento bancario gerado baixa a baixa
							If lAtuSldBco
								If SE5->E5_TIPODOC $ "VL|PA"
									AtuSalBco(cBanco,cAgencia,cConta,dDataSE5,nValorSE5,If(SE5->E5_RECPAG == 'P','-','+'))
								Endif
							EndIf

							//-----------------------------------------------------------
							// Valores Acessorios.
							//-----------------------------------------------------------
							If __lFKDBx
								FAtuFKDBx( .F., "P" )
							EndIf
						Else
							lRet := .F.
							cLog := cValToChar(oModelBxP:GetErrorMessage()[4]) + ' - '
							cLog += cValToChar(oModelBxP:GetErrorMessage()[5]) + ' - '
							cLog += cValToChar(oModelBxP:GetErrorMessage()[6])
							Help( ,,"M020VLDI5",,cLog, 1, 0 )
							DisarmTransaction()
							Break
						Endif
					Else
						DisarmTransaction()
						Break
					Endif

					oModelBxP:DeActivate()
					oModelBxP:Destroy()
					oModelBxP := Nil
					FinSetAPrc("")

					//Gravação FK3/FK4 dos impostos via conf Motor Retenção
					If __lTemMR .And. lRet .And. !lGerPAMov
						If lIsTitPA
							FMRDelImp(cE5TABORI, cE5IDORIG)
							cE5TABORI := ""
							cE5IDORIG := ""
						ElseIf Len(__aImpMR) > 0
							FinGrvImp("1", SE2->(Recno()),__aImpMR,"FINA090",.F., {}, {},.F.,.F.,.T./*eh Baixa*/,dBaixa,"FK2",cSequencia,,SE2->E2_FILORIG)
						EndIf
					EndIf

					If (__lPccMR .Or. __lIrfMR .Or. __lIssMR)
						nImposMR := Len(__aImpMR)

						For nX := 1 To nImposMR	
							If __nPisMR > 0 .And. __aImpMR[nX,8] == "PIS"
								SE2->E2_VRETPIS += __nPisMR
								SE2->E2_PRETPIS := "3"
							EndIf 

							If __nCofMR > 0 .And. __aImpMR[nX,8] == "COF"
								SE2->E2_VRETCOF += __nCofMR
								SE2->E2_PRETCOF := "3"  
							EndIf

							If __nCslMR > 0 .And. __aImpMR[nX,8] == "CSL"
								SE2->E2_VRETCSL += __nCslMR
								SE2->E2_PRETCSL := "3"  
							EndIf

							If __nIrfMR > 0 .And. __aImpMR[nX,8] == "IRF"
								SE2->E2_VRETIRF += __nIrfMR 
								SE2->E2_PRETIRF := "3" 
							EndIf

							If __nIssMR > 0 .And. __aImpMR[nX,8] == "ISS"
								SE2->E2_VRETISS += __nIssMR 
							EndIf
						Next nX
					EndIf

					//Integração SIGAPFS x SIGAFIN
					If lRet .And. lJGrvBxPag

						lRet := JGrvBxPag(SE2->(RECNO()), 3, SE5->(RECNO()))

						If !lRet .And. InTransact()
							DisarmTransaction()
							Break
						EndIf
					EndIf

					//Caso a retenção ocorreu na inclusão do pagamento antecipado efetua a exclusão dos títulos de impostos
					If !__lIrfMR .And. lIsTitPA .And. !lGerPAMov .and. SE2->E2_IRRF > 0
						F241DelTxIR("FINA080",SE2->(Recno()),SE2->E2_IRRF)
					EndIf

					If (lContrRet .and. lIsTitPA .And. (SE2->(E2_PIS + E2_COFINS + E2_CSLL) > 0 .Or. SE2->E2_ISS > 0))
						lPAMov := .F.

						//verifica se PA possui movimentacao bancaria
						nRecPAInc := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

						If  nRecPAInc > 0
							SE5->(DBGoto(nRecPAInc))
							lPAMov := .T.
						EndIf

						//verifica se PA possui registro de inclusao
						nRecPAInc := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

						If	nRecPAInc > 0
							SE5->(DBGoto(nRecPAInc))
							lPAMov := .T.
						EndIf

						If 	lPAMov .And. !lGerPAMov
							aRecSE5 := FImpDelTit("SE5",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
							nRecSe5 := SE5->(Recno())

							For nY := 1 to Len(aRecSE5)
								SE5->(MSGoto(aRecSE5[nY]))
								RecLock("SE5",.F.)

								//Se nao reteve somente IRRF
								If 	(!Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)) .and. SE5->E5_MOTBX <> "CMP"
									SE5->E5_PRETPIS := "1"
									SE5->E5_PRETCOF := "1"
									SE5->E5_PRETCSL := "1"
								Endif

								MsUnlock()
							Next

							//Exclui os registros de relacionamentos do SFQ
							SE5->(dbGoto(nRecSe5))
							FImpDelSFQ("SE5",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
							aRecSE2 := FImpExcTit("SE2",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)

							For nY := 1 to Len(aRecSE2)
								SE2->(MSGoto(aRecSE2[nY]))
								FaAvalSE2(4)
							Next

							//Exclui os registros de relacionamentos do SFQ
							SE5->(dbGoto(nRecSe5))
							FImpExcSFQ("SE2",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)

							FDelTxBx(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ,SE2->E2_PARCPIS,SE2->E2_PARCCOF,SE2->E2_PARCSLL)

							IF IsIssBx("P") .And. EMPTY(SE2->E2_NUMBOR) .And. SE2->E2_VRETISS != 0
								//Apaga tambem os registro de impostos-ISS
								SE5->(dbGoto(nRecSe5))
								SE2->(dbGoTo(nRecSE2))

								If __oBillRel <> Nil
									jTitFilho  := __oBillRel:getRelatedBills('SE2', .F.)
									nLiObFilho := 1
									bWhile     := {|| nLiObFilho <= Len(jTitFilho['document'])}

									DBSelectArea("SE2")
									DBSetOrder(1) // Indice 1 - E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
								Else
									dbSelectArea("SE2")
									dbSetOrder(17)

									cChavePai := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
									cChavePai := PadR(cChavePai, nTamTitPai)

									If MsSeek(xFilial("SE2") + cChavePai)
										bWhile := {|| !Eof() .And. E2_FILIAL+E2_TITPAI == xFilial("SE2") + cChavePai }
									EndIf
								EndIf

								cNatIss	:= AllTrim(F090GetNat("MV_ISS"))

								While Eval(bWhile)
									If __oBillRel <> Nil
										SE2->(DBSeek(FWxFilial("SE2") + jTitFilho['document'][nLiObFilho]['FK7_PREFIX'] +;
																		jTitFilho['document'][nLiObFilho]['FK7_NUM'] +;
																		jTitFilho['document'][nLiObFilho]['FK7_PARCEL'] +;
																		jTitFilho['document'][nLiObFilho]['FK7_TIPO'] +;
																		jTitFilho['document'][nLiObFilho]['FK7_CLIFOR'] +;
																		jTitFilho['document'][nLiObFilho]['FK7_LOJA']))
									EndIf
									IF E2_TIPO $ MVISS .And. ;
											AllTrim(E2_NATUREZ) == cNatIss .And. ;
											STR(SE2->E2_SALDO,17,2) == STR(SE2->E2_VALOR,17,2) .and. ;
											(AllTrim(SE2->E2_ORIGEM) $ "FINA050|FINA080|FINA090|FINA091") .and. ;
											SE5->E5_SEQ == SE2->E2_SEQBX
										If lExistFJU
											FinGrvEx("P")
										Endif
										If __oBillRel <> Nil
											cChaveTit := SE2->E2_FILIAL + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" +;
															SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
											FINDELFKs(cChaveTit, "SE2")
										EndIf

										RecLock( "SE2" ,.F.,.T.)
										dbDelete( )
									EndIf

									nLiObFilho++

									dbSkip()
								Enddo
							EndIf

							SE5->(dbGoto(nRecSe5))

						EndIf
					Endif

					//Atualiza o Cadastro de Fornecedores
					dbSelectArea("SA2")
					If Empty( __cFilSA2 )    //Multi-Filial
						cMFilial := xFilial("SA2")
					Else
						If Empty( __cFilSE2 )
							cMFilial := xFilial("SA2")
						Else
							cMFilial := SE2->E2_FILIAL
						EndIf
					EndIf

					If !dbSeek(cMFilial+SE2->E2_FORNECE+SE2->E2_LOJA) .And. !Empty(xFilial("SA2"))
						//executará quando o forn estiver em filial diferente
						lAchouFor := dbSeek(xFilial("SA2", SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA)
					else
						lAchouFor := .T.
					EndIf

					If lAtuForn .and. lAchouFor
						RecLock("SA2")
						nSalDup := xMoeda(nSaldo-nTotAbtF,SE2->E2_MOEDA,nMoedaBco,SE2->E2_EMISSAO,,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))
						SA2->A2_SALDUP	-=	nSalDup
						SA2->A2_SALDUPM	-= xMoeda(nSaldo-nTotAbtF,SE2->E2_MOEDA,;
							__nMVMCUST,SE2->E2_EMISSAO,,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))
						MsUnlock()
					Endif

					//Verifica qual o Lanc Padrao que sera utilizado
					dbSelectArea("SE2")

					VALOR2     := nTotAbat		// Valor para contabilizar
					ABATIMENTO := nTotAbat

					If cPaisLoc = "BRA" .And. lPccBaixa .And. lBord241
						Reclock("SE2")
						SE2->E2_VRETPIS := nOldRetPis
						SE2->E2_VRETCOF := nOldRetCof
						SE2->E2_VRETCSL := nOldRetCsl
						MsUnlock()
					EndIf

					SA6->(DbSetOrder(1))
					SA6->(DbSeek(xFilial()+cBco090+cAge090+cCta090))

					// Baixa por bordero e totalizacao bordero a bordero
					If lPadrao .and. mv_par03==1 .and. nTipoBX == 2 .and. mv_par05 == 2 .and. !lGerPAMov
						AAdd( aRegCtBor, { SE2->(Recno()), SA2->(Recno()), SA6->(Recno()) , F090RcSE5(aSE5Baixado) } )
					EndIf

					If cPAISLOC $ "PER|DOM|BOL"
						nBaseITF := SE5->E5_VALOR
					EndIf

					//Rateio de Multi Naturezas/Centro de Custos
					If lMultNat .And. SE2->E2_MULTNAT == "1"
						If cPaisLoc <> "BRA"
							If !(cPaisLoc $ "BOL" ) .And. FinProcITF( nRecnSE5,1 )
								FinProcITF( nRecnSE5,3,nBaseITF, .F.,{} ,  )
							EndIf

							If cPaisLoc $ "BOL" .And. FinProcITF(  SE5->( Recno()),1 )
								FinProcITF(  SE5->( Recno()),3,nBaseITF, .F.,{} ,  )
							EndIf
						EndIf
						MultNatB("SE2", .F., "1", @lOk, @aColsSEV, @lMultNat, .T.)

						If lOk
							MultNatC("SE2" /*cAlias*/, @nHdlPrv /*@nHdlPrv*/, @nTotal /*@nTotal*/, @cArquivo /*@cArquivo*/, (mv_par03 == 1) /*lCtbOnline*/, .T. /*lBxLote*/,;
								"1" /*cReplica*/, nTotLtEZ /*nTotLtEZ*/, lOk /*lOk*/, aColsSEV /*aCols*/, .T. /*lBaixou*/, aGrvLctPco /*aGrvLctPco*/, lUsaFlag /*lUsaFlag*/, @aFlagCTB /*@aFlagCTB*/)
						Endif
					Else
						If (cCtBaixa == "C" .And. lCheque .and. lMovBcoBx .And. MV_PAR04 == 1) .Or. ;
								(cCtBaixa $"B|A") .Or. (TrazCodMot(cMotBx) $ "VEN/DEB") .or. (MovBcoBx(cMotBx, .T.) .and. ;
								!ChqMotBx(cMotBx)) .or. lGerPAMov

							If nHdlPrv == 0 .And. lPadrao .And. MV_PAR03 == 1
								nHdlPrv := HeadProva( cLote, "FINA090" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
							EndIf

							If	lPadrao .And. mv_par03 == 1 .And. !(nTipoBx = 2 .And. mv_par05 == 2 .And. !lGerPAMov)
								dbSelectArea("SE5")
								SE5->(dbGoTo(nRegPrinc))

								If UsaSeqCor()
									AaDd(aDiario, {"SE5", SE5->(Recno()), cCodDiario, "E5_NODIA", "E5_DIACTB"})
								EndIf

								If cPaisLoc <> "BRA"
									If  !(cPaisLoc $ "BOL") .And. FinProcITF( nRecnSE5,1 )
										FinProcITF( nRecnSE5,3,nBaseITF, .F.,{nHdlPrv,cPadrao,"FINA090","FINA090",cLote} ,  )
									ElseIf  cPaisLoc $ "BOL" .And. FinProcITF( SE5->( Recno()),1 )
										FinProcITF( SE5->( Recno()),3,nBaseITF, .F.,{nHdlPrv,cPadrao,"FINA090","FINA090",cLote} ,  )
									EndIf
								EndIf

								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
									If lGerPaMov
										aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
									EndIf
								Endif

								nTotal += F090DetPro(nHdlPrv,cPadrao,"FINA090",cLote,,,,@aFlagCTB,cFilCorr,cFilOriCtb)

							EndIf
						Else
							If cPaisLoc <> "BRA"
								If FinProcITF( SE5->( Recno() ),1 )
									FinProcITF( SE5->( Recno() ),3,nBaseITF, .F.,{} ,  )
								EndIf
							EndIf
						EndIf
					EndIf

					dbSelectArea("SE2")

					If lFina090
						Execblock("FINA090",.f.,.f.)
					Endif

					If FWHasEAI("FINA080",.T.,,.T.)
						FwIntegDef( 'FINA080' )
					Endif

					// Integração EAI.
					If lEAIF080
						llOpc  := ALTERA
						ALTERA := .T.  // Baixa de título.

						aEaiRet := FWIntegDef('FINA080',,,, 'FINA080')
						If !aEaiRet[1]
							Help(" ", 1, "HELP", STR0174, STR0175 + CRLF + aEaiRet[2], 3, 1)  // "Erro EAI" / "Problemas na integração EAI. Transação não executada."
							DisarmTransaction()
							Break
						Endif

						ALTERA := llOpc
					Endif

					IF __lFinVDoc
						CN062ValDocs("03",.F.,.T.)
					EndIf
				EndIf

				dbSelectArea("SE2")

				If lBaixaMnt
					// Função que atualiza a TRX  - Multa (Integração SIGAFIN - SIGAMNT).
					NGBAIXASE2( 1 )
				EndIf

			Endif

			(cAliasSE2)->(dbSkip())
			SE2->(dbGoto((cAliasSE2)->NUM_REG))

			//	Define data da contabilização on line
			Do Case
			Case nDtContOn == 1 // 1- Data Digitação
				dDtLanc := dDtDigit
			Case nDtContOn == 2 // 2- Data Disponibilizadade
				dDtLanc := dDebito
			Case nDtContOn == 3 // 3- Data Pagamento
				dDtLanc := dBaixa
			EndCase

			If nHdlPrv > 0 .And. nTotal > 0 .And. mv_par03 == 1;
					.and. ((mv_par08 == 2 .And. cFilAnt <> SE2->E2_FILORIG) .OR. cBordAnt <> SE2->E2_NUMBOR)

				//Efetiva Lancamento Contabil
				F090Contab(cArquivo, @nHdlPrv, cLote, lDigita, lAglut, dDtLanc, @aFlagCTB, aDiario, cFilCorr, cFilOriCtb)

				aFlagCTB 	:= {}  // Limpa o coteudo apos a efetivacao do lancamento
				nHdlPrv 	:= 0
				nTotal		:= 0
				aDiario		:= {}
				lStartCTB 	:= .T.

				//Flag de contabilizacao dos titulos de bordero
				If LanceiCTB .and. !lUsaFlag
					For nX := 1 To Len( aSE5Baixado )
						SE5->( DbGoto( aSE5Baixado[nX] ) )
						Reclock( "SE5" )
						SE5-> E5_LA	:=	"S" + Substr( E5_LA, 2, 1 )
						MsUnlock( )
					Next nX

					// Flag contabilizacao Movimento PA
					For nX := 1 to Len( aSE2Pagant )
						SE2->( DbGoto( aSE2Pagant[nX] ) )
						Reclock( "SE2" )
						SE2-> E2_LA	:=	"S"
						MsUnlock( )
					Next nX
				Endif
			EndIf

		Enddo

		cFilAnt := cFilBaixa

		If nGerPAMov > 0 .AND. !lF090Auto// Verifico se houve a ocorrencia de PA sem Movimento bancario para acionar aviso ao usuario
			MsgAlert( STR0173 ) // "Durante o processo de baixa, foi verificada a existência de títulos de Pagamentos Antecipados sem movimento bancário. Para esses registros não foi alterado o saldo do título, mas apenas gerado o seu movimento bancário inicial."
			nGerPAMov := 0
		EndIf

		//Grava cheque totalizador no SEF e cheque no SE5
		If lCheque .and. !Empty(cCheq090) .And. Substr(cCheq090,1,1) != '*' .AND. nValorCheq > 0

			//Model de Movimento bancario
			oModelMov := FWLoadModel("FINM030")
			oModelMov:SetOperation(MODEL_OPERATION_INSERT) //Inclusao
			oModelMov:Activate()
			oSubFK5M  := oModelMov:GetModel("FK5DETAIL")
			oSubFKAM  := oModelMov:GetModel("FKADETAIL" )

			//Informar o novo campo EF_IDSEF nas inclusões de SEF:
			If SubStr( SEF->EF_NUM,1,1 ) != "*" .and. cLiberado == "S"
				cChaveCH := FWUUIDV4()
			Endif

			Reclock("SEF",.T.)
			EF_FILIAL	:= xFilial("SEF")
			EF_NUM		:= cCheq090
			EF_BANCO	:= cBco090
			EF_DATA		:= dDataBase
			EF_AGENCIA	:= cAge090
			EF_CONTA	:= cCta090
			EF_VALOR	:= nValorCheq
			EF_BENEF	:= cBenef090
			EF_LA		:= If(mv_par03==1 .and. mv_par04==1 .and. lPadrao .and. !lUsaFlag .and. cCtBaixa$"BA","S"," ")
			EF_LIBER	:= cLiberado
			EF_HIST		:= Iif(AllTrim(cHistor090)="",STR0070,cHistor090) //"Cheque por Bx. Automatica"
			EF_ORIGEM	:= "FINA090"
			EF_FILORIG	:= cFilAnt
			EF_FILCHQ	:= cFilCorr
			EF_IDSEF	:= cChaveCH		//ID do cheque
			MsUnlock()

			//Gero informacao de amarracao apenas se gerei movimento bancario
			If SubStr( SEF->EF_NUM,1,1 ) != "*" .and. cLiberado == "S"
				If !oSubFKAM:IsEmpty()
					oSubFKAM:AddLine()
					oSubFKAM:GoLine( oSubFKAM:Length() )
				Endif

				oSubFKAM:SetValue( 'FKA_IDORIG', cChaveCH )
				oSubFKAM:SetValue( 'FKA_TABORI', 'SEF' )

				//-----------------------------------------------------------------------
				// Atualização da Movimentação Bancaria, somente se o cheque for efetivo
				// (sem * na primeira posição).
				// Obs: Se o cheque foi criado por uma devolução de adiantamento não
				// precisa movimentar o saldo, pois isto foi feito pela rotina de baixa
				// de adiantamentos.
				// Também só atualiza a Movimentação bancária se o parametro MV_LIBCHEQ
				// for "S", caso contrário a movimentação bancária só será atualizada
				// na opção Conf.Cheque do prg Cheq s/ Titulos (FINA390).
				//-----------------------------------------------------------------------
				// Inclui registro no SE5 para a geracao do cheque
				cCamposE5 := "{{'E5_DTDIGIT' , dDtDigit	}"
				cCamposE5 += ",{'E5_BENEF'   , '"+StrTran(cBenef090,"'","")+"' } }"

				oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
				oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo

				//Relacionamento FKA X FK5
				If !oSubFKAM:IsEmpty()
					oSubFKAM:AddLine()
					oSubFKAM:GoLine( oSubFKAM:Length() )
				Endif

				oSubFKAM:SetValue( 'FKA_IDORIG', FWUUIDV4() )
				oSubFKAM:SetValue( 'FKA_TABORI', "FK5" )
				oSubFK5M:SetValue( "FK5_BANCO"  , cBco090 )
				oSubFK5M:SetValue( "FK5_AGENCI" , cAge090 )
				oSubFK5M:SetValue( "FK5_CONTA"  , cCta090 )
				oSubFK5M:SetValue( "FK5_NUMCH"  , cCheq090 )
				oSubFK5M:SetValue( "FK5_VALOR"  , nValorCheq )
				oSubFK5M:SetValue( "FK5_RECPAG" , "P" )
				oSubFK5M:SetValue( "FK5_HISTOR" , IIF(AllTrim(cHistor090)<>"",cHistor090,STR0070)) //"Cheque por Bx. Automatica"
				oSubFK5M:SetValue( "FK5_DATA"   , dDataBase )
				oSubFK5M:SetValue( "FK5_DTDISP" , dDataBase )
				oSubFK5M:SetValue( "FK5_NATURE" , cNatur090 )
				oSubFK5M:SetValue( "FK5_ORIGEM" , FunName() )
				oSubFK5M:SetValue( "FK5_TPDOC"  , Iif(lCheque,"CH","VL") )
				oSubFK5M:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
				oSubFK5M:SetValue( "FK5_FILORI" , cFilAnt )
				oSubFK5M:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
				oSubFK5M:SetValue( "FK5_LA"     , Iif(mv_par04==1 .and. lPadrao .and. !lUsaFlag .and. cCtBaixa$"AC","S"," ") )
				oSubFK5M:SetValue( "FK5_LOTE"   , cLoteFin )
				
				If lSpbInUse
					oSubFK5M:SetValue( "FK5_MODSPB" , "3" )
				Endif

				If oModelMov:VldData()
					oModelMov:CommitData()
					nRecSE5 := oModelMov:GetValue("MASTER","E5_RECNO")
					SE5->(dbGoTo(nRecSE5))
					Aadd(aRec090Se5,nRecSE5)
				Else
					lRet := .F.
					cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[6])
					Help( ,,"M020VLDI6",,cLog, 1, 0 )
				Endif

				oModelMov:DeActivate()
				oModelMov:Destroy()
				oModelMov := Nil

				//Atualização do Saldo Bancario
				If lAtuSldBco
					AtuSalBco( cBco090,cAge090,cCta090,SEF->EF_DATA,nValorCheq,"-" )
				EndIf
			Endif
		Endif

		If lF090SE5
			ExecBlock("F090SE5",.F.,.F.,{aRec090Se5})
		Endif

		//Finaliza processo de integracao com SIGAPCO
		If __lUsaPCO
			PCOFinLan("000006")
		EndIf

		// vai para EOF() para contabilizar apenas o total
		dbSelectArea("SE2")
		SE2->(dbGoBottom())
		SE2->(dbSkip())

		// Se for baixa de titulos e o motivo for VENDOR, nao existir o
		// parametro MV_BXAUTVE ou existir e retornar retornar .T.
		// Cria titulo de vendor baseado no total baixado
		If TrazCodMot(cMotBx) == "VEN" .And. nTipoBx == 1 .And. __lMVVENDO
			If !lF090Auto
				lVendor := Fa080Vdr(@aVendor, nValorTotal, Ctod(""))
			Else
				// Atualiza dados do vendor (matriz enviada por referencia)
				If Len(aVendor) > 0
					lVendor := .T.
				Endif
			Endif

			If lVendor
				lPadraoVd := VerPadrao( "518" ) .And. cCtBaixa $ "BA"
				Fa080GrVen(@cTitOrig,lPadraoVd,Iif(mv_par03==1,"S","N"),aVendor, "FINA090")
				nLen := Len(aTitBaixado)

				Begin Transaction
					For nX := 1 To nLen
						SE2->(DbGoto(aTitBaixado[nX,1]))

						If lPadraoVd .and. mv_par03==1
							If UsaSeqCor()
								AaDd(aDiario,{"SE5",SE5->(Recno()),cCodDiario,"E5_NODIA","E5_DIACTB"})
							EndIf

							//Prepara Lancamento Contabil
							If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
								aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
							Endif

							nTotal += DetProva( nHdlPrv, "518" /*cPadrao*/, "FINA090" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/,;
							/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
							Endif

						Reclock("SE2")
						SE2->E2_TITORIG	:= cTitOrig
						MsUnlock()
					Next
				End Transaction
			Endif
		ElseIf lPadAux .And. mv_par03 == 1 .and. nTipoBX == 2 .and. mv_par05 == 2 //Baixa por bordero e totalizacao bordero a bordero
			nLstRecSE5 := SE5->( RecNo() )
			nLen := Len(aTitBaixado)

			If nHdlPrv == 0
				nHdlPrv := HeadProva( cLote, "FINA090" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
			Endif

			aSort(aTitBaixado,,,{|x,y| x[2] < y[2]})
			nValorTotal := 0

			For nX := 1 To nLen
				SE2->(DbGoto(aTitBaixado[nX,1]))
				SED->(dbSeek(xFilial("SED")+SE2->E2_NATUREZ))

				If lPadAux
					If Len(aRegCtBor) > 0
						nI := aScan( aRegCtBor, { |x| x[1] == aTitBaixado[nX,1] } )
						SA2->(dbGoTo(aRegCtBor[nI,2]))
						SA6->(dbGoTo(aRegCtBor[nI,3]))

						//Posiona na SE5
						If aRegCtBor[nI,4] <> 0
							SE5->(dbGoTo(aRegCtBor[nI,4]))
						Else
							SE5->(dbGoTo(nLstRecSE5))
						EndIf
					EndIf

					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
					Endif

					nTotal += DetProva( nHdlPrv, "532", "FINA090" /*cPrograma*/, cLote, 0 /*nLinha*/, .T. /*lExecuta*/, "FINA090" /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/,;
					/*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )

					If UsaSeqCor()
						AaDd(aDiario,{"SE5",SE5->(Recno()),cCodDiario,"E5_NODIA","E5_DIACTB"})
					EndIf
				EndIF

				nValorTotal += SE2->E2_VALLIQ

				//Verifica se eh o mesmo bordero ou se eh o ultimo titulo
				If (nX+1 <= nLen .and. aTitBaixado[nX+1,2] != aTitBaixado[nX,2]) .or. (nX+1 > nLen)
					VALOR		:= nValorTotal
					VLRINSTR	:= nValorTotal
					VALOR2		:= 0
					ABATIMENTO 	:= 0
					STRLCTPAD	:= aTitBaixado[nX,2]

					If lPadAux
						nRecNoSE5 := SE5->( RecNO() )
						nRecNoSE2 := SE2->( RecNO() )
						nRecNoFK2 := FK2->( RecNO() )

						SE5->( DBGoBottom() )
						SE5->( DBSkip() )
						SE2->( dbGoBottom() )
						SE2->( dbSkip() )
						FK2->( dbGoBottom() )
						FK2->( dbSkip() )

						//Prepara Lancamento Contabil
						nTotal += DetProva( nHdlPrv, "532", "FINA090" /*cPrograma*/, cLote, 0 /*nLinha*/, .T. /*lExecuta*/, "FINA090" /*cCriterio*/, /*lRateio*/,;
						/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, /*@aFlagCTB*/, /*aTabRecOri*/, /*aDadosProva*/ )

						//Restaura a posicao do arquivo
						SE5->( DBGoTo( nRecNoSE5 ) )
						SE2->( DBGoTo( nRecNoSE2 ) )
						FK2->( DBGoTo( nRecNoFK2 ) )

						If UsaSeqCor()
							AaDd(aDiario,{"SE5",SE5->(RecNo()),cCodDiario,"E5_NODIA","E5_DIACTB"})
						EndIf
					EndIF

					nValorTotal := 0
					VALOR		:= 0
					VLRINSTR	:= 0
					VALOR2		:= 0
					ABATIMENTO 	:= 0
					STRLCTPAD	:= "  "
				Endif
			Next

			VALOR := 0
			lTotPorBord := .T.

		EndIf

		If !lTotPorBord .And. nTipoBx == 2
			// Credito do Banco = Variavel VALOR
			//Zero as variáveis de impostos caso não gere movimento totalizador (MV_BXCNAB == S)
			If !lBxCnab
				FINVARCTB()
			Endif

			//Credito do Banco = Variavel VALOR
			VALOR		:= nValorTotal
			VLRINSTR	:= nValorTotal		// CONDICIONAL DA VARIAVEL VALOR
			Valor2		:= 0					// TOTAL DOS ABATIMENTOS (por titulo)
			ABATIMENTO	:= 0

			If (cCtBaixa == "C" .And. lCheque .and. lMovBcoBx .And. MV_PAR04==1) .or. (cCtBaixa $"B|A") .or. (TrazCodMot(cMotBx) $ "VEN/DEB") .or. (MovBcoBx(cMotBx, .T.) .and. !ChqMotBx(cMotBx))
				If lPadAux .and. mv_par03 == 1

					If nHdlPrv == 0
						nHdlPrv := HeadProva( cLote, "FINA090" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
					Endif

					//vai para EOF() para contabilizar apenas o total
					nRecNoSE5 := SE5->( RecNO() )
					nRecNoSE2 := SE2->( RecNO() )
					nRecNoFK2 := FK2->( RecNO() )

					SE5->( DBGoBottom() )
					SE5->( DBSkip() )
					SE2->( dbGoBottom() )
					SE2->( dbSkip() )
					FK2->( dbGoBottom() )
					FK2->( dbSkip() )

					//Prepara Lancamento Contabil
					nTotal += DetProva( nHdlPrv, "532", "FINA090" /*cPrograma*/, cLote, 0 /*nLinha*/, .T. /*lExecuta*/, "FINA090" /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/,;
					/*aCT5*/, /*lPosiciona*/, /*@aFlagCTB*/, /*aTabRecOri*/, /*aDadosProva*/ )

					//Restaura a posicao do arquivo
					SE5->( DBGoTo( nRecNoSE5 ) )
					SE2->( DBGoTo( nRecNoSE2 ) )
					FK2->( DBGoTo( nRecNoFK2 ) )

					If UsaSeqCor()
						AaDd(aDiario,{"SE5",SE5->(Recno()),cCodDiario,"E5_NODIA","E5_DIACTB"})
					EndIf
				EndIF

				VALOR := 0
			Endif
		EndIf

		//Envia para Lancamento Contabil, se gerado arquivo
		If nHdlPrv > 0 .And. nTotal > 0 .And. mv_par03 == 1
			lDigita := If( mv_par01 == 1 .and. !lF090Auto , .T., .F. )
			lAglut  := If( mv_par02 == 1, .T., .F. )

			//Se for rotina automatica força exibir mensagens na tela, pois mesmo quando não exibe os lançametnos, a tela
			//sera exibida caso ocorram erros nos lançamentos padronizados
			If lF090Auto	// Chamada Automatizada
				lSetAuto := _SetAutoMode(.F.)
				lSetHelp := HelpInDark(.F.)
			EndIf

			//	Define data da contabilização on line
			Do Case
			Case nDtContOn == 1 // 1- Data Digitação
				dDtLanc := dDtDigit
			Case nDtContOn == 2 // 2- Data Disponibilizadade
				dDtLanc := dDebito
			Case nDtContOn == 3 // 3- Data Pagamento
				dDtLanc := dBaixa
			EndCase

			//Efetiva Lancamento Contabil
			cA100Incl(cArquivo, nHdlPrv, /*nOpcx*/, cLote, lDigita, lAglut, /*cOnLine*/, dDtLanc, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, aDiario )

			aFlagCTB := {}

			If lF090Auto	// Chamada Automatizada
				HelpInDark(lSetHelp)
				_SetAutoMode(lSetAuto)
			EndIf

			//Flag de contabilizacao dos titulos de bordero
			If ( nTotal > 0 ) .and. !lUsaFlag
				For nX := 1 To Len( aSE5Baixado )
					SE5->( DbGoto( aSE5Baixado[nX] ) )
					If !lUsaFlag
						Reclock( "SE5" )
						SE5-> E5_LA	:=	"S" + Substr( E5_LA, 2, 1 )
						MsUnlock( )
					Endif
				Next
			Endif

			// Flag Contabilizacao Movimento PA
			For nX := 1 to Len( aSE2Pagant )
				SE2->( DbGoto( aSE2Pagant[nX] ) )
				If !lUsaFlag .And. lCtMovPa
					Reclock( "SE2" )
					SE2-> E2_LA	:=	"S"
					MsUnlock( )
				Endif
			Next
		EndIf

	END TRANSACTION// Garante a transacao após a geração do cheque aglutinador

	If __oBillRel <> Nil
		FWFreeObj(__oBillRel)
	EndIf

	dbSelectArea( "SE2" )
	RetIndex("SE2")
	Set Filter to

Return lContinua

//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa090ChecF
Funcao para montar e processar a query	

@Param nTipoBx	, Numeric	, Tipo de Baix: 1 = Título ou 2 = Borderô
@Param cBord090I, Character , Código do borderô inicial
@Param cBord090F, Character , Código do borderô final
@Param cBco090	, Character , Código do banco
@Param cAge090	, Character , Código da agência
@Param cCta090	, Character , Código do borderô final

@return cFiltro	, Character , Texto da Query

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function Fa090ChecF(nTipoBx,cBord090I,cBord090F,aSelFil,aTMPFil,cBco090,cAge090,cCta090)

	Local cFiltro   	:= ""
	Local cF090QFIL 	:= "" // Retorno do P.E. cFiltro
	Local cF090FIL	 	:= "" // Retorno do P.E. cFiltro
	Local lBxTxa    	:= SuperGetMv("MV_BXTXA",.F.,"1") == "1"
	Local lF090Tipo 	:= ExistBlock( "F090TIPO" )
	Local cNomeCpo  	:= ""
	Local aFiluser		:= {}
	Local cTmpSE1Fil	:= ""
	Local cFilCxCtr 	:= F090IsCaixa(.T.)
	Local lMvCheques 	:= Type('MVCHEQUES')=='C'
	Local cMvCheques 	:= F90FORMATIN( IIF(lMvCheques,MVCHEQUES,MVCHEQUE) )

	DEFAULT nTipoBx		:= 1
	DEFAULT cBord090I	:= ""
	DEFAULT cBord090F	:= ""
	DEFAULT aSelFil 	:= {cFilAnt}
	DEFAULT aTMPFil 	:= {}
	DEFAULT cBco090		:= ""
	DEFAULT cAge090		:= ""
	DEFAULT cCta090		:= ""
	Default __lQFILTRO  := ExistBlock("F090QFIL")
	Default __lF090FIL  := ExistBlock("F090FIL")
	Default __lCtLIPag 	:= GetMv("MV_CTLIPAG")

	//nTipoBx -> 1 = Baixa somente titulos que não estao em bordero
	//nTipoBx -> 2 = Baixa somente titulos em bordero
	aFiluser := FA090CKUS(aSelFil) //Pega somente as filiais que o usuario tem acesso

	//alteracao efetuada para possibilitar baixa Multi-Filial
	If !aFiluser[1] .And. Len(aFiluser[2]) > 0	// verifica se o usuario tem restrições de acesso a alguma filial
		cFiltro := "E2_FILIAL IN " + F90FORMATIN(Fa090MnFil(aFiluser[2]))
	else
		cFiltro += "E2_FILIAL " + GetRngFil( aSelFil, "SE2", .T., @cTmpSE1Fil )
		aAdd(aTMPFil, cTmpSE1Fil)
	endIf

	cFiltro  += " AND "

	If ExistBlock("F090FILEMI")
		cNomeCpo := ExecBlock("F090FILEMI",.F.,.F.,{})
		If SE2->(ColumnPos(cNomeCpo)) > 0
			cFiltro += cNomeCpo + " <= '" + DTOS(dBaixa) + "' AND "
		EndIf
	EndIf

	cFiltro += " E2_EMISSAO <= '" + DTOS(dBaixa) + "' AND "
	If !Empty(cBcoDe) .And. !Empty(cBcoAte) .And. Alltrim(cBcoDe) == Alltrim(cBcoAte)
		cFiltro  += " E2_PORTADO = '" + cBcoDe + "' AND "
	Else
		cFiltro  += " E2_PORTADO >= '" + cBcoDe  + "' AND "
		cFiltro  += " E2_PORTADO <= '" + cBcoAte + "' AND "
	EndIf

	If cPaisLoc $ "PER|DOM|ARG"
		cFiltro += " E2_PORTADO NOT IN " + cFilCxCtr + " AND "
	Endif

	If nTipoBx == 1
		cFiltro += " E2_VENCREA >= '" + DTOS(dVencIni) + "' AND "
		cFiltro += " E2_VENCREA <= '" + DTOS(dVencFim) + "' AND "
		cFiltro += " E2_NUMBOR = '" + Space(TamSx3("E2_NUMBOR")[1]) + "' AND "
	Endif
	If nTipoBx == 2
		If !Empty(cBord090I) .And. !Empty(cBord090F) .And. Alltrim(cBord090I) == Alltrim(cBord090F)
			cFiltro  += " E2_NUMBOR = '" + cBord090I + "' AND "
		Else
			cFiltro  += " E2_NUMBOR >= '" + cBord090I + "' AND "
			cFiltro  += " E2_NUMBOR <= '" + cBord090F + "' AND "
			cFiltro  += " E2_NUMBOR != '" + Space(TamSx3("E2_NUMBOR")[1]) + "' AND "
		EndIf
	Endif

	/*Caso o !lBxTxa seja .T. por causa do parâmetro MV_BXTXA, será acrescentado no filtro a
		validação da flag E2_OK, para assim não exibir na janela de marcação um título do tipo TXA
		que já foi baixado, como solicitado no chamado TGACUL */
	If !lBxTxa
		cFiltro += " (E2_OK <> 'TA' ) AND "
	Endif
	cTipo := If(!Empty(MVPROVIS), MVPROVIS, '')
	cTipo += If(!Empty(MV_CPNEG),'/'+MV_CPNEG,'')
	cTipo += If(!Empty(MVABATIM),'/'+MVABATIM,'')
	cTipo += If(!Empty(MVENVBCOR),'/'+MVENVBCOR,'')

	If lF090Tipo
		cTipo := ExecBlock( 'F090TIPO' , .F. , .F. , { cTipo } )
	EndIf

	cFiltro += " E2_TIPO NOT IN " + F90FORMATIN( cTipo ) + " AND "

	If SuperGetMV("MV_EASYFIN",,"N") == "S" .And. FindFunction("EasyFinOri")
		cFiltro += EasyFinOri() + " AND "
	Else
		cFiltro  += " E2_ORIGEM NOT IN ('SIGAEEC','SIGAEDC','SIGAECO','SIGAEFF','SIGAESS', 'SIGAEIC') AND "
	EndIf

	If FindFunction("EasyOrigem") .And. FindFunction("F050EasyOrig")
		cFiltro  += " E2_TIPO NOT IN ('PR','PRE') AND "
	EndIf

	// Para o Brasil, apresenta somente os titulos cuja moeda e' a mesma do banco selecionado para baixa.
	// Caso a moeda do banco estiver vazia ou caso o motivo de baixa nao movimente banco, considero apenas a moeda forte
	If FXMultSld()
		If nMoedaBco > 1 .And. MovBcoBx(cMotBx,.T.)
			cFiltro  += " E2_MOEDA = " +  StrZero( nMoedaBco, 2 ) + " AND "
		Endif
	EndIf

	// Se trabalha com liberacao de pagto., filtra os registros que ultrapassem o valor minimo
	If __lCtLIPag
		cFiltro  += " ( E2_DATALIB !=  '        '  OR (E2_SALDO+E2_SDACRES-E2_SDDECRE) <= " + Str(GetMV("MV_VLMINPG"),17,2) + ") AND "
	Endif

	// Verifica se o titulo esta bloqueado - Gestao de Contratos
	If cPaisLoc == "CHI" .And. !Empty(SE2->(ColumnPos("E2_MSBLQL")))
		If !Empty(E2_CODOPE)
			cFiltro += " E2_CODOPE = '02' AND "
		Else
			cFiltro += " E2_MSBLQL != '1' AND "
		EndIf
	ElseIf !Empty(SE2->(ColumnPos("E2_MSBLQL")))
		cFiltro += " E2_MSBLQL != '1' AND "
	EndIf

	cFiltro += " E2_SALDO > 0 "

	// Para localizados deve ser apresentado apenas os titulos do tipo Cheque
	If cPaisLoc <> "BRA"
		cFiltro += " AND E2_TIPO IN " + cMvCheques + " "
	EndIf

	// PONTO DE ENTRADA PARA ALTERACAO DO FILTRO - ORIGINAL FINA090
	If __lQFILTRO
		cF090QFIL := ExecBlock("F090QFIL",.F.,.F.,{cFiltro, nTipoBx})
		If (ValType(cF090QFIL) == "C" .AND. !Empty(cF090QFIL))
			cFiltro := cF090QFIL
		EndIf
	// PONTO DE ENTRADA PARA ALTERACAO DO FILTRO - ORIGINAL FINA091
	ElseIf __lF090FIL
		cF090FIL := ExecBlock("F090FIL",.f.,.f.,{nTipoBx,cBco090,cAge090,cCta090,cBord090I,cBord090F,cFiltro})
		If (ValType(cF090QFIL) == "C" .AND. !Empty(cF090FIL))
			cFiltro := cF090FIL
		EndIf
	Endif

	// Complemento de filtro - SIAFI
	cFiltro  +=  FinTemDH(.T. /*lFiltro*/,/*cAlias*/,.F. /*lHelp*/, .T./*lTop*/)

Return cFiltro


//-------------------------------------------------------------------
/*{Protheus.doc} FA090CKUS
função ira verificar quais filais estão acessiveis pelo usuario logado

@param 	cFilIni - Filial Inicial
cFilFim - Filail Final

@author Caio Quiqueto
@since 21/07/2015
@version P11

@return Array{lAceCompl,aRet
lAceCompl - se o usuario tem acesso a todas as filais do Grupo de empresas
aRet - array com todas as filais que o usuario tem acesso no Grupo de empresas
*/
//-------------------------------------------------------------------
function FA090CKUS(aSelFil)

	Local aSM0		:= FWLoadSM0()	//Carrega as informações das filiais
	Local GrpCorr	:= FWGrpCompany ()	// Retorna o grupo de empresas utilizada pelo Sistema.
	Local nX		:= 1
	Local nGrpCont	:= 0
	Local aRet 		:= {}
	Local lAceCompl := .F.

	DEFAULT aSelFil := {}

	//ordena o array de filial por grupo e código de filial
	aSM0 := asort(aSM0,,,{|X,Y| X[1]+X[2] < Y[1]+Y[2]})

	//posiciona no primeiro registro do grupo logado
	nX := aScan(aSM0,{|X| X[1] == GrpCorr})

	while aSM0[nX][1] = GrpCorr
		If aSM0[nX][11] .AND. IF(LEN(aSelFil)>0,ASCAN(aSelFil,{|e| e == aSM0[nX][2]}) > 0,.T.)
			aADD(aRet, xFilial( "SE2", aSM0[nX][2] ))
		EndIf
		If nX == Len(aSM0)
			Exit
		EndIf
		nGrpCont ++
		nX ++
	enddo

	if nGrpCont = len(aRet)
		lAceCompl := .T.
	EndIf

return {lAceCompl,aRet}


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fa090Correc
Calculo da Correção Monetária

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function fa090Correc( )

	Local nCorrecao := 0
	Local nValAtual := 0
	Local nValEmiss := 0
	Local nTxEmis	:= 0
	Local nTxBaix	:= 0

	IF SE2->E2_MOEDA > 1

		//Caso seja a primeira apuracao de variacao monetaria
		If Empty(SE2->E2_TXMOEDA) .and. Empty(SE2->E2_DTVARIA)
			nValEmiss := SE2->E2_VLCRUZ
		Else
			nTxEmis	:= If(SE2->E2_MOEDA > 1,If(SE2->E2_TXMOEDA > 0 .and. Empty(SE2->E2_DTVARIA) .And. RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA) == 0, SE2->E2_TXMOEDA,;
				IIf(RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA) > 0 .And. Empty(SE2->E2_TXMOEDA), RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA), SE2->E2_TXMOEDA)),0)
			If !Empty(SE2->E2_TXMDCOR)
				nValEmiss := Round(xMoeda( SE2->E2_SALDO, SE2->E2_MOEDA, 1, IF(Empty(SE2->E2_DTVARIA),SE2->E2_EMISSAO,SE2->E2_DTVARIA),3,SE2->E2_TXMDCOR ),2)
			Else
				nValEmiss := Round(xMoeda( SE2->E2_SALDO, SE2->E2_MOEDA, 1, If(Empty(SE2->E2_DTVARIA),SE2->E2_EMISSAO,SE2->E2_DTVARIA),3,nTxEmis),2)
			EndIf
		End

		nTxBaix :=  If(SE2->E2_MOEDA > 1,If(SE2->E2_TXMOEDA > 0 .and. Empty(SE2->E2_DTVARIA) .And. RecMoeda(dDataBase,SE2->E2_MOEDA) == 0, SE2->E2_TXMOEDA,;
			IIf(RecMoeda(dDataBase,SE2->E2_MOEDA) > 0 .And. Empty(SE2->E2_TXMOEDA), RecMoeda(dDataBase,SE2->E2_MOEDA), SE2->E2_TXMOEDA)),0)

		nValAtual := Round(xMoeda( SE2 -> E2_SALDO, SE2 -> E2_MOEDA, nMoedaBco, dDataBase, 3, nTxBaix ),2)

		//--------------------------------------------------------------------
		// Verifica atraves do parametro MV_CALCCM se sera calculada a
		// correcao monetaria. Caso o parametro nao exista, sera assumido "S"
		//--------------------------------------------------------------------
		If SE2->E2_MOEDA != nMoedaBco .AND. GetMv("MV_CALCCM") == "S"
			nCorrecao := nValAtual - nValEmiss
		Else
			nCorrecao := 0
		Endif
	Endif

Return nCorrecao


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fA090Par
Ativa Parâmetros do Programa 

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function fA090Par()
	pergunte(__cPerg,.T.)
Return .T.


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa090Marca
Trata o valor para marcar e desmarcar item

@Param cAlias	, Character , Alias utilizado para seleção de títulos
@Param cMarca	, Character , Código da marca do processo
@Param aTitulos , Array		, Array dos títulos a serem processados
@Param nTipoBx	, Numeric	, Tipo de Baix: 1 = Título ou 2 = Borderô

@return cFiltro	, Character , Texto da Query

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function Fa090Marca(cAlias,cMarca,aTitulos,nTipoBx)

	Local nRec		 := 0
	Local cAliasAnt  := Alias()
	Local nY		 := 0
	Local lHelpBxTit := .F.

	Private nValorMarca	:= 0 // Permitir alterar valor do titulo marcado no PE F090TIT

	Default aTitulos := {}

	If cPaisLoc <> "BRA"
		nVA :=  IIF(Type("nVA") == "U" ,0,nVA)
		SCU->(DbSetOrder(2))
	Endif

	dbSelectArea("SE2")
	nRec := SE2->(Recno())

	//Rotina Normal (NAO Automatizada)
	If Empty(aTitulos)

		ProcRegua((cAlias)->(RecCount()))
		(cAlias)->(DbGoTop())
		While (cAlias)->(!Eof())

			SE2->(DBGoto((cAlias)->NUM_REG) )
			F090VldMrk(cAlias,aTitulos, @lHelpBxTit )
			IncProc(STR0164) //"Selecionando registros..."

			(cAlias)->(dbSkip())
		EndDo
	Else
		//Rotina Automatizada
		For nY := 1 to Len(aTitulos)
			(cAlias)->(DbSetOrder(3))

			If (cAlias)->(MsSeek(aTitulos[nY]))
				SE2->(dbGoto(aTitulos[nY]))
				F090VldMrk(cAlias,aTitulos, @lHelpBxTit )
			Endif
		Next nY

		If lHelpBxTit
			Help(" ",1,"F090PAMOV",,STR0172,1,0) //"Nao é possivel realizar a baixa de pagamento antecipado sem movimentação bancária."
		EndIf

		If !Empty((cAlias)->E2_NUMBOR)
			nTipoBx := 2
		EndIf
		(cAlias)->(DbSetOrder(4))
	Endif

	dbSelectArea("SE2")
	dbGoto(nRec)
	dbSelectArea(cAliasAnt)
Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090VldMrk
	Efetua a gravação da Marca no título

	@author Pequim
	@since 18/11/2021

	@param aTitulos, Array, Lista dos títulos a serem marcados (Automatica)
	@return return_var, return_type, return_description
/*/
//---------------------------------------------------------------------------------------------------------
Static Function F090VldMrk (cAlias As Character, aTitulos AS Array, lHelpBxTit AS Logical)

	Local lTodos As Logical
	Local lRet AS Logical
	Local lBxTit AS Logical
	Local lPrimeiro AS Logical
	Local cUserLga AS Character
	Local nAbat	AS Numeric
	Local nRecPA AS Numeric

	Default __lF090TIT	:= ExistBlock("F090TIT")
	Default __lSOLNCP 	:= SuperGetMv('MV_SOLNCP')
	Default __lCtLIPag 	:= GetMv("MV_CTLIPAG")
	Default __lFinVDoc	:= GetNewPar("MV_FINVDOC","2") == "1" //Controle de validacao de documentos obrigatorios
	Default __nTamMD2	:= TamSx3("E2_TXMOEDA")[2]
	Default __lExtUSLG  := ColumnPos('E2_USERLGA') > 0

	lBxTit		:= .T.
	lPrimeiro	:= .T.
	lRet		:= .T.
	lTodos		:= Empty(aTitulos)
	cUserLga	:= ""
	nAbat		:= 0
	nRecPA		:= 0

	//-------------------------------------------------------------------
	// Caso esteja ligado o controle de solicitacao de notas de credito
	// e exista alguma pendencia para este titulo
	//-------------------------------------------------------------------
	If cPaisloc <> "BRA" .And. __lSOLNCP .And. SE2->E2_TIPO == MVNOTAFIS .And. ;
			SCU->(MsSeek(xFilial("SCU")+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_NUM+SE2->E2_PREFIXO)).And. Empty(SCU->CU_NCRED)
		lRet := .F.
	EndIf

	// Documentos Apresentados
	IF lRet .and. __lFinVDoc
		If !CN062ValDocs("03",.F.,.F.,lTodos,@lPrimeiro)
			lRet := .F.
		EndIf
	Endif

	// Verifica se possui movimento de baixa valido
	If lRet .and. (cAlias)->E2_TIPO $ "INA"
		If F090PagINA( SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) )
			lRet := .F.
		EndIf
	EndIf

	If lRet
		lRet := Fa080Integ(.F.,.F.)
	Endif

	If lRet
		lBxTit := .T.

		// Caso tenha integracao SIGAPFS (MV_JURXFIN = .T.), valida as regras para manipulacao do título.
		If !Fa090Juri(.F., .F.)
			lBxTit := .F.
		EndIf

		//Verifica motivo de baixa para titulo cancelado
		If __lCtLIPag .And. !Empty(SE2->E2_DATACAN) .And. MovBcoBx(cMotBx, .T.)
			IF !lTodos
				Help(" ",1,"F090SELCANC",,STR0117,1,0) //"Impossível selecionar este título, pois o motivo de baixa é inválido para títulos cancelados."
			EndIf
			lBxTit := .F.
		Endif

		//Verifica se PA possui movimentacao para permitir a baixa
		If SE2->E2_TIPO $ MVPAGANT .and. lBxTit
			nRecPA := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			If nRecPA < 1
				//Verifica se ‚ PA de CNAB (Gera Ch para Adt = N?o / Mov. Banc. sem Cheque = N?o) - Nesse caso deve permitir a baixa para gerar mov. a pagar
				nRecPA := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
				If nRecPA > 0
					lBxTit := .F.
					If !lTodos
						lHelpBxTit	:= .T.
					Endif
				Else
					lBxTit := .T.
				Endif
			EndIf
		Endif

		If __lExtUSLG
			cUserLga := SE2->E2_USERLGA
		EndIf

		If (cAlias)->(MsRLock()) .and. SE2->(MsRLock())// Se conseguir travar o registro
			(cAlias)->E2_OK := cMarca
			SE2->E2_OK := cMarca

			If __lExtUSLG
				SE2->E2_USERLGA := 	cUserLga
			EndIf

			nAbat := F090GETABAT()

			nVA 	:= FValAcess( SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NATUREZ, .T. ,, "P", dDatabase, , SE2->E2_MOEDA )

			nValorMarca	:= xMoeda(Round(SE2->E2_SALDO+fa080Juros(nMoedaBco) + nVA + SE2->E2_SDACRES-SE2->E2_SDDECRE-nAbat,2) ,SE2->E2_MOEDA,nMoedaBco,,__nTamMd2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))

			//-------------------------------------------------------------------------------------------------------
			// PONTO DE ENTRADA F090TIT
			// Verifica se titulo pode ser marcado para baixa ou não caso tenha sido alterada a marcação do titulo.
			// Retornar .F. para não haver alteração dos acumuladores de valores e numero de titulos.
			// Importante:
			// Os valores passados como parãmetro para esse PE são apenas para manter a compatibilidade
			// com a chamada feita no FINA090.
			// Valores utilizados apenas na chamada da rotina automática do FINA090
			//-------------------------------------------------------------------------------------------------------
			If __lF090TIT
				lBxTit := ExecBlock("F090TIT",.F.,.F.,{nValorMarca,aTitulos})
			Endif
			If lBxTit
				nValor += nValorMarca - nDescont
				nQtdTit	++
			Else
				(cAlias)->E2_OK := "  "
				SE2->E2_OK := "  "
				(cAlias)->(MsUnlock())
				SE2->(MsUnlock())
			Endif
		Endif
	Endif

Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa090Inverte
Marca / Desmarca todos os titulos

@Param cAliasSe2, Character , Alias utilizado para seleção de títulos
@Param cMarca	, Character , Código da marca do processo
@Param oValor 	, Object	, Objeto para atualização do valor selecionado para baixa
@Param oQtda 	, Object	, Objeto para atualização do numero de registros selecionado para baixa
@Param lTodos	, Logical	, Indica se está sendo chamada de um título ou da inverte
@Param oMark 	, Object	, Objeto para atualização da marcação

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function Fa090Inverte(cAliasSE2,cMarca,oValor,oQtda,lTodos,oMark)

	Local nAbat		 := 0
	Local nVa        := 0
	Local lBxTit	 := .T.
	Local aAreaSE2	 :=	SE2->(GetArea())
	Local aAreaAlias := (cAliasSe2)->(GetArea())
	Local lPrimeiro	 :=.T.
	Local lLibLock	 := .F.
	Local cUserLga   := ""

	Local nRecPA     := 0

	Private nValorMarca	:= 0 // Permitir alterar valor do titulo marcado no PE F090TIT

	DEFAULT lTodos	  	:= .T.
	Default __lDescont	:= ExistBlock("F090DESC")
	Default __lF090TIT	:= ExistBlock("F090TIT")
	Default __lCtLIPag 	:= GetMv("MV_CTLIPAG")
	Default __lFinVDoc	:= GetNewPar("MV_FINVDOC","2") == "1" //Controle de validacao de documentos obrigatorios
	Default __nTamMD2	:= TamSx3("E2_TXMOEDA")[2]
	Default __lExtUSLG  := ColumnPos('E2_USERLGA') > 0

	dbSelectArea(cAliasSE2)
	If lTodos
		(cAliasSE2)->(dbSetOrder(1))		//E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
		(cAliasSE2)->(DbGoTop())
	EndIf

	While !lTodos .Or. !(cAliasSE2)->(Eof())

		SE2->(dbGoto((cAliasSE2)->NUM_REG))
		If __lExtUSLG
			cUserLga := SE2->E2_USERLGA
		EndIF

		If SE2->(MsRLock()) .AND. (cAliasSE2)->(MsRLock())
			IF (cAliasSE2)->E2_OK == cMarca
				(cAliasSE2)->E2_OK := "  "
				SE2->E2_OK := "  "
				lLibLock := .T.
				nAbat := F090GETABAT()

				nVa	:= FValAcess(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NATUREZ, .T./*lBaixados*/,/*cCodVa*/,"P",dBaixa)

				nValor	-= xMoeda(Round(SE2->E2_SALDO+fa080Juros(nMoedaBco) + nVA +SE2->E2_SDACRES-SE2->E2_SDDECRE-nAbat-nDescont,2) ,SE2->E2_MOEDA,nMoedaBco,,__nTamMd2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))

				nQtdTit	--
			Else
				lBxTit := .T.

				// Caso tenha integracao SIGAPFS (MV_JURXFIN = .T.), valida as regras para manipulacao do título.
				If !Fa090Juri(lTodos, @lPrimeiro)
					lBxTit := .F.
					lLibLock := .T.
				EndIf

				//Verifica se motivo e valido no caso de titulo cancelado
				If lBxTit .and. __lCtLIPag .And. !Empty(SE2->E2_DATACAN) .And. MovBcoBx(cMotBx, .T.)
					IF !lTodos
						Help(" ",1,"F090SELCANC",,STR0117,1,0) //"Impossível selecionar este título, pois o motivo de baixa é inválido para títulos cancelados."
					EndIf
					lBxTit := .F.
					lLibLock := .T.
				EndIf

				// Caso tenha integracao Documentos
				If  lBxTit .and. __lFinVDoc
					If !CN062ValDocs("03",.F.,.F.,lTodos,@lPrimeiro)
						(cAliasSE2)->E2_OK := "  "
						SE2->E2_OK	:= "  "
						lBxTit := .F.
						lLibLock := .T.
					EndIf
				EndIf

				// Verifica se possui movimento de baixa valido
				If lBxTit .and. SE2->E2_TIPO $ "INA"
					If F090PagINA( SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) )
						IF !lTodos
							HELP(" ",1,"SE2BLOQ")
						EndIf
						(cAliasSE2)->E2_OK := "  "
						SE2->E2_OK	:= "  "
						lBxTit := .F.
						lLibLock := .T.
					EndIf
				EndIf

				// Verifica se PA possui movimentacao bancaria
				If  lBxTit .and. SE2->E2_TIPO $ MVPAGANT
					nRecPA := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
					If nRecPA < 1
						//Verifica se é PA de CNAB (Gera Ch para Adt = Não / Mov. Banc. sem Cheque = Não) - Nesse caso deve permitir a baixa para gerar mov. a pagar
						nRecPA := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
						If nRecPA > 0
							IF !lTodos
								Help(" ",1,"F090PAMOV",,STR0172,1,0) //"Não é possível realizar a baixa de pagamento antecipado sem movimentação bancária."
							Endif
							lBxTit := .F.
							lLibLock := .T.
						Else
							lBxTit := .T.
							lLibLock := .F.
						Endif
					EndIf
				Endif

				//------------------------------------------------------------------------------------------
				// PONTO DE ENTRADA F090TIT
				// Verifica se titulo pode ser marcado para baixa ou nÆo. Caso tenha
				// sido alterada a marcação do titulo.
				// Retornar .F. para não haver alteração dos acumuladores de valores e numero de titulos.
				// Importante:
				// Os valores passados como parãmetro para esse PE são apenas para manter a compatibilidade
				// com a chamada feita no FINA090.
				// Valores utilizados apenas na chamada da rotina automática do FINA090
				//------------------------------------------------------------------------------------------
				IF __lF090TIT .and. !Empty(E2_OK)
					lBxTit := ExecBlock("F090TIT",.F.,.F.,{nValorMarca,{}})
				Endif

				If lBxTit
					(cAliasSE2)->E2_OK := cMarca
					SE2->E2_OK	:= cMarca

					nAbat 		:= F090GETABAT()
					nVa	:= FValAcess(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NATUREZ, .T./*lBaixados*/,/*cCodVa*/,"P",dBaixa)
					nValorMarca := xMoeda(Round(SE2->E2_SALDO+fa080Juros(nMoedaBco) + nVA + SE2->E2_SDACRES-SE2->E2_SDDECRE-nAbat,2) ,SE2->E2_MOEDA,nMoedaBco,,__nTamMd2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))
					nValor += IIF(__lDescont, (nValorMarca - nDescont), nValorMarca)
					nQtdTit++
				Else
					(cAliasSE2)->E2_OK	:= "  "
					SE2->E2_OK	:= "  "
					lLibLock := .T.
				Endif
			EndIf
			If __lExtUSLG
				SE2->E2_USERLGA := cUserLga
			EndIF
		EndIf
		IF lLibLock
			(cAliasSE2)->(MsUnlock())
			SE2->(MsUnlock())
		ENDIF

		If lTodos
			(cAliasSE2)->(dbSkip())
		Else
			Exit
		EndIf

	Enddo

	RestArea(aAreaSE2)
	RestArea(aAreaAlias)

	oValor:Refresh()
	oQtda:Refresh()

Return Nil



//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fa090Busca
Pesquisa com indice temporario

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function fa090Busca()
	AxPesqui()
	Eval(bFilBrw)
Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090VldBx
Valida dados para baixa automática

@Param nTipoBx	, Numeric	, Tipo de Baix: 1 = Título ou 2 = Borderô
@Param lBxCnab	, Logical	, Gera totalizador quando baixa CNAB
@Param cBco090	, Character , Código do banco
@Param cAge090	, Character , Código da agência
@Param cCta090	, Character , Código do borderô final
@Param cMotBx	, Character , Motivo de Baixa
@Param oDlg 	, Object	, Objeto que contém as informações a serem validadas
@Param cCheq090	, Character , Código do cheque 
@Param cBord090I, Character , Código do borderô inicial
@Param cBord090F, Character , Código do borderô final
@Param oRadio 	, Object	, Objeto que contém as informações do tipo de baixa (Título/Bordero)
@Param lBcoExcl	, Logical	, Indica se o cadastro de bancos é exclusivo ou compartilhado
@Param lF090Auto, Logical	, Indica se ExecAuto
@Param aVendor  , Array		, Array contendo dados para baixa por VENDOR

@Return lRet	, Logical	, Informa se a validação foi positiva ou não

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function F090VldBx(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,oRadio,lBcoExcl,lF090Auto,aVendor)

	Local nX	:= 0
	Local lRet	:= .T.
	Local lWhen

	DEFAULT lBcoExcl := .F.
	DEFAULT lF090Auto := .F.
	DEFAULT aVendor := {}
	DEFAULT __lMVVENDO := SuperGetMv("MV_BXAUTVE",.F.,.F.)

	If !lF090Auto
		For nX := 1 To Len(oDlg:aControls)
			If ValType(oDlg:aControls[nX]) == "O" .And.;
					!Empty(oDlg:aControls[nX]:bValid)
				lWhen := Eval(oDlg:aControls[nX]:bWhen)
				// So valida a condicao Valid, se passou pela condicao When
				If ValType(lWhen) != "L" .Or. lWhen
					lRet:=Eval(oDlg:aControls[nX]:bValid)
					If ValType(lRet) != "L"
						lRet := .T.
					Endif
					If !lRet
						Help(" ",1,"F090Erro",,STR0073,1,0) // "Campos obrigatórios não preenchidos"+chr(13)+"ou com valores inválidos"
						Exit // Sai no primeiro campo invalido
					Endif
				Endif
			Endif
		Next
	Endif

	If ExistBlock("F090TOK")
		lRet := ExecBlock("F090TOK",.F.,.F.,{cBcoDe,cBcoAte,cBco090,cAge090,cCta090,cCheq090,cBord090I,cBord090F,dVencIni,dVencFim,nTipoBx,oRadio})
	Endif

	If lRet .and. nTipoBx == 2 .and. mv_par01 == 2 .and. lBxCnab
		If !Empty(cLoteFin)
			lRet := CheckLote("P", !lF090Auto, cBco090)
		Else
			lRet := .F.
		Endif
	Endif

	//Verifica a conta corrente e se a mesma não está bloqueada
	NUMCHEQUE:=""
	If lRet .And. MovBcoBx(cMotBx,.T.)
		If !CarregaSa6(@cBco090,@cAge090,@cCta090,.T.,,.T.)
			lRet := .F.
		EndIf
	Endif

	If lRet
		if !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
			NUMCHEQUE := cCheq090
		Endif
	Endif

	If lRet .and. lF090Auto .and. TrazCodMot(cMotBx) == "VEN" .And. nTipoBx == 1 .And. __lMVVENDO .and. Len(aVendor) > 0
		cContrato 	:= aVendor[1]
		cBancoV		:= aVendor[2]
		cAgenciaV	:= aVendor[3]
		cPrefV		:= aVendor[4]
		cNumV	  	:= aVendor[5]
		cParcV		:= aVendor[6]
		cTipV	  	:= aVendor[7]
		dDataVencV	:= aVendor[8]
		nTxAcresV 	:= aVendor[9]
		cNaturV	  	:= aVendor[10]
		nValTitV  	:= aVendor[11]

		If Empty(cContrato) .or. !Fa080Contr(cContrato)
			lRet := .F.
		ElseIf Empty(cNumV)
			lRet := .F.
		ElseIf Empty(cTipV) .or. !Fa080Tip(cTipV) .and. !Fa080NRV(cPrefV,cNumV,cParcV,cTipV)
			lRet := .F.
		ElseIf Empty(cNaturV) .or. !Fa080Nat(cNaturV)
			lRet := .F.
		ElseIf Empty(nTxAcresV)
			lRet := .F.
		ElseIf Empty(dDataVencV) .or. !Fa080DtVen(dDataVencV)
			lRet := .F.
		Endif

		If !lRet
			Help(" " , 1 , "FA080DADVEND")
		Endif

	EndIf

	If lRet .And. !IsBlind() .And. nTipoBx == 1 .And. lBcoExcl .and. MV_PAR07 == 1 .And. MovBcoBx(cMotBx,.T.)
		MsgAlert(STR0177, STR0180) //"Somente serão apresentados os títulos das filiais que tenham um cadastro de banco igual ao escolhido.", "Atenção"
	EndIf

Return lRet


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fa090Cheq
Valida cheque digitado, se digitado é diferente de '*' e se não existe outro com mesmo número

@Param cBanco090	, Character , Código do banco
@Param cAgencia090	, Character , Código da agência
@Param cConta090	, Character , Código do borderô final
@Param cCheq090		, Character , Código do cheque 

@Return lRet	, Logical	, Informa se a validação foi positiva ou não

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function fa090Cheq(cBanco090,cAgencia090,cConta090,cCheq090 )
	Local lRet    := .T.

	lRet := VldUser("EF_NUM") // Chama a validacao de usuario
	If lRet .And. !Empty(cCheq090) .And. Substr(cCheq090,1,1) != "*"
		SEF->(dbSetOrder(1))
		If SEF->( (dbSeek( cFilial + cBanco090 + cAgencia090 + cConta090 + cCheq090 ) ) )
			Help( " ",1,"F090Cheq" )
			lRet := .f.
		Endif
	Endif

Return lRet


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa090bAval
Bloco de marcação

@Param cAliasSe2, Character , Alias utilizado para seleção de títulos
@Param cMarca	, Character , Código da marca do processo
@Param oValor 	, Object	, Objeto para atualização do valor selecionado para baixa
@Param oQtda 	, Object	, Objeto para atualização do numero de registros selecionado para baixa
@Param oMark 	, Object	, Objeto para atualização da marcação
@Param nValor 	, Numeric	, Valor para a validação da marcação

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function Fa090bAval(cAliasSE2,cMarca,oValor,oQtda,oMark,nValor)
	Local lRet	 := .T.
	Local lVld	 := .F.
	Local nRecPA := 0
	Default __lPOSTIT := ExistBlock("F090POSTIT")

	SE2->(dbGoto((cAliasSE2)->NUM_REG))

	lRet:=IIF((cAliasSE2)->E2_OK==cMarca,.T.,FA080Integ(.F.,.T.))
	If lRet
		If (cAliasSE2)->(MsRLock())
			If GetNewPar("MV_VLTITAD",.F.) .And. ( (cAliasSE2)->E2_OK <> cMarca )
				If F090VlMark(.F.,cAliasSE2,cMarca,oValor,oQtda,oMark,nValor)
					lVld := .T.
				Endif
			Else
				lVld := .T.
			Endif
			If lVld
				If SE2->E2_TIPO $ MVPAGANT
					//Verifica se PA possui movimentacao para permitir a baixa
					nRecPA := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
					If nRecPA < 1
						//Verifica se ‚ PA de CNAB (Gera Ch para Adt = N?o / Mov. Banc. sem Cheque = N?o) - Nesse caso deve permitir a baixa para gerar mov. a pagar
						nRecPA := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
						If nRecPA > 0
							lVld := .F.
							IW_MsgBox(STR0172,STR0072,"STOP")  //"N?o ‚ poss¡vel realizar a baixa de pagamento antecipado sem movimenta‡?o banc ria."
						Else
							lVld := .T.
						Endif
					EndIf
				Endif
			EndIf
			If lVld
				Fa090Inverte(cAliasSe2,cMarca,oValor,oQtda,.F.,oMark) // Marca o registro e trava
				lRet := .T.
			Else
				lRet := .F.
			EndIf
		Else
			IW_MsgBox(STR0071,STR0072,"STOP")  //"Este titulo está sendo utilizado em outro terminal, não pode ser utilizado na fatura"###"Atenção"
			lRet := .F.
		EndIf
	EndIf

	If __lPOSTIT
		ExecBlock("F090POSTIT", .F., .F., { cAliasSE2 } )//cAliasSE2
	EndIf

Return lRet


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090VlMark
Bloco de marcação

@Param lGeral	, Logical	, Define se verifica somente registro corrente ou todos registros
@Param cAliasA	, Character , Alias utilizado para seleção de títulos
@Param cMarca	, Character , Código da marca do processo
@Param oValor 	, Object	, Objeto para atualização do valor selecionado para baixa
@Param oQtda 	, Object	, Objeto para atualização do numero de registros selecionado para baixa
@Param oMark 	, Object	, Objeto para atualização da marcação
@Param nValor 	, Numeric	, Valor para a validação da marcação
@Param cProg	, Character	, Código da Rotinas que está chamando

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function F090VlMark(lGeral As Logical, cAliasA As Character, cMarca As Character, oValor As Object, oQtda As Object, oMark As Object, nValor As Numeric, cProg As Character) As Logical
	Local aArea As Array
	Local lMsg As Logical
	Local cMsg As Character
	Local lMarca As Logical
	Local lRet As Logical
	Local lErro As Logical
	Local nPos As Numeric
	Local nBusca As Numeric
	Local nTamMark As Numeric
	Local aLog As Array
	Local lf090log As Logical
	Local lF240 As Logical
	Local cFilBckp As Character
	Local lTemFilOg As Logical
	Local aAreaAlias As Array
	Local aBuscaAD As Array
	Local nPosBusca As Numeric
	Local cDocKey As Character

	Default lGeral := .T. // Define se verifica somente registro corrente ou todos registros
	Default cProg  := "FINA090"

	aArea      := GetArea()
	lMsg       := .F.
	cMsg       := ""
	lMarca     := .F.
	lRet       := .T.
	lErro      := .F.
	nPos       := 1
	nBusca     := 0
	nTamMark   := 0
	aLog       := {}
	lf090log   := ExistBlock("F090LOG")
	lF240      := AllTrim(FunName()) == 'FINA240'
	cFilBckp   := cFilAnt
	lTemFilOg  := .F.
	aAreaAlias := (cAliasA)->(GetArea())
	aBuscaAD   := {}
	nPosBusca  := 0
	cDocKey    := ""

	If __oBillRel == Nil
		If FindFunction("UsaBillRel")
			__oBillRel := UsaBillRel()
		EndIf
	EndIf

	dbSelectArea(cAliasA)
	If "FINA090" $ Upper(Funname())
		dbSetOrder(1)
	Endif

	nTamMark	:= oMark:oBrowse:nLen

	If lGeral
		lMsg := .F.
		(cAliasA)->(DbGoTop())
	Else
		lMsg := .T.
	Endif

	If lGeral
		If MsgYesNo( STR0077 ) //"Gostaria que desmarque os titulos cujo Fornecedor possua Adiantamento ou Devolucao ?"
			lMarca := .T.
		Endif
	Endif

	//Como o alias pode ser um query, temporário, o campo de FILORIG pode não estar presente
	lTemFilOg := (cAliasA)->( ColumnPos( "E2_FILORIG" ) ) > 0

	While .T.

		// Condicao para sair do While - Troca de todos Registros
		If lGeral .And. ( nPos > nTamMark )
			Exit
		Endif

		If lGeral .And. (cAliasA)->E2_OK <> cMarca
			(cAliasA)->(DbSkip())
			nPos++
			Loop
		Endif

		If lTemFilOg
			cFilAnt := Iif( Empty( (cAliasA)->E2_FILORIG ) , cFilAnt , (cAliasA)->E2_FILORIG )
		EndIf
		SE2->(DBGoto( (cAliasA)->NUM_REG ))
		If (cAliasA)->E2_TIPO $ MVINSS
			cDocKey := SE2->E2_TITPAI
			If __oBillRel <> Nil
				cDocKey := __oBillRel:getRelatedBillKey('SE2')
			EndIf

			If !Empty(cDocKey)
				If F090LocINA( cDocKey )
					If lMsg
						cMsg += STR0184	 //"Existem titulos de INSS retidos em pagamentos antecipados ainda pendentes de compensação para este fornecedor, efetua a baixa mesmo assim?"
					EndIf
					lRet := .F.
					nBusca := 9
				Endif
			Endif
		Else
			If lF240 .And. Select("__SE2") == 0
				ChkFile("SE2",.F.,"__SE2")
			EndIf

			nPosBusca := aScan(aBuscaAD, {|x| Alltrim(x[1]+x[2]+x[3]) == Alltrim((cAliasA)->E2_FILIAL+(cAliasA)->E2_FORNECE+(cAliasA)->E2_LOJA)})
			If nPosBusca == 0
				nBusca := F090BuscAD( "__SE2", (cAliasA)->E2_FORNECE, (cAliasA)->E2_LOJA )
				aAdd(aBuscaAD,{(cAliasA)->E2_FILIAL,(cAliasA)->E2_FORNECE,(cAliasA)->E2_LOJA,nBusca} )
			Else
				nBusca := aBuscaAD[nPosBusca][4]
			EndIf

			If lMsg .And. nBusca <> 0
				cMsg := STR0078 //"O Fornecedor para este titulo possui "
			Endif

			Do Case
			Case nBusca == 1 // Adiantamento
				lRet := .F.
				If lMsg
					cMsg += STR0079 //"Adiantamento."
				Endif
			Case nBusca == 2 // Devolucao
				lRet := .F.
				If lMsg
					cMsg += STR0080 //"Devolucao."
				Endif
			Otherwise
				lRet  := .T.
			End Case

		EndIf

		If lGeral .And. nBusca <> 0
			lErro := .T.
			If lMarca .And. (cAliasA)->E2_OK == cMarca .and. (cAliasA)->(MsRLock())
				If cProg == "FINA090"
					Fa090Inverte(cAliasA,cMarca,oValor,oQtda,.F.,oMark)
				ElseIf cProg == "FINA240"
					FA240Inverte(cMarca,oValor,oQtda,.F.,cAliasA)
				Endif
			Endif

			// Adiciona Array de LOG.
			Aadd( aLog, { 	(cAliasA)->E2_PREFIXO, (cAliasA)->E2_NUM    , (cAliasA)->E2_PARCELA, (cAliasA)->E2_TIPO,;
				(cAliasA)->E2_SALDO  , (cAliasA)->E2_FORNECE, (cAliasA)->E2_LOJA} )
		Endif

		// Usuario define se seleciona registro com Adiantamento ou Devolucao.
		If !lRet .And. lMsg
			cMsg += CRLF
			cMsg += STR0081 //"Deseja mesmo assim seleciona-lo ?"
			If MsgYesNo( cMsg )
				lRet := .T.
				If lf090log
					ExecBlock( "F090LOG",.F.,.F.) // Ponto de Entrada para gravação do log.
				EndIf
			Else
				lRet := .F.
			Endif
		Else
			lRet := .T.
		Endif

		(cAliasA)->(DbSkip())
		nPos++

		// Condicao para sair do While - Troca do Registro atual
		If !lGeral
			Exit
		Endif
	Enddo

	cFilAnt := cFilBckp
	RestArea( aArea )
	RestArea( aAreaAlias )

	oValor:Refresh()
	oQtda:Refresh()

	If __oBillRel <> Nil
		FWFreeObj(__oBillRel)
	EndIf
	
	If lGeral
		lVldAD := .T.
		If !lErro
			MsgInfo(STR0082) //"Nao existem titulos selecionados, cujos Fornecedores possuam Adiantamento ou Devolucao."
		Else
			If MsgYesNo( STR0083 ) //"Gostaria de imprimir a lista de titulos cujos Fornecedores possuam Adiantamento ou Devolucao ?"
				F090PrtLog( aLog, cProg )
			Endif
		Endif
	Else
		lVldAD := .F.
	Endif

Return( lRet )


//-------------------------------------------------------------------------
/*/{Protheus.doc} F090BuscAD
Funcao que Busca para o fornecedor passado se existem Adiantamentos ou devolucoes 

@Param cAliasB	, Character , Alias utilizado para seleção de títulos
@Param cFor		, Character , Fornecedor
@Param cLoj		, Character , Loja

@Return nRet	, Numeric	, Número de adiantamentos existentes para
								o fornecedor

@author Mauricio Pequim Jr
@since  07/10/2021
@version 12.1.30
/*/
//-------------------------------------------------------------------------
Function F090BuscAD( cAliasB As Character, cFor As Character, cLj As Character ) As Numeric
	Local aArBusca		As Array
	Local nRet			As Numeric
	Local cIndexC		As Character
	Local cCondicao1	As Character
	Local cKey1  	 	As Character
	Local lMultFil		As Logical
	Local nIndexC		As Numeric
	Local cFilter		As Character
	Local lFiliais		As Logical
	Local lPaBx			As Logical
	Local nRegB			As Numeric
	Local cCompSE2	    As Character
	Local cCompSA2	    As Character
	Local aIndReg		As Array
	Local cChave		As Character

	Default cAliasB		:= ""
	Default cFor		:= ""
	Default cLj 		:= ""

	aArBusca			:= GetArea()
	nRet				:= 0
	cIndexC				:= ""
	cCondicao1			:= ""
	cKey1  	 			:= ""
	lMultFil			:= .F.
	nIndexC				:= 0
	cFilter				:= ""
	lFiliais			:= FunName() $ "FINA240|FINA090" //Utilizado pelas rotinas que possuem conceito de multi-filiais
	lPaBx				:= .F.
	nRegB				:= 0
	cCompSE2	    	:= FwModeAcces("SE2",1)
	cCompSA2	    	:= FwModeAcces("SA2",1)
	aIndReg				:= {}
	cChave				:= ""

	If Select(cAliasB) <= 0
		SomaAbat("","","","P")
	EndIf

	If __lFILTABT = NIL
		__lFILTABT	:= ExistBlock("F090ADFR")
		__lPAsBX	:= ExistBlock("F090PABX")
	Endif

	nRegB := (cAliasB)->(Recno())
	If !Empty(cAliasB) .And. !Empty(cFor) .And. !Empty(cLj)

		cFilter := (cAliasB)->(DbFilter())

		//-----------------------F090PABX----------------------------
		// Ponto de entrada utilizado para verificação da existência
		// de títulos do tipo PA de um determinado fornecedor
		// sem considerar a loja.
		//-----------------------------------------------------------
		If __lPAsBX
			lPaBx := ExecBlock("F090PABX",.F.,.F.)
		EndIf

		dbSelectArea(cAliasB)
		dbSetOrder(6)
		If dbSeek( xFilial("SE2")+ cFor + cLj )
			cIndexC := CriaTrab(nil,.f.)
			If !lFiliais
				cCondicao1 	:= "(E2_TIPO $ '"+MV_CPNEG + "/" + MVPAGANT+ "')"
				cCondicao1 	+= ' .AND. E2_SALDO > 0 '

				cKey1	   	:= "E2_FILIAL+E2_FORNECE"+iif(!lpaBx,"+E2_LOJA","")
				cChave 		:= xFilial("SE2")+cFor+iif(!lpaBx,cLj,"")
			Else
				cCondicao1 	:= "E2_FILIAL >= '  ' .And. E2_FILIAL <= 'ZZ' .And. "
				cCondicao1 	+= "(E2_TIPO $ '"+MV_CPNEG + "/" + MVPAGANT+ "')"
				cCondicao1 	+= ' .AND. E2_SALDO > 0 '

				cKey1	   	:= "E2_FORNECE"+iif(!lpaBx,"+E2_LOJA","")
				cChave 		:= cFor+iif(!lpaBx,cLj,"")
			EndIf

			//-----------------------F090ADFR----------------------------
			// Ponto de Entrada para manipulação o filtro que
			// seleciona os registros de abatimentos do fornecedor.
			//-----------------------------------------------------------
			If __lFILTABT
				aIndReg := ExecBlock("F090ADFR", .F., .F., {cCondicao1,lMultFil})
				if len(aIndReg) > 1
					cCondicao1 := aIndReg[1]
					lMultFil := aIndReg[2]

					cKey1	:= iif(!lMultFil,"E2_FILIAL+"  ,"")	+"E2_FORNECE"	+iif(!lpaBx,"+E2_LOJA","")
					cChave 	:= iif(!lMultFil,xFilial("SE2"),"")	+cFor			+iif(!lpaBx,cLj,"")
				endif
			EndIf

			IndRegua(cAliasB,cIndexC,cKey1,,cCondicao1,STR0025) //"Selecionando Registros..."
			nIndexC := RetIndex("SE2",cAliasB)
			dbSelectArea(cAliasB)
			dbSetOrder(nIndexC + 1 )

			(cAliasB)->(dbSeek(cChave))

			While (cAliasB)->(!Eof()) .And. cChave == (cAliasB)->(&cKey1)
				// So Processa titulos
				// com saldo
				If (cAliasB)->E2_SALDO <= 0
					dbSkip()
					Loop
				Endif

				// Adiantamento
				If (cAliasB)->E2_TIPO $ MVPAGANT
					If cCompSE2 != cCompSA2 .And. xFilial("SE2") != (cAliasB)->E2_FILIAL .And. !lMultFil
						nRet := 0
					Else
						nRet := 1
					EndIf
				Endif

				// Devolucao
				If (cAliasB)->E2_TIPO $ MV_CPNEG
					nRet := 2
				Endif

				// Adiantamentos já relacionados com Pedidos
				if FinAdtSld("P", SE2->( (cAliasB)->(E2_FORNECE + E2_LOJA + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO) ))
					nRet := 0
				Endif

				If nRet <> 0
					Exit
				Endif

				(cAliasB)->(DbSkip())
			EndDo
		EndIf
	EndIf

	//-----------------------------------------------------------
	// Recupera a Integridade dos dados
	//-----------------------------------------------------------
	RetIndex("SE2",cAliasB)
	DbSelectArea(cAliasB)
	Set Filter to &cFilter
	(cAliasB)->(DbGoTo(nRegB))
	RestArea( aArBusca )
	FwFreeArray(aArBusca)
	FwFreeArray(aIndReg)

Return( nRet )


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090PrtLog
Imprime array com informacoes dos titulos cujos Fornecedores possuem Adiantamentos ou Devolucoes.

@Param aPrtLog	, Array		, Array com o Log a ser impresso
@Param cProg	, Character	, Código da Rotinas que está chamando

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function F090PrtLog( aPrtLog, cProg )

	Local cDesc1	:= STR0084 //"Imprime relacao de titulos selecionados para baixa, "
	Local cDesc2	:= STR0085 //"cujos Fornecedores possuam Adiantamento ou Devolucao."
	Local cDesc3	:= ""
	Local titulo	:= STR0086 //"Tit. com Adiantamento ou Devolucao."
	Local nLin		:= 80
	Local Cabec1	:= PadR("Prefixo", 8 ) + PadR("Numero", 15) + PadR("Parcela", 10 ) + PadR("Tipo", 17 ) + ;
		PadR("Valor", 20) + " - " + PadR("Fornecedor", 15 ) + PadR("Loja", 4)
	Local Cabec2	:= ""
	Local aOrd 		:= {}

	Private lEnd		:= .F.
	Private lAbortPrint	:= .F.
	Private limite		:= 80
	Private tamanho		:= "M"
	Private nomeprog	:= cProg
	Private nTipo		:= 18
	Private aReturn		:= { "Zebrado", 1, "Administracao", 2, 2, 1, "", 1 }
	Private nLastKey	:= 0
	Private cbtxt		:= Space(10)
	Private cbcont		:= 00
	Private CONTFL		:= 01
	Private m_pag		:= 01
	Private wnrel		:= nomeprog
	Private cString 	:= ""

	wnrel := SetPrint( cString, NomeProg, "", @titulo, 		cDesc1, cDesc2, cDesc3, .T., aOrd, .T., Tamanho, , .T. )

	If nLastKey == 27
		Return
	EndIf

	SetDefault( aReturn, cString)

	If nLastKey == 27
		Return
	Endif

	nTipo := If( aReturn[4] == 1, 15, 18 )

	RptStatus({|| RunReport(Cabec1,Cabec2,Titulo,nLin,aPrtLog) },Titulo)
Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RunReport
Imprime o relatório

@Param Cabec1	, Character	, Cabeçalho 1 do relatório
@Param Cabec2	, Character	, Cabeçalho 2 do relatório
@Param Titulo	, Character	, Titulo do relatório
@Param nLin		, Numérico	, Número de linhas por página
@Param aPL		, Array		, Array com o Log a ser impresso

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function RunReport(Cabec1,Cabec2,Titulo,nLin,aPL)

	Local nP		:= 0
	Local nTamLog	:= Len(aPL)
	Local cPict		:= PesqPict("SE2","E2_SALDO")

	SetRegua( nTamLog )

	For nP := 1 To nTamLog

		// Verifica o cancelamento pelo usuario...
		If lAbortPrint
			@nLin,00 PSAY STR0087 //"*** CANCELADO PELO OPERADOR ***"
			Exit
		Endif

		// Impressao do cabecalho do relatorio.
		If nLin > 55 // Salto de Página. Neste caso o formulario tem 55 linhas...
			Cabec(Titulo,Cabec1,Cabec2,NomeProg,Tamanho,nTipo)
			nLin := 8
		Endif

		@ nLin,01 PSAY aPL[nP][1] // Prefixo (8)
		@ nLin,08 PSAY aPL[nP][2] // Numero Tit (15)
		@ nLin,23 PSAY aPL[nP][3] // Parcela (10)
		@ nLin,33 PSAY aPL[nP][4] // Tipo (5)
		@ nLin,38 PSAY aPL[nP][5] Picture cPict // Saldo (20)
		@ nLin,58 PSAY " - "
		@ nLin,61 PSAY aPL[nP][6] // Fornecedor (15)
		@ nLin,76 PSAY aPL[nP][7] // Loja Fornecedor (4)

		nLin := nLin + 1 // Avanca a linha de impressao

	Next nP

	SET DEVICE TO SCREEN

	If aReturn[5]==1
		dbCommitAll()
		SET PRINTER TO
		OurSpool(wnrel)
	Endif

	MS_FLUSH()

Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fa090CX
Funcao que abre ou não o get do nro de cheque na baixa

@Param cBanco	, Character	, Banco
@Param lBord	, Logical	, Informa se é uma baixa de Borderô

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function fa090CX(cBanco, lBord)
	Local lRet := .T.
	Default __cMVCARTE := GetMv("MV_CARTEIR")
	// Nao habilita o numero de cheque para :
	// Banco Caixa, Carteira ou Motivo igual a D‚bito em C/C
	If SubStr(cBanco,1,2) == "CX"  	     .or. ;
			cBanco $ __cMVCARTE			     .or. ;
			TrazCodMot(cMotBx) $ "DEB/DAC"   .or. ;
			! ChqMotBx(cMotBx)				 .or. ;
			(lBord .And. GetMv("MV_CHQBOR") == "N")
		lRet := .F.
	Endif
Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de menu Funcional

Parametros do array aRotina
1. Nome a aparecer no cabecalho
2. Nome da Rotina associada
3. Reservado
4. Tipo de Transação a ser efetuada:
	1 - Pesquisa e Posiciona em um Banco de Dados
	2 - Simplesmente Mostra os Campos
	3 - Inclui registros no Bancos de Dados
	4 - Altera o registro corrente
	5 - Remove o registro corrente do Banco de Dados
5. Nivel de acesso
6. Habilita Menu Funcional

@author Ana Paula N. Silva
@version P12
@since   29/11/2006
@return  Array com opcoes da rotina.
/*/
//-------------------------------------------------------------------
Static Function MenuDef()
	Local aRotina := {}
	If cPaisLoc == "BRA"
		aRotina	:=	{	{ STR0057, "AxPesqui"   ,0,1,,.F.},;	// "Pesquisar"
		{ STR0001,"fA090Par"    ,0,1},;  		// "Parƒmetros"
		{ STR0002,"fA090Aut"    ,0,3},;			// "Autom tica"
		{ STR0136,"FA090CAUT"   ,0,5},;			// "Cancelamento Automático de Baixas"
		{ STR0134,"CTBC662"     ,0,7},;			// "Tracker Contábil"
		{ STR0061,"FA040Legenda",0,6, ,.F.} }
	Else
		aRotina	:=	{	{ STR0057,"fA090Busca"	,0,1,,.F.},;	// "Pesquisar"
		{ STR0001,"fA090Par"	,0,1},;			// "Parƒmetros"
		{ STR0002,"fA090Aut"	,0,3},;			// "Autom tica"
		{ STR0058,"fA090Can"	,0,2},;			// "Cancela Chq"
		{ STR0136,"FA090CAUT"   ,0,5},;			// "Cancelamento Automático de Baixas"
		{ STR0134,"CTBC662"     ,0,7},;			// "Tracker Contábil"
		{ STR0061,"FA040Legenda",0,6, ,.F.} }	// "Legenda"
	EndIf
	//Rateio Multinatureza
	If FindFunction("F050CMNT") .and. MV_MULNATP
		aAdd( aRotina,	{ STR0162 ,"F050CMNT()", 0 , 2})	//"Consulta Rateio Multi Naturezas"
	Endif

	If cPaisLoc == "BRA"
		Aadd(aRotina, {STR0178,"FINCRET('SE2')", 0, 2}) //'Consulta de Retenções'
	EndIF

Return(aRotina)


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA090PcoLan
Verifica e efetua o bloqueio na confirmacao da tela de baixa automatica, se utilizada a integracao 
e configuracao de lancamento de bloqueio do SIGAPCO.

@Param cMarca	, Character	, Indica que o titulo/bordero esta marcado


@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function FA090PcoLan(cMarca)

	Local lRet	:= .T.
	Local aArea := GetArea()
	Default __lUsaPCO	:= SuperGetMV("MV_PCOINTE",.F.,"2") =="1"

	If __lUsaPCO
		(cAliasSE2)->(dbSetOrder(__nIdxE2OK))
		(cAliasSE2)->(dbSeek(cMarca))
		SE2->(DBGOTO((caliasSE2)->NUM_REG))

		Do While (cAliasSE2)->(!Eof() .AND. E2_OK == cMarca)
			SE2->(DBGOTO((caliasSE2)->NUM_REG))
			RegToMemory("SE2",.F.)
			lRet := PcoVldLan("000006","01","FINA090")
			If !lRet
				Exit
			EndIf
			(cAliasSE2)->(dbSkip())
		EndDo

		RestArea( aArea )
	Endif

Return lRet


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinA090T
Chamada semi-automatica utilizado pelo gestor financeiro

@Param aParam	, Array	, Parametros da rotina

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function FinA090T(aParam)
	cRotinaExec := "FINA090"
	ReCreateBrow("SE2",FinWindow)
	FinA090(aParam[1])
	ReCreateBrow("SE2",FinWindow)
	dbSelectArea("SE2")

	INCLUI := .F.
	ALTERA := .F.

Return .T.


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fa090BcoCx
Correção do número de cheque para banco caixa

@Param cBco090	, Character , Código do banco
@Param cAge090	, Character , Código da agência
@Param cCta090	, Character , Código do borderô final
@Param cCheq090	, Character , Código do cheque 

@Return lRet	, Logical	, Informa se a validação foi positiva ou não

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function fa090BcoCx(cBco090, cAge090, cCta090, cCheq090)

	Local lRet := .T.
	Default __lBcoOk	:= ExistBlock("FA090BCO")
	Default __cMVCARTE  := GetMv("MV_CARTEIR")

	If SubStr(cBco090,1,2) == "CX" .or. cBco090 $ __cMVCARTE
		cCheq090 := Space(15)
		If Type("oCheque")=="O"
			oCheq090:Refresh()
		Endif
	Endif

	If __lBcoOk
		lRet := ExecBlock("FA090BCO", .F., .F., {cBco090,cAge090,cCta090})
	Endif

Return lRet


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} VldBanco
Valida se o motivo de baixa gera movimento bancário.
Caso não gere, limpa os campos 

@Param cMotBx	, Character , Motivo da Baixa
@Param cBco090	, Character , Código do banco
@Param cAge090	, Character , Código da agência
@Param cCta090	, Character , Código do borderô final
@Param cCheq090	, Character , Código do cheque 

@Return lRet	, Logical	, Informa se a validação foi positiva ou não

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function VldBanco( cMotBx, cBco090, cAge090, cCta090 )

	Local lReturn := MovBcoBx(cMotBx,.T.)

	If !lReturn
		cBco090 := CriaVar( "A6_COD"     )
		cAge090 := CriaVar( "A6_AGENCIA" )
		cCta090 := CriaVar( "A6_NUMCON"  )
	EndIf
Return lReturn


//-------------------------------------------------------------------
/*/{Protheus.doc} Fa090Juri(lTodos, lPrimeiro)
Rotina para verifica se tem integracao com o SIGAPFS e realiza
realiza as validacoes da integracao.

@param lTodos    Se .T. indica se foi precionada a opção de selecionar todos os título
@param lPrimeiro  Quando encontrar o primeiro título que não atenda a validação e
					exibir a mensagem, retorna por referencia que não serão exibidas
					novas mensagens caso ocorram inconsistencias nos próximos títulos.

@Return lRet   .T. Se o título é valido para ser manipulado.

@author Luciano Pereira dos Santos
@since 09/10/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function Fa090Juri(lTodos, lPrimeiro)
	Local lRet      := .T.

	Default lTodos    := .F.
	Default lPrimeiro := .T.
	Default __lMVJURFI := SuperGetMv("MV_JURXFIN",.T.,.F.)

	If __lMVJURFI .And. FindFunction("JVldBxPag")
		lRet := JVldBxPag(SE2->(RECNO()), lTodos, @lPrimeiro)
	EndIf

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} F090IsCaixa
Rotina para montar string com os códigos dos caixas do SIGALOJA,
Financeiro e bancos Carteira

@Return cStringCX   String contendo os códigos dos caixas

@author pequim
@since 20/10/2021
@version 1.0
/*/
//-------------------------------------------------------------------
Function F090IsCaixa(lFormatIN as Logical)

	Local nX AS Numeric
	Local nLen23 AS Numeric
	Local cMV_CXFIN AS Character
	Local cStringCX AS Character

	DEFAULT lFormatIN := .F.
	DEFAULT __cMVCARTE := GetMv("MV_CARTEIR")

	nX := 0
	nLen23 := 0

	cStringCX := ""

	If __aTab23 == NIL
		__aTab23 := FWGetSX5("23")
	Endif

	nLen23 := Len(__aTab23)

	For nX := 1 to nLen23
		cStringCX += Substr(__aTab23[nX,3],1,3)
		If nX != nLen23
			cStringCX += "/"
		Endif
	Next

	cMV_CXFIN 	:= Left(SuperGetMV("MV_CXFIN"),TamSX3("A6_COD")[1])

	If !Empty(cMV_CXFIN)
		cStringCX += "/" + cMV_CXFIN
	Endif

	If !Empty(__cMVCARTE)
		cStringCX += "/" + __cMVCARTE
	Endif

	cStringCX := F90FORMATIN( cStringCX, lFormatIN )

Return cStringCX


//-------------------------------------------------------------------
/*/{Protheus.doc} FA090StChq
Filtro p/ Mbrowse do Controle de Cheques.  
Equador/Rep. Dominicana/Argentina

@author Wagner Montenegro
@since 30/09/2010
@version 1.0
/*/
//-------------------------------------------------------------------
Function FA090StChq(cBusca)
	Local lRet := .F.
	Local nOrdSEF:=SEF->(IndexOrd())
	SEF->(DbSetOrder(6))
	If SEF->(DBSeek(cBusca))
		If SEF->EF_IMPRESS=="S" .AND. (SEF->EF_STATUS=="03" .OR. SEF->EF_STATUS=="01")
			lRet:=.T.
		Endif
	Endif
	SEF->(DbSetOrder(nOrdSEF))

Return(lRet)


//-------------------------------------------------------------------
/*/{Protheus.doc} FA090VldMt
Validação dos Motivos de Cancelamento do Cheque 
Equador/Rep. Dominicana/Argentina

@author Wagner Montenegro
@since 30/09/2010
@version 1.0
/*/
//-------------------------------------------------------------------
Function FA090VldMt(nRecOld,lAnular)
	Local lRet :=.F.
	Local nRegMot:=SEF->(Recno())
	Local cInfoForn:="."
	Local aFina050:={}
	SEF->(DbGoTo(nRecOld))
	If SEF->EF_STATUS $ "01|04"
		If cChvLbx $ "11/12"
			If FRF->(DbSeek(xFilial("FRF")+SEF->EF_BANCO+SEF->EF_AGENCIA+SEF->EF_CONTA+SEF->EF_PREFIXO+SEF->EF_NUM+cChvLbx))
				MsgAlert(STR0103+cChvLbx+STR0104) //"O motivo '"+cChvLbx+"' já foi registrado para este cheque."
			Else
				If cChvLbx $ "12"
					If FRF->(DbSeek(xFilial("FRF")+SEF->EF_BANCO+SEF->EF_AGENCIA+SEF->EF_CONTA+SEF->EF_PREFIXO+SEF->EF_NUM+"11"))
						If cPaisLoc != "BRA" .and. lAnular
							SA2->(DbSetOrder(1))
							If SA2->(DbSeek(xFilial("SA2")+SEF->EF_FORNECE+SEF->EF_LOJA))
								cInfoForn:="["+SA2->A2_COD+"-"+SA2->A2_LOJA+" "+Rtrim(SA2->A2_NOME)+"]."
							Endif
							Help(" ",1,"HELP",STR0127,STR0128+cInfoForn,1,0)//"FA090 - DEVOLUCAO CHEQUE"   //"O cancelamento deste cheque gera automaticamente uma NDI a favor do fornecedor"
							If MsgYesNo(STR0129) //"Confirma a geração de NDI?"
								aAdd(aFina050,  {"E2_PREFIXO" , GetMv("MV_FINPXE2")  , Nil})
								aAdd(aFina050,  {"E2_NUM"     ,"" , Nil})//GetSx8Num("SE2","FINPRDB")    , Nil})
								aAdd(aFina050,  {"E2_TIPO"    , 'NDI'           , Nil})
								aAdd(aFina050,  {"E2_NATUREZ" , SEF->EF_NATUR   , Nil})
								aAdd(aFina050,  {"E2_FORNECE" , SA2->A2_COD		, Nil})
								aAdd(aFina050,  {"E2_LOJA"    , SA2->A2_LOJA    , Nil})
								aAdd(aFina050,  {"E2_EMISSAO" , dDataBase 		, Nil})
								aAdd(aFina050,  {"E2_VENCTO"  , dDataBase			, Nil})
								aAdd(aFina050,  {"E2_VALOR"   , SEF->EF_VALOR   , Nil})
								aAdd(aFina050,  {"E2_VLCRUZ"  , SEF->EF_VALOR   , Nil})
								aAdd(aFina050,  {"E2_ORIGEM"  , "FINA095"		   , Nil})
								aAdd(aDados050,aFina050)
								lRet:=.T.
							Endif
						Else
							lRet:=.T.
						Endif
					Else
						MsgAlert(STR0105) //"O motivo '11' não consta para este cheque"
					Endif
				Else
					lRet:=.T.
				Endif
			Endif
		Else
			lRet:=.T.
		Endif
	Else
		lRet:=.T.
	Endif
	SEF->(DbGoTo(nRegMot))
	lTOk:=lRet
Return(lRet)


//-------------------------------------------------------------------
/*/{Protheus.doc} F090NLOTE
Verificar a chamada do ponto de entrada F090NLOTE   

@Param nTipoBx	, Numeric	, Tipo de Baix: 1 = Título ou 2 = Borderô
@Param cBord090I, Character , Código do borderô inicial
@Param cBord090F, Character , Código do borderô final

@author Leandro Sousa
@since 30/09/2010
@version 1.0
/*/
//-------------------------------------------------------------------
Function F090NLOTE(nTipoBx,cBord090I,cBord090F)
	Local lF090NLote := ExistBlock ("F090NLOTE")

	IF lF090NLote
		ExecBlock ("F090NLOTE",.F.,.F.,{nTipoBx,cBord090I,cBord090F})
	EndIf

Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} F090CHQOK
Ponto de entrada para a confirmaçao da baixas automaticas 
ao utilizar o botao ok da tela de seleçao dos titulos.

@author Leandro Sousa
@since 30/09/2010
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function F090CHQOK()
	Local lF090CHOK := ExistBlock("F090CHOK")
	Local lRetorno  := .T.

	If lF090CHOK
		lRetorno := ExecBlock("F090CHOK",.F.,.F.)
	Endif

Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} F090NLOTE
Ponto de entrada para a confirmaçao da baixas automaticas 
ao utilizar o botao ok da tela de seleçao dos titulos.

@author Leandro Sousa
@since 30/09/2010
@version 1.0
/*/
//-------------------------------------------------------------------
Function FA090TPCH(cChave)

	Local aArea := GetArea()
	Local aAreaFRE := {}
	Local cRetorno := "1"

	DbSelectArea("FRE")

	aAreaFRE := FRE->(GetArea())

	FRE->(DbSetOrder(3)) //FRE_FILIAL+FRE_BANCO+FRE_AGENCI+FRE_CONTA+FRE_TALAO
	If FRE->(DbSeek(xFilial("FRE")+cChave))
		cRetorno := FRE->FRE_TIPO
	EndIf

	RestArea(aArea)
	RestArea(aAreaFRE)

Return cRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} F090LocINA
Funcao que Busca para o titulo passado se existem 
Adiantamentos de INSS

@author Andre Lago
@since 14/05/2012
@version 1.0
@params cPai, Character, titulo para pesquisa
/*/
//-------------------------------------------------------------------
Function F090LocINA(cPai)
	Local aArBusca	As Array
	Local aSE2 	 	As Array
	Local lRet		As Logical
	Local cQry		As Character
	Local lFiliais	As Logical    //Utilizado pelas rotinas que possuem conceito de multi-filiais
	Local cFor	    As Character
	Local cLj 	    As Character
	Local nI		As Numeric
	Local cTblTmp	As Character

	Default cPai	:= ""

	aArBusca := GetArea()
	aSE2 	 := SE2->(GetArea())
	lRet	 := .F.
	cQry	 := ""
	lFiliais := FunName() $ "FINA240|FINA090"
	cFor	 := ""
	cLj 	 := ""
	nI		 := 0
	cTblTmp	 := ""

	If !Empty(cPai)

		dbSelectArea("SE2")
		dbSetOrder(1)
		If dbSeek( xFilial("SE2")+cPai )
			cFor := SE2->E2_FORNECE
			cLj  := SE2->E2_LOJA

			If __oTemINA == Nil
				cQry := "SELECT SE2.E2_FILIAL, SE2.E2_PREFIXO, SE2.E2_NUM, SE2.E2_PARCELA, SE2.E2_TIPO, SE2.E2_FORNECE, SE2.E2_LOJA, SE2.E2_PARCINS, SE2.E2_SALDO FROM " + RetSqlName("SE2") + " SE2 "
				cQry += "INNER JOIN " + RetSqlName("SE2") + " SE2A ON "
				cQry += "SE2.E2_FILIAL = SE2A.E2_FILIAL AND "
				cQry += "SE2.E2_PREFIXO = SE2.E2_PREFIXO AND "
				cQry += "SE2.E2_NUM = SE2A.E2_NUM AND "
				cQry += "SE2.E2_PARCINS = SE2A.E2_PARCELA "
				cQry += "WHERE "
				If !lFiliais
					cQry += "SE2.E2_FILIAL = ? AND "
				EndIf
				cQry += "SE2.E2_FORNECE = ? AND "
				cQry += "SE2.E2_LOJA = ? AND "
				cQry += "SE2.E2_INSS > 0 AND "
				cQry += "SE2.E2_SALDO > 0 AND "
				cQry += "SE2.E2_TIPO IN " + F90FORMATIN(MVPAGANT+"/"+MV_CPNEG) + " AND "
				cQry += "SE2A.E2_TIPO = 'INA' AND "
				cQry += "SE2A.E2_SALDO > 0 AND "
				cQry += "SE2.D_E_L_E_T_ = ' ' AND "
				cQry += "SE2A.D_E_L_E_T_ = ' ' "

				cQry := ChangeQuery(cQry)
				__oTemINA := FWPreparedStatement():New(cQry)
			EndIf

			nI := 1
			If !lFiliais
				__oTemINA:SetString(nI,xFilial("SE2",SE2->E2_FILORIG) )
				nI++
			Endif
			__oTemINA:SetString(nI, cFor)
			nI++
			__oTemINA:SetString(nI, cLj)

			cQry := __oTemINA:GetFixQuery()
			cTblTmp := MpSysOpenQuery(cQry)

			If (cTblTmp)->(!Eof())
				lRet := .T.
			EndIf

			(cTblTmp)->(dbCloseArea())
		EndIf
	EndIf

	// Recupera a Integridade dos dados
	RestArea(aSE2)
	RestArea(aArBusca)
	FwFreeArray(aSE2)
	FwFreeArray(aArBusca)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F090PagINA
Funcao que Busca para o titulo passado se existem Movimentos 
bancarios para os Adiantamentos de INSS

@author Andre Lago
@since 14/05/2012
@version 1.0
/*/
//-------------------------------------------------------------------
Function F090PagINA( cPai )

	Local aArBusca	:= GetArea()
	Local lRet		:= .F.
	Local cAliasB   := "SE5"

	Default cPai	:= ""

	If !Empty(cPai)

		dbSelectArea(cAliasB)
		dbSetOrder(7)
		dbSeek( cPai )

		While !Eof() .And. cPai == (cAliasB)->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA )

			If TemBxCanc((cAliasB)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ))
				(cAliasB)->(Dbskip())
				Loop
			Endif
			lRet := ((cAliasB)->E5_RECPAG == "P" .and. (cAliasB)->E5_SITUACA <> "C")
			If lRet
				Exit
			EndIf
			dbSkip()

		EndDo

	EndIf

	RestArea( aArBusca )

Return( lRet )


//-------------------------------------------------------------------
/*/{Protheus.doc} RetPCC241
Rotina para verificar se o bordero baixado ja possui retencao 
via FINA241, com registro E5_MOTBX = 'PCC'.
Neste caso o registro SE5 deve constar como ja retido em bordero (4)

@author Clovis Magenta
@since 22/02/2013
@version 1.0
/*/
//-------------------------------------------------------------------
Function RetPCC241( cSequencia , cNumBor )
	Local aArea		:= GetArea()
	Local lAchou	:= .F.
	Local xSeqAnt	:= Val(cSequencia)-1
	Local cQuery 	:= ""

	xSeqAnt	:= Strzero(xSeqAnt, TamSx3("E5_SEQ")[1] )

	If __oPrepare == nil

		cQuery 	:= " SELECT E5_DOCUMEN FROM "+RetSqlName("SE5")+" WHERE "
		cQuery 	+= " E5_DOCUMEN = ? "
		cQuery 	+= " AND E5_MOTBX = ? "
		cQuery 	+= " AND E5_PREFIXO = ?"
		cQuery 	+= " AND E5_NUMERO = ? "
		cQuery 	+= " AND E5_PARCELA = ?"
		cQuery 	+= " AND E5_CLIFOR = ?"
		cQuery 	+= " AND E5_LOJA = ?"
		cQuery 	+= " AND E5_TIPO = ? "
		cQuery 	+= " AND E5_SITUACA != ?"
		cQuery 	+= " AND E5_SEQ = ?"
		cQuery 	+= " AND (E5_PRETPIS = ? OR E5_PRETCSL = ? OR E5_PRETCOF = ?)"
		cQuery 	+= " AND E5_FILORIG = ? "
		cQuery 	+= " AND D_E_L_E_T_=' ' "
		cQuery 	:= ChangeQuery(cQuery)
		__oPrepare:=FWPreparedStatement():New(cQuery)
	Endif

	__oPrepare:SetString(1,cNumBor)
	__oPrepare:SetString(2,"PCC")
	__oPrepare:SetString(3,SE2->E2_PREFIXO)
	__oPrepare:SetString(4,SE2->E2_NUM)
	__oPrepare:SetString(5,SE2->E2_PARCELA)
	__oPrepare:SetString(6,SE2->E2_FORNECE)
	__oPrepare:SetString(7,SE2->E2_LOJA)
	__oPrepare:SetString(8,SE2->E2_TIPO)
	__oPrepare:SetString(9,"C")
	__oPrepare:SetString(10,xSeqAnt)
	__oPrepare:SetString(11,"4")
	__oPrepare:SetString(12,"4")
	__oPrepare:SetString(13,"4")
	__oPrepare:SetString(14,SE2->E2_FILORIG)
	cQuery:=__oPrepare:GetFixQuery()

	lAchou := !Empty(MpSysExecScalar(cQuery,"E5_DOCUMEN"))
	RestArea(aArea)

Return lAchou


//-------------------------------------------------------------------
/*/{Protheus.doc} F090RcSE5
Retorna o RecNo do título principal conforme array populado
caso contrário retorna  posição da SE5 se a mesma estiver posicionada

@author Daniel Mendes
@since 31/10/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function F090RcSE5(aRecNosSE5)
	Local nRecSE5 := 0

	If !Empty( aRecNosSE5 )
		nRecSE5 := aRecNosSE5[ Len( aRecNosSE5 ) ]
	Else
		If !SE5->(Eof()) .And. !SE5->(Bof())
			nRecSE5 := SE5->(RecNo())
		EndIf
	EndIf

Return nRecSE5


//-------------------------------------------------------------------
/*/{Protheus.doc} DtValVcto
Funcion para validar fecha de vencimiento.   

@author Ivan Michael Gomez
@since 22/08/2016 
@version 1.0
/*/
//-------------------------------------------------------------------
Function DtValVcto(dDtVctoSub)

	If dDtVctoSub > Ddatabase + 360
		dDtVctoSub = dDataBase + 1
		MsgAlert(STR0158) //"La fecha de Vencimiento no puede exceder los 360 días de la fecha de emisión"
		lTipo := .F.
	ElseIf dDtVctoSub < dDataBase + 1
		dDtVctoSub = dDataBase + 1
		MsgAlert(STR0157) //"La fecha de Vencimiento debe ser mayor a la Fecha de emisión"
		lTipo := .F.
	Else
		lTipo := .T.
	EndIf

Return lTipo


//-------------------------------------------------------------------
/*/{Protheus.doc} f091QryA

Faz a query de filtro dos titulos

@author Karen Honda
@since 22/09/2017
@version P12
/*/
//-------------------------------------------------------------------
Static Function F090QryA(aSelFil,aTMPFil,aCampos,aEstruct,nTipoBX,cBord090I,cBord090F,cBco090,cAge090,cCta090)

	Local cQuery := ""
	Local cFiltro := ''

	DEFAULT aEstruct := {}
	IF !EMPTY(aEstruct)
		// Constroi a clausula de filtro da seleção
		cFiltro := FA090ChecF(nTipoBx,cBord090I,cBord090F,aSelFil,aTMPFil,cBco090,cAge090,cCta090)
		cQuery  := "SELECT "
		aEval(aEstruct,{|x| cQuery += x[1] + ", "})
		If cPaisLoc = "ARG"
			cQuery += "SE2.R_E_C_N_O_ NUM_REG "
			cQuery += "FROM " + RetSqlName("SE2") + " SE2 "
			cQuery += "INNER JOIN " + RetSqlName("SEF") + " ON E2_PREFIXO||E2_NUM = EF_PREFIXO||EF_NUM AND E2_BCOCHQ||E2_AGECHQ||E2_CTACHQ = EF_BANCO||EF_AGENCIA||EF_CONTA "
			cQuery += "WHERE "
			cQuery += "SE2.D_E_L_E_T_ = ' ' AND "
		Else
			cQuery += "R_E_C_N_O_ NUM_REG "
			cQuery += "FROM " + RetSqlName("SE2") + " "
			cQuery += "WHERE "
			cQuery += "D_E_L_E_T_ = ' ' AND "
		EndIf
		cQuery += cFiltro + " "
		If cPaisLoc = "ARG"
			cQuery += "AND EF_STATUS = '03'"
		Endif
		cQuery += "ORDER BY " + SqlOrder(SE2->(indexkey()))
		cQuery := ChangeQuery(cQuery)

		cArqNew := F090MTTMP(cQuery,aCampos,aEstruct,cBord090I,cBord090F,@cBco090,@cAge090,@cCta090,nTipoBx)
	ENDIF

Return cArqNew

//-------------------------------------------------------------------
/*/{Protheus.doc} F090MTTMP

Monta a temporaria da query

@author Karen Honda
@since 22/09/2017
@version P12
/*/
//-------------------------------------------------------------------
Static Function F090MTTMP(cQuery,aCampos,aEstruct,cBord090I,cBord090F,cBco090,cAge090,cCta090,nTipoBx)

	Local nTcSql		:= 0
	Local aArea			:= GetArea()
	Local cQuery2		:= ''
	Local cCampos		:= ''
	Local cChave		:= ""
	Local nTamEFNUM		:= TamSX3('EF_NUM')[1]

	DEFAULT nTipoBx  	:= 1
	DEFAULT cBord090I	:= ""
	DEFAULT cBord090F	:= ""
	DEFAULT __F090VLEX  := ExistBlock("F090VLEX")
	DEFAULT __lTemMR	:= FTemMotor()

	If aScan(aEstruct, {|x| Alltrim(UPPER(x[1])) == Alltrim(UPPER("NUM_REG"))}) == 0
		AADD(aEstruct,{"NUM_REG","N",10,0})
	Endif

	AADD(aEstruct,{"VLSOMAABAT","N",14,2})
	AADD(aEstruct,{"HASCLCABAT","C",1,0})
	AADD(aEstruct,{"HASCLCTRIB","C",1,0})
	AADD(aEstruct,{"IMPCONF","C",250,0})

	If __oFIN0901 <> Nil
		__oFIN0901:Delete()
		__oFIN0901 := Nil
	EndIF

	// Criação da Tabela Temporária >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	__oFIN0901 := FWTemporaryTable():New( cAliasSE2 )
	__oFIN0901:SetFields(aEstruct)
	__oFIN0901:AddIndex("1", {"E2_FILIAL","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO"})
	__oFIN0901:AddIndex(TRIM(STR(__nIdxE2OK)), {"E2_OK","E2_FILIAL","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO"})
	__oFIN0901:AddIndex("3", {"NUM_REG"})
	__oFIN0901:AddIndex("4", TTFtIndex(StrToKarr(SE2->(IndexKey()),"+"))) // Indice Ativo na Browse

	__oFIN0901:Create()

	cQuery2 := " INSERT "
	If ALLTRIM(tcGetdb()) == "ORACLE"
		cQuery2 += " /*+ APPEND */ "
	Endif

	aEval(aEstruct,{|x| cCampos += If( 'E2_' $ x[1] .OR. 'IMPOSTOS' == x[1], ALLTRIM(x[1]) + ',', '')})

	cCampos += ' NUM_REG'

	If AllTrim(TcGetDb()) == "DB2"
		cQuery := STRTRAN( cQuery, "FOR READ ONLY", "" )
	EndIf
	cQuery2 += " INTO "+__oFIN0901:GetRealName()+" ("+cCampos+") " + STRTRAN(cQuery,'IMPOSTOS','0 AS IMPOSTOS')

	Processa({|| nTcSql := TcSQLExec(cQuery2)})

	If nTcSql < 0
		If ExistFunc("FinxMsgE")
			FinxMsgE(TCSQLError())
		Else
			Help(" ",1,"F090MTTMP",, STR0167+ CRLF + CRLF + TCSQLError() ,1,0) //"Não foi possivel montar a tabela temporaria, favor verificar o seu ambiente Protheus."
		EndIf
	EndIf

	(cAliasSE2)->(DBSETORDER(4))
	(cAliasSE2)->(DBGOTOP())
	// ---------------------------------------------------------------------------------------

	While !(cAliasSE2)->(EOF())

		SE2->(DBGoto((cAliasSE2)->NUM_REG))

		If cPaisLoc=="BRA"

			// Se for um titulo de adiantamento, verifica se existem cheques nao liberados, pois se existir, nao permitir a baixa
			// Isso ocorre quando o parametro MV_LIBCHEQ esta igual a N, foi gerado um cheque para o adiantamento e este
			// ainda nao foi liberado
			If Alltrim(SE2->E2_TIPO) $ MVPAGANT
				SEF->(DbSetOrder(3))
				SEF->(MsSeek(xFilial("SEF")+(cAliasSE2)->( E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+Pad(E2_NUMBCO,nTamEFNUM) )))
				If SEF->EF_LIBER == "N"
					(cAliasSE2)->(DbDelete())
					(cAliasSE2)->(DbSkip())
					Loop
				EndIf
			EndIf

			// Para o Brasil, apresenta somente os titulos cuja moeda e' a mesma do banco selecionado para baixa.
			// Caso a moeda do banco estiver vazia ou caso o motivo de baixa nao movimente banco, considero apenas a moeda forte
			If FXMultSld()
				If nMoedaBco > 1 .And. MovBcoBx(cMotBx,.T.)
					If !FXVldBxBco(cBco090,cAge090,cCta090,(cAliasSE2)->E2_NATUREZ, (cAliasSE2)->E2_MOEDA,.F.)
						(cAliasSE2)->(DbDelete())
						(cAliasSE2)->(DbSkip())
						Loop
					EndIf
				Endif
			EndIf

		EndIf

		If cPaisLoc $ "ARG|DOM|EQU" .and. FUNNAME()=="FINA095"
			If cPaisLoc=="ARG"
				cChave := xFilial('SEF') + "P" + cBco090 + cAge090 + cCta090 + SUBSTR((cAliasSE2)->E2_NUM,1,nTamEFNUM) + (cAliasSE2)->E2_PREFIXO
			Else
				cChave := xFilial('SEF') + "P" + cBco090 + cAge090 + cCta090 + SUBSTR((cAliasSE2)->E2_NUMBCO,1,nTamEFNUM) + (cAliasSE2)->E2_PREFIXO
			Endif

			If !FA090StChq(cChave)
				(cAliasSE2)->(DbDelete())
				(cAliasSE2)->(DbSkip())
				Loop
			EndIf

		Endif

		//Retenções geradas na emissão
		If __lTemMR
			(cAliasSE2)->IMPOSTOS := FMRGETRET("P", "SE2")
		Endif

		//Ponto de Entrada para tratamentos específicos de exclusão dos registros
		If (__F090VLEX)
			Execblock("F090VLEX", .F., .F., {cMotBx, nTipoBx, nMoedaBco})
		EndIf

		(cAliasSE2)->(DbSkip())
	EndDo

	RestArea(aArea)

Return cAliasSE2


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090Clean

Limpa o objeto da temporarytable

@Author	Karen Yoshie Honda
@since	29/08/2017
/*/
//-----------------------------------------------------------------------------------------------------
Static Function F090Clean()

	If __oFIN0901 <> Nil
		__oFIN0901:Delete()
		__oFIN0901 := Nil
	Endif

	If __oTemINA <> Nil
		__oTemINA:Destroy()
		FwFreeObj(__oTemINA)
		__oTemINA := Nil
	Endif

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa090Display

Atualiza a flag na tabela temporaria após atualização da SE2

@Author	Karen Yoshie Honda
@since	29/08/2017
/*/
//-----------------------------------------------------------------------------------------------------
Static Function Fa090Display(cAliasSE2,cMarca,lInverte,oValor,oQtda,cArquivo,lBaixa)
	FinaDisplay(cMarca,lInverte,oValor,oQtda,cArquivo,,lBaixa)

	If (cAliasSE2)->(MsRLock())
		(cAliasSE2)->E2_OK	:= SE2->E2_OK
		(cAliasSE2)->(MsUnlock())
	EndIf
Return


//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090GETABAT
Esta função Verifica se o calculo da função SumAbatPag() já foi efetuado para o registro atual de cAliasSE2
@type function
@author Karen Yoshie Honda
@since 04/08/2017
@version 1.0
@return $numerico, $Valor de Abatimento do título posicionado, caso houver.
@example
	nTotAbat := F090GETABAT()
/*/
//-----------------------------------------------------------------------------------------------------------------------
STATIC Function F090GETABAT() As Numeric
	Local nRet		as NUMERIC

	//Inicialização
	nRet	:= 0

	IF (cAliasSE2)->HASCLCABAT == '1'
		nRet := (cAliasSE2)->VLSOMAABAT
	Else
		nRet := SumAbatPag(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_FORNECE, SE2->E2_MOEDA, "V", SE2->E2_BAIXA, SE2->E2_LOJA)
		(cAliasSE2)->VLSOMAABAT := nRet
		(cAliasSE2)->HASCLCABAT := '1'
	EndIf

Return nRet


//-------------------------------------------------------------------
/*/{Protheus.doc} F090GetCampos
Preenche 2 arrays de campos, sendo: 1 para exibição em MarkBrowse e 1 para criação de tabela temporaria.
@author  Norberto Monteiro de Melo
@since   12/01/2018
@version P12
/*/
//-------------------------------------------------------------------
STATIC FUNCTION F090GetCampos(aCampos as ARRAY, aEstruct as ARRAY )

	Local cIndex As Character
	Local cCampoSX3 As Character
	Local aRestrict As Array
	Local nX As Numeric
	Local aFields As Array

	Default aCampos  	:= {}	// Campos para o MarkBrowse - Deve ser passado por referência
	Default aEstruct 	:= {}	// Campos para a tabela temporária - Deve ser passado por referência
	Default __lTemMR	:= FTemMotor()
	Default __cLstImp	:= If (__lTemMR, FSE2ColImp(), "")
	DEFAULT __cLayout	:= FWSM0Layout()
	DEFAULT __lGestao	:= "E" $ __cLayout .Or. "U" $ __cLayout
	DEFAULT __cFilSE2	:= IIF( __lGestao , FwFilial("SE2") , xFilial("SE2") )

	//campos do indice do browse
	cIndex := SE2->(INDEXKEY())
	aRestrict := StrToKArr(cIndex,'+')
	cCampoSX3 := ""
	nX := 0
	aFields := SE2->(dbStruct())

	For nX := 1 To Len(aRestrict)
		aRestrict[nX] := FinExtCpo("SE2",aRestrict[nX])
	Next

	AADD(aCampos,{"E2_OK","","  ",""})
	AADD(aEstruct,{"E2_OK","C",2,0})

	// Sempre adiciona o campo E2_FILIAL na estrutura
	AADD(aEstruct,{"E2_FILIAL",GetSx3Cache("E2_FILIAL","X3_TIPO"),GetSx3Cache("E2_FILIAL","X3_TAMANHO"),GetSx3Cache("E2_FILIAL","X3_DECIMAL")})
	// Apenas adiciona o campo E2_FILIAL se SE2 estiver exclusiva.
	If !Empty( __cFilSE2 ) .Or. X3USO(GetSx3Cache("E2_FILIAL","X3_USADO")) .And. cNivel >= GetSx3Cache("E2_FILIAL","X3_NIVEL")
		AADD(aCampos,{"E2_FILIAL","",GetSx3Cache("E2_FILIAL","X3_TITULO"),GetSx3Cache("E2_FILIAL","X3_PICTURE")})
	EndIf

	For nX := 1 to Len(aFields)

		cCampoSX3 := AllTrim(Upper(aFields[nX,1]))

		//Campo E2_FILIAL já inserido anteriormente garantindo que fique na primeira posição após o E2_OK
		If !(cCampoSX3 $ "E2_FILIAL|E2_OK")
			// Processa o restante das colunas adicionando aquelas que passam pela regra.
			If ( (ASCAN(aRestrict,{|x| AllTrim(Upper(x)) == cCampoSX3 }) > 0) .Or. ;
					(aFields[nX,2] != "M" .And. X3USO(GetSx3Cache(aFields[nX,1],"X3_USADO")) .AND. ;
					cNivel >= GetSx3Cache(aFields[nX,1],"X3_NIVEL") .And. GetSx3Cache(aFields[nX,1],"X3_CONTEXT") != "V" ) .Or.;
					AllTrim(aFields[nX,1]) $ "E2_SALDO|E2_NUMBCO|E2_FATURA|E2_FATPREF|E2_NUMBOR" )

				IF !(TRIM(aFields[nX,1]) $ __cLstImp)
					AADD(aCampos,{aFields[nX,1],"",GetSx3Cache(aFields[nX,1],"X3_TITULO"),GetSx3Cache(aFields[nX,1],"X3_PICTURE")})
				ENDIF

				AADD(aEstruct,{aFields[nX,1],aFields[nX,2],aFields[nX,3],aFields[nX,4]})

				IF Trim(aFields[nX,1]) == "E2_VALOR"
					AADD(aCampos ,{'IMPOSTOS','','Retenções',GetSx3Cache(aFields[nX,1],"X3_PICTURE")})
					AADD(aEstruct,{'IMPOSTOS',aFields[nX,2],aFields[nX,3],aFields[nX,4]})
				ENDIF
			Endif
		Endif
	Next nX

RETURN NIL


//-------------------------------------------------------------------
/*/{Protheus.doc} F090VldImp()
Cálculo dos impostos a serem retidos
@author  Sivaldo Oliveira
@since 23/02/2018
@version 12
/*/
//-------------------------------------------------------------------
Static Function F090VldImp(lCancel As Logical)
	Local nZ As Numeric
	Local nImpos As Numeric
	Local nBasMR As Numeric
	Local aImpos As Array
	Local aBasMR As Array
	Local aImpConf As Array
	Local nCasDec as Numeric
	Local lBordero As Logical
	Local aBaseImp As Array
	Local nBaseDif As Numeric
	Local cIdFK0 As Character
	Local cChaveTit As Character

	Default lCancel := .F.

	//Inicilaiza variaveis
	nZ := 0
	nImpos := 0
	nBasMR := 0
	aImpos := {}
	aBasMR := {}
	aImpConf := {}
	nCasDec := (MsDecimais(1) + 1)
	lBordero := !Empty(SE2->E2_NUMBOR) .AND. ("FINA241" $ SEA->EA_ORIGEM)
	aBaseImp := {}
	nBaseDif := 0
	cIdFK0 := ""
	__aImpMR := {}
	__lPccMR := .F.
	__lIrfMR := .F.
	__lInsMR := .F.
	__lIssMR := .F.
	__lCidMR := .F.
	__lSesMR := .F.
	__nPisMR := 0
	__nCofMR := 0
	__nCslMR := 0
	__nIrfMR := 0
	__nInsMR := 0
	__nIssMR := 0
	__nCidMR := 0
	__nSesMR := 0
	__nImpMR := 0

	//Valida quais os impostos configurados pelo motor de retenções
	If !SE2->E2_TIPO $ MVPAGANT+"|"+MVABATIM+"|"+MVPROVIS+"|"+MV_CPNEG+"|"+MVTAXA+"|"+MVTXA+"|INA"
		aImpConf := FinImpConf("1", SE2->E2_FILORIG, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ)
		nImpos := Len(aImpConf)

		For nZ := 1 To nImpos
			Do Case
			Case aImpConf[nZ,1] $ "PIS|COF|CSL"
				__lPccMR := .T.
				__lPccBxMR := aImpConf[nZ,2] == "2"
			Case aImpConf[nZ,1] == "IRF"
				__lIrfMR := .T.
			Case aImpConf[nZ,1] == "INSS"
				__lInsMR := .T.
			Case aImpConf[nZ,1] == "ISS"
				__lIssMR := .T.
			Case aImpConf[nZ,1] == "CIDE"
				__lCidMR := .T.
			Case aImpConf[nZ,1] == "SEST"
				__lSesMR := .T.
			OtherWise
				_lImpMR := .T.
			EndCase

			//Retenção na primeira baixa
			If aImpConf[nZ,7] == "1"
				nBaseDif := SE2->E2_VALOR

				If SE2->E2_MOEDA > 1
					nBaseDif := NoRound(xMoeda(nBaseDif, SE2->E2_MOEDA, 1, dBaixa, nCasDec, SE2->E2_TXMOEDA), nCasDec)
				EndIf

				Aadd(aBaseImp, {aImpConf[nZ,1], nBaseDif})
			EndIf
		Next nZ

		//busca chave p/ verificar se já houve retenção, se conf retenção na 1ª baixa
		cChaveTit := xFilial("SE2", SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA

		//Impostos gerado pelo fiscal
		If nImpos == 0
			nImpos := Len(aImpConf := FinImpFis(cChaveTit, SE2->E2_FILORIG, "SE2", .F., 0, Nil, SE2->E2_FORNECE, SE2->E2_LOJA))
		EndIf
	EndIf

	If !lCancel .And. !lBordero .And. nImpos > 0
		/*--------------------------------------------------
		Estrutura da aBasMR
		[1] = base de retenção
		[2] = Imp retidos na emissão motor de retenção
		[3] = Imp retidos Bx.MR e antigo que recompoem base
		----------------------------------------------------*/
		nBasMR := SE2->E2_SALDO

		aBasMR := FinBaseMR(nBasMR, .F., SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA,;
			__lPccMR, __lIrfMR, __lInsMR, __lIssMR, __lCidMR, __lSesMR, SE2->E2_MOEDA, SE2->E2_TXMOEDA, dBaixa)

		For nZ := 1 To Len(aBasMR)
			nBasMR := aBasMR[nZ]
			exit
		Next nZ

		If SE2->E2_MOEDA > 1
			nBasMR := NoRound(xMoeda(nBasMR, SE2->E2_MOEDA, 1, dBaixa, nCasDec, SE2->E2_TXMOEDA), nCasDec)
		EndIf

		If Len(aBaseImp) > 0
			cIdFK0 := FINGRVFK7("SE2", cChaveTit)
		EndIf

		//Cálculo motor de retenções.
		aImpos := FINCalImp("1", SE2->E2_NATUREZ, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_FILORIG, nBasMR, dBaixa, .T., aBaseImp, SE2->E2_TIPO, cChaveTit, cIdFK0, {})
		nImpos := Len(aImpos)

		For nZ := 1 To nImpos
			If (aImpos[nZ,9] != "2")
				Loop
			EndIf

			//Vlr de imps a ser abatido do valor a de pagto
			__nImpMR += aImpos[nZ,5]

			//Variáveis para gravar os Vrets.
			Do Case
			Case aImpos[nZ,8] == "PIS"
				__nPisMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "COF"
				__nCofMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "CSL"
				__nCslMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "IRF"
				__nIrfMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "INSS"
				__nInsMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "ISS"
				__nIssMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "CIDE"
				__nCidMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "SEST"
				__nSesMR += aImpos[nZ,5]
			EndCase
		Next nZ

		__nBasLeg := nBasMR

		__aImpMR := Aclone(aImpos)
	EndIf

Return Nil


//-------------------------------------------------------
/*/ Fa090BnkVl
Valida o banco selecionando quando integração SIGAPFS x SIGAFIN está ativa.

@Param cTipo    Indica se é campo Banco (1), Agência (2) ou Conta(3)
@param cBanco, Código do banco.
@param cAgencia, Agência do banco.
@param cNumCont, Conta do banco.

@author Bruno Ritter
@since 30/07/2018
@version P12
*/
//-------------------------------------------------------
Static Function Fa090BnkVl(cTipo, cBanco, cAgencia, cNumCont)
	Local lRet     := .T.
	Local cEscrit  := ""

	If __lJFilBco
		cEscrit := JurGetDados("NS7", 4, xFilial("NS7") + cFilant + cEmpAnt, "NS7_COD")
		lRet := JurVldSA6(cTipo, {cEscrit, cBanco, cAgencia, cNumCont})
	EndIf

Return lRet

/*/{Protheus.doc} F090DetPro
Função centralizadora para prepar lançamentos contábeis de acordo
com a filial logada.
@type function
@version 12
@author gabriel.asantos
@since 22/09/2022
/*/
Static Function F090DetPro( nHdlPrv AS Numeric, cPadrao AS Character, cPrograma AS Character,;
		cLote AS Character, nLinha AS Numeric, lExecuta AS Logical,;
		cCriterio AS Character, aFlagCTB AS Array, cFilCorr as Character,;
		cFilOriCtb as Character ) AS Numeric

	Local cFilBkp AS Character
	Local nTotal AS Numeric

	Default nHdlPrv 	:= 0
	Default cPadrao		:= "531"
	Default cLote		:= ""
	Default cPrograma	:= "FINA090"
	Default nLinha		:= 0
	Default lExecuta	:= .T.
	Default cCriterio	:= "FINA090"
	Default aFlagCTB	:= {}
	Default cFilCorr	:= cFilAnt
	Default cFilOriCtb	:= cFilAnt

	cFilBkp := cFilAnt

	//Prepara lançamento na filial logada
	IF mv_par08 == 1
		cFilAnt := cFilCorr
	Else
		cFilAnt := cFilOriCtb
	ENDIF

	nTotal := DetProva(nHdlPrv,cPadrao,cPrograma,cLote,nLinha,lExecuta,cCriterio,,,,,@aFlagCTB,,)

	//Restaura filial para não afetar os movimentos da SE5
	cFilAnt := cFilBkp

Return nTotal

/*/{Protheus.doc} F090Contab
Função centralizadora para efetivar lançamentos contábeis de acordo
com a filial logada.
@type function
@version 12
@author gabriel.asantos
@since 22/09/2022
/*/
Static Function F090Contab( cArquivo AS Character, nHdlPrv AS Numeric, cLote AS Character,;
		lDigita AS Logical, lAglut AS Logical, dDtLanc AS Date, aFlagCTB AS Array,;
		aDiario AS Array, cFilCorr AS Character, cFilOriCtb AS Character)

	Local cFilBkp AS Character

	Default cArquivo 	:= ""
	Default nHdlPrv 	:= 0
	Default cLote		:= ""
	Default lDigita		:= IIF(mv_par01==1,.T.,.F.)
	Default lAglut		:= IIF(mv_par02==1,.T.,.F.)
	Default dDtLanc		:= dDataBase
	Default aFlagCTB	:= {}
	Default aDiario		:= {}
	Default cFilCorr	:= cFilAnt
	Default cFilOriCtb	:= cFilAnt

	cFilBkp := cFilAnt

	//Prepara lançamento na filial logada
	IF mv_par08 == 1
		cFilAnt := cFilCorr
	Else
		cFilAnt := cFilOriCtb
	ENDIF

	cA100Incl(cArquivo,nHdlPrv,,cLote,lDigita,lAglut,,dDtLanc,,@aFlagCTB,,aDiario)

	//Restaura filial para não afetar os movimentos da SE5
	cFilAnt := cFilBkp
Return

//-------------------------------------------- CANCELAMENTO AUTOMATICO DE BAIXAS -----------------------------------------------------------------

//--------------------------------------------------------------------------------------
/*/{Protheus.doc}FA090CAUT
Filtros para montagem do grid de Títulos a Pagar, visando cancelamento das suas baixas
@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//--------------------------------------------------------------------------------------
Function FA090CAUT(cAlias,cCampo,nOpcE,aM,aTitulos)

	Local cBord1 	:= Space(6)
	Local cBord2 	:= Space(6)
	Local cDatB1 	:= CTOD("//")
	Local cDatB2 	:= CTOD("//")
	Local cFor1	 	:= Space(6)
	Local cFor2  	:= Space(6)
	Local nX 	 	:= 0
	Local nRadio	:= 1
	Local nOpca		:= 0
	Local aRadio	:= {}
	Local aSelFil	:= {}
	Local aTmpFil	:= {}
	Local lSelFil	:= .F.
	Local oSize		:= NIL
	Local oDlg1		:= NIL
	Local oSelFil	:= NIL
	Local oPanel1 	:= NIL
	Local oMasterPanel := NIL
	Local bProcessa
	Local nTamaTits	:= 0
	Local lAutomato := .F.

	Private oBord1 	:= NIL
	Private oBord2 	:= NIL
	Private oDatB1 	:= NIL
	Private oDatB2 	:= NIL
	Private oFor1 	:= NIL
	Private oFor2 	:= NIL

	DEFAULT aTitulos := {}

	nTamaTits := Len(aTitulos)
	lAutomato := FindFunction("GetParAuto") .AND. nTamaTits > 0

	If !lAutomato
		aAdd(aRadio, STR0066)	//"Títulos"
		aAdd(aRadio, STR0067)	//"Borderôs"

		DEFINE MSDIALOG oDlg1 TITLE STR0137 OF oMainWnd PIXEL FROM 050,010 TO 324,340 // "Cancelamento Automático de Baixas a Pagar"

		//Defino o tamanho dos componentes através do método FwDefSize(), amarrando ao objeto oDlg
		oSize := FwDefSize():New(.F.,,,oDlg1)

		oSize:lLateral := .F.
		oSize:lProp := .T.
		oSize:AddObject("MASTER",100,100,.T.,.T.)
		oSize:Process()

		//Instancio um painel "master" como container
		oMasterPanel := TPanel():New(oSize:GetDimension("MASTER","LININI"),oSize:GetDimension("MASTER","COLINI"),;
			,oDlg1,,,,,,oSize:GetDimension("MASTER","XSIZE"),oSize:GetDimension("MASTER","YSIZE"),.F.,.F.)

		oPanel1 := TPanel():New(0,0,'',oMasterPanel,, .T., .T.,, ,115,115,.f.,.f. )
		oPanel1:Align := CONTROL_ALIGN_ALLCLIENT

		@ 05,005 TO 117,158 PROMPT ""  PIXEL OF oPanel1

		@ 06,010 TO 33,150 PROMPT STR0138 PIXEL OF oPanel1		//  "Cancelar Baixas"
		@ 12,063 RADIO oRadio VAR nRadio ITEMS aRadio[1],aRadio[2]  SIZE 080,209 PIXEL OF oPanel1 ON CHANGE Fa090Radio(nRadio,@cBord1,@cBord2,@cDatB1,@cDatB2,@cFor1,@cFor2)

		@ 35,010 SAY STR0139	SIZE 555,10 PIXEL OF oPanel1  	// "Borderô De"
		@ 43,010 MSGET oBord1 	VAR cBord1	PICTURE  "@S6"  OF oPanel1  SIZE 060,10 PIXEL

		@ 35,085 SAY STR0140	SIZE 555,10 PIXEL OF oPanel1  // "Borderô Até"
		@ 43,085 MSGET oBord2	VAR cBord2	PICTURE  "@S6"  OF oPanel1  SIZE 060,10 PIXEL

		@ 55,010 SAY STR0141	SIZE 555,10 PIXEL OF oPanel1	//"Dt. Baixa De"
		@ 63,010 MSGET oDatB1	VAR cDatB1	   PICTURE "@!"	   OF oPanel1 SIZE 060,10 PIXEL HASBUTTON

		@ 55,085 SAY STR0142	SIZE 555,10 PIXEL 	OF oPanel1	//"Dt. Baixa Ate"
		@ 63,085 MSGET oDatB2	VAR cDatB2	PICTURE "@!"	   OF oPanel1 SIZE 060,10 PIXEL HASBUTTON

		@ 75,010 SAY STR0143	SIZE 555,10 PIXEL OF oPanel1	// "Fornecedor De"
		@ 83,010 MSGET oFor1	VAR cFor1   F3 "FOR" 	PICTURE "@!"  OF oPanel1  SIZE 060,10 PIXEL HASBUTTON

		@ 75,085 SAY STR0144	SIZE 555,10 PIXEL OF oPanel1	//"Fornecedor Ate"
		@ 83,093 MSGET oFor2	VAR cFor2	F3 "FOR"    PICTURE "@!"  OF oPanel1  SIZE 060,10 PIXEL HASBUTTON

		@ 100,010 CHECKBOX oSelFil VAR lSelFil PROMPT "" SIZE 11,11 OF oPanel1 PIXEL
		@ 100,020 SAY STR0168 SIZE 50, 07 OF oPanel1 PIXEL	//"Seleciona Filiais"

		DEFINE SBUTTON FROM 120,093 TYPE 1 ACTION (nOpca := 1,If(Fa090ValOk(nRadio,cBord1,cBord2,cDatB1,cDatB2,cFor1,cFor2), oDlg1:End(), nOpca:=0))  ENABLE OF oPanel1
		DEFINE SBUTTON FROM 120,122 TYPE 2 ACTION oDlg1:End()  ENABLE OF oPanel1

		oDatB1:disable()
		oDatB2:disable()
		oFor1:disable()
		oFor2:disable()
		oBord1:disable()
		oBord2:disable()

		If Empty(cFor2)
			cFor2 := Replicate("Z",Len(SE2->E2_FORNECE))
			cBord2 := Replicate("Z",Len(SEA->EA_NUMBOR))
		Endif

		ACTIVATE MSDIALOG oDlg1 CENTERED ON INIT Fa090Radio(nRadio,@cBord1,@cBord2,@cDatB1,@cDatB2,@cFor1,@cFor2)

	Else
		If nTamaTits > 0
			nRadio		:= aTitulos[1] //1 = Cancela Baixa de titulos titulos 	2 = cancela baixa somente titulos em bordero
			cBord1		:= aTitulos[2] // Borderõ De
			cBord2 		:= aTitulos[3] // Borderô Até
			cDatB1		:= aTitulos[4] // Dt. Baixa Inicial
			cDatB2		:= aTitulos[5] // Dt. Baixa Final
			cFor1		:= aTitulos[6] // Fornecedor De
			cFor2		:= aTitulos[7] // Fornecedor Até
			aSelFil		:= aTitulos[8] // Array com as filiais a serem consideradas na seleção dos titulos
			nOpca 		:= 1
		Endif
	Endif

	If nOpca == 1
		pergunte(__cPerg,.F.)

		bProcessa := {|| FA090STIT(nRadio, aSelFil, aTmpFil, lSelFil, cBord1, cBord2, cDatB1, cDatB2, cFor1, cFor2, lAutomato)}
		IF !lAutomato
			If lSelFil
				// Seleção de filiais
				aSelFil := AdmGetFil(, .F., "SE2")
				If Len( aSelFil ) <= 0
					nOpca := 0
				Endif
			Else
				aSelFil := {cFilAnt}
			EndIf
			If nOpca != 0
				Processa(bProcessa)
			Endif
		Else
			Eval(bProcessa)
		Endif
	EndIF

	For nX := 1 TO Len(aTmpFil)
		CtbTmpErase(aTmpFil[nX])
	Next

Return


//---------------------------------------------------------------------
/*/{Protheus.doc}Fa090Radio
Validacao do RadioButtom - Tela de Filtros para selecao dos dados -
Cancelamento Automatico Baixas Titulo a Pagar

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function Fa090Radio(nRadio,cBord1,cBord2,cDatB1,cDatB2,cFor1,cFor2)

	cBord1 := Space(TamSX3("EA_NUMBOR")[1])
	cBord2 := Replicate("Z",TamSX3("EA_NUMBOR")[1] )

	If nRadio == 1		//Opção TITULO
		oDatB1:enable()
		oDatB2:enable()
		oFor1:enable()
		oFor2:enable()
		oBord1:disable()
		oBord2:disable()

		cDatB1 := dDataBase
		cDatB2 := dDataBase
		cFor1 := Space(TamSX3("E2_FORNECE")[1])
		cFor2 := Replicate("Z",TamSX3("E2_FORNECE")[1] )
		oDatB1:SetFocus()
	Else				//Opção BORDERO
		oDatB1:disable()
		oDatB2:disable()
		oFor1:disable()
		oFor2:disable()
		oBord1:enable()
		oBord2:enable()

		cDatB1 := CtoD("01/01/1980","ddmmyy")
		cDatB2 := CtoD("31/12/2099","ddmmyy")
		cFor1 := Space(TamSX3("E2_FORNECE")[1])
		cFor2 := Replicate("Z",TamSX3("E2_FORNECE")[1])
		oBord1:SetFocus()
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc}Fa090ValOk
Validacao dos Gets - Tela de Filtros para selecao dos dados -
Cancelamento Automatico Baixas Titulos a Pagar

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function Fa090ValOk(nRadio,cBord1,cBord2,cDatB1,cDatB2,cFor1,cFor2)

	Local lRet := .T.

// Valida todos os gets
	If Empty(cDatB1) .or. Empty(cDatB2) .or. (cDatB2 < cDatB1)
		MsgAlert( STR0169 , STR0146 )	//"Por favor, verifique o intervalo de datas informado."###"Validação"
		lRet := .F.
	Endif

	If lRet .and. Empty(cFor2)
		MsgAlert( STR0145 , STR0146 )	//"Fornecedor Até não está preenchido"###"Validação"
		lRet := .F.
	Endif

	If lRet .and. nRadio == 2 .and. Empty(cBord2)
		MsgAlert( STR0147 , STR0146 )   //"Borderô Até não está preenchido"###"Validação"
		lRet := .F.
	Endif

	If lRet .and. nRadio == 2 .and. cBord2 < cBord1
		MsgAlert( STR0170 , STR0146 )   //"Por favor, verifique o intervalo de borderôs informado."###"Validação"
		lRet := .F.
	EndIf

Return lRet

//--------------------------------------------------------------------------------------
/*/{Protheus.doc}FA090STIT
FWMarkBrowse contendo os Títulos a Pagar, visando o cancelamento das suas baixas,
a partir dos Filtros escolhidos

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//--------------------------------------------------------------------------------------
Static Function FA090STIT(nRadio, aSelFil, aTmpFil, lSelFil, cBord1, cBord2, cDatB1, cDatB2, cFor1, cFor2, lAutomato)

	Local cQuery 		:= ''
	Local cArqTrab 		:= ""
	Local cCampos		:= ""
	Local cTmpSE2Fil	:= ""
	Local cMarca		:= ""
	Local nX 			:= 1
	Local nTcSql		:= 0
	Local aStruct		:= {}
	Local aDadosBx		:= {}
	Local aColumns		:= {}
	Local aSize			:= {}
	Local aRotAtu		:= Aclone(aRotina)
	Local bOk 			:= {}
	Local oDlgy			:= Nil
	Local oSize			:= NIL
	Local oMasterPanel	:= NIL
	Local oFnt2S		:= TFont():New("Arial      ",7,15,.F.,.F.,,,,,.F.) 	  //NEGRITO SUBLINHADO
	Local lRet			:= .T.

	Private oMrkBrowse	:= FWMarkBrowse():New()

	DEFAULT nRadio		:= 0
	DEFAULT aSelFil		:= {cFilAnt}
	DEFAULT aTmpFil	 	:= {}
	DEFAULT lSelFil	 	:= .F.
	DEFAULT cBord1	 	:= ''
	DEFAULT cBord2	 	:= ''
	DEFAULT cDatB1 		:= ''
	DEFAULT cDatB2 		:= ''
	DEFAULT cFor1 		:= ''
	DEFAULT cFor2 		:= ''
	DEFAULT lAutomato 	:= .F.
	DEFAULT __lFK7Cpos	:= FK7->(ColumnPos("FK7_CLIFOR")) > 0 .And. FindFunction("FinFK7Cpos") .And. FExecFixN("2")

	aRotina := {}

	F090CnStru(aStruct, @cCampos)

//Filtra baixas realizadas nos Titulos a Pagar
	cQuery := " SELECT DISTINCT "
	cQuery += cCampos
	cQuery += "SE2.E2_OK, SE2.R_E_C_N_O_ NUM_REG "
	cQuery += "FROM " + RetSqlName("FK2") + " FK2 "

//Amarracao FK2 + FK7
	cQuery += "Join " + RetSqlName("FK7") + " FK7 "
	cQuery += "ON ( FK7.FK7_IDDOC = FK2.FK2_IDDOC ) "

//Amarracao FK2 + FKA
	cQuery += "Join " + RetSqlName("FKA") + " FKA "
	cQuery += "ON ( FKA.FKA_IDORIG = FK2.FK2_IDFK2 ) "

//Amarracao FK2 + SE2
	cQuery += "Join " + RetSqlName("SE2") + " SE2 "

	If __lFK7Cpos
		cQuery += "ON "
		cQuery += "SE2.E2_FILIAL = FK7.FK7_FILTIT AND "
		cQuery += "SE2.E2_PREFIXO = FK7.FK7_PREFIX AND "
		cQuery += "SE2.E2_NUM = FK7.FK7_NUM AND "
		cQuery += "SE2.E2_PARCELA = FK7.FK7_PARCEL AND "
		cQuery += "SE2.E2_TIPO = FK7.FK7_TIPO AND "
		cQuery += "SE2.E2_FORNECE = FK7.FK7_CLIFOR AND "
		cQuery += "SE2.E2_LOJA = FK7.FK7_LOJA  "
	Else
		//Caso o banco seja Postgres ou MySQL dever  utilizar o Concat para tratamento do trecho de compara‡?o de chave
		If ALLTRIM(tcGetdb()) == "POSTGRES" .or. ALLTRIM(tcGetdb()) == "MYSQL"
			cQuery += "ON RTRIM(CONCAT(SE2.E2_FILIAL,'|', SE2.E2_PREFIXO,'|',SE2.E2_NUM,'|',SE2.E2_PARCELA,'|',SE2.E2_TIPO,'|',SE2.E2_FORNECE,'|',SE2.E2_LOJA)) = RTRIM(FK7.FK7_CHAVE) "
		Else
			cQuery += "ON ( SE2.E2_FILIAL || '|' || SE2.E2_PREFIXO || '|' || SE2.E2_NUM || '|' || SE2.E2_PARCELA || '|' ||  SE2.E2_TIPO || '|' ||  SE2.E2_FORNECE || '|' ||  SE2.E2_LOJA = FK7.FK7_CHAVE ) "
		EndIf
	Endif

	cQuery += "WHERE "
	cQuery += "SE2.E2_FILIAL " + GetRngFil( aSelFil, "SE2", .T., @cTmpSE2Fil )
	aAdd(aTMPFil, cTmpSE2Fil)

	If nRadio == 1///Opção Titulo
		cQuery += " AND FK2.FK2_DATA BETWEEN '"+ DTOS(cDatB1) +"' AND '"+ DTOS(cDatB2) +"' "
		cQuery += " AND SE2.E2_FORNECE BETWEEN '"+ cFor1 +"' AND '"+ cFor2 +"' "
	Else
		cQuery += " AND SE2.E2_NUMBOR BETWEEN '"+ cBord1 +"' AND '"+ cBord2 +"' "
	Endif
	cQuery += " AND (SE2.E2_VALOR <> SE2.E2_SALDO)  " 				// houve baixa em algum momento
	cQuery += " AND FK2.FK2_TPDOC NOT IN('ES','PA') "   			// apenas Baixas realizadas e não registros estornados
	cQuery += " AND FK2.FK2_MOTBX NOT IN ('DSD','LIQ','CEC','PCC','IRF','ISS','FAT','CMP','STP','IMR','IPA') "
	cQuery += " AND FK2.D_E_L_E_T_ = ' ' "
	cQuery += " AND FK7.FK7_ALIAS = 'SE2' "
	cQuery += " AND FK7.D_E_L_E_T_ = ' ' "
	cQuery += " AND SE2.D_E_L_E_T_ = ' ' "

	cQuery += " AND NOT EXISTS ("
	cQuery += "SELECT A.FK2_IDDOC "
	cQuery += "FROM "+RetSqlName("FK2")+" A "

	cQuery += "WHERE "
	cQuery += "A.FK2_FILIAL = FK2.FK2_FILIAL AND "
	cQuery += "A.FK2_IDDOC = FK2.FK2_IDDOC AND "
	cQuery += "A.FK2_SEQ = FK2.FK2_SEQ AND "
	cQuery += "A.FK2_TPDOC = 'ES' AND "
	cQuery += "A.D_E_L_E_T_ = ' ')"

	cQuery := ChangeQuery(cQuery)

	If __oFIN0902 <> Nil
		//-- Limpa registros para nova execução
		cArqTrab := __oFIN0902:GetAlias()
		nTcSql := TcSQLExec("DELETE FROM "+__oFIN0902:GetRealName())
		If nTcSql < 0
			//-- Se ocorrer algum problema refaz a temporaria
			__oFIN0902:Delete()
			__oFIN0902 := Nil
		Else
			(cArqTrab)->(dbGoTo(1))
		Endif
	EndIF

	If __oFIN0902 == Nil
		// Criação da Tabela Temporária
		cArqTrab := GetNextAlias()
		__oFIN0902 := FWTemporaryTable():New( cArqTrab )
		__oFIN0902:SetFields(aStruct)
		__oFIN0902:AddIndex("1", {"FK2_FILIAL","FK2_DATA","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO", "E2_FORNECE","E2_LOJA"})
		__oFIN0902:AddIndex("2", {"FK2_OK","FK2_FILIAL","FK2_DATA","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO", "E2_FORNECE","E2_LOJA"})
		__oFIN0902:AddIndex("3", {"NUM_REG"})
		__oFIN0902:AddIndex("4", {"FK2_FILIAL","FK2_IDFK2"})

		__oFIN0902:Create()
	EndIf

	cQuery2 := " INSERT "
	If ALLTRIM(tcGetdb()) == "ORACLE"
		cQuery2 += " /*+ APPEND */ "
	Endif

	cCampos += 'FK2_OK, NUM_REG'

	If AllTrim(TcGetDb()) == "DB2"
		cQuery := STRTRAN( cQuery, "FOR READ ONLY", "" )
	EndIf

	cQuery2 += " INTO " + __oFIN0902:GetRealName() + " (" + cCampos + " ) " + cQuery

	If lAutomato
		nTcSql := TcSQLExec(cQuery2)
	Else
		Processa({|| nTcSql := TcSQLExec(cQuery2)})
	Endif

	If nTcSql < 0
		If FindFunction("FinSqlLog")
			FinSqlLog("FN090" ,TCSqlError() , "TEMPORARIA_TITULOS")
			lRet := .F.
		Endif
	Endif

//Verifica se o banco esta bloqueado e deleta os registros
	iF lRet .and. FindFunction("FxBcoBloq") .and. FxBcoBloq(__oFIN0902:GetRealName(),{"FK2_FILIAL","FK2_IDFK2"}) < 0
		FinSqlLog("FN090" ,TCSqlError() , "DELETE_TEMPORARIA")
		lRet := .F.
	Endif

	If lRet
		cArqTrab := __oFIN0902:GetAlias()

		(cArqTrab)->(DBGOTOP())

		If (cArqTrab)->(Eof())
			If !lAutomato
				MsgAlert( STR0149 , STR0146 )	//"Não existem dados a partir dos filtros mencionados."###"Validação"
			Endif
		Else
			If !lAutomato
				//----------------MarkBrowse----------------------------------------------------
				For nX := 1 To Len(aStruct)
					If	aStruct[nX][1] $ "FK2_FILIAL|E2_PREFIXO|E2_NUM|E2_PARCELA|E2_TIPO|E2_FORNECE|E2_LOJA|E2_NOMFOR|FK2_DATA|FK2_MOTBX|FK2_VALOR"
						AAdd(aColumns,FWBrwColumn():New())
						aColumns[Len(aColumns)]:SetData( &("{||"+aStruct[nX][1]+"}") )
						aColumns[Len(aColumns)]:SetTitle(Alltrim(RetTitle(aStruct[nX][1]))  )
						aColumns[Len(aColumns)]:SetSize(6)
						aColumns[Len(aColumns)]:SetDecimal(aStruct[nX][4])

						IF aStruct[nX][1] == 'FK2_VALOR'
							aColumns[Len(aColumns)]:SetPicture(PesqPict("FK2",aStruct[nX][1]))
							aColumns[Len(aColumns)]:SetAlign('RIGHT')
						Endif
					EndIf
				Next nX

				aSize := MSADVSIZE(.F.)

				DEFINE MSDIALOG oDlgy TITLE STR0137 From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL  //'Cancelamento Automático de Baixas de Títulos a Pagar'

				//Defino o tamanho dos componentes através do método FwDefSize(), amarrando ao objeto oDlg
				oSize := FwDefSize():New(.T.,,,oDlgy)
				oSize:lLateral := .F.
				oSize:lProp := .T.
				oSize:AddObject("MASTER",100,100,.T.,.T.)
				oSize:Process()

				//Instancio um painel "master" como container
				oMasterPanel := TPanel():New(oSize:GetDimension("MASTER","LININI"),oSize:GetDimension("MASTER","COLINI"),;
					,oDlgy,,,,,,oSize:GetDimension("MASTER","XSIZE"),oSize:GetDimension("MASTER","YSIZE"),.F.,.F.)

				oPanel1 := TPanel():New(0,0,'',oMasterPanel,, .T., .T.,, ,115,115,.F.,.F. )
				oPanel1:Align := CONTROL_ALIGN_ALLCLIENT

				oMrkBrowse:SetFieldMark("FK2_OK")
				oMrkBrowse:SetOwner(oPanel1)
				oMrkBrowse:SetAlias(cArqTrab)
				oMrkBrowse:bMark     := {||FI090Mark(cArqTrab )}
				oMrkBrowse:bAllMark  := {||FA090AllMk(oMrkBrowse,cArqTrab)}
				oMrkBrowse:SetDescription("")
				oMrkBrowse:SetColumns(aColumns)
				oMrkBrowse:SetMenuDef("")
				oMrkBrowse:DisableReport("")

				oMrkBrowse:Activate()

				oMrkBrowse:SetFontBrowse(oFnt2S)
				oMrkBrowse:SetLineHeight(25)

				bOk := {||Processa({||If(F090Grava(cArqTrab,aDadosBx), IIf(Fa090ExcA(aDadosBx),(oMrkBrowse:Deactivate(), oDlgy:End()), oDlgy:End()), Nil)}) }

				ACTIVATE MSDIALOG oDlgy ON INIT EnchoiceBar( oDlgy,	{|| ( Eval(bOk) ) },;
					{|| nOpca := 0,oDlgy:End()},, ) CENTER
			Else

				FA090AllMk( ,cArqTrab,lAutomato,@cMarca)
				If F090Grava(cArqTrab,aDadosBx,lAutomato,cMarca)

					Fa090ExcA(aDadosBx,.T.)
				Endif
			Endif
		EndIf

	Else
		IF !lAutomato
			HELP(" ",1,"SGDBInfo",,STR0181 ,2,0,,,,,, { STR0182 })  // Ocorreu erro no comando do banco de dados. ###  Avalie o log de incosistências gerado na pasta system arquivo FR110Log.
		Endif
	Endif

	aRotina := Aclone(aRotAtu)

Return aDadosBx


//---------------------------------------------------------------------
/*/{Protheus.doc}F090CnStru
Estrutura da Tabela Temporária apresentados no FWMarkBorwse

@author Mauricio Pequim Jr
@since  07/10/2021
@version 12
/*/
//---------------------------------------------------------------------
Static Function F090CnStru(aStruct As Array, cCampos As Character)

	Local aAux As Array

	DEFAULT aStruct := {}
	DEFAULT cCampos	:= ""

	//Cria estrutura e tabela tmp com os campos necessarios da SE2 e FK2
	aAux := TamSx3("FK2_FILIAL")
	cCampos += "FK2_FILIAL, "
	Aadd(aStruct, {"FK2_FILIAL",aAux[3],aAux[1],0})

	aAux := TamSx3("E2_PREFIXO")
	cCampos += "E2_PREFIXO, "
	Aadd(aStruct, {"E2_PREFIXO",aAux[3],aAux[1],0})

	aAux := TamSx3("E2_NUM")
	cCampos += "E2_NUM, "
	Aadd(aStruct, {"E2_NUM"    ,aAux[3],aAux[1],0})

	aAux := TamSx3("E2_PARCELA")
	cCampos += "E2_PARCELA, "
	Aadd(aStruct, {"E2_PARCELA",aAux[3],aAux[1],0})

	aAux := TamSx3("E2_TIPO")
	cCampos += "E2_TIPO, "
	Aadd(aStruct, {"E2_TIPO"   ,aAux[3],aAux[1],0})

	aAux := TamSx3("E2_FORNECE")
	cCampos += "E2_FORNECE, "
	Aadd(aStruct, {"E2_FORNECE",aAux[3],aAux[1],0})

	aAux := TamSx3("E2_LOJA")
	cCampos += "E2_LOJA, "
	Aadd(aStruct, {"E2_LOJA"   ,aAux[3],aAux[1],0})

	aAux := TamSx3("E2_NOMFOR")
	cCampos += "E2_NOMFOR, "
	Aadd(aStruct, {"E2_NOMFOR" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_MOTBX")
	cCampos += "FK2_MOTBX, "
	Aadd(aStruct, {"FK2_MOTBX" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_DATA")
	cCampos += "FK2_DATA, "
	Aadd(aStruct, {"FK2_DATA" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_VALOR")
	cCampos += "FK2_VALOR, "
	Aadd(aStruct, {"FK2_VALOR" ,aAux[3],aAux[1],aAux[2]})

	aAux := TamSx3("FK7_CHAVE")
	cCampos += "FK7_CHAVE, "
	Aadd(aStruct, {"FK7_CHAVE" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_IDDOC")
	cCampos += "FK2_IDDOC, "
	Aadd(aStruct, {"FK2_IDDOC" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_FILORI")
	cCampos += "FK2_FILORI, "
	Aadd(aStruct, {"FK2_FILORI",aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_IDFK2")
	cCampos += "FK2_IDFK2, "
	Aadd(aStruct, {"FK2_IDFK2" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_TPDOC")
	cCampos += "FK2_TPDOC, "
	Aadd(aStruct, {"FK2_TPDOC" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_SEQ")
	cCampos += "FK2_SEQ, "
	Aadd(aStruct, {"FK2_SEQ"   ,aAux[3],aAux[1],0})

	Aadd(aStruct, {"FK2_OK","C",2,0})
	Aadd(aStruct, {"NUM_REG","N",10,0})

Return


//---------------------------------------------------------------------
/*/{Protheus.doc}F090Grava
Faz gravação na Tabela Temporária a partir dos dados selecionados e
apresentados no FWMarkBorwse

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function F090Grava(cArqTrab, aDadosBx, lAutomato, cMarca)

	Local lRet := .T.
	Local nRecNo := 0

	DEFAULT lAutomato := .F.
	DEFAULT cMarca := If(lAutomato, cMarca, oMrkBrowse:cMark)
	DEFAULT __cLayout	:= FWSM0Layout()
	DEFAULT __lGestao	:= "E" $ __cLayout .Or. "U" $ __cLayout
	DEFAULT __cFilSA6	:= IIF( __lGestao , FwFilial("SA6") , xFilial("SA6") )

	dbSelectArea(cArqTrab)
	nRecno := (cArqTrab)->(RecNo())

	(cArqTrab)->(dbSetOrder(2))
	(cArqTrab)->(DbGoTop())

	If (cArqTrab)->(DbSeek(cMarca))
		While !(cArqTrab)->(Eof())
			If (cMarca $ (cArqTrab)->FK2_OK)
				(cArqTrab)->( AADD(aDadosBx,{ FK7_CHAVE, FK2_IDDOC, IF(!EMPTY(__cFilSA6),FK2_FILIAL,FK2_FILORI), FK2_IDFK2, FK2_SEQ }) )
			EndIf
			(cArqTrab)->(DbSkip())
		Enddo
	EndIF

	(cArqTrab)->(dbSetOrder(1))
	(cArqTrab)->(DbGoTo(nRecno))

	lRet := If (Len(aDadosBx) > 0, .T., .F.)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc}FA090AllMk
Faz gravação no cmapo FK2_OK com a marcação.
@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function FA090AllMk(oMrkBrowse,cArqTrab,lAutomato,cMarca)

	Local nReg 	 := (cArqTrab)->(Recno())

	Default cMarca := oMrkBrowse:cMark

	If lAutomato
		cMarca := GetMark()
	EndIf

	dbSelectArea(cArqTrab)
	(cArqTrab)->(DbGoTop())

	While !(cArqTrab)->(Eof())
		SE2->(dbGoto((cArqTrab)->NUM_REG))
		If SE2->(MsRLock()) .AND. (cArqTrab)->(MsRLock())
			IF	(cArqTrab)->FK2_OK == cMarca
				(cArqTrab)->FK2_OK := "  "
				(cArqTrab)->(MsUnlock())
				SE2->(MsUnlock())
			Else
				(cArqTrab)->FK2_OK := cMarca
			Endif
		Endif
		(cArqTrab)->(dbSkip())
	Enddo

	(cArqTrab)->(dbGoto(nReg))

	If !lAutomato
		oMrkBrowse:oBrowse:Refresh(.t.)
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc}
Faz gravação no cmapo FK2_OK com a marcação.
@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Function FI090Mark(cAliasTRB)

	Local lRet		:= .T.

	SE2->(dbGoto((cAliasTRB)->NUM_REG))

	If SE2->(MsRLock()) .AND. (cAliasTRB)->(MsRLock())
		// destravamos o mesmo para uso de outro terminal
		If Empty( (cAliasTRB)->FK2_OK )
			(cAliasTRB)->(MsUnlock())
			SE2->(MsUnlock())
		Endif
	Else
		lRet := .F.
	Endif

Return lRet


//--------------------------------------------------------------------------
/*/{Protheus.doc} Fa090ExcA
Rotina Automática(ExecAuto) para Cancelamento de Baixas de Titulo a Pagar

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//--------------------------------------------------------------------------
Function Fa090ExcA(aDadosBx, lAutomato)

	Local aArea       As Array
	Local aAreaSEA    As Array
	Local aDiario     As Array
	Local aFlagCtb    As Array
	Local aPerg       As Array
	Local aVetor      As Array
	Local cAgeBco     As character
	Local cArquivo    As character
	Local cCodBco     As character
	Local cCtaBco     As character
	Local cFilAtu     As character
	Local cFilOrig    As character
	Local cIDOrig     As character
	Local cNextFil    As character
	Local cPadrao     As character
	Local cSequencia  As character
	Local lAglut      As logical
	Local lCtbOnline  As logical
	Local lDigita     As logical
	Local lFlagCtbBx  As logical
	Local lPadraoBx   As logical
	Local lPadraoVd   As logical
	Local lRet        As logical
	Local lUsaFlag    As logical
	Local nHdlPrv     As numeric
	Local nRecSE2     As numeric
	Local nTamDadosBx As numeric
	Local nTotal      As numeric
	Local nX          As numeric

	aArea       := GetArea()
	aAreaSEA    := SEA->(GetArea())
	aDiario     := {}
	aFlagCtb    := {}
	aPerg       := {}
	aVetor      := {}
	cAgeBco     := ""
	cArquivo    := ""
	cCodBco     := ""
	cCtaBco     := ""
	cFilAtu     := cFilAnt
	cFilOrig    := ""
	cIDOrig     := ""
	cNextFil    := ""
	cPadrao     := "531"
	cSequencia  := ""
	lAglut      := mv_par02 == 1
	lCtbOnline  := .F.
	lDigita     := mv_par01 == 1
	lFlagCtbBx  := .F.
	lPadraoBx   := .F.
	lPadraoVd   := .F.
	lRet        := .T.
	lUsaFlag    := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	nHdlPrv     := 0
	nRecSE2     := 0
	nTamDadosBx := 0
	nTotal      := 0
	nX        	:= 0

	// VerIfica o numero do Lote
	PRIVATE cLote
	LoteCont( "FIN" )

	Private lMsErroAuto     := .F.
	Private lMsHelpAuto     := .T.
	Private lMostraErro     := .F.
	Private LanceiCTB 		:= .F.

	DEFAULT aDadosBx	:= {}
	DEFAULT lAutomato	:= .F.

	nTamDadosBx  := Len(aDadosBx)

	If nTamDadosBx > 0

		//Realiza o repasse dos perguntes conforme a o rotina informada.
		F90ResPerg(@aPerg)

		lDigita 	 := (aPerg[1] == 1) // Mostra Lançamento Contabil
		lAglut		 := (aPerg[2] == 1) // Aglutina Lançamento
		lCtbOnline   := (aPerg[3] == 1) // Contabiliza Online
		aPerg[3]	 := 2				// Ajusto para não contabilizar na FINA080 via ExecAuto
		lPadraoBx	 := VerPadrao("531")
		lPadraoVd	 := VerPadrao("519")

		ProcRegua(nTamDadosBx)

		For nX := 1 to nTamDadosBx

			aVetor 		:= {}
			lMsErroAuto := .F.
			cDadosTit 	:= FinFK7Key(aDadosBx[nX,1],"")
			cNextFil  	:= If (nX < nTamDadosBx, aDadosBx[nX+1,3], "")
			cFilOrig	:= aDadosBx[nX,3]
			cFilAnt		:= cFilOrig

			If nHdlPrv == 0 .And. lCtbOnline .And. (lPadraoBx .or. lPadraoVd)
				nHdlPrv := HeadProva( cLote, "FINA090" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
				If Len(aPerg) >= 4
					aPerg[4] := nHdlPrv
				Endif
			Endif

			dbSelectArea('SE2')
			SE2->(dbSetOrder(1)) // Filial + Fornecedor + Loja + Prefixo + Número + Parcela + Tipo

			If SE2->(MsSeek( cDadosTit ) )

				BEGIN TRANSACTION
					nRecSE2 := SE2->(RECNO())

					IncProc(STR0183 + aDadosBx[nX,1]) //"Cancelando Baixa: "

					AADD(aVetor,{"E2_FILIAL"     , SE2->E2_FILIAL        ,Nil})
					AADD(aVetor,{"E2_PREFIXO"    , SE2->E2_PREFIXO       ,Nil})
					AADD(aVetor,{"E2_NUM"        , SE2->E2_NUM           ,Nil})
					AADD(aVetor,{"E2_PARCELA"    , SE2->E2_PARCELA       ,Nil})
					AADD(aVetor,{"E2_TIPO"       , SE2->E2_TIPO          ,Nil})
					AADD(aVetor,{"E2_FORNECE"    , SE2->E2_FORNECE       ,Nil})
					AADD(aVetor,{"E2_LOJA"       , SE2->E2_LOJA          ,Nil})

					//posiciona SE5 a partir do FK2_IDFK2
					cIDOrig		:= aDadosBx[nX,4]
					cSequencia	:= aDadosBx[nX,5]

					//posiciona SE5 a partir do FK2_IDFK2
					dbSelectArea('SE5')
					SE5->(dbSetOrder(21)) //  E5_FILORIG + E5_IDORIG + E5_TIPODOC
					SE5->(DbSeek((xFilial("SE5",cFilOrig)) + cIDOrig ) )
					lFlagCtbBx := SE5->E5_LA = "S"
					cCodBco:=SE5->E5_BANCO
					cAgeBco:=SE5->E5_AGENCIA
					cCtaBco:=SE5->E5_CONTA

					MSExecAuto({|a,b,c,d,e,f,g,h,i,j,k,l| Fina080(a,b,c,d,e,f,g,h,i,j,k,l)},aVetor,5,,,,.F.,cSequencia,,,,,aPerg)

					//Em caso de erro na baixa desarma a transação
					If lMsErroAuto
						lRet:= .F.
						If !IsBlind()
							MOSTRAERRO()
						EndIf
						DisarmTransaction()
						Break
					Endif
				END TRANSACTION

				If lRet
					lDigita 	 := (aPerg[1] == 1) // Mostra Lançamento Contabil
					lAglut		 := (aPerg[2] == 1) // Aglutina Lançamento

					If UsaSeqCor()
						aAdd(aDiario,{"SE5",SE5->(RecNo()),cCodDiario,"E5_NODIA","E5_DIACTB"})
					Else
						aDiario := {}
					EndIf

					If lUsaFlag  //Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E5_LA" , "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
						aAdd( aFlagCTB, {"FK2_LA", "S", "FK2", FK2->( Recno() ), 0, 0, 0} )
					Endif

					//Carrega dados do Banco para evitar desposicionamento
					DBSelectArea("SA6")
					SA6->(dbGotop())
					SA6->(dbSetOrder(1)) // Filial+Codigo+Agencia+Conta
					SA6->(dbSeek(xFilial("SA6")+cCodBco+cAgeBco+cCtaBco))

					If lPadraoBx .and. lFlagCtbBx .and. lCtbOnline
						nTotal += F090DetPro(nHdlPrv,cPadrao,"FINA090",cLote,,,,@aFlagCTB,cFilAtu,cFilOrig)
						FINCARVAR() //Carrega as variáveis de contabilização e evita o desposicionamento (xFilial) da FK2
					EndIf

					If !lUsaFlag .AND. LanceiCTB
						RecLock("FK2",.F.)
							FK2->FK2_LA := "S"
						MsUnlock()

						RecLock("SE5",.F.)
							SE5->E5_LA := "S"
						MsUnlock()
					Endif

					If nHdlPrv > 0 .And. nTotal > 0 .And. lCtbOnline .and. (( mv_par08 == 1 .And. nX == nTamDadosBx ) .Or. (mv_par08 == 2 .And. cFilAnt != cNextFil))
						//Efetiva Lancamento Contabil
						F090Contab(cArquivo, @nHdlPrv, cLote, lDigita, lAglut, dDataBase, @aFlagCTB, aDiario, cFilAtu, cFilOrig)

						aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
						nHdlPrv  := 0
						nTotal	 := 0
						aDiario	 := {}
					Endif
				Else

					If nHdlPrv > 0 .And. nTotal > 0 .And. lCtbOnline
						//Efetiva Lancamento Contabil
						F090Contab(cArquivo, @nHdlPrv, cLote, lDigita, lAglut, dDataBase, @aFlagCTB, aDiario, cFilAtu, cFilOrig)

						aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
						nHdlPrv  := 0
						nTotal	 := 0
						aDiario	 := {}
						If !lAutomato
							MsgInfo( STR0200 , STR0151  )  ///"Cancelamento de Baixas de Títulos a Pagar foi parcialmente realizado."###"Cancelamento de Baixas a Pagar"
						Endif
					Endif
					Exit 
				Endif
			EndIf
		Next nX

		//Restaurando o grupo de perguntas
		F90ResPerg()

		cFilAnt := cFilAtu //  restaura cFilAnt para Filial logada

		If lRet .and. !lAutomato
			MsgInfo( STR0150 , STR0151  )  ///"Cancelamento de Baixas de Títulos a Pagar foi realizado com sucesso."###"Cancelamento de Baixas a Pagar"
		Endif

		SEA->(RestArea(aAreaSEA))
		RestArea(aArea)
	Endif

Return lRet


//----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FiltFilBco
Função para remover as filiais selecionadas que não possuam o banco selecionado para
baixas multi-filiais. Utilizada quando a tabela de bancos (SA6) está exclusiva.

@author pedro.alencar
@since 06/02/2020
@version 1.0
@type static function

@param aFilAux, array, Vetor com as filiais selecionadas (AdmGetFil) para a baixa
@param cChaveBco, char, Chave do banco informado (Código + Agência + Conta)
@return aRet, Vetor com a relação de filiais selecionadas que possuem o cadastro do banco informado
/*/
//----------------------------------------------------------------------------------------------------
Static Function FiltFilBco( aFilAux As Array, cChaveBco As Char ) As Array
	Local aRet As Array
	Local aAreaSA6 As Array
	Local cFilSA6 As Char
	Local nI As Numeric
	Default aFilAux := {}
	Default cChaveBco := ""

	aRet := {}
	aAreaSA6 := SA6->( GetArea() )
	SA6->( dbSetOrder(1) ) //A6_FILIAL+A6_COD+A6_AGENCIA+A6_NUMCON

	For nI := 1 To Len(aFilAux)
		cFilSA6 := FWxFilial( "SA6", aFilAux[nI] )

		If SA6->( msSeek( cFilSA6 + cChaveBco ) )
			aAdd( aRet, aFilAux[nI] )
		EndIf
	Next nI

	RestArea(aAreaSA6)
	FwFreeArray(aAreaSA6)
Return aRet


//-------------------------------------------------------------------
/*/{Protheus.doc} function F90ResPerg
Restaura os perguntes.
@Param	aPerg, Array, array para o grupo de perguntas.
@author  Vincius do Prado
@since   06/03/2020
@version P12
/*/
//-------------------------------------------------------------------
Static Function F90ResPerg(aPerg as Array)

	//Realiza o repasse dos perguntes conforme a o rotina informada.
	SetKey (VK_F12,{|a,b| AcessaPerg(__cPerg,.T.)})
	Pergunte(__cPerg,.F.)

	If(ValType(aPerg)=="A")
		AADD(aPerg,mv_par01) // Mostra Lançamento Contabil
		AADD(aPerg,mv_par02) // Aglutina Lançamento
		AADD(aPerg,mv_par03) // Contabiliza Online
		AADD(aPerg,0       ) // nHdlPrv para controle de Contabilização Online
	EndIf

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} function F90FORMATIN
Formata separadores de string para uso em cláusula IN de queries.
@author  Norberto M de Melo
@since   03/01/2017
@version P12
/*/
//-------------------------------------------------------------------
Static Function F90FORMATIN(cString as character, lFormatIN as Logical) as character

	DEFAULT cString 	:= ''
	DEFAULT lFormatIN	:= .T.

	cString	:=	StrTran(cString,',','/')
	cString	:=	StrTran(cString,';','/')
	cString	:=	StrTran(cString,'|','/')
	cString	:=	StrTran(cString,'\','/')

	If lFormatIN
		cString := Formatin(cString,"/")
	Endif

Return cString


//-------------------------------------------------------------------
/*{Protheus.doc} Fa090MnFil
Função responsavel por criar filtro para Filiais a partir de um array

@param	aFiluser - array com todas as filais para criação o filtro

@author Caio Quiqueto
@since 21/07/2015
@version P11

@return cRet - string do filtro para todas as filiais
*/
//-------------------------------------------------------------------
FUNCTION Fa090MnFil(aFiluser)
	Local cRet		:= ''
	Local nX		:= 0
	Local cRetOld	:= ""
	Local nRecSM0	:= SM0->(Recno())

	For nX := 1 to len(aFiluser)  Step 1
		cRet += aFiluser[nX] + "|"
	next

	/*Esse tratamento só será executado em casos que o sigamat possua no mínimo
	de 400 filiais. Nesse caso monta o novo filtro com as filiais que o user não
	possui acesso a fim de usar o menor filtro na IndRegua*/
	If Len(cRet) > 1500
		cRetOld := cRet
		SM0->(dbGotop())

		While SM0->(!EOF())
			If !AllTrim(xFilial("SE2",SM0->M0_CODFIL)) $ cRetOld
				cRet += AllTrim(xFilial("SE2",SM0->M0_CODFIL)) + "|"
			EndIf
			SM0->(dbSkip())
		EndDo

		If Len(cRet) > Len(cRetOld)
			cRet := cRetOld
		EndIf

		SM0->(dbGoto(nRecSM0))
	EndIf

return cRet


//-------------------------------------------------------------------
/*{Protheus.doc} F090GetNat
Função responsavel por retornar as naturezas parametrizadas para os
títulos de impostos

@param	cParam - parâmetro o qual se deseja obter o valor

@author Mauricio Pequim Jr
@since 05/11/2021
@version P12

@return cValParam - string do valor do parâmetro
*/
//-------------------------------------------------------------------
Function F090GetNat(cParam As Character)

	Local cValParam As Character

	DEFAULT cParam := ""

	cValParam := ""

	If cParam $ "MV_IRF|MV_ISS"
		cValParam := &(SuperGetMV(cParam))
	Else
		cValParam := (SuperGetMV(cParam))
	Endif

Return cValParam


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGRVSFQPCC
	
	Realiza a gravação dos relacionamentos de retenção de impostos PCC entre 
	o título retentor e os retidos

	@type  Function
	@author pequim
	@since 12/11/2021
	@version P12

	@param aImpostos , Array	, Prefixo do titulo retentor
	@param aDadosRet , Array	, Dados dos títulos cujo imposto foi retido nessa baixa
	@param cSequencia, Character, Sequência da baixa na qual o imposto foi retido
	@param cCamposPCC, Character, Dados da gravação dos campos de retenção (referência)
	@param lIRPFBaixa, Logical  , Define se a retenção do IRRF é na baixa
	@param lAplVlMin , Logical  , Fornecedor do titulo retentor
	@param nVlMinImp , Numeric  , Loja do titulo retentor
	@param lPCC241	 , Logical  , Sequência da baixa na qual o imposto foi retido

/*/
//------------------------------------------------------------------------------------------
Function FGRVSFQPCC(aImpostos As Array,aDadosRet As Array,cSequencia As Character,cCamposPCC As Character, lRetParc As Logical,;
		lIRPFBaixa As Logical, lAplVlMin As Logical, nVlMinImp As Numeric, lPCC241 As Logical)

	Local aRecnos 	AS Array
	Local cPrefOri	AS Character
	Local cNumOri 	AS Character
	Local cParcOri	AS Character
	Local cTipoOri	AS Character
	Local cCfOri	AS Character
	Local cLojaOri	AS Character
	Local cPRet		AS Character
	Local nX		AS Numeric
	Local nLoop		AS Numeric
	Local nSavRec 	AS Numeric
	Local lEmpGImp 	AS Logical
	Local cNccRet  	AS Character

	DEFAULT aImpostos	:= {}
	DEFAULT aDadosRet 	:= {}
	DEFAULT cSequencia	:= ""
	DEFAULT cCamposPCC	:= ""
	DEFAULT lRetParc 	:= .T.
	DEFAULT lIRPFBaixa	:= .F.
	DEFAULT lAplVlMin	:= .T.
	DEFAULT nVlMinImp 	:= 0
	DEFAULT lPCC241		:= .F.
	DEFAULT __cMRetPIS  := GetNewPar( "MV_RT10925", "1" )

	aRecnos	 := {}
	cPrefOri := ""
	cNumOri	 := ""
	cParcOri := ""
	cTipoOri := ""
	cCfOri	 := ""
	cLojaOri := ""
	cPRet	 := ""
	nX		 := 0
	nLoop	 := 0
	nSavRec  := 0
	//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
	//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
	//3-Nao Controla
	cNccRet  := SuperGetMv("MV_NCCRET",.F.,"1")

	lEmpGImp := !(lEmpPub .And. !__lIrfMR .AND. lIRPFBaixa .And. lAplMinP .And. ;
		(nPis + nCoFins + nCsll + nIrrf + aDadosRet[2] + aDadosRet[3] + aDadosRet[4] + aDadosRet[5] < nVlMPub .And.;
		!(aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] == 0 .And. aDadosRet[1] > 0) ) )

	cCamposPCC := ",{'E5_VRETPIS' , " + cValToChar(If(__lPccMR, __nPisMR, nPis)) + " }"
	cCamposPCC += ",{'E5_VRETCOF' , " + cValToChar(If(__lPccMR, __nCofMR, nCofins)) + " }"
	cCamposPCC += ",{'E5_VRETCSL' , " + cValToChar(If(__lPccMR, __nCslMR, nCsll)) + " }"

	Do Case
	Case __cMRetPIS == "1"
		If ((aDadosRet[ 1 ] + (nValPgto + nPis + nCofins + nCsll + nIrrf + nInss + nDescont + SE2->E2_ISS + nTotAbat - nJuros - nMulta)	> nVlMinImp) .or. !lAplVlMin) .And. lEmpGImp
			lRetParc := .T.

			//Rotina para gerar titulo de adiantamento
			If cNccRet == "1" .and. nDiferImp < 0
				FGerCredRt(Abs(nDiferImp),SE2->E2_MOEDA,SE5->E5_SEQ)
			Endif

			nSavRec := SE5->( Recno() )

			//Exclui a Marca de "pendente recolhimento" dos demais registros
			If aDadosRet[1] > 0
				aRecnos   := aClone( aDadosRet[ 6 ] )
				cPrefOri  := SE2->E2_PREFIXO
				cNumOri   := SE2->E2_NUM
				cParcOri  := SE2->E2_PARCELA
				cTipoOri  := SE2->E2_TIPO
				cCfOri    := SE2->E2_FORNECE
				cLojaOri  := SE2->E2_LOJA
				cPRet	  := " "

				For nLoop := 1 to Len( aRecnos )
					SE5->( dbGoto( aRecnos[ nLoop ] ) )

					RecLock("SE5", .F.)
					E5_PRETPIS := '2'
					E5_PRETCOF := '2'
					E5_PRETCSL := '2'
					MsUnlock()

					FK3->(DbSetOrder(2))
					For nX := 1 to Len(aImpostos)
						If aImpostos[nX,1] != "IRF"
							If FK3->(MsSeek(xFilial("FK3", SE5->E5_FILORIG) + SE5->E5_TABORI + SE5->E5_IDORIG + aImpostos[nX,1]))
								If Empty(FK3->FK3_IDRET)
									RecLock("FK3", .F.)
									FK3->FK3_IDRET := aImpostos[nX,4] 		//cIdFk4
									MsUnlock()
								Endif
							Endif
						Endif
					Next

					F090SFQGrv(cPrefOri, cNumOri, cParcOri, cTipoOri, cCfOri, cLojaOri, cSequencia)

				Next nLoop
			Endif
		Else
			If nVlRetPis + nVlRetCof + nVlRetCsl + nVlRetIrf > 0 .Or. !lEmpGImp
				IF lPCC241
					cPRet := "4"
				Else
					cPRet := "1"
				Endif

				//Atualiza a informação de retencao de impostos no titulo que está sendo baixado
				cCamposPCC += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
				cCamposPCC += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
				cCamposPCC += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
				cCamposPCC += ",{'E5_PRETPIS' , '"+cPRet+"'}"
				cCamposPCC += ",{'E5_PRETCOF' , '"+cPRet+"'}"
				cCamposPCC += ",{'E5_PRETCSL' , '"+cPRet+"'}"
			EndIf
			lRetParc := .F.
		EndIf

		//Atualiza o registro da SE2 baseado no registro da SE5, nos campos de retenção de PCC
		RecLock("SE2",.F.)
		SE2->E2_PRETPIS := If(lPCC241 .And. Empty(cPRet), "4", cPRet)
		SE2->E2_PRETCOF := If(lPCC241 .And. Empty(cPRet), "4", cPRet)
		SE2->E2_PRETCSL := If(lPCC241 .And. Empty(cPRet), "4", cPRet)
		SE2->(MsUnlock())

	Case __cMRetPIS == "2"
		//Exclui a Marca de "pendente recolhimento" dos demais registros
		If aDadosRet[1] > 0
			aRecnos  := aClone( aDadosRet [ 6 ] )
			cPrefOri := SE2->E2_PREFIXO
			cNumOri  := SE2->E2_NUM
			cParcOri := SE2->E2_PARCELA
			cTipoOri := SE2->E2_TIPO
			cCfOri   := SE2->E2_FORNECE
			cLojaOri := SE2->E2_LOJA

			For nLoop := 1 to Len( aRecnos )
				SE5->( dbGoto( aRecnos[ nLoop ] ) )

				If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)
					RecLock("SE5", .F.)
					E5_PRETPIS := '2'
					E5_PRETCOF := '2'
					E5_PRETCSL := '2'
					MsUnlock()

					FK3->(DbSetOrder(2))
					For nX := 1 to Len(aImpostos)
						If aImpostos[nX,1] != "IRF"
							If FK3->(MsSeek(xFilial("FK3", SE5->E5_FILORIG) + SE5->E5_TABORI + SE5->E5_IDORIG + aImpostos[nX,1]))
								If Empty(FK3->FK3_IDRET)
									RecLock("FK3", .F.)
									FK3->FK3_IDRET := aImpostos[nX,4] 		//cIdFk4
									MsUnlock()
								Endif
							Endif
						Endif
					Next
				EndIf

				F090SFQGrv(cPrefOri, cNumOri, cParcOri, cTipoOri, cCfOri, cLojaOri, cSequencia)

			Next nLoop
		Endif

		lRetParc := .T.

	Case __cMRetPIS == "3"
		//Grava a Marca de "pendente recolhimento" dos demais registros
		If nVlRetPis + nVlRetCof + nVlRetCsl + nVlRetIrf > 0
			//Atualiza a informação de retencao de impostos no titulo que está sendo baixado
			//Carrego o Model
			cCamposPCC += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
			cCamposPCC += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
			cCamposPCC += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
			cCamposPCC += ",{'E5_PRETPIS' , '1'}"
			cCamposPCC += ",{'E5_PRETCOF' , '1'}"
			cCamposPCC += ",{'E5_PRETCSL' , '1'}"
		EndIf

		lRetParc := .F.
	EndCase

Return


//------------------------------------------------------------------------------------
/*/{Protheus.doc} F090SFQGRV
	
	Realiza a gravação dos relacionamentos de retenção de impostos PCC entre 
	o título retentor e os retidos

	@type  Function
	@author pequim
	@since 12/11/2021
	@version p12
	@param cPrefOri	 , Character, Prefixo do titulo retentor
	@param cNumOri 	 , Character, Número do titulo retentor
	@param cParcOri  , Character, Parcela do titulo retentor
	@param cTipoOri  , Character, Tipo do titulo retentor
	@param cCfOri    , Character, Fornecedor do titulo retentor
	@param cLojaOri  , Character, Loja do titulo retentor
	@param cSequencia, Character, Sequência da baixa na qual o imposto foi retido

/*/
//------------------------------------------------------------------------------------
Function F090SFQGRV(cPrefOri AS Character, cNumOri AS Character, cParcOri AS Character, cTipoOri AS Character,cCfOri AS Character, cLojaOri AS Character, cSequencia AS Character)

	Local cMFilial As Character

	DEFAULT cPrefOri	:= ""
	DEFAULT cNumOri		:= ""
	DEFAULT cParcOri	:= ""
	DEFAULT cTipoOri	:= ""
	DEFAULT cCfOri		:= ""
	DEFAULT cLojaOri	:= ""
	DEFAULT cSequencia	:= ""
	DEFAULT __cLayout	:= FWSM0Layout()
	DEFAULT __lGestao	:= "E" $ __cLayout .Or. "U" $ __cLayout
	DEFAULT __cFilSE2	:= IIF( __lGestao , FwFilial("SE2") , xFilial("SE2") )
	DEFAULT __cFilSFQ	:= IIF( __lGestao , FwFilial("SFQ") , xFilial("SFQ") )

	If Empty( __cFilSFQ )   //Multi-Filial
		cMFilial := xFilial("SFQ")
	Else
		If Empty( __cFilSE2 )
			cMFilial := xFilial("SFQ")
		Else
			cMFilial := SE2->E2_FILIAL
		EndIf
	EndIf

	RecLock("SFQ",.T.)
	SFQ->FQ_FILIAL  := cMFilial
	SFQ->FQ_ENTORI  := "SE5"
	SFQ->FQ_PREFORI := cPrefOri
	SFQ->FQ_NUMORI  := cNumOri
	SFQ->FQ_PARCORI := cParcOri
	SFQ->FQ_TIPOORI := cTipoOri
	SFQ->FQ_CFORI   := cCfOri
	SFQ->FQ_LOJAORI := cLojaOri
	SFQ->FQ_SEQORI  := cSequencia
	SFQ->FQ_ENTDES  := "SE5"
	SFQ->FQ_PREFDES := SE5->E5_PREFIXO
	SFQ->FQ_NUMDES  := SE5->E5_NUMERO
	SFQ->FQ_PARCDES := SE5->E5_PARCELA
	SFQ->FQ_TIPODES := SE5->E5_TIPO
	SFQ->FQ_CFDES   := SE5->E5_CLIFOR
	SFQ->FQ_LOJADES := SE5->E5_LOJA
	SFQ->FQ_SEQDES  := SE5->E5_SEQ
	SFQ->FQ_FILDES	:= SE5->E5_FILIAL
	MsUnlock()

Return


//------------------- LOCALIZAÇÃO --------------------------
//-------------------------------------------------------------------
/*/{Protheus.doc} f090Talao
Validar a digitação do número do Talonário quando CH cheque for próprio.

@author Luis Samaniego
@since 04/08/2015 
@version 1.0
/*/
//-------------------------------------------------------------------
Function f090Talao(cBcoSub, cAgeSub, cCtaSub, cChqSub, cPrxSub, nRegChSub)

	Local aSavArea	:= GetArea()
	Local lRet		:= .T.
	Local nTamCta	:= TamSX3("A6_NUMCON")[1]

	DBSelectArea("FRE")
	FRE->(dbSetOrder(3)) // Filial + Banco + Agência + Conta + Talão
	If !FRE->(dbSeek(xFilial("FRE")+cBcoSub+cAgeSub+Substr(cCtaSub, 1, nTamCta)+cNumTalao))
		MsgAlert(STR0153 , STR0072 ) //"Talão de cheques não cadastrado."###"Atención" //
		lRet := .F.
	ElseIf cTipoTalao <> FRE->FRE_TIPO
		MsgAlert(STR0159 )  //"No se puede reemplazar un cheque que no sea del mismo tipo"
		lRet := .F.
	Else
		If  FRE->FRE_STATUS = "2"
			If  ObtTalCHQ(cBcoSub,cAgeSub,cCtaSub,cNumTalao)
				cChqSub := cNumCHQ
				cPrxSub := cPreCHQ
				nRegChSub := nTalCHQ
				cTipTalao := Lower(X3COMBO("FRE_TIPO",FRE->FRE_TIPO))
				If cChStatus $ "01|04"
					If oCBXMotiv != Nil
						oCBXMotiv:Enable()
					EndIf
				Else
					If oCBXMotiv != Nil
						oCBXMotiv:Disable()
					EndIf
				Endif
				lRet := .T.
			Else
				MsgAlert( STR0154 , STR0072 ) // "Chequera no disponible"
				lRet := .F.
			Endif
		Else
			MsgAlert( STR0154 , STR0072 ) // "Chequera no disponible"
			lRet := .F.
		Endif
	EndIf

	If !lRet
		lCheckSub:=.F.
		If !cChStatus $ "01/02/03/07"
			If oCBXMotiv != Nil
				oCBXMotiv:Enable()
			EndIf
		Endif
	EndIf

	If oBcoSub != Nil
		oBcoSub:Refresh()
	EndIf
	If oAgeSub != Nil
		oAgeSub:Refresh()
	EndIf
	If oCtaSub != Nil
		oCtaSub:Refresh()
	EndIf
	If oPrxSub != Nil
		oPrxSub:Refresh()
	EndIf
	If oChqSub != Nil
		oChqSub:Refresh()
	EndIf
	If oChkBoxSub != Nil
		oChkBoxSub:Refresh()
	EndIf
	If oChkBoxNul != Nil
		oChkBoxNul:Refresh()
	EndIf
	If oDtVctoSub != Nil
		oDtVctoSub:Refresh()
	EndIf
	If oCBXMotiv != Nil
		oCBXMotiv:Refresh()
	EndIf
	If oTalao != Nil
		oTalao:Refresh()
	EndIf
	If oTipTalao != Nil
		oTipTalao:Refresh()
	EndIf

	RestArea(aSavArea)

Return(lRet)


//-------------------------------------------------------------------
/*/{Protheus.doc} ObtTalCHQ
Validar a digitação do número do Talonário quando CH cheque for próprio.

@author Luis Samaniego
@since 04/08/2015 
@version 1.0
/*/
//-------------------------------------------------------------------

Static Function ObtTalCHQ(cBanco,cAgencia,cConta,cNumTalao,nOpc,nNCheque)

	Local cQrySEF	:= ""
	Local cTmpSEF	:= ""
	Local nX        := 0
	Local lRet      := .T.

	Default nOpc    := 1
	Default nNCheque:= 0

	cTmpSEF := GetNextAlias()
	cQrySEF	:= "Select EF_BANCO,EF_CONTA,EF_AGENCIA,EF_TALAO,EF_PREFIXO,EF_NUM,R_E_C_N_O_"
	cQrySEF	+= " from " + RetSqlName("SEF") + " SEF"
	cQrySEF += " where EF_FILIAL = '" + xFilial("SEF") + "'"
	cQrySEF += " and EF_CART	= 'P'"
	cQrySEF	+= " and EF_BANCO	= '" + cBanco + "'"
	cQrySEF += " and EF_AGENCIA	= '" + cAgencia + "'"
	cQrySEF += " and EF_CONTA 	= '" + cConta + "'"
	cQrySEF += " and EF_TALAO 	= '" + cNumTalao + "'"
	cQrySEF += " and EF_STATUS 	= '00' AND EF_LIBER = 'S'"
	cQrySEF	+= " and D_E_L_E_T_ = ' '"
	If  nOpc==2 //Buscar el cheque si esta disponible
		cQrySEF	+= " and EF_NUM	= '" + nNCheque + "'"
	Endif
	cQrySEF += " order by EF_BANCO,EF_AGENCIA,EF_CONTA,EF_TALAO,EF_PREFIXO,EF_NUM"
	cQrySEF	:= ChangeQuery(cQrySEF)
	DbUseArea(.T.,"TOPCONN",TCGenQry(,,cQrySEF),cTmpSEF,.F.,.T.)
	(cTmpSEF)->(dbGoTop())

	nX := 0
	While !((cTmpSEF)->(EOF()))
		nX++
		If  !(nOpc==2)
			cNumCHQ := (cTmpSEF)->EF_NUM
			cPreCHQ := (cTmpSEF)->EF_PREFIXO
			nTalCHQ := (cTmpSEF)->R_E_C_N_O_
			SEF->(DbGoTo(nTalCHQ))
			If (SEF->(DbRlock(nRecChqSub)))
				Exit
			EndIf
		Endif
		(cTmpSEF)->(dbSkip())
	Enddo
	dbSelectArea(cTmpSEF)
	DbCloseArea()
	If  nX==0
		If  !(nOpc==2)
			MsgAlert(STR0102)  //"Não foi encontrado cheque disponivel para este pagamento!"
		Endif
		lRet:=.F.
	Endif

Return(lRet)

//-------------------------------------------------------------------------
/*/{Protheus.doc} F090CRatIR
Função para criar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param 
/*/
//-------------------------------------------------------------------------
Function F090CRatIR() As Object

	Local cCdRetIRRt	As Character

	cCdRetIRRt    := SuperGetMv("MV_RETIRRT",.T.,"3208")

	F090LRatIR(.F.)

	If Alltrim(SE2->E2_CODRET) $ cCdRetIRRt
		If FindFunction("FinXRatIR")
			If __oRatIRF == Nil
				__oRatIRF := FinBCRateioIR():New()
			EndIf
			__oRatIRF:SetFilOrig(cFilAnt)
			__oRatIRF:SetForLoja(SE2->E2_FORNECE,SE2->E2_LOJA)
			__oRatIRF:SetIRBaixa(.T.)
		EndIf
	EndIf

Return __oRatIRF

//-------------------------------------------------------------------------
/*/{Protheus.doc} F090LRatIR
Função para limpar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param lExclui, Logical, Define se ira excluir o Objeto da memoria
/*/
//-------------------------------------------------------------------------
Function F090LRatIR(lExclui as Logical)

	Default lExclui := .T.

	If __oRatIRF <> Nil
		__oRatIRF:Clean()
		If lExclui
			FwFreeObj(__oRatIRF)
			__oRatIRF := Nil
		EndIf
	EndIf

Return

//-------------------------------------------------------------------------
/*/{Protheus.doc} F090SRatIR
Função para setar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param oObj, Object, Objeto que sera atribuido ao oRatIrf
/*/
//-------------------------------------------------------------------------
Function F090SRatIR(obj as Object)
	__oRatIRF := obj
Return


//-------------------------------------------------------------------------
/*/{Protheus.doc} FinExp090
	Apresenta uma tela informando que a rotina sera descontinuada
	@type  Function
	@author reynaldo
	@since 30/06/2021
	@version 1.0
	@param cExpirFunc, caracter, nome da rotina que deve ser descontinuada
/*/
//-------------------------------------------------------------------------
Function FinExp090(cExpirFunc)
	Local dDate      	as date
	Local oProfile   	as object
	Local aLoad      	as array
	Local cShow      	as character
	Local lCheck     	as logical
	Local cExpiraData	as character
	Local nPauseDays	as numeric
	Local cLinkTDN      as character
//
// Data de expiração da rotina
//
	cExpiraData	:= "20220404"

//
// numero de dias que pode ser desabilitada a mensagem
//
	nPauseDays	:= 30

	cLinkTDN	:= "https://tdn.totvs.com/pages/viewpage.action?pageId=606846610"

	dDate := Date()
	oProfile := FwProFile():New()
	oProfile:SetTask("ESTExpired") //Nome da sess?o
	oProfile:SetType(cExpirFunc) //Valor
	aLoad := oProfile:Load()
	If Empty(aLoad)
		cShow := "00000000"
	Else
		cShow := aLoad[1]
	Endif

// reseta o controle de nPauseDays dias e volta apresentar a tela de advertencia
	If cShow <> "00000000" .and. STOD(cShow) + nPauseDays <= dDate
		cShow := "00000000"
		oProfile:SetProfile({cShow})
		oProfile:Save()
	ENDIF

	If cShow == "00000000"
		lCheck := DlgExp090(cExpirFunc,cExpiraData, nPauseDays, cLinkTDN)

		If lCheck
			cShow := dtos(date())
			oProfile:SetProfile({cShow})
			oProfile:Save()
		EndIf

	EndIf

	oProfile:Destroy()
	oProfile := nil
	aLoad := aSize(aLoad,0)
	aLoad := nil

RETURN

//----------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DlgExp090
	Apresenta uma tela informando que a rotina sera descontinuada
	@type  Function
	@author reynaldo
	@since 30/06/2021
	@version 1.0
	@param cExpirFunc, caracter, função que está sendo expirada
	@param cExpiraData, caracter, data de experiração a ser informada deve estar no formato AAAAMMDD
	@param nPauseDays, numeric, numero de dias que a mensagem pode ser ocultada
	@param cDescrFunc, caracter, descricaod a rotina e nome da rotina que substitui a rotina descontinuada
	@param cLinkTDN, caracter, endere?o http referente a rotina que esta sendo descontinuada
	@return lCheck, logico, Verdadeiro se foi escolhido para desabilitar a mensagem por 3O dias
/*/
//----------------------------------------------------------------------------------------------------------------
Static Function DlgExp090(cExpirFunc as character, cExpiraData as character, nPauseDays as numeric, cLinkTDN as character)
	local oSay1		as object
	local oSay2		as object
	local oSay3		as object
	local oSay4		as object
	local oCheck1	as object
	local oModal	as object
	Local cMsg1		as character
	Local cMsg2		as character
	Local cMsg3		as character
	Local cMsg4		as character
	Local cDescr	as character
	Local lCheck	as logical
	Local nLin2		as numeric
	Local nLin3		as numeric
	Local nLin4		as numeric

	oModal := FWDialogModal():New()
	oModal:SetCloseButton( .F. )
	oModal:SetEscClose( .F. )
	oModal:setTitle(STR0190)	//"Comunicado Ciclo de Vida de Software - TOTVS Linha Protheus"

//define a altura e largura da janela em pixel
	oModal:setSize(180, 250)

	oModal:createDialog()

	oModal:AddButton( STR0039, {||oModal:DeActivate()}, STR0039, , .T., .F., .T., ) // "Confirmar"

	oContainer := TPanel():New( ,,, oModal:getPanelMain() )
	oContainer:Align := CONTROL_ALIGN_ALLCLIENT


	cMsg1  := STR0191	//'Essa rotina será descontinuada e não sofrerá mais manutenções em nenhum release a partir de 04/04/2022 e ficará indisponível a partir de 01/08/2022 para o release 12.1.33 e posteriores.'
	cDescr := STR0192	//'Seus recursos e funcionalidades foram implementadas na rotina FINA090 (Baixa Automática).'
	nLin2  := 40
	nLin3  := 60
	nLin4  := 80

	cMsg2 := i18n("<b>" + cDescr + "</b>", {} )
	cMsg4 := STR0195	//"Para maiores informações, favor contatar o administrador do sistema ou seu ESN TOTVS."

	oSay1 := TSay():New( 10,10,{||cMsg1 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

	oSay2 := TSay():New( nLin2,10,{||cMsg2 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

	cMsg3 := STR0196 +space(01)	//"Para conhecer mais sobre a convergência entre essas rotinas,"
	If ! Empty(cLinkTDN)
		cMsg3 += "<b><a target='_blank' href='"+cLinkTDN+"'> "
		cMsg3 += STR0197	//"clique aqui"
		cMsg3 += " </a></b>."
		cMsg3 += "<span style='font-family: Verdana; font-size: 12px; color: #565759;' >" + ' ' +"</span>"
		oSay3 := TSay():New(nLin3,10,{||cMsg3},oContainer,,,,,,.T.,,,220,20,,,,,,.T.)
		oSay3:bLClicked := {|| MsgRun( STR0198, "URL",{|| ShellExecute("open",cLinkTDN,"","",1) } ) } // "Abrindo o link... Aguarde..."
	EndIf
	oSay4 := TSay():New( nLin4,10,{||cMsg4 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

	lCheck := .F.
	oCheck1 := TCheckBox():New(100,10,i18n(STR0199,{strzero(nPauseDays,2)}) ,{|x|If(Pcount()==0,lCheck,lCheck:=x)},oContainer,220,21,,,,,,,,.T.,,,) // "Não apresentar esta mensagem nos proximos #1[30]# dias."

	oModal:Activate()

Return lCheck
//-------------------------------------------------------------------------
/*/{Protheus.doc} F000RatIr
Retorna array do rateio de IRPF, indicando que houve alteração de valor

@author Pâmela Bernardo
@since  12/01/2022
@version 1
/*/
//-------------------------------------------------------------------------
Function F090RatIr()
	Local aRet As Array

	aRet := {}
	If __oRatIRF <> Nil
		aRet := __oRatIRF:aRatIRF
	EndIf

Return aRet


/*/{Protheus.doc} AjustaPerg
	Proteção para o caso das perguntas MV_PAR08 e MV_PAR09 não existirem na base (caso do MI).
	@type function
	@version 12.1.2210
	@author guilherme.sordi
	@since 31/01/2023
/*/
Static Function AjustaPerg()

	IF Empty(mv_par08)
		mv_par08 := 2
	Endif

	IF TYPE("mv_par09") <> 'N' .OR. Empty(mv_par09)
		mv_par09 := 2
	Endif

	//Caso não tenha o novo grupo de perguntas, seto Considera Filiais = Não
	If __cPerg == "FIN090"
		mv_par06 := If(cPaisloc != "BRA", 2, mv_par06)
		mv_par07 := 2
	EndIf

Return Nil
