#INCLUDE "PROTHEUS.CH"
#INCLUDE "FISXATF.CH"

STATIC _lDefTopCTB	:= IfDefTopCTB()
STATIC lIpiExc		:= SuperGetMv("MV_ATFEIPI",.F., .F.) 
STATIC __lAFHasF4 	:= NIL

/*
DeprecAtivo 
Retorna a depreciacao do periodo dos bens utilizados na fabricacao de produtos 
destinados a venda, que sera utilizada no calculo do PIS. 
pelo usuario e adicionar na matriz de campos que poder ser alterados
*/
Function DeprecAtivo(dDtIni, dDtFim, lRetVCred, lFiltro, aProcItem, lRelBasApr, lProcBase, cNATBCCrd, cMs_Fil, lContaBem, aTiposExc, lCCBem, lAquisicao, aFilsCalc, cAqDpr)
//Estas funcoes foram retiradas deste fonte e incluido no fonte fisxatf.prx e deverão ser substituidas pelo nome novo
//pois somente o fonte fisxatf sofrerá manutencao - somente foram redirecionada para manter legado
//Alert("Esta funcao foi redirecionada para fonte fisxatf.prx - Devera ser invocada como _DeprecAtivo()")
Return( _DeprecAtivo(@dDtIni, @dDtFim, @lRetVCred, @lFiltro, @aProcItem, @lRelBasApr, @lProcBase, @cNATBCCrd, @cMs_Fil, @lContaBem, @aTiposExc, @lCCBem, @lAquisicao, aFilsCalc, cAqDpr) )

/*
AtfRegF130
Geracao de arquivo temporario para gerar registro F130 do SPED FISCAL PIS/COFINS
*/
Function AtfRegF130(cFilProc, dDtIni, dDtFim, cCdBaseIni, cCdBaseFim, cAliasTmp, lRelBasApr, cNATBCCrd, aTiposExc)
//Estas funcoes foram retiradas deste fonte e incluido no fonte fisxatf.prx e deverão ser substituidas pelo nome novo
//pois somente o fonte fisxatf sofrerá manutencao - somente foram redirecionada para manter legado
//Alert("ESta funcao foi redirecionada para o fonte fisxatf.prx - Devera ser chamada por _AtfRegF130()")
Return( _AtfRegF130(@cFilProc, @dDtIni, @dDtFim, @cCdBaseIni, @cCdBaseFim, @cAliasTmp, @lRelBasApr, @cNATBCCrd, @aTiposExc) )

/*/{Protheus.doc} _DeprecAtivo
Retorna a depreciacao do periodo dos bens utilizados na fabricacao de produtos 
destinados a venda, que sera utilizada no calculo do PIS.
pelo usuario e adicionar na matriz de campos que poder ser alterados   	
@type Function
@since 13/12/2002
@author TOTVS
@param dDtIni, Date, Data inicial do período de depreciacao
@param dDtFim, Date, Data Final do período de depreciacao
@param lRetVCred, Logical, Retorna Valor Credito
@param lFiltro, Logical, habilita o filtro pela data de aquisição
@param aProcItem, Array, Array contendo os perguntes utilizados (ativo, datas, tabela temporaria)
@param lRelBasApr, Logical, Rel Base Apropriação
@param lProcBase, Logical, Flag para indicar se devera processar o calculo pela base (DEFAULT eh .T. = Processa)
@param cNATBCCrd, Character, Código de Base de Cálculo do Credito (09 ou 11)
@param cMs_Fil, Character, Codigo da filial posicionado
@param lContaBem, Logical, Baseado na conta contabil do bem imobilizado ( IIF(lContaBem == .T.,N3_CCONTAB,N3_CDEPREC) )
@param aTiposExc, Array, Tipos de ativos que não são considerados o valor do mesmo para base de calculo de PIS/COFIN
@param lCCBem, Logical, Considera ou não o centro de custo
@param lAquisicao, Logical, Considera inicio de depreciação ou data de aquisição
@param aFilsCalc, Array, Filiais de Calculo
@param cAqDpr, Character, Arquivo de depreciação
/*/
Function _DeprecAtivo(dDtIni as Date, dDtFim as Date, lRetVCred as Logical, lFiltro as Logical, aProcItem as Array, lRelBasApr as Logical, lProcBase as Logical,;
                     cNATBCCrd as Character, cMs_Fil as Character, lContaBem as Logical, aTiposExc as Array, lCCBem as Logical, lAquisicao as Logical, aFilsCalc as Array, cAqDpr as Character)

Local aAreaSn1 as Array
Local aAreaSn3 as Array
Local aAreaSn4 as Array
Local aAreaSD1 as Array
Local aArea as Array
Local aTemp as Array
Local aDatas as Array
Local aStru as Array

Local cAliasTmp as Character
Local cFiltro as Character
Local cIndTmp as Character
Local cArqIndSD1 as Character
Local cAtivIni as Character
Local cAtivFim as Character
Local cArqATI as Character
Local cArqAtiv as Character
Local cMoedAtf as Character

Local dAquisicao as Date
Local dDtAtivIni as Date
Local dDtAtivFim as Date
Local dPeriodo as Date
Local dLimite as Date

Local lQuery as Logical      
Local lProcItem as Logical

Local nRet as Numeric
Local nIndex as Numeric
Local nBaseCred as Numeric 
Local nMeses as Numeric
Local nMesRef as Numeric
Local nIndSD1 as Numeric
Local nBaseItem as Numeric            
Local nRetItem as Numeric
Local nMes as Numeric
Local nAno as Numeric
Local nX as Numeric
Local nVlRatF as Numeric

Local nVlBsCl as Numeric
Local nFLDBase as Numeric
Local aAtivo as Array
Local lRecNotFis as Logical

Local aRelImp as Array
Local nScanPis as Numeric
Local cCpAlPisEn as Character
Local nScanCof as Numeric
Local cCpAlCofEn as Character
Local cXFor as Character
Local lShared as Logical
Local aSldSN4 as Array
Local nVlrBaixa as Numeric
Local cTipoNotIn as Character
Local lConsSN1 as Logical
Local lN1MSFIL as Logical

Local nTxDepr as Numeric

Local aModoComp as Array
Local nRecnSD1 as Numeric

Local cFilBack as Character
Local nLoop as Numeric
Local nForFilial as Numeric

Local lPISCOF12 as Logical
Local cProdSN1 as character
Local nMAlqPis as Numeric
Local nMAlqCof as Numeric
Local lHasSF4  as Logical

Default dDtIni     := ctod("") 
Default dDtFim     := ctod("")
Default lRetVCred  := .F.
Default lFiltro	   := .F.                                                                                
Default aProcItem  := {} 
Default lRelBasApr := .F. 
Default lProcBase  := .F. //Parâmetro obsoleto - 02/07/2024
Default	cNATBCCrd  := ""
Default cMs_Fil    := cFilAnt
Default lContaBem  := .T.
Default aTiposExc  := {'10','02','42','04','05','06','08','09'} 
Default	lCCBem     := SuperGetMv("MV_ATFCCMV",.F., .T.) //.T. = Considera Centro Custo Cpo N3_CCUSTO (Padrao) .F. =Considera CC das Movimentacoes (SN4) N4_CCUSTO
Default lAquisicao := .F.  //PARA ESTABELECER DLIMITE --> .F. = Considera DATA INICIO DEPRECIACAO (PADRAO) .T. = DATA DE AQUISICAO 

DEFAULT aFilsCalc := MatFilCalc(.F.)

Default cAqDpr := ""

aAreaSn1   := SN1->(GetArea())
aAreaSn3   := SN3->(GetArea())
aAreaSn4   := SN4->(GetArea())
aAreaSD1   := SD1->(GetArea())
aArea      := GetArea()
aTemp      := {}
aDatas     := {}                           
aStru      := {}
cAliasTmp  := ""
cFiltro    := ""
cIndTmp    := ""
cArqIndSD1 := ""
cAtivIni   := ""
cAtivFim   := "ZZZZZZZZZZ"
cArqATI    := ""
cArqAtiv   := "ATI"
cMoedAtf   := ""
dAquisicao := CToD( "" ) 
dDtAtivIni := CToD( "" ) 
dDtAtivFim := CToD( "" ) 
dPeriodo   := CToD( "" ) 
dLimite    := CToD( "" )
lQuery     := .F.      
lProcItem  := .F.
nRet       := 0
nIndex     := 0
nBaseCred  := 0  
nMeses     := 48
nMesRef    := 48
nIndSD1    := 0
nBaseItem  := 0            
nRetItem   := 0
nMes       := 0
nAno       := 0
nX         := 1
nVlRatF    := 0
nVlBsCl    := SuperGetMv("MV_BSCREPC",,1) //1 = Valor do bem Imobilizado e 2= Valor de Aquisição do Ativo
nFLDBase   := SuperGetMv("MV_FLDBSCR",,1) //1=D1_TOTAL, 2=D1_BASEIMP
aAtivo     := {}
lRecNotFis := .F.
aRelImp    := MaFisRelImp("MT100",{ "SD1" })
nScanPis   := 0
cCpAlPisEn := ""
nScanCof   := 0
cCpAlCofEn := ""
cXFor      := ""
lShared    := .F.
aSldSN4    := {}
nVlrBaixa  := 0
cTipoNotIn := ""
lConsSN1   := .T.
lN1MSFIL   := SN1->(FieldPos("N1_MSFIL"))> 0 .AND. FWModeAccess("SN1",3)=="C"
nTxDepr    := 0
aModoComp  := {}
nRecnSD1   := 0

cFilBack   := cFilAnt
nLoop      := 0 
nForFilial := 0
nMAlqPis   := 0
nMAlqCof   := 0

lPISCOF12 := SuperGetMV("MV_ATFDP12",, .T.) // Habilita o calculo de depreciação do ativo somente pelo tipo 12 (Valor Recuperavel de Ativo).
cProdSN1  := ""

lHasSF4   := If(FindFunction("ATFHasSF4"),ATFHasSF4(),.F.)

dbSelectArea("SD1")
dbSetOrder(1)

cTipoNotIn	:= ""
#IFNDEF TOP	
For nX := 1 TO Len(aTiposExc)
	cTipoNotIn	+= aTiposExc[nX]
	cTipoNotIn	+= If(nX<Len(aTiposExc), "|", "")
Next
#ELSE
For nX := 1 TO Len(aTiposExc)
	cTipoNotIn	+= "'"+aTiposExc[nX]
	cTipoNotIn	+= If(nX<Len(aTiposExc), "',", "'")
Next
#ENDIF	

dbSelectArea("SN1")
aAdd(aModoComp, FWModeAccess("SN1",1) )
aAdd(aModoComp, FWModeAccess("SN1",2) )
aAdd(aModoComp, FWModeAccess("SN1",3) )
lShared := Ascan(aModoComp, 'C') > 0

lConsSN1 	:= lCCBem  //se for cc bem considera sempre do SN1

/*/³Verifica se as depreciacoes serao processadas item a item.³
//³Conteudo do array aProcItem:                              ³
//³[01] = Codigo do ativo inicial a ser processado           ³
//³[02] = Codigo do ativo final a ser processado             ³
//³[03] = Data de aquisicao inicial a ser processada         ³
//³[04] = Data de aquisicao final a ser processada           ³
//³[05] = Alias do arquivo temporario a ser criado           ³/*/
If GetMv("MV_ATFMDF", ,"0") == "0"
	cMoedAtf := "1"
Else
	cMoedAtf := AllTrim(GetMv("MV_ATFMOED"))
Endif

If Len(aProcItem) > 0

	lProcItem	:= .T.
	
	cAtivIni 	:= aProcItem[01]
	cAtivFim 	:= aProcItem[02]
	dDtAtivIni 	:= aProcItem[03]
	dDtAtivFim 	:= aProcItem[04]	
	cArqAtiv	:= aProcItem[05]
	
	// Cria o arquivo temporário que ira receber as depreciacoes de cada um dos itens
	AADD(aStru,{"BEM"			,"C"	,TamSx3("N4_CBASE")[1],0})
	AADD(aStru,{"ITEM"			,"C"	,TamSx3("N4_ITEM")[1],0})
	AADD(aStru,{"DESCRI"		,"C"	,TamSx3("N1_DESCRIC")[1],0})
	AADD(aStru,{"BASE"			,"N"	,013,2})
	AADD(aStru,{"VRET"			,"N"	,013,2})
	AADD(aStru,{"DTAPR"			,"D"	,008,0})

	AADD(aStru,{"NATBCCRED"		,"C"	,002,0})
	AADD(aStru,{"INDBEMIMOB"	,"C"	,002,0})
	AADD(aStru,{"INDORIGCRD"	,"C"	,001,0})
	AADD(aStru,{"INDUTILBEM"	,"C"	,001,0})
	AADD(aStru,{"CSTPIS"		,"C"	,002,0})
	
	//PARC_OPER_NAO_BC_CRED -- CAMPO 07 DO LEIAUTE - CAMPO VLRBCEXC
	AADD(aStru,{"VLRBCEXC"		,"N"	,018,2})
	
	AADD(aStru,{"VLRBCPIS"		,"N"	,018,2})
	AADD(aStru,{"ALIQPIS"		,"N"	,008,4})
	AADD(aStru,{"VLRPIS"		,"N"	,018,2})
	AADD(aStru,{"CSTCOFINS"		,"C"	,002,0})
	AADD(aStru,{"VLRBCCOFIN"	,"N"	,018,2})
	AADD(aStru,{"ALIQCOFINS"	,"N"	,008,4})
	AADD(aStru,{"VLRCOFINS"		,"N"	,018,2})
	AADD(aStru,{"CODCONTA"		,"C"	,TamSx3("N3_CCONTAB")[1],0})
	AADD(aStru,{"CODCCUSTO"		,"C"	,TamSx3("N3_CCUSTO")[1],0})
	AADD(aStru,{"DESCBEMIMO"	,"C"	,250,0})
	
	//campos a ser utilizado pelo pessoal do N3-FISCAL (caio.martins)
	AADD(aStru,{"NOTAFISCAL"	,"C"	,Len(SN1->N1_NFISCAL),0})
	AADD(aStru,{"SERIE"			,"C"	,Len(SN1->N1_NSERIE),0})
	AADD(aStru,{"FORNECEDOR"	,"C"	,Len(SN1->N1_FORNEC),0})
	AADD(aStru,{"LOJA"			,"C"	,Len(SN1->N1_LOJA ),0})
	AADD(aStru,{"NUMPRO"		,"C"	,10,0})
	AADD(aStru,{"INDPRO"		,"C"	,1,0})

	cArqATI	:=	CriaTrab(aStru)
	dbUseArea(.T.,__LocalDriver,cArqATI,cArqAtiv)
	IndRegua(cArqAtiv,cArqATI,"BEM+ITEM+DTOS(DTAPR)")
	
	AADD(aTemp,{cArqATI,cArqAtiv})

	//Tratamento para formatar o IN() de ambiente TOP
	If !Empty(cNATBCCrd)
		cXFor	:=	"'"+SubStr(cNATBCCrd,1,2)+"'"
		For nX := 4 To Len(cNATBCCrd) Step 3
			cXFor	+=	",'"+SubStr(cNATBCCrd,nX,2)+"'"
		Next nX
		cNATBCCrd	:=	cXFor		
	EndIf
Endif

//Cria um array com todos os periodos que serao processados, para imprimir
//mes a mes cada um dos bens quando necessario.                            
If lProcItem   
	For dPeriodo := dDtIni to dDtFim
		If nMes <> Month(dPeriodo) .Or. nAno <> Year(dPeriodo)
			nMes 		:= Month(dPeriodo)	                    
			nAno 		:= Year(dPeriodo)
			aAdd(aDatas,{dPeriodo,LastDay(dPeriodo)})      
		Endif
	Next                                        

	//Posiciono o campo correto com a base do PIS da tabela SD1
	If !Empty( nScanPis := aScan(aRelImp,{|x| x[1]=="SD1" .And. x[3]=="IT_ALIQPS2"} ) )
		cCpAlPisEn := aRelImp[nScanPis,2]
	EndIf
	
	//Posiciono o campo correto com a base da COFINS da tabela SD1
	If !Empty( nScanCof := aScan(aRelImp,{|x| x[1]=="SD1" .And. x[3]=="IT_ALIQCF2"} ) )
		cCpAlCofEn := aRelImp[nScanCof,2]
	EndIf
Else 
	aAdd(aDatas,{dDtIni,dDtFim})							
Endif

For nForFilial := 1 To Len(aFilsCalc)
	If !aFilsCalc[nForFilial][1]
		Loop
	EndIf
	cFilAnt	:= aFilsCalc[nForFilial][2]
		
			lQuery := .T.
		
			//Query utilizada para processar somente as depreciacoes dos ativos com CALCPIS = Sim ou Fracao
			//Montagem da somatoria dos valores depreciados (N4_VLROC1).                                  
		   	cAliasTmp := GetNextAlias()                           

	       	cFiltro := "SELECT N4_DATA,N4_CBASE,N4_ITEM,N1_CBASE,N1_DESCRIC,N1_CALCPIS,SUM(SN4.N4_VLROC"+ AllTrim(cMoedAtf) + " ) SOMA " 
	       	cFiltro += ",N3_AQUISIC,N3_DINDEPR,N3_CODBAIX,N1_MESCPIS,N4_TXDEPR " 
		   
		   	cFiltro += ",N1_ORIGCRD"
		   	cFiltro += ",N1_CSTPIS"
			cFiltro += ",N1_ALIQPIS"
			cFiltro += ",N1_CSTCOFI"
			cFiltro += ",N1_ALIQCOF"
			cFiltro += ",N1_DETPATR"
			cFiltro += ",N1_UTIPATR"
			cFiltro += ",N1_NFITEM"
			cFiltro += ",N1_CODBCC"
			cFiltro += ",N1_NUMPRO"
			cFiltro += ",N1_INDPRO"
			cFiltro += ",N1_AQUISIC"
            //campos criados para verificar se base do pis considera da nota ou do bem  e se calcula PIS registrado no movimento SN4
			cFiltro += ",N1_CBCPIS"
			cFiltro += ",N4_CALCPIS"
			cFiltro += ",N4_TIPO"
			cFiltro += ",N4_MOTIVO"
			cFiltro += ",N3_FILORIG"
			If lContaBem
				cFiltro += ",N1_NFISCAL, N1_NSERIE, N1_FORNEC, N1_LOJA,N3_CCONTAB"
				If lCCBem
					cFiltro += ",N3_CCUSTO "
				Else
					cFiltro += ",N4_CCUSTO "
				EndIf
			Else
				cFiltro += ",N1_NFISCAL, N1_NSERIE, N1_FORNEC, N1_LOJA,N3_CDEPREC "
				If lCCBem
					cFiltro += ",N3_CCUSTO "
				Else
					cFiltro += ",N4_CCUSTO "
				EndIf
			EndIf
		   	
		   	cFiltro += " FROM "+RetSqlName("SN1")+" SN1,"
		   	cFiltro +=         RetSqlName("SN3")+" SN3,"
		   	cFiltro +=         RetSqlName("SN4")+" SN4 "
		   	cFiltro += " WHERE "
		   	cFiltro += "N1_FILIAL='"+xFilial("SN1")+"' AND "
			If  !Empty(cMs_Fil) .And. lN1MSFIL  //se tabela SN1 eh compartilhada e passado o parametro cMs_Fil
				//dbSelectArea("SN1")
				cFiltro += "N1_MSFIL='"+cMs_Fil+"' AND "
			EndIf
		   	If lConsSN1  //se considera do cadastro do ativo o campo calcula pis
			   	cFiltro += "N1_CALCPIS IN ('1','S','3') AND "
			   	cFiltro += "(N1_MESCPIS <> 1 OR N1_CODBCC <> '10') AND "
		   	Else         //considera do arquivo de movimento (SN4) tem q ter o campo criado    
		   		cFiltro += "N4_CALCPIS IN ('1','S','3') AND "
			Endif
					   
		   	If lProcItem
	   		   cFiltro += "N1_CBASE >= '" + cAtivIni + "' AND " 
	   		   cFiltro += "N1_CBASE <= '" + cAtivFim + "' AND "
			   cFiltro += "N1_AQUISIC >= '" + DtoS(dDtAtivIni) + "' AND "
			   cFiltro += "N1_AQUISIC <= '" + DtoS(dDtAtivFim) + "' AND "
		   	Endif
		   	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Utilizado pelo SPED Pis/Cofins (FISCAL) para processar um ³
			//³determinado tipo de credito.                              ³
			//³Obs.: Ao alterar o MATR927 analisar o MATA996, pois       ³
			//³as rotinas apresentam as mesmas informações.              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(cNATBCCrd) .And. FunName() <> "MATR927" .And. FunName() <> "MATA996"
				cFiltro += "N1_CODBCC IN("+cNATBCCrd+") AND "
	 		EndIf
			
		   	cFiltro += "SN1.D_E_L_E_T_=' ' AND "
		   	cFiltro += "N3_FILIAL='"+xFilial("SN3")+"' AND "
		   	cFiltro += "N3_CBASE = N1_CBASE AND "
		   	cFiltro += "N3_ITEM  = N1_ITEM  AND "
		   	
		   	If !Empty(cTipoNotIn)
			   	//Quando o tipo do Item for igual a 10 nao deve ser considerado o valor
			   	//do mesmo para base de calculo de PIS/COFINS
				//Conforme Instrucao Normativa SRF 457 de 18/10/2001 art. 2/4 os tipo 2 e 42
				//nao devem fazer parte do credito de PIS/COFINS " 
				//por solicitacao analista Mauro Afonso Goncalves - N3 - FISCAL
			   	cFiltro += "N3_TIPO NOT IN("+cTipoNotIn+") AND "		                             
		   	EndIf
		   	
		   	cFiltro += "SN3.D_E_L_E_T_=' ' AND "
		   	cFiltro += "N4_FILIAL='"+xFilial("SN4")+"' AND "
		   	cFiltro += "N4_CBASE = N1_CBASE AND "
		   	cFiltro += "N4_ITEM  = N1_ITEM  AND "
		   	cFiltro += "N4_TIPO  = N3_TIPO  AND "
		   	cFiltro += "N4_SEQ	= N3_SEQ AND "
		   	cFiltro += "N4_DATA>='"+Dtos(dDtIni)+"' AND "
		   	cFiltro += "N4_DATA<='"+Dtos(dDtFim)+"' AND "
		   	If lPISCOF12
				cFiltro += "N4_OCORR IN ('06','10','20') AND "
			Else
				cFiltro += "N4_OCORR IN ('06','10') AND "
			EndIf
		   	cFiltro += "N4_TIPOCNT ='3' AND "
		   	cFiltro += "SN4.D_E_L_E_T_=' '"
		   	
		   	cFiltro += " GROUP BY N4_DATA,N4_CBASE,N4_ITEM,N1_CBASE,N1_DESCRIC,N1_CALCPIS"		   
	    	cFiltro += ",N3_AQUISIC,N3_DINDEPR,N3_CODBAIX,N1_MESCPIS,N4_TXDEPR " 
		   
		   	cFiltro += ",N1_ORIGCRD"
		   	cFiltro += ",N1_CSTPIS"
			cFiltro += ",N1_ALIQPIS"
			cFiltro += ",N1_CSTCOFI"
			cFiltro += ",N1_ALIQCOF"
			cFiltro += ",N1_DETPATR"
			cFiltro += ",N1_UTIPATR"
			cFiltro += ",N1_NFITEM"
			cFiltro += ",N1_CODBCC"
			cFiltro += ",N1_NUMPRO"
			cFiltro += ",N1_INDPRO"
			cFiltro += ",N1_AQUISIC"
            //campos criados para verificar se base do pis considera da nota ou do bem  e se calcula PIS registrado no movimento SN4
			cFiltro += ",N1_CBCPIS"
			cFiltro += ",N4_CALCPIS"
			cFiltro += ",N4_TIPO"
			cFiltro += ",N4_MOTIVO"
			cFiltro += ",N3_FILORIG"
			If lContaBem
				cFiltro += ",N1_NFISCAL, N1_NSERIE, N1_FORNEC, N1_LOJA,N3_CCONTAB "
				If lCCBem
					cFiltro += ",N3_CCUSTO "
				Else
					cFiltro += ",N4_CCUSTO "
				EndIf
			Else
				cFiltro += ",N1_NFISCAL, N1_NSERIE, N1_FORNEC, N1_LOJA,N3_CDEPREC "
				If lCCBem
					cFiltro += ",N3_CCUSTO "
				Else
					cFiltro += ",N4_CCUSTO "
				EndIf
			EndIf

			If ExistBlock( 'DEPRECQRY' )
				cFiltro := Execblock( 'DEPRECQRY' , .F. , .F. , {cFiltro} )
			Endif			
		   	
		   	cFiltro := ChangeQuery(cFiltro)
		   	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cFiltro),cAliasTmp,.T.,.T.)
		   
		   	//Gravando Temporario do processamento por item
			Do While !(cAliasTmp)->(Eof())

				nAliqPis	:=	0
				nAliqCof	:=	0	
				cOrigCred	:=	""
				cCstPis	    :=	""
				cCstCofin	:=	""
				lAchouSF4	:=	.F. 	
				nRecnSD1    := 0		
				nMAlqPis	:= 0
				nMAlqCof	:= 0

				If lPISCOF12 .And. (cAliasTmp)->N4_TIPO # '12' .And. ATFTipo12((cAliasTmp)->N4_CBASE, (cAliasTmp)->N4_ITEM)
					// Solicitação da Consultoria Tributária, onde o calculo da depreciação para a base do PIS e COFINS deverá ser feita apenas no registro
					// da tabela SN3 de tipo 12. Caso o ativo não tenha um tipo 12, o calculo deverá seguir o procedimento antigo. Issue = DSERCTR1-43493.
					(cAliasTmp)->(DBSkip())
					Loop
				EndIf

	             //campos criados para verificar se base do pis considera da nota ou do bem  e se calcula PIS registrado no movimento SN4 (deverá ser maior que 0)
				If !((cAliasTMP)->SOMA > 0) .Or. !((cAliasTmp)->N4_CALCPIS $ " |1|S|3")  //nao calcula pis no mov. avanca registro-colocado space(1)tb devido mov. antigos
					(cAliasTmp)->( dbSkip() )
					Loop
				EndIf
				
				nBaseItem 	:= 0
				nMeses		:= IIf(!Empty((cAliasTMP)->N1_MESCPIS),(cAliasTMP)->N1_MESCPIS, 48 )
				nMesRef		:= Iif(!Empty((cAliasTMP)->N1_MESCPIS),(cAliasTMP)->N1_MESCPIS-1, 47 )

				If ! lAquisicao
					dLimite 		:= Iif((cAliasTMP)->N3_AQUISIC<(cAliasTMP)->N3_DINDEPR, MonthSum(Stod((cAliasTMP)->N3_DINDEPR),nMesRef), MonthSum(Stod((cAliasTMP)->N3_AQUISIC),nMesRef))    				
					If Month(dLimite)==1 .And. Iif((cAliasTMP)->N3_AQUISIC<(cAliasTMP)->N3_DINDEPR, Month(Stod((cAliasTMP)->N3_DINDEPR)), Month(Stod((cAliasTMP)->N3_AQUISIC)))==1
						dLimite	:= Ctod(Alltrim(Str(Day(dLimite)))+"/"+"12"+"/"+Alltrim(Str(Year(dLimite)-1)))
					Endif
				Else
					dLimite 		:= MonthSum(Stod((cAliasTMP)->N3_AQUISIC),nMesRef)
					If Month(dLimite)==1 .And. Month(Stod((cAliasTMP)->N3_AQUISIC))==1
						dLimite	:= Ctod(Alltrim(Str(Day(dLimite)))+"/"+"12"+"/"+Alltrim(Str(Year(dLimite)-1)))
					Endif
				EndIf
			
				If StoD((cAliasTMP)->N4_DATA)<=LastDay(dLimite) .Or. (cAliasTMP)->N1_CALCPIS=="1" .Or. ( (cAliasTMP)->N4_CALCPIS=="1" )
					
					nRet +=(cAliasTMP)->SOMA
					nTxDepr  := (cAliasTMP)->N4_TXDEPR
				   	
					If lProcItem
				   	
						If (cAliasTMP)->N1_CALCPIS $"3|1" .And. ExistBlock("DEPREATF")
							nBaseItem		:= ExecBlock("DEPREATF",.f.,.f.,{cAliasTMP,cAliasTMP, "F120"})
						Else

							lRecNotFis := !Empty((cAliasTmp)->(N1_NFISCAL+N1_NSERIE+N1_FORNEC+N1_LOJA)) .And.;
											SD1->(MsSeek(xFilial("SD1")+(cAliasTmp)->(N1_NFISCAL+N1_NSERIE+N1_FORNEC+N1_LOJA)))
																						   		
							If lRecNotFis
								nRecnSD1 := SD1->(Recno())
								While SD1->(! Eof() .And. SD1->(D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA) == xFilial("SD1")+(cAliasTmp)->(N1_NFISCAL+N1_NSERIE+N1_FORNEC+N1_LOJA))								
									If SD1->D1_ITEM == (cAliasTmp)->N1_NFITEM .And. !Empty((cAliasTmp)->N1_NFITEM)
										lAchouSF4 := SF4->(MsSeek(xFilial("SF4")+SD1->D1_TES))
										nRecnSD1  := SD1->(Recno())
                                        Exit 										
									ElseIf (cAliasTmp)->N1_CBASE == Left(SD1->D1_CBASEAF, TamSx3("N1_CBASE")[1]) .And. Empty((cAliasTmp)->N1_NFITEM)
										lAchouSF4 := SF4->(MsSeek(xFilial("SF4")+SD1->D1_TES))
										If lAchouSF4 .And. SF4->F4_BENSATF == "1"
                                            cProdSN1 := Posicione("SN1", 1, xFilial("SN1")+(cAliasTMP)->(N4_CBASE+N4_ITEM), "N1_PRODUTO")									
											If !Empty(cProdSN1) .And. SD1->(MsSeek(xFilial("SD1")+(cAliasTmp)->(N1_NFISCAL+N1_NSERIE+N1_FORNEC+N1_LOJA)+cProdSN1))
										    	nRecnSD1 := SD1->(Recno())
												Exit										
											EndIf
                                        ElseIf lAchouSF4 .And. (cAliasTmp)->(N1_CBASE+N4_ITEM) == SD1->D1_CBASEAF
                                           nRecnSD1 := SD1->(Recno())                                      
                                           Exit
                                        EndIf
									EndIf

									SD1->(dbSkip())
								End
								
								If lAchouSF4 .AND. (cAliasTmp)->N1_CBCPIS <> "2"
									nAliqPis  := SD1->&(AllTrim(cCpAlPisEn))
									nAliqCof  := SD1->&(AllTrim(cCpAlCofEn))	
									cOrigCred := Iif(Left(SD1->D1_CF,1)=="3","1","0")
									If Empty(SD1->D1_IDTRIB) .AND. lHasSF4
										cCstPis   := SF4->F4_CSTPIS
										cCstCofin := SF4->F4_CSTCOF
									Else
										ATFCfgTrib(SD1->D1_IDTRIB, @cCstPis, @cCstCofin, @nMAlqPis, @nMAlqCof)
									EndIf
								EndIf																			
							EndIf
						EndIf
				   	    
						If !Empty((cAliasTMP)->N1_NFISCAL)
							SF4->(MsSeek(xFilial("SF4")+SD1->D1_TES))
							
							If Empty(SD1->D1_IDTRIB) .AND. lHasSF4
								lPisMajor	:=  If (SF4->F4_MALQPIS <> 0, .T., .F.) 
								lCofMajor	:=  If (SF4->F4_MALQCOF <> 0, .T., .F.) 
							Else
								lPisMajor	:=  If (nMAlqPis <> 0, .T., .F.)
								lCofMajor	:=  If (nMAlqCof <> 0, .T., .F.)
							EndIf
							
							If lPisMajor .And. lCofMajor								
								(cAliasTMP)->(dbSkip())
								Loop 
							Endif
						Endif
												
						DeprecTMP((cAliasTMP)->N4_CBASE,;
								(cAliasTMP)->N4_ITEM,;
								(cAliasTMP)->N1_DESCRIC,;
								nBaseItem,;
								(cAliasTMP)->SOMA,;
								SToD((cAliasTMP)->N4_DATA),;
								cArqAtiv,;
								If(lContaBem, (cAliasTMP)->N3_CCONTAB, (cAliasTMP)->N3_CDEPREC),;
								If(lCCBem, (cAliasTMP)->N3_CCUSTO, (cAliasTMP)->N4_CCUSTO),;
								Iif(Empty(cOrigCred),(cAliasTMP)->N1_ORIGCRD,cOrigCred),;
								Iif(Empty(cCstPis),(cAliasTMP)->N1_CSTPIS,cCstPis),;
								Iif(nAliqPis==0,(cAliasTMP)->N1_ALIQPIS,nAliqPis),;
								Iif(Empty(cCstCofin),(cAliasTMP)->N1_CSTCOFI,cCstCofin),;
								Iif(nAliqCof==0,(cAliasTMP)->N1_ALIQCOF,nAliqCof),;
								(cAliasTMP)->N1_DETPATR,;
								(cAliasTMP)->N1_UTIPATR,;
								(cAliasTMP)->N1_CODBCC,;
								(cAliasTMP)->N1_NFISCAL,;
								(cAliasTMP)->N1_NSERIE,;
								(cAliasTMP)->N1_FORNEC,;
								(cAliasTMP)->N1_LOJA,;
								(cAliasTMP)->N1_NUMPRO,;
								(cAliasTMP)->N1_INDPRO,;
								nTxDepr,;
								nRecnSD1,; //Segundo consulta ao analista Arnaldo Raymundo, o sistema soh trata este lancamento
								(cAliasTMP)->N4_MOTIVO,;
								(cAliasTMP)->N3_FILORIG,;
								SToD((cAliasTMP)->N1_AQUISIC),;
								(cAliasTMP)->N3_CODBAIX )
					Endif	
				Endif
				
				(cAliasTmp)->(dbSkip())
			Enddo
		   	(cAliasTmp)->( dbCloseArea() ) 					

	If !lQuery 	
		dbSelectArea("SN1")
		DbClearFil()
		RetIndex("SN1")
		fErase(cIndTmp+OrdBagExt())
	Endif
		
Next

cFilAnt	:= cFilBack
SN1->(RestArea(aAreaSn1))
SN3->(RestArea(aAreaSn3))	
SN4->(RestArea(aAreaSn4))

If _lDefTopCTB //Proteção para não ocorrer error.log de index not found da SD1.
	SD1->(RestArea(aAreaSD1))
Endif
RestArea(aArea)

If lRetVCred
	xValor := { nRet, nBaseCred }
Else 
	xValor := nRet
EndIf 	      	

If !lProcItem
	Return( xValor )
Else 
	// Caso o processamento seja por item, será retornado o nome do temporario criado para exclusao.
	Return(aTemp)
Endif

/*/{Protheus.doc} DeprecTMP
Grava arquivo temporário retornado no processamento dos creditos nas depreciacoes por item  	
@type StaticFunction
@since 11/04/2005
@author Mary C. Hergert 
@param cCodBem, Character, Código do bem imobilizado
@param cItem, Character, Item do bem imobilizado
@param cDescr, Character, Descrição do bem imobilizado
@param nBase, Numeric, Valor de base do item
@param nRet, Numeric, Valor somado de movimentação
@param dData, Date, Data da movimentação
@param cArqAtiv, Character, Nome do arquivo temporario
@param cContaC, Character, Conta Contabil ou Conta depreciação
@param cCCusto, Character, Código do centro de custo ou centro de custo despesa
@param cOrigCred, Character, Ind. Origem Credito
@param cCSTPis, Character, Cod.Sit.Trib. PIS
@param nAliqPis, Numeric, Perc. Aliquota PIS    
@param cCSTCofins, Character, Cod.Sit.Trib. Cofins
@param nAliqCofins, Numeric, Perc. Aliquota Cofins    
@param cIndBem, Character, Identificador do bem
@param cUtilBem, Character, Utilização do bem
@param cNatBCCrd, Character, Código de Base de Cálculo do Credito (09 ou 11)
@param cNotaFis, Character, Nota Fiscal vinculada ao bem imobilizado
@param cSerNF, Character, Serie da Nota Fiscal vinculada ao bem imobilizado
@param cFornec, Character, Fornecedor da Nota Fiscal vinculada ao bem imobilizado
@param cLoja, Character, Loja do Fornecedor da Nota Fiscal vinculada ao bem imobilizado
@param cNumPro, Character, Número do Processo referenciado relacionado ao Bem
@param cIndPro, Character, Tipo de Processo
@param nTxDepr, Numeric, Taxa de depreciação 
@param nRecnSD1, Numeric, Recno da SD1
@param cMotivo, Character, Motivo de Baixa
@param cfilOri, Character, Filial de Origem
@param dN1Aquis, Date, Data de Aquisição do Bem
@param cCodBaixa, Character, Codigo de baixa do bem 
/*/
Static Function DeprecTMP(cCodBem as Character, cItem as Character, cDescr as Character, nBase as Numeric, nRet as Numeric, dData as Date, cArqAtiv as Character, cContaC as Character, cCCusto as Character,;
						cOrigCred as Character, cCSTPis as Character, nAliqPis as Numeric, cCSTCofins as Character, nAliqCofins as Numeric, cIndBem as Character, cUtilBem as Character, cNatBCCrd as Character,;
						cNotaFis as Character, cSerNF as Character, cFornec as Character, cLoja as Character, cNumPro as Character, cIndPro as Character, nTxDepr as Numeric,nRecnSD1 as Numeric, cMotivo as Character,;
						cfilOri as Character, dN1Aquis as Date, cCodBaixa as Character)

Local cDescExt 		as Character
Local lPEF120EXCL 	as Logical
Local lF120Cust 	as Logical
Local cAliasSN1		as Character
Local nVlrExcl 	 	as Numeric
Local nVlExcICMS 	as Numeric
Local lNils 		as Logical
Local aVlExcICM 	as Array
local lExcICMS      as Logical
local lExcIPI       as Logical
Local aRetICMIPI    as Array
Local nQtdNFe		as Numeric

Default cCodBem     := ""
Default cItem       := ""
Default cDescr      := ""
Default nBase       := 0
Default nRet        := 0
Default dData       := ctod("")
Default cArqAtiv    := ""
Default cContaC     := ""
Default cCCusto     := ""
Default cOrigCred   := ""
Default cCSTPis     := ""
Default nAliqPis    := 0
Default cCSTCofins  := ""
Default nAliqCofins := 0
Default cIndBem     := ""
Default cUtilBem    := ""
Default cNatBCCrd   := ""
Default cNotaFis    := ""
Default cSerNF      := ""
Default cFornec     := ""
Default cLoja       := ""
Default cNumPro     := ""
Default cIndPro     := ""
Default nTxDepr     := 0
Default cMotivo     := ""
Default cFilOri     := ""
Default dN1Aquis    := ctod("")
Default cCodBaixa   := ""

aVlExcICM := {}
cDescExt    := ""
lPEF120EXCL := ExistBlock("AF120EXC")
lF120Cust   := ExistBlock("F120CUST" )
cAliasSN1   := Alias()
nVlExcICMS  := 0
lNils       := cContaC==Nil .And. cCCusto==Nil .And. cOrigCred==Nil .And. cCSTPis==Nil .And. nAliqPis==Nil .And. cCSTCofins==Nil .And. nAliqCofins==Nil .And. cIndBem==Nil .And. cUtilBem==Nil
aRetICMIPI  :={}
lExcICMS    :=.F.
lExcIPI     :=.F.
nVlrExcl := 0
nQtdNFe  := 1

If lPEF120EXCL     //ponto de entrada para incluir valor a excluir
	nVlrExcl := ExecBlock("AF120EXC",.F.,.F.,{cArqAtiv,cCodBem,cItem,dData})
	If ValType(nVlrExcl) != "N"
		nVlrExcl := 0
	EndIf
EndIf

If nRet > 0
	If dN1Aquis >= STOD('20230501') 
		aRetICMIPI:= BscTESF120(nRecnSD1,cNotaFis,cSerNF,cFornec,cLoja)
		lExcICMS := !aRetICMIPI[1]
		lExcIPI  := !aRetICMIPI[2]	.and. lIpiExc

		If lExcICMS .or. lExcIPI
			If Empty(cCodBaixa)
				nVlExcICMS := BscICMSExc("F120",cCodBem,cItem,nRecnSD1,cNotaFis,cSerNF,cFornec,cLoja,lExcICMS,lExcIPI)	 	
			Else
				nQtdNFe   := QtdAtivos(cCodBaixa)
				aVlExcICM := VlF130F120( "SN1", /*nRecnSD1*/, cCodBem, cItem, .F./*lDebPISCOF*/, cCodBaixa,"F120")
				If len(aVlExcICM) > 0
					nVlExcICMS := aVlExcICM[1]
				EndIf
			EndIf
			If nVlExcICMS > 0
				If Empty(cMotivo)
					nVlExcICMS := ((nVlExcICMS / nQtdNFe) * nTxDepr)
				Else
					nVlExcICMS := ATFRetVlEx(cCodBem, cItem, cFilOri, nVlExcICMS, nTxDepr, dData)
				EndIf
			EndIf
		EndIf
	EndIf	
EndIf

If ExistBlock("DEPREATF")
	nRet	:= nBase
EndIf	

//PONTO DE ENTRADA F120CUST - Substitui a gravação do padrão no arquivo de saida utilizado pelo Fiscal
If lF120Cust
	ExecBlock("F120CUST",.F.,.F.,{"F120"/*cReg*/, cArqAtiv, cCodBem, cItem, cDescr, dData, cDescExt, ""/*cTabOri*/, cNumPro, cIndPro, nRet, cAliasSN1, nBase, cContaC, cCCusto, cOrigCred, cCSTPis, nAliqPis, cCSTCofins, nAliqCofins, cIndBem, cUtilBem, cNatBCCrd, cNotaFis, cSerNF, cFornec, cLoja, nVlrExcl })   
Else
	(cArqAtiv)->(dbSetOrder(1))
	If !(cArqAtiv)->(dbSeek(cCodBem+cItem+dtos(dData)))
		
		//Processamento da descricao complementar do ativo SN2.
		If !lNils
			cDescExt	:= Atf130DExt(cCodBem,cItem)
			cDescExt	:= If(Empty(cDescExt),cDescr,cDescExt)
		EndIf
		
		RecLock(cArqAtiv,.T.)
		(cArqAtiv)->BEM    := cCodBem
		(cArqAtiv)->ITEM   := cItem
		(cArqAtiv)->DESCRI := cDescr

		(cArqAtiv)->DTAPR  := dData
		
		If !lNils	
			(cArqAtiv)->NATBCCRED	:=	cNatBCCrd
			(cArqAtiv)->INDBEMIMOB	:=	cIndBem		
			(cArqAtiv)->INDORIGCRD	:=	cOrigCred	
			(cArqAtiv)->INDUTILBEM	:=	cUtilBem	
			(cArqAtiv)->CSTPIS		:=	cCSTPis
			(cArqAtiv)->ALIQPIS		:=	nAliqPis
			(cArqAtiv)->CSTCOFINS	:=	cCSTCofins
			(cArqAtiv)->ALIQCOFINS	:=	nAliqCofins
			(cArqAtiv)->CODCONTA	:=	cContaC
			(cArqAtiv)->CODCCUSTO	:=	cCCusto
			(cArqAtiv)->DESCBEMIMO	:=	cDescExt
		EndIf
		
	Else
		RecLock(cArqAtiv,.F.)
	Endif

	(cArqAtiv)->BASE	+= nBase
	(cArqAtiv)->VRET	+= nRet

	(cArqAtiv)->VLRBCEXC    := nVlrExcl + nVlExcICMS
	(cArqAtiv)->VLRBCPIS	:= (cArqAtiv)->VRET - (cArqAtiv)->VLRBCEXC
	(cArqAtiv)->VLRPIS		:= (cArqAtiv)->(VLRBCPIS*(ALIQPIS/100))	
	(cArqAtiv)->VLRBCCOFIN	:= (cArqAtiv)->VRET - (cArqAtiv)->VLRBCEXC
	(cArqAtiv)->VLRCOFINS	:= (cArqAtiv)->(VLRBCCOFIN*(ALIQCOFINS/100))		

	//campos a ser utilizado pelo pessoal do N3-FISCAL (caio.martins)
	(cArqAtiv)->NOTAFISCAL 	:=	cNotaFis
	(cArqAtiv)->SERIE 		:=	cSerNF
	(cArqAtiv)->FORNECEDOR 	:=	cFornec
	(cArqAtiv)->LOJA 		:=	cLoja
	(cArqAtiv)->NUMPRO 		:=	cNumPro
	(cArqAtiv)->INDPRO 		:=	cIndPro

	MsUnLock()
Endif

Return

/*/{Protheus.doc} _AtfRegF130
Geracao de arquivo temporario para gerar registro F130 do SPED FISCAL PIS/COFINS  	
@type Function
@since 04/05/2011
@author TOTVS
@param cFilProc, Character, Filial de Processamento
@param dDtIni, Date, Data inicial do período de apuração
@param dDtFim, Date, Data Final do período de apuração
@param cCdBaseIni, Character, Codigo inicial(De) do Bem Imobilizado
@param cCdBaseFim, Character, Codigo Final(Até) do Bem Imobilizado
@param cAliasTmp, Character, Alias tabela temporária
@param lRelBasApr, Logical, Rel Base Apropriação
@param cNATBCCrd, Character, Código de Base de Cálculo do Credito
@param aFisTipos, Array, Tipos de Ativos passados pelo time fiscal para selecao dos bens
@return Array, Dados da temporária
/*/
Function _AtfRegF130(cFilProc as Character,dDtIni as Date,dDtFim as Date,cCdBaseIni as Character,cCdBaseFim as Character,cAliasTmp as Character,lRelBasApr as Logical,cNATBCCrd as Character,aFisTipos as Array) as Array
					
Local aAreaSn1 as Array
Local aAreaSn3 as Array
Local aAreaSn4 as Array
Local aAreaSD1 as Array
Local aArea as Array
Local aTemp as Array

Local cAliasSN1 as Character
Local cQuery as Character
Local cWhere as Character
Local cTmpWhere as Character
Local lQuery as Logical     
Local cIndTmp as Character
Local nIndex as Numeric
Local dAquisicao as Date
Local dLimite as Date 

Local nVlrAquisic as Numeric
Local nVlrBCPIS as Numeric
Local nVlrBCCOF as Numeric
Local nMeses as Numeric
Local nMesRef as Numeric
Local nX as Numeric
Local nT as Numeric
Local aSldSN4 as Array
Local lATFPR130 as Logical
Local cFilX as Character
Local cFilSN1 as Character
Local cRecSN1 as Character
Local cCposSN1 as Character
Local cCposSD1 as Character
Local nVlBsCl as Numeric

//Se debitou na base o PIS/COFINS na entrada, precisa utilizar SD1 como referência para cálculo dos impostos, independente do F4_ATUATF 
Local cDebPIS as Character
Local cDebCOF as Character
Local lDebPISCOF as Logical    

Local cXFor as Character
Local cMs_Fil as Character
Local lShared as Logical
Local aModoComp as Array
Local lN1MSFIL as Logical
Local cCondTp as Character
Local lAGVLATF as Logical
Local aValorAquis as Array
Local nVlrICMS as Numeric
Local aValF130 as Array

DEFAULT cFilProc   := cFilAnt
DEFAULT dDtIni     := FirstDay(dDataBase)
DEFAULT dDtFim     := LastDay(dDataBase)
DEFAULT cCdBaseIni := Space(Len(SN1->N1_CBASE))
DEFAULT cCdBaseFim := Replicate("z", Len(SN1->N1_CBASE))
DEFAULT cAliasTmp  := CriaTrab(,.F.)   
DEFAULT lRelBasApr := .F.
DEFAULT cNATBCCrd  := ""
DEFAULT aFisTipos  := {"01","03"}

aAreaSn1 := SN1->(GetArea())
aAreaSn3 := SN3->(GetArea())
aAreaSn4 := SN4->(GetArea())
aAreaSD1 := SD1->(GetArea())
aArea    := GetArea()
aTemp    := {}

cAliasSN1  := ""
cQuery     := ""
cWhere     := ""
cTmpWhere  := ""
lQuery     := .F.      
cIndTmp    := ""
nIndex     := 0
dAquisicao := CToD( "" ) 
dLimite    := CToD( "" )

nVlrAquisic := 0
nVlrBCPIS   := 0
nVlrBCCOF   := 0
nMeses      := 48
nMesRef     := 48
nX          := 0
nT          := 0
aSldSN4     := {}
lATFPR130   := ExistBlock("ATFPR130")
cFilX       := cFilAnt
cFilSN1     := ""
cRecSN1     := ""
cCposSN1    := ""
cCposSD1    := ""
nVlBsCl     := SuperGetMv("MV_BSCREPC",.F., 1) //1 = Valor do bem Imobilizado e 2= Valor de Aquisição do Ativo                    

//Se debitou na base o PIS/COFINS na entrada, precisa utilizar SD1 como referência para cálculo dos impostos, independente do F4_ATUATF 
cDebPIS    := SuperGetMv("MV_DEDBPIS",.F., 'N') 
cDebCOF    := SuperGetMv("MV_DEDBCOF",.F., 'N')  
lDebPISCOF := cDebPIS <> 'N' .Or. cDebCOF <> 'N'     

cXFor       := ""
cMs_Fil     := ""
lShared     := .F.
aModoComp   := {}
lN1MSFIL    := SN1->(FieldPos("N1_MSFIL"))> 0 .AND. FWModeAccess("SN1",3)=="C"
cCondTp     := "" //Condicao dos tipos passados pelo time fiscal para selecao dos bens
lAGVLATF    := SuperGetMv("MV_AGVLATF",.F., .F.) 
aValorAquis := {}
nVlrICMS    := 0
aValF130	:= {}

cFilAnt := cFilProc

dbSelectArea("SN1")
cFilSN1 			:= xFilial("SN1")
aAdd(aModoComp, FWModeAccess("SN1",1) )
aAdd(aModoComp, FWModeAccess("SN1",2) )
aAdd(aModoComp, FWModeAccess("SN1",3) )
lShared := Ascan(aModoComp, 'C') > 0

cMs_Fil 			:= If(lShared,cFilProc,"")

If !Empty(aFisTipos)
    For nT := 1 to len(aFisTipos)
        If nT < len(aFisTipos)
            cCondTp +=  "'" + aFisTipos[nT] + "'" + ","
        Else
            cCondTp +=  "'" + aFisTipos[nT] + "'" 
        EndIf
    Next nT 
Endif

If Select( cAliasTmp ) > 0
	MsgStop("Error - Alias already in use. Verify.")
	Return( aTemp )
EndIf
	
// Cria o arquivo temporário que ira receber as depreciacoes de cada um dos itens
AtfCriaTmp( AtfLayout("F130"), cAliasTmp, aTemp )

	//Tratamento para formatar o IN() de ambiente TOP
	If !Empty(cNATBCCrd) 
		cXFor	:=	"'"+SubStr(cNATBCCrd,1,2)+"'"
		For nX := 4 To Len(cNATBCCrd) Step 3
			cXFor	+=	",'"+SubStr(cNATBCCrd,nX,2)+"'"
		Next nX
		
		#IFDEF TOP
			IF TcSrvType() != "AS/400"
				cNATBCCrd	:=	cXFor
			EndIf
		#ENDIF
	EndIf

	//Tabela tipos de entrada e saida
	dbSelectArea("SF4")
	DbSetOrder (1)
	//tabela itens da nota fiscal de entrada
	dbSelectArea("SD1")
	dbSetOrder(1)
	
	If _lDefTopCTB

	   	dbSelectArea("SN1")
	    lQuery := .T.
	    aStruSN3 := SN3->( dbStruct()) 
		cAliasSN1 := GetNextAlias() 
		cRecSN1 := "SN1.R_E_C_N_O_ SN1RECNO "

		cCposSN1 := "'SN1' TABORI, N1_FILIAL,N1_CBASE,N1_ITEM,N1_CALCPIS,N3_CCONTAB,N3_CCUSTO,N3_CDEPREC,N1_DETPATR,N1_UTIPATR,N1_NFISCAL,N1_NSERIE,N1_FORNEC,N1_LOJA,"
		cCposSN1 += "N3_TIPO,N3_SEQ,N3_SEQREAV,N3_AQUISIC,N3_DINDEPR,N3_VORIG1,N1_QUANTD,N1_ITEM,N3_DLANCTO,N1_DESCRIC, 0 SD1RECNO, SN1.R_E_C_N_O_ SN1RECNO "
		cCposSN1 += ",N1_MESCPIS " 
		// o Campo N1_VLAQUIS contém o valor da aquisição informado diretamente no ATIVO
		cCposSN1 += ",N1_VLAQUIS "
		cCposSN1 += ",N1_NUMPRO "
		cCposSN1 += ",N1_INDPRO "
		cCposSN1 += ",N1_AQUISIC "
		cCposSN1 += ",N3_CODBAIX "
		
		cCposSD1 := "'SD1' TABORI, N1_FILIAL,N1_CBASE,N1_ITEM,N1_CALCPIS,N3_CCONTAB,N3_CCUSTO,N3_CDEPREC,N1_DETPATR,N1_UTIPATR,N1_NFISCAL,N1_NSERIE,N1_FORNEC,N1_LOJA,"
		cCposSD1 += "N3_TIPO,N3_SEQ,N3_SEQREAV,N3_AQUISIC,N3_DINDEPR,N3_VORIG1,N1_QUANTD,N1_ITEM,N3_DLANCTO,N1_DESCRIC, SD1.R_E_C_N_O_ SD1RECNO, SN1.R_E_C_N_O_ SN1RECNO "
		cCposSD1 += ",N1_MESCPIS " 
		// o Campo N1_VLAQUIS contém o valor da aquisição informado diretamente no ATIVO
		cCposSD1 += ",N1_VLAQUIS "
		cCposSD1 += ",N1_NUMPRO "
		cCposSD1 += ",N1_INDPRO "
		cCposSD1 += ",N1_AQUISIC "
		cCposSD1 += ",N3_CODBAIX "
		
		cWhere := ""	
		cWhere += "N1_FILIAL='"+cFilSN1+"' AND "
		If lShared .And. !Empty(cMs_Fil) .And. lN1MSFIL //se tabela SN1 eh compartilhada e passado o parametro cMs_Fil
			dbSelectArea("SN1")
			cWhere += "N1_MSFIL='"+cMs_Fil+"' AND "
		EndIf
		cWhere += "N1_CALCPIS IN ('1','S','3') AND "
	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	    //³Verifica se deverao ser processadas as depreciacoes por ativo.³
	    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    If Empty(cCdBaseIni)
			cWhere += "N1_CBASE != ' ' AND " 	    
	    Else
	  		cWhere += "N1_CBASE >= '" + cCdBaseIni + "' AND " 
	 	EndIf
   		cWhere += "N1_CBASE <= '" + cCdBaseFim + "' AND "
		cWhere += "N1_AQUISIC <= '" + DtoS(dDtFim) + "' AND "		
	   	cWhere += "SN1.D_E_L_E_T_=' ' AND "
		cWhere += "N3_FILIAL= N1_FILIAL AND "
		cWhere += "N3_CBASE=N1_CBASE AND "
		cWhere += "N3_ITEM=N1_ITEM AND "
		cWhere += "N3_TIPO IN (" + cCondTp  + ") AND "
		
		//somente os bens ativos na data
		cWhere += " ( N3_DTBAIXA > '" + DTOS(dDtFim) + "'  OR N3_DTBAIXA = ' ') AND "+ CRLF
		cWhere += " (N1_BAIXA   > '" + DTOS(dDtFim) + "' OR N1_BAIXA = ' ')  AND "+ CRLF
		//somente a ultima sequencia ativa do bem
		cWhere += "N3_SEQ = ( "
		cWhere += "          SELECT  "
		cWhere += "          MAX(N4_SEQ) N4_SEQ "
		cWhere += "          FROM " + RetSQLTab("SN4")
		cWhere += "          WHERE "
		cWhere += " 		  N4_FILIAL 	= SN3.N3_FILIAL AND "
		cWhere += " 	      N4_CBASE 	= SN3.N3_CBASE AND "
		cWhere += " 		  N4_ITEM 	= SN3.N3_ITEM AND "
		cWhere += " 		  N4_TIPO 	= SN3.N3_TIPO AND "
		cWhere += " 		  N4_SEQREAV 	= SN3.N3_SEQREAV AND "
		cWhere += " 		  N4_OCORR 	IN ('04','05','16') AND "+ CRLF  //04=TRANSFERENCIA PARA 05=AQUISICAO  16=AQUISICAO POR TRANSFERENCIA
		cWhere += "     	  N4_DATA 	<= '"+DtoS(dDtFim)+"' AND "
		cWhere += "     	  SN4.D_E_L_E_T_ = ''  "
		cWhere += "     	) AND "
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Utilizado pelo SPED Pis/Cofins (FISCAL) para processar um ³
		//³determinado tipo de credito                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   	If !Empty(cNATBCCrd) 
			cWhere += "N1_CODBCC IN("+cNATBCCrd+") AND "
	   	EndIf
		cWhere += "SN3.D_E_L_E_T_=' ' " 
		cWhereSD1 := ""		
		If !lDebPISCOF
			cWhereSD1 += " F4_FILIAL='"+xFilial("SF4")+"' AND "
			cWhereSD1 += " F4_CODIGO= D1_TES  AND "
			cWhereSD1 += " F4_ATUATF = 'S' AND "
		EndIf
		cWhereSD1 += " D1_FILIAL='"+xFilial("SD1")+"' AND "
		cWhereSD1 += " D1_DOC = N1_NFISCAL AND "
		cWhereSD1 += " D1_SERIE = N1_NSERIE AND "
		cWhereSD1 += "( "
		cWhereSD1 += "( N1_NFITEM != ' ' AND D1_ITEM = N1_NFITEM ) OR "
		If AllTrim( Upper( TcGetDb() ) ) $ "ORACLE_INFORMIX" 
			cWhereSD1 += "( N1_NFITEM = ' ' AND F4_BENSATF = '1' AND N1_CBASE =  SUBSTR(D1_CBASEAF, 1, "+Alltrim(Str(Int(Len(SN1->N1_CBASE))))+") ) OR "
			cWhereSD1 += "( N1_NFITEM = ' ' AND (F4_BENSATF = '2' OR F4_BENSATF = ' ' ) AND N1_CBASE =  SUBSTR(D1_CBASEAF, 1, "+Alltrim(Str(Int(Len(SN1->N1_CBASE))))+")  AND N1_ITEM =  SUBSTR(D1_CBASEAF, "+Alltrim(Str(Int(Len(SN1->N1_CBASE)+1)))+","+Alltrim(Str(Int(Len(SN1->N1_ITEM))))+")  ) "				
		Else
			cWhereSD1 += "( N1_NFITEM = ' ' AND F4_BENSATF = '1' AND N1_CBASE =  SUBSTRING(D1_CBASEAF, 1, "+Alltrim(Str(Int(Len(SN1->N1_CBASE))))+") ) OR "
			cWhereSD1 += "( N1_NFITEM = ' ' AND (F4_BENSATF = '2' OR F4_BENSATF = ' ' ) AND N1_CBASE =  SUBSTRING(D1_CBASEAF, 1, "+Alltrim(Str(Int(Len(SN1->N1_CBASE))))+") "+" AND N1_ITEM =  SUBSTRING(D1_CBASEAF, "+Alltrim(Str(Int(Len(SN1->N1_CBASE)+1)))+","+Alltrim(Str(Int(Len(SN1->N1_ITEM))))+")  ) "				
		EndIf
		cWhereSD1 += " ) AND "
		cWhereSD1 += "D1_FORNECE = N1_FORNEC AND "
		cWhereSD1 += "D1_LOJA = N1_LOJA  AND "
		cWhereSD1 += " N1_CBCPIS <> '2'	 AND "                     								
		cWhereSD1 += "SD1.D_E_L_E_T_=' ' "
		
		//no ponto de entrada somente devera ser colocado condicoes para as tabelas sn1/sn3
		IF lATFPR130
			cTmpWhere 	:= ExecBlock("ATFPR130",.F.,.F.,{lQuery,cWhere})
			cWhere 		:= IIF(ValType(cTmpWhere) != "C" .Or. Empty(cTmpWhere),cWhere,cTmpWhere)
		ENDIF
		//query 1  --> SOMENTE OS BENS QUE POSSUEM NF VIA COMPRAS
	   	cQuery := " SELECT " + cCposSD1 
		cQuery += "FROM "+RetSqlName("SN1")+" SN1,"
		cQuery +=         RetSqlName("SN3")+" SN3, "
		cQuery +=         RetSqlName("SD1")+" SD1, "
		cQuery +=         RetSqlName("SF4")+" SF4 "
		cQuery += "WHERE "
		cQuery += cWhere
		
		cQuery += " AND N1_NFISCAL != ' ' "
		cQuery += " AND N1_FORNEC != ' ' "
		cQuery += " AND N1_LOJA != ' ' "
		cQuery += " AND "+ cWhereSD1
		
		cQuery += " UNION "
		
		//query 2  ---> SOMENTE OS BENS QUE NAO POSSUEM NF 
		cQuery += " SELECT " + cCposSN1 
		cQuery += "FROM "+RetSqlName("SN1")+" SN1,"
		cQuery +=         RetSqlName("SN3")+" SN3 "
		cQuery += "WHERE "
		cQuery += cWhere
		
		cQuery += " AND SN1.R_E_C_N_O_ NOT IN ( "
			//filtrar apenas os recnos que nao foram contemplados na query 1
			cQuery += " SELECT " + cRecSN1
			cQuery += "FROM "+RetSqlName("SN1")+" SN1,"
			cQuery +=         RetSqlName("SN3")+" SN3, "
			cQuery +=         RetSqlName("SD1")+" SD1, "
			cQuery +=         RetSqlName("SF4")+" SF4 "
			cQuery += "WHERE "
			cQuery += cWhere
			cQuery += " AND "+ cWhereSD1
			//termino do filtro
		cQuery += "                           ) "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSN1,.T.,.T.)
		
		For nX := 1 To Len( aStruSN3 ) 
			If AllTrim( aStruSN3[ nX, 1 ] ) $ "N3_AQUISIC|N3_DINDEPR|N3_VORIG1"
				TcSetField( cAliasSN1, aStruSN3[nX,1], aStruSN3[nX,2], aStruSN3[nX,3],aStruSN3[ nX,4])
			EndIf 					
		Next nX 					
		
		While !( cAliasSN1 )->( Eof() )

			aValorAquis := {}
			nVlrICMS    := 0
			nVlrBCPIS   := 0
			nVlrBCCOF   := 0
			aValF130    := {}

			//data de aquisicao - retirado a data de depreciacao conforme fnc 00000005622/2012
			//If ( cAliasSN1 )->N3_DINDEPR > ( cAliasSN1 )->N3_AQUISIC
			//	dAquisicao  := ( cAliasSN1 )->N3_DINDEPR
			//Else
				dAquisicao  := ( cAliasSN1 )->N3_AQUISIC
			//EndIf			
			//credito de pis por fracao == "3"
			If ( cAliasSN1 )->N1_CALCPIS == "3" 
				// Verifica se esta dentro do periodo definido no campo N1_MESCPIS (06, 12, 24, 48 entre outros)
				nMeses      := IIf(!Empty(( cAliasSN1 )->N1_MESCPIS),( cAliasSN1 )->N1_MESCPIS, 48 )
				nMesRef		:= IIf(!Empty(( cAliasSN1 )->N1_MESCPIS),( cAliasSN1 )->N1_MESCPIS-1, 47 )
				dLimite		:=  LastDay( MonthSum(dAquisicao,nMesRef) )
            Else
				dLimite  := LastDay(dAquisicao)
			EndIf
			
			nPorcAtiva := 0
			
			If dAquisicao <= dDtFim .And. dLimite > dDtIni
		   		If ( cAliasSN1 )->N1_CALCPIS $ "1|3" .And. ExistBlock("DEPREATF")
					nVlrBCPIS :=nVlrBCCOF := ExecBlock("DEPREATF",.f.,.f.,{cAliasSN1,cAliasSN1, "F130"})
					AtfPopuTmp("F130",cAliasSN1,cAliasTmp,( cAliasSN1 )->N1_CBASE,( cAliasSN1 )->N1_ITEM,( cAliasSN1 )->N1_DESCRIC,dAquisicao,nVlrBCPIS,nVlrBCCOF, "SN1" ,(cAliasSN1)->N1_NUMPRO,(cAliasSN1)->N1_INDPRO)					
				Else
	                //Valor do bem que servira de base na aquisicao
					aSldSN4	:= SaldoSN4( ( cAliasSN1 )->N1_FILIAL,( cAliasSN1 )->N1_CBASE,( cAliasSN1 )->N1_ITEM,( cAliasSN1 )->N3_TIPO,( cAliasSN1 )->N3_SEQ,( cAliasSN1 )->N3_SEQREAV,/*aMoeda*/,dAquisicao/*dDataSLD*/,.T./*lAgrupa*/,/*dDataIni*/,/*cSaldo*/)
					If Len(aSldSN4) > 0
						nVlrAquisic := aSldSN4[1,2,1]  //aquisicao nao considera baixas
					Else
						nVlrAquisic := ( cAliasSN1 )->N3_VORIG1
					EndIf

				    //Valor do bem na data final
					aSldSN4	:= SaldoSN4( ( cAliasSN1 )->N1_FILIAL,( cAliasSN1 )->N1_CBASE,( cAliasSN1 )->N1_ITEM,( cAliasSN1 )->N3_TIPO,( cAliasSN1 )->N3_SEQ,( cAliasSN1 )->N3_SEQREAV,/*aMoeda*/,dDtFim/*dDataSLD*/,.T./*lAgrupa*/,dAquisicao/*dDataIni*/,/*cSaldo*/)
					If Len(aSldSN4) > 0
						nVlrDtFim:= aSldSN4[1,2,1]-aSldSN4[1,2,8]  //na data final considera aquisicao - baixas
					Else
						nVlrDtFim:= nVlrAquisic
					EndIf

					//porcao ativa do bem na data final
					If nVlrAquisic > 0 
						nPorcAtiva := nVlrDtFim / nVlrAquisic
					EndIf
			
					If ( cAliasSN1 )->TABORI == "SD1" .AND. !(lAGVLATF)
						SD1->( dbGoto ( ( cAliasSN1 )->SD1RECNO ) )
								    
						If SF4->( MsSeek (xFilial ("SF4")+SD1->D1_TES) ) .And. (SF4->F4_ATUATF = "S" .Or. lDebPISCOF)
							//se desmembrar ativo em bens individual deve dividir pela quantidade, i.e., uma ficha de bem para cada unidade do item da nota
							If SF4->F4_BENSATF = "1"
								nVlrBCPIS := nPorcAtiva * SD1->D1_BASIMP6 / SD1->D1_QUANT
								nVlrBCCOF := nPorcAtiva * SD1->D1_BASIMP5 / SD1->D1_QUANT 
							Else
								nVlrBCPIS := nPorcAtiva * SD1->D1_BASIMP6
								nVlrBCCOF := nPorcAtiva * SD1->D1_BASIMP5
							EndIf
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Armazena os valores das bases por item+data caso seja solicitado³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							AtfPopuTmp("F130",cAliasSN1,cAliasTmp,( cAliasSN1 )->N1_CBASE,( cAliasSN1 )->N1_ITEM,( cAliasSN1 )->N1_DESCRIC,dAquisicao,nVlrBCPIS,nVlrBCCOF,( cAliasSN1 )->TABORI,(cAliasSN1)->N1_NUMPRO,(cAliasSN1)->N1_INDPRO)
						
						EndIf  
					Else 
						//implementar quando nao tem nota fiscal igual ao tratamento na funcao deprecativo
						IF nVlBsCl == 1	
							nVlrBCPIS := nPorcAtiva * nVlrAquisic //( cAliasSN1 )->N3_VORIG1
							nVlrBCCOF := nPorcAtiva * nVlrAquisic //( cAliasSN1 )->N3_VORIG1
						ELSE

							If ( cAliasSN1 )->TABORI == "SD1"
								aValF130 := VlF130F120((cAliasSN1)->TABORI, (cAliasSN1)->SD1RECNO, (cAliasSN1)->N1_CBASE, (cAliasSN1)->N1_ITEM, lDebPISCOF, (cAliasSN1)->N3_CODBAIX)

								If Len(aValF130) == 2
									aValorAquis := aValF130[1]
									nVlrICMS    := aValF130[2]
									
									nVlrBCPIS := nPorcAtiva * aValorAquis[1]
									nVlrBCCOF := nPorcAtiva * aValorAquis[2]
								EndIf
							Else
								If Empty((cAliasSN1)->N3_CODBAIX)
									nVlrBCPIS := nPorcAtiva * ( cAliasSN1 )->N1_VLAQUIS
									nVlrBCCOF := nPorcAtiva * ( cAliasSN1 )->N1_VLAQUIS
								Else // Tratamento para ativos adquiridos por transferencia.
									aValF130 := VlF130F120((cAliasSN1)->TABORI, (cAliasSN1)->SD1RECNO, (cAliasSN1)->N1_CBASE, (cAliasSN1)->N1_ITEM, lDebPISCOF, (cAliasSN1)->N3_CODBAIX)

									If Len(aValF130) == 2
										aValorAquis := aValF130[1]
										nVlrICMS    := aValF130[2]
										
										nVlrBCPIS := nPorcAtiva * aValorAquis[1]
										nVlrBCCOF := nPorcAtiva * aValorAquis[2]
									EndIf
								EndIf
							EndIf

							If STOD((cAliasSN1)->N1_AQUISIC) < STOD('20230501')
								nVlrICMS := 0 //O valor do ICMS deverá estar zerado se o bem foi incluido antes da Lei 14.592
							EndIf

						EndIf
		
						AtfPopuTmp("F130",cAliasSN1,cAliasTmp,( cAliasSN1 )->N1_CBASE,( cAliasSN1 )->N1_ITEM,( cAliasSN1 )->N1_DESCRIC,dAquisicao,nVlrBCPIS,nVlrBCCOF,( cAliasSN1 )->TABORI,(cAliasSN1)->N1_NUMPRO,(cAliasSN1)->N1_INDPRO,nVlrICMS)
					
					EndIf
				EndIf
			EndIf
			
			DbSelectArea(cAliasSN1)
			DbSkip()
			
		EndDo
			(cAliasSN1)->( DbCloseArea() )
    EndIf
	If !lQuery 	
		dbSelectArea("SN1")
		DbClearFil()
		RetIndex("SN1")
		fErase(cIndTmp+OrdBagExt())
	Endif


RestArea(aAreaSn1)
RestArea(aAreaSn3)
RestArea(aAreaSn4)
RestArea(aAreaSD1)
RestArea(aArea)

cFilAnt := cFilX

Return(aTemp)

/*/{Protheus.doc} AtfLayout
Monta Estrutura para arquivo temporario para gerar registro SPED FISCAL PIS/COFINS	
@type StaticFunction
@since 04/05/2011
@author TOTVS
@param cReg, Character, identificador do registro F130
/*/
Static Function AtfLayout(cReg)
Local aStru := {}

AADD(aStru,{"BEM"	,"C",010,0})
AADD(aStru,{"ITEM"	,"C",004,0})
AADD(aStru,{"DESCRI","C",040,0})
AADD(aStru,{"DTAQS"	,"D",008,0})

If 		cReg == "F130"
				//1234567890           //CAMPO No.
	AADD(aStru,{"REG"			,"C",004,0})  //01
	AADD(aStru,{"NAT_BC_CRE"	,"C",002,0})  //02
	AADD(aStru,{"IDENT_BEM"		,"N",002,0})  //03
	AADD(aStru,{"IND_ORIG_C"	,"C",001,0})  //04
	AADD(aStru,{"IND_UTIL_B"	,"N",001,0})  //05
	AADD(aStru,{"MES_OPER_A"	,"N",006,0})  //06
	AADD(aStru,{"VL_OPER_AQ"	,"N",018,2})  //07
	AADD(aStru,{"PARC_OPER"		,"N",018,2})  //08
	AADD(aStru,{"VL_BC_CRED"	,"N",018,2})  //09
	AADD(aStru,{"IND_NR_PAR"	,"N",001,0})  //10
	AADD(aStru,{"CST_PIS"		,"N",002,0})  //11
	AADD(aStru,{"VL_BC_PIS"		,"N",018,2})  //12
	AADD(aStru,{"ALIQ_PIS"		,"N",008,4})  //13
	AADD(aStru,{"VL_PIS"		,"N",018,2})  //14
	AADD(aStru,{"CST_COFINS"	,"N",002,0})  //15
	AADD(aStru,{"VL_BC_COFI"	,"N",018,2})  //16
	AADD(aStru,{"ALIQ_COFIN"	,"N",008,4})  //17
	AADD(aStru,{"VL_COFINS"		,"N",018,2})  //18
	AADD(aStru,{"COD_CTA"		,"C",060,0})  //19
	AADD(aStru,{"COD_CCUS"		,"C",060,0})  //20
	AADD(aStru,{"DESC_BEM_I"	,"C",200,0})  //21
	//campos a ser utilizado pelo pessoal do N3-FISCAL (caio.martins)
	AADD(aStru,{"NOTAFISCAL"	,"C",Len(SN1->N1_NFISCAL),0})
	AADD(aStru,{"SERIE"			,"C",Len(SN1->N1_NSERIE),0})
	AADD(aStru,{"FORNECEDOR"	,"C",Len(SN1->N1_FORNEC),0})
	AADD(aStru,{"LOJA"			,"C",Len(SN1->N1_LOJA ),0})
	AADD(aStru,{"NUMPRO"		,"C"	,10,0})
	AADD(aStru,{"INDPRO"		,"C"	,1,0})

EndIf
Return aStru

/*/{Protheus.doc} AtfPopuTmp
Popular o arquivo temporario para gerar registro SPED FISCAL SPED FISCAL PIS/COFINS 	
@type StaticFunction
@since 04/05/2011
@author TOTVS
@param cReg, Character, identificador do registro F130
@param cAliasSN1, Character, Alias da tabela SN1
@param cAliasTmp, Character, Alias da tabela Temporária
@param cCodBem, Character, Codigo do Bem Imobilizado
@param cItem, Character, Item do Bem Imobilizado
@param cDescr, Character, Descrição do Bem Imobilizado
@param dData, Date, Data de aquisição do Bem Imobilizado
@param nVlrBCPIS, Numeric, Valor de base do PIS
@param nVlrBCCOF, Numeric, Valor de base do COFINS
@param cTabOri, Character, Tabela de Origem (SN1 ou SD1)
@param cNumPro, Character, Número do Processo referenciado relacionado ao Bem
@param cIndPro, Character, Tipo de Processo
@param nVlrICMS, Numeric, Valor do ICMS
/*/
Static Function AtfPopuTmp(cReg as Character,cAliasSN1 as Character,cAliasTmp as Character,cCodBem as Character,cItem as Character,cDescr as Character,;
						 dData as Date,nVlrBCPIS as Numeric,nVlrBCCOF as Numeric,cTabOri as Character,cNumPro as Character,cIndPro as Character,nVlrICMS as Numeric)

Local lDefTop		as Logical
Local nValor		as Numeric
Local cDescExt		as Character    
Local cIND_ORIG_C	as Character
Local nALIQ_PIS		as Numeric
Local nCST_PIS		as Numeric
Local nCST_COFINS 	as Numeric
Local nALIQ_COFIN 	as Numeric
Local lPEF130EXCL 	as Logical
Local lF120Cust 	as Logical
Local lPisMajor 	as Logical
Local lCofMajor 	as Logical
Local nAlqPisMaj 	as Numeric
Local nAlqCofMaj 	as Numeric
Local lAGVLATF 		as Logical
Local nVlBsCalc 	as Numeric
Local nMAlqPis 		as Numeric
Local nMAlqCof 		as Numeric
Local lHasSF4		as Logical

Default cReg      := ""
Default cAliasSN1 := ""
Default cAliasTmp := ""
Default cCodBem   := ""
Default cItem     := ""
Default cDescr    := ""
Default dData     := ctod("")
Default nVlrBCPIS := 0
Default nVlrBCCOF := 0
Default cTabOri   := ""
Default cNumPro   := ""
Default cIndPro   := ""
Default nVlrICMS  := 0

lDefTop     := .F.
nValor      := nVlrBCPIS //somente considerara nVlrBCPIS pq no layout atual considera que são iguais
cDescExt    := ""    
cIND_ORIG_C := ""
nALIQ_PIS   := 0
nCST_PIS    := 0
nCST_COFINS := 0
nALIQ_COFIN := 0
lPEF130EXCL := ExistBlock("AF130EXC")
lF120Cust   := ExistBlock("F120CUST" )
lPisMajor   := .F.
lCofMajor   := .F.
nAlqPisMaj  := 0
nAlqCofMaj  := 0
lAGVLATF    := SuperGetMv("MV_AGVLATF",.F., .F.)
nVlBsCalc   := 0
nMAlqPis	:= 0
nMAlqCof	:= 0

lDefTop := _lDefTopCTB

lHasSF4   	:= If(FindFunction("ATFHasSF4"),ATFHasSF4(),.F.)

If lF120Cust
	ExecBlock("F120CUST",.F.,.F.,{cReg, cAliasTmp, cCodBem, cItem, cDescr, dData, cDescExt, cTabOri, cNumPro, cIndPro, nValor, cAliasSN1,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL})   
Else 
	(cAliasTmp)->(dbSetOrder(1))
	If !(cAliasTmp)->(dbSeek(cCodBem+cItem+dtos(dData)))
		RecLock(cAliasTmp,.T.)
		(cAliasTmp)->BEM		:= cCodBem
		(cAliasTmp)->ITEM		:= cItem
		(cAliasTmp)->DESCRI		:= cDescr
		(cAliasTmp)->DTAQS		:= dData
		cDescExt				:= Atf130DExt(cCodBem,cItem)
		(cAliasTmp)->DESC_BEM_I	:= If(Empty(cDescExt),cDescr,cDescExt)					//cpo:18 F120 ou cpo:21 F130
		MsUnLock()
	Endif
	
	If lDefTop
		SN1->( dbGoto( (cAliasSN1)->SN1RECNO  ) )
	EndIf
	
	nVlrExcl := 0
	If lPEF130EXCL     //ponto de entrada para incluir valor a excluir
		nVlrExcl := ExecBlock("AF130EXC",.F.,.F.,{cAliasTMP})
		If ValType(nVlrExcl) != "N"
			nVlrExcl := 0
		EndIf
	EndIf

	If cTabOri == "SD1" .AND. !(lAGVLATF)
		cIND_ORIG_C		:= If(Left(SD1->D1_CF,1)=="3","1","0")
		If Empty(SD1->D1_IDTRIB) .AND. lHasSF4
			nCST_PIS 		:=	Int(Val(SF4->F4_CSTPIS))
			nCST_COFINS		:= 	Int(Val(SF4->F4_CSTCOF))
		Else
			ATFCfgTrib(SD1->D1_IDTRIB, @nCST_PIS, @nCST_COFINS, @nMAlqPis, @nMAlqCof)
			nCST_PIS    := Int(Val(nCST_PIS))
			nCST_COFINS := Int(Val(nCST_COFINS))
		EndIf
		nALIQ_PIS 		:= SD1->D1_ALQIMP6
		nALIQ_COFIN		:= 	SD1->D1_ALQIMP5	
		If Empty(SD1->D1_IDTRIB) .AND. lHasSF4
			nAlqPisMaj 		:= SF4->F4_MALQPIS
			nAlqCofMaj 		:= SF4->F4_MALQCOF
			lPisMajor		:=  ( SF4->F4_MALQPIS <> 0 )
			lCofMajor		:=  ( SF4->F4_MALQCOF <> 0 )
		Else
			nAlqPisMaj 		:= nMAlqPis
			nAlqCofMaj 		:= nMAlqCof
			lPisMajor		:=  ( nMAlqPis <> 0 )
			lCofMajor		:=  ( nMAlqCof <> 0 )
		EndIf
	Else
		cIND_ORIG_C		:= SN1->N1_ORIGCRD
		nCST_PIS 		:= Int(Val(SN1->N1_CSTPIS))
		nALIQ_PIS 		:= SN1->N1_ALIQPIS 
		nCST_COFINS		:= Int(Val(SN1->N1_CSTCOFI))
		nALIQ_COFIN		:= SN1->N1_ALIQCOF 
	EndIf
	
	RecLock(cAliasTmp,.F.) 

		If cReg == "F130"
			(cAliasTmp)->REG			:= "F130"															//01
			(cAliasTmp)->NAT_BC_CRE		:= "10"																//02
			(cAliasTmp)->IDENT_BEM		:= Int(Val((cAliasSN1)->N1_DETPATR))								//03
			(cAliasTmp)->IND_ORIG_C		:= cIND_ORIG_C														//04
			(cAliasTmp)->IND_UTIL_B		:= Int(Val((cAliasSN1)->N1_UTIPATR))								//05
			(cAliasTmp)->MES_OPER_A		:= Int(Val(Subs(Dtos(dData),5,2)+Subs(Dtos(dData),1,4)))			//06
			(cAliasTmp)->VL_OPER_AQ		+= nValor															//07
			(cAliasTmp)->PARC_OPER		+= nVlrExcl + nVlrICMS												//08
			(cAliasTmp)->VL_BC_CRED		:= (cAliasTmp)->(VL_OPER_AQ)        								//09
			(cAliasTmp)->IND_NR_PAR		:= Atf130Parc(Int((cAliasSN1)->N1_MESCPIS))						    //10
			(cAliasTmp)->CST_PIS		:= nCST_PIS															//11

			nVlBsCalc := (cAliasTmp)->VL_BC_CRED - (cAliasTmp)->PARC_OPER  //09 (07 - 08)

			If Int((cAliasSN1)->N1_MESCPIS) > 0
				(cAliasTmp)->VL_BC_PIS 	:= nVlBsCalc/Int((cAliasSN1)->N1_MESCPIS) 			                //12
			Else
				(cAliasTmp)->VL_BC_PIS 	:= nVlBsCalc                         	 			                //12
			EndIF

			If !lPisMajor  //se nao tem PIS majorado
				(cAliasTmp)->ALIQ_PIS		:= 	nALIQ_PIS														//13
				(cAliasTmp)->VL_PIS 		:= (cAliasTmp)->(VL_BC_PIS*ALIQ_PIS/100)							//14
			Else
				(cAliasTmp)->ALIQ_PIS		:= 	nALIQ_PIS - nAlqPisMaj														//13
				(cAliasTmp)->VL_PIS 		:= ( (cAliasTmp)->(VL_BC_PIS*nALIQ_PIS/100) - (cAliasTmp)->(VL_BC_PIS*nAlqPisMaj/100) )							//14
			EndIf

			(cAliasTmp)->CST_COFINS		:= 	nCST_COFINS														//15
			If Int((cAliasSN1)->N1_MESCPIS) > 0
				(cAliasTmp)->VL_BC_COFI	:= nVlBsCalc/Int((cAliasSN1)->N1_MESCPIS) 			                //16
			Else
				(cAliasTmp)->VL_BC_COFI	:= nVlBsCalc								 			            //16
			EndIf

			If !lCofMajor  //se nao tem COFINS majorado
				(cAliasTmp)->ALIQ_COFIN		:= nALIQ_COFIN														//17
				(cAliasTmp)->VL_COFINS		:= (cAliasTmp)->(VL_BC_COFI*ALIQ_COFIN/100)		 				//18
			Else
				(cAliasTmp)->ALIQ_COFIN		:= nALIQ_COFIN - nAlqCofMaj														//17
				(cAliasTmp)->VL_COFINS		:= ( (cAliasTmp)->(VL_BC_COFI*nALIQ_COFIN/100) - (cAliasTmp)->(VL_BC_COFI*nAlqCofMaj/100) )	 				//18
			EndIf

			(cAliasTmp)->COD_CTA		:= (cAliasSN1)->N3_CCONTAB											//19
			(cAliasTmp)->COD_CCUS		:= (cAliasSN1)->N3_CCUSTO											//20
			//campos a ser utilizado pelo pessoal do N3-FISCAL (caio.martins)
			(cAliasTmp)->NOTAFISCAL		:= (cAliasSN1)->N1_NFISCAL
			(cAliasTmp)->SERIE			:= (cAliasSN1)->N1_NSERIE
			(cAliasTmp)->FORNECEDOR		:= (cAliasSN1)->N1_FORNEC
			(cAliasTmp)->LOJA 			:= (cAliasSN1)->N1_LOJA
			(cAliasTmp)->NUMPRO 		:= cNumPro
			(cAliasTmp)->INDPRO			:= cIndPro
			
		EndIf

	MsUnLock()
EndIf

Return

/*/{Protheus.doc} Atf130Parc
Retorna codigo para layout correspondente ao numero de meses (N1_MESCPIS)  
@type StaticFunction
@since 11/05/2011
@author TOTVS
@param nMeses, Numeric, quantidade de Meses
@return Numeric, retorno do código para layout
/*/
Static Function Atf130Parc(nMeses)
Local nRet := 0
If nMeses == 0
	nRet := 1
ElseIf nMeses == 12
	nRet := 2
ElseIf nMeses == 24
	nRet := 3
ElseIf nMeses == 48
	nRet := 4
//ElseIf nMeses == 6     Utilizado apenas para Embalagens de bebidas frias
//	nRet := 5
Else
	nRet := 9
EndIf
Return(nRet)

/*/{Protheus.doc} AtfCriaTmp
Criacao do arquivo temporario para gerar registro SPED FISCAL PIS/COFINS   
@type StaticFunction
@since 04/05/2011
@author TOTVS
@param aStru, Array, Estrutura do registro F130
@param cAliasTmp, Character, Alias Temporário
@param aRetTmp, Array, retorno da temporaria
@return Array, Alias das tabelas temporarias
/*/
Static Function AtfCriaTmp(aStru,cAliasTmp,aRetTmp)
Local cArqTmp
Default aRetTmp := {}

cArqTmp	:=	CriaTrab(aStru)

If Select( cArqTmp ) > 0
	DbSelectArea( cArqTmp )
	( cArqTmp )->( DbCloseArea() )
Endif

dbUseArea(.T.,__LocalDriver,cArqTmp,cAliasTmp)
IndRegua(cAliasTmp,cArqTmp,"BEM+ITEM+DTOS(DTAQS)")
AADD(aRetTmp,{cArqTmp,cAliasTmp})

Return aRetTmp

/*/{Protheus.doc} Atf130DExt
Retorna descricao estendia
@type StaticFunction
@since 11/05/2011
@author TOTVS
@param cCodBem, Character, Código do ativo imobilizado
@param cItem, Character, Item do ativo imobilizado
@return Character, Retorno da descrição estendida
@version P12
/*/
Static Function Atf130DExt(cCodBem,cItem)
Local cString := ""
dbSelectArea("SN2")
dbSetOrder(1)
If dbSeek(xFilial("SN2")+cCodBem+cItem+"01")
	While SN2->(!Eof() .And. N2_FILIAL+N2_CBASE+N2_ITEM+N2_TIPO==xFilial("SN2")+cCodBem+cItem+"01")
		cString += Alltrim(SN2->N2_HISTOR)+Space(1)
		SN2->(dbSkip())
	EndDo
EndIf
cString := Alltrim(StrTran(cString,CRLF,' '))
Return(cString)

/*/{Protheus.doc} AtfBscNFs
Busca os valores das notas (NF + CTE) apenas do F130
@type StaticFunction
@author TOTVS
@since 21/06/2023
@param cRecnoD1, Character, Recno da tabela SD1
@param lDebPISCOF, logical, MV_DEDBPIS <> 'N' .Or. MV_DEDBCOF <> 'N'
@param cCodBem, Character, código da base do bem
@param cItemBem, Character, item da base do bem
@return Array, Retorno dos valores correspondentes as Notas vinculadas ao ativo
@version P12
/*/
Static Function AtfBscNFs(cRecnoD1 As Numeric,lDebPISCOF As Logical,cCodBem As Character,cItemBem As Character) As Array

Local cChavSD1 As Character
Local cCodProd As Character
Local cItmProd As Character
Local cDesmAtf As Character
Local cChavSF8 As Character

Local nD1TotCTe As Numeric
Local nVlTotCTe As Numeric
Local nD1TotNF As Numeric
Local nD1QtdNF As Numeric
Local nVlTotNF As Numeric
Local nD1QtdGar As Numeric
Local nD1TotGar As Numeric
Local nVlTotGar As Numeric
Local nN As Numeric
Local nValorPIS As Numeric
Local nValorCOF As Numeric
Local nX As Numeric

Local aValNfs As Array
Local aAreaSD1 As Array
Local aChvNfEst As Array
Local bValF130 As Block

Default cRecnoD1   := ""
Default lDebPISCOF := .F.
Default cCodBem    := ""
Default cItemBem   := ""

cChavSD1 := ""
cCodProd := ""
cItmProd := ""
cDesmAtf := ""
cChavSF8 := ""

nD1TotCTe := 0
nVlTotCTe := 0
nD1TotNF  := 0
nD1QtdNF  := 0
nVlTotNF  := 0
nD1QtdGar := 0
nD1TotGar := 0
nVlTotGar := 0
nN        := 0
nValorPIS := 0
nValorCOF := 0
nX        := 0

aValNfs   := {}
aAreaSD1  := {}
aChvNfEst := {}

bValF130    := {|| &( SuperGetMV( "MV_AFVL130",.F., 'SD1->D1_TOTAL' ) ) }

SD1->( dbGoto ( cRecnoD1 ) ) // Nota de compra do ativo.

cChavSD1 := SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA
cCodProd := SD1->D1_COD
cItmProd := SD1->D1_ITEM

nD1TotNF := Eval( bValF130 )
nD1TotNF := IIF(ValType(nD1TotNF) <> "N", SD1->D1_TOTAL, nD1TotNF) //Tratamento para não dar erro caso o usuário informe o parâmetro entre aspas, será considerado o padrão atual

nD1QtdNF := SD1->D1_QUANT
nVlTotNF := nD1TotNF / nD1QtdNF

If SF4->( DbSeek(xFilial("SF4")+SD1->D1_TES) ) .And. (SF4->F4_ATUATF == "S" .Or. lDebPISCOF)
	cDesmAtf :=	SF4->F4_BENSATF
EndIf

// Busca a nota de entrada de garantia estendida e serviços, pois os valores dessas NFs precisam compôr o valor do ativo na apuração do EFD.
If AliasIndic("FN0")
	aChvNfEst := NfCompFN0(cCodBem,cItemBem,.T.)
EndIf
If Len(aChvNfEst) > 0
	For nX := 1 To Len(aChvNfEst)
		nD1TotGar += nVlTotGar += aChvNfEst[nX]
	Next nX
Else
	aChvNfEst := ATFNFGarEs(cCodBem,cItemBem) // Nota da garantia estendida e serviços do ativo. Para poder ratear esses valores, precisa buscar as notas fiscais somente com a base do ativo.
	If Len(aChvNfEst) > 0
		aAreaSD1 := SD1->(GetArea())
		SD1->(DBSetOrder(1)) // Indice 1 - D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
		For nN := 1 To Len(aChvNfEst)
			If SD1->(DBSeek(aChvNfEst[nN]))

				nD1TotGar := Eval( bValF130 )
				nD1TotGar := IIF(ValType(nD1TotGar) <> "N", SD1->D1_TOTAL, nD1TotGar) 	

				nD1QtdGar := SD1->D1_QUANT
				nVlTotGar += nD1TotGar / nD1QtdGar
			EndIf
		Next nN
		RestArea(aAreaSD1)
	EndIf
EndIf

DbSelectArea("SF8")
DbSetOrder(2) //F8_FILIAL+F8_NFORIG+F8_SERORIG+F8_FORNECE+F8_LOJA
If SF8->( DbSeek(cChavSD1) )
	cChavSF8 := SF8->(F8_NFDIFRE+F8_SEDIFRE)
	aAreaSD1 := SD1->(GetArea())
	DbSelectArea("SD1")
	DbSetOrder(2) // Indice 2 - D1_FILIAL+D1_COD+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA
	If SD1->( DbSeek( xFilial("SD1") + cCodProd + cChavSF8 )) // Busca o documento CT-e.

		nD1TotCTe := Eval( bValF130 ) 
		nD1TotCTe := IIF(ValType(nD1TotCTe) <> "N", SD1->D1_TOTAL, nD1TotCTe) 	
			
		nVlTotCTe := nD1TotCTe / nD1QtdNF // No caso do CT-e, por ser uma nota de complemento, a quantidade é zero, portanto a divisão será feita pela quantidade da nota de compra do ativo.
	EndIf
	RestArea(aAreaSD1)
EndIf

If cDesmAtf == "2" .OR. Empty(cDesmAtf) //Não Desmembra o Ativo
	nValorPIS := nValorCOF := nD1TotNF + nD1TotCTe + nD1TotGar
ElseIf cDesmAtf == "1" //Desmembra o Ativo
	nValorPIS := nValorCOF := nVlTotNF + nVlTotCTe + nVlTotGar
EndIf

aValNfs := {nValorPIS,nValorCOF}

Return aValNfs

/*/{Protheus.doc} ATFTipo12
Verifica se o ativo imobilizado possui um registro do tipo 12 na tabela SN3.
@type function
@version 12.1.2310
@author Ciro Pedreira
@since 30/10/2023
@param cBase, character, base do ativo
@param cItem, character, item da base do ativo
@return logical, .T. = ativo possui tipo 12 ou .F. = ativo não possui tipo 12
/*/
Function ATFTipo12(cBase As Character, cItem As Character) As Logical

	Local lRet As Logical
	Local cQuery As Character
	Local __oQry As Object
	Local cAliasQry As Character

	lRet      := .F.
	cQuery    := ""
	__oQry    := Nil
	cAliasQry := GetNextAlias()

	cQuery += "SELECT N3_TIPO "
	cQuery += "FROM ? "
	cQuery += "WHERE "
	cQuery += "N3_FILIAL = ? AND " // Ordens dos campos do WHERE baseado no indice 1 (N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ)
	cQuery += "N3_CBASE = ? AND "
	cQuery += "N3_ITEM = ? AND "
	cQuery += "N3_TIPO = ? AND "
	cQuery += "D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery(cQuery)
	__oQry := FWPreparedStatement():New(cQuery)
	
	__oQry:SetNumeric(1, RetSqlName("SN3"))
	__oQry:SetString(2, FWxFilial("SN3"))
	__oQry:SetString(3, cBase)
	__oQry:SetString(4, cItem)
	__oQry:SetString(5, "12")

	cAliasQry := MPSYSOpenQuery(__oQry:GetFixQuery(), cAliasQry)

	lRet := (cAliasQry)->(!EOF())

	(cAliasQry)->(DBCloseArea())

Return lRet

/*/{Protheus.doc} BscICMSExc
Busca o valor de ICMS a ser excluído da Base do PIS e COFINS	
@type StaticFunction
@author TOTVS
@since 31/10/2023
@param cReg, character, identificador do registro F120 ou F130
@param cCodBase, Character, Codigo do Ativo Fixo
@param cItemAtf, Character, Item do Ativo Fixo
@param nRecSD1, Numeric, Recno do SD1
@param cNotaFis, Character, Nota Fiscal que gerou o ativo
@param cSerNF, Character, série da Nota Fiscal que gerou o ativo
@param cFornec, Character, Fornecedor da Nota Fiscal que gerou o ativo
@param cLoja, Character, Loja do Fornecedor da Nota Fiscal que gerou o ativo
@return Numeric, Valor do ICMS
@version P12
/*/
Static Function BscICMSExc(cReg as Character,cCodBase as Character,cItemAtf as Character,nRecSD1 as Numeric,cNotaFis as Character,cSerNF as Character,cFornec as Character,cLoja as Character,lExcICms as Logical,lExcIPI as Logical) as Numeric

Local aAreaSD1 as Array
Local aAreaCTE as Array
Local nICMS    as Numeric
Local nIPI     as Numeric
Local cDesmAtf as Character
Local lRet     as Logical
Local cChavSD1 as Character
Local cChavSF8 as Character
Local cCodProd as Character
Local nQtdNfAt as Numeric
Local nX       as Numeric
Local aChvNfEst as Array
Local lSF4	   as Logical

Default cReg     := ""
Default cCodBase := ""
Default cItemAtf := ""
Default nRecSD1  := 0
Default cNotaFis := ""
Default cSerNF   := ""
Default cFornec  := ""
Default cLoja    := ""
Default lExcICms := .T.
Default lExcIPI  := .F.

aAreaSD1 := SD1->(GetArea())
aAreaCTE := SD1->(GetArea())
nICMS    := 0
nIPI     := 0
cDesmAtf := ""
lRet     := .F.
cCodProd := ""
cChavSD1 := ""
cChavSF8 := ""
nQtdNfAt := 0
nX       := 0
aChvNfEst := {}
lSF4	 := .F.

If !lIpiExc
	 lExcIPI := .F.
EndIf

If cReg == "F120"

	If nRecSD1 > 0
		SD1->( dbGoto ( nRecSD1 ) ) // Nota de compra do ativo.
		IF SD1->(!EOF())
			lRet := .T.
		EndIf					
	Else
		If SD1->(DbSeek(xFilial("SD1")+(cNotaFis+cSerNF+cFornec+cLoja)))
			lRet := .T.
		EndIf
	EndIf
					
	If lRet
		cChavSD1 := SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA
		cCodProd := SD1->D1_COD
		nQtdNfAt := SD1->D1_QUANT
	
		If SF4->( DbSeek(xFilial("SF4")+SD1->D1_TES) ) .And. (SF4->F4_ATUATF == "S")
			cDesmAtf :=	SF4->F4_BENSATF
			lSF4     := .T.				  
		EndIf

		If lSF4
			If cDesmAtf == "1" //Desmembra ativo
				If lExcICms
					nICMS := SD1->D1_VALICM/SD1->D1_QUANT
				EndIf
				If lExcIPI
					nIPI := SD1->D1_VALIPI/SD1->D1_QUANT
				EndIf
			ElseIf cDesmAtf == "2"  .OR. Empty(cDesmAtf)//Não Desmembra o Ativo
				If lExcICms
					nICMS := SD1->D1_VALICM
				EndIf
				If lExcIPI
					nIPI := SD1->D1_VALIPI
				EndIf
			EndIf
		EndIf	
	EndIf	

ElseIf cReg == "F130"

	SD1->( dbGoto ( nRecSD1 ) ) // Nota de compra do ativo.

	IF SD1->(!EOF())
		lRet := .T.
	EndIf

	If lRet
		cChavSD1 := SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA
		cCodProd := SD1->D1_COD
		nQtdNfAt := SD1->D1_QUANT

		If SF4->( DbSeek(xFilial("SF4")+SD1->D1_TES) ) .And. (SF4->F4_ATUATF == "S")
			cDesmAtf :=	SF4->F4_BENSATF
			lSF4     := .T.	  
		EndIf

		If lSF4
			If cDesmAtf == "1" //Desmembra ativo
				If lExcICms
					nICMS := SD1->D1_VALICM/SD1->D1_QUANT
				EndIf
				If lExcIPI
					nIPI := SD1->D1_VALIPI/SD1->D1_QUANT
				EndIf
			ElseIf cDesmAtf == "2" .OR. Empty(cDesmAtf) //Não Desmembra o Ativo
				If lExcICms
					nICMS := SD1->D1_VALICM	
				EndIf
				If lExcIPI
					nIPI := SD1->D1_VALIPI
				EndIf
			EndIf
		EndIf
	EndIf	
EndIf

If lRet
	DbSelectArea("SF8")
	DbSetOrder(2) //F8_FILIAL+F8_NFORIG+F8_SERORIG+F8_FORNECE+F8_LOJA
	If SF8->( DbSeek(cChavSD1) )
		cChavSF8 := SF8->(F8_NFDIFRE+F8_SEDIFRE)
		aAreaCTE := SD1->(GetArea())
		DbSelectArea("SD1")
		DbSetOrder(2) // Indice 2 - D1_FILIAL+D1_COD+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA
		If SD1->( DbSeek( xFilial("SD1") + cCodProd + cChavSF8 )) .AND. lSF4 // Busca o documento CT-e.
			If cDesmAtf == "1" //Desmembra ativo
				If lExcICms
					nICMS += SD1->D1_VALICM/nQtdNfAt // No caso do CT-e, por ser uma nota de complemento, a quantidade é zero, portanto a divisão será feita pela quantidade da nota de compra do ativo.
				EndIf
			ElseIf cDesmAtf == "2" .or. Empty(cDesmAtf) //Não Desmembra o Ativo
				If lExcICms
					nICMS += SD1->D1_VALICM	
				EndIf
			EndIf
		EndIf
		RestArea(aAreaCTE)
	EndIf

	If AliasIndic("FN0")
		If lExcICms
			aChvNfEst := NfCompFN0(cCodBase,cItemAtf,.T.,.T.)
			If Len(aChvNfEst) > 0
				For nX := 1 To Len(aChvNfEst)
					nICMS += aChvNfEst[nX]
				Next nX
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aAreaSD1)

Return nICMS + nIPI

/*/{Protheus.doc} BscTESF120
Busca na TES vinculada a Nota Fiscal do Bem imobilizado e validar se Credita ICMS	
@type StaticFunction
@author TOTVS
@since 06/12/2023
@param nRecSD1, Numeric, Recno do SD1
@param cNotaFis, Character, Nota Fiscal que gerou o ativo
@param cSerNF, Character, série da Nota Fiscal que gerou o ativo
@param cFornec, Character, Fornecedor da Nota Fiscal que gerou o ativo
@param cLoja, Character, Loja do Fornecedor da Nota Fiscal que gerou o ativo
@return Array, Se Credita o ICMS e IPI Sim ou não (posição 1-ICMS, 2-IPI)
@version P12
/*/
Static Function BscTESF120(nRecSD1 as Numeric,cNotaFis as Character,cSerNF as Character,cFornec as Character,cLoja as Character) as Array

Local aAreaSD1	as Array
Local lCredICMS	as Logical
Local lCredIPI	as Logical
Local lTmNFVinc as Logical
Local aRetCred  as Array
Local lIdTrib	as Logical
Local cCredIcmCT  as character
Local cCredIPICT  as character
Local lHasSF4	as Logical

Default nRecSD1  := 0
Default cNotaFis := ""
Default cSerNF   := ""
Default cFornec  := ""
Default cLoja    := ""

aAreaSD1  := SD1->(GetArea())
lCredICMS := .F.
lCredIPI  := .F.
lTmNFVinc := .F.
aRetCred  := {}
lIdTrib	  := .F.
cCredIcmCT := "N"
cCredIPICT := "N"
lHasSF4   := If(FindFunction("ATFHasSF4"),ATFHasSF4(),.F.)

DbSelectArea("SD1")
If nRecSD1 > 0
	SD1->( dbGoto ( nRecSD1 ) ) // Nota de compra do ativo.
	lTmNFVinc := .T.
Else
	SD1->(DbSetOrder(1)) //Indice 1 - D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
	If SD1->(DbSeek(xFilial("SD1")+(cNotaFis+cSerNF+cFornec+cLoja)))
		lTmNFVinc := .T.
	EndIf
EndIf

If lTmNFVinc //Tem nota fiscal vinculada ao bem imobilizado
	IF !Empty(SD1->D1_IDTRIB) .AND. backoffice.stock.calculationcost.HasRulesCust() //Valida se o ambiente está apto para utilizar a regra de custo no Configurador de Tributos.
		ATFVlCGTrb(SD1->D1_IDTRIB, , @cCredIcmCT, @cCredIPICT )
		lIdTrib := .T.
	EndIf 
	
	If SF4->( DbSeek(xFilial("SF4")+SD1->D1_TES) )
		lCredICMS := IIF(lIdTrib,cCredIcmCT == "S",If(lHasSF4,SF4->F4_CREDICM == "S",.F.))
		If lIpiExc
			lCredIPI  := IIF(lIdTrib,cCredIPICT == "S",If(lHasSF4,SF4->F4_CREDIPI == "S",.F.))
		EndIf
	EndIf
EndIf	

Aadd(aRetCred,lCredICMS)
Aadd(aRetCred,lCredIPI)

RestArea(aAreaSD1)

Return aRetCred

/*/{Protheus.doc} ATFRetVlEx
Retorna o valor de exclusão para itens que sofreram baixa no período
@type StaticFunction
@author TOTVS
@since 01/07/2024
@param cCodBem, Character, Código do bem imobilizado
@param cItem, Character, Item do bem imobilizado
@param cFilOri, Character, Filial de Origem do Bem
@param nVlExcICMS, Numeric, Valor do ICMS
@param nTxDepr, Numeric, Taxa de depreciação 
@param dData, Character, série da Nota Fiscal que gerou o ativo

@return nValRet, Numeric, Valor calculado de Exclusão
@version P12
/*/
Static Function ATFRetVlEx(cCodBem, cItem, cFilOri, nVlExcICMS, nTxDepr, dData)
Local nValRet 	As Numeric
Local nDiasBx   As Numeric
Local nDiasMes  As Numeric
Local aArea     As Array
Local cTipDepr  As Character

Default cCodBem	   := ""
Default cItem	   := ""
Default cFilOri    := ""
Default nVlExcICMS := 0
Default nTxDepr    := 0
Default dData      := StoD("")

nValRet   := 0
nDiasBx   := 0
nDiasMes  := 0
aArea     := {}
cTipDepr  := ""

aArea     := GetArea()

FN6->(dbSetOrder(2))
If FN6->(dbSeek(xFilial("FN6")+cFilOri+cCodBem+cItem+DtoS(dData)))
	cTipDepr := FN6->FN6_DEPREC
EndIf

nTxDepr := (nTxDepr/100)/12 //Taxa de Depreciação mensal cheia

If cTipDepr == "1" //Depreciação Parcail FN6_DEPREC = 1
	nDiasBx  := Day(dData)
	nDiasMes := Day(LastDay(dData))	
	nTxDepr  := (nDiasBx*nTxDepr)/nDiasMes //Regra de 3 para taxa proporcional da baixa
EndIf

nValRet := nVlExcICMS*nTxDepr // Valor de exclusão calculado

RestArea(aArea)

Return nValRet

/*/{Protheus.doc} VlF130F120
Retorna os valores de aquisição e ICMS do Bem para a composição do registro F130/F120.
@type StaticFunction
@author tp.ciro.pedreira
@since 10/07/2024
@param cTabOri, Character, Tabela de origem do registro
@param nRecSn1, Character, Recno do registro da tabela SD1
@param cBase, Character, Base do bem imobilizado
@param cItem, Numeric, Item do bem imobilizado
@param lDebPisCof, Numeric, .T. = deduzir o valor do ICMS da base do PIS e COFINS; .F. = não deduzir
@param cCodBaixa, Character, Código da baixa gerado pela rotina ATFA251
@return Array, [1] = Valor de aquisição do Bem; [2] = Valor de ICMS do Bem
@version P12
/*/
Static Function VlF130F120(cTabOri As Character, nRecSn1 As Numeric, cBase As Character, cItem As Character, lDebPisCof As Logical, cCodBaixa As Character,cTipo As Character) As Array

	Local aRet As Array
	Local cQuery As Character
	Local __oQry As Object
	Local cAliasQry As Character
	Local nParam As Numeric
	Local aVlAquis As Numeric
	Local nVlPis As Numeric
	Local nVlCofins As Numeric
	Local nVlICMS As Numeric
	Local nTamBase As Numeric
	Local nTamItBas As Numeric

	Default cTabOri    := ""
	Default nRecSn1    := 0
	Default cBase      := ""
	Default cItem      := ""
	Default lDebPisCof := .F.
	Default cCodBaixa  := ""
	Default cTipo  	   := "F130" 

	aRet      := {}
	cQuery    := ""
	__oQry    := Nil
	cAliasQry := GetNextAlias()
	nParam    := 1
	aVlAquis  := {}
	nVlICMS   := 0
	nTamBase  := TamSX3("N1_CBASE")[1]
	nTamItBas := TamSX3("N1_ITEM")[1]
	nVlPis    := 0
	nVlCofins := 0

	If cTabOri == "SD1"

		AAdd(aRet, AtfBscNFs(nRecSn1, lDebPisCof, cBase, cItem))
		AAdd(aRet, BscICMSExc(cTipo, cBase, cItem, nRecSn1,,,,, .T.,lIpiExc))        
		
	Else
		/*
		Documentação do ChangeQuery():
			https://tdn.totvs.com/display/public/framework/ChangeQuery
			Usar o SUBSTRING na Query SQL e a função transformará em SUBSTR caso necessário para cada banco de dados.
		*/

		cQuery := "SELECT DISTINCT "
		cQuery += "	N1_CBASE, "
		cQuery += "	N1_ITEM, "
		cQuery += "	N1_NFISCAL, "
		cQuery += "	N1_NSERIE, "
		cQuery += "	N1_FORNEC, "
		cQuery += "	N1_LOJA, "
		cQuery += "	SD1.R_E_C_N_O_ RECSD1 "
		cQuery += "FROM ? SN3 "
		cQuery += "INNER JOIN ? SN1 ON " // Amarração baseada no indice 1 = N1_FILIAL+N1_CBASE+N1_ITEM
		cQuery += "	SN1.N1_FILIAL = ? AND "
		cQuery += "	SN1.N1_CBASE = SN3.N3_CBASE AND "
		cQuery += "	SN1.N1_ITEM = SN3.N3_ITEM AND "
		cQuery += "	SN1.N1_NFISCAL <> ' ' AND "
		cQuery += "	SN1.N1_FORNEC <> ' ' AND "
		cQuery += "	SN1.N1_LOJA <> ' ' AND "
		cQuery += "	SN1.D_E_L_E_T_ = ' ' "
		cQuery += "INNER JOIN ? SD1 ON " // Amarração baseada no indice 1 = D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
		cQuery += "	SD1.D1_FILIAL = ? AND "
		cQuery += "	SD1.D1_DOC = SN1.N1_NFISCAL AND "
		cQuery += "	SD1.D1_SERIE = SN1.N1_NSERIE AND "
		cQuery += "	SD1.D1_FORNECE = SN1.N1_FORNEC AND "
		cQuery += "	SD1.D1_LOJA = SN1.N1_LOJA AND "
		cQuery += "	SD1.D_E_L_E_T_ = ' ' "
		cQuery += "INNER JOIN ? SF4 ON " // Amarração baseada no indice 1 = F4_FILIAL+F4_CODIGO
		cQuery += "	SF4.F4_FILIAL = ? AND "
		cQuery += "	SF4.F4_CODIGO = SD1.D1_TES AND "
		cQuery += "	SF4.D_E_L_E_T_ = ' ' AND "
		cQuery += "( "
		cQuery += "	(SN1.N1_NFITEM <> ' ' AND SD1.D1_ITEM = SN1.N1_NFITEM) OR "
		cQuery += "	(SN1.N1_NFITEM = ' ' AND SF4.F4_BENSATF = '1' AND SN1.N1_CBASE = SUBSTRING(SD1.D1_CBASEAF, 1, ?)) OR "
		cQuery += "	(SN1.N1_NFITEM = ' ' AND (SF4.F4_BENSATF = '2' OR SF4.F4_BENSATF = ' ') AND SN1.N1_CBASE = SUBSTRING(SD1.D1_CBASEAF, 1, ?) AND "
		cQuery += "		SN1.N1_ITEM = SUBSTRING(SD1.D1_CBASEAF, ?, ?)) "
		cQuery += ") "
		cQuery += "WHERE " // Where baseado no indice 8 = N3_FILIAL+N3_CODBAIX+N3_CBASE+N3_ITEM+N3_TIPO+N3_SEQ
		cQuery += "	SN3.N3_FILIAL = ? AND "
		cQuery += "	SN3.N3_CODBAIX = ? AND "
		cQuery += "	SN3.N3_BAIXA IN ('1', '2') AND "
		cQuery += "	SN3.D_E_L_E_T_ = ' ' "

		cQuery := ChangeQuery(cQuery)
		__oQry := FWPreparedStatement():New(cQuery)
		
		__oQry:SetNumeric(nParam++, RetSqlName("SN3"))
		__oQry:SetNumeric(nParam++, RetSqlName("SN1"))
		__oQry:SetString(nParam++, FWxFilial("SN1"))
		__oQry:SetNumeric(nParam++, RetSqlName("SD1"))
		__oQry:SetString(nParam++, FWxFilial("SD1"))
		__oQry:SetNumeric(nParam++, RetSqlName("SF4"))
		__oQry:SetString(nParam++, FWxFilial("SF4"))
		__oQry:SetNumeric(nParam++, nTamBase)
		__oQry:SetNumeric(nParam++, nTamBase)
		__oQry:SetNumeric(nParam++, nTamBase + 1)
		__oQry:SetNumeric(nParam++, nTamItBas)
		__oQry:SetString(nParam++, FWxFilial("SN3"))
		__oQry:SetString(nParam++, cCodBaixa)

		cAliasQry := MPSYSOpenQuery(__oQry:GetFixQuery(), cAliasQry)

		If (cAliasQry)->(!EOF())

			While (cAliasQry)->(!EOF())

				If cTipo == "F130"
					aVlAquis := AtfBscNFs((cAliasQry)->RECSD1, lDebPisCof, (cAliasQry)->N1_CBASE, (cAliasQry)->N1_ITEM)
					nVlPis    += aVlAquis[1]
					nVlCofins += aVlAquis[2]
					nVlICMS  += BscICMSExc(cTipo, (cAliasQry)->N1_CBASE, (cAliasQry)->N1_ITEM, (cAliasQry)->RECSD1,,,,, .T.,lIpiExc)
				Else
					aRetICMIPI := BscTESF120((cAliasQry)->RECSD1,(cAliasQry)->N1_NFISCAL,(cAliasQry)->N1_NSERIE,(cAliasQry)->N1_FORNEC,(cAliasQry)->N1_LOJA)
					lExcICMS := !aRetICMIPI[1]
					lExcIPI  := !aRetICMIPI[2]	.and. lIpiExc
					If lExcICMS .or. lExcIPI
						nVlICMS  += BscICMSExc(cTipo, (cAliasQry)->N1_CBASE, (cAliasQry)->N1_ITEM, (cAliasQry)->RECSD1,,,,,lExcICMS,lExcIPI)						            
					EndIF
				Endif
				
				(cAliasQry)->(DBSkip())

			EndDo
			If cTipo == "F130"
				aVlAquis := {nVlPis, nVlCofins}
				AAdd(aRet, aVlAquis)
			EndIf
			
			AAdd(aRet, nVlICMS)
			
		EndIf

		(cAliasQry)->(DBCloseArea())
		
	EndIf

Return aRet

/*/{Protheus.doc} ATFCfgTrib
Busca os tributos no Configurador de Tributos.
@type function
@version 12.1.2410
@author cirop
@since 11/19/2024
@param cIdTribCT, character, ID do Configurador de Tributos
@param cCstPisCT, character, retorna o CST do PIS
@param cCstCofCT, character, retorna o CST do COFINS
@param nMAlqPisCT, numeric, retorna a aliquota majorada do PIS
@param nMAlqCofCT, numeric, retorna a aliquota majorada do COFINS
@param lCalcIPI,  logical, retorna se calcula IPI 
@param lCalcIcm,  logical, retorna se calcula ICMS 
@param lCalcIcmCl, logical, retorna se calcula ICMS Complementar
@param lAFTribGen, logical, varial de controle para evitar repetições 
	   desnecessárias no laço, pois quando acionada a função ATFTribGen
	   as variaveis enviadas por referencia já são preenchidas.
@obs quando essa função "ATFCfgTrib" é acionada pelo MATA103, é necessário desviar o fluxo para utilizar a função ATFTribGen
	 pois a função ATFTribGen utiliza a Classe TCIProcessing() que trabalha com dados em memoria ainda não gravados
	 que é diferente quando essa função "ATFCfgTrib" é acionada pelo EFD, onde os tributos já estão gravados
	 nas tabelas do Fiscal.
@return logical, .T. = Se achou a classe do Configurador de Tributos; .F. = Se não encontrou a classe
/*/
Function ATFCfgTrib(cIdTribCT As Character, cCstPisCT As Character, cCstCofCT As Character, nMAlqPisCT As Numeric, nMAlqCofCT As Numeric, lCalcIPI as Logical, lCalcIcm As Logical, lCalcIcmCl  As Logical) As Logical

Local oDados    	As Object
Local cJsonDoc  	As Character
Local oJson 		As Object
Local oJsonImp  	As Object
Local cTrib 		As Character
Local lRet 			As Logical
Local nI    		As Numeric 
Local lAFTribGen	As Logical

Default cIdTribCT  := ""
Default cCstPisCT  := ""
Default cCstCofCT  := ""
Default nMAlqPisCT := 0
Default nMAlqCofCT := 0
Default lCalcIPI   := .F. 
Default lCalcIcm   := .F. 
Default lCalcIcmCl := .F.

lRet := .F.

cCstPisCT := cValtoChar(cCstPisCT)
cCstCofCT := cValtoChar(cCstCofCT)

// Verifica se a classe do Configurador de Tributos existe no repositório.
If FindClass("totvs.protheus.backoffice.fiscal.tciclass.TCIWritten")
	lRet   := .T.
	oDados := totvs.protheus.backoffice.fiscal.tciclass.TCIWritten():New()
	oDados:SetId({cIdTribCT})
	
	cJsonDoc := oDados:GetDataId()

	oJson := JsonObject():New()
	oJson:FromJson(cJsonDoc)

	If oJson:HasProperty("dados_Id")
		If oJson["dados_Id"]:HasProperty(cIdTribCT)
			lAFTribGen	:= .F.
			aDados:= oJson["dados_Id"][cIdTribCT]:GetNames()
			For nI:=1 To Len(aDados)
				cTrib := aDados[nI]
				If oJson["dados_Id"][cIdTribCT]:HasProperty(cTrib)
					If oJson["dados_Id"][cIdTribCT][cTrib]:HasProperty("codigo_tributo_relacionado")
						// 000015 - PIS| 000016 - COFINS | 000021 - ICMS |  000022 - IPI | 000038 - ICMS COMPL
						If oJson["dados_Id"][cIdTribCT][cTrib]["codigo_tributo_relacionado"] $ "000015,000016,000021,000022,000038"
							oJsonImp := oJson["dados_Id"][cIdTribCT][cTrib]["dados_escriturados"]
							If oJson["dados_Id"][cIdTribCT][cTrib]["codigo_tributo_relacionado"] == "000015" // PIS.
								cCstPisCT  := oJsonImp["cst"]
								nMAlqPisCT := oJsonImp["perc_majorado"]
							ElseIf oJson["dados_Id"][cIdTribCT][cTrib]["codigo_tributo_relacionado"] == "000016" // COFINS.
								cCstCofCT  := oJsonImp["cst"]
								nMAlqCofCT := oJsonImp["perc_majorado"]
							ElseIf !lAFTribGen .AND. oJson["dados_Id"][cIdTribCT][cTrib]["codigo_tributo_relacionado"]  $ "000021,000038,000022" // ICMS,ICMS COMPL,IPI
								If FWisincallstack("MATA103") .AND. !FwIsInCallStack("ATFJob103")
									ATFTribGen(SD1->D1_ITEM, /*cCstPis*/, /*cCstCofin*/, /*nMAlqPis*/, /*nMAlqCof*/,@lCalcIcm,@lCalcIcmCl,@lCalcIPI)
									lAFTribGen	:= .T.	
								Else 
									If oJson["dados_Id"][cIdTribCT][cTrib]["codigo_tributo_relacionado"] == "000021" // ICMS.
										If !Empty(oJsonImp["cst"]) 
											lCalcIcm	:= .T. 
										EndIf
									ElseIf oJson["dados_Id"][cIdTribCT][cTrib]["codigo_tributo_relacionado"] == "000022" // IPI.
							 			If !Empty(oJsonImp["cst"]) 
											lCalcIPI	:= .T.
										EndIf	
									ElseIf oJson["dados_Id"][cIdTribCT][cTrib]["codigo_tributo_relacionado"] == "000038" // ICMS COMPL.
										If !Empty(oJsonImp["cst"]) 
											lCalcIcmCl	:= .T.
										EndIf
									EndIf
								EndIf
							EndIf 
						EndIf
					EndIf
				EndIf
			Next nI
		EndIf
	EndIf

	oDados:Destroy()
EndIf

Return lRet

/*/{Protheus.doc} QtdAtivos
Retorna a quantidade de ativos novos gerados pela opção de Transferência.
Essa quantidade será usada no rateio do valor de exclusão do ICMS para os novos ativos.
@type function
@version 12.1.2410
@author tp.ciro.pedreira
@since 08/08/2025
@param cCodBaixa, character, código da baixa
@return numeric, quantidade de ativos
/*/
Static Function QtdAtivos(cCodBaixa As Character) As Numeric

	Local cQuery As Character
	Local __oQry As Object
	Local cAliasQry As Character
	Local nRet As Numeric
	Local nParam As Numeric

	__oQry    := Nil
	cAliasQry := GetNextAlias()
	cQuery    := ""
	nRet      := 1
	nParam    := 1

	cQuery := "SELECT COUNT(*) QTD_ATIVOS "
	cQuery += "FROM ( "
	
	cQuery += "	SELECT DISTINCT N1_CBASE " // 1 SN1 para N SN3.
	cQuery += "	FROM " + RetSQLName("SN3") + " SN3 "
	cQuery += "	INNER JOIN " + RetSQLName("SN1") + " SN1 ON "
	cQuery += "		SN1.N1_FILIAL = ? "
	cQuery += "		AND SN1.N1_CBASE = SN3.N3_CBASE "
	cQuery += "		AND SN1.N1_ITEM = SN3.N3_ITEM "
	cQuery += "		AND SN1.D_E_L_E_T_ = ? "
	cQuery += "	WHERE SN3.N3_FILIAL = ? "
	cQuery += "		AND SN3.N3_CODBAIX = ? "
	cQuery += "		AND SN3.N3_BAIXA = ? "
	cQuery += "		AND SN3.D_E_L_E_T_ = ? "

	cQuery += ") ATIVOS_NOVOS "

	cQuery := ChangeQuery(cQuery)
	__oQry := FWPreparedStatement():New(cQuery)
	
	__oQry:SetString(nParam++, FWxFilial("SN1"))
	__oQry:SetString(nParam++, ' ')
	__oQry:SetString(nParam++, FWxFilial("SN3"))
	__oQry:SetString(nParam++, cCodBaixa)
	__oQry:SetString(nParam++, '0')
	__oQry:SetString(nParam++, ' ')

	cAliasQry := MPSYSOpenQuery(__oQry:GetFixQuery(), cAliasQry)

	If (cAliasQry)->(!EOF())
		nRet := (cAliasQry)->QTD_ATIVOS
	EndIf

	(cAliasQry)->(DBCloseArea())

	FreeObj(__oQry)

Return nRet

/*/{Protheus.doc} ATFTribGen
Busca os tributos no Configurador de Tributos.
@type function
@version 12.1.2410
@author vinicius.snascimento
@since 13/08/2025
@param cItem, character, Item que acionou essa função exemplo: D1_ITEM
@param cCstPis, character, retorna o CST do PIS
@param cCstCofin, character, retorna o CST do COFINS
@param nMAlqPis, numeric, retorna a aliquota majorada do PIS
@param nMAlqCof, numeric, retorna a aliquota majorada do COFINS
@param lCalcIcm, logical, retorna se calcula ICMS
@param lCalcIcmCl, logical, retorna se calcula ICMS Complementar
@param lCalcIPI, logical, retorna se calcula IPI
@param lAchouPis | lAchouCof, logical, variavel de controle para evitar voltas 
	   desnecessárias no laço de repetição, como por exemplo em caso de majoração
	   pois nesse caso aparecerá duas regras Pis por exemplo, uma regra será da base
	   de majoração, e a outra referente ao valor base de Pis da NF.
@return logical, .T. 
/*/
Function ATFTribGen(cItem as character, cCstPis as character, cCstCofin  as character, nMAlqPis as numeric, nMAlqCof as numeric, lCalcIcm as logical, lCalcIcmCl as logical, lCalcIPI as logical) as logical
Local oDados        as object
Local oJsonLivro	as object
Local jJson         as json
Local jRegras       as json
Local cRetorno      as character
Local nX      		as numeric
Local lHasRlCust	as logical
Local nItem			as numeric
Local aRegraCalc	as array
Local lAchouPis 	as logical
Local lAchouCof 	as logical


Default cItem       := ""
Default cCstPis		:= ""
Default cCSTCofin	:= ""
Default nMAlqPis	:= 0
Default nMAlqCof	:= 0
Default lCalcIcm	:= .F.
Default lCalcIcmCl  := .F.
Default lCalcIPI	:= .F.

lHasRlCust			:= FindFunction("backoffice.stock.calculationcost.HasRulesCust",.T.) .AND. backoffice.stock.calculationcost.HasRulesCust()
nItem				:= 0
aRegraCalc			:= {}

if lHasRlCust

	nItem := Val(cItem)
	cItem := cValtochar(nItem)
	oDados:= totvs.protheus.backoffice.fiscal.tciclass.TCIProcessing():New()
	oDados:setDataItems({"detalhe_livro"})
	cRetorno := oDados:GetDataItems()

	jJson := JsonObject():New()
	jJson:FromJson(cRetorno)

	jRegras := jJson["dados_itens"][cItem]
		
	// Existem tributos gerados pelo configurador de tributos
	if ValType(jRegras) == "J" .AND. !jRegras:HasProperty("Aviso")
		lAchouPis 	:= .F.
		lAchouCof 	:= .F.
		aRegraCalc := jRegras:GetNames()
		for nX := 1 to len(aRegraCalc)

			If !lAchouPis .AND. jJson['dados_itens'][cItem][aRegraCalc[nX]]['ident_trib'] == '000015' // PIS.
				oJsonLivro := jJson['dados_itens'][cItem][aRegraCalc[nX]]['detalhe_livro']
				cCstPis    := oJsonLivro['cst']
				nMAlqPis   := oJsonLivro['perc_majorado']
				lAchouPis  := .T.
			EndIf

			If !lAchouCof .AND. jJson['dados_itens'][cItem][aRegraCalc[nX]]['ident_trib'] == "000016" // COFINS.
				oJsonLivro := jJson['dados_itens'][cItem][aRegraCalc[nX]]['detalhe_livro']
				cCstCofin  := oJsonLivro['cst']
				nMAlqCof   := oJsonLivro['perc_majorado']
				lAchouCof  := .T.
			EndIf

			If jJson['dados_itens'][cItem][aRegraCalc[nX]]['ident_trib'] ==  "000021" // ICMS.
				oJsonLivro := jJson['dados_itens'][cItem][aRegraCalc[nX]]['detalhe_livro']
				If !Empty(oJsonLivro['cst'])
					lCalcIcm := .T.
				EndIf
			EndIf 

			If jJson['dados_itens'][cItem][aRegraCalc[nX]]['ident_trib'] == "000038" // ICMS COMPL.
				oJsonLivro := jJson['dados_itens'][cItem][aRegraCalc[nX]]['detalhe_livro']
				If !Empty(oJsonLivro['cst'])
					lCalcIcmCl := .T.
				EndIf
			EndIf

			If jJson['dados_itens'][cItem][aRegraCalc[nX]]['ident_trib'] == "000022" // IPI.
				oJsonLivro := jJson['dados_itens'][cItem][aRegraCalc[nX]]['detalhe_livro']
				If !Empty(oJsonLivro['cst'])
					lCalcIPI := .T.
				EndIf
			EndIf

		next nX
	EndIf

	oDados:destroy()
	FreeObj(oDados)

EndIf

Return .T.


/*/{Protheus.doc} ATFHasSF4
Verificar se os campos da SF4 existem na base.
Existe a expectativa de que permanecerão no TES apenas os campos cuja função única e exclusiva seja a integração entre os módulos.
https://tdn.totvs.com/pages/releaseview.action?pageId=928965724
Obs: Nessa função não foram adicionados todos os campos que serão removidos para verificação, apenas alguns. 
	 Caso esses não existam, os demais também não existirão.
@type function
@version 12.1.2410
@author vinicius.snascimento
@since 15/08/2025
@return logical, .T. 
/*/
Function ATFHasSF4() as logical
Local aArea		as array

If __lAFHasF4 == NIL

	If cPaisLoc == "BRA"
		aArea := GetArea()
		__lAFHasF4 := .F.

		If ( SF4->(FieldPos("F4_CSTPIS")) > 0 .AND. SF4->(FieldPos("F4_CSTCOF")) > 0 .AND. SF4->(FieldPos("F4_MALQPIS")) > 0  .AND. ;
			SF4->(FieldPos("F4_MALQCOF")) > 0 .AND. SF4->(FieldPos("F4_CREDIPI")) > 0 .AND. SF4->(FieldPos("F4_CREDICM")) > 0 )	
			__lAFHasF4 := .T.
		EndIf

		RestArea(aArea)
		aSize(aArea,0)
		aArea := nil
	Else 
		__lAFHasF4 := .T.
	EndIf
EndIf 

Return __lAFHasF4
