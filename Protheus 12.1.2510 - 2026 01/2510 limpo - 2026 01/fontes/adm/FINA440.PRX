#INCLUDE "FINA440.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWLIBVERSION.CH"

/*
*** Definição de cada posição do array aBase ***
	1 - Código do vendedor
	2 - Base da comissão
	3 - Base na emissão
	4 - Base na baixa
	5 - Valor na emissão
	6 - Valor na baixa
	7 - % da comissão (se % é zero, conterá diversos caracteres de porcentagem - %)
	8 - PIS
	9 - COFINS
	10 - CSLL
	11 - IRRF
	12 - Valor original do título baixado (soma do valor dos títulos baixados por liquidação)
	13 - RECNO do título filho
*/

Static lFWCodFil	:= .T.
Static nValAbatCom	:= 0
Static nSldTitComis	:= 0
Static cNatCom
Static cComiLiq
Static cChaveComis
Static cComisCR
Static cParComEm
Static cMV_1DUP
Static lFindPccBx	:= .T.
Static lFindIrBx	:= .T.
Static lFindAtuSld	:= .T.
Static lF440BasEm
Static lComiLiq
Static lCompensa
Static IsBlind
Static lDevolucao
Static lF440DelB
Static lGestao
Static lF440VEND
Static lF440Liq		As Logical
Static lFA440VLD	As Logical
Static lSF2460I		As Logical
Static lF440CVB		As Logical
Static lF440CBase	As Logical
Static lF440JurDes	As Logical
Static lF440FAL		As Logical
Static lLj440SbCm	As Logical
Static lPEPerCom	As Logical
Static lF440COM		As Logical
Static cModeAcSE1	As Character
Static cModeAcSF1	As Character
Static cModeAcSF2	As Character
Static cModeAcSF4	As Character
Static cModeAcSE2	As Character
Static cModeAcSE4	As Character
Static cModeAcSD1	As Character
Static cModeAcSD2	As Character
Static cModeAcSE5	As Character
Static cModeAcFI7	As Character
Static _cMEmpAcE1	As Character
Static _cMEmpAcE5	As Character
Static __cCpoFlag	As Character

Static aRelImp
Static __oValLiq  	:= NIL
Static __oTotLiq  	:= NIL
Static __oPropSD2	:= NIL
Static __oPropSD1	:= NIL

Static nTamE2_NATUR	As Numeric
Static nTamBascom	As Numeric
Static nTamPerc		As Numeric
Static nTamParc		As Numeric
Static __nTmMoed	As Numeric
Static __nTmPref	As Numeric
Static __nTmNum		As Numeric
Static __nTmParc	As Numeric
Static __nTmTipo	As Numeric
Static __nTmBase	As Numeric
Static __nTmComi	As Numeric
Static __nTmSeri	As Numeric
Static __nTmItem	As Numeric
Static __nCasDec 	As Numeric
Static __nVend
Static __lMetric	:= NIL
Static __lComisON	:= NIL
Static __lReliq		:= .F.
Static __cFunBkp    := ""
Static __cFunMet	:= ""
Static __nRecOrig	:= 0
Static __nDecPCom	:= Nil
Static __lRndPCom	:= Nil
Static __aCpos		:= NIL

Static __oStParcL	:= NIL
Static __oStFO0Pr	:= NIL
Static __oStParJD	:= NIL
Static __oStVldLJ	:= NIL
Static __lExecSt	:= NIL
Static __oObjSE3	:= Nil
Static __lF440aB1	As Logical
Static __lF440aB2	As Logical
Static __lLbSchdl	As Logical
Static __lAuto		As Logical
Static __l440Flag	As Logical

Static __lLoaded	:= loadStatic()
Static __lUsaClass  As Logical

Static Function loadStatic()
	Default __lLoaded := .F.

	If !__lLoaded .and. Select("SX3") > 0
		nTamE2_NATUR	:= TamSX3("E2_NATUREZ")[1]
		nTamBascom		:= TamSX3("E1_BASCOM1")[2]
		nTamPerc		:= TamSX3("E1_COMIS1")[2]
		nTamParc		:= TamSX3("E1_PARCELA")[1]
		__nTmMoed		:= TamSX3("CTO_MOEDA")[1]
		__nTmPref		:= TamSX3("E1_PREFIXO")[1]
		__nTmNum		:= TamSX3("E1_NUM")[1]
		__nTmParc		:= TamSX3("E1_PARCELA")[1]
		__nTmTipo		:= TamSX3("E1_TIPO")[1]
		__nTmBase		:= TamSX3("E3_BASE")[2]
		__nTmComi		:= TamSX3("E3_COMIS")[2]
		__nTmSeri		:= TamSX3("D2_SERIE")[1]
		__nTmItem		:= TamSX3("FT_ITEM")[1]
		__nCasDec 		:= TamSx3("E1_TXMOEDA")[2]

		lF440Liq		:= ExistBlock("F440LIQ")
		lFA440VLD		:= ExistBlock("FA440VLD")
		lSF2460I		:= ExistBlock("SF2460I")
		__lF440aB1		:= Existblock("F440aBas")
		__lF440aB2		:= Existblock("F440aBa2")
		__l440Flag		:= Existblock("F440FLAGE3")
		lF440CVB		:= ExistBlock("F440CVB")
		lF440CBase		:= ExistBlock("F440CBASE")
		lF440JurDes		:= ExistBlock("F440JurDes")
		lF440FAL		:= Existblock("F440FAL")
		lPEPerCom		:= ExistBlock("FIN440PE")
		lF440COM		:= ExistBlock("F440COM")

		cModeAcSE1		:= FWModeAccess("SE1",3)
		cModeAcSF1		:= FWModeAccess("SF1",3)
		cModeAcSF2		:= FWModeAccess("SF2",3)
		cModeAcSF4		:= FWModeAccess("SF4",3)
		cModeAcSE2		:= FWModeAccess("SE2",3)
		cModeAcSE4		:= FWModeAccess("SE4",3)
		cModeAcSD1		:= FWModeAccess("SD1",3)
		cModeAcSD2		:= FWModeAccess("SD2",3)
		cModeAcSE5		:= FWModeAccess("SE5",3)
		cModeAcFI7		:= FWModeAccess("FI7",3)
		_cMEmpAcE1		:= FWModeAccess("SE1",1)
		_cMEmpAcE5		:= FWModeAccess("SE5",1)
		
		lLj440SbCm		:= FindFunction("Lj440SbCom") //Lj440SbCom() - LOJA440

		__lExecSt		:= FwLibVersion() >= "20211116"
		__lLbSchdl		:= FwLibVersion() >= "20240520"
		__lAuto			:= .F.

		__lLoaded := .T.

		If __l440Flag
			F440FLAGE3(@__l440Flag, @__cCpoFlag )
		Endif
	EndIf

Return __lLoaded

//-------------------------------------------------------------------
/*{Protheus.doc} FINA440
Cálculo de comissões off line

@param lAuto Indica a chamada via rotina autmática

@author  Eduardo Riera
@version 12.1.27
@since   19/12/1997
*/
//-------------------------------------------------------------------
Function FINA440(lAuto)

Local nEnt		 	:= 0 
Local cLayout	 	:= FWSM0Layout()
Local lGestao	 	:= "E" $ cLayout .Or. "U" $ cLayout
Local lSE1SE3Dif 	:= .F.
Local cFunction		:= "FINA440" as character
Local cTitle		:= STR0003 as character
Local cDescription	:= STR0004 + STR0005 as character
Local cPerg			:= "AFI440" as character
Local oProcess as Object

loadStatic()

Private cCadastro := STR0003 //"Cálculo de comissões off line"
Default lAuto := .F.
__lAuto := lAuto
If !lAuto
	If lGestao
		For nEnt := 1 To 3
			If ( FwModeAccess("SE1", nEnt) <> FwModeAccess("SE3", nEnt) )
				lSE1SE3Dif := .T.
				Exit
			EndIf
		Next nEnt
	Else
		If xFilial("SE1") !=  xFilial("SE3")
            lSE1SE3Dif := .T.
		Endif
	EndIf
	
	If lSE1SE3Dif
		F440Help()
	EndIf
EndIf			
Pergunte("AFI440",.f.)

__lMetric	:= FwLibVersion() >= "20210517"

If !__lLbSchdl
	If isBlind()
		BatchProcess( cCadastro, cDescription, cPerg,{ || Processa({|lEnd| fa440Proc()}) }, { || .F. } )
		Return .T.
	EndIf
EndIf

oProcess := tNewProcess():New( cFunction, cTitle, {|oSelf| fa440Proc(oSelf) }, cDescription, cPerg, /* aInfoCustom*/, /* lPanelAux*/, /* nSizePanelAux*/, /* cDescriAux*/, /* lViewExecute*/, /* lOneMeter*/, .T. )

//---------------------------------------------------------------
// Parametros:
// mv_par01 = Data Inicial
// mv_par02 = Data Final
// mv_par03 = Do Vendedor
// mv_par04 = At‚ o Vendedor
// mv_par05 = Considera Juros (Sim/Não)
// mv_par06 = Considera Descontos (Sim/Não)
// mv_par07 = Calcula Comiss s/NCC (Sim/Não)
// mv_par08 = Calcular (Ambas/Emissao/Baixa)
// mv_par09 = Considera Data (Data Baixa/Data Disponib.)
// mv_par10 = Comis. Vend. Bloqueado (Sim/Não)
// mv_par11 = Calc.Comiss.s/ RAZ (Sim/Não)
//---------------------------------------------------------------

Return(.T.)

Static Function fa440Proc(oProcess)
	Local cMay  	:= "FINA440"
	Local nInicio	:= 0
	Local nFim		:= 0
	Local nRegProc	:= 0
	Local nSetRegua := 0

	Default oProcess := Nil

if MV_PAR08 == 1
	nSetRegua := 6
else
	nSetRegua := 4
endIf

dbSelectArea("SE3")
If !MayIUseCode(cMay+xFilial())
	MsgStop(STR0003 + STR0024)
	Return(.F.)
Endif

//Metricas - Processamento - Inicio
If __lMetric
	nInicio := Seconds()
Endif

// Atualiza o log de processamento - INICIO
ProcLogAtu("INICIO")

If ExistBlock("FN440COM")
	ExecBlock("FN440COM",.F.,.F.)
EndIf
if oProcess <> Nil
	oProcess:SetRegua1(nSetRegua)
endIf

fa440DelE3(MV_PAR08,@nRegProc,oProcess)  //"Excluindo Comiss”es n„o pagas"
If ( MV_PAR08 <> 3 )
	fa440ProcE(@nRegProc,oProcess) //"Calculando Comiss”es pela Emiss„o"
EndIf
If ( MV_PAR08 <> 2 )
	fa440ProcB(__lAuto,@nRegProc,oProcess) //"Calculando Comiss”es pela Baixa"
Endif

// Atualiza o log de processamento - FIM
ProcLogAtu("FIM")

//Metricas - Processamento - FIM
If __lMetric .and. nRegProc > 0
	//Metricas - Acessos a Compensação
	__cFunBkp   := FunName()
	__cFunMet	:= Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA440",__cFunBkp)
	nFim := Seconds() - nInicio
	nFim := nFim / nRegProc 

	SetFunName(__cFunMet)
	FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoGravacao", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
	SetFunName(__cFunBkp)
Endif

dbSelectArea("SE3")
dbSetOrder(1)

Return(.T.)


//-------------------------------------------------------------------
/*{Protheus.doc} Fa440DelE3
Zera as comissoes do periodo antes do recálculo

@param nTipo Indica o tipo de comissão as ser excluida
		1 = Baixa e Emissão
		2 = Emissão
		3 = Baixa

@author  Eduardo Riera
@version 12.1.27
@since   19/12/1997
*/
//-------------------------------------------------------------------
Static Function Fa440DelE3(nTipo,nRegProc,oProcess)

Local aArea			:= GetArea()
Local cChave    	:= ""
Local nValComis		:= ""
Local lDelFisico	:= GetNewPar('MV_FIN440D',.T.)
Local cQuery		:= ""
Local nX			:= 0
Local nMax			:= 0
Local nMin			:= 0
Local cNatCom		:= PADR(&(GetNewPar("MV_NATCOM",'"COMISSOES"')),nTamE2_NATUR)
Local cFunName 		:= Alltrim(FUNNAME())
Local nRecCount		:= 0

DEFAULT nRegProc	:= 0
Default oProcess		:= Nil

if oProcess <> Nil
	oProcess:IncRegua1("Excluindo Registros...")
endIf

If Empty(cNatCom)
	cNatCom := "COMISSOES"
EndIf

dbSelectArea("SE3")
dbSetOrder(1)

//Atualiza saldo das naturezas antes de deletar as comissoes
cQuery := "SELECT E3_VENCTO, SUM(E3_COMIS) VLRCOMIS, E3_EMISSAO, E3_MOEDA "
cQuery += "FROM "+RetSqlName("SE3")+" SE3 "
cQuery += " WHERE SE3.E3_FILIAL   = '"+xFilial("SE3")+"'"
cQuery += 	" AND SE3.E3_EMISSAO BETWEEN '"+ Dtos(mv_par01) +"' AND '"+ Dtos(mv_par02) +"' "
cQuery += 	" AND SE3.E3_VEND BETWEEN '"+ mv_par03 +"' AND '"+ mv_par04 +"' "
cQuery += 	" AND SE3.E3_DATA     = '"+Dtos(Ctod(""))+"'"
cQuery += 	" AND SE3.E3_ORIGEM NOT IN(' ','L') AND "
Do Case
	Case nTipo == 2
		cQuery += "SE3.E3_BAIEMI='E' AND "
	Case nTipo == 3
		cQuery += "SE3.E3_BAIEMI='B' AND "
EndCase

cQuery += 	" SE3.D_E_L_E_T_ = ' '"
cQuery += 	" GROUP BY E3_VENCTO , E3_EMISSAO, E3_MOEDA "
	
cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"TRBNAT")
Count To nRecCount

TRBNAT->(dbGoTop())

TCSetField('TRBNAT','E3_VENCTO','D',8,0)
TCSetField('TRBNAT','VLRCOMIS' ,'N',17,2)
TCSetField('TRBNAT','E3_EMISSAO','D',8,0)

dbSelectArea("TRBNAT")

//Ajuste do Saldo de Naturezas
If cNatCom != NIL

	While TRBNAT->(!Eof())
		// Tratamento de outras moedas no controle de saldos do fluxo de caixa por natureza
		If VAL(TRBNAT->E3_MOEDA) > 1
			nValComis := NOROUND(XMOEDA(TRBNAT->VLRCOMIS,01,VAL(TRBNAT->E3_MOEDA),TRBNAT->E3_EMISSAO))
		Else
			nValComis := TRBNAT->VLRCOMIS
		EndIf

		//Atualizo o valor atual para o saldo da natureza
		//Diminuo pois as comissoes serao recalculadas e somadas posteriormente
		AtuSldNat(cNatCom, TRBNAT->E3_VENCTO, TRBNAT->E3_MOEDA, "2", "P",nValComis, TRBNAT->VLRCOMIS,"-",,cFunName,"SE3",0)
		dbSkip()
	Enddo
Endif

dbSelectArea("TRBNAT")
dbCloseArea()
dbSelectArea("SE3")

If lDelFisico

	// Verifica qual eh o maior e o menor Recno que satisfaca a selecao
	cQuery := "SELECT MIN(R_E_C_N_O_) MINRECNO,"
	cQuery += 		" MAX(R_E_C_N_O_) MAXRECNO "
	cQuery += 	" FROM "+RetSqlName("SE3")+" SE3 "
	cQuery += " WHERE SE3.E3_FILIAL   = '"+xFilial("SE3")+"'"
	cQuery += 	" AND SE3.E3_EMISSAO BETWEEN '"+ Dtos(mv_par01) +"' AND '"+ Dtos(mv_par02) +"' "
	cQuery += 	" AND SE3.E3_VEND BETWEEN '"+ mv_par03 +"' AND '"+ mv_par04 +"' "
	cQuery += 	" AND SE3.E3_DATA     = '"+Dtos(Ctod(""))+"'"
	cQuery += 	" AND SE3.E3_ORIGEM NOT IN(' ','L') AND "
	Do Case
		Case nTipo == 2
			cQuery += "SE3.E3_BAIEMI='E' AND "
		Case nTipo == 3
			cQuery += "SE3.E3_BAIEMI='B' AND "
	EndCase

	cQuery += 	" SE3.D_E_L_E_T_ = ' '"
	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"FA440DELE3")
	
	nMax := FA440DELE3->MAXRECNO
	nMin := FA440DELE3->MINRECNO
	dbCloseArea()

	dbSelectArea("SE3")
	//--------------------------------------
	// Monta a string de execucao no banco
	//--------------------------------------
	cQuery := "DELETE FROM "+ RetSqlName("SE3") +" "
	cQuery += " WHERE E3_FILIAL = '"+ xFilial("SE3" )+"'"
	cQuery += 	" AND E3_EMISSAO BETWEEN '"+ Dtos(mv_par01) +"' AND '"+ Dtos(mv_par02) +"'"
	cQuery += 	" AND E3_VEND BETWEEN '"+ mv_par03 +"' AND '"+ mv_par04 +"'"
	cQuery += 	" AND E3_DATA = '"+ Dtos(Ctod("")) +"'"
	cQuery += 	" AND E3_ORIGEM NOT IN(' ','L') AND "
	Do Case
		Case nTipo == 2
			cQuery += "E3_BAIEMI='E' AND "
		Case nTipo == 3
			cQuery += "E3_BAIEMI='B' AND "
	EndCase
	cQuery += 	" D_E_L_E_T_ = ' ' AND "
	
	//----------------------------------------------------------------------------------------------------------
	//³Executa a string de execucao no banco para os proximos 1024 registro a fim de nao estourar o log do SGBD
	//----------------------------------------------------------------------------------------------------------
	For nX := nMin To nMax STEP 1024
		cChave := "R_E_C_N_O_>="+Str(nX,10,0)+" AND R_E_C_N_O_<="+Str(nX+1023,10,0)+""
		TcSqlExec(cQuery+cChave)
	Next nX

	// A tabela eh fechada para restaurar o buffer da aplicacao
	dbSelectArea("SE3")
	dbCloseArea()
	ChkFile("SE3",.F.)

	if oProcess <> Nil
		oProcess:SetRegua2(1)
		oProcess:IncRegua2()
		oProcess:IncRegua1()
	else
		ProcRegua(1)
		IncProc()
	endIf

Else
	if oProcess <> Nil
		oProcess:SetRegua2(nRecCount)
	else
		ProcRegua(nRecCount)
	endIf

	//Deleção dos registros - NORMAL
	cQuery := "SELECT R_E_C_N_O_ RECSE3 "
	cQuery += "FROM "+RetSqlName("SE3")+" SE3 "
	cQuery += " WHERE SE3.E3_FILIAL   = '"+xFilial("SE3")+"'"
	cQuery += 	" AND SE3.E3_EMISSAO BETWEEN '"+ Dtos(mv_par01) +"' AND '"+ Dtos(mv_par02) +"' "
	cQuery += 	" AND SE3.E3_VEND BETWEEN '"+ mv_par03 +"' AND '"+ mv_par04 +"' "
	cQuery += 	" AND SE3.E3_DATA     = '"+Dtos(Ctod(""))+"'"
	cQuery += 	" AND SE3.E3_ORIGEM NOT IN(' ','L') AND "
	Do Case
		Case nTipo == 2
			cQuery += "SE3.E3_BAIEMI='E' AND "
		Case nTipo == 3
			cQuery += "SE3.E3_BAIEMI='B' AND "
	EndCase
	cQuery += 	" SE3.D_E_L_E_T_ = ' '"
		
	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"FA440DELE3")

	dbSelectArea("FA440DELE3")

	FA440DELE3->(dbGoTop())

	While FA440DELE3->(!Eof())
		SE3->(DBGoto(FA440DELE3->RECSE3))

		nRegProc += 1

		RecLock("SE3")
			If !(__l440Flag .And. SE3->&(Upper(__cCpoFlag)) == "1") .And. IsInCallStack("FINA440") .And. SE3->E3_AJUSTE != "R"
				dbDelete()
			Endif
		MsUnlock()

		FA440DELE3->(dbSkip())
		if oProcess <> Nil
			oProcess:IncRegua2()
		else
			IncProc()
		endIf
	Enddo
	if oProcess <> Nil
		oProcess:IncRegua1()
	endIf
	IF Select("FA440DELE3") > 0
		dbSelectArea("FA440DELE3")
		FA440DELE3->(dbCloseArea())
	EndIf
	dbSelectArea("SE3")
Endif

RestArea(aArea)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³FA440ProcE   ³ Autor ³ Eduardo Riera         ³ Data ³16/12/97³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Processa o c lculo das comissoes pela Emissao               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA440                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Fa440ProcE(nRegProc,oProcess)

Local cAlias	:= "SE1"
Local cQuery	:= ""
Local cSelecVen	:= ""
Local cWhereVen	:= ""
Local nX		:= 0
Local lComiDev	:= SuperGetMv("MV_COMIDEV")
Local lDesdobr	:= .F.
Local lCalcVdLj := AllTrim( SuperGetMV("MV_LJCOMIS",, "") )	== "FINA440"	// Indica se deve considerar vendas do Loja - MV_LJCOMIS Define qual rotina utilizar para os cálculos de comissões de venda Off-Line, LOJA440 ou FINA440.
Local nRecCount	:= 0

DEFAULT nRegProc := 0
Default oProcess	:= Nil

if oProcess <> Nil
	oProcess:IncRegua1("Processando Registros...")
endIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Selecionando Registros                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SE1")
dbSetOrder(1)

__nVend := fa440CntVen() // Numero M ximo de Vendedores

For nX := 1 To __nVend
	cSelecVen += " SE1.E1_VEND" + RetAsc( nX, 1, .T. ) + ", "
	cWhereVen += " (SE1.E1_VEND" + RetAsc( nX, 1, .T. ) + " >= '" + mv_par03 + "' AND  SE1.E1_VEND" + RetAsc( nX, 1, .T. ) + " <= '" + mv_par04 + "') " + IIF(nX <> __nVend, "OR", "") + " "
Next nX

cAlias := "FA440PROCE"

cQuery := "SELECT R_E_C_N_O_     SE1RECNO,       SE1.E1_TIPO,  SE1.E1_ORIGEM,  "
cQuery += 		" SE1.E1_FILIAL, SE1.E1_PREFIXO, SE1.E1_NUM,   SE1.E1_PARCELA, SE1.E1_CLIENTE, SE1.E1_LOJA, "
cQuery += 		cSelecVen // Vendedores
cQuery += 		" SE1.E1_DESDOBR "
cQuery += " FROM "+RetSqlName("SE1")+" SE1 "
cQuery += " WHERE SE1.E1_FILIAL   = '"+xFilial("SE1")+"'"
cQuery += 		" AND SE1.E1_EMISSAO >= '"+DTOS(mv_par01)+"'"
cQuery += 		" AND SE1.E1_EMISSAO <= '"+DTOS(mv_par02)+"'"
cQuery += 		" AND SE1.E1_ORIGEM NOT LIKE('%FINA630%') "
// Filtro para rodar a atualização somente dos vendedores escolhidos no filtro.
cQuery += " AND ("
cQuery += cWhereVen // Vendedores
cQuery += " )"
cQuery += " AND "
cQuery += " SE1.E1_TIPO NOT IN('" + MVRECANT + "','NCC'"
If ( !lComiDev )
	For nX := 1 To Len(MV_CRNEG) STEP 4
		If SubStr(MV_CRNEG,nX,3)<>'NCC'
			cQuery += ",'"+SubStr(MV_CRNEG,nX,3)+"'"
		EndIf
	Next nX
EndIf

If lCalcVdLj
	cQuery += " ) "
Else
	cQuery += ") AND SE1.E1_ORIGEM NOT LIKE 'LOJA%' "
EndIf

cQuery += " AND SE1.D_E_L_E_T_ = ' ' "

cQuery += " Union All "
cQuery += " SELECT R_E_C_N_O_ SE1RECNO, SE1.E1_TIPO, SE1.E1_ORIGEM, "
cQuery += 		" SE1.E1_FILIAL, SE1.E1_PREFIXO, SE1.E1_NUM, SE1.E1_PARCELA, SE1.E1_CLIENTE, SE1.E1_LOJA, "
cQuery += 		cSelecVen
cQuery += 		" SE1.E1_DESDOBR "
cQuery += " FROM "+RetSqlName("SE1")+" SE1 "
cQuery += " WHERE SE1.E1_FILIAL   = '"+xFilial("SE1")+"'"
cQuery += 	" AND SE1.E1_EMISSAO >= '"+DTOS(mv_par01)+"'"
cQuery += 	" AND SE1.E1_EMISSAO <= '"+DTOS(mv_par02)+"'"
If lF440COM
	cQuery += " AND SE1.E1_TIPO IN " + FormatIn( MVRECANT + "|" + MV_CRNEG, "|" )
Else 
	cQuery += " AND SE1.E1_TIPO = 'NCC' "
EndIf

If !lCalcVdLj
	cQuery += 	" AND SE1.E1_ORIGEM NOT LIKE 'LOJA%' "
EndIf

cQuery += 	" AND SE1.D_E_L_E_T_ = ' ' "
cQuery += " ORDER BY "+SqlOrder(SE1->(IndexKey()))

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias)
Count To nRecCount

(cAlias)->(dbGoTop())

if oProcess <> Nil
	oProcess:SetRegua2(nRecCount)
else
	ProcRegua(nRecCount)
endIf

	
While ( ! (cAlias)->(Eof()) )
	If !(cAlias)->E1_TIPO $ MVABATIM
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo da Comissao na Emissao                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		
		If (cAlias)->E1_DESDOBR == "1"
			lDesdobr := VerBxDsd((cAlias)->E1_PREFIXO, (cAlias)->E1_NUM, (cAlias)->E1_PARCELA, (cAlias)->E1_TIPO, (cAlias)->E1_CLIENTE, (cAlias)->E1_LOJA )
		EndIf

		If !lDesdobr
			dbSelectArea("SE1")
			MsGoto((cAlias)->(SE1RECNO))
			Fa440CalcE("FINA440",mv_par03,mv_par04,,,,@nRegProc)
		EndIf
	EndIf
	dbSelectArea(cAlias)
	dbSkip()
	if oProcess <> Nil
		oProcess:IncRegua2()
	else
		IncProc(STR0010+":"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA) //"Titulo"
	endIf
EndDo

if oProcess <> Nil
	oProcess:IncRegua1()
endIf

dbSelectArea(cAlias)
dbCloseArea()

dbSelectArea("SE1")
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Fa440CalcE³ Autor ³ Eduardo Riera         ³ Data ³ 16/12/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Efetua c lculo das comissoes pela emissao                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1: Origem da Comissao			 			          ³±±
±±³			 ³ ExpC2: Vendedor De 										  ³±±
±±³			 ³ ExpC3: Vendedor Ate										  ³±±
±±³			 ³ ExpC4: Sinal da Comissao (+/-) 							  ³±±
±±³			 ³ ExpL5: Indica se a Comissao ira considerar as parcelas do  ³±±
±±³     	 ³        Titulo Financeiro                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Fina440                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function Fa440CalcE(cOrigem,cVendDe,cVendAte,cSinal,lParcela,lAjusVlr,nRegProc)

Local aArea 	 := GetArea()
Local nCntFor    := 1
Local lPago      := .F.
Local aBases     := {}
Local nBases	 := 0
Local nValor     := 0
Local nVlrProp   := 0
Local cVend      := ""
Local cVendedor  := ""
Local aVendedor  := {}
Local cParcela   := Space(nTamParc)
Local nDia		 := 0
Local nMes		 := 0
Local nAno		 := 0
Local dVencto	 := Ctod("")
Local lComVdBlq  := .T.
Local nValComis	 := 0
Local nDecimal   := nTamBascom // N@ de decimais considerados no calculo
Local nDecimalP	 := nTamPerc   // N@ de decimais considerados no percentual de comissão
Local lAtuSldNat := lFindAtuSld
Local cNatCom	 := PADR(&(GetNewPar("MV_NATCOM",'"COMISSOES"')),nTamE2_NATUR)
Local nPosVend	 := 0	//posicao do campo E3_VEND
Local nPosBase	 := 0	//posicao do campo E3_BASE
Local aSE3		 := {}	//array com os dados da comissao
Local nI		 := 0	//contador
Local cSuperv	 := ""	//Supervisor do Vendedor (A3_SUPER)
Local cGerente	 := ""	//Gerente do Vendedor (A3_GEREN)
Local cMvTpComLj := AllTrim( SuperGetMV("MV_TPCOMLJ",,"B") )	//indica se a comissao eh online ou offline (SIGALOJA)
Local lMSE3440   := ExistBlock("MSE3440")
Local cOnOff	 := ""	 
Local aPosSE1	 := {}  //Array para guardar dados(E1_NUMNOTA,E1_SERIE,E1_CLIENTE,E1_LOJA) que serão enviados como parâmetro para função Lj720RecComis
Local cMVLJCOMIS := AllTrim( SuperGetMV("MV_LJCOMIS",, "") )	// Define qual rotina utilizar para os cálculos de comissões de venda, LOJA440 ou FINA440.
Local nPosBxEmi	:= 0	//posicao do campo E3_BAIEMI
Local nPosComis := 0	//posicao do campo E3_COMIS
Local nPosPorc	 := 0   //posicao do campo E3_PORC
Local lMultVend  :=	SuperGetMv("MV_LJTPCOM",,"1" ) == "2"

Private nJuros 	:= 0
Private nDescont:= 0
Private nMulta	:= 0

DEFAULT lF440BasEm	:= Existblock("F440BASE")
DEFAULT cParComEm 	:= GetNewPar("MV_PARCOMI","N") // Parcelamento da comissao na emissao
DEFAULT lF440VEND	:= ExistBlock("F440VEND")
DEFAULT lAjusVlr    := .F.
DEFAULT nRegProc	:= 0

lF440BasEm	:= Existblock("F440BASE")

If Empty(cNatCom)
	cNatCom := "COMISSOES"
EndIf

If (lParcela == Nil)
	lParcela:= .F.
EndIf

If IsInCallStack("LJ7Venda") .AND. AllTrim(GetNewPar("MV_PARCOMI","N")) == "N"
	// Tratamento para quando a tela de devolucao de venda (LOJA720) eh aberta de dentro do Venda Assistida.
	cParComEm := "N"
EndIf

If lParcela
	cParComEm:= "S"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ponto de entrada para validacoes de usuario para calculo de comissao  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lFA440VLD .And. ! ExecBlock( "FA440VLD", .F., .F., 1 )
	Return .F.
EndIf

//Metricas - Acessos a Calculo de Comissões EMISSAO
If __lMetric == NIL
	__lMetric	:= FwLibVersion() >= "20210517"
Endif

If __lComisON == NIL
	__lComisON := (SuperGetMV("MV_TPCOMIS",,"O") == "O")
Endif

If __lMetric
	cOnOff := Alltrim(ProcName()) + If(__lComisON, " - ON" , " - OFF")
	__cFunBkp   := FunName()
	__cFunMet	:= Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA440",__cFunBkp)

	SetFunName(__cFunMet)
	// Metrica de controle de acessos 
   	FwCustomMetrics():setUniqueMetric(cOnOff, "financeiro-protheus_qtd-por-acesso_total", "1")
	SetFunName(__cFunBkp)
Endif

dbSelectArea("SE3")    // Para Abrir se precisar
dbSelectArea (aArea[1])
cOrigem  := If(Empty(cOrigem),"FINA440", AllTrim(cOrigem) )
cVendDe  := If( cVendDe==Nil ,Space(Len(SE3->E3_VEND)),cVendDe)
cVendAte := If( cVendAte==Nil,Repl("z",Len(SE3->E3_VEND)),cVendAte)
cSinal   := If( cSinal  == Nil ,If(SE1->E1_TIPO$MV_CRNEG,"-","+"),cSinal)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria a natureza IRF caso nao exista		   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aAreaSED  	:= SED->(GetArea())
DbSelectArea("SED")
If ( !DbSeek(XFILIAL("SED")+cNatCom) ) .AND. lAtuSldNat
	RecLock("SED",.T.)
	SED->ED_FILIAL  := XFILIAL("SED")
	SED->ED_CODIGO  := cNatCom
	SED->ED_CALCIRF := "N"
	SED->ED_CALCISS := "N"
	SED->ED_CALCINS := "N"
	SED->ED_CALCCSL := "N"
	SED->ED_CALCCOF := "N"
	SED->ED_CALCPIS := "N"
	SED->ED_DESCRIC := "COMISSOES DE VENDEDORES"
	SED->ED_TIPO	:= "2"
	MsUnlock()
	FKCOMMIT()
Else
	RestArea(aAreaSED)

EndIf

If !(SE1->E1_TIPO$MV_CRNEG+"/"+MVTAXA+"/"+MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG) .Or. ;
		(SE1->E1_TIPO$MV_CRNEG .And. SuperGetMv("MV_COMIDEV")) .And.;
		!SE1->E1_TIPO $ MVABATIM

	If Alltrim(SE1->E1_FATURA) == "NOTFAT"
		Return .f.
	EndIf

	aBases   := Fa440Comis(SE1->(Recno()),.T.,.T.)
    
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada para manipular o tratamento do calculo      ³
	//³ das bases da comissao.                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lF440BasEm
		aBases := ExecBlock("F440BASE",.F.,.F.,aBases)
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Adiciona vendedores que deverÆo ter comissÆo calculada por t¡tulo. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	For nCntFor := 1 To Len(aBases)
		If lF440VEND
			lRet := ExecBlock("F440VEND",.f.,.f.,{aBases[nCntFor,1],SE1->E1_NUM})
			If lRet == .T.
				cVendedor := aBases[nCntFor,1]
			Else
				cVendedor := ""
			EndIf
		Else
			cVendedor := aBases[nCntFor,1]
		EndIf
		If (!Empty(cVendedor) .And. ;
				cVendedor >= cVendDe .And. ;
				cVendedor <= cVendAte )
			AAdd( aVendedor, { cVendedor })
		EndIf
	Next nCntFor

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Efetua os c lculos para cada vendedor.                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nCntFor := 1 To Len( aVendedor )
		lPago  		:= .F.
		lComVdBlq	:= .T.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Procura a Base da Comissao                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nBases := aScan(aBases,{|x| x[1] == aVendedor[nCntFor][1] })
		If ( nBases <> 0 )
			nValor := aBases[nBases][5]
			nVlrProp := aBases[nBases][3]
			If cPaisLoc == "PTG"
				nValor := aBases[nBases,11]
				nVlrProp := aBases[nBases,12]
			EndIf
		Else
			nValor := 0
		EndIf

		aBases[nBases] := Fa440LjTrc(@nVlrProp,@nValor,aBases[nBases],"E")

		If ( nValor <> Nil .And. nValor <> 0 )
			cParcela := IIF(cParComEm=="S",SE1->E1_PARCELA,Space(nTamParc))
		
			SA3->(MsSeek(xFilial("SA3")+aVendedor[nCntFor,1]))
			If lF440CVB			
				lComVdBlq := ExecBlock("F440CVB",.F.,.F.)
			ElseIf SA3->A3_MSBLQL == "1"
				lComVdBlq := .F.
				If (cOrigem == "FINA440" .and. MV_PAR10 == 1)
					lComVdBlq := .T.
				EndIf
			EndIf

			If lComVdBlq
				SE3->(DbSetOrder(3))	//E3_FILIAL + E3_VEND + E3_CODCLI + E3_LOJA + E3_PREFIXO + E3_NUM + E3_PARCELA + E3_TIPO + E3_SEQ
				If SE3->(DbSeek(xFilial("SE3")+aVendedor[nCntFor,1]+;
					SE1->E1_CLIENTE+SE1->E1_LOJA+SE1->E1_PREFIXO+SE1->E1_NUM+cParcela+SE1->E1_TIPO+Space(Len(SE3->E3_SEQ)),.F.))

					If ( !Empty(SE3->E3_DATA) )
						lPago := .T.
						If ( !cOrigem $ "FINA440" ) //.And. cSinal == "-" )
							RecLock("SE3",.T.)
						EndIf
					// Não alterar comissões geradas pelo LOJA440 	E3_ORIGEM = L
					ElseIf SE3->E3_ORIGEM == "L" .Or. (__l440Flag .And. SE3->&(Upper(__cCpoFlag)) == "1" .And. IsInCallStack("FINA440")) .Or. SE3->E3_AJUSTE = "R"
						Loop
					Else
						lPago := .F.
						RecLock("SE3",.F.)					
					EndIf
				Else
					lPago := .F.
					RecLock("SE3",.T.)
				EndIf
				If aBases[nBases][5] <> Nil
					If ( (!lPago .Or. !cOrigem$"FINA440") .And. aBases[nBases][5] <> 0 )
						
						If lAjusVlr
							SE3->E3_BASE  := (nVlrProp * Iif(cSinal == "-",-1,1) )	// Valor Base da Comissao
							If SE3->E3_COMIS == Round(nValor,nDecimal)
								SE3->E3_COMIS := (Round(nValor,nDecimal) * Iif(cSinal == "-",-1,1) ) // Valor a Pagar ( na EmissÆo )
							Else
								SE3->E3_COMIS := (nValor * Iif(cSinal == "-",-1,1) ) // Valor a Pagar ( na EmissÆo )
							Endif
						Else
							SE3->E3_BASE    += (nVlrProp * Iif(cSinal == "-",-1,1) )	// Valor Base da Comissao
							// tratamento para arredondamentos
							If SE3->E3_COMIS == Round(nValor,nDecimal)
								SE3->E3_COMIS   += (Round(nValor,nDecimal) * Iif(cSinal == "-",-1,1) ) // Valor a Pagar ( na EmissÆo )
							Else
								SE3->E3_COMIS   += (nValor * Iif(cSinal == "-",-1,1) ) // Valor a Pagar ( na EmissÆo )
							Endif
						EndIf

						SE3->E3_FILIAL  := xFilial()				// Filial
						SE3->E3_VEND    := aVendedor[nCntFor,1]		// C¢d. Vendedor
						SE3->E3_NUM     := SE1->E1_NUM        		// No. T¡tulo
						SerieNfId('SE3',1,'E3_SERIE',,,,SE1->E1_SERIE)
						SE3->E3_PORC    := Abs(Round((SE3->E3_COMIS/SE3->E3_BASE)*100,nDecimalP))	// % da ComissÆo ( na EmissÆo )
						SE3->E3_CODCLI  := SE1->E1_CLIENTE    		// C¢d. Cliente
						SE3->E3_LOJA    := SE1->E1_LOJA       		// Loja
						SE3->E3_EMISSAO := SE1->E1_EMISSAO    		// Data da emissao do t¡tulo
						SE3->E3_PREFIXO := SE1->E1_PREFIXO    		// Prefixo do T¡tulo
						SE3->E3_PARCELA := cParcela
						SE3->E3_TIPO    := SE1->E1_TIPO       		// Tipo do T¡tulo
						SE3->E3_BAIEMI  := "E"                		// Flag (Pago na Emissao)

						If AllTrim(SE1->E1_ORIGEM) $ "LOJA010#LOJA020#LOJA220#FRTA010#LOJA701#LOJA720"
							SE3->E3_ORIGEM  := Fa440Origem(cOrigem)	
						Else
							SE3->E3_ORIGEM  := Fa440Origem(If(Empty(SE1->E1_ORIGEM),cOrigem,SE1->E1_ORIGEM))
						EndIf

						SE3->E3_PEDIDO  := SE1->E1_PEDIDO
						SE3->E3_CCUSTO  := SE1->E1_CCUSTO

						If ( aBases[nBases][7] <> 0 )
							SE3->E3_PORC := aBases[nBases][7]
						EndIf

						If Empty( SA3->A3_DIA )
							dVencto := SE1->E1_EMISSAO
						Else
							dVencto := Ctod( strzero(SA3->A3_DIA,2)+"/"+;
								strzero(month(SE1->E1_EMISSAO),2)+"/"+;
								strzero( year(SE1->E1_EMISSAO),4),"ddmmyy")
							nDia := SA3->A3_DIA

							While empty( dVencto)
								nDia -= 1
								dVencto := CtoD(strzero(nDia,2)+"/"+;
									strzero(month(SE1->E1_EMISSAO),2)+"/"+;
									strzero( year(SE1->E1_EMISSAO),4),"ddmmyy")
							EndDo
						EndIf
	
						if SA3->A3_DDD == "F" .or. dVencto < SE1->E1_EMISSAO		//Fora o mes
							nDia := SA3->A3_DIA
							nMes := month(dVencto) + 1
							nAno := year (dVencto)
							If nMes == 13
								nMes := 01
								nAno := nAno + 1
							Endif
							nDia	  := strzero(nDia,2)
							nMes	  := strzero(nMes,2)
							nAno	  := substr(lTrim(str(nAno)),3,2)
							dVencto := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
						Else
							nDia	  := strzero(day(dVencto),2)
							nMes	  := strzero(month(dVencto),2)
							nAno	  := substr(lTrim(str(Year(dVencto))),3,2)
						Endif
	
						While empty( dVencto)
							nDia := if(Valtype(nDia)=="C",Val(nDia),nDia)
							nDia -= 1
							dVencto := CtoD(strzero(nDia,2)+"/"+nMes+"/"+nAno,"ddmmyy")
							if !empty( dVencto )
								if dVencto < SE1->E1_EMISSAO
									dVencto += 2
								EndIf
							EndIf
						Enddo

						SE3->E3_VENCTO  := dVencto

						If cPaisLoc=="MEX"
							SE3->E3_MOEDA := StrZero(1,__nTmMoed)
						Else
					   		SE3->E3_MOEDA := StrZero(SE1->E1_MOEDA,__nTmMoed)
						EndIf

						If lMSE3440
							ExecBlock("MSE3440",.F.,.F.)
						EndIf

						//Controle de Saldo de Naturezas
						If lAtuSldNat .and. cNatCom <> NIL
							//Atualizo o valor atual para o saldo da natureza
							//Diminuo pois as comissoes serao recalculadas e somadas posteriormente
							If Val(SE3->E3_MOEDA) > 1
								nValComis := NoRound( XMOEDA(nValor,1, Val(SE3->E3_MOEDA),SE3->E3_EMISSAO) )
							Else
						   		nValComis := nValor
							EndIf

							cMoeda := SE3->E3_MOEDA
							AtuSldNat(	cNatCom	, dVencto	, cMoeda	, "2"				,;
										"P"		, nValComis	, nValor	, cSinal			,;
										Nil		, FunName()	, "SE3"		, SE3->(Recno())	)
						EndIf
						MsUnlock()

						// Recalcula comissão do vendedor, em casos de vendas com devolução parcial
						If ("LOJA"$SE1->E1_ORIGEM) .AND. IsInCallStack("LOJA720")
							aPosSE1	 := {}
							Aadd(aPosSE1,{SE1->E1_NUMNOTA, SE1->E1_SERIE, SE1->E1_CLIENTE, SE1->E1_LOJA })
							LJ720RecComis( aPosSE1, 1, SE1->E1_FILIAL, Nil, .T. )
						EndIf

						//Metricas - Registros processados
						nRegProc += 1

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Somente gravamos as comissoes para Supervisor e Gerente para as comissoes|
						//|do modulo SIGALOJA. Para outros modulos, eh necessario uma analise		³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lLj440SbCm .AND. lMultVend .AND. ((SE3->E3_ORIGEM == "L" .OR. SE3->E3_ORIGEM == "D") .OR. cMVLJCOMIS == "FINA440" .OR. "LOJA" $SE1->E1_ORIGEM) .AND.;
						 cMvTpComLj == "O" .AND. ( !Empty(SA3->A3_SUPER) .OR. !Empty(SA3->A3_GEREN) )

							For nI := 1 to SE3->( FCount() )
								Aadd(aSE3, {FieldName(nI), &(FieldName(nI))} )	//nome do campo, valor do campo
							Next

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Verifica se existe gerente ou supervisor³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							cSuperv	:= SA3->A3_SUPER
							cGerente:= SA3->A3_GEREN
							cVend	:= SA3->A3_COD
							nPosVend:= aScan( aSE3, {|x| x[1]  == "E3_VEND"} )
							nPosBase:= aScan( aSE3, {|x| x[1]  == "E3_BASE"} )
							nPosPorc:= aScan( aSE3, {|x| x[1]  == "E3_PORC"} )
							nPosBxEmi:= aScan( aSE3, {|x| x[1] == "E3_BAIEMI"} )	
							nPosComis:= aScan( aSE3, {|x| x[1] == "E3_COMIS"} )

							If !Empty(cSuperv)	//verifica se o vendedor possui um supervisor cadastrado
								If nPosVend > 0
									aSE3[nPosVend][2] := cSuperv
								EndIf

								If nPosBase > 0	//valor base = valor emissao + valor baixa
									aSE3[nPosBase][2] := aBases[nCntFor][3] + aBases[nCntFor][4]
								EndIf
								
								// Gera Comissão pela porcentagem na Emissão do Supervisor
								If SA3->A3_ALEMISS > 0
									aSE3[nPosBxEmi][2] := "E"								
									aSE3[nPosPorc][2]  := ( SA3->A3_COMIS * SA3->A3_ALEMISS ) / 100	//% comissao
									aSE3[nPosComis][2] := ( aSE3[nPosBase][2] * aSE3[nPosPorc][2] ) / 100	//$ comissao
								  	Lj440SbCom(aSE3)	//(LOJA440.PRW)
								EndIf
							EndIf

							If !Empty(cGerente)	//verifica se o vendedor possui um gerente cadastrado
								If nPosVend > 0
									aSE3[nPosVend][2] := cGerente
								EndIf

								If nPosBase > 0	//valor base = valor emissao + valor baixa
									aSE3[nPosBase][2] := aBases[nCntFor][3] + aBases[nCntFor][4]
								EndIf

								// Gera Comissão pela porcentagem na Emissão do Gerente
								If SA3->A3_ALEMISS > 0
									aSE3[nPosBxEmi][2] := "E"								
									aSE3[nPosPorc][2]  := ( SA3->A3_COMIS * SA3->A3_ALEMISS ) / 100	//% comissao
									aSE3[nPosComis][2] := ( aSE3[nPosBase][2] * aSE3[nPosPorc][2] ) / 100	//$ comissao
								  	Lj440SbCom(aSE3)	//(LOJA440.PRW)
								EndIf												
							EndIf

							aSE3 := {}	//resetamos o array aSE3
						EndIf	//fim do bloco referente a gravacao de comissao dos gerentes e supervisores

					EndIf
				Endif
			Endif
		EndIf
	Next nCntFor
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada do F440COM,	 serve p/ tratar Comis-³
	//³sao dos titulos RA.                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE1->E1_TIPO $ MVRECANT
		IF lF440COM
			ExecBlock( "F440COM", .F., .F. )
		Endif
	EndIf
Endif
dbSelectArea("SE3")
dbSetOrder(1)

dbSelectArea("SA3")
dbSetOrder(1)

RestArea(aArea)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³FA440ProcB ³ Autor ³ Eduardo Riera         ³ Data ³ 16/12/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Processa o c lculo das comissoes pela Baixa                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA440                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Fa440ProcB(lAuto as Logical, nRegProc as Numeric, oProcess as Object) as Logical

Local aBaixas 	 as Array
Local aBxEst	 as Array
Local cChave	 as Character
Local cQuebra    as Character
Local cRegPos	 as Character
Local cAliasSE5  as Character
Local nPos       as Numeric
Local cQuery     as Character
Local nCntFor    as Numeric
Local cSeekSE5   as Character
Local lFA440 	 as Logical
Local lGerComNeg as Logical
Local nRecCount	 as Numeric
Local oMovements as Object
Local oDocumenE5 as Object
Local cTipoComp  as Character

Default lAuto 	:= .F.
Default nRegProc := 0
Default oProcess := Nil

aBaixas    := {}
aBxEst	   := {}
cChave	   := ""
cQuebra    := ""
cRegPos	   := ""
cAliasSE5  := "SE5"
nPos       := 0
cQuery     := ""
nCntFor    := 0
cSeekSE5   := ""
lFA440 	   := FunName() == "FINA440"
lGerComNeg := .F.
nRecCount  := 0
oMovements := Nil
oDocumenE5 := Nil
cTipoComp  := ""

if oProcess <> Nil
	oProcess:IncRegua1("Processando Registros...")
endIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³             Array aBaixas             ³
//³                                       ³
//³ 1 : Motivo da Baixa                   ³
//³ 2 : Sequencia da Baixa                ³
//³ 3 : Registro no SE5                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Abre com outro alias para eliminar o filtro do Top Connect ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( ChkFile("SE5",.F.,"NEWSE5") )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Selecionando Registros.               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE5")
	If lFA440
		cChave   := "E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ+DTOS(E5_DATA)+E5_MOTBX"
	Else
		cChave   := "E5_FILIAL+DTOS(E5_DATA)+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_MOTBX+E5_SEQ"
	Endif

	cAliasSE5 := "FA440PROCB"	
	
	cQuery := "SELECT E5_FILIAL, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA, E5_SEQ, E5_DATA, "
	cQuery += "E5_MOTBX, E5_FORMAPG, E5_DOCUMEN, E5_TIPODOC, E5_SITUACA, E5_RECPAG, E5_FILORIG, SE5.R_E_C_N_O_ SE5RECNO "	
	cQuery += "FROM "+RetSqlName("SE5") + " SE5 "
	cQuery += "WHERE "
	cQuery += Fa440ChecF(2,.T.)+" AND "
	cQuery += "D_E_L_E_T_=' ' "
	cQuery += "ORDER BY "+SqlOrder(cChave)
	cQuery := ChangeQuery(cQuery)
	
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE5)
	TcSetField("SE5", "E5_DATA", "D", 8, 0)
	Count To nRecCount
	(cAliasSE5)->(dbGoTop())
	
	if oProcess <> Nil
		oProcess:SetRegua2(nRecCount)
	else
		ProcRegua(nRecCount)
	endIf

	If (cAliasSE5)->(!Eof())				   	
		If Alltrim((cAliasSE5)->E5_MOTBX) == "LOJ"
			cQuebra := Alltrim((cAliasSE5)->E5_PREFIXO+(cAliasSE5)->E5_NUMERO+(cAliasSE5)->E5_PARCELA+(cAliasSE5)->E5_TIPO+(cAliasSE5)->E5_CLIFOR+(cAliasSE5)->E5_LOJA+(cAliasSE5)->E5_FORMAPG)
		Else
			cQuebra := Alltrim((cAliasSE5)->E5_PREFIXO+(cAliasSE5)->E5_NUMERO+(cAliasSE5)->E5_PARCELA+(cAliasSE5)->E5_TIPO+(cAliasSE5)->E5_CLIFOR+(cAliasSE5)->E5_LOJA)
		EndIf

		__lUsaClass := Iif(__lUsaClass == Nil, FindClass("totvs.protheus.backoffice.fin.movements.Movements"), __lUsaClass)

		If __lUsaClass
			oMovements := totvs.protheus.backoffice.fin.movements.Movements():New()	
		EndIf
	EndIf

	While ( (cAliasSE5)->(!Eof()) .And. (xFilial("SE5") == (cAliasSE5)->E5_FILIAL .OR. cFilAnt == (cAliasSE5)->E5_FILORIG) )
		If !f440Loja("SE5",cAliasSE5)		// Baixas de Vendas do SIGALOJA nao deve entrar.
			nPos := (__nTmPref) + (__nTmNum) + (__nTmParc) + 1

			cTipoComp := Substr((cAliasSE5)->E5_DOCUMEN, nPos, 3)			

			If __lUsaClass .And. (cAliasSE5)->E5_MOTBX == "CMP"
				oDocumenE5 := oMovements:getCompDocumentJsonBySE5((cAliasSE5)->SE5RECNO)							
				If oDocumenE5 <> Nil .And. Len(oDocumenE5["document"]) > 0
					cTipoComp := oDocumenE5["document"][1]["FK7_TIPO"]					
				EndIf			
			EndIf

			If ( (cAliasSE5)->E5_TIPODOC != "ES" .and. !(cAliasSE5)->E5_TIPO $ MVPAGANT .and. (cAliasSE5)->E5_SITUACA != "C" ) .And.;
				 (  ( (mv_par07 == 1 .And. cTipoComp == MV_CRNEG .And. (cAliasSE5)->E5_MOTBX == "CMP" .And. !(cAliasSE5)->E5_TIPO$MV_CRNEG+"|"+MVRECANT) ) .Or. ; 	// SIM - > COMISSÃO NCC
   			   	  	( (mv_par11 == 1 .And. cTipoComp == MVRECANT .And. (cAliasSE5)->E5_MOTBX == "CMP" .And. !(cAliasSE5)->E5_TIPO$MV_CRNEG+"|"+MVRECANT) ) .Or. ;	// SIM - > COMISSÃO RA 
				    ( !(cAliasSE5)->E5_MOTBX == "CMP" .And. !(cAliasSE5)->E5_TIPO$MV_CRNEG+"|"+MVRECANT)	)	.OR. ((cAliasSE5)->E5_MOTBX == "CMP" .AND.(cAliasSE5)->E5_TIPO $ MV_CRNEG .AND. mv_par07 == 1) 	
				aadd(aBaixas,{ (cAliasSE5)->E5_MOTBX,(cAliasSE5)->E5_SEQ,(cAliasSE5)->SE5RECNO })
			Elseif ((cAliasSE5)->E5_TIPODOC == "ES" .or. (cAliasSE5)->E5_SITUACA == "C")  .And. !( (cAliasSE5)->E5_TIPO $ MVRECANT+"|"+MV_CRNEG )
				aadd(aBxEst, {(cAliasSE5)->SE5RECNO,(cAliasSE5)->E5_FILIAL} )
			EndIf
		EndIf

		dbSelectArea(cAliasSE5)
		//Marca flag para geracao de comissao negativa.
		If (cAliasSE5)->E5_RECPAG $ "P|R".And.(cAliasSE5)->E5_TIPO $ MV_CRNEG
			lGerComNeg := .T.
		Endif
		(cAliasSE5)->(dbSkip())
		if oProcess <> Nil
			oProcess:IncRegua2()
		else
			IncProc(STR0010+":"+(cAliasSE5)->E5_PREFIXO+(cAliasSE5)->E5_NUMERO+(cAliasSE5)->E5_PARCELA) //"Titulo"
		endIf
		
		If Alltrim((cAliasSE5)->E5_MOTBX) == "LOJ"
			cRegPos := Alltrim((cAliasSE5)->E5_PREFIXO+(cAliasSE5)->E5_NUMERO+(cAliasSE5)->E5_PARCELA+(cAliasSE5)->E5_TIPO+(cAliasSE5)->E5_CLIFOR+(cAliasSE5)->E5_LOJA+(cAliasSE5)->E5_FORMAPG)
		Else
			cRegPos := Alltrim((cAliasSE5)->E5_PREFIXO+(cAliasSE5)->E5_NUMERO+(cAliasSE5)->E5_PARCELA+(cAliasSE5)->E5_TIPO+(cAliasSE5)->E5_CLIFOR+(cAliasSE5)->E5_LOJA)
		EndIf
		
		If (cQuebra != cRegPos) .OR. Eof()

			If ( !Empty(aBaixas) )
				
				fa440CalcB(aBaixas,If(MV_PAR05==1,.T.,.F.), If(MV_PAR06==1,.T.,.F.),;
									"FINA440",If(lGerComNeg,"-","+"),mv_par03,mv_par04,,,mv_par09,,lAuto,@nRegProc)
			EndIf
			If ( !Empty(aBxEst) )
				For nCntFor := 1 To Len(aBxEst)
					aBaixas := {}
					dbSelectArea("NEWSE5")
					MsGoto(aBxEst[nCntFor][1])
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Caso tenha desconto o MsGoto ira posicionar numa sequencia do SE5       ³
					//³que ja foi processada por isso a verificao abaixo                       ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If cSeekSE5 == NEWSE5->E5_PREFIXO+NEWSE5->E5_NUMERO+NEWSE5->E5_PARCELA+NEWSE5->E5_TIPO+NEWSE5->E5_CLIFOR+NEWSE5->E5_LOJA+NEWSE5->E5_SEQ
						Loop
					EndIf
					cSeekSE5 := NEWSE5->E5_PREFIXO+NEWSE5->E5_NUMERO+NEWSE5->E5_PARCELA+NEWSE5->E5_TIPO+NEWSE5->E5_CLIFOR+NEWSE5->E5_LOJA+NEWSE5->E5_SEQ
					dbSelectArea("NEWSE5")
					dbSetOrder(7)
					MsSeek(aBxEst[nCntFor][2]+cSeekSE5)
					While ( !Eof() .And. aBxEst[nCntFor][2]	== NEWSE5->E5_FILIAL .And.;
							cSeekSE5			== NEWSE5->E5_PREFIXO+;
							NEWSE5->E5_NUMERO+;
							NEWSE5->E5_PARCELA+;
							NEWSE5->E5_TIPO+;
							NEWSE5->E5_CLIFOR+;
							NEWSE5->E5_LOJA+;
							NEWSE5->E5_SEQ )
						If ( NEWSE5->E5_TIPODOC != "ES" )
							aadd(aBaixas,{ NEWSE5->E5_MOTBX,NEWSE5->E5_SEQ,NEWSE5->(Recno()) })
						EndIf
						dbSelectArea("NEWSE5")
						dbSkip()
					EndDo
					dbSelectArea(cAliasSE5)
					fa440DeleB(aBaixas,If(MV_PAR05==1,.T.,.F.),;
						If(MV_PAR06==1,.T.,.F.);
						,"FINA440",mv_par03,mv_par04)
				Next nCntFor
			EndIf
			dbSelectArea(cAliasSE5)
			lGerComNeg := .F. 	//Recarrega como falso a variavel para verificacao do titulo seguinte.
			aBaixas := {}
			aBxEst  := {}
			cQuebra :=  Alltrim((cAliasSE5)->E5_PREFIXO+(cAliasSE5)->E5_NUMERO+(cAliasSE5)->E5_PARCELA+;
				(cAliasSE5)->E5_TIPO+(cAliasSE5)->E5_CLIFOR+(cAliasSE5)->E5_LOJA)
		EndIf
	EndDo

	if oProcess <> Nil
		oProcess:IncRegua1()
	endIf
	dbSelectArea(cAliasSE5)
	dbCloseArea()
	dbSelectArea("SE5")
	
	dbSelectArea("NEWSE5")
	dbCloseArea()
	dbSelectArea("SE5")
Else
	Help(" ",1,"FA440FALHA")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento com o erro  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogAtu("ERRO","FA440FALHA",Ap5GetHelp("FA440FALHA"))
EndIf

FreeObj(oMovements)
FreeObj(oDocumenE5)

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Fa440CalcB³ Autor ³ Eduardo Riera         ³ Data ³ 27/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Efetua c lculo das comissoes pela baixa                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aBaixas   : array c/ dados da baixa                        ³±±
±±³          ³ lJuros    : Considera Juros                                ³±±
±±³          ³ lDescont  : Considera Desconto                             ³±±
±±³          ³ lDevolucao: Considera Devolucao                            ³±±
±±³          ³ cOrigem   : Origem da Comissao                             ³±±
±±³          ³ cSinal    : Sinal da Comissao (+/-)                        ³±±
±±³			 ³ cVendDe   : Vendedor Inicial        					      ³±±
±±³			 ³ cVendAte  : Vendedor Final           				      ³±±
±±³			 ³ lGoto     : Se Deve ser posicionado o SE1 (Opcional)       ³±±
±±³			 ³ nSE1Rec   : Registro do SE1 a ser posicionado    	      ³±±
±±³			 ³ nData     : Define se considera E5_DATA ou E5_DTDISPO      ³±±
±±³          ³ lOriFiLj  : Informa se a CMP do Loja tem origem no Financ. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fa440CalcB(aBaixas As Array,lJuros As Logical,lDescont As Logical,cOrigem As Character,cSinal As Character,cVendDe As Character,cVendAte As Character,lGoto As Logical,nSE1Rec As Numeric,nData As Numeric,lOriFiLj As Logical,lAuto As Logical,nRegProc As Numeric, lMostComis As Logical) As Logical
	
	Local nRecFor		As Numeric
	Local nOrdFor		As Numeric
	Local sFilial		As Character
	Local aArea 		As Array
	Local aAreaSA3  	As Array
	Local aAreaSE1  	As Array
	Local aAreaSE5  	As Array
	Local aLiquid   	As Array
	Local nX        	As Numeric
	Local nCntFor  		As Numeric
	Local nCntFor2  	As Numeric
	Local nVlrRec  		As Numeric
	Local nVlrLiq  		As Numeric
	Local nVlrProp  	As Numeric
	Local nValor   		As Numeric
	Local nAbatim		As Numeric
	Local nQtdVend  	As Numeric
	Local nRegSE1   	As Numeric
	Local nVlrFatura	As Numeric
	Local cQuebra   	As Character
	Local cVendedor 	As Character
	Local cSeq 	   		As Character
	Local cFunName 		As Character
	Local cVend     	As Character
	Local dData			As Date
	Local lFatura   	As Logical 
	Local lLiquid   	As Logical
	Local lPago     	As Logical
	Local aBases    	As Array
	Local nDecimal  	As Numeric
	Local nBaseComis	As Numeric
	Local nBaseEmis 	As Numeric
	Local nBaseBaix 	As Numeric
	Local nVlrEmis  	As Numeric
	Local nVlrBaix  	As Numeric
	Local nPerComis 	As Numeric
	LOCAL lCalcComis	As Logical
	Local lProcess  	As Logical
	Local cPrimParc 	As Character
	Local cKeySE1 		As Character
	Local aFatura 		As Array
	Local nValBase  	As Numeric
	Local nValComis 	As Numeric
	Local nValSldNat	As Numeric
	Local lComVdBlq 	As Logical
	Local nK 			As Numeric
	Local aSeqCont 		As Array
	Local nPosTit 		As Numeric
	Local nVlLiquid 	As Numeric
	Local lRecIRRF  	As Logical
	Local nVlrJuros 	As Numeric
	Local nPerJuros 	As Numeric
	Local nVlrDesc	 	As Numeric
	Local nPerDesc		As Numeric
	Local aRetF440FALI	As Array
	Local nSavRecSE1	As Numeric
	Local lAtuSldNat 	As Logical
	//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
	Local lNaoGera  	As Logical
	Local cChave		As Character
	Local aRetBases 	As Array
	Local lRet 			As Logical
	Local lMVPar06		As Logical
	Local lMVPar07		As Logical
	Local aRecSE1		As Array
	Local nY 			As Numeric
	Local cAliasSE1 	As Character
	Local cFilSA3		As Character
	Local cFilSE3		As Character
	Local nBaseBAK		As Numeric
	Local nComiBAK		As Numeric
	Local nValIRBx		As Numeric
	Local nValPis		As Numeric
	Local nValCof		As Numeric
	Local nValCsl		As Numeric
	Local lPccBxCr		As Logical
	Local nValCruz		As Numeric
	Local nPosBase		As Numeric
	Local aSE3			As Array
	Local cMvTpComLj	As Character
	Local lLj440SbCm	As Logical
	Local aTitFat  		As Array
	Local lTitFat   	As Logical
	Local ix			As Numeric
	Local aTitLiq   	As Array
	Local lTitLiq		As Logical
	Local nFatRetImp	As Numeric
	Local cWhere    	As Character
	Local cLastPed  	As Character
	Local cComFiLj  	As Character
	Local lCompFiLj 	As Logical
	Local lRestPerg 	As Logical
	Local lMSE3440  	As Logical
	Local lDescISS  	As Logical
	Local aAuxBases		As Array
	Local aAuxBsBKP 	As Array
	Local nPosAuxBs 	As Numeric
	Local nVlrParc 		As Numeric
	Local nVlrCom  		As Numeric
	Local nCont			As Numeric
	Local nPosIni		As Numeric
	Local cFilOri		As Character
	Local lVldLj		As Logical
	Local lCountHlp 	As Logical
	Local nVlLiqSE5 	As Numeric
	Local nAuxLqSE5 	As Numeric
	Local nPropParc		As Numeric
	Local nVlTotLiq		As Numeric
	Local nAuxVlLiq		As Numeric
	Local nDif			As Numeric
	Local nPosNumLiq 	As Numeric
	Local nSe3Comis		As Numeric
	Local nVlrSaldo		As Numeric
	Local nVlrBxVend	As Numeric
	Local nValorJR		As Numeric
	Local nValorMT		As Numeric
	Local nValorDC		As Numeric
	Local cLiquid		As Character
	Local aNLiquid		As Array
	Local cOnOff		As Character
	Local dVencto
	Local nDia
	Local nMes
	Local nAno
    Local aBasesAux     As Array
	Local cOriCobr 		:= Iif(!(cPaisLoc $ "BRA|ARG") .AND. FindFunction('OriCobrDiv'),OriCobrDiv(),"")
	Local oObjVend		As Object
	Local lReliq        As Logical
	Local aCtrVCom		As Array
	Local aAreaFlag		As Array
	Local nPVCom        As Numeric
	Local nVlrPos12		As Numeric
	Local lVldMT490		As Logical
	Local lHelpFlag		As Logical
	Local nSomaVA 		As Numeric 
	Local nSubtVA		As Numeric
	Local nRecnoSE5		As Numeric	
	Local nVlrVA        As Numeric
	Local nMoedaBaix    As Numeric
	Local nTaxaBaixa    As Numeric
	Local lUsaTaxaBx    As Logical
	Local nNccLiqSE1	As Numeric

	nRecFor		:= 0
	nOrdFor		:= 0
	sFilial		:= ""
	aArea 		:= GetArea()
	aAreaSA3  	:= SA3->(GetArea())
	aAreaSE1  	:= SE1->(GetArea())
	aAreaSE5  	:= SE5->(GetArea())
	aLiquid   	:= {}
	nX        	:= 0
	nCntFor  	:= 0
	nCntFor2  	:= 0
	nVlrRec  	:= 0
	nVlrLiq  	:= 0
	nVlrProp  	:= 0
	nValor   	:= 0
	nAbatim		:= 0
	nQtdVend  	:= 0
	nRegSE1   	:= 0
	nVlrFatura	:= 0
	cQuebra   	:= ""
	cVendedor 	:= ""
	cSeq 	   	:= ""
	cFunName 	:= Alltrim(FUNNAME())
	cVend     	:= "1"
	dData		:= Ctod("")
	lFatura   	:= .F.
	lLiquid   	:= .F.
	lPago     	:= .F.
	aBases    	:= {}
	nDecimal  	:= nTamBascom
	nBaseComis	:= 0
	nBaseEmis 	:= 0
	nBaseBaix 	:= 0
	nVlrEmis  	:= 0
	nVlrBaix  	:= 0
	nPerComis 	:= 0
	lCalcComis	:= .F.
	lProcess  	:= .T.
	cPrimParc 	:= " "
	cKeySE1 	:= ""
	aFatura 	:= {}
	nValBase  	:= 0
	nValComis 	:= 0
	nValSldNat	:= 0
	lComVdBlq 	:= .T.
	nK 			:= 0
	aSeqCont 	:= {} //Controle de calculo de comissoes (Sequencia no SE5)
	nPosTit 	:= 0
	nVlLiquid 	:= 0
	lRecIRRF  	:= .F.
	nVlrJuros 	:= 0
	nPerJuros 	:= 0
	nVlrDesc	:= 0
	nPerDesc	:= 0
	aRetF440FALI:= {}
	nSavRecSE1	:= 0
	lAtuSldNat 	:= lFindAtuSld
	//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
	lNaoGera  	:= .F.
	cChave		:= ""
	aRetBases 	:= {}
	lRet 		:= .T.
	lMVPar06	:= .F.
	lMVPar07	:= .F.
	aRecSE1		:= {}
	nY 			:= 0
	cAliasSE1 	:= GetNextAlias()
	cFilSA3		:= ""
	cFilSE3		:= ""
	nBaseBAK	:= 0
	nComiBAK	:= 0
	nValIRBx	:= 0
	nValPis		:= 0
	nValCof		:= 0
	nValCsl		:= 0
	lPccBxCr	:= .F.
	nValCruz	:= 0
	nPosBase	:= 0	//posicao do campo E3_BASE
	aSE3		:= {}	//array com os dados da comissao
	cMvTpComLj	:= AllTrim( SuperGetMV("MV_TPCOMLJ",,"B") ) //indica se eh comissao online ou offline (SIGALOJA)
	lLj440SbCm	:= .T.				//indica se a funcao Lj440SbCom(LOJA440) existe no RPO
	aTitFat   	:= {}
	lTitFat   	:= .F.
	ix        	:=0
	aTitLiq   	:= {}
	lTitLiq   	:= .F.
	nFatRetImp	:= 0
	cWhere    	:= ""
	cLastPed  	:= ""
	cComFiLj  	:=  SuperGetMV("MV_LJFICOM",,"N") //Define se a comissão do loja utiliza NCC gerado no financeiro
	lCompFiLj 	:= cComFiLj == "S" //Indica se a comissão do loja utiliza NCC gerado no financeiro
	lRestPerg 	:= .F.
	lMSE3440  	:= ExistBlock("MSE3440")
	lDescISS  	:= SuperGetMV("MV_DESCISS",,.F.)
	aAuxBases 	:= {}
	aAuxBsBKP 	:= {}
	nPosAuxBs 	:= 0
	nVlrParc 	:= 0
	nVlrCom  	:= 0
	nCont		:= 0
	nPosIni		:= 0
	cFilOri		:= cFilAnt
	lVldLj		:= .F.
	lCountHlp 	:= .F.
	nVlLiqSE5 	:= 0
	nAuxLqSE5 	:= 0
	nPropParc	:= 0
	nVlTotLiq	:= 0
	nAuxVlLiq	:= 0
	nDif		:= 0
	nPosNumLiq 	:= 0
	nSe3Comis	:= 0
	nVlrSaldo	:= 0
	nVlrBxVend	:= 0
	nValorJR	:= 0
	nValorMT	:= 0
	nValorDC	:= 0
	cLiquid		:= ""
	aNLiquid	:= {}
	cOnOff		:= ""
	oObjVend	:= Nil
	lReliq		:= .F.
	aCtrVCom	:= {}
	aAreaFlag	:= {}
	nPVCom		:= 0
	lVldMT490	:= .F.
	lHelpFlag	:= .F.
	nSomaVA 	:= 0
	nSubtVA 	:= 0
	nRecnoSE5	:= 0
	nVlrVA      := 0
	nMoedaBaix  := 0
	nTaxaBaixa  := 0
	lUsaTaxaBx  := SuperGetMv("MV_COMTXMO",.F.,"2") == "2"
	nNccLiqSE1	:= 0

	Private lFina070 	:= cFunName == "FINA070" .or. (cFunName=="FINA740" .And. isInCallStack("FINA070")) .OR. IsBlind()
	Private lFina110 	:= cFunName == "FINA110"
	Private lFina200 	:= cFunName == "FINA200" .or. (IsIncallStack("FINA200"))
	Private lFina440 	:= cFunName == "FINA440" .Or. (IsIncallStack("FINA440"))
	Private lFina330 	:= cFunName == "FINA330" .Or. (IsIncallStack("FINA330"))
	Private nDescont 	:= 0
	Private nMulta	 	:= 0
	Private nJuros	 	:= 0
	Private lGrvAjuste	:= .F.
	Private nSeqVend	:= 0
	Private nQtdeMVC	:= 0
	Private aBaseMVC	:= {}

	DEFAULT lGestao   	:= Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
	DEFAULT cNatCom		:= PADR(&(GetNewPar("MV_NATCOM","")),nTamE2_NATUR)
	DEFAULT cComiLiq 	:= SuperGetMv("MV_COMILIQ",,"2")
	DEFAULT lComiLiq	:= ComisBx("LIQ") .AND. cComiLiq == "1"
	DEFAULT cComisCR    := SuperGetMv("MV_COMISCR")
	DEFAULT lCompensa   := cComisCR == "S"
	DEFAULT lDevolucao	:= SuperGetMv("MV_COMIDEV")
	DEFAULT IsBlind		:= isBlind()
	DEFAULT cMV_1DUP	:= SuperGetMv("MV_1DUP")
	DEFAULT lOriFiLj    := .F.
	DEFAULT lAuto  		:= .F.
	DEFAULT nRegProc	:= 0
	DEFAULT lMostComis	:= .F.

	// Caso seja uma chamada externa carrega parametricação da rotina de comissões 
	IF !IsInCallStack("FINA440") .And. !lFina330
		SaveInter()
		Pergunte("AFI440",.F.)
		lRestPerg := .T.
	ENDIF

	If __nDecPCom == NIL
		__nDecPCom := TamSX3("E3_PORC")[2]
	EndIf
	If __lRndPCom == NIL
		__lRndPCom := SuperGetMv("MV_RNDPCOM",,.T.)
	EndIf

	If (lFina330) // Compensação FINA330
		lMVPar06	:= Iif(!IsBlind .AND. MV_PAR06==1,.T.,.F.) // Considera NCC?
		lMVPar13	:= Iif(!IsBlind .AND. MV_PAR13==1,.T.,.F.) // Considera RA ?
	ElseIf (lFina440)
		lMVPar07 := Iif((!IsBlind .or. lAuto) .AND. MV_PAR07==1,.T.,.F.)	 //Considera NCC?
		lMVPar11 := Iif((!IsBlind .or. lAuto) .AND. MV_PAR11==1,.T.,.F.)	 //Considera RA ?
	EndIf

	cOrigem		:= If( cOrigem == Nil ,"FINA440",cOrigem)
	cSinal    	:= If( cSinal  == Nil ,"+",cSinal)
	cVendDe		:= If( cVendDe==Nil ,Space(Len(SE3->E3_VEND)),cVendDe)
	cVendAte  	:= If( cVendAte==Nil,Repl("z",Len(SE3->E3_VEND)),cVendAte)
	lGoto     	:= If( lGoto == Nil ,.F.,lGoto)

	DEFAULT nData := 1 //Considera Data? Baixa = 1(Default) / Data Dispo. = 2

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada para validacoes de usuario para calculo de comissao  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lFa440Vld .And. ! ExecBlock( "FA440VLD", .F., .F., 2 )
		// Caso seja uma chamada externa restaura parametricação da rotina chamadora 
		IF lRestPerg
			RestInter()
		ENDIF
		
		Return .F.
	EndIf

	//Metricas - Acessos a Calculo de Comissões BAIXA
	If __lMetric == NIL
		__lMetric	:= FwLibVersion() >= "20210517"
	Endif

	If __lComisON == NIL
		__lComisON := (SuperGetMV("MV_TPCOMIS",,"O") == "O")
	Endif

	If __lMetric
		cOnOff := Alltrim(ProcName()) + If(__lComisON, " - ON" , " - OFF")
		__cFunBkp   := FunName()
		__cFunMet	:= Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA440",__cFunBkp)

		SetFunName(__cFunMet)
		// Metrica de controle de acessos 
		FwCustomMetrics():setUniqueMetric(cOnOff, "financeiro-protheus_qtd-por-acesso_total", "1")
		SetFunName(__cFunBkp)
	Endif

	// Verifica se é a primeira parcela de uma fatura
	If nTamParc == 1
		cPrimParc := "1A "
	ElseIf nTamparc == 2
		cPrimParc := cMV_1DUP+Space(2-Len(cMV_1DUP))
		cPrimParc += "#1 #A #  #01"
	Else
		cPrimParc := cMV_1DUP+Space(3-Len(cMV_1DUP))
		cPrimParc += "#1  #A  #   #001"
	Endif

	If (Len(aBaixas) > 0 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posicionando Registros.                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SE5")
		SE1->(DbSetOrder(1))
		
		For nCntFor := 1 To Len(aBaixas)
			//quando titulo sofre baixa com juros/multa/desconto o aBaixas vem com os recnos de todos esses registros da SE5
			//Tratamento para posicionar na SE5 da baixa  
			SE5->(MsGoto(aBaixas[nCntFor][3]))
			
			If nRecnoSE5 == 0 .And. Alltrim(SE5->E5_TIPODOC) $ 'VL|BA'				
				nRecnoSE5 := aBaixas[nCntFor][3]
				Loop
			EndIf
			
			If Alltrim(SE5->E5_TIPODOC) $ "VA" 
				nVlrVA := SE5->E5_VALOR
				
				If (nMoedaBaix := Val(SE5->E5_MOEDA)) > 1
					nVlrVA := Abs(nVlrVA)
					
					If lUsaTaxaBx .And. (nTaxaBaixa := SE5->E5_TXMOEDA) <= 1
						nTaxaBaixa := 0
						
						If SE1->(MsSeek(xFilial("SE1", SE5->E5_FILORIG) + SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))) .And. SE1->E1_TXMOEDA > 0
							nTaxaBaixa := SE1->E1_TXMOEDA 
						EndIf
					EndIf
					
					nVlrVA := Round(xMoeda(nVlrVA, nMoedaBaix, 1, SE5->E5_DATA, __nCasDec, nTaxaBaixa, 0), 2)
				EndIf
				
				If SE5->E5_VALOR > 0
					nSomaVA += nVlrVA
				ElseIf SE5->E5_VALOR < 0
					nSubtVA += Abs(nVlrVA)
				EndIf
			EndIf
		Next nCntFor
		
		If nRecnoSE5 > 0
			SE5->(dbGoTo(nRecnoSE5))
		EndIf
		
		DbSelectArea("SE1")
		SE1->(DbSetOrder(2))
		
		If ( !lGoto )
			If Type("aTitulos") == "A"
				If Len(aTitulos[1])>=23
					If cPaisLoc == "BRA"
						nPosTit := aScan(aTitulos,{|x| x[1] == SE5->E5_PREFIXO .and. x[2] == SE5->E5_NUMERO .and. x[3] == SE5->E5_PARCELA .and. x[4] == SE5->E5_TIPO .and. x[10] == SE5->E5_CLIFOR+"-"+SE5->E5_LOJA })
					Else
						nPosTit := aScan(aTitulos,{|x| x[1] == SE5->E5_PREFIXO .and. x[2] == SE5->E5_NUMERO .and. x[3] == SE5->E5_PARCELA .and. x[4] == SE5->E5_TIPO .and. x[11] == SE5->E5_CLIFOR+"-"+SE5->E5_LOJA })
					Endif
				Else
					nPosTit := aScan(aTitulos,{|x| x[1] == SE5->E5_PREFIXO .and. x[2] == SE5->E5_NUMERO .and. x[3] == SE5->E5_PARCELA .and. x[4] == SE5->E5_TIPO })
				EndIf
			Else
				nPosTit := 0
			EndIf

			If nPosTit > 0
				If isInCallStack('FINA330')
					If MV_PAR02 == 2
						If isInCallStack('FA330Desc')
							sFilial := aTitulos[nPosTit][12]
						Else
							sFilial := aTitulos[nPosTit][16]
						EndIf
					Else
						If isInCallStack('FA330Desc')
							sFilial := aTitulos[nPosTit][12]
						Else
							sFilial := aTitulos[nPosTit][13]
						EndIf
					Endif
				Else
					sFilial := aTitulos[nPosTit][Len(aTitulos[nPosTit])]
				Endif
			Else
				sFilial := xFilial("SE1",SE5->E5_FILORIG)
			EndIf
			SE1->(MsSeek(sFilial+SE5->E5_CLIFOR+SE5->E5_LOJA+SE5->E5_PREFIXO+;
				SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO))
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se devo mover para o registro fisico. Isto se d  em ³
			//³ virtude de no SQL o registro sair do filtro quando deixar de ³
			//³ atender a alguma das condicoes do mesmo.                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			MsGoto(nSE1Rec)
		EndIf

		If lF440Liq
			lProcess := ExecBlock("F440LIQ",.F.,.F.)
		EndIf

		If (( SE1->(Found()) .Or. lGoto ) .and. lProcess )
			lFatura	 := If(alltrim(SE1->E1_FATURA)=="NOTFAT",.T.,.F.)

			If lComiLiq
				//Se calcula comissao pelo metodo antigo (na geracao da liquidacao)
				lLiquid := .F.
			Else
				//Se calcula comissao pelo metodo novo (na baixa do titulo gerado pela liquidacao)
				lLiquid  := !Empty(SE1->E1_NUMLIQ)
			EndIf

			If lFina330 .And. ( lFatura .Or. lLiquid )
				cFilAnt := sFilial
			EndIf
			//Verifica se o cliente e responsavel pelo recolhimento do IR ou nao.
			If cPaisloc == "BRA"

				dbSelectArea("SED")       
				SED->(dbSetOrder(1))
				
				dbSelectArea("SA1")
				SA1->(dbSetOrder(1))
				
				If SED->(dbSeek(xFilial("SED") + SED->ED_CODIGO ) ) .And. SED->ED_RECIRRF == "1"
					lRecIRRF := .T.
				ElseIf SA1->(dbSeek(xFilial("SA1")+SE1->(E1_CLIENTE+E1_LOJA))) .And. SA1->A1_RECIRRF == "1"
					lRecIRRF := .T.
				EndIf
			EndIf
			
			If ( !lFatura .And. !lLiquid )
				If (!(SE1->E1_TIPO$MVPAGANT+"/"+MVTAXA+"/"+MVPROVIS+"/"+MVRECANT+"/"+MVABATIM+"/"+MV_CPNEG+"/"+MV_CRNEG) .And. (cFunName=="FINA070") .Or. ;
						(IF(lFina330,lMvPar06,.F.) .Or. If(lFina440 .And. SE1->E1_TIPO $ MV_CRNEG , lMvPar07, .F. )) ) .Or. ; // Comissão NCC - BRASIL
						(IF(lFina330,lMvPar13,.F.) .Or. If(lFina440 .And. SE1->E1_TIPO $ MVRECANT , lMvPar11, .F. )) .Or. ;   // Comissão RA - BRASIL
						(cPaisLoc<>"BRA" .And. SE1->E1_TIPO $ MV_CRNEG)
					aBases   := Fa440Comis(SE1->(Recno()),cOrigem$Iif(!lSF2460I .or.(lSF2460I .And. "MATA460"$SE1->E1_ORIGEM) ,"FINA440#FINA087A#FINA070#FINA110#"+cOriCobr,"FINA440#FINA087A#"+cOriCobr),cOrigem$Iif(!lSF2460I .or.(lSF2460I .And. "MATA460"$SE1->E1_ORIGEM),"FINA440#FINA087A#FINA070#FINA110#"+cOriCobr,"FINA440#FINA087A#"+cOriCobr))
				ElseIf (!(SE1->E1_TIPO$MVPAGANT+"/"+MVTAXA+"/"+MVPROVIS+"/"+MVRECANT+"/"+MVABATIM+"/"+MV_CPNEG+"/"+MV_CRNEG)) .or. ;
						(cPaisLoc<>"BRA" .And. SE1->E1_TIPO $ MV_CRNEG)
					aBases   := Fa440Comis(SE1->(Recno()),cOrigem$Iif(!lSF2460I .or.(lSF2460I .And. "MATA460"$SE1->E1_ORIGEM),"FINA440#FINA087A#FINA070#FINA110#"+cOriCobr,"FINA440#FINA087A#"+cOriCobr),cOrigem$Iif(!lSF2460I .or.(lSF2460I .And. "MATA460"$SE1->E1_ORIGEM),"FINA440#FINA087A#FINA070#FINA110"+cOriCobr,"FINA440#FINA087A#"+cOriCobr))     
				EndIf

                    nQtdVend := Len(aBases)
                    cVend := "1"
                    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    //³ Ponto de entrada para manipular o tratamento do calculo      ³
                    //³ das bases da comissao.                                       ³
                    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    If __lF440aB1
                        aBases := ExecBlock("F440aBas",.F.,.F.,aBases)
                    Endif
                    nQtdVend := Len(aBases)
                    cVend := "1"
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Aqui e' verificado os vendedores para os titulo aglutinados  ³
				//³ na fatura a receber.                                         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nRegSE1 := SE1->(Recno())
				If Select("__SE1") == 0
					ChkFile("SE1",.F.,"__SE1")
				Endif
				nVlLiquid := SE1->E1_VLCRUZ
				If lFatura
					aRecSE1 := {}
					nSavRecSE1 := SE1->(RECNO())
					cWhere  := ""	
					If SE1->E1_ORIGEM <> "FINA280M" // Se fatura com multiplas filiais
						cWhere  +=  "SE1.E1_FILIAL = '"+ xFilial("SE1",SE1->E1_FILORIG) +"' AND "
					EndIf
					cWhere +=  "SE1.E1_FATPREF = '" + SE1->E1_PREFIXO + "' AND "
					cWhere +=  "SE1.E1_FATURA = '" + SE1->E1_NUM + "' "
					cWhere := "%"+cWhere+"%"
					BeginSql Alias cAliasSE1
						SELECT
							SE1.R_E_C_N_O_ RECSE1
						FROM
							%Table:SE1% SE1
						WHERE
							%Exp:cWhere% AND SE1.%NotDel%
						ORDER BY
							E1_FILIAL,E1_CLIENTE,E1_LOJA,E1_FATPREF,E1_FATURA
					EndSql
		
					(cAliasSE1)->(dbGoTop())
		
					While !(cAliasSE1)->(Eof())
						aAdd(aRecSE1,(cAliasSE1)->RECSE1)
						(cAliasSE1)->(dbSkip())
					EndDo
		
					(cAliasSE1)->(dbCloseArea())
		
					If !Empty(aRecSE1)
						__SE1->(dbGoTo(aRecSE1[1]))
						nRegSE1Orig := __SE1->(Recno())
					EndIf
		
					if !fa440temVe("__SE1")  
						If !Empty(__SE1->E1_NUMLIQ)
							dbSelectArea("SE5")
							dbSetOrder(10)
							If dbSeek(xFilial("SE5")+__SE1->E1_NUMLIQ)
								dbSelectArea("SE1")
								dbSetOrder(1)
								If dbSeek(xFilial("SE1")+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO)
									nRegSE1Orig := SE1->(Recno())
								Endif
								SE1->(dbGoto(nRegSE1))
							Endif
						Endif
					Endif
					Fa440LiqFat(@aRecSE1, @aTitLiq)
		
					For nY := 1 To Len(aRecSE1)
		
						lTitLiq := .F.
						cLastPed := ""
						dbSelectArea("__SE1")
						__SE1->(dbGoTo(aRecSE1[nY]))
						nRegSE1Orig := __SE1->(Recno())
						If Alltrim(__SE1->E1_FATURA) == "NOTFAT"
							Loop
						EndIf
						aFatura := Fa440Comis(__SE1->(Recno()),cOrigem$"FINA440",cOrigem$"FINA440",,,nRegSE1Orig)
						nQtdVend := Len(aFatura)
						cVend := "1"
						If !__SE1->E1_TIPO $ MVABATIM
							nVlrProp   := 1
							nAbatim := SomaAbat(__SE1->E1_PREFIXO,__SE1->E1_NUM,__SE1->E1_PARCELA,"R",__SE1->E1_MOEDA,__SE1->E1_EMISSAO,__SE1->E1_CLIENTE)
							__SE1->(dbGoTo(nRegSE1Orig))
							SE5->(dbSetOrder(7))
							cKeySe1 := __SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)
							If SE5->(MsSeek(xFilial("SE5")+cKeySe1))
								While !SE5->(Eof()) .and. SE5->E5_FILIAL == xFilial("SE5") .and. ;
									cKeySe1 == SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)
									If Len(aTitLiq) > 0 .and. (Ascan(aTitLiq, aRecSE1[nY]) > 0 )
										lTitLiq := .T.
									EndIf
									//Ignora a NCC pois já foi feito o abatimento na geração da fatura.
									If (SE5->E5_MOTBX == "FAT" .and. SE5->E5_SITUACA != "C" .And. SE5->E5_TIPO != MV_CRNEG) .or. lTitliq
										nFatRetImp := 0
										If !(SE5->E5_PRETPIS	$	"1;2")
											nFatRetImp += SE5->E5_VRETPIS
										EndIf
										If !(SE5->E5_PRETCOF	$	"1;2")
											nFatRetImp += SE5->E5_VRETCOF
										EndIf
										If !(SE5->E5_PRETCSL	$	"1;2")
											nFatRetImp += SE5->E5_VRETCSL
										EndIf
										nFatRetImp := SE5->E5_VRETIRF + SE1->(E1_INSS+If(lDescISS,SE1->(E1_ISS),0))
										nVlrFatura += If( nFatRetImp > 0, SE5->E5_VALOR+nFatRetImp, SE5->E5_VALOR)
										nVlrProp := (((nVlrFatura  + nAbatim)*1000)/__SE1->E1_VLCRUZ)/1000
										If nVlrProp+0.01 >= 1
											nVlrProp := 1
										EndIf
										Exit
									Endif
									SE5->(dbSkip())
								Enddo
							Else
								nVlrFatura += __SE1->E1_VLCRUZ
								nVlrProp   := 1
							Endif
							For nCntFor := 1 To Len(aFatura)
								aFatura[nCntFor,2]:= Round(NoRound(aFatura[nCntFor,2]*nVlrProp,nDecimal+1),nDecimal)
								aFatura[nCntFor,3]:= Round(NoRound(aFatura[nCntFor,3]*nVlrProp,nDecimal+1),nDecimal)
								aFatura[nCntFor,4]:= Round(NoRound(aFatura[nCntFor,4]*nVlrProp,nDecimal+1),nDecimal)
								aFatura[nCntFor,5]:= Round(NoRound(aFatura[nCntFor,5]*nVlrProp,nDecimal+1),nDecimal)
								aFatura[nCntFor,6]:= Round(NoRound(aFatura[nCntFor,6]*nVlrProp,nDecimal+1),nDecimal)
							Next nCntFor
						EndIf
						For nCntFor := 1 To Len(aFatura)
							If __SE1->E1_PEDIDO == cLastPed
								cLastPed := __SE1->E1_PEDIDO
								nPerComis := aScan(aBases,{|x| x[1] == aFatura[nCntFor,1]})
								If nPerComis <> 0
									nPerComis := aBases[nPerComis,7]
									If nPerComis <> aFatura[nCntFor,7]
										nPerComis := -1
									EndIf
								Else						
									cLastPed := __SE1->E1_PEDIDO
									nPerComis := aFatura[nCntFor,7]
								EndIf
							Else
								nPerComis := aFatura[nCntFor,7]
							EndIf
							aadd(abases,{	aFatura[nCntFor,1],;
								aFatura[nCntFor,2],;
								aFatura[nCntFor,3],;
								aFatura[nCntFor,4],;
								aFatura[nCntFor,5],;
								aFatura[nCntFor,6],;
								Max(0,nPerComis)  ,;
								aFatura[nCntFor,8],;	// PIS
								aFatura[nCntFor,9],;	// COFINS
								aFatura[nCntFor,10],;	// CSLL
								Iif(Len(aFatura[nCntFor]) > 10,aFatura[nCntFor,11],0),; // IRRF
								__SE1->E1_VALOR,;		// Valor Original do título filho.
								__SE1->(Recno()) })		// Recno do título filho
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Ponto de entrada para manipular o aBases na Fatura ou/e Liquidação      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lF440FAL
								aRetF440FALI := ExecBlock("F440FAL",.F.,.F.,{abases,lFatura,lLiquid})
								If(ValType(aRetF440FALI)=="A")
									abases := aRetF440FALI
								EndIf
							Endif
						Next nCntFor
						dbSelectArea("__SE1")
						dbSkip()
					Next nY

				ElseIf ! SE1->E1_TIPO $ MV_CRNEG // Titulo gerado pela liquidacao porem eh uma nota de credito (nao calcula comissao)
					Fa440LiqSe1(SE1->E1_NUMLIQ,@aLiquid,,@aSeqCont,,,@aTitFat,@aNLiquid)
					nK += 1
					nVlLiquid	:= 0
					nVlrSaldo	:= 0
					lTitFat		:= .F.
					dbSelectArea("__SE1")
					For nX := 1 To Len(aLiquid)
						__SE1->(MsGoto(aLiquid[nX]))
						aFatura := Fa440Comis(__SE1->(Recno()),cOrigem$"FINA440",cOrigem$"FINA440")
						nQtdVend := Len(aFatura)
						cVend := "1"
						//FNC 00000029183/2009
						nVlrJuros := 0
						nPerJuros := 0
						nVlrDesc  := 0
						nPerDesc  := 0
						//
						nVlrProp   := 1
						nVlLiquid += __SE1->E1_VLCRUZ
						nVlrSaldo += __SE1->E1_SALDO
						nValCruz	 += __SE1->E1_VLCRUZ
						If !__SE1->E1_TIPO $ MVABATIM
							SE5->(dbSetOrder(7))
							cKeySe1 := __SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)
							// Qdo a liquidação originou de fatura
							If Len(atitFat) > 0
								For iX := 1 to len(aTitFat)
									If aTitFat[iX][1] == __SE1->(Recno())
										lTitFat := .T.
										exit
									EndIf
								Next
							EndIf
							// Proporcionaliza baixas por liquidacao
							If SE5->(MsSeek(xFilial("SE5")+cKeySe1)) .AND. lComiLiq 
								While !SE5->(Eof()) .and. SE5->E5_FILIAL == xFilial("SE5") .and. ;
									cKeySe1 == SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)
									If (SE5->E5_MOTBX == "LIQ" .and. SE5->E5_SITUACA != "C" .And. SE5->E5_TIPODOC == "BA";
										.And. SE5->E5_SEQ == aSeqCont[nK]) .or. lTitFat
										nVlrFatura 	+= SE5->E5_VALOR
										//FNC 00000029183/2009
										//Não acumular mais a variavel, o juros vai ser passado para a array aBase
										If lJuros
											nVlrJuros	:= f440JurLiq(__SE1->(recno()))
										EndIf
										If nVlrJuros > 0
											nPerJuros 	:= ((nVlrJuros*1000)/__SE1->E1_VLCRUZ)/1000
										Endif
										nVlrDesc	:= f440DesLiq(__SE1->(recno()))
										If lDescont .And. nVlrDesc > 0
											nPerDesc 	:= ((nVlrDesc*1000)/__SE1->E1_VLCRUZ)/1000
										Endif
										nVlrProp 	:= ( ;
														( ;
														( SE5->E5_VALOR - ;
														IF(lJuros .AND. nVlrJuros > 0, SE5->E5_VLJUROS,0) + ;
														IF( nVlrDesc > 0, SE5->E5_VLDESCO,0) ;
														) * 1000 ;
														) / __SE1->E1_VLCRUZ ;
														) / 1000
										nK++
										If nVlrProp+0.01 >= 1
											nVlrProp := 1
										EndIf
										Exit
									Endif
									SE5->(dbSkip())
								Enddo
							Else
								nVlrFatura += __SE1->E1_VLCRUZ
								nVlrProp   := 1
							Endif
						EndIf

						For nCntFor := 1 To Len(aFatura)
							nPerComis := aFatura[nCntFor,7]

							nVlrPos12  := 0

							If __SE1->E1_MOEDA > 1
								nVlrPos12 := __SE1->E1_VALOR * (aFatura[nCntFor,2] / __SE1->E1_VALOR)
							Else
								nVlrPos12 := __SE1->E1_VALOR
							Endif
							//FNC 00000029183/2009
							//Incluido o calculo do perc. do juros (nPerJuros) e desconto (nPerDesc) sobre os elementos da array para o ajuste do calculo
							aadd(aBases,{aFatura[nCntFor,1],;
								(aFatura[nCntFor,2]*nVlrProp)+(aFatura[nCntFor,2]*nPerJuros)-(aFatura[nCntFor,2]*nPerDesc),;
								aFatura[nCntFor,3]*nVlrProp+(aFatura[nCntFor,3]*nPerJuros)-(aFatura[nCntFor,2]*nPerDesc),;
								aFatura[nCntFor,4]*nVlrProp+(aFatura[nCntFor,4]*nPerJuros)-(aFatura[nCntFor,2]*nPerDesc),;	
								aFatura[nCntFor,5]*nVlrProp+(aFatura[nCntFor,5]*nPerJuros)-(aFatura[nCntFor,2]*nPerDesc),;
								aFatura[nCntFor,6]*nVlrProp+(aFatura[nCntFor,6]*nPerJuros)-(aFatura[nCntFor,2]*nPerDesc),;
								Max(0,nPerComis),;
								aFatura[nCntFor,8],;	// PIS
								aFatura[nCntFor,9],;	// COFINS
								aFatura[nCntFor,10],;	// CSLL
								Iif(Len(aFatura[nCntFor]) > 10,aFatura[nCntFor,11],0),;	// IRRF
								nVlrPos12,;		// Valor Original do título filho.
								__SE1->(Recno()),; 		// Recno do título filho
								SE1->E1_VALOR,;
								0,; 	                // Valor da parcela
								VlrSe5Bx({aLiquid[nX]},aFatura[nCntFor,1]) })	

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Ponto de entrada para manipular o aBases na Fatura ou/e Liquidação      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lF440FAL
								aRetF440FALI := ExecBlock("F440FAL",.F.,.F.,{aBases,lFatura,lLiquid})
								If(ValType(aRetF440FALI)=="A")
									aBases := aRetF440FALI
								EndIf
							Endif
						Next nCntFor
					Next nX
				EndIf

				If lF440CBase
					aRetBases := ExecBlock("F440CBASE",.F.,.F.,{aBases})
					If !Empty(aRetBases) .And. ValType(aRetBases) == "A"
						aBases := aClone(aRetBases)
					EndIf
				EndIf

				dbSelectArea("SE1")
				dbSetOrder(1)
				MsGoto(nRegSE1)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Aqui e' feito o ajuste das bases em relacao ao titulo.       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("SE1")
				If lFatura
					nVlrProp := ((SE1->E1_VLCRUZ*10000)/nVlrFatura)/10000
				Else
					nVlrProp := ((SE1->E1_VLCRUZ*10000)/nVlLiquid)/10000
				Endif
				
				aAuxBsBKP := {}
				aAuxBases := {}
				aBases    := aSort(aBases,,,{|x,y| x[1] + cValToChar(x[13]) < y[1] + cValToChar(y[13]) })
				nPosIni   := 1

				For nCntFor := 1 To Len(aBases)
					If aBases[Iif(nCntFor>1,nCntFor-1,1),1] == aBases[nCntFor,1]     
						If aBases[nCntFor,6] > 0 .Or. Len(aLiquid) > 0
							If (aBases[nCntFor,2] > aBases[nCntFor,3]) .And. aBases[nCntFor,3] > 0
								nVlrParc += aBases[nCntFor,3]
							Else
								If Len( aBases[nCntFor] ) >= 16 .And. aBases[nCntFor,16] > 0
									nVlrParc += aBases[nCntFor,2] - aBases[nCntFor,16]
									aBases[nCntFor,6]	:=	(aBases[nCntFor,2] - aBases[nCntFor,16]) * aBases[nCntFor,7]/100
								Else
									nVlrParc += aBases[nCntFor,2]
								EndIf
							Endif
							
							nVlrCom  += aBases[nCntFor,6]
						EndIf
					Else
						For nCont := nPosIni To (nCntFor - 1)
							If aBases[nCont,6] > 0
								aBases[nCont,7] := nVlrCom / nVlrParc * 100
							Else
								aBases[nCont, 2] := 0
								aBases[nCont, 4] := 0
								aBases[nCont, 6] := 0
								aBases[nCont, 7] := nVlrCom / nVlrParc * 100
								aBases[nCont,12] := 0
							Endif

							If Len( aBases[nCont] ) >= 15
								aBases[nCont,15] := nVlrParc
							EndIf
						Next i
						nPosIni := nCntFor
						
						If aBases[nCntFor,6] > 0 .Or. Len(aLiquid) > 0
							If (aBases[nCntFor,2] > aBases[nCntFor,3]) .And. aBases[nCntFor,3] > 0
								nVlrParc := aBases[nCntFor,3]
							Else
								If Len( aBases[nCntFor] ) >= 16 .And. aBases[nCntFor,16] > 0
									nVlrParc := aBases[nCntFor,2] - aBases[nCntFor,16]
									aBases[nCntFor,6]	:=	(aBases[nCntFor,2] - aBases[nCntFor,16]) * aBases[nCntFor,7]/100
								Else
									nVlrParc := aBases[nCntFor,2]
								EndIf
							Endif					
							nVlrCom  := aBases[nCntFor,6]
						EndIf	
					EndIf
				Next nCntFor
				
				For nCont := nPosIni To (nCntFor - 1)
					If (nCntFor - 1) > 1
						If aBases[nCont,6] > 0
							aBases[nCont,7] := nVlrCom / nVlrParc * 100
						Else
							aBases[nCont, 2] := 0
							aBases[nCont, 4] := 0
							aBases[nCont, 6] := 0
							aBases[nCont, 7] := nVlrCom / nVlrParc * 100
							aBases[nCont,12] := 0
						Endif

						If Len( aBases[nCont] ) >= 15
							aBases[nCont,15] := nVlrParc
						EndIf
					Endif
				Next nCont
				
				For nCntFor := 1 To Len(aBases)

					If ( nPVCom := aScan( aCtrVCom, {|aX| aX[ 1 ] == aBases[nCntFor,1] } ) ) == 0
						aAdd( aCtrVCom, { aBases[nCntFor,1], Iif( aBases[nCntFor,2] # 0, .T., .F. ) } )
					else
						aCtrVCom[ nPVCom, 2 ]	:=	Iif( !aCtrVCom[ nPVCom, 2 ], .F., Iif( aBases[nCntFor,2] # 0, .T., .F. ) )
					EndIf

					nPosAuxBs := aScan( aAuxBsBKP, {|x| x[1] == aBases[nCntFor,1]} )
					If nPosAuxBs > 0
						aAuxBsBKP[nPosAuxBs][2]  += aBases[nCntFor,2]
						aAuxBsBKP[nPosAuxBs][3]  += aBases[nCntFor,3]
						aAuxBsBKP[nPosAuxBs][4]  += aBases[nCntFor,4]
						aAuxBsBKP[nPosAuxBs][5]  += aBases[nCntFor,5]
						aAuxBsBKP[nPosAuxBs][6]  += aBases[nCntFor,6]
						aAuxBsBKP[nPosAuxBs][8]  += aBases[nCntFor,8]
						aAuxBsBKP[nPosAuxBs][9]  += aBases[nCntFor,9]
						aAuxBsBKP[nPosAuxBs][10] += aBases[nCntFor,10]
						aAuxBsBKP[nPosAuxBs][11] += aBases[nCntFor,11]
						aAuxBsBKP[nPosAuxBs][12] += aBases[nCntFor,12]
						Aadd(aAuxBsBKP[nPosAuxBs][13],aBases[nCntFor,13])
						If Len( aBases[nCntFor] ) >= 16
							aAuxBsBKP[nPosAuxBs][17] += aBases[nCntFor,16]
						EndIf
					Else
						aAuxBases := {}
						aAdd(aAuxBases, aBases[nCntFor,1])
						aAdd(aAuxBases, aBases[nCntFor,2])
						aAdd(aAuxBases, aBases[nCntFor,3])
						aAdd(aAuxBases, aBases[nCntFor,4])
						aAdd(aAuxBases, aBases[nCntFor,5])
						aAdd(aAuxBases, aBases[nCntFor,6])
						aAdd(aAuxBases, aBases[nCntFor,7])
						aAdd(aAuxBases, aBases[nCntFor,8])
						aAdd(aAuxBases, aBases[nCntFor,9])
						aAdd(aAuxBases, aBases[nCntFor,10])
						aAdd(aAuxBases, aBases[nCntFor,11])
						aAdd(aAuxBases, aBases[nCntFor,12])
						aAdd(aAuxBases, {aBases[nCntFor,13]})
						aAdd(aAuxBases, .F.) // Será para controle se chama ou não a função VlrProp()
						If Len( aBases[nCntFor] ) >= 14
							aAdd(aAuxBases, aBases[nCntFor,14])
						EndIf

						If Len( aBases[nCntFor] ) >= 15
							aAdd(aAuxBases, aBases[nCntFor,15])
						EndIf
						
						If Len( aBases[nCntFor] ) >= 16
							aAdd(aAuxBases, aBases[nCntFor,16])
						EndIf

						aAdd(aAuxBsBKP, aAuxBases )
					Endif
				Next nCntFor 
				
				aBases := {}
				
				For nCntFor := 1 To Len(aAuxBsBKP)
					aAdd(aBases,aAuxBsBKP[nCntFor])
					
					If Len( aTail( aBases ) ) >= 14
						nPVCom := aScan( aCtrVCom, {|aX| aX[ 1 ] == aBases[nCntFor,1] } )
						aTail( aBases )[ 14 ]	:=	!aCtrVCom[ nPVCom, 2 ]
					EndIf
				next nCntFor
				
				cVendedor := ""
				For nCntFor := 1 To Len(aBases)				

					If !lFatura
						lReliq	:=	.F.
						cLiquid	:= SE1->E1_NUMLIQ

						nVlTotLiq := nVlLiquid

						//Proporcionalizacao referente as parcelas 
						If lLiquid
							nAuxVlLiq := F440TotLiq(SE1->E1_FILIAL, cLiquid, SE1->E1_CLIENTE, SE1->E1_LOJA)
							nVlTotLiq := IIF(nAuxVlLiq > 0, nAuxVlLiq, nVlLiquid)
						EndIf

						nNccLiqSE1	:= 0

						//Realiza a proporcionalizacao para cada vendedor	
						If SE1->E1_MOEDA > 1				
							nAuxLqSE5 := Fa440VlLiq(cLiquid, aBases[nCntFor,1], 2, @lReliq, 1, @nNccLiqSE1 )
						Else
							nAuxLqSE5 := Fa440VlLiq(cLiquid, aBases[nCntFor,1], 2, @lReliq, 2, @nNccLiqSE1 )
						Endif

						If lReliq .And. nNccLiqSE1 > 0
							nPropParc := ((SE1->E1_VLCRUZ * 10000) / nVlTotLiq) / 10000
						ElseIf lReliq .And. aBases[nCntFor,17] == 0
							nPropParc := ((SE1->E1_VLCRUZ * 10000) / nVlLiquid) / 10000
						Else
							nPropParc := ((SE1->E1_VLCRUZ * 10000) / nVlTotLiq) / 10000
						Endif
						
						nVlLiqSE5 := IIF(nAuxLqSE5 > 0, nAuxLqSE5, Iif(lReliq, nVlTotLiq, nVlLiquid ))
						nVlLiqSE5 := nVlLiqSE5 * nPropParc

						//Tratativa para problemas de arredondamento
						nDif := SE1->E1_VLCRUZ - Round(nVlLiqSE5, 2)
						If Abs(nDif) == 0.01 
							nVlrProp := ((SE1->E1_VLCRUZ*10000)/Iif(lReliq, nVlTotLiq, nVlLiquid ))/10000
						Else
							If lReliq .And. (aBases[nCntFor,17] == 0)
								nVlrProp := nPropParc
							Else
								nVlrProp := ((nVlLiqSE5*10000)/aBases[nCntFor,12])/10000
							Endif
						EndIf
					EndIf

					nBaseComis:= aBases[nCntFor,2] * nVlrProp
					nBaseEmis := aBases[nCntFor,3] * nVlrProp
					nBaseBaix := (aBases[nCntFor,4] + IIf(Len(aBases[nCntFor]) > 10, aBases[nCntFor,11], 0)) * nVlrProp
					nVlrEmis  := aBases[nCntFor,5] * nVlrProp
					nVlrBaix  := aBases[nCntFor,6] * nVlrProp

					If ( cVendedor <> aBases[nCntFor][1] )
						//--> Base da Comissao
						nBaseDif := NoRound(aBases[nCntFor,2]*(1-nVlrProp),nDecimal+1)
						nBaseDif := aBases[nCntFor,2]-nBaseDif-nBaseComis
						aBases[nCntFor,2] := nBaseComis+nBaseDif

						//--> Base da Comissao na Emissao
						nBaseDif := NoRound(aBases[nCntFor,3]*(1-nVlrProp),nDecimal+1)
						nBaseDif := aBases[nCntFor,3]-nBaseDif-nBaseEmis
						aBases[nCntFor,3] := nBaseEmis+nBaseDif

						//--> Base da Comissao na Baixa
						nBaseDif := NoRound((aBases[nCntFor,4]+IIf(Len(aBases[nCntFor]) > 10, aBases[nCntFor,11], 0)) *(1-nVlrProp),nDecimal+1)
						nBaseDif := (aBases[nCntFor,4]+IIf(Len(aBases[nCntFor]) > 10, aBases[nCntFor,11], 0))-nBaseDif-nBaseBaix
						aBases[nCntFor,4] := nBaseBaix+nBaseDif

						//--> Valor da Comissao na Emissao
						nBaseDif := NoRound(aBases[nCntFor,5]*(1-nVlrProp),nDecimal+1)
						nBaseDif := aBases[nCntFor,5]-nBaseDif-nVlrEmis
						aBases[nCntFor,5] := nVlrEmis+nBaseDif

						//--> Valor da Comissao na Baixa
						nBaseDif := NoRound(aBases[nCntFor,6]*(1-nVlrProp),nDecimal+1)
						nBaseDif := aBases[nCntFor,6]-nBaseDif-nVlrBaix
						aBases[nCntFor,6] := nVlrBaix+nBaseDif
					Else
						aBases[nCntFor,2] := nBaseComis
						aBases[nCntFor,3] := nBaseEmis
						aBases[nCntFor,4] := nBaseBaix
						aBases[nCntFor,5] := nVlrEmis
						aBases[nCntFor,6] := nVlrBaix
					EndIf
					cVendedor := aBases[nCntFor][1]
				Next nCntFor
			EndIf
			nDescont  := 0
			nVlrRec   := 0
			If lJuros .or. funname() $ "FINA200" 
				nJuros    := 0
			Endif 
			nMulta	:= 0
			cQuebra	:= ""
			cSeq	:= ""
			// CASOS DE SE1 COMPARTILHADO E SA3 ESCLUSIVA
			If lGestao
				cFilSA3 := Iif(Empty(FwFilial("SA3")) , xFilial("SA3") , FwxFilial("SE1",SE1->E1_FILORIG) )
				cFilSE3 := Iif(Empty(FwFilial("SE3")) , xFilial("SE3") , FwxFilial("SE3",SE1->E1_FILORIG) )
			Else
				cFilSA3 := Iif(Empty(xFilial("SA3")) , xFilial("SA3") , SE1->E1_FILORIG )
				cFilSE3 := Iif(Empty(xFilial("SE3")) , xFilial("SE3") , SE1->E1_FILORIG )
			EndIf
			lPccBxCr	:= lFindPccBx .and. FPccBxCr()
			For nCntFor := 1 To Len(aBaixas)

				If Alltrim(aBaixas[nCntFor][1]) == "LOJ" .AND. IsMoney(SE5->E5_FORMAPG) // Trata recebimento em dinheiro realizado pelo SIGALOJA.
					Loop
				EndIf
				
				If (Iif(aBaixas[nCntFor,1]=="DEV",lDevolucao,.T.)  .And. Iif(aBaixas[nCntFor,1]=="CMP", Iif(lCompensa,.T.,Iif(lCompFiLj,lOriFiLj,.F.)),.T.))

					dbSelectArea("SE5")
					MsGoto(aBaixas[nCntFor,3])
					nVlrRec := SE5->E5_VALOR
					cSeq	:= SE5->E5_SEQ
					dData	:= Iif(nData == 1,SE5->E5_DATA,SE5->E5_DTDISPO)
					
					If (SE5->E5_MOTBX $ "DAC" .Or. SE5->E5_TIPODOC $ "CM|MT|JR|DC|M2|J2|D2|CH|VA") .Or. (SE5->E5_MOTBX $ "TRF" .And. Alltrim(SE5->E5_ORIGEM) $ "FINA630")
						Loop
					Endif

					lCalcComis	:= .F.
					nValBase	:= 0
					nValComis	:= 0

					If ComisBx(SE5->E5_MOTBX)
						lCalcComis := .T.
					ElseIf lDevolucao .And. SE5->E5_MOTBX == "CMP"
						If !lCountHlp
							HELP(" ",1,"FA440COMISBX",, STR0025 ,1,0) // "O motivo de baixa "CMP" está configurado para não gerar comissão e o parâmetro MV_COMIDEV está .T. (verdadeiro), sendo assim, a comissão da baixa do título compensado será gerada."
							lCountHlp := .T.
						EndIf	
						lCalcComis := .T.
					Else
						Loop
					EndIf

					If lPccBxCr
						nValPis	:= 0
						nValCof	:= 0
						nValCsl	:= 0
						If !(SE5->E5_PRETPIS $ "1|2")
							nValPis	:= SE5->E5_VRETPIS
						EndIf
						If !(SE5->E5_PRETCOF $ "1|2")
							nValCof := SE5->E5_VRETCOF
						EndIf
						If !(SE5->E5_PRETCSL $ "1|2")
							nValCsl := SE5->E5_VRETCSL
						EndIf
					Endif

					nValIRBx := SE5->E5_VRETIRF

					If ( SE5->E5_TIPODOC $ "VL|BA|V2|CP|LJ" ) .and. lCalcComis
						nJuros  	+= SE5->E5_VLJUROS
						nDescont	+= SE5->E5_VLDESCO
						nMulta		+= SE5->E5_VLMULTA
					EndIf

					nSeqVend := 0

					For nCntFor2 := 1 To Len(aBases)
						If ( aBases[nCntFor2,1] >= cVendDe  .And. aBases[nCntFor2,1] <= cVendAte )
							lHelpFlag	:= .F.
							If __l440Flag .And. !lFina440 .And. (lReliq .Or. lLiquid)
								lHelpFlag := .T.
							Endif
							If lFina440
								lVldMT490 := .F.
								aAreaFlag	:= SE3->(GetArea())
								SE3->(DbSetOrder(3))
								If SE3->(DbSeek(xFilial("SE3") + aBases[nCntFor2,1] + SE1->E1_CLIENTE + SE1->E1_LOJA + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO + cSeq ))
									If (__l440Flag .And. SE3->&(Upper(__cCpoFlag)) == "1") .Or. SE3->E3_AJUSTE == 'R'
										lVldMT490 := .T.
									Endif
								Endif

								RestArea(aAreaFlag)

								If lVldMT490
									Loop
								Endif
							Endif

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Calcula o Valor Recebido sobre o Principal       ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							IF __lF440aB1 .and. lF440JurDes
								lRet:= MsgYesNo(STR0013)
							Else
								lRet := .T.
							EndIf

							nVlrLiq :=  nVlrRec

							If lRet
								nVlrLiq :=  nVlrRec - Iif(lJuros,0, (nJuros + nMulta + nSomaVA))
								nVlrLiq +=  Iif(lDescont,0, (nDescont + nSubtVA))
							EndIF

							SA3->(MsSeek(cFilSA3+aBases[nCntFor2,1]))
							//backup antes da alteração do aBases para proporcionalização
							nBaseBAK	:= aBases[nCntFor2,4]
							nComiBAK	:= aBases[nCntFor2,6]

							If !lFina440 
								F070Fator(nVlrRec,nVlrLiq,aBases,aBases[nCntFor2,2],nCntFor2,lJuros,lDescont, !Empty(SE1->E1_NUMLIQ) .Or. lFatura, nValPis,nValCof,nValCsl,nValIRBx, nSomaVA, nSubtVA)
							Else
								F440Fator(nVlrRec,nVlrLiq,aBases,nCntFor2,nValIRBx,nValPis,nValCof,nValCsl,lJuros,lDescont,(nDescont+nSubtVA),(nJuros+nMulta+nSomaVA),nCntFor==Len(aBaixas), !Empty(SE1->E1_NUMLIQ) .Or. lFatura)
							EndIf

							nVlrProp := aBases[nCntFor2,4]

							If Len(aBases[nCntFor2]) > 13 .And. aBases[nCntFor2,14]
								nValor	:= aBases[nCntFor2,6]
							Else
								// Base de Comissão
								aBases[nCntFor2,6]	:= aBases[nCntFor2,4] * (aBases[nCntFor2,7]/100)
								nValor				:= aBases[nCntFor2,6]
							Endif

                            IF (lFatura .OR. lLiquid) .AND. __lF440aB2
                                aBasesAux := ExecBlock("F440aBa2",.F.,.F.,{"OP_LIQFAT",AClone(aBases)})
                                IF ValType(aBasesAux) == "A" .OR. (Len(aBasesAux) == Len(aBases))
                                    aBases := AClone(aBasesAux)
                                    aBases[nCntFor2][6] := (aBases[nCntFor2][4] * (aBases[1][7]/100))
                                    nVlrProp := aBases[nCntFor2][4]
                                    nValor := aBases[nCntFor2][6]
                                ENDIF
                                FwFreeArray(aBasesAux)
                            ENDIF

                            //-- Contexto do SIGALOJA
                            aBases[nCntFor2] := Fa440LjTrc(@nVlrProp,@nValor,aBases[nCntFor2],"B")

							If  IsInCallStack("FINA070") .And. ValType(lF070Auto) == "L" .And. !lF070Auto .And. !IsBlind .And. lMostComis
								lGrvAjuste	:=	.F.
								aBaseMVC	:=	aClone({aBases[nCntFor2]})
								nQtdeMVC 	:= Len(aBases)
								nSeqVend++
								
								FINA440MVC() // Função vai abrir tela em MVC para o cliente ajustar a comissão do vendedor.

								If lGrvAjuste
									nVlrProp	:= aBases[nCntFor2,4]	:= aBaseMVC[1,4]
									nValor		:= aBases[nCntFor2,6]	:= aBaseMVC[1,6]
									aBases[nCntFor2,7]	:= aBaseMVC[1,7]
								Endif
							Endif
									
							If ( aBases[nCntFor2,6] != 0 .And. nVlrProp > 0 ) .OR. ( aBases[nCntFor2,6] != 0 .AND. !Empty(SE1->E1_NUMLIQ) )

								SA3->(MsSeek(cFilSA3+aBases[nCntFor2,1]))

								lComVdBlq	:= .T.

								//ponto de entrada para validar se calcula comissao para vendedores bloqueados
								If lF440CVB
									lComVdBlq := ExecBlock("F440CVB",.F.,.F.)
								ElseIf SA3->A3_MSBLQL == "1"
									lComVdBlq := .F.
									If (cOrigem == "FINA440" .and. MV_PAR10 == 1)
										lComVdBlq := .T.
									EndIf
								EndIf

								If lComVdBlq
									SE3->(DbSetOrder(3))
									SE3->(MsSeek(cFilSE3+aBases[nCntFor2,1]+;
										SE1->E1_CLIENTE+SE1->E1_LOJA+;
										SE1->E1_PREFIXO+;
										SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO+cSeq))
									
									// Validação para que seja verificada existencia do título negativo na base.
									// Caso já exista e já esteja pago, não deverá gerar mais nenhum registro negativo na SE3
									If cSinal == "-"
										cChave := cFilSE3+aBases[nCntFor2,1]+ SE1->E1_CLIENTE+SE1->E1_LOJA+ SE1->E1_PREFIXO+ SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO+(cSeq)

										While SE3->(!EOF()) .AND. cFilSE3+SE3->(E3_VEND+E3_CODCLI+E3_LOJA+E3_PREFIXO+E3_NUM+E3_PARCELA+E3_TIPO+E3_SEQ)==cChave
											If "-" $ STR(SE3->E3_BASE)
												If !Empty(SE3->E3_DATA)
													lPago 	:= .T.
													lNaoGera := .T.
												EndIf
											EndIf
											SE3->(dbSkip())
										EndDo
									EndIf

									If !lNaoGera
										If SE3->(Found())
											If ( !Empty(SE3->E3_DATA) )
												lPago := .T.
												If (! cOrigem $ "FINA440" )  .Or. (cOrigem $ "FINA440" .And. cSinal == "-")
													RecLock("SE3",.T.)
													nValBase 		:= 0
													nValComis 		:= 0
												EndIf
											Else
												lPago := .F.
												RecLock("SE3",.F.)
											EndIf
										Else
											lPago := .F.
											
											If VldTitLJ()
												RecLock("SE3",.T.)
												lVldLj	:= .T.
											Endif
										
											nValBase 		:= 0
											nValComis 		:= 0
										EndIf
									Endif

									If ((((!lPago .Or. !(cOrigem $ "FINA440")) .Or. (lPago .And. (cSinal == '-' .and. !lNaoGera)) .And. nValor!=0))) .And. lVldLj

										nValBase  += (nVlrProp * Iif( cSinal == "-" .Or.( SE1->E1_TIPO $ MV_CRNEG  .And. cPaisLoc <>"BRA"),-1,1))
										nValComis += (nValor * Iif( cSinal == "-" .Or.( SE1->E1_TIPO $ MV_CRNEG  .And. cPaisLoc <>"BRA"),-1,1))

										If cPaisLoc=="MEX" 
											SE3->E3_MOEDA := StrZero(1,__nTmMoed)													
										Else
											SE3->E3_MOEDA := StrZero(SE1->E1_MOEDA,__nTmMoed)
										EndIf	
										
										If cPaisLoc=="MEX"
											nValBase:= xMoeda(nValBase,SE1->E1_MOEDA,SE1->E1_MOEDA,dDataBase)
											nValComis:= xMoeda(nValComis,SE1->E1_MOEDA,SE1->E1_MOEDA,dDataBase)
										EndIf

										SE3->E3_BASE    := Round(nValBase,__nTmBase )
										SE3->E3_COMIS   := Round(nValComis,__nTmComi )
										If __lRndPCom
											SE3->E3_PORC    := Round( Abs((nValComis/nValBase)*100), __nDecPCom + 1 )
										Else
											SE3->E3_PORC    := Noround( Abs((nValComis/nValBase)*100), __nDecPCom )
										EndIf
										SE3->E3_FILIAL  := cFilSE3
										SE3->E3_VEND    := aBases[nCntFor2,1]
										SerieNfId('SE3',1,'E3_SERIE',,,,SE1->E1_SERIE)
										SE3->E3_NUM     := SE1->E1_NUM
										SE3->E3_CODCLI  := SE1->E1_CLIENTE
										SE3->E3_LOJA    := SE1->E1_LOJA
										SE3->E3_EMISSAO := (Iif( cSinal == "-", dDatabase, dData))
										SE3->E3_PREFIXO := SE1->E1_PREFIXO
										SE3->E3_PARCELA := SE1->E1_PARCELA
										SE3->E3_TIPO    := SE1->E1_TIPO
										SE3->E3_BAIEMI  := "B"
										SE3->E3_ORIGEM  := Fa440Origem(cOrigem)
										SE3->E3_PEDIDO  := SE1->E1_PEDIDO
										SE3->E3_SEQ     := cSeq
										SE3->E3_CCUSTO  := SE1->E1_CCUSTO

										If nValBase < 0 .And. nValComis < 0
											SE3->E3_DATA  := dDatabase
										Endif

										If lGrvAjuste
											SE3->E3_AJUSTE := "R"
										Endif

										If cPaisLoc=="MEX"
											SE3->E3_MOEDA := StrZero(1,__nTmMoed)
										Else
											SE3->E3_MOEDA := StrZero(SE1->E1_MOEDA,__nTmMoed)
										EndIf

										If ( aBases[nCntFor2,7] != 0 ) .And. Empty(SE3->E3_PORC)
											If __lRndPCom
												SE3->E3_PORC    := Round( aBases[nCntFor2,7], __nDecPCom + 1 )
											Else
												SE3->E3_PORC    := Noround( aBases[nCntFor2,7], __nDecPCom )
											EndIf
										EndIf
										If Empty( SA3->A3_DIA )
											dVencto := dData
										Else
											dVencto := Ctod( strzero(SA3->A3_DIA,2)+"/"+;
												strzero(Month(dData),2)+"/"+;
												strzero( Year(dData),4),"ddmmyy")
											nDia := SA3->A3_DIA
											While empty( dVencto)
												nDia -= 1
												dVencto := CtoD(strzero(nDia,2)+"/"+;
													strzero(month(dData),2)+"/"+;
													strzero( year(dData),4),"ddmmyy")
											endDo
										EndIf

										if SA3->A3_DDD == "F" .or. dVencto < dData		//Fora o mes
											nDia := SA3->A3_DIA
											nMes := month(dVencto) + 1
											nAno := year (dVencto)
											If nMes == 13
												nMes := 01
												nAno := nAno + 1
											Endif
											nDia	  := strzero(nDia,2)
											nMes	  := strzero(nMes,2)
											nAno	  := substr(lTrim(str(nAno)),3,2)
											dVencto := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
										Else
											nDia	  := strzero(day(dVencto),2)
											nMes	  := strzero(month(dVencto),2)
											nAno	  := substr(lTrim(str(Year(dVencto))),3,2)
										Endif

										While empty( dVencto)
											nDia := if(Valtype(nDia)=="C",Val(nDia),nDia)
											nDia -= 1
											dVencto := CtoD(strzero(nDia,2)+"/"+nMes+"/"+nAno,"ddmmyy")
											if !empty( dVencto )
												if dVencto < dData
													dVencto += 2
												EndIf
											EndIf
										EndDo

										SE3->E3_VENCTO  := dVencto

										If lMSE3440
											ExecBlock("MSE3440",.F.,.F.,{nDescont,nJuros,cOrigem})
										EndIf

										//Controle de Saldo de Naturezas
										If lAtuSldNat .and. cNatCom <> NIL
											// Tratamento de outras moedas no controle de saldos do fluxo de caixa por natureza
											If VAL(SE3->E3_MOEDA) > 1
												nValSldNat := NOROUND(XMOEDA(SE3->E3_COMIS,1,VAL(SE3->E3_MOEDA),SE3->E3_EMISSAO))
											Else
												nValSldNat := SE3->E3_COMIS
											EndIf

											//Atualizo o valor atual para o saldo da natureza
											AtuSldNat(cNatCom, dVencto, SE3->E3_MOEDA, "2", "P", nValSldNat, SE3->E3_COMIS,"+",,FunName(),"SE3",SE3->(Recno()))
										EndIf

										MsUnlock()

										//Metricas - Registros processados
										nRegProc += 1

										FVldExcCom(,,,,,.T.,cSinal)

										// Somente gravamos as comissoes para Supervisor e Gerente para as comissoes
										// do modulo SIGALOJA. Para outros modulos, eh necessario uma analise
					
										// lLj440SbCm = .T. 		- indica se a funcao Lj440SbCom(LOJA440) existe no RPO
										// cFunName   = "LOJA701"	- Módulo SIGALOJA
										// cMvTpComLj = "O" 		- Flag de sistema utilizado, para informar se o cálculo da comissao, 
										//						  	  sera On-Line (O) ou em Batch (B).	
										
										If lLj440SbCm .AND. cFunName == "LOJA701" .AND. cMvTpComLj == "O"
											// Campo A3_SUPER preenchido e igual aBases[nCntFor2,1]
											// aBases[nCntFor2,1] = Posição do Vendedor no array aBases
											If ( !Empty(SA3->A3_SUPER) .AND. SA3->A3_SUPER == aBases[nCntFor2,1])											

												nPosBase:= aScan( aSE3, {|x| x[1] == "E3_BASE"} )		

												If nPosBase > 0												
													// Atualiza posição do array aSE3
													aSE3[nPosBase][2] := aBases[nCntFor2][4]
													// Calcula e atualiza os valores da comissão do Supervisor			
													Lj440SbCom(aSE3)	//(LOJA440.PRW)
												EndIf	
											EndIf	

											// Campo A3_GEREN preenchido e igual posição do array aBases 
											If ( !Empty(SA3->A3_GEREN) .AND. SA3->A3_GEREN == aBases[nCntFor2,1])
										
												nPosBase:= aScan( aSE3, {|x| x[1] == "E3_BASE"} )

												If nPosBase > 0												
													// Atualiza posição do array aSE3														
													aSE3[nPosBase][2] := aBases[nCntFor2][4]
													// Calcula e atualiza os valores da comissão do Gerente
													Lj440SbCom(aSE3)	//(LOJA440.PRW)																		
												EndIf	
											EndIf	
										EndIf
									EndIf																						
								EndIf
							EndIf
						EndIf
						aBases[nCntFor2,4] := nBaseBAK
						aBases[nCntFor2,6] := nComiBAK
					Next nCntFor2
					nDescont  := 0
					nVlrRec   := 0
					nJuros    := 0
					nMulta    := 0
					If aBaixas[nCntFor,3] == 0
						Exit
					EndIf
				EndIf
			Next nCntFor
			cFilAnt := cFilOri
		EndIf
	EndIf

	If lHelpFlag
		HELP(" ",1,"F440FLAGE3",, STR0031, 1, 0,,,,,,{STR0032})
	Endif

	//Limpa o objeto utilizado no MpSysExecScalar 
	If __oValLiq != Nil
		__oValLiq:Destroy()
		__oValLiq := Nil
	Endif

	If __oTotLiq != Nil
		__oTotLiq:Destroy()
		__oTotLiq := Nil
	Endif

	If __oPropSD2 != Nil
		__oPropSD2:Destroy()
		__oPropSD2 := Nil
	Endif

	If __oPropSD1 != Nil
		__oPropSD1:Destroy()
		__oPropSD1 := Nil
	Endif

	If __oStVldLJ != Nil
		__oStVldLJ:Destroy()
		__oStVldLJ := Nil
	Endif

	// Caso seja uma chamada externa restaura parametricação da rotina chamadora 
	IF lRestPerg
		RestInter()
	ENDIF

	nValAbatCom		:= 0
	cChaveComis		:= ""
	nSldTitComis	:= 0

	RestArea(aAreaSE5)
	FwFreeArray(aAreaSE5)

	RestArea(aAreaSE1)
	FwFreeArray(aAreaSE1)

	RestArea(aAreaSA3)
	FwFreeArray(aAreaSA3)

	RestArea(aArea)
	FwFreeArray(aArea)

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Fa440DeleE³ Autor ³ Eduardo Riera         ³ Data ³ 28/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Efetua descalculo da comissao na emissao do SE1 corrente   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cOrigem   : Origem da Comissao                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generio                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fa440DeleE(cOrigem,lParcela)

Local aArea     := GetArea()
Local aAreaSA3  := SA3->(GetArea())
Local aAreaSE1  := SE1->(GetArea())
Local aVendedor := {}
Local cVendedor := ""
Local cVend     := ""
Local nQtdVend  := Fa440CntVen()
Local nCntFor   := 0
Local cParcela  := Space(nTamParc)
Local cSinal    := If(SE1->E1_TIPO $ MV_CRNEG,"+","-")
Local aAux      := {}
Local lF440DEL  := Existblock("F440DEL")

DEFAULT lDevolucao:= SuperGetMv("MV_COMIDEV")
DEFAULT cParComEm 	:= GetNewPar("MV_PARCOMI","N") // Parcelamento da comissao na emissao
lParcela := IIF(lParcela == NIL, .F., .T.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Adiciona vendedores que deverÆo ter comissÆo descalculada.         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cVend := "1"
If ( SE1->E1_TIPO $ MV_CRNEG .And. lDevolucao )
	aAux := Fa440Comis(SE1->(RecNo()),.F.,.F.) // Verifica os vendedores apenas
	For nCntFor := 1 To Len(aAux)
		aadd(aVendedor,aAux[nCntFor,1])
	Next nCntFor
Else
	For nCntFor := 1 to nQtdVend
		cVendedor := SE1->(FieldGet(FieldPos("E1_VEND"+cVend)))
		If ( !Empty(cVendedor) )
			AAdd( aVendedor, cVendedor )
		EndIf
		cVend := Soma1(cVend,1)
	Next nCntFor
EndIf
//Verifica se foi parcelada a comissao na emissao
If cParComEm == "S" .or. lParcela
	cParcela := SE1->E1_PARCELA
Endif

For nCntFor := 1 To Len(aVendedor)
	lFound := .F.
	dbSelectArea("SE3")
	dbSetOrder(3)
	MsSeek(xFilial("SE3")+aVendedor[nCntfor]+SE1->E1_CLIENTE+SE1->E1_LOJA+SE1->E1_PREFIXO+SE1->E1_NUM+cParcela+SE1->E1_TIPO)
	If Found() .And. ( cParComEm == "S" .Or. lParcela )
		If ( Empty(SE3->E3_DATA) ) // Nao esta pago
			RecLock("SE3")
			dbDelete()
			MsUnlock()
		Else
			Fa440CalcE(cOrigem,aVendedor[nCntFor],aVendedor[nCntFor],cSinal)
		EndIf
	Else
		Fa440CalcE(cOrigem,aVendedor[nCntFor],aVendedor[nCntFor],cSinal)
		dbSelectArea("SE3")
		dbSetOrder(3)
		If MsSeek(xFilial("SE3")+aVendedor[nCntfor]+SE1->E1_CLIENTE+SE1->E1_LOJA+SE1->E1_PREFIXO+SE1->E1_NUM+cParcela+SE1->E1_TIPO)
			If (SE3->E3_COMIS == 0 .And. Empty(SE3->E3_DATA)) .Or. (__l440Flag .And. SE3->&(Upper(__cCpoFlag)) == "1" .And. IsInCallStack("FINA040")) .Or. SE3->E3_AJUSTE != "R"
				RecLock("SE3")
				dbDelete()
				MsUnlock()
			EndIf
		EndIf
	EndIf

	If lF440DEL
		ExecBlock("F440DEL",.F.,.F., aVendedor[nCntFor])
	EndIf
	
Next nCntFor

RestArea(aAreaSE1)
RestArea(aAreaSA3)
RestArea(aArea)

Return(.F.)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Fa440DeleB³ Autor ³ Eduardo Riera         ³ Data ³ 27/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Efetua descalculo da comissao na baixa                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aBaixas   : array c/ dados da baixa : [MOTBX,SEQ,REGISTRO] ³±±
±±³          ³ lJuros    : Considera Juros                                ³±±
±±³          ³ lDescont  : Considera Desconto                             ³±±
±±³          ³ cOrigem   : Origem da Comissao                             ³±±
±±³          ³ cVendDe   : Vendedor de ?                                  ³±±
±±³          ³ cVendAte  : Vendedor ate?                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generio                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fa440DeleB(aBaixas,lJuros,lDescont,cOrigem,cVendDe,cVendAte)

Local aArea 	 := GetArea()
Local aAreaSA3 	 := SA3->(GetArea())
Local aAreaSE1 	 := SE1->(GetArea())
Local aAreaSE5 	 := SE5->(GetArea())
Local aVendedor	 := {}
Local aLiquid  	 := {}
Local aSeqCont	 := {} //Controle de calculo de comissoes (Sequencia no SE5)
Local aRecSE1	 := {}
Local aTitLiq	 := {}
Local nCntFor  	 := 0
Local nCntFor2 	 := 0
Local nX		 := 0
Local nY		 := 0
Local nRecSE1	 := 0
Local nValComis	 := 0
Local nQtdVend 	 := Fa440CntVen()
Local cQuebra  	 := ""
Local cSeq     	 := ""
Local cTitulo  	 := ""
Local cVendedor	 := ""
Local cAliasSE1	 := ""
Local cWhere	 := ""
Local lLiquid    := .F. 
Local lFatura  	 := .F.
Local cNatCom	 := PADR(&(GetNewPar("MV_NATCOM","")),nTamE2_NATUR)
Local lAtuSldNat := lFindAtuSld .AND. AliasInDic("FIV") .AND. AliasInDic("FIW")
Local cFilSE3	 := ''
Local cVendNx 	 := ''
Local cSoma1 	 := '9'
Local cFilOri	 := cFilAnt
Local nQtdBaixas As Numeric
Local cFilialTit As Character

DEFAULT lDevolucao	:= SuperGetMv("MV_COMIDEV")
DEFAULT cComisCR	:= GetMv("MV_COMISCR")
DEFAULT lCompensa	:= cComisCR == "S"
DEFAULT lF440DelB	:= Existblock("F440DELB")
DEFAULT lGestao		:= Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa

PRIVATE cKeySE1 	:= ""

If cPaisLoc == "MEX"
	cFilSE3 := xFilial("SE3")
Else
	If lGestao
		cFilSE3 := Iif(Empty(FwFilial("SE3")) , xFilial("SE3") , SE1->E1_FILORIG )
	Else
		cFilSE3 := Iif(Empty(xFilial("SE3")) , xFilial("SE3") , SE1->E1_FILORIG )
	EndIf
Endif

If (nQtdBaixas := Len(aBaixas)) > 0
	DbSelectArea("SE3")
	AAdd(aBaixas, {"zzz", "zz", 0}) //Controle de Saida
	nQtdBaixas += 1
	cFilialTit := Nil
	
	For nCntFor := 1 To nQtdBaixas
		If ( If(!lDevolucao,aBaixas[nCntFor,1]!="DEV",.T.) .And. ;
				If(!lCompensa ,aBaixas[nCntFor,1]!="CMP",.T.) )
			dbSelectArea("SE5")
			
			If ( aBaixas[nCntFor,3] != 0 )
				SE5->(MsGoto(aBaixas[nCntFor,3]))
			Else
				cQuebra := ""	
			EndIf	
			
			If ( cQuebra != aBaixas[nCntFor,1]+aBaixas[nCntFor,2]+CVALTOCHAR(aBaixas[nCntFor,3]) .OR. FunName()=="FINA088")
				If ( !Empty(cQuebra) .Or. aBaixas[nCntFor,3] == 0 )
					dbSelectArea("SE1")
					dbSetOrder(2)			

					If !SE1->(MsSeek(xFilial("SE1", cFilialTit)+cTitulo)) .And. cOrigem == "FINA330"
						MsSeek(SE5->E5_FILORIG+cTitulo)
						cFilAnt := SE5->E5_FILORIG
					EndIf
					
					nRecSE1 := SE1->(Recno())
					lFatura   := If(alltrim(SE1->E1_FATURA)=="NOTFAT",.T.,.F.)
					lLiquid  := !Empty(SE1->E1_NUMLIQ)
					
					//Adiciona vendedores que deverÆo ser descalculados
					If ( !lFatura .And. !lLiquid)
						aVendedor 	:= {}
						cSoma1		:= "9"
						
						For nCntFor2 := 1 to nQtdVend
							If nCntFor2 > 9
								cSoma1 := Soma1(cSoma1,1)	// Converte para "A" e assim por diante
								cVendNx := cSoma1
							Else
								cVendNx := Str(nCntFor2)
							EndIf
							
							cVendedor := &("SE1->E1_VEND"+Alltrim(cVendNx))
							
							If ( !Empty(cVendedor) )
								AAdd( aVendedor , cVendedor)
							EndIf
						Next nCntFor2
					Else
						If lFatura
							aVendedor := {}
							nRecSE1 := SE1->(Recno())							
								cWhere  := ""
								If SE1->E1_ORIGEM <> "FINA280M" // Se fatura com multiplas filiais
									cWhere  +=  "SE1.E1_FILIAL = '"+ xFilial("SE1") +"' AND "
								EndIf
								cWhere +=  "SE1.E1_FATPREF = '" + SE1->E1_PREFIXO + "' AND "
								cWhere +=  "SE1.E1_FATURA = '" + SE1->E1_NUM + "' "
								cWhere := "%"+cWhere+"%"
								cAliasSE1 := GetNextAlias()
								BeginSql Alias cAliasSE1
									SELECT 
										SE1.R_E_C_N_O_ RECSE1 
									FROM 
										%Table:SE1% SE1
									WHERE 
										%Exp:cWhere% AND
										SE1.%NotDel%							
									ORDER BY
										E1_FILIAL,E1_CLIENTE,E1_LOJA,E1_FATPREF,E1_FATURA
								EndSql
								
								(cAliasSE1)->(dbGoTop())
					
								While !(cAliasSE1)->(Eof())
									aAdd(aRecSE1,(cAliasSE1)->RECSE1)
									(cAliasSE1)->(dbSkip())
								EndDo
			
								(cAliasSE1)->(dbCloseArea())

								Fa440LiqFat(@aRecSE1, @aTitLiq)
								
								For nY := 1 To Len(aRecSE1) 
									dbSelectArea("SE1")
									SE1->(dbGoTo(aRecSE1[nY]))
										cSoma1 := "9"
										For nCntFor2 := 1 to nQtdVend
											If nCntFor2 > 9
												cSoma1 := Soma1(cSoma1,1)	// Converte para "A" e assim por diante
												cVendNx := cSoma1
											Else
												cVendNx := Str(nCntFor2)
											EndIf
											cVendedor := &("SE1->E1_VEND"+Alltrim(cVendNx))
											If ( !Empty(cVendedor) )
												If ( aScan(aVendedor,{|x| x == cVendedor}) == 0 )
													AAdd( aVendedor , cVendedor)
												EndIf	
											EndIf
										Next nCntFor2
								Next nY

								//volta ao registro original antes de procurar o vendedor da proxima loja
								dbSelectArea("SE1")
								SE1->(dbGoto(nRecSE1))							
						Else
							Fa440LiqSE1(SE1->E1_NUMLIQ,@aLiquid,,@aSeqCont)							
							For nX := 1 To Len(aLiquid)							
								SE1->(MsGoto(aLiquid[nX]))
									cSoma1 := "9"
									For nCntFor2 := 1 to nQtdVend
										If nCntFor2 > 9
											cSoma1 := Soma1(cSoma1,1)	// Converte para "A" e assim por diante
											cVendNx := cSoma1
										Else
											cVendNx := Str(nCntFor2)
										EndIf
										cVendedor := &("SE1->E1_VEND"+Alltrim(cVendNx))
										If ( !Empty(cVendedor) )
											If ( aScan(aVendedor,{|x| x == cVendedor}) == 0 )
												AAdd( aVendedor , cVendedor)
											EndIf
										EndIf
									Next nCntFor2
							Next nX
						EndIf
					EndIf
					
					SE1->(dbGoto(nRecSE1))
					
					If !Empty(SE1->E1_FILORIG)
						cFilSE3 := FwxFilial("SE3", SE1->E1_FILORIG)
					EndIf
					
					For nCntFor2 := 1 To Len(aVendedor)
						If ( If(cVendDe==Nil.Or.cVendAte==Nil,.T.,;
								aVendedor[nCntFor2]>=cVendDe.And.;
								aVendedor[nCntFor2] <= cVendAte ) )
								
							dbSelectArea("SE3")
							dbSetOrder(3) //E3_FILIAL+E3_VEND+E3_CODCLI+E3_LOJA+E3_PREFIXO+E3_NUM+E3_PARCELA+E3_TIPO+E3_SEQ
							MsSeek(cFilSE3+aVendedor[nCntFor2]+cTitulo+cSeq,.F.)
							If ( Found() )
								If ( Empty(SE3->E3_DATA) ) // Nao esta pago
									If lAtuSldNat .and. cNatCom != NIL
										// Tratamento de outras moedas no controle de saldos do fluxo de caixa por natureza
										If VAL(SE3->E3_MOEDA) > 1
											nValComis := NOROUND(XMOEDA(SE3->E3_COMIS,1,VAL(SE3->E3_MOEDA),SE3->E3_EMISSAO))
										Else
									   		nValComis := SE3->E3_COMIS
										EndIf
									
										//Atualizo o valor atual para o saldo da natureza
										AtuSldNat(cNatCom, SE3->E3_VENCTO,  SE3->E3_MOEDA, "2", "P", nValComis, SE3->E3_COMIS,"-",,FunName(),"SE3",SE3->(Recno()))
									Endif
																					
									RecLock("SE3")
										If !(__l440Flag .And. SE3->&(Upper(__cCpoFlag)) == "1") .Or. IsInCallStack("FINA070") .Or. SE3->E3_AJUSTE != "R"
											dbDelete()
										Endif
									MsUnlock()
								Else
									If (SE5->E5_MOTBX <> 'LIQ' .AND. SE5->E5_SITUACA <> 'C')
										// não gerar comissao negativa para liquidacao cancelada, pois a comissao gerada é excluida no cancelamento
										Fa440CalcB({aBaixas[nCntFor-1]},lJuros,lDescont,cOrigem,"-",aVendedor[nCntFor2],aVendedor[nCntFor2])
									EndIf	
								EndIf
							EndIf
						EndIf
						
						If lF440DelB
							ExecBlock("F440DELB",.F.,.F., aVendedor[nCntFor2])
						EndIf
					Next nCntFor2
					
					If aBaixas[nCntFor,3] == 0
						Exit
					Else
						aLiquid := {} 
					EndIf
					
					cFilAnt := cFilOri
				EndIf
				
				cQuebra := aBaixas[nCntFor,1]+aBaixas[nCntFor,2]+CVALTOCHAR(aBaixas[nCntFor,3])
				cTitulo := SE5->(E5_CLIFOR+E5_LOJA+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)
				cSeq    := SE5->E5_SEQ
				
				If !Empty(SE5->E5_FILORIG) 
					cFilialTit := SE5->E5_FILORIG
				EndIf
			EndIf
		EndIf
	Next nCntFor
EndIf

RestArea(aAreaSE5)
RestArea(aAreaSE1)
RestArea(aAreaSA3)
RestArea(aArea)
Return(.F.)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³FA440ChecF³ Autor ³ Eduardo Riera         ³ Data ³ 01/10/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Efetua sele‡„o dos T¡tulos.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA440                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fa440Checf(nFiltro,lQuery)

Local cFiltro		:= ""
Local cQuery		:= ""
Local lSE5MCFIL 	:= FWMODEACCESS("SE5",3) == 'C'

DEFAULT lQuery 		:= .F.
DEFAULT cComiLiq 	:= SuperGetMv("MV_COMILIQ",,"2")
DEFAULT lDevolucao	:= SuperGetMv("MV_COMIDEV")
DEFAULT lComiLiq	:= ComisBx("LIQ") .AND. cComiLiq == "1"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso motivo da baixa seja DEVOLUCAO e lCalcComis = .F.	³
//³ NO calcula a comiss„o . O Valor de lCalcComis vem do 	³
//³ parƒmetro MV_COMIDEV									³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If ( nFiltro == 1 )
	cFiltro := 'E1_FILIAL=="'+xFilial("SE1")+'".And.'
	cFiltro += 'DTOS(E1_EMISSAO)>="'+DTOS(mv_par01)+'".And.'
	cFiltro += 'DTOS(E1_EMISSAO)<="'+DTOS(mv_par02)+'".And.'
	cFiltro += '!(E1_TIPO $ "' + MVRECANT + If(!lDevolucao,'#'+MV_CRNEG,'')+'")'
EndIf
If ( nFiltro == 2 )
	cFiltro := 'E5_FILIAL=="'+xFilial("SE5")+'".And.'
	If !lSE5MCFIL
     	cQuery := "((E5_FILIAL = '" + xFilial("SE5") + "' AND E5_MOTBX NOT IN ('CMP','CEC')) OR (E5_FILORIG = '" + xFilial("SE5") +"' AND E5_MOTBX IN ('CMP','CEC'))) AND "
    Else
        cQuery := "E5_FILIAL = '" + xFilial("SE5") + "' AND "
    Endif

   //Verifica se considera a data da baixa ou a data de disponibilidade do titulo
	If mv_par09 == 1
		cFiltro += 'Dtos(E5_DATA)>="' + Dtos(mv_par01) + '".And.'
		cQuery  += "E5_DATA >= '"+dtos(mv_par01) + "' AND "
		cFiltro += 'Dtos(E5_DATA)<="' + Dtos(mv_par02) + '".And.'
		cQuery  += "E5_DATA <= '"+Dtos(mv_par02) + "' AND "
	Else
		cFiltro += 'Dtos(E5_DTDISPO)>="' + Dtos(mv_par01) + '".And.'
		cQuery  += "E5_DTDISPO >= '"+dtos(mv_par01) + "' AND "
		cFiltro += 'Dtos(E5_DTDISPO)<="' + Dtos(mv_par02) + '".And.'
		cQuery  += "E5_DTDISPO <= '"+Dtos(mv_par02) + "' AND "
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso parƒmetro MV_COMIDEV = .F.	, desconsidera o baixa de³
	//³ titulo por devolucao para fins de recalculo de comissao. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lDevolucao
		cFiltro += 'E5_MOTBX!="DEV".And.'
		cQuery  += "E5_MOTBX<>'DEV' AND "
	Endif
	cFiltro += 'E5_MOTBX != "'+Space(Len(SE5->E5_MOTBX))+'".And.'

	//NAO permitir que se faca calculo de comissao pela geracao da liquidacao e sim pelo metodo novo
	If !lComiLiq
		cQuery  += "E5_MOTBX NOT IN('   ','LIQ') AND "
		cFiltro += 'E5_MOTBX <> "LIQ" .And.'
	Endif

	cFiltro += '(E5_RECPAG=="R".Or.(E5_RECPAG=="P".And.(E5_TIPODOC=="ES" .Or. E5_TIPO $ MV_CRNEG))) .And. !(E5_TIPODOC$"BD#TR")'
	cQuery  += "(E5_RECPAG='R' OR (E5_RECPAG='P' AND (E5_TIPODOC='ES' Or E5_TIPO IN "+FormatIN(MV_CRNEG,,3)+"))) AND E5_TIPODOC NOT IN('BD','TR','CM') "

EndIf
If ( nFiltro == 3 )
	cFiltro := 'E3_FILIAL=="'+xFilial("SE3")+'".And.'
	cFiltro += 'Dtos(E3_EMISSAO)>="'+Dtos(mv_par01)+'".And.'
	cFiltro += 'Dtos(E3_EMISSAO)<="'+Dtos(mv_par02)+'".And.'
	cFiltro += 'E3_VEND>="'+mv_par03+'".And.'
	cFiltro += 'E3_VEND<="'+mv_par04+'".And.'
	cFiltro += 'Dtos(E3_DATA)=="'+Dtos(cTod("//"))+'".And.'
	cFiltro += 'E3_ORIGEM!=" "'
EndIf

Return IIF(lQuery,cQuery,cFiltro)


/*/{Protheus.doc} Fa440Comis
    @description Efetua o calculo das bases da comissao de um determinado título financeiro.
    @author Eduardo Riera
    @since 16/12/97
	@param 
		nRegistro, 	Numeric, 	Número do registro do SE1 (contas a receber)
		lGrava, 	Logical, 	Atualiza as bases da comissão na SE1
		lRefaz, 	Logical, 	(.F.) Retorna bases do SE1 ou (.T.) recalcula (Default)
		nRegDevol, 	Numeric, 	Número do Registro do SD2 para Devol.de Vendas
		lCalcParc, 	Logical, 	Não calcula array de bases por parcela da NF
		nRecnoOrig, Numeric, 	
    @return Retorna um Array com as bases da comissão na seguinte estrutura:
         1 - Código do vendedor
         2 - Base da comissão
         3 - Base na emissão
         4 - Base na baixa
         5 - Valor na emissão
         6 - Valor na baixa
         7 - % da comissão (se "zero" retorna diversos %'s)
         8 - Valor do Pis
         9 - Valor do CSLL
        10 - Valor do COFINS
        11 - Valor do IRRF

    @type function
/*/
Function Fa440Comis(nRegistro as Numeric, lGrava as Logical, lRefaz as Logical, nRegDevol as Numeric, lCalcParc as Logical, nRecnoOrig as Numeric, lVendaLoja as Logical, nRegSF2 as Numeric) as Array

	Local aArea 		as Array
	Local aAreaSE4  	as Array
	Local aAreaSF2  	as Array
	Local aAreaSF4  	as Array
	Local aAreaSD2  	as Array
	Local aAreaSA1  	as Array
	Local aAreaSA3  	as Array
	Local aAreaSD1  	as Array
	Local aAreaSF1  	as Array
	Local aAreaSE1  	as Array
	Local aAux      	as Array
	Local aSD2Vend  	as Array // Array c/ as Bases dos Vend. por item de nota
	Local aBaseNCC  	as Array // Array c/ as Bases dos Vend.
	Local aBaseSE1  	as Array // Array c/ as Bases dos Vend. do Titulo em questao
	Local aBaseSD1  	as Array // Array c/ as Bases dos Vend. do Item da NFE
	Local aImp			as Array  // Recebe o array de TesImpInf
	Local aSemNota		as Array
	Local aVendPed  	as Array
	Local nCntFor   	as Numeric
	Local nMaxFor   	as Numeric
	Local nBaseSe1  	as Numeric // Base da Comissao
	Local nBaseDif  	as Numeric
	Local nPerComis 	as Numeric // Percentual da Comissao
	Local nBaseEmis 	as Numeric // Base da Comissao na Emissao
	Local nBaseBaix 	as Numeric // Base da Comissao na Baixa                  s
	Local nVlrEmis  	as Numeric // Valor da Comissao na Emissao
	Local nVlrBaix  	as Numeric // Valor da Comissao na Baixa
	Local nFrete    	as Numeric // Valor do Frete
	Local nIcmFrete 	as Numeric // Valor do Icms sobre frete
	Local nTotal    	as Numeric // Total das mercadorias pelo item
	Local nRatFrete 	as Numeric // Valor rateado do Frete por item
	Local nRatIcmFre	as Numeric // Valor rateado do icms s/ frete por item
	Local nSF2IcmRet	as Numeric // Valor do Icms Retido
	Local nVlrFat   	as Numeric // Valor faturado
	Local nVlrTit   	as Numeric // valor do titulo em questao
	Local nProp     	as Numeric
	Local nPos      	as Numeric
	Local nAlEmissao	as Numeric
	Local nAlBaixa  	as Numeric
	Local nRatINSS  	as Numeric
	Local nRatIRRF  	as Numeric
	Local nX        	as Numeric
	Local nRatCOF		as Numeric
	Local nRatCSL		as Numeric
	Local nRatPIS  	    as Numeric
	Local nScanPis  	as Numeric
	Local nScanCof  	as Numeric
	Local nImp      	as Numeric
	Local nDescImp  	as Numeric
	Local nFreteAux 	as Numeric
	Local nPis 			as Numeric
	Local nCofins 		as Numeric
	Local nCsll 		as Numeric
	Local nDecimal  	as Numeric // N@ de decimais considerados no calculo
	Local cVend     	as Character
	Local cVendedor 	as Character
	Local cSerie    	as Character
	Local cPrefixo  	as Character // Prefixo da Duplicata
	Local cFilialSD1	as Character
	Local cFilialSD2	as Character
	Local cFilialSE1	as Character
	Local cFilialSE4	as Character
	Local cFilialSF1	as Character
	Local cFilialSF2	as Character
	Local cFilialSF4	as Character
	Local cFieldPis 	as Character
	Local cFieldCof 	as Character
	Local cCposSD2  	as Character
	Local cAliasSD1 	as Character
	Local cAliasSD2 	as Character
	Local cAliasDev 	as Character
	Local cAliasSF4 	as Character
	Local cImp			as Character	 // Se A3_COMIMP nao existe, cImp = N, senao pega valor em A3_COMIMP
	Local cEspSes		as Character
	Local lQuery    	as Logical
	Local lContinua 	as Logical
	Local cPrimParc 	as Character
	Local lRecIRRF  	as Logical
	Local lMata460  	as Logical
	//Controla o Pis Cofins e Csll na baixa  (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default) )
	Local lPccBxCr		as Logical

	Local lIrPjBxCr		as Logical
	Local lCalEmis		as Logical
	Local lCOMIPIS		as Logical
	Local lCOMICOF		as Logical
	Local lCOMICSL		as Logical
	Local lCOMISIR		as Logical
	Local lCOMISIN		as Logical
	Local lMultVend     as Logical
	Local nImpComis	    as Numeric
	Local nIrrf     	as Numeric
	Local cFunName 	    as Character
	Local cLastVend	    as Character
	Local cLastItem	    as Character
	Local nPosITEM	    as Numeric
	Local nRedIcms	    as Numeric
	Local cEstado		as Character
	Local nCntForOld    as Numeric
	Local lCalcIssBx	as Logical
	Local nValISS		as Numeric
	Local nValCom 	    as Numeric
	Local lLoja         as Logical
	Local c1DUPREF      as Character
	Local nVRetISS      as Numeric
	Local nPosTXM 		as Numeric
	//Variável usadas como aux ao P.E F440BASE, para não gerar.
	//divergência na gravação do valor base da comissão.
	Local nF440BasEm 	as Numeric
	Local cQuery    	as Character
	Local lTransf		as Logical
	Local nRecSe1		as Numeric
	Local lIntGC		as Logical
	Local lFuncGC		as Logical
	Local lIsCallCbr    as Logical 
	Local cAliasTtLj	as Character 		// Alias dos titulos da venda do Loja
	Local nBaseComX		as Numeric
	Local aAreaSE6		as Array
	Local cVendItLoj	as Character		// Código do Vendedor por item
	Local nComisVen		as Numeric
	Local lPedLoja		as Logical 			// Pedido de Vendas gerado pelo SIGALOJA
	Local lChkLoj		as Logical 			// Verifica se a função Lj720CkLoj está compilada no RPO

	aArea 			:= GetArea()
	aAreaSE4  		:= {}
	aAreaSF2  		:= {}
	aAreaSF4  		:= {}
	aAreaSD2  		:= {}
	aAreaSA1  		:= {}
	aAreaSA3  		:= {}
	aAreaSD1  		:= {}
	aAreaSF1  		:= {}
	aAreaSE1  		:= {}
	aAux      		:= {}
	aSD2Vend  		:= {} // Array c/ as Bases dos Vend. por item de nota
	aBaseNCC  		:= {} // Array c/ as Bases dos Vend.
	aBaseSE1  		:= {} // Array c/ as Bases dos Vend. do Titulo em questao
	aBaseSD1  		:= {} // Array c/ as Bases dos Vend. do Item da NFE
	aImp			:= {}  // Recebe o array de TesImpInf
	aSemNota		:= {}
	aVendPed  		:= {}
	nCntFor   		:= 0
	nMaxFor   		:= 0
	nBaseSe1  		:= 0 // Base da Comissao
	nBaseDif  		:= 0
	nPerComis 		:= 0 // Percentual da Comissao
	nBaseEmis 		:= 0 // Base da Comissao na Emissao
	nBaseBaix 		:= 0 // Base da Comissao na Baixa                  s
	nVlrEmis  		:= 0 // Valor da Comissao na Emissao
	nVlrBaix  		:= 0 // Valor da Comissao na Baixa
	nFrete    		:= 0 // Valor do Frete
	nIcmFrete 		:= 0 // Valor do Icms sobre frete
	nTotal    		:= 0 // Total das mercadorias pelo item
	nRatFrete 		:= 0 // Valor rateado do Frete por item
	nRatIcmFre		:= 0 // Valor rateado do icms s/ frete por item
	nSF2IcmRet		:= 0 // Valor do Icms Retido
	nVlrFat   		:= 0 // Valor faturado
	nVlrTit   		:= 0 // valor do titulo em questao
	nProp     		:= 0
	nPos      		:= 0
	nAlEmissao		:= 0
	nAlBaixa  		:= 0
	nRatINSS  		:= 0
	nRatIRRF  		:= 0
	nX        		:= 0
	nRatCOF			:= 0
	nRatCSL			:= 0
	nRatPIS  	    := 0
	nScanPis  		:= 0
	nScanCof  		:= 0
	nImp      		:= 0
	nDescImp  		:= 0
	nFreteAux 		:= 0
	nPis 			:= 0
	nCofins 		:= 0
	nCsll 			:= 0
	nDecimal  		:= nTamBascom // N@ de decimais considerados no calculo
	cVend     		:= "1"
	cVendedor 		:= ""
	cSerie    		:= ""
	cPrefixo  		:= "" // Prefixo da Duplicata
	cFilialSD1		:= ""
	cFilialSD2		:= ""
	cFilialSE1		:= ""
	cFilialSE4		:= ""
	cFilialSF1		:= ""
	cFilialSF2		:= ""
	cFilialSF4		:= ""
	cFieldPis 		:= ""
	cFieldCof 		:= ""
	cCposSD2  		:= ""
	cAliasSD1 		:= "SD1"
	cAliasSD2 		:= "SD2"
	cAliasDev 		:= "SD1"
	cAliasSF4 		:= "SF4"
	cImp			:= "N"	 // Se A3_COMIMP nao existe, cImp = N, senao pega valor em A3_COMIMP
	cEspSes			:= " "
	lQuery    		:= .F.
	lContinua 		:= .T.
	cPrimParc 		:= " "
	lRecIRRF  		:= .F.
	lMata460  		:= Alltrim(SE1->E1_ORIGEM) == "MATA460"
	//Controla o Pis Cofins e Csll na baixa  (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default) )
	lPccBxCr		:= If (lFindPccBx,FPccBxCr(),.F.)

	lIrPjBxCr		:= If (lFindIrBx,FIrPjBxCr(),.F.)
	lCalEmis		:= IsInCallStack("FA440CALCE")
	lCOMIPIS		:= GetNewPar("MV_COMIPIS","N") == "N"
	lCOMICOF		:= GetNewPar("MV_COMICOF","N") == "N"
	lCOMICSL		:= GetNewPar("MV_COMICSL","N") == "N"
	lCOMISIR		:= GetNewPar("MV_COMISIR","N") == "N"
	lCOMISIN		:= GetNewPar("MV_COMIINS","N") == "N"
	lMultVend     	:= SuperGetMv("MV_LJTPCOM",,"1" ) == "2"
	nImpComis	    := 0
	nIrrf     		:= 0
	cFunName 	    := FunName()
	cLastVend	    := ""
	cLastItem	    := ""
	nPosITEM	    := 0
	nRedIcms	    := 0
	cEstado			:= SuperGetMv("MV_ESTADO")
	nCntForOld    	:= 0
	lCalcIssBx		:= GetNewPar("MV_MRETISS","1") == "2"
	nValISS			:= 0
	nValCom 	    := 0
	lLoja         	:= IsInCallStack("LjGrvFin") .Or. cFunName == "LOJA701" //Funcoes chamadas pelo Loja
	c1DUPREF      	:= GetMV("MV_1DUPREF")
	nVRetISS      	:= SuperGetMV("MV_VRETISS",.F.,0)
	nPosTXM 		:= 0
	//Variável usadas como aux ao P.E F440BASE, para não gerar.
	//divergência na gravação do valor base da comissão.
	nF440BasEm 		:= 0
	cQuery    		:= ""
	lTransf			:= .F.
	nRecSe1			:= 0
	lIntGC          := IIf((SuperGetMV("MV_VEICULO",,"N")) == "S",.T.,.F.) // Módulos Concessionárias ( 11 - Veiculos / 14 - Oficina / 41 - Auto-Peças )
	lFuncGC         := FindFunction("OFIA291") // Existe a função de Concessionárias ( 11 - Veiculos / 14 - Oficina / 41 - Auto-Peças )
	lIsCallCbr      := Iif(FindFunction('IsCallCobr'),IsCallCobr(),IsInCallStack("FINA087A"))
	cAliasTtLj		:= ""						// Alias dos titulos da venda do Loja
	nBaseComX		:= 0
	aAreaSE6		:= {}
	cVendItLoj		:= ""
	nComisVen		:= 0
	lPedLoja		:= .F.							// Pedido de Vendas gerado pelo SIGALOJA
	lChkLoj			:= FindFunction("Lj720CkLoj") 	// Verifica se a função Lj720CkLoj está compilada o RPO

	Static aStruSD1
	Static aStruSD2
	Static aStruSF4

	Default lCalcParc := .T.
	Default nRecnoOrig := nRegistro
	Default cMV_1DUP	:= SuperGetMv("MV_1DUP")
	Default cComiLiq 	:= SuperGetMv("MV_COMILIQ",,"2")
	Default lComiLiq	:= ComisBx("LIQ") .AND. cComiLiq == "1"
	Default lF440BasEm	:= Existblock("F440BASE")
	Default lVendaLoja	:= .F. 									// Indica se eh venda originaria do Loja
	Default nRegSF2		:= 0 									// Recno da SF2 da venda do Loja

	__nVend := fa440CntVen() // Numero M ximo de Vendedores
	If aRelImp == nil 
		aRelImp		:= MaFisRelImp("MT100",{ "SD2" })
	EndIf	
	// Abertura dos arquivos pois no Loja alguns nao sao utilizados

	If cPaisLoc == "BRA"
		cCposSD2 := "D2_FILIAL#D2_DOC#D2_SERIE#D2_CLIENTE#D2_LOJA#D2_TES#D2_ICMFRET#D2_TOTAL#D2_VALICM#D2_ICMSCOM#D2_DIFAL#D2_VALIPI#D2_IPI#D2_ICMSRET#D2_VALACRS#D2_ITEM#D2_COD#D2_DESCICM#D2_VALISS"
	Else
		cCposSD2 := "D2_FILIAL#D2_DOC#D2_SERIE#D2_CLIENTE#D2_LOJA#D2_TES#D2_ICMFRET#D2_TOTAL#D2_VALICM#D2_VALIPI#D2_IPI#D2_ICMSRET#D2_VALACRS#D2_ITEM#D2_COD#D2_DESCICM"
	EndIf

	If "FINA630" $ SE1->E1_ORIGEM
		__nRecOrig := 0
		nRecSE1 := SE1->(Recno())
		lTransf	:= FindF2Orig()
		cFilAnt	:= SE1->E1_FILORIG
	EndIf

	dbSelectArea("SE4")
	aAreaSE4  := SE4->(GetArea())
	cFilialSE4:= xFilial("SE4")

	dbSelectArea("SF2")
	aAreaSF2  := SF2->(GetArea())
	cFilialSF2:= xFilial("SF2", SE1->E1_FILORIG)

	dbSelectArea("SF4")
	aAreaSF4  := SF4->(GetArea())
	cFilialSF4:= xFilial("SF4", SE1->E1_FILORIG)

	dbSelectArea("SD2")
	aAreaSD2  := SD2->(GetArea())
	cFilialSD2:= xFilial("SD2", SE1->E1_FILORIG)

	dbSelectArea("SA1")
	aAreaSA1  := SA1->(GetArea())

	dbSelectArea("SA3")
	aAreaSA3  := SA3->(GetArea())

	dbSelectArea("SD1")
	aAreaSD1  := SD1->(GetArea())
	cFilialSD1:= xFilial("SD1", SE1->E1_FILORIG)

	dbSelectArea("SF1")
	aAreaSF1  := SF1->(GetArea())
	cFilialSF1:= xFilial("SF1", SE1->E1_FILORIG)

	If lTransf
		SE1->(DbGoTo(nRecSE1))
		cFilAnt	:= SE1->E1_FILORIG
	EndIf

	dbSelectArea("SE1")
	aAreaSE1  := SE1->(GetArea())
	cFilialSE1:= xFilial("SE1")

	RestArea(aArea)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se é a primeira parcela de uma fatura               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nTamParc == 1
		cPrimParc := "1A "
	ElseIf nTamparc == 2
		cPrimParc := cMV_1DUP+Space(2-Len(cMV_1DUP))
		If cPrimParc == "00"
			cPrimParc += "#1 #A #  "
		Else	
			cPrimParc += "#1 #A #  #01"
		EndIf
	Else
		cPrimParc := cMV_1DUP+Space(3-Len(cMV_1DUP))
		If cPrimParc == "000"
			cPrimParc += "#1  #A  #   "
		Else	
			cPrimParc += "#1  #A  #   #001"
		EndIf
	Endif

	If nTamParc == 1
		cSegparc := "2B "
	ElseIf nTamparc == 2
		cSegparc := soma1(cMV_1DUP,1)+Space(2-Len(cMV_1DUP))
		cSegparc += "#2 #B #  #02"
	Else	
		cSegparc := soma1(cMV_1DUP,1)+Space(3-Len(cMV_1DUP))
		cSegparc += "#2  #B  #   #002"
	Endif
	if cPaisLoc<>"BRA"
		cEspSes	:= GetSesNew("NDC","1")
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento de Parametros Default da funcao                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lRefaz := If( lRefaz == Nil , .T. , lRefaz )
	lGrava := If( lGrava == Nil , .T. , lGrava )
	If ( aStruSD1 == Nil )
		aStruSD1 := {}
		dbSelectArea("SD1")
		aAux := dbStruct()
		For nCntFor := 1 To Len(aAux)
			If ( FieldName(nCntFor)$"D1_FILIAL#D1_DOC#D1_SERIE#D1_FORNECE#D1_LOJA" .Or.;
					FieldName(nCntFor)$"D1_NFORI#D1_SERIORI#D1_COD#D1_ITEMORI#D1_TOTAL#D1_VALDESC#D1_ITEM" )
				aadd(aStruSD1,{aAux[nCntFor,1],aAux[nCntFor,2],aAux[nCntFor,3],aAux[nCntFor,4]})
			EndIf
		Next nCntFor
	EndIf
	If ( aStruSD2 == Nil )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se os campos que gravam o valor do PIS/COFINS para  ³
		//³ abater da base conforme configurado                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If !Empty( nScanPis := aScan(aRelImp,{|x| x[1]=="SD2" .And. x[3]=="IT_VALPS2"} ) )
			cFieldPis  := aRelImp[nScanPis,2]
		EndIf

		If !Empty( nScanCof := aScan(aRelImp,{|x| x[1]=="SD2" .And. x[3]=="IT_VALCF2"} ) )
			cFieldCof := aRelImp[nScanCof,2]
		EndIf

		aStruSD2 := {}
		dbSelectArea("SD2")
		aAux := dbStruct()
		For nCntFor := 1 To Len(aAux)
			If ( FieldName(nCntFor)$cCposSD2 .Or.;
				FieldName(nCntFor)$cFieldPis .Or.;
				FieldName(nCntFor)$cFieldCof .Or.;
				"D2_COMIS"$FieldName(nCntFor) )
				aadd(aStruSD2,{aAux[nCntFor,1],aAux[nCntFor,2],aAux[nCntFor,3],aAux[nCntFor,4]})
			EndIf
		Next nCntFor
	EndIf
	If ( aStruSF4 == Nil )
		aStruSF4 := {}
		dbSelectArea("SF4")
		aAux := dbStruct()
		For nCntFor := 1 To Len(aAux)
			If ( FieldName(nCntFor)$"F4_DUPLIC#F4_INCIDE#F4_IPIFRET#F4_INCSOL#F4_ISS" )
				aadd(aStruSF4,{aAux[nCntFor,1],aAux[nCntFor,2],aAux[nCntFor,3],aAux[nCntFor,4]})
			EndIf
		Next nCntFor
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no Registro do SE1 a ser calculado                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE1")
	MsGoto(nRegistro)
	//Verifica se o cliente e responsavel pelo recolhimento do IR ou nao.
	If cPaisLoc == "BRA"

				dbSelectArea("SED")       
				SED->(dbSetOrder(1))
				
		dbSelectArea("SA1")
		SA1->(dbSetOrder(1))
				
		If SED->(dbSeek(xFilial("SED") + SED->ED_CODIGO ) ) .And. SED->ED_RECIRRF == "1"
			lRecIRRF := .T.
		ElseIf SA1->(dbSeek(xFilial("SA1")+SE1->(E1_CLIENTE+E1_LOJA))) .And. SA1->A1_RECIRRF == "1"
			lRecIRRF := .T.
		Endif
		
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o titulo foi gerado pelo faturamento e for neces-³
	//³ sario recalcular suas bases.                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( ( SE1->E1_TIPO $ MVNOTAFIS+cEspSes .OR.;
		(AllTrim(SE1->E1_ORIGEM) $ "LOJA701" .AND. !Empty(SE1->E1_NUMNOTA) .AND. !(IsInCallStack("LjGeraE5") .AND. IsInCallStack("FINA070")) ) ) .and.;
		(!lSF2460I .or.(lSF2460I .And. "MATA460"$SE1->E1_ORIGEM)) ) ; 
		.or. ( lIntGC .and. lFuncGC .and. OFIA291( "1" , SE1->(RecNo()) ) )
		For nCntFor := 1 To __nVend
			cVendedor := SE1->(FieldGet(SE1->(FieldPos("E1_VEND"+cVend))))
			nPerComis := SE1->(FieldGet(SE1->(FieldPos("E1_COMIS"+cVend))))
			If ( nPerComis == 0 .And. !Empty(cVendedor) )
				lRefaz := .T.
				Exit
			EndIf
			cVend := Soma1(cVend,1)
		Next nCntFor
	ElseIf	cPaisLoc <>"BRA" .and.( SE1->E1_TIPO $ MV_CRNEG+MVRECANT)
		lRefaz := .T.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona Registros                                          ³
	//³ Aqui se faz necessaria a cria‡Æo de tratamento de filial de  ³
	//³ origem para quando se tem SE1 compartilhado e SF2, SE4 ou SD2³
	//³ exclusivos                                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If "FINA630" $ SE1->E1_ORIGEM
		nRecSE1 := SE1->(Recno())
		If __nRecOrig > 0
			SE1->(DbGoTo(__nRecOrig))
		EndIf
	EndIf

	If SE1->(FieldPos("E1_MSFIL")) > 0
		If !Empty(SE1->E1_MSFIL) .and. !(Empty(cFilialSf1)) .And. cModeAcSE1=="C" .And. cModeAcSF1=="E" 
			cFilialSf1 := SE1->E1_MSFIL
		Endif
		If !Empty(SE1->E1_MSFIL) .and. !(Empty(cFilialSf2)) .And. cModeAcSE1=="C" .And. cModeAcSF2=="E" 
			cFilialSf2 := SE1->E1_MSFIL
		Endif
		If !Empty(SE1->E1_MSFIL) .and. !(Empty(cFilialSf4)) .And. cModeAcSE1=="C" .And. cModeAcSF4=="E" 
			cFilialSf4 := SE1->E1_MSFIL
		Endif
		If !Empty(SE1->E1_MSFIL) .and. !(Empty(cFilialSe4)) .And. cModeAcSE1=="C" .And. cModeAcSE4=="E" 
			cFilialSe4 := SE1->E1_MSFIL
		Endif
		If !Empty(SE1->E1_MSFIL) .and. !(Empty(cFilialSd1)) .And. cModeAcSE1=="C" .And. cModeAcSD1=="E" 
			cFilialSd1 := SE1->E1_MSFIL
		Endif
		If !Empty(SE1->E1_MSFIL) .and. !(Empty(cFilialSd2)) .And. cModeAcSE1=="C" .And. cModeAcSD2=="E" 
			cFilialSd2 := SE1->E1_MSFIL
		Endif
	Else
		If SE1->(FieldPos("E1_FILORIG")) > 0
			If !Empty(SE1->E1_FILORIG) .and. !(Empty(cFilialSf1)) .And. cModeAcSE1=="C" .And. cModeAcSF1=="E" 
				cFilialSf1 := SE1->E1_FILORIG
			Endif	
			If !Empty(SE1->E1_FILORIG) .and. !(Empty(cFilialSf2)) .And. cModeAcSE1=="C" .And. cModeAcSF2=="E" 
				cFilialSf2 := SE1->E1_FILORIG
			Endif
			If !Empty(SE1->E1_FILORIG) .and. !(Empty(cFilialSe4)) .And. cModeAcSE1=="C" .And. cModeAcSE4=="E" 
				cFilialSe4 := SE1->E1_FILORIG
			Endif
			If !Empty(SE1->E1_FILORIG) .and. !(Empty(cFilialSd1)) .And. cModeAcSE1=="C" .And. cModeAcSD1=="E" 
				cFilialSd1 := SE1->E1_FILORIG
			Endif	
			If !Empty(SE1->E1_FILORIG) .and. !(Empty(cFilialSd2)).And. cModeAcSE1=="C" .And. cModeAcSD2=="E" 
				cFilialSd2 := SE1->E1_FILORIG
			Endif
			If !Empty(SE1->E1_FILORIG) .and. !(Empty(cFilialSf4)) .And. cModeAcSE1=="C" .And. cModeAcSF4=="E" 
				cFilialSf4 := SE1->E1_FILORIG
			Endif
		Endif
	EndIf

	If lTransf .And. __nRecOrig > 0
		SE1->(DbGoTo(nRecSE1))
	EndIf

	If ( (SE1->E1_TIPO $ MVNOTAFIS+cEspSes .OR.;
		( AllTrim(SE1->E1_ORIGEM) $ "LOJA701" .AND. !Empty(SE1->E1_NUMNOTA) .AND. !(IsInCallStack("LjGeraE5") .AND. IsInCallStack("FINA070")) ) ) .And. lRefaz ) ;
		.or. ( lIntGC .and. lFuncGC .and. OFIA291( "1" , SE1->(RecNo()) ) )
		If Year(SE1->E1_EMISSAO)<2001
			cSerie := If(Empty(SE1->E1_SERIE),SE1->E1_PREFIXO,SE1->E1_SERIE)
		Else
			cSerie := SE1->E1_SERIE
		EndIf
		cSerie := PadR(cSerie,__nTmSeri)
		dbSelectArea("SF2")
		dbSetOrder(1)
		If (!MsSeek(cFilialSF2+SE1->E1_NUM+cSerie+SE1->E1_CLIENTE+SE1->E1_LOJA,.F.))

			If (IsInCallStack("LOJA720") .OR. IsInCallStack("LOJA140") ) .AND. (SF2->( dbSeek(cFilialSF2 + SE1->E1_NUMNOTA + cSerie) ))
				lContinua := .T.
				lVendaLoja := .T.
			ElseIf lVendaLoja
				SF2->(dbGoTo(nRegSF2))
				lContinua := .T.
			Else
				lContinua := .F.
			EndIf
		EndIf
		dbSelectArea("SE4")
		dbSetOrder(1)
		If (!MsSeek(cFilialSE4+SF2->F2_COND))
			lContinua := .F.
		EndIf
		dbSelectArea("SD2")
		dbSetOrder(3)
		SD2->(dbCommit())
		lQuery := .T.
		cAliasSD2 := "FA440COMIS"
		cAliasSF4 := "FA440COMIS"
		cQuery := ""
		For nCntFor := 1 To Len(aStruSD2)
			cQuery += ","+aStruSD2[nCntFor][1]
		Next nCntFor
		For nCntFor := 1 To Len(aStruSF4)
			cQuery += ","+aStruSF4[nCntFor][1]
		Next nCntFor

		cQuery += ","+"D2_ITEMPV"

		cQuery := "SELECT SD2.R_E_C_N_O_ SD2RECNO,"+SubStr(cQuery,2)
		cQuery += "  FROM "+RetSqlName("SD2")+" SD2,"+RetSqlName("SF4")+" SF4 "
		cQuery += " WHERE SD2.D2_FILIAL   = '"+cFilialSD2+"'"

		If lVendaLoja
			cQuery += "   AND SD2.D2_DOC	  = '" + SF2->F2_DOC + "'"
			cQuery += "   AND SD2.D2_SERIE	  = '" + SF2->F2_SERIE + "'"			
		Else
			cQuery += "   AND SD2.D2_DOC	  = '"+SE1->E1_NUM+"'"
			cQuery += "   AND SD2.D2_SERIE	  = '"+cSerie+"'"			
		EndIf

		If "LOJA" $ Upper(SE1->E1_ORIGEM)
			cQuery += "   AND SD2.D2_CLIENTE  = '"+SF2->F2_CLIENTE+"'" 
			cQuery += "   AND SD2.D2_LOJA     = '"+SF2->F2_LOJA+"'"
		Else 
			cQuery += "   AND SD2.D2_CLIENTE  = '"+SE1->E1_CLIENTE+"'" 
			cQuery += "   AND SD2.D2_LOJA     = '"+SE1->E1_LOJA+"'"	
		EndIf

		cQuery += "   AND SD2.D_E_L_E_T_ = ' ' "
		cQuery += "   AND SF4.F4_FILIAL	  ='"+cFilialSF4+"'"
		cQuery += "   AND SF4.F4_CODIGO   = SD2.D2_TES"
		cQuery += "   AND SF4.D_E_L_E_T_ = ' ' "
		cQuery += " ORDER BY "+SqlOrder(SD2->(IndexKey()))

		//cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD2)

		lContinua := !(cAliasSD2)->(Eof())
		For nCntFor := 1 To Len(aStruSD2)
			If ( aStruSD2[nCntFor][2]!= "C" )
				TcSetField(cAliasSD2,aStruSD2[nCntFor][1],aStruSD2[nCntFor][2],aStruSD2[nCntFor][3],aStruSD2[nCntFor][4])
			EndIf
		Next nCntFor
		For nCntFor := 1 To Len(aStruSF4)
			If ( aStruSF4[nCntFor][2]!="C" )
				TcSetField(cAliasSF4,aStruSF4[nCntFor][1],aStruSF4[nCntFor][2],aStruSD2[nCntFor][3],aStruSF4[nCntFor][4])
			EndIf
		Next nCntFor
		If ( lContinua )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calculo da comissao por item de nota fiscal                  ³
			//³                                                              ³
			//³1)O Valor do icms s/ frete e adiciona ao campo F2_VALICM, por ³
			//³esta razao deve-se somar o vlr do icms dos itens e subtrair   ³
			//³do total de icms (F2_VALICM) para apurar-se o vlr icms s/frete³
			//³                                                              ³
			//³2)O mesmo ocorre para o valor do IPI sobre frete, Por esta ra-³
			//³zao e' calculado o valor do IPI sobre frete do item multipli- ³
			//³cando-se o valor do frete do item pelo % de ipi do item.      ³
			//³                                                              ³
			//³3)O Valor do Icms Retido pode nÆo estar no total da nota (F2_-³
			//³VALBRUT) por isto deve-se considerar o campo (D2_ICMSRET).    ³
			//³                                                              ³
			//³4)O percentual da comissao dever ser considerado para cada i- ³
			//³tem de nota fiscal pois ela pode ser diferente entre eles. O  ³
			//³percentual gravado no E1_COMIS ‚ sempre um valor aproximado e ³
			//³nao deve ser considerado ser houver nota fiscal para o titulo.³
			//³                                                              ³
			//³5)A Base da Comissao ‚ o valor da mercadoria + o valor do ipi ³
			//³+ o valor das despesas acessorias +  o icms solidario. Como e'³
			//³por item deve-se conhece-lo pelo item a item.                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nTotal     := 0
			nFrete     := (SF2->F2_FRETE + SF2->F2_SEGURO + SF2->F2_DESPESA)
			nIcmFrete  := 0
			nSF2IcmRet :=0

			If !Empty( nScanPis := aScan(aRelImp,{|x| x[1]=="SD2" .And. x[3]=="IT_VALPS2"} ) )
				cFieldPis  := aRelImp[nScanPis,2]
			EndIf

			If !Empty( nScanCof := aScan(aRelImp,{|x| x[1]=="SD2" .And. x[3]=="IT_VALCF2"} ) )
				cFieldCof := aRelImp[nScanCof,2]
			EndIf

			If  lPccBxCr .and. !lCalEmis
				nPis		:= SE1->E1_PIS
				nCofins	:= SE1->E1_COFINS
				nCsll	:= SE1->E1_CSLL
			Endif

			If lIsCallCbr .and. cPaisLoc == "MEX"				 
				nPosTXM	:= Iif(!Type("aCposSE1") == "U",AScan(aCposSE1,"E1_TXMOEDA"),SE1->E1_TXMOEDA) 
			EndIf

			While !Eof() .And. (cAliasSD2)->D2_FILIAL == cFilialSD2 .And.;
					( (cAliasSD2)->D2_DOC == SE1->E1_NUM .And. (cAliasSD2)->D2_SERIE == cSerie .And. (cAliasSD2)->D2_CLIENTE  == SF2->F2_CLIENTE .And. (cAliasSD2)->D2_LOJA	 == SF2->F2_LOJA ) .OR.;
					( lVendaLoja .And. (cAliasSD2)->D2_DOC == SF2->F2_DOC .And. (cAliasSD2)->D2_SERIE == SF2->F2_SERIE 	.And. (cAliasSD2)->D2_CLIENTE  == SF2->F2_CLIENTE .And. (cAliasSD2)->D2_LOJA == SF2->F2_LOJA )

				If ( !lQuery )
					dbSelectArea("SF4")
					dbSetOrder(1)
					MsSeek(cFilialSF4+(cAliasSD2)->D2_TES)
				Else
					If cPaisLoc<>"BRA"
						SD2->(DbGoto((cAliasSD2)->SD2RECNO))
					Endif
				EndIf
				nRedIcms := 0
				
				If AllTrim(cEstado) == "MG" .And. cPaisLoc == "BRA"
					DbSelectArea("SFT")
					SFT->(DbSetOrder(1))
					If SFT->(DbSeek(xFilial("SFT")+'S'+(cAliasSD2)->(D2_SERIE+D2_DOC+D2_CLIENTE+D2_LOJA+PADR((cAliasSD2)->D2_ITEM, __nTmItem )+D2_COD)))
						nRedIcms := SFT->FT_DS43080
					EndIf
				EndIf
				
				//Essa chamada deve ficar fora do FOR por motivos de performance
				If cPaisLoc <> "BRA"
					aImp := TesImpInf((cAliasSD2)->D2_TES)
				EndIf

				cVend := "1"

				// Resgata o vendedor que foi informado no item na vendo do Loja
				If  FindFunction("Lj720VdItm") .AND. lMultVend .AND. (("LOJA" $ SE1->E1_ORIGEM) .OR. ("FATA701" $ SE1->E1_ORIGEM))
					cVendItLoj := Lj720VdItm((cAliasSD2)->D2_FILIAL,(cAliasSD2)->D2_DOC, (cAliasSD2)->D2_SERIE, (cAliasSD2)->D2_CLIENTE,;
											(cAliasSD2)->D2_LOJA,  (cAliasSD2)->D2_ITEMPV)
					__nVend := 1 // Se Vendedor por Item(SIGALOJA) não é necessário for com todas as posições
				EndIf

				For nCntFor := 1 To __nVend
					If lMultVend .AND. !Empty(cVendItLoj)
						cVendedor	:= cVendItLoj
					Else
						cVendedor := SF2->(FieldGet(SF2->(FieldPos("F2_VEND"+cVend))))
					EndIf					

					// Verifica se o vendedor foi informado no item na vendo do Loja
					// caso nao for, descontidera este vendedor 
					nPerComis := (cAliasSD2)->(FieldGet((cAliasSD2)->(FieldPos("D2_COMIS"+cVend))))

					nImp      := 0
					nDescImp  := 0
					If cPaisLoc <> "BRA"
						SA3->(DbSetOrder(1))
						SA3->(DbSeek(xFilial()+cVendedor))
						cImp := SA3->A3_COMIMP
						For nX :=1 to Len(aImp)
							If (cImp+aImp[nX][3] == "S1")
								nImp += SD2->(FieldGet(FieldPos(aImp[nX][2])))
							ElseIf (cImp+aImp[nX][3] == "N2")
								nImp -=	SD2->(FieldGet(FieldPos(aImp[nX][2])))
							EndIf
							If cPaisLoc == "PTG" .And. cImp+aImp[nX][13] == "N1"
								nImpComis -= SD2->(FieldGet(FieldPos(aImp[nX][2])))
							EndIf
						Next nX
					Else
						If cPaisLoc == "BRA"
							nDescImp -= (cAliasSD2)->D2_DESCICM
						EndIf
					EndIf
					If ( !Empty(cVendedor) .And. (cAliasSF4)->F4_DUPLIC == "S") .OR. (lVendaLoja .OR. IsInCallStack("LJGRVFIN"))
						aadd(aSD2Vend,{ cVendedor,;
							(cAliasSD2)->D2_TOTAL-nRedIcms+nImp+nDescImp,;
							IIf(cPaisLoc == "BRA", (cAliasSD2)->(D2_VALICM+D2_ICMSCOM+D2_DIFAL)+nDescImp+(cAliasSD2)->D2_VALISS, (cAliasSD2)->D2_VALICM+nDescImp),;
							(cAliasSD2)->D2_VALIPI,;
							(cAliasSD2)->D2_IPI,;
							(cAliasSF4)->F4_INCIDE,;
							(cAliasSF4)->F4_IPIFRET,;
							Iif(cPaisLoc<>"BRA".Or.(cAliasSF4)->F4_INCSOL=="N",0,(cAliasSD2)->D2_ICMSRET),;
							nPerComis,;
							(cAliasSD2)->D2_VALACRS,;
							If(lQuery,(cAliasSD2)->SD2RECNO,(cAliasSD2)->(RecNo())),;
							(cAliasSF4)->F4_ISS=="S",;
							cVend,;
							nPis,;
							nCofins,;
							Iif(!Empty(cFieldPis), (cAliasSD2)-> D2_VALIMP5,0) ,; // pis apuração
							Iif(!Empty(cFieldCof), (cAliasSD2)-> D2_VALIMP6,0) }) // cofins apuração
						If cPaisLoc == "PTG"
							Aadd(aSD2Vend[Len(aSD2Vend)],(cAliasSD2)->D2_TOTAL+nImpComis+nDescImp)
							Aadd(aSD2Vend[Len(aSD2Vend)],(cAliasSD2)->D2_ITEM)
						Else
							Aadd(aSD2Vend[Len(aSD2Vend)],(cAliasSD2)->D2_ITEM)
						EndIf
						nPosITEM := Len(aSD2Vend[Len(aSD2Vend)])
						If aScan(aVendPed, cVendedor) == 0	  // Monta um array com os vendedores para rateio do frete
							aadd(aVendPed, cVendedor)
						Endif
						//*****************************************************
						// Ajusta a base da comissao da nota para a Moeda 01  *
						//*****************************************************
						If cPaisLoc <> "BRA"
							If lIsCallCbr 
								If cPaisLoc == "MEX"
									aSD2Vend[Len(aSD2Vend),2] := xMoeda( aSD2Vend[Len(aSD2Vend),2] , SF2->F2_MOEDA , 1 , SF2->F2_EMISSAO , nDecimal ,IIf( SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA ,aLinMoed[SE1->E1_MOEDA][2]))
								Else 
									aSD2Vend[Len(aSD2Vend),2] := xMoeda( aSD2Vend[Len(aSD2Vend),2] , SF2->F2_MOEDA , 1 , SF2->F2_EMISSAO , nDecimal , aLinMoed[SE1->E1_MOEDA][2])
								EndIf
							Else
								aSD2Vend[Len(aSD2Vend),2]	:= 	xMoeda( aSD2Vend[Len(aSD2Vend),2] , SF2->F2_MOEDA , 1 , SF2->F2_EMISSAO , nDecimal , SF2->F2_TXMOEDA )
							EndIf
						EndIf
					EndIf
					cVend := Soma1(cVend,1)
				Next nCntFor

				If ( (cAliasSF4)->F4_ISS != "S" )
					nSF2IcmRet += Iif((cAliasSF4)->F4_INCSOL=="N",0,(cAliasSD2)->D2_ICMSRET)
					nIcmFrete  += (cAliasSD2)->D2_ICMFRET
				EndIf

				nTotal	  += (cAliasSD2)->D2_TOTAL-nRedIcms
				dbSelectArea(cAliasSD2)
				dbSkip()
			EndDo

			If ( lQuery )
				dbSelectArea(cAliasSD2)
				dbCloseArea()
				dbSelectArea("SD2")
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calculo da comissao pela nota.                               ³
			//³                                                              ³
			//³1)Apos calculado as bases de cada vendedor por item de nota   ³
			//³deve-se aglutina-las formando uma unica base para toda a nota ³
			//³fiscal.                                                       ³
			//³                                                              ³
			//³2)Como os valores serao aglutinados pode-se haver perda de de-³
			//³cimais por isto deve-se haver um controle para que a perda se-³
			//³ja adicionada a primeira parcela da nota.                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nMaxFor := Len(aSD2Vend)
			nPerComis:=0
			nFreteAux := 0
			For nCntFor := 1 To nMaxFor
				If (lPePercom)
					nPerComis := ExecBlock("FIN440PE",.F.,.F.,{aSD2Vend[nCntFor][1]})
					If ( ValType(nPerComis)<>"N" )
						nPerComis := aSD2Vend[nCntFor][9]
					Else
						aSD2Vend[nCntFor][9] := nPerComis
					EndIf
				Else
					nPerComis := aSD2Vend[nCntFor][9]
				EndIf
				If ( SE1->E1_PARCELA $ cPrimParc )
					nBaseDif  := NoRound(nFrete*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal+1)
					nBaseDif  := nFrete - nBaseDif
					// No ultimo item o valor do rateio do frete é o valor do frete menos o rateio do frete acumulado
					// ate o penultimo item (evitar diferenca de centavos na base da comissao (E1_BASCOM)
					If nCntFor == nMaxFor
					nRatFrete := (nFrete * If(Len(aVendPed) > 0, Len(aVendPed), 1)) - nFreteAux
					Else
						nFreteAux += nBaseDif
						nRatFrete := nBaseDif
					EndIf
				Else
					nRatFrete := NoRound(nFrete*aSD2Vend[nCntFor,2]/nTotal,nDecimal+1)
				EndIf
				If cPaisLoc == "BRA"
					If ( SE1->E1_PARCELA $ cPrimParc )
						nBaseDif  := NoRound(SF2->F2_VALINSS*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal+1)
						nBaseDif  := SF2->F2_VALINSS - nBaseDif
						nRatINSS  := nBaseDif
					Else
						nRatINSS := NoRound(SF2->F2_VALINSS*aSD2Vend[nCntFor,2]/nTotal,nDecimal+1)
					EndIf

					If  lPccBxCr .and. !lCalEmis
						If !(SE5->E5_PRETPIS	$	"1;2")
							nPis	:= SE5->E5_VRETPIS
						Else
							nPis	:=	0
						EndIf
						If !(SE5->E5_PRETCOF	$	"1;2")
							nCofins	:= SE5->E5_VRETCOF
						Else
							nCofins	:= 0
						EndIf
						If !(SE5->E5_PRETCSL	$	"1;2")
							nCsll	:= SE5->E5_VRETCSL
						Else
							nCsll	:=	0
						EndIf
						If ( SE1->E1_PARCELA $ cPrimParc )
							nBaseDif  := NoRound(SE1->E1_CSLL*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal)
							nBaseDif  := SE1->E1_CSLL - nBaseDif
							nRatCSL  := nBaseDif

							nBaseDif  := NoRound(SE1->E1_PIS*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal)
							nBaseDif  := SE1->E1_PIS - nBaseDif
							nRatPIS  := nBaseDif
							
							nBaseDif  := NoRound(SE1->E1_COFINS*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal)
							nBaseDif  := SE1->E1_COFINS - nBaseDif
							nRatCOF  := nBaseDif
						Else
							nRatCSL := NoRound(SE1->E1_CSLL*aSD2Vend[nCntFor,2]/nTotal,nDecimal)
							nRatPIS:= NoRound(SE1->E1_PIS*aSD2Vend[nCntFor,2]/nTotal,nDecimal)
							nRatCOF := NoRound(SE1->E1_COFINS*aSD2Vend[nCntFor,2]/nTotal,nDecimal)
						EndIf

					Elseif !lPccBxCr 

						If ( SE1->E1_PARCELA $ cPrimParc )
							nBaseDif  := NoRound(SF2->F2_VALCSLL*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal)
							nBaseDif  := SF2->F2_VALCSLL - nBaseDif
							nRatCSL  := nBaseDif
						Else
							nRatCSL := NoRound(SF2->F2_VALCSLL*aSD2Vend[nCntFor,2]/nTotal,nDecimal)
						EndIf

						If ( SE1->E1_PARCELA $ cPrimParc )
							nBaseDif  := NoRound(SF2->F2_VALPIS*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal)
							nBaseDif  := SF2->F2_VALPIS - nBaseDif
							nRatPIS  := nBaseDif
						Else
							nRatPIS := NoRound(SF2->F2_VALPIS*aSD2Vend[nCntFor,2]/nTotal,nDecimal)
						EndIf

						If ( SE1->E1_PARCELA $ cPrimParc )
							nBaseDif  := NoRound(SF2->F2_VALCOFI*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal)
							nBaseDif  := SF2->F2_VALCOFI - nBaseDif
							nRatCOF  := nBaseDif
						Else
							nRatCOF := NoRound(SF2->F2_VALCOFI*aSD2Vend[nCntFor,2]/nTotal,nDecimal)
						EndIf
					Endif

					
					If lIrPjBxCr .And. !lCalEmis
						If !(SE5->E5_PRETIRF	$"1;2")
							nIRRF	:= SE5->E5_VRETIRF
						Else
							nIRRF	:= 0
						EndIf
						If ( SE1->E1_PARCELA $ cPrimParc )
							nBaseDif  := NoRound(SE1->E1_IRRF*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal)
							nBaseDif  := SE1->E1_IRRF - nBaseDif
							nRatIRRF  := nBaseDif
						Else
							nRatIRRF := Round(SE1->E1_IRRF*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal)
						EndIf
					ElseIf !lIrPjBxCr
						If ( SE1->E1_PARCELA $ cPrimParc )
							nBaseDif  := NoRound(SF2->F2_VALIRRF*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal)
							nBaseDif  := SF2->F2_VALIRRF - nBaseDif
							nRatIRRF  := nBaseDif
							nRatIRRF := NoRound(SF2->F2_VALIRRF*aSD2Vend[nCntFor,2]/nTotal,nDecimal)
						Else
							nRatIRRF := NoRound(SF2->F2_VALIRRF*aSD2Vend[nCntFor,2]/nTotal,nDecimal)
						EndIf
					EndIf
					
				EndIf
				nRatIcmFre:= 0
				nBaseSE1  := 0
				nPos      := 0
				nRatIcmFre:= NoRound(nIcmFrete*aSD2Vend[nCntFor,2]/nTotal,nDecimal)
				nBaseSE1  := aSD2Vend[nCntFor,2] + IIf(SF2->F2_TIPO=='P', 0, aSD2Vend[nCntFor,4]) + aSD2Vend[nCntFor,8] + nRatFrete //soma-se IPI e ICM Retido
				dbSelectArea("SA3")
				dbSetOrder(1)
				MsSeek(xFilial("SA3")+aSD2Vend[nCntFor,1])
				lCOMISIR := IIf( cPaisLoc == "BRA" , SA3->A3_BASEIR == "1" , lCOMISIR )

				If SE1->(FieldPos("E1_ALEMIS"+aSD2Vend[nCntFor,13]))<>0 //Nao criar no dicionario padrao
					nAlEmissao := SE1->(FieldGet(FieldPos("E1_ALEMIS"+aSD2Vend[nCntFor,13])))
				Else
					nAlEmissao := SA3->A3_ALEMISS
				EndIf
				If SE1->(FieldPos("E1_ALBAIX"+aSD2Vend[nCntFor,13]))<>0 //Nao criar no dicionario padrao
					nAlBaixa := SE1->(FieldGet(FieldPos("E1_ALBAIX"+aSD2Vend[nCntFor,13])))
				Else
					nAlBaixa := SA3->A3_ALBAIXA
				EndIf

				If ( SA3->A3_FRETE == "N" )
					nBaseSE1 -=  nRatFrete
					nBaseSE1 +=  nRatIcmFre
				Endif

				If ( SA3->A3_IPI   == "N" )
					nBaseSE1 -= ( aSD2Vend[nCntFor,4] )
				EndIf

				If !aSD2Vend[nCntFor,12]
					If ( SA3->A3_ICM   == "N" )
						nBaseSE1 -= aSD2Vend[nCntFor,3] 
					EndIf
				Else
					If ( SA3->A3_ISS == "N" )
						//Se o valor do ISS calculado for inferior ao minimo de retencao (MV_VRETISS), nao descontar da base de comissao
						If nVRetISS < aSD2Vend[nCntFor,3]
							nBaseSE1 -= ( aSD2Vend[nCntFor,3] )
						Endif
					EndIf 
				EndIf  

				If ( SA3->A3_ICMSRET == "N" )
					nBaseSE1 -= ( aSD2Vend[nCntFor,8] )
				EndIf

				If ( SA3->A3_ACREFIN == "N" ) .and. aSD2Vend[nCntFor,10] > 0 .AND. !("LOJA" $ SE1->E1_ORIGEM)
					nBaseSE1 -= ( aSD2Vend[nCntFor,10] )
				EndIf

				If cPaisLoc == "BRA"
					Do Case
					Case SA3->A3_PISCOF == "2" //Abate Pis
						nBaseSE1 -=aSD2Vend[nCntFor,16]
					Case SA3->A3_PISCOF == "3" //Abate Cofins
						nBaseSE1 -=aSD2Vend[nCntFor,17]
					Case SA3->A3_PISCOF == "4" //Abate ambos
						nBaseSE1 -=aSD2Vend[nCntFor,16]
						nBaseSE1 -=aSD2Vend[nCntFor,17]
					EndCase
				EndIf

				If lCOMISIR .And. lRecIRRF
					nBaseSE1 -= nRatIRRF
				Endif
				If lCOMISIN
					nBaseSE1 -= nRatINSS
				EndIf
				
				If lCOMIPIS
					nBaseSE1 -= nRatPIS
				EndIf

				If lCOMICOF
					nBaseSE1 -= nRatCOF
				EndIf

				If lCOMICSL
					nBaseSE1 -= nRatCSL
				EndIf

				nPos := aScan(aBaseSE1,{|x| x[1] == aSD2Vend[nCntFor,1]})
				cVend := aSD2Vend[nCntFor,13]

				If Alltrim(SE1->E1_Hist) <> "VENDA EM DINHEIRO" .OR. AllTrim(SE1->E1_ORIGEM) == "LOJA701"
					nBaseBaix := Round(nBaseSE1*nAlBaixa/100,nDecimal+1)	 	// Base da Comissao na Baixa
				ELSE
					nBaseBaix:= 0
				Endif
				nBaseEmis := nBaseSE1-nBaseBaix                           		// Base da Comissao na Emissao
				If ( nAlEmissao==0 .AND.  Alltrim(SE1->E1_Hist) <> "VENDA EM DINHEIRO" )
					nBaseEmis := 0
				EndIf

				nVlrEmis  := nBaseEmis * aSD2Vend[nCntFor,9] / 100	// Valor da Comissao na Emissao
				nVlrBaix  := nBaseBaix*aSD2Vend[nCntFor,9]/100	// Valor da Comissao na Baixa

				If ( Empty(nRegDevol) .Or. nRegDevol == aSD2Vend[nCntFor,11] )
					If ( nPos == 0 ) .AND. Iif(IsInCallStack("LjGrvFin") .OR. IsInCallStack("LOJA720"), (nVlrEmis + nVlrBaix) > 0, .T.)
						aadd(aBaseSE1,{ aSD2Vend[nCntFor,1] ,;
							nBaseSE1  				,;
							nBaseEmis 				,;
							nBaseBaix 				,;
							nVlrEmis  				,;
							nVlrBaix				,;
							nPerComis				,;
							nPis					,;
							nCsll					,;
							nCofins					,;
							nIrrf					})
							If cPaisLoc == "PTG"
								Aadd(aBaseSE1[Len(aBaseSE1)],Round((aSD2Vend[nCntFor,18]*aSD2Vend[nCntFor,9]/100)*SA3->A3_ALEMISS/100,nDecimal))
								Aadd(aBaseSE1[Len(aBaseSE1)],aSD2Vend[nCntFor,18]*SA3->A3_ALEMISS/100)
							EndIf
					ElseIf !( IsInCallStack("LOJA720") .AND. lMultVend .AND. (("LOJA" $ SE1->E1_ORIGEM) .OR. ("FATA701" $ SE1->E1_ORIGEM)) ) .AND.;
							Iif(IsInCallStack("LjGrvFin") .OR. IsInCallStack("LOJA720"), (nVlrEmis + nVlrBaix) > 0, .T.)
						aBaseSE1[nPos,2] += nBaseSE1
						aBaseSE1[nPos,3] += nBaseEmis
						aBaseSE1[nPos,4] += nBaseBaix
						aBaseSE1[nPos,5] += nVlrEmis
						aBaseSE1[nPos,6] += nVlrBaix
						If aBaseSE1[nPos,7] == nPerComis
							aBaseSE1[nPos,7] := nPerComis
						Else
							aBaseSE1[nPos,7] := 0
						EndIf
					EndIf
				EndIf
			Next nCntFor
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calculo da comissao pelas parcelas.                          ³
			//³                                                              ³
			//³1)O SE3 ‚ gravado por parcela e nao pela nota. assim e'neces- ³
			//³ssario calcular a base da comissao para a parcela em questao. ³
			//³                                                              ³
			//³2)Aqui deve-se tomar o maximo cuidado com a Condi‡Æo de pagto ³
			//³pois se o Icms Solidario ou o Ipi for separado de alguma par- ³
			//³cela deve-se considera esta separacao para calcular-se a me-  ³
			//³lhor propor‡ao possivel para a base da parcela.               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lCalcParc
				nMaxFor := Len(aBaseSE1)
				For nCntFor := 1 To nMaxFor
					nProp   := 0
					If lIsCallCbr
						If cPaisLoc == "MEX"
							nVlrFat := xMoeda(SF2->F2_VALFAT,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,,IIF( SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA ,aLinMoed[SE1->E1_MOEDA][2]))
						Else
							nVlrFat := xMoeda(SF2->F2_VALFAT,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,,aLinMoed[SE1->E1_MOEDA][2])
						EndIf
					Else
						nVlrFat := xMoeda(SF2->F2_VALFAT,SE1->E1_MOEDA,1,Iif(!Empty(SF2->F2_DTTXREF),SF2->F2_DTTXREF,SE1->E1_EMISSAO) )
					EndIf			
					
					If lIsCallCbr
						If cPaisLoc == "MEX"
							nVlrTit := xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,,IIF( SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA ,aLinMoed[SE1->E1_MOEDA][2]))
						Else					
							nVlrTit := xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,,aLinMoed[SE1->E1_MOEDA][2])
						EndIf
					Else                     
						nVlrTit := SE1->E1_VLCRUZ
					EndIf
					nCntForOld := nCntFor
					cLastVend := aBaseSE1[nCntFor,1]
					cLastItem := ""
					dbSelectArea("SA3")
					dbSetOrder(1)
					MsSeek(xFilial("SA3")+aBaseSE1[nCntFor,1])
					For nCntFor :=1 To Len(aSD2Vend)
						If cLastVend == aSD2Vend[nCntFor,1] .And. cLastItem != aSD2Vend[nCntFor,nPosITEM]
							If ( SA3->A3_IPI == "N" .Or. SA3->A3_ICMSRET == "N" )
								If ( (SE4->E4_IPI == "S" .And. SF2->F2_VALIPI <> 0) .Or. ( SE4->E4_SOLID=="S" .And. SF2->F2_ICMSRET <> 0 .And. aSD2Vend[nCntFor,08] <> 0 ) ) .And. (SE1->E1_PARCELA $ cPrimParc)
									If !Empty(SE1->E1_PARCELA)
										nVlrTit := 0
										nVlrFat := 0
									EndIf
								EndIf
								If ( (SE4->E4_IPI == "S" .Or. SE4->E4_SOLID == "S") .And. !(SE1->E1_PARCELA $ cPrimParc))
									If SE1->E1_PARCELA $ cSegParc .OR. (SE1->E1_PARCELA > cSegParc .And. SE4->E4_SOLID == "S" .And. SE4->E4_IPI $ "N ")
										If SE4->E4_IPI == "S" 
											nVlrFat -= aSD2Vend[nCntFor,04]
											If SE4->E4_SOLID == "J"  .And. !(SE4->E4_IPI == "S")
												nVlrFat	-= aSD2Vend[nCntFor,08]
											EndIf
										EndIf
										If SE4->E4_SOLID == "S" .Or. (SE4->E4_IPI == "S" .And. SE4->E4_SOLID == "J")
											nVlrFat -= aSD2Vend[nCntFor,08]
											If SE4->E4_IPI == "J" .And. !(SE4->E4_SOLID == "S")
												nVlrFat	-= aSD2Vend[nCntFor,04]
											EndIf
										EndIf
									ElseIf SE4->E4_IPI == "S" .And. SE4->E4_SOLID == "S"
										nVlrFat -= aSD2Vend[nCntFor,04]
										nVlrFat -= aSD2Vend[nCntFor,08]
									ElseIf SE4->E4_IPI == "S" .And. SE4->E4_SOLID $ "N "
										If SA3->A3_IPI == "N"
											nVlrFat	-= aSD2Vend[nCntFor,04]
										EndIf
									ElseIf SE4->E4_IPI == "J" .And. SE4->E4_SOLID == "S"
										If SA3->A3_ICMSRET == "N"
											nVlrFat -= aSD2Vend[nCntFor,08]
										EndIf
									EndIf
								EndIf
								If ( SE4->E4_IPI == "J" .And. SE1->E1_PARCELA $ cPrimParc ) 
									If SA3->A3_IPI == "N" //Se for primeira parcela do título e vendedor estiver para não pagar comissão sob IPI, retira o valor de IPI da base.
										nVlrFat	-= aSD2Vend[nCntFor,04]
										nVlrTit	-= aSD2Vend[nCntFor,04]
									EndIf
								ElseIf ( SE4->E4_IPI == "J" .And. !(SE1->E1_PARCELA $ cPrimParc) )
									If SA3->A3_IPI == "N"
										nVlrFat	-= aSD2Vend[nCntFor,04]
									EndIf
								EndIf
								If ( SE4->E4_SOLID == "J" .And. SE1->E1_PARCELA $ cPrimParc  .And. !(SE4->E4_IPI == "S"))
									nVlrFat -= aSD2Vend[nCntFor,08]
									nVlrTit -= aSD2Vend[nCntFor,08]
								EndIf
								If ( SE4->E4_SOLID == "J" .And. !(SE1->E1_PARCELA $ cPrimParc) .And. !(SE4->E4_IPI == "S")) 
									nVlrFat -= aSD2Vend[nCntFor,08]
									If SE4->E4_IPI == "S"
										nVlrFat	-= aSD2Vend[nCntFor,04]
									EndIf
								EndIf
							EndIf
							cLastItem := aSD2Vend[nCntFor,nPosITEM]
						EndIf
					Next nCntFor
					nCntFor := nCntForOld
					If ( nVlrTit > 0 )
						nProp := nVlrFat / nVlrTit
					Else
						nProp := 0
					EndIf

					If (nVlrFat < nVlrTit .AND. lVendaLoja .AND. "LOJA" $ SE1->E1_ORIGEM) .OR. IsInCallStack("LOJA720")
						nBaseSE1 := aBaseSE1[nCntFor,2]						
						nBaseEmis:= aBaseSE1[nCntFor,3]
						nBaseBaix:= aBaseSE1[nCntFor,4]
						nVlrEmis := aBaseSE1[nCntFor,5]
						nVlrBaix := aBaseSE1[nCntFor,6]
						nProp := 1
					ElseIf (nProp != 0 )
						nBaseSE1 := aBaseSE1[nCntFor,2]/nProp
						nBaseEmis:= aBaseSE1[nCntFor,3]/nProp
						nBaseBaix:= aBaseSE1[nCntFor,4]/nProp
						nVlrEmis := aBaseSE1[nCntFor,5]/nProp
						nVlrBaix := aBaseSE1[nCntFor,6]/nProp
					Else
						nBaseSE1 := 0
						nBaseEmis:= 0
						nBaseBaix:= 0
						nVlrEmis := 0
						nVlrBaix := 0
					EndIf
					If ( SE1->E1_PARCELA $ cPrimParc .And. nBaseSE1 != 0 )
						//--> Calculo da Proporcao para a Base da Comissao
						nBaseDif := Round(nBaseSE1 * nProp,nDecimal+1)
						nBaseDif := aBaseSE1[nCntFor,2]-nBaseDif
						aBaseSE1[nCntFor,2] := nBaseSE1+nBaseDif

						//--> Calculo da Proporcao para a Base da Comissao pela Emissao
						nBaseDif := Round(nBaseEmis * nProp,nDecimal+1)
						nBaseDif := aBaseSE1[nCntFor,3]-nBaseDif
						aBaseSE1[nCntFor,3] := nBaseEmis+nBaseDif
						If cPaisLoc == "PTG"
							aBaseSE1[nCntFor,12] := NoRound(aBaseSE1[nCntFor,12]/nProp,nDecimal+1)
						EndIf

						//--> Calculo da Proporcao para a Base da Comissao pela Baixa
						nBaseDif := Round(nBaseBaix * nProp,nDecimal+1)
						nBaseDif := aBaseSE1[nCntFor,4]-nBaseDif
						aBaseSE1[nCntFor,4] := nBaseBaix+nBaseDif

						//--> Calculo da Proporcao para o Valor da Comissao pela Emissao
						nBaseDif := Round(nVlrEmis * nProp,nDecimal+1)
						nBaseDif := aBaseSE1[nCntFor,5]-nBaseDif
						aBaseSE1[nCntFor,5] := nVlrEmis+nBaseDif
						If cPaisLoc == "PTG"
							aBaseSE1[nCntFor,11] := Round(aBaseSE1[nCntFor,11]/nProp,nDecimal+1)
						EndIf

						//--> Calculo da Proporcao para o Valor da Comissao pela Baixa
						nBaseDif := Round(nVlrBaix * nProp,nDecimal+1)
						nBaseDif := aBaseSE1[nCntFor,6]-nBaseDif
						aBaseSE1[nCntFor,6] := nVlrBaix+nBaseDif
					Else
						aBaseSE1[nCntFor,2] := nBaseSE1
						aBaseSE1[nCntFor,3] := nBaseEmis
						aBaseSE1[nCntFor,4] := nBaseBaix
						aBaseSE1[nCntFor,5] := nVlrEmis
						aBaseSE1[nCntFor,6] := nVlrBaix
						If cPaisLoc == "PTG"
							aBaseSE1[nCntFor,12] := NoRound(aBaseSE1[nCntFor,12]/nProp,nDecimal+1)
							aBaseSE1[nCntFor,11] := Round(aBaseSE1[nCntFor,11]/nProp,nDecimal+1)
						EndIf
					EndIf
					
					//--> Calculo da Proporcao para o Percentual de Comissao pela Baixa
					If aBaseSE1[nCntFor,7] == 0
						aBaseSE1[nCntFor,7] := (aBaseSE1[nCntFor,6]*100)/aBaseSE1[nCntFor,4]
					EndIf
				Next nCntFor
			EndIf
		Else
			If ( lQuery .And. Select(cAliasSD2)<>0 )
				dbSelectArea(cAliasSD2)
				dbCloseArea()
				dbSelectArea("SE1")
			EndIf
		EndIf
	EndIf
	If ( SE1->E1_TIPO $ MV_CRNEG ) .And. !("FINA040" $ SE1->E1_ORIGEM)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica a filial de origem das notas de devolucao de Venda  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If !Empty(SE1->E1_FILORIG) .and. !(Empty(cFilialSF1)) .And. cModeAcSE1=="C" .And. cModeAcSF1=="E"
			cFilialSF1 := SE1->E1_FILORIG
		Endif
		If !Empty(SE1->E1_FILORIG) .and. !(Empty(cFilialSD1)) .And. cModeAcSE1=="C" .And. cModeAcSD1=="E"
			cFilialSD1 := SE1->E1_FILORIG
		Endif

		If Year(SE1->E1_EMISSAO)<2001
			cSerie := If(Empty(SE1->E1_SERIE),SE1->E1_PREFIXO,SE1->E1_SERIE)
		Else
			cSerie := SE1->E1_SERIE
		EndIf
		cSerie := PadR(cSerie,__nTmSeri)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona Registros                                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SF1")
		dbSetOrder(1)
		If (!MsSeek(cFilialSF1+SE1->E1_NUM+cSerie+SE1->E1_CLIENTE+SE1->E1_LOJA,.F.))
			lContinua := .F.
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo do Estorno da Comissao.                              ³
		//³                                                              ³
		//³1) Localiza-se a Nota Original                                ³
		//³                                                              ³
		//³2) Calcula a Comissao para a Nota Original                    ³
		//³                                                              ³
		//³3) Faz a Proporcao entre os valor da Mercadoria e os valores  ³
		//³   da comissao.                                               ³
		//³                                                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SD1")
		dbSetOrder(1)
		SD1->(dbCommit())
		cAliasSD1 := "BFA440COMIS"
		lQuery := .T.
		cQuery := ""
		For nCntFor := 1 To Len(aStruSD1)
			cQuery += ","+aStruSD1[nCntFor][1]
		Next nCntFor

		cQuery := "SELECT "+SubStr(cQuery,2)
		cQuery += "  FROM "+RetSqlName("SD1")+" SD1 "
		cQuery += " WHERE SD1.D1_FILIAL  = '"+cFilialSD1+"'"
		cQuery += "   AND SD1.D1_DOC	 = '"+SE1->E1_NUM+"'"
		cQuery += "   AND SD1.D1_SERIE	 = '"+cSerie+"'"
		cQuery += "   AND SD1.D1_FORNECE = '"+SE1->E1_CLIENTE+"'"
		cQuery += "   AND SD1.D1_LOJA    = '"+SE1->E1_LOJA+"'"
		cQuery += "   AND "
		If cPaisLoc<>"BRA"
			cQuery += "SD1.D_E_L_E_T_ = ' ' "
		Else
			cQuery += "    SD1.D_E_L_E_T_ = ' ' "
			cQuery += "AND SD1.D1_ITEMORI<>'"+Space(Len(SD1->D1_ITEMORI))+"' "
		EndIF
		cQuery += "ORDER BY "+SqlOrder(SD1->(IndexKey()))

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD1,.T.,.T.)

		lContinua := !(cAliasSD1)->(Eof())
		For nCntFor := 1 To Len(aStruSD1)
			If ( aStruSD1[nCntFor][2]!="C" )
				TcSetField(cAliasSD1,aStruSD1[nCntFor][1],aStruSD1[nCntFor][2],aStruSD1[nCntFor][3],aStruSD1[nCntFor][4])
			EndIf
		Next nCntFor

		aSemNota	:=	{}
		While ( !Eof() .And. cFilialSD1  == (cAliasSD1)->D1_FILIAL  .And.;
				SF1->F1_DOC 	 == (cAliasSD1)->D1_DOC	  .And.;
				SF1->F1_SERIE	 == (cAliasSD1)->D1_SERIE   .And.;
				SF1->F1_FORNECE == (cAliasSD1)->D1_FORNECE .And.;
				SF1->F1_LOJA	 == (cAliasSD1)->D1_LOJA )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Localiza a Nota de Saida - Item                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SD2")
			dbSetOrder(3)
			MsSeek(cFilialSD2+(cAliasSD1)->D1_NFORI+(cAliasSD1)->D1_SERIORI+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD+AllTrim((cAliasSD1)->D1_ITEMORI))
			If !SD2->(FOUND())
				//Carrega os items que nao tem nota original
				AAdd(aSemNota,(cAliasSD1)->D1_ITEM)
			Endif
			aBaseSD1 := {} // Inicializa Bases do Item
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no Nota Fiscal de Saida - Cabecalho                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SF2")
			dbSetOrder(1)
			MsSeek(cFilialSF2+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA)
			If Empty(SF2->F2_PREFIXO)
				cPrefixo := Alltrim(Posicione("SX6",1,cFilialSF2+"MV_1DUPREF","X6_CONTEUD"))
				If Empty(cPrefixo) //Caso não exista o parametro na filial posicionada, pega o coteudo (GetMv)
					cPrefixo := &(c1DUPREF)
				EndIf
			Else
				cPrefixo := SF2->F2_PREFIXO
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no Titulo Financeiro                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SE1")
			dbSetOrder(2)
			lVendaLoja 	:= .F.	
			lPedLoja	:= .F.
				
			If lChkLoj .AND. !Empty(SD2->D2_PEDIDO)
				lPedLoja := Lj720CkLoj(xFilial("SC5"),SD2->D2_PEDIDO)
			Endif

			// Caso for venda com origem do Loja, a SE1 pode estar atrelada ao orçamento (SL1) e nao a Nota
			If FindFunction("Lj720LocE1") .And. (IsInCallStack("LOJA720") .OR. IsInCallStack("LOJA140") .OR. Upper(AllTrim(SD2->D2_ORIGLAN)) == "LO" .OR. lPedLoja)
				// Localiza título de venda do Loja, onde pode haver títulos que ficam em nome da Adm. Financeira e nao em nome do cliente
				cAliasTtLj := Lj720LocE1(cFilialSE1, cPrefixo)
				lVendaLoja := .T.
			Else
				MsSeek(cFilialSE1+SF2->F2_CLIENTE+SF2->F2_LOJA+cPrefixo+SD2->D2_DOC)
			EndIf			

			/*
			|| Tratamento para vendas do Loja, pois podem ter varios tipos de Formas de Pagamento
			|| em uma unica venda, com Adm. Financeiras diferentes, com isso o cliente e loja do 
			|| título podem mudar
			*/
			If lVendaLoja
				While (cAliasTtLj)->(!EOF())
							// Calcula o Valor da Comissao para a Parcela
					aBaseNCC := Fa440Comis( (cAliasTtLj)->E1RECNO,.F.,.T., SD2->(RecNo()), Nil, NIl, lVendaLoja, SF2->(Recno()) )
					For nCntFor := 1 To Len(aBaseNCC)
						cVendedor := aBaseNCC[nCntFor,1]
						nPos := aScan(aBaseSD1,{|x| x[1]==cVendedor})
						If ( nPos == 0 )
							aadd(aBaseSD1,{ 	aBaseNCC[nCntFor,1],;
								aBaseNCC[nCntFor,2],;
								aBaseNCC[nCntFor,3],;
								aBaseNCC[nCntFor,4],;
								aBaseNCC[nCntFor,5],;
								aBaseNCC[nCntFor,6],;
								aBaseNCC[nCntFor,7]})
							If lVendaLoja
								Aadd(aBaseSD1[nCntFor],(cAliasSD1)->D1_ITEMORI)							
							EndIf	
						Else
							If lVendaLoja
								nPos := aScan(aBaseSD1,{|x| x[Len(aBaseSD1[nCntFor])]==(cAliasSD1)->D1_ITEMORI})
								If ( nPos == 0 )							
									aBaseSD1[nPos,2] += aBaseNCC[nCntFor,2]
									aBaseSD1[nPos,3] += aBaseNCC[nCntFor,3]
									aBaseSD1[nPos,4] += aBaseNCC[nCntFor,4]
									aBaseSD1[nPos,5] += aBaseNCC[nCntFor,5]
									aBaseSD1[nPos,6] += aBaseNCC[nCntFor,6]
								EndIf
							Else		
								aBaseSD1[nPos,2] += aBaseNCC[nCntFor,2]
								aBaseSD1[nPos,3] += aBaseNCC[nCntFor,3]
								aBaseSD1[nPos,4] += aBaseNCC[nCntFor,4]
								aBaseSD1[nPos,5] += aBaseNCC[nCntFor,5]
								aBaseSD1[nPos,6] += aBaseNCC[nCntFor,6]							
							EndIf	
						EndIf
					Next nCntFor
					(cAliasTtLj)->( dbSkip() )
				EndDo

				If Select(cAliasTtLj) > 0
					dbSelectArea(cAliasTtLj)
					(cAliasTtLj)->(dbCloseArea())
				EndIf

				dbSelectArea("SE1")
			Else
				While ( !Eof() .And. cFilialSE1  == SE1->E1_FILIAL .And.;
						SE1->E1_CLIENTE == SF2->F2_CLIENTE .And.;
						SE1->E1_LOJA    == SF2->F2_LOJA .And.;
						SE1->E1_PREFIXO == cPrefixo .And.;
						SE1->E1_NUM		 == SF2->F2_DOC )
					If ( SE1->E1_TIPO $ MVNOTAFIS+cEspSes ) ;
						.or. ( lIntGC .and. lFuncGC .and. OFIA291( "1" , SE1->(RecNo()) ) )
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Calcula o Valor da Comissao para a Parcela                   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						aBaseNCC := Fa440Comis(SE1->(Recno()),.F.,.T.,SD2->(RecNo()))
						For nCntFor := 1 To Len(aBaseNCC)
							cVendedor := aBaseNCC[nCntFor,1]
							nPos := aScan(aBaseSD1,{|x| x[1]==cVendedor})
							If ( nPos == 0 )
								aadd(aBaseSD1,{ 	aBaseNCC[nCntFor,1],;
									aBaseNCC[nCntFor,2],;
									aBaseNCC[nCntFor,3],;
									aBaseNCC[nCntFor,4],;
									aBaseNCC[nCntFor,5],;
									aBaseNCC[nCntFor,6],;
									aBaseNCC[nCntFor,7]})
							Else
								aBaseSD1[nPos,2] += aBaseNCC[nCntFor,2]
								aBaseSD1[nPos,3] += aBaseNCC[nCntFor,3]
								aBaseSD1[nPos,4] += aBaseNCC[nCntFor,4]
								aBaseSD1[nPos,5] += aBaseNCC[nCntFor,5]
								aBaseSD1[nPos,6] += aBaseNCC[nCntFor,6]
							EndIf
						Next nCntFor
					EndIf
					dbSelectArea("SE1")
					dbSkip()
				EndDo
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Aqui eh proporcionalizado as Bases da nota de saida com o item devol.  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nCntFor := 1 To Len(aBaseSD1)
				aBaseSD1[nCntFor,2] := NoRound(aBaseSD1[nCntFor,2]*((cAliasSD1)->D1_TOTAL-(cAliasSD1)->D1_VALDESC)/SD2->D2_TOTAL,nDecimal+1)
				aBaseSD1[nCntFor,3] := Round(aBaseSD1[nCntFor,3]*((cAliasSD1)->D1_TOTAL-(cAliasSD1)->D1_VALDESC)/SD2->D2_TOTAL,nDecimal+1)
				aBaseSD1[nCntFor,4] := NoRound(aBaseSD1[nCntFor,4]*((cAliasSD1)->D1_TOTAL-(cAliasSD1)->D1_VALDESC)/SD2->D2_TOTAL,nDecimal+1)
				aBaseSD1[nCntFor,5] := (aBaseSD1[nCntFor,5]*((cAliasSD1)->D1_TOTAL-(cAliasSD1)->D1_VALDESC)/SD2->D2_TOTAL)
				aBaseSD1[nCntFor,6] := NoRound(aBaseSD1[nCntFor,6]*((cAliasSD1)->D1_TOTAL-(cAliasSD1)->D1_VALDESC)/SD2->D2_TOTAL,nDecimal+1)
			Next nCntFor
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Aqui eh somado as bases ja calculadas e como a NCC estorna os valores   ³
			//³na emissao, adiciona-se a base da baixa na base da emissao.             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nCntFor := 1 To Len(aBaseSD1)
				cVendedor := aBaseSD1[nCntFor,1]
				nPos := aScan(aBAseSE1,{|x| x[1] == cVendedor })
				If ( nPos == 0 )
					aadd(aBaseSE1,{ aBaseSD1[nCntFor,1],;
					aBaseSD1[nCntFor,2],;
					aBaseSD1[nCntFor,3]+aBaseSD1[nCntFor,4],0,;
					aBaseSD1[nCntFor,5]+aBaseSD1[nCntFor,6],0,0,;
					0,;
					0,;
					0,;
					0})
				Else
					aBaseSE1[nPos,2] += aBaseSD1[nCntFor,2]
					aBaseSE1[nPos,3] += aBaseSD1[nCntFor,3]+aBaseSD1[nCntFor,4]
					aBaseSE1[nPos,5] += aBaseSD1[nCntFor,5]+aBaseSD1[nCntFor,6]
				EndIf
			Next nCntFor
			dbSelectArea(cAliasSD1)
			dbSkip()
		EndDo
		If ( (Empty(aBaseSE1).Or. Len(aSemNota) > 0) .And. lRefaz .And. cPaisLoc<>"BRA")
			dbSelectArea("SE1")
			MsGoto(nRegistro)
			cSerie := If(Empty(SE1->E1_SERIE),SE1->E1_PREFIXO,SE1->E1_SERIE)
			cSerie := PadR(cSerie,__nTmSeri)
			dbSelectArea("SF1")
			dbSetOrder(1)
			If (!MsSeek(cFilialSF1+SE1->E1_NUM+cSerie+SE1->E1_CLIENTE+SE1->E1_LOJA,.F.))
				lContinua := .F.
			EndIf
			dbSelectArea("SE4")
			dbSetOrder(1)
			If (!MsSeek(cFilialSE4+SF1->F1_COND))
				lContinua := .F.
			EndIf
			dbSelectArea("SD1")
			dbSetOrder(1)
			lQuery := .T.
			cAliasDev := "FA440COMIS"
			cAliasSF4 := "FA440COMIS"
			cQuery := ""
			For nCntFor := 1 To Len(aStruSD1)
				cQuery += ","+aStruSD1[nCntFor][1]
			Next nCntFor
			For nCntFor := 1 To Len(aStruSF4)
				cQuery += ","+aStruSF4[nCntFor][1]
			Next nCntFor

			cQuery := "SELECT SD1.R_E_C_N_O_ SD1RECNO,"+SubStr(cQuery,2)
			cQuery += "  FROM "+RetSqlName("SD1")+" SD1,"+RetSqlName("SF4")+" SF4 "
			cQuery += " WHERE SD1.D1_FILIAL   = '"+cFilialSD1+"'"
			cQuery += "   AND SD1.D1_DOC      = '"+SE1->E1_NUM+"'"
			cQuery += "   AND SD1.D1_SERIE    = '"+cSerie+"'"
			cQuery += "   AND SD1.D1_FORNECE  = '"+SE1->E1_CLIENTE+"'"
			cQuery += "   AND SD1.D1_LOJA	  = '"+SE1->E1_LOJA+"'"
			cQuery += "   AND SD1.D_E_L_E_T_  = ' '"
			cQuery += "   AND SF4.F4_FILIAL   = '"+cFilialSF4+"'"
			cQuery += "   AND SF4.F4_CODIGO   = SD1.D1_TES"
			cQuery += "   AND SF4.D_E_L_E_T_  = ' ' "
			cQuery += "ORDER BY "+SqlOrder(SD1->(IndexKey()))

			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasDev)

			lContinua := !(cAliasDev)->(Eof())
			For nCntFor := 1 To Len(aStruSD1)
				If ( aStruSD1[nCntFor][2]!= "C" )
					TcSetField(cAliasDev,aStruSD1[nCntFor][1],aStruSD1[nCntFor][2],aStruSD1[nCntFor][3],aStruSD1[nCntFor][4])
				EndIf
			Next nCntFor
			For nCntFor := 1 To Len(aStruSF4)
				If ( aStruSF4[nCntFor][2]!="C" )
					TcSetField(cAliasSF4,aStruSF4[nCntFor][1],aStruSF4[nCntFor][2],aStruSD1[nCntFor][3],aStruSF4[nCntFor][4])
				EndIf
			Next nCntFor

			If ( lContinua )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calculo da comissao por item de nota fiscal 			     ³
				//³																 ³
				//³1)O Valor do icms s/ frete e adiciona ao campo F2_VALICM, por ³
				//³esta razao deve-se somar o vlr do icms dos itens e subtrair   ³
				//³do total de icms (F2_VALICM) para apurar-se o vlr icms s/frete³
				//³																 ³
				//³2)O mesmo ocorre para o valor do IPI sobre frete, Por esta ra-³
				//³zao e' calculado o valor do IPI sobre frete do item multipli- ³
				//³cando-se o valor do frete do item pelo % de ipi do item. 	 ³
				//³																 ³
				//³3)O Valor do Icms Retido pode nÆo estar no total da nota (F2_-³
				//³VALBRUT) por isto deve-se considerar o campo (D2_ICMSRET).	 ³
				//³																 ³
				//³4)O percentual da comissao dever ser considerado para cada i- ³
				//³tem de nota fiscal pois ela pode ser diferente entre eles. O  ³
				//³percentual gravado no E1_COMIS ‚ sempre um valor aproximado e ³
				//³nao deve ser considerado ser houver nota fiscal para o titulo.³
				//³																 ³
				//³5)A Base da Comissao ‚ o valor da mercadoria + o valor do ipi ³
				//³+ o valor das despesas acessorias +  o icms solidario. Como e'³
				//³por item deve-se conhece-lo pelo item a item.				 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nTotal	  := 0
				nFrete	  := (SF1->F1_FRETE + SF1->F1_SEGURO + SF1->F1_DESPESA)
				nIcmFrete  := 0
				nSF2IcmRet :=0
				While ( !Eof() .And. (cAliasDev)->D1_FILIAL == cFilialSD1 .And.;
						(cAliasDev)->D1_DOC 	 == SE1->E1_NUM .And.;
						(cAliasDev)->D1_SERIE	 == cSerie .And.;
						(cAliasDev)->D1_FORNECE  == SE1->E1_CLIENTE .And.;
						(cAliasDev)->D1_LOJA	 == SE1->E1_LOJA	)

					If Ascan(aSemNota,(cAliasDev)->D1_ITEM) ==0
						(cAliasDev)->(DbSkip())
						Loop
					EndIf

					If ( !lQuery )
						dbSelectArea("SF4")
						dbSetOrder(1)
						MsSeek(cFilialSF4+(cAliasDev)->D1_TES)
					Else
						If cPaisLoc<>"BRA"
							SD1->(DbGoto((cAliasDev)->SD1RECNO))
						Endif
					EndIf
					cVend := "1"

					cVendedor := SF1->F1_VEND1

					nImp := 0
					If cPaisLoc <> "BRA"
						SA3->(DbSetOrder(1))
						SA3->(DbSeek(xFilial()+cVendedor))
						aImp := TesImpInf(SD1->D1_TES)
						cImp := IIF( cPaisLoc <> "BRA" ,SA3->A3_COMIMP,"N")
						nPerComis := SA3->A3_COMIS
						For nX :=1 to Len(aImp)
							If (cImp+aImp[nX][3] == "S1")
								nImp += SD1->(FieldGet(FieldPos(aImp[nX][2])))
							ElseIf (cImp+aImp[nX][3] == "N2")
								nImp -= SD1->(FieldGet(FieldPos(aImp[nX][2]))	)
							Endif
						Next
					EndIf

					If ( !Empty(cVendedor) .And. (cAliasSF4)->F4_DUPLIC == "S" )
						If (cAliasDev)->(FieldPos("D1_COMIS"+cVend)) > 0 .And.;
							(cAliasDev)->(FieldGet((cAliasDev)->(FieldPos("D1_COMIS"+cVend)))) > 0
							nPerComis := (cAliasDev)->(FieldGet((cAliasDev)->(FieldPos("D1_COMIS"+cVend))))
						Endif
						aadd(aSD2Vend,{ cVendedor,;
							(cAliasDev)->D1_TOTAL+nImp,;
							0,;
							0,;
							0,;
							(cAliasSF4)->F4_INCIDE,;
							(cAliasSF4)->F4_IPIFRET,;
							0,;
							nPerComis,;
							0,;
							If(lQuery,(cAliasDev)->SD1RECNO,(cAliasDev)->(RecNo()))})
					EndIf

					nTotal	  += (cAliasDev)->D1_TOTAL
					dbSelectArea(cAliasDev)
					dbSkip()
				EndDo
				If ( lQuery )
					dbSelectArea(cAliasDev)
					dbCloseArea()
					dbSelectArea("SD1")
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calculo da comissao pela nota.							     ³
				//³																 ³
				//³1)Apos calculado as bases de cada vendedor por item de nota   ³
				//³deve-se aglutina-las formando uma unica base para toda a nota ³
				//³fiscal.														 ³
				//³																 ³
				//³2)Como os valores serao aglutinados pode-se haver perda de de-³
				//³cimais por isto deve-se haver um controle para que a perda se-³
				//³ja adicionada a primeira parcela da nota. 					 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nMaxFor := Len(aSD2Vend)
				If Funname() <> "FINA846" 
					nPerComis := 0
				Endif
				For nCntFor := 1 To nMaxFor
					If ( lPeperCom )
						nPerComis := ExecBlock("FIN440PE",.F.,.F.,{aSD2Vend[nCntFor][1]})
						If ( ValType(nPerComis)<>"N" )
							nPerComis := aSD2Vend[nCntFor][9]
						EndIf
					EndIf
					If ( SE1->E1_PARCELA $ cPrimParc )
						nBaseDif  := NoRound(nFrete*(1-(aSD2Vend[nCntFor,2]/nTotal)),nDecimal+1)
						nBaseDif  := nFrete - nBaseDif
						nRatFrete := nBaseDif
					Else
						nRatFrete := NoRound(nFrete*aSD2Vend[nCntFor,2]/nTotal,nDecimal+1)
					EndIf
					nRatIcmFre:= 0
					nBaseSE1  := 0
					nPos		 := 0
					nRatIcmFre:= NoRound(nIcmFrete*aSD2Vend[nCntFor,2]/nTotal,nDecimal+1)
					nBaseSE1  := aSD2Vend[nCntFor,2]+aSD2Vend[nCntFor,4]+aSD2Vend[nCntFor,8]+nRatFrete
					dbSelectArea("SA3")
					dbSetOrder(1)
					MsSeek(xFilial()+aSD2Vend[nCntFor,1])

					nAlEmissao := SA3->A3_ALEMISS
					nAlBaixa := SA3->A3_ALBAIXA

					If ( SA3->A3_FRETE == "N" )
						nBaseSE1 -= ( nRatFrete )
					Endif
					

					If ( SA3->A3_ACREFIN == "N" ) .and. aSD2Vend[nCntFor,10] > 0
						nBaseSE1 -= ( aSD2Vend[nCntFor,10] )
					EndIf
					nPos := aScan(aBaseSE1,{|x| x[1] == aSD2Vend[nCntFor,1]})
					If Alltrim(SE1->E1_Hist) <> "VENDA EM DINHEIRO"
						nBaseBaix := Round(nBaseSE1*nAlBaixa/100,nDecimal+1) 	// Base da Comissao na Baixa
					Else
						nBaseBaix:= 0
					EndIf
					nBaseEmis := nBaseSE1-nBaseBaix											// Base da Comissao na Emissao
					nVlrEmis  := Round(nBaseEmis*aSD2Vend[nCntFor,9]/100,nDecimal+1) // Valor da Comissao na Emissao
					nVlrBaix  := Round(nBaseBaix*aSD2Vend[nCntFor,9]/100,nDecimal+1) // Valor da Comissao na Baixa
					If ( Empty(nRegDevol) .Or. nRegDevol == aSD2Vend[nCntFor,11] )
						If ( nPos == 0 )
							aadd(aBaseSE1,{ aSD2Vend[nCntFor,1] ,;
								nBaseSE1				,;
								nBaseEmis				,;
								nBaseBaix				,;
								nVlrEmis				,;
								nVlrBaix				,;
								nPerComis		,;
								nPis,;
								nCsll,;
								nCofins,;
								nIrrf})
						Else
							aBaseSE1[nPos,2] += nBaseSE1
							aBaseSE1[nPos,3] += nBaseEmis
							aBaseSE1[nPos,4] += nBaseBaix
							aBaseSE1[nPos,5] += nVlrEmis
							aBaseSE1[nPos,6] += nVlrBaix
							If aBaseSE1[nPos,7] == nPerComis
								aBaseSE1[nPos,7] := nPerComis
							Else
								aBaseSE1[nPos,7] := 0
							EndIf
						EndIf
					EndIf
				Next nCntFor
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calculo da comissao pelas parcelas.							 ³
				//³																 ³
				//³1)O SE3 ‚ gravado por parcela e nao pela nota. assim e'neces- ³
				//³ssario calcular a base da comissao para a parcela em questao. ³
				//³																 ³
				//³2)Aqui deve-se tomar o maximo cuidado com a Condi‡Æo de pagto ³
				//³pois se o Icms Solidario ou o Ipi for separado de alguma par- ³
				//³cela deve-se considera esta separacao para calcular-se a me-  ³
				//³lhor propor‡ao possivel para a base da parcela. 				 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nMaxFor := Len(aBaseSE1)
				For nCntFor := 1 To nMaxFor
					nProp   := 0
					nVlrFat := xMoeda(SF1->F1_VALBRUT,SE1->E1_MOEDA,1,SE1->E1_EMISSAO)
					nVlrTit := SE1->E1_VLCRUZ
					dbSelectArea("SA3")
					dbSetOrder(1)
					MsSeek(xFilial()+aBaseSE1[nCntFor,1])
					If ( nVlrTit > 0 )
						nProp := nVlrFat / nVlrTit
					Else
						nProp := 0
					EndIf
					If (nProp != 0 )
						nBaseSE1 := NoRound(aBaseSE1[nCntFor,2]/nProp,nDecimal+1)
						nBaseEmis:= NoRound(aBaseSE1[nCntFor,3]/nProp,nDecimal+1)
						nBaseBaix:= NoRound(aBaseSE1[nCntFor,4]/nProp,nDecimal+1)
						nVlrEmis := Round(aBaseSE1[nCntFor,5]/nProp,nDecimal+1)
						nVlrBaix := Round(aBaseSE1[nCntFor,6]/nProp,nDecimal+1)
					Else
						nBaseSE1 := 0
						nBaseEmis:= 0
						nBaseBaix:= 0
						nVlrEmis := 0
						nVlrBaix := 0
					EndIf
					If ( SE1->E1_PARCELA $ cPrimParc .And. nBaseSE1 != 0 )
						//--> Calculo da Proporcao para a Base da Comissao
						nBaseDif := Round(nBaseSE1 * nProp,nDecimal+1)
						nBaseDif := aBaseSE1[nCntFor,2]-nBaseDif
						aBaseSE1[nCntFor,2] := nBaseSE1+nBaseDif
						//--> Calculo da Proporcao para a Base da Comissao pela Emissao

						nBaseDif := Round(nBaseEmis * nProp,nDecimal+1)
						nBaseDif := aBaseSE1[nCntFor,3]-nBaseDif
						aBaseSE1[nCntFor,3] := nBaseEmis+nBaseDif
						//--> Calculo da Proporcao para a Base da Comissao pela Baixa

						nBaseDif := Round(nBaseBaix * nProp,nDecimal+1)
						nBaseDif := aBaseSE1[nCntFor,4]-nBaseDif
						aBaseSE1[nCntFor,4] := nBaseBaix+nBaseDif
						//--> Calculo da Proporcao para o Valor da Comissao pela Emissao

						nBaseDif := Round(nVlrEmis * nProp,nDecimal+1)
						nBaseDif := aBaseSE1[nCntFor,5]-nBaseDif
						aBaseSE1[nCntFor,5] := nVlrEmis+nBaseDif
						//--> Calculo da Proporcao para o Valor da Comissao pela Baixa

						nBaseDif := Round(nVlrBaix * nProp,nDecimal+1)
						nBaseDif := aBaseSE1[nCntFor,6]-nBaseDif
						aBaseSE1[nCntFor,6] := nVlrBaix+nBaseDif
					Else
						aBaseSE1[nCntFor,2] := nBaseSE1
						aBaseSE1[nCntFor,3] := nBaseEmis
						aBaseSE1[nCntFor,4] := nBaseBaix
						aBaseSE1[nCntFor,5] := nVlrEmis
						aBaseSE1[nCntFor,6] := nVlrBaix
					EndIf
				Next nCntFor
			Else
				If ( lQuery .And. Select(cAliasDev)<>0 )
					dbSelectArea(cAliasDev)
					dbCloseArea()
					dbSelectArea("SE1")
				EndIf
			EndIf
		Endif
		If ( lQuery .And. Select(cAliasDev)<>0 )
			dbSelectArea(cAliasDev)
			dbCloseArea()
			dbSelectArea("SE1")
		EndIf
		If ( lQuery )
			dbSelectArea(cAliasSD1)
			dbCloseArea()
			dbSelectArea("SD1")
		EndIf
	Else
		If Empty(nRegDevol)
			If ( Empty(aBaseSE1) .And. lRefaz )
				cVend := "1"
				For nCntFor := 1 To __nVend
					nIRRF 		:= 0
					cVendedor 	:= SE1->(FieldGet(SE1->(FieldPos("E1_VEND"+cVend))))

					//No caso da NCC, ha situacoes que o Vendedor esta nela e ha casos que nao, mas esta no titulo original
					If ( SE1->E1_TIPO $ MV_CRNEG .And. nRecnoOrig <> nRegistro .And. Empty( cVendedor ) ) .Or.;
						!SE1->E1_TIPO $ MV_CRNEG .And. nRecnoOrig <> nRegistro
						SE1->(dbGoto(nRecnoOrig)) // pra caso o titulo parta de uma liquidação
					EndIf
					cVendedor := SE1->(FieldGet(SE1->(FieldPos("E1_VEND"+cVend))))
					nPerComis := SE1->(FieldGet(SE1->(FieldPos("E1_COMIS"+cVend))))

					dbSelectArea("SE3")
					dbSetOrder(1)
					If DbSeek(XFilial("SE3")+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA)

						// Verifica se o tipo da comissao bate com o tipo do titulo. Pode ocorrer dois titulos
						// com o mesmo prefixo/numero/parcela/cliente/loja com tipos diferentes
						Do While 	SE3->( ! EoF() ) .And. ;
									SE3->( xFilial( "SE3" ) + E3_PREFIXO + E3_NUM + E3_PARCELA ) == ;
									SE1->( xFilial( "SE1" ) + E1_PREFIXO + E1_NUM + E1_PARCELA )
							If SE3->E3_TIPO == SE1->E1_TIPO .And.  SE1->(FieldGet(SE1->(FieldPos("E1_VEND"+cVend)))) ==  SE3->E3_VEND
								If !(__l440Flag .And. SE3->&(Upper(__cCpoFlag)) == "1") .Or. SE3->E3_AJUSTE != "R"
									nPerComis := SE3->E3_PORC
								Endif
								Exit
							EndIf
							SE3->( dbSkip() )
						EndDo

					EndIf

					MsUnLock()

					SE1->(dbGoto(nRegistro)) // volta ao recno original

					dbSelectArea("SA3")
					dbSetOrder(1)
					MsSeek(xFilial("SA3")+cVendedor)
					lCOMISIR := IIf( cPaisLoc == "BRA" , SA3->A3_BASEIR == "1" , lCOMISIR )
					
					If SE1->(FieldPos("E1_ALEMIS"+cVend))<>0//Nao criar no dicionario padrao
						nAlEmissao := SE1->(FieldGet(FieldPos("E1_ALEMIS"+cVend)))
					Else
						nAlEmissao := SA3->A3_ALEMISS
					EndIf
					If SE1->(FieldPos("E1_ALBAIX"+cVend))<>0//Nao criar no dicionario padrao
						nAlBaixa := SE1->(FieldGet(FieldPos("E1_ALBAIX"+cVend)))
					Else
						nAlBaixa := SA3->A3_ALBAIXA
					EndIf

					If ( !Empty(cVendedor) ) .and. !SE1->E1_TIPO $ MVABATIM
						If Alltrim(SE1->E1_Hist) <> "VENDA EM DINHEIRO" .OR.;		 //Adriano - Comissoes
							( Alltrim(SE1->E1_Hist) == "VENDA EM DINHEIRO" .AND. (("LOJA"$SE1->E1_ORIGEM) .OR. "FATA701"$ SE1->E1_ORIGEM))
							If lMultVend .OR. (("LOJA"$SE1->E1_ORIGEM) .OR. ("FATA701"$ SE1->E1_ORIGEM))
								nBaseEmis := Round(SE1->(FieldGet(SE1->(FieldPos("E1_BASCOM"+cVend))))*(nAlEmissao/100),nDecimal+1)
								nBaseBaix := Round(SE1->(FieldGet(SE1->(FieldPos("E1_BASCOM"+cVend))))*(nAlBaixa/100),nDecimal+1)
							Else
								nBaseEmis := Round(SE1->E1_VLCRUZ*(nAlEmissao/100),nDecimal+1)
								nBaseBaix := Round(SE1->E1_VLCRUZ*(nAlBaixa/100),nDecimal+1)
							
								If lF440BasEm
									nF440BasEm := Round(IIF(SE1->E1_BASCOM1 > 0, SE1->E1_BASCOM1, SE1->E1_VLCRUZ)*(nAlEmissao/100),nDecimal+1)
									If nBaseEmis <= 0
										lF440BasEm := .F.
									EndIf 
								EndIf
							EndIf
						Else
							nBaseEmis := SE1->(FieldGet(SE1->(FieldPos("E1_BASCOM"+cVend))))
							nBaseBaix := nBaseEmis
							If "LOJA"$SE1->E1_ORIGEM .AND. Alltrim(SE1->E1_Hist) <> "VENDA EM DINHEIRO"
								If nAlEmissao > 0 .AND. lCalEmis
									nBaseEmis := Round( (nBaseEmis ) * ( nAlEmissao / 100 ), nDecimal+1 )
									nBaseBaix := 0
								ElseIf nAlBaixa > 0
									nBaseEmis := 0
									nBaseBaix := Round( (nBaseBaix) * ( nAlBaixa / 100 ), nDecimal+1 )
								Endif
							Endif
						Endif
						
						// IRRF
						If lCOMISIR  .And. lRecIRRF
							nBaseEmis -= IIF(nAlEmissao > 0 .And. nAlBaixa > 0,; 
									Iif(nBaseEmis > 0, Round((Round(SE1->E1_IRRF,nDecimal+1)) * ( nAlEmissao / 100 ), nDecimal+1 ), 0),;
									Iif(nBaseEmis > 0, Round(SE1->E1_IRRF,nDecimal+1), 0))							
							
							nBaseBaix -= IIF(nAlEmissao > 0 .And. nAlBaixa > 0,; 
									Iif(nBaseBaix > 0, Round((Round(SE1->E1_IRRF,nDecimal+1)) * (nAlBaixa / 100 ), nDecimal+1 ), 0),;
									Iif(nBaseBaix > 0, Round(SE1->E1_IRRF,nDecimal+1), 0))							 						
						EndIf
						// IRRF da BAIXA - FATOR DE PROPORCIONALIZAÇÃO
						If lIrPjBxCr .And. !lCalEmis
							If !(SE5->E5_PRETIRF	$"1;2")
								nIRRF	:= SE5->E5_VRETIRF
							Else
								nIRRF	:= 0
							EndIf
						Endif
							
						// INSS
						If lCOMISIN
							nBaseEmis -= IIF(nAlEmissao > 0 .And. nAlBaixa > 0,;
													Iif(nBaseEmis > 0, Round((Round(SE1->E1_INSS,nDecimal+1)) * ( nAlEmissao / 100 ), nDecimal+1), 0),;							
													Iif(nBaseEmis > 0, Round(SE1->E1_INSS,nDecimal+1), 0))
							
							
						EndIf
						
											
						// PIS, COFINS, CSLL
						If lCOMIPIS						
								nBaseBaix -= IIF(nAlEmissao > 0 .And. nAlBaixa > 0,;
														Iif(nBaseBaix > 0, Round((Round(SE1->E1_PIS,nDecimal+1)) * ( nAlBaixa / 100 ), nDecimal+1), 0),;													
														Iif(nBaseBaix > 0, Round(SE1->E1_PIS,nDecimal+1), 0)) 	
								nBaseEmis -= IIF(nAlEmissao > 0 .And. nAlBaixa > 0,;
														Iif(nBaseEmis > 0, Round((Round(SE1->E1_PIS,nDecimal+1)) * ( nAlEmissao / 100 ), nDecimal+1), 0),;							
														Iif(nBaseEmis > 0, Round(SE1->E1_PIS,nDecimal+1), 0))
							EndIf

						If lCOMICOF
								nBaseBaix -= IIF(nAlEmissao > 0 .And. nAlBaixa > 0,;													
														Iif(nBaseBaix > 0, Round((Round(SE1->E1_COFINS,nDecimal+1)) * ( nAlBaixa / 100 ), nDecimal+1), 0),;													
														Iif(nBaseBaix > 0, Round(SE1->E1_COFINS,nDecimal+1), 0))
								nBaseEmis -= IIF(nAlEmissao > 0 .And. nAlBaixa > 0,;
														Iif(nBaseEmis > 0, Round((Round(SE1->E1_COFINS,nDecimal+1)) * ( nAlEmissao / 100 ), nDecimal+1), 0),;
														Iif(nBaseEmis > 0, Round(SE1->E1_COFINS,nDecimal+1), 0))							
							EndIf
						
						If lCOMICSL
								nBaseBaix -= IIF(nAlEmissao > 0 .And. nAlBaixa > 0,;													
														Iif(nBaseBaix > 0, Round((Round(SE1->E1_CSLL,nDecimal+1)) * ( nAlBaixa / 100 ), nDecimal+1), 0),;													
														Iif(nBaseBaix > 0, Round(SE1->E1_CSLL,nDecimal+1), 0))
								nBaseEmis -= Iif(nAlEmissao > 0 .And. nAlBaixa > 0,;
														Iif(nBaseEmis > 0, Round((Round(SE1->E1_CSLL,nDecimal+1)) * ( nAlEmissao / 100 ), nDecimal+1), 0),;
														Iif(nBaseEmis > 0, Round(SE1->E1_CSLL,nDecimal+1), 0))							
						EndIf
						
						// PCC da BAIXA - FATOR DE PROPORCIONALIZAÇÃO
						If lPccBxCr .and. !lCalEmis
							If !(SE5->E5_PRETPIS	$	"1;2")
								nPis	:= SE5->E5_VRETPIS
							Else
								nPis	:=	0
							EndIf
							If !(SE5->E5_PRETCOF	$	"1;2")
								nCofins	:= SE5->E5_VRETCOF
							Else
								nCofins	:= 0
							EndIf
							If !(SE5->E5_PRETCSL	$	"1;2")
								nCsll	:= SE5->E5_VRETCSL
							Else
								nCsll	:=	0
							EndIf
						Endif
						
						
						//ISS
						If ( SA3->A3_ISS == "N" )
							nValISS := IIF(lCalcIssBx,SE5->E5_VRETISS,SE1->E1_ISS)
							//Se o valor do ISS calculado for inferior ao minimo de retencao (MV_VRETISS), nao descontar da base de comissao
							If nVRetISS < if(!Empty(aSD2Vend),aSD2Vend[nCntFor,3],nValISS)
								nBaseEmis -= Round(SE1->E1_ISS*(nAlEmissao/100),nDecimal+1)
								nBaseBaix -= Round(SE1->E1_ISS*(nAlBaixa/100),nDecimal+1)
							EndIf
						EndIf
						//Validação FWMYTESTRUNNER 
						If ((!lComiLiq .and. IsInCallStack("FINA040")) .or. lLoja .or. (cFunName$ "FINA440|FATA701|RPC" .and. Empty(SE1->E1_NUMLIQ))) 
							nVlrEmis  := Round(nBaseEmis * (nPerComis/100),nDecimal+1)
							nVlrBaix  := Round(nBaseBaix * (nPerComis/100),nDecimal+1)   
						Else 
							nVlrEmis  := 0
							nVlrBaix  := Round(nBaseBaix * (nPerComis/100),nDecimal+1) 
						Endif  
						
						If (lComiliq)
							nVlrEmis  := Round(nBaseEmis * (nPerComis/100),nDecimal+1)
							nVlrBaix  := Round(nBaseBaix * (nPerComis/100),nDecimal+1)
						Endif


						// --> quer dizer que já comissionou na liquidacao do titulo original
						If ( lComiLiq ) .and. !Empty(SE1->E1_NUMLIQ)
							IF IsInCallStack("FA460CAN") .or. ( cFunName == "FINA460" )
							// Se "comiliq", considero comissao como se fosse na baixa e nao na emissao
								nVlrEmis := nVlrBaix
								nBaseEmis:= nBaseBaix
							Elseif !( cFunName == "FINA460" )
								nVlrBaix  	:= 0
								nBaseBaix	:= 0
							Endif
						Endif

						// Tratamento para nao pegar o frete caso esteja configurado na SA3
						If SA3->A3_FRETE == "N"
							nValCom := SE1->E1_VLCRUZ - SL1->L1_FRETE
						Else
							nValCom := SE1->E1_VLCRUZ 
						EndIf
						
						aadd(aBaseSE1,{ cVendedor,;
							SE1->E1_VLCRUZ ,;
							nBaseEmis ,;
							nBaseBaix ,;
							nVlrEmis  ,;
							nVlrBaix  ,;
							nPerComis ,;
							nPis      ,;
							nCsll     ,;
							nCofins   ,;
							nIRRF     })
					EndIf
					cVend := Soma1(cVend,1)
				Next nCntFor
			EndIf
			If ( lGrava .And. lRefaz ) .AND. !("LOJA"$SE1->E1_ORIGEM .OR. "FATA701"$SE1->E1_ORIGEM)
				dbSelectArea("SE1")
				RecLock("SE1")
				cVend := "1"

				For nCntFor := 1 To Len(aBaseSE1)
					dbSelectArea("SA3")
					dbSetOrder(1)
					MsSeek(xFilial("SA3")+aBaseSE1[nCntFor,1])
					dbSelectArea("SE1")
					If ( FieldGet(FieldPos("E1_VEND"+cVend)) == aBaseSE1[nCntFor,1] )
						If ("FINA630" $ SE1->E1_ORIGEM)
							aAreaSE6	:= SE1->(GetArea())
							SE1->(DbSetOrder(1))
							If SE1->(DbSeek(xFilial("SE1", SE6->E6_FILORIG) + SE6->(E6_PREFIXO + E6_NUM + E6_PARCELA + E6_TIPO))) 
								If Alltrim(SE1->E1_ORIGEM) $ "MATA460"
									nBaseComX	:= &("SE1->E1_BASCOM" + cVend)
									aBaseSE1[nCntFor, 2] := nBaseComX
									aBaseSE1[nCntFor, 4] := nBaseComX
									aBaseSE1[nCntFor, 6] := nBaseComX * aBaseSE1[nCntFor, 7] / 100
								Endif
							Endif
							RestArea(aAreaSE6)
						Endif

						FieldPut(FieldPos("E1_BASCOM"+cVend), IIF(lF440BasEm, nF440BasEm, aBaseSE1[nCntFor,2]))

						If ( aBaseSE1[nCntFor,3] != 0 .Or. aBaseSE1[nCntFor,4] != 0 )
							FieldPut(FieldPos("E1_COMIS"+cVend),aBaseSE1[nCntFor,7])
						Endif
						FieldPut(FieldPos("E1_VALCOM"+cVend),aBaseSE1[nCntFor,5])
						If cPaisLoc == "PTG"
							FieldPut(FieldPos("E1_BASCOM"+cVend),aBaseSE1[nCntFor,12])
							FieldPut(FieldPos("E1_VALCOM"+cVend),aBaseSE1[nCntFor,11])
						EndIf
					Else
						If ( SE1->(FieldPos("E1_VEND"+cVend)) != 0 )
							nCntFor--
						EndIf
					EndIf
					cVend := Soma1(cVend,1)
				Next nCntFor
				
				MsUnlock()
			EndIf
			If ( Empty(aBaseSE1) )
				cVend := "1"
				For nCntFor := 1 To __nVend
					nIRRF := 0
					cVendedor := SE1->(FieldGet(SE1->(FieldPos("E1_VEND"+cVend))))
					nPerComis := SE1->(FieldGet(SE1->(FieldPos("E1_COMIS"+cVend))))
					dbSelectArea("SA3")
					dbSetOrder(1)
					MsSeek(xFilial("SA3") + cVendedor)
					lCOMISIR := IIf( cPaisLoc == "BRA", SA3->A3_BASEIR == "1" , lCOMISIR )
					
					If ( !Empty(cVendedor) )
						//Trazer a base gravada na emissao, substituindo o zero, para evitar valores negativos
						If SA3->A3_ALBAIXA > 0
							nBaseSE1  := SE1->(FieldGet(FieldPos("E1_BASCOM" + "1"))) * (SA3->A3_ALBAIXA / 100)
							nBaseEmis := SE1->(FieldGet(FieldPos("E1_BASCOM" + "1"))) - (SE1->(FieldGet(FieldPos("E1_BASCOM" + "1"))) * (SA3->A3_ALBAIXA / 100))
							nBaseBaix := SE1->(FieldGet(SE1->(FieldPos("E1_BASCOM"+cVend)))) * (SA3->A3_ALBAIXA / 100)
							nVlrEmis  := SE1->(FieldGet(FieldPos("E1_BASCOM" + "1"))) - (SE1->(FieldGet(FieldPos("E1_BASCOM" + "1"))) * (SA3->A3_ALBAIXA / 100))
						Else
							nBaseSE1  := SE1->(FieldGet(FieldPos("E1_BASCOM" + "1")))
							nBaseEmis := 0
							nBaseBaix := SE1->(FieldGet(SE1->(FieldPos("E1_BASCOM"+cVend)))) * (SA3->A3_ALBAIXA / 100)
							nVlrEmis  := 0
						EndIf
						// --> Quando o percentual da comissao estiver no produto o sistema
						// --> arredonda o percentual se for pago na baixa, caso haja muita
						// --> distorcao de valores deve-se alterar o numero de casas
						// --> decimais do campo E1_COMIS1..E1_COMIS(n)
						If  lPccBxCr .and. !lCalEmis
							If !(SE5->E5_PRETPIS $	"1;2")
								nPis		:= SE5->E5_VRETPIS
							Else
								nPis		:=	0
							EndIf
							If !(SE5->E5_PRETCOF	$	"1;2")
								nCofins	:= SE5->E5_VRETCOF
							Else
								nCofins	:= 0
							EndIf
							If !(SE5->E5_PRETCSL $	"1;2")
								nCsll		:= SE5->E5_VRETCSL
							Else
								nCsll		:=	0
							EndIf
						ElseIf !lIrPjBxCr .And. lCalEmis    
							nPis			:= SE1->E1_PIS
							nCofins		:= SE1->E1_COFINS
							nCsll		:= SE1->E1_CSLL
						Endif
						If lCOMISIR .and. !lMata460
							nBaseSE1 -= SE1->E1_IRRF
							nBaseBaix -= SE1->E1_IRRF
							If lIrPjBxCr
								nIRRF := Round(SE5->E5_VRETIRF*(nAlBaixa/100),nDecimal+1)
							Else
								nIRRF := Round(SE1->E1_IRRF*(nAlBaixa/100),nDecimal+1)
							EndIf
						Endif
						If GetNewPar("MV_COMIINS","N") == "N" .and. !lMata460
							nBaseSE1 -= SE1->E1_INSS     
							nBaseBaix -= SE1->E1_INSS    						
						EndIf
						If !lPccBxCr
							If lCOMIPIS .and. !lMata460
								nBaseSE1 -= SE1->E1_PIS
								nBaseBaix -= SE1->E1_PIS
							EndIf
							If lCOMICOF .and. !lMata460
								nBaseSE1 -= SE1->E1_COFINS 
								nBaseBaix -= SE1->E1_COFINS
							EndIf
							If lCOMICSL .and. !lMata460
								nBaseSE1 -= SE1->E1_CSLL 
								nBaseBaix -= SE1->E1_CSLL
							EndIf
						Endif
						If ( SA3->A3_ISS == "N" )
							nValISS := IIF(lCalcIssBx,SE5->E5_VRETISS,SE1->E1_ISS)
							//Se o valor do ISS calculado for inferior ao minimo de retencao (MV_VRETISS), nao descontar da base de comissao
							If nVRetISS < if(!Empty(aSD2Vend),aSD2Vend[nCntFor,3],nValISS)
								nBaseEmis -= Round(SE1->E1_ISS*(SA3->A3_ALEMISS/100),nDecimal+1)
								nBaseBaix -= Round(SE1->E1_ISS*(SA3->A3_ALBAIXA/100),nDecimal+1)
							EndIf
						EndIf																	

						nVlrBaix  := nBaseBaix * (nPerComis/100)
						//No segundo elemento, a variavel nBaseSE1 foi substituida pelo campo SE1->E1_VLCRUZ (base bruta), pois apenas passava valores
						//negativos
						aadd(aBaseSE1,{ cVendedor,;
							SE1->E1_VLCRUZ,;
							nBaseEmis,;
							nBaseBaix,;
							nVlrEmis,;
							nVlrBaix,;
							nPerComis,;
							nPis		,;
							nCsll		,;
							nCofins, ;
							nIRRF})
					EndIf
					cVend := Soma1(cVend,1)
				Next nCntFor
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Restaura a Integridade dos dados de Entrada                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea(aAreaSE1)
	RestArea(aAreaSE4)
	RestArea(aAreaSF1)
	RestArea(aAreaSF2)
	RestArea(aAreaSF4)
	RestArea(aAreaSD1)
	RestArea(aAreaSD2)
	RestArea(aAreaSA1)
	RestArea(aAreaSA3)
	RestArea(aArea)

Return(aBaseSE1)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³FA440CntVe³ Autor ³ Eduardo Riera         ³ Data ³ 16/12/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao de Contagem do Numero de Vendedores Utilizados.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Numero de Vendedores                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA440                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fa440CntVen()

	Local cCnt     := "1"
	Local aStruct  := {}
	Local lContinua:= .T.

	If ( Empty(__nVend) )
		__nVend := 0
		aStruct := SE1->(dbStruct())
		While ( lContinua )
			If ( aScan(aStruct,{|x| Trim(x[1]) == "E1_VEND"+cCnt}) != 0 ) 
				__nVend++
				cCnt := Soma1(cCnt,1)
			Else
				lContinua := .F.
			EndIf
		EndDo
		__nVend := Max(__nVend,5)
	EndIf
Return(__nVend)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FA440Orige³ Autor ³Eduardo Riera          ³ Data ³05.08.98  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o Codigo de Origem do SE3                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpC1 := Origem do SE3                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 := Programa de Chamada                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function FA440Origem(cOrigem)

Local cRetorno := ""
Local cOriCobr := Iif(!(cPaisLoc $ "BRA|ARG") .AND. FindFunction('OriCobrDiv'),OriCobrDiv(),"")

cOrigem := AllTrim(cOrigem)
Do Case
Case cOrigem $ "FINA040#FINA280"
	cRetorno := "E" //Emissao Financeiro
Case cOrigem $ "FINA070#FINA330#FINA110#FINA087A#"+cOriCobr
	cRetorno := "B" //Baixa Financeiro
Case cOrigem $ "MATA460#MATA520#MATA467N#MATA465N#MATA468N"
	cRetorno := "F" //Faturamento
Case cOrigem $ "MATA100"
	cRetorno := "D" //Devolucao de Venda
Case cOrigem $ "FINA440"
	cRetorno := "R" //Recalculo quando nao ha origem
Case cOrigem $ "LOJA010#LOJA020#LOJA220#FRTA010#LOJA701"
	cRetorno := "L" //SigaLoja
OtherWise
	cRetorno := " " //Desconhecido
EndCase
Return(cRetorno)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ComisBx   ³ Autor ³ Andreia Santos        ³ Data ³ 25/11/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Responde com T ou F se uma comiss„o ser  considerada        ³±±
±±³Descri‡„o ³em fun‡„o de uma baixa                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ComixBx(ExpC1) - Motivo de uma baixa                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ComisBx( cMotBx )
LOCAL nPos,lRet := .F.
Local aMotBx := ReadMotBx()
 nPos := Ascan(aMotBx, {|x| Substr(x,1,3) == Upper(cMotBx) })
If nPos > 0
	lRet := Iif(Substr(aMotBx[nPos],26,1) == "S",.T.,.F.)
Endif
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³F440Loja  ³ Autor ³ Wagner Xavier         ³ Data ³ 05/06/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Responde com T ou F se uma comiss„o foi gerada pelo SIGALOJA³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³F440LOja(ExpC1) - Sufixo (SE1 ou SE5)							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³Generico																	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function f440Loja(cArquivo,cAlias)
Local aArea := GetArea()
Local lRet := .F.
Local cMVLJCOMIS	:= AllTrim( SuperGetMV("MV_LJCOMIS",, "") )	// Define qual rotina utilizar para os cálculos de comissões de venda, LOJA440 ou FINA440.

If Empty(cMVLJCOMIS) .OR. cMVLJCOMIS == "LOJA440"

	If cArquivo == "SE1"
		dbSelectArea("SL1")
		dbSetOrder(2)
		If MsSeek(xFilial(cAlias)+(cAlias)->E1_SERIE+(cAlias)->E1_NUM)
			lRet := .T.
		Endif
	Else
		If (cAlias)->E5_TIPODOC == "LJ"
			lRet := .T.
		Else
			dbSelectArea("SL1")
			dbSetOrder(2)
			If MsSeek(xFilial(cAlias)+(cAlias)->E5_PREFIXO+(cAlias)->E5_NUMERO)
				lRet := .T.
			Endif
		Endif
		//se for um titulo de CC/CD gerado pelo SIGALOJA, a comissao só deverá ser gerada pelo LOJA440, pois senão haverá duas comissões para a mesma venda
		If !lRet
			dbSelectArea("SE1")
			SE1->( dbSetOrder(1) )	//E1_FILIAL, E1_PREFIXO, E1_NUM, E1_PARCELA, E1_TIPO
			If MsSeek( xFilial("SE1") + (cAlias)->E5_PREFIXO + (cAlias)->E5_NUMERO + (cAlias)->E5_PARCELA + (cAlias)->E5_TIPO )
				If AllTrim(SE1->E1_ORIGEM) $ "LOJA701#FATA701" .AND. AllTrim(SE1->E1_TIPO) $ "CC|CD"
					lRet := .T.	
				EndIf			
			Endif
		EndIf
	Endif

EndIf

RestArea(aArea)
Return lRet


/*/{Protheus.doc} Fa440LiqSe1
    @description 
    @author Eduardo Riera
    @since 21/11/2003
    @return logical, execução concluída
	@param
		cNumLiq, Character
		aLiquid, Array
		aValLiq, Array
		aSeqCont, Array
		cNumFat, Character
		cFatPref, Character
		aTitFat, Array
		aNLiquid, Array
    @type function
/*/
Function Fa440LiqSe1(cNumLiq as Character, aLiquid as Array, aValLiq as Array, aSeqCont as Array, cNumFat as Character, cFatPref as Character, aTitFat as Array, aNLiquid as Array) As Logical
	Local nPosLiq 		as Numeric
	Local aArea 		as Array
	Local cAliasSE5		as Character
	Local aAreaSE1 		as Array
	Local aAreaSE5 		as Array
	Local lRelat 		as Logical
	Local nX 			as Numeric
	Local nZ 			as Numeric
	Local aStruSE5 		as Array
	Local cQuery 		as Character
	Local nReliq 		as Numeric
	Local aBkpReliq 	as Array
	Local aReliqNew 	as Array
	Local nPosNumLiq 	as Numeric
	Local aNumLiq 		as Array
	Local cNumReliq 	as Character
	Local nPosNew 		as Numeric
	Local aTitReliq 	as Array
	Local nPNLiquid 	as Numeric
	Local lNoMssql  	as Logical
	Local nTamSE5		as Numeric

	Local cFilOri 		as Character
	Local cSubs 		as Character
	Local nTamSE1 		as Numeric
	Local cBDname 		as Character
	Local cFilOriSe5	as Character

	Default aLiquid  := {}
	Default aValLiq  := {}
	Default aSeqCont := {}
	Default cNumFat  := ""
	Default cFatPref := ""
	Default aTitFat  := {}
	Default aNLiquid := {}
	
	nPosLiq			:= 0
	aArea    		:= GetArea()
	cAliasSE5		:= "SE5"
	aAreaSE1 		:= SE1->(GetArea())
	aAreaSE5 		:= SE5->(GetArea())
	lRelat   		:= IsInCallStack("MATR540")
	nX       		:= 0
	nZ	   			:= 0
	aStruSE5 		:= {}
	cQuery   		:= ""
	nReliq     		:= 0
	aBkpReliq	 	:= {}
	aReliqNew  		:= {} 
	nPosNumLiq 		:= 0 
	aNumLiq	 		:= {}
	cNumReliq	 	:= ""
	nPosNew 	 	:= 0
	aTitReliq 		:= {} 
	nPNLiquid		:= 0 

	cFilOri			:= cFilAnt
	cSubs			:= "SUBSTRING"
	nTamSE1 		:= LEN(ALLTRIM(xFILIAL("SE1")))
	nTamSE5			:= LEN(xFilial("SE5"))
	cBDname 		:= Upper( TCGetDB() )
	cFilOriSe5		:=	""

	__lReliq	:= .F.

	If !Empty(cNumLiq)
		If "FINA630" $ SE1->E1_ORIGEM
			SE6->(dbSetOrder(4))
			If SE6->(MsSeek(xFilial("SE6")+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
				cFilAnt := SE6->E6_FILORIG
			EndIf
		EndIf
	Endif

	If Select("__SE1") == 0
		ChkFile("SE1",.F.,"__SE1")
	Endif

	dbSelectArea("SE5")
	dbSetOrder(10)

	aStruSE5 := SE5->(dbStruct())
	cAliasSE5 := GetNextAlias()

	lNoMssql := (cBDname $ "ORACLE|DB2|POSTGRES|INFORMIX")
	If lNoMssql
		cSubs 	:= "SUBSTR"
	EndIf

	cQuery := "SELECT E5_FILIAL, E5_MOTBX,   E5_DOCUMEN, E5_CLIFOR, E5_LOJA, E5_PREFIXO, E5_NUMERO, E5_PARCELA, "
	cQuery += "       E5_TIPO,   E5_SITUACA, E5_DATA,    E5_VALOR,  E5_SEQ,  E5_FATPREF, E5_FATURA, E5_FILORIG "

	If lRelat
		cQuery += ",E5_TIPODOC "
	EndIf

	cQuery += ", E1_NUMLIQ, E1_BCOCHQ, E1_FATURA, SE1.R_E_C_N_O_ RECSE1, E1_VLCRUZ, E1_FATPREF, E1_FATURA, E1_STATUS "

	cQuery += " FROM " + RetSqlName("SE5") + " SE5 "

	cQuery += " INNER JOIN " + RetSqlName("SE1") + " SE1 " 

	IF cModeAcSE1 == "E"
		cQuery += "	ON SE1.E1_FILIAL = SE5.E5_FILORIG "
	ELSEIF nTamSE1 = 0
		cQuery += " ON SE1.E1_FILIAL = '"+ xFilial("SE1") +"'"
	ELSE
		If lNoMssql
			cQuery += "	ON SE1.E1_FILIAL = RPAD(" + cSubs + "(SE5.E5_FILORIG,1," + cValToChar(nTamSE1) + "), " + cValToChar(nTamSE5) + ") "
		Else 
			cQuery += "	ON SE1.E1_FILIAL = " + cSubs + "(SE5.E5_FILORIG,1," + cValToChar(nTamSE1) + ") "
		EndIf
	ENDIF

	cQuery += " AND SE1.E1_CLIENTE = SE5.E5_CLIFOR AND SE1.E1_LOJA = SE5.E5_LOJA "

	//ALTERADO PARA VALIDAR APENAS CENÁRIOS COM RELIQUIDAÇÃO NOS PAIS
	If !Empty(cNumLiq)
		cQuery += " AND SE1.E1_PREFIXO = SE5.E5_PREFIXO AND SE1.E1_NUM = SE5.E5_NUMERO AND SE1.E1_PARCELA = SE5.E5_PARCELA "
		cQuery += " AND SE1.E1_TIPO = SE5.E5_TIPO AND SE1.D_E_L_E_T_ = ' ' "
		cQuery += " INNER JOIN "+RetSQLName("FI7")+" FI7 "
		cQuery += "			ON SE1.E1_FILIAL = FI7.FI7_FILDES "
		cQuery += "			AND SE1.E1_PREFIXO = FI7.FI7_PRFDES " 
		cQuery += "			AND SE1.E1_NUM = FI7.FI7_NUMDES "
		cQuery += "			AND SE1.E1_PARCELA = FI7.FI7_PARDES "
		cQuery += "			AND SE1.E1_TIPO = FI7.FI7_TIPDES "
		cQuery += "			AND FI7.D_E_L_E_T_ = ' ' "
		cQuery += " WHERE SE5.E5_FILIAL = '" + xFilial("SE5") + "' AND "
		cQuery += " SE5.E5_DOCUMEN = '" + cNumLiq + "' AND "
		cQuery += " SE5.E5_MOTBX = 'LIQ' AND "
	Else
		cQuery += " AND SE1.E1_FATPREF = SE5.E5_FATPREF AND SE1.E1_FATURA = SE5.E5_FATURA AND SE1.E1_FILORIG = SE5.E5_FILORIG "
		cQuery += " WHERE SE5.E5_FILIAL = '" + xFilial("SE5") + "' AND SE1.E1_FILIAL = '" + xFilial("SE1") + "' AND "
	Endif

	If !Empty(cNumFat) .And. !Empty(cFatPref)
		cQuery += "SE5.E5_FATURA = '"+cNumFat+"' AND "
		cQuery += "SE5.E5_FATPREF = '"+cFatPref+"' AND "
		cQuery += "SE5.E5_MOTBX = 'FAT' AND "
	EndIf

	cQuery += "SE5.E5_SITUACA <> 'C' AND "
	cQuery += "SE5.E5_RECPAG = 'R' AND "
	cQuery += "SE5.D_E_L_E_T_ = ' ' AND "
	cQuery += "SE1.D_E_L_E_T_ = ' ' "

	//UNION PARA VALIDAR CENÁRIO QUE PAIS POSSUAM VENDEDOR
	cQuery += "UNION "

	cQuery += "SELECT E5_FILIAL, E5_MOTBX,   E5_DOCUMEN, E5_CLIFOR, E5_LOJA, E5_PREFIXO, E5_NUMERO, E5_PARCELA, "
	cQuery += "       E5_TIPO,   E5_SITUACA, E5_DATA,    E5_VALOR,  E5_SEQ,  E5_FATPREF, E5_FATURA, E5_FILORIG "

	If lRelat
		cQuery += ",E5_TIPODOC "
	EndIf

	cQuery += ", E1_NUMLIQ, E1_BCOCHQ, E1_FATURA, SE1.R_E_C_N_O_ RECSE1, E1_VLCRUZ, E1_FATPREF, E1_FATURA, E1_STATUS "

	cQuery += " FROM " + RetSqlName("SE5") + " SE5 "

	cQuery += " INNER JOIN " + RetSqlName("SE1") + " SE1 " 

	IF cModeAcSE1 == "E"
		cQuery += "	ON SE1.E1_FILIAL = SE5.E5_FILORIG "
	ELSEIF nTamSE1 = 0
		cQuery += " ON SE1.E1_FILIAL = '"+ xFilial("SE1") +"'"
	ELSE
		If lNoMssql
			cQuery += "	ON SE1.E1_FILIAL = RPAD(" + cSubs + "(SE5.E5_FILORIG,1," + cValToChar(nTamSE1) + "), " + cValToChar(nTamSE5) + ") "
		Else 
			cQuery += "	ON SE1.E1_FILIAL = " + cSubs + "(SE5.E5_FILORIG,1," + cValToChar(nTamSE1) + ") "
		EndIf 
	ENDIF

	cQuery += " AND SE1.E1_CLIENTE = SE5.E5_CLIFOR AND SE1.E1_LOJA = SE5.E5_LOJA "

	If !Empty(cNumLiq)
		cQuery += " AND SE1.E1_PREFIXO = SE5.E5_PREFIXO AND SE1.E1_NUM = SE5.E5_NUMERO AND SE1.E1_PARCELA = SE5.E5_PARCELA "
		cQuery += " AND SE1.E1_TIPO = SE5.E5_TIPO AND SE1.D_E_L_E_T_ = ' ' "
		cQuery += " AND ("+ fa440CpoCh("SE1", 2, "<>", "", "OR") +")"
		cQuery += " WHERE SE5.E5_FILIAL = '" + xFilial("SE5") + "' AND "
		cQuery += " SE5.E5_DOCUMEN = '" + cNumLiq + "' AND "
		cQuery += " SE5.E5_MOTBX = 'LIQ' AND "
	Else
		cQuery += " AND SE1.E1_FATPREF = SE5.E5_FATPREF AND SE1.E1_FATURA = SE5.E5_FATURA "
		cQuery += " WHERE SE5.E5_FILIAL = '" + xFilial("SE5") + "' AND SE1.E1_FILIAL = '" + xFilial("SE1") + "' AND "
	Endif

	If !Empty(cNumFat) .And. !Empty(cFatPref)
		cQuery += "SE5.E5_FATURA = '"+cNumFat+"' AND "
		cQuery += "SE5.E5_FATPREF = '"+cFatPref+"' AND "
		cQuery += "SE5.E5_MOTBX = 'FAT' AND "
	EndIf

	cQuery += "SE5.E5_SITUACA <> 'C' AND "
	cQuery += "SE5.E5_RECPAG = 'R' AND "
	cQuery += "SE5.D_E_L_E_T_ = ' ' AND "
	cQuery += "SE1.D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery(cQuery)

	//CENÁRIOS EM QUE OS PAIS NÃO TENHAM VENDEDOR OU RELIQUIDAÇÃO FICARÃO DE FORA DA QUERY PARA MOTIVOS DE PERFORMANCE
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE5)

	For nX := 1 To Len(aStruSE5)
		If aStruSE5[nX][2]<>"C" .And. FieldPos(aStruSE5[nX][1])<>0
			TcSetField(cAliasSE5,aStruSE5[nX][1],aStruSE5[nX][2],aStruSE5[nX][3],aStruSE5[nX][4])
		EndIf
	Next nX

	// Condição do While antiga corrigida, P12 só será executada em SQL e o filtro já foi feito pela query acima 
	While !(cAliasSE5)->(Eof())
		If Empty((cAliasSE5)->E1_NUMLIQ) .And. Empty((cAliasSE5)->E1_BCOCHQ) .And. !Empty(cNumLiq) .And. Empty((cAliasSE5)->E1_FATURA)

			nPNLiquid := aScan(aNLiquid,{|x| x[1] == (cAliasSE5)->RECSE1 })
			If nPNLiquid == 0
				aadd( aNLiquid, {(cAliasSE5)->RECSE1,(cAliasSE5)->E5_DOCUMEN} )
			EndIf

			nPosLiq := aScan( aLiquid , (cAliasSE5)->RECSE1 )
			If nPosLiq == 0
				aadd( aLiquid, (cAliasSE5)->RECSE1 )

				If lRelat
					aAdd(aValLiq,{(cAliasSE5)->E5_DATA,IIf((cAliasSE5)->E5_TIPODOC # "JR",(cAliasSE5)->E5_VALOR,0)})
				Else
					aAdd(aValLiq,{(cAliasSE5)->E5_DATA,(cAliasSE5)->E5_VALOR})
				EndIf

				aAdd(aSeqCont,(cAliasSE5)->E5_SEQ)

			ElseIf Len(aValLiq) > 0 .AND. Len(aValLiq) >= nPosLiq
				aValLiq[nPosLiq][1]:=(cAliasSE5)->E5_DATA
				aValLiq[nPosLiq][2]+=(cAliasSE5)->E5_VALOR
			Else
				aAdd(aValLiq,{(cAliasSE5)->E5_DATA,(cAliasSE5)->E5_VALOR})
			EndIf

		ElseIf !Empty( (cAliasSE5)->E1_FATPREF) .And. !Empty( (cAliasSE5)->E1_FATURA) .And. Empty(cNumLiq)
			nPNLiquid := aScan(aNLiquid, {|x| x[1] == (cAliasSE5)->RECSE1 })
			If nPNLiquid == 0
				aadd( aNLiquid, {(cAliasSE5)->RECSE1,(cAliasSE5)->E5_DOCUMEN} )
			EndIf

			nPosLiq := aScan(aLiquid, (cAliasSE5)->RECSE1 )		
			If nPosLiq == 0
				aadd(aLiquid, (cAliasSE5)->RECSE1 )
				aAdd(aValLiq,{(cAliasSE5)->E5_DATA,(cAliasSE5)->E5_VALOR})
				aAdd(aSeqCont,(cAliasSE5)->E5_SEQ)
				aAdd(aTitFat,{ (cAliasSE5)->RECSE1 , (cAliasSE5)->E1_VLCRUZ , (cAliasSE5)->E1_FATPREF , (cAliasSE5)->E1_FATURA } )
			Endif

		ElseIf (cAliasSE5)->E1_NUMLIQ == cNumLiq .And. (cAliasSE5)->E1_STATUS <> "R" //Reliquidacoes anteriores a versao 811

			CONOUTR("Erro Titulo : " + (cAliasSE5)->E5_PREFIXO + (cAliasSE5)->E5_NUMERO + (cAliasSE5)->E5_PARCELA + (cAliasSE5)->E5_TIPO )
			ProcLogAtu("ERRO","ERRO_LIQUIDACAO","Erro no processamento de liquidação titulo : " + (cAliasSE5)->E5_PREFIXO + (cAliasSE5)->E5_NUMERO + (cAliasSE5)->E5_PARCELA + (cAliasSE5)->E5_TIPO )

		Else
			If !Empty((cAliasSE5)->E1_NUMLIQ)
				// verifica se a liquidação já foi processada anteriormente
				nPosNumLiq := aScan(aNumLiq,  (cAliasSE5)->E1_NUMLIQ )
				If nPosNumLiq = 0
					aAdd(aNumLiq,(cAliasSE5)->E1_NUMLIQ)
					cNumReliq := (cAliasSE5)->E1_NUMLIQ
					nPosNew := Ascan( aReliqNew, { |x| x[1] == cNumReliq } )
					
					If nPosNew = 0
						aTitReliq := {}
						cFilOriSe5 := (cAliasSE5)->E5_FILORIG
						aTitReliq := Fa440ReLiq(cNumReliq,@aLiquid,@aValLiq,@aSeqCont,@aNLiquid,cFilOriSe5)

						__lReliq	:= Len(aTitReliq) > 0
						For nReliq := 1 To Len(aTitReliq)
							__SE1->(dbGoTo(aTitReliq[nReliq][1]))
							If Empty(__SE1->E1_NUMLIQ) .And. Empty(__SE1->E1_BCOCHQ) .And. Empty(__SE1->E1_FATURA) 						
							
								nPNLiquid := aScan(aNLiquid,{|x| x[1] ==  aTitReliq[nReliq][1]})
								If nPNLiquid == 0
									aadd( aNLiquid, {aTitReliq[nReliq][1],(cAliasSE5)->E5_DOCUMEN} )
								EndIf

								nPosLiq := aScan(aLiquid, aTitReliq[nReliq][1] )

								If nPosLiq == 0

									aadd( aLiquid, aTitReliq[nReliq][1] )
									aAdd( aValLiq, { aTitReliq[nReliq][2] , aTitReliq[nReliq][3] } ) 
									aAdd( aSeqCont, aTitReliq[nReliq][4] )

								ElseIf Len(aValLiq) > 0 .AND. Len(aValLiq) >= nPosLiq

									aValLiq[nPosLiq][1] := aTitReliq[nReliq][2]
									aValLiq[nPosLiq][2] += aTitReliq[nReliq][3]

								Else

									aAdd(aValLiq,{ aTitReliq[nReliq][2] , aTitReliq[nReliq][3] })

								EndIf

							Else

								nPosNew := Ascan( aReliqNew, { |x| x[1] == cNumReliq } )

								If nPosNew = 0
									aAdd( aReliqNew, { cNumReliq , aTitReliq, .F. } )
								Endif  
								
							Endif
						Next nReliq
						
					Endif 
					
				Endif

			ElseIf !Empty(__SE1->E1_FATURA)
				Fa440LiqSe1(__SE1->E1_NUMLIQ,@aLiquid,@aValLiq,@aSeqCont,__SE1->E1_NUM,__SE1->E1_PREFIXO, @aTitFat, @aNLiquid)
			EndIf

		EndIf
		dbSelectArea(cAliasSE5)
		dbSkip()
	EndDo

	If Len(aTitReliq) == 0 .And. !__lReliq
		aTitReliq := Fa440ReLiq(cNumLiq)
		If Len(aTitReliq) > 0
			__lReliq := .T.
		EndIf
	EndIf

	lContinua := !Empty(aReliqNew)

	While lContinua

		lContinua := .F.
		For nZ := 1 To Len(aReliqNew)
			If !aReliqNew[nZ][3]
				lContinua := .T.
				aTitReliq := aReliqNew[nZ][2]
				lOkReliq := .T.
				For nReliq := 1 To Len(aTitReliq)
					__SE1->(dbGoTo(aTitReliq[nReliq][1]))
					If Empty(__SE1->E1_NUMLIQ) .And. Empty(__SE1->E1_BCOCHQ) .And. Empty(__SE1->E1_FATURA) 
						nPosLiq := aScan(aLiquid, aTitReliq[nReliq][1] )
						If nPosLiq == 0
							aadd(aLiquid, aTitReliq[nReliq][1] )
							aAdd( aValLiq,{ aTitReliq[nReliq][2] , aTitReliq[nReliq][3] } ) 
							aAdd(aSeqCont, aTitReliq[nReliq][4] )
						ElseIf Len(aValLiq) > 0 .AND. Len(aValLiq) >= nPosLiq
							aValLiq[nPosLiq][1] := aTitReliq[nReliq][2]
							aValLiq[nPosLiq][2] += aTitReliq[nReliq][3]
						Else
							aAdd(aValLiq,{ aTitReliq[nReliq][2] , aTitReliq[nReliq][3] })
						EndIf
					Else
						cNumReliq := __SE1->E1_NUMLIQ
						nPosNew := Ascan( aReliqNew, { |x| x[1] == cNumReliq } )
						If nPosNew = 0
							aBkpReliq := {}
							aBkpReliq := Fa440ReLiq(cNumReliq,@aLiquid,@aValLiq,@aSeqCont,@aNLiquid)
							lContinua := .T.
							aAdd( aReliqNew, { cNumReliq , aBkpReliq, Empty(aBkpReliq) } )
							lOkReliq := .F.
						Endif  
					Endif
				Next
				If lOkReliq
					aReliqNew[nZ][3] := .T.
				EndIf
			EndIf
		Next 

	EndDo

	dbSelectArea(cAliasSE5)
	dbCloseArea()
	dbSelectArea("SE5")

	cFilAnt := cFilOri

	RestArea(aAreaSE1)
	RestArea(aAreaSE5)
	RestArea(aArea)
Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ChkAbtImp ³ Autor ³ Edson Maricate        ³ Data ³13/01/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Soma titulos de abatimento relacionado aos impostos         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ChkAbtImp()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Prefixo,Numero,Parcela,Moeda,Saldo ou Valor,Data            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA440                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ChkAbtImp(cPrefixo,cNumero,cParcela,nMoeda,cCpo,dData)

Local cAlias:=Alias()
Local nRec:=RecNo()
Local nTotAbImp := 0

dData :=IIF(dData==NIL,dDataBase,dData)
nMoeda:=IIF(nMoeda==NIL,1,nMoeda)

cCampo	:= IIF( cCpo == "V", "E1_VALOR" , "E1_SALDO" )

If Select("__SE1") == 0
	ChkFile("SE1",.F.,"__SE1")
Else
	dbSelectArea("__SE1")
Endif

dbSetOrder( 1 )
dbSeek( xFilial("SE1")+cPrefixo+cNumero+cParcela )

While !Eof() .And. E1_FILIAL == xFilial("SE1") .And. E1_PREFIXO == cPrefixo .And.;
		E1_NUM == cNumero .And. E1_PARCELA == cParcela
	If E1_TIPO != 'AB-' .And. E1_TIPO $ MVCSABT+"/"+MVCFABT+"/"+MVPIABT
		nTotAbImp +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData)
	Endif
	dbSkip()
Enddo

dbSetOrder( 1 )

dbSelectArea( cAlias )
dbGoTo( nRec )

Return ( nTotAbImp )



/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ f440JurLiq   ³ Autor ³Marcel Borges Ferreira ³ Data ³ 14/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o valor dos juros de um titulo gerado por liquidação   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA440                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function f440JurLiq(nRecno As Numeric,cAliasSE1 As Character)
	Local aArea    := GetArea()
	Local aAreaSE1 := SE1->(GetArea())
	Local aAreaSE5 := SE5->(GetArea())
	Local nVlrJuros := 0
	Local cKeySE1
	
	Default cAliasSE1 := "SE1"

	(cAliasSE1)->(MsGoTo(nRecno))
	cKeySe1 := (cAliasSE1)->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)

	SE5->(dbSetOrder(7))

	If SE5->(MsSeek(xFilial("SE5")+cKeySe1))
		While !SE5->(Eof()) .and. SE5->E5_FILIAL == xFilial("SE5") .and. ;
			cKeySe1 == SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)
			If SE5->E5_MOTBX == "LIQ" .and. SE5->E5_SITUACA != "C" .And. SE5->E5_TIPODOC == "JR"
				nVlrJuros += SE5->E5_VALOR
			Endif
			SE5->(dbSkip())
		Enddo
	Endif

	RestArea(aArea)
	RestArea(aAreaSE1)
	RestArea(aAreaSE5)

Return nVlrJuros

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ f440DesLiq   ³ Autor ³ Leonardo Castro       ³ Data ³ 13/05/16 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o valor dos descontos de um titulo gerado              ³±±
±±³          ³ por liquidação                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA440                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function f440DesLiq(nRecno As Numeric,cAliasSE1 As Character)
	Local aArea    := GetArea()
	Local aAreaSE1 := SE1->(GetArea())
	Local aAreaSE5 := SE5->(GetArea())
	Local nVlrDesc := 0
	Local cKeySE1

	Default cAliasSE1 := "SE1"
	
	(cAliasSE1)->(MsGoTo(nRecno))
	cKeySe1 := (cAliasSE1)->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)
		
	SE5->(dbSetOrder(7))
	If SE5->(MsSeek(xFilial("SE5")+cKeySe1))
		While !SE5->(Eof()) .and. SE5->E5_FILIAL == xFilial("SE5") .and. ;
			cKeySe1 == SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)
			If SE5->E5_MOTBX == "LIQ" .and. SE5->E5_SITUACA != "C" .And. SE5->E5_TIPODOC == "DC"
				nVlrDesc += SE5->E5_VALOR
			Endif
			SE5->(dbSkip())
		Enddo	
	Endif
	
	RestArea(aArea)
	RestArea(aAreaSE1)
	RestArea(aAreaSE5)
	
Return nVlrDesc

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Fa440LjTrc   ³ Autor ³ Vendas e CRM          ³ Data ³ 02/06/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ No caso do SIGALOJA faz o tratamento quano a venda possui troco³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA440                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa440LjTrc(nVlrProp,nValor,aBasesVend,cBaixa)

Local aArea    	:= GetArea()
Local cNumTit	:= SE1->E1_NUM
Local cPrefTit	:= If(Empty(SE1->E1_SERIE),SE1->E1_PREFIXO,SE1->E1_SERIE)
Local nComRep	:= 0
Local cSl4      := ""
Local lDinh     := .F.
Local nPorcVen  := 0       // Porcentagem de comissao do vendedor.
Local nPercent  := 0
Local aSL4Forma := {}      // Array contendo os tipos de pagamento e valores
Local nValBE    := 0
Local nVlrBE    := 0

Local aAreaSL1    	:= SL1->(GetArea())
Local aAreaSL4    	:= SL4->(GetArea())
Local lMVLJTROC := SuperGetMv("MV_LJTROCO",, .F.)

DEFAULT nVlrProp:= 0	    // Valor do titulo
DEFAULT nValor	:= 0	    // Valor da comissao
DEFAULT aBasesVend := {}  	// Valores para Calculo do Vendedor
DEFAULT cBaixa := "E"

nValBE := If(cBaixa == "E" , 3, 4 )
nVlrBE := If(cBaixa == "E" , 5, 6 )

cPrefTit := Padr(cPrefTit,__nTmSeri)

If Len(aBasesVend) > 0
	nPorcVen := aBasesVend[7]
EndIf
If !lMVLJTROC .And. AllTrim(Upper(SE1->E1_ORIGEM))$"LOJA010/LOJA701"
	DbSelectArea("SL1")
	DbSetOrder(2)	//L1_FILIAL + L1_SERIE + L1_DOC 
	If DbSeek(xFilial("SL1")+cPrefTit+cNumTit)	    
		If SL1->( FieldPos( "L1_TROCO1" ) ) > 0 .AND. SL1->L1_TROCO1 > 0 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se existe mais de uma forma de pagamento na venda   ³
			//³ para que seja ajustada o valor de comissao de uma forma de   ³
			//³ pagamento													 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SL4->(DbSetorder(1))
			If SL4->(DbSeek(xFilial("SL1") + SL1->L1_NUM ) )
				cSl4 := xFilial("SL1") + SL1->L1_NUM
				while !SL4->(EOF()) .AND. cSl4 == xFilial("SL4") + SL4->L4_NUM
					AADD(aSL4Forma , {SL4->L4_FORMA,SL4->L4_VALOR} )
					If IsMoney(SL4->L4_FORMA) 
						lDinh := .T.
					EndIf           
					SL4->(DbSkip())
				End
			EndIf
			
			If Len(aSL4Forma) > 1  .OR. SL1->L1_CREDITO > 0
				ASort( aSL4Forma,,,{|x,y| x[2] > y[2] } )
				If (lDinh .AND. IsMoney(SE1->E1_TIPO) ) .OR. (!lDinh .AND. (Len(aSL4Forma) >= 1 .AND. SE1->E1_TIPO $ aSL4Forma[1][1]))
				   nPercent := aBasesVend[nValBE] / aBasesVend[2]  
				   If !"CC|CD" $ SE1->E1_TIPO 
				   		aBasesVend[nValBE] := (SE1->E1_VALOR - SL1->L1_TROCO1) * nPercent	
				   Else
				   		aBasesVend[nValBE] := (SE1->E1_VLRREAL - SL1->L1_TROCO1) * nPercent				   
				   EndIf                                                                   
				   aBasesVend[nVlrBE] := aBasesVend[nValBE] * ( nPorcVen /100)				 
				   nVlrProp := aBasesVend[nValBE]
   				   nValor   := aBasesVend[nVlrBE] 
			    EndIf
			Else   // unica forma de pagamento			
				If nVlrProp == SL1->L1_VLRTOT
					nValor	 := nVlrProp * (nPorcVen/100)   
				Else
					nComRep  := nVlrProp / ( SL1->L1_VLRTOT + SL1->L1_TROCO1)
					nVlrProp := nVlrProp - ( SL1->L1_TROCO1 * nComRep)
					nValor	 := nVlrProp * (nPorcVen/100)   
				Endif	

				aBasesVend[nValBE] := nVlrProp 
				aBasesVend[nVlrBE] := nValor 				 
			EndIf
		EndIf	

	EndIf
EndIf

RestArea(aArea)
RestArea(aAreaSL1)
RestArea(aAreaSL4)

Return (aBasesVend)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ VerBxDsd   ³ Autor ³ Ramon Teodoro          ³ Data ³ 30/10/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica o motivo de baixa DSD, para não fazer parte do recalculo³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA440                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VerBxDsd(cPrefixo,cNum,cParcela,cTipo,cCliente,cLoja)

Local lBxDSD := .F.

DbSelectArea("SE5")
DbSetOrder(7)
DbGoTop()

If DbSeek(xFilial("SE5")+cPrefixo+cNum+cParcela+cTipo+cCliente+cLoja)
	If SE5->E5_MOTBX == "DSD" .And. SE5->E5_SITUACA <> "C"
		lBxDSD := .T.
	EndIf
EndIf

Return lBxDSD

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ F440Fator  ³ Autor ³ Totvs                   ³ Data ³ 30/10/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Recalculo base de comissão                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA440                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function F440Fator(nVlrRec As Numeric,nVlrLiq As Numeric,aBases As Array,nPosition As Numeric,nValIRBx As Numeric,;
                nValPis As Numeric,nValCof As Numeric,nValCsl As Numeric,lJuros As Logical, lDescont As Logical,;
                nDescont As Numeric, nJuros As Numeric, lUltimo As Logical, lLiqFat As Logical)

	Local aArea			As Array
	Local aAreaSE1		As Array
	Local aJD			As Array
	LOCAL aBasesAux     AS Array
	Local dDataBx		As Date
	Local lPccBxCr		As Logical
	Local lIrPjBxCr		As Logical
	Local lIssEmis		As Logical
	Local lRecIss		As Logical
	Local lBQ10925		As Logical
	Local lCalcComis	As Logical
	Local lBxTotal		As Logical
	Local lCOMISAB		As Logical
	Local lComiDev		As Logical
	Local lTxMoeda		As Logical
	Local nAbatimento	As Numeric
	Local nMoedaBCO		As Numeric
	Local nMoedaTit		As Numeric
	Local nVlrTit		As Numeric
	Local nProp			As Numeric
	Local nJurAux 		As Numeric
	Local nDescAux		As Numeric
	Local nSomaImp		As Numeric
	Local nABMenos		As Numeric
	Local nBaseDesc		As Numeric
	Local nBaseJur		As Numeric
    Local nTxBaixa		As Numeric
	Local nTaxaMoed		As Numeric
	Local nValMoedE5    As Numeric

	//Parametros da rotina
	Default lJuros 		:= .F.
	Default lDescont 	:= .F.
	Default nDescont	:= 0
	Default nJuros		:= 0
	Default lUltimo 	:= .F.
	Default lLiqFat		:= .F.

	aArea		:= GetArea()
	aAreaSE1	:= SE1->(GetArea())
	aJD			:= {}
	dDataBx		:= If(Empty(SE1->E1_BAIXA), dDataBase, SE1->E1_BAIXA)
	lPccBxCr	:= If(lFindPccBx,FPccBxCr(),.F.)
	lIrPjBxCr	:= If(lFindIrBx,FIrPjBxCr(),.F.)
	lIssEmis	:= SuperGetMv("MV_MRETISS",.T.,"2") == "1" 			// .T. = Na emissão
	lRecIss		:= IIf(cPaisLoc == "BRA", SA1->A1_RECISS == "1", .F.)
	lBQ10925	:= SuperGetMv("MV_BQ10925",.T.,"2") == "2" 			// .2. = Liquido 1 = Bruto
	lCalcComis	:= ComisBx(SE5->E5_MOTBX)
	lBxTotal	:= .F.
	lCOMISAB	:= SuperGetMv("MV_COMISAB",.T.,.F.) 			// Subtrai Título AB- da base de Cálculo da Comissão?
	lComiDev	:= SuperGetMv("MV_COMIDEV")
	lTxMoeda	:= SuperGetMv("MV_COMTXMO",.F.,"2") == "2"
	nAbatimento	:= SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",1,SE1->E1_EMISSAO,SE1->E1_CLIENTE,SE1->E1_LOJA)
	nMoedaBCO	:= Val(SE5->E5_MOEDA)
	nMoedaTit	:= SE1->E1_MOEDA
	nVlrTit		:= SE1->E1_VALOR
	nTaxaMoed	:= 0
	nProp		:= 0
	nJurAux 	:= 0
	nDescAux	:= 0
	nSomaImp	:= nValPis + nValCof + nValCsl + nValIRBx + IIF(lIssEmis .or. !lRecIss,0,SE5->E5_VRETISS) + nAbatimento
	nABMenos	:= 0		// Somente valor de títulos AB-
	nBaseDesc	:= 0
	nBaseJur	:= 0
	nTxBaixa   	:= 0
	nValMoedE5  := Val(SE5->E5_MOEDA)

	nJurAux	:= nJuros
	nDescAux := nDescont

	nTxBaixa := RecMoeda(dDataBx,SE1->E1_MOEDA)

	If SE1->E1_MOEDA > 1 .Or. (SE1->E1_MOEDA == 1 .And. nValMoedE5 <> SE1->E1_MOEDA )
	    If lTxMoeda
	        If SE5->E5_TXMOEDA > 0 .And. SE5->E5_TXMOEDA <> 1 
	            nTaxaMoed := SE5->E5_TXMOEDA
	        ElseIf SE1->E1_TXMOEDA > 0 
				nTaxaMoed := SE1->E1_TXMOEDA
			Else
				nTaxaMoed := nTxBaixa
	        Endif 
	    Else 
	        nTaxaMoed := nTxBaixa
	    Endif 
	EndIf

	// Caso os valores estejam em outra moeda converto para REAL afim de proporcionalizar a baixa corretamente.
	nVlrRec := If(nMoedaBCO > 1, xMoeda(nVlrRec,nMoedaBCO,1,dDataBx,3,nTaxaMoed), nVlrRec)
	nVlrTit := If(nMoedaTit > 1, xMoeda(nVlrTit,nMoedaTit,1,dDataBx,3,nTaxaMoed), nVlrTit)
	// Verifica se é uma Baixa Total.
	If ( nVlrRec - nJurAux + nDescAux + nSomaImp == nVlrTit ) .Or. ;
	( SE1->E1_SALDO - ( nVlrRec + nSomaImp - nJurAux + nDescAux ) == 0 ) .Or. ;
	( SE1->E1_SALDO == 0 .And. FunName() == "FINA330" ) .Or. ;
	( SE1->E1_SALDO == 0 .And. lUltimo )
		lBxTotal := .T.
	EndIf

	// Recompor o Valor Recebido para compor a proporcionalização da Base de Comissão
	/*   INICIO   */
	nVlrRec := nVlrRec + nDescAux - nJurAux

	// Tratamento para impostos na Emissão
	nVlrRec += If(lBxTotal .And. lCalcComis, nAbatimento, 0)

	// Tratamento para impostos na Baixa
	If lPccBxCr .And. (lBQ10925 .Or. lBxTotal)
		nVlrRec += nValPis		// PIS
		nVlrRec += nValCof		// COFINS
		nVlrRec += nValCsl		// CSLL
	EndIf

	If lIrPjBxCr .And. (lBQ10925 .Or. lBxTotal)
		nVlrRec += nValIRBx		// IRRF
	EndIf

	/*    FIM    */

	// Base de proporção = Valor do Título
	nBaseBAK := If(nMoedaTit > 1, SE1->E1_VLCRUZ, nVlrTit)

	// Calculo da Proporção - título vindo do Loja (sem pedido) não deve entrar na função F440Prop
	if nVlrRec == nBaseBak .or. empty(SE1->E1_PEDIDO) .or. !lComiDev
		nProp := nVlrRec / nBaseBak
	else
		nProp := F440Prop(nVlrRec, nBaseBak, SE1->E1_FILORIG, SE1->E1_PEDIDO, .T.)
	endif

	// Calcula juros e desconto conforme aplicável
	aJD := calcJD(aBases[nPosition,2], lJuros, lDescont, nJurAux, nDescAux, ;
		SE1->(recno()), lLiqFat, if(len(aBases[nPosition])>11, aBases[nPosition,13], NIL), aBases[nPosition,1], nVlrRec, nProp, dDataBx)
	nBaseJur := aJD[1]
	nBaseDesc := aJD[2]


	//	Subtrai AB- da base
	If lBxTotal .AND. lCOMISAB
		nABMenos := GetABMenos( SE1->E1_FILIAL , SE1->E1_PREFIXO , SE1->E1_NUM , SE1->E1_PARCELA )
	EndIf

	aBases[nPosition,4] := aBases[nPosition,4] * nProp
	aBases[nPosition,4] := aBases[nPosition,4] - nBaseDesc + nBaseJur - nABMenos

    //--Ponto de entrada que permite modificar a base de cálculo da comissão.
    IF !lLiqFat .AND. __lF440aB2
        aBasesAux := ExecBlock("F440aBa2",.F.,.F.,{"OP_NOLIQFAT",AClone(aBases)})
        IF ValType(aBasesAux) == "A" .OR. (Len(aBasesAux) == Len(aBases))
            aBases := AClone(aBasesAux)
        ENDIF
        FwFreeArray(aBasesAux)
    ENDIF

	// Valor da Comissão
	If Len( aBases[nPosition]) >= 16 .And. aBases[nPosition,14] .And. nProp != 1
		aBases[nPosition,6] := (aBases[nPosition,16] * (aBases[nPosition,7]/100))*nProp
	Else
		aBases[nPosition,6] := aBases[nPosition,4] * (aBases[nPosition,7]/100)
	EndIf

	RestArea(aAreaSE1)
	RestArea(aArea)

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ F070Fator  ³ Autor ³ Totvs                   ³ Data ³ 30/10/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Recalculo base de comissão                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA440                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function F070Fator(nVlrRec As Numeric,nVlrLiq As Numeric,aBases As Array,nBaseBAK As Numeric,nX As Numeric,;
                    lJuros As Logical,lDescont As Logical,lLiqFat As Logical,;
                    nValPis As Numeric,nValCof As Numeric,nValCsl As Numeric,nValIrf As Numeric,nSomaVA as Numeric,nSubtVA as Numeric)

	Local aArea			As Array
	Local aAreaSE1		As Array
	Local aJD			As Array
	Local aBasesAux     As Array
	Local dDataBx		As Date
	Local nAbatimento	As Numeric
	Local nProp			As Numeric
	Local nMoedaBCO		As Numeric
	Local nMoedaTit		As Numeric
	Local nVlrTit		As Numeric
	Local nTxMoeda 		As Numeric
	Local nTaxaMoed		As Numeric
	Local nJurAux 		As Numeric
	Local nDescAux		As Numeric
	Local nSomaImp 		As Numeric
	Local nMVLjCpNCC    As Numeric
	Local nABMenos		As Numeric
	Local nBaseDesc		As Numeric
	Local nBaseJur		As Numeric
	Local lPccBxCr		As Logical
	Local lIrPjBxCr		As Logical
	Local lIssEmis		As Logical
	Local lRecIss		As Logical
	Local lBQ10925		As Logical
	Local lBxTotal		As Logical
	Local lParcial      As Logical
	Local lCOMIPIS		As Logical
	Local lCOMICOF		As Logical
	Local lCOMICSL		As Logical
	Local lCOMISIR		As Logical
	Local lCOMISAB		As Logical
	Local lComiDev		As Logical
	Local lTxMoeda		As Logical
	Local nTxBaixa		As Numeric	
	Local nValMoedE5 	As Numeric 

	//Parametros de entrada
	DEFAULT lLiqFat := .F.
	DEFAULT nValPis := 0
	DEFAULT nValCof := 0
	DEFAULT nValCsl := 0
	DEFAULT nValIrf := 0
	DEFAULT nSomaVA := 0
	DEFAULT nSubtVA := 0	

	aArea		:= GetArea()
	aAreaSE1	:= SE1->(GetArea())
	aJD			:= {}
	dDataBx		:= If (Type("dBaixa") == "D" .And. !Empty(dBaixa), dBaixa , dDataBase)
	nAbatimento	:= SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",1,SE1->E1_EMISSAO,SE1->E1_CLIENTE,SE1->E1_LOJA)
	nProp		:= 0
	nMoedaBCO	:= Val(SE5->E5_MOEDA)
	nMoedaTit	:= SE1->E1_MOEDA
	nVlrTit		:= SE1->E1_VALOR
	nTxMoeda 	:= 0
	nTaxaMoed	:= 0
	nJurAux 	:= If ((lFina070 .or. lFina110 .or. lFina200 .or. lFina330), (nJuros + nMulta + nSomaVA), 0)
	nDescAux	:= If ((lFina070 .or. lFina110 .or. lFina200 .or. lFina330), (nDescont + nSubtVA), 0)
	lIssEmis	:= SuperGetMv("MV_MRETISS",.T.,"2") == "1" 			// .T. = Na emissão
	lRecIss		:= IIf(cPaisLoc == "BRA", SA1->A1_RECISS == "1", .F.)
	nSomaImp 	:= iif(cPaisloc == "BRA",aBases[nX,8] + aBases[nX,9] + aBases[nX,10] + aBases[nX,11] + IIF(lIssEmis .or. !lRecIss,0,SE5->E5_VRETISS) + nAbatimento,0) //quando o ISS é na emissão e gerado no CR, o valor dele já está contido em nAbatimento
	nMVLjCpNCC  := SuperGetMV("MV_LJCPNCC",,1)  //Tratamento para compensacao de NCC 1=Compensa em uma nova NCC; 2=Abate o saldo mesma NCC;3=Consome o Saldo da NCC; 4=Devolve o troco da NCC em dinheiro
	nABMenos	:= 0		// Somente valor de títulos AB-
	nBaseDesc	:= 0
	nBaseJur	:= 0
	lPccBxCr	:= If (lFindPccBx,FPccBxCr(),.F.)
	lIrPjBxCr	:= If (lFindIrBx,FIrPjBxCr(),.F.)
	lBQ10925	:= SuperGetMv("MV_BQ10925",.T.,"2") == "2" 			// .2. = Liquido 1 = Bruto
	lBxTotal	:= .F.
	lParcial	:= .F.
	lCOMIPIS	:= GetNewPar("MV_COMIPIS","N") == "N"
	lCOMICOF	:= GetNewPar("MV_COMICOF","N") == "N"
	lCOMICSL	:= GetNewPar("MV_COMICSL","N") == "N"
	lCOMISIR	:= GetNewPar("MV_COMISIR","N") == "N"
	lCOMISAB	:= SuperGetMv("MV_COMISAB",.T.,.F.)		// Subtrai Título AB- da base de Cálculo da Comissão?
	lComiDev	:= SuperGetMv("MV_COMIDEV") //Comissão sobre baixa por devolução FAT
	lTxMoeda	:= SuperGetMv("MV_COMTXMO",.F.,"2") == "2"
	nTxBaixa  	:= 0
	nValMoedE5  := Val(SE5->E5_MOEDA)

	If (nMVLjCpNCC == 3 .Or. nMVLjCpNCC == 4) .And. AllTrim(Upper(SE1->E1_ORIGEM))$"LOJA010/LOJA701" .AND. AllTrim(SE1->E1_TIPO)  == "CR"
		nVlrRec := aBases[nX,2]
	EndIf

	nTxBaixa := RecMoeda(dDataBx,SE1->E1_MOEDA)

	If SE1->E1_MOEDA > 1 .Or. (SE1->E1_MOEDA == 1 .And. nValMoedE5 <> SE1->E1_MOEDA )
		If Type("nTxMoeda") == "N" .And. nTxMoeda > 0 
			nTaxaMoed := nTxMoeda	
	    ElseIf lTxMoeda
	        If SE5->E5_TXMOEDA > 0 .And. SE5->E5_TXMOEDA <> 1
	            nTaxaMoed := SE5->E5_TXMOEDA
	        ElseIf SE1->E1_TXMOEDA > 0
				nTaxaMoed := SE1->E1_TXMOEDA
			Else
				nTaxaMoed := nTxBaixa
	        Endif 
	    Else 
	        nTaxaMoed := nTxBaixa
	    Endif 
	EndIf

	// Caso os valores estejam em outra moeda converto para REAL afim de proporcionalizar a baixa corretamente.
	nVlrRec := If(nMoedaBCO > 1, xMoeda(nVlrRec,nMoedaBCO,1,dDataBx,3,nTaxaMoed), nVlrRec)
	nVlrTit := If(nMoedaTit > 1, xMoeda(nVlrTit,nMoedaTit,1,dDataBx,3,nTaxaMoed), nVlrTit)

	// Verifica se já existiu baixa parcial do título.
	If (lFina070 .Or. lFina330) .And. SE1->E1_VALOR <> SE1->E1_SALDO
		lParcial := .T.
	Endif

	// Verifica se é uma Baixa Total do valor título.
	If ( nVlrRec - nJurAux + nDescAux + nSomaImp == nVlrTit ) .Or. ;
		( SE1->E1_SALDO - ( nVlrRec + nSomaImp - nJurAux + nDescAux ) == 0 ) .Or. ;
		( SE1->E1_SALDO == 0 .And. FunName() == "FINA330" )
		lBxTotal := .T.
	EndIf

	// Recompor o Valor Recebido para compor a proporcionalização da Base de Comissão
	/*   INICIO   */
	nVlrRec := nVlrRec + nDescAux - nJurAux

	// Tratamento para impostos na Emissão
	nVlrRec += If(lBxTotal, nAbatimento, 0)

	// Tratamento para impostos na Baixa
	If lPccBxCr .And. (lBQ10925 .Or. lBxTotal)
		nVlrRec += aBases[nX,8]		// PIS
		If !lCOMIPIS .And. lParcial
			nVlrRec += nValPis
		Endif	
		
		nVlrRec += aBases[nX,9]		// COFINS
		If !lCOMICOF .And. lParcial
			nVlrRec += nValCof
		Endif	
		
		nVlrRec += aBases[nX,10]	// CSLL
		If !lCOMICSL .And. lParcial
			nVlrRec += nValCsl
		Endif	
	EndIf

	If lIrPjBxCr .And. (lBQ10925 .Or. lBxTotal)
		nVlrRec += aBases[nX,11]	// IRRF
		If !lCOMISIR .And. lParcial
			nVlrRec += nValIrf
		Endif
	EndIf
	/*    FIM    */

	// Base de proporção = Valor do Título
	nBaseBAK := If(nMoedaTit > 1, SE1->E1_VLCRUZ, nVlrTit)

	// Calculo da Proporção - título vindo do Loja (sem pedido) não deve entrar na função F440Prop
	if nVlrRec == nBaseBak .or. empty(SE1->E1_PEDIDO) .or. !lComiDev
		nProp := nVlrRec / nBaseBak
	else
		nProp := F440Prop(nVlrRec, nBaseBak, SE1->E1_FILORIG, SE1->E1_PEDIDO)
	endif

	// Calcula juros e desconto conforme aplicável
	aJD := calcJD(aBases[nX,2], lJuros, lDescont, nJurAux, nDescAux, ;
		SE1->(recno()), lLiqFat, if(len(aBases[nX])>11, aBases[nX,13], NIL), aBases[nX,1], nVlrRec, nProp, dDataBx )
	nBaseJur := aJD[1]
	nBaseDesc := aJD[2]


	//	Subtrai AB- da base
	If lBxTotal .AND. lCOMISAB
		nABMenos := GetABMenos( SE1->E1_FILIAL , SE1->E1_PREFIXO , SE1->E1_NUM , SE1->E1_PARCELA )
	EndIf

	aBases[nX,4] := aBases[nX,4] * nProp
	
	aBases[nX,4] -= (nBaseDesc+nABMenos)
	aBases[nX,4] += nBaseJur

    //--Ponto de entrada que permite modificar a base de cálculo da comissão.
    IF !lLiqFat .AND. __lF440aB2
        aBasesAux := ExecBlock("F440aBa2",.F.,.F.,{"OP_NOLIQFAT",AClone(aBases)})
        IF ValType(aBasesAux) == "A" .OR. (Len(aBasesAux) == Len(aBases))
            aBases := AClone(aBasesAux)
        ENDIF
        FwFreeArray(aBasesAux)
    ENDIF

	// Valor da Comissão
	aBases[nX,6] := aBases[nX,4] * (aBases[nX,7]/100)

	RestArea(aAreaSE1)
	RestArea(aArea)

Return

/*/{Protheus.doc} calcJD
    @description Calcula valor de juros e desconto que deve ser somado e subtrído da base de cálculo da comissão.
    @author guilherme.sordi
    @since 06/07/2022
    @return Retorna array de duas posições, sendo, respectivamente JUROS e DESCONTO.
	@param nBase, Numeric, Base de comissão calculada para o vendedor em questão
	@param lJuros, Logical, Considera (soma) juros na comissão?
	@param lDesconto, Logical, Considera (subtrai) desconto na comissão?
	@param nJurBx, Numeric, Valor de juros da baixa que está sendo processada
	@param nDescBx, Numeric, Valor de desconto da baixa que está sendo processada
	@param nRecTit, Numeric, RECNO do título que está sendo processado
	@param lLiqFat, Logical, O título foi gerado por liquidação/fatura?
	@param nRecOrig, Numeric, Caso seja título de liquidação, informar o RECNO de um título pai
	@param nVlOrig, Numeric, Caso seja título de liquidação, informar o valor total baixado por liquidação (líquido, isto é, sem considerar juros e desconto)
	@param cCodVend, Character, Código do vendedor
    @type static function
/*/
Static Function calcJD(nBase as Numeric, lJuros as Logical, lDesconto as Logical, nJurBx as Numeric, nDescBx as Numeric,;
	nRecTit as Numeric, lLiqFat as Logical, aRecOrig as Array, cCodVend as Character, nVlRecBrut as Numeric, nPropBxPar as Numeric, dDataBx as Date) as Array

	Local aRet 			as Array
	Local aJDParc		as Array
	Local nVlOrig		as Numeric
	Local nJurOrig		as Numeric
	Local nDesOrig		as Numeric
	Local nJurParc		as Numeric
	Local nDesParc		as Numeric
	Local nVlTit		as Numeric
	Local nVlLiquido	as Numeric
	Local nJurUsaOri	as Numeric
	Local nDesUsaOri	as Numeric
	Local nJurUsaPar	as Numeric
	Local nDesUsaPar	as Numeric
	Local nRazLiq		as Numeric
	Local nRazJur		as Numeric
	Local nRazDesc		as Numeric
	Local nRazJurR		as Numeric
	Local nRazDescR		as Numeric
	Local nBaseJur		as Numeric
	Local nBaseDesc		as Numeric
	Local nRazBaseBx	as Numeric
	Local nX			as Numeric
	Local nTxMoeda		as Numeric
	Local nVlrBase		as Numeric

	aRet 		:= {0,0}
	aJDParc 	:= {}
	nVlOrig		:= 0
	nJurOrig	:= 0
	nDesOrig	:= 0
	nJurParc	:= 0
	nDesParc	:= 0
	nVlTit		:= 0
	nVlLiquido	:= 0
	nJurUsaOri	:= 0
	nDesUsaOri	:= 0
	nJurUsaPar	:= 0
	nDesUsaPar	:= 0
	nRazLiq		:= 0
	nRazJur		:= 0
	nRazDesc	:= 0
	nRazJurR	:= 0
	nRazDescR	:= 0
	nBaseJur	:= 0
	nBaseDesc	:= 0
	nRazBaseBx 	:= ( nBase * nPropBxPar ) / nVlRecBrut
	nX			:= 0
	nTxMoeda	:= 0
	nVlrBase	:= 0

	If !lJuros .and. !lDesconto
		Return aRet
	EndIf

	// Calcula juros e desconto conforme aplicável
	If lLiqFat .and. aRecOrig != NIL .and. nVlOrig != NIL

		If SE1->(recno()) != nRecTit
			SE1->(DbGoTo(nRecTit))
		EndIf
		nVlTit := SE1->E1_VALOR

		//Recupera juros e desconto pertinente ao vendedor em questão no título pai da liquidação
		nVlOrig  := Fa440VlLiq(SE1->E1_NUMLIQ, cCodVend, , , 1)

		If nDescBx > 0 .And. SE1->E1_MOEDA > 1
			nTxMoeda	:= SE1->E1_TXMOEDA
			If nTxMoeda == 0
				nTxMoeda	:= RecMoeda(dDataBx, SE1->E1_MOEDA)
			Endif
			
			nVlrBase := xMoeda(nVlTit, SE1->E1_MOEDA, 1, dDataBx, , nTxMoeda, 1 ) 

			If nVlrBase == nBase
				nDescBx  := xMoeda(nDescBx, 1, SE1->E1_MOEDA, dDataBx, __nTmBase, 1, nTxMoeda )
			Else
				If nVlTit == nVlOrig
					nDescBx := xMoeda(nDescBx, 1, SE1->E1_MOEDA, dDataBx, __nTmBase, 1, (nbase / nVlTit) )
				Else
					nDescBx := xMoeda(nDescBx, 1, SE1->E1_MOEDA, dDataBx, __nTmBase, 1, (nbase / nVlOrig) )
				Endif
			Endif
		Endif

		If Len(aRecOrig) > 0
			For nX := 1 To Len(aRecOrig)
				nJurOrig += f440JurLiq(aRecOrig[nX])
				nDesOrig += f440DesLiq(aRecOrig[nX])
			Next nX
		Endif

		//Calcula juros e desconto de renegociação do título filho que está sendo baixado.
		//Quando não considera juros e desconto, é preciso desconsiderar tanto no pai
		//quanto no filho para chegar na razão correta	
		aJDParc := parcLiqJD(nRecTit)
		nJurParc := aJDParc[1]
		nDesParc := aJDParc[2]

		nVlLiquido := nVlTit - nJurParc + nDesParc
		
		nJurUsaOri := if(lJuros, nJurOrig, 0)
		nDesUsaOri := if(lDesconto, nDesOrig, 0)
		
		nJurUsaPar := if(lJuros, nJurParc, 0)
		nDesUsaPar := if(lDesconto, nDesParc, 0)

		nRazLiq := (nVlOrig + nJurUsaOri - nDesUsaOri) / (nVlLiquido + nJurUsaPar - nDesUsaPar)

		//Juros e desconto da baixa
		nRazJur := nJurBx / nVlOrig
		nRazDesc := nDescBx / nVlOrig

		nBaseJur := if(lJuros, (nBase * nRazLiq * nRazJur), 0) 
		nBaseDesc := if(lDesconto, (nBase * nRazLiq * nRazDesc), 0)

		//Juros e desconto da renegociação
		nRazJurR := nJurUsaOri / nVlOrig
		nRazDescR := nDesUsaOri / nVlOrig

		nBaseJur += if(lJuros, (nBase * nRazJurR), 0)
		nBaseDesc += if(lDesconto, (nBase * nRazDescR), 0)
	Else
		nBaseJur := if(lJuros, nJurBx, 0)
		nBaseDesc := if(lDesconto, nDescBx, 0)	

		//Se algum imposto é desconsiderado na base de cálculo da comissão, deve ser desconsiderado também no juros/desconto, na mesma proporção.
		nBaseJur *= nRazBaseBx
		nBaseDesc *= nRazBaseBx
	EndIf

	FwFreeArray(aRet)
	aRet := {nBaseJur, nBaseDesc}

return aRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ F440LiqFat  ³ Autor ³ Totvs                ³ Data ³ 19/04/2013 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Recupera os recnos e adiciona no array aRecSE1 os recnos dos   ³±±
±± titulos que origens da fatura que vieram de liquidação                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA440                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa440LiqFat(aRecSE1, aTitLiq)
Local aAreaSE1 := GetArea("SE1")
Local aAreaSE5 := GEtArea("SE5")
Local iX := 1
Local nPos := 0
Local nTamRec := Len(aRecSE1)

If Select("__SE1") == 0
	ChkFile("SE1",.F.,"__SE1")
Endif

While iX <= nTamRec
	__SE1->(dbGoTo(aRecSE1[iX]))
	If !Empty(__SE1->E1_NUMLIQ)
		dbSelectArea("SE5")
		dbSetOrder(10)
		If dbSeek(xFilial("SE5")+__SE1->E1_NUMLIQ)
			While !SE5->(Eof()) .and. xFilial("SE5") == SE5->E5_FILIAL .And. __SE1->E1_NUMLIQ == Substr(SE5->E5_DOCUMEN, 1, Len(__SE1->E1_NUMLIQ))
				If SE5->E5_MOTBX == "LIQ"
					dbSelectArea("SE1")
					dbSetOrder(1)
					If dbSeek(xFilial("SE1")+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO)
						nPos := aScan(aRecSE1, SE1->(RecNo()))
						If nPos == 0
							Aadd(aRecSE1, SE1->(Recno()) )
							Aadd(aTitLiq, SE1->(Recno()))
						Endif
					EndIf
				EndIf
				SE5->(dbSkip())
			EndDo
			aDel(aRecSE1, iX)
			aSize(aRecSE1, Len(aRecSE1)-1)
			nTamRec := Len(aRecSE1)
			iX -= 1
		Endif
	Endif
	iX++
EndDo

RestArea(aAreaSE1)
RestArea(aAreaSE5)
Return()

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Fa440ReLiq³ Autor ³Rogerio Melonio        ³ Data ³20.04.2018³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna um array dos titulos de origem                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 := Codigo da Liquidacao                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa440ReLiq(cNumLiq as Character,aLiquid as Array,aValLiq as Array,aSeqCont as Array,aNLiquid as Array,cFilOriSe5 as Character)
Local nPosLiq 		as Numeric
Local aArea   		as Array
Local cAliasSE5		as Character
Local lRelat   		as Logical
Local aStruSE5		as Array
Local cQuery   		as Character
Local aTitReliq 	as Array
Local nY			as Numeric
Local nPNLiquid		as Numeric
Local cFilOld 		as Character

DEFAULT aLiquid  := {}
DEFAULT aValLiq  := {}
DEFAULT aSeqCont := {}
DEFAULT aNLiquid := {}
DEFAULT cFilOriSe5  := cFilAnt

nPosLiq := 0
aArea    := GetArea()
cAliasSE5:= "SE5"
lRelat   := IsInCallStack("MATR540")
aStruSE5 := {}
cQuery   := ""
aTitReliq := {} 
nY		:= 0
nPNLiquid	:= 0
cFilOld := "" 

cFilOld := cFilAnt
cFilAnt := cFilOriSe5

aStruSE5 := SE5->(dbStruct())
cAliasSE5 := GetNextAlias()

cQuery := "SELECT E5_FILIAL, E5_MOTBX,   E5_DOCUMEN, E5_CLIFOR, E5_LOJA, E5_PREFIXO, E5_NUMERO, E5_PARCELA, "
cQuery += "       E5_TIPO,   E5_SITUACA, E5_DATA,    E5_VALOR,  E5_SEQ,  E5_FATPREF, E5_FATURA "

If lRelat
	cQuery += ",E5_TIPODOC "
EndIf

cQuery += ", E1_NUMLIQ, E1_BCOCHQ, E1_FATURA, SE1.R_E_C_N_O_ RECSE1, E1_VLCRUZ, E1_FATPREF, E1_FATURA, E1_STATUS, SE1.R_E_C_N_O_ RECSE1"
cQuery += " FROM " + RetSqlName("SE5") + " SE5 "
cQuery += " INNER JOIN " + RetSqlName("SE1") + " SE1 ON " 
cQuery += " SE1.E1_CLIENTE = SE5.E5_CLIFOR AND SE1.E1_LOJA = SE5.E5_LOJA "
cQuery += " AND SE1.E1_PREFIXO = SE5.E5_PREFIXO AND SE1.E1_NUM = SE5.E5_NUMERO AND SE1.E1_PARCELA = SE5.E5_PARCELA "
cQuery += " AND SE1.E1_TIPO = SE5.E5_TIPO AND SE1.D_E_L_E_T_ = ' ' "
cQuery += " WHERE SE5.E5_FILIAL='" + xFilial("SE5") + "' AND SE1.E1_FILIAL = '" + xFilial("SE1") + "' AND "
cQuery += "SE5.E5_DOCUMEN='"+cNumLiq+"' AND "
cQuery += "SE5.E5_MOTBX = 'LIQ' AND "
cQuery += "SE5.E5_SITUACA <> 'C' AND "
cQuery += "SE5.D_E_L_E_T_ = ' ' AND "
cQuery += "SE1.D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE5)

For ny := 1 To Len(aStruSE5)
	If aStruSE5[ny][2]<>"C" .And. FieldPos(aStruSE5[ny][1])<>0
		TcSetField(cAliasSE5,aStruSE5[ny][1],aStruSE5[ny][2],aStruSE5[ny][3],aStruSE5[ny][4])
	EndIf
Next ny

// Condição do While antiga corrigida, P12 só será executada em SQL e o filtro já foi feito pela query acima 
While !(cAliasSE5)->(Eof())
	If Empty((cAliasSE5)->E1_NUMLIQ) .And. Empty((cAliasSE5)->E1_BCOCHQ) .And. Empty((cAliasSE5)->E1_FATURA) 

		nPNLiquid := aScan(aNLiquid,{|x| x[1] == (cAliasSE5)->RECSE1 })
		If nPNLiquid == 0
			aadd( aNLiquid, {(cAliasSE5)->RECSE1,(cAliasSE5)->E5_DOCUMEN} )
		EndIf

		nPosLiq := aScan( aLiquid , (cAliasSE5)->RECSE1 )
		If nPosLiq == 0
			aadd( aLiquid, (cAliasSE5)->RECSE1 )

			nValSE5 := (cAliasSE5)->E5_VALOR
			If lRelat
				If (cAliasSE5)->E5_TIPODOC = "JR"
					nValSE5 := 0
				Endif
			Endif

			aAdd(aValLiq,{ (cAliasSE5)->E5_DATA, nValSE5 })

			aAdd(aSeqCont,(cAliasSE5)->E5_SEQ)

		ElseIf Len(aValLiq) > 0 .AND. Len(aValLiq) >= nPosLiq
			aValLiq[nPosLiq][1]:=(cAliasSE5)->E5_DATA
			aValLiq[nPosLiq][2]+=(cAliasSE5)->E5_VALOR
		Else
			aAdd(aValLiq,{(cAliasSE5)->E5_DATA,(cAliasSE5)->E5_VALOR})
		EndIf
	ElseIf (cAliasSE5)->E1_NUMLIQ == cNumLiq .And. (cAliasSE5)->E1_STATUS <> "R" //Reliquidacoes anteriores a versao 811
		CONOUTR("Erro Titulo : " + (cAliasSE5)->E5_PREFIXO + (cAliasSE5)->E5_NUMERO + (cAliasSE5)->E5_PARCELA + (cAliasSE5)->E5_TIPO )
		ProcLogAtu("ERRO","ERRO_LIQUIDACAO","Erro no processamento de liquidação titulo : " + (cAliasSE5)->E5_PREFIXO + (cAliasSE5)->E5_NUMERO + (cAliasSE5)->E5_PARCELA + (cAliasSE5)->E5_TIPO )
	ElseIf !Empty((cAliasSE5)->E1_NUMLIQ)
		nValSE5 := (cAliasSE5)->E5_VALOR
		If lRelat
			If (cAliasSE5)->E5_TIPODOC = "JR"
				nValSE5 := 0
			Endif
		Endif
		aAdd(aTitReliq,{ (cAliasSE5)->RECSE1, (cAliasSE5)->E5_DATA, nValSE5, (cAliasSE5)->E5_SEQ } )
	Endif
	(cAliasSE5)->(dbSkip())
Enddo

dbSelectArea(cAliasSE5)
dbCloseArea()
RestArea(aArea)

cFilAnt := cFilOld

Return aTitReliq

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FVldExcCom  ³ Autor ³ Totvs              ³ Data ³ 30/08/2018 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se comissão pode ser excluida.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA440                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FVldExcCom(cFilSE1,cPrefSE1,cNumSE1,cParcSE1,cTipoSE1,lFINA440,cSinal,cSeq,lAutomato)
Local cQueryE2  := ""
Local cQueryE3  := ""
Local cAliasSE3 := GetNextAlias()
Local cAliasSE2 := ""
Local cProcCom  := ""
Local cFilSE2   := ""
Local cPrefSE2  := ""
Local cParcSE2  := ""
Local cTipoSE2  := ""
Local cNumSE2   := ""
Local nTamIni   := 0
Local lExclui   := .T.

Default cFilSE1     := ""
Default cPrefSE1    := ""
Default cNumSE1     := ""
Default cParcSE1    := ""
Default cTipoSE1    := ""
Default lFINA440    := .T.
Default cSinal      := ""
Default cSeq        := ""
Default lAutomato   := .F.

If lFINA440
//Posiciono na comissão cancelada para deletar também a origem 											
	If cSinal == '-'
		aAreaSE3  	:= SE3->(GetArea())
		//Verifica qual eh o Recno que satisfaca a selecao.
		cQuery := "SELECT SE3.R_E_C_N_O_ RECNO, SE3.E3_PROCCOM "
		cQuery += "  FROM "+RetSqlName("SE3")+" SE3 "
		cQuery += " WHERE SE3.E3_FILIAL   = '"+xFilial("SE3")+"'"
		cQuery += "  AND SE3.E3_VEND    	= '"+SE3->E3_VEND+"'"
		cQuery += "  AND SE3.E3_CODCLI  	= '"+SE3->E3_CODCLI+"'"
		cQuery += "  AND SE3.E3_LOJA    	= '"+SE3->E3_LOJA+"'"
		cQuery += "  AND SE3.E3_PREFIXO 	= '"+SE3->E3_PREFIXO+"'"
		
		cQuery += "  AND SE3.E3_NUM     	= '"+SE3->E3_NUM+"'"
		cQuery += "  AND SE3.E3_PARCELA 	= '"+SE3->E3_PARCELA+"'"
		cQuery += "  AND SE3.E3_TIPO    	= '"+SE3->E3_TIPO+"'"
		cQuery += "  AND SE3.E3_SEQ 		= '"+SE3->E3_SEQ+"'"
		cQuery += "  AND SE3.E3_BAIEMI		= 'B' "
		cQuery += "  AND SE3.E3_ORIGEM NOT IN(' ','L') "																				
		cQuery += "  AND SE3.D_E_L_E_T_ = ' ' "																						
		
		cQuery := ChangeQuery(cQuery)										
	  	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE3)
	  	
	  	SE3->(dbGoTo((cAliasSE3)->RECNO))
	  	cProcCom := (cAliasSE3)->E3_PROCCOM	
	  	
	  	If !Empty(cProcCom)
			RecLock("SE3")
				dbDelete()
			MsUnlock()
		Endif	
		
		If !Empty(cProcCom)
			cAliasSE2 := GetNextAlias()
			
			nTamIni:= 1
			cFilSE2 := SUBSTR(cProcCom,1,TAMSX3("E2_FILIAL")[1])
			nTamIni += TAMSX3("E2_FILIAL")[1]
			cPrefSE2:= SUBSTR(cProcCom,nTamIni,TAMSX3("E2_PREFIXO")[1])
			nTamIni += TAMSX3("E2_PREFIXO")[1]
			cNumSE2 := SUBSTR(cProcCom,nTamIni,TAMSX3("E2_NUM")[1])
			
			cQueryE2 := "SELECT SE2.R_E_C_N_O_ RECNO,SE2.E2_FILIAL,SE2.E2_PREFIXO,SE2.E2_NUM,SE2.E2_PARCELA,SE2.E2_TIPO "
			cQueryE2 += " FROM "+RetSqlName("SE2")+" SE2 "
			cQueryE2 += "	WHERE SE2.E2_FILIAL   = '"+cFilSE2+"'"								
			cQueryE2 += "  AND SE2.E2_PREFIXO 	= '"+cPrefSE2+"'"
			cQueryE2 += "  AND SE2.E2_NUM     	= '"+cNumSE2+"'"																													
			cQueryE2 += "  AND SE2.D_E_L_E_T_ = ' ' "																						
			
			cQueryE2 := ChangeQuery(cQueryE2)										
		  	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQueryE2),cAliasSE2)

			SE2->(dbGoTo((cAliasSE2)->RECNO))
			//Realizo a deleção da comissão no contas a pagar caso não tenha sido paga.
			If Alltrim(SE2->E2_TIPO) = "DP" .and. Empty(SE2->E2_BAIXA)
				RecLock("SE2")
					dbDelete()
				MsUnlock()
			Endif

			(cAliasSE2)->(dbCloseArea())

		Endif	
		nTamIni:= 0
		RestArea(aAreaSE3)
	Endif 
Else 
	cQueryE3 := "SELECT SE3.R_E_C_N_O_ RECNO,SE3.E3_FILIAL,SE3.E3_PREFIXO,SE3.E3_NUM,SE3.E3_PARCELA,SE3.E3_TIPO,SE3.E3_PROCCOM "
	cQueryE3 += " FROM "+RetSqlName("SE3")+" SE3 "
	cQueryE3 += " WHERE SE3.E3_FILIAL  = '"+cFilSE1+"'"								
	cQueryE3 += "  AND SE3.E3_PREFIXO 	= '"+cPrefSE1+"'"
	cQueryE3 += "  AND SE3.E3_NUM     	= '"+cNumSE1+"'"		
	cQueryE3 += "  AND SE3.E3_PARCELA  = '"+cParcSE1+"'"	
	cQueryE3 += "  AND SE3.E3_TIPO    	= '"+cTipoSE1+"'"	
	cQueryE3 += "  AND SE3.E3_SEQ 		= '"+cSeq+"'"																											
	cQueryE3 += "  AND SE3.D_E_L_E_T_ = ' ' "		
	
	cQueryE3 := ChangeQuery(cQueryE3)										
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQueryE3),cAliasSE3)
	
	SE3->(dbGoTo((cAliasSE3)->RECNO))
	cProcCom := (cAliasSE3)->E3_PROCCOM	
		
	If !Empty(cProcCom)
													
		cAliasSE2 := GetNextAlias()
		
		nTamIni:= 1
		cFilSE2 := SUBSTR(cProcCom,1,TAMSX3("E2_FILIAL")[1])
		nTamIni += TAMSX3("E2_FILIAL")[1]
		cPrefSE2:= SUBSTR(cProcCom,nTamIni,TAMSX3("E2_PREFIXO")[1])
		nTamIni += TAMSX3("E2_PREFIXO")[1]
		cNumSE2 := SUBSTR(cProcCom,nTamIni,TAMSX3("E2_NUM")[1])
		
		cQueryE2 := "SELECT SE2.R_E_C_N_O_ RECNO,SE2.E2_FILIAL,SE2.E2_PREFIXO,SE2.E2_NUM,SE2.E2_PARCELA,SE2.E2_TIPO,SE2.E2_BAIXA "
		cQueryE2 += " FROM "+RetSqlName("SE2")+" SE2 "
		cQueryE2 += "	WHERE SE2.E2_FILIAL   = '"+cFilSE2+"'"								
		cQueryE2 += "  AND SE2.E2_PREFIXO 	= '"+cPrefSE2+"'"
		cQueryE2 += "  AND SE2.E2_NUM     	= '"+cNumSE2+"'"																													
		cQueryE2 += "  AND SE2.D_E_L_E_T_ = ' ' "
		cQueryE2 += "  ORDER BY R_E_C_N_O_ DESC "																						
		
		cQueryE2 := ChangeQuery(cQueryE2)										
	  	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQueryE2),cAliasSE2)
	  	
	  	cParcSE2 := (cAliasSE2)->E2_PARCELA
	  	cTipoSE2 := (cAliasSE2)->E2_TIPO
	
		SE2->(dbGoTo((cAliasSE2)->RECNO))
		
		If Alltrim(SE2->E2_TIPO) = "DP" .and. !Empty(SE2->E2_BAIXA)
			Help(NIL, NIL, "BxNaoCanc.", NIL, STR0019+CRLF+CRLF+;// Baixa não pode ser cancelada. Título possui comissão paga.
																STR0014 +' "'+Alltrim(cFilSE2)+'" '+CRLF+;
																STR0015 +' "'+Alltrim(cPrefSE2)+'" '+CRLF+;
																STR0016 +' "'+Alltrim(cNumSE2)+'" '+CRLF+;
																STR0017 +' "'+Alltrim(cParcSE2)+'" '+CRLF+;
																STR0018 +' "'+Alltrim(cTipoSE2)+'" ' , 1, 0)												
			lExclui := .F.
		ElseIf Alltrim(SE2->E2_TIPO) = "DP" .and. Empty(SE2->E2_BAIXA)
			If lAutomato .Or. MsgYesNo(STR0020) //Existe Título de comissão gerado no Contas a Pagar para esta Baixa, deseja exclui-lo agora?..
												 
				RecLock("SE3") // Deleto SE3 relacionado a baixa
					dbDelete()
				MsUnlock()
		        (cAliasSE2)->(DbGoTop())
		        While (cAliasSE2)->(!EOF()) .and. Empty((cAliasSE2)->E2_BAIXA)
		        
		        	cParcSE2 := (cAliasSE2)->E2_PARCELA
		            
		            RecLock("SE2") // Deleto SE2 relacionada
						dbDelete()
					MsUnlock()                     
					
					If Empty((cAliasSE2)->E2_BAIXA)
						MsgInfo( STR0022+CRLF+CRLF+;// Título relacionado abaixo referente à Comissão desta baixa cancelada/excluída foi excluído do Contas a Pagar.
																		STR0014 +' "'+Alltrim(cFilSE2)+'" '+CRLF+;
																		STR0015 +' "'+Alltrim(cPrefSE2)+'" '+CRLF+;
																		STR0016 +' "'+Alltrim(cNumSE2)+'" '+CRLF+;
																		STR0017 +' "'+Alltrim(cParcSE2)+'" '+CRLF+;
																		STR0018 +' "'+Alltrim(cTipoSE2)+'" ' +CRLF+CRLF+;
																		STR0023+CRLF)
					Else 
						Help(NIL, NIL, "BxNaoCanc.", NIL, STR0019+CRLF+CRLF+;// Baixa não pode ser cancelada. Título possui comissão paga.
																STR0014 +' "'+Alltrim(cFilSE2)+'" '+CRLF+;
																STR0015 +' "'+Alltrim(cPrefSE2)+'" '+CRLF+;
																STR0016 +' "'+Alltrim(cNumSE2)+'" '+CRLF+;
																STR0017 +' "'+Alltrim(cParcSE2)+'" '+CRLF+;
																STR0018 +' "'+Alltrim(cTipoSE2)+'" ' , 1, 0)												
						lExclui := .F.					
					Endif
					(cAliasSE2)->(DBSKIP())
				ENDDO
				
			Else
				ALERT( STR0021+CRLF+CRLF+;// Título possui comissão gerada, se faz necessário excluir o Título de comissão relacionado abaixo no Contas a Pagar para que este Cancelamento/Exclusão seja Efetivo.
																STR0014 +' "'+Alltrim(cFilSE2)+'" '+CRLF+;
																STR0015 +' "'+Alltrim(cPrefSE2)+'" '+CRLF+;
																STR0016 +' "'+Alltrim(cNumSE2)+'" '+CRLF+;
																STR0017 +' "'+Alltrim(cParcSE2)+'" '+CRLF+;
																STR0018 +' "'+Alltrim(cTipoSE2)+'" ' +CRLF)
				lExclui := .F.
			EndIf 
		EndIf

		(cAliasSE2)->(dbCloseArea())
	EndIf	
EndIf

If Select(cAliasSE3) > 0
	(cAliasSE3)->(dbCloseArea())
EndIf

Return lExclui

//-------------------------------------------------------------------
/*/{Protheus.doc} VlrProp
Função para proporcionalizar o valor da comissão para quando o título 
pai possui baixa parcial e o parametro MV_COMILIQ estiver 2.

@author Alberto Teixeira
@since 30/03/2020
@version P12.1.27
/*/
//-------------------------------------------------------------------
Function VlrProp(aLiquid,aBases,nCntFor2) as nRet

Local nRet as Numeric
Local aArea as Array
Local aAreaSE1 as Array
Local aAreaSE3 as Array
Local nPercBase as Numeric
Local nX as Numeric
Local cKeySe1 as Character
Local nVlrParc as Numeric
Local nSe3Comis as Numeric
Local lRecalc as Logical
Local nSe5Bx as Numeric
Local nVlrPropBx as Numeric
Local cFilSe3 as Character

Default aLiquid := {}
Default aBases := {}
Default nCntFor2 := 0

nRet := 0
aArea := GetArea()
aAreaSE1 := SE1->(GetArea())
aAreaSE3 := SE3->(GetArea())
nPercBase := 0
nX := 0
cKeySe1 := ""
nVlrParc := 0
nSe3Comis := 0
lRecalc := .F.
nSe5Bx := 0
nVlrPropBx := 0
cFilSe3 := ""

If !lComiliq
	DbSelectArea("SE1")
	If Len(aLiquid) > 0
		nPercBase := aBases[nCntFor2][12]*(aBases[nCntFor2][7]/100)
	Else 
		nPercBase := aBases[nCntFor2][6]
	EndIf
	For nX := 1 To Len(aLiquid)
		SE1->(DbGoto(aLiquid[nX]))
		cFilSe3 := xFilial("SE3",SE1->E1_FILORIG)
		SE3->(DbSetOrder(3))
		cKeySe1 :=  aBases[nCntFor2][1]+SE1->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)
		If SE3->(DbSeek(cFilSe3+cKeySe1))
			While !SE3->(Eof()) .and. SE3->E3_FILIAL == cFilSe3 .and. ;
				cKeySe1 == SE3->(E3_VEND+E3_CODCLI+E3_LOJA+E3_PREFIXO+E3_NUM+E3_PARCELA+E3_TIPO)
				nSe3Comis += SE3->E3_COMIS
				lRecalc := .T.
				SE3->(DbSkip())
			EndDo
		EndIf
	Next nX
Else
	nRet := aBases[nCntFor2][6]
EndIf

If !lRecalc
	nRet := aBases[nCntFor2][6]
Else
	nSe5Bx := VlrSe5Bx(aLiquid,aBases[nCntFor2][1]) 
	
	nVlrPropBx := aBases[nCntFor2][12] - nSe5Bx - aBases[nCntFor2][3]

	nIndice := aBases[nCntFor2][4] / nVlrPropBx
	
	nVlrParc := nPercBase-nSe3Comis

	If nVlrParc < aBases[nCntFor2][6] .Or. Len(aLiquid) > 0
		nRet := nIndice * nVlrParc
		aBases[nCntFor2][6] := nRet
		aBases[nCntFor2][7] := (aBases[nCntFor2][6]/aBases[nCntFor2][4])*100
	Else
		nRet := aBases[nCntFor2][6]
	Endif
EndIf

RestArea(aAreaSE3)
RestArea(aAreaSE1)
RestArea(aArea)

Return nRet		

//-------------------------------------------------------------------
/*/{Protheus.doc} VlrSe5Bx
Soma os valores das baixas parciais dos títulos pai envolvidos
na liquidação.

@author Alberto Teixeira
@since 02/04/2020
@version P12.1.27
/*/
//-------------------------------------------------------------------
Function VlrSe5Bx(aLiquid,aCodVend) as nSe5Bx

Local nSe5Bx as Numeric
Local aArea as Array
Local aAreaSE5 as Array
Local nX as Numeric
Local cKeySe1 as Character
Local cFilSe5 as Character

nSe5Bx := 0
aArea := GetArea()
aAreaSE5 := SE5->(GetArea())
nX := 0
cKeySe1 := ""
cFilSe5 := ""

For nX := 1 To Len(aLiquid)
	SE1->(DbGoto(aLiquid[nX]))
	// Tratamento para se o compartilhamento das tabelas forem diferentes
	cFilSe5 := xFilial("SE5",SE1->E1_FILORIG)
	If PesqVend(aLiquid[nX],aCodVend)
		SE5->(DbSetOrder(7))
		cKeySe1 := SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)
		If SE5->(DbSeek(cFilSe5+cKeySe1))
			While !SE5->(Eof()) .and. SE5->E5_FILIAL == cFilSe5 .and. ;
				cKeySe1 == SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)
				If SE5->E5_SITUACA != "C" .and. SE5->E5_MOTBX <> 'LIQ'
					If SE5->E5_RECPAG == "R"
						nSe5Bx += SE5->E5_VALOR
					Else
						nSe5Bx -= SE5->E5_VALOR
					EndIf
				EndIf
				SE5->(DbSkip())
			EndDo
		EndIf
	EndIf	
Next nX			

RestArea(aAreaSE5)
RestArea(aArea)
Return nSe5Bx

//-------------------------------------------------------------------
/*/{Protheus.doc} PesqVend
Verifica se o vendedor posicionado está em algum título negociado.

@author Alberto Teixeira
@since 06/04/2020
@version P12.1.27
/*/
//-------------------------------------------------------------------
Function PesqVend(aLiquid,aCodVend) as lRet

Local lRet as Logical
Local cVend as Character
Local cVendedor as Character
Local nCntFor as Numeric

lRet := .F.
cVend := "1"
cVendeor := ""
nCntFor := 0

For nCntFor := 1 To __nVend
	cVendedor := SE1->(FieldGet(SE1->(FieldPos("E1_VEND"+cVend))))
	If aCodVend == cVendedor
		lRet := .T.
		Exit
	EndIf
	cVend := Soma1(cVend,1)
Next nCntFor

Return lRet	

//-------------------------------------------------------------------
/*/{Protheus.doc} VldTitLJ
Verifica se o titulo tem origem loja e se existe SE3

@author Francisco Oliveira
@since 12/05/2020
@version P12.1.27
/*/
//-------------------------------------------------------------------

Static Function VldTitLJ() As Logical

Local lRet     As Logical
Local aAreaSE1 As Array
Local aAreaSE3 As Array
Local cQuery   As Character
Local cFilSE3  As Character
Local nRecnoLj As Numeric

lRet 		:= .T.
aAreaSE1	:= SE1->(GetArea())
aAreaSE3	:= SE3->(GetArea())
cQuery		:= ""
cFilSE3		:= FWModeAccess("SE3",3)
nRecnoLj	:= 0

If "LOJ" $ SE1->E1_ORIGEM .And. SE1->E1_TIPOLIQ == 'LIQ'

	If __oStVldLJ == NIL
		cQuery := "SELECT SE3.R_E_C_N_O_ RECNO "
		cQuery += "FROM " + RetSqlName("SE3") + " SE3 "
		cQuery += "WHERE "
		cQuery += "SE3.E3_FILIAL  = ? AND "
		cQuery += "SE3.E3_PREFIXO = ? AND "
		cQuery += "SE3.E3_NUM     = ? AND "
		cQuery += "SE3.E3_PARCELA = ? AND "
		cQuery += "SE3.E3_TIPO    = ? AND "
		cQuery += "SE3.E3_ORIGEM  = ? AND "
		cQuery += "SE3.D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)

		__oStVldLJ := if(__lExecSt, FWExecStatement():New(cQuery), FWPreparedStatement():New(cQuery) )
	EndIf

	__oStVldLJ:SetString(1, If(cFilSE3 = "C", SE1->E1_FILORIG, xFilial("SE3")))
	__oStVldLJ:SetString(2, SE1->E1_PREFIXO)
	__oStVldLJ:SetString(3, SE1->E1_NUM)
	__oStVldLJ:SetString(4, SE1->E1_PARCELA)
	__oStVldLJ:SetString(5, SE1->E1_TIPO)
	__oStVldLJ:SetString(6, 'L')

	nRecnoLj := if(__lExecSt, __oStVldLJ:ExecScalar('RECNO'), MpSysExecScalar(__oStVldLJ:GetFixQuery(),"RECNO") )

	If nRecnoLj > 0
		lRet := .F.
	Endif
Endif

RestArea(aAreaSE3)
FwFreeArray(aAreaSE3)

RestArea(aAreaSE1)
FwFreeArray(aAreaSE1)

Return lRet 

//-------------------------------------------------------------------
/*/{Protheus.doc} GetABMenos
Retorna valor somente de título tipo AB- para o título passado

@author rafael rondon
@since 25/06/2020
@version P12.1.27
/*/
//-------------------------------------------------------------------
Static Function GetABMenos( cFilTit As Character , cPrefixo As Character , cTitulo As Character , cParcela As Character ) As Numeric

Local nABMenos		As Numeric
Local aArea			As Array
Local cQuery 		As Character

aArea	:= GetArea()

cQuery := "SELECT E1_VALOR FROM " + RetSqlName("SE1")
cQuery += "WHERE E1_FILIAL = '" + cFilTit + "' "
cQuery += "AND E1_PREFIXO = '" + cPrefixo + "' "
cQuery += "AND E1_NUM = '" + cTitulo + "' "
cQuery += "AND E1_PARCELA = '" + cParcela + "' "
cQuery += "AND E1_TIPO = 'AB-' "
cQuery += "AND D_E_L_E_T_ = ' ' "
cQuery := ChangeQuery(cQuery)

nABMenos := MpSysExecScalar(cQuery,"E1_VALOR")

RestArea(aArea)

Return nABMenos
/*{Protheus.doc} ProcFI7
Funcao recursiva para montar um array com todas as liquidacoes e re-liquidacoes e suas baixas para efetuar os calculos corretos proporcionalizando conforme a baixa do titulo final

@type static function

@param cChRecur, character, chave de pesquisa na FI7 para pegar o titulo original
@param aTits, array, array contendo todos as liquidacoes, a amarracao entre a liquidacao Origem e Destino eh a posicao 5 e 6 do array
@param nNivRecus, numeric, nivel de controle da recursividade

@author  Gustavo G. Rueda
@version 12.1.2210
@since   28/11/2023
*/
static function ProcFI7( cChRecur as character, aTits as array, aLiqs as array, nNivRecus as numeric, nNccLiqSE1 as numeric)
	Local 	aAreaSav		as	array
	Local 	nSe5Bx			as	numeric
	Local	cFilSe5			as	character
	Local 	nNCC			as	numeric
	Local	cChaveFI7		as	character

	Default	cChRecur		:=	SE1->( E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA )
	Default	aTits			:=	{}
	Default	aLiqs			:=	{}
	Default nNivRecus		:=	0
	Default nNccLiqSE1		:=	0

	aAreaSav		:=	{ SE1->( GetArea() ), FK7->( GetArea() ), FI7->( GetArea() ), SE5->( GetArea() ) }
	nSe5Bx			:=	0
	nNCC			:=	0
	cChaveFI7		:=	''
	cFilSe5			:=	''

	dbSelectArea( 'FI7' )
	FI7->( dbSetOrder( 2 ) )	//PROCURAR PELA CHAVE DESTINO

	dbSelectArea( 'SE5' )
	SE5->( dbSetOrder( 7 ) )

	//Primeiro nivel, grava o titulo principal no array aTits, trata-se daquele titulo a ser baixado conforme o pagamento for ocorrendo.
	If nNivRecus == 0 .And. SE1->( MsSeek( xFilial( 'SE1' ) + cChRecur ) )
		cFilSe5 	:= 	xFilial( "SE5", SE1->E1_FILORIG )			
		If SE5->( MsSeek( cFilSe5 + cChRecur ) )
			While !SE5->( Eof() ) .And. SE5->E5_FILIAL == cFilSe5 .And. ;
				SE5->( E5_PREFIXO + E5_NUMERO + E5_PARCELA + E5_TIPO + E5_CLIENTE + E5_LOJA ) == cChRecur
				
				If SE5->E5_SITUACA != "C" .and. SE5->E5_MOTBX <> 'LIQ'
					If SE5->E5_RECPAG == "R"
						nSe5Bx += SE5->E5_VALOR
					EndIf
				EndIf

				SE5-> (DbSkip() )
			EndDo
		EndIf

		aAdd( aTits, { SE1->E1_VALOR, nSe5Bx, nNCC, ( ( nSe5Bx + nNCC ) / SE1->E1_VALOR ),;
			'ORI:' + xFilial( 'SE1' ) + cChRecur,;
			'DES:',;
			SE1->E1_NUMLIQ } )

		nSe5Bx	:=	0
	EndIf

	If FI7->( MsSeek( xFilial( 'FI7' ) + cChRecur ) )
	
		while FI7->( !Eof() ) .And.;
			FI7->( FI7_FILDES + FI7_PRFDES + FI7_NUMDES + FI7_PARDES + FI7_TIPDES + FI7_CLIDES + FI7_LOJDES ) == xFilial( 'FI7' ) + cChRecur

			If SE1->( MsSeek( xFilial( 'SE1' ) + FI7->( FI7_PRFORI + FI7_NUMORI + FI7_PARORI + FI7_TIPORI + FI7_CLIORI + FI7_LOJORI ) ) )

				If FI7->FI7_TIPORI != MV_CRNEG
				
					nSe5Bx		:=	0
					cFilSe5 	:= 	xFilial( "SE5", SE1->E1_FILORIG )			
					If SE5->( MsSeek( cFilSe5 + FI7->( FI7_PRFORI + FI7_NUMORI + FI7_PARORI + FI7_TIPORI + FI7_CLIORI + FI7_LOJORI ) ) )
						While !SE5->( Eof() ) .And. SE5->E5_FILIAL == cFilSe5 .And. ;
							SE5->( E5_PREFIXO + E5_NUMERO + E5_PARCELA + E5_TIPO + E5_CLIFOR + E5_LOJA ) ==;
							FI7->( FI7_PRFORI + FI7_NUMORI + FI7_PARORI + FI7_TIPORI + FI7_CLIORI + FI7_LOJORI )
							
							If SE5->E5_SITUACA != "C" .and. SE5->E5_MOTBX <> 'LIQ'
								If SE5->E5_RECPAG == "R"
									nSe5Bx += SE5->E5_VALOR
								EndIf
							EndIf

							SE5-> (DbSkip() )
						EndDo

						If !Empty( SE1->E1_NUMLIQ ) .And. aScan( aLiqs, { |aX| aX[ 1 ] == SE1->E1_NUMLIQ } ) == 0
							aAdd( aLiqs, { SE1->E1_NUMLIQ, F440TotLiq( SE1->E1_FILIAL, SE1->E1_NUMLIQ, SE1->E1_CLIENTE, SE1->E1_LOJA ) } )
						EndIf
					EndIF

					aAdd( aTits, { SE1->E1_VALOR, nSe5Bx, nNCC, ( ( nSe5Bx + nNCC ) / SE1->E1_VALOR ),;
					'ORI:' + FI7->( FI7_FILIAL + FI7_PRFORI + FI7_NUMORI + FI7_PARORI + FI7_TIPORI + FI7_CLIORI + FI7_LOJORI ),;
					'DES:' + FI7->( FI7_FILDES + FI7_PRFDES + FI7_NUMDES + FI7_PARDES + FI7_TIPDES + FI7_CLIDES + FI7_LOJDES ),;
					SE1->E1_NUMLIQ } )

					nNivRecus++
					
					ProcFI7( FI7->( FI7_PRFORI + FI7_NUMORI + FI7_PARORI + FI7_TIPORI + FI7_CLIORI + FI7_LOJORI ), @aTits, @aLiqs, nNivRecus )
				ElseIf FI7->FI7_TIPORI == MV_CRNEG
					cFilSe5 	:= 	xFilial( "SE5", SE1->E1_FILORIG )
					If !(SE5->( MsSeek( cFilSe5 + FI7->( FI7_PRFORI + FI7_NUMORI + FI7_PARORI + FI7_TIPORI + FI7_CLIORI + FI7_LOJORI ) ) ))
						cChaveFI7 := FI7->( FI7_PRFORI + FI7_NUMORI + FI7_PARORI + FI7_TIPORI + FI7_CLIORI + FI7_LOJORI )
						nNccLiqSE1 := 1
					Endif
				Endif				
			EndIf
			FI7->( dbSkip() )
		EndDo
	EndIf

	RestArea( aAreaSav[ 1 ] )
	RestArea( aAreaSav[ 2 ] )
	RestArea( aAreaSav[ 3 ] )
	RestArea( aAreaSav[ 4 ] )

return
//-------------------------------------------------------------------
/*{Protheus.doc} Fa440VlLiq
Retorna o valor BRUTO (ver changeset 681189) dos titulos originadores da liquidacao 
referente a um determinado vendedor.

@param cNumLiq, char, numero da liquidacao.
@param cVend, char, codigo do vendedor.
@param nFlagCalc, numeric, flag de processamento, Default 1=modelo inicial criado, 2 passa por um novo tratamento com base na fi7
@return nValLiq, numeric, valor total dos titulos liquidados 
referente a determinado vendedor.

@author  Vinicius do Prado
@version 12.1.27
@since   16/10/2020
@type    Static Function	
*/
//-------------------------------------------------------------------
Static Function Fa440VlLiq(cNumLiq As Character, cVend As Character, nFlagCalc as numeric, lReliq as logical, nParamMoed as Numeric, nNccLiqSE1 As Numeric ) As Numeric
	
	Local aAreaSav		AS Array
	Local aLiqs			As Array
	Local aTits         As Array
	Local cQuery  		As Character
	Local cChRecur  	As Character
	Local cChaveFI7     As Character
	Local cChavePrinc   As Character
	Local cNumLiqBkp	As Character
	Local cAliasCom		As Character
	Local lProc			As Logical
	Local lCalcProp     As Logical
	Local lIndexK1K7	As Logical
	Local nValLiq		As Numeric
	Local nX      		As Numeric
	Local nParam		As Numeric
	Local nCtd			AS Numeric
	Local nTamLiqs      As Numeric
	Local nE5VALORBX	As Numeric
	Local nE1VALORTT	As Numeric
	Local nPropParc     As Numeric
	Local nTamTits      As Numeric
	Local nTxBaixa		As Numeric
	Local nMoedaBx		As Numeric
	
	Default cNumLiq 	:= SE1->E1_NUMLIQ
	Default cVend		:= SE1->E1_VEND1
	Default nFlagCalc	:= 1
	Default lReliq      := .F.
	Default nParamMoed	:= 1
	Default nNccLiqSE1	:= 0
	
	nValLiq		:= 	0
	cQuery		:= 	""
	nX			:= 	0
	nParam		:= 	1
	aAreaSav	:= 	{}
	nCtd		:= 	0
	aAreaSav	:=	{ SE1->( GetArea() ), FK6->( GetArea() ) }
	aLiqs		:=	{}
	cChRecur	:= 	''
	nTamLiqs	:=	0
	nE5VALORBX	:=	0
	nE1VALORTT	:=	0
	aTits		:=	{}
	lProc		:=	.T.
	nPropParc   := 	0
	lCalcProp   := 	.F.
	cChavePrinc := ''
	cNumLiqBkp	:=	cNumLiq
	lBind		:= FindFunction("totvs.protheus.backoffice.ngf.util.BranchRelation")
	cAliasCom	:= ""
	nTxBaixa	:= 0
	nMoedaBx	:= 0
	lIndexK1K7 	:= Empty(FK7->(IndexKey(5))) .Or. Empty(FK1->(IndexKey(5)))

	If lBind
		cBind	:= totvs.protheus.backoffice.ngf.util.BranchRelation( {'FK1','FK1_FILORI','FK1'}, {'FK7','FK7_FILTIT','FK7'}  )
	Endif

	//Tratamento criado especificamente para o processo de re-liquidacao, onde por definicao,
	//	diferente da forma inicial criada, o calculo deve ser realizado com base no principal e NAO
	//	na re-liquidacao anterior
	If nFlagCalc == 2

		//Levantando a quantidade de liquidacoes/re-liquidacoes realizadas	
		cChRecur	:=	SE1->( E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA )
		ProcFI7( cChRecur, @aTits, @aLiqs, , @nNccLiqSE1 )

		nSomaVlLiq	:=	0
		nTamTits	:=	Len( aTits )	//Re-Liquidacao nTamTits > 1
		nTamLiqs	:=	Len( aLiqs )
		If nTamLiqs > 0 .And. nTamTits > 1
			lReliq	:=	.T.
			
			For nCtd := 1 To nTamTits
				If lProc .And. !Empty( aTits[ nCtd, 7 ] )
					nValLiq		:=	0
					cChaveFI7	:=	StrTran( aTits[ nCtd, 5 ], 'ORI:', 'DES:' )
					If aTits[ nCtd, 4 ] > 0
						nPropParc	:=	Iif( nPropParc == 0, 1, nPropParc ) * aTits[ nCtd, 4 ]
					EndIf

					If nCtd == 1
						cChavePrinc	:=	cChaveFI7
						lCalcProp	:=	.F.
						If nPropParc == 1
							lCalcProp	:=	.T.
						endIf
					EndIf

					lProc	:=	.F.

					If nCtd == nTamTits .Or. !Empty( aTits[ nCtd + 1, 7 ] )
						Loop
					EndIf

				ElseIf Empty( aTits[ nCtd, 7 ] )
					lProc		:=	.T.
					nPropParc	:=	0
					nSomaVlLiq 	+= 	nValLiq
					nValLiq		:=	0
					Loop
				EndIf

				If aTits[ nCtd, 6 ] == cChaveFI7 .Or. ( nTamTits > nCtd .And. Empty( aTits[ nCtd + 1, 7 ] ) )
					If nCtd < nTamTits
						If aTits[ nCtd, 4 ] > 0
							nPropParc	:=	nPropParc * aTits[ nCtd, 4 ]
						EndIf
						nValLiq	:=	aTits[ nCtd, 1 ] * Iif( lCalcProp .And. nPropParc <> 0, nPropParc, 1 )
					EndIf
					cChaveFI7	:=	StrTran( aTits[ nCtd, 5 ], 'ORI:', 'DES:' )
				EndIf
			Next nX

			If nSomaVlLiq > 0
				nValLiq	:=	nSomaVlLiq
			EndIf
		EndIf
		cNumLiq	:=	cNumLiqBkp
	EndIf

	//Caso nao ocorra reliquidacao, continua fazendo o padrao
	If nTamLiqs == 0
		If __oValLiq == Nil

			cQuery := " SELECT FK1_IDFK1, FK1_VALOR, FK1_VLMOE2, FK1_MOEDA, FK1_TXMOED "
			cQuery += " FROM "       + RetSqlName("FK1") + " FK1 "
			cQuery += " INNER JOIN " + RetSqlName("FK7") + " FK7 "
			cQuery += " ON "

			If lBind .And. lIndexK1K7
				cQuery += " FK7.FK7_ALIAS = ? "
				cQuery += " AND ? " + " AND " "
			Endif

			cQuery += " FK7.FK7_IDDOC = FK1.FK1_IDDOC "
			cQuery += " AND FK7.D_E_L_E_T_ = ? "
			cQuery += " INNER JOIN " + RetSqlName("SE1") + " SE1 "
			cQuery += " ON "
			cQuery += "     SE1.E1_FILIAL  = FK7.FK7_FILTIT "
			cQuery += " AND SE1.E1_PREFIXO = FK7.FK7_PREFIX "
			cQuery += " AND SE1.E1_NUM     = FK7.FK7_NUM "
			cQuery += " AND SE1.E1_PARCELA = FK7.FK7_PARCEL "
			cQuery += " AND SE1.E1_TIPO    = FK7.FK7_TIPO "
			cQuery += " AND SE1.E1_CLIENTE = FK7.FK7_CLIFOR "
			cQuery += " AND SE1.E1_LOJA    = FK7.FK7_LOJA "

			If !__lReliq
				cQuery += "AND ( ? ) "
			EndIf

			cQuery += " AND SE1.D_E_L_E_T_ = ? "
			cQuery += " WHERE "
			cQuery += "     FK1.D_E_L_E_T_ = ? "
			cQuery += " AND FK1.FK1_FILIAL = ? "
			cQuery += " AND FK1.FK1_MOTBX  = ? "
			cQuery += " AND FK1.FK1_DOC    = ? "
			
			cQuery := ChangeQuery(cQuery)
			__oValLiq := if ( __lExecSt, FWExecStatement():New(cQuery), FWPreparedStatement():New(cQuery) )
		Endif

		If lBind .And. lIndexK1K7
			__oValLiq:SetString(nParam++, 'SE1')
			__oValLiq:SetUnsafe(nParam++, cBind)
		Endif
			
		__oValLiq:SetString(nParam++, " ")

		If !__lReliq
			__oValLiq:SetUnsafe(nParam++, fa440CpoCh(,2,"=",cVend,"OR"))
		EndIf

		__oValLiq:SetString(nParam++, " ")
		__oValLiq:SetString(nParam++, " ")
		__oValLiq:SetString(nParam++, FwxFilial("FK1"))
		__oValLiq:SetString(nParam++, 'LIQ')
		__oValLiq:SetString(nParam++, cNumLiq)
		
		cAliasCom := Iif( __lExecSt, __oValLiq:OpenAlias(), MPSysOpenQuery(__oValLiq:getFixQuery()) )

		DbSelectArea("FK6")
		FK6->(DbSetOrder(2))

		While !(cAliasCom)->(Eof())

			nTxBaixa := (cAliasCom)->FK1_TXMOED
			nMoedaBx := Val((cAliasCom)->FK1_MOEDA)

			If nMoedaBx > 1 .And. nTxBaixa == 0 .And. (nTxBaixa := SE1->E1_TXMOEDA) == 0
				nTxBaixa := RecMoeda(SE1->E1_BAIXA,SE1->E1_MOEDA)
			Endif

			If ((nParamMoed > 1) .Or. (nParamMoed == 1 .And. SE1->E1_MOEDA > 1 .And. nMoedaBx == 1))
                nValLiq += (cAliasCom)->FK1_VLMOE2
            Else
                nValLiq  += (cAliasCom)->FK1_VALOR
            EndIf

			If FK6->(DbSeek(xFilial("FK6") + (cAliasCom)->FK1_IDFK1 + "FK1"))
				While FK6->(!Eof()) .And. FK6->FK6_IDORIG == (cAliasCom)->FK1_IDFK1 .And. FK6->FK6_TABORI == "FK1"
					If FK6->FK6_TPDOC $ 'DC|D2'
						If nMoedaBx == 1
							nValLiq += FK6->FK6_VALMOV
						Else
							nValLiq += NoRound(xMoeda(FK6->FK6_VALMOV, nMoedaBx, SE1->E1_MOEDA,  SE1->E1_BAIXA , __nTmBase, nTxBaixa, 1 )) 
						Endif
					ElseIf !(FK6->FK6_TPDOC $ 'CM|VM|C2')
						If nMoedaBx == 1
							nValLiq -= FK6->FK6_VALMOV
						Else
							nValLiq -= NoRound(xMoeda(FK6->FK6_VALMOV, nMoedaBx, SE1->E1_MOEDA,  SE1->E1_BAIXA , __nTmBase, nTxBaixa, 1 )) 
						Endif 
					Endif
					FK6->(DbSkip())
				EndDo
			Endif
			(cAliasCom)->(DbSkip())
		EndDo

		(cAliasCom)->(DbCloseArea())

		If __lReliq
			//Incluo o valor da NCC gerada na liquidacao com valor superior ao valor da origem
			SE1->( dbSetOrder( 15 ) )	//FILIAL+NUMLIQ
			If SE1->( MsSeek( xFilial( 'SE1' ) + cNumLiq ) )
				While SE1->( !Eof() ) .And. SE1->( E1_FILIAL == xFilial( 'SE1' ) .And. E1_NUMLIQ == cNumLiq )
					If SE1->E1_TIPO $ MV_CRNEG .And. SE1->E1_SALDO < SE1->E1_VALOR
						nValLiq	+=	SE1->E1_VALOR - SE1->E1_SALDO
					EndIf
					SE1->( dbSkip() )
				EndDo
			EndIf
		EndIf
	EndIf

	RestArea( aAreaSav[ 1 ] )
	RestArea( aAreaSav[ 2 ] )

Return nValLiq

//-------------------------------------------------------------------
/*{Protheus.doc} F440TotLiq
Retorna o valor total das parcelas geradas pela liquidacao.

@param cFilSE1, char, filial onde foi realizada a liquidacao.
@param cNumLiq, char, numero da liquidacao.
@param cCliente, char, cliente utilizado na liquidacao.
@param cLoja, char, loja utilizado na liquidacao.
@return nValLiq, numeric, valor total da liquidacao.

@author  Vinicius do Prado
@version 12.1.27
@since   30/03/2021
@type    Static Function	
*/
//-------------------------------------------------------------------
Static Function F440TotLiq(cFilLiq As Character, cNumLiq As Character, cCliente As Character, cLoja As Character) As Numeric

	Local nValLiq	As Numeric
	Local cQuery  	As Character
	Local aArea 	As Array

	DEFAULT cFilLiq  := SE1->E1_FILIAL
	DEFAULT cNumLiq  := SE1->E1_NUMLIQ
	DEFAULT cCliente := SE1->E1_CLIENTE
	DEFAULT cLoja	 := SE1->E1_LOJA

	aArea 	:= GetArea()
	nValLiq := 0
	cNumLiq := Alltrim(cNumLiq)

	// Tratamento para quando tem SE1 - Compartilhada e FO2 - Exclusiva
	If(Empty(cFilLiq) .And. xFilial("SE1") != xFilial("FO2"))
		cFilLiq := SE1->E1_FILORIG
	Endif

	dbSelectArea("FO0")
	dbSetOrder(2)
	
	cQuery 	 := ""
	If dbSeek( FwxFilial("FO0",cFilLiq) + cNumLiq + cCliente + cLoja )
		nProcess := FO0->FO0_PROCES

		If __oTotLiq == Nil
			cQuery := " SELECT SUM(FO2_VALOR) VALLIQ "
			cQuery += " FROM ? "
			cQuery += " WHERE FO2_FILIAL = ? "
			cQuery += " AND FO2_PROCES = ? "
			cQuery += " AND D_E_L_E_T_ = ' '"

			cQuery := ChangeQuery(cQuery)
			__oTotLiq := FWPreparedStatement():New(cQuery)
		EndIF

		__oTotLiq:SetNumeric(1, RetSqlName("FO2"))
		__oTotLiq:SetString(2,cFilLiq)
		__oTotLiq:SetString(3,nProcess)

		cQuery   := __oTotLiq:GetFixQuery()
		nValLiq  := MpSysExecScalar(cQuery,"VALLIQ")

		RestArea(aArea)
	EndIf

Return nValLiq

//-------------------------------------------------------------------
/*{Protheus.doc} F440Prop
Retorna o valor proporcional para recálculo da comissão

@param nVlrParc, 	numeric, valor recebido
@param nTotNF, 		numeric, valor total
@param cFilial, 	character, filial do pedido
@param cPedido, 	character, pedido
@return nValProp, numeric, valor da proporcionalidade

@author  Sidney Santos
@version 12.1.27
@since   31/05/2021
@type    Static Function	
*/
//-------------------------------------------------------------------
Static Function F440Prop(nVlrParc As Numeric, nTotNF As Numeric, cFilSE1 As Character, cPedido As Character, lFina440 As Logical) As Numeric

	Local aArea		 As Array
	Local cQrySD1  	 As Character
	Local cQrySD2  	 As Character
	Local cD2Doc	 As Character
	Local cD2Serie	 As Character
	Local cATRBSD2	 As Character
	Local cATRBSD1	 As Character
	Local nD2ICM 	 As Numeric
	Local nD2ICRet	 As Numeric
	Local nD2ISS  	 As Numeric
	Local nD2IPI  	 As Numeric
	Local nD2Fre  	 As Numeric
	Local nD2AcrF 	 As Numeric
	Local nD2COF  	 As Numeric
	Local nD2PIS  	 As Numeric
	Local nD2CSL  	 As Numeric
	Local nD2IRRF 	 As Numeric
	Local nD2INSS 	 As Numeric
	Local nD1ICM  	 As Numeric
	Local nD1ICRet	 As Numeric
	Local nD1ISS  	 As Numeric
	Local nD1IPI  	 As Numeric
	Local nD1Fre  	 As Numeric
	Local nD1AcrF 	 As Numeric
	Local nD1COF  	 As Numeric
	Local nD1PIS  	 As Numeric
	Local nD1CSL  	 As Numeric
	Local nD1IRRF 	 As Numeric
	Local nD1INSS 	 As Numeric
	Local nValProp	 As Numeric
	Local nParcBkp	 As Numeric
	Local nTotNFBkp	 As Numeric
	Local _oFINA4401 As Object
	Local _oFINA4402 As Object
	Local lCOMIPIS	 As Logical
	Local lCOMICOF 	 As Logical
	Local lCOMICSL 	 As Logical
	Local lCOMISIR 	 As Logical
	Local lCOMISIN 	 As Logical

	DEFAULT nVlrParc := 1
	DEFAULT nTotNF   := 1
	DEFAULT cFilSE1  := SE1->E1_FILIAL
	DEFAULT cPedido  := SE1->E1_PEDIDO
	DEFAULT lFina440 := .F.

	aArea 		:= GetArea()
	cATRBSD2	:= "TRBSD2"
	cATRBSD1	:= "TRBSD1"
	cD2Doc  	:= ""
	cD2Serie	:= ""
	nD2ICM  	:= 0
	nD2ICRet	:= 0
	nD2ISS  	:= 0
	nD2IPI  	:= 0
	nD2Fre  	:= 0
	nD2AcrF 	:= 0
	nD2COF  	:= 0
	nD2PIS  	:= 0
	nD2CSL  	:= 0
	nD2IRRF 	:= 0
	nD2INSS 	:= 0	
	nD1ICM  	:= 0
	nD1ICRet	:= 0
	nD1ISS  	:= 0
	nD1IPI  	:= 0
	nD1Fre  	:= 0
	nD1AcrF 	:= 0
	nD1COF  	:= 0
	nD1PIS  	:= 0
	nD1CSL  	:= 0
	nD1IRRF 	:= 0
	nD1INSS 	:= 0
	nValProp	:= 1
	_oFINA4401	:= Nil
	_oFINA4402	:= Nil
	lCOMIPIS	:= GetNewPar("MV_COMIPIS","N") == "N"
	lCOMICOF	:= GetNewPar("MV_COMICOF","N") == "N"
	lCOMICSL	:= GetNewPar("MV_COMICSL","N") == "N"
	lCOMISIR	:= GetNewPar("MV_COMISIR","N") == "N"
	lCOMISIN	:= GetNewPar("MV_COMIINS","N") == "N"

	nParcBkp	:= nVlrParc
	nTotNFBkp	:= nTotNF

	If __oPropSD2 == Nil

		DbSelectArea("SD2")

		cQrySD2 := " SELECT SUM(D2_VALICM) VALICM, SUM(D2_ICMSRET) ICMSRET, SUM(D2_VALISS) VALISS, SUM(D2_VALINS) VALINS, "
		cQrySD2 += " SUM(D2_VALIPI) VALIPI, SUM(D2_VALFRE) VALFRE, SUM(D2_VALACRS) VALACRS, "
		if cPaisLoc == "BRA"		
			cQrySD2 += " SUM(D2_VALCOF) VALCOF, SUM(D2_VALPIS) VALPIS, SUM(D2_VALCSL) VALCSL,  SUM(D2_VALIRRF) VALIRRF, "
		endif
		cQrySD2 += " D2_DOC D2DOC, D2_SERIE D2SERIE"
		cQrySD2 += " FROM ? "
		cQrySD2 += " WHERE D2_FILIAL = ? "
		cQrySD2 += " AND D2_PEDIDO = ? "
		cQrySD2 += " AND D_E_L_E_T_ = ' '"
		cQrySD2 += " GROUP BY D2_DOC, D2_SERIE"

		cQrySD2 := ChangeQuery(cQrySD2)
		__oPropSD2 := FWPreparedStatement():New(cQrySD2)
		
	Endif

	__oPropSD2:SetNumeric(1,	RetSqlName("SD2"))
	__oPropSD2:SetString(2, 	cFilSE1)
	__oPropSD2:SetString(3, 	cPedido)

	cQrySD2   	:= __oPropSD2:GetFixQuery()
	
	MPSysOpenQuery(cQrySD2, cATRBSD2)
	
	dbSelectArea(cATRBSD2)
	(cATRBSD2)->(dbGoTop())
	
	If (cATRBSD2)->(!EOF()) .and. (cATRBSD2)->(!BOF())
	
		nD2ICM  	:= (cATRBSD2)->VALICM
		nD2ICRet	:= (cATRBSD2)->ICMSRET
		nD2ISS  	:= (cATRBSD2)->VALISS
		nD2IPI  	:= (cATRBSD2)->VALIPI	
		nD2Fre  	:= (cATRBSD2)->VALFRE
		nD2AcrF  	:= (cATRBSD2)->VALACRS		
		nD2INSS  	:= (cATRBSD2)->VALINS
		cD2Doc  	:= (cATRBSD2)->D2DOC
		cD2Serie  	:= (cATRBSD2)->D2SERIE
		
		if cPaisLoc = "BRA"
			nD2COF  	:= (cATRBSD2)->VALCOF
			nD2PIS  	:= (cATRBSD2)->VALPIS	
			nD2CSL  	:= (cATRBSD2)->VALCSL	
			nD2IRRF  	:= (cATRBSD2)->VALIRRF
		else
			nD2Cod := nD2PIS := nD2CSL := 0
		endif

		If(SA3->A3_ICM == "N")
			nTotNF -= nD2ICM
		Endif

		If(SA3->A3_ICMSRET == "N")
			nTotNF -= nD2ICRet
		Endif

		If(SA3->A3_ISS == "N")
			nTotNF -= nD2ISS
		Endif

		If(SA3->A3_IPI == "N")
			nTotNF -= nD2IPI
		Endif

		If(SA3->A3_FRETE == "N")
			nTotNF -= nD2Fre
		Endif

		If(SA3->A3_ACREFIN == "N")
			nTotNF -= nD2AcrF
		Endif	

		If cPaisLoc == "BRA"
			If(lCOMIPIS .And. lCOMICOF .And. SA3->A3_PISCOF == "4")
				nTotNF -= nD2PIS - nD2COF			
			Elseif(lCOMIPIS .And. SA3->A3_PISCOF == "2")
				nTotNF -= nD2PIS			
			Elseif(lCOMICOF .And. SA3->A3_PISCOF == "3")
				nTotNF -= nD2COF			
			Endif

			If(lCOMICSL)
				nTotNF -= nD2CSL
			Endif

			If(lCOMISIR)
				If(SA3->A3_BASEIR == "1")
					nTotNF -= nD2IRRF
				Endif
			Endif
		Endif

		If(lCOMISIN)
			nTotNF -= nD2INSS
		Endif

		SD2->(DbCloseArea())

		If (!Empty(cD2Doc) .And. !Empty(cD2Serie)) .And. (!lFina440 .Or. (lFina440 .And. MV_PAR07 != 1) )

			If __oPropSD1 == Nil

				DbSelectArea("SD1")

				cQrySD1 := " SELECT SUM(D1_VALICM) VALICM, SUM(D1_ICMSRET) ICMSRET, SUM(D1_VALISS) VALISS, SUM(D1_VALINS) VALINS, "
				cQrySD1 += " SUM(D1_VALIPI) VALIPI, SUM(D1_VALFRE) VALFRE,  "
				if cPaisLoc == "BRA"
					cQrySD1 += " SUM(D1_VALCSL) VALCSL, SUM(D1_VALCOF) VALCOF, SUM(D1_VALPIS) VALPIS, SUM(D1_VALIRR) VALIRRF, "	
				endif
				cQrySD1 += " SUM(D1_VALACRS) VALACRS"
				cQrySD1 += " FROM ? "
				cQrySD1 += " WHERE D1_FILIAL = ? "
				cQrySD1 += " AND D1_NFORI = ? "
				cQrySD1 += " AND D1_SERIORI = ? "
				cQrySD1 += " AND D_E_L_E_T_ = ' '"

				cQrySD1 := ChangeQuery(cQrySD1)
				__oPropSD1 := FWPreparedStatement():New(cQrySD1)
				
			Endif

			__oPropSD1:SetNumeric(1,	RetSqlName("SD1"))
			__oPropSD1:SetString(2, 	cFilSE1)
			__oPropSD1:SetString(3, 	cD2Doc)
			__oPropSD1:SetString(4, 	cD2Serie)

			cQrySD1   	:= __oPropSD1:GetFixQuery()
			
			MPSysOpenQuery(cQrySD1, cATRBSD1)

			dbSelectArea(cATRBSD1)
			(cATRBSD1)->(dbGoTop())
			
			If (cATRBSD1)->(!EOF()) .and. (cATRBSD1)->(!BOF())
			
				nD1ICM  	:= (cATRBSD1)->VALICM
				nD1ICRet	:= (cATRBSD1)->ICMSRET
				nD1ISS  	:= (cATRBSD1)->VALISS
				nD1IPI  	:= (cATRBSD1)->VALIPI
				nD1Fre  	:= (cATRBSD1)->VALFRE			
				nD1AcrF  	:= (cATRBSD1)->VALACRS	
				nD1INSS  	:= (cATRBSD1)->VALINS	
				if cPaisLoc == "BRA"
					nD1COF  	:= (cATRBSD1)->VALCOF
					nD1PIS  	:= (cATRBSD1)->VALPIS
					nD1CSL  	:= (cATRBSD1)->VALCSL			
					nD1IRRF  	:= (cATRBSD1)->VALIRRF	
				else
					nD1COF:= nD1PIS := nD1CSL := nD1IRRF := 0			
				endif

				If(SA3->A3_ICM == "N")
					nVlrParc -= nD1ICM
				Endif

				If(SA3->A3_ICMSRET == "N")
					nVlrParc -= nD1ICRet
				Endif

				If(SA3->A3_ISS == "N")
					nVlrParc -= nD1ISS
				Endif

				If(SA3->A3_IPI == "N")
					nVlrParc -= nD1IPI
				Endif

				If(SA3->A3_FRETE == "N")
					nVlrParc -= nD1Fre
				Endif

				If(SA3->A3_ACREFIN == "N")
					nVlrParc -= nD1AcrF
				Endif	

				If cPaisLoc == "BRA"
					If(lCOMIPIS .And. lCOMICOF .And. SA3->A3_PISCOF == "4")
						nVlrParc -= nD1PIS - nD1COF				
					Elseif(lCOMIPIS .And. SA3->A3_PISCOF == "2")
						nVlrParc -= nD1PIS				
					Elseif(lCOMICOF .And. SA3->A3_PISCOF == "3")
						nVlrParc -= nD1COF				
					Endif	

					If(lCOMICSL)
						nVlrParc -= nD1CSL
					Endif		

					If(lCOMISIR)
						If(SA3->A3_BASEIR == "1")
							nVlrParc -= nD1IRRF
						Endif
					Endif
				EndIf	

				If(lCOMISIN)
					nVlrParc -= nD1INSS
				Endif
					
				SD1->(DbCloseArea())
			Endif

			(cATRBSD1)->(DbCloseArea())

		Endif
	EndIf

	(cATRBSD2)->(DbCloseArea())

If nVlrParc <> nParcBkp .And. nTotNf <> nTotNFBkp
	nValProp := nVlrParc / nTotNF
Else
	nValProp := nParcBkp / nTotNFBkp
EndIf

RestArea(aArea)

Return nValProp

//-------------------------------------------------------------------
/*{Protheus.doc} F440Help
Exibe tela com mensagem e link da documentação, caso o compartilhamento entre as tabelas 
SE1 e SE3 estejam diferentes.

@author  Simone Mie Sato Kakinoana
@version 12.1.27
@since   22/07/2021
@type    Static Function	
*/
//-------------------------------------------------------------------
Static Function F440Help() 

Local aSays		:= {}
local aButtons	:= {}

aAdd(aSays,STR0030)//ATENÇÃO !!!!
aAdd(aSays,"")
aAdd(aSays,STR0026 )//"Compartilhamento das tabelas SE1 e SE3 não homologado." 
aAdd(aSays,STR0027 )// "O processamento irá prosseguir, porém poderão ocorrer inconsistências "
aAdd(aSays,STR0028) //"no cálculo de comissões." 

aAdd(aButtons, { 1, .T., {|o| ShellExecute("open","https://tdn.totvs.com/x/R1DvH","","",1),FechaBatch() } } )

//Abre a tela de processamento
FormBatch( STR0029, aSays, aButtons )//"Compartilhamento de tabelas"

Return

//-------------------------------------------------------------------
/*{Protheus.doc} FindF2Orig
Procura na SE1 o título de origem (do pedido de venda) do título
transferido

@author  Rodrigo Oliveira
@version 12.1.27
@since   02/02/2022
@type    Static Function	
*/
//-------------------------------------------------------------------
Static Function FindF2Orig() As Logical
	Local cQuery	As Character
	Local lRet		As Logical
	Local nRec		As Numeric

	cQuery	:= ""
	lRet	:= .F.
	nRec	:= 0

	DbSelectArea("SE6")
	SE6->(DbSetOrder(4))

	If SE6->(DbSeek(xFilial("SE1")+SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)))
		cQuery := " Select R_E_C_N_O_ RECSE1 "
		cQuery += " From " + RetSqlName("SE1") + " SE1 "
		cQuery += " Where E1_FILORIG = '" + SE6->E6_FILORIG + "' "
		cQuery += " And E1_CLIENTE = '" + SE1->E1_CLIENTE + "' "
		cQuery += " And E1_LOJA = '" 	+ SE1->E1_LOJA + "' "
		cQuery += " And E1_PREFIXO = '" + SE1->E1_PREFIXO + "' "
		cQuery += " And E1_NUM = '" 	+ SE1->E1_NUM + "' "
		cQuery += " And E1_PARCELA = '" + SE1->E1_PARCELA + "' "
		cQuery += " And E1_TIPO = '" 	+ SE1->E1_TIPO + "' "
		cQuery += " And SE1.D_E_L_E_T_ = ' ' "

		cQuery := ChangeQuery(cQuery)

		__nRecOrig := nRec := MpSysExecScalar(cQuery,"RECSE1")
	EndIf
	If nRec > 0
		SE1->(DbGoTo(nRec))
		lRet	:= .T.
	EndIf

Return lRet

/*/{Protheus.doc} fa440Cpos
    Monta array com os campos da SE1 referente a vendedores.

	Movido do FINR137 (static function CposComis()) em 31/05/2022

    @author rafael.rondon, guilherme.sordi
    @since 17/03/2021
    @return Array com os campos da SE1 referente a vendedores
    @type function
/*/
Function fa440Cpos() As Array

	Local nX		As Numeric
	local nVends 	As Numeric 
	local cSufixo	as character

	if __aCpos != NIL
		return aClone(__aCpos)
	endIf

	nVends := fa440CntVen()
	__aCpos := {}

	For nX := 1 To nVends

		cSufixo := RetAsc(nX, 1, .T.)
		AADD( __aCpos , { "E1_VEND" + cSufixo , "E1_COMIS" + cSufixo, "E1_BASCOM" + cSufixo } )

	Next nX

Return aClone(__aCpos)


/*/{Protheus.doc} fa440CpoCh
    Retorna stirng com os campos da SE1 relacionados à comissão, para serem usados na query.

	Tipo
	1 = Apenas os CAMPOS para o SELECT (E1_VEND, E1_COMIS e E1_BASCOM). Exemplo: E1_VEND1, E1_COMIS1, E1_BASCOM1, E1_VEND2, E1_COMIS2 ... 
	2 = Comparação de todos os vendedores em uma série de OU - Para ser usado como condição nas queries. Exemplo: E1_VEND1 <> ' ' OR E1_VEND2 <> ' ' ...
	3 = Apenas os campos E1_VEND para o SELECT (foi criado depois). Exemplo: E1_VEND1, E1_VEND2, E1_VEND3 ...

    @author guilherme.sordi
    @since 31/05/2022
    @return Array com os campos da SE1 referente a vendedores
	@param cAlias, Alias da tabela na query. Exemplo: cAlias = E1ORI => E1ORI.CVEND1, E1ORI.CVEND2
	@param nTipo, 
	@param cOpComp, Operador de comparação para a query
	@param cValComp, Valor de comparação para a query
	@param cOpLogico, Operador lógico para a série de comparações
    @type function
/*/
Function fa440CpoCh(cAlias as character, nTipo as numeric, cOpComp as character, cValComp as character, cOpLogico as character) As character

	Local nX		As Numeric
	local nY 		as Numeric
	local aCpos		as array 
	local cRet		as character

	default cAlias := ""
	default nTipo := 1
	default cOpComp := "<>"
	default cValComp := ""
	default cOpLogico := "OR"

	aCpos := fa440Cpos()
	cRet := ""

	if !Empty(cAlias)
		cAlias += "."
	endIf

	Do Case
	Case nTipo = 1	

		for nX := 1 to len(aCpos)
			
			if !Empty(cAlias)
				for nY := 1 to 3
					aCpos[nX][nY] := cAlias + aCpos[nX][nY]
				next nY
			endIf

			cRet += iif(Empty(cRet),"",", ") + ArrTokStr(aCpos[nX], ", ")
		next nX

	Case nTipo = 2

		if Empty(cValComp)
			cValComp := "'" + space(TamSX3("A3_COD")[1]) + "'"
		else
			if cValComp != '?'
				cValComp := "'" + cValComp + "'"
			endIf
		endIf
		for nX := 1 to len(aCpos)		
			cRet += iif(Empty(cRet),""," "+ cOpLogico +" ") + cAlias + aCpos[nX][1] + " " + cOpComp + " " + cValComp
		next nX

	Case nTipo = 3	

		for nX := 1 to len(aCpos)
			cRet += iif(Empty(cRet),"",", ") + cAlias + aCpos[nX][1]
		next nX
		
	EndCase
	
Return cRet


/*/{Protheus.doc} fa440temVe
    @description Recebe um alias e verifica se algum campo de vendedor do registro posicionado está preenchido.
    @author guilherme.sordi
    @since 07/06/2022
    @return Retorna True se tem vendedor no título posicionado e False caso contrário
	@param cAlias, Alias do registro que será verificado	
    @type function
/*/
function fa440temVe(cAlias as character) as logical
	local aCpos as character
	local cVends as character
	local nX as numeric

	aCpos := fa440Cpos()
	cVends := ""

	for nX := 1 to len(aCpos)
		cVends += (cAlias)->&(aCpos[nX][1])
	next nX

return !Empty(cVends)



/*/{Protheus.doc} getFo0Proc
    @description Retorna um array contendo respectivamente Filial, Processo e Versão da liquidação do título informado
    @author guilherme.sordi
    @since 06/07/2022
    @return Retorna quantos títulos foram gerados na liquidação
	@param nRecnoSE1, RECNO do registro SE1 que será verificado. Deve ser um título filho de liquidação.
    @type static function
/*/
Static Function getFO0Proc (nRecnoSE1 as Numeric) 
	Local cQuery as Character
	Local cAlias as Character
	Local cFilFO2 as Character
	Local aRet as Array

	cFilFO2 := xFilial("FO2", SE1->E1_FILORIG)
	cAlias := ""
	aRet := {"", "", ""}
	cQuery := ""

	If __oStFO0Pr == NIL
				
		cQuery := " SELECT FO2_FILIAL, FO2_PROCES, FO2_VERSAO "
		cQuery += " FROM " + retSQLName("FO2") + " FO2 "
		cQuery += " JOIN "+ retSQLName("SE1") + " SE1 "
		cQuery += " ON FO2_FILIAL = ? "
		cQuery += " AND FO2_PREFIX = E1_PREFIXO "
		cQuery += " AND FO2_NUM = E1_NUM "
		cQuery += " AND FO2_PARCEL = E1_PARCELA "
		cQuery += " AND FO2_TIPO = E1_TIPO "
		cQuery += " AND SE1.D_E_L_E_T_ = ' ' "
		
		cQuery += " JOIN "+ retSQLName("FO0") +" FO0 "
		cQuery += " ON FO2_FILIAL = FO0_FILIAL "
		cQuery += " AND FO2_PROCES = FO0_PROCES "
		cQuery += " AND FO2_VERSAO = FO0_VERSAO "
		cQuery += " AND FO0.D_E_L_E_T_ = ' ' "
		cQuery += " AND FO0.FO0_STATUS <> '5' "

		cQuery += " WHERE SE1.R_E_C_N_O_ = ? "
		cQuery += " AND FO2.D_E_L_E_T_ = ' ' "

		cQuery := changeQuery(cQuery)
		__oStFO0Pr := FWPreparedStatement():New(cQuery)
	EndIf
	__oStFO0Pr:setString(1, cFilFO2)
	__oStFO0Pr:setNumeric(2, nRecnoSE1)

	cAlias := MPSysOpenQuery(__oStFO0Pr:GetFixQuery())
	If !(cAlias)->(EOF()) .and. !(cAlias)->(BOF())
		FwFreeArray(aRet)
		aRet := {(cAlias)->FO2_FILIAL, (cAlias)->FO2_PROCES, (cAlias)->FO2_VERSAO}
	EndIf

	(cAlias)->(DBCloseArea())

Return aRet


/*/{Protheus.doc} contaFLiq
    @description Retorna quantos títulos foram gerados na liquidação
    @author guilherme.sordi
    @since 06/07/2022
    @return Retorna quantos títulos foram gerados na liquidação
	@param nRecnoSE1, RECNO do registro SE1 que será verificado
    @type static function
/*/
Static Function contaFLiq (cFilFO2 as Character, cProcesso as Character, cVersao as Character)
	Local nParcelas as Numeric
	Local cQuery as Character

	nParcelas := 0
	cQuery := ""

	If __oStParcL == NIL
		
		cQuery := " SELECT COALESCE(COUNT(FO2.R_E_C_N_O_),0) PARCELAS "
		cQuery += " FROM " + retSQLName("FO2") + " FO2 "
		cQuery += " WHERE FO2.D_E_L_E_T_ = ' ' "
		cQuery += " AND FO2_FILIAL = ? "
		cQuery += " AND FO2_PROCES = ? "
		cQuery += " AND FO2_VERSAO = ? "		

		cQuery := changeQuery(cQuery)
		__oStParcL := FWPreparedStatement():New(cQuery)
	EndIf
	__oStParcL:setString(1, cFilFO2)
	__oStParcL:setString(2, cProcesso)
	__oStParcL:setString(3, cVersao)

	nParcelas := MpSysExecScalar(__oStParcL:GetFixQuery(),"PARCELAS")

Return nParcelas


/*/{Protheus.doc} parcLiq
    @description Ao avaliar um título gerado por liquidação, retorna quanto do título é 
	juros e desconto
    @author guilherme.sordi
    @since 06/07/2022
    @return Retorna array de duas posições, sendo, respectivamente JUROS e DESCONTO (de cada parcela)
	@param nRecnoSE1, RECNO do registro SE1 que será verificado
    @type static function
/*/
Static Function parcLiqJD(nRecnoSE1)
	Local aRet as Array
	Local cQuery as Character
	Local cAlias as Character
	Local aProces as Array
	Local nParcelas as Numeric

	aRet := {0, 0}
	aProces := getFO0Proc(nRecnoSE1)
	cFilFO1 := aProces[1]
	cProcesso := aProces[2]
	cVersao := aProces[3]
	cQuery := ""

	nParcelas := contaFLiq(cFilFO1, cProcesso, cVersao)

	If __oStParJD == NIL
		
		cQuery := " SELECT COALESCE( SUM(FO1_VLJUR + FO1_VLMUL + FO1_ACRESC) ,0) JUROS, COALESCE( SUM(FO1_DESCON + FO1_DECRES) ,0) DESCONTO "
		cQuery += " FROM " + retSQLName("FO1") + " FO1 "
		cQuery += " WHERE FO1.D_E_L_E_T_ = ' ' "
		cQuery += " AND FO1_FILIAL = ? "
		cQuery += " AND FO1_PROCES = ? "
		cQuery += " AND FO1_VERSAO = ? "

		cQuery := changeQuery(cQuery)
		__oStParJD := FWPreparedStatement():New(cQuery)
	EndIf
	__oStParJD:setString(1, cFilFO1)
	__oStParJD:setString(2, cProcesso)
	__oStParJD:setString(3, cVersao)

	cAlias := MPSysOpenQuery(__oStParJD:GetFixQuery())
	If !(cAlias)->(EOF()) .and. !(cAlias)->(BOF())
		FwFreeArray(aRet)
		aRet := { ((cAlias)->JUROS/nParcelas), ((cAlias)->DESCONTO/nParcelas) }
	EndIf

	(cAlias)->(DBCloseArea())

Return aRet

//-------------------------------------------------------------------
/*{Protheus.doc} SchedDef
Utilizado somente se a rotina for executada via Schedule.
Permite usar o botao Parametros da nova rotina de Schedule
para definir os parametros(SX1) que serao passados a rotina agendada.

@author  guilhermed.santos
@version 12.1.24
@since   18/06/2024
@return  aParam
*/
//-------------------------------------------------------------------
Static Function SchedDef(  )
	Local aParam := {}

	aParam := {	"P"	,;	 //Tipo R para relatorio P para processo
	"AFI440",;	 //Nome do grupo de perguntas (SX1)
	Nil,;	 //cAlias (para Relatorio)
	Nil,;	 //aArray (para Relatorio)
	Nil   } //Titulo (para Relatorio)

Return aParam

//-------------------------------------------------------------------
/*{Protheus.doc} F440FLAGE3
Função utilizada para uso do ponto de entrada F440FLAGE3
Deverá devolver campo criado pelo cliente para uso de flag em manutenção de comissão

@author  Francisco Oliveira
@version 12.1.2410
@since   18/10/2024
@return  Nil
*/
//-------------------------------------------------------------------
Static Function F440FLAGE3(__l440Flag As Logical, __cCpoFlag As Character)

	Local cCpoFlag	As Character

	cCpoFlag	:= ""
	
	__l440Flag	:= .F.
	__cCpoFlag	:= ""

	DbSelectArea("SE3")

	cCpoFlag 	:= ExecBlock("F440FLAGE3",.F.,.F.)
	If !Empty(cCpoFlag) .And. SE3->(ColumnPos(Upper(cCpoFlag))) > 0 .And. TamSX3(cCpoFlag)[3] == 'C'
		__l440Flag	:= .T.
		__cCpoFlag	:= cCpoFlag
	Endif

Return 
