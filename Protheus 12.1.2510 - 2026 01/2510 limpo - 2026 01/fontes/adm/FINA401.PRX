#include "FINA401.ch"  
#include "PROTHEUS.ch"
#Include "FWBROWSE.CH"

#DEFINE CNPJ			1
#DEFINE VALORDOIMPOSTO	2
#DEFINE CODIGORETENCAO	3
#DEFINE MES				4
#DEFINE BASEDECALCULO	5
#DEFINE CHAVETITULO		6
#DEFINE VALORDOINSS		7
#DEFINE ANO				8
#DEFINE ISENTONAOTRIB	9
#DEFINE NIFEX           10

#DEFINE TAM_FIL			FinTamSXG("033",TAMSX3("E2_FILIAL")[1])[1]
#DEFINE TAM_PREF		10
#DEFINE TAM_NUM 		TamSX3("E2_NUM")[1]
#DEFINE TAM_PARC		10
#DEFINE TAM_TIPO		5
#DEFINE TAM_NAT			10
#DEFINE TAM_VALOR		17
#DEFINE LOG_VALOR		11

#DEFINE SA2_SQL_JOIN  1
#DEFINE SA2_SQL_WHERE 2

#DEFINE SIGAFIN 6

Static cQryConcat	:= ""
Static lPlsAtiv		:= .F.
Static cVenctoPJ 	:= SuperGetMv("MV_ACMIRPJ",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Static cUniao 		:= GetMv("MV_UNIAO")
Static aStru 		:= {}
Static cVenctoPF 	:= SuperGetMv("MV_ACMIRPF",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao

Static lFa401Cmp 	:= ExistBlock("FA401CMP")
Static lINSIRF   	:= (SuperGetMv("MV_INSIRF",.F.,"2") == "1")
Static lMRETISS  	:= GetNewPar( "MV_MRETISS", "1" ) == "2"
Static	nTamFor 	:= TamSx3("E2_FORNECE")[1]
Static nTamLj  		:= TamSx3("E2_LOJA")[1]
Static nTamTit 		:= ( TamSx3( "E2_PREFIXO" )[1] + TamSx3( "E2_NUM" )[1] + TamSx3( "E2_PARCELA" )[1] + TamSx3( "E2_TIPO" )[1]) + 1
Static nTMSVDEP		:= GetMV("MV_TMSVDEP",,0)
Static cBDname		:= Upper( TCGetDB() )
Static lF401QRY2 	:= ExistBlock("F401QRY2")
Static lF401QRY3 	:= ExistBlock("F401QRY3")
Static lFA401PROC 	:= ExistBlock("FA401PROC")

Static lFA401SR4 	:= ExistBlock("FA401SR4")
Static lF401REX 	:= ExistBlock("F401REX")
Static lF401Qry4 	:= ExistBlock("F401Qry4")
Static lFA401QRY 	:= ExistBlock("FA401QRY")
Static lF401Qry5 	:= ExistBlock("F401Qry5")

Static cSrvType 	:= TcSrvType()
Static lISNIF 		:= SR4->(ColumnPos( "R4_ISNIF")) > 0
Static nTamTpRen 	:= TamSx3( "R4_TIPOREN" )[1]
Static nTamPref 	:= TamSx3( "E2_PREFIXO" )[1]
Static nTamNum 		:=  TamSx3( "E2_NUM" )[1]
Static nTamPar  	:=  TamSx3( "E2_PARCELA" )[1]
Static nTamTipo 	:=  TamSx3( "E2_TIPO" )[1]
Static lFina992 	:= FindFunction("F992RetVal")  .and. AliasInDic("FKI")
Static lExistFKJ 	:= FindFunction("FINA993") .and.  AliasInDic("FKJ")
Static lFina405 	:= AliasInDic("FOM").AND. AliasInDic("FON") .AND. FindFunction("FINA405")
Static lTpEnt 		:= SA2->( ColumnPos( "A2_TPENT") ) > 0
Static lIrBx	  	:= .F.
Static lCalcIssBx 	:= .F.

Static __lPaBruto   := NIL
Static __lPrImPA	:= NIL

Static __lPCCBaixa	:= NIL
Static cFilSel		:= NIL
Static _oFINA4011
Static _oFINA4012
Static c401QryIr1 	:= F401QryIr(1)
Static c401QryIr2 	:= F401QryIr(2)
Static c401QryMes 	:= F401QryMes()
Static __LVALPGTO 	:= NIl
Static cFilSA2	 	:= NIL	
Static aEmptyCPF 	:= {}
Static __oPrepIrf	:= NIL
Static __lFMP1171   As Logical
Static __lDicSimpl	As Logical
Static __nFVL1171   As Numeric
Static __nTamIMPO	As Numeric
Static __cFilSE2	As Character
Static __oQrySimp	As Logical

/*ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FINA401    ³ Autor ³ Claudio D. de Souza   ³ Data ³ 24.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera dados para DIRF na Folha                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FINA401()                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIN                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Eduardo Ju  ³06/03/03³----- ³ Criacao de Queries para filtros em TOP.    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FINA401(lAutomato As Logical) As Logical

    Local aButtons As Array
    Local aNatVar As Array
    Local aSays As Array
    Local aSE2Stru As Array
    Local aSelFil As Array
    Local aTmpFil As Array
    Local cTmpSE2Fil As Character
    Local lPanelFin As Logical
    Local lRet As Logical
    Local nOpca As Numeric
    Local nRegEmp As Numeric
    Local nx As Numeric

    Private cCadastro As Character
    Private cMVIRNAT As Character
    Private cMVINSNAT As Character
    Private cMVPISNAT As Character
    Private cMVCOFNAT As Character
    Private cMVCSLNAT As Character
    Private cPccTit As Character

    Default lAutomato := .F.

    lPanelFin := IsPanelFin()
    nOpca := 0
    aButtons := {}
    aSays := {}
    nRegEmp	:= SM0->(Recno())

    aNatVar	:= {"cMVIRNAT","cMVINSNAT","cMVPISNAT","cMVCOFNAT","cMVCSLNAT"}
    nx := 0
    aSE2Stru := SE2->(dbStruct())

    aSelFil := {}
    aTmpFil := {}
    cTmpSE2Fil := ""

    cCadastro := STR0001  //"Gera dados para DIRF"
    cMVIRNAT := Eval({|| SuperGetMv("MV_IRF",.T.,"IRF")})
    cMVINSNAT := Eval({|| SuperGetMv("MV_INSS",.T.,"INSS")})
    cMVPISNAT := Eval({|| SuperGetMv("MV_PISNAT",.T.,"PIS")})
    cMVCOFNAT := Eval({|| SuperGetMv("MV_COFINS",.T.,"COFINS")})
    cMVCSLNAT := Eval({|| SuperGetMv("MV_CSLL",.T.,"CSLL")})
    cPccTit := Alltrim("('"+GetMV("MV_PISNAT"))+"','"+ALLTRIM(GETMV("MV_COFINS"))+"','"+ALLTRIM(GETMV("MV_CSLL"))+"')"

	If __lFMP1171 == Nil
		__lFMP1171 := SuperGetMV("MV_FMP1171",.F.,.F.)
	EndIf
	If __nFVL1171 == Nil
 		__nFVL1171:= SuperGetMV("MV_FVL1171",.F.,528)
	EndIf
    //-- Valida a licença do módulo
    If lRet := VldLicenca()

        If cPaisLoc != "BRA"
            MsgStop(STR0041,STR0031) //"Atenção" "Rotina somente para o país Brasil."
            Return
        EndIf

        If GetHlpLGPD({"A2_CGC"})
	        Return
        EndIf

        If Len(aStru) == 0
	        For nX := 1 To len(aSE2Stru)
		        If aSE2Stru[nX,2] != 'C'
			        aAdd(aStru,{aSE2Stru[nX,1], aSE2Stru[nX,2], aSE2Stru[nX,3],aSE2Stru[nX,4]})
        		EndIf
	        Next nX
        EndIf

        //-- Carregar variaveis
        __lPCCBaixa	:= NIL
        __lPaBruto	:= NIL
        F401PccBx()

        //Variavel para armazenar a natureza do IRRF,INSS,PIS,COFINS e CSLL, resultado de formula e/ou string, garantindo-se que o retorno sera sempre do tipo caracter,
        //evitando falhas de validacao por tipo de dados.
        For nx := 1 to Len(aNatVar) Step 1
            bOk := .F.
            If At('"', &(aNatVar[nx])) > 0
                bOk = .T.
            ElseIf At('(', &(aNatVar[nx])) > 0
                bOk := .T.
            ElseIf At("'", &(aNatVar[nx])) > 0
                bOk := .T.
            Endif
            //O conteudo do parametro eh uma formula ou esta declarado com aspas ou apostrofo, precisa de macrosubstituicao
            If bOk
                &(aNatVar[nx]) := &(&(aNatVar[nx]))
            Endif
            If ValType(&(aNatVar[nx])) # "C"
                &(aNatVar[nx]) := cValToChar(&(aNatVar[nx]))
            Endif
        Next nx

        /*
        ---------------------------------------------------
        01	Considera Data ?
        02	Data inicial ?
        03	Data final ?
        04	Tipo de Fornecedor ?
        05	Verifica data ?
        06	Centralizar na filial ?
        07	Gerar Log de Processamento ?
        08  Seleciona Filiais ?
        09  Qual data usar para processar Tit. PCC ?
        10  Considera Pagto Antecipado(PA)?
        ---------------------------------------------------
        */
        
        //-- Define valor padrao para o novo parâmetro, caso nao exista na base
        MV_PAR10 := 2
        pergunte("FIN401",.F.)

        nOpcA := 0
        aSays := {}
        AADD(aSays, STR0002) //"Este programa tem como objetivo gerar os dados necessarios  "
        AADD(aSays, STR0003) //"para DIRF na folha, utilizando os titulos a pagar que tenham"
        AADD(aSays, STR0004) //"sido informados o campo E2_DIRF como 1-Sim"

        ProcLogIni( aButtons )  //-- Inicializa o log de processamento

        If !lAutomato
            If lPanelFin  //-- Chamado pelo Painel Financeiro
                aButtonTxt := {}
                If Len(aButtons) > 0
                    AADD(aButtonTxt,{STR0006,STR0006,aButtons[1][3]}) // Visualizar
                Endif
                AADD(aButtonTxt,{STR0007,STR0007, {||Pergunte("FIN401",.T. )}}) // Parametros
                FaMyFormBatch(aSays,aButtonTxt,{||If(F401VldCtz(),nOpca:= 1,nOpca:=0)},{||nOpca:=0})
            Else
                AADD(aButtons, { 5,.T.,{|| Pergunte("FIN401",.T. ) } } )
                AADD(aButtons, { 1,.T.,{|o| If(F401VldCtz(),(nOpca:= 1,o:oWnd:End()),nOpca:=0)}} )
                AADD(aButtons, { 2,.T.,{|o| o:oWnd:End() }} )
                FormBatch( cCadastro, aSays, aButtons ,,,390)
            Endif
        Else
            nOpca:= 1
        Endif
        
        If nOpcA == 1

            //-- Selecao de filiais
            If MV_PAR08 == 1 .And. Len( aSelFil ) <= 0
                If !lAutomato
                    aSelFil := AdmGetFil(.F.,.T.,"SE2")
                Else
                    If FindFunction("GetParAuto")
                        aRetAuto 		:= GetParAuto("FINA401TESTCASE")
                        aSelFil := aRetAuto[2]
                    EndIf
                EndIf
                If Len( aSelFil ) <= 0
                    Return
                EndIf
            Else
                aSelFil := { cFilAnt }
            EndIf

            cFilSel := FinSelFil( aSelFil, "SE2", .F., .T., 3)
            cFilSel := Replace(cFilSel,"E2_FILIAL","") //Mantem cFilSel s/ E2_FILIAL (pareando c/ o retorno antigo da GetRngFil)

            aAdd(aTmpFil, cTmpSE2Fil)

            ProcLogAtu("INICIO")   //-- Atualiza o log de processamento
            Processa({|lEnd| fa401Processa(aSelFil,lAutomato)})
            ProcLogAtu("FIM")   //-- Atualiza o log de processamento

            For nX := 1 TO Len(aTmpFil)
                CtbTmpErase(aTmpFil[nX])
            Next

            FinEraseTmpFil()

            SM0->(dbGoTo(nRegEmp))
            cFilAnt := FWGETCODFILIAL

        Endif

        //-- O codigo abaixo eh utilizado nesse ponto para garantir que tanto o alias
        //-- quanto o browse serao recriados sem problemas na utilizacao do painel
        //-- financeiro quando a rotina nao eh chamada de forma semi-automatica pois
        //-- esse tratamento eh realizado na rotina
        If lPanelFin //-- Chamado pelo Painel Financeiro
            dbSelectArea(FinWindow:cAliasFile)
            ReCreateBrow(FinWindow:cAliasFile,FinWindow)
        Endif
    EndIf

Return lRet


/*/{Protheus.doc} Fa401Processa
	Processa geracao dos dados da DIRF para folha
	@type function
	@version 
	@author Claudio D. de Souza
	@since 24/08/2021
	@param aSelFil, array, param_description
	@param lAutomato, logical, param_description
	@return variant, return_description
/*/
Static Function Fa401Processa(aSelFil as Array, lAutomato as Logical)
	Local cRaMat          as Character
	Local aArea           as Array
	Local cChave          as Character
	Local lF401dcmp       as Logical
	Local aTitulo         as Array
	Local cTipoFj         as Character
	Local cFiltro         as Character
	Local cCampo          as Character
	Local cCampoP         as Character
	Local lAchouPai       as Logical
	Local cAliasPai       as Character
	Local aRecno          as Array
	Local cRecno          as Character
	Local nX              as Numeric
	Local nY              as Numeric
	Local cAliasTrb       as Character
	Local cChaveSr4       as Character
	Local cQuery          as Character
	Local nI              as Numeric
	Local cIndex          as Character

	Local lDelFisico      as Logical
	Local aTitPLS         as Array
	Local lContinua       as Logical
	Local dDtIni          as Date

	Local lReproc         as Logical
	Local nRendTributavel as Numeric
	Local aTitPai         as Array
	Local aBxPai          as Array
	Local aUltPCC         as Array
	Local aFornec         as Array
	Local aTitJaProc      as Array
	Local nNaoTributavel  as Numeric
	Local bAscan          as Codeblock
	Local nDedDep         as Numeric
	Local cFilAtu         as Character
	Local cTitsSum        as Character
	Local lF401GRV        as Logical
	Local cFilSR4         as Character

	Local cDtPgt          as Character
	Local cNat            as Character
	Local lGerLog         as Logical
	Local nRecMin         as Numeric
	Local nRecMax         as Numeric
	Local aLog            as Array
	Local cArqLog         as Character
	Local nPosLog         as Numeric
	Local nTotREG         as Numeric
	Local aCRIN480        as Array
	Local lGrvDIRF        as Logical
	Local lPCCbxado       as Logical
	Local lRetemPCC       as Logical
	Local lPJIRPrg        as Logical
	Local cFilInic        as Character
	Local cArqTMP1        as Character
	Local cArqINDEX1      as Character
	Local aCampos         as Array
	Local cAbatim         as Character
	Local cImpostos       as Character
	Local cTipoIn         as Character
	Local lErroUpd        as Logical

	//fornecedor exterior
	Local lTemNIF         as Logical
	Local cNIFEX          as Character
	Local lForExt         as Logical
	Local nTamNIF         as Numeric
	Local lGeraNIF        as Logical

	Local lF401VldPai     as Logical
	Local lVldPai         as Logical
	Local nK              as Numeric
	Local aCPFs           as Array
	Local nValCalc        as Numeric
	Local nValOriIR       as Numeric
	Local lPa             as Logical

	Local nSomaBxPA       as Numeric
	Local nImpEmis        as Numeric
	Local lInssPA         as Logical
	Local aRetBaseIR      as Array
	Local cMesAnt         as Character
	Local aRecnoFon       as Array
	Local cTpRen          as Character
	Local cFilCen         as Character
	Local cFilSE2         as Character
	Local aFilProc        as Array
	Local nDedSimp 		  as Numeric
	Local nBaseTrb 		  as Numeric
	Local nTotInsD 		  as Numeric
	Local lFa401Grv		  as Logical	

	aArea           := GetArea()
	cChave          := ""
	lF401dcmp       := ExistBlock("F401DCMP")
	aTitulo         := {}
	lAchouPai       := .T.
	aRecno          := {}
	cRecno          := ""
	cQuery          := ""
	nI              := 0

	lDelFisico      := GetNewPar( 'MV_FIN401D' ,.T.)
	aTitPLS         := {}
	lContinua       := .T.


	lReproc         := .F.
	nRendTributavel := 0
	aTitPai         := {}
	aBxPai          := {} //usado para o PCC na baixa.
	aUltPCC         := {} //usado para verificar se já foi composta a base de calculo da ultima baixa com pcc.
	aFornec         := {}
	aTitJaProc      := {}
	nNaoTributavel  := 0
	nDedDep         := 0
	cFilAtu         := cFilAnt
	cTitsSum        := ""
	lF401GRV        := Existblock("lF401GRV")
	cFilSR4         := xFilial("SR4")

	cNat            := ""
	lGerLog         := (MV_PAR07 == 1)
	nRecMin         := 0
	nRecMax         := 0
	aLog            := {}
	cArqLog         := ""
	nPosLog         := 0
	nTotREG         := 0
	aCRIN480        := {}
	lGrvDIRF        := .T.
	lRetemPCC       := .F.
	lPJIRPrg        := .F.
	cFilInic        := cFilAnt //Filial atual do sistema, essa variável não deve ser alterada em momento algum da rotina
	//Cria arquivo temporário para controle que os titulos não sejam enviados com duplicidade.
	cArqTMP1        := ""
	cArqINDEX1      := CriaTrab(,.F.)
	aCampos         := {}
	cAbatim         := MV_CRNEG+"|"+MV_CPNEG+"|"+MVIRABT+"|"+MVCSABT+"|"+MVCFABT+"|"+MVPIABT+"|"+MVABATIM
	cImpostos       := MVISS+"|"+ MVTAXA+"|"+MVINSS+"|"+"SES"
	cTipoIn         := ""
	lErroUpd        := .F.

	//fornecedor exterior
	lTemNIF         := .F.
	cNIFEX          := ""
	lForExt         := .F.
	nTamNIF         := 0
	lGeraNIF        := .F.

	lF401VldPai     := Existblock("F401VldPai")
	lVldPai         := .F.
	nK              := 0
	aCPFs           := {}
	nValCalc        := 0
	nValOriIR       := 0
	lPa             := .F.

	nSomaBxPA       := 0
	nImpEmis        := 0
	lInssPA         := .F.
	aRetBaseIR      := {}
	cMesAnt         := ""
	aRecnoFon       := {}
	cTpRen          := ""
	cFilCen         := cFilAnt
	cFilSE2         := ""
	aFilProc        := {}
	nDedSimp		:= 0
	nTotInsD		:= 0
	nBaseTrb		:= 0
	lFa401Grv 		:= ExistBlock("FA401GRV")
	
	Static cChavePF as Character
	Static cTipoP   as Character

	Default lAutomato := .F.

	If FindFunction( 'IsIssBx' )
		lCalcIssBx :=	IsIssBx( "P" )
	Else
		lCalcIssBx :=	SA2->A2_TIPO == "J" .And. GetNewPar("MV_MRETISS","1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)
	EndIf

	cFilSA2 := FinSelFil( aSelFil, "SA2", .F., .T., 3)
	__cFilSE2 := FinSelFil( aSelFil, "SE2", .F., .T., 3)
	nTamNIF := TamSx3("RL_NIFEX")[1]

	Do Case
		Case "MSSQL"$cBDname
			cQryConcat := "+"
		Case "MYSQL"$cBDname
			cQryConcat := "CONCAT("
		Otherwise
			cQryConcat := "||"
	Endcase

	F401PccBx()

	If MV_PAR10 == 1
		If !__lPccBaixa
			MV_PAR10 := 2
		EndIf
		MsgAlert(STR0042) //"Somente será considerado o TX gerado de PA, se a configuração de retenção de IR e PCC for na baixa!"
	EndIf

	If ExistBlock("FINCDRET")
		aCRIN480 :=ExecBlock("FINCDRET")
	End

	AADD(aCampos,{"NROREG"  	,"N",9,0})
	AADD(aCampos,{"TITIPAI"  	,"L",1,0})
	CriaTMP(aCampos,@cArqTMP1,"TMP1",cArqINDEX1,"NROREG")

	// Se existir o campo da data de processamento, questiona se trata-se de reprocessamento

	If !lAutomato
		lReproc := MsgNoYes(	STR0033+Chr(13)+Chr(13)+;		//'Deseja reprocessar a geração dos dados para o ano do periodo solicitado?'
							STR0034+;						//'Se optar por "Sim", os dados já registrados no periodo serão processados. Será '
							STR0035+;						//'efetuada a exclusão apenas dos dados do financeiro já  processados no período e serão '
							STR0036+Chr(13)+;				//'considerados todos os itens do periodo. Reprocessar primeiro a filial centralizadora e depois, as demais.'
							STR0037+;						//'Se optar por "Não", nenhum dado será excluido e apenas os titulos ainda não processados '
							STR0038,STR0031)				//'serão enviados a DIRF.'###"Atenção"
	Else
		If FindFunction("GetParAuto")
			aRetAuto 		:= GetParAuto("FINA401TESTCASE")
			lReproc := aRetAuto[1]
		EndIf
	EndIf

	If lReproc
		If lDelFisico

			// Se possuir filial centralizadora, posiciona nesta filial
			If !Empty(MV_PAR06) .And. SM0->(MsSeek(cEmpAnt+MV_PAR06))
				cFilAnt := MV_PAR06
			Endif

			cQuery := "SELECT min(R_E_C_N_O_) MINREC , MAX(R_E_C_N_O_) MAXREC FROM " + RetSqlName( "SR4" ) + " "
			cQuery += " WHERE R_E_C_N_O_ IN ( "
			cQuery += " SELECT B.R_E_C_N_O_ FROM "
			cQuery += RetSqlName("SR4") + " B , "
			cQuery += RetSqlName("SA2")+" A "
			cQuery += " WHERE B.R4_FILIAL  = '"	+ xFilial("SR4") 	+ "'"
			cQuery += "   AND (B.R4_ANO >= '"	+ StrZero(Year(MV_PAR02),4)	+ "'"
			cQuery += "   AND B.R4_ANO <= '"	+ StrZero(Year(MV_PAR03),4)	+ "')"
			cQuery += "   AND B.R4_ORIGEM = '2' "
			cQuery += "   AND B.D_E_L_E_T_ = ' ' "

			cQuery += "   AND A.A2_FILIAL  " + cFilSA2

			cQuery += "   AND ( (A.A2_CGC = B.R4_CPFCGC OR A.A2_CPFIRP = B.R4_CPFCGC )  "
			If lExistFKJ
				cQuery += " OR EXISTS(SELECT FKJ.FKJ_COD, FKJ.FKJ_LOJA FROM " + RETSQLNAME('FKJ')
				cQuery += " FKJ WHERE FKJ.FKJ_FILIAL = A.A2_FILIAL "
				cQuery += " AND FKJ.FKJ_COD = A.A2_COD "
				cQuery += " AND FKJ.FKJ_LOJA = A.A2_LOJA "
				cQuery += " AND FKJ.FKJ_CPF = B.R4_CPFCGC "
				cQuery += " AND FKJ.D_E_L_E_T_ = ' ' ) "
			EndIf
			cQuery += " ) AND "

			cQuery += Fa401SqlA2( SA2_SQL_WHERE , "A" )

			cQuery += " A.D_E_L_E_T_ = ' ' ) "

			cQuery := ChangeQuery(cQuery)

			dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"SR4DEL",.F.,.T.)

			SR4DEL->(DbGoTop())
			nRecMin := SR4DEL->(MINREC)
			nRecMax := SR4DEL->(MAXREC)

			SR4DEL->(dbCloseArea())

			While nRecMin <= nRecMax
				cQuery := "DELETE FROM " + RetSqlName( "SR4" ) + " "
				cQuery += " WHERE R_E_C_N_O_ BETWEEN " + Str(nRecMin) + " AND " + Str(nRecMin + 1000) + " AND "
				cQuery += " R_E_C_N_O_ IN ( "
				cQuery += " SELECT B.R_E_C_N_O_ FROM "
				cQuery += RetSqlName("SR4") + " B , "
				cQuery += RetSqlName("SA2")+" A "
				cQuery += " WHERE B.R4_FILIAL  = '"	+ xFilial("SR4") 	+ "'"
				cQuery += "   AND (B.R4_ANO >= '"	+ StrZero(Year(MV_PAR02),4)	+ "'"
				cQuery += "   AND B.R4_ANO <= '"	+ StrZero(Year(MV_PAR03),4)	+ "')"
				cQuery += "   AND B.R4_ORIGEM = '2' "

				cQuery += "   AND B.D_E_L_E_T_ = ' ' "

				cQuery += "   AND A.A2_FILIAL " + cFilSA2

				cQuery += "   AND ( (A.A2_CGC = B.R4_CPFCGC OR A.A2_CPFIRP = B.R4_CPFCGC )  "
				If lExistFKJ
					cQuery += " OR EXISTS(SELECT FKJ.FKJ_COD, FKJ.FKJ_LOJA FROM " + RETSQLNAME('FKJ')
					cQuery += " FKJ WHERE FKJ.FKJ_FILIAL = A.A2_FILIAL "
					cQuery += " AND FKJ.FKJ_COD = A.A2_COD "
					cQuery += " AND FKJ.FKJ_LOJA = A.A2_LOJA "
					cQuery += " AND FKJ.FKJ_CPF = B.R4_CPFCGC "
					cQuery += " AND FKJ.D_E_L_E_T_ = ' ' ) "
				EndIf
				cQuery += " ) "

				If MV_PAR04 == 1 //Fisico
					//Se for PJ com IR Progressivo, será tratado como Pessoa Física.
					cQuery +=	" AND (A.A2_TIPO = 'F' OR (A.A2_TIPO = 'J' AND A.A2_IRPROG = '1')) "

				Else
					cQuery +=	" AND (A.A2_TIPO = 'X'  OR (A.A2_TIPO = 'J' AND A.A2_IRPROG != '1') )"
				Endif

				cQuery += " AND A.D_E_L_E_T_ = ' ' ) "

				nResult := TcSqlExec(cQuery)

				nRecMin += 1000

				//Restauro a filial do sistema quando processar com filial centralizadora
				If !Empty(MV_PAR06)
					cFilAnt := cFilAtu
				Endif

			EndDo
		Else

			cQuery := "UPDATE "+RetSqlName("SR4")+" "
			cQuery += "SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_ "
			cQuery += "WHERE R_E_C_N_O_ IN ( "
			cQuery += "SELECT B.R_E_C_N_O_ FROM "
			cQuery += RetSqlName("SR4") + " B , "
			cQuery += RetSqlName("SA2")+" A "
			cQuery += " WHERE B.R4_FILIAL  = '"	+ cFilSR4 	+ "'"
			cQuery += " AND (B.R4_ANO >= '"	+ StrZero(Year(MV_PAR02),4)	+ "'"
			cQuery += " AND B.R4_ANO <= '"	+ StrZero(Year(MV_PAR02),4)	+ "')"
			cQuery += "   AND B.R4_ORIGEM = '2' "

			cQuery += " AND B.D_E_L_E_T_ = ' ' "

			cQuery += "   AND A.A2_FILIAL " + cFilSA2

			cQuery += "   AND (A.A2_CGC = B.R4_CPFCGC OR A.A2_CPFIRP = B.R4_CPFCGC ) "

			If MV_PAR04 == 1 //Fisico
				//Se for PJ com IR Progressivo, será tratado como Pessoa Física.
				cQuery +=	" AND (A.A2_TIPO = 'F' OR (A.A2_TIPO = 'J' AND A.A2_IRPROG = '1')) "
			Else
				cQuery +=	" AND (A.A2_TIPO = 'X'  OR (A.A2_TIPO = 'J' AND A.A2_IRPROG != '1')) "
			Endif

			cQuery += " AND A.D_E_L_E_T_ = ' ' ) "

			nResult := TcSqlExec(cQuery)

		Endif
	Endif

	// Posiciona no ultimo registro do Cadastro de funcionarios
	// para verificar a ultima matricula na filial atual
	DbSelectArea("SRA")
	DbSetOrder(1)
	DbSeek(IncLast(xFilial("SRA")),.T.)
	DbSkip(-1)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre o SE2 com outro alias para ser localizado o titulo 	 ³
	//³ principal do imposto                   							 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !( ChkFile("SE2",.F.,"NEWSE2") )
		Return(Nil)
	EndIf

	lQuery := .T.

	DbSelectArea("SRL")
	DbSetOrder(2)

	DbSelectArea("SR4")
	DbSetOrder(1)

	DbSelectArea("SE2")
	DbSetOrder(1)

	DbSelectArea("NEWSE2")
	DbSetOrder(1)

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³  Variaveis utilizadas para parametros									³
	³  MV_PAR01		 // Considera data                                      ³
	³  MV_PAR02		 // Data Inicial										³
	³  MV_PAR03		 // Data final  			                            ³
	³  MV_PAR04		 // Tipo de Fornecedor							        ³
	³  MV_PAR05		 // Verifica data										³
	³  MV_PAR06      // Centralizar na filial						        |
	³  MV_PAR07      // Gerar Log de Processamento ?  				        |
	³  MV_PAR08      // Seleciona Filial							        |
	³  MV_PAR09      // Qual data usar para processar Tit. PCC		        |
	³  MV_PAR10      // Considera Pagto. Antecipado?							        |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	*/

	If MV_PAR10 == 2 // NAO-mantem a atual
		cTipoIn := FormatIn(cAbatim+"|"+cImpostos+"|"+MVPROVIS+"|"+MVPAGANT + "|" +MVTXA  ,"|")
	Else
		cTipoIn := FormatIn(cAbatim+"|"+cImpostos+"|"+MVPROVIS ,"|")
	EndIf

	if lReproc .and. lQuery
		//faz a limpeza de E2_DTDIRF
		f401LimpaDt(cTipoIn,@lErroUpd)
	EndIf

	If lFina405 .and. lReproc .and. MV_PAR04 == 2 // PJ
		//atualiza flag dos registro de repasse de IR
		Fa405Limpa(MV_PAR06,MV_PAR02,MV_PAR03, MV_PAR08)
	EndIf


	Fa401SqlCImp(@cAliasTrb,@cQuery,@lPlsAtiv,@lReproc,@cPccTit,@cCampo,@cCampoP,@cChave,@ni,@nTotREG,@cIndex,,@cFiltro,cTipoIn)
	ProcRegua(nTotREG)

	aTitPLS := {}
	aTitPai := {}
	SFQ->(dbSetOrder(1))

	While (cAliasTrb)->(!Eof()) //.And. (cAliasTrb)->E2_FILIAL == xFilial("SE2")

		IncProc()

		aRetBaseIR := {}
		lPCCbxado := .F.
		lAchouPai := .F.
		lTemNIF := .F.
		cNIFEX := Space(nTamNIF)
		lForExt := .F.	
		cNat := AllTrim( (cAliasTrb)->E2_NATUREZ )

		//Seto a filial atual para a filial de origem do titulo TX
		If !Empty(MV_PAR06)
			If !Empty((cAliasTrb)->E2_FILORIG)
				cFilAnt := (cAliasTrb)->E2_FILORIG
				cFilAtu := (cAliasTrb)->E2_FILORIG
			ElseIf Empty(cFilAnt) .And. Alltrim(cFilAnt)<>Alltrim((cAliasTrb)->E2_FILIAL)
				cFilAnt := (cAliasTrb)->E2_FILIAL
				cFilAtu := (cAliasTrb)->E2_FILIAL
			Endif
		Endif

		// Posiciona no titulo pai para obter o valor total do titulo
		If !Empty((cAliasTrb)->(RECNOPAI))
			cAliasPai := "NEWSE2"
			(cAliasPai)->(DBGoto((cAliasTrb)->(RECNOPAI) ))
			lAchouPai :=  (cAliasPai)->(Recno()) == (cAliasTrb)->(RECNOPAI)
		EndIf
		If !lAchouPai
			lAchouPai := Fa401Pai(cAliasTrb)
			cAliasPai := If( lAchouPai , "NEWSE2" , cAliasTrb)
		EndIf
		If !lAchouPai
			If lFA401PROC
				ExecBlock("FA401PROC",.F.,.F.)
			EndIf
			(cAliasTrb)->(dbSkip())
			Loop
		EndIf

		dbSelectArea("SA2")
		dbSetOrder(1)
		If !dbSeek(xFilial("SA2")+(cAliasPai)->(E2_FORNECE+E2_LOJA))
			(cAliasTrb)->(dbSkip())
			Loop
		EndIf

		dbSetOrder(1)
		If ! SED->(dbSeek(xFilial("SED")+(cAliasPai)->(E2_NATUREZ)))
			(cAliasTrb)->(dbSkip())
			Loop
		EndIf

		lIrBx := SA2->A2_CALCIRF == "2" .And. SED->ED_CALCIRF = "S"
		lRetemPCC := __lPccbaixa .and. ( SA2->A2_RECPIS == "2" .OR. SA2->A2_RECCOFI == "2" .OR. SA2->A2_RECCSLL == "2")
		lInssPA := SED->ED_RINSSPA = "1"


		// PE para ignorar determinados registros do SE2 que não devem fazer parte da gravação da DIRF.
		If lF401GRV
			lGrvDIRF := ExecBlock("lF401GRV",.F.,.F.,{cAliasTrb})
		Endif

		//Verifico o tipo da pessoa do Fornecedor (Fisico ou Juridico.
		//Em branco ou X - Outros, serao verificados pelo CGC
		If Empty(SA2->A2_TIPO) .or. !(SA2->A2_TIPO $ "F/J")
			If SA2->A2_TIPO == 'X' // Fornecedor exterior processa como PJ
				cTipoFj := "2"
			ElseIf SA2->A2_IRPROG == '1'
				cTipoFj := "1"
			Else
				cTipoFj := Iif(Len(AllTrim(SA2->A2_CGC	)) > 11 .or. Empty(SA2->A2_CGC),"2","1")
			EndIf
		Else
			cTipoFj := IIf( SA2->A2_TIPO = "F" , "1" , If(SA2->A2_TIPO == 'J' .AND. SA2->A2_IRPROG == '1',"1","2") )
		Endif
		IIF( SA2->A2_TIPO == "F" , cTipoP := "1" , cTipoP := "2" )
		// Se for um fornecedor definido no parametro
		If Val(cTipoFj) == MV_PAR04

			lContinua := .T.

			If !(cNat$cPccTit) //Titulo de Pcc
				If MV_PAR05 == 1 // Verifica Data Titulo Principal
					Do Case
						Case MV_PAR01 == 3 // Considera Data Vencto Real
							If (cAliasPai)->(E2_VENCREA) < MV_PAR02 .OR. (cAliasPai)->(E2_VENCREA) > MV_PAR03
								lContinua := .F.
							EndIf
						Case MV_PAR01 == 2 // Considera Data Vencto
							If (cAliasPai)->(E2_VENCTO) < MV_PAR02 .OR. (cAliasPai)->(E2_VENCTO) > MV_PAR03
								lContinua := .F.
							EndIf
						Case MV_PAR01 == 1 // Considera Emissão Digit.
							If (cAliasPai)->(E2_EMIS1) < MV_PAR02 .OR. (cAliasPai)->(E2_EMIS1) > MV_PAR03
								lContinua := .F.
							EndIf
						Case MV_PAR01 == 4 // Considera Data baixa
							If (!Empty((cAliasPai)->(E2_BAIXA)) .AND. ((cAliasPai)->(E2_BAIXA) < MV_PAR02 .OR. (cAliasPai)->(E2_BAIXA) > MV_PAR03)) .OR.;
							( Empty((cAliasPai)->(E2_BAIXA)) .AND. ((cAliasPai)->(E2_EMIS1) < MV_PAR02 .OR. (cAliasPai)->(E2_EMIS1) > MV_PAR03))
								lContinua := .F.
							EndIf
						Case MV_PAR01 == 5 // Considera Emissão Real.
							If (cAliasPai)->(E2_EMISSAO) < MV_PAR02 .OR. (cAliasPai)->(E2_EMISSAO) > MV_PAR03
								lContinua := .F.
							EndIf
					EndCase
				EndIf
			Else
				If MV_PAR05 == 1 // Verifica Data Titulo Principal
					Do Case
						Case MV_PAR09 == 3 // Considera Data Vencto Real
							If (cAliasPai)->(E2_VENCREA) < MV_PAR02 .OR. (cAliasPai)->(E2_VENCREA) > MV_PAR03
								lContinua := .F.
							EndIf
						Case MV_PAR09 == 2 // Considera Data Vencto
							If (cAliasPai)->(E2_VENCTO) < MV_PAR02 .OR. (cAliasPai)->(E2_VENCTO) > MV_PAR03
								lContinua := .F.
							EndIf
						Case MV_PAR09 == 1 // Considera Emissão
							If (cAliasPai)->(E2_EMIS1) < MV_PAR02 .OR. (cAliasPai)->(E2_EMIS1) > MV_PAR03
								lContinua := .F.
							EndIf
						Case MV_PAR09 == 4 // // Considera Data baixa, se for PA considera data de emissao
							If __lPccBaixa
								//se for PCC na baixa, considera data de emissao do TX 
								If ( (cAliasTrb)->(E2_EMIS1) < MV_PAR02 .OR. (cAliasTrb)->(E2_EMIS1) > MV_PAR03 ) .and. !(cAliasPai)->E2_TIPO $ MVPAGANT
									lContinua := .F.
								EndIF
							Else
								If (( (cAliasPai)->(E2_BAIXA) < MV_PAR02 .OR. (cAliasPai)->(E2_BAIXA) > MV_PAR03 ) .and. !(cAliasPai)->E2_TIPO $ MVPAGANT) .OR.;
								(( (cAliasPai)->(E2_EMIS1) < MV_PAR02 .OR. (cAliasPai)->(E2_EMIS1) > MV_PAR03 ) .and. (cAliasPai)->E2_TIPO $ MVPAGANT)

									lContinua := .F.
									EndIf
							EndIF
						Case MV_PAR09 == 5 // Considera Emissão Real
							If (cAliasPai)->(E2_EMISSAO) < MV_PAR02 .OR. (cAliasPai)->(E2_EMISSAO) > MV_PAR03
								lContinua := .F.
							EndIf
					EndCase
				EndIf
			Endif
			nSomaBxPA := 0
			nImpEmis  := 0
			//tratamento para PA
			//MV_PAR10 = Nao - Mantem legado, nao envia pa somente titulos principais
			//MV_PAR10 = Sim - Toda PA sera enviada, e será tratado a NF que foi compensada, nao deve ir
			If lContinua .and. MV_PAR10 == 1 //sim -considera pagamento antecipado

				If !(cAliasPai)->E2_TIPO $ MVPAGANT
					lPa := .F.
				Else
					lPa := .T.
					If !lIrBx .or. SA2->A2_TIPO != 'J' .OR. !lRetemPCC
						lContinua := .F.
					EndIf
				EndIf

				If lContinua
					If ((lIrBx .and. cNat$cMVIRNAT) .or. (__lPccbaixa .and. cNat$cPccTit) ) .and. !lPa
						//verifica se NF foi compensada
						nSomaBxPA := RetValCMP(cAliasPai,,lIrBx,lCalcIssBx,@nImpEmis)

						//Se Imposto é na baixa e houve compensacao da NF, desconsiderar a NF, pois será enviado a PA
						If nSomaBxPA > 0
							If nSomaBxPA == (cAliasTrb)->E2_VALOR + Iif(lIrBx,0, (cAliasTrb)->E2_IRRF) + Iif(__lPccbaixa,0,(cAliasTrb)->(E2_PIS+E2_COFINS+E2_CSLL)) +  (cAliasTrb)->E2_INSS + If(lCalcIssBx,0,(cAliasTrb)->E2_ISS)
								lContinua := .F.
							EndIf
						EndIf

					ElseIf lPa

						// verifica se PA nao está baixada, o que significa o seu cancelamento
						nSomaBxPA := RetValCMP(cAliasPai,(cAliasTrb)->E2_TIPO $ MVTXA ,lIrBx,lCalcIssBx,@nImpEmis)

						If nSomaBxPA > 0
							If nSomaBxPA == (cAliasPai)->E2_VALOR + If(__lPaBruto,If(lInssPA,(cAliasPai)->E2_INSS,0),(cAliasPai)->(E2_IRRF + E2_PIS + E2_COFINS + E2_CSLL) + Iif(__lPrImPA, (cAliasPai)->(E2_ISS + E2_PRISS + E2_INSS + E2_PRINSS),0 ))
								//PA foi baixada, devolucao da PA desconsiderar PA
								lContinua := .F.
							EndIf
						EndIf
					EndIf
				EndIf

			EndIf

			If lContinua .and. lGrvDIRF

				// Se possuir filial centralizadora, posiciona nesta filial
				If !Empty(MV_PAR06)
					SM0->(MsSeek(cEmpAnt+MV_PAR06))
					cFilAnt := MV_PAR06
				Endif

				aCPFs 		:= {}
				nValOriIR 	:= (cAliasTrb)->E2_VALOR
				lPJIRPrg 	:= SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG == '1'
				If (lPJIRPrg .or. FKJ->(MsSeek(xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA) )) .And. (cNat$cMVIRNAT)
					aCPFs := VerCPFProg(cAliasPai,cAliasTrb,.F.)
				Else
					Aadd(aCPFs, {Padr(SA2->A2_CGC,Len(SRL->RL_CPFCGC)),100,SA2->A2_NOME, SA2->A2_COD, SA2->A2_LOJA,.F.})
				EndIf

				//tratamento para fornecedor
				lGeraNIF := .F. 
				If !EMPTY(SA2->A2_PAISEX) 
					If IsCodResExt((cAliasTrb)->E2_CODRET)
						lForExt := .T.
						lGeraNIF := .T.
					ElseIf SA2->A2_TIPO $ "J|X" .and. (Empty(SA2->A2_CGC) .or. SA2->A2_CGC =="00000000000000")
						// Se for um fornecedor exterior gerando titulo com cod retenção sem ser do exterior
						// com cgc em branco ou zerado, gera a chave nif para separar os fornecedores, mas este deve tratar como brasil
						lGeraNIF := .T.
					EndIf
					If lGeraNIF
						// fornecedor exterior sem NIF, envia cod+loja como chave
						If Empty(SA2->A2_NIFEX)
							cNIFEX := SA2->A2_COD +  SA2->A2_LOJA
							lTemNIF := .F.
						Else
							cNIFEX := SA2->A2_NIFEX
							lTemNIF := .T.
						EndIf
					EndIf
				EndIf

				For nK := 1 To Len(aCPFs)

					//RL_FILIAL, RL_CGCFONT, RL_CODRET, RL_TIPOFJ, RL_CPFCGC, R_E_C_N_O_, D_E_L_E_T_
					// Pesquisa cabecalho da DIRF
					If !SRL->(MsSeek(xFilial("SRL")+Padr(SM0->M0_CGC,Len(SRL->RL_CGCFONT))+ ;
							(cAliasTrb)->E2_CODRET +cTipoFj+aCPFs[nK][1] + cNIFEX   ))

						Reclock("SRL", .T.)

						cRaMat := GetSxENum( "SRL" , "RL_MAT")

						SRL->RL_FILIAL  := xFilial("SRL")
						SRL->RL_MAT     := If(Val(SRA->RA_MAT) < 900000 .And. Val(cRaMat) < 900000, "900000",cRaMat)
						SRL->RL_CODRET  := (cAliasTrb)->E2_CODRET
						SRL->RL_TIPOFJ  := cTipoFj
						SRL->RL_CPFCGC  := aCPFs[nK][1] 
						SRL->RL_BENEFIC := aCPFs[nK][3]
						SRL->RL_ENDBENE := Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END)
						SRL->RL_UFBENEF := SA2->A2_EST
						SRL->RL_COMPLEM := SA2->A2_BAIRRO
						SRL->RL_CGCFONT := SM0->M0_CGC
						SRL->RL_NOMFONT := SM0->M0_NOMECOM
						SRL->RL_ORIGEM := "2"
						SRL->RL_NIFEX := cNIFEX

						If IsCodResExt(SRL->RL_CODRET)

							SRL->RL_CGCEX := SA2->A2_CGCEX
							SRL->RL_PAIS  := SA2->A2_PAISEX
							SRL->RL_NEMPR := SA2->A2_NEMPR
							SRL->RL_TPCON := SA2->A2_TPCON
							SRL->RL_DTINI := SA2->A2_DTINIR
							SRL->RL_DTFIM := SA2->A2_DTFIMR
							SRL->RL_LOGEX := SA2->A2_LOGEX
							SRL->RL_NUMEX := SA2->A2_NUMEX
							SRL->RL_COMPL := SA2->A2_COMPLR
							SRL->RL_BAIEX := SA2->A2_BAIEX
							SRL->RL_POSEX := SA2->A2_POSEX
							SRL->RL_CIDEX := SA2->A2_CIDEX
							SRL->RL_ESTEX := SA2->A2_ESTEX
							SRL->RL_TELEX := SA2->A2_TELRE
							SRL->RL_BREEX := SA2->A2_BREEX
							SRL->RL_TPREX := SA2->A2_TPREX
							SRL->RL_TRBEX := SA2->A2_TRBEX
							If !lTemNIF
								If SA2->A2_MOTNIF == "1"                                                                         
									SRL->RL_BEDINI := "1" //Fornecedor dispensado do NIF   
									SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
								Elseif SA2->A2_MOTNIF == "2"             
									SRL->RL_PAEXNI := "2" //País do fornecedor nao exige NIF   
								Endif
							Else
								SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
							Endif
						EndIf

						SRL->(MsUnlock())
					Endif

					//Restauro a filial do sistema quando processar com filial centralizadora
					If !Empty(MV_PAR06)
						cFilAnt := cFilAtu
					Endif

					//Se for pela data da baixa, verifico qual data a ser considerada
					//Se titulo baixado, considero data da baixa
					//Se titulo não baixado, considero data da emissao
					If !cNat$cPccTit	 // Título não PCC
						If MV_PAR01 == 4
							//Data da Baixa
							cCampo := "E2_BAIXA"

							If MV_PAR05 == 1
								If Empty((cAliasPai)->&(cCampo))
									cCampo := "E2_EMIS1"
								Endif
							Else
								If Empty((cAliasTrb)->&(cCampo))
									cCampo := "E2_EMIS1"
								Endif
							Endif
						Endif
					Else  // Título de PCC
						If MV_PAR09 == 4
							//Data da Baixa
							If lPa
								cCampoP := "E2_EMIS1"
							Else
								If __lPccbaixa
									cCampoP := "E2_EMIS1"
								Else
									cCampoP := "E2_BAIXA"
								Endif	
							EndIf

						Endif
					Endif
					If !cNat$cPccTit
						If MV_PAR05 == 1 //se for pelo titulo principal pega data do principal
							cMes := STRZERO(MONTH((cAliasPai)->&(cCampo)),2)
							cAno := STRZERO(YEAR((cAliasPai)->&(cCampo)),4)
							cDtPgt := (cAliasPai)->&(cCampo)
						Else
							cMes := STRZERO(MONTH((cAliasTrb)->&(cCampo)),2)
							cAno := STRZERO(YEAR((cAliasTrb)->&(cCampo)),4)
							cDtPgt := (cAliasTrb)->&(cCampo)
						EndIf
					Else // Tratamento para títulos de pcc
						If MV_PAR05 == 1 //se for pelo titulo principal pega data do principal
							If __lPccbaixa .and. !lPa .and. MV_PAR09 == 4
								cMes := STRZERO(MONTH((cAliasTrb)->&(cCampoP)),2)
								cAno := STRZERO(YEAR ((cAliasTrb)->&(cCampoP)),4)
								cDtPgt := (cAliasTrb)->&(cCampoP)
							Else
								cMes := STRZERO(MONTH((cAliasPai)->&(cCampoP)),2)
								cAno := STRZERO(YEAR ((cAliasPai)->&(cCampoP)),4)
								cDtPgt := (cAliasPai)->&(cCampoP)
							EndIf	
						Else
							cMes := STRZERO(MONTH((cAliasTrb)->&(cCampoP)),2)
							cAno := STRZERO(YEAR ((cAliasTrb)->&(cCampoP)),4)
							cDtPgt := (cAliasTrb)->&(cCampoP)
						EndIf
						IIF(cMes=="00",lPCCbxado:=.T.,lPCCbxado:=.F.)	// Título PCC não foi baixado
					Endif

					If MV_PAR05!=1 .and. !"NF"$(cAliasPai)->E2_TIPO
						If lPCCbxado
							dbSelectArea(cAliasTrb)
							(cAliasTrb)->(dbSkip())
							Loop
						Endif
					Endif

					If cMes = "00" .and. MV_PAR05 == 1
						If lPCCbxado
							dbSelectArea(cAliasTrb)
							(cAliasTrb)->(dbSkip())
							Loop
						Else
							cMes := STRZERO(MONTH((cAliasPai)->&(cCampo)),2)
							cAno := STRZERO(YEAR ((cAliasPai)->&(cCampo)),4)
							cDtPgt := (cAliasPai)->&(cCampo)
						Endif
					Endif

						aTitulo	:= {	aCPFs[nK][1],;
										0					,;
										(cAliasTrb)->E2_CODRET	,;
										cMes,;
										0              ,;
										{}             ,;
										0 /* Valor do INSS */,;
										cAno,;
										0/* Valor Nao Tributado ou Isento */ ,;
										cNIFEX }

					//Se possuir filial centralizadora, posiciona nesta filial
					If !Empty(MV_PAR06)
						cFilAnt := MV_PAR06
					Endif

					// Tipo do rendimento considera tipo da entidade
					If lTpEnt
						If Empty((cAliasTrb)->A2_TPENT)
							cTpRen := "A"
						Else
							If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
								cTpRen := "I2"
							ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
								cTpRen := "I3"
							EndIf
						EndIf
					Else
						cTpRen := "A"
					EndIf

					// Se existir o ano na chave do SR4
					// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
					cChaveSr4 := xFilial("SR4")+SRL->RL_MAT+ Padr(aTitulo[CNPJ],Len(SR4->R4_CPFCGC)) + aTitulo[CODIGORETENCAO]+aTitulo[ANO]+aTitulo[MES]
					cChavePF := cChaveSr4 + padr(cTpRen,nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX
					// Mudou o mes, fornecedor ou codigo de retencao
					// Gera Valor do Imposto do titulo
					//R4_FILIAL, R4_MAT, R4_CPFCGC, R4_CODRET, R4_ANO, R4_MES, R4_TIPOREN, R4_PAIS, R4_NIFEX, R_E_C_N_O_, D_E_L_E_T_
					If !(cAliasTrb)->E2_TIPO $ MVINSS+"|"+"INA"
						If !SR4->( MsSeek( cChaveSr4 + padr("D",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))

							Reclock("SR4", .T.)

							SR4->R4_FILIAL  := xFilial("SR4")
							SR4->R4_MAT     := SRL->RL_MAT
							SR4->R4_CPFCGC  := aTitulo[CNPJ]
							SR4->R4_MES     := aTitulo[MES]
							SR4->R4_TIPOREN := "D"
							SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
							SR4->R4_ANO  := aTitulo[ANO]
							SR4->R4_ORIGEM := "2"
							SR4->R4_NIFEX := SRL->RL_NIFEX

							If !Empty(SRL->RL_PAIS)
								SR4->R4_PAIS := SRL->RL_PAIS
								
								SR4->R4_DTPGT := cDtPgt
								If lISNIF
									SR4->R4_ISNIF := IIF(lTemNIF,"1","2")
								EndIf

							EndIf

						Else
							Reclock("SR4", .F.)
						Endif
						//se NÃO é pela BAIXA do TIT PRINCIPAL
						If !(MV_PAR01 == 4 .and. MV_PAR05 == 1)	.Or. !(MV_PAR09 == 4 .and. MV_PAR05 == 1)
							//Calculo antigo do rateio de CPF's Ir Progressivo, legado
							If !aCPFs[nK][6]
								nValCalc := Round( ( (cAliasTrb)->E2_VALOR * aCPFs[nK][2]) / 100,2 )

								If Len(aCPFs) == nK
									nValCalc := nValOriIR
								Else
									nValOriIR -= nValCalc
								EndIf
							//Novo calculo do rateio de Ir Progressivo
							Else
								nValCalc := (cAliasTrb)->E2_VALOR	
							Endif
							SR4->R4_VALOR   += nValCalc
							nRegPai	:=	(cAliasPai)->(Recno())
							If !TMP1->(Dbseek(nRegPai))
								Reclock("TMP1", .T.)
								TMP1->NROREG 		:= nRegPai
								TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
								TMP1->(MSUNLOCK())
							Endif

							If !Empty(SRL->RL_PAIS)
								SR4->R4_DTPGT := cDtPgt
							EndIf
							SR4->(MsUnlock())
							Fa401AddLog(	@aLog, lGerLog, SR4->R4_CPFCGC, SR4->R4_CODRET, SR4->R4_MES, SR4->R4_TIPOREN, (cAliasTRB)->E2_FILIAL, (cAliasTRB)->E2_PREFIXO,;
												(cAliasTRB)->E2_NUM, (cAliasTRB)->E2_PARCELA, (cAliasTRB)->E2_TIPO, (cAliasTRB)->E2_NATUREZ, nValCalc, cNIFEX, SA2->A2_COD, SA2->A2_LOJA ,;
												SA2->A2_FILIAL , SA2->A2_NOME )
						//se É pela BAIXA do TIT PRINCIPAL
						//vejo se o principal/pai está baixado no período
						//ou, se nao estiver baixado, vejo de a data de emissao está dentro do período solicitado
						Else
							If !cNat$cPccTit  .Or. (cNat$cPccTit .And. MV_PAR09 == 4 .And. MV_PAR05 == 1) //Quando nao for titulo de PCC ou Titulo de PCC e data selecionada for BAIXA.

								If (((cAliasPai)->E2_BAIXA >= MV_PAR02 .AND. (cAliasPai)->E2_BAIXA <= MV_PAR03) .OR.;
									((cAliasPai)->E2_BAIXA == CToD('') .AND. (cAliasPai)->E2_EMIS1 >= MV_PAR02 .AND. (cAliasPai)->E2_EMIS1 <= MV_PAR03))
									SR4->R4_VALOR   += (cAliasTrb)->E2_VALOR

									nRegPai	:=	(cAliasPai)->(Recno())
									If !TMP1->(Dbseek(nRegPai))
										Reclock("TMP1", .T.)
										TMP1->NROREG 		:= nRegPai
										TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
										TMP1->(MSUNLOCK())
									Endif

									If !Empty(SRL->RL_PAIS)
										SR4->R4_DTPGT := cDtPgt
									EndIf
									Fa401AddLog(	@aLog, lGerLog, SR4->R4_CPFCGC, SR4->R4_CODRET, SR4->R4_MES, SR4->R4_TIPOREN, (cAliasTRB)->E2_FILIAL, (cAliasTRB)->E2_PREFIXO,;
													(cAliasTRB)->E2_NUM, (cAliasTRB)->E2_PARCELA, (cAliasTRB)->E2_TIPO, (cAliasTRB)->E2_NATUREZ, (cAliasTRB)->E2_VALOR, cNIFEX, SA2->A2_COD,;
														SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
								Endif
							Endif
						EndIf

					Else // Eh um titulo de INSS
						If (cAliasTrb)->E2_VALOR  > 0 .And. MV_PAR04 ==1 // Somente se for pessoa fisica (MV_PAR04 = 1)
							If !SR4->(MsSeek(cChaveSr4+padr("B",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))
								Reclock("SR4", .T.)
								SR4->R4_FILIAL  := xFilial("SR4")
								SR4->R4_MAT     := SRL->RL_MAT
								SR4->R4_CPFCGC  := aTitulo[CNPJ]
								SR4->R4_MES     := aTitulo[MES]
								SR4->R4_TIPOREN := "B"
								SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
								SR4->R4_ANO  := aTitulo[ANO]
								SR4->R4_ORIGEM := "2"
								SR4->R4_NIFEX := SRL->RL_NIFEX
								If  !Empty(SRL->RL_PAIS)
									SR4->R4_PAIS := SRL->RL_PAIS
									
									SR4->R4_DTPGT := cDtPgt
									If lISNIF
										SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
									EndIf
								EndIf
							Else
								Reclock("SR4", .F.)
							Endif

							If  !Empty(SRL->RL_PAIS)
								SR4->R4_DTPGT := cDtPgt
							EndIf
							SR4->R4_VALOR   += (cAliasTrb)->E2_VALOR
							nRegPai	:=	(cAliasPai)->(Recno())
							If !TMP1->(Dbseek(nRegPai))
								Reclock("TMP1", .T.)
								TMP1->NROREG 		:= nRegPai
								TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
								TMP1->(MSUNLOCK())
							Endif

							Fa401AddLog(	@aLog, lGerLog, SR4->R4_CPFCGC, SR4->R4_CODRET, SR4->R4_MES, SR4->R4_TIPOREN, (cAliasTRB)->E2_FILIAL, (cAliasTRB)->E2_PREFIXO,;
											(cAliasTRB)->E2_NUM, (cAliasTRB)->E2_PARCELA, (cAliasTRB)->E2_TIPO, (cAliasTRB)->E2_NATUREZ, (cAliasTRB)->E2_VALOR, cNIFEX, SA2->A2_COD, ;
												SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

						Endif
					EndIf

					If lFa401Cmp
						// Utilizado para gravar campos complementares do SR4
						ExecBlock("FA401CMP", .F.,.F.)
					Endif
					
					If lFa401Grv
						// Utilizado para gravar campos complementares do SR4, referente ao tipo de rendimento "D"
						ExecBlock("FA401GRV" ,.F.,.F.,{cAliasPai, cAliasTRB})
					Endif

					SR4->(MsUnlock())

					// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
					cChaveSr4 := xFilial("SR4")+SRL->RL_MAT+ Padr(aTitulo[CNPJ],Len(SR4->R4_CPFCGC)) + aTitulo[CODIGORETENCAO] + aTitulo[ANO] + aTitulo[MES]

					nRendTributavel := 0
					nNaoTributavel  := 0

					// Tipo do rendimento considera tipo da entidade
					If lTpEnt
						If Empty((cAliasTrb)->A2_TPENT)
							cTpRen := "A"
						Else
							If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
								cTpRen := "I2"
							ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
								cTpRen := "I3"
							EndIf
						EndIf
					Else
						cTpRen := "A"
					EndIf

					//Restauro a filial do sistema quando processar com filial centralizadora
					If !Empty(MV_PAR06)
						cFilAnt := cFilAtu
					Endif
					//lTitRet	:=	.F.
					// se nao é INSS, nem IR, entao é PCC - AQUI calcula o Rendimento Tributável do PCC
						// Se utilizar codigo único de retenção  - (Empresa Pública - exemplo: Dataprev) e o título tiver IR
						// nao calcular o Rendimento Tributável pois já será calculado no IR
						// dessa forma o valor do rendimento nao ficará em dobro
					If !(cAliasTrb)->E2_TIPO $ MVINSS+"|"+"INA" .And.	!(AllTrim((cAliasTrb)->E2_NATUREZ ) $ cMVIRNAT) .and.;
						( (cAliasPai)->E2_IRRF == 0 .or. ((cAliasPai)->E2_IRRF > 0 .and. !f401CodUn(cAliasTrb,cAliasPai,aCRIN480)))

						If AllTrim((cAliasTrb)->E2_SEQBX) == "" .and. ;    //isso significa que o PCC nao foi gerado na baixa e sim na emissão do título
							SFQ->(MsSeek(xFilial("SFQ")+"SE2"+(cAliasPai)->E2_PREFIXO+(cAliasPai)->E2_NUM+(cAliasPai)->E2_PARCELA+(cAliasPai)->E2_TIPO+(cAliasPai)->E2_FORNECE+(cAliasPai)->E2_LOJA)) .and.;
							Ascan(aTitPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) == 0

							nCalcRend  := ValRenPCC(cAliasPai, cAliasTrb)

							nRendTributavel += nCalcRend

								Fa401AddLog(	@aLog, lGerLog, aTitulo[CNPJ] , aTitulo[CODIGORETENCAO], cMes, cTpRen, (cAliasPai)->E2_FILIAL, (cAliasPai)->E2_PREFIXO,;
												(cAliasPai)->E2_NUM, (cAliasPai)->E2_PARCELA, (cAliasPai)->E2_TIPO, (cAliasPai)->E2_NATUREZ, nCalcRend,aTitulo[NIFEX], SA2->A2_COD,;
													SA2->A2_LOJA  , SA2->A2_FILIAL , SA2->A2_NOME )

							Aadd(aTitPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

							//ver se a baixa está no SFQ para varrer as baixas que compuseram a base desse imposto.
						ElseIf AllTrim((cAliasTrb)->E2_SEQBX) <> "" .and. ; //isso significa que o PCC FOI gerado na baixa
								Ascan(aBxPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+(cAliasTrb)->E2_SEQBX) == 0

							/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Posiciono na baixa que gerou o TX.³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
							SE5->(DbSetOrder(7))
							SE5->(DbSeek(xFilial("SE5")+(cAliasPai)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+(cAliasTrb)->E2_SEQBX))

							Do While !SE5->(Eof()) .AND. SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == ;
								(cAliasPai)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)

								//Posiciono no movimento de baixa do titulo pai, caso exista por exemplo um DC (desconto) com a mesma chave do titulo pai
								If AllTrim(SE5->E5_TIPODOC) $ "CP/BA/PA/VL"
									Exit
								Endif
								SE5->(dbSkip())
							EndDo

							/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Nao posso somar os impostos da emissão aqui, pois se o  ³
							//³mesmo título tiver várias baixas, vai somar os impostos ³
							//³da emissão varias vezes.                                ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
							//Somar os juros, multa, correcao e desconto para formar o valor total do titulo pai
							nCalcRend  := ValRenPCC(cAliasPai, cAliasTrb, @aUltPCC, SE5->E5_SEQ)

							nRendTributavel += nCalcRend

							nPosLog	:= AScan( aLog, {	|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] == ;
															Iif(!Empty(cNIFEX),cNIFEX,aTitulo[CNPJ]) + aTitulo[CODIGORETENCAO] + aTitulo[MES] + cTpRen +;
														(cAliasPai)->( E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_NATUREZ ) } )

							If nPosLog == 0
								Fa401AddLog( @aLog, lGerLog, aTitulo[CNPJ], aTitulo[CODIGORETENCAO], aTitulo[MES], cTpRen, (cAliasPai)->E2_FILIAL, (cAliasPai)->E2_PREFIXO,;
													(cAliasPai)->E2_NUM, (cAliasPai)->E2_PARCELA, (cAliasPai)->E2_TIPO, (cAliasPai)->E2_NATUREZ, nCalcRend,aTitulo[NIFEX] , SA2->A2_COD,;
													SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
								nPosLog	:= Len(aLog)
							Else
								Fa401EdtLog( @aLog, lGerLog, nPosLog, LOG_VALOR, nCalcRend, "+" )
							EndIf

							Aadd( aBxPai ,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+(cAliasTrb)->E2_SEQBX )

							/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Os impostos gerados na emissão serão somados          ³
							//³na ultima baixa.                                      ³
							//³Também os impostos que são deduzidos do valor da baixa³
							//³na gravação do SE5 serão somados na ultima baixa.     ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							If (cAliasPai)->E2_SALDO == 0 .and. lPa .and. ;
								(MV_PAR05 == 1 .and. Ascan(aUltPCC,Alltrim((cAliasTrb)->E2_CODRET) + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) == 0) .and.;
								IsTheLastPost((cAliasPai)->E2_PREFIXO,(cAliasPai)->E2_NUM,(cAliasPai)->E2_PARCELA,(cAliasPai)->E2_TIPO,(cAliasPai)->E2_FORNECE,(cAliasPai)->E2_LOJA)
									If __lPaBruto
										nCalcRend := (cAliasPai)->(E2_VALOR) + IIf(lInssPa,  (cAliasPai)->(E2_INSS), 0 )
									Else
										nCalcRend := (cAliasPai)->(E2_VALOR+E2_RETENC+E2_SEST+E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL)
										If __lPrImPA
											nCalcRend += (cAliasPai)->(E2_ISS+E2_INSS+E2_PRINSS+E2_PRISS)
										EndIf
									EndIf

									If 	nSomabxPa > 0
										nCalcRend -= nImpEmis
									EndIf

									nRendTributavel += nCalcRend

									nPosLog	:= AScan( aLog, {	|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] == ;
															Iif(!Empty(cNIFEX),cNIFEX,aTitulo[CNPJ]) + aTitulo[CODIGORETENCAO] + aTitulo[MES] + cTpRen +;
														(cAliasPai)->( E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_NATUREZ ) } )

									If nPosLog == 0
										Fa401AddLog( @aLog, lGerLog, aTitulo[CNPJ], aTitulo[CODIGORETENCAO], cMes, cTpRen, (cAliasPai)->E2_FILIAL, (cAliasPai)->E2_PREFIXO,;
														(cAliasPai)->E2_NUM, (cAliasPai)->E2_PARCELA, (cAliasPai)->E2_TIPO, (cAliasPai)->E2_NATUREZ, nCalcRend,aTitulo[NIFEX], SA2->A2_COD,;
														SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
									Else

										Fa401EdtLog( @aLog, lGerLog, nPosLog, LOG_VALOR, nCalcRend, "+" )
									EndIf
									Aadd(aUltPCC,Alltrim((cAliasTrb)->E2_CODRET) + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
							ElseIf (cAliasPai)->E2_SALDO == 0 .and. ;
									(MV_PAR05 == 2) .and. lPa .and. ; //se a dirf esta sendo processada pelo imposto  ////							   (MV_PAR01 == 1 .and. MV_PAR05 == 2) .and. ; //se a dirf esta sendo processada pela emissao X imposto
									aTitulo[MES] == STRZERO(Month(cDtPgt),2) .and.;
									IsTheLastPost((cAliasPai)->E2_PREFIXO,(cAliasPai)->E2_NUM,(cAliasPai)->E2_PARCELA,(cAliasPai)->E2_TIPO,(cAliasPai)->E2_FORNECE,(cAliasPai)->E2_LOJA).and.;
									Ascan(aUltPCC,Alltrim((cAliasTrb)->E2_CODRET) + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) == 0
									nPosLog	:= AScan( aLog, {	|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] == ;
															Iif(!Empty(cNIFEX),cNIFEX,aTitulo[CNPJ])+ aTitulo[CODIGORETENCAO] + aTitulo[MES] + cTpRen +;
														(cAliasPai)->( E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_NATUREZ ) } )

									If __lPaBruto
										nCalcRend := (cAliasPai)->(E2_VALOR) + IIf(lInssPa,  (cAliasPai)->(E2_INSS), 0 )
									Else
										nCalcRend := (cAliasPai)->(E2_VALOR+E2_RETENC+E2_SEST+E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL)
										If __lPrImPA
											nCalcRend += (cAliasPai)->(E2_ISS+E2_INSS+E2_PRINSS+E2_PRISS)
										EndIf
									EndIf

									If 	nSomabxPa > 0
										nCalcRend -= nImpEmis//aqui
									EndIf


									nRendTributavel += nCalcRend
									If nPosLog == 0
											Fa401AddLog( @aLog, lGerLog,aTitulo[CNPJ], aTitulo[CODIGORETENCAO], aTitulo[MES], cTpRen, (cAliasPai)->E2_FILIAL, (cAliasPai)->E2_PREFIXO,;
															(cAliasPai)->E2_NUM, (cAliasPai)->E2_PARCELA, (cAliasPai)->E2_TIPO, (cAliasPai)->E2_NATUREZ, nCalcRend,aTitulo[NIFEX], SA2->A2_COD, ;
															SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
									Else
										Fa401EdtLog( @aLog, lGerLog, nPosLog, LOG_VALOR, nCalcRend, "+" )
									EndIf
									Aadd(aUltPCC,Alltrim((cAliasTrb)->E2_CODRET) + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
							EndIf

							Aadd( aTitPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) )

						Else
							If Ascan(aTitPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) == 0

								If lPa
									If __lPaBruto
										nCalcRend := (cAliasPai)->(E2_VALOR) + IIf(lInssPa,  (cAliasPai)->(E2_INSS), 0 )
									Else
										nCalcRend := (cAliasPai)->(E2_VALOR+E2_RETENC+E2_SEST+E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL)
										If __lPrImPA
											nCalcRend += (cAliasPai)->(E2_ISS+E2_INSS+E2_PRINSS+E2_PRISS)
										EndIf
									EndIf
								Else
									nCalcRend := ValRenPCC(cAliasPai, cAliasTrb)
								EndIf

								nRendTributavel += nCalcRend

								Fa401AddLog(	@aLog, lGerLog, aTitulo[CNPJ], aTitulo[CODIGORETENCAO], aTitulo[MES], cTpRen, (cAliasPai)->E2_FILIAL, (cAliasPai)->E2_PREFIXO,;
												(cAliasPai)->E2_NUM, (cAliasPai)->E2_PARCELA, (cAliasPai)->E2_TIPO, (cAliasPai)->E2_NATUREZ, nCalcRend,aTitulo[NIFEX], SA2->A2_COD,;
													SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

								// Somo o valor do rendimento tributavel, apenas uma vez, pois o titulo pode ser pai de varios impostos
								Aadd(aTitPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
							Endif
						EndIf

					//processa 'IRRF' ou 'INSS sem a presenca de IRRF no titulo'
					Elseif !(cAliasTrb)->E2_TIPO $ MVINSS .Or. ((cAliasTrb)->E2_TIPO $ MVINSS .And. Empty((cAliasPai)->E2_IRRF))

						// Apuro o valor do rendimento tributavel para IRRF PJ e PF, pois o valor do tributo
						// pode fazer referencia a soma de outros titulos.
							dDtIni := FirstDay(MV_PAR02)
							cMes := F401CMES(dDtIni,LastDay(dDtIni),cMes,aTitulo[CODIGORETENCAO], lReproc, cFilAtu )
							cMesAnt := ""

						While dDtIni <= MV_PAR03
							bAscan := { || If( SA2->A2_TIPO == "F" .or. SA2->A2_IRPROG == '1' ,;
								Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO]+cNIFEX) == 0,;
								Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+aTitulo[CODIGORETENCAO]+cNIFEX) == 0) }

							If Eval(bAscan) // Se ainda nao apurou o rendimento para este fornecedor no periodo

								// Tipo do rendimento considera tipo da entidade
								If lTpEnt
									If Empty((cAliasTrb)->A2_TPENT)
										cTpRen := "A"
									Else
										If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
											cTpRen := "I2"
										ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
											cTpRen := "I3"
										EndIf
									EndIf
								Else
									cTpRen := "A"
								EndIf

								//Restauro a filial do sistema para a centralizadora
								If !Empty(MV_PAR06)
									SM0->(MsSeek(cEmpAnt+MV_PAR06))
									cFilAnt := MV_PAR06
								Endif

								// Se existir o ano na chave do SR4
								// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
								cChaveSr4 := xFilial("SR4")+SRL->RL_MAT+ Padr(aTitulo[CNPJ],Len(SR4->R4_CPFCGC)) +aTitulo[CODIGORETENCAO]+STRZERO(YEAR(dDtIni),4)+cMes

								// Gera valor do Rendimento do IR
								If !SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))

									If cMesAnt <> cMes
										nRendTributavel := 0
										nNaoTributavel  := 0
										nDedSimp		:= 0
										nTotInsD		:= 0
										aRetBaseIR := F401BaseIr(	dDtIni,LastDay(dDtIni),@nNaoTributavel,cAliasTrb,@nDedDep,cFilAtu,aTitulo[CODIGORETENCAO],;
																	@cTitsSum,lReproc,@aLog,aTitulo[CNPJ],cMes,lGerLog,aSelfil, cArqTMP1,lForExt,cNIFEX, lTemNIF, aCPFs[nK][2],@cDtPgt,aCPFs[nK][6],(cAliasPai)->(Recno()), @nTotInsD )
									EndIf
                                    If ValType(aRetBaseIR) == "A"
                                        If ( SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1'))
                                            aEval(aRetBaseIR, {|x| nRendTributavel += x[2]})
                                            aEval(aRetBaseIR, {|x| nNaoTributavel += x[3]})
											nDedSimp := DedIrSimp(cMes, cAno, nRendTributavel, nTotInsD+nDedDep+nNaoTributavel)
                                        Else
                                            aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nRendTributavel += x[2],0)})
                                            aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nNaoTributavel  += x[3],0)})
                                        EndIf
                                    EndIf
									If !(MV_PAR01 == 2  .and. MV_PAR05 == 2) .AND. !(MV_PAR01 == 4  .and. MV_PAR05 == 2)  // Vencimento e tit de imposto e baixa e tit de imposto
										If nRendTributavel > 0
											Reclock("SR4", .T.)

											SR4->R4_FILIAL  := xFilial("SR4")
											SR4->R4_MAT     := SRL->RL_MAT
											SR4->R4_CPFCGC  := aTitulo[CNPJ]
											SR4->R4_MES     := cMes
											SR4->R4_TIPOREN := cTpRen
											SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
											SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
											SR4->R4_VALOR   := nRendTributavel

											nRegPai	:=	(cAliasPai)->(Recno())
											If !TMP1->(Dbseek(nRegPai))
												Reclock("TMP1", .T.)
												TMP1->NROREG 		:= nRegPai
												TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
												TMP1->(MSUNLOCK())
											Endif

											SR4->R4_ORIGEM := "2"
											SR4->R4_NIFEX := SRL->RL_NIFEX
											If  !Empty(SRL->RL_PAIS)
												SR4->R4_PAIS := SRL->RL_PAIS
												
												SR4->R4_DTPGT := cDtPgt
												If lISNIF
													SR4->R4_ISNIF := IIF(lTemNIF,"1","2")
												EndIf
											EndIf

											If lFa401Cmp
												// Utilizado para gravar campos complementares do SR4
												ExecBlock("FA401CMP", .F.,.F.)
											Endif

											If lFa401Grv
												// Utilizado para gravar campos complementares do SR4, referente ao tipo de rendimento "A"
												ExecBlock("FA401GRV" ,.F.,.F.,{cAliasPai, cAliasTRB})
											Endif

											SR4->(MsUnlock())


											If SA2->A2_TIPO == "F" .or. SA2->A2_IRPROG == '1'
													If Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO] + cNIFEX) == 0
														Aadd(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO] + cNIFEX )
												Endif
											Else
													If Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1] +DTOS(dDtIni)+aTitulo[CODIGORETENCAO]+cNIFEX) == 0
														Aadd(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1] +DTOS(dDtIni)+aTitulo[CODIGORETENCAO]+cNIFEX)
												Endif
											Endif

										Endif
									EndIf

									If nNaoTributavel > 0
										If !SR4->(MsSeek(cChaveSr4+padr("I",nTamTpRen)+SRL->RL_PAIS + SRL->RL_NIFEX ))

											Reclock("SR4", .T.)

											SR4->R4_FILIAL  := xFilial("SR4")
											SR4->R4_MAT     := SRL->RL_MAT
											SR4->R4_CPFCGC  := aTitulo[CNPJ]
											SR4->R4_MES     := STRZERO(MONTH(dDtIni),2)
											SR4->R4_TIPOREN := "I"
											SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
											SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
											SR4->R4_VALOR   := nNaoTributavel

											SR4->R4_ORIGEM := "2"
											SR4->R4_NIFEX := SRL->RL_NIFEX
											If !Empty(SRL->RL_PAIS)
												SR4->R4_PAIS := SRL->RL_PAIS
												
												SR4->R4_DTPGT := dDtIni
												If lISNIF
													SR4->R4_ISNIF := IIF(lTemNIF,"1","2")
												EndIf

											EndIf

											If lFa401Cmp
												// Utilizado para gravar campos complementares do SR4
												ExecBlock("FA401CMP", .F.,.F.)
											Endif

											SR4->(MsUnlock())

											//-- Função para gravar tabela RCS
											FinGrvRCS(cTipoFJ,aTitulo,nNaoTributavel,cAliasTrb)

										Endif
									Endif
									If nDedSimp > 0
										If !SR4->(MsSeek(cChaveSr4+padr("B4",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))

											Reclock("SR4", .T.)

											SR4->R4_FILIAL  := xFilial("SR4")
											SR4->R4_MAT     := SRL->RL_MAT
											SR4->R4_CPFCGC  := aTitulo[CNPJ]
											SR4->R4_MES     := STRZERO(MONTH(dDtIni),2)
											SR4->R4_TIPOREN := "B4"
											SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
											SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
											SR4->R4_VALOR   := nDedSimp
											SR4->R4_ORIGEM := "2"
											SR4->R4_NIFEX := SRL->RL_NIFEX

											If lFa401Cmp
												// Utilizado para gravar campos complementares do SR4
												ExecBlock("FA401CMP", .F.,.F.)
											Endif

											SR4->(MsUnlock())

											Fa401AddLog(	@aLog, lGerLog, SR4->R4_CPFCGC, SR4->R4_CODRET, SR4->R4_MES, SR4->R4_TIPOREN, (cAliasTRB)->E2_FILIAL, "",;
															"", "", "", "", nDedSimp,SR4->R4_NIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

											nDedSimp := 0
										Endif

									EndIf
									If nDedDep > 0
										If !SR4->(MsSeek(cChaveSr4+padr("T",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))

											Reclock("SR4", .T.)

											SR4->R4_FILIAL  := xFilial("SR4")
											SR4->R4_MAT     := SRL->RL_MAT
											SR4->R4_CPFCGC  := aTitulo[CNPJ]
											SR4->R4_MES     := STRZERO(MONTH(dDtIni),2)
											SR4->R4_TIPOREN := "T"
											SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
											SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
											SR4->R4_VALOR   := nDedDep
											SR4->R4_ORIGEM := "2"
											SR4->R4_NIFEX := SRL->RL_NIFEX

											If !Empty(SRL->RL_PAIS)
												SR4->R4_PAIS := SRL->RL_PAIS
												SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
												If lISNIF
													SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
												EndIf
											EndIf

											If lFa401Cmp
												// Utilizado para gravar campos complementares do SR4
												ExecBlock("FA401CMP", .F.,.F.)
											Endif

											SR4->(MsUnlock())

											Fa401AddLog(	@aLog, lGerLog, SR4->R4_CPFCGC, SR4->R4_CODRET, SR4->R4_MES, SR4->R4_TIPOREN, (cAliasTRB)->E2_FILIAL, "",;
															"", "", "", "", nDedDep,SR4->R4_NIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
										Endif
									Endif
									// depende de retornar corretamente os titulos do dia que serao considerados
									While Len(cTitsSum) > 0
										//Restura a filial para a original para o uso do DbSeek
										If !Empty(MV_PAR06)
											cFilAnt := cFilAtu
										Endif
										SE2->(DbSeek(xFilial("SE2")+SubStr(cTitsSum,1,AT("|",cTitsSum)-(Len((cAliasTrb)->E2_CODRET)+1)))) //			cTitsSum += TRBIRF->( E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA ) + cCodRet + "|"
										//Restauro a filial do sistema para a centralizadora
										If !Empty(MV_PAR06)
											cFilAnt := MV_PAR06
										Endif

										Aadd(aRecno, SE2->(Recno()))

										cTitsSum := SubStr(cTitsSum,AT("|",cTitsSum)+1,Len(cTitsSum))
									EndDo
								Else// se nao é PF e não é PJ com IR Progressivo
									If ( SA2->A2_TIPO != "F" .and. !SA2->A2_IRPROG == '1' ) .Or. MV_PAR08 == 1

										If cMesAnt <> cMes
											nRendTributavel := 0
											nNaoTributavel  := 0
											nDedSimp		:= 0
											nTotInsD		:= 0
											nBaseTrb		:= 0
											aRetBaseIR := F401BaseIr(	dDtIni,LastDay(dDtIni),@nNaoTributavel,cAliasTrb,@nDedDep,cFilAtu,aTitulo[CODIGORETENCAO],;
																				@cTitsSum,lReproc,@aLog,aTitulo[CNPJ],cMes,lGerLog,aSelFil,cArqTMP1,lForExt, cNIFEX,lTemNIF,aCPFs[nK][2],@cDtPgt,aCPFs[nK][6],(cAliasPai)->(Recno()) )
										EndIf

                                        If ValType(aRetBaseIR) == "A"
                                            If ( SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1'))
                                                aEval(aRetBaseIR, {|x| nRendTributavel += x[2]})
                                                aEval(aRetBaseIR, {|x| nNaoTributavel += x[3]})
                                            Else
                                                aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nRendTributavel += x[2],0)})
                                                aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nNaoTributavel  += x[3],0)})
                                            EndIf
                                        EndIf

										If !(MV_PAR01 == 4  .and. MV_PAR05 == 2)
											If nRendTributavel > 0
												Reclock("SR4", .F.)
												SR4->R4_VALOR   += nRendTributavel

												nRegPai	:=	(cAliasPai)->(Recno())
												If !TMP1->(Dbseek(nRegPai))
													Reclock("TMP1", .T.)
													TMP1->NROREG 		:= nRegPai
													TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
													TMP1->(MSUNLOCK())
												Endif
												nBaseTrb := SR4->R4_VALOR
												SR4->(MsUnlock())
											Endif
										EndIf

										If nNaoTributavel > 0

											If !SR4->(MsSeek(cChaveSr4+padr(cTpRen,nTamTpRen)+ SRL->RL_PAIS + SRL->RL_NIFEX))

												Reclock("SR4", .T.)

												SR4->R4_FILIAL  := xFilial("SR4")
												SR4->R4_MAT     := SRL->RL_MAT
												SR4->R4_CPFCGC  := aTitulo[CNPJ]
												SR4->R4_MES     := STRZERO(MONTH(dDtIni),2)
												SR4->R4_TIPOREN := cTpRen
												SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
												SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
												SR4->R4_ORIGEM := "2"
												SR4->R4_NIFEX := SRL->RL_NIFEX

												If  !Empty(SRL->RL_PAIS)
													SR4->R4_PAIS := SRL->RL_PAIS												
													SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
													If lISNIF
														SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
													EndIf

												EndIf

											Else
												Reclock("SR4", .F.)
											Endif

											SR4->R4_VALOR   += nNaoTributavel
											If lFa401Cmp
												// Utilizado para gravar campos complementares do SR4
												ExecBlock("FA401CMP", .F.,.F.)
											Endif

											SR4->(MsUnlock())
											//-- Função para gravar tabela RCS
											FinGrvRCS(cTipoFJ,aTitulo,nNaoTributavel,cAliasTrb)
										Endif
										If !lReproc .And. (SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1'))
											If SR4->(MsSeek(cChaveSr4+padr("B",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))
												nTotInsD := SR4->R4_VALOR
											EndIf
											nDedSimp := DedIrSimp(cMes, cAno, nBaseTrb, nTotInsD+nDedDep)
											If  nDedSimp == 0 .And. SR4->(MsSeek(cChaveSr4+padr("B4",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))
												Reclock("SR4", .F.)
													SR4->(DbDelete())
												SR4->(MsUnlock())
											EndIf
										EndIf
									Else
										//certeza que ainda nao somou para esse fornecedor+mes+codret
										If !lReproc .and. Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aTitulo[CNPJ]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO] + cNIFEX ) == 0//Ascan(aFornec, aTitulo[1]) == 0
                                            If cMesAnt <> SR4->R4_MES
                                                nRendTributavel := 0
                                                nNaoTributavel  := 0
												nDedSimp		:= 0
												nTotInsD		:= 0
												nBaseTrb		:= 0
                                                aRetBaseIR := F401BaseIr(	dDtIni,LastDay(dDtIni),@nNaoTributavel,cAliasTrb,@nDedDep,cFilAtu,aTitulo[CODIGORETENCAO],;
                                                                         @cTitsSum,lReproc,@aLog,aTitulo[CNPJ],SR4->R4_MES,lGerLog,aSelfil,cArqTMP1,lForExt,cNIFEX,lTemNIF,aCPFs[nK][2],@cDtPgt,aCPFs[nK][6],(cAliasPai)->(Recno()))
                                            EndIf

                                            If ValType(aRetBaseIR) == "A"
                                                If ( SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1'))
                                                    aEval(aRetBaseIR, {|x| nRendTributavel += x[2]})
                                                    aEval(aRetBaseIR, {|x| nNaoTributavel += x[3]})
                                                Else
                                                    aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nRendTributavel += x[2],0)})
                                                    aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nNaoTributavel  += x[3],0)})
                                                EndIf
                                            EndIf

                                            If nRendTributavel > 0
                                                Reclock("SR4", .F.)
                                                SR4->R4_VALOR  += nRendTributavel
                                                SR4->(MsUnlock())

												nBaseTrb := SR4->R4_VALOR

                                                nRegPai	:=	(cAliasPai)->(Recno())
                                                If !TMP1->(Dbseek(nRegPai))
                                                    Reclock("TMP1", .T.)
                                                    TMP1->NROREG 		:= nRegPai
                                                    TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
                                                    TMP1->(MSUNLOCK())
                                                Endif

                                            EndIf
                                            If nNaoTributavel > 0
                                                // Tipo do rendimento considera tipo da entidade
                                                If lTpEnt
                                                    If Empty((cAliasTrb)->A2_TPENT)
                                                        cTpRen := "I"
                                                    Else
                                                        If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
                                                            cTpRen := "I2"
                                                        ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
                                                            cTpRen := "I3"
                                                        EndIf
                                                    EndIf
                                                Else
                                                    cTpRen := "I"
                                                EndIf
                                                If !SR4->(MsSeek(cChaveSr4+padr(cTpRen,nTamTpRen)+ SRL->RL_PAIS + SRL->RL_NIFEX ))

                                                    Reclock("SR4", .T.)

                                                    SR4->R4_FILIAL  := xFilial("SR4")
                                                    SR4->R4_MAT     := SRL->RL_MAT
                                                    SR4->R4_CPFCGC  := aTitulo[CNPJ]
                                                    SR4->R4_MES     := STRZERO(MONTH(dDtIni),2)
                                                    SR4->R4_TIPOREN := cTpRen
                                                    SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
                                                    SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
                                                    SR4->R4_ORIGEM := "2"
                                                    SR4->R4_NIFEX := SRL->RL_NIFEX

                                                    If !Empty(SRL->RL_PAIS)
                                                        SR4->R4_PAIS := SRL->RL_PAIS														
                                                        SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
                                                        If lISNIF
                                                            SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
                                                        EndIf
                                                    EndIf

                                                Else
                                                    Reclock("SR4", .F.)
                                                Endif

                                                SR4->R4_VALOR   += nNaoTributavel
                                                If lFa401Cmp
                                                    // Utilizado para gravar campos complementares do SR4
                                                    ExecBlock("FA401CMP", .F.,.F.)
                                                Endif

                                                SR4->(MsUnlock())
                                            Endif
											If (SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1'))
												If SR4->(MsSeek(cChaveSr4+padr("B",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))
													nTotInsD := SR4->R4_VALOR
												EndIf
												nDedSimp := DedIrSimp(cMes, cAno, nBaseTrb, nTotInsD+nDedDep)
												If  nDedSimp == 0 .And. SR4->(MsSeek(cChaveSr4+padr("B4",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))
													Reclock("SR4", .F.)
														SR4->(DbDelete())
													SR4->(MsUnlock())
												EndIf
											EndIf
										EndIf
									Endif
								Endif

								//Restauro a filial do sistema quando processar com filial centralizadora
								If !Empty(MV_PAR06)
									cFilAnt := cFilAtu
								Endif
								If SA2->A2_TIPO == "F" .or. SA2->A2_IRPROG == '1'
										If Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO] + cNIFEX ) == 0 .And.;
										(aTitulo[MES] == STRZERO(MONTH(dDtIni),2))
											Aadd(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO]+ cNIFEX )
									Endif

									cMesAnt:= STRZERO(MONTH(dDtini),2)
									dDtIni += 40
									dDtIni := FirstDay(dDtIni)
									cMes := F401CMES(dDtIni,LastDay(dDtIni),cMes,aTitulo[CODIGORETENCAO],lReproc, cFilAtu )
								Else
										If Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1] +DTOS(dDtIni)+aTitulo[CODIGORETENCAO] + cNIFEX ) == 0
											Aadd(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1] +DTOS(dDtIni)+aTitulo[CODIGORETENCAO]+ cNIFEX)
									Endif

									cMesAnt:= STRZERO(MONTH(dDtini),2)
									dDtIni++
									cMes:=F401CMES(dDtIni,LastDay(dDtIni),cMes,aTitulo[CODIGORETENCAO],lReproc, cFilAtu )
								Endif

							Else
								cMesAnt:= STRZERO(MONTH(dDtini),2)
								dDtIni := FirstDay(MsSomaMes(dDtIni, 1, .F.))

								If SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))
									If !Empty(SRL->RL_PAIS)
										Reclock("SR4", .F.)
										SR4->R4_DTPGT := cDtPgt
										SR4->(MsUnlock())

									EndIf
								EndIf

							Endif
							nRendTributavel := 0
							nNaoTributavel	 := 0
						EndDo

					Endif

					If nRendTributavel > 0
						//Restauro a filial do sistema para a centralizadora
						If !Empty(MV_PAR06)
							cFilAnt := MV_PAR06
						Endif

						// Tipo do rendimento considera tipo da entidade
						If lTpEnt
							If Empty((cAliasTrb)->A2_TPENT)
								cTpRen := "A"
							Else
								If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
									cTpRen := "I2"
								ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
									cTpRen := "I3"
								EndIf
							EndIf
						Else
							cTpRen := "A"
						EndIf

						// Gera valor do Rendimento do IR
						If !SR4->(MsSeek(cChaveSr4+padr(cTpRen,nTamTpRen)+ SRL->RL_PAIS + SRL->RL_NIFEX))

							Reclock("SR4", .T.)

							SR4->R4_FILIAL  := xFilial("SR4")
							SR4->R4_MAT     := SRL->RL_MAT
							SR4->R4_CPFCGC  := aTitulo[CNPJ]
							SR4->R4_MES     := aTitulo[MES]
							SR4->R4_TIPOREN := cTpRen
							SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
							SR4->R4_ANO  := aTitulo[ANO]
							SR4->R4_ORIGEM := "2"
							SR4->R4_NIFEX := SRL->RL_NIFEX

							If  !Empty(SRL->RL_PAIS)
									SR4->R4_PAIS := SRL->RL_PAIS
									
									SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
									If lISNIF
										SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
									EndIf
							EndIf

							If lFa401Cmp
								// Utilizado para gravar campos complementares do SR4
								ExecBlock("FA401CMP", .F.,.F.)
							Endif

							SR4->R4_VALOR += nRendTributavel

						Else
							If lF401VldPai

								lVldPai:= ExecBlock("F401VldPai",.F.,.F.,{(cAliasTrb)->RECNOPAI})

								If lVldPai

									nRegPai	:=	(cAliasPai)->(Recno())
									If !TMP1->(Dbseek(nRegPai))
										Reclock("SR4", .F.)
										SR4->R4_VALOR += nRendTributavel
									Endif

								Else
									Reclock("SR4", .F.)
									SR4->R4_VALOR += nRendTributavel
								EndIf
							Else
								Reclock("SR4", .F.)
								SR4->R4_VALOR += nRendTributavel
							EndIf
						Endif

						nRegPai	:=	(cAliasPai)->(Recno())
						If !TMP1->(Dbseek(nRegPai))
							Reclock("TMP1", .T.)
							TMP1->NROREG 		:= nRegPai
							TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
							TMP1->(MSUNLOCK())
						Endif

						SR4->(MsUnlock())

					Endif

					//Restauro a filial do sistema quando processar com filial centralizadora
					If !Empty(MV_PAR06)
						cFilAnt := cFilAtu
					Endif

					ConfirmSx8()

					Aadd(aRecno, (cAliasTrb)->R_E_C_N_O_)

					If ValType(aRetBaseIR) == "A" 
						aSize(aRetBaseIR,0)
						aRetBaseIR := {}
					EndIf

				Next nK
			EndIf
		EndIf

		//RESTAURO PARA A FILIAL DO WHILE, FILIAL DE ENTRADA NO SISTEMA
		If !Empty(MV_PAR06)
			cFilAnt := cFilAtu
		Endif

		dbSelectArea(cAliasTrb)
		(cAliasTrb)->(dbSkip())
	Enddo

	(cAliasTrb)->(dbCloseArea())
	dbSelectArea("SE2")
	dbSetOrder(1)

	//Array com os titulos pais já processados
	Aadd( aTitJaProc , aTitPai )
	Aadd( aTitJaProc , aBxPai  )
	Aadd( aTitJaProc , aUltPCC )

	// Processa todos os forncedores que não
	// tiveram impostos no periodo
	// ou  titulos que possuem fatura com retencao de IRRF ou PCC na baixa.
	// Na gestão de filiais, a rotina será executada uma vez para cada filial selecionada
	If MV_PAR08 == 1 
		For nX := 1 To Len( aSelFil )
			cFilSE2 := xFilial("SE2",aSelFil[nX])
			If Ascan(aFilProc, cFilSE2 ) == 0 //Verifica se filial já foi processada
				Aadd(aFilProc, cFilSE2 )
				cFilAnt  := aSelFil[ nX ]
				cFilAtu  := aSelFil[ nX ]
				// Processa todos os titulos que possuirem retencao de IR ou PCC mas nao geraram titulos de impostos e nao estao retidos em outros titulos.
				// No final desta função já é feito a exclusao das datas da dirf no caso de reprocessamento para os titulos selecionados (igual Fa401UpDtDirf).
				Fa401SemRet(aRecno,lReproc,cFilAtu,@aLog,lGerLog,cArqTMP1)
				Fa401SemImp(aRecno,lReproc,cFilAtu,@aLog,lGerLog,aTitJaProc,cArqTMP1)
			Endif
		Next nX
		
		cFilAnt := cFilInic
	Else
		cFilAnt := cFilInic
		cFilAtu := cFilInic
		// Processa todos os titulos que possuirem retencao de IR ou PCC mas nao geraram titulos de impostos e nao estao retidos em outros titulos.
		// No final desta função já é feito a exclusao das datas da dirf no caso de reprocessamento para os titulos selecionados (igual Fa401UpDtDirf).
		Fa401SemRet(aRecno,lReproc,cFilAtu,@aLog,lGerLog,cArqTMP1)
		Fa401SemImp(aRecno,lReproc,cFilAtu,@aLog,lGerLog,aTitJaProc,cArqTMP1)
	EndIf

	// Atualiza o flag de geracao da DIRF.
	For nX := 1  To Len(aRecno)
		cRecno := ""

		// Monta a string limitando a 500 registros por vez
		For nY := nX To (499+nX)
			If nY > Len(aRecno)
				Exit
			Endif
			cRecno += Alltrim(Str(aRecno[nY],20))+","
		Next

		// Atualiza o flag de geracao da DIRF para nao gerar novamente em novo processamento.
		cQuery := "UPDATE "
		cQuery += RetSqlName("SE2")+" "
		cQuery += "SET E2_DTDIRF = '" + Dtos(dDataBase) + "'"
		cQuery += " WHERE R_E_C_N_O_ IN ("+SubStr(cRecno,1,rat(",",cRecno)-1)+") AND "
		cQuery += "D_E_L_E_T_ = ' ' "

		TcSqlExec(cQuery)

		nX := nY
	Next

	//Gera o repasse do IR
	If lFina405 .and. MV_PAR04 == 2 // PJ
		cFilCen := If(Empty(MV_PAR06), cFilCen, MV_PAR06)
		aRecnoFon := Fa405DIRF("FINA401", @aLog, lGerLog, cFilCen, MV_PAR02, MV_PAR03, aSelFil )
	EndIf

	If lErroUpd .or. !lQuery
		Fa401UpDtDirf(lPlsAtiv,lReproc,cPccTit,cCampo,cCampoP,cChave,ni,nTotREG,cIndex)
	EndIf
	NEWSE2->(dbCloseArea())

	WrDtDirf(aRecno, cIndex)

	// Zera o valor do rendimento de fornecedores que nao reteram IR, mas reteram INSS
	// e o valor do rendimento ficou inferior a 6000.
	// Alteração feita conforme resposta da nossa consultoria tributária.
	// Caso haja necessidade de desfazer esse procedimento, basta desviar essa chamada ou excluí-la.
	// Também zera o proprio INSS conforme nossa consulta jurídica - JIRA - 02/fev/10

	//NAO DEVE ZERAR OS VALORES, ESTES DEVEM IR PARA SR4 ONDE O RH IRÁ FILTRAR PARA A DIRF
	//Fa401ZRINSS(@aLog)

	If lF401dcmp
		// Utilizado para gravar DADOS COMPLEMENTARES
		ExecBlock("F401DCMP", .F.,.F.)
	Endif


	If !Empty(aEmptyCPF) .and. !lAutomato
		ForSemCPF()
	EndIf


	If lGerLog
		If Len(aLog) > 0
			// Grava arquivo de LOG em formato .CSV
			cArqLog := Fa401GerLog( aLog )
			// Deseja visualizar relatorio de log com os titulos processados? ### Atencao
			If MsgYesNo( STR0030, STR0031 )
				Fa401ImpLog( aLog, cArqLog )
			EndIf
		Endif

		If Len(aRecnoFon) > 0 .AND. lFina405
			If MsgYesNo( STR0043, STR0031 )  //"Deseja visualizar o relatório de log com os repasses de IR processados?"
				FINR405(aRecnoFon)
			EndIf
		EndIF
	EndIf

	If Select("__NEWSE2") > 0
		__NEWSE2->(DbCloseArea())
	Endif

	//Restauro a filial do sistema quando processar com filial centralizadora
	If !Empty(MV_PAR06)
		cFilAnt := cFilInic
	Endif

	RestArea(aArea)
	TMP1->(DbCloseArea())

	FWFReeArray(aFilProc)

	//Deleta tabela temporária no banco de dados, caso exista
	If _oFINA4011 <> Nil
		_oFINA4011:Delete()
		_oFINA4011 := Nil
	Endif

Return


//***************
// Soma um no ultimo byte de uma string, normalmente
// para ser utilizado em pesquisas com softseek on, para posicionar no
// ultimo registro + 1, de uma chave. Ex.:
// cChave := "CLAUDIO"
// DbSeek(IncLast(cChave)),.T.) // DbSeek("CLAUDIP")
// Se na base tiver:
// CLAUDIO <-- Ponteiro atual    (1)
// CLAUDIO
// CLAUDIO
// CLAUDIO
// DANIELA <-- Apos o DbSeek     (2)
STATIC FUNCTION IncLast( cString )
Return Left(cString, Len(cString)-1)+;
       CHR(ASC(RIGHT(cString,1))+1)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fa401Pai  ºAutor  ³Microsiga           º Data ³  02/19/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
STATIC FUNCTION Fa401Pai(cAliasTrb)
Local nRegSE2	:= NEWSE2->(Recno())
Local lAchou	:= .F.
Local cPrefixo 	:= (cAliasTrb)->E2_PREFIXO
Local cNum		:= (cAliasTrb)->E2_NUM
Local cParcela 	:= (cAliasTrb)->E2_PARCELA
Local cTipoPai 	:= (cAliasTrb)->E2_TIPO
Local cParcPai 	:= ""
Local aArea 	:= GetArea()
Local lPai 		:= .F.
Local lPis		:= .F.
Local lCofins	:= .F.
Local lCsll		:= .F.
Local cTitPai	:= (cAliasTrb)->E2_TITPAI
Local lNatPCC	:= 	AllTrim(GetMv("MV_PISNAT")) == AllTrim(GetMv("MV_COFINS")) .And.;	//Verifica se a natureza é a
					AllTrim(GetMv("MV_COFINS")) == AllTrim(GetMv("MV_CSLL"))				//mesma para o Pis, Cofins e Csll.

If lNatPCC //Quando utilizar a mesma natureza nos títulos de PCC.

	//Como os títulos de impostos possuem o mesmo nome, é necessário encontrar o título principal mesmo não
	//existindo uma chave completa de pesquisa.
	dbSelectArea( "NEWSE2" )
	dbSetOrder(1)

	If MsSeek( xFilial("SE2") + cPrefixo + cNum )

		While !Eof() .And. NEWSE2->( E2_FILIAL + E2_PREFIXO + E2_NUM ) == xFilial("SE2") + cPrefixo + cNum

			If NEWSE2->E2_PARCPIS == cParcela
				If NEWSE2->E2_PIS == (cAliasTrb)->E2_VALOR
					lPis := .T.
					Exit
				EndIf

			ElseIf NEWSE2->E2_PARCCOF == cParcela
				If NEWSE2->E2_COFINS == (cAliasTrb)->E2_VALOR
					lCofins := .T.
					Exit
				EndIf

			ElseIf NEWSE2->E2_PARCSLL == cParcela
				If NEWSE2->E2_CSLL == (cAliasTrb)->E2_VALOR
					lCsll := .T.
					Exit
				EndIf

			EndIf

			NEWSE2->(DbSkip())
		Enddo
	EndIf

	If (cAliasTrb)->E2_TIPO $ MVTAXA + "/" + MVTXA .Or. (cAliasTrb)->E2_TIPO $ MVINSS+"|"+"INA"

		If (cAliasTrb)->E2_FORNECE == GetMv("MV_MUNIC")
			cValorPai := "NEWSE2->E2_ISS"
			cParcPai  := "E2_PARCISS"

		Else
			Do Case
			Case lPis
				cValorPai := "NEWSE2->E2_PIS"
				cParcPai  := "E2_PARCPIS"

			Case lCofins
				cValorPai := "NEWSE2->E2_COFINS"
				cParcPai  := "E2_PARCCOF"

			Case lCsll
				cValorPai := "NEWSE2->E2_CSLL"
				cParcPai  := "E2_PARCSLL"

			Case Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVINSNAT
				cValorPai := "NEWSE2->E2_INSS"
				cParcPai  := "E2_PARCINS"

			OtherWise
				cValorPai := "NEWSE2->E2_IRRF"
				cParcPai  := "E2_PARCIR"
			EndCase
		Endif
	Else
		lPai := .T.
	Endif

Else
	If (cAliasTrb)->E2_TIPO $ MVTAXA + "/" + MVTXA .Or. (cAliasTrb)->E2_TIPO $ MVINSS+"|"+"INA"

	 	If AllTrim((cAliasTrb)->E2_TITPAI) <> ""
			cTitPai	:= (cAliasTrb)->E2_TITPAI
		EndIf

		If (cAliasTrb)->E2_FORNECE == GetMv("MV_MUNIC")
			cValorPai := "NEWSE2->E2_ISS"
			cParcPai := "E2_PARCISS"
		Else
			Do Case
			Case Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVPISNAT
				cValorPai := "NEWSE2->E2_PIS"
				cParcPai := "E2_PARCPIS"

			Case Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVCOFNAT
				cValorPai := "NEWSE2->E2_COFINS"
				cParcPai := "E2_PARCCOF"

			Case Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVCSLNAT
				cValorPai := "NEWSE2->E2_CSLL"
				cParcPai := "E2_PARCSLL"

			Case Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVINSNAT
				cValorPai := "NEWSE2->E2_INSS"
				cParcPai := "E2_PARCINS"

			OtherWise
				cValorPai := "NEWSE2->E2_IRRF"
				cParcPai := "E2_PARCIR"

			EndCase
		Endif
	Else
		lPai := .T.
	Endif
EndIf

// Se nao estiver no titulo pai, procura o titulo Pai.
If !lPai
	dbSelectArea("NEWSE2")
	dbSetOrder(1)
	nRegSE2:= Recno()

	If !EMPTY(cTitPai)
		If MsSeek(xFilial("SE2")+cTitPai)
			lAchou := .T.
		EndIf

	ElseIf MsSeek( xFilial("SE2") + cPrefixo + cNum )
		While !Eof() .and. NEWSE2->( E2_FILIAL + E2_PREFIXO + E2_NUM ) == xFilial( "SE2" ) + cPrefixo + cNum

			If &(cParcPai) == cParcela .and. IIF( cTipoPai $ MVTXA , NEWSE2->E2_TIPO $ MVPAGANT + "/" + MV_CPNEG , .T. )
				If &(cValorPai) != 0
					lAchou := .T.
					Exit
				EndIf
			EndIf

			NEWSE2->(DbSkip())
		Enddo

	EndIf
Endif

dbSelectArea("NEWSE2")

// Se nao encontrou o registro pai, restaura o ponteiro do alias alternativo
// Pois o registro pode ja estar posicionado no titulo principal.
If !lAchou .And. !lPai
	dbGoto(nRegSE2)

ElseIf !lAchou
	NEWSE2->(MsSeek(xFilial("SE2")+(cAliasTrb)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

Endif

RestArea(aArea)

Return lAchou

//---------------------------------------------------------------------------
/*/{Protheus.doc} F401BaseIr
@description Retorna a Base de calculo do IR Pessoa Fisica e Juridica
@type function 
@author Claudio D. de Souza
@since 05/01/07
@version 1.0
@param 
	dDtIni		  , data, 	  Data Inicial para o calculo
	dDtFin		  , data, 	  Data Final para o calculo
	nNaoTributavel, numerico, Valores não tributaveis
	cAliasTrb	  , caracter, Alias utilizado na rotina 
	nDedDep		  , numerico, Valor dedução por dependentes
	cFilAtu		  , numerico, Filial logada
	cCodRet		  , caracter, Codigo de Retenção do Imposto
	cTitsSum	  , caracter, Chave de busca do titulo a ser considerado 
	lReproc		  , booleano, Indica se é um Reprocessamento 
	aLog		  , array   , Array de Logs do processamento
	cCGCCPF		  , caracter, CNPJ/CPF do titulo em execução 
	cMes		  , caracter, Mes que está considerado no calculo 
	lGerLog		  , booleano, Indica se gera log do processamento 
	aSelFil		  , array   , Array de Filiais Selecionadas para processamento
	TMP1		  , alias   , Alias processado na query
	lForExt		  , booleano, Fornecedor fora do pais ou equiparado
	cNIFEX		  , caracter, Codigo Fiscal Fornecedor no Exterior 
	lTemNIF		  , booleano, Indica se foi informado codigo fiscal Exterior ou enviado Codigo+Loja no lugar
	nPercIR		  , numerico, Percentual do IR 
	dDtPgt		  , data    , Data do pagamento do imposto
	lNovoCalc	  , booleano, Indica se houve um novo calculo 
	nRegPai		  , numerico, Recno do Registro Pai do processo
	nTotInsD      , numerico, Total da dedução de INSS

@return aRetBase  , Array com a Base de calculo retornada na função
/*/
//---------------------------------------------------------------------------
Static Function F401BaseIr(	dDtIni as DATE, dDtFin as DATE, nNaoTributavel as NUMERIC, cAliasTrb as CHARACTER, nDedDep as NUMERIC, cFilAtu as CHARACTER,;
							cCodRet as CHARACTER, cTitsSum as CHARACTER, lReproc as LOGICAL, aLog as ARRAY, cCGCCPF as CHARACTER, cMes as CHARACTER,;
							lGerLog as LOGICAL, aSelFil as ARRAY, TMP1 , lForExt as LOGICAL, cNIFEX as CHARACTER, lTemNIF as LOGICAL,; 
							nPercIR as NUMERIC, dDtPgt as DATE, lNovoCalc as LOGICAL, nRegPai as NUMERIC, nTotInsD as Numeric ) as ARRAY
	
	Local aArea 		as ARRAY
	Local aAreaTRB		as ARRAY
	Local nTotTit 		as NUMERIC
	Local nTotInss 		as NUMERIC
	Local nTotIrrf 		as NUMERIC
	Local nX 			as NUMERIC
	// Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
	Local nBaseIr   	as NUMERIC
	Local dData   		as DATE
	Local cChaveSr4 	as CHARACTER

	Local lIRPFBaixa 	as LOGICAL
	Local lAbatINSS		as LOGICAL
	Local nLenLog		as NUMERIC
	Local lUnidNeg		as LOGICAL
	//--
	Local lPesJur		as LOGICAL
	Local lCalcIssBx 	as LOGICAL
	Local cA2CGC		as CHARACTER
	Local aAreaSR4 		as ARRAY

	Local cAno 			as CHARACTER
	Local cSepRec 		as CHARACTER

	Local nSomaBxPA 	as NUMERIC
	Local nImpEmis 		as NUMERIC
	Local lRetemPCC 	as LOGICAL
	Local aRetBase 		as ARRAY
	Local cCampoD  		as CHARACTER
	Local dDataAnt 		as DATE
	Local nTotNaoTrib 	as NUMERIC
	Local nPercReduz 	as NUMERIC
	Local nValNTrib		as NUMERIC
	Local cTpRen		as CHARACTER
	Local aBaixas 		as ARRAY
	Local lFK4OK		as LOGICAL
	Local lRetVlrIr		as LOGICAL
	Local nBaseAux		as NUMERIC

	aArea 		:= GetArea()
	aAreaTRB 	:= {}
	nTotTit 	:= 0
	nTotInss 	:= 0
	nTotIrrf 	:= 0
	nX 			:= 0
	
	nBaseIr   	:= 0
	dData   	:= dtos(dDtIni)
	cChaveSr4 	:= ''
	
	lIRPFBaixa 	:= If(SA2->A2_CALCIRF == "2", .T., .F.)
	lAbatINSS	:=  lINSIRF .And. MV_PAR04 == 1
	nLenLog		:= 0
	lUnidNeg	:= FWGETTAMFILIAL > 2	// Indica se usa Gestao Corporativa
	
	lPesJur		:= SA2->A2_TIPO == "J"
	lCalcIssBx	:= .F.
	cA2CGC		:= SA2->A2_CGC
	aAreaSR4 	:= SR4->(GetArea())

	cAno 		:= STR(YEAR(dDtIni),4)
	cSepRec 	:= If("|"$MVPAGANT,"|",",")

	nSomaBxPA 	:= 0
	nImpEmis 	:= 0
	lRetemPCC 	:= __lPccbaixa .and. ( SA2->A2_RECPIS == "2" .OR. SA2->A2_RECCOFI == "2" .OR. SA2->A2_RECCSLL == "2")
	aRetBase 	:= {}
	cCampoD  	:= ""
	dDataAnt 	:= dData
	nTotNaoTrib := 0
	nPercReduz	:= 0
	nValNTrib	:= 0
	cTpRen		:= ""
	aBaixas 	:= {}
	lFK4OK		:= ( getRpoRelease() >= '12.1.033' ) .and. ( val(SuperGetMV("MV_FINFIX", .F., '0')) > 12 ) //FIX 012 - Ajusta a tabela FK4 gravando os campos FK4_CGC e FK4_RAICGC
	lRetVlrIr	:= .T.
	nBaseAux	:= 0
		
	Default lTemNIF := .F.
	Default lForExt := .F.
	Default cNIFEX := ""
	Default nPercIR := 100
	Default lNovoCalc := .F.
	Default nRegPai	:= 0
	Default nTotInsD := 0

	//Quando IR Progressivo
	If SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1'
		If Len(cCGCCPF) < 14
			cCGCCPF	:= cCGCCPF + Replicate( " ", 14-Len(cCGCCPF) )
		Endif
	Endif

	//Carregar variaveis
	//__lPccBaixa
	If __lpccbaixa == nil
		F401PccBx()
	EndIf
	lCalcIssBx :=	lPesJur .and. lMRETISS //Retencao do ISS pela emissao (1) ou baixa (2)

	If FindFunction( 'IsIssBx' )
		lCalcIssBx :=	IsIssBx( "P" )
	EndIf

	nNaoTributavel  := 0
	nDedDep         := 0
	nTotInsD		:= 0

	cFilAnt := cFilAtu

	DEFAULT aSelFil := { cFilAnt }

	cQuery := c401QryIr1
	cQuery += " AND SE2."+__cFilSE2+" "
	cQuery += " AND SA2.A2_FILIAL"+ cFilSA2 + " "
	

	If !Empty( Iif( lUnidNeg, FWFilial("SED") , xFilial("SED") ) )  .And. Empty( Iif( lUnidNeg, FWFilial("SE2") , xFilial("SE2") ) )
		cQuery += "   AND SED.ED_FILIAL =  SE2.E2_FILORIG "
	Else
		cQuery += "   AND SED.ED_FILIAL = '" + xFilial( "SED" ) + "'"
	Endif

	//--
	If	lPesJur .and. !lForExt
		cQuery += " AND SA2.A2_CGC = '" + cA2CGC + "' "
		cQuery += " AND SA2.A2_PAISEX = ' ' "
		If SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1'
			cQuery += " AND SA2.A2_CPFIRP	= '" + SA2->A2_CPFIRP +	"'"
		Endif

	Else
		cQuery += "   AND SE2.E2_FORNECE = '" + SA2->A2_COD + "'"
		cQuery += "   AND SE2.E2_LOJA = '" + SA2->A2_LOJA + "' "
	EndIf

	// Para Pessoa fisica totaliza os titulos emitidos no mes
	If SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1')
		Do Case
			Case MV_PAR01 == 1 // Data de emissao digitada
				cQuery += " AND SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
				cQuery +=     " SE2.E2_EMIS1 <= '" + Dtos(dDtFin) + "' "
				cCampoD := "E2_EMIS1"
			Case MV_PAR01 == 2// Vencimento
				cQuery += " AND SE2.E2_VENCTO >= '" + Dtos(dDtIni) + "' AND "
				cQuery +=     " SE2.E2_VENCTO <= '" + Dtos(dDtFin) + "' "
				cCampoD := "E2_VENCTO"
			Case MV_PAR01 == 3 //Vencimento real
				cQuery += " AND SE2.E2_VENCREA >= '" + Dtos(dDtIni) + "' AND "
				cQuery +=     " SE2.E2_VENCREA <= '" + Dtos(dDtFin) + "' "
				cCampoD := "E2_VENCREA"
			Case MV_PAR01 == 4 //Data de Baixa ³  MV_PAR01		 // Considera data                                      ³
				cQuery += " AND ((SE2.E2_BAIXA >= '" + Dtos(dDtIni) + "' AND "
				cQuery += "   SE2.E2_BAIXA <= '" + Dtos(dDtFin) + "') OR "
				cQuery += "  (SE2.E2_BAIXA = ' ' AND "
				cQuery += "   SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
				cQuery += "   SE2.E2_EMIS1 <= '" + Dtos(dDtFin)	+ "') ) "
				cCampoD := "E2_BAIXA"
			Case MV_PAR01 == 5 // Data de emissao real
				cQuery += " AND SE2.E2_EMISSAO >= '" + Dtos(dDtIni) + "' AND "
				cQuery +=     " SE2.E2_EMISSAO <= '" + Dtos(dDtFin) + "' "
				cCampoD := "E2_EMISSAO"
		EndCase
	Else
		Do Case
			Case MV_PAR01 == 1 // Data de emissao digit.
				cQuery += " AND SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
				cQuery +=     " SE2.E2_EMIS1 <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03)) + "' "
				cCampoD := "E2_EMIS1"
			Case MV_PAR01 == 2// Vencimento
				cQuery += " AND SE2.E2_VENCTO >= '" + Dtos(dDtIni) + "' AND "
				cQuery +=     " SE2.E2_VENCTO <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03)) + "' "
				cCampoD := "E2_VENCTO"
			Case MV_PAR01 == 3 //Vencimento real
				cQuery += " AND SE2.E2_VENCREA >= '" + Dtos(dDtIni) + "' AND "
				cQuery +=     " SE2.E2_VENCREA <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03)) + "' "
				cCampoD := "E2_VENCREA"
			Case MV_PAR01 == 4 //Data de Baixa
				cQuery += " AND ((SE2.E2_BAIXA >= '" + Dtos(dDtIni) + "' AND "
				cQuery += "   SE2.E2_BAIXA <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03)) + "') OR "
				cQuery += "  (SE2.E2_BAIXA = ' ' AND "
				cQuery += "   SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
				cQuery += "   SE2.E2_EMIS1 <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03))	+ "') ) "
				cCampoD := "E2_BAIXA"

			Case MV_PAR01 == 5 // Data de emissao real
				cQuery += " AND SE2.E2_EMISSAO >= '" + Dtos(dDtIni) + "' AND "
				cQuery +=     " SE2.E2_EMISSAO <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03)) + "' "
				cCampoD := "E2_EMISSAO"
		EndCase
	Endif


	//O valor do rendimento tributavel sera calculado por codigo de retencao, portanto todas as notas que
	//não tiverem codigo de rentencao, não entrarao na somatoria do mês.
	cQuery += " AND SE2.E2_CODRET = '" + cCodRet + "'"

	// Se existir a data de processamento da DIRF, verifica se trata-se de reprocessamento
	If !lReproc
		// filtra os titulos que nao foram processados
		cQuery += "AND SE2.E2_DTDIRF = ' '"
	Endif
	If MV_PAR10 == 2
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)
	EndIf

	If lF401QRY2
			cQuery := ExecBlock("F401QRY2",.F.,.F.,{cQuery})
	Endif

	//cQuery := ChangeQuery(cQuery)

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBIRF", .F., .T.)
	If TRBIRF->(!Eof())
		For nX := 1 to Len(aStru)
			If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
				TCSetField('TRBIRF', aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
			Endif
		Next
	EndIf

	dbSelectArea("TRBIRF")
	While !(TRBIRF->(Eof()))

		dData   	:= DtoS(TRBIRF->&(cCampoD))
		If cCampoD == "E2_BAIXA" .and. Empty(dData)
			dData   	:= DtoS(TRBIRF->E2_EMIS1)
		EndIf
		dDataAnt := dData
		dDtPgt := stod(dData)

		If lAbatINSS
			nTotInsD += TRBIRF->E2_INSS
		EndIf

		// verifica se existe IR baixado, se existir, pula o titulo
		If ( MV_PAR01 == 4 .AND. MV_PAR05 == 2 ) .AND. VerIRBx( TRBIRF->( E2_PREFIXO ) , TRBIRF->( E2_NUM ) , TRBIRF->( E2_PARCIR ) , TRBIRF->( E2_PARCINS ) , dDtFin ).AND. !Empty(TRBIRF->( E2_PARCIR )) .AND. SA2->A2_TIPO=="J"
			TRBIRF->(dbSkip())
			Loop
		EndIf

		IF AScan( aLog, {	|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] + x[12] + DTOS(dDtIni) == ;
														cCGCCPF + 	cCodRet + cMes + "A" +;
														TRBIRF->E2_FILIAL + TRBIRF->(E2_PREFIXO) + TRBIRF->(E2_NUM) + TRBIRF->(E2_PARCELA) + TRBIRF->(E2_TIPO) + TRBIRF->(E2_NATUREZ) + cNIFEX + DTOS(TRBIRF->&(cCampoD)) }) <>0
			TRBIRF->(dbSkip())
			Loop
		EndIf

		If Alltrim(TRBIRF->(E2_NATUREZ)) $ alltrim(cMVPISNAT) .Or. Alltrim(TRBIRF->(E2_NATUREZ) ) $ Alltrim(cMVCOFNAT) .Or. Alltrim(TRBIRF->(E2_NATUREZ) ) $ alltrim(cMVCSLNAT)

			TRBIRF->(dbSkip())
			Loop
		EndIf

		If F401PDesd(TRBIRF->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
			TRBIRF->(dbSkip())
			Loop
		EndIf

		nSomaBxPA := 0
		If MV_PAR10 == 1 // considera PA
			// se for NF e imposto eh na baixa , somente considerar o PA caso nf foi compensada.

			If (!lIRPFBaixa .or. SA2->A2_TIPO != 'J' .OR. !lRetemPCC) .and. TRBIRF->E2_TIPO $ MVPAGANT
				TRBIRF->(dbSkip())
				Loop
			EndIf

			If lIRPFBaixa .and. !TRBIRF->E2_TIPO $ MVPAGANT

				//verifica se NF foi compensada
				nSomaBxPA := RetValCMP("TRBIRF",.F.,lIRPFBaixa,lCalcIssBx,@nImpEmis)

				//Se Imposto é na baixa e houve compensacao da NF, desconsiderar a NF, pois será enviado a PA
				If nSomaBxPA > 0
					If nSomaBxPA == TRBIRF->E2_VALOR + Iif(lIRPFBaixa,0, TRBIRF->E2_IRRF) + Iif(__lPccbaixa,0,TRBIRF->(E2_PIS+E2_COFINS+E2_CSLL)) +  TRBIRF->E2_INSS + If(lCalcIssBx,0,TRBIRF->E2_ISS)
						TRBIRF->(dbSkip())
						Loop
					EndIf
				EndIf

			ElseIf TRBIRF->E2_TIPO $ MVPAGANT

				// verifica se PA nao está baixada, o que significa o seu cancelamento
				nSomaBxPA := RetValCMP("TRBIRF",!lIRPFBaixa ,lIRPFBaixa,lCalcIssBx,@nImpEmis)

				If nSomaBxPA > 0
					If nSomaBxPA == TRBIRF->E2_VALOR + If(__lPaBruto,0,TRBIRF->(E2_IRRF + E2_PIS + E2_COFINS + E2_CSLL) + Iif(__lPrImPA, TRBIRF->(E2_ISS + E2_PRISS + E2_INSS + E2_PRINSS),0 ))
						//PA foi baixada, devolucao da PA desconsiderar PA
						TRBIRF->(dbSkip())
						Loop
					EndIf

				EndIf
			EndIf

		EndIf

		If lFina992
			nTMSVDEP := F992RetVal(cMes, cAno)
			nDedDep :=  nTMSVDEP* SA2->A2_NUMDEP
		Else
			nDedDep :=  nTMSVDEP* SA2->A2_NUMDEP
		EndIf
		If lTpEnt
			If Empty(TRBIRF->A2_TPENT)
				cTpRen := "A"
			Else
				If TRBIRF->A2_TPENT == "1"	 // Fornecedores Imunes
					cTpRen := "I2"
				ElseIf TRBIRF->A2_TPENT == "2"  // Fornecedores Isentos
					cTpRen := "I3"
				EndIf
			EndIf
		Else
			cTpRen := "A"
		EndIf
		If TRBIRF->ED_BASEIRC > 0
			nBaseIr := (TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + If(!lCalcIssBx,E2_ISS,0) + E2_SEST +;
				E2_INSS + if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) * TRBIRF->( ED_BASEIRC / 100 )) 

			nBaseIr := nBaseIr - nSomaBxPA
			If !lNovoCalc
				nBaseIr := Round((nBaseIr * nPercIR)/100,2)
			Endif	

			Fa401AddLog( @aLog, lGerLog, cCGCCPF, cCodRet, cMes, cTpRen, TRBIRF->E2_FILIAL, TRBIRF->E2_PREFIXO, TRBIRF->E2_NUM, TRBIRF->E2_PARCELA, TRBIRF->E2_TIPO, ;
					TRBIRF->E2_NATUREZ, nBaseIr, cNIFEX,SA2->A2_COD, SA2->A2_LOJA  , SA2->A2_FILIAL , SA2->A2_NOME )

			nValNTrib := TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) +;
					E2_INSS + If(!lCalcIssBx,E2_ISS,0) + E2_SEST + if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) - nBaseIr

			// Gera log para rendimentos nao tributaveis
			Fa401AddLog(	@aLog, lGerLog, cCGCCPF, cCodRet, cMes, "I", TRBIRF->E2_FILIAL, TRBIRF->E2_PREFIXO, TRBIRF->E2_NUM, TRBIRF->E2_PARCELA, TRBIRF->E2_TIPO,;
							TRBIRF->E2_NATUREZ, nValNTrib,cNIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
		Else
			nPercReduz := Posicione("SED",1,xfilial("SED") + TRBIRF->E2_NATUREZ,"ED_BASEIRF")
			If nPercReduz > 0
				nBaseIr := (TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + If(!lCalcIssBx,E2_ISS,0) + E2_SEST +;
					E2_INSS + if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) * nPercReduz / 100 )

				nBaseIr := nBaseIr - nSomaBxPA
				If !lNovoCalc
					nBaseIr := Round((nBaseIr * nPercIR)/100,2)
				Endif	

				nValNTrib := TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) +;
					E2_INSS + If(!lCalcIssBx,E2_ISS,0) + E2_SEST + if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) - nBaseIr

				// Gera log para rendimentos nao tributaveis
				Fa401AddLog(	@aLog, lGerLog, cCGCCPF, cCodRet, cMes, "I", TRBIRF->E2_FILIAL, TRBIRF->E2_PREFIXO, TRBIRF->E2_NUM, TRBIRF->E2_PARCELA, TRBIRF->E2_TIPO,;
							TRBIRF->E2_NATUREZ, nValNTrib,cNIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
			Else
				If !Empty(TRBIRF->E2_BAIXA) .and. lIrBx
					aAreaTRB   := GetArea()
					dbSelectArea("SE5")
					aBaixas := GetPosts( xFilial("SE5",TRBIRF->E2_FILIAL),TRBIRF->E2_PREFIXO,;
										TRBIRF->E2_NUM,TRBIRF->E2_PARCELA,TRBIRF->E2_TIPO,;
										TRBIRF->E2_FORNECE,TRBIRF->E2_LOJA,"E5_TIPODOC IN ('VL','BA','CP')" )
										
					If SA2->A2_IRPROG == '1' .And. !Empty(SA2->A2_CPFIRP)
						nBaseIr := F401IrProg(cCGCCPF,aBaixas,lNovoCalc)
					else
						If TRBIRF->E2_SALDO > 0 .or. Len(aBaixas) == 1
							nBaseIr 	:= 0
							nBaseAux	:= 0
							lRetVlrIr	:= .T.

							SE5->(dbGoTo(aBaixas[Len(aBaixas)]))
							nBaseIr := FGetImpRet(SE5->E5_IDORIG,"FK4_BASIMP",{ {"FK4_FILIAL",SE5->E5_FILIAL}, {"FK4_CGC",cCGCCPF}, {"FK4_IMPOS","IRF"} }, @lRetVlrIr)
							If SA2->A2_TIPO == "F" .And. lRetVlrIr .And. !(FKJ->(MsSeek(xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA) ))
								nBaseAux += SE5->E5_BASEIRF
							Endif
							
							if !lFK4OK .and. Empty(nBaseIR)
								nBaseIr := SE5->E5_BASEIRF
							endIf

							If nBaseAux > 0
								nBaseIR := nBaseAux
							Endif 
						Else
							nBaseIr 	:= 0
							nBaseAux	:= 0
							lRetVlrIr	:= .T.
							
							For nX := 1 to Len(aBaixas)
								SE5->(dbGoTo(aBaixas[nX]))
								If !AllTrim(SE5->E5_MOTBX) $ "PCC|ISS"
									nBaseIr += FGetImpRet(SE5->E5_IDORIG,"FK4_BASIMP",{ {"FK4_FILIAL",SE5->E5_FILIAL}, {"FK4_CGC",cCGCCPF}, {"FK4_IMPOS","IRF"} }, @lRetVlrIr)
									If SA2->A2_TIPO == "F" .And. lRetVlrIr .And. !(FKJ->(MsSeek(xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA) ))
										nBaseAux += SE5->E5_BASEIRF
									Endif

									If !lFK4OK .and. Empty(nBaseIR)
										nBaseIr += SE5->E5_BASEIRF
									EndIf
								Endif
							Next nX

							If nBaseAux > 0
								nBaseIR := nBaseAux
							Endif 
						EndIf
					endIf

					If MV_PAR04 == 1 .And. TRBIRF->E2_SALDO == 0 .And. nBaseIr == TRBIRF->E2_BASEIRF
						If lINSIRF 
							//Conforme legislacao, para PF o rendimento tributavel deve ser o valor bruto e nao o valor reduzido
							If (nBaseIr + TRBIRF->E2_INSS +nDedDep) >= TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
								//se a soma da base do ir + o valor do inss for maior que o valor do titulo, mando o valor do titulo
								nBaseIr := TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
							EndIf
						EndIf
					EndIf
					RestArea(aAreaTRB)	
				Else
					If 	TRBIRF->E2_BASEIRF > 0
						nBaseIr := TRBIRF->E2_BASEIRF
						If MV_PAR04 == 1
							If __lFMP1171
								If __nFVL1171+nBaseIr == TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
									nBaseIr += __nFVL1171
								EndIf
							EndIf
							If lINSIRF 
								//Conforme legislacao, para PF o rendimento tributavel deve ser o valor bruto e nao o valor reduzido
								If  (nBaseIr + TRBIRF->E2_INSS +nDedDep) >= TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
									//se a soma da base do ir + o valor do inss for maior que o valor do titulo, mando o valor do titulo
									nBaseIr := TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
								Else
									nBaseIr += TRBIRF->E2_INSS
								EndIf
							EndIf
						EndIf
					Else
						If lIRPFBaixa .AND. TRBIRF->E2_SALDO > 0
							nBaseIr := TRBIRF->( E2_SALDO + E2_VRETIRF +;
							E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
						Else
							nBaseIr := TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) +;
							E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
						EndIf
					EndIf
					If TRBIRF->E2_MOEDA > 1 // Converte valores do titulo para Moeda 1
						nBaseIr := Round(NoRound(xMoeda(nBaseIr,TRBIRF->E2_MOEDA,1,TRBIRF->E2_EMISSAO,MsDecimais(1)+1,TRBIRF->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
					EndIf
				EndIf
			EndIf

			nBaseIr := nBaseIr - nSomaBxPA

			If !lNovoCalc .or. (lNovoCalc .and. Empty(TRBIRF->E2_BAIXA)) 
				nBaseIr := Round((nBaseIr * nPercIR)/100,2)
			Endif

			If Empty(TRBIRF->E2_VRETIRF) .AND. TRBIRF->ED_CALCIRF="N"
				cMes:=STRZERO(MONTH(dDtini),2)
			Else
				cMes:=F401CMES(dDtIni,LastDay(dDtIni),cMes,cCodRet,lReproc, cFilAtu )
			EndIf
			If (MV_PAR01 == 2  .and. MV_PAR05 == 2) .OR. (MV_PAR01 == 4  .and. MV_PAR05 == 2)
				//Se possuir filial centralizadora, posiciona nesta filial
				If !Empty(MV_PAR06)
					cFilAnt := MV_PAR06
				Endif
				// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
				cChaveSr4 := xFilial("SR4")+SRL->RL_MAT+ Padr(cCGCCPF,Len(SR4->R4_CPFCGC)) +cCodRet+STRZERO(YEAR(dDtIni),4)+cMes

				If !SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX  ))

					If nBaseir > 0
						Reclock("SR4", .T.)

						SR4->R4_FILIAL  := xFilial("SR4")
						SR4->R4_MAT     := SRL->RL_MAT
						SR4->R4_CPFCGC  := cCGCCPF
						SR4->R4_MES     := cMes
						SR4->R4_TIPOREN := cTpRen
						SR4->R4_CODRET  := cCodRet
						SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
						SR4->R4_VALOR   := nBaseir
						SR4->R4_ORIGEM := "2"
						SR4->R4_NIFEX := SRL->RL_NIFEX

						If  !Empty(SRL->RL_PAIS)
							SR4->R4_PAIS := SRL->RL_PAIS
							
							SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
							If lISNIF
								SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
							EndIf
						EndIf

						If lFa401Cmp
							// Utilizado para gravar campos complementares do SR4
							ExecBlock("FA401CMP", .F.,.F.)
						Endif

						SR4->(MsUnlock())
					EndIf
				Else
					If nBaseir > 0
						Reclock("SR4", .F.)
						SR4->R4_VALOR  += nBaseir
						SR4->(MsUnlock())
					EndIf
				EndIf
				//Restauro a filial do sistema quando processar com filial centralizadora
				If !Empty(MV_PAR06)
					cFilAnt := cFilAtu
				Endif
			EndIf
			If nBaseir > 0
				// Gera log para rendimentos tributaveis
				Fa401AddLog( @aLog, lGerLog, cCGCCPF, cCodRet, cMes, cTpRen, TRBIRF->E2_FILIAL, TRBIRF->E2_PREFIXO, TRBIRF->E2_NUM, TRBIRF->E2_PARCELA,;
							TRBIRF->E2_TIPO, TRBIRF->E2_NATUREZ, nBaseIr, cNIFEX,SA2->A2_COD, SA2->A2_LOJA  , SA2->A2_FILIAL , SA2->A2_NOME )
			EndIf
		Endif
		If nBaseIr > 0
			If !TMP1->(Dbseek( TRBIRF->RECNO ))
				Reclock("TMP1", .T.)
				TMP1->NROREG 		:= TRBIRF->RECNO
				TMP1->TITIPAI		:= (TRBIRF->RECNO == nRegPai)
				TMP1->(MSUNLOCK())
			Endif
		EndIf	

		nTotTit	+= nBaseIr
		nTotNaoTrib += nValNTrib
		nLenLog := Len( aLog )

		nTotInss += TRBIRF->E2_INSS
		nTotIrrf += TRBIRF->E2_IRRF

		If nBaseIr > 0
			cTitsSum += TRBIRF->( E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA ) + cCodRet + "|"
		EndIf	

		TRBIRF->(dbSkip())

		dData   	:= DtoS(TRBIRF->&(cCampoD))
		If cCampoD == "E2_BAIXA" .and. Empty(dData)
			dData   	:= DtoS(TRBIRF->E2_EMIS1)
		EndIf

		If TRBIRF->(Eof()) .or. dDataAnt <> dData
			aAdd(aRetBase, {dDataAnt, nTotTit,nTotNaoTrib})
			nTotTit := 0
			nTotNaoTrib := 0
		EndIf

	Enddo

	TRBIRF->(dbCloseArea())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³SELECIONA OS DADOS TODOS OS DADOS DE SE2 COM BAIXA                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( MV_PAR01 = 4 .AND. MV_PAR05 = 2 )  //SE ESTÁ SENDO PROCESSADO PELA BAIXA DO TÍTULO DE IMPOSTO

		// QUERY PRINCIPAL DE BUSCA DOS TITULOS
		cQuery := c401QryIr2
		If lPesJur
			cQuery += " AND SE2.E2_FILIAL = '" + xFilial("SE2") + "'"
			cQuery += " AND SA2.A2_FILIAL = '" + xFilial( "SA2" ) + "'"
		Endif

		// Para Pessoa fisica totaliza os titulos baixados no mes
		If SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1')
			cQuery += " AND SE2.E2_BAIXA BETWEEN '" + Dtos(FirstDay(dDtIni)) + "' AND '" + Dtos(LastDay(dDtFin))+ "'"
		Else
			// Para Pessoa juridica totaliza os titulos baixados no dia
			cQuery += " AND SE2.E2_BAIXA BETWEEN '" + Dtos(dDtIni) + "' AND '" + Dtos(MV_PAR03)+ "'"
		Endif
		If !lReproc
			// Senao filtra os titulos que nao foram processados
			cQuery += " AND SE2.E2_DTDIRF = ' '"
		Endif

		//O valor do rendimento tributavel sera calculado por codigo de retencao, portanto todas as notas que
		//não tiverem codigo de rentencao, não entrarao na somatoria do mês.
		cQuery += " AND SE2.E2_CODRET = '" + cCodRet + "'"

		cQuery += " AND '" + SA2->A2_COD + "' = SA2.A2_COD "
		cQuery += " AND '" + SA2->A2_LOJA + "' =  SA2.A2_LOJA"

		cQuery := ChangeQuery( cQuery )

		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBIRF", .F., .T.)

		For nX := 1 to Len(aStru)
			If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
				TCSetField('TRBIRF', aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
			Endif
		Next

		DbSelectArea("TRBIRF")
		While !(TRBIRF->(Eof()))

			dData   	:= DtoS(TRBIRF->E2_BAIXA)
			dDataAnt := dData
			dDtPgt := stod(dData)

			SE2->(DbSetOrder(1))
			SE2->(DbSeek(xFilial("SE2")+TRBIRF->(E2_PREFIXO+E2_NUM)))
			While SE2->E2_PARCIR <> TRBIRF->E2_PARCELA .AND.;
					SE2->(E2_PREFIXO+E2_NUM) == TRBIRF->(E2_PREFIXO+E2_NUM)
				SE2->(DbSkip())
			EndDo
			SED->(DbSetOrder(1))
			SED->(DbSeek(xFilial("SED")+SE2->(E2_NATUREZ)))
			cMes:=STRZERO(MONTH(dDtini),2)
				IF AScan( aLog, {	|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] + x[12]== ;
													cCGCCPF + 	cCodRet + cMes + "A" +;
													xFilial("SE2") + SE2->(E2_PREFIXO) + SE2->(E2_NUM) + SE2->(E2_PARCELA) + SE2->(E2_TIPO) + SE2->(E2_NATUREZ) + cNIFEX  }) <>0
				TRBIRF->(dbSkip())
				Loop
			EndIf

			If SED->ED_BASEIRC > 0 // Se houver base de reducao de carreteiro
				nBaseIr := SE2->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) +;
						E2_INSS + If(!lCalcIssBx,E2_ISS,0) + E2_SEST+ if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) * SED->( ED_BASEIRC / 100 )
					If lINSIRF .And. MV_PAR04 == 1
						nBaseIr :=nBaseIr -SE2->E2_INSS
					EndIf
				Fa401AddLog(  @aLog, lGerLog, cCGCCPF, cCodRet, cMes, "A", SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO,;
								SE2->E2_NATUREZ, nBaseIr, cNIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME  )

				nNaoTributavel := SE2->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) +;
					E2_INSS + If(!lCalcIssBx,E2_ISS,0) + E2_SEST+ if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) - nBaseIr
				// Gera log para rendimentos nao tributaveis
				Fa401AddLog(	@aLog, lGerLog, cCGCCPF, cCodRet, cMes, "I", SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO,;
								SE2->E2_NATUREZ, nNaoTributavel, cNIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME  )
			Else
				If lIRPFBaixa .AND. SE2->E2_SALDO > 0
					nBaseIr := SE2->( E2_SALDO + E2_VRETIRF +;
						E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
				Else
					nBaseIr := SE2->(E2_VALOR + If(lIRPFBaixa,0,E2_IRRF)+;
						E2_INSS+If(!lCalcIssBx,E2_ISS,0)+E2_SEST+ if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
				Endif
				// Gera log para rendimentos tributaveis
				Fa401AddLog(	@aLog, lGerLog, cCGCCPF, cCodRet, cMes, "A", SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA,;
								SE2->E2_TIPO, SE2->E2_NATUREZ, nBaseIr, cNIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME  )
			EndIf
			If MV_PAR01 == 4  .and. MV_PAR05 == 2 .and. SA2->A2_TIPO=="J"
				//Se possuir filial centralizadora, posiciona nesta filial
				If !Empty(MV_PAR06)
					cFilAnt := MV_PAR06
				Endif

				If lTpEnt
					If Empty(TRBIRF->A2_TPENT)
						cTpRen := "A"
					Else
						If TRBIRF->A2_TPENT == "1"	 // Fornecedores Imunes
							cTpRen := "I2"
						ElseIf TRBIRF->A2_TPENT == "2"  // Fornecedores Isentos
							cTpRen := "I3"
						EndIf
					EndIf
				Else
					cTpRen := "A"
				EndIf

				// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
				cChaveSr4 := xFilial("SR4")+SRL->RL_MAT+ Padr(cCGCCPF,Len(SR4->R4_CPFCGC)) +cCodRet+STRZERO(YEAR(dDtIni),4)+cMes
				If !SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))
					If nBaseir > 0
						Reclock("SR4", .T.)

						SR4->R4_FILIAL  := xFilial("SR4")
						SR4->R4_MAT     := SRL->RL_MAT
						SR4->R4_CPFCGC  := cCGCCPF
						SR4->R4_MES     := cMes
						SR4->R4_TIPOREN := cTpRen
						SR4->R4_CODRET  := cCodRet
						SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
						SR4->R4_VALOR   := nBaseir
						SR4->R4_ORIGEM := "2"
						SR4->R4_NIFEX := SRL->RL_NIFEX

						If !Empty(SRL->RL_PAIS)
							SR4->R4_PAIS := SRL->RL_PAIS
							
							SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
							If lISNIF
								SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
							EndIf
						EndIf

						If lFa401Cmp
							// Utilizado para gravar campos complementares do SR4
							ExecBlock("FA401CMP", .F.,.F.)
						Endif

						SR4->(MsUnlock())
					EndIf

				Else
					If nBaseir > 0
						Reclock("SR4", .F.)
						SR4->R4_VALOR  += nBaseir
						SR4->(MsUnlock())
					EndIf
				EndIf
				//Restauro a filial do sistema quando processar com filial centralizadora
				If !Empty(MV_PAR06)
					cFilAnt := cFilAtu
				Endif
			Endif

			nTotTit	+= nBaseIr
			nTotNaoTrib += nNaoTributavel
			nLenLog := Len( aLog )

			nTotInss += SE2->(E2_INSS)
			nTotIrrf += SE2->(E2_IRRF)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Somente gera log com abatimento do INSS da base de calculo   ³
			//³ se for fornecedor do tipo pessoa fisica.                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SED")
			SED->(DbSetOrder(1))
			SED->(DbSeek(xFilial("SED")+ NEWSE2->E2_NATUREZ))

			If lAbatINSS .And. SED->ED_BASEIRC == 0
				Fa401EdtLog( @aLog, lGerLog, nLenLog, LOG_VALOR, SE2->E2_INSS, "-" )
			EndIf

			If nBaseIr > 0
				cTitsSum += SE2->( E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA ) + cCodRet + "|"
			EndIf
			
			TRBIRF->(dbSkip())

			dData   	:= DtoS(TRBIRF->&(cCampoD))
			If cCampoD == "E2_BAIXA" .and. Empty(dData)
				dData   	:= DtoS(TRBIRF->E2_EMIS1)
			EndIf

			If TRBIRF->(Eof()) .or. dDataAnt <> dData
				aAdd(aRetBase, {dDataAnt, nTotTit,nTotNaoTrib})
				nTotTit := 0
				nTotNaoTrib := 0
			EndIf		

		Enddo

		TRBIRF->(dbCloseArea())
	EndIf

	nBaseIr := nTotTit

	dbSelectArea("SE2")

	//Restauro a filial do sistema quando processar com filial centralizadora
	If !Empty(MV_PAR06)
		cFilAnt := MV_PAR06
	Endif

	RestArea(aArea)
	SR4->(RestArea(aAreaSR4))
Return aClone(aRetBase)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MsSomaMes ºAutor  ³Microsiga           º Data ³  16/05/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Soma meses em determinada data                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Generico                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MsSomaMes( dGivenDate, nAddMonths, lMakeEOM)
// Baseada em FT_MADD da Nanfor
  LOCAL nAdjDay, dTemp, i

  IF(VALTYPE(dGivenDate) != 'D', dGivenDate := DATE(), )
  IF(VALTYPE(nAddMonths) != 'N', nAddMonths := 0, )
  IF(VALTYPE(lMakeEOM)   != 'L', lMakeEom := .F., )

  nAdjDay := DAY( dGivenDate ) - 1

  dTemp := dGivenDate - nAdjDay     // first of month

  /* Trabalha sempre com o primeiro dia dos meses.*/
  For i := 1 To Abs(nAddMonths)
      dTemp += If( nAddMonths > 0, 31, -1 )
      dTemp += 1 - DAY( dTemp )
  Next

  If lMakeEom
     dTemp += 31 - DAY( dTemp + 31 )
  Else
     dTemp := MIN( (dTemp + nAdjday), (dTemp += 31 - DAY( dTemp + 31 )))
  Endif

Return dTemp

/*
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³ f401TotPLS ³ Autor ³ Sandro Hoffman Lopes  ³ Data ³ 10.03.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Totaliza os valores pagos por fornecedor no mes - PLS        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ f401TotPLS(cAliasPai, cAliasTrb)	 				                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAliasPai: Alias do Titulo Principal                         ³±±
±±³          ³ cAliasTrb: Alias do Titulo de Imposto                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function f401TotPLS(cAliasPai, cAliasTrb)

Local aArea := GetArea()
Local nRendTributavel := 0
Local aCodLan
Local nI

If Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVIRNAT .or. Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVINSNAT
	If lINSIRF .And. MV_PAR04 == 1
	    aCodLan := {"198","195","193","197","1A1"}
	Else
	    aCodLan := {"198"}
	EndIf
Else // PIS, COFINS e CSLL
	If (cAliasTrb)->(E2_CODRET) == "5979" // PIS
		aCodLan := { "186" }
	ElseIf (cAliasTrb)->(E2_CODRET) == "5960" // COFINS
		aCodLan := { "188" }
	ElseIf (cAliasTrb)->(E2_CODRET) == "5987" // CSL
		aCodLan := { "190" }
	Else // 5952 --> PIS + COFINS + CSLL
		aCodLan := { "186" }
	EndIf
EndIf

// Indice 1: BMR_FILIAL+BMR_OPERDA+BMR_CODRDA+BMR_OPELOT+BMR_ANOLOT+BMR_MESLOT+BMR_NUMLOT+BMR_CODLAN
BMR->(DbSetOrder(1))
For nI := 1 To Len(aCodLan)
 	If BMR->(MsSeek(xFilial("BMR")+(cAliasPai)->(E2_PLOPELT+E2_CODRDA+E2_PLOPELT+E2_PLLOTE)+aCodLan[nI]))
		nRendTributavel += BMR->BMR_VLRPAG
	EndIf
Next nI

RestArea(aArea)

Return nRendTributavel

/*
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Fa401SemImp ³ Autor ³ Claudio D. de Souza   ³ Data ³ 24.04.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Totaliza titulos sem impostos cujo valor seja maior que 6000 ³±±
±±³e gera titulos que possuem fatura com retencao de IRRF ou PCC na baixa  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Fa401SemImp()										                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401SemImp(aRecno,lReproc,cFilAtu,aLog,lGerLog,aTitPai,TMP1)
Local cQuery 	 := ""
Local cAbatim 	 := MV_CRNEG+"|"+MV_CPNEG+"|"+MVIRABT+"|"+MVCSABT+"|"+MVCFABT+"|"+MVPIABT+"|"+MVABATIM
Local cImpostos := MVISS+"|"+MVTAXA+"|"+MVTXA+"|"+MVINSS+"|"+"SES"+ "|" + "INA"
Local cNotIn	 := ""
Local cAliasTrb := GetNextAlias()
Local cTipoFj

Local nX, nY
Local bWhile 	 	 := { || .T. }
Local bFor   	 	 := { || .T. }
Local cFornUniao 	 := GetMv("MV_UNIAO")
Local aRendimentos := {}
Local nRendAnual	 := 0
Local cChaveAnt	 := ""
Local nAscan
Local lQuery 	:= .F.
Local cCondicao := ""
Local cCampo
Local cCampoP
Local nPosLog	:= 0
Local aDadosLog	:= {}

Local nIRRet
Local nValor	:= 0
Local lCalcIssBx :=	SA2->A2_TIPO == "J" .And. GetNewPar("MV_MRETISS","1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)
Local lIrBx		:=	.F.
Local cCodRet		:= ' '
Local cRaMat		:=	''
Local lEnvia		:=	.T.
Local nOrdSe2		:= SE2->(IndexOrd())
Local aAreaSe2 	:= SE2->(GetArea())
Local lFatBx		:=	.F.
Local cData		:= ""
Local lTemNIF := .F.
Local cNIFEX := ""
Local nTamNIF := TamSx3("RL_NIFEX")[1]
Local nSomaBxPA := 0
Local lInssPA := .F.
Local lRetemPCC  := .F.
Local cTpRen	 := ""

If FindFunction( 'IsIssBx' )
	lCalcIssBx :=	IsIssBx( "P" )
EndIf


// Se possuir filial centralizadora, posiciona nesta filial
If !Empty(MV_PAR06)
	cFilAnt := cFilAtu
Endif

Do Case //Titulos de outros impostos
	Case MV_PAR01 == 1 // Data de emissao digitada
		cData  := "E2_EMIS1"
	Case MV_PAR01 == 2// Vencimento
		cData  := "E2_VENCTO"
	Case MV_PAR01 == 3 //Vencimento real
		cData  := "E2_VENCREA"
	Case MV_PAR01 == 4 //Data de Baixa
		cData := "E2_BAIXA"
	Case MV_PAR01 == 5 // Data de emissao real
		cData  := "E2_EMISSAO"
EndCase
//campo data de titulos de pcc
Do Case
	Case MV_PAR09 == 1 // Data de emissao
		cCampoP  := "E2_EMIS1"
	Case MV_PAR09 == 2// Vencimento
		cCampoP  := "E2_VENCTO"
	Case MV_PAR09 == 3 //Vencimento real
		cCampoP  := "E2_VENCREA"
	Case MV_PAR09 == 4 //Data de Baixa
		cCampoP := "E2_BAIXA"
	Case MV_PAR09 == 5 //Data de Emissao
		cCampoP := "E2_EMISSAO"

EndCase
Fa401SqlSImp(@cNotIn,@lQuery,@cAbatim,@cImpostos,@cQuery,@lReproc,@cFornUniao,@cAliasTrb,@nX,@cCondicao,@bWhile,@bFor,@cCampo)

While (cAliasTrb)->(!Eof()) .And. Eval(bWhile)

	If TMP1->(Dbseek((cAliasTrb)->R_E_C_N_O_))
		(cAliasTrb)->(Dbskip())
		Loop
	Endif

	//Caso titulo seja retido em outro que já foi gravado para a DIRF durante esta execução não deve duplicar.
	SFQ->(DbSetOrder(2)) //FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
	If SFQ->(DbSeek(xFilial("SFQ")+ Iif(__lPCCBaixa,"SE5","SE2") + (cAliasTrb)->E2_PREFIXO + (cAliasTrb)->E2_NUM + (cAliasTrb)->E2_PARCELA + (cAliasTrb)->E2_TIPO +;
							 (cAliasTrb)->E2_FORNECE + (cAliasTrb)->E2_LOJA ))
		aAreaSe2 := SE2->(GetArea())
		SE2->(DbSetOrder(1))
		If SE2->(Dbseek(xFilial("SE2")+ SFQ->FQ_PREFORI + SFQ->FQ_NUMORI + SFQ->FQ_PARCORI + SFQ->FQ_TIPOORI + SFQ->FQ_CFORI + SFQ->FQ_LOJAORI))
			If (SE2->&(cData) <= MV_PAR03 .And. SE2->&(cData) >= MV_PAR02)
				(cAliasTrb)->(Dbskip())
				Loop
			Endif
		Endif
		SE2->(RestArea(aAreaSe2))
	Endif

	If Eval(bFor) .And. !Fa401PaiProc( aTitPai , (cAliasTrb)->(E2_CODRET+E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) )

		SA2->(MsGoto((cAliasTrb)->RECNOSA2))
		SED->(DBSeek(xFilial("SED") + (cAliasTrb)->(E2_NATUREZ)))
		lIrBx:=	SA2->A2_CALCIRF == "2" .And. SED->ED_CALCIRF = "S"
		lRetemPCC := __lPccbaixa .and. ( SA2->A2_RECPIS == "2" .OR. SA2->A2_RECCOFI == "2" .OR. SA2->A2_RECCSLL == "2")

		lInssPa:= SED->ED_RINSSPA = "1"

		nSomaBxPA := 0
		//tratamento para PA
		//MV_PAR10 = Nao - Mantem legado, nao envia pa somente titulos principais
		//MV_PAR10 = Sim - Toda PA sera enviada, e será tratado a NF que foi compensada, nao deve ir
		If MV_PAR10 == 1 //sim -considera pagamento antecipado

			If (!lIrBx .or. SA2->A2_TIPO != 'J' .OR. !lRetemPCC) .and. (cAliasTrb)->E2_TIPO $ MVPAGANT
				(cAliasTrb)->(Dbskip())
				Loop
			EndIf


			If (lIrBx .and. lRetemPCC ) .and. !(cAliasTrb)->E2_TIPO $ MVPAGANT

				//verifica se NF foi compensada
				nSomaBxPA := RetValCMP(cAliasTrb,.F.,lIrBx,lCalcIssBx,)

				//Se Imposto é na baixa e houve compensacao da NF, desconsiderar a NF, pois será enviado a PA
				If nSomaBxPA > 0
					If nSomaBxPA == (cAliasTrb)->E2_VALOR + Iif(lIrBx,0, (cAliasTrb)->E2_IRRF) + Iif(__lPccbaixa,0,(cAliasTrb)->(E2_PIS+E2_COFINS+E2_CSLL)) +  (cAliasTrb)->E2_INSS + If(lCalcIssBx,0,(cAliasTrb)->E2_ISS)
						(cAliasTrb)->(Dbskip())
						Loop
					EndIf
				EndIf

			ElseIf (cAliasTrb)->E2_TIPO $ MVPAGANT

				// verifica se PA nao está baixada, o que significa o seu cancelamento
				nSomaBxPA := RetValCMP(cAliasTrb, (!lIrBx .or. !__lPccbaixa),lIrBx,lCalcIssBx,)

				If nSomaBxPA > 0
					If nSomaBxPA == (cAliasTrb)->E2_VALOR + If(__lPaBruto, IIf(lInssPa,  (cAliasTrb)->(E2_INSS), 0 ),(cAliasTrb)->(E2_IRRF + E2_PIS + E2_COFINS + E2_CSLL) + Iif(__lPrImPA, (cAliasTrb)->(E2_ISS + E2_PRISS + E2_INSS + E2_PRINSS),0 ))
						//PA foi baixada, devolucao da PA desconsiderar PA
						(cAliasTrb)->(Dbskip())
						Loop
					EndIf
				EndIf
			EndIf

		EndIf

		lTemNIF := .F.
		cNIFEX := Space(nTamNIF)
		//Verifico o tipo da pessoa do Fornecedor (Fisico ou Juridico.
		//Em branco ou X - Outros, serao verificados pelo CGC
		If Empty(SA2->A2_TIPO) .or. !(SA2->A2_TIPO $ "F/J")
			If SA2->A2_TIPO == "X"
				cTipoFj := "2"
			ElseIf SA2->A2_IRPROG == '2'
				cTipoFj := "1"
			Else
				cTipoFj := Iif(Len(AllTrim(SA2->A2_CGC	)) > 11,"2","1")
			EndIf
		Else
			cTipoFj := IIf( SA2->A2_TIPO = "F" , "1" , If(SA2->A2_TIPO == 'J' .AND. SA2->A2_IRPROG == '1',"1","2") )
		Endif

		// Se for um fornecedor definido no parametro
		If Val(cTipoFj) == MV_PAR04

			// Se possuir filial centralizadora, posiciona nesta filial
			If !Empty(MV_PAR06)
				cFilAnt := MV_PAR06
			Endif

			If MV_PAR01 == 4
				/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se for pela data da baixa, verifico qual data a ser considerada³
				//³Se titulo baixado, considero data da baixa                     ³
				//³Se titulo não baixado, considero data da emissao			            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				//Data da Baixa
				If Empty((cAliasTrb)->E2_BAIXA)
					cCampo := "E2_EMIS1"
				Else
					cCampo := "E2_BAIXA"
				Endif
			Endif

			//tratamento para fornecedor exterior sem NIF
			If !Empty(SA2->A2_PAISEX) 
				If IsCodResExt((cAliasTrb)->E2_CODRET) .or. (SA2->A2_TIPO $ "J|X" .and. (Empty(SA2->A2_CGC) .or. SA2->A2_CGC =="00000000000000"))
					If Empty(SA2->A2_NIFEX)
						cNIFEX := SA2->A2_COD +  SA2->A2_LOJA
						lTemNIF := .F.
					Else
						cNIFEX := SA2->A2_NIFEX
						lTemNIF := .T.
					EndIf
				EndIf					
			EndIf


			// Gera novo numero de matricula, caso ainda nao exista no cabecalho (SRL)
			If !SRL->(MsSeek(xFilial("SRL")+Padr(SM0->M0_CGC,Len(SRL->RL_CGCFONT))+;
			 (cAliasTrb)->E2_CODRET +cTipoFj+If(SA2->A2_TIPO == "J"  .and. SA2->A2_IRPROG = '1',Padr(SA2->A2_CPFIRP,14),Padr(SA2->A2_CGC,Len(SRL->RL_CPFCGC))) + cNIFEX ))

				If (nAscan:=Ascan(aRendimentos, {|e| e[5]+e[2]+e[3]+e[13]== (cAliasTrb)->E2_CODRET+cTipoFj+If(SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG = '1',SA2->A2_CPFIRP,SA2->A2_CGC)+ cNIFEX  })) == 0
					cRaMat := GetSxENum("SRL", "RL_MAT")
					cRaMat := If(Val(SRA->RA_MAT) < 900000 .And. Val(cRaMat) < 900000, "900000",cRaMat)
					ConfirmSx8()
				Else
					cRaMat := aRendimentos[nAscan,12]
				Endif
			Else
				cRaMat := SRL->RL_MAT
			Endif
			// Se existir o ano na chave do SR4
	  		// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
	  		cChaveSr4 := xFilial("SR4")+cRaMat+If(SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1',Padr(SA2->A2_CPFIRP,Len(SR4->R4_CPFCGC)),SA2->A2_CGC)+(cAliasTrb)->E2_CODRET+STRZERO(YEAR((cAliasTrb)->&(cCampo)),4)+STRZERO(MONTH((cAliasTrb)->&(cCampo)),2)

			//Restauro a filial do sistema quando processar com filial centralizadora
			If !Empty(MV_PAR06)
				cFilAnt := cFilAtu
			Endif

			lEnvia		:=	.T.
			cCodRet	:= (cAliasTrb)->E2_CODRET
			lFatBx		:=	.F.
			//Titulo que possua fatura que retenha IRRF ou PCC na baixa.
			//se fatura estiver baixada e tiver imposto na baixa, envia a fatura, caso contrario envia a nf
			If ((lIrBx .And. (cAliasTrb)->E2_IRRF > 0) .Or.;
				 (__lPCCBaixa .And. ((cAliasTrb)->E2_COFINS+(cAliasTrb)->E2_PIS+(cAliasTrb)->E2_CSLL) > 0)) .And.;
					!Empty((cAliasTrb)->E2_FATURA)
				If Alltrim((cAliasTrb)->E2_FATURA) != "NOTFAT"
					nOrdSe2	:= SE2->(IndexOrd())
					aAreaSe2 	:= SE2->(GetArea())

					//Procurar a fatura deste titulo.
					SE2->(Dbsetorder(6)) //FILIAL+FORNECE+LOJA+PREFIXO+NUM//+PARCELA+TIPO
					If SE2->(Dbseek( xFilial("SE2") + (cAliasTrb)->E2_FATFOR + (cAliasTrb)->E2_FATLOJ + (cAliasTrb)->E2_FATPREF + (cAliasTrb)->E2_FATURA  ))
						While !SE2->(Eof()) .And.;
								SE2->E2_FILIAL = xFilial("SE2") .And. ;
								(SE2->E2_FORNECE + SE2->E2_LOJA + SE2->E2_PREFIXO + SE2->E2_NUM) = ((cAliasTrb)->E2_FATFOR + (cAliasTrb)->E2_FATLOJ + (cAliasTrb)->E2_FATPREF + (cAliasTrb)->E2_FATURA)

							If SE2->E2_TIPO = (cAliasTrb)->E2_TIPOFAT
								If !Empty(SE2->E2_BAIXA)
									lFatBx	:=	.T.
									lEnvia	:=	.F.
								Endif
							Endif
							SE2->(Dbskip())
						Enddo
					Endif

					SE2->(Dbsetorder(nOrdSe2))
					SE2->(RestArea(aAreaSe2))
				Else
					If Empty((cAliasTrb)->E2_BAIXA)
						//se o título for uma fatura e estiver em aberto, não enviar para DIRF, pois deverá enviar as NFs que a compoe
						lEnvia	:=	.F.
					EndIf
				EndIf

				If lEnvia
					SA2->(MsSeek(xFilial("SA2")+(cAliasTrb)->(E2_FORNECE+E2_LOJA)))

					nValor		:=	0

					//Gravar dados do IRRF
					If !Empty(cCodRet) .And. (cAliasTrb)->E2_IRRF > 0  .And. lIrBx
						nValor		:=	(cAliasTrb)->E2_IRRF
						If !Empty(cCodRet) .And. nValor > 0
							GravTitFat(cCodRet,nValor,cRaMat,cTipoFj,cAliasTrb,cCampo,aLog,lGerLog,@aRendimento,@aDadosLog,lFatBx)
						Endif
					Endif

					//Gravar dados do PCC
					If (cAliasTrb)->E2_PIS + (cAliasTrb)->E2_COFINS + (cAliasTrb)->E2_CSLL > 0 .And. __lPccBaixa
						cCodRet	:=	'5952'
						nValor		:=	(cAliasTrb)->E2_PIS + (cAliasTrb)->E2_COFINS + (cAliasTrb)->E2_CSLL
						If nValor > 0
							GravTitFat(cCodRet,nValor,cRaMat,cTipoFj,cAliasTrb,cCampoP,aLog,lGerLog,@aRendimento,@aDadosLog,lFatBx)
						Endif
					Endif
				Endif
			Else
				If lTpEnt
					If Empty((cAliasTrb)->A2_TPENT)
						cTpRen := "A"
					Else
						If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
							cTpRen := "I2"
						ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
							cTpRen := "I3"
						EndIf
					EndIf
				Else
					cTpRen := "A"
				EndIf
				// Gera valor do Rendimento do IR
				If (nAscan:=Ascan(aRendimentos, {|e| e[1] == cChaveSr4+padr(cTpRen,nTamTpRen)+SRL->RL_PAIS + SRL->RL_NIFEX })) == 0
					If SED->ED_BASEIRC > 0 	
						nValor := ((cAliasTrb)->E2_VALOR + If(lIrBx,0,(cAliasTrb)->E2_IRRF) +;
						(cAliasTrb)->E2_INSS + If(!lCalcIssBx,(cAliasTrb)->E2_ISS,0) ) * SED->( ED_BASEIRC / 100 )
						If lINSIRF .And. MV_PAR04 == 1
							nValor :=nValor -(cAliasTrb)->E2_INSS
						EndIf
					Else
						//recompoe o valor bruto onde foi descontado o ISS na emissão e INSS, pois deve ser gerado pelo valor bruto
						nValor := (cAliasTrb)->E2_VALOR + IIf(!lCalcIssBx .and. (cAliasTrb)->E2_ISS > 0, (cAliasTrb)->E2_ISS,0) + (cAliasTrb)->E2_INSS
					EndIf
					Aadd(aRendimentos, {	cChaveSr4+padr(cTpRen,nTamTpRen)+ SRL->RL_PAIS + SRL->RL_NIFEX ,;
												cTipoFj,;
												If(SA2->A2_TIPO == "J".and. SA2->A2_IRPROG = '1',SA2->A2_CPFIRP,SA2->A2_CGC),;
												STRZERO(MONTH((cAliasTrb)->&(cCampo)),2),;
												(cAliasTrb)->E2_CODRET,;
												STRZERO(YEAR((cAliasTrb)->&(cCampo)),4),;
												nValor,;
												SA2->A2_NOME,;
												Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END),;
												SA2->A2_EST,;
												SA2->A2_BAIRRO,;
												cRaMat,;
												cNIFEX,;
												lTemNIF,;
												cTpRen } )
					nPosLog := Len(aRendimentos)
				Else

				 	nValor := (cAliasTrb)->E2_VALOR + IIf(!lCalcIssBx .and. (cAliasTrb)->E2_ISS > 0, (cAliasTrb)->E2_ISS,0) + (cAliasTrb)->E2_INSS

					aRendimentos[nAscan,7] += nValor
					nPosLog := nAscan
				Endif

				If lGerLog
					(cAliasTrb)->( AAdd( aDadosLog, {	aRendimentos[nPosLog,3], aRendimentos[nPosLog,5], aRendimentos[nPosLog,4], "A",;
														E2_FILIAL, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, E2_NATUREZ, nValor, SRL->RL_NIFEX,SA2->A2_COD , SA2->A2_LOJA,;
														SA2->A2_FILIAL, SA2->A2_NOME  } ) )
				EndIf

			Endif

			Aadd(aRecno, (cAliasTrb)->R_E_C_N_O_)

		Endif

	Endif

	(cAliasTrb)->(DbSkip())

	// Se possuir filial centralizadora, posiciona nesta filial
	If !Empty(MV_PAR06)
		cFilAnt := cFilAtu
	Endif
Enddo

// Se possuir filial centralizadora, posiciona nesta filial
If !Empty(MV_PAR06)
	cFilAnt := MV_PAR06
Endif

nRendAnual	:= 0
cChaveAnt	:= ""
nLen        := Len(aRendimentos)

// Ordena por Fornecedor + Codigo de retencao
aSort(aRendimentos,,,{ |x,y| x[3]+x[13]+x[5] <  y[3]+y[13]+y[5] } )
aSort(aDadosLog,,,{ |x,y| x[1]+x[12]+x[2] < y[1]+y[12]+y[2] } )

//Se possuir filial centralizadora, posiciona nesta filial
If !Empty(MV_PAR06)
	cFilAnt := MV_PAR06
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ So grava para quem teve rendimento superior a 6.000 no ano,  ³
//³ conforme artigo 1o. da IN. SRF No. 511/2005.		         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 To nLen

	If Len(aRendimentos[nX]) > 14
		cTpRen := aRendimentos[nX,15]
	ElseIf Empty(cTpRen)
		cTpRen := "A"
	EndIf

	// Soma os rendimentos do ano do mesmo fornecedor
	If Empty(nRendAnual) .Or. cChaveAnt != aRendimentos[nX,3] + aRendimentos[nX,13]

		cQuery := "SELECT SUM(R4_VALOR) RENDIMENTO "
		cQuery += "FROM " + RetSqlName("SR4") + " A "
		cQuery += "WHERE R4_CPFCGC = '" + aRendimentos[nX,3] + "' AND "
		cQuery += "R4_CODRET = '"+ aRendimentos[nX,5] + "' AND "
		cQuery += "R4_TIPOREN = '" + cTpRen + "' AND "
		cQuery += "R4_FILIAL = '" + xFilial("SR4") + "' AND "
		cQuery += "R4_NIFEX = '"+ aRendimentos[nX,13] + "' AND "
		cQuery += "D_E_L_E_T_ = ' ' "

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "REND", .F., .T.)

		nRendAnual := 0 + REND->RENDIMENTO
		REND->(DbCloseArea())
		cChaveAnt  := (aRendimentos[nX,3] + aRendimentos[nX,13] + aRendimentos[nX,5])
		For nY := nX To nLen
			// Mudou de fornecedor ou codigo de retencao
			If cChaveAnt != (aRendimentos[nY,3]+aRendimentos[nY,13] + aRendimentos[nY,5])
				Exit
			Endif
			nRendAnual += aRendimentos[nY,7]
		Next
	Endif

	cQuery := "SELECT SUM(R4_VALOR) IRRETIDO "
	cQuery += "FROM " + RetSqlName("SR4") + " A "
	cQuery += "WHERE R4_CPFCGC = '" + aRendimentos[nX,3] + "' AND "
	cQuery += "R4_CODRET = '"+ aRendimentos[nX,5] + "' AND "
	cQuery += "R4_TIPOREN = 'D' AND "
	cQuery += "R4_FILIAL = '" + xFilial("SR4") + "' AND "
	cQuery += "R4_NIFEX = '"+ aRendimentos[nX,13] + "' AND "
	cQuery += "D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "IMPOST", .F., .T.)

	nIRRet := 0 + IMPOST->IRRETIDO
	IMPOST->(DbCloseArea())

	// Grava SR4 apenas para fornecedores com rendimento anual maior que 6.000,00
	If nRendAnual > 0 .or. nIRRet > 0
		If !SR4->(MsSeek(aRendimentos[nX,1]))
			// Pesquisa cabecalho da DIRF
			If !SRL->(MsSeek(xFilial("SRL")+SM0->M0_CGC+aRendimentos[nX,5]+aRendimentos[nX,2]+aRendimentos[nX,3] + aRendimentos[nX,13]) )
				PosSA2Log(aRendimentos[nX,3], aRendimentos[nX,13])
				Reclock("SRL", .T.)
				SRL->RL_FILIAL  := xFilial("SRL")
				SRL->RL_MAT     := aRendimentos[nX,12]
				SRL->RL_CODRET  := aRendimentos[nX,5]
				SRL->RL_TIPOFJ  := aRendimentos[nX,2]
				SRL->RL_CPFCGC  := aRendimentos[nX,3]
				SRL->RL_BENEFIC := aRendimentos[nX,8]
				SRL->RL_ENDBENE := aRendimentos[nX,9]
				SRL->RL_UFBENEF := aRendimentos[nX,10]
				SRL->RL_COMPLEM := aRendimentos[nX,11]
				SRL->RL_CGCFONT := SM0->M0_CGC
				SRL->RL_NOMFONT := SM0->M0_NOMECOM
				SRL->RL_ORIGEM := "2"
				SRL->RL_CGCEX := SA2->A2_CGCEX
				SRL->RL_PAIS  := SA2->A2_PAISEX
				SRL->RL_NIFEX := aRendimentos[nX,13] //SA2->A2_NIFEX

				If  IsCodResExt(SRL->RL_CODRET)
					SRL->RL_NEMPR := SA2->A2_NEMPR
					SRL->RL_TPCON := SA2->A2_TPCON
					SRL->RL_DTINI := SA2->A2_DTINIR
					SRL->RL_DTFIM := SA2->A2_DTFIMR
					SRL->RL_LOGEX := SA2->A2_LOGEX
					SRL->RL_NUMEX := SA2->A2_NUMEX
					SRL->RL_COMPL := SA2->A2_COMPLR
					SRL->RL_BAIEX := SA2->A2_BAIEX
					SRL->RL_POSEX := SA2->A2_POSEX
					SRL->RL_CIDEX := SA2->A2_CIDEX
					SRL->RL_ESTEX := SA2->A2_ESTEX
					SRL->RL_TELEX := SA2->A2_TELRE
					SRL->RL_BREEX := SA2->A2_BREEX
					SRL->RL_TPREX := SA2->A2_TPREX
					SRL->RL_TRBEX := SA2->A2_TRBEX
					If !lTemNIF
						If SA2->A2_MOTNIF == "1"                                                                         
							SRL->RL_BEDINI := "1" //Fornecedor dispensado do NIF   
							SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
						Elseif SA2->A2_MOTNIF == "2"             
							SRL->RL_PAEXNI := "2" //País do fornecedor nao exige NIF   
						Endif
					Else
						SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
					Endif
				EndIf
				SRL->(MsUnlock())
				ConfirmSx8()
			Endif
			Reclock("SR4", .T.)
			SR4->R4_FILIAL  := xFilial("SR4")
			SR4->R4_MAT     := aRendimentos[nX,12]
			SR4->R4_CPFCGC  := aRendimentos[nX,3]
			SR4->R4_MES     := aRendimentos[nX,4]
			SR4->R4_TIPOREN := cTpRen
			SR4->R4_CODRET  := aRendimentos[nX,5]
			SR4->R4_ANO  := aRendimentos[nX,6]
			SR4->R4_ORIGEM := "2"

			If  !Empty(SRL->RL_PAIS)
				SR4->R4_PAIS := SRL->RL_PAIS
				SR4->R4_NIFEX := SRL->RL_NIFEX
				SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
				If lISNIF
					SR4->R4_ISNIF :=  IIF(aRendimentos[nX,14],"1","2")
				EndIf
			EndIf

			If lFa401Cmp
				// Utilizado para gravar campos complementares do SR4
				ExecBlock("FA401CMP", .F.,.F.)
			Endif
		Else
			Reclock("SR4", .F.)
		Endif

		SR4->R4_VALOR += aRendimentos[nX,7]

		SR4->(MsUnlock())

		// Processa gravacao dos titulos que geraram este acumulo na SR4
		If lGerLog
			nPosLog := aScan( aDadosLog, { |x| x[1] + Alltrim(x[12])+ x[2] == aRendimentos[nX,3] + Alltrim(aRendimentos[nX,13]) + aRendimentos[nX,5] } )
			If nPosLog > 0
				For nY := nPosLog To Len(aDadosLog)
					cChaveAnt := ( aDadosLog[nPosLog,1] +aDadosLog[nPosLog,12]+ aDadosLog[nPosLog,2] )
					If cChaveAnt != ( aDadosLog[nY,1] +aDadosLog[nY,12]+ aDadosLog[nY,2] )
						Exit
					EndIf
					Fa401AddLog(	@aLog, lGerLog,;
				                aDadosLog[ nY, 1 ], aDadosLog[ nY, 2 ], aDadosLog[ nY, 3 ], aDadosLog[ nY, 4 ],;
								aDadosLog[ nY, 5 ], aDadosLog[ nY, 6 ], aDadosLog[ nY, 7 ], aDadosLog[ nY, 8 ],;
								aDadosLog[ nY, 9 ], aDadosLog[ nY, 10], aDadosLog[ nY, 11], aDadosLog[ nY, 12],;
								aDadosLog[ nY, 13], aDadosLog[ nY, 14], aDadosLog[ nY, 15], aDadosLog[ nY, 16])
								
				Next nY
			EndIf
		EndIf
	Endif
	cChaveAnt	:= (aRendimentos[nX,3] + aRendimentos[nX,13] + aRendimentos[nX,5])
Next

// Restauro a filial do sistema quando processar com filial centralizadora
If !Empty(MV_PAR06)
	cFilAnt := cFilAtu
Endif
(cAliasTrb)->(DbCloseArea())

Fa401SImpDtUptDirf(cNotIn,lQuery,cAbatim,cImpostos,lReproc,cFornUniao,nX,cCondicao,bWhile,bFor,cCampo)

Return Nil


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ VerIRBx      ³ Autor ³                       ³ Data ³ 11/07/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Ver se tem IR Baixado em outro mês   						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA401                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VerIRBx( cPrefixo , cNum , cParcIR , cParInss , dDtFin)
Local lRet := .F.
Local aArea		:= GetArea()
Local aAreaSE2 	:= SE2->(GetArea())
Local cLojaImp	:= PadR( "00", TamSX3( "A2_LOJA" )[1], "0" )
Local cFornUniao:= Padr( Alltrim( GetMv( 'MV_UNIAO' ) ) , Len( SE2->E2_FORNECE ) ) + cLojaImp
Local cFornInss := PADR( Alltrim( StrTran( cMVINSNAT , '"' , '' )) , LEN(SE2->E2_FORNECE) ) + cLojaImp

SE2->(DbSetOrder(1))

If !Empty( cParcIR )
	If SE2->( DbSeek( xFilial("SE2") + cPrefixo + cNum + cParcIR + MVTAXA + cFornUniao ))
		If SE2->E2_BAIXA <> CtoD( "" )
			lRet := .T.
		EndIf
	EndIf
Endif

If !lRet .And. !Empty( cParInss )
	If SE2->( DbSeek( xFilial("SE2") + cPrefixo + cNum + cParInss + MVTAXA + cFornInss ))
		If SE2->E2_BAIXA <> CtoD( "" )
			lRet := .T.
		EndIf
	EndIf
Endif

RestArea(aAreaSE2)
RestArea(aArea)

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fa401ZRINSS ºAutor  ³Adrianne Furtado  º Data ³  04/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Processa todos os fornecedores da DIRF e caso encontre     º±±
±±º          ³ casos em que o fornecedor nao reteve IR e o somatório dos  º±±
±±º          ³ rendimentos tributáveis seja inferior a 6000, zera toda a  º±±
±±º          ³ coluna de rendimentos tributáveis, conforme orientação da  º±±
±±º          ³ nossa acessoria jurídica - Liz                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa401ZRINSS(aLog)

Local cQuery := ""
Local aRecnos := {}
Local nX
Local cAnoIni := STRZERO(YEAR (MV_PAR02),4)
Local cAnoFim := STRZERO(YEAR (MV_PAR03),4)
Local lGerLog	:= (MV_PAR07 == 1)
Local nScanLog := 0
Local cFilSA2	:= xFilial("SA2")
Local aAreaSA2 := SA2->(GetArea())
Local nI

cQuery := "SELECT R4_FILIAL, R4_MAT, R4_CPFCGC, R4_ANO, R4_TIPOREN, R4_CODRET "
cQuery += "FROM " + RetSQLname("SR4") + " SR4 "
cQuery += " WHERE "
cQuery += "R4_TIPOREN = 'A' AND "
cQuery += "R4_ANO between '"+ cAnoIni+"' AND '"+ cAnoFim +"' AND "
cQuery += "D_E_L_E_T_ = ' ' AND "
//filtro para nao levar registros que tenham equivalentes referente a IR (TIPOREN = "D")
cQuery += "NOT EXISTS(SELECT B.R4_CPFCGC, B.R4_MAT, B.R4_CODRET, B.R4_TIPOREN FROM "+ RetSQLname("SR4")+ " B "
cQuery += 			 "WHERE  B.R4_FILIAL = SR4.R4_FILIAL AND "
cQuery +=					"B.R4_CPFCGC = SR4.R4_CPFCGC AND "
cQuery +=					"B.R4_MAT	 = SR4.R4_MAT AND "
cQuery +=					"B.R4_ANO	 = SR4.R4_ANO AND "
cQuery +=					"B.R4_CODRET = SR4.R4_CODRET AND "
cQuery +=					"B.R4_TIPOREN = 'D' AND "
cQuery +=					"B.D_E_L_E_T_ = '' ) AND "
cQuery +="EXISTS(SELECT C.R4_CPFCGC, C.R4_MAT, C.R4_CODRET, C.R4_TIPOREN FROM "+ RetSQLname("SR4")+ " C "
cQuery += 			 "WHERE  C.R4_FILIAL = SR4.R4_FILIAL AND "
cQuery +=					"C.R4_CPFCGC = SR4.R4_CPFCGC AND "
cQuery +=					"C.R4_MAT	   = SR4.R4_MAT AND "
cQuery +=					"C.R4_ANO	   = SR4.R4_ANO AND "
cQuery +=					"C.R4_CODRET = SR4.R4_CODRET AND "
cQuery +=					"C.R4_TIPOREN = 'B' AND "
cQuery +=					"C.D_E_L_E_T_ = '' ) "
cQuery +="GROUP BY R4_MAT, R4_CPFCGC, R4_CODRET, R4_TIPOREN, R4_ANO, R4_FILIAL "
cQuery +="HAVING SUM(R4_VALOR) < 6000 "
cQuery := ChangeQuery(cQuery)

If lFA401SR4
	cQuery := ExecBlock("FA401SR4",.F.,.F.,{cQuery})
Endif

dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBZRINS",.F.,.T.)

/*	For nX := 1 to Len(aStruSR4)
If aStruSR4[nX,2] != 'C' .and. FieldPos(aStruSR4[nX,1]) > 0
	TCSetField("TRBZRINS", aStruSR4[nX,1], aStruSR4[nX,2],aStruSR4[nX,3],aStruSR4[nX,4])
Endif
Next
*/
SA2->(DbSetOrder(3)) //A2_FILIAL+A2_CGC
dbSelectArea("TRBZRINS")
While !(TRBZRINS->(Eof()))
	//zera os rendimentos tributáveis
	//apagar o registro que tem TIPOREN = "A "
	SR4->(DbSetOrder(1))
	SR4->(DbSeek(TRBZRINS->(R4_FILIAL + R4_MAT + R4_CPFCGC + R4_CODRET + R4_ANO)))
	SA2->(MsSeek(cFilSA2+TRBZRINS->R4_CPFCGC))
	While SR4->(R4_FILIAL + R4_MAT + R4_CPFCGC + R4_CODRET + R4_ANO) == ;
			TRBZRINS->(R4_FILIAL + R4_MAT + R4_CPFCGC + R4_CODRET + R4_ANO)
		If AllTrim(SR4->R4_TIPOREN) == "A"
			Aadd(aRecnos,SR4->(Recno()))
		EndIf
		SR4->(DbSkip())
	EndDo

	//zera as contribuições previdenciarias
	//apagar o registro que tem TIPOREN = "B "
	For nX := 1 to Len(aRecnos)
		SR4->(DbGoTo(aRecnos[nX]))
		cChINSS := SR4->(R4_FILIAL + R4_MAT + R4_CPFCGC + R4_CODRET + R4_ANO)
		SR4->(DbSeek(cChINSS))
		While SR4->(R4_FILIAL + R4_MAT + R4_CPFCGC + R4_CODRET + R4_ANO) == cChINSS
			If AllTrim(SR4->R4_TIPOREN) <> "A"
				Aadd(aRecnos,SR4->(Recno()))
			EndIf
			SR4->(DbSkip())
		EndDo
	Next nX

	For nX := 1 to Len(aRecnos)
		SR4->(DbGoTo(aRecnos[nX]))
		If lGerLog
			cChaveTit := SR4->(R4_CPFCGC+R4_CODRET+R4_MES+AllTrim(R4_TIPOREN))
			nScanLog := AScan( aLog, { |x| Alltrim(x[1] + x[2] + x[3] + x[4]) == Alltrim(cChaveTit) } )
			If nScanLog > 0
				For nI:= 1 To Len(aLog)
					If aLog[nI,1] + aLog[nI,2] + aLog[nI,3] + aLog[nI,4] = cChaveTit
						// o ideal era corrigir a gravacao do log para ficar tudo dentro do mesmo padrao
						// mas por segurança fiz assim.
						// qdo tiver oportunidade, fazer a alteracao mais adequada.
						//Fa401EdtLog( @aLog, lGerLog, nScanLog, LOG_VALOR, 0, "=" )
						Fa401EdtLog( @aLog, lGerLog, nI, LOG_VALOR, 0, "=" )
					Endif
				Next
			ElseIf nScanLog = 0
				cChaveTit := SR4->(R4_CPFCGC+R4_CODRET+R4_MES+R4_TIPOREN)
				//zera E2_DTDIRF
				nScanLog := AScan( aLog, { |x| x[1] + x[2] + x[3] + x[4] == cChaveTit } )
			Endif
		EndIf
		RecLock("SR4",.F.)
		dBDelete()
		SR4->(MsUnLock())
	Next nX
	LmpDtDirf()
	aRecnos := {}
	TRBZRINS->(DbSkip())
EndDo
TRBZRINS->(dbCloseArea())
RestArea(aAreaSA2)

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401AddLog ºAutor ³ Gustavo Henrique º Data ³  29/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Adiciona dados do titulo no vetor de log para posterior    º±±
±±º          ³ impressao do relatorio e geracao do arquivo de log (.CSV)  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPA01 - Array com os dados dos titulos                    º±±
±±º          ³ EXPL02 - Indicar se deve gerar log de acordo com a perguntaº±±
±±º          ³         "Gera Log de Processamento?" (MV_PAR07)            º±±
±±º          ³ EXPC03 - CNPJ/CPF do fornecedor                            º±±
±±º          ³ EXPC04 - Codigo de retencao do titulo                      º±±
±±º          ³ EXPC05 - Mes em que o titulo sera gerado na DIRF           º±±
±±º          ³ EXPC06 - Tipo de retencao                                  º±±
±±º          ³ EXPC07 - Filial do titulo                                  º±±
±±º          ³ EXPC08 - Prefixo                                           º±±
±±º          ³ EXPC09 - Numero                                            º±±
±±º          ³ EXPC10 - Parcela                                           º±±
±±º          ³ EXPC11 - Tipo                                              º±±
±±º          ³ EXPC12 - Natureza                                          º±±
±±º          ³ EXPC13 - Valor                                             º±±
±±º          ³ EXPC14 - Numero NIFEX                                      º±±
±±º          ³ EXPC15 - A2_COD                                            º±±
±±º          ³ EXPC16 - A2_LOJA                                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401AddLog( aLog, lGerLog, cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit,;
								cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor,cNIFEX,cCodFor, cLoja, cFilFor , cNomeFor  )

Local aArea		:= GetArea()
Local aAreaSR4	:= SR4->(GetArea())
Local aAreaSED	:= SED->(GetArea())
Local cChaveTit	:= ""
Local lGravRend	:= .F.
Local cMV_INSS	:= GetMv("MV_INSS")
 
Default aLog	 := {}
Default lGerLog	 := .F.
Default cNIFEX	 := ""
Default cCodFor	 := SA2->A2_COD
Default cLoja	 := SA2->A2_LOJA
Default cFilFor  := SA2->A2_FILIAL 
Default cNomeFor := SA2->A2_NOME 

cNIFEX := Alltrim(cNIFEX)

Iif( TYPE("cAno") == "U" , cAno := SR4->R4_ANO , NIL )

If !SR4->( dbSeek( xFilial("SR4") + SRL->RL_MAT + Padr(cCPFCGC,Len(SR4->R4_CPFCGC)) + cCodRet + cAno + cMes + padr(cTipoRen,nTamTpRen) + SRL->RL_PAIS + cNIFEX) )
	lGravRend := .T.
Endif

If lGerLog
	// Somente inclui o titulo se nao existir no vetor de log
	cChaveTit	:= cCPFCGC + cCodRet + cMes + cTipoRen + cFilTit + cPrefixo + cNum + cParcela + cTipo + cNatureza + cNIFEX
	If AScan( aLog, { |x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] + x[12] == cChaveTit } ) == 0
		If cTipoRen == "A" .or. cTipoRen == "I2" .or. cTipoRen == "I3"
			If lGravRend
				AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja } )
			ElseIf nValor == SR4->R4_VALOR
				AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja  } )
			ElseIf !lGravRend .and. (AllTrim(cNatureza)$cMV_INSS .or. Posicione("SED",1,xfilial("SED") + cNatureza,"ED_CALCINS") = "S")
				AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja  } )
			ElseIf IsInCallStack("Fa401SemRet") .Or. IsInCallStack("Fa401SemImp")
				AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja  } )
			Else
				AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja  } )
			Endif
		Else
			AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja  } )
		Endif
	EndIf
	
	If MV_PAR04 == 1 .and. Empty(cCPFCGC) 
		If aScan(aEmptyCPF,{|x| x[1] + x[2] + x[3]  == cFilFor + cCodFor + cLoja  }) == 0
			aAdd(aEmptyCPF, {cFilFor , cCodFor , cLoja ,  cNomeFor,SA2->(Recno()) })	
		EndIf		
	EndIf
EndIf

RestArea(aAreaSED)
RestArea(aAreaSR4)
RestArea(aArea)

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401EdtLog ºAutor ³ Gustavo Henrique º Data ³  29/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Edita valores do jah existentes no log. Possibilita somar  º±±
±±º          ³ ou modificar valores.									  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPA1 - Array com os dados dos titulos                     º±±
±±º          ³ EXPL2 - Indicar se deve gerar log de acordo com a pergunta º±±
±±º          ³         "Gera Log de Processamento?" (MV_PAR07)            º±±
±±º          ³ EXPN3 - Linha no vetor de log (titulo)                     º±±
±±º          ³ EXPN4 - Coluna na linha encontrada no log (dado do titulo) º±±
±±º          ³ EXPU5 - Dado a ser somado ou atribuido na posicao          º±±
±±º          ³ EXPL6 - Indica a operacao que deve ser realizada:          º±±
±±º          ³         "=" - Atribuicao de conteudo caracter ou valor     º±±
±±º          ³         "+" - Acrescenta ao conteudo da posicao            º±±
±±º          ³         "-" - Subtrai do conteudo da posicao               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401EdtLog( aLog, lGerLog, nPosLog, nPosEdt, xConteudo, cOper )

Local aArea		:= GetArea()
Local aAreaSR4	:= SR4->(GetArea())
Local aAreaSED	:= SED->(GetArea())

Default aLog	:= {}
Default lGerLog	:= .F.
Default cOper	:= "="

If lGerLog .And. nPosLog > 0 .And. nPosEdt > 0
	If cOper == "+" .or. cOper == "||" .or. "CONCAT"$cQryConcat
		If cTipoP=="1"
			If !SR4->( dbSeek (cChavePF) )
				aLog[ nPosLog, nPosEdt ] += xConteudo
			Endif
		Else
			aLog[ nPosLog, nPosEdt ] += xConteudo
		Endif
	ElseIf cOper == "="
		aLog[ nPosLog, nPosEdt ] := xConteudo
	ElseIf cOper == "-"
		aLog[ nPosLog, nPosEdt ] -= xConteudo
	EndIf
EndIf

RestArea(aAreaSED)
RestArea(aAreaSR4)
RestArea(aArea)

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401ImpLog º Autor ³ Gustavo Henriqueº Data ³  19/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Imprimir relatorio com o log dos titulos processados na    º±±
±±º          ³ geracao dos valores da DIRF                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPA1 - Vetor com os titulos a serem impressos no relatorioº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401ImpLog( aLog, cArqLog )

Local aImpLog	:= {}
Local aLogTitle	:= {}
Local aTotMes	:= { 0, 0, 0, 0, 0, 0}
Local nX		:= 0
Local cCGCCPF	:= ""
Local cCodRet	:= ""
Local cMes		:= ""
Local cTipoRen	:= ""
Local cSep		:= Space( 2 )
Local cPictVal	:= PesqPict( "SE2", "E2_VALOR", TAM_VALOR )



// Estrutura do vetor aLog
//
// aLog[ 01 ] - CPF/CGC do fornecedor do titulo
// aLog[ 02 ] - Codigo de retencao do titulo informado no cadastro
// aLog[ 03 ] - Numero do mes que o valor foi gerado na DIRF
// aLog[ 04 ] - Tipo de Retencao:
//				A-Rendimento Tributavel;
//				D-Imposto Retido;
//				B-Contrib. Previdenciaria;
//				I-Outros Nao Tributavel;
//				T-Dependentes
// aLog[ 05 ] - Filial
// aLog[ 06 ] - Prefixo
// aLog[ 07 ] - Numero
// aLog[ 08 ] - Parcela
// aLog[ 09 ] - Tipo
// aLog[ 10 ] - Valor

aSort( aLog,,,{ |x,y| x[1] + x[12] + x[2] + x[3] + x[4] < y[1] + y[12] + y[2] + y[3] + y[4] } )

AAdd( aLogTitle,	PadR( STR0011, TAM_FIL	 	) + cSep +;		// Filial
  					PadR( STR0012, TAM_PREF	 	) + cSep +;		// Prefixo
  					PadR( STR0013, TAM_NUM	 	) + cSep +;		// Numero
  					PadR( STR0014, TAM_PARC	 	) + cSep +;		// Parcela
  					PadR( STR0015, TAM_TIPO  	) + cSep +;		// Tipo
  					PadR( STR0016, TAM_NAT  	) + cSep +;		// Natureza
  					PadL( STR0017, TAM_VALOR	) + cSep +;		// Rendimentos Trib. 	"A"
  					PadL( STR0018, TAM_VALOR	) + cSep +;		// Contrib. Previd.		"B"
  					PadL( STR0019, TAM_VALOR	) + cSep +;		// Val.Dependentes		"T"
  					PadL( STR0020, TAM_VALOR	) + cSep +;		// Imposto Retido		"D"
					PadL( STR0053, TAM_VALOR	) + cSep +;		// Dedução simplificada	"B4"
  					PadL( STR0021, TAM_VALOR	) )        		// Outros Não Trib.		"I"

Fa401ImpCab( @aImpLog, aLog[1,1], aLog[1,2], aLog[1,3],,,aLog[1,12], aLog[1,13],aLog[1,14] )

cCGCCPF	:= aLog[1,1]+aLog[1,12]
cCodRet	:= aLog[1,2]
cMes	:= aLog[1,3]

For nX := 1 to Len( aLog )

	// Quebrou por Fornecedor
	If	cCGCCPF != aLog[nX,1]+aLog[nX,12]

		Fa401ImpTot( STR0022 + " " + MesExtenso( Val( cMes ) ) + " : ", cSep, cPictVal, @aTotMes, @aImpLog )	// Total

		Fa401ImpCab( @aImpLog, aLog[nX,1], aLog[nX,2], aLog[nX,3],,,aLog[nX,12],aLog[nX,13], aLog[nX,14] )

		cCGCCPF := aLog[nX,1]+aLog[nX,12]
		cCodRet := aLog[nX,2]
		cMes	:= aLog[nX,3]

	// Quebrou por Codigo de Retencao
	ElseIf cCodRet != aLog[nX,2]

		Fa401ImpTot( STR0022 + " " + MesExtenso( Val( cMes ) ) + " : ", cSep, cPictVal, @aTotMes, @aImpLog )	// Total

		Fa401ImpCab( @aImpLog, aLog[nX,1], aLog[nX,2], aLog[nX,3], .F.,,aLog[nX,12] ,aLog[nX,13], aLog[nX,14])

		cCodRet := aLog[nX,2]
		cMes	:= aLog[nX,3]

	// Quebrou por Mes
	ElseIf cMes != aLog[nX,3]

		Fa401ImpTot( STR0022 + " " + MesExtenso( Val( cMes ) ) + " : ", cSep, cPictVal, @aTotMes, @aImpLog )	// Total

		Fa401ImpCab( @aImpLog, aLog[nX,1], aLog[nX,2], aLog[nX,3], .F., .F., aLog[nX,12],aLog[nX,13], aLog[nX,14])

		cMes := aLog[nX,3]

	EndIf

	cTipoRen := AllTrim( aLog[nX,4] )

	AAdd( aImpLog,	PadR( aLog[nX,5] , TAM_FIL	) + cSep +;
					PadR( aLog[nX,6] , TAM_PREF	) + cSep +;
					PadR( aLog[nX,7] , TAM_NUM	) + cSep +;
					PadR( aLog[nX,8] , TAM_PARC	) + cSep +;
					PadR( aLog[nX,9] , TAM_TIPO	) + cSep +;
					PadR( aLog[nX,10], TAM_NAT 	) + cSep +;
					PadR( Transform( IIf( cTipoRen == "A" .or. cTipoRen == "I2" .or. cTipoRen == "I3", aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep +;
					PadR( Transform( IIf( cTipoRen == "B", aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep +;
					PadR( Transform( IIf( cTipoRen == "T", aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep +;
					PadR( Transform( IIf( cTipoRen == "D", aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep +;
					PadR( Transform( IIf( cTipoRen == "B4", aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep +;
					PadR( Transform( IIf( cTipoRen == "I" , aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep )

	If cTipoRen == "A" .or. cTipoRen == "I2" .or. cTipoRen == "I3"
		aTotMes[1] += aLog[nX,LOG_VALOR]
	ElseIf cTipoRen == "B"
		aTotMes[2] += aLog[nX,LOG_VALOR]
	ElseIf cTipoRen == "T"
		aTotMes[3] += aLog[nX,LOG_VALOR]
	ElseIf cTipoRen == "D"
		aTotMes[4] += aLog[nX,LOG_VALOR]
	ElseIf cTipoRen == "B4"
		aTotMes[5] += aLog[nX,LOG_VALOR]
	ElseIf cTipoRen == "I"
		aTotMes[6] += aLog[nX,LOG_VALOR]
	EndIf

Next nX

Fa401ImpTot( STR0022 + " " + MesExtenso( Val( cMes ) ) + " : ", cSep, cPictVal, @aTotMes, @aImpLog, .F. )	// Total

// DIRF - Relacao de Titulos Processados - Arquivo
fMakeLog( { aImpLog }, aLogTitle, NIL, NIL, "DIRF" + DtoS(dDataBase), STR0023 + " (" + cArqLog + ")", "G", "L", , .F. )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401ImpCab ºAutor ³ Gustavo Henrique º Data ³  21/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Imprime cabecalho do relatorio de log dos titulos          º±±
±±º          ³ processados na geracao da DIRF                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPA1 - Vetor com as linhas a serem impressas no relatorio º±±
±±º          ³ EXPC2 - CGCCPF do fornecedor                               º±±
±±º          ³ EXPC3 - Codigo de retencao                                 º±±
±±º          ³ EXPA4 - Mes a ser impresso                                 º±±
±±º          ³ EXPL5 - Indicar se deve imprimir o cab. de fornecedor      º±±
±±º          ³ EXPL6 - Indicar se deve imprimir o cab. de cod. retencao   º±±
±±º          ³ EXPL7 - COdigo NIFEX, caso fornecedor exterior             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401ImpCab( aImpLog, cCGCCPF, cCodRet, cMes, lImpFor, lImpRet, cNIFEX, cCodFor, cLoja )

Local cPictCNPJ := ""
Local cNome := ""

Default lImpFor := .T.
Default lImpRet := .T.

If lImpFor
	If ! Empty( cCGCCPF ) .or. !Empty(cNIFEX)

		PosSA2Log(cCGCCPF,cNIFEX, cCodFor, cLoja, @cNome)

		cPictCNPJ := AllTrim( PicPes( If(SA2->A2_IRPROG == "1" .AND. LEN( ALLtrim(cCGCCPF))<= 11, "F", SA2->A2_TIPO) ) )
		cPictCNPJ := SubStr( cPictCNPJ, 1, ( Len( cPictCNPJ ) - 2 ) )
		Aadd( aImpLog, STR0024 + "  : " + AllTrim( SA2->A2_COD ) + " - " + AllTrim( cNome ) +;		// Fornecedor + CGC
						" - CNPJ/CPF: " + Transform( cCGCCPF, cPictCNPJ ) )
	Else
		Aadd( aImpLog, STR0024 + "  : ")	// Fornecedor
	EndIf
EndIf

If lImpRet
	Aadd( aImpLog, STR0025 + ": " + cCodRet )	// Cod.Retencao
EndIf

Aadd( aImpLog, STR0026 + "         : " + MesExtenso( Val( cMes ) ) )	// Mes
Aadd( aImpLog, "" )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401ImpTot ºAutor ³ Gustavo Henrique º Data ³  21/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Imprime total do relatorio de log de titulos processados   º±±
±±º          ³ na geracao da DIRF                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPC1 - Texto da linha de total;                           º±±
±±º          ³ EXPC2 - Separador (espacos)                                º±±
±±º          ³ EXPC3 - Picture para o valor impresso                      º±±
±±º          ³ EXPA4 - Vetor com os valores totalizados por tipo de       º±±
±±º          ³         retencao (R4_TIPOREN)                              º±±
±±º          ³ EXPA5 - Vetor com as linhas a serem impressas no relatorio º±±
±±º          ³ EXPA6 - Indicar se deve imprimir a linha continua          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401ImpTot( cTotal, cSep, cPictVal, aTotal, aImpLog, lImpLin )

Local bTabTotal	:= { |x| PadR( " ", ( TAM_FIL + TAM_PREF + TAM_NUM + TAM_PARC + TAM_TIPO + TAM_NAT + ( Len( cSep ) * 6 ) ) - x ) }

Default lImpLin	:= .T.

Aadd( aImpLog, 	"" )


Aadd( aImpLog,	cTotal + Eval( bTabTotal, Len( cTotal ) ) +;
				PadR( Transform( aTotal[1], cPictVal ), TAM_VALOR ) + cSep +;
				PadR( Transform( aTotal[2], cPictVal ), TAM_VALOR ) + cSep +;
				PadR( Transform( aTotal[3], cPictVal ), TAM_VALOR ) + cSep +;
				PadR( Transform( aTotal[4], cPictVal ), TAM_VALOR ) + cSep +;
				PadR( Transform( aTotal[5], cPictVal ), TAM_VALOR ) + cSep +;
				PadR( Transform( aTotal[6], cPictVal ), TAM_VALOR ) + cSep )

If lImpLin
	Aadd( aImpLog, 	Replicate( "-", 220 ) )
EndIf

aTotal := { 0, 0, 0, 0, 0, 0}

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401GerLog ºAutor ³ Gustavo Henrique º Data ³  21/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Gera arquivo de log em formato de planilha Excel (.CSV)    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPA1 - Vetor com os titulos processados que geraram DIRF  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401GerLog( aLog )

Local cPath		:= ""
Local cBarra	:= If( isSrvUnix(), "/", "\" )
Local cDirAnt   := CurDir()
Local cSeqArq	:= "01"
Local cArqLog	:= ""
Local cTexto	:= ""
Local cSep		:= ";"
Local cTipoRen	:= ""
Local cPictCNPJ := ""

Local aDirLog	:= {}
Local aX1Def 	:= {}

Local nHandle	:= 0
Local nX		:= 0
Local nValPerg	:= 0

Local lRet		:= .T.
Local cNome := ""

// Caso nao exista, cria pasta \DIRF para armazenamento do log.
cPath	:= GetSrvProfString("StartPath", "") + If( Right( GetSrvProfString("StartPath",""), 1 ) == cBarra, "", cBarra ) + "DIRF"
cArqLog	:= "DIRF" + DtoS(dDataBase) + cSeqArq + ".CSV"

aSort( aLog,,,{ |x,y| x[1] + x[12] + x[2] + x[3] + x[4] < y[1] + y[12] + y[2] + y[3] + y[4] } )

// Cria a pasta DIRF caso nao exista.
If !File( cPath )
	MakeDir(cPath)
EndIf

// Muda para pasta DIRF
CurDir( cPath )

// Se o arquivo de log jah existe, gera outro arquivo com nova sequencia inicial
If File(cArqLog)
	aDirLog := Directory( "DIRF" + AllTrim( Str( Year(dDataBase) ) ) + StrZero( Month(dDataBase), 2 ) + StrZero( Day(dDataBase), 2 ) + "??.CSV" )
	aSort( aDirLog,,,{|x,y| x[1] < y[1]} )
	cSeqArq := SubStr( aDirLog[ Len(aDirLog), 1 ], 1, At( ".", aDirLog[ Len(aDirLog), 1 ] ) -1 )
	cSeqArq := Soma1( Right( cSeqArq, 2 ) )
	cArqLog := "DIRF" + DtoS(dDataBase) + cSeqArq + ".CSV"
EndIf

// Tratamento para criacao do arquivo
If !File(cArqLog)
	nHandle := fCreate(cArqLog)
	If nHandle < 0
		nError := fError()
		// Nao foi possivel criar o arquivo de Log ### Erro numero:
		MsgAlert( STR0027 + cArqLog + ". " + STR0028 + PadR( Str(nError), 4 ) )
		lRet := .F.
	Else
		fClose(nHandle)
	EndIf
Endif

// Se conseguiu criar o arquivo, grava os dados do vetor aLog
If lRet

	nHandle := fOpen( cArqLog, 2 )
	fSeek( nHandle, 0, 2 )     // Posiciona no final do arquivo

    // Percorre o grupo de perguntas e grava no arquivo .CSV
	SX1->( dbSetOrder( 1 ) )
	SX1->( MsSeek( "FIN401" ) )

	Do While SX1->( ! EoF() .And. X1_GRUPO == PadR( "FIN401", Len( X1_GRUPO ) ) )

		cTexto := STR0029 + SX1->X1_ORDEM + ":" + cSep + SX1->X1_PERGUNT + cSep	// Pergunta

		If SX1->X1_TIPO == "D"
			cTexto += ToXLSFormat( DtoC( &( SX1->X1_VAR01 ) ) )
		ElseIf SX1->X1_GSC == "C"	// Combo box
			aX1Def   := { X1Def01(), X1Def02(), X1Def03(), X1Def04(), X1Def05() }
			nValPerg := &( SX1->X1_VAR01 )
			cTexto += ToXLSFormat( aX1Def[ nValPerg ] )
		Else
			cTexto += ToXLSFormat( &( SX1->X1_VAR01 ) )
		EndIf

		fWrite( nHandle, cTexto + Chr(13) + Chr(10), Len( cTexto ) + 2 )
		fSeek(  nHandle, 0, 2 )     // Posiciona no final do arquivo

		SX1->( dbSkip() )

	EndDo

	fWrite( nHandle, Chr(13) + Chr(10), 2 )
	fSeek(  nHandle, 0, 2 )     // Posiciona no final do arquivo

	// Grava titulo das colunas
	cTexto :=	STR0024 + cSep + "CNPJ/CPF"	+ cSep + STR0025 + cSep + STR0026 + cSep + STR0011 + cSep +;	// Fornecedor ### Cod.Retencao ### Mes ### Filial
				STR0012 + cSep + STR0013	+ cSep + STR0014 + cSep + STR0015 + cSep + STR0016 + cSep +;	// Prefixo ### Numero ### Parcela ### Tipo ### Natureza
				STR0017	+ cSep + STR0018	+ cSep + STR0019 + cSep + STR0020 + cSep + STR0021	// Rendimentos Trib. ### Contrib. Previd. ### Val.Dependentes
																								// Imposto Retido ### Outros Nao Trib.

	fWrite( nHandle, cTexto + Chr(13) + Chr(10), Len(cTexto) + 2 )
	fSeek(  nHandle, 0, 2 )     // Posiciona no final do arquivo

	cCGCCPF	:= aLog[1,1]+aLog[1,12]
	cCodRet	:= aLog[1,2]
	cMes	:= aLog[1,3]

	// Realiza a gravação dos dados do array no arquivo .CSV
	For nX := 1 To Len( aLog )

 		cTexto := ""

		If	cCGCCPF != aLog[nX,1]+aLog[nX,12] .Or. cCodRet != aLog[nX,2] .Or. cMes != aLog[nX,3]
			cCGCCPF	:= aLog[nX,1]+aLog[nX,12]
			cCodRet	:= aLog[nX,2]
			cMes	:= aLog[nX,3]
			cTexto  += CRLF
		EndIf

		cTipoRen := AllTrim( aLog[nX,4] )

		If !Empty( aLog[ nX, 1 ] + aLog[nX,12] )

			PosSA2Log(aLog[ nX, 1 ],aLog[nX,12],aLog[nX,13],aLog[nX,14],@cNome)
			cTexto		+= RTrim(SA2->A2_COD) + " - " + cNome + cSep
			cPictCNPJ   := AllTrim( PicPes( If(SA2->A2_IRPROG == "1", "F", SA2->A2_TIPO) ) )
			cPictCNPJ	:= SubStr( cPictCNPJ, 1, ( Len( cPictCNPJ ) - 2 ) )
		Else
			cTexto += cSep
		EndIf

		cTexto += 	Iif( !Empty( aLog[nX, 1] ), Transform( aLog[nX,1], cPictCNPJ ), " " ) + cSep +;
					ToXLSFormat( aLog[nX, 2] )	+ cSep + ToXLSFormat( MesExtenso( aLog[nX, 3] ) ) + cSep +;
					ToXLSFormat( aLog[nX, 5] )	+ cSep + ToXLSFormat( aLog[nX, 6] ) + cSep + ToXLSFormat( aLog[nX, 7] ) + cSep +;
					ToXLSFormat( aLog[nX, 8] )	+ cSep + ToXLSFormat( aLog[nX, 9] ) + cSep + ToXLSFormat( aLog[nX,10] ) + cSep +;
					ToXLSFormat( IIf( cTipoRen == "A" .or. cTipoRen == "I2" .or. cTipoRen == "I3", aLog[nX,LOG_VALOR], 0 ) ) + cSep +;
					ToXLSFormat( IIf( cTipoRen == "B", aLog[nX,LOG_VALOR], 0 ) ) + cSep +;
					ToXLSFormat( IIf( cTipoRen == "T", aLog[nX,LOG_VALOR], 0 ) ) + cSep +;
					ToXLSFormat( IIf( cTipoRen == "D", aLog[nX,LOG_VALOR], 0 ) ) + cSep +;
					ToXLSFormat( IIf( cTipoRen == "I", aLog[nX,LOG_VALOR], 0 ) )

		fWrite( nHandle, cTexto + Chr(13) + Chr(10), Len( cTexto ) + 2 )
		fSeek(  nHandle, 0, 2 )     // Posiciona no final do arquivo

	Next nX

	fClose( nHandle )

EndIf

// Volta para pasta \system
CurDir( cBarra + cDirAnt )

Return( cArqLog )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA401   ºAutor  ³Microsiga           º Data ³  02/04/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LmpDtDirf()
//só para limpar os DtDIrf dos titulos que tiveram INSS + rendimento zerado.

Local cQuery := ""
Local cAliasTrb := GetNextAlias()

cQuery := "SELECT "
cQuery += "SE2.E2_FILIAL, SE2.E2_FORNECE, SE2.E2_LOJA, SE2.E2_VENCREA, SE2.E2_PREFIXO, "
cQuery += "SE2.E2_NUM, SE2.E2_PARCELA, SE2.E2_TIPO, SE2.E2_BAIXA, SE2.E2_EMIS1, SE2.E2_PARCINS, "
cQuery += "SE2.E2_VENCTO, SE2.E2_INSS, SE2.R_E_C_N_O_ "
cQuery += " FROM " + RetSqlName("SE2") +" SE2 "
cQuery += " WHERE SE2.E2_FILIAL = '" + xFilial("SE2") + "'"
cQuery += "   AND SE2.E2_DIRF IN ('1','S')"
cQuery += "   AND SE2.E2_CODRET != ' '"
cQuery += "   AND SE2.E2_DTDIRF != ' '"
//vou trazer só os pais, os TX de inss procuro a partir do pai
cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVINSS+"|"+"INA","|") +" "
cQuery += " AND SE2.E2_FORNECE = '" + SA2->A2_COD +"'"


If MV_PAR05 == 2 .OR. MV_PAR01 == 1
	cQuery += " AND SE2.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "'"
	cQuery += " AND SE2.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "'"
ElseIf MV_PAR05 == 2 .OR. MV_PAR01 == 5
	cQuery += " AND SE2.E2_EMISSAO >= '" + Dtos(MV_PAR02) + "'"
	cQuery += " AND SE2.E2_EMISSAO <= '" + Dtos(MV_PAR03) + "'"
else  //pelo titulo principal
	Do Case
	Case MV_PAR01 == 2// Vencimento
		cQuery += " AND SE2.E2_VENCTO >= '" + Dtos(MV_PAR02) + "'"
		cQuery += " AND SE2.E2_VENCTO <= '" + Dtos(MV_PAR03) + "'"
	Case MV_PAR01 == 3 //Vencimento real
		cQuery += " AND SE2.E2_VENCREA >= '" + Dtos(MV_PAR02) + "'"
		cQuery += " AND SE2.E2_VENCREA <= '" + Dtos(MV_PAR03) + "'"
	Case MV_PAR01 == 4 //Data de Baixa
		cQuery += " AND ((SE2.E2_BAIXA >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += "       SE2.E2_BAIXA <= '" + Dtos(MV_PAR03) + "' ) OR"
		cQuery += "      (SE2.E2_BAIXA = ' ' AND "
		cQuery += "       SE2.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " 		SE2.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "' ) ) "
	EndCase
EndIF

cQuery += " AND SE2.D_E_L_E_T_ = ' '"

cQuery := ChangeQuery(cQuery)

dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTrb,.F.,.T.)
/*
		For ni := 1 to Len(aStru)
			If aStru[ni,2] != 'C' .and. FieldPos(aStru[ni,1]) > 0
				TCSetField(cAliasTrb, aStru[ni,1], aStru[ni,2],aStru[ni,3],aStru[ni,4])
			Endif
		Next
*/
SE2->(DBSetOrder(1))
While !(cAliasTrb)->(Eof())
	//		grava dtdirf do pai
	SE2->(DbSeek((cAliasTrb)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	RecLock("SE2")
	SE2->E2_DTDIRF := Ctod("  /  /  ")
	SE2->(MsUnlock())
	If (cAliasTrb)->E2_INSS <> 0
		SE2->(DbSeek((cAliasTrb)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCINS)))
		RecLock("SE2",.F.)
		SE2->E2_DTDIRF := Ctod("  /  /  ")
		SE2->(MsUnlock())
	EndIf
	(cAliasTrb)->(DbSkip())
EndDo

(cAliasTrb)->(DbCloseArea())

Return



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA401   ºAutor  ³Microsiga           º Data ³  02/06/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function WrDtDirf(aRecno, cIndex)
Local nX, nY := 0

dbSelectArea("SE2")
dbSetOrder(1)

// Atualiza o flag de geracao da DIRF.
For nX := 1  To Len(aRecno)
	cRecno := ""

	// Monta a string limitando a 500 registros por vez
	For nY := nX To (499+nX)
		If nY > Len(aRecno)
			Exit
		Endif
		cRecno += Alltrim(Str(aRecno[nY],20))+","
	Next

	// Atualiza o flag de geracao da DIRF para nao gerar novamente em novo processamento.
	cQuery := "UPDATE "
	cQuery += RetSqlName("SE2")+" "
	cQuery += "SET E2_DTDIRF = '" + Dtos(dDataBase) + "'"
	cQuery += " WHERE R_E_C_N_O_ IN ("+SubStr(cRecno,1,rat(",",cRecno)-1)+") AND "
	cQuery += "D_E_L_E_T_ = ' ' "

	TcSqlExec(cQuery)

	nX := nY
Next

Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³FinAtuSXD ³ Autor ³ Totvs	³ Data ³ 27/03/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao de processamento da gravacao do SXD                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³ Uso      ³FINA401                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FinTamSXG(cGrupo,nTamPad)
Local aRet

DbSelectArea("SXG")
DbSetOrder(1)

IF DbSeek(cGrupo)
	aRet := TamSXG(cGrupo)
Else
	aRet := {nTamPad,"@!",nTamPad,nTamPad}
Endif

Return aRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³F401PDesd ³ Autor ³ Adrianne              ³ Data ³ 19/10/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao de verificação de titulos PAI de desdobramento      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA401                                            			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function F401PDesd(cChave)
Local lPDesd := .F.
Local aArea := SE5->(GetArea())

SE5->(DbSetOrder(7))
If SE5->(DbSeek(xFilial("SE5")+cChave))
	While !lPDesd .and. SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == cChave
		If SE5->E5_MOTBX == 'DSD' .and. SE5->E5_SITUACA == " "
			lPDesd := .T.
		EndIf
		SE5->(DbSkip())
	EndDo
EndIf

RestArea(aArea)
Return lPDesd

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³IsTheLastPost ³ Autor ³ Adrianne Furtado  ³ Data ³ 13/01/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao de verificação de titulos PAI de desdobramento      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA401                                            			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsTheLastPost(cPrefixo,cNum,cParcela,cTipo,cFornece,cLoja)
Local lRet := .F.
Local cSeq := SE5->E5_SEQ
Local aAreaSE5 := GetArea("SE5")
Local cQuery

cQuery := "SELECT MAX(SE5.E5_SEQ) SEQMAX"
cQuery += " FROM " + RetSqlName("SE5") +" SE5 "
cQuery += " WHERE SE5.E5_FILIAL = '" + xFilial("SE5") + "' AND"
cQuery += "    	SE5.E5_RECPAG = 'P' AND "
cQuery += "    	SE5.E5_SITUACA != 'C' AND "
cQuery += "    	SE5.D_E_L_E_T_ = ' ' AND "
cQuery += "       SE5.E5_PREFIXO = '" + cPrefixo + "' AND"
cQuery += "       SE5.E5_NUMERO  = '" + cNum + "' AND"
cQuery += "       SE5.E5_PARCELA = '" + cParcela + "' AND"
cQuery += "       SE5.E5_TIPO = '" + cTipo + "' AND"
cQuery += "       SE5.E5_CLIFOR = '" + cFornece + "' AND"
cQuery += "       SE5.E5_LOJA = '" + cLoja + "' "
//cQuery += "ORDER BY SE5.E5_SEQ"

cQuery := ChangeQuery(cQuery)

dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"SEQUEN",.F.,.T.)


/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se a maior sequencia de baixa desse título for igual  ³
//³a sequencia que está sendo tratada, significa que é a ³
//³ultima baixa que ocorreu no título.                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
If SEQUEN->SEQMAX == cSeq
	lRet := .T.
EndIf

SEQUEN->(dbCloseArea())

RestArea(aAreaSE5)

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³f401CodUn ºAutor  ³Adrianne Furtado    º Data ³  20/01/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se esse título utiliza código único de retenção.   º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function f401CodUn(cAliasTrb,cAliasPai,aCRIN480)
Local lRet := .F.
Local lIRPFBaixa := If(SA2->A2_CALCIRF == "2", .T., .F.)

//Carregar variaveis
//__lPccBaixa

If __lpccbaixa == nil
	F401PccBx()
EndIf

/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validação de uso do codigo de retenção único.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
If SA2->A2_TIPO $ 'J|X'
	/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄç
	//³Para PJ, haverá codigo único quando o código de retenção ³
	//³utilizado estiver no array de códigos únicos e houver    ³
	//³IR no título.                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
	If	aScan(aCRIN480,(cAliasTrb)->E2_CODRET) > 0
		lRet := .T.
	EndIf
Else //Pessoa Física
	/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Quando o PCC e o IR são na baixa.                   ³
	//³Os títulos de impostos da PF assumem o mesmo código ³
	//³de retenção.                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
	If lIRPFBaixa .and. __lPCCBaixa
		If SR4->( dbSeek (cChavePF) )
			lRet := .T.
		Endif
	EndIf
EndIf

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³IsCodResExt  ³ Autor ³ Adrianne Furtado  ³ Data ³ 22/02/11  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao retorna se o codigo utilizado é referente a residen-³±±
±±³          ³ te exterior.                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA401                                            			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsCodResExt(cCodRet)
Local aCodREx := {"0422","0490","0481","9453","9478","5286","0473","9412","9466","9427","5192"}
Local lRet := .F.

/* lista de códigos retirada do documento de layout da DIRF 2011/2010 diponibilizado pela receita
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ)
//³0422 Royalties e Pagamentos de Assistência Técnica            ³
//³0490 Aplicações em Fundos de Conversão de Débitos externos    ³
//³0481 Juros e Comissões em Geral                               ³
//³9453 Juros Sobre o Capital Próprio                            ³
//³9478 Aluguel e Arrendamento                                   ³
//³5286 Aplicações Financeiras/Entidades de Investimento Coletivo³
//³0473 Rendas e Proventos de Qualquer Natureza                  ³
//³9412 Fretes Internacionais                                    ³
//³9466 Previdência Privada e Fapi                               ³
//³9427 Remuneração de Direitos                                  ³
//³5192 Obras Audiovisuais                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ)
*/

If lF401REX
	aCodREx := ExecBlock("F401REX",.F.,.F.,{aCodREx})
EndIf

If Ascan(aCodREx,cCodRet)<>0
	lRet :=.T.
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FinGrvRCS ºAutor  ³Fabricio Pequeno    º Data ³  03/18/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para gravar a tabela RCS com informações para        º±±
±±º          ³rendimentos não tributáveis.                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FinGrvRCS(cTipoFJ,aTitulo,nNaoTributavel,cAliasTrb)

Local aArea		:= GetArea()
Local cDescri	:= " "

dbSelectArea("SED")
dbSetOrder(1)
If ( SED->(DbSeek(xFilial("SED")+AllTrim(NEWSE2->E2_NATUREZ))) )
	cDescri := AllTrim(SED->ED_DESCRIC)
EndIf

dbSelectArea("RCS")
dbSetOrder(1)
If( RCS->(DbSeek(xFilial("RCS")+SRL->RL_MAT+cTipoFJ+aTitulo[CNPJ]+aTitulo[CODIGORETENCAO]+SR4->R4_ANO+SR4->R4_TIPOREN)) )
	RecLock("RCS",.F.)
		dBDelete()
	MsUnLock()
EndIf
If!( RCS->(DbSeek(xFilial("RCS")+SRL->RL_MAT+cTipoFJ+aTitulo[CNPJ]+aTitulo[CODIGORETENCAO]+SR4->R4_ANO+SR4->R4_TIPOREN)) )
	RecLock("RCS",.T.)
		RCS->RCS_FILIAL		:= xFilial("RCS")
		RCS->RCS_MAT 		:= SRL->RL_MAT
		RCS->RCS_TIPOFJ		:= cTipoFJ
		RCS->RCS_CPFBEN		:= aTitulo[CNPJ]
		RCS->RCS_CODRET		:= aTitulo[CODIGORETENCAO]
		RCS->RCS_ANO		:= SR4->R4_ANO
		RCS->RCS_VERBA		:= SR4->R4_TIPOREN
		RCS->RCS_TIPORE		:= "I"
		RCS->RCS_NOME		:= SA2->A2_NOME
		RCS->RCS_CPFCGC		:= " "
		RCS->RCS_VALOR		:= nNaoTributavel
		RCS->RCS_DESCRI		:= cDescri //-- Conversado com equipe do SLA e definido o campo cDescri
		RCS->RCS_OUTROS		:= cDescri //-- para RCS_DESCRI e RCS_OUTROS.
		RCS->RCS_ORIGEM:= "2" //--ORIGEM LACTO: 1 FOL,2 FIN
	MsUnlock()
EndIf

RestArea(aArea)

Return Nil
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³PosSA2Log ºAutor  ³Adrianne Furtado    º Data ³  19/04/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para posicionar o SA2 no registro do fornecedor da   º±±
±±º          ³linha de log corrente.                                		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function PosSA2Log(cCGCCPF, cNIFEX, cCodFor, cLoja, cNome)
Local cAliasTmp

Default cNIFEX := ""
Default cLoja := ""
Default cCodFor := ""

cAliasTmp := GetNextAlias()

	If !Empty(cNIFEX)
		cQuery := "SELECT "
		cQuery += "SA2.A2_FILIAL, SA2.A2_COD, SA2.A2_LOJA, SA2.A2_CGC,SA2.A2_CPFIRP, "
		cQuery += "SA2.R_E_C_N_O_ RECSA2"
		cQuery += " FROM " + RetSqlName("SA2") +" SA2 "
		cQuery += " WHERE SA2.A2_FILIAL = '" + xFilial( "SA2" ) + "'"
		cQuery += " AND ( (SA2.A2_NIFEX != ' ' AND SA2.A2_NIFEX = '" + Alltrim(cNIFEX) + "') OR "
		cQuery += " ( SA2.A2_NIFEX = ' ' AND SA2.A2_COD || SA2.A2_LOJA = '" + Alltrim(cNIFEX) + "'))"
	  	cQuery += " AND SA2.D_E_L_E_T_ = ' '"
		cQuery += " ORDER BY A2_FILIAL, A2_COD, A2_LOJA"
		cQuery := ChangeQuery(cQuery)
	 	dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTmp,.F.,.T.)

		SA2->( DBGOTO( (cAliasTmp)->RECSA2 ) )
		cNome := SA2->A2_NOME
		(cAliasTmp)->(DbCloseArea())

	Else

		SA2->( dbSetOrder( 3 ) )
		If (!SA2->( MsSeek( xFilial( "SA2" ) + cCGCCPF ) ) )  //.OR.  LEN( ALLtrim(cCGCCPF))> 11
			//procurar no campo de CPF IR Progressivo
			cQuery := "SELECT "
			cQuery += "SA2.A2_FILIAL, SA2.A2_COD, SA2.A2_LOJA, SA2.A2_CGC,SA2.A2_CPFIRP, "
			cQuery += "SA2.R_E_C_N_O_ RECSA2"
			cQuery += " FROM " + RetSqlName("SA2") +" SA2 "
			cQuery += " WHERE "
			If LEN( ALLtrim(cCGCCPF))<= 11
				cQuery += " SA2.A2_CPFIRP	= '" + cCGCCPF +	"'"
			Else
				cQuery += " SA2.A2_CPFIRP	= ' ' "
				cQuery += " AND SA2.A2_CGC	= '" + cCGCCPF +	"'"
			Endif
			cQuery += " AND SA2.A2_COD	= '"+cCodFor+"'"
			cQuery += " AND SA2.A2_LOJA	= '"+cLoja+"'"
			cQuery += " AND SA2.A2_IRPROG	= '1'"
	  		cQuery += " AND SA2.D_E_L_E_T_ = ' '"
			cQuery += " ORDER BY A2_FILIAL, A2_COD, A2_LOJA"
			cQuery := ChangeQuery(cQuery)
	 		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTmp,.F.,.T.)

			SA2->( DBGOTO( (cAliasTmp)->RECSA2 ) )
			cNome := SA2->A2_NOME
			(cAliasTmp)->(DbCloseArea())

			If SA2->(Eof()) .or. SA2->(Bof())
				//procura o CGC sem filial na SA2
				cQuery := "SELECT "
				cQuery += "SA2.A2_FILIAL, SA2.A2_COD, SA2.A2_LOJA, SA2.A2_CGC,SA2.A2_CPFIRP, "
				cQuery += "SA2.R_E_C_N_O_ RECSA2"
				cQuery += " FROM " + RetSqlName("SA2") +" SA2 "
				cQuery += " WHERE "
				cQuery += " SA2.A2_CPFIRP	= ' ' "
				cQuery += " AND SA2.A2_CGC	= '" + cCGCCPF +	"'"
				cQuery += " AND SA2.A2_IRPROG	<> '1'"
			  	cQuery += " AND SA2.D_E_L_E_T_ = ' '"
				cQuery += " ORDER BY A2_FILIAL, A2_COD, A2_LOJA"
				cQuery := ChangeQuery(cQuery)
			 	dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTmp,.F.,.T.)

				SA2->( DBGOTO( (cAliasTmp)->RECSA2 ) )
				cNome := SA2->A2_NOME
				(cAliasTmp)->(DbCloseArea())

				// se ainda nao encontrou o CGC/CPF procura na  FKJ
				If lExistFKJ .and. SA2->(Eof()) .or. SA2->(Bof())
					cQuery := "SELECT "
					cQuery += "FKJ.FKJ_NOME, FKJ.FKJ_FILIAL, FKJ.FKJ_COD, FKJ.FKJ_LOJA  "
					cQuery += " FROM " + RetSqlName("FKJ") +" FKJ "
					cQuery += " WHERE "
					cQuery += " FKJ.FKJ_COD = '"+cCodFor+"'"
					cQuery += " AND FKJ.FKJ_LOJA = '"+cLoja+"'"
					cQuery += " AND FKJ.FKJ_CPF	= '" + cCGCCPF +	"'"
				  	cQuery += " AND FKJ.D_E_L_E_T_ = ' '"
					cQuery += " ORDER BY FKJ.FKJ_FILIAL, FKJ.FKJ_COD, FKJ.FKJ_LOJA"
					cQuery := ChangeQuery(cQuery)
				 	dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTmp,.F.,.T.)
					SA2->( dbSetOrder( 1 ) )
					SA2->( dbSeek(  (cAliasTmp)->FKJ_FILIAL +  (cAliasTmp)->FKJ_COD + (cAliasTmp)->FKJ_LOJA ) )
					cNome := (cAliasTmp)->FKJ_NOME

					(cAliasTmp)->(DbCloseArea())

				EndIf
			ElseIf lExistFKJ
				//se encontrou verifica se o CPF esta cadastrado na FKJ
				FKJ->( dbSetOrder( 1 ) ) //FKJ_FILIAL, FKJ_COD, FKJ_LOJA, FKJ_CPF, R_E_C_N_O_, D_E_L_E_T_
				If FKJ->(DBseek(SA2->(A2_FILIAL + A2_COD + A2_LOJA + A2_CPFIRP) ))
					cNome := FKJ->FKJ_NOME
				EndIf

			EndIf
		Else
			cNome := SA2->A2_NOME
		EndIf


	EndiF

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA401   ºAutor  ³Pamela Bernardo     º Data ³  11/30/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³   Função para definir o conteúdo do cMes                   º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function F401CMES(dDtIni,dDtFin,cMes,cCodRet,lReproc,cFilAtu)
Local cQuery	:= ""
Local cAlias := "SE2SED"
Local cFilAux := cFilAnt

//Caso a filial esteja como centralizadora, a filial é alterada para a que esteja sendo usada na query
If cFilAnt <> cFilAtu
	cFilAtu := cFilAnt
EndIf

If MV_PAR05 == 1
	cMes:=STRZERO(MONTH(dDtini),2)
Else

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³SELECIONA OS DADOS PARA PROCESSAMENTO                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	cQuery := c401QryMes
	cQuery += "   AND SE2.E2_FILIAL = '" + xFilial( "SE2" ) + "'"
	cQuery += "   AND SED.ED_FILIAL = '" + xFilial( "SED" ) + "'"
	cQuery += "   AND SE2.E2_FORNECE = '" + SA2->A2_COD + "'"
	cQuery += "   AND SE2.E2_LOJA = '" + SA2->A2_LOJA + "' "

	Do Case
		Case MV_PAR01 == 1 // Data de emissao digitada
			cQuery += " AND (( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_EMIS1 <= '" + Dtos(dDtFin) + "' ) OR "
		Case MV_PAR01 == 2// Vencimento
			cQuery += " AND (( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCTO <= '" + Dtos(dDtFin) + "' ) OR "
		Case MV_PAR01 == 3 //Vencimento real
			cQuery += " AND (( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCREA <= '" + Dtos(dDtFin) + "' ) OR "
		Case MV_PAR01 == 4 //Data de Baixa ³  MV_PAR01		 // Considera data
			cQuery += " AND (( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ((SE2.E2_BAIXA >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_BAIXA <= '" + Dtos(dDtFin) + "') OR "
			cQuery += "  (SE2.E2_BAIXA = ' ' AND "
			cQuery += "   SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_EMIS1 <= '" + Dtos(dDtFin)	+ "') ) ) OR "
		Case MV_PAR01 == 5 // Data de emissao real
			cQuery += " AND (( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMISSAO >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_EMISSAO <= '" + Dtos(dDtFin) + "' ) OR "
	EndCase

	Do Case
		Case MV_PAR09 == 1 // Data de emissao
			cQuery += " ( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_EMIS1 <= '" + Dtos(dDtFin) + "') )"
		Case MV_PAR09 == 2// Vencimento
			cQuery += " ( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCTO <= '" + Dtos(dDtFin) + "') )"
		Case MV_PAR09 == 3 //Vencimento real
			cQuery += " ( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCREA <= '" + Dtos(dDtFin) + "') )"
		Case MV_PAR09 == 4 //Data de Baixa ³  MV_PAR01		 // Considera data
			cQuery += " ( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND ((SE2.E2_BAIXA >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_BAIXA <= '" + Dtos(dDtFin) + "') )) )"
		Case MV_PAR09 == 5 //Data de Emissao Real
			cQuery += " ( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND ((SE2.E2_EMISSAO >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_EMISSAO <= '" + Dtos(dDtFin) + "') ))) "
	EndCase

	//O valor do rendimento tributavel sera calculado por codigo de retencao, portanto todas as notas que
	//não tiverem codigo de rentencao, não entrarao na somatoria do mês.
	cQuery += " AND SE2.E2_CODRET = '" + cCodRet + "'"

	// Se existir a data de processamento da DIRF, verifica se trata-se de reprocessamento
	If !lReproc
		// filtra os titulos que nao foram processados
		cQuery += "AND SE2.E2_DTDIRF = ' '"
	Endif

	If lF401Qry4
		cQuery := ExecBlock("F401Qry4",.F.,.F.,{cQuery})
	EndIf

	//cQuery := ChangeQuery(cQuery)

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), (cAlias), .F., .T.)

	dbSelectArea(cAlias)

	dbSelectArea("SE2")
	dbSetOrder(1)
	While !((cAlias)->(Eof()))

		If dbSeek(xFilial("SE2")+(cAlias)->(E2_PREFIXO+E2_NUM+E2_PARCIR)+"TX "+cUniao)

			Do Case
				Case MV_PAR01 == 1 .AND.  MV_PAR05 == 2
					If VAL(STRZERO(MONTH(SE2->E2_EMIS1),2))>=VAL(cMes)+1
							cMes:=STRZERO(MONTH(SE2->E2_EMIS1),2)
					EndIf
				Case MV_PAR01 == 2 .AND.  MV_PAR05 == 2
				If VAL(STRZERO(MONTH(SE2->E2_VENCTO),2))>=VAL(cMes)+1
						cMes:=STRZERO(MONTH(SE2->E2_VENCTO),2)
					EndIf
				Case MV_PAR01 == 3 .AND.  MV_PAR05 == 2
				If VAL(STRZERO(MONTH(SE2->E2_VENCREA),2))>=VAL(cMes)+1
						cMes:=STRZERO(MONTH(SE2->E2_VENCREA),2)
					EndIf
				Case MV_PAR01 == 4 .AND.  MV_PAR05 == 2
					If Empty(SE2->E2_BAIXA)
						//	cMes:=STRZERO(MONTH(dDtini),2)
						cMes := StrZero(Month(SE2->E2_EMIS1),2)			
					ElseIf VAL(STRZERO(MONTH(SE2->E2_BAIXA),2))>=VAL(cMes)+1
						cMes:=STRZERO(MONTH(SE2->E2_BAIXA),2)

					EndIf
				Case MV_PAR01 == 5 .AND.  MV_PAR05 == 2
					If VAL(STRZERO(MONTH(SE2->E2_EMISSAO),2))>=VAL(cMes)+1
							cMes:=STRZERO(MONTH(SE2->E2_EMISSAO),2)
					EndIf
					
				EndCase
				(cAlias)->(dbSkip())
		Else
				If	MV_PAR05 == 2 .AND. MV_PAR01 <> 2
					cMes:=STRZERO(MONTH(dDtini),2)
				Endif
			(cAlias)->(dbSkip())
		EndIf
	EndDo

	(cAlias)->(dbCloseArea())
EndIf

//Restaura a filial que estava antes de entrar na rotina
cFilAnt := cFilAux

Return(cMes)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³F401VldCtz³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 13/08/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validacao da pergunta Centralizar na filial ? (MV_PAR06)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA401                                            		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function F401VldCtz()

Local lGestao   := FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
Local cEmpFil	:= FWCodEmp()
Local nTamEmp	:= Len(cEmpFil)
Local lRet		:= .T.

If !Empty( MV_PAR06 )
	If	!FWFilExist(,MV_PAR06)
		Help(" ",1,"FILIALNOEXIST",,STR0008+CRLF+STR0009+CRLF+STR0010 ,1,0)
		lRet := .F.

	ElseIf lGestao
		If Substr(cFilAnt,1,nTamEmp) != Substr(MV_PAR06,1,nTamEmp)
			Help(" ",1,"OUTRA_EMP",,STR0039+CRLF+"  "+CRLF+STR0040 ,1,0)	//"A filial selecionada para centralização das informações e a filial corrente não pertencem a mesma empresa."
																			//"Selecione uma filial centralizadora que pertença a mesma empresa da filial corrente."
			lRet := .F.
		Endif
	EndIf
EndIf

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ F450PccBx    ³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 27/08/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Vericicacoes referentes ao PCC e PCC-CC           			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F450PccBx()												 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA450                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function F401PccBx()

If __lPCCBaixa == NIL
	__lPCCBaixa	:= SuperGetMv( "MV_BX10925" ,.T.,"2") == "1"

	__lPaBruto:= SuperGetMv("MV_PABRUTO",.T.,"2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor

	__lPrImPA := !__lPaBruto .And. (SuperGetMv("MV_PAPRIME",.T.,"2") == "1")

	__lValPgto := SuperGetMv("MV_BP10925",.T.,"1") == "2" //1- Valor bruto da baixa parcial / 2- Valor da baixa parcial menos os impostos
Endif

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GravTitFat ºAutor ³Andrea Verissimo Santiago º Data 02/01/14 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função que grava dados da DIRF e gerar relatorio de log paraº±±
±±º           titulos que possuam fatura e retenham IRRF ou PCC na baixa. º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Financeiro                                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function GravTitFat(cCodRet,nValor,cRaMat,cTipoFj,cAliasTrb,cCampo,aLog,lGerLog,;
									aRendimento,aDadosLog,lFatBx)
Local cChaveSr4 := ''
Local nPosLog	  :=	0
Local lCalcIssBx  :=	SA2->A2_TIPO == "J" .And. GetNewPar("MV_MRETISS","1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)
Local nAscan	  :=	0
Local cTpRen	  := ""

Local lForExt := .F.
Local cNIFEX  := ""
Local lTemNIF := .F.
Local lGeraNIF := .F.

If FindFunction( 'IsIssBx' )
	lCalcIssBx :=	IsIssBx( "P" )
EndIf

//tratamento para fornecedor exterior sem NIF
If !Empty(SA2->A2_PAISEX) 
	If IsCodResExt(cCodRet)
		lForExt := .T.
		lGeraNIF := .T.
	ElseIf SA2->A2_TIPO $ "J|X" .and. (Empty(SA2->A2_CGC) .or. SA2->A2_CGC =="00000000000000")
		lGeraNIF := .T.
	EndIf	
	If lGeraNIF
		If Empty(SA2->A2_NIFEX)
			cNIFEX := SA2->A2_COD +  SA2->A2_LOJA
			lTemNIF := .F.
		Else
			cNIFEX := SA2->A2_NIFEX
			lTemNIF := .T.
		EndIf
	EndIf
EndIf

// Tipo do rendimento considera tipo da entidade
If lTpEnt
	If Empty(SA2->A2_TPENT)
		cTpRen := "A"
	Else
		If SA2->A2_TPENT == "1"	 // Fornecedores Imunes
			cTpRen := "I2"
		ElseIf SA2->A2_TPENT == "2"  // Fornecedores Isentos
			cTpRen := "I3"
		EndIf
	EndIf
Else
	cTpRen := "A"
EndIf

If !SRL->(MsSeek(xFilial("SRL")+SM0->M0_CGC+ cCodRet +cTipoFj+If(SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1',Padr(SA2->A2_CPFIRP,14),SA2->A2_CGC) + cNIFEX))

	Reclock("SRL", .T.)

	cRaMat := GetSxENum("SRL", "RL_MAT")

	SRL->RL_FILIAL  := xFilial("SRL")
	SRL->RL_MAT     := If(Val(SRA->RA_MAT) < 900000 .And. Val(cRaMat) < 900000, "900000",cRaMat)
	SRL->RL_CODRET  := cCodRet
	SRL->RL_TIPOFJ  := cTipoFj
	SRL->RL_CPFCGC  := If(SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG = '1',Padr(SA2->A2_CPFIRP,14),SA2->A2_CGC)
	SRL->RL_BENEFIC := Substr(SA2->A2_NOME,1,60)
	SRL->RL_ENDBENE := Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END)
	SRL->RL_UFBENEF := SA2->A2_EST
	SRL->RL_COMPLEM := SA2->A2_BAIRRO
	SRL->RL_CGCFONT := SM0->M0_CGC
	SRL->RL_NOMFONT := SM0->M0_NOMECOM
	SRL->RL_ORIGEM := "2"
	SRL->RL_CGCEX := SA2->A2_CGCEX
	SRL->RL_PAIS  := SA2->A2_PAISEX
	SRL->RL_NIFEX := cNIFEX //SA2->A2_NIFEX

	If IsCodResExt(SRL->RL_CODRET)

		SRL->RL_NEMPR := SA2->A2_NEMPR
		SRL->RL_TPCON := SA2->A2_TPCON
		SRL->RL_DTINI := SA2->A2_DTINIR
		SRL->RL_DTFIM := SA2->A2_DTFIMR
		SRL->RL_LOGEX := SA2->A2_LOGEX
		SRL->RL_NUMEX := SA2->A2_NUMEX
		SRL->RL_COMPL := SA2->A2_COMPLR
		SRL->RL_BAIEX := SA2->A2_BAIEX
		SRL->RL_POSEX := SA2->A2_POSEX
		SRL->RL_CIDEX := SA2->A2_CIDEX
		SRL->RL_ESTEX := SA2->A2_ESTEX
		SRL->RL_TELEX := SA2->A2_TELRE
		SRL->RL_BREEX := SA2->A2_BREEX
		SRL->RL_TPREX := SA2->A2_TPREX
		SRL->RL_TRBEX := SA2->A2_TRBEX
		If !lTemNIF
			If SA2->A2_MOTNIF == "1"                                                                         
				SRL->RL_BEDINI := "1" //Fornecedor dispensado do NIF   
				SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
			Elseif SA2->A2_MOTNIF == "2"             
				SRL->RL_PAEXNI := "2" //País do fornecedor nao exige NIF   
			Endif
		Else
			SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
		Endif	
	EndIf

	SRL->(MsUnlock())
Endif

// Se existir o ano na chave do SR4
// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
cChaveSr4 := xFilial("SR4")+ SRL->RL_MAT+ SRL->RL_CPFCGC + cCodRet + STRZERO(YEAR((cAliasTrb)->&(cCampo)),4) + STRZERO(MONTH((cAliasTrb)->&(cCampo)),2)

If lFatBx //Gera valores dos impostos (IRRF ou PCC) porque a fatura foi baixada e os titulos gerados.
	If !SR4->( MsSeek( cChaveSr4 + padr("D",nTamTpRen)+ SRL->RL_PAIS + SRL->RL_NIFEX ))
		If nValor > 0
			Reclock("SR4", .T.)
			SR4->R4_FILIAL  := xFilial("SR4")
			SR4->R4_MAT     := SRL->RL_MAT
			SR4->R4_CPFCGC  := SRL->RL_CPFCGC
			SR4->R4_MES     := STRZERO(MONTH((cAliasTrb)->&(cCampo)),2)
			SR4->R4_TIPOREN := "D"
			SR4->R4_CODRET  := cCodRet
			SR4->R4_ANO  := STRZERO(YEAR((cAliasTrb)->&(cCampo)),4)
			SR4->R4_VALOR   := nValor
			SR4->R4_ORIGEM := "2"
			SR4->R4_PAIS 	:= SRL->RL_PAIS
			SR4->R4_NIFEX := SRL->RL_NIFEX

			If  !Empty(SRL->RL_PAIS) .And. IsCodResExt(SRL->RL_CODRET)
				SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
				If lISNIF
					SR4->R4_ISNIF := IIF(lTemNIF,"1","2")
				EndIf
			EndIf
			SR4->(MsUnlock())

			If Alltrim(cCodRet) = '5952'
			 	Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX',GetMv("MV_PISNAT"), (cAliasTrb)->E2_PIS, cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

				Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX', GetMv("MV_COFINS") , (cAliasTrb)->E2_COFINS, cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

				Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX', GetMv("MV_CSLL"), (cAliasTrb)->E2_CSLL,cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
			Else// IRRF
				Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
									(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
									'TX', &(SuperGetMv("MV_IRF")), nValor,cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
			Endif
		EndIf
	Else
		Reclock("SR4", .F.)
		SR4->R4_VALOR   += nValor
		SR4->(MsUnlock())

		If Alltrim(cCodRet) = '5952'
		 	Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX',GetMv("MV_PISNAT"), (cAliasTrb)->E2_PIS , cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

			Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX', GetMv("MV_COFINS") , (cAliasTrb)->E2_COFINS, cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

			Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX', GetMv("MV_CSLL"), (cAliasTrb)->E2_CSLL, cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
		Else// IRRF
			Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
									(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
									'TX', &(SuperGetMv("MV_IRF")), nValor, cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
		Endif

	Endif
Endif

// Gera valor do Rendimento do imposto.
If lFatBx .Or. (!lFatBx .And. Alltrim(cCodRet) == Alltrim((cAliasTrb)->E2_CODRET))
	If (nAscan:=Ascan(aRendimentos, {|e| e[1] == cChaveSr4+padr(cTpRen,nTamTpRen)+SRL->RL_PAIS + SRL->RL_NIFEX})) == 0

		//recompoe o valor bruto onde foi descontado o ISS na emissão e INSS, pois deve ser gerado pelo valor bruto
		nValor := (cAliasTrb)->E2_VALOR + IIf(!lCalcIssBx .and. (cAliasTrb)->E2_ISS > 0, (cAliasTrb)->E2_ISS,0) + (cAliasTrb)->E2_INSS
		Aadd(aRendimentos, {	cChaveSr4+padr(cTpRen,nTamTpRen)+SRL->RL_PAIS + SRL->RL_NIFEX,;
								cTipoFj,;
								If(SA2->A2_TIPO == "J".and. SA2->A2_IRPROG = '1',SA2->A2_CPFIRP,SA2->A2_CGC),;
								STRZERO(MONTH((cAliasTrb)->&(cCampo)),2),;
								cCodRet,;
								STRZERO(YEAR((cAliasTrb)->&(cCampo)),4),;
								nValor,;
								SA2->A2_NOME,;
								Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END),;
								SA2->A2_EST,;
								SA2->A2_BAIRRO,;
								cRaMat,;
								SRL->RL_NIFEX } )
		nPosLog := Len(aRendimentos)
	Else
		nValor := (cAliasTrb)->E2_VALOR + IIf(!lCalcIssBx .and. (cAliasTrb)->E2_ISS > 0, (cAliasTrb)->E2_ISS,0) + (cAliasTrb)->E2_INSS
		aRendimentos[nAscan,7] += nValor
		nPosLog := nAscan
	Endif

	If lGerLog
		(cAliasTrb)->( AAdd( aDadosLog, {	aRendimentos[nPosLog,3], aRendimentos[nPosLog,5], aRendimentos[nPosLog,4], cTpRen,;
												(cAliasTrb)->E2_FILIAL, (cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM,;
												(cAliasTrb)->E2_PARCELA, (cAliasTrb)->E2_TIPO, (cAliasTrb)->E2_NATUREZ, nValor,SRL->RL_NIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME } ) )
	EndIf
Endif

Return Nil



/*     */
Static function F401QryMes()
Local cQuery 	:= ""
Local cSepNeg := If("|"$MV_CPNEG,"|",",")
Local cSepProv:= If("|"$MVPROVIS,"|",",")
Local cSepRec := If("|"$MVPAGANT,"|",",")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³SELECIONA OS DADOS TODOS OS DADOS DE SE2.                                       ³
//³EFETUA A TRATATIVA PARA A NÃO INCLUSÃO DOS ITENS BAIXADOS NESTE PRIMEIRO MOMENTO³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cQuery := "SELECT DISTINCT SE2.E2_VALOR";
			           + ", SE2.E2_IRRF";
			           + ", SE2.E2_INSS";
			           + ", SE2.E2_ISS";
			           + ", SE2.E2_SEST";
			           + ", SE2.E2_PRETPIS";
			           + ", SE2.E2_PRETCOF";
			           + ", SE2.E2_PRETCSL";
			           + ", SE2.E2_VRETPIS";
			           + ", SE2.E2_VRETCOF";
			           + ", SE2.E2_VRETCSL";
	  	               + ", SE2.E2_VRETIRF";
			           + ", SE2.E2_INSS";
			           + ", SE2.E2_IRRF";
			           + ", SE2.E2_PREFIXO";
			           + ", SE2.E2_NUM";
			           + ", SE2.E2_TIPO";
			           + ", SE2.E2_PARCELA";
			           + ", SE2.E2_FORNECE";
			           + ", SE2.E2_LOJA";
			           + ", SE2.E2_PARCIR";
			           + ", SE2.E2_PARCINS";
		 		       + ", SE2.E2_BAIXA";
		 		       + ", SE2.E2_SALDO";
		 		       + ", SE2.E2_NATUREZ";
		 		       + ", SED.ED_BASEIRC"

		cQuery += " FROM " + RetSQLname("SE2") + " SE2, "
		cQuery +=           RetSQLname("SED") + " SED "
		cquery += " WHERE SE2.E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)
		cQuery += " AND SE2.E2_NATUREZ = SED.ED_CODIGO "
		cQuery += " AND SE2.D_E_L_E_T_ = ' '"
		cQuery += " AND SED.D_E_L_E_T_ = ' '"

		//cQuery:=ChangeQuery(cQuery)
Return cQuery

/*
{Protheus.doc} F401QryIr
@description Retorna query com os dados para processamento de IR
@param nTipo 1 = Query normal, 2 = Query para processamento pela baixa do título de imposto
@author Totvs
*/
Static Function F401QryIr(nTipo as numeric)
	Local cQuery as Character
	Local cSepNeg as Character
	Local cSepProv as Character
	
	cQuery 		:= ""
	cSepNeg 	:= If("|"$MV_CPNEG,"|",",")
	cSepProv	:= If("|"$MVPROVIS,"|",",")

	cQuery := "SELECT DISTINCT SE2.E2_VALOR";
		+ ", SE2.E2_BASEIRF";
		+ ", SE2.E2_IRRF";
		+ ", SE2.E2_INSS";
		+ ", SE2.E2_ISS";
		+ ", SE2.E2_SEST";
		+ ", SE2.E2_PRETPIS";
		+ ", SE2.E2_PRETCOF";
		+ ", SE2.E2_PRETCSL";
		+ ", SE2.E2_VRETPIS";
		+ ", SE2.E2_VRETCOF";
		+ ", SE2.E2_VRETCSL";
		+ ", SE2.E2_VRETIRF";
		+ ", SE2.E2_INSS";
		+ ", SE2.E2_IRRF";
		+ ", SE2.E2_PREFIXO";
		+ ", SE2.E2_NUM";
		+ ", SE2.E2_TIPO";
		+ ", SE2.E2_PARCELA";
		+ ", SE2.E2_FORNECE";
		+ ", SE2.E2_LOJA";
		+ ", SE2.E2_PARCIR";
		+ ", SE2.E2_PARCINS";
		+ ", SE2.E2_BAIXA";
		+ ", SE2.E2_SALDO";
		+ ", SE2.E2_NATUREZ";
		+ ", SE2.E2_FILIAL";
		+ ", SE2.E2_PIS";
		+ ", SE2.E2_CSLL";
		+ ", SE2.E2_COFINS";
		+ ", SE2.E2_ORIGEM";
		+ ", SE2.R_E_C_N_O_ RECNO ";
		+ ", SE2.E2_PRISS ";
		+ ", SE2.E2_PRINSS ";
		+ ", SE2.E2_MOEDA ";
		+ ", SE2.E2_TXMOEDA ";
		+ ", SE2.E2_EMIS1 "

	If lTpEnt
		cQuery += ", SA2.A2_TPENT"
	EndIf

	If nTipo == 1
		cQuery +=", SED.ED_BASEIRC"
		cQuery +=", SED.ED_CALCIRF";
				+ ", SE2.E2_EMISSAO";
				+ ", SE2.E2_VENCTO";
				+ ", SE2.E2_VENCREA";

		cQuery += " FROM " + RetSQLname("SE2") + " SE2, "
		cQuery +=             RetSQLname("SED") + " SED, "
		cQuery +=             RetSQLname("SA2") + " SA2 "

		cQuery += " WHERE SE2.E2_TIPO NOT IN " + FormatIn(MVTXA+"|"+MVTAXA,"|")
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)

		cQuery += " AND SE2.E2_NATUREZ = SED.ED_CODIGO"
		cQuery += " AND SE2.E2_FORNECE = SA2.A2_COD "
		cQuery += " AND SE2.E2_LOJA = SA2.A2_LOJA "
		cQuery += " AND SE2.D_E_L_E_T_ = ' '"
		cQuery += " AND SED.D_E_L_E_T_ = ' '"
		cQuery += " AND SA2.D_E_L_E_T_ = ' '"

	ElseIf nTipo == 2

		cQuery += " FROM " + RetSQLname("SE2") + " SE2"
		cQuery += " JOIN " + RetSQLname("SA2") + " SA2 "
		cQuery += " ON SA2.A2_COD = SUBSTRING( SE2.E2_TITPAI ," + Str(nTamTit) + ","+ Str(nTamFor)+ ")"
		cQuery += " AND SA2.A2_LOJA = SUBSTRING( SE2.E2_TITPAI ," + Str(nTamTit+nTamFor)+","+ Str(nTamLj)+ ")"

		cQuery += " WHERE SE2.E2_FORNECE = '"+ cUniao + "'"
		cQuery += " AND SE2.E2_TIPO = " + FormatIn(MVTAXA,"|")	
		cQuery += " AND SE2.D_E_L_E_T_ = ' '"
		cQuery += " AND SA2.D_E_L_E_T_ = ' '"
		
	EndIf

Return cQuery


//----------------------------------------------------------------
/*/{Protheus.doc} Fa401UpDtDirf
Faz a exclusao das datas da dirf no caso de reprocessamento - Com imposto
@sample Fa401UpDtDirf(lPlsAtiv,lReproc,cPccTit,cCampo,cChave,ni,nTotREG,cIndex,UPDATE_COM_IMPOSTO)
@param
	lPlsAtiv - Parametro MV_PLSATIV
	lReproc - Se a rotina é de reprocessamento
	cPccTit - Parametros de Pis, Cofins e Csll
	cCampo - Armazena o campo de data que sera utilizado
	cChave - Chave ( PK ) da tabela
	ni - Variavel usado para o loop
	nTotREG - Total de registros da tabela
	cIndex - Index da tabela
@author  Daniel.Mendes
@since 26/03/2014
@version P11
/*/
//----------------------------------------------------------------
Static Function Fa401UpDtDirf(lPlsAtiv,lReproc,cPccTit,cCampo,cCampoP,cChave,ni,nTotREG,cIndex)
Local cQuery    := ""
Local cAliasTrb := ""
Local aAreaSE2  := {}
Local aAreaSA2  := {}
Local lUpdate   := .T.
Local bDbSeek   := {||}

	If lReproc .And. FWModeAccess( "SA2" , 3 ) == "C"
		aAreaSE2 := SE2->(GetArea())
		aAreaSA2 := SA2->(GetArea())
		bDbSeek  := {||SE2->(DbSeek((cAliasTrb)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))}
		Fa401SqlCImp(@cAliasTrb,@cQuery,lPlsAtiv,lReproc,cPccTit,cCampo,cCampoP,cChave,ni,nTotREG,cIndex,lReproc)
		SE2->(DBSetOrder(1))
		SA2->(DBSetOrder(1))

		While !(cAliasTrb)->(Eof())
			Eval(bDbSeek)
			lUpdate := .T.

			/// QUANDO FOR PCC OU INSS, PESQUISAR O TIPO DE FORNECEDOR DO DOCUMENTO PAI E VERIFICAR COM O PARAMETRO DE TELA INFORMADO
			If AllTrim(SE2->E2_NATUREZ)$cPccTit+cMVINSNAT
				SE2->(DbSeek((cAliasTrb)->(E2_FILIAL+E2_TITPAI)))
				If SA2->(DbSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))
					If MV_PAR04 == 1
						If !(SA2->A2_TIPO == "F" .Or. (SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG == "1"))
							lUpdate := .F.
						EndIf
					Else
						If !(SA2->A2_TIPO == "J" .Or. (SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG <> "1"))
							lUpdate := .F.
						EndIf
					EndIf
				Else
					lUpdate := .F.
				EndIf

				Eval(bDbSeek)
			EndIf

			If lUpdate
				RecLock("SE2")
				SE2->E2_DTDIRF := Ctod("  /  /  ")
				SE2->(MsUnlock())
			EndIf

			(cAliasTrb)->(DbSkip())
		EndDo

		(cAliasTrb)->(DbCloseArea())
		SA2->(RestArea(aAreaSA2))
		SE2->(RestArea(aAreaSE2))
	EndIf

Return

//----------------------------------------------------------------
/*/{Protheus.doc} Fa401SImpDtUptDirf
Faz a exclusao das datas da dirf no caso de reprocessamento - Sem imposto
@sample Fa401SImpDtUptDirf(cNotIn,lQuery,cAbatim,cImpostos,lReproc,cFornUniao,nX,cCondicao,bWhile,bFor,cCampo)
@param
	cNotIn - String que guarda os valores do not in, usados no where do E2_TIPO
	lQuery - Se será utilizado uma query ou nao
	cAbatim - String que guarda os tipos de abatimentos - usado no not in
	cImpostos - String que guarda os tipos de impostos - usado no not in
	lReproc - Se a rotina é de reprocessamento
	cFornUniao - Nome do fornecedor UNIAO
	nX - Variavel usado para o loop
	cCondicao - Condicao/Where
	bWhile - Bloco de codigo do while
	bFor - Bloco de codigo do for
	cCampo - Armazena o campo de data que sera utilizado
@author  Daniel.Mendes
@since 28/04/2014
@version P11
/*/
//----------------------------------------------------------------
Static Function Fa401SImpDtUptDirf(cNotIn,lQuery,cAbatim,cImpostos,lReproc,cFornUniao,nX,cCondicao,bWhile,bFor,cCampo)
Local cQuery    := ""
Local cAliasTrb := ""
Local aArea     := {}
Local lGestao		:= FWSizeFilial() > 2
Local lSE2Access	:= Iif( lGestao .And. FWModeAccess("SE1",1) == "E",.T.,.F.)

	If lReproc .And. FWModeAccess( "SA2" , 3 ) == "C"
		cAliasTrb := GetNextAlias()
		aArea := SE2->(GetArea())
		Fa401SqlSImp(cNotIn,lQuery,cAbatim,cImpostos,@cQuery,lReproc,cFornUniao,@cAliasTrb,nX,cCondicao,@bWhile,@bFor,cCampo,lReproc)
		SE2->(DBSetOrder(1))

		While !(cAliasTrb)->(Eof()) .And. Eval(bWhile)
			SE2->(DbSeek((cAliasTrb)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

			//Respeitar a gestão de emepresas para não apagar campos de outras empresas
			If lSE2Access  .And. Len(FWSM0Layout(, 1))>0 .And. (FWCOMPANY() != Substr((cAliasTrb)->E2_FILIAL,1,Len(FWSM0Layout(, 1))))
				(cAliasTrb)->(DbSkip())
				Loop
			EndIf
			RecLock("SE2")
			SE2->E2_DTDIRF := Ctod("  /  /  ")
			SE2->(MsUnlock())
			(cAliasTrb)->(DbSkip())

		EndDo

		(cAliasTrb)->(DbCloseArea())
		SE2->(RestArea(aArea))
	EndIf

Return

//----------------------------------------------------------------
/*/{Protheus.doc} Fa401SqlCImp
Cria uma query conforme os parametros informados na SE2 - Com imposto
@sample Fa401SqlCImp(cAliasTrb,cQuery,lPlsAtiv,lReproc,cPccTit,cCampo,cChave,ni,nTotREG,cIndex,lExclusao)
@param
	cAliasTrb - Alias para ser usado na query
	cQuery - Armazena o select
	lPlsAtiv - Parametro MV_PLSATIV
	lReproc - Se a rotina é de reprocessamento
	cPccTit - Parametros de Pis, Cofins e Csll
	cCampo - Armazena o campo de data que sera utilizado
	cCampoP - Armazena o campo de data que sera utilizado quando for PCC
	cChave - Chave ( PK ) da tabela
	ni - Variavel usado para o loop
	nTotREG - Total de registros da tabela
	cIndex - Index da tabela
	lExclusao - Se a query e para efetuar a exclusao da data da dirf
	cFiltro - filtro para base DBF
	cTipoIn - Filtro para o tipos de titulos
@author  Daniel.Mendes
@since 25/04/2014
@version P11
/*/
//----------------------------------------------------------------
Static Function Fa401SqlCImp(cAliasTrb,cQuery,lPlsAtiv,lReproc,cPccTit,cCampo,;
									cCampoP,cChave,ni,nTotREG,cIndex,lExclusao,cFiltro,cTipoIn)

Local cCompSA2 := FWModeAccess( "SA2" , 1 ) + FWModeAccess( "SA2" , 2 ) + FWModeAccess( "SA2" , 3 )
Local nTamFilSA2 := If( "E" $ cCompSA2, Len(Alltrim(xFilial("SA2"))) , 0 )

Default lExclusao := .F.
Default cTipoIn := ""

cAliasTrb := GetNextAlias()

cQuery := "SELECT "
cQuery += "SE2.E2_FILIAL, SE2.E2_FORNECE, SE2.E2_LOJA, SE2.E2_CODRET,SE2.E2_VENCREA, SE2.E2_PREFIXO, "
cQuery += "SE2.E2_NUM, SE2.E2_PARCELA, SE2.E2_TIPO, SE2.E2_NATUREZ, SE2.E2_BAIXA, SE2.E2_EMIS1,SE2.E2_SEQBX, "
cQuery += "SE2.E2_EMISSAO,SE2.E2_VENCTO, SE2.E2_VALOR, SE2.E2_INSS, SE2.E2_IRRF, SE2.E2_ISS, SE2.E2_PIS, SE2.E2_COFINS, SE2.E2_CSLL, "
cQuery += "SE2.E2_PARCIR, SE2.E2_PARCPIS,SE2.E2_FILORIG,SE2.E2_CNPJRET,SE2.E2_NOMERET,SE2.E2_TITPAI,SE2.E2_FILORIG,SE2.R_E_C_N_O_ "
If !lExclusao
	If cBDname $ "INFORMIX*ORACLE"
		cQuery += ", NVL(PAI.R_E_C_N_O_,0) RECNOPAI "
	ElseIf  cBDname $ "DB2*POSTGRES" .OR. ( cBDname == "DB2/400" .And. Upper(cSrvType) == "ISERIES" )
		cQuery += ", COALESCE(PAI.R_E_C_N_O_,0) RECNOPAI "
	Else
		cQuery += ", ISNULL(PAI.R_E_C_N_O_,0) RECNOPAI  "
	EndIf
EndIf

cQuery += ", SE2.E2_TITPAI "
If lTpEnt
	cQuery += ", SA2.A2_TPENT"
EndIf
cQuery += " FROM " + RetSqlName("SE2") +" SE2 "

cQuery += " LEFT JOIN " + RetSqlName("SE2") +" PAI ON "
cQuery += " (SE2.E2_FILIAL = PAI.E2_FILIAL AND "
If "MYSQL" $ cBDname
	cQuery += cQryConcat+" PAI.E2_PREFIXO,PAI.E2_NUM,PAI.E2_PARCELA,PAI.E2_TIPO,PAI.E2_FORNECE,PAI.E2_LOJA) = SE2.E2_TITPAI AND "
ElseIf cBDname $ "DB2|POSTGRES|MSSQL"  .OR. ( cBDname == "DB2/400" .And. Upper(cSrvType) == "ISERIES" )
	cQuery += " PAI.E2_PREFIXO = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,1," +STR(nTamPref) + "))"
	cQuery += " AND PAI.E2_NUM = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+1) +"," + STR(nTamNum) + "))"
	cQuery += " AND PAI.E2_PARCELA =  RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+nTamNum+1)+","+STR(nTamPar)+"))"
	cQuery += " AND PAI.E2_TIPO = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+nTamNum+nTamPar+1)+","+STR(nTamTipo)+"))"
	cQuery += " AND PAI.E2_FORNECE = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI,"+STR(nTamPref+nTamNum+nTamPar+nTamTipo+1)+","+STR(nTamFor)+"))"
	cQuery += " AND PAI.E2_LOJA = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI,"+STR(nTamPref+nTamNum+nTamPar+nTamTipo+nTamFor+1)+","+STR(nTamLj)+")) AND"

Else
	cQuery += " PAI.E2_PREFIXO" +cQryConcat+"PAI.E2_NUM"+cQryConcat+"PAI.E2_PARCELA"+cQryConcat+"PAI.E2_TIPO"+cQryConcat+"PAI.E2_FORNECE"+cQryConcat+"PAI.E2_LOJA = SE2.E2_TITPAI AND "
EndIf
If !Empty(cTipoIn)
	cQuery += " PAI.E2_TIPO NOT IN " + cTipoIn + " AND "
EndIf
cQuery += " PAI.D_E_L_E_T_= ' ' )"
cQuery += " JOIN " +  RetSqlName("SA2") + " SA2 ON "

If MV_PAR08 == 1
	cQuery += "( SA2.A2_FILIAL " + cFilSA2 + " AND PAI.E2_FORNECE = SA2.A2_COD AND PAI.E2_LOJA = SA2.A2_LOJA AND SA2.D_E_L_E_T_ = ' ' "
Else
	cQuery += "( SA2.A2_FILIAL = '" + xFilial("SA2") + "' AND PAI.E2_FORNECE = SA2.A2_COD AND PAI.E2_LOJA = SA2.A2_LOJA AND SA2.D_E_L_E_T_ = ' ' "
EndIf

If nTamFilSA2 > 0
		If cBDname $ "ORACLE|DB2|POSTGRES|INFORMIX"
		cQuery += " AND SUBSTR(SA2.A2_FILIAL,1," + str(nTamFilSA2) +" ) = SUBSTR(PAI.E2_FILORIG,1,"+Str(nTamFilSA2)+")  "
	Else
		cQuery += " AND SUBSTRING(SA2.A2_FILIAL,1,"+ str(nTamFilSA2)+") = SUBSTRING(PAI.E2_FILORIG,1,"+Str(nTamFilSA2)+") "
	EndIf
EndIf

If MV_PAR04 == 1 //Fisico
	//Se for PJ com IR Progressivo, será tratado como Pessoa Física.
	cQuery +=	" AND (SA2.A2_TIPO = 'F'  OR (SA2.A2_TIPO = 'J' AND SA2.A2_IRPROG = '1')) "
Else
	cQuery +=	" AND (SA2.A2_TIPO = 'X' OR (SA2.A2_TIPO = 'J' AND SA2.A2_IRPROG != '1')) "
Endif
cQuery += ") "



//If lExclusao
//	cQuery += Fa401SqlA2( SA2_SQL_JOIN , "SA2" , "PAI" , lExclusao )
//EndIf

/// QUANDO FOR EXCLUSAO, DEVE PEGAR TODAS AS FILIAIS DIFERENTES NA FILIAL ATUAL, CASO CONTRARIO SOMENTE DA FILIAL ATUAL
//Gestao
If MV_PAR08 == 1
	If !lExclusao
		cQuery += " WHERE SE2.E2_FILIAL " + cFilSel + " "
	Else
		cQuery += " WHERE SE2.E2_FILIAL " + Iif( " IN " $ cFilSel , " NOT " + cFilSel , "!= '" + cFilAnt + "'" )
	EndIf
Else
	cQuery += " WHERE SE2.E2_FILIAL " + Iif( !lExclusao , ("= '" + xFilial("SE2")) , ("!= '" + cFilAnt) ) + "'"
Endif

cQuery += "   AND SE2.E2_DIRF IN ('1','S' " + Iif( lExclusao , ",'2'" , "" ) + ")"
cQuery += "   AND SE2.E2_CODRET != ' ' AND "
If !Empty(cTipoIn)
	If MV_PAR10 == 2
		cQuery += " SE2.E2_TIPO IN " + cTipoIn + " AND "
	Else

		cQuery += " ( SE2.E2_TIPO IN  " + cTipoIn + " OR "
		cQuery += " (SE2.E2_TIPO IN " + FormatIn(MVTXA+"|"+"INA","|") + " AND SE2.E2_BAIXA != ' ' "
		cQuery += " AND EXISTS (SELECT SE5.R_E_C_N_O_ FROM " + RetSqlName("SE5") + " SE5 WHERE "
		cQuery += " SE5.E5_FILORIG = SE2.E2_FILORIG AND "
		cQuery += " SE5.E5_PREFIXO = SE2.E2_PREFIXO AND "
		cQuery += " SE5.E5_NUMERO = SE2.E2_NUM AND "
		cQuery += " SE5.E5_PARCELA = SE2.E2_PARCELA AND "
		cQuery += " SE5.E5_CLIFOR = SE2.E2_FORNECE AND "
		cQuery += " SE5.E5_LOJA = SE2.E2_LOJA AND "
		cQuery += " SE5.E5_TIPODOC IN ('BA','VL') AND "
		cQuery += " SE5.E5_MOTBX NOT IN ('CMP','DSD') AND "
		cQuery += " SE5.E5_SITUACA NOT IN ( 'C' , 'E' , 'X' )"
		cQuery += " AND SE5.E5_TIPODOC <> 'ES'"
		cQuery += " AND SE5.D_E_L_E_T_ = ' '))) AND "
	EndIf

EndIf

/// QUANDO FOR EXCLUSAO, DEVE PEGAR TODAS AS DATAS JA PREENCHIDAS
If lExclusao
	cQuery += "SE2.E2_DTDIRF != ' ' AND "
Else
	// Se existir a data de processamento da DIRF, verifica se trata-se de reprocessamento
	// Se for reprocessamento, filtra apenas os titulos que ja foram processados
	If !lReproc
		// Senao filtra os titulos que nao foram processados
		cQuery += "SE2.E2_DTDIRF = ' ' AND "
	Endif
EndIf

/// DESSA FORMA A EXCLUSAO FICA O CONTRARIO DA EXCLUSAO SEM IMPOSTOS, NAO PESQUISANDO DOCUMENTOS IGUAIS
If lExclusao
	cQuery += Fa401SqlA2( SA2_SQL_WHERE , "SA2" , "SE2" , lExclusao , .T. )
EndIf

Do Case
	Case MV_PAR01 == 1 // Data de emissao digitada
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ( PAI.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) OR "
		EndIf
		cCampo  := "E2_EMIS1"

	Case MV_PAR01 == 2// Vencimento
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ( PAI.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) OR "
		Endif
		cCampo  := "E2_VENCTO"

	Case MV_PAR01 == 3 //Vencimento real
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ( PAI.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) OR "
		Endif
		cCampo  := "E2_VENCREA"

	Case MV_PAR01 == 4 //Data de Baixa
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ((SE2.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
			cQuery += " (SE2.E2_BAIXA = ' ' AND "
			cQuery += " SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) ) ) OR "
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ( (PAI.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR "
			cQuery += " (PAI.E2_BAIXA = ' ' AND "
			cQuery += " PAI.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) )) OR "
		EndIf
		cCampo := "E2_BAIXA"

	Case MV_PAR01 == 5 // Data de emissao real
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ( PAI.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) OR "
		EndIf
		cCampo  := "E2_EMISSAO"

EndCase

Do Case
	Case MV_PAR09 == 1 // Data de emissao
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND PAI.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) AND "
		EndIf
		cCampoP  := "E2_EMIS1"

	Case MV_PAR09 == 2// Vencimento
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND PAI.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) AND "
		Endif
		cCampoP  := "E2_VENCTO"

	Case MV_PAR09 == 3 //Vencimento real
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND PAI.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) AND "
		Endif
		cCampoP  := "E2_VENCREA"

	Case MV_PAR09 == 4 //Data de Baixa
		cCampoP := "E2_BAIXA"
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND (SE2.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) "
			
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			If MV_PAR10 == 1 // considera PA
				cQuery += " AND ((PAI.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' "
				cQuery += " AND PAI.E2_TIPO NOT IN " + FormatIn(MVPAGANT,"|") + ") OR "
				cQuery += " (PAI.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' "
				cQuery += " AND PAI.E2_TIPO IN " + FormatIn(MVPAGANT,"|") + ")))) AND  "
				
			Else
				If __lPccBaixa
					cQuery += " AND (SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) AND "
					cCampoP := "E2_EMIS1"				
				Else
					cQuery += " AND (PAI.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) AND "
				EndIf	
				
			EndIf
		EndIf
		

	Case MV_PAR09 == 5 //Data de Emissao Real
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND (SE2.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) "
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND (PAI.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) AND "
		EndIf
		cCampoP := "E2_EMISSAO"
EndCase

cChave := "SE2.E2_FILIAL , SE2.E2_FORNECE,SE2.E2_LOJA , SE2.E2_CODRET ,SE2."+cCampo+" , SE2.E2_PREFIXO , SE2.E2_NUM , SE2.E2_PARCELA , SE2.E2_TIPO"
IF MV_PAR05 == 2
	cQuery += " AND SE2.D_E_L_E_T_ = ' '"
Else
	cQuery += " SE2.D_E_L_E_T_ = ' '"
Endif
cQuery += " ORDER BY " + cChave

//cQuery := ChangeQuery(cQuery)

If lFA401QRY
	cQuery := ExecBlock("FA401QRY",.F.,.F.,{cQuery})
Endif

dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTrb,.F.,.T.)
//MPSysOpenQuery( cQuery , cAliasTrb ,aStru )

For ni := 1 to Len(aStru)
	If aStru[ni,2] != 'C' .and. FieldPos(aStru[ni,1]) > 0
		TCSetField(cAliasTrb, aStru[ni,1], aStru[ni,2],aStru[ni,3],aStru[ni,4])
	Endif
Next

//Com o arquivo temporario da query, a contagem precisa ser feita registro a registro
(cAliasTrb)->(dbEval({|| nTotREG++}))
(cAliasTrb)->(dbGoTop())

Return

//----------------------------------------------------------------
/*/{Protheus.doc} Fa401SqlSImp
Cria uma query conforme os parametros informados na SE2 - Sem imposto
@sample Fa401SqlSImp(cNotIn,lQuery,cAbatim,cImpostos,cQuery,lReproc,cFornUniao,cAliasTrb,nX,cCondicao,bWhile,bFor,cCampo,lExclusao)
@param
	cNotIn - String que guarda os valores do not in, usados no where do E2_TIPO
	lQuery - Se será utilizado uma query ou nao
	cAbatim - String que guarda os tipos de abatimentos - usado no not in
	cImpostos - String que guarda os tipos de impostos - usado no not in
	cQuery - Armazena o select
	lReproc - Se a rotina é de reprocessamento
	cFornUniao - Nome do fornecedor UNIAO
	cAliasTrb - Alias para ser usado na query
	nX - Variavel usado para o loop
	cCondicao - Condicao/Where
	bWhile - Bloco de codigo do while
	bFor - Bloco de codigo do for
	cCampo - Armazena o campo de data que sera utilizado
	lExclusao - Se a query e para efetuar a exclusao da data da dirf
@author  Daniel.Mendes
@since 28/04/2014
@version P11
/*/
//----------------------------------------------------------------
Static Function Fa401SqlSImp(cNotIn,lQuery,cAbatim,cImpostos,cQuery,lReproc,cFornUniao,cAliasTrb,nX,cCondicao,bWhile,bFor,cCampo,lExclusao)

Default lExclusao := .F.

cNotIn := FormatIn(cAbatim+"|"+cImpostos+"|"+MVPROVIS+"|"+MVPAGANT,"|")
lQuery := .T.

cQuery := "SELECT A.E2_FILIAL, A.E2_VALOR, A.E2_CODRET, A.E2_EMIS1, A.E2_FORNECE, A.E2_LOJA, A.E2_IRRF, A.E2_PREFIXO, A.E2_NUM, "
cQuery += " A.E2_PARCELA, A.E2_TIPO, A.E2_PARCIR, A.E2_PIS, A.E2_PARCPIS, A.E2_COFINS, A.E2_CSLL, "
cQuery += " A.E2_VENCTO, A.E2_VENCREA, A.E2_BAIXA, A.E2_NATUREZ, "
cQuery += " A.E2_FATURA, A.E2_FATFOR, A.E2_FATLOJ, A.E2_FATPREF, A.E2_TIPOFAT, "
cQuery += " A.R_E_C_N_O_, SA2.A2_CGC, A.E2_ISS, A.E2_INSS ,A.E2_EMISSAO,"
cQuery += " SA2.A2_CPFIRP, "
cQuery += " A.E2_ISS , A.E2_SALDO ,  A.E2_INSS , A.E2_PRINSS, A.E2_PRISS,"

If lTpEnt
	cQuery += "	SA2.A2_TPENT,"
EndIf
cQuery += " SA2.R_E_C_N_O_ RECNOSA2 "
cQuery += "FROM " + RetSqlName("SE2") + " A "

cQuery += Fa401SqlA2( SA2_SQL_JOIN , "SA2" , "A" , lExclusao )
cQuery += "WHERE 	"

/// QUANDO FOR EXCLUSAO, DEVE PEGAR TODAS AS FILIAIS DIFERENTES NA FILIAL ATUAL, CASO CONTRARIO SOMENTE DA FILIAL ATUAL
If !lExclusao
	cQuery += " A.E2_FILIAL = '" + xFilial("SE2") + "' AND "
Else
	//Gestão
	If MV_PAR08 == 1 .And. "IN" $ cFilSel
		cQuery += " A.E2_FILIAL " + Iif( " IN " $ cFilSel , " NOT " , "" ) + cFilSel + " AND "
	Else
		cQuery += " A.E2_FILIAL != '" + cFilAnt + "' AND "
	EndIf
EndIf

Do Case
	Case MV_PAR01 == 1 // Data de emissao digitada
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit + "  AND "
		cQuery += " A.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_EMIS1"
	Case MV_PAR01 == 2// Vencimento
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit  + "  AND "
		cQuery += " A.E2_VENCTO >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_VENCTO <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_VENCTO"
	Case MV_PAR01 == 3 //Vencimento real
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit   + "  AND "
		cQuery += " A.E2_VENCREA >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_VENCREA <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_VENCREA"
	Case MV_PAR01 == 4 //Data de Baixa
		cQuery += "( A.E2_NATUREZ NOT IN " +  cPccTit  + "  AND "
		cQuery += " (A.E2_BAIXA >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += "   A.E2_BAIXA <= '" + Dtos(MV_PAR03) + "' ) OR"
		cQuery += "  (A.E2_BAIXA = ' ' AND "
		cQuery += "   A.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += "   A.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "' ) ) "
		cCampo := "E2_EMIS1"
	Case MV_PAR01 == 5 // Data de emissao real
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit + "  AND "
		cQuery += " A.E2_EMISSAO >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_EMISSAO <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_EMISSAO"
EndCase
// Desconsidera titulo baixado por desdobramento
cQuery += "AND NOT EXISTS (SELECT SE5.R_E_C_N_O_ FROM " + RetSqlName("SE5") + " SE5 WHERE "
cQuery += " SE5.E5_FILORIG = A.E2_FILORIG AND "
cQuery += " SE5.E5_PREFIXO = A.E2_PREFIXO AND "
cQuery += " SE5.E5_NUMERO = A.E2_NUM AND "
cQuery += " SE5.E5_PARCELA = A.E2_PARCELA AND "
cQuery += " SE5.E5_CLIFOR = A.E2_FORNECE AND "
cQuery += " SE5.E5_LOJA = A.E2_LOJA AND "
cQuery += " SE5.E5_MOTBX IN ('DSD') AND "
cQuery += " SE5.E5_SITUACA NOT IN ( 'C' , 'E' , 'X' )"
cQuery += " AND SE5.D_E_L_E_T_ = ' ')

cQuery += " AND "
cQuery += " A.E2_TIPO NOT IN " + cNotIn + " AND "
cQuery += " A.E2_CODRET != ' ' AND "
If !lExclusao
	cQuery += " A.E2_DIRF = '1' AND "
Else
	cQuery += " A.E2_DIRF IN ( '1' , '2' ) AND "
	cQuery += Fa401SqlA2( SA2_SQL_WHERE , "SA2" , "A" , lExclusao )
EndIf

/// QUANDO FOR EXCLUSAO, DEVE PEGAR TODAS AS DATAS JA PREENCHIDAS
If lExclusao
	cQuery += "A.E2_DTDIRF != ' ' AND "
// Se existir a data de processamento da DIRF, verifica se trata-se de reprocessamento
ElseIf !lReproc
	// filtra os titulos que nao foram processados
	cQuery += "A.E2_DTDIRF = ' ' AND "
Endif

cQuery += "NOT EXISTS ( SELECT	B.E2_NUM FROM " + RetSqlName("SE2") + " B "

If !lExclusao
	cQuery += "			        WHERE  B.E2_FILIAL = '"+xFilial("SE2") + "' AND "
Else
	cQuery += "			        WHERE  B.E2_FILIAL = A.E2_FILIAL AND "
EndIf

cQuery += "           				B.E2_PREFIXO = A.E2_PREFIXO AND "
cQuery += "				B.E2_NUM = A.E2_NUM AND "
cQuery += "				(B.E2_PARCELA = A.E2_PARCIR OR B.E2_PARCELA = A.E2_PARCPIS OR B.E2_PARCELA = A.E2_PARCCOF OR B.E2_PARCELA = A.E2_PARCSLL) AND "
cQuery += "	  			B.E2_TIPO = '"+MVTAXA +"' AND "
cQuery += "				B.E2_FORNECE = '"+cFornUniao+"' AND "
cQuery += "				B.E2_LOJA = '00' AND
cQuery += " 			B.D_E_L_E_T_ = ' ') AND "
cQuery += " A.D_E_L_E_T_ = ' ' "

If lF401Qry5
	cQuery := ExecBlock("F401Qry5",.F.,.F.,{cQuery})
EndIf

cQuery := ChangeQuery(cQuery)
dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasTrb, .F., .T.)

For nX := 1 to Len(aStru)
	If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
		TCSetField(cAliasTrb, aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
	Endif
Next

Return

//----------------------------------------------------------------
/*/{Protheus.doc} Fa401SqlA2
Cria e retorna o join ou where da tabela SA2 conforme parametros informados
@sample Fa401SqlA2( nTipo , cAliasSA2 , cAliasSE2 , lExclusao )
@param
	nTipo - Tipo de retorna, join das tabelas ou where da tabela SA2
	cAliasSA2 - Alias da tabela SA2 na query
	cAliasSE2 - Alias da tabela SE2 na query
	lExclusao - Se e para efetuar a rotina de exclusao
@return Valor do where ou join da tabela SA2
@author  Daniel.Mendes
@since 28/04/2014
@version P11
/*/
//----------------------------------------------------------------
Static Function Fa401SqlA2( nTipo , cAliasSA2 , cAliasSE2 , lExclusao , lComImposto )
Local   cSql        := ""
Local   lSA2Compar  := .F.
Local   cAbatim     := ""
Local   cImpostos   := ""
Local   cWhereTpJF  := ""
Local   cTpWhereJ   := ""
Default cAliasSE2   := "SE2"
Default lExclusao   := .F.
Default lComImposto := .F.

	If nTipo == SA2_SQL_JOIN
		lSA2Compar := FWModeAccess( "SE2" , 3 ) <> FWModeAccess( "SA2" , 3 )
		cSql += " JOIN " + RetSqlName("SA2") + " SA2 ON "

		If lSA2Compar .Or. !lExclusao
			cSql += " " + cAliasSA2 + ".A2_FILIAL = '" + xFilial("SA2") + "' AND "
		Else
			cSql += " " + cAliasSA2 + ".A2_FILIAL = " + cAliasSE2 + ".E2_FILIAL AND "
		EndIf
		cSql += " " + cAliasSE2 + ".E2_FORNECE = " + cAliasSA2 + ".A2_COD AND "
		cSql += " " + cAliasSE2 + ".E2_LOJA = " + cAliasSA2 + ".A2_LOJA AND "
		cSql += " " + cAliasSA2 + ".D_E_L_E_T_ = ' ' "
	ElseIf nTipo == SA2_SQL_WHERE
		If MV_PAR04 == 1 //Fisico
				cWhereTpJF := " ("+cAliasSA2+".A2_TIPO = 'F' OR ("+cAliasSA2+".A2_TIPO = 'J' AND "+cAliasSA2+".A2_IRPROG = '1'))"
				cTpWhereJ  := " (" + cAliasSA2 + ".A2_TIPO = 'X' OR (" + cAliasSA2  + ".A2_TIPO = 'J' AND "+cAliasSA2+".A2_IRPROG != '1')) "

				If lExclusao .And. lComImposto
					cAbatim   := MV_CRNEG+"|"+MV_CPNEG+"|"+MVIRABT+"|"+MVCSABT+"|"+MVCFABT+"|"+MVPIABT+"|"+MVABATIM
					cImpostos := MVISS+"|"+MVTXA+"|"+MVINSS+"|"+"SES"+"|" + "INA"
					cSql      += "( ( " + cAliasSE2 + ".E2_TIPO IN " + FormatIn(cAbatim+"|"+cImpostos+"|"+MVPROVIS+"|"+MVPAGANT,"|") + " AND "
					cSql      += cTpWhereJ + " ) OR "
					cSql      += "( "+cTpWhereJ+" AND "+cAliasSE2+".E2_TIPO = '"+MVTAXA+"' AND "+cAliasSE2+".E2_NATUREZ IN "+cPccTit+") OR"
					cSql      += cWhereTpJF + ") AND "
				Else
					//Se for PJ com IR Progressivo, será tratado como Pessoa Física.
					cSql += cWhereTpJF + " AND "
				EndIf
		Else
			cSql += " (" + cAliasSA2 + ".A2_TIPO = 'X' OR (" + cAliasSA2  + ".A2_TIPO = 'J'  AND " + cAliasSA2 + ".A2_IRPROG != '1')) AND "
		Endif
	EndIf

Return cSql

//----------------------------------------------------------------------
/*/{Protheus.doc} Fa401PaiProc
Verifica se a chave informada existe no array dos titulos pais
@sample Fa401PaiProc( aTitulos , cChaveSE2 )
@param
	aTit - Array dos titulos pais
	cChave - Chave da SE2 concatenada
@return Boolean, .T. se encontrar o titulo no array, .F. caso contrário
@author  Daniel.Mendes
@since 30/07/2014
@version P12
/*/
//----------------------------------------------------------------------
Static Function Fa401PaiProc( aTit , cChave )
Local lRet := .F.
Local nX := 0

For nX := 1 To Len( aTit )
	If !Empty( aTit[nX] )
		If aScan( aTit[nX] , cChave ) > 0
			lRet := .T.
			Exit
		EndIf
	EndIf
Next nX

Return lRet
/*
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Fa401SemRet ³ Autor ³ Andrea V. Santiago   ³ Data ³ 03.07.14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Processa todos os titulos que possuirem retencao de IR ou PCC³±±
±±³mas que nao geraram titulos de impostos e nao estao retidos em outros.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Fa401SemRet()										        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401SemRet(aRecno As Array,lReproc As Logical,cFilAtu As Character,aLog As Array,lGerLog As Logical,TMP1 As Character)

	Local cQuery 	 	As Character
	Local cAbatim 		As Character
	Local cImpostos 	AS Character
	Local cNotIn	 	As Character
	Local cAliasRet 	As Character

	Local nX			As Numeric
	Local nRendTributavel	As Numeric
	Local cTipoFj		As Character
	Local cRaMat		As Character
	Local lGrava		As Logical
	Local cData			As Character
	Local lExclusao		As Logical
	Local aAreaSe2 		As Array
	Local lOk			As Logical
	Local cArqTMP		As Character
	Local cArqINDEX		As Character
	Local aCampos		As Array

	Local cCampo		As Character
	Local aCodRet		As Array
	Local cCdRet		As Character
	Local nI			As Numeric
	Local lIRPFBaixa 	As Logical
	Local lCalcIssBx 	As Logical
	Local nPos			As Numeric
	Local lExc			As Logical
	Local cNIFEX 		As Character
	Local lTemNIF 		As Logical
	Local lForExt 		As Logical
	Local lGeraNIF 		As Logical
	Local lF401arec	 	As Logical
	Local lARec			As Logical
	Local nz			As Numeric
	Local cRec			As Character
	Local cTpRen		As Character 
	Local lEnvia		As Logical
	Local lRetPis		As Logical
	Local lRetCof		As Logical
	Local lRetCSL		As Logical
	Local lRetIR 		As Logical
	Local aCPFs			As Array
	Local lPJIRPrg		As Logical
	
	cQuery 	 	:= ""
	cAbatim 	:= MV_CRNEG+"|"+MV_CPNEG+"|"+MVIRABT+"|"+MVCSABT+"|"+MVCFABT+"|"+MVPIABT+"|"+MVABATIM
	cImpostos 	:= MVISS+"|"+MVTAXA+"|"+MVTXA+"|"+MVINSS+"|"+"SES"+ "|" + "INA"
	cNotIn	 	:= ""
	cAliasRet 	:= GetNextAlias()

	nX				:=	0
	nRendTributavel	:=	0
	cTipoFj			:=	""
	cRaMat			:=	""
	lGrava			:=	 .F.
	cData			:= ""
	lExclusao		:=	.F.
	aAreaSe2 		:= 	{}
	lOk				:=	.T.
	cArqTMP			:= ""
	cArqINDEX		:= CriaTrab(,.F.)
	aCampos			:= {}

	cCampo			:=	""
	aCodRet			:=	{}
	cCdRet			:= ""
	nI				:= 0
	lIRPFBaixa 		:= If(SA2->A2_CALCIRF == "2", .T., .F.)
	lCalcIssBx		:=	SA2->A2_TIPO == "J" .And. GetNewPar("MV_MRETISS","1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)
	nPos			:=	0
	lExc			:=	.F.
	cNIFEX 			:= ""
	lTemNIF 		:= .F.
	lForExt 		:= .F.
	lGeraNIF 		:= .F.
	lF401arec		:= ExistBlock("F401arec")
	lARec			:= .F.
	nz				:= 0
	cRec			:= ""
	cTpRen			:= ""
	lEnvia			:=	.T.
	lRetPis			:= .F.
	lRetCof			:= .F.
	lRetCSL			:= .F.
	lRetIR 			:= .F.
	aCPFs			:= {}
	lPJIRPrg		:= .F.

	If FindFunction( 'IsIssBx' )
		lCalcIssBx :=	IsIssBx( "P" )
	EndIf

	AADD(aCampos,{"NROREG"  	,"N",9,0})
	AADD(aCampos,{"TITIPAI"  	,"L",1,0})
	CriaTMP(aCampos,@cArqTMP,"TMP",cArqINDEX,"NROREG")

	If !Empty(MV_PAR06) // Se possuir filial centralizadora, posiciona nesta filial
		cFilAnt := cFilAtu
	Endif

	Do Case //Titulos de outros impostos
		Case MV_PAR01 == 1 // Data de emissao digitada
			cData  := "E2_EMIS1"
		Case MV_PAR01 == 2// Vencimento
			cData  := "E2_VENCTO"
		Case MV_PAR01 == 3 //Vencimento real
			cData  := "E2_VENCREA"
		Case MV_PAR01 == 4 //Data de Baixa
			cData := "E2_BAIXA"
		Case MV_PAR01 == 5 // Data de emissao real
			cData  := "E2_EMISSAO"
	EndCase

	cNotIn := FormatIn(cAbatim+"|"+cImpostos+"|"+MVPROVIS+"|"+MVPAGANT,"|")

	lQuery := .T.

	cQuery := "SELECT DISTINCT A.E2_FILIAL, A.E2_VALOR, A.E2_CODRET, A.E2_EMIS1, A.E2_FORNECE, A.E2_LOJA, A.E2_IRRF, A.E2_PREFIXO, A.E2_NUM, "
	cQuery += " A.E2_PARCELA, A.E2_TIPO, A.E2_PARCIR, A.E2_PIS, A.E2_PARCPIS, A.E2_COFINS, A.E2_CSLL, "
	cQuery += " A.E2_VENCTO, A.E2_VENCREA, A.E2_BAIXA, A.E2_NATUREZ, "
	cQuery += " A.E2_FATURA, A.E2_FATFOR, A.E2_FATLOJ, A.E2_FATPREF, A.E2_TIPOFAT, "
	cQuery += " A.E2_PRETPIS, A.E2_PRETCOF, A.E2_PRETCSL, A.E2_PRETIRF, A.E2_VRETCOF , A.E2_VRETPIS, A.E2_VRETCSL, A.E2_VRETIRF,"
	cQuery += " A.R_E_C_N_O_, SA2.A2_CGC, A.E2_ISS, A.E2_INSS , A.E2_EMISSAO, A.E2_NUMBOR, A.E2_SALDO, "
	cQuery += " A.E2_BASEIRF,A.E2_FILORIG, A.E2_BASEPIS,A.E2_BASECOF,A.E2_BASECSL, A.E2_VRETISS, A.E2_SEST, A.E2_RETENC, A.E2_DECRESC, "

	cQuery += " SA2.A2_CPFIRP, A.E2_VRETINS, "

	cQuery += "	SA2.R_E_C_N_O_ RECNOSA2, COALESCE(FKJ.FKJ_COD,'"+ space(TamSx3("FKJ_COD")[1]) +"') FKJ_COD "
	If lTpEnt
		cQuery += ", SA2.A2_TPENT"
	EndIf
	cQuery += "FROM " + RetSqlName("SE2") + " A "

	cQuery += Fa401SqlA2( SA2_SQL_JOIN , "SA2" , "A" , lExclusao )
	cQuery += " LEFT JOIN " + RetSqlName("FKJ") + " FKJ " 
	cQuery += " ON SA2.A2_FILIAL = FKJ.FKJ_FILIAL "
	cQuery += " AND SA2.A2_COD = FKJ.FKJ_COD "
	cQuery += " AND SA2.A2_LOJA = FKJ.FKJ_LOJA "
	cQuery += "WHERE 	"
	cQuery += " A.E2_FILIAL = '" + xFilial("SE2") + "' AND "

	Do Case
		Case MV_PAR01 == 1 // Data de emissao digitada
			cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit + "  AND "
			cQuery += " A.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "' AND "
			cQuery += " A.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "') "
			cCampo := "E2_EMIS1"
		Case MV_PAR01 == 2// Vencimento
			cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit  + "  AND "
			cQuery += " A.E2_VENCTO >= '" + Dtos(MV_PAR02) + "' AND "
			cQuery += " A.E2_VENCTO <= '" + Dtos(MV_PAR03) + "') "
			cCampo := "E2_VENCTO"
		Case MV_PAR01 == 3 //Vencimento real
			cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit   + "  AND "
			cQuery += " A.E2_VENCREA >= '" + Dtos(MV_PAR02) + "' AND "
			cQuery += " A.E2_VENCREA <= '" + Dtos(MV_PAR03) + "') "
			cCampo := "E2_VENCREA"
		Case MV_PAR01 == 4 //Data de Baixa
			cQuery += "( A.E2_NATUREZ NOT IN " +  cPccTit  + "  AND "
			cQuery += " (A.E2_BAIXA >= '" + Dtos(MV_PAR02) + "' AND "
			cQuery += "   A.E2_BAIXA <= '" + Dtos(MV_PAR03) + "' ) OR"
			cQuery += "  (A.E2_BAIXA = ' ' AND "
			cQuery += "   A.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "' AND "
			cQuery += "   A.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "' ) ) "
			cCampo := "E2_EMIS1"
		Case MV_PAR01 == 5 // Data de emissao real
			cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit + "  AND "
			cQuery += " A.E2_EMISSAO >= '" + Dtos(MV_PAR02) + "' AND "
			cQuery += " A.E2_EMISSAO <= '" + Dtos(MV_PAR03) + "') "
			cCampo := "E2_EMISSAO"
	EndCase

	If !lReproc .or. lF401arec
		// filtra os titulos que nao foram processados
		If lF401arec
			If Len(aRecno) > 0
				lARec	:= ExecBlock("F401arec",.F.,.F.,)
			EndIf
			If lARec
				cQuery += " AND (A.E2_DTDIRF = ' '  "
				For nz := 1 to Len(aRecno)
					If nz == 1
						cRec	:= "("
					Else
						cRec	+= ","
					EndIf
					cRec	+= Alltrim(STR(aRecno[nz]))
				Next
				cRec	+= ")"
				cQuery += "OR A.R_E_C_N_O_ IN " + cRec + " ) "
			Else
				cQuery += " AND A.E2_DTDIRF = ' '  "
			EndIf
		Else
			cQuery += " AND A.E2_DTDIRF = ' '  "
		EndIf

	Endif
	cQuery += " AND A.E2_TIPO NOT IN " + cNotIn + " AND "
	cQuery += " A.E2_CODRET != ' ' AND "  //Titulo definido para ir na DIRF.

	//Titulos de PCC que estejam pendentes de retenção. Neste caso pode ser um titulo de valor minimo de retenção ou
	//que o momento de retenção do imposto esteja na baixa e ainda não foi efetuada a mesma.
	cQuery += "  ( A.E2_VRETPIS + A.E2_VRETCOF + A.E2_VRETCSL = 0 )  AND "
	cQUery += "  (E2_VRETIRF = 0 OR (E2_IRRF = 0 AND E2_VRETIRF <> 0) OR "
	cQuery += "   FKJ.FKJ_CPF <> '') AND "
	cQuery += " A.D_E_L_E_T_ = ' ' AND "
	cQuery += " COALESCE(FKJ.D_E_L_E_T_,' ') = ' ' "

	cQuery := ChangeQuery(cQuery)

	If lF401QRY3
		cQuery := ExecBlock("F401QRY3",.F.,.F.,{cQuery})
	Endif

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasRet, .F., .T.)

	For nX := 1 to Len(aStru)
		If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
			TCSetField(cAliasRet, aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
		Endif
	Next

	SA2->(Dbsetorder(1))

	While (cAliasRet)->(!Eof())

		If !Empty(MV_PAR06)
			cFilAnt := cFilAtu
		Endif

		//titulos que ainda nao reteve PCC e estão em abertos não enviar se data pcc for dt baixa
		If ((cAliasRet)->E2_PRETPIS = '1' .And. (cAliasRet)->E2_PRETCOF = '1' .And. (cAliasRet)->E2_PRETCSL = '1' ) .and. ((cAliasRet)->(E2_PIS + E2_COFINS + E2_CSLL )> 0);
			.And. (cAliasRet)->E2_IRRF = 0 .and.  MV_PAR09 == 4 .and. Empty((cAliasRet)->E2_BAIXA)
				(cAliasRet)->(Dbskip())
				Loop
		EndIf

		//Para titulos com natureza sem retencao devem ser selecionados em outra query.
		SED->(Dbseek( xFilial("SED") + (cAliasRet)->E2_NATUREZ ))
		If SED->ED_CALCIRF == "N" .And. SED->ED_CALCISS == "N" .And. SED->ED_CALCINS == "N" .And. SED->ED_CALCCSL == "N" .And.;
			SED->ED_CALCPIS == "N" .And. SED->ED_CALCCOF == "N"
			(cAliasRet)->(Dbskip())
			Loop
		Endif

		lOk	:=	.T.
		aCodRet	:=	{}
		cCdRet		:= ""
		lForExt := .f.
		cNIFEX := ""
		lTemNIF := .F.
		lGrava	:=	 .F.
		aCPFs	:= {}

		//Caso titulo seja retido em outro que já foi gravado para a DIRF durante esta execução não deve duplicar.
		SFQ->(DbSetOrder(2)) //FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
		If SFQ->(DbSeek(xFilial("SFQ")+ Iif(__lPCCBaixa,"SE5","SE2") + (cAliasRet)->E2_PREFIXO + (cAliasRet)->E2_NUM + (cAliasRet)->E2_PARCELA + (cAliasRet)->E2_TIPO +;
								(cAliasRet)->E2_FORNECE + (cAliasRet)->E2_LOJA ))
			aAreaSe2 := SE2->(GetArea())
			SE2->(DbSetOrder(1))
			If SE2->(Dbseek(xFilial("SE2")+ SFQ->FQ_PREFORI + SFQ->FQ_NUMORI + SFQ->FQ_PARCORI + SFQ->FQ_TIPOORI + SFQ->FQ_CFORI + SFQ->FQ_LOJAORI))
				If (SE2->&(cData) <= MV_PAR03 .And. SE2->&(cData) >= MV_PAR02)
					lOk	:=	.F.
				Endif
			Endif
			SE2->(RestArea(aAreaSe2))
		Endif

		//Titulo que possua fatura que retenha IRRF ou PCC na baixa.
		//Se fatura estiver baixada, envia a fatura e não envia a NF, somente envia a NF se ela tiver impostos na emissao
		lEnvia	:=	.T.
		If ((lIrBx .And. (cAliasRet)->E2_IRRF > 0) .Or.;
			(__lPCCBaixa .And. ((cAliasRet)->E2_COFINS+(cAliasRet)->E2_PIS+(cAliasRet)->E2_CSLL) > 0)) .And.;
				!Empty((cAliasRet)->E2_FATURA)
			If 	Alltrim((cAliasRet)->E2_FATURA) != "NOTFAT"
				aAreaSe2 	:= SE2->(GetArea())

				//Procurar a fatura deste titulo.
				SE2->(Dbsetorder(6)) //FILIAL+FORNECE+LOJA+PREFIXO+NUM//+PARCELA+TIPO
				If SE2->(Dbseek( xFilial("SE2") + (cAliasRet)->E2_FATFOR + (cAliasRet)->E2_FATLOJ + (cAliasRet)->E2_FATPREF + (cAliasRet)->E2_FATURA  ))
					While !SE2->(Eof()) .And.;
							SE2->E2_FILIAL = xFilial("SE2") .And. ;
							(SE2->E2_FORNECE + SE2->E2_LOJA + SE2->E2_PREFIXO + SE2->E2_NUM) = ((cAliasRet)->E2_FATFOR + (cAliasRet)->E2_FATLOJ + (cAliasRet)->E2_FATPREF + (cAliasRet)->E2_FATURA)

						If SE2->E2_TIPO = (cAliasRet)->E2_TIPOFAT
							If !Empty(SE2->E2_BAIXA)
								lEnvia	:=	.F.
							Endif
						Endif
						SE2->(Dbskip())
					Enddo
				Endif
				RestArea(aAreaSe2)
			Else
				If Empty((cAliasRet)->E2_BAIXA)
					//se o título for uma fatura e estiver em aberto, não enviar para DIRF, pois deverá enviar as NFs que a compoe
					lEnvia	:=	.F.
				EndIf
			EndIf
		EndIf

		If !lEnvia
			(cAliasRet)->(Dbskip())
			Loop
		EndIf

		SA2->(Dbseek(xFilial("SA2")+(cAliasRet)->(E2_FORNECE+E2_LOJA)))
		//Verifico o tipo da pessoa do Fornecedor (Fisico ou Juridico.	Em branco ou X - Outros, serao verificados pelo CGC
		If Empty(SA2->A2_TIPO) .or. !(SA2->A2_TIPO $ "F/J")
			If SA2->A2_TIPO == 'X'
				cTipoFj := "2"
			ElseIf SA2->A2_IRPROG == '1'
				cTipoFj := "1"
			Else
				cTipoFj := Iif(Len(AllTrim(SA2->A2_CGC	)) > 11,"2","1")
			EndIf
		Else
			cTipoFj := IIf( SA2->A2_TIPO = "F" , "1" , If(SA2->A2_TIPO == 'J' .AND. SA2->A2_IRPROG == '1',"1","2") )
		Endif

		lPJIRPrg 	:= SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1'

		lIRPFBaixa := If(SA2->A2_CALCIRF == "2", .T., .F.)

		lRetPis 	:= (SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS  == "2" )
		lRetCof 	:= (SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2" )
		lRetCSL		:= (SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL == "2" )
		lRetIR		:= (SED->ED_CALCIRF == "S" .and. SA2->A2_CALCIRF $ "1|2" )

		lCalcIssBx :=	SA2->A2_TIPO == "J" .And. GetNewPar("MV_MRETISS","1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)

		If FindFunction( 'IsIssBx' )
			lCalcIssBx :=	IsIssBx( "P" )
		EndIf

		//Para titulos que retenham IRRF e PCC devo verificar se o código de retencao gerada foi somente para um destes impostos.
		//Retencao de PCC
		If  lRetPis .and. lRetCof .and. lRetCSL
			//If !__lPCCBaixa .OR. (__lPCCBaixa .and. (!Empty((cAliasRet)->E2_BAIXA) .or. !Empty((cAliasRet)->E2_NUMBOR )  ))
				Aadd(aCodRet,"5952")
			//EndIf
		Else
			If lRetPis
				Aadd(aCodRet,"5979")	
			EndIF
			If lRetCof
				Aadd(aCodRet,"5960")
			EndIF	
			If lRetCSL
				Aadd(aCodRet,"5987")	
			Endif
		Endif

		// Se possuir filial centralizadora, posiciona nesta filial
		If !Empty(MV_PAR06)
			SM0->(MsSeek(cEmpAnt+MV_PAR06))
			cFilAnt := MV_PAR06
		Endif

		//tratamento para fornecedor exterior sem NIF
		If !Empty(SA2->A2_PAISEX) 
			If IsCodResExt((cAliasRet)->E2_CODRET)
				lForExt := .T.
				lGeraNIF := .T.
			ElseIf SA2->A2_TIPO $ "J|X" .and. (Empty(SA2->A2_CGC) .or. SA2->A2_CGC =="00000000000000")
				lGeraNIF := .T.			
			EndIf	
			If lGeraNIF
				If Empty(SA2->A2_NIFEX)
					cNIFEX := SA2->A2_COD +  SA2->A2_LOJA
					lTemNIF := .F.
				Else
					cNIFEX := SA2->A2_NIFEX
					lTemNIF := .T.
				EndIf
			EndIf	
		EndIf

		//Retencao de IRRF
		If ( ( (cAliasRet)->E2_PRETIRF = '1') .Or. ( ((cAliasRet)->E2_PRETIRF == ' ' .Or. (cAliasRet)->E2_PRETIRF ='6')   .And. (cAliasRet)->E2_IRRF == 0 .And. (cAliasRet)->E2_VRETIRF > 0 .or.(!Empty((cAliasRet)->FKJ_COD))) ) //E2_PRETIRF = 6 borderô
			If SED->ED_CALCIRF == "S"
				If MV_PAR04 == 1 // PF
					If FKJ->(MsSeek(xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA) )
						aCPFs := VerCPFProg(,, .T.)
						If Len(aCPFs) >= 1
							// função para verificar se existe CPF sem titulo de IR gerado
							lGrava := CPFSemRet(cAliasRet,lIRPFBaixa, aCPfs, (cAliasRet)->E2_CODRET, cTipoFj, cNIFEX, cData, @aLog,lGerLog, lTemNIF)
						EndIf	
					EndIf
				EndIf
				If Empty(aCPFs) 
					Aadd(aCodRet, (cAliasRet)->E2_CODRET )
				EndIf	
			Endif
		Endif

		//Caso titulo já tenha sido gerado não deve ser duplicado.
		//Ou se não tiver natureza que retenha o imposto (Len(aCodRet)==0 ).
		//Caso titulo já tenha sido gerado para a DIRF não deve ir novamente.
		If TMP1->(Dbseek((cAliasRet)->R_E_C_N_O_)) .and. (TMP1->(TITIPAI) .or. (lRetIR .and. !(lRetPis .and. lRetCof .and. lRetCSL) ) )
			If (Len(aCodRet)==0 .Or. (Len(aCodRet)==1 .And. Alltrim((cAliasRet)->E2_CODRET)== Alltrim(aCodRet[1])))		
				(cAliasRet)->(Dbskip())
				Loop
			ElseIf Len(aCodRet)>= 1 .and. aCodRet[1] == "5952" .and. (( (__lPCCBaixa .and. (Empty((cAliasRet)->E2_BAIXA) .or. Empty((cAliasRet)->E2_NUMBOR )  ) .and. !lF401arec) .or.;
			(!__lPCCBaixa .and. !lF401arec)) .or. (lF401arec .and. !lARec))
				//Se for PCC e o PCC ainda nao foi gerado e ja gerou o rendimento em outro imposto
				(cAliasRet)->(Dbskip())
				Loop
			ElseIf Len(aCodRet)>= 1 .and. aCodRet[Len(aCodRet)] == (cAliasRet)->E2_CODRET .and. (lIRPFBaixa .and. (Empty((cAliasRet)->E2_BAIXA) .or. Empty((cAliasRet)->E2_NUMBOR  ) ))
				//Se for IR e o IR ainda nao foi gerado e ja gerou o rendimento em outro imposto
				(cAliasRet)->(Dbskip())
				Loop
			EndIf	
		Endif

		//Caso o titulo possua retencao de IRRF e PCC mas nao tenha retido o IRRF os rendimentos jah foram gerados anteriormente.
		If Len(aCodRet) > 1 .and. (cAliasRet)->E2_VRETIRF > 0
			nPos	:= Ascan(aCodRet,(cAliasRet)->E2_CODRET)
			lExc	:=	.F.
			If nPos > 0
				If TMP1->(Dbseek((cAliasRet)->R_E_C_N_O_))
					lExc	:=	.T.
				Endif
				If lExc
					Adel(aCodRet,nPos)
					Asize(aCodRet,Len(aCodRet)-1)
				Else
					//se tiver mais de 1 imposto e nenhum foi gerado ainda, gerar somente 1 retenção
					aCodRet := {}
					Aadd(aCodRet, (cAliasRet)->E2_CODRET )
				Endif
			Endif
		Endif	

		If !lOk
			(cAliasRet)->(Dbskip())
			Loop
		Endif

		If Val(cTipoFj) == MV_PAR04	// Se for um fornecedor definido no parametro

			If !Empty(MV_PAR06) // Se possuir filial centralizadora, posiciona nesta filial
				cFilAnt := MV_PAR06
			Endif

			For nI:=1 to Len(aCodRet)

				cCdRet	:= aCodRet[nI]

				// Pesquisa cabecalho da DIRF
				If !SRL->(MsSeek(xFilial("SRL")+Padr(SM0->M0_CGC,Len(SRL->RL_CGCFONT))+ cCdRet +;
					cTipoFj+If(SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1',PADR(SA2->A2_CPFIRP,14),Padr(SA2->A2_CGC,Len(SRL->RL_CPFCGC)))+ cNIFEX  ))

					Reclock("SRL", .T.)

					cRaMat := GetSxENum("SRL", "RL_MAT")

					SRL->RL_FILIAL  := xFilial("SRL")
					SRL->RL_MAT     := If(Val(SRA->RA_MAT) < 900000 .And. Val(cRaMat) < 900000, "900000",cRaMat)
					SRL->RL_CODRET  := cCdRet
					SRL->RL_TIPOFJ  := cTipoFj
					SRL->RL_CPFCGC  := If(SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG = '1',Padr(SA2->A2_CPFIRP,14),SA2->A2_CGC)
					SRL->RL_BENEFIC := Substr(SA2->A2_NOME,1,60)
					SRL->RL_ENDBENE := Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END)
					SRL->RL_UFBENEF := SA2->A2_EST
					SRL->RL_COMPLEM := SA2->A2_BAIRRO
					SRL->RL_CGCFONT := SM0->M0_CGC
					SRL->RL_NOMFONT := SM0->M0_NOMECOM
					SRL->RL_ORIGEM := "2"
					SRL->RL_NIFEX := cNIFEX //SA2->A2_NIFEX

					If  IsCodResExt(cCdRet)
						SRL->RL_CGCEX := SA2->A2_CGCEX
						SRL->RL_PAIS  := SA2->A2_PAISEX
						SRL->RL_NEMPR := SA2->A2_NEMPR
						SRL->RL_TPCON := SA2->A2_TPCON
						SRL->RL_DTINI := SA2->A2_DTINIR
						SRL->RL_DTFIM := SA2->A2_DTFIMR
						SRL->RL_LOGEX := SA2->A2_LOGEX
						SRL->RL_NUMEX := SA2->A2_NUMEX
						SRL->RL_COMPL := SA2->A2_COMPLR
						SRL->RL_BAIEX := SA2->A2_BAIEX
						SRL->RL_POSEX := SA2->A2_POSEX
						SRL->RL_CIDEX := SA2->A2_CIDEX
						SRL->RL_ESTEX := SA2->A2_ESTEX
						SRL->RL_TELEX := SA2->A2_TELRE
						SRL->RL_BREEX := SA2->A2_BREEX
						SRL->RL_TPREX := SA2->A2_TPREX
						SRL->RL_TRBEX := SA2->A2_TRBEX
						If !lTemNIF
							If SA2->A2_MOTNIF == "1"                                                                         
								SRL->RL_BEDINI := "1" //Fornecedor dispensado do NIF   
								SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
							Elseif SA2->A2_MOTNIF == "2"             
								SRL->RL_PAEXNI := "2" //País do fornecedor nao exige NIF   
							Endif
						Else
							SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
						Endif				
					EndIf
					SRL->(MsUnlock())
				Endif	

				// Se for pela data baixa e nao houve o pagamento, considerar data E2_EMIS1
				If MV_PAR01 == 4 .and. STRZERO(MONTH((cAliasRet)->&(cData)),2) == "00"
					cData := "E2_EMIS1"
				EndIf

				//Validação de MV_PAR09 (Considera Data PCC?)
				If cCdRet == '5952'

					Do Case //Titulos de outros impostos
						Case MV_PAR09 == 1 // Data de emissao digitada
							cData  := "E2_EMIS1"
						Case MV_PAR09 == 2// Vencimento
							cData  := "E2_VENCTO"
						Case MV_PAR09 == 3 //Vencimento real
							cData  := "E2_VENCREA"
						Case MV_PAR09 == 4 //Data de Baixa
							cData := "E2_BAIXA"
						Case MV_PAR09 == 5 // Data de emissao real
							cData  := "E2_EMISSAO"
					EndCase

				EndIf

				// Se existir o ano na chave do SR4
				// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
				cChaveSr4 := xFilial("SR4")+ SRL->RL_MAT+ SRL->RL_CPFCGC + cCdRet + STRZERO(YEAR((cAliasRet)->&cData),4) + STRZERO(MONTH((cAliasRet)->&cData),2)

				// Gera valor do Rendimento
				nRendTributavel	:=	(cAliasRet)->E2_VALOR

				If (cAliasRet)->E2_PRETPIS = '1' .And. (cAliasRet)->E2_PRETCOF = '1' .And. (cAliasRet)->E2_PRETCSL = '1'
					If (cAliasRet)->E2_SALDO == 0 .And. !Empty((cAliasRet)->E2_BAIXA) //Trata-se da ultima baixa.
						nRendTributavel	+=	(cAliasRet)->E2_VRETPIS + 	(cAliasRet)->E2_VRETCOF + 	 (cAliasRet)->E2_VRETCSL
					Endif
				ElseIf Empty((cAliasRet)->E2_PRETPIS) 	.and. Empty((cAliasRet)->E2_PRETCOF) .and. Empty((cAliasRet)->E2_PRETCSL)
					If !__lPccBaixa
						nRendTributavel += (cAliasRet)->E2_PIS + (cAliasRet)->E2_COFINS + (cAliasRet)->E2_CSLL
					EndIf
				Endif

				nRendTributavel	+=	(cAliasRet)->E2_INSS

				If !lIRPFBaixa
					nRendTributavel	+=	(cAliasRet)->E2_IRRF
				Endif

				If !lCalcIssBx
					nRendTributavel	+=	(cAliasRet)->E2_ISS
				Endif

				lGrava	:=	 .F.

				// Tipo do rendimento considera tipo da entidade
				If lTpEnt
					If Empty((cAliasRet)->A2_TPENT)
						cTpRen := "A"
					Else
						If (cAliasRet)->A2_TPENT == "1"	 // Fornecedores Imunes
							cTpRen := "I2"
						ElseIf (cAliasRet)->A2_TPENT == "2"  // Fornecedores Isentos
							cTpRen := "I3"
						EndIf
					EndIf
				Else
					cTpRen := "A"
				EndIf

				If !SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) +SRL->RL_PAIS + SRL->RL_NIFEX ))

					If nRendTributavel > 0

						Reclock("SR4", .T.)

						SR4->R4_FILIAL  := xFilial("SR4")
						SR4->R4_MAT     := SRL->RL_MAT
						SR4->R4_CPFCGC  := SRL->RL_CPFCGC
						SR4->R4_MES     := STRZERO(MONTH((cAliasRet)->&(cData)),2)
						SR4->R4_TIPOREN := cTpRen
						SR4->R4_CODRET  := cCdRet
						SR4->R4_ANO  := STRZERO(YEAR((cAliasRet)->&(cData)),4)
						SR4->R4_VALOR   := nRendTributavel
						SR4->R4_ORIGEM := "2"
						SR4->R4_PAIS 	:= SRL->RL_PAIS
						SR4->R4_NIFEX := SRL->RL_NIFEX

						If !Empty(SRL->RL_PAIS) .And. IsCodResExt(SRL->RL_CODRET)
							SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
							If lISNIF
								SR4->R4_ISNIF := Iif(lTemNIF,"1","2")
							EndIf
						EndIf

						SR4->(MsUnlock())

						Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCdRet , STRZERO(MONTH((cAliasRet)->&(cData)),2) 	, "A",;
													(cAliasRet)->E2_FILIAL,(cAliasRet)->E2_PREFIXO, (cAliasRet)->E2_NUM, (cAliasRet)->E2_PARCELA,;
													(cAliasRet)->E2_TIPO,(cAliasRet)->E2_NATUREZ, nRendTributavel, cNIFEX )

						lGrava	:=	 .T.
					EndIf
				Else
					Reclock("SR4", .F.)
					SR4->R4_VALOR   += nRendTributavel
					SR4->(MsUnlock())

					Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCdRet , STRZERO(MONTH( (cAliasRet)->&(cData)),2) 	, "A",;
														(cAliasRet)->E2_FILIAL,(cAliasRet)->E2_PREFIXO, (cAliasRet)->E2_NUM, (cAliasRet)->E2_PARCELA,;
														(cAliasRet)->E2_TIPO,(cAliasRet)->E2_NATUREZ, nRendTributavel, cNIFEX )

					lGrava	:=	 .T.
				Endif
			
			Next nI

			If	lGrava
				Reclock("TMP1", .T.)
				TMP1->NROREG 		:= (cAliasRet)->R_E_C_N_O_
				TMP1->TITIPAI		:= .F.
				TMP1->(MSUNLOCK())

				Reclock("TMP", .T.)
				TMP->NROREG 		:= (cAliasRet)->R_E_C_N_O_
				TMP1->TITIPAI		:= .F.
				TMP->(MSUNLOCK())
			Endif
			Aadd(aRecno, (cAliasRet)->R_E_C_N_O_)
		Endif

		(cAliasRet)->(DbSkip())

		If !Empty(MV_PAR06) // Se possuir filial centralizadora, posiciona nesta filial
			cFilAnt := cFilAtu
		Endif
	Enddo

	If !Empty(MV_PAR06) // Restauro a filial do sistema quando processar com filial centralizadora.
		cFilAnt := cFilAtu
	Endif

	If TMP->(Eof()) .And. lReproc//Faz a exclusao das datas da dirf no caso de reprocessamento.
		aAreaSE2 := SE2->(GetArea())
		While !(TMP->(Eof()))
			SE2->(Dbgoto(TMP->NROREG))
			SE2->(RecLock())
			SE2->E2_DTDIRF := Ctod("  /  /  ")
			SE2->(MsUnlock())
			TMP->(DbSkip())
		EndDo
		SE2->(RestArea(aAreaSE2))
	Endif

	TMP->(DbCloseArea())
	(cAliasRet)->(DBCloseArea())

	//Deleta tabela temporária no banco de dados, caso exista
	If _oFINA4012 <> Nil
		_oFINA4012:Delete()
		_oFINA4012 := Nil
	Endif

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CriaTMPºAutor  ³  Totvs             º Data ³  07/08/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cria tabela temporaria para armazenar registro conciliados, º±±
±±º          ³não conciliadas evitando ascan em array                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CriaTMP(aCampos,cArq,cAlias,cArqINDEX,cChave)
Local aSaveArea	:= GetArea()

If ALLTRIM(cAlias) == "TMP1"

	If Select(cAlias) > 0
		(cAlias)->(DbCloseArea())
	EndIf

	//------------------
	//Criação da tabela temporaria
	//------------------
	If _oFINA4011 <> Nil
		_oFINA4011:Delete()
		_oFINA4011 := Nil
	Endif

	_oFINA4011 := FWTemporaryTable():New( cAlias )
	_oFINA4011:SetFields(aCampos)
	_oFINA4011:AddIndex("1", {cChave})
	_oFINA4011:Create()

Else

	If Select(cAlias) > 0
		(cAlias)->(DbCloseArea())
	EndIf

	//------------------
	//Criação da tabela temporaria
	//------------------
	If _oFINA4012 <> Nil
		_oFINA4012:Delete()
		_oFINA4012 := Nil
	Endif

	_oFINA4012 := FWTemporaryTable():New( cAlias )
	_oFINA4012:SetFields(aCampos)
	_oFINA4012:AddIndex("1", {cChave})
	_oFINA4012:Create()

Endif

RestArea( aSaveArea )

Return nil

Static Function f401LimpaDt(cTipoIn,lErroUpd)
Local cQuery := ""
Local cUpdate := ""
Local cCompSA2 := FWModeAccess( "SA2" , 1 ) + FWModeAccess( "SA2" , 2 ) + FWModeAccess( "SA2" , 3 )
Local nTamFilSA2 := If( "E" $ cCompSA2, Len(Alltrim(xFilial("SA2"))) , 0 )


cQuery += " LEFT JOIN " + RetSqlName("SE2") +" PAI ON "
cQuery += " (SE2.E2_FILIAL = PAI.E2_FILIAL AND "
If "MYSQL" $ cBDname
	cQuery += cQryConcat+" PAI.E2_PREFIXO,PAI.E2_NUM,PAI.E2_PARCELA,PAI.E2_TIPO,PAI.E2_FORNECE,PAI.E2_LOJA) = SE2.E2_TITPAI AND "
ElseIf cBDname $ "DB2|POSTGRES|MSSQL"  .OR. ( cBDname == "DB2/400" .And. Upper(cSrvType) == "ISERIES" )
	cQuery += " PAI.E2_PREFIXO = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,1," +STR(nTamPref) + "))"
	cQuery += " AND PAI.E2_NUM = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+1) +"," + STR(nTamNum) + "))"
	cQuery += " AND PAI.E2_PARCELA =  RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+nTamNum+1)+","+STR(nTamPar)+"))"
	cQuery += " AND PAI.E2_TIPO = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+nTamNum+nTamPar+1)+","+STR(nTamTipo)+"))"
	cQuery += " AND PAI.E2_FORNECE = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI,"+STR(nTamPref+nTamNum+nTamPar+nTamTipo+1)+","+STR(nTamFor)+"))"
	cQuery += " AND PAI.E2_LOJA = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI,"+STR(nTamPref+nTamNum+nTamPar+nTamTipo+nTamFor+1)+","+STR(nTamLj)+")) AND"

Else
	cQuery += " PAI.E2_PREFIXO" +cQryConcat+"PAI.E2_NUM"+cQryConcat+"PAI.E2_PARCELA"+cQryConcat+"PAI.E2_TIPO"+cQryConcat+"PAI.E2_FORNECE"+cQryConcat+"PAI.E2_LOJA = SE2.E2_TITPAI AND "
EndIf
If !Empty(cTipoIn)
	cQuery += " PAI.E2_TIPO NOT IN " + cTipoIn + " AND "
EndIf
cQuery += " PAI.D_E_L_E_T_= ' ' )"

cQuery += " JOIN " +  RetSqlName("SA2") + " SA2 ON "
cQuery += "(PAI.E2_FORNECE = SA2.A2_COD AND PAI.E2_LOJA = SA2.A2_LOJA AND SA2.D_E_L_E_T_ = ' ' "
If nTamFilSA2 > 0
		If cBDname $ "ORACLE|DB2|POSTGRES|INFORMIX"
		cQuery += " AND SUBSTR(SA2.A2_FILIAL,1," +str(nTamFilSA2) +" ) = SUBSTR(PAI.E2_FILORIG,1,"+str(nTamFilSA2)+") "
	Else
		cQuery += " AND SUBSTRING(SA2.A2_FILIAL,1,"+str(nTamFilSA2)+") = SUBSTRING(PAI.E2_FILORIG,1,"+str(nTamFilSA2)+") "
	EndIf
EndIf

If MV_PAR04 == 1 //Fisico
	//Se for PJ com IR Progressivo, será tratado como Pessoa Física.
	cQuery +=	" AND (SA2.A2_TIPO = 'F' OR (SA2.A2_TIPO = 'J' AND SA2.A2_IRPROG = '1')) "
Else
	cQuery +=	" AND (SA2.A2_TIPO = 'X' OR (SA2.A2_TIPO = 'J' AND SA2.A2_IRPROG != '1')) "
Endif
cQuery += ") "


cQuery += " WHERE "
If MV_PAR08 <> 1
	cQuery += " SE2.E2_FILIAL = '" + cFilAnt + "' AND "
Endif

cQuery += "   SE2.E2_DIRF IN ('1','S','2') AND "
cQuery += "   SE2.E2_CODRET != ' ' AND "
If !Empty(cTipoIn)
	cQuery += " SE2.E2_TIPO IN " + cTipoIn + " AND "
EndIf

Do Case
	Case MV_PAR01 == 1 // Data de emissao digitada
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		EndIf
	Case MV_PAR01 == 2// Vencimento
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		Endif

	Case MV_PAR01 == 3 //Vencimento real
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		Endif

	Case MV_PAR01 == 4 //Data de Baixa
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ((SE2.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
			cQuery += " (SE2.E2_BAIXA = ' ' AND "
			cQuery += " SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) ) ) OR "
		EndIf

	Case MV_PAR01 == 5 // Data de emissao real
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		EndIf
EndCase

Do Case
	Case MV_PAR09 == 1 // Data de emissao
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		EndIf

	Case MV_PAR09 == 2// Vencimento
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		Endif

	Case MV_PAR09 == 3 //Vencimento real
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		Endif

	Case MV_PAR09 == 4 //Data de Baixa
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND (SE2.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) "
		EndIf

	Case MV_PAR09 == 5 //Data de Emissao Real
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND (SE2.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) "
		EndIf
EndCase

IF MV_PAR05 == 2
  	cQuery += " AND SE2.D_E_L_E_T_ = ' '"
Else
  	cQuery += " SE2.D_E_L_E_T_ = ' '"
Endif


cUpdate := "UPDATE " + RetSqlName("SE2")  + " SET E2_DTDIRF = ' ' "
cUpdate += "WHERE R_E_C_N_O_ IN(  SELECT PAI.R_E_C_N_O_  FROM " + RetSqlName("SE2") + " SE2 "
cUpdate += cQuery + ")"
If TcSqlExec(cUpdate) <> 0
	MsgStop( "Erro ao limpar registros Pai: " + TCSQLError() )
	lErroUpd := .T.
EndIf


cUpdate := "UPDATE " + RetSqlName("SE2")  + " SET E2_DTDIRF = ' ' "
cUpdate += "WHERE R_E_C_N_O_ IN(  SELECT SE2.R_E_C_N_O_  FROM " + RetSqlName("SE2") + " SE2 "
cUpdate += cQuery + ")"
If TcSqlExec(cUpdate) <> 0
	MsgStop( "Erro ao limpar registros: " + TCSQLError() )
	lErroUpd := .T.
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RetValCMPºAutor  ³  Karen Honda       º Data ³  14/12/16    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna o valor compensado do titulo.                       ¹±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function RetValCMP(cAliasPai, lImpEmissao,lIrBx,lCalcIssBx,nImpEmis)
Local nSomaBxPA := 0
Local aAreaSE2 := SE2->(GetArea())
Local nImpEmisPa := 0
Local lBaixaTotNF := .F.
Local cPrefixo := (cAliasPai)->E2_PREFIXO
Local cNum := (cAliasPai)->E2_NUM
Local cParcela := (cAliasPai)->E2_PARCELA
Local cTipo := (cAliasPai)->E2_TIPO
Local cFornece := (cAliasPai)->E2_FORNECE
Local cLoja := (cAliasPai)->E2_LOJA
Local nValorTotPA	:= 0
Local nProp	:= 0
Local nPropImpEmis := 0
Local nRecSe5NF := 0
Local lCheqLib := .F.
Local nTotSomaBx := 0

Default lImpEmissao := .F.

nImpEmis := 0
If cTipo $ MVPAGANT
	nValorTotPA := (cAliasPai)->E2_VALOR
	If !__lPaBruto

		nValorTotPA += (cAliasPai)->(E2_INSS+ E2_PRINSS)
		nValorTotPA += (cAliasPai)->(E2_ISS+ E2_PRISS)
		nValorTotPA += (cAliasPai)->(E2_PIS+E2_COFINS+E2_CSLL)
		nValorTotPA += (cAliasPai)->(E2_IRRF)

	EndIf
EndIf

SE2->(DBSetOrder(1))
SE5->(DBSetOrder(7)) //E5_FILIAL, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA, E5_SEQ, R_E_C_N_O_, D_E_L_E_T_
If SE5->(DbSeek(xFilial("SE5") + cPrefixo + cNum + cParcela + cTipo + cFornece + cLoja ))

	While SE5->(!Eof()) .and. SE5->(E5_FILIAL+ E5_PREFIXO+ E5_NUMERO+ E5_PARCELA+ E5_TIPO+ E5_CLIFOR+ E5_LOJA) == xFilial("SE5") + cPrefixo + cNum + cParcela + cTipo + cFornece + cLoja
		If !SE5->E5_SITUACA $ ( 'C' , 'E' , 'X' ) .AND. SE5->E5_TIPODOC <> 'ES' .and. !TemBxCanc2()
			nPropImpEmis := 0
			If !cTipo $ MVPAGANT
	 			// Se for NF, verifica se houve compensacao com alguma PA e retorna o valor compensado
				If SE5->E5_MOTBX == 'CMP' .and. SE5->E5_TIPODOC $ 'CP|BA|VL'
					nSomaBxPA += SE5->(E5_VALOR)


					nSomaBxPA += SE5->(E5_VRETPIS + E5_VRETCOF+E5_VRETCSL+E5_VRETIRF)

					//Verificar se houve uma compensacao total, se sim, soma os impostos da emissao

					If (cAliasPai)->E2_SALDO == 0
						nImpEmisPa := 0
						nImpEmisPa += (cAliasPai)->(E2_INSS+ E2_PRINSS)

						If !lCalcIssBx
							nImpEmisPa += (cAliasPai)->(E2_ISS+ E2_PRISS)
						EndIf
						If !__lPccBaixa
							nImpEmisPa += (cAliasPai)->(E2_PIS+E2_COFINS+E2_CSLL)
						EndIf
						If !lIrBx
							nImpEmisPa += (cAliasPai)->(E2_IRRF)
						EndIf

						//se foi a ultima baixa soma os impostos da emissao
						If IsTheLastPost((cAliasPai)->E2_PREFIXO,(cAliasPai)->E2_NUM,(cAliasPai)->E2_PARCELA,(cAliasPai)->E2_TIPO,(cAliasPai)->E2_FORNECE,(cAliasPai)->E2_LOJA)
							nSomaBxPA += nImpEmisPa
							lBaixaTotNF := .T.
						Else
							nSomaBxPA := 0
						EndIf
					Else
						nSomaBxPA := 0
					EndIf

					//Se nao for baixa total , procura o PA com o qual foi compensado para ver se houve baixa total da PA
					If !lBaixaTotNF .and. SE2->(DBSeek(xFilial("SE2")+ Rtrim(SE5->E5_DOCUMEN)))

						nValorTotPA := SE2->E2_VALOR

						If !__lPaBruto

							nImpEmisPa := 0
							nImpEmisPa += SE2->(E2_INSS+ E2_PRINSS)
							nImpEmisPa += SE2->(E2_ISS+ E2_PRISS)
							nImpEmisPa += SE2->(E2_PIS+E2_COFINS+E2_CSLL)
							nImpEmisPa += SE2->(E2_IRRF)

							nValorTotPA += 	nImpEmisPa

						EndIf

						//localiza a SE5 da compensacao da PA
						nRecSe5NF := SE5->(Recno())
						If SE5->(DBSeek(xFilial("SE5")+ SE2->(E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA ) + SE5->E5_SEQ ))

							nSomaBxPA += SE5->(E5_VALOR)

							//pega a proporcao para obter o valor do INSS e ISS proporcional, pois o mesmo nao eh gravado na SE5 e nem na SE2
							If SE2->E2_IRRF > 0
								nProp := (SE5->E5_VRETIRF/SE2->E2_IRRF)
							ElseIf (cAliasPai)->E2_PIS > 0
								nProp := (SE5->E5_VRETPIS/SE2->E2_PIS)
							EndIf


							If !__lPaBruto
								nPropImpEmis += SE2->(E2_INSS+E2_PRINSS) * nProp
								nPropImpEmis += SE2->(E2_ISS+E2_PRISS) * nProp

								nImpEmis +=  nPropImpEmis
								//nSomaBxPA += nPropImpEmis
								nSomaBxPA += SE5->(E5_VRETPIS + E5_VRETCOF+E5_VRETCSL+E5_VRETIRF )
							EndIf

							//se a baixa foi total da PA, reomponho o valor dos impostos da emissao
							If SE2->E2_SALDO == 0 .and. nSomaBxPA +If(!__lPaBruto, nPropImpEmis ,0)== nValorTotPA
								nSomaBxPA += nPropImpEmis
							Else
								nImpEmis := 0

								If __lPccBaixa
									nImpEmis += SE5->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
								EndIf
								If lIrBx
									nImpEmis += SE5->E5_VRETIRF
								EndIf
							EndIf
						EndIf
						SE5->(DBGoto(nRecSe5NF))
					EndIf

					nTotSomaBx += nSomaBxPA
				EndIf
			Else

				//se imposto for na emissao, sera gerado na NF, logo se a PA for compensada, deve ser desconsiderada
				If lImpEmissao
					If SE5->E5_MOTBX == 'CMP' .AND. SE5->E5_TIPODOC $ 'CP|BA|VL'
						nSomaBxPA += SE5->E5_VALOR

						//faz a regra de 3 para achar a proporcao para pegar o valor do ISS e INSS descontado do saldo
						//pois este valor nao sao gravados na compensacao
						nProp := 0
						If (cAliasPai)->E2_IRRF > 0
							nProp := (SE5->E5_VRETIRF/(cAliasPai)->E2_IRRF)
						ElseIf (cAliasPai)->E2_PIS > 0
							nProp := (SE5->E5_VRETPIS/(cAliasPai)->E2_PIS)
						EndIf

						If !__lPaBruto
							nPropImpEmis += (cAliasPai)->(E2_INSS+E2_PRINSS) * nProp
							nPropImpEmis += (cAliasPai)->(E2_ISS+E2_PRISS) * nProp

						EndIf
						//verifica se houve compensacao total
						If (cAliasPai)->E2_SALDO == 0 .and. SE5->(E5_VALOR+ E5_VRETPIS + E5_VRETCOF+E5_VRETCSL+E5_VRETIRF) +If(!__lPaBruto, nPropImpEmis ,0)== nValorTotPA
							nSomaBxPA += nPropImpEmis
							nSomaBxPA += SE5->( E5_VRETPIS + E5_VRETCOF+E5_VRETCSL+E5_VRETIRF)
						EndIf

					EndIf
				EndIf

				//se for PA verifica se PA foi baixada sem ser por compensacao, o que significa o seu cancelamento
				//e retorna o valor da baixa
				If SE5->E5_MOTBX <> 'CMP' .AND. SE5->E5_TIPODOC $ 'VL'
					If (cAliasPai)->E2_SALDO == 0 .and. SE5->E5_VALOR == (cAliasPai)->E2_VALOR
						nSomaBxPA := nValorTotPA
					EndIf

				Else

					//Verifica se houve movimentacao bancaria para envio da pa
					If (SE5->E5_TIPODOC $ "BA/CH" .And. !Empty(SE5->E5_NUMCHEQ) .And. SubStr(SE5->E5_NUMCHEQ,1,1) <> "*") .OR. SE5->E5_TIPODOC $ "VL"
						lCheqLib := .T.
					EndIf

					If SE5->E5_TIPODOC $ "PA"
						lCheqLib	:= .T.
					EndIf

				Endif

				nTotSomaBx += nSomaBxPA
			EndIf

		EndIf
		SE5->(DBSkip())
	EndDo
EndIf
//nao houve movimentacao bancaria da PA, nao enviar
If cTipo $ MVPAGANT .and. !lCheqLib
	nTotSomaBx := nValorTotPA
EndIf
nImpEmis := abs(nImpEmis)
RestArea(aAreaSE2)
Return nTotSomaBx

//-------------------------------------------------------------------
/*/{Protheus.doc} ValRenPCC
Retorna valor de rendimento do PCC
@author Igor Sousa do Nascimento
@since  05/01/2018
/*/
//-------------------------------------------------------------------
Function ValRenPCC( cAlias1, cAlias2, aUltPCC, cSeqBX, lRendIR )

Local aArea		:= GetArea()
Local aAlias1	:= {}
Local aAreaTRB	:= {}
Local aBaixas	:= {}
Local lConsVA	:= SuperGetMv("MV_IMPBAIX",.T.,"2") == "1"
Local lRetEmis	:= .F.
Local nValRend	:= 0

Local nX		:= 0

Local nProp		:= 1
Local nValOri	:= 0
Local lUltBx	:= .F.

Default cAlias1	:= Alias()
Default cAlias2	:= cAlias1
Default cSeqBX	:= ""
Default lRendIR	:= .F.


aAlias1	 := (cAlias1)->( GetArea() )
If !lRendIR
	aAreaTRB := (cAlias2)->( GetArea() )

	DbSelectArea(cAlias1)
	(cAlias1)->( DbSetOrder(1) )
EndIf	
DbSelectArea("SE5")
SE5->( DbSetOrder(1) )

aBaixas := GetPosts( xFilial("SE5", (cAlias1)->E2_FILORIG),;
					(cAlias1)->E2_PREFIXO,;
					(cAlias1)->E2_NUM,;
					(cAlias1)->E2_PARCELA,;
					(cAlias1)->E2_TIPO,;
					(cAlias1)->E2_FORNECE,;
					(cAlias1)->E2_LOJA,;
					"SE5.E5_TIPODOC IN ('VL','BA','CP')")

// Verifica se a ultima baixa teve seu valor abatido de retencao de imposto de baixas anteriores
If Len(aBaixas) > 0
	For nX := 1 to Len(aBaixas)

		SE5->(dbGoTo(aBaixas[nX]))
		//desconsidera o registro de IR gerado na baixa pelo bordero, pois está somando o valor do IR 2x
		If AllTrim(SE5->E5_MOTBX) $ "IRF|ISS" .and. AllTrim(SE5->E5_ORIGEM) $ "FINA241|FINA750"
			Loop
		EndIf
		lUltBx := .F.
		If Empty(cSeqBX) .or. (!EMPTY(cSeqBX) .AND. SE5->E5_SEQ == cSeqBX)
			lUltBx := (cAlias1)->E2_SALDO == 0 .and. IsTheLastPost(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)
			
			If __lPccBaixa
				If SE5->E5_VRETPIS+SE5->E5_VRETCOF+SE5->E5_VRETCSL > 0
					If AllTrim(SE5->E5_MOTBX) $ "PCC" .and. AllTrim(SE5->E5_ORIGEM) $ "FINA241|FINA590|FINA750" 	// PCC gerado no bordero de impostos
						If !Empty(aAreaTRB)
							RestArea(aAreaTRB)
						EndIf
						nValRend += (cAlias1)->E2_VALOR
						If !lIrBx
							nValRend += (cAlias1)->E2_IRRF
						EndIf
						If !lCalcIssBx
							nValRend += (cAlias1)->E2_ISS
						EndIf
						nValRend += (cAlias1)->E2_INSS
						nX++
						Exit
					Else
						If __lValPgto 
							nValRend += SE5->E5_VRETPIS+SE5->E5_VRETCOF+SE5->E5_VRETCSL
						ElseIf lUltBx
							nValRend += (cAlias1)->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
						EndIf
					EndIf
				EndIf
			Else
				nValRend += (cAlias1)->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
			EndIf
			nValRend += SE5->E5_VALOR
			If lIrBx
				If __lValPgto 
					nValRend += SE5->E5_VRETIRF
				ElseIf lUltBx
					nValRend += (cAlias1)->E2_VRETIRF
				EndIf
			ElseIf lUltBx .or. !__lPccBaixa
				If SA2->A2_MINIRF == "1" .Or. (cAlias1)->E2_IRRF > GetMv("MV_VLRETIR") .or. ;
					 ((cAlias1)->E2_IRRF == (cAlias1)->E2_VRETIRF .and. !Empty((cAlias1)->E2_PARCIR ) )
					nValRend += (cAlias1)->E2_IRRF
				EndIf
			EndIf
			If lCalcIssBx
				If __lValPgto 
					nValRend += SE5->E5_VRETISS
				ElseIf 	lUltBx
					nValRend += (cAlias1)->E2_ISS
				EndIf
			ElseIf lUltBx
				nValRend += (cAlias1)->E2_ISS
			EndIf
			If lUltBx
				nValRend += (cAlias1)->E2_VRETINS
			EndIf	
			nValRend += SE5->E5_VLCORRE
			If !lConsVA
				If Upper(SE5->E5_TPDESC) == "I" .or. (cAlias1)->E2_DECRESC > 0
					nValRend += SE5->E5_VLDESCO
				EndIf
				nValRend -= SE5->E5_VLJUROS
				nValRend -= SE5->E5_VLMULTA
			EndIf

			//Se for uma fatura, verifica se foi a ultima baixa para pegar o rendimento correto
			If Alltrim((cAlias1)->E2_FATURA) == "NOTFAT" .and. lUltBx
				If Alltrim((cAlias2)->E2_NATUREZ) $ cMVPISNAT
					nValRend += (cAlias1)->E2_BASEPIS - (cAlias1)->E2_VALOR
				ElseIf Alltrim((cAlias2)->E2_NATUREZ) $ cMVCOFNAT
					nValRend += (cAlias1)->E2_BASECOF - (cAlias1)->E2_VALOR
				ElseIf Alltrim((cAlias2)->E2_NATUREZ) $ cMVCSLNAT
					nValRend += (cAlias1)->E2_BASECSL - (cAlias1)->E2_VALOR
				ElseIf lRendIR 
					nValRend += (cAlias1)->E2_BASEIRF - (cAlias1)->E2_VALOR
				EndIf
			EndIf

			If !lRetEmis .and. !lRendIR	// Desposiciona SE2 para nao contar os impostos da emissao novamente se houver + baixas
				aAreaTRB := (cAlias1)->(GetArea())
				(cAlias1)->(dbGoBottom())
				(cAlias1)->(dbSkip())
				lRetEmis := .T.
			EndIf

		EndIf
	Next nX
	If !lRendIR .and. ValType(aUltPCC) == "A"
		Aadd(aUltPCC,Alltrim((cAlias2)->E2_CODRET) + SE5->(E5_FILIAL + E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))
	EndIf
	If !Empty(aAreaTRB)
		RestArea(aAreaTRB)
	EndIf	
	nValOri := (cAlias1)->E2_VALOR
	
	//Recompoe valor original com impostos na emissão
	nValOri += Iif(!lCalcIssBx, (cAlias1)->E2_ISS, 0)
	nValOri += Iif(!lIrBx, (cAlias1)->E2_IRRF, 0)
	nValOri += Iif(!__lPccBaixa,  (cAlias1)->(E2_PIS+E2_COFINS+E2_CSLL), 0)
	nValOri += (cAlias1)->E2_INSS
	//Aplica a proporcionalidade da base do pcc sobre o valor pago
	If Alltrim((cAlias2)->E2_NATUREZ) $ cMVPISNAT
		nProp := (cAlias1)->E2_BASEPIS / nValOri
	ElseIf Alltrim((cAlias2)->E2_NATUREZ) $ cMVCOFNAT
		nProp := (cAlias1)->E2_BASECOF / nValOri
	ElseIf Alltrim((cAlias2)->E2_NATUREZ) $ cMVCSLNAT
		nProp := (cAlias1)->E2_BASECSL / nValOri
	ElseIf 	lRendIR
		nProp := (cAlias1)->E2_BASEIRF / nValOri
	EndIf

	nValRend := nValRend * nProp

Else
	If !lIrBx
		nValRend += (cAlias1)->E2_VRETIRF
	EndIf
	If !__lPccBaixa
		nValRend += (cAlias1)->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
	EndIf
	If !lCalcIssBx
		nValRend += (cAlias1)->E2_VRETISS
	EndIf
	nValRend += (cAlias1)->E2_VRETINS
	nValRend += (cAlias1)->E2_SEST
	nValRend += (cAlias1)->E2_RETENC
	nValRend += (cAlias1)->E2_VALOR
	// Verifica base reduzida
	If nValRend <> (cAlias1)->E2_BASEPIS .and. (cAlias1)->E2_VRETPIS > 0 .and. (cAlias1)->E2_BASEPIS > 0
		nValRend := (cAlias1)->E2_BASEPIS
	ElseIf nValRend <> (cAlias1)->E2_BASECOF .and. (cAlias1)->E2_VRETCOF > 0 .and. (cAlias1)->E2_BASECOF > 0
		nValRend := (cAlias1)->E2_BASECOF
	ElseIf nValRend <> (cAlias1)->E2_BASECSL .and. (cAlias1)->E2_VRETCSL > 0 .and. (cAlias1)->E2_BASECSL > 0
		nValRend := (cAlias1)->E2_BASECSL
	ElseIf lIrBx .and. nValRend <> (cAlias1)->E2_BASEIRF
		nValRend := (cAlias1)->E2_BASEIRF
	EndIf
EndIf

RestArea(aArea)
RestArea(aAlias1)

Return nValRend


//-------------------------------------------------------------------
/*/{Protheus.doc} GetPosts
Retorna array com recnos das baixas de um titulo
@param cChave - Chave unica do titulo
@param cFiltro - Filtro para baixas especificas
@author Igor Sousa do Nascimento
@since  05/01/2018
/*/
//-------------------------------------------------------------------
Static Function GetPosts(cXFilial,cPrefixo,cNum,cParcela,cTipo,cFornec,cLoja,cFiltro)

	Local aArea    := GetArea()
	Local aBaixas  := {}
	Local cTmp	   := CriaTrab(,.F.)
	Local cQuery   := ""

	Default cXFilial := ""
	Default cPrefixo := ""
	Default cNum 	 := ""
	Default cParcela := ""
	Default cTipo 	 := ""
	Default cFornec  := ""
	Default cLoja    := ""
	Default cFiltro  := ""

	If Empty(cXFilial) .and. Empty(cPrefixo) .and. Empty(cNum) .and.; 
		Empty(cParcela) .and. Empty(cTipo) .and. Empty(cFornec) .and. Empty(cLoja)
		If "SE2" $ Alias()
			cXFilial := xFilial("SE2")
			cPrefixo := E2_PREFIXO
			cNum 	 := E2_NUM
			cParcela := E2_PARCELA
			cTipo 	 := E2_TIPO
			cFornec  := E2_FORNECE
			cLoja 	 := E2_LOJA
		ElseIf "SE5" $ Alias()
			cXFilial := xFilial("SE5")
			cPrefixo := E5_PREFIXO
			cNum 	 := E5_NUMERO
			cParcela := E5_PARCELA
			cTipo 	 := E5_TIPO
			cFornec  := E5_CLIFOR
			cLoja 	 := E5_LOJA
		EndIf
	EndIf
	cQuery := "SELECT SE5.R_E_C_N_O_ RECNOBX "
	cQuery += "FROM " + RetSqlName("SE5") + " SE5 "
	cQuery += "WHERE "
	cQuery += "SE5.E5_FILIAL = '" + cXFilial + "' "
	cQuery += "AND SE5.E5_PREFIXO = '" + cPrefixo + "' "
	cQuery += "AND SE5.E5_NUMERO = '" + cNum + "' "
	cQuery += "AND SE5.E5_PARCELA = '" + cParcela + "' "
	cQuery += "AND SE5.E5_TIPO = '" + cTipo + "' "
	cQuery += "AND SE5.E5_CLIFOR = '" + cFornec + "' "
	cQuery += "AND SE5.E5_LOJA = '" + cLoja + "' "
	If !Empty(cFiltro)
		cQuery += "AND " + cFiltro
	EndIf
	cQuery += " AND SE5.E5_SITUACA NOT IN ( 'C' , 'E' , 'X' ) "
	cQuery += "AND SE5.E5_NUMERO NOT IN ( "
	cQuery += 			"SELECT SUBSE5.E5_NUMERO FROM " + RetSqlName("SE5") + " SUBSE5 "
	cQuery +=			"WHERE SUBSE5.E5_FILIAL = SE5.E5_FILIAL "
	cQuery += 			"AND SUBSE5.E5_PREFIXO = SE5.E5_PREFIXO "
	cQuery += 			"AND SUBSE5.E5_NUMERO = SE5.E5_NUMERO "
	cQuery += 			"AND SUBSE5.E5_PARCELA = SE5.E5_PARCELA "
	cQuery += 			"AND SUBSE5.E5_TIPO = SE5.E5_TIPO "
	cQuery += 			"AND SUBSE5.E5_CLIFOR = SE5.E5_CLIFOR "
	cQuery += 			"AND SUBSE5.E5_LOJA = SE5.E5_LOJA "
	cQuery += 			"AND SUBSE5.E5_TIPODOC = 'ES' "
	cQuery += 			"AND SUBSE5.E5_SEQ = SE5.E5_SEQ "
	cQuery += 			"AND SUBSE5.D_E_L_E_T_ = ' ' ) "
	cQuery += "AND SE5.D_E_L_E_T_ = ' '"
	cQuery := ChangeQuery(cQuery)
	MPSysOpenQuery(cQuery, cTmp)
	dbSelectArea(cTmp)
	While !(cTmp)->(EoF())
		Aadd(aBaixas, (cTmp)->RECNOBX)
		(cTmp)->(dbSkip())
	EndDo
	(cTmp)->(dbCloseArea())
	RestArea(aArea)

Return aBaixas


//-------------------------------------------------------------------
/*/{Protheus.doc} ForSemCPF
Exibe os fornecedores do tipo pessoa fisica, que contem CPF em branco.
@author  Luiz Henrique Oliveira Silva
@since   05/11/2019
@version 1
/*/
//-------------------------------------------------------------------
Static Function ForSemCPF()
	Local oBrowse
	Local oColumn
	Local oDlg
	

	//Existem Fornecedores com CPF em branco
	//Para geração da Dirf, os seus valores serão aglutinados. Deseja visualizar os Fornecedores?
	If MsgYesNo(STR0044,STR0045) 
		DEFINE DIALOG oDlg FROM 0,0 TO 600,800 PIXEL TITLE STR0050 //Fornecedores com CPF em Branco !

		DEFINE FWFORMBROWSE oBrowse DATA ARRAY ARRAY aEmptyCPF NO SEEK NO CONFIG NO REPORT NO LOCATE Of oDlg

		ADD COLUMN oColumn DATA { || aEmptyCPF[oBrowse:At(),1] } TITLE STR0011 SIZE TamSX3("A2_FILIAL")[1] OF oBrowse // Filial
		ADD COLUMN oColumn DATA { || aEmptyCPF[oBrowse:At(),2] } TITLE STR0046 SIZE TamSX3("A2_COD")[1] OF oBrowse // Codigo do Fornecedor
		ADD COLUMN oColumn DATA { || aEmptyCPF[oBrowse:At(),3] } TITLE STR0047 SIZE TamSX3("A2_LOJA")[1] OF oBrowse // Loja
		ADD COLUMN oColumn DATA { || aEmptyCPF[oBrowse:At(),4] } TITLE STR0048 SIZE TamSX3("A2_NOME")[1] OF oBrowse // Nome
		ADD BUTTON oSair TITLE STR0049 Action { || oDlg:End()} Of oBrowse // Sair

		ACTIVATE FWFORMBROWSE oBrowse

		ACTIVATE DIALOG oDlg CENTERED
	EndIf

	FwFreeArray(aEmptyCPF)	

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} F401IrProg
Função para recompor a base do IR Progressivo

@Param cCnpjCpf, CNPJ/CPF do fornecedor
@Param aBaixas, Array com recnos da tabela SE5
@Return nIrBase, Valor bruto da base do IR 
@author  Vitor Duca
@since   27/12/2019
@version 12
/*/
//-------------------------------------------------------------------
Static Function F401IrProg(cCnpjCpf As Character, aBaixas As Array, lNovoCalc As Logical)
	Local nIrBase  As Numeric
	Local lRatFKJ  As Logical
	Local nY	   As Numeric
	Local aArea	   As Array
	Local aAreaSE5 As Array
	Local aAreaFKJ As Array
	Local lJurMulDes As Logical

	Default aBaixas 	:= {}
	Default cCnpjCpf 	:= ""
	Default lNovoCalc	:= .F.
	
	nIrBase  := 0
	lRatFKJ  := .F.
	nY	   	 := 0
	aArea	 := GetArea() 
	aAreaSE5 := SE5->(GetArea())
	aAreaFKJ := FKJ->(GetArea())
	lJurMulDes := SuperGetMv("MV_IMPBAIX",.t.,"2") == "1"

	FKJ->(DbSetOrder(1))
	If FKJ->(DbSeek(xFilial("FKJ",SA2->A2_FILIAL)+SA2->A2_COD+SA2->A2_LOJA))
		While FKJ->(!Eof()) .and. FKJ->(FKJ_FILIAL+FKJ_COD+FKJ_LOJA) == SA2->(A2_FILIAL+A2_COD+A2_LOJA)
			If AllTrim(cCnpjCpf) == AllTrim(FKJ->FKJ_CPF)
				lRatFKJ := .T.
				Exit
			Endif
			FKJ->(DbSkip())
		EndDo
	Endif	

	For nY := 1 to Len(aBaixas)
		SE5->(DbGoTo(aBaixas[nY]))
		nIrBase += SE5->E5_BASEIRF

		If lJurMulDes
			nIrBase -= SE5->E5_VLDESCO
			nIrBase += SE5->E5_VLJUROS
			nIrBase += SE5->E5_VLMULTA
		EndIf		
	Next nY
	

	If lRatFKJ .and. lNovoCalc
		nIrBase := nIrBase * (FKJ->FKJ_PERCEN/100)
	Endif	

	RestArea(aAreaFKJ)
	RestArea(aAreaSE5)
	RestArea(aArea)

Return nIrBase

//-------------------------------------------------------------------
/*/{Protheus.doc} VerCPFProg
Função que verifica se o calculo do IR Progressivo é legado ou novo calculo
gerando os impostos de acordo com o rateio cadastrado na FKJ

@Param cAliasPai, Tabela temporaria com as informações do titulo pai
@Param cAliasTrb, Tabela temporaria com as informações dos impostos
@aReturn aCPF, Array que sera utilizado na gravação da DIRF

Estrutura do aCPF
		[1]  = CNPJ/CPF de retenção
		[2]  = Percentual (Apenas para calculo do legado)
		[3]  = Nome do fornecedor
		[4]  = Codigo do fornecedor
		[5]  = Loja do fornecedor
		[6]  = Define se o calculo do IR progressivo sera legado ou novo (.T. = Novo, .F. = Legado)

@author  Vitor Duca
@since   30/12/2019
@version 12
/*/
//-------------------------------------------------------------------
Static Function VerCPFProg(cAliasPai As Character,cAliasTrb As Character, lPesqFKJ As Logical)
	Local aCPF 		As Array
	Local aTitulos 	As Array
	Local aArea 	As Array
	Local cCgc      As Character
	Local nPadr     As Numeric
	Default lPesqFKJ := .F.

	aCPF 		:= {}
	aTitulos 	:= {}
	aArea 		:= GetArea()
	cCgc 		:= PADR(SA2->A2_CPFIRP,14)
	nPadr       := 14

	If SA2->A2_TIPO == 'F'
		cCgc  := PADR(SA2->A2_CGC,11)
		nPadr := 11
	ENDIF

	DBSelectArea("FKJ")
	FKJ->(DBSetOrder(1))
	If !lPesqFKJ .AND. !Empty((cAliasTrb)->E2_CNPJRET) .and.  !Empty((cAliasTrb)->E2_NOMERET) // Título Novo
		If FKJ->(MsSeek(xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA + Alltrim((cAliasTrb)->E2_CNPJRET)) )
			Aadd(aCPF, {PADR((cAliasTrb)->E2_CNPJRET,nPadr),FKJ->FKJ_PERCEN,(cAliasTrb)->E2_NOMERET, SA2->A2_COD, SA2->A2_LOJA, .T.})
		Else
			Aadd(aCPF, {cCgc,100,SA2->A2_NOME, SA2->A2_COD, SA2->A2_LOJA, .T.})
		EndIf	
	Else
		If FKJ->(MsSeek(xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA) )
			While FKJ->(!Eof()) .and. FKJ->(FKJ_FILIAL + FKJ_COD + FKJ_LOJA) == xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA
				Aadd(aCPF, {PADR(FKJ->FKJ_CPF,nPadr),FKJ->FKJ_PERCEN,FKJ->FKJ_NOME, SA2->A2_COD, SA2->A2_LOJA, .F.})
				FKJ->(DBSkip())
			EndDo
		Else
			Aadd(aCPF, {cCgc,100,SA2->A2_NOME,SA2->A2_COD, SA2->A2_LOJA,.F.})
		Endif	
	Endif

	RestArea(aArea)

Return aClone(aCPF)

//-------------------------------------------------------------------
/*/{Protheus.doc} CPFSemRet
Função que verifica se o calculo do IR Progressivo rateado em mais de um CPF, possui 
algum IR não retido por não atingir o mínimo

@Param 
@Param 
@aReturn 

@author  Karen Honda
@since   09/01/2020
@version 12
/*/
//-------------------------------------------------------------------
Static Function CPFSemRet(cAliasRet As Character,lIRPFBaixa As Logical, aCPfs As Array, cCdRet As Character, cTipoFj As Character, cNIFEX As Character,cData As Character, aLog As Array, lGerLog As Logical, lTemNif As Logical )

Local cQuery as Character
Local cTmp	 as Character
Local nK as Numeric
Local nRendTributavel as Numeric
Local nRendIR as Numeric
Local cRaMat as Character
Local lGrava as Logical
Local nScan	as Numeric
Local cChaveSr4 as Character
Local cTpRen as Character
Local aCPFRet as Array
Local cAno as Character
Local cMesIni as Character
Local cMesFim as Character

nRendTributavel := 0
nRendIR := 0
cRaMat := ""
lGrava := .F.
nScan := 0
cTpRen := ""
cChaveSr4 := ""
aCPFRet := aClone(aCPFs)
cAno := STRZERO(YEAR((cAliasRet)->&cData),4)
cMesIni := STRZERO(MONTH(MV_PAR02),2)
cMesFim := STRZERO(MONTH(MV_PAR03),2)

// Se for pela data baixa e nao houve o pagamento, considerar data E2_EMIS1
If MV_PAR01 == 4 .and. cAno == "0000"
	cData := "E2_EMIS1"
	cAno := STRZERO(YEAR((cAliasRet)->&cData),4)
EndIf

cTmp  := CriaTrab(,.F.)

For nk := 1 to Len(aCPFs)
	cQuery := "SELECT R4_CPFCGC, R4_CODRET "
	cQuery += " FROM " + RetSqlName("SR4")
	cQuery += " WHERE R4_FILIAL = '" + xFilial("SR4") + "' "
	cQuery += " AND R4_CPFCGC = '" + aCPFs[nK][1] + "' "
	cQuery += " AND R4_ANO = '" + cAno + "' "
	cQuery += " AND R4_MES BETWEEN '" + cMesIni + "' AND '" +  cMesFim + "' "
	cQuery += " AND R4_CODRET = '" + cCdRet + "' "
	cQuery += " AND R4_TIPOREN = 'D' "
	cQuery += " AND D_E_L_E_T_ = ' '"
	cQuery := ChangeQuery(cQuery)
	MPSysOpenQuery(cQuery, cTmp)

	dbSelectArea(cTmp)

	If (cTmp)->( !EoF() ) 
		// possui título de IR gerado. 
		nScan := Ascan(aCPFRet, {|x| Alltrim(x[1]) == Alltrim((cTmp)->R4_CPFCGC)})

		If nScan > 0
			Adel(aCPFRet,nScan)
			Asize(aCPFRet,Len(aCPFRet)-1)
		EndIf

	EndIf
	(cTmp)->( DBCloseArea() ) 	
Next nK

aCpfs := aClone(aCPFRet)

If Len(aCpfs) > 0
	
	nRendIR			:= ValRenPCC( cAliasRet, , , , .T. )
	//não foi gerado o IR
	For nK := 1 To Len(aCPFs)
		
		// Pesquisa cabecalho da DIRF
		If !SRL->(MsSeek(xFilial("SRL")+Padr(SM0->M0_CGC,Len(SRL->RL_CGCFONT))+ cCdRet +;
			cTipoFj+If(SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1',PADR(aCPFs[nK][1],14),Padr(aCPFs[nK][1],Len(SRL->RL_CPFCGC)))+ cNIFEX  ))

			Reclock("SRL", .T.)

			cRaMat := GetSxENum("SRL", "RL_MAT")

			SRL->RL_FILIAL  := xFilial("SRL")
			SRL->RL_MAT     := If(Val(SRA->RA_MAT) < 900000 .And. Val(cRaMat) < 900000, "900000",cRaMat)
			SRL->RL_CODRET  := cCdRet
			SRL->RL_TIPOFJ  := cTipoFj
			SRL->RL_CPFCGC  := If(SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG = '1',Padr(aCPFs[nK][1],14),aCPFs[nK][1])
			SRL->RL_BENEFIC := Substr(aCPFs[nK][3],1,60)
			SRL->RL_ENDBENE := Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END)
			SRL->RL_UFBENEF := SA2->A2_EST
			SRL->RL_COMPLEM := SA2->A2_BAIRRO
			SRL->RL_CGCFONT := SM0->M0_CGC
			SRL->RL_NOMFONT := SM0->M0_NOMECOM
			SRL->RL_ORIGEM := "2"
			SRL->RL_CGCEX := SA2->A2_CGCEX
			SRL->RL_PAIS  := SA2->A2_PAISEX
			SRL->RL_NIFEX := cNIFEX //SA2->A2_NIFEX

			If  IsCodResExt(cCdRet)
				SRL->RL_NEMPR := SA2->A2_NEMPR
				SRL->RL_TPCON := SA2->A2_TPCON
				SRL->RL_DTINI := SA2->A2_DTINIR
				SRL->RL_DTFIM := SA2->A2_DTFIMR
				SRL->RL_LOGEX := SA2->A2_LOGEX
				SRL->RL_NUMEX := SA2->A2_NUMEX
				SRL->RL_COMPL := SA2->A2_COMPLR
				SRL->RL_BAIEX := SA2->A2_BAIEX
				SRL->RL_POSEX := SA2->A2_POSEX
				SRL->RL_CIDEX := SA2->A2_CIDEX
				SRL->RL_ESTEX := SA2->A2_ESTEX
				SRL->RL_TELEX := SA2->A2_TELRE
				SRL->RL_BREEX := SA2->A2_BREEX
				SRL->RL_TPREX := SA2->A2_TPREX
				SRL->RL_TRBEX := SA2->A2_TRBEX
				If !lTemNIF
					If SA2->A2_MOTNIF == "1"                                                                         
						SRL->RL_BEDINI := "1" //Fornecedor dispensado do NIF   
						SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
					Elseif SA2->A2_MOTNIF == "2"             
						SRL->RL_PAEXNI := "2" //País do fornecedor nao exige NIF   
					Endif
				Else
					SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
				Endif
			EndIf
			SRL->(MsUnlock())
		Endif

		// Se existir o ano na chave do SR4
		// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
		cChaveSr4 := xFilial("SR4")+ SRL->RL_MAT+ SRL->RL_CPFCGC + cCdRet + cAno + STRZERO(MONTH((cAliasRet)->&cData),2)

		// Gera valor do Rendimento
		
		nRendTributavel := Round( ( nRendIR * aCPFs[nK][2]) / 100,2 )

		// Tipo do rendimento considera tipo da entidade
		If lTpEnt
			If Empty((cAliasRet)->A2_TPENT)
				cTpRen := "A"
			Else
				If (cAliasRet)->A2_TPENT == "1"	 // Fornecedores Imunes
					cTpRen := "I2"
				ElseIf (cAliasRet)->A2_TPENT == "2"  // Fornecedores Isentos
					cTpRen := "I3"
				EndIf
			EndIf
		Else
			cTpRen := "A"
		EndIf

		If !SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) +SRL->RL_PAIS + SRL->RL_NIFEX ))

			If nRendTributavel > 0

				Reclock("SR4", .T.)

				SR4->R4_FILIAL  := xFilial("SR4")
				SR4->R4_MAT     := SRL->RL_MAT
				SR4->R4_CPFCGC  := SRL->RL_CPFCGC
				SR4->R4_MES     := STRZERO(MONTH((cAliasRet)->&(cData)),2)
				SR4->R4_TIPOREN := cTpRen
				SR4->R4_CODRET  := cCdRet
				SR4->R4_ANO  := STRZERO(YEAR((cAliasRet)->&(cData)),4)
				SR4->R4_VALOR   := nRendTributavel
				SR4->R4_ORIGEM := "2"
				SR4->R4_PAIS 	:= SRL->RL_PAIS
				SR4->R4_NIFEX := SRL->RL_NIFEX

				If !Empty(SRL->RL_PAIS) .And. IsCodResExt(SRL->RL_CODRET)
					SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
					If lISNIF
						SR4->R4_ISNIF := Iif(lTemNIF,"1","2")
					EndIf
				EndIf

				SR4->(MsUnlock())

				Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCdRet , STRZERO(MONTH((cAliasRet)->&(cData)),2) 	, "A",;
											(cAliasRet)->E2_FILIAL,(cAliasRet)->E2_PREFIXO, (cAliasRet)->E2_NUM, (cAliasRet)->E2_PARCELA,;
											(cAliasRet)->E2_TIPO,(cAliasRet)->E2_NATUREZ, nRendTributavel, cNIFEX )

				lGrava := .T.	
			EndIf
		Else
			Reclock("SR4", .F.)
			SR4->R4_VALOR   += nRendTributavel
			SR4->(MsUnlock())

			Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCdRet , STRZERO(MONTH( (cAliasRet)->&(cData)),2) 	, "A",;
											(cAliasRet)->E2_FILIAL,(cAliasRet)->E2_PREFIXO, (cAliasRet)->E2_NUM, (cAliasRet)->E2_PARCELA,;
											(cAliasRet)->E2_TIPO,(cAliasRet)->E2_NATUREZ, nRendTributavel, cNIFEX )

			lGrava := .T.
		Endif

	Next nK 	

EndIf
	
Return lGrava

/*/{Protheus.doc} VldLicenca
Verifica se a rotina selecionada está sendo chamada com licença de uso para o módulo de origem 
@type function
@version 12 
@author gabriel.asantos
@since 03/02/2023
@return logical, Se retorno verdadeiro então possui licença, caso contrário não possui licença
/*/
Static Function VldLicenca() As Logical
	Local lRet As Logical

	FwBlkUserFunction(.T.)
	lRet := AmIIn(SIGAFIN)
	FwBlkUserFunction(.F.)
	
Return lRet

/*/{Protheus.doc} DedIrSimp
Função que retorna o valor de dedução do IRPF Simplificado
@type function
@version 12 

@Param cMes, mês de calculo do IRPF
@Param cAno, Ano de calculo do IRPF
@Param nValorBase, base de calculo do IRPF
@Param nDedBase, deduções legais de calculo do IRPF

@author Pâmela Bernardo
@since 23/01/2024
@return Valor de Dedução do IRPF Simplificado.
/*/
Static Function DedIrSimp(cMes As Character, cAno As Character, nValorBase As Numeric, nDedBase As Numeric) As Numeric
	Local nCalcIRF 		As Numeric
	Local nCalcSimp 	As Numeric 
	Local nDedSimp 		As Numeric
	Local dVigMP1171 	As Date
	Local lCalc2023		As Logical

	Default cMes 		:= StrZero(Month(MV_PAR02),2)
	Default cAno 		:= StrZero(Year(MV_PAR02),4)
	Default nValorBase 	:= 0
	Default nDedBase 	:= 0

	nCalcIRF 	:= 0
	nCalcSimp 	:= 0
	nDedSimp 	:= 0
	dVigMP1171 	:= CTOD("01/"+cMes+"/"+cAno)
	lCalc2023 	:= LastDay(dVigMP1171) <= CTOD("31/01/2024") 

	If __lDicSimpl == NIL
	    __lDicSimpl := FK4->(FieldPos("FK4_DEDIRS")) > 0
	Endif

	If dVigMP1171 >= CTOD("01/05/2023") .And. lCalc2023 .And. __lFMP1171
		nCalcIRF := Round(NoRound(Fa401TabIr(Round(nValorBase-nDedBase,MsDecimais(1))),3),2)
		nCalcSimp := Round(NoRound(Fa401TabIr(Round(nValorBase,MsDecimais(1)),.T.),3),2)

		If nCalcIRF > nCalcSimp
			nDedSimp := 528
		EndIf
	ElseIf __lDicSimpl
		nDedSimp := FDedSimp(SA2->A2_CGC, MV_PAR02, MV_PAR03)
	EndIf

Return nDedSimp
//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa401TabIr

Cálculo de IRRF aplicando a tabela progressiva ano calendário 05/2023 a 01/2024.

@param nValTitulo = Valor do titulo na moeda do titulo
@param lIrTabSimp = Define se o calculo do IRPF terá a dedução simplificada (MP 1.171/2023)

@return nValor, Numeric, retorna o valor do IR já calculado com as deduções

@Author	Pâmela Bernardo
@since	14/02/2024
/*/
//-----------------------------------------------------------------------------------------------------
Static Function Fa401TabIr( nValTitulo As Numeric, lIrTabSimp As Logical ) As Numeric
	Local nValor	 As Numeric
	Local nDescSimpl As Numeric
	Local aTabela	 As Array
	Local lTabela	 As Logical
	Local nI		 As Numeric
	Local lRound 	 As Logical

	Default nValTitulo 	:= 0
	Default lIrTabSimp 	:= .F.
	
	nValor		:= 0
	nDescSimpl  := 528
	aTabela		:= {}
	lTabela	 	:= .F.
	nI		 	:= 0
	lRound 	 	:= GetNewPar( "MV_RNDIRF", .T. ) //Arredonda valor do imposto.

	AADD(aTabela,{2112,0,0})
	AADD(aTabela,{2826.65,7.5,158.40})
	AADD(aTabela,{3751.05,15,370.40})
	AADD(aTabela,{4664.68,22.5,651.73})
	AADD(aTabela,{999999999.99,27.5,884.96})

	If lIrTabSimp
		nValTitulo -= nDescSimpl //Subtrai o desconto simplificado antes de encontrar a faixa na tabela do IR
	EndIf

	For nI = 1 to Len(aTabela)
		If !lTabela
			If nValTitulo<=aTabela[nI][1] .or. nI = Len(aTabela)

				If lRound
					nValor:= Round(nValTitulo * Iif(aTabela[nI][2] > 0, aTabela[nI][2], 0)/100,2)-aTabela[nI][3]
				Else
					nValor:= NoRound(nValTitulo * Iif(aTabela[nI][2] > 0, aTabela[nI][2], 0)/100)-aTabela[nI][3]
				Endif

				lTabela:=.T.
			EndIf
		EndIf
	Next

	nValor := IIF(nValor<0,0,nValor)
Return(nValor)

//-------------------------------------------------------------------
/*/{Protheus.doc} FDedSimp
Função que retorna valor de dedução do IR Simplificado, caso ocorra.

@param cCPF   , Character, CPF do contribuinte (FK4_CGC)
@param dDataIni , Date, Data inicial de processamento
@param dDataFim , Date, Data final de processamento

@return nDedSimp - Numeric, com o valor de dedução, caso seja 0, 
a ultima retenção o calculo foi realizado via tabela. (FK4_DEDIRS)

@author Rodrigo Oliveira
@since 14/01/2026
@version P12
/*/
//-------------------------------------------------------------------
Static Function FDedSimp(cCPF As Character, dDataIni As Date, dDataFim As Date) As Numeric
	Local nDedSimp	As Numeric
	Local cQry		As Character
	Local cTpImp	As Character
	
	Default cCPF     := SA2->A2_CGC
	Default dDataIni := dDataBase
	Default dDataFim := dDataBase
	
	nDedSimp	:= 0
	cQry 		:= ""

	If __nTamIMPO == Nil
		__nTamIMPO := TamSX3('FK4_IMPOS')[1]
	EndIf

	cTpImp		:= "IRF"+Space(__nTamIMPO-3)

	If __oQrySimp == NIL 
		cQry := "SELECT FK4_DEDIRS "
		cQry += " FROM " + RetSqlName("FK4") + " FK4"
		cQry += " WHERE FK4.FK4_CGC = ? "
		cQry += " AND FK4.FK4_IMPOS = ? "
		cQry += " AND FK4.FK4_DATA BETWEEN ? AND ? "
		cQry += " AND FK4.FK4_RECPAG = ? "
		cQry += " AND FK4.FK4_STATUS = ? "
		cQry += " AND FK4.D_E_L_E_T_ = ? "
		cQry += " AND EXISTS ("
		cQry += " 	SELECT FK3_IDRET"
		cQry += " 	FROM " + RetSqlName("FK3") + " FK3"
		cQry += " 	WHERE FK3.FK3_FILIAL = FK4.FK4_FILIAL"
		cQry += " 	AND FK3.FK3_IDORIG = FK4.FK4_IDORIG"
		cQry += " 	AND FK3.FK3_IDRET = FK4.FK4_IDFK4"
		cQry += " 	AND FK3.D_E_L_E_T_ = ? )
		cQry += " ORDER BY R_E_C_N_O_ DESC"

		cQry	:= ChangeQuery(cQry)				
		__oQrySimp	:= FwExecStatement():New(cQry)
	EndIf

	__oQrySimp:SetString(1, cCPF)
	__oQrySimp:SetString(2, cTpImp)
	__oQrySimp:SetString(3, Dtos(dDataIni))
	__oQrySimp:SetString(4, Dtos(dDataFim))
	__oQrySimp:SetString(5, "P")
	__oQrySimp:SetString(6, "1")
	__oQrySimp:SetString(7, " ")
	__oQrySimp:SetString(8, " ")

	nDedSimp := __oQrySimp:ExecScalar('FK4_DEDIRS')

Return nDedSimp
