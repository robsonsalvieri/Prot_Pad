#INCLUDE "FINA717.ch"
#INCLUDE "TOTVS.ch"

Static __lF717LYT := NIL
Static __cLytPers := "N"
Static __lF717GRV := NIL
Static __oPrepSt  := NIL
Static __aStatus  := NIL

/*/{Protheus.doc} FINA717
	Job para transmissão de contas a pagar via api
	@type function
	@version 12.1.2210
	@author jailton.urbano
	@since 13/23/2022
/*/
Function FINA717()
	Local cLockName As Character
	cLockName := cEmpAnt + ' - FINA717'
	If F717VldUso()
		If LockByName(cLockName, .T./*lEmpresa*/, .F./*lFilial*/ ) // uma execução por vez
			F717Pagar()
			UnLockByName(cLockName, .T./*lEmpresa*/, .F./*lFilial*/ )
		EndIf
	EndIf
Return

/*/{Protheus.doc} F717VldUso
	Verifica se o sistema está preparado para uso da api de bancos
	@type function
	@version 12.1.33
	@author jailton.urbano
	@since 15/12/2022
	@return logical, true para o ambiente configurado
/*/
Function F717VldUso() As Logical
	Local lRet As Logical
	lRet := .F.
	If cPaisloc <> 'BRA' .Or. GetRPORelease() < '12.1.033'
		lRet := .F.
	Else
		lRet := SA6->(FieldPos("A6_CFGBOLP")) > 0 .And. SA6->(FieldPos("A6_CFGAPIP")) > 0;
			.And. SEA->(FieldPos("EA_BORAPI")) > 0 .And. SEA->(FieldPos("EA_APIMSG")) > 0;
			.And. SEA->(FieldPos("EA_APILOG")) > 0 .And. SEA->(FieldPos('EA_SUBCTA')) > 0;
			.And. SEA->(FieldPos('EA_ESPECIE')) > 0 .And. SEA->(FieldPos('EA_IDTRANS')) > 0;
			.And. SEE->(FieldPos('EE_IDTRANS')) > 0 .And. SEE->(FieldPos('EE_LIBEAUT')) > 0;
			.And. AliasInDic("F7A") .and. F7A->(FieldPos('F7A_FORNEC')) > 0
	EndIf
Return lRet

/*/{Protheus.doc} SchedDef
	Execucao da rotina via Schedule.
	@return  aParam
/*/
Static Function SchedDef()
	Local aParam := {}

	aParam := {"P",; //Tipo R para relatorio P para processo
		"FINA717",;     //Nome do grupo de perguntas (SX1)
		Nil,;    //cAlias (para Relatorio)
		Nil,;    //aArray (para Relatorio)
		Nil}     //Titulo (para Relatorio)
Return aParam

/*/{Protheus.doc} F717PosInd
	Posiciona os indices da tabelas que serão utilizadas no processo
	@type  Function
	@author Vitor Duca
	@since 08/03/2023
/*/
Function F717PosInd()

	DbSelectArea('SA6')
	DbSetOrder(1)   // A6_FILIAL, A6_COD, A6_AGENCIA, A6_NUMCON, R_E_C_N_O_, D_E_L_E_T_
	DbSelectArea('SEA')
	DbSetOrder(4)   //EA_FILORIG, EA_NUMBOR, EA_CART, EA_PREFIXO, EA_NUM, EA_PARCELA, EA_TIPO, EA_FORNECE, EA_LOJA, R_E_C_N_O_, D_E_L_E_T_
	DbSelectArea('SE2')
	DbSetOrder(1)   // E2_FILIAL, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, R_E_C_N_O_, D_E_L_E_T_
	DbSelectArea('SA2')
	DbSetOrder(1)   // A1_FILIAL, A1_COD, A1_LOJA, R_E_C_N_O_, D_E_L_E_T_
	DbSelectArea('SEE')
	DbSetOrder(1)   // EE_FILIAL, EE_CODIGO, EE_AGENCIA, EE_CONTA, EE_SUBCTA, R_E_C_N_O_, D_E_L_E_T_
Return 

/*/{Protheus.doc} F717DbArea
	Posiciona as tabelas do título e gera o IDCNAB
	@type function
	@version 12.1.33
	@author renato.ito
	@since 14/04/2021
	@param cSEAFilOri, character, EA_FILORIG
	@param cSEANumBor, character, EA_NUMBOR
	@param cSEAPref, character, EA_PREFIXO
	@param cSEANum, character, EA_NUM
	@param cSEAParc, character, EA_PARCELA
	@param cSEATipo, character, EA_TIPO
	@return logical, True se conseguiu posicionar em todas as tabelas
/*/
Function F717DbArea(cSEAFilOri As Character, cSEANumBor As Character, cSEAPref As Character, cSEANum As Character, cSEAParc As Character, cSEATipo As Character, cSEAFor As Character, cSEALoja As Character) As Logical
	Local lRet As Logical
	Local cCart As Character 
	Local cFilBor As Character

	cCart := 'P'
	cFilBor := ""
	lRet := .T.

	//EA_FILORIG, EA_NUMBOR, EA_CART, EA_PREFIXO, EA_NUM, EA_PARCELA, EA_TIPO, EA_FORNECE, EA_LOJA, R_E_C_N_O_, D_E_L_E_T_
	If lRet .And. (SEA->(DbSeek(cSEAFilOri + cSEANumBor + cCart + cSEAPref + cSEANum + cSEAParc + cSEATipo + cSEAFor + cSEALoja)))
		cFilAnt := SEA->EA_FILORIG
		cFilBor := cFilAnt

		If FWModeAccess('SEA',3) == "E"
        	cFilBor := SEA->EA_FILIAL
    	EndIf

	Else
		lRet := .F.
	Endif

	// A6_FILIAL, A6_COD, A6_AGENCIA, A6_NUMCON, R_E_C_N_O_, D_E_L_E_T_
	If lRet .And. !(SA6->(DbSeek(xFilial('SA6', cFilBor) + SEA->EA_PORTADO + SEA->EA_AGEDEP + SEA->EA_NUMCON)))
		lRet := .F.
	Endif

	//EE_FILIAL, EE_CODIGO, EE_AGENCIA, EE_CONTA, EE_SUBCTA, R_E_C_N_O_, D_E_L_E_T_
	If (lRet .And. !(SEE->(DbSeek(xFilial('SEE', cFilBor) + SEA->EA_PORTADO + SEA->EA_AGEDEP + SEA->EA_NUMCON + SEA->EA_SUBCTA))))
		lRet := .F.
	Endif

	// E2_FILIAL, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, E2_FORNECE, E2_LOJA, R_E_C_N_O_, D_E_L_E_T_
	If lRet .And. SE2->(DbSeek(xFilial('SE2') + cSEAPref + cSEANum + cSEAParc + cSEATipo + cSEAFor + cSEALoja))
		If SE2->E2_NUMBOR <> cSEANumBor
			lRet := .F.
		Else
			F717IdCnab()
		EndIf
	Else
		lRet := .F.
	EndIf

	If lRet .And. !SA2->(DbSeek(xFilial('SA2') + SE2->E2_FORNECE + SE2->E2_LOJA))
		lRet := .F.
	EndIf

Return lRet

/*/{Protheus.doc} getIDCNAB2
	Próximo IDCNAB SE2
	@type function
	@version 12.1.33
	@author renato.ito
	@since 27/12/2022
	@return character, Próximo IDCNAB
/*/
Function getIDCNAB2() As Character
	Local cIDCNAB   As Character
	Local cQuery    As Character
	Local lUsedId	As Logical

	lUsedId := .T.

	cQuery := "SELECT COUNT(E2_IDCNAB) IDCNAB FROM " + RetSQLName('SE2') + " SE2 "
	cQuery += " WHERE "
	cQuery += " SE2.D_E_L_E_T_ = ' ' "
	cQuery += " AND SE2.E2_IDCNAB = ? "
	cQuery := changeQuery(cQuery)
	While lUsedId
		cIDCNAB := GetSxENum("SE2", "E2_IDCNAB", "E2_IDCNAB" + cEmpAnt, 13)
		ConfirmSX8()
		lUsedId := MpSysExecScalar(cQuery, 'IDCNAB', { cIDCNAB }) > 0
	EndDo
Return cIDCNAB

/*/{Protheus.doc} F717QrySEA
	tabela temporaria para listar os títulos com determinados status
	@type function
	@author jailton.urbano
	@since 14/12/2022
	@param cStatus, character, status separados com |
	@return character, alias
/*/
Static Function F717QrySEA(cStatus as Character, aRecnos As Array) As Character
	Local cQuery 	As Character
	Local nX		As Numeric
	Local nLenRecno	As Numeric
	Local nParam	As Numeric
	Local oPrepStat	As Object

	Default aRecnos := {}

	cQuery := ""
	nParam := 1
	nX := 0
	nLenRecno := Len(aRecnos)

	cQuery := " SELECT SEA.EA_FILIAL, SEA.EA_PORTADO, SEA.EA_AGEDEP, SEA.EA_NUMCON, SEA.EA_NUMBOR, SEA.R_E_C_N_O_ RECNOSEA"
	cQuery += " FROM " + RetSqlName("SEA") + " SEA "
	cQuery += " WHERE "
	cQuery += " SEA.EA_CART = ? "
	cQuery += " AND SEA.EA_BORAPI = ? "
	cQuery += " AND SEA.EA_TRANSF IN ? "

	If ExistBlock("NGFAPIQRY")
		cQuery += " AND " + ExecBlock("NGFAPIQRY", .F., .F.)
  	Endif
	
	If nLenRecno > 0
		cQuery += " AND SEA.R_E_C_N_O_ IN (?) "
	Endif
	cQuery += " AND SEA.D_E_L_E_T_ = ? "
	cQuery += " ORDER BY SEA.EA_FILIAL, SEA.EA_PORTADO, SEA.EA_AGEDEP, SEA.EA_NUMCON, SEA.EA_NUMBOR "

	oPrepStat := FwExecStatement():new(cQuery)
	
	oPrepStat:SetString(nParam++, "P")
	oPrepStat:SetString(nParam++, "S")
	oPrepStat:SetUnSafe(nParam++, FormatIn(cStatus, "|"))
	If nLenRecno > 0
		oPrepStat:SetIn(nParam++, aRecnos)
	Endif	
	oPrepStat:SetString(nParam++, " ")
Return oPrepStat:openAlias()

/*/{Protheus.doc} F717Pagar
	Transmite os boletos a pagar
	@type function
	@version 12.2210
	@author jailton.urbano
	@since 13/12/2022
	@param aRecnos, Array, Matriz contendo os R_E_C_N_O_S da SEA que serão processados
	@param lAutomato, Logical, Define se esta sendo chamado de forma automatica (Automação)
	@param jRespMock, Json, Resposta mockada da API (Automação)
	@param cProcesso, Character, Indica qual processo esta executando a função
/*/
Function F717Pagar(aRecnos As Array, lAutomato As Logical, jRespMock As Json, cProcesso As Character, cQryAPI As Character)
	Local cBolAlias  as Character
	Local cBorFil    as Character
	Local cBorBco    as Character
	Local cBorAge    as Character
	Local cBorCnt    as Character
	Local cBorSub    as Character
	Local cApiMsg    as Character
	Local cFebrabran as Character
	Local oLayout    as Object
	Local oApiMsg    as Object
	Local oBills     as Object
	Local oApiLog    as Object
	Local lRet       as Logical
	Local nIdRegApi  as Numeric
	Local oBlock     as Object
	Local cQueryIn   as Character
	Local nTpSend    as Numeric
	Local lAgrpPay   as Logical
	Local jBorSend   as Json //Armazena os borderos que ja foram transmitidos quando configurado para agrupar
	Local nIdTrans   as Numeric
	Local cBody      as Character
	Local cLoteKey   as Character
	Local cIDCNAB    as Character

	Default aRecnos 	:= {}
	Default lAutomato 	:= .F.
	Default jRespMock 	:= JsonObject():new()
	Default cProcesso 	:= "JOB"
	Default cQryAPI 	:= ""

	cBorFil    := ""
	cBorBco    := ""
	cBorAge    := ""
	cBorCnt    := ""
	cBorSub    := ""
	cFebrabran := ""
	cBody      := ""
	cQueryIn   := " |V|P|B"
	nTpSend    := 1
	lAgrpPay   := .F.
	jBorSend   := JsonObject():new()
	nIdTrans   := 0
	lRet       := .F.
	cLoteKey   := ""
	cIDCNAB    := ""

	If __lF717GRV == NIL
		__lF717GRV := ExistBlock("F717GRV")
	Endif

	//Posiciona as tabelas nos indices corretos
	F717PosInd()
	
	oBills  := &("totvs.protheus.backoffice.ngf.bills.payments.payments():new()")
	oBills:setAutomato(lAutomato, jRespMock) //Configura a classe para automação caso necessario

	oLayout     := JsonObject():new()
	oApiLog     := JsonObject():new()
	oApiMsg     := JsonObject():new()

	//busca os borderos
	If Upper(Alltrim(cProcesso)) == "API"
		cQueryIn := cQryAPI
	Else 
		If ValType(MV_PAR01) == "N" .and. MV_PAR01 == 1
			cQueryIn := " |F|V|P|B"
		Endif
	Endif
	__aStatus := {}
	If 'F' $ cQueryIn
		aAdd(__aStatus, 'F')
	EndIf
	If ' ' $ cQueryIn
		aAdd(__aStatus, ' ')
	EndIf
	/*Tipo de envio do pagamento
		1 - Individual
		2 - Lote
	*/
	If ValType(MV_PAR02) == "N"
		nTpSend := MV_PAR02
	Endif

	lAgrpPay := nTpSend == 2

	oBills:setTypeSend(nTpSend)

	cBolAlias := F717QrySEA(cQueryIn, aRecnos)
	(cBolAlias)->(DbGoTop())
	While (cBolAlias)->(!EOF())
		oBlock := ErrorBlock( { |e| F717Err(e, 'registroPagar', @cApiMsg, @lRet) } )
		// Se der erro limpa as variáveis para gerar log de erro do próximo título
		If !lRet
			cBorFil := ""
			cBorBco := ""
			cBorAge := ""
			cBorCnt := ""
			cBorSub := ""
		EndIf
		lRet        := .T.
		nIdRegApi   := 0
		cApiMsg     := ""
		cBody       := ""
		__cLytPers  := "N"
		nIdTrans    := 0

		Begin Sequence
			SEA->(DbGoto((cBolAlias)->RECNOSEA))
			// Posiciona as tabelas
			If F717DbArea(SEA->EA_FILORIG, SEA->EA_NUMBOR, SEA->EA_PREFIXO, SEA->EA_NUM, SEA->EA_PARCELA, SEA->EA_TIPO, SEA->EA_FORNECE, SEA->EA_LOJA)

				// verifica se mudou o banco, senão mudou a configuração continua a mesma
				If cBorFil <> SEA->EA_FILIAL .Or. cBorBco <> SEA->EA_PORTADO .Or. cBorAge <> SEA->EA_AGEDEP .Or. cBorCnt <> SEA->EA_NUMCON .Or. cBorSub <> SEA->EA_SUBCTA
					cBorFil := SEA->EA_FILIAL
					cBorBco := SEA->EA_PORTADO
					cBorAge := SEA->EA_AGEDEP
					cBorCnt := SEA->EA_NUMCON
					cBorSub := SEA->EA_SUBCTA

					cFebrabran := SA6->A6_BCOOFI

					If SA6->A6_CFGAPIP $ '1|3'
						If !Empty(oLayout:FromJson(SA6->A6_CFGBOLP))
							lRet     := .F.
							cApiMsg  := STR0001 //"Problema na configuração do layout na conta (A6_CFGBOLP)."
						Else
							// configura as credenciais do banco
							If oLayout:hasProperty("credentials") .And. !oBills:setCredentials(oLayout["credentials"]:toJSON(), cFebrabran)
								lRet := .F.
								cApiMsg := STR0002 + SA6->A6_FILIAL +"|"+ SA6->A6_COD +"|"+ SA6->A6_AGENCIA +"|"+ SA6->A6_NUMCON //"Não foi possíver obter as credenciais do layout. "
								FwLogMsg('ERROR',, "FINA717", "FINA717", "", "CREDENTIALS", cApiMsg )
							EndIf
						EndIf
						If oLayout:hasProperty("beneficiarioFilial")
							oLayout["layout"]["filial"] := oLayout["beneficiarioFilial"]
						EndIf
						If oLayout:hasProperty("retornoBancario") .And. MethIsMemberOf(oBills , "setRecurrence")
							oBills:setRecurrence(oLayout["retornoBancario"]:toJSON())
						EndIf
					Else
						lRet := .F.
						cApiMsg := STR0003 + SA6->A6_FILIAL +"|"+ SA6->A6_COD +"|"+ SA6->A6_AGENCIA +"|"+ SA6->A6_NUMCON //"Conta não está configurada para envio de pagamentos. "
						(cBolAlias)->(DbSkip())
						FwLogMsg("ERROR",, "FINA717", "FINA717", "", "A6_CFGAPIP ", cApiMsg)
					EndIf
				EndIf
			Else
				lRet := .F.
				cApiMsg := STR0004 + SEA->EA_FILIAL +"|"+ SEA->EA_NUMBOR +"|"+ SEA->EA_PREFIXO +"|"+ SEA->EA_NUM +"|"+ SEA->EA_PARCELA +"|"+ SEA->EA_TIPO +"|"+ SEA->EA_FORNECE +"|"+ SEA->EA_LOJA //"Não foi possível posicionar as tabelas para o título:"
				(cBolAlias)->(DbSkip())
				FwLogMsg("ERROR",, "FINA717", "FINA717", "", "SEEK_TABLES", cApiMsg)
			EndIf

			cLoteKey := cBorFil + cBorBco + cBorAge + cBorCnt + SEA->EA_NUMBOR
			cIDCNAB  := Alltrim(SE2->E2_IDCNAB)
			If SEA->EA_TRANSF $ "V|P|B" .or. !(jBorSend:hasProperty(cLoteKey) .and. jBorSend[cLoteKey]["RESULTS"]:hasProperty(cIDCNAB))
				//Só deve transmitir titulos com o EA_TRANSF = F ou vazio
				If lRet .and. !SEA->EA_TRANSF $ "V|P|B"
					// pega o id de transmissão atual e armazena o próximo
					nIdTrans 	:= SEE->EE_IDTRANS
	
					Reclock("SEE",.F.)
						SEE->EE_IDTRANS := nIdTrans + 1
					SEE->(MSunlock())

					RecLock("SEA", .F.)
						SEA->EA_IDTRANS  := nIdTrans
					SEA->(MsUnlock())
					
					cBody := oBills:getBody(oLayout["layout"]:toJSON())
					If Empty(cBody)
						lRet := .F.
						cApiMsg := oBills:getLog()
					Else
						cApiMsg := getF717LYT(@cBody, cFebrabran, @lRet)
					Endif
				EndIf

				If lRet
					//Verifica se o titulo em questão esta aguardando a consulta para concluir a transmissão
					If SEA->EA_TRANSF $ "V|P|B"
						lRet := oBills:consult()
					Else
						lRet := oBills:send(cBody)
						If lAgrpPay
							jBorSend[cLoteKey] := JsonObject():new()
						Endif
					Endif	
					cApiMsg := oBills:getLog()
				EndIf

				oApiLog["date"]    := FWTimeStamp(2, DATE(), TIME())
				oApiLog["message"] := cApiMsg

				oApiMsg["bank"]    := cFebrabran
				oApiMsg["log"]     := oBills:getResult() // {"request", "response"}
				oApiMsg["custom"]  := __cLytPers

				F717GrvSEA(oApiMsg:ToJSON(), oApiLog:ToJSON(), IIF(lRet, oBills:getStatus(), "F"), nIdTrans)

				If lAgrpPay .and. jBorSend:hasProperty(cLoteKey)
					jBorSend[cLoteKey]["EA_APIMSG"]  := SEA->EA_APIMSG
					jBorSend[cLoteKey]["EA_TRANSF"]  := SEA->EA_TRANSF
					jBorSend[cLoteKey]["EA_APILOG"]  := SEA->EA_APILOG
					jBorSend[cLoteKey]["EA_IDTRANS"] := SEA->EA_IDTRANS
					jBorSend[cLoteKey]["RESULTS"]    := oBills:resultByID()
				Endif
			Else
				oApiMsg:ToJson(jBorSend[cLoteKey]["EA_APIMSG"])
				
				If jBorSend[cLoteKey]["EA_TRANSF"] <> "F"
					oApiMsg["bank"]    := cFebrabran
					oApiMsg["log"]     := jBorSend[cLoteKey]["RESULTS"][cIDCNAB]:toJson() // {"request", "response"}
					oApiMsg["custom"]  := __cLytPers
				Endif	

				F717GrvSEA(	oApiMsg:ToJSON(),;
							jBorSend[cLoteKey]["EA_APILOG"],;
							jBorSend[cLoteKey]["EA_TRANSF"],;
							jBorSend[cLoteKey]["EA_IDTRANS"])
			Endif

			RECOVER

				oApiLog["date"]    := FWTimeStamp(2, DATE(), TIME())
				oApiLog["message"] := cApiMsg

				oApiMsg["bank"]    := cFebrabran
				oApiMsg["log"]     := oBills:getResult() // {"request", "response"}
				oApiMsg["custom"]  := __cLytPers

				// Atualiza a SEA
				RecLock('SEA', .F.)
					If !SEA->EA_TRANSF $ "V|P|B"
						SEA->EA_APIMSG  := oApiMsg:ToJSON()
						SEA->EA_TRANSF  := "F"
					Endif	
					SEA->EA_APILOG  := oApiLog:ToJSON()
				SEA->(MsUnlock())
		End Sequence
		ErrorBlock(oBlock)
		(cBolAlias)->(DbSkip())
	EndDo

	(cBolAlias)->(DbCloseArea())
	FreeObj(oBills)
	FreeObj(oApiLog)
	FreeObj(oApiMsg)
	FreeObj(jBorSend)
Return

/*/{Protheus.doc} F717Err
	Carrega o erro da macroexecução do layout
	@type function
	@author renato.ito
	@since 18/05/2021
	@param e   , Object   , objeto do erro
	@param cErr, Character, mensagem de erro
/*/
Static Function F717Err(e As Object, cErr As Character, cMsg as Character, lRet as Logical)
	cMsg := (e:errorStack + ' - ' + cErr)
	FwLogMsg("ERROR",, "FINA717", "FINA717", "", e:description , e:errorStack )
	lRet := .F.
	BREAK
Return

/*/{Protheus.doc} getF717LYT
    Chama o PE F717LYT para customizacao do layout.

    @type  Function
    @author Vitor Duca
    @since 27/02/2024
    @version 1.0
    @param cLayout, Character(por Referencia), layout para transmissão.
	@param cFebrabran, Character, Banco oficial (A6_BCOOFI)
	@param lRet, Logical, Controla o erro de execução do job e altera se necessario (referencia)
    @return cError, Character, erro ao ler o layout customizado (Vazio = sem erros).
/*/
Function getF717LYT(cLayout As Character, cFebrabran As Character, lRet As Logical) As Character
    Local cChvTit	As Character
    Local cLytAuxPE As Character
    Local cError    As Character
    Local cFailJson As Character
    Local oLayPE 	As Object

	cChvTit   	:= ""  	
	cLytAuxPE 	:= ""  	
	cError    	:= ""  	
	cFailJson 	:= ""

    If __lF717LYT == Nil
        __lF717LYT := ExistBlock("F717LYT")
    EndIf
    
    If __lF717LYT
        cLytAuxPE := cLayout

        cChvTit := SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA
        cLytAuxPE := ExecBlock("F717LYT",.F.,.F., { cFebrabran, cChvTit, cLytAuxPE })
        If !Empty(cLytAuxPE)
            oLayPE := JsonObject():new()
			cFailJson := oLayPE:FromJson(cLytAuxPE)
			lParseOk := oLayPE != Nil .And. cFailJson == Nil

            If lParseOk
                cLayout := cLytAuxPE
            Else
				lRet := .F.
                cError := STR0005 //"Não foi possivel converter o layout customizado pelo ponto de entrada F717LYT, por favor verifique com seu administrador"
            EndIf

            __cLytPers := "S"
        EndIf
    EndIf
Return cError

/*/{Protheus.doc} F717QrySE2
	Realiza a busca dos titulos que estão contidos no bordero
	e devolve os recnos dos titulos
	@type  Function
	@author Vitor Duca
	@since 11/07/2024
	@version 1.0
	@param cFilBor, Character, Filial do bordero EA_FILIAL
	@param cNumBor, Character, Numero do bordero EA_NUMBOR
	@return aRecnos, Array, Matriz contendo os RECNOS da SE2
/*/
Function F717QrySE2(cFilBor As Character, cNumBor As Character) As Array
	Local cQuery	As Character
	Local cAliasTmp As Character
	Local aRecnos	As Numeric

	Default cFilBor := ""
	Default cNumBor := ""

	If __aStatus == NIL
		__aStatus := {' '}
	EndIf

	cAliasTmp := ""
	cQuery := ""
	aRecnos := {}

	If __oPrepSt == NIL
		cQuery := "SELECT SE2.R_E_C_N_O_ RECNOSE2 "
		cQuery += "FROM " + RetSqlName("SEA") + " SEA "
		cQuery += 	"INNER JOIN " + RetSqlName("SE2") + " SE2 "
		cQuery += 				"ON " + totvs.protheus.backoffice.ngf.util.BranchRelation( {"SEA","EA_FILORIG","SEA"}, {"SE2","E2_FILIAL","SE2"}  ) + " "
		cQuery += 				"AND SEA.EA_PREFIXO = SE2.E2_PREFIXO "
		cQuery += 				"AND SEA.EA_NUM = SE2.E2_NUM "
		cQuery += 				"AND SEA.EA_PARCELA = SE2.E2_PARCELA "
		cQuery += 				"AND SEA.EA_TIPO = SE2.E2_TIPO "
		cQuery += 				"AND SEA.EA_FORNECE = SE2.E2_FORNECE "
		cQuery += 				"AND SEA.EA_LOJA = SE2.E2_LOJA "
		cQuery += 				"AND SE2.D_E_L_E_T_ = ? "
		cQuery += "WHERE  SEA.EA_FILIAL = ? "
		cQuery += 	"AND SEA.EA_NUMBOR = ? "
		cQuery += 	"AND SEA.EA_TRANSF IN (?)  "
		cQuery += 	"AND SEA.D_E_L_E_T_ = ?  "

		__oPrepSt := FwExecStatement():New(ChangeQuery(cQuery))
	Endif

	__oPrepSt:SetString(01, ' ')
	__oPrepSt:SetString(02, cFilBor)
	__oPrepSt:SetString(03, cNumBor)
	__oPrepSt:SetIn(04, __aStatus)
	__oPrepSt:SetString(05, ' ')

	cAliasTmp := __oPrepSt:OpenAlias()

	While (cAliasTmp)->(!Eof())
		Aadd(aRecnos, (cAliasTmp)->RECNOSE2)
		(cAliasTmp)->(DbSkip())
	EndDo

	(cAliasTmp)->(DbCloseArea())
Return aRecnos

/*/{Protheus.doc} F717IdCnab
	Grava o campo IDCNAB do titulo posicionado
	@type  Function
	@author Vitor Duca
	@since 11/07/2024
	@version 1.0
/*/
Function F717IdCnab()
	If Empty(SE2->E2_IDCNAB)
		RecLock('SE2', .F.)
			SE2->E2_IDCNAB := getIDCNAB2()
		SE2->(MsUnlock())
	Endif		
Return

/*/{Protheus.doc} F717GrvSEA
	Função que realiza a gravação da tabela SEA
	@type  Static Function
	@author Vitor Duca
	@since 16/07/2024
	@version 1.0
	@param cApiMsg, Character, Conteudo que será gravado no campo EA_APIMSG
	@param cApiLog, Character, Conteudo que será gravado no campo EA_APILOG
	@param cTransf, Character, Conteudo que será gravado no campo EA_TRANSF
/*/
Static Function F717GrvSEA(cApiMsg As Character, cApiLog As Character, cTransf As Character, nIdTrans As Numeric)
	Default cApiMsg 	:= ""
	Default cApiLog 	:= ""
	Default cTransf		:= ""
	Default nIdTrans	:= 0

	RecLock('SEA', .F.)
		SEA->EA_APIMSG  := cApiMsg
		SEA->EA_TRANSF  := cTransf
		SEA->EA_APILOG  := cApiLog
		If nIdTrans > 0
			SEA->EA_IDTRANS := nIdTrans
		Endif	
	SEA->(MsUnlock())
				
	//Permite realizar gravações complementares nas tabelas posicionadas
	If __lF717GRV
		ExecBlock("F717GRV",.F.,.F.)
	Endif
Return
