#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fin.banktransactionaccounting.ch'

namespace custom.financeiro.banktransactionaccounting.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} backoffice.sv.fin.banktransactionaccounting.accounting
@description Classe para creación del Objeto de Negocio de Facturas de compras conciliadas para SMARTVIEW
@author Leonardo Pereira
@since 31/10/2024
@version 1.1
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFIN', tables='SE5,CT2,CV3,FK5', name='Movimientos bancarios conciliados', country='ALL', initialRelease='12.1.2410', customTables='FK5,CT2' )
class banktransactionaccountingTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected Data aFields as array
	protected Data aStruct as array
	protected Data jItems as json
	protected Data jParams as json
	protected Data cAliasA as character

	protected Method converteMovimento() as numeric

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe 
@Return object: self
@author Leonardo Pereira
@since 31/10/2024
@version 1.0
*/
//-------------------------------------------------------------------
Method new() class banktransactionaccountingTReportsBusinessObject

	Local aCpos := { } as array

	_Super:new( )

	// Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 )  // 'Movimientos bancarios conciliados'

	// Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 )  // 'Movimientos bancarios conciliados'

	// Define a Área
	self:appendArea( STR0002 ) // 'Financeiro'

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'FINSV857' )
		IIf(!self:setErrorStatus( 400, STR0003, STR0004 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0005,,, ),'') // 'Sin Preguntas' // '¡Verifique el grupo de preguntas dado!' // 'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0006,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// campos que no existen en SX3
	aAdd( aCpos, { 'M0_CGC'	   , STR0007, 'string', STR0007 } )	// 'RFC Emisor'
	aAdd( aCpos, { 'M0_NOMECOM', STR0008, 'string', STR0008 } ) // 'Nombre Emisor'
	aAdd( aCpos, { 'CT2_DOCLSL', STR0009, 'string', STR0009 } ) // 'Doc/Lote/Sublote'
	aAdd( aCpos, { 'CT2_DTACTB', STR0010, 'date'  , STR0010 } ) // 'Fecha de Asiento'
	aAdd( aCpos, { 'CT2_TPSLD' , STR0011, 'string', STR0011 } ) // 'Tipo Saldo'
	aAdd( aCpos, { 'CT2_HISTO' , STR0012, 'string', STR0012 } ) // 'Historial'

	// demais campos
	self:aFields := { 'FK5_FILIAL', 'M0_CGC', 'M0_NOMECOM', "FK5_BANCO", "FK5_AGENCI", "FK5_CONTA", "FK5_DTDISP", "FK5_DTCONC", "FK5_RECPAG", "FK5_VALOR", "FK5_TXMOED", "FK5_MOEDA", "FK5_HISTOR", "FK5_DOC", 'CT2_DOCLSL', 'CT2_DTACTB', 'CT2_TPSLD', 'CT2_HISTO' }

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio
@param nPage, numérico, indica la pagina actual del relatório
@param oFilter, objeto, contiene el filtro del TReports
@return object: self:oData
@author Leonardo Pereira
@since 31/10/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class banktransactionaccountingTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery		as character
	Local cFiltro 		as character
	Local cCpoCT2		as character
	Local cCpoFK5		as character
	Local cExp 			as character
	Local nX		    as numeric
	Local n1			as numeric
	Local aPDFields	    as array
	Local aFiltro		as array
	Local aCustomFields as array
	Local lObfuscated	as logical
	Local oExecA		as object
	Local oExecB        as object
	Local cAliasB       as character
	Local cChaveCTL     as character
	Local cFilialCTL    as character
	Local cFilialCV3    as character
	Local nCasasDecimais as numeric

	nCasasDecimais := GetSx3Cache('M2_MOEDA2','X3_TAMANHO')

	cFilialCTL := FWxFilial( 'CTL' )
	cFilialCV3 := FWxFilial( 'CV3' )
	cChaveCTL  := AllTrim( Posicione( 'CTL', 1, cFilialCTL + '517', 'CTL_KEY' ) )
	cChaveCTL  := IIF("SQL" $ TcGetDB(),cChaveCTL,StrTran(cChaveCTL,"+","||"))

	cFiltro 			:= ''
	cExp 				:= ''
	cAliasB			:= ''

	nX 				:= 0
	n1				   := 0

	aPDFields		:= { }
	aFiltro			:= { }
	aCustomFields	:= { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	self:jParams := oFilter:getParameters( )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	cCpoFK5 := getCpoUser( aCustomFields, 'FK5', 'FK5', ',' )
	cCpoCT2 := getCpoUser( aCustomFields, 'CT2', 'CT2', ',' )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	If oFilter:hasFilter( )
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )
		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )
	EndIf

	// Realiza a montagem da QUERY que será enviada para o smartview
	cQuery := "SELECT FK5.FK5_FILIAL, SM0.M0_CGC, SM0.M0_NOMECOM, FK5.FK5_BANCO, FK5.FK5_AGENCI, FK5.FK5_CONTA, "
	cQuery += " FK5.FK5_DTDISP, FK5.FK5_DTCONC, FK5.FK5_RECPAG, FK5.FK5_VALOR, "
	cQuery += " FK5.FK5_TXMOED, FK5.FK5_MOEDA, FK5.FK5_HISTOR, FK5.FK5_DOC, FK5.FK5_FILORI, "
	cQuery += " FK5.FK5_IDMOV, FK5.FK5_IDDOC, FK5.FK5_ORIGEM, FK5.FK5_TPDOC, FK5.FK5_NUMCH, ?"
	cQuery += " FK5.R_E_C_N_O_ AS REGFK5, ? AS CHVE "
	cQuery += " FROM " + RetSqlName( 'FK5' ) +  " FK5 "
	cQuery += " INNER JOIN " + RetSqlName( 'SE5' ) + " SE5 "
	cQuery += "   ON SE5.E5_FILIAL = ? "
	cQuery += "      AND SE5.E5_IDORIG = FK5.FK5_IDMOV "
	cQuery += "      AND SE5.D_E_L_E_T_ = ? "	
	cQuery += " INNER JOIN SYS_COMPANY SM0 "
	cQuery += "   ON M0_CODIGO = ? "
	cQuery += "      AND M0_CODFIL = ? "
	cQuery += "      AND SM0.D_E_L_E_T_ = ? "
	cQuery += " WHERE FK5.FK5_FILIAL = ? "
	cQuery += "   AND FK5.FK5_BANCO = ? "
	cQuery += "   AND FK5.FK5_AGENCI = ? "
	cQuery += "   AND FK5.FK5_CONTA =  ? "
	cQuery += "   AND FK5.FK5_DTDISP BETWEEN ? AND ? "
	cQuery += "   AND FK5.D_E_L_E_T_ = ? "

	// Agrega os filtros na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += " AND ? " + ' ' + " ? ? "
	Next

	cQuery := ChangeQuery( cQuery )

	oExecA := FwExecStatement():New( cQuery )

	nSeq := 0 
    oExecA:SetUnSafe( nSeq += 1, cCpoFK5 )
	oExecA:SetUnSafe( nSeq += 1, StrTran(cChaveCTL,"E5_","SE5.E5_"))
	oExecA:SetString( nSeq += 1, FWxFilial( "SE5" ) )
	oExecA:SetString( nSeq += 1, ' ' )
	oExecA:SetString( nSeq += 1, cEmpAnt )
	oExecA:SetString( nSeq += 1, cFilAnt )
	oExecA:SetString( nSeq += 1, ' ' )
	oExecA:SetString( nSeq += 1, FWxFilial( "FK5" ) )
	oExecA:SetString( nSeq += 1, self:jParams['MV_PAR01'][1] )
	oExecA:SetString( nSeq += 1, self:jParams['MV_PAR02'][1] )
	oExecA:SetString( nSeq += 1, self:jParams['MV_PAR03'][1] )
	oExecA:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( self:jParams['MV_PAR04'][1] )[1] ) )
	oExecA:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( self:jParams['MV_PAR05'][1] )[1] ) )
	oExecA:SetString( nSeq += 1, ' ' )
	For nX := 1 To Len( aFiltro )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 1] )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 2] )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 3] )
	Next
	cQuery := oExecA:getFixQuery( )

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	self:cAliasA := oExecA:OpenAlias( )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( self:cAliasA )->( EOF( ) )
		self:jItems := JsonObject():new( )

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( self:cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf ( LEFT( self:aStruct[nX][5],4 ) == "CT2_" )
				cQuery := "SELECT CT2_LOTE,CT2_SBLOTE,CT2_DOC, CT2_DATA CT2_DTACTB, ?" 
				cQuery += " CT2_TPSALD  CT2_TPSLD, CT2_HIST CT2_HISTO"
				cQuery += " FROM " + RetSqlName("CT2") + " CT2"
				cQuery += " INNER JOIN " + RetSqlName("CTL") + " CTL ON CTL_FILIAL = ? AND CTL_LP = ? AND CTL.D_E_L_E_T_ = ?"
				cQuery += " INNER JOIN " + RetSqlName("CV3") + " CV3 ON CV3_FILIAL = ? AND CV3_KEY = ? AND CV3.D_E_L_E_T_ = ? "
				cQuery += " WHERE CV3.CV3_RECDES <> ? "
				cQuery += "   AND CT2.R_E_C_N_O_ = CAST(CV3.CV3_RECDES AS ? )"   
				cQuery += "   AND CT2.D_E_L_E_T_ = ?"
				cQuery := ChangeQuery(cQuery)
				oExecB := FwExecStatement():New( cQuery )
				oExecB:SetUnSafe( 01, cCpoCT2)
				oExecB:SetString( 02, cFilialCTL )
				oExecB:SetString( 03, "517" )
				oExecB:SetString( 04, ' ' )
				oExecB:SetString( 05, cFilialCV3 )
				oExecB:SetString( 06, ( self:cAliasA )->CHVE )
				oExecB:SetString( 07, ' ' )
				oExecB:SetString( 08, ' ' )
				oExecB:SetUnsafe( 09, IIF("ORACLE" $ TcGetDB(),"INT","BIGINT"))
				oExecB:SetString( 10, ' ' )
				cQuery := oExecB:getFixQuery( )

				// Executa a QUERY e cria uma tabela temporaria com os dados retornados
				cAliasB := oExecB:OpenAlias( )

				If ( self:aStruct[nX][3] == 'date' )
					self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
				ElseiF self:aStruct[nX][5] == "CT2_DOCLSL"
					self:jItems[self:aStruct[nX][1]] := ( cAliasB )->CT2_LOTE+"/"+( cAliasB )->CT2_SBLOTE+"/"+( cAliasB )->CT2_DOC						
				Else
					self:jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
				EndIf

				// fecha tabela
				( cAliasB )->( DbCloseArea( ) )
				oExecB:Destroy( )
				oExecB := Nil
			ElseIf ( self:aStruct[nX][3] == 'date' )
				self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( self:cAliasA )->&( self:aStruct[nX][5] ) ) )
			ElseIf ( self:aStruct[nx][5] == 'FK5_VALOR' )
				self:jItems[self:aStruct[nX][1]] := self:converteMovimento( ( self:cAliasA )->&( self:aStruct[nX][5] ), nCasasDecimais )
			Else
				self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->&( self:aStruct[nX][5] )
			EndIf
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		self:oData:appendData( self:jItems )

		( self:cAliasA )->( DbSkip( ) )
	End

	( self:cAliasA )->( DbCloseArea( ) )

	oExecA:Destroy( )
	oExecA := Nil

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
@description Retorna la estructura de los campos
@return object: self:oSchema
@author Leonardo Pereira
@since 31/10/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema() as object class banktransactionaccountingTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTView
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )

//-------------------------------------------------------------------
/*{Protheus.doc} new
Converte o valor do movimento para a moeda do relatório. 
@Return Number: nValor
@author Leonardo Pereira
@since 31/10/2024
@version 1.0
*/
//-------------------------------------------------------------------
Method converteMovimento( nValor as numeric, nCasasDecimais as numeric ) as numeric class banktransactionaccountingTReportsBusinessObject

	Local dConversao as date
	Local nTaxaContratada := 0 as numeric
	Local nTaxaOrigem := 0 as numeric
	Local nTaxaDestino := 0 as numeric
	Local nMoeda := 0 as numeric
	Local nTaxa := 0 as numeric

	dConversao := dDatabase
	nMoeda := Val( RIGHT(( self:cAliasA )->FK5_MOEDA ,1))

	If ( self:jParams['MV_PAR06'][1] <> 1 )
		DbSelectArea("SM2")
		DbSetOrder(1) // M2_DATA
		If SM2->( DbSeek(DtoS(dConversao)))
			cCampo := "M2_MOEDA" + AllTrim(Str(self:jParams['MV_PAR06'][1]))
			nTaxa  := &("SM2->"+cCampo)
		Endif
	Endif

	If ( self:jParams['MV_PAR07'][1] == 1 )
		dConversao := dDataBase
		nTaxaContratada := ( self:cAliasA )->FK5_TXMOED
	Else
		dConversao := STOD(( self:cAliasA )->FK5_DTDISP)
		nTaxaContratada := nTaxa
	EndIf

	If ( nMoeda == 1 )
		nTaxaDestino := nTaxaContratada
	Else
		nTaxaOrigem := nTaxaContratada
		nTaxaDestino := nTaxa
	EndIf

	nValor := xMoeda( nValor, nMoeda , self:jParams['MV_PAR06'][1], dConversao, nCasasDecimais, nTaxaOrigem, nTaxaDestino )

	If nTaxa <= 0 .And. ( self:jParams['MV_PAR06'][1] <> 1 )
		nValor := 0
	Endif

Return( nValor )

