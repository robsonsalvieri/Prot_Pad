#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fin.compensation.ch'

namespace custom.financieiro.compensation.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} backoffice.sv.com.compensation
@description Classe para creación del Objeto de Negocio de Recibos pendientes por cobrador para TReports
@author Marcelo Hruschka
@since 19/11/2024
@version 1.1
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFIN', tables='SA2,SA1,SE1,SE2,FK5', name='Demostrativo de compensación', country='ALL', initialRelease='12.1.2410', customTables='SA2,SA1,SE1,SE2,FK5' )
class compensationTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array
	protected data nRecno as numeric
	protected data jItems as json

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe 
@Return object: self
@author Marcelo Hruschka
@since 19/11/2024
@version 1.0
*/
//-------------------------------------------------------------------
Method new() class compensationTReportsBusinessObject

	Local aCpos := {} as array

	_Super:new()

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 )  // 'Demostrativo de compensación'

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 )  // 'Demostrativo de compensación'

	// Define a Área
	self:appendArea( STR0002 ) // 'Financieiro'

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'FINSV515' )
		IIf(!self:setErrorStatus( 400, STR0003, STR0004 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0005,,, ),'') // 'Sin Preguntas' // '¡Verifique el grupo de preguntas dado!' // 'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0006,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	//Cheques emitidos e cheques recebidos
	aAdd( aCpos, { 'CLIFOR'			, STR0007 , 'string'	, STR0007 } ) // 'Cliente/Provedor'
	aAdd( aCpos, { 'DEBITO'			, STR0008 , 'number'	, STR0008 } ) // 'DEBITO'
	aAdd( aCpos, { 'CREDITO'		, STR0009 , 'number'	, STR0009 } ) // 'CREDITO'
	aAdd( aCpos, { 'SALDO'			, STR0010 , 'number'	, STR0010 } ) // 'SALDO'
	aAdd( aCpos, { 'COMPROVANTE'	, STR0011 , 'string'	, STR0011 } ) // 'COMPROVANTE'

	// demais campos
	self:aFields := {'E1_CLIENTE','E1_LOJA','A1_NREDUZ','E1_PREFIXO','E1_NUM','E1_PARCELA','E1_TIPO','E1_NATUREZ','E1_EMISSAO','E1_VENCTO','E1_VALOR','E1_MOEDA','E2_FORNECE','E2_LOJA','A2_NREDUZ','E2_PREFIXO','E2_NUM','E2_PARCELA','E2_TIPO','E2_NATUREZ','E2_EMISSAO','E2_VENCTO','E2_VALOR','E2_MOEDA','CLIFOR','DEBITO','CREDITO','SALDO','COMPROVANTE'}

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio
@param nPage, numérico, indica la pagina actual del relatório
@param oFilter, objeto, contiene el filtro del TReports
@return object: self:oData
@author Marcelo Hruschka
@since 19/11/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class compensationTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery		as character
	Local cFiltro 		as character

	Local nX			as numeric
	Local n1			as numeric
	Local nPosMon		as numeric
	Local nPosExp		as numeric
	Local nDecs 		as numeric

	Local jParams 		as json

	Local aPDFields		as array
	Local aFiltro		as array
	Local aCustomFields as array

	Local lObfuscated	as logical

	Local oExecA		as object
	Local cAliasA       as character
	Local oExecB		as object
	Local cAliasB       as character
	Local cExp          as character

	cFiltro 			:= ''
	cAliasA			    := ''
	cAliasB			    := ''
	cExp                := ''

	nPosMon   		:= 0
	nPosExp 		:= 0
	nDecs 			:= 0
	nX 				:= 0
	n1				:= 0

	aPDFields		:= { }
	aFiltro			:= { }
	aCustomFields	:= { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )
	cCpoSA1 := getCpoUser( aCustomFields, 'SA1', 'A1', ',' )
	cCpoSA2 := getCpoUser( aCustomFields, 'SA2', 'A2', ',' )
	cCpoSE1 := getCpoUser( aCustomFields, 'SE1', 'E1', ',' )
	cCpoSE2 := getCpoUser( aCustomFields, 'SE2', 'E2', ',' )
	cCpoFK5 := getCpoUser( aCustomFields, 'FK5', 'FK5', ',' )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	If oFilter:hasFilter( )
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )
		aFiltro := getParamToArr( cFiltro )
		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )

		// Define os dados para conversão de moedas
		nPosExp := aScan( aFiltro, { | x | AllTrim( x[1] ) == 'CLIFOR' } )
		If ( nPosExp > 0 )
			cExp := aFiltro[nPosExp, 3]
			aDel( aFiltro, nPosExp )
			aSize( aFiltro, ( Len( aFiltro ) - 1 ) )
		EndIf
	EndIf

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	If "CLIENTE" $ cExp
		lCliente := .T.
		cQuery := "SELECT SE1.E1_CLIENTE, SE1.E1_LOJA, SA1.A1_NREDUZ, SE1.E1_PREFIXO, SE1.E1_NUM, SE1.E1_PARCELA, SE1.E1_TIPO, SE1.E1_NATUREZ, SE1.E1_EMISSAO, SE1.E1_VENCTO, SE1.E1_VALOR, SE1.E1_MOEDA,"
		cQuery += " ''  E2_FORNECE, ''  E2_LOJA, ''  A2_NREDUZ, ''  E2_PREFIXO, ''  E2_NUM, ''  E2_PARCELA, ''  E2_TIPO, ''  E2_NATUREZ, ''  E2_EMISSAO, ''  E2_VENCTO, 0  E2_VALOR, 0  E2_MOEDA,"
		cQuery += " ? "
		cQuery += " ? "
		cQuery += " 'CLIENTE'  CLIFOR, SE1.R_E_C_N_O_  REG"
		cQuery += " FROM " + RetSqlName("SE1") + " SE1"
		cQuery += " INNER JOIN " + RetSqlName("SA1") + " SA1 ON SA1.A1_FILIAL = ? AND SA1.A1_COD = SE1.E1_CLIENTE AND SA1.A1_LOJA = SE1.E1_LOJA AND SA1.D_E_L_E_T_ = ?"
		cQuery += " WHERE SE1.E1_FILIAL = ?"
		cQuery += "	  AND SE1.E1_CLIENTE BETWEEN ? AND ?"
		cQuery += "	  AND SE1.E1_EMISSAO BETWEEN ? AND ?"
		cQuery += "	  AND SE1.E1_NATUREZ BETWEEN ? AND ?"
		cQuery += "   AND SE1.D_E_L_E_T_ = ?"
	Else
		lCliente := .F.
		cQuery := "SELECT SE2.E2_FORNECE, SE2.E2_LOJA, SA2.A2_NREDUZ, SE2.E2_PREFIXO, SE2.E2_NUM, SE2.E2_PARCELA, SE2.E2_TIPO, SE2.E2_NATUREZ, SE2.E2_EMISSAO, SE2.E2_VENCTO, SE2.E2_VALOR, SE2.E2_MOEDA,"
		cQuery += " ''  E1_CLIENTE, ''  E1_LOJA, ''  A1_NREDUZ, ''  E1_PREFIXO, ''  E1_NUM, ''  E1_PARCELA, ''  E1_TIPO, ''  E1_NATUREZ, ''  E1_EMISSAO, ''  E1_VENCTO, 0  E1_VALOR, 0  E1_MOEDA,"
		cQuery += " ? "
		cQuery += " ? "
		cQuery += " 'FORNECEDOR'  CLIFOR, SE2.R_E_C_N_O_  REG"
		cQuery += " FROM " + RetSqlName("SE2") + " SE2"
		cQuery += " INNER JOIN " + RetSqlName("SA2") + " SA2 ON SA2.A2_FILIAL = ? AND SA2.A2_COD = SE2.E2_FORNECE AND SA2.A2_LOJA = SE2.E2_LOJA AND SA2.D_E_L_E_T_ = ?"
		cQuery += " WHERE SE2.E2_FILIAL = ?"
		cQuery += "	  AND SE2.E2_FORNECE BETWEEN ? AND ?"
		cQuery += "	  AND SE2.E2_EMISSAO BETWEEN ? AND ?"
		cQuery += "	  AND SE2.E2_NATUREZ BETWEEN ? AND ?"
		cQuery += "   AND SE2.D_E_L_E_T_ = ?"
	Endif

	// Agrega os filtros na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += " AND ? " + ' ' + " ? ? "
	Next

	cQuery := ChangeQuery(cQuery)
	oExecA := FwExecStatement():New( cQuery )

	nSeq := 0

	If "CLIENTE" $ cExp
		oExecA:SetUnSafe( nSeq += 1, cCpoSA1 )
		oExecA:SetUnSafe( nSeq += 1, cCpoSE1 )
	Else
		oExecA:SetUnSafe( nSeq += 1, cCpoSA2 )
		oExecA:SetUnSafe( nSeq += 1, cCpoSE2 )
	Endif
	oExecA:SetString( nSeq += 1, IIF(lCliente,xFilial("SA1"),xFilial("SA2")) )			// A1_FILIAL OU A2_FILIAL
	oExecA:SetString( nSeq += 1, ' ' )						// SA1.D_E_L_E_T_
	oExecA:SetString( nSeq += 1, IIF(lCliente,xFilial("SE1"),xFilial("SE2")) )			// E1_FILIAL OU E2_FILIAL
	oExecA:SetString( nSeq += 1, jParams['MV_PAR01'][1] )	// E1_CLIENTE OU E2_FORNECE
	oExecA:SetString( nSeq += 1, jParams['MV_PAR02'][1] )	// E1_CLIENTE OU E2_FORNECE
	oExecA:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR03'][1] )[1] ) )
	oExecA:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR04'][1] )[1] ) )
	oExecA:SetString( nSeq += 1, jParams['MV_PAR05'][1] )	// E1_NATUREZ OU E2_NATUREZ
	oExecA:SetString( nSeq += 1, jParams['MV_PAR06'][1] )	// E1_NATUREZ OU E2_NATUREZ
	oExecA:SetString( nSeq += 1, ' ' )						// SE1.D_E_L_E_T_
	For nX := 1 To Len( aFiltro )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 1] )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 2] )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 3] )
	Next

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	cAliasA := oExecA:OpenAlias( )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( cAliasA )->( EOF( ) )


		self:jItems := JsonObject():new( )
		self:nRecno := ( cAliasA )->REG

		// zera variaveis
		nCredito := 0
		nDebito  := 0
		nSaldo   := 0
		cComprovante := ""

		// busca baixas
		IF "CLIENTE" $ cExp
			cQuery := "SELECT DISTINCT FK1_DATA FK5_DATA, FK1_VALOR FK5_VALOR, FK1_ORDREC FK5_ORDREC, FK1_TPDOC FK5_TIPODOC, FK1_DOC FK5_DOCUMEN, ISNULL(FK5_STATUS,'') FK5_SITUACA, FK7_TIPO FK5_TIPO, FK1_MOTBX FK5_MOTBX, ?  FK1_RECPAG FK5_RECPAG"
			cQuery += " FROM " + RetSqlName("FK1") + " FK1"
			cQuery += " LEFT JOIN " + RetSqlName("FK7") + " FK7 ON FK7.FK7_FILIAL = ? AND FK7.FK7_IDDOC = FK1.FK1_IDDOC AND FK7.D_E_L_E_T_ = ?"
		Else
			cQuery := "SELECT DISTINCT FK2_DATA FK5_DATA, FK2_VALOR FK5_VALOR, FK2_ORDREC FK5_ORDREC, FK2_TPDOC FK5_TIPODOC, FK2_DOC FK5_DOCUMEN, ISNULL(FK5_STATUS,'') FK5_SITUACA, FK7_TIPO FK5_TIPO, FK2_MOTBX FK5_MOTBX, ?  FK2_RECPAG FK5_RECPAG"
			cQuery += " FROM " + RetSqlName("FK2") + " FK2
			cQuery += " LEFT JOIN " + RetSqlName("FK7") + " FK7 ON FK7.FK7_FILIAL = ? AND FK7.FK7_IDDOC = FK2.FK2_IDDOC AND FK7.D_E_L_E_T_ = ?"
		Endif
		cQuery += " LEFT JOIN  " + RetSqlName("FK5") + " FK5 ON FK5.FK5_FILIAL = ? AND FK5.FK5_IDFK7 = FK7.FK7_IDDOC AND FK5.D_E_L_E_T_ = ?"
		IF "CLIENTE" $ cExp
			cQuery += " WHERE FK1.FK1_FILIAL = ?"
		Else
			cQuery += " WHERE FK2.FK2_FILIAL = ?"
		Endif
		cQuery += " AND FK7.FK7_PREFIX = ?"
		cQuery += " AND FK7.FK7_NUM = ?"
		cQuery += " AND FK7.FK7_PARCEL = ?"
		cQuery += " AND FK7.FK7_TIPO = ?"
		cQuery += " AND FK7.FK7_CLIFOR = ?"
		cQuery += " AND FK7.FK7_LOJA = ?"
		cQuery += " AND FK7.D_E_L_E_T_ = ?"


		cQuery := ChangeQuery(cQuery)
		oExecB := FwExecStatement():New( cQuery )
		oExecB:SetUnSafe( 01, cCpoFK5 )
		oExecB:SetString( 02, xFilial('FK7') )			// FK7.FILIAL
		oExecB:SetString( 03, ' ' )						// D_E_L_E_T_
		oExecB:SetString( 04, xFilial('FK5') )			// FK5.FILIAL
		oExecB:SetString( 05, ' ' )						// D_E_L_E_T_
		IF "CLIENTE" $ cExp
			oExecB:SetString( 06, xFilial('FK1') )			// FK1_FILIAL
		Else
			oExecB:SetString( 06, xFilial('FK2') )			// FK2_FILIAL
		Endif
		IF "CLIENTE" $ cExp
			oExecB:SetString( 07, ( cAliasA )->E1_PREFIXO )	// FK5_PREFIXO
			oExecB:SetString( 08, ( cAliasA )->E1_NUM )		// FK5_NUMERO
			oExecB:SetString( 09, ( cAliasA )->E1_PARCELA )	// FK5_PARCELA
			oExecB:SetString( 10, ( cAliasA )->E1_TIPO )	// FK5_TIPO
			oExecB:SetString( 11, ( cAliasA )->E1_CLIENTE )	// FK5_CLIFOR
			oExecB:SetString( 12, ( cAliasA )->E1_LOJA )	// FK5_LOJA
		Else
			oExecB:SetString( 07, ( cAliasA )->E2_PREFIXO )	// FK5_PREFIXO
			oExecB:SetString( 08, ( cAliasA )->E2_NUM )		// FK5_NUMERO
			oExecB:SetString( 09, ( cAliasA )->E2_PARCELA )	// FK5_PARCELA
			oExecB:SetString( 10, ( cAliasA )->E2_TIPO )	// FK5_TIPO
			oExecB:SetString( 11, ( cAliasA )->E2_FORNECE )	// FK5_CLIFOR
			oExecB:SetString( 12, ( cAliasA )->E2_LOJA )	// FK5_LOJA
		Endif
		oExecB:SetString( 13, ' ' )						// FK7.D_E_L_E_T_

		cAliasB := oExecB:OpenAlias( )

		// Alimenta o objeto de dados da classe para retornar ao SmartView
		While !( cAliasB )->( EOF( ) )

			If (( cAliasB )->FK5_TIPODOC == IIF(lCliente,"RA","PA") .And. EMPTY(( cAliasB )->FK5_DOCUMEN)  .And. EMPTY(( cAliasB )->FK5_ORDREC)) .OR. (( cAliasB )->FK5_SITUACA $("C|X") .And. EMPTY(( cAliasB )->FK5_ORDREC))
				( cAliasB )->( DbSkip() )
				Loop
			EndIf

			If (( cAliasB )->FK5_SITUACA $ "C" .And. !EMPTY(( cAliasB )->FK5_ORDREC))  //caso o recibo tenha sido cancelado
				( cAliasB )->( DbSkip() )
				Loop
			EndIf

			If ( cAliasB )->FK5_TIPO $ MVPAGANT .And. ( cAliasB )->FK5_TIPODOC=="BA".AND. ( cAliasB )->FK5_MOTBX=='NOR'.AND. ( cAliasB )->FK5_RECPAG=="P" .And. EMPTY(( cAliasB )->FK5_DOCUMEN) //PA GERADO SEM GERAR CHEQUE
				( cAliasB )->( DbSkip() )
				Loop
			EndIf

			If "CLIENTE" $ cExp
				If ( cAliasA )->E1_TIPO $ MV_CRNEG + "/" + MVRECANT
					nDebito += ( cAliasB )->FK5_VALOR
				Else
					nCredito += ( cAliasB )->FK5_VALOR
				Endif
			Else
				If ( cAliasA )->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
					nDebito += ( cAliasB )->FK5_VALOR
				Else
					nCredito += ( cAliasB )->FK5_VALOR
				Endif
			Endif

			cComprovante += DTOC(STOD(( cAliasB )->FK5_DATA)) + " " + AllTrim(( cAliasB )->FK5_ORDREC)+" | "
			( cAliasB )->( DbSkip() )

		End
		( cAliasB )->( DbCloseArea() )

		oExecB:Destroy( )
		oExecB := Nil

		// calcula saldo
		If "CLIENTE" $ cExp
			If ( cAliasA )->E1_TIPO $ MV_CRNEG + "/" + MVRECANT
				nCredito := ( cAliasA )->E1_VALOR
			Else
				nDebito  := ( cAliasA )->E1_VALOR
			Endif
		Else
			If ( cAliasA )->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
				nCredito  := ( cAliasA )->E2_VALOR
			Else
				nDebito := ( cAliasA )->E2_VALOR
			Endif

		Endif

		// saldo final
		nSaldo := nDebito - nCredito

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf ( self:aStruct[nX][3] == 'date' )
				self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
			ElseIf ( self:aStruct[nX][5] == "COMPROVANTE" )
				self:jItems[self:aStruct[nX][1]] := cComprovante
			ElseIf ( self:aStruct[nX][5] == "DEBITO" )
				self:jItems[self:aStruct[nX][1]] := nDebito
			ElseIf ( self:aStruct[nX][5] == "CREDITO" )
				self:jItems[self:aStruct[nX][1]] := nCredito
			ElseIf ( self:aStruct[nX][5] == "SALDO" )
				self:jItems[self:aStruct[nX][1]] := nSaldo
			Else
				self:jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
			Endif
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		//self:processData()
		self:oData:appendData( self:jItems )

		( cAliasA )->( DbSkip( ) )

	End
	( cAliasA )->( DbCloseArea( ) )

	oExecA:Destroy( )
	oExecA := Nil

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
@description Retorna la estructura de los campos
@return object: self:oSchema
@author Marcelo Hruschka
@since 19/11/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema() as object class compensationTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTView
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )
