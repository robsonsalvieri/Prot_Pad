#INCLUDE 'totvs.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fin.taccount.ch'

namespace custom.financeiro.taccount.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} backoffice.sv.fin.taccount
@description Classe para creación del Objeto de Negocio de cuenta de cliente y provvedores - SMARTVIEW
@author Leonardo Pereira
@since 19/11/2024
@version 1.1
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFIN', tables='SA1,SA2,SE1,SE2,SE5,SEK,SEL,SX5', name='Cuentas T Clientes y Proveedores', country='ALL', initialRelease='12.1.2310', customTables='SA1,SA2,SE1,SE2' )
class taccountTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected Data aFields as array
	protected Data aStruct as array
	protected Data jItems as json
	protected Data jParams as json
	protected Data cAliasA as json

	protected Method calculaSaldoInicial() as numeric

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe 
@Return object: self
@author Leonardo Pereira
@since 31/10/2024
@version 1.0
*/
//-------------------------------------------------------------------
Method new() class taccountTReportsBusinessObject

	Local aCpos := { } as array

	_Super:new( )

	// Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 )  // 'Cuenta T de  Clientes o Proveedores'

	// Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 )  // 'Cuenta T de  Clientes o Proveedores'

	// Define a Área
	self:appendArea( STR0002 ) // 'Financeiro'

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'FINSV551' )
		IIf(!self:setErrorStatus( 400, STR0003, STR0004 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0005,,, ),'') // 'Sin Preguntas' // '¡Verifique el grupo de preguntas dado!' // 'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0006,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// campos que no existen en SX3
	aAdd( aCpos, { 'E1_DEBCRE', STR0007, 'string', STR0007 } ) // 'Debito/Credito'
	aAdd( aCpos, { 'E1_SLDINI', STR0008, 'number', STR0008 } ) // 'Saldo Inicial'
	aAdd( aCpos, { 'E1_SLDATU', STR0009, 'number', STR0009 } ) // 'Saldo Atual'

	// Demais campos
	self:aFields := { 'E1_FILIAL', 'E1_PORTADO', 'E1_PREFIXO', 'E1_NUM', 'E1_PARCELA', 'E1_TIPO', 'A1_COD', 'A1_LOJA', 'A1_NOME', 'E1_EMISSAO', 'E1_VENCREA', 'E1_VALOR', 'E1_DEBCRE', 'E1_SLDINI', 'E1_SLDATU', 'E1_MOEDA', 'E1_TXMOEDA', 'E1_HIST' }

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio
@param nPage, numérico, indica la pagina actual del relatório
@param oFilter, objeto, contiene el filtro del TReports
@return object: self:oData
@author Leonardo Pereira
@since 31/10/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class taccountTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery		  as character
	Local cFiltro 		  as character
	Local cCpoSA1		  as character
	Local cCpoSA2		  as character
	Local cCpoSE1		  as character
	Local cCpoSE2		  as character
	Local cExp 			  as character
	Local cAliasB		  as character

	Local nX			     as numeric
	Local n1			     as numeric

	Local aPDFields	  as array
	Local aFiltro		  as array
	Local aCustomFields as array

	Local lObfuscated	  as logical

	Local oExecA		  as object
	Local oExecB		  as object

	cFiltro 			:= ''
	cExp 				:= ''
	cAliasB			:= ''

	nX 				:= 0
	n1				   := 0

	aPDFields		:= { }
	aFiltro			:= { }
	aCustomFields	:= { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	self:jParams := oFilter:getParameters( )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	cCpoSA1 := getCpoUser( aCustomFields, 'SA1', 'A1', ',' )
	cCpoSA2 := getCpoUser( aCustomFields, 'SA2', 'A2', ',' )
	cCpoSE1 := getCpoUser( aCustomFields, 'SE1', 'E1', ',' )
	cCpoSE2 := getCpoUser( aCustomFields, 'SE2', 'E2', ',' )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	If oFilter:hasFilter( )
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )
		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )
	EndIf

	If ( self:jParams['MV_PAR03'][1] == 1 )
		// Realiza a montagem da QUERY que será enviada para o smartview
		cQuery := "SELECT SE1.E1_FILIAL, SE1.E1_PORTADO, SE1.E1_PREFIXO, SE1.E1_NUM, SE1.E1_PARCELA, SE1.E1_TIPO, ? "
		cQuery += "SA1.A1_COD  CLIFOR, SA1.A1_LOJA  LOJA, SA1.A1_NOME  NOME, ? "
		cQuery += "SE1.E1_EMISSAO, SE1.E1_VENCREA, SE1.E1_VALOR, SE1.E1_MOEDA, SE1.E1_TXMOEDA, SE1.E1_HIST, SE1.E1_FATURA, SE1.E1_DTFATUR, SE1.E1_BAIXA "

		cQuery += "FROM " + RetSQLName( 'SA1' ) +  " SA1 "

		cQuery += "LEFT JOIN " + RetSqlName( 'SE1' ) + " SE1 "
		cQuery += "   ON SA1.A1_FILIAL = ? "
		cQuery += "      AND SA1.A1_COD = SE1.E1_CLIENTE "
		cQuery += "      AND SA1.A1_LOJA = SE1.E1_LOJA "
		cQuery += "      AND SA1.D_E_L_E_T_ = ? "

		cQuery += "WHERE SE1.E1_FILIAL = ? "
		cQuery += "   AND SE1.E1_PREFIXO BETWEEN ? AND ? "
		cQuery += "   AND SE1.E1_CLIENTE BETWEEN ? AND ? "
		cQuery += "   AND SE1.E1_EMISSAO BETWEEN ? AND ? "
		cQuery += "   AND SUBSTRING(SE1.E1_TIPO,1,2) != ? "
		cQuery += "   AND SE1.E1_TIPO NOT IN(?) "
		cQuery += "   AND SUBSTRING(SE1.E1_TIPO,3,1) != ? "
		cQuery += "   AND SE1.E1_PREFIXO != ? "
		cQuery += "   AND SE1.E1_CLIENTE != ? "
		cQuery += "   AND SE1.E1_MOEDA = ?"
		cQuery += "   AND SE1.D_E_L_E_T_ = ? "
	ElseIf ( self:jParams['MV_PAR03'][1] == 2 )
		// Realiza a montagem da QUERY que será enviada para o smartview
		cQuery := "SELECT SE2.E2_FILIAL  E1_FILIAL, SE2.E2_PORTADO  E1_PORTADO, SE2.E2_PREFIXO  E1_PREFIXO, SE2.E2_NUM  E1_NUM, SE2.E2_PARCELA  E1_PARCELA, SE2.E2_TIPO  E1_TIPO, ? "
		cQuery += "SA2.A2_COD  CLIFOR, SA2.A2_LOJA  LOJA, SA2.A2_NOME  NOME, ? "
		cQuery += "SE2.E2_EMISSAO  E1_EMISSAO, SE2.E2_VENCREA  E1_VENCREA, SE2.E2_VALOR  E1_VALOR, SE2.E2_MOEDA  E1_MOEDA, SE2.E2_TXMOEDA  E1_TXMOEDA, SE2.E2_HIST  E1_HIST, SE2.E2_FATURA  E1_FATURA, SE2.E2_DTFATUR  E1_DTFATUR, SE2.E2_BAIXA  E1_BAIXA "

		cQuery += "FROM " + RetSQLName( 'SA2' ) +  " SA2 "

		cQuery += "INNER JOIN " + RetSqlName( 'SE2' ) + " SE2 "
		cQuery += "   ON SA2.A2_FILIAL = ? "
		cQuery += "      AND SA2.A2_COD = SE2.E2_FORNECE "
		cQuery += "      AND SA2.A2_LOJA = SE2.E2_LOJA "
		cQuery += "      AND SA2.D_E_L_E_T_ = ? "

		cQuery += "WHERE SE2.E2_FILIAL = ? "
		cQuery += "   AND SE2.E2_PREFIXO BETWEEN ? AND ? "
		cQuery += "   AND SE2.E2_FORNECE BETWEEN ? AND ? "
		cQuery += "   AND SE2.E2_EMISSAO BETWEEN ? AND ? "
		cQuery += "   AND SUBSTRING(SE2.E2_TIPO,1,2) != ? "
		cQuery += "   AND SE2.E2_MOEDA = ?"
		cQuery += "   AND SE2.D_E_L_E_T_ = ? "
	EndIf

	// Agrega os filtros na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += " AND ? " + ' ' + " ? ? "
	Next

	cQuery := ChangeQuery( cQuery )

	oExecA := FwExecStatement( ):New( cQuery )

	If ( self:jParams['MV_PAR03'][1] == 1 )
		nSeq := 1
		oExecA:SetUnSafe( nSeq++, cCpoSE1 )
		oExecA:SetUnSafe( nSeq++, cCpoSA1 )
		oExecA:SetString( nSeq++, FWxFilial( 'SA1' ) )
		oExecA:SetString( nSeq++, ' ' )
		oExecA:SetString( nSeq++, FWxFilial( 'SE1' ) )
		oExecA:SetString( nSeq++, self:jParams['MV_PAR06'][1] )
		oExecA:SetString( nSeq++, self:jParams['MV_PAR07'][1] )
		oExecA:SetString( nSeq++, self:jParams['MV_PAR04'][1] )
		oExecA:SetString( nSeq++, self:jParams['MV_PAR05'][1] )
		oExecA:SetString( nSeq++, DtoS( FwDateTimeToLocal( self:jParams['MV_PAR01'][1] )[1] ) )
		oExecA:SetString( nSeq++, DtoS( FwDateTimeToLocal( self:jParams['MV_PAR02'][1] )[1] ) )
		oExecA:SetString( nSeq++, MVPROVIS )
		oExecA:SetIn( nSeq++, StrToArray( MVRECANT + '|' + MV_CRNEG, '|' ) )
		oExecA:SetString( nSeq++, '-' )
		oExecA:SetString( nSeq++, 'REC' )
		oExecA:SetString( nSeq++, AllTrim( GetMv( 'MV_UNIAO' ) ) )
		oExecA:SetString( nSeq++, AllTrim(Str(self:jParams['MV_PAR08'][1])) )
		oExecA:SetString( nSeq++, ' ' )
	ElseIf ( self:jParams['MV_PAR03'][1] == 2 )
		nSeq := 1
		oExecA:SetUnSafe( nSeq++, cCpoSE2 )
		oExecA:SetUnSafe( nSeq++, cCpoSA2 )
		oExecA:SetString( nSeq++, FWxFilial( 'SA2' ) )
		oExecA:SetString( nSeq++, ' ' )
		oExecA:SetString( nSeq++, FWxFilial( 'SE2' ) )
		oExecA:SetString( nSeq++, self:jParams['MV_PAR06'][1] )
		oExecA:SetString( nSeq++, self:jParams['MV_PAR07'][1] )
		oExecA:SetString( nSeq++, self:jParams['MV_PAR04'][1] )
		oExecA:SetString( nSeq++, self:jParams['MV_PAR05'][1] )
		oExecA:SetString( nSeq++, DtoS( FwDateTimeToLocal( self:jParams['MV_PAR01'][1] )[1] ) )
		oExecA:SetString( nSeq++, DtoS( FwDateTimeToLocal( self:jParams['MV_PAR02'][1] )[1] ) )
		oExecA:SetString( nSeq++, 'PR' )
		oExecA:SetString( nSeq++, AllTrim(Str(self:jParams['MV_PAR08'][1])) )
		oExecA:SetString( nSeq++, ' ' )
	EndIf
	For nX := 1 To Len( aFiltro )
		oExecA:SetUnSafe ( nSeq++ , aFiltro[nX, 1] )
		oExecA:SetUnSafe ( nSeq++ , aFiltro[nX, 2] )
		oExecA:SetUnSafe ( nSeq++ , aFiltro[nX, 3] )
	Next
	cQuery := oExecA:getFixQuery( )

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	self:cAliasA := oExecA:OpenAlias( )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( self:cAliasA )->( EOF( ) )
		self:jItems := JsonObject():new( )

		If ( self:jParams['MV_PAR03'][1] == 1 )
			For nX := 1 To Len( self:aStruct )
				If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
					self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( self:cAliasA )->&( self:aStruct[nX][5] ) )
				ElseIf ( self:aStruct[nX][3] == 'date' )
					self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( self:cAliasA )->&( self:aStruct[nX][5] ) ) )
				ElseIf ( self:aStruct[nx][5] == 'E1_DEBCRE' )
					If ( ( self:cAliasA )->E1_TIPO $ MV_CRNEG + "|" + MVRECANT + "|" + MVCHEQUES .Or. ( SubStr( ( self:cAliasA )->E1_TIPO, 3, 1 ) == "-" ) )
						self:jItems[self:aStruct[nX][1]] := "C"
					Else
						self:jItems[self:aStruct[nX][1]] := "D"
					EndIf
				ElseIf ( self:aStruct[nx][5] == 'E1_SLDINI' )
					self:jItems[self:aStruct[nX][1]] := self:calculaSaldoInicial( )
				ElseIf ( self:aStruct[nx][5] == 'E1_SLDATU' )
					self:jItems[self:aStruct[nX][1]] := ( self:calculaSaldoInicial( ) - ( self:cAliasA )->E1_VALOR )
				ElseIf ( self:aStruct[nx][5] == 'A1_COD' )
					self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->CLIFOR
				ElseIf ( self:aStruct[nx][5] == 'A1_LOJA' )
					self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->LOJA
				ElseIf ( self:aStruct[nx][5] == 'A1_NOME' )
					self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->NOME
				Else
					self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->&( self:aStruct[nX][5] )
				EndIf
			Next

			self:oData:appendData( self:jItems )

			If ( AllTrim(( self:cAliasA )->E1_FATURA) == "NOTFAT" ) .And. ( ( self:cAliasA )->E1_DTFATUR <= DtoS( FwDateTimeToLocal( self:jParams['MV_PAR02'][1] )[1] ) ) .And. ( ( self:cAliasA )->E1_BAIXA <= DtoS( FwDateTimeToLocal( self:jParams['MV_PAR02'][1] )[1] ) )

				// Realiza a montagem da QUERY que será enviada para o smartview
				cQuery := "SELECT SE1.E1_FILIAL, SE1.E1_PORTADO, SE1.E1_PREFIXO, SE1.E1_NUM, SE1.E1_PARCELA, SE1.E1_TIPO, ? "
				cQuery += "SA1.A1_COD, SA1.A1_LOJA, SA1.A1_NOME, ? "
				cQuery += "SE1.E1_EMISSAO, SE1.E1_VENCREA, SE1.E1_VALOR, SE1.E1_MOEDA, SE1.E1_TXMOEDA, SE1.E1_HIST, SE1.E1_FATURA "
				cQuery += "FROM " + RetSQLName( 'SE1' ) +  " SE1 "
				cQuery += "LEFT JOIN " + RetSqlName( 'SA1' ) + " SA1 "
				cQuery += "   ON SA1.A1_FILIAL = ? "
				cQuery += "      AND SA1.A1_COD = SE1.E1_CLIENTE "
				cQuery += "      AND SA1.A1_LOJA = SE1.E1_LOJA "
				cQuery += "      AND SA1.D_E_L_E_T_ = ? "
				cQuery += "WHERE SE1.E1_FILIAL = ? "
				cQuery += "   AND SE1.E1_FATPREF = ? "
				cQuery += "   AND SE1.E1_CLIENTE = ? "
				cQuery += "   AND SE1.E1_LOJA = ? "
				cQuery += "   AND SE1.E1_FATURA = ? "
				cQuery += "   AND SE1.D_E_L_E_T_ = ? "

				cQuery := ChangeQuery( cQuery )

				oExecB := FwExecStatement( ):New( cQuery )

				nSeq := 1
				oExecB:SetUnSafe( nSeq++, cCpoSE1 )
				oExecB:SetUnSafe( nSeq++, cCpoSA1 )
				oExecB:SetString( nSeq++, FWxFilial( 'SA1' ) )
				oExecB:SetString( nSeq++, ' ' )
				oExecB:SetString( nSeq++, ( self:cAliasA )->E1_FILIAL )
				oExecB:SetString( nSeq++, ( self:cAliasA )->E1_PREFIXO )
				oExecB:SetString( nSeq++, ( self:cAliasA )->CLIFOR )
				oExecB:SetString( nSeq++, ( self:cAliasA )->LOJA )
				oExecB:SetString( nSeq++, ( self:cAliasA )->E1_NUM )
				oExecB:SetString( nSeq++, ' ' )

				cQuery := oExecB:getFixQuery( )

				// Executa a QUERY e cria uma tabela temporaria com os dados retornados
				cAliasB := oExecB:OpenAlias( )

				// Alimenta o objeto de dados da classe para retornar ao SmartView
				While !( cAliasB )->( EOF( ) )
					self:jItems := JsonObject( ):new( )

					For nX := 1 To Len( self:aStruct )
						If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
							self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
						ElseIf ( self:aStruct[nX][3] == 'date' )
							self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
							//ElseIf ( self:aStruct[nx][5] == 'E1_VALOR' )
							//	self:jItems[self:aStruct[nX][1]] := self:converteMovimento( ( cAliasB )->&( self:aStruct[nX][5] ) )
						ElseIf ( self:aStruct[nx][5] == 'E1_DEBCRE' )
							If SubStr( ( cAliasB )->E1_TIPO, 3, 1 ) != "-" .And. !( ( cAliasB )->E1_TIPO $ MV_CRNEG + "," + MVRECANT + "," + MVCHEQUES )
								self:jItems[self:aStruct[nX][1]] := "C"
							Else
								self:jItems[self:aStruct[nX][1]] := "D"
							EndIf
						ElseIf ( self:aStruct[nx][5] == 'E1_SLDINI' )
							self:jItems[self:aStruct[nX][1]] := self:calculaSaldoInicial( )
						ElseIf ( self:aStruct[nx][5] == 'E1_SLDATU' )
							self:jItems[self:aStruct[nX][1]] := ( self:calculaSaldoInicial( ) - ( self:cAliasA )->E1_VALOR )
						ElseIf ( self:aStruct[nx][5] == 'A1_COD' )
							self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->CLIFOR
						ElseIf ( self:aStruct[nx][5] == 'A1_LOJA' )
							self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->LOJA
						ElseIf ( self:aStruct[nx][5] == 'A1_NOME' )
							self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->NOME
						ElseIf ( self:aStruct[nx][5] == 'E1_HIST' )
							self:jItems[self:aStruct[nX][1]] := ( cAliasB )->E1_FATURA
						Else
							self:jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
						EndIf
					Next

					self:oData:appendData( self:jItems )

					( cAliasB )->( DbSkip( ) )
				End
				( cAliasB )->( DbCloseArea( ) )

				oExecB:Destroy( )
				oExecB := Nil
			EndIf
		ElseIf ( self:jParams['MV_PAR03'][1] == 2 )
			For nX := 1 To Len( self:aStruct )
				If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
					self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( self:cAliasA )->&( self:aStruct[nX][5] ) )
				ElseIf ( self:aStruct[nX][3] == 'date' )
					self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( self:cAliasA )->&( self:aStruct[nX][5] ) ) )
					//ElseIf ( self:aStruct[nx][5] == 'E1_VALOR' )
					//	self:jItems[self:aStruct[nX][1]] := self:converteMovimento( ( self:cAliasA )->&( self:aStruct[nX][5] ) )
				ElseIf ( self:aStruct[nx][5] == 'E1_DEBCRE' )
					If ( ( self:cAliasA )->E1_TIPO $ MV_CPNEG + "|" + MVPAGANT ) 
						self:jItems[self:aStruct[nX][1]] := "D"
					Else
						self:jItems[self:aStruct[nX][1]] := "C"
					EndIf
				ElseIf ( self:aStruct[nx][5] == 'E1_SLDINI' )
					self:jItems[self:aStruct[nX][1]] := self:calculaSaldoInicial( )
				ElseIf ( self:aStruct[nx][5] == 'E1_SLDATU' )
					self:jItems[self:aStruct[nX][1]] := ( self:calculaSaldoInicial( ) + ( self:cAliasA )->E1_VALOR )
				ElseIf ( self:aStruct[nx][5] == 'A1_COD' )
					self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->CLIFOR
				ElseIf ( self:aStruct[nx][5] == 'A1_LOJA' )
					self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->LOJA
				ElseIf ( self:aStruct[nx][5] == 'A1_NOME' )
					self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->NOME
				Else
					self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->&( self:aStruct[nX][5] )
				EndIf
			Next

			self:oData:appendData( self:jItems )

			If ( AllTrim(( self:cAliasA )->E1_FATURA) == "NOTFAT" )
				// Realiza a montagem da QUERY que será enviada para o smartview
				cQuery := "SELECT SE2.E2_FILIAL  E1_FILIAL, SE2.E2_PORTADO  E1_PORTADO, SE2.E2_PREFIXO  E1_PREFIXO, SE2.E2_NUM  E1_NUM, SE2.E2_PARCELA  E1_PARCELA, SE2.E2_TIPO  E1_TIPO, ? "
				cQuery += "SA2.A2_COD  CLIFOR, SA2.A2_LOJA  LOJA, SA2.A2_NOME  NOME, ? "
				cQuery += "SE2.E2_EMISSAO  E1_EMISSAO, SE2.E2_VENCREA  E1_VENCREA, SE2.E2_VALOR  E1_VALOR, SE2.E2_MOEDA  E1_MOEDA, SE2.E2_TXMOEDA  E1_TXMOEDA, SE2.E2_HIST  E1_HIST, SE2.E2_FATURA  E1_FATURA "
				cQuery += "FROM " + RetSQLName( 'SE2' ) +  " SE2 "
				cQuery += "INNER JOIN " + RetSqlName( 'SA2' ) + " SA2 "
				cQuery += "   ON SA2.A2_FILIAL = ? "
				cQuery += "      AND SA2.A2_COD = SE2.E2_FORNECE "
				cQuery += "      AND SA2.A2_LOJA = SE2.E2_LOJA "
				cQuery += "      AND SA2.D_E_L_E_T_ = ? "
				cQuery += "WHERE SE2.E2_FILIAL = ? "
				cQuery += "   AND SE2.E2_FATPREF = ? "
				cQuery += "   AND SE2.E2_FORNECE = ? "
				cQuery += "   AND SE2.E2_LOJA = ? "
				cQuery += "   AND SE2.E2_FATURA = ? "
				cQuery += "   AND SE2.D_E_L_E_T_ = ? "

				cQuery := ChangeQuery( cQuery )

				oExecB := FwExecStatement( ):New( cQuery )

				nSeq := 1
				oExecB:SetUnSafe( nSeq++, cCpoSE2 )
				oExecB:SetUnSafe( nSeq++, cCpoSA2 )
				oExecB:SetString( nSeq++, FWxFilial( 'SA2' ) )
				oExecB:SetString( nSeq++, ' ' )
				oExecB:SetString( nSeq++, ( self:cAliasA )->E1_FILIAL )
				oExecB:SetString( nSeq++, ( self:cAliasA )->E1_PREFIXO )
				oExecB:SetString( nSeq++, ( self:cAliasA )->CLIFOR )
				oExecB:SetString( nSeq++, ( self:cAliasA )->LOJA )
				oExecB:SetString( nSeq++, ( self:cAliasA )->E1_NUM )
				oExecB:SetString( nSeq++, ' ' )

				cQuery := oExecB:getFixQuery( )

				// Executa a QUERY e cria uma tabela temporaria com os dados retornados
				cAliasB := oExecB:OpenAlias( )

				// Alimenta o objeto de dados da classe para retornar ao SmartView
				While !( cAliasB )->( EOF( ) )
					self:jItems := JsonObject( ):new( )

					For nX := 1 To Len( self:aStruct )
						If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
							self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
						ElseIf ( self:aStruct[nX][3] == 'date' )
							self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
							//ElseIf ( self:aStruct[nx][5] == 'E1_VALOR' )
							//	self:jItems[self:aStruct[nX][1]] := self:converteMovimento( ( cAliasB )->&( self:aStruct[nX][5] ) )
						ElseIf ( self:aStruct[nx][5] == 'E1_DEBCRE' )
							If SubStr( ( cAliasB )->E1_TIPO, 3, 1 ) != "-" .And. ! ( ( cAliasB )->E1_TIPO $ "PA /" + MV_CPNEG )
								self:jItems[self:aStruct[nX][1]] := "C"
							Else
								self:jItems[self:aStruct[nX][1]] := "D"
							EndIf
						ElseIf ( self:aStruct[nx][5] == 'E1_SLDINI' )
							self:jItems[self:aStruct[nX][1]] := self:calculaSaldoInicial( )
						ElseIf ( self:aStruct[nx][5] == 'E1_SLDATU' )
							self:jItems[self:aStruct[nX][1]] := ( self:calculaSaldoInicial( ) - ( self:cAliasA )->E1_VALOR )
						ElseIf ( self:aStruct[nx][5] == 'A1_COD' )
							self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->CLIFOR
						ElseIf ( self:aStruct[nx][5] == 'A1_LOJA' )
							self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->LOJA
						ElseIf ( self:aStruct[nx][5] == 'A1_NOME' )
							self:jItems[self:aStruct[nX][1]] := ( self:cAliasA )->NOME
						ElseIf ( self:aStruct[nx][5] == 'E1_HIST' )
							self:jItems[self:aStruct[nX][1]] := ( cAliasB )->E1_FATURA
						Else
							self:jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
						EndIf
					Next

					self:oData:appendData( self:jItems )

					( cAliasB )->( DbSkip( ) )
				End
				( cAliasB )->( DbCloseArea( ) )

				oExecB:Destroy( )
				oExecB := Nil
			EndIf

		EndIf
		( self:cAliasA )->( DbSkip( ) )
	End

	( self:cAliasA )->( DbCloseArea( ) )

	oExecA:Destroy( )
	oExecA := Nil

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
@description Retorna la estructura de los campos
@return object: self:oSchema
@author Leonardo Pereira
@since 31/10/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema() as object class taccountTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTView
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )

//-------------------------------------------------------------------
/*{Protheus.doc} new
Retorna o calculo do saldo inicial do cliente/fornecedor
@Return object: self
@author Leonardo Pereira
@since 30/11/2024
@version 1.0
*/
//-------------------------------------------------------------------
Method calculaSaldoInicial() class taccountTReportsBusinessObject

	Local nRet as numeric
	Local nSeq as numeric

	Local cQuery as character
	Local cAliasC as character

	Local oExecC as object

	nRet := 0
	nSeq := 0

	// Realiza a montagem da QUERY que será enviada para o smartview
	cQuery := "SELECT ? SALDOINICIAL "
	cQuery += "FROM ? "
	If ( self:jParams['MV_PAR03'][1] == 1 )
		cQuery += "WHERE SE1.E1_FILIAL = ? "
		cQuery += "   AND SE1.E1_CLIENTE = ? "
		cQuery += "   AND SE1.E1_LOJA = ? "
		cQuery += "   AND SE1.E1_EMISSAO < ? "
		cQuery += "   AND SE1.D_E_L_E_T_ = ? "
		cQuery += "   AND SE1.E1_NATUREZ = ''"
		cQuery += "   AND SE1.E1_PREFIXO <> 'REC'"
	ElseIf ( self:jParams['MV_PAR03'][1] == 2 )
		cQuery += "WHERE SE2.E2_FILIAL = ? "
		cQuery += "   AND SE2.E2_FORNECE = ? "
		cQuery += "   AND SE2.E2_LOJA = ? "
		cQuery += "   AND SE2.E2_EMISSAO < ? "
		cQuery += "   AND SE2.D_E_L_E_T_ = ? "
	EndIf

	cQuery := ChangeQuery( cQuery )

	oExecC := FwExecStatement( ):New( cQuery )

	nSeq := 1

	oExecC:SetUnSafe( nSeq++, IIf( ( self:jParams['MV_PAR03'][1] == 1 ), "SUM(SE1.E1_VALOR)", "SUM(SE2.E2_VALOR)" ) )
	oExecC:SetUnSafe( nSeq++, IIf( ( self:jParams['MV_PAR03'][1] == 1 ), RetSQLName( 'SE1' ) +  " SE1 ", RetSQLName( 'SE2' ) +  " SE2 " ))
	oExecC:SetString( nSeq++, ( self:cAliasA )->E1_FILIAL )
	oExecC:SetString( nSeq++, ( self:cAliasA )->CLIFOR )
	oExecC:SetString( nSeq++, ( self:cAliasA )->LOJA )
	oExecC:SetString( nSeq++, DtoS( FwDateTimeToLocal( self:jParams['MV_PAR01'][1] )[1] ) )
	oExecC:SetString( nSeq++, ' ' )

	cQuery := oExecC:getFixQuery( )

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	cAliasC := oExecC:OpenAlias( )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( cAliasC )->( EOF( ) )
		nRet := ( cAliasC )->SALDOINICIAL
		( cAliasC )->( DbSkip( ) )
	End

	oExecC:Destroy( )
	oExecC := Nil

Return( nRet )

