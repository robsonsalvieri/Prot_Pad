#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fin.PaymentOrder.ch'

namespace custom.financeiro.OrdenesPago.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} OrdenesPagoTReportsBusinessObject
@Description Classe para creación del Objeto de Negocio de Órdenes de Pago para TReports 
@author Leonardo Pereira
@since 18/07/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider(active=.T., team='SIGAFIN', tables='SEK,SA2,SFE', name='Ordenes de Pago', country='ALL', initialRelease='12.1.2310' )
class OrdenesPagoTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Description Description Método de instância da classe
@Return object: self
@author Leonardo Pereira
@since 18/07/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method new() class OrdenesPagoTReportsBusinessObject
	Local aCpos := {} as array

	_Super:new()

	// Define a Área
	self:appendArea( STR0001 )  // 'Financiero'

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0012 ) // "Ordenes de Pago"

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0013 ) // "Lista detallada de ordenes de Pago"

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte('FINSV998') // Indica o pergunte que será utilizado
		IIf(!self:setErrorStatus( 400, STR0002, STR0003 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0004,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0005 ,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// Adiciona os campos virtuais/calculados
	aAdd( aCpos, { 'EK_DESMOE' , STR0006 		, 'string', STR0007 } ) // 'Descripción de la moneda' # 'Desc. Moneda'
	aAdd( aCpos, { 'EK_DESTIPO', STR0008 		, 'string', STR0009 } ) // "Tipo de Retención" # "Retención"
	aAdd( aCpos, { 'EK_IDGRUPO', STR0010 		, 'string', STR0011 } ) // 'Identificación de grupo' # 'ID Grupo'
	aAdd( aCpos, { 'M0_NOMECOM', 'M0_NOMECOM'	, 'string', 'M0_NOMECOM'} )
	aAdd( aCpos, { 'M0_ENDCOB' , 'M0_ENDCOB'	, 'string', 'M0_ENDCOB'	} )
	aAdd( aCpos, { 'M0_COMPCOB', 'M0_COMPCOB'	, 'string', 'M0_COMPCOB'} )
	aAdd( aCpos, { 'M0_BAIRCOB', 'M0_BAIRCOB'	, 'string', 'M0_BAIRCOB'} )
	aAdd( aCpos, { 'M0_CIDCOB' , 'M0_CIDCOB'	, 'string', 'M0_CIDCOB'	} )
	aAdd( aCpos, { 'M0_ESTCOB' , 'M0_ESTCOB'	, 'string', 'M0_ESTCOB'	} )
	aAdd( aCpos, { 'M0_TEL'    , 'M0_TEL'		, 'string', 'M0_TEL'	} )

	self:aFields := { 'EK_FORNEPG', 'EK_LOJAPG', 'EK_ORDPAGO', 'EK_TIPODOC', 'EK_TIPO', 'EK_PREFIXO', 'EK_NUM', 'EK_PARCELA', 'EK_EMISSAO', 'EK_VENCTO', 'EK_MOEDA', 'EK_BANCO', 'EK_AGENCIA', 'EK_CONTA', 'EK_VALOR', 'EK_VALORIG', 'EK_SALDO', 'EK_VLMOED1', 'EK_DESCONT', 'EK_JUROS', 'EK_NATUREZ', 'A2_NOME', 'A2_END', 'A2_MUN', 'A2_EST', 'A2_CGC', 'A2_EMAIL', 'A2_TEL', 'EK_DESMOE', 'EK_DESTIPO', 'EK_IDGRUPO', 'M0_NOMECOM' , 'M0_ENDCOB' , 'M0_COMPCOB', 'M0_BAIRCOB', 'M0_CIDCOB', 'M0_ESTCOB', 'M0_TEL' }

	self:aStruct := getStrutObj(self:aFields, aCpos)

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
@Description Retorna los datos del objeto de negócio 
@param oFilter, objeto, contiene el filtro del TReports
@return object: self:oData
@author Leonardo Pereira
@since 18/07/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getData( nPage as numeric, oFilter as object ) as object class OrdenesPagoTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery as character
	Local cAliasA := GetNextAlias() as character
	Local cAliasB := GetNextAlias() as character
	Local cOrdePago as character
	Local cDescMon as character

	Local nCount as numeric
	Local nX as numeric
	Local nMVPAR07 as numeric
	Local nQtMoedas as numeric
	Local nPosMon as numeric
	Local nSeq as numeric

	Local jParams as json
	Local jItems as json

	Local aPDFields as array
	Local aNomeMoed as array

	Local lObfuscated as logical
	Local lOrdePago as logical

	Local oQueryA as object
	Local oQueryB as object

	nQtMoedas := Moedfin()
	aNomeMoed := { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )
	lOrdePago := .T.

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	nMVPAR07 := IIf( ValType( jParams['MV_PAR07'][1] ) == 'C', Val( jParams['MV_PAR07'][1] ), jParams['MV_PAR07'][1] )

	// Lista as moedas e suas descrições
	For nX := 1 To nQtMoedas
		aAdd( aNomeMoed, { AllTrim( Str( nX ) ), SuperGetMv( 'MV_MOEDA' + AllTrim( Str( nX ) ) ) } )
	Next

	nCount := 0

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQuery := "SELECT SEK.EK_FORNEPG, SEK.EK_LOJAPG, SEK.EK_ORDPAGO, SEK.EK_TIPODOC, SEK.EK_TIPO, SEK.EK_PREFIXO, SEK.EK_NUM, SEK.EK_PARCELA, SEK.EK_EMISSAO, SEK.EK_VENCTO, SEK.EK_MOEDA, SEK.EK_BANCO, SEK.EK_AGENCIA, SEK.EK_CONTA, SEK.EK_VALOR, SEK.EK_VALORIG, SEK.EK_SALDO, SEK.EK_VLMOED1, SEK.EK_DESCONT, SEK.EK_JUROS, SEK.EK_NATUREZ, SA2.A2_NOME, SA2.A2_END, SA2.A2_MUN, SA2.A2_EST, SA2.A2_CGC, SA2.A2_EMAIL, SA2.A2_TEL, '' EK_DESMOE, '' EK_DESTIPO, CASE WHEN EK_TIPODOC IN('NF','TB') THEN '01' WHEN EK_TIPODOC IN('CP','CT','PA','DE') THEN '02' END EK_IDGRUPO, "
	cQuery += " SM0.M0_NOMECOM, SM0.M0_ENDCOB, SM0.M0_COMPCOB, SM0.M0_BAIRCOB, SM0.M0_CIDCOB, SM0.M0_ESTCOB, SM0.M0_TEL"
	cQuery += "FROM " + RetSqlName("SA2") + " SA2 "
	cQuery += "INNER JOIN " + RetSqlName("SEK") + " SEK "
	cQuery += "   ON SEK.EK_FILIAL = ? "
	cQuery += "      AND SEK.EK_ORDPAGO BETWEEN ? AND ? "
	cQuery += "      AND SEK.EK_FORNEPG BETWEEN ? AND ? "
	cQuery += "      AND SEK.EK_TIPODOC IN( ? ) "
	cQuery += "      AND SEK.EK_FORNEPG = SA2.A2_COD "
	cQuery += "      AND SEK.EK_LOJA = SA2.A2_LOJA "
	cQuery += "      AND SEK.EK_EMISSAO BETWEEN ? AND ? "
	cQuery += "      AND SEK.EK_CANCEL = ? "
	If !Empty( nMVPAR07 ) .And. ( nMVPAR07 <> 0 )
		cQuery += "   AND SEK.EK_MOEDA = ? "
	EndIf
	cQuery += "      AND SEK.D_E_L_E_T_ = ? "
	cQuery += "INNER JOIN SYS_COMPANY SM0 ON SM0.M0_CODIGO = ? AND SM0.M0_CODFIL = ? AND SM0.D_E_L_E_T_ = ?"
	cQuery += "WHERE SA2.A2_FILIAL = ? "
	cQuery +=    "AND SA2.D_E_L_E_T_ = ? "

	// Agrega os filtroa na QUERY
	If oFilter:hasFilter()
		cQuery += "   AND " + oFilter:getSQLExpression( ) + " "
	EndIf

	cQuery += "ORDER BY ? "

	cQuery := ChangeQuery( cQuery )

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	oQueryA := FwExecStatement():New()

	//Define a consulta e os parâmetros
	oQueryA:SetQuery( cQuery )

	oQueryA:SetString( 1, FwxFilial( 'SEK' ) )
	oQueryA:SetString( 2, jParams['MV_PAR03'][1] )
	oQueryA:SetString( 3, jParams['MV_PAR04'][1] )
	oQueryA:SetString( 4, jParams['MV_PAR01'][1] )
	oQueryA:SetString( 5, jParams['MV_PAR02'][1] )
	oQueryA:SetIn( 6, { 'TB', 'CP', 'CT', 'PA', 'DE' } )
	oQueryA:SetString( 7, DtoS( FwDateTimeToLocal( jParams['MV_PAR05'][1] )[1] ) )
	oQueryA:SetString( 8, DtoS( FwDateTimeToLocal( jParams['MV_PAR06'][1] )[1] ) )
	oQueryA:SetString( 9, 'F' )

	nSeq := 9
	If !Empty( nMVPAR07 ) .And. ( nMVPAR07 <> 0 )
		oQueryA:SetNumeric( ( nSeq += 1 ), nMVPAR07 )
	Endif
	oQueryA:SetString( ( nSeq += 1 ), ' ' )

	oQueryA:SetString( ( nSeq += 1 ), cEmpAnt )
	oQueryA:SetString( ( nSeq += 1 ), cFilAnt )
	oQueryA:SetString( ( nSeq += 1 ), ' ' )

	oQueryA:SetString( ( nSeq += 1 ), FwxFilial( 'SA2' ) )
	oQueryA:SetString( ( nSeq += 1 ), ' ' )
	oQueryA:SetUnsafe( ( nSeq += 1 ), 'SEK.EK_FILIAL, SEK.EK_ORDPAGO, SEK.EK_TIPODOC' )

	cQuery := oQueryA:getFixQuery( )

	// cria alias
	oQueryA:OpenAlias( cAliasA )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( cAliasA )->( EOF( ) )
		jItems := JsonObject():new()
		cOrdePago := ( cAliasA )->EK_ORDPAGO

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf ( self:aStruct[nX][3] == 'date' )
				jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
			Else
				If ( self:aStruct[nx][5] == 'EK_DESMOE' )
					// Moneda
					nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == ( cAliasA )->EK_MOEDA } )
					cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
					jItems[self:aStruct[nX][1]] := cDescMon
				Else
					jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
				EndIf
			EndIf
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		self:oData:appendData( jItems )

		If lOrdePago
			nSQl := 0

			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery := "SELECT DISTINCT SFE.FE_FORNECE EK_FORNEPG, SFE.FE_LOJA EK_LOJAPG, SFE.FE_ORDPAGO EK_ORDPAGO, 'RET' EK_TIPODOC, SFE.FE_TIPO EK_TIPO, SFE.FE_SERIE EK_PREFIXO, SFE.FE_NFISCAL EK_NUM, SFE.FE_PARCELA EK_PARCELA, SFE.FE_EMISSAO EK_EMISSAO, SFE.FE_EMISSAO EK_VENCTO, '' EK_MOEDA, '' EK_BANCO, '' EK_AGENCIA, '' EK_CONTA, SFE.FE_RETENC EK_VALOR, SFE.FE_RETENC EK_VALORIG, SFE.FE_RETENC EK_SALDO, SFE.FE_RETENC EK_VLMOED1, 0 EK_DESCONT, 0 EK_JUROS, '' EK_NATUREZ , SA2.A2_NOME, SA2.A2_END, SA2.A2_MUN, SA2.A2_EST, SA2.A2_CGC, SA2.A2_EMAIL, SA2.A2_TEL, '' EK_DESCMOE, '' EK_DESTIPO, '03' EK_IDGRUPO,"
			cQuery += " SM0.M0_NOMECOM, SM0.M0_ENDCOB, SM0.M0_COMPCOB, SM0.M0_BAIRCOB, SM0.M0_CIDCOB, SM0.M0_ESTCOB, SM0.M0_TEL"
			cQuery += 'FROM ' + RetSQLName( 'SFE' ) + ' SFE '
			cQuery += 'INNER JOIN ' + RetSQLName( 'SA2' ) + ' SA2 '
			cQuery += '   ON SA2.A2_FILIAL = ? '
			cQuery += '      AND SA2.A2_COD = SFE.FE_FORNECE '
			cQuery += '      AND SA2.A2_LOJA = SFE.FE_LOJA '
			cQuery += '      AND SA2.D_E_L_E_T_ = ? '
			cQuery += 'INNER JOIN ' + RetSQLName( 'SEK' ) + ' SEK '
			cQuery += '   ON SEK.EK_FILIAL = ? '
			cQuery += '      AND SEK.EK_ORDPAGO = SFE.FE_ORDPAGO '
			cQuery += '      AND SEK.D_E_L_E_T_ = ? '
			cQuery += "INNER JOIN SYS_COMPANY SM0 ON SM0.M0_CODIGO = ? AND SM0.M0_CODFIL = ? AND SM0.D_E_L_E_T_ = ?"
			cQuery += "WHERE SFE.FE_ORDPAGO = ? "
			cQuery += "   AND SFE.FE_RETENC > ? "
			cQuery += "   AND SFE.D_E_L_E_T_ = ? "

			cQuery := ChangeQuery( cQuery )

			// Executa a QUERY e cria uma tabela temporaria com os dados retornados
			oQueryB := FwExecStatement():New()

			//Define a consulta e os parâmetros
			oQueryB:SetQuery( cQuery )

			oQueryB:SetString( 1, FwxFilial( 'SA2' ) )
			oQueryB:SetString( 2, ' ' )
			oQueryB:SetString( 3, FwxFilial( 'SEK' ) )
			oQueryB:SetString( 4, ' ' )
			oQueryB:SetString( 5, cEmpAnt )
			oQueryB:SetString( 6, cFilAnt )
			oQueryB:SetString( 7, ' ' )
			oQueryB:SetString( 8, ( cAliasA )->EK_ORDPAGO )
			oQueryB:SetNumeric( 9, 0 )
			oQueryB:SetString( 10, ' ' )

			cQuery := oQueryB:getFixQuery( )

			// Monta tabela com a query
			oQueryB:OpenAlias(cAliasB)

			// Alimenta o objeto de dados da classe para retornar ao SmartView
			While !( cAliasB )->( EOF( ) )
				jItems := JsonObject():new()

				For nX := 1 To Len( self:aStruct )
					If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
					ElseIf ( self:aStruct[nX][3] == 'date' )
						jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
					Else
						If ( self:aStruct[nx][5] == 'EK_MOEDA' )
							jItems[self:aStruct[nX][1]] := ( cAliasA )->EK_MOEDA
						ElseIf ( self:aStruct[nx][5] == 'EK_DESTIPO' )
							jItems[self:aStruct[nX][1]] := GetDescRet( AllTrim( ( cAliasB )->EK_TIPO ) )
						ElseIf ( self:aStruct[nx][5] == 'EK_DESMOE' )
							// Moneda
							nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == ( cAliasA )->EK_MOEDA } )
							cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
							jItems[self:aStruct[nX][1]] := cDescMon
						Else
							jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
						EndIf
					EndIf
				Next

				// Inclui os dados no objeto paea retorno ao SmartView
				self:oData:appendData( jItems )

				( cAliasB )->( DbSkip( ) )
				nCount++
			End
			( cAliasB )->( DbCloseArea( ) )
		EndIf

		( cAliasA )->( DbSkip( ) )
		nCount++

		If ( cOrdePago == ( cAliasA )->EK_ORDPAGO )
			lOrdePago := .F.
		Else
			cOrdePago := ( cAliasA )->EK_ORDPAGO
			lOrdePago := .T.
		EndIf
	End

	// fecha objeto
	If oQueryA <> Nil
		oQueryA:Destroy()
		oQueryA := NIL
		FwFreeObj(oQueryA)
	EndIf
	If oQueryB <> Nil
		oQueryB:Destroy()
		oQueryB := NIL
		FwFreeObj(oQueryB)
	EndIf

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
@description Retorna la estructura de los campos
@return object: self:oSchema
@author Leonardo Pereira
@since 18/07/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getSchema() as object class OrdenesPagoTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTView
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )

//-------------------------------------------------------------------
/*{Protheus.doc} GetDescRet
Obtiene la descripción para las Retenciones
@param cTipo Caracter: Tipo de Retención
@Return Caracter: Descripción de la Retención
@author Leonardo Pereira
@since 14/04/2023
@version 1.0
*/
//-------------------------------------------------------------------
Static Function GetDescRet( cTipo )

	Local cRet := ''
	// "RETENCIÓN DE " // "GANANCIAS"
	cRet := IIF( cPaisLoc == 'ARG',STR0014 + IIf( ( cTipo == 'G' ), OemToAnsi( STR0015 ), IIf( ( cTipo == 'B' ), OemToAnsi( "ING. BR." ), IIf( ( cTipo == 'S' ), OemToAnsi( "S.U.S.S." ), OemToAnsi( "I.V.A." ) ) ) ) ,IIF ( cPaisLoc $ 'URU|BOL' ,cRet := OemToAnsi( "I.R.I.C." ),IIf ( cPaisLoc == 'PER' .AND. cTipo == 'I', cRet := OemToAnsi( "I.G.V." ), "")))

Return( cRet )

