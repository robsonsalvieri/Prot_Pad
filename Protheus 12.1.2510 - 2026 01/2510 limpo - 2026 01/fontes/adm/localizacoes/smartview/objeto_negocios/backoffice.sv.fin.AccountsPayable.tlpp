#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fin.accountspayable.ch'

namespace custom.financeiro.accountspayable.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} accountspayableTReportsBusinessObject
@description Classe para creación del Objeto de Negocio de Cuentas por Pagar para TReports
@author Leonardo Pereira
@since 11/07/2023
@version 1.1
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFIN', tables='SA2,SE2,SEK', name='Cuentas por Pagar', country='ALL', initialRelease='12.1.2310', customTables='SA2,SE2' )
class accountspayableTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe 
@Return object: self
@author Leonardo Pereira
@since 11/07/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method new() class accountspayableTReportsBusinessObject

	Local aCpos := {} as array

	_Super:new()

	//Define o nome do Objeto de Negócio
   self:setDisplayName( STR0001 ) /*/ 'Cuentas por Pagar' /*/

	//Define a descrição do Objeto de Negócio
   self:setDescription( STR0002 ) /*/ 'Detalle de Cuentas por Pagar'/*/

	// Define a Área
	self:appendArea( STR0003 ) /*'Financeiro'*/

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'FINSV15H' ) // Indica o pergunte que será utilizado
		IIf(!self:setErrorStatus( 400, STR0004, STR0005 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0006,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0007,,, ) /*'Grupo de preguntas no encontrado!'*/
	EndIf

	// Adiciona os campos virtuais/calculados
	aAdd( aCpos, { 'E2_DESCMON' , STR0008, 'string', STR0008 } ) /*'Descripción de la moneda'*/
	aAdd( aCpos, { 'E2_TAXADIA' , STR0009, 'number', STR0009 } ) /*'Tasa del Día'*/
	aAdd( aCpos, { 'E2_TITVENC' , STR0010, 'number', STR0010 } ) /*'Títulos Vencidos'*/
	aAdd( aCpos, { 'E2_TITAVEN' , STR0011, 'number', STR0011 } ) /*'Títulos a Vencer'*/
	aAdd( aCpos, { 'E2_TOTCON1' , STR0012, 'number', STR0012 } ) /*'Saldo Conv. Moneda 1'*/
	aAdd( aCpos, { 'E2_TOTCON2' , STR0013, 'number', STR0013 } ) /*'Saldo Conv. Tx. Dia'*/
	aAdd( aCpos, { 'E2_ATRASO'  , STR0014, 'string', STR0014 } ) /*'Días Atraso'*/
	aAdd( aCpos, { 'E2_VLRDEB'  , STR0015, 'number', STR0015 } ) /*'Debitos'*/
	aAdd( aCpos, { 'E2_VLRCRE'  , STR0016, 'number', STR0016 } ) /*'Creditos'*/
	aAdd( aCpos, { 'E2_XTXMOEDA', STR0017, 'number', STR0017 } ) /*'Tasa del titulo'*/


	self:aFields := { 'E2_FILIAL', 'E2_FORNECE', 'E2_LOJA', 'A2_NOME', 'E2_ORDPAGO', 'E2_PREFIXO', 'E2_NUM', 'E2_PARCELA', 'E2_TIPO', 'E2_NATUREZ', 'E2_EMISSAO', 'E2_EMIS1', 'E2_VENCTO', 'E2_VENCREA', 'E2_BAIXA', 'E2_VALOR', 'E2_SALDO', 'E2_CCUSTO', 'E2_MOEDA', 'E2_DESCMON', 'E2_XTXMOEDA', 'E2_TAXADIA', 'E2_VLRDEB', 'E2_VLRCRE', 'E2_TOTCON1', 'E2_TOTCON2', 'E2_TITVENC', 'E2_TITAVEN', 'E2_SITUACA', 'E2_BCOCHQ', 'E2_AGECHQ', 'E2_CTACHQ', 'E2_JUROS', 'E2_PORTADO', 'E2_ORIGEM', 'E2_ATRASO' ,'E2_TXMOEDA'}

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio
@param oFilter, objeto, contiene el filtro del TReports
@return object: self:oData
@author Leonardo Pereira
@since 11/07/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object ) as object class accountspayableTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery		as character
	Local cAliasA		as character
	Local cAliasB		as character
	Local cDescMon		as character
	Local cFiltro 		as character
	Local cExp 			as character
	Local cCpoSA2 		as character
	Local cCpoSE2 		as character
	Local cCpoSEK 		as character
	Local cMVJURTIPO	as character

	Local nCount		as numeric
	Local nX			as numeric
	Local n1			as numeric
	Local nPosMon		as numeric
	Local nPosExp		as numeric
	Local nDecs 		as numeric
	Local nTxMoeConv 	as numeric
	Local nMoeda		as numeric
	Local nTOTCon1		as numeric
	Local nQtdMoeda  	as numeric
	Local nMVPAR11		as numeric
	Local nJuros		as numeric
	Local nMVFINJRTP  as numeric
	Local nToler      as numeric
	Local nSQL      	as numeric

	Local jItems		as json
	Local jParams 		as json

	Local aPDFields	as array
	Local aNomeMoed	as array
	Local aFiltro		as array
	Local aCustomFields 	as array

	Local lObfuscated	as logical
	Local lAutomato     as logical

	Local oExecA		as object
	Local oExecB		as object

	cDescMon			:= ''
	cFiltro 			:= ''
	cExp 				:= ''
	cAliasA			:= ''
	cAliasB			:= ''
	cCpoSA2 			:= ''
	cCpoSE2 			:= ''
	cCpoSEK 			:= ''
	lAutomato      := IsBlind()
	cMVJURTIPO     := AllTrim( IIf(lAutomato,GetMv( 'MV_JURTIPO' ),SuperGetMv( 'MV_JURTIPO',, 'M' )) )

	nPosMon   		:= 0
	nPosExp 			:= 0
	nDecs 			:= 0
	nTxMoeConv 		:= 1
	nMoeda			:= 1
	nTOTCon1			:= 0
	nX 				:= 0
	n1					:= 0
	nJuros			:= 0
	nQtdMoeda 		:= Moedfin( )
	nMVFINJRTP     := IIf(lAutomato,GetMv('MV_FINJRTP'),SuperGetMv('MV_FINJRTP',, 1 ))
	nToler         := IIf(lAutomato,GetMv('MV_TOLER'),SuperGetMv( 'MV_TOLER',, 0 ))
	nSQL				:= 1

	aNomeMoed 		:= { }
	aPDFields		:= { }
	aFiltro			:= { }
	aCustomFields	:= { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	// Coleta os campos personalizados pra agregar na query
	cCpoSA2 := getCpoUser( aCustomFields, 'SA2', 'A2', ',' )
	cCpoSE2 := getCpoUser( aCustomFields, 'SE2', 'E2', ',' )
	cCpoSEK := getCpoUser( aCustomFields, 'SEK', 'EK', ',' )

	nMVPAR11 := IIf( ( ValType( jParams['MV_PAR11'][1] ) == 'C' ), Val( jParams['MV_PAR11'][1] ), jParams['MV_PAR11'][1] )

	If oFilter:hasFilter( )
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )

		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )

		// Define os dados para conversão de moedas
		nPosExp := aScan( aFiltro, { | x | AllTrim( x[1] ) == 'E2_ORIGEM' } )
		If ( nPosExp > 0 )
			cExp := aFiltro[nPosExp, 3]

			// Exclui o elemento do Array
			aDel( aFiltro, nPosExp )

			// Redimensiona o Array
			aSize( aFiltro, ( Len( aFiltro ) - 1 ) )
		EndIf
	EndIf

	// Lista as moedas e suas descrições
	For nX := 1 To nQtdMoeda
		aAdd( aNomeMoed, { AllTrim( Str( nX ) ), SuperGetMv( 'MV_MOEDA' + AllTrim( Str( nX ) ) ) } )
	Next

	// Pesquisa a taxa do dia
	If ( nMVPAR11 > 1 )
		DbSelectArea( 'SM2' )
		SM2->( DbSetOrder( 1 ) )
		If SM2->( DbSeek( DtoS( dDataBase ) ) ) // M2_DATA
			nTxMoeConv := SM2->&( ( 'M2_MOEDA' + StrZero( nMVPAR11, 1 ) ) )
		EndIf
	Endif

	nCount := 0

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQuery := "SELECT SA2.A2_COD, SA2.A2_LOJA, ? SA2.A2_NOME "
	cQuery += "FROM " + RetSQLName( "SA2" ) + " SA2 "
	cQuery += "WHERE SA2.A2_FILIAL = ? "
	cQuery += "   AND SA2.A2_COD BETWEEN ? AND ? "
	cQuery += "   AND SA2.A2_LOJA BETWEEN ? AND ? "
	cQuery += "   AND SA2.D_E_L_E_T_= ? "
	cQuery += "ORDER BY ? "

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	cQuery := ChangeQuery( cQuery )

	oExecA := FwExecStatement():New( cQuery )

	oExecA:SetUnSafe( 1, cCpoSA2 )
	oExecA:SetString( 2, xFilial( 'SA2' ) )
	oExecA:SetString( 3, jParams['MV_PAR01'][1] )
	oExecA:SetString( 4, jParams['MV_PAR02'][1] )
	oExecA:SetString( 5, jParams['MV_PAR03'][1] )
	oExecA:SetString( 6, jParams['MV_PAR04'][1] )
	oExecA:SetString( 7, ' ' )
	oExecA:SetUnsafe( 8, 'SA2.A2_COD,SA2.A2_LOJA' )

	cQuery := oExecA:getFixQuery( )

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	cAliasA := oExecA:OpenAlias( )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( cAliasA )->( EOF( ) )
		// Realiza a montagem da QUERY que será enviada para o banco de dados
		cQuery := "SELECT SE2.E2_FILIAL, SE2.E2_ORDPAGO, SE2.E2_PREFIXO, SE2.E2_NUM, SE2.E2_PARCELA, SE2.E2_TIPO, '' E2_TIPODOC, SE2.E2_EMISSAO, SE2.E2_EMIS1, SE2.E2_VENCTO, SE2.E2_VENCREA, SE2.E2_BAIXA, SE2.E2_VALOR, SE2.E2_SALDO, SE2.E2_CCUSTO, SE2.E2_NATUREZ, SE2.E2_MOEDA, SE2.E2_TXMOEDA E2_XTXMOEDA, SE2.E2_SITUACA, SE2.E2_BCOCHQ, SE2.E2_AGECHQ, SE2.E2_CTACHQ, SE2.E2_JUROS, SE2.E2_PORTADO, SE2.E2_VALJUR, SE2.E2_PORCJUR, ? SE2.E2_ORIGEM, SE2.E2_TXMOEDA "
		cQuery += "FROM " + RetSQLName( "SE2" ) + " SE2 "
		cQuery += "WHERE SE2.E2_FORNECE = ? "
		cQuery += "   AND SE2.E2_LOJA = ? "
		cQuery += "   AND SE2.E2_NATUREZ BETWEEN ? AND ? "
		cQuery += "   AND SE2.E2_EMISSAO BETWEEN ? AND ? "
		cQuery += "   AND SE2.E2_VENCTO BETWEEN ? AND ? "
		If ( cExp == "'SV01VIS'" )
			cQuery += "   AND SE2.E2_SALDO > ? "
			cQuery += "   AND SE2.E2_TIPO NOT IN(?) "
			cQuery += "   AND SE2.D_E_L_E_T_= ? "
		ElseIf ( cExp == "'SV02VIS'" )
			cQuery += "   AND SE2.E2_TIPO NOT IN(?) "
			cQuery += "   AND SE2.D_E_L_E_T_= ? "
		ElseIf ( cExp == "'SV03VIS'" )
			cQuery += "   AND SE2.E2_SALDO > ? "
			cQuery += "   AND SE2.E2_TIPO IN(?) "
			cQuery += "   AND SE2.D_E_L_E_T_= ? "
		ElseIf ( cExp == "'SV04VIS'" ) .Or. Empty(cExp)
			cQuery += "   AND SE2.D_E_L_E_T_= ? "
		EndIf

		If ( cExp == "'SV02VIS'" )
			// Realiza a montagem da QUERY que será enviada para o banco de dados
			cQuery += "UNION "

			cQuery += "SELECT SEK.EK_FILIAL E2_FILIAL, SEK.EK_ORDPAGO E2_ORDPAGO, SEK.EK_PREFIXO E2_PREFIXO, SEK.EK_NUM E2_NUM, SEK.EK_PARCELA E2_PARCELA, SEK.EK_TIPO E2_TIPO, 'OP' E2_TIPODOC, SEK.EK_EMISSAO E2_EMISSAO, SEK.EK_DTDIGIT E2_EMIS1, SEK.EK_VENCTO E2_VENCTO, SEK.EK_VENCTO E2_VENCREA, SEK.EK_VENCTO E2_BAIXA, SEK.EK_VALOR E2_VALOR, SEK.EK_SALDO E2_SALDO, '' E2_CCUSTO, SEK.EK_NATUREZ E2_NATUREZ, CAST(SEK.EK_MOEDA AS INT) E2_MOEDA, 0 E2_XTXMOEDA, '' E2_SITUACA, SEK.EK_BANCO E2_BCOCHQ, SEK.EK_AGENCIA E2_AGECHQ, SEK.EK_CONTA E2_CTACHQ, SEK.EK_JUROS E2_JUROS, SEK.EK_BANCO E2_PORTADO, 0 E2_VALJUR, 0 E2_PORCJUR, ' ' E2_ORIGEM, 0 E2_TXMOEDA "
			cQuery += " FROM " + RetSQLName( 'SEK' ) + " SEK "
			cQuery += " WHERE SEK.EK_SALDO > ? "
			cQuery += "   AND SEK.EK_FORNECE = ? "
			cQuery += "   AND SEK.EK_LOJA = ? "
			cQuery += "   AND (SEK.EK_TIPODOC = ? OR SEK.EK_TIPODOC = ?) "
			cQuery += "   AND SEK.EK_NATUREZ BETWEEN ? AND ? "
			cQuery += "   AND SEK.EK_DTDIGIT BETWEEN ? AND ? "
			cQuery += "   AND SEK.EK_CANCEL = ? "
			cQuery += "   AND SEK.D_E_L_E_T_ = ? "
		EndIf

		// Agrega os filtros na QUERY
		For nX := 1 To Len( aFiltro )
			cQuery += " AND ? " + ' ' + " ? ? "
		Next

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		cQuery := ChangeQuery( cQuery )

		oExecB := FwExecStatement():New( cQuery )

		nSeq := 0
		oExecB:SetUnSafe( nSeq += 1, cCpoSE2 )
		oExecB:SetString( nSeq += 1, ( cAliasA )->A2_COD )
		oExecB:SetString( nSeq += 1, ( cAliasA )->A2_LOJA )
		oExecB:SetString( nSeq += 1, jParams['MV_PAR05'][1] )
		oExecB:SetString( nSeq += 1, jParams['MV_PAR06'][1] )
		oExecB:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR07'][1] )[1] ) )
		oExecB:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR08'][1] )[1] ) )
		oExecB:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR09'][1] )[1] ) )
		oExecB:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR10'][1] )[1] ) )


		If ( cExp == "'SV01VIS'" )
			oExecB:SetNumeric( nSeq += 1, 0 )
			oExecB:SetIn( nSeq += 1, { 'TF', 'CH' } )
			oExecB:SetString( nSeq += 1, ' ' )
		ElseIf ( cExp == "'SV02VIS'" )
			oExecB:SetIn( nSeq += 1, { 'TF', 'CH', 'PA' } )
			oExecB:SetString( nSeq += 1, ' ' )
			oExecB:SetNumeric( nSeq += 1, 0 )
			oExecB:SetString( nSeq += 1, ( cAliasA )->A2_COD )
			oExecB:SetString( nSeq += 1, ( cAliasA )->A2_LOJA )
			oExecB:SetString( nSeq += 1, 'TB' )
			oExecB:SetString( nSeq += 1, 'PA' )
			oExecB:SetString( nSeq += 1, jParams['MV_PAR05'][1] )
			oExecB:SetString( nSeq += 1, jParams['MV_PAR06'][1] )
			oExecB:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR07'][1] )[1] ) )
			oExecB:SetString( nSeq += 1, DtoS( FwDateTimeToLocal( jParams['MV_PAR08'][1] )[1] ) )
			oExecB:SetString( nSeq += 1, 'F' )
			oExecB:SetString( nSeq += 1, ' ' )
		ElseIf ( cExp == "'SV03VIS'" )
			oExecB:SetNumeric( nSeq += 1, 0 )
			oExecB:SetIn( nSeq += 1, { 'TF', 'CH' } )
			oExecB:SetString( nSeq += 1, ' ' )

		ElseIf ( cExp == "'SV04VIS'" ) .Or. Empty(cExp)
			oExecB:SetString( nSeq += 1, ' ' )
		EndIf

		For nX := 1 To Len( aFiltro )
			oExecB:SetUnSafe ( nSeq += 1, aFiltro[nX, 1] )
			oExecB:SetUnSafe ( nSeq += 1, aFiltro[nX, 2] )
			oExecB:SetUnSafe ( nSeq += 1, aFiltro[nX, 3] )
		Next

		cQuery := oExecB:getFixQuery( )

		// Executa a QUERY e cria uma tabela temporaria com os dados retornados
		cAliasB := oExecB:OpenAlias( )

		// Alimenta o objeto de dados da classe para retornar ao SmartView
		While !( cAliasB )->( EOF( ) )
			jItems := JsonObject():new( )

			// Calculo de Juros e Multas
			nJuros := 0
			If ( dDataBase > StoD( ( cAliasB )->E2_VENCREA ) )
				nJuros := svJuros( ( cAliasB )->E2_VALOR, ( cAliasB )->E2_SALDO, StoD( ( cAliasB )->E2_VENCTO ), ( cAliasB )->E2_VALJUR, ( cAliasB )->E2_PORCJUR, ( cAliasB )->E2_MOEDA, StoD( ( cAliasB )->E2_EMISSAO ), dDataBase, ( cAliasB )->E2_XTXMOEDA, StoD( ( cAliasB )->E2_BAIXA ), StoD( ( cAliasB )->E2_VENCREA ), ( cAliasB )->E2_TIPO, cMVJURTIPO, nMVFINJRTP, nToler )
			EndIf

			// popula os campos
			For nX := 1 To Len( self:aStruct )
				If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
					If "A2_" $ self:aStruct[nX][5]
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
					Else
						jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasB )->&( self:aStruct[nX][5] ) )
					Endif
				ElseIf ( self:aStruct[nX][3] == 'date' )
					jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
				Else
					If ( self:aStruct[nX][5] == 'E2_DESCMON' )
						// Descripción Moneda
						nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAliasB )->E2_MOEDA ) ) } )
						cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )
						jItems[self:aStruct[nX][1]] := cDescMon
					ElseIf ( self:aStruct[nX][5] == 'E2_FORNECE' )
						jItems[self:aStruct[nX][1]] := ( cAliasA )->A2_COD
					ElseIf ( self:aStruct[nX][5] == 'E2_LOJA' )
						jItems[self:aStruct[nX][1]] := ( cAliasA )->A2_LOJA
					ElseIf ( self:aStruct[nX][5] == 'A2_NOME' )
						jItems[self:aStruct[nX][1]] := ( cAliasA )->A2_NOME
					ElseIf ( self:aStruct[nX][5] == 'E2_TAXADIA' )
						jItems[self:aStruct[nX][1]] := nTxMoeConv
					ElseIf ( self:aStruct[nX][5] == 'E2_ATRASO' )
						jItems[self:aStruct[nX][1]] := AllTrim( Str( dDatabase - StoD( ( cAliasB )->E2_VENCTO ) ) )
					ElseIf ( self:aStruct[nX][5] == 'E2_VALOR' ) .Or. ( self:aStruct[nX][5] == 'E2_SALDO' )
						If ( AllTrim( ( cAliasB )->E2_TIPO ) $ 'PA|' + AllTrim( MV_CPNEG ) )
							jItems[self:aStruct[nX][1]] := ( ( cAliasB )->&( self:aStruct[nX][5] ) * IIf( cExp == "'SV02VIS'", 1, -1 ) )
						Else
							jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
						EndIf
					ElseIf ( self:aStruct[nX][5] == 'E2_TITVENC' )
						jItems[self:aStruct[nX][1]] := ( ( cAliasB )->E2_SALDO + nJuros )
					ElseIf ( self:aStruct[nX][5] == 'E2_TITAVEN' )
						If ( StoD( ( cAliasB )->E2_VENCREA ) >= dDataBase )
							jItems[self:aStruct[nX][1]] := ( cAliasB )->E2_SALDO
						Else
							jItems[self:aStruct[nX][1]] := 0
						EndIf
					ElseIf ( self:aStruct[nX][5] == 'E2_TOTCON1' )  // Saldo Conv. Moneda 1

						//nTOTCon1 := Round(( cAliasB )->E2_SALDO * ( cAliasB )->E2_XTXMOEDA,2)
						//nTOTCon1 := xMoeda(( cAliasB )->E2_SALDO,( cAliasB )->E2_MOEDA,1,StoD( ( cAliasB )->E2_EMISSAO ),2,1,( cAliasB )->E2_XTXMOEDA)
						nTOTCon1 := xMoeda(( cAliasB )->E2_SALDO,( cAliasB )->E2_MOEDA,nMVPAR11,StoD( ( cAliasB )->E2_EMISSAO ),5,( cAliasB )->E2_XTXMOEDA,RecMoeda(( cAliasB )->E2_EMISSAO,nMVPAR11))

			



						If ( AllTrim( ( cAliasB )->E2_TIPO ) $ 'PA|' + AllTrim( MV_CPNEG ) )
							jItems[self:aStruct[nX][1]] := ( nTOTCon1 * IIf( cExp == "'SV02VIS'", 1, -1 ) )
						Else
							jItems[self:aStruct[nX][1]] := nTOTCon1
						EndIf

					ElseIf ( self:aStruct[nX][5] == 'E2_TOTCON2' )   // Saldo Conv. Tasa del dia

						// si la moneda del documento es igual a la moneda del parametro, dejar el mismo importe del saldo del documento (no hacer conversión)
						n2TxMoeConv := nTxMoeConv
						If  ( cAliasB )->E2_MOEDA == nMVPAR11
							n2TxMoeConv := ( cAliasB )->E2_XTXMOEDA
						Endif
						nTOTCon2 := Round( nTOTCon1 / n2TxMoeConv,2)
						If ( AllTrim( ( cAliasB )->E2_TIPO ) $ 'PA|' + AllTrim( MV_CPNEG ) )
							jItems[self:aStruct[nX][1]] := ( nTOTCon2 * IIf( cExp == "'SV02VIS'", 1, -1 ) )
						Else
							jItems[self:aStruct[nX][1]] := nTOTCon2
						EndIf


					ElseIf ( self:aStruct[nX][5] == 'E2_JUROS' )
						jItems[self:aStruct[nX][1]] := nJuros
					ElseIf ( self:aStruct[nX][5] == 'E2_VLRDEB' )
						If !( AllTrim( ( cAliasB )->E2_TIPO ) $ AllTrim( MV_CPNEG ) ) .And. !( SubStr( ( cAliasB )->E2_TIPO, 3, 1 ) == '-' )
							jItems[self:aStruct[nX][1]] := ( cAliasB )->E2_VALOR
						Else
							jItems[self:aStruct[nX][1]] := 0
						EndIf
					ElseIf ( self:aStruct[nX][5] == 'E2_VLRCRE' )
						If ( AllTrim( ( cAliasB )->E2_TIPO ) $ AllTrim( MV_CPNEG ) ) .Or. ( SubStr( ( cAliasB )->E2_TIPO, 3, 1 ) == '-' )
							jItems[self:aStruct[nX][1]] := ( cAliasB )->E2_VALOR
						Else
							jItems[self:aStruct[nX][1]] := 0
						EndIf
					Else
						If ( self:aStruct[nX][1] $ cCpoSA2 )
							jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
						Else
							jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
						EndIf
					EndIf
				EndIf
			Next

			// Inclui os dados no objeto paea retorno ao SmartView
			self:oData:appendData( jItems )

			( cAliasB )->( DbSkip( ) )
			nCount++
		End
		( cAliasB )->( DbCloseArea( ) )

		oExecB:Destroy( )
		oExecB := Nil

		( cAliasA )->( DbSkip( ) )
	End

	// Se não for o último registro indica que terá próxima página
	self:setHasNext( !( cAliasA )->( EOF( ) ) )
	( cAliasA )->( DbCloseArea( ) )

	oExecA:Destroy( )
	oExecA := Nil

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
@description Retorna la estructura de los campos
@return object: self:oSchema
@author Leonardo Pereira
@since 11/07/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema() as object class accountspayableTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTView
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SVJUROS
@description Calculo dos juros.
@Author	Leonardo Pereira
@since	09/10/2023
@ Parametros
ExpN1	: Valor do Titulo
ExpN2	: Saldo do Titulo
ExpD3  	: Data de vencimento do Titulo.
ExpN4  	: Valor do Juros do Titulo
ExpN5  	: Taxa de Permanencia.
ExpN6  	: Moeda em que se encontra o Titulo
ExpD7  	: Data de Emissao.
ExpD8  	: Data de Baixa.
ExpN9  	: Taxa da moeda.
ExpD10 	: Data da Ultima Baixa.
ExpD11 	: Data do Vencimento.
ExpC12 	: Tipo do Titulo.
/*/
//-----------------------------------------------------------------------------------------------------
Static Function svJuros( nVlrTit, nSaldo, dVencto, nValJur, nPerJur, nMoeda, dEmissao, dBaixa, nTxMoeda, dUltBaixa, dVencRea, cTipo, cMVJURTIPO, nMVFINJRTP, nToler)

	Local nAtraso		:= 0
	Local nTxPer		:= 0
	Local nJuros		:= 0
	Local nAtrSimp		:= 0
	Local nSaldoC		:= 0
	Local nDiasAtraso	:= 0

	Default dUltBaixa := dVencto
	Default cTipo		:= ''
	Default nPerJur	:= 0
	Default nVlrTit	:= 0
	Default nSaldo		:= 0
	Default dVencto	:= dDataBase
	Default nValJur	:= 0
	Default nMoeda		:= 1
	Default dEmissao	:= dDataBase
	Default dBaixa		:= dDataBase
	Default nTxMoeda	:= 0
	Default dVencRea	:= dDataBase

	nAtraso := ( dBaixa - dVencto )

	nAtraso := Iif ( Dow( dVencto ) == 1 .Or. Dow( dVencto ) == 7  .And.  cMVJURTIPO != 'L'  .And.  Dow( dBaixa ) == 2 .And.  nAtraso <= 2 , 0, nAtraso)

	nAtraso	:= IIf( nAtraso < 0, 0, nAtraso )

	// Compara dias de atraso com o parametro tolerancia de atraso
	If ( nAtraso <= nToler )
		nAtraso := 0
	EndIf

	// Quando nÆo houver percentual de juros no titulo deve-se calcular pela taxa de permanencia. Quando ha percentual ou ele
	// se refere a taxa de permanencia ou ele foi informado manualmente na inclusao do titulo a receber.
	If ( nAtraso != 0 .And. ( !Empty( nValJur ) .Or. !Empty( nPerJur ) ) )
		If !Empty( nValJur ) .And. ( nMVFINJRTP == 1 )
			nJuros := ( nValJur * nAtraso )
		Else // MV_FINJRTP = 2.Juros ou 3.Ambos
			nTxPer := nPerJur

			// Calcula os juros compostos caso o parƒmetro seja "C";
				// Calcula os juros simples caso o parametro seja "S";
				// Calcula os juros mistos  caso o parametro seja "M"
			If ( cMVJURTIPO == 'M' ) .Or. ( cMVJURTIPO == 'S' )
				// Calcula os juros simples
				If ( cMVJURTIPO == 'M' )
					nAtrSimp := IIf( nAtraso > 30, 30, nAtraso )
				Else
					nAtrSimp := nAtraso
				EndIf
				nJuros := nSaldo * ( 1 + ( nAtrSimp * ( nTxPer / 100 ) ) )
				nDiasAtraso := nAtraso
				nAtraso := IIf( cMVJURTIPO == 'M', nAtraso - 30, nAtraso )
			ElseIf nMVFINJRTP == 3 .And. !Empty( nValJur )  // MV_FINJRTP = 3.Ambos
				nDiasAtraso := nAtraso
			EndIf

			If ( cMVJURTIPO == 'M' .And. nAtraso > 0 ) .Or. ( cMVJURTIPO == 'C' )
				// Calcula os juros compostos
				If ( cMVJURTIPO == 'C' )
					nSaldoC := nSaldo
				Else
					nSaldoC := nJuros
				EndIf
				nJuros := nSaldoC * ( ( 1 + ( nTxPer / 100 ) ) ** nAtraso )
			EndIf

			nJuros := ( nJuros - nSaldo )

			// MV_FINJRTP = 3.Ambos
			If ( nMVFINJRTP == 3 ) .And. !Empty( nValJur )
				nJuros := ( nJuros + ( nValJur * nDiasAtraso ) )
			EndIf
		EndIf
	EndIf

Return( nJuros )
