#INCLUDE "PROTHEUS.CH"
#INCLUDE "finxfin.ch"
#INCLUDE "FWCSS.CH"
#INCLUDE "SHELL.CH"
#INCLUDE "FWLIBVERSION.CH"

Static lMT103DRF	:= !ExistBlock("MT103DRF")
Static __lRelat	    := FwIsInCallStack( 'FINR130' ) .or. FwIsInCallStack( 'FINR150' ) .or. FwIsInCallStack( 'FINR350' )
Static lPLSTITPF	:= NIL
Static __oFlBxFK1	:= Nil
Static __oFlBxFK2	:= Nil
Static __lDicInDB	:= NIL
Static aGetFlBxSE5  := {}
Static __aTmpFils 	:= {}
Static __lTemFK6	:= NIL
Static __lPccBx     := NIL
Static __IssBx	    := NIL
Static __cProc      := ""
Static __cUltFil
Static __cUltEmp
Static __cIdDoc
Static __cChvFK7
Static __nMoeda
Static __nDecs
Static __cQryFK6P   := ""
Static __cQryFK6R   := ""
Static __oPreparB	:= NIL
Static __lCmpoFK1	:= Nil
Static __lCmpoFK2	:= Nil
Static __cQryBxP	:= ""
Static __cQryBxR	:= ""
Static __oPrepFK6	:= NIL
Static __oSomaFK6R	:= Nil
Static __oSomaFK6P	:= Nil
Static __oSldtit	:= NIL
Static __cMVFinFix  := NIL
Static _cQryAbtRV	:= ""	//Query E1_VALOR
Static _cQryAbtRS	:= ""	//Query E1_SALDO
Static _aBindAbtR	As Array
Static nOrdTitPai   := 28
Static __cRelease	:= Nil
Static __lTCGQry2	:= Nil
Static __cMVDESCFIN	:= Nil
Static __cMVDTDESCF	:= Nil
Static __lTemFKD	:= NIL
Static __lRpoR33	:= NIL
Static __aSEVstru	:= Nil
Static __aSEZstru	:= Nil
Static __lIncNat	:= .F.
Static __lMsblql 	:= Nil

//--- revisão performance UNIFIQUE
Static __lM040Se1	:= NIL
Static __lM040CSSR	:= NIL
Static __lF040MIRF	:= NIL
Static __lF040GER	:= NIL
Static __lF040IRF 	:= NIL
Static __lF040INS 	:= NIL
Static __lF040COF 	:= NIL
Static __lF040PIS 	:= NIL
Static __lF040CSL 	:= NIL
Static __lF040MISS 	:= NIL
Static __lFVldIns	:= NIL
Static __lNTFUNR 	:= NIL
Static __nTamFor	:= NIL
Static __nTamLoja	:= NIL
Static __nTamParc	:= NIL
Static __nTamNat	:= NIL
Static __nMinRetIR	:= NIL
Static __lRMClass	:= NIL
Static __lLjAtuSa	:= NIL
Static __cCliPad    := NIL
Static __cLojaPad   := NIL
Static __lVcAntIss	:= NIL
Static __nMinISS	:= NIL
Static __cModRIss	:= NIL
Static __lVRetIrf	:= NIL
Static __lPccBxCr	:= NIL
Static __lIrPjBxCr	:= NIL
Static __lIRMP232 	:= NIL
Static __nVlInsRet 	:= NIL
Static __lTrfIssF 	:= NIL
Static __nVlMinImp	:= NIL
Static __nDiaUtIss	:= NIL
Static __nDiaIss 	:= NIL
Static __cVencIss 	:= NIL
Static __lFINCTAL	:= NIL
Static __nVRetCOF	:= NIL
Static __nVRetPIS 	:= NIL
Static __nVRetCSLL	:= NIL
Static __lECCia		:= NIL
Static __lIssMunic	:= NIL
Static __lCodRtPCC	:= NIL
Static __nVencto	:= NIL
Static __cCSSNAT	:= NIL
Static __cCSLNAT	:= NIL
Static __cPISNAT	:= NIL
Static __CCOFNAT	:= NIL
Static __lAgFETHA	:= NIL
Static __lLocBRA	:= NIL
Static __lMoedTit	:= NIL
Static __nMCusto 	:= NIL
Static __lCposIMA	:= NIL
Static __lA1RECFMD	:= NIL
Static __lCalcFMP	:= NIL
Static lFumipeq		:= NIL
Static __lFina986 	:= NIL
Static __nTamFJV	:= NIL
Static __cTipAbat   := Nil
Static __lRskActv   := Nil	// MAIS NEGÓCIOS ATIVO NO AMBIENTE = .T.
Static __cRskCPay   := Nil	// CONTEÚDO DO PARÂMETRO MV_RSKCPAY
Static __cRskFPay   := Nil  // CONTEÚDO DO PARÂMETRO MV_RSKFPAY
Static __oRetFil    := Nil
Static __aMatTbl   As Array
Static __lBuscFK7  As Logical
Static __lDicSimpl As Logical
Static __lCachQry  As Logical
Static __lBillRel  As Logical
Static __oBillRel  As JSon
//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINXFIN

Funções genéricas do módulo financeiro

@Author Vários
@version 12
@since   09/12/2014

/*/
//-----------------------------------------------------------------------------------------------------
//FINXFUN
#DEFINE DECIMALDECALCULO 12
//FINXFUN
Static aMoedaFin  // Array contendo as descricoes das moedas
Static lF070DES		:= NIL
Static lF070DSCF	:= NIL
Static lDiaDesc		:= NIL
Static __lPFin002	:= NIL
Static lNatSA 		:= NIL
Static nTamBco 		:= 0
Static nTamAge 		:= 0
Static nTamCta 		:= 0
Static nTamChq 		:= 0
Static nTamCPo 		:= 0
//Melhoria Performance CHG
Static lSPBInUse	:= NIL
Static lFADTMOV		:= NIL
Static dDataFin		:= NIL
Static nTamSeq		:= NIL
Static oPrepared	:= NIL
Static __oTXSeek 	:= Nil		// utilizado como Statement
//FINXATU
Static lF040ADLE
Static lFinaleg
Static lF040URET
Static __lFaLegPares
//MATXFUNB
Static __aLayCNAB	:= {}
Static __lPFin001	:= NIL
//MATXATU
Static lTravaSA1	:= ExistBlock("F040TRVSA1")
Static dLastPcc		:= CTOD("22/06/2015")
Static lIsIssBx		:= FindFunction("IsIssBx")
Static lF420ICNB 	:= ExistBlock("F420ICNB")
Static __cBD		As Character // Define banco de dados para procedure SomaAbat utilizar sintaxe correta ("||" ou "+")
Static lFamad 		:= Nil
Static __lAtuSlBco	:= ExistBlock("ATUSLBCO")
//Motor de Retenções
Static __lMotRet    := ExistFunc("FTemMotor") .And. FTemMotor()
Static __cRuPrf 	:= '' // used for filters  FINXFIN02_FILFilter(),  Function FINXFIN01_BCOFilter()

Static aAdianta		:= NIL
Static bFilFIE		:= NIL
Static lAdComPart	:= NIL
Static __cSGBD      := Nil
Static __cQrySE8    := Nil
Static __lGesplan 	:= Nil
Static oJsonStamp	:= Nil

/*
----------------------------------------------------------------------------
	            Funcoes retiradas do arquivo FINXATU.PRX
----------------------------------------------------------------------------
*/

//-------------------------------------------------------------------
/*/{Protheus.doc} FaGetCodFJV
obtém o código para chave única da tabela FJV
Arquivo original: FINXATU.PRX

@author pequim
@since 09/09/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Function FaGetCodFJV()
Local cCodFJV	 := ""
Local aArea		 := GetArea()
Local cTab		 := ""
Local cQuery	 := ""
Local cCodFJVSx8 := ""
Local cFVJInd2   := FJV->(IndexKey(2))
Local nOrder     := Iif(!Empty(cFVJInd2) .and. Alltrim(cFVJInd2) == "FJV_CODIGO" ,2,0)

If nOrder == 2
	FJV->(DbSetOrder(nOrder))
	While Empty(cCodFJV) .OR. FJV->(DBSEEK(cCodFJV))
		cCodFJV := GetSx8Num("FJV","FJV_CODIGO","FJV_CODIGO"+cEmpAnt,nOrder)
		ConfirmSx8()
	EndDo
Else

	If __nTamFJV == NIL
		__nTamFJV  := TamSX3("FJV_CODIGO")[1]
	Endif

	cTab := GetNextAlias()
    cQuery := "SELECT MAX(FJV_CODIGO) MAXFJV"
    cQuery += " FROM "+RetSqlName("FJV")+" FJV"
    cQuery += " WHERE D_E_L_E_T_ = ' ' "
    cQuery := ChangeQuery(cQuery)

    If Select(cTab) > 0
        (cTab)->(dbCloseArea())
    EndIf

    dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cTab, .T., .T.)

    // Tratamento para formatação do Valor retornado na consulta
    cCodFJV := Left((cTab)->MAXFJV, __nTamFJV)
    If Len(AllTrim(cCodFJV)) < __nTamFJV
        cCodFJV := PadL(cCodFJV,__nTamFJV,"0")
    EndIf
    (cTab)->(dbCloseArea())

    While EMPTY(cCodFJVSx8) .OR. cCodFJVSx8 <= cCodFJV
        cCodFJVSx8 := GetSx8Num("FJV","FJV_CODIGO","FJV_CODIGO"+cEmpAnt)
        ConfirmSx8()
    EndDo
    cCodFJV := cCodFJVSx8
EndIf

RestArea(aArea)

Return cCodFJV

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINSOMALOTE

Soma Lote Financeiro com tratamento para possivel aumento do campo de 4 para 8 posicoes (Retorno CNAB).
Arquivo original: FINXATU.PRX

@param cLoteFin - número do lote par cálculo da Soma1.

@Author	Gustavo Henrique
@since	15/09/09
/*/
//-----------------------------------------------------------------------------------------------------
Function FinSomaLote(cLoteFin)

Local cRet		:= ""
Local nTamLote	:= TamSX3("EE_LOTE")[1]
Local nTamLtFin := Len(Alltrim(cLoteFin))

cRet	:= AllTrim( cLoteFin )
If nTamLtFin < nTamLote
	cRet:= Soma1(cRet)
Else
	cRet := Soma1( PadL( cRet, nTamLote ) )
EndIf
Return cRet


//-------------------------------------------------------------------
/*/{Protheus.doc} FINMsgCnab
Função para validação dos campos de mensagem para CNAB (Tabela SEE)
Arquivo original: FINXATY.PRX

@sample FINMsgCnab()
@author Mauricio Pequim Jr
@since 15/05/13
@version 1.0

@return lRet	Fórmula válida ou não
/*/
//-------------------------------------------------------------------
Function FINMsgCnab()
Local xResult	:= NIL
Local cForm		:= &(ReadVar())
Local lRet		:=.T.
Local aRetSyntax:= {}
Local cLine		:= ""
Local lExec		:= .T.
Local bBlock	:= {||.T.}
Local nPos		:= 0

aRetSyntax := ParAnalise(cForm)	// Analise estrutural de sintaxe

IF !Empty(aRetSyntax[1])
	Help(" ",1,"ERROFORM",,OemToAnsi( STR0001 + aRetSyntax[1]),1,0)  //"Estrutura Inconsistente : "
	lRet := .f.
Endif

If lRet
	For nPos := 1 to len(aRetSyntax[2])
		cLine	:= upper(aRetSyntax[2][nPos])
		If "M->" $ cLine .or. "m->" $ cLine
			lExec := .F.
		Endif
	Next nX

	If lExec
		bBlock := ErrorBlock( { |e| ChecErro(e) } )
		BEGIN SEQUENCE
			xResult := &cForm
		RECOVER
			lRet := .F.
		END SEQUENCE
		ErrorBlock(bBlock)
	Endif
Endif

Return lRet


//------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ParAnalise
Função static auxiliar da validação dos campos de mensagem para CNAB (Tabela SEE)
Valida a sintaxe da fórmula digitada.

Arquivo original: FINXATU.PRX

@sample ParAnalise(cTexto)
@author Mauricio Pequim Jr
@since 15/05/13
@version 1.0

@param cTexto		Expresão ou fórmula a ser validada
@return aVetor		Vetor [1] cStack -> Se preenchido, indica qual caracter na estrutura não está  coerente com a mesma.
					Vetor [2] aParam -> Array com os textos correspondentes dentro das estruturas.
/*/
//------------------------------------------------------------------------------------------------------------------------
Static Function ParAnalise(cTexto)

Local cStack:=""  , cAspas:=""
Local aSepFunc:={"()","[]","{}"}, aParam:={}
Local nPosAt:=1 , uLastPar:=1 , cPosAtual
Local uAbre , uFecha , cSeparador:=","

// Arranca os caracteres da esquerda se forem 'espa‡o' ou 'TAB'
While left(cTexto,1)==" " .or. left(cTexto,1)==chr(9)
   cTexto:=right(cTexto,len(cTexto)-1)
EndDo
While nPosAt<=len(cTexto)
   cPosAtual:=substr(cTexto,nPosAt,1)
   If cPosAtual==chr(34) .or. cPosAtual==chr(39)	// Achou "ASPAS"
		cAspas:=If(empty(cAspas),cPosAtual,If(cAspas == cPosAtual,"",cAspas))
   Endif
   If empty(cAspas)			// Apenas analiza a estrutura caso nao esteja entre aspas
      uAbre :=ascan(aSepFunc,{|_v|  left(_v,1) == cPosAtual})
      uFecha:=ascan(aSepFunc,{|_v| right(_v,1) == cPosAtual})
      If uAbre+uFecha>0		// Abriu ou Fechou uma estrutura
         If uAbre>0	// Abriu uma estrutura ! Acrescenta no STACK
            If !empty(substr(cTexto,uLastPar,nPosAt-uLastPar))
               aadd(aParam,substr(cTexto,uLastPar,nPosAt-uLastPar))
            Endif
	         uLastPar:=nPosAt+1	 ; cStack:=cStack+cPosAtual
         Else			// Fechou uma estrutura : Checa o STACK
            If right(cStack,1)==Left(aSepFunc[uFecha],1)	// Se fechou certo, tira do Stack
               cStack:=left(cStack,len(cStack)-1)
				Else	// Estrutura fechada incorretamente
					cStack:=right(aSepFunc[uFecha],1)
					EXIT
            Endif
            If !empty(substr(cTexto,uLastPar,nPosAt-uLastPar))
               aadd(aParam,substr(cTexto,uLastPar,nPosAt-uLastPar))
            Endif
	         uLastPar:=nPosAt+1
         Endif
      Else	// Verifica separador
			If cPosAtual==cSeparador
            aadd(aParam,substr(cTexto,uLastPar,nPosAt-uLastPar))
            uLastPar:=nPosAt+1
         Endif
      Endif
   Endif
	nPosAt++
EndDo
IF !empty(cTexto) .and. len(aParam) == 0
	aadd(aParam,alltrim(cTexto))
Endif
cStack+=if(empty(cAspas),"",cAspas)
Return {cStack,aParam}


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FMsgCnab
Função para macroexecução do conteúdo dos campos de mensagem do chab (Tabela SEE):
EE_FORMEN1, EE_FORMEN2, EE_FOREXT1, EE_FOREXT2

Arquivo original: FINXATU.PRX

@sample FMsgCnab(cCampo)
@author Mauricio Pequim Jr
@since 15/05/13
@version 1.0

@param cCampo	Nome do campo a ser macroexecutado
@return cTexto	Texto resultante da macroexecução do campo
/*/
//---------------------------------------------------------------------------------------------------------
Function FMsgCnab(cCampo)

Local cRet		:= ""
Local aRetSyntax:= {}

Default cCampo := ""

aRetSyntax := ParAnalise(cCampo)	// Analise estrutural de sintaxe

IF Empty(aRetSyntax[1])

	bBlock := ErrorBlock( { |e| ChecErro(e) } )
	BEGIN SEQUENCE
		cRet := &cCampo
	RECOVER
		cRet := STR0002 //"Falha de configuração. Verifique configuração da mensagem."
	END SEQUENCE
	ErrorBlock(bBlock)
Else
	cRet := STR0002		//"Falha de configuração. Verifique configuração da mensagem."
Endif

Return cRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA040LEGENDA

Legenda do SE1 - Contas a Receber
Arquivo original: FINXATU.PRX

@param cLoteFin - número do lote par cálculo da Soma1.

@Author	Wagner Mobile Costa
@since	22/10/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa040Legenda(cAlias, nReg)
Local lPrjCni		:= ValidaCNI()
Local aLegenda		:= {{"BR_VERDE", 	STR0003 },;	//1.  "Titulo em aberto"
						{"BR_AZUL", 	STR0004 },;	//2.  "Baixado parcialmente"
						{"BR_VERMELHO", STR0005 },;	//3.  "Titulo Baixado"
						{"BR_PRETO", 	STR0006 },;	//4.  "Titulo em Bordero"
						{"BR_BRANCO", 	STR0007 },;	//5.  "Adiantamento com saldo"
						{"BR_CINZA",	STR0008 },; //6. "Titulo baixado parcialmente e em bordero"
						{"BR_AMARELO", STR0072} } 	//7. "Adiantamento de Imp. Bx. com saldo"
Local uRetorno		:= .T.
Local aLegNew		:= {}

Default __lFaLegPares	:= ExistBlock("FaLegPARes") .And. ExecBlock("FaLegPARes",.f.,.f.) // Ponto de Entrada permite visualizar na legenda se um titulo de PA possue residuos de saldo.
Default lF040ADLE		:= ExistBlock("F040ADLE")
Default lFinaleg		:= ExistBlock("FINALEG")
Default lF040URET		:= ExistBlock("F040URET")

If __lFaLegPares	.And. cAlias = "SE2"
	Aadd(aLegenda,{"BR_MARROM",STR0009}) //"Adiantamento com resíduo no saldo"
EndIf

/*
	Sem Recno --> Retornar array com as regras para o Browse colocar as cores na coluna.
	Com Recno --> Chamada via botão Legendas do browse -> Abrir telinha de Legendas (BrwLegenda)
*/
If nReg = Nil	// Retornar as regras de legenda

	uRetorno := {}

	If cAlias = "SE1"

		Aadd(aLegenda, {"BR_VERDE_ESCURO", STR0012})  //8. "Titulo Protestado"
		Aadd(aLegenda, {"BR_AZUL_CLARO", STR0090}) //9. "Fatura Cancelada (SIGAPFS)"

		If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
			Aadd(aLegenda, {"BR_PINK"	,STR0010}) //10.  "Adiantamento gerado por Nota Fiscal"
			Aadd(aLegenda, {"BR_LARANJA",STR0011}) //11.  "Titulo com operacão de adiantamento"
		EndIf

		If cPaisLoc == "BRA" .And. FindFunction("FINA890")
			aAdd(aLegenda, { "BR_LARANJA" , STR0092 })  //10. "Título em PIX"
			aAdd(aLegenda, { "BR_MARROM" , STR0093 }) //11. "Título baixado parcialmente e em PIX"
			aAdd(aLegenda, { "BR_PINK" , STR0094 }) //12. "Título em PIX e Borderô"
			aAdd(aLegenda, { "BR_VIOLETA" , STR0095 }) //13. "Título baixado parcialmente e em PIX e Borderô"
		EndIf

		Aadd(uRetorno, { 'Iif(FindFunction("JurCNF"), JurCNF(SE1->(Recno())), .F.)'					, aLegenda[9][1]				 }) // "Fatura Cancelada (SIGAPFS)"
		Aadd(uRetorno, { 'ROUND(E1_SALDO,2) = 0'													, aLegenda[3][1]				} ) //"Titulo Baixado"
		If cPaisLoc == "BRA" .And. FindFunction("FINA890")
			aAdd(uRetorno, { 'TitTemPIX(E1_FILIAL) .And. !Empty(E1_NUMBOR) .and.(ROUND(E1_SALDO,2) # ROUND(E1_VALOR,2))', aLegenda[13][1] }) // "Título baixado parcialmente e em PIX e Borderô"
			aAdd(uRetorno, { 'TitTemPIX(E1_FILIAL) .And.(ROUND(E1_SALDO,2) # ROUND(E1_VALOR,2))', aLegenda[11][1] }) // "Título baixado parcialmente e em PIX"
			aAdd(uRetorno, { 'TitTemPIX(E1_FILIAL) .And. !Empty(E1_NUMBOR)', aLegenda[12][1] }) // "Título em PIX e Borderô"
			aAdd(uRetorno, { 'TitTemPIX(E1_FILIAL)', aLegenda[10][1] }) // "Título em PIX"
		EndIf
		Aadd(uRetorno, { '!Empty(E1_NUMBOR) .and.(ROUND(E1_SALDO,2) # ROUND(E1_VALOR,2))'			, aLegenda[6][1]				} ) //"Titulo baixado parcialmente e em bordero"
		Aadd(uRetorno, { 'E1_TIPO == "'+MVRECANT+'".and. ROUND(E1_SALDO,2) > 0 .And. !FXAtuTitCo()'	, aLegenda[5][1]				} ) //"Adiantamento com saldo"
		Aadd(uRetorno, { '!Empty(E1_NUMBOR)'														, aLegenda[4][1]				} ) //"Titulo em Bordero"
		Aadd(uRetorno, { '!((ROUND(E1_SDACRES,2)>0.OR.ROUND(E1_ACRESC,2)>0) .AND. ROUND(E1_SALDO,2)=ROUND(E1_VALOR,2)) .And. ROUND(E1_SALDO,2) + ROUND(E1_SDACRES,2) # ROUND(E1_VALOR,2) + ROUND(E1_ACRESC,2) .And. !FXAtuTitCo()', aLegenda[2][1]} ) //"Baixado parcialmente"
		Aadd(uRetorno, { 'ROUND(E1_SALDO,2) == ROUND(E1_VALOR,2) .and. AllTrim(E1_SITUACA)== "F"'			, aLegenda[8][1]	} ) //"Titulo Protestado"

		If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
			Aadd(uRetorno, {	'E1_ORIGEM == "MATA467N" .And. ROUND(E1_SALDO,2) > 0 .And. FXAtuTitCo()'									, aLegenda[10][1] } )
			Aadd(uRetorno, {	'ALLTRIM(E1_ORIGEM) $ "FINA087A|'+IIF(FindFunction('OriCobrDiv'),OriCobrDiv(),"")+'" .And. ROUND(E1_SALDO,2) > 0 .And. FXAtuTitCo() .And. E1_TIPO == "'+MVRECANT+'"'	, aLegenda[11][1] } )
		EndIf

	Else // SE2

		If lPrjCni
			IF !Empty(SuperGetMv("MV_APRPAG",.F.,"")) .or. SuperGetMv("MV_CTLIPAG",.F.,.F.)
				Aadd(aLegenda, {"BR_PINK", STR0013})  //"Titulo aguardando liberacao"
				Aadd(uRetorno, { ' EMPTY(E2_DATALIB) .AND. (SE2->E2_SALDO+SE2->E2_SDACRES-SE2->E2_SDDECRE) > GetMV("MV_VLMINPG") .AND. E2_SALDO > 0', aLegenda[Len(aLegenda)][1] } )
			EndIf
		Else
			IF SuperGetMv("MV_CTLIPAG",.F.,.F.)
				Aadd(aLegenda, {"BR_PINK", STR0074})	//"Titulo aguardando liberacao"
				Aadd(uRetorno, { ' !( SE2->E2_TIPO $ MVPAGANT ).and. EMPTY(E2_DATALIB) .AND. (SE2->E2_SALDO+SE2->E2_SDACRES-SE2->E2_SDDECRE) > SuperGetMV("MV_VLMINPG",.F.,0) .AND. E2_SALDO > 0', aLegenda[Len(aLegenda)][1] } )
			EndIf
		EndIf

		Aadd(aLegenda, {"BR_LARANJA", STR0073}) //"Adiantamento de Viagem sem taxa"
		Aadd(uRetorno, { ' (ALLTRIM(SE2->E2_ORIGEM) $ "FINA667|FINA677") .and. SE2->E2_MOEDA > 1 .AND. SE2->E2_TXMOEDA == 0 .AND. SE2->E2_SALDO > 0', aLegenda[Len(aLegenda)][1] } )

		IF __lFaLegPares
			Aadd(aLegenda,{"BR_MARROM",STR0046})
			Aadd(uRetorno, { 'E2_TIPO == "'+MVPAGANT+'" .and. ROUND(E2_SALDO,2) > 0 .And. (ROUND(E2_SALDO,2) < ROUND(E2_VALOR,2))', aLegenda[Len(aLegenda)][1] } )
		Endif

		//Validação para uso do documento hábil - SIAFI
		If FinUsaDH()
			Aadd(aLegenda,{"BR_VIOLETA",STR0070}) // "Titulo Vinculado a Docto Hábil"
			Aadd(uRetorno, { 'ROUND(E2_SALDO,2) > 0 .And. !EMPTY(E2_DOCHAB)'	, aLegenda[Len(aLegenda)][1]				} ) //"Titulo relacionado ao Documento hábil"
		Endif
		Aadd(uRetorno, { 'E2_TIPO $ "INA/'+MVTXA+'" .and. ROUND(E2_SALDO,2) > 0 .And. E2_OK == "TA"  ', aLegenda[7][1] } )
		Aadd(uRetorno, { 'E2_TIPO == "'+MVPAGANT+'" .and. ROUND(E2_SALDO,2) > 0', aLegenda[5][1] } )
		Aadd(uRetorno, { 'ROUND(E2_SALDO,2) + ROUND(E2_SDACRES,2)  = 0', aLegenda[3][1] } )
		Aadd(uRetorno, { '!Empty(E2_NUMBOR) .and.(ROUND(E2_SALDO,2)+ ROUND(E2_SDACRES,2) # ROUND(E2_VALOR,2)+ ROUND(E2_ACRESC,2))', aLegenda[6][1] } )
		Aadd(uRetorno, { '!Empty(E2_NUMBOR)', aLegenda[4][1] } )
		Aadd(uRetorno, { 'ROUND(E2_SALDO,2)+ ROUND(E2_SDACRES,2) # ROUND(E2_VALOR,2)+ ROUND(E2_ACRESC,2)', aLegenda[2][1] } )

	Endif


	// PE que Adiciona regra de legendas do usuário --> adiciona sempre no final, antes da { .T. , BR_VERDE }
	If lF040URET
		uRetNew := ExecBlock("F040URET",.F.,.F.,{uRetorno,aLegenda})
		If ValType(uRetNew) = "A"
			aEval(uRetNew,{|J| aAdd(uRetorno,{J[1],J[2]}) })
		Endif
	Endif
	// --> Legenda BR_VERDE -> Última regra de legenda, tanto para SE1 e SE2
	Aadd(uRetorno, { '.T.', aLegenda[1][1] } )

	If lFinaleg // Ponto de entrada para manipular toda a regra de legendas
		uRetorno := ExecBlock("FINALEG",.F.,.F.,{nReg,cAlias,uRetorno,{}})
	EndIf


Else // Abrir telinha de Legendas (BrwLegenda)

	If cAlias = "SE1"
		If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
			Aadd(aLegenda, {"BR_PINK"	,STR0010}) //7.  "Adiantamento gerado por Nota Fiscal"
			Aadd(aLegenda, {"BR_LARANJA",STR0014}) //8.  "Titulo com operacão de adiantamento"
		EndIf
		Aadd(aLegenda,{"BR_VERDE_ESCURO", STR0012}) //"Titulo Protestado"
		Aadd(aLegenda,{"BR_AZUL_CLARO", STR0090}) //"Fatura Cancelada (SIGAPFS)"
		
		If cPaisLoc == "BRA" .And. FindFunction("FINA890")
			aAdd(aLegenda, { "BR_LARANJA" , STR0092 }) // "Título em PIX"
			aAdd(aLegenda, { "BR_MARROM" , STR0093 }) // "Título baixado parcialmente e em PIX"
			aAdd(aLegenda, { "BR_PINK" , STR0094 }) // "Título em PIX e Borderô"
			aAdd(aLegenda, { "BR_VIOLETA" , STR0095 })	// "Título baixado parcialmente e em PIX e Borderô"
		EndIf
	Else
		If lPrjCni
			If !Empty(SuperGetMv("MV_APRPAG",.F.,"")) .or. SuperGetMv("MV_CTLIPAG",.F.,.F.)
				Aadd(aLegenda, {"BR_PINK",  STR0013})		//"Titulo aguardando liberacao"
			EndIf
		Else
			IF SuperGetMv("MV_CTLIPAG",.F.,.F.)
				Aadd(aLegenda, {"BR_PINK",  STR0013})		//"Titulo aguardando liberacao"
			EndIf
		Endif

		If cPaisLoc == "BRA" .Or. !(FindFunction("FA080MI") .And. FA080MI())	// No aplica para países de MI
			Aadd(aLegenda, {"BR_LARANJA", STR0073}) //"Adiantamento de Viagem sem taxa"
		EndIf

		IF __lFaLegPares
			Aadd(aLegenda,{"BR_MARROM",STR0046})
		Endif

		//Validação para uso do documento habil (SIAFI)
		If FinUsaDH()
			Aadd(aLegenda,{"BR_VIOLETA",STR0070}) // "Titulo Vinculado a Docto Hábil"
		EndIf
	EndIf

	If lF040ADLE
		aLegNew := ExecBlock("F040ADLE",.F.,.F.,aLegenda)
		If ValType(aLegNew) = "A"
			aEval(aLegNew,{|J| aAdd(aLegenda,{J[1],J[2]}) })
		Endif
	EndIf

	If lFinaleg
		ExecBlock("FINALEG",.F.,.F.,{nReg,cAlias,{},aLegenda})
	Else
		BrwLegenda(cCadastro, STR0066, aLegenda)		//"Legenda"
	EndIf

EndIf

Return uRetorno


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINSEQSE5

Encontra a proxima sequencia para o movto bancario (CR) (FINA191).
Arquivo original: FINXATU.PRX

@Author	Claudio D. de Souza
@since	06/11/2003
/*/
//-----------------------------------------------------------------------------------------------------
Function FinSeqSe5(cPrefixo,cNum,cParcela,cTipo,lQuery)
Local cSequencia	:= ""
Local aAreaSE1		:= SE1->(GetArea())

Default cPrefixo	:= SE1->E1_PREFIXO
Default cNum		:= SE1->E1_NUM
Default cParcela	:= SE1->E1_PARCELA
Default cTipo		:= SE1->E1_TIPO
Default lQuery		:= .F.

SE1->(dbSetOrder(1))
SE1->(MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+cTipo))

cSequencia := FinSeqFK1()

RestArea(aAreaSE1)
FwFreeArray(aAreaSE1)

Return cSequencia


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FBXLOTAUT

Baixa Automatica em lotes (Chama FINA110 e FINA090).
Arquivo original: FINXATU.PRX

@param cAlias - Alias (SE1 ou SE2)
@param aRecnos - Array contendo o Recno dos arquivos a serem baixados
@param cBanco - Banco para baixa
@param cAgencia - Agencia para Baixa
@param cConta - Conta para Baixa
@param cCheque - Cheque para Baixa
@param cLoteFin - Lote para agrupamento das baixas (loteFin)
@param cNatureza - Natureza do movimento bancario (C.Pagar)
@param dBaixa


@Author	Mauricio Pequim Jr.
@since	11/05/2010
/*/
//-----------------------------------------------------------------------------------------------------
Function FBxLotAut(cAlias,aRecnos,cBanco,cAgencia,cConta,cCheque,cLoteFin,cNatureza,dBaixa)

Local aTitulos		:= {}
Local lRet			:= .T.
Local dBKPDTBase	:= dDataBase	// Copia para restaurar no final
Local lBaixaVenc	:= .F.
Local nThreads		:= 0
Local lSitef		:= FwIsInCallStack("FINA910") .Or. FWIsInCallStack("FINA918")

PRIVATE lMSHelpAuto	:= .T.
PRIVATE lMsErroAuto	:= .F.

Default cAlias		:= ""
Default aRecnos		:= {}
Default cBanco		:= ""
Default cAgencia	:= ""
Default cConta		:= ""
Default cCheque		:= ""
Default cLoteFin	:= ""
Default cNatureza	:= ""
Default dBaixa		:= dDatabase

If lSitef .and. Type("LUSEFIFDTCRED") == "L" .AND. lUseFIFDtCred
	//se deve gravar a data de credito na E1_BAIXA
	lBaixaVenc := .T.
EndIf

nThreads := If( (nThreads > 20) , 20 , nThreads )
//Gero numeracao automatica de lote
If Empty(cLoteFin)
	cLoteFin := GetNewLote()
Endif

cBanco		:= PADR(cBanco,TAMSX3("A6_COD")[1])
cAgencia	:= PADR(cAgencia,TAMSX3("A6_AGENCIA")[1])
cConta		:= PADR(cConta,TAMSX3("A6_NUMCON")[1])
cCheque		:= PADR(cCheque,TAMSX3("EF_NUM")[1])
cNatureza	:= PADR(cNatureza,TAMSX3("ED_CODIGO")[1])

SED->(dbSetOrder(1))

//Verifico informacoes para processo
If Empty(cAlias) .or. Empty(cBanco) .or. Empty(cAgencia) .or. Empty(cConta)
	Help(" ",1,"BXLTAUT1",,STR0015, 1, 0 ) //"Informações incorretas não permitem a baixa automática em lote. Verifique as informações passadas para a função FBXLOTAUT()"
	lRet		:= .F.
ElseIf !CarregaSa6(@cBanco,@cAgencia,@cConta,IIf( nThreads > 1, .F., .T. ),,.T.,,,lSitef)
	lRet		:= .F.
ElseIf Empty(aRecnos)
	Help(" ",1,"RECNO")
	lRet		:= .F.
ElseIf !Empty(cNatureza) .and. !ExistCpo("SED",cNatureza,,STR0016) //"Natureza Informada não Existe."
	lRet		:= .F.
ElseIf !Empty(cCheque) .and. cAlias == "SE2" .and. !(FVerCheq(cBanco,cAgencia,cConta,cCheque))
	lRet		:= .F.
Else
	aTitulos := {aRecnos,cBanco,cAgencia,cConta,cCheque,cLoteFin,cNatureza,dBaixa,lBaixaVenc}
	VALOR := 0

	If cAlias == "SE1"
		FINA110( 3 , aTitulos )
	Else
		FINA090( 3 , aTitulos )
	Endif
Endif

If lMsErroAuto
	MOSTRAERRO()
	RollBackSx8()
	lRet := .F.
EndIf

lMSHelpAuto := .F.
lMsErroAuto := .F.

//volta a database
dDataBase := dBKPDTBase

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FVERCHEQ

Valida cheque informado.se digitado e diferente de '*' (chamada da FBxLotAut).
Arquivo original: FINXATU.PRX

@Author	Mauricio Pequim Jr.
@since	13/05/2010
/*/
//-----------------------------------------------------------------------------------------------------
Function FVerCheq(cBanco,cAgencia,cConta,cCheque )
Local lRet    := .t.

lRet := VldUser("EF_NUM") // Chama a validacao de usuario
If lRet .And. !Empty(cCheque) .And. Substr(cCheque,1,1) # "*"
	SEF->(dbSetOrder(1))
	If SEF->( (dbSeek( xFilial("SEF") + cBanco + cAgencia + cConta + cCheque ) ) )
		Help( " ",1,"F090Cheq" )
		lRet := .f.
	Endif
Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FINSITCOP

Apresenta tela para selecao de situacoes de cobranca (finr721/finr730/finr731)
Arquivo original: FINXATU.PRX

@author pequim

@since 13/12/2013
@version 1.0
/*/
//-------------------------------------------------------------------
Function FinSitCob()

Local oQual
Local oDlg
Local oOk			:= LoadBitmap( GetResources(), "LBOK" )
Local oNo			:= LoadBitmap( GetResources(), "LBNO" )
Local cCapital		:= ""
Local cVar			:= "  "
Local cTitulo		:= STR0018 //"Situações de Cobrança"
Local cSituaca		:= ""
Local nX			:= 0
Local nOpca			:= 0
Local aArea			:= GetArea()
Local aTipoBack		:={}
Local aSituaca		:={}
Local lRunDblClick	:= .T.

//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
// Monta a tabela de tipos de T¡tulos
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
dbSelectArea("FRV")
dbSeek(xFilial("FRV"))
While !EOF() .and. FRV->FRV_FILIAL == xFilial("FRV")
	cCapital := Capital(FRV->FRV_DESCRI)
	Aadd(aSituaca,{.T.,FRV->FRV_CODIGO,PadR(cCapital,20)})
	dbSkip()
EndDo

aTipoBack := aClone(aSituaca)

nOpca := 0

DEFINE MSDIALOG oDlg TITLE cTitulo From 9,0 To 35,50 OF oMainWnd

@ 0.5,  0.3 TO 13.6, 20.0 LABEL cTitulo OF oDlg
@ 2.3,3 Say OemToAnsi("  ")
@ 1.0,.7 LISTBOX oQual VAR cVar Fields HEADER "",STR0019,STR0020 SIZE 150,170 ON DBLCLICK (aTipoBack:=FA060Troca(oQual:nAt,aTipoBack),oQual:Refresh()) NOSCROLL //"Código"###"Descrição"

oQual:SetArray(aTipoBack)
oQual:bLine := { || {if(aTipoBack[oQual:nAt,1],oOk,oNo),aTipoBack[oQual:nAt,2],aTipoBack[oQual:nAt,3]}}
oQual:bHeaderClick := {|oObj,nCol| If(lRunDblClick .And. nCol==1, aEval(aTipoBack, {|e| e[1] := !e[1]}),Nil), lRunDblClick := !lRunDblClick, oQual:Refresh()}

DEFINE SBUTTON FROM 10  ,166  TYPE 1 ACTION (nOpca := 1,oDlg:End()) ENABLE OF oDlg
DEFINE SBUTTON FROM 22.5,166  TYPE 2 ACTION oDlg:End() ENABLE OF oDlg

ACTIVATE MSDIALOG oDlg CENTERED

IF nOpca == 1
	aSituaca := Aclone(aTipoBack)
EndIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta a string de tipos para filtrar o arquivo               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cTipos :=""

For nX := 1 To Len(aSituaca)
	If aSituaca[nX,1]
		cSituaca += aSituaca[nX,2]+"|"
	Endif
Next nX

DeleteObject(oOk)
DeleteObject(oNo)

RestArea(aArea)

Return cSituaca

//-------------------------------------------------------------------
/*/{Protheus.doc} NEWTIPCART

Função utilizada para verificar carteira do tipo de titulo contido no
arquivo SES (tipos de documentos) (FINA040/FINA050/FINA280/FINA290).
Arquivo original: FINXATU.PRX

@author Mauricio Pequim Jr.
@since 22/08/2000
/*/
//-------------------------------------------------------------------
Function NEWTIPCART(cTipo,cCarteira)
Local lRet := .T.
SES->(dbSetOrder(1))
If cTipo == NIL .or. cCarteira == NIL
	lRet := .F.
Elseif SES->(dbSeek(xFilial("SES")+cTipo))
	If !(SES->ES_CARTEIR $ cCarteira+"/3")
		lRet := .F.
	Endif
Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FA040NUM

Validação do numero do titulo CR.
Arquivo original: FINXATU.PRX

@author Wagner Xavier
@since 22/04/1992
/*/
//-------------------------------------------------------------------
Function FA040Num()
Local lRetorna := .T., nOrder, cAlias
Local nRecNo := SE1 -> (RecNo())
Local nPos := 0
Local cTipo := ""
Local lInclTit	:= IIF(TYPE("INCLUI")<>"U",INCLUI,.F.)
Local AGETS := {}

If cPaisLoc == "EQU" .and. !lInclTit //somente para equador e se nao for inclusão
	If Type("lF040Auto")=="L" .and. lF040Auto
		nPos := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "E1_TIPO"})
		If nPos > 0
			cTipo := aAutoCab[nPos] [2]
		EndIf
		M->E1_PREFIXO 	:= SE1->E1_PREFIXO
		M->E1_NUM 		:= SE1->E1_NUM
		M->E1_TIPO 		:= cTipo
		M->E1_PARCELA 	:= SE1->E1_PARCELA
		M->E1_CLIENTE	:= SE1->E1_CLIENTE
		M->E1_LOJA 		:= SE1->E1_LOJA
	EndIf
EndIF
cAlias := Alias()
nOrder := IndexOrd()

If IIf(Type("lF040Auto")=="U",.T.,lF040Auto==.F.)
	If (!Empty(M->E1_CLIENTE))
		If cPaisLoc $ "BRA|MEX"
			If Readvar() == "M->E1_CLIENTE"
				If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA410" .or. FunName() = "MATA460A" .or. FunName() = "MATA460B")
					If IIf(FunName() = "MATA410" .and. Type("M->C5_CLIENTE") != "U",M->E1_CLIENTE != M->C5_CLIENTE,IIf(FunName() = "MATA460A" .and. SC5->(!Eof()),M->E1_CLIENTE != SC5->C5_CLIENTE,.F.))
						Aviso(STR0067,STR0021,{ "Ok" })  //"Atenção"###"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do cliente seja o mesmo do 'Pedido de Venda/Documento de Saída'."
						Return(.F.)
					Endif
				Endif
			Endif
		Endif
	Endif
Endif

If ( !Empty(M->E1_CLIENTE) .And. !Empty(M->E1_LOJA) )
	If Readvar() == "M->E1_CLIENTE"

		If IIf(Type("lF040Auto")=="U",.T.,lF040Auto==.F.)
			If cPaisLoc $ "BRA|MEX"
				If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA410" .or. FunName() = "MATA460A" .or. FunName() = "MATA460B")
					If IIf((FunName() = "MATA410" .or. FunName() = "MATA460B") .and. Type("M->C5_CLIENTE") != "U" .and. Type("M->C5_LOJACLI") != "U" ,(M->E1_CLIENTE+M->E1_LOJA != M->C5_CLIENTE+M->C5_LOJACLI),IIf(FunName() = "MATA460A" .and. SC5->(!Eof()),(M->E1_CLIENTE+M->E1_LOJA != SC5->C5_CLIENTE+SC5->C5_LOJACLI),.F.))
						Aviso(STR0067,STR0021,{ "Ok" }) 	//"Atenção"###"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do cliente seja o mesmo do 'Pedido de Venda/Documento de Saída'."
						Return(.F.)
					Endif
				Endif
			Endif
		Endif

		If ( SA1->A1_COD != M->E1_CLIENTE )
			dbSelectArea("SA1")
			dbSetOrder(1)
			dbSeek(xFilial()+M->E1_CLIENTE,.F.)
		EndIf
		M->E1_LOJA := SA1->A1_LOJA
	Else
		If IIf(Type("lF040Auto")=="U",.T.,lF040Auto==.F.)
			If Readvar() == "M->E1_LOJA"
				If cPaisLoc $ "BRA|MEX"
					If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA410" .or. FunName() = "MATA460A" .or. FunName() = "MATA460B")
						If IIf(FunName() = "MATA410" .and. Type("M->C5_CLIENTE") != "U" .and. Type("M->C5_LOJACLI") != "U" ,(M->E1_CLIENTE+M->E1_LOJA != M->C5_CLIENTE+M->C5_LOJACLI),IIf((FunName() = "MATA460A"  .or. FunName() = "MATA460B") .and. SC5->(!Eof()),(M->E1_CLIENTE+M->E1_LOJA != SC5->C5_CLIENTE+SC5->C5_LOJACLI),.F.))
							Aviso(STR0067,STR0022,{ "Ok" })  //"Atenção"###"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do cliente e loja sejam os mesmos do 'Pedido de Venda/Documento de Saída'."
							Return(.F.)
						Endif
					Endif
				Endif
			Endif
		Endif

		dbSelectArea("SA1")
		dbSetOrder(1)
		IF !dbSeek(xFilial("SA1")+M->E1_CLIENTE+M->E1_LOJA)
			lRetorna := .F.
			M->E2_LOJA := "  "
		Endif
	Endif
	lRefresh:=.T.
Endif

If SA1->A1_MSBLQL == "1" .And. M->E1_CLIENTE == SA1->A1_COD .And. M->E1_LOJA == SA1->A1_LOJA
	HELP(" ",1,"REGBLOQ",,STR0119,3,1) // SA1 - Cadastro de Clientes
	Return .F.
Endif

If !Empty(m->e1_num) .And. !Empty(m->e1_tipo)
	dbSelectArea("SE1")
	dbSetOrder(1)
	If (dbSeek(xFilial("SE1")+m->e1_prefixo+m->e1_num+m->e1_parcela+m->e1_tipo) )
		Help(" ",1,"FA040NUM")
		dbGoTo( nRecNo )
		Return .F.
	ElseIf m->e1_tipo $ MVABATIM
		If ! (dbSeek(xFilial("SE1")+m->e1_prefixo+m->e1_num+m->e1_parcela))
			Help(" ",1,"FA040TIT")
			dbGoTo( nRecNo )
			Return .f.
		End
	ElseIf m->e1_tipo $ MVRECANT
		dbSelectArea("SE5")
		dbSetOrder(7)
		If dbSeek(xFilial("SE5")+m->e1_prefixo+m->e1_num+m->e1_parcela+m->e1_tipo)
			Help(" ",1,"RA_EXISTIU")
			lRetorna := .F.
		Endif
	Else
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "E1_OCORREN" } )
		If nEndereco > 0
			nEnd1 := Val(Subs(aGets[nEndereco],1,2))
			nEnd2 := Val(Subs(aGets[nEndereco],3,1))*2
			nTam	:= Len(aTela[nEnd1][nEnd2])
			IF M->E1_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+;
				MVCFABT+"/"+MVCSABT
				m->e1_ocorren := "04"
				aTela[nEnd1][nEnd2] := "04"
			Else
				m->e1_ocorren := "01"
				aTela[nEnd1][nEnd2] := "01"
			End
			lRefresh := .T.
		EndIf
		lRetorna := .T.
	EndIf
EndIf
dbSelectArea(cAlias)
dbSetOrder(nOrder)
SE1->(dbGoTo( nRecNo ))
Return lRetorna

//-------------------------------------------------------------------
/*/{Protheus.doc} FA050NUM

Validação do numero do titulo CP.
Arquivo original: FINXATU.PRX

@author Wagner Xavier
@since 27/04/1992
@Return lRetorna, Logical, Validação OK
/*/
//-------------------------------------------------------------------
Function FA050Num() As Logical
Local lRetorna	As Logical
Local nOrder 	As Numeric
Local cAlias	As Character
Local nRecNo	As Numeric
Local lLoja		As Logical
Local nTamLoja	As Numeric
Local cChaveSe2	As Character
Local nPos		As Numeric
Local cTipo		As Character
Local lInclTit	As Logical
Local aFornBco	As Array
Local cFilOpe	As Character
Local aArea		As Array
Local lJurRest  As Logical

lRetorna	:= .T.
nRecNo		:= SE2->(RecNo())
lLoja		:= .F.
nTamLoja	:= nPosLoja1 := nPosLoja2 := 0
cChaveSe2	:= ""
nPos		:= 0
cTipo		:= ""
lInclTit	:= IIF(TYPE("INCLUI")<>"U",INCLUI,.F.)
aFornBco	:= {}
cFilOpe		:= ''
aArea		:= SE2->(GetArea())
lJurRest    := .F.

If Type("lF050Auto")=="U"
	lF050Auto:=.F.
EndIf

If ( lF050Auto ) .And. cPaisLoc == "EQU" .AND. !lInclTit // QUANDO FOR INCLUSAO, ESTA VALIDAÇÃO NAO PODERA SER CHAMADA.
	nPos := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "E2_TIPO"})
	If nPos > 0
		cTipo := aAutoCab[nPos] [2]
	EndIf
	M->E2_PREFIXO 		:= SE2->E2_PREFIXO
	M->E2_NUM 				:= SE2->E2_NUM
	M->E2_TIPO 				:= cTipo
	M->E2_PARCELA 	:= SE2->E2_PARCELA
	M->E2_FORNECE	:= SE2->E2_FORNECE
	M->E2_LOJA 				:= SE2->E2_LOJA
EndIF

//Quando rotina automatica usa informação passada pelo chamador
cFilOpe := If(lF050Auto,'M->E2_FILIAL','xFilial("SE2")')

cChaveSe2 := cFilOpe + " + M->E2_PREFIXO + M->E2_NUM + M->E2_PARCELA +" +;
			" M->E2_TIPO + M->E2_FORNECE + M->E2_LOJA"

nOrder := IndexOrd()
cAlias := Alias()

//-----------------------------------------------------------
// Em chamadas automaticas do FINA050 para inclusao eh
// necessario alimentar as variaveis do fornecedor para
// validacao adequada de bloqueio do mesmo.
//-----------------------------------------------------------
If Empty(M->E2_FORNECE) .OR. Empty(M->E2_LOJA)
	If FwIsInCallStack("FINA050") .AND. FunName() # "FINA050" .AND. Type("lF050Auto") == "L" .AND. lF050Auto .AND. INCLUI .AND. Type("aAutoCab") # "U"
		If aScan(aAutoCab,{|x| x[1] == "E2_FORNECE"}) > 0 .AND. aScan(aAutoCab,{|x| x[1] == "E2_LOJA"}) > 0
			M->E2_FORNECE := aAutoCab[aScan(aAutoCab,{|x| x[1] == "E2_FORNECE"})][2]
			M->E2_LOJA := aAutoCab[aScan(aAutoCab,{|x| x[1] == "E2_LOJA"})][2]
		Endif
	Endif
Endif

If !lF050Auto
	If (!Empty(M->E2_FORNECE))
		If cPaisLoc $ "BRA|MEX"
			If Readvar() == "M->E2_FORNECE"
				If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA121" .or. FunName() = "MATA103")
					If IIf(FunName() = "MATA121" .and. Type("cA120Forn") != "U",M->E2_FORNECE != cA120Forn,IIf(FunName() = "MATA103" .and. Type("cA100For") != "U",M->E2_FORNECE != cA100For,.F.))
						Aviso(STR0067,STR0035,{ "Ok" })		//"Atenção"###"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do fornecedor seja o mesmo do 'Pedido de Compra/Documento de Entrada'."
						Return(.F.)
					Endif
				Endif
			Endif
		Endif
	Endif
Endif

If (!Empty(M->E2_FORNECE) .And. !Empty(M->E2_LOJA))

	If !lF050Auto
		If cPaisLoc $ "BRA|MEX"
			If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA121" .or. FunName() = "MATA103")
				If Readvar() == "M->E2_FORNECE"
					If IIf(FunName() = "MATA121" .and. Type("cA120Forn") != "U" .and. Type("cA120Loj") != "U" ,(M->E2_FORNECE+M->E2_LOJA != cA120Forn+cA120Loj),IIf(FunName() = "MATA103" .and. Type("cA100For") != "U" .and. Type("cLoja") != "U",(M->E2_FORNECE+M->E2_LOJA != cA100For+cLoja),.F.))
						Aviso(STR0067,STR0035,{ "Ok" })	//"Atenção","Por tratar-se de título para processo de adiantamento, é obrigatório que o código do fornecedor seja o mesmo do 'Pedido de Compra/Documento de Entrada'."
						Return(.F.)
					Endif
				Elseif ReadVar() == "M->E2_LOJA"
					If IIf(FunName() = "MATA121" .and. Type("cA120Forn") != "U" .and. Type("cA120Loj") != "U" ,(M->E2_FORNECE+M->E2_LOJA != cA120Forn+cA120Loj),IIf(FunName() = "MATA103" .and. Type("cA100For") != "U" .and. Type("cLoja") != "U",(M->E2_FORNECE+M->E2_LOJA != cA100For+cLoja),.F.))
						Aviso(STR0067,STR0025,{ "Ok" }) //"Atenção"###"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do fornecedor e loja sejam os mesmos do 'Pedido de Compra/Documento de Entrada'."
						Return(.F.)
					Endif
				Endif
			Endif
		Endif
	Endif

	dbSelectArea("SA2")
	dbSetOrder(1)
	If dbSeek(xFilial()+M->E2_FORNECE+M->E2_LOJA,.T.)
		If M->E2_LOJA != SA2->A2_LOJA .And. !Empty(M->E2_LOJA)
			Help(" ",1,"FA050NUM")
			lRetorna := .F.
		EndIf

		If lRetorna .And.SA2->A2_MSBLQL == "1" .And. M->E2_FORNECE == SA2->A2_COD .And. M->E2_LOJA == SA2->A2_LOJA
			HELP(" ",1,"REGBLOQ")
			lRetorna := .F.
		Endif
	Else
		// Limpa o codigo da loja, se estiver editando o codigo do fornecededor e
		// a loja estiver preenchida. Isto ocorre qdo. o usu rio volta ao campo
		// com a seta.
		IF !EMPTY(M->E2_LOJA) .AND. "E2_FORNECE" $ READVAR()
			M->E2_LOJA := SPACE(LEN(M->E2_LOJA))
		ENDIF
		If dbSeek(xFilial()+M->E2_FORNECE+M->E2_LOJA,.T.)
			If M->E2_LOJA != SA2->A2_LOJA .And. !Empty(M->E2_LOJA)
				Help(" ",1,"FA050NUM")
				lRetorna := .F.
			EndIf
		EndIf
	Endif
Endif

If SA2->A2_MSBLQL == "1" .And. "E2_FORNECE" $ READVAR() .And. M->E2_FORNECE == SA2->A2_COD .And. M->E2_LOJA == SA2->A2_LOJA
	HELP(" ",1,"REGBLOQ")
	lRetorna := .F.
Endif

If ! Empty(m->e2_num) .and. !Empty(m->e2_tipo) .And. !Empty(m->e2_fornece) .And. !Empty(m->e2_loja)
	dbSelectArea("SE2")
	dbSetOrder(1)
	dbSeek(&cChaveSe2)
	If Found()
		If !(lF050Auto .and. ALTERA)
			Help(" ",1,"FA050NUM")
			lRetorna := .F.
		Endif
	else
		RestArea(aArea)
	EndIf

	//-----------------------------------------------------------
	// Verifica se numeração já  havia sido utilizada - PA
	//-----------------------------------------------------------
	If m->e2_tipo $ MVPAGANT
		DbSelectArea("SE5")
		DbSetOrder(7)

		If F050PAEXIS(m->e2_prefixo, m->e2_num, m->e2_parcela, m->e2_tipo, m->e2_fornece, m->e2_loja)
			Help(" ",1,"PA_EXISTIU")
			DbSelectArea(cAlias)
			dbSetOrder(nOrder)
			Return .f.
		Endif
		SE5->(DbGoto(0))
		DbSelectArea("SE2")
	Endif

	If (cPaisLoc <> "PER" .And. M->E2_TIPO $ MVABATIM) .And. (cPaisLoc == "PER" .And. M->E2_TIPO $ StrTran( MVABATIM , "IR-|" , "" ))
		DbSetOrder(6)
		If ! dbSeek(xFilial("SE2") + m->e2_fornece + m->e2_loja + m->e2_prefixo +;
			m->e2_num + m->e2_parcela)
			Help(" ",1,"FA040TIT")
			DbSetOrder(1)
			dbGoTo( nRecNo )
			Return .f.
		End
		DbSetOrder(1)
	End
End

// RFC - Validação para o Codigo de retenção da DIRF
IF ( M->E2_DIRF == "1" ) .And. Empty( M->E2_CODRET )
	Help( " " , 1 , "FA050CODRET" ,, STR0023, 1, 0 )  //"Código de retenção não informado!"
	RETURN .F.
ENDIF

dbSelectArea(cAlias)
dbSetOrder(nOrder)
If ( lLoja .And. !lRetorna )
	M->E2_LOJA := ""
	aTela[nPosLoja1][nPosLoja2] := PadL(M->E2_LOJA,nTamLoja)
EndIf
lRefresh := .T.

If cPaisLoc != "RUS" .And. !Empty(M->E2_FORNECE) .and. !Empty(M->E2_LOJA) .and. (readvar() == "M->E2_FORNECE" .or. readvar() == "M->E2_LOJA") .or. lF050Auto

	lJurRest := FindFunction("JurIsRest") .And. JurIsRest() .And. !Empty(M->E2_FORBCO)

	If !lJurRest
		aFornBco := F050CBCO(M->E2_FORNECE, M->E2_LOJA)
		If !Empty(aFornBco)
			M->E2_FORBCO	:=	aFornBco[1]
			M->E2_FORAGE	:=	aFornBco[2]
			M->E2_FAGEDV	:=	aFornBco[3]
			M->E2_FORCTA	:=	aFornBco[4]
			M->E2_FCTADV	:=	aFornBco[5]
			If !lF050Auto
				M->E2_FORMPAG := aFornBco[6]
			Endif
		EndIf
	EndIf

EndIf

If lInclTit .And. M->E2_TIPO $ MVABATIM .And. nRecNo > 0
	RestArea(aArea)
EndIf
FwFreeArray(aArea)

Return lRetorna

//-------------------------------------------------------------------
/*/{Protheus.doc} F050PAEXIS
Verifica se um registro PA já foi registrado antes.

@param cPrefixo - Prefixo
@param cNumero - Número do título
@param cParcela - Parcelas
@param cTipo - Tipo
@param cCliFor - Fornecedor
@param cLoja - Loja

@return lRetorna - True/False se o título já existir ou não na base

@author Luiz Fernando Nai Ribeiro	
@since 30/08/2025
/*/
//-------------------------------------------------------------------
Function F050PAEXIS(cPrefixo as Character, cNumero as Character, cParcela as Character, cTipo as Character, cCliFor as Character, cLoja as Character)
	Local oMovTit		as Object
	Local lRetorna		as Logical
	Local cQuery  		as Character
	Local cDBMS			as Character
	
	oMovTit 	:= Nil
	lRetorna 	:= .F.
	cQuery 		:= "SELECT "
	cDBMS		:= UPPER(TcGetDb())

	If cDBMS == "MSSQL"
		cQuery := "SELECT TOP 1 "
	EndIf

	cQuery += "E5_NUMERO NUMERO FROM " + RetSqlName("SE5") + " WHERE "
	cQuery += "E5_FILIAL = ? AND "
	cQuery += "E5_PREFIXO = ? AND "
	cQuery += "E5_NUMERO = ? AND "
	cQuery += "E5_PARCELA = ? AND "
	cQuery += "E5_TIPO = ? AND "
	cQuery += "E5_CLIFOR = ? AND "
	cQuery += "E5_LOJA = ? AND "
	cQuery += "E5_FILORIG = ? AND "
	cQuery += "D_E_L_E_T_ = ? "

	If cDBMS == "ORACLE"
		cQuery += " AND ROWNUM < ? "
	EndIf

	If cDBMS == "POSTGRES"
		cQuery += " LIMIT ? "
	EndIf

	oMovTit := FwExecStatement():New(ChangeQuery(cQuery))

	oMovTit:SetString(1, xFilial("SE5"))
	oMovTit:SetString(2, cPrefixo)
	oMovTit:SetString(3, cNumero)
	oMovTit:SetString(4, cParcela)
	oMovTit:SetString(5, cTipo)
	oMovTit:SetString(6, cCliFor)
	oMovTit:SetString(7, cLoja)
	oMovTit:SetString(8, cFilAnt)
	oMovTit:SetString(9, ' ')

	If cDBMS == "ORACLE"
		oMovTit:SetNumeric(10, 2)
	EndIf

	If cDBMS == "POSTGRES"
		oMovTit:SetNumeric(10, 1)
	EndIf

	lRetorna := !Empty(oMovTit:execScalar("NUMERO"))

Return lRetorna

//-------------------------------------------------------------------
/*/{Protheus.doc} F050CBCO

Busca dados do banco do fornecedor.

@author Lucas de Oliveira
@since 27/02/2015
/*/
//-------------------------------------------------------------------
Function F050CBCO(cE2_Forn, cE2_Loja)
Local aFornBco := {}

Default cE2_Forn := ""
Default cE2_Loja := ""

//Verifica primeiro na tabela FIL se existe o banco cadastrado no fornecedor, se não busca os valores que estão na SA2
DBSelectArea("FIL")
DBSetOrder(1)
If FIL->(DBSeek(xFilial("FIL") + cE2_Forn + cE2_Loja))

	Aadd(aFornBco, FIL->FIL_BANCO)
	Aadd(aFornBco, FIL->FIL_AGENCI)
	Aadd(aFornBco, FIL->FIL_DVAGE)
	Aadd(aFornBco, FIL->FIL_CONTA)
	Aadd(aFornBco, FIL->FIL_DVCTA)
Else
	DBSelectArea("SA2")
	DBSetOrder(1)
	If SA2->(DBSeek(xFilial("SA2") + cE2_Forn + cE2_Loja))

		Aadd(aFornBco, SA2->A2_BANCO)
		Aadd(aFornBco, SA2->A2_AGENCIA)
		Aadd(aFornBco, SA2->A2_DVAGE)
		Aadd(aFornBco, SA2->A2_NUMCON)
		Aadd(aFornBco, SA2->A2_DVCTA)
		Aadd(aFornBco, SA2->A2_FORMPAG)
	Endif
EndIf

//Verifica se existe forma de pagamento cadastrada no fornecedor
DBSelectArea("SA2")
DBSetOrder(1)
If SA2->(DBSeek(xFilial("SA2") + cE2_Forn + cE2_Loja))
	Aadd(aFornBco, SA2->A2_FORMPAG)
Endif

Return aFornBco

//-------------------------------------------------------------------
/*/{Protheus.doc} FINOKDIACTB

Funcao para validação do botão OK ref ao Diario de Contabil (fina100/fina088).
Utilizado apenas em PTG, retorna o codigo do diário

Arquivo original: FINXATU.PRX

@author Marcelo Celi Marques
@since 06/06/2008
/*/
//-------------------------------------------------------------------
Function FinOkDiaCTB(cDiaCtb)

Default cDiaCtb := ""

If cPaisLoc == "PTG" .And. !Empty( cDiaCtb )

	cCodDiario := CTBAVerDia()

	If Empty( cCodDiario )
		Return(.F.)
	Endif
Endif

Return(.T.)


//-------------------------------------------------------------------
/*/{Protheus.doc} XCXFINA

Retorna o Caixa/Agencia/Conta geral do Financeiro

Arquivo original: FINXATU.PRX

@author Mauricio Pequim Jr.
@since 17/11/1998
/*/
//-------------------------------------------------------------------
Function xCxFina(cCaixa,cDesc)
Local aCaixaRet := {}
Local cAlias := Alias()
Local nReg	 := Recno()
Local nOrdem := IndexOrd()
Local cBcoCx := CriaVar("E1_PORTADO")
Local cAgeCx := CriaVar("E1_AGEDEP")
Local cCtaCx := CriaVar("E1_CONTA")
Local lCria
Local lIntPfs := SuperGetMV("MV_JURXFIN",,.F.)

Default cCaixa	:= GetMv("MV_CXFIN")
Default cDesc	:= STR0079 //"CAIXA GERAL"

cBcoCx := Substr(cCaixa,1,At("/",cCaixa) - 1)
cBcoCx += Space(Len(SE1->E1_PORTADO)-Len(cBcoCx))

cAgeCx := Substr(cCaixa,At("/",cCaixa) +1 ,(Rat("/",cCaixa)-At("/",cCaixa)-1))
cAgeCx += Space(Len(SE1->E1_AGEDEP)-Len(cAgeCx))

cCtaCx := Substr(cCaixa,Rat("/",cCaixa) +1,Len(SE1->E1_CONTA))
cCtaCx += Space(Len(SE1->E1_CONTA)-Len(cCtaCx))

Aadd( aCaixaRet, cBcoCx )
Aadd( aCaixaRet, cAgeCx )
Aadd( aCaixaRet, cCtaCx )

dbSelectArea("SA6")
dbSetOrder(1)		//A6_FILIAL+A6_COD+A6_AGENCIA+A6_NUMCON
// Verifica se os dados sao validos para criacao do banco.
lCria :=	!Empty(aCaixaRet[1]) .And.;
			!Empty(aCaixaRet[2]) .And.;
			!Empty(aCaixaRet[3])

If lCria .And. !SA6->(dbSeek(xFilial("SA6")+aCaixaRet[1]+aCaixaRet[2]+aCaixaRet[3]))
	RecLock("SA6",.T.)
	SA6->A6_FILIAL  := xFilial("SA6")
	SA6->A6_COD 	  := aCaixaRet[1]
	SA6->A6_AGENCIA := aCaixaRet[2]
	SA6->A6_NUMCON  := aCaixaRet[3]
	SA6->A6_NOME	  := cDesc
	SA6->A6_NREDUZ  := cDesc
	SA6->A6_MOEDA   := 01
	MsUnLock()
EndIf

If lIntPfs .And. FindFunction("J170GRAVA")// Integração com Jurídico
	J170GRAVA("SA6", xFilial("SA6") + aCaixaRet[1] + aCaixaRet[2] + aCaixaRet[3], "3")
EndIf


dbSelectArea(cAlias)
dbSetOrder(nOrdem)
dbGoto(nReg)

Return aCaixaRet


//-------------------------------------------------------------------
/*/{Protheus.doc} FXATUTITCO

Define se o titulo é de adiantamento para compensacao - Manejo de Anticipo
México

Arquivo original: FINXATU.PRX

@author TOTVS
@since 07/02/2012
/*/
//-------------------------------------------------------------------
Function FXAtuTitCo()
Local aArea	:= GetArea()
Local lRet	:= .F.

If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
	If GetAdvFVal("SED","ED_OPERADT",XFilial("SED")+SE1->E1_NATUREZ,1,"") == "1"
		lRet := .T.
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*
----------------------------------------------------------------------------
	            Funcoes retiradas do arquivo FINXFUN.PRX
----------------------------------------------------------------------------
*/

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINADISPLAY

Atualiza tela de seleção de registros da baixa automática (markbrowse especifica FINA070/080/110)
Arquivo original: FINXFUN.PRX

@Author	Vinicius S. Barreira
@since	14/12/1995
/*/
//-----------------------------------------------------------------------------------------------------
Function FinaDisplay(cMarca,lInverte,oValor,oQtda,cArquivo,oPrazoMed,lBaixa)
Local cFieldMarca := "E1_OK"
Local cArea := "R"
Local cTipo := SE1->E1_TIPO
Local lBxTitPag 	:= .T.
Local lBxTitRec		:= .T.
Local lRet			:= .T.
Local lFinVDoc		:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios
Local nVlImp		:= 0

Private nValorMarca	:= 0

Default lBaixa := .F.
If cArquivo == "R"
	cFieldMarca := "E1_OK"
	nValorMarca := SE1->(E1_SALDO+E1_SDACRES-E1_SDDECRE)
	cArea       := "R"
	cTipo       := SE1->E1_TIPO

ElseIF cArquivo == "P"
	cFieldMarca := "E2_OK"
	nValorMarca := SE2->(E2_SALDO+E2_SDACRES-E2_SDDECRE)
	cArea       := "P"
	cTipo       := SE2->E2_TIPO
	nVlImp		:= SE2->(E2_IRRF+E2_INSS+E2_ISS+E2_PIS+E2_COFINS+E2_CSLL)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso esteja ligado o controle de solicitacao de notas de credito e exista alguma ³
//³ pendencia para este titulo                                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc <> "BRA"
    SCU->(DbSetOrder(2))
Endif
If lBaixa .And. cPaisloc <> "BRA" .And. SuperGetMv('MV_SOLNCP') .And. SE2->E2_TIPO == MVNOTAFIS ;
   .And. SCU->(MsSeek(xFilial()+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_NUM+SE2->E2_PREFIXO)).And. Empty(SCU->CU_NCRED)
	HELP(" ",1,"SOLNCPAB")
	RecLock("SE2",.F.)
	Replace &cFieldMarca With ""
	SE2->(MsUnLock())
	Return
Else
	If IsMark(cFieldMarca,cMarca,lInverte)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PONTO DE ENTRADA F090TIT                                      ³
		//³ Verifica se titulo pode ser marcado para baixa ou nÆo. Caso	³
		//³ tenha sido alterada a marca‡Æo do titulo, ExecBlock dever     ³
		//³ retornar .F., para nÆo haver altera‡Æo dos acumuladores de    ³
		//³ valores e numero de titulos. Apenas para FINA080 e FINA090    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF (ExistBlock("F090TIT")) .and. cFieldMarca == "E2_OK" .and. !Empty(&cFieldMarca)
			// Bloqueio antes de chamar o ponto de entrada, pois no momento da chamada deste mesmo PE no
			// FINA090, funcoes Fa090Marca e Fa090Inverte o registro da SE2 jah estah bloqueado.
			RecLock("SE2",.F.)
			lBxTitPag := ExecBlock("F090TIT",.F.,.F.,{ nValorMarca })
			If !lBxTitPag
				SE2->&(cFieldMarca) := ""
			EndIf
			SE2->(MsUnlock())
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PONTO DE ENTRADA F110TIT                                      ³
		//³ Verifica se titulo pode ser marcado para baixa. Caso tenha    ³
		//³ sido alterada a marca‡Æo do titulo, ExecBlock dever           ³
		//³ retornar .F., para nÆo haver altera‡Æo dos acumuladores de    ³
		//³ valores e numero de titulos. Apenas para FINA070 e FINA110 	  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF (ExistBlock("F110TIT")) .and. cFieldMarca == "E1_OK" .and. !Empty(&cFieldMarca)
			// Bloqueio antes de chamar o ponto de entrada, pois no momento da chamada deste mesmo PE no
			// FINA110, funcoes Fa110Marca e Fa110Inverte o registro da SE1 jah estah bloqueado.
			RecLock("SE1",.F.)
			lBxTitRec := ExecBlock("F110TIT",.F.,.F., { nValorMarca })
			SE1->(MsUnlock())
		Endif

		If lBxTitPag .And. lBxTitRec
			If cTipo $ MVABATIM
				nValor -= Moeda(nValorMarca,1,cArea)
				nValImp -= nVlImp
				If ! Empty(oPrazoMed)
					nData    := SE1->E1_VENCTO - SE1->E1_EMISSAO
					nPrazo   -= ( nData * Moeda(nValorMarca,nMoeda,"R") )
				EndIf
			Else
				nValor += Moeda(nValorMarca,1,cArea)
				nValImp += nVlImp
				If !Empty(oPrazoMed)
					nData  := SE1->E1_VENCTO - SE1->E1_EMISSAO
					nPrazo += ( nData * Moeda(nValorMarca,nMoeda,"R") )
				EndIf
			EndIf
			nQtdTit++
		Endif
	Else
		If cTipo $ MVABATIM
			nValor += Moeda(nValorMarca,1,cArea)
			nValImp += nVlImp
			If !Empty(oPrazoMed)
				nData  := SE1->E1_VENCTO - SE1->E1_EMISSAO
				nPrazo += ( nData * Moeda(nValorMarca,nMoeda,"R") )
			EndIF
		Else
			nValor -= Moeda(nValorMarca,1,cArea)
			nValImp -= nVlImp
			If !Empty(oPrazoMed)
				nData  := SE1->E1_VENCTO - SE1->E1_EMISSAO
				nPrazo += ( nData * Moeda(nValorMarca,nMoeda,"R") )
			EndIf
		EndIf
		nQtdTit--
		nQtdTit:= Iif(nQtdTit<0,0,nQtdTit)
	EndIf
EndIf


//Controle de documentos apresentados
If cArquivo == "P"
	If SE2->E2_OK == cMarca
		IF  lFinVDoc
			lRet := .T.
			SE2->(dbGoTo(RECNO()))
			If !CN062ValDocs("01",.F.)
				//Help(" ",1,"CN062NODOC")		//"Exite(m) documento(s) não apresentado(s) para o(s) título(s)."##"Não é permitida a liberação / movimentação do(s) título(s)."
				lRet := .F.
			EndIf
		EndIf
	EndIf
	If lRet
		If SE2->E2_OK == cMarca
		nValor += Round(NoRound(xMoeda(SE2->(E2_SALDO+E2_SDACRES-E2_SDDECRE),SE2->E2_MOEDA,1,,3),3),2)
		nQtdTit++
			nValImp += nVlImp
		Else
		nValor -= Round(NoRound(xMoeda(SE2->(E2_SALDO+E2_SDACRES-E2_SDDECRE),SE2->E2_MOEDA,1,,3),3),2)
		nQtdTit--
			nValImp -= nVlImp
		Endif
		nQtdTit:= Iif(nQtdTit<0,0,nQtdTit)
		//oValor:Refresh()
		//oQtdTit:Refresh()
	Else
		RecLock("SE2")
		IF SE2->E2_OK == cMarca
			SE2->E2_OK	:= "  "
		Else
			SE2->E2_OK	:= cMarca
		Endif
		MsUnlock()
		nQtdTit:= Iif(nQtdTit<0,0,nQtdTit)
		//oValor:Refresh()
		//oQtdTit:Refresh()
		//oMark:oBrowse:Refresh(.t.)
	EndIf
EndIf

oValor:Refresh()
oQtda:Refresh()
oMark:oBrowse:Refresh(.t.)
If !Empty(oPrazoMed)
	If nValor != 0
		nPrazoMed := nPrazo / nValor
	Else
		nPrazoMed := 0
	EndIf
	oPrazoMed:Refresh()
EndIf
Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FDESCMOED

Carrega array com as descrioes das moedas utilizadas no sistema.
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	26/08/2002
/*/
//-----------------------------------------------------------------------------------------------------
Function FDescMoed()
Local cVar	 := ""
Local nX

If aMoedaFin == NIL
	// Inicializa array com as moedas existentes
	aMoedaFin := {}
	For nX := 1 to 99	// Limite de moedas possiveis atraves do CtbWizMoedas
		cVar := SuperGetMV("MV_MOEDA"+cValtoChar(nX),.F.,"")
		If Empty(cVar)
			Exit
		Else
			aAdd(aMoedaFin, StrZero(nX,2)+" "+Upper(cVar))
		EndIf
	Next
	aSort(aMoedaFin)
Endif

Return (aMoedaFin)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DATAWINDOW

Converte a data em formato Windows para Clipper
Arquivo original: FINXFUN.PRX

@Author	Eduardo Riera
@since	12/03/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function DataWindow(_Data)

Local dRetorno := Ctod("01/01/1980","ddmmyy")

If ( ValType(_Data)=="N" )
	_Data := _Data - 29221 // Corresponde a 01/01/80
	dRetorno := dRetorno + _Data
Else
	If ( ValType(_Data)=="C" )
		dRetorno := Ctod(_Data,"ddmmyy")
	Else
		dRetorno := _Data
	EndIf
EndIf
Return(dRetorno)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} BOOLWINDOW

Converte um valor logico do Window p/ um valor do Clipper.
Arquivo original: FINXFUN.PRX

@Author	Eduardo Riera
@since	12/03/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function BoolWindow(Logic)

Local lRetorno

If ( ValType(Logic)=="N" )
	If ( Logic <= 0 )
		lRetorno := .F.
	Else
		lRetorno := .T.
	EndIf
Else
	If ( ValType(Logic)=="L" )
		lRetorno := Logic
	Else
		If ( ValType(Logic)=="C" )
			If ( LOGIC $ "VERDADEIRO#TRUE#.T.#0#SIM" )
				lRetorno := .T.
			Else
				lRetorno := .F.
			EndIf
		Else
			lRetorno := .T.
		EndIf
	EndIf
EndIf
Return(lRetorno)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FNATSAISON

Define se tratamento de naturezas estruturadas esta ativo (MV_NATSINT)
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	17/12/2012
/*/
//-----------------------------------------------------------------------------------------------------
Function FNatSAIsOn()

If lNatSA == NIL  //Variavel estatica (vide topo
	lNatSA := SuperGetMv("MV_NATSINT",.T.,"2") == "1"
Endif

Return lNatSA


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MASCNAT

Devolve a natureza editada de acordo com a mascara .
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	01/06/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function MascNat(cNatur)
Local j,i
Local cMascara := SuperGetmv("MV_MASCNAT",.F.,"")
Local cNatured :=""
Local nDesl    :=0

Default cNatur := ""
If  !Empty(cMascara )
	For i = 1 To Len(cMascara)

		For j=1 To Val(Substr(cMascara,i,1))
			cNatured+=Substr(cNatur,nDesl+j,1)
		NEXT j
		If Substr(cNatur,nDesl+j,1)== " " .OR. (nDesl+j) = 15
			j=99
			i=99
			nDesl := nDesl+Val(Substr(cMascara,i,1))
		Else
			cNatured+="."
			nDesl := nDesl+Val(Substr(cMascara,i,1))
		EndIf
	Next I

	//Retira ultimo caracter se for um ponto(.)
	IF Right(AllTrim(cNatured),1) == "."
		cNatured := Substr(cNatured,1,Len(cNatured)-1)
	EndIf
Else
	cNatured:= cNatur
EndIf

Return cNatured


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FAPRNUMCHQ

Executa o Ponto de Entrada PAGNUMCHEQ para sugerir o proximo numero valido para cheque do banco informado.
 (FINA050, FINA080, FINA090, FINA190 e FINA390).
Arquivo original: FINXFUN.PRX

@Author	Cristiano Denardi
@since	22/06/2005
/*/
//-----------------------------------------------------------------------------------------------------
Function FaPrNumChq(cBco,cAg,cNum,oChq,cChq,lVal)

Local lRet        := .T.
Local nPosBlock   := 0

Static aCodeBlock := {}

Default lVal := .F.

If ExistBlock("PAGNUMCHEQ")
	If !Empty(cBco) .And. !Empty(cAg) .And. !Empty(cNum) .And. ( lVal .Or. Empty(cChq) )
		cChq := ExecBlock("PAGNUMCHEQ",.F.,.F.,{cBco,cAg,cNum,cChq})
		oChq:Refresh()
	Endif
Endif


//Ponto de entrada para validacao do Banco
If ExistBlock("F080KCO")
	lRet := ExecBlock("F080KCO",.F.,.F.,{cBco,cAg,cNum})
Endif



// Ponto de entrada para desabilitação do objeto GET do numero do cheque

// Guarda o Codigo de bloco na primeira chamada deste ponto pela da rotina para posteriormente se
// for o caso restaura-la
If ( nPosBlock := aScan( aCodeBlock, { |x| x[1] == Alltrim( FunName() ) } ) ) == 0
	aAdd( aCodeBlock, { FunName(), oChq:bWhen } )
	nPosBlock := Len( aCodeBlock )
EndIf

If ExistBlock("PAGOBJCH")
	If !Empty(cBco) .And. !Empty(cAg) .And. !Empty(cNum)
		If !ExecBlock("PAGOBJCH",.F.,.F.,{cBco,cAg,cNum,cChq,oChq,lRet})
			// O bWhen sobrepuja a definicao de oChq:Disable() pois ele é a ultimo a ser executado
			// se o bwhen retornar vedadeiro mesmo definindo oChq:Disable() o campo fica habilitado
			// por isso eh desabilitado o bwhen
			oChq:Disable()
			oChq:bWhen := { || .F. }
		Else
		    // Habilita e volta o bWhen existente no oChq da rotina que chamou este pontos
			oChq:Enable()
			oChq:bWhen := aCodeBlock[nPosBlock][2]
		EndIf
		oChq:Refresh()
	EndIf
Endif

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DELTRBIR

Funcao de EXCLUSAO do arquivo do IRRF em transacao.
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	21/10/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function DELTRBIR(cEmp,cFil,lRPC,nTread,cArqTmp)
Return EXCTRBIR(cEmp,cFil,lRPC,nTread,cArqTmp)



//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA060TROCA

Função de inversão de marcação ligada a FINATIPOS().
Arquivo original: FINXFUN.PRX

@Author	Marcos Patricio
@since	11/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FA060Troca(nIt,aArray)
aArray[nIt,1] := !aArray[nIt,1]
Return aArray


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINATIPOS

Monta tela para seleção dos tipos de titulos as serem considerados em determinado processamento.
Arquivo original: FINXFUN.PRX

@Author	Eveli Morasco
@since	06/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FinaTipos()

	FinRTipos(.T.)

Return


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINRTIPOS

Monta tela para seleção dos tipos de titulos as serem considerados em determinado processamento
(Relatorios).
Arquivo original: FINXFUN.PRX

@Author	Eveli Morasco
@since	06/05/1992
@param 	lFinATipos, logical, se a chamada foi efetuada pela função FinATipos
/*/
//-----------------------------------------------------------------------------------------------------
Function FinrTipos(lFinATipos As Logical)

	Local aTipos		As Array
	Local aTipoBack		As Array
	Local aFwSX5		As Array

	Local cAlias		As Character
	Local cCad			As Character
	Local cCapital		As Character
	Local cSX5Key		As Character
	Local cVar			As Character

	Local lRunDblClick	As Logical

	Local nChave		As Numeric
	Local nOpca			As Numeric
	Local nSeleciona	As Numeric
	Local nSX5			As Numeric
	Local nSX5Descri	As Numeric
	Local nSX5Filial	As Numeric
	Local nSX5Key		As Numeric
	Local nTipo			As Numeric

	Local oDlg			As Object
	Local oOk			As Object
	Local oNo			As Object
	Local oQual			As Object

	Default lFinATipos	:= .F.

	aFwSX5 			:= FwGetSX5("05")
	aTipoBack		:= {}
	aTipos			:= {}

	cAlias			:= Alias()
	cCad			:= OemToAnsi(STR0024) //"Tipos de títulos"
	cCapital		:= ""
	cSX5Key			:= ""
	cVar			:= "  "

	lRunDblClick	:= .T.

	nChave			:= 2
	nOpca			:= 0
	nSeleciona		:= 1
	nSX5			:= 0
	nSX5Descri		:= 4
	nSX5Filial		:= 1
	nSX5Key			:= 3
	nTipo			:= 0

	oDlg			:= Nil
	oOk				:= LoadBitmap(GetResources(), "LBOK")
	oNo				:= LoadBitmap(GetResources(), "LBNO")
	oQual			:= Nil

	For nSX5 := 1 To Len(aFwSX5)
		cSX5Key := SubStr(aFwSX5[nSX5][nSX5Key], 1, 3)
		If !lFinATipos .And. cSX5Key == "PR "
			Loop
		EndIf
		cCapital := Capital(AllTrim(aFwSX5[nSX5][nSX5Descri]))

		AAdd(aTipos, {.T., cSX5Key + " " + IIf(Len(cCapital) > 50, SubStr(cCapital, 1, 50), cCapital + Space(50 - Len(cCapital)))})
	Next nSX5

	aTipoBack := AClone(aTipos)

	nOpca := 0

	DEFINE MSDIALOG oDlg TITLE cCad From 9, 0 To 35, 50 OF oMainWnd

	@0.5, 0.3 TO 13.6, 20.0 LABEL cCad OF oDlg
	@2.3,3 Say OemToAnsi("  ")
	@1.0,.7 LISTBOX oQual VAR cVar Fields HEADER "", OemToAnsi( STR0024 ) SIZE 150,170 ON DBLCLICK (aTipoBack := FA060Troca(oQual:nAt, aTipoBack), oQual:Refresh()) NOSCROLL //"Tipos de títulos"
	oQual:SetArray(aTipoBack)
	oQual:bLine := {|| {If(aTipoBack[oQual:nAt][1], oOk, oNo), aTipoBack[oQual:nAt][2]}}
	oQual:bHeaderClick := {|oObj, nCol| If(lRunDblClick .And. nCol == 1, AEval(aTipoBack, {|e| e[1] := !e[1]}), Nil), lRunDblClick := !lRunDblClick, oQual:Refresh()}

	DEFINE SBUTTON FROM 10  , 166  TYPE 1 ACTION (nOpca := 1, oDlg:End()) ENABLE OF oDlg
	DEFINE SBUTTON FROM 22.5, 166  TYPE 2 ACTION oDlg:End() ENABLE OF oDlg

	ACTIVATE MSDIALOG oDlg CENTERED

	If nOpca == 1
		FwFreeArray(aTipos)
		aTipos := AClone(aTipoBack)
	EndIf

	//Monta a string de tipos para filtrar o arquivo
	cTipos := ""
	For nTipo := 1 To Len(aTipos)
		If aTipos[nTipo][nSeleciona]
			cTipos += SubStr(aTipos[nTipo][nChave], 1, 3) + "/"
		EndIf
	Next nTipo

	FreeObj(oOk)
	FreeObj(oNo)

	FwFreeArray(aTipos)
	FwFreeArray(aTipoBack)
	FwFreeArray(aFwSX5)

	DbSelectArea(cAlias)

Return Nil

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGetSE5Seq

Retorna a última sequencia de baixa do SE5
Arquivo original: FINXFUN.PRX

@author    Marcos Berto
@since     16/01/13

@return cSeq 	- Última sequência de baixa
/*/
//------------------------------------------------------------------------------------------
Function FGetSE5Seq(cFil,cPrefixo,cNum,cParcela,cTipo,cCliFor,cLoja)

Local nTamSeq		:= TamSX3("FK1_SEQ")[1]
Local cSeq			:= Replicate("0",nTamSeq)
Local aAreaSE1		:= SE1->(GetArea())

Default cFil		:= ""
Default cPrefixo	:= ""
Default cNum		:= ""
Default cParcela	:= ""
Default cTipo		:= ""
Default cCliFor		:= ""
Default cLoja		:= ""

SE1->(dbSetOrder(1))
If SE1->(MSSeek(cFil+cPrefixo+cNum+cParcela+cTipo))
	cSeq := FaNxtSeqBx()
Endif

RestArea(aAreaSE1)
FwFreeArray(aAreaSE1)

Return cSeq


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SLDBCO

Retorna o Saldo Bancario em uma data .
Arquivo original: FINXFUN.PRX

@Author	Eduardo Riera
@since	12/03/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function SldBco(cBanco,cAgencia,cConta,dData,nMoeda,lLimite)
Local aArea     := { Alias() , IndexOrd() , Recno() }
Local aAreaSA6  := { SA6->(IndexOrd()), SA6->(Recno()) }
Local aBcoSA6   := {}
Local nSaldo    := 0
Local bCondSA6
Local nCntFor   := 0
Local nMaxFor   := 0
Local lFirst := .T.
Local nLimite := 0

lLimite := IIF(lLimite == NIL, .F., lLimite)

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Testa os parametros vindos do Excel                  ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cBanco   := If(Empty(cBanco),"",cBanco)
cAgencia := If(Empty(cAgencia),"",cAgencia)
cConta   := If(Empty(cConta),"",cConta)
cConta   := If(Empty(cConta),"",cConta)
dData    := If(Empty(dData),dDataBase,dData)
nMoeda      := If(Empty(nMoeda),1,nMoeda)
If ( ValType(cBanco)=="N" )
	cBanco := StrZero(cBanco,TamSX3("A6_COD")[1])
EndIf
If ( ValType(cAgencia)=="N" )
	cAgencia := StrZero(cAgencia,TamSX3("A6_AGENCIA")[1])
Else
	cAgencia := PadR(cAgencia,TamSX3("A6_AGENCIA")[1])
EndIf
If ( ValType(cConta)=="N" )
	cConta := StrZero(cConta,TamSX3("A6_NUMCON")[1])
Else
	cConta := PadR(cConta,TamSX3("A6_NUMCON")[1])
EndIf
If ( ValType(nMoeda)=="C" )
	nMoeda := Val(nMoeda)
EndIf
dData := DataWindow(dData)
If ( Upper(cBanco) $ "TODOS#ALL")
	cBanco := ""
EndIf
If ( Upper(cAgencia) $ "TODOS#ALL")
	cAgencia := ""
EndIf
If ( Upper(cConta) $ "TODOS#ALL")
	cConta := ""
EndIf

dbSelectArea("SA6")
dbSetOrder(1)
dbSeek(xFilial()+cBanco+cAgencia+cConta,.T.)
bCondSA6 := {|| !Eof() .And. xFilial("SA6")== SA6->A6_FILIAL .And.;
	(Empty(cBanco).Or.cBanco==SA6->A6_COD) .And.;
	(Empty(cAgencia).Or.cAgencia==SA6->A6_AGENCIA).And.;
	(Empty(cConta).Or.cConta==SA6->A6_NUMCON) }
While ( Eval(bCondSA6) )

	// Se considerar limite do chq especial para composicao do saldo
	If lLimite .and. lFirst
		nLimite := SA6->A6_LIMCRED
		lFirst := .F.
	Endif

	aadd(aBcoSA6,{ SA6->A6_COD , SA6->A6_AGENCIA , SA6->A6_NUMCON })
	dbSelectArea("SA6")
	dbSkip()
EndDo
nMaxFor := Len(aBcoSA6)
For nCntFor := 1 To nMaxFor
	nSaldo += RecSalBco(aBcoSa6[nCntFor,1],aBcoSa6[nCntFor,2],aBcoSa6[nCntFor,3],dData)
Next

If lLimite
	nSaldo += nLimite
Endif

dbSelectArea("SA6")
dbSetOrder(aAreaSA6[1])
dbGoto(aAreaSA6[2])

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])

Return(xMoeda(nSaldo,1,nMoeda,dData))


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ADMABRESMO

Retorna um array com as informacoes das filias das empresas (funções fc020Venda/fc020Compra/FLOJASIRRF).
Arquivo original: FINXFUN.PRX

@Author	Orizio
@since	22/01/2010
/*/
//-----------------------------------------------------------------------------------------------------
Static Function AdmAbreSM0()
	Local aArea			:= SM0->( GetArea() )
	Local aAux			:= {}
	Local aRetSM0		:= {}
	Local lFWLoadSM0	:= .T.
	Local lFWCodFilSM0 	:= .T.

	If lFWLoadSM0
		aRetSM0	:= FWLoadSM0()
	Else
		DbSelectArea( "SM0" )
		SM0->( DbGoTop() )
		While SM0->( !Eof() )
			aAux := { 	SM0->M0_CODIGO,;
						IIf( lFWCodFilSM0, FWGETCODFILIAL, SM0->M0_CODFIL ),;
						"",;
						"",;
						"",;
						SM0->M0_NOME,;
						SM0->M0_FILIAL }

			aAdd( aRetSM0, aClone( aAux ) )
			SM0->( DbSkip() )
		End
	EndIf

	RestArea( aArea )
Return aRetSM0


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINDPESQ

Retorna um array contendo todas as descricoes de indice para o alias solicitado. (FINA060/FINA061).
Arquivo original: FINXFUN.PRX

@Author	Pedro Pereira Lima
@since	04/08/2010
/*/
//-----------------------------------------------------------------------------------------------------
Function FIndPesq(cAliasPesq)
Local aArea := GetArea()
Local aRet  := {}

Default cAliasPesq := ""

If !Empty(cAliasPesq)
	SIX->(dbSetOrder(1))
	SIX->(DbSeek(cAliasPesq))
	While !SIX->(Eof()) .And. SIX->INDICE == cAliasPesq
		If cAliasPesq == "SE1"
			aAdd(aRet,{"Filial + " + SIX->DESCRICAO,1})
		Else
			aAdd(aRet,{SIX->DESCRICAO,1})
		EndIf
		SIX->(dbSkip())
	EndDo
EndIf

RestArea(aArea)

Return aRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINADTSLD

Retorna verdadeiro se existe saldo de adiantamento relacionado com pedido de compras/vendas.
Arquivo original: FINXFUN.PRX

@Author	Gustavo Henrique
@since	15/09/2011
/*/
//-----------------------------------------------------------------------------------------------------
Function FinAdtSld( cCart, cChave )

Local bChave
Local nSaldo	:= 0
Local aArea     := GetArea()
Local cFilFIE	:= xFilial( "FIE" )

If aAdianta == NIL
	aAdianta := ProtCfgAdt()
	bFilFIE := Iif(aAdianta[1,4],{|| FIE_FILORI==cFilAnt .Or. Empty(FIE_FILORI)},{||.T.})
	lAdComPart := aAdianta[1,5] .And. 'C' $ aAdianta[1,1]+aAdianta[1,2]+aAdianta[1,3]
Endif

If cCart == "P"
	FIE->( DBSetOrder( 3 ) )
	bChave := { || FIE->( cFilFIE + cCart + cChave == FIE_FILIAL + FIE_CART + FIE_FORNEC + FIE_LOJA + FIE_PREFIX + FIE_NUM + FIE_PARCEL + FIE_TIPO ) }
Else
	FIE->( DBSetOrder( 2 ) )
	bChave := { || FIE->( cFilFIE + cCart + cChave == FIE_FILIAL + FIE_CART + FIE_CLIENT + FIE_LOJA + FIE_PREFIX + FIE_NUM + FIE_PARCEL + FIE_TIPO ) }
EndIf

FIE->( MsSeek( xFilial( "FIE" ) + cCart + cChave ) )

// Percorre os pedidos relacionados ao adiantamento
Do While FIE->( ! Eof() .And. Eval( bChave ) )
	If FIE->(Eval(bFilFIE))
		nSaldo += FIE->FIE_SALDO
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se achou uma ocorrencia com saldo, nao precisa verificar as proximas ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nSaldo > 0
			Exit
		EndIf
	EndIf
	FIE->( DBSkip() )
EndDo

lRet := ( nSaldo > 0 )

RestArea( aArea )

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} TAMPARCELA

Verifica o tamanho do campo parcela e retorna valor desejado dependendo do tamanho da parcela.
Arquivo original: FINXFUN.PRX

@Author	Claudio D. de Souza
@since	29/05/2002
/*/
//-----------------------------------------------------------------------------------------------------
Function TamParcela(cCampo,uPar1,uPar2,uPar3)
Static cCampoAnt
Static aTamParc
// Carrega o tamanho do campo, somente quando este ainda não estiver carregado para
// evitar leitura do SX3 desnecessaria.
If cCampoAnt == Nil .Or. cCampoAnt != cCampo .Or. aTamParc == Nil
	aTamParc := TamSx3(Upper(cCampo))
	cCampoAnt := cCampo
Endif

Return If(aTamParc[1]==1,uPar1,If(aTamParc[1]==2,uPar2,uPar3))


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA080JUROS

Calcula juros de um determinado titulo.
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	06/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fa080Juros(nMoeda, nVlrTit, cAlias, dUltBaixa, nTxMoeda, nCasDec)

Local nAtraso 		:= 0
Local lRet 			:= .F.
Local cAliasAnt 	:= Alias()
Local nMVFINJRTP 	:= SuperGetMv("MV_FINJRTP",,1)
Local cTpDocJR		:= PadR("JR",TamSX3("FK2_TPDOC")[1])
Local cDataBase 	:= DtoS(dDataBase)

Default cAlias 		:= "SE2"
Default nMoeda 		:= 1
Default nVlrTit 	:= (cAlias)->E2_SALDO
Default dUltBaixa 	:= (cAlias)->E2_BAIXA
Default nTxMoeda 	:= 0
Default nCasDec  	:= 2

If Type("dBaixa") == "U"
	private dBaixa as date
	dBaixa := dDatabase
EndIf

nJuros := 0
dbSelectArea(cAlias)

If __lRpoR33 == NIL
	__lRpoR33 := GetRpoRelease() >= "12.1.033"
Endif

IF !(Empty(E2_VALJUR) .and. Empty(E2_PORCJUR))

	If Empty(dUltBaixa)
		If DataValida((cAlias)->E2_VENCTO,.T.) < dBaixa
			dVencto := (cAlias)->E2_VENCTO
		Else
			dVencto := DataValida((cAlias)->E2_VENCTO,.t.)
		Endif
	Else
		If DataValida((cAlias)->E2_VENCTO,.T.) < dUltBaixa
			dVencto := dUltBaixa
		Else
			dVencto := DataValida((cAlias)->E2_VENCTO,.t.)
		Endif
	Endif

	nAtraso := dBaixa - dVencto

	IF Dow((cAlias)->E2_VENCTO) == 1 .Or. Dow((cAlias)->E2_VENCTO) == 7
		IF Dow(dBaixa) == 2 .and. nAtraso <= 2
			nAtraso := 0
		EndIF
	EndIF
	nAtraso := IIF(nAtraso < 0, 0, nAtraso)

	If nAtraso != 0
		If nMVFINJRTP <> 1 .and. !Empty(E2_VALJUR) .and. !Empty(E2_PORCJUR)
			If nMVFINJRTP == 2    // soh juros
				nJuros := nVlrTit * (E2_PORCJUR * nAtraso)/100
			Else   //nMVFINJRTP == 3    ambos
				nJuros:=(E2_VALJUR * nAtraso) + (nVlrTit * (E2_PORCJUR*nAtraso)/100)
			EndIf
		Else  // soh taxa de permanencia

			If __lRpoR33		//Release 12.1.33 e posteriores FKS
				If FINFK2Atv(cAlias)
					IF !Empty((cAlias)->E2_VALJUR)
						lRet := .T.
					EndIf
				Endif
			Else
				dbSelectArea("SE5")
				dbSetOrder(2)

				cSeq := ""
				If SE5->(dbSeek(xFilial("SE5")+ cTpDocJR +(cAlias)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+cDataBase+E2_FORNECE+E2_LOJA)))

					While SE5->(!Eof()) .AND. xFilial("SE5")+ cTpDocJR +(cAlias)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+cDataBase+E2_FORNECE+E2_LOJA) ==;
							E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+cDataBase+E5_CLIFOR+E5_LOJA
						If E5_SITUACA <> "C"
							cSeq := E5_SEQ
						EndIf
						SE5->(DbSkip())
					End

					If !SE5->(dbSeek(xFilial("SE5")+PadR("JR",TamSX3("E5_TIPODOC")[1])+(cAlias)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+DtoS(dDataBase)+E2_FORNECE+E2_LOJA+cSeq))).Or.SE5->E5_SITUACA=="C"
						IF !Empty((cAlias)->E2_VALJUR)
							lRet := .T.
						Endif
					EndIf
				Else
					IF !Empty((cAlias)->E2_VALJUR)
						lRet := .T.
					Endif
				EndIf
			Endif

			//Calculo dos Juros
			If lRet
				nJuros := (cAlias)->E2_VALJUR * nAtraso
			ElseIf !Empty((cAlias)->E2_PORCJUR)
				nJuros := nVlrTit * ((cAlias)->E2_PORCJUR * nAtraso)/100
			Endif

		EndIf
		//Permite a alteracao dos Juros em Ponto de Entrada
		If ExistBlock("F080JUR")
			nJuros := ExecBlock("F080JUR",.f.,.f.)
		Endif

		If nJuros > 0 .And. (cAlias)->E2_MOEDA != nMoeda
			If (cAlias)->E2_MOEDA > 1 .And. nMoeda > 1
				nJuros := xMoeda(nJuros, (cAlias)->E2_MOEDA, nMoeda, dDataBase, nCasDec, (cAlias)->E2_TXMOEDA, nTxMoeda)
			ElseIf (cAlias)->E2_MOEDA > 1
				nJuros := xMoeda(nJuros, (cAlias)->E2_MOEDA, nMoeda, dDataBase, nCasDec, nTxMoeda, 0)
			Else
				nJuros := xMoeda(nJuros, (cAlias)->E2_MOEDA, nMoeda, dDataBase, nCasDec, 0, nTxMoeda)
			EndIf

			If nCasDec <= 2
				nJuros := Round(nJuros, 2)
			EndIf
		EndIf
	EndIf
EndIf

DbSelectArea(cAliasAnt)

Return nJuros

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINFK2Atv

Verifica se o título tem uma baixa ativa em uma determinada data.

Utilizada, por exemplo, para verificar se tenho ou não que calcular juros numa determinada baixa
Caso já tenha uma outra baixa parcial do título na data, não calcula
Caso não tenha uma outra baixa parcial do título na data, calcula

@Author	Mauricio Pequim Jr
@since	28/01/2021
/*/
//-----------------------------------------------------------------------------------------------------
Function FINFK2Atv(cAlias,dData)

Local lRet := .T.
Local cChaveFK7 As Character
Local cChaveTit As Character
Local cAliasFK2 As Character
Local cDataBase As Character

DEFAULT cAlias := ''
DEFAULT dData := dDataBase

//Dados da tabela auxiliar com o código do título a pagar
cChaveTit := xFilial("SE2", (cAlias)->E2_FILORIG) + "|" + (cAlias)->E2_PREFIXO + "|" + (cAlias)->E2_NUM     + "|" + (cAlias)->E2_PARCELA + "|" + ;
	              			(cAlias)->E2_TIPO     + "|" + (cAlias)->E2_FORNECE + "|" + (cAlias)->E2_LOJA
cChaveFK7 := FINGRVFK7( "SE2", cChaveTit )

cDataBase := DtoS(dData)

cAliasFK2 := ""

If __oPreparB == NIL

	cQuery 	:= "SELECT FK2_FILORI, FK2_IDFK2, FK2_SEQ FROM "+ RetSqlName("FK2") +" FK2 "
	cQuery 	+= "WHERE FK2_IDDOC = ? AND"
	cQuery 	+= " FK2_RECPAG = 'P' AND"
	cQuery 	+= " FK2_DATA = ? AND"
	cQuery 	+= " D_E_L_E_T_ = ' ' "

	cQuery	+= " AND NOT EXISTS( "
	cQuery	+= " SELECT FK2EST.FK2_IDDOC FROM " + RetSqlName("FK2") +" FK2EST"
	cQuery	+= " WHERE FK2EST.FK2_IDDOC = ? "
	cQuery	+= " AND FK2EST.FK2_SEQ = FK2.FK2_SEQ "
	cQuery	+= " AND FK2EST.FK2_TPDOC = 'ES' "
	cQuery	+= " AND FK2EST.D_E_L_E_T_ = ' ') "

	cQuery 	:= ChangeQuery(cQuery)
	__oPreparB:=FWPreparedStatement():New(cQuery)
Endif

__oPreparB:SetString(1,cChaveFK7)
__oPreparB:SetString(2,cDataBase)
__oPreparB:SetString(3,cChaveFK7)

cQuery := __oPreparB:GetFixQuery()

cAliasFK2 := mpsysopenquery(cQuery)

IF !( cAliasFK2 )->(Eof())
	lRet := .F.
Endif

( cAliasFK2 )->( dbCloseArea() )

dbSelectArea(cAlias)

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FADESCFIN

Calcula o desconto Financeiro de um determinado titulo.
Arquivo original: FINXFUN.PRX

@Author	Eduardo Riera
@since	24/11/1997
/*/
//-----------------------------------------------------------------------------------------------------
Function FaDescFin(cAliasSE1,dDtBaixa,nValor,nMoeda,lVerBxado,lTemGEM)
Local aArea     := GetArea()
Local nDesconto := 0
Local dDtLimite := 0
Local nPosData  := 0
Local nJuros	:= 0
Local nDias
Local nVPA

Default lF070DSCF	:= ExistBlock("F070DSCF")
Default lF070DES	:= ExistBlock("F070DES")
Default lDiaDesc	:= SuperGetMv("MV_DIADESC",.F.,.F.)
Default cAliasSE1	:= "SE1"
Default lVerBxado	:= .F. //Quando .T., devera retornar o valor do desconto financeiro de titulos baixados.
Default lTemGEM		:= ExistTemplate("GEMDESCTO") .And. HasTemplate("LOT")

If lTemGEM
	nCM1		:= iIf(Type("nCM1")     != "N",0,nCM1)
	nProRata	:= iIf(Type("nProRata") != "N",0,nProRata)
EndIf

If __cMVDESCFIN	== Nil
	__cMVDESCFIN := SuperGetMV("MV_DESCFIN",,"I")
EndIf
If __cMVDTDESCF	== Nil
	__cMVDTDESCF:= SuperGetMv("MV_DTDESCF")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso a baixa seja parcial, o desconto ser  concedido totalmente na pri-³
//³ meira baixa.                                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cAliasSE1)
If Empty ((cAliasSE1)->E1_BAIXA) .Or. lVerBxado .Or.(__cMVDESCFIN =="P")
	nPosData := FieldPos(&(__cMVDTDESCF))
	dDtBaixa := If(Empty(dDtBaixa),dDataBase,dDtBaixa)
	nMoeda   := If(Empty(nMoeda),1,nMoeda)
	nValor   := If(Empty(nValor),(cAliasSE1)->E1_VALOR,nValor)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula a Data Limite para desconto do Titulo                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty((cAliasSE1)->E1_LIDESCF) // Se existir a data limite para pagto. com desconto, apos o
													// vencto. do titulo, utiliza esta data.
		dDtLimite := (cAliasSE1)->E1_LIDESCF // Data fixa
	Else
		If ( nPosData == 0 )
			dDtLimite := (cAliasSE1)->E1_VENCREA - (cAliasSE1)->E1_DIADESC
		Else
			dDtLimite := FieldGet(nPosData) - (cAliasSE1)->E1_DIADESC
		Endif
	EndIf
	If lDiaDesc
		dDtLimite := DataValida(dDtLimite,.T.)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula o Valor do Desconto do Titulo                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF (cAliasSE1)->E1_TIPODES $ " 1" // Desconto fixo ate a data limite
		If ( !Empty(dDtLimite) .And. dDtBaixa <= dDtLimite ) .Or.;
			(AllTrim((cAliasSE1)->E1_ORIGEM) $ 'S|L|T' .And. (cAliasSE1)->E1_IDLAN > 0)

			If FwIsInCallStack("TK271CallCenter")
				nDesconto := (cAliasSE1)->E1_SALDO * ((cAliasSE1)->E1_DESCFIN / 100 )
				If 	(cAliasSE1)->(FieldPos("E1_DESCJUR")) > 0
					nJuros 		:= nValor - (cAliasSE1)->E1_SALDO
					nDesconto	+= nJuros * ((cAliasSE1)->E1_DESCJUR / 100 )
				EndIf
			ElseIF FUNNAME()=="FINR130" .AND. (cAliasSE1)->E1_DESCONT<> 0 .AND. (cAliasSE1)->E1_DESCFIN == 0
				nDesconto:=0
			Else
				nDesconto := nValor * ((cAliasSE1)->E1_DESCFIN / 100 )
			EndIf
		Endif
	ElseIf (cAliasSE1)->E1_TIPODES == "2"	// Desconto por dia de antecipacao
		If ( nPosData == 0 )
			nDias := (cAliasSE1)->E1_VENCREA - dDtBaixa
		Else
			nDias := FieldGet(nPosData) - dDtBaixa
		Endif
		If nDias > 0
			// Calcula o novo valor da prestacao
			nVPA := nValor / (((1+((cAliasSE1)->E1_DESCFIN / 100 )))^(nDias/30))
			// Calcula o desconto
			nDesconto := nValor - nVPA
		Endif
	EndIf
	If ( nDesconto > nValor )
		nDesconto := nValor
	EndIf
	nDesconto := Round(NoRound(xMoeda(nDesconto,(cAliasSE1)->E1_MOEDA,nMoeda,,3),3),2)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PONTO DE ENTRADA F070DES                                      ³
	//³ Recalculo do desconto financeiro.                          	  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF lF070DES
		nDesconto := ExecBlock("F070DES",.F.,.F.,nDesconto)
	EndIf

EndIf

//
// Template GEM
//
// Executa os calculos das variaveis private:
//		nCM1
//		nProRata
//
If lTemGEM
	nDesconto := ExecTemplate("GEMDESCTO",.F.,.F.,{cAliasSE1 ,dDatabase ,nDesconto ,(cAliasSE1)->E1_BAIXA ,(cAliasSE1)->E1_SALDO})
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PONTO DE ENTRADA F070DES                                      ³
//³ Recalculo do desconto financeiro.                          	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF lF070DSCF
	nDesconto := ExecBlock("F070DSCF",.F.,.F.,nDesconto)
EndIf

RestArea(aArea)
Return(nDesconto)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA171CALC

Calcula o Valor Atual da Aplicacao/Emprestimo Financeiro.
Arquivo original: FINXFUN.PRX

Parametro
Deve estar posicionado no SEH
ExpD1 : Data do Saldo
ExpN2 : Moeda do Saldo
ExpL3 : Considera data de resgate
ExpN3 : Valor da Moeda do Saldo
ExpD5 : Ultima Apropriacao
ExpN4 : Valor da cota anterior
ExpN5 : Valor da cota atual
ExpN6 : Valor do resgate
ExpL1 : Por Filial/Empresa


@Author	Eduardo Riera
@since	01/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa171Calc(	dDtSaldo, nSaldo, lResgate, nVlMoeda, dUltApr, nCotaAnt, nCotaAtual,;
					nVlResgate, lFilial, lDeduzIR, nTaxaIrf, lFinr820, dDtValida, nTxOut, nVlCotaIR )

LOCAL aRetorno	:= {}
LOCAL aAglutina	:= { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
LOCAL aArea		:= { Alias() , IndexOrd() , Recno() }
LOCAL aAreaSEH	:= { SEH->(IndexOrd()) , SEH->(Recno()) }
LOCAL cNumero	:= SEH->EH_NUMERO
LOCAL nCntFor	:= 0
LOCAL nCntFor2	:= 0
LOCAL nMaxFor	:= 0
Local lL11033	:= SuperGetMv("MV_L11033",,.F.)

Default lFilial		:= .T.
Default lDeduzIR	:= .T.
Default lFinr820	:= .F.
Default dDtValida	:= CToD(" / / ")
Default nTxOut		:= 0

nCotaAnt		:= Iif(nCotaAnt==Nil,0,nCotaAnt)
nCotaAtual		:= Iif(nCotaAtual==Nil,0,nCotaAtual)
nVlResgate		:= Iif(nVlResgate==Nil,0,nVlResgate)
dbSelectArea("SEH")

If lFilial
	dbSetOrder(1)
	If ( SEH->EH_REVISAO !="01" )
		dbSeek(xFilial("SEH")+SEH->EH_NUMERO)
	EndIf
Endif

While ( !Eof() .And. If(lFilial, xFilial() == SEH->EH_FILIAL, .T.) .And.;
		SEH->EH_NUMERO == cNumero )
	If ( SEH->EH_APLEMP == "APL" )
			aAglutina := Fa171CalAp(dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,nCotaAnt,;
								 	   nCotaAtual,nVlResgate,,lFilial,,lDeduzIR,nTaxaIrf,lFinr820,dDtValida,nTxOut,nVlCotaIR)
	Else
		If lL11033
			aAglutina := Fa171CalEp(dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,lFilial, lDeduzIR, nTaxaIrf)
		Else
			aAglutina := Fa171CalEp(dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,lFilial)
		EndIf
	EndIf
	If ( !Empty(aRetorno) )
		nMaxFor := Len(aAGlutina)
		For nCntFor := 1 To nMaxFor
			If ( SEH->EH_APLEMP == "EMP" )
				For nCntFor2 := 1 To Len(aAGlutina[nCntFor])
					aRetorno[nCntFor][nCntFor2] += aAglutina[nCntFor][nCntFor2]
				Next
			Else
				aRetorno[nCntFor] += aAglutina[nCntFor]
			Endif
		Next nMaxFor
	Else
		aRetorno := aAglutina
	EndIf
	dbSelectArea("SEH")
	dbSkip()
EndDo

dbSelectArea("SEH")
dbSetOrder(aAreaSEH[1])
dbGoto(aAreaSEH[2])

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])

Return ( aRetorno )


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA171CALAP

Calcula o Valor da Aplicacao Financeira  (Fa171Calc).
Arquivo original: FINXFUN.PRX

Parametro
Deve estar posicionado no SEH
ExpD1 : Data do Saldo
ExpN2 : Moeda do Saldo
ExpL3 : Considera data de resgate
ExpN4 : Valor da cota anterior
ExpD5 : Data da Ultima apropriacao
ExpN6 : Valor da Ultima cota registrada
ExpL4 : Por Filial/Empresa

@Author	Eduardo Riera
@since	30/03/1998
/*/
//-----------------------------------------------------------------------------------------------------
Static Function Fa171CalAp(	dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,nCotaAnt,nCotaAtual,;
										nVlResgate,nVlrCota,lFilial,nTaxa,lDeduzIR,nTaxaIrf,lFinr820, dDtValida, nTxOut, nVlCotaIR)
Local cDiasUtCo as Character
Local nDiasCalc as Numeric
Local nDiasCor	as Numeric
Local dDtCont	as Numeric
Local nDiaCont	as Numeric
Local nDiasAno	as Numeric
Local nQtdCota  as Numeric

Local aArea			:= GetArea()
Local dDtCalculo	:= DataValida(SEH->EH_DATA,.T.)
Local nPosMoeda		:= SM2->(FieldPos("M2_MOEDA"+AllTrim(Str(SEH->EH_MOEDA,2))))
Local nFatorDia		:= 1 // Rentabilidade no Dia
Local nFatorAtu		:= 1 // Rentabilidade atual
Local nVlrAplAnt	:= 0
Local nVlrAplAtu	:= 0 // Valor da Aplicacao no Mes
Local nJurAplAtu	:= 0 // Juros da Aplicacao no Mes
Local nIrfAplAtu	:= 0 // I.R.  da Aplicacao no Mes
Local nIofAplAtu  	:= 0 // IOF sobre os rendimentos da aplicação
Local lClsIof   	:= SEH->EH_CLSIOF == "1"
Local lRetorna      := .F.
Local nProporcao	:= 0
Local dData			:= Ctod("")
Local nAjVarCab		:= GetMv("MV_APLVCAB")
Local nUltCota		:= 0
Local nRdBruto                  // Redimento bruto
Local nIRRdBruto                // Ir sobre o rendimento bruto
Local nVlLiquido                // Valor liquido subtraindo o Ir sobre o rendimento bruto
Local nDelta                    // Aliquota apurado entre os valores das cotas
Local nBaseCalc                 // Base de calculo para o valor do Ir
Local nResgBruto                // Resgate bruto
Local nSldAplicado				// Saldo a ser aplicado
Local nDias			:= IF(FwIsInCallStack("FINR820"),(dDTsaldo - SEH->EH_DATA),(dDataBase - SEH->EH_DATA))
Local cTabIof		:= "A0"
Local cFilAp  		:= If(lFilial, xFilial(), SEH->EH_FILIAL)
Local nTaxaSEI		:= 0
Local cBaseCdi		:= GetMv("MV_BASECDI",,"2") // 1-Base mensal, 2-Base Anual
Local nRendAprop	:= 0
Local nIRAprop		:= 0
Local dFerMunic		:= Ctod("")
Local lFerMunic		:= .F.
Local cDate			:= SET(_SET_DATEFORMAT)
Local aSA6          := SA6->(GetArea())
Local nQtdCotas		:= 0
Local nRendimento	:= 0 // Valor do rendimento proporcional ao resgate
Local dDtCota
Local nRdMes		:= 0
Local nRdMesCC		:= 0
Local aTabIrf		:= {{ 180, 22.5 },{ 360, 20.0 },{ 720, 17.5 },{ 1000000, 15.0 }}
Local nDiasCTB		:= GetNewPar("MV_DIASCTB", 360) //Quantidade de dias para o ano contábil
Local nFatorUm		:= DEC_CREATE("1",64,0)
Local nResultParc	:= DEC_CREATE("1",64,16)
Local nValor1		:= 0
Local nValor2		:= 0
Local nFormula1		:= 0
Local nFormula2		:= 0
Local nDec1			:= 0
Local nDec2			:= 0
Local lAplImune		:= SuperGetMv("MV_APLIMUN",,"1") $ "2|3"
Local lZeraIRApr	:= .F.
Local nRendAux		:= 0
Local lAniverMes	:= .T.
Local nPeriodo		:= 0
Local nQtdMeses		:= 0
Local lNewCalc		:= TableInDic('FO3')
Local aAnivCP		:= {}
Local nX			:= 0
Local aTaxas		:= {}
Local nSaldoCP		:= 0
Local lOldCP		:= .F.
Local nTaxaCP		:= 0
Local oFerMunic		:= FerMunic()
Local oVal			:= NIL
Local aUltComeCotas	:= {}
Local nVlrUltCome	:= 0
Local lF171RdMn		:= Iif(ExistBlock("F171RDMN"),.T.,.F.)
Local lF171RdBr		:= Iif(ExistBlock("F171RDBR"),.T.,.F.)
local fAux			:= DEC_CREATE("1",64,16)
Local lIsAprIrf     := AllTrim(FunName()) == "FINA183"
Local lFGetOutAp	As Logical
Local nAno 			As Numeric
Local nIrAcum    	As Numeric
Local nRendAcum    	As Numeric
Local lRepoIR    	As Logical
Local lRndMensal  	As Logical
Local nRendCC		As Numeric
Local nVlrAtuCC		As Numeric
Local nIRCC			As Numeric
Local nRedMesAtu	As Numeric

Default nVlrCota	:= 0
Default nVlCotaIR	:= 0
Default nTaxa		:= SEH->EH_TAXA
// A taxa de IR sera: Se o campo estiver vazio, utiliza a tabela AR se ela existir ou a tabela acima caso contrario.
// Se o campo de TAXA de IR estiver preenchido no cadastro, utiliza esta taxa.
Default nTaxaIrf	:= TxIRResgate( nDias , aTabIrf )
Default lDeduzIR	:= .T.
Default lFinr820	:= .F.

If Empty(dDtValida)
	dDtValida := dDtSaldo
EndIf

nCotaAnt	 := Iif(nCotaAnt==Nil,0,nCotaAnt)
nCotaAtual	 := Iif(nCotaAtual==Nil,0,nCotaAtual)
nVlMoeda  	 := Iif(nVlMoeda==Nil,0,nVlMoeda)
nVlResgate	 := Iif(nVlResgate==Nil,0,nVlResgate)
nRdBruto	 := 0
nIRRdBruto	 := 0
nVlLiquido	 := 0
nDelta		 := 0
nBaseCalc	 := 0
nResgBruto	 := 0
nSldAplicado := 0
cDiasUtCo	 := SuperGetMV("MV_APLUTCO",,'1') // 1 - Dias Corridos, 2 - Dias Uteis
nDiasCor	 := 0
nQtdCota     := 0
lFGetOutAp	 := FwIsInCallStack("FINA181") .And. FindFunction("FGetOutAp")
nOutAplAtu	 := 0
nVlrRegAtu	 := 0
nIrAcum  	 := 0
aRet 		 := {}
nRendAcum	 := 0
lRepoIR		 := .F.
nRendCC		 := 0
nVlrAtuCC	 := 0
nIRCC		 := 0
nRedMesAtu	 := 0
lRndMensal   := SuperGetMv("MV_RENAPL4",,"1") == "2"

If lNewCalc
	If AllTrim(SEH->EH_TIPO) != "CP"
		lNewCalc := .F.
	EndIf
EndIf

//Ponto de entrada para validacao do dias CTB
If ExistBlock("FADIACTB")
	nDiasCTB := ExecBlock("FADIACTB",.F.,.F.,{nDiasCTB})
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calcula a data de Ultima apropriacao                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( dUltApr != Nil )
	DbSelectArea("SEI")
	DbSetOrder(1)
	If lResgate
		DbSeek(cFilAP+SEH->EH_APLEMP+SEH->EH_NUMERO+SEH->EH_REVISAO)
		While ( !Eof() .And. SEI->EI_FILIAL == cFilAP .And.;
				SEI->EI_APLEMP  == SEH->EH_APLEMP .And.;
				SEI->EI_NUMERO  == SEH->EH_NUMERO .And.;
				SEI->EI_REVISAO == SEH->EH_REVISAO )
			If ( SEI->EI_DATA <= dUltApr .And. SEI->EI_STATUS!="C" )
				dData    := Max(dData,SEI->EI_DATA)
				nTaxaSEI := SEI->EI_TAXA
				nUltCota := SEI->EI_VLRQTA
			EndIf
			dbSelectArea("SEI")
			dbSkip()
		EndDo
	EndIf

	If lFinr820
		If ( Empty(dData) .Or.  dDtSaldo < dData .Or. dDtSaldo > SEH->EH_DATARES )
			dData := dDtCalculo
		Else
			aRet   := Fa171CalAp(dData,SEH->EH_SALDO,lResgate,,,,,,, lFilial,nTaxaSEI)
			nSaldo := aRet[1]
			If ( dUltApr != Nil .And. dDtSaldo >= dUltApr )
				Return(aRet)
			EndIf
		EndIf
	Else
		If ( Empty(dData) )
			dData  := dDtCalculo
		Else
			nSaldo := Fa171CalAp(dData,SEH->EH_SALDO,lResgate,,,,,,, lFilial,nTaxaSEI)[1]
		EndIf
	EndIf

EndIf

dUltApr    := If(Empty(dData),dUltApr,dData)
dDtCalculo := If(Empty(dUltApr),dDtCalculo,dUltApr)
dDtSaldo   := If(Empty(dDtSaldo),dDataBase,dDtSaldo)
nSaldo     := If(Empty(nSaldo ) ,SEH->EH_SALDO,nSaldo)
lResgate   := If(lResgate==Nil,.F.,lResgate)

dbSelectArea("SEH")
If ( dDtSaldo == SEH->EH_DATARES .Or.;
		Empty(SEH->EH_DATARES) .Or.;
		lResgate .Or.;
		(!Empty(SEH->EH_DATARES) .and. nSaldo > 0))
	Do Case
	Case !Empty(SEH->EH_FORMULA)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ A formula deve utilizar as variaveis PRIVATES dFormula,nFormu-³
		//³ la e lFormula para calcular o multiplicador da aplicacao.     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dFormula  := dDtSaldo
		nFormula  := nSaldo
		lFormula  := lResgate
		nFatorAtu := Formula(SEH->EH_FORMULA)

	Case SEH->EH_TIPO $ GETMV("MV_APLCAL1") .And. !lNewCalc
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo da Aplicacao pelo CDI diario. A taxa informado refe-  ³
		//³ re-se ao %do valor do CDI que o banco paga pela aplicacao.    ³
		//³ Para uma melhor entendimento a taxa e' um percetual sobre uma ³
		//³ moeda cadastrada, sendo que o calculo e' atualizado dia a dia.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		/*
		Metodologia de calculo acumulado

		O calculo do DI-CETIP acumulado entre datas eh efetuado atraves da seguinte formula:
		    n
		C = ä  (1+TDIk x (p / 100)), onde:
		    k-1

		C -  Produtorio das taxas DI-CETIP Over com uso do percentual destacado, da data inicial (inclusive) ate a data final (exclusive), calculado com arredondamento de 8 (oito) casas decimais.
		n -  Numero total de taxas DI-CETIP Over, sendo "n" um numero inteiro.
		p -  Percentual destacado para a remuneracao, informado com 4 (quatro) casas decimais.
		TDIk- Taxa DI-CETIP Over, expressa ao dia, calculada com arredondamento de 8 (oito) casas decimais.

		--------------------------------------------

		Expressao de TDIk ate 31/12/1997

		TDIk = DIk / 3000, onde: k = 1, 2, ..., n

		--------------------------------------------

		Expressao de TDIk a partir de 01/01/1998

		TDIk = (((DIk / 100) + 1) ^(1/252)) - 1, onde: k = 1, 2, ..., n


		DIk - Taxa DI-CETIP Over, informada com 2 (duas) casas decimais.

		Observacoes:

		1)    O fator resultante da expressao eh considerado com 16 (dezesseis) casas sem arredondamento.

		2)    Efetua-se o produtorio dos fatores diarios , sendo que a cada fator diario acumulado, trunca-se o resultado com 16 (dezesseis) casas decimais e
				aplica-se o proximo fator diario, assim por diante ate o ultimo fator diario considerado.

		3)    Uma vez os fatores diarios estando acumulados como descrito acima, considera-se o fator resultante C com 8 (oito) decimais com arredondamento.
		*/
		nAno := Year(dDtCalculo)
		While dDtCalculo < dDtValida

			If Year(dDtCalculo) - nAno > 1
				nAno := Year(dDtCalculo)
				CleanFeriados()
			Endif

			dbSelectArea("SM2") // Cadastro de Moedas
			dbSetOrder(1)
			dbSeek( dDtCalculo )
			If ( Found() )

				nFatorDia := DEC_CREATE("1",64,16)

				If (cBaseCdi=="1") .Or. dDtCalculo <= Ctod("31/12/1997") // Ate 31/12/1997 a taxa do DI era divulgada ao mes, depois a taxa comecou a ser divulgada ao ano.

					nFormula1 := SEH->EH_TAXA/100 //Percentual destacado - Precisao 4
					nFormula2 := SM2->(FieldGet(nPosMoeda))/3000 ////TDIk - Precisao 8

				Else

					nFormula1 := SEH->EH_TAXA/100 //Percentual destacado - Precisao 4

					nValor1 := (1+(SM2->(FieldGet(nPosMoeda))/100))
					nValor2 := (1/252)

					nFormula2 := (nValor1 ^ nValor2) - 1   //TDIk - Precisao 8

				Endif

				nDec1       := DEC_CREATE(Str(nFormula1),64,4)
				nDec2       := DEC_CREATE(Str(nFormula2),64,8)

				nFatorDia   :=  DEC_MUL(nDec1,nDec2)
				nFatorDia   :=  DEC_RESCALE(nFatorDia,16,2) // Produtorio das taxas (C) - Precisao 16

				nFatorDia   :=  DEC_ADD(nFatorUm,nFatorDia) // Soma 1 no Produtorio das taxas (C)

				nResultParc := DEC_MUL(nFatorDia,nResultParc)
				nResultParc := DEC_RESCALE(nResultParc,16,2) // Produtorio das taxas (C) - Precisao 16
			EndIf

			/*###############################
			* VALIDAÇÃO FERIADO MUNICIPAL   *
			################################*/
			SET(_SET_DATEFORMAT, "DD/MM/YY")

			lFerMunic := .F.
			dFerMunic := dDtCalculo+1

			// Deixa a data de verificação de feriado municipal com o próximo dia útil
			While (DOW(dFerMunic) == 1 .Or. DOW(dFerMunic) == 7)
				dFerMunic++
			EndDo

			If !Empty(oFerMunic)
				If !HMGet(oFerMunic,xFilial("SX5")+SubSTR(DTOC(dFerMunic),1,8)+"M",oVal)
					If HMGet(oFerMunic,xFilial("SX5")+(SubSTR(DTOC(dFerMunic),1,5)+"   "+"M"),oVal)
						lFerMunic := .T.
					Endif
				Else
					lFerMunic := .T.
				Endif
			Endif

			SET(_SET_DATEFORMAT, cDate)

			If lFerMunic // FERIADO MUNICIPAL É CONSIDERADO NO CALCULO
				dDtCalculo := dFerMunic
			Else
				dDtCalculo := DataValida(dDtCalculo+1,.T.)
			EndIf

		EndDo

		//Fator resutante - Precisao 8
		nResultParc := DEC_RESCALE(nResultParc,8,0)
		nFatorAtu   := Val(cValToChar(nResultParc)) //Transforma para numerico

		If ( nFatorAtu == 0 )
			nFatorAtu := 1
		EndIf

	Case SEH->EH_TIPO $ GETMV("MV_APLCAL2") .And. !lNewCalc
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo da Aplicacao pela formula de juros composto diario    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( dDtCalculo <= dDtSaldo )
			nFatorDia := NoRound(nTaxa/100, DECIMALDECALCULO )+1
			lAniverMes := Alltrim(SEH->EH_TIPO) $ "CP"
			If lAniverMes
				nPeriodo++
				While (dDtSaldo >= Monthsum(dDtCalculo,nPeriodo))
					nPeriodo++
					nQtdMeses++
				EndDo
				if ValType(nFatorDia) == "F"
					fAux := (nQtdMeses/12)
					nFatorAtu := NoRound( DEC_POW( nFatorDia , fAux), DECIMALDECALCULO )
				else
					nFatorAtu := NoRound(nFatorDia**(nQtdMeses/12), DECIMALDECALCULO )
				endIf
			Else
				nDiasCalc 	  := dDtSaldo-dDtCalculo
				nDiasAno	  := nDiasCTB

				If cDiasUtCo == '2' //1 - Dias Corridos, 2 - Dias Uteis
					nDiasCor  := dDtSaldo-dDtCalculo
					nDiasCalc := 0
					dDtCont   := dDtCalculo
					nDiasAno  := 252

					// Se existe data de vencimento no CDB deve considerar todo o periodo do contrato
					// o laco nao considera a data de inclusao
					If !Empty(SEH->EH_DATVENC) .And. SEH->EH_DATVENC >= dDtSaldo
						If dDtCont == DataValida(dDtCont,.T.)
							nDiasCalc ++
						EndIf
					EndIf

					For nDiaCont := 1 To nDiasCor
						dDtCont ++
						If dDtCont == DataValida(dDtCont,.T.)
							nDiasCalc ++
						EndIf
					Next nDiaCont
				EndIf
				if ValType(nFatorDia) == "F"
					fAux := ((nDiasCalc)/nDiasAno)
					nFatorAtu := NoRound( DEC_POW(nFatorDia , fAux) , DECIMALDECALCULO )
				else
					nFatorAtu := NoRound(nFatorDia**((nDiasCalc)/nDiasAno), DECIMALDECALCULO )
				endIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Efetua a Convercao Monetaria                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF ( SEH->EH_MOEDA >= 2 )
				nFatorAtu := NoRound(nFatorAtu/RecMoeda(DataValida(dDtCalculo-nAjVarCab,.F.),SEH->EH_MOEDA)*;
					RecMoeda(DataValida(dDtSaldo-nAjVarCab,.F.),SEH->EH_MOEDA), DECIMALDECALCULO )
			Else
				nFatorAtu := NoRound(nFatorAtu, DECIMALDECALCULO )
			EndIf
		Else
			nFatorAtu := 0
		EndIf
		If ( nFatorAtu == 0 )
			nFatorAtu := 1
		EndIf
	Case SEH->EH_TIPO $ GETMV("MV_APLCAL3") .And. !lNewCalc
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo da Aplicacao pela formula de juros simples mensal     ³
		//³ Dias Corridos.                                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( nDias > 0 )
			nFatorDia := NoRound(nTaxa/100, DECIMALDECALCULO )
			lAniverMes := Alltrim(SEH->EH_TIPO) $ "CP"
			If lAniverMes
				nPeriodo++
				While (dDtSaldo >= Monthsum(dDtCalculo,nPeriodo))
					nPeriodo++
					nQtdMeses++
				EndDo
				nFatorAtu := NoRound(nFatorDia/12*nQtdMeses,DECIMALDECALCULO )+1
			Else
				nFatorAtu := NoRound(nFatorDia/nDiasCTB*nDias,DECIMALDECALCULO )+1
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Efetua a Convercao Monetaria                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			// posiciona o banco da aplicação para verificar a moeda dele
			SA6->(DbSetOrder(1))
			SA6->(DbSeek(SEH->(xFilial("SA6")+EH_BANCO+EH_AGENCIA+EH_CONTA)))

			// encontrou no arquivo e moedas são diferentes verifica variacao cambial
			IF ( SA6->(!Eof()) .And. SEH->EH_MOEDA != SA6->A6_MOEDA )
				nFatorAtu := NoRound(nFatorAtu/RecMoeda(DataValida(dDtCalculo-nAjVarCab,.F.),SEH->EH_MOEDA)*;
					RecMoeda(DataValida(dDtSaldo-nAjVarCab,.F.),SEH->EH_MOEDA), DECIMALDECALCULO )
			Else
				nFatorAtu := NoRound(nFatorAtu, DECIMALDECALCULO )
			EndIf
		Else
			nFatorAtu := 0
		EndIf
		If ( nFatorAtu == 0 )
			nFatorAtu := 1
		EndIf
	OtherWise
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo da Aplicacao por valores fixos por cota, ou seja nao  ³
		//³ ha taxa pre-fixada. Normalmente utilizado para Fundos ou acoes³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SE9")
		DbSetOrder(1)
		DbSeek(cFilAP+SEH->EH_CONTRAT+SEH->EH_BCOCONT+SEH->EH_AGECONT)

		nProporcao := 0
		nFatorAtu  := 1

	EndCase
Else
	nFatorAtu := 1
EndIf

If SEH->EH_TIPO $ (GetMv("MV_APLCAL1")+GetMv("MV_APLCAL2")+GetMv("MV_APLCAL3")) .And. !lNewCalc
	nVlrAplAtu := Round(Round(nSaldo*nFatorAtu,TamSX3("EH_SALDO")[2]+1),TamSX3("EH_SALDO")[2])
	If ( nVlrAplAtu <= 0.01 .And. SEH->EH_GARANTE=="S" )
		nVlrAplAtu := nSaldo
	EndIf
	If ( nFatorAtu != 0 )
		nJurAplAtu := nVlrAplAtu - nSaldo
	EndIf
	If !Empty(SEH->EH_TAXAIOF) .Or. SEH->EH_TIPO $ GetMv("MV_APLCAL3")
		nIofAplAtu := NoRound(nJurAplAtu*SEH->EH_TAXAIOF/100,TamSX3("EH_SALDO")[2])
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcula o IOF conforme a tabela cadastrada no SX5, ou a taxa de IOF cadastrada na aplicacao          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nDias := (IIf(!lFinr820,dDataBase,dDtSaldo) - SEH->EH_DATA) // Data da Inclusao da Aplicacao
		If ABS(nDias) <= 29 .AND. !EMPTY(cTabIOF) .And. nDias > 0
  			nIofAplAtu := NoRound((Round(NoRound((nJurAplAtu),3),2) * VAL(TABELA(cTabIof, STRZERO(nDias,2)))/100),TamSX3("EH_SALDO")[2])
		Endif

		If SEH->EH_TIPO == "CDI" .and. lClsIof
			nIofAplAtu := 0
			lRetorna := .T.
		EndIf
	Endif

	//Para aplicacoes do Tipo - CP (Caderneta de Poupança), nao existe incidencia de IR
	If (Alltrim(SEH->EH_TIPO) $ "CP")
		nIrfAplAtu	:= 0
	Else
		nIrfAplAtu	:= NoRound((nJurAplAtu-nIofAplAtu)*nTaxaIrf/100,TamSX3("EH_SALDO")[2])
	EndIf

	nOutAplAtu	:= NoRound(nJurAplAtu*SEH->EH_IMPOSTO/100,TamSX3("EH_SALDO")[2])

	If lFGetOutAp .And. Empty(nOutAplAtu)
		FGetOutAp(@nOutAplAtu)
	ElseIf !Empty(nTxOut)
		nOutAplAtu	:= nTxOut
	EndIf
	If lAplImune
		FA181Imune(@nIofAplAtu,@nIrfAplAtu)
	EndIf

	nVlrRegAtu	 := ( nVlrAplAtu-nIrfAplAtu-nIofAplAtu-nOutAplAtu )
	nRdBruto	 := 0
	nIRRdBruto	 := 0
	nVlLiquido	 := 0
	nDelta		 := 0
	nBaseCalc	 := 0
	nResgBruto	 := 0
	nSldAplicado := 0
Else
	If lNewCalc
		//-------------------------------------------------
		//Efetuo o cálculo da Caderneta de Pupança
		//utilizando os índices cadastrados na tabela FO3
		//-------------------------------------------------

		//Para cadernetas de poupança que tenham sido abertas até dia 03/05/2012, o rendimento será
		//sobre TR + o percentual emitido pelo BCB
		//Para cadernetas de poupança que tenham sido abertas a partir do dia 04/05/2012, o rendimento será de
		//TR + 0,5% caso a Taxa Meta Selic seja igual ou superior à 8,5%
		//Caso a Taxa Meta Selic seja inferior à 8,5%, o rendimento será de TR + 70% da Taxa Meta Selic
		If SEH->EH_DATA <= CtoD( '03/05/2012' )
			lOldCP := .T.
		EndIf

		aAnivCP := RetAnivCP( SEH->EH_DATA, dDtSaldo )

		FO3->( DbSetOrder( 1 ) )
		For nX := 1 To Len( aAnivCP )
			If FO3->( DbSeek( xFilial( 'FO3' ) + aAnivCP[nX] ) )
				aAdd( aTaxas, { FO3->FO3_DATA,;
								FO3->FO3_IDXCPA,;
								FO3->FO3_IDXCPN,;
								FO3->FO3_IDXSLM,;
								FO3->FO3_PERC,;
								FO3->FO3_IDXTR } )
			EndIf
		Next nX

		nSaldoCP := nSaldo

		For nX := 1 To Len( aTaxas )
			If lOldCP
				nTaxaCP := aTaxas[nX][2]
			Else
				//Verifico se a taxa para poupança cadastrada confere com a taxa da meta selic
				If Round( ( ( (1 + ( aTaxas[nX][4] * ( aTaxas[nX][5] / 100 ) )/100 ) ^ (1/12) - 1) * 100 ), 4) == aTaxas[nX][3]
					nTaxaCP := aTaxas[nX][3]
				Else
					nTaxaCP := Round( ( ( (1 + ( aTaxas[nX][4] * ( aTaxas[nX][5] / 100 ) )/100 ) ^ (1/12) - 1) * 100 ), 4)
				EndIf

				If aTaxas[nX][4] > 8.5
					nTaxaCP := 0.5
				EndIf

			EndIf

			//Cálculo do rendimento da poupança com juros compostos
			nSaldoCP := nSaldoCP * ( 1 +  ( nTaxaCP + aTaxas[nX][6] ) / 100  )

		Next nX

		nVlrAplAtu  := Round( nSaldoCP, 2)
		nJurAplAtu  := nVlrAplAtu - nSaldo
		nIrfAplAtu	:= 0 //Caderneta de Poupança é isenta de IR
		nResgBruto	:= nVlResgate
		nOutAplAtu	:= nJurAplAtu * SEH->EH_IMPOSTO / 100

		If lFGetOutAp .And. Empty(nOutAplAtu)
			FGetOutAp(@nOutAplAtu)
		ElseIf !Empty(nTxOut)
			nOutAplAtu := nTxOut
		EndIf

		nVlrRegAtu := 0
	Else

		aUltComeCotas := UltComeCotas()	// Busca data do ultimo come-cotas

		If AllTrim(SEH->EH_TIPO) == "FIC" .AND. lIsAprIrf .AND. lDeduzIR .AND. !Empty(aUltComeCotas[1])

			/*
				Cálculo diferenciado para Apropriação por cotas
				Rendimento do último come-cotas até o come-cotas atual
			*/

			/*
				Valor atual da Aplicação
			*/
			nVlrAplAtu	:= nSaldo * nCotaAtual

			/*
				Valor da aplicação no último come-cotas
			*/
			nVlrUltCome := nSaldo * aUltComeCotas[2]

			/*
				Rendimento do último come-cotas até hoje
			*/
			nRendimento := nVlrAplAtu - nVlrUltCome
			nRdBruto	:= nRendimento
			nRdMes		:= nRendimento

			nIRRdBruto	:= ((nRdBruto-nIofAplAtu) * (nTaxaIrf/100))
			nIrfAplAtu	:= nIrRdBruto

			nVlLiquido	:= (nVlResgate - nIRRdBruto)

			nDelta		:= (nCotaAtual / aUltComeCotas[2]) - 1

		Else
			dDtCota := SEH->EH_DATA

			If lFinr820
				SE0->(dbSeek(xFilial("SE0")+SE9->(E9_BANCO+E9_AGENCIA+E9_CONTA+E9_NUMERO+Dtos(dDtcota))))
			Else
				// Localiza a cotacao da Aplicacao para Calcular o Rendimento
				SE0->(MsSeek(xFilial("SE0")+ SEH->(EH_BCOCONT+EH_AGECONT+EH_CTACONT+EH_CONTRAT+Str(21001231-Val(DTOS(dDtcota)),11))))
			EndIf

			// Houve resgate parcial no mesmo dia do mês
			If nCotaAtual == nCotaAnt .And. SE9->E9_COTAANT > 0
				nCotaAnt := SE9->E9_COTAANT
			ElseIf Str(nCotaAnt) $ Str(SE0->E0_VALOR)
				nCotaAnt := SE0->E0_VALOR
			EndIf

			nQtdCotas := nVlResgate / nCotaAtual

			nVlrAplAtu	:= nQtdCotas * nCotaAtual

			nVlrAplAnt	:= nQtdCotas * nCotaAnt

			nDelta := (nCotaAtual / nCotaAnt) - 1

			nRendimento := Round(nVlResgate  - (nQtdCotas * nCotaAnt), 2)

			If lF171RdBr
				// Ponto de Entrada F171RDBR para alterar o valor do Rendimento Bruto do período, recebendo o valor calculado até o ponto de entrada
				nRendAux := ExecBlock( "F171RDBR", .F., .F., { nRendimento } )

				If ValType(nRendAux) == "N"
					nRendimento := nRendAux
					nRendAux := 0
				EndIf
			EndIf

			nRdMes := nRendimento

			If !lRndMensal .And. lIsAprIrf .And. !Empty(SEH->EH_DATARES)
				nRdMes := rendResg()
			EndIf

			nIrAcum := IRsAcum()

			nRendAcum := rendAcumu(nRdMes)

			If lF171RdMn
				// Ponto de entrada F171RDMN para alterar o valor do Rendimento do mês, recebendo o valor calculado até o ponto de entrada.
				nRendAux := ExecBlock( "F171RDMN", .F., .F., { nRendimento } )

				If ValType(nRendAux) == "N"
					nRendimento := nRendAux
					nRendAux := 0
				EndIf
				nRdMes := nRendimento
			EndIf

			//Só verifica o parametro MV_RENAPL4, se não tiver nenhum dos dois pontos de entrada:
			//F171RDMN e F171RDBR
			If (lIsAprIrf .And. !lF171RdMn .And. !lF171RdBr)
				If lRndMensal
					nRendimento	:= nRdMes
					nRdBruto 	:= nRdMes
				Else
					nRdMes 		:= nRendAcum
					nRdBruto 	:= nRendAcum
				EndIf
			Else
				nRdBruto := nRdMes
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcula o IOF conforme a tabela cadastrada no SX5, ou a taxa de IOF cadastrada na aplicacao          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nDias := dDataBase - SEH->EH_DATA // Data da Inclusao da Aplicacao
			nIofAplAtu := FIN_IOF(SEH->EH_APLEMP, nRdMes, nDias)

			//Acumulado dos rendimentos e IR de apropriacao
			dbSelectArea("SEI")
			SEI->(dbSetOrder(2))		//EI_FILIAL, EI_APLEMP, EI_NUMERO, EI_REVISAO, EI_MOTBX

			If SEI->(dbSeek(xFilial("SEI")+SEH->(EH_APLEMP+EH_NUMERO+EH_REVISAO)+"APR"))
				While !SEI->(Eof()) .And. xFilial("SEI")+SEH->(EH_APLEMP+EH_NUMERO+EH_REVISAO)+"APR" == SEI->(EI_FILIAL+EI_APLEMP+EI_NUMERO+EI_REVISAO+EI_MOTBX)
					If SEI->EI_DATA == SEH->EH_ULTAPR
						If SEI->EI_TIPODOC == "I6" .And. SEI->EI_STATUS != "C"
							nIRAprop += SEI->EI_VALOR
							nQtdCota += SEI->EI_QTDCOTA
						EndIf

						If SEI->EI_TIPODOC == "I7" .And. SEI->EI_STATUS != "C"
							nRendAprop += SEI->EI_VALOR
						EndIf
					EndIf

					SEI->(dbSkip())
				EndDo
			Endif

			DbSelectArea("SEI")
			DbSetOrder(1)		//EI_FILIAL, EI_APLEMP, EI_NUMERO, EI_REVISAO, EI_SEQ

			If SEI->(DbSeek(xFilial("SEI") + SEH->(EH_APLEMP+EH_NUMERO+EH_REVISAO)))
				While !SEI->(Eof()) .AND. xFilial("SEI")+SEH->(EH_APLEMP+EH_NUMERO+EH_REVISAO) == SEI->(EI_FILIAL+EI_APLEMP+EI_NUMERO+EI_REVISAO)
					If SEI->EI_TIPODOC == "I1" .AND. SEI->EI_DATA >= SEH->EH_ULTAPR .AND. SEI->EI_STATUS != "C"
						lZeraIRApr := .T.
					EndIf

					SEI->(DbSkip())
				End
			EndIf

			//So Desconta o IR apropriado se não houve resgate após a ultima apropriação
			If lZeraIRApr
				nIRAprop 	:= 0
				nRendAprop 	:= 0
				nQtdCota    := 0
			Endif

			// IR da última apropriação
			If nIRAprop == 0 .Or. (nIRAprop <> 0 .And. !(nQtdCota <> 0 .And. FWIsInCallStack("FINR820")) )
				nIRAprop := IRAprCotas( nQtdCotas , aUltComeCotas )
			EndIf

			If (lIsAprIrf .And. lRndMensal) .Or. lRndMensal
				// IR Mensal
				nIRRdBruto := ROUNDFIN(((nRdBruto-nIofAplAtu) * (nTaxaIrf/100)),2,.T.)
			ElseIf !lIsAprIrf
				// IR Mensal
				nIRRdBruto := ROUNDFIN(((nRdBruto-nIofAplAtu) * (nTaxaIrf/100)),2,.T.) - ROUNDFIN(nIRAprop,2,.T.)
			Else
				// IR Acumulado
				nIRRdBruto := ROUNDFIN(((nRendAcum-nIofAplAtu) * (nTaxaIrf/100)),2,.T.) - ROUNDFIN(nIrAcum,2,.T.)
			EndIf
		EndIf

		If lAplImune
			FA181Imune(@nIofAplAtu,@nIRRdBruto)
		EndIf

		nVlLiquido := (nVlResgate - nIRRdBruto)
		nBaseCalc  := 0

		If nVlrAplAtu <= 0.01 .And. SEH->EH_GARANTE == "S"
			nVlrAplAtu := nSaldo
		EndIf

		If nCotaAtual > 0
			nJurAplAtu := nRdBruto
		EndIf

		nIrfAplAtu	 := nIrRdBruto
		nResgBruto	 := nVlResgate + nIrfAplAtu
		nSldAplicado := nVlrAplAtu - nResgBruto
		nOutAplAtu	 := nJurAplAtu * SEH->EH_IMPOSTO / 100

		If lFGetOutAp .And. Empty(nOutAplAtu)
			FGetOutAp(@nOutAplAtu)
		ElseIf !Empty(nTxOut)
			nOutAplAtu := nTxOut
		EndIf

		nVlrRegAtu := ( nVlrAplAtu-nIrfAplAtu-nIofAplAtu-nOutAplAtu )

	EndIf
EndIf

// Restaura a area de trabalho
SA6->(RestArea(aSA6))
RestArea(aArea)

If !Empty(oFerMunic)
	FwFreeObj(oFerMunic)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ajustar os valores para nao deixar Impostos negativos         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nIrfAplAtu := If( nIrfAplAtu < 0, 0, nIrfAplAtu )
nIofAplAtu := If( nIofAplAtu < 0, 0, nIofAplAtu )
nOutAplAtu := If( nOutAplAtu < 0, 0, nOutAplAtu )
nVlrRegAtu := If( nVlrRegAtu < 0, 0, nVlrRegAtu )

// Em 2024 houve mudança no cálculo dos impostos na lei 14754
// no qual ao invés de utilizar o valor da cota do último dia dos meses de maio e novembro
// irá se utilizar o penúltimo dia ÚTIL
If lIsAprIrf .And. lDeduzIR .And. Year(dDtSaldo) >= 2024 .And. SEH->EH_TIPO $ SuperGetMV("MV_APLCAL4", .F., "FAF")

	nVlrAtuCC := nSaldo * nVlCotaIR

	nRdMesCC := Round(nVlrAtuCC - nVlrAplAnt, 2)

	nRendCC := rendAcumu(nRdMesCC)

	nDias := DataValida((dDtSaldo-1), .F.) - SEH->EH_DATA

	nIofAplAtu := FIN_IOF(SEH->EH_APLEMP, nRendCC, nDias)

	// IR Acumulado
	nIRCC := ROUNDFIN(((nRendCC-nIofAplAtu) * (nTaxaIrf/100)),2,.T.) - ROUNDFIN(nIrAcum,2,.T.)

EndIf

Return({ nVlrAplAtu,nIrfAplAtu,nIofAplAtu,nOutAplAtu,nJurAplAtu,nVlrRegAtu,nRdMes,nIrRdBruto,nVlLiquido,nDelta,nBaseCalc,nRendCC,nIRCC })

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA171CALEP

Calcula o Valor da Aplicacao Financeira  (Fa171Calc).
Arquivo original: FINXFUN.PRX

Parametro
Deve estar posicionado no SEH
ExpD1 : Data do Saldo
ExpN2 : Moeda do Saldo
ExpL3 : Considera data de resgate
ExpN4 : Valor da Moeda do Saldo
ExpD5 : Data da Ultima apropriacao (somente para recalculo)
ExpL1 : Por Filial/Empresa

@Author	Eduardo Riera
@since	13/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Static Function Fa171CalEp(dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,lFilial,lDeduzIR,nTaxaIrf)

Local dDtCalculo	:= SEH->EH_DATA
Local nVlEmpAtu2	:= 0 // Valor atualizado na moeda do emprestimo
Local nVlEmpAtu1	:= 0 // Valor atualizado na moeda 1
Local nVlEmpJur2	:= 0 // Juros na moeda do emprestimo
Local nVlEmpJur1	:= 0 // Juros na moeda 1
Local nVlEmpVC		:= 0 // Variacao Cambial
Local nVlEmpCVC		:= 0 // Variacao Cambial a Curto Prazo
Local nVlEmpLVC		:= 0 // Variacao Cambial a Longo Prazo
Local nVlEmpJVC		:= 0 // Variacao Cambial do Juros
Local nAcEmpJur2	:= SEH->EH_ACUJUR2 // Acumulado do Juros na moeda do Emprestimo
Local nAcEmpJur1	:= SEH->EH_ACUJUR  // Acumulado do juros na moeda corrente
Local nAcEmpCVC		:= SEH->EH_ACUVCCP // Acumulado da Variacao Cambial a Curto Prazo
Local nAcEmpLVC		:= SEH->EH_ACUVCLP // Acumulado da Variacao Cambial a Longo Prazo
Local nAcEmpJVC		:= SEH->EH_ACUVCJR // Acumulado da Variacao Cambial dos Juros
Local nTxIOF		:= SEH->EH_TAXAIOF
Local nIofAtu		:= 0
Local dData			:= Ctod("")
Local cFilAp		:= If(lFilial, xFilial(), SEH->EH_FILIAL)
Local nDiasCTB		:= GetNewPar("MV_DIASCTB", 360) //Quantidade de dias para o ano contábil
Local nDias			:= If(FwIsInCallStack('FINR820'),(dDtSaldo - SEH->EH_DATA),(dDataBase - SEH->EH_DATA))
Local cTabIrf		:= "AR"
Local aTabIrf		:= {	{ 180, 22.5 },;
							{ 360, 20.0 },;
							{ 720, 17.5 },;
							{ 1000000, 15.0 } }
Local nAscan		:= Ascan( aTabIrf, { |e| e[1] >= nDias } ) // Pesquisa a aliquota conforme o tempo da aplicacao
Local lL11033		:= SuperGetMv("MV_L11033",,.F.)

Default nTaxaIrf	:= If(Empty(SEH->EH_TAXAIRF), If(SX5->(MsSeek(xFilial("SX5")+"AR")),;
								Val(TabelaIrf(cTabIrf,nDias)),aTabIrf[nAscan][2]), SEH->EH_TAXAIRF)
Default lDeduzIR	:= .T.

//Ponto de entrada para validacao do dias CTB
If ExistBlock("FADIACTB")
	nDiasCTB := ExecBlock("FADIACTB",.F.,.F.,{nDiasCTB})
Endif

dUltApr := If(dUltApr == Nil , SEH->EH_ULTAPR , dUltApr )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calculo do Valores Acumulados                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SEI")
dbSetOrder(1)
dbSeek(cFilAp+SEH->EH_APLEMP+SEH->EH_NUMERO+SEH->EH_REVISAO)
While ( !Eof() .And. SEI->EI_FILIAL == cFilAp .And.;
		SEI->EI_APLEMP == SEH->EH_APLEMP .And.;
		SEI->EI_NUMERO == SEH->EH_NUMERO .And.;
		SEI->EI_REVISAO== SEH->EH_REVISAO )
	If ( SEI->EI_DATA <= dUltApr .And. SEI->EI_STATUS!="C" )
		If ( SEI->EI_MOTBX=="APR" )
			If ( SEI->EI_TIPODOC == "JR" )
				nAcEmpJur2 += SEI->EI_VLMOED2
				nAcEmpJur1 += SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V2" )
				nAcEmpCVC += SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V1" )
				nAcEmpLVC += SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V3" )
				nAcEmpJVC += SEI->EI_VALOR
			EndIf
		Else
			If ( SEI->EI_TIPODOC == "JR" )
				nAcEmpJur2 -= SEI->EI_VLMOED2
				nAcEmpJur1 -= SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V2" )
				nAcEmpCVC -= SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V1" )
				nAcEmpLVC -= SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V3" )
				nAcEmpJVC -= SEI->EI_VALOR
			EndIf
		EndIf
		dData := Max(dData,SEI->EI_DATA)
	EndIf
	dbSelectArea("SEI")
	dbSkip()
EndDo

dUltApr	 := If(Empty(dData),SEH->EH_ULTAPR,dData)
dDtCalculo:= If(Empty(dUltApr),dDtCalculo,dUltApr)
dDtSaldo  := If(Empty(dDtSaldo),dDataBase,dDtSaldo)
nSaldo    := If(Empty(nSaldo ) ,SEH->EH_SALDO,nSaldo)
lResgate  := If(lResgate==Nil,.F.,lResgate)
nVlMoeda  := If(nVlMoeda==Nil,RecMoeda(dDtSaldo,SEH->EH_MOEDA),nVlMoeda)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calculo do Numero de Dias para apropriacao.                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SEH")
Do Case
Case SEH->EH_TIPO $ GetMv("MV_EMPAPRO")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calculo do emprestimo Euro Notes. Sua principal caracteristica³
	//³ e'que o juros sempre sao calculados com trinta dias uteis,    ³
	//³ independente do numero de dias do mes.                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nDias    := 0
	If ( dDtCalculo != dDtSaldo )
		While ( dDtCalculo < dDtSaldo )
			Do Case
			Case Day(dDtCalculo) == 28 .AND.;
					Month(dDtCalculo) == 02
				nDias += 2
			Case Day(dDtCalculo) == 29 .AND.;
					Month(dDtCalculo) == 02 .AND.;
					nDias == 0
				nDias ++
			Case ( Day(dDtCalculo) != 31 )
				nDias ++
			EndCase
			dDtCalculo++
		EndDo
	EndIf
OtherWise
	nDias := ( dDtSaldo - dDtCalculo )
	If ( nDias < 0 )
		nDias := 0
	EndIf
EndCase
Do Case
Case ( !Empty(SEH->EH_FORMULA) )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A formula deve utilizar as variaveis PRIVATES dFormula,nFormu-³
	//³ la e lFormula para calcular o multiplicador da aplicacao.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dFormula := dDtSaldo
	nFormula := nSaldo
	lFormula := lResgate

	nVlEmpJur2 := Formula(SEH->EH_FORMULA)
	nVlEmpJur1 := Round(nVlEmpJur2 * nVlMoeda,TamSX3("EH_VALOR")[2])
	nVlEmpAtu2 := SEH->EH_SALDO+nVlEmpJur2
	nVlEmpAtu1 := Round(nVlEmpAtu2*nVlMoeda,TamSX3("EH_VALOR")[2])

	nAcEmpJur2 += nVlEmpJur2
	nAcEmpJur1 += nVlEmpJur1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A variacao cambial e'calculada sobre a diferenca entre o saldo do em-   ³
	//³ prestimo e o valor original em moeda corrente                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nVlEmpVC  := Round((nSaldo * nVlMoeda)-SEH->EH_VLCRUZ,TamSX3("EH_SALDO")[2])
	nVlEmpCVC := Round((nVlEmpVC*SEH->EH_PERCPLP/100),TamSX3("EH_SALDO")[2]) - nAcEmpCVC
	nVlEmpLVC := nVlEmpVC - nVlEmpCVC - nAcEmpLVC

	nAcEmpCVC += nVlEmpCVC
	nAcEmpLVC += nVlEmpLVC

	nVlEmpJVC := Round(((nAcEmpJur2 * nVlMoeda)-nAcEmpJur1),TamSX3("EH_SALDO")[2]) - nAcEmpJVC
	nACEmpJVC += nVlEmpJVC
Case ( SEH->EH_MOEDA != 1 .And.;
		SEH->EH_TIPO $ GetMv("MV_EMPCAL1")+"|"+GetMv("MV_EMPCAL4") )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Emprestimos Estrangeiros                                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ O juros e'calculado sobre o saldo do emprestimo que esta na moeda da    ³
	//³ operacao financeira.                                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SEH->EH_TIPO $ GetMv("MV_EMPCAL4") )
		nVlEmpJur2 := Round(nSaldo*((((SEH->EH_TAXA/100)+1)**(nDias/nDiasCTB))-1),TamSX3("EH_SALDO")[2])
	Else
		nVlEmpJur2 := Round((SEH->EH_TAXA/100)*(nSaldo/nDiasCTB)*nDias,TamSX3("EH_SALDO")[2])
	EndIf
	nVlEmpJur1 := Round(nVlEmpJur2 * nVlMoeda,TamSX3("EH_VALOR")[2])
	nVlEmpAtu2 := SEH->EH_SALDO+nVlEmpJur2
	nVlEmpAtu1 := Round(nVlEmpAtu2*nVlMoeda,TamSX3("EH_VALOR")[2])

	nAcEmpJur2 += nVlEmpJur2
	nAcEmpJur1 += Round(nVlEmpJur1,TamSX3("EH_VALOR")[2])
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A variacao cambial e'calculada sobre a diferenca entre o saldo do em-   ³
	//³ prestimo e o valor original em moeda corrente                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nVlEmpVC  := Round((nSaldo * nVlMoeda)-SEH->EH_VLCRUZ,TamSX3("EH_SALDO")[2])
	nVlEmpCVC := Round((nVlEmpVC*SEH->EH_PERCPLP/100),TamSX3("EH_SALDO")[2])-nAcEmpCVC
	nVlEmpLVC := nVlEmpVC - nVlEmpCVC - nAcEmpLVC

	nAcEmpCVC += nVlEmpCVC
	nAcEmpLVC += nVlEmpLVC

	nVlEmpJVC := Round(((nAcEmpJur2 * nVlMoeda)-nAcEmpJur1),TamSX3("EH_SALDO")[2])-nAcEmpJVC
	nAcEmpJVC += nVlEmpJVC
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Emprestimos Nacionais.                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case ( SEH->EH_TIPO $ GetMv("MV_EMPCAL2")+"|"+GetMv("MV_EMPCAL3") )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calculo do emprestimo Hot Money. Sua principal  caracteristica³
	//³ e'que o juros sao simples e o resgate e quase imediato.       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SEH->EH_TIPO $ GetMv("MV_EMPCAL2") )
		nVlEmpJur1 := Round((SEH->EH_TAXA/100)*(nSaldo/nDiasCTB)*nDias,TamSX3("EH_SALDO")[2])
	Else
		nVlEmpJur1 := DEC_FIN(nSaldo + nAcEmpJur1,(((SEH->EH_TAXA/100)+1)**(nDias/nDiasCTB))-1)
	EndIf
	nVlEmpJur2 := nVlEmpJur1
	nVlEmpAtu1 := SEH->EH_SALDO+nVlEmpJur1
	nVlEmpAtu2 := nVlEmpAtu1
	nAcEmpJur2 += nVlEmpJur2
	nAcEmpJur1 += nVlEmpJur1
EndCase

If FwIsInCallStack("FINA181")// Calculo feito pelo FINA181
	// Calcula o IOF conforme a tabela cadastrada no SX5, ou a taxa de IOF cadastrada na aplicacao
	nDias := dDataBase - SEH->EH_DATA // Data da Inclusao da Aplicacao
	nIOFAtu := FIN_IOF(SEH->EH_APLEMP,nA181VPLP1,ndias,nTxIOF)
EndIf

If lL11033
	nA181VlIrf	:= NoRound( (nVlEmpJur1) * nTaxaIrf/100, TamSX3("EH_SALDO")[2] )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ajustar os valores para nao deixar Impostos negativos         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nA181VlIrf := If( nA181VlIrf < 0, 0, nA181VlIrf )
EndIf

Return( {	{ nVlEmpAtu2, nAcEmpJur2, 0, 0, 0, nVlEmpJur2, 0, 0, 0 }, ;
			{ nVlEmpAtu1, nAcEmpJur1, nAcEmpLVC, nAcEmpCVC, nAcEmpJVC, nVlEmpJur1, nVlEmpLVC, nVlEmpCVC, nVlEmpJVC, nIofAtu } } )


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} OPENCMC7

Abre porta para a leitora de cheques (CMC7).
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	13/08/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function OpenCMC7()

Local cModelo	:= Alltrim(GetMv("MV_CMC7MOD",.F.,""))
Local cPrtCMC7	:= AllTrim(GetMv("MV_CMC7PRT",.F.,""))

nHdlCMC7	:= IIF(nHdlCMC7==NIL,-1,nHdlCMC7)

If !Empty(cModelo) .and. !Empty(cPrtCMC7)
	If CheckDLLLj()
		nHdlCMC7 := CMC7Abr(cModelo,cPrtCMC7,"N")
	EndIf
EndIf
Return


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} READCMC7

Efetua a leitura dos dados da leitora de cheques (CMC7)
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	13/08/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function ReadCmC7()

Local aCmC7 := {}

nHdlCMC7	:= IIF(nHdlCMC7==NIL,-1,nHdlCMC7)
AADD(aCMC7,nHdlCMC7)
AADD(aCMC7,GetMv("MV_CMC7FIN"))

Return aCmC7


//888.03 Leitora de cheques ARGENTINA

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinVldCMC7

Funcao para a validar o código capturado pelo leitor de CMC7. (ARGENTINA)
Arquivo original: FINXFUN.PRX

@author    Mauricio Pequim Jr
@version   11.80
@since     05/02/13

@return ExpL1 = Confirma se os dados lidos sao validos

/*/
//-----------------------------------------------------------------------------------------------------
Function FinVldCMC7( cCmc7 )
Local lRet := .F.		// Retorno da validacao da string
Local nTamCmc7 := 31

Default cCmc7	:= ""	//Codigo do CMC7

If !Empty(cCmc7)
	nPosIni := AT("<", cCmc7)
	If nPosIni == 0
		nPosIni := AT("C", cCmc7)
	Endif
	If nPosIni > 0
		cCmc7	:= SubStr(Alltrim(cCmc7), nPosIni , Len(Alltrim(cCmc7)) - 1)
	Endif
EndIf

If Empty( cCmc7 ) // Caso nao leia nada
	MsgAlert( STR0026 ) //"Passe o cheque novamente no leitor."
Elseif ( "?" $ cCmc7 ) .or. ( ":" $ cCmc7 ) .or. Len( AllTrim( cCmc7 ) ) <> nTamCmc7  // Se encontrar o caracter de erro (? ou :) ou tamnaho menor que o correto (34)
	MsgAlert( STR0027 + " " + STR0026) //"Falha na leitura."  ### "Passe o cheque novamente no leitor."
	cCmc7 := Padr(cCmc7,35)
Else
	lRet := .T.
Endif

Return ( lRet )


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinCmc7Tc

Funcao para a captura do código CMC7 pelo leitor via teclado.(ARGENTINA)
Arquivo original: FINXFUN.PRX

@author    Mauricio Pequim Jr
@version   11.80
@since     05/02/13

@return aCmc7Tc	- Array contendo as informações de Banco, Agencia, Conta e Codigo Postal do cheque

/*/
//-----------------------------------------------------------------------------------------------------
Function FinCmc7Tc(lFazPerg)
Local cCmc7 	:= Space(35)	// Recebera o conteudo lido do cheque
Local oCmc7						// Objeto do get do CMC7
Local oDlg						// Monta a tela de captura do codigo
Local aCmc7Tc	:= {}			// Armazena os dados do cheque; retorno da funcao
Local nOpcx 	:= 0

Default lFazPerg := .T.

If nTamBco == 0
	nTamBco := TamSX3("EF_BANCO")[1]
Endif
If nTamAge == 0
	nTamAge := TamSX3("EF_AGENCIA")[1]
Endif
If nTamCta == 0
	nTamCta := TamSX3("EF_CONTA")[1]
Endif
If nTamChq == 0
	nTamChq := TamSX3("EF_NUM")[1]
Endif
If nTamCPo == 0
	nTamCPo := TamSX3("EF_POSTAL")[1]
Endif

If cPaisloc == "ARG" .and. (!lFazPerg .or. MsgYesNo(STR0028,STR0029))	//"Deseja utilizar a leitora de cheques?"###"Leitura de cheques"

	If ExistBlock("FINLRCHQ")
		cCmC7 := ExecBlock("FINLRCHQ",.F.,.F.,{})
	EndIf

	DEFINE MSDIALOG oDlg TITLE STR0030 FROM 200 , 001 TO 300 , 300 OF oMainWnd PIXEL	 //"Leitura do código do cheque"
	@ 008 , 018 Say STR0031 SIZE 200 , 10 OF oDlg PIXEL								 //"Por favor, passe o cheque pelo leitor..."
	@ 018 , 018 MSGET oCmc7 VAR cCmc7 PICTURE "@!" SIZE 120,009 OF oDlg PIXEL

	DEFINE SBUTTON FROM 35 , 080 TYPE 1 ACTION (Iif (FinVldCMC7(@cCmc7), (oDlg:End(), nOpcx := 1), oCmc7:SetFocus()) )  ENABLE OF oDlg
	DEFINE SBUTTON FROM 35 , 110 TYPE 2 ACTION oDlg:End()  ENABLE OF oDlg

	ACTIVATE MSDIALOG oDlg CENTERED

	If nOpcx == 1  //Confirmou cheque

		If ExistBlock("FINCMTC")
			aCmc7Tc := ExecBlock("FINCMTC",.F.,.F.,{cCmc7})
		Else

			Aadd( aCmc7Tc, PadR(SubStr(cCmc7,  2,  3),nTamBco) )	//Banco
			Aadd( aCmc7Tc, PadR(SubStr(cCmc7,  5,  3),nTamAge) )	//Agencia
			Aadd( aCmc7Tc, PadR(SubStr(cCmc7,  8,  4),nTamCPo) )	//Codigo Postal
			Aadd( aCmc7Tc, PadR(SubStr(cCmc7, 12,  8),nTamChq) )	//Cheque
			Aadd( aCmc7Tc, PadR(SubStr(cCmc7, 20, 10),nTamCta) )	//Conta
			Aadd( aCmc7Tc,      SubStr(cCmc7, 30,  1)          )	//DV Conta

		Endif

	Endif
Endif

Return( aCmc7Tc )


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FC020FORM

Intrepreta a Formula de Reajuste (Fluxos de caixa - Pedidos de compra / venda).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	01/02/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function Fc020Form(cFormula,dDataReaj)
Local xAlias, cForm:=" ", xValor:=0, nPos, nLen
Local cErros := ""
Private dDtReaj:=dDataReaj,lFormula:=.T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Salva a integridade dos dados                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
xAlias := Alias()

dbSelectArea("SM4")
dbSeek(cFilial+cFormula)
IF Found()
	cForm := Upper(AllTrim(M4_FORMULA))
	nPos  := At("RECMOEDA(",cForm)
	If nPos > 0
		nPos += 9
		nLen := 0
		While SubStr(cForm,nPos+nLen,1) != ","
			nLen++
		End
		cVarData := SubStr(cForm,nPos,nLen)
		cForm    := strtran(cForm,cVarData,"dDtReaj")
	End
	If At("C9_",cForm) > 0
		cForm := StrTran(cForm,"C9_","C6_")
	End
	If At("C9->",cForm) > 0
		cForm := StrTran(cForm,"C9->","C6->")
	End
	dbSelectArea(xAlias)

	IF At( cForm, cErros ) = 0
		lFormula := fa020TestF( cForm, @xValor )
		IF !( lFormula )
			cErros +=cForm+"ü"
		End
	End
Else
	xValor := 0
End
dbSelectArea(xAlias)
Return xValor


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA020TESTF

Intrepreta a Formula de Reajuste (Fluxos de caixa - Pedidos de compra / venda).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	10/11/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fa020TestF( cForm, xValor )
Local bErro := ErrorBlock( { |e| ChecErr260(e,cForm) } )
PRIVATE lRet := .T.

BEGIN SEQUENCE
	xValor := &cForm
END SEQUENCE
ErrorBlock(bErro)
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FC020COMPR

Monta array com Pedidos de Compra (Fluxos de caixa).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	06/07/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fc020Compra(cAliasPc, aTotais, lRegua, nMoeda, aPeriodo, cFilIni, cFilFin, cPedidos, lConsDtBase, aCCustos, aSelFil, lAnalitic)

	Local cNumPed
	Local cCond
	Local i
	Local nPrcCompra
	Local dData
	Local nValIPILiq
	Local nTotDesc
	Local cFilDe
	Local cFilAte
	Local cFilPed
	Local bSelFil
	Local cSaveFil		:= cFilAnt
	Local nAscan		:= 0
	Local dDataFluxo	:= {}
	Local aDataAux		:= {}
	Local nPosData 		:= 0
	Local nValTot		:= 0
	Local nValIpi		:= 0
	Local aVenc			:= {}
	Local nDespFrete	:= 0
	Local lFc020Com		:= ExistBlock("FC020COM")
	Local lFC020CQR		:= ExistBlock("FC020CQR")
	Local lF021DtFl		:= ExistBlock("FC021DTF")
	Local nDecimais		:= TamSx3("C7_PRECO")[2]
	Local nInc			:= 0
	Local aSM0			:= AdmAbreSM0()
	Local nTaxaMoed		:= 0
	Local cCustos		:= ''
	Local nX			:= 0
	Local lFincFluxo	:= FwIsInCallStack("FINC021") .OR. FwIsInCallStack("FINC022") .OR. FwIsInCallStack("FINR140")
	Local lFinc024		:= FwIsInCallStack("FINC024")
	Local nValPagAnt	:= 0
	Local lPACalc		:= .F. //Controle do calc do PA, para não duplic no fluxo de cx quando o pedid tem mais de um item.
	Local nTotRegSC7	:= 0
	Local lSE2Excl		:= FwModeAccess("SE2",1) == "E" .And. FwModeAccess("SE2",2) == "E" .And. FwModeAccess("SE2",3) == "E"
	Local nI			:= 0
	Local cQuery		:= ""
	Local aStru			:= SC7->(dbStruct())
	Local aData 		:= {}
	Local nPos  		:= 0
	Local cTblTmp
	Local lTES			:= .F.
	Local __oMovPA		:= NIL
	Local nValFIE		:= 0
	Local nValAdto 		:= 0
	Local nVlPAItem     := 0
	Local lInclusao		:= .T.
	Local lSC7Exclus	:= FwModeAccess("SC7", 3) == "E"
	Local nOrdTmp		:= 3
	Local cChaveTmp		:= "DToS(dDataFluxo) + SC7->C7_NUM + SC7->C7_ITEM"

	Default nMoeda		:= 1
	Default cFilIni		:= "  "
	Default cFilFin		:= "zz"
	Default cPedidos	:= "3" // Todos os pedidos
	Default aCCustos	:= {}
	Default aSelFil		:= {}
	Default lAnalitic	:= .F.

	If aAdianta == NIL
		aAdianta := ProtCfgAdt()
		bFilFIE := Iif(aAdianta[1,4],{|| FIE_FILORI==cFilAnt .Or. Empty(FIE_FILORI)},{||.T.})
		lAdComPart := aAdianta[1,5] .And. 'C' $ aAdianta[1,1]+aAdianta[1,2]+aAdianta[1,3]
	Endif

	If lSC7Exclus
		nOrdTmp		:= 4
		cChaveTmp	:= 'FwXFilial("SC7") + DToS(dDataFluxo) + SC7->C7_NUM + SC7->C7_ITEM'
	EndIf

	// Verifica o tipo de filtro de filial.
	If empty(aSelFil)
		bSelFil := {|cFilInc| aScan(aSelFil, cFilInc) > 0}
	Else
		If mv_par03 == 2		// por empresa
			cFilDe	:= cFilIni
			cFilAte	:= cFilFin
		Else					// por filial
			cFilDe	:= cFilAnt
			cFilAte	:= cFilAnt
		Endif
		bSelFil := {|cFilInc| AllTrim(cFilInc) >= Alltrim(cFilDe) .And. AllTrim(cFilInc) <= Alltrim(cFilAte)}
	Endif

	If lFinc024
		For nX := 1 To Len(aCCustos)
			cCustos += "'" + aCCustos[nX] + "',"
		Next nX
		cCustos := Substr(cCustos, 1, Len(cCustos) - 1)
	EndIf

	For nInc := 1 To Len( aSM0 )
		If aSM0[nInc][1] == cEmpAnt .And. Eval(bSelFil, aSM0[nInc][2])
			cFilAnt := aSM0[nInc][2]
			//--------------------------
			// Ler Pedidos de Compra
			//--------------------------
			DbSelectArea("SC7")
			SC7->(DbSetOrder(1))
			DbSeek(xFilial())

			If lF021DtFl
				cQuery := "SELECT * "
			Else
				cQuery := "SELECT C7_FILIAL,C7_NUM,C7_COND,C7_TOTAL,C7_VLDESC,C7_RESIDUO,C7_QUANT,C7_QUJE,C7_CONAPRO,C7_FLUXO,C7_PRODUTO,"
				cQuery += "C7_TES,C7_DATPRF,C7_MOEDA,C7_PRECO,C7_TXMOEDA,C7_REAJUST,C7_VALFRE,C7_SEGURO,C7_DESPESA,C7_DESC1,"
				cQuery += "C7_DESC2,C7_DESC3,C7_VLDESC,C7_ITEM,C7_FORNECE,C7_LOJA,C7_EMISSAO,C7_TIPO,C7_SEQUEN,C7_IPI,C7_IPIBRUT "
				If lFincFluxo
					cQuery += " ,D1_FILIAL,D1_PEDIDO,D1_FORNECE,D1_LOJA,SUM(ISNULL(D1_VALDESC,0)) D1_VALDESC,(C7_VLDESC - SUM(ISNULL(D1_VALDESC,0))) SALDO "
				EndIf
			EndIf

			cQuery += " FROM " + RetSqlName("SC7") + " SC7 "

			If lFincFluxo .and. !lF021DtFl
				cQuery += " LEFT JOIN " + RetSqlName("SD1") + " SD1 "
				cQuery += " ON SD1.D_E_L_E_T_ = '' "
				cQuery += " AND SD1.D1_FILIAL  = C7_FILIAL "
				cQuery += " AND SD1.D1_PEDIDO  = C7_NUM "
				cQuery += " AND SD1.D1_ITEMPC  = C7_ITEM "
				cQuery += " AND SD1.D1_COD     = C7_PRODUTO "
				cQuery += " AND SD1.D1_FORNECE = C7_FORNECE "
				cQuery += " AND SD1.D1_LOJA    = C7_LOJA "
			EndIf

			cQuery += " WHERE C7_FILIAL = '" + xFilial("SC7") + "'"
			cQuery += " AND SC7.D_E_L_E_T_ = ' ' "
			cQuery += " AND C7_QUJE < C7_QUANT"
			cQuery += " AND C7_RESIDUO <> 'S'"
			cQuery += " AND C7_FLUXO   <> 'N'"

			If lFC020CQR
				cQuery += ExecBlock("FC020CQR",.F.,.F.)
			EndIf

			If lFincFluxo .and. !lF021DtFl
				cQuery += " GROUP BY D1_FILIAL, D1_PEDIDO, D1_FORNECE, D1_LOJA, C7_FILIAL,C7_NUM,C7_COND,C7_TOTAL,C7_VLDESC,C7_RESIDUO,C7_QUANT,C7_QUJE, "
				cQuery += " C7_CONAPRO,C7_FLUXO,C7_PRODUTO,C7_TES,C7_DATPRF,C7_MOEDA,C7_PRECO,C7_TXMOEDA,C7_REAJUST,C7_VALFRE,C7_SEGURO,C7_DESPESA, "
				cQuery += " C7_DESC1,C7_DESC2,C7_DESC3,C7_VLDESC,C7_ITEM,C7_FORNECE,C7_LOJA,C7_EMISSAO,C7_TIPO,C7_SEQUEN,C7_IPI,C7_IPIBRUT "
			EndIf

			If lFinc024
				cQuery += "AND C7_RATEIO = '2'" //Rateio SCH é filtrado na outra query.
				If !Empty(cCustos)
					cQuery += "AND C7_CC IN (" + cCustos + ")"
				EndIf
			EndIf

			If lFinc024
				cQuery +=	"UNION ALL"

				If lF021DtFl
					cQuery := "SELECT * "
				Else
					cQuery := "SELECT C7_FILIAL,C7_NUM,C7_COND,C7_TOTAL,C7_VLDESC,C7_RESIDUO,C7_QUANT,C7_QUJE,C7_CONAPRO,C7_FLUXO,C7_PRODUTO,"
					cQuery += "C7_TES,C7_DATPRF,C7_MOEDA,C7_PRECO,C7_TXMOEDA,C7_REAJUST,C7_VALFRE,C7_SEGURO,C7_DESPESA,C7_DESC1,"
					cQuery += "C7_DESC2,C7_DESC3,C7_VLDESC,C7_ITEM,C7_FORNECE,C7_LOJA,C7_EMISSAO,C7_TIPO,C7_SEQUEN,C7_IPI,C7_IPIBRUT "
				EndIf

				cQuery += " FROM "+	RetSQLTab("SC7")
				cQuery += " JOIN "+	RetSQLTab("SCH") + " ON SCH.CH_PEDIDO = SC7.C7_NUM AND SCH.CH_ITEMPD = SC7.C7_ITEM "
				If (!Empty(cCustos), cQuery += "AND SCH.CH_CC IN (" + cCustos + ")", Nil)
				cQuery += " WHERE C7_FILIAL = '" + xFilial("SC7") + "'"
				cQuery += " AND C7_QUJE < C7_QUANT"
				cQuery += " AND C7_RESIDUO <> 'S'"
				cQuery += " AND C7_FLUXO   <> 'N' AND "
				cQuery += 	RetSqlCond("SC7,SCH")
			Else
				cQuery += " ORDER BY "+ SqlOrder(IndexKey())
			EndIf
			cQuery := ChangeQuery(cQuery)
			DbSelectArea("SC7")
			DbCloseArea()
			DbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), 'SC7', .F., .T.)

			For nI := 1 to Len(aStru)
				If aStru[nI,2] != 'C'
					TCSetField('SC7', aStru[nI,1], aStru[nI,2],aStru[nI,3],aStru[nI,4])
				Endif
			Next nI

			While SC7->(!Eof())

				cFilPed		:= SC7->C7_FILIAL
				cNumPed		:= SC7->C7_NUM
				nValTot		:= 0
				nValIpi		:= 0
				aVenc		:= {}
				cCond		:= SC7->C7_COND
				nTotDesc	:= SC7->C7_VLDESC
				nDespFrete	:= 0
				nValFIE	 	:= 0 //Ler adiantamentos do pedido somente uma vez

				While SC7->(!Eof()) .And. SC7->C7_NUM==cNumPed .and. xFilial("SC7") == SC7->C7_FILIAL
					If lRegua != Nil .and. lRegua
						IncProc(STR0032) // Processando Pedidos de compras
					Endif
					IF SC7->C7_QUJE >= SC7->C7_QUANT .or. SC7->C7_RESIDUO == "S" .or. SC7->C7_FLUXO == "N"
						SC7->(dbSkip())
						Loop
					Endif
					If (SC7->C7_CONAPRO == "B" .And. Left(cPedidos,1) == "1") .Or. (SC7->C7_CONAPRO != "B" .And. Left(cPedidos,1) == "2")
						SC7->(dbSkip())
						Loop
					Endif

					SB1->(dbSeek( xFilial("SB1") + SC7->C7_PRODUTO)) // Posiciona Produto
					If !Empty(SC7->C7_TES)
						lTES := SF4->(dbSeek( xFilial("SF4") + SC7->C7_TES ))  // Posiciona TES
					Else
						lTES := SF4->(dbSeek( xFilial("SF4") + RetFldProd(SB1->B1_COD,"B1_TE") ))  // Posiciona TES
					Endif

					// Se nao houver TES no Pedido ou Produto serah considerado pois o tes no PC nao eh obrigatorio ou comum.
					IF lTES .and. SF4->F4_DUPLIC == "N"
						dbSelectArea("SC7")
						dbSkip()
						Loop
					Endif

					SE2->(Dbsetorder(1))

					If nValFIE == 0//Ler adiantamentos do pedido somente uma vez
						FIE->(dbSetOrder(1))// Tabela Pedidos x Adiantamentos
						FIE->(MsSeek(xFilial("FIE")+"P"+cNumPed))
						While FIE->(!EOF()) .And. FIE->FIE_PEDIDO == cNumPed .And. !lPACalc
							If FIE->(Eval(bFilFIE))
								If SE2->(Dbseek(xFilial("SE2")+FIE->(FIE_PREFIX+FIE_NUM+FIE_PARCEL+FIE_TIPO+FIE_FORNEC+FIE_LOJA)))
									If F340MovPA(Nil, "SE2",.T.)[1] //Verifica se a PA possui movimentação bancária
										IF SE2->E2_MOEDA <> nMoeda
											If SE2->E2_TIPO $ MVPAGANT
												nValFIE += SE2->E2_VLCRUZ
											Endif
										Else
											If FIE->FIE_TIPO $ MVPAGANT
												nValFIE += FIE->FIE_VALOR  	// Valor do Adiantamento
											EndIf
										Endif
									EndIf
								EndIf
							EndIf
							FIE->(dbSkip())
						EndDo
						nValAdto += nValFIE
					EndIf

					//para que o calc da PA não seja executado com base na qtd de itens do pedido
					lPACalc := (FunName() == "FINC021" .or. FunName() == "FINA701")

					If lPACalc .And. nValPagAnt > 0 .And. TcSrvType() != "AS/400" .And. nTotRegSC7 == 0 .And. lSE2Excl
						aReaAt := GetArea()

						If __oMovPA == Nil
							cQuery := "SELECT COUNT(DISTINCT SC7.C7_DATPRF) TOTREGSC7 "
							cQuery += "FROM " + RetSqlName("SC7") + " SC7 "
							cQuery += "JOIN " + RetSqlName("FIE") + " FIE "
							cQuery += "ON (SC7.C7_NUM = FIE.FIE_PEDIDO AND SC7.C7_FILIAL = FIE.FIE_FILIAL) "
							cQuery += "JOIN " + RetSqlName("SE2") + " SE2 "
							cQuery += "ON (FIE.FIE_PREFIX = SE2.E2_PREFIXO AND FIE.FIE_NUM = SE2.E2_NUM AND "
							cQuery += "FIE.FIE_PARCEL = SE2.E2_PARCELA AND FIE.FIE_LOJA = SE2.E2_LOJA AND "
							cQuery += "FIE.FIE_FILIAL = SE2.E2_FILIAL AND "
							cQuery += "FIE.FIE_TIPO = SE2.E2_TIPO AND FIE.FIE_FORNEC = SE2.E2_FORNECE ) "
							cQuery += "JOIN " + RetSqlName("SE4") + " SE4 "
							cQuery += "ON (SC7.C7_COND = SE4.E4_CODIGO) "
							cQuery += "WHERE SC7.C7_NUM = ? AND "
							cQuery += "SC7.C7_FILIAL = ? AND "
							cQuery += "FIE.FIE_CART = 'P' AND FIE.FIE_TIPO IN('PA') AND "
							If lAdComPart
								cQuery += " ((FIE_FILORI = '"+cFilant+"') OR (FIE_FILORI = ' '))"
							EndIf
							cQuery += "SC7.D_E_L_E_T_ = ' ' AND "
							cQuery += "SE2.D_E_L_E_T_ = ' ' AND "
							cQuery += "FIE.D_E_L_E_T_ = ' ' AND "
							cQuery += "SE4.D_E_L_E_T_ = ' ' "

							cQuery := ChangeQuery(cQuery)
							__oMovPA := FWPreparedStatement():New(cQuery)
						EndIf

						__oMovPA:SetString(1, cNumPed)
						__oMovPA:SetString(2, xFilial("SC7"))

						cQry := __oMovPA:GetFixQuery()
						cTblTmp := MpSysOpenQuery(cQry)

						If (cTblTmp)->(!Eof())
							nTotRegSC7 := (cTblTmp)->TOTREGSC7
						EndIf
						(cTblTmp)->(DbCloseArea())

						If nTotRegSC7 > 1
							nValPagAnt := (nValPagAnt/nTotRegSC7)
						ElseIf nTotRegSC7 == 0
							SC7->(dbSkip())
							Loop
						EndIf

						RestArea(aReaAt)
					EndIf

					dbSelectArea("SC7")

					//------------------------------------------
					// Calcula o reajuste do pedido de compra
					//------------------------------------------
					dData := SC7->C7_DATPRF
					nPos := Ascan(aData, { |x| x[1] == SC7->C7_DATPRF } )
					If nPos == 0
						dData := DataValida(SC7->C7_DATPRF)
						aadd(aData, {SC7->C7_DATPRF, dData})
					Else
						dData := aData[nPos, 2]
					EndIf

					If lF021DtFl
						dData := Execblock("FC021DTF",.F.,.F.,{"SC7","SC7"})
					ElseIf lConsDtBase
						dData := Iif(SC7->C7_DATPRF < dDataBase, dDataBase, dData)
					Endif

					If SC7->C7_MOEDA != nMoeda .or. SC7->C7_MOEDA > 1
						nTaxaMoed:= If(Empty(SC7->C7_TXMOEDA), RecMoeda(dData,SC7->C7_MOEDA), SC7->C7_TXMOEDA)
					EndIf

					nPrcCompra := SC7->C7_PRECO
					If SC7->C7_MOEDA != nMoeda
						nPrcCompra := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,nMoeda,dData,nDecimais, nTaxaMoed)
					EndIf

					If !Empty(SC7->C7_REAJUST)
						nPrcCompra := fc020Form(SC7->C7_REAJUST, dData)
					Endif

					nDespFrete := SC7->C7_VALFRE + SC7->C7_SEGURO + SC7->C7_DESPESA
					If SC7->C7_MOEDA != nMoeda
						nDespFrete := xMoeda(SC7->C7_VALFRE + SC7->C7_SEGURO + SC7->C7_DESPESA,SC7->C7_MOEDA,nMoeda,dData,nDecimais, nTaxaMoed)
					EndIf

					//Reiniciando variaveis
					nValTot	  	:= ((SC7->C7_QUANT-SC7->C7_QUJE) * nPrcCompra ) + nDespFrete
					nValIPILiq  := nValTot
					nValIPI	  	:= 0
					nTotDesc	:= SC7->C7_VLDESC

					If nTotDesc == 0
						nTotDesc := CalcDesc(nValTot,SC7->C7_DESC1,SC7->C7_DESC2,SC7->C7_DESC3)
					Else

						//-----------------------------------------------------------
						// Consulta o desconto de pedidos com entrega parcial
						//-----------------------------------------------------------

						If lFincFluxo .and. !lF021DtFl
							If (nTotDesc := SC7->SALDO) < 0	//Consulta o Saldo de desconto não aplicado, considerando C7_VLDESC - D1_VALDESC.
								nTotDesc := 0				//Se o desconto D1_VALDESC está acima do planejado em C7_VLDESC, o sistema não vai considerar desconto p/ o saldo restante do pedido.
							EndIf
						Else

							nTotDesc := ((SC7->C7_VLDESC * (nValTot - nDespFrete))/SC7->C7_TOTAL)

						Endif

					EndIf

					nValTot	  := nValTot - nTotDesc

					IF SC7->C7_IPI > 0
						If SC7->C7_IPIBRUT != "L"
							nBaseIPI := nValTot
						Else
							nBaseIPI := nValIPILiq
						Endif
						IF SF4->F4_BASEIPI > 0
							nBaseIPI *= SF4->F4_BASEIPI / 100
						Endif
						nValIPI := IIf(nBaseIPI = 0, 0, nBaseIPI * SC7->C7_IPI / 100)
					Endif
					nValTot  += nValIPI
					dbSelectArea("SE4")
					dbSeek(xFilial("SE4")+SC7->C7_COND)
					nValTot  *= (SE4->E4_ACRSFIN/100)+1
					dbSelectArea("SC7")
					If lFc020Com		// Retornar a condicao do Item e do Total
						aVenc := ExecBlock("FC020COM",.F.,.F.,{SC7->C7_NUM,SC7->C7_ITEM,nValTot,cCond,nValIpi,dData})
					Else
						aVenc := Condicao(nValTot,cCond,nValIpi,dData)
					Endif

					IF Len(aVenc) > 0
						// Posiciona no fornecedor para buscar a natureza
						DbSelectArea("SA2")
						DbSetOrder(1)
						MsSeek(xFilial("SA2")+SC7->C7_FORNECE+SC7->C7_LOJA)
						cNatureza := PAd(If(Empty(SA2->A2_NATUREZ), "PC", SA2->A2_NATUREZ ), Len(SED->ED_CODIGO))

						For i:=1 To Len(aVenc)

							If i==1 //Só deve considerar o adiantamento na primeira parcela, para refletir o processo de compensação automatica
								If (nValAdto-nValPagAnt) > aVenc[i][2]
									nVlPAItem := aVenc[i][2]
								Else
									nVlPAItem := (nValAdto-nValPagAnt)
								EndIf

								nValPagAnt += nVlPAItem

								If nValPagAnt > nValAdto
									nValPagAnt := nValAdto
								Endif
							ELSE
								nVlPAItem := 0
							EndIf

							nPosData := Ascan(aDataAux, {|e| e[1] == aVenc[i][1]})
							If nPosData == 0
								dDataFluxo := DataValida(aVenc[i][1])
								AADD(aDataAux, {aVenc[i][1], dDataFluxo})
							Else
								dDataFluxo := aDataAux[nPosData][2]
							Endif

							// Verifico se a data já foi validada
							If lAnalitic
								nL := Ascan(aCompras, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza .And. e[5] == cNumPed .And. e[6] == cFilPed})
							Else
								nL := Ascan(aCompras, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza } )
							Endif

							IF nL != 0
								aCompras[nL][2] += aVenc[i][2]
								aCompras[nL][4] += nVlPAItem
							Else
								AADD(aCompras, {dDataFluxo, aVenc[i][2], cNatureza, nVlPAItem, cNumPed, cFilPed})
								AADD(adCompras, dDataFluxo)
							Endif

							// Se foi enviado o arquivo temporario para geracao do fluxo de caixa analitico, gera o pedido de compra neste arquivo
							If cAliasPc != Nil
								DbSelectArea(cAliasPc)
								nAscan := AScan(aPeriodo, {|e| e[1] == dDataFluxo})
								// Se a data do pedido ja venceu, insere na primeira data do fluxo
								If dDataFluxo < aPeriodo[1][1]
									dDataFluxo := aPeriodo[1][1]
									nAscan := 1
								EndIf
								If nAscan > 0
									lInclusao := .T.
									(cAliasPc)->(DbSetOrder(nOrdTmp))
									If (cAliasPc)->(DbSeek(&(cChaveTmp)))
										lInclusao := .F.
									EndIf

									RecLock(cAliasPc, lInclusao)
									If lInclusao
										If lSC7Exclus
											(cAliasPc)->FILIAL	:= SC7->C7_FILIAL
										EndIf
										(cAliasPc)->DATAX	:= dDataFluxo
										(cAliasPc)->PERIODO	:= aPeriodo[nAscan][2]
										(cAliasPc)->NUMERO	:= SC7->C7_NUM
										(cAliasPc)->EMISSAO	:= SC7->C7_EMISSAO
										(cAliasPc)->CLIFOR	:= SC7->C7_FORNECE
										(cAliasPc)->TIPO	:= SC7->C7_TIPO
										(cAliasPc)->ITEM	:= SC7->C7_ITEM
										// Posiciona no fornecedor para buscar o nome
										SA2->(DbSetOrder(1))
										SA2->(MsSeek(FwXFilial("SA2") + SC7->C7_FORNECE + SC7->C7_LOJA))
										(cAliasPc)->NOMCLIFOR	:= SA2->A2_NOME
										(cAliasPc)->PRODUTO		:= SC7->C7_PRODUTO
										(cAliasPc)->NATUREZA	:= SA2->A2_NATUREZ
										(cAliasPc)->CHAVE		:= FwXFilial("SC7") + SC7->C7_NUM + SC7->C7_ITEM + SC7->C7_SEQUEN
									EndIf

									(cAliasPc)->SALDO += aVenc[i][2]
									If i == 1
										(cAliasPc)->VALPAGANT := nValPagAnt
									EndIf

									(cAliasPc)->(MsUnlock())

									// Pesquisa na matriz de totais, os totais de pedidos de compra da data de trabalho.
									If aTotais # Nil
										nAscan := Ascan( aTotais[3], {|e| e[1] == (cAliasPc)->DATAX})
										If nAscan == 0
											Aadd( aTotais[3], {(cAliasPc)->DATAX,aVenc[i][2]})
										Else
											aTotais[3][nAscan][2] += aVenc[i][2] //(cAliasPc)->SALDO // Totaliza os pedidos de compra
										EndIf
									EndIf
								EndIf
								(cAliasPc)->(DbSetOrder(1))
							EndIf
						Next i
					EndIf
					DbSelectArea("SC7")
					SC7->(DbSkip())
				EndDo
				nValPagAnt	:= 0
				lPACalc		:= .F.
				nTotRegSC7	:= 0
				nValAdto	:= 0
			EndDo

			DbSelectArea("SC7")
			DbCloseArea()
			ChKFile("SC7")
			DbSelectArea("SC7")
			DbSetOrder(1)

			If Empty(xFilial("SC7"))
				Exit
			Endif
		EndIf
	Next

	If __oMovPA <> Nil
		__oMovPA:Destroy()
	EndIf
	cFilAnt := cSaveFil // recupera variavel cFilAnt

Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FC020VENDA

Monta array com Pedidos de Venda (Fluxos de caixa).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	06/07/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fc020Venda(cMoedas, cAliasPv, aTotais, lRegua, nMoeda, aPeriodo, cFilIni, cFilFin, aCCustos, cRiscoDe, cRiscoAte, aSelFil, lAnalitic,lTxMoePed)

Local cNumPed
Local cCond
Local nValTot		:= 0
Local nValIpi		:= 0
Local aVenc			:= {}
Local i
Local nPrcVen
Local dData
Local lFc020Vda		:= ExistBlock("FC020VDA")
Local lFc020Vdb		:= ExistBlock("FC020VDB")
Local lFc020Vdc		:= ExistBlock("FC020VDC")
Local lFC020VQR		:= ExistBlock("FC020VQR")
Local cFilDe
Local cFilAte
Local cFilPed
Local bSelFil
Local cSaveFil		:= cFilAnt
Local nAscan
Local dDataFluxo	:= {}
Local aDataAux		:= {}
Local nPosData 		:= 0
Local aDesp			:= {}
Local lPedido		:= .T.
Local lFirst		:= .T.
Local nDespFrete	:= 0
Local lMoedaFre		:= (SuperGetMv("MV_FRETMOE") == "S")
Local nDecimais		:= TamSx3("C6_PRCVEN")[2]
Local cAliasSc6		:= "SC6"
Local nInc			:= 0
Local aSM0			:= AdmAbreSM0()
Local lF021DtFl		:= Existblock("FC021DTF")
Local cCustos		:= ''
Local lFinc024		:= FwIsInCallStack("FINC024")
Local nX			:= 0
Local nI			:= 0
Local aStru			:= SC6->(dbStruct())
Local cQuery
Local nValRecAnt	:= 0
Local nTaxaMoeda    := 0
Local lSldPcFIe		:= FindFunction("SldPcFIe")

Default nMoeda		:= 1
Default cFilIni		:= Space( FWGETTAMFILIAL)
Default cFilFin		:= Replicate( "Z", FWGETTAMFILIAL)
Default aCCustos	:= {}
Default cRiscoDe	:= ''
Default cRiscoAte	:= ''
Default lAnalitic   := .F.
Default cMoedas		:= "012345"
Default lTxMoePed   := .F.

// Verifica o tipo de filtro de filial.
If empty(aSelFil)
	bSelFil := {|cFilInc| aScan(aSelFil, cFilInc) > 0}
Else
	If mv_par03 == 2		// por empresa
		cFilDe	:= cFilIni
		cFilAte := cFilFin
	Else					// por filial
		cFilDe	:= cFilAnt
		cFilAte := cFilAnt
	Endif
	bSelFil := {|cFilInc| AllTrim(cFilInc) >= Alltrim(cFilDe) .And. AllTrim(cFilInc) <= Alltrim(cFilAte)}
Endif

If lFinc024
	For nX := 1 To Len(aCCustos)
		cCustos += "'" + aCCustos[nX] + "',"
	Next nX
	cCustos := Substr(cCustos, 1, Len(cCustos) - 1)
EndIf

For nInc := 1 To Len( aSM0 )
	If aSM0[nInc][1] == cEmpAnt .And. Eval(bSelFil, aSM0[nInc][2])
		cFilAnt := aSM0[nInc][2]

		//--------------------------
		// Ler Pedidos de Venda
		//--------------------------
		dbSelectArea("SC6")
		dbSetOrder(1)
		dbSeek(xFilial())

		cAliasSc6 := GetNextAlias()

		If lFinc024
			If lF021DtFl
				cQuery := "SELECT * "
			Else
				cQuery := "SELECT C6_FILIAL, C6_NUM, C6_ITEM, C6_BLQ,C6_QTDENT,C6_QTDVEN, C6_TES, C6_ENTREG, C6_PRODUTO,C6_PRCVEN "
			EndIf

			cQuery += "  FROM "+	RetSqlName("SC5") + " SC5
			//Filtra o cliente pelo risco.
			cQuery += " JOIN "+ RetSqlName("SA1")  + " ON A1_COD = C5_CLIENT AND A1_LOJA = C5_LOJACLI AND "
			cQuery += " A1_RISCO >='" + cRiscoDe  + "' AND "
			cQuery += " A1_RISCO <='" + cRiscoAte +"',"

			cQuery +=           	RetSqlName("SC6") + " SC6 "
			cQuery += " WHERE SC6.C6_FILIAL = '" + xFilial("SC6") + "'"
			cQuery += " AND SC6.C6_BLQ <> 'R'"
			cQuery += " AND SC6.C6_BLQ <> 'S'"
			cQuery += " AND SC6.C6_QTDENT < SC6.C6_QTDVEN"
			cQuery += " AND SC5.C5_FILIAL = '" + xFilial("SC5") + "'"
			cQuery += " AND SC6.C6_NUM = SC5.C5_NUM "
			cQuery += " AND SC6.C6_RATEIO = '2' AND " // Não filtra itens que tiveram rateio.
			If (!Empty(cCustos), cQuery += " SC6.C6_CCUSTO IN (" + cCustos + ") AND ", Nil)
			cQuery += 	RetSqlCond("SC6,SC5")

			//Faz relacionamento com a tabela AGG para filtrar o centro de custo.
			cQuery += " UNION ALL "

			cQuery += "SELECT C6_FILIAL, C6_NUM, C6_ITEM, C6_BLQ,C6_QTDENT,C6_QTDVEN, C6_TES, C6_ENTREG, C6_PRODUTO, "
			cQuery += "(C6_PRCVEN * AGG_PERC)/100"
			cQuery += "  FROM "+	RetSqlName("SC5") + " SC5
							//Filtra o cliente pelo risco.
			cQuery += " JOIN "+ RetSqlName("SA1")  + " ON A1_COD = C5_CLIENT AND A1_LOJA = C5_LOJACLI AND "
			cQuery += " A1_RISCO >='" + cRiscoDe  + "' AND "
			cQuery += " A1_RISCO <='" + cRiscoAte +"',"

			cQuery +=          	RetSqlName("SC6") + " SC6  "
			cQuery += "  JOIN "+	RetSqlName("AGG") + " AGG ON AGG_PEDIDO = C6_NUM AND AGG_ITEMPD = C6_ITEM "
			If (!Empty(cCustos), cQuery += " AND AGG_CC IN (" + cCustos + ") ", Nil)
			cQuery += " WHERE SC6.C6_FILIAL = '" + xFilial("SC6") + "'"
			cQuery += " AND SC6.C6_BLQ <> 'R'"
			cQuery += " AND SC6.C6_BLQ <> 'S'"
			cQuery += " AND SC6.C6_QTDENT < SC6.C6_QTDVEN"
			cQuery += " AND SC5.C5_FILIAL = '" + xFilial("SC5") + "'"
			cQuery += " AND SC6.C6_NUM = SC5.C5_NUM AND "
			cQuery += 	RetSqlCond("SC6,SC5,AGG")

		Else
			If lF021DtFl
				cQuery := "SELECT * "
			Else
				cQuery := "SELECT DISTINCT C6_FILIAL, C6_NUM, C6_ITEM, C6_BLQ,C6_QTDENT,C6_QTDVEN, C6_TES, C6_PRCVEN, C6_ENTREG, C6_PRODUTO "
			EndIf

			cQuery += "  FROM " +	RetSqlName("SC6") + " SC6, "
			cQuery +=           	RetSqlName("SC5") + " SC5 "
			cQuery += " WHERE SC6.C6_FILIAL = '" + xFilial("SC6") + "'"
			cQuery += " AND SC6.C6_BLQ <> 'R'"
			cQuery += " AND SC6.C6_BLQ <> 'S'"
			cQuery += " AND SC6.C6_QTDENT < SC6.C6_QTDVEN"
			cQuery += " AND SC5.C5_FILIAL = '" + xFilial("SC5") + "'"
			cQuery += " AND SC6.C6_NUM = SC5.C5_NUM "
			cQuery += " AND SC5.D_E_L_E_T_ = ' ' "
			cQuery += " AND SC6.D_E_L_E_T_ = ' ' "
		EndIf

		If lFC020VQR
			cQuery += ExecBlock("FC020VQR",.F.,.F.)
		EndIf

		cQuery += " ORDER BY C6_FILIAL, C6_NUM, C6_ITEM "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasSc6, .F., .T.)

		For nI := 1 to Len(aStru)
			If aStru[nI,2] != 'C'  .And. FieldPos(aStru[nI,1]) > 0
				TCSetField(cAliasSc6, aStru[nI,1], aStru[nI,2],aStru[nI,3],aStru[nI,4])
			Endif
		Next nI

		While (cAliasSc6)->(!Eof()) .AND. (cAliasSc6)->C6_FILIAL == xFilial("SC6")

			cFilPed := (cAliasSc6)->C6_FILIAL
			cNumPed := (cAliasSc6)->C6_NUM
			nValTot := 0
			nValIpi := 0
			aVenc := {}
			aDesp := {}
			lPedido := .T.
			lFirst:= .T.
			While (cAliasSc6)->(!Eof()) .and. (cAliasSc6)->C6_NUM == cNumPed .and. xFilial("SC6") == (cAliasSc6)->C6_FILIAL
				If lRegua != Nil .And. lRegua
					IncProc(STR0069)  // "Processando Pedidos de vendas"
				Endif
				If lFc020Vdb
					SF4->(dbSetOrder(1))
					If SF4->(!dbSeek(xFilial() + (cAliasSc6)->C6_TES, .F.) .Or. F4_DUPLIC == "N")
						(cAliasSc6)->(dbSkip())
						Loop
					Endif
				Endif
				dbSelectArea("SC5")
				SC5->(MsSeek( xFilial("SC5")+cNumPed ))
				If (STR(SC5->C5_MOEDA,1) $ cMoedas)
					cCond := SC5->C5_CONDPAG

					//Verifica se existe a função SldPCFIE
					If lSldPcFIe
						nValRecAnt += SldPCFIE(cNumPed,'R',0,{|| FIE->FIE_TIPO $ MVRECANT } )
					Else
						dbSelectArea("FIE")  // Tabela Pedidos x Adiantamentos
						FIE->(dbSetOrder(1))
						FIE->(dbGoTop())
						FIE->(MsSeek(xFilial("FIE")+"R"+cNumPed))
						While FIE->(!EOF()) .And. FIE->FIE_PEDIDO == cNumPed
							If FIE->FIE_TIPO $ MVRECANT
								nValRecAnt += FIE->FIE_VALOR  	// Valor do Adiantamento
							EndIf
							FIE->(dbSkip())
						EndDo
					Endif

					If lFc020Vdc
						/*
							Este PE foi criado para substituir os PEs FC021DTF(para Vendas) e FC020VDA/FC020VDB
							Recomenda-se o uso/migração para este novo PE FC020VDC -> onde se espera o retorno de todos os valores do pedido inteiro, semelhante ao aVenc := Ma410Fluxo(cNumPed,.F.)

							Motivo da substituição:
							1) A data do PE FC021DTF não é utilizada para o fluxo em si, somente utilizada somente para reajuste de preço e fluxo dos valores de frete/despesa/seguro ( função condição() ) . Diferente do
							2) Para vendas é passado apenas 1 vez por pedido no laço e não por item,  como os PEs FC020VDA/FC020VDB sugerem
							3) O tratamento para Frete/Despesa/Seguro logo após os PEs não é possível manipular pelo PE, sendo utilizada condicao(), podendo ficar "descasado" do tratamento do PE
						*/
						aVenc := ExecBlock("FC020VDC",.F.,.F.,{(cAliasSc6)->C6_NUM})
						If ValType(aVenc) <> 'A' .OR. Len(aVenc) <= 0
							aVenc := Ma410Fluxo((cAliasSc6)->C6_NUM,.F.)
						EndIf

					ElseIf lFc020Vdb
						dbSelectArea(cAliasSc6)

						//----------------------------------------
						// Calcula o reajuste do pedido de venda
						//----------------------------------------
						nPrcVen := (cAliasSc6)->C6_PRCVEN
						If lF021DtFl
							dData := Execblock("FC021DTF",.F.,.F.,{"SC6",cAliasSc6})
						Else
							dData := Iif( (cAliasSc6)->C6_ENTREG < dDataBase, dDataBase, (DataValida((cAliasSc6)->C6_ENTREG)))
						Endif

						IF !Empty(SC5->C5_REAJUST)
							nPrcVen := fc020Form(SC5->C5_REAJUST,dData)
						Endif
						nPrcVen := xMoeda(nPrcVen,SC5->C5_MOEDA,nMoeda,dData,nDecimais)

						nValTot	:= ((cAliasSc6)->(C6_QTDVEN-C6_QTDENT)) * nPrcVen
						cProd 	:= (cAliasSc6)->C6_PRODUTO
						dbSelectArea("SB1")
						dbSeek(xFilial("SB1")+cProd)
						dbSelectArea(cAliasSc6)
						nValIPI	:= 0
						IF SF4->F4_IPI == "S" .And. SB1->B1_IPI > 0
							nBaseIPI :=((cAliasSc6)->(C6_QTDVEN-C6_QTDENT))*nPrcVen
							If SF4->F4_BASEIPI > 0
								nBaseIPI*=(SF4->F4_BASEIPI/100)
							Endif
							nValIpi  :=IIf(nBaseIPI=0,0,(nBaseIPI*SB1->B1_IPI)/100)
						Endif
						nValTot += nValIPI
						nValTot *= (SC5->C5_ACRSFIN/100)+1
						dbSelectArea(cAliasSc6)

						If lFc020Vda // Retornar a condicao do Item e do Total
							aVenc := ExecBlock("FC020VDA",.F.,.F.,{(cAliasSc6)->C6_NUM,(cAliasSc6)->C6_ITEM,nValTot,cCond,nValIpi,dData})
						Else
						  	aVenc := ExecBlock("FC020VDB",.F.,.F.,{(cAliasSc6)->C6_NUM,(cAliasSc6)->C6_ITEM,nValTot,cCond,nValIpi,dData})
						Endif
						If Len(aVenc) > 0
							If lPedido
								//Despesas, Seguro e Frete
								nDespFrete := xMoeda(SC5->C5_FRETE+SC5->C5_SEGURO+SC5->C5_DESPESA,If(lMoedaFre,SC5->C5_MOEDA,1),mv_par02,dData,nDecimais)
								aDesp := Condicao(nDespFrete,cCond,,dData)
								lPedido := .F.
								If Len(aDesp) > 0
									DbSelectArea("SA1")
									DbSetOrder(1)
									MsSeek(xFilial("SA1")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
									cNatureza := Pad(If(Empty(SA1->A1_NATUREZ), "PV", SA1->A1_NATUREZ ), Len(SED->ED_CODIGO))
									For i := 1 To Len(aDesp)
										dDataFluxo := DataValida(aDesp[i][1])
										If lAnalitic
											nL := Ascan(aVendas, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza .And. e[5] == cNumPed .And. e[6] == cFilPed})
										Else
											nL := Ascan(aVendas, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza})
										Endif
										IF nL != 0
											aVendas[nL][2]+=aDesp[i][2]
											aVendas[nL][4]+=nValRecAnt
										Else
											AADD(aVendas, {dDataFluxo, aDesp[i][2], cNatureza, nValRecAnt, cNumPed, cFilPed})
											AADD(aDVendas, dDataFluxo)
										Endif
									Next i
								Endif
							Endif
						Endif
					Else
						aVenc := Ma410Fluxo(cNumPed,.F.)
						For i := 1 To Len(aVenc)
							If SC5->C5_MOEDA != nMoeda .or. SC5->C5_MOEDA > 1
								If lTxMoePed
									nTaxaMoeda := SC5->C5_TXMOEDA
								Else
									nTaxaMoeda := RecMoeda(aVenc[i][1],SC5->C5_MOEDA)
								EndIf
							EndIf

							If SC5->C5_MOEDA != nMoeda
								aVenc[i][2] := xMoeda(aVenc[i][2], SC5->C5_MOEDA, nMoeda, aVenc[i][1], nDecimais,nTaxaMoeda)
							Endif
						Next
					Endif

					// Parcelas do Pedido
					DbSelectArea("SA1")
					DbSetOrder(1)
					MsSeek(xFilial("SA1")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
					cNatureza := Pad(If(Empty(SA1->A1_NATUREZ), "PV", SA1->A1_NATUREZ ), Len(SED->ED_CODIGO))

					dbSelectArea("FIE")  // Tabela Pedidos x Adiantamentos
					FIE->(dbSetOrder(1))
					If FIE->(dbSeek(xFilial("FIE")+"R"+cNumPed))
						nValRecAnt := 0
						While FIE->(FIE_FILIAL+FIE_CART+FIE_PEDIDO) == xFilial("FIE")+"R"+cNumPed
							If FIE->FIE_TIPO $ MVRECANT
							/* - Moeda do RA for diferente da moeda solicitada na consulta
								- Posiciono na RA no SE1 para verifica a moeda do RA							    */
								dbSelectArea("SE1")
								dbSetOrder(1)
								If dbSeek(xFilial("SE1")+FIE->(FIE_PREFIX+FIE->FIE_NUM+FIE_PARCEL+FIE_TIPO))
									If SE1->E1_MOEDA != nMoeda
										nValRecAnt += xMoeda(FIE->FIE_VALOR, SE1->E1_MOEDA, nMoeda, dDataFluxo)
									Else
										nValRecAnt += FIE->FIE_VALOR
									EndIf
								Endif
							EndIf
							FIE->(dbSkip())
						Enddo
					EndIf

					For i := 1 To Len(aVenc)

						If i==1 //Só deve considerar o adiantamento na primeira parcela, como é feito no compras
							If nValRecAnt > aVenc[i][2]
								nValRecAnt := aVenc[i][2]
							EndIf
						Else
							nValRecAnt := 0
						EndIf

						nPosData := Ascan(aDataAux, {|e| e[1] == aVenc[i][1]})
						If nPosData == 0
							dDataFluxo := DataValida(aVenc[i][1])
							AADD(aDataAux, {aVenc[i][1], dDataFluxo})
						Else
							dDataFluxo := aDataAux[nPosData][2]
						Endif

						If lAnalitic
							nL := Ascan(aVendas, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza .And. e[5] == cNumPed .And. e[6] == cFilPed})
						Else
							nL := Ascan(aVendas, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza})
						Endif
						IF nL != 0
							aVendas[nL][2]+=aVenc[i][2]
							aVendas[nL][4]+=nValRecAnt
						Else
							AADD(aVendas, {dDataFluxo, aVenc[i][2], cNatureza, nValRecAnt, cNumPed, cFilPed})
							AADD(aDVendas, dDataFluxo)
						Endif

						// Se foi enviado o arquivo temporario para geracao do fluxo
						// de caixa analitico, gera o pedido de venda neste arquivo
						If cAliasPv != Nil
							DbSelectArea(cAliasPv)
							nAscan := Ascan(aPeriodo, {|e| e[1] == dDataFluxo})
							// Se a data do pedido ja venceu, insere na primeira data do fluxo
							If dDataFluxo < aPeriodo[1][1]
								dDataFluxo := aPeriodo[1][1]
								nAscan := 1
							Endif
							If nAscan > 0
								If !dbSeek(dTos(dDataFluxo)+SC5->C5_NUM)
									RecLock(cAliasPv,.T.)
									(cAliasPv)->DATAX  := dDataFluxo
									(cAliasPv)->Periodo:= aPeriodo[nAscan][2]
									(cAliasPv)->NUMERO := SC5->C5_NUM
									(cAliasPv)->EMISSAO:= SC5->C5_EMISSAO
									(cAliasPv)->CLIFOR := SC5->C5_CLIENTE
									(cAliasPv)->LOJAENT:= SC5->C5_LOJAENT
									(cAliasPv)->LOJACLI:= SC5->C5_LOJACLI
									(cAliasPv)->TIPO   := SC5->C5_TIPO
									// Posiciona no cliente para buscar o nome
									If SC5->C5_TIPO=="D"
										DbSelectArea("SA2")
										DbSetOrder(1)
										MsSeek(xFilial("SA2")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
										DbSelectArea(cAliasPv)
										(cAliasPv)->NOMCLIFOR:= SA2->A2_NOME
										(cAliasPv)->CHAVE  := xFilial("SC5")+SC5->C5_NUM
									Else
										DbSelectArea("SA1")
										DbSetOrder(1)
										MsSeek(xFilial("SA1")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
										DbSelectArea(cAliasPv)
										(cAliasPv)->NOMCLIFOR:= SA1->A1_NOME
										(cAliasPv)->CHAVE  := xFilial("SC5")+SC5->C5_NUM
									Endif
								Else
									RecLock(cAliasPv,.F.)
								Endif

								//Somo a despesa/Frete/Seguro relativa a parcela apenas uma vez
								//Se refere ao valor da parcela e nao do item
								IF Len(aDesp) > 0 .and. lFirst
									nValDfs := aDesp[i][2]
									lFirst := .F.
								Else
									nValDfs := 0
								Endif
	         					(cAliasPv)->SALDO  += aVenc[i][2]+ nValDfs
	         					(cAliasPv)->VALRECANT += nValRecAnt

								// Pesquisa na matriz de totais, os totais de pedidos de compra
								// da data de trabalho.
								nAscan := Ascan( aTotais[4], {|e| e[1] == (cAliasPv)->DATAX})
								If nAscan == 0
									Aadd( aTotais[4], {(cAliasPv)->DATAX,aVenc[i][2]+ nValDfs})
								Else
									aTotais[4][nAscan][2] += aVenc[i][2]+ nValDfs // Totaliza os pedidos de venda
								Endif
							Endif
						Endif
					Next i
				Endif
				dbSelectArea(cAliasSc6)

				// Vai para o proximo pedido, pois a Ma410Fluxo ja processou todos
				// o itens, e se nao for para proximo pedido, os dados ficarao duplicados
				While (cAliasSc6)->(!Eof()) .And. (cAliasSc6)->C6_NUM == cNumPed .And. xFilial("SC6") == (cAliasSc6)->C6_FILIAL
					dbSkip()
				EndDo

			EndDo
			nValRecAnt := 0
		EndDo

		dbSelectArea(cAliasSc6)
		dbCloseArea()
		dbSelectArea("SC6")
		dbSetOrder(1)

		If Empty(xFilial("SC6"))
			Exit
		Endif
	EndIf
Next nInc

cFilAnt := cSaveFil // recupera variavel cFilAnt

Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GATCLI

Funcao da regra dos gatilhos do campo E1_CLIENTE..
Arquivo original: FINXFUN.PRX

@Author	Adrianne Furtado
@since	15/06/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function GatCli(cDomin)
Local cRet

If cDomin == "E1_NOMCLI"
	If SA1->(A1_COD) == M->(E1_CLIENTE)
		cRet := SA1->A1_NREDUZ
	Else
		cRet := Posicione("SA1", 1, xFilial("SA1")+M->E1_CLIENTE, "SA1->A1_NREDUZ")
	EndIf
ElseIf cDomin == "E1_LOJA"
	cRet := SA1->A1_LOJA
EndIf

Return cRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GATFORN

Funcao da regra dos gatilhos do campo E2_FORNECE.
Arquivo original: FINXFUN.PRX

@Author	Adrianne Furtado
@since	15/06/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function GatForn(cDomin)
Local cRet

If cDomin == "E2_NOMFOR"
	If SA2->(A2_COD) == M->(E2_FORNECE)// .and. !Empty(M->E2_LOJA)
		cRet := SA2->A2_NREDUZ
	Else
		cRet := Posicione("SA2", 1, xFilial("SA2")+M->E2_FORNECE , "SA2->A2_NREDUZ" )
	EndIf
ElseIf cDomin == "E2_LOJA"
	cRet := SA2->A2_LOJA
EndIf

Return cRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA050NOME

Mostra o nome do fornecedor se a loja e codigo estiverem  preenchidos corretamente. (Gatilho).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	27/04/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FA050Nome(cCodOuLoj)

Local lRetorna := .T.
Local nValor 	:= 0
Local nPercIss := 0

If lRetorna
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso altere o Fornecedor e este n†o recolha ISS							³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(m->e2_naturez)
		nValor		:= m->e2_valor + m->e2_iss + m->e2_irrf + m->e2_inss
		m->e2_valor += m->e2_iss
		m->e2_iss	:= 0
		nOldIss		:= 0
		If SED->ED_CALCISS == "S" .And. SA2->A2_RECISS != "S"
			nPercIss := GetMV("MV_ALIQISS")
			If ExistBlock("F050PISS")
				nPercIss := ExecBlock("F050PISS",.F.,.F.)
			Endif
			m->e2_iss := (nValor) * nPercIss / 100
		EndIf
		If m->e2_tipo $ MVPROVIS+"/"+MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG
			m->e2_iss	:= 0
			nOldIss		:= 0
		EndIf
		m->e2_valor += m->e2_inss
		m->e2_inss	:= 0
		nOldInss		:= 0
		If SED->ED_CALCINS == "S" .And. SA2->A2_RECINSS == "S"
			m->e2_inss := (nValor) * SED->ED_PERCINS / 100
		EndIf
		If m->e2_tipo $ MVPROVIS+"/"+MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG
			m->e2_inss	:= 0
			nOldInss		:= 0
		EndIf
		m->e2_valor -= m->e2_iss + m->e2_inss

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicializa o valor em Real como sugestao									³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nSavRec := SX3->(Recno())
		cMascara:=PesqPict("SE2","E2_VLCRUZ",19)
		SX3->(DbGoto(nSavRec))
		M->E2_VLCRUZ:=xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,,M->E2_TXMOEDA)
		lRetorna := .T.
	EndIf
EndIf
If lRetorna
	lRefresh := .T.
EndIf
nOldValor := m->e2_valor
Return lRetorna


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ORDTITPAI

Função que retorna a ordem do indice E1_FILIAL + E1_TITPAI
Arquivo original: FINXFUN.PRX

@Author	Pâmela Bernardo
@since	30/10/2012
/*/
//-----------------------------------------------------------------------------------------------------
Function OrdTitpai()
Return nOrdTitPai


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RECSALBCO

Recupera o saldo bancário em uma determinada data.
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	25/07/1997
/*/
//-----------------------------------------------------------------------------------------------------
Function RecSalBco( cBanco, cAgencia, cConta, dData )

Local cAlias 		:= ALIAS()
Local nRecnoSE8		:= 0

dbSelectArea("SE8")
dbSetOrder(1)
dbSeek(xFilial()+cBanco+cAgencia+cConta+DtoS(dData),.T.)
If SE8->E8_DTSALAT==dData.and.E8_FILIAL+E8_BANCO+E8_AGENCIA+E8_CONTA==xFilial()+cBanco+cAgencia+cConta
	nSaldo := SE8->E8_SALATUA
Else
	nRecnoSE8 := SE8->(RECNO())
	SE8->(DbSkip(-1))
	If SE8->(RECNO()) <> nRecnoSE8 // DbSkip(-1) no primeiro registro
		If E8_FILIAL+E8_BANCO+E8_AGENCIA+E8_CONTA == xFilial()+cBanco+cAgencia+cConta
			nSaldo := SE8->E8_SALATUA
		Else
			nSaldo := 0
		Endif
	Else
		nSaldo := 0
	Endif
Endif
dbSelectArea( cAlias )
Return nSaldo


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FRVLCOMPFIL

Funcao que retorna o valor da compensacao de um título que  foi compensado em filiais diferentes
(FINR130/FINR150/FINR340).
Arquivo original: FINXFUN.PRX

Parametros
EXPC1 - Tipo da carteira:"R" - Contas a Receber; "P" - Contas a Pagar
EXPC2 - Prefixo do titulo principal
EXPC3 - Numero do titulo principal
EXPC4 - Parcela do titulo principal
EXPC5 - Tipo do titulo principal
EXPC6 - Fornecedor do titulo principal
EXPC7 - Loja do titulo principal
EXPC8 - Tipo de data a ser utilizada para compor o saldo do
		0 = Data Da Baixa (E5_DATA)
		1 = Data de Disponibilidade (E5_DTDISPO)
		2 = Data de Contabilidação (E5_DTDIGIT)
EXPA9  - Vetor com todas as filiais da empresa
EXPC10 - Vetor com as filiais diferentes da filial atual

@Author	Marcio Menon
@since	24/03/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function FRVlCompFil(cRecPag,cPrefixo,cNumero,cParcela,cTipo,cCliFor,cLoja,nTipoData,aFiliais,cFilQry,lAS400,nMoeda,nMoedaTit,nTxMoeda,dDataTx,lNovoCalc)
	Local aArea     := GetArea()
	Local nValor    := 0
	Local cTipoData := "0"
	Local nX        := 0
	Local cFilSE5	:= xFilial("SE5")
	Local cCpoQry   := ""
	Local cWhere    := ""
	Local nLenFil	:= 0
	Local cAliasComp := GetNextAlias()

	Default cFilQry	:= ""
	Default lAS400	:= .T.
	Default aFiliais  := {}
	Default nMoeda    := 1
	Default nMoedaTit := 1
	Default nTxMoeda  := 1
	Default dDataTx   := dDataBase
	Default lNovoCalc := .F.

	//Caso já tenha sido rodado o FIX 11 na base, esta função se torna desnecessária
	If __cMVFinFix   == NIL
		__cMVFinFix := SuperGetMv("MV_FINFIX",.F.,"")
	Endif

	If lNovoCalc
		If cRecPag == "R"
			aFiliais := GetFlBxSE5( SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ, SE1->E1_FILORIG, "R", 2, __lRelat )
		Else
			aFiliais := GetFlBxSE5( SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, SE2->E2_FILORIG, "P", 2, __lRelat )
		EndIf
	EndIf

	nLenFil := Len( aFiliais )

	// tratativa para a leitura de aFiliais. Usados nos relatorios do Financeiro
	If (!lNovoCalc .And. nLenFil <= 1) .Or. (lNovoCalc .And. nLenFil == 0)
		Return nValor
	EndIf

	nTipoData  := Iif( nTipoData == Nil, 0, nTipoData )

	//Tipos de Data (cTipoData)
	// 0 = Data Da Baixa (E5_DATA)
	// 1 = Data de Disponibilidade (E5_DTDISPO)
	// 2 = Data de Contabilidação (E5_DTDIGIT)
	If nTipoData == 1
		cTipoData := "0"
	ElseIf nTipodata == 2
		cTipoData := "1"
	Else
		cTipoData := "2"
	Endif

	//Não foi convertido para FKs devido
	//- A stored procedure da saldotit não foi convertida para FKs
	//- Caso não possua stored instalada e rodou os fixes das FKs, essa função não será chamada
	//- Caso não possua stored instalada e não rodou os fixes das FKs, essa função será chamada
	For nX := 1 To nLenFil
		If aFiliais[nX] != cFilSE5
			If !Empty( cFilQry )
				cFilQry += ", "
			Endif
			cFilQry += "'" + aFiliais[nX] + "'"
		Endif
	Next nX

	If Empty(cFilQry)
		cFilQry := "''"
	EndIf

	cQuery  := "SELECT "

	cCpoQry := "R_E_C_N_O_ "
	cCpoQry += "FROM " +RetSqlName("SE5") + " SE5 "

	//Movimentos
	cWhere := "WHERE "
	cWhere += "SE5.E5_FILIAL IN ( " + cFilQry  + " ) AND "
	cWhere += "SE5.E5_PREFIXO = '"  + cPrefixo + "' AND "
	cWhere += "SE5.E5_NUMERO = '"   + cNumero  + "' AND "
	cWhere += "SE5.E5_PARCELA = '"  + cParcela + "' AND "
	cWhere += "SE5.E5_TIPO = '"     + cTipo    + "' AND "
	cWhere += "SE5.E5_CLIFOR = '"   + cCliFor  + "' AND "
	cWhere += "SE5.E5_LOJA = '"     + cLoja    + "' AND "
	cWhere += "SE5.D_E_L_E_T_ = ' ' AND "
	cWhere += "SE5.E5_TIPODOC <> 'ES' AND "

	If !(cTipo $ MVRECANT)
		cWhere += "SE5.E5_RECPAG = '" + cRecPag + "' AND "
	EndIf
	// Falta tratativa do PA ?? // TODO
	cWhere += "SE5.E5_SEQ NOT IN ("

	//Estorno.
	cWhere += "SELECT EST.E5_SEQ FROM " + RetSqlName("SE5") + " EST "
	cWhere += "WHERE EST.E5_FILIAL IN ( " + cFilQry  + " ) AND "
	cWhere += "EST.E5_PREFIXO = '"  + cPrefixo + "' AND "
	cWhere += "EST.E5_NUMERO = '"   + cNumero  + "' AND "
	cWhere += "EST.E5_PARCELA = '"  + cParcela + "' AND "
	cWhere += "EST.E5_TIPO = '"     + cTipo    + "' AND "
	cWhere += "EST.E5_CLIFOR = '"   + cCliFor  + "' AND "
	cWhere += "EST.E5_LOJA = '"     + cLoja    + "' AND "
	cWhere += "EST.D_E_L_E_T_ = ' ' AND "
	cWhere += "EST.E5_RECPAG = '" + IIF(cRecPag == "P", "R", "P") + "' AND "
	cWhere += "EST.E5_TIPODOC = 'ES' AND E5_DATA <= '" + DTOS(dDataBase) + "') "

	cQuery  += cCpoQry
	cQuery  += cWhere

	cQuery := ChangeQuery( cQuery )

	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasComp, .T., .T. )

	// Se existir compensacao em outras filiais, realiza query completa (performance)
	If (cAliasComp)->( !EoF() )

		If cRecPag == "R"

			dbSelectArea( "SE1" )

			(cAliasComp)->( dbCloseArea() )

			cQuery	:= "SELECT "

			cCpoQry	:= "SE5.E5_FILIAL, SE5.E5_TIPODOC, SE5.E5_FILORIG, "
			cCpoQry	+= "SE5.E5_TIPO, SE5.E5_VALOR, SE5.E5_MOTBX, SE5.E5_RECPAG, SE5.E5_SITUACA, "
			cCpoQry	+= "SE5.E5_VLMULTA, SE5.E5_VLJUROS, SE5.E5_VLDESCO, "

			If cTipoData == "0"
				cCpoQry += "SE5.E5_DATA "
			ElseIf cTipoData == "1"
				cCpoQry += "SE5.E5_DTDISPO "
			Else
				cCpoQry += "SE5.E5_DTDIGIT "
			Endif

			cCpoQry  += "FROM " + RetSqlName("SE5") + " SE5, " + RetSqlName("SE1") + " SE1 "

			cWhere  += "AND "
			cWhere  += "SE1.E1_FILIAL = '"  + xFilial("SE1") + "' AND "
			cWhere  += "SE1.E1_PREFIXO = SE5.E5_PREFIXO AND "
			cWhere  += "SE1.E1_NUM = SE5.E5_NUMERO AND "
			cWhere  += "SE1.E1_PARCELA = SE5.E5_PARCELA AND "
			cWhere  += "SE1.E1_TIPO = SE5.E5_TIPO AND "
			cWhere  += "SE1.E1_CLIENTE = SE5.E5_CLIFOR AND "
			cWhere  += "SE1.E1_LOJA = SE5.E5_LOJA AND "
			cWhere  += "SE1.D_E_L_E_T_ = ' ' "

			cQuery  += cCpoQry
			cQuery  += cWhere

			cQuery := ChangeQuery( cQuery )

			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasComp, .T., .T. )
			TCSetField( cAliasComp, "E5_VALOR", "N", TamSX3("E5_VALOR")[1], TamSX3("E5_VALOR")[2] )

			If cTipoData == "0"
				TCSetField( cAliasComp, "E5_DATA", "D" )
			ElseIf cTipoData == "1"
				TCSetField( (cAliasComp), "E5_DTDISPO", "D" )
			Else
				TCSetField( (cAliasComp), "E5_DTDIGIT", "D" )
			Endif

			Do While (cAliasComp)->( !Eof() )

				If (cAliasComp)->E5_MOTBX $ "CMP|CEC" .And. (cAliasComp)->E5_FILORIG == cFilSE5 .And. (cAliasComp)->E5_SITUACA != 'C'

					If cTipoData == "0"
						lOk := ( DtoS((cAliasComp)->E5_DATA) <= DtoS(dDataBase) )
					ElseIf cTipoData == "1"
						lOk := ( DtoS((cAliasComp)->E5_DTDISPO) <= DtoS(dDataBase) )
					Else
						lOk := ( DtoS((cAliasComp)->E5_DTDIGIT) <= DtoS(dDataBase) )
					EndIf

					If lOk
						If (cAliasComp)->E5_RECPAG == cRecPag
							If (cAliasComp)->E5_TIPO $ MVRECANT+"|"+MV_CRNEG
								If (cAliasComp)->E5_TIPODOC $ "BA|VL"
									nValor += (cAliasComp)->E5_VALOR
								EndIf
							ElseIf ((cAliasComp)->E5_TIPODOC $ "CP" .Or. ((cAliasComp)->E5_TIPODOC $ "BA" .And. (cAliasComp)->E5_MOTBX $ "CMP|CEC")) .Or. (cAliasComp)->E5_TIPODOC == 'CEC'
								nValor += (cAliasComp)->E5_VALOR - ((cAliasComp)->E5_VLMULTA + (cAliasComp)->E5_VLJUROS - (cAliasComp)->E5_VLDESCO)
							EndIf
						EndIf

						If (cTipo $ MVRECANT .And. (cAliasComp)->E5_RECPAG == "P" .And. (cAliasComp)->E5_TIPODOC == "BA")
							nValor += (cAliasComp)->E5_VALOR
						EndIf
					EndIf
				EndIf

				(cAliasComp)->(dbSkip())
			EndDo
		ElseIf cRecPag == "P"

			dbSelectArea( "SE2" )

			(cAliasComp)->( dbCloseArea() )

			cQuery	:= "SELECT "

			cCpoQry	:= "SE5.E5_FILIAL, SE5.E5_TIPODOC, SE5.E5_FILORIG, "
			cCpoQry	+= "SE5.E5_TIPO, SE5.E5_VALOR, SE5.E5_MOTBX, SE5.E5_RECPAG, SE5.E5_SITUACA, "
			cCpoQry	+= "SE5.E5_VLMULTA, SE5.E5_VLJUROS, SE5.E5_VLDESCO, SE5.E5_TXMOEDA, SE5.E5_MOEDA, SE5.E5_BANCO, SE5.E5_VLMOED2, SE5.E5_DATA, "

			If cTipoData == "1"
				cCpoQry += "SE5.E5_DTDISPO "
			Else
				cCpoQry += "SE5.E5_DTDIGIT "
			Endif

			cCpoQry  += "FROM " + RetSqlName("SE5") + " SE5, " + RetSqlName("SE2") + " SE2 "

			cWhere  += "AND "
			cWhere  += "SE2.E2_FILIAL = '"  + xFilial("SE2") + "' AND "
			cWhere  += "SE2.E2_PREFIXO = SE5.E5_PREFIXO AND "
			cWhere  += "SE2.E2_NUM = SE5.E5_NUMERO AND "
			cWhere  += "SE2.E2_PARCELA = SE5.E5_PARCELA AND "
			cWhere  += "SE2.E2_TIPO = SE5.E5_TIPO AND "
			cWhere  += "SE2.E2_FORNECE = SE5.E5_CLIFOR AND "
			cWhere  += "SE2.E2_LOJA = SE5.E5_LOJA AND "
			cWhere  += "SE5.E5_MOTBX IN ('CMP', 'CEC') AND "
			cWhere  += "SE5.E5_SITUACA <> 'C' AND "
			cWhere  += "SE2.D_E_L_E_T_ = ' ' AND "
			cWhere  += "SE5.D_E_L_E_T_ = ' ' "

			cQuery  += cCpoQry
			cQuery  += cWhere
			cQuery := ChangeQuery( cQuery )

			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasComp, .T., .T. )

			TCSetField( cAliasComp, "E5_VALOR", "N", TamSX3("E5_VALOR")[1], TamSX3("E5_VALOR")[2] )
			TCSetField( cAliasComp, "E5_DATA", "D" )

			If cTipoData == "1"
				TCSetField( cAliasComp, "E5_DTDISPO", "D" )
			Else
				TCSetField( cAliasComp, "E5_DTDIGIT", "D" )
			Endif

			Do While (cAliasComp)->( !Eof() )
				If (cAliasComp)->E5_FILORIG == cFilSE5
					If cTipoData == "0"
						lOk := ( DtoS((cAliasComp)->E5_DATA) <= DtoS(dDataBase) )
					ElseIf cTipoData == "1"
						lOk := ( DtoS((cAliasComp)->E5_DTDISPO) <= DtoS(dDataBase) )
					Else
						lOk := ( DtoS((cAliasComp)->E5_DTDIGIT) <= DtoS(dDataBase) )
					EndIf

					If lOk
						If (cAliasComp)->E5_RECPAG == cRecPag
							If (cAliasComp)->E5_TIPO $ MVPAGANT+"|"+MV_CPNEG
								If (cAliasComp)->E5_TIPODOC $ "BA|VL"
									If !lNovoCalc
										nValor += (cAliasComp)->E5_VALOR
									Else
										nValor += IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty((cAliasComp)->E5_BANCO) .OR. (cAliasComp)->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),(cAliasComp)->E5_VALOR,(cAliasComp)->E5_VLMOED2)
										nValor -= xMoeda((cAliasComp)->E5_VLMULTA+(cAliasComp)->E5_VLJUROS-(cAliasComp)->E5_VLDESCO,1,nMoedaTit,(cAliasComp)->E5_DATA,3,,IIF((cAliasComp)->E5_TXMOEDA==0,nTxMoeda,(cAliasComp)->E5_TXMOEDA))
									EndIf
								EndIf
							ElseIf ((cAliasComp)->E5_TIPODOC $ "CP" .Or. ((cAliasComp)->E5_TIPODOC $ "BA" .And. (cAliasComp)->E5_MOTBX $ "CEC")) .Or. (cAliasComp)->E5_TIPODOC == 'CEC'
								If !lNovoCalc
									nValor += (cAliasComp)->E5_VALOR
								Else
									nValor += IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty((cAliasComp)->E5_BANCO) .OR. (cAliasComp)->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),(cAliasComp)->E5_VALOR,(cAliasComp)->E5_VLMOED2)
									nValor -= xMoeda((cAliasComp)->E5_VLMULTA+(cAliasComp)->E5_VLJUROS-(cAliasComp)->E5_VLDESCO,1,nMoedaTit,(cAliasComp)->E5_DATA,3,,IIF((cAliasComp)->E5_TXMOEDA==0,nTxMoeda,(cAliasComp)->E5_TXMOEDA))
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf

				(cAliasComp)->(dbSkip())
			EndDo

			If lNovoCalc
				nValor := Round(NoRound(xMoeda(nValor,nMoedaTit,nMoeda,dDataTx,Msdecimais(nMoeda)+1,nTxMoeda),Msdecimais(nMoeda)+1),Msdecimais(nMoeda))
			EndIf
		EndIf
	EndIf

	dbSelectArea(cAliasComp)
	(cAliasComp)->(dbCloseArea())

	RestArea(aArea)

Return nValor


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINRETFIL

Retorna vetor com as filiais da empresa atual (SM0) (FINR130, FINR150, FINR340).
Arquivo original: FINXFUN.PRX


@Author	Gustavo Henrique
@since	16/10/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function FinRetFil()

Local aFiliais 		:= {}
Local nInc			:= 0
Local aSM0			:= AdmAbreSM0()

For nInc := 1 To Len( aSM0 )
	If aSM0[nInc][1] == cEmpAnt
		aAdd( aFiliais, aSM0[nInc][2] )
	EndIf
Next

Return( aFiliais )


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FUNLOCKDOC

Atualiza o status do arquivo para validação de alias em uso

IMPORTANTE: Estas funções são utilizadas para processamentos multiusuários e que envolvem
a utilização de tabelas temporárias criadas diretamente no banco de dados, para garantir que
as mesmas sejam excluídas no final do processamento dos relatórios/consultas

Arquivo original: FINXFUN.PRX

@author    Marcos Berto
@version   11.80
@since     16/01/13

@param nHandle	- Handle do arquivo
@param cTabTRB	- Tabela

/*/
//------------------------------------------------------------------------------------------
Function FUnlockDoc(nHandle,cStatus)

Default nHandle 	:= 0
Default cStatus	:= ""

FWrite(nHandle,cStatus +Chr(13) + Chr(10))
FClose(nHandle)

Return


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FTRBAlias

Busca o próximo alias disponível

IMPORTANTE: Estas funções são utilizadas para processamentos multiusuários e que envolvem
a utilização de tabelas temporárias criadas diretamente no banco de dados, para garantir que
as mesmas sejam excluídas no final do processamento dos relatórios/consultas

Arquivo original: FINXFUN.PRX

@author    Marcos Berto
@version   11.80
@since     16/01/13

@param nHandle	- Handle do arquivo

@return lErase 	- Indica se a tabela temporária foi excluída.

/*/
//------------------------------------------------------------------------------------------
Function FTRBAlias()

Local cNextAlias := ""
Local aArea := GetArea()

While .T.
	cNextAlias := GetNextAlias()
	If !TCCanOpen(cNextAlias) .And. Select(cNextAlias) == 0
		Exit
	EndIf
EndDo

RestArea(aArea)

Return cNextAlias


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FLockDoc

Cria ou abre o arquivo de controle do semáforo

IMPORTANTE: Estas funções são utilizadas para processamentos multiusuários e que envolvem
a utilização de tabelas temporárias criadas diretamente no banco de dados, para garantir que
as mesmas sejam excluídas no final do processamento dos relatórios/consultas


Arquivo original: FINXFUN.PRX


@author    Marcos Berto
@version   11.80
@since     16/01/13

@param cFile	- Arquivo

@return cNomeArq 	- Nome do Arquivo que será gerado

/*/
//------------------------------------------------------------------------------------------
Function FLockDoc(cFile)

Local nHandle := 0

Default cFile := ""

If File(cFile)
	nHandle := FOpen(cFile,2)
Else
	nHandle:= FCreate(cFile)
EndIf

Return nHandle


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FCloseTRB

Gerencia a exclusao da tabela temporária no banco

IMPORTANTE: Estas funções são utilizadas para processamentos multiusuários e que envolvem
a utilização de tabelas temporárias criadas diretamente no banco de dados, para garantir que
as mesmas sejam excluídas no final do processamento dos relatórios/consultas

Arquivo original: FINXFUN.PRX

@author    Marcos Berto
@version   11.80
@since     16/01/13

@param cFile		- Arquivo de controle do alias.
@param cPrefixo	- Prefixo/Alias

/*/
//------------------------------------------------------------------------------------------
Function FCloseTRB(cFile,cPrefixo)

Local aProc 		:= {}
Local aFiles		:= {}
Local cTabTRB		:= ""
Local cFileName	:= ""
Local cMessage	:= ""
Local cDir  		:= "\Semaforo\"
Local nX			:= 0

Default cFile 	:= ""
Default cPrefixo	:= ""

//Adiciona todos os arquivos que serão processados
If !Empty(cFile)
	aAdd(aProc,cFile)
Else
	//Busca todos os arquivos do mesmo prefixo para exclusão de tabelas que não estão em uso
	aFiles := Directory(cDir+cPrefixo+"*.*")

	For nX := 1 to Len(aFiles)
		aAdd(aProc,cDir+aFiles[nX][1])
	Next nX
EndIf

For nX := 1 to Len(aProc)
	If FT_FUse(aProc[nX]) > 0

		FT_FGoTop()

		While !FT_fEof()
			cMessage := FT_FReadLn()
			FT_FSkip()
		EndDo

		cFileName 	:= RetFileName(aProc[nX])
		cTabTRB	:= SubStr(cFileName,Len(cPrefixo)+1)

		If (AllTrim(cMessage) == "OPEN" .And. TCCanOpen(cTabTRB) .And. Select(cTabTRB) == 0)
			MsErase(cTabTRB,,"TOPCONN")
		ElseIf AllTrim(cMessage) == "CLOSE"
			If Select(cPrefixo) > 0
				dbSelectArea(cPrefixo)
				(cPrefixo)->(dbClearIndex())
				(cPrefixo)->(dbCloseArea())
				MsErase(cTabTRB,,"TOPCONN")
			EndIf)
		EndIf

		//Fecha o arquivo
		FT_FUse()
		FErase(aProc[nX])

	EndIf
Next

Return


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FPrepDoc

Prepara os dados para criação dos arquivos para controle do semaforo na emissao de
relatórios e consultas

IMPORTANTE: Estas funções são utilizadas para processamentos multiusuários e que envolvem
a utilização de tabelas temporárias criadas diretamente no banco de dados, para garantir que
as mesmas sejam excluídas no final do processamento dos relatórios/consultas

Arquivo original: FINXFUN.PRX

@author    Marcos Berto
@version   11.80
@since     16/01/13

@param cTRBTab	- Tabela temporaria
@param cFilArq	- Filial em que o arquivo esta sendo processado

@return cNomeArq 	- Nome do Arquivo que será gerado

/*/
//------------------------------------------------------------------------------------------
Function FPrepDoc(cAlias,cTRBTab)

Local cDir  		:= "\Semaforo\"
Local cFileName	:= ""

Default cAlias 	:= ""
Default cTRBTab	:= ""

If !ExistDir(cDir)
	MontaDir(cDir)
EndIf

cFileName := cDir+cAlias+cTRBTab+ '.txt'

Return cFileName


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} VERIDPROC

Identifica a sequencia de controle do fonte ADVPL com a stored procedure, qualquer alteracao que envolva
diretamente a stored procedure a variavel sera incrementada. Procedure FIN002  (Ligada a SALDOTIT).
Arquivo original: FINXFUN.PRX

@Author	Marcelo Pimentel
@since	24/07/2007
/*/
//-----------------------------------------------------------------------------------------------------

Static Function VerIDProc()
Return '015'


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SALDOTIT

Retorna saldo retroativo do titulo em uma determinada data (com procedure).
Arquivo original: FINXFUN.PRX

@param cPrefixo   - Numero do Prefixo
@param cNumero    - Numero do Titulo
@param cParcela   - Parcela
@param cTipo      - Tipo
@param cNatureza  - Natureza
@param cCart      - Carteira  (R/P)
@param cCliFor    - Fornecedor(se cCart = 'R')
@param nMoeda     - Moeda
@param dData      - Data para conversao
@param dDataBaixa - Data data baixa a ser considerada (retroativa)
@param cLOja      - Loja do titulo
@param cFilTit    - Filial do titulo
@param nTxMoeda   - Taxa da Moeda
@param nTipoData  - Tipo de data para compor saldo (baixa/dispo/digit)
@param lIsTxContr - Define se a taxa contratada é taxa contratada

@Author	Vicente Sementilli
@since	05/08/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function SaldoTit(cPrefixo,cNumero,cParcela,cTipo,cNatureza,cCart,cCliFor,nMoeda,;
						dData,dDataBaixa,cLoja,cFilTit,nTxMoeda,nTipoData,lFinR,__oTBxCanc,lIsTxContr, lCmpMulFil, lForcaFK as logical)
//Tipos de Data (cTipoData ou xTipoData)
// 0 = Data Da Baixa (E5_DATA) (Default)
// 1 = Data de Disponibilidade (E5_DTDISPO)
// 2 = Data de Contabilidação (E5_DTDIGIT)

Local cErrStrPr		:= ""
Local nSaldo		:= 0
Local nVa			:= 0
Local cTipoData		:= "0"
Local cFiliOrig		:= ""
Local cIdDoc		:= ""
Local cAliasTit
Local lIRPFBaixa 	:= IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
Local cIssBx 		:= ""
Local cIrfBx    	:= Iif(lIRPFBaixa,"1","0")
Local cPCCBaixa		:= ""
Local cAdiant		:= Iif( (cTipo $ MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG), "1","0")
Local cFilialSE 	:= ""
Local aAreaAnt		:= {}

Default lForcaFK 	:= .F.

If __lBuscFK7 == NIL
	__lBuscFK7 := FWIsInCallStack("FINR130") .Or. FWIsInCallStack("FINR150") .Or. FWIsInCallStack("FINR140")
EndIf

If __lTemFK6 == NIL
	__lTemFK6	:= ExistFunc('FxLoadFK6')
Endif

If __nMoeda == NIL .or. __nMoeda <> nMoeda
	__nMoeda := nMoeda
	__nDecs  := Msdecimais(nMoeda)
Endif

If (__cUltFil == NIL) .or. !(__cUltEmp+__cUltFil == cEmpAnt+cFilAnt )
	__cUltEmp := cEmpAnt
	__cUltFil := cFilAnt

	__lPccBx	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"
	__IssBx		:= SuperGetMv("MV_MRETISS",.T.,"2") == "2"
	__cProc 	:= GetSPName("FIN002","10")

Endif

If type("ltxZero") == "U"
	ltxZero   := .F.
Else
	Default ltxZero   := .F.
Endif

cIssBx 	:= Iif(__IssBx,"1","0")
cPCCBaixa	:= Iif(__lPccBx,"1","0")

Default cFilTit		:= Iif(cFilTit == Nil,xFilial("SE5"),cFilTit)
Default nTxMoeda	:= 0
Default __lPFIN002	:= ExistProc( __cProc, VerIDProc() )
Default lFinR		:= FwIsInCallStack("FINR350")
Default lIsTxContr	:= .F.		// Define se a taxa passada é taxa contratada
Default lCmpMulFil  := .F.

dDataBaixa  := Iif( dDataBaixa == Nil , dDataBase, dDataBaixa )
dData       := Iif( dData      == Nil , dDataBase, dData )
nMoeda      := Iif( nMoeda     == Nil , 1        , nMoeda )
cLoja       := Iif( cLoja      == Nil , Iif( cCart == "R" , SE1->E1_LOJA , SE2->E2_LOJA ) , cLoja )
nTipoData   := Iif( nTipoData  == Nil , 1 , nTipoData )

If nTipoData == 1
	cTipoData := "0"  // E5_DATA
ElseIf nTipodata == 2
	cTipoData := "1"  // E5_DTDISPO
Else
	cTipoData := "2"  // E5_DTDIGIT
Endif

If __lTemFKD == NIL
	__lTemFKD	:= TableInDic("FKD")
Endif

If __lPFin002 .and. !lFinR .and. !lForcaFK .And. cPaisLoc <>'RUS'
	aResult    := {}
	lCmpMulFil := .T.
	cCliFor    := Iif(cCliFor = NIL, Iif(cCart == "R", SE1->E1_CLIENTE, SE2->E2_FORNECE), cCliFor)
	cLoja      := Iif(cLoja   = NIL, Iif(cCart == "R", SE1->E1_LOJA, SE2->E2_LOJA), cLoja)

	If cCart = "R"
		cAliasTit := "SE1"
		dbSelectArea("SE1")
		nSaldo    := (SE1->(E1_VALOR+E1_ACRESC) - SE1->E1_DECRESC)
		nMoedaTit := SE1->E1_MOEDA
		cCliFor   := Iif(Empty(cCliFor),SE1->E1_CLIENTE,cCliFor)
		cLoja     := Iif(Empty(cLoja  ),SE1->E1_LOJA,cLoja)
		cFiliOrig := SE1->E1_FILORIG
		cFilialSE := SE1->E1_FILIAL
	Else
		cAliasTit := "SE2"
		dbSelectArea("SE2")
		nSaldo    := (SE2->(E2_VALOR + E2_ACRESC) - SE2->E2_DECRESC)
		nMoedaTit := SE2->E2_MOEDA
		cFiliOrig := SE2->E2_FILORIG
		cFilialSE := SE2->E2_FILIAL
	Endif
	If __lBuscFK7
		cIdDoc := FinBuscaFK7(cFilialSE +"|"+ cPrefixo +"|"+ cNumero +"|"+ cParcela +"|"+ cTipo +"|"+ cCliFor +"|"+ cLoja, cAliasTit)
	Else
		cIdDoc := FINGRVFK7(cAliasTit, cFilialSE +"|"+ cPrefixo +"|"+ cNumero +"|"+ cParcela +"|"+ cTipo +"|"+ cCliFor +"|"+ cLoja)
	EndIf


	nMoeda    := ((nMoeda+1.00)-1.00)
	nMoedaTit := ((nMoedaTit+1.00)-1.00)

	aResult := TcSpExec( xProcedures(__cProc),;
			cPrefixo,                cNumero,;
			cParcela,                cTipo,;
			cCliFor,                 DTOS(dData),;
			DTOS(dDataBaixa),        cLoja,;
			DTOS(dDataBase),         cFilTit,;
			nSaldo,                  nMoedaTit,;
			cPaisLoc,                cTipoData,;
			cPCCBaixa,               cCart, cAdiant, cIrfBx, nTxMoeda, cIssBx, cFiliOrig )

	If aResult == Nil
		cErrStrPr := TcSqlError()
		Final( STR0089 + Iif( !Empty( cErrStrPr ) , cErrStrPr , "" ) )
	Endif

	nSaldo := aResult[1]

	// Zera o Saldo devido problema de arredondamento nos juros, ou seja, o valor dos juros que eh gravado com
	// 2 casas decimais, gera diferena na recomposicao do saldo no titulo
	// Exemplo: Titulo com valor de 24.450, com E1_PORCJUR de 0.13 e tres dias de atraso, grava em E5_JUROS o valor
	// de 95.36, sendo que o valor dos juros seria 95.355
	// Movimentacao no SE5:
	//	      Baixa	Juros	       Saldo
	//		 		            24.450,00
	//-------------------------------
	//		4.001,04	95,36 	20.544,32 3 dias apos vencto.
	//		2.100,95		      18.443,37 mesma data
	//		3.474,23		      14.969,14 mesma data
	//		6.000,00		       8.969,14 5 dias apos vencto
	//		5.060,00		       3.909,14 10 dias apos vencto
	//		3.919,29	10,16	        0,01 12 dias apos vencto
	If Empty((cAliasTit)->&(Right(cAliasTit,2)+"_SALDO")) .And. nSaldo <= 0.009
		nSaldo := 0
	Else
		If nMoeda <> nMoedaTit .AND. !lIsTxContr .AND. RecMoeda(dData,nMoedaTit) == 0
			ltxZero  := .T.
		Endif
		nSaldo := Round(NoRound(xMoeda(nSaldo,nMoedaTit,nMoeda,dData,__nDecs+1,nTxMoeda),__nDecs+1),__nDecs)
	EndIf

	If __lTemFKD .and. Select("FKD") == 0
		aAreaAnt := GetArea()
		dbSelectArea("FKD")
	EndIf

	//Valores Acessorios do titulo
	FKD->(dbSetOrder(2))	//FILIAL+IDDOC
	If !Empty(cIdDoc) .and. FKD->(dbSeek( cFilTit+cIdDoc ) )
		If __cRelease == Nil .Or. __lTCGQry2 == Nil
			__cRelease := GetRPORelease()
			__lTCGQry2 := FindFunction("TCGenQry2")
		EndIf

		If __cRelease > "12.1.017" .and. __lTCGQry2
			nVa := FinSomaFK6(cFilTit, cIdDoc, cCart, dDataBaixa, cTipoData, cAdiant, dDataBase, cFiliOrig, nMoedaTit, nTxMoeda)
		Else
			nVa := FinFK6V2(cFilTit, cIdDoc, cCart, dDataBaixa, cTipoData, cAdiant, dDataBase, cFiliOrig, nMoedaTit, nTxMoeda)
		EndIf

		nSaldo += nVa
	EndIf

	If !Empty(aAreaAnt)
		RestArea(aAreaAnt)
	EndIf

	Return (nSaldo)
Else
	Return xSaldoTit(@cPrefixo,@cNumero,@cParcela,@cTipo,@cNatureza,@cCart,@cCliFor,@nMoeda,;
		@dData,@dDataBaixa,@cLoja,@cFilTit,nTxMoeda,nTipoData,__oTBxCanc,lIsTxContr,@lCmpMulFil, lForcaFK)
Endif


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} XSALDOTIT

Retorna sado retroativo do titulo em uma determinada data (sem procedure).
Arquivo original: FINXFUN.PRX

@param cPrefixo   - Numero do Prefixo
@param cNumero    - Numero do Titulo
@param cParcela   - Parcela
@param cTipo      - Tipo
@param cNatureza  - Natureza
@param cCart      - Carteira  (R/P)
@param cCliFor    - Fornecedor(se cCart = 'R')
@param nMoeda     - Moeda
@param dData      - Data para conversao
@param dDataBaixa - Data data baixa a ser considerada (retroativa)
@param cLOja      - Loja do titulo
@param cFilTit    - Filial do titulo
@param nTxMoeda   - Taxa da Moeda
@param nTipoData  - Tipo de data para compor saldo (baixa/dispo/digit)
@param lIsTxContr - Define se a taxa contratada é taxa contratada

@Author	Vicente Sementilli
@since	05/08/1998
/*/
//-----------------------------------------------------------------------------------------------------

Function xSaldoTit( cPrefixo   As Character,;
					cNumero    As Character,;
					cParcela   As Character,;
					cTipo 	   As Character,;
					cNatureza  As Character,;
					cCart 	   As Character,;
					cCliFor	   As Character,;
					nMoeda 	   As Numeric,;
					dData 	   As Date,;
					dDataBaixa As Date,;
					cLoja 	   As Character,;
					cFilTit    As Character,;
					nTxMoeda   As Numeric,;
					nTipoData  As Numeric,;
					__oTBxCanc As Object,;
					lIsTxContr As Logical,;
					lCmpMulFil As Logical,;
					lForcaFK   As Logical) As Numeric

Local cAlias		As Character
Local nSaldo		As Numeric
Local dDataMoeda	As Date
Local nMoedaTit		As Numeric
Local cCarteira		As Character
Local dDtFina		As Date
Local cAliasTit		As Character
Local cFOrigE1		As Character
Local aFilBaixa 	As Array
Local aRelat		As Array
Local lRelat		As Logical
Local lConsult		As Logical
Local lFinR130		As Logical
Local lFinR150		As Logical
Local lFinR350		As Logical
Local lFinR13H		As Logical
Local lFinR340		As Logical
Local nI            As Numeric
Local lMovM2        As Logical
Local lIRPFBaixa	As Logical
Local cFilSE5		As Character
Local cTabOri		As Character
Local cTipoDocs		As Character
Local lConUni 		As Logical
Local lAdvanc       As Logical


cAlias		:= Alias()
nSaldo		:= 0
//Controla o Pis Cofins e Csll na baixa
aFilBaixa 	:= {}
aRelat		:= {}
lRelat		:= .F.
lConsult	:= FwIsInCallStack("Fc040Con")
lFinR130	:= FwIsInCallStack("FINR130") .or. FunName() $ "FINR130" //FunName para não quebrar o Robo
lFinR150	:= FwIsInCallStack("FINR150") .or. FunName() $ "FINR150" //FunName para não quebrar o Robo
lFinR350	:= FwIsInCallStack("FINR350")
lFinR13H	:= FwIsInCallStack("FINR13H")
lFinR340	:= FwIsInCallStack("FINR340") .or. FunName() $ "FINR340"
nI          := 0
lMovM2      := .F.
lIRPFBaixa	:= IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
cFilSE5		:= ""
cTabOri		:= ""
cTipoDocs	:= Iif(cPaisLoc=="ARG" .AND. lFinR13H, "VL|BA|V2|CP|LJ|DC","VL|BA|V2|CP|LJ")
lConUni 	:= .F.
lAdvanc      := .F.

If type("ltxZero") == "U"
	ltxZero   := .F.
Else
	Default ltxZero   := .F.
Endif

AADD(aRelat,"FINR150")
AADD(aRelat,"FINR130")
AADD(aRelat,"FINR340")

Default nTxMoeda  	:= 0
Default lIsTxContr	:= .F.
Default lForcaFK 	:= .F.

//Verifica se Relatórios estão na Pilha //
For nI := 1 To Len(aRelat)
	If FwIsInCallStack(aRelat[nI])
		lRelat:=.t.
		exit
	EndIf
Next nI

cCliFor    := Iif( cCliFor=NIL,Iif(cCart=="R",SE1->E1_CLIENTE,SE2->E2_FORNECE),cCliFor )
cLoja      := Iif( cLoja  =NIL,Iif(cCart=="R",SE1->E1_LOJA   ,SE2->E2_LOJA   ),cLoja   )
nMoeda     := IIF( nMoeda==NIL,1,nMoeda )
dDataMoeda := IIF( dData==NIL,dDataBase,dData )
dDataBaixa := IIF( dDataBaixa==NIL,dDataBase,dDataBaixa )
nTipoData  := IIF( nTipoData  ==nil, 0 , nTipoData )
lCmpMulFil := .T.

//Tipos de Data (cTipoData)
// 0 = Data Da Baixa (E5_DATA)
// 1 = Data de Disponibilidade (E5_DTDISPO)
// 2 = Data de Contabilidação (E5_DTDIGIT)
If nTipoData == 1
	cTipoData := "0"  // E5_DATA
ElseIf nTipodata == 2
	cTipoData := "1"  // E5_DTDISPO
Else
	cTipoData := "2"  // E5_DTDIGIT
Endif

// cFiltit somente e' usado no caso de relatorios que podem ser tirados
// por empresa (opcional)
cFilTit := Iif(cFilTit==Nil,xFilial("SE5"),cFilTit)

If __cMVFinFix   == NIL
	__cMVFinFix := SuperGetMv("MV_FINFIX",.F.,"")
Endif

dbSelectArea("SE5")
If Empty( xFilial() )
	cFilTit := Space( FWGETTAMFILIAL)
Endif

If cCart = "R"
	cAliasTit := "SE1"
	dbSelectArea("SE1")
	If lConsult
		nSaldo := SE1->E1_VALOR
	Else
   		nSaldo := SE1->E1_VALOR+SE1->E1_ACRESC-SE1->E1_DECRESC
	EndIf
	nMoedaTit := SE1->E1_MOEDA
	cCliFor   := Iif(Empty(cCliFor),SE1->E1_CLIENTE,cCliFor)
	cLoja     := Iif(Empty(cLoja  ),SE1->E1_LOJA,cLoja)
	cFilSE1   := xFilial("SE1")
	cFOrigE1  := SE1->E1_FILORIG

	If AllTrim(SE1->E1_TIPO) $ MVRECANT + "|" + MV_CRNEG .AND. !(lFinR130 .and. __cMVFinFix >= "20")// Contem todos os tipos que podem ser compensa‡?o
		aFilBaixa :=  GetFlBxSE5( SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ, SE1->E1_FILORIG, cCart, 2, __lRelat )
	ElseIf cPaisLoc $ "ARG|MEX" // Busca filial da baixa do t¡tulo para localizado Argentina ou M‚xico no caso da baixa ser realizada em filial diferente das inclus?o
		aFilBaixa :=  GetFlBxSE5( SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ, SE1->E1_FILORIG, cCart, 1, __lRelat )
	EndIf
Else
	cAliasTit := "SE2"
	dbSelectArea("SE2")
	nSaldo    := SE2->E2_VALOR+SE2->E2_ACRESC-SE2->E2_DECRESC
	nMoedaTit := SE2->E2_MOEDA
	cFilSE2   := xFilial("SE2")

	If AllTrim(SE2->E2_TIPO) $ MVPAGANT + "|" + MV_CPNEG .AND. !(lFinR150 .and. __cMVFinFix >= "20") // Contem todos os tipos que podem ser compensa‡?o
		aFilBaixa := GetFlBxSE5(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, SE2->E2_FILORIG, cCart, 2, __lRelat )
	Endif
Endif

If cPaisLoc == "RUS"
	If cAliasTit == "SE1"
		lAdvanc := (cAliasTit)->(E1_TIPO) $ MVRECANT
		lConUni := (SE1->E1_CONUNI == '1')
	Elseif cAliasTit == "SE2"
		lAdvanc := (cAliasTit)->(E2_TIPO) $ MVPAGANT
		lConUni := (SE2->E2_CONUNI == '1')
	EndIf
	If ((lConUni .OR. lAdvanc) .AND. nMoeda == 1)
		nSaldo := (cAliasTit)->&(SubStr(cAliasTit,2,2)+"_VLCRUZ")
	EndIf
EndIf

If Empty(aFilBaixa)
	aAdd(aFilBaixa,cFilTit)
EndIf

If (lFinR130 .OR. lFinR150 .or. lForcaFK) .and. __cMVFinFix >= "20"
	nSaldo := SldTitFK (cPrefixo,cNumero,cParcela,cTipo,cNatureza,cCliFor,nMoedaTit,dData,dDataBaixa,;
						cLoja,cFilTit,nTxMoeda,cTipoData,@lCmpMulFil,nSaldo, cCart )

	If nSaldo <= 0.009
		nSaldo := 0
	Endif
Else
	If Select("__BAIXA") == 0
		ChkFile("SE5",.F.,"__BAIXA")
	Else
		dbSelectArea("__BAIXA")
	EndIf

	cFilSE5 := FWxFilial("SE5")

	dbSetOrder(7)
	For nI := 1 To Len(aFilBaixa)
		cFilTit := aFilBaixa[nI]

		dbSeek(cFilTit+cPrefixo+cNumero+cParcela+cTipo)

		While !__BAIXA->(EOF()) .and. __BAIXA->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO) == cFilTit + cPrefixo + cNumero + cParcela + cTipo
			SE5->(DbGoTo(__BAIXA->(Recno()))) //Posicionar o SE5 pois dentro da TEMBXCANC condulta o SE5 e nao o __BAIXA

			IF AllTrim(SE5->E5_SITUACA) == "C" .AND. IF(EMPTY(SE5->E5_DTCANBX), .T., SE5->E5_DTCANBX <= dDataBaixa)
				__BAIXA->(dbSkip())
				Loop
			Endif

			IF !(SE5->E5_TIPODOC $ cTipoDocs)
				__BAIXA->(dbSkip())
				Loop
			Endif

			If TemBxCanc(SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO+SE5->E5_CLIFOR+SE5->E5_LOJA+SE5->E5_SEQ,,SE5->E5_FILIAL,__oTBxCanc,dDataBaixa)
				__BAIXA->(dbskip())
				Loop
			EndIf

			// se a origem da Baixa é do SIGALOJA e TipoDoc for VL , não usa na composicao do Saldo a receber
			IF AllTrim(SE5->E5_ORIGEM) == 'LOJXREC' .AND. SE5->E5_TIPODOC $ "VL"
				__BAIXA->(dbskip())
				Loop
			EndIf

			cCarteira := cCart

			If cCart == "R"
				If (SE5->E5_TIPO $ MVRECANT + "/" + MV_CRNEG).and. SE5->E5_TIPODOC $ "BA|VL|MT|JR|CM" ;
						.and. Empty(SE5->E5_DOCUMEN) .and. IIF(!(MovBcoBx(SE5->E5_MOTBX)), .T. , !Empty(E5_BANCO) )
					cCarteira := "P"        //Baixa de adiantamento (inverte)
					cLoja     := SE1->E1_LOJA
				Endif
			Endif

			//TRATAMENTO PARA MVPAGANT ou MVCPNEG COMPENSADO ENTRE CARTEIRAS
			If lFinR350 .And. dDatabase >= SE5->E5_DATA .And. ALLTRIM(SE5->E5_TIPO) $ MVPAGANT+"/"+MV_CPNEG .And. SE5->E5_MOTBX $ "CEC" .And. SE5->E5_TIPODOC == "BA"
				nSaldo -= SE5->E5_VALOR
			Endif

			If cCart == "R" .AND. !Empty(SE5->E5_FILORIG) .And. cFOrigE1 <> SE5->E5_FILORIG
				__BAIXA->(dbskip())
				Loop
			EndIf

			If cCart == "P" .AND. SE5->E5_TIPO $ MVPAGANT .and. (Alltrim(SE5->E5_ORIGEM) == 'FINA050')
				__BAIXA->(dbskip())
				Loop
			Endif

			//Tratamento para NDF's baixadas pela rotina de Faturas (FINA290)
			If lFinR350 .AND. AllTrim(E5_TIPO) $ MV_CPNEG .AND. AllTrim(E5_MOTBX) == "FAT" .AND. AllTrim(E5_TIPODOC) == "BA"
				nSaldo -= E5_VALOR
			EndIf

			If cCart == "P"
				If (SE5->E5_TIPO $ MVPAGANT+"/"+MV_CPNEG).and. SE5->E5_TIPODOC $ "BA|VL|MT|JR|CM" .and. ;
						SE5->E5_RECPAG =='R' .and. IIF(!(MovBcoBx(SE5->E5_MOTBX)), .T. , !Empty(SE5->E5_BANCO) )
					cCarteira := "R"        //Baixa de adiantamento (inverte)
				Endif
			Endif

			// Colocado este tratamento para conseguir compor o saldo no relatório de titulos a receber. Antes do Tratamento, fazia skip e ignorava o registro nos relatórios
			If !lRelat .Or. (lRelat .And. !Empty(SE5->E5_NUMCHEQ))
				IF (cCarteira == "P" .and. SE5->E5_RECPAG == "R") .or. (cCarteira == "R" .and. SE5->E5_RECPAG == "P")
					__BAIXA->(dbskip())
					Loop
				Endif
			EndIf

			IF cCliFor + cLoja  != SE5->(E5_CLIFOR + E5_LOJA)
				__BAIXA->(dbskip())
				Loop
			EndIF

			// Tratamento para diferenciar títulos com a mesma chave e filiais diferentes com SE5 compartilhado
			If Empty( cFilSE5) .And. Iif( cCart == "R", ! Empty( cFilSE1), ! Empty( cFilSE2) )
				If SE5->E5_FILORIG <> Iif( cCart == "R", cFilSE1, cFilSE2 )
					__BAIXA->(dbskip())
					Loop
				EndIf
			EndIf

			//Defino qual o tipo de data a ser utilizado para compor o saldo do titulo
			If cTipoData == "0"
				dDtFina := SE5->E5_DATA
			ElseIf cTipoData == "1"
				dDtFina := SE5->E5_DTDISPO
			Else
				dDtFina := SE5->E5_DTDIGIT
			Endif

			IF dDtFina <= dDataBaixa
				IF SE5->E5_TIPODOC $ cTipoDocs
					lCmpMulFil := .F.
					lMovM2 := SE5->E5_MOTBX == "CMP" .And. MovMoedEs(SE5->E5_MOEDA, SE5->E5_TIPODOC, SE5->E5_MOTBX, DTOS(dDtFina), SE5->E5_RECPAG)

					If	(lFinR130 .And. SE5->E5_RECPAG == "R") .Or. (lFinR130 .And. SE5->E5_RECPAG == "P" .And. SE5->E5_TIPO $ MVRECANT+"/"+MV_CRNEG ) .Or.;
						(lFinR150 .And. SE5->E5_RECPAG == "P" .And. cCarteira # "R") .Or. (lFinR150 .And. SE5->E5_RECPAG == "R" .And. SE5->E5_TIPO $ MVPAGANT+"/"+MV_CPNEG ) .Or. ;
						(lFinR130 .And. SE5->E5_RECPAG == "P" .And. SE5->E5_TIPO $ MVRECANT+"/"+MV_CRNEG )

						If SE5->E5_MOTBX =="CMP"
							nSaldo -= IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty(SE5->E5_BANCO) .OR. SE5->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),SE5->E5_VALOR,IIF(cPaisLoc=="BRA",IIF(lMovM2,SE5->E5_VALOR,SE5->E5_VLMOED2),SE5->E5_VALOR))
							nSaldo += Round(NoRound(xMoeda(SE5->E5_VLMULTA + SE5->(E5_VLJUROS-E5_VLACRES) - SE5->(E5_VLDESCO-E5_VLDECRE),1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
						ElseiF VAL(SE5->E5_MOEDA) < 2
							nSaldo -= IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty(SE5->E5_BANCO) .OR. SE5->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),SE5->E5_VALOR,SE5->E5_VLMOED2)
							nSaldo += Round(NoRound(xMoeda(SE5->E5_VLMULTA + SE5->(E5_VLJUROS-E5_VLACRES) - SE5->(E5_VLDESCO-E5_VLDECRE),1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
						Else //para moeda estrangeira os valores na se5 estão na moeda do banco, mesma moeda da nSaldo
							nSaldo -= IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty(SE5->E5_BANCO) .OR. SE5->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),SE5->E5_VALOR,SE5->E5_VLMOED2)
							nSaldo += SE5->E5_VLMULTA + SE5->(E5_VLJUROS-E5_VLACRES) - SE5->(E5_VLDESCO-E5_VLDECRE)
						EndIf
					ElseIf !lFinR150 .And. !lFinR130
						If (cPaisLoc == "RUS" .Or. (cPaisLoc $ "MEX|PER|COL" .And. lFinR340)) .And. nMoedaTit > 1 .And. SE5->E5_MOEDA == '01' 
							IF !cPaisLoc == "RUS" 
								nSaldo -= SE5->E5_VLMOED2
							Else
								If lConuni .OR. lAdvanc
									If nMoedaTit >= 1  .AND. nMoeda == 1
										nSaldo -= SE5->E5_VALOR
									ElseIf nMoedaTit > 1
										nSaldo -= SE5->E5_VLMOED2 
									EndIf
								Else
									nSaldo -= SE5->E5_VALOR
								EndIf
								nSaldo -= SE5->E5_VLMOED2
							Endif 
						ELSE
							If lMovM2
								nSaldo -= SE5->E5_VALOR
							Else
								If cPaisLoc $ 'MEX|COL|PER|PAR' .AND.  cTipo ==  PADR("RA",TamSx3("E1_TIPO")[1]) .AND.  nMoedaTit < 2 .And. val(SE5->E5_MOEDA) > 1
									nSaldo -= xMoeda(SE5->E5_VLMOED2 + SE5->E5_VLDESCO - SE5->E5_VLACRES,vAL(SE5->E5_MOEDA),nMoedaTit,SE5->E5_DATA, TamSx3("E1_TXMOEDA")[2],,nTxMoeda  )
								Else
									If  cPaisLoc == "ARG"
										If  ( nMoedaTit <> 1 )  .OR. (nMoedaTit == 1 .and. !(SE5->E5_TIPODOC $ "DC"))
											nSaldo -= If(nMoedaTit > 1 .And. !Empty(SE5->(E5_BANCO+E5_ORDREC)), SE5->E5_VALOR, SE5->E5_VLMOED2 + SE5->E5_VLDESCO - SE5->E5_VLACRES)
										Endif
									Else
										nSaldo -= If((nMoedaTit < 2 .And. cPaisLoc == "BRA") .Or. (!(cPaisLoc $ "BRA|MEX") .And. nMoedaTit > 1 .And. !Empty(SE5->(E5_BANCO+E5_ORDREC))), SE5->E5_VALOR, SE5->E5_VLMOED2 + SE5->E5_VLDESCO - SE5->E5_VLACRES)
									EndIf
								Endif
							EndIf
						ENDIF

						If !lFinR13H
							nSaldo += Round(NoRound(xMoeda(SE5->E5_VLMULTA+SE5->(E5_VLJUROS-E5_VLACRES)-SE5->(E5_VLDESCO-E5_VLDECRE),1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
						EndIf

					EndIf
					//Retencao de impostos na baixa
					If __lPccBx .and. cCarteira == "P" .and. SE5->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSLL) > 0   .and. !(SE5->E5_MOTBX == "PCC")
						nSaldo -= Round(NoRound(xMoeda(SE5->E5_VRETPIS+SE5->E5_VRETCOF+SE5->E5_VRETCSLL,1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
					Endif

					//Retenção de Irrf na baixa
					If lIRPFBaixa .and. cCarteira == "P" .and. Empty(SE5->E5_PRETIRF) .and. !(SE5->E5_MOTBX == "IRF")
						nSaldo -= Round(NoRound(xMoeda(SE5->E5_VRETIRF,1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
					Endif

					//Retenção de ISS na baixa
					If __IssBx .and. cCarteira == "P"
						nSaldo -= Round(NoRound(xMoeda(E5_VRETISS,1,nMoedaTit,E5_DATA,3,,IIF(E5_TXMOEDA==0,nTxMoeda,E5_TXMOEDA)),3),2)
					Endif

					If (lFinR350 .Or. lFinR150) .And. cCarteira == "P"
						nSaldo -= Round(NoRound(xMoeda(E5_VRETISS,1,nMoedaTit,E5_DATA,3,,IIF(E5_TXMOEDA==0,nTxMoeda,E5_TXMOEDA)),3),2)
					EndIf

					//Valores Acessorios
					cTabOri := IIf(SE5->E5_RECPAG == "P", "FK2", "FK1")
					nVA		:= IIf(__lTemFK6, FxLoadFK6(cTabOri, SE5->E5_IDORIG, "VA")[1][2], 0) //Pego o valor Informado
					nVA := Round(NoRound(xMoeda(nVA,1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
					nSaldo += nVA

					If nSaldo <= 0.009
						nSaldo := 0
					Endif
				Endif
			EndIF
			__BAIXA->(dbSkip())
		Enddo
	Next nI
EndIf

// Zera o Saldo devido problema de arredondamento nos juros, ou seja, o valor dos juros que eh gravado com
// 2 casas decimais, gera diferena na recomposicao do saldo no titulo
// Exemplo: Titulo com valor de 24.450, com E1_PORCJUR de 0.13 e tres dias de atraso, grava em SE5->E5_JUROS o valor
// de 95.36, sendo que o valor dos juros seria 95.355
// Movimentacao no SE5:
//	      Baixa	Juros	       Saldo
//		 		            24.450,00
//-------------------------------
//		4.001,04	95,36 	20.544,32 3 dias apos vencto.
//		2.100,95		      18.443,37 mesma data
//		3.474,23		      14.969,14 mesma data
//		6.000,00		       8.969,14 5 dias apos vencto
//		5.060,00		       3.909,14 10 dias apos vencto
//		3.919,29	10,16	        0,01 12 dias apos vencto
If Empty((cAliasTit)->&(Right(cAliasTit,2)+"_SALDO")) .And. Abs(nSaldo) <= 0.009
	nSaldo := 0
Else
	If nMoeda <> nMoedaTit .AND. !lIsTxContr .AND. RecMoeda(dData,nMoedaTit) == 0
		ltxZero  := .T.
	Endif
	If cPaisLoc != "RUS" .OR. !(nMoeda == nMoedaTit .OR. lConuni .OR. lAdvanc)
		nSaldo := Round(NoRound(xMoeda(nSaldo,nMoedaTit,nMoeda,dData,__nDecs+1,nTxMoeda),__nDecs+1),__nDecs)
	EndIf
Endif
If !Empty(cAlias)
	dbSelectArea(cAlias)
EndIf

Return ( nSaldo )


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXIBAN

Atualiza campos de memória com o calculo do digito verificador de conta corrente (A6_DV)
Arquivo original: FINXFUN.PRX

@param cCod: numero do banco (A6_COD)
@param cAgencia: numero da agencia (A6_AGENCIA)
@param cNumCon: numero da conta (A6_NUMCON)

@Author	Edvin Zimmermann
@since	09/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function fxIBAN( cCod, cAgencia, cNumCon )

	Local cNum := ""
	Local cIBAN := ""

	if !( empty(cCod) .or. empty(cAgencia)  .or. empty(cNumCon) )
		cIBAN := cCod + cAgencia + cNumCon
		cNum := FINMod9710(@cIBAN)
		If cPaisLoc $ "ANG|EQU|HAI"
			M->A6_DV := cNum
		EndIf
		M->A6_IBAN := cIBAN
	endIf

Return .t.


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINMOD9710

Calculo do digito verificador de conta corrente (A6_DV e A6_IBAN)
Arquivo original: FINXFUN.PRX

@param cNum: Numero a ser calculado.Pode conter caracteres de "0" a "9" e de "A" a "Z". Se passado por referencia, eh atualizado com os digitos verificadores

@Author	TOTVS
@since	09/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FINMod9710(cNum)

	Local nX, nY
	Local nTot := 0
	Local cAux
	Local nNum
	Local cRet
	Local cNumAux
	Local aW := {1, 10, 3, 30, 9, 90, 27, 76, 81, 34, 49, 5, 50, 15, 53, 45, 62, 38, 89, 17, 73, 51, 25, 56, 75, 71, 31, 19, 93, 57, 85, 74, 61, 28, 86, 84, 64, 58, 95, 77, 91, 37, 79, 14, 43, 42, 32, 29, 96, 87, 94, 67, 88, 7, 70, 21, 16, 63, 48, 92, 47, 82, 44, 52, 35, 59, 8, 80, 24, 46, 72, 41, 22, 26, 66, 78, 4, 40, 12, 23, 36, 69, 11, 13, 33, 39, 2, 20, 6, 60, 18, 83, 54, 55, 65, 68} // Os pesos já foram calculados usando a fórmula aW[i] = mod( 10^(i-1), 97) para melhoria de performance. A partir da posição 97 a seqüência se repete

	cNum := Alltrim(Upper(cNum))
	cNumAux := ""

	nX := len(cNum)
	nY := mod(nX, 97) + 1
	Do While nX >= 3
		cAux := subs(cNum, nX, 1)
		If cAux >= "0" .and. cAux <= "9"
			nNum := val(cAux)
			cNumAux := cNumAux +cAux
		ElseIf cAux >= "A" .and. cAux <= "Z"
			nNum := ASC(cAux) - 55
			cNumAux := cNumAux + cAux
		Else
			nNum := 0
			cNumAux := cNumAux +"0"
		EndIf
		nTot := nTot + ( nNum * aW[nY])
		nX := nX - 1
		If nY > 1
			nY := nY - 1
		Else
			nY := 98
		EndIf
	Enddo

	nTot := mod(nTot, 97)
	nTot := 98 - nTot
	cRet := strzero(nTot, 2)
	cNum := cNumAux + cRet

Return cRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINVLDNAT

Valida a natureza  (utilizado em vários fontes e campos).
Arquivo original: FINXFUN.PRX


@param lVazio: Se valia o campo vazio
@param cCampo: conteudo a ser validado
@param nUso: Onde a natureza vai ser usada
@param nTipoOK: Tipo de natureza permitida

@Author	TOTVS
@since	23/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FinVldNat( lVazio as Logical, cCampo as Character, nUso as Numeric, nTipoOk as Numeric) as Logical
	Local lRet		as Logical
	Local aArea		as Array
	Local cFunName	as Character
	Local nScan		as Numeric

	Default cCampo	:= &( ReadVar() )
	Default nTipoOk	:= 0
	DEFAULT __lGesplan  := (SEV->(FieldPos("EV_MSUID")) > 0 .And. SuperGetMv("MV_FINTGES",.F.,.F.))

	lRet		:= .T.
	aArea		:= SED->( GetArea() )
	cFunName	:= FunName()
	nScan		:= 0

	//Caso não seja passado o nUso é inicializado. (X3_VALID EV_NATUREZ rateio por execauto)
	If nUso == Nil
		If FwIsInCallStack("FINA040") .or. FwIsInCallStack("FINA070")
			nUso := 1  // A receber.
		ElseIf FwIsInCallStack("FINA050") .or. FwIsInCallStack("FINA080")
			nUso := 2  // A pagar.
		else
			nUso := 0 //Default
		Endif
	Endif

	If !lVazio .AND. Empty( cCampo )
		Help( " ", 1, "NATVAZIA",, STR0033, 1, 0 ) //"É necessário que seja informada uma natureza para esse processo.!"
		lRet	:= .F.
	EndIf

	If lRet .AND. !Empty( cCampo )
		DbSelectArea( "SED" )
		SED->( DbSetOrder( 1 ) )
		If SED->( DbSeek( xFilial( "SED" ) + cCampo ) )
			If Val( SED->ED_TIPO ) == 1 .AND. nTipoOk == 0
				Help( " ", 1, "NATUREZ1",, STR0034, 1, 0 )  //"Verifique se a natureza informada está classificada corretamente. Apenas naturezas do titpo analítico serão aceitas para este processo.!"
				lRet	:= .F.
			EndIf

			If lRet .AND. nTipoOk > 0 .AND. Val( SED->ED_TIPO ) <> nTipoOk
				Help( " ", 1, "NATUREZ2",, STR0036, 1, 0 ) //###"Verifique o tipo da natureza!"
				lRet	:= .F.
			EndIf

			If lRet .and. nUso <> 0 .and. !Empty(SED->ED_USO) .and. SED->ED_USO <> "0"
				//Validação do nUso
				If nUso <> Val( SED->ED_USO )
					// Valida contas a receber.
					If lRet .AND. cFunName $ "FINA040|FINA740|FINA070|FINA460"
						If 	!SED->ED_USO $ '0|1'
							Help( " ", 1, "USONATCR",, STR0037, 1, 0 ) //"A natureza não poderá ser usada nesta rotina!"
							lRet	:= .F.
						EndIf
					EndIf

					// Valida contas a pagar.
					If lRet .AND. cFunName $ "FINA050|FINA750|FINA080|FINA565"
						If  !SED->ED_USO $ '0|2'
							Help( " ", 1, "USONATCP",, STR0037, 1, 0 )  //"A natureza não poderá ser usada nesta rotina!"
							lRet	:= .F.
						EndIf
					EndIf

					// Valida outras rotinas.
					If lRet .AND. !IsInCallStack("MATA103") .and. !(cFunName $	"FINA040|FINA050|FINA740|FINA750|FINA070|FINA080|FINA090|FINA110|FINA190|FINA191|FINA280|FINA290|FINA450|FINA460|FINA565|MATA103|FINA330|FINA340|FINA390|FINA470|FINA473|FINA430")
						Help( " ", 1, "USONATGR",, STR0037, 1, 0 )	 //"A natureza não poderá ser usada nesta rotina!"
						lRet	:= .F.
					EndIf
				EndIf
			EndIf

			If lRet .And. FindFunction("JVldNat290")
				lRet := JVldNat290(SE2->E2_NATUREZ, .F., "FINXFIN")
			EndIf
		Else
			Help( " ", 1, "NATNAOENC",, STR0038, 1, 0 )   //"A natureza não foi encontrada!!"
			lRet	:= .F.
		EndIf
	EndIf

	If lRet .AND. cPaisLoc $ 'URU|ARG|CHI|BOL|PAR' .AND. FwIsInCallStack("FINA100")
		If !(ExistCpo("SED",cCampo))
			lRet := .F.
		EndIf
	EndIf

	If (lRet .And. __lGesplan .And. (FwIsInCallStack("FA050ALTER") .Or. FwIsInCallStack("FA040ALTER")) .And. TYPE('aCols')=='A' )
		// Se a natureza estiver registrada (mesmo que apagada), nao permite nova distribuicao para a mesma natureza
		nAscan := Ascan( aCols, { |e| e[1] == cCampo } )
		If nAscan > 0 .And. n != nAscan .And. !aCols[n][Len(aCols[1])]
			Help( " ", 1, "USONATGR",, STR0037, 1, 0 )	 //"A natureza não poderá ser usada nesta rotina!"
			lRet	:= .F.
		EndIF
	EndIF

	RestArea( aArea )

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FCKRESEXT

Valida o conteúdo digitado no campos (validação dos campos A2_PAISEX/A2_BREEX/A2_TPREX/A2_TRBEX)
Arquivo original: FINXFUN.PRX

@Author	Adrianne Furtado
@since	17/02/2011
/*/
//-----------------------------------------------------------------------------------------------------
Function FCkResExt(cCpo, uConteudo)
Local lRet := .F.
Local aTabela1
Local aTabela2
Local aTabela3

//1. Informações sobre os rendimentos
aTabela1 := {"100","110","120","130","140","150","160","170","180","190","200","210","220","230","300"}

//2. Informações sobre a forma de tributação
aTabela2 := {"10","11","12","13","30","40","41","42","43","44","50"}

//3. Informações sobre os beneficiários dos rendimentos
aTabela3 := {"500","510","520","530","540","550","560","570","900"}

Do Case
	Case cCpo == 'A2_PAISEX'
		lRet := .T.
	Case cCpo == 'A2_BREEX'
		lRet := Ascan(aTabela3, {|x| x == uConteudo}) > 0
	Case cCpo == 'A2_TPREX'
		lRet := Ascan(aTabela1, {|x| x == uConteudo}) > 0
	Case cCpo == 'A2_TRBEX'
		lRet := Ascan(aTabela2, {|x| x == uConteudo}) > 0
EndCase

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA390BANCO

Valida banco digitado (FINA190/FINA390).
Arquivo original: FINXFUN.PRX

@param nGet - Indica sequencia que vou montar minha chave
@param lVldBloq - Valido ou nao o bloqueio da conta

@Author	Wagner Xavier
@since	21/03/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function fa390Banco(nGet As Numeric, lVldBloq As Logical)
Local cChave 	As Character
Local lRet	 	As Logical
Local cCampo 	As Character

DEFAULT nGet     := 0
DEFAULT lVldBloq := .F.

cChave 	:= ""
lRet	:= .T.
cChave	:= cBanco390+cAgencia390+cConta390

DbSetOrder(1)

If nGet > 0 .And. !Empty(cChave)
  	If !SA6->(DbSeek( xFilial("SA6") + cChave ))
		Help( " ",1,"fa390Banco" )
		lRet := .f.
	Endif

  	If lRet .and. SA6->A6_BLOCKED == "1"
		Help(" ",1,"CCBLOCKED")
		lRet := .f.
	Endif
Else
	lAchou := !Empty(cConta390) .And. SA6->(DbSeek(xFilial("SA6")+cChave))
	cCampo := ReadVar()

	If !lAchou
		If cCampo == "CBANCO390"
			cChave := cBanco390
		Elseif cCampo =="CAGENCIA390"
			cChave := cBanco390+cAgencia390
		Endif

		lAchou := SA6->(DbSeek(xFilial("SA6")+cChave))
	Endif

	If lAchou
		cBanco390 	:= SA6->A6_COD
		cAgencia390 := SA6->A6_AGENCIA
		cConta390 	:= SA6->A6_NUMCON
	Else
		Help(" ",1,"fa390banco" )
		lRet := .F.
	Endif

	If lRet .And. lVldBloq .And. SA6->A6_BLOCKED == "1"
		Help(" ",1,"CCBLOCKED")
		lRet := .f.
	Endif
Endif

If lRet .And. SA6->(ColumnPos("A6_MSBLQL")) > 0
	If SA6->A6_MSBLQL == "1"
		Help(" ",1,"REGBLOQ",,,1,0)
		lRet := .F.
	Endif
Endif

//-----------------------------------------------------------------
// Ponto de Entrada para controle da numeracao do cheque no
// FINA390 e tambem sera retornado o Banco, Agencia e Conta.
//-----------------------------------------------------------------
If ExistBlock("F390NCHQ") .And. !Empty(cBanco390) .And. !Empty(cAgencia390) .And. !Empty(cConta390)
	cCheque390 := Padr(ExecBlock("F390NCHQ",.F.,.F.,{cBanco390,cAgencia390,cConta390}),TamSX3("EF_NUM")[1])
EndIf

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA390CHEQ

Valida cheque digitado (FINA190/FINA390).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	21/03/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function fa390Cheq(nNum)
Local cAlias:= Alias( )
Local lRet  := .t.
Local nReg  := Recno()

If Empty( cCheque390 )
	Return .f.
Endif
dbSelectArea( "SEF" )
dbSetOrder(1)
If (dbSeek( cFilial + cBanco390 + cAgencia390 + cConta390 + cCheque390 ) )
	If nNum == 1
		Help( " ",1,"fa390Cheq" )
		lRet := .f.
	Endif
Else
	If nNum == 2
		Help( " ",1,"fa390NoXeq" )
		lRet := .f.
	Endif
	dbGoto(nReg)
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PE F390VCH                                              ³
//³ Utilizado para validacoes extras ao nro. do chq s/ tit. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("F390VCH")
	lRet := ExecBlock("F390VCH",.F.,.F.)
Endif

dbSelectArea( cAlias )
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINVLACDC

Valida se o acrescimo e descrecimo estao preenchidos (validação de campos E1_ACRESC, E1_DECRES, E2_ACRESC,
E2_DECRES).
Arquivo original: FINXFUN.PRX

@Author	TOTVS
@since	17/05/2012
/*/
//-----------------------------------------------------------------------------------------------------
Function FinVlAcDc(cTipo)

Local lRet := .T.
Local aArea := SE2->( GetArea() )

If cTipo == "P"
	If M->E2_ACRESC>0 .And. M->E2_DECRESC>0
		Help(" ",1,"ACRES/DECRES")
		lRet := .F.
	ElseIf M->E2_ACRESC>0 .And. M->E2_DECRESC==0
		lRet := .T.
	ElseIf M->E2_DECRESC>0 .And. M->E2_ACRESC==0
		lRet := .T.
	EndIf
ElseIf cTipo == "R"
	If M->E1_ACRESC>0 .And. M->E1_DECRESC>0
		Help(" ",1,"ACRES/DECRES",,"")
		lRet := .F.
	ElseIf M->E1_ACRESC>0 .And. M->E1_DECRESC==0
		lRet := .T.
	ElseIf M->E1_DECRESC>0 .And. M->E1_ACRESC==0
		lRet := .T.
	EndIf
EndIf

RestArea( aArea )
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXVLDBXBCO

Valida se o banco selecionado por ser usado na baixa..
Arquivo original: FINXFUN.PRX

@param cBco      - Banco
@param cAg       - Agencia
@param cCnta     - Numero da Conta
@param cNatureza - Natureza
@param nMoedTit  - Moeda do titulo
@param lAlerta   - Se exibe o alerta em situacao de erro

@Author	TOTVS
@since	11/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FXVldBxBco( cBco As Character, cAg As Character, cCnta As Character, cNatureza As Character, nMoedTit As Numeric, lAlerta As Logical, oBanco As Object ) As Logical

Local aArea		As Array
Local lRet 		As Logical
Local lMoedaBco	As Logical
Local lNatBcEx	As Logical

aArea		:= GetArea()
lRet 		:= .T.
lMoedaBco	:= SuperGetMv("MV_MOEDBCO",, .F.)
lNatBcEx	:= SuperGetMv("MV_NATBCEX",, .T.)

Default cCnta	:= ""
Default lAlerta	:= .T.
Default oBanco	:= Nil

// Verifica se o banco selecionado pode ser usado para baixa do titulo
If cPaisLoc == "BRA" .AND. !Empty( cCnta )
	DbSelectArea( "SA6" )
	SA6->( DbSetOrder( 1 ) )
	If SA6->( DbSeek( xFilial( "SA6" ) + cBco + cAg + cCnta ) )
		If SA6->A6_MOEDA > 1 .AND. lNatBcEx
			If FXCalcImp( cNatureza )
				If lAlerta
					Help( " ", 1, "FA100NAT",, STR0039, 1, 0 )  //"A baixa de titulos cuja configuração da natureza calcula impostos só é permitida em conta bancáia com moeda corrente!"
				EndIf

				lRet 		:= .F.
			EndIf

			If lRet .AND. SA6->A6_MOEDA <> nMoedTit .AND. !lMoedaBco
				If lAlerta
					Help( " ", 1, "FA100BCO2",, STR0040, 1, 0 )  //"O banco para baixa deve ser em moeda corrente ou na moeda do titulo!"
				EndIf

				lRet 		:= .F.
			EndIf

		EndIf
	EndIf

	If lRet
		nMoedaBco := SA6->A6_MOEDA
	Endif

	If oBanco != Nil .And. !lRet 
		lRet := .T.
		oBanco:SetFocus()
	Endif

EndIf

RestArea( aArea )

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXMULSLD

Verifica  se  o ambiente  esta preparado  para  controle de saldos bancarios em multiplas moedas.
(função utilizada para saber se existiam campos A6_MOEDA e a tabela FIJ).
Arquivo original: FINXFUN.PRX

@Author	TOTVS
@since	12/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FXMultSld()
	Local lRet := .F.

	If cPaisLoc $ "BRA"
		lRet	:= .T.
	EndIf

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXVLDBCO

Valida se o bordero foi feito em moeda nacional  ou na moeda da conta bancária (FINA060/FINA061).
Arquivo original: FINXFUN.PRX

@Author	TOTVS
@since	09/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FXVldBco( cPort, cAgen, cConta, nMoeda, lBord )
Local lRet		:= .T.
Local aArea		:= SA6->( GetArea() )
Local cMensa	:= ""

Default nMoeda := 0
Default lBord	:= .F.

If cPaisLoc == "BRA"
	DbSelectArea( "SA6" )
	SA6->( DbSetOrder( 1 ) )
	If SA6->( DbSeek( xFilial( "SA6" ) + cPort + cAgen + cConta ) )

		nMoedaBco	:= Max(SA6->A6_MOEDA,1)
		nMoeda		:= If (nMoeda == 0, nMoedaBco, nMoeda)
		cMensa	   := If (lBord, STR0041 + CHR(10) + STR0042, STR0043) //"Moeda do borderô e Moeda do Banco são diferentes."###"Para contas correntes com moeda diferente de 1 somente poderão ser gerados borderos na mesma moeda da conta corrente."###"O banco para baixa deve ser em moeda corrente ou na moeda do portador do bordero!"


		If  nMoedaBco > 1 .and. nMoedaBco != nMoeda
			Help( " ", 1, "A6_MOEDA",, cMensa, 1, 0 )
			Return .F.
		EndIf
	EndIf
EndIf

RestArea( aArea )
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} CCBLOCKED

Verifica se conta corrente esta bloqueada.
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	03/07/2003
/*/
//-----------------------------------------------------------------------------------------------------
FUNCTION CCBlocked(cBanco,cAgencia,cConta,lHelp,lVldData,cXFilial)
	Local aArea		As Array
	Local aAreaSA6  As Array
	Local lRet		As Logical

	Default lVldData 	:= .F.
	Default cBanco		:= ""
	Default cAgencia	:= ""
	Default cConta		:= ""
	Default cXFilial    := cFilAnt
	Default lHelp		:= .T.

	aArea    := GetArea()
	aAreaSA6 := SA6->(GetArea())
	lRet	 := .F.

	SA6->( DbSetOrder(1) )
	If SA6->( DbSeek(xFilial("SA6",cXFilial)+cBanco+cAgencia+cConta))

		If SA6->A6_BLOCKED == "1" .and. If(lVldData,SA6->A6_DTBLOQ <= dDataBase,.T.)
			If lHelp
				Help(" ",1,"CCBLOCKED",,STR0091,1,0)
			Endif

			lRet := .T.
		ElseIf SA6->(ColumnPos("A6_MSBLQL")) > 0 .And. SA6->A6_MSBLQL == "1"
			If lHelp
				Help(" ",1,"REGBLOQ",,,1,0)
			Endif

			lRet := .T.
		Endif
	Endif

	RestArea(aAreaSA6)
	RestArea(aArea)
	FwFreeArray(aAreaSA6)
	FwFreeArray(aArea)

Return lRet
//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXCALCIMP

Verifica se natureza calcula impostos (ligada a FXVldBxBco)
Arquivo original: FINXFUN.PRX

@Author	TOTVS
@since	11/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FXCalcImp( cNatureza )
	Local lRet	:= .T.
	Local aArea	:= SED->( GetArea() )

	If cPaisLoc == "BRA"
		dbSelectArea("SED")
		SED->( DbSetOrder( 1 ) )
		If SED->( DbSeek( xFilial( "SED" ) + cNatureza ) )
			lRet :=	SED->ED_CALCCOF == "S" .OR. ;
					SED->ED_CALCCSL == "S" .OR. ;
					SED->ED_CALCINS == "S" .OR. ;
					SED->ED_CALCIRF == "S" .OR. ;
					SED->ED_CALCISS == "S" .OR. ;
					SED->ED_CALCPIS == "S"
		EndIf
	EndIf

	RestArea( aArea )
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXCalImp2

Verifica se natureza calcula determinado imposto.

@Param 	cNatureza = Código da Natureza
		cCpo = Nome do campo do imposto a ser consultado na tabela SED

@Author	TOTVS
@since	19/03/15
/*/
//-----------------------------------------------------------------------------------------------------

Function FXCalImp2( cNatureza, cCpo )
	Local lRet	:= .T.
	Local aArea	:= SED->( GetArea() )

	If cPaisLoc == "BRA"
		dbSelectArea("SED")
		SED->( DbSetOrder( 1 ) )
		If SED->( DbSeek( xFilial( "SED" ) + cNatureza ) )
			lRet :=	&("SED->" + cCpo) == "S"
		EndIf
	EndIf

	RestArea( aArea )
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MOVBCOBX

Verifica se o motivo de baixa gera movimento bancário.
Arquivo original: FINXFUN.PRX

@Author	Andreia Santos
@since	25/11/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function MovBcoBx( cMotBx, lDescricao )
Local nPos
Local lRet := .F.
Local aMotBx:= ReadMotBx()

lDescricao := If(lDescricao = Nil, .F., lDescricao)

If lDescricao
	nPos := Ascan(aMotBx, {|x| Substr(x,7,10) = Upper(cMotBx) })
Else
	nPos := Ascan(aMotBx, {|x| Substr(x,1,3) = Upper(cMotBx) })
Endif

If nPos > 0
	lRet := Iif(Substr(aMotBx[nPos],19,1) == "S",.T.,.F.)
Endif
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SPBINUSE

Verifica se o SPB (Sistema de pagamentos brasileiro) está ativo no Financeiro.
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	25/02/2002
/*/
//-----------------------------------------------------------------------------------------------------
Function SpbInUse()

If lSPBInUse == NIL
	If cPaisLoc == "BRA" .and. SuperGetMv("MV_USASPB",,"N") == "S"
		lSPBInUse := .T.
	Else
		lSPBInUse := .F.
	Endif
Endif

Return lSPBInUse

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SPBTIPO

Verifica se o tipo do SPB está valido (TED ou STR) (FINA070/FINA080/FINA100).
Arquivo original: FINXFUN.PRX

@param cAlias - Alias
@param cModSpb - Modalidade do SPB
@param cTipoTit - Tipo do titulo utilizado no movimento
@param cTipoMov

@Author	Mauricio Pequim Jr.
@since	25/02/2002
/*/
//-----------------------------------------------------------------------------------------------------
Function SpbTipo (cAlias,cModSpb,cTipoTit,cTipoMov)

Local lRet := .T.
Local aSaveArea := GetArea()
Local cAlias2 := cAlias
Local lValidCpo := .T.

cMotBx := Iif(Type("cMotBx")!="C",Space(3),cMotBx)
cTipoMov := IIF(cTipoMov == NIL,"  ",cTipoMov)	// Tipo de movimentacao manual

//Verifica se validacao no campo _MODSPB - Inclusao
If cModSpb == NIL .and. cTipoTit == NIL .and. cAlias $ "SE1/SE2"
	dbSelectArea(cAlias)
	cAlias2 := Right(cAlias,2)
	cTipoTit := M->&(cAlias2+"_TIPO")
	cModSpb  := M->&(cAlias2+"_MODSPB")
	If Empty(cTipoTit)
		lValidCpo := .F.
	Endif
Endif
//Verifica se validacao no campo _MODSPB - Inclusao movimentação Rec/Pag
//Esse trecho não foi convertido pois a FINA100 ainda está toda baseada na SE5.
If cModSpb == NIL .and. cTipoTit == NIL .and. cAlias == "SE5"
	dbSelectArea(cAlias)
	cTipoTit := M->E5_MOEDA
	cModSpb  := M->E5_MODSPB
	If Empty(cTipoTit)
		lValidCpo := .F.
	Endif
Endif


//Titulos de adiantamento sempre serao STR pois considera como valor disponível
//e nao como eventual futura baixa
If lValidCpo
	If cTipoTit $ MVRECANT+"/"+MV_CRNEG .and. cModSpb != "1"
		Help(" ",1,"ADTINSPB")	//"Titulos de adiantamento sempre serao modalidade "
										//"TED pois considera-se como valor disponível "
										//"e nao como eventual baixa futura"
		lRet := .F.

	// Baixa de titulos a receber com data de credito posterior a baixa
	ElseIf !Empty(cMotBx).and.cAlias == "SE1".and. MovBcoBx(cMotbx,.T.) .and. ;
			dDtCredito > dBaixa .and. cModSpb != "3"
		Help(" ",1,"MODSPBCR")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize motivo de baixa "
										//"que aceite retencao (COMP)"

		lRet := .F.

	// Baixa de titulos a receber com data de credito igual a baixa
	ElseIf !Empty(cMotBx).and.cAlias == "SE1".and. MovBcoBx(cMotbx,.T.) .and. ;
			dDtCredito == dBaixa .and. cModSpb == "3"
		Help(" ",1,"MODSPBSR")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize motivo de baixa "
										//"sem retencao (STR ou CIP)"

		lRet := .F.

	// Apenas para baixas a pagar
	ElseIf !Empty(cMotBx).and. cAlias == "SE2" .and. MovBcoBx(cMotbx,.T.) .and.;
			 ChqMotBx(cMotBx) .and. cModSpb != "3"
		Help(" ",1,"MODSPBCP")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize motivo de baixa "
										//"que nao gere cheques"

		lRet := .F.

	// Apenas para baixas a pagar
	ElseIf !Empty(cMotBx).and. cAlias == "SE2" .and. MovBcoBx(cMotbx,.T.) .and.;
			!ChqMotBx(cMotBx) .and. cModSpb == "3"
		Help(" ",1,"MODSPBCPR")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize motivo de baixa "
										//"que gere cheques (COMP)."

		lRet := .F.


	// Apenas para Mov. Manual Pagar ou Receber
	ElseIf cAlias == "SE5" .and. cTipoTit $ "C1/C2/C3/C4/C5/CH" .and. Empty(cTipoMov).and. ;
		cModSpb != "3"
		Help(" ",1,"MODSPBC1")	 //"Modalidade invalida para esse tipo de movimento. "
										 //"Para essa modalidade de SPB, utilize movimentacao "
										 //"que gere cheques (COMP)."

		lRet := .F.

	// Apenas para Mov. Manual Pagar ou Receber
	ElseIf cAlias == "SE5" .and. cTipoTit $ "M1/M2/M3/M4/M5" .and. Empty(cTipoMov).and. ;
		cModSpb == "3"
		Help(" ",1,"MODSPBM1")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize movimentacao "
										//"que nao gere cheques (TED ou CIP)."

		lRet := .F.

	// Apenas para Transferencia - Mov. sem documento
	ElseIf cAlias == "SE5" .and. !(cTipoTit $ "TB /CH /DOC") .and. cTipoMov == "TR" .and. ;
		cModSpb == "3"
		Help(" ",1,"MODSPBT1")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize movimentacao "
										//"que nao gere cheques (STR ou CIP)."

		lRet := .F.

	// Apenas para Transferencia - Mov. com documento
	ElseIf cAlias == "SE5" .and. cTipoTit $ "TB /CH " .and. cTipoMov == "TR" .and. ;
		cModSpb != "3"
		Help(" ",1,"MODSPBT2")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize movimentacao "
										//"que gere cheques (COMP)."

		lRet := .F.
	Endif

Endif
RestArea(aSaveArea)
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FVldJurxFin
Função mantida por compatibilidade, avaliar retirar após Release 12.1.2310

@author    Mauricio Pequim Jr
@version   11.80
@since     12/03/13

@return ExpL1 = Confirma a integração Caixinha Financeiro x SigaPFS

/*/
//-----------------------------------------------------------------------------------------------------
Function FVldJurxFin()
Return .F.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINMODPROC

Função que define qual processo será utilizado nos contas a receber e contas a pagar no módulo do
Financeiro (modelo 1ou model
o II - Argentina).
Processos:
FINA087A - Recebimentos Diversos - Modelo I
FINA840	- Recebimentos Diversos - Modelo II
FINA085A - Ordem de Pagamento - Modelo I
FINA850	- Ordem de Pagamento - Modelo II
FINA095	- Cheques Emitidos
FINA096	- Cheques de Terceiros
FINA025	- Modo de Pago
FINA585	- Solicitação de Fundos
FINA085P	- Pré-Ordem de Pago - Modelo I
FINA855	- Pré-Ordem de Pago - Modelo II
FINA845	- Entrada de Documentos em Trânsito
FINA841	- Manutenção de Recibos de Cobrança Modelo II

Arquivo original: FINXFUN.PRX

@Author	Marylly A. Silva
@since	06/01/2012
/*/
//-----------------------------------------------------------------------------------------------------
Function FinModProc(lMsg,cTexto)

Local lRet 		:= .T.
Local aAreaSX6 	:= {}
Local nModProc	:= 1
Local cNomRotin := AllTrim(FunName())
Local lRotina	:= FwIsInCallStack(cNomRotin)
Local cMsg := ""

Default lMsg := .T.
Default cTexto := ""

DbSelectArea("SX6")
aAreaSX6 := SX6->(GetArea("SX6"))
nModProc := GetMV("MV_FINCTMD",.T.,1)

If lRotina .AND. cPaisLoc <> "BRA"
	lRet := .F.
	Do Case
		Case cNomRotin $ "FINA025|FINA585|FINA845|FINA841" .AND. nModProc == 1
			cMsg += STR0044 //"O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo II."
		Case cNomRotin == "FINA087A" .AND. nModProc == 2
			cMsg += STR0045 //"O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA840 - " + STR0047 //"Utilize a rotina "###" Recebimentos Diversos Mod.II"
		Case cNomRotin $ "FINA840|FINA846" .AND. nModProc == 1
			cMsg += STR0044 //"O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo II."
			cMsg := cMsg + CRLF + STR0046 + "FINA087A - " + STR0048 //"Utilize a rotina "###" Recebimentos Diversos."
		Case cNomRotin == "FINA085A" .AND. nModProc == 2
			cMsg += STR0045 //"O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA850 - " + STR0049 //"Utilize a rotina "###" Ordem Pago Mod. II."
		Case cNomRotin $ "FINA850|FINA847" .AND. nModProc == 1
			cMsg += STR0044 //"O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo II."
			cMsg := cMsg + CRLF + STR0046 + "FINA085A - " + STR0050 //"Utilize a rotina "###" Ordem Pago."
		Case cNomRotin == "FINA855" .AND. nModProc == 1
			cMsg+= "O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo II."
			cMsg := cMsg + CRLF + STR0046 + "FINA085P - " + STR0051 //"Utilize a rotina "###" Pré-Ordem Pago."
		Case cNomRotin == "FINA085P" .AND. nModProc == 2
			cMsg+= "O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046+ "FINA855 - " + STR0052 //"Utilize a rotina "###" Pré-Ordem Mod. II."
		Case cNomRotin == "FINA090" .AND. nModProc == 2
			cMsg+= "O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA095 - " + STR0053 //"Utilize a rotina "###" Cheques emitidos"
		Case cNomRotin == "FINA095" .AND. nModProc == 1
			cMsg += "O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA090 - " + STR0054 //"Utilize a rotina "###" Debitar Cheques"
		Case cNomRotin == "FINA089" .AND. nModProc == 2
			cMsg += "O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA096 - " + STR0055 //"Utilize a rotina "###" Cheques Recebidos"
		Case cNomRotin == "FINA096" .AND. nModProc == 1
			cMsg += "O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA089 - " + STR0056 //"Utilize a rotina "###" Liquidar Cheques "
		Case cNomRotin == "FINA472" .AND. nModProc == 1
			cMsg += "O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo II."
			cMsg := cMsg + CRLF + STR0046 + "FINA470 - " + STR0057 //"Utilize a rotina "###"Concil. Automatica"
		Case cNomRotin == "FINA470" .AND. nModProc == 2
			cMsg += "O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA472 - " + STR0088 //"Utilize a rotina "###"Concil. Bancária"
 		Case cNomRotin == "FINR470" .AND. nModProc == 2
			cMsg += "O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINR856 - " + STR0088 //"Utilize a rotina "###"Concil. Bancária"
		Otherwise
			lRet := .T.
	EndCase
	If lMsg .And. !Empty(cMsg)
		MsgAlert(cMsg)
	Else
		cTexto += cMsg
	EndIf
EndIf

RestArea(aAreaSX6)
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINEntBc

Verificacao e gravacao das entidades bancarias (ARGENTINA)
Arquivo original: FINXFUN.PRX

@author    Mauricio Pequim Jr
@version   11.80
@since     05/02/13

@param cBanco	- Código do Banco
@param cAgencia	- Código da Agência
@param cCodPost	- Código Postal

@return ExpL1 = Confirma a gravacao da entidade bancaria

/*/
//-----------------------------------------------------------------------------------------------------
Function FINEntBc(cBanco,cAgencia,cCodPost)

Local aArea := GetArea()
Local aAreaFJO := FJO->(GetArea())
Local aAreaFJN := FJN->(GetArea())

Default cBanco   := ""
Default cAgencia := ""
Default cCodPost := ""

//Cadastro de entidades bancarias (bancos)
dbSelectArea("FJO")
FJO->(DbSetOrder(1))
IF !(MsSeek(xfilial("FJO")+cBanco))
	RecLock("FJO",.T.)
	FJO->FJO_FILIAL := xFilial("FJO")
	FJO->FJO_COD 	:= cBanco
	MsUnlock()
Endif

dbSelectArea("FJN")
FJN->(DbSetOrder(2))
IF !(MsSeek(xFilial("FJN")+cCodPost+cBanco+cAgencia))
	RecLock("FJN",.T.)
	FJN->FJN_FILIAL := xFilial("FJN")
	FJN->FJN_POSTAL := cCodPost
	FJN->FJN_COD 	:= cBanco
	FJN->FJN_AGENCI := cAgencia
	MsUnlock()
Endif

RestArea(aAreaFJN)
RestArea(aAreaFJO)
RestArea(aArea)

Return .T.


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} EDITAPLIC

Editar o valor da cota do dia das aplicacoes por cotas (ligada a função Aplicacoes).
Arquivo original: FINXFUN.PRX

@author    Claudio D. de Souza
@since     03/10/2001
/*/
//-----------------------------------------------------------------------------------------------------
Static Function EditAplic(nCol,oAplic,aAplic)
Local nClick := 0

nClick := oAplic:nAtCol(nCol)

If nClick <> 1
	// Transforma para numerico para que o usuario possa editar o campo com entrada
	// de numeros apenas.
	aAplic[oAplic:nAt][nCol] := Val(StrTran(StrTran(aAplic[oAplic:nAt][nCol],".",""),",","."))
	lEditCell(@aAplic,oAplic,PesqPict("SE9","E9_VLRCOTA",18),nCol)
	// Volta para caracter o numero editado para que possa ser exibido corretamente
	// pela LISTBOX.
	aAplic[oAplic:nAt][nCol] := Transform(aAplic[oAplic:nAt][nCol],PesqPict("SE9","E9_VLRCOTA",18))
	oAplic:SetFocus()
EndIf
Return


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} APLICACOES

Exibe aplicacoes para selecao/informacao das cotas diarias.
Arquivo original: FINXFUN.PRX

@param lConsFil - considera filiais
@param nMoeda - código da moeda
@param lAvisa

@return aAplic (.f.,banco,agencia,conta,ome,saldo)

@author    Claudio D. de Souza
@since     03/10/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function Aplicacoes(lConsFil, nMoeda, lAvisa)
Local oDlgAplic
Local aAplic
Local nX
Local aArea    := GetArea()
Local aAreaSe9 := SE9->(GetArea())

Default lAvisa := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa array com os bancos existentes.						  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aAplic := GetAplic(lConsFil)
If !IsBlind()
	If Len(aAplic) == 0
		If lAvisa
			ApMsgAlert(STR0058) //"Nao existem aplicações financeiras"
		Endif
	Else
		ASort(aAplic)

		DEFINE MSDIALOG oDlgAplic TITLE STR0059 From 5,5 To 20,87 OF oMainWnd  //"Informe os valores das cotas diarias"
		@	.8, .5 LISTBOX oAplic FIELDS HEADER STR0060,STR0061,STR0062,STR0063,STR0064,STR0065 FIELDSIZES 14,25,31,31,60,40,40 SIZE 275, 100 OF oDlgAplic  //"Contrato"###"Banco"###"Agencia"###"Saldo"###"Vlr. Cota Atual"###"Vlr. Cota do dia"
		oAplic:SetArray(aAplic)
		oAplic:bLine      := {|| {	aAplic[oAplic:nAt,1],;
								   		aAplic[oAplic:nAt,2],;
								   		aAplic[oAplic:nAt,3],;
								   		aAplic[oAplic:nAt,4],;
								   		aAplic[oAplic:nAt,5],;
								   		aAplic[oAplic:nAt,6]}}

		oAplic:bLDblClick := {|| EditAplic(6,@oAplic,@aAplic),oAplic:GoRight(),oAplic:GoLeft()}

		DEFINE SBUTTON FROM 05, 290 TYPE 1 ACTION oDlgAplic:End() ENABLE OF oDlgAplic
		ACTIVATE MSDIALOG oDlgAplic

	Endif
	// Transforma o ultimo elemento da matriz (Valor da cota do dia) para numerico
	// Eliminando a picture deste campo e grava valor da cota do dia, caso exista o campo
	For nX := 1 To Len(aAplic)
		aAplic[nX][6] := Val(StrTran(StrTran(aAplic[nX][6],".",""),",","."))
		dbSelectArea("SE9")
		dbSetOrder(1)
		IF MsSeek(xFilial("SE9")+aAplic[nX][1]+aAplic[nX][2]+aAplic[nX][3]) .And. ;
			Str(SE9->E9_COTADIA,17,4) != Str(aAplic[nX][6],17,4)
			RecLock("SE9")
			SE9->E9_COTADIA := aAplic[nX][6]
		Endif
	Next
Endif
SE9->(RestArea(aAreaSe9))
RestArea(aArea)

Return aAplic


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GETAPLIC

Obter as aplicacoes do cadastro de aplicações (ligada a função Aplicacoes)
Arquivo original: FINXFUN.PRX

@param lConsFil - considera filiais
@param nMoeda - código da moeda
@param lAvisa

@return aAplic (.f.,banco,agencia,conta,ome,saldo)

@author    Claudio D. de Souza
@since     03/10/2001
/*/
//-----------------------------------------------------------------------------------------------------
Static Function GetAplic(lConsFil)
Local aRet     := {},;
		aArea    := GetArea(),;
		aAreaSeh := Seh->(GetArea()),;
		aAreaSe9 := Se9->(GetArea()),;
		cAplCotas:= GetMv("MV_APLCAL4"),;
		cIndSEH  := "",;
		cFiltro
DbSelectArea("SEH")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Filtra o arquivo de aplicacoes  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SEH")
cIndSEH := CriaTrab(,.F.)
If lConsFil
	cFiltro := "EH_TIPO$'"+&cAplCotas+"' .And. EH_FILIAL='"+xFilial("SEH")+"'"
Else
	cFiltro := "EH_TIPO$'"+&cAplCotas+"'"
Endif
IndRegua("SEH",cIndSEH,If(lConsFil, "EH_FILIAL+","")+"EH_NUMERO+EH_REVISAO",,cFiltro)
nIndSEH := RetIndex("SEH")
nIndSEH++

While !Eof() // Processa arquivo filtrado
	dbSelectArea("SE9")
	dbSetOrder(1)
	MsSeek(xFilial("SE9")+SEH->EH_CONTRAT+SEH->EH_BCOCONT+SEH->EH_AGECONT)
	dbSelectArea("SEH")

	Aadd(aRet,{	SEH->EH_CONTRAT,SEH->EH_BCOCONT,SEH->EH_AGECONT,Transform(SEH->EH_SALDO,PesqPict("SEH","EH_SALDO")),Transform(SE9->E9_VLRCOTA,PesqPict("SE9","E9_VLRCOTA",18)),;
					If(SE9->E9_COTADIA > 0,;
						Transform(SE9->E9_COTADIA,PesqPict("SE9","E9_COTADIA",18)),;
						Transform(SE9->E9_VLRCOTA,PesqPict("SE9","E9_VLRCOTA",18)))})
	DbSkip()
End

If !Empty(cIndSEH)
	dbSelectArea("SEH")
	RetIndex("SEH")
	dbClearFilter()
	Ferase(cIndSEH+OrdBagExt())
EndIf

SEH->(RestArea(aAreaSeh))
SE9->(RestArea(aAreaSe9))
RestArea(aArea)

Return aRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} TABELAIRF

Devolve o conteudo da tabela de IRF conforme a chave (FINA181 - Tabela AR do SX5)
Arquivo original: FINXFUN.PRX

@param cTab - conteudo da tabela
@param nChave - código da tabela

@author    Claudio D. de Souza
@since     24/04/2006
/*/
//-----------------------------------------------------------------------------------------------------
Function TabelaIrf(cTab,nChave)
Local cRet:="",xAlias
xAlias:=Alias()
DbSelectArea("SX5")
MsSeek(xFilial("SX5") + cTab)

While cTab == SX5->X5_TABELA .And. SX5->(!Eof())
	If Val(SX5->X5_CHAVE) >= nChave
		cRet := AllTrim(X5Descri())
		Exit
	Endif
	SX5->(dbSkip())
End

DbSelectArea(xAlias)

Return cRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} LOTECONT

Recupera o número do lote contábil.
Arquivo original: FINXFUN.PRX

@author    Wagner Xavier
@since     16/04/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function LoteCont( cChave )
	Local aArea := GetArea()

	dbSelectArea( "SX5" )
	MsSeek( xFilial("SX5") + "09" + Trim( cChave ) )
	If Eof()
		Help( " ", 1, "NOLOTCONT" )
		cLote := Space(Iif(CtbInUse(),6,4))
	Else
		If CtbInUse()
			cLote := Alltrim(SX5->X5_DESCRI)
		Else
			cLote := Substr(SX5->X5_DESCRI,1,4)
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se ‚ um EXECBLOCK e caso sendo, executa-o                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If At(UPPER("EXEC"),SX5->X5_DESCRI) > 0
		cLote := &(SX5->X5_DESCRI)
		cLote := Substr(cLote,1,Iif(CtbInUse(),6,4))
	Endif
	RestArea(aArea)

Return cLote


/*
----------------------------------------------------------------------------
	            Funcoes retiradas do arquivo MATXATU.PRX
----------------------------------------------------------------------------
*/

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} A050DUPPAG

Gravações complementares da inclusão de C.Pagar.
Arquivo original: MATXATU.PRX

@Author	Wagner Xavier
@since	28/02/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function A050DupPag( cOrigem AS CHARACTER, lUpDate AS LOGICAL, nTotIrrf AS NUMERIC, nTotINSS AS NUMERIC,;
                     lRtPICFCS AS LOGICAL, nTotISS AS NUMERIC, nBasISS AS NUMERIC, lRatImp AS LOGICAL,;
                     lFina050 AS LOGICAL, cRecIss AS CHARACTER, aCodR AS ARRAY, aMotRet AS ARRAY,;
                     lPccMR AS LOGICAL, lIrfMR AS LOGICAL, lInsMR AS LOGICAL, lIssMR AS LOGICAL,;
                     lCidMR AS LOGICAL, lSestMR AS LOGICAL, aRatIRF AS ARRAY, lFunMR AS Logical,;
                     lInsPMR AS LOGICAL, lFamadMR AS LOGICAL, lFethabMR AS LOGICAL, lFacsMR AS LOGICAL,;
                     lImaMR AS LOGICAL, lFabovMR AS LOGICAL, lDedSimpl AS LOGICAL )

	Local aAreaFor		AS ARRAY
	Local aForISSCPM    AS ARRAY
	Local aImpostos		AS ARRAY
	Local aRatSev		AS ARRAY
	Local aRatSez		AS ARRAY
	Local aRecImpos		AS ARRAY
	Local aTamParc		AS ARRAY
	Local aTamParcI		AS ARRAY
	Local cCNPJRET		AS CHARACTER
	Local cCodAprov		AS CHARACTER
	Local cCodForISS	AS CHARACTER
	Local cCodINSS		AS CHARACTER
	Local cCodMVINS		AS CHARACTER
	Local cCodMVRES  	AS CHARACTER
	Local cCodRetIr		AS CHARACTER
	Local cCodServ		AS CHARACTER
	Local cDiaISS       AS CHARACTER
	Local cFilDeb		AS CHARACTER
	Local cFilOrig		AS CHARACTER
	Local cForLojISS	AS CHARACTER
	Local cFornCD		AS CHARACTER
	Local cFornSe2		AS CHARACTER
	Local cFornUni		AS CHARACTER
	Local cForPai		AS CHARACTER
	Local cForSEST		AS CHARACTER
	Local cGeraDirf		AS CHARACTER
	Local cLa			AS CHARACTER
	Local cLojaImpos	AS CHARACTER
	Local cLojaIss		AS CHARACTER
	Local cLojaSe2		AS CHARACTER
	Local cLojaUni		AS CHARACTER
	Local cLojForISS	AS CHARACTER
	Local cLojPAi		AS CHARACTER
	Local cMultNat		AS CHARACTER
	Local cMunIss		AS CHARACTER
	Local cMVInsAcpj    AS CHARACTER
	Local cNatureza     AS CHARACTER
	Local cNome			AS CHARACTER
	Local cNum          AS CHARACTER
	Local cParcela      AS CHARACTER
	Local cParcFab		AS CHARACTER
	Local cParcFac		AS CHARACTER
	Local cParcFet		AS CHARACTER
	Local cParcFmd		AS CHARACTER
	Local cParcIMA		AS CHARACTER
	Local cPrefixo      AS CHARACTER
	Local cRecFab		AS CHARACTER
	Local cRecFac		AS CHARACTER
	Local cRecFet		AS CHARACTER
	Local cRecFmd		AS CHARACTER
	Local cRecIMA		AS CHARACTER
	Local cSEST			AS CHARACTER
	Local cTipoE2       AS CHARACTER
	Local cTipoFor		AS CHARACTER
	Local cTitPai		AS CHARACTER
	Local cVencIss		AS CHARACTER
	Local dDtRec		AS DATE
	Local dEmis1		AS DATE
	Local dEmissao      AS DATE
	Local dVctoReal		AS DATE
	Local dVencRea      AS DATE
	Local dVencRIss		AS DATE
	Local dVencto       AS DATE
	Local dVenISS		AS DATE
	Local lAgFETHA		AS LOGICAL
	Local lAplMinP		AS LOGICAL
	Local lAtuForn      AS LOGICAL
	Local lBtrISS		AS LOGICAL
	Local lCalcINP		AS LOGICAL
	Local lCalcIssBx	AS LOGICAL
	Local lCallMT103	AS LOGICAL
	Local lCond         AS LOGICAL
	Local lContinua     AS LOGICAL
	Local lCposIMA		AS LOGICAL
	Local lDedInss		AS LOGICAL
	Local lDesMinIR		AS LOGICAL
	Local lEmpPub		AS LOGICAL
	Local lF050GER		AS LOGICAL
	Local lFina986 		AS LOGICAL
	Local lFinVldIns	AS LOGICAL
	Local lInssBx		AS LOGICAL
	Local lInsss		AS LOGICAL
	Local lIrfRetAnt	AS LOGICAL
	Local lIRPFBaixa	AS LOGICAL
	Local lM050CSSP		AS LOGICAL
	Local lMata103		AS LOGICAL
	Local lParcLivre	AS LOGICAL
	Local lPCCBaixa		AS LOGICAL
	Local lPercINP		AS LOGICAL
	Local lRatInss		AS LOGICAL
	Local lRetPer		AS LOGICAL
	Local lSA2			AS LOGICAL
	Local lValBtrISS	AS LOGICAL
	Local lValISS		AS LOGICAL
	Local lVcAntIss		AS LOGICAL
	Local lVerMinIn		AS LOGICAL
	Local lZeraIrrf		AS LOGICAL
	Local nBtrISS		AS NUMERIC
	Local nCIDE			AS NUMERIC
	Local nCofins		AS NUMERIC
	Local nCsll			AS NUMERIC
	Local nDia			AS NUMERIC
	Local nDiaISS       AS NUMERIC
	Local nDiaUtil		AS NUMERIC
	Local nDiaUtIss		AS NUMERIC
	Local nFabov		AS NUMERIC
	Local nFacs			AS NUMERIC
	Local nFamad		AS NUMERIC
	Local nFethab		AS NUMERIC
	Local nI			AS NUMERIC
	Local nIMA			AS NUMERIC
	Local nImpostos		AS NUMERIC
	Local nInss			AS NUMERIC
	Local nIrrf			AS NUMERIC
	Local nIss			AS NUMERIC
	Local nMCusto		AS NUMERIC
	Local nMesIss		AS NUMERIC
	Local nMinIns       AS NUMERIC
	Local nMinRetIR		AS NUMERIC
	Local nMoeda		AS NUMERIC
	Local nOrdSe2		AS NUMERIC
	Local nPis			AS NUMERIC
	Local nRegSA2       AS NUMERIC
	Local nRegSe2       AS NUMERIC
	Local nRegSED       AS NUMERIC
	Local nSEST			AS NUMERIC
	Local nTamData		AS NUMERIC
	Local nTamFor		AS NUMERIC
	Local nValForte		AS NUMERIC
	Local nValInss		AS NUMERIC
	Local nVlMPub		AS NUMERIC
	Local nVlrCruz 		AS NUMERIC
	Local xMinRetIR		AS NUMERIC

	Default cOrigem 	:= ""
	Default lUpDate 	:= .T.
	Default nTotINSS 	:= 0
	Default lRtPICFCS 	:= .T.
	Default nTotISS 	:= SE2->E2_ISS
	Default nBasISS 	:= IIf(nTotISS>0,SE2->E2_VALOR+nTotISS,0)
	Default lRatImp  	:= .F.
	Default lFina050  	:= .F.
	Default nTotIrrf  	:= SE2->E2_IRRF
	Default cRecIss	  	:= ""
	Default aCodR		:= {}
	Default aRatIRF		:= {}
	//=== Motor de Retenções
	Default aMotRet 	:= {}
	Default lCidMR  	:= .F.
	Default lFabovMR    := .F.
	Default lFacsMR     := .F.
	Default lFamadMR    := .F.
	Default lFethabMR   := .F.
	Default lFunMR      := .F.
	Default lImaMR      := .F.
	Default lInsMR  	:= .F.
	Default lInsPMR  	:= .F.
	Default lIrfMR  	:= .F.
	Default lIssMR  	:= .F.
	Default lPccMR  	:= .F.
	Default lSestMR 	:= .F.
	Default lDedSimpl	:= .F.
	//====================//

	nValForte       := 0
	nIrrf           := 0
	nIss            := 0
	nInss           := 0
	nSEST           := 0
	cParcela        := ""
	dEmissao        := CTOD("")
	dVencto         := CTOD("")
	dVencRea        := CTOD("")
	cPrefixo        := ""
	cNum            := ""
	cTipoE2         := ""
	nMoeda          := SE2->E2_MOEDA
	nRegSe2         := 0
	nRegSA2         := 0
	nRegSED         := 0
	cNatureza       := ""
	lCond           := .F.
	lSA2            := .T.
	nTamData        := 0
	lZeraIrrf       := .F.
	cLa             := SE2->E2_LA
	nDiaUtil        := 0
	nDia            := 0
	nMCusto         := 0
	nOrdSe2         := SE2->(IndexOrd())
	cSEST           := GetMv("MV_SEST",,"")
	cForSEST        := PadR( GetMv("MV_FORSEST",,""), Len( SE2->E2_FORNECE ) )
	aTamParc        := TamSx3("E2_PARCELA")
	lM050CSSP       := ExistBlock("M050CSSP")
	cMunIss         := GetMv("MV_MUNIC")
	cNome           := ""
	cForLojISS      := ""
	dVenISS         := CtoD("")
	dEmis1          := SE2->E2_EMIS1
	dVctoReal       := SE2->E2_VENCREA
	cFornSe2        := SE2->E2_FORNECE
	cLojaSe2        := SE2->E2_LOJA
	cFilDeb         := SE2->E2_FILDEB
	cGeraDirf       := If(cPaisLoc=="BRA",SE2->E2_DIRF,"")
	cCodRetIr       := If(cPaisLoc=="BRA",SE2->E2_CODRET,"")
	cMultNat        := SE2->E2_MULTNAT
	cFornUni        := ""
	cLojaUni        := ""
	cLojaImpos      := PadR( "00", Len( SE2->E2_LOJA ), "0" )
	cLojaIss        := PadR( "00", Len( SE2->E2_LOJA ), "0" )
	nCofins         := 0
	nPis            := 0
	nCsll           := 0
	nFethab         := 0
	nFabov          := 0
	nFacs           := 0
	nFamad          := 0
	cParcFet        := ""
	cParcFab        := ""
	cParcFac        := ""
	cParcIMA        := ""
	cParcFmd        := ""
	aTamParcI       := {}
	cRecFet         := ""
	cRecFab         := ""
	cRecFac         := ""
	cRecIMA         := ""
	cRecFmd         := ""
	dDtRec          := CtoD("")
	lPCCBaixa       := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	lIRPFBaixa      := Iif(cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
	lDesMinIR       := Iif(cPaisLoc == "BRA", SA2->A2_MINIRF == "1", .F.) // Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
	nMinRetIR       := GetMv("MV_VLRETIR")
	xMinRetIR       := 0
	lCalcIssBx      := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
	aRatSev         := {}
	aRatSez         := {}
	nImpostos       := 0
	nCIDE           := 0
	lVcAntIss       := (SuperGetMV("MV_ANTVISS",.T.,"2") == "1")  //Antecipa ou nao o vencimento do ISS em caso de vencimento em dia nao util
	dVencRIss       := CTOD("//")
	cFornCD         := GetNewPar("MV_FORNCD","  ")
	cTipoFor        := ""
	lIrfRetAnt      := .F.
	cTitPai         := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
	cFilOrig        := SE2->E2_FILORIG
	lF050GER        := ExistBlock("F050GER")
	aRecImpos       := {}
	lFinVldIns      := Existblock("FinVldIns")
	cCodAprov       := SE2->E2_CODAPRO
	nDiaUtIss       := SuperGetMv("MV_DIAUISS",.T.,0) //Nro de dias uteis que deve ser gerado o vencimento do titulo do ISS.
	nI              := 0
	lInssBx         := SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
	aAreaFor        := {}
	cForPai         := ""
	cLojPAi         := ""
	cCNPJRET        := ""
	lAplMinP        := SA2->A2_MINPUB == "2"
	lEmpPub         := IsEmpPub() .And. lAplMinP
	nVlMPub         := SuperGetMv("MV_VLMPUB" ,.T.,10)
	lCallMT103      := IsInCallStack("MATA103")
	lPercINP        := SED->( ColumnPos("ED_PERCINP") ) > 0
	lCalcINP        := SED->( ColumnPos("ED_CALCINP") ) > 0
	cCodINSS        := SUBSTR(GetMv("MV_FORINSS"),1, TAMSX3("A2_COD")[1])
	nDiaISS         := SuperGetMv("MV_DIAISS",.F.,10,)
	cDiaISS         := StrZero(nDiaISS,2)
	nVlrCruz        := 0
	lAtuForn        := SuperGetMv("MV_ATUFORN",.F.,.T.)
	lFina986        := FindFunction("Fa986grava") .and. AliasInDic("FKG")
	lInsss          := .F.
	nMinIns         := 0
	nTamFor         := TamSx3("E2_FORNECE")[1]
	lDedInss        := .T.
	nValInss        := 0
	cMVInsAcpj      := SuperGetMv("MV_INSACPJ", .F., "1")
	lMata103        := FUNNAME() == "MATA103"
	lVerMinIn       := .T.
	nIMA            := 0
	lCposIMA        := (SE2->(ColumnPos("E2_IMA"))   > 0 .And. SE2->(ColumnPos("E2_PARCIMA")) > 0)
	lBtrISS         := SE2->(ColumnPos("E2_BTRISS")) > 0 .and. SE2->(ColumnPos("E2_VRETBIS")) > 0 .and. SE2->(ColumnPos("E2_CODSERV")) > 0
	nBtrISS         := 0
	lValBtrISS      := .F.
	lValISS         := .F.
	cCodServ        := ""
	cCodMVINS       := GetMv("MV_FORINSS")
	cCodMVRES       := GetMV("MV_RECEST")
	lRetPer         := .F.
	aForISSCPM      := {}
	cCodForISS      := ""
	cLojForISS      := ""
	lParcLivre      := .F.
	lContinua       := .T.
	lRatInss        := SuperGetMV("MV_RATINSS",.F.,.F.)
	nMesIss         := 0
	cVencIss        := ""
	aImpostos       := {}
	lAgFETHA        :=  SuperGetMv("MV_AGFETHA",,.F.)

	cOrigem := Iif( !Empty(cOrigem), Upper(cOrigem), Space(8) )

	If !__lIncNat
		//-- Carrega as naturezas de impostos
		__lIncNat:=.T.
		FININCNAT()
	EndIF

	If lPLSTITPF == NIL
		lPLSTITPF	:= ('PLS' $ SE2->E2_ORIGEM) .and. FindFunction("PLSTITPF")
	EndIf

	DbSelectArea("SA2")
	nRegSA2 := RecNo()
	DbSelectArea("SE2")
	nRegSE2 := RecNo()

	// Verifica se o ambiente esta configurado com Multiplos Vinculos de ISS
	cNome := "MUNICIPIO"
	If !Empty( SE2->E2_CODISS )
		DbSelectArea( "FIM" )
		FIM->( DbSetOrder( 1 ) )
		If FIM->( DbSeek( xFilial( "FIM" ) + SE2->E2_CODISS ) )
			cMunIss 	:= FIM->FIM_CODFOR
			cLojaIss	:= FIM->FIM_FORLOJ
			cNome	+= "-" + AllTrim( FIM->FIM_MUN )
		EndIf

		If AliasInDic("CC2")
			CC2->(DbSetOrder( 1 ))
			If CC2->(DbSeek(xFilial("CC2") + FIM->FIM_EST + FIM->FIM_CODMUN))
				dDtRec := CC2->CC2_DTRECO
			EndIf
		EndIf
	EndIf

	// Se o titulo estiver rateado em multiplas naturezas,
	If lRatImp .And. MV_MULNATP .And. SE2->E2_MULTNAT == "1"

		If __aSEVstru == NIL
			__aSEVstru	:=SEV->(DbStruct())
			__aSEZstru	:=SEZ->(DbStruct())
		EndIF

		nImpostos := If(lIRPFBaixa,0,SE2->E2_IRRF)+;
						If(!lCalcIssBx,SE2->E2_ISS,0)+;
						SE2->E2_INSS+;
						If(lPccBaixa,0,SE2->(E2_PIS+E2_COFINS+E2_CSLL))+SE2->E2_RETENC+SE2->E2_SEST
		// Carrega os rateios do titulo principal, para repassar aos titulos de impostos
		SEV->(DbSetOrder(2))
		SEZ->(DbSetOrder(1))
		SEV->(MsSeek(xFilial("SEV")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA+"1")))		//1=Inclusao
		While SEV->(EV_FILIAL+EV_PREFIXO+EV_NUM+EV_PARCELA+EV_TIPO+EV_CLIFOR+EV_LOJA+EV_IDENT) ==;
				xFilial("SEV")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA+"1")	//1 = Inclusao

			//Doc de Entrada ja desconsidera os impostos (quando parametrizado assim)
			//Não necessita atualizar o valor, mas é preciso carregar os dados (aRatSev e aRatSez) para gravar o rateio dos impostos
			If !lCallMT103 .And. nImpostos > 0
				// Recalcula os rateios, desconsiderando os impostos
				RecLock("SEV", .F.)
				SEV->EV_VALOR := SEV->EV_VALOR - (nImpostos*SEV->EV_PERC)
				msUnlock()
			EndIF

			// Adiciona todos os campos do SEV
			AAdd(aRatSev, {} )
			Aeval( __aSEVstru , { |e,i| Aadd(aRatSev[Len(aRatSev)], { e[1], SEV->(FieldGet(i)) } ) } )

			SEZ->(MsSeek(xFilial("SEZ")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA+SEV->EV_NATUREZ)))
			While SEZ->(EZ_FILIAL+EZ_PREFIXO+EZ_NUM+EZ_PARCELA+EZ_TIPO+EZ_CLIFOR+EZ_LOJA+EZ_NATUREZ) ==;
				xFilial("SEZ")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA+SEV->EV_NATUREZ)

				If !lCallMT103 .And. nImpostos > 0
					// Recalcula os rateios, desconsiderando os impostos
					RecLock("SEZ", .F.)
					SEZ->EZ_VALOR := (SEV->EV_VALOR * SEZ->EZ_PERC)
					msUnlock()
				EndIF

				AAdd(aRatSez, {} )
				Aeval( __aSEZstru , { |e,i| Aadd(aRatSez[Len(aRatSez)], { e[1], SEZ->(FieldGet(i)) } ) } )
				SEZ->(DbSkip())
			End
			SEV->(DbSkip())
		End
	Endif
	DbSelectArea("SED")
	SED->(MsSeek(xFilial("SED")+SE2->E2_NATUREZ))
	nRegSED := RecNo()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verificar o Municipio de ISS deste Fornecedor   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//FieldPos adicionado pois não foi encontrado a origem da criação deste campo – NÃO RETIRAR
	If SA2->(FieldPos("A2_MUNIC")) > 0 .And. !Empty(SA2->A2_MUNIC)
		cMvMunic := SA2->A2_MUNIC
		cForLojISS := Pad(cMvMunic,Len(SA2->A2_COD))+cLojaIss
	Else
		cForLojISS := Pad(cMunIss,Len(SA2->A2_COD))+cLojaIss
	EndIf

	If lBtrISS
		If  FunName() $ "FINA050|FINA750"	// FINA050 ainda nao encerrou o commit do titulo
			cCodServ := M->E2_CODSERV
		Else
			cCodServ := SE2->E2_CODSERV
		EndIf
		aForISSCPM := BtrISSMun( cCodServ, SA2->A2_EST, SA2->A2_COD_MUN )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Transfere titulo de ISS para fornecedor de origem ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(SE2->E2_FORNISS) .And. !Empty(SE2->E2_LOJAISS)
		cForLojISS := SE2->E2_FORNISS+SE2->E2_LOJAISS
		IF !Empty(cForLojISS)
			aAreaSA2 := SA2->(GetArea())
			DbSelectArea("SA2")
			DbSetOrder(1)
			If DbSeek(xFilial("SA2")+SE2->E2_FORNISS+SE2->E2_LOJAISS)
				cNome := SA2->A2_NREDUZ
			EndIF
			RestArea(aAreaSA2)
		ENDIF
	EndIf

	If !Empty(SE2->E2_VENCISS)
		dVenISS := SE2->E2_VENCISS
	EndIf

	If Empty(cRecIss)
		cRecIss	:=	SA2->A2_RECISS
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza dados do Fornecedor 			   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE2")
	lCond := .F.

	If ( cRecIss$"1S" .And. lSA2)     // Fornecedor recolhe ISS
		If !E2_NATUREZ$&(GetMv("MV_ISS")) .Or. !E2_NATUREZ$&(GetMv("MV_IRF")) .or.;
			!E2_NATUREZ$&(GetMv("MV_INSS")) .or. !E2_NATUREZ$AllTrim(cSEST)
			lCond := .T.
		EndIf
	ElseIf SA2->A2_RECINSS == "S" .Or. (lCalcINP .And. SED->ED_CALCINP == "1")      // Fornecedor recolhe INSS
		If !E2_NATUREZ$&(GetMv("MV_ISS")) .Or. !E2_NATUREZ$&(GetMv("MV_IRF")) .or.;
			!E2_NATUREZ$&(GetMv("MV_INSS"))
			lCond := .T.
		EndIf
	ElseIf cPaisLoc == "BRA" .And. SA2->A2_RECSEST $ "S1"      // Fornecedor recolhe SEST
		If !E2_NATUREZ$&(GetMv("MV_ISS")) .Or. !E2_NATUREZ$&(GetMv("MV_IRF")) .or.;
			!E2_NATUREZ$AllTrim(cSEST)
			lCond := .T.
		EndIf
	ElseIf ( !E2_NATUREZ$&(GetMv("MV_IRF")) )
		lCond := .T.
	EndIf

	If SED->ED_DEDINSS == "2"
		lDedInss := .F. // Não Deduz
	Else
		lDedInss := .T. // Deduz
	EndIf

	If lFina986
		//realiza a gravacao do model
		Fa986grava("SE2",cOrigem)
	EndIf

	cTipoFor := SA2->A2_TIPO
	If cTipoFor == "J"
		nMinIns := SuperGetMv("MV_VLRETIN", .T., 25) // Valor minimo para Pessoa Juridica
	ElseIf cTipoFor == "F"
		nMinIns := SuperGetMv("MV_MININSS", .T., 0) // Valor minimo para Pessoa Fisica
	EndIf

	If ( lCond )
		//Ponto de entrada para tratamento do valor minimo para IRRF.
		If ExistBlock("F040MIRF")
			xMinRetIR := 0
			xMinRetIR := Execblock("F040MIRF",.F.,.F.,{SA2->A2_COD,SA2->A2_LOJA})
			nMinRetIR := If(ValType(xMinRetIR)=="N",xMinRetIR,nMinRetIR)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza dados do Cta Pagar					  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "BRA"
			//Verificacao do valor minimo de IRRF - Nao gerados pelo FINANCEIRO
			If !lIrfMR .And. !lFina050
				nTotIrrf := FCalcIr(0,cTipoFor,.F.,@lIrfRetAnt,.F.)
				If ( cOrigem == "MATA100" ) .And. nTotIrrf != Nil .And. GetMv("MV_VENCIRF") == "E"
					// Verifica se o fornecedor trata o valor minimo de retencao e se a regra se aplica.
					If lEmpPub .and. !lIrfRetAnt .And. SE2->(E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL)+nTotIrrf < nVlMPub
						lZeraIrrf	:= .T.
					ElseiF !lDesMinIR .And. (nTotIrrf <= nMinRetIR .and. !lIrfRetAnt)
						lZeraIrrf	:= .T.
					EndIf
				Else
					// Verifica se o fornecedor trata o valor minimo de retencao , se a regra se aplica e se o titulo nao foi gerado pelo fina050
					If lEmpPub .and. !lIrfRetAnt .And. SE2->(E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL)+nTotIrrf < nVlMPub
						lZeraIrrf	:= .T.
					ElseiF !lDesMinIR .And. (nTotIrrf <= nMinRetIR .and. !lIrfRetAnt)
						lZeraIrrf	:= .T.
					Endif
				EndIf
				If lZeraIrrf .and. !lIRPFBaixa
					DbSelectArea("SE2")
					RecLock("SE2",.F.)
					SE2->E2_VALOR	+= SE2->E2_IRRF
					SE2->E2_SALDO	+= SE2->E2_IRRF
					SE2->E2_VLCRUZ  := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
					SE2->E2_VRETIRF := SE2->E2_IRRF
					SE2->E2_IRRF	:= 0
				ElseIf !lFina050 .and. nTotIrrf > SE2->E2_IRRF
					//Recompoem o valor do IRRF no saldo e desconta o valor acumulado
					DbSelectArea("SE2")
					RecLock("SE2",.F.)
					SE2->E2_VALOR	+= SE2->E2_IRRF - nTotIrrf
					SE2->E2_SALDO	+= SE2->E2_IRRF - nTotIrrf
					SE2->E2_VLCRUZ  := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
					SE2->E2_VRETIRF := SE2->E2_IRRF
					SE2->E2_IRRF	:= nTotIrrf
				ElseIf lIRPFBaixa
					RecLock("SE2",.F.)
					SE2->E2_PRETIRF := '1'
				Else
					DbSelectArea("SE2")
					RecLock("SE2",.F.)
					SE2->E2_VRETIRF := SE2->E2_IRRF
				EndIf
			Endif

			nVlrCruz := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))

			If lFina050
				If nVlrCruz > SE2->E2_VLCRUZ .And. Abs(nVlrCruz - SE2->E2_VLCRUZ) != 0.01
					SE2->E2_VLCRUZ	:= nVlrCruz
				Else
					nVlrCruz := SE2->E2_VLCRUZ
				EndIf
			EndIf

			// Faço somente para o Compras, pois no Mata103 não consideram que o minimo de retenção de Pessoa Fisica e juridica possa ser diferentes
			If lMata103
				dDataFim  := LastDay( SE2->E2_VENCREA  )
				dDataIni  := FirstDay( SE2->E2_VENCREA  )
				dEmissao  := E2_EMISSAO
				dVencRea  := E2_VENCREA
				lInsss	  := .F.


				If ( SA2->A2_TIPO == "J" .And. cMVInsAcpj == "1") .Or. SA2->A2_TIPO == "F"//Cumulatividade
					nValInss := VerInssCalc( SA2->A2_COD, SA2->A2_LOJA, SA2->A2_NREDUZ, SE2->E2_EMISSAO, SE2->E2_VENCREA,,,@lRetPer )
					//Necess rio passar pela fun‡?o VerInssCalc para verificar se houve reten‡?o no mesmo per¡odo (retorno da vari vel lRetPer).
					If lRatInss
						nValInss := 0
					EndIf
				Else
					nValInss := 0
				EndIf

				If nMinIns > 0
					lVerMinIn	:= .T.
				Else
					lVerMinIn	:= .F.
				EndIf

				If nValInss < nMinIns
					lInsss:= .T.
				Endif

				If lInsss .And. (If(lFinVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. ))
					DbSelectArea("SE2")
					RecLock("SE2", .F.)

					If !lRetPer .And. lVerMinIn .And. (nValInss + nTotINSS) < nMinIns
						If lDedInss
							SE2->E2_VALOR	+= SE2->E2_INSS // Somo o valor do imposto no valor do titulo devido ao compras realizar a subtração sem verificar cumulatividade
							SE2->E2_SALDO	+= SE2->E2_INSS
							SE2->E2_VLCRUZ	:= nVlrCruz
						EndIf

						//Verifico se o valor Acumulado somado ao valor do INSS do titulo atual é igual ao valor E2_INSS
						//pois se a soma dos dois está igual é necessario corrigir para não impactar no valor a ser retido no futuro.
						If cMVInsAcpj == "1"
							If SE2->E2_INSS <> 0
								If nValInss + nTotINSS == SE2->E2_INSS
									SE2->E2_VRETINS := nTotINSS
								Else
									SE2->E2_VRETINS := SE2->E2_INSS
								EndIf
							Else
								SE2->E2_VRETINS := nTotINSS
							EndIf
						Else
							SE2->E2_VRETINS := If(SE2->E2_INSS == 0, nTotINSS, SE2->E2_INSS )
						EndIf
						SE2->E2_PRETINS := "1"
						SE2->E2_INSS	:= 0
					EndIf
				EndIf
				lRetPer	:= .F.
			Endif

			If !lIrfMR .And. lIRPFBaixa
				RecLock("SE2",.F.)
				SE2->E2_PRETIRF	:= "1"
			EndIf

			If !lIrfMR .And. ( cOrigem == "MATA100" ) .And. !lIRPFBaixa
				// Ajuste de cumulatividade de IRRF que ultrapassa valor do título
				If SE2->E2_IRRF > SE2->E2_VALOR .And. SE2->E2_VALOR < 0
					SE2->E2_IRRF  += SE2->E2_VALOR - 0.01
					SE2->E2_VALOR := 0.01
					SE2->E2_SALDO := 0.01
				EndIf
			EndIf

			If !lIssMR .And. lCalcIssBx
				If nTotISS > 0 .And. nTotISS <= SuperGetMv("MV_VRETISS",.T.,0)
					SE2->E2_ISS	:= 0
				EndIf
			EndIf
		ElseIf ( cPaisLoc <> "RUS" )
			nVlrCruz := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))

			DbSelectArea("SE2")
			RecLock("SE2",.F.)
			SE2->E2_VLCRUZ := nVlrCruz
		EndIf
		If ExistBlock("ATUDPPAG")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de Entrada para Atualiza‡”es no SE2   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ExecBlock("ATUDPPAG",.f.,.f.,cOrigem)
		EndIf
		nRegSe2	  := RecNo()
		cPrefixo  := SE2->E2_PREFIXO
		cNum	  := SE2->E2_NUM
		cTipoE2	  := SE2->E2_TIPO
		nValForte := ConvMoeda(SE2->E2_EMISSAO,SE2->E2_VENCTO,SE2->E2_VALOR,GetMv("MV_MCUSTO"))

		// Criado o parametro MV_FORNCD para possibilitar um grande volume de notas SEM LOCK do SA2 para definir, por exemplo, notas de um centro de
		// distruicao (ponto de gargalo)
		If !SE2->E2_TIPO $ MVABATIM .And. cFornCD != SE2->E2_FORNECE + SE2->E2_LOJA .And. lAtuForn
			RecLock(If(lSA2,"SA2","SA1"))
			If ! ( SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG )
				If lSA2 .and. SA2->(!Eof())
					SA2->A2_SALDUP +=Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3,SE2->E2_TXMOEDA),3),2)
					SA2->A2_SALDUPM+=Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,Val(GetMv("MV_MCUSTO")),SE2->E2_EMISSAO,3),3),2)
				EndIf
			ElseIf SE2->E2_TIPO $ MV_CPNEG .and. cPaisLoc = "ARG" .and. funname()== "MATA466N" .and. SA2->(!Eof())
				SA2->A2_SALDUP -=Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3,SE2->E2_TXMOEDA),3),2)
			ElseIf ( !lSA2 ) .and. SA2->(!Eof())
				AtuSalDup("-",SE2->E2_VALOR,SE2->E2_MOEDA,SE2->E2_TIPO,,SE2->E2_EMISSAO)
			EndIf
			nValForte:=ConvMoeda(SE2->E2_EMISSAO,SE2->E2_VENCTO,If(lSA2,A2_SALDUP,A1_SALDUP),GetMv("mv_mcusto"))
			nMCusto:=Val(GetMV("MV_MCUSTO"))
			If ( lSA2 ) .AND. SA2->(!Eof())
				DbSelectArea( "SA2" )
				If ( SA2->A2_SALDUPM > A2_MSALDO )
					SA2->A2_MSALDO := SA2->A2_SALDUPM
				EndIf
				SA2->A2_PRICOM  := Iif(SE2->E2_EMISSAO<A2_PRICOM .Or. Empty(SA2->A2_PRICOM),SE2->E2_EMISSAO,SA2->A2_PRICOM)
				SA2->A2_ULTCOM  := Iif(SA2->A2_ULTCOM<SE2->E2_EMISSAO,SE2->E2_EMISSAO,SA2->A2_ULTCOM)

				If __lRskActv == NIL // VERIFICA SE O MAIS NEGÓCIOS ESTÁ ATIVO NO AMBIENTE
					__lRskActv := .F.
					If FindFunction("RskIsActive")
						__lRskActv := RskIsActive()
					EndIf
				EndIf

				If __lRskActv // VERIFICA O CONTEÚDO DO PARÂMETRO COM O CÓDIGO DO FORNECEDOR NA SA2 PARA A SUPPLIER
					If __cRskFPay == NIL
						__cRskFPay := SuperGetMV("MV_RSKFPAY",, "SUPPLI|01")
					EndIf
				Else
					__cRskFPay := ""
				EndIf

				If (!__lRskActv .or. !(AllTrim(SA2->A2_COD) + "|" + AllTrim(SA2->A2_LOJA) == AllTrim(__cRskFPay)))
					SA2->A2_NROCOM  := SA2->A2_NROCOM + If( lUpDate,1,0 )
				EndIf

				If ( SA2->A2_MCOMPRA < Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2) )
					SA2->A2_MCOMPRA := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2)
				EndIf
				If SubStr(SE2->E2_ORIGEM,1,3) == "FIN"
					SA2->A2_MNOTA   := Max(SA2->A2_MNOTA,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2) )
				ElseIf SubStr(cOrigem,1,7) $ "MATA100"
					aArea := SF1->(GetArea())
					DbSelectArea("SF1")
					DbSetOrder(1)
					DbSeek(xFilial("SF1")+SE2->E2_NUM+SE2->E2_PREFIXO+SE2->E2_FORNECE+SE2->E2_LOJA)
					SA2->A2_MNOTA   := Max(SA2->A2_MNOTA,Round(NoRound(xMoeda(SF1->F1_VALBRUT,SE2->E2_MOEDA,nMCusto,SF1->F1_EMISSAO,3),3),2) )
					RestArea(aArea)
				EndIf
			EndIf
			If lSA2
				If lAtuForn
					SA2->(MsUnlock())
				EndIf
			Else
				SA1->(MsUnlock())
			EndIf
		EndIf

		DbSelectArea( "SE2" )
		cParcela := E2_PARCELA
		dEmissao := E2_EMISSAO
		dVencto	 := E2_VENCREA
		If !lIrfMR
			nIrrf 	 := E2_IRRF
		EndIf
		If !lIssMR
			lValISS	 := (nIss := E2_ISS) > 0
			If lBtrISS
				nBtrISS    := E2_BTRISS
				lValBtrISS := nBtrISS > 0
				cCodServ   := E2_CODSERV
			EndIf
		EndIf
		If !lInsMR
			nInss 	 := E2_INSS
		EndIf
		If !lSestMR
			nSEST 	 := E2_SEST
		EndIf
		If !lCidMR .And. cPaisLoc == "BRA"
			nCIDE 	 := E2_CIDE
		EndIf

		If !lPccMR
			nCofins  := SE2->E2_COFINS
			nPis     := SE2->E2_PIS
			nCsll    := SE2->E2_CSLL

			If lEmpPub
				If (lPCCBaixa  .And. nPis + nCofins + nCsll + nIrrf < nVlMPub) .Or. (!lPCCBaixa .And. lZeraIrrf )
					nPis := nCofins := nCsll := nIrrf := 0
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo de IRRF para PAs 				  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lIrfMR .And. nIrrf > 0 .and. (!lIRPFBaixa .or. (lIRPFBaixa .And. SE2->E2_TIPO $ MVPAGANT))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Calculo do vencimento do imposto³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			If !Empty(aCodR) .And. aScan( aCodR, {|aX|aX[4]=="IRR"})>0 .And. lMT103DRF
				cCodRetIR := aCodR[aScan( aCodR, {|aX|aX[4]=="IRR"})][2]
			Endif

			dVencRea := F050VIMP("IRRF",dEmissao,dEmis1,dVctoReal,cCodRetIr,cTipoFor,lIRPFBaixa)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Grava título do IRRF e informações relacionadas ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			FGrvIRRF(cOrigem,dVencRea,dEmissao,cPrefixo,cNum,cTipoE2,nIrrf,nMoeda,cLa,cGeraDIRF,cCodRetIR,lRatImp,;
			aRatSev,aRatSEZ,nRegSE2,'SE2',lIRPFBaixa,aRecImpos,aRatIRF,@aImpostos )

		EndIf

		//Gravação dos impostos motor retenções
		If __lMotRet .And. Len(aMotRet) > 0
			FinGrvImp("1", nRegSE2, aMotRet, cOrigem, lRatImp, aRatSev, aRatSez, .T., .F., .F., dEmissao, "", "")
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo de INSS 							  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lInsMR .And. nInss > 0
			//Caso inss na baixa nao devo gravar o titulo do imposto na inclusao do titulo pai no financeiro ou em outros modulos.
			If  (!lInssBx) .Or. ( lInssBx .And. !(FwIsInCallStack("FINA050")) .And. Subst(cOrigem,1,4) <> "MATA")
				//Forcar o posicionamento do fornecedor para evitar que o tipo de fornecedor que a funcao fGrvINSS passara para determinar o vencimento do imposto (MP447)
				//seja determinado incorretamente.

				If !Empty(aCodR) .And. aScan( aCodR, {|aX|aX[4]=="INS"})>0 .And. lMT103DRF
					cCodRetIR := aCodR[aScan( aCodR, {|aX|aX[4]=="INS"})][2]
				Endif

				SA2->(dbGoto(nRegSA2))
				FGrvINSS(cPrefixo,cNum,cParcela,cLojaImpos,cOrigem,nMoeda,nRegSED,nRegSE2,dEmissao,dEmis1,dVctoReal,nInss,;
							lRatImp,aRatSev,aRatSez,cGeraDIRF,cCodRetIR,,,aRecImpos)

				If !Empty(SE2->E2_CODRET) .and. SA2->A2_TIPO = "J" .and. nIrrf == 0 .and. ( nPis + nCofins + nCsll ) == 0
					Reclock("SE2", .F.)
					SE2->E2_DIRF := "1"
					SE2->(MsUnlock())
				EndIf
			Endif
		ElseIf !lInsMR .And. nInss = 0
			SA2->(dbGoto(nRegSA2))
			SED->(dbGoto(nRegSED))
			If  !Empty(SE2->E2_CODRET) .And. SE2->E2_DIRF = "1" .And. SA2->A2_RECINSS = "S" .And. SA2->A2_TIPO="F" .And. SED->ED_CALCINS="S"
				Reclock("SE2", .F.)
				SE2->E2_DIRF := "2"
				SE2->(MsUnlock())
			Endif

			If SE2->E2_VRETINS > 0 .And. SA2->A2_RECINSS = "S" .And. SED->ED_CALCINS="S"
				Reclock("SE2", .F.)
				SE2->E2_PRETINS := "1" // Se possui valor a reter, grava 1 pendente de retenção
				SE2->(MsUnlock())
			EndIf
		EndIf

		//Titulo de Pessoa Fisica com natureza para reter Inss mas que não foi gerado o titulo do imposto.
		If !lInsMR .And. !Empty(SE2->E2_CODRET) .And. SA2->A2_TIPO="F" .And. SED->ED_CALCINS="S" .And. ;
						SED->ED_CALCIRF $ "N " .And. SED->ED_CALCISS $ "N " .And. ;
						SED->ED_CALCCSL $ "N " .And. SED->ED_CALCCOF $ "N " .And. SED->ED_CALCPIS $ "N "
			If nInss > 0 .AND. !lInssBx
				Reclock("SE2", .F.)
				SE2->E2_DIRF := "2" //Titulo do imposto Inss foi gerado.
				SE2->(MsUnlock())
			Else
				Reclock("SE2", .F.)
				SE2->E2_DIRF := "1" //Titulo pai retém Inss mas não gerou titulo do imposto.
				SE2->(MsUnlock())
			Endif
		Endif

		// Para títulos PJ que retenham apenas INSS
		If !Empty(SE2->E2_CODRET) .And. SA2->A2_TIPO = "J" .And. SED->ED_CALCINS = "S" .And.;
			SED->ED_CALCIRF = "N" .And. SED->ED_CALCISS = "N" .And. SED->ED_CALCCSL = "N" .And.;
			SED->ED_CALCCOF = "N" .And.	SED->ED_CALCPIS = "N"

			Reclock("SE2", .F.)
				SE2->E2_DIRF := "1"
			SE2->(MsUnlock())
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo de SEST 					   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lSestMR .And. nSEST > 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o Fornecedor, caso nao exista 	       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SA2")
			If !(DbSeek(xFilial() + cForSEST + cLojaImpos ))
				Reclock("SA2",.T.)
				SA2->A2_FILIAL := cFilial
				SA2->A2_COD 	:= cForSEST
				SA2->A2_LOJA	:= cLojaImpos
				SA2->A2_NOME	:= STR0068  //Servico Social do Transporte
				SA2->A2_NREDUZ :=  "SEST"
				SA2->A2_BAIRRO := "."
				SA2->A2_MUN 	:= "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	:= "."
				SA2->A2_TIPO	:= "J"
				MsUnlock()
				FKCOMMIT()
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza SEST caso nao exista		  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cNatureza		:= cSEST
			cNatureza		:= cNatureza+Space(10-Len(cNatureza))
			DbSelectArea("SED")
			If !DbSeek(cFilial+cNatureza)
				RecLock("SED",.T.)
				SED->ED_FILIAL  := cFilial
				SED->ED_CODIGO  := cNatureza
				SED->ED_CALCIRF := "N"
				SED->ED_CALCISS := "N"
				SED->ED_CALCINS := "N"
				SED->ED_CALCCSL := "N"
				SED->ED_CALCCOF := "N"
				SED->ED_CALCPIS := "N"
				SED->ED_DESCRIC := STR0068 //Servico Social do Transporte
				SED->ED_TIPO	:= "2"
				MsUnlock()
				Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
				FKCOMMIT()
			EndIf
			DbGoTo(nRegSED)

			cParcela := STRZERO(1,aTamParc[1])
			While .T.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ VerIfica se ja' ha' titulo de SEST com esta numera‡„o ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SE2")
				DbSetOrder(1)
				If (DbSeek(cFilial+cPrefixo+cNum+cParcela+"SES"+cForSEST))
					cParcela := Soma1( cParcela,,.t. )
					Loop
				EndIf
				Exit
			End
			DbGoTo( nRegSe2 )

			// Calcula o vencto do imposto
			// Na mesma data do titulo de INSS
			dVencRea := F050VIMP("INSS",dEmissao,dEmis1,dVctoReal,,cTipoFor)

			RecLock("SE2",.T.)
			SE2->E2_FILIAL  := xFilial()
			SE2->E2_PREFIXO := cPrefixo
			SE2->E2_NUM 	 := cNum
			SE2->E2_PARCELA := cParcela
			SE2->E2_TIPO	 := "SES"
			SE2->E2_EMISSAO := dEmissao
			SE2->E2_VALOR	 := nSEST
			SE2->E2_VENCREA := dVencrea
			SE2->E2_SALDO	 := nSEST
			SE2->E2_VENCTO  := dVencRea
			SE2->E2_VENCORI := dVencRea
			SE2->E2_MOEDA	 := If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_EMIS1	 := dDataBase
			SE2->E2_FORNECE := cForSEST
			SE2->E2_VLCRUZ  := Round( SE2->E2_VALOR, MsDecimais(1) )
			SE2->E2_LOJA	 := SA2->A2_LOJA
			SE2->E2_NOMFOR  := SA2->A2_NREDUZ
			SE2->E2_ORIGEM  := cOrigem
			SE2->E2_NATUREZ := cNatureza
			SE2->E2_LA      := "S"
			SE2->E2_TITPAI  := cTitPai
			SE2->E2_FORMPAG := SA2->A2_FORMPAG
			If !Empty(cFilDeb)
				SE2->E2_FILDEB := cFilDeb
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava a filial de origem quando existir o campo no SE2            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE2->E2_FILORIG := cFilorig //filial origem do titulo pai
			SE2->E2_MULTNAT := cMultNat
			SE2->E2_CODAPRO := cCodAprov
			//Grava Retenção INSS
			SE2->E2_RETINS := GetAdvFval("SE2","E2_RETINS",cTitPai,1,"")

			//Grava CNPJ da Retenção INSS
			cForPai	:= GetAdvFval("SE2","E2_FORNECE",cTitPai,1,"")
			cLojPAi	:= GetAdvFval("SE2","E2_LOJA",cTitPai,1,"")
			cTipoFor 	:= ALLTRIM(GetAdvFval("SA2","A2_TIPO",xFilial("SA2")+cForPai+cLojPAi,1,""))
			If cTipoFor == "J"
				cCNPJRET := GetAdvFval("SA2","A2_CGC",xFilial("SA2")+cForPai+cLojPAi,1,"")
			Else
				cCNPJRET := GetAdvFval("SM0","M0_CGC",cEmpAnt+xFilial("SE2"),1,"")
			EndIf
			cRETINS := GetAdvFval("SE2","E2_RETINS",xFilial("SE2")+cPrefixo+cNum+cParcela,1,"")

			SE2->E2_CNPJRET := cCNPJRET
			MsUnlock()
			FKCOMMIT()
			
			FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)

			if lPLSTITPF
				PLSTITPF('SE2',cTitPai)
			endIf

			AADD(aRecImpos,{"SE2",Recno()})

			If ExistBlock("F050SES")
				Execblock("F050SES",.F.,.F.,nRegSE2)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava lançamento do imposto SEST/SENAT no SIGAPCO se a rotina foi chamada do contas a pagar ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If "FINA050" $ cOrigem
				PCODetLan("000002","08","FINA050")
			EndIf
			// Se rateia os impostos, grava o rateio multipla natureza/centro de custo
			If lRatImp
				// Grava SEV e SEZ dos impostos, baseado nos percentuais do rateio do titulo principal
				GrvSevSezImp(aRatSev,aRatSez,SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_VALOR)
			Else
				AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava parcela do SEST na parcela do titulo ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea( "SE2" )
			DbGoTo( nRegSe2 )
			Reclock( "SE2" ,.F.)
			SE2->E2_PARCSES := cParcela
			MsUnlock()

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo de CIDE 					   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lCidMR .And. nCIDE > 0

			// Calcula o vencto do imposto
			dVencRea := F050VIMP("CIDE",dEmissao,dEmis1,dVctoReal)

			// Gravação do Título de CIDE
			nRecTit := FGrvCIDE( nCIDE, dEmissao, dVencRea, nRegSe2, , cOrigem )

			If lPLSTITPF
				PLSTITPF('SE2',cTitPai)
			endIf

			AADD(aRecImpos,{"SE2",nRecTit})

			// Se rateia os impostos, grava o rateio multipla natureza/centro de custo
			If lRatImp
				// Grava SEV e SEZ dos impostos, baseado nos percentuais do rateio do titulo principal
				GrvSevSezImp(aRatSev,aRatSez,SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_VALOR)
			Else
				AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
			EndIf

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo de ISS						   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lIssMR .And. (( lValISS .And. (!lCalcIssBx .or. (lCalcIssBx .And. SE2->E2_TIPO $ MVPAGANT))) .or. lValBtrISS)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o fornecedor, caso nao exista 		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lValISS
				DbSelectArea("SA2")
				MsSeek(cFilial+cForLojISS)
				If ( EOF() )
					Reclock("SA2",.T.)
					SA2->A2_FILIAL   := cFilial
					SA2->A2_COD 	  := Left(cForLojISS,Len(SA2->A2_COD))
					SA2->A2_LOJA	  := Right(cForLojISS,Len(SA2->A2_LOJA))
					SA2->A2_NOME	  := cNome //"MUNICIPIO"
					SA2->A2_NREDUZ   := cNome //"MUNICIPIO"
					SA2->A2_BAIRRO   := "."
					SA2->A2_MUN 	  := "."
					SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
					SA2->A2_End 	  := "."
					MsUnlock()
					FKCOMMIT()
				EndIf

				cParcela := STRZERO(1,aTamParc[1])
				While ( .T. )
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ VerIfica se ja' ha' titulo de ISS com esta numera‡„o ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					DbSelectArea("SE2")
					DbSetOrder(1)
					If (DbSeek(cFilial+cPrefixo+cNum+cParcela+"ISS"+cForLojISS))
						cParcela := Soma1( cParcela,,.t.)
						Loop
					EndIf
					Exit
				EndDo
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza ISS caso nao exista		  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cNatureza	:= &(GetMv("MV_ISS"))
			cNatureza	:= cNatureza + Space( 10 - Len( cNatureza ) )
			cVencIss	:= GetNewPar("MV_VENCISS","E")
			nMesIss		:= GetNewPar( "MV_MESISS", 1 )
			nMesIss		:= If( nMesIss > 0, nMesIss, 1 )
			If Empty(dVenISS)
				Do Case
					Case nDiaUtIss > 0 //Vencimento do ISS deve ser gerado por dias uteis.

						nMesIss		:= If( nMesIss == 1, 0, nMesIss - 1 )

						If lCalcIssBx // Mes subsequente de acordo com o momento de retenção do imposto.
							dVenISS	:= LastDay( MonthSum( dVencto, nMesIss ) )
						Else
							dVenISS	:= LastDay( MonthSum( dEmissao, nMesIss ) )
						Endif

						For nI:= 1 To nDiaUtIss
							dVenISS ++
							dVenISS := DataValida(dVenISS)
						Next nI

					Case cVencIss == "E" //E=Emissão

						dVenISS		:= MonthSum( dEmissao, nMesIss )

						nTamData	:= If( Len( Dtoc( dVenISS ) ) == 10, 7, 5 )

						//Caso o mes do vcto seja Fevereiro e o parametro MV_DIAISS estiver 30 ou 31
						If Month(dVenISS) == 2 .And. cDiaISS $ "30/31"
							dVenISS := LastDay(dVenISS)
						Else
							If !Empty(dDtRec)
								dVenISS	:= Ctod( StrZero( dDtRec, 2 ) + "/" + Subs( Dtoc( dVenISS ), 4, nTamData ) )
							Else
								dVenISS	:= Ctod( cDiaISS + "/" + Subs( Dtoc( dVenISS ), 4, nTamData ) )
							Endif
						Endif

					Case cVencIss == "Q" //Ultimo dia util da quinzena subsequente a dEmissao

						If Day(dEmissao) <= 15
							nMesIss	:= If( nMesIss == 1, 0, nMesIss - 1 )
							dVenISS	:= LastDay( MonthSum( dEmissao, nMesIss ) )
							dVenISS := DataValida( dVenISS, .F. )
						Else
							//dVenISS := DataValida( ( LastDay(dEmissao) + 1 ) + 14, .F. )
							dVenISS := DataValida( FirstDate( MonthSum( dEmissao, nMesIss ) ) + 14, .F. )
						EndIf

					Case cVencIss == "U" //Ultimo dia util do mes subsequente da dEmissao
						//ok
						dVenISS := DataValida( LastDay( MonthSum( dEmissao, nMesIss ) ), .F. )

					Case cVencIss == "D"

						dVenISS		:= FirstDay( MonthSum( dEmissao, nMesIss ) )
						nDiaUtil	:= nDiaISS

						For nDia := 1 To nDiaUtil-1
							If !(dVenISS == DataValida(dVenISS,.T.))
								nDia-=1
							EndIf
							dVenISS+=1
						Next nDia

					Case cVencIss == "F" //Qtd de dia do parametro MV_DIAISS apos o fechamento da quinzena.
						/*F =	Se a data de emissão for menor que 15 (primeira quinzena) a data
								de vencimento será 15 mais o conteúdo do MV_DIAISS (considerando
								o primeiro dia do mês na conta), se a data de emissão for maior que
								15 (segunda quinzena) será no dia informado no MV_DIAISS do mês subsequente.*/

						If Day(dEmissao) <= 15
							nMesIss	:= If( nMesIss == 1, 0, nMesIss - 1 )
							dVenISS := CtoD("15" + SUBSTR( DtoC( MonthSum( dEmissao, nMesIss ) ), 3, Len( DtoC( dEmissao ) ) ) ) + nDiaISS
						Else
							nMesIss	:= If( nMesIss == 1, 0, nMesIss - 1 )
							dVenISS := LastDay( MonthSum( dEmissao, nMesIss ) ) + nDiaISS
						EndIf

					OtherWise //V=Vencimento
						//Ok
						dVenISS		:= MonthSum( dVencto, nMesIss )
						nTamData	:= If( Len( Dtoc(dVenISS) ) == 10, 7, 5 )
						dVenISS		:= Ctod( cDiaISS + "/" + Subs( Dtoc(dVenISS), 4, nTamData ) )

				EndCase
			EndIf

			dVencRIss := DataValida(dVenISS,IIF(lVcAntIss,.F.,.T.))
			dVenISS := IIF(dVenIss > dVencRIss, dVencRISS, dVenIss)

			If Alltrim(SM0->M0_ESTENT) == "SC" .And. ;
				( ( Len( Alltrim( SM0->M0_CODMUN ) ) == 5 .And. Alltrim( SM0->M0_CODMUN ) == "09102" ) .Or. ( Len( Alltrim( SM0->M0_CODMUN ) ) == 7 .And. SubStr( Alltrim( SM0->M0_CODMUN ) , 3 , 5 ) == "09102" ) )
				aAreaFor:= getArea("SA2")
				DbSelectArea("SA2")
				DbSetOrder(1)
				If SA2->(DbSeek(xFilial("SA2")+cFornSe2+cLojaSe2)) .And. Alltrim(SA2->A2_EST) == "SC"
					dVenISS := fCRetCal(6,dEmissao)
					dVencRIss := dVenISS
				EndIf
				restArea(aAreaFor)
			EndIf

			dVencRea := DataValida(dVenISS,.T.)
			If lValISS
				RecLock("SE2",.T.)
				SE2->E2_FILIAL  := cFilial
				SE2->E2_PREFIXO := cPrefixo
				SE2->E2_NUM		:= cNum
				SE2->E2_PARCELA := cParcela
				SE2->E2_TIPO	:= MVISS
				SE2->E2_EMISSAO := dEmissao
				SE2->E2_EMIS1	:= dDataBase
				SE2->E2_VALOR	:= nIss
				SE2->E2_VENCTO  := dVenISS
				SE2->E2_SALDO	:= nIss
				SE2->E2_VENCREA := dVencRIss
				SE2->E2_VENCORI := dVenISS
				SE2->E2_FORNECE := Left(cForLojISS,Len(SE2->E2_FORNECE))
				SE2->E2_LOJA    := Right(cForLojISS,Len(SE2->E2_LOJA))
				SE2->E2_NOMFOR  := SA2->A2_NREDUZ
				SE2->E2_MOEDA	:= If(cPaisLoc=="BRA",1,nMoeda)
				SE2->E2_VLCRUZ  := Round(SE2->E2_VALOR, MsDecimais(1))
				SE2->E2_ORIGEM  := cOrigem
				SE2->E2_NATUREZ := cNatureza
				SE2->E2_LA      := cLA			// Herda do principal
				SE2->E2_FORMPAG := SA2->A2_FORMPAG
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava a filial de origem quando existir o campo no SE2            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SE2->E2_FILORIG := cFilorig //filial origem do titulo pai

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o fornecedor de origem quando existir o campo no SE2        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SE2->E2_TITPAI  := cTitPai
				SE2->E2_MULTNAT := cMultNat
				SE2->E2_CODAPRO := cCodAprov
				If lBtrISS
					SE2->E2_CODSERV := cCodServ
				EndIf
				MsUnlock()
				FKCOMMIT()
				
				FINGRVFK7("SE2", cFilial +"|"+ cPrefixo +"|"+ cNum +"|"+ cParcela +"|"+ MVISS +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)
				
				if lPLSTITPF
					PLSTITPF('SE2',cTitPai)
				endIf

				AADD(aRecImpos,{"SE2",Recno()})

				If ExistBlock("F050ISS")
					Execblock("F050ISS",.F.,.F.,nRegSE2)
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava lançamento do imposto ISS no SIGAPCO se a rotina foi chamada do contas a pagar ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If "FINA050" $ cOrigem
					PCODetLan("000002","09","FINA050")
				EndIf
				// Se rateia os impostos, grava o rateio multipla natureza/centro de custo
				If lRatImp
					// Grava SEV e SEZ dos impostos, baseado nos percentuais do rateio do titulo principal
					GrvSevSezImp(aRatSev,aRatSez,SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_VALOR)
				Else
					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava parcela do IRF na parcela do titulo  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea( "SE2" )
				DbGoTo( nRegSe2 )
				Reclock( "SE2" , .F. )
				SE2->E2_PARCISS := cParcela
				MsUnlock()
			Endif

			If lValBtrISS

				If Len(aForISSCPM) >= 2
					cCodForISS := aForISSCPM[1]
					cLojForISS := aForISSCPM[2]
					FwFreeArray(aForISSCPM)
					lContinua := .T.
				Else
					lContinua := .F.
				EndIf

				If lContinua
					cParcela := STRZERO( 1, aTamParc[1] )
					lParcLivre := .F.
					SE2->( dbSetOrder(1) ) //E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
					While !lParcLivre
						If SE2->( msSeek( cFilial + cPrefixo + cNum + cParcela + "ISS" + cCodForISS + cLojForISS ) )
							cParcela := Soma1( cParcela,, .T. )
						Else
							lParcLivre := .T.
						EndIf
					EndDo

					// Grava TX da bitributacao do ISS
					RecLock("SE2", .T.)
					SE2->E2_FILIAL  := cFilial
					SE2->E2_PREFIXO := cPrefixo
					SE2->E2_NUM		:= cNum
					SE2->E2_PARCELA := cParcela
					SE2->E2_TIPO	:= MVISS
					SE2->E2_EMISSAO := dEmissao
					SE2->E2_EMIS1	:= dDataBase
					SE2->E2_VALOR	:= nBtrISS
					SE2->E2_VENCTO  := dVenISS
					SE2->E2_SALDO	:= nBtrISS
					SE2->E2_VENCREA := dVencRIss
					SE2->E2_VENCORI := dVenISS
					SE2->E2_FORNECE := cCodForISS
					SE2->E2_LOJA    := cLojForISS
					SE2->E2_NOMFOR  := SA2->A2_NREDUZ
					SE2->E2_MOEDA	:= Iif(cPaisLoc=="BRA",1,nMoeda)
					SE2->E2_VLCRUZ  := Round(SE2->E2_VALOR, MsDecimais(1))
					SE2->E2_ORIGEM  := cOrigem
					SE2->E2_NATUREZ := cNatureza
					SE2->E2_LA      := cLA // Herda do principal
					SE2->E2_FORMPAG := SA2->A2_FORMPAG
					SE2->E2_FILORIG := cFilorig //filial origem do titulo pai
					SE2->E2_TITPAI 	:= cTitPai
					SE2->E2_MULTNAT := cMultNat
					SE2->E2_CODAPRO := cCodAprov
					If lBtrISS
						SE2->E2_CODSERV := cCodServ
					EndIf
					SE2->( MsUnlock() )
					FKCOMMIT()

					FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)

					if lPLSTITPF
						PLSTITPF('SE2',cTitPai)
					endIf

					AADD(aRecImpos,{"SE2",Recno()})

					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
				EndIf

			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo Funrural					   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nValFun := Iif(Type("nValFun")=="U",0,nValFun)

		If !lFunMR .AND. ( nValFun > 0 )
			cParcela := STRZERO(1,aTamParc[1])
			While .T.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ VerIfica se ja' ha' titulo de FunRural com esta numera‡„o ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SE2")
				DbSetOrder(1)
				If (DbSeek(cFilial + cPrefixo + cNum + cParcela + "TX " + PadR(cCodMVINS,6)))
					cParcela := Soma1( cParcela,,.t. )
					Loop
				EndIf
				Exit
			End
			dVenFun := dEmissao + 28
			If Month(dVenFun) == Month(dEmissao)
				dVenFun := dVenFun+28
			EndIf
			nTamData := Iif(Len(Dtoc(dVenFun)) == 10, 7, 5)
			dVenFun	:= Ctod(StrZero(GetMv("mv_DiaFun"),2)+"/"+Subs(Dtoc(dVenFun),4,nTamData))
			dVencRea := DataValida(dVenFun,.F.)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o Fornecedor, caso nao exista 		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SA2")
			If !(MsSeek(xFilial() + cCodMVINS + Space(Len(A2_COD) - Len(cCodMVINS)) + cLojaImpos))
				Reclock("SA2",.T.)
				SA2->A2_FILIAL := cFilial
				SA2->A2_COD 	:= cCodMVINS
				SA2->A2_LOJA	:= cLojaImpos
				SA2->A2_NOME	:= "Instituto Nacional de Previdencia Social"
				SA2->A2_NREDUZ := "INPS"
				SA2->A2_BAIRRO := "."
				SA2->A2_MUN 	:= "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	:= "."
				SA2->A2_TIPO	:= "J"
				MsUnlock()
				FKCOMMIT()
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza CSS caso nao exista		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cNatureza		:= GetMv("MV_CSS")
			IF ExistBlock("NTFUNR")
				cNatureza   := ExecBlock("NTFUNR",.f.,.f.,{cOrigem,cPrefixo})
			Endif
			cNatureza		:= cNatureza+Space(10-Len(cNatureza))
			DbSelectArea("SED")
			DbSeek(cFilial+cNatureza)
			If ( EOF() )
				RecLock("SED",.T.)
				SED->ED_FILIAL 	:= cFilial
				SED->ED_CODIGO 	:= cNatureza
				SED->ED_CALCIRF	:= "N"
				SED->ED_CALCISS	:= "N"
				SED->ED_CALCINS	:= "N"
				SED->ED_CALCCSL	:= "N"
				SED->ED_CALCCOF	:= "N"
				SED->ED_CALCPIS	:= "N"
				SED->ED_DESCRIC	:= "CONTRIBUICAO SEGURIDADE SOCIAL"
				SED->ED_TIPO	:= "2"
				MsUnlock()
				Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
				FKCOMMIT()
			EndIf

			DbSelectArea("SE2")
			RecLock("SE2",.T.)
			SE2->E2_FILIAL 	:= cFilial
			SE2->E2_PREFIXO  := cPrefixo
			SE2->E2_NUM 	  := cNum
			SE2->E2_PARCELA  := cParcela
			SE2->E2_TIPO	  := MVTAXA
			SE2->E2_EMISSAO  := dEmissao
			SE2->E2_VALOR	  := nValFun
			SE2->E2_VENCREA  := dVencrea
			SE2->E2_SALDO	  := nValFun
			SE2->E2_VENCTO   := dVencRea
			SE2->E2_VENCORI  := dVencRea
			SE2->E2_MOEDA	  := If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_EMIS1	  := dDataBase
			SE2->E2_FORNECE  := cCodMVINS
			SE2->E2_VLCRUZ   := Round( SE2->E2_VALOR, MsDecimais(1) )
			SE2->E2_LOJA	  := SA2->A2_LOJA
			SE2->E2_NOMFOR   := SA2->A2_NREDUZ
			SE2->E2_ORIGEM   := cOrigem
			SE2->E2_NATUREZ  := cNatureza
			SE2->E2_LA       := cLA			// Herda do principal
			SE2->E2_FILORIG := cFilorig //filial origem do titulo pai
			SE2->E2_TITPAI  := cTitPai
			SE2->E2_MULTNAT  := cMultNat
			SE2->E2_CODAPRO := cCodAprov
			SE2->E2_FORMPAG := SA2->A2_FORMPAG
			MsUnlock()
			FKCOMMIT()

			FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)

			if lPLSTITPF
				PLSTITPF('SE2',cTitPai)
			endIf

			AADD(aRecImpos,{"SE2",Recno()})

			If lM050CSSP
				ExecBlock("M050CSSP",.F.,.F.,nRegSe2)
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava parcela do CSS na parcela do titulo  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea( "SE2" )
			DbGoTo( nRegSe2 )
			Reclock( "SE2" , .F. )
			SE2->E2_PARCCSS := cParcela
			MsUnlock()
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo INSS Patronal				   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nValINP := Iif(Type("nValINP")=="U",0,nValINP)
		SA2->(dbGoto(nRegSA2))
		If !lInsPMR .AND. ( nValINP > 0 ) .Or. ( Type("lF050Auto") != "U" .And. lF050Auto .And. (lCalcINP .And. SED->ED_CALCINP == "1") .And. SA2->A2_CALCINP =='1')
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o Fornecedor, caso nao exista 		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nValINP == 0 .And. lPercINP
				nValINP := ( ( M->E2_BASEINS * SED->ED_PERCINP ) / 100 )
			EndIf
			DbSelectArea("SA2")
			If !(MsSeek(xFilial()+cCodINSS+Space(Len(A2_COD)-Len(cCodINSS))+cLojaImpos))
				Reclock("SA2",.T.)
				SA2->A2_FILIAL := xFilial("SA2")
				SA2->A2_COD 	:= cCodINSS
				SA2->A2_LOJA	:= cLojaImpos
				SA2->A2_NOME	:= "Instituto Nacional de Previdencia Social"
				SA2->A2_NREDUZ := "INPS"
				SA2->A2_BAIRRO := "."
				SA2->A2_MUN 	:= "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	:= "."
				SA2->A2_TIPO	:= "J"
				MsUnlock()
				FKCOMMIT()
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza INSS caso nao exista		  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cNatureza	:= &(SuperGetMv("MV_INSP",,"'INSP'"))
			cNatureza	:= cNatureza+Space(10-Len(cNatureza))
			DbSelectArea("SED")
			If !DbSeek(cFilial+cNatureza)
				RecLock("SED",.T.)
				SED->ED_FILIAL  := cFilial
				SED->ED_CODIGO  := cNatureza
				SED->ED_CALCIRF := "N"
				SED->ED_CALCISS := "N"
				SED->ED_CALCINS := "N"
				SED->ED_CALCCSL := "N"
				SED->ED_CALCCOF := "N"
				SED->ED_CALCPIS := "N"
				SED->ED_DESCRIC := "RETENCAO P/ SEGURIDADE SOCIAL"
				SED->ED_TIPO	:= "2"
				MsUnlock()
				Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
				FKCOMMIT()
			EndIf
			DbGoTo(nRegSED)

			cParcela := STRZERO(1,aTamParc[1])
			DbSelectArea("SE2")
			DbSetOrder(1)
			While .T.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ VerIfica se ja' ha' titulo de INSS com esta numera‡„o ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (DbSeek(cFilial + cPrefixo + cNum + cParcela + "INP" + PadR(cCodMVINS,6)))
					cParcela := Soma1( cParcela,,.t. )
					Loop
				EndIf
				Exit
			End

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava a parcela do INSS no titulo pai fazendo ³
			//³ a amarracao titulo x titulo INSS			  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbGoTo( nRegSe2 )
			cLa := SE2->E2_LA

			// Calcula o vencto do imposto
			dVencRea := F050VIMP("INSS",dEmissao,dEmis1,dVctoReal,cCodRetIr,cTipoFor)

			RecLock("SE2",.T.)
			SE2->E2_FILIAL  := xFilial()
			SE2->E2_PREFIXO := cPrefixo
			SE2->E2_NUM 	 := cNum
			SE2->E2_PARCELA := cParcela
			SE2->E2_TIPO	 := "INP"
			SE2->E2_EMISSAO := dEmissao
			SE2->E2_VALOR	 := nValINP
			SE2->E2_VENCREA := dVencrea
			SE2->E2_SALDO	 := nValINP
			SE2->E2_VENCTO  := dVencRea
			SE2->E2_VENCORI := dVencRea
			SE2->E2_MOEDA	 := If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_EMIS1	 := dDataBase
			SE2->E2_FORNECE := cCodMVINS
			SE2->E2_VLCRUZ  := Round( SE2->E2_VALOR, MsDecimais(1) )
			SE2->E2_LOJA	 := SA2->A2_LOJA
			SE2->E2_NOMFOR  := SA2->A2_NREDUZ
			SE2->E2_ORIGEM  := cOrigem
			SE2->E2_NATUREZ := cNatureza
			SE2->E2_LA      := cLA			// Herda do principal
			SE2->E2_FORMPAG := SA2->A2_FORMPAG

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava a filial de origem quando existir o campo no SE2            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE2->E2_FILORIG := cFilorig //filial origem do titulo pai


			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava os dados do titulo de origem do imposto se existir o campo no SE2 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE2->E2_TITPAI := cTitPai


			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o campo E2_MULTNAT = '1' para que seja possivel a        ³
			//³ visualizacao do roteio atraves da rotina FINA050 (FA050Rateio)    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lRatImp .And. lCallMT103 .And. SuperGetMV("MV_MULNATP",.F.,.F.)
				SE2->E2_MULTNAT := "1"
			EndIf

			SE2->(MsUnlock())
			FKCOMMIT()

			FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)			

			if lPLSTITPF
				PLSTITPF('SE2',cTitPai)
			endIf

			AADD(aRecImpos,{"SE2",Recno()})

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava lançamento do imposto INSS no SIGAPCO se a rotina foi chamada do contas a pagar ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			// Se rateia os impostos, grava o rateio multipla natureza/centro de custo
			If lRatImp
				// Grava SEV e SEZ dos impostos, baseado nos percentuais do rateio do titulo principal
				GrvSevSezImp(aRatSev,aRatSez,SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_VALOR)
			Else
				AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
			Endif
			DbSelectArea( "SE2" )
			DbGoTo( nRegSE2 )
		EndIf

		// Posiciono novamente no fornecedor do título principal
		DbSelectArea("SA2")
		DbGoTo( nRegSA2 )

		//Gravacao dos titulos de Pis, Cofins e Csll
		If !lPccBaixa
			FGrvImpPcc(nPis,nCofins,nCsll,nRegSe2,.T.,lRtPICFCS,"",cOrigem,nMoeda,cGeraDirf,nIrrf,,lRatImp,aRatSev,aRatSez,lPccMR,lIrfMR,lInsMR,lIssMR,lCidMR,lSestMR)
		Endif
	EndIf

	DbSelectArea("SA2")
	DbGoTo( nRegSA2 )

	If cPaisLoc == "BRA"
		cRecFet := SA2->A2_RECFET
		cRecFab := SA2->A2_RFABOV
		cRecFac := SA2->A2_RFACS
		cRecIMA := SA2->A2_RIMAMT
	EndIf
	nFethab := SE2->E2_FETHAB
	nFabov  := SE2->E2_FABOV
	nFacs   := SE2->E2_FACS

	If lFamad == Nil
		lFamad := SA2->(ColumnPos("A2_RECFMD")) > 0 .and. SE2->(ColumnPos("E2_FAMAD")) > 0
	EndIf

	If lFamad
		cRecFmd := SA2->A2_RECFMD
		nFamad  := SE2->E2_FAMAD
	Endif

	If lCposIMA
		nIma := SE2->E2_IMA
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de FETHAB                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lAgFETHA
		If !lFethabMR .AND. nFethab > 0
			If cRecFet=="2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria o Fornecedor, caso nao exista 		   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SA2")
				SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
				If ( EOF() )
					Reclock("SA2",.T.)
					SA2->A2_FILIAL := cFilial
					SA2->A2_COD 	:= cCodMVRES
					SA2->A2_LOJA	:= cLojaImpos
					SA2->A2_NOME	:= "RECEITA ESTADUAL"
					SA2->A2_NREDUZ := "RECEITA"
					SA2->A2_BAIRRO := "."
					SA2->A2_MUN 	:= "."
					SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
					SA2->A2_End 	:= "."
					SA2->A2_TIPO	:= "J"
					MsUnlock()
				EndIf

				cFornUni  := SA2->A2_COD
				cLojaUni  := SA2->A2_LOJA
				cPrefixo  := SE2->E2_PREFIXO
				cNum	  := SE2->E2_NUM
				cTipoE2   := SE2->E2_TIPO
				dEmissao  := SE2->E2_EMISSAO
				dEmis1	  := SE2->E2_EMIS1
				dVctoReal := SE2->E2_VENCREA

				DbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				aTamParcI := TamSx3("E2_PARCELA")
				cParcFet  := StrZero(1,aTamParcI[1])
				While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFet + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
					cParcFet := Soma1(cParcFet,aTamParcI[1])
				EndDo

				RecLock("SE2",.T.)
				SE2->E2_FILIAL 	:= cFilial
				SE2->E2_FILORIG := cFilAnt
				SE2->E2_PREFIXO	:= cPrefixo
				SE2->E2_NUM    	:= cNum
				SE2->E2_PARCELA	:= cParcFet
				SE2->E2_TIPO 	:= MVTAXA
				SE2->E2_EMISSAO	:= dEmissao
				SE2->E2_EMIS1  	:= dDataBase
				SE2->E2_VALOR  	:= nFethab+nFabov+nFacs+nFamad
				SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
				SE2->E2_SALDO  	:= nFethab+nFabov+nFacs+nFamad
				SE2->E2_VENCREA	:= DTVenIcms()
				SE2->E2_VENCORI	:= dEmissao
				SE2->E2_FORNECE	:= cCodMVRES
				SE2->E2_LOJA   	:= cLojaImpos
				SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
				SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
				SE2->E2_VLCRUZ 	:= Round(nFethab+nFabov+nFacs+nFamad, MsDecimais(1) )
				SE2->E2_ORIGEM 	:= Upper(cOrigem)
				cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
				IF ExistBlock("NTFETHAB")
					cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
				Endif
				SE2->E2_NATUREZ	:= Alltrim(cNatureza)
				SE2->E2_CODAPRO := cCodAprov
				SE2->E2_FORMPAG := SA2->A2_FORMPAG
				SE2->E2_TITPAI  := cTitPai
				MsUnLock()
				FKCOMMIT()

				FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)

				if lPLSTITPF
					PLSTITPF('SE2',cTitPai)
				endIf

				AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
				AADD(aRecImpos,{"SE2",Recno()})

				//Gravar a parcela do Fethab no titulo principal
				DbSelectArea("SE2")
				DbGoTo( nRegSe2 )
				Reclock( "SE2" , .F. )
				SE2->E2_PARCFET := cParcFet
				MsUnlock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria a natureza Fethab caso nao exista     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SED")
				If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
					RecLock("SED",.T.)
					SED->ED_FILIAL  := cFilial
					SED->ED_CODIGO  := cNatureza
					SED->ED_CALCIRF := "N"
					SED->ED_CALCISS := "N"
					SED->ED_CALCINS := "N"
					SED->ED_CALCCSL := "N"
					SED->ED_CALCCOF := "N"
					SED->ED_CALCPIS := "N"
					SED->ED_DESCRIC := "FETHAB"
					SED->ED_TIPO	:= "2"
					MsUnlock()
					Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo de IMA                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lImaMR .AND. nIMA > 0
			If cPaisLoc == "BRA" .And. cRecIMA == "2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria o Fornecedor, caso nao exista 		   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SA2")
				SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
				If ( EOF() )
					Reclock("SA2",.T.)
					SA2->A2_FILIAL 	:= cFilial
					SA2->A2_COD 	:= cCodMVRES
					SA2->A2_LOJA	:= cLojaImpos
					SA2->A2_NOME	:= "RECEITA ESTADUAL"
					SA2->A2_NREDUZ	:= "RECEITA"
					SA2->A2_BAIRRO 	:= "."
					SA2->A2_MUN 	:= "."
					SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
					SA2->A2_End 	:= "."
					SA2->A2_TIPO	:= "J"
					MsUnlock()
				EndIf

				cFornUni  := SA2->A2_COD
				cLojaUni  := SA2->A2_LOJA
				cPrefixo  := SE2->E2_PREFIXO
				cNum	  := SE2->E2_NUM
				cTipoE2   := SE2->E2_TIPO
				dEmissao  := SE2->E2_EMISSAO
				dEmis1	  := SE2->E2_EMIS1
				dVctoReal := SE2->E2_VENCREA

				DbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				aTamParcI := TamSx3("E2_PARCELA")
				cParcIMA  := SE2->E2_PARCELA

				While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcIMA + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
					cParcIMA := Soma1(cParcIMA,aTamParcI[1])
				EndDo

				RecLock("SE2",.T.)
				SE2->E2_FILIAL 	:= cFilial
				SE2->E2_FILORIG := cFilAnt
				SE2->E2_PREFIXO	:= cPrefixo
				SE2->E2_NUM    	:= cNum
				SE2->E2_PARCELA	:= cParcIMA
				SE2->E2_TIPO 	:= MVTAXA
				SE2->E2_EMISSAO	:= dEmissao
				SE2->E2_EMIS1  	:= dDataBase
				SE2->E2_VALOR  	:= nIMA
				SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do IMA, coincidem com o vencimento do ICMS
				SE2->E2_SALDO  	:= nIMA
				SE2->E2_VENCREA	:= DTVenIcms()
				SE2->E2_VENCORI	:= dEmissao
				SE2->E2_FORNECE	:= cCodMVRES
				SE2->E2_LOJA   	:= cLojaImpos
				SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
				SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
				SE2->E2_VLCRUZ 	:= Round(nIMA, MsDecimais(1) )
				SE2->E2_ORIGEM 	:= Upper(cOrigem)
				cNatureza      	:= SuperGetMV("MV_IMANAT",.F.,"IMA")
				SE2->E2_NATUREZ	:= Alltrim(cNatureza)
				SE2->E2_CODAPRO := cCodAprov
				SE2->E2_FORMPAG := SA2->A2_FORMPAG
				SE2->E2_TITPAI  := cTitPai

				If lCposIMA
					SE2->E2_IMA		:= Round(nIma,MsDecimais(1))
					SE2->E2_PARCIMA := cParcIMA
				Endif

				MsUnLock()
				FKCOMMIT()

				FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)

				if lPLSTITPF
					PLSTITPF('SE2',cTitPai)
				endIf

				AADD(aRecImpos,{"SE2",Recno()})

				//Gravar a parcela do IMA no titulo principal
				If lCposIMA
					DbSelectArea("SE2")
					DbGoTo( nRegSe2 )
					Reclock( "SE2" , .F. )
					SE2->E2_PARCIMA := cParcIMA
					MsUnlock()
				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria a natureza IMA caso nao exista       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SED")
				If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
					RecLock("SED",.T.)
					SED->ED_FILIAL  := cFilial
					SED->ED_CODIGO  := cNatureza
					SED->ED_CALCIRF := "N"
					SED->ED_CALCISS := "N"
					SED->ED_CALCINS := "N"
					SED->ED_CALCCSL := "N"
					SED->ED_CALCCOF := "N"
					SED->ED_CALCPIS := "N"
					SED->ED_DESCRIC := "IMA"
					SED->ED_TIPO	:= "2"
					MsUnlock()
					Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
				EndIf
			EndIf
		EndIf
	Else
		If !lFethabMR .AND. nFethab > 0
			If cRecFet=="2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria o Fornecedor, caso nao exista 		   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SA2")
				SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
				If ( EOF() )
					Reclock("SA2",.T.)
					SA2->A2_FILIAL := cFilial
					SA2->A2_COD 	:= cCodMVRES
					SA2->A2_LOJA	:= cLojaImpos
					SA2->A2_NOME	:= "RECEITA ESTADUAL"
					SA2->A2_NREDUZ := "RECEITA"
					SA2->A2_BAIRRO := "."
					SA2->A2_MUN 	:= "."
					SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
					SA2->A2_End 	:= "."
					SA2->A2_TIPO	:= "J"
					MsUnlock()
				EndIf

				cFornUni  := SA2->A2_COD
				cLojaUni  := SA2->A2_LOJA
				cPrefixo  := SE2->E2_PREFIXO
				cNum	  := SE2->E2_NUM
				cTipoE2   := SE2->E2_TIPO
				dEmissao  := SE2->E2_EMISSAO
				dEmis1	  := SE2->E2_EMIS1
				dVctoReal := SE2->E2_VENCREA

				DbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				aTamParcI := TamSx3("E2_PARCELA")
				cParcFet  := StrZero(1,aTamParcI[1])
				While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFet + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
					cParcFet := Soma1(cParcFet,aTamParcI[1])
				EndDo

				RecLock("SE2",.T.)
				SE2->E2_FILIAL 	:= cFilial
				SE2->E2_FILORIG := cFilAnt
				SE2->E2_PREFIXO	:= cPrefixo
				SE2->E2_NUM    	:= cNum
				SE2->E2_PARCELA	:= cParcFet
				SE2->E2_TIPO 	:= MVTAXA
				SE2->E2_EMISSAO	:= dEmissao
				SE2->E2_EMIS1  	:= dDataBase
				SE2->E2_VALOR  	:= nFethab
				SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
				SE2->E2_SALDO  	:= nFethab
				SE2->E2_VENCREA	:= DTVenIcms()
				SE2->E2_VENCORI	:= dEmissao
				SE2->E2_FORNECE	:= cCodMVRES
				SE2->E2_LOJA   	:= cLojaImpos
				SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
				SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
				SE2->E2_VLCRUZ 	:= Round(nFethab, MsDecimais(1) )
				SE2->E2_ORIGEM 	:= Upper(cOrigem)
				cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
				IF ExistBlock("NTFETHAB")
					cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
				Endif
				SE2->E2_NATUREZ	:= Alltrim(cNatureza)
				SE2->E2_CODAPRO := cCodAprov
				SE2->E2_FORMPAG := SA2->A2_FORMPAG
				SE2->E2_TITPAI  := cTitPai
				MsUnLock()
				FKCOMMIT()

				FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)

				if lPLSTITPF
					PLSTITPF('SE2',cTitPai)
				endIf

				AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
				AADD(aRecImpos,{"SE2",Recno()})

				//Gravar a parcela do Fethab no titulo principal
				DbSelectArea("SE2")
				DbGoTo( nRegSe2 )
				Reclock( "SE2" , .F. )
				SE2->E2_PARCFET := cParcFet
				MsUnlock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria a natureza Fethab caso nao exista     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SED")
				If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
					RecLock("SED",.T.)
					SED->ED_FILIAL  := cFilial
					SED->ED_CODIGO  := cNatureza
					SED->ED_CALCIRF := "N"
					SED->ED_CALCISS := "N"
					SED->ED_CALCINS := "N"
					SED->ED_CALCCSL := "N"
					SED->ED_CALCCOF := "N"
					SED->ED_CALCPIS := "N"
					SED->ED_DESCRIC := "FETHAB"
					SED->ED_TIPO	:= "2"
					MsUnlock()
					Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo de FABOV                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lFabovMR .AND. (nFabov > 0)
			If cRecFab =="2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria o Fornecedor, caso nao exista 		   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SA2")
				SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
				If ( EOF() )
					Reclock("SA2",.T.)
					SA2->A2_FILIAL := cFilial
					SA2->A2_COD 	:= cCodMVRES
					SA2->A2_LOJA	:= cLojaImpos
					SA2->A2_NOME	:= "RECEITA ESTADUAL"
					SA2->A2_NREDUZ := "RECEITA"
					SA2->A2_BAIRRO := "."
					SA2->A2_MUN 	:= "."
					SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
					SA2->A2_End 	:= "."
					SA2->A2_TIPO	:= "J"
					MsUnlock()
				EndIf

				cFornUni  := SA2->A2_COD
				cLojaUni  := SA2->A2_LOJA
				cPrefixo  := SE2->E2_PREFIXO
				cNum	  := SE2->E2_NUM
				cTipoE2   := SE2->E2_TIPO
				dEmissao  := SE2->E2_EMISSAO
				dEmis1	  := SE2->E2_EMIS1
				dVctoReal := SE2->E2_VENCREA

				DbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				aTamParcI := TamSx3("E2_PARCELA")
				cParcFab  := StrZero(1,aTamParcI[1])
				While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFab + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
					cParcFab := Soma1(cParcFab,aTamParcI[1])
				EndDo

				RecLock("SE2",.T.)
				SE2->E2_FILIAL 	:= cFilial
				SE2->E2_FILORIG := cFilAnt
				SE2->E2_PREFIXO	:= cPrefixo
				SE2->E2_NUM    	:= cNum
				SE2->E2_PARCELA	:= cParcFab
				SE2->E2_TIPO 	:= MVTAXA
				SE2->E2_EMISSAO	:= dEmissao
				SE2->E2_EMIS1  	:= dDataBase
				SE2->E2_VALOR  	:= nFabov
				SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
				SE2->E2_SALDO  	:= nFabov
				SE2->E2_VENCREA	:= DTVenIcms()
				SE2->E2_VENCORI	:= dEmissao
				SE2->E2_FORNECE	:= cCodMVRES
				SE2->E2_LOJA   	:= cLojaImpos
				SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
				SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
				SE2->E2_VLCRUZ 	:= Round(nFabov, MsDecimais(1) )
				SE2->E2_ORIGEM 	:= Upper(cOrigem)
				cNatureza      	:= SuperGetMV("MV_FABNAT",.F.,"FABOV")
				SE2->E2_NATUREZ	:= Alltrim(cNatureza)
				SE2->E2_CODAPRO := cCodAprov
				SE2->E2_FORMPAG := SA2->A2_FORMPAG
				SE2->E2_TITPAI  := cTitPai
				MsUnLock()
				FKCOMMIT()

				FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)

				if lPLSTITPF
					PLSTITPF('SE2',cTitPai)
				endIf

				AADD(aRecImpos,{"SE2",Recno()})

				//Gravar a parcela do FABOV no titulo principal
				DbSelectArea("SE2")
				DbGoTo( nRegSe2 )
				Reclock( "SE2" , .F. )
				SE2->E2_PARCFAB := cParcFab
				MsUnlock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria a natureza FABOV caso nao exista      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SED")
				If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
					RecLock("SED",.T.)
					SED->ED_FILIAL  := cFilial
					SED->ED_CODIGO  := cNatureza
					SED->ED_CALCIRF := "N"
					SED->ED_CALCISS := "N"
					SED->ED_CALCINS := "N"
					SED->ED_CALCCSL := "N"
					SED->ED_CALCCOF := "N"
					SED->ED_CALCPIS := "N"
					SED->ED_DESCRIC := "FABOV"
					SED->ED_TIPO	:= "2"
					MsUnlock()
					Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo de FACS                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lFacsMR .AND. nFacs > 0
			If cRecFac=="2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria o Fornecedor, caso nao exista 		   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SA2")
				SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
				If ( EOF() )
					Reclock("SA2",.T.)
					SA2->A2_FILIAL := cFilial
					SA2->A2_COD 	:= cCodMVRES
					SA2->A2_LOJA	:= cLojaImpos
					SA2->A2_NOME	:= "RECEITA ESTADUAL"
					SA2->A2_NREDUZ := "RECEITA"
					SA2->A2_BAIRRO := "."
					SA2->A2_MUN 	:= "."
					SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
					SA2->A2_End 	:= "."
					SA2->A2_TIPO	:= "J"
					MsUnlock()
				EndIf

				cFornUni  := SA2->A2_COD
				cLojaUni  := SA2->A2_LOJA
				cPrefixo  := SE2->E2_PREFIXO
				cNum	  := SE2->E2_NUM
				cTipoE2   := SE2->E2_TIPO
				dEmissao  := SE2->E2_EMISSAO
				dEmis1	  := SE2->E2_EMIS1
				dVctoReal := SE2->E2_VENCREA

				DbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				aTamParcI := TamSx3("E2_PARCELA")
				cParcFac  := StrZero(1,aTamParcI[1])

				While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFac + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
					cParcFac := Soma1(cParcFac,aTamParcI[1])
				EndDo

				RecLock("SE2",.T.)
				SE2->E2_FILIAL 	:= cFilial
				SE2->E2_FILORIG := cFilAnt
				SE2->E2_PREFIXO	:= cPrefixo
				SE2->E2_NUM    	:= cNum
				SE2->E2_PARCELA	:= cParcFac
				SE2->E2_TIPO 	:= MVTAXA
				SE2->E2_EMISSAO	:= dEmissao
				SE2->E2_EMIS1  	:= dDataBase
				SE2->E2_VALOR  	:= nFacs
				SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
				SE2->E2_SALDO  	:= nFacs
				SE2->E2_VENCREA	:= DTVenIcms()
				SE2->E2_VENCORI	:= dEmissao
				SE2->E2_FORNECE	:= cCodMVRES
				SE2->E2_LOJA   	:= cLojaImpos
				SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
				SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
				SE2->E2_VLCRUZ 	:= Round(nFacs, MsDecimais(1) )
				SE2->E2_ORIGEM 	:= Upper(cOrigem)
				cNatureza      	:= SuperGetMV("MV_FACNAT",.F.,"FACS")
				SE2->E2_NATUREZ	:= Alltrim(cNatureza)
				SE2->E2_CODAPRO := cCodAprov
				SE2->E2_FORMPAG := SA2->A2_FORMPAG
				SE2->E2_TITPAI  := cTitPai
				MsUnLock()
				FKCOMMIT()

				FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)

				if lPLSTITPF
					PLSTITPF('SE2',cTitPai)
				endIf

				AADD(aRecImpos,{"SE2",Recno()})

				//Gravar a parcela do FACS no titulo principal
				DbSelectArea("SE2")
				DbGoTo( nRegSe2 )
				Reclock( "SE2" , .F. )
				SE2->E2_PARCFAC := cParcFac
				MsUnlock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria a natureza FACS caso nao exista       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SED")
				If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
					RecLock("SED",.T.)
					SED->ED_FILIAL  := cFilial
					SED->ED_CODIGO  := cNatureza
					SED->ED_CALCIRF := "N"
					SED->ED_CALCISS := "N"
					SED->ED_CALCINS := "N"
					SED->ED_CALCCSL := "N"
					SED->ED_CALCCOF := "N"
					SED->ED_CALCPIS := "N"
					SED->ED_DESCRIC := "FACS"
					SED->ED_TIPO	:= "2"
					MsUnlock()
					Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo de IMA                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nIMA > 0
			If cPaisLoc == "BRA" .And. cRecIMA == "2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria o Fornecedor, caso nao exista 		   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SA2")
				SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
				If ( EOF() )
					Reclock("SA2",.T.)
					SA2->A2_FILIAL 	:= cFilial
					SA2->A2_COD 	:= cCodMVRES
					SA2->A2_LOJA	:= cLojaImpos
					SA2->A2_NOME	:= "RECEITA ESTADUAL"
					SA2->A2_NREDUZ	:= "RECEITA"
					SA2->A2_BAIRRO 	:= "."
					SA2->A2_MUN 	:= "."
					SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
					SA2->A2_End 	:= "."
					SA2->A2_TIPO	:= "J"
					MsUnlock()
				EndIf

				cFornUni  := SA2->A2_COD
				cLojaUni  := SA2->A2_LOJA
				cPrefixo  := SE2->E2_PREFIXO
				cNum	  := SE2->E2_NUM
				cTipoE2   := SE2->E2_TIPO
				dEmissao  := SE2->E2_EMISSAO
				dEmis1	  := SE2->E2_EMIS1
				dVctoReal := SE2->E2_VENCREA

				DbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				aTamParcI := TamSx3("E2_PARCELA")
				cParcIMA  := SE2->E2_PARCELA

				While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcIMA + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
					cParcIMA := Soma1(cParcIMA,aTamParcI[1])
				EndDo

				RecLock("SE2",.T.)
				SE2->E2_FILIAL 	:= cFilial
				SE2->E2_FILORIG := cFilAnt
				SE2->E2_PREFIXO	:= cPrefixo
				SE2->E2_NUM    	:= cNum
				SE2->E2_PARCELA	:= cParcIMA
				SE2->E2_TIPO 	:= MVTAXA
				SE2->E2_EMISSAO	:= dEmissao
				SE2->E2_EMIS1  	:= dDataBase
				SE2->E2_VALOR  	:= nIMA
				SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do IMA, coincidem com o vencimento do ICMS
				SE2->E2_SALDO  	:= nIMA
				SE2->E2_VENCREA	:= DTVenIcms()
				SE2->E2_VENCORI	:= dEmissao
				SE2->E2_FORNECE	:= cCodMVRES
				SE2->E2_LOJA   	:= cLojaImpos
				SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
				SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
				SE2->E2_VLCRUZ 	:= Round(nIMA, MsDecimais(1) )
				SE2->E2_ORIGEM 	:= Upper(cOrigem)
				cNatureza      	:= SuperGetMV("MV_IMANAT",.F.,"IMA")
				SE2->E2_NATUREZ	:= Alltrim(cNatureza)
				SE2->E2_CODAPRO := cCodAprov
				SE2->E2_FORMPAG := SA2->A2_FORMPAG
				SE2->E2_TITPAI := cTitPai

				If lCposIMA
					SE2->E2_IMA		:= Round(nIma,MsDecimais(1))
					SE2->E2_PARCIMA := cParcIMA
				Endif

				MsUnLock()
				FKCOMMIT()

				FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)

				if lPLSTITPF
					PLSTITPF('SE2',cTitPai)
				endIf

				AADD(aRecImpos,{"SE2",Recno()})

				//Gravar a parcela do IMA no titulo principal
				If lCposIMA
					DbSelectArea("SE2")
					DbGoTo( nRegSe2 )
					Reclock( "SE2" , .F. )
					SE2->E2_PARCIMA := cParcIMA
					MsUnlock()
				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria a natureza IMA caso nao exista       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SED")
				If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
					RecLock("SED",.T.)
					SED->ED_FILIAL  := cFilial
					SED->ED_CODIGO  := cNatureza
					SED->ED_CALCIRF := "N"
					SED->ED_CALCISS := "N"
					SED->ED_CALCINS := "N"
					SED->ED_CALCCSL := "N"
					SED->ED_CALCCOF := "N"
					SED->ED_CALCPIS := "N"
					SED->ED_DESCRIC := "IMA"
					SED->ED_TIPO	:= "2"
					MsUnlock()
					Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera titulo de FAMAD                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lFamadMR .AND. nFamad > 0
			If cRecFmd=="2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria o Fornecedor, caso nao exista 		   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SA2")
				SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
				If ( EOF() )
					Reclock("SA2",.T.)
					SA2->A2_FILIAL := cFilial
					SA2->A2_COD 	:= cCodMVRES
					SA2->A2_LOJA	:= cLojaImpos
					SA2->A2_NOME	:= "RECEITA ESTADUAL"
					SA2->A2_NREDUZ := "RECEITA"
					SA2->A2_BAIRRO := "."
					SA2->A2_MUN 	:= "."
					SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
					SA2->A2_End 	:= "."
					SA2->A2_TIPO	:= "J"
					MsUnlock()
				EndIf

				cFornUni  := SA2->A2_COD
				cLojaUni  := SA2->A2_LOJA
				cPrefixo  := SE2->E2_PREFIXO
				cNum	  := SE2->E2_NUM
				cTipoE2   := SE2->E2_TIPO
				dEmissao  := SE2->E2_EMISSAO
				dEmis1	  := SE2->E2_EMIS1
				dVctoReal := SE2->E2_VENCREA

				DbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				aTamParcI := TamSx3("E2_PARCELA")
				cParcFmd  := StrZero(1,aTamParcI[1])

				While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFmd + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
					cParcFmd := Soma1(cParcFmd,aTamParcI[1])
				EndDo

				RecLock("SE2",.T.)
				SE2->E2_FILIAL 	:= cFilial
				SE2->E2_FILORIG := cFilAnt
				SE2->E2_PREFIXO	:= cPrefixo
				SE2->E2_NUM    	:= cNum
				SE2->E2_PARCELA	:= cParcFmd
				SE2->E2_TIPO 	:= MVTAXA
				SE2->E2_EMISSAO	:= dEmissao
				SE2->E2_EMIS1  	:= dDataBase
				SE2->E2_VALOR  	:= nFamad
				SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
				SE2->E2_SALDO  	:= nFamad
				SE2->E2_VENCREA	:= DTVenIcms()
				SE2->E2_VENCORI	:= dEmissao
				SE2->E2_FORNECE	:= cCodMVRES
				SE2->E2_LOJA   	:= cLojaImpos
				SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
				SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
				SE2->E2_VLCRUZ 	:= Round(nFamad, MsDecimais(1) )
				SE2->E2_ORIGEM 	:= Upper(cOrigem)
				cNatureza      	:= SuperGetMV("MV_FAMNAT",.F.,"FAMAD")
				SE2->E2_NATUREZ	:= Alltrim(cNatureza)
				SE2->E2_CODAPRO := cCodAprov
				SE2->E2_FORMPAG := SA2->A2_FORMPAG
				SE2->E2_TITPAI := cTitPai
				MsUnLock()

				FKCOMMIT()

				FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA,,cTitPai)

				if lPLSTITPF
					PLSTITPF('SE2',cTitPai)
				endIf

				AADD(aRecImpos,{"SE2",Recno()})

				//Gravar a parcela do FACS no titulo principal
				DbSelectArea("SE2")
				DbGoTo( nRegSe2 )
				Reclock( "SE2" , .F. )
				SE2->E2_PARCFAM := cParcFmd
				MsUnlock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria a natureza FACS caso nao exista       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SED")
				If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
					RecLock("SED",.T.)
					SED->ED_FILIAL  := cFilial
					SED->ED_CODIGO  := cNatureza
					SED->ED_CALCIRF := "N"
					SED->ED_CALCISS := "N"
					SED->ED_CALCINS := "N"
					SED->ED_CALCCSL := "N"
					SED->ED_CALCCOF := "N"
					SED->ED_CALCPIS := "N"
					SED->ED_DESCRIC := "FAMAD"
					SED->ED_TIPO	:= "2"
					MsUnlock()
					Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
				EndIf
			EndIf
		EndIf
	EndIf

	//Ponto se entrada para gravacoes genericas a todos os titulos de impostos
	If lF050GER
		ExecBlock("F050GER",.F.,.F.,aRecImpos)
	Endif

	If !lPccMR .And. !lPccBaixa

		SE2->( MsGoto( nRegSE2 ) )
		Reclock( "SE2" , .F. )

		If lRtPICFCS
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava os campos de valor retido              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE2->E2_VRETPIS := SE2->E2_PIS
			SE2->E2_VRETCOF := SE2->E2_COFINS
			SE2->E2_VRETCSL := SE2->E2_CSLL

			SE2->E2_PRETPIS := " "
			SE2->E2_PRETCOF := " "
			SE2->E2_PRETCSL := " "
		EndIf

		MsUnlock()

	EndIf

	//Gravação da FK3/FK4 para os impostos da emissão
	If __lMotRet .AND. !Empty(aImpostos)
		FxGrvImpE("SE2", nRegSE2, aImpostos, aRecImpos,.F., lDedSimpl )
	Endif

	DbSelectArea("SA2")
	DbGoTo( nRegSA2 )
	DbSelectArea("SED")
	DbGoTo( nRegSED )
	DbSelectArea("SE2")
	DbSetOrder(nOrdSe2)
	DbGoTo(nRegSE2)
	RecLock("SE2")
	SE2->E2_ORIGEM := cOrigem

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} A040DUPREC

Gravações complementares da inclusão de C.Receber.
Arquivo original: MATXATU.PRX

@Author	Ary Medeiros
/*/
//-----------------------------------------------------------------------------------------------------
Function A040DupRec( cOrigem AS Character, lUpDate AS Logical, nValTot AS Numeric, lAbate AS Logical,;
					 lGerAbtISS AS Logical, lAtuSalDup AS Logical, nTotISS AS Numeric, cRecIss AS Character,;
					 lFina040 AS Logical, aMedicao AS Array, nProp AS Numeric, lTitFim AS Logical,;
					 lLojaDin AS Logical, cRetCli AS Character, cTitpai AS Character, nValFetR AS Numeric,;
					 cCodIrrf AS Character, aMotRet AS Array, lPccMR AS Logical, lIrfMR AS Logical, lInsMR AS Logical,;
					 lIssMR AS Logical, lFunMR AS Logical, lFetMR AS Logical, lFabMR AS Logical, lFacMR AS Logical,;
					 lTpdMR AS Logical, lFamadMR AS LOGICAL ) AS Logical 

	Local nSavRec		AS Numeric
	Local nRecSE1		AS Numeric
	Local nValForte		AS Numeric
	Local nIss			AS Numeric
	Local nIrrf			AS Numeric
	Local cParcela		AS Character
	Local cCliente		AS Character
	Local cLoja			AS Character
	Local dEmissao		AS Date
	Local dVencto		AS Date
	Local dVencRea		AS Date
	Local cPrefixo		AS Character
	Local cNum			AS Character
	Local cTipoE1		AS Character
	Local dVenISS		AS Date
	Local dVenFun		AS Date
	Local nMoeda		AS Numeric
	Local nSalvCli		AS Numeric
	Local cNatur		AS Character
	Local dNextDay		AS Date
	Local cNatureza		AS Character
	Local nInss			AS Numeric
	Local nTamData		AS Numeric
	Local nPis			AS Numeric
	Local nCofins		AS Numeric
	Local nCsll			AS Numeric
	Local nDiaUtil		AS Numeric
	Local nDia			AS Numeric
	Local nVRetISS		AS Numeric
	Local cLA			AS Character
	Local cFatura		AS Character
	Local cMunIss		AS Character
	Local lAbateuPIS	AS Logical
	Local lAbateuCOF	AS Logical
	Local lAbateuCSLL	AS Logical
	Local lAbateuIRF	AS Logical
	Local lAtuAcum		AS Logical	// Verifica se deve alterar os campos A1_VACUM e A1_NROCOM qdo modulo for o loja
	Local xMinRetIR		AS Numeric
	Local cParcIRF		AS Character
	Local cParcFet		AS Character
	Local cParcFab		AS Character
	Local cParcFac		AS Character
	Local cParTPDP		AS Character
	Local cParcFam	    AS Character

	Local lLojaCartao	AS Logical	// Indica se eh rotina chamada pelo modulo sigaloja e se forma de pagamento eh cartao.
	Local nModOrig		AS Numeric	// modulo origem quando recebimento de titulo do loja via web service
	Local lLojxRec		AS Logical // Verifica se esta na rotina de recebimento de titulos
	Local dVencRIss		AS Date
	Local nFamad		AS Numeric
	Local nFumipeq		AS Numeric
	Local nFetHab		AS Numeric
	Local nFabov		AS Numeric
	Local nFacs			AS Numeric
	Local nTPDP			AS Numeric
	Local nIMA			AS Numeric
	Local lIrfRetAnt	AS Logical
	Local nCalcIr		AS Numeric
	Local aArea			AS Array
	Local lOriFatura	AS Logical
	Local cNatImp		AS Character
	Local aRecImpos		AS Array
	Local cNome			AS Character
	Local nTaxaTit		AS Numeric
	Local aAreaSAE		AS Array
	Local lFINA460		AS Logical
	Local cChaveSE1		AS Character
	Local cCodAprov		AS Character
	//.T. - Gera o titulo de ISS (se houver) na filial de destino juntamente com o titulo NF, baixando o titulo ISS na origem
	//.F. - NÃ£ gera o titulo de ISS na filial de destino, permanecendo o titulo ISS na origem em aberto.
	Local lFINA630		AS Logical
	Local lTrfISSf		AS Logical
	Local nBase061		AS Numeric    //Base utilizada para calcular os impostos no FINA061.
	Local lGeraTitMin	AS Logical //Gera imposto de titulo com valor minimo para retencao.
	Local lIRBx			AS Logical
	Local lIsVendaVP	AS Logical	// Indica se eh venda de Vale Presente (SIGALOJA / FRONTLOJA)
	Local lIsVdRecCP	AS Logical	// Indica se eh venda de Recarga de Cartao Presente (Gift Card) - SIGALOJA
	Local cForniss		AS Character
	Local nI			AS Numeric
	Local cMun			AS Character
	Local cUf			AS Character
	Local cConsulta		AS Character
	Local cAliasQry		AS Character
	Local lMat460		AS Logical
	Local lGrvSa1		AS Logical
	Local cFilSE1		AS Character
	Local aAreaSA2		AS Array
	Local aAreaSED		AS Array
	Local cTipoFor		AS Character //Topo do fornecedor para INSS
	Local cCNPJRET		AS Character //CNPJ fornecedor para INSS
	Local cRETINS		AS Character
	Local lECCiaPed		AS Logical //Pedido CiaShop
	Local lRecFun		AS Logical
	Local lCdRetInd		AS Logical
	Local dRef			As Date
	Local nBtrISS		AS Numeric
	Local lValBtrISS	AS Logical
	Local lAplTxMoeda	AS Logical	//Define se aplica taxa da moeda no cálculo de IR. ==> .F. para quando a base de IR já vem com a taxa da moeda aplicada
	Local dVencReaAux	AS Date
	Local lRetPIX		AS Logical
	Local lBorde		AS Logical
	Local lDescISS      AS Logical
	Local lM460Iren		AS Logical
	Local cOrigImp		AS Character
	Local cLojaIrf		AS Character
	Local cLojaImpos	AS Character
	Local cUniao		AS Character
	Local cCodMVRES  	AS Character
	Local cCodMVINS		AS Character
	Local cMVMUNIC		AS Character
	Local lCposIMA		AS Logical
	Local nTamFor		AS Numeric
	Local nDiaUtIss		AS Numeric
	Local nTamParc		AS Numeric
	LOCAL nVRetPIS      AS NUMERIC
	LOCAL nVRetCOF      AS NUMERIC
	LOCAL nVRetCSLL     AS NUMERIC
	Local cCodRetIR		As Character
	Local cChaveTit		As Character

	Default lGerAbtISS	:= .T.
	Default lAbate		:= .T.
	Default lAtuSalDup	:= .T.
	Default nTotISS		:= SE1->E1_ISS
	Default cRecISS		:= ""
	Default lFina040	:= .F.
	Default aMedicao	:= {}
	Default nProp		:= 0
	Default lTitFim		:= .F.
	Default lLojaDin	:= .F. //Pagamento da loja em dinheiro
	Default cRetCli		:= ""
	Default cTitPai		:= ""
	Default nValFetR	:= 0  //Campo criado para tratar retenÃ§Ã£o do FETHAB. Campo utilizado quando operaÃ§Ãµespossui nota fiscal
	Default cCodIrrf	:= "" // Codigo de retenÃ§Ã£o do TX de Irrf.
	Default aMotRet 	:= {}
	Default lPccMR 		:= .F.
	Default lIrfMR 		:= .F.
	Default lInsMR 		:= .F.
	Default lIssMR 		:= .F.
	Default lFunMR 		:= .F.
	Default lFetMR 		:= .F.
	Default lFabMR 		:= .F.
	Default lFacMR 		:= .F.
	Default lTpdMR 		:= .F.
	Default lFamadMR    := .F.

	nSavRec			:= 0
	nRecSE1			:= 0
	nValForte		:= 0
	nIss			:= 0
	nIrrf			:= 0
	cParcela		:= ""
	cCliente		:= ""
	cLoja			:= ""
	dEmissao		:= CTOD('//')
	dVencto			:= CTOD('//')
	dVencRea		:= CTOD('//')
	cPrefixo		:= ""
	cNum			:= ""
	cTipoE1			:= ""
	dVenISS			:= CTOD('//')
	dVenFun			:= CTOD('//')
	nMoeda			:= SE1->E1_MOEDA
	nSalvCli		:= 0
	cNatur			:= ""
	dNextDay		:= CTOD('//')
	cNatureza		:= ""
	nInss			:= 0
	nTamData		:= 0
	nPis			:= 0
	nCofins			:= 0
	nCsll			:= 0
	nDiaUtil		:= 0
	nDia			:= 0
	nVRetISS		:= 0
	cLA				:= SE1->E1_LA
	cFatura			:= SE1->E1_FATURA
	cMunIss			:= ''
	lAbateuPIS		:= .F.
	lAbateuCOF		:= .F.
	lAbateuCSLL		:= .F.
	lAbateuIRF		:= .F.
	lAtuAcum		:= .T.	// Verifica se deve alterar os campos A1_VACUM e A1_NROCOM qdo modulo for o loja
	xMinRetIR		:= 0
	cParcIRF		:= ""
	cParcFet		:= ""
	cParcFab		:= ""
	cParcFac		:= ""
	cParTPDP		:= ""
	cParcFam	    := ""
	lLojaCartao		:= .F.	// Indica se eh rotina chamada pelo modulo sigaloja e se forma de pagamento eh cartao.
	nModOrig		:= LjGetModOr()	// modulo origem quando recebimento de titulo do loja via web service
	lLojxRec		:= LjGetLjRec() // Verifica se esta na rotina de recebimento de titulos
	dVencRIss		:= CTOD("//")
	nFamad			:= 0
	nFumipeq		:= 0
	nFetHab			:= 0
	nFabov			:= 0
	nFacs			:= 0
	nTPDP			:= 0
	nIMA			:= 0
	lIrfRetAnt		:= .F.
	nCalcIr			:= 0
	aArea			:= {}
	lOriFatura		:= Iif("FINA280" $ SE1->E1_ORIGEM,.T.,.F.)
	cNatImp			:= ""
	aRecImpos		:= {}
	cNome			:= ""
	nTaxaTit		:= 0
	aAreaSAE		:= SAE->(GetArea())
	lFINA460		:= FunName() == "FINA460"
	cChaveSE1		:= ""
	cCodAprov		:= ""
	lFINA630		:= FwIsInCallStack("FINA630")
	lTrfISSf		:= .F.
	nBase061		:= 0    //Base utilizada para calcular os impostos no FINA061.
	lGeraTitMin		:= .F. //Gera imposto de titulo com valor minimo para retencao.
	lIRBx			:= .F.
	lIsVendaVP		:= If(Lj7VPNew(), Lj7VPYesNo() == "S",.F.)	// Indica se eh venda de Vale Presente (SIGALOJA / FRONTLOJA)
	lIsVdRecCP		:= If(FindFunction("Lj7CP_OK") .And. Lj7CP_OK(),Lj7CPGetSt()=="S",.F.)	// Indica se eh venda de Recarga de Cartao Presente (Gift Card) - SIGALOJA
	cForniss		:= ""
	nI				:= 0
	cMun			:= ""
	cUf				:= ""
	cConsulta		:= ""
	cAliasQry		:= ""
	lMat460			:= Alltrim(FUNNAME()) $ "MATA460A_MATA461_MATA460"
	lGrvSa1			:= .T.
	cFilSE1			:= FWXFILIAL("SE1")
	aAreaSA2		:= {}
	aAreaSED		:= SED->(getArea())
	cTipoFor		:= "" //Topo do fornecedor para INSS
	cCNPJRET		:= "" //CNPJ fornecedor para INSS
	cRETINS			:= ""
	lECCiaPed		:= .F. //Pedido CiaShop
	lRecFun			:=	.T.
	lCdRetInd		:= .F.
	dRef			:= dDatabase
	nBtrISS			:= 0
	lValBtrISS		:= .F.
	lAplTxMoeda		:= .T.				//Define se aplica taxa da moeda no cálculo de IR. ==> .F. para quando a base de IR já vem com a taxa da moeda aplicada
	dVencReaAux		:= CTOD('//')
	lRetPIX			:= Alltrim(FunName()) $ "FINA890"
	lBorde			:= (Alltrim(FunName()) $ "FINA061_FINA590" .or. FwIsInCallStack("FA061Borde")) .or. lRetPIX
	lDescISS      	:= GetNewPar("MV_DESCISS",.F.)
	lM460Iren		:= .F.
	cOrigImp		:= Iif (FwIsInCallStack("FINA891"),"FINA890","FINA061")
	cLojaIrf		:= ""
	cLojaImpos		:= ""
	cCodRetIR		:= ""
	cUniao			:= If(!EMPTY(GetMV("MV_UNIAO")),GetMV("MV_UNIAO"),'UNIAO')
	cCodMVRES  		:= If(!EMPTY(GetMV("MV_RECEST")),GetMV("MV_RECEST"),'RECEITA')
	cCodMVINS		:= If(!EMPTY(GetMV("MV_FORINSS")),GetMV("MV_FORINSS"),'INSS')
	cMVMUNIC		:= AllTrim(SuperGetMv("MV_MUNIC"))
	lCposIMA		:= .F.
	nTamFor			:= 0
	nDiaUtIss		:= 0
	nTamParc		:= 0
	nVRetPIS        := 0
	nVRetCOF        := 0
	nVRetCSLL       := 0

	FININCNAT() //cria as naturezas que possuem retenção na baixa
	RestArea(aAreaSED)

	If __lLocBRA == NIL
		__lLocBRA	:= cPaisLoc == "BRA"
	Endif

	If __lTrfIssF == NIL
		__lTrfIssF 	:= GetNewPar("MV_TRFISSF",.T.)
	Endif

	lTrfISSf := lFINA630 .And. __lTrfIssF

	If __nTamFor == NIL
		__nTamFor	:= TamSx3("E2_FORNECE")[1]
	Endif

	If __nTamLoja == NIL
		__nTamLoja	:= TamSx3("E2_LOJA")[1]
	Endif

	If __nTamParc == NIL
		__nTamParc	:= TamSx3("E2_PARCELA")[1]
	Endif

	If __nTamNat == NIL
		__nTamNat	:= TamSx3("E2_NATUREZ")[1]
	Endif

	If __lF040GER == NIL
		__lF040GER	:= ExistBlock("F040GER")
	Endif

	If __lM040Se1 == NIL
		__lM040Se1	:= Existblock("M040SE1")
	Endif

	If __nMinRetIR == NIL
		__nMinRetIR	:= SuperGetMV("MV_VLRETIR")
	Endif

	If __lF040MIRF == NIL
		__lF040MIRF	:= ExistBlock("F040MIRF")
	Endif

	If __nMinISS == NIL
		__nMinISS	:= SuperGetMv("MV_VRETISS",.T.,0)
	Endif

	If __lPccBxCr == NIL
		__lPccBxCr	:= FPccBxCr(.T.)
	Endif

	If __lIrPjBxCr == NIL
		__lIrPjBxCr	:= FIrPjBxCr(.T.)
	Endif

	If __nVlMinImp == NIL
		__nVlMinImp	:= GetNewPar("MV_VL10925",5000)
	Endif

	If __lFINCTAL == NIL
		__lFINCTAL	:= (SuperGetMV( "MV_FINCTAL", .T., "1" ) == "2")
	Endif

	cCodAprov	:= If(__lFINCTAL, FA050Aprov(If(__lLocBRA,1,nMoeda))," ")

	// A leitura deve ser efetuada a cada acesso, pois estas variáveis
	// estão sendo alteradas em razão do título atual
	__nVRetCOF	:= SuperGetMV("MV_VRETCOF")
	__nVRetPIS 	:= SuperGetMV("MV_VRETPIS")
	__nVRetCSLL	:= SuperGetMV("MV_VRETCSL")
	__nDiaUtIss	:= SuperGetMv("MV_DIAUISS",.T., 0)
	__nDiaIss	:= SuperGetMv("MV_DIAISS", .F., 10, )
	__cVencIss 	:= GetNewPar("MV_VENCISS", "E")
	// ---------------------------------------------------------------

	cLojaImpos	:= PadR( "00", __nTamLoja, "0" )
	cLojaIrf	:= Padr( "00", __nTamLoja, "0" )
	cUniao		:= PadR(cUniao,__nTamFor)
	cCodMVRES	:= PadR(cCodMVRES,__nTamFor)
	cCodMVINS	:= PadR(GetMv("MV_FORINSS"),__nTamFor)

	If __lAgFETHA == NIL
		__lAgFETHA	:= SuperGetMv("MV_AGFETHA",,.F.)
	Endif

	If __lMoedTit == NIL
		__lMoedTit	:= SuperGetMv("MV_MOEDTIT",.F.,"N") == "S"
	Endif

	If __nMCusto == NIL
		__nMCusto := Val(SuperGetMV("MV_MCUSTO"))
	Endif

	If __lFina986 == NIL
		__lFina986 	:= __lLocBRA  .and. FindFunction("Fa986grava") .and. AliasInDic("FKG")
	Endif

	If lPLSTITPF == NIL
		lPLSTITPF	:= ('PLS' $ SE1->E1_ORIGEM) .and. FindFunction("PLSTITPF")
	EndIf

	If __lRskActv == NIL // VERIFICA SE O MAIS NEGÓCIOS ESTÁ ATIVO NO AMBIENTE
		__lRskActv := .F.
		If FindFunction("RskIsActive")
			__lRskActv := RskIsActive()
		EndIf
	EndIf

	If __lRskActv // VERIFICA O CONTEÚDO DO PARÂMETRO COM O CÓDIGO DE CLIENTE NA SA1 PARA A SUPPLIER
		If __cRskCPay == NIL
			__cRskCPay := SuperGetMV("MV_RSKCPAY",, "SUPPLI|01")
		EndIf
	Else
		__cRskCPay := ""
	EndIf

	If !lPccMR

		If __nVencto == NIL
			__nVencto	:= SuperGetMv("MV_VCPCCR",.T.,1)
		Endif

		If (lBorde .and. dDataBase >= dLastPcc) .or. (SE1->E1_EMISSAO >= dLastPcc)
			__nVlMinImp	:= 0
			nVRetPIS	:= __nVRetPIS
			nVRetCOF	:= __nVRetCOF
			nVRetCSLL	:= __nVRetCSLL
			__nVRetPIS	:= 0
			__nVRetCOF	:= 0
			__nVRetCSLL	:= 0
		EndIf

		If __nVencto == 2
			dRef := SE1->E1_VENCREA
		ElseIf __nVencto == 1 .OR. EMPTY(__nVencto)
			dRef := SE1->E1_EMISSAO
		ElseIf __nVencto == 3
			dRef := SE1->E1_EMIS1
		EndIf
	EndIf

	If __lFina986 .and. !( SE1->E1_TIPO $ MV_CRNEG)
		//realiza a gravacao do model
		Fa986grava("SE1",cOrigem)
	EndIf

	If __lLocBRA .And. Alltrim(FunName()) $ "MATA460A_MATA461_MATA460"
		cLojaImpos	:=	FinVldSA2(SC5->C5_FORNISS)
	EndIf

	If SA1->(Eof())
		SA1->(Dbsetorder(1))
		SA1->(DbSeek(xFilial("SA1") + SE1->E1_CLIENTE))
	EndIf

	nSalvCli := SA1->(RecNo())

	nBase061	:=	0    //Base utilizada para calcular os impostos no FINA061.
	If lBorde
		If !lPccMR .And. __lPccBxCr
			nBase061	:=	nValRec
			lGeraTitMin	:=  lRetTitMin
		EndIf
		If !lIrfMR
			lIRBx:=	__lLocBRA .And. ;
					Posicione("SA1",1,xfilial("SA1") + SE1->(E1_CLIENTE+E1_LOJA),"A1_IRBAX") == "1" .And. ;
					!(Posicione("SA1",1,xfilial("SA1") + SE1->(E1_CLIENTE+E1_LOJA),"A1_ENTID")) $ "00_02_10" .And. ;
					Posicione("SA1",1,xFilial("SA1")+SE1->(E1_CLIENTE+E1_LOJA),"A1_PESSOA") == "J" .And.;
					Posicione("SED",1,xfilial("SED") + SE1->(E1_NATUREZ),"ED_CALCIRF") = "S"
			nBase061	:=	nValRec
		Else
			lIRBx := .F.
		EndIf
	Else
		nBase061	:=	0
		lIRBx			:= .F.
	Endif
	cOrigem := Iif(cOrigem==NIL,Space(8),cOrigem)

	// Valor de IRRF referente ao recolhimento pelo Emitente;
	nRecIRRF	:= Iif(Type("nRecIRRF") <> "N", 0, nRecIRRF)

	lAltera	:=	.F.
	lUpDate	:=	If( (lUpDate == NIL),.T.,lUpDate )

	If Upper(subs(cOrigem,1,3)) == "LOJ"
		If ALLTRIM( SE1->E1_TIPO)  $ "CC;VA;CO;CD;FI"		// Cartao Credito, Vales, Convenio, Cartao de Debito, Financiamento Proprio
			lLojaCartao := .T.

			If __lECCia == NIL
				__lECCia := SuperGetMv("MV_LJECOMO", .T., .F.) .AND. SuperGetMv("MV_LJECOMS",.T., .F.) //EC CiaShop Implantado
			Endif

			If __lECCia
				lECCiaPed := SL1->L1_ECFLAG == "1" //Venda EC CiaShop
			EndIf
		Endif
	Endif

	DbSelectArea("SA1")
	DbSetOrder(1)
	Do Case
		Case lLojaCartao .AND. SL1->L1_TIPO <> "P"	.AND. ( SAE->AE_FINPRO == "N" .OR. Empty(SAE->AE_FINPRO) ) .AND. nModOrig <> 23 .And. !lLojxRec
			DbSeek(cFilial + SE1->E1_CLIENTE + SE1->E1_LOJA)
		Case lLojaCartao .AND. SL1->L1_TIPO <> "P" .AND. nModOrig <> 23 .And. !lLojxRec .And. !lIsVendaVP .And. !lIsVdRecCP .and. !lECCiaPed
			DbSeek(cFilial + SF2->F2_CLIENTE + SF2->F2_LOJA)
		Case lLojaCartao .AND. nModOrig <> 23 .And. !lLojxRec
			DbSeek(cFilial + SL1->L1_CLIENTE + SL1->L1_LOJA)
		OtherWise
			DbSeek(cFilial + SE1->E1_CLIENTE + SE1->E1_LOJA)
	EndCase

	// No SIGALOJA quando for cliente ADM Finan e o parametro estiver habilitado nao trava o registro do cliente
	aAreaSAE := SAE->(GetArea())
	SAE->(DbSetOrder(2))
	If SAE->(DbSeek(xFilial("SAE")+SA1->A1_COD))
		If __lLjAtuSa == NIL
			__lLjAtuSa	:= SuperGetMv("MV_LJATUSA",,.F.)
		Endif
		If __lLjAtuSa
			lAtuSalDup 	:= .F.
			lAtuAcum	:= .F.
			// Se tiver IRRF posicionamos no cliente para pegar a configuração dos campos do IRRF.
			If SE1->E1_IRRF > 0 .And. SE1->E1_CLIENTE + SE1->E1_LOJA <> SL1->L1_CLIENTE + SL1->L1_LOJA
				SA1->(DbSeek(cFilial + SL1->L1_CLIENTE + SL1->L1_LOJA))
			EndIf 
		EndIf
	EndIf
	SAE->(RestArea(aAreaSAE))

	If !lIssMR
		If __lLocBRA .and. Empty(cRecISS)
			cRecISS := SA1->A1_RECISS
			If !Empty(SE1->E1_PEDIDO) .And. Alltrim(SE1->E1_ORIGEM) == "FINA630"
				SC5->(Dbsetorder(3)) //C5_FILIAL+C5_CLIENTE+C5_LOJACLI+C5_NUM
				If SC5->(Dbseek(xFilial("SC5",SE6->E6_FILORIG) + SE1->E1_CLIENTE + SE1->E1_LOJA + SE1->E1_PEDIDO )) .And. !Empty(SC5->C5_RECISS)
					cRecIss := (SC5->C5_RECISS)
				Endif
			Endif
			If nModulo == 43 //TMS
				If type('nDTCRECISS') <> 'U'
					If nDTCRECISS == 2
						cRecISS := "2"
					ElseIf nDTCRECISS == 1
						cRecISS := "1"
					EndIf
				EndIf
			EndIf
		EndIf

		If Empty(cMVMUNIC) .and. !Empty(SA1->A1_MUNC)
			cMunISS := SA1->A1_MUNC
		Else
			If __lRMClass == NIL
				__lRMClass	:= SuperGetMV("MV_RMCLASS",,.F.)
			Endif

			If !__lRMClass
				// Validação para buscar o fornecdor e a loja do titulo de ISS
				// Olhar primeiro para o pedido de venda, se não econtrar olhar para
				// o cadastro de aliquotas e se não encontrar busca do parametro.

				// o campo C5_FORNISS existe apenas na localização BRA
				If __lLocBRA .And. !(Empty(SC5->C5_FORNISS))
					cForniss := SC5->C5_FORNISS
				EndIf

				If __lIssMunic == NIL
					__lIssMunic	:= SuperGetMv("MV_ISSXMUN",.T.,.F.)
				EndIf

				
				If __lLocBRA .And. !Empty(cForniss)
						cMunIss		:= cForniss
						cLojaImpos	:= FinVldSA2(cForniss)
				ElseIf __lLocBRA .And. __lIssMunic
					If !(Empty(SC5->C5_MUNPRES) .And. Empty(SC5->C5_ESTPRES))
						cMun 	:= Alltrim(SC5->C5_MUNPRES)
						cUf 	:= SC5->C5_ESTPRES
					Else
						cMun 	:= Alltrim(SA1->A1_COD_MUN)
						cUf 	:= SA1->A1_EST
					EndIf
					If ((CE1->(DbSeek(xFilial("CE1") + SD2->D2_CODISS + cUf + cMun + SD2->D2_COD))) .Or. (CE1->(DbSeek(xFilial("CE1") + SD2->D2_CODISS + cUf + cMun ))))
						cMunIss := CE1->CE1_FORISS
						cLojaImpos	:= FinVldSA2(CE1->CE1_FORISS)
					Else
					cAliasQry := GetNextAlias()

					cConsulta := ""
					cConsulta := "SELECT CE1_LOJISS, CE1_FORISS FROM "+RetSqlName("CE1")
					cConsulta += " WHERE CE1_FILIAL = '" + xFilial("CE1") + "'"
					cConsulta += "   AND CE1_ESTISS = '" + cUf + "'"
					cConsulta += "   AND CE1_CMUISS = '" + cMun + "'"
					cConsulta += "   AND CE1_PROISS = '" + SD2->D2_COD + "'"
					cConsulta := ChangeQuery( cConsulta )

					dbUseArea( .T., "TOPCONN", TcGenQry(,,cConsulta), cAliasQry, .F., .T. )

					If !( cAliasQRY )->( Eof())
						cMunIss := (cAliasQRY)->CE1_FORISS
						cLojaImpos	:= (cAliasQRY)->CE1_LOJISS
						EndIf
					( cAliasQRY )->( dbCloseArea() )
					EndIf
				EndIf
				RestArea(aAreaSA2)

				If Empty(cMunIss)
					cMunIss := cMVMUNIC
				EndIf
			Else
				cMunIss := cMVMUNIC
			EndIf
		EndIf
	EndIf

	// Verifica se aplica-se o valor mÃ­nimo de retecao do Ir pode ser retido
	If __lLocBRA .and. !lIrfMR
		If	SA1->A1_MINIRF == "1"
			__nMinRetIR := 0
		Endif
	Endif

	If cRetCli <> "2"
		cRetCli := IIf(Empty(SA1->A1_ABATIMP),"1",SA1->A1_ABATIMP)
	Endif

	If __lLocBRA .and. !lIssMR
		cMunISS := IIF(!Empty(SE1->E1_FORNISS),SE1->E1_FORNISS,cMunISS)
	Endif

	//Ponto de entrada para tratamento do valor minimo para IRRF.
	If !lIrfMR .And. __lF040MIRF
		xMinRetIR := 0
		xMinRetIR := Execblock("F040MIRF",.F.,.F.,{SA2->A2_COD,SA2->A2_LOJA})
		__nMinRetIR := If(ValType(xMinRetIR)=="N",xMinRetIR,__nMinRetIR)
	EndIf

	If !lIssMR
		// Verifica se o ambiente esta configurado com Multiplos Vinculos de ISS
		cNome := "MUNICIPIO"

		If __lLocBRA
			If !Empty( SE1->E1_CODISS )
				DbSelectArea( "FIM" )
				FIM->( DbSetOrder( 1 ) )
				If FIM->( DbSeek( xFilial( "FIM" ) + SE1->E1_CODISS ) )
					cMunIss := FIM->FIM_CODMUN
					cNome	+= "-" + AllTrim( FIM->FIM_MUN )
				EndIf
			EndIf
		EndIf

		If __lF040MISS == NIL
			__lF040MISS := ExistBlock("F040MISS")
		Endif

		If __lF040MISS
			__nMinISS := Execblock("F040MISS",.F.,.F.,{cMunISS})
		EndIf
	EndIf

	If nModulo == 43 .And. FindFunction("RetMunISS")	//-- TMS
		RetMunISS(SE1->E1_CLIENTE,SE1->E1_LOJA,@cMunIss,@cLojaImpos)
	EndIf

	// Atualiza Contas a Receber
	aArea := SE1->(GetArea())

	If cOrigem == "MATA460" .AND. __lMoedTit .AND. SE1->E1_MOEDA <> 1
		lAplTxMoeda := .F.	// Define se aplica taxa da moeda no cÃ¡lculo de IR. .F. para quando a base de IR jah vem com a taxa da moeda aplicada
	EndIf

	If ExistBlock("M460IREN")
		lM460Iren	:= .T.
	EndIf

	If !lIrfMR .And. !lFina040 .And. !lBorde

		If __lVRetIrf == NIL
			__lVRetIrf	:= !(cPaisLoc == "RUS") .and. !Empty(SE1->(FieldPos("E1_VRETIRF")))
		Endif

		If __lVRetIrf .And. SED->ED_CALCIRF == "S" .And. !lM460Iren
			nCalcIr := F040CalcIr(0,,.F.,SE1->E1_IRRF,@lIrfRetAnt ,, lAplTxMoeda)
		Endif
	EndIf
	SE1->(RestArea(aArea))

	DbSelectArea("SE1")
	RecLock("SE1",.F.)

	// Avalia as medicoes de contrato - SIGAGCT
	If len(aMedicao) > 0
		CNTAvalSC5(aMedicao,nProp,lTitFim)
	EndIf

	If __lLocBRA
		SE1->E1_RELATO := Iif(Empty(SE1->E1_RELATO),"2",SE1->E1_RELATO)
		SE1->E1_TPDESC := Iif(Empty(SE1->E1_TPDESC),"C",SE1->E1_TPDESC)
		//Verificacao do valor minimo de IRRF - Nao gerados pelo FINANCEIRO
		If !lIrfMR .And. !lFina040 .and. !lBorde  .And. !lM460Iren
			SE1->E1_IRRF := nCalcIr
			// Verifica se o Ir pode ser retido. Valor menor que MV_VLRETIR e' dispensado de recolhimento
			If ( SE1->E1_IRRF <= __nMinRetIR .and. !lIrfRetAnt .And. cRetCli <> "2")  .or. cRetCli == "3"
				SE1->E1_IRRF	:= 0
				If cRetCli == "3"
					SE1->E1_VRETIRF := 0
				EndIf
			EndIf
		Endif

		If __lFVldIns == NIL
			__lFVldIns	:= Existblock("FinVldIns")
		Endif

		If __nVlInsRet == NIL
			__nVlInsRet := SuperGetMV("MV_VLRETIN")
		Endif

		If !lInsMR .And. ( SE1->E1_INSS < __nVlInsRet )  .AND. (IIF(__lFVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. )) 	// VerIfica se o Inss pode ser retido
			SE1->E1_INSS := 0	// Valor menor que MV_VLRETIN e' dispensado de recolhimento
		EndIf

		If !lPccMR

			If __lCodRtPCC == NIL
				__lCodRtPCC	:= !__lPccBxCr .And. SE1->(FieldPos("E1_CODRET")) > 0 .And. SED->(FieldPos("ED_PCCINDV")) > 0
			Endif

			If SE1->E1_EMISSAO < dLastPcc
				If cRetCli == "3" .OR. ( SE1->E1_COFINS <= __nVRetCOF .And. cRetCli <> "2" ) // VerIfica se o Cofins pode ser retido
					If lMat460
						SE1->E1_SABTCOF	:= SE1->E1_COFINS
					EndIf
					SE1->E1_COFINS	:= 0							 // Valor menor que MV_VRETCOF e' dispensado de recolhimento.
				EndIf
				If cRetCli == "3" .OR. ( SE1->E1_PIS <= __nVRetPIS .And. cRetCli <> "2" ) // VerIfica se o Pis pode ser retido
					If lMat460
						SE1->E1_SABTPIS	:= SE1->E1_PIS
					EndIf
					SE1->E1_PIS	:= 0							 // Valor menor que MV_VRETPIS e' dispensado de recolhimento.
				EndIf
				If cRetCli == "3" .OR. ( SE1->E1_CSLL <= __nVRetCSLL .And. cRetCli <> "2" ) // VerIfica se o Csll pode ser retido
					If lMat460
						SE1->E1_SABTCSL	:= SE1->E1_CSLL
					EndIf
					SE1->E1_CSLL	:= 0							 // Valor menor que MV_VRETCSL e' dispensado de recolhimento.
				EndIf
			ElseIf lAbate .And. __lCodRtPCC .And. SED->ED_PCCINDV == '1' .And. ( SE1->E1_COFINS == 0 .Or. SE1->E1_PIS == 0 .Or. SE1->E1_CSLL == 0 )
				If cRetCli == "3" .OR. ( SE1->E1_COFINS <= nVRetCOF .And. cRetCli <> "2" ) // VerIfica se o Cofins pode ser retido
					If lMat460
						SE1->E1_SABTCOF	:= SE1->E1_COFINS
					EndIf
					SE1->E1_COFINS	:= 0							 // Valor menor que MV_VRETCOF e' dispensado de recolhimento.
				EndIf

				If cRetCli == "3" .OR. ( SE1->E1_PIS <= nVRetPIS .And. cRetCli <> "2" ) // VerIfica se o Pis pode ser retido
					If lMat460
						SE1->E1_SABTPIS	:= SE1->E1_PIS
					EndIf
					SE1->E1_PIS	:= 0							 // Valor menor que MV_VRETPIS e' dispensado de recolhimento.
				EndIf

				If cRetCli == "3" .OR. ( SE1->E1_CSLL <= nVRetCSLL .And. cRetCli <> "2" ) // VerIfica se o Csll pode ser retido
					If lMat460
						SE1->E1_SABTCSL	:= SE1->E1_CSLL
					EndIf
					SE1->E1_CSLL	:= 0							 // Valor menor que MV_VRETCSL e' dispensado de recolhimento.
				EndIf
			EndIf
		ElseIf lMat460 .And. lPccMR
			
			SE1->E1_SABTCOF	:= 0
			SE1->E1_SABTCSL	:= 0
			SE1->E1_SABTPIS := 0	

		EndIf
		// Se o cliente abate o ISS, gera abatimento. Senao, gera titulo para pagamento do tributo.
		If !lIssMR .And. cRecISS == "1" .And. lDescIss
			If lGerAbtISS
				If __cModRIss == NIL
					__cModRIss	:= SuperGetMv("MV_MODRISS",,"1")
				Endif
				SomaTitISS("SE1",SE1->E1_CLIENTE,SE1->E1_LOJA,SE1->E1_VENCREA,@nTotISS,@nVRetISS)
				If ( SE1->E1_FRETISS=="1" .Or.;	//Se a opcao no cadastro de clientes existir e estiver como 1=Considera Valor Minimo, respeito o tratamento padrao.
					(SE1->E1_FRETISS=="2" .And. __cModRIss == "2") .Or.; //Se a opcao no cadastro de clientes existir, estiver como 2=Sempre reter e a Modalidade de retencao for 1=Por titulo, desconsidero o Valor minimo e gero o titulo normalmente.
					(nTotISS > 0 .And. nTotISS <= __nMinISS ))
					If SE1->E1_VLMINIS == "2" //Tratamento para a cidade de Cascavel-PR Decreto n.Âº 8.230
						If (SE1->E1_ISS+nVRetISS) > (SE1->E1_VALOR)-0.01
							SE1->E1_VRETISS := (SE1->E1_ISS+nVRetISS) - ((SE1->E1_VALOR)-0.01)
							SE1->E1_ISS := (SE1->E1_VALOR)-0.01
						Else
							SE1->E1_ISS := (SE1->E1_ISS+nVRetISS)
						EndIf
					Else
						If (nTotISS > 0 .And. (nTotISS >= __nMinISS .OR. SE1->E1_FRETISS == "2"))
							SE1->E1_VRETISS := SE1->E1_ISS
						Else
							SE1->E1_ISS := 0
						EndIf
					Endif
				Else
					If (SE1->E1_ISS+nVRetISS) > (SE1->E1_VALOR)-0.01
						SE1->E1_VRETISS := (SE1->E1_ISS+nVRetISS) - ((SE1->E1_VALOR)-0.01)
						SE1->E1_ISS := (SE1->E1_VALOR)-0.01
						Else
						SE1->E1_ISS := (SE1->E1_ISS+nVRetISS)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	SE1->E1_NOMCLI  := SA1->A1_NREDUZ

	//Se a origem for o LOJA e a carteira jah estiver definida, nao alterar.
	If AllTrim(Upper(cOrigem)) $ "LOJA010|LOJA701|FATA701"
		If Empty(SE1->E1_SITUACA) .AND. !Upper(AllTrim(SE1->E1_SITUACA)) $ "I|J"
			SE1->E1_SITUACA := "0"
		Endif
	Else
		SE1->E1_SITUACA := "0"
	Endif

	If EMPTY(SE1->E1_EMIS1)
		SE1->E1_EMIS1	 := dDataBase
	EndIF

	If !lBorde
		SE1->E1_BAIXA	 := CtoD("  /  /  ")
	Endif

	If !(SE1->E1_SALDO < SE1->E1_VALOR .And. lBorde)
		SE1->E1_SALDO	 := SE1->E1_VALOR
	Endif
	SE1->E1_STATUS  := Iif(E1_SALDO>0.01,"A","B")

	If !lBorde
		SE1->E1_ORIGEM  := UPPER(cOrigem)
	EndIf

	If SE1->E1_TIPO $ MVABATIM		 // Se for abatimento
		SE1->E1_OCORREN := "04"
		SE1->E1_TITPAI  := cTitpai
	EndIf
	SE1->E1_FILORIG  := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)

	cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
			SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
	
	FINGRVFK7("SE1", cChaveTit,, SE1->E1_TITPAI)

	if lPLSTITPF
		PLSTITPF('SE1',cTitPai)
	endIf

	If __lM040Se1
		Execblock("M040SE1",.F.,.F.)
	Endif

	// NÃO atualiza acumuladores quando operacao de adiantamento no mexico.
	If cPaisLoc == "MEX" .AND. FunName() == "MATA467N" .AND. SF2->F2_TIPO == "A"
		lAtuAcum 		:= .F.
		lAtuSalDup 	:= .F.
	EndIf

	nSavRec  := SE1->(RecNo())
	
	__nMCusto := If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, __nMCusto)

	// Atualiza Acumulado de Clientes
	If SA1->(eof())
		SA1->(Dbsetorder(1))
		SA1->(DbSeek(xFilial("SA1") + SE1->E1_CLIENTE))
	EndIf

	If !( SE1->E1_TIPO $ MVRECANT + "/"+MV_CRNEG)
		DbSelectArea("SA1")

		If __cCliPad == NIL
			__cCliPad    := SuperGetMv("MV_CLIPAD",,"")
		Endif

		If __cLojaPad == NIL
			__cLojaPad   := SuperGetMv("MV_LOJAPAD",,"")
		Endif

		// Nao atualizar os campos A1_VACUM e A1_NROCOM se o modulo for o loja ou frontloja (via RPC) e o cliente = cliente padrao.
		If ((Upper(subs(cOrigem,1,3)) == "LOJ") .AND. (__cCliPad + __cLojaPad == SA1->A1_COD + SA1->A1_LOJA));
			.Or. (FunName() == "FINA074")
			lAtuAcum := .F.
		EndIf

		If lTravaSA1
			lGrvSa1:= ExecBlock("F040TRVSA1",.F.,.F.)
		Endif

		If lAtuAcum .And. !lOriFatura .and. !lFINA460 .and. lGrvSa1 .and. (!__lRskActv .or. !(AllTrim(SA1->A1_COD) + "|" + AllTrim(SA1->A1_LOJA) == AllTrim(__cRskCPay)))
			Reclock("SA1",.F.)
			SA1->A1_PRICOM  := Iif(SE1->E1_EMISSAO<SA1->A1_PRICOM .Or. Empty(SA1->A1_PRICOM),SE1->E1_EMISSAO,SA1->A1_PRICOM)
			SA1->A1_ULTCOM  := Iif(SA1->A1_ULTCOM<SE1->E1_EMISSAO .And. SE1->E1_TIPO != "NDC",SE1->E1_EMISSAO,SA1->A1_ULTCOM)
			SA1->A1_NROCOM  := SA1->A1_NROCOM + If( lUpDate,1,0 )
			If !IsInCallStack("FA040Subst")//Caso seja uma substuiÃ§Ã£o não somar o valor novamente
				SA1->A1_VACUM	:= SA1->A1_VACUM + Round(NoRound(xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,__nMCusto,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA),3),2)
			EndIf
			SA1->(MsUnlock())
		EndIf
	EndIf

	DbSelectArea("SE1")
	If !( SE1->E1_TIPO $ MVABATIM )

		If __cCSLNAT == NIL
			__cCSLNAT	:= PadR(SuperGetMV("MV_CSLL",.F.,"CSLL"),__nTamNat)
		Endif

		If __cPISNAT == NIL
			__cPISNAT	:= PadR(SuperGetMV("MV_PISNAT",.F.,"PIS"),__nTamNat)
		Endif

		If __cCOFNAT == NIL
			__cCOFNAT	:= PadR(SuperGetMV("MV_COFINS",.F.,"COFINS"),__nTamNat)
		Endif

		cNatImp += "|" + If(!lIssMR .And. !Empty(SuperGetMV("MV_ISS")),PADR(&(SuperGetMV("MV_ISS")),__nTamNat),"")
		cNatImp += "|" + If(!lIrfMR .And. !Empty(SuperGetMV("MV_IRF")),PADR(&(SuperGetMV("MV_IRF")),__nTamNat),"")
		cNatImp += "|" + If(!lInsMR.And. !Empty(SuperGetMV("MV_INSS")),PADR(&(SuperGetMV("MV_INSS")),__nTamNat),"")
		If !lPccMR
			cNatImp += "|" + If(!Empty(__cCSLNAT),__cCSLNAT,"")
			cNatImp += "|" + If(!Empty(__cPISNAT),__cPISNAT,"")
			cNatImp += "|" + If(!Empty(__cCOFNAT),__cCOFNAT,"")
		EndIf

		If !__lLocBRA .Or. !(SE1->E1_NATUREZ $ cNatImp)

			cPrefixo  	:= E1_PREFIXO
			cNum		:= E1_NUM
			cTipoE1   	:= E1_TIPO

			// Atualiza Acumulado Financeiros do Cliente
			If nValTot == Nil
				nValTot := 0
				DbSelectArea("SE1")
				DbSetOrder(1)
				DbSeek(cFilial+cPrefixo+cNum)
				While ( !EOF() .And. E1_FILIAL+E1_PREFIXO+E1_NUM+E1_TIPO == ;
					cFilial+cPrefixo+cNum+cTipoE1 )
					nValTot := nValTot + xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,__nMCusto,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
					DbSkip()
				EndDo
				DbGoTo( nSavRec )
			EndIf

			// Nao Atualiza Caso seja um RA / NCC / PR
			If lAtuSalDup .And. !( SE1->E1_TIPO $ MVRECANT+"/"+MVPROVIS+"/"+MV_CRNEG )

				// No caso dos modulos Sigaloja e Front Loja na atualiza os saldos de duplicatas para o cliente padrao
				If !( (Upper(subs(cOrigem,1,3)) == "LOJ") .AND. (__cCliPad + __cLojaPad == SE1->E1_ClIENTE + SE1->E1_LOJA) ) .And. FunName() <> "FINA074"
					nValForte := xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
					If !lLojaDin
						AtuSalDup("+",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
					EndIf
					nValForte := xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,__nMCusto,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
					If lGrvSa1 .and. (!__lRskActv .or. !(AllTrim(SA1->A1_COD) + "|" + AllTrim(SA1->A1_LOJA) == AllTrim(__cRskCPay)))
						nValForte := xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,__nMCusto,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
						RecLock("SA1",.F.)
						SA1->A1_MSALDO :=Iif(SA1->A1_SALDUPM>SA1->A1_MSALDO,SA1->A1_SALDUPM,SA1->A1_MSALDO)
						If ( nValForte > SA1->A1_MAIDUPL )
							SA1->A1_MAIDUPL := nValForte
						EndIf
						DbSelectArea("SA1")
						If ( nValTot > SA1->A1_MCOMPRA )
							SA1->A1_MCOMPRA := nValTot
						EndIf
						MsUnlock()
					EndIf
				EndIf
			EndIf
			If __lLocBRA
				DbSelectArea( "SE1" )
				cParcela 	:= SE1->E1_PARCELA
				dEmissao 	:= SE1->E1_EMISSAO
				dVencto		:= SE1->E1_VENCTO
				dVencRea	:= SE1->E1_VENCREA
				If lBorde .and. AllTrim(FunName()) <> "FINA890"
					dEmissao 	:= SEA->EA_DATABOR
				EndIf
				If !lIrfMR
					nIrrf 	:= SE1->E1_IRRF
				EndIf
				If !lIssMR
					nIss		:= SE1->E1_ISS
					nBtrIss		:= SE1->E1_BTRISS
					lValBtrISS 	:= nBtrIss > 0

					If Alltrim(SE1->E1_ORIGEM) $ "TMSA491/TMSA850" .And. Type('nDTCISS') <> 'U' .And. nModulo == 43 //TMS
						nIss 	:= nDTCISS
					EndIf
				EndIf
				If !lInsMR
					nInss 		:= SE1->E1_INSS
				EndIf
				cNatur		:= SE1->E1_NATUREZ
				cCliente 	:= SE1->E1_CLIENTE
				cLoja 		:= SE1->E1_LOJA
				If !lPccMR
					nCofins  	:= SE1->E1_COFINS
					If nBase061 > 0	//Chamado pela rotina de criacao de bordero de imposto a receber e PCC na baixa	os valores do PCC estarao preenchidos.
						If lRetPIX
							nCofins := nCofFin891
							nPis    := nPisFin891
							nCsll   := nCslFin891
							nIrrf   := nIrfFin891
						Else
							nCofins	:=	nCofFina061
							nPis	:=	nPisFina061
							nCsll	:= 	nCslFina061
						EndIf
					ElseIf nBase061 = 0
						nCofins 	:= SE1->E1_COFINS
						nPis     	:= SE1->E1_PIS
						nCsll    	:= SE1->E1_CSLL
					EndIf
					If !lRetPIX .and. lIRBx .and. lBorde
						nIrrf		:= nIrrfFina061
					EndIf
				EndIf

				//Tratamento loja para manter a chave do titulo pai informado no parametro
				If Upper(subs(cOrigem,1,3)) == "LOJ"
					If Empty(cTitPai)
						cTitPai := SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)
					EndIf
				Else
					cTitPai := SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)
				EndIf

				// Gravação da taxa contratada para gravação no titulo de imposto (abatimento)
				// que poderá ser gerado futuramente na moeda 1
				If SE1->E1_MOEDA <> 1
					nTaxaTit := SE1->E1_TXMOEDA
				Endif
				nFetHab := SE1->E1_FETHAB
				nFabov  := SE1->E1_FABOV
				nTPDP   := SE1->E1_TPDP
				nFacs   := SE1->E1_FACS

				If lFamad == Nil
					lFamad := SE1->(ColumnPos("E1_PARCFAM")) > 0 .and. SE1->(ColumnPos("E1_FAMAD")) > 0
				EndIf

				If lFamad
					nFamad  := SE1->E1_FAMAD
				Endif

				If lFumipeq == NIL
					lFumipeq	:= (SE1->(ColumnPos("E1_FMPEQ")) > 0 .And. SE1->(ColumnPos("E1_PARCFMP")) > 0)
				Endif

				If __lCposIMA == NIL
					__lCposIMA	:= (SE1->(ColumnPos("E1_IMA"))   > 0 .And. SE1->(ColumnPos("E1_PARCIMA")) > 0)
				Endif

				If __lCposIMA
					nIMA := SE1->E1_IMA
				Endif

				If lFumipeq
					nFumipeq := SE1->E1_FMPEQ
				EndIf

				//Gravação dos impostos pelo motor de retenções
				If __lMotRet .And. Len(aMotRet) > 0
					FinGrvImp( "2", SE1->(RECNO()), aMotRet, cOrigem, .F., {}, {}, .T., .F., .F., , "", "", SE1->E1_TIPO $ MVRECANT)
				EndIf
				//----------------------------------------------
				// Gera titulo de IRRF
				//----------------------------------------------
				If !lIrfMR .And. ( nIrrf > 0 .And.  Iif(lBorde,lIRBx ,!__lIrPjBxCr))
					If ( SED->ED_RECIRRF == "2" .OR. ( SA1->A1_RECIRRF == "2" .AND. SED->ED_RECIRRF $ "3| " ) )

						// Cria o Fornecedor, caso nao exista
						DbSelectArea("SA2")
						SA2->(DbSetOrder(1))
						If !DbSeek(xFilial("SA2")+cUniao+cLojaIrf)
							Reclock("SA2",.T.)
							SA2->A2_FILIAL  := cFilial
							SA2->A2_COD 	:= cUniao
							SA2->A2_LOJA	:= cLojaIrf
							SA2->A2_NOME	:= "UNIAO"
							SA2->A2_NREDUZ  := "UNIAO"
							SA2->A2_BAIRRO  := "."
							SA2->A2_MUN 	:= "."
							SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
							SA2->A2_End 	:= "."
							SA2->A2_TIPO	:= "J"
							MsUnlock()
						EndIf

						cCodRetIR := SED->ED_CODRET
						cParcIRF  := ParcImposto(cPrefixo,cNum,MVTAXA)
						dNextDay  := F050vImp("IRRF",dEmissao,dDataBase,dVencrea)
						dVencRea  := dNextDay

						RecLock("SE2",.T.)
						SE2->E2_FILIAL	:= cFilial
						SE2->E2_PREFIXO	:= cPrefixo
						SE2->E2_NUM		:= cNum
						SE2->E2_PARCELA	:= cParcIRF
						SE2->E2_TIPO	:= MVTAXA
						SE2->E2_EMISSAO	:= dEmissao
						SE2->E2_VALOR	:= nIrrf
						SE2->E2_VENCREA	:= dVencrea
						SE2->E2_SALDO	:= nIrrf
						SE2->E2_VENCTO	:= dVencRea
						SE2->E2_VENCORI	:= dVencRea
						SE2->E2_MOEDA	:= If(__lLocBRA,1,nMoeda)
						SE2->E2_EMIS1	:= dDataBase
						SE2->E2_FORNECE	:= cUniao
						SE2->E2_VLCRUZ	:= Round(nIrrf, MsDecimais(1) )
						SE2->E2_LOJA	:= SA2->A2_LOJA
						SE2->E2_NOMFOR	:= SA2->A2_NREDUZ
						SE2->E2_ORIGEM	:= Upper(cOrigem)
						cNatureza		:= &(GetMv("MV_IRF"))
						SE2->E2_NATUREZ	:= cNatureza
						SE2->E2_LA		:= cLA			// Herda do principal
						SE2->E2_CODAPRO	:= cCodAprov
						SE2->E2_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
						SE2->E2_TITPAI  := cTitpai
						If __lLocBRA .and. !Empty(cCodRetIR)
							SE2->E2_DIRF		:= "1"
							SE2->E2_CODRET		:= cCodRetIR
						EndIf

						MsUnLock()

						cChaveTit := xFilial("SE2", SE2->E2_FILORIG) + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" + ;
							SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
						FINGRVFK7("SE2", cChaveTit,, cTitpai, "SE1")

						if lPLSTITPF
							PLSTITPF('SE2',cTitPai)
						endIf

						AADD(aRecImpos,{"SE2",Recno()})

						//GRAVAR A PARCELA DO IRRF NO TITULO PRINCIPAL NO SE1
						DbSelectArea("SE1")
						DbGoTo(nSavRec)
						RecLock("SE1",.F.)
						SE1->E1_PARCIRF	:= cParcIRF
						SE1->(MsUnLock())

						// Gera lançamento do IRRF no SIGAPCO a partir do contas a pagar
						If Upper(cOrigem) == "FINA040"
							PCODetLan("000001","12",Upper(cOrigem))
						EndIf
					Endif

					If  ( SED->ED_RECIRRF == "1" .OR.( SA1->A1_RECIRRF == "1" .AND. SED->ED_RECIRRF $ "3| " ) )

						If __lIRMP232 == NIL
							__lIRMP232 	:= (GetNewPar("MV_IRMP232","2") != "1")
						Endif

						If __lIRMP232

							cNatureza	:= &(SuperGetMV("MV_IRF"))
							cNatureza	:= PadR(cNatureza, __nTamNat)

							// Busca a parcela IR de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA
							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVIRABT,3))
								cParcela := Soma1(cParcela,__nTamParc)
							EndDo

							DbSelectArea("SE1")
							RecLock("SE1",.T.)
							SE1->E1_FILIAL  := cFilSE1
							SE1->E1_PREFIXO := cPrefixo
							SE1->E1_NUM 	:= cNum
							SE1->E1_EMISSAO := dEmissao
							SE1->E1_VALOR	:= nIrrf
							SE1->E1_VENCREA := dVencRea
							SE1->E1_VENCTO  := dVencto
							SE1->E1_VENCORI := dVencto
							SE1->E1_EMIS1	:= dDataBase
							SE1->E1_CLIENTE := cCliente
							SE1->E1_LOJA	:= cLoja
							SE1->E1_SITUACA := "0"
							SE1->E1_NOMCLI  := SA1->A1_NREDUZ
							SE1->E1_MOEDA	:= If(__lLocBRA,1,nMoeda)
							SE1->E1_VLCRUZ  := Round( nIrrf , MsDecimais(1) )

							If (lIRBx .And. lBorde)
								SE1->E1_STATUS	 	:= "B"
								SE1->E1_ORIGEM		:= cOrigImp
								SE1->E1_TIPO	  	:= "IRF"
								SE1->E1_PARCELA		:= ParcImpRec(cPrefixo,cNum,"IRF")
								SE1->E1_SALDO	 	:= 0
								SE1->E1_OCORREN 	:= Space(2)
							Else
								SE1->E1_PARCELA		:= cParcela
								SE1->E1_STATUS 		:= Iif(SE1->E1_SALDO>0.01,"A","B")
								SE1->E1_ORIGEM 		:= UPPER(cOrigem)
								SE1->E1_TIPO		:= MVIRABT
								SE1->E1_SALDO	 	:= nIrrf
								SE1->E1_OCORREN 	:= "04"
							Endif
							SE1->E1_NATUREZ 	:= cNatureza
							SE1->E1_LA      	:= cLa
							SE1->E1_FATURA		:= cFatura
							SE1->E1_TXMOEDA 	:= nTaxaTit
							SE1->E1_FILORIG  	:= If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
							SE1->E1_TITPAI 		:= cTitpai
							SE1->E1_CODIRRF 	:= cCodIrrf
							If __lLocBRA .and. !Empty(SED->ED_CODRET)
								SE1->E1_CODRET	:= SED->ED_CODRET
							EndIf

							lAbateuIRF	:=	.T.

							AADD(aRecImpos,{"SE1",Recno()})

							If __lF040IRF == NIL
								__lF040IRF 	:= ExistBlock("F040IRF")
							Endif

							If __lF040IRF
								Execblock("F040IRF",.F.,.F.,nSavRec)
							EndIf

							AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

							cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
								SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							FINGRVFK7("SE1", cChaveTit, , cTitpai)

							if lPLSTITPF
								PLSTITPF('SE1',cTitPai)
							endIf

							// Baixa do Saldo do cliente o valor do IR.
							DbSelectArea("SA1")
							If lAtuSalDup .and. ( DbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA ))
								If !lLojaDin
									AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
								EndIf
							EndIf

							// Gera lançamento do IRRF no SIGAPCO a partir do contas a receber
							If Upper(cOrigem) == "FINA040"
								PCODetLan("000001","06",Upper(cOrigem))
							EndIf

						Else
							lAbateuIRF	:=	.F.
						EndIf
					Endif
				Endif
				//----------------------------------------------
				// Gera titulo de INSS
				//----------------------------------------------
				If !lInsMR .And. ( nInss > 0 ) .And. !lBorde

					// Busca a parcela INSS de acordo com o titulo
					dbSelectArea("SE1")
					dbSetOrder(1)

					cParcela := SE1->E1_PARCELA
					nRecSE1 := SE1->(Recno())

					While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVINABT,3))
						cParcela := Soma1(cParcela,__nTamParc)
					EndDo

					cNatureza	:= &(SuperGetMV("MV_INSS"))
					cNatureza	:= PadR(cNatureza, __nTamNat)

					If SE1->(Eof())
						SE1->(dbGoTo(nRecSE1))
					EndIf

					SA1->(DbSetOrder(1))
					cChaveSE1 := IIf(!Empty(SE1->(E1_CLIENTE+E1_LOJA)),SE1->(E1_CLIENTE+E1_LOJA),IIf(Type("M->E1_CLIENTE") != "U",M->(E1_CLIENTE+E1_LOJA),""))
					SA1->(DbSeek(xFilial("SA1")+cChaveSE1))

					If SA1->A1_RECINSS == "S" .Or. AllTrim(cOrigem) == "FINA040"
						RecLock("SE1",.T.)
						SE1->E1_FILIAL  := cFilSE1
						SE1->E1_PREFIXO := cPrefixo
						SE1->E1_NUM 	:= cNum
						SE1->E1_PARCELA := cParcela
						SE1->E1_TIPO	:= MVINABT
						SE1->E1_EMISSAO := dEmissao
						SE1->E1_VALOR	:= nInss
						SE1->E1_VENCREA := dVencRea
						SE1->E1_SALDO	:= nInss
						SE1->E1_VENCTO  := dVencto
						SE1->E1_VENCORI := dVencto
						SE1->E1_EMIS1	:= dDataBase
						SE1->E1_CLIENTE := cCliente
						SE1->E1_LOJA	:= cLoja
						SE1->E1_SITUACA := "0"
						SE1->E1_NOMCLI  := SA1->A1_NREDUZ
						SE1->E1_MOEDA	:= If(__lLocBRA,1,nMoeda)
						SE1->E1_VLCRUZ  := Round( nInss, MsDecimais(1) )
						SE1->E1_STATUS  := Iif(SE1->E1_SALDO > 0.01,"A","B")
						SE1->E1_ORIGEM  := UPPER(cOrigem)
						SE1->E1_OCORREN := "04"
						SE1->E1_NATUREZ := cNatureza
						SE1->E1_LA      := cLa
						SE1->E1_FATURA  := cFatura
						SE1->E1_TXMOEDA := nTaxaTit
						SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
						SE1->E1_TITPAI  := cTitpai

						AADD(aRecImpos,{"SE1",Recno()})

						If __lF040INS == NIL
							__lF040INS 	:= ExistBlock("F040INS")
						Endif

						If __lF040INS
							Execblock("F040INS",.F.,.F.,nSavRec)
						EndIf

						MsUnlock()

						cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
							SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
						FINGRVFK7("SE1", cChaveTit, , cTitpai)

						if lPLSTITPF
							PLSTITPF('SE1',cTitPai)
						endIf

						// Baixa do Saldo do cliente o valor do Inss
						DbSelectArea("SA1")
						If lAtuSalDup .AND. ( DbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA ))
							If !lLojaDin
								AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
							EndIf
						EndIf

						AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

					ElseIf !lFINA460
						//Cria o fornecedor caso não encontre
						DbSelectArea("SA2")
						If !(MsSeek(xFilial() + cCodMVINS + cLojaImpos))
							Reclock("SA2",.T.)
							SA2->A2_FILIAL	:= xFilial("SA2")
							SA2->A2_COD		:= cCodMVINS
							SA2->A2_LOJA	:= If(Alltrim(cLojaImpos)<>"",cLojaImpos,PadR("00",TamSX3("A2_LOJA")[1],"0"))
							SA2->A2_NOME	:= "Instituto Nacional de Previdencia Social"
							SA2->A2_NREDUZ	:= "INPS"
							SA2->A2_BAIRRO	:= "."
							SA2->A2_MUN		:= "."
							SA2->A2_EST		:= SuperGetMv("MV_ESTADO")
							SA2->A2_END		:= "."
							SA2->A2_TIPO	:= "J"
							MsUnlock()
							FKCOMMIT()
						EndIf

						cNatureza	:= &(GetMv("MV_INSS"))
						cNatureza	:= PadR(cNatureza, __nTamNat)

						If Type("CA100FOR") <> "U"
							cTipoFor 	:= ALLTRIM(GetAdvFval("SA2","A2_TIPO",xFilial("SA2")+CA100FOR+cLoja,1,""))
							If cTipoFor == "J"
								cCNPJRET := GetAdvFval("SA2","A2_CGC",xFilial("SA2")+CA100FOR+cLoja,1,"")
							Else
								cCNPJRET := GetAdvFval("SM0","M0_CGC",cEmpAnt+xFilial("SE2"),1,"")
							EndIf
						Else
							cCNPJRET := ""
						EndIf
						cRETINS := GetAdvFval("SE2","E2_RETINS",xFilial("SE2")+cPrefixo+cNum+cParcela,1,"")

						dVencReaAux := dVencRea
						dVencRea	:= F050vImp("INSS",dEmissao,dDataBase,dVencrea)

						If "LOJ" $ cOrigem
							dbSelectArea("SE2")
							dbSetOrder(1)

							cParcela := SE2->E2_PARCELA
							nTamParc := Len(SE2->E2_PARCELA)
							While MSSeek(xFilial("SE2")+cPrefixo+cNum+cParcela+left(MVINSS,3))
								cParcela := Soma1(cParcela,nTamParc)
							EndDo
						EndIf

						RecLock("SE2",.T.)
						SE2->E2_FILIAL  := xFilial("SE2")
						SE2->E2_PREFIXO := cPrefixo
						SE2->E2_NUM 	:= cNum
						SE2->E2_PARCELA := cParcela
						SE2->E2_TIPO	:= MVINSS
						SE2->E2_EMISSAO := dEmissao
						SE2->E2_VALOR	:= nInss
						SE2->E2_VENCREA := dVencrea
						SE2->E2_SALDO	:= nInss
						SE2->E2_VENCTO  := dVencRea
						SE2->E2_VENCORI := dVencRea
						SE2->E2_MOEDA	:= If(__lLocBRA,1,nMoeda)
						SE2->E2_EMIS1	:= dDataBase
						SE2->E2_FORNECE := cCodMVINS
						SE2->E2_VLCRUZ  := nInss
						SE2->E2_LOJA	:= cLojaImpos
						SE2->E2_NOMFOR  := "INPS"
						SE2->E2_ORIGEM  := cOrigem
						SE2->E2_NATUREZ := cNatureza
						SE2->E2_LA      := cLA
						SE2->E2_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG) //filial origem do titulo pai
						SE2->E2_TITPAI  := cTitpai
						SE2->E2_CODAPRO	:= cCodAprov
						SE2->E2_RETINS  := cRETINS
						SE2->E2_CNPJRET := cCNPJRET

						MsUnLock()

						cChaveTit := xFilial("SE2", SE2->E2_FILORIG) + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" + ;
							SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
						FINGRVFK7("SE2", cChaveTit,, cTitpai, "SE1")

						if lPLSTITPF
							PLSTITPF('SE2',cTitPai)
						endIf

						AADD(aRecImpos,{"SE2",Recno()})

						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))

						dVencRea := dVencReaAux
					EndIf

					//Gera lançamento do INSS no SIGAPCO a partir do contas a receber
					If Upper(cOrigem) == "FINA040"
						PCODetLan("000001","07",Upper(cOrigem))
					EndIf

				EndIf

				//--------------------------------------------------------
				//Gera titulo de ISS
				//--------------------------------------------------------
				If !lIssMR .And. ( nIss > 0 ) .And. !lBorde
					//Cria o fornecedor, caso nao exista
					DbSelectArea("SA2")
					Dbsetorder (1)
					If !( DbSeek(xFilial("SA2")+PadR(cMunIss,__nTamFor)+cLojaImpos) )
						Reclock("SA2",.T.)
						SA2->A2_FILIAL	:= cFilial
						SA2->A2_COD 	:= cMunIss
						SA2->A2_LOJA	:= cLojaImpos
						SA2->A2_NOME	:= cNome // MUNICIPIO
						SA2->A2_NREDUZ	:= cNome // MUNICIPIO
						SA2->A2_BAIRRO	:= "."
						SA2->A2_MUN 	:= "."
						SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
						SA2->A2_End 	:= "."
						MsUnlock()
						FKCOMMIT()
					EndIf

					cNatureza	:= &(SuperGetMV("MV_ISS"))
					cNatureza	:= PadR(cNatureza, __nTamNat)

					// Se o cliente abate o ISS, gera abatimento. Senao, gera titulo para pagamento do tributo.
					If cRecISS == "1" .And. lDescIss .And. IIF(lFINA630, lTrfISSf, .T.)

						If lGerAbtISS
							//Busca a parcela ISS de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA
							nTamParc := Len(SE1->E1_PARCELA)
							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVISABT,3))
								cParcela := Soma1(cParcela,nTamParc)
							EndDo

							If Alltrim(SM0->M0_ESTENT) == "SC" .And. ;
								( ( Len( Alltrim( SM0->M0_CODMUN ) ) == 5 .And. Alltrim( SM0->M0_CODMUN ) == "09102" ) .Or. ( Len( Alltrim( SM0->M0_CODMUN ) ) == 7 .And. SubStr( Alltrim( SM0->M0_CODMUN ) , 3 , 5 ) == "09102" ) )
								aAreaFor:= getArea("SA1")
								DbSelectArea("SA1")
								DbSetOrder(1)
								If SA1->(DbSeek(xFilial("SA1")+cCliente+cLoja)) .And. Alltrim(SA1->A1_EST) == "SC"
									dVenISS := fCRetCal(6,dEmissao)
									dVencRIss := dVenISS
									nDiaUtIss := 1
								EndIf
								restArea(aAreaFor)
							EndIf

							__nDiaUtIss := If(nDiaUtIss > 0, nDiaUtIss, __nDiaUtIss)

							RecLock("SE1",.T.)
							SE1->E1_FILIAL	:= cFilSE1
							SE1->E1_PREFIXO := cPrefixo
							SE1->E1_NUM		:= cNum
							SE1->E1_PARCELA := cParcela

							cNatureza:= &(SuperGetMV("MV_ISS"))
							SE1->E1_NATUREZ := PadR(cNatureza, __nTamNat)
							SE1->E1_TIPO	:= MVISABT
							SE1->E1_EMISSAO := dEmissao
							SE1->E1_VALOR	:= nIss
							SE1->E1_VENCREA := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencRea)
							SE1->E1_SALDO	:= nIss
							SE1->E1_VENCTO  := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencto)
							SE1->E1_VENCORI := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencto)
							SE1->E1_EMIS1	:= dDataBase
							SE1->E1_CLIENTE := cCliente
							SE1->E1_LOJA	:= cLoja
							SE1->E1_NOMCLI  := SA1->A1_NREDUZ
							SE1->E1_MOEDA	:= If(__lLocBRA,1,nMoeda)
							SE1->E1_VLCRUZ  := Round( nIss, MsDecimais(1) )
							SE1->E1_STATUS  := Iif(SE1->E1_SALDO > 0.01,"A","B")
							SE1->E1_ORIGEM  := UPPER(cOrigem)
							SE1->E1_LA      := cLa
							SE1->E1_FATURA	:= cFatura
							SE1->E1_SITUACA := "0"
							SE1->E1_OCORREN := "04"
							SE1->E1_SITUACA := "0"
							SE1->E1_TXMOEDA := nTaxaTit
							SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
							SE1->E1_TITPAI  := cTitpai

							AADD(aRecImpos,{"SE1",Recno()})

							// Baixa do Saldo do cliente o valor do Iss
							DbSelectArea("SA1")
							If lAtuSalDup .and. ( MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA ))
								If !lLojaDin
									AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
								EndIf
							EndIf

							AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

							cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
								SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							FINGRVFK7("SE1", cChaveTit, , cTitpai)

							if lPLSTITPF
								PLSTITPF('SE1',cTitPai)
							endIf

							// Gera lançamento do ISS no SIGAPCO a partir do contas a receber
							If Upper(cOrigem) == "FINA040"
								PCODetLan("000001","08",Upper(cOrigem))
							EndIf
						Elseif !lGerAbtISS .and. nTotISS > 0 .And. nTotISS <= __nMinISS .And. Upper(cOrigem) != "MATA460"
							SE1->E1_VALOR+= nTotISS
							SE1->E1_SALDO+= nTotISS
						EndIf

					Else
						If (!lFINA460 .And. !(cOrigem = "FINA460" .And. Funname()="FINA740")) .And. (!lFINA630 .Or. lTrfISSf)

							Do Case
								Case __nDiaUtIss > 0 //Vencimento do ISS deve ser gerado por dias uteis.
									dVenISS	:=	LastDay(dEmissao)

									For nI:= 1 To __nDiaUtIss
										dVenISS ++
										dVenISS := DataValida(dVenISS)
									Next

								Case __cVencIss == "E"
									dVenISS := dEmissao
									dVenISS += 28
									If ( Month(dVenISS) == Month(dEmissao) )
										dVenISS := dVenISS + 28
									EndIf
									nTamData := Iif(Len(Dtoc(dVenISS)) == 10, 7, 5)
									dVenISS	:= Ctod(StrZero(__nDiaIss,2)+"/"+Subs(Dtoc(dVenISS),4,nTamData))
								Case __cVencIss == "Q" //Ultimo dia util da quinzena subsequente a dEmissao
									If Day(dEmissao) <= 15
										dVenISS	:= LastDay(dEmissao)
										dVenISS := DataValida(dVenISS,.F.)
									Else
										dVenISS := DataValida((LastDay(dEmissao)+1)+14,.F.)
									EndIf
								Case __cVencIss == "U" //Ultimo dia util do mes subsequente da dEmissao
									dVenISS := DataValida(LastDay(LastDay(dEmissao)+1),.F.)
								Case __cVencIss == "D"
									dVenISS := (LastDay(dEmissao)+1)
									nDiaUtil:= __nDiaIss
									For nDia := 1 To nDiaUtil-1
										If !(dVenISS == DataValida(dVenISS,.T.))
											nDia-=1
										EndIf
										dVenISS+=1
									Next nDia
								Case __cVencIss == "F" //Qtd de dia do parametro MV_DIAISS apos o fechamento da quinzena.
									If Day(dEmissao) <= 15
										dVenISS := CtoD("15"+SUBSTR(DtoC(dEmissao),3,Len(DtoC(dEmissao))))+__nDiaIss
									Else
										dVenISS := LastDay(dEmissao)+__nDiaIss
									EndIf
								OtherWise
									dVenISS := dVencto
									dVenISS += 28
									If ( Month(dVenISS) == Month(dVencto) )
										dVenISS := dVenISS+28
									EndIf
									nTamData := Iif(Len(Dtoc(dVenISS)) == 10, 7, 5)
									dVenISS	:= Ctod(StrZero(__nDiaIss,2)+"/"+Subs(Dtoc(dVenISS),4,nTamData))
							EndCase

							dbSelectArea("SE2")
							dbSetOrder(1)

							If "LOJ" $ cOrigem
								cParcela := SE2->E2_PARCELA
								nTamParc := Len(SE2->E2_PARCELA)
								While MSSeek(xFilial("SE2")+cPrefixo+cNum+cParcela+left(MVTAXA,3))
									cParcela := Soma1(cParcela,nTamParc)
								EndDo
							EndIf

							If __lVcAntIss == NIL
								__lVcAntIss	:= (SuperGetMV("MV_ANTVISS",.T.,"2") == "1")
							Endif

							dVencRIss := DataValida(dVenISS,IIF(__lVcAntIss,.F.,.T.))
							dVenISS := IIF(dVenIss > dVencRIss, dVencRISS, dVenIss)

							If Alltrim(SM0->M0_ESTENT) == "SC" .And. ;
							( ( Len( Alltrim( SM0->M0_CODMUN ) ) == 5 .And. Alltrim( SM0->M0_CODMUN ) == "09102" ) .Or. ( Len( Alltrim( SM0->M0_CODMUN ) ) == 7 .And. SubStr( Alltrim( SM0->M0_CODMUN ) , 3 , 5 ) == "09102" ) )
								aAreaFor:= getArea("SA1")
								DbSelectArea("SA1")
								DbSetOrder(1)
								If SA1->(DbSeek(xFilial("SA1")+cCliente+cLoja)) .And. Alltrim(SA1->A1_EST) == "SC"
									dVenISS := fCRetCal(6,dEmissao)
									dVencRIss := dVenISS
								EndIf
								restArea(aAreaFor)
							EndIf

							RecLock("SE2",.T.)
							SE2->E2_FILIAL	:= cFilial
							SE2->E2_PREFIXO := cPrefixo
							SE2->E2_NUM 	:= cNum
							SE2->E2_PARCELA := cParcela
							SE2->E2_TIPO	:= MVTAXA
							SE2->E2_EMISSAO := dEmissao
							SE2->E2_EMIS1	:= dDataBase
							SE2->E2_VALOR	:= nIss
							SE2->E2_VENCREA := dVencRIss
							SE2->E2_VENCTO  := dVenISS
							SE2->E2_SALDO	:= nIss
							SE2->E2_VENCORI := dVenISS
							SE2->E2_FORNECE := cMunIss
							SE2->E2_LOJA	:= cLojaImpos
							SE2->E2_NOMFOR  := SA2->A2_NREDUZ
							SE2->E2_MOEDA	:= If(__lLocBRA,1,nMoeda)
							SE2->E2_VLCRUZ	:= Round(SE2->E2_VALOR,MsDecimais(1))
							SE2->E2_ORIGEM  := Upper(cOrigem)
							SE2->E2_TITPAI 	:= cTitpai

							cNatureza:= &(SuperGetMV("MV_ISS"))
							SE2->E2_NATUREZ := Padr(cNatureza,__nTamNat)

							SE2->E2_LA      := cLA
							SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
							SE2->E2_CODAPRO	:= cCodAprov

							AADD(aRecImpos,{"SE2",Recno()})

							cChaveTit := xFilial("SE2", SE2->E2_FILORIG) + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" + ;
								SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
							FINGRVFK7("SE2", cChaveTit,, cTitpai, "SE1")

							//Gera lançamento do ISS no SIGAPCO a partir do contas a pagar
							If Upper(cOrigem) == "FINA040"
								PCODetLan("000001","13",Upper(cOrigem))
							EndIf
						Endif
					Endif
					MsUnLock()

					If ExistBlock("F040ISS")
						Execblock("F040ISS",.F.,.F.,nSavRec)
					EndIf
				EndIf

				//--------------------------------------
				//Bitributacao ISS
				//--------------------------------------
				If lValBtrISS

					dbSelectArea("SE1")
					dbSetOrder(1)

					cParcela := SE1->E1_PARCELA
					nTamParc := __nTamParc

					While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVISABT,3))
						cParcela := Soma1(cParcela,nTamParc)
					EndDo

					cNatureza:= &(SuperGetMV("MV_ISS"))

					RecLock("SE1",.T.)
					SE1->E1_FILIAL  := cFilSE1
					SE1->E1_PREFIXO := cPrefixo
					SE1->E1_NUM 	:= cNum
					SE1->E1_PARCELA := cParcela
					SE1->E1_NATUREZ := Padr(cNatureza,__nTamNat)
					SE1->E1_TIPO	:=  "I2-"
					SE1->E1_EMISSAO := dEmissao
					SE1->E1_VALOR	:= nbtrIss
					SE1->E1_VENCREA := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencRea)
					SE1->E1_SALDO	:= nbtrIss
					SE1->E1_VENCTO  := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencto)
					SE1->E1_VENCORI := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencto)
					SE1->E1_EMIS1	:= dDataBase
					SE1->E1_CLIENTE := cCliente
					SE1->E1_LOJA	:= cLoja
					SE1->E1_NOMCLI  := SA1->A1_NREDUZ
					SE1->E1_MOEDA	:= If(__lLocBRA,1,nMoeda)
					SE1->E1_VLCRUZ  := Round( nIss, MsDecimais(1) )
					SE1->E1_STATUS  := Iif(SE1->E1_SALDO>0.01,"A","B")
					SE1->E1_ORIGEM  := UPPER(cOrigem)
					SE1->E1_LA      := cLa
					SE1->E1_FATURA	:= cFatura
					SE1->E1_SITUACA := "0"
					SE1->E1_OCORREN := "04"
					SE1->E1_SITUACA := "0"
					SE1->E1_TXMOEDA := nTaxaTit
					SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
					SE1->E1_TITPAI  := cTitpai

					AADD(aRecImpos,{"SE1",Recno()})

					cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
						SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
					FINGRVFK7("SE1", cChaveTit, , cTitpai)

					SE1->(MsUnLock())

					if lPLSTITPF
						PLSTITPF('SE1',cTitPai)
					endIf

				Endif

				//-----------------------------------------------
				// Gera titulo Funrural
				//-----------------------------------------------
				If !lFunMR
					nValFun := Iif(Type("nValFun")=="U",0,nValFun)
					If ( nValFun > 0 ) .And. !lBorde

						If __lLocBRA
							If SED->(DbSeek(xFilial("SED")+cNatur))
								lRecFun	:=	If(SED->ED_RECFUN=="1",.T.,.F.) //cliente recolhe o imposto funrural
							Endif
						Endif

						If __cCSSNAT == NIL
							__cCSSNAT	:= PadR(SuperGetMV("MV_CSS",.F.,"CSS"),__nTamNat)
						Endif

						If __lNTFUNR == NIL
							__lNTFUNR 	:= ExistBlock("NTFUNR")
						Endif

						IF __lNTFUNR
							__cCSSNAT := ExecBlock("NTFUNR",.f.,.f.,{cOrigem,cPrefixo})
							__cCSSNAT := PADR( __cCSSNAT, __nTamNat )
						Endif

						// Cria a natureza FUNRURAL caso nao exista
						cNatureza := __cCSSNAT

						If !SED->(DbSeek(cFilial+__cCSSNAT))
							RecLock("SED",.T.)
							SED->ED_FILIAL  := cFilial
							SED->ED_CODIGO  := cNatureza
							SED->ED_CALCIRF := "N"
							SED->ED_CALCISS := "N"
							SED->ED_CALCINS := "N"
							SED->ED_CALCCSL := "N"
							SED->ED_CALCCOF := "N"
							SED->ED_CALCPIS := "N"
							SED->ED_DESCRIC := "CONTRIBUICAO SEGURIDADE SOCIAL"
							SED->ED_TIPO	:= "2"
							MsUnlock()
							FKCOMMIT()
						EndIf

						dVenFun := dEmissao + 28
						If Month(dVenFun) == Month(dEmissao)
							dVenFun := dVenFun+28
						EndIf
						nTamData := If(Len(Dtoc(dVenFun)) == 10, 7, 5)
						dVenFun	:= Ctod(StrZero(SuperGetMV("MV_DIAFUN"),2)+"/"+Subs(Dtoc(dVenFun),4,nTamData))
						dVencRea := DataValida(dVenFun,.F.)
						DbSelectArea("SA1")
						DbGoTo(nSalvCli)
						//Caso o cliente seja do tipo revendedor e a natureza esteja configurada para o cliente recolher o funrural
						//ou o tipo de cliente não seja L ou F deve ser gerado um titulo a receber para o imposto.
						//Porem se o cliente for do tipo revendedor e natureza esteja configurada para que o cliente não recolha o funrural
						//ou o tipo do cliente seja L ou F	deve ser gerado um titulo a pagar para o imposto.
						If (__lLocBRA .And. lRecFun .And. SM0->M0_PRODRUR $ "FL13" .and. SA1->A1_PESSOA == "J" .and. SA1->A1_TIPO == "R")

							//Busca a parcela Funrural de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA
							nTamParc := Len(SE1->E1_PARCELA)

							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVFUABT,3))
								cParcela := Soma1(cParcela,nTamParc)
							EndDo

							RecLock("SE1",.T.)
							SE1->E1_FILIAL  := cFilSE1
							SE1->E1_PREFIXO := cPrefixo
							SE1->E1_NUM 	:= cNum
							SE1->E1_PARCELA := cParcela
							SE1->E1_NATUREZ := cNatureza
							SE1->E1_TIPO	:= MVFUABT
							SE1->E1_EMISSAO := dEmissao
							SE1->E1_VALOR	:= nValFun
							SE1->E1_VENCREA := dEmissao
							SE1->E1_SALDO	:= nValFun
							SE1->E1_VENCTO  := dEmissao
							SE1->E1_VENCORI := dEmissao
							SE1->E1_EMIS1	:= dDataBase
							SE1->E1_CLIENTE := SA1->A1_COD
							SE1->E1_LOJA	:= SA1->A1_LOJA
							SE1->E1_NOMCLI  := SA1->A1_NREDUZ
							SE1->E1_MOEDA	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE1->E1_VLCRUZ  := Round( nValFun, MsDecimais(1) )
							SE1->E1_STATUS  := Iif(SE1->E1_SALDO>0.01,"A","B")
							SE1->E1_ORIGEM  := UPPER(cOrigem)
							SE1->E1_LA      := cLa
							SE1->E1_FATURA	:= cFatura
							SE1->E1_SITUACA := "0"
							SE1->E1_TXMOEDA := nTaxaTit
							SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
							SE1->E1_TITPAI  := cTitpai

							AADD(aRecImpos,{"SE1",Recno()})

							// Baixa do Saldo do cliente o valor do Funrural
							DbSelectArea("SA1")
							If ( MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA )) .And. lAtuSalDup
								If !lLojaDin
									AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
								EndIf
							EndIf

							AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

							MsUnLock()

							cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
								SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							FINGRVFK7("SE1", cChaveTit, , cTitpai)

							if lPLSTITPF
								PLSTITPF('SE1',cTitPai)
							endIf

						Else

							// Cria o fornecedor, caso nao exista
							DbSelectArea("SA2")
							DbSetOrder(1)
							If !(DbSeek(xFilial() + cCodMVINS + cLojaImpos))
								Reclock("SA2",.T.)
								SA2->A2_FILIAL := cFilial
								SA2->A2_COD 	:= cCodMVINS
								SA2->A2_LOJA	:= cLojaImpos
								SA2->A2_NOME	:= "Instituto Nacional de Previdencia Social"
								SA2->A2_NREDUZ := "INPS"
								SA2->A2_BAIRRO := "."
								SA2->A2_MUN 	:= "."
								SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
								SA2->A2_End 	:= "."
								SA2->A2_TIPO	:= "J"
								MsUnlock()
								FKCOMMIT()
							EndIf

							// Gera titulo para uniao, pois quando a venda é para pessoa fisica quem recolhe o funrural é quem vende
							DbSelectArea("SE2")
							RecLock("SE2",.T.)
							SE2->E2_FILIAL  := cFilial
							SE2->E2_PREFIXO := cPrefixo
							SE2->E2_NUM 	:= cNum
							SE2->E2_PARCELA := cParcela
							SE2->E2_NATUREZ := cNatureza
							SE2->E2_TIPO	:= MVTAXA
							SE2->E2_EMISSAO := dEmissao
							SE2->E2_VALOR	:= nValFun
							SE2->E2_VENCTO  := dVenFun
							SE2->E2_SALDO	:= nValFun
							SE2->E2_VENCREA := dVencRea
							SE2->E2_VENCORI := dVenFun
							SE2->E2_EMIS1	:= dDataBase
							SE2->E2_FORNECE := cCodMVINS
							SE2->E2_LOJA	:= cLojaImpos
							SE2->E2_NOMFOR  := SA2->A2_NREDUZ
							SE2->E2_MOEDA	:= If(__lLocBRA,1,nMoeda)
							SE2->E2_VLCRUZ	:= Round(SE2->E2_VALOR,MsDecimais(1))
							SE2->E2_ORIGEM  := Upper(cOrigem)
							SE2->E2_LA      := cLa
							SE2->E2_CODAPRO	:= cCodAprov
							SE2->E2_FILORIG := cFilAnt

							AADD(aRecImpos,{"SE2",Recno()})

							If __lM040CSSR == NIL
								__lM040CSSR	:= ExistBlock("M040CSSR")
							Endif

							If __lM040CSSR
								ExecBlock("M040CSSR",.F.,.F.)
							Endif

							MsUnlock()

							cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
								SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							FINGRVFK7("SE2", cChaveTit,, cTitpai, "SE1")

						EndIf
					EndIf
				EndIf

				If !lPccMR
					If lFina040 .And. __lCodRtPCC
						lCdRetInd := ( nPis <= 0 .Or. nCofins <= 0 .Or. nCsll <= 0 ) .And. M->E1_CODRET $ "5987|5960|5979"
					ElseIf __lLocBRA .And. __lCodRtPCC .And. Alltrim(FUNNAME()) $ "MATA460A_MATA461_MATA460"
						aPcc		:= newMinPcc(dRef, SE1->E1_VALOR,SE1->E1_NATUREZ,"R",SA1->A1_COD+SA1->A1_LOJA,nil,nil,nil,.F.,nil,nil)
						lCdRetInd	:= ( aPcc[2] <= 0 .Or. aPcc[3] <= 0 .Or. aPcc[4] <= 0 ) .And. SED->ED_PCCINDV == '1'
						If lCdRetInd
							If Alias() == "SE1"
								Replace E1_CODRET with "5952"
							EndIf
							nPis 	:= Iif( aPCC[2] <= nVRetPIS	, 0, aPCC[2] )
							nCofins	:= Iif( aPCC[3] <= nVRetCOF	, 0, aPCC[3] )
							nCsll	:= Iif( aPCC[4] <= nVRetCSLL, 0, aPCC[4] )
						EndIf
					EndIf

					// Caso nao exista os tres impostos, o codigo de retencao sera diferenciado para cada imposto
					If	lCdRetInd
						cCodRetPis := "5979"
						cCodRetCof := "5960"
						cCodRetCsl := "5987"
					Else
						// Se os 3 impostos juntos for maior que a media de retencao, o codigo sera o mesmo para os tres.
						If SE1->(E1_PIS+E1_COFINS+E1_CSLL) > ((__nVRetPIS+__nVRetCOF+__nVRetCSLL) / 3)
							cCodRetPis := "5952"
							cCodRetCof := "5952"
							cCodRetCsl := "5952"
						Endif
					Endif

					//-------------------------------------------------------------
					// Gera titulo de COFINS
					//-------------------------------------------------------------
					If ( nCofins > 0 .And. ((!__lPccBxCr .And. !lBorde ) .Or. (nBase061 > __nVlMinImp .Or.  lGeraTitMin )  ) )

						If lAbate

							// Busca a parcela Cofins de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA
							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVCFABT,3))
								cParcela := Soma1(cParcela,__nTamParc)
							EndDo

							RecLock("SE1",.T.)
							SE1->E1_FILIAL  := cFilSE1
							SE1->E1_PREFIXO := cPrefixo
							SE1->E1_NUM     := cNum
							SE1->E1_PARCELA := cParcela
							SE1->E1_EMISSAO := dEmissao
							SE1->E1_EMIS1   := dDataBase
							SE1->E1_VALOR   := nCofins
							SE1->E1_VENCTO  := dVencto
							SE1->E1_VENCREA := dVencRea
							SE1->E1_VENCORI := dVencto
							SE1->E1_CLIENTE := cCliente
							SE1->E1_LOJA    := cLoja
							SE1->E1_NOMCLI  := SA1->A1_NREDUZ
							SE1->E1_MOEDA   := If(__lLocBRA,1,nMoeda)
							SE1->E1_VLCRUZ  := Round(SE1->E1_VALOR,MsDecimais(1))
							SE1->E1_NATUREZ := __cCOFNAT
							SE1->E1_SITUACA := "0"

							If nBase061 > 0
								SE1->E1_STATUS  	:= "B"
								SE1->E1_ORIGEM		:= cOrigImp
								SE1->E1_PARCELA 	:= ParcImpRec(cPrefixo,cNum,"COF")
								SE1->E1_TIPO    	:= "COF"
								SE1->E1_SALDO		:= 0
								SE1->E1_OCORREN 	:= Space(2)
							Else
								SE1->E1_STATUS  	:= "A"
								SE1->E1_ORIGEM  	:= Upper(cOrigem)
								SE1->E1_PARCELA 	:= cParcela
								SE1->E1_TIPO    	:= MVCFABT
								SE1->E1_SALDO   	:= nCofins
								SE1->E1_OCORREN 	:= "04"
							Endif
							SE1->E1_LA      := cLa
							SE1->E1_FATURA  := cFatura
							SE1->E1_TXMOEDA := nTaxaTit
							SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
							SE1->E1_TITPAI  := cTitpai

							AADD(aRecImpos,{"SE1",Recno()})

							// Baixa do Saldo do cliente o valor do COFINS
							DbSelectArea("SA1")
							If ( MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA )) .And. lAtuSalDup
								If !lLojaDin
									AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
								EndIf
							EndIf

							AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

							cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
								SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							FINGRVFK7("SE1", cChaveTit, , cTitpai)

							if lPLSTITPF
								PLSTITPF('SE1',cTitPai)
							endIf

							lAbateuCOF := .T.

							If __lF040COF == NIL
								__lF040COF 	:= ExistBlock("F040COF")
							Endif

							If __lF040COF
								Execblock("F040COF",.F.,.F.,nSavRec)
							EndIf

							// Gera lançamento do COFINS no SIGAPCO a partir do contas a receber
							If Upper(cOrigem) == "FINA040"
								PCODetLan("000001","09",Upper(cOrigem))
							EndIf
						Else
							lAbateuCOF := .F.
						EndIf

					EndIf

					//---------------------------------------------------------------------
					// Gera titulo de PIS
					//---------------------------------------------------------------------
					If ( nPis > 0 .And. ( (!__lPccBxCr  .And. !lBorde)  .Or. (nBase061 > __nVlMinImp .Or. lGeraTitMin) ) )

						If lAbate

							//Busca a parcela PIS de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA

							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVPIABT,3))
								cParcela := Soma1(cParcela,__nTamParc)
							EndDo

							RecLock("SE1",.T.)
							SE1->E1_FILIAL  := cFilSE1
							SE1->E1_PREFIXO := cPrefixo
							SE1->E1_NUM     := cNum
							SE1->E1_EMISSAO := dEmissao
							SE1->E1_EMIS1   := dDataBase
							SE1->E1_VALOR   := nPis
							SE1->E1_VENCTO  := dVencto
							SE1->E1_VENCREA := dVencRea
							SE1->E1_VENCORI := dVencto
							SE1->E1_CLIENTE := cCliente
							SE1->E1_LOJA    := cLoja
							SE1->E1_NOMCLI  := SA1->A1_NREDUZ
							SE1->E1_MOEDA   := If(__lLocBRA,1,nMoeda)
							SE1->E1_VLCRUZ  := Round(SE1->E1_VALOR,MsDecimais(1))
							SE1->E1_NATUREZ := __cPISNAT

							If nBase061 > 0
								SE1->E1_STATUS  	:= "B"
								SE1->E1_ORIGEM		:= cOrigImp
								SE1->E1_PARCELA 	:= ParcImpRec(cPrefixo,cNum,"PIS")
								SE1->E1_TIPO    	:= "PIS"
								SE1->E1_SALDO   	:= 0
								SE1->E1_OCORREN   := Space(2)
							Else
								SE1->E1_STATUS  	:= "A"
								SE1->E1_ORIGEM  	:= Upper(cOrigem)
								SE1->E1_PARCELA 	:= cParcela
								SE1->E1_TIPO    	:= MVPIABT
								SE1->E1_SALDO   	:= nPis
								SE1->E1_OCORREN 	:= "04"
							Endif

							SE1->E1_SITUACA := "0"
							SE1->E1_LA      := cLa
							SE1->E1_FATURA	:= cFatura
							SE1->E1_TXMOEDA := nTaxaTit
							SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
							SE1->E1_TITPAI 	:= cTitpai

							AADD(aRecImpos,{"SE1",Recno()})

							// Baixa do Saldo do cliente o valor do PIS
							DbSelectArea("SA1")
							If ( MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA )) .And. lAtuSalDup
								If !lLojaDin
									AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
								EndIf
							EndIf

							AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))
							
							cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
								SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							FINGRVFK7("SE1", cChaveTit, , cTitpai)

							if lPLSTITPF
								PLSTITPF('SE1',cTitPai)
							endIf

							lAbateuPIS := .T.

							If __lF040PIS == NIL
								__lF040PIS 	:= ExistBlock("F040PIS")
							Endif

							If __lF040PIS
								Execblock("F040PIS",.F.,.F.,nSavRec)
							EndIf

							// Gera lançamento do PIS no SIGAPCO a partir do contas a receber
							If Upper(cOrigem) == "FINA040"
								PCODetLan("000001","10",Upper(cOrigem))
							EndIf

						Else
							lAbateuPIS := .F.
						EndIf

					EndIf

					//----------------------------------------------
					// Gera titulo de CSLL
					//----------------------------------------------
					If ( nCsll > 0 .And. ( (!__lPccBxCr .And. !lBorde) .Or. (nBase061 > __nVlMinImp .Or.  lGeraTitMin ) ) )

						If lAbate
							//Busca a parcela CSLL de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA

							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVCSABT,3))
								cParcela := Soma1(cParcela,__nTamParc)
							EndDo

							RecLock("SE1",.T.)
							SE1->E1_FILIAL  := cFilSE1
							SE1->E1_PREFIXO := cPrefixo
							SE1->E1_NUM     := cNum
							SE1->E1_EMISSAO := dEmissao
							SE1->E1_EMIS1   := dDataBase
							SE1->E1_VALOR   := nCsll
							SE1->E1_VENCTO  := dVencto
							SE1->E1_VENCREA := dVencRea
							SE1->E1_VENCORI := dVencto
							SE1->E1_CLIENTE := cCliente
							SE1->E1_LOJA    := cLoja
							SE1->E1_NOMCLI  := SA1->A1_NREDUZ
							SE1->E1_MOEDA   := If(__lLocBRA,1,nMoeda)
							SE1->E1_VLCRUZ  := Round(SE1->E1_VALOR,MsDecimais(1))
							SE1->E1_NATUREZ := __cCSLNAT

							If nBase061 > 0
								SE1->E1_STATUS  	:= "B"
								SE1->E1_ORIGEM		:= cOrigImp
								SE1->E1_TIPO    	:= "CSL"
								SE1->E1_PARCELA 	:= ParcImpRec(cPrefixo,cNum,"CSL")
								SE1->E1_SALDO   	:= 0
								SE1->E1_OCORREN 	:= Space(2)
							Else
								SE1->E1_STATUS  	:= "A"
								SE1->E1_ORIGEM  	:= Upper(cOrigem)
								SE1->E1_PARCELA 	:= cParcela
								SE1->E1_TIPO    	:= MVCSABT
								SE1->E1_SALDO   	:= nCsll
								SE1->E1_OCORREN 	:= "04"
							Endif

							SE1->E1_SITUACA := "0"
							SE1->E1_LA      := cLa
							SE1->E1_FATURA	:= cFatura
							SE1->E1_TXMOEDA := nTaxaTit
							SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
							SE1->E1_TITPAI  := cTitpai

							AADD(aRecImpos,{"SE1",Recno()})

							//Baixa do Saldo do cliente o valor do csll
							DbSelectArea("SA1")
							If ( MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA )) .And. lAtuSalDup
								If !lLojaDin
									AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
								EndIf
							EndIf

							AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

							cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
								SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							FINGRVFK7("SE1", cChaveTit, , cTitpai)

							if lPLSTITPF
								PLSTITPF('SE1',cTitPai)
							endIf

							lAbateuCSLL := .T.

							If __lF040CSL == NIL
								__lF040CSL 	:= ExistBlock("F040CSL")
							Endif

							If __lF040CSL
								Execblock("F040CSL",.F.,.F.,nSavRec)
							EndIf

							//Gera lançamento do CSLL no SIGAPCO a partir do contas a receber
							If Upper(cOrigem) == "FINA040"
								PCODetLan("000001","11",Upper(cOrigem))
							EndIf

						Else
							lAbateuCSLL := .F.
						EndIf
					EndIf
				EndIf

				//--------------------------------------------------------
				//Titulo do FETHAB
				//--------------------------------------------------------
				If __lAgFETHA

					If !lFetMR

						//Aglutina titulos do FETHAB
						If nFethab > 0  .And. !lBorde
							If cPaisLoc == "BRA" .And. SA1->A1_RECFET=="2" .And. Iif( "FIN" $ FunName(),SA1->A1_RECFET=="2",nValFetR == 0)
								//Cria o Fornecedor, caso nao exista
								DbSelectArea("SA2")
								SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
								If ( EOF() )
									Reclock("SA2",.T.)
									SA2->A2_FILIAL	:= cFilial
									SA2->A2_COD 	:= cCodMVRES
									SA2->A2_LOJA	:= cLojaImpos
									SA2->A2_NOME	:= "RECEITA ESTADUAL"
									SA2->A2_NREDUZ	:= "RECEITA"
									SA2->A2_BAIRRO	:= "."
									SA2->A2_MUN 	:= "."
									SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
									SA2->A2_End 	:= "."
									SA2->A2_TIPO	:= "J"
									MsUnlock()
								EndIf
								DbSelectArea("SE2")
								SE2->(DbSetOrder(1))
								aTamParcI := TamSx3("E2_PARCELA")
								cParcFet  := StrZero(1,aTamParcI[1])
								While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFet + MVTAXA + PadR(cCodMVRES,__nTamFor) + cLojaImpos)
									cParcFet := Soma1(cParcFet,aTamParcI[1])
								EndDo

								RecLock("SE2",.T.)
								SE2->E2_FILIAL 	:= cFilial
								SE2->E2_FILORIG := cFilAnt
								SE2->E2_PREFIXO	:= cPrefixo
								SE2->E2_NUM    	:= cNum
								SE2->E2_PARCELA	:= cParcFet
								SE2->E2_TIPO 	:= MVTAXA
								SE2->E2_EMISSAO	:= dEmissao
								SE2->E2_EMIS1  	:= dDataBase
								SE2->E2_VALOR  	:= nFethab+nFabov+nFacs+nFamad
								SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
								SE2->E2_SALDO  	:= nFethab+nFabov+nFacs+nFamad
								SE2->E2_VENCREA	:= DTVenIcms()
								SE2->E2_VENCORI	:= dEmissao
								SE2->E2_FORNECE	:= cCodMVRES
								SE2->E2_LOJA   	:= cLojaImpos
								SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
								SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
								SE2->E2_VLCRUZ 	:= Round(nFethab+nFabov+nFacs+nFamad, MsDecimais(1) )
								SE2->E2_ORIGEM 	:= Upper(cOrigem)
								cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
								IF ExistBlock("NTFETHAB")
									cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
								Endif
								SE2->E2_NATUREZ	:= Alltrim(cNatureza)
								SE2->E2_CODAPRO	:= cCodAprov
								MsUnLock()
								
								FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA, , cTitpai, "SE1")

								AADD(aRecImpos,{"SE2",Recno()})

								//Gravar a parcela do Fethab no titulo principal
								DbSelectArea("SE1")
								SE1->(DbGoTo(nSavRec))
								RecLock("SE1",.F.)
								SE1->E1_PARCFET	:= cParcFet
								MsUnLock()

								//Cria a natureza Fethab caso nao exista
								DbSelectArea("SED")
								If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
									RecLock("SED",.T.)
									SED->ED_FILIAL  := cFilial
									SED->ED_CODIGO  := cNatureza
									SED->ED_CALCIRF := "N"
									SED->ED_CALCISS := "N"
									SED->ED_CALCINS := "N"
									SED->ED_CALCCSL := "N"
									SED->ED_CALCCOF := "N"
									SED->ED_CALCPIS := "N"
									SED->ED_DESCRIC := "FETHAB"
									SED->ED_TIPO	:= "2"
									MsUnlock()
								EndIf
							Else
								//Busca a parcela Fethab de acordo com o titulo
								dbSelectArea("SE1")
								dbSetOrder(1)

								cParcela := SE1->E1_PARCELA
								nTamParc := Len(SE1->E1_PARCELA)
								While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FE-")
									cParcela := Soma1(cParcela,nTamParc)
								EndDo

								RecLock("SE1",.T.)
								SE1->E1_FILIAL	:= cFilSE1
								SE1->E1_FILORIG := cFilAnt
								SE1->E1_PREFIXO	:= cPrefixo
								SE1->E1_NUM 	:= cNum
								SE1->E1_PARCELA	:= cParcela
								SE1->E1_TIPO   	:= "FE-"
								SE1->E1_EMISSAO	:= dEmissao
								SE1->E1_EMIS1  	:= dDataBase
								SE1->E1_VALOR  	:= nFetHab+nFabov+nFacs+nFamad
								SE1->E1_VENCTO 	:= dVencto
								SE1->E1_SALDO  	:= nFethab+nFabov+nFacs+nFamad
								SE1->E1_VENCREA	:= dVencRea
								SE1->E1_VENCORI	:= dVencto
								SE1->E1_CLIENTE	:= cCliente
								SE1->E1_LOJA   	:= cLoja
								SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
								SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
								SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
								SE1->E1_ORIGEM 	:= Upper(cOrigem)
								cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
								IF ExistBlock("NTFETHAB")
									cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
								Endif
								SE1->E1_NATUREZ	:= Alltrim(cNatureza)
								SE1->E1_STATUS 	:= "A"
								SE1->E1_SITUACA	:= "0"
								SE1->E1_OCORREN	:= "04"
								SE1->E1_LA     	:= cLa
								SE1->E1_FATURA	:= cFatura
								SE1->E1_TITPAI  := cTitPai

								AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

								AADD(aRecImpos,{"SE1",Recno()})

								cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
									SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
								FINGRVFK7("SE1", cChaveTit, , cTitpai)

								if lPLSTITPF
									PLSTITPF('SE1',cTitPai)
								endIf

								//Cria a natureza Fethab caso nao exista
								DbSelectArea("SED")
								cNatureza := AllTrim(cNatureza)
								If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
									RecLock("SED",.T.)
									SED->ED_FILIAL  := cFilial
									SED->ED_CODIGO  := cNatureza
									SED->ED_CALCIRF := "N"
									SED->ED_CALCISS := "N"
									SED->ED_CALCINS := "N"
									SED->ED_CALCCSL := "N"
									SED->ED_CALCCOF := "N"
									SED->ED_CALCPIS := "N"
									SED->ED_DESCRIC := "FETHAB"
									SED->ED_TIPO	:= "2"
								EndIf

								If ExistBlock("F040FET")
									Execblock("F040FET",.F.,.F.,nSavRec)
								Endif

							Endif
						EndIf
					EndIf
				Else
					If !lFetMR

						If nFethab > 0 .And. !lBorde
							If cPaisLoc == "BRA" .And. SA1->A1_RECFET=="2" .And. Iif( "FIN" $ FunName(),SA1->A1_RECFET=="2",nValFetR == 0)
								//Cria o Fornecedor, caso nao exista
								DbSelectArea("SA2")
								SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
								If ( EOF() )
									Reclock("SA2",.T.)
									SA2->A2_FILIAL	:= cFilial
									SA2->A2_COD 	:= cCodMVRES
									SA2->A2_LOJA	:= cLojaImpos
									SA2->A2_NOME	:= "RECEITA ESTADUAL"
									SA2->A2_NREDUZ	:= "RECEITA"
									SA2->A2_BAIRRO	:= "."
									SA2->A2_MUN 	:= "."
									SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
									SA2->A2_End 	:= "."
									SA2->A2_TIPO	:= "J"
									MsUnlock()
								EndIf
								DbSelectArea("SE2")
								SE2->(DbSetOrder(1))
								aTamParcI := TamSx3("E2_PARCELA")
								cParcFet  := StrZero(1,aTamParcI[1])
								While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFet + MVTAXA + PadR(cCodMVRES,__nTamFor) + cLojaImpos)
									cParcFet := Soma1(cParcFet,aTamParcI[1])
								EndDo

								RecLock("SE2",.T.)
								SE2->E2_FILIAL 	:= cFilial
								SE2->E2_FILORIG := cFilAnt
								SE2->E2_PREFIXO	:= cPrefixo
								SE2->E2_NUM    	:= cNum
								SE2->E2_PARCELA	:= cParcFet
								SE2->E2_TIPO 	:= MVTAXA
								SE2->E2_EMISSAO	:= dEmissao
								SE2->E2_EMIS1  	:= dDataBase
								SE2->E2_VALOR  	:= nFethab
								SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
								SE2->E2_SALDO  	:= nFethab
								SE2->E2_VENCREA	:= DTVenIcms()
								SE2->E2_VENCORI	:= dEmissao
								SE2->E2_FORNECE	:= cCodMVRES
								SE2->E2_LOJA   	:= cLojaImpos
								SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
								SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
								SE2->E2_VLCRUZ 	:= Round(nFethab, MsDecimais(1) )
								SE2->E2_ORIGEM 	:= Upper(cOrigem)
								cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
								IF ExistBlock("NTFETHAB")
									cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
								Endif
								SE2->E2_NATUREZ	:= Alltrim(cNatureza)
								SE2->E2_CODAPRO	:= cCodAprov
								MsUnLock()

								FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA, , cTitpai, "SE1")

								AADD(aRecImpos,{"SE2",Recno()})

								//Gravar a parcela do Fethab no titulo principal
								DbSelectArea("SE1")
								SE1->(DbGoTo(nSavRec))
								RecLock("SE1",.F.)
								SE1->E1_PARCFET	:= cParcFet
								MsUnLock()

								//Cria a natureza Fethab caso nao exista
								DbSelectArea("SED")
								If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
									RecLock("SED",.T.)
									SED->ED_FILIAL  := cFilial
									SED->ED_CODIGO  := cNatureza
									SED->ED_CALCIRF := "N"
									SED->ED_CALCISS := "N"
									SED->ED_CALCINS := "N"
									SED->ED_CALCCSL := "N"
									SED->ED_CALCCOF := "N"
									SED->ED_CALCPIS := "N"
									SED->ED_DESCRIC := "FETHAB"
									SED->ED_TIPO	:= "2"
									MsUnlock()
								EndIf
							Else
								//Busca a parcela Fethab de acordo com o titulo
								dbSelectArea("SE1")
								dbSetOrder(1)

								cParcela := SE1->E1_PARCELA
								nTamParc := Len(SE1->E1_PARCELA)
								While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FE-")
									cParcela := Soma1(cParcela,nTamParc)
								EndDo

								RecLock("SE1",.T.)
								SE1->E1_FILIAL	:= cFilSE1
								SE1->E1_FILORIG := cFilAnt
								SE1->E1_PREFIXO	:= cPrefixo
								SE1->E1_NUM 	:= cNum
								SE1->E1_PARCELA	:= cParcela
								SE1->E1_TIPO   	:= "FE-"
								SE1->E1_EMISSAO	:= dEmissao
								SE1->E1_EMIS1  	:= dDataBase
								SE1->E1_VALOR  	:= nFetHab
								SE1->E1_VENCTO 	:= dVencto
								SE1->E1_SALDO  	:= nFethab
								SE1->E1_VENCREA	:= dVencRea
								SE1->E1_VENCORI	:= dVencto
								SE1->E1_CLIENTE	:= cCliente
								SE1->E1_LOJA   	:= cLoja
								SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
								SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
								SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
								SE1->E1_ORIGEM 	:= Upper(cOrigem)
								cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
								IF ExistBlock("NTFETHAB")
									cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
								Endif
								SE1->E1_NATUREZ	:= Alltrim(cNatureza)
								SE1->E1_STATUS 	:= "A"
								SE1->E1_SITUACA	:= "0"
								SE1->E1_OCORREN	:= "04"
								SE1->E1_LA     	:= cLa
								SE1->E1_FATURA	:= cFatura
								SE1->E1_TITPAI  := cTitPai

								AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

								AADD(aRecImpos,{"SE1",Recno()})

								cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
									SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
								FINGRVFK7("SE1", cChaveTit, , cTitpai)

								if lPLSTITPF
									PLSTITPF('SE1',cTitPai)
								endIf

								//Cria a natureza Fethab caso nao exista
								DbSelectArea("SED")
								cNatureza := AllTrim(cNatureza)
								If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
									RecLock("SED",.T.)
									SED->ED_FILIAL  := cFilial
									SED->ED_CODIGO  := cNatureza
									SED->ED_CALCIRF := "N"
									SED->ED_CALCISS := "N"
									SED->ED_CALCINS := "N"
									SED->ED_CALCCSL := "N"
									SED->ED_CALCCOF := "N"
									SED->ED_CALCPIS := "N"
									SED->ED_DESCRIC := "FETHAB"
									SED->ED_TIPO	:= "2"
								EndIf
								If ExistBlock("F040FET")
									Execblock("F040FET",.F.,.F.,nSavRec)
								Endif
							Endif
						EndIf
					EndIf

					//----------------------------------------------
					//Titulo do FABOV
					//----------------------------------------------
					If !lFabMR
						If nFabov > 0 .And. !lBorde
							If SA1->A1_RFABOV == "2"
								//Cria o Fornecedor, caso nao exista
								DbSelectArea("SA2")
								SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
								If ( EOF() )
									Reclock("SA2",.T.)
									SA2->A2_FILIAL	:= cFilial
									SA2->A2_COD 	:= cCodMVRES
									SA2->A2_LOJA	:= cLojaImpos
									SA2->A2_NOME	:= "RECEITA ESTADUAL"
									SA2->A2_NREDUZ	:= "RECEITA"
									SA2->A2_BAIRRO	:= "."
									SA2->A2_MUN 	:= "."
									SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
									SA2->A2_End 	:= "."
									SA2->A2_TIPO	:= "J"
									MsUnlock()
								EndIf

								DbSelectArea("SE2")
								SE2->(DbSetOrder(1))
								aTamParcI := TamSx3("E2_PARCELA")
								cParcFab  := StrZero(1,aTamParcI[1])
								While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFab + MVTAXA + PadR(cCodMVRES,__nTamFor) + cLojaImpos)
									cParcFab := Soma1(cParcFab,aTamParcI[1])
								EndDo

								RecLock("SE2",.T.)
								SE2->E2_FILIAL 	:= cFilial
								SE2->E2_FILORIG := cFilAnt
								SE2->E2_PREFIXO	:= cPrefixo
								SE2->E2_NUM    	:= cNum
								SE2->E2_PARCELA	:= cParcFab
								SE2->E2_TIPO 	:= MVTAXA
								SE2->E2_EMISSAO	:= dEmissao
								SE2->E2_EMIS1  	:= dDataBase
								SE2->E2_VALOR  	:= nFabov
								SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
								SE2->E2_SALDO  	:= nFabov
								SE2->E2_VENCREA	:= DTVenIcms()
								SE2->E2_VENCORI	:= dEmissao
								SE2->E2_FORNECE	:= cCodMVRES
								SE2->E2_LOJA   	:= cLojaImpos
								SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
								SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
								SE2->E2_VLCRUZ 	:= Round(nFabov, MsDecimais(1) )
								SE2->E2_ORIGEM 	:= Upper(cOrigem)
								cNatureza      	:= SuperGetMV("MV_FABNAT",.F.,"FABOV")
								SE2->E2_NATUREZ	:= Alltrim(cNatureza)
								SE2->E2_CODAPRO	:= cCodAprov
								MsUnLock()
								AADD(aRecImpos,{"SE2",Recno()})

								FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA, , cTitpai, "SE1")

								//Gravar a parcela do Fabov no titulo principal
								DbSelectArea("SE1")
								SE1->(DbGoTo(nSavRec))
								RecLock("SE1",.F.)
								SE1->E1_PARCFAB	:= cParcFab
								MsUnLock()

								//Cria a natureza Fabov caso nao exista
								DbSelectArea("SED")
								If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
									RecLock("SED",.T.)
									SED->ED_FILIAL  := cFilial
									SED->ED_CODIGO  := cNatureza
									SED->ED_CALCIRF := "N"
									SED->ED_CALCISS := "N"
									SED->ED_CALCINS := "N"
									SED->ED_CALCCSL := "N"
									SED->ED_CALCCOF := "N"
									SED->ED_CALCPIS := "N"
									SED->ED_DESCRIC := "FABOV"
									SED->ED_TIPO	:= "2"
									MsUnlock()
								EndIf
							Else
								//Busca a parcela Fabov de acordo com o titulo
								dbSelectArea("SE1")
								dbSetOrder(1)

								cParcela := SE1->E1_PARCELA
								nTamParc := Len(SE1->E1_PARCELA)
								While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FB-")
									cParcela := Soma1(cParcela,nTamParc)
								EndDo

								RecLock("SE1",.T.)
								SE1->E1_FILIAL	:= cFilSE1
								SE1->E1_PREFIXO	:= cPrefixo
								SE1->E1_NUM 	:= cNum
								SE1->E1_PARCELA	:= cParcela
								SE1->E1_TIPO   	:= "FB-"
								SE1->E1_EMISSAO	:= dEmissao
								SE1->E1_EMIS1  	:= dDataBase
								SE1->E1_VALOR  	:= nFabov
								SE1->E1_VENCTO 	:= dVencto
								SE1->E1_SALDO  	:= nFabov
								SE1->E1_VENCREA	:= dVencRea
								SE1->E1_VENCORI	:= dVencto
								SE1->E1_CLIENTE	:= cCliente
								SE1->E1_LOJA   	:= cLoja
								SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
								SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
								SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
								SE1->E1_ORIGEM 	:= Upper(cOrigem)
								cNatureza      	:= SuperGetMV("MV_FABNAT",.F.,"FABOV")
								SE1->E1_NATUREZ	:= Alltrim(cNatureza)
								SE1->E1_STATUS 	:= "A"
								SE1->E1_SITUACA	:= "0"
								SE1->E1_OCORREN	:= "04"
								SE1->E1_LA     	:= cLa
								SE1->E1_FATURA	:= cFatura
								SE1->E1_TITPAI 	:= cTitPai
								SE1->E1_FILORIG	:= cFilAnt

								AADD(aRecImpos,{"SE1",Recno()})

								cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
									SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
								FINGRVFK7("SE1", cChaveTit, , cTitpai)

								if lPLSTITPF
									PLSTITPF('SE1',cTitPai)
								endIf

								//Cria a natureza Fabov caso nao exista
								DbSelectArea("SED")
								cNatureza := AllTrim(cNatureza)
								If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
									RecLock("SED",.T.)
									SED->ED_FILIAL  := cFilial
									SED->ED_CODIGO  := cNatureza
									SED->ED_CALCIRF := "N"
									SED->ED_CALCISS := "N"
									SED->ED_CALCINS := "N"
									SED->ED_CALCCSL := "N"
									SED->ED_CALCCOF := "N"
									SED->ED_CALCPIS := "N"
									SED->ED_DESCRIC := "FABOV"
									SED->ED_TIPO	:= "2"
								EndIf
								If ExistBlock("F040FAB")
									Execblock("F040FAB",.F.,.F.,nSavRec)
								Endif
							Endif
						EndIf
					EndIf

					If !lFacMR
						//---------------------------------------------
						//Titulo do FACS
						//---------------------------------------------
						If nFacs > 0 .And. !lBorde
							If cPaisLoc == "BRA" .And. SA1->A1_RFACS == "2"

								//Cria o Fornecedor, caso nao exista
								DbSelectArea("SA2")
								SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
								If ( EOF() )
									Reclock("SA2",.T.)
									SA2->A2_FILIAL	:= cFilial
									SA2->A2_COD 	:= cCodMVRES
									SA2->A2_LOJA	:= cLojaImpos
									SA2->A2_NOME	:= "RECEITA ESTADUAL"
									SA2->A2_NREDUZ	:= "RECEITA"
									SA2->A2_BAIRRO	:= "."
									SA2->A2_MUN 	:= "."
									SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
									SA2->A2_End 	:= "."
									SA2->A2_TIPO	:= "J"
									MsUnlock()
								EndIf

								DbSelectArea("SE2")
								SE2->(DbSetOrder(1))
								aTamParcI := TamSx3("E2_PARCELA")
								cParcFac  := StrZero(1,aTamParcI[1])
								While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFac + MVTAXA + PadR(cCodMVRES,__nTamFor) + cLojaImpos)
									cParcFac := Soma1(cParcFac,aTamParcI[1])
								EndDo

								RecLock("SE2",.T.)
								SE2->E2_FILIAL 	:= cFilial
								SE2->E2_FILORIG := cFilAnt
								SE2->E2_PREFIXO	:= cPrefixo
								SE2->E2_NUM    	:= cNum
								SE2->E2_PARCELA	:= cParcFac
								SE2->E2_TIPO 	:= MVTAXA
								SE2->E2_EMISSAO	:= dEmissao
								SE2->E2_EMIS1  	:= dDataBase
								SE2->E2_VALOR  	:= nFacs
								SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
								SE2->E2_SALDO  	:= nFacs
								SE2->E2_VENCREA	:= DTVenIcms()
								SE2->E2_VENCORI	:= dEmissao
								SE2->E2_FORNECE	:= cCodMVRES
								SE2->E2_LOJA   	:= cLojaImpos
								SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
								SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
								SE2->E2_VLCRUZ 	:= Round(nFacs, MsDecimais(1) )
								SE2->E2_ORIGEM 	:= Upper(cOrigem)
								cNatureza      	:= SuperGetMV("MV_FACNAT",.F.,"FACS")
								SE2->E2_NATUREZ	:= Alltrim(cNatureza)
								SE2->E2_CODAPRO	:= cCodAprov
								MsUnLock()
								AADD(aRecImpos,{"SE2",Recno()})

								FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA, , cTitpai, "SE1")

								//Gravar a parcela do Facs no titulo principal
								DbSelectArea("SE1")
								SE1->(DbGoTo(nSavRec))
								RecLock("SE1",.F.)
								SE1->E1_PARCFAC	:= cParcFac
								MsUnLock()

								//Cria a natureza Facs caso nao exista
								DbSelectArea("SED")
								If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
									RecLock("SED",.T.)
									SED->ED_FILIAL  := cFilial
									SED->ED_CODIGO  := cNatureza
									SED->ED_CALCIRF := "N"
									SED->ED_CALCISS := "N"
									SED->ED_CALCINS := "N"
									SED->ED_CALCCSL := "N"
									SED->ED_CALCCOF := "N"
									SED->ED_CALCPIS := "N"
									SED->ED_DESCRIC := "FACS"
									SED->ED_TIPO	:= "2"
									MsUnlock()
								EndIf
							Else
								//Busca a parcela Facs de acordo com o titulo
								dbSelectArea("SE1")
								dbSetOrder(1)

								cParcela := SE1->E1_PARCELA
								nTamParc := Len(SE1->E1_PARCELA)
								While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FC-")
									cParcela := Soma1(cParcela,nTamParc)
								EndDo

								RecLock("SE1",.T.)
								SE1->E1_FILIAL	:= cFilSE1
								SE1->E1_FILORIG := cFilAnt
								SE1->E1_PREFIXO	:= cPrefixo
								SE1->E1_NUM 	:= cNum
								SE1->E1_PARCELA	:= cParcela
								SE1->E1_TIPO   	:= "FC-"
								SE1->E1_EMISSAO	:= dEmissao
								SE1->E1_EMIS1  	:= dDataBase
								SE1->E1_VALOR  	:= nFacs
								SE1->E1_VENCTO 	:= dVencto
								SE1->E1_SALDO  	:= nFacs
								SE1->E1_VENCREA	:= dVencRea
								SE1->E1_VENCORI	:= dVencto
								SE1->E1_CLIENTE	:= cCliente
								SE1->E1_LOJA   	:= cLoja
								SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
								SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
								SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
								SE1->E1_ORIGEM 	:= Upper(cOrigem)
								cNatureza      	:= SuperGetMV("MV_FACNAT",.F.,"FACS")
								SE1->E1_NATUREZ	:= Alltrim(cNatureza)
								SE1->E1_STATUS 	:= "A"
								SE1->E1_SITUACA	:= "0"
								SE1->E1_OCORREN	:= "04"
								SE1->E1_LA     	:= cLa
								SE1->E1_FATURA	:= cFatura
								SE1->E1_TITPAI	:= cTitPai

								AADD(aRecImpos,{"SE1",Recno()})

								cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
									SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
								FINGRVFK7("SE1", cChaveTit, , cTitpai)

								if lPLSTITPF
									PLSTITPF('SE1',cTitPai)
								endIf

								// Cria a natureza Facs caso nao exista
								DbSelectArea("SED")
								cNatureza := AllTrim(cNatureza)
								If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
									RecLock("SED",.T.)
									SED->ED_FILIAL  := cFilial
									SED->ED_CODIGO  := cNatureza
									SED->ED_CALCIRF := "N"
									SED->ED_CALCISS := "N"
									SED->ED_CALCINS := "N"
									SED->ED_CALCCSL := "N"
									SED->ED_CALCCOF := "N"
									SED->ED_CALCPIS := "N"
									SED->ED_DESCRIC := "FACS"
									SED->ED_TIPO	:= "2"
								EndIf
								If ExistBlock("F040FAC")
									Execblock("F040FAC",.F.,.F.,nSavRec)
								EndIf
							EndIf
						EndIf
					EndIf
					//-------------------------------------------------------------
					// titulo do FAMAD
					//-------------------------------------------------------------
					If !lFamadMR .AND. lFamad .and. nFamad > 0 .And. !lBorde

						If SA1->(FieldPos("A1_RECFMD"))>0 .And. SA1->A1_RECFMD != "1"
							// Cria o Fornecedor, caso nao exista
							DbSelectArea("SA2")
							SA2->(DbSeek(xFilial("SA2")+GetMV("MV_RECEST")+Space(Len(A2_COD)-Len(GetMV("MV_RECEST")))+cLojaImpos))
							If ( EOF() )
								Reclock("SA2",.T.)
								SA2->A2_FILIAL	:= xFilial("SA2")
								SA2->A2_COD 	:= GetMV("MV_RECEST")
								SA2->A2_LOJA	:= cLojaImpos
								SA2->A2_NOME	:= "RECEITA ESTADUAL"
								SA2->A2_NREDUZ	:= "RECEITA"
								SA2->A2_BAIRRO	:= "."
								SA2->A2_MUN 	:= "."
								SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
								SA2->A2_End 	:= "."
								SA2->A2_TIPO	:= "J"
								MsUnlock()
							EndIf

							DbSelectArea("SE2")
							SE2->(DbSetOrder(1))
							aTamParcI := TamSx3("E2_PARCELA")
							cParcFam  := StrZero(1,aTamParcI[1])
							nTamFor	:= TamSx3("E2_FORNECE")[1]
							While MSSeek(xFilial("SE2")+cPrefixo+cNum+cParcFam+MVTAXA+PadR(GetMv("MV_RECEST"),nTamFor)+cLojaImpos)
								cParcFam := Soma1(cParcFam,aTamParcI[1])
							EndDo

							RecLock("SE2",.T.)
							SE2->E2_FILIAL 	:= cFilial
							SE2->E2_PREFIXO	:= cPrefixo
							SE2->E2_NUM    	:= cNum
							SE2->E2_PARCELA	:= cParcFam
							SE2->E2_TIPO 	:= MVTAXA
							SE2->E2_EMISSAO	:= dEmissao
							SE2->E2_EMIS1  	:= dDataBase
							SE2->E2_VALOR  	:= nFamad
							SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
							SE2->E2_SALDO  	:= nFamad
							SE2->E2_VENCREA	:= DTVenIcms()
							SE2->E2_VENCORI	:= dEmissao
							SE2->E2_FORNECE	:= GetMv("MV_RECEST")
							SE2->E2_LOJA   	:= cLojaImpos
							SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
							SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE2->E2_VLCRUZ 	:= Round(nFamad, MsDecimais(1) )
							SE2->E2_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_FAMNAT",.F.,"FAMAD")
							SE2->E2_NATUREZ	:= Alltrim(cNatureza)
							SE2->E2_FILORIG	:= cFilAnt
							MsUnLock()

							FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA, , cTitpai, "SE1")

							AADD(aRecImpos,{"SE2",Recno()})

							//Gravar a parcela do Famad no titulo principal
							DbSelectArea("SE1")
							If SE1->(FieldPos("E1_PARCFAM")>0)
								SE1->(DbGoTo(nSavRec))
								RecLock("SE1",.F.)
								SE1->E1_PARCFAM	:= cParcFam
								MsUnLock()
							Endif

							// Cria a natureza Famad caso nao exista
							DbSelectArea("SED")
							If !SED->(DbSeek(xFilial("SED")+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := xFilial("SED")
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "FAMAD"
								SED->ED_TIPO	:= "2"
								MsUnlock()
							EndIf
						Else
							// Busca a parcela Fabov de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA
							nTamParc := Len(SE1->E1_PARCELA)
							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FM-")
								cParcela := Soma1(cParcela,nTamParc)
							EndDo

							RecLock("SE1",.T.)
							SE1->E1_FILIAL	:= cFilial
							SE1->E1_PREFIXO	:= cPrefixo
							SE1->E1_NUM 	:= cNum
							SE1->E1_PARCELA	:= cParcela
							SE1->E1_TIPO   	:= "FM-"
							SE1->E1_EMISSAO	:= dEmissao
							SE1->E1_EMIS1  	:= dDataBase
							SE1->E1_VALOR  	:= nFamad
							SE1->E1_VENCTO 	:= dVencto
							SE1->E1_SALDO  	:= nFamad
							SE1->E1_VENCREA	:= dVencRea
							SE1->E1_VENCORI	:= dVencto
							SE1->E1_CLIENTE	:= cCliente
							SE1->E1_LOJA   	:= cLoja
							SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
							SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
							SE1->E1_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_FAMNAT",.F.,"FAMAD")
							SE1->E1_NATUREZ	:= Alltrim(cNatureza)
							SE1->E1_STATUS 	:= "A"
							SE1->E1_SITUACA	:= "0"
							SE1->E1_OCORREN	:= "04"
							SE1->E1_LA     	:= cLa
							SE1->E1_FATURA	:= cFatura
							SE1->E1_FILORIG	:= cFilAnt

							SE1->E1_TITPAI := cTitPai

							AADD(aRecImpos,{"SE1",Recno()})

							cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
								SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							FINGRVFK7("SE1", cChaveTit, , cTitpai)

							//Cria a natureza FAMAD caso nao exista
							DbSelectArea("SED")
							cNatureza := AllTrim(cNatureza)
							If !SED->(DbSeek(xFilial("SED")+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := xFilial("SED")
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "FAMAD"
								SED->ED_TIPO	:= "2"
							EndIf
							If ExistBlock("F040FAM")
								Execblock("F040FAM",.F.,.F.,nSavRec)
							Endif
						Endif
					EndIf
				EndIf //If lAgFETHA

				If !lTpdMR
					//---------------------------------------
					// titulo do Imposto IMA
					//---------------------------------------
					If nIma > 0 .And. !lBorde

						lCposIMA := __lCposIMA
						nTamFor := __nTamFor

						If __lLocBRA .And. SA1->A1_RIMAMT == "2"
							// Cria o Fornecedor, caso nao exista
							DbSelectArea("SA2")
							SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
							If ( EOF() )
								Reclock("SA2",.T.)
								SA2->A2_FILIAL 	:= cFilial
								SA2->A2_COD 	:= cCodMVRES
								SA2->A2_LOJA	:= cLojaImpos
								SA2->A2_NOME	:= "RECEITA ESTADUAL"
								SA2->A2_NREDUZ	:= "RECEITA"
								SA2->A2_BAIRRO 	:= "."
								SA2->A2_MUN 	:= "."
								SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
								SA2->A2_End 	:= "."
								SA2->A2_TIPO	:= "J"
								MsUnlock()
							EndIf

							DbSelectArea("SE2")
							SE2->(DbSetOrder(1))
							aTamParcI := TamSx3("E2_PARCELA")
							cParcFac  := StrZero(1,aTamParcI[1])
							While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFac + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
								cParcFac := Soma1(cParcFac,aTamParcI[1])
							EndDo

							RecLock("SE2",.T.)
							SE2->E2_FILIAL 	:= cFilial
							SE2->E2_FILORIG := cFilAnt
							SE2->E2_PREFIXO	:= cPrefixo
							SE2->E2_NUM    	:= cNum
							SE2->E2_PARCELA	:= cParcFac
							SE2->E2_TIPO 	:= MVTAXA
							SE2->E2_EMISSAO	:= dEmissao
							SE2->E2_EMIS1  	:= dDataBase
							SE2->E2_VALOR  	:= nIma
							SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
							SE2->E2_SALDO  	:= nIma
							SE2->E2_VENCREA	:= DTVenIcms()
							SE2->E2_VENCORI	:= dEmissao
							SE2->E2_FORNECE	:= cCodMVRES
							SE2->E2_LOJA   	:= cLojaImpos
							SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
							SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE2->E2_VLCRUZ 	:= Round(nIma, MsDecimais(1) )
							SE2->E2_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_IMANAT",.F.,"IMA")
							SE2->E2_NATUREZ	:= Alltrim(cNatureza)
							SE2->E2_CODAPRO	:= cCodAprov
							MsUnLock()
							AADD(aRecImpos,{"SE2",Recno()})

							FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA, , cTitpai, "SE1")

							//Gravar a parcela do IMA no titulo principal
							If lCposIMA
								DbSelectArea("SE1")
								SE1->(DbGoTo(nSavRec))
								RecLock("SE1",.F.)
								SE1->E1_PARCIMA	:= cParcFac
								MsUnLock()
							Endif

							//Cria a natureza IMA caso nao exista
							DbSelectArea("SED")
							If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := cFilial
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "IMA"
								SED->ED_TIPO	:= "2"
								MsUnlock()
							EndIf
						else
							//Busca a parcela IMA de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA
							nTamParc := Len(SE1->E1_PARCELA)
							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"IM-")
								cParcela := Soma1(cParcela,nTamParc)
							EndDo

							RecLock("SE1",.T.)
							SE1->E1_FILIAL	:= cFilSE1
							SE1->E1_FILORIG := cFilAnt
							SE1->E1_PREFIXO	:= cPrefixo
							SE1->E1_NUM 	:= cNum
							SE1->E1_PARCELA	:= cParcela
							SE1->E1_TIPO   	:= "IM-"
							SE1->E1_EMISSAO	:= dEmissao
							SE1->E1_EMIS1  	:= dDataBase
							SE1->E1_VALOR  	:= nIma
							SE1->E1_VENCTO 	:= dVencto
							SE1->E1_SALDO  	:= nIma
							SE1->E1_VENCREA	:= dVencRea
							SE1->E1_VENCORI	:= dVencto
							SE1->E1_CLIENTE	:= cCliente
							SE1->E1_LOJA   	:= cLoja
							SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
							SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE1->E1_VLCRUZ 	:= Round(nIma,MsDecimais(1))
							SE1->E1_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_IMANAT",.F.,"IMA")
							SE1->E1_NATUREZ	:= Alltrim(cNatureza)
							SE1->E1_STATUS 	:= "A"
							SE1->E1_SITUACA	:= "0"
							SE1->E1_OCORREN	:= "04"
							SE1->E1_LA     	:= cLa
							SE1->E1_FATURA	:= cFatura
							SE1->E1_TITPAI	:= cTitPai
							If __lCposIMA
								SE1->E1_IMA 	:= Round(nIma,MsDecimais(1))
								SE1->E1_PARCIMA	:= cParcela
							Endif

							AADD(aRecImpos,{"SE1",Recno()})

							cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
								SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							FINGRVFK7("SE1", cChaveTit, , cTitpai)

							if lPLSTITPF
								PLSTITPF('SE1',cTitPai)
							endIf

							//Cria a natureza IMA caso nao exista
							DbSelectArea("SED")
							cNatureza := AllTrim(cNatureza)
							If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := cFilial
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "IMA"
								SED->ED_TIPO	:= "2"
							EndIf
							If ExistBlock("F040IMA")
								Execblock("F040IMA",.F.,.F.,nSavRec)
							Endif
						Endif
					EndIf

					//--------------------------------------------------
					// Titulo do TPDP
					//--------------------------------------------------
					If nTPDP > 0 .And. SE1->E1_VALOR >= 100 .And. !lBorde

						//Cria o Fornecedor, caso nao exista
						DbSelectArea("SA2")
						SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
						If ( EOF() )
							Reclock("SA2",.T.)
							SA2->A2_FILIAL  := cFilial
							SA2->A2_COD 	:= cCodMVRES
							SA2->A2_LOJA	:= cLojaImpos
							SA2->A2_NOME	:= "RECEITA ESTADUAL"
							SA2->A2_NREDUZ  := "RECEITA"
							SA2->A2_BAIRRO  := "."
							SA2->A2_MUN 	:= "."
							SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
							SA2->A2_End 	:= "."
							SA2->A2_TIPO	:= "J"
							MsUnlock()
						EndIf

						DbSelectArea("SE2")
						SE2->(DbSetOrder(1))
						aTamParcI := TamSx3("E2_PARCELA")
						cParTPDP  := StrZero(1,aTamParcI[1])

						While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParTPDP + MVTAXA + PadR(cCodMVRES,__nTamFor) + cLojaImpos)
							cParTPDP := Soma1(cParTPDP,aTamParcI[1])
						EndDo

						RecLock("SE2",.T.)
						SE2->E2_FILIAL 	:= cFilial
						SE2->E2_FILORIG := cFilAnt
						SE2->E2_PREFIXO	:= cPrefixo
						SE2->E2_NUM    	:= cNum
						SE2->E2_PARCELA	:= cParTPDP
						SE2->E2_TIPO 	:= MVTAXA
						SE2->E2_EMISSAO	:= dEmissao
						SE2->E2_EMIS1  	:= dDataBase
						SE2->E2_VALOR  	:= nTPDP
						SE2->E2_VENCTO 	:= DataValida(IIF(SE1->E1_VENCTO > dDataBase+3,SE1->E1_VENCTO-3,SE1->E1_VENCTO),.t.)
						SE2->E2_SALDO  	:= nTPDP
						SE2->E2_VENCREA	:= DataValida(IIF(SE1->E1_VENCTO > dDataBase+3,SE1->E1_VENCTO-3,SE1->E1_VENCTO),.t.)
						SE2->E2_VENCORI	:= DataValida(IIF(SE1->E1_VENCTO > dDataBase+3,SE1->E1_VENCTO-3,SE1->E1_VENCTO),.t.)
						SE2->E2_FORNECE	:= cCodMVRES
						SE2->E2_LOJA   	:= cLojaImpos
						SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
						SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
						SE2->E2_VLCRUZ 	:= Round(nTPDP, MsDecimais(1) )
						SE2->E2_ORIGEM 	:= Upper(cOrigem)
						cNatureza      	:= SuperGetMV("MV_APTPDP",.F.,"TPDP")
						SE2->E2_NATUREZ	:= Alltrim(cNatureza)
						SE2->E2_CODAPRO	:= cCodAprov
						MsUnLock()
						AADD(aRecImpos,{"SE2",Recno()})

						FINGRVFK7("SE2", SE2->E2_FILIAL +"|"+ SE2->E2_PREFIXO +"|"+ SE2->E2_NUM +"|"+ SE2->E2_PARCELA +"|"+ SE2->E2_TIPO +"|"+ SE2->E2_FORNECE +"|"+ SE2->E2_LOJA, , cTitpai, "SE1")

						//Gravar a parcela da TPDP no titulo principal
						DbSelectArea("SE1")
						SE1->(DbGoTo(nSavRec))
						RecLock("SE1",.F.)
						SE1->E1_PARTPDP	:= cParTPDP
						MsUnLock()

						// Cria a natureza TPDP caso nao exista
						DbSelectArea("SED")
						If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
							RecLock("SED",.T.)
							SED->ED_FILIAL  := cFilial
							SED->ED_CODIGO  := cNatureza
							SED->ED_CALCIRF := "N"
							SED->ED_CALCISS := "N"
							SED->ED_CALCINS := "N"
							SED->ED_CALCCSL := "N"
							SED->ED_CALCCOF := "N"
							SED->ED_CALCPIS := "N"
							SED->ED_DESCRIC := "TPDP"
							SED->ED_TIPO	:= "2"
							MsUnlock()
						EndIf
					EndIf
				EndIf

				//-------------------------------------------------
				//Titulo do FUMIPEQ
				//-------------------------------------------------
				If lFumipeq .and. nFumipeq > 0 .And. !lBorde
					aResSED := getArea("SED")
					//Para garantir que estara no titulo principal.
					SE1->(DbGoTo(nSavRec))
					If SED->(ColumnPos("ED_CALCFMP"))>0 .And. SED->(DbSeek(xFilial("SED")+SE1->E1_NATUREZ)) .And. SED->ED_CALCFMP=="1"
						// Busca a parcela FUMIPEQ de acordo com o titulo
						dbSelectArea("SE1")
						dbSetOrder(1)

						cParcela := SE1->E1_PARCELA
						nTamParc := Len(SE1->E1_PARCELA)
						While !SE1->(Eof()) .And. MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FP-")
							cParcela := Soma1(cParcela,nTamParc)
						EndDo

						RecLock("SE1",.T.)
						SE1->E1_FILIAL	:= cFilial
						SE1->E1_PREFIXO	:= cPrefixo
						SE1->E1_NUM 	:= cNum
						SE1->E1_PARCELA	:= cParcela
						SE1->E1_TIPO   	:= "FP-"
						SE1->E1_EMISSAO	:= dEmissao
						SE1->E1_EMIS1  	:= dDataBase
						SE1->E1_VALOR  	:= nFumipeq
						SE1->E1_VENCTO 	:= dVencto
						SE1->E1_SALDO  	:= nFumipeq
						SE1->E1_VENCREA	:= dVencRea
						SE1->E1_VENCORI	:= dVencto
						SE1->E1_CLIENTE	:= cCliente
						SE1->E1_LOJA   	:= cLoja
						SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
						SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
						SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
						SE1->E1_ORIGEM 	:= Upper(cOrigem)
						cNatureza      	:= SuperGetMV("MV_FMPNAT",.F.,"FUMIPEQ")
						SE1->E1_NATUREZ	:= Alltrim(cNatureza)
						SE1->E1_STATUS 	:= "A"
						SE1->E1_SITUACA	:= "0"
						SE1->E1_OCORREN	:= "04"
						SE1->E1_LA     	:= cLa
						SE1->E1_FATURA	:= cFatura
						SE1->E1_FILORIG	:= cFilAnt
						SE1->E1_TITPAI 	:= cTitPai

						AADD(aRecImpos,{"SE1",Recno()})

						cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + ;
							SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
						FINGRVFK7("SE1", cChaveTit, , cTitpai)

						if lPLSTITPF
							PLSTITPF('SE1',cTitPai)
						endIf

						// Cria a natureza FUMIPEQ caso nao exista
						DbSelectArea("SED")
						cNatureza := AllTrim(cNatureza)
						If !SED->(DbSeek(xFilial("SED")+avKey(cNatureza,"ED_CODIGO")))
							RecLock("SED",.T.)
							SED->ED_FILIAL  := xFilial("SED")
							SED->ED_CODIGO  := cNatureza
							SED->ED_CALCIRF := "N"
							SED->ED_CALCISS := "N"
							SED->ED_CALCINS := "N"
							SED->ED_CALCCSL := "N"
							SED->ED_CALCCOF := "N"
							SED->ED_CALCPIS := "N"
							SED->ED_DESCRIC := "FUMIPEQ"
							SED->ED_TIPO	:= "2"
						EndIf
						If ExistBlock("F040FMP")
							Execblock("F040FMP",.F.,.F.,nSavRec)
						Endif
					Endif
					RestArea(aResSED)
				EndIf
			EndIf
			//Ponto se entrada para gravacoes genericas a todos os titulos de impostos
			If __lF040GER
				ExecBlock("F040GER",.F.,.F.,aRecImpos)
			Endif
		EndIf
	EndIf

	//Caso nao tenha efetuado os abatimentos, grava os campos de saldo a abater
	If !lPccMR .And. ( __lPccBxCr .Or. lAbateuPIS .Or. lAbateuCOF .Or. lAbateuCSLL .Or. lAbateuIRF )
		SE1->( MsGoto( nSavREC ) )
		RecLock( "SE1", .F. )

		If lAbateuPIS .or. __lPccBxCr
			SE1->E1_SABTPIS := 0
		EndIf

		If lAbateuCOF .or. __lPccBxCr
			SE1->E1_SABTCOF := 0
		EndIf

		If lAbateuCSLL .or. __lPccBxCr
			SE1->E1_SABTCSL := 0
		EndIf

		If lAbateuIRF
			SE1->E1_SABTIRF := 0
		EndIf
		SE1->( MsUnlock() )

	ElseIf !lIrfMR .And. __lIrPjBxCr
		SE1->( MsGoto( nSavREC ) )

		RecLock( "SE1", .F. )
		SE1->E1_SABTIRF := 0
		SE1->( MsUnlock() )

	EndIf

	__lIrPjBxCr := NIL
	DbSelectArea( "SA1" )
	DbGoTo( nSalvCli )
	DbSelectArea( "SE1" )
	DbGoTo( nSavRec )

Return(.T.)

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ATUSALBCO

Atualização de saldo bancário.
Arquivo original: MATXATU.PRX

@Author	Wagner Xavier
@since 16/04/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function AtuSalBco(cBanco, cAgencia, cConta, dData, nValor, cSinal,lReconc, lSalatu)
Local cAlias := Alias()
Local nRecNo := 0
Local nSalIni:=0
Local cMoeda := "  "
Local nRecBco := SA6->(Recno())
Local nSalIniRec :=0
Local cQuery  := ""
Local cFilSE8 := ""
Local cTblTmp := ""

Default lReconc := .F.  //Atualiza saldo concilialdo
Default lSalAtu  := .T. //Atualiza saldo principal Atual

If Empty(cBanco)
	Return
EndIf

// Ponto de Entrada bloquear atualização do saldo bancário
If __lAtuSlBco
	If !ExecBlock('ATUSLBCO',.F.,.F.,{cBanco, cAgencia, cConta, dData, nValor, cSinal})
		Return
	EndIf
Endif

If __cSGBD == Nil
	__cSGBD := TcGetDb()
EndIf

DbSelectArea("SA6")
SA6->(DbSetOrder(1))

If !SA6->(MsSeek(xFilial("SA6")+cBanco+cAgencia+cConta))
	Reclock( "SA6", .T. )
	SA6 -> A6_FILIAL := xFilial("SA6")
	SA6 -> A6_COD	  := cBanco
	SA6 -> A6_AGENCIA:= cAgencia
	SA6 -> A6_NUMCON := cConta
	SA6 -> A6_NOME   := "."
	SA6 -> A6_NREDUZ := "."
	SA6 -> A6_MOEDA  := 1
	IF cPaisLoc $ "ANG|EQU|HAI" //Campo existente apenas nos países ANG, EQU e HAI
		SA6 -> A6_DV := FINMod9710( cBanco + cAgencia + cConta )
	ENDIF

	MsUnlock()
Endif

cMoeda := STR(MAX(SA6->A6_MOEDA,1),2)

DbSelectArea("SE8")
SE8->(DbSetOrder(1))
cFilSE8 := FWxFilial("SE8")

If !SE8->(MsSeek(cFilSE8+cBanco+cAgencia+cConta+DtoS(dData),.t.))
	Reclock('SE8',.T.)
	SE8 -> E8_FILIAL := xFilial("SE8")
	SE8 -> E8_BANCO	:= cBanco
	SE8 -> E8_AGENCIA:= cAgencia
	SE8 -> E8_CONTA	:= cConta
	SE8 -> E8_DTSALAT:= dData
	SE8->(MsUnlock())

	Reclock('SE8',.F.)
	nRecNo := SE8->(Recno())

	DbSeek(cFilSE8+cBanco+cAgencia+cConta+DtoS(dData),.t.)
	DbSkip(-1)

	If E8_FILIAL+E8_BANCO+E8_AGENCIA+E8_CONTA == cFilSE8+cBanco+cAgencia+cConta .and. dData >= SE8->E8_DTSALAT
		nSalIni := E8_SALATUA
		nSalIniRec := E8_SALRECO
	Else
		nSalIni := 0
		nSalIniRec := 0
	EndIf

	SE8->(DBGoto(nRecNo))
Else
	Reclock('SE8',.F.)
	nSalIni    := SE8->E8_SALATUA
	nSalIniRec := SE8->E8_SALRECO
EndIf

RecLock("SE8",.F.)

If lSalAtu
	SE8->E8_SALATUA := nSalini + (Iif(cSinal=="+",nValor,nValor*-1))
Endif

If lReconc
	SE8->E8_SALRECO := nSaliniRec + (Iif(cSinal=="+",nValor,nValor*-1))
ElseIf SE8->E8_SALRECO == 0
	SE8->E8_SALRECO := nSaliniRec
Endif

SE8 -> E8_MOEDA  := cMoeda

SE8->(MsUnlock())
nRecNo := SE8->(RecNo())
DbSkip()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Recalcula os saldos do diante em diante, se necess rio. 	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (lSalAtu .Or. lReconc)
	cQuery := "UPDATE " + RetSqlName("SE8") + " SET "

	If lSalAtu
		cQuery += "E8_SALATUA = (E8_SALATUA " + cSinal + " " + cValToChar(nValor) + ") "
	EndIf

	If lReconc
		If lSalAtu
			cQuery += ","
		EndIf

		cQuery += "E8_SALRECO = (E8_SALRECO " + cSinal + " " + cValToChar(nValor) + ") "
	EndIf

	cQuery += "WHERE E8_FILIAL = '" + cFilSE8 + "' "
	cQuery += "AND E8_BANCO    = '" + cBanco + "' "
	cQuery += "AND E8_AGENCIA  = '" + cAgencia + "' "
	cQuery += "AND E8_CONTA    = '" + cConta + "' "
	cQuery += "AND E8_DTSALAT  > '" + DtoS(dData) + "' "
	cQuery += "AND D_E_L_E_T_  = ' ' "

	If TcSqlExec(cQuery) != 0
		UserException("Erro ao atualizar saldo" + CRLF + TcSqlError())
	EndIf
EndIf

//Busca o ultimo saldo
If __cQrySE8 == Nil
	__cQrySE8 := "SELECT "

	If __cSGBD == "MSSQL"
		__cQrySE8 := "SELECT TOP 1 "
	EndIf

	__cQrySE8 += "E8_DTSALAT,E8_SALATUA, R_E_C_N_O_ RECSE8 "
	__cQrySE8 += "FROM " + RetSqlName("SE8") + " "
	__cQrySE8 += "WHERE E8_FILIAL = ? "
	__cQrySE8 += "AND E8_BANCO    = ? "
	__cQrySE8 += "AND E8_AGENCIA  = ? "
	__cQrySE8 += "AND E8_CONTA    = ? "
	__cQrySE8 += "AND D_E_L_E_T_  = ' ' "

	If __cSGBD == "ORACLE"
		__cQrySE8 += " AND ROWNUM = 1 "
	EndIf

	__cQrySE8 += "ORDER BY E8_DTSALAT DESC "

	If __cSGBD == "POSTGRES"
		__cQrySE8 += "LIMIT 1"
	EndIf

	__cQrySE8 := ChangeQuery(__cQrySE8)
EndIf

cTblTmp := GetNextAlias()
DbUseArea(.T., "TOPCONN", TCGenQry2(Nil, Nil, __cQrySE8, {cFilSE8, cBanco, cAgencia, cConta}), cTblTmp, .F., .T.)

//Efetua a atualização do saldo no banco
Reclock("SA6")
SA6->A6_SALATU  := (cTblTmp)->E8_SALATUA
MsUnlock()

//POSICIONA O REGISTRO DO SE8
SE8->(DbGoTo((cTblTmp)->RECSE8))

(cTblTmp)->(DbCloseArea())


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para Reconciliacao Bancaria					  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (ExistBlock( "FAATUBCO" ) )
	ExecBlock("FAATUBCO",.F.,.F.,{cBanco, cAgencia, cConta, dData, nValor, cSinal,lReconc , lSalatu})
EndIf

SA6->(DbGoTo(nRecBco))   // Reposiciona no Banco da entrada da funcao
DbSelectArea(cAlias)
Return



/*
----------------------------------------------------------------------------
	            Funcoes retiradas do arquivo MATXFUNA.PRX
----------------------------------------------------------------------------
*/

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SUMABATREC

Soma titulos de abatimento relacionado a um determinado titulo a receber.
Arquivo original: MATXFUNA.PRX

@Author	Wagner Xavier
@since 23/03/1993
/*/
//-----------------------------------------------------------------------------------------------------
Function SumAbatRec(cPrefixo, cNumero, cParcela, nMoeda, cCpo, dData, nTotAbImp, nTotIrAbt, nTotCsAbt, nTotPisAbt, nTotCofAbt,;
					nTotInsAbt, cFilAbat, nTxMoeda, nTotISS, lFuncNova)

	Local cAlias     := ""
	Local nTotAbat   := 0
	Local nRec       := 0
	Local cCliLj     := ""
	Local lTitpaiSE1 := .F.
	Local cTipo      := ""
	Local nOrdTitPai := 0
	Local lIrPjBxCr  := .F.
	Local lProc		 := .T.
	Local lMotImp	 := .F.
	Local aOutImp	 := {}
	Local nY		 := 0
	Local aImpConf	 := {}
	Local lTemTtPai	 := .F.

	Default nTotAbImp  := 0
	Default nTotIrAbt  := 0
	Default nTotCsAbt  := 0
	Default nTotPisAbt := 0
	Default nTotCofAbt := 0
	Default nTotInsAbt := 0
	Default cFilAbat   := xFilial("SE1")
	Default nTxMoeda   := 0
	Default nTotISS    := 0 // --Transferencia de titulos parametrizado para nao tranferir o ISS
	Default lFuncNova  := .F.

	If lFuncNova //Cálculo dos abatimentos pela SumAbatRec restruturada para melhor performance
		nTotAbat := FinAbatRec(cPrefixo, cNumero, cParcela, nMoeda, cCpo, dData, @nTotAbImp, @nTotIrAbt, @nTotCsAbt, @nTotPisAbt, @nTotCofAbt,;
					@nTotInsAbt, cFilAbat, nTxMoeda, @nTotISS)
	Else
		cAlias     := Alias()
		nRec       := RecNo()
		lTitpaiSE1 := (SE1->(FieldPos("E1_TITPAI")) > 0)
		lIrPjBxCr  := FIrPjBxCr(.T.)
		lMotImp	   := FindFunction("FinImpConf")

		//Proteção para casos da SE1 compartilhada e o cFilAbat foi informado nos parâmetros com a cFilAnt
		cFilAbat := xFilial( "SE1" , cFilAbat )
		dData    := IIF(dData==NIL,dDataBase,dData)

		If Valtype(dData)=="C"
			dData := StoD(dData)
		Endif

		nMoeda  := IIF(nMoeda == NIL, 1, nMoeda)
		cCampo	:= IIF(cCpo == "V", "E1_VALOR", "E1_SALDO")

		If cAlias == "__SE1"
			cCliLj := __SE1->(E1_CLIENTE+E1_LOJA)
			cTipo	:=__SE1->E1_TIPO
		Else
			cCliLj := SE1->(E1_CLIENTE+E1_LOJA)
			cTipo  := SE1->E1_TIPO
		EndIf

		If Select("__SE1") == 0
			ChkFile("SE1",.F.,"__SE1")
		Else
			dbSelectArea("__SE1")
		Endif

		//RFC: se não informei os dados do titulo, retorno sem abatimento
		If Empty(cPrefixo + cNumero + cParcela )
			dbSelectArea( cAlias )
			dbGoTo(nRec)
			Return 0
		Endif

		If __lMotRet .And. lMotImp
			aImpConf	:=  FinImpConf("2", cFilAbat, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ)

			For nY := 1 To Len(aImpConf)
				If aImpConf[nY,4] == "1"
					Aadd(aOutImp,aImpConf[nY,8])
				EndIf
			Next nY
		Endif

		dbSetOrder( 1 )
		lProc := dbSeek( cFilAbat+cPrefixo+cNumero+cParcela+cTipo+cCliLj )

		If lProc
			//Países localizados não possuem impostos que geram títulos a partir de um título pai
			If cPaisLoc == "BRA" .And. lTitpaiSE1
				If FindFunction("OrdTitpai") .and. (nOrdTitPai:= OrdTitpai()) > 0
					DbSetOrder(nOrdTitPai)
					If	DbSeek(cFilAbat+cPrefixo+cNumero+cParcela+cTipo+cCliLj)
						lProc 		:= .T.
						lTemTtPai	:= .T.
					Else
						DbSetOrder(1)
						lProc := DbSeek(cFilAbat+cPrefixo+cNumero+cParcela)
					Endif
				Endif
			EndIf
		EndIf

		If lProc
			While !Eof() .And. (Iif(!lTemTtPai, E1_FILIAL == cFilAbat .And. E1_PREFIXO == cPrefixo .And. E1_NUM == cNumero .And. E1_PARCELA == cParcela .and. E1_TIPO = cTipo .and. E1_CLIENTE+E1_LOJA = cCliLj, ;
				!Empty(E1_TITPAI) .And. E1_FILIAL+E1_TITPAI == cFilAbat+Padr(cPrefixo+cNumero+cParcela+cTipo+cCliLj,Len(E1_TITPAI)) ) )
				If lTitpaiSE1
					If (!Empty(E1_TITPAI) .and. (E1_TITPAI!=Padr(cPrefixo+cNumero+cParcela+cTipo+cCliLj,Len(E1_TITPAI))) ) .or. Empty(E1_TITPAI)
						DbSkip()
						Loop
					EndIf
				EndIf

				If !Empty( cCliLj ) .And. (E1_CLIENTE+E1_LOJA == cCliLj)
					If E1_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVFUABT .And. !E1_TIPO $(MVPIABT+"/"+MVCFABT+"/"+MVCSABT)
						nTotAbat+= Iif(lIrPjBxCr, xMoeda(&cCampo.,E1_MOEDA, nMoeda,dData,,,nTxMoeda), xMoeda(&cCampo.,E1_MOEDA, nMoeda,E1_EMISSAO,,,nTxMoeda))
					EndIf

					If E1_TIPO $(MVPIABT+"/"+MVCFABT+"/"+MVCSABT)
						nTotAbat+=xMoeda(&cCampo.,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					EndIf

					If E1_TIPO $ MVIRABT+"/"+MVINABT+"/"+MVISABT+"/"+MVFUABT
						If (E1_TIPO $ MVIRABT .Or. E1_TIPO $ MVABATIM) .And. !lIrPjBxCr .And. nMoeda <> 1 .And. cPaisLoc == "BRA"
							nTotAbImp+=xMoeda(&cCampo.,E1_MOEDA, nMoeda,E1_EMISSAO,,,nTxMoeda)
						Else
							nTotAbImp +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
						Endif
					ElseIf  aScan(aOutImp, {|x| x == E1_TIPO}) > 0 .AND. !E1_TIPO $(MVPIABT+"/"+MVCFABT+"/"+MVCSABT)
						nTotAbImp +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif

					If E1_TIPO $(MVPIABT+"/"+MVCFABT+"/"+MVCSABT)
						nTotAbImp+=xMoeda(&cCampo.,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					EndIf

					//Irrf
					If E1_TIPO $ MVIRABT .And. E1_TIPO $ MVABATIM
						nTotIrAbt +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif
					//Csll
					If E1_TIPO $ MVCSABT .And. E1_TIPO $ MVABATIM
						nTotCsAbt +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif
					//PIS
					If E1_TIPO $ MVPIABT .And. E1_TIPO $ MVABATIM
						nTotPisAbt +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif
					//COFINS
					If E1_TIPO $ MVCFABT .And. E1_TIPO $ MVABATIM
						nTotCofAbt +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif
					//INSS
					If E1_TIPO $ MVINABT .And. E1_TIPO $ MVABATIM
						nTotInsAbt +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif
					//ISS
					IF E1_TIPO $ MVISABT .And. E1_TIPO $ MVABATIM
						nTotISS += xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					EndIf
				ElseIf Empty( cCliLj )
					Exit
				Endif
				dbSkip()
			Enddo
		Endif

		dbSetOrder( 1 )
		dbSelectArea( cAlias )
		dbGoTo(nRec)
	EndIf
Return (NoRound(nTotAbat))

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SUMABATPAG

Soma titulos de abatimento relacionado a um determinado titulo a pagar.
Arquivo original: MATXFUNA.PRX

@Author	Wagner Xavier
@since 23/03/1993
/*/
//-----------------------------------------------------------------------------------------------------
Function SumAbatPag(cPrefixo,cNumero,cParcela,cFornece,nMoeda,cCpo,dData,cLoja,cTipoData,dDataIni,dDataFim,dDataTxConv,cTipo)
Local aArea	   := GetArea()
Local cTmp	   := "ABATPAG"
Local cQuery   := ""
Local cFilTit  := If( Type("E2_FILIAL") <> "U", xFilial("SE2",E2_FILIAL), xFilial("SE2") )
Local nTotAbat := 0

Default cPrefixo  	:= If( Type("E2_PREFIXO") <> "U", E2_PREFIXO, "" )
Default cNumero	  	:= If( Type("E2_NUM") <> "U", E2_NUM, "" )
Default cParcela  	:= If( Type("E2_PARCELA") <> "U", E2_PARCELA, "" )
Default cFornece  	:= If( Type("E2_TIPO") <> "U", E2_TIPO, "" )
Default nMoeda 	  	:= 1
Default cCpo	  	:= ""
Default dData  	  	:= dDatabase
Default cLoja  	  	:= If( Type("E2_LOJA") <> "U", E2_LOJA, "" )
Default cTipoData 	:= ""
Default dDataIni 	:= StoD("")
Default dDataFim 	:= dDataBase
Default dDataTxConv := dDataBase
Default cTipo 		:= If( Type("E2_TIPO") <> "U", E2_TIPO, "" )

cQuery := "SELECT E2_MOEDA"
If cCpo == "V"
	cQuery += ",E2_VALOR AS VLRET"
Else
	cQuery += ",E2_SALDO AS VLRET"
EndIf
If cTipoData == "1"
	cQuery += ",E2_EMISSAO AS DTEMIS"
ElseIf cTipoData == "2"
	cQuery += ",E2_EMIS1 AS DTEMIS"
EndIf
cQuery += " FROM " + RetSqlName("SE2")
cQuery += " WHERE E2_FILIAL = '" +cFilTit+ "' AND"
cQuery += " E2_TITPAI = '" +cPrefixo+cNumero+cParcela+cTipo+cFornece+cLoja+ "' AND"
cQuery += " E2_TIPO IN " +FormatIn(MVABATIM,"|")+ " AND"
If cTipoData == "1"
	cQuery += " E2_EMISSAO BETWEEN '" +DtoS(dDataIni)+ "' AND '" +DtoS(dDataFim)+ "' AND"
ElseIf cTipoData == "2"
	cQuery += " E2_EMIS1 BETWEEN '" +DtoS(dDataIni)+ "' AND '" +DtoS(dDataFim)+ "' AND"
EndIf
cQuery += " D_E_L_E_T_ = ' '"
cQuery := ChangeQuery(cQuery)
cTmp   := MpSysOpenQuery(cQuery,cTmp)

While (cTmp)->(!EoF())
	nTotAbat += xMoeda((cTmp)->VLRET,(cTmp)->E2_MOEDA, nMoeda, dDataTxConv)
	(cTmp)->(dbSkip())
EndDo

(cTmp)->(dbCloseArea())
RestArea(aArea)

Return (NoRound(nTotAbat))

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA280VISUA

Função para visualizacao de contas a receber (FINA040/FINA280/fina281/FINA740/TmsA500) .
Arquivo original: MATXFUNA.PRX

@Author	Wagner Xavier
@since 16/04/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FA280Visua(cAlias,nReg,nOpc)
Local nOpca
Local aBut040 	:= {}
Local aUsButtons
Local lFina040 	:= FwIsInCallStack("FINA040")
Local lMotRet 	:= ExistFunc("FTemMotor") .And. FTemMotor()
Local aSE1Field := {}

PRIVATE aRatAFT		:= {}

bPMSDlgRC := IF(Type("bPMSDlgRC") == "U",  {||PmsDlgRC(2,M->E1_PREFIXO,M->E1_NUM,M->E1_PARCELA,M->E1_TIPO,M->E1_CLIENTE,M->E1_LOJA)}, bPMSDlgRC)

If lFina040
	aBut040 := fa040BAR('SE1->E1_PROJPMS == "1"',bPmsDlgRC)
ElseIf ExistBlock( "F040BUT" ) // Adiciona botoes do usuario na EnchoiceBar
	aUsButtons := ExecBlock( "F040BUT", .F., .F. )
	AEval( aUsButtons, { |x| AAdd( aBut040, x ) } )
EndIf

//inclusao do botao Posicao
If FindFunction("Fc040Con")
	AADD(aBut040, {"HISTORIC", {|| Fc040Con() }, STR0120})
Endif

//inclusao do botao Rastreamento
If FindFunction("Fin250Rec")
	AADD(aBut040, {"HISTORIC", {|| Fin250Rec(2) }, STR0121})
EndIf

//Motor de retenções
If lMotRet
	Aadd( aBut040, { "MTRRETIMP", { || FINCRET("SE1") }, STR0087, STR0087 } ) //"Consulta de Retenções"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Salva a Integridade dos dados de Entrada              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

DbSelectArea("SA1")
DbSeek(cFilial+SE1->E1_CLIENTE+SE1->E1_LOJA)

If (ExistBlock("FA40Prot"))
	ExecBlock("FA40Prot",.f.,.f.)
EndIf

DbSelectArea(cAlias)
If cPaisLoc   == "RUS"
	aSE1Field := FINXFIN03(cAlias) // FINXFIN03_FlView
	nOpca := AxVisual(cAlias,nReg,nOpc,aSE1Field,4,SA1->A1_NOME,, aBut040)
Else
	nOpca := AxVisual(cAlias,nReg,nOpc,,4,SA1->A1_NOME,, aBut040)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a Integridade dos dados de Entrada             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} CARREGASA6

Validação genérica de Banco Agência e C/C.
Arquivo original: MATXFUNA.PRX

@Author	Wagner Xavier
@since 21/03/1996
/*/
//-----------------------------------------------------------------------------------------------------
Function CarregaSa6(cBanco,cAgencia,cConta,lHelp,cBenef100,lValidBloq,cNatureza, cMoeda,lSitef, cOldBanco, cOldAgenc,cOldConta, cChmSA6)
Local cAlias	 := Alias()
Local cChave	 := ""
Local lRet		 :=.T.
Local nTamBen	 := Iif(cBenef100=NIL,0,Len(cBenef100))
Local lBenefi	 := .T.
Local lFinBenef	 := Existblock ("FINBENEF")
Local lChmPor	 := .T.
Local cFunName   := AllTrim(FunName())
Local lCallStack := ((cFunName == "FINA091") .Or. (cFunName == "FINA715") .Or. (cFunName == "WEBHOOK") .Or. (cFunName == "FINA718") .Or. FwIsInCallStack("FIN892Proc") .Or. FwIsInCallStack("baixaTitul") .Or. (cFunName == "FINI100G"))

Default cBanco		:= ""
Default cAgencia	:= ""
Default cConta		:= ""
Default lHelp		:= .T.
Default cBenef100	:= ""
Default lValidBloq  := .F.
Default cMoeda		:= ""
Default cNatureza	:= ""
Default lSitef 		:= .F.
Default cOldBanco	:= ""
Default cOldAgenc   := ""
Default cOldConta	:= ""
Default cChmSA6		:= ""

If __lMsblql == Nil 
	__lMsblql := FieldPos("A6_MSBLQL") > 0 
EndIf

If cChmSA6 = "cChmBco"
	If !Empty(cBanco) .And. Empty(cAgencia) .And. Empty(cConta)
		cChave:= cBanco
		If !SA6->(DbSeek(xFilial("SA6")+cChave))
			Help(" ",1,"FA100BCO")
			Return .F.
		EndIf
		cAgencia := ""
		cConta   := ""
	ElseIf cBanco <> cOldBanco .And. !Empty(cAgencia) .And. !Empty(cConta)
		If cAgencia <> cOldAgenc .And. cConta <> cOldConta
			cChave:= cBanco + cAgencia + cConta
			If !SA6->(DbSeek(xFilial("SA6")+cChave))
				Help(" ",1,"FA100BCO")
				Return .F.
			EndIf
			lChmPor		:= .F.
			cOldBanco := cBanco
			cOldAgenc := cAgencia
			cOldConta := cConta
		Else
			cChave:= cBanco
			cOldBanco := cBanco
			lChmPor		:= .F.
		EndIf
	EndIf
ElseIf cChmSA6 = "cChmAge"
	If cBanco = cOldBanco .And. cAgencia <> cOldAgenc
		cChave:= cBanco + cAgencia
		If !SA6->(DbSeek(xFilial("SA6")+cChave))
			Help(" ",1,"FA100BCO")
			Return .F.
		EndIf
		lChmPor	  := .F.
		cOldBanco := cBanco
		cOldAgenc := cAgencia
	ElseIf cBanco = cOldBanco .And. cAgencia = cOldAgenc .And. cConta <> cOldConta
		cChave:= cBanco + cAgencia
		lChmPor	  := .F.
		cOldBanco := cBanco
		cOldAgenc := cAgencia
	ElseIf cBanco <> cOldBanco .And. cAgencia <> cOldAgenc .And. cConta = cOldConta
		cChave:= cBanco + cAgencia + cConta
		If !SA6->(DbSeek(xFilial("SA6")+cChave))
			Help(" ",1,"FA100BCO")
			Return .F.
		EndIf
		lChmPor	  := .F.
		cOldBanco := cBanco
		cOldAgenc := cAgencia
		cOldConta := cConta
	EndIf
ElseIf cChmSA6 = "cChmCta"
	If cBanco = cOldBanco .And. cAgencia = cOldAgenc .And. cConta <> cOldConta
		cChave:= cBanco + cAgencia + cConta
		If !SA6->(DbSeek(xFilial("SA6")+cChave))
			Help(" ",1,"FA100BCO")
			Return .F.
		EndIf
		lChmPor	  := .F.
		cOldBanco := cBanco
		cOldAgenc := cAgencia
		cOldConta := cConta
	Else
		cChave:= cBanco + cAgencia + cConta
		If !SA6->(DbSeek(xFilial("SA6")+cChave))
			Help(" ",1,"FA100BCO")
			Return .F.
		EndIf			
		lChmPor	  := .F.
	Endif
Else
	If FunName() == 'FINA110' .And. !Empty(cAgencia) .And. !Empty(cConta) .AND. (cBanco <> cOldBanco .OR. cAgencia <> cOldAgenc .OR. cConta <> cOldConta) .AND. SA6->(DbSeek(xFilial("SA6")+ cBanco + cAgencia + cConta))// Quando alterado banco, agência e conta via F3
		cChave := cBanco + cAgencia + cConta
	Else
		If cOldBanco <> cBanco .And. cOldBanco <> ""
			cAgencia := ""
			cConta   := ""
		ElseIf cOldAgenc <> cAgencia .And. cOldAgenc <> ""
			cConta := ""
		EndIf
	EndIf
Endif

If lChmPor
	cChave:= cBanco+Iif(Empty(cAgencia),"",cAgencia)+Iif(Empty(cConta),"",cConta)
Endif
nTamBen := Len(cBenef100)

lHelp := Iif( lHelp=Nil,.T.,lHelp)
cFilOld:= cFilAnt
If !lCallStack .And. !lSitef
	cFilAnt:= SM0->M0_CODFIL
Endif
DbSelectArea("SA6")
DbSetOrder(1)

If FunName() $ "FINA080|FINA750"
	If Type("oBanco") == "O"
		If oBanco:lModiFied

			//Caso seja alterado o banco, limpo as váriaveis cAgencia e cConta para evitar execução desnecessária da Função.
			If cBanco <> SA6->A6_COD 
				cAgencia := ""
				cConta 	 := ""
			EndIf 

			cChave := cBanco + IIF(!Empty(cAgencia), cAgencia,"") + IIF(!Empty(cConta), cConta,"") 
			
			If DbSeek(cFilial + cChave)
				While SA6->(!EoF()) .And. cBanco == SA6->A6_COD
					If !(SA6->A6_BLOCKED == "1" .Or. (__lMsblql .And. SA6->A6_MSBLQL == "1"))
						If cAgencia <> SA6->A6_AGENCIA
							cAgencia 	:= 	SA6->A6_AGENCIA
							cConta		:=	SA6->A6_NUMCON
						Else
							If cConta<>SA6->A6_NUMCON
								cConta:=SA6->A6_NUMCON
							EndIf
						EndIf
						Exit
					EndIf
					SA6->(DbSkip())
				EndDo
			Else
				cAgencia:=""
				cConta:=""
				cChave:=cBanco
			EndIf
		EndIf
	EndIf
EndIf

If FunName() $ "FINA080|FINA750"
	If Type("oAgencia") == "O"
		If oAgencia:lModiFied
			cChave:=(cBanco+cAgencia+cConta)
			If DbSeek(cFilial+cChave)
				If cConta<>SA6->A6_NUMCON
					cConta:=SA6->A6_NUMCON
				Endif
			Else
				cConta:=""
			EndIf
		EndIf
  	EndIf
EndIf

If !DbSeek(xFilial("SA6")+cChave)
	lRet := .F.
	If lHelp
		Help(" ",1,"FA100BCO")
	EndIf
Else
	cBanco		:= Iif(cBanco	== NIl .or.  Empty( cBanco ),  SA6->A6_COD,     cBanco )
	cAgencia	:= Iif(cAgencia == NIl .or. Empty( cAgencia ), SA6->A6_AGENCIA	, cAgencia )
	cConta		:= Iif(cConta   == Nil .or. Empty( cConta   ), SA6->A6_NUMCON	, cConta   )
	If cPaisLoc == "BRA" .And. SA6->A6_MOEDA > 0
		cMoeda := SA6->A6_MOEDA
	EndIf
EndIf

cOldBanco := cBanco
cOldAgenc := cAgencia
cOldConta := cConta

// Carrega o nome do beneficiario, caso banco destino
If	lFinBenef
	lBenefi := ExecBlock ("FINBENEF",.F.,.F.)
Endif

If lRet .and. cBenef100 != Nil .and. lBenefi   // FINA100
	cBenef100 := Padr(SUBSTR(SM0->M0_NOMECOM,1,nTamBen),nTamben)
EndIf

If lRet .And. lValidBloq
	If SA6->A6_BLOCKED == "1"  //Conta Bloqueada
		Help(" ",1,"CCBLOCKED",,STR0091,1,0)
		lRet := .F.		
	ElseIf FieldPos("A6_MSBLQL") > 0 .And. SA6->A6_MSBLQL == "1" // campo de bloqueio ativado e banco bloqueado
		Help(" ",1,"REGBLOQ",,,1,0)
		lRet := .F.
	Endif
EndIf

If lRet .and. ExistBlock("PE_LOADSA6")
	cNatureza := Execblock("PE_LOADSA6",.F.,.F.)
EndIf
cFilAnt:=cFilOld
DbSelectArea( cAlias )
Return lRet


/*
----------------------------------------------------------------------------
	            Funcoes retiradas do arquivo MATXFUNB.PRX
----------------------------------------------------------------------------
*/

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} READCNAB2

CNAB Modelo 2.
Arquivo original: MATXFUNB.PRX

@param nHandle - Handle do Arquivo a ser lido
@param cLayaout - Nome do arquivo de configuracao
@param nMaxLn - Tamanho maximo da linha
@param aLayout - Atributos do arquivo de configuracao
@param nLinRead

@Author	Eduardo Riera
@since 16/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function ReadCnab2(nHandle,cLayOut,nMaxLn,aLayOut,nLinRead)
	Local nHdlLay		:= 0
	Local lContinua		:= .T.
	Local cBuffer		:= ""
	Local nCntFor		:= 0
	Local nPosIni		:= 0
	Local nPosFim		:= 0
	Local nTamanho		:= 0
	Local nDecimal		:= 0
	Local nPosSeg		:= 0
	Local aSegmento		:= {}
	Local aDetalhe		:= {}
	Local cLinUlt		:= ""
	Local cLinAtu		:= ""
	Local nCntFor2		:= 0
	Local cIdent		:= ""
	Local xTITULO		:= ""
	Local xTIPO			:= ""
	Local xOCORRENCI	:= ""
	Local xDATA     	:= "000000"
	Local xVALOR    	:= 0.00
	Local xDESPESA  	:= 0.00
	Local xDESCONTO 	:= 0.00
	Local xABATIMENT	:= 0.00
	Local xJUROS    	:= 0.00
	Local xMULTA    	:= 0.00
	Local xDespAux		:= 0.00
	Local xNOSSONUM 	:= ""
	Local xRESERVADO	:= ""
	Local xValIof   	:= 0.00
	Local xValCC    	:= 0.00
	Local xDATACRED 	:= "000000"
	Local xMOTIVO   	:= ""
	Local xBuffer   	:= ""
	Local nLeitura  	:= 0			// Numero de Leituras Efetuadas
	Local lSegValido	:= .F.			// Controle de Leitura de segmentos validos
	Local nLidosBco 	:= 0			// Numero de Bytes lidos do Arquivo de Retorno
	Local xAUTENTICA	:= ""
	Local aBuffer		:= {}
	Local xCGC			:= ""
	Local cChave    	:= ""
	Local aDirTmp   	:= {}
	Local xBANCO		:= ""
	Local xAGENCIA		:= ""
	Local xCONTA		:= ""
	Local aHeadL		:= Array(4,5)	//Array das posicoes de Banco, Agencia e Conta no Header para a baixa
	Local aBanco		:= Array(3)		//Dados bancarios para a baixa (coletados no header)
	Local lHeadL		:= .F.
	Local xCGCH			:= ""
	Local xCODBAR		:= ""
	Local xContOpt		:=""
	Local nPosj52		:= 0
	Local cSegmento		:= ''
	Local cSeg52		:= ''
	Local lReadJ		:= .F.
	Local aReadSeg		:= {}
	Local xCGCEMP		:= ""			//CNPJ da empresa utilizada no DDA para posicionar a SM0
	Local cTipoReg      := ""
	Local lBuffer       := .F.
	Local cHeader       := ""

	Default nMaxLn		:= 1000
	Default aLayOut		:= {}
	Default nLinRead	:= 0

	Private xConteudo  := ""
	
	If File(cLayOut)
		If Len(aLayOut) == 0
			aDirTmp	:= Directory(cLayOut)
		ELse
			aDirTmp := AClone(aLayOut)
		EndIf

		// Inicializa flag que indica se possui dados bancarios para baixa - Header de Lote
		For nCntFor := 1 to Len(aHeadL)
			aHeadL[ nCntFor, 5 ] := .F.
		Next
		
		cChave := aDirTmp[1][1]+str(aDirTmp[1][2])+DtoC(aDirTmp[1][3])+aDirTmp[1][4]
		
		If Empty(__aLayCNAB) .Or. cChave != __aLayCNAB[1]
			nHdlLay := FOpen(cLayOut,64)		
			
			While lContinua
				cBuffer := FreadStr(nHdlLay,502)
				
				If !Empty(cBuffer)
					If ( SubStr(cBuffer,1,1)=="1" )
						If ( SubStr(cBuffer,3,1)=="D" )
							aadd(aSegmento,{AllTrim(SubStr(cBuffer,02,03)),;
							AllTrim(SubStr(cBuffer,35,255)),0,0,0,0})
							aadd(aDetalhe,Array(20,4))
						EndIf
					Else
						If ( SubStr(cBuffer,3,1)=="D" )
							nPosIni  := Val(SubStr(cBuffer,20,03))
							nPosFim  := Val(SubStr(cBuffer,23,03))
							nDecimal := Val(SubStr(cBuffer,26,01))
							nTamanho := nPosFim - nPosIni +1
							xConteudo:= AllTrim(SubStr(cBuffer,27,255))
							nPosSeg  := AScan(aSegmento,{|x| x[1]==Alltrim(SubStr(cBuffer,02,03))})
							
							If ( nPosSeg != 0 )
								Do Case
								Case xConteudo=="TITULO"
									aDetalhe[nPosSeg,1,1] := "TITULO"
									aDetalhe[nPosSeg,1,2] := nPosIni
									aDetalhe[nPosSeg,1,3] := nTamanho
									aDetalhe[nPosSeg,1,4] := nDecimal
								Case  xConteudo=="ESPECIE"
									aDetalhe[nPosSeg,2,1] := "ESPECIE"
									aDetalhe[nPosSeg,2,2] := nPosIni
									aDetalhe[nPosSeg,2,3] := nTamanho
									aDetalhe[nPosSeg,2,4] := nDecimal
								Case xConteudo=="OCORRENCIA"
									aDetalhe[nPosSeg,3,1] := "OCORRENCIA"
									aDetalhe[nPosSeg,3,2] := nPosIni
									aDetalhe[nPosSeg,3,3] := nTamanho
									aDetalhe[nPosSeg,3,4] := nDecimal
								Case xConteudo=="DATA"
									aDetalhe[nPosSeg,4,1] := "DATA"
									aDetalhe[nPosSeg,4,2] := nPosIni
									aDetalhe[nPosSeg,4,3] := nTamanho
									aDetalhe[nPosSeg,4,4] := nDecimal
								Case xConteudo=="VALOR"
									aDetalhe[nPosSeg,5,1] := "VALOR"
									aDetalhe[nPosSeg,5,2] := nPosIni
									aDetalhe[nPosSeg,5,3] := nTamanho
									aDetalhe[nPosSeg,5,4] := nDecimal
								Case xConteudo=="DESPESA"
									aDetalhe[nPosSeg,6,1] := "DESPESA"
									aDetalhe[nPosSeg,6,2] := nPosIni
									aDetalhe[nPosSeg,6,3] := nTamanho
									aDetalhe[nPosSeg,6,4] := nDecimal
								Case xConteudo=="DESCONTO"
									aDetalhe[nPosSeg,7,1] := "DESCONTO"
									aDetalhe[nPosSeg,7,2] := nPosIni
									aDetalhe[nPosSeg,7,3] := nTamanho
									aDetalhe[nPosSeg,7,4] := nDecimal
								Case xConteudo=="ABATIMENTO"
									aDetalhe[nPosSeg,8,1] := "ABATIMENTO"
									aDetalhe[nPosSeg,8,2] := nPosIni
									aDetalhe[nPosSeg,8,3] := nTamanho
									aDetalhe[nPosSeg,8,4] := nDecimal
								Case xConteudo=="JUROS"
									aDetalhe[nPosSeg,9,1] := "JUROS"
									aDetalhe[nPosSeg,9,2] := nPosIni
									aDetalhe[nPosSeg,9,3] := nTamanho
									aDetalhe[nPosSeg,9,4] := nDecimal
								Case xConteudo=="MULTA"
									aDetalhe[nPosSeg,10,1] := "MULTA"
									aDetalhe[nPosSeg,10,2] := nPosIni
									aDetalhe[nPosSeg,10,3] := nTamanho
									aDetalhe[nPosSeg,10,4] := nDecimal
								Case xConteudo=="IOF"
									aDetalhe[nPosSeg,11,1] := "IOF"
									aDetalhe[nPosSeg,11,2] := nPosIni
									aDetalhe[nPosSeg,11,3] := nTamanho
									aDetalhe[nPosSeg,11,4] := nDecimal
								Case xConteudo=="OUTROSCREDITOS"
									aDetalhe[nPosSeg,12,1] := "OUTROSCREDITOS"
									aDetalhe[nPosSeg,12,2] := nPosIni
									aDetalhe[nPosSeg,12,3] := nTamanho
									aDetalhe[nPosSeg,12,4] := nDecimal
								Case xConteudo=="DATACREDITO"
									aDetalhe[nPosSeg,13,1] := "DATACREDITO"
									aDetalhe[nPosSeg,13,2] := nPosIni
									aDetalhe[nPosSeg,13,3] := nTamanho
									aDetalhe[nPosSeg,13,4] := nDecimal
								Case xConteudo=="MOTIVO"
									aDetalhe[nPosSeg,14,1] := "MOTIVO"
									aDetalhe[nPosSeg,14,2] := nPosIni
									aDetalhe[nPosSeg,14,3] := nTamanho
									aDetalhe[nPosSeg,14,4] := nDecimal
								Case xConteudo=="NOSSONUMERO"
									aDetalhe[nPosSeg,15,1] := "NOSSONUMERO"
									aDetalhe[nPosSeg,15,2] := nPosIni
									aDetalhe[nPosSeg,15,3] := nTamanho
									aDetalhe[nPosSeg,15,4] := nDecimal
								Case xConteudo=="RESERVADO"
									aDetalhe[nPosSeg,16,1] := "RESERVADO"
									aDetalhe[nPosSeg,16,2] := nPosIni
									aDetalhe[nPosSeg,16,3] := nTamanho
									aDetalhe[nPosSeg,16,4] := nDecimal
								Case xConteudo=="SEGMENTO"
									aSegmento[nPosSeg,3] := nPosIni
									aSegmento[nPosSeg,4] := nTamanho
								Case xConteudo=="AUTENTICACAO"
									aDetalhe[nPosSeg,17,1] := "AUTENTICACAO"
									aDetalhe[nPosSeg,17,2] := nPosIni
									aDetalhe[nPosSeg,17,3] := nTamanho
									aDetalhe[nPosSeg,17,4] := nDecimal
								Case xConteudo=="CGC"
									aDetalhe[nPosSeg,18,1] := "CGC"
									aDetalhe[nPosSeg,18,2] := nPosIni
									aDetalhe[nPosSeg,18,3] := nTamanho
									aDetalhe[nPosSeg,18,4] := nDecimal
								Case xConteudo=="CGCH"
									aDetalhe[nPosSeg,19,1] := "CGCH"
									aDetalhe[nPosSeg,19,2] := nPosIni
									aDetalhe[nPosSeg,19,3] := nTamanho
									aDetalhe[nPosSeg,19,4] := nDecimal
								Case xConteudo=="CODBAR"
									aDetalhe[nPosSeg,20,1] := "CODBAR"
									aDetalhe[nPosSeg,20,2] := nPosIni
									aDetalhe[nPosSeg,20,3] := nTamanho
									aDetalhe[nPosSeg,20,4] := nDecimal
								Case xConteudo=="SEGJ52"
									aSegmento[nPosSeg,5] := nPosIni
									aSegmento[nPosSeg,6] := nTamanho
								EndCase
							EndIf
						//Dados bancarios para a baixa
						ElseIf ( SubStr(cBuffer,3,1)=="H" )
							nPosIni  := Val(SubStr(cBuffer,20,03))
							nPosFim  := Val(SubStr(cBuffer,23,03))
							nDecimal := Val(SubStr(cBuffer,26,01))
							nTamanho := nPosFim - nPosIni +1
							xConteudo:= AllTrim(SubStr(cBuffer,27,255))
							lHeadL   := .T.
							Do Case
								Case xConteudo=="BANCO"
									aHeadL[1,1] := "BANCO"
									aHeadL[1,2] := nPosIni
									aHeadL[1,3] := nTamanho
									aHeadL[1,4] := nDecimal
									aHeadL[1,5] := .T.
								Case xConteudo=="AGENCIA"
									aHeadL[2,1] := "AGENCIA"
									aHeadL[2,2] := nPosIni
									aHeadL[2,3] := nTamanho
									aHeadL[2,4] := nDecimal
									aHeadL[2,5] := .T.
								Case xConteudo=="CONTA"
									aHeadL[3,1] := "CONTA"
									aHeadL[3,2] := nPosIni
									aHeadL[3,3] := nTamanho
									aHeadL[3,4] := nDecimal
									aHeadL[3,5] := .T.
								Case xConteudo=="CGCEMP"
									aHeadL[4,1] := "CGCEMP"
									aHeadL[4,2] := nPosIni
									aHeadL[4,3] := nTamanho
									aHeadL[4,4] := nDecimal
									aHeadL[4,5] := .T.
							EndCase
						EndIf
					EndIf
				Else
					lContinua := .F.
				EndIf
			EndDo
			
			FClose(nHdlLay)
			__aLayCNAB	:=	{}
			Aadd(__aLayCNAB,cChave)
			Aadd(__aLayCNAB,aSegmento)
			Aadd(__aLayCNAB,aDetalhe)
			Aadd(__aLayCNAB,aHeadL)
			Aadd(__aLayCNAB,aBanco)
		Else
			aSegmento	:= aClone(__aLayCNAB[2])
			aDetalhe	:= aClone(__aLayCNAB[3])
			aHeadL		:= aClone(__aLayCNAB[4])
			aBanco		:= aClone(__aLayCNAB[5])
		EndIf
	EndIf
	
	lContinua := .T.
	
	While lContinua
		aLinha		:= LerLinha(nHandle,nMaxLn)
		cBuffer 	:= aLinha[1]
		nLidosBco 	:= aLinha[2]
		lSegValido	:= .F.
		nLeitura++
		nLinRead++
		cSegmento	:= ""
		lBuffer     := .F.
		cHeader     := ""
		
		If (lBuffer := !Empty(cBuffer))
			cTipoReg := Substr(cBuffer, 8, 1)
		EndIf

		//Para o tratamento de CNPJ no Header de Lote, verifico as informações do Header se o mesmo foi configurado
		If nMaxLn < 1000 .And. !lHeadL
			lHeadL  := Len(aHeadL) > 0
		EndIf

		If lBuffer
			//Layout 150 posições débito automático
			If lBuffer .And. (nMaxLn >= 150 .And. nMaxLn <= 152)
				cHeader := Substr(cBuffer, 1, 1)
			EndIf

			//Lendo no Header de Lote o Banco, Agencia e Conta para baixa
			If (cHeader == "A") .Or. (cTipoReg == "1" .And. lHeadL .And. cHeader != "F")
				For nCntFor := 1 To Len(aHeadL)
					If aHeadL[nCntFor,5]
						nPosIni := aHeadL[nCntFor,2]
						nTamanho:= aHeadL[nCntFor,3]
						nDecimal:= aHeadL[nCntFor,4]
						Do Case
						Case aHeadL[nCntFor,1]=="BANCO"
							xBANCO	:= SubStr(cBuffer,nPosIni,nTamanho)
							aBanco[1] := xBANCO
						Case aHeadL[nCntFor,1]=="AGENCIA"
							xAGENCIA	:= SubStr(cBuffer,nPosIni,nTamanho)
							aBanco[2] := xAGENCIA
						Case aHeadL[nCntFor,1]=="CONTA"
							xCONTA	:= SubStr(cBuffer,nPosIni,nTamanho)
							aBanco[3] := xCONTA
						Case aHeadL[nCntFor,1]=="CGCEMP"
							xCGCEMP	:= SubStr(cBuffer,nPosIni,nTamanho)
						EndCase
					EndIf
				Next
				__aLayCNAB[5] := aClone( aBanco )
			Else
				//Recarrego os dados bancarios quando estiver processando o detalhe
				//Esses dados estao apenas no header e somente serao trocados quando
				//lido um novo header
				If Empty(xBanco) .and. !Empty(aBanco[1])
					xBanco	:= aBanco[1]
					xAgencia := aBanco[2]
					xConta	:= aBanco[3]
				Endif

				// Posição do SEGMENTO J52
				nPosJ52 := Ascan(aSegmento,{|x| x[2] = "J52" })
				lReadJ  := Ascan(aReadSeg, {|x| x == "J" }) > 0
				
				//Busca o segmento da linha atual no array(aSegmento)
				For nCntFor := 1 To Len(aSegmento)
					If Empty(cSegmento)
						cSegmento := If(SubStr(cBuffer,aSegmento[nCntFor,3],aSegmento[nCntFor,4]) == aSegmento[nCntFor,2], aSegmento[nCntFor,2],"")
					ElseIf cSegmento == "J" .And. lReadJ .And. nPosJ52 != 0 .And. nPosJ52 == nCntFor // Verifica se existe SEGMENTO J52 (Opicional)
						cSeg52    := Alltrim(SubStr(cBuffer, aSegmento[nCntFor,3], aSegmento[nCntFor,4])) + SubStr(cBuffer, aSegmento[nCntFor,5], aSegmento[nCntFor,6])
						cSegmento := If(cSeg52 == aSegmento[nPosJ52,2], aSegmento[nCntFor,2], cSegmento)
					EndIf
				Next
				
				// Caso o segmento ja foi processado por uma linha do arquivo de retorno, saio da função com os dados carregados até o momento.
				If !Empty(cSegmento) .And. AScan(aReadSeg, {|x| x == cSegmento}) > 0				
					//Retorna a linha atual para ser relida na proxima interacao.
					nLinRead--
					FSeek(nHandle,-2*(nLidosBco),1)
					cBuffer := LerLinha(nHandle,nMaxLn)[1]
					lContinua := .F.
					Exit
				ElseIf !Empty(cSegmento)
					AADD(aReadSeg,cSegmento)
				EndIf

				For nCntFor := 1 To Len(aSegmento)
					//-----------------------------------------------------------------
					//                      Teste de Quebra
					//  1D(n)
					//  ------------------------------
					//  |(n)-------------------------  -> Linha Detalhe  =  Conj.
					//  | 1 |------------------------A - Identificador    | da
					//  | 2 |------------------------B - Identificador    | Linha
					//  | 3 |------------------------C - Identificador    | Detalhe
					//  |   -------------------------                    =
					//  |
					//  ------------------------------
					//  2D(n)
					//  ------------------------------
					//  |(n)-------------------------  -> Linha Detalhe  =  Conj.
					//  | 1 |------------------------A - Identificador    | da
					//  | 2 |------------------------B - Identificador    | Linha
					//  | 3 |------------------------C - Identificador    | Detalhe
					//  |   -------------------------                    =
					//  |
					//  ------------------------------
					//
					//-----------------------------------------------------------------
					xConteudo  := Alltrim(SubStr(cBuffer,aSegmento[nCntFor,3],aSegmento[nCntFor,4]))
					
					If nPosj52 > 0 .And. !Empty(cSeg52)
						If nCntFor == nPosj52
							xContOpt   := SubStr(cBuffer,aSegmento[nCntFor,5],aSegmento[nCntFor,6])

							If !Empty(xContOpt) .And. xContOpt == "52"
								xConteudo := Alltrim( xConteudo ) + xContOpt
							EndIf
						Else
							xConteudo  := ""
						EndIf
					EndIf
					
					//Verifica a qual linha detalhe o segmento valido pertence.				
					If ((nPosj52 > 0 .And. xConteudo == aSegmento[nCntFor,2]) .Or. (nPosj52 <= 0 .And. xConteudo $ aSegmento[nCntFor,2]))
						cLinAtu := SubStr(aSegmento[nCntFor][1], 1, 1)
					EndIf
					
					// Verifica se houve quebra de linha detalhe, ou se o houve repeticao do mesmo conjunto da linha detalhe.
					// A repeticao ocorre quando o identificador de linha repete-se.				
					If ((cIdent == xConteudo) .Or. (cLinAtu != cLinUlt)) .And. !Empty(cIdent) .And. !Empty(cLinUlt) .And. nLeitura > 1
						//Retorna a linha atual para ser relida na proxima interacao.
						nLinRead--
						FSeek(nHandle, -2 * (nLidosBco), 1)
						cBuffer   := LerLinha(nHandle,nMaxLn)[1]
						lContinua := .F.
						Exit
					EndIf
					
					If lContinua .And. ((nPosj52 > 0 .And. xConteudo == aSegmento[nCntFor,2]) .Or. (nPosj52 <= 0 .And. xConteudo $ aSegmento[nCntFor,2]))
						lSegValido := .T.
						xBuffer    += cBuffer
						Aadd(aBuffer,cBuffer)
						
						If Empty(cIdent)
							nLeitura := 1
							cIdent 	:= xConteudo
							cLinUlt := SubStr(aSegmento[nCntFor][1],1,1)
						EndIf
						
						If ((!cTipoReg $ "5|9") .Or. (xTITULO != Nil .And. Empty(xTITULO)))
							For nCntFor2 := 1 To Len(aDetalhe[nCntFor])
								nPosIni := aDetalhe[nCntFor,nCntFor2,2]
								nTamanho:= aDetalhe[nCntFor,nCntFor2,3]
								nDecimal:= aDetalhe[nCntFor,nCntFor2,4]
								
								Do Case
								Case aDetalhe[nCntFor,nCntFor2,1]=="TITULO"
									xTITULO := SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="NOSSONUMERO"
									xNOSSONUM := SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="ESPECIE"
									xTIPO     := SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="OCORRENCIA"
									xOCORRENCI := SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="DATA"
									xDATA := SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="VALOR"
									xVALOR := SubStr(cBuffer,nPosIni,nTamanho)
									xVALOR := Val(xVALOR)/(Val("1"+Repl("0",nDecimal)))
								Case aDetalhe[nCntFor,nCntFor2,1]=="DESPESA"
									xDESPESA := SubStr(cBuffer,nPosIni,nTamanho)
									xDESPESA := Val(xDESPESA)/(Val("1"+Repl("0",nDecimal)))
									xDespAux += xDESPESA
									xDESPESA := xDespAux
								Case aDetalhe[nCntFor,nCntFor2,1]=="DESCONTO"
									xDESCONTO := SubStr(cBuffer,nPosIni,nTamanho)
									xDESCONTO := Val(xDESCONTO)/(Val("1"+Repl("0",nDecimal)))
								Case aDetalhe[nCntFor,nCntFor2,1]=="ABATIMENTO"
									xABATIMENT := SubStr(cBuffer,nPosIni,nTamanho)
									xABATIMENT := Val(xABATIMENT)/(Val("1"+Repl("0",nDecimal)))
								Case aDetalhe[nCntFor,nCntFor2,1]=="JUROS"
									xJUROS := SubStr(cBuffer,nPosIni,nTamanho)
									xJUROS := Val(xJUROS)/(Val("1"+Repl("0",nDecimal)))
								Case aDetalhe[nCntFor,nCntFor2,1]=="MULTA"
									xMULTA := SubStr(cBuffer,nPosIni,nTamanho)
									xMULTA := Val(xMULTA)/(Val("1"+Repl("0",nDecimal)))
								Case aDetalhe[nCntFor,nCntFor2,1]=="OUTROSCREDITOS"
									xValCC := SubStr(cBuffer,nPosIni,nTamanho)
									xValCC := Val(xValCC)/(Val("1"+Repl("0",nDecimal)))
								Case aDetalhe[nCntFor,nCntFor2,1]=="IOF"
									xValIof := SubStr(cBuffer,nPosIni,nTamanho)
									xValIof := Val(xValIof)/(Val("1"+Repl("0",nDecimal)))
								Case aDetalhe[nCntFor,nCntFor2,1]=="DATACREDITO"
									xDATACRED := SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="MOTIVO"
									xMOTIVO := SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="RESERVADO"
									xRESERVADO:= SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="AUTENTICACAO"
									xAUTENTICA := SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="CGC"
									xCGC:= SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="CGCH"
									xCGCH:= SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="CODBAR"
									xCODBAR:= SubStr(cBuffer,nPosIni,nTamanho)
								Case aDetalhe[nCntFor,nCntFor2,1]=="IDENT REG OPCIO"
									xIdent:= SubStr(cBuffer,nPosIni,nTamanho)
								EndCase
							Next
						EndIf
					EndIf
				Next nCntFor
				
				cSeg52 := ""
				
				If !lSegValido .And. !Empty(cIdent)
					lContinua := .F.
				EndIf
			Endif
		Else
			lContinua := .F.
		EndIf
	EndDo

Return({xTITULO, xTIPO, xOCORRENCI, xDATA, xVALOR,;
		xDESPESA, xDESCONTO, xABATIMENT, xJUROS, xMULTA,;
		xNOSSONUM, xValIof, xValCC, xDATACRED, xMOTIVO,;
		xRESERVADO, xBuffer, xAUTENTICA, aBuffer, xCGC,;
		xBanco, xAgencia, xConta, xCGCH, xCODBAR, xCGCEMP})


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} HEADLOTE2

CNAB Modelo 2 - Cria Header do lote de registro no arq Cnab Modelo 2
Arquivo original: MATXFUNB.PRX

@param nHandle - Handle do Arquivo a ser lido
@param cLayout - Atributos do arquivo de configuracao

@Author	Claudio Donizete
@since 27/12/2005
/*/
//-----------------------------------------------------------------------------------------------------
Function HeadLote2(nHdlSaida,cLayOut)

Local nHdlLay	 := 0
Local lContinua := .T.
Local cBuffer	 := ""
Local aLayOut	 := {}
Local aDetalhe  := {}
Local nCntFor	 := 0
Local nCntFor2  := 0
Local lFormula  := ""
Local nPosIni	 := 0
Local nPosFim	 := 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	 := ErrorBlock()

Private xConteudo := ""

If ( File(cLayOut) )
	nHdlLay := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHdlLay,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,2,1)$"1/2/3/4/5/6/7/8/9" )
					If ( SubStr(cBuffer,3,1) == "H" )
						aadd(aLayOut, {SubStr(cBuffer,02,03), SubStr(cBuffer,05,30), SubStr(cBuffer,35,255) } )
					EndIf
				Endif
			Else
				If ( SubStr(cBuffer,3,1) == "H" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHdlLay)
EndIf
For nCntFor := 1 To Len(aLayOut)
	Begin Sequence
	lFormula := &(AllTrim(aLayOut[nCntFor,3]))
	If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="H" )
		cBuffer := ""
		For nCntFor2 := 1 To Len(aDetalhe)
			If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
				xConteudo := (AllTrim(aDetalhe[nCntFor2,6]))
				If ( Empty(xConteudo) )
					xConteudo := ""
				Else
					xConteudo := &(AllTrim(xConteudo))
				EndIf
				nPosIni   := Val(aDetalhe[nCntFor2,3])
				nPosFim   := Val(aDetalhe[nCntFor2,4])
				nDecimal  := Val(aDetalhe[nCntFor2,5])
				nTamanho  := nPosFim-nPosIni+1
				Do Case
					Case ValType(xConteudo) == "D"
						xConteudo := GravaData(xConteudo,.F.)
					Case ValType(xConteudo) == "N"
						xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
				EndCase
				xConteudo := SubStr(xConteudo,1,nTamanho)
				xConteudo := PadR(xConteudo,nTamanho)
				cBuffer += xConteudo
			EndIf
		Next nCntFor2
		cBuffer += Chr(13)+Chr(10)
		If FwIsInCallStack("FINA150")
			F150Write(nHdlSaida,cBuffer,Len(cBuffer))
		else
			FWrite(nHdlSaida,cBuffer,Len(cBuffer))
		EndIf
	EndIf
	End Sequence
Next nCntFor
ErrorBlock(bBlock)
Return(nHdlSaida)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} HEADCNAB2

CNAB Modelo 2 - Cria o Arquivo padrao Cnab Modelo 2.
Arquivo original: MATXFUNB.PRX

@param nArquivo - nome do arquivo a ser gerado
@param cLayout - nome do arquivo de configuração

@Author	Eduardo Riera
@since 16/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function HeadCnab2(cArquivo,cLayOut)

Local nHandle	 := 0
Local lContinua := .T.
Local cBuffer	 := ""
Local aLayOut	 := {}
Local aDetalhe  := {}
Local nCntFor	 := 0
Local nCntFor2  := 0
Local lFormula  := ""
Local nPosIni	 := 0
Local nPosFim	 := 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	 := ErrorBlock()
Local lUtilizaMI := cPaisLoc $ "PER|MEX|COL|EQU"
Private xConteudo := ""

If Type("nDecTotal") == "U"
	Private nDecTotal:= 0
EndIf

If ( File(cLayOut) )
	nHandle := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHandle,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,3,1) == "H" )
					aadd(aLayOut,{ SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,30),;
					SubStr(cBuffer,35,255)})
				EndIf
			Else
				If ( SubStr(cBuffer,3,1) == "H" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHandle)
EndIf
nHandle := FCreate(cArquivo)
If nHandle > 0
	For nCntFor := 1 To Len(aLayOut)
		Begin Sequence
		lFormula := &(AllTrim(aLayOut[nCntFor,3]))
		If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="H" )
			cBuffer := ""
			For nCntFor2 := 1 To Len(aDetalhe)
				If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
					xConteudo := (AllTrim(aDetalhe[nCntFor2,6]))
					If ( Empty(xConteudo) )
						xConteudo := ""
					Else
						If "NTOTFUNC" $ xConteudo
							xConteudo := &(AllTrim(xConteudo))
							xConteudo := replicate("^",len(xConteudo))
						Elseif "NTOTAL" $ xConteudo .And. lUtilizaMI
							xConteudo := &(AllTrim(xConteudo))
							xConteudo := replicate("#",len(xConteudo))
						Else
							xConteudo := &(AllTrim(xConteudo))
						EndIf
					EndIf
					nPosIni   := Val(aDetalhe[nCntFor2,3])
					nPosFim   := Val(aDetalhe[nCntFor2,4])
					nDecimal  := Val(aDetalhe[nCntFor2,5])
					If "NTOTAL" $ aDetalhe[nCntFor2,6] .And. lUtilizaMI
						nDecTotal:=nDecimal
					EndIF
					nTamanho  := nPosFim-nPosIni+1
					Do Case
						Case ValType(xConteudo) == "D"
							xConteudo := GravaData(xConteudo,.F.)
						Case ValType(xConteudo) == "N"
							xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
					EndCase
					xConteudo := SubStr(xConteudo,1,nTamanho)
					xConteudo := PadR(xConteudo,nTamanho)
					cBuffer += xConteudo
				EndIf
			Next nCntFor2
			cBuffer += Chr(13)+Chr(10)
			If FwIsInCallStack("FINA150")
				F150Write(nHandle,cBuffer,Len(cBuffer))
			else
				FWrite(nHandle,cBuffer,Len(cBuffer))
			EndIf
		EndIf
		End Sequence
	Next nCntFor
	ErrorBlock(bBlock)
Endif
Return(nHandle)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DETCNAB2

CNAB Modelo 2 - Inseri as linhas de detalhe do CNAB Modelo 2.
Arquivo original: MATXFUNB.PRX

@Author	Eduardo Riera
@since 16/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function DetCnab2(nHandle,cLayOut,lIdCnab,cAlias)

Local nHdlLay	 := 0
Local lContinua := .T.
Local cBuffer	 := ""
Local aLayOut	 := {}
Local aDetalhe  := {}
Local nCntFor	 := 0
Local nCntFor2  := 0
Local lFormula  := ""
Local nPosIni	 := 0
Local nPosFim	 := 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	 := ErrorBlock()
Local aGetArea  := GetArea()
Local cChaveID  := ""
Local cIdCnab
Local aArea
Local nOrdem

Default cAlias 	:= ""
Default lIdCnab 	:= .F.
Private xConteudo := ""

nQtdLinLote := If(Type("nQtdLinLote") != "N", 0, nQtdLinLote)
nQtdLnLote  := If(Type("nQtdLnLote")  != "N", 0, nQtdLnLote)

If ( File(cLayOut) )
	nHdlLay := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHdlLay,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,3,1) == "D" )
					aadd(aLayOut,{ SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,30),;
					SubStr(cBuffer,35,255)})
				EndIf
			Else
				If ( SubStr(cBuffer,3,1) == "D" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHdlLay)
EndIf
If nHandle > 0
	For nCntFor := 1 To Len(aLayOut)
		Begin Sequence
		lFormula := &(AllTrim(aLayOut[nCntFor,3]))

		If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="D" )
			cBuffer := ""
			// So gera outro identificador, caso o titulo ainda nao o tenha, pois pode ser um re-envio do arquivo
			If !Empty(cAlias) .And. lIdCnab .And. Empty((cAlias)->&(Right(cAlias,2)+"_IDCNAB"))
				// Gera identificador do registro CNAB no titulo enviado
				cIdCnab := GetSxENum(cAlias, Right(cAlias, 2 ) + "_IDCNAB", Right(cAlias,2) + "_IDCNAB" + cEmpAnt, nOrdem)
				nOrdem := If(Alltrim(Upper(cAlias)) == "SE1",19,13)
				cChaveID := cIdCnab

				// Garante que o identificador gerado nao existe na base
				dbSelectArea(cAlias)
				aArea := (cAlias)->(GetArea())
				dbSetOrder(nOrdem)

				While (cAlias)->(MsSeek(cChaveID))
					ConOutR("Id CNAB " + cIdCnab + " já existe para o arquivo " + cAlias + ". Gerando novo número ")

					If ( __lSx8 )
						ConfirmSX8()
					EndIf

					cIdCnab	:= GetSxENum(cAlias, Right(cAlias,2)+"_IDCNAB",Right(cAlias,2)+"_IDCNAB"+cEmpAnt,nOrdem)
					cChaveID := cIdCnab

				EndDo

				//+----------------------------------------------------------+
				//¦ Ponto de entrada para tratamento da variavel cIdCnab     ¦
				//+----------------------------------------------------------+
				If lF420ICNB
					cIdCnab := ExecBlock("F420ICNB",.F.,.F.,{cIdCnab})
				EndIf

				(cAlias)->(RestArea(aArea))
				Reclock(cAlias)
				(cAlias)->&(Right(cAlias,2)+"_IDCNAB") := cIdCnab
				MsUnlock()
				ConfirmSx8()
				lIdCnab := .F. // Gera o identificacao do registro CNAB apenas uma vez no titulo enviado
			Endif

			For nCntFor2 := 1 To Len(aDetalhe)
				If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
					xConteudo := aDetalhe[nCntFor2,6]
					If ( Empty(xConteudo) )
						xConteudo := ""
					Else
						xConteudo := &(AllTrim(xConteudo))
					EndIf
					nPosIni   := Val(aDetalhe[nCntFor2,3])
					nPosFim   := Val(aDetalhe[nCntFor2,4])
					nDecimal  := Val(aDetalhe[nCntFor2,5])
					nTamanho  := nPosFim-nPosIni+1
					Do Case
						Case ValType(xConteudo) == "D"
							xConteudo := GravaData(xConteudo,.F.)
						Case ValType(xConteudo) == "N"
							xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
					EndCase
					xConteudo := SubStr(xConteudo,1,nTamanho)
					xConteudo := PadR(xConteudo,nTamanho)
					cBuffer += xConteudo
				EndIf
			Next nCntFor2

			cBuffer += Chr(13)+Chr(10)
			If FwIsInCallStack("FINA150")
				F150Write(nHandle,cBuffer,Len(cBuffer))
			else
				FWrite(nHandle,cBuffer,Len(cBuffer))
			EndIf
			nQtdLinLote++
		EndIf
		End Sequence
	Next nCntFor
	ErrorBlock(bBlock)
Endif
RestArea(aGetArea)
Return(.T.)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RODACNAB2

CNAB Modelo 2 -  Fecha o arquivo CNAB Modelo 2.
Arquivo original: MATXFUNB.PRX

@param nHandle - handle do arquivo criado pela HeadCnab2
@param cLayout - nome do arquivo de configuração
@param lQuebra

@Author	Eduardo Riera
@since 16/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function RodaCnab2(nHandle,cLayOut,lQuebra)

Local nHdlLay	:= 0
Local lContinua	:= .T.
Local cBuffer	:= ""
Local aLayOut	:= {}
Local aDetalhe  := {}
Local nCntFor	:= 0
Local nCntFor2  := 0
Local lFormula  := .F.
Local nPosIni	:= 0
Local nPosFim	:= 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	:= ErrorBlock()

//-- Variaveis para tratamento de geracao de Chr(10) + Chr(13) para ultima linha gerada
Local nLHead 	:= nCntFor
Local nLDet		:= nCntFor2
Local nLUltLin	:= nCntFor2

//-- Determina se gera Chr(10) + Chr(13) para as linhas geradas
DEFAULT	lQuebra	:= .T.

Private xConteudo := ""

If ( File(cLayOut) )
	nHdlLay := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHdlLay,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,3,1) == "T" )
					aadd(aLayOut,{ SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,30),;
					SubStr(cBuffer,35,255)})

				EndIf
			Else
				If ( SubStr(cBuffer,3,1)=="T" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHdlLay)
EndIf
aSort(aLayOut,,,{|x,y| x[1]>y[1]})
If nHandle > 0

	//-- Obtem a ultima posicao da linha gerada no arquivo
	IF !lQuebra
		For nCntFor := 1 To Len(aLayOut)
			Begin Sequence
			lFormula := &(aLayOut[nCntFor,3])
			If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
				cBuffer := ""
				For nCntFor2 := 1 To Len(aDetalhe)
					If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
						xConteudo := (aDetalhe[nCntFor2,6])
						If ( Empty(xConteudo) )
							xConteudo := ""
						Else
							xConteudo := &(AllTrim(xConteudo))
						EndIf
						nPosIni   := Val(aDetalhe[nCntFor2,3])
						nPosFim   := Val(aDetalhe[nCntFor2,4])
						nDecimal  := Val(aDetalhe[nCntFor2,5])
						nTamanho  := nPosFim-nPosIni+1
						Do Case
							Case ValType(xConteudo) == "D"
								xConteudo := GravaData(xConteudo,.F.)
							Case ValType(xConteudo) == "N"
								xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
						EndCase
						xConteudo := SubStr(xConteudo,1,nTamanho)
						xConteudo := PadR(xConteudo,nTamanho)
						cBuffer += xConteudo
						//- Obtem a ultima posicao da linha gerada no arquivo
					 	nLDet	:= nCntFor2
					 	nLHead 	:= nCntFor
					EndIf
				Next nCntFor2

			EndIf
			End Sequence
		Next nCntFor
	Endif

 	nLUltLin:= 0

	For nCntFor := 1 To Len(aLayOut)
		Begin Sequence
		lFormula := &(aLayOut[nCntFor,3])
		If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
			cBuffer := ""
			For nCntFor2 := 1 To Len(aDetalhe)
				If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
					xConteudo := (aDetalhe[nCntFor2,6])
					If ( Empty(xConteudo) )
						xConteudo := ""
					Else
						xConteudo := &(AllTrim(xConteudo))
					EndIf
					nPosIni   := Val(aDetalhe[nCntFor2,3])
					nPosFim   := Val(aDetalhe[nCntFor2,4])
					nDecimal  := Val(aDetalhe[nCntFor2,5])
					nTamanho  := nPosFim-nPosIni+1
					Do Case
						Case ValType(xConteudo) == "D"
							xConteudo := GravaData(xConteudo,.F.)
						Case ValType(xConteudo) == "N"
							xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
					EndCase
					xConteudo := SubStr(xConteudo,1,nTamanho)
					xConteudo := PadR(xConteudo,nTamanho)
					cBuffer += xConteudo
					nLUltLin:= nCntFor2
				EndIf

			Next nCntFor2

			//-- Gera Chr(13)+Chr(10) para todas as linhas ou para as N-1 linhas
			If ( lQuebra ) .OR. ( !lQuebra .AND. !( (nLUltLin == nLDet) .and. (nCntFor == nLHead)) )
				cBuffer += Chr(13)+Chr(10)
			EndIf
			If FwIsInCallStack("FINA150")
				F150Write(nHandle,cBuffer,Len(cBuffer))
			Else
				FWrite(nHandle,cBuffer,Len(cBuffer))
			EndIf
		EndIf
		End Sequence
	Next nCntFor

	ErrorBlock(bBlock)
	If FwIsInCallStack("FINA150")
		if len(cBuffWrite) > 0
			fwrite(nHandle,cBuffWrite)
			cBuffWrite := ''
		endif
	endif
	FClose(nHandle)
Endif
Return(.T.)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RODALOTE2

CNAB Modelo 2 -  Gera Trailler de Lote CNAB Modelo  2.
Arquivo original: MATXFUNB.PRX

@param nHandle - handle do arquivo criado pela HeadCnab2
@param cLayout - nome do arquivo de configuração

@Author	Claudio DOnizete
@since 27/12/2005
/*/
//-----------------------------------------------------------------------------------------------------
Function RodaLote2(nHandle,cLayOut)

Local nHdlLay	 := 0
Local lContinua := .T.
Local cBuffer	 := ""
Local aLayOut	 := {}
Local aDetalhe  := {}
Local nCntFor	 := 0
Local nCntFor2  := 0
Local lFormula  := .F.
Local nPosIni	 := 0
Local nPosFim	 := 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	 := ErrorBlock()

Private xConteudo := ""

If ( File(cLayOut) )
	nHdlLay := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHdlLay,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,2,1) != "0" )		 //	If ( SubStr(cBuffer,2,1)=="1" )
					If ( SubStr(cBuffer,3,1) == "T" )
						aadd(aLayOut,{ SubStr(cBuffer,02,03),;
						SubStr(cBuffer,05,30),;
						SubStr(cBuffer,35,255)})
					EndIf
				Endif
			Else
				If ( SubStr(cBuffer,3,1)=="T" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHdlLay)
EndIf
aSort(aLayOut,,,{|x,y| x[1]>y[1]})
If nHandle > 0
	For nCntFor := 1 To Len(aLayOut)
		Begin Sequence
		lFormula := &(aLayOut[nCntFor,3])
		If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
			cBuffer := ""
			For nCntFor2 := 1 To Len(aDetalhe)
				If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
					xConteudo := (aDetalhe[nCntFor2,6])
					If ( Empty(xConteudo) )
						xConteudo := ""
					Else
						xConteudo := &(AllTrim(xConteudo))
					EndIf
					nPosIni   := Val(aDetalhe[nCntFor2,3])
					nPosFim   := Val(aDetalhe[nCntFor2,4])
					nDecimal  := Val(aDetalhe[nCntFor2,5])
					nTamanho  := nPosFim-nPosIni+1
					Do Case
						Case ValType(xConteudo) == "D"
							xConteudo := GravaData(xConteudo,.F.)
						Case ValType(xConteudo) == "N"
							xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
					EndCase
					xConteudo := SubStr(xConteudo,1,nTamanho)
					xConteudo := PadR(xConteudo,nTamanho)
					cBuffer += xConteudo
				EndIf
			Next nCntFor2
			cBuffer += Chr(13)+Chr(10)
			If FwIsInCallStack("FINA150")
				F150Write(nHandle,cBuffer,Len(cBuffer))
			Else
				FWrite(nHandle,cBuffer,Len(cBuffer))
			EndIf
		EndIf
		End Sequence
	Next nCntFor
	ErrorBlock(bBlock)
Endif
Return(.T.)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SOMAABAT

Soma todos os titulos de abatimento ate uma data limite
Arquivo original: MATXFUNB.PRX

@Author	Eduardo Riera
@since 17/03/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function SomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat,dDataRef,cTipo)

Local cProcedure := GetSPName("FIN001","08") //'SUMABAT'
Local aResult
Local nTotAbat 	:= 0
Local cNoOrdPago := ""
Default cTipo:= ""

Default __lPFin001 := ExistProc(cProcedure, EngSPS08Signature())

nMoeda	 := If( nMoeda	 == NIL, 1 ,nMoeda )
dData  	 := If( dData	 == NIL, dDataBase,dData )
cFilAbat := If( cFilAbat == NIL, If( cCart == "R", xFilial("SE1"),xFilial("SE2")), cFilAbat)
cFornCli := If( cFornCli == Nil, If( cCart == "R", SE1->E1_CLIENTE, SE2->E2_FORNECE), cFornCli)
cLoja    := If( cLoja	 == Nil, If( cCart == "R", SE1->E1_LOJA, SE2->E2_LOJA), cLoja)
dDataRef := If( dDataRef == NIL, dDataBase, dDataRef )
cTipo	 := If( Empty(cTipo), If( cCart=="R", SE1->E1_TIPO, SE2->E2_TIPO), cTipo)
cNoOrdPago := IIf(FwIsInCallStack("FINA085A") .Or. FwIsInCallStack("FINA850"), "0", "1")

If __lPFin001 .and. !(FwIsInCallStack("FINR340")) .and. !Empty(cNumero)

	// Define banco de dados para procedure SomaAbat utilizar sintaxe correta ("||" ou "+")
	If __cBD == Nil
		__cBD := IIf((Alltrim(Upper(TcGetDb()))) $ 'ORACLE.POSTGRES.DB2.INFORMIX' ,'2','1')
	EndIf

	If cCart == "R"	.and. !Empty(SE1->E1_TITPAI)
		If(Alltrim(SE1->E1_TITPAI) == Alltrim(cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja))
			aResult := TCSPEXEC(xProcedures(cProcedure), cPrefixo,;
					     cNumero, cParcela, cCart,nMoeda,DTOS(dData),cFornCli,cLoja,cFilAbat,;
						  DTOS(dDataRef), cTipo, __cBD, cNoOrdPago)
			Return aResult[1]
		Else
			Return nTotAbat
		EndIf
	Else
		aResult := TCSPEXEC(xProcedures(cProcedure), cPrefixo,;
				     cNumero, cParcela, cCart,nMoeda,DTOS(dData),cFornCli,cLoja,cFilAbat,;
					  DTOS(dDataRef), cTipo, __cBD, cNoOrdPago)
		Return Iif( ValType(aResult) == "A" .And. Len(aResult) > 0, aResult[1], nTotAbat )
	Endif
Else
	Return xSomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat, dDataRef, cTipo)
EndIf


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} XSOMAABAT

Soma todos os titulos de abatimento ate uma data limite (Filha da SomaAbat).
Arquivo original: MATXFUNB.PRX

@Author	TOTVS
@since 17/03/1998
/*/
//-----------------------------------------------------------------------------------------------------

Static Function xSomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat, dDataRef, cTipo)

	Local nTotAbat  := 0
	Local cAliasAbt := Alias()
	Local nOrdem    := indexord()
	//controle de abatimento pelo titpai
	Local cAliasSoma := GetNextAlias()
	Local cAbatiment

	DEFAULT cCart    := If(cCart="R",cCart,"P")
	DEFAULT nMoeda   := 1
	DEFAULT dData    := dDataBase
	DEFAULT cFilAbat := If(cCart=="R", xFilial("SE1"), xFilial("SE2"))
	DEFAULT cFornCli := If(cCart=="R", SE1->E1_CLIENTE, SE2->E2_FORNECE)
	DEFAULT cLoja    := If(cCart=="R", SE1->E1_LOJA, SE2->E2_LOJA)
	DEFAULT cTipo	 := If(cCart=="R", SE1->E1_TIPO, SE2->E2_TIPO)
	DEFAULT dDataRef := dDataBase
	Default cTipo:= ""

	If cCart == "R"
		If Select("__SE1") == 0
			ChkFile("SE1",.F.,"__SE1")
		Else
			DbSelectArea("__SE1")
		EndIf
		cAbatiment := " E1_TIPO LIKE '%-' "
		IF FwIsInCallStack("FINR340")
			cAbatiment := "("+cAbatiment + " OR E1_TIPO = '"+MVIRF+"')"
		EndIf

		cAbatiment := "%" + cAbatiment + "%"

		BeginSql Alias cAliasSoma
		Column EMISSAO As Date
		select E1_EMISSAO EMISSAO, E1_TIPO TIPO,E1_MOEDA MOEDA, E1_TXMOEDA TXMOEDA, E1_VALOR VALOR, E1_SALDO SALDO
			from %Table:SE1% SE1
			where E1_FILIAL    = %Exp:cFilAbat%
			and E1_PREFIXO   = %Exp:cPrefixo%
			and E1_NUM       = %Exp:cNumero%
			and E1_PARCELA   = %Exp:cParcela%
			and %Exp:cAbatiment%
			and (E1_CLIENTE  = %Exp:cFornCli% or E1_CLIENTE  = 'UNIAO ')
			and (E1_LOJA     = %Exp:cLoja%    or E1_CLIENTE  = 'UNIAO ')
			and E1_EMISSAO  <= %Exp:dDataRef%
			and E1_TITPAI	   = %Exp:cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja%
			AND SE1.%NotDel%
		EndSql
	ELSE
		IF SELECT("__SE2") == 0
			ChkFile("SE2",.F.,"__SE2")
		Else
			DbSelectArea("__SE2")
		EndIf
		cAbatiment := " E2_TIPO LIKE '%-' "

		cAbatiment := "%" + cAbatiment + "%"

		//Verifico há o FINA340 ou do FINC050 na pilha de chamadas e, se tiver, olha a E2_TITPAI para vincular corretamente o abatimento.
		//Valida o E2_TITPAI, pois no legado há títulos de abatimento sem ele.
		If FWIsInCallStack("FINA340") .OR. FWIsInCallStack("FC050CON")

			BeginSql Alias cAliasSoma
			Column EMISSAO As Date
			select E2_EMISSAO EMISSAO, E2_TIPO TIPO,E2_MOEDA MOEDA, E2_TXMOEDA TXMOEDA, E2_VALOR VALOR, E2_SALDO SALDO
			from %Table:SE2% SE2
			where E2_FILIAL   = %Exp:cFilAbat%
				and E2_PREFIXO  = %Exp:cPrefixo%
				and E2_NUM      = %Exp:cNumero%
				and E2_PARCELA  = %Exp:cParcela%
				and %Exp:cAbatiment%
				and E2_FORNECE  = %Exp:cFornCli%
				and E2_LOJA     = %Exp:cLoja%
				and E2_EMISSAO <= %Exp:dDataRef%
				and E2_TITPAI	 = %Exp:cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja%
				and SE2.%NotDel%
			EndSql

		Else 

			BeginSql Alias cAliasSoma
			Column EMISSAO As Date
			select E2_EMISSAO EMISSAO, E2_TIPO TIPO,E2_MOEDA MOEDA, E2_TXMOEDA TXMOEDA, E2_VALOR VALOR, E2_SALDO SALDO
			from %Table:SE2% SE2
			where E2_FILIAL   = %Exp:cFilAbat%
				and E2_PREFIXO  = %Exp:cPrefixo%
				and E2_NUM      = %Exp:cNumero%
				and E2_PARCELA  = %Exp:cParcela%
				and %Exp:cAbatiment%
				and E2_FORNECE  = %Exp:cFornCli%
				and E2_LOJA     = %Exp:cLoja%
				and E2_EMISSAO <= %Exp:dDataRef%
				and SE2.%NotDel%
			EndSql
		EndIf
	ENDIF
	DbSelectArea(cAliasSoma)


	While (cAliasSoma)->(!Eof())
		//----------------------------------------------------------------------
		// Validacao inserida para o processo de baixa parcial da Ordem de Pago
		// evitando que o titulo de abatimento seja descontado mais de uma vez
		//----------------------------------------------------------------------
		If (cAliasSoma)->SALDO > 0 .Or. !(FwIsInCallStack("FINA085A") .Or. FwIsInCallStack("FINA850"))
			nTotAbat += xMoeda((cAliasSoma)->VALOR,(cAliasSoma)->MOEDA,nMoeda,;
						Iif(AllTrim((cAliasSoma)->TIPO) == "IR-", (cAliasSoma)->EMISSAO, dData),,If(cPaisLoc=="BRA",(cAliasSoma)->TXMOEDA,0))
		EndIf
		(cAliasSoma)->(dbSkip())
	EndDo
	(cAliasSoma)->(dbCloseArea())

	If !Empty(cAliasAbt)
		DbSelectArea(cAliasAbt)
		DbSetOrder(nOrdem)
	Endif

Return(nTotAbat)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DTMOVFIN

Data limite para realização de Movimento no Financeiro.
Arquivo original: MATXFUNB.PRX

@Author	Mauricio Pequim Jr.
@since 06/11/1997
/*/
//-----------------------------------------------------------------------------------------------------
Function DtMovFin(dData As Date, lHelp As Logical, cFunct As Character, lContaEmis As Logical)
	Local lRet     As Logical
	Local lValBloq As Logical

	//Parâmetros de entrada.
	Default dData      := dDatabase
	Default lHelp      := .T.
	Default cFunct     := "1"
	Default lContaEmis := .F.

	//Inicializa variáveis
	lRet     := .T.
	lValBloq := (lContaEmis .Or. (cPaisLoc == "MEX" .AND. FunName() == "FISA817" .AND. FindFunction("FS817VlCnt")))

	If lFADTMOV == NIL
		lFADTMOV := ExistBlock("FADTMOV")
	Endif

	dDataFin := SuperGetMv("MV_DATAFIN",.T.,StoD("19800101"),cFilAnt)

	If dData < dDataFin .And. !lFADTMOV
		If lHelp
			Help ( " ", 1, "DTMOVFIN")
		EndIf
		lRet:=.F.
	EndIf

	/*Ponto de entrada para controlar datas diferentes para movimento bancario,
	contas a pagar entre outras funcionalidades em que é aplicado a DtMovFin*/
	If lFADTMOV
		lRet :=	ExecBlock("FADTMOV",.F.,.F.,{dData})
	EndIf

	If lRet .And. !lValBloq
		lRet := CtbValiDt(,dData,lHelp,,,IIF(cFunct == "1",{"FIN001"},IIF(cFunct == "2",{"FIN002"},IIF(cFunct == "3",{"FIN001","FIN002"},""))),)
	Endif
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}IsEmpPub
Programa p/ verificar o minimo de irrf e pcc esta configurado
corretamente para empresas publicas.
@author Caique Bispo Ferreira
@since  19/02/2015
/*/
//-------------------------------------------------------------------

Function IsEmpPub()

Local lRet := .F.
Local lEmpPub := SuperGetMv("MV_ISPPUBL" ,.T.,"2") == "1"
Local nVlMinPCC := SuperGetMv("MV_VL10925" ,.T.,5000)
Local nVlMinIR := SuperGetMv("MV_VLRETIR" ,.T.,10)

If lEmpPub .And. nVlMinPCC == 0 .And. nVlMinIR == 0
	lRet := .T.
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fCRetCal
Programa p/ calcular data vencimento de Impostos.

@param nTipo
	1 - diario
	2 - Semanal add 3 dias.
	3 - Decendio add 3 dias.
	4 - Até o ultima dia da Quinzena SubSequente
	5 - Até Dia 20 do mês subsequente
	6 - Até o Décimo quinto dia util do mês subsequente

@param dEmissao -

@author Marjorie
@since  26/02/15
/*/
//-------------------------------------------------------------------
Function fCRetCal(nTipo,dEmissao)

Local nNextMes 	:= 0
Local dData 		:= CtoD("//")
Local nI 			:= 1

Default dEmissao := dDatabase
Default nTipo := 0

dData 				:= dEmissao
nNextMes 			:= Month(dData) + 1

If nTipo == 1
	//na data de ocorrência
	dData	:= dData

ElseIf nTipo == 2
	//Semanal add 3 dias.
	For nI:=1 To 7
		If Dow( dData ) = 1
			Exit
		End
		dData++
	Next nI

ElseIf nTipo == 3
	//Decendio add 3 dias.
	If Day(dData) >= 1 .And. Day(dData) <= 10
		dData := CTOD("11/"+StrZero(Month(dData),2)+"/"+Str(Year(dData)))
	ElseIf Day(dData) >= 11 .And. Day(dData) <= 20
		dData := CTOD("21/"+StrZero(Month(dData),2)+"/"+Str(Year(dData)))
	Else
		dData := CTOD("01/"+If(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
					Str(If(nNextMes==13,Year(dData)+1,Year(dData))))
	EndIf

ElseIf nTipo == 4
	//Até o ultima dia da Quinzena SubSequente
	If Day(dData) <= 15
		dData := CTOD("01/"+;  //dia
		Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+; //mes
			Substr(Str(Iif(nNextMes==13,Year(dData)+1,Year(dData))),2))    //ano
	Else
		dData := CTOD("16/"+;  //dia
		Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+; //mes
			Substr(Str(Iif(nNextMes==13,Year(dData)+1,Year(dData))),2))    //ano

	EndIf
	dData -= 1

ElseIf nTipo == 5
	//Até Dia 20 do mês subsequente
	dData := CTOD("20/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/";
			+Substr(Str(Iif(nNextMes==13,Year(dData)+1,Year(dData))),2))
ElseIf nTipo == 6
	//Até o décimo quinto dia util do mês subsequente
	dData := CTOD("15/"+;  //dia
		Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+; //mes
			Substr(Str(Iif(nNextMes==13,Year(dData)+1,Year(dData))),2))    //ano
EndIf


//Valida Data Valida
If nTipo == 5 .Or. nTipo == 4 .Or. nTipo == 6
	//Subtrai dia
	While .T.
		If DataValida(dData,.T.) == dData
			Exit
		Else
			dData -= 1
		Endif
	Enddo

ElseIf nTipo == 2 .Or. nTipo == 3
	//Adiciona 3 dias.
	nI := 1
	While nI <= 3
		If DataValida(dData,.T.) == dData
			If nI < 3
				dData += 1
			EndIf
			nI +=1
		Else
			dData += 1
		Endif
	EndDo
EndIf

Return dData

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ LerLinha ³ Autor ³ J£lio Wittwer         ³ Data ³ 20.12.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Le mais uma linha do Arquivo de Retorno CNAB               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ cRet := LerLinha(nHandleRet)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ ReadCnab2()                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Static Function LerLinha(nHandle,nMaxLn)
Local cString	:= ""
Local nTotLidos	:= 0
Local lCRLF		:= .T.

Default nMaxLn := 1000

cString := Space(nMaxLn)
FReadLn(nHandle, @cString, nMaxLn, @lCRLF) // Le uma linha ate CR+LF.

//Se a linha possuir CRLF no seu final
If lCRLF
	nTotLidos := Len(cString)+2
//Se a linha NAO possuir CRLF no seu final
Else
	nTotLidos := Len(cString)
Endif

Return {cString,nTotLidos}

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinaCONC
faz a concatenação das mensagens de LOG para criação de Histórico de Cobrança
@author Alexandre Felicio
@since  02/07/2015
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Function FinaCONC(aAlt As Array, cAlias As Character)
Local nCx           As Numeric
Local cHistorico    As Character
Local cProcesso     As Character

Default cAlias      := Alias() //Procura chave do titulo SE1 ou SE2
//Rotinas do ADM que devem ser revisadas para subir passando alias FIN887EventDEF, FINA040, FINA050, FINA060, FINA061, FINA070, FINA080, FINA110
//FINA330, FINA450, FINA460, FINA460a, FINA590, FINA620, FINA630, FINA770, FINA771, FINA087A

nCx         := 0
cHistorico  := ''
cProcesso   := ''

For nCx := 1 to LEN(aAlt)

    cProcesso := aAlt[nCx][1]

    If !Empty(aAlt[nCx][2])
	    cHistorico += aAlt[nCx][2] + CRLF
	endif
	If !Empty(aAlt[nCx][3])
	    cHistorico += aAlt[nCx][3] + CRLF
	endif
	If !Empty(aAlt[nCx][4])
	    cHistorico += aAlt[nCx][4] + CRLF
	endif
	 If !Empty(aAlt[nCx][5])
	    cHistorico += aAlt[nCx][5] + CRLF
	endif

	cHistorico += CRLF

Next nCx

FinaLog(cProcesso,cHistorico, cAlias)

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinaLog
Faz inclusão de registros de LOG a partir do Processo e Histórico informados
@author Alexandre Felicio
@since  01/07/2015
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Function FinaLog(cProcesso As Character, cHistorico As Character, cAlias As Character)
Local cIdDoc    As Character
Local cIdCV8    As Character
Local cChaveTit As Character
Local cFilOrig  As Character
Local cAliasAtu As Character

Default cProcesso  := ''
Default cHistorico := ''
Default cAlias      := Alias()

cIdDoc      := ''
cIdCV8      := ''
cChaveTit   := ''
cFilOrig    := ''
cAliasAtu   := cAlias

//Validar se e criacao de bordero
If cAliasAtu == "SEA"
	If SEA->EA_CART == "R"
		cAliasAtu := "SE1"
	ElseIf SEA->EA_CART == "P"
		cAliasAtu := "SE2"
	EndIf
EndIf

If !Empty(cProcesso) .and. !Empty(cHistorico)
	//Obtenho o ID do título
	//Dados da tabela auxiliar com o código do título a receber
	If cAliasAtu == "SE1"
		cChaveTit := xFilial("SE1", SE1->E1_FILORIG) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" +;
					 SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
		cFilOrig := SE1->E1_FILORIG
	ElseIf cAliasAtu == "SE2"
		cChaveTit := xFilial("SE2", SE2->E2_FILORIG) + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" +;
					 SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
		cFilOrig := SE2->E2_FILORIG
	EndIf

	If cAliasAtu $ "SE1|SE2"
		cIdDoc := FINGRVFK7(cAliasAtu, cChaveTit)

		//Gravo o log para histórico do título
		ProcLogIni( {}, cIdDoc,   , @cIdCV8 )
		ProcLogAtu( "MENSAGEM", cProcesso, cHistorico, , .T., cFilOrig )
	EndIf
EndIf

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINSEQFK1

Encontra a proxima sequencia para o movto bancario (CR)

@Author	TOTVS
@since	15/09/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FinSeqFK1()
Local aArea			:= GetArea()
Local cIDFK1		:= ""
Local cChave		:= ""
Local cAliasFK1		:= GetNextAlias()
Local cSequencia	:= ""

//Inicializa Staticas
If nTamSeq == NIL
	nTamSeq		:= TamSX3("FK1_SEQ")[1]
Endif
cSequencia	:= Replicate("0",nTamSeq)

cChave :=	XFilial("SE1")+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+;
			SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA

cIDFK1 := FINBuscaFK7(cChave, "SE1")

BeginSQL Alias cAliasFK1
	SELECT MAX(FK1_SEQ) FK1_SEQ
	FROM	%Table:FK1% FK1
	WHERE	FK1.FK1_FILIAL = %XFilial:FK1%
			AND FK1.FK1_IDDOC = %Exp:cIDFK1%
			AND FK1.%NotDel%
EndSQL

If !(cAliasFK1)->(Eof())
	cSequencia := Left((cAliasFK1)->FK1_SEQ,nTamSeq) //left incluido para corrigir problema em banco postgres - nao remover
EndIf

(cAliasFK1)->(DbCloseArea())

cSequencia := Soma1(cSequencia,nTamSeq)

RestArea(aArea)

Return cSequencia


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINSEQFK5

Encontra a proxima sequencia para o movto bancario (CR) - Compensação de cheques CR

@Author	TOTVS
@since	15/09/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FinSeqFK5()
Local aArea			:= GetArea()
Local cAliasFK5		:= GetNextAlias()
Local cSequencia	:= ""

cChave :=	XFilial("SE1")+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+;
			SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA

cIdDoc := FINBuscaFK7(cChave, "SE1")

//Inicializa Staticas
If nTamSeq == NIL
	nTamSeq		:= TamSX3("FK5_SEQ")[1]
Endif
cSequencia	:= Replicate("0",nTamSeq)

BeginSQL Alias cAliasFK5
	SELECT MAX(FK5_SEQ) FK5_SEQ
	FROM	%Table:FK5% FK5
	WHERE	FK5.FK5_FILIAL = %XFilial:FK5%
			AND FK5.FK5_IDDOC  = %Exp:cIdDoc%
			AND FK5.%NotDel%
EndSQL

If !(cAliasFK5)->(Eof())
	cSequencia := Left((cAliasFK5)->FK5_SEQ,nTamSeq) //left incluido para corrigir problema em banco postgres - nao remover
EndIf

(cAliasFK5)->(DbCloseArea())

cSequencia := Soma1(cSequencia,nTamSeq)

RestArea(aArea)

Return cSequencia



//-------------------------------------------------------------------
/*/{Protheus.doc} IsIssBx
Programa p/ verificar se o Iss está na baixa.

@author TOTVS S/A
@since  08/04/15
/*/
//-------------------------------------------------------------------
Function IsIssBx(cCart)

Local lCalcIssBx := .F.
Default cCart := "P"

If cPaisLoc == "BRA"
	If cCart == "P"
		lCalcIssBx := SuperGetMv("MV_MRETISS",.F.,"1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)
	EndIf
EndIf

Return lCalcIssBx


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinRetSix
Apresenta uma lista com os índices de uma determinada tabela, permitindo a seleção para o uso, por
exemplo, na indexação de arquivos temporários. A lista é feita a partir do dicionário de dados (SIX).

@param cAlias - Alias do arquivo do qual serão selecionados os índices.
@param aIndices - Array onde serão colocados os índices selecionados (enviar "por referência"). Cada
elemento (array) possui a seguinte estrutura:
ordem do índice, descrição (campo1 + campo2 + ...), expressão do índice, campos que formam o índice (array).
@param cMsg - texto explicativo

@return true - se há índice selecionado; false - não há índice selecinado.

@Author	Marcello Gabriel
@since	29/10/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FinRetSix(cAlias, aIndices, cMsg, lCancela, nF240Index)
	Local nX			:= 0
	Local aTitulos		:= {}
	Local aChaves		:= {}
	Local aCampos		:= {}
	Local aCposAlias	:= {}
	Local cTitulo		:= ""
	Local cDesc			:= ""
	Local cCampo		:= ""
	Local cCposInd		:= ""
	Local oPnlMaster	:= Nil
	Local oPnlMsg		:= Nil
	Local oDlg			:= Nil
	Local oSize			:= Nil
	Local oBrwSix		:= Nil
	Local oOk 			:= Nil
	Local oNo 			:= Nil
	Local lF240IND		:= ExistBlock("F240IND") .And. FwIsInCallStack('FINA240')
	Local nF240Ind  	:= 0
	Local cIndexSE2		:= ""

	Default aIndices	:= {}
	Default lCancela 	:= .F.
	Default cAlias		:= ""
	Default cMsg		:= STR0075		//"Selecione o(s) índice(s) desejado(s)."
	Default nF240Index	:= 0

	aIndices := {}

	cAlias := AllTrim(cAlias)

	If SIX->(DbSeek(cAlias))
		While !(SIX->(Eof())) .And. SIX->INDICE == cAlias
			aCampos := StrToKArr(SIX->CHAVE,"+")
			aTitulos := StrToKArr(SixDescricao(),"+")

			cDesc := ""
			aCposAlias := {}
			cCposInd := ""
			For nX := 1 To Len(aCampos)
				cCampo := FinExtCpo(cAlias,aCampos[nX])
				cCposInd += cCampo + "+"
				If nX > 1
					cDesc += " + "
				Endif
				cTitulo := AllTrim(SX3->(RetTitle(cCampo)))
				If Empty(cTitulo)
					cDesc += AllTrim(aTitulos[nX - 1])
				Else
					cDesc += cTitulo
				Endif
				Aadd(aCposAlias,cCampo)
			Next
			Aadd(aChaves,{.F.,cDesc,Substr(cCposInd,1,Len(cCposInd)-1)/*SIX->CHAVE*/,Aclone(aCposAlias)})
			SIX->(DbSkip())
		Enddo

		oSize := FwDefSize():New(.T.)
		oSize:lLateral := .F.
		oSize:AddObject("MASTER",100,100,.T.,.T.)
		oSize:lProp := .T.
		oSize:Process()

		oOk := LoadBitmap( GetResources(), "LBOK" )
		oNo := LoadBitmap( GetResources(), "LBNO" )
		DEFINE MSDIALOG oDlg TITLE STR0076 From oSize:aWindSize[1]*0.6,oSize:aWindSize[2]*0.6 To oSize:aWindSize[3]*0.6,oSize:aWindSize[4]*0.6 OF oMainWnd PIXEL //"Índices"
			oSize := FwDefSize():New(.T.,,,oDlg)
			oSize:lLateral := .F.
			oSize:AddObject("MENSAGEM",100,15,.T.,.T.)
			oSize:AddObject("MASTER",100,85,.T.,.T.)
			oSize:lProp := .T.
			oSize:Process()

			oPnlMsg := TPanel():New(oSize:GetDimension("MENSAGEM","LININI"),oSize:GetDimension("MENSAGEM","COLINI"),cMsg,oDlg,, .F., .F.,, ,oSize:GetDimension("MENSAGEM","XSIZE"),oSize:GetDimension("MENSAGEM","YSIZE"))

			oPnlMaster := TPanel():New(oSize:GetDimension("MASTER","LININI"),oSize:GetDimension("MASTER","COLINI"),,oDlg,, .T., .T.,, ,oSize:GetDimension("MASTER","XSIZE"),oSize:GetDimension("MASTER","YSIZE"))
				oBrwSix:= TCBrowse():New(0,0,10,10,,,,oPnlMaster,,,,,,,,,,,,,,.T.,,,,.T.,)
					oBrwSix:AddColumn(TCColumn():New("  ",{|| If(aChaves[oBrwSix:nAt,1],oOk,oNo)},,,,,010,.T.,.F.,,,,,))
					oBrwSix:AddColumn(TCColumn():New("Índices",{|| aChaves[oBrwSix:nAt,2]},,,,,040,.F.,.F.,,,,,))
					oBrwSix:Align := CONTROL_ALIGN_ALLCLIENT
					oBrwSix:SetArray(aChaves)
					oBrwSix:bLDblClick := {|| aChaves[oBrwSix:nAT,1] := !aChaves[oBrwSix:nAT,1]}
					oBrwSix:Refresh()
		ACTIVATE DIALOG oDlg ON INIT (EnchoiceBar(oDlg,{|| oDlg:End()},{|| lCancela:= .T. ,oDlg:End()},,,,,.F.,.F.,.F.),oBrwSix:Refresh()) CENTERED

		FreeObj(oDlg)
		FreeObj(oBrwSix)
		FreeObj(oSize)
		FreeObj(oPnlMsg)
		FreeObj(oPnlMaster)
		FreeObj(oOk)
		FreeObj(oNo)

		If lF240IND
			nF240Ind := ExecBlock("F240IND", .F., .F., {.F., {}})

			If !(FwSIXUtil():ExistIndex("SE2", (RetAsc(nF240Ind, 1, .T.))))
				nF240Ind := 1
			EndIf

			cIndexSE2 := SE2->(IndexKey(nF240Ind))

			If (nPosChave := AScan(aChaves, {|chave| AllTrim(chave[3]) == AllTrim(cIndexSE2)})) > 0
				aChaves[nPosChave][1] := .T. //Marca índice para que o mesmo seja adicionado no array aIndices
			EndIf
		EndIf

		For nX := 1 To Len(aChaves)
			If aChaves[nX][1]
				AAdd(aIndices, {nX, aChaves[nX][2], aChaves[nX][3], AClone(aChaves[nX][4])})
			EndIf
		Next nX

		If lF240IND
			//Busca posição do índice selecionado via PE para ordenação
			nF240Index := AScan(aIndices, {|indice| indice[1] == nF240Ind})
		Endif

		FwFreeArray(aCampos)
		FwFreeArray(aChaves)
		FwFreeArray(aTitulos)
		FwFreeArray(aCposAlias)
	EndIf

Return (Len(aIndices) > 0)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinCposSix
"Quebra" a expressão dos índices de uma tabela nos campos que os formam. Também, baseado em uma array
de campos, verifica se os dos índices estão nessa array e os inclui caso não estejam.

@param cAlias - Alias do arquivo do qual serão selecionados os índices.
@param aOrdem - Array onde serão colocados os índices "quebrados" (enviar "por referência").
Cada elemento (array) possui a seguinte estrutura: descrição (campo1 + campo2 + ...), Campos (array), expressão do índice.
Estutura da array Campos: "" (vazio),tipo do campo,tamanho,decimais,título,picture
@param aCposBase - Array com os campos dos índices "quebrados".
@param cMsg - Texto explicando o uso dos índices.

@return true - se há índice selecionado; false - não há índice selecinado.

@Author	Marcello Gabriel
@since	29/10/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FinCposSix(cAlias, aOrdem, aCposBase, cMsg, lCancela, lAutomatico, nF240Index)
	Local nCpo		:= 0
	Local nChv		:= 0
	Local aTamSX3	:= {}
	Local aCpos		:= {}
	Local aIndices	:= {}
	Local aArea		:= {}

	Default lCancela 	:= .F.
	Default aCposBase	:= {}
	Default aOrdem		:= {}
	Default cAlias		:= ""
	Default cMsg		:= STR0077 + CRLF + STR0078		//"Selecione os índices que deseja usar na pesquisa para os registros selecionados." ###"Caso nenhum seja selecionado, será considerado o primeiro da lista."
	Default lAutomatico := .F.
	Default nF240Index	:= 0

	If AliasInDic(cAlias)
		aArea := GetArea()
		If !lAutomatico
			FinRetSix(cAlias, @aIndices, cMsg, @lCancela, @nF240Index)
		Endif
		If Empty(aIndices)
			SIX->(DbSeek(cAlias))

			Aadd(aIndices,{1,AllTrim(SX3->(RetTitle("E2_FILIAL"))) + "+" + SixDescricao() ,SIX->CHAVE,{}})

			aCpos := StrToKArr(SIX->CHAVE,"+")
			For nCpo := 1 To Len(aCpos)
				Aadd(aIndices[1,4],FinExtCpo(cAlias,aCpos[nCpo]))
			Next
			Asize(aCpos,0)
		Endif
		For nChv := 1 To Len(aIndices)
			For nCpo := 1 To Len(aIndices[nChv,4])
				aTamSX3 := TamSX3(aIndices[nChv,4,nCpo])
				Aadd(aCpos,{"",ValType(aIndices[nChv,4,nCpo]),aTamSX3[1],aTamSX3[2],AllTrim(SX3->(RetTitle(aIndices[nChv,4,nCpo]))),X3PICTURE(aIndices[nChv,4,nCpo]),aIndices[nChv,4,nCpo]})
				If Ascan(aCposBase,{|ccpo| AllTrim(ccpo) == Alltrim(aIndices[nChv,4,nCpo])}) == 0
					Aadd(aCposBase,aIndices[nChv,4,nCpo])
				Endif
			Next nCpo
			If !Empty(aCpos)
				Aadd(aOrdem,{aIndices[nChv,2],Aclone(aCpos),aIndices[nChv,3]})
			Endif
			Asize(aCpos,0)
		Next nChv
		RestArea(aArea)
		FwFreeArray(aCpos)
		FwFreeArray(aTamSX3)
		FwFreeArray(aArea)
		FwFreeArray(aIndices)
	Endif

Return(Len(aOrdem) > 0)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinExtCpo
Verifica se há um campo de uma tabela em um expressão. Caso haja, retorna o primeiro campoa encontrado.

@param cAlias - Alias do arquivo do qual serão verificados os campos.
@param cCampo - expressão que contém o campo

@return cCpo - primeiro campo encontrado; vazio caso não haja campos na expressão.

@Author	Marcello Gabriel
@since	29/10/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FinExtCpo(cAlias,cCampo)
Local cCpo		:= ""
Local nPos		:= 0
Local cPrefixo	:= ""

cPrefixo := cAlias + "_"
nPos := At(cPrefixo,cCampo)
If nPos == 0
	cPrefixo := Substr(cPrefixo,2)
	nPos := At(cPrefixo,cCampo)
Endif
If nPos > 0
	cCpo := Substr(cCampo,nPos,10)
	nPos := (calias)->(FieldPos(cCpo))
	While nPos == 0 .And. !Empty(cCpo)
		cCpo := AllTrim(Substr(cCpo,1,Len(cCpo) - 1))
		nPos := (calias)->(FieldPos(cCpo))
	Enddo
Endif
Return(cCpo)


//-------------------------------------------------------------------
/*/{Protheus.doc} FINBuscaNF
Função que busca nota fiscal com base nas informações. Utilizado pela nova estrutura do campo Serie.
Retorna o recno da nota para posicionar

@author Alvaro Camillo Neto
@since  03/11/15
/*/
//-------------------------------------------------------------------
Function FINBuscaNF(cFilTit,cDoc,cPrefix,cCliente,cLoja,cTabNF,lPrefix)
Local nRec 	:= 0
Local cQuery	:= ""
Local cTab		:= GetNextAlias()
Local aArea	:= GetArea()

Default cFilTit := cFilAnt
Default lPrefix := .T.

If cTabNF == "SF1"
	cQuery	+= " SELECT R_E_C_N_O_ RECNO " + CRLF
	cQuery	+= " FROM "+RetSQLName("SF1")+" SF1 " + CRLF
	cQuery	+= " WHERE " + CRLF
	cQuery	+= " SF1.F1_FILIAL = '"+xFilial("SF1",cFilTit)+"' AND " + CRLF
	cQuery	+= " SF1.F1_DOC = '"+cDoc+"' AND " + CRLF
	If lPrefix
		cQuery	+= " SF1.F1_PREFIXO = '"+cPrefix+"' AND " + CRLF
	Else
		cQuery	+= SerieNfId('SF1',3,'F1_SERIE') + " = '"+cPrefix+"' AND " + CRLF
	EndIf
	cQuery	+= " SF1.F1_FORNECE = '"+cCliente+"' AND " + CRLF
	cQuery	+= " SF1.F1_LOJA = '"+cLoja+"' AND " + CRLF
	cQuery	+= " SF1.D_E_L_E_T_ = ' ' " + CRLF

ElseIf cTabNF == "SF2"
	cQuery	+= " SELECT R_E_C_N_O_ RECNO " + CRLF
	cQuery	+= " FROM "+RetSQLName("SF2")+" SF2 " + CRLF
	cQuery	+= " WHERE " + CRLF
	cQuery	+= " SF2.F2_FILIAL = '"+xFilial("SF2",cFilTit)+"' AND " + CRLF
	cQuery	+= " SF2.F2_DOC = '"+cDoc+"' AND " + CRLF
	If lPrefix
		cQuery	+= " SF2.F2_PREFIXO = '"+cPrefix+"' AND " + CRLF
	Else
		cQuery	+= SerieNfId('SF2',3,'F2_SERIE') + " = '"+cPrefix+"' AND " + CRLF
	EndIf
	cQuery	+= " SF2.F2_CLIENTE = '"+cCliente+"' AND " + CRLF
	cQuery	+= " SF2.F2_LOJA = '"+cLoja+"' AND " + CRLF
	cQuery	+= " SF2.D_E_L_E_T_ = ' ' " + CRLF
ElseIf cTabNF == "SFE"
	cQuery	+= " SELECT R_E_C_N_O_ RECNO " + CRLF
	cQuery	+= " FROM "+RetSQLName("SFE")+" SFE " + CRLF
	cQuery	+= " WHERE " + CRLF
	cQuery	+= " SFE.FE_FILIAL = '"+xFilial("SFE",cFilTit)+"' AND " + CRLF
	cQuery	+= " SFE.FE_NFISCAL = '"+cDoc+"' AND " + CRLF
	cQuery	+= SerieNfId('SFE',3,'FE_SERIE') + " = '"+cPrefix+"' AND " + CRLF
	cQuery	+= " SFE.FE_FORNECE = '"+cCliente+"' AND " + CRLF
	cQuery	+= " SFE.FE_LOJA = '"+cLoja+"' AND " + CRLF
	cQuery	+= " SFE.D_E_L_E_T_ = ' ' " + CRLF
EndIF

If !Empty(cQuery)
	cQuery := ChangeQuery(cQuery)

	If Select(cTab) > 0
		dbSelectArea(cTab)
		dbCloseArea()
	Endif

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cTab,.T.,.F.)

	If (cTab)->(!EOF())
		nRec := (cTab)->RECNO
	EndIf

	dbSelectArea(cTab)
	dbCloseArea()

EndIf

RestArea(aArea)
Return nRec


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ADMGTUSFL ºAutor  ³Totvs                  º Data ³  19/11/15   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Define as filiais que o usuário tem permissão.                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ finxfun                                                       º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ lTodasFil					                                       ³±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function ADMGTUSFL(lTodasFil)

Local cEmpresa 	:= cEmpAnt
Local cTitulo	:= ""
Local MvParDef	:= ""
Local nI 		:= 0
Local aArea 	:= GetArea() 					 // Salva Alias Anterior
Local nReg	    := 0
Local nSit		:= 0
Local aSit		:= {}
Local aFil 		:= {}
Local nTamFil	:= Len(xFilial("CT2"))
Local lDefTop 	:= IIF( FindFunction("IfDefTopCTB"), IfDefTopCTB(), .F.) // verificar se pode executar query (TOPCONN)
Local nInc		:= 0
Local aSM0		:= AdmAbreSM0()
Local aFilAtu	:= {}
Local lFWCodFil := FindFunction( "FWCodFil" )
Local lGestao	:= Iif( lFWCodFil, ( "E" $ FWSM0Layout() .And. "U" $ FWSM0Layout() ), .F. )	// Indica se usa Gestao Corporativa

Default lTodasFil := .F.

If lDefTop
	If !IsBlind()
		PswOrder(1)
		If PswSeek( __cUserID, .T. )

			aSit		:= {}
			aFilNome	:= {}
			aFilAtu		:= FWArrFilAtu( cEmpresa, cFilAnt )
			If Len( aFilAtu ) > 0
				cTxtAux := IIF(lGestao,STR0047,STR0048)//"Empresa/Unidade/Filial de "##"Filiais de "
				cTitulo := cTxtAux + AllTrim( aFilAtu[6] )
			EndIf

			// Adiciona as filiais que o usuario tem permissão
			For nInc := 1 To Len( aSM0 )
				//DEFINES da SMO encontra-se no arquivo FWCommand.CH
				//Na função FWLoadSM0(), ela retorna na posicao [SM0_USEROK] se esta filial é válida para o user
				If (aSM0[nInc][SM0_GRPEMP] == cEmpAnt .And. ((ValType(aSM0[nInc][SM0_EMPOK]) == "L" .And. aSM0[nInc][SM0_EMPOK]) .Or. ValType(aSM0[nInc][SM0_EMPOK]) <> "L") .And. aSM0[nInc][SM0_USEROK] )
					AAdd(aSit, aSM0[nInc][SM0_CODFIL] + " - " +aSM0[nInc][SM0_NOMRED] )
					MvParDef += aSM0[nInc][SM0_CODFIL]
					nI++
				Endif

			Next
			If Len( aSit ) <= 0
				// Se não tem permissão ou ocorreu erro nos dados do usuario, pego a filial corrente.
				Aadd(aSit, aFilAtu[2]+" - "+aFilAtu[7] )
				MvParDef := aFilAtu[2]
				nI++
			EndIf
		EndIf

		aFil := {}
		nSit := 1
		For nReg := 1 To len(mvpardef) Step nTamFil  // Acumula as filiais num vetor
			If SubSTR(mvpardef, nReg, nTamFil) <> Replicate("*",nTamFil)
		 		AADD(aFil, SubSTR(mvpardef, nReg, nTamFil) )
			endif
			nSit++
		next
		If Len(aFil) == Len(aSit)
			lTodasFil := .T.
		EndIf
	Else
		aFil := {cFilAnt}
	EndIf
EndIf

RestArea(aArea)

Return(aFil)

//-------------------------------------------------------------------
/*/{Protheus.doc} GetFlBxSE5
Pesquisa as filiais de baixa de um título
@author Daniel Mendes
@since  08/03/2016
/*/
//-------------------------------------------------------------------
Function GetFlBxSE5( cPrefixo, cNumero, cParcela, cTipo, cCliFor, cLoja, cNatureza, cFilOrig, cCart, nTipo, lRelat )
	Local aArea			:= NIL
	Local aFilsSE5		:= {}
	Local cAliasQry		:= ""
	Local cQueryFK1		:= ""
	Local cQueryFK2		:= ""
	Local cChvFK7		:= Iif(cCart == 'R', xFilial("SE1", cFilOrig), xFilial("SE2", cFilOrig)) + "|" ;
							+ cPrefixo +"|"+ cNumero +"|"+ cParcela +"|"+ cTipo +"|"+ cCliFor +"|"+ cLoja
	Local cFilOld		:= ""

	Default lRelat	:= .F.

	If __cChvFK7 == Nil
		__cChvFK7 	:= ""
	EndIf

	If __cChvFK7 != cChvFK7
		cFilOld		:= cFilAnt
		cFilAnt		:= cFilOrig
		__cIdDoc 	:= FINBuscaFK7(cChvFK7, Iif(cCart == 'R', "SE1", "SE2"))
		__cChvFK7 	:= cChvFK7
		cFilAnt		:= cFilOld
	EndIf

    // Verifica se já tem um resultado armazenado para a mesma chave
    IF lRelat .AND. !EMPTY(aGetFlBxSE5) .AND.;
		(aGetFlBxSE5[1] == (cPrefixo+cNumero+cParcela+cTipo+cCliFor+cLoja+cNatureza+cFilOrig+cCart))

       aFilsSE5 := ACLONE(aGetFlBxSE5[2])
    ELSE
		aArea  := GetArea()

		If lRelat // Qd chamado pelo FINR150 ou FINR130 deve avaliar sem carteria para ter os movimento de compensação

			If __oFlBxFK1 == Nil
				cQueryFK1 := " SELECT DISTINCT FK1.FK1_FILIAL AS FILS"
				cQueryFK1 += " FROM " + RetSqlName("FK1") + " FK1"
				cQueryFK1 += " WHERE FK1_IDDOC = ?"
				cQueryFK1 += " AND ( FK1_MOTBX = 'CEC' OR FK1_MOTBX = 'CMP')"
				cQueryFK1 += " AND ( FK1_TPDOC = 'CP' OR FK1_TPDOC = 'BA')"
				cQueryFK1 += " AND FK1_NATURE = ?"
				cQueryFK1 += " AND FK1.D_E_L_E_T_ = ' '"

				cQueryFK2 := " SELECT DISTINCT FK2.FK2_FILIAL AS FILS"
				cQueryFK2 += " FROM " + RetSqlName("FK2") + " FK2"
				cQueryFK2 += " WHERE FK2_IDDOC = ?"
				cQueryFK2 += " AND ( FK2_MOTBX = 'CEC' OR FK2_MOTBX = 'CMP')
				cQueryFK2 += " AND ( FK2_TPDOC = 'CP' OR FK2_TPDOC = 'BA')
				cQueryFK2 += " AND FK2_NATURE = ?"
				cQueryFK2 += " AND FK2.D_E_L_E_T_ = ' '"

				cQueryFK1 := ChangeQuery(cQueryFK1)
				cQueryFK2 := ChangeQuery(cQueryFK2)
				__oFlBxFK1 := FWPreparedStatement():New(cQueryFK1)
				__oFlBxFK2 := FWPreparedStatement():New(cQueryFK2)
			EndIf

			__oFlBxFK1:SetString(1, __cIdDoc)
			__oFlBxFK1:SetString(2, cNatureza)
			__oFlBxFK2:SetString(1, __cIdDoc)
			__oFlBxFK2:SetString(2, cNatureza)

			cQueryFK1 := __oFlBxFK1:GetFixQuery()
			cAliasQry := MpSysOpenQuery(cQueryFK1)

			While !(cAliasQry)->(EoF())
				AAdd(aFilsSE5, (cAliasQry)->FILS)
				(cAliasQry)->(DbSkip())
			EndDo

			(cAliasQry)->(DbCloseArea())

			cQueryFK2 := __oFlBxFK2:GetFixQuery()
			cAliasQry := MpSysOpenQuery(cQueryFK2)

			While !(cAliasQry)->(EoF())
				If (AScan(aFilsSE5, {|filial| filial == (cAliasQry)->FILS})) == 0
					AAdd(aFilsSE5, (cAliasQry)->FILS)
				EndIf
				(cAliasQry)->(DbSkip())
			EndDo
			(cAliasQry)->(DbCloseArea())
		Else
			cAliasQry := GetNextAlias()

			If nTipo == 2 //Compensacao - não avalia carteira devido a Compensação em carteira.
				BeginSql Alias cAliasQry
					SELECT
						DISTINCT FK1.FK1_FILIAL AS FILS
					FROM
						%Table:FK1% FK1
					WHERE
						FK1_IDDOC = %Exp:__cIdDoc%
						AND ( FK1_MOTBX = 'CEC' OR FK1_MOTBX = 'CMP')
						AND ( FK1_TPDOC = 'CP' OR FK1_TPDOC = 'BA')
						AND FK1_NATURE = %Exp:cNatureza%
						AND FK1.%NotDel%
					UNION
					SELECT
						DISTINCT FK2.FK2_FILIAL AS FILS
					FROM
						%Table:FK2% FK2
					WHERE
						FK2_IDDOC = %Exp:__cIdDoc%
						AND ( FK2_MOTBX = 'CEC' OR FK2_MOTBX = 'CMP')
						AND ( FK2_TPDOC = 'CP' OR FK2_TPDOC = 'BA')
						AND FK2_NATURE = %Exp:cNatureza%
						AND FK2.%NotDel%
				EndSql
			Else
				If cCart == "R"
					BeginSql Alias cAliasQry
						SELECT
							DISTINCT FK1.FK1_FILIAL AS FILS
						FROM
							%Table:FK1% FK1
						WHERE
							FK1_IDDOC = %Exp:__cIdDoc%
							AND FK1_NATURE = %Exp:cNatureza%
							AND FK1.%NotDel%
					EndSql
				Else
					BeginSql Alias cAliasQry
						SELECT
							DISTINCT FK2.FK2_FILIAL AS FILS
						FROM
							%Table:FK2% FK2
						WHERE
							FK2_IDDOC = %Exp:__cIdDoc%
							AND FK2_NATURE = %Exp:cNatureza%
							AND FK2.%NotDel%
					EndSql
				EndIf
			EndIf
			While !(cAliasQry)->( Eof() )
				aAdd( aFilsSE5 , (cAliasQry)->FILS )
				(cAliasQry)->( dbSkip() )
			EndDo
			(cAliasQry)->( dbCloseArea() )
		EndIf

		RestArea(aArea)
    ENDIF

	// Guarda o resultado para possivel aproveitamento em novas chamadas com a mesma chave
	IF lRelat
		aGetFlBxSE5 := {cPrefixo+cNumero+cParcela+cTipo+cCliFor+cLoja+cNatureza+cFilOrig+cCart,ACLONE(aFilsSE5)}
	ENDIF
Return aFilsSE5

//-------------------------------------------------------------------
/*/{Protheus.doc} FA181Imune
Zera os valores do IR e IOF para aplicações de empresas Imunes.
@author Rodrigo Oliveira
@since  04/04/2016
/*/
//-------------------------------------------------------------------
Function FA181Imune(nIofAplAtu,nIR,lPerg)

Local cImune			:= SuperGetMv("MV_APLIMUN",,"1")

If Type("lPergAplIm") == "U"
	lPergAplIm	:= .F.
EndIf

If cImune == "3" .And. (lPerg # Nil .And. lPerg)
	lPergAplIm	:= MsgYesNo(STR0080,STR0081) // "Esta aplicação é Imune de IR e IOF?" ### "Aplic. Imune"
EndIf

If cImune == "2" .Or. lPergAplIm
	nIR	:= nIofAplAtu := 0
EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc}ValParFin
Valida o conteudo dos parametros MV_INSS, MV_ISS, MV_IRF

@param X6_CONTEUD- conteudo em portugues
@param 	X6_CONTSPA- conteudo em espanhol
@param X6_CONTENG- conteudo em ingles

@return lRet - Retorna .T. se conteudo estiver correto

@author Karen Honda
@since  27/06/2016
/*/
//-------------------------------------------------------------------

Function ValParFin(cExpPor,cExpSpa,cExpEng)
Local lRet := .T.

cExpPor := Alltrim(cExpPor)
cExpSpa := Alltrim(cExpSpa)
cExpEng := Alltrim(cExpEng)

If !Empty(cExpPor)
	If Type(cExpPor) == "U"
		Alert(STR0082)//"Conteúdo deve conter aspas!"
		lRet := .F.
	EndIf
EndIf

If lRet .and. !Empty(cExpSpa)
	If Type(cExpSpa) == "U"
		Alert(STR0083)//"Conteúdo em espanhol deve conter aspas!"
		lRet := .F.
	EndIf
EndIf

If lRet .and. !Empty(cExpEng)
	If Type(cExpEng) == "U"
		Alert(STR0084)//"Conteúdo em inglês deve conter aspas!"
		lRet := .F.
	EndIf
EndIf
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SumRetRec
Retorna os valores retidos na baixa de um determinado título

@Author	Totvs
@since	29/07/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function SumRetRec(cPrefixo,cNumero,cParcela,cTipo,cCli, cLj,nMoeda,nTotImp,nTotIrrf,nTotCsll,nTotPis,nTotCof,nTxMoeda,dDtDe,dDtAte)
Local lIrrfBxPj 	:= .F.
Local lPccBxCr		:= FPccBxCr(.T.)
Local aBaixa		:= {}
Local nx			:= 0

Default cPrefixo	:= ""
Default cNumero		:= ""
DEFAULT	cParcela	:= ""
Default cTipo		:= ""
Default cCli 		:= ""
Default cLj			:= ""
Default nMoeda		:= 0
Default nTotImp 	:= 0
Default nTotIrrf 	:= 0
Default nTotCsll 	:= 0
Default nTotPis		:= 0
Default nTotCof		:= 0
Default nTxMoeda  	:= 0
Default dDtDe		:= dDataBase
Default dDtAte		:= dDataBase

Private aBaixaSE5 	:= {}

dbSelectArea("SA1")
SA1->(MsSeek(xFilial("SA1")+cCli+cLj))

lIrrfBxPj 	:= IIf(FindFunction("FIrPjBxCr"),FIrPjBxCr(.T.),.F.)


If SE1->E1_CLIENTE+SE1->E1_LOJA == cCli+cLj
	aBaixa := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, cPrefixo, cNumero, cParcela, cTipo,,, cCli, cLj,,,,,,)
	For nx := 1 To Len(aBaixaSE5)
		If aBaixaSE5[nx][7] >= dDtDe .AND. aBaixaSE5[nx][7] <= dDtAte
			If lPccBxCr
				//CSLL
				nTotCsll 	+= xMoeda(aBaixaSE5[nx][20] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				nTotImp 	+= xMoeda(aBaixaSE5[nx][20] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				//PIS
				nTotPis 	+= xMoeda(aBaixaSE5[nx][18] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				//nTotImp 	+= xMoeda(aBaixaSE5[nx][18] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				//COFINS
				nTotCof 	+= xMoeda(aBaixaSE5[nx][19] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				//nTotImp 	+= xMoeda(aBaixaSE5[nx][19] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
			EndIf
			If lIrrfBxPj
				//IRRF
				nTotIrrf 	+= xMoeda(aBaixaSE5[nx][30] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				nTotImp 	+= xMoeda(aBaixaSE5[nx][30] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)

			EndIf
		EndIf
	Next
EndIf

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FDelQuery
Destroy o objeto criado na FinSeqSe5()

@Author	Mauricio Pequim Jr
@since	02/01/2017
/*/
//-----------------------------------------------------------------------------------------------------
Function FDelQuery( lGetFlBx )

Default lGetFlBx := .F.

If oPrepared != NIL
	oPrepared:Destroy()
	oPrepared := NIL
Endif

If lGetFlBx
	If __oFlBxFK1 != Nil
		__oFlBxFK1:Destroy()
		__oFlBxFK1 := Nil
		__oFlBxFK2:Destroy()
		__oFlBxFK1 := Nil
		FWFreeArray(aGetFlBxSE5)
		aGetFlBxSE5 := {}
	EndIf
EndIf

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FilsUsr
Retorna uma string com as filiais de acesso do operador

@Parâm.    	FlIni = Filial de (par. MV) FlFim = Filial Até (par. MV)
			cFils = String com filiais autorizadas
@Retorno   	lRet  = se .T., usuario acessa todas as filiais do range
@Author	Rodrigo Oliveira
@since	06/04/2017
/*/
//-----------------------------------------------------------------------------------------------------
Function FilsUsr(FlIni, FlFim, cFils)

Local aSM0		:= FwAllFilial()
Local lAdmUsFl	:= FindFunction("ADMGTUSFL")
Local nQtde		:= 0
Local nQtdUsr	:= 0
Local lRet		:= .T.
Local nI		:= 0
Local aFlUsr	:= {}

nQtde	:= ContaFil(FlIni, FlFim, aSM0, aFlUsr)

If lAdmUsFl
	aFlUsr 	:= ADMGTUSFL()
	nQtdUsr := ContaFil(FlIni, FlFim, aSm0, aFlUsr)
EndIf

If nQtde > nQtdUsr
	lRet := .F.
	For nI := 1 to Len(aFlUsr)
		cFils += "'" + aFlUsr[nI] + Iif(nI == Len(aFlUsr), "'", "',")
	Next
EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ContaFil
Retorna o total de filiais que o operador tem acesso

@Parâm.    	FlIni = Filial de (par. MV) FlFim = Filial Até (par. MV)
			aSM0 = array contendo o Sigamat
@Retorno   	nTotal  = Total de filiais encontradas
@Author	Rodrigo Oliveira
@since	06/04/2017
/*/
//-----------------------------------------------------------------------------------------------------
Static Function ContaFil(FlIni, FlFim, aSM0, aFlUsr)

Local nPosIni	:= 0
Local nPosFim	:= 0
Local nTotal	:= 0
Local nI		:= 0
Local aFlUsr1	:= {}

If Len(aFlUsr) > 0
	If ( aFlUsr[1] < FlIni .Or. aFlUsr[Len(aFlUsr)] > FlFim )
		For nI := 1 to Len(aFlUsr)
			If  aFlUsr[nI] >= FlIni .And. aFlUsr[nI] <= FlFim
				aAdd(aFlUsr1,aFlUsr[nI])
			EndIf
		Next
		aFlUsr := aClone(aFlUsr1)
		nTotal	:= Len(aFlUsr)
	Else
		nTotal	:= Len(aFlUsr)
	EndIf
Else
	If Empty(Alltrim(FlIni))
		FlIni	:= aSM0[1]
		nPosIni := 1
	Else
		nPosIni	:= aScan(aSM0,{|x| x == FlIni})
	EndIf

	If "ZZ" $ UPPER(FlFim)
		FlFim	:= aSM0[Len(aSm0)]
		nPosFim := Len(aSm0)
	Else
		nPosFim	:= aScan(aSM0,{|x| x == FlFim})
	EndIf

	nTotal := (nPosFim + 1) - nPosIni
EndIf

Return nTotal

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GetFKDCOD
Função responsavel por verificar se o codigo do valor acessorio digitado esta correto e se esta ativo
@type function
@author jose.aribeiro
@since 27/09/2016
@version 1.0
@param cCod , caracter, Codigo do valor acessorio para ser validado
@return lRet, logico  , .T. para encontrado e ativo e .F. para nao encontradoou nao validado
/*/
//-----------------------------------------------------------------------------------------------------
Function GetFKDCOD(cCod)
Local lRet := .T.

	DbSelectArea("FKC")
	FKC->(DbSetOrder(1))
	If(FKC->(DbSeek(xFilial("FKC")+cCod)))
		If(FKC->FKC_ATIVO == "2")

			lRet := .F.
			Help(" ",1,"GETFKDCOD",,STR0085, 1, 0 ) //O Codigo de valor acessorio informado, esta bloqueado , Verifique

		EndIf
	Else

		lRet := .F.
		Help(" ",1,"GETFKDCOD",,STR0086, 1, 0 ) //O Codigo de valor acessorio informado, não foi encontrado , Verifique

	EndIf
Return lRet

//-------------------------------------------------------------------
/*{Protheus.doc} TTFtIndex
Formata indice que possui campo numerico/data
obs: necessario para classe FWTemporaryTable, metodo AddIndex
@author Igor Sousa do Nascimento
@version 12.1.17
@since   31/10/2017
*/
//-------------------------------------------------------------------
Function TTFtIndex(aFields) As Array

	Local nX   	  As Numeric
	Local nAt  	  As Numeric

	Default aFields := {}

	For nX := 1 to Len(aFields)
		If "DTOS" $ aFields[nX] 	  // Verifica se existe conversao de campo data (DTOS)
			// Remove funcao de conversao
			aFields[nX] := StrTran(aFields[nX],"DTOS","")
			// Remove parenteses
			aFields[nX] := StrTran(aFields[nX],"(","")
			aFields[nX] := StrTran(aFields[nX],")","")
		ElseIf "STR" $ aFields[nX]	  // Verifica se existe conversao de campo numerico (STR)
			// Remove funcao de conversao
			aFields[nX] := StrTran(aFields[nX],"STR","")
			// Remove parenteses
			aFields[nX] := StrTran(aFields[nX],"(","")
			nAt := At(",",aFields[nX])
			If nAt > 0	// Ignora virgula e parametros da funcao STR
				aFields[nX] := SubStr(aFields[nX],1,nAt-1)
			Else		// Caso nao encontre parametros, remove parentese
				aFields[nX] := StrTran(aFields[nX],")","")
			EndIf
		EndIf
	Next nX

Return aFields

//-------------------------------------------------------------------
/*{Protheus.doc} TTGetStru

Retorna string dos campos de determinada estrutura de tabela(SX2).
obs: necessario para classe FWTemporaryTable, metodo SetFields

@param aStruct - Estrutura da tabela (Array referencia)
@param cAlias - Alias da Tabela
@param cSepara - Caractere separador

@return cFields - String com a estrutura dos campos.
@author Leonardo Castro
@version 12.1.17
@since   04/04/2018
*/
//-------------------------------------------------------------------
Function TTGetStru(aStruct As Array, cAlias As Character, cSepara As Character) As Character

	Local aAux As Array
	Local cFields As Character
	Local nX As Numeric

	Default cAlias := Alias()
	Default aStruct := {}
	Default cSepara := ","

	aAux := Array(0)
	cFields := ""
	aStruct := If(Empty(aStruct),&(cAlias)->(DbStruct()),aStruct)

	For nX := 1 To Len(aStruct)

		// Remove da estrutura campos do tipo MEMO
		If aStruct[nX,2] != "M"

			/*
			-----------------------------------------------------------
			Estrutura Montada
			aStruct = Array contendo os campos da estrutura
			cFields = String dos campos concatenados por separador
			-----------------------------------------------------------
			*/
			aAdd(aAux,aStruct[nX])
			cFields += IF(nX == 1, aStruct[nX,1], cSepara + aStruct[nX,1])

		EndIf

	Next nX

	aStruct := aClone(aAux)

Return cFields


//------------------------------------------------------------------------
/*/{Protheus.doc} FXRetFil
Programa para retornar a filial completa para trocar o conteudo da variavel
cFilAnt.
Quando a filial está compartilhada e realizavam a troca do conteudo da cFilAnt
usando os campos E2_FILIAL ou E5_FILIAL ocorriam erros de validação em tabelas
onde a filial não é compartilhada.
@author	Rodrigo Pirolo
@since		23/11/2017
@version	12
@param		cTabela, Character, Tabela para a qual os modos de acessos serão feitos
@param		cFil, Character, Conteudo da filial da tabela que será verificada (TABELA_FILIAL)
@param		lComple, Logical, Define se retorna filial completa
@param		lHasCache, Logical, Define se irá utilizar cache para pesquisa (Recomendado o uso em processo massivos)
@return 	cFilRet, Character, Filial que será utilizada na cFilAnt
/*/
//------------------------------------------------------------------------

Function FXRetFil( cTabela, cFil, lComple, lHasCache )
Local aModAc	:= {}
Local aLayoutGC	:= {}
Local nPosGC	:= 0
Local cFilRet	:= SE2->E2_FILORIG
Local lTudoExc	:= .F.
Local lFilComp	:= .F.
Local lUNFilCom	:= .F.
Local lTudoCom	:= .F.

Default cTabela	:= "SE2"
Default cFil	:= SE2->E2_FILORIG
Default lComple	:= .T.
Default lHasCache := .F.

	If __oRetFil == NIL
		__oRetFil := FwHashMap():New()
	Endif

	If lHasCache .and. __oRetFil:containsKey(cTabela + cFil)
		cFilRet := __oRetFil:get(cTabela + cFil)
	Else

	If ( "E" $ FWSM0Layout() .OR. "U" $ FWSM0Layout() .OR. "F" $ FWSM0Layout() )

		aLayoutGC	:= FWLoadSM0()

		AAdd( aModAc, FWModeAccess( cTabela, 1 ) )
		AAdd( aModAc, FWModeAccess( cTabela, 2 ) )
		AAdd( aModAc, FWModeAccess( cTabela, 3 ) )

		If aModAc[1] == "E" .AND. aModAc[2] == "E" .AND. aModAc[3] == "C"
			lFilComp := .T.
		ElseIf aModAc[1] == "E" .AND. aModAc[2] == "E" .AND. aModAc[3] == "E"
			lTudoExc := .T.
		ElseIf aModAc[1] == "E" .AND. aModAc[2] == "C" .AND. aModAc[3] == "C"
			lUNFilCom := .T.
		ElseIf aModAc[1] == "C" .AND. aModAc[2] == "C" .AND. aModAc[3] == "C"
			lTudoCom := .T.
		EndIf

		If lTudoExc .OR. lTudoCom
			nPosGC := Ascan( aLayoutGC,{ |x| x[2] == cFil } )
		ElseIf lFilComp
			nPosGC := Ascan( aLayoutGC,{ |x| x[3] + x[4] == Left(cFil, Len(x[3] + x[4] ) ) } )
		ElseIf lUNFilCom
			nPosGC := Ascan( aLayoutGC,{ |x| x[3] == Left(cFil, Len(x[3]) ) } )
		EndIf

		If lComple
			If nPosGC > 0
				cFilRet := aLayoutGC[nPosGC][2]
			EndIf
		Else
			If nPosGC > 0
				If lTudoCom
					cFilRet := xFilial( cTabela, aLayoutGC[nPosGC][2] ) //empresa
				Else
					cFilRet := aLayoutGC[nPosGC][3] //empresa
					If lTudoExc
						cFilRet += aLayoutGC[nPosGC][4] //unidade de negócio
						cFilRet += aLayoutGC[nPosGC][5] //filial
					ElseIf lFilComp
						cFilRet += aLayoutGC[nPosGC][4] //unidade de negócio
						cFilRet += Space( Len( aLayoutGC[nPosGC][5] ) ) //filial
					ElseIf lUNFilCom
						cFilRet += Space( Len( aLayoutGC[nPosGC][4] ) ) //unidade de negócio
						cFilRet += Space( Len( aLayoutGC[nPosGC][5] ) ) //filial
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		cFilRet := cFil
	EndIf

	If lHasCache
			__oRetFil:put(cTabela + cFil, cFilRet)
		Endif
	Endif
Return cFilRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FINRDME
Motivo de Baixa Financeiro (Esta função retorno os motivos de baixa que sejam do tipo ESPECIE)

@author francisco.carmo
@since 09/03/2018
@version 12.1.20
/*/
//-------------------------------------------------------------------
Function MotBxEsp() As Array

	Local nX 		As Numeric
	Local aMotBx	As Array
	Local aMotFil	As Array

	aMotFil :={}
	aMotBx	:= ReadMotBx()
	
	For nX:=1 to Len(aMotBx)
		If SubStr(aMotBx[nX],48,1) == "S" .And. SubStr(aMotBx[nX],34,1) $ "AR"
			aADD(aMotFil, {SubStr(aMotBx[nX],1,3), SubStr(aMotBx[nX],7,10), SubStr(aMotBx[nX],48,1) })
		Endif
	Next nX

	FwFreeArray(aMotBx)

Return aMotFil

//-------------------------------------------------------------------
/*/{Protheus.doc} MovMoedEs
Verifica se o movimentos de fatura, compensação e liquidação ocorreu
em moeda estrangeira, para efeito de visualização nas consultas e relatórios

@author Sivaldo Oliveira
@since 06/04/2018
@version P12
/*/
//-------------------------------------------------------------------
Function MovMoedEs(cMoeda As Character, cTipoDoc As Character, cMotBx As Character, cDtMov As Character, cCart As Character) As Logical

Local lRet As Logical
Local nMoeda As Numeric

Default cMoeda   := "1"
Default cTipoDoc := ""
Default cMotBx   := ""
Default cDtMov   := DTOS(DATE())
Default cCart    := "P"

// Inicializa variáveis.
lRet := .F.
nMoeda := Val(cValToChar(cMoeda))

If cMotBx $ "LIQ|FAT|CMP" .And. nMoeda > 1 .And. !Empty(cTipoDoc) .And. !Empty(cMotBx)
	cTipoDoc := AllTrim(cTipoDoc)
	cMotBx   := AllTrim(cMotBx)
	cCart    := AllTrim(cCart)

	// A partir destas datas foram alteradas as gravações dos movimentos (E5_VALOR e E5_VLMOED2) em moeda estrangeira
	// dos processos de fatura, liquidação e compensação CP
	If cCart == "P"
		lRet := ((cDtMov >= "20180413") .Or. (cDtMov >= "20171227" .And. cTipoDoc $ "ES|CP" .And. cMotBx == "CMP"))
	Else
		lRet := (cDtMov >= "20181129" .And. cTipoDoc $ "BA|CP|ES" .And. cMotBx == "CMP")
	Endif

	If lRet
		If cTipoDoc $ "CP|BA|ES" .And. cMotBx == "CMP"
			// Compensação
			lRet := .T.
		ElseIf cTipoDoc $ "BA|ES" .And. cMotBx $ "LIQ|FAT"
			// Liquidação ou fatura.
			lRet := .T.
		Else
			lRet := .F.
		EndIf
	EndIf
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} HelpSX1

Busca o help das perguntas (SX1) no arquivo de Help da System

@author Fabio Casagrande Lima
@since  17/04/2018
@param	cGrupo - Grupo de pergunta a ser pesquisado (X1_GRUPO)
@param	cOrdem - Ordem da pergunta a ser pesquisada (X1_ORDEM)
/*/
//-------------------------------------------------------------------

Function HelpSX1(cGrupo As Character, cOrdem As Character) As Character

	Local cRet     As Character
	Local cChave   As Character
	Local cChaveP  As Character
	Local cChave1  As Character
	Local cChave2  As Character
	Local cChave3  As Character
	Local cHelp	   As Character
	Local cLine    As Character
	Local lError   As Logical
	Local ni	   As Numeric
	Local aHelp	   As Array

	Default cGrupo := ""

	cGrupo 	   := PadR(cGrupo, Len(SX1->X1_GRUPO), " ") //Adiciona espaços a direita para utilização no DbSeek
	cRet       := ""
	cChave     := "." + AllTrim(cGrupo) + AllTrim(cOrdem) + "."  //Define o nome da pergunta
	cChaveP    := ''
	cChave1	   := ''
	cChave2	   := ''
	cChave3	   := ''
	cHelp	   := ''
	lError	   := .F.
	aHelp	   := {}
	cLine      := ""

	If __lDicInDB	== NIL
		__lDicInDB := MPDicInDb()
	Endif

	If !__lDicInDB
		cChave := "P" + cChave
	Endif

	DbSelectArea('SX1')
	SX1->(DbSetOrder(1)) // Grupo + Ordem
	If SX1->(DbSeek(cGrupo + cOrdem))
		aHelp := FWReadHelp( RetHlpFile(), cChave, /*cMensagem*/, /*nLinha1*/, /*nColuna*/, /*lSubHelp*/, /*lSoluc*/, .T./*l40Col*/ )
	Endif

	For ni := 1 to Len(aHelp)
		cRet += aHelp[ni]
	Next

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FinSelFil(nRecno)
Retorna filtro dos campos e2_filial ou e2_filorig

@param aFil - Vetor com as filiais a serem consideradas na seleção dos títulos a serem liquidados
@param cAlias - Alias da tabela
@param lFilOrig - Indica se o filtro sera pelo T - FILORIG ou F- FILIAL
@param lCriaTmp - .T. indica se cria a tabela temporaria se o limite de filiais ultrapassar nLimTmp, .F. não cria a tabela temporaria
@param nLimTmp - Quantidade limite de filias, para montar a temporaria
@Return cRet - condição dos campos e2_filial ou e2_filorig

@author Sivaldo Oliveira
@since 25/04/2018
@version P12
/*/
//-------------------------------------------------------------------
Function FinSelFil(aFil As Array, cAlias As Character, lFilOrig As Logical, lCriaTmp As Logical,nLimTmp As Numeric) As Character
	Local cRet As Character
	Local nY As Numeric
	Local nAfil As Numeric
	Local cCampoFil As Character
	Local cCampoFilO As Character
	Local nTamFil As Numeric
	Local cTmpFil As Character
	Local cTable As Character
	Local cInsert As Character
	Local nX As Numeric
	Local cAtualxFil As Character
	Local aStruTmp As Array
	Local oTmpFil as Object
	Local lTotComp as Logical

	Default aFil := {}
	Default cAlias := "SE2"
	Default nLimTmp := 50
	Default lFilOrig := .T.
	Default lCriaTmp := .F.


	//Inicializa variáveis.
	cRet := ""
	nY := 0
	nAfil := Len(aFil)
	oTmpFil := NIL
	lTotComp := (len(allTrim(xFilial(cAlias, if(nAfil>0, aFil[1], NIL)))) == 0)


	If cAlias == "SE1"
		cCampoFil := "E1_FILIAL"
		cCampoFilO := "E1_FILORIG"
	ElseIf cAlias == "SE5"
		cCampoFil := "E5_FILIAL"
		cCampoFilO := "E5_FILORIG"
	ElseIf cAlias == "FK4"
		cCampoFil := "FK4_FILIAL"
		cCampoFilO := "FK4_FILORI"
	ElseIf cAlias == "SE2"
		cCampoFil := "E2_FILIAL"
		cCampoFilO := "E2_FILORIG"
	Else
		cCampoFil := ""
		cCampoFilO := ""
	EndIf

	If lTotComp .And. !lFilOrig
		return cCampoFil + " = " + "'" + xFilial(cAlias, if(nAfil>0, aFil[1], NIL)) + "' "
	EndIf

	If nAfil <= nLimTmp .or. !lCriaTmp
		If nAfil > 1
			cRet := Iif(lFilOrig, cCampoFilO,cCampoFil) + " IN ('" + Iif(lFilOrig, aFil[1], xFilial(cAlias,aFil[1]) ) + "'"

			For nY := 2 To nAfil
				cRet += ", '" + Iif(lFilOrig, aFil[nY], xFilial(cAlias,aFil[nY]) ) + "'"
			Next nY

			cRet += ") "
		ElseIf nAfil == 1
			cRet := IIf(lFilOrig, cCampoFilO + " = '" + aFil[1], cCampoFil + " = '" + xFilial(cAlias, aFil[1])) + "' "
		Else
			cRet := IIf(lFilOrig, cCampoFilO + " = '" + cFilAnt, cCampoFil + " = '" + xFilial(cAlias)) + "' "
		EndIf
	Else
		cTmpFil := GetNextAlias()
		nTamFil = CtbTamSXG("033",2)
		cTable := ""
		aStruTmp := {}

		If len(__aTmpFils) > 9
			__aTmpFils[1]:delete()
			ADel(__aTmpFils,1)
			ASize(__aTmpFils, len(__aTmpFils)-1)
		EndIf

		aAdd( aStruTmp, {'TMPFIL','C',nTamFil,0} )

		oTmpFil := FwTemporaryTable():New( cTmpFil )
		oTmpFil:SetFields( aStruTmp )
		oTmpFil:AddIndex( '01', {'TMPFIL'} )
		oTmpFil:Create()
		aAdd(__aTmpFils, oTmpFil)

		cTable	:= oTmpFil:GetRealName()

		cInsert := " INSERT INTO " + cTable  + "  (TMPFIL)  "
		For nX := 1 to Len(aFil)
			cAtualxFil := Iif(lFilOrig, aFil[nX], xFilial(cAlias,aFil[nX]) )
			cInsertValue := " VALUES ('" + cAtualxFil + "')  "
			TcSqlExec( cInsert + cInsertValue)
		Next nX

		( cTmpFil )->(DbGoTop())

		If Upper(TcGetDb()) $ "MSSQL7"
			cTable := StrTran (cTable,'dbo.')
		EndIf

		cRet := Iif(lFilOrig, cCampoFilO,cCampoFil) + " IN (SELECT TMPFIL FROM " + cTable + ")"
	EndIf
Return cRet
//-------------------------------------------------------------------
/*/{Protheus.doc} FinEraseTmpFil()
Limpa o objeto da temporaria da selecao de filiais, criado na funcao FinSelFil()

@author Karen Honda
@since 16/09/2020
@version P12
/*/
//-------------------------------------------------------------------
Function FinEraseTmpFil() As Character
	Local nX as Numeric
	nX := 1

	For nX := 1 to len(__aTmpFils)
		if __aTmpFils[nX] != NIL
			__aTmpFils[nX]:delete()
			FreeObj(__aTmpFils[nX])
		EndIf
	Next nX

	FWFreeArray(__aTmpFils)
	__aTmpFils := {}
Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} TXSeek

Posiciona em um titulo de imposto (TX) especifico baseado na natureza

@param cNatImp: Natureza do TX
@param cChave: Chave do titulo pai
@param lDelStmt: Indica se o objeto statement sera deletado
		(obrigatorio mandar .T. quando nao for chamar esta funcao novamente)
@param cFilOrig: Filial de origem do título pai

@return lRet: Identifica se encontrou e posicionou no TX do imposto

@Author	Igor Sousa do Nascimento
@since	08/05/2018
/*/
//-----------------------------------------------------------------------------------------------------
Function TXSeek(cNatImp,cChave,lDelStmt,cFilOrig)

	Local cAlias	As Character
	Local cQry 		As Character
	Local nRecnoTX 	As Numeric
	Local nParam	As Numeric
	Local lRet 		As Logical
	Local aTipos 	As Array

	Default cNatImp  := ""
	Default cChave   := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
	Default lDelStmt := .F.
	Default cFilOrig := cFilAnt

	cAlias	 := Alias()
	cQry	 := ""
	nRecnoTX := 0
	nParam	 := 1
	lRet	 := .F.
	aTipos	 := StrtoKarr2( MVISS +"|"+ MVTAXA +"|"+ MVTXA +"|"+ MVINSS +"|"+ 'SES' +"|"+ 'CID' + "|"+ 'INA', "|", .F.)

	If !Empty(cNatImp) .and. !Empty(cChave)
		If __oTXSeek == Nil
			cQry := "SELECT SE2.R_E_C_N_O_ RECNO "
			cQry += "FROM ? SE2 "
			cQry += "WHERE SE2.E2_FILIAL = ? AND "
			cQry += "SE2.E2_TITPAI = ? AND "
			cQry += "SE2.E2_NATUREZ = ? AND "
			cQry += "SE2.E2_TIPO IN (?) AND "
			cQry += "SE2.D_E_L_E_T_ = ? "
			cQry := ChangeQuery(cQry)

			__oTXSeek := FwExecStatement():New(cQry)
		EndIf

		__oTXSeek:setUnsafe(nParam++, RetSqlName('SE2'))
		__oTXSeek:SetString(nParam++, xFilial("SE2", cFilOrig))
		__oTXSeek:SetString(nParam++, cChave)
		__oTXSeek:SetString(nParam++, cNatImp)
		__oTXSeek:SetIn(nParam++, aTipos )
		__oTXSeek:SetString(nParam++, Space(1))

		nRecnoTX :=  __oTXSeek:ExecScalar("RECNO")

		If nRecnoTX > 0
			dbSelectArea("SE2")
			dbGoTo(nRecnoTX)
			lRet := .T.
		EndIf

		If !Empty(cAlias)
			dbSelectArea(cAlias)
		EndIf
	EndIf

	If lDelStmt .and. __oTXSeek <> Nil
		__oTXSeek:Destroy()
		__oTXSeek:= Nil
	EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ISSCPOM

Verifica se o municipio exige CPOM e se havera bitributacao do ISS

@param cTpEnt: Tipo da entidade, P - Prestador, T - Tomador
@param cEnt: Fornecedor ou Cliente + Loja
@param cCodServ: Codigo do tipo de servico (SX5)
@return aRet: Vetor com UF, municipio, aliquota, vlr.min e cod.munic
@author	Igor Sousa do Nascimento
@since	16/10/2018
/*/
//-----------------------------------------------------------------------------------------------------
Function ISSCPOM(cTpEnt,cEnt,cCodServ)

	Local aArea		:= GetArea()
	Local aRet		:= {}
	Local cMunSM0 := Iif(Len(Alltrim(SM0->M0_CODMUN))==5, Alltrim(SM0->M0_CODMUN), Substr(Alltrim(SM0->M0_CODMUN),3,5))
	Local lVerCPOM	:= .F.
	Local lCC2VlMin := CC2->(ColumnPos("CC2_ISSMIN")) > 0

	Default cTpEnt  := ""
	Default cEnt 	:= ""
	Default cCodServ:= ""

	If cTpEnt == "T"	// Tomador de Servicos - CP
		dbSelectArea("SA2")
		dbSetOrder(1)
		If dbSeek(xFilial("SA2")+cEnt)
			lVerCPOM := Upper(AllTrim(cMunSM0)) <> Upper(AllTrim(SA2->A2_COD_MUN))
			cMunSM0  := AllTrim(SA2->A2_COD_MUN)
		EndIf
	ElseIf cTpEnt == "P"	// Prestador de Servicos - CR
		dbSelectArea("SA1")
		dbSetOrder(1)
		If dbSeek(xFilial("SA1")+cEnt)
			lVerCPOM := Upper(AllTrim(cMunSM0)) <> Upper(AllTrim(SA1->A1_COD_MUN))
			cMunSM0  := AllTrim(SA1->A1_COD_MUN)
		EndIf
	EndIf

	If lVerCPOM
		dbSelectArea("CLI")
		dbSetOrder(1)
		If cTpEnt == "T"
			If dbSeek(xFilial("CLI")+"1"+cCodServ+SA2->A2_EST+cMunSM0+cEnt)
				dbSelectArea("CE1")
				dbSetOrder(1)
				If dbSeek(xFilial("CE1")+CLI->CLI_CODISS+CLI->CLI_UF+CLI->CLI_CODMUN)
					If CE1->CE1_RETISS == "1"
						aAdd(aRet,CE1->CE1_ESTISS)
						aAdd(aRet,CE1->CE1_MUNISS)
						aAdd(aRet,CE1->CE1_ALQISS)
						If lCC2VlMin
							dbSelectArea("CC2")
							dbSetOrder(1)
							If dbSeek(xFilial("CC2")+SA2->A2_EST+cMunSM0)
								aAdd(aRet,CC2->CC2_ISSMIN)
							EndIf
						EndIf
						aAdd(aRet,cMunSM0)
					EndIf
				EndIf
			EndIf
		ElseIf cTpEnt == "P"
			If dbSeek(xFilial("CLI")+"2"+cCodServ+SA1->A1_EST+cMunSM0)
				dbSelectArea("CE1")
				dbSetOrder(1)
				If dbSeek(xFilial("CE1")+CLI->CLI_CODISS+CLI->CLI_UF+CLI->CLI_CODMUN)
					If CE1->CE1_RETISS == "1"
						aAdd(aRet,CE1->CE1_ESTISS)
						aAdd(aRet,CE1->CE1_MUNISS)
						aAdd(aRet,CE1->CE1_ALQISS)
						If lCC2VlMin
							dbSelectArea("CC2")
							dbSetOrder(1)
							If dbSeek(xFilial("CC2")+SA1->A1_EST+cMunSM0)
								aAdd(aRet,CC2->CC2_ISSMIN)
							EndIf
						EndIf
						aAdd(aRet,cMunSM0)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return aRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} BtrISSMun
Função para buscar o fornecedor e loja para pagamento do ISS, conforme
código de serviço, estado e munícipio cadastrado nas alíquotas do ISS

@author caio.martins
@since 26/10/2018
@type function

@param cCodISS, characters, Código de serviço do ISS
@param cEstado, characters, Código do estado ao qual pertence o município
@param cMunicipio, characters, Código do municcío ao qual se aplica a alíquota

@return aRet, Vetor com as informações do fornecedor para pagamento do ISS bitributado
@sample aRet[1] = Código do Fornecedor
		aRet[2] = Loja do Fornecedot
/*/
//-----------------------------------------------------------------------------------------------------
Function BtrISSMun( cCodISS, cEstado, cMunicipio )
	Local aRet := {}
	Local aAreaCE1 := CE1->( GetArea() )

	Default cCodISS := ""
	Default cEstado := ""
	Default cMunicipio := ""

	CE1->( dbSetOrder(1) ) //CE1_FILIAL+CE1_CODISS+CE1_ESTISS+CE1_CMUISS+CE1_PROISS
	If CE1->( MsSeek( FWxFilial("CE1") + cCodISS + cEstado + cMunicipio ) )
		aRet := { CE1->CE1_FORISS, CE1->CE1_LOJISS }
	EndIf

	RestArea(aAreaCE1)
	FwFreeArray(aAreaCE1)
Return aRet

//--------------------------------------------------------------------------
/*/{Protheus.doc} RetAnivCP()
Função que retorna todas as datas de aniversário da respectiva caderneta
de poupança, da data de cadastro até a data do resgate

@author Pedro Pereira Lima
@since 20/12/2018
@version 12.1.17
/*/
//--------------------------------------------------------------------------
Static Function RetAnivCP( dDataCP As Date, dDtSaldo As Date ) As Array
	Local aAniv		As Array
	Local nDiaAniv	As Numeric
	Local nX		As Numeric
	Local nDifData	As Numeric
	Local nTo		As Numeric
	Local nDia		As Numeric
	Local lUltAniv	As Logical
	Local lResgate	As Logical

	aAniv := {}

	nDiaAniv := 0
	nX := 0
	nDifData := 0
	nTo := 1
	nDia := Day( dDataCP )

	lUltAniv := .F.
	lResgate := !Empty( SEH->EH_DATARES )

	// Caso o dia da data de aniversário seja maior que 28
	// assumo que o dia do aniversário da poupança será
	// sempre o dia 01 do mês seguinte (Regra do BCB)
	If nDia > 28
		nDiaAniv := 1
		// Forço o laço para começar sempre a partir do dia 2
		// caso o aniversário da poupança seja no dia 1 por causa
		// da regra do dia 28 estabelecida pelo BCB caso não tenha
		// havido nenhum resgate nesta caderneta de poupança
		If !lResgate
			If nDia == 29
				nTo := 4
			ElseIf nDia == 30
				nTo := 3
			Else
				nTo := 2
			EndIf
		EndIf
	Else
		nDiaAniv := nDia
	EndIf

	// Verifico se o resgate está sendo feito no dia do aniversário ou posterior
	If Day( dDtSaldo ) - nDiaAniv >= 0 .And. DataValida( dDtSaldo, .T. ) == dDtSaldo
		lUltAniv := .T.
	Else
		lUltAniv := .F.
	EndIf

	// Caso tente efetuar resgate no mesmo dia ou em data anterior a outro resgate
	// evito que os rendimentos anteriores sejam calculados novamente em cima
	// do saldo restante na caderneta de poupança
	If lResgate
		nDifData := dDtSaldo - SEH->EH_DATARES
		dDataCP := SEH->EH_DATARES
	Else
		nDifData := dDtSaldo - dDataCP
	EndIf

	For nX := nTo To nDifData
		If Day( dDataCP + nX ) == nDiaAniv
			// Caso o aniversário da poupança caia num final de semana ou feriado,
			// neste mês, o aniversário será no dia útil seguinte ao dia do aniversário
			// da caderneta de poupança
			If lResgate .And. !lUltAniv
				If DataValida( dDataCP + nX, .T. ) <= dDtSaldo
					aAdd( aAniv, DtoS( DataValida( dDataCP + nX, .T. ) ) )
				EndIf
			Else
				aAdd( aAniv, DtoS( DataValida( dDataCP + nX, .T. ) ) )
			EndIf
		EndIf
	Next nX

Return aAniv

Static Function ProtCfgAdt()
Local aRet := {}
If FindFunction('CfgAdianta')
	aRet := CfgAdianta()
Else
	aRet := {;
			{FwModeAccess('FIE',1),;
 			 FwModeAccess('FIE',2),;
			 FwModeAccess('FIE',3),;
			 FWSIXUtil():ExistIndex( 'FIE', '4' ),;
			 FWSIXUtil():ExistIndex( 'FIE', '5' )},;
			{FwModeAccess('FR3',1),;
			 FwModeAccess('FR3',2),;
			 FwModeAccess('FR3',3),;
			 FWSIXUtil():ExistIndex( 'FR3' , '8' ),;
			 FWSIXUtil():ExistIndex( 'FR3' , '9' )},;
			{FwModeAccess('SE1',3),;
			 FwModeAccess('SE2',3)} }
EndIf
Return(aRet)

//------------------------------------------------------------------------------------------
	/*/{Protheus.doc} TemChqCr
	Verifica se existe cheque amarrado ao título aguardando compensação. (MV_SLDBXCR = C)
	@type  Function
	@author Renato.ito
	@since 30/01/2020
	@param cFilOrig, Character, E1_FILIAL
	@param cPrefixo, Character, E1_PREFIXO
	@param cTitulo, Character, E1_NUM
	@param cParcela, Character, E1_PARCELA
	@param cTipo, Character, E1_TIPO
	@return lAchou, Logical, retorna se existe um cheque para o título
	/*/
//------------------------------------------------------------------------------------------
Function TemChqCr(cFilOrig As Character, cPrefixo As Character, cTitulo As Character, cParcela As Character, cTipo As Character) As Logical

	Local cQuery As Character
	Local lAchou As Logical

	Default cFilOrig	:= ""
	Default cPrefixo	:= ""
	Default cTitulo		:= ""
	Default cParcela	:= ""
	Default cTipo		:= ""

	cQuery := "SELECT COUNT(EF_NUM) CHEQUE FROM " + RetSqlName("SEF") + " WHERE "
	cQuery += "EF_FILORIG = ? "
	cQuery += "AND EF_PREFIXO = ? "
	cQuery += "AND EF_TITULO =  ? "
	cQuery += "AND EF_PARCELA = ? "
	cQuery += "AND EF_TIPO = ? "
	cQuery += "AND EF_CART = ? "
	cQuery += "AND EF_LIBER  = ? "
	cQuery += "AND EF_DTCOMP = ? "
	cQuery += "AND EF_CHDEVOL != ? "
	cQuery += "AND D_E_L_E_T_ = ? "

	cQuery := ChangeQuery(cQuery)

	oPrepared:=FWPreparedStatement():New(cQuery)
	oPrepared:SetString(1, xFilial('SEF',cFilOrig))
	oPrepared:SetString(2, cPrefixo)
	oPrepared:SetString(3, cTitulo)
	oPrepared:SetString(4, cParcela)
	oPrepared:SetString(5, cTipo)
	oPrepared:SetString(6, 'R')
	oPrepared:SetString(7, Nil)
	oPrepared:SetString(8, Nil)
	oPrepared:SetString(9, 'S')
	oPrepared:SetString(10, Nil)

	cQuery:=oPrepared:GetFixQuery()

	lAchou := !Empty(MpSysExecScalar(cQuery,"CHEQUE"))

Return lAchou

/*/{Protheus.doc} FinHelp
Rotina para exibir HELP com direcionamento para o TDN/KCS
@type  Function
@author renato.campos
@since 06/06/2019
@version 12.1.17
@return
/*/
Function FinHelp(cTitulo AS Character, cMsg AS Character, aBtLinks AS Array, nLargura As Numeric, nAltura As Numeric)
Local oDlg 		AS Object
Local oBtnLink1 AS Object
Local oBtnLink2 AS Object
Local oBtnLink3 AS Object
Local oFont		AS Object

Default cTitulo := ""
Default cMsg := ""
Default aBtLinks := {}
Default nLargura := 500
Default nAltura  := 800

oFont 		:= TFont():New('Arial',,-12,.T.)

// Limite de 3 links externos para não estourar a tela
DEFINE MSDIALOG oDlg FROM 0,0 TO nLargura,nAltura TITLE OemToAnsi(cTitulo) PIXEL
oDlg:lMaximized := .F.

lHtml := .T.
TSay():New(10,10,{||cMsg},oDlg,,oFont,,,,.T.,,,295,300,,,,,,lHtml)

If Len(aBtLinks) >= 1
	oBtnLink1 := TButton():New( (oDlg:nHeight/2)-60, 3, aBtLinks[1,1]   ,oDlg,, 295 ,12,,,.F.,.T.,.F.,,.F.,,,.F. )
	oBtnLink1:SetCSS("QPushButton {text-decoration: underline; font-weight: bold; border: 0px solid #DCDCDC; border-radius: 0px;Text-align:left; }")
	oBtnLink1:bLClicked := {|| ShellExecute("open", aBtLinks[1,2] ,"","",SW_SHOW) }
EndIf

If Len(aBtLinks) >= 2
	oBtnLink2 := TButton():New( (oDlg:nHeight/2)-48, 3, aBtLinks[2,1]   ,oDlg,, 295 ,12,,,.F.,.T.,.F.,,.F.,,,.F. )
	oBtnLink2:SetCSS("QPushButton {text-decoration: underline; font-weight: bold; border: 0px solid #DCDCDC; border-radius: 0px;Text-align:left;}")
	oBtnLink2:bLClicked := {|| ShellExecute("open", aBtLinks[2,2] ,"","",SW_SHOW) }
EndIf

If Len(aBtLinks) >= 3
	oBtnLink3 := TButton():New( (oDlg:nHeight/2)-36, 3, aBtLinks[3,1]   ,oDlg,, 295 ,12,,,.F.,.T.,.F.,,.F.,,,.F. )
	oBtnLink3:SetCSS("QPushButton {text-decoration: underline; font-weight: bold; border: 0px solid #DCDCDC; border-radius: 0px;Text-align:left;}")
	oBtnLink3:bLClicked := {|| ShellExecute("open", aBtLinks[3,2] ,"","",SW_SHOW) }
EndIf

ACTIVATE MSDIALOG oDlg CENTERED

Return

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} setHelpColors
Função que utiliza seta as cores das fontes para apresentar na função FinHelp.

@type  Function
@author Fabio Henrique Andrade Silva
@since 01/07/2024
@param cColorTitle, Character, Passagem por Referência
@param cColorSubTitle, Character, Passagem por Referência
@param cColorText, Character, Passagem por Referência
@return Nil
/*/
//------------------------------------------------------------------------------------------
Function setHelpColors(cColorTitle,cColorSubTitle,cColorText)
	Local oTheme  As Object 
	Local lRelease2410   AS Logical 

	cColorTitle  	:= "#0c9abe"
	cColorSubTitle 	:= "#444"
	cColorText 		:= "#444"

	lRelease2410 	:= GetRpoRelease() >= "12.1.2410"

	If lRelease2410
	
		oTheme := totvs.framework.css.ProtheusTheme():New()
		
		cColorTitle 	:= oTheme:oTheme:neutralDark90
		cColorSubTitle 	:= oTheme:oTheme:fontColorLight 
		cColorText      := oTheme:oTheme:fontColorLight

	EndIf
Return


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} DEC_FIN
Função que utiliza o tipo de dado F (fixed) para multiplicações
que necessitem maior precisão matemática.

@type  Function
@author Fabio Casagrandre/Norberto M de Melo
@since 10/Mar/2020
@param nSaldo, Numeric
@param nTaxa, Numeric
@return nRet, Numeric
/*/
//------------------------------------------------------------------------------------------
Function DEC_FIN(nSaldo as Numeric,nTaxa as Numeric) as Numeric
	Local nRet as Numeric
	Local fDCSaldo //Variavel de ponto flutuante, não possui tipagem
	Local fDCTaxa  //Variavel de ponto flutuante, não possui tipagem
	Local fDCProduto //Variavel de ponto flutuante, não possui tipagem

	DEFAULT nSaldo := 0.0
	DEFAULT nTaxa := 0.0

	If !EMPTY(nSaldo+nTaxa)
		// Transforma os dados numericos em Fixed Size Decimal (ValType() = 'F')
		fDCSaldo := DEC_CREATE(ALLTRIM(STR(nSaldo)),15,8)
		fDCTaxa := DEC_CREATE(nTaxa,15,8)
		// Obtém o produto do Saldo pela Taxa
		fDCProduto := DEC_MUL(fDCSaldo,fDCTaxa)
		// Arredondamento
		nRet := RoundFIN(fDCProduto,8)
	else
		nRet := 0
	Endif

Return nRet
//------------------------------------------------------------------------------------------
/*/{Protheus.doc} RoundFIN
Arredondamento com suporte ao tipo de dado F (fixed) e à norma ABNT NBR 5891.

@type  Function
@author Fabio Casagrandre/Norberto M de Melo
@since 10/Mar/2020
@param uValor, Undefined (Numeric/Fixed)
@param nDec, Numeric
@param lABNT, Logical
@return nRet, Numeric
/*/
//------------------------------------------------------------------------------------------
Function RoundFIN(uValor as Variant, nDec as Numeric, lABNT as Logical) as Numeric
	Local nRet as Numeric
	Local nInt as Numeric
	Local nFrac as Numeric
	Local cNumToInc as Character
	Local cNumToChk as Character
	Local lIncrementa as Logical
	Local cFixed as Character

	Default uValor := 0
	Default nDec := 0
	Default lABNT := .F.

	nRet := If(VALTYPE(uValor)=='N',uValor,VAL(cValToChar(uValor)))

	nFrac := CTOD('')

	// Se os algarismos decimais seguintes
	// forem menores que 50, 500, 5000..., o anterior não se modifica.
	lIncrementa := .F.

	If !EMPTY(MOD(uValor,1))
		If VALTYPE(uValor) == 'N'
			nInt := INT(uValor)
			nFrac := MOD(uValor,1)
			cNumToInc := SUBSTR(STRTRAN(ALLTRIM(STR(nFrac)),'0.',''),1,nDec)
			cNumToChk := SUBSTR(STRTRAN(ALLTRIM(STR(nFrac)),'0.',''),nDec+1)
		ElseIf VALTYPE(uValor) == 'F'
			nInt := INT(VAL(cValToChar(uValor)))
			cFixed := SUBSTR(cValToChar(uValor),AT('.',cValToChar(uValor))+1)
			cNumToInc := SUBSTR(cFixed,1,nDec)
			cNumToChk := STRTRAN(cFixed,cNumToInc)
		EndIf

		If VAL(cNumToChk) > VAL('5'+REPLICATE('0',LEN(cNumToChk)-1))
			// Se os algarismos decimais seguintes
			// forem maiores a 50, 500, 5000..., o anterior incrementa-se em uma unidade.
			lIncrementa := .T.
		elseif VAL(cNumToChk) == VAL('5'+REPLICATE('0',LEN(cNumToChk)-1))
			// Para os casos ABNT: ------------------------------------
			// Se os algarismos decimais seguintes
			// forem iguais a 50, 500, 5000..., verifica-se o anterior;
			// se for par, o anterior não se modifica;
			// se for impar, o anterior incrementa-se em uma unidade.
			lIncrementa := If(lABNT, MOD(VAL(cNumToInc),2) > 0, .T.)
		EndIf

		nRet := nInt + VAL('0.' + cNumToInc)
		If lIncrementa
			nRet := nRet + (1/(10^nDec))
		EndIf
	EndIf

Return nRet

/*/{Protheus.doc} FerMunic
	Monta array com os feriados municipais cadastrados na tabela 63 (SX5)
	@type  Static Function
	@author Vitor Duca
	@since 02/06/2020
	@version version
	@param param, param_type, param_descr
	@return oRet, Object, HashMap com os feriados municipais
/*/
Static Function FerMunic()
	Local aFeriado As Array
	Local aRet	   As Array
	Local cTpFeriado As Character
	Local nPosFer	As Numeric
	Local nX		As Numeric
	Local oRet 		As Object

	aRet 	 	:= {}
	aFeriado 	:= FWGetSX5( "63",,"pt-br")
	nPosFer  	:= 0
	cTpFeriado	:= ""
	oRet 		:= NIL

	For nX := 1 to Len(aFeriado)
		nPosFer	 := At("[",aFeriado[nX][4])
		cTpFeriado := If( nPosFer != 0, SubSTR(aFeriado[nX][4],nPosFer+1,1),"U")
		If cTpFeriado == "M"
			Aadd(aRet,{aFeriado[nX][1]+SubSTR(aFeriado[nX][4],1,8)+cTpFeriado})
		Endif
	Next nX

	If !Empty(aRet)
		oRet := AtoHM(aRet)
		FwFreeArray(aRet)
	Endif

	FwFreeArray(aFeriado)

Return oRet

//------------------------------------------------------------------------------
/*/	{Protheus.doc} IRCurtoPrazo()
Retorna a Taxa de IR para Fundos de Curto Prazo (FIC)
SEH deve posicionada

@param nDiasApl - Dias corridos de Aplicação
@author	rafael rondon
@since 08/07/2020
@version	12.1.30
@return nTaxaIrf - Taxa de IR para FIC - Fundos de Curto Prazo (FIC)
/*/
//------------------------------------------------------------------------------
Function IRCurtoPrazo( nDiasApl As Numeric )  As Numeric

Local nTaxaIrf	As Numeric

Default nDiasApl	:= dDataBase - SEH->EH_DATA

nTaxaIrf := 0

If nDiasApl <= 180
	nTaxaIrf := 22.5
Else
	nTaxaIrf := 20
EndIf

Return nTaxaIrf


//------------------------------------------------------------------------------
/*/	{Protheus.doc} IRCurtoPrazo()
Retorna a Taxa de IR para Fundos de Curto Prazo (FIC)
SEH deve posicionada

@param nDiasApl - Dias corridos de Aplicação
@author	rafael rondon
@since 08/07/2020
@version	12.1.30
@return nTaxaIrf - Taxa de IR para FIC - Fundos de Curto Prazo (FIC)
/*/
//------------------------------------------------------------------------------
Static Function TxIRResgate( nDias As Numeric , aTabIrf As Array ) As Numeric

Local nTaxaIR		As Numeric
Local nAscan		As Numeric

Default nDias		:= dDataBase - SEH->EH_DATA
Default aTabIrf		:= {{ 180, 22.5 },{ 360, 20.0 },{ 720, 17.5 },{ 1000000, 15.0 }}

Do Case
	Case !Empty(SEH->EH_TAXAIRF)

		nTaxaIR := SEH->EH_TAXAIRF

	Case AllTrim(SEH->EH_TIPO) == "FIC" // Fundos de Curto prazo

		nTaxaIR := IRCurtoPrazo(nDias)

	Case SX5->(MsSeek(xFilial("SX5")+"AR"))

		nTaxaIR := Val( TabelaIrf( 'AR' , nDias ) )

	OtherWise

		nAscan := Ascan( aTabIrf, { |e| e[1] >= nDias } ) // Pesquisa a aliquota conforme o tempo da aplicacao
		nTaxaIR := aTabIrf[nAscan][2]

EndCase

Return nTaxaIR

//------------------------------------------------------------------------------
/*/	{Protheus.doc} IRAprCotas()
Caso tenha ocorrido come-cotas, retorna o IR referente ao rendimento que já foi deduzido pelo come-cotas para subtrair no IR do rendimento atual (diferencial do IR)
SEH deve posicionada

@param nQtdCotas - Valor em cotas referente ao resgate atual
@author	rafael rondon
@since 08/07/2020
@version	12.1.30
@return nIRAprop -
/*/
//------------------------------------------------------------------------------
Static Function IRAprCotas( nQtdCotas As Numeric , aUltComeCotas As Array) As Numeric

Local nIRAprop		As Numeric
Local nTaxaIR		As Numeric
Local nRendCome		As Numeric
Local nValIni		As Numeric
Local nValCome		As Numeric

Default aUltComeCotas	:= UltComeCotas()	// Busca data do ultimo come-cotas

nIRAprop := 0

If !Empty(aUltComeCotas[1])
	nTaxaIR := TaxaIRAp(.T.)
	/*
		Valor R$ das cotas a serem resgatas na cotação inicial
	*/
	nValIni := nQtdCotas * SEH->EH_VLRCOTA
	/*
		Valor R$ das cotas a serem resgatas na cotação do último Come-Cotas
	*/
	nValCome := nQtdCotas * aUltComeCotas[2]
	/*
		Rendimento inicial até último Come-Cotas
	*/
	nRendCome := nValCome - nValIni

	// Deduz IOF antes de calcular IR
	IF !EMPTY(aUltComeCotas) .AND. SEH->(EH_APLEMP == 'APL' .AND. EH_TIPO == 'FAF')
 		nRendCome -= FIN_IOF(SEH->EH_APLEMP, nRendCome, aUltComeCotas[1]-SEH->EH_DATA)
		nRendCome := RoundFIN(nRendCome,2,.T.)
	ENDIF

	nIRAprop := nRendCome * nTaxaIR / 100
EndIf

Return nIRAprop

//------------------------------------------------------------------------------
/*/	{Protheus.doc} UltComeCotas()
Retorna a Data e Cotação do Último come-cotas
SEH deve posicionada

@param nRendimento - Rendimento da aplicação
@author	rafael rondon
@since 08/07/2020
@version	12.1.30
@return aRet[1] - Data do último come-cotas
		aRet[2} - Cotação da data do último come-cotas
/*/
//------------------------------------------------------------------------------
Static Function UltComeCotas() As Numeric

	Local aArea			As Array
	Local aAreaSE0		As Array
	Local cQuery		As Character
	Local aRet			As Array
	Local oUltCC		As Object

	aRet		:= {}
	aArea		:= GetArea()
	aAreaSE0	:= SE0->(GetArea())
	cQuery 		:= ""
	oUltCC 		:= NIL

	AADD(aRet , CToD("")	)
	AADD(aRet , 0			)

	cQuery := " SELECT EI_DATA, EI_VLRQTS FROM " + RetSqlName("SEI")
	cQuery += " WHERE EI_FILIAL = ? "
	cQuery += " AND EI_APLEMP = ? "
	cQuery += " AND EI_NUMERO = ? "
	cQuery += " AND EI_REVISAO = ? "
	cQuery += " AND EI_MOTBX = ? "
	cQuery += " AND EI_TIPODOC = ? " // "I6" // Retencao do IRF  -- gravado no come-cotas (FINA183)
	cQuery += " AND EI_QTDCOTA > ? "	//	Quantidade de cotas "comidas" subtraídas
	cQuery += " AND EI_STATUS = ? "
	cQuery += " AND D_E_L_E_T_ = ? "
	cQuery += " ORDER BY EI_DATA DESC "

	cQuery	:= ChangeQuery(cQuery)
	oUltCC	:= FwExecStatement():New(cQuery)

	oUltCC:SetString(1, 	xFilial('SEI'))
	oUltCC:SetString(2, 	SEH->EH_APLEMP)
	oUltCC:SetString(3, 	SEH->EH_NUMERO)
	oUltCC:SetString(4, 	SEH->EH_REVISAO)
	oUltCC:SetString(5, 	'APR')
	oUltCC:SetString(6, 	'I6')
	oUltCC:SetNumeric(7, 	0)
	oUltCC:SetString(8, 	' ')
	oUltCC:SetString(9, 	' ')

	aRet[1]	:= SToD(oUltCC:ExecScalar('EI_DATA'))

	If !Empty(aRet[1])
		If Year(dDataBase) >= 2024 .And. SEH->EH_TIPO $ SuperGetMV("MV_APLCAL4", .F., "FAF")
			aRet[2] := oUltCC:ExecScalar('EI_VLRQTS')
		Else
			DbSelectArea('SE0')
			SE0->(DbSetOrder(2)) // E0_FILIAL+E0_BANCO+E0_AGENCIA+E0_CONTA+E0_CONTRAT+DTOS(E0_DATA)+E0_SUBCTA
			If SE0->(MsSeek(xFilial("SE0")+ SEH->(EH_BCOCONT + EH_AGECONT + EH_CTACONT + EH_CONTRAT + DToS(aRet[1]))))
				aRet[2] := SE0->E0_VALOR
			EndIf
		EndIf
	EndIf

	If oUltCC <> Nil
		oUltCC:Destroy()
	EndIf

	RestArea(aAreaSE0)
	RestArea(aArea)

Return aRet

//------------------------------------------------------------------------------
/*/	{Protheus.doc} TaxaIRAp()
Retorna a Taxa de IR para Apropriação por cotas
SEH deve posicionada

@param lComeCotas - Mês do come-cotas?


@return nTaxaIrf - Taxa de IR para apropriação por cotas

@author	rafael rondon
@since 08/07/2020
@version	12.1.30
/*/
//------------------------------------------------------------------------------
Function TaxaIRAp( lComeCotas As Logical  ) As Numeric

Local nTaxaIrf	As Numeric
Local nDiasApl	AS Numeric

Default lComeCotas		:= (StrZero(Month(dDataBase),2) $ SuperGetMv("MV_10892",,"05#11")) // Meses do come cotas

nTaxaIrf	:= 0
nDiasApl	:= dDataBase - SEH->EH_DATA

If lComeCotas
	/*
		No mês do come-cotas considera-se alíquota:
		Fundos de curto prazo = 20%	(FIC)
		Fundos de longo prazo = 15% (FAF)
	*/
	If AllTrim(SEH->EH_TIPO) == "FIC" // Curto prazo
		nTaxaIrf := 20
	Else
		nTaxaIrf := 15
	EndIf
Else
	If SuperGetMv("MV_APIRTAB",,.F.) // Define alíquota de IR para os meses não come-cotas, .T. - será considerada tabela regressiva de IR; .F. - 15% / 20%
		/*
			Meses que não são come-cotas considera a tabela regressiva de IR
		*/
		If AllTrim(SEH->EH_TIPO) == "FIC"
			nTaxaIrf := IRCurtoPrazo( nDiasApl )
		Else
			nTaxaIrf := Val(TabelaIrf( "AR" , nDiasApl ) )
		EndIf
	Else
		/*
			Entendimento em 14/07/2020 é que com o parâmetro MV_APIRTAB = .T. acima é o correto, porém foi parametrizado para quem operava com 15%.
		*/
		If AllTrim(SEH->EH_TIPO) == "FIC" // Curto prazo
			nTaxaIrf := 20
		Else
			nTaxaIrf := 15
		EndIf
	EndIf
EndIf

Return nTaxaIrf

//-------------------------------------
/*/{Protheus.doc}SeqBxFKs
Busca a última sequência de baixa do título nas tabelas FK1 ou FK2

@param cTabFk, char, Tabela FK na qual será feita a busca na sequencia de baixa
@param cFil, char, Filial de inclusão do título
@param cPref, char, Prefixo do título
@param cNro, char, Número do título
@param cParc, char, Parcela do título
@param cTipo, char, Tipo do título
@param cCliFor, char, Cliente / Fornecedor do título
@param cLoja, char, Loja do Cliente / Fornecedor do título
@param oQryFk1, char, Objeto de consulta da tabela FK1
@param oQryFk1, char, Objeto de consulta da tabela FK2
@return cSeqMax, char, retorna a última sequência de baixa do título

@author Sivaldo Oliveira
@since  09/09/2020
@version 12
@type  Function
/*/
//-------------------------------------
Function SeqBxFKs(cTabFk As Char, cFil As Char, cPref As Char, cNro As Char, cParc As Char, cTipo As Char, cCliFor As Char, cLoja As Char,;
oQryFk1 As Object, oQryFk2 As Object) As Char
	Local cChaveTit As Char
	Local cChaveFk7 As Char
	Local cQuery As Char
	Local cSeqMax As Char
	Local cSequen As Char
	Local cTipDoc As Char
	Local cTblTmp As Char

	Default cTabFk  := ""
	Default cFil    := ""
	Default cPref   := ""
	Default cNro    := ""
	Default cParc   := ""
	Default cTipo   := ""
	Default cCliFor := ""
	Default cLoja   := ""
	Default oQryFk1 := Nil
	Default oQryFk2 := Nil

	//Inicializa variáveis.
	cChaveTit := ""
	cChaveFk7 := ""
	cQuery    := ""
	cSeqMax   := ""
	cSequen   := ""
	cTipDoc   := ""
	cTblTmp   := ""

	If !Empty(cTabFk) .And. cTabFk $ "FK1|FK2"
		cChaveTit := cFil + "|" + cPref + "|" + cNro + "|" + cParc + "|" + cTipo + "|" + cCliFor + "|" + cLoja
    	cChaveFk7 := FINGRVFK7(Iif(cTabFk == "FK1", "SE1", "SE2"), cChaveTit)

		If cTabFk == "FK1"
			cSequen := AllTrim(PadR("0", TamSX3("FK1_SEQ")[1], "0"))

			If oQryFk1 == Nil
				cQuery := "SELECT ISNULL(MAX(FK1_SEQ), '" + cSequen + "') MAXSEQ "
				cQuery += "FROM " + RetSqlName("FK1") + " FK1 WHERE "
				cQuery += "FK1_FILIAL = ? "
				cQuery += "AND FK1_IDDOC = ? "
				cQuery += "AND FK1.D_E_L_E_T_ = ' ' "
				cQuery  := ChangeQuery(cQuery)
				oQryFk1 := FWPreparedStatement():New(cQuery)
			EndIf

			oQryFk1:SetString(1, xFilial(cTabFk) )
			oQryFk1:SetString(2, cChaveFk7)
			cQuery := oQryFk1:GetFixQuery()
		Else
			cSequen := AllTrim(PadR("0", TamSX3("FK2_SEQ")[1], "0"))

			If oQryFk2 == Nil
				cQuery := "SELECT ISNULL(MAX(FK2_SEQ), '" + cSequen + "') MAXSEQ "
				cQuery += "FROM " + RetSqlName("FK2") + " FK2 WHERE "
				cQuery += "FK2_FILIAL = ? "
				cQuery += "AND FK2_IDDOC = ? "
				cQuery += "AND FK2.D_E_L_E_T_ = ' ' "
				cQuery  := ChangeQuery(cQuery)
				oQryFk2 := FWPreparedStatement():New(cQuery)
			EndIf

			oQryFk2:SetString(1, xFilial(cTabFk))
			oQryFk2:SetString(2, cChaveFk7)
			cQuery := oQryFk2:GetFixQuery()
		EndIf

		cTblTmp := MpSysOpenQuery(cQuery)
		cSeqMax := AllTrim((cTblTmp)->MAXSEQ)
		(cTblTmp)->(DbCloseArea())
		cSeqMax := Iif(cSequen == cSeqMax, "", cSeqMax)
	EndIf
Return cSeqMax

/*/
{Protheus.doc} FIN_IOF()
Retorna o Calculo de IOF sobre Operações de Crédito, Câmbio e Seguro ou relativas a Títulos ou Valores Mobiliários

@param cAplEmp - Caracter - Identifica tipo Operação
@param nBaseCalculo - Valor monetário - Montante onde será aplicado o calculado de IOF
@param nDiasAcumulados - Quantidade de dias a ser aplicado o IOF diario
@param nIOFAdicional - Percentual - Atualmente este valor muda quando aplicado:
									para empréstimo e financiamento	de 0,38% a 3,38%
									para cartão de crédito	6,38%
									para seguro	até 25%
									para câmbio de moedas	1,1% sobre o total
@param nIOFDiario - Percentual - IOF incidente sobre operações de crédito.
@author	Norberto M de Melo
@since 03/09/2020
@version 1.0
@return nValorIOF - Valor calculado do IOF
/*/
FUNCTION FIN_IOF(cAPlEmp AS CHARACTER, nBaseCalculo AS NUMERIC, nDiasAcumulados AS NUMERIC, nIOFAdicional AS NUMERIC, nIOFDiario AS NUMERIC) AS NUMERIC
	LOCAL nValorIOF AS NUMERIC
	LOCAL nRet AS NUMERIC
	LOCAL nTaxaIOF as Variant// Tipo (F)IXED

	DEFAULT cAplEmp := 'EMP'
	DEFAULT nBaseCalculo := 0.00
	DEFAULT nDiasAcumulados := 0
	DEFAULT nIOFAdicional := 0.38
	DEFAULT nIOFDiario := IF(FWSM0Util():GetSM0Data(cEmpAnt,cFilAnt,{'M0_TPINSC'})[1][2]==2,0.0041,0.0082)

	nRet := 0.00
	nBaseCalculo := ABS(nBaseCalculo)
	nDiasAcumulados := ABS(nDiasAcumulados)
	nIOFAdicional := ABS(nIOFAdicional)
	nIOFDiario := ABS(nIOFDiario)

	IF !EMPTY(nBaseCalculo)
		nTaxaIOF := DEC_CREATE(0,12,8)
		nBaseCalculo := DEC_CREATE(nBaseCalculo,15,8)

		IF cAplEmp == 'EMP' .AND. !EMPTY(nIOFAdicional)
			// Converte as taxas de porcentagem para decinal
			nIOFAdicional := DEC_DIV(DEC_CREATE(nIOFAdicional,12,8),DEC_CREATE(100,6,0))

			If !EMPTY(nIOFDiario) .AND. !EMPTY(nDiasAcumulados)
				nIOFDiario := DEC_DIV(DEC_CREATE(nIOFDiario,12,8),DEC_CREATE(100,6,0))
				// Multiplica IOF diario pelos dias acumulados
				nIOFDiario := DEC_MUL(nIOFDiario,DEC_CREATE(MIN(nDiasAcumulados,365),6,0))
			ELse	// Garantir que o tipo seja (f)ixed para o correto uso na DEC_ADD()
				nIOFDiario := DEC_CREATE(nIOFDiario,12,8)
			EndIf

			// Soma os fatores IOF Adicional e Diario
			nTaxaIOF := DEC_ADD(nIOFAdicional,nIOFDiario)
		ELSEIF cAplEmp == 'APL' .AND. !EMPTY(nDiasAcumulados) .AND. ABS(nDiasAcumulados) <= 29
			nTaxaIOF := DEC_CREATE((VAL(TABELA('A0'/*Tabela IOF SX5*/, STRZERO(nDiasAcumulados,2)))/100),12,8)
		ENDIF

		// Multiplica para encontrar o valor do IOF
		nValorIOF := DEC_MUL(nBaseCalculo,nTaxaIOF)
		// Aplica arredondamento
		nRet := RoundFIN(nValorIOF,2,.T.)
	ENDIF
RETURN nRet

//--------------------------------------
/*/{Protheus.doc}FinTotAb
Retorna o total de abatimento de um título.

@Param cTabela, tabela de títulos a pagar ou receber
@Param cChaTitPai, chave do titulo pai (E1/E1 - TITPAI)
@Param cFilialOri, Filial de origem do título pai
@Param nMoedaDest, moeda na qual deve retornar o valor do abatimento
@Param dDataRef, data de referência a ser usada na conversão de moeda
@Param nCasDec, Casas decimais a ser considerada no arredondamento
@Param oObjAb, objeto com a consulta do abatimento, um objeto por carteira.
@Param cListaAb, Char lista dos abatimentos
@Param cSeparador Char caracter separador dos abatimentos
@return nTotal, retorna o total de abatimento.

@author Sivaldo Oliveira
@since  07/10/2020
@version 12
/*/
//----------------------------------------
Function FinTotAb(cTabela As Char, cChaTitPai As Char, cFilialOri As Char, nMoedaDest As Numeric, dDataRef As Date, nCasDec As Numeric,;
																	oObjAb As Object, cListaAb As Char, cSeparador As Char) As Numeric
	Local nTotal As Numeric
	Local nVlrAb As Numeric
	Local cQry   As Char
	Local lSE1Shared As Logical
	Local lSE2Shared As Logical

	//Inicializa variáveis.
	nTotal 		:= 0
	nVlrAb 		:= 0
	cQry   		:= ""
	lSE1Shared 	:= FWModeAccess('SE1', 1) == "C"
	lSE2Shared 	:= FWModeAccess('SE2', 1) == "C"

	Default cTabela    := ""
	Default cChaTitPai := ""
	Default cFilialOri := cFilAnt
	Default nMoedaDest := 1
	Default dDataRef   := dDataBase
	Default oObjAb     := Nil
	Default nCasDec    := 2
	Default cListaAb   := MVABATIM
	Default cSeparador := "|"

	cTabela := AllTrim(cTabela)

	If cTabela $ "SE1|SE2" .And. !Empty(cChaTitPai)
		If cTabela == "SE1"
			cChaTitPai := PadR(cChaTitPai, TamSx3("E1_TITPAI")[1], "")

			If oObjAb == Nil
				cQry := "SELECT E1_VALOR VALORINC, ISNULL(E1_MOEDA, 0) MOEDAINC, ISNULL(E1_TXMOEDA, 0) TAXAINC FROM " + RetSqlName(cTabela) + " "
				
				if(lSE1Shared)
					cQry += "WHERE E1_TITPAI = ? AND E1_FILORIG = ? AND E1_TIPO IN (?) "
				Else
					cQry += "WHERE E1_TITPAI = ? AND E1_FILIAL = ? AND E1_TIPO IN (?) "
				EndIf

				cQry += "AND D_E_L_E_T_ = ? "
				cQry := ChangeQuery(cQry)
			EndIf
		Else
			cChaTitPai := PadR(cChaTitPai, TamSx3("E2_TITPAI")[1], "")

			If oObjAb == Nil
				cQry := "SELECT E2_VALOR VALORINC, ISNULL(E2_MOEDA, 0) MOEDAINC, ISNULL(E2_TXMOEDA, 0) TAXAINC FROM " + RetSqlName(cTabela) + " "

				if(lSE2Shared)
					cQry += "WHERE E2_TITPAI = ? AND E2_FILORIG = ? AND E2_TIPO IN (?) "
				Else
					cQry += "WHERE E2_TITPAI = ? AND E2_FILIAL = ? AND E2_TIPO IN (?) "
				EndIf

				cQry += "AND D_E_L_E_T_ = ? "
				cQry := ChangeQuery(cQry)
			EndIf
		EndIf

		If oObjAb == Nil
			oObjAb := FWExecStatement():New(cQry)
		EndIf

		oObjAb:SetString(1, cChaTitPai)
		oObjAb:SetString(2, cFilialOri)
		oObjAb:SetIn(3, FinSetIn(cListaAb, cSeparador))
		oObjAb:SetString(4, ' ')
		cTblTmp := oObjAb:OpenAlias()

		While (cTblTmp)->(!Eof())
			If (cTblTmp)->MOEDAINC == 0
				(cTblTmp)->(DbSkip())
				Loop
			EndIf

			nVlrAb := (cTblTmp)->VALORINC

			If (cTblTmp)->MOEDAINC != nMoedaDest
				nVlrAb := Round(xMoeda(nVlrAb, (cTblTmp)->MOEDAINC, nMoedaDest, dDataRef, 4, (cTblTmp)->TAXAINC, Nil), 2)
			EndIf

			nTotal += nVlrAb
			(cTblTmp)->(DbSkip())
		EndDo

		(cTblTmp)->(DbCloseArea())
	EndIf
Return nTotal

//--------------------------------------------
/*/{Protheus.doc}FinSetIn
Cria um vetor com os tipos de títulos, o objetivo é ,
que esse vetor seja usado na função SetIn da instância
da classe FwPreparedStatement.

@Param cString, lista dos tipos
@Param cSeparador, caracter que separa os tipos
@return aTipo, retorna um vetor com os tipos

@author Sivaldo Oliveira
@since  07/10/2020
@version 12
/*/
//--------------------------------------------
Function FinSetIn(cString As Char, cSeparador As Char, nLenTipo As Numeric) As Array
	Local cTipo      As Character
	Local cCaract    As Character
	Local nY         As Numeric
	Local nLenString As Numeric
	Local nQuant     As Numeric
	Local aTipo      As array

	Default cString    := ""
	Default cSeparador := ""
	Default nLenTipo   := 0

	//Inicializa variáveis
	cTipo      := ""
	cCaract    := ""
	nY         := 0
	nLenString := 0
	nQuant     := 0
	aTipo      := {}
	cSeparador := AllTrim(cSeparador)

	If !Empty(cSeparador)
		cString    := AllTrim(cString)

		If (nLenString := Len(cString)) > 0
			If nLenTipo == 0
				nLenTipo := TamSx3("E2_TIPO")[1]
			EndIf
		EndIf

		For nY := 1 To nLenString
			cCaract := SUBSTR(cString, nY, 1)

			If cCaract == cSeparador
				If nY < nLenString
					Loop
				EndIf
				cCaract := ""
			EndIf

			cTipo  += cCaract
			nQuant += 1

			If ((nQuant == nLenTipo) .Or. (nY == nLenString))
				Aadd(aTipo,  Padr(AllTrim(cTipo), nLenTipo, ""))
				cTipo  := ""
				nQuant := 0
			EndIf
		Next nY
	EndIf

	If Len(aTipo) == 0
		aTipo := {""}
	EndIf
Return aTipo

/*/{Protheus.doc} NewSumAbat
	Realiza o calculo dos abatimentos para processos massivos,
	(relatorios e baixas automaticas), a função não realiza a conversão
	pelo xMoeda(), sendo responsabilidade da função chamadora efetuar a conversão

	@type  Function
	@author Vitor Duca
	@since 30/10/2020
	@version 1.0
	@param cTable, Character, Tabela temporaria que recebera o UPDATE
	@param aUpdField, Array, Array com os campos da temporaria que receberão o UPDATE
	@param cCarteira, Character, Carteira do titulo (Pagar = P, Receber = R)
	@param aFieldsTmp, Array, Array contendo os campos da temporaria que possuem a informação do _TITPAI (chave do titulo)
	@return nError, Numeric, Codigo de erro na execução da função TcSqlExec()
	@example
	(examples)
	@see (links_or_references)
/*/
Function NewSumAbat(cTable As Character,aUpdField As Character,cCarteira As Character,aFieldsTmp As Array)
	Local nError   As Numeric
	Local cQry 	   As Character
	Local cNulo	   As Character
	Local cBDname  As Character
	Local cTblAbt  As Character
	Local cFieldAbt As Character
	Local cSelect As Character
	Local nX		As Numeric

	Default cTable	  := RetSqlName("SE1")
	DEFAULT aUpdField := {}
	DEFAULT cCarteira := "R"
	DEFAULT aFieldsTmp := {}

	nError    := 0
	cQry 	  := ""
	cNulo	  := ""
	cSelect   := ""
	cBDname   := Upper( TCGetDB() )
	cAliasTMP := IIF( cBDname $ "POSTGRES", "", cTable + "." )
	cTblAbt   := "SE1"
	cFieldAbt := "E1"

	Do CASE
		CASE cBDname $ "ORACLE|INFORMIX|DB2"
			cNulo := "NVL"
		CASE cBDname $ "POSTGRES|MYSQL"
			cNulo := "COALESCE"
		OTHERWISE
			cNulo := "ISNULL"
	End CASE

	If cCarteira == "P"
		cTblAbt := "SE2"
		cFieldAbt := "E2"
	Endif

	nFieldUpd := Len(aUpdField)

	If nFieldUpd == 3
		For nX := 1 to nFieldUpd
			If nError == 0
				Do Case
					Case nX == 1
						cSelect := "((SELECT SUM(" + cTblAbt + "." + cFieldAbt + "_VALOR" + ") "
					Case nX == 2
						cSelect := "((SELECT " + cTblAbt + "." + cFieldAbt + "_MOEDA" + " "
					OtherWise
						cSelect := "((SELECT " + cTblAbt + "." + cFieldAbt + "_TXMOEDA" + " "
				EndCase

				cQry := " UPDATE " + cTable
				cQry += " SET "+ cAliasTMP + aUpdField[nX] + " = "
				cQry += cNulo + cSelect
				cQry += " FROM " + RetSqlName(cTblAbt) + " " + cTblAbt
				cQry += " WHERE " + cTblAbt + "." + cFieldAbt + "_FILIAL = "+ cTable + "." + aFieldsTmp[1] + " AND "
				cQry += cTblAbt + "." + cFieldAbt + "_TITPAI = " + cTable + "." + aFieldsTmp[2] + " + " + cTable + "." + aFieldsTmp[3]
				cQry += " + " + cTable + "." + aFieldsTmp[4] + " + " + cTable + "." + aFieldsTmp[5]
				cQry += " + " + cTable + "." + aFieldsTmp[6] + " + " + cTable + "." + aFieldsTmp[7] + " AND "
				cQry += " " + cTblAbt+"."+"D_E_L_E_T_ = ' ' AND "
				cQry += cTable+ ".D_E_L_E_T_ = ' '),0) "

				nError := TcSQLExec(cQry)
			Endif
		Next
	Endif

Return nError

/*/{Protheus.doc} FxBcoBloq
	Função responsavel por verificar se banco esta bloqueado para processos massivos,
	funcionamento semelhante ao da função CCBlocked()

	@type  Function
	@author Vitor Duca
	@since 20/11/2020
	@version 1.0
	@param cTable, Character, Tabela temporaria que recebera o UPDATE
	@param cUpdField, Character, Campo da tabela temporaria que ira receber o UPDATE
	@param aFieldsTmp, Array, Array contendo os campos da temporaria que possuem a do ID da baixa e Filial de acordo com a carteira
	@return nError, Numeric, Codigo de erro na execução da função TcSqlExec()
	@example
	FxBcoBloq(_oFINA0902:GetRealName(),{FK2_FILIAL,FK2_IDFK2})
	@see
/*/
Function FxBcoBloq(cTable As Character,aFieldsTmp As Array) As Numeric
	Local nError   As Numeric
	Local cQry 	   As Character
	Local cBDname  As Character
	Local nTamFilA6 As Numeric
	Local cSubs		As Character

	Default cTable	  := RetSqlName("SE1")
	DEFAULT aFieldsTmp := {}

	nError    := 0
	cQry 	  := ""
	cBDname   := Upper( TCGetDB() )
	nTamFilA6 := Len(AllTrim(xFilial("SA6")))
	cSubs     := "SUBSTRING"

	If cBDname $ "ORACLE|POSTGRES"
		cSubs 	:= "SUBSTR"
	EndIf

	cQry := "DELETE FROM "+cTable+" "
	cQry += "WHERE "+cTable+".R_E_C_N_O_ IN (SELECT TEMP.R_E_C_N_O_ FROM "+cTable+" TEMP "
	cQry += "INNER JOIN "+RetSqlName("FKA")+" FKA1 ON FKA1.FKA_FILIAL = TEMP."+aFieldsTmp[1]+" AND FKA1.FKA_IDORIG = TEMP."+aFieldsTmp[2]+" AND FKA1.D_E_L_E_T_ = '' "
 	cQry += "LEFT JOIN "+RetSqlName("FKA")+" FKA2 ON FKA2.FKA_FILIAL = FKA1.FKA_FILIAL AND FKA2.FKA_IDPROC = FKA1.FKA_IDPROC AND FKA2.D_E_L_E_T_ = '' "
	cQry += "INNER JOIN "+RetSqlName("FK5")+" FK5  ON  FK5.FK5_FILIAL = FKA2.FKA_FILIAL AND FKA2.FKA_TABORI = 'FK5' AND FK5.FK5_IDMOV = FKA2.FKA_IDORIG AND FK5.D_E_L_E_T_ = '' "
	cQry += "INNER JOIN "+RetSqlName("SA6")+" SA6 ON SA6.A6_FILIAL = "+cSubs+"(FK5.FK5_FILORI,1,"+cValTochar(nTamFilA6)+") AND SA6.A6_COD = FK5.FK5_BANCO AND SA6.A6_AGENCIA = FK5.FK5_AGENCI AND SA6.A6_NUMCON = FK5.FK5_CONTA AND SA6.D_E_L_E_T_ = '' "
	cQry += "WHERE "
	cQry += "SA6.A6_BLOCKED = '1' AND SA6.A6_DTBLOQ <= '"+Dtos(dDataBase)+"' "
	cQry += "AND TEMP.D_E_L_E_T_ = ' ' "

	IF SA6->(ColumnPos("A6_MSBLQL")) > 0
		cQry += " OR (SA6.A6_MSBLQL = '1' AND TEMP.D_E_L_E_T_ = ' ')"
	ENDIF

	cQry += ")"

	nError := TcSQLExec(cQry)

Return nError

/*/{Protheus.doc} FinSqlLog
	Função para logar os erros de execução do TcSQLExec.
	@type  Function
	@author Vitor Duca
	@since 20/11/2020
	@version 1.0
	@param cLogName, Character, Nome do log a ser gravado
	@param cLogText, Character, Identificação do erro
	@param cSQLControl, Character, Erro retornado pela função TcSqlExec
	@return return_var, return_type, return_description
	@example
	FinSqlLog("FR090LOG","UPDATE_TEMPORARIA",tcSqlError())
	@see (links_or_references)
/*/
Function FinSqlLog(cLogName As Character, cLogText As Character, cSQLControl As Character)
	Local cFunction As Character
	Local cLogFile  As Character
	Local cLogHead  As Character
	Local cPath     As Character
	Local cProcLine As Character
	Local cThreadID As Character
	Local lContinua As Logical
	Local nHandle   As Numeric

	lContinua := .T.
	cPath := "\SYSTEM\"
	cLogFile := cPath + cLogName +Alltrim(cEmpAnt+cFilant)+"_"+Dtos(Date())+".log"

	If !File(cLogFile)
		nHandle := FCreate( cLogFile )
		If nHandle == -1
			lContinua := .F.
		Else
			cLogHead:= DToC(date()) + CRLF
			FSeek ( nHandle, 0, 2 )	// Posiciona no final do arquivo.
			FWrite( nHandle, cLogHead, Len(cLogHead) )
			FClose(nHandle)

		EndIf
	EndIf

	If lContinua

		cThreadID 	:= AllTrim(Str(ThreadID())) 	//Retorna o ID (número de identificação) da thread em que a chamada da função foi realizada
		cProcLine 	:= AllTrim(Str(ProcLine(1))) 	//Retorna o número da linha do código fonte executado que fez a chamada da geração do LOG
		cFunction 	:= ProcName(1) 					//Retorna o nome da funcao em execução que fez a chamada da geração do LOG

		cFunction := " Function " + cFunction

		cLogText := Time() + " " + "["+cThreadID+"]" + cFunction + " Line " + cProcLine + CRLF +;
					Space(5) +  "[" + cSQLControl + "] " + cLogText + CRLF

		// Grava o texto no Arquivo de LOG
		nHandle := FOpen(cLogFile, 2 )
		FSeek ( nHandle, 0, 2 )	// Posiciona no final do arquivo.
		FWrite( nHandle, cLogText, Len(cLogText) )
		FClose( nHandle )
	EndIf

Return

/*/{Protheus.doc} FinSomaFK6
Rotina que soma os valores acessórios para SaldoTit (procedure).

@type       function
@author     Rafael Riego
@since      19/01/2020
@param      cFilMov, character, filial do movimento (FK5_FILIAL/E5_FILIAL)
@param      cFilTit, character, filial do título (E1_FILIAL/E2_FILIAL)
@param      cIdDoc, character, Id do titulo na FK7
@param      cCarteira, character, carteira do título
@param      dDataBaixa, date, data da baixa
@param      cTipoData, character, tipo da data a ser utilizada na pesquisa {"0" = E5_DATA; "1" = E5_DTDISPO; "2" = E5_DTDIGIT}
@param      cAdiant, character, IIf(cTipo $ MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG), "1","0")
@param      dDataBase, date, database utilizada na soma
@param      cFilOri, character, filial de origem do título
@param      nMoedaTit, numeric, moeda do título
@param      nTaxaMoeda, numeric, taxa da moeda
@return     numeric, valor acessório somado
/*/
Function FinSomaFK6(cFilMov As Character, cIdDoc As Character,;
					cCarteira As Character, dDataBaixa As Date, cTipoData As Character,;
					cAdiant As Character, dDataBase As Date, cFilOri As Character,;
					nMoedaTit As Numeric, nTaxaMoeda As Numeric) As Numeric

	Local aArea			As Array
    Local aBind         As Array
    Local cAliasTMP     As Character
    Local cCartAux      As Character
    Local cDataBaixa    As Character
    Local cDataBase     As Character
    Local cQuery        As Character
    Local nVA           As Numeric

	nVa := 0

	aArea		:= GetArea()
	cCartAux    := cCarteira
	cDataBaixa  := DToS(dDataBaixa)
	cDataBase   := DToS(dDataBase)

	If __lCmpoFK1 == Nil .Or. __lCmpoFK2 == Nil
		__lCmpoFK1	:= FK1->(FieldPos("FK1_DTDISP")) > 0 .And. FK1->(FieldPos("FK1_DTDIGI")) > 0
		__lCmpoFK2	:= FK2->(FieldPos("FK2_DTDISP")) > 0 .And. FK2->(FieldPos("FK2_DTDIGI")) > 0
	EndIf

	If cAdiant == "1"
		If cCartAux == "P"
			cCartAux := "R"
		Else
			cCartAux := "P"
		EndIf
	EndIf

	//cTipoData := "0"  // FK1_DATA/FK2_DATA
	//cTipoData := "1"  // FK1_DTDISP/FK2_DTDISP
	//cTipoData := "2"  // FK1_DTDIGI/FK2_DTDIGI
	If cCartAux == "P"
		If !__lCmpoFK2 .And. cTipoData $ "1|2"
			Return nVa
		EndIf
		If Empty(__cQryFK6P)
			__cQryFK6P := FinFK6Pag()
		EndIf
		cQuery := __cQryFK6P
	Else
		If !__lCmpoFK1 .And. cTipoData $ "1|2"
			Return nVa
		EndIf
		If Empty(__cQryFK6R)
			__cQryFK6R := FinFK6Rec()
		EndIf
		cQuery := __cQryFK6R
	EndIf

	If (__lCmpoFK1 .And. cCartAux == "R") .Or. (__lCmpoFK2 .And. cCartAux == "P")
		aBind := {;
			FWxFilial("FK1",cFilMov)	        ,;//#01
			cIdDoc			,;//#02
			cFilOri         ,;//#03
			cDataBaixa      ,;//#04
			cTipoData       ,;//#05
			cDataBaixa      ,;//#06
			cTipoData       ,;//#07
			cDataBaixa      ,;//#08
			cTipoData       ,;//#09
			cCartAux        ,;//#10
			cCartAux        ,;//#11
			cCarteira       ,;//#12
			cDataBase       ,;//#13
			cTipoData       ,;//#14
			cDataBase       ,;//#15
			cTipoData       ,;//#16
			cDataBase       ,;//#17
			cTipoData       } //#18
	Else
		aBind := {;
			FWxFilial("FK1",cFilMov)	        ,;//#01
			cIdDoc			,;//#02
			cFilOri         ,;//#03
			cDataBaixa      ,;//#04
			cCartAux        ,;//#05
			cCartAux        ,;//#06
			cCarteira       ,;//#07
			cDataBase       }//#08
	EndIf

	cAliasTMP := GetNextAlias()

	DbUseArea(.T., "TOPCONN", TCGenQry2(Nil, Nil, cQuery, aBind), cAliasTMP, .F., .T.)

	If __nMoeda != nMoedaTit
		While (cAliasTMP)->(!(EoF()))
			nVa += Round(NoRound(xMoeda((cAliasTMP)->VA, 1, nMoedaTit, (cAliasTMP)->FKDATA, 3,, IIf((cAliasTMP)->TXMOEDA == 0, nTaxaMoeda, (cAliasTMP)->TXMOEDA)), 3), 2)
			(cAliasTMP)->(DbSkip())
		End
	Else
		While (cAliasTMP)->(!(EoF()))
			nVa += (cAliasTMP)->VA
			(cAliasTMP)->(DbSkip())
		End
	EndIf

	(cAliasTMP)->(DbCloseArea())
	FwFreeArray(aBind)
	RestArea(aArea)

Return nVA

/*/{Protheus.doc} FinFK6Rec
Construção da query de soma do VA para títulos a receber (SE1).

@type       function
@author     Rafael Riego
@since      19/01/2020
@return     character, query para somatória do VA
/*/
Static Function FinFK6Rec() As Character

    Local cQuery    As Character

	cQuery := " SELECT FK1.FK1_DATA FKDATA, FK1.FK1_TXMOED TXMOEDA, COALESCE(SUM(CASE WHEN FK6.FK6_ACAO = '1' THEN FK6.FK6_VALMOV ELSE -FK6.FK6_VALMOV END), 0) VA"
    cQuery += " FROM " + RetSQLName("FK1") + " FK1 "
    cQuery += " INNER JOIN " + RetSQLName("FK6") + " FK6 ON "
    // Filtros JOIN FK1 x FK6
    cQuery += " FK6.FK6_FILIAL = FK1.FK1_FILIAL "
    cQuery += " AND FK6.FK6_IDORIG = FK1.FK1_IDFK1 "
    cQuery += " AND FK6.FK6_TABORI = 'FK1' "
    cQuery += " AND FK6.FK6_TPDOC = 'VA' "
    cQuery += " AND FK6.D_E_L_E_T_ = ' ' "
    // Filtros FK1
    cQuery += " WHERE "

	cQuery += " FK1.FK1_FILIAL = ? " //#01
    cQuery += " AND FK1.FK1_IDDOC = ? " //#02
    cQuery += " AND FK1.D_E_L_E_T_ = ' ' "
    cQuery += " AND FK1.FK1_FILORI = ? "		//#03
    cQuery += " AND FK1.FK1_TPDOC IN ('VL', 'BA', 'V2', 'CP', 'LJ') "

	If __lCmpoFK1
    	cQuery += " AND ((FK1.FK1_DATA <= ? AND ? = '0') "	//(#10/#11) ou (#04/#05)
    	cQuery += " OR (FK1.FK1_DTDISP <= ? AND ? = '1') "	//(#12/#13) ou (#06/#07)
    	cQuery += " OR (FK1.FK1_DTDIGI <= ? AND ? = '2')) "	//(#14/#15) ou (#08/#09)
	Else
		cQuery += " AND FK1.FK1_DATA <= ? "
	EndIf
    cQuery += " AND NOT (FK1.FK1_TPDOC = 'VL' AND FK1.FK1_ORIGEM = 'LOJXREC' AND ? = 'R') "		//#16 ou #10
    cQuery += " AND ((FK1.FK1_RECPAG = ?) OR (FK1.FK1_RECPAG = ? AND FK1.FK1_DOC != ' ' )) "	//(#17/#18) ou (#11/#12)
    cQuery += " AND NOT EXISTS( "
    cQuery += " SELECT FK1EST.FK1_IDDOC FROM " + RetSQLName("FK1") +" FK1EST"
    cQuery += " WHERE FK1EST.FK1_FILIAL = FK1.FK1_FILIAL"
    cQuery += " AND FK1EST.FK1_IDDOC = FK1.FK1_IDDOC "
    cQuery += " AND FK1EST.FK1_SEQ = FK1.FK1_SEQ "
    cQuery += " AND FK1EST.FK1_DOC = FK1.FK1_DOC "
    cQuery += " AND FK1EST.FK1_TPDOC = 'ES' "
	If __lCmpoFK1
    	cQuery += " AND ((FK1EST.FK1_DATA <= ? AND ? = '0') "	//(#19/#20) ou (#13/#14)
    	cQuery += " OR (FK1EST.FK1_DTDISP <= ? AND ? = '1') "	//(#21/#22) ou (#15/#16)
    	cQuery += " OR (FK1EST.FK1_DTDIGI <= ? AND ? = '2')) "	//(#23/#24) ou (#17/#18)
	Else
		cQuery += " AND FK1EST.FK1_DATA <= ? "
	EndIf
    cQuery += " AND FK1EST.D_E_L_E_T_ = ' ') "
    cQuery += " GROUP BY FK1.FK1_FILIAL, FK1.FK1_IDFK1, FK1.FK1_DATA, FK1.FK1_TXMOED"

    cQuery := ChangeQuery(cQuery)

Return cQuery

/*/{Protheus.doc} FinFK6Pag
Construção da query de soma do VA para títulos a pagar (SE2).

@type       function
@author     Rafael Riego
@since      19/01/2020
@return     character, query para somatória do VA
/*/
Static Function FinFK6Pag() As Character

    Local cQuery    As Character

	cQuery := " SELECT FK2.FK2_DATA FKDATA, FK2.FK2_TXMOED TXMOEDA, COALESCE(SUM(CASE WHEN FK6.FK6_ACAO = '1' THEN FK6.FK6_VALMOV ELSE -FK6.FK6_VALMOV END), 0) VA"
    cQuery += " FROM " + RetSQLName("FK2") + " FK2 "
    cQuery += " INNER JOIN " + RetSQLName("FK6") + " FK6 ON "
    // Filtros JOIN FK2 x FK6
    cQuery += " FK6.FK6_FILIAL = FK2.FK2_FILIAL "
    cQuery += " AND FK6.FK6_IDORIG = FK2.FK2_IDFK2 "
    cQuery += " AND FK6.FK6_TABORI = 'FK2' "
    cQuery += " AND FK6.FK6_TPDOC = 'VA' "
    cQuery += " AND FK6.D_E_L_E_T_ = ' ' "
    // Filtros FK2
    cQuery += " WHERE "
    cQuery += " FK2.FK2_FILIAL = ? " //#1
	cQuery += " AND FK2.FK2_IDDOC = ?"		//#02
    cQuery += " AND FK2.D_E_L_E_T_ = ' ' "
    cQuery += " AND FK2.FK2_FILORI = ? "		//#09 ou #03
    cQuery += " AND FK2.FK2_TPDOC IN ('VL', 'BA', 'V2', 'CP', 'LJ') "
	If __lCmpoFK2
    	cQuery += " AND ((FK2.FK2_DATA <= ? AND ? = '0') "		//(#10/#11) ou (#04/#05)
    	cQuery += " OR (FK2.FK2_DTDISP <= ? AND ? = '1') "		//(#12/#13) ou (#06/#07)
    	cQuery += " OR (FK2.FK2_DTDIGI <= ? AND ? = '2')) "		//(#14/#15) ou (#08/#09)
	Else
		cQuery += " AND FK2.FK2_DATA <= ? "
	EndIf
    cQuery += " AND NOT (FK2.FK2_TPDOC = 'VL' AND FK2.FK2_ORIGEM = 'LOJXREC' AND ? = 'R') "		//#16 ou #10
    cQuery += " AND ((FK2.FK2_RECPAG = ?) OR (FK2.FK2_RECPAG = ? AND FK2.FK2_DOC != ' ' )) "	//(#17/#18) ou (#11/#12)
    cQuery += " AND NOT EXISTS( "
    cQuery += " SELECT FK2EST.FK2_IDDOC FROM " + RetSQLName("FK2") +" FK2EST"
    cQuery += " WHERE FK2EST.FK2_FILIAL = FK2.FK2_FILIAL"
    cQuery += " AND FK2EST.FK2_IDDOC = FK2.FK2_IDDOC "
    cQuery += " AND FK2EST.FK2_SEQ = FK2.FK2_SEQ "
    cQuery += " AND FK2EST.FK2_DOC = FK2.FK2_DOC "
    cQuery += " AND FK2EST.FK2_TPDOC = 'ES' "
	If __lCmpoFK2
    	cQuery += " AND ((FK2EST.FK2_DATA <= ? AND ? = '0') "		//(#19/#20) ou (#13/#14)
    	cQuery += " OR (FK2EST.FK2_DTDISP <= ? AND ? = '1') "		//(#21/#22) ou (#15/#16)
    	cQuery += " OR (FK2EST.FK2_DTDIGI <= ? AND ? = '2')) "		//(#23/#24) ou (#17/#18)
	Else
		cQuery += " AND FK2EST.FK2_DATA <= ? "
	EndIf
    cQuery += " AND FK2EST.D_E_L_E_T_ = ' ') "
    cQuery += " GROUP BY FK2.FK2_FILIAL, FK2.FK2_IDFK2, FK2.FK2_DATA, FK2.FK2_TXMOED"

    cQuery := ChangeQuery(cQuery)

Return cQuery


//-------------------------------------------------------------------------------
/*/{Protheus.doc} FExecFixN
Verifica se uma rotina de atualização de base (FIX) já foi executada

@author 	Pâmela Bernardo
@since 		01/10/2020
@version	P12
@param 		cEmp, characters, código da empresafilial
@return 	logical, Lógico indicado se a rotina ja foi executada anteriormente
/*/
//-------------------------------------------------------------------------------
Function FExecFixN(cFix As Character) as Logical

	Local cMVFinFix As Character
	Local lRet  	As Logical

	lRet	    := .F.
    cMVFinFix   := GetMV("MV_FINFIX")       //Verifico se tenho o novo parâmetro

	//Verifico se existe o parâmetro e se já a rotina já foi executada
	If !Empty(cMVFinFix)
		If Val(cMVFinFix) >= Val(cFix)	//Se executou a rotina
			lRet	:= .T.
		EndIf
	EndIf

Return lRet


/*/{Protheus.doc} FinxMsgE
Apresenta tela de Mensagem para que seja possivel ver e gravar o erro.

@author 	Reene Julian
@since 		04/02/2021
@version	P12
@param 		cMensagem caracter com a mensagem a ser apresentada e salva
@return
/*/
Function FinxMsgE(cMensagem as Character, cTexto1 As Character)

    Local oGroup As Object
    Local oTBitmap1 As Object
    Local oGroup1 As Object
    Local oTFont1 As Object
    Local oSay1 As Object
    Local oScr2 As Object
    Local oButton1 As Object
    Local oButton2 As Object
    Local oButton3 As Object
    Local lDetalhe As Logical

    Default cMensagem := ""
    Default cTexto1 :=  STR0096 // "Ocorreu um erro no processamento, o que impede a conclusão do processo atual, por favor salvar as informações abaixo e encaminhar ao administrador do sistema."
    
	lDetalhe := .F.

	If !IsBlind()
		DEFINE DIALOG oDlg TITLE STR0100 FROM 180,180 TO 365,580 PIXEL //180,180 TO 530,580 PIXEL

			oGroup := TGroup():New(00,00,30,202,'',oDlg,,,.T.)


			oTBitmap1 := TBitmap():New(00,00,260,184,,"OPENCLOSING_MDI.PNG",.T.,oGroup,;
			{|| .T. },,.F.,.F.,,,.F.,,.T.,,.F.)
			oTBitmap1:lAutoSize := .T.


			oGroup1:= TGroup():New(33,01,091,200,'',oDlg,,,.T.)
			oTFont1 := TFont():New('Arial',,-15,.F.)
			oTFont2 := TFont():New('Arial',,-11,.F.)
			oSay1:= TSay():New(36,05,{||cTexto1},oGroup1,,oTFont1,,,,.T.,CLR_BLACK,CLR_WHITE,198,60)


			oScr2 := TScrollBox():New(oGroup1,59,05,100,190,.T.,.F.,.T.)
			oScr2:hide()
			oSay2:= TSay():New(05,05,{||cMensagem},oScr2,,oTFont2,,,,.T.,CLR_BLACK,CLR_WHITE,200,1000)


			oButton1 := TButton():New( 075,05, STR0097 ,oGroup1,{|| If(lDetalhe, lDetalhe := .F.,lDetalhe := .T.) ,;
																	If(!lDetalhe,oScr2:hide(),oScr2:Show() ) ,;
																	oSay1:oFont := If(lDetalhe , oTFont2 , oTFont1 ) ,;
																	oButton1:nTop := if(lDetalhe, 320 , 150 ),;
																	oButton2:nTop := if(lDetalhe, 320 , 150 ),;
																	oButton3:nTop := if(lDetalhe, 320 , 150 ),;
																	oGroup1:nHeight := If( lDetalhe, 289 , 119 ) ,;
																	oDlg:nHeight := If( lDetalhe, 385 , 215 ) ,;
																	oDlg:Refresh()  },40,015,,,.F.,.T.,.F.,,.F.,,,.F.)

			oButton2 := TButton():New( 075,155,STR0099 ,oGroup1,{|| oDlg:End() },40,015,,,.F.,.T.,.F.,,.F.,,,.F.)

			oButton3 := TButton():New( 075,55,STR0098 ,oGroup1,{|| FinxSArq(cMensagem) },40,015,,,.F.,.T.,.F.,,.F.,,,.F.) //160,55

		ACTIVATE DIALOG oDlg CENTERED
	Endif	
Return


/*/{Protheus.doc} FinxSArq
Apresenta tela para seleção de pasta e gravação do arquivo com a mensagem.

@author 	Reene Julian
@since 		04/02/2021
@version	P12
@param 		cMensagem caracter com a mensagem a ser salva
@return 	Logico verdadeiro mensagem salva falso mensagem nao pode ser salva.
/*/
Function FinxSArq(cMensagem) as Logical
Local lRet As Logical
local cDir As Character
local cParq As Character
local nHandle As Numeric

Default cMensagem := ""

lRet  := .F.
ctmp := ""
cParq := ""
nHandle := 0

cDir  := getTempPath()
cParq := tFileDialog( "All files (*.*) | All Text files (*.txt) ",;
        STR0101,, cDir, .T., GETF_MULTISELECT   )

nHandle := FCREATE(cParq)

If nHandle = -1
        MsgAlert(STR0102+ CRLF + STR0103 + Str(Ferror()))
    Else
        FWrite(nHandle, cMensagem )
        FClose(nHandle)
        lRet := .T.
        If File(cParq)
            MsgInfo(STR0104)
        EndIf
    Endif

Return lRet

//------------------------------------------------------------------------------------------------
/*/{Protheus.doc}SldTitFK
Retorna o saldo do títulos na data informada para as baixas

@param cPrefixo   - Numero do Prefixo
@param cNumero    - Numero do Titulo
@param cParcela   - Parcela
@param cTipo      - Tipo
@param cNatureza  - Natureza
@param cCliFor    - Cliente
@param nMoedaTit  - Moeda do título
@param dData      - Data para conversao
@param dDataBaixa - Data data baixa a ser considerada (retroativa)
@param cLOja      - Loja do titulo
@param cFilTit    - Filial do titulo
@param nTxMoeda   - Taxa da Moeda
@param cTipoData  - Tipo de data para compor saldo (baixa/dispo/digit)
@param nSaldo  	  - Saldo bruto do título
@param Carteira	  - Carteira do título a ser processada


@author Pâmela Bernardo
@since  02/02/2021
@version 12
/*/
//------------------------------------------------------------------------------------------------
Static Function SldTitFK(cPrefixo,cNumero,cParcela,cTipo,cNatureza,cCliFor,nMoedaTit,dData,;
						 dDataBaixa,cLoja,cFilTit,nTxMoeda,cTipoData,lCmpMulFil,nSaldo,cCart,aMotBx)

	Local cQuery	As Character
	Local cChaveTit	As Character
	Local cIdDoc	As Character
	Local cAliasTMP As Character
	Local nRet		As Numeric
	Local nVa		As Numeric
	Local nMoedBx	As Numeric
	Local laMotBx	As Logical
	Local lMovM2	As Logical

	cQuery 		:= ""
	cIdDoc 		:= ""
	cAliasTMP	:= ""
	nRet 		:= nSaldo
	nVa 		:= 0
	nMoedBx		:= 1
	lMovM2		:= .F.

	Default aMotBx := {}
	laMotBx	:= !Empty(aMotBx)

	If cCart == "R"
		cChaveTit := xFilial("SE1",cFilTit ) + "|" + cPrefixo + "|" + cNumero + "|" + cParcela+ "|" +;
					cTipo  + "|" + cCliFor + "|" + cLoja

		cIdDoc    := FINBuscaFK7(cChaveTit, "SE1")

		If __oSldtit == Nil
			cQuery := " SELECT FK1_IDFK1, FK1_VALOR, FK1_VLMOE2, FK1_DATA, FK1_TXMOED,FK1_MOEDA, "
			cQuery +=  " FK1_MOTBX, FK1_TPDOC, FK1_RECPAG "
			cQuery += "FROM " + RetSqlName("FK1") + " FK1 "
			cQuery += "WHERE FK1.FK1_IDDOC = ? "
			If cTipoData == "0"
				cQuery += "AND FK1.FK1_DATA <= ? "
			ElseIf cTipoData == "1"
				cQuery += "AND FK1.FK1_DTDISP <= ? "
			Else
				cQuery += "AND FK1.FK1_DTDIGI <= ? "
			EndIf

			If laMotBx
				cQuery += "AND FK1.FK1_MOTBX IN (?) "
			EndIF

			cQuery += "AND FK1.FK1_ORIGEM <> 'LOJXREC' "
			cQuery += "AND FK1.D_E_L_E_T_ = ''  "
			cQuery += "AND NOT EXISTS( SELECT FK1EST.FK1_IDDOC "
			cQuery += 	"FROM " + RetSqlName("FK1") + " FK1EST  "
			cQuery += 	"WHERE "
			cQuery += 	"FK1EST.FK1_IDDOC = ?  "
			cQuery += 	"AND FK1EST.FK1_SEQ = FK1.FK1_SEQ   "
			cQuery += 	"AND FK1EST.FK1_TPDOC = 'ES'   "

			If cTipoData == "0"
				cQuery += "AND FK1EST.FK1_DATA <= ? "
			ElseIf cTipoData == "1"
				cQuery += "AND FK1EST.FK1_DTDISP <= ? "
			Else
				cQuery += "AND FK1EST.FK1_DTDIGI <= ? "
			EndIf

			If laMotBx
				cQuery += "AND FK1EST.FK1_MOTBX IN (?) "
			EndIF

			cQuery += "AND FK1EST.D_E_L_E_T_ = ' '  ) "

			cQuery := ChangeQuery(cQuery)
			__oSldtit:=FWPreparedStatement():New(cQuery)

		EndIf
	Else
		cChaveTit := xFilial("SE2",cFilTit ) + "|" + cPrefixo + "|" + cNumero + "|" + cParcela+ "|" +;
					cTipo  + "|" + cCliFor + "|" + cLoja

		cIdDoc    := FINBuscaFK7(cChaveTit, "SE2")

		If __oSldtit == Nil
			cQuery := " SELECT FK2_IDFK2, FK2_VALOR, FK2_VLMOE2, FK2_DATA, FK2_TXMOED, FK2_MOEDA, "
			cQuery +=  " FK2_MOTBX, FK2_TPDOC, FK2_RECPAG "
			cQuery += "FROM " + RetSqlName("FK2") + " FK2 "
			cQuery += "WHERE FK2.FK2_IDDOC = ? "
			If cTipoData == "0"
				cQuery += "AND FK2.FK2_DATA <= ? "
			ElseIf cTipoData == "1"
				cQuery += "AND FK2.FK2_DTDISP <= ? "
			Else
				cQuery += "AND FK2.FK2_DTDIGI <= ? "
			EndIf

			If laMotBx
				cQuery += "AND FK2.FK2_MOTBX IN (?) "
			EndIF

			cQuery += "AND FK2.D_E_L_E_T_ = ''  "
			cQuery += "AND NOT EXISTS( SELECT FK2EST.FK2_IDDOC "
			cQuery += 	"FROM " + RetSqlName("FK2") + " FK2EST  "
			cQuery += 	"WHERE "
			cQuery += 	"FK2EST.FK2_IDDOC = ?  "
			cQuery += 	"AND FK2EST.FK2_SEQ = FK2.FK2_SEQ   "
			cQuery += 	"AND FK2EST.FK2_TPDOC = 'ES'   "

			If cTipoData == "0"
				cQuery += "AND FK2EST.FK2_DATA <= ? "
			ElseIf cTipoData == "1"
				cQuery += "AND FK2EST.FK2_DTDISP <= ? "
			Else
				cQuery += "AND FK2EST.FK2_DTDIGI <= ? "
			EndIf

			If laMotBx
				cQuery += "AND FK2EST.FK2_MOTBX IN (?) "
			EndIF

			cQuery += "AND FK2EST.D_E_L_E_T_ = ' '  ) "

			cQuery := ChangeQuery(cQuery)
			__oSldtit:=FWPreparedStatement():New(cQuery)

		EndIf
	EndIf

	If laMotBx
		__oSldtit:SetString(1,cIdDoc)
		__oSldtit:SetString(2,dToS(dDataBaixa))
		__oSldtit:SetIn(3,aMotBx)
		__oSldtit:SetString(4,cIdDoc)
		__oSldtit:SetString(5,dToS(dDataBaixa))
		__oSldtit:SetIn(6,aMotBx)
	Else
		__oSldtit:SetString(1,cIdDoc)
		__oSldtit:SetString(2,dToS(dDataBaixa))
		__oSldtit:SetString(3,cIdDoc)
		__oSldtit:SetString(4,dToS(dDataBaixa))
	Endif

	cQuery := __oSldtit:GetFixQuery()
	cAliasTMP := mpsysopenquery(cQuery)

	If !(cAliasTMP)->(Eof())
		If cCart == "R" .and. (SE1->E1_ACRESC+SE1->E1_DECRESC) > 0
			nRet-=SE1->E1_ACRESC
			nRet+=SE1->E1_DECRESC
		ElseIf cCart == "P" .and. (SE2->E2_ACRESC+SE2->E2_DECRESC) > 0
			nRet-=SE2->E2_ACRESC
			nRet+=SE2->E2_DECRESC
		EndIf
	EndIf

	While !(cAliasTMP)->(Eof())

		lCmpMulFil := .F.

		If cCart == "R"
			lMovM2 := (cAliasTMP)->FK1_MOTBX == "CMP" .And. MovMoedEs((cAliasTMP)->FK1_MOEDA, (cAliasTMP)->FK1_TPDOC, (cAliasTMP)->FK1_MOTBX, DTOS(dDataBaixa), (cAliasTMP)->FK1_RECPAG)
			IF(cPaisLoc=="BRA" .and. (nMoedaTit < 2 .Or. lMovM2)) .Or.;
				(cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (cAliasTMP)->FK1_MOEDA=="0"+cValtoChar(nMoedaTit))
				nRet -= (cAliasTMP)->FK1_VALOR
			Else
				nRet -= (cAliasTMP)->FK1_VLMOE2
				nMoedBx := Val((cAliasTMP)->FK1_MOEDA)
			EndIf

			nVa := FinTotFK6((cAliasTMP)->FK1_IDFK1, "FK1")
			nVA := Round(NoRound(xMoeda(nVA,nMoedBx,nMoedaTit,(cAliasTMP)->FK1_DATA,3,,IIF((cAliasTMP)->FK1_TXMOED==0,nTxMoeda,(cAliasTMP)->FK1_TXMOED)),3),2)
		Else
			lMovM2 := (cAliasTMP)->FK2_MOTBX == "CMP" .And. MovMoedEs((cAliasTMP)->FK2_MOEDA, (cAliasTMP)->FK2_TPDOC, (cAliasTMP)->FK2_MOTBX, DTOS(dDataBaixa), (cAliasTMP)->FK2_RECPAG)
			IF(cPaisLoc=="BRA" .and. (nMoedaTit < 2 .Or. lMovM2)) .Or.;
				(cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (cAliasTMP)->FK2_MOEDA == "0"+cValtoChar(nMoedaTit))
				nRet -= (cAliasTMP)->FK2_VALOR
			Else
				nRet -= (cAliasTMP)->FK2_VLMOE2
				nMoedBx := Val((cAliasTMP)->FK2_MOEDA)
			EndIf

			nVa := FinTotFK6((cAliasTMP)->FK2_IDFK2, "FK2")
			nVA := Round(NoRound(xMoeda(nVA,nMoedBx,nMoedaTit,(cAliasTMP)->FK2_DATA,3,,IIF((cAliasTMP)->FK2_TXMOED==0,nTxMoeda,(cAliasTMP)->FK2_TXMOED)),3),2)
		EndIF

		nRet += nVA

		(cAliasTMP)->(dbSkip())
	EndDo

	(cAliasTMP)->(dbCloseArea())
	MsErase(cAliasTMP)


Return nRet

//------------------------------------------------------------------------------------------------
/*/{Protheus.doc}FinTotFK6
Retorna o total de valores acessórios que afetam o os valores de baixas, juros, multas, descontos e VA

@param cIdFKs - ID da baixa (FK1/FK2)
@param cTabOri - tabela de origem do ID(FK1/FK2)
@author Pâmela Bernardo
@since  15/01/2021
@version 12
/*/
//------------------------------------------------------------------------------------------------
Function FinTotFK6(cIdFKs As Character, cTabOri As Character) As Numeric

	Local nTotFk6  	As Numeric
	Local cQuery	As Character
	Local cAliasFK6 As Character

	Default cIdFKs := ""
	Default cTabOri := ""

	nTotFk6 := 0
	cQuery  := ""
	cAliasFK6 := ""

	If __oPrepFK6 == Nil
		cQuery := " SELECT COALESCE(SUM(CASE WHEN FK6.FK6_TPDOC NOT IN ('DC', 'D2' ) THEN FK6.FK6_VALMOV ELSE -FK6.FK6_VALMOV END),0) TOTFK6 "
		cQuery += "From " + RetSqlName("FK6") + " FK6 "
		cQuery += "Where FK6.FK6_FILIAL = ?  "
		cQuery += "AND FK6.FK6_IDORIG = ? "
		cQuery += "AND FK6.FK6_TABORI = ? "
			cQuery += "AND FK6.FK6_TPDOC NOT IN ('CM', 'VM','C2'  ) "
		cQuery += "AND FK6.D_E_L_E_T_ = ' '  "

		cQuery := ChangeQuery(cQuery)
		__oPrepFK6:=FWPreparedStatement():New(cQuery)

	EndIf

	__oPrepFK6:SetString(1,xFilial("FK6" ))
	__oPrepFK6:SetString(2,cIdFKs)
	__oPrepFK6:SetString(3,cTabOri)

	cQuery := __oPrepFK6:GetFixQuery()
	cAliasFK6 := mpsysopenquery(cQuery)

	If !(cAliasFK6)->(Eof())
		nTotFk6 := (cAliasFK6)->(TOTFK6)
	EndIf

	(cAliasFK6)->(dbCloseArea())


Return nTotFk6


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DelSldTit
Destroy o objeto criado na FinTotFK6() e SldTitFK()

@Author	Pâmela Bernardo
@since	03/02/2021
/*/
//-----------------------------------------------------------------------------------------------------
Function DelSldTit()

	If __oSldtit != NIL
		__oSldtit:Destroy()
		__oSldtit := NIL
	Endif

	If __oPrepFK6 != NIL
		__oPrepFK6:Destroy()
		__oPrepFK6 := NIL
	Endif

Return

/*/{Protheus.doc} FinExistBx
Verifica se o título possui baixa com desconto até a data informada. Rotina utilizada para definir qual campo (valor ou saldo) do Decréscimo deverá ser utilizado para retroagir o saldo.

@type       function
@author     Rafael Riego
@since      10/02/2020
@param      cFilMov, character, filial do movimento (FK5_FILIAL/E5_FILIAL)
@param      cFilTit, character, filial do título (E1_FILIAL/E2_FILIAL)
@param      cPrefixo, character, prefixo do título
@param      cNumero, character, número do título
@param      cParcela, character, parcela do título
@param      cTipo, character, tipo do título
@param      cCliFor, character, cliente/fornecedor do título
@param      cLoja, character, loja do título
@param      cCarteira, character, carteira do título
@param      dDataBaixa, date, data da baixa
@param      cTipoData, character, tipo da data a ser utilizada na pesquisa {"0" = E5_DATA; "1" = E5_DTDISPO; "2" = E5_DTDIGIT}
@param      cAdiant, character, IIf(cTipo $ MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG), "1","0")
@param      dDataBase, date, database utilizada na soma
@param      cFilOri, character, filial de origem do título
@return     logical, verdadeiro caso exista alguma baixa igual ou inferior a data informada
/*/
Function FinExistBx(cFilMov As Character, cFilTit As Character, cPrefixo As Character, cNumero As Character, cParcela As Character, cTipo As Character, cCliFor As Character, cLoja As Character, cCarteira As Character, dDataBaixa As Date, cTipoData As Character, cAdiant As Character, dDataBase As Date, cFilOri As Character) As Logical

	Local aArea			As Array
    Local aBind			As Array

    Local cAliasTMP		As Character
    Local cCartAux		As Character
	Local cChaveFK7		As Character
    Local cDataBaixa	As Character
    Local cDataBase		As Character
    Local cFilialFK7	As Character
    Local cQuery		As Character

	Local lPossuiBx		As Logical

	aArea		:= GetArea()
	cCartAux	:= cCarteira
	cDataBaixa	:= DToS(dDataBaixa)
	cDataBase	:= DToS(dDataBase)
	cFilialFK7	:= FwXFilial("FK7", cFilMov)
	lPossuiBx	:= .F.

	If __lCmpoFK1 == Nil .Or. __lCmpoFK2 == Nil
		__lCmpoFK1 := FK1->(FieldPos("FK1_DTDISP")) > 0 .And. FK1->(FieldPos("FK1_DTDIGI")) > 0
		__lCmpoFK2 := FK2->(FieldPos("FK2_DTDISP")) > 0 .And. FK2->(FieldPos("FK2_DTDIGI")) > 0
	EndIf

	If cAdiant == "1"
		If cCartAux == "P"
			cCartAux := "R"
		Else
			cCartAux := "P"
		EndIf
	EndIf

	//cTipoData := "0"  // FK1_DATA/FK2_DATA
	//cTipoData := "1"  // FK1_DTDISP/FK2_DTDISP
	//cTipoData := "2"  // FK1_DTDIGI/FK2_DTDIGI
	If cCartAux == "P"
		If !__lCmpoFK2 .And. cTipoData $ "1|2"
			Return lPossuiBx
		EndIf
		If Empty(__cQryBxP)
			__cQryBxP := FinBxPag()
		EndIf
		cQuery := __cQryBxP
	Else
		If !__lCmpoFK1 .And. cTipoData $ "1|2"
			Return lPossuiBx
		EndIf
		If Empty(__cQryBxR)
			__cQryBxR := FinBxRec()
		EndIf
		cQuery := __cQryBxR
	EndIf

	If (__lCmpoFK1 .And. cCartAux == "R") .Or. (__lCmpoFK2 .And. cCartAux == "P")
		aBind := {;
			cFilialFK7      ,;//#01
			cFilTit         ,;//#02
			cPrefixo        ,;//#03
			cNumero         ,;//#04
			cParcela        ,;//#05
			cTipo           ,;//#06
			cCliFor         ,;//#07
			cLoja           ,;//#08
			cFilOri         ,;//#09
			cDataBaixa      ,;//#10
			cTipoData       ,;//#11
			cDataBaixa      ,;//#12
			cTipoData       ,;//#13
			cDataBaixa      ,;//#14
			cTipoData       ,;//#15
			cCartAux        ,;//#16
			cCartAux        ,;//#17
			cCarteira       ,;//#18
			cDataBase       ,;//#19
			cTipoData       ,;//#20
			cDataBase       ,;//#21
			cTipoData       ,;//#22
			cDataBase       ,;//#23
			cTipoData       } //#24
	Else
		aBind := {;
			cFilialFK7      ,;//#01
			cFilTit         ,;//#02
			cPrefixo        ,;//#03
			cNumero         ,;//#04
			cParcela        ,;//#05
			cTipo           ,;//#06
			cCliFor         ,;//#07
			cLoja           ,;//#08
			cFilOri         ,;//#09
			cDataBaixa      ,;//#10
			cCartAux        ,;//#11
			cCartAux        ,;//#12
			cCarteira       ,;//#13
			cDataBase       } //#14
	EndIf

	cAliasTMP := GetNextAlias()

	DbUseArea(.T., "TOPCONN", TCGenQry2(Nil, Nil, cQuery, aBind), cAliasTMP, .F., .T.)

	If (cAliasTMP)->(!(EoF()))
		lPossuiBx := .T.
	EndIf

	(cAliasTMP)->(DbCloseArea())
	FwFreeArray(aBind)
	RestArea(aArea)

Return lPossuiBx

/*/{Protheus.doc} FinBxPag
Efetua a montagem da query para verificação de baixas de títulos a pagar.

@type       function
@author     Rafael Riego
@since      10/02/2020
@return     character, query montada com bind para pesquisa de baixa
/*/
Static Function FinBxPag() As Character

	Local cQuery	As Character

    cQuery := " SELECT FK2.FK2_FILIAL "
    cQuery += " FROM " + RetSQLName("FK7") + " FK7 "
    cQuery += " INNER JOIN " + RetSQLName("FK2") + " FK2 ON "
    // Filtros JOIN FK7 x FK2
    cQuery += " FK2.FK2_FILIAL = FK7.FK7_FILIAL "
    cQuery += " AND FK2.FK2_IDDOC = FK7.FK7_IDDOC "
    cQuery += " AND FK2.D_E_L_E_T_ = ' ' "
	cQuery += " INNER JOIN " + RetSQLName("FK6") + " FK6 ON "
    // Filtros JOIN FK2 x FK6
    cQuery += " FK6.FK6_FILIAL = FK2.FK2_FILIAL "
    cQuery += " AND FK6.FK6_IDORIG = FK2.FK2_IDFK2 "
    cQuery += " AND FK6.FK6_TABORI = 'FK2' "
    cQuery += " AND FK6.FK6_TPDOC IN ('DC', 'D2') "
    cQuery += " AND FK6.D_E_L_E_T_ = ' ' "
    // Filtros FK7
    cQuery += " WHERE " // WHERE baseado no indice 3 da tabela FK7 - FK7_FILIAL+FK7_ALIAS+FK7_FILTIT+FK7_PREFIX+FK7_NUM+FK7_PARCEL+FK7_TIPO+FK7_CLIFOR+FK7_LOJA
    cQuery += " FK7.FK7_FILIAL = ? " //#01
	cQuery += " AND FK7.FK7_ALIAS = 'SE2' "
	cQuery += " AND FK7.FK7_FILTIT = ? "	//#02
	cQuery += " AND FK7.FK7_PREFIX = ? "	//#03
	cQuery += " AND FK7.FK7_NUM = ? "	 	//#04
	cQuery += " AND FK7.FK7_PARCEL = ? "	//#05
	cQuery += " AND FK7.FK7_TIPO = ? "		//#06
	cQuery += " AND FK7.FK7_CLIFOR = ? "	//#07
	cQuery += " AND FK7.FK7_LOJA = ? "		//#08
    cQuery += " AND FK7.D_E_L_E_T_ = ' ' "
    // Filtros FK2
    cQuery += " AND FK2.FK2_FILORI = ? "		//#09 ou #03
    cQuery += " AND FK2.FK2_TPDOC IN ('VL', 'BA', 'V2', 'CP', 'LJ') "
	If __lCmpoFK2
    	cQuery += " AND ((FK2.FK2_DATA <= ? AND ? = '0') "		//(#10/#11) ou (#04/#05)
    	cQuery += " OR (FK2.FK2_DTDISP <= ? AND ? = '1') "		//(#12/#13) ou (#06/#07)
    	cQuery += " OR (FK2.FK2_DTDIGI <= ? AND ? = '2')) "		//(#14/#15) ou (#08/#09)
	Else
		cQuery += " AND FK2.FK2_DATA <= ? "
	EndIf
    cQuery += " AND NOT (FK2.FK2_TPDOC = 'VL' AND FK2.FK2_ORIGEM = 'LOJXREC' AND ? = 'R') "		//#16 ou #10
    cQuery += " AND ((FK2.FK2_RECPAG = ?) OR (FK2.FK2_RECPAG = ? AND FK2.FK2_DOC != ' ' )) "	//(#17/#18) ou (#11/#12)
    cQuery += " AND NOT EXISTS( "
    cQuery += " SELECT FK2EST.FK2_IDDOC FROM " + RetSQLName("FK2") +" FK2EST"
    cQuery += " WHERE FK2EST.FK2_FILIAL = FK2.FK2_FILIAL"
    cQuery += " AND FK2EST.FK2_IDDOC = FK2.FK2_IDDOC "
    cQuery += " AND FK2EST.FK2_SEQ = FK2.FK2_SEQ "
    cQuery += " AND FK2EST.FK2_DOC = FK2.FK2_DOC "
    cQuery += " AND FK2EST.FK2_TPDOC = 'ES' "
	If __lCmpoFK2
    	cQuery += " AND ((FK2EST.FK2_DATA <= ? AND ? = '0') "		//(#19/#20) ou (#13/#14)
    	cQuery += " OR (FK2EST.FK2_DTDISP <= ? AND ? = '1') "		//(#21/#22) ou (#15/#16)
    	cQuery += " OR (FK2EST.FK2_DTDIGI <= ? AND ? = '2')) "		//(#23/#24) ou (#17/#18)
	Else
		cQuery += " AND FK2EST.FK2_DATA <= ? "
	EndIf
    cQuery += " AND FK2EST.D_E_L_E_T_ = ' ') "

    cQuery := ChangeQuery(cQuery)

Return cQuery

/*/{Protheus.doc} FinBxRec
Efetua a montagem da query para verificação de baixas de títulos a receber.

@type       function
@author     Rafael Riego
@since      10/02/2020
@return     character, query montada com bind para pesquisa de baixa
/*/
Static Function FinBxRec() As Character

	Local cQuery	As Character

    cQuery := " SELECT FK1.FK1_FILIAL "
    cQuery += " FROM " + RetSQLName("FK7") + " FK7 "
    cQuery += " INNER JOIN " + RetSQLName("FK1") + " FK1 ON "
    // Filtros JOIN FK7 x FK1
    cQuery += " FK1.FK1_FILIAL = FK7.FK7_FILIAL "
    cQuery += " AND FK1.FK1_IDDOC = FK7.FK7_IDDOC "
    cQuery += " AND FK1.D_E_L_E_T_ = ' ' "
	cQuery += " INNER JOIN " + RetSQLName("FK6") + " FK6 ON "
    // Filtros JOIN FK1 x FK6
    cQuery += " FK6.FK6_FILIAL = FK1.FK1_FILIAL "
    cQuery += " AND FK6.FK6_IDORIG = FK1.FK1_IDFK1 "
    cQuery += " AND FK6.FK6_TABORI = 'FK1' "
    cQuery += " AND FK6.FK6_TPDOC IN ('DC', 'D2') "
    cQuery += " AND FK6.D_E_L_E_T_ = ' ' "
    // Filtros FK7
    cQuery += " WHERE " // WHERE baseado no indice 3 da tabela FK7 - FK7_FILIAL+FK7_ALIAS+FK7_FILTIT+FK7_PREFIX+FK7_NUM+FK7_PARCEL+FK7_TIPO+FK7_CLIFOR+FK7_LOJA
    cQuery += " FK7.FK7_FILIAL = ? " //#01
	cQuery += " AND FK7.FK7_ALIAS = 'SE1' "
    cQuery += " AND FK7.FK7_FILTIT = ? "	//#02
	cQuery += " AND FK7.FK7_PREFIX = ? "	//#03
	cQuery += " AND FK7.FK7_NUM = ? "	 	//#04
	cQuery += " AND FK7.FK7_PARCEL = ? "	//#05
	cQuery += " AND FK7.FK7_TIPO = ? "		//#06
	cQuery += " AND FK7.FK7_CLIFOR = ? "	//#07
	cQuery += " AND FK7.FK7_LOJA = ? "		//#08
    cQuery += " AND FK7.D_E_L_E_T_ = ' ' "
    // Filtros FK1
    cQuery += " AND FK1.FK1_FILORI = ? "		//#09 ou #03
    cQuery += " AND FK1.FK1_TPDOC IN ('VL', 'BA', 'V2', 'CP', 'LJ') "
	If __lCmpoFK1
    	cQuery += " AND ((FK1.FK1_DATA <= ? AND ? = '0') "	//(#10/#11) ou (#04/#05)
    	cQuery += " OR (FK1.FK1_DTDISP <= ? AND ? = '1') "	//(#12/#13) ou (#06/#07)
    	cQuery += " OR (FK1.FK1_DTDIGI <= ? AND ? = '2')) "	//(#14/#15) ou (#08/#09)
	Else
		cQuery += " AND FK1.FK1_DATA <= ? "
	EndIf
    cQuery += " AND NOT (FK1.FK1_TPDOC = 'VL' AND FK1.FK1_ORIGEM = 'LOJXREC' AND ? = 'R') "		//#16 ou #10
    cQuery += " AND ((FK1.FK1_RECPAG = ?) OR (FK1.FK1_RECPAG = ? AND FK1.FK1_DOC != ' ' )) "	//(#17/#18) ou (#11/#12)
    cQuery += " AND NOT EXISTS( "
    cQuery += " SELECT FK1EST.FK1_IDDOC FROM " + RetSQLName("FK1") +" FK1EST"
    cQuery += " WHERE FK1EST.FK1_FILIAL = FK1.FK1_FILIAL"
    cQuery += " AND FK1EST.FK1_IDDOC = FK1.FK1_IDDOC "
    cQuery += " AND FK1EST.FK1_SEQ = FK1.FK1_SEQ "
    cQuery += " AND FK1EST.FK1_DOC = FK1.FK1_DOC "
    cQuery += " AND FK1EST.FK1_TPDOC = 'ES' "
	If __lCmpoFK1
    	cQuery += " AND ((FK1EST.FK1_DATA <= ? AND ? = '0') "	//(#19/#20) ou (#13/#14)
    	cQuery += " OR (FK1EST.FK1_DTDISP <= ? AND ? = '1') "	//(#21/#22) ou (#15/#16)
    	cQuery += " OR (FK1EST.FK1_DTDIGI <= ? AND ? = '2')) "	//(#23/#24) ou (#17/#18)
	Else
		cQuery += " AND FK1EST.FK1_DATA <= ? "
	EndIf

    cQuery += " AND FK1EST.D_E_L_E_T_ = ' ') "

    cQuery := ChangeQuery(cQuery)

Return cQuery

//----------------------------------------
/*/{Protheus.doc} FinAbatRec
Soma titulos de abatimento relacionado a um determinado titulo a receber.

@author Igor Nascimento
@since  04/02/2021
@version 12
/*/
//----------------------------------------
Static Function FinAbatRec(cPrefixo As Char, cNumero As Char, cParcela As Char, nMoeda As Numeric,;
					cCpo As Char, dData As Date, nTotAbImp As Numeric, nTotIrAbt As Numeric,;
					nTotCsAbt As Numeric, nTotPisAbt As Numeric, nTotCofAbt As Numeric,;
					nTotInsAbt As Numeric, cFilAbat As Char, nTxMoeda As Numeric, nTotISS As Numeric) As Numeric

	Local aArea     As Array
	Local aAreaSE1  As Array
	Local aTiposAbt	As Array
	Local cAlias    As Char
	Local cCliente  As Char
	Local cTipo     As Char
	Local cQuery    As Char
	Local cTmp      As Char
	Local cLoja     As Char
	Local nTotAbat  As Numeric
	Local nI		As Numeric
	Local nY		As Numeric
	Local nLenTipos	As Numeric
	Local lIrPjBxCr As Logical
	Local lProc		As Logical
	Local lTemFilho As Logical

	//Parâmetros de entrada entrada da função.
	Default cPrefixo   := SE1->E1_PREFIXO
	Default cNumero    := SE1->E1_NUM
	Default cParcela   := SE1->E1_PARCELA
	Default nMoeda     := SE1->E1_MOEDA
	Default cCpo       := "V"
	Default dData      := dDatabase

	Begin Sequence
		cAlias     := Alias()
		aArea      := GetArea()
		cFilAbat   := xFilial("SE1", cFilAbat)
		nTotAbat   := 0
		nI         := 0
		nY         := 0
		lTemFilho  := .F.
		lIrPjBxCr  := FIrPjBxCr(.T.)
		lProc      := .T.

		If __cTipAbat == Nil
			__cTipAbat := PadR("AB-", TamSX3("E1_TIPO")[1])
		EndIf

		If Valtype(dData) == "C"
			dData := StoD(dData)
		EndIf

		If cAlias == "__SE1"
			cCliente := __SE1->E1_CLIENTE
			cLoja    := __SE1->E1_LOJA
			cTipo	 := __SE1->E1_TIPO
			dbSelectArea("__SE1")
		Else
			cCliente := SE1->E1_CLIENTE
			cLoja    := SE1->E1_LOJA
			cTipo    := SE1->E1_TIPO

			If Select("__SE1") == 0
				ChkFile("SE1", .F., "__SE1")
			Else
				dbSelectArea("__SE1")
			Endif
		Endif

		//RFC: se nao informei os dados do titulo, retorno sem abatimento
		If Empty(cPrefixo + cNumero + cParcela)
			BREAK
		Endif

		__SE1->(DbSetOrder(1))
		aAreaSE1 := __SE1->(GetArea())
		lProc    := __SE1->(MsSeek(cFilAbat+cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja))

		If lProc
			//Países localizados não possuem impostos que geram títulos a partir de um título pai
			If cPaisLoc == "BRA"
				If E1_TIPO $ MVABATIM .and. !Empty(AllTrim(E1_TITPAI))
					If MsSeek(cFilAbat+RTrim(E1_TITPAI),.T.)
						cPrefixo := E1_PREFIXO
						cNumero  := E1_NUM
						cParcela := E1_PARCELA
						cTipo    := E1_TIPO
						cCliente := E1_CLIENTE
						cLoja    := E1_LOJA
					Else
						RestArea(aAreaSE1)
						BREAK
					EndIf
				EndIf
			Endif

			If _aBindAbtR == Nil
				//Cache do bind para nao precisar montar o IN do MVABATIM toda chamada
				_aBindAbtR := { cFilAbat,; //#01
						PadR(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja, TamSX3("E1_TITPAI")[1]) } //#02

				aTiposAbt := StrTokArr2(MVABATIM,"|")
				nLenTipos := Len(aTiposAbt)

				For nI := 1 To nLenTipos
					Aadd(_aBindAbtR,aTiposAbt[nI])	//Ordenacao dinamica do bind a partir da posicao #03
				Next nI
			Else	//Atualiza array do bind
				_aBindAbtR[1] := cFilAbat
				_aBindAbtR[2] := PadR(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja, TamSX3("E1_TITPAI")[1])
			EndIf

			cTmp := GetNextAlias()

			If cCpo == "V" //E1_VALOR
				cQuery := AbatRecVal()
			Else //E1_SALDO
				cQuery := AbatRecSal()
			EndIf

			DbUseArea(.T., "TOPCONN", TCGenQry2(Nil, Nil, cQuery, _aBindAbtR), cTmp, .F., .T.)

			While (cTmp)->(!EoF())
				Do Case
					Case (cTmp)->E1_TIPO == MVIRABT
						nTotIrAbt += (cTmp)->VALOR

					Case (cTmp)->E1_TIPO == MVPIABT
						nTotPisAbt += (cTmp)->VALOR

					Case (cTmp)->E1_TIPO == MVCFABT
						nTotCofAbt += (cTmp)->VALOR

					Case (cTmp)->E1_TIPO == MVCSABT
						nTotCsAbt += (cTmp)->VALOR

					Case (cTmp)->E1_TIPO == MVINABT
						nTotInsAbt += (cTmp)->VALOR

					Case (cTmp)->E1_TIPO == MVISABT
						nTotISS += (cTmp)->VALOR
				EndCase

				If (cTmp)->E1_TIPO != __cTipAbat
					nTotAbImp += (cTmp)->VALOR
				EndIf

				nTotAbat += (cTmp)->VALOR
				(cTmp)->(DbSkip())
			EndDo

			(cTmp)->(dbCloseArea())

			If nMoeda > 1
				If nTotIrAbt > 0
					nTotIrAbt  := xMoeda(nTotIrAbt,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If nTotPisAbt > 0
					nTotPisAbt := xMoeda(nTotPisAbt,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If nTotCofAbt > 0
					nTotCofAbt := xMoeda(nTotCofAbt,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If nTotCsAbt > 0
					nTotCsAbt  := xMoeda(nTotCsAbt,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If nTotInsAbt > 0
					nTotInsAbt := xMoeda(nTotInsAbt,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If nTotISS > 0
					nTotISS    := xMoeda(nTotISS,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If lIrPjBxCr
					If nTotAbImp > 0
						nTotAbImp := xMoeda(nTotAbImp,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					EndIf
					If nTotAbat > 0
						nTotAbat  := xMoeda(nTotAbat,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					EndIf
				Else
					If nTotAbImp > 0
						nTotAbImp := xMoeda(nTotAbImp,(cAlias)->E1_MOEDA, nMoeda,(cAlias)->E1_EMISSAO,,,)
					EndIf
					If nTotAbat > 0
						nTotAbat  := xMoeda(nTotAbat,(cAlias)->E1_MOEDA, nMoeda,(cAlias)->E1_EMISSAO,,,)
					EndIf
				EndIf
			EndIf
		Endif

		RestArea(aAreaSE1)
		FwFreeArray(aAreaSE1)
	End Sequence

	RestArea(aArea)
	FwFreeArray(aArea)
Return nTotAbat

//----------------------------------------
/*/{Protheus.doc}AbatRecVal
Monta a query da SumAbatRec utilizando o campo E1_VALOR, para
	mante-la em cache

@return cQuery - String da query final para montar a temporaria da SumAbatRec
@author Igor Nascimento
@since  04/02/2021
@version 12
/*/
//----------------------------------------
Static Function AbatRecVal() As Char
	Local nLenTipos As Numeric
	Local nI		As Numeric

	If Empty(_cQryAbtRV)
		nLenTipos  := Len(_aBindAbtR)
		_cQryAbtRV += "SELECT SUM(E1_VALOR) VALOR, E1_TIPO FROM " + RetSQLName("SE1")
		_cQryAbtRV += " WHERE E1_FILIAL = ?"    //#01
		_cQryAbtRV += " AND E1_TITPAI = ?"      //#02
		_cQryAbtRV += " AND E1_TIPO IN ("		//# A partir do 03

		For nI := 3 To nLenTipos
			_cQryAbtRV += "?,"	//# ordenacao dinamica do bind para o IN
		Next nI

		_cQryAbtRV := SubStr(_cQryAbtRV,1,Len(_cQryAbtRV)-1)	// Remove ultima virgula
		_cQryAbtRV += ") AND D_E_L_E_T_ = ' '"
		_cQryAbtRV += " GROUP BY E1_TIPO"
		_cQryAbtRV := ChangeQuery(_cQryAbtRV)
	EndIf
Return _cQryAbtRV

//----------------------------------------
/*/{Protheus.doc}AbatRecSal
Monta a query da SumAbatRec utilizando o campo E1_SALDO, para mante-la em cache

@return cQuery - String da query final para montar a temporaria da SumAbatRec
@author Igor Nascimento
@since  04/02/2021
@version 12
/*/
//----------------------------------------
Static Function AbatRecSal() As Char
	Local nLenTipos As Numeric
	Local nI		As Numeric

	If Empty(_cQryAbtRS)
		nLenTipos  := Len(_aBindAbtR)
		_cQryAbtRS += "SELECT SUM(E1_SALDO) VALOR, E1_TIPO FROM " + RetSQLName("SE1")
		_cQryAbtRS += " WHERE E1_FILIAL = ?"    //#01
		_cQryAbtRS += " AND E1_TITPAI = ?"      //#02
		_cQryAbtRS += " AND E1_TIPO IN ("		//# A partir do 03

		For nI := 3 To nLenTipos
			_cQryAbtRS += "?,"	//# ordenacao dinamica do bind para o IN
		Next nI

		_cQryAbtRS := SubStr(_cQryAbtRS, 1, Len(_cQryAbtRS) - 1)	// Remove ultima virgula
		_cQryAbtRS += ") AND D_E_L_E_T_ = ' '"
		_cQryAbtRS += " GROUP BY E1_TIPO"
		_cQryAbtRS := ChangeQuery(_cQryAbtRS)
	EndIf
Return _cQryAbtRS



/*/{Protheus.doc} FinFK6V2
Rotina que soma os valores acessórios para SaldoTit (procedure).

@type       function
@author     Rafael Riego
@since      19/01/2020
@param      cFilMov, character, filial do movimento (FK5_FILIAL/E5_FILIAL)
@param      cFilTit, character, filial do título (E1_FILIAL/E2_FILIAL)
@param      cPrefixo, character, prefixo do título
@param      cNumero, character, número do título
@param      cParcela, character, parcela do título
@param      cTipo, character, tipo do título
@param      cCliFor, character, cliente/fornecedor do título
@param      cLoja, character, loja do título
@param      cCarteira, character, carteira do título
@param      dDataBaixa, date, data da baixa
@param      cTipoData, character, tipo da data a ser utilizada na pesquisa {"0" = E5_DATA; "1" = E5_DTDISPO; "2" = E5_DTDIGIT}
@param      cAdiant, character, IIf(cTipo $ MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG), "1","0")
@param      dDataBase, date, database utilizada na soma
@param      cFilOri, character, filial de origem do título
@param      nMoedaTit, numeric, moeda do título
@param      nTaxaMoeda, numeric, taxa da moeda
@return     numeric, valor acessório somado
/*/
Function FinFK6V2(cFilMov As Character, cIdDoc As Character,;
					cCarteira As Character, dDataBaixa As Date, cTipoData As Character,;
					cAdiant As Character, dDataBase As Date, cFilOri As Character,;
					nMoedaTit As Numeric, nTaxaMoeda As Numeric) As Numeric

	Local aArea			As Array
    Local cAliasTMP     As Character
    Local cCartAux      As Character
    Local cDataBaixa    As Character
    Local cDataBase     As Character
    Local cFilialFK7    As Character
    Local cQuery        As Character
    Local nVA           As Numeric
	Local oSomaFK6		As Object

	nVa := 0

	aArea		:= GetArea()
	cCartAux    := cCarteira
	cDataBaixa  := DToS(dDataBaixa)
	cDataBase   := DToS(dDataBase)
	cFilialFK7  := FwXFilial("FK7", cFilMov)

	If __lCmpoFK1 == Nil .Or. __lCmpoFK2 == Nil
		__lCmpoFK1	:= FK1->(FieldPos("FK1_DTDISP")) > 0 .And. FK1->(FieldPos("FK1_DTDIGI")) > 0
		__lCmpoFK2	:= FK2->(FieldPos("FK2_DTDISP")) > 0 .And. FK2->(FieldPos("FK2_DTDIGI")) > 0
	EndIf

	If cAdiant == "1"
		If cCartAux == "P"
			cCartAux := "R"
		Else
			cCartAux := "P"
		EndIf
	EndIf

	//cTipoData := "0"  // FK1_DATA/FK2_DATA
	//cTipoData := "1"  // FK1_DTDISP/FK2_DTDISP
	//cTipoData := "2"  // FK1_DTDIGI/FK2_DTDIGI
	If cCartAux == "P"
		If !__lCmpoFK2 .And. cTipoData $ "1|2"
			Return nVa
		EndIf
		If Empty(__cQryFK6P)
			__cQryFK6P	:= FinFK6Pag()
			__oSomaFK6P	:= FwPreparedStatement():New(__cQryFK6P)
		EndIf
		oSomaFK6 := __oSomaFK6P
	Else
		If !__lCmpoFK1 .And. cTipoData $ "1|2"
			Return nVa
		EndIf
		If Empty(__cQryFK6R)
			__cQryFK6R	:= FinFK6Rec()
			__oSomaFK6R	:= FwPreparedStatement():New(__cQryFK6R)
		EndIf
		oSomaFK6 := __oSomaFK6R
	EndIf

	If (__lCmpoFK1 .And. cCartAux == "R") .Or. (__lCmpoFK2 .And. cCartAux == "P")
		oSomaFK6:SetString(01, FWxFilial("FK1",cFilMov))
		oSomaFK6:SetString(02, cIdDoc)
		oSomaFK6:SetString(03, cFilOri)
		oSomaFK6:SetString(04, cDataBaixa)
		oSomaFK6:SetString(05, cTipoData)
		oSomaFK6:SetString(06, cDataBaixa)
		oSomaFK6:SetString(07, cTipoData)
		oSomaFK6:SetString(08, cDataBaixa)
		oSomaFK6:SetString(09, cTipoData)
		oSomaFK6:SetString(10, cCartAux)
		oSomaFK6:SetString(11, cCartAux)
		oSomaFK6:SetString(12, cCarteira)
		oSomaFK6:SetString(13, cDataBase)
		oSomaFK6:SetString(14, cTipoData)
		oSomaFK6:SetString(15, cDataBase)
		oSomaFK6:SetString(16, cTipoData)
		oSomaFK6:SetString(17, cDataBase)
		oSomaFK6:SetString(18, cTipoData)
	Else
		oSomaFK6:SetString(01, FWxFilial("FK1",cFilMov))
		oSomaFK6:SetString(02, cIdDoc)
		oSomaFK6:SetString(03, cFilOri)
		oSomaFK6:SetString(04, cDataBaixa)
		oSomaFK6:SetString(05, cCartAux)
		oSomaFK6:SetString(06, cCartAux)
		oSomaFK6:SetString(07, cCarteira)
		oSomaFK6:SetString(08, cDataBase)
	EndIf

	cQuery := oSomaFK6:GetFixQuery()

	cAliasTMP := GetNextAlias()

	DbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasTMP, .F., .T.)

	If __nMoeda != nMoedaTit
		While (cAliasTMP)->(!(EoF()))
			nVa += Round(NoRound(xMoeda((cAliasTMP)->VA, 1, nMoedaTit, (cAliasTMP)->FKDATA, 3,, IIf((cAliasTMP)->TXMOEDA == 0, nTaxaMoeda, (cAliasTMP)->TXMOEDA)), 3), 2)
			(cAliasTMP)->(DbSkip())
		End
	Else
		While (cAliasTMP)->(!(EoF()))
			nVa += (cAliasTMP)->VA
			(cAliasTMP)->(DbSkip())
		End
	EndIf

	(cAliasTMP)->(DbCloseArea())
	RestArea(aArea)

Return nVA

//-----------------------------------------------------------------------
/*/{Protheus.doc} FinhlpUrl
Modal para ser exebida quando for não for localizado nenhum título com a taxa
contrada do título de partida e quando o parâmetro  for Falso
@author  Bruno Horvat
@since   27/07/2021
@version 1.0
/*/
//-----------------------------------------------------------------------
Function FinhlpUrl(cTitle,cHelp,cLink,cUrl)

local oModal 		:= nil
local oContainer	:= nil
local oSay1			:= nil
local oSay2			:= nil
Local cRmtType 		:= ""

GetRemoteType(@cRmtType)

If "WIN" $ cRmtType
	bBlock :=  {|| ShellExecute("open",cUrl,"","",1) }
Else
	bBlock :=  {|| ShellExecute("Browser", "/usr/bin/firefox",cUrl, "/", 1 ) }
EndIf

oModal := FWDialogModal():New()
oModal:SetEscClose(.T.)
oModal:setTitle(cTitle)

oModal:setSize(110, 203)

oModal:createDialog()
oModal:addCloseButton(nil, "Fechar")
oContainer := TPanel():New( ,,, oModal:getPanelMain() )
oContainer:Align := CONTROL_ALIGN_ALLCLIENT

@ 010,005 SAY oSay1 PROMPT cHelp SIZE 190,110 COLORS CLR_BLACK,CLR_WHITE OF oContainer HTML PIXEL
@ 050,005 SAY oSay2 PROMPT cLink              COLORS CLR_BLACK,CLR_WHITE OF oContainer HTML PIXEL

oSay2:bLClicked := {|| MsgRun( STR0105, "URL", bBlock ) }	//"Abrindo o link... Aguarde..."

oModal:Activate()

return

//-----------------------------------------------------------------------
/*/{Protheus.doc} EngSPS10Signature
Função para retornar assinatura da rotina - Processo 10 - SALDO DO TÍTULO
@author  Norberto M de Melo
@since   20/12/2021
@version 1.0
/*/
//-----------------------------------------------------------------------
Function EngSPS10Signature(cProcess as character)
Local cAssinatura as character

cAssinatura := VERIDPROC()

Return cAssinatura
//-----------------------------------------------------------------------

/*/{Protheus.doc} VldExtCNAB
Valida as extensões dos arquivos de remessa/retorno CNAB.

@type  		Function
@author 	Rafael Riego
@since 		18/03/2022
@param		cExtensao, character, extensão do arquivo a ser validada
@param 		cRotina, character, rotina que está sendo executada. Determina qual parâmetro (SX6) será utilizado para validação
@return 	logical, verdadeiro caso a extensão informada para o arquivo de configuração seja válida
/*/
Function VldExtCNAB(cExtensao As Character, cRotina As Character) As Logical

	Local cExtensoes	As Character
	Local cExtLower		As Character
	Local cHelpExt		As Character
	Local cMVExtCNAB	As Character

	Local lExtensVld	As Logical

	Default cExtensao	:= ""
	Default cRotina		:= "FINA150"

	cMVExtCNAB	:= ""
	lExtensVld	:= .T.
	cExtLower	:= Lower(AllTrim(cExtensao))

	If !(Empty(cExtLower))
		If cRotina == "FINA150"			//Geração de Remessa (Receber)
			cMVExtCNAB 	:= "MV_FEXREMR"
		ElseIf cRotina == "FINA200"		//Retorno de Remessa (Receber)
			cMVExtCNAB := "MV_FEXRETR"
		ElseIf cRotina == "FINA420"		//Geração de Remessa (Pagar)
			cMVExtCNAB := "MV_FEXREMP"
		Else //FINA430					//Retorno de Remessa (Pagar)
			cMVExtCNAB := "MV_FEXRETP"
		EndIf

		//Somente valida a extensão do arquivo caso o parâmetro esteja preenchido com as extensões permitidas
		If !(Empty(cExtensoes := Lower(AllTrim(SuperGetMV(cMVExtCNAB,, "")))))
			If !(cExtLower $ cExtensoes)
				cHelpExt := STR0110 + " '" + cMVExtCNAB + "' " + STR0111 + "'" + AllTrim(cExtensao) + "'."
				Help(,, "ARQCFGCNAB",, STR0107 + " '" + AllTrim(cExtensao) + "' " + STR0108, 1, 0,,,,,, {cHelpExt})
				lExtensVld := .F.
			EndIf
		EndIf
	EndIf

Return lExtensVld

// -----------------------------------------------------------
/*/{Protheus.doc} FinVldStr

@author Gabriel Oliveira dos Santos
@since 05/10/2022
@version 1.0
@return  Possui (T) ou não (F) caracter especial
// -----------------------------------------------------------
/*/

Function FinVldStr(cConteudo As Character,cCaracEsp As Character,oModel As Object) As logical

	Local lRet 	As Logical
	Local nX 	As Numeric

	lRet	:= .T.
	nX		:= 0

	Default cCaracEsp	:= "|'"
	Default cConteudo	:= Alltrim(&(ReadVar()))

	For nX:= 1 To Len(cConteudo)
		If SubStr(cConteudo,nX,1) $ cCaracEsp
			lRet:= .F.
			Exit
		EndIf

	Next(nX)

	If !lRet .AND. oModel != NIL
		oModel:SetErrorMessage("","","","","NOTSPCHAR",STR0112,STR0113) //STR0112: Não é permitido o uso de caracteres especiais - STR0113: Favor retirar os caracteres especiais
	Endif

Return lRet

//--------------------------------------------------------------------------------
/*/{Protheus.doc} FUpdStamp
Integração Gesplan - Update somente para atualização do timestamp no banco

@type  		Function
@author 	Fabio Zanchim
@since 		22/03/2023
@param		cAlias, character, tabela a ser atualizada
@param 		cField, character, campo do update
@param 		nRecno, numeric, registro a ser atualizado
@version   	1.0
/*/
//--------------------------------------------------------------------------------
Function FUpdStamp(cAlias As Character ,nRecno As Numeric)

Local cStatement As Character

If oJsonStamp == Nil
	oJsonStamp := JsonObject():New()
EndIf

If !oJsonStamp:HasProperty(cAlias)
	oJsonStamp[cAlias] := Ascan(TCStruct(RetSqlName(cAlias)), {|x| x[1] == 'S_T_A_M_P_'}) <> 0
EndIf

If oJsonStamp[cAlias]
	cStatement	:= " UPDATE "+RetSqlName(cAlias)
	//- Forçando o envio de nulo, é disparado corretamente a atualizaçao do stamp
	cStatement 	+= " SET S_T_A_M_P_ = NULL "
	cStatement 	+= " Where R_E_C_N_O_ = " + cValToChar(nRecno)
	If TcSqlExec(cStatement) != 0
		Help(" ",1,"ERROSTAMP",,OemToAnsi( STR0118 + TcSqlError() ),1,0)  //"Ocorreu um erro inesperado na atualização do campo S_T_A_M_P_: "
	EndIf
EndIf

Return

/*/{Protheus.doc} NiveisComp
	Retorna uma matriz com os níveis de compartilhamento/modo de acesso
	da uma ou um conjunto de tabelas.
	
	@author Sivaldo Oliveira
	@since 21/11/2023
	
	@param aTabela, Array, Vetor/array de uma única dimensão (unidimensional)
	@return aMatrizRet, Array, Matriz/array com mais de uma única dimensão (bidimensional)
/*/
Function NiveisComp(aTabela As Array)
	Local cTabela    As Char
	Local cMAEmpTbl  As Char
	Local cMAUniTbl  As Char
	Local cMAFilTbl  As Char	
	Local nTamEmp    As Numeric
	Local nTamUni    As Numeric	
	Local nQtdTabela As Numeric
	Local nContador  As Numeric
	Local aMatrizRet As Array
	
	//Parâmetros de entrada
	Default aTabela := {}
	
	//Inicilaiza variáveis
	cTabela    := ""
	cMAEmpTbl  := ""
	cMAUniTbl  := ""
	cMAFilTbl  := ""
	nTamEmp    := 0
	nTamUni    := 0
	nQtdTabela := Len(aTabela)
	nContador  := 0
	aMatrizRet := {}
	
	If nQtdTabela > 0 
		nTamEmp := Len(FwSM0Layout(,1))
		nTamUni := Len(FwSM0Layout(,2))
		
		If __aMatTbl == Nil
			__aMatTbl := {}
		EndIf
		
		For nContador := 1 To nQtdTabela
			If !Empty(cTabela := AllTrim(aTabela[nContador]))				
				If (nPosicao := (ASCan(__aMatTbl, {|Tbl| Tbl[1] == cTabela}))) > 0
					AAdd(aMatrizRet, Aclone(__aMatTbl[nPosicao]))
					Loop
				EndIf
				
				cMAEmpTbl := AllTrim(FWModeAccess(cTabela, 1))
				cMAUniTbl := AllTrim(FWModeAccess(cTabela, 2))
				cMAFilTbl := AllTrim(FWModeAccess(cTabela, 3))
				
				If (nTamEmp+nTamUni) == 0
					cMAEmpTbl := cMAUniTbl := cMAFilTbl
				Else
					If nTamEmp == 0
						cMAEmpTbl := cMAUniTbl
					ElseIf nTamUni == 0
						cMAUniTbl := cMAFilTbl
					EndIf 
				EndIf
				
				AAdd(aMatrizRet, {cTabela, cMAEmpTbl, cMAUniTbl, cMAFilTbl, (cMAEmpTbl+cMAUniTbl+cMAFilTbl)})
				AAdd(__aMatTbl, Aclone(aMatrizRet[Len(aMatrizRet)]))
			EndIf	
		Next nContador
	EndIf
Return aMatrizRet

/*/{Protheus.doc} FVerMP1171
	Retorna se calculo de IRPF será simplificado ou não
	
	@author Pâmela Bernardo
	@since 04/12/2023
	
	@param cFornece, Character, Código do fornecedor (A2_CODIGO)
	@param cLoja, Loja do fornecedor (A2_LOJA)
	@return lIrTabSimp, Logical, indica se calculo ocorre ou não pelo calculo de IRPF Simplificado
/*/
Function FVerMP1171(cFornece As Character, cLoja As Character)
	Local lIrTabSimp As Logical 

	Default cFornece := ""
	Default cLoja := ""
	
	lIrTabSimp :=  SuperGetMV("MV_FMP1171",.F.,.F.) //Habilita calculo do IRPF c/ dedução simplificada

	 If __lDicSimpl == NIL
	    __lDicSimpl := (AliasInDic("DKE") .And. DKE->(FieldPos("DKE_IRSIMP")) > 0) .And. FK4->(FieldPos("FK4_DEDIRS")) > 0
    Endif

	If __lLocBRA == NIL
		__lLocBRA	:= cPaisLoc == "BRA"
	Endif

	 If __lLocBRA .And. __lDicSimpl //Habilita calculo do IRPF c/ dedução simplificada
		dBSelectArea('DKE')
		If DKE->(MSSeek(xFilial("DKE")+cFornece+cLoja))
			If lIrTabSimp
				lIrTabSimp:= DKE->DKE_IRSIMP <> "2"
			EndIf
		EndIf
	EndIf


Return lIrTabSimp

/*/{Protheus.doc} FinSumFK6
	Realiza a soma dos valores acessorios a baixa (FK6) para processos massivos, 
	que utilizam tabela temporaria (FwTemporaryTable)
	@type  Function
	@author Vitor Duca
	@since 17/01/2024
	@version 1.0
	@param cTable, Character, Nome da tabela temporaria (FwTemporaryTable:GetRealName())
	@param cCmpFilial, Character, Campo da tabela temporaria onde esta a informação da filial do titulo
	@param cCmpIDORIG, Character, Campo da tabela temporaria onde esta a informação do IDORIG do titulo tipo
	@param cCmpUpdate, Character, Campo que irá receber a atualização dos valores
	@param cTipo, Character, Informar caso exista a necessidade de filtrar pelo FK6_TPDOC
	@param cTabOri, Character, Tabela origem da baixa (FK1 ou FK2)
	@return lRet, Logical, Se a execução da query ocorreu com sucesso
	@see https://tdn.totvs.com/pages/viewpage.action?pageId=820559421
	@example
	FinSumFK6(oTemporary:GetRealName(), "E1_FILORIG", "E5_IDORIG", "FKD_VALOR", "VA", "FK1")
/*/
Function FinSumFK6(cTable As Character, cCmpFilial As Character, cCmpIDORIG As Character, cCmpUpdate As Character, cTipo As Character, cTabOri As Character) As Logical
	Local cQuery	As Character
	Local lRet		As Logical
	Local cIsNull	As Character
	Local cAliasTMP As Character
	Local cBDname	As Character
	Local oQuery	As Object

	Default cTipo := ""

	cQuery 	:= ""
	lRet 	:= .T.
	cIsNull := "ISNULL"
	cBDname := tcGetdb()
	cAliasTMP := IIF( cBDname $ "POSTGRES", "", cTable + "." )
	
	If FindFunction("totvs.protheus.backoffice.ngf.util.FunctionToDb")
		cIsNull := totvs.protheus.backoffice.ngf.util.FunctionToDb(cBDname, "ISNULL")
	Endif

	cQuery := "UPDATE ? "
	cQuery += "SET ? = "

	cQuery += "(SELECT ?(SUM(CASE WHEN FK6.FK6_TPDOC NOT IN ('DC', 'D2' ) THEN FK6.FK6_VALMOV ELSE -FK6.FK6_VALMOV END),0) "
	cQuery += "FROM " + RetSqlName("FK6") + " FK6 "
	cQuery += "WHERE FK6.FK6_FILIAL = ? "
	cQuery += "AND FK6.FK6_IDORIG = ? "
	cQuery += "AND FK6.FK6_TABORI = ? "

	If !Empty(cTipo)
		cQuery += "AND FK6.FK6_TPDOC = ? "
	Endif

	cQuery += "AND FK6.D_E_L_E_T_ = ' ' )"

	oQuery := FWPreparedStatement():New(cQuery)
	oQuery:SetUnSafe(1, cTable)
	oQuery:SetUnSafe(2, cAliasTMP + cCmpUpdate)
	oQuery:SetUnSafe(3, cIsNull)
	oQuery:SetUnSafe(4, cAliasTMP + cCmpFilial)
	oQuery:SetUnSafe(5, cAliasTMP + cCmpIDORIG)
	oQuery:SetString(6, cTabOri)

	If !Empty(cTipo)
		oQuery:SetString(7, cTipo)
	EndIf	

	cQuery := oQuery:getFixQuery()

	If TcSqlExec(cQuery) != 0
		lRet := .F.
		FinxMsgE(TcSqlError(), STR0117) //"Ocorreu um erro inesperado no calculo dos valores acessórios, por favor salvar as informações abaixo e encaminhar ao administrador do sistema."
	Endif

Return lRet

//------------------------------------------------------------------------------
/*/	{Protheus.doc} IRsAcum()
Retorna os IRs pagos no come cotas
SEH deve posicionada

@author	Sidney Santos
@since 14/02/2024
@version 1.0
@return nTotalIR - soma dos IRs pagos nos meses come cotas
/*/
//------------------------------------------------------------------------------
Static Function IRsAcum() As Numeric

	Local aArea			As Array
	Local cQuery		As Character
	Local nTotalIR		As Numeric
	Local cEHAPLEMP     As Character
	Local cEHNUMERO     As Character
	Local cEHREVISAO    As Character
	Local oIRsAcum		As Object

	aArea 	   := GetArea()
	nTotalIR   := 0
	cEHAPLEMP  := SEH->EH_APLEMP
	cEHNUMERO  := SEH->EH_NUMERO
	cEHREVISAO := SEH->EH_REVISAO
	oIRsAcum   := Nil
	
	If !Empty(cEHAPLEMP) .And. !Empty(cEHNUMERO) .And. !Empty(cEHREVISAO)

		cQuery := " SELECT SUM(EI_VALOR) TOTALIRACUM FROM " + RetSqlName("SEI")
		cQuery += " WHERE EI_FILIAL = ? "
		cQuery += " AND EI_APLEMP = ? "
		cQuery += " AND EI_NUMERO = ? "
		cQuery += " AND EI_REVISAO = ? "
		cQuery += " AND ((EI_MOTBX = ? AND EI_TIPODOC = ?) OR (EI_MOTBX = ? AND EI_TIPODOC = ?)) "
		cQuery += " AND EI_QTDCOTA > ? "
		cQuery += " AND EI_STATUS = ? "
		cQuery += " AND D_E_L_E_T_ = ? "

		cQuery := ChangeQuery(cQuery)

		oIRsAcum := FWExecStatement():New(cQuery)

		oIRsAcum:SetString(1, 	xFilial("SEI"))
		oIRsAcum:SetString(2, 	cEHAPLEMP)
		oIRsAcum:SetString(3, 	cEHNUMERO)
		oIRsAcum:SetString(4, 	cEHREVISAO)
		oIRsAcum:SetString(5, 	'APR')
		oIRsAcum:SetString(6, 	'I6')
		oIRsAcum:SetString(7, 	'NOR')
		oIRsAcum:SetString(8, 	'I1')
		oIRsAcum:SetNumeric(9, 	0)
		oIRsAcum:SetString(10, 	' ')
		oIRsAcum:SetString(11, 	' ')
		
		nTotalIR := oIRsAcum:ExecScalar("TOTALIRACUM")
	EndIf


	If oIRsAcum <> Nil
		oIRsAcum:Destroy()
		oIRsAcum := Nil
	EndIf

	RestArea(aArea)

Return nTotalIR

// -----------------------------------------------------------
/*/{Protheus.doc} FinVldSA2

Retorna loja correta do fornecedor de ISS

@author Victor Azevedo	
@since 27/02/2024
@version 1.0
@return  cLojaIss - Loja do fornecedor ISS
// -----------------------------------------------------------
/*/
Function FinVldSA2(cFornIss As Character) As Character

	Local aAreaSA2	As Array
	Local cLojaIss  As Character

	Default cFornIss	:= ""

	//inicializa variavel
	cLojaIss	:= PadR( "00", __nTamLoja, "0" )

	aAreaSA2 := SA2->(GetArea())
	SA2->(DbSetOrder(1))
	If __lLocBRA .And. !(Empty(cFornIss)) .And. SA2->(DbSeek(xFilial("SA2") + cFornIss))
		While !SA2->(EOF()) .And. SA2->A2_COD == cForniss .And. SA2->A2_FILIAL == xFilial("SA2")
			If SA2->A2_MSBLQL <> '1'
				cLojaIss	:= SA2->A2_LOJA
				Exit
			EndIf
			SA2->(DbSkip())
		EndDo
	EndIf

	RestArea(aAreaSA2)

Return cLojaIss

// -----------------------------------------------------------
/*/{Protheus.doc} posComeCot

Retorna se é mês pós come cotas
Mês come cotas são Maio e Novembro (5 e 11)

@author sidney.silva
@since 11/09/2024
@return lPosCC - retorna se é mês pós come cotas
// -----------------------------------------------------------
/*/
Static Function posComeCot() As Logical

	Local lPosCC As Logical 

	nMesAtual := Month(dDatabase)

	lPosCC := nMesAtual == 6 .Or. nMesAtual == 12

Return lPosCC

// -----------------------------------------------------------
/*/{Protheus.doc} rendAcumu
Calcula o rendimento acumulado da aplicação

@author sidney.silva
@since 24/06/2025
@version 1.0
@param nRndMesAtu, Numeric, rendimento do mês atual
@return nRendAcum, Numeric, retorna o rendimento acumulado
// -----------------------------------------------------------
/*/
Static Function rendAcumu(nRndMesAtu As Numeric) As Numeric
	Local cQuery 		As Character
	Local cAliasSEI		As Character
	Local nAtual		As Numeric
	Local nSumRendM		As Numeric
	Local nRendMes		As Numeric
	Local nRendAcum		As Numeric
	Local oRendAcu		As Object

	Default nRndMesAtu := 0

	cQuery 			:= ''
	cAliasSEI		:= ''
	nAtual			:= 0
	nSumRendM		:= 0
	nRendMes		:= 0
	nRendAcum		:= 0
	oRendAcu		:= NIL

	cQuery := " SELECT EI_VALOR "
	cQuery += " FROM "+ RetSqlName("SEI") + " SEI "
	cQuery += " WHERE "
	cQuery += " EI_FILIAL 		= ? "
	cQuery += " AND EI_APLEMP 	= ? "
	cQuery += " AND EI_NUMERO 	= ? "
	cQuery += " AND EI_REVISAO 	= ? "
	cQuery += " AND EI_MOTBX 	= ? "
	cQuery += " AND EI_TIPODOC 	= ? "
	cQuery += " AND EI_IRACUM 	> ? "
	cQuery += " AND EI_STATUS 	= ? "
	cQuery += " AND D_E_L_E_T_ 	= ? "

	cQuery 		:= ChangeQuery(cQuery)
	oRendAcu 	:= FwExecStatement():New(cQuery)

	oRendAcu:SetString(1, 	xFilial('SEI'))
	oRendAcu:SetString(2, 	SEH->EH_APLEMP)
	oRendAcu:SetString(3, 	SEH->EH_NUMERO)
	oRendAcu:SetString(4, 	SEH->EH_REVISAO)
	oRendAcu:SetString(5, 	'APR')
	oRendAcu:SetString(6, 	'I7')
	oRendAcu:SetNumeric(7, 	0)
	oRendAcu:SetString(8, 	' ')
	oRendAcu:SetString(9, 	' ')

	cAliasSEI := oRendAcu:OpenAlias()

	While !(cAliasSEI)->(Eof())
		nAtual 		:= (cAliasSEI)->EI_VALOR
		nRendMes	+= nSumRendM + nAtual

		nSumRendM 	:= -nAtual

		(cAliasSEI)->(DbSkip())
	EndDo

	nRendAcum := nRendMes + nRndMesAtu

	(cAliasSEI)->(DbCloseArea())

	If oRendAcu <> Nil
		oRendAcu:Destroy()
	EndIf

Return nRendAcum

//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} FinVldBco
Realiza validacao do banco informado e atualiza agencia e conta caso exista o codigo do banco.

@author Victor Azevedo
@version P12
@since  10/12/2024
@return  lRet
*/
//-----------------------------------------------------------------------------------------------------------------------
Function FinVldBco(cBanco, cAgencia, cConta, lVldHelp, lVldBlqCta, oGet) As Logical
	
	Local lRet 		As Logical
	Local cCampo	As Character
	Local cAgen		As Character
	Local cCnta 	As Character
	Local cFunName  As Character
	Local lHelpBco  As Logical
	Local lVldSA6	As Logical
	
	Default cBanco     := ""
	Default cAgencia   := ""
	Default cConta     := ""
	Default lVldHelp   := .F.
	Default lVldBlqCta := .F.
	Default oGet	   := Nil

	lHelpBco := .T.
	lRet	 := .T.
	cAgen	 := ""
	cCnta	 := ""
	cCampo	 := AllTrim(ReadVar())
	cFunName := FunName()
	lVldSA6  := .T.
	
	If oGet != Nil .And. lVldHelp .And. lVldBlqCta

		If FwIsInCallStack("FA060Trans") .and. Empty(cBanco) .and. Empty(cAgencia) .and. Empty(cConta)
			lVldSA6 := .F.
		EndIf

		If lVldSA6 .And. !(CarregaSA6( @cBanco, @cAgencia, @cConta, lVldHelp, Nil, lVldBlqCta ))	
			lRet := .T.
			oGet:SetFocus()
		EndIf
	
	ElseIf (AllTrim( cBanco ) # AllTrim( SA6->A6_COD ))

		If Empty(cAgencia)
			cAgencia := CriaVar( "A6_AGENCIA" )
		EndIf

		If Empty(cConta)
			cConta := CriaVar( "A6_NUMCON" )
		EndIf
		
		If cCampo $ "CCBANCO|CPORT060" .And. !Empty(cAgencia)
			cAgencia  := ""
			cConta    := ""
		EndIf

		If cCampo $ "CAGENCIA|CAGEN060" .And. !Empty(cConta)
			cConta    := ""
			lHelpBco  := .F.
		EndIf

		If FwIsInCallStack("FA060Trans") .And. Empty(cBanco)
			lVldSA6 := .F.
		EndIf

		If lVldSA6
			lRet := CarregaSA6( @cBanco, @cAgencia, @cConta, lHelpBco )
		EndIf
	EndIf
	
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} TrataFil
    @description Realizar o tratamento de filial para execução de bind na query de acordo com o compartilhamento da tabela enviado
    @author victor.azevedo@totvs.com.br
	@version P12
	@since 03/02/2025
	@return aRetFils (array com as filiais tratadas conforme compartilhamento da tabela enviada)
*/
//-------------------------------------------------------------------
Function TrataFil(cAlias as Character, aBranches as Array) as Array
    
	Local cFilAux	as Character
	Local nX 		as Numeric
	Local aRetFils	as Array

	Default cAlias		:= "SE2"
	Default aBranches	:= {}

	cFilAux		:= ""
	nX			:= 1
	aRetFils	:= {}

	If !Empty(aBranches)
		For nX := 1 to Len(aBranches)
			cFilAux := FWxFilial(cAlias, aBranches[nX])
            If aScan( aRetFils, cFilAux ) == 0
                AAdd(aRetFils, FwXFilial(cAlias, cFilAux))
            EndIf
		Next nX
	EndIf

Return aRetFils

//-------------------------------------------------------------------
/*{Protheus.doc} buscaUltBx
    Responsável por buscar a última data de baixa válida para o título posicionado,
    levando em conta a data base do sistema.
    É o equivalente ao E1_BAIXA/E2_BAIXA.
    @return Date
    @author victor.azevedo@totvs.com.br
    @since 25/02/2025
*/
//-------------------------------------------------------------------
Function buscaUltBx(cIdFK7, oUltBaixa) as Date
    
	Local dUltBaixa	 	as Date
    Local cQuery 		as Character
	Local cSpace		as Character
	Local cFK2Name 		as Character
	Local nParam		as Numeric
	Local aMotBx		as Array	

	Default cIdFK7	:= ""
	Default oUltBaixa	:= Nil

	dUltBaixa	:= CTOD(" / / ")
	cQuery		:= ""
	cSpace		:= Space(1)
	cFK2Name	:= RetSqlName("FK2")
	nParam		:= 1
	aMotBx		:= {'PCC', 'IRF', 'ISS', 'IMR'}
    
	If oUltBaixa == NIL
        cQuery := "SELECT MAX(FK2_DATA) ULTIMA_BAIXA "
        cQuery += "FROM ? FK2 "
        cQuery += "WHERE FK2_IDDOC = ? "
        cQuery += "AND NOT EXISTS ( "
        cQuery += "    SELECT EST.FK2_IDDOC "
        cQuery += "    FROM ? EST "
        cQuery += "    WHERE EST.FK2_IDDOC = FK2.FK2_IDDOC "
        cQuery += "    AND EST.FK2_SEQ = FK2.FK2_SEQ "
        cQuery += "    AND EST.FK2_TPDOC = ?  "
        cQuery += "    AND EST.D_E_L_E_T_ = ? "
        cQuery += "    AND EST.FK2_DATA <= ? "
        cQuery += ") "
        cQuery += "AND FK2.FK2_TPDOC <> ? "
        cQuery += "AND FK2.FK2_DATA <= ? "
		cQuery += "AND FK2.FK2_MOTBX NOT IN (?) ""
        cQuery := changeQuery(cQuery)
        
        oUltBaixa := FwExecStatement():New(cQuery)
    endIf
    
	oUltBaixa:setUnsafe(nParam++, cFK2Name)
	oUltBaixa:setString(nParam++, cIdFK7)
	oUltBaixa:setUnsafe(nParam++, cFK2Name)
    oUltBaixa:setString(nParam++, "ES")
	oUltBaixa:setString(nParam++, cSpace)
	oUltBaixa:setDate(nParam++, dDatabase)
	oUltBaixa:setString(nParam++, "ES")
    oUltBaixa:setDate(nParam++, dDatabase)
	oUltBaixa:setIn(nParam++, aMotBx)

    dUltBaixa := sTod(oUltBaixa:ExecScalar("ULTIMA_BAIXA"))

Return dUltBaixa

/*/{Protheus.doc} FinSepara
Função tem como objetivo criar array a partir de uma string, onde pode ser array com N elementos
A quebra para adicionar no array será atraves de caracter enviado pelo chamada. 
Se não for enviado o caracter separador, por padrão irá utilizar o caracter PIPE '|'
@param cString - String que será lida pela função
@param cSepara - Caracter usado como separador e quebra para alimentar vetor. - Se não informado será considerado o caractere PIPE
@param cAbreBloco - Caracter usado para abertura do bloco de caracteres que será montado.  - Se não informado será considerado o caractere "{"
@param cFechBloco - Caracter usado para fechamento do bloco de caracteres que será montado.  - Se não informado será considerado o caractere "}"

@Return - Array
@author Francisco Oliveira
@since  18/03/2025
@version 12
/*/ 
Function FinSepara(cString As Character, cSepara As Character, cAbreBloco As Character, cFechBloco As Character) As Array

    Local nXStr     As Numeric
    Local nXStrAux  As Numeric
    Local nTamStr   As Numeric
    Local cCharSub  As Character
    Local cStrMem   As Character
    Local cLastChr  As Character
    Local cStrAux   As Character
    Local aArrStr   As Array

    Default cString     := ""
    Default cSepara     := "|"
    Default cAbreBloco  := "{"
    Default cFechBloco  := "}"

    cCharSub    := ""    
    cStrMem     := ""
    cLastChr    := ""
    cStrAux     := ""
    aArrStr     := {}
    nTamStr     := Rat(cFechBloco, (cString := AllTrim(cString)))
    nXStrAux    :=  At(cAbreBloco, cString )

    If nXStrAux > 0 .And. nTamStr > 0
        For nXStr := nXStrAux To nTamStr
            cCharSub := SubStr(cString, nXStr, 1 )
            If (cCharSub == cAbreBloco .Or. cCharSub == cFechBloco)
                cStrAux  += cCharSub
                cLastChr := cCharSub
                
                If nXStr < nTamStr
                    Loop
                Endif
			Endif

            If cLastChr == cFechBloco .And. Empty(cCharSub)
                Loop
            ElseIf cLastChr == cFechBloco .And. !Empty(cCharSub) .And. cCharSub != cSepara .And. nXStr < nTamStr
                cStrAux += cCharSub
            ElseIf !(cLastChr == cFechBloco) .And. !Empty(cCharSub) .And. Len(cStrAux) > 0 .And. cCharSub != cSepara
                cStrAux += cCharSub
            Endif

            If Len(cStrAux) > 0
                cStrMem += cStrAux
                cStrAux := ""
            Else
                cStrMem += cCharSub
            Endif
        Next nXStr
    Endif

    If Len(cStrMem) > 0
        Aadd(aArrStr, cStrMem)
    Endif

Return aArrStr

/*/{Protheus.doc} FINPICVAR
Função criada para tratamento da picture dos campos E2_CNPJRET, EF_CPFCNPJ e EU_CGC
@param nCpo, numeric, Número do campo.
@type function
@Return character, cMasc
@author matheus.monteiro@totvs.com.br
@since  10/04/2025
@version 12
/*/ 
Function FINPICVAR(nCpo As Numeric) As Character
    
    Local cMasc		As Character
	Local oModelFLX	As Object
	Local oGridFLX	As Object
	Local cMascFLX	As Character

	cMasc    := PICPES("J")
	cMascFLX := ""

    Default nCpo := 0

	If FwIsInCallStack("FINA027") .Or. FwIsInCallStack("FINA027A")
		oModelFLX := FWModelActive()
		oGridFLX  := oModelFLX:GetModel("FLXDETAIL")
		cMascFLX  := oGridFLX:GetValue("FLX_TIPO")
		If cMascFLX == "1"
			cMascFLX := "F"
		Else
			cMascFLX := "J"
		EndIf
	EndIf

    If nCpo == 2 .And. (FwIsInCallStack("FINA750") .Or. FwIsInCallStack("FINA050")) .And. Empty(cMascFLX)
        cMasc := PICPES(Posicione("SA2", 1, xFilial("SA2") + M->E2_FORNECE + M->E2_LOJA, "A2_TIPO"))
    ElseIf nCpo == 3 .And. !Empty(M->EU_CGC) .And. Len(AllTrim(M->EU_CGC)) == 11 .And. Empty(cMascFLX)
        cMasc := PICPES("F")
    ElseIf nCpo == 1
        cMasc := "@!"
	ElseIf cMascFLX $ "F|J"
		cMasc := PICPES(cMascFLX)
    Endif

    cMasc := cMasc + "%C"

Return cMasc

// -----------------------------------------------------------
/*/{Protheus.doc} rendResg
Calcula o rendimento acumulado da aplicação

@author sidney.silva
@since 01/07/2025
@version 1.0
@return nRendResg, Numeric, retorna o rendimento dos resgates
// -----------------------------------------------------------
/*/
Static Function rendResg() As Numeric
	Local aAreaSE0 		As Array
	Local cQuery 		As Character
	Local nVlResgMes	As Numeric
	Local nRendResg		As Numeric
	Local nCotasResg	As Numeric
	Local oVlrResg		As Object

	aAreaSE0		:= SE0->(GetArea())
	cQuery 			:= ''
	nVlResgMes		:= 0
	nRendResg		:= 0
	nCotasResg		:= 0
	oVlrResg		:= NIL

	cQuery := " SELECT SUM(EI_VALOR) VLRESGMES, SUM(EI_QTDCOTA) COTASRESG" 
	cQuery += " FROM "+ RetSqlName("SEI") + " SEI "
	cQuery += " WHERE "
	cQuery += " EI_FILIAL 		= ? "
	cQuery += " AND EI_APLEMP 	= ? "
	cQuery += " AND EI_NUMERO 	= ? "
	cQuery += " AND EI_REVISAO 	= ? "
	cQuery += " AND EI_MOTBX 	= ? "
	cQuery += " AND EI_TIPODOC 	= ? "
	cQuery += " AND D_E_L_E_T_ 	= ? "

	cQuery 		:= ChangeQuery(cQuery)
	oVlrResg 	:= FwExecStatement():New(cQuery)

	oVlrResg:SetString(1, 	xFilial('SEI'))
	oVlrResg:SetString(2, 	SEH->EH_APLEMP)
	oVlrResg:SetString(3, 	SEH->EH_NUMERO)
	oVlrResg:SetString(4, 	SEH->EH_REVISAO)
	oVlrResg:SetString(5, 	'NOR')
	oVlrResg:SetString(6, 	'RG')
	oVlrResg:SetString(7, 	' ')

	nVlResgMes := oVlrResg:ExecScalar('VLRESGMES')
	nCotasResg := oVlrResg:ExecScalar('COTASRESG')

	If oVlrResg <> Nil
		oVlrResg:Destroy()
	EndIf

	SE0->(MsSeek(xFilial("SE0")+ SEH->(EH_BCOCONT+EH_AGECONT+EH_CTACONT+EH_CONTRAT+Str(21001231-Val(DTOS(dDatabase - (Day(dDatabase)))),11))))

	nRendResg := (nVlResgMes + (SEH->EH_SLDCOTA * SE9->E9_VLRCOTA)) - (SE0->E0_VALOR * (SEH->EH_SLDCOTA + nCotasResg))

	RestArea(aAreaSE0)

Return nRendResg

/*/{Protheus.doc} UsaBillRel
	Valida se a class BillRelated está disponível para uso
	
	@author Sivaldo Oliveira
	@since 05/08/2025
/*/
Function UsaBillRel(aLstMetodo As Array, jMetodoCls As JSon)
	Local nQtdMetodo As Numeric
	Local nLinha     As Numeric
	
	//Parâmetros de entrada
	Default aLstMetodo := {}
	Default jMetodoCls := Nil
	
	//Inicializa variáveis
	nQtdMetodo := Len(aLstMetodo) 
	nLinha     := 0

	If __lBillRel == Nil 
		__lBillRel := FindClass("totvs.protheus.backoffice.fin.bills.related.BillRelated")
	EndIf

	If __lBillRel .And. __oBillRel == Nil
		__oBillRel := totvs.protheus.backoffice.fin.bills.related.BillRelated():New()

		If !__oBillRel:canUseRelatedBill()
			FwFreeObj(__oBillRel)
		EndIf
	EndIf

	If nQtdMetodo > 0 .And. __oBillRel != Nil
		If jMetodoCls == Nil 
			jMetodoCls := JsonObject():New()
		EndIf

		For nLinha := 1 To nQtdMetodo
			If !Empty(AllTrim(aLstMetodo[nLinha])) .And. !jMetodoCls:HasProperty(aLstMetodo[nLinha])
				jMetodoCls[aLstMetodo[nLinha]] := MethIsMemberOf(__oBillRel, aLstMetodo[nLinha])
			EndIf
		Next nLinha

		FwFreeArray(aLstMetodo)
	EndIf
Return __oBillRel

/*/{Protheus.doc} RetFK7Tit
	Realiza a busca do(s) titulo(s) pai ou filhos na FK7

	@param cTab, character, Informa a tabela do titulo (SE1 ou SE2)
	@param lTitFilho, logical, Indica se o titulo é filho
	@param cAliasOrig, character, Tabela de origem do registro (ex:
	quando o SE2 é gerado a partir da inclusao do SE1)

	@return xFK7Tit, undefined, titulo(s) localizado(s)

	@type  Static Function
	@author Marcos Pires
	@since 30/09/2025
/*/
Function RetFK7Tit(cTab as character, lTitFilho as logical, cTabOrig as character,cTitPaiOld as character) as array
Local xFK7Tit      := Nil
Local oObjTitPai   as object
Local json         as json
Local nX           as numeric
Local aLstMetodo   as array
Local jMetodoCls   as json
Local cChavTit     as character

Default cTab       := ""
Default lTitFilho  := .F.
Default cTabOrig   := ""
Default cTitPaiOld := ""

xFK7Tit    := Iif(lTitFilho,"",{})
oObjTitPai := Nil
json       := Nil
nX         := 0
aLstMetodo := {"setAliasOrig"}
jMetodoCls := Nil
cChavTit   := ""

oObjTitPai := UsaBillRel(aLstMetodo, @jMetodoCls)

If oObjTitPai <> Nil

 	If !Empty(cTabOrig) .And. jMetodoCls['setAliasOrig']
		oObjTitPai:setAliasOrig(cTabOrig)
	EndIf

	json := oObjTitPai:getRelatedBills(cTab, lTitFilho)

	if !Empty(json['document']) .And. Len(json['document']) > 0
		For nX := 1 To Len(json['document'])

			cChaveTit :=	json['document'][nX]['FK7_FILTIT']	+;
							json['document'][nX]['FK7_PREFIX']	+;
							json['document'][nX]['FK7_NUM']		+;
							json['document'][nX]['FK7_PARCEL']	+;
							json['document'][nX]['FK7_TIPO']	+;
							json['document'][nX]['FK7_CLIFOR']	+;
							json['document'][nX]['FK7_LOJA']

			If lTitFilho
				xFK7Tit :=	cChaveTit
			Else
				AAdd(xFK7Tit, cChaveTit)
			EndIf

		Next nX
	EndIf

	FWFreeObj(json)
	FWFreeObj(jMetodoCls)
	FWFreeObj(oObjTitPai)
EndIf

If Empty(xFK7Tit) .And. lTitFilho .And. !Empty(cTitPaiOld)
	xFK7Tit := cTitPaiOld
EndIf

Return xFK7Tit
