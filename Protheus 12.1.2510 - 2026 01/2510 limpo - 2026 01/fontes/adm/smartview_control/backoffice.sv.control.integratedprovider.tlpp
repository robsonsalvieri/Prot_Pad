#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "totvs.ch"
#include "msobject.ch"
#include "PROTHEUS.CH"
#include "FWMVCDEF.CH"

namespace totvs.protheus.backoffice.control.smartView.integratedProvider

//-------------------------------------------------------------------
/*/{Protheus.doc} ControlSvParamUtil
Classe para tratativas de parâmetros a serem utilizados no SmartView.

@author Controladoria
@since 24/04/2024
@version 1.0    
/*/
//-------------------------------------------------------------------
class ControlIntegratedProvider
    
    public method new() as object

    public method setBranchPar()
    public method loadFilterBranches()
    public method loadBranches()   as array
    public method getCompanyName() as character
    public method getBranchName()  as character

    //Metodos de controle de paginação
    public method setStep()
    public method hasNextPage() as logical
    public method setPageRangeByStep()

    public data lAllowBranchFilter  as logical
    public data lMultSelectBranches as logical

    public data oFilterBranches     as object
    public data lEmptyMultiBranches as logical
    public data cFromBranch     as character
    public data cToBranch       as character
    public data aMultiBranches  as array

    //Atributos para controlar paginação nas queries
    public data lAppend      as logical
    public data nTotalRows   as numeric
    public data nLastRowPage as numeric
    public data nRecnoI   as numeric
    public data nRecnoF   as numeric
    protected data nStep     as numeric
    
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} new
Construtor da classe

@author Controladoria
@since 18/09/2024
@version 1.0
/*/
//-------------------------------------------------------------------
method new() class ControlIntegratedProvider
    ::lMultSelectBranches := .F.
    ::lAllowBranchFilter  := .F.
    ::lEmptyMultiBranches := .F.
    ::lAppend      := .F.
    ::nRecnoI      := 0
    ::nRecnoF      := 0
    ::nStep        := 500
    ::nTotalRows   := 0
    ::nLastRowPage := 0
return Self

//-------------------------------------------------------------------
/*/{Protheus.doc} setBranchPar
    Atribui valores para as variáveis de filiais.
    
    @author Controladoria
    @since 18/09/2024
    @version 12.1.2310
*/
//-------------------------------------------------------------------
method setBranchPar(oJsonMvPar as json) class ControlIntegratedProvider
    if self:lMultSelectBranches
        self:aMultiBranches := oJsonMvPar:SV_MULTBRANCH
    else
        self:cFromBranch := oJsonMvPar:SV_FROMBRANCH[1]
        self:cToBranch := oJsonMvPar:SV_TOBRANCH[1]
    endIf
    //Este if existe, pois após executar o filtro, limpar e enviar novamente, 
    //ele considera array com 1 posição vazia
    if empty( self:aMultiBranches )
        self:lEmptyMultiBranches := .T. 
    elseIf empty( self:aMultiBranches[1] ) 
        self:lEmptyMultiBranches := .T. 
    endIf
return

//-------------------------------------------------------------------
/*/{Protheus.doc} loadFilterBranches

    @author Controladoria
    @since 18/09/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method loadFilterBranches(aAliasBranches as array) class ControlIntegratedProvider
    local nX := 1 as numeric

    self:oFilterBranches := JSONObject():new()
    
    if self:lMultSelectBranches //Se o ON for seleção de múltiplas filiais, seguir esse modelo
        if self:lEmptyMultiBranches
            for nX := 1 to Len(aAliasBranches)
                self:oFilterBranches[aAliasBranches[nX]] := {}
                aAdd( self:oFilterBranches[aAliasBranches[nX]], { } )
            next nX
        else
            for nX := 1 to Len(aAliasBranches)
                self:oFilterBranches[aAliasBranches[nX]] := {}
                aAdd( self:oFilterBranches[aAliasBranches[nX]], self:loadBranches(aAliasBranches[nX]) )
            next nX
        endIf
    else // Se o ON for Filial De/Até, seguir esse modelo
        if empty(self:cFromBranch) .and. empty(self:cToBranch)
            self:cFromBranch := FWxFilial(aAliasBranches[nX])
            self:cToBranch := FWxFilial(aAliasBranches[nX])
        endIf
    endIf    
return 

//-------------------------------------------------------------------
/*/{Protheus.doc} loadBranches

    @author Controladoria
    @since 18/09/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method loadBranches(cAlias as character) as array class ControlIntegratedProvider
    local nX, nY     := 0   as numeric
    local aBranches  := {}  as array
    local cFilAux    := ""  as character
    local lExclusivo := .F.	as logical 
    local lComparFil := .F. as logical
    local lEmpExc as logical
    local lUniExc as logical
    local lFilExc as logical

    lEmpExc	:= FwModeAccess(cAlias, 1) == "E"
    lUniExc	:= FwModeAccess(cAlias, 2) == "E"
    lFilExc := FwModeAccess(cAlias, 3) == "E"

    lExclusivo := IIF( lEmpExc .And. lUniExc .And. lFilExc, .T., .F. )
    lComparFil := IIF( lEmpExc .And. lUniExc .And. !lFilExc, .T., .F. ) //Somente compartilhado por Filial
    
    for nX := 1 to len(self:aMultiBranches)
        if ValType(self:aMultiBranches[nX]) == "A"
            for nY := 1 to len(self:aMultiBranches[nX])
                if lComparFil
                    cFilAux := FWxFilial(cAlias,self:aMultiBranches[nX][nY])
                else
                    cFilAux := self:aMultiBranches[nX][nY]
                endif
                if aScan( aBranches, cFilAux ) == 0
                    aAdd( aBranches, cFilAux )
                endIf  
            next nY
        else
            if lComparFil
                cFilAux := FWxFilial(cAlias,self:aMultiBranches[nX])
            else
                cFilAux := self:aMultiBranches[nX]
            endif
            
            if aScan( aBranches, cFilAux ) == 0
                aAdd( aBranches, cFilAux )
            endIf
        endif
    next nX
return aBranches

//-------------------------------------------------------------------
/*/{Protheus.doc} getCompanyName
    Retorna o nome da empresa logada

    @author Controladoria
    @since 18/09/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method getCompanyName() as character class ControlIntegratedProvider
return AllTrim(FWEmpName(cEmpAnt))

//-------------------------------------------------------------------
/*/{Protheus.doc} getBranchName
    Retorna o nome da filial logada

    @author Controladoria
    @since 18/09/2024
    @version 12.1.2410
*/
//-------------------------------------------------------------------
method getBranchName() as character class ControlIntegratedProvider
return AllTrim(FWFilialName())

//-------------------------------------------------------------------
/*/{Protheus.doc} setStep
    Seta o atributo de step, conforme parâmetro informado

    @author Renan Gremes
    @since 10/09/2025
    @version 12.1.2310
/*/ 
//-------------------------------------------------------------------
method setStep(nNewStep as numeric) class ControlIntegratedProvider
    ::nStep := nNewStep
return

//-------------------------------------------------------------------
/*/{Protheus.doc} hasNextPage
    Verifica se tem próxima página

    @author Renan Gremes
    @since 10/09/2025
    @version 12.1.2310
/*/ 
//-------------------------------------------------------------------
method hasNextPage() as logical class ControlIntegratedProvider
return ::nRecnoF < ::nTotalRows .and. ::nTotalRows > 0

//-------------------------------------------------------------------
/*/{Protheus.doc} setPageRangeByStep
    Seta a paginação conforme step

    @param lFirst Indica se é a primeira chamada

    @author Renan Gremes
    @since 10/09/2025
    @version 12.1.2310
/*/ 
//-------------------------------------------------------------------
method setPageRangeByStep(lFirst as logical) class ControlIntegratedProvider
    local nStepAux as numeric

    default lFirst := .F.
    
    if lFirst .or. !self:lAppend
        nStepAux := 0 //Se for a primeira chamada ou ainda não appendou nada no objeto, trás apenas 1 registro
    else
        nStepAux := ::nStep-1 //Aqui faz -1 para garantir que não vai trazer registros duplicados, pois a página inicial soma +1
    endif

    ::nRecnoI := iif(::nLastRowPage > 0, ::nLastRowPage, ::nRecnoF)+1
    ::nRecnoF := iif(::nRecnoI+nStepAux < ::nTotalRows .or. ::nTotalRows == 0, ::nRecnoI+nStepAux, ::nTotalRows)
    ::nLastRowPage := 0 //Reseta o contador de linhas da página
return
