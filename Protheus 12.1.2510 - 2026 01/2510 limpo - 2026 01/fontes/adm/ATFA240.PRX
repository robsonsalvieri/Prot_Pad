/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³  DATA  ³ BOPS ³Program.³					ALTERACAO				  ³±±
±±ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³29.03.99³      ³Alice   ³ Desabilitar o cria automatico no windows e   ³±±
±±³        ³      ³        ³ na classificacao do 2§ ou proximo aRotina ini³±±
±±³        ³      ³        ³cializar o arotina com 3 (Inclusao).          ³±±
±±³20.04.99³      ³Alice   ³ Alteracao de macro (PROTHEUS).               ³±±
±±³16.11.99³      ³Alice   ³ Alteracao na passagem de parametro no atfmod3³±±
±±³22.12.99³      ³Pilar   ³ Retirar chamada do Windows					  ³±±
±±ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
#Include "ATFA240.CH"
#INCLUDE "Protheus.ch"
#Include "FWLIBVERSION.CH"

#define Confirma 1
#define Redigita 2
#define Abandona 3

//********************************
// Controle de multiplas moedas  *
//********************************
Static lMultMoed := .T.

//Variavel de controle para evitar a rotina chamar novamente a tela de classificação após operação
Static __lMostraTela	:= .T.

//Metricas
Static __lMetric	:= FwLibVersion() >= "20210517" .And. GetSrvVersion() >= "19.3.0.6" //Metricas apenas em Lib a partir de 20210517 e Binario 19.3.0.6
Static oMrkBrowse	

Static __cProcPrinc  	:= "ATFA240"
Static _oATFA0240
Static oQueryQry	:= NIL
Static __aCTBEnt 	:= {}
Static __lEntAdd    := .F. //Vejo apenas nesse campo para identificar se o wizard dos campos foi executado																								  

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ ATFA240    ³ Autor ³ Alice                 ³ Data ³ 27/01/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Classificacao de Bens                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Sigaatf                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ATFA240(nPosArot, lAutomato)
LOCAL cFilEsp		:= ""
LOCAL cAlias		:= "SN1"
Local lBmContr      := IIf(SN1->(FieldPos("N1_BMCONTR"))>0,.T., .F.) 

Private aRotina := MenuDef()
Private aPos:= {  8,  4, 11, 74 }
Private nOriginal  := 0
Private cMoedaAtf := GetMV("MV_ATFMOED")
Private cFilter    := Nil

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define o cabecalho da tela de atualizacoes                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private cCadastro := STR0004 		//"Classifica‡„o de Ativos Imobilizados"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Vari veis para filtro do browse ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private aIndexFil	:= {}
Private bFiltraBrw
Private cFilPad		:= ""

Default nPosArot	:= 0 //Variável criada para teste de automação
Default lAutomato	:= .F. //Variável criada para teste de automação

__aCTBEnt   := CTBEntArr()
__lEntAdd	:= SN3->(FieldPos("N3_EC05DB")) > 0										 
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ativa tecla F12 para ativar parametros de lan‡amentos contab.             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

SetKey( VK_F12, { || pergunte("AFA240",.T.)} )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega as perguntas selecionadas                                         ³
//³ mv_par01 - Se mostra ou n„o os lan‡amentos cont beis                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Pergunte("AFA240",.F.)

ATFXKERNEL()

//PONTO DE ENTRADA - FILBROWSE
cFilPad := ".T."
IF ExistBlock("AF240BRW")
	cFilEsp := ExecBlock("AF240BRW",.F.,.F.,cFilPad)
	cFilPad	:= IIF(ValType(cFilEsp) == "C",cFilEsp,cFilPad)
ENDIF

//PONTO DE ENTRADA - MBROWSE
If lBmContr	
	cFilter := " N1_BMCONTR = ' ' "
EndIf
IF ExistBlock("AF240BRT")
	cFilter :=ExecBlock("AF240BRT",.F.,.F.,cFilter)
	cFilter :=IIF(ValType(cFilter) == "C",cFilter,Nil)
ENDIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Endere‡a a fun‡„o de BROWSE ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAutomato .And. nPosArot > 0 //Se for chamada por testes de automação
	DbSelectArea("SN1")
	bBlock := &("{|a,b,c,d| " + aRotina[nPosArot,2] + "(a,b,c,d)}") //Pega a função desejada para automação a partir do Menudef (aRotina)
	Eval (bBlock,cAlias,,3,lAutomato)
Else
	mBrowse( 6, 1,22,75,"SN1",,,,,, Af240Legenda(cAlias),,,,,,,,cFilter)
EndIf	

lClassifica := .F.
SetKey(VK_F12, { || Verdade() } )

If _oATFA0240 <> Nil
	_oATFA0240:Delete()
	_oATFA0240 := Nil
Endif

Return
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ af240Class ³ Autor ³ Alice                 ³ Data ³ 27/01/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Classificacao de Bens                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Sigaatf                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function af240Class( cAlias,nReg,nOpc, lAutomato )
Local nOpca		:= 0
Local cCodAnt		:= SN1->N1_CBASE
Local cItemAnt		:= SN1->N1_ITEM
Local dDataBloq := GetNewPar("MV_ATFBLQM",CTOD(""))
Local cChaveSNN := ""
Local aRetAuto := {} //Array a ser utilizado nos testes de automação
Local aRegAC9	:= {}
Local ny		:= 0

Default lAutomato := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Evita a chamada da tela após a operação³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If !__lMostraTela
	__lMostraTela := .T.
	Return(.T.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Salva a integridade dos campos de Bancos de Dados            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cAlias)
IF Reccount() == 0
	Return (.T.)
EndIf

If lAutomato
	If FindFunction("GetParAuto")
		aRetAuto	:= GetParAuto("ATFA240TestCase")
		cAutBase	:= aRetAuto[1][2][2] //Código do Ativo 
		cAutItem	:= aRetAuto[1][3][2] //Item do Ativo 
		nOpca	:= 3
	EndIf
	
	DbSelectArea("SN1")
	DbSetOrder( 1 )
	DbSeek(xFilial("SN1")+cAutBase+cAutItem)
	
EndIf

IF SN1->N1_FILIAL != xFilial("SN1")
	Help(" ",1,"A000FI")
	Return (.T.)
Endif

If !Empty(dDataBloq) .AND. (SN1->N1_AQUISIC <= dDataBloq)
	HELP(" ",1,"AF240BLQM",,STR0015 + DTOC(dDataBloq) ,1,0)    //"A data de aquisição do bem é igual ou menor que a data de bloqueio de movimentação : "
	Return (.T.)
Endif

//Validacao para o bloquei do proceco
If !CtbValiDt(,SN1->N1_AQUISIC  ,,,,{"ATF001"},)
	Return (.T.)
EndIf

If SN1->N1_STATUS $ "2|3"
	Help(" ",1,"AF240BLOQ")   //Este bem esta bloqueado, nao poder sofrer baixas.
	Return (.T.)
EndIf

If Af240JaClas()
	Help(" ",1,"AF240CLASS")
	Return .T.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³  Verifica se o registro n„o est  em uso por outra esta‡„o. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !SoftLock("SN1")
	Return .T.
Endif

If !AtfVldMoed(cMoedaAtf)
	Help(" ",1,"ATFVLDMOED",,STR0037,1,0)//"Parâmetro MV_ATFMOED configurado incorretamente"
	Return .T.
EndIf

If !lAutomato
	Pergunte("AFA012",.f.)	
	SaveInter()	
	aRotina := GetRotAux()	
	nOpca := FWExecView(STR0006, 'ATFA012', 4, /*oDlg*/, { || .T. } )
	RestInter()
Else
	MsExecAuto({|a,b,c| ATFA012(a,b,c)},aRetAuto[1]/*aCab*/, aRetAuto[2]/*aItens*/, 4)
EndIf

// Atualiza o codigo do bem no Planejamento
IF nOpca == 0
	dbSelectArea("SNN")
	cChaveSNN:=IndexKey(2)
	If AllTrim(cChaveSNN) == "NN_FILIAL+NN_CODEFTV+NN_ITMEFTV+NN_CODIGO+NN_ITEM"
		dbSetOrder( 2 )
		If dbSeek(xFilial("SNN")+cCodAnt)
			RecLock("SNN",.F.)
			SNN->NN_CODEFTV:=SN1->N1_CBASE
			SNN->NN_ITMEFTV:=SN1->N1_ITEM
			MsUnlock()
		EndIF
	EndIf
EndIf

// Atualiza o codigo do bem no Conhecimento (AC9)
If cCodAnt+cItemAnt <> SN1->N1_CBASE+SN1->N1_ITEM

	dbSelectarea("AC9")
	AC9->( DbSetOrder( 2 ) ) //AC9_FILIAL + AC9_ENTIDA + AC9_FILENT + AC9_CODENT + AC9_CODOBJ

	If AC9->(DbSeek(xFilial("AC9")+'SN1'+xFilial("SN1")+cCodAnt+cItemAnt) ) 
		
		While AC9->(!EOF() .And. AC9_FILIAL == XFILIAL("AC9") .And. AC9_ENTIDA == 'SN1' .And. AC9_FILENT == xFilial("SN1") .And. Alltrim(AC9_CODENT) == cCodAnt+cItemAnt )
			aAdd(aRegAC9, AC9->( Recno() ) )
			AC9->(dbSkip())		
		Enddo
		
		For ny := 1 to len(aRegAC9)
			AC9->( DbGoto(aRegAC9[ny]) )
			RecLock("AC9",.F.)
			AC9->AC9_CODENT := SN1->N1_CBASE+SN1->N1_ITEM
			MsUnlock()
		Next
	
	Endif
EndIF

//Metrica de quantidade de bens que são classificados que contém ciap
If __lMetric .And. !Empty(SN1->N1_CODCIAP)
	ATF240Metrics("01" /*cEvent*/,/*nStart*/, "001" /*cSubEvent*/, Alltrim(ProcName()) /*cSubRoutine*/)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Este unlock libera o softlock acima deste While. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectarea("SN1")
MsUnlock()
IF nOpca == 0
	If ExistBlock("AF240CLA")
		ExecBlock("AF240CLA",.F.,.F.)
	Endif
Endif

MBrChgLoop(.F.) //Desabilita a chamada da tela de inclusão novamente.

Return nOpca

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Af240Base ³ Autor ³ Vin¡cius Barreira     ³ Data ³ 14/09/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se o novo c¢digo ‚ v lido                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ af240Base()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAATF                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Af240Base(cBasePara,cBaseDe)
If Empty( cBasePara )
	HELP(" ",1,"AFA130Vazi")
	Return .F.
ElseIf cBasePara == cBaseDe
	HELP(" ",1,"AFA130Igua")
	Return .F.
Endif
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Af240Legenda³ Autor ³ Wagner Mobile Costa ³ Data ³ 19.11.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria uma janela contendo a legenda da mBrowse ou retorna a ³±±
±±³          ³ para o BROWSE                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Atfa240                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Af240Legenda(cAlias, nReg)

Local aLegenda := 	{ 	{"BR_PRETO", STR0011 },; //"Bem nao Classificado"
{"BR_VERDE", STR0012 },; //"Bem Classificado"
{"BR_VERMELHO", STR0013 } } //"Bem totalmente baixado"

Local uRetorno := .T.

If nReg = Nil	// Chamada direta da funcao onde nao passa, via menu Recno eh passado
	uRetorno := {}
	Aadd(uRetorno, { '! Empty(N1_BAIXA)' 	, aLegenda[3][1] } )	//Não Classificado
	Aadd(uRetorno, { 'Af240JaClas()'		, aLegenda[2][1] } )	//Classificado
	Aadd(uRetorno, { '.T.'					, aLegenda[1][1] } )
Else
	BrwLegenda(cCadastro, STR0010, aLegenda) //"Legenda"
Endif

Return uRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Af240JaClas ³ Autor ³ Wagner Mobile Costa ³ Data ³ 19.11.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna se o bem ja foi ou nao classificado                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Atfa240                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Af240JaClas()
Local lRet     := .F.
Local aArea    := GetArea()
Local aAreaSN1 := SN1->(GetArea())
Local aAreaSN3 := SN3->(GetArea())

DbSelectArea("SN3")
SN3->(dbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
SN3->(MsSeek(SN1->(N1_FILIAL+N1_CBASE+SN1->N1_ITEM)))

If Alltrim(SN1->N1_ORIGEM) == "ATFA310"
	If SN1->N1_STATUS != "0" // Pendente de Classificação
		lRet := .T.
	EndIf
Else
	If SN1->N1_STATUS # "0" 	// Pendente de Classificação  			//-- JRJ - 20170922
		While SN1->N1_FILIAL+SN1->N1_CBASE+SN1->N1_ITEM == SN3->(N3_FILIAL+N3_CBASE+N3_ITEM) .and. SN3->(!Eof())
			If Val( SN3->N3_BAIXA ) # 0 .or. !Empty(SN3->N3_CCONTAB)
				lRet := .T.
				Exit
			EndIf
			SN3->(dbSkip())
		Enddo
	EndIf																//-- JRJ - 20170922
EndIf


RestArea(aAreaSN3)
RestArea(aAreaSN1)
RestArea(aArea)
Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Ana Paula N. Silva     ³ Data ³29/11/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transa‡„o a ser efetuada:                        ³±±
±±³          ³		1 - Pesquisa e Posiciona em um Banco de Dados     ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³    6 - Acessa cadastro de Bens de Terceiro                 ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef()
Local nX		:= 0
Local aAF240BUT := {}
Local aRotina 	:= {{ STR0001, "AxPesqui"  		, 0 , 1 , ,.F.},;     //"Pesquisar"
					{ STR0002, "VIEWDEF.ATFA012", 0 , 2},;        		//"Visualizar"
					{ STR0003, "AF240Class"		, 0 , 3, 43 },;		//"Classificar"
					{ STR0010, "AF240Legenda"	, 0 , 5, ,.F. },;	// "Legenda"
					 {STR0020, "AF240Lote"	    , 0 , 3, ,.F. }}	//"Classificação em Lote",

Aadd(aRotina, { STR0017		, "ATFA320"	, 0, 6, 45 } )	//"Contr. Terceiros"

Aadd(aRotina, { STR0018  , "ATFA321"	, 0, 6, 45 } )	//"Contr.em Terceiros"

Aadd(aRotina, { STR0063  , "af240CancC"	, 0, 6 } )	//"Cancelar Classificação""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ P.E. Utilizado para adicionar botoes ao Menu Principal       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock( "AF240BUT" )
	aAF240BUT := ExecBlock( "AF240BUT", .F., .F., aRotina )
	IF ValType( aAF240BUT ) == "A" .AND. Len( aAF240BUT ) > 0
		For nX := 1 To Len( aAF240BUT )
			aAdd( aRotina, aAF240BUT[ nX ] )
		Next
	ENDIF
Endif

Return(aRotina)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ATF240PRJC   ³Autor ³Rodrigo Gimenes       ³Data³11/11/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se é uma projecao ou compra                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ATF240PRJC()

Local lRetorno := .F.

If !Empty(SN1->N1_STATUS)
	lRetorno := SN1->N1_STATUS == '2' .AND. Alltrim(SN1->N1_ORIGEM) == "ATFA310"
EndIf

Return(lRetorno)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ BemProj      ³Autor ³Rodrigo Gimenes       ³Data³11/11/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se é uma projecao para a Legenda                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function BemProj()

Local lRetorno := .F.

lRetorno := Empty(SN1->N1_BAIXA) .And. !Af240JaClas() .And. ATF240PRJC()


Return(lRetorno)
//-------------------------------------------------------------------
/*/{Protheus.doc}GetRotAux
Cria um menu fake para habilitar a opção de carregar imagem no folder 
FOTO.
O aRotina é restaurado após a execução da View.

@author TOTVS
@since  19/09/2019
@version 12
/*/	
//-------------------------------------------------------------------
Static Function GetRotAux()
Local aRotAux := {{ "", "", 0 , 1},; 
				  { "", "", 0 , 2},; 
				  { "", "", 0 , 3},; 
				  { "", "", 0 , 4},;
				  { "", "", 0 , 5}}
Return aRotAux


/*/{Protheus.doc} ATF012Metrics
	
	ATF012Metrics - Funç?o utilizada para metricas no CTBR400

	@type  Static Function
	@author user
	@since date
	@version version
	@param param, param_type, param_descr
	@return return, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function ATF240Metrics(cEvent, nStart, cSubEvent, cSubRoutine, nQtdReg)

Local cFunBkp	:= ""
Local cFunMet	:= ""

// Local nFim := 0

Local cIdMetric  := ""
Local dDateSend := CtoD("") 
Local nLapTime := 0
Local nTotal := ""

Default cEvent := ""
Default nStart := Seconds() //Caso futuramente exista metrica de tempo medio
Default cSubEvent := ""
Default cSubRoutine := Alltrim(ProcName(1))
Default nQtdReg := 0

//Só capturar metricas se a vers?o da lib for superior a 20210517
If __lMetric .And. !Empty(cEvent)
	
	//grava funname atual na variavel cFunBkp
	cFunBkp := FunName()

	If cEvent == "01" //Evento 01 -  Metrica da quantidade de bens classificados que contém CIAP 

		
		//Evento 01 - Metrica da quantidade de bens classificados que contém CIAP
		If cEvent == "01" 

			If cSubEvent == '001'

				cFunMet := Iif(AllTrim(cFunBkp)=='RPC',"RPCATFA240",cFunBkp)
				SetFunName(cFunMet)

				//atribuicao das variaveis que serao utilizadas pelo FwCustomMetrics
				cSubRoutine := Alltrim(cSubRoutine)			
				cIdMetric  := "ativo-fixo--protheus_classificacao-bem-ciap-qtd_total"
				nTotal := 1 //nTotal					
				dDateSend := LastDay( Date() ) //Date()//
				FWCustomMetrics():SetSumMetric(cSubRoutine, cIdMetric, nTotal, dDateSend, nLapTime)
			EndIf
		EndIf
	EndIf

	//Restaura setfunname a partir da variavel salva cFunBkp
	SetFunName(cFunBkp)
EndIf

Return 

/*{Protheus.doc}AF240Lote
Classificação em lote
@author Mayara Alves da silva
@since 05/08/2015
@version P12
@project Inovação Controladoria
*/
Function AF240Lote( cAlias,nReg,nOpc )
Local cGrupo		:= ""								//Grupo Classificação
Local cCodBas		:= ""								//Codigo Base
Local cItem			:= ""								//Item inicial
Local cNumPla		:= ""								//Numero da Palqueta
Local cAliasMrk		:= "" 								//Alias
Local cMarca		:= "0w"
Local nX			:= 0 								//Variavel do for para criar colunas mark
Local nCols			:= 1
Local aArea			:= GetArea()
Local aAreaSNG		:= SNG->(GetArea())
Local aStru			:= SN1->(DbStruct()) 				//Estrutura da tabela SN1
Local aSize			:= MSADVSIZE()	
Local aColsEdit		:= {}
Local aColumns		:= {}
Local aRotOld		:= aClone(aRotina)
Local oDlgMrk		:= Nil
Local lAglutina		:= .F.
Local lContinua		:= .T.								//Continua função depois das validações
Local lRepetChap	:= Iif(mv_par02 == 1, .T., .F. )	//Salva SX1 -> AFA240 se repete chapa ou n?o
Local bOk 			:= {|| MsgRun(STR0034,"",{|| Iif( AF240LTOK(cAliasMrk,oMrkBrowse,lRepetChap) ,lContinua := AF240LGrv(cAliasMrk,lAglutina,lRepetChap),lContinua:=.F.), Iif( lContinua,(oMrkBrowse:Deactivate(),oDlgMrk:End()),Nil) })}//"Classificação em lote"
Local bCancel		:= {|| oMrkBrowse:Deactivate(),oDlgMrk:End()}
Local lBmContr      := IIf(SN1->(FieldPos("N1_BMCONTR"))>0,.T., .F.) 
Private xAliasAux

aRotina := {}

//Usado para preservar os parametros do pergunt do F12
SaveInter()

If Pergunte("AFA240L", .T.)

	/*-----------Descritivo Perguntas - AFA240L----------*/
	//"mv_par01"	//Código Base De ?
	//"mv_par02"	//Item De ?
	//"mv_par03"	//Código Base Até ?
	//"mv_par04"	//Item Até ?
	//"mv_par05"	//Documento De ?
	//"mv_par06"	//Série De ?
	//"mv_par07"	//Fornecedor De ?
	//"mv_par08"	//Loja  De ?
	//"mv_par09"	//Documento Até ?
	//"mv_par10"	//Série Até ?
	//"mv_par11"	//Fornecedor Até ?
	//"mv_par12"	//Loja  Até ?
	//"mv_par13"	//Produto ?
	//"mv_par14"	//Dt Aquisiç?o de ?
	//"mv_par15"	//Dt Aquisiç?o Até ?
	//"mv_par16"	//Contabiliza On line ?
	//"mv_par17"	//Aglutina Lançamento ?
	//"mv_par18"	//Grupo Classificaç?o ?
	//"mv_par19"	//Incremento Automático ?
	//"mv_par20"	//Código Base ?
	//"mv_par21"	//Item Inicial ?
	//"mv_par22"	//Número da plaqueta Inicial ?
	//"mv_par23"	//Descriç?o ? 
	//"mv_par24" 	//Data de Aquisiç?o ?
	
	//Transforma parametros do tipo Range em expressao ADVPL para ser utilizada no filtro
	MakeSqlExpr("AFA240L")

	//Atribui valores do pergunte
	cGrupo		:= MV_PAR18 //Grupo Classificação
	cCodBas	:= MV_PAR20 //Codigo Base
	cItem		:= MV_PAR21 //Item inicial
	cNumPla	:= MV_PAR22 //Numero da Palqueta
	lAglutina := IIf(MV_PAR17 == 1, .T. , .F.)
	
	If lBmContr
		lContinua	:=	VldCanClas(mv_par01,mv_par02,mv_par03,mv_par04) //Verifica se o bem naa e em construç?o ou outros tipos(futuros realizar nessa mesma funç?o) para abortar programa.
	EndIf
	
	//Valida os parametros
	SNG->(dbSetOrder(1))
	If lContinua .And. Empty(cGrupo)
		Help(" ",1,"AF240GRPEMPTY",, STR0030, 1, 0) //"Codigo do grupo deve estar preenchido."
		lContinua	:= .F.
	Elseif lContinua .And. !SNG->(dbSeek(xFilial("SNG")+cGrupo))
		lContinua	:= .F.
		Help(" ",1,"AF240GRP",, STR0021, 1, 0) //"O grupo da classificação não existe."
	EndIf

	If lContinua .And. Empty(cCodBas)
		lContinua	:= .F.
		Help(" ",1,"AF240BEM",, STR0022, 1, 0) //"O Código Base deve estar preenchido."
	EndIf

	If lContinua .And. Empty(cItem)
		lContinua	:= .F.
		Help(" ",1,"AF240ITE",, STR0023, 1, 0) //"O Item Inicial deve estar preenchido."
	EndIf
	
	If lContinua .And. Empty(cNumPla) .And. !lRepetChap
		lContinua	:= .F.
		Help(" ",1,"AF240PLA",, STR0024, 1, 0) //"O Número da plaqueta deve estar preenchido."
	EndIf
	
	If lContinua .And. !Empty(cNumPla)
		dbSelectArea("SN1")
		SN1->(dbSetOrder(2))
		If SN1->(dbSeek(xFilial("SN1")+cNumPla)) .And. !lRepetChap
			lContinua	:= .F.
			Help(" ",1,"AF240PLA",, STR0029, 1, 0) //"O Número da plaqueta já existente"
		EndIf
		dbSelectArea("SN1")
		SN1->(dbSetOrder(1))
	EndIf 

	If lContinua

		cAliasMrk	:= A240ExcQr(lRepetChap)
		xAliasAux	:= cAliasMrk
 		//Define as colunas a serem apresentadas na markbrowse
		For nX := 1 To Len(aStru)
			If	aStru[nX][1] $ "N1_CODBAR|N1_CBASE|N1_ITEM|N1_DESCRIC|N1_PRODUTO|N1_AQUISIC|N1_QUANTD|N1_FORNEC|N1_LOJA|N1_NSERIE|N1_NFISCAL|N1_CHAPA|N1_GRUPO"
				//Pega o valor da coluna
				nCols += 1

				AAdd(aColumns,FWBrwColumn():New())
				aColumns[Len(aColumns)]:SetData( &("{||"+aStru[nX][1]+"}") )
				aColumns[Len(aColumns)]:SetTitle(RetTitle(aStru[nX][1]))
				aColumns[Len(aColumns)]:SetSize(aStru[nX][3])
				aColumns[Len(aColumns)]:SetDecimal(aStru[nX][4])
				aColumns[Len(aColumns)]:SetPicture(PesqPict("SN1",aStru[nX][1]))
		
				If aStru[nX][1] $ "N1_CODBAR|N1_CBASE|N1_ITEM|N1_DESCRIC|N1_GRUPO|N1_CHAPA"
					aColumns[Len(aColumns)]:SetEdit(.T.)
					aColumns[Len(aColumns)]:SetReadVar("(xAliasAux)->"+aStru[nX][1])
					//Validação de campo
					If aStru[nX][1] = "N1_GRUPO"
 						aColumns[Len(aColumns)]:SetValid({||ExistCpo("SNG")})
					Endif
					If aStru[nX][1] = "N1_CBASE"
 						aColumns[Len(aColumns)]:SetValid({|| Af240Chave((xAliasAux)->N1_CBASE, (xAliasAux)->N1_ITEM) .And. FreeForUse("SN1",(xAliasAux)->N1_CBASE) })
					Endif
					If aStru[nX][1] = "N1_ITEM"
						aColumns[Len(aColumns)]:SetValid({|| Af240Chave((xAliasAux)->N1_CBASE, (xAliasAux)->N1_ITEM)})
					Endif
					If aStru[nX][1] = "N1_DESCRIC"
						aColumns[Len(aColumns)]:SetPicture("@!") 
					Endif
					If aStru[nX][1] = "N1_CHAPA"
						aColumns[Len(aColumns)]:SetValid({|| AF240CHAPA(((xAliasAux)->N1_CHAPA), lRepetChap) })
					Endif
					//Inclui array para guardar colunas editaveis
					aAdd(aColsEdit, nCols )
				EndIf
		
				//Coloca consulta padrão no grupo de bens
				If aStru[nX][1] $ "N1_GRUPO"
					aColumns[Len(aColumns)]:SetF3("SNG")
				EndIf
			EndIf
		Next nX
			
 		If !(cAliasMrk)->(Eof())
							
				//DEFINE MSDIALOG oDlg TITLE STR0017 From 300,0 to 800,800 OF oMainWnd PIXEL //Situações de Cobrança
				//Tela de digitacao dos dados dos titulos a serem gerados pela liquidacao
			
			DEFINE MSDIALOG oDlgMrk TITLE STR0020 PIXEL FROM aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL //"Classificação em Lote"
			oDlgMrk:lMaximized := .T.

			oMrkBrowse:= FWMarkBrowse():New()
			oMrkBrowse:SetMark(cMarca, cAliasMrk, "N1_OK")
				
				
			(cAliasMrk)->(DbGoTop())
			While (cAliasMrk)->(!Eof())
				RecLock(cAliasMrk,.F.)
				(cAliasMrk)->N1_OK :=  oMrkBrowse:Mark()
				(cAliasMrk)->(MsUnlock())
				(cAliasMrk)->(DbSkip())
			End
			(cAliasMrk)->(DbGoTop())			
					
			oMrkBrowse:SetFieldMark("N1_OK")
			oMrkBrowse:SetOwner(oDlgMrk)
			oMrkBrowse:SetAlias(cAliasMrk)
			oMrkBrowse:SetCustomMarkRec({||EditaCell(oMrkBrowse,aColsEdit)})
			oMrkBrowse:oBrowse:SetEditCell(.T.)
			oMrkBrowse:SetMenuDef("")
			oMrkBrowse:AddButton(STR0035,bOk,,2) //Confirmar
			oMrkBrowse:AddButton(STR0036,bCancel,,2 ) //Cancelar
			oMrkBrowse:bMark	:= {||}
			oMrkBrowse:bAllMark	:= {|| AF240CMark(oMrkBrowse,cAliasMrk)}
			oMrkBrowse:SetDescription("")
			oMrkBrowse:SetColumns(aColumns)
			oMrkBrowse:DisableFilter()
			oMrkBrowse:DisableConfig()
			oMrkBrowse:Activate()
			ACTIVATE MSDIALOG oDlgMrk CENTERED

		Else	
	
			Help(" ",1,"AF240BEM",, STR0025, 1, 0) //"Não a há bens a ser classificado."
	
		Endif
		
	EndIf
EndIf

RestInter()
RestArea(aAreaSNG)
RestArea(aArea)
aRotina := aClone(aRotOld)

Return


/*{Protheus.doc}A240ExcQr
REALIZA FILRTO DO MARK
@author Mayara Alves da silva
@since 05/08/2015
@version P12
@project Inovação Controladoria
*/
Static Function A240ExcQr(lRepetChap)
Local cQuery	:= ""
Local cArqTrab	:= ""
Local cCampo	:= ""
Local nZ		:= 0
Local nPosCpo	:= 0
Local aArea		:= GetArea()
Local aStru		:= SN1->(DbStruct()) //Estrutura da tabela SN1
//Variaveis do pergunte - AFA240L
Local cBaseDe	:= PadR(MV_PAR01, Len(SN1->N1_CBASE))
Local cItemDe	:= PadR(MV_PAR02, Len(SN1->N1_ITEM))
Local cBaseAte	:= PadR(MV_PAR03, Len(SN1->N1_CBASE))
Local cItemAte	:= PadR(MV_PAR04, Len(SN1->N1_ITEM))
Local cNotaDe	:= PadR(MV_PAR05, Len(SN1->N1_NFISCAL))
Local cSeriDe	:= PadR(MV_PAR06, Len(SN1->N1_NSERIE))
Local cFornDe	:= PadR(MV_PAR07, Len(SN1->N1_FORNEC))
Local cLojaDe	:= PadR(MV_PAR08, Len(SN1->N1_LOJA))
Local cNotaAte	:= PadR(MV_PAR09, Len(SN1->N1_NFISCAL))
Local cSeriAte	:= PadR(MV_PAR10, Len(SN1->N1_NSERIE))
Local cFornAte	:= PadR(MV_PAR11, Len(SN1->N1_FORNEC))
Local cLojaAte	:= PadR(MV_PAR12, Len(SN1->N1_LOJA ))
Local cProd		:= MV_PAR13
Local cAquiDe	:= DTOS(MV_PAR14)
Local cAquiAte	:= DTOS(MV_PAR15)

cQuery += "SELECT "
cQuery += "  N1_CODBAR, N1_CBASE, N1_ITEM, N1_PRODUTO, N1_QUANTD, "
cQuery += "  N1_FORNEC, N1_LOJA, N1_NSERIE, N1_NFISCAL, N1_CHAPA, N1_OK, "
cQuery += IIf( Empty(MV_PAR23), " N1_DESCRIC, ", " '" + MV_PAR23 + "' N1_DESCRIC, ")
cQuery += IIf( Empty(MV_PAR24), " '" + DtoS(dDataBase) + "' N1_AQUISIC, ", " '" + DtoS(MV_PAR24) + "' N1_AQUISIC, ")
cQuery += " '" + MV_PAR18 + "' N1_GRUPO, "		
cQuery += " SN1.R_E_C_N_O_ NRECNO "
cQuery += "  FROM "+	RetSqlName("SN1") + " SN1 "
cQuery += " WHERE N1_FILIAL = '"	+ XFilial("SN1")+ "' "
cQuery += " AND N1_CBASE||N1_ITEM BETWEEN '"     +cBaseDe+cItemDe+"' AND '"+cBaseAte+cItemAte+"' "
cQuery += " AND N1_FORNEC||N1_LOJA BETWEEN '"    +cFornDe+cLojaDe+"' AND '"+cFornAte+cLojaAte+" ' "
cQuery += " AND N1_NFISCAL||N1_NSERIE BETWEEN '" +cNotaDe+cSeriDe+"' AND '"+cNotaAte+cSeriAte+" ' "

If !Empty(cProd) //Produto  - tipo range
	cQuery += " AND " + cProd + CRLF
EndIf
cQuery += " AND N1_AQUISIC BETWEEN '"+cAquiDe+"' AND '"+cAquiAte+"'  " + CRLF
cQuery += " AND N1_STATUS = '0' "
cQuery += " AND SN1.D_E_L_E_T_ = ' ' "
cQuery := ChangeQuery(cQuery)

cChave		:= SN1->(IndexKey())

Aadd(aStru, {"NRECNO","N",10,0})
cArqTrab := CriaTrab(,.F.) // Nome do alias temporario

If _oATFA0240 <> Nil
	_oATFA0240:Delete()
	_oATFA0240 := Nil
Endif

_oATFA0240 := FWTemporaryTable():New( cArqTrab )
_oATFA0240:SetFields(aStru)
_oATFA0240:Create()

DbUseArea(.T., "TOPCONN", TcGenQry(,, cQuery), "AFLOTE240")

While AFLOTE240->( !Eof() )
	
	dbSelectArea(cArqTrab)
	Reclock(cArqTrab,.T.)
	
	For nZ:=1 to len(aStru)
		cCampo	:=	AFLOTE240->(FieldName(nZ))
		nPosCpo	:=	(cArqTrab)->(FieldPos(cCampo))

		If nPosCpo > 0 
			( cArqTrab )->( FieldPut( nPosCpo, ( AFLOTE240->( FieldGet(nZ) ) ) ) )
		EndIf

	Next
	
	( cArqTrab )->( MsUnlock() )
	AFLOTE240->( DbSkip() )

EndDo

AFLOTE240->( DbCloseArea() )
DbSelectArea(cArqTrab)

// IndRegua (cArqTrab,cArqTrab,cChave,,,"STR0092"+"...")	//"Selecionando Registros"

//gera codigo, item e plaqueta apartir do paramentro
AFA240ATUTAB(@cArqTrab,lRepetChap)

RestArea(aArea)

Return (cArqTrab)



/*{Protheus.doc}EditaCell
Posiciona nas colunas que poderam ser editadas e faz o tratamento para a edição.
@author Mayara Alves da silva
@since 05/08/2015
@param oMark	- objeto mark
@param aColsEdit	- com as colunas q podem ser editadas.
@version P12
@project Inovação Controladoria
*/
Static function EditaCell(oMark,aColsEdit)
Local lRet:= .T.
Default oMark := Nil
Default aColsEdit := {}

If aScan(aColsEdit,oMark:oBrowse:ColPos()) > 0
		RecLock(oMark:Alias(),.F.)
		oMark:oBrowse:EditCell(oMark:oBrowse:ColPos())
		(oMark:Alias())->(MsUnLock())
Else
	
	RecLock(oMark:Alias(),.F.)
	If (oMark:Alias())->N1_OK != oMark:Mark()
		(oMark:Alias())->N1_OK  := oMark:Mark()
	Else
		(oMark:Alias())->N1_OK  := "  "
	Endif
	(oMark:Alias())->(MsUnLock())

Endif

Return lRet

/*{Protheus.doc}AF240LGrv
Faz a classificação em lote via excauto do ATFA012	
@author Mayara Alves da silva
@since 05/08/2015
@param cArqTrab	- Tabela temporaria
@param lAglutina	- Aglutina sim ou não
@version P12
@project Inovação Controladoria
*/
Static Function AF240LGrv(cAliasMrk,lAglutina,lRepetChap)
Local cArquivo			:= ""
Local cId				:= ""
Local cMensIni			:= STR0020 + " : "  // "Classificação em Lote: "
Local nY				:= 0
Local nHdlPrv			:= 0
Local nTotal			:= 0
Local aCab				:= {}
Local aItens			:= {}
Local aParam			:= {}
Local aLog				:= {}
Local aArea				:= GetArea() 
Local aAreaSN1			:= SN1->(GetArea())
Local aCtb				:= {}
Local lErro				:= .F.
Local lRet 				:= .T.
Local lContab 			:= IIf(MV_PAR16 == 1, .T. , .F.) //Contabilização on line sim ou não
Local dDtBaseAnt		:= dDataBase
Local dAquisic			:= MV_PAR24

Private lMsErroAuto 	:= .F.
Private lMsHelpAuto 	:= .T.
Private lAutoErrNoFile 	:= .T.

Default cAliasMrk		:= ""
Default lAglutina 		:= .F.

//Começa o log de processamento
ProcLogIni( {},__cProcPrinc,STR0020,@cId ) //	"Classificação em Lote "
	
//Abre o arquivo de contabilização 
cLote		:= LoteCont("ATF")
lLancPad	:= VerPadrao('801')
		
//Inicializa contabilizacao
If nHdlPrv <= 0 .And. lLancPad .And. lContab
	If !Empty(MV_PAR24)
		dDataBase	:=	MV_PAR24
	EndIf		 
	nHdlPrv := HeadProva(cLote,"ATFA240",Substr(cUsername,1,6),@cArquivo)
	If !Empty(MV_PAR24)
		dDataBase	:=	dDtBaseAnt
	EndIf	
EndIf

aAdd( aParam, {"MV_PAR01", 2			} ) //Mostra lancamento		(1-Sim/2-Nao)
aAdd( aParam, {"MV_PAR02", IIf(lRepetChap,1,2)			} ) //Repete Chapa			(1-Sim/2-Nao)
aAdd( aParam, {"MV_PAR03", 2			} ) //Copiar valores			(1-Sim/2-Nao)
AAdd( aParam, {"MV_PAR05", MV_PAR16	} ) //Contabilizar Online	(1-Sim/2-Nao)
AAdd( aParam, {"MV_PAR06", MV_PAR17	} ) //Aglutina Lançamentos	(1-Sim/2-Nao)

(cAliasMrk)->(dbGoTop())

While (cAliasMrk)->(!Eof())
	If !Empty((cAliasMrk)->N1_OK)
		
		//Carrega aCab para o excauto
		AAdd(aCab,{"N1_CBASE"  	, (cAliasMrk)->N1_CBASE		,NIL})
		AAdd(aCab,{"N1_ITEM"   	, (cAliasMrk)->N1_ITEM		,NIL})
		AAdd(aCab,{"N1_DESCRIC"	, (cAliasMrk)->N1_DESCRIC	,NIL})
		AAdd(aCab,{"N1_CHAPA" 	, (cAliasMrk)->N1_CHAPA	,NIL})
		AAdd(aCab,{"N1_GRUPO" 	, (cAliasMrk)->N1_GRUPO		,NIL})
		AAdd(aCab,{"N1_CODBAR" 	, (cAliasMrk)->N1_CODBAR		,NIL})
		If Empty(MV_PAR24)
			AAdd(aCab,{"N1_AQUISIC" 	, dDataBase		,NIL})
			AAdd(aCab,{"N1_INIAVP" 		, dDataBase		,NIL})
		Else
			AAdd(aCab,{"N1_AQUISIC" 	, dAquisic		,NIL})
			AAdd(aCab,{"N1_INIAVP" 		, dAquisic		,NIL})		
		Endif
		
		AAdd(aCab,{"N1_STATUS" 	, "1"			,NIL})
		
		aItens := {}
		//-- Preenche itens
		If Empty(MV_PAR24)
			AAdd(aItens,{{"N3_DINDEPR" , RetDinDepr(dDataBase) ,NIL},;
			{"N3_AQUISIC" , dDataBase ,NIL}})
		Else
			AAdd(aItens,{{"N3_DINDEPR" , RetDinDepr(dAquisic) ,NIL},;
			{"N3_AQUISIC" , dAquisic ,NIL}})						
		EndIf
	
		//Posiciona no registro gravado na SN1 para executar o excauto		
		SN1->(DbGoto((cAliasMrk)->NRECNO))
		
		//ATFA012(xCab,xItens,nOpcAuto,aParam,aCtb)
  		MSExecAuto({|x,y,z,w,a| Atfa012(x,y,z,w,a)},aCab,aItens,4,aParam,aCtb)
		
		If lMsErroAuto
			aLog := GETAUTOGRLOG()
			lMsErroAuto := .F.
			lErro := .T.

			cDetalhe := ""
			For nY := 1 to Len(aLog)
				cDetalhe += aLog[nY]
			Next nY
			
			ProcLogAtu("ERRO",cMensIni,cDetalhe,,.T. )
		Else
		
			If lLancPad .And. nHdlPrv > 0
				If !Empty(MV_PAR24)
					dDataBase	:=	MV_PAR24
				EndIf		 
			
				dbSelectArea("SN3")
				SN3->(dbSetOrder(1))
				If SN3->(dbSeek(xFilial("SN3")+(cAliasMrk)->N1_CBASE+(cAliasMrk)->N1_ITEM))
					While SN3->(!Eof()) .And. (xFilial("SN3")+(cAliasMrk)->N1_CBASE+(cAliasMrk)->N1_ITEM == SN3->N3_FILIAL+SN3->N3_CBASE+SN3->N3_ITEM)
						nTotal += DetProva(nHdlPrv, "801", "ATFA240", cLote)
						SN3->(dbSkip())
					End
				EndIf
				If !Empty(MV_PAR24)
					dDataBase	:=	dDtBaseAnt
				EndIf	 
				
			EndIf
		
		EndIf
		
		aCab := {}
	EndIf

	(cAliasMrk)->(dbSkip())
End

If lLancPad .And. nHdlPrv > 0 .And. nTotal > 0
	If !Empty(MV_PAR24)
		dDataBase	:=	MV_PAR24
	EndIf		 
			
	RodaProva(nHdlPrv,nTotal)
	cA100Incl(cArquivo, nHdlPrv, 2, cLote, .T., lAglutina)
	
	If !Empty(MV_PAR24)
		dDataBase	:= dDtBaseAnt
	EndIf	
Endif

ProcLogAtu("FIM",cMensIni,,,.T.)

//mostra o log
ProcLogView(,__cProcPrinc)
RestArea(aAreaSN1)
RestArea(aArea)

Return lRet


/*{Protheus.doc}AFA240ATUTAB
Atualiza codigo do bem, item e plaqueta da tabela temporaria 
apartir do pergunte
@author Mayara Alves da silva
@since 05/08/2015
@param cArqTrab	- Tabela temporaria
@version P12
@project Inovação Controladoria
*/
Static Function AFA240ATUTAB(cArqTrab As Character,lRepetChap As Logical) As Character
Local nIncre	As Numeric
Local cCodIni	As Character
Local cItemIn	As Character
Local cPlacta	As Character
Local lCodB		As Logical
Local aArea		As Array
Local aAreaSn1	As Array

nIncre		:= MV_PAR19
cCodIni		:= PadR(MV_PAR20,Len(SN1->N1_CBASE))
cItemIn		:= PadR(MV_PAR21,Len(SN1->N1_ITEM))
cPlacta		:= PadR(MV_PAR22,Len(SN1->N1_CHAPA))
lCodB		:= Iif(nIncre == 1, .T. ,.F. ) //1 - Codigo 2 - Item
aArea		:= GetArea()
aAreaSn1	:= SN1->(GetArea())


Default cArqTrab	:= ""

(cArqTrab)->(dbGoTop())

While (cArqTrab)->(!Eof())
	dbselectarea("SN1")
	dbSetOrder(1)//N1_FILIAL+N1_CBASE+N1_ITEM
	If lCodB
		RecLock(cArqTrab,.F.)

		cCodIni := fBscCod(cCodIni,cItemIn)

		(cArqTrab)->N1_CBASE := alltrim(cCodIni)

		If !Empty((cArqTrab)->N1_ITEM)
			(cArqTrab)->N1_ITEM	:= cItemIn
		Endif
			
		(cArqTrab)->N1_CHAPA := cPlacta
			
		If !lRepetChap
			cPlacta:= SOMA1(alltrim(cPlacta),Len(SN1->N1_CHAPA))
		EndIf

		cCodIni := SOMA1(alltrim(cCodIni),Len(SN1->N1_CBASE))
		(cArqTrab)->(MsUnLock())
	Else
		RecLock(cArqTrab,.F.)
		
		If !Empty((cArqTrab)->N1_CBASE)
			(cArqTrab)->N1_CBASE:= cCodIni
		Endif

		cItemIn := fBscIt(cCodIni,cItemIn)

		(cArqTrab)->N1_ITEM	:= cItemIn	
		(cArqTrab)->N1_CHAPA := cPlacta

		If !lRepetChap
			cPlacta:= SOMA1(Alltrim(cPlacta),Len(SN1->N1_CHAPA))
		EndIf

		cItemIn := SOMA1(Alltrim(cItemIn),Len(SN1->N1_ITEM))
		(cArqTrab)->(MsUnLock())
	Endif
	(cArqTrab)->(dbSkip())
EndDo

If (cArqTrab)->(Eof())
	(cArqTrab)->(dbGoTop())
EndIf

RestArea(aAreaSN1)
RestArea(aArea)
Return 

/*{Protheus.doc}AF240LTOK
Valida codigo e itens duplicados
@author Mayara Alves da silva
@since 12/08/2015
@param cAliasMrk	- Tabela temporaria
@version P12
@project Inovação Controladoria
*/
Static Function AF240LTOK(cAliasMrk,oMrkBrowse,lRepetChap)
Local lRet := .T.
Local aBens := {} //Array com os bens e os itens
Local aArea := GetArea()
Local aAreaSN1    := SN1->(GetArea())
Local nMark	:= 0 //Intes marcados
 Local nX   := 1

Default cAliasMrk	:= ""
 
(cAliasMrk)->(dbGoTop())
 
dbSelectArea("SN1")
SN1->(dbSetOrder(1))
           
While (cAliasMrk)->(!Eof())
    If !Empty((cAliasMrk)->N1_OK)
		nMark := nMark + 1 
		//Carrega array com bem+item
		AAdd(aBens, {(cAliasMrk)->N1_CBASE+(cAliasMrk)->N1_ITEM, (cAliasMrk)->N1_CHAPA})
		If nMark > 1    
			For nX := 2 to Len(aBens)  // VErifico a partir da segunda linha do MarkBRowse
				If aBens[nx-1][1] == ((cAliasMrk)->N1_CBASE+(cAliasMrk)->N1_ITEM)
					lRet := .F.
					Help(" ",1,"AF240DUPLI",, STR0028, 1, 0) //"Existe linhas duplicadas (Cod. Base e Item iguais)."
					Exit
				EndIf
				If aBens[nx-1][2] == ((cAliasMrk)->N1_CHAPA) .And. !lRepetChap
					lRet := .F.
					Help(" ",1,"AF240CHAPA",,STR0039 , 1, 0)    //"Existe linhas duplicadas (Plaquetas iguais)."
					Exit
				EndIf
				If SN1->(dbSeek(FwXFilial('SN1')+(cAliasMrk)->N1_CBASE+(cAliasMrk)->N1_ITEM)) .and. SN1->N1_STATUS <> '0'
					lRet := .F.
					Help(" ",1,"JACLASSIFICLOT",,STR0066 + (cAliasMrk)->N1_CBASE + " " + (cAliasMrk)->N1_ITEM , 1, 0)    //""Bem ja classificado por outro usuario."
					Exit
				EndIf
			Next    
		EndIf
    EndIf
	If !lRet	
		Exit 
	Endif
    (cAliasMrk)->(dbSkip())
End
 
If nMark == 0
	lRet := .F.
    Help(" ",1,"NOMARK",, STR0033, 1, 0) //"Não há nenhum item selecionado."
EndIf

//(cAliasMrk)->(dbGoTop())

oMrkBrowse:Refresh()
 
RestArea(aAreaSN1)
RestArea(aArea)

aSize(aBens, 0)
aBens := NIL

Return lRet


/*{Protheus.doc}AF240CMark
Marcaçao Multi-Registros
@author Kaique Olivero
@since 01/09/2015
@param oMrkBrowse	- Tabela temporaria
@param cAliasMrk	- Tabela temporaria
@version P12
@project Inovação Controladoria
*/
Static Function AF240CMark(oMrkBrowse,cAliasTRB)

DbSelectArea(cAliasTRB)
DbGoTop() 

While !(cAliasTRB)->(Eof())
	RecLock(oMrkBrowse:Alias(),.F.)
	If (oMrkBrowse:Alias())->N1_OK == "  "
		(oMrkBrowse:Alias())->N1_OK  := oMrkBrowse:Mark()
	Else
		(oMrkBrowse:Alias())->N1_OK  := "  "
	Endif
	(oMrkBrowse:Alias())->(MsUnLock())
	(cAliasTRB)->(dbSkip())
EndDo

oMrkBrowse:oBrowse:Refresh(.T.)

Return


Static Function VldCanClas(cBaseVini,cItemVini,cBaseVate,cItemVAte)
	
	Local aArea    	:= GetArea()
	Local aAreaSN1 	:= SN1->(GetArea())
	Local cQuery	:= ""
	Local lRet		:= .T.
	Local aBindSN1
	
	cQuery		:=	"SELECT COUNT(R_E_C_N_O_) QTDBEM "
	cQuery		+=	"FROM " + RetSqlName("SN1") + " SN1 "
	cQuery		+=	"WHERE N1_FILIAL		= ? " 
	cQuery		+= "AND ( "
	cQuery		+= "     (N1_CBASE >  ? OR (N1_CBASE = ? AND N1_ITEM >= ?)) " //Filtra primeiro pela Base
	cQuery		+= " AND "													  //Se for Base inicial ou final, valida também o Item
	cQuery		+= "     (N1_CBASE <  ? OR (N1_CBASE = ? AND N1_ITEM <= ?)) " //Equivalente a Base+Item BETWEEN início e fim
	cQuery		+= ") "
	cQuery		+=	"AND N1_BMCONTR = ? "
	cQuery		+=	"AND SN1.D_E_L_E_T_		= ? "
	cQuery		:= ChangeQuery(cQuery)

	aBindSN1 :={}
	aAdd(aBindSN1, xFilial('SN1'))
	// Início
	aAdd(aBindSN1, cBaseVini)
	aAdd(aBindSN1, cBaseVini)
	aAdd(aBindSN1, cItemVini)
	// Fim
	aAdd(aBindSN1, cBaseVate)
	aAdd(aBindSN1, cBaseVate)
	aAdd(aBindSN1, cItemVAte)
	aAdd(aBindSN1, '1')
	aAdd(aBindSN1, Space(1))

	dbUseArea(.T.,"TOPCONN",TcGenQry2(,,cQuery,aBindSN1),'cQryTrab')

	If cQryTrab->QTDBEM > 0
		lRet	:=	.F.	//Bem já foi classificado
		Help(" ",1,"AF240INVALID",, STR0038, 1, 0) //"N?o é possivel classificar bens em construç?o na funcionalidade em lote, Verifique se entre o range De/Ate existem bens com essas caracteristicas."
	EndIF

	cQryTrab->(DbCloseArea())
	aSize(aBindSN1,0)
	RestArea(aAreaSN1)
	RestArea(aArea)
	
Return lRet

/* {Protheus.doc}
	AF240CHAP -	Verifca se a Plaqueta;Chapa existe
	@author Totvs
	@since 
	@param (xAliasAux)->N1_CHAPA) - plaqueta digitada
	@param lRepetChap  - .T. permite a mesma plaqueta, .F. -n"ao permite plaquetas iguais
	@version P12
*/
Static Function AF240Chapa(cChapa, lRepetChap)
Local aArea 		:= GetArea()
Local aAreaSN1 		:= SN1->(GetArea())
Local lRet := .T.

If !lRepetChap
	If Empty(cChapa)
		Help(" ",1,"AF012ACHAP",,STR0040,1,0,,,,,,{STR0041 }) //"Plaqueta não informada."###"Preencha o campo Plaqueta."
		lRet := .F.
	Else
		DBSelectArea("SN1")
		DBSetOrder(2)
		If DBSeek(XFilial("SN1") + cChapa) //.And. cBase+cItem != SN1->(N1_CBASE+N1_ITEM)
			Help(" ",1,"AF012ACHAP",,STR0042,1,0,,,,,,{STR0043}) //"Plaqueta já existente no sistema."###"Defina um novo código no campo Plaqueta."
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea(aAreaSN1)
RestArea(aArea)

Return lRet

/* {Protheus.doc}
	Af240Chave -Verifca se a Ativo Existe no SN1
	@author Totvs
	@since 
	@param (xAliasAux)->N1_CBASE) - cBase
	@param (xAliasAux)->N1_ITEM)  - cItem
	@version P12
*/

Static Function Af240Chave(cBase,cItem)
Local lRet  := .T.
Local aArea 		:= GetArea()
Local aAreaSN1 		:= SN1->(GetArea())

DBSelectArea("SN1")
DBSetOrder(1)
If DBSeek(XFilial("SN1") + cBase+ cItem) 
	If SN1->N1_STATUS != "0" 
		Help(" ",1,"AF240Chave",,STR0044,1,0,,,,,,{STR0045}) //"Ativo já existente no sistema."###"Defina um novo código no campo item."
		lRet := .F.
	EndIf
EndIf

RestArea(aAreaSN1)
RestArea(aArea)
Return lRet

/* {Protheus.doc}
	fBscCod - Busca o próximo código base disponível
	@author Totvs
	@since 
	@param (xAliasAux)->N1_CBASE) - cBase
	@param (xAliasAux)->N1_ITEM)  - cItem
	@version P12
*/
Static Function fBscCod(cCodIni As Character,cItemIn As Character) As Character
	Local aArea As Array
	aArea := GetArea()
	
	While .t.
		If SN1->(DbSeek(xFilial("SN1")+cCodIni+cItemIn))
			If SN1->N1_STATUS != "0" //0 = Não Classificado
				cCodIni := Soma1(Alltrim(cCodIni),Len(SN1->N1_CBASE))
			Else 
				exit
			EndIf
		Else
			exit
		EndIf
	EndDo

	RestArea(aArea)
Return cCodIni

/* {Protheus.doc}
	fBscIt - Busca o próximo código do item disponível
	@author Totvs
	@since 
	@param (xAliasAux)->N1_CBASE) - cBase
	@param (xAliasAux)->N1_ITEM)  - cItem
	@version P12
*/
Static Function fBscIt(cCodIni As Character,cItemIn As Character) As Character
	Local aArea As Array
	aArea := GetArea()

	While .t.
		If SN1->(DbSeek(xFilial("SN1")+cCodIni+cItemIn))
			If SN1->N1_STATUS != "0" //0 = Não Classificado
				cItemIn := SOMA1(Alltrim(cItemIn),Len(SN1->N1_ITEM))
			Else 
				exit
			EndIf
		Else
			exit
		EndIf
	EndDo
	RestArea(aArea)
Return cItemIn


/* {Protheus.doc}
	af240CancC - Cancela classificação de bem posicionado, excluindo SN5, SN3 e SN4 diferente de 01/03

	@author Totvs
	@since 
	@param cBaseAut as Character, cItemAut as Character, lAutomato as Logical 
	@version P12
*/
Function af240CancC(cBaseAut as Character, cItemAut as Character, lAutomato as Logical ) as Logical

Local cBase 		as Character
Local cItem 		as Character
Local cTpBem 		as Character
Local cFilBem 		as Character
Local cChvBemAnt	as Character
Local cChaveSN3		as Character		
Local cChaveSN4		as Character		
Local cPadrao 		as Character		
Local cLote			as Character		
Local cArquivo		as Character		
Local nTx			as numeric
Local nTy			as numeric
Local nCountTx		as numeric
Local nContEnt		as numeric		
Local nHdlPrv		as numeric		
Local nTotal		as numeric		
Local lRet 			as Logical
Local lLancPad		as Logical		
Local lContab   	as Logical		 //Sempre true, pois e exclusao
Local lAglutina 	as Logical		
Local lMostra 		as Logical		
Local aArea 		As Array
Local aValorMoed	As Array

DEFAULT lAutomato	:= .F.

//Inicializa variaveis com padrão
cChvBemAnt			:= "" 
cChaveSN3 			:= "" 
cPadrao 			:= ""
cLote				:= ""
cArquivo			:= ""
nTx 				:= 0
nTy 				:= 0
nCountTx 			:= 0
nContEnt 			:= 0
nHdlPrv				:= 0
nTotal				:= 0
lLancPad			:= .F.
lContab   			:= .T.
lAglutina 			:= .F.
lMostra 			:= .F.
aValorMoed			:= {}

aArea 				:= GetArea()
nCountTx 			:= AtfMoedas() //Funcao generica do fonte AtfxOld
cFilBem 			:= xFilial("SN1")

If lAutomato
	cBase := cBaseAut
	cItem := cItemAut
Else
	cBase				:=	SN1->N1_CBASE 
	cItem				:=	SN1->N1_ITEM
EndIf

//Validacoes
lRet 				:= af240VldCa(cBase,cItem)
cTpBem				:=	SN3->N3_TIPO //pega o tipo após reposicionar na N3 novamente

If !lRet //Encerra processo caso negativa
	Return lRet
EndIf

If !lAutomato
	lRet := MsgYesNo(STR0048 + cBase + STR0049 + cItem + STR0050 ) //"Deseja realmente cancelar a classificação do bem de código : e item ?"
Else
	lRet := .T.
EndIf

Pergunte("AFA012",.f.)	
SaveInter()	

//Gravacao
If lRet //Depois das validacoes e aceite do usuario

	//Adicionar ordem das SN
	SN1->(DbSetOrder(1))
	SN3->(DbSetOrder(1))
	SN4->(DbSetOrder(1))

	lRet	:=	SN1->(DbSeek(cFilBem+cBase+cItem))
	If lRet
		lRet	:=	SN3->(DbSeek(cFilBem+cBase+cItem))
		lRet	:=	SN4->(DbSeek(cFilBem+cBase+cItem))
	EndIf

	If lRet
		//Abre o arquivo de contabilização 
		cLote		:= LoteCont("ATF")
		lMostra 	:= MV_PAR01 == 1
		lAglutina 	:= MV_PAR06 == 1
		cPadrao 	:= AF012AQPAD(SN3->N3_TIPO,.T.)
		lLancPad	:= VerPadrao(cPadrao)

		//Inicializa contabilizacao
		If nHdlPrv <= 0 .And. lLancPad .And. lContab
			nHdlPrv := HeadProva(cLote,"ATFA240",Substr(cUsername,1,6),@cArquivo)
		EndIf

		cChaveSN3 := cFilBem + cBase + cItem + cTpBem
		cChaveSN4 := cFilBem + cBase + cItem + cTpBem
		cChvBemAnt := cFilBem + cBase + cItem
		
		//Limpeza e delecao SN3
		While (!SN3->(Eof()) .And. SN3->N3_FILIAL + SN3->N3_CBASE + SN3->N3_ITEM + SN3->N3_TIPO == cChaveSN3 .And. SN3->N3_FILIAL + SN3->N3_CBASE + SN3->N3_ITEM == cChvBemAnt )
			If lLancPad .And. nHdlPrv > 0
				nTotal += DetProva(nHdlPrv, cPadrao, "ATFA240", cLote)
			EndIf

			//Função para pegar o valor de todas as moedas do tipo posicionado, campo N3_VORIG dependendo de quantas moedas foram criadas
			aValorMoed := AtfMultMoe("SN3","N3_VORIG")

			dbSelectArea("SN5") //para pegar o alias corretamente na funcao na linha 651
			dbSetOrder(1)
			ATFXSLDCTB(SN3->N3_CCONTAB,SN3->N3_AQUISIC,"1",SN3->N3_VORIG1,SN3->N3_VORIG2,SN3->N3_VORIG3,SN3->N3_VORIG4,SN3->N3_VORIG5,"-",NIL,SN3->N3_SUBCCON,NIL,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1",aValorMoed,SN3->N3_TPSALDO,"",SN3->N3_TIPO,"","05")

			If !(SN3->N3_TIPO $ "01,03")
				If SN3->(RECLOCK('SN3', .F.,.T.))
					SN3->(dbDelete())
					SN3->(MSUNLOCK())
				EndIf
			Else
				If SN3->(RECLOCK('SN3', .F.))
					SN3->N3_HISTOR := ""		
					//Entidades de depreciacao e do bem
				 	//Os campos N3_SUBCCON, N3_CLVLCON ,N3_CUSTBEM ,N3_CCUSTO  / N4_CUSTO, N4_CLVL ,N4_SUBCTA Irão permanecer os mesmos enviados do MATA103
					SN3->N3_CCONTAB := "" //Ira deixar em branco, MATA103 não envia conta contábil mesmo quando preenche ela
					SN3->N3_CDEPREC	:= ""
					SN3->N3_CCDEPR	:= "" 
					SN3->N3_CDESP	:= ""  
					SN3->N3_CCORREC	:= ""
					
					SN3->N3_CCDESP 	:= ""
					SN3->N3_CCCDEP 	:= ""
					SN3->N3_CCCDES 	:= ""
					SN3->N3_CCCORR 	:= ""

					SN3->N3_SUBCTA 	:= ""
					SN3->N3_SUBCDEP	:= ""
					SN3->N3_SUBCCDE	:= ""
					SN3->N3_SUBCDES	:= ""
					SN3->N3_SUBCCOR	:= ""

					SN3->N3_CLVL   	:= ""
					SN3->N3_CLVLDEP	:= ""
					SN3->N3_CLVLCDE	:= ""
					SN3->N3_CLVLDES	:= ""
					SN3->N3_CLVLCOR	:= ""

					//Entidades Adicionais
					If Len(__aCTBEnt) > 0 .AND. __lEntAdd
						For nContEnt := 1 to Len(__aCTBEnt)
							SN3->&("N3_EC" + __aCTBEnt[nContEnt]+"DB")	:=	""
							SN3->&("N3_EC" + __aCTBEnt[nContEnt]+"CR")	:=	""					
						Next nContEnt
					EndIf

					//Taxas e moedas diferente da 1
					For nTx := 1 to nCountTx
						If ( SN3->(FieldPos("N3_TXDEPR" + Alltrim(str(nTx)) )) > 0  .And. SN3->(FieldPos("N3_VORIG" + Alltrim(str(nTx)) )) > 0  ).And. nTx <= 9
							SN3->&("N3_TXDEPR" + AllTrim(Str(nTx))) := 0
							If nTx > 1
								SN3->&("N3_VORIG" + AllTrim(Str(nTx)))  := 0
							EndIf
						ElseIf ( SN3->(FieldPos("N3_TXDEP" + Alltrim(str(nTx)) )) > 0  .And. SN3->(FieldPos("N3_VORIG" + Alltrim(str(nTx)) )) > 0 ).And. nTx >= 10			
							SN3->&("N3_TXDEP" + AllTrim(Str(nTx)))	:= 0
							If nTx > 1
								SN3->&("N3_VORIG" + AllTrim(Str(nTx)))	:= 0
							EndIf
						EndIf
					Next
					SN3->(MSUNLOCK())
				EndIf
			EndIf			
			SN3->(DbSkip())
			cChaveSN3 := cFilBem + SN3->N3_CBASE + SN3->N3_ITEM + SN3->N3_TIPO //+ SN3->N3_SEQ
		EndDo

		//Limpeza N4 tipo 01/03 e demais delecao
		While (!SN4->(Eof()) .And. SN4->N4_FILIAL + SN4->N4_CBASE + SN4->N4_ITEM + SN4->N4_TIPO == cChaveSN4 .And. SN4->N4_FILIAL + SN4->N4_CBASE + SN4->N4_ITEM == cChvBemAnt )
			If !(SN4->N4_TIPO $ "01,03") .And. SN4->N4_OCORR = "05" .And. SN4->N4_TIPOCNT = "1"	
				If SN4->(RECLOCK('SN4', .F.,.T.))
					SN4->(dbDelete())				
					SN4->(MSUNLOCK())
				EndIf				
			Else
				If SN4->(RECLOCK('SN4', .F.))
					//Taxas e moedas diferente da 1
					For nTy := 1 to nCountTx
						If ( SN4->(FieldPos("N4_VLROC" + Alltrim(str(nTy)) )) > 0  )
							If nTy > 1
								SN4->&("N4_VLROC" + AllTrim(Str(nTy)))  := 0
							EndIf

						EndIf
					Next
					If SN4->N4_LA ='S'
						SN4->N4_LA		:= "N"
					EndiF				
					SN4->N4_CONTA	:= ""
					SN4->N4_TXDEPR	:= 0
					SN4->(MSUNLOCK())
				EndIf
			EndIf
			SN4->(DbSkip())
			cChaveSN4 := cFilBem + SN4->N4_CBASE + SN4->N4_ITEM + SN4->N4_TIPO //+ SN3->N3_SEQ
		EndDo

		// Após limpar SN5, SN3 e SN4
		If SN1->(RECLOCK('SN1', .F.))
			SN1->N1_STATUS 	:= "0"
			SN1->N1_DTCLASS := STOD("")
			SN1->N1_CHAPA 	:= ""
			SN1->N1_GRUPO	:= ""
			SN1->(MSUNLOCK())
		EndIf
	EndIf

	If lLancPad .And. nHdlPrv > 0 .And. nTotal > 0		 			
		RodaProva(nHdlPrv,nTotal)
		cA100Incl(cArquivo, nHdlPrv, 2, cLote, lMostra, lAglutina)
	Endif
EndIf

RestInter()	
RestArea(aArea)

Return lRet

/* {Protheus.doc}
	af240VldCa - Função de validacoes para saber se pode cancelar classificação

	@author Totvs
	@since 
	@param CodBase as Character, CodItem as Character return as logical 
	@version P12
*/
Static Function af240VldCa(CodBase as Character, CodItem as Character ) as Logical

Local lRetVld as Logical
Local lTemMov as Logical

lRetVld 		:= .T.
lTemMov 		:= .F.

lRetVld	:=	SN1->(DbSeek(xFilial("SN1")+CodBase+CodItem))
lRetVld	:=	SN3->(DbSeek(xFilial("SN3")+CodBase+CodItem))
lRetVld	:=	SN4->(DbSeek(xFilial("SN4")+CodBase+CodItem))

If lRetVld 
	If SN1->N1_STATUS == '0' //a classificar
		Help(" ",1,"AF240JACLASS",,STR0051,1,0,,,,,,{STR0052}) //""###""
		lRetVld := .F.
	ElseIf SN1->N1_STATUS == '4' //Transferencia
		Help(" ",1,"AF240TRANSF",,STR0053,1,0,,,,,,{STR0054}) //""###""
		lRetVld := .F.
	ElseIf SN1->N1_STATUS $ '2|3' //Bloqueado por usuario ou local 
		Help(" ",1,"AF240BLQCAN",,STR0055 ,1,0,,,,,,{STR0056}) //""###""
		lRetVld := .F.
	ElseIf cPaisLoc == 'BRA' .And. !Empty(SN1->N1_SLBMCON) .And. !Empty(SN1->N1_CDCONTR)
		Help(" ",1,"AF240CONST",,STR0057,1,0,,,,,,{STR0058}) //""###""
		lRetVld := .F.
	ElseIf Empty(SN1->N1_NFISCAL)
		Help(" ",1,"AF240NNOTA",,STR0059,1,0,,,,,,{STR0060}) //""###""
		lRetVld := .F.
	EndIf

	If lRetVld
		lTemMov	:=	VldCanCanc(CodBase,CodItem)
	EndIf

	If lTemMov
		Help(" ",1,"AF240MOV",,STR0061,1,0,,,,,,{STR0062}) //""###""
		lRetVld := .F.
	EndIf

EndIf

FreeObj(oQueryQry)

Return lRetVld

/* {Protheus.doc}
	VldCanCanc - Funcao que verifica se existe qualquer tipo de movimento ou depreciacao
	no bem posicionado para possibilidade de cancelamento de classificacao

	@author Totvs
	@since 
	@param CodBase as Character, CodItem as Character return as logical 
	@version P12
*/
Static Function VldCanCanc(CodBase as Character, CodItem as Character) as Logical

	Local cQry			as Character
	Local cQry2			as Character
	Local cNextAlias	as Character
	Local lRetQry		as Logical
	Local nSeq			as Numeric

	lRetQry			:= .T.
	cQry2			:= ""
	cNextAlias		:= GetNextAlias()
	nSeq			:= 1

	If oQueryQry == Nil
		cQry	:= " SELECT Count(N4_CBASE) MOV "
		cQry	+= " FROM "+ RetSqlName("SN4") +" SN4 "
		cQry	+= " WHERE "
		cQry	+= " SN4.N4_FILIAL = ? "
		cQry	+= " AND SN4.N4_CBASE = ? "
		cQry	+= " AND SN4.N4_ITEM = ?"
		cQry	+= " AND "
		cQry	+= " (( SN4.N4_OCORR <> ?  ) OR ( SN4.N4_ORIGEM <> ? ))   " //Casos de depreciacoes ou movimentos
		cQry	+= " AND SN4.D_E_L_E_T_ = ? "
		cQry 	:= ChangeQuery(cQry)
		oQueryQry := FWPreparedStatement():New(cQry)
	EndIf

	oQueryQry:SetString(nSeq++,		xFilial( "SN4" ))
	oQueryQry:SetString(nSeq++,		CodBase)
	oQueryQry:SetString(nSeq++,		CodItem)
	oQueryQry:SetString(nSeq++,		'05')
	oQueryQry:SetString(nSeq++,		'ATFA012')
	oQueryQry:SetString(nSeq++,		Space(1))
	
	cNextAlias := MPSYSOpenQuery(oQueryQry:GetFixQuery(),cNextAlias)
	DbSelectArea(cNextAlias)

	lRetQry	:=	 ((cNextAlias)->MOV > 0)

	(cNextAlias)->(dbCloseArea()) 
	oQueryQry:Destroy()
	oQueryQry := Nil
	
	If !lRetQry //Verifica outros movimentos de inclusão de Ativo a partir do primeiro
		If oQueryQry == Nil
			nSeq 	:=1
			cQry2	:= " SELECT Count(N4_CBASE) MOV "
			cQry2	+= " FROM "+ RetSqlName("SN4") +" SN4 "
			cQry2	+= " INNER JOIN "+ RetSqlName("SN1") +" SN1 ON SN1.N1_FILIAL = SN4.N4_FILIAL AND SN1.N1_CBASE = SN4.N4_CBASE AND SN1.N1_ITEM = SN4.N4_ITEM
			cQry2	+= " WHERE "
			cQry2	+= " SN4.N4_FILIAL = ? "
			cQry2	+= " AND SN1.N1_BASESUP = ? "
			cQry2	+= " AND SN1.N1_ITEMSUP = ? "
			cQry2	+= " AND SN4.N4_OCORR = ? AND SN4.N4_TIPOCNT = ?  AND SN4.N4_ORIGEM <> ? AND SN4.N4_ORIGEM <> SN1.N1_ORIGEM     " //Outros movimentos de inclusão a partir do primeiro
			cQry2	+= " AND SN4.D_E_L_E_T_ = ? "
			cQry2	+= " AND SN1.D_E_L_E_T_ = ? "
			cQry2 	:= ChangeQuery(cQry2)

			oQueryQry := FWPreparedStatement():New(cQry2)

			oQueryQry:SetString(nSeq++,		xFilial( "SN4" ))
			oQueryQry:SetString(nSeq++,		CodBase)
			oQueryQry:SetString(nSeq++,		CodItem)
			oQueryQry:SetString(nSeq++,		'05')
			oQueryQry:SetString(nSeq++,		'1')
			oQueryQry:SetString(nSeq++,		Space(1))
			oQueryQry:SetString(nSeq++,		Space(1))
			oQueryQry:SetString(nSeq++,		Space(1))
			
			cNextAlias	:= GetNextAlias()
			cNextAlias := MPSYSOpenQuery(oQueryQry:GetFixQuery(),cNextAlias)
			DbSelectArea(cNextAlias)

			lRetQry	:=	 ((cNextAlias)->MOV > 0)

			(cNextAlias)->(dbCloseArea()) 
			oQueryQry:Destroy()
			oQueryQry := Nil
		EndIf
	Endif

Return lRetQry
