#INCLUDE "PROTHEUS.CH"
#INCLUDE "SET.CH"
#INCLUDE "FINA080.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "FWADAPTEREAI.CH"
#INCLUDE "FWLIBVERSION.CH"

#DEFINE ALIAS  1
#DEFINE IDORIG 2

Static lIsRussia := cPaisLoc == 'RUS'
Static nFirstRsn :=Iif(lIsRussia,nFirstRsn := 2,  nFirstRsn := 1)
Static lFa080Bco
Static lFWCodFil  := .T.
Static nValMax	  := 0
Static lSiafi	  := .F.
Static dLastPcc   := CTOD("22/06/2015")
Static lSpbInUse  := Nil
Static lIsIssBx   := Nil
Static lSE5FI080  := Nil
Static lF80GRVFK  := Nil
Static lImp10925  := Nil
Static lFa080PCC  := Nil
Static __F080EXEA := Nil
Static __F080PCAN := Nil
Static lF080ACRE  := Nil
Static lFA080POS  := Nil
Static lFA080ACES := Nil
Static lFA080BTN  := Nil
Static lFA080BTH  := Nil
Static lF080FILEM := Nil
Static lFA080PE   := Nil
Static lF080ACONT := Nil
Static lFA080CHK  := Nil
Static lFina080   := Nil
Static lF080DCNB  := Nil
Static lBenef	  := Nil
Static lF080TXIR  := Nil
Static lF80L9816  := Nil
Static lPaisMI	  := (FindFunction("FA080MI") .And. FA080MI())

Static cMotBxBco  := NIL
Static lFina450   := NIL
Static __oMovPA   := Nil
Static __oMovPA2  := Nil
Static __oMovCnb  := Nil
Static nTamLote   := Nil
Static nTamHist   := Nil
Static nDecTxMd   := Nil
Static nTamCodA6  := Nil
Static nTamParc   := Nil
Static __lExistVA := NIL	//Valores Acessórios
Static __lPodeTVA := Nil
Static __lEAIF080 := Nil
Static lIntPFS	  := Nil
Static lBxParBor  := Nil
Static __aVAAuto  := NIL		//Valores Acessórios - Baixa via execauto
Static __aCtb430  := {}
Static __cLanc430 := "N"	
Static __nTxMoeAt := 0		
Static __nTxTitBx := 0
Static __nVlrAjst := 0
Static __nAcresc  := 0
Static __nDecresc := 0
Static __lMetric  := .F.
Static __cFunBkp  := ""
Static __cFunMet  := ""
Static __oObJFK2  := Nil

// Motor de retenções
Static _lTemMR := Nil
Static _aImpMR := {}
Static _lPccMR := .F.
Static _lIrfMR := .F.
Static _lInsMR := .F.
Static _lIssMR := .F.
Static _lCidMR := .F.
Static _lSesMR := .F.
Static _lImpMR := .F.
Static _lPccBxMR := .F.
Static _nImpMR := 0
Static _nTotImp := 0
Static _nImpEmMR := 0
Static _nImpBxMR := 0
Static _nValPgto := 0
Static _nPisMR := 0
Static _nCofMR := 0
Static _nCslMR := 0
Static _nIrfMR := 0
Static _nInsMR := 0
Static _nIssMR := 0
Static _nCidMR := 0
Static _nSesMR := 0
Static _cTabOri := ""
Static _cIdOrig := ""
Static _nBasLeg := 0
Static __lLGPD	:= NIL
Static __lAtuVlr := Nil

//Atualização Tela FINA080
Static __cBcoAgCt := ""
Static __nTxMoeda := 0
Static __dBaixa   := dDataBase
Static __nMoedBco := 0
Static __lOk      := .T.
Static lPCCBaixa  := Nil
// Considera baixas que geram ou nao movimento bancario.
// 1 = Somente os motivos que geram movimento bancario
// 2 = Considera todos os motivos de baixa.
Static lMotBxMBco := Nil
Static __oRatIRF  := Nil		// Rateio IR Progressivo
Static __lVlTitAd := NIL
Static __lFINA090 := Nil

Static __nDedSimpl 	As Numeric
Static __lDicSimpl  As Logical

//-------------------------------------------------------------------
//- Models
Static oModelBxP  as object //- Model de baixas a pagar
Static oModelMov  as object //- Model de Movimento bancario
Static __lAltVrBx as Logical
Static __lCpoJuro As Logical
Static __lCpoMult As Logical
Static __lCpoDesc As Logical
Static __lTxMoeda As Logical
Static __BordeImp As Logical
Static lChkLxProp := FindFunction("ChkLxProp")
Static __lShoHelp  As Logical
Static __oImpConf  As Object
Static __oQryFKQ   As Object
Static __lFK7IDPA  As Logical
Static __lIDFK7  := NIL

//-------------------------------------------------------------------
/*/{Protheus.doc}FINA080
Programa de Baixa de Titulos a Pagar
@author Totvs
@since  26/05/1992
@version 12
/*/
//-------------------------------------------------------------------
Function FINA080(xAutoCab,nOpc,lNoMBrowse,nOpbaixa,lExibeLanc,lOnline, aVAAut, aCtb430, cLanc430, aTxExt,lMov,aPerg)

	Local lDigita,lAglut
	Local bBlock

	Private lF080Auto    := (ValType(xAutoCab) = "A")
	Private aAutoCab     := {}
	Private lBxLote      := .F.
	Private nEstOriginal := 0
    PRIVATE LanceiCTB    := .F.

	DEFAULT nOpc       := 3
	DEFAULT lNoMBrowse := .F.
	Default nOpBaixa   := 1
	Default aCtb430    := {}
	Default cLanc430   := "N"
	Default aTxExt     := {}
	Default aPerg      := {}
	DEFAULT lMov       := .T.
    
    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT __lPodeTVA := ExistFunc("FAPodeTVA")
    DEFAULT lFina450   := FwIsInCallStack("FINA450")
    DEFAULT nTamLote   := TamSX3("E2_LOTE")[1]

	lF415Auto := IIf(Type("lF415Auto")=="U",.F.,lF415Auto)		// Sergio Fuzinaka - 05.06.02

	//----------------------------------------------------------------
	// Restringe o uso do programa ao Financeiro e Sigaloja
	//----------------------------------------------------------------
	If !(AmIIn(6,12,17,72))		// S¢ Fin e Loja e EIC e photo
		Return
	Endif

	//------------------------------------------------------------------------------
	PRIVATE lFini055	:= FwIsInCallStack("FINI055")
	PRIVATE lImp  		:= (SuperGetMv("MV_IMPTRAN",.F.,"1") == "2" )
	PRIVATE lGerImp 	:= !(FWIsInCallStack("FINA631") .And. lImp )

	PRIVATE aRotina 	:= MenuDef()
	PRIVATE cBanco 		:= CriaVar("E1_PORTADO")
	PRIVATE cAgencia	:= CriaVar("E1_AGEDEP")
	PRIVATE cConta		:= CriaVar("E1_CONTA")
	PRIVATE cCheque 	:= CriaVar("E1_NUMBCO")
	PRIVATE cOrdPag 	:= CriaVar("E2_ORDPAGO")
	PRIVATE cIDProc 	:= CriaVar("FKA_IDPROC")
	PRIVATE cPortado	:= "   "
	PRIVATE cNumBor 	:= Space(6)
	PRIVATE cMarca 		:= ''
	PRIVATE nValPadrao	:= 0
	PRIVATE nValEstrang	:= 0
	PRIVATE cBenef
	PRIVATE cBancoV
	PRIVATE cAgenciaV
	PRIVATE cContrato
	PRIVATE cPrefV
	PRIVATE cNumV
	PRIVATE cParcV
	PRIVATE cTipV
	PRIVATE cNaturV
	PRIVATE cFornecV
	PRIVATE nValAcres
	PRIVATE nTxAcresV
	PRIVATE nValtitV
	PRIVATE dDataVencV
	PRIVATE cCtbaixa 	:= GETMV("MV_CTBAIXA")
	Private cFil080
	PRIVATE oVlEstrang,oCM
	PRIVATE lGerouSef 	:= .F.
	PRIVATE nAcresc     := 0
	PRIVATE nDecresc    := 0
	PRIVATE lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
	PRIVATE lEECFAT  := SuperGetMv("MV_EECFAT",.F.,.F.)
	PRIVATE oDifCambio
	PRIVATE oAcresc
	PRIVATE oDecresc
	Private aDadosSPB 	:= {}
	PRIVATE nMoedaBco	 := 1
	Private cCodDiario	:= ""
	PRIVATE lIRProg	:= "2"
	PRIVATE nPgtoAuto := 0
	PRIVATE nValEIC  := 0
	Private nF080TXIR  := 0
	
	If Type("cLoteFin") == "U" // Pode vir do Fina430 (Arquivo Cnab)
		PRIVATE cLoteFin 	:= Space(nTamLote)
	EndIF

	nOpc1 := 0

	NUMCHEQUE 	:= ""		//para contabilizar o numero do cheque

	__nTxMoeAt := 0			//Taxa contratada para rotina automática	
	__lAltVrBx := .F.	

	If Type("lWserver") == "U"		//-- utilizado para evitar problemas quando chamado via WS - TMS
		cMarca 		:= Get080Mark()
	EndIf

	//Carrega fun‡ao Pergunte
	SetKey (VK_F12,{|a,b| AcessaPerg("FIN080",.T.)})

	If FunName() <> "FINA415" .And. !(FunName() == "FINA050" .And. FwIsInCallStack('Fa050Subst'))
		Pergunte("FIN080",.F.)
	EndIf

	//Tratamento para evitar conflito do pergunte FIN080
	//com o TMA250 ao gerar contrato de carreteiro - TMS
	If lExibeLanc <> NIL .And. ValType(lExibeLanc) == "L"
		mv_par01 := Iif(lExibeLanc,1,2) //Exibe Lancamentos Contabeis
	EndIf

	//Tratamento para evitar conflito do pergunte FIN080
	//com o TMA250 ao gerar contrato de carreteiro - TMS
	If lOnline <> NIL .And. ValType(lOnline) == "L"
		mv_par03 := Iif(lOnline,1,2) //Contabiliza On-Line
	EndIf

	lDigita:=IIf(mv_par01==1,.T.,.F.)
	lAglut :=IIf(mv_par02==1,.T.,.F.)

	//Valores Acessórios - Rotina Automatica Bx CP
	If lF080Auto .and. __lPodeTVA
		If (aVAAut <> Nil )
			__aVAAuto := aClone(aVAAut)
		Else
			__aVAAuto := {}
		Endif
	Endif

	If cLanc430 == "S"
		__cLanc430 := cLanc430
	Endif

	// VerIfica o numero do Lote
	PRIVATE cLote
	LoteCont( "FIN" )

	// Define o cabe‡alho da tela de baixas
	PRIVATE cCadastro := OemToAnsi(STR0006 )  //"Baixa de Titulos"

	If lNoMBrowse
		Do Case
			Case nOpc == 3
				INCLUI := .T.
				ALTERA := .F.
			Case nOpc == 4
				INCLUI := .F.
				ALTERA := .T.
			OtherWise
				INCLUI := .F.
				ALTERA := .F.
		EndCase
		dbSelectArea("SE2")

		If ( nOpc <> 0 )  .And. !Deleted()
			bBlock := &( "{ |a,b,c,d,e| " + aRotina[ nOpc,2 ] + "(a,b,c,d,e) }" )
			Eval( bBlock, Alias(), (Alias())->(Recno()),nOpc)
		EndIf
	Else
		If !lF080Auto
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de entrada para pre-validar os dados a serem  ³
			//³ exibidos.                                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF ExistBlock("F080BROW")
				ExecBlock("F080BROW",.f.,.f.)
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Endereça a Função de BROWSE											  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			mBrowse( 6, 1,22,75,"SE2",,,,,, Fa040Legenda("SE2"),,,,,,,,IIF(ExistBlock("F080FILB"),ExecBlock("F080FILB",.f.,.f.),NIL))
		Else
			dbSelectArea('SE2')
			aAutoCab := SE2->(MSArrayXDB(xAutoCab,nil,4))
			If Len(aAutoCab) == 0
				Return
			EndIf

			//Verificação da validação documento hábil - SIAFI
			lSiafi := FwIsInCallStack("FINA761")

			if nOpc == 3
				If lIsRussia
					fA080Tit("SE2",Recno(),4,,,aTxExt)
				Else
					fA080Tit("SE2",Recno(),4,,,			,aPerg)
				ENDIF
			Elseif nOpc == 4
				INCLUI := .F.
				ALTERA := .T.
				fA080Tit("SE2", Recno(), 4,,,,aPerg)
			ElseIf nOpc == 5
				If lIsRussia
					fA080Can("SE2", Recno(), 5,, nOpbaixa,lMov)
				Else
					fA080Can("SE2", Recno(), 5,, nOpbaixa , 	, aPerg)
				ENDIF
			ElseIf nOpc == 6
				fA080Can("SE2", Recno(), 6,, nOpbaixa	,		, aPerg)
			Endif
		Endif
	Endif

	aCtb430 := __aCtb430

	//-- Efetua a exclusão do model na saída.
	//-- Para rotinas automaticas não efetua a limpeza para que o Model seja
	//-- reaproveitado, mas a limpeza deve ser feita na função chamadora
	IF !lF080Auto
		F080ClearM()
	EndIF

	dbSelectArea("SE2")
	SET FILTER TO
	SetKey( VK_F12, Nil )
	dbSetOrder(1)

	lFina450 := NIL

	//Valores Acessórios
	If __lPodeTVA
		If (__aVAAuto <> Nil )
			aSize(__aVAAuto,0)
			__aVAAuto := Nil
		Endif
	Endif

Return

//------------------------------------------------------------------
/*/{Protheus.doc}fA080Tit
Função utilizada para Baixa de Titulos a Pagar  
@author Wagner Xavier 
@since  26/05/1992
/*/
//------------------------------------------------------------------
Function fA080Tit(cAlias,nReg,nOpcx,aM,lAut,aTxExt,aPerg)

	Local lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
	Local lPanelFin := IsPanelFin()
	LOCAL nOpt
	LOCAL lDigita	:=IIf(mv_par01==1,.T.,.F.)
	LOCAL lAglut	:=IIf(mv_par02==1,.T.,.F.)
	LOCAL nHdlPrv	:=0
	LOCAL nTotal	:=0
	LOCAL lPadraoBx
	LOCAL cArquivo
	LOCAL lRet:=.T.
	LOCAL nSalvRec:=0
	LOCAL cParcela
	LOCAL cNum
	LOCAL cFornece
	LOCAL cMoeda
	LOCAL nOrdem
	LOCAL nErro :=0
	LOCAL lPadraoVd
	LOCAL cContabiliza := GETMV("MV_CTBAIXA")
	LOCAL lContabiliza
	Local lContabMnat
	Local cLanca	:= Iif(mv_par03==1,"S","N")
	Local aCmc7:={}
	Local lFa080tit:= Existblock("FA080TIT")
	Local aMotBx := ReadMotBx()
	Local cPadrao
	Local aOldValores
	LOCAL oCbx
	LOCAL aDescMotbx := {}
	Local cMoedaTx, nA := 0
	LOCAL oImpSubst
	Local nDecrescF:= 0
	Local cClearing := Space(3) // Bank of America
	Local cTipoPgto := Space(2) // Bank of America
	Local cStored := Space(4) // Bank of America
	Local cHora := Substr(Time(),1,5) // Bank of America
	Local cCodBar := Space(44) // Bank of America
	Local nEventoSPB := 0 // Bank of America
	LOCAL aModalSPB :=  {"1=TED","2=CIP","3=COMP"}
	LOCAL oModSpb
	Local nUltLin
	Local nTamTitOri := TamParcela("E2_PARCELA",19,20,21)
	Local oMultNat
	Local lMultNat := .F.
	Local lOk := .F. //Controla se foi confirmada a distribuicao
	Local aColsSEV := {}
	Local oTxMoeda
	Local nTolerCp := SuperGetMv("MV_TOLERCP",.F.,0)
	Local nI
	Local cNatPis 	:= SuperGetMv("MV_PISNAT",.F.,"PIS")
	Local cNatCof	:= SuperGetMv("MV_COFINS",.F.,"COF")
	Local cNatCsl	:= SuperGetMv("MV_CSLL",.F.,"CSL")
	Local lMensagem := .T.
	Local nLinha := 0
	Local nOldVlPis := 0
	Local nOldVlCof := 0
	Local nOldVlCsl := 0
	Local nCentMd1	:= MsDecimais(1)
	Local nOldVlIrf := 0
	Local lIRPFBaixa := .F.
	Local aArea := SE2->(GetArea())
	Local cPrefixo := SE2->E2_PREFIXO
	Local cTipoPai := SE2->E2_TIPO
	Local lAchou := .F.
	Local cMsg	 := ""
	Local nBusca := 0
	Local lAD	 := .F.
	Local lAcessImp:= .T.
	Local aButtons  := {}
	Local lCalcIssBx :=  IsIssBx("P") .And. !SE2->E2_TIPO $ MVPAGANT
	Local lCideBX := cPaisLoc == "BRA" .And. SuperGetMv("MV_FGCIDE",.T.,"2") == "1" // Define o fato gerador do imposto CIDE. 1 = Baixa ou 2 = Emissão

	Local nOldVlIss := 0

	Local nOldRetPis := 0
	Local nOldRetCof := 0
	Local nOldRetCsl := 0
	Local lContrRet  := .T.

	Local lBordero		:= !Empty(SE2->E2_NUMBOR) .And. "4" $ SE2->(E2_PRETCOF+E2_PRETCSL+E2_PRETPIS)
	Local lEmBordero	:= F080EmBord() // Melhoria DSERFINP-10020

	Local lBxEstTotal := .F.
	Local lJurMulDes := (SuperGetMv("MV_IMPBAIX",.t.,"2") == "1")
	Local nSalImp := 0

	Local lAcessMul      := .T.
	Local lAcessJur	     := .T.
	Local lAceDtBxa   := .T.
	Local lAceDtDeb := .T.
	Local lAcessDes	     := .T.
	Local aCposDes	     := {}
	Local nT 		     := 0
	LOCAL nY	         := 0
	Local nZ			 := 0
	Local oJuros
	Local oDescont
	Local oMulta
	LOCAL oNaturez
	LOCAL oTipo
	LOCAL cTipo
	Local oDtBaixa
	Local oDtDebito
	Local oNomFor
	Local oBenef
	Local lCarret       := .F.

	//Huawei
	Local cPort240 := Criavar("EF_BANCO")
	Local cAgen240	:= CriaVar("A6_AGENCIA")
	Local cConta240:= CriaVar("A6_NUMCON")
	Local cModPgto := CriaVar("EA_MODELO")
	Local cTipoPag := CriaVar("EA_TIPOPAG")
	Local dDataBord := dDatabase
	Local lAltBord := .F.
	Local aGrvLctPco := {	{"000005","03","FINA080"}, ;
							{"000005","04","FINA080"}  }

	Local aFlagCTB := {}
	Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	Local nPgtoIRRF := 0
	Local lValPgto := SuperGetMv("MV_BP10925",.T.,"1") == "2" //1- Valor bruto da baixa parcial / 2- Valor da baixa parcial menos os impostos
	Local lF080VLAD := ExistBlock("F080VLAD")
	Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
	Local aAreaSE2   := {}
	Local lPAMov := .F.
	Local lCb10925 	:= GetNewPar("MV_CB10925","2") == "1"
	Local lIsIrBx	:= .F.
	Local lTemPCCBX	:= .F.
	Local lTemISSBX	:= .F.
	Local nRecPAInc := 0
	Local aAreaSA2   := {}
	Local lSigaEIC	:= .F.
	Local aAux		:= {}
	Local cFunName	:= FunName()
	Local lFinVDoc	:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios
	Local nLimInss  := SuperGetMv("MV_LIMINSS",.F.,0)
	Local lBaixou	:= .F.
	Local lDtBaixa	:= .F.
	Local lF080VCheq := ExistBlock( "F080VCHEQ" )
	Local cNomeCpo   :=	'E2_EMISSAO'
	Local lSubsPrv := FwIsInCallStack("FA050Subst")
	Local lFINA430	:= cFunName == "FINA430" .Or. FwIsInCallStack("fa430gera")
	Local aDiario	:= {}
	Local lVerifyBlq := Empty(SE2->E2_CODOPE)
	Local lTpDesc		:= cPaisLoc == "BRA" //Verifica campo TPDESC na tabela SE5 (<C>ondicional ou <I>ncondicional)
	Local aAreaSED 	:= {}
	Local lNatApura	:=	.F. //Natureza configurada para apurar impostos no SPED PIS/COFINS.
	Local lCposSped	:=	 cPaisLoc == "BRA" //Campos que apuram impostos no SPED PIS/COFINS.
	Local lESSCOM   := .F. //Trade-Easy - RRC - 17/07/2013 - Integração SIGACOM x SIGAESS: Geração automática das invoices e parcelas de câmbio a partir do documento de entrada
	Local lESSEIC   := .F. //Trade-Easy - RRC - 05/12/2013 - Integração SIGAEIC x SIGAESS: Geração automática das parcelas de câmbio a partir dos títulos
	Local llOpc	:= Nil
	Local aEaiRet := {}
	Local lBxTxa := SuperGetMv("MV_BXTXA",.F.,"1") == "1"
	Local nMinINS1 	:= SuperGetMv("MV_MININSS",.F.,0)
	Local nMinINS2 	:= SuperGetMv("MV_VLRETIN",.F.,0)
	Local lInsPub 	:=	SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And.;
						nLimInss == 0 .And. nMinINS2 == 0 //Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
	Local nOldInss	:= 0
	Local nPcc 		:= 0

	//Inss Baixa
	Local lAcmPJ 	 	:= SuperGetMv("MV_INSACPJ",.T.,"2") == "1"  //1 = Acumula    2= Não acumula
	Local aBaixa		:=	{}
	Local lNotBax 		:= .F.
	LOCAL nTotAdto 		:= 0
	Local lBxCEC 		:= .F.  //Verificador de existencia de baixa por compensacao entre carteiras
	Local nParciais		:=	0
	Local cNccIr		:= SuperGetMv("MV_NCCIR",.F.,"2")
	Local nRecSE5Ins 	:= 0
	Local aPcc			:= {}
	Local lMVBP10925  	:= SuperGetMv("MV_BP10925",.F., "1") == "2" // Default (Bruto)
	Local lAdiantamento := .f.
	Local lMovBcoBx 	:= .T.
	Local lCnab 		:= .F.
	Local lExistFJU 	:= FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")
	Local aOutImp		:= {}
	Local lEdJur		:= SED->(ColumnPos('ED_JURSPD')) > 0
	Local noldPcc		:= 0
	Local lMVCNBImpg 	:= GetNewPar("MV_CNBIMPG",.F.)
	Local nRcN_PASE5 	:= 0
	Local lRatIrrf		:= SuperGetMv("MV_RATIRRF",.F.,.T.)
	Local cParc1Dup		:= SuperGetMv("MV_1DUP")
	Local cMinParcE2 	:= "" 
	Local nValAuto		:= 0
	Local lBcoCxCart 	:= .F.
	Local lMotBxChq 	:= .F.
	Local nValToVld 	:= 0
	Local lIssSum450 	:= .F.
	Local aCtBaixa	:= {}
	Local nX		:= 0
	Local lLibCheq	:= SuperGetMv( "MV_LIBCHEQ", .F., 'N' ) == "S"
	Local lRetBor	:= .T.

	Local lJFilBco	 := SuperGetMv( "MV_JFILBCO", .F., .F. ) .And. FindFunction("JURF3SA6") .And. FindFunction("JurVldSA6") //Indica se filtra as contas correntes vinculadas ao escritório logado - SIGAPFS.
	Local cEscrit    := Iif(lJFilBco, JurGetDados("NS7", 4, xFilial("NS7") + cFilant + cEmpAnt, "NS7_COD"), "") // Código do escritório relacionado a filial logada - SIGAPFS.
	Local cF3Bco     := Iif(lJFilBco, "SA6JUR", "SA6")

	Local aAreaCTB		:= {}
	Local cIDMovE5		:= ""
	Local lMvPar06		:= .F.
	Local nLaco			:= 0
	Local dDtaAnt       := dDataBase
	lOCAL lOFINI055		:= AllTrim(SE2->E2_ORIGEM)=="FINI055"
	Local oMyBar		:= NIL
	Local oFont24		:= TFont():New("Arial",10,24,,.F.,,,,.T.,.F.)
	
	Local nCasDec := TamSx3("E2_TXMOEDA")[2]
	Local nVlrMov := 0
	Local nVlrImp := 0
	Local lAltVlrAut := .F. //indica se houve alteração de valor de pagamento via execauto
	Local lAbatInss  := SuperGetMv("MV_INSIRF",.F.,"2") == "1"
	Local aTitCalc	 := {}
	Local aRestPerg	 := {}
	Local cHelpMsg   := ""
	Local cTitleHlp  := ""
	Local nInicio	 := 0
	Local nFim		 := 0
	Local nDtContOn	 := SuperGetMv("MV_DTCNBXP",.F.,3) // Data para contabilização Online baixas pagar 1- Data Digitação; 2- Data Disponibilidade; 3- Data Pagamento
	Local dDtLanc	 := dDataBase 
	Local lF390chq   := Iif(SE2->E2_IMPCHEQ == "S",.T.,.F.)
	Local cTipoCm	 := SuperGetMv("MV_TIPOCM", .T., "T")
	Local lIntMNT    := SuperGetMv( 'MV_NGMNTFI', .F., 'N' ) == 'S'
    Local lMNTIntFin := FindFunction( 'MNTIntFIN' )
    Local cOldVAbkp  := ""
	Local lPgtoMaior := .F.
	Local lVldBcoFin := FindFunction("FinVldBco")
	Local lRoundCsll := SuperGetMV("MV_RNDCSL", .F., .F.)
	Local lRoundPis  := SuperGetMV("MV_RNDPIS", .F., .F.)
	Local lValidCsl	 := .F.
	Local lValidPis  := .F.
	Local nCsllRet 	 := 0
	Local nPisRet 	 := 0
	Local lCOL4XMIL	 := cPaisLoc == "COL" .and. FindFunction("FINX4XMIL") 
	Local lVal4xMil	 := .F.
	Local nImposMR 	 := 0
	
	Default aPerg 	   := {}
	Default aTxExt	   := {}
   	DEFAULT lAut       := .F.

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT __lEAIF080 := FWHasEAI("FINA080",.T.,,.T.)
    DEFAULT __lMetric  := FwLibVersion() >= "20210517"
    DEFAULT __lPodeTVA := ExistFunc("FAPodeTVA")
    DEFAULT _lTemMR	   := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
    DEFAULT lBenef     := ExistBlock("F080BENEF")
    DEFAULT lF080ACONT := ExistBlock("F080ACONT")
    DEFAULT lF080ACRE  := ExistBlock("F080ACRE")
    DEFAULT lF080DCNB  := ExistBlock("F080DCNB")
    DEFAULT lF080FILEM := ExistBlock("F080FILEMI")
    DEFAULT lF080TXIR  := ExistBlock("F080TXIR")
    DEFAULT lF80L9816  := ExistBlock("F80L9816")
    DEFAULT lFA080ACES := ExistBlock("FA080ACES")
    DEFAULT lFA080BTH  := ExistBlock("FA080BTH")
    DEFAULT lFA080BTN  := ExistBlock("FA080BTN")
    DEFAULT lFA080CHK  := ExistBlock("FA080CHK")
    DEFAULT lFa080PCC  := ExistBlock("FA080PCC")
    DEFAULT lFA080PE   := ExistBlock("FA080PE")
    DEFAULT lFA080POS  := ExistBlock("FA080POS")
    DEFAULT lFina080   := Existblock("FINA080")
    DEFAULT lFina450   := FwIsInCallStack("FINA450")
    DEFAULT lImp10925  := ExistBlock("FA080IMP")
    DEFAULT lPCCBaixa  := (SuperGetMv("MV_BX10925",.T.,"2") == "1")
    DEFAULT lSpbInUse  := SpbInUse() .AND. VerCpoSPB()
    DEFAULT nDecTxMd   := TamSX3("E2_TXMOEDA")[2]
    DEFAULT nTamCodA6  := TamSX3("A6_COD")[1]
    DEFAULT nTamHist   := TamSX3("E5_HISTOR")[1]

	PRIVATE l450		:= .F.
	PRIVATE oCheque,oAgencia,oBanco,oConta,oDlg,oValPgto
	PRIVATE cHist070  := CriaVar("E5_HISTOR")
	PRIVATE dBaixa	  := CriaVar("E2_BAIXA")
	PRIVATE dDebito	  := CriaVar("E2_BAIXA")
	PRIVATE cNatMov   := CriaVar("ED_MOVBCO")
	PRIVATE nValPgto  := 0
	PRIVATE nCM 	  := 0
	PRIVATE	nCMCalc	  := 0
	PRIVATE nDescont := 0
	PRIVATE nJuros   := 0
	Private nVA		 := 0		// Valores acessórios.
	PRIVATE nMulta   := 0
	PRIVATE nOtrga       := 0
	PRIVATE nDifCambio   := 0
	PRIVATE nImpSubst    := 0
	PRIVATE aTxMoedas	  := {}
	Private nOldValor := 0
	Private aDadosSPB := {}
	PRIVATE lUsaCmc7 := .F.
	PRIVATE cModSpb		:= "1"
	PRIVATE nValBrut		:= 0
	PRIVATE nPis 		:= 0
	PRIVATE nCofins   := 0
	PRIVATE nCsll		:= 0
	PRIVATE nCide := 0
	PRIVATE aDadosRef := Array(7)
	PRIVATE aDadosRet := Array(7)
	PRIVATE aRecnosSE2 := ()
	PRIVATE nOldValPgto := 0
	PRIVATE dBxDt_Venc
	PRIVATE dOldData := CToD("")
	PRIVATE nOldDescont := 0
	PRIVATE nOldMulta := 0
	PRIVATE nOldJuros := 0
	Private nOldVA := 0
	Private cOldVA := ""
	PRIVATE nOldIRRF := 0
	PRIVATE nOldPis := 0
	PRIVATE nOldCofins := 0
	PRIVATE nOldCsll := 0
	PRIVATE nOldCide := 0
	PRIVATE nValComp := 0
	Private nIss := 0
	Private nIrrf := 0
	Private nBaseIrpf := 0
	PRIVATE nOldIss := 0
	PRIVATE nVlImpPCC:= 0
	Private nAcrescF := 0
	PRIVATE oFontLbl
	PRIVATE dDataCan := CTOD("")
	Private nOldTxMoed := 0
	Private aBaixaSE5 := {}
	
	//IRRF - BAIXA
	PRIVATE aDadosIr := Array(3)
	Private lBaixaAbat := .F.
	Private nTotImpost := 0
	PRIVATE nVlRetIrf:= 0
	Private cTpDesc := "I"
	Private lEmpPub := IsEmpPub()
	Private nVlMPub := SuperGetMv("MV_VLMPUB" ,.T.,10)
	Private lAplMinP := .F.
	Private nBaseIns	:= 0 //Inss Baixa
	Private nVretInss	:= 0
	Private aRecnoINSS	:= {}
	Private aBordINSS	:= {}
	Private cPretIns	:= ""
	Private nInss		:= 0
	Private lAglImp := .F.
	Private oCofins
	Private oPis
	Private oCsll
	Private oIrrf
	Private oCide
	Private oRetMotor As Object

	aFill(aDadosIr,0)
	aFill(aDadosRef,0)
	aFill(aDadosRet,0)

	//Reestruturacao SE5
	PRIVATE nDescCalc 	:= 0
	PRIVATE nJurosCalc 	:= 0
	Private nVACalc 	:= 0
	PRIVATE nMultaCalc 	:= 0
	PRIVATE nCorrCalc	:= 0
	PRIVATE nDifCamCalc	:= 0
	PRIVATE nImpSubCalc	:= 0
	PRIVATE nPisCalc	:= 0
	PRIVATE nCofCalc	:= 0
	PRIVATE nCslCalc	:= 0
	PRIVATE nIrfCalc	:= 0
	PRIVATE nIssCalc	:= 0
	PRIVATE nInsCalc	:= 0
	PRIVATE nPisBaseR 	:= 0
	PRIVATE nCofBaseR	:= 0
	PRIVATE nCslBaseR 	:= 0
	PRIVATE nIrfBaseR 	:= 0
	PRIVATE nIssBaseR 	:= 0
	PRIVATE nInsBaseR 	:= 0
	PRIVATE nPisBaseC 	:= 0
	PRIVATE nCofBaseC 	:= 0
	PRIVATE nCslBaseC 	:= 0
	PRIVATE nIrfBaseC 	:= 0
	PRIVATE nIssBaseC 	:= 0
	PRIVATE nInsBaseC 	:= 0
	PRIVATE nCidBase	:= 0
	PRIVATE nValTt  	:= 0
	PRIVATE nBSCLCPCC	:= 0
	PRIVATE lChqPre 	:= .f.  //-- Variavel auxiliar  … analise se o titulo veio de um cheque pre datado
	PRIVATE cMotBx  	:= CriaVar("E5_MOTBX")
	PRIVATE cBenef		:= CriaVar("E5_BENEF")
	PRIVATE nTxMoeda    := 0    //-- Deve ser PRIVATE 
	__nMoedBco := 0
	__nTxMoeda := 0

	lValidCsl := lRoundCsll .And. lPccBaixa
	lValidPis := lRoundPis  .And. lPccBaixa

	If __lAtuVlr == NIL
		__lAtuVlr := .F.
	EndIf	
	
	IF Type("lPrim750")== "U"
		lPrim750 := .T.
	EndIf
	
	IF Type("lF080Auto") <> "L"
		lF080Auto := .F.
	EndIf

	__BordeImp  := IIf(__BordeImp == Nil, FindFunction("BorderoImp"), __BordeImp)

	nF080TXIR := Iif(!(TYPE("nF080TXIR") == 'N'),0,nF080TXIR)
	
	If __lVlTitAd == NIL
		__lVlTitAd	:= GetNewPar("MV_VLTITAD",.F.)
	Endif

	__cFunBkp   := FunName()
	__cFunMet	:= Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA080",__cFunBkp)

	If __lMetric
		SetFunName(__cFunMet)
        // Metrica de controle de acessos 
        FwCustomMetrics():setSumMetric(Alltrim(ProcName()), "financeiro-protheus_qtd-por-acesso_total", 1)
		SetFunName(__cFunBkp)
    Endif

    //Realiza o Backup das informações do pergunte original da rotina
    If Len(aPerg) == 3
		AADD(aRestPerg,mv_par01) // Mostra Lançamento Contabil
		AADD(aRestPerg,mv_par02) // Aglutina Lançamento
		AADD(aRestPerg,mv_par03) // Contabiliza Online
		
		//Repasse do Pergunte de origem FINA415
        mv_par01    := aPerg[1]
        mv_par02    := aPerg[2]
        mv_par03    := aPerg[3]
    EndIf

	lMvPar06 := ChekSX1(6)

	//Valores Acessórios
	If __lExistVA == NIL
		__lExistVA 		:= TableInDic("FKD") .and. TableInDic("FKC") .and. FindFunction("FINA080VA")
	EndIF

	If __lLGPD == NIL
		__lLGPD	:= FindFunction("RetGlbLGPD")
	EndIf	
	
	//Retorna o Array aDescMotBx contendo apenas a descricao do motivo das Baixas
    If Len(aDescMotbx) == 0
        For nI := 1 to len( aMotBx )
            If substr(aMotBx[nI],34,01) == "A" .or. substr(aMotBx[nI],34,01) =="P"
                If !(substr(aMotBx[nI],01,03) $ "FAT|LOJ|LIQ|CEC|CMP|DSD")
                    AADD( aDescMotbx,substr(aMotBx[nI],07,10))
                EndIf
            EndIf
        Next nI
    EndIf

    // Carrega varivael cmotbx para sua verifcacao na funcao fa080totmes()
    cMotBx := aDescMotBx[nFirstRsn] 	//NORMAL

	//Armazena conteúdo da última seleção de Banco, Agencia e Conta (do FINA750) selecionado no título anterior caso seja da mesma filial
	If FwIsInCallStack("Fin750080") .and. !lPrim750 .and. SA6->A6_FILIAL == xFilial("SA6")
		If (!lMvPar06 .Or. (lMvPar06 .And. mv_par06 == 1) .And. FXVldBxBco( SA6->A6_COD, SA6->A6_AGENCIA, SA6->A6_NUMCON, SE2->E2_NATUREZ, SE2->E2_MOEDA, .F.))
			cBanco 		:= SA6->A6_COD
			cAgencia	:= SA6->A6_AGENCIA
			cConta		:= SA6->A6_NUMCON
		EndIf
	EndIf

	// Verificar antes de abrir a tela de baixa se usar o parâmetro 'banco anterior'
    If (lMvPar06 .And. mv_par06 == 2) .OR. !MovBcoBx(cMotBx, .T.)
		cBanco 		:= CriaVar("E1_PORTADO")
		cAgencia	:= CriaVar("E1_AGEDEP")
		cConta		:= CriaVar("E1_CONTA")
	EndIf

	lSigaEIC := .F.
	aAux := {"EIC","EEC","EFF","EDC","ESS"}
	aEval(aAux, {|x| Iif(x $ UPPER(cFunName), lSigaEIC := .T.,)})	

	If (ExistBlock( "FA080CMC" ) )
		lUsaCmc7 := ExecBlock("FA080CMC",.F.,.F.)
	Endif

	IF ExistBlock("F080MNAT")
		lMultNat := ExecBlock("F080MNAT",.F.,.F.)
	Endif

	//se estiver sendo chamado via rotina automática a partir da compensação entre carteiras,
	//nao deve processar ISS E IR
	If lFina450 .and. lF080Auto
		lIssSum450 := lCalcIssBx
		lCalcIssBx := .F.
	EndIf

	If Type("lAltVr") == "U"
		lAltVr	:= .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se titulo esta suspenso			 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty( SE2->E2_DATASUS )
		Return .F. /*Function fA080Tit*/
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe Adiantamento ou Devolucao ³
	//³ para o Fornecedor do título a ser baixado.   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (IIF(((cFunName == "MATA101N") .Or. (lChkLxProp .and. ChkLxProp("CancelacionAnticipo"))) .AND. cPaisLoc $ "MEX|PER", .T. , __lVlTitAd .And. !(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG+"/"+MVINSS) ) )
		nBusca := F090BuscAD( "SE2", SE2->E2_FORNECE, SE2->E2_LOJA )
		If nBusca <> 0
			lAD := .T.
			cMsg := STR0144 //"O Fornecedor deste titulo possui "
			Do Case
				Case nBusca = 1 // Adiantamento
					cMsg += STR0145 //"Adiantamento."
				Case nBusca = 2 // Devolucao
					cMsg += STR0146 //"Devolucao."
			End Case
			cMsg += chr(13)+chr(10)
			cMsg += STR0147 //"Deseja mesmo assim baixa-lo ?"
			If isBlind()
				If lF080VLAD
					If !(ExecBlock("F080VLAD",.F.,.F.))
						Return .F. /*Function fA080Tit*/
					Endif
				Endif
			Else
				If !MsgYesNo( cMsg )
					Return .F. /*Function fA080Tit*/
				Endif
			Endif
		Endif
	Endif

	//----------------------------------------------
	// Verifica se existe Adiantamento de INSS
	//----------------------------------------------
	nBusca := 0
	
	If __lVlTitAd .And. SE2->E2_TIPO $ MVINSS
		If !Empty(SE2->E2_TITPAI)
			If F090LocINA( SE2->E2_TITPAI )
				If !isBlind()
					If !MsgYesNo(STR0196) // "Existem titulos de INSS retido em pagamentos antecipados ainda pendentes de compensação para este fornecedor, efetua a baixa mesmo assim?"
						Return .F. /*Function fA080Tit*/
					Endif
				Else
					Return .F. /*Function fA080Tit*/
				Endif
			Endif
		Endif
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Paises Localizados:                                  ³
	//³Nao deixa baixar o titulo se no cadastro de Moeda SM2³
	//³a taxa estiver com valor Zero                        ³
	//³Validacao somente para titulo com Moeda > 1          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( cPaisLoc <> "BRA" ) .And. ( SE2->E2_MOEDA > 1 )
		If !(RecMoeda(dBaixa,SE2->E2_MOEDA) > 0 )
			Help(" ",1,"A080TXZERO")
			Return .F. /*Function fA080Tit*/
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³VerIfica se pode baixar titulo inserido em um bordero 				³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If mv_par04 == 2	// Nao permite baixa se o titulo estiver num bordero.
		If !Empty( SE2->E2_NUMBOR )
			Help(" " , 1 , "FA080NAOBAIXA")
			Return .F. /*Function fA080Tit*/
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o titulo esta bloqueado - Gestao de Contratos ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(SE2->(FieldPos("E2_MSBLQL"))) .And. SE2->E2_MSBLQL == "1" .And. lVerifyBlq
		Help(" ",1,"SE2BLOQ")
		Return .F. /*Function fA080Tit*/
	EndIf
	
	If !lSubsPrv
		If !SE2->E2_TIPO $ MVPAGANT .And. (GetMv("MV_CTLIPAG") .and. Empty(SE2->E2_DATALIB) .and. SE2->(E2_SALDO+E2_SDACRES-E2_SDDECRE) > GetMV("MV_VLMINPG"))
			If (lF080Auto .Or. FwIsInCallStack("FWMYTESTRUNNER"))	
				AutoGrLog(STR0220)
				lMsErroAuto := .T.
			Else			
				Help(' ', 1 , "FA080NAOLIB", NIL, STR0220, 2, 0, , , , , , {STR0229})
			Endif
			
			Return .F.		
		Endif
	Endif	
	
	//Verifica se permite baixa pelo Financeiro Se existir integração Pamcard não é possivel. Permitido apenas pelo TMS.
	If UPPER(SE2->E2_ORIGEM) = "SIGATMS" .AND. FindFunction( "T250VldBx" )
		If !T250VldBx( SE2->E2_FILORIG,SE2->E2_NUM, SE2->E2_CODOPE )
			Return
		EndIf
	EndIf

	If !lF080Auto 
		//Verifica a apresentação dos documentos
		If lFinVDoc .And. AliasIndic("FRD") .And. (SE2->(FieldPos("E2_TEMDOCS")) > 0) .And. !CN062ValDocs("02",.F.)
			Return .F.
		EndIf
		
		//Caso tenha sido gerado pelo SigaEic e do tipo PR ou PRE nao podera se baixado se nao for pela rotina automatica
		If lIntegracao .And. AllTrim(SE2->E2_TIPO) $ "PR|PRE" .And. UPPER(SE2->E2_ORIGEM) = "SIGAEIC"
			HELP(" ",1,"FAORIEIC")
			Return .F.
		Endif
		
		//DFS - 16/03/11 - Deve-se verificar se os títulos foram gerados por módulos Trade-Easy, antes de apresentar a mensagem.
		// TDF - 26/12/11 - Acrescentado o módulo EFF para permitir liquidação
		// NCF - 25/03/13 - Acrescentado o módulo SIGAESS (Siscoserv)
		// NCF - 27/04/17 - retirada a verificação de país do fornecedor
		If (UPPER(Alltrim(SE2->E2_Origem)) $ "SIGAEEC/SIGAEDC/SIGAECO/SIGAESS" .And. !(cModulo $ "EEC/EDC/ECO/EFF/ESS") .And. SE2->E2_MOEDA > 1)
			HELP(" ",1,"FAORIEEC")
			Return .F.
		Endif
		
		//Caso tenha sido gerado pelo SigaEic e do tipo INV e do BRASIL nao podera se baixado se nao for pela rotina automatica
		If lIntegracao .and. cPaisloc == "BRA" .and.  SE2->E2_TIPO =="INV"  .and.  UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEIC"
			HELP(" ",1,"FAORIEIC")
			Return .F.
		Endif
		
		//AAF - Titulos originados no SIGAEFF não devem ser alterados
		If "SIGAEFF" $ SE2->E2_ORIGEM
			Help(" ",1,"FAORIEFF")
			Return .F.
		EndIf
	ElseIf lFinVDoc .And. !CN062ValDocs("02",.T.) //Verifica a apresentação dos documentos
		Return .F.
	EndIf
	
	//Caso tenha integracao SIGAPFS (MV_JURXFIN = .T.), valida as regras para manipulacao do título.
	If !Fa080Juri(.F., .T.)
		Return .F. /*Function fA080Tit*/
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso esteja ligado o controle de solicitacao de notas de credito e exista alguma ³
	//³ pendencia para este titulo                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc <> "BRA"
		SCU->(DbSetOrder(2))
	Endif
	
	If !lF080Auto .And. cPaisLoc <> "BRA" .And. SuperGetMv('MV_SOLNCP') .And.  SE2->E2_TIPO == MVNOTAFIS ;
		.And. SCU->(MsSeek(xFilial()+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_NUM+SE2->E2_PREFIXO)).And. Empty(SCU->CU_NCRED)
		HELP(" ",1,"SOLNCPAB")
		Return .F. /*Function fA080Tit*/
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se possui movimento de baixa valido						³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE2->E2_TIPO $ "INA"
		If !FwIsInCallStack("FINA870") .AND. F090PagINA( SE2->E2_FILIAL + SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCELA + SE2->E2_TIPO + SE2->E2_FORNECE + SE2->E2_LOJA )
			HELP(" ",1,"SE2BLOQ")
			Return .F. /*Function fA080Tit*/
		EndIf
	EndIf

	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
		lAdiantamento := .T.
	EndIf
	
	//verifica se PA teve movimentação bancária com atualizaçãod de saldo para poder realizar a baixa
	If cPaisloc == "BRA" 
		If SE2->E2_TIPO $ MVPAGANT
			//posicionar na SE5 de movimentacao bancaria da PA
			lPAMov := .F.
			//verifica se PA possui movimentacao bancaria
			nRecPAInc := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			If  nRecPAInc > 0
				SE5->(DBGoto(nRecPAInc))
				lPAMov := .T.
			EndIf
			If !lPAMov
				Help(" ",1,"NOTPAMOV",,STR0143 + CRLF + CRLF + STR0197 , 4, 0) 
				Return .F. /*Function fA080Tit*/
			EndIf
			//verifica se PA possui registro de inclusao
			nRecPAInc := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			If	nRecPAInc > 0
				SE5->(DBGoto(nRecPAInc))
			EndIf
			If !Fa050Filho(.T.)
				lIsIrBx	:= Fa080IrBx()
				lTemPCCBX := Fa080PCCBx()
				lTemISSBX := Fa080ISSBx() 	

				If !lCb10925 .and. (lIsIrBx .or. lTemPCCBX .or. lTemISSBX) //se o imposto baixado for Imposto de Renda gerado na baixa -> nao deixa cancelar baixa do principal.
					Help(" ",1,"NODELETA",,STR0153 + CRLF + STR0201, 4, 0) // "Este titulo possui impostos e"//"um desses impostos sofreu baixa."
					Return .F.  /*Function fA080Tit*/
				Else
					If SE5->E5_PRETPIS=='2' .or. SE5->E5_PRETCOF=='2' .or. SE5->E5_PRETCSL=='2'
						If (ExistBlock("F080PCBX") .and. ExecBlock("F080PCBX",.F.,.F.)==.F.)
							//"Nao é possível realizar essa baixa pois possui impostos PCC retidos em outra baixa. E necessario cancelar primeiro a baixa responsavel pela retenção dos impostos"
							MsgStop(STR0198 +chr(13)+STR0164,STR0143)
							Return .F. /*Function fA080Tit*/
						EndIf
					EndIf
					//Mesmo permitindo o cancelamento MV_CB10925 = 1, será feita uma pergunta de confirmação
					//caso exista algum título filho que já tenha sido baixado.
					If !lF080Auto .and. lCb10925 .and. (lIsIrBx .or. lTemPCCBX .or. lTemISSBX) .and. !MsgYesNo(STR0153 + CRLF + STR0201 + STR0159,STR0143)	//"Este titulo possui impostos e"+chr(13)+"um desses impostos sofreu baixa."
						//"Deseja mesmo cancelar ?"
						Return .F. /*Function fA080Tit*/
					EndIf
				EndIf
			ElseIf !Fa050Filho(.F.)   //verifica se esse título tem TX filhos, sem verificar se esses TXs foram baixados
				If SE5->E5_PRETPIS=='2' .or. SE5->E5_PRETCOF=='2' .or. SE5->E5_PRETCSL=='2'
					If (ExistBlock("F080PCBX") .and. ExecBlock("F080PCBX",.F.,.F.)==.F.)
						//"Nao é possível realizar essa baixa pois possui impostos PCC retidos em outra baixa. E necessario cancelar primeiro a baixa responsavel pela retenção dos impostos"
						MsgStop(STR0198 +chr(13)+STR0164,STR0143)
						Return .F. /*Function fA080Tit*/
					ElseIf lPccBaixa
						If !MsgYesNo(STR0192)//Essa baixa possui impostos retidos em outra baixa, deseja continuar ?
							Return .F. /*Function fA080Tit*/
						Endif
					EndIf
				EndIf
				If SE2->E2_VALOR != SE2->E2_SALDO .And. !Empty(SE2->E2_BAIXA) .And. !Empty(SE2->E2_VALLIQ)
					MsgStop(STR0208+chr(13)+STR0209,STR0143)
					Return .F. /*Function fA080Tit*/
				EndIf
			ElseIf lPccBaixa
				//posicionar na SE5 de inclusao da PA
				If SE5->E5_PRETPIS=='2' .or. SE5->E5_PRETCOF=='2' .or. SE5->E5_PRETCSL=='2'
					If !MsgYesNo(STR0192)//Essa baixa possui impostos retidos em outra baixa, deseja continuar ?
						Return .F. /*Function fA080Tit*/
					Endif
				EndIf
			Endif
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PONTO DE ENTRADA 													³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lFA080CHK
		If !(ExecBlock("FA080CHK",.F.,.F.))
			Return .F. /*Function fA080Tit*/
		EndIf
	Endif

	//Caso a rotina esteja cadastrada no adapter, so pode ser enviada como 'Sincrona'. Uma baixa enviada como assincrona
	//sera concretizada mesmo que de erro no sistema integrado.
	If !lFini055
		If !(FA080Integ(.F.))
			Return .F. /*Function fA080Tit*/
		Endif
	Endif

	//-----------------------------------------------------
	// Validação Siafi
	//-----------------------------------------------------
	If !lSiafi .and. FinTemDH()
		Return .T. /*Function fA080Tit*/
	Endif

	//-----------------------------------------------------
	// Validação Adiantamento N Moedas
	//-----------------------------------------------------
	If !FXNMoedas("1")
		Return .T.
	Endif

	If SE2->( Deleted() )
		Help( " " , 1 , "RECNO" )
		Return .F. /*Function fA080Tit*/
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	//³Monta Hist¢rico da Baixa para digitação pelo usuario					?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	cHist070 := Criavar("E5_HISTOR")		//Inicilizador padrao

	If Empty(cHist070)
		cHist070 := PadR(OemToAnsi(STR0011),nTamHist) 	//"Valor pago s/ Titulo"
	Endif

	//Verificar se o Motivo de Baixa existe	
	If lF080Auto 
		nInicio := Seconds()
		nT      := ascan(aAutoCab, {|x| x[1]='AUTMOTBX'})
		
		If nT > 0
			cMotBx := aAutoCab[nT,2]
			//Validação pelo Motivo de baixa e pela Descrição
			nY := AScan(aMotBx, {|x| (AllTrim(SubStr(x, 01, 03)) == AllTrim(cMotBx)) .Or. (AllTrim(SubStr(x, 07, 10)) == AllTrim(cMotBx))}) 
			
			if nY == 0
				cHelpMsg  := STR0029 + " " + cMotBx + " " + STR0227 //"Mot. Baixa" ## "não encontrado"
				cTitleHlp := "MOTBX"
			EndIf
		Else
			cHelpMsg  := STR0245 //"Motivo de baixa não informado"
			cTitleHlp := "NOMOTBX"

			If FwIsInCallStack("FINI080")
				cHelpMsg := STR0245 + STR0246 //"Motivo de baixa não informado." # "Verifique a tag PaymentMethodCode no arquivo XML "
			Endif
		Endif
		
		If lFINA430 .And. (nT := AScan(aAutoCab, {|x| x[1] == "AUTVLRVA"})) > 0
			nVA := aAutoCab[nT,2]
		EndIf
		
		If !Empty(cHelpMsg)
			HELP(" ", 01, cTitleHlp , ,cHelpMsg, 02,1,,,,,.T., {STR0228})//#"Selecione um motivo de baixa existente"
			AutoGrLog(cHelpMsg)
			lMsErroAuto := .T.
			Return .F.
		Endif
		
		nFim := Seconds() - nInicio		
	Endif

	If lF080Auto 
		aValidGet := {}
		If MovBcobx(cMotBx, .T.)	// Sergio Fuzinaka - 28.05.02
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTBANCO'})) > 0
				Aadd(aValidGet,{'cBanco' ,aAutoCab[nT,2],"CarregaSa6(@cBanco,,,.T.)",.t.})
			Endif
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTAGENCIA'}) ) > 0
				Aadd(aValidGet,{'cAgencia' ,aAutoCab[nT,2],"CarregaSa6(@cBanco,@cAgencia,,.T.)",.t.})
			EndIf
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTCONTA'}) ) > 0
				Aadd(aValidGet,{'cConta' ,aAutoCab[nT,2],"CarregaSa6(@cBanco,@cAgencia,@cConta,.T.,,.T.)",.t.})
			EndIf
			nInicio := Seconds()
			// EJA - Alterado para estar junto com as outras validações - Trade Easy
			If !Empty(aValidGet) .And. !SE2->(MsVldGAuto(aValidGet))
				Return .F. /*Function fA080Tit*/
			EndIf
			nFim += Seconds() - nInicio
		EndIf
	EndIf

	dbSelectArea("SE2")
	nOrdem	:= IndexOrd()
	dbSetOrder(1)

	If lIsRussia .and. !empty(aTxExt)
		aTxMoedas:=aTxExt
	ElseIf cPaisLoc <> "BRA"
		Aadd(aTxMoedas,{"",1,PesqPict("SM2","M2_MOEDA1")})
		For nA	:=	2	To MoedFin()
			cMoedaTx	:=	Str(nA,IIf(nA <= 9,1,2))
			If !Empty(GetMv("MV_MOEDA"+cMoedaTx))
				Aadd(aTxMoedas,{GetMv("MV_MOEDA"+cMoedaTx),RecMoeda(dDataBase,nA),PesqPict("SM2","M2_MOEDA"+cMoedaTx) })
			Else
				Exit
			Endif
		Next
	EndIf

	//Analisa se o titulo foi gerado a partir de um cheque pre datado
	lChqPre := .f.
	dbSelectArea("SE5")
	dbSetOrder(2)
	If SE5->(dbSeek( xFilial("SE5") + "CD" + SE2->E2_PREFIXO + ;
			SE2->E2_NUM + SE2->E2_PARCELA + SE2->E2_TIPO + dToS(SE2->E2_EMISSAO )+;
			SE2->E2_FORNECE + SE2->E2_LOJA ))

			lChqPre := .T.
			cBanco   := SE5->E5_BANCO
			cAgencia := SE5->E5_AGENCIA
			cConta   := SE5->E5_CONTA
			cCheque  := SE5->E5_NUMCHEQ
			cBenef   := SE5->E5_BENEF
			cHist070 := SE5->E5_HISTOR
	EndIf

	nOrdSA6:=SA6->(IndexOrd())
	DbSetOrder(1)
	SA6->(dbSeek(xFilial("SA6")+cBanco+cAgencia+cConta))
	nMoedaBco:= Max(SA6->A6_MOEDA,1)
	SA6->(DbSetOrder(nOrdSA6))

	If cPaisLoc == "PER" .AND. FunName() == 'FINA415' 
		nMoedaBco := SE2->E2_MOEDA
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Mostra dados cadastrais do titulo										³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SA2")
	MsSeek(xFilial("SA2",SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA)

	//se estiver sendo chamado via rotina automática a partir da compensação entre carteiras, nao deve processar ISS E IR
	If !_lIrfMR .And. !(Funname() == "FINA450" .and. lF080Auto) .And.;
		cPaisLoc = "BRA" .And. SA2->A2_CALCIRF == "2" .And. !SE2->E2_TIPO $ MVPAGANT
		lIRPFBaixa := (Posicione("SED",1,xfilial("SED",SE2->E2_FILORIG) + SE2->(E2_NATUREZ),"ED_CALCIRF") == "S")
	EndIf

	If SA2->A2_MINPUB == "2"
		lAplMinP := .T.
	EndIf

	lIRProg := IIf( cPaisLoc == "BRA", IIf(!Empty(SA2->A2_IRPROG), SA2->A2_IRPROG, "2"), "2")

	//³Carrega Beneficiario com Nome do Fornecedor
	If Empty(cBenef)
		dbSelectArea("SA2")
		SA2->(dbSeek(xFilial("SA2",SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA))
		dbSelectArea("SE2")
		cBenef   := Padr(SA2->A2_NREDUZ,TamSx3("EF_BENEF")[1])
	Endif
	If lBenef
		cBenef := ExecBlock("F080BENEF",.F.,.F.)
	EndIf

	IF !lChqPre
		cCheque  := CriaVar("EF_NUM",.F.)
	Endif

	dBaixa  := CriaVar("E2_BAIXA")

	If !lF080Auto
		dDebito := dBaixa
	Endif

	nTxMoeda := RecMoeda(dBaixa, SE2->E2_MOEDA)
	__nTxTitBx := 0
	
	If cPaisLoc == "BRA"		
		If (nT := ascan(aAutoCab, {|x| x[1] == "AUTTXMOEDA"}) ) > 0
			nTxMoeda :=	aAutoCab[nT,2]
		EndIf
		
		If !(lIntegracao .And. !SE2->E2_TIPO $ MVNOTAFIS+"|"+MVPAGANT .And. UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEEC/SIGAEDC/SIGAECO/SIGAESS")
			If nT > 0
				__nTxMoeAt := nTxMoeda
			ElseIf nMoedaBco > 1 .And. SE2->E2_MOEDA != nMoedaBco  
				nTxMoeda := RecMoeda(dBaixa, nMoedaBco)
			ElseIf (SE2->E2_MOEDA == 1) .Or. (SE2->E2_TXMOEDA > 0 .And. Empty(SE2->E2_DTVARIA))
				nTxMoeda := SE2->E2_TXMOEDA
			Endif
		EndIf
		
		If nT > 0 .AND. lIntegracao .AND. UPPER(Alltrim(SE2->E2_ORIGEM)) == "SIGAEIC" 
			/*
				Casos do EIC onde é gravada taxa na SE2, porém na baixa a taxa da moeda do título para baixa é diferente da SE2 e pode ser diferente da SM2 e é mandada no execauto (e baixado em banco moeda diferente de 1)
			*/
			If nMoedaBco > 1 .AND. SE2->E2_MOEDA > 1 .AND. nMoedaBco <> SE2->E2_MOEDA
				nTxMoeda := RecMoeda(dBaixa, nMoedaBco) // E5_VALOR e E5_TXMOEDA considerar a taxa do banco
				__nTxTitBx	:= aAutoCab[nT,2] // Realizar os cálculos para baixa com a taxa de baixa enviada pelo EIC/execauto (E5_VLMOED2 com a moeda do título)
			EndIf
		endif
	Endif
	
	
	cPortado	 := SE2->E2_PORTADO

	If !SoftLock( "SE2" )
		Return .F. /*Function fA080Tit*/
	EndIf

	If (ExistBlock( "F080MENS" ) )
		lMensagem:=ExecBlock("F080MENS",.F.,.F.)
	Endif

	//se vier da integracao Protheus X Tin nao e permitido alterar na baixa
	If lOFINI055 .And. !lF080Auto
		lAcessMul := .F.
		lAcessDes := .F.
		lAcessJur := .F.
		lAceDtBxa := .F.
		lAceDtDeb := .F.
	
	//Ponto de entrada para desabilitar campos de Multa, Juros ou Descontos, data de baixa, data de debito
	ElseIf lF080DCNB
		aCposDes := ExecBlock("F080DCNB",.F.,.F.)
		If Len(aCposDes) > 0
			IF (nT := ascan(aCposDes,'MULTA')) > 0
				lAcessMul := .F.
			Endif
			IF (nT := ascan(aCposDes,'DESCONTO')) > 0
				lAcessDes := .F.
			Endif
			IF (nT := ascan(aCposDes,'JUROS')) > 0
				lAcessJur := .F.
			Endif
			IF (nT := ascan(aCposDes,'DATABAIXA')) > 0
				lAceDtBxa := .F.
			Endif
			IF (nT := ascan(aCposDes,'DATADEBITO')) > 0
				lAceDtDeb := .F.
			Endif
		Endif
	Endif

	//Aviso ao baixar titulo de Imposto gerado por bordero e baixa do principal ainda nao
	//foi efetuada.
	If lMensagem .and. cPaisLoc == "BRA" .and. !lF080Auto .and. ;
		("FINA241" $ SE2->E2_ORIGEM) .and. lPccBaixa .and. ;
		SE2->E2_TIPO $ MVTAXA .and. ((cNatPis $ E2_NATUREZ).or. ;
		(cNatCof $ E2_NATUREZ ).or. (cNatCsl $ E2_NATUREZ))

		Do Case
		Case Alltrim(E2_NATUREZ) $ AllTrim(GetMv("MV_PISNAT"))
			cValorPai := "SE2->E2_PIS"
			cParcPai := "E2_PARCPIS"
		Case Alltrim(E2_NATUREZ) $ AllTrim(GetMv("MV_COFINS"))
			cValorPai := "SE2->E2_COFINS"
			cParcPai := "E2_PARCCOF"
		Case Alltrim(E2_NATUREZ) $ AllTrim(GetMv("MV_CSLL"))
			cValorPai := "SE2->E2_CSLL"
			cParcPai := "E2_PARCSLL"
		OtherWise
			cValorPai := "SE2->E2_IRRF"
			cParcPai := "E2_PARCIR"
		EndCase

		dbSelectArea("SE2")
		dbSetOrder(1)
		nRegSE2		:= Recno()				
		aArea 	:= SE2->(GetArea())
		cPrefixo	:= SE2->E2_PREFIXO
		cNum		:= SE2->E2_NUM
		cParcela	:= SE2->E2_PARCELA
		cTipoPai := SE2->E2_TIPO
		cFilTit		:= xFilial("SE2",SE2->E2_FILORIG)
		lAchou	:= .F.

		If MsSeek(cFilTit+cPrefixo+cNum)
			While !Eof() .and. SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM) == cFilTit+cPrefixo+cNum
				If &(cParcPai) == cParcela .and. IIF(cTipoPai $ MVTXA,SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,.T.)
					If &(cValorPai) != 0 .and. SE2->E2_SALDO > 0
						lAchou := .T.
						Exit
					EndIf
				EndIf
				DbSkip()
			Enddo
		EndIf

		If lAchou
			IF !MSGYESNO(STR0139+; // "Tentativa de efetuar baixa de titulo de imposto sem que o titulo "
								STR0140,"BXIMPBOR") // "principal tenha sido baixado. Continuar o processo de baixa ?"
				RestArea(aArea)
				Return .F. /*Function fA080Tit*/
			Endif
		Endif
		RestArea(aArea)
	Endif

	// Se for um titulo de adiantamento, verifica se existem cheques nao liberados, pois se existir, nao permitir a baixa
	// Isso ocorre quando o parametro MV_LIBCHEQ esta igual a N, foi gerado um cheque para o adiantamento e este
	// ainda nao foi liberado
	If !lF080Auto .And. Alltrim(SE2->E2_TIPO) $ MVPAGANT
		SEF->(DbSetOrder(3))
		SEF->(MsSeek(xFilial("SEF")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+Pad(E2_NUMBCO,Len(SEF->EF_NUM)))))
		If SEF->EF_LIBER == "N"
			Help(" ",1,"NOCHQADT")
			RestArea(aArea)
			Return (.F.) /*Function fA080Tit*/
		Endif
	Endif

	// Verifica integracao com PMS e nao permite alteracao de titulos que tenham solicitacoes
	// de transferencias em aberto.
	If !( Alltrim(Upper(cFunName)) == "FINA631" .or. (Type("lF631Auto")=="L" .and. lF631Auto) ) .And. (SE2->(FieldPos("E2_NUMSOL")) > 0 .AND. !Empty(SE2->E2_NUMSOL))
		HELP(" ",1,"FIN62003")
		Return .F. /*Function fA080Tit*/
	Endif

	// Nao permitir baixar titulos de adiantamento relacionados a pedido
	If cPaisLoc $ "BRA|MEX|PER"
		If FinAdtSld( "P", SE2->( E2_FORNECE + E2_LOJA + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO ) )
			Help(" ",1,"ADTXPED",,STR0171,1,0) //"Adiantamento relacionado a um pedido. Somente poder?ser utilizado no relacionamento com pedidos."
			Return .F. /*Function fA080Tit*/
		EndIf
	Endif

	// Nao permitir baixar titulos de adiantamento en Argentina
	If cPaisLoc == "ARG" .And. SE2->E2_TIPO $ MVPAGANT .And. Upper(Alltrim(SE2->E2_ORIGEM)) == "FINA850"
		Help(,,STR0145,,STR0248,1,0,,,,,.T., {STR0249})	//	"Anticipo."##"No es posible realizar la baja de pago anticipado desde esta rutina."##"Acceda a Orden Pago Modelo II - Anular Ord. Pago."
		Return .F.
	EndIf

	While .T.
		nTotAGer  := 0 // Variaveis para acumulo dos valores
		nTotADesp := 0 // na baixa
		nTotADesc := 0
		nTotAMul  := 0
		nTotAJur  := 0
		nTotAdto  := 0
		nValPgto := 0
		nCM 	 := 0
		nDescont := 0
		nJuros   := 0
		nMulta   := 0
		nAcrescF  := nAcresc  := SE2->E2_SDACRES
		nDecrescF := nDecresc := SE2->E2_SDDECRE
		lVal4xMil := .F.

		__nAcresc  := nAcresc
		__nDecresc := nDecresc
		
		If (nAcresc+nDecresc) > 0 .And. (nMoedaBco > 1 .Or. SE2->E2_MOEDA > 1)
			nAcreDecre := IIf(nAcresc > 0, nAcresc, nDecresc)
			
			If SE2->E2_MOEDA == 1
				nAcresc := Round(xMoeda(nAcreDecre, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2)
			ElseIf nMoedaBco == 1
				nAcresc := Round(xMoeda(nAcreDecre, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, SE2->E2_TXMOEDA, 0), 2)
			Else
				nAcresc := Round(xMoeda(nAcreDecre, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, SE2->E2_TXMOEDA, nTxMoeda), 2)
			EndIf
			
			If nDecresc > 0			
				nDecresc := nAcresc  	
				nAcresc := 0
			EndIf 
		EndIf
		
		//Ponto de entrada para alterar o valor do acrescimo
		If lF080ACRE
			ExecBlock("F080ACRE",.F.,.F.)
		EndIf

		nPis		:= 0
		nCofins		:= 0
		nCsll		:= 0
		nVlRetPis	:= 0
		nVlRetCof	:= 0
		nVlRetCsl	:= 0
		nDiferImp	:= 0
		cNumBor		:= SE2->E2_NUMBOR

		nIrrf		:= 0
		nVlRetIrf	:= 0
		nBaseIrpf	:= 0
		nIss		:= 0
		nInss		:= 0
		nCide		:= 0
		nBaseIns	:= 0
		nVretInss	:= 0

		//Reestruturacao SE5
		nDescCalc 	:= 0
		nJurosCalc 	:= 0
		nVACalc	 	:= 0
		nMultaCalc 	:= 0
		nCorrCalc	:= 0
		nDifCboCalc	:= 0
		nImpSubCalc	:= 0
		nPisCalc	:= 0
		nCofCalc	:= 0
		nCslCalc	:= 0
		nIrfCalc	:= 0
		nIssCalc	:= 0
		nInsCalc	:= 0
		nPisBaseR 	:= 0
		nCofBaseR	:= 0
		nCslBaseR 	:= 0
		nIrfBaseR 	:= 0
		nIssBaseR 	:= 0
		nInsBaseR 	:= 0
		nPisBaseC 	:= 0
		nCofBaseC 	:= 0
		nCslBaseC 	:= 0
		nIrfBaseC 	:= 0
		nIssBaseC 	:= 0
		nInsBaseC 	:= 0	
		cTpDesc	 := "I"
		_nBasLeg := 0
		__lCpoJuro  := .F.
		__lCpoMult  := .F.
		__lCpoDesc  := .F.		
		__lTxMoeda  := .F.
		lPgtoMaior  := .F.
		__lShoHelp  := .T.
		f080LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo
		
		IF Empty(cBanco) .Or. lJFilBco
			cBanco	:= CriaVar( "E5_BANCO" )
			cAgencia := CriaVar( "E5_AGENCIA")
			cConta	:= CriaVar( "E5_CONTA" )
		Endif

		dbSelectArea("SE2")
		//-----------------------------------------------------------------------
		// Verifica se o Titulo ja foi Baixado Totalmente 						
		//-----------------------------------------------------------------------
		IF (SE2->E2_SALDO + SE2->E2_SDACRES == 0) .or. (!lBxTxa .and. SE2->E2_OK == 'TA' .and. !SE2->E2_TIPO $ MVPAGANT)
			If lIsRussia
				Help(NIL,NIL,"TITBAIXADO", NIL, "", 1, 0, NIL, NIL, NIL, NIL, NIL, {""}) // show only problem description, not solution
			Else
				Help(" ",1,"TITBAIXADO")
			EndIf
			MsUnlock()
			Exit
		EndIF

		//-----------------------------------------------------------------------
		// Verifica se ‚ um registro Principal									
		//-----------------------------------------------------------------------
		IF SE2->E2_TIPO $ MVABATIM
			Help(" ",1,"NAOPRINCIP")
			MsUnlock()
			Exit
		EndIF

		//-----------------------------------------------------------------------
		// Verifica se ‚ um titulo provisorio 									  
		//-----------------------------------------------------------------------
		IF SE2->E2_TIPO $ MVPROVIS .and. !lSubsPrv .and. !lFini055
			Help(" ",1,"TITULOPROV")
			MsUnlock()
			Exit
		EndIF	
		
		If __BordeImp .And. !Empty(SE2->E2_NUMBOR) .And. !SE2->E2_TIPO $ MVPAGANT+"|"+MVPROVIS+"|"+MV_CPNEG
			lRetBor := !BorderoImp(SE2->E2_FILORIG, SE2->E2_NUMBOR, "P", SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA)	 
		Endif
		
		//Motor de retenções.
		If _lTemMR
			F080VldImp(.F.)
		EndIf

		//Identifica se contab. deve ocorrer na baixa ou geração de cheques e se
		//o tipo do titulo for PA e existir cheque deve ser contabilizado
		dbSelectArea("SEF")
		dbSetOrder(3)
		If SE2->E2_TIPO $ MVPAGANT .and. SEF->(dbseek(xFilial("SEF")+SE2->E2_PREFIXO+SE2->E2_NUM+;
			SE2->E2_PARCELA+SE2->E2_TIPO))
			lContabiliza := .T.
		Else
			lContabiliza := IIf(cContabiliza = "B" .Or. cContabiliza = "A", .T., .F.) .and. !lFina450
		EndIf
		dbSelectArea("SE2")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Carrega as variaveis utilizadas para receber os dados do titulo		   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nSalvRec 	:= SE2->(RecNO())
		cNum	  	:= SE2->E2_NUM
		cPrefixo 	:= SE2->E2_PREFIXO
		cParcela 	:= SE2->E2_PARCELA
		cFornece 	:= SE2->E2_FORNECE
		cLoja	  	:= SE2->E2_LOJA
		cTipo		:= SE2->E2_TIPO
		nTotAbat 	:= 0
		nValPadrao 	:= 0
		dAnter 		:= dBaixa
		cMoeda 		:= IIF(Empty(SE2->E2_MOEDA),"1",AllTrim(Str(SE2->E2_MOEDA,2)))
		cDescMoeda  := SubStr(GetMV("MV_SIMB"+cMoeda),1,3)
		dDataCan	:= SE2->E2_DATACAN //FRS - Sit. Titulo

		//Soma Titulos Abatimentos
		nTotAbat := SumAbatPag(cPrefixo, cNum, cParcela, cFornece, SE2->E2_MOEDA, "S", dBaixa, cLoja)
		If lIsRussia .and. aScan(aAutoCab,{|x| x[1]='AUTIDPROC'})  == 0
			nTotAbat+= RU06XFUN56(xFILIAL("SE2") +"|"+ cPrefixo+ "|" + cNum+ "|" +cParcela+ "|" + cTipo + "|" +  cFornece+ "|" + cLoja ) //RU06XFUN56_GetLockedBalance 
		EndIF
		SE2->( dbGoTo( nSalvRec ) )
		lCont := .F.
		nValTot := SE2->E2_VLCRUZ

		//Recompor a base c/ impostos já retidos em outras baixas, para proporcionalizar o valor do imposto corretamente.
		If lMVBP10925
			nValEstrang := SE2->E2_SALDO - nTotAbat
		Else 
			nValEstrang := IiF(!_lPccMR .And. lPccBaixa, SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL), 0) +If(!_lIrfMR .and. lIRPFBaixa, SE2->E2_VRETIRF, 0)+ SE2->E2_SALDO - nTotAbat
		EndIf
		
		If SE2->E2_MOEDA == 1 .And. nValEstrang >= _nImpMR
			nValEstrang -= _nImpMR
		EndIf
		
		nValOrig 	:= nValEstrang
		
		If cPaisLoc == "BRA"
			If SE2->E2_MOEDA > 1 .And. nMoedaBco > 1  
				nValMoeda  := xMoeda(nValOrig, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA ), nTxMoeda)
			Else
				nValMoeda  := xMoeda(nValOrig, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTxMoeda)
			EndIf
			
			nValMoeda1 := (SE2->E2_VALOR-nTotAbat)
			
			If SE2->E2_MOEDA != 1 
				nValMoeda1 := xMoeda(nValMoeda1, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda)
			EndIf
		Else
			nCentMd1 	:= 4
			nValMoeda	:= xMoeda(nValOrig,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,,nTxMoeda)
			nValMoeda1	:= xMoeda(SE2->E2_VALOR-nTotAbat,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,,nTxMoeda)
		EndIf

		nValPgto := (nValMoeda+nMulta+nJuros-nDescont+nAcresc-nDecresc)
		nValLiq  := nValMoeda
		
		If !_lPccMR .And. (nPis+nCoFins+nCsll) > 0 .And. nMoedaBco != 1 
			nVlrImp := Round(xMoeda((nPis+nCoFins+nCsll), 1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2) 
			nValPgto -= nVlrImp
			nValLiq  += nVlrImp
		EndIf
		
		If !_lIrfMR .And. nIrrf > 0 .And. nMoedaBco != 1
			nVlrImp  := Round(xMoeda(nIrrf, 1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2) 
			nValPgto -= nVlrImp
			nValLiq  += nVlrImp
		EndIf
		
		If !_lIssMR .And. nIss > 0 .And. nMoedaBco != 1 
			nVlrImp  := Round(xMoeda(nIss, 1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2) 
			nValPgto -= nVlrImp
			nValLiq  += nVlrImp
		EndIf
		
		nVlrImp := 0
		nOldValPgto	:= nValPgto
		
		If !__BordeImp .And. !Empty(SE2->E2_NUMBOR)
			lRetBor := VLDBOR(cNumBor,"P")
		Endif
		
		If cFunName <> "FINA415" .And. !_lIssMR .And. lCalcIssBx .AND. lGerImp .And. !(SE2->E2_TIPO $ MVPAGANT) .and. lRetBor
			//Calcula ISS na Baixa
			F080IssBx()
		EndIf
		
		//Caso Natureza calcule IRRF de carreteiro
		lCarret := (Posicione("SED",1,xFilial("SED",SE2->E2_FILORIG)+SE2->E2_NATUREZ,"ED_IRRFCAR") == "S")
		
		If SE2->E2_FATURA == "NOTFAT"
			aRet := FinFatAbat(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_FORNECE,SE2->E2_LOJA)
			nTotIss := If(!_lIssMR, aRet[1], 0)
			nTotIns := If(!_lInsMR, aRet[2], 0)
			nTotIrf := If(!_lIrfMR, aRet[3], 0)

			If !_lPccMR
				nTotPis := aRet[4]
				nTotCof := aRet[5]
				nTotCsl := aRet[6]
			EndIf

			nTotSes := If(!_lSesMR, aRet[7], 0)
		Else
			If !_lIssMR
				If !lCalcIssBx
					nTotIss := SE2->E2_ISS - SE2->E2_VRETISS
				Else
					nTotIss := SE2->E2_VRETISS
				EndIf
			EndIf

			nTotIns := If(!_lInsMR, SE2->E2_INSS, 0)
			nTotIrf := If(!_lIrfMR, SE2->E2_VRETIRF, 0)

			If !_lPccMR
				nTotPis := SE2->E2_VRETPIS
				nTotCof := SE2->E2_VRETCOF
				nTotCsl := SE2->E2_VRETCSL
			EndIf

			nTotSes := If(!_lSesMR, SE2->E2_SEST, 0)
		Endif

		If !lCarret
			//Calcula Impostos pela Baixa
			If lValPgto
				//Verificacao se o INSS deve ser abatido do base de calculo do IRRF
				If !lAbatInss .And. (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1"))
					nPgtoIRRF := nValPgto + If(!_lIssMR, (nTotIss - FVRetISSBx()), 0) + If(!_lInsMR, nTotIns, 0)
				ElseIf lAbatInss .And. (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1"))
					nPgtoIRRF := nValPgto + If(!_lIssMR, (nTotIss - FVRetISSBx()), 0)

					If !_lInsMR .And. SA2->A2_TIPO == "J"
						nPgtoIRRF += nTotIns
					EndIf
				Else
					nPgtoIRRF := nValPgto

					If !_lInsMR .And. SA2->A2_TIPO == "J"
						nPgtoIRRF += nTotIns
					EndIf
				Endif
			Else
				If !lAbatInss .And. (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1"))
					//Essa validacao do ISS acompanha a validacao incluida na função F080IssBx(), onde a variável
					//nValPgto só é atualizada se não estiver sendo utilizado IR na Baixa.
					nPgtoIRRF :=  nValPgto + If(!_lIssMR .And. !lCalcIssBx .and. !_lIrfMR .And. lIRPFBaixa, nTotIss, 0) + If(!_lInsMR, nTotIns, 0)
				ElseIf lAbatInss .And. (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1"))
					//Essa validacao do ISS acompanha a validacao incluida na função F080IssBx(), onde a variável
					//nValPgto só é atualizada se não estiver sendo utilizado IR na Baixa.
					nPgtoIRRF :=  nValPgto + If(!_lIssMR .And. !lCalcIssBx .and. !_lIrfMR .And. !lIRPFBaixa, nTotIss, 0)

					If !_lInsMR .And. SA2->A2_TIPO == "J"
						nPgtoIRRF += nTotIns
					EndIf
				Else
					nPgtoIRRF := nValPgto

					If SA2->A2_TIPO == "J"
						nPgtoIRRF += If(!_lInsMR, nTotIns, 0) + If(!_lIssMR .And. !lCalcIssBx .and. !_lIrfMR .And. lIRPFBaixa, nTotIss, 0)//Acacio
					EndIf
				Endif

				If !_lIssMR
					nPgtoIRRF += SE2->E2_VRETISS
				EndIf

			//Soma o valor retido do pcc
				If !_lPccMR
					nPgtoIRRF += nTotPis
					nPgtoIRRF += nTotCof
					nPgtoIRRF += nTotCsl
				EndIf

				//Soma o valor retido do IRRF anteriormente
				If !_lIrfMR .And. lIRPFBaixa
					nPgtoIRRF += nTotIrf
				Endif

			EndIf
		Else
			//Caso seja titulo de carreteiro recompoe base com valor bruto
			nPgtoIRRF :=  nValPgto + If(!_lIssMR, nTotIss, 0) + If(!_lInsMR, nTotIns, 0) + If(!_lSesMR, nTotSes, 0)
			nINSSRet	:=  If(!_lInsMR, nTotIns, 0)

			If !_lInsMR .And. nLimInss > 0 .And. nINSSRet > nLimInss
				nINSSRet := nLimInss
			EndIf
		Endif

		// Cálculo de CIDE na baixa
		If !_lCidMR .And. lCideBX
			nCidBase := salRefPag(SE2->E2_FORNECE + SE2->E2_LOJA, _lPccMR, _lIrfMR, _lInsMR, _lIssMR, _lCidMR, _lSesMR)
			nCide := FCalcCIDE(nCidBase, SE2->E2_NATUREZ, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_FILORIG, SE2->E2_MOEDA, nTxMoeda, dBaixa)
		EndIf

		//Evita o sistema calcular o IRRF para documento de entrada que nao teve retencao
		//de IRRF ( itens ) mesmo possuindo um fornecedor e natureza que calcule (MATA100)
		//Evita também qdo for Rotina Automática - A chamada ocorrerá mais adiante
		If !_lIrfMR .And. lIRPFBaixa .And. FunName() <> "FINA415" .And. lGerImp .And.;
			!FwIsInCallStack('Fa050Subst') .And. !( "MATA100" $ SE2->E2_ORIGEM .And.;
			Empty( SE2->E2_BASEIRF ) .And. Empty( SE2->E2_IRRF ) ) .AND. !lF080Auto

			//Novo calculo de IRRF pela Baixa
			//Calculo para o  IRRF
			//o primeiro parametro, neste caso vai zerado pois o calculo
			//eh feito com base no saldo do titulo
			If lRetBor
				nIRRF := FCalcIRBx(0,SA2->A2_TIPO,dBaixa,dDebito,/*lAltValor*/,/*nTxMoeda*/,/*cMotBx*/)
			Else
				nIRRF := 0 
			EndIf

		EndIf

		// Lei 9.816 de 1999, para determinar a base de cálculo do IRRF
		If lF80L9816 .And. lIRPFBaixa .And. !lF080Auto
			Fa080Irrf(,,,,nIRRF)
		EndIF

		nValPgto -= IF(lMVBP10925 .And. SE2->E2_SALDO != SE2->E2_VALOR,SE2->E2_DECRESC, 0)

		If lPccBaixa .And. lGerImp
			fa080Data(nTxMoeda, /*lButOk*/, /*lHelp*/, /*oDtBaixa*/,aTitCalc)

			//Caso IRRF na Baixa
			//a variavel nValPgto retorna da funcao FA080DATA() com o valor do nIRRF deduzido.
			//Igualo nOldValPgto a nValPgto para que nao se constitua alteracao do valor verificada
			//pela funcao F080TOTMES() e nao gere distorcoes nos calculos do PCC
			nOldValPgto	:= nValPgto

			If (lF080Auto .And. lFina450 .And. (lPCCBaixa .or. lIRPFBaixa) )
				//Caso seja rotina automatica chamada pela rotina de Compensacao entre Carteiras verificar o valor antes de gerar os titulos do PCC.
				aValidGet:= {}
				IF (nT := ascan(aAutoCab,{|x| x[1]='AUTVLRPG'}) ) > 0
					If  (aAutoCab[nT,2]+SE2->((E2_PIS-E2_VRETPIS) + (E2_COFINS-E2_VRETCOF) + (E2_CSLL-E2_VRETCSL)) != SE2->E2_SALDO)

						nValToVld := aAutoCab[nT,2]
						If lPccBaixa
							nValToVld += SE2->((E2_PIS-E2_VRETPIS) + (E2_COFINS-E2_VRETCOF) + (E2_CSLL-E2_VRETCSL))
						Endif
						If lIRPFBaixa
							nValToVld += (E2_IRRF-E2_VRETIRF)
						Endif

						If nValToVld != SE2->E2_SALDO
							Aadd(aValidGet,{'nValPgto' ,aAutoCab[nT,2],"Fa080ValVR("+STR(nTxMoeda,17,nDecTxMd)+")",.t.})

							If !SE2->(MsVldGAuto(aValidGet)) // consiste os gets
								Return .f. /*Function fA080Tit*/
							EndIf
						EndIf
						l450 := .T.
					Endif
				EndIf
			Endif
			
			nValMax := SE2->E2_SALDO

			If cPaisLoc == "BRA" .and. lPCCBaixa 
				If (dBaixa < dLastPcc .Or. lEmpPub)
					f080TotMes(dBaixa,.T.)
				Else
					If lRetBor .And. !lBordero .And. SA2->A2_TIPO <> "F" .And. !SE2->E2_TIPO $ MVPAGANT+"/"+MVPROVIS
						If lFina450
							If nValPgto == SE2->E2_SALDO // só pode retirar os valores dos impostos na emissão na ultima baixa
								nSalImp := nValPgto
								nSalImp += If(_lPccMR .or. lMVBP10925, 0, SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL))
								nSalImp += If(_lIrfMR .or. lIRPFBaixa, 0, SE2->E2_IRRF)
								nSalImp += If(_lIssMR .or. lCalcIssBx, 0, SE2->E2_ISS)
								nSalImp += If(_lInsMR .or. lInssBx,    0, SE2->E2_VRETINS)
							Else
								nSalImp := nValPgto
							EndIf
						Else
							nSalImp := salRefPag(SA2->A2_COD + SA2->A2_LOJA, _lPccMR, _lIrfMR, _lInsMR, _lIssMR, _lCidMR, _lSesMR,, nTxMoeda)
						EndIf

						If SE2->E2_MOEDA > 1 .and. !lFina430
							nSalImp := xMoeda(nSalImp,SE2->E2_MOEDA,1,dBaixa,,SE2->E2_TXMOEDA)
						EndIf

						If !Empty(_nBasLeg)
							nSalImp := _nBasLeg	
						EndIf
						
						nSalImp += F080JuMuDe()

						If !_lPccMR
							aPcc    := newMinPcc(dDataBase, nSalImp,SED->ED_CODIGO,"P",SA2->A2_COD+SA2->A2_LOJA,nIss,nInss,nIRRF, /*lMin*/, /*lIgnrOrg*/, cMotBx,,nTxmoeda)
							nPis    := aPcc[2]
							nCofins := aPcc[3]
							nCsll   := aPcc[4]
							If len(aPCC)>4
								aTitCalc := aPCC[5]
							Endif

							If lFina450 .And. (lMVBP10925 .or. SE2->E2_SALDO == nValPgto)
								nValPgto -= (nPis+nCofins+nCsll)
								noldPcc := nValPgto
							EndIf

							nPisRet  := SE2->E2_VRETPIS + nPis
							nCsllRet := SE2->E2_VRETCSL + nCsll

							If lValidPis .And. SE2->E2_SALDO == nValPgto .And. SE2->E2_MOEDA == 1 .And. nPisRet > SE2->E2_PIS
								If (nPisRet - SE2->E2_PIS) <= ABS(0.01)
									nPis := nPis - 0.01
									nPisRet := 0 
									__lAtuVlr := .T.
								EndIf
							EndIf

							If lValidCsl .And. SE2->E2_SALDO == nValPgto .And. SE2->E2_MOEDA == 1 .And. nCsllRet > SE2->E2_CSLL 
								If (nCsllRet - SE2->E2_CSLL) <= ABS(0.01)
									nCsll := nCsll - 0.01
									nCsllRet := 0 
									__lAtuVlr := .T.
								EndIf
							EndIf
						EndIf
					Else
						nPis	:= 0
						nCofins := 0
						nCsll	:= 0
					EndIf
				EndIf

				If lFa080PCC
					ExecBlock("FA080PCC",.F.,.F.,{nPis, nCofins, nCsll, nIrrf, nSalImp})
				Endif

				//Ponto de entrada para manipular os valores de impostos(nPis, nCofins, nCsll)
				If lImp10925 .and. (nPis+nCofins+nCsll) > 0
					ExecBlock("FA080IMP",.F.,.F.)
				EndIf
			EndIf
		Endif

		//Evita o sistema calcular o IRRF para documento de entrada que nao teve retencao
		//de IRRF ( itens ) mesmo possuindo um fornecedor e natureza que calcule (MATA100)
		If lIRPFBaixa .And. !_lIrfMR .And. !FwIsInCallStack('FINA415') .And. lGerImp .And. !FwIsInCallStack('Fa050Subst') .And.;
			!( "MATA100" $ SE2->E2_ORIGEM .And. Empty( SE2->E2_BASEIRF ) .And. Empty( SE2->E2_IRRF ) )

			//Novo calculo de IRRF pela Baixa
			//Calculo para o  IRRF
			//o primeiro parametro, neste caso vai zerado pois o calculo
			//eh feito com base no saldo do titulo

			cMinParcE2	:= Iif(FindFunction("FinParcSE2"), FinParcSE2(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_FILORIG), cParc1Dup)

			If (!lRatIrrf .AND. ( SE2->E2_DESDOBR == 'S' .Or. AllTrim(SE2->E2_ORIGEM) != "FINA050" ) .AND. SE2->E2_IRRF == 0 .And. !Empty(SE2->E2_PARCELA) .AND. SE2->E2_PARCELA != cMinParcE2 )
				nIrrf := 0
			Else
				//Não calcula IR caso o borderô tenha sido gerado através do FINA241 ou quando é NDF
				If lRetBor .And. !SE2->E2_TIPO $ MV_CPNEG
					nIrrf := FCalcIRBx(0,SA2->A2_TIPO,dBaixa,dDebito,/*lAltValor*/,Iif(nF080TXIR > 0 , nF080TXIR , Nil ),cMotBx)					
				Else
					nIrrf := 0
				Endif
				
				If lFina450 .And. lMVBP10925
					nValPgto -= nIrrf
				Endif
			EndIf
		EndIf

		If lEmpPub
			nTotARet:=0 // Se for empresa pública já foi abatido na função f080TotMes os valores de nPis + nCofins + nCsll + nIrrf, e não deve ser abatido novamente.
		Else
			nTotARet := If(!_lPccMR, (nPis+nCofins+nCsll), 0) + If(!_lIrfMR, nIrrf, 0)
		Endif
		nDiferImp := nSalImp - nTotARet  

		If nDiferImp < 0

			aOutImp := {}
			If !_lPccMR
				aAdd(aOutImp, {"PIS", nPis })
				aAdd(aOutImp, {"COF", nCofins })
				aAdd(aOutImp, {"CSL", nCsll })
			EndIf

			If !_lIrfMR .And. lIRPFBaixa
				aAdd(aOutImp, {"IRF", nIrrf })
			EndIf

			If !_lInsMR .And. lInssBx .And. nInss == 0
				aAdd(aOutImp, {"INS", (SE2->E2_INSS - SE2->E2_VRETINS) })
			EndIf

			If !_lIssMR .And. lCalcIssBx .And. nIss == 0
				aAdd(aOutImp, {"ISS", (SE2->E2_ISS - SE2->E2_VRETISS) })
			EndIf

			aDadosPar := verVrAR(nSalImp, aOutImp ) 
			If !_lPccMR
				nPis    := aDadosPar[1]
				nCofins := aDadosPar[2]
				nCsll   := aDadosPar[3]
			EndIf
		Endif
		
		//Tratamento execauto para não reter PCC
		If lF080Auto .and. !l450  .And. lGerImp .And. !FwIsInCallStack("FA450CMP")
			aValidGet := {}
			
			If (nT := Ascan(aAutoCab, {|x| x[1] == "AUTVLRPG"})) > 0 .And. !FwIsInCallStack("FINA415")
				nPgtoAuto := aAutoCab[nT,2]
			Else
				nPgtoAuto := SE2->E2_SALDO + nVa
				nSalImp   := salRefPag(SA2->(A2_COD+A2_LOJA), _lPccMR, _lIrfMR, _lInsMR, _lIssMR, _lCidMR, _lSesMR)
			EndIf
			
			If nMoedaBco != SE2->E2_MOEDA
				If SE2->E2_MOEDA == 1
					nPgtoAuto := xMoeda(nPgtoAuto, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda)
					nSalImp   := xMoeda(nSalImp, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda)
				ElseIf nMoedaBco == 1
					lAltVlrAut := nPgtoAuto < SE2->E2_SALDO 
					nPgtoAuto := xMoeda(nPgtoAuto, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTxMoeda, 0)
					nSalImp   := xMoeda(nSalImp, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTxMoeda, 0)
				Else
					nPgtoAuto := xMoeda(nPgtoAuto, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, SE2->E2_TXMOEDA, nTxMoeda)
					nSalImp   := xMoeda(nSalImp, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, SE2->E2_TXMOEDA, nTxMoeda)
				EndIf 
			EndIf
			
			If nT > 0					
				If !_lPccMR .And. SE2->(E2_PIS+E2_COFINS+E2_CSLL) > 0
					nVlrImp := SE2->(E2_PIS+E2_COFINS+E2_CSLL) - SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
					
					If SE2->E2_MOEDA > 1
						nVlrImp := xMoeda(nVlrImp, 1, SE2->E2_MOEDA, SE2->E2_EMISSAO, nCasDec, 0, SE2->E2_TXMOEDA)
					EndIf
				EndIf
				
				If Round((aAutoCab[nT,2] + nVlrImp), 0) != SE2->E2_SALDO 
					Aadd(aValidGet, {'nValPgto', nPgtoAuto, "Fa080ValVR(" + STR(nTxMoeda, 17, nDecTxMd) +",,,"+cValtoChar(lIRPFBaixa)+")", .T.})
					
					If !SE2->(MsVldGAuto(aValidGet))
						Return .F.
					EndIf
					
					If nBSCLCPCC > 0
						nSalImp := nBSCLCPCC 
					EndIf
					
					nBSCLCPCC := 0					
				EndIf
				
				nVlrImp := 0  
			EndIf
			
			nValMax := SE2->E2_SALDO

			If lIRPFBaixa .and. !lSubsPrv

				// Lei 9.816 de 1999, para determinar a base de cálculo do IRRF
				If lF80L9816
					IF (nZ := ascan(aAutoCab,{|x| x[1]='AUTDTBAIXA'}) ) > 0
						dBaixa := aAutoCab[nZ,2]				
					EndIf					
					IF (nZ := ascan(aAutoCab,{|x| x[1]='AUTDTDEB'}) ) > 0
						dDebito :=	aAutoCab[nZ,2]				
					EndIf
							
					nF080TXIR := ExecBlock("F80L9816", .F., .F., {SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),;
																 dBaixa,dDebito, 4})
				EndIF	

				//P.E. para mesmo tratamento do P.E acima, criado anteriormente somente para Execauto e mantido aqui para compatibilidade
				If lF080TXIR
					nF080TXIR := FA080TXIR(SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),;
					AllTrim(SE2->E2_ORIGEM), nOpcx, dBaixa)
				EndIf
				If nT == 0 .And. Alltrim(SE2->E2_ORIGEM) <> "MATA100" 
					nValAuto := Iif(SA2->A2_TIPO=="F",SE2->E2_BASEIRF,nSalImp)
				ElseIf nT == 0 .And. AllTrim(SE2->E2_ORIGEM) == "MATA100" 
					nValAuto := SE2->E2_BASEIRF		
				//Mantém a Base do IR do título na baixa do CNAB para não descontar a retenção em duplicidade
				ElseIf lMVCNBImpg .And. FwIsInCallStack("Fa430gera") 
					nValAuto := SE2->E2_BASEIRF	
				Else 
					nValAuto := nPgtoAuto
				EndIf
				nF080TXIR := Iif(nF080TXIR > 0, nF080TXIR, nTxMoeda)
				
				If ( nMoedaBco>1 .Or. (SE2->E2_MOEDA>1 .And.  (lF80L9816 .Or. lF080TXIR)) )

					If nMoedaBco == 1
						nValAuto := xMoeda(nValAuto, 1, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda)
						nValAuto := Round(xMoeda(nValAuto, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nF080TXIR, 0), 2)
					ElseIf SE2->E2_MOEDA == 1
						nValAuto := Round(xMoeda(nValAuto, nMoedaBco, 1, dBaixa, nCasDec, nTxMoeda, 0), 2)
					Else
						nValAuto := xMoeda(nValAuto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, SE2->E2_TXMOEDA, nTxMoeda)
						nValAuto := Round(xMoeda(nValAuto, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nF080TXIR, 0), 2)						
					EndIf
				Else
					/*
					-------------------------------------------------------------------------------------------------------------------------
					Se a variavel nT é 0 , não veio AUTVLRPG no array do execauto.
					Dessa forma precisa passar nValAuto zerado para FCalcIRBx() entender que precisa calcular IR total, caso contrario a função
					se comporta como se o valor de baixa tivesse sido digitado, e não calcula corretamente alguns cenários de cumulatividade .
					-------------------------------------------------------------------------------------------------------------------------
					*/
					nValAuto:=Iif( (nT==0) , 0 , nValAuto)					
				EndIf				
				If !_lIrfMR .And. lRetBor .And. !("MATA100" $ SE2->E2_ORIGEM .And. Empty(SE2->E2_BASEIRF) .And. Empty(SE2->E2_IRRF))
					nIRRF := FCalcIRBx(nValAuto, SA2->A2_TIPO, dBaixa, dDebito, lAltVlrAut, nF080TXIR, cMotBx, Nil, Nil, Nil)
				Else
					nIRRF := 0
				EndIf
			EndIf

			If cPaisLoc == "BRA" .AND. lPCCBaixa
				If (dBaixa < dLastPcc .Or. lEmpPub)
					f080TotMes(dBaixa,.T.)
				Else
					If !SE2->E2_TIPO $ MVPAGANT+"/"+MVPROVIS .And. lRetBor
						If !_lPccMR

							IF (nT := ascan(aAutoCab,{|x| x[1]='AUTMULTA'}) ) > 0
								nMulta :=  aAutoCab[nT,2]
							EndIf

							If !lAltVlrAut //Baixa total por execauto
								nSalImp := salRefPag(SA2->A2_COD+SA2->A2_LOJA)	
								If SE2->E2_MOEDA > 1
									nSalImp := xMoeda(nSalImp,SE2->E2_MOEDA,1,dBaixa,3,nTxMoeda)
								EndIf
								nSalImp += F080JuMuDe()
							Else
								nSalImp := nPgtoAuto //baixa parcial por execauto
								If !lJurMulDes .And. !(nValPgto - nMulta - nJuros + nDescont > xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoedaBco,dBaixa,3,nTxMoeda))
									nSalImp := nSalImp - nMulta - nJuros - nAcresc + nDescont + nDecresc
								EndIf
							Endif
							
							If (Len(aPcc) == 0 .Or. lF080Auto) .And. !lFINA430
								aPcc    := newMinPcc(dDataBase, nSalImp,SED->ED_CODIGO,"P",SA2->A2_COD+SA2->A2_LOJA, /*nIss*/, /*nIns*/, /*nIrf*/, /*lMin*/, /*lIgnrOrg*/, cMotBx,,nTxmoeda)
								nPis    := aPcc[2]
								nCofins := aPcc[3]
								nCsll   := aPcc[4]
								If len(aPCC)>4
									aTitCalc := aPCC[5]
								Endif

								nPisRet  := SE2->E2_VRETPIS + nPis
								nCsllRet := SE2->E2_VRETCSL + nCsll

								If lValidPis .And. SE2->E2_SALDO == nValPgto .And. SE2->E2_MOEDA == 1 .And. nPisRet > SE2->E2_PIS
									If (nPisRet - SE2->E2_PIS) <= ABS(0.01)
										nPis := nPis - 0.01
										nPisRet := 0 
										__lAtuVlr := .T.
									EndIf
								EndIf

								If lValidCsl .And. SE2->E2_SALDO == nValPgto .And. SE2->E2_MOEDA == 1 .And. nCsllRet > SE2->E2_CSLL 
									If (nCsllRet - SE2->E2_CSLL) <= ABS(0.01)
										nCsll := nCsll - 0.01
										nCsllRet := 0
										__lAtuVlr := .T.
									EndIf
								EndIf
							EndIf
						Endif
					Else
						nPis	:= 0
						nCofins := 0
						nCsll	:= 0
					EndIf
				EndIf

				If lFa080PCC
					ExecBlock("FA080PCC",.F.,.F.,{nPis, nCofins, nCsll, nIrrf, nSalImp})
				Endif

				//Ponto de entrada para manipular os valores de impostos(nPis, nCofins, nCsll)
				If lImp10925 .and. (nPis+nCofins+nCsll) > 0
					ExecBlock("FA080IMP",.F.,.F.)
				EndIf
			EndIf
			If !lAltVlrAut .or. (lAltVlrAut .and. lMVBP10925)				
				nPcc := Iif(_nPisMR+_nCofMR+_nCslMR > 0,_nPisMr+_nCofMR+_nCslMR ,nPis+nCoFins+nCsll)

				If nPcc > 0 
					nPgtoAuto -= Round(xMoeda(nPcc, 1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2)
				EndIf
				
				If nIrrf > 0 .Or. _nIrfMR > 0 
					nPgtoAuto -= Round(xMoeda(Iif(_nIrfMR > 0,_nIrfMR,nIrrf), 1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2)
				EndIf
				
				If nIss > 0 .Or. _nIssMR > 0
					nPgtoAuto -= Round(xMoeda(Iif(_nIssMr > 0,_nIssMR,nIss), 1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2)
				EndIf						
				
				nPgtoAuto += nJuros + nMulta + nAcresc - nDescont - nDecresc				
				nValPgto := nPgtoAuto
				nOldValPgto := nValPgto
			EndIf
		Endif
		
		If SE2->E2_TIPO $ MV_CPNEG // NDF nao deve calcular imposto
			nPis := nCoFins := nCsll  := 0
		EndIf
		
		//Guardo o valor dos impostos calculados para diferenciar quando os mesmos
		//forem digitados manualmente pelo usuario
		If lEmpPub .And. lAplMinP .And. (nPis+nCoFins+nCsll+nIrrf+aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5]< nVlMPub .And.;
			!(aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] == 0 .And. aDadosRet[1] > 0))
			nPis := nCoFins := nCsll := nIrrf := 0
		EndIf
		
		nVlImpPCC := If(!_lPccMR, nPis+nCoFins+nCsll, 0)

		IF (nMulta+nJuros+nVA+nDescont+nAcresc+nDecresc+nVlImpPCC+nIrrf+nIss) > 0 .OR. Round(nValEstrang - xMoeda(nValPgto,nMoEdaBco,SE2->E2_MOEDA,dBaixa,,,nTxMoeda),2 ) > 0.01
			If lAltVlrAut .and. lMVBP10925
				nValEstrang := Round(NoRound(xMoeda(nValPgto-nMulta-nJuros-nVA+nDescont-nAcresc+nDecresc,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
			else
				nValEstrang := Round(NoRound(xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
			EndIf

			If cTipoCm == "T" .and. nVlImpPCC+nIrrf+nIss>0
				FA080CORR(nEstOriginal,nTxMoeda) 
			EndIf

		EndIF

		nValLiq := nValPgto-nMulta-nJuros-nVA+nDescont-nAcresc+nDecresc+nVlImpPCC + If(!_lIrfMR, nIrrf, 0) + If(!_lIssMR, nIss, 0)

		If SE2->E2_MOEDA == 1
			nCm:=0
		Endif

		SA2->( dbseek( xFilial("SA2",SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA))
		cNomeFor := SE2->E2_FORNECE + " " + SA2->A2_NOME
		cTitulo := SE2->E2_PREFIXO + " " + SE2->E2_NUM+ " " + SE2->E2_PARCELA
		nPagtoParcial := SE2->E2_VALOR-SE2->E2_SALDO
		cTexto := OemToAnsi(STR0101)+ SubStr(GetMV("MV_SIMB"+cMoeda),1,3)  //"Valor Original "

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³PONTO DE ENTRADA FA080POS  ³
		//³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Permite a alteração de vari veis apos carga de dados do t¡tulo a ser ³
		//³ baixado, antes das informa‡äes serem mostradas na Tela.              ³
		//³ Vari veis dispon¡veis para serem alteradas :                         ³
		//³                                                                      ³
		//³ cBanco , cAgencia, cConta, cCheque                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lFA080POS
			ExecBlock("FA080POS",.F.,.F.)
			SE2->(dbGoTo(nSalvRec))
			reposSA6()
		Endif

		If cPaisLoc <> "BRA" .And. !lF415Auto
			nTxMoeda   := RecMoeda(dBaixa,SE2->E2_MOEDA)
			nDifCambio := ( Round( (SE2->E2_VALOR * nTxMoeda), nCentMd1) - SE2->E2_VLCRUZ )
		EndIf

		lNatApura	:=	.F.
		If cPaisLoc == "BRA"
			aAreaSED 	:= SED->(GetArea())
			DbSelectArea("SED")
			DbSetOrder(1)
			If DbSeek(xFilial("SED")+ SE2->E2_NATUREZ) .And. lCposSped
				If ( !Empty(SED->ED_APURCOF) .Or. !Empty(SED->ED_APURPIS) ) .OR. ( lEdJur .and. SED->ED_JURSPD == "1" )			
				
					lNatApura	:=	.T. //Natureza configurada para apurar impostos no SPED PIS/COFINS.
				Endif
			Endif
			RestArea(aAreaSED)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³PONTO DE ENTRADA FA080ACES ³
		//³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Permite ou nao que o usuario altere os valores dos impostos da lei 10925 ³
		//³ calculados automaticamente pelo sistema.                                 ³
		//³ Vari veis dispon¡veis para serem alteradas :                             ³
		//³                                                                          ³
		//³ lAcessImp ( .T. - PERMITE  /  .F. - NAO PERMITE )						 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lFA080ACES
			lAcessImp := ExecBlock("FA080ACES",.F.,.F.)
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicializa a gravacao dos lancamentos do SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		PcoIniLan("000005")

		//Reestruturacao SE5
		//Obtenho os valores calculados de juros, multas, descontos etc
		nDescCalc 	:= nDescont + nDecresc
		nJurosCalc 	:= IIf(cPaisLoc<>"CHI",nJuros + nAcresc,nOtrga)
		nMultaCalc 	:= nMulta
		nVACalc 	:= nVA
		nCMCalc		:= IIf(cPaisLoc<>"CHI",nCM,nDifCambio)
		nDifCambio	:= nDifCambio
		nImpSubCalc	:= nImpSubst

		If !lF080Auto
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Recebe os dados do t¡tulo a ser baixado 							 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nOpc1 := 0
			// Carrega as variaveis bancarias
			Fa080BDev(.F.)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Pr‚-inicializa a modalidade de SPB                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lSpbInUse
				If !Empty(SE2->E2_MODSPB)
					cModSpb := SE2->E2_MODSPB
				Else
				cModSpb := "1"
				Endif
			Endif

			If lPaisMI
				cCadastro := OemToAnsi(STR0003)	// "Dar de baja"
			EndIf

			DEFINE MSDIALOG oDlg FROM	31,15 TO 640,574 TITLE OemToAnsi(STR0007)  PIXEL OF oMainWnd //"Baixas a Pagar"

			//Faz o calculo automatico de dimensoes de objetos
			oSize := FwDefSize():New(.T.,,,oDlg)

			oSize:lLateral := .F.
			oSize:lProp	:= .T. // Proporcional
			
			oSize:AddObject( "1STROW" ,  100, 19, .T., .T. ) // Totalmente dimensionavel
			oSize:AddObject( "2NDROW" ,  100, 81, .T., .T. ) // Totalmente dimensionavel

			oSize:Process() // Dispara os calculos

			a1stRow := {oSize:GetDimension("1STROW","LININI"),;
						oSize:GetDimension("1STROW","COLINI"),;
						oSize:GetDimension("1STROW","LINEND"),;
						oSize:GetDimension("1STROW","XSIZE")}

			a2ndRow := {oSize:GetDimension("2NDROW","LININI"),;
						oSize:GetDimension("2NDROW","COLINI"),;
						oSize:GetDimension("2NDROW","LINEND"),;
						oSize:GetDimension("2NDROW","XSIZE")}

			If IsPanelFin()
				@ 000, a1stRow[2] + 000 GROUP oMyBar  TO a1stRow[1] - 1, (a1stRow[4]-7) OF oDlg PIXEL 
                @ 010, a1stRow[2] + 008 SAY cCadastro+" - "+Upper(STR0003) FONT oFont24 COLOR CLR_HBLUE OF oDlg PIXEL //"BAIXAR"
			Endif

			@ a1stRow[1] + 000, a1stRow[2] + 000 GROUP oGrp1  TO a1stRow[3], (a1stRow[4]-7) LABEL STR0015 OF oDlg PIXEL //"Principal"
			@ a2ndRow[1] + 000, a2ndRow[2] + 000 GROUP oGrp2  TO a2ndRow[3], 135 LABEL STR0013 OF oDlg  PIXEL //"Dados Gerais"
			@ a2ndRow[1] + 000, a2ndRow[2] + 139 GROUP oGrp3  TO a2ndRow[3], (a2ndRow[4]-7) LABEL STR0014 OF oDlg  PIXEL //"Valores da Baixa"

			If lUsaCmc7
				aCmc7:=LjLeCmc7(1)
				If Len(aCmc7) > 0
					cBanco  :=aCmc7[1]
					cAgencia:=aCmc7[2]
					cConta  :=aCmc7[3]
					cCheque :=aCmc7[4]
				Endif
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ\¿
			//³Ponto de Entrada para o escolher se a data exibida é a E2_VENCREA ou a E2_VENCTO³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ\Ù
			If Type("dBxDt_Venc") == "U"
				dBxDt_Venc := SE2->E2_VENCREA
			EndIf
			
			If lIsRussia
				cHist070 := STR0230
			EndIf
			//DADOS DO TITULO
			@ a1stRow[1] + 008, a1stRow[2] + 004 SAY STR0092			SIZE 31,07 OF oDlg PIXEL //Prefixo
			@ a1stRow[1] + 008, a1stRow[2] + 027 MSGET SE2->E2_PREFIXO	SIZE 25,08 OF oDlg PIXEL When .F.
			@ a1stRow[1] + 008, a1stRow[2] + 060 SAY STR0093 			SIZE 31,07 OF oDlg PIXEL //Numero
			@ a1stRow[1] + 008, a1stRow[2] + 085 MSGET SE2->E2_NUM		SIZE 70,08 OF oDlg PIXEL When .F.
			@ a1stRow[1] + 008, a1stRow[2] + 165 SAY STR0094 			SIZE 31,07 OF oDlg PIXEL //Parcela
			@ a1stRow[1] + 008, a1stRow[2] + 188 MSGET SE2->E2_PARCELA	SIZE 25,08 OF oDlg PIXEL When .F.
			@ a1stRow[1] + 008, a1stRow[2] + 220 SAY STR0095			SIZE 31,07 OF oDlg PIXEL //Tipo
			If lIsRussia
				// standard query for E2_TIPO. We can't change cTipo and we don't need it. Real purpose: see what types there are and their descriptions
				@ a1stRow[1] + 008, a1stRow[2] + 238 MSGET oTipo VAR cTipo	F3 "05" SIZE 30,08 OF oDlg PIXEL HASBUTTON
			Else
				@ a1stRow[1] + 008, a1stRow[2] + 238 MSGET oTipo VAR cTipo	F3 "SE2RDO" SIZE 30,08 OF oDlg PIXEL HASBUTTON
			EndIf
			oTipo:lReadOnly := .T.

			@ a1stRow[1] + 020, a1stRow[2] + 004 SAY STR0019 SIZE 22,07 OF oDlg PIXEL //"Fornecedor"
			@ a1stRow[1] + 020, a1stRow[2] + 027 MSGET oCodFor VAR SE2->E2_FORNECE F3 "SA2" SIZE 70,08 OF oDlg PIXEL HASBUTTON
			oCodFor:lReadOnly := .T.
			If __lLGPD 
				@ a1stRow[1] + 020, a1stRow[2] + 105 MSGET oNomFor VAR SA2->A2_NOME SIZE 165,08 OF oDlg PIXEL When .F. OBFUSCATED RetGlbLGPD("A2_NOME")
			Else
				@ a1stRow[1] + 020, a1stRow[2] + 105 MSGET oNomFor VAR SA2->A2_NOME SIZE 165,08 OF oDlg PIXEL When .F. 
			EndIf	
			@ a1stRow[1] + 032, a1stRow[2] + 004 SAY STR0098 			SIZE 31,07 OF oDlg PIXEL //"Natureza"
			@ a1stRow[1] + 032, a1stRow[2] + 027 MSGET oNaturez VAR SE2->E2_NATUREZ	F3 "SED" SIZE 70,08 OF oDlg PIXEL HASBUTTON
			oNaturez:lReadOnly := .T.
			@ a1stRow[1] + 032, a1stRow[2] + 105 SAY STR0017 			SIZE 31,07 OF oDlg PIXEL //"Emiss„o"
			@ a1stRow[1] + 032, a1stRow[2] + 133 MSGET SE2->E2_EMISSAO	SIZE 48,08 OF oDlg PIXEL When .F. HASBUTTON
			@ a1stRow[1] + 032, a1stRow[2] + 189 SAY STR0018 			SIZE 49,07 OF oDlg PIXEL //"Vencto.Atual"
			@ a1stRow[1] + 032, a1stRow[2] + 222 MSGET SE2->E2_VENCREA	SIZE 48,08 OF oDlg PIXEL When .F. HASBUTTON

			//////////////////
			//DADOS GERAIS

			nUltLin := 10 + a2ndRow[1]

			@ nUltLin,005 SAY OemToAnsi(STR0020)	SIZE 38,07 OF oDlg PIXEL //"Hist.Emiss„o"
			@ nUltLin,065 MSGET SE2->E2_HIST 		SIZE 65, 08 OF oDlg PIXEL HASBUTTON When .F.

			nUltLin += 12
			@ nUltLin,005 SAY OemToAnsi(STR0021)	SIZE 39,07 OF oDlg PIXEL //"Portador"
			@ nUltLin,065 MSGET cPortado				SIZE 65, 08 OF oDlg PIXEL HASBUTTON When .F.

			nUltLin += 12
			@ nUltLin,005 SAY OemToAnsi(STR0029)	SIZE 37,07 OF oDlg PIXEL //"Mot.Baixa"

			@ nUltLin,065 MSCOMBOBOX oCbx VAR cMotBx ITEMS aDescMotbx SIZE 65,47 OF oDlg PIXEL ; //"Alterando o Mot. Baixa"
			WHEN f080DMotBx(cMotBx) ON CHANGE (fa080ChkVdr(),oBanco:lReadOnly := !fa080digit(),if(MovBcoBx(cMotBx, .T. )<>MovBcoBx(cOldMotBx,.T.), ;
				if((dBaixa < dLastPcc .Or. lEmpPub), F080TotMes(dBaixa,.T.),fa80AltTela(nTxMoeda, ,cMotBx, cOldMotBx,aTitCalc) .and.;
															  Fa080Refr(oJuros, oMulta, oDescont, oDtBaixa, oTxMoeda)),)) ;
				Valid fa080BDev() .and. F080MtBx() .AND. F080SPB(@lSpbInUse,@cClearing,@cTipoPgto,@cStored,@cHora) .and. FA080VlNat(cMotBx)

			nUltLin += 18
			@ nUltLin,005 SAY OemToAnsi(STR0022)	SIZE 40,07 OF oDlg PIXEL //"Banco"
			@ nUltLin,065 MSGET oBanco VAR cBanco 	SIZE 65, 08 OF oDlg PIXEL HASBUTTON F3 cF3Bco ;
				Valid (!MovBcobx(cMotBx, .T.) .and. Empty(cBanco)) .or. ;
						(Iif(lVldBcoFin, FinVldBco(@cBanco,@cAgencia,@cConta,MovBcoBx(cOldMotBx,.T.),.F., oAgencia),;
						CarregaSA6(@cBanco,@cAgencia,@cConta,MovBcoBx(cOldMotBx,.T.))) .and. fa080BcoCx() .And. ;
						FaPrNumChq(cBanco,cAgencia,cConta,@oCheque,@cCheque) .And. ;
						fa80AltTela(@nTxMoeda, ,cMotBx, cOldMotBx,aTitCalc) .and.;
						Fa080Refr(oJuros, oMulta, oDescont, oDtBaixa, oTxMoeda);
						.And. Iif(lJFilBco, JurVldSA6("1", {cEscrit, cBanco, cAgencia, cConta}), .T.))
			oBanco:lReadOnly := !fa080digit()

			nUltLin += 12
			@ nUltLin,005 SAY OemToAnsi(STR0023)	SIZE 39,07 OF oDlg PIXEL //"Agˆncia"
			@ nUltLin,065 MSGET oAgencia VAR cAgencia	SIZE 65, 08 OF oDlg PIXEL HASBUTTON When fa080digit() ;
			Valid Iif(lVldBcoFin, FinVldBco(@cBanco,@cAgencia,@cConta,.F.,.F., oConta),;
					CarregaSA6(@cBanco,@cAgencia,@cConta,.F.)) .And. ;
					FaPrNumChq(cBanco,cAgencia,cConta,@oCheque,@cCheque) .And. ;
					fa80AltTela(@nTxMoeda,,,,aTitCalc) .and.;
					Fa080Refr(oJuros, oMulta, oDescont, oDtBaixa, oTxMoeda);
					.And. Iif(lJFilBco, JurVldSA6("2", {cEscrit, cBanco, cAgencia, cConta}), .T.)

			nUltLin += 12
			@ nUltLin,005 SAY OemToAnsi(STR0024)	SIZE 41,07 OF oDlg PIXEL //"Conta"
			@ nUltLin,065 MSGET oConta VAR cConta 	SIZE 65, 08 OF oDlg PIXEL HASBUTTON When fa080digit() ;
			Valid If(Iif(lVldBcoFin, FinVldBco(@cBanco,@cAgencia,@cConta,.T.,.T., oBanco),;
					CarregaSA6(@cBanco,@cAgencia,@cConta,.T.,,.T.)) .And. ; 
					( FXVldBxBco( cBanco, cAgencia, cConta, SE2->E2_NATUREZ, SE2->E2_MOEDA, , oBanco ) ), ;
					FaPrNumChq(cBanco,cAgencia,cConta,@oCheque,@cCheque) .And. fa80AltTela(@nTxMoeda,,,,aTitCalc).and.;
					Fa080Refr(oJuros, oMulta, oDescont, oDtBaixa, oTxMoeda),oBanco:SetFocus();
					.And. Iif(lJFilBco, JurVldSA6("3", {cEscrit, cBanco, cAgencia, cConta}), .T.))
			
			nUltLin += 12
			@ nUltLin,005 SAY OemToAnsi(STR0027)	SIZE 40,07 OF oDlg PIXEL //"Cheque No."
			@ nUltLin,065 MSGET oCheque VAR cCheque	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict( "SEF","EF_NUM") When IIf(__lLGPD, !RetGlbLGPD("EF_NUM"), .T.) .and. ( IIf( !lF080VCheq, fa080digit(), Execblock("F080VCHEQ", .F.,.F.)) .and. faDigiChq());
			Valid fa080Cheq() .AND. checkAcento()

			nUltLin += 12
			@ nUltLin,005 SAY OemToAnsi(STR0025)	SIZE 38,07 OF oDlg PIXEL //"Data Pagto."
			@ nUltLin,065 MSGET oDtBaixa VAR dBaixa 			SIZE 65, 08 OF oDlg PIXEL HASBUTTON;
																ON CHANGE (lDtPag:=.T.,iif((dBaixa < dLastPcc .Or. lEmpPub), f080TotMes(dBaixa,.T.,,,dOldData # dBaixa),),If(lIRPFBaixa.and.FunName()<>"FINA415", Fa080Irrf(nPgtoIRRF,dBaixa,lCarret,.T.,nOldIrrf) , .T.), Iif(lIRPFBaixa .and. nIrrf > 0 .and. nValPgto < 0 .and. cNccIr == "1", nValPgto := nIrrf, nValPgto));
																Valid Iif(dOldData # dBaixa, fa080Data(@nTxMoeda,,.T.,oDtBaixa,aTitCalc), .T.) .and. Iif(SuperGetMv("MV_BXDTFIN",,"1") == "2", DtMovFin(dBaixa,,"1"), .T.);
																When lAceDtBxa
			dOldData := dBaixa

			nUltLin += 12
			@ nUltLin,005 SAY OemToAnsi(STR0149)	SIZE 38,07 OF oDlg PIXEL //"Data Debito"
			@ nUltLin,065 MSGET oDtDebito		VAR dDebito 			SIZE 65, 08 OF oDlg PIXEL HASBUTTON;
																		ON CHANGE (lDtPag:=.T.,iif((dBaixa < dLastPcc .Or. lEmpPub),f080TotMes(dDebito,.T.,,,dOldData # dDebito),),If(lIRPFBaixa.and.FunName()<>"FINA415", Fa080Irrf(nPgtoIRRF,dDebito,lCarret,.T.,nOldIrrf) , .T.), Iif(lIRPFBaixa .and. nIrrf > 0 .and. nValPgto < 0 .and. cNccIr == "1", nValPgto := nIrrf, nValPgto));
																		Valid (IIf(dDebito > dBaixa, fa080Data(@nTxMoeda, /*lButOk*/, /*lHelp*/, /*oDtBaixa*/,aTitCalc),.T.) .and. Iif(SuperGetMv("MV_BXDTFIN",,"1") == "2", DtMovFin(dDebito,,"1"), .T.));
																		When lAceDtDeb

			nUltLin += 12
			@ nUltLin,005 SAY OemToAnsi(STR0026)	SIZE 39,07 OF oDlg PIXEL //"Hist.Baixa"
			@ nUltLin,065 MSGET cHist070			SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture "@!" VALID CheckSX3("E5_HISTOR") .AND. checkAcento() When VisualSX3("E5_HISTOR")

			nUltLin += 12
			@ nUltLin,005 SAY OemToAnsi(STR0028)	SIZE 36,07 OF oDlg PIXEL //"Beneficiário"
			If __lLGPD  
				@ nUltLin,065 MSGET oBenef VAR cBenef			SIZE 65, 08 OF  oDlg PIXEL HASBUTTON Picture "@!" When cNivel >= NivelSx3("E5_BENEF") .and. fa080digit() VALID checkAcento()  OBFUSCATED RetGlbLGPD("E5_BENEF")
			Else
				@ nUltLin,065 MSGET oBenef VAR cBenef			SIZE 65, 08 OF  oDlg PIXEL HASBUTTON Picture "@!" When cNivel >= NivelSx3("E5_BENEF") .and. fa080digit() VALID checkAcento()
			EndIf		

			If cPaisLoc == "BRA" .And. SE2->E2_MOEDA > 1 
				nUltLin += 12
				@ nUltLin,005 SAY STR0129 	SIZE 53, 07 OF oDlg PIXEL //"Taxa contratada"
				@ nUltLin,065 MSGET oTxMoeda VAR nTxMoeda SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict( "SM2","M2_MOEDA"+AllTrim(Str(SE2->E2_MOEDA))) ;
				Valid fa80AltTela(nTxMoeda,,,,aTitCalc) 
				nOldTxMoed := nTxMoeda
			Endif
			If lSpbInUse
				nUltLin += 12
				@ nUltLin,005 SAY STR0128 SIZE 32, 07 OF oDlg PIXEL  //"Modalidade SPB"
				@ nUltLin,065 COMBOBOX oModSPB VAR cModSpb ITEMS aModalSpb SIZE 56, 47 OF oDlg PIXEL ;
									When MovBcoBx(cMotBx,.T.)
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Somente exibe a opcao Rateio Multiplas Naturezas se parametro MV_MULNATP = .T.  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If MV_MULNATP
				nUltLin += 12
				@ nUltLin,005 SAY STR0132 SIZE 100, 07 OF oDlg PIXEL	 //"Rateio Mult.Naturezas"
				@ nUltLin,065 CHECKBOX oMultNat VAR lMultNat PROMPT "" SIZE 11,11 OF oDlg PIXEL
			Endif

			//DADOS DA BAIXA
			nUltLin := 10 + a2ndRow[1]
			If cPaisLoc <> "CHI"
				nValOrigem	:= SE2->E2_VALOR

				@ nUltLin,144 SAY cTexto 				SIZE 53,07 OF oDlg PIXEL COLOR CLR_HBLUE //"Valor Original"
				@ nUltLin,210 MSGET SE2->E2_VALOR		SIZE 65, 08 OF oDlg PIXEL HASBUTTON When .F. Picture PesqPict("SE2","E2_VALOR")

				nUltLin += 12
				@ nUltLin,144 SAY OemToAnsi(STR0035)	SIZE 53,07 OF oDlg PIXEL //"- Abatimentos"
				@ nUltLin,210 MSGET nTotAbat			SIZE 65, 08 OF oDlg PIXEL HASBUTTON When .F. Picture PesqPict("SE2","E2_VALOR")
			Else
				@ nUltLin,144 SAY OemToAnsi(STR0034) 	SIZE 53,07 OF oDlg PIXEL COLOR CLR_HBLUE //"Valor Original"
				@ nUltLin,210 MSGET SE2->E2_VLCRUZ		SIZE 65, 08 OF oDlg PIXEL HASBUTTON When .F. Picture PesqPict("SE2","E2_VLCRUZ")

				nUltLin += 12
				@ nUltLin,144 SAY OemToAnsi(STR0118)	SIZE 53,07 OF oDlg PIXEL //"+ Imposto Subst."
				@ nUltLin,210 MSGET oImpSubst VAR nImpSubst	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_IMPSUBS") Valid Fa080Val(nImpSubst,nTxMoeda,,,,,,aTitCalc) When !lOFINI055
			EndIf

			nUltLin += 12
			@ nUltLin,144 SAY OemToAnsi(STR0036)  		SIZE 53,07 OF oDlg PIXEL //"- Pagtos.Parciais"
			@ nUltLin,210 MSGET nPagtoParcial			SIZE 65, 08 OF oDlg PIXEL HASBUTTON When .F. Picture PesqPict("SE2","E2_VALOR")

			nUltLin += 12
			@ nUltLin,144 SAY OemToAnsi(STR0120)    	SIZE 53,07 OF oDlg PIXEL //"+ Acrescimo"
			@ nUltLin,210 MSGET oAcresc VAR nAcrescF	SIZE 65, 08 OF oDlg PIXEL HASBUTTON When .f. Picture PesqPict("SE2","E2_SDACRES")

			nUltLin += 12
			@ nUltLin,144 SAY OemToAnsi(STR0121)		SIZE 53,07 OF oDlg PIXEL //"- Decrescimo"
			@ nUltLin,210 MSGET oDecresc VAR nDecrescF	SIZE 65, 08 OF oDlg PIXEL HASBUTTON When .f. Picture PesqPict("SE2","E2_SDDECRE")

			If SE2->E2_IMPCHEQ == "S" .and. SE2->E2_JUROS > 0
				nJuros := SE2->E2_JUROS
			Endif
			If nJuros > 0 .and. SE2->E2_MOEDA >1 .AND. nMoedaBco > 1 .AND. SE2->E2_MOEDA <> nMoedaBco
				nJuros:= Round(Noround(xMoeda(nJuros,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,SE2->E2_TXMOEDA,nTxMoeda),nCentMd1+1),nCentMd1)
			EndIf
			
			/*-----------------------------+
            | Integração SIGAMNT x SIGAFIN |
            +-----------------------------*/
            If lIntMNT .And. AllTrim( SE2->E2_ORIGEM ) $ 'MNTA765/MNTA766'

                If lMNTIntFin

                    MNTIntFin( @nDescont, @nOldDescont )

                Else

                    nDescont := IntegMnta()

                EndIf

            EndIf

			If lCOL4XMIL
				 lVal4xMil := FINX4XMIL(SE2->E2_NUM,SE2->E2_PREFIXO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_EMISSAO)
			EndIf
			nUltLin += 12
			@ nUltLin,144 SAY OemToAnsi(STR0037)	   	SIZE 53,07 OF oDlg PIXEL //"- Descontos"
			@ nUltLin,210 MSGET oDescont VAR nDescont	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_DESCONT") Valid Iif(nOldDescont # nDescont,;
			(Fa080Val(nDescont,nTxMoeda,.T.,,,,,aTitCalc),nOldDescont := nDescont,Fa080Desc(lTpDesc,lNatApura)), .T.) When lAcessDes .and. !lVal4xMil

			nUltLin += 12
			@ nUltLin,144 SAY OemToAnsi(STR0038)		SIZE 53,07 OF oDlg PIXEL //"+ Multa"
			@ nUltLin,210 MSGET oMulta VAR nMulta 		SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_MULTA") Valid Iif(nOldMulta # nMulta, (Fa080Val(nMulta,nTxMoeda,.T.,.T.,,.T.,,aTitCalc),nOldMulta := nMulta), .T.) When lAcessMul .and. !lVal4xMil
			nOldMulta := nMulta

			If cPaisLoc <> "CHI"
				nUltLin += 12
				@ nUltLin,144 SAY OemToAnsi(STR0039)  	SIZE 53,7 OF oDlg PIXEL //"+ Tx.Permanenc."
				@ nUltLin,210 MSGET oJuros VAR nJuros 	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_JUROS") Valid Iif(nOldJuros # nJuros, (Fa080Val(nJuros,nTxMoeda,.T.,,,.T.,,aTitCalc),nOldJuros := nJuros), .T.) When lAcessJur .and. !lVal4xMil

				nOldJuros := nJuros
			Else
				nUltLin += 12
				@ nUltLin,144 SAY OemToAnsi(STR0117)  	SIZE 53,7 OF oDlg PIXEL //"+ Outros Gastos"
				@ nUltLin,210 MSGET nOtrga 			SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_OTRGA") Valid Iif(nOldJuros # nOtrga, (Fa080Val(nOtrga,nTxMoeda,,,,,,aTitCalc),nOldJuros := nOtrga), .T.);
				When  !lOFINI055

				nOldJuros := nOtrga
			EndIf

			// Valores acessórios.
			If __lPodeTVA .and. FAPodeTVA(SE2->E2_TIPO, SE2->E2_NATUREZ, .F., "P")
				nUltLin +=12
				@ nUltLin,144 SAY STR0204	SIZE 53,07 OF oDlg PIXEL  // "Valores Acessórios"
				@ nUltLin,210 MSGET oVA VAR nVA SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("FKD","FKD_VALOR") When  .F.
				nOldVA := nVA
			EndIf

			nLinha := nUltLin
			//Get do ISS na baixa
			If (!_lTemMR .Or. !_lIssMR) .And. lCalcIssBx
				nLinha +=12
				@ nLinha,144 SAY "- Iss"	SIZE 53,07 OF oDlg PIXEL
				@ nLinha,210 MSGET oIss VAR nIss	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALLIQ")  ;
				Valid ( Iif(nOldIss # nIss, (Fa080Val(nIss,nTxMoeda,,.T.,,,,aTitCalc),nOldIss := nIss), .T.)) When  !lOFINI055 .And. !lEmBordero .And. (nOldIss>0 .Or. nIss>0 .Or. lFA080ACES)	
				nOldIss := nIss
			Endif

			If (!_lTemMR .Or. !_lInsMR) .And. lInssBx .And. cPaisLoc == "BRA" .And. nInss > 0 .And. !(lInsPub .And. SE2->E2_TIPO $ MVPAGANT+"/INA") //Inss Baixa
				nLinha +=12
				@ nLinha,144 SAY "- Inss"	SIZE 53,07 OF oDlg PIXEL
				@ nLinha,204 MSGET oInss VAR nInss	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALLIQ")  ;
				Valid ( Iif(nOldInss # nInss, Fa080Val(nInss,nTxMoeda,,.T.,,,,aTitCalc), .T.)) When  !lOFINI055
				nOldInss := nInss
			Endif

			If (!_lTemMR .Or. !_lIrfMR) .And. lIRPFBaixa
				nLinha +=12
				@ nLinha,144 SAY "- Irrf"	SIZE 53,07 OF oDlg PIXEL
				@ nLinha,210 MSGET oIrrf VAR nIrrf	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALLIQ")  ;
				Valid ( Iif(nOldIRRF # nIrrf, Fa080Val(nIrrf,nTxMoeda,,.T.,,,,aTitCalc), .T.)) When  !lOFINI055 .And. !lEmBordero .And. (nOldIRRF>0 .Or. nIrrf>0 .Or. lFA080ACES)	
				nOldIRRF := nIrrf
			Endif

			If (!_lTemMR .Or. !_lPccMR) .And. lPccBaixa .and. cPaisLoc == "BRA"
				nLinha +=12
				@ nLinha,144 SAY "- Pis"	SIZE 53,07 OF oDlg PIXEL
				@ nLinha,210 MSGET oPis VAR nPis	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALLIQ")  ;
				Valid ( Iif(nOldPis # nPis, Fa080Val(nPis,nTxMoeda,,.T.,,,,aTitCalc), .T.)) When  !lOFINI055 .And. !lEmBordero .And. (nOldPis>0 .Or. nPis>0 .Or. lFA080ACES)				
				oPis:SetEnable( lAcessImp )
				nOldPis := nPis

				nLinha +=12
				@ nLinha,144 SAY "- Cofins" 	SIZE 53,07 OF oDlg PIXEL
				@ nLinha,210 MSGET oCofins VAR nCofins SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALLIQ") ;
				Valid ( Iif(nOldCofins # nCofins, Fa080Val(nCofins,nTxMoeda,,.T.,,,,aTitCalc), .T.)) When !lOFINI055 .And. !lEmBordero .And. (nOldCofins>0 .Or. nCofins>0 .Or. lFA080ACES)
				oCofins:SetEnable( lAcessImp )
				nOldCofins := nCofins

				nLinha +=12
				@ nLinha,144 SAY "- Csll"	SIZE 53,07 OF oDlg PIXEL
				@ nLinha,210 MSGET oCsll VAR nCsll	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALLIQ") ;
				Valid ( Iif(nOldCsll # nCsll, Fa080Val(nCsll,nTxMoeda,,.T.,,,,aTitCalc), .T.)) When !lOFINI055 .And. !lEmBordero .And. (nOldCsll>0 .Or. nCsll>0 .Or. lFA080ACES)
				oCsll:SetEnable( lAcessImp )
				nOldCsll := nCsll
			Endif

			If (!_lTemMR .Or. !_lCidMR) .And. lCideBX
				nLinha +=12
				@ nLinha,144 SAY "- Cide"	SIZE 53,07 OF oDlg PIXEL
				@ nLinha,210 MSGET oCide VAR nCide	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALLIQ")  ;
				Valid ( Iif(nOldCide # nCide, (Fa080Val(nCide,nTxMoeda,,.T.,,,,aTitCalc),nOldCide := nCide), .T.)) When  !(ALLTRIM(SE2->E2_ORIGEM) =="FINI055") .And. !lEmBordero
				nOldCide := nCide
			EndIf

			If _lTemMR .And. _nImpMR > 0
				nLinha +=12
				@ nLinha,144 SAY "  Retenções"	SIZE 53,07 OF oDlg PIXEL
				@ nLinha,210 MSGET oRetMotor VAR _nTotImp	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALLIQ")  ;
				Valid .T. When .F.
			EndIf

			If Empty(nTxMoeda)
				nTxMoeda := 0 //evitar erro type mismatch na função xmoeda, quando parâmetro MV_EASYFIN for igual S e a moeda = 2
			EndIf 
			
			nValTot	     := SE2->E2_VLCRUZ
			nValEstrang  := nValOrig := (SE2->E2_SALDO - nTotAbat)
			
			If SE2->E2_MOEDA == 1 .And. nValEstrang >= _nImpMR
				nValEstrang -= _nImpMR 
			EndIf  
			
			nEstOriginal := nValEstrang-(xMoeda(nJuros+nVA+nMulta-nDescont+nOtrga+nImpSubst,nMoedaBco,SE2->E2_MOEDA,,,,nTxMoeda))
			
			If SE2->E2_MOEDA > 1 .And. nMoedaBco > 1 .And. SE2->E2_MOEDA <> nMoedaBco
				nValMoeda    := Round(xMoeda((nValOrig+nAcresc-nDecresc), SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, SE2->E2_TXMOEDA, nTxMoeda),2)
				nValMoeda1   := Round(xMoeda((SE2->E2_VALOR-nTotAbat+nAcresc-nDecresc), SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, SE2->E2_TXMOEDA, nTxMoeda), 2)
				nValPgto     := nValMoeda + nMulta + nJuros + nVA - nDescont + nOtrga + nImpSubst 
				
				If !_lPccMR .And. (nPis+nCoFins+nCsll) > 0
					nValPgto -= (nPis+nCoFins+nCsll) 
				EndIf
				
				If !_lIrfMR .And. lIRPFBaixa .And. nIrrf > 0
					nValPgto -= nIrrf 
				EndIf
				 
				If !_lIssMR .And. nIss > 0
					nValPgto -= nIss 	
				EndIf
				
				If _nImpMR > 0
					nValPgto -= _nImpMR 
				EndIf
				
				If (nMulta+nJuros+nDescont+nOtrga+nImpSubst+Abs(nVA)+nAcresc+nDecresc+nPis+nCoFins+nCsll+nIrrf+nIss) > 0 .or. Round(nValEstrang - xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,,,nTxMoeda),2) > 0.01
					nValEstrang := Round(xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, SE2->E2_TXMOEDA), 2)
				EndIF
			Else
				nValMoeda    := Round(Noround(xMoeda(nValOrig,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCasDec+1,nTxMoeda),nCasDec+1),nCasDec)
				nValMoeda1   := Round(NoRound(xMoeda(SE2->E2_VALOR-nTotAbat,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
				nValPgto     := nValMoeda+nMulta+nJuros+nVA-nDescont+nOtrga+nImpSubst+nAcresc-nDecresc - If(!_lPccMR, (nPis+nCoFins+nCsll), 0);
							-Iif(!_lIrfMR .And. lIRPFBaixa, nIrrf, 0) - If(!_lIssMR, nIss, 0) - Iif(!_lInsMR .And. lInssBx, nInss, 0) - _nImpMR
							nOldValPgto  := nValPgto
				IF (nMulta+nJuros+nDescont+nOtrga+nImpSubst+Abs(nVA)+nAcresc+nDecresc+nPis+nCoFins+nCsll+nIrrf+nIss) > 0 .or. Round(nValEstrang - xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,,,nTxMoeda),2) > 0.01 
					nValEstrang := Round(NoRound(xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
				EndIF				
			EndIf
			
			nValLiq := nValPgto-nMulta-nJuros+nVA+nDescont-nOtrga-nImpSubst-nAcresc+nDecresc+;
						If(!_lPccMR, (nPis+nCoFins+nCsll), 0) + If(!_lIrfMR, nIrrf, 0) + If(!_lIssMR, nIss, 0) - Iif(!_lInsMR .And. lInssBx, nInss, 0) - _nImpMR

		
			If cTipoCm == "T"
				FA080CORR(nEstOriginal,nTxMoeda)
			EndIf
		
			nLinha +=12
			@ nLinha,144 SAY OemToAnsi(STR0041)	 	SIZE 53,07 OF oDlg PIXEL COLOR CLR_HBLUE //"= Valor Pago"
			@ nLinha,210 MSGET oValPgto VAR nValPgto	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALOR") When If(cPaisLoc <> "CHI", !lEmBordero .and. !lVal4xMil, .T. ) ;
			Valid ( fa80AltTela(nTxMoeda,,,,aTitCalc, @lPgtoMaior),Fa080Refr(oJuros, oMulta, oDescont, oDtBaixa, oTxMoeda) )
		
			If SE2->E2_MOEDA > 1 .Or. cPaisLoc<>"BRA"
				nLinha +=12
				@ nLinha,144 SAY OemToAnsi(STR0042)  + SubStr(GetMV("MV_SIMB"+cMoeda),1,3)    SIZE 53,07 OF oDlg PIXEL //"Valor "
				@ nLinha,210	MSGET oVlEstrang VAR nValEstrang		SIZE 65, 08 OF oDlg PIXEL HASBUTTON ;
				Picture PesqPict("SE2","E2_VALOR") When !lVal4xMil  Valid	FA080Estrang(nTxMoeda,nTolerCP) .And.;
				fa80AltTela(nTxMoeda,,,,aTitCalc, @lPgtoMaior) .And.Fa080Refr(oJuros, oMulta, oDescont, oDtBaixa, oTxMoeda)
			

				If cPaisloc <> "CHI"
					nLinha +=12
					@ nLinha,144 SAY OemToAnsi(STR0040) 		SIZE 53,07 OF oDlg PIXEL //"+ Corr.Monet ria"
					@ nLinha,210 MSGET oCM VAR nCM				SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_CORREC") ;
					When SE2->E2_MOEDA > 1 .and. (IIf(GetMv("MV_CALCCM") == "S",.T.,.F.) .And. cPaisLoc<>"BRA")
				Else
					nLinha +=12
					@ nLinha,144 SAY OemToAnsi(STR0119)				SIZE 53,07 OF oDlg PIXEL //"+/- Dif. Cambio"
					@ nLinha,210 MSGET oDifCambio VAR nDifCambio	SIZE 65, 08 OF oDlg PIXEL HASBUTTON Picture PesqPict("SE2","E2_CAMBIO");
					When .F.
				EndIf
			Endif

			//Atualiza o valor caso seja necessario calcular juros no titulo
			nValMax := SE2->E2_SALDO
			If ( cPaisLoc <> "BRA" ) .Or. (cPaisLoc == "BRA" .And. !lPccBaixa)
				fa080Data(nTxMoeda, /*lButOk*/, /*lHelp*/, /*oDtBaixa*/,aTitCalc)
			Endif

			//Verifica os botoes de usuarios
			If lFA080BTN
				aButtons:= ExecBlock("FA080BTN",.F.,.F.,{aButtons})
			EndIf

			//Botao para permitir manutencao de bordero
			If lFA080BTH
				AADD(aButtons, {"SIMULACA", {|| FaActBord(@cNumBor,@cPort240,@cAgen240,@cConta240,@dDataBord,@cModPgto,@cTipoPag)}, "Bordero"})
			EndIf

			//Verifica os botoes de usuarios no Template
			If ExistTemplate("FA080BTN")
				aButtons := ExecTemplate("FA080BTN",.F.,.F.,{aButtons})
			EndIf

			If ( cPaisLoc <> "BRA" )
				AADD(aButtons, {"TABPRICE", {|| (nTxMoeda:=Fa080SetMd(), fA080Val(0,nTxMoeda,,,,,,aTitCalc),Fa080ValVR(nTxMoeda,,,,,,aTitCalc),fa80AltTela(nTxMoeda,,,,aTitCalc),;
															  Fa080Refr(oJuros, oMulta, oDescont, oDtBaixa, oTxMoeda), FA080REFRE(1))},STR0138 }) //Troca de Taxas
			Endif

			// Valores acessórios.
			If __lPodeTVA .and. FAPodeTVA(SE2->E2_TIPO, SE2->E2_NATUREZ, .F., "P")
				Aadd(aButtons, {"VALACESS", {||	If(FINA080VA() == 0, fA080Val(nVa, nTxMoeda,/*lCalcImp*/,/*lAtuVlr*/,/*lDtBaix*/,/*lRecMot*/,.T.,aTitCalc), nil) }, STR0205})  // Valores Acessórios.
			Endif

			If FindFunction("FINMRATIR") .and. __oRatIRF <> Nil .AND. Len(__oRatIRF:aRatIRF) > 0
				Aadd(aButtons, {"RATEIOCPF", {||FINMRATIR(__oRatIRF:aRatIRF,.T.) }, STR0240})//"Rateio de IR progressivo"
			Endif			

			//Motor de Retenções
			If _lTemMR
				Aadd(aButtons, {"NOTE", {||F080ConImp()},,STR0216,STR0216})
			EndIf

			_nValPgto := nValPgto

			If lPanelFin  //Chamado pelo Painel Financeiro
				ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oMyBar,{||iIf( iIf( !MovBcoBx(cMotBx, .T.),Fa080BDev(),Fa080Cont().and.;
				( IIf( SuperGetMv("MV_BXDTFIN",,"1") == "2", DtMovFin(dBaixa,,"1"), .T.) ) .and.;
				fa080Data(@nTxMoeda,.T.,.T., /*oDtBaixa*/,aTitCalc) .and. fa080Cheq(.F.)) .And.;
				( IIf( FXMultSld(), FXVldBxBco( cBanco, cAgencia, cConta, SE2->E2_NATUREZ, SE2->E2_MOEDA ), .T. ) ) .AND.;
				PcoVldLan("000005","01","FINA080") .AND. ( FA080VlCan(dDataCan, cMotBx)).and. Iif( FA080VlNat(cMotBx),.T.,.F.) ,(nOpc1 := 1,oDlg:End()),NIL) },;
				{||nOpc1 := 0,oDlg:End()},aButtons) CENTERED
			Else
				ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||iIf( iIf( !MovBcoBx(cMotBx, .T.),Fa080BDev() .and. IIf( SuperGetMv("MV_BXDTFIN",,"1") == "2", DtMovFin(dBaixa,,"1"), .T.),Fa080Cont().and.;
				( IIf( SuperGetMv("MV_BXDTFIN",,"1") == "2", DtMovFin(dBaixa,,"1"), .T.) ) .and.;
				fa080Data(@nTxMoeda,.T.,.T.,oDtBaixa,aTitCalc) .and. fa080Cheq(.F.)),.T.,.F.) .And.;
				( IIf( FXMultSld(), FXVldBxBco( cBanco, cAgencia, cConta, SE2->E2_NATUREZ, SE2->E2_MOEDA ), .T. ) ) .And. !lPgtoMaior .And.;
				PcoVldLan("000005","01","FINA080") .AND. ( FA080VlCan(dDataCan, cMotBx)) .and. Fa080Lib() .and. Iif( FA080VlNat(cMotBx) ,(nOpc1 := 1,oDlg:End()),NIL) },;
				{||nOpc1 := 0,oDlg:End()},,aButtons) CENTERED
			Endif
		Else
			// rotina automatica
			lCont := .F.
			aOldValores := {nDescont, nMulta, nJuros, nOTRGA, nVA}
			//Valores Acessorios
			//ESTRUTURA __aVAAuto
			//__aVAAuto[nLaco][1] = cChaveFK7
			//__aVAAuto[nLaco][2] = Código do VA
			//__aVAAuto[nLaco][3] = Valor do VA
			If __lPodeTVA .and. __lExistVA
				FKD->( dbSetOrder( 2 ) ) //FKD_FILIAL+FKD_IDDOC+FKD_CODIGO
				nRecSe2 := SE2->(RecNo())

				If Len(__aVAAuto) > 0
					FVAAuto( .T. ) //Indica que, ao ativar o model FINA080VA, os VAs não serão recalculados (pois os valores já vieram na execauto)

					For nLaco := 1 To Len(__aVAAuto)

						cAcaoVA := Posicione( "FKC", 1, FWxFilial("FKC") + __aVAAuto[nLaco][2], "FKC_ACAO" )
						If cAcaoVA == "2" //Se for VA de subtração, então multiplica o valor informado na execauto por -1
							nVaCalc := __aVAAuto[nLaco][3] * -1
						Else
							nVaCalc := __aVAAuto[nLaco][3]
						Endif

						If FKD->( msSeek( FWxFilial("FKD") + __aVAAuto[nLaco][1] + __aVAAuto[nLaco][2] ) )
							RecLock("FKD",.F.)
								FKD->FKD_VLCALC := nVaCalc
								FKD->FKD_VLINFO := nVaCalc
							FKD->(MsUnlock())
						Else
							RecLock("FKD",.T.)
								FKD->FKD_FILIAL := xFilial("FKD")
								FKD->FKD_IDDOC  := __aVAAuto[nLaco][1]
								FKD->FKD_CODIGO := __aVAAuto[nLaco][2]
								FKD->FKD_VALOR  := __aVAAuto[nLaco][3]
								FKD->FKD_SALDO  := 0
								FKD->FKD_DTBAIX := CtoD("//")
								FKD->FKD_VLCALC := nVaCalc
								FKD->FKD_VLINFO := nVaCalc
							FKD->(MsUnlock())
						EndIf
					Next nLaco
				ElseIf lF080Auto
					FVAAuto( .F. ) //Indica que, ao ativar o model FINA070VA, os VAs serão calculados
				Endif
				dbSelectArea("SE2")
				
				//Ativa o modelo de dados para calcular os VAs (ou considerar os valores recebidos na execauto)
				cOldVA := ""
				oModelVA := FWLoadModel("FINA080VA")				
				oModelVA:SetOperation( MODEL_OPERATION_UPDATE )
				oModelVA:Activate()
				cOldVA  := oModelVA:GetXMLData()
				oModelVa:Deactivate()
				oModelVa:Destroy()
				oModelVa := NIL
				FVAAuto( .F. )

				SE2->( dbGoTo(nRecSe2) )
                IF (SE2->E2_MOEDA != nMoedaBCO)
                    nVA := xMoeda(nVa,SE2->E2_MOEDA,nMoedaBCO,dBaixa,3,,nTxMoeda)
                ENDIF

			Endif
			
			aValidGet:= {}
			
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTMOTBX'})) > 0
				cMotBx	:=	aAutoCab[nT,2]		// Sergio Fuzinaka - 28.05.02
				
				If Len(AllTrim(cMotBx)) == 3
					If (nY := ascan(aMotBx,{|x| SubStr(x,1,3) == AllTrim(cMotBx)})) > 0
						aAutoCab[nT,2] := SubStr(aMotBx[nY],07,10)
						cMotBx := aAutoCab[nT,2]
					EndIf
				EndIf
				
				Aadd(aValidGet,{'cMotBx' ,aAutoCab[nT,2],"fa080BDev()",.t.})
			EndIf
			
			If MovBcobx(cMotBx, .T.)	// Sergio Fuzinaka - 28.05.02
				IF (nT := ascan(aAutoCab,{|x| x[1]='AUTBANCO'})) > 0
					Aadd(aValidGet,{'cBanco' ,aAutoCab[nT,2],"CarregaSa6(@cBanco,,,.T.)",.t.})
				Endif
				IF (nT := ascan(aAutoCab,{|x| x[1]='AUTAGENCIA'}) ) > 0
					Aadd(aValidGet,{'cAgencia' ,aAutoCab[nT,2],"CarregaSa6(@cBanco,@cAgencia,,.T.)",.t.})
				EndIf
				IF (nT := ascan(aAutoCab,{|x| x[1]='AUTCONTA'}) ) > 0
					Aadd(aValidGet,{'cConta' ,aAutoCab[nT,2],"CarregaSa6(@cBanco,@cAgencia,@cConta,.T.,,.T.)",.t.})
				EndIf
			EndIf
			
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTDTBAIXA'}) ) > 0
				dBaixa := aAutoCab[nT,2]
				Aadd(aValidGet,{'dBaixa' ,aAutoCab[nT,2],"fA080Data()",.t.})
			EndIf
			
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTDTDEB'}) ) > 0
				dDebito :=	aAutoCab[nT,2]
				Aadd(aValidGet,{'dDebito' ,aAutoCab[nT,2],"(dDebito >= dBaixa  .and. DtMovFin(dDebito,,'1'))",.t.})
			EndIf
			
			IF lIsRussia .and. (nT := ascan(aAutoCab,{|x| x[1] == 'AUTPAYORD'}) ) > 0 //used to link the the payment order in the writoff. 
				cOrdPag :=	aAutoCab[nT,2]			
			EndIf
		
			IF lIsRussia .and. (nT := aScan(aAutoCab,{|x| x[1]='AUTIDPROC'}) ) > 0
				cIDProc :=	aAutoCab[nT,2]			
			EndIf
			
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTCHEQUE'}) ) > 0
				cCheque := aAutoCab[nT,2]
				Aadd(aValidGet,{'cCheque' ,aAutoCab[nT,2],"fA080Cheq()",.t.})
			EndIf
			
			IF VisualSX3("E5_HISTOR") .AND. (nT := ascan(aAutoCab,{|x| x[1]='AUTHIST'}) ) > 0
				cHist070 := aAutoCab[nT,2]
				Aadd(aValidGet,{'cHist070' ,PadR(aAutoCab[nT,2],nTamHist),"CheckSX3('E5_HISTOR')",.t.})
			EndIf
			
			nOldValor := aOldValores[1]			
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTDESCONT'}) ) > 0
				nDescont := aAutoCab[nT,2]
				Aadd(aValidGet,{'nDescont' ,aAutoCab[nT,2],'Fa080Val(nDescont, ' + If(nTxMoeda > 0, STR(nTxMoeda), "0") + ',.f.) .and. IIF(cPaisLoc<>"CHI",nDescont<= Round(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoedaBco,dBaixa,MsDecimais(1)+1,'+ STR(nTxMoeda,17,nDecTxMd) +'),2),iF(SE2->E2_MOEDA==1,nDescont<=moeda(SE2->E2_SALDO,1,"P",dBaixa),.T.))  .and. if((SE2->E2_IMPCHEQ == "S" .or. lChqPre) .and. nDescont!=nOldValor,Help(" ",1,"JACHQSTIT")!=NIL,.t.)',.t.})
			EndIf
			
			nOldValor := aOldValores[2]
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTMULTA'}) ) > 0
				nMulta :=  aAutoCab[nT,2]
				Aadd(aValidGet,{'nMulta' ,aAutoCab[nT,2],'Fa080Val(nMulta,' + If(nTxMoeda > 0, STR(nTxMoeda), "0") + ',.f.) .and. if((SE2->E2_IMPCHEQ == "S" .or. lChqPre) .and. nMulta!=nOldValor,Help(" ",1,"JACHQSTIT")!=NIL,.t.)',.t.})
			EndIf
			
			nOldValor := aOldValores[3]
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTJUROS'}) ) > 0
				nJuros := aAutoCab[nT,2]
				Aadd(aValidGet,{'nJuros' ,aAutoCab[nT,2],'Fa080Val(nJuros, ' + If(nTxMoeda > 0, STR(nTxMoeda), "0") + ',.f.) .and. if((SE2->E2_IMPCHEQ == "S" .or. lChqPre) .and. nJuros!=nOldValor,Help(" ",1,"JACHQSTIT")!=NIL,.t.)',.t.})
			EndIf
			
			nOldValor := aOldValores[4]
			If cPaisLoc == "CHI"
				IF (nT := ascan(aAutoCab,{|x| x[1]='AUTOUTGAS'}) ) > 0
					Aadd(aValidGet,{'nOTRGA' ,aAutoCab[nT,2],'Fa080Val(nOTRGA) .and. if(!fa080Digit() .and. nOTRGA!=nOldValor,Help(" ",1,"JACHQSTIT")!=NIL,.t.)',.t.})
				EndIf
			EndIf
			
			IF SE2->E2_MOEDA > 1				
				If (nT := ascan(aAutoCab,{|x| x[1]='AUTVLRME'}) ) > 0
					nValEstrang	:=	aAutoCab[nT,2]
					If !cModulo $ "EIC/EEC/EFF/ESS"
						Aadd(aValidGet,{'nValEstrang' ,aAutoCab[nT,2],"Fa080Estrang() .And. Fa080ValEstrang(nValEstrang,"+STR(nTxMoeda,17,nDecTxMd)+",@nValPgto,dBaixa,,,nJuros,nMulta,nDescont,nOtrga,nImpSubst,nEstOriginal,nVA)",.T.})
					Else
						Aadd(aValidGet,{'nValEstrang' ,aAutoCab[nT,2],"Fa080Estrang("+STR(nTxMoeda,17,nDecTxMd)+") .And. Fa080ValEstrang(nValEstrang,"+STR(nTxMoeda,17,nDecTxMd)+",@nValPgto,dBaixa,,,nJuros,nMulta,nDescont,nOtrga,nImpSubst,nEstOriginal,nVA)",.T.})
					EndIf
				ElseIf Empty(nValEstrang)
					nValEstrang := SE2->E2_SALDO-nTotAbat
					lBxEstTotal := .T.
				EndIf
			ENDIF
			
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTBENEF'}) ) > 0
				cBenef :=	aAutoCab[nT,2]
				Aadd(aValidGet, {'cBenef', aAutoCab[nT,2], '.T.', .T.})
			EndIf
			
			If (nT := ascan(aAutoCab, {|x| x[1] == 'AUTVLRPG'})) > 0
				If !lFina450 .Or. (lFina450 .And. aAutoCab[nT,2] + SE2->((E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF) - (E2_VRETPIS+E2_VRETCOF+E2_VRETCSL+E2_VRETIRF)) != SE2->E2_SALDO)
					If SE2->E2_MOEDA == nMoedaBco
						nVlrMov := aAutoCab[nT,2]
					ElseIf SE2->E2_MOEDA == 1
						nVlrMov := xMoeda(aAutoCab[nT,2], 1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda)
					ElseIf nMoedaBco == 1
						nVlrMov := xMoeda(aAutoCab[nT,2], SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda, 0)
					ElseIf lIntegracao .AND. UPPER(Alltrim(SE2->E2_ORIGEM)) == "SIGAEIC" // Exemplo titulo em euro e banco em dolar, EIC passa o AUTVLRPG já em dólar, não preciso converter
						nVlrMov := aAutoCab[nT,2]
					Else
						nVlrMov := xMoeda(aAutoCab[nT,2], SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, SE2->E2_TXMOEDA, nTxMoeda)
					EndIf
					
					Aadd(aValidGet, {'nValPgto', nVlrMov, "Fa080ValVR(" + STR(nTxMoeda, 17, nDecTxMd) +",,,"+cValtoChar(lIRPFBaixa)+")", .T.})
				EndIf
			EndIf
			
			IF (nT := ascan(aAutoCab,{|x| x[1]='AUTTPDESC'}) ) > 0
				cTpDesc :=	aAutoCab[nT,2]
				Aadd(aValidGet, {'cTpDesc', aAutoCab[nT,2], 'cTpDesc == "C" .or. cTpDesc == "I"', .T.})
			EndIf

			nValTot	 := SE2->E2_VLCRUZ
			nValOrig := SE2->E2_SALDO-nTotAbat
			RegToMemory("SE2", .F.)

			nInicio := Seconds()
			If !SE2->(MsVldGAuto(aValidGet)) // consiste os gets
				Return .f.
			EndIf
			nFim += Seconds() - nInicio
			
			If __lMetric
				SetFunName(__cFunMet)
				// Metrica do tempo das validações execauto
        		FwCustomMetrics():setAverageMetric("AutTempoVld", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
				SetFunName(__cFunBkp)
			Endif

			If cPaisLoc =="CHI" .And. SE2->E2_MOEDA <> 1
				nValPgto := nValTot + nMulta + nJuros - nDescont + nOTRGA
			Endif

			If !( lIntegracao .AND. UPPER(Alltrim(SE2->E2_ORIGEM)) == "SIGAEIC" .AND. __nTxTitBx > 0 )
				IF (nMulta+nJuros+nDescont+nOTRGA) > 0 .or. Round(nValEstrang - xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa),2 ) > 0.01
					nValEstrang := Round(NoRound(xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
				EndIF
			EndIf

			nValLiq := nValPgto - nMulta - nJuros - nVA + nDescont - nOtrga - nImpSubst - nAcresc + nDecresc +;
								If(!_lPccMR, (nPis+nCoFins+nCsll), 0) + If(!_lIrfMR, nIrrf, 0) + If(!_lIssMR, nIss, 0)
			
			
			If lFINA430 // se for retorno do Cnab

				// Considera diretamente os valores passados pela EXECAUTO.
				If (nT := ascan(aAutoCab,{|x| x[1]='AUTJUROS'}) ) > 0
					nJuros := Round(NoRound(aAutoCab[nT,2]),2)
				EndIf

				If (nT := ascan(aAutoCab,{|x| x[1]='AUTDESCONT'}) ) > 0
					nDescont := Round(NoRound(aAutoCab[nT,2]),2)
				EndIf

				If (nT := ascan(aAutoCab,{|x| x[1]='AUTMULTA'}) ) > 0
					nMulta := Round(NoRound(aAutoCab[nT,2]),2)
				EndIf

				If (nT := ascan(aAutoCab,{|x| x[1]='AUTACRESC'}) ) > 0
					nAcresc := Round(NoRound(aAutoCab[nT,2]),2)
				EndIf

				If (nT := ascan(aAutoCab,{|x| x[1]='AUTDECRESC'}) ) > 0
					nDecresc := Round(NoRound(aAutoCab[nT,2]),2)
				EndIf

				If (nT := ascan(aAutoCab,{|x| x[1]='AUTVLRPG'}) ) > 0
					aAutoCab[nT,2] := Round(NoRound(nValPgto,2),2)
				EndIf
			EndIf
			
			nValMax := SE2->E2_SALDO
			nOpc1 := 1
		Endif
		
		If nOpc1 == 0
			nErro ++
		EndIf

		If nErro > 2
			nErro :=0
			If Abandona()
				MsUnlock()
				Exit
			Endif
		Endif

		NUMCHEQUE := cCheque	//para contabilizar o numero do cheque

		//Verifica onde ocorrer  a contabilização. Se for informado num. do cheque, deve contabilizar pela baixa
		//Se não informou num.do cheque ou num. cheque começar com "*" na geração Contabiliza tamb‚m caso seja CAIXA
		If (!Empty( cCheque ) .and. SubStr( cCheque, 1, 1 ) != "*" .and. SE2->E2_IMPCHEQ != "S") .or. ;
			cContabiliza = "B" .Or. cContabiliza = "A" .or. ;
			cBanco $ Left(GetMv("MV_CXFIN"),nTamCodA6) .or. cBanco$GetMV("MV_CARTEIR")

			If !lFina450
				lContabiliza := .T.
			Endif
		Endif

		//Caso motivo seja VENDOR, dever ser contabilizado na baixa
		If Empty(cMotBx)
			cMotBx		:= aDescMotBx[nFirstRsn] 	//NORMAL
		Endif

		If TrazCodMot(cMotBx) $ "VEN/DEB"
			lContabiliza := .T.
		EndIF

		If MovBcoBx(cMotBx, .T.) .and. !ChqMotBx(cMotBx)
			lContabiliza := .T.
		EndIF
		If cContabiliza == "C" .And. !ChqMotBx(cMotBx)
			lContabiliza := .T.
		EndIF
		
		If SE2->E2_TIPO $ MVPAGANT
			lContabiliza := .T.
		EndIf

		//Não contabilizar baixas de títulos de origem PLS
		If "PLS" $ SE2->E2_ORIGEM
			lContabiliza := .F.
		EndIf

		If lF080FILEM
			cNomeCpo := ExecBlock("F080FILEMI",.F.,.F.,{})
			If SE2->(FieldPos(cNomeCpo)) == 0
				cNomeCpo := 'E2_EMISSAO'
			EndIf
		EndIf

		If nOpc1 == 1 .And. dBaixa < SE2->(&cNomeCpo)
			Help( " ", 1, "DATAERRP",, STR0150,1,0 ) //"Data do pagamento não pode ser menor que a data de emissâo do título correspondente"
			If !lF080Auto
				Loop
			Else
				nopc1 := 0
			Endif
		Endif

		//Verifica se valor da baixa ‚ maior que valor maximo a pagar
		If nOpc1 == 1 .and. SE2->E2_MOEDA == 1 .AND. nMoedaBco == 1
			IF nOpc1 == 1 .And. Str(nValPgto,17,2) > STR(SE2->E2_SALDO+nJuros+nVA+nMulta-nDescont-nTotAbat+nOtrga+nImpSubst+nAcresc-nDecresc+nTolerCp-nPis-nCoFins-nCsll-nIrrf-nIss,17,2)
				If !FwIsInCallStack("FINA450") .And. ( !lMVCNBImpg .Or. ( lMVCNBImpg .And. !(FwIsInCallStack("Fa430gera"))))
					Help(" ",1,"ValorMaior")
					If !lF080Auto
						Loop
					Else
						nopc1 := 0
					Endif
				Endif
			Endif
		EndIf

		If nOpc1 == 1
			If !Fa080ValCh()
				If !lF080Auto
					Loop
				Else
					nopc1 := 0
				Endif
			Endif
		EndIf

		//Baixa de titulo em moeda forte com a cotacao da moeda igual a zero !!
		If nOpc1 == 1 .and. SE2->E2_MOEDA > 1 .and. RECMOEDA(dBaixa,cMoeda) == 0 .and. nTxMoeda == 0 .and. ;
			nValPgto == 0 .and. nValEstrang == 0
			Help(" ",1,"TX_MOEDA",, STR0130,1,0)	//"Nao sera possivel baixar este titulo pois a cotacao da moeda do titulo na data da baixa é igual a zero."
			// Se nao for baixa por rotina automatica, volta para o usuario corrigir os
			// dados, senao abandona a baixa.
			If !lF080Auto
				loop
			Else
				nOpc1 := 0
			Endif
		Endif

		If nAcresc > nValPgto
			nValPadrao 	:= 0
			nAcresc		:= nValPgto
		Else
			If nValPgto < nIrrf .and. nValPgto != 0.01
				nValPadrao := nValPgto
			Else
				nValPadrao := nValPgto-(nJuros + nVA +Iif(SE2->E2_MOEDA<=1,nCM,0) + nMulta - nDescont + nAcresc - nDecresc -;
							If(!_lPccMR, (nPis+nCoFins+nCsll), 0) - If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0))
			EndIf
		EndIf
		nOpt := IIF(Str(nValPadrao,14,2)=Str(Moeda(SE2->E2_SALDO,1,"P",dBaixa),14,2),1,2)

		If nOpc1 <> 1
			cBanco 		:= CriaVar("E1_PORTADO")
			cAgencia	:= CriaVar("E1_AGEDEP")
			cConta		:= CriaVar("E1_CONTA")
			lRet := .F.
			MsUnlock()
			Exit
		Endif

		If SE2->( Deleted() )
			nOpc1 := 0
			lRet  := .F.
			Help( " " , 1 , "RECNO" )
			Return lRet /*Function fA080Tit*/
		EndIf

		IF nOpc1 == 1

			//Métricas
			IF __lMetric .and. SE2->E2_MOEDA != nMoedaBco .AND. nCm > 0 .and. ;
					(nJuros + nVA + nMulta + nDescont + nAcresc + nDecresc) != 0
				SetFunName(__cFunMet)
				// Metrica do tempo das validações execauto
				FwCustomMetrics():setUniqueMetric("MV_TIPOCM ("+ cTipoCm + ")", "financeiro-protheus_qtd-por-conteudo_total", cTipoCm)
				SetFunName(__cFunBkp)
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de Entrada - para confirmacao da baixa			   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lFa080Tit
				lRet := ExecBlock("FA080TIT",.F.,.F.)
				If !lRet
					// Se nao for baixa por rotina automatica, volta para o usuario corrigir os dados, senao abandona a baixa.
					If !lF080Auto
						loop
					Else
						Exit
					Endif
				Endif
			Endif

			If !lRet
				Return lRet /*Function fA080Tit*/
			EndIf

			If SE2->E2_MOEDA == 1 .AND. nMoedaBco > 1 
				nTxMoeda := RecMoeda(dBaixa,nMoedaBco)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se modalidade do SPB é valida.								 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lSpbInUse .and. !lF080Auto
				cModSpb := Substr(cModSpb,1,1)
				IF !(SpbTipo("SE2",cModSpb,SE2->E2_TIPO))
					Loop
				Endif
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se n„o h  campos em branco									³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF Empty(cMotBx)
				Help(" ",1,"FA080MOT")
				DbSelectArea("SE2")
				If !lF080Auto
					Loop
				Else
					Exit
				Endif
			EndIF
			IF FwIsInCallStack("FINA450") .And. SE2->E2_IMPCHEQ != "S"
				IF ((MovBcoBx(cMotBx, .T.) .and. (Empty(dBaixa) .Or. Empty(cBanco) .Or. Empty(cConta))) .Or. ;
				( nValPgto < 0 ))
					Help(" ",1,"FA080VAZ")
					DbSelectArea ("SE2")
					If !lF080Auto
						Loop
					Else
						Exit
					Endif
				Endif
			Endif

			IF (nTotAbat = 0 .and. nDescont = 0 .and. nDecresc = 0 .and. nPis = 0 .and. ;
				nCofins = 0 .and. nCsll = 0 .and. nIrrf = 0 .and. nIss = 0.and. nValPgto = 0) .or. ;
				(nValPgto=0.and.(nTotAbat+nDescont+nDecresc+nPis+nCofins+nCsll+nIrrf+nIss)!=xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoedaBco,dBaixa,,nTxMoeda) .and. ;
				nDescont > (Round(nMulta+nJuros+nVA+xMoeda(SE2->E2_SALDO-nTotAbat,SE2->E2_MOEDA,1,dBaixa,3,nTxMoeda),2)+nAcresc-nDecresc) )
				Help(" ",1,"FA070INV")
				dbSelectArea("SE2")
				If !lF080Auto
					Loop
				Else
					Exit
				Endif
				//Verifica cheque sobre titulo com valor de juros, multa ou desconto e que tornem o
				//valor pago diferente do tratado na geracao do cheque sobre titulo (FINA390)
			ElseIf (nDescont+nMulta+nJuros+nVA > 0 .and. SE2->E2_IMPCHEQ == "S")
				IF SEF->(MSSEEK(xFilial("SEF")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_NUMBCO)))
					If !(Round(nValPgto,2) == Round(SEF->EF_VALOR,2))
						Help(" ",1,"JACHQSTIT")
						If !lF080Auto
							Loop
						Else
							Exit
						Endif
					Endif
				Endif
			Endif

			If !F080VldRec()
				DbSelectArea("SE2")
				If !lF080Auto
					Loop
				Else
					Exit
				Endif
			Endif

			IF (nValPgto-nAcresc+nDecresc) != nValLiq .And. TrazCodMot(cMotBx) == "VEN"
				Help(" ",1,"FA080BXPARC")
				dbSelectArea("SE2")
				If !lF080Auto
					Loop
				Else
					Exit
				Endif
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Rotina de validacao e execucao da baixao via SPB           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lSpbInUse
				IF !F080BxSPB(cClearing,cTipoPgto,cStored,cHora,@cCodBar,@nEventoSpb)
					Loop
				Endif
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Soma nos totalizadores									 	  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nTotAGer += nValPgto
			nTotADesc+= nDescont+nDecresc
			nTotAMul += nMulta
			nTotAJur += nJuros+nAcresc
			nTotADesp+=Iif(SE2->E2_MOEDA<=1,nCM,0)
			VALOR := nValPgto
			cPadrao:="530"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Contabiliza se existir o lan‡amento e:						    ³
			//³ - a contabilização for feita na baixa (parƒmetro mv_ctBaixa) ou  ³
			//³ - se digitou numero de cheque ou se a contabilização for on-line ³
			//³ Verifica existencia do lan‡amento padr„o da baixa e/ou do geração³
			//³ do t¡tulo referente ao Vendor.									³
			//³ Lan‡amento Padr„o referente a baixa   := "530"                   ³
			//³ Lan‡amento Padr„o referente ao Vendor := "518"                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lPadraoBx := VerPadrao(cPadrao) .And. lContabiliza
			lPadraoVd := VerPadrao( "518" ) .And. lContabiliza

			IF !lF080Auto
				// Verifica se esta utilizando multiplas naturezas
				// E chama a rotina para distribuir o valor entre as naturezas
				If MV_MULNATP .and. lMultNat
					MultNatB("SE2",.F.,STR(mv_par05,1),@lOk,@aColsSEV,@lMultNat)
					//Caso tenha cancelado a tela de rateio multinat, retorna para a tela de baixa
					If !lMultNat
						Loop
					Endif
				Endif
			Endif

			If EMPTY(SE2->E2_BAIXA)
				lDtBaixa := .F.
			ElseIf !EMPTY(SE2->E2_BAIXA)
				lDtBaixa := .T.
			EndIf


			//Verifico se foi passado "S" como parametro pelo FINA430
			If lFina430
				cLanca := __cLanc430
			Else
				cLanca :=  Iif(mv_par03==1,"S","N")
			Endif

			// Inicio da proteção via TTS
			Begin Transaction
				Begin Sequence //Proteção (Break) para transações quem vem do FINA430.
					aAreaSA2 := SA2->(GetArea())
					
					nInicio := Seconds()
					lBaixou := fa080Grv(lPadraoBx,lPadraoVd,lFINA430,cLanca, ,nTxMoeda,dDebito,,lMultNat,lUsaFlag,lAltBord,@aCtBaixa,aTitCalc)
					nFim := Seconds() - nInicio

					If __lPodeTVA .and. __lExistVA
                        cOldVAbkp := cOldVA
                        cOldVA := ""
                        FAtuFKDBx(.F., "P")
                        cOldVA := cOldVAbkp
					Endif

					IF lBaixou .and. __lMetric
						SetFunName(__cFunMet)
						// Metrica do tempo das validações execauto
						FwCustomMetrics():setAverageMetric("TempoGravação", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
						SetFunName(__cFunBkp)
					Endif

					If __cLanc430 == "S"
						cLanca := "N"
					Endif
					
					If !lBaixou .And. !lFina430
						DisarmTransaction()
						Break
					EndIf

					RestArea(aAreaSA2)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Grava título do IRRF e informações relacionadas ³
					//³quando IRPF na Baixa                            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lBaixou
						If lIRPFBaixa
							RestArea(aAreaSA2)
							RecLock("SE2")

							//Atualizo o valor do IR apenas para calculo antigo do IRRF na baixa
							If SA2->A2_TIPO == "F"
								If lDtBaixa
									SE2->E2_IRRF += nIRRF
								ElseIf Empty(SE2->E2_NUMBOR)
									SE2->E2_IRRF := nIRRF
								Elseif 	FwIsInCallStack("Fa430gera") .And. lMVCNBImpg
								    SE2->E2_IRRF := nIRRF
									SE2->E2_VRETIRF += nIrrf
								EndIf
							Endif

							If !lMVCNBImpg
								SE2->E2_VRETIRF += nIrrf
							EndIf
							
							MsUnlock()

						Else
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Caso tenha havido retenção na inclusão do pagamento³
							//³antecipado efetua a exclusão do título de IR (TXA) ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If !_lIrfMR .And. SE2->E2_TIPO $ MVPAGANT .And. SE2->E2_IRRF > 0
								F241DelTxIR("FINA080",SE2->(Recno()),SE2->E2_IRRF)
							EndIf
						EndIf
					EndIf

					//Caso a retenção ocorreu na inclusão do pagamento antecipado  efetua a exclusão do título PCC
					If (lContrRet .and.  SE2->E2_TIPO $ MVPAGANT .And. (SE2->(E2_PIS + E2_COFINS + E2_CSLL) > 0 .Or. SE2->E2_ISS > 0))
						//posicionar na SE5 gerada na inclusao da PA

						nRcN_PASE5 := SE5->( RecNo() )
						lPAMov := .F.
						//verifica se PA possui movimentacao bancaria
						nRecPAInc := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
						If  nRecPAInc > 0
							SE5->(DBGoto(nRecPAInc))
							lPAMov := .T.
						EndIf
						//verifica se PA possui registro de inclusao
						nRecPAInc := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
						If	nRecPAInc > 0
							SE5->(DBGoto(nRecPAInc))
							lPAMov := .T.
						EndIf
						If 	lPAMov

							aRecSE5 := FImpDelTit("SE5",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
							nRecSe5 := SE5->(Recno())
							For nY := 1 to Len(aRecSE5)
								SE5->(MSGoto(aRecSE5[nY]))
								RecLock("SE5",.F.)

								//Se nao reteve somente IRRF
								If 	(!Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)) .and. SE5->E5_MOTBX<>"CMP"
									SE5->E5_PRETPIS := "1"
									SE5->E5_PRETCOF := "1"
									SE5->E5_PRETCSL := "1"
								Endif

								MsUnlock()
							Next

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Exclui os registros de relacionamentos do SFQ                                ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							SE5->(dbGoto(nRecSe5))
							FImpDelSFQ("SE5",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)

							aRecSE2 := FImpExcTit("SE2",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)
							For nY := 1 to Len(aRecSE2)
								SE2->(MSGoto(aRecSE2[nY]))
								FaAvalSE2(4)
							Next

							//Exclui os registros de relacionamentos do SFQ
							SE5->(dbGoto(nRecSe5))
							FImpExcSFQ("SE2",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)

							If !_lPccMR
								FDelTxBx(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ,SE2->E2_PARCPIS,SE2->E2_PARCCOF,SE2->E2_PARCSLL)
							EndIf

							If !_lIssMR .And. SE2->E2_ISS != 0
								//Apaga tambem os registro de impostos - ISS
								SE5->(dbGoto(nRecSe5))
								SE2->(dbGoTo(nSalvRec))
								SE2->(dbSetOrder(1))
								cChavePai := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
								If MsSeek(xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM))
									cChaveImp := SE2->(E2_PREFIXO+E2_NUM)
									cNatIss	:= AllTrim(&(GetMv("MV_ISS")))
									While !Eof() .And. E2_FILIAL+E2_PREFIXO+E2_NUM == xFilial("SE2")+cChaveImp
										IF SE2->E2_TIPO $ MVISS .And. ;
											AllTrim(SE2->E2_NATUREZ) == cNatIss .And. ;
											STR(SE2->E2_SALDO,17,2) == STR(SE2->E2_VALOR,17,2) .and. ;
											SE5->E5_SEQ == SE2->E2_SEQBX .And. AllTrim(SE2->E2_TITPAI) == AllTrim(cChavePai)
											If lExistFJU
												FinGrvEx("P")
											Endif 
											FINDELFKs(SE2->E2_FILIAL+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
											RecLock("SE2",.F.)
											SE2->(dbDelete())
											SE2->(MsUnlock())
										EndIf
										dbSkip()
									Enddo
								Endif
							EndIf
							SE5->(dbGoTo(nRecSe5))
							SE2->(dbGoTo(nSalvRec))

							If !_lInsMR .And. !lInsPub
								FDelTxInss(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ,lAltVr)
							Endif

							/*
							Projeto FKs
							-------------------------------------------------------------
								Este trecho foi comentado conforme acordado com o Nagy
								Este tipo de movimento era gerado na emissão de um PA sem movimento mas foi descontinuado desde 2018, não tendo assim que ser convertido
									nos ajustes de gravação das FKs.
								Foi mantido no código apenas para que, caso exista algum cliente com esta situação, possa ser revertido facilmente.

							SE5->(dbGoto(nRecSe5))
							If SE5->E5_TIPODOC = "BA" .And. SE5->E5_MOTBX = "PCC"
								RecLock("SE5",.F.)
								SE5->E5_SITUACA := "C"
								If SE5->( ColumnPos( "E5_DTCANBX" ) ) > 0
									SE5->E5_DTCANBX := dDataBase
								EndIf
								SE5->(MsUnlock())
							EndIf
							--------------------------------------------------------------
							*/
						EndIf

						SE5->( dbGoTo( nRcN_PASE5 ) )
					Endif

					If lAltBord .and. !Empty(cNumBor)
						FaGrvActBd(cNumBor,cPort240,cAgen240,cConta240,dDataBord,cModPgto,cTipoPag)
					Endif

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Rotina de Gravacao dos dados do SPB						   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lSpbInUse
						RecLock("SE2")
						SE2->E2_OKSPB		:= "A"		// Em Aberto, aguardando confirmacao
						SE2->E2_CLEARIN	:= cClearing
						SE2->E2_TPPGTO		:= cTipoPgto
						SE2->E2_HORASPB	:= cHora
						SE2->E2_CODBAR		:= cCodBar
						SE2->E2_EVTSPB		:= nEventoSPB
						MsUnlock()
					Endif
					nTotAbat := Round(NoRound(xMoeda(nTotAbat,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
					ABATIMENTO := nTotAbat

					//Reposiciono o arquivo de fornecedores para a contabilizacao
					SA2->(dbSetOrder(1))
					SA2->(MsSeek(xFilial("SA2",SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA))

					//Reposiciono o arquivo de BANCOS para a contabilizacao
					SA6->(DbSetOrder(1))
					SA6->(dbSeek(xFilial("SA6")+cBanco+cAgencia+cConta))

					IF !lAut
						If cPaisLoc == "BRA" .AND. (lPccBaixa .Or. lIRPFBaixa .Or. lCalcIssBx .Or. lInssBx)
							nOldVlPis := SE2->E2_PIS
							nOldVlCof := SE2->E2_COFINS
							nOldVlCsl := SE2->E2_CSLL
							nOldVlIrf := SE2->E2_IRRF
							nOldVlIss := SE2->E2_ISS

							//Armazeno os valores retidos de impostos, se os mesmos foram gerados por um bordero
							If lBordero
								nOldRetPis := SE2->E2_VRETPIS
								nOldRetCof := SE2->E2_VRETCOF
								nOldRetCsl := SE2->E2_VRETCSL
							EndIf

							Reclock("SE2")

							If lCalcIssBx
								SE2->E2_ISS := nOldVlIss
								SE2->E2_VRETISS += nIss
							EndIf

							//Gravo valores retidos para o titulo permitindo a contabilizacao
							If cPaisLoc == "BRA" .AND. lPccBaixa
								SE2->E2_PIS := nPis
								SE2->E2_COFINS := nCofins
								SE2->E2_CSLL := nCsll
								If lGerImp
									SE2->E2_VRETPIS += nPis
									SE2->E2_VRETCOF += nCofins
									SE2->E2_VRETCSL += nCsll
								Endif

								If SE2->E2_VRETPIS == 0
									SE2->E2_PRETPIS := "1"
								EndIf

								If SE2->E2_VRETCOF == 0
									SE2->E2_PRETCOF := "1"
								EndIf

								If SE2->E2_VRETCSL == 0
									SE2->E2_PRETCSL := "1"
								EndIf

							Endif

							If lInssBx .And. cPaisLoc = "BRA" .And. Empty(SE2->E2_NUMBOR) .And. !lInsPub//!(lInsPub .And. SE2->E2_TIPO $ MVPAGANT+"/INA") //Inss Baixa
								nParciais	:= SE2->E2_VALOR-SE2->E2_SALDO
								nRecSE5Ins := SE5->( RecNo() )
								aBaixa := Sel080Baixa("VL /BA /CP /",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,@nTotAdto,@lBaixaAbat,SE2->E2_FORNECE,SE2->E2_LOJA,@lBxCec,.F.,@lNotBax,@nTotImpost,@lAglImp,.T.,,,,,SE2->E2_FILORIG)
								SE5->( dbGoTo( nRecSE5Ins ) )

								If Len(aBaixaSE5) == 1 //primeira baixa
									SE2->E2_INSS	:=	nInss
								Endif
								If ((nInss > 0 .And. !lAcmPJ) .Or. (lAcmPJ)) .And. SA2->A2_TIPO == "J"
									If Len(aBaixaSE5) == 1 //primeira baixa
										SE2->E2_VRETINS	:= nVretInss
									Endif
								ElseIf SA2->A2_TIPO == "F"
									If Len(aBaixaSE5) == 1 //primeira baixa
										SE2->E2_VRETINS:= nVretInss
									Endif
								Endif
							Endif
							MsUnlock()
						Endif

						//Grava os lancamentos nas contas orcamentarias SIGAPCO
						PcoDetLan("000005","01","FINA080")


						If cPaisLoc == "BRA" .AND. lPccBaixa
							Reclock("SE2")
							SE2->E2_PIS := nOldVlPis
							SE2->E2_COFINS := nOldVlCof
							SE2->E2_CSLL := nOldVlCsl
							SE2->E2_IRRF := nOldVlIrf

							//Restauro os valores retidos de impostos, se os mesmos foram gerados por um bordero
							If lBordero
								SE2->E2_VRETPIS := nOldRetPis
								SE2->E2_VRETCOF := nOldRetCof
								SE2->E2_VRETCSL := nOldRetCsl
							EndIf

							MsUnlock()
						Endif
					Endif

					If lBaixou .And. _lTemMR
						nImposMR := Len(_aImpMR)

						For nX := 1 To nImposMR	
							If nImposMR > 0
								If _nPisMR > 0 .And. _aImpMR[nX,8] == "PIS"
									SE2->E2_VRETPIS += _nPisMR
									SE2->E2_PRETPIS := "3"
								EndIf 

								If _nCofMR > 0 .And. _aImpMR[nX,8] == "COF"
									SE2->E2_VRETCOF += _nCofMR
									SE2->E2_PRETCOF := "3"  
								EndIf

								If _nCslMR > 0 .And. _aImpMR[nX,8] == "CSL"
									SE2->E2_VRETCSL += _nCslMR
									SE2->E2_PRETCSL := "3"  
								EndIf

								If _nIrfMR > 0 .And. _aImpMR[nX,8] == "IRF"
									SE2->E2_VRETIRF += _nIrfMR 
									SE2->E2_PRETIRF := "3" 
								EndIf

								If _nIssMR > 0 .And. _aImpMR[nX,8] == "ISS"
									SE2->E2_VRETISS += _nIssMR 
								EndIf
							EndIf 
						Next nX
					EndIf

					If lBaixou
						PABrtComp(.T.)
					EndIf

					//Envio de e-mail pela rotina de checklist de documentos obrigatorios
					IF lFinVDoc
						CN062ValDocs("02",.F.,.T.)
					EndIf

					If !lFini055 .and. __lEAIF080
						llOpc  := ALTERA
						ALTERA := .T.  // Baixa de título.

						aEaiRet := FWIntegDef('FINA080',,,, 'FINA080')
						If !aEaiRet[1]
							Help(" ", 1, "HELP", STR0217, STR0218 + CRLF + aEaiRet[2], 3, 1)  // "Erro EAI" / "Problemas na integração EAI. Transação não executada."
							DisarmTransaction()
							lBaixou := .F.
						Endif

						ALTERA	:= llOpc
					Endif

					If lBaixou
						lCnab		:= IIF(EMPTY(SE5->E5_ARQCNAB),.F.,.T.)
						cLoteFin 	:= SE5->E5_LOTE

						If !lAdiantamento
							lMovBcoBx := MovBcoBx(cMotBx, .T.)
							lBcoCxCart := (cBanco $ Left(GetMv("MV_CXFIN"),nTamCodA6) .or. cBanco $ GetMv("MV_CARTEIR"))
							lMotBxChq := ChqMotBx(cMotBx)

							If (lCNAB .and. Empty(cLoteFin)) .Or. ;
								(lMovBcoBx .And. SE5->E5_TIPODOC $ "VL|PA|BA" .And.;
								(lBcoCxCart .Or. (!lMotBxChq .And. !lCnab) .Or. (!Empty(cCheque) .And. Substr(cCheque,1,1) != "*" .And. lLibCheq .And. !lF390chq)))
								AtuSalBco(cBanco, cAgencia, cConta, dDebito, nValPgto, "-" )
							Endif
						EndIf
					Endif
					
					If MV_MULNATP .and. lMultNat .and. lOk
						dDataBase   := dBaixa
						lContabMNat := lContabiliza .and. mv_par03 == 1

						MultNatC("SE2" /*cAlias*/, @nHdlPrv /*@nHdlPrv*/, @nTotal /*@nTotal*/, @cArquivo /*@cArquivo*/, lContabMNat /*lContabiliza*/, .F. /*lBxLote*/,;
						STR( mv_par05, 1 ) /*cReplica*/, /*nTotLtEZ*/, lOk /*lOk*/, aColsSEV /*aCols*/, lBaixou /*lBaixou*/, aGrvLctPco /*aGrvLctPco*/,;
						lUsaFlag /*lUsaFlag*/, @aFlagCTB /*@aFlagCTB*/)

						If VerPadrao("537") .and. !lPadraoBx .and. cPadrao=="530"
							lPadraoBx := .T.
						Endif
						dDataBase   := dDtaAnt
					EndIf

					//Ponto de entrada antes da contabilizacao
					If lF080ACONT
						ExecBlock("F080ACONT",.F.,.F.)
					EndIf

					//Finaliza a gravacao dos lancamentos do SIGAPCO
					PcoFinLan("000005")

					//³Integracao protheus X tin Baixa Manual
					dbSelectArea(cAlias)
					If nSalvRec > 0
						dbGoTo(nSalvRec)
					EndIf
					dbSetOrder(nOrdem)

					//Atualização TMS - Status do Contrato de Carreteiro
					If lBaixou .And. AllTrim(SE2->E2_ORIGEM) == 'SIGATMS'
						aAreaSE2 := SE2->(GetArea())
						TMSA250PBx(SE2->E2_FILORIG, SE2->E2_NUM)
						RestArea(aAreaSE2)
					EndIf

					//Trade-Easy
					//RRC - 05/12/2013 - Integração SIGACOM x SIGAESS e SIGAEIC x SIGAESS a partir dos títulos do SIGAFIN
					/*Verifica se não veio do ESSPS400 pois esta chamada pode ser decorrente da própria PS400BuscFat(), ao atualizar o câmbio do SIGAESS.
					Dessa forma, impede uma recursividade desnecessária*/
					If AvFlags("CONTROLE_SERVICOS_AQUISICAO") .And. !FwIsInCallStack("ESSPS400") .And. lBaixou .And. SE2->E2_TIPO == MVNOTAFIS
						lESSCOM := GetMv("MV_COMSEIC",,.F.) .And. GetMv("MV_ESS0012",,.F.) .And. GetMv("MV_ESS0013",,.F.) .And. AllTrim(SE2->E2_ORIGEM) == "MATA100"
						lESSEIC := GetMv("MV_ESS0022",,.T.) .And. /*AllTrim(SE2->E2_ORIGEM) == "SIGAEIC"*/ AllTrim(SE2->E2_PREFIXO) == "EIC" .And. SWD->(FieldPos("WD_MOEDA")) > 0 .And. SWD->(FieldPos("WD_VL_MOE")) > 0 .And. SWD->(FieldPos("WD_TX_MOE")) > 0  // TDF - 18/06/2015
						If lESSCOM .Or. lESSEIC
							PS400BuscFat("A",If(lESSCOM,"SIGACOM","SIGAEIC"),,SE2->E2_NUM,SE2->E2_PREFIXO,.T.,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_PARCELA)
						EndIf
					EndIf

					If lBaixou .And. FindFunction("NGBAIXASE2") .And. GetNewPar( "MV_NGMNTFI","N" ) == 'S'
						NGBAIXASE2(1)
						// Função que gera uma apropriação de débito da multa, (Integração SIGAFIN - SIGAMNT).
						If FindFunction( "MNT765CONF" ) //Se for executado a baixa automática de pagaento da multa;
							lPagAutFin := .F. //Variável utilizada em fonte especifico do SIGAMNT;
							MNT765CONF( 3 ) 	//Executa a função que gera APD;
						EndIf
					Endif

					dbSelectArea(cAlias)
					If nSalvRec > 0
						dbGoTo(nSalvRec)
					EndIf
					dbSetOrder(nOrdem)
				End Sequence
			End transaction
			//Fim transação de gravação 

			If lBaixou
				//Inicia transação contábil 
				Begin Transaction
				
					If !lSubsPrv .And. (lPadraoBx .or. lPadraoVd) .and. cLanca == "S" .and. !lMultNat
						//Inicializa Lancamento Contabil
						nHdlPrv := HeadProva( cLote, "FINA080" /*cPrograma*/, Substr(cUsuario,7,6), @cArquivo )
					Endif

					If !lSubsPrv .And. lPadraoBx .and. cLanca == "S"  .and. !lMultNat
						//Prepara Lancamento Contabil
						If lUsaFlag // Armazena em aFlagCTB para atualizar no modulo Contabil
							cIDMovE5 := SE5->E5_IDORIG
							aAdd( aFlagCTB, {"E5_LA" , "S", "SE5", SE5->( Recno() ), 0, 0, 0} )

							aAreaCTB := SE5->(GetArea())
							DbSelectArea("SE5")
							SE5->(DbSetOrder(21))
							If SE5->(DbSeek(xFilial("SE5")+ cIDMovE5))
								While SE5->(!EoF()) .and. SE5->E5_IDORIG == cIDMovE5
									If SE5->E5_TIPODOC  $ "JR|DC|VA|MT"
										aAdd( aFlagCTB, {"E5_LA" , "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
									EndIf
									SE5->(DbSkip())
								EndDo
							Endif

							RestArea(aAreaCTB)

							If	lLibCheq .and. !Empty( cCheque ) .and.	left( cCheque, 1 ) != "*" .and.	lGerouSef .and.	!SEF->( Eof( ) )
								//Atualiza flag cheque se houver
								aAdd( aFlagCTB, {"EF_LA" , "S", "SEF", SEF->( Recno() ), 0, 0, 0} )
							Endif
						Endif

						dDataBase := dBaixa
						nTotal += DetProva(nHdlPrv, cPadrao, "FINA080" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/,;
						/*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
						dDataBase := dDtaAnt
					Endif

					If !lSubsPrv .And. !lMultNat .And. lPadraoVd .and. cLanca == "S" .and. TrazCodMot(cMotBx) == "VEN"
						dbSelectArea("SE2")

						IF (dbSeek( cFilial +  Left(SE2-> E2_TITORIG,nTamTitOri)) )
							//Prepara Lancamento Contabil

							If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
								aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
								aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
							Endif

							dDataBase := dBaixa
							nTotal += DetProva(nHdlPrv, "518" /*cPadrao*/, "FINA080" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/,;
							/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/)
							dDataBase := dDtaAnt
						Endif
					Endif

					IF !lSubsPrv .And. (lPadraoBx .or. lPadraoVd ) .and. cLanca=="S" .and. lBaixou
						//-- Se for rotina automatica força exibir mensagens na tela, pois mesmo quando não exibe os lançametnos, a tela
						//-- sera exibida caso ocorram erros nos lançamentos padronizados
						If lF080Auto
							lSetAuto := _SetAutoMode(.F.)
							lSetHelp := HelpInDark(.F.)
							If Type('lMSHelpAuto') == 'L'
								lMSHelpAuto := !lMSHelpAuto
							EndIf
						EndIf

						lDigita := IIf(mv_par01 == 1, .T., .F.)
						lAglut  := IIf(mv_par02 == 1, .T., .F.)

						If lFina080
							Execblock("FINA080",.F.,.F.)
						Endif

						If UsaSeqCor()
							aAdd(aDiario,{"SE5",SE5->(RecNo()),cCodDiario,"E5_NODIA","E5_DIACTB"})
						Else
							aDiario := {}
						EndIf

						//	Define data da contabilização on line
						Do Case 
							Case nDtContOn == 1 // 1- Data Digitação
								dDtLanc := dDataBase
							Case nDtContOn == 2 // 2- Data Disponibilizadade
								dDtLanc := dDebito
							Case nDtContOn == 3 // 3- Data Pagamento
								dDtLanc := dBaixa
						EndCase

						//Efetiva Lan‡amento Contabil
                            If lContabiliza .And. mv_par03 == 1 .And. nHdlPrv != 0
                                dDataBase := dBaixa
                                cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, lDigita, lAglut, /*cOnLine*/, dDtLanc, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, aDiario)
                                dDataBase := dDtaAnt
                                If LanceiCTB
                                    If	!Empty( cCheque ) .and.;
                                        left( cCheque, 1 ) != "*" .and.;
                                        lGerouSef .and.;
                                        !SEF->( Eof( ) ) .and.;
                                        !lUsaFlag
                                        //Atualiza SEF apos contabilização
                                        Reclock("SEF")
                                        SEF->EF_LA := "S"
                                        SEF->(MsUnlock())
                                    Endif

                                    /* Marca flag de contabilizacao da baixa nas FKs */
                                    If !Empty(aCtBaixa) .and. !lUsaFlag
                                        For nX := 1 to Len(aCtBaixa)
                                            If aCtBaixa[nX, ALIAS] == "FK2"
                                                dbSelectArea("FK2")
                                                FK2->(dbSetOrder(1))
                                                If FK2->(dbSeek( xFilial("FK2") + aCtBaixa[nX, IDORIG] ))
                                                    RecLock("FK2",.F.)
                                                    FK2->FK2_LA := "S"
                                                    MsUnlock()
                                                EndIf
                                            ElseIf aCtBaixa[nX, ALIAS] == "FK5"
                                                dbSelectArea("FK5")
                                                FK5->(dbSetOrder(1))
                                                If FK5->(dbSeek( xFilial("FK5") + aCtBaixa[nX, IDORIG] ))
                                                    RecLock("FK5",.F.)
                                                    FK5->FK5_LA := "S"
                                                    MsUnlock()
                                                EndIf
                                            Elseif aCtBaixa[nX, ALIAS] == "SE5"
                                                dbSelectArea("SE5")
                                                DbGoTo(aCtBaixa[nX, IDORIG])
                                                If SE5->(!BoF() .And. !EoF())
                                                    RecLock("SE5",.F.)
                                                    SE5->E5_LA := "S"
                                                    MsUnlock()
                                                EndIf
                                            EndIf
                                        Next nX
                                    EndIf
                                EndIf	
                            EndIf
                            aFlagCTB := {}//Limpa o coteudo apos a efetivacao do lancamento

						If lF080Auto
							HelpInDark(lSetHelp)
							_SetAutoMode(lSetAuto)
							If Type('lMSHelpAuto') == 'L'
								lMSHelpAuto := !lMSHelpAuto
							EndIf
						EndIf

					Endif
					//Pontos de Entrada FA080PE sera executado na saida da funcao de baixa, apos gravar todos os dados e após a contabilização.					
					If (ExistTemplate( "FA080PE" ) )
						ExecTemplate("FA080PE",.F.,.F.)
					Endif

					If lFA080PE
						ExecBlock("FA080PE",.F.,.F.)
					Endif
				End Transaction
			EndIf
		Else
			//Finaliza a gravacao dos lancamentos do SIGAPCO
			PcoFinLan("000005")
		EndIF

		Exit
	Enddo

	If lIsRussia .And. !IsBlind() .And. nOpc1 == 1
		Aviso(STR0233, STR0234)
	EndIf	
	
    //Restaura Pergunte do FINA080
    If Len(aPerg) == 3
        mv_par01    :=  aRestPerg[1]
        mv_par02    :=  aRestPerg[2]
        mv_par03    :=  aRestPerg[3]
    EndIf	

	f080LRatIR(.T.)
	
	If __oImpConf != Nil
		__oImpConf:Destroy()
		__oImpConf := Nil
	EndIf
	
	If __oQryFKQ != Nil 
		__oQryFKQ:Destroy()
		__oQryFKQ := Nil
	EndIf
Return  /*Function fA080Tit*/

//-------------------------------------------------------------------
/*/{Protheus.doc}FA080Lot
Seleciona titulos a serem baixados 
@author Wagner Xavier 
@since  03/08/1992
/*/
//-------------------------------------------------------------------
Function FA080Lot(cAlias,nReg,nOpcx)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Salva a integridade dos dados 										 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	LOCAL oDlg
	LOCAL oDebConta

	LOCAL nSalvRec
	LOCAL lGrava:=.F.
	LOCAL nOrdem
	LOCAL cIndex := ""
	Local cLanca := Iif(mv_par03==1,"S","N")
	Local cSetFilter := SE2->(DBFILTER()) // Salva o filtro
	Local oVencDe
	Local oVencAte
	Local oLoteFin
	Local oBcoLot
	Local cMoedaTx, nA := 0
	Local aSize := {}
	Local oPanel
	Local oPanel1
	Local aButton := { { "PESQUISA", { || Fa070Pesq(oMark, "SE2")  }, "Pesquisar..(CTRL-P)","Pesquisar" } }
	Local bSet16
	Local lF080BxLote:= ExistBLock("F080BXLOTE")
	Local lFinVDoc		:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios

	Local lJFilBco	 := SuperGetMv( "MV_JFILBCO", .F., .F. ) .And. FindFunction("JURF3SA6") .And. FindFunction("JurVldSA6") //Indica se filtra as contas correntes vinculadas ao escritório logado - SIGAPFS.
	Local cEscrit    := Iif(lJFilBco, JurGetDados("NS7", 4, xFilial("NS7") + cFilant + cEmpAnt, "NS7_COD"), "") // Código do escritório relacionado a filial logada - SIGAPFS.
	Local cF3Bco     := Iif(lJFilBco, "SA6JUR", "SA6")

	PRIVATE cBanco		:=CriaVar("E1_PORTADO")
	PRIVATE cAgencia	:=CriaVar("E1_AGEDEP")
	PRIVATE cConta		:=CriaVar("E1_CONTA")
	PRIVATE dBaixa	    := CriaVar("E2_BAIXA")
	PRIVATE nNroTit	:=0
	PRIVATE nTotDesp	:=0
	PRIVATE nTotJur	:=0
	PRIVATE nTotMul	:=0
	PRIVATE nDebConta	:=0
	PRIVATE nTotDesc	:=0
	PRIVATE nTotGer	:=0
	PRIVATE nValor		:=0
	PRIVATE nQtdtit	:=0
	PRIVATE dVencDe	:=Ctod(Space(8))
	PRIVATE cNatDe		:=CriaVar("E2_NATUREZ")
	PRIVATE dVencAte	:=Ctod(Space(8))
	PRIVATE cNatAte	:=CriaVar("E2_NATUREZ")
	PRIVATE lInverte 	:= .F.
	PRIVATE nOtrga    := 0
	PRIVATE nImpSubst := 0
	PRIVATE nDifCambio:= 0
	PRIVATE aTxMoedas	  := {}

	//Reestruturacao SE5
	PRIVATE nDescCalc 	:= 0
	PRIVATE nJurosCalc 	:= 0
	Private nVACalc 	:= 0	// Valores acessórios.
	PRIVATE nMultaCalc 	:= 0
	PRIVATE nCorrCalc	:= 0
	PRIVATE nDifCamCalc	:= 0
	PRIVATE nImpSubCalc	:= 0
	PRIVATE nPisCalc	:= 0
	PRIVATE nCofCalc	:= 0
	PRIVATE nCslCalc	:= 0
	PRIVATE nIrfCalc	:= 0
	PRIVATE nIssCalc	:= 0
	PRIVATE nInsCalc	:= 0
	PRIVATE nPisBaseR 	:= 0
	PRIVATE nCofBaseR	:= 0
	PRIVATE nCslBaseR 	:= 0
	PRIVATE nIrfBaseR 	:= 0
	PRIVATE nIssBaseR 	:= 0
	PRIVATE nInsBaseR 	:= 0
	PRIVATE nPisBaseC 	:= 0
	PRIVATE nCofBaseC 	:= 0
	PRIVATE nCslBaseC 	:= 0
	PRIVATE nIrfBaseC 	:= 0
	PRIVATE nIssBaseC 	:= 0
	PRIVATE nInsBaseC 	:= 0
	PRIVATE nCidBase	:= 0
	
    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT __lMetric := FwLibVersion() >= "20210517"
    DEFAULT lFina450  := FwIsInCallStack("FINA450")
    DEFAULT nTamLote  := TamSX3("E2_LOTE")[1]

	If lIsRussia
		aButton := { { "PESQUISA", { || Fa070Pesq(oMark, "SE2")  }, STR0001 + "..(CTRL-P)", STR0001 } }
	EndIf

	__cFunBkp   := FunName()
	__cFunMet	:= Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA080",__cFunBkp)

	If __lMetric
		SetFunName(__cFunMet)
		// Metrica de controle de acessos 
    	FwCustomMetrics():setSumMetric(Alltrim(ProcName()), "financeiro-protheus_qtd-por-acesso_total", 1)
		SetFunName(__cFunBkp)
	Endif

	SE2->(MsUnlock())

	SX3->(dbSetOrder(1))  // Queiroz Galvao

	lBxLote := .T.

	If cPaisLoc <> "BRA"
		Aadd(aTxMoedas,{"",1,PesqPict("SM2","M2_MOEDA1")})
		For nA	:=	2	To MoedFin()
			cMoedaTx	:=	Str(nA,IIf(nA <= 9,1,2))
			If !Empty(GetMv("MV_MOEDA"+cMoedaTx))
				Aadd(aTxMoedas,{GetMv("MV_MOEDA"+cMoedaTx),RecMoeda(dDataBase,nA),PesqPict("SM2","M2_MOEDA"+cMoedaTx) })
			Else
				Exit
			Endif
		Next
	EndIf

	While .T.
		nTotAGer  := 0 // Variaveis para acumulo dos valores
		nTotADesp := 0 // na baixa
		nTotADesc := 0
		nTotAMul	 := 0
		nTotAJur	 := 0

		If Type("lWserver") == "U"
			cMarca := Get080Mark()
		Else
			cMarca := ''
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Salva ordem atual 												³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea( cAlias )
		nOrdem 	:= IndexOrd()
		nSalvRec := Recno()
		nOpc1 	:= 1
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Desenha tela padrao do browse								  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nValor := 0
		nQtdtit:= 0

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se data do movimento ‚ menor que data limite de     ³
		//³ movimentacao no financeiro                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SuperGetMv("MV_BXDTFIN",,"1") == "2" .and.!DtMovFin(,,"1")
			lBxLote := .F.
			Return
		Endif

		aSize := MSADVSIZE()

		If IsPanelFin()  //Chamado pelo Painel Financeiro
			dbSelectArea(cAlias)
			oPanelDados := FinWindow:GetVisPanel()
			oPanelDados:FreeChildren()
			aDim := DLGinPANEL(oPanelDados)
			DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Observacao Importante quanto as coordenadas calculadas abaixo: ³
			//³ -------------------------------------------------------------- ³
			//³ a funcao DlgWidthPanel() retorna o dobro do valor da area do   ³
			//³ painel, sendo assim este deve ser dividido por 2 antes da sub- ³
			//³ tracao e redivisao por 2 para a centralizacao. 				   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nEspLarg := (((DlgWidthPanel(oPanelDados)/2) - 266) /2) -5
			nEspLin  := 0

		Else

			IF lF080BxLote
				cLoteFin := ExecBlock ("F080BXLOTE",.F.,.F.)
			EndIf

			DEFINE MSDIALOG oDlg FROM	102,5 TO 301,552 TITLE OemToAnsi(STR0058)	PIXEL //"Baixa a Pagar em Lote"
			nEspLarg := 0
			nEspLin  := 0

		Endif

		oDlg:lMaximized := .F.
		oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
		oPanel:Align := CONTROL_ALIGN_ALLCLIENT

		@ 02+nEspLin, 004+nEspLarg TO 98+nEspLin, 77+nEspLarg  LABEL OemToAnsi(STR0059) 	 		PIXEL OF oPanel   //"Dados Banc rios"
		@ 02+nEspLin, 079+nEspLarg TO 98+nEspLin, 180+nEspLarg LABEL OemToAnsi(STR0060) 			PIXEL OF oPanel //"Valores"
		@ 02+nEspLin, 182+nEspLarg TO 73+nEspLin, 270+nEspLarg LABEL OemToAnsi(STR0061)			PIXEL OF oPanel //"Filtragem"

		@ 15+nEspLin, 09+nEspLarg SAY OemToAnsi(STR0022)				SIZE 30, 7 	PIXEL OF oPanel //"Banco"
		@ 12+nEspLin, 35+nEspLarg MSGET oBcoLot VAR cBanco			SIZE 20, 10 PIXEL OF oPanel Hasbutton Picture "@!" F3 cF3Bco Valid ;
			If(nOpc1<>0,CarregaSA6(@cBanco,,,.T.) .And. fa080BcoCx() .And. Iif(lJFilBco, JurVldSA6("1", {cEscrit, cBanco, cAgencia, cConta}), .T.), .T.)
		@ 29+nEspLin, 09+nEspLarg SAY OemToAnsi(STR0023)			  	SIZE 30, 7  PIXEL OF oPanel //"Agˆncia"
		@ 26+nEspLin, 35+nEspLarg MSGET cAgencia 						SIZE 25, 10 PIXEL OF oPanel Picture "@!" Valid ;
			If(nOpc1<>0,CarregaSA6(@cBanco,@cAgencia,,.T.) .And. Iif(lJFilBco, JurVldSA6("2", {cEscrit, cBanco, cAgencia, cConta}), .T.), .T.)
		@ 42+nEspLin, 09+nEspLarg SAY OemToAnsi(STR0024)				SIZE 29, 7  PIXEL OF oPanel //"Conta"
		@ 40+nEspLin, 35+nEspLarg MSGET cConta							SIZE 38, 10 PIXEL OF oPanel Picture "@!" Valid ;
			If(nOpc1<>0, IF(CarregaSA6(@cBanco,@cAgencia,@cConta,.T.,,.T.) .And. Iif(lJFilBco, JurVldSA6("3", {cEscrit, cBanco, cAgencia, cConta}), .T.), .T., oBcoLot:SetFocus()), .T.)

		@ 56+nEspLin, 09+nEspLarg SAY OemToAnsi(STR0062)				SIZE 30, 7	PIXEL OF oPanel //"N.Titulos"
		@ 54+nEspLin, 35+nEspLarg MSGET nNroTit							SIZE 13, 10 PIXEL OF oPanel Picture "999" Valid nNroTit > 0
		@ 70+nEspLin, 09+nEspLarg SAY OemToAnsi(STR0063)				SIZE 29, 7  PIXEL OF oPanel //"Lote"
		@ 69+nEspLin, 35+nEspLarg MSGET oLoteFin VAR cLoteFin 		SIZE 19, 10 PIXEL OF oPanel ;
		When UltiLote() ;
		Valid CheckLote("P") Picture "@!"
		@ 14+nEspLin, 084+nEspLarg SAY OemToAnsi(STR0064)	  		SIZE 53, 7  PIXEL OF oPanel //"Valor T¡tulos"
		@ 11+nEspLin, 125+nEspLarg MSGET nTotGer					SIZE 52, 08 PIXEL OF oPanel Hasbutton Picture PesqPict("SE2","E2_VALOR") Valid MontaTot(oDebConta)
		@ 27+nEspLin, 084+nEspLarg SAY OemToAnsi(STR0065)	 		SIZE 53, 7  PIXEL OF oPanel //"Total Despesas"
		@ 25+nEspLin, 125+nEspLarg MSGET nTotDesp					SIZE 52, 08 PIXEL OF oPanel Hasbutton Picture PesqPict("SE2","E2_VALOR") Valid MontaTot(oDebConta)
		@ 42+nEspLin, 084+nEspLarg SAY OemToAnsi(STR0066) 			SIZE 53, 7  PIXEL OF oPanel //"Total Descontos"
		@ 39+nEspLin, 125+nEspLarg MSGET nTotDesc					SIZE 52, 08 PIXEL OF oPanel Hasbutton Picture PesqPict("SE2","E2_VALOR") Valid MontaTot(oDebConta)
		@ 56+nEspLin, 084+nEspLarg SAY OemToAnsi(STR0067)			SIZE 53, 7	PIXEL OF oPanel //"Total Multas"
		@ 54+nEspLin, 125+nEspLarg MSGET nTotMul 					SIZE 52, 08 PIXEL OF oPanel Hasbutton Picture PesqPict("SE2","E2_VALOR") Valid MontaTot(oDebConta)
		@ 70+nEspLin, 084+nEspLarg SAY OemToAnsi(STR0068)			SIZE 53, 7	PIXEL OF oPanel //"Total Juros"
		@ 69+nEspLin, 125+nEspLarg MSGET nTotJur 					SIZE 52, 08 PIXEL OF oPanel Hasbutton Picture PesqPict("SE2","E2_VALOR") Valid MontaTot(oDebConta)
		@ 85+nEspLin, 084+nEspLarg SAY OemToAnsi(STR0069)	  		SIZE 53, 7  PIXEL OF oPanel //"D‚bito em C/C"
		@ 83+nEspLin, 125+nEspLarg MSGET oDebConta VAR nDebConta	SIZE 52, 08 PIXEL OF oPanel Hasbutton Picture PesqPict("SE2","E2_VALOR")

		@ 16+nEspLin, 187+nEspLarg SAY OemToAnsi(STR0070) 			SIZE 44, 7	PIXEL OF oPanel //"Do Vencto."
		@ 14+nEspLin, 225+nEspLarg MSGET oVencDe VAR dVencDe		SIZE 45, 10 PIXEL OF oPanel Hasbutton Valid ! Empty(dVencDe)
		oVencDe:cReadVar := "DVENCINI"  // Help
		@ 30+nEspLin, 187+nEspLarg SAY OemToAnsi(STR0071) 			SIZE 42, 7	PIXEL OF oPanel //"Até o Vencto."
		@ 28+nEspLin, 225+nEspLarg MSGET oVencAte VAR dVencAte		SIZE 45, 10 PIXEL OF oPanel Hasbutton Valid dVencAte >= dVencDe
		oVencAte:cReadVar := "DVENCFIM" // Help
		@ 45+nEspLin, 187+nEspLarg SAY OemToAnsi(STR0072) 	  		SIZE 39, 7  PIXEL OF oPanel //"Da Natureza"
		@ 42+nEspLin, 225+nEspLarg MSGET cNatDe						SIZE 45, 10 PIXEL OF oPanel Hasbutton Picture "@!" F3 "SED"
		@ 59+nEspLin, 187+nEspLarg SAY OemToAnsi(STR0073)   		SIZE 45, 7  PIXEL OF oPanel //"At‚ a Natureza"
		@ 57+nEspLin, 225+nEspLarg MSGET cNatAte 					SIZE 45, 10 PIXEL OF oPanel Hasbutton Picture "@!" Valid cNatAte >= cNatDe F3 "SED"


		If IsPanelFin()  //Chamado pelo Painel Financeiro
			oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])
			ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
			{||,nOpc1 := 1,IIF(Empty(cLoteFin),(oLoteFin:SetFocus(),nOpc1 := 0),oDlg:End())},;
			{||,nOpc1 := 0,oDlg:End()});
			VALID (iif(nOpc1==1,Fa080Cont().and. ValidaTot(cLoteFin),.t.))

			FinVisual(cAlias,FinWindow,(cAlias)->(Recno()),.T.)


		Else
			DEFINE SBUTTON FROM 80, 214 TYPE 1 ENABLE OF oDlg ACTION (nOpc1 := 1,IIF(Empty(cLoteFin),(oLoteFin:SetFocus(),nOpc1 := 0),oDlg:End()))
			DEFINE SBUTTON FROM 80, 244 TYPE 2 ENABLE OF oDlg ACTION (nOpc1 := 0,oDlg:End())

			ACTIVATE MSDIALOG oDlg VALID (iif(nOpc1==1,Fa080Cont().and. ValidaTot(cLoteFin),.t.)) CENTERED
		Endif

		If nOpc1 != 1
			Exit
		Endif

		dbSelectArea( cAlias )

		//Acerto a moeda do banco
		nMoedaBco := Max( MoedaBco(cBanco,cAgencia,cConta), 1 )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Execblock a ser executado antes da Indregua                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ExistBlock("F080FIL")
			cFil080 := ExecBlock("F080FIL",.f.,.f.)
		Else
			cFil080 := ""
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Filtra o arquivo para titulos em abertos					 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cIndex := CriaTrab(nil,.f.)
		cChave	:= IndexKey()
		IndRegua("SE2",cIndex,cChave,,FA080ChecF(),OemToAnsi(STR0074) ) //"Selecionando Registros..."
		nIndex := RetIndex("SE2")
		dbSelectArea("SE2")
		dbSetOrder(nIndex+1)
		DbGoTop()
		IF BOF() .and. EOF()
			Help(" ",1,"RECNO")
			Exit
		EndIF

		nValor	:= 0		// valor total dos T¡tulos,mostrado no rodape do browse
		nQtdtit	:= 0		// quantidade de T¡tulos,mostrado no rodape do browse
		nOpca	:= 0

		//Faz o calculo automatico de dimensoes de objetos
		oSize := FwDefSize():New(.T.)

		oSize:lLateral := .F.
		oSize:lProp	:= .T. // Proporcional

		oSize:AddObject( "1STROW" ,  100, 05, .T., .T. ) // Totalmente dimensionavel
		oSize:AddObject( "2NDROW" ,  100, 95, .T., .T. ) // Totalmente dimensionavel

		oSize:aMargins := { 2, 2, 1, 2 } // Espaco ao lado dos objetos 0, entre eles 3

		oSize:Process() // Dispara os calculos

		a1stRow := {oSize:GetDimension("1STROW","LININI"),;
		oSize:GetDimension("1STROW","COLINI"),;
		oSize:GetDimension("1STROW","LINEND"),;
		oSize:GetDimension("1STROW","COLEND")}

		a2ndRow := {oSize:GetDimension("2NDROW","LININI"),;
		oSize:GetDimension("2NDROW","COLINI"),;
		oSize:GetDimension("2NDROW","LINEND"),;
		oSize:GetDimension("2NDROW","COLEND")}

		DEFINE MSDIALOG oDlg1 TITLE STR0075 From oSize:aWindSize[1],oSize:aWindSize[2] to oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL //"Baixa em Lote"
		oDlg1:lMaximized := .T.

		Dbeval( { |a| FA080Dbeva() } )

		oPanel1 := TPanel():New(05,a1stRow[4]-150,'',oDlg,,,,, ,150,20)

		@ a1stRow[1] + 001, a1stRow[2] + 001 To a1stRow[3],a1stRow[4] PIXEL OF oDlg1
		@ a1stRow[1] + 003, a1stRow[2] + 005 Say STR0076 PIXEL Of oDlg1 // "Valor Total:"
		@ a1stRow[1] + 003, a1stRow[2] + 060 Say oValor VAR nValor Picture PesqPict("SE2","E2_VALOR") PIXEL Of oDlg1
		@ a1stRow[1] + 003, a1stRow[2] + 120 Say STR0077 PIXEL Of oDlg1// "Quantidade:"
		@ a1stRow[1] + 003, a1stRow[2] + 150 Say oQtda VAR nQtdTit Picture "@E 99999" SIZE 50,10 PIXEL of oDlg1

		oMark := MsSelect():New(cAlias,"E2_OK","!E2_SALDO",,@lInverte,@cMarca,{a2ndRow[1],a2ndRow[2],a2ndRow[3],a2ndRow[4]})
		oMark:bMark := {| | finaDisplay(cMarca,lInverte,oValor,oQtda,"P")}
		oMark:bAval	:= {|| Fa080bAval(cAlias,cMarca,oValor,oQtda)}
		oMark:oBrowse:lhasMark = .t.
		oMark:oBrowse:lCanAllmark := .t.
		oMark:oBrowse:bAllMark := { || FA080Inverte(cMarca,oValor,oQtda) }
		bSet16 := SetKey(16,{||Fa070Pesq(oMark,"SE2")})

		If IsPanelFin()  //Chamado pelo Painel Financeiro
			ACTIVATE MSDIALOG oDlg1 ON INIT FaMyBar(oPanel1,{||nOpca := 1,oDlg1:End()},{|| nOpca := 2,oDlg1:End()},aButton)
		Else
			ACTIVATE MSDIALOG oDlg1 ON INIT EnchoiceBar(oDlg1,{|| nOpca := 1,oDlg1:End()},{|| nOpca := 2,oDlg1:End()},,aButton) CENTERED
		Endif

		SetKey(16,bSet16)

		IF nOpcA == 1
			IF lFinVDoc
				SE2->(dbGoTo(RECNO()))
				If CN062ValDocs("04",.T.)
					lGrava := fA080Grava(cLanca)
				EndIf
			Else
				lGrava := fA080Grava(cLanca)
			EndIf
		Endif
		Exit

	EndDO
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Restaura os indices 								     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE2")
	RetIndex("SE2")
	dbSetOrder(nOrdem)
	If nSalvRec > 0
		dbGoTo(nSalvRec)
	EndIf
	cLoteFin := SPACE(nTamLote)
	// Restaura o filtro, para que o usuario que utilizar filtro atraves do PE F080BROW
	// nao perca este filtro.
	Set Filter to &cSetFilter.
	lBxLote := .F.
	f080LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo
	If lIsRussia .And. !IsBlind() .And. nOpc1 == 1
		Aviso(STR0233, STR0234)
	EndIf
Return /*Function FA080Lot*/

//-------------------------------------------------------------------
/*/{Protheus.doc}fa080Can
Rotina de Cancelamento de Baixa a pagar 
@author Wagner Xavier 
@since  06/05/1992
/*/
//-------------------------------------------------------------------
Function fa080Can(cAlias,nReg,nOpcx,aEncho,nOpBaixa,lMov,aPerg)

    LOCAL dDtBaixa	AS DATE
	Local cChave	As Character

    Local lPanelFin := IsPanelFin()
	Local oDlg
	Local lOk			:= .F.
	Local lDigita		:= .F.
	Local lAglut		:= .F.
	Local nHdlPrv		:= 0
	Local nTotal		:= 0
	Local lPadraoBx
	Local nOrdem
	Local lPadraoVd
	Local cArquivo
	Local nSalvRec		:= 0
	Local cParcela
	Local cNum
	Local cPrefixo
	Local dBaixa
	Local dDebito
	Local cAgencia		:= CriaVar("E1_AGEDEP")
	Local cCheque		:= CriaVar("EF_NUM")
	Local cFornece
	Local cMoeda
	Local cTitAnt
	Local cDescrMo		:= " "
	Local aBaixa		:= {}
	Local cTipo
	Local nJuros		:= 0
	LOCAL nVA	 		:= 0	// Valores acessórios.
	Local nMulta		:= 0
	Local nCorrec		:= 0
	Local nDescont		:= 0
	Local nAcresc		:= 0
	Local nDecresc		:= 0
	Local dDataAnt
	Local lBaixaAbat	:= .F.
	Local cSequencia	:= "  "
	Local cParcCanc		:= ""
	Local nRegB
	Local lVend			:= .F.
	Local nRegV
	Local lCheque		:= .F.
	Local cBenef		:= ""
	Local oBenef
	Local cTitPai		:= ""
	Local lContabilizou
	Local lBkpContab 	:= .F.
	Local cNumCheq		:= CRIAVAR("EF_NUM")
	Local lEstorna
	Local nTotAdto		:= 0
	Local cSeqSe5		:= Space(TamSX3("E5_SEQ")[1])
	Local nTxMoeda		:= 0
	Local cTipoDoc		:= ""
	Local aAux			:= {}
	Local nI			:= 0
	Local nRecDelSef	:= 0
	Local nRecSe2		:= 0
	Local nRecSe5		:= 0
	Local lRet			:= .T.
	Local lFa080Own		:= ExistBlock("FA080OWN")
	Local lFa080Est		:= ExistBlock("FA080EST")
	Local lFa080VEst	:= ExistBlock("FA080VEST")
	Local lEst			:= .T.
	Local aMotBx		:= ReadMotBx()
	Local cPadrao
	Local cTitOriV		:= CRIAVAR("E2_TITORIG")
	Local lBaixaOk		:= .T.
	Local nOrdSa6		:= 0
	Local nRecSa6		:= 0
	Local nDifCambio	:= 0
	Local nImpSubst		:= 0
	Local nOtrga		:= 0
	Local nAtraso		:= 0
	Local lLanca		:= .F.
	Local lCnab			:= .F.
	Local cModSPB		:= "1"	// Modalidade de SPB
	Local aModalSpb		:= {"TED","CIP","COMP"}
	Local cDescSpb		:= "TED"
	Local nTamTitOri	:= TamParcela("E2_PARCELA",19,20,21)
	Local lSetDeleted	:= SET(_SET_DELETED)
	Local cSefOrigem	:= ""
	Local lDeleted		:= .F.
	Local cEfImpress	:= ""
	Local lBxCEC		:= .F.  //Verificador de existencia de baixa por compensacao entre carteiras
	Local lAcreDecre	:= .F.
	Local nMoedaBco		:= 1
	Local nMoedaTit		:= SE2->E2_MOEDA
	Local nTxModBco		:= 0
	Local nTxModTit		:= 0
	Local lContrRet		:= .T.
	Local nPis			:= 0
	Local nCofins		:= 0
	Local nCsll			:= 0
	Local nPisOld		:= 0
	Local nCofOld		:= 0
	Local nCslOld		:= 0
	Local nVRPisOld		:= 0
	Local nVRCofOld		:= 0
	Local nVRCslold		:= 0
	Local aImp			:= {}
	Local nLinha		:= 0
	Local nX			:= 0
	Local lNotBax		:= .F.
	Local lAglImp		:= .F.
	Local nCentMd1		:= MsDecimais(1)
	Local nTotImpost	:= 0  //Valores de baixas de por geracao de impostos
	Local nTotaIRPF		:= 0
	Local lIRPFBaixa	:= .F.
	Local nIrrf			:= 0
	Local lRetSoIrf		:= .F.  //Baixa reteve apenas IRRF
	Local cParcPis		:= ""
	Local cParcCof		:= ""
	Local cParcCsl		:= ""
	Local lAchouRel		:= .F.
	Local lCideBX       := cPaisLoc == "BRA" .And. SuperGetMv("MV_FGCIDE",.T.,"2") == "1" // Define o fato gerador do imposto CIDE. 1 = Baixa ou 2 = Emissão
	Local nCide			:= 0
	Local lCalcIssBx	:= IsIssBx("P")
	Local nIss			:= 0
	Local lBxConc		:= GetNewPar("MV_BXCONC","2") == "1"
	Local lExclusao		:= .F. //Para tratar a exclusao de baixa (BOPS 134077)
	Local lIntegracao	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
	Local lPaBruto		:= GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor
	Local lCb10925		:= GetNewPar("MV_CB10925","2") == "1"
	Local lIsIrBx		:= .F.
	Local lFina379		:= FwIsInCallStack("FINA379")
	Local lRecalcPCC	:= GetNewPar("MV_RC10925","2") == "1"
	Local oTipo
	Local oBanco
	Local dVencRea
	Local aFlagCTB		:= {}
	Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	Local lCTBaixa  	:= SuperGetMV("MV_CTBAIXA", .F., "C") == "C"
	Local lAtuSldNat	:= .T.
	Local lSubstPR		:= FwIsInCallStack("F050RetPR") //Estorno de subistituicao de titulo provisorio
	Local a450ListBx	:= {}
	Local cNatIss		:= ""
	Local cChavePai		:= ""
	Local lBxLiq		:= .F.
	Local aDiario		:= {}
	Local nPosMotBx		:= 0
	Local lESSCOM		:= .F. //Trade-Easy - RRC - 17/07/2013 - Integração SIGACOM x SIGAESS: Geração automática das invoices e parcelas de câmbio a partir do documento de entrada
	Local lESSEIC		:= .F. //Trade-Easy - RRC - 05/12/2013 - Integração SIGAEIC x SIGAESS: Geração automática das parcelas de câmbio a partir dos títulos
	Local cFilBor		:= ""
	Local lInssBx		:= SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
	Local nInss			:= 0
	Local nInssParc		:= 0
	Local nVlRetin		:= SuperGetMv("MV_VLRETIN",.F.,0)
	Local lAltVr		:= .T.
	Local nMinINS1		:= SuperGetMv("MV_MININSS",.F.,0)
	Local nLimInss		:= GetMv("MV_LIMINSS",.F.,0)
	Local nMinINS2		:= SuperGetMv("MV_VLRETIN",.F.,0)
	//Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
	Local lInsPub		:=	SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And. nLimInss == 0 .And. nMinINS2 == 0
	Local lCanBorder	:= GetMv("MV_CANBORP") == "S"//Cancelamento do borderô
	Local cTpBxCtb		:= ""
	Local lCtbEstn		:= .F.
	Local lAtuForn		:= SuperGetMv("MV_ATUFORN",.F.,.T.)
	//Reestruturacao SE5
	Local aAreaAnt		:= {}
	Local oModelBx		:= nil//FWLoadModel("FINM020")
	Local cLog			:= ""
	Local nOperFK2		:= 0
	Local aAreaSE2		:= {}
	Local aAreaSE5		:= {}
	Local lCpRet		:= .F.
	Local cTpDesc		:= ""
	Local cHistCan070	:= " "
	Local lExistFJU		:= FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")
	Local lDtCanBx		:= SE5->(ColumnPos("E5_DTCANBX")) > 0
	Local aAreaE5		:= {}
	Local aBorrado		:= {}
	Local lCancPFS  	:= .T.
	Local llOpc 		:= .F.
	Local aEaiRet 		:= {}
	Local aButtons      := {}
	Local nImpBor 		:= 0
	Local cChaveFK7 	:= ""
	Local cChaveSE2 	:= ""
	Local nBaixa 		:= 0
	Local aRestPerg     := {}
	Local oNomFor
	Local oMyBar		:= NIL
	Local oFont24		:= TFont():New("Arial",10,24,,.F.,,,,.T.,.F.)
	Local cOpcao		:= Upper(STR0241) //"Cancelar"
	Local aAreaAt		:= {}
	Local nOrFKABkp		:= 1
	Local dDatSave		:= dDataBase  //Save actual date -- RUSSIA, na rotina de Bank Statement, a data do cancelamento deve ser a mesma da baixa e nao a do dia==Bs we must consider the date of operation and not the actual day
	Local lTemPCCBX		:= .F.
	Local lTemISSBX		:= .F.
	Local nCasDec   	:= TamSx3("E2_TXMOEDA")[2]
	Local nQtdBx        := 0
	Local nSaldoBx      := 0
	Local lValPedim		:= (cPaisLoc $ "MEX" .And. FunName() $ "MATA447" .And. FindFunction("LxVldBaixa"))
	Local lCtCanAut		:= .F.
	Local lBord241		:= .F.
	Local nTamE5Seq		:= TamSX3("E5_SEQ")[1]
    Local ntxLiqCamb    := 0
	Local cDocSE2		:= ""
	Local cIdFk2		:= ""
	Local cDocKey		:= ""
	Local aImpos		:= {{"PIS"},{"COF"},{"CSL"},{"IRF"},{"ISS"}}
	Local lRetBor       := .T.
	Local lMovBcoBx     := .T.
	Local lF080ActSEK	:= FindFunction("F080ActSEK")	
	Local lCOL4XMIL		:= cPaisLoc == "COL" .And. FindFunction("FINXBJ4XML")
	Local cTributo 		:= ""
	Local cChaveFK4 	:= ""
	Local cPret 	    := ""
	Local nVlrTribut 	:= 0

	Default nOpBaixa    := 1
	Default lMov        :=.T.
    Default aPerg 		:= {}

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT __F080EXEA  := ExistBlock("F080EXEA")
	DEFAULT __F080PCAN  := ExistBlock("F080PCAN")
    DEFAULT __lEAIF080  := FWHasEAI("FINA080",.T.,,.T.)
    DEFAULT __lMetric   := FwLibVersion() >= "20210517"
    DEFAULT __lPodeTVA  := ExistFunc("FAPodeTVA")
    DEFAULT _lTemMR	    := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
    DEFAULT lFina450    := FwIsInCallStack("FINA450")
    DEFAULT lIntPFS	    := SuperGetMv("MV_JURXFIN",.T.,.F.)
    DEFAULT lPCCBaixa   := (SuperGetMv("MV_BX10925",.T.,"2") == "1")
    DEFAULT lSpbInUse   := SpbInUse() .AND. VerCpoSPB()
    DEFAULT nTamCodA6   := TamSX3("A6_COD")[1]
    DEFAULT nTamHist    := TamSX3("E5_HISTOR")[1]
    DEFAULT nTamParc    := TamSX3("E2_PARCELA")[1]

	PRIVATE aBaixaSE5 := {}
	PRIVATE aRecBorra := {}
	
	__cFunBkp   := FunName()
	__cFunMet	:= Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA080",__cFunBkp)
	__BordeImp  := IIf(__BordeImp == Nil, FindFunction("BorderoImp"), __BordeImp)
	
	f080LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

	If __lMetric
		SetFunName(__cFunMet)
		// Metrica de controle de acessos
		If nOpcx == 6 
    		FwCustomMetrics():setSumMetric(Alltrim(ProcName())+"_Exclusão", "financeiro-protheus_qtd-por-acesso_total", 1)
		Else
			FwCustomMetrics():setSumMetric(Alltrim(ProcName())+"_Cancelamento", "financeiro-protheus_qtd-por-acesso_total", 1)
		Endif		
		SetFunName(__cFunBkp)
	Endif

	nPagtoParcial	:=	0
	
	If __BordeImp .And. !Empty(SE2->E2_NUMBOR) .And. !SE2->E2_TIPO $ MVPAGANT+"|"+MVPROVIS+"|"+MV_CPNEG
		lRetBor := !BorderoImp(SE2->E2_FILORIG, SE2->E2_NUMBOR, "P", SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA)	 
	Endif
	
	lRetBor := IIf(__BordeImp, lRetBor, VLDBOR(SE2->E2_NUMBOR,"P",cFilAnt))

    //Realiza o Backup das informações do pergunte original da rotina
    If Len(aPerg) >= 3
		AADD(aRestPerg,mv_par01) // Mostra Lançamento Contabil
		AADD(aRestPerg,mv_par02) // Aglutina Lançamento
		AADD(aRestPerg,mv_par03) // Contabiliza Online
		
		//Repasse do Pergunte de origem FINA090 ou FINA091
        mv_par01    := aPerg[1]
        mv_par02    := aPerg[2]
        mv_par03    := aPerg[3]
		If Len(aPerg) == 4
			nHdlPrv   := aPerg[4]
		Endif
		lCtCanAut := (nHdlPrv > 0)
    EndIf

	//Validação dos Perguntes ref. a Contabilização Online
    lDigita  := If( mv_par01 == 1 , .T. , .F. )
    lAglut   := If( mv_par02 == 1 , .T. , .F. )
    lLanca   := If( mv_par03 == 1 , .T. , .F. )

	//Tratamento de rotina automatica
	IF Type("lF080Auto") <> "L"
		lF080Auto := .F.
	EndIf

	//Valores Acessórios
	If __lExistVA == NIL
		__lExistVA 		:= TableInDic("FKD") .and. TableInDic("FKC") .and. FindFunction("FINA080VA")
	EndIF

	If __lLGPD == NIL
		__lLGPD	:= FindFunction("RetGlbLGPD")
	EndIf	

	//se estiver sendo chamado via rotina automática a partir da compensação entre carteiras,
	//nao deve processar ISS E IR
	If lFina450 .and. lF080Auto
		lCalcIssBx := .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Procura pelas baixas deste titulo                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aBaixa := Sel080Baixa("VL /BA /CP /",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,@nTotAdto,;
	@lBaixaAbat,SE2->E2_FORNECE,SE2->E2_LOJA,@lBxCec,(!lIsRussia),@lNotBax,@nTotImpost,@lAglImp,;
	((lFina450 .or. FwIsInCallStack("FINA703")) ) ,lFina379,@nTotaIRPF,SE2->E2_IDENTEE,@lBxLiq,SE2->E2_FILORIG) // Recalculo do PCC (FINA379))
	
	//ordenar array de abaixa de forma crescente pelo sequencia E5_SEQ
	aSort(aBaixa,,,{|x,y| Right(x, nTamE5Seq) < Right(y, nTamE5Seq)})
	aSort(aBaixaSE5,,,{|x,y| x[9] < y[9]})

	If lIsRussia .and. (Type("lF080Auto")<>"U" .and. lF080Auto) .AND.  (nT := ascan(aAutoCab,{|x| x[1] == 'AUTPAYORD'}) ) > 0
		//Used to find the write-off related to that payment order received in variable AUTPAYORD.
		nX := ascan(aBaixaSE5,{|x| x[29] == aAutoCab[nT][2]})
		If nX > 0
			nOpBaixa := nX
			//check if we need to change the date do original
			If  (nT := ascan(aAutoCab,{|x| x[1] == 'AUTORIGDT'}) ) > 0 //use the original database
				//Consider the original data base relatated to this cancel BS(cancel use original date and storno use the actual date)
				//RUSSIA, na rotina de Bank Statement, a data do cancelamento deve ser a mesma da baixa e nao a do dia // Bs we must consider the date of operation and not the actual day
				If aAutoCab[nT][2]
					dDataBase  :=  aBaixaSE5[nX,7]
				Endif
			Endif
			nX       := 0
		EndIf
	ENDIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o Titulo nao sofreu nenhuma baixa 						 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF Empty(SE2->E2_BAIXA) .And. ( Len(aBaixa)<=0 )
		If lIsRussia
			Help(NIL,NIL,"TITNAOXADO", NIL, "", 1, 0, NIL, NIL, NIL, NIL, NIL, {""}) // show only problem description, not solution
		Else
			Help(" ",1,"TITNAOXADO")
		EndIf
		Return /*Function fa080Can*/
	EndIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso tenha sido gerado pelo SigaEic e do tipo PR nao podera se baixado se nao for pela rotina automatica ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lF080Auto .and. lIntegracao .and.  SE2->E2_TIPO = "PR "  .and. UPPER(SE2->E2_ORIGEM) = "SIGAEIC"
		HELP(" ",1,"FAORIEIC")
		Return /*Function fa080Can*/
	Endif

	//DFS - 16/03/11 - Deve-se verificar se os títulos foram gerados por módulos Trade-Easy, antes de apresentar a mensagem.
	// TDF - 26/12/11 - Acrescentado o módulo EFF para permitir liquidação
	// NCF - 25/03/13 - Acrescentado o módulo SIGAESS (Siscoserv)
	If !lF080Auto .And. (UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEEC/SIGAEDC/SIGAECO/SIGAESS/SIGAEFF" .AND. (nOpcx == 5 .Or. nOpcx == 6) .AND. !(cModulo $ "EEC/EDC/ECO/EFF/ESS") .AND.;
		Posicione("SA2",1,xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA),"A2_PAIS") <> "105" .AND. SE2->E2_MOEDA > 1)
		HELP(" ",1,"FAORIEEC")
		Return
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso tenha sido gerado pelo SigaEic e do tipo INV e do BRASIL   ³
	//³ nao podera se baixado se nao for pela rotina automatica         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lF080Auto .and. lIntegracao .and. cPaisloc = "BRA" .and.  SE2->E2_TIPO = "INV"  .and. UPPER(SE2->E2_ORIGEM) = "SIGAEIC"
		HELP(" ",1,"FAORIEIC")
		Return /*Function fa080Can*/
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o Titulo teve cheque sobre titulo						 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF !Empty(SE2->E2_IMPCHEQ)
		Help(" " , 1 , "FA080TEMCH")
		Return /*Function fa080Can*/
	EndIF

	//Checks SE2 record for reversal, it can not be cancelled for Russia******
	//according to specification FI-CF-23-3***********************************
	If lIsRussia .AND. RU06XFUN28(SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+;
																			E2_TIPO  +E2_FORNECE+E2_LOJA))
		Help("",1,STR0223/*Reversal of PA*/,,STR0224/*This kind of WRITE OFF cannot be canceled*/,;
			1,0,,,,,,{STR0225/*Reversal Of PA is a system Write off and cannot be canceled*/}) 
		Return /*Function fa080Can*/
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o titulo for um adiantamento de viagem e estiver com status de encerrado ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If (ALLTRIM(SE2->E2_ORIGEM) $ "FINA667|FINA677") .and. !(FINVERRES(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),SE2->E2_ORIGEM, "P"))
		Help(" " , 1 , "FAVIAGEM")
		Return /*Function fa080Can*/
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ AAF - Titulos originados no SIGAEFF não devem ser alterados   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lF080Auto .AND. "SIGAEFF" $ SE2->E2_ORIGEM
		Help(" ",1,"FAORIEFF")
		Return
	EndIf

	// usa o Modulo 88 GTP
	If nModulo <> 88
		If  !lF080Auto .AND. Upper(AllTrim(SE2->E2_ORIGEM)) $ IIF(FindFunction('GTPFUNCRET'),GTPFUNCRET('FINA080','3','SE2'),'GTPA421|GTPA700|GTPA700A|GTPA700L|GTPA819') .And.;
			 Upper(AllTrim(SE2->E2_ORIGEM))<>'P'//-- Origem RM
			Help(" ",1,"NODELGTP",,STR0226,1,0) //"Este título não pode ser excluido ou cancelada sua baixa ,pois foi gerado através do GTP."                                                                                                                                                                                                                                                                                                                                                                                                                         
			Return
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
	//³ movimentacao no financeiro    								 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lF080Auto
		If nOpcx == 5 // cancelamento
			If SuperGetMv("MV_BXDTFIN",,"1") == "2" .and.!DtMovFin(,,"1")
				Return
			Endif
		Elseif nOpcx==6 //exclusao
			If SuperGetMv("MV_BXDTFIN",,"1") == "2" .and.!DtMovFin(dBaixa,,"1")
				Return
			Endif
		Endif
	Endif	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se ‚ um registro Principal									³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF SE2->E2_TIPO $ MVABATIM
		Help(" ",1,"NAOPRINCIP")
		Return /*Function fa080Can*/
	Endif

	//-----------------------------------------------------
	// Validação Siafi
	//-----------------------------------------------------
	If !lSiafi .and. FinTemDH()
		Return .T.
	Endif

	//Caso a rotina esteja cadastrada no adapter, so pode ser enviada como 'Sincrona'. Uma baixa enviada como assincrona
	//sera concretizada mesmo que de erro no sistema integrado.
	If !lFini055
		If !(FA080Integ(.T.))
			Return
		Endif
	Endif

	If _lTemMR
		F080VldImp(.T.)
	EndIf

	//verifica se existem os campos de valores de acrescimo e decrescimo no SE5
	lAcreDecre := .T.

	dbSelectArea("SE2")
	nOrdem:=IndexOrd()
	dbSetOrder(1)
	If cPaisLoc<>"BRA"
		nCentMd1:=4
	EndIf
	cMoeda    := IIF(Empty(SE2->E2_MOEDA),"1",AllTrim(Str(SE2->E2_MOEDA,2)))
	nSalvRec  := SE2->( RecNO() )
	cNum      := SE2->E2_NUM
	cPrefixo  := SE2->E2_PREFIXO
	cParcela  := SE2->E2_PARCELA
	cFornece  := SE2->E2_FORNECE
	cTipo     := SE2->E2_TIPO
	cLoja     := SE2->E2_LOJA
	nTotAbat  := 0
	nValPgto  := SE2->E2_VALLIQ
	nTotal    := 0
	VALOR     := 0
	cChaveSE2 := SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)

	If !(lInsPub .And. SE2->E2_TIPO $ MVPAGANT+"/INA") //Inss Baixa Empresa Publica
		If lInssBx .And. !Empty(SE2->E2_NUMBOR) .And. !lPccBaixa .And. SE2->E2_PRETINS == '4' //Titulo com bordero e pcc na emissao devo descontar o valor do inss gerado.
			nValPgto := nValPgto + SE2->E2_VRETINS
		Endif
	Endif

	dBaixa	:= SE2->E2_BAIXA
	nTotAbat := SumAbatPag( cPrefixo, cNum, cParcela, cFornece, SE2->E2_MOEDA,"V",dBaixa,cLoja )
	If cPaisLoc == "CHI"
		nOtrga     := SE2->E2_OTRGA
		nDifCambio := SE2->E2_CAMBIO
		nImpSubst  := SE2->E2_IMPSUBS
	EndIf

	nAcresc  := SE2->E2_ACRESC
	nDecresc := SE2->E2_DECRESC
	SE2->( dbGoTo( nSalvRec ) )
	SA2->(dbSetOrder(1))
	SA2->(MSSEEK(xFilial("SA2",SE2->E2_FILORIG)+SE2->(E2_FORNECE+SE2->E2_LOJA)))

	//se estiver sendo chamado via rotina automática a partir da compensação entre carteiras,
	//nao deve processar ISS E IR
	lIRPFBaixa := If(cPaisLoc = "BRA" , SA2->A2_CALCIRF == "2", .F.) .And. ;
	Posicione("SED",1,xfilial("SED",SE2->E2_FILORIG) + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S" .And. ;
	!SE2->E2_TIPO $ MVPAGANT

	//se estiver sendo chamado via rotina automática a partir da compensação entre carteiras,
	//nao deve processar INSS
	If (lFina450 .and. (Type("lF080Auto")<>"U" .and. lF080Auto))
		lInssBx	:=	.F.
	Endif

	lIRProg := IIf( cPaisLoc == "BRA", IIf(!Empty(SA2->A2_IRPROG), SA2->A2_IRPROG, "2"), "2")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Escolhe Baixa a ser cancelada									 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lF080Auto
		If Len(aBaixa) > 1
			cListBox := aBaixa[1]
			nOpbaixa := 1
			DEFINE MSDIALOG oDlg FROM 5, 5 TO 14, 53 TITLE OemToAnsi(STR0080) //"Escolha A Baixa"

			@	.5, 2 LISTBOX nOpBaixa ITEMS aBaixa SIZE 160 , 40 Font oDlg:oFont
			DEFINE SBUTTON FROM 055,112	TYPE 1 ACTION (lOk := .T.,oDlg:End()) ENABLE OF oDlg
			DEFINE SBUTTON FROM 055,139.1 TYPE 2 ACTION (lOk := .F.,oDlg:End()) ENABLE OF oDlg

			ACTIVATE MSDIALOG oDlg CENTERED
			If !lOk .Or. !F080CanBx(aBaixa,nOpBaixa,lPccBaixa)
				Return Nil /*Function fa080Can*/
			Endif
		Else
			nOpbaixa := 1
		EndIF
	Else
		If nOpBaixa > Len(aBaixa)
			nOpBaixa := 1
		Endif
	Endif
	If Len(aBaixa) == 0 .And.(!Empty( SE2->E2_FATURA ) .AND. SE2->E2_FATURA <> "NOTFAT")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Procura pelas compensa‡”es										    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lBxCEC  //Compensacao entre carteiras
			Help(" ",1,"BX_CEC")
		ElseIf  SE5->(dbSeek(xFilial("SE5")+"CP"+cPrefixo+cNum+cParcela+cTipo)) .And. !SE5->(dbSeek(xFilial("SE5")+"ES"+cPrefixo+cNum+cParcela+cTipo))
			Help(" ",1,"TITULOADT")
		ElseIf  SE2->E2_TIPO $ MVPAGANT .and. SE5->(dbSeek(xFilial("SE5")+"BA"+cPrefixo+cNum+cParcela+cTipo))
			Help(" ",1,"TITULOADT")
		ElseIf SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG .and. !lBaixaAbat
			Help(" ",1,"TITULOADT")
		Elseif (SE2->E2_TIPO $ MVPROVIS .and. FunName() <> "FINA040" .and. !lF080Auto)
			Help(" ",1,"TITULOPRV",,STR0178,1) //"Titulo Provisorio não pode ser estornado diretamente, exclua o título efetivo gerado na substituiçao!"
		ElseIf lBxLiq .and. Len(aBaixa) == 0   // Se houver baixa por Liquidacao
			Help(" ",1,"BXLIQUIDAC")
		ElseIf lNotBax
			Help(" ",1,"A080ORDREC")
		ElseIf (nTotImpost > 0 .or. nTotaIRPF > 0) .and. !Empty(SE2->E2_NUMBOR)
			Help(" ",1,"BXBORD",,STR0151 +CHR(13)+CHR(10)+CHR(13)+CHR(10)+ STR0152,1,1) // "Baixa realizada por geração de impostos via borderô. Para o cancelamento desta, utilize a rotina de Cancelamento do borderô."
		ElseIf lAglImp
			Help(" ",1,"BXAGLUT",,STR0154+CHR(13)+CHR(10)+CHR(13)+CHR(10)+STR0155,1,1) //"O titulo de imposto selecionado sofreu aglutinação. Para o cancelamento" ## "desta baixa, utilize a rotina de Aglutinação de Impostos (FINA378)."
		Elseif Empty( SE2 -> E2_FATURA ) .and. SuperGetMv("MV_NRASDSD",.F.,.F.) == .F.
			Help(" ",1,"MVNRASDSD")
		Elseif Empty( SE2 -> E2_FATURA )
			Help(" ",1,"BAIXTITINC")
		Else
			Help(" ",1,"TITFATURAD")
		EndIF
		Return /*Function fa080Can*/
	EndIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³PARA OS QUE NÃO SE APLICA EM NENHUMA DAS VALIDAÇÕES ANTERIORES,
	//VERIFICAR SE OCORREU BAIXA ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF Len(aBaixa)<=0
		If lIsRussia
			Help(NIL,NIL,"TITNAOXADO", NIL, "", 1, 0, NIL, NIL, NIL, NIL, NIL, {""}) // show only problem description, not solution
		Else
			Help(" ",1,"TITNAOXADO")
		EndIf
		Return /*Function fa080Can*/
	EndIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pega os Valores da Baixa Escolhida 									 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dBaixa		:= aBaixaSE5[nOpBaixa,07]
	dDebito     := aBaixaSE5[nOpBaixa,14]
	cSequencia 	:= aBaixaSE5[nOpBaixa,09]
	cChave      := SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+Dtos(dBaixa)+cFornece+cLoja+cSequencia
	cParcCanc 	:= aBaixaSE5[nOpBaixa,03]
	nBaixa		:= Len(aBaixa)

	If lInssBx .And. cPaisLoc == "BRA" .And. !(lInsPub .And. SE2->E2_TIPO $ MVPAGANT+"/INA") //Inss Baixa
		nInssParc		:=	aBaixaSE5[nOpBaixa,27]
	Endif

	aAreaE5	:= SE5->(GETAREA())
	If SE5->(dbSeek(xFilial("SE5")+"BA"+cPrefixo+cNum+cParcela+cTipo))
		While SE5->(!Eof()) .and. SE5->E5_FILIAL == xFilial("SE5") .and. SE5->E5_TIPODOC == "BA" .and. SE5->E5_PREFIXO == cPrefixo ;
		.and. SE5->E5_NUMERO == cNum .and. SE5->E5_PARCELA == cParcela .and. SE5->E5_TIPO == cTipo  .And. SE5->E5_CLIFOR == cFornece .And. SE5->E5_LOJA ==cLoja
			If SE5->E5_TIPODOC == "BA" .AND. !Empty(SE5->E5_DOCUMEN) .AND. SE5->E5_MOTBX $ "PCC#IRF" .and. SE5->E5_SITUACA <> "C"
				If SE5->E5_SEQ > cSequencia
					Help(" ",1,"H080BORBX",,STR0221,1,0,,,,,,{STR0222}) //"A baixa não pode ser cancelada devido existirem impostos retidos através de borderô." # "Retire o título através da manutenção de borderô ou efetue o cancelamento do mesmo."
					Return /*Function fa080Can*/
				EndIf
			EndIf
			Se5->(Dbskip())
		EndDo
	EndIf
	RestArea(aAreaE5)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se utilizar PCC na CEC (Compens. entre Carteiras) e PCC na Baixa. 	 ³
	//³ Nao pode canelar	as baixas fora de ordem. Necessário cancelar a(s)   ³
	//³ compensação(ões) primeiro															 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(lFina450.and. lF080Auto)
		If SuperGetMV( "MV_CC10925" , , 1) == 2
			//chamada para alimentar o array a450ListBx
			Sel450Baixa("VL /BA /CP /CEC",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,,@a450ListBx)
			IF cPaisLoc == "BRA" .AND. lPCCBaixa .and.; // usa PCC na Comp.Carteiras e PCC na Baixa
			(aBaixaSE5[nOpBaixa][15] <> 0 .or. aBaixaSE5[nOpBaixa][16] <> 0 .and. aBaixaSE5[nOpBaixa][17] <> 0)	// essa baixa reteve impostos
				For nX := 1 to Len(a450ListBx)
					If a450ListBx[nX][09] > cSequencia .and. a450ListBx[nX][18] == "CEC" .and.;
					(a450ListBx[nX][11] <> 0 .or. aBaixaSE5[nX][12] <> 0 .and. aBaixaSE5[nX][13] <> 0)

						nX := Len(a450ListBx)+1
						//"Para títulos com impostos na Compensação entre Carteiras não é permitido cancelar
						// uma baixa intermediária. É necessário que cancele a partir da ultima baixa."

						Help(" ",1,"FIN80ICEC") //nao pode cancelar fora de ordem
						Return /*Function fa080Can*/

					EndIf
				Next nX
			EndIF
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se data do cancelamento ‚ menor que a data da baixa ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If dBaixa > dDataBase
		Help(" ",1,"DTBAIXA")
		Return /*Function fa080Can*/
	Endif

	dbSelectArea("SE5")
	SE5->(dbSetOrder(2)) // E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ
	cTipoDoc := "CM/CX/DC/MT/JR/BA/VL/VA/"
	IIf(cPaisloc == "CHI",cTipoDoc += "IS/",.T.)
	
	For nI := 1 to len( cTipoDoc) Step 3
		IF SE5->( dbSeek(xFilial("SE5")+substr(cTipoDoc,nI,2)+cChave) )

			//-- Garante o posicionamento correto no SE5, caso haja algum compartilhamento na tabela
			While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .and. ;
				SE5->(E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)+DtoS(SE5->E5_DATA)+SE5->(E5_CLIFOR+E5_LOJA+E5_SEQ)==Substr(cTipoDoc,nI,2)+cChave				
				If SE5->E5_FILORIG == SE2->E2_FILORIG
					Exit
				EndIf
				SE5->(dbSkip())
			EndDo

			If SE5->E5_RECPAG <> "P" .And. !SE2->E2_TIPO $ MVPAGANT+"/INA/"+MV_CPNEG
				PosicMov(xFilial("SE5")+substr(cTipoDoc,nI,2)+cChave, "P")
				IF Alltrim(SE5->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)) != ;
						AllTrim(SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) .OR.  SE5->E5_RECPAG <> "P"
					Loop
				EndIf	
			EndIf

			nMoedaBco  := Max(Val(SE5->E5_MOEDA), 1)

			If ( cPaisloc <> "BRA" )
				nMoedaTit  := SE2->E2_MOEDA
				nTxModBco  := SE5->E5_TXMOEDA
				nTxModTit  := RecMoeda(SE5->E5_DATA,nMoedaTit)
			Endif

			If substr(cTipoDoc,nI,2) $ "CM/CX"
				If ( cPaisLoc <> "BRA" )
					If ( cPaisloc <> "CHI" )
						nCorrec		:= xMoeda( SE5->E5_VALOR, nMoedaBco, 1, SE5->E5_DATA,, nTxModBco )
					Else
						nDifcambio	:= xMoeda( SE5->E5_VALOR, nMoedaBco, 1, SE5->E5_DATA,, nTxModBco )
					Endif
				Else
					nCorrec := SE5->E5_VALOR
				Endif
			ElseIf substr(cTipoDoc,nI,2) $ "DC"
				If ( cPaisLoc <> "BRA" )
					nDescont:= xMoeda( SE5->E5_VALOR, nMoedaBco, 1, SE5->E5_DATA,, nTxModBco )
				Else
					nDescont:= SE5->E5_VALOR
				Endif
			ElseIf substr(cTipoDoc,nI,2) $ "MT"
				If ( cPaisLoc <> "BRA" )
					nMulta	:= xMoeda( SE5->E5_VALOR, nMoedaBco, 1, SE5->E5_DATA,, nTxModBco )
				Else
					nMulta	:= SE5->E5_VALOR
				Endif
			ElseIf substr(cTipoDoc,nI,2) $ "JR"
				If ( cPaisLoc <> "BRA" )
					If ( cPaisloc <> "CHI" )
						nJuros := xMoeda( SE5->E5_VALOR, nMoedaBco, 1, SE5->E5_DATA,, nTxModBco )
					Else
						nOtrga := xMoeda( SE5->E5_VALOR, nMoedaBco, 1, SE5->E5_DATA,, nTxModBco )
					Endif
				Else
					nJuros := SE5->E5_VALOR
				Endif
			ElseIf substr(cTipoDoc,nI,2 ) $ "BA/VL"
				If cPaisLoc <> "BRA" .And. !Empty(SE5->E5_BANCO)
					SA6->(DbSetOrder(1))
					SA6->(MsSeek(xFilial()+SE5->E5_BANCO+SE5->E5_AGENCIA+SE5->E5_CONTA))
					If( Max(IIf(Type("SA6->A6_MOEDAP")=="U" .Or. SA6->A6_MOEDAP == 0,SA6->A6_MOEDA,SA6->A6_MOEDAP),1) )== 1
						nValPgto := SE5->E5_VALOR
						nValestrang := SE5->E5_VLMOED2
					Else
						nValestrang := SE5->E5_VALOR
						nValPgto := SE5->E5_VLMOED2
					Endif
				Else
					nValPgto := SE5->E5_VALOR
					If !(lInsPub .And. SE2->E2_TIPO $ MVPAGANT+"/INA") //Inss Baixa Empresa Publica
						If lInssBx .And. !Empty(SE2->E2_NUMBOR) .And. !lPccBaixa .And. SE2->E2_PRETINS == '4' //Titulo com bordero e pcc na emissao devo descontar o valor do inss gerado.
							nValPgto := nValPgto + SE2->E2_VRETINS
						Endif
					Endif
					nValestrang := SE5->E5_VLMOED2
				Endif
				cHist070 := SE5->E5_HISTOR
				cMotBx   := SE5->E5_MOTBX
				cNumBor  := SubStr(SE5->E5_DOCUMEN,1,6)
				cLoteFin := SE5->E5_LOTE
				nRecSe5  := SE5->(RecNo())

				If lIsRussia
					cHistCan070 := STR0238 
					If aScan(aAutoCab,{|x| x[1] == 'AUTPAYORD'}) > 0 // Is Bank  statement process 
						cHistCan070 +=  " " + F4C->F4C_BNKORD + STR0239 + dtoc(F4C->F4C_DTPAYM)
					Endif 
				Else
					cHistCan070 := PADR(IIF(Empty(SE5->E5_LOTE),STR0114,STR0113+SE5->E5_LOTE),nTamHist) // Cancelamento de baixa###"Canc Baixa Lote "
				EndIf
				cMultNat	:= SE5->E5_MULTNAT
				cSeqSE5	:= SE5->E5_SEQ
				nPis := nCofins := nCsll := nIrrf := nIss := 0

				If _lTemMR
					_nTotImp := FinRetBxMR("P", SE5->E5_IDORIG, .T.)
				EndIf

				If cPaisLoc == "BRA"
					If (lIRPFBaixa .Or. _lIrfMR) .And. Empty(SE5->E5_PRETIRF)
						nIrrf := SE5->E5_VRETIRF
						f080CRatIR()
					Endif
					
					If (lPccBaixa .Or. _lPccMR)
						If Empty(SE5->E5_PRETPIS)
							nPis := SE5->E5_VRETPIS
						Endif
						If Empty(SE5->E5_PRETCOF)
							nCofins := SE5->E5_VRETCOF
						Endif
						If Empty(SE5->E5_PRETCSL)
							nCsll := SE5->E5_VRETCSL
						Endif
					Endif
				EndIf

				If (lCalcIssBx .Or. _lIssMR) .AND. EMPTY(SE2->E2_NUMBOR)
					nIss := SE5->E5_VRETISS
				ElseIf lRetBor .And. lCalcIssBx .and. !EMPTY(SE2->E2_NUMBOR)
					nIss := SE5->E5_VRETISS
				Endif

				If !_lCidMR .And. lCideBX
					nCide := FinRetBxMR("P", SE5->E5_IDORIG, .F., "CID")
				EndIf
			ElseIf substr(cTipoDoc,nI,2) $ "IS" 	//Localizacao Chile
				If ( cPaisLoc <> "BRA" )
					nImpsubst := xMoeda( SE5->E5_VALOR, nMoedaBco, 1, SE5->E5_DATA,, nTxModBco )
				Else
					nImpsubst := SE5->E5_VALOR
				Endif

			ElseIf __lPodeTVA .and. __lExistVA .and. substr(cTipoDoc,nI,2) == "VA"  // Valores acessórios.
				While SE5->(!EOF() .AND. xFilial("SE5")+substr(cTipoDoc,nI,2)+cChave == E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ)
					If ( cPaisLoc == "BRA" )
						nVA += SE5->E5_VALOR
					Else
						nVA += xMoeda( SE5->E5_VALOR, nMoedaBco, 1, SE5->E5_DATA,, nTxModBco )
					Endif
					SE5->(dbSkip())
				EndDo
			EndIF
		EndIF
	Next

	lEstorna 	 := Iif(Empty(cNumBor),.F.,.T.)

	// Verifica se foi utilizada taxa contratada para moeda > 1
	SE5->(dbGoTo(nRecSe5))		//volta para o registro principal

	//Nao permito cancelamento de baixa se a mesma foi conciliada e se
	//o parametro MV_BXCONC estiver como 2(Padrao) - Nao permite
	If !lBxConc
		If !Empty(SE5->E5_RECONC)
			Help(" ",1,"BXCONCIL")
			dbSelectArea("SE2")
			Return /*Function fa080Can*/
		ElseIf !Empty(SE5->E5_LOTE) .And. !Empty(SE5->E5_DOCUMEN) //Titulos em bordero
			nSaveRec := SE5->(Recno())
			nSaveIdx := SE5->(IndexOrd())
			nLote    := SE5->E5_LOTE
			SE5->(DbSetOrder(5))
			If SE5->(DbSeek(xFilial("SE5")+nLote))
				While SE5->( ! Eof() .And. E5_FILIAL == xFilial("SE5") .And. E5_LOTE == nLote )
					If !Empty(SE5->E5_RECONC) .AND. SE5->E5_RECPAG == 'P'
						Help(" ",1,"F080BORD",,STR0167+CHR(13)+STR0168+CHR(13)+STR0169,1,0)  //"Esta baixa nao pode ser cancelada, pois "###"o titulo esta em bordero e um ou mais"###"titulos ja foram conciliados. "
						SE5->(DbSetOrder(nSaveIdx))
						SE5->(DbGoTo(nSaveRec))
						dbSelectArea("SE2")
						Return /*Function fa080Can*/
					EndIf
					SE5->(DbSkip())
				EndDo
			EndIf
			SE5->(DbSetOrder(nSaveIdx))
			SE5->(DbGoTo(nSaveRec))
		Endif
	EndIf

	If cPaisLoc <>"BRA"
		SA6->( DbSetOrder(1) )
		SA6->( MsSeek(xFilial("SA6")+SE5->(E5_BANCO+E5_AGENCIA+E5_CONTA) ) )
		If Max(IIf(Type("SA6->A6_MOEDAP")=="U",SA6->A6_MOEDA,SA6->A6_MOEDAP),1) == 1

			If SE2->E2_MOEDA > 1 .AND. Round(NoRound(xMoeda(nValpgto,1,SE2->E2_MOEDA,dBaixa,3),3),2) != SE5->E5_VLMOED2
				nTxMoeda := Noround((SE5->E5_VALOR / SE5->E5_VLMOED2),5)
			Else
				nTxMoeda := RecMoeda(dBaixa,SE2->E2_MOEDA)
			Endif
		Else
			If SE2->E2_MOEDA > 1 .and. Round(NoRound(xMoeda(nValpgto,1,SE2->E2_MOEDA,dBaixa,3),3),2) != SE5->E5_VALOR
				nTxMoeda := Noround((SE5->E5_VLMOED2/SE5->E5_VALOR),5)
			Else
				nTxMoeda := RecMoeda(dBaixa,SE2->E2_MOEDA)
			Endif
		EndIf
	Else
		If SE5->E5_TXMOEDA == 0
			If SE2->E2_MOEDA > 1 .and. Round(NoRound(xMoeda(nValpgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,3),3),2) != SE5->E5_VLMOED2
				nTxMoeda := Noround((SE5->E5_VALOR / SE5->E5_VLMOED2),5)
			Else
				nTxMoeda := RecMoeda(dBaixa,SE2->E2_MOEDA) 
			Endif
		Else
			nTxMoeda := SE5->E5_TXMOEDA
		EndIf
	EndIf

	// Caso moeda ==1 a funcao RecMoeda iguala nTxMoeda = 0. Iguala-se
	// nTxMoeda = 1 p/ evitar problema c/ calculos de abatimento e outros.
	nTxMoeda := IIF(nTxMoeda == 0 , 1 , nTxMoeda)

	// Se nao for titulo de imposto, verifica se um dos titulos de impostos já foi baixado e nao permite a exclusao
	If !SE2->E2_TIPO $ MVISS+"/"+MVTAXA+"/"+MVTXA+"/"+MVINSS+"/"+"SES"+"/"+"INA"

		If !Fa050Filho(.T.)
			lIsIrBx := Fa080IrBx()
			lTemPCCBX := Fa080PCCBx()
			lTemISSBX := Fa080ISSBx() 	
			If !lCb10925 .and. (lIsIrBx .or. lTemPCCBX .or. lTemISSBX)//se o imposto baixado for Imposto de Renda gerado na baixa -> nao deixa cancelar baixa do principal.
				Help(" ",1,"NODELETA",,STR0153 + CRLF + STR0201, 4, 0) // "Este titulo possui impostos e"+chr(13)+"um desses impostos sofreu baixa."
				Return .F.  /*Function fa080Can*/
			Else
				If SE5->E5_PRETPIS=='2' .or. SE5->E5_PRETCOF=='2' .or. SE5->E5_PRETCSL=='2'
					If (ExistBlock("F080PCBX") .and. ExecBlock("F080PCBX",.F.,.F.)==.F.)
						//"Essa baixa possui impostos retidos em outra baixa. E necessario cancelar primeiro a baixa responsavel pela retenção dos impostos"
						MsgStop(STR0163 +chr(13)+STR0164,STR0143)
						Return .F. /*Function fa080Can*/
					EndIf
				EndIf
				//Mesmo permitindo o cancelamento MV_CB10925 = 1, será feita uma pergunta de confirmação
				//caso exista algum título filho que já tenha sido baixado.
				If !lF080Auto .and. lCb10925 .and. (lIsIrBx .or. lTemPCCBX .or. lTemISSBX) .and. !MsgYesNo(STR0153 + CRLF + STR0201 + STR0159,STR0143)	//"Este titulo possui impostos e"+chr(13)+"um desses impostos sofreu baixa."
					//"Deseja mesmo cancelar ?"
					Return .F. /*Function fa080Can*/
				EndIf
			EndIf
		ElseIf !Fa050Filho(.F.)   //verifica se esse título tem TX filhos, sem verificar se esses TXs foram baixados
			If SE5->E5_PRETPIS=='2' .or. SE5->E5_PRETCOF=='2' .or. SE5->E5_PRETCSL=='2'
				If (ExistBlock("F080PCBX") .and. ExecBlock("F080PCBX",.F.,.F.)==.F.)
					//"Essa baixa possui impostos retidos em outra baixa. E necessario cancelar primeiro a baixa responsavel pela retenção dos impostos"
					MsgStop(STR0163 +chr(13)+STR0164,STR0143)
					Return .F. /*Function fa080Can*/
				ElseIf cPaisLoc == "BRA" .AND. (lPccBaixa .Or. _lPccMR)
					If !MsgYesNo(STR0192)//Essa baixa possui impostos retidos em outra baixa, deseja continuar ?
						Return .F.
					Endif
				EndIf
			EndIf
		ElseIf (lPccBaixa .Or. _lPccMR)
			If SE5->E5_PRETPIS=='2' .or. SE5->E5_PRETCOF=='2' .or. SE5->E5_PRETCSL=='2'
				If !MsgYesNo(STR0192)//Essa baixa possui impostos retidos em outra baixa, deseja continuar ?
					Return .F.
				Endif
			EndIf
		Endif
	Endif

	//Se vier da integração Protheus X Tin e tiver sido baixado pro Distrato ou Aditivo, não pode excluir
	If Upper(AllTrim(SE5->E5_MOTBX))== "TIN"  .And. Alltrim(SE2->E2_ORIGEM)=="FINI055"
		HELP(" ",1,"ProtheusXTIN" ,,STR0179,2,0)//"Títulos baixados por DISTRATO ou ADITIVO na Integração Protheus X TIN não podem ter a baixa cancelada!"
		Return
	Endif

	//³Verifica se foi ja foi gerado cheque para esta baixa; se o cheque ³
	//³ ja foi gerado nao permite o cancelamento						    ³
	dbSelectArea("SEF")
	dbSetOrder(3)
	If !(SE5->E5_TIPO $ MVPAGANT)
		// Devido a verificacao do "MV_CTBAIXA" $ "BA"
		// nao conseguiamos contabilizar o LP 531 quando o cheque era gerado
		// no momento da baixa do titulo, a contabilizacao efetuada pelo LP 530 e o
		// MV_CTBAIXA fosse igual a C. Para cancelar a baixa, o usuario precisa cancelar o
		// cheque primeiro. Entao pesquisamos com Set Deleted Off para verificar
		// se o cheque gerado para a baixa e permitir a contabilizacao do LP 531.
		SET(_SET_DELETED, .F.)	// Habilita pesquisa nos cheques deletados, para verificar
		// se a contabilizacao deva ocorrer pelo 531
		If SEF->(dbSeek(FWxFilial("SEF",SE5->E5_FILIAL)+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO))
			cSeqSe5 := SE5->E5_SEQ

			While SEF->( !Eof()) .and. EF_FILIAL == xFilial() 		.and. ;
					EF_TITULO == SE5->E5_NUMERO	.and. ;
					EF_PARCELA== SE5->E5_PARCELA .and. ;
					EF_PREFIXO== SE5->E5_PREFIXO .and. ;
					EF_TIPO   == SE5->E5_TIPO

				If Str(SE5->E5_VALOR,17,2)	 == Str(SEF->EF_VALOR,17,2)	.And.;
					SEF->EF_SEQUENC == cSeqSe5			.And.;
					SE5->E5_CLIFOR  == SEF->EF_FORNECE

					nRecDelSef	:= SEF->( RecNo() )
					lEstorna 	:= .F.  //achou cheque para esta baixa
					cEfImpress	:= SEF->EF_IMPRESS
					cSefOrigem	:= SEF->EF_ORIGEM
					lDeleted		:= SEF->(Deleted())
					lCheque		:= .F.

					// Permite a baixa se houver cheque cancelado.
					IF SEF->EF_IMPRESS # "C"
						lCheque		:= .T.
						cNumCheq		:= SEF->EF_NUM
						cBenef		:= SEF->EF_BENEF
					Endif
					// Como o SET DELETED esta desligado, verifica se o registro eh valido
					// para sair do LOOP, pois o que vale sao os dados do utlimo cheque
					// gravado no SEF, quando existirem registros identicos mas, um ou mais
					// registros estiverem deletados.
					If SEF->(!Deleted())
						Exit
					Endif
				Endif
				SEF->( dbSkip() )
			Enddo
		ElseIf !lEstorna .AND. Empty(cNumBor)
			lEstorna := .T.
		Endif
	EndIf
	dbSelectArea("SEF")
	dbSetOrder(1)

	lBkpContab := lContabilizou := SE5->E5_LA = "S" .and. !lFina450 

	nValPadrao	:= nValPgto-(nJuros+nVA+nMulta-nDescont-nPis-nCoFins-nCsll-nIrrf-nIss-nInss)
	nSalDup		:= SE2->E2_SALDO-nValPadrao

	cBanco := aBaixaSE5[nOpbaixa,11]
	cAgencia := aBaixaSE5[nOpBaixa,12]
	cConta := aBaixaSE5[nOpBaixa,13]

	dbSelectArea("SEF")
	dbSetOrder(1)
	If (lCheque .and. !Empty(cNumCheq)) .Or. (!Empty(SE2->E2_NUMBCO) .and. !Empty(cEfImpress) .and. !SE2->E2_TIPO $ MVPAGANT )
		If !lDeleted // Achou um cheque e este nao esta deletado, avisa e nao permite o
			// cancelamento da baixa
			SET(_SET_DELETED,lSetDeleted) // Restaura ambiente
			Help(" " , 1 , "FA080TEMCH")
			dbSelectArea("SE2")
			Return /*Function fa080Can*/
		Endif
	Endif

	nPosMotBx := Ascan(aMotBx,{|e| AllTrim(Upper(cMotBx))==AllTrim(Upper(Substr(e,1,3)))})

	//Se nao contabiliza por Cheque
	//Motivo de baixa nao e Vendor
	//E o banco nao eh caixa (neste caso contabiliza sem emissao de cheque)
	If lCTBaixa .And. !TrazCodMot(cMotBx) $ "VEN/DEB/PCC/DAC" .and. ;
		!(cBanco $ Left(GetMv("MV_CXFIN"),nTamCodA6) .or. cBanco$GetMV("MV_CARTEIR")) .and. ;
		(Iif( nPosMotBx>0, substr(aMotBx[ nPosMotBx ],41,01)=="S", .T.))
		lContabilizou := .F.
	EndIf

	If !lContabilizou .And. lBkpContab .And. lCTBaixa
		lContabilizou := .T.
	EndIf

	If (SE2->E2_TIPO $ MVPAGANT)
		If SE2->(E2_PIS + E2_COFINS + E2_CSLL) > 0
			If !lF080Auto
				MsgStop(STR0199,STR0143) //"Cancelamento da baixa de pagamento adiantado com cálculo de impostos não permitida."
			Else
				Help(" ",1, STR0143,,STR0199,4,0)	//"Atenção"###"Cancelamento da baixa de pagamento adiantado com cálculo de impostos não permitida."
			EndIf

			Return
		EndIf
	EndIf

	SET(_SET_DELETED,lSetDeleted) // Restaura ambiente
	dbSelectArea("SE5")
	dbGoTo(nRecSe5)		//volta para o registro principal

	nI :=  Ascan(aMotBx, {|x| Substr(x,1,3) == Upper(cMotBx) })
	cDescrMo := if( nI > 0,Substr(aMotBx[nI],07,10),"" )

	SA2->(dbseek(xFilial("SA2",SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA))
	dbSelectArea("SE2")

	If RecLock("SE2",.F.,,.T.)
		cNomeFor      := SE2->E2_FORNECE + " " + SA2->A2_NOME
		cTitulo := SE2->E2_PREFIXO + " " + SE2->E2_NUM+ " " + SE2->E2_PARCELA
		nPagtoParcial := SE2->E2_VALOR-SE2->E2_SALDO
		cTexto	     := OemToAnsi(STR0084) + SubStr(GetMV("MV_SIMB"+cMoeda),1,3)  //"Valor Original "
		cBenef := IIF(Empty(cBenef),SE2->E2_NOMFOR,cBenef)

		If lSpbInUse
			cModSpb	:= IIF(!Empty(SE5->E5_MODSPB),SE5->E5_MODSPB,"1")
			cDescSpb := aModalSpb[Val(cModSpb)]
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada antes das baixas a serem Canceladas.          		  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lFa080Est
			ExecBlock('FA080EST',.F.,.F.)
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Recebe os dados do t¡tulo a ser baixado 								 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nOpc1 := 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada para validar dados antes das baixas a serem Canceladas.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lFa080VEst
			lEst:= ExecBlock('FA080VEST',.F.,.F.,nOpcx)
		Endif
		If lEst
			If !lF080Auto
				If lPaisMI
					cCadastro := IIF(nOpcx==5, OemToAnsi(STR0005), OemToAnsi(STR0115))	// "Anula Baja"##"Borrar"
				EndIf

				DEFINE MSDIALOG oDlg FROM	31,15 TO 590,574 TITLE IIf(!lPaisMI,OemToAnsi(STR0085),OemToAnsi(STR0007))  PIXEL OF oMainWnd //  "Cancelamento de Baixas a Pagar"

				//Faz o calculo automatico de dimensoes de objetos
				oSize := FwDefSize():New(.T.,,,oDlg)
				oSize:lLateral := .F.
				oSize:lProp	:= .T. // Proporcional
				oSize:AddObject( "1STROW" ,  100, 19, .T., .T. ) // Totalmente dimensionavel
				oSize:AddObject( "2NDROW" ,  100, 81, .T., .T. ) // Totalmente dimensionavel
				oSize:Process() // Dispara os calculos

				a1stRow := {oSize:GetDimension("1STROW","LININI"),;
							oSize:GetDimension("1STROW","COLINI"),;
							oSize:GetDimension("1STROW","LINEND"),;
							oSize:GetDimension("1STROW","XSIZE")}

				a2ndRow := {oSize:GetDimension("2NDROW","LININI"),;
							oSize:GetDimension("2NDROW","COLINI"),;
							oSize:GetDimension("2NDROW","LINEND"),;
							oSize:GetDimension("2NDROW","XSIZE")}
				
				If nOpcx == 6
					cOpcao := Upper(STR0115)
				Endif

				If IsPanelFin()
					@ 000, a1stRow[2] + 000 GROUP oMyBar  TO a1stRow[1] - 1, (a1stRow[4]-7) OF oDlg PIXEL 
                	@ 010, a1stRow[2] + 008 SAY cCadastro+" - "+ Upper(cOpcao) FONT oFont24 COLOR CLR_HBLUE OF oDlg PIXEL //"CANCELAR/EXCLUIR"
				Endif

				@ a1stRow[1] + 000, a1stRow[2] + 000 GROUP oGrp1 TO a1stRow[3], (a1stRow[4]-7) LABEL STR0015 OF oDlg PIXEL //"Principal"
				@ a2ndRow[1] + 000, a2ndRow[2] + 000 GROUP oGrp2 TO a2ndRow[3], 135 LABEL STR0013 OF oDlg  PIXEL //"Dados Gerais"
				@ a2ndRow[1] + 000, a2ndRow[2] + 139 GROUP oGrp3 TO a2ndRow[3], (a2ndRow[4]-7) LABEL STR0014 OF oDlg  PIXEL //"Valores da Baixa"

				//////////////////
				//DADOS DO TITULO
				@ a1stRow[1] + 008, a1stRow[2] + 004 SAY STR0092			SIZE 31,07 OF oDlg PIXEL //Prefixo
				@ a1stRow[1] + 008, a1stRow[2] + 027 MSGET SE2->E2_PREFIXO	SIZE 25,08 OF oDlg PIXEL When .F.
				@ a1stRow[1] + 008, a1stRow[2] + 060 SAY STR0093 			SIZE 31,07 OF oDlg PIXEL //Numero
				@ a1stRow[1] + 008, a1stRow[2] + 085 MSGET SE2->E2_NUM		SIZE 70,08 OF oDlg PIXEL When .F.
				@ a1stRow[1] + 008, a1stRow[2] + 165 SAY STR0094 			SIZE 31,07 OF oDlg PIXEL //Parcela
				@ a1stRow[1] + 008, a1stRow[2] + 188 MSGET SE2->E2_PARCELA	SIZE 25,08 OF oDlg PIXEL When .F.
				@ a1stRow[1] + 008, a1stRow[2] + 220 SAY STR0095			SIZE 31,07 OF oDlg PIXEL //Tipo
				@ a1stRow[1] + 008, a1stRow[2] + 238 MSGET oTipo VAR cTipo	F3 "SE2RDO" SIZE 30,08 OF oDlg PIXEL HASBUTTON
				oTipo:lReadOnly := .T.

				@ a1stRow[1] + 020, a1stRow[2] + 004 SAY STR0019 SIZE 22,07 OF oDlg PIXEL //"Fornecedor"
				@ a1stRow[1] + 020, a1stRow[2] + 027 MSGET oCodFor VAR SE2->E2_FORNECE F3 "SA2" SIZE 70,08 OF oDlg PIXEL HASBUTTON
				oCodFor:lReadOnly := .T.
				If __lLGPD 
					@ a1stRow[1] + 020, a1stRow[2] + 105 MSGET oNomFor VAR SA2->A2_NOME SIZE 165,08 OF oDlg PIXEL When .F. OBFUSCATED RetGlbLGPD("A2_NOME")
				Else
					@ a1stRow[1] + 020, a1stRow[2] + 105 MSGET oNomFor VAR SA2->A2_NOME SIZE 165,08 OF oDlg PIXEL When .F.
				EndIf		

				@ a1stRow[1] + 032, a1stRow[2] + 004 SAY STR0098 			SIZE 31,07 OF oDlg PIXEL //"Natureza"
				@ a1stRow[1] + 032, a1stRow[2] + 027 MSGET oNaturez VAR SE2->E2_NATUREZ	F3 "SED" SIZE 70,08 OF oDlg PIXEL HASBUTTON
				oNaturez:lReadOnly := .T.
				@ a1stRow[1] + 032, a1stRow[2] + 105 SAY STR0017 			SIZE 31,07 OF oDlg PIXEL //"Emiss„o"
				@ a1stRow[1] + 032, a1stRow[2] + 133 MSGET SE2->E2_EMISSAO	SIZE 48,08 OF oDlg PIXEL When .F. HASBUTTON
				@ a1stRow[1] + 032, a1stRow[2] + 189 SAY STR0018 			SIZE 49,07 OF oDlg PIXEL //"Vencto.Atual"
				@ a1stRow[1] + 032, a1stRow[2] + 222 MSGET SE2->E2_VENCREA	SIZE 48,08 OF oDlg PIXEL When .F. HASBUTTON

				//DADOS GERAIS

				nUltLin := 10 + a2ndRow[1]

				@ nUltLin,005 SAY OemToAnsi(STR0020)	 		SIZE 38,07 OF oDlg PIXEL //"Hist.Emiss„o"
				@ nUltLin,065 MSGET SE2->E2_HIST 				SIZE 65, 08 OF oDlg PIXEL When .F.
				nUltLin +=12

				@ nUltLin,005 SAY OemToAnsi(STR0021)		  	SIZE 39,07 OF oDlg PIXEL //"Portador"
				@ nUltLin,065 MSGET SE2->E2_PORTADO				SIZE 65, 08 OF oDlg PIXEL When .F.
				nUltLin +=12

				@ nUltLin,005 SAY OemToAnsi(STR0022)			SIZE 40,07 OF oDlg PIXEL //"Banco"
				@ nUltLin,065 MSGET oBanco VAR aBaixaSE5[nOpBaixa,11]	F3 "SA6" SIZE 65, 08 OF oDlg PIXEL Hasbutton
				oBanco:lReadOnly := .T.
				nUltLin +=12

				@ nUltLin,005 SAY OemToAnsi(STR0023)		SIZE 39,07 OF oDlg PIXEL //"Agˆncia"
				@ nUltLin,065 MSGET aBaixaSE5[nOpBaixa,12]	SIZE 65, 08 OF oDlg PIXEL When .F.
				nUltLin +=12

				@ nUltLin,005 SAY OemToAnsi(STR0024)		SIZE 41,07 OF oDlg PIXEL //"Conta"
				@ nUltLin,065 MSGET aBaixaSE5[nOpBaixa,13]	SIZE 65, 08 OF oDlg PIXEL When .F.
				nUltLin +=12

				@ nUltLin,005 SAY OemToAnsi(STR0089) 		SIZE 38,07 OF oDlg PIXEL //"Data Receb."
				@ nUltLin,065 MSGET dBaixa 					SIZE 65, 08 OF oDlg PIXEL When .F.  HASBUTTON
				nUltLin +=12

				@ nUltLin,005 SAY OemToAnsi(STR0149) 		SIZE 39,07 OF oDlg PIXEL //"Data Debito"
				@ nUltLin,065 MSGET dDebito					SIZE 65, 08 OF oDlg PIXEL When .F.  HASBUTTON
				nUltLin +=12

				@ nUltLin,005 SAY OemToAnsi(STR0026)	  	SIZE 39,07 OF oDlg PIXEL //"Hist.Baixa"
				@ nUltLin,065 MSGET cHist070				SIZE 65, 08 OF oDlg PIXEL When .F.
				nUltLin +=12

				@ nUltLin,005 SAY OemToAnsi(STR0027)	  	SIZE 40,07 OF oDlg PIXEL //"Cheque No."
				@ nUltLin,065 MSGET cNumCheq		 		SIZE 65, 08 OF oDlg PIXEL When .F.
				nUltLin +=12

				@ nUltLin,005 SAY OemToAnsi(STR0028)		SIZE 36,07 OF oDlg PIXEL //"Beneficiário"
				If __lLGPD 
					@ nUltLin,065 MSGET oBenef VAR cBenef 		SIZE 65, 08 OF oDlg PIXEL When .F. OBFUSCATED RetGlbLGPD("E2_NOMFOR")
				Else
					@ nUltLin,065 MSGET oBenef VAR cBenef 		SIZE 65, 08 OF oDlg PIXEL When .F.
				EndIf	
				nUltLin +=12

				@ nUltLin,005 SAY OemToAnsi(STR0029)		SIZE 37,07 OF oDlg PIXEL //"Mot.Baixa"
				@ nUltLin,065 MSGET cDescrMo 				SIZE 65, 08 OF oDlg PIXEL When .F.
				nUltLin +=12

				@ nUltLin,005 SAY STR0131 					SIZE 32, 07 OF oDlg PIXEL // //"Hist.Cancel."
				@ nUltLin,065 MSGET cHistCan070				SIZE 65, 08 OF oDlg PIXEL
				nUltLin +=12

				If lSpbInUse
					@ nUltLin,005 SAY STR0128 SIZE 32, 07 OF oDlg PIXEL  //"Modalidade SPB"
					@ nUltLin,065 MSGET cDescSpb SIZE 56, 10 OF oDlg PIXEL When .F.
					nUltLin +=12
				Endif

				//////////////////
				//DADOS DA BAIXA
				nUltLin := 10 + a2ndRow[1]

				If cPaisLoc <> "CHI"
					@ nUltLin,144 SAY cTexto				  	SIZE 53,07 OF oDlg PIXEL //"Valor Original"
					@ nUltLin,210 MSGET SE2->E2_VALOR			SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_VALOR") HASBUTTON
					nUltLin +=12

					@ nUltLin,144 SAY OemToAnsi(STR0035)		SIZE 53,07 OF oDlg PIXEL //"- Abatimentos"
					@ nUltLin,210 MSGET nTotAbat				SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_VALOR") HASBUTTON
					nUltLin +=12
				Else
					@ nUltLin,144 SAY OemToAnsi(STR0034)		SIZE 53,07 OF oDlg PIXEL //"Valor Original"
					@ nUltLin,210 MSGET SE2->E2_VLCRUZ  		SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_VLCRUZ") HASBUTTON
					nUltLin +=12

					@ nUltLin,144 SAY OemToAnsi(STR0118)			SIZE 53,07 OF oDlg PIXEL //"+ Otros Gastos"
					@ nUltLin,210 MSGET nImpSubst				SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_IMPSUBS") HASBUTTON
					nUltLin +=12
				EndIf

				@ nUltLin,144 SAY OemToAnsi(STR0036)			SIZE 53,07 OF oDlg PIXEL //"- Pagtos.Parciais"
				@ nUltLin,210 MSGET nPagtoParcial				SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_VALOR") HASBUTTON
				nUltLin +=12

				@ nUltLin,144 SAY OemToAnsi(STR0037)	 		SIZE 53,07 OF oDlg PIXEL //"- Descontos"
				@ nUltLin,210 MSGET nDescont					SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_DESCONT") HASBUTTON
				nUltLin +=12

				@ nUltLin,144 SAY OemToAnsi(STR0038)		  	SIZE 53,07 OF oDlg PIXEL //"+ Multa"
				@ nUltLin,210 MSGET nMulta 						SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_MULTA") HASBUTTON
				nUltLin +=12

				If cPaisLoc <> "CHI"
					@ nUltLin,144 SAY OemToAnsi(STR0039) 		SIZE 53,07 OF oDlg PIXEL //"+ Tx.Permanenc."
					@ nUltLin,210 MSGET nJuros 					SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_JUROS") HASBUTTON
					nUltLin +=12
				Else
					@ nUltLin,144 SAY OemToAnsi(STR0117)			SIZE 53,7 OF oDlg PIXEL //"+ Impuesto Subst."
					@ nUltLin,210 MSGET nOtrga					SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_OTRGA") HASBUTTON
					nUltLin +=12
				EndIf

				// Valores acessórios.
				If __lPodeTVA .and. FAPodeTVA(SE2->E2_TIPO, SE2->E2_NATUREZ, .F., "P")
					@ nUltLin, 144 SAY STR0204 	SIZE 53,07 OF oDlg PIXEL		// "Valores Acessórios"
					@ nUltLin, 210 MSGET nVA 	SIZE 65,08 OF oDlg PIXEL HASBUTTON When  .F. Picture PesqPict("FKD","FKD_VALOR")
					nUltLin +=12
				EndIf

				nLinha := nUltLin

				//Get do ISS na baixa
				If (!_lTemMR .Or. !_lIssMR) .And. lCalcIssBx
					@ nLinha, 144 SAY "- Iss"	SIZE 53,07 OF oDlg PIXEL
					@ nLinha, 210 MSGET nIss	SIZE 65, 08 OF oDlg PIXEL  When .F. Picture PesqPict("SE2","E2_ISS") HASBUTTON
					nLinha +=12
				Endif

				If (!_lTemMR .Or. !_lIrfMR) .And. lIRPFBaixa .And. cPaisLoc == "BRA"

					@ nLinha, 144 SAY "- Irrf"	SIZE 53,07 OF oDlg PIXEL
					@ nLinha, 210 MSGET nIrrf	SIZE 65,08 OF oDlg PIXEL  When .F. Picture PesqPict("SE2","E2_IRRF") HASBUTTON  ;
						Valid ( Fa080Val(nIrrf))
					nLinha +=12
				Endif

				If (!_lTemMR .Or. !_lPccMR) .And. lPccBaixa .and. cPaisLoc == "BRA"

					@ nLinha, 144 SAY "- Pis"	SIZE 53,07 OF oDlg PIXEL
					@ nLinha, 210 MSGET nPis	SIZE 65, 08 OF oDlg PIXEL When .F.  Picture PesqPict("SE2","E2_PIS") HASBUTTON
					nLinha +=12
					@ nLinha, 144 SAY "- Cofins" 	SIZE 53,07 OF oDlg PIXEL
					@ nLinha, 210 MSGET nCofins		SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_COFINS") HASBUTTON
					nLinha +=12
					@ nLinha, 144 SAY "- Csll"	SIZE 53,07 OF oDlg PIXEL
					@ nLinha, 210 MSGET nCsll	SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_CSLL") HASBUTTON
					nLinha +=12
				Endif

				If (!_lTemMR .Or. !_lCidMR) .And. lCideBX
					@ nLinha, 144 SAY "- Cide"	SIZE 53,07 OF oDlg PIXEL
					@ nLinha, 210 MSGET nCide	SIZE 65, 08 OF oDlg PIXEL  When .F. Picture PesqPict("SE2","E2_CIDE") HASBUTTON
					nLinha +=12
				EndIf

				If _lTemMR .And. _nTotImp > 0
					@ nLinha, 144 SAY "  Retenções"	SIZE 53,07 OF oDlg PIXEL
					@ nLinha, 210 MSGET _nTotImp SIZE 65, 08 OF oDlg PIXEL  When .F. Picture PesqPict("SE2","E2_ISS") HASBUTTON
					nLinha +=12
				EndIf

				@ nLinha, 144 SAY OemToAnsi(STR0041)	SIZE 53,07 OF oDlg PIXEL //"= Valor Pago"
				@ nLinha, 210 MSGET nValPgto			SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_VALLIQ") HASBUTTON

				IF SE2->E2_MOEDA > 1
					nLinha+=12
					@ nLinha, 144 SAY OemToAnsi(STR0042)  + SubStr(GetMV("MV_SIMB"+cMoeda),1,3)    SIZE 53,07 OF oDlg PIXEL //"Valor "
					@ nLinha, 210 MSGET nValEstrang		SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_VALOR") HASBUTTON
					nLinha+=12
					If cPaisLoc <> "CHI"
						@ nLinha,144 SAY OemToAnsi(STR0040)	SIZE 53,07 OF oDlg PIXEL //"+ Corr.Monet ria"
						@ nLinha,210 MSGET nCorrec			SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_CORREC") HASBUTTON
					Else
						@ nLinha,144 SAY OemToAnsi(STR0119)	SIZE 53,07 OF oDlg PIXEL //"+/- Dif. Cambio"
						@ nLinha,210 MSGET nDifCambio		SIZE 65, 08 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_CAMBIO") HASBUTTON
					EndIf
				ENDIF

				If _lTemMR
					Aadd(aButtons, {"NOTE", {||FINCRET('SE2')}, ,STR0216, STR0216})  //"'Retencao de Impostos'
				EndIf

				If lPanelFin
					ACTIVATE MSDIALOG oDlg CENTERED ON INIT FaMyBar(oMyBar,{||nOpc1:=1,oDlg:End()},{||oDlg:End()},aButtons)
				Else
					ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpc1:=1,oDlg:End()},{||oDlg:End()},,aButtons) CENTERED
				Endif
			Else
				// rotina automatica
				nOpc1 := 1
			Endif
			SE2->(MSUnlock())
		EndIf
	Else
		nOpc1 := 0
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PONTO DE ENTRADA P/ PERMISSAO DE CANCELAMENTO DE BAIXA DE TITULO		  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lFa080Own
		lEst := ExecBlock('FA080OWN',.F.,.F.,{nOpcx})
	Endif

	If !lEst
		Return /*Function fa080Can*/
	Endif

	If Alltrim(Upper(cMotBx)) == "TRF" .and. Alltrim(Upper(FunName())) != "FINA631" .And. (!Empty(SE2->E2_NUMSOL))
		Help(" ",1,"A070NAOPOD",,STR0183, 4, 0 )
		Return
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Consiste MV_DATAFIN antes de cancelar baixa ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet .and. SuperGetMv("MV_BXDTFIN",,"1") == "2"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ A data da baixa deve ser passada como parametro, pois tanto ³
		//³ o cancelamento como a exclusao devem ser validados pela     ³
		//³ data de baixa e nao pela data base do sistema.              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		// Depois de conversar com a liderança da inovação, ficou claro que o parametro MV_DATAFIN
		// foi criado para definir uma data para impedir a ATUALIZAÇÃO DE SALDO de um banco
		// Logo, caso seja um cancelamento, a atualização de saldo é na data base e
		// caso uma exclusão, será exclusão do movimento na data da movimentação (tem que impedir baseando-se na data do movimento)
		If nOpcx == 5 // cancelamento
			lRet := DtMovFin(,,"1")
		Elseif nOpcx==6 //exclusao
			lRet := DtMovFin(dBaixa,,"1")
		Endif
	Endif
	
	//Verifica se o banco esta bloqueado
	IF CCBlocked(SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA,,.T.)
		lRet := .F. 
	EndIF

	If !lRet
		Return /*Function fa080Can*/
	EndIf

	IF nOpc1 == 1
		If cPaisLoc == "BRA" 
			If SE2->(E2_PIS+E2_COFINS+E2_CSLL) > 0  
				lCpRet:= SLDRMSG(If(lPCCBaixa,dDatabase,SE2->E2_EMISSAO), nValPgto,SE2->E2_NATUREZ,"P",SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_TIPO,nMoedaBco)
				If lCpRet
					If !IsBlind()
						If !MSGNoYes(STR0203)//"Esta baixa possui PIS/COFINS/CSLL retidos em outra baixa e os impostos não serão recalculados,deseja continuar?"
							Return
						Endif
					EndIf
				Endif
			Endif	
			If lSpbInUse
				If SE2->E2_OKSPB == "B" // Titulo Baixado via SPB com aceite de pagamento
					Help(" " , 1 , "NOCANCBX")
					dbSelectArea("SE2")
					Return /*Function fa080Can*/
				ElseIf SE2->E2_OKSPB == "A" //Titulo baixado via SPB com aceite de pagto em aberto
					If !ChkPsw(104)
						dbSelectArea("SE2")
						Return /*Function fa080Can*/
					Endif
				Endif
			Endif
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicia a gravacao dos lancamentos - SIGAPCO ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		PcoIniLan("000005")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicio da protecao via TTS										³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nOrdSa6 := SA6->(INDEXORD())
		nRecSa6 := SA6->(RECNO())
		lMovBcoBx := MovBcoBx(cMotBx, .T.) 

		Begin Transaction
			SED->( MSSeek(xFilial("SED",SE2->E2_FILORIG)+SE2->E2_NATUREZ) )
			SA6->( DbSetOrder(1) )
			SA6->( DbSeek(xFilial("SA6")+SE5->(E5_BANCO+E5_AGENCIA+E5_CONTA) ) )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Apaga Titulo de Vendor Gerado				  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lBaixaOk := .T.
			IF TrazCodMot(cMotBx) == "VEN"
				dbSelectArea("SE2")
				cTitOriV := Left(SE2->E2_TITORIG,nTamTitOri)
				IF SE2->( dbSeek(xFilial("SE2")+Left(SE2->E2_TITORIG,nTamTitOri)) )
					lVend := .T.
					nRegV := SE2->( Recno() )
				Endif

				If lBaixaOk
					dbGoto(nReg)
					RecLock("SE2",.F.)
					Replace SE2->E2_TITORIG With Space(TamSx3("E2_TITORIG")[1])
				Endif
			Endif
			If lBaixaOk
			
				// Integração SIGAPFS x SIGAFIN
				If lIntPFS .And. FindFunction("JSetImpLan")
					JSetImpLan(SE2->(RECNO()))
				EndIf
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Gravar valores no SE2												³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SE2->E2_OK <> 'TA'
					Reclock( "SE2" )
					SE2->E2_VALLIQ := nValPgto
					If cPaisloc <> "CHI"
						If SE2->E2_ORIGEM != 'FINA171'
							SE2->E2_JUROS	:= nJuros
						EndIf
						SE2->E2_CORREC  := nCorrec
					Else
						SE2->E2_JUROS	:= nOtrga + nImpsubst
						SE2->E2_CORREC  := nDifCambio
						SE2->E2_OTRGA   := nOtrga
						SE2->E2_CAMBIO  := nDifCambio
						SE2->E2_IMPSUBS := nImpSubst
					EndIf
					SE2->E2_MULTA	:= nMulta
					SE2->E2_DESCONT:= nDescont

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Gera lancamento contabil de estorno 								³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cPadrao := "531"    //cancelamento de baixa
					lPadraoBx := (VerPadrao(cPadrao) .and. lContabilizou)

					nRegB := SE2->( Recno() )
					lPadraoVd := VerPadrao("519") //cancelamento de baixa vendor
					dbSelectArea( "SE2" )
					dbGoto(nRegB)

					IF lVend
						lPadraoBx := VerPadrao( "531" ) //cancelamento
					Endif
					
					nTotAbat := Noround(xMoeda(nTotAbat,SE2->E2_MOEDA,nMoedaBco,dBaixa,,,nTxMoeda),3)
					ABATIMENTO := nTotAbat

					//Guardo valores antigos para contabilizar impostos no cancelamento
					If !_lPccMR .And. cPaisLoc == "BRA" .AND. lPccBaixa
						nPisOld		:= SE2->E2_PIS
						nCofOld		:= SE2->E2_COFINS
						nCslOld		:= SE2->E2_CSLL
						nVRPisOld	:= SE2->E2_VRETPIS
						nVRCofOld	:= SE2->E2_VRETCOF
						nVRCslold	:= SE2->E2_VRETCSL

						Reclock("SE2")
						Replace E2_PIS		With nPis
						Replace E2_COFINS	With nCofins
						Replace E2_CSLL		With nCsll
						Replace E2_VRETPIS	With nPis
						Replace E2_VRETCOF	With nCofins
						Replace E2_VRETCSL	With nCsll
						MsUnlock()
					Endif

					If !_lIrfMR
						If lIRPFBaixa
							If SE2->E2_PRETIRF != "4"
								Reclock("SE2")
								SE2->E2_VRETIRF -= nIrrf
								If SA2->A2_TIPO == "F"
									SE2->E2_IRRF -= nIrrf
								Endif

								MsUnlock()
							EndIf

							If (nIRRf > 0 .And. Empty(SE2->E2_NUMBOR)) .or. (nIRRf > 0 .And. !Empty(SE2->E2_NUMBOR).and. lCanBorder)//Quando a taxa possuir um bordero nao deve ser excluida.
								If lAtuSldNat
									dVencRea := F050VIMP("IRRF",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,'',SA2->A2_TIPO,lIRPFBaixa)
									AtuSldNat(GetMV("MV_UNIAO"),dVencRea, SE2->E2_MOEDA, "2", "P",nIRRf,0, If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"+","-"),,FunName(),"SE2",SE2->(Recno()),nOpcx)
								EndIf

								If SE2->E2_PRETIRF != "4"
									nRecSe2 := SE2->( Recno())
									If __oRatIRF <> Nil .AND. !Empty(__oRatIRF:aRatIRF)
										__oRatIRF:GetIRRetido(SE5->E5_IDORIG)
										For nX := 1 To Len(__oRatIRF:aRatIRF)
											F241DelTxIR( "FINA080", nRecSe2, __oRatIRF:aRatIRF[nX][7] )
										Next nX
									Else
										F241DelTxIR( "FINA080", nRecSe2, nIRRF )
									EndIf
								EndIf								
							Endif
						Else
							//Gera novamente o titulo de IR para o adiantamento
							If SE2->E2_PRETIRF = '1' .AND. AllTrim( SE2->E2_TIPO ) $ MVPAGANT
								nIRRF := SE2->E2_IRRF
								dVencRea := F050VIMP("IRRF",SE2->E2_EMISSAO,SE2->E2_EMIS1,SE2->E2_VENCREA,'',SA2->A2_TIPO,lIRPFBaixa)

								FGrvIRRF("FINA050",dVencRea,dDataBase,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_TIPO,nIRRF,SE2->E2_MOEDA,SE2->E2_LA,SE2->E2_DIRF,SE2->E2_CODRET,.F.,;
								{},{},SE2->(Recno()),"SE2",.T.)

								nIRRF := 0
							EndIf
						EndIf
					EndIf

					If !_lIssMR .And. lCalcIssBx
						Reclock("SE2")
						If SE2->E2_VRETISS > 0
							SE2->E2_VRETISS -= nIss
						EndIf
						MsUnlock()
					EndIf

					If (_lPccMR .Or. _lIrfMR .Or. _lIssMR)
						FK4->(DbSetOrder(3))
						cChaveFK4 := (FWxFilial("FK4", SE5->E5_FILORIG) + SE5->E5_IDORIG)
							
						If FK4->(DbSeek(cChaveFK4))
							While FK4->(!Eof()) .And. cChaveFK4 == FK4->(FK4_FILIAL+FK4_IDORIG)
								nVlrTribut := 0
								
								If FK4->FK4_STATUS == "1" .And. !Empty(FK4->FK4_CODFKM) .And. FK4->FK4_FILORI == SE5->E5_FILORIG
									nVlrTribut := FK4->FK4_VALOR
									cTributo   := AllTrim(FK4->FK4_IMPOS)
									
									Do Case
										Case cTributo $ "PIS|COF|CSL"
											If SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0
												SE2->E2_VRETPIS -= IIf(cTributo == "PIS", nVlrTribut, 0)
												SE2->E2_VRETCOF -= IIf(cTributo == "COF", nVlrTribut, 0)
												SE2->E2_VRETCSL -= IIf(cTributo == "CSL", nVlrTribut, 0)
											EndIf
											
											cPret := IIf(SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) == 0, "1", " ")
											SE2->E2_PRETPIS := cPret
											SE2->E2_PRETCOF := cPret
											SE2->E2_PRETCSL := cPret
										Case cTributo == "IRF"
											If SE2->E2_VRETIRF > 0																			
												SE2->E2_VRETIRF -= nVlrTribut
											EndIf 

											SE2->E2_PRETIRF := IIf(SE2->E2_VRETIRF == 0, "1", " ")
										Case cTributo == "ISS"	
											If SE2->E2_VRETISS > 0 																		
												SE2->E2_VRETISS -= nVlrTribut
											EndIf
									EndCase
								EndIf

								FK4->(DbSkip())
							EndDo
						EndIf
					EndIf
																		
					//Atualiza o status de viagem
					If (ALLTRIM(SE2->E2_ORIGEM) $ "FINA667|FINA677")
						FINATURES(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),.F.,SE2->E2_ORIGEM,"P")
					Endif
					If !(lInsPub .And. SE2->E2_TIPO $ MVPAGANT+"/INA") //Inss Baixa Empresa Publica
						If !lInsPub
							If SED->ED_CALCINS == "S" .and. SA2->A2_RECINSS == "S" .And. lInssBx .And. cPaisLoc = "BRA" //Inss Baixa
								Reclock("SE2")
								If SE2->E2_VRETINS > 0 .And. nInss > nVlRetin .And. lAltVr
									SE2->E2_VRETINS -= nInss
									SE2->E2_INSS 		-= nInss
								EndIf
								If SE2->E2_PRETINS	==	"2"
									SE2->E2_PRETINS	:=	"1"
								Endif
								MsUnlock()
							EndIf
						Else
							SE2->E2_VRETINS -= nInss
						Endif
					Endif
				Else
					RecLock("SE2")
					SE2->E2_OK := ''
					MsUnlock()

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Gera lancamento contabil de estorno 								³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cPadrao := "531"    //cancelamento de baixa
					lPadraoBx := (VerPadrao(cPadrao) .and. lContabilizou)

					nRegB := SE2->( Recno() )
					lPadraoVd := VerPadrao("519") //cancelamento de baixa vendor
					dbSelectArea( "SE2" )
					dbGoto(nRegB)

					IF lVend
						lPadraoBx := VerPadrao( "531" ) //cancelamento
					Endif
				EndIf

				//Verifica se contabiliza on-line o estorno da baixa Estorno de Vendor deve ser on-line.
				//Caso a baixa do titulo tenha sido contabilizada força a contabilização ON-LINE do cancelamento para que não fique nenhuma perna na contabilidade
				lLanca := .T.
				If nOpcx == 5 .and. !lVend .and. SE5->E5_TIPODOC == "VL"
					lLanca := mv_par03 == 1 .And. (SE5->E5_LA = "S" .or. cMultNat=="1")
				Endif

				//Não contabilizar baixas de títulos de origem PLS
				If "PLS" $ SE2->E2_ORIGEM
					lLanca := .F.
				EndIf

				cTpBxCtb := SE5->E5_TIPODOC
				//Condições para ser lançada a linha de estorno, a linha de estorno pode não ser gerada por conta de exclusão de lançamento ou movimentações que são apenas canceladas
				lCtbEstn := nOpcx == 5 .Or. ( nOpcx == 6 .And. ( ( cTpBxCtb =="BA" .And. !Empty(cLoteFin) .And. !Empty( SE5->E5_ARQCNAB ) ) .Or. ( lBxConc .And. !Empty( SE5->E5_RECONC ) ) ) )
				lCtbEstn := lCtbEstn .And. ( cTpBxCtb $ "VL" .Or. ( cTpBxCtb =="BA" .And. !Empty( cLoteFin ) .And. !Empty( SE5->E5_ARQCNAB ) ) )

				//Carrega a variável valor, conforme mov de bx, pois o tít pode ter bxs parciais
				If mv_par03 == 1 .And. Len(aBaixaSE5) > 0
					VALOR := aBaixaSE5[nOpbaixa, 8]
				EndIf

				If cMultNat == "1"
					DelMNatBx("SE2",@nHdlPrv,@nTotal,@cArquivo,nOpcx != 5,cSeqSE5,lLanca,lUsaFlag,@aFlagCTB) // Apaga as naturezas geradas para o titulo

					If nTotal > 0
						lContabilizou := .T.
						lPadraoBx := (VerPadrao(cPadrao) .and. lContabilizou)
					Endif
				Else
					If !lSubstPR .And. lAtuSldNat // Nao atualiza saldos de natureza para titulos provisorios
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_BAIXA, SE2->E2_MOEDA, "3", "P", If(SE2->E2_MOEDA > 1,nValEstrang,nValPgto),If(SE2->E2_MOEDA > 1, nValPgto, nValEstrang), If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"+","-"),,FunName(),"SE2",SE2->(Recno()),nOpcx)
					Endif
					
					IF (lPadraoBx .or. lPadraoVd ) .and. lContabilizou .and. lLanca
						If !lCtCanAut
							nHdlPrv := HeadProva( cLote, "FINA080" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
						Endif
						
						If lPadraoBx
							ABATIMENTO := nTotAbat
							If !lCtbEstn .And. !lCtCanAut
								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
								Endif
								//Prepara Lancamento Contabil
								nTotal += DetProva(nHdlPrv, cPadrao, "FINA080" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/,;
								/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/)
							EndIf
						Endif
						
						If lPadraoVd .And. lVend
							dbSelectArea("SE2")
							SE2->(dbGoto(nRegV) )
							
							If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
								aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
							Endif
							
							//Prepara Lancamento Contabil
							nTotal += DetProva( nHdlPrv, "519" /*cPadrao*/, "FINA080" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/,;
							/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
						Endif
					Endif
				Endif
				
				IF TrazCodMot(cMotBx) == "VEN"
					dbSelectArea("SE2")
					dbSetOrder(1)
					If dbSeek(xFilial("SE2")+cTitOriV) .And. SE2->E2_ORIGEM != "FINA090"
						If SE2->E2_SALDO == SE2->E2_VALOR
							If lExistFJU
								FinGrvEx("P")
							Endif
							Reclock("SE2",.F.,.T.)
							dbDelete()
						Else
							Help(" ",1,"BXVENDOR",,Subs(cTitOriV,1,3)+" "+Subs(cTitOriV,4,6)+;
							" "+Subs(cTitOriV,10,nTamParc)+" "+Subs(cTitOriV,10+nTamParc,3),5,1)
							lBaixaOk := .F.
						Endif
					ElseIf SE2->(!Eof()) .And. Alltrim(SE2->E2_ORIGEM) == "FINA090" .And. SuperGetMv("MV_BXAUTVE",.F.,.F.)
						Aviso(	STR0143, STR0141 + Chr(13)+; // "Atenção", "Existe um titulo de vendor gerado por esta baixa! Porém, como ele foi gerado pela rotina de baixa automática, seu valor não será alterado."
						STR0142 + Subs(cTitOriV,1,3)+" "+Subs(cTitOriV,4,6)+; // "Prefixo/Numero/Parcela/Tipo do titulo de VENDOR gerado: "
						" "+Subs(cTitOriV,10,nTamParc)+" "+Subs(cTitOriV,10+nTamParc,3),{"Ok"})
					Endif
				EndIf

				SE2->(dbGoto(nRegB))
				Reclock("SE2")
				nQtdBx   := Len(aBaixa)
				nTotAbat := Iif(SE2->E2_SALDO != 0, 0, nTotAbat)
				dDataAnt := Iif(nOpBaixa == nQtdBx, Iif(nQtdBx == 1, CtoD(""), aBaixaSE5[(nQtdBx-1),7]), SE2->E2_BAIXA)
				nValor   := SE2->E2_SALDO
				nSaldoBx := (nValPgto - (nJuros+nMulta+nOtrga+nImpSubst)) + (nDescont+nTotAbat) 
				nSaldoBx := Iif(nVA > 0, (nSaldoBx-nVA), (nSaldoBx + Abs(nVA)))
				
				If SE2->E2_MOEDA > 1 .And. nMoedaBco > 1
				    if ExistFunc("EasyOrigCambio") .And. EasyOrigCambio(SE5->E5_ORIGEM,SE5->E5_TIPO,SE5->E5_NUMERO,@nTxLiqCamb) // SE5->E5_ORIGEM = "EICAP100" .AND. SE5->E5_TIPO = "INV"
					   nValor += Round(xMoeda(nSaldoBx, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, @nTxLiqCamb), 2)
					else
  					   nValor += Round(xMoeda(nSaldoBx, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, SE2->E2_TXMOEDA), 2)				
					endif   
				ElseIf nMoedaBco > 1
					nValor += Round(xMoeda(nSaldoBx, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, 0), 2)
				Else
					nSaldoBx += _nTotImp
					nSaldoBx += IIf(_lPccMR, 0, (nPis+nCoFins+nCsll))
					nSaldoBx += IIf(_lIrfMR, 0, nIrrf)
					nSaldoBx += IIf(_lIssMR, 0, nIss)
					nSaldoBx += IIf(_lInsMR, 0, nInss)					
					nValor   += Round(xMoeda(nSaldoBx, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda), 2)
				EndIf
                
				If nValor <> SE2->E2_VALOR .AND. ABS(nValor - SE2->E2_VALOR) <= ABS(0.01) .And.;
					Len(aBaixa) <= 1		//Somente tratar a diferença de 0.01 centavos no caso do cancelamento ser da ultima baixa; se houver outras alem dessa, nao tratar;
											//	Ex: Efetuado 2 baixas, a primeira de 0.01 e a segunda do restante; ao cancelar a segunda, como a diferença eh de 0.01 centavos,
											//	entra neste IF tratando a baixa como TOTAL incorretamente, sendo que ainda possui outra 
                    nValor := SE2->E2_VALOR
                EndIf

				//Volta valor original do titulo se for o cancelamento final das baixas, se nao houverem compensa‡oes e se o titulo, ou parte dele, nao estiver em fatura.
				If nQtdBx == 1 .and. (nTotAdto+nTotImpost+nTotaIRPF) == 0 .And. !SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG .And. nValor == SE2->E2_VALOR .And.;
					(Empty(SE2->E2_FATURA) .Or. LTrim(SubStr(SE2->E2_FATURA,1,6)) == "NOTFAT") .And. !(SE2->E2_SALDO == 0)
					nValor := SE2->E2_VALOR
				Endif

				If SE2->E2_SALDO != SE2->E2_VALOR 
					SE2->E2_SALDO := IIf(nValor < 0, 0, nValor)
					If SE2->E2_SALDO > SE2->E2_VALOR
						SE2->E2_SALDO := SE2->E2_VALOR
					EndIf
				EndIf
				
				If 	cPaisLoc == "EUA"
					SE2->E2_SLPLAID := SE2->E2_SALDO
				EndIf
		
				SE2->E2_NUMSOL := ""

				If nQtdBx == 1 .And. SE2->E2_SALDO == SE2->E2_VALOR .And. SE2->E2_SDACRES == SE2->E2_ACRESC .And. SE2->E2_SDDECRE == SE2->E2_DECRESC					
					SE2->E2_BAIXA :=	 CtoD("")
					SE2->E2_MOVIMEN := SE2->E2_BAIXA
				ElseIf !(Empty(dDataAnt) .And. nQtdBx == 1 .And. SE2->E2_SALDO < SE2->E2_VALOR .And. !Empty( SE2->E2_BAIXA))
					SE2->E2_BAIXA	:= dDataAnt
				EndIf

				If lIRPFBaixa .And. SE2->E2_PRETIRF != "4"
					SE2->E2_PRETIRF := IIf(SE2->E2_SALDO > 0, "1"," ")
				EndIf

				SE2->E2_DESCONT := 0
				SE2->E2_MULTA	:= 0
				
				If SE2->E2_ORIGEM != 'FINA171'
					SE2->E2_JUROS	:= 0
				EndIf
				
				SE2->E2_CORREC	:= 0
				SE2->E2_VALLIQ	:= 0
				SE2->E2_LOTE 	:= Space(Len(SE2->E2_LOTE))
				SE2->E2_NUMBCO	:=	Space(Len(SE2->E2_NUMBCO))
				
				If cPaisLoc == "CHI"
					SE2->E2_OTRGA    := 0
					SE2->E2_CAMBIO   := 0
					SE2->E2_IMPSUBS  := 0
					SE2->E2_TXMOEDA  := 0
				EndIf
				
				//Caso exista solicitacao de NCP eh necessario atualizar o campo CU_DTBAIXA...
				If cPaisLoc <> "BRA"
					A055AtuDtBx("2",SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NUM,SE2->E2_PREFIXO,SE2->E2_BAIXA)
				EndIf
				
				If lSpbInUse
					SE2->E2_OKSPB		:= " "
					SE2->E2_CLEARIN	:= Space(3)
					SE2->E2_TPPGTO		:= Space(2)
					SE2->E2_HORASPB	:= Space(5)
				Endif
				
				If (SE2->E2_SALDO == SE2->E2_VALOR .AND. EMPTY(SE2->E2_BAIXA)) .AND. (SE5->E5_VLACRES > 0 .OR. SE5->E5_VLDECRE > 0)
					SE2->E2_SDACRES := SE2->E2_ACRESC
					SE2->E2_SDDECRE := SE2->E2_DECRESC
				Else
					If SE2->E2_MOEDA > 1 .AND. cPaisLoc == "BRA"
						If Round(NoRound(xMoeda(SE2->E2_ACRESC,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1) == Round(NoRound(SE5->E5_VLACRES,nCentMd1+1),nCentMd1)
							SE2->E2_SDACRES += Round(Noround(SE2->E2_ACRESC,nCentMd1+1),nCentMd1)
						Else
							SE2->E2_SDACRES += Round(Noround(xMoeda(SE5->E5_VLACRES,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
						Endif

						If Round(NoRound(xMoeda(SE2->E2_DECRESC,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1) == Round(NoRound(SE5->E5_VLDECRE,nCentMd1+1),nCentMd1)
							SE2->E2_SDDECRE += Round(Noround(SE2->E2_DECRESC,nCentMd1+1),nCentMd1)
						Else
							SE2->E2_SDDECRE += Round(Noround(xMoeda(SE5->E5_VLDECRE,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
						Endif
					Else
						SE2->E2_SDACRES += Round(Noround(xMoeda(SE5->E5_VLACRES,1,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
						SE2->E2_SDDECRE += Round(Noround(xMoeda(SE5->E5_VLDECRE,1,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
					Endif
					
					IF( Str(E2_SALDO,17,2) == Str(E2_VALOR,17,2) .and. Str(E2_SDACRES,17,2) = Str(E2_ACRESC,17,2) .and. Len(aBaixa) == 1  )//Se for a ultima baixa, pois pode ocorrer de haver baixa somente dos juros,logo os valores sao iguais com mais de uma baixa
						SE2->E2_BAIXA := CtoD("")
					EndIf
				EndIf

				//Guardo as parcelas de impostos para deleção correta dos mesmos
				If cPaisLoc == "BRA"
					cParcPis := SE2->E2_PARCPIS
					cParcCof := SE2->E2_PARCCOF
					cParcCsl := SE2->E2_PARCSLL
				EndIf

				If ((lPccBaixa .And. !_lPccMR) .Or. _lPccBxMR) .And. cPaisLoc == "BRA"
					//Guardo valores antigos para contabilizar impostos no cancelamento
					If !_lPccMR
						SE2->E2_PIS	    := nPisOld
						SE2->E2_COFINS	:= nCofOld
						SE2->E2_CSLL	:= nCslOld
						SE2->E2_VRETPIS := nVRPisOld
						SE2->E2_VRETCOF := nVRCofOld
						SE2->E2_VRETCSL := nVRCslOld
					EndIf

					SE2->E2_DIRF:= IF (!EMPTY(SE2->E2_CODRET).AND. (SE2->E2_VALOR-SE2->E2_SALDO)==0, "1", "2")

					//Verifica se o titulo em questao ja foi retido em outro titulo
					aAreaSE2 := SE2->(GetArea())
					dbSelectArea("SFQ")
					dbSetOrder(2)
					lAchouRel := MsSeek(xFilial("SFQ")+cAlias+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

					If !Empty(SE2->E2_NUMBOR)
						dbSelectArea("SEA")
						dbSetOrder(4)					
						If MsSeek(SE2->E2_FILORIG + SE2->(E2_NUMBOR+"P"+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
							lBord241:=(Alltrim(SEA->EA_ORIGEM)=='FINA241')
						EndIF
					EndIF
					RestArea(aAreaSE2)

					//Se o titulo estiver em bordero, permanece os campos de retencao do bordero
					If !Empty (SE2->E2_NUMBOR) .And. !lCanBorder
						If SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0
							SE2->E2_PRETPIS := Iif(lBord241,"4","1")
							SE2->E2_PRETCOF := Iif(lBord241,"4","1")
							SE2->E2_PRETCSL := Iif(lBord241,"4","1")
							If !_lPccMR .And. !lBord241
								SE2->E2_VRETPIS := Iif((nVRPisOld - nPis) < 0.00,0,(nVRPisOld - nPis))
								SE2->E2_VRETCOF := Iif((nVRCofOld - nCofins) < 0.00,0,(nVRCofOld - nCofins))
								SE2->E2_VRETCSL := Iif((nVRCslOld - nCSLL) < 0.00,0,(nVRCslOld - nCSLL))
							EndIf							
						ElseIf lAchouRel
							SE2->E2_PRETPIS := "2"
							SE2->E2_PRETCOF := "2"
							SE2->E2_PRETCSL := "2"
						ElseIf lRetBor
							SE2->E2_PRETPIS := "1"
							SE2->E2_PRETCOF := "1"
							SE2->E2_PRETCSL := "1"
							SE2->E2_PRETIRF := "1"
						EndIf
					Elseif !SE2->E2_TIPO $ MVPAGANT //Se for PA (geracao de tx's pela emissao), nao exclui o numero da parcela.
						If !_lPccMR 
							SE2->E2_VRETPIS := Iif((nVRPisOld - nPis) < 0.00,0,(nVRPisOld - nPis))
							SE2->E2_VRETCOF := Iif((nVRCofOld - nCofins) < 0.00,0,(nVRCofOld - nCofins))
							SE2->E2_VRETCSL := Iif((nVRCslOld - nCSLL) < 0.00,0,(nVRCslOld - nCSLL))
						EndIf
						SE2->E2_PARCPIS := Space(Len("E2_PARCPIS"))
						SE2->E2_PARCCOF := Space(Len("E2_PARCCOF"))
						SE2->E2_PARCSLL := Space(Len("E2_PARCSLL"))

						If (SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0) .Or. (_lPccBxMR .And. !Empty(SE2->E2_NUMBOR))
							cPret := FinRtPret(SE5->E5_SEQ)
							SE2->E2_PRETPIS := cPret
							SE2->E2_PRETCOF := cPret
							SE2->E2_PRETCSL := cPret
						Else
							SE2->E2_PRETPIS := "1"
							SE2->E2_PRETCOF := "1"
							SE2->E2_PRETCSL := "1"
						Endif
					EndIf
				Endif

				//Altera data de vencimento dos titulos de impostos
				If Empty(SE2->E2_BAIXA) .and. !lPccBaixa
					AltvencImp(SE2->E2_VENCREA)				
				Endif

				//Altera valor dos impostos
				If !lPccBaixa
					F080Impost(SE2->(RECNO()),.T.,nJuros,nMulta,nDescont,nValPgto,nVA)
				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica se h  abatimentos para voltar a carteira					³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cTitPai   := RTrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
				SE2->(DBSetorder(1))
				If SE2->(dbSeek(xFilial("SE2")+E2_PREFIXO+E2_NUM+E2_PARCELA))
					cTitAnt := SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA)
					While !SE2->(Eof()) .and. cTitAnt == (SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA)
						IF !SE2->E2_TIPO $ MVABATIM .Or. ( !Empty(SE2->E2_TITPAI) .And. cTitPai != RTrim(SE2->E2_TITPAI) )
							SE2->(dbSkip())
							Loop
						EndIF
						IF SE2->E2_FORNECE+SE2->E2_LOJA != cFornece+cLoja
							SE2->(dbSkip())
							Loop
						EndIF
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Volta titulo para carteira 				³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						Reclock("SE2")
						SE2->E2_BAIXA	:= dDataAnt
						SE2->E2_SALDO	:= E2_VALOR
						SE2->E2_DESCONT := 0
						SE2->E2_JUROS	:= 0
						SE2->E2_MULTA	:= 0
						SE2->E2_CORREC	:= 0
						SE2->E2_VARURV	:= 0
						SE2->E2_LOTE	:= Space(Len(E2_LOTE))
						SE2->E2_VALLIQ	:= 0
						SE2->E2_NUMBCO	:= Space(Len(SE2->E2_NUMBCO))

						If lCanBorder
							SE2->E2_NUMBOR := Space(Len(SE2->E2_NUMBOR))
						Endif

						If cPaisLoc == "CHI"
							SE2->E2_OTRGA    := 0
							SE2->E2_CAMBIO   := 0
							SE2->E2_IMPSUBS  := 0
							SE2->E2_TXMOEDA  := 0
						EndIf
						SE2->(dbSkip())
					Enddo
				Endif

				SE2->( dbGoTo( nSalvRec ) )

				// Valores acessórios.
				If __lPodeTVA .and. __lExistVA
					FAtuFKDBx(.T., "P")
				Endif

				//PONTOS DE ENTRADA
				If ExistTemplate("FA080CAN")
					ExecTemplate("FA080CAN",.F.,.F.,{nOpcx})
				Endif

				If ExistBlock("FA080CAN")
					ExecBlock("FA080CAN",.F.,.F.,{nOpcx})
				Endif

				If ExistBlock("FA080REC")
					ExecBlock("FA080REC",.F.,.F.,{nJuros,nMulta,dDataAnt})
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³LOCALiza na movimentação banc ria, os registros referentes a baixa³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				//Limpo referencias de apuracao de impostos.
				//Verifica cancelamentos apenas se o imposto realmente foi retido na baixa.
				//Exemplo abaixo:
				//Cancelamento de baixa de titulo cuja retenção ocorreu no bordero e nao na baixa
				If (lContrRet .and. lPccBaixa .and. !(nTotImpost > 0 .and. nPis+nCofins+nCsll == 0)) .Or.;
					(lIRPFBaixa .And. nTotaIRPF > 0) .Or. (lInssBx .And. nInssParc > 0)

					dbSelectArea("SE5")
					dbSetOrder(2)
					dbGoto(nRecSe5)
					If lIRPFBaixa .AND. (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1")) .AND. Empty(SE5->E5_PRETIRF) .and. ;
						!Empty(SE5->E5_PRETPIS)
						lRetSoIrf := .T.
					Endif

					aRecSE5 := FImpDelTit("SE5",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)

					For nX := 1 to Len(aRecSE5)
						//REESTRUTURACAO SE5
						//Neste ponto a rotina apenas seta os valores de pendencias de retencao de impostos no SE5
						//Foi mantida dasta forma antiga pois, na atualização das FKs (Model) eh que ocorrera
						// - A exclusao da retenção na FK4
						// - A exclusao do calculo de impostos da baixa que esta sendo canelada
						// - A limpeza do IDs de retencao dos demais titulos que compuseram a retencao mas continuam baixados
						SE5->(MSGoto(aRecSE5[nX]))
						RecLock("SE5",.F.)

						//Se nao reteve somente IRRF
						If !lRetSoIrf .And. (((!SE5->E5_TIPO $ MVPAGANT) .Or. (SE5->E5_TIPO $ MVPAGANT)) .And.;
						!Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)) .and. SE5->E5_MOTBX<>"CMP"
							SE5->E5_PRETPIS := "1"
							SE5->E5_PRETCOF := "1"
							SE5->E5_PRETCSL := "1"
						Endif

						If lIRPFBaixa .and. !Empty(SE5->E5_PRETIRF).and. SE5->E5_MOTBX<>"CMP" .and. SE5->E5_PRETIRF <> "4"
							SE5->E5_PRETIRF := "1"
						EndIf

						If lInssBx	.And. SE5->E5_PRETINS ==	"2" .And. !(lInsPub .And. SE2->E2_TIPO $ MVPAGANT+"/INA") //Inss Baixa
							SE5->E5_PRETINS	:=	"1"
						Endif
						SE5->(MsUnlock())
					Next

					//Exclui os registros de relacionamentos do SFQ
					SE5->(dbGoto(nRecSe5))
					FImpDelSFQ("SE5",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)

					aRecSE2 := FImpExcTit("SE2",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)

					For nX := 1 to Len(aRecSE2)
						SE2->(MSGoto(aRecSE2[nX]))
						FaAvalSE2(4)
					Next

					//Exclui os registros de relacionamentos do SFQ
					SE5->(dbGoto(nRecSe5))
					FImpExcSFQ("SE2",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)

					If !_lPccMR
						FDelTxBx(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ,cParcPis,cParcCof,cParcCsl)
					EndIf

					If !_lInsMR .And. lInssBx .And. !(SE2->E2_TIPO $ MVPAGANT+"/INA") //Inss Baixa
						FDelTxInss(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ,lAltVr)
					Endif
					SE5->(dbGoto(nRecSe5))
				Endif

				IF !_lIssMR .And. nIss != 0
					//Apaga tambem os registro de impostos-ISS
					SE5->(dbGoto(nRecSe5))
					SE2->(dbGoTo(nSalvRec))
					dbSelectArea("SE2")
					
					aAreaAt := GetArea()
					//Abro o SE2 com outro alias pois pode estar filtrado
					If Select("__SE2") == 0
						ChkFile("SE2",.F.,"__SE2")
					Else
						DbSelectArea("__SE2")
					EndIf

					dbSetOrder(1)

					__SE2->(dbGoTo(nSalvRec))

					cChavePai := __SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
					If MsSeek(xFilial("SE2")+__SE2->(E2_PREFIXO+E2_NUM))
						cChaveImp := __SE2->(E2_PREFIXO+E2_NUM)
						cNatIss	:= AllTrim(&(GetMv("MV_ISS")))
						While !Eof() .And. __SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM) == xFilial("SE2")+cChaveImp
							IF E2_TIPO $ MVISS .And. ;
								AllTrim(E2_NATUREZ) == cNatIss .And. ;
								STR(__SE2->E2_SALDO,17,2) == STR(__SE2->E2_VALOR,17,2) .and. ;
								(AllTrim(__SE2->E2_ORIGEM) $ "FINA080|FINA090|FINA091") .and. ;
								SE5->E5_SEQ == __SE2->E2_SEQBX .And. AllTrim(__SE2->E2_TITPAI) == AllTrim(cChavePai)
								If lExistFJU
									FinGrvEx("P")
								Endif

								// Integração SIGAPFS x SIGAFIN - Deleta os desdobramentos para os titulos filhos, quando estes forem gerados na baixa do titulo Pai.
								Iif(FindFunction("JDelTitCP")  .AND. lIntPFS, JDelTitCP(__SE2->(Recno())), Nil)
								
								FINDELFKs(__SE2->E2_FILIAL+"|"+__SE2->E2_PREFIXO+"|"+__SE2->E2_NUM+"|"+__SE2->E2_PARCELA+"|"+__SE2->E2_TIPO+"|"+__SE2->E2_FORNECE+"|"+__SE2->E2_LOJA,"SE2")
								
								RecLock( "__SE2" ,.F.,.T.)
								dbDelete( )
							EndIf
							dbSkip()
						Enddo
					Endif
					RestArea(aAreaAt)

				EndIf

				If !_lCidMR .And. nCide != 0
					// Deleta os registro de impostos-CIDE
					FDelCIDE( nSalvRec, , SE5->E5_SEQ )
				EndIf

				SE5->(dbGoto(nRecSe5))
				SE2->(dbGoTo(nSalvRec))

				dbSelectArea("SE5")
				dbSetOrder(2) // E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ

				If lIsRussia
					aAux := {"BA","JR","MT","OG","DC"}
				Else
					aAux := {"VL","BA","CM","CX","DC","MT","JR","VA"}
				EndIF
				IIf(cPaisloc == "CHI",AADD(aAux,"IS"),.T.)

				For nI := 1 to len(aAux)
					If SE5->(dbSeek(xFilial("SE5")+aAux[ni]+cChave))

						//-- Garante o posicionamento correto no SE5, caso haja algum compartilhamento na tabela
						While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .and. ;
							SE5->(E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)+DtoS(SE5->E5_DATA)+SE5->(E5_CLIFOR+E5_LOJA+E5_SEQ)==aAux[ni]+cChave							
							If SE5->E5_FILORIG == SE2->E2_FILORIG
								Exit
							EndIf
							SE5->(dbSkip())
						EndDo

						If SE5->E5_RECPAG <> "P" .And. !SE2->E2_TIPO $ MVPAGANT+"/INA/"+MV_CPNEG
							PosicMov(xFilial("SE5")+aAux[ni]+cChave, "P")
							If Alltrim(SE5->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)) != ;
									AllTrim(SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) .OR.  SE5->E5_RECPAG <> "P"
								Loop
							EndIf	
						EndIf

						cBanco	 := SE5->E5_BANCO
						cAgencia := SE5->E5_AGENCIA
						cConta   := SE5->E5_CONTA
						cTitulo := SE5->E5_NUMERO
						cCheque := SE5->E5_NUMCHEQ
						lCnab	:= IIF(EMPTY(SE5->E5_ARQCNAB),.F.,.T.)
						cTpDesc := IIF( cPaisLoc == "BRA" , SE5->E5_TPDESC , "" )

						If lAcreDecre
							nAcresc := SE5->E5_VLACRES
							nDecresc := SE5->E5_VLDECRE
						Endif

						If lContrRet .and. (lPccBaixa .Or. lIRPFBaixa .Or. lCalcIssBx)
							aImp := {SE5->E5_VRETPIS,SE5->E5_VRETCOF,SE5->E5_VRETCSL,SE5->E5_PRETPIS,SE5->E5_PRETCOF,SE5->E5_PRETCSL,/*E5_VRETIRF*/,/*E5_PRETIRF*/,/*E5_VRETISS*/}

							If lIRPFBaixa
								aImp[7] := SE5->E5_VRETIRF
								aImp[8] := SE5->E5_PRETIRF
							EndIf

							If lCalcIssBx
								aImp[9] := SE5->E5_VRETISS
							Endif
						Endif
						
						If lFina450
							cHistCan070 := STR0247
						ENDIF

						If (lPccBaixa .Or. lIRPFBaixa) .And. !Empty(SE2->E2_NUMBOR) .and. !lCanBorder
							//Gero o ID do documento - Titulo a Pagar
							cDocSE2 := xFilial("SE2") 	+ "|"
							cDocSE2 += SE2->E2_PREFIXO 	+ "|"
							cDocSE2 += SE2->E2_NUM 		+ "|"
							cDocSE2 += SE2->E2_PARCELA 	+ "|"
							cDocSE2 += SE2->E2_TIPO 	+ "|"
							cDocSE2 += SE2->E2_FORNECE 	+ "|"
							cDocSE2 += SE2->E2_LOJA

							cDocKey := FINBUSCAFK7(cDocSE2,"SE2")								
							FINGFK3BOR(2,"FK7",cDocKey,,,,,SE5->E5_IDORIG)
						EndIf	

						If nOpcx == 5 .Or. (nOpcx == 6 .And. ((aAux[nI]=="BA" .And. !Empty(cLoteFin) .And. lCnab) .Or.(lBxConc .and. !Empty(SE5->E5_RECONC))))
							If SE5->E5_TIPODOC $ "VL|BA" .AND. Iif(lIsRussia,lMov,.T.) 
								//Cancela as baixas gerando um lancamento de estorno no SE5
								If aAux[nI] $ "VL" .or. (aAux[nI]=="BA" .and. !Empty(cLoteFin).and. lCnab ) ;
									.or. (lFina450 .and. aAux[nI]=="BA" .and. IIf(FindFunction("F450VerEst"),F450VerEst(),.F.))
									nOperFK2 := 2	//Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK5
								Else
									nOperFK2 := 1	//Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
								EndIf
								If lIsRussia .and. lMov
									nOperFK2 := 1	//Change E5_SITUACA from SE5 to 'C' and generates a reversal on FK5
								EndIf

								aAreaAnt := GetArea()
								//Adicionado apenas para garantir o posicionamento da FKA
								If !EMPTY(FKA->FKA_IDORIG) .and. !EMPTY(SE5->E5_IDORIG) .and. FKA->FKA_IDORIG <> SE5->E5_IDORIG
									nOrFKABkp:= FKA->(IndexOrd())
									FKA->(dbSetOrder(3))//FKA_FILIAL+FKA_TABORI+FKA_IDORIG
									FKA->(MsSeek(xFilial("FKA")+SE5->E5_TABORI+SE5->E5_IDORIG))
									FKA->(dbSetOrder(nOrFKABkp))
								EndIf

                                dDtBaixa := SE5->E5_DATA

								oModelBx  := FWLoadModel("FINM020")
								
								oModelBx:SetOperation( 4 ) //Alteração
								oModelBx:Activate()	
								oModelBx:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5

								oSubFKA := oModelBx:GetModel( "FKADETAIL" )
								oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

								//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
								//E5_OPERACAO 2 = Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK5
								//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
								oModelBx:SetValue( "MASTER", "E5_OPERACAO", nOperFK2 )

								If cPaisLoc == "BRA"
									oModelBx:SetValue( "MASTER", "E5_CAMPOS", "{ {'E5_TPDESC' , '" + cTpDesc + "'} " + If( lDtCanBx,", {'E5_DTCANBX' , '" + DTOS(dDataBase) +"'}" , "") +" }" )
								EndIf
								
								oModelBx:SetValue( "MASTER", "HISTMOV"    , cHistCan070 )
								oModelBx:SetValue( "MASTER", "E5_LA", Iif((lPadraoBx .OR. lPadraoVd ) .and. lContabilizou .and. lLanca .and. !lUsaFlag,"S","N") )
								cIdFk2:= SE5->E5_IDORIG
								If oModelBx:VldData()
									oModelBx:CommitData()
									nRecSE5 := oModelBx:GetValue("MASTER","E5_RECNO")
									SE5->(dbGoTo(nRecSE5))

									//Se for cancelamento de baixa feita em lote, então gera registro de estorno na FK5 (referente ao BL)
									IF aAux[nI] == "BA" .AND. !Empty(cLoteFin)
										FA080EstBL( cLoteFin, cHistCan070, dDtBaixa )
									Endif

									If lUsaFlag .and. nOperFK2 == 2  // Armazena em aFlagCTB para atualizar no modulo Contabil
										aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
									Endif

									IF (cPaisloc $ "MEX|PER" .and. ((FUNNAME() == "MATA101N") .Or. (lChkLxProp .and. ChkLxProp("CancelacionAnticipo")))) .Or. lValPedim
										AADD(aRecBorra,{SE5->( Recno() ),"N"})
									EndIf

									If lPadraoBx .and. lContabilizou .and. lLanca .And. aAux[nI] $ cTpBxCtb .And. lCtbEstn .And. !lCtCanAut
										nTotal += DetProva( nHdlPrv, cPadrao, "FINA080" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/,;
										/*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
									EndIf
								Else
									lRet := .F.
									cLog := cValToChar(oModelBx:GetErrorMessage()[4]) + ' - '
									cLog += cValToChar(oModelBx:GetErrorMessage()[5]) + ' - '
									cLog += cValToChar(oModelBx:GetErrorMessage()[6])
									Help( ,,"M020VLDE2",,cLog, 1, 0 )
									lCancPFS := .F.
									DisarmTransaction()
									Break
								Endif
								oModelBx:DeActivate()
								oModelBx:Destroy()
								oModelBx:= Nil

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ PONTO DE ENTRADA F080EST                            ³
								//³ PE para grava‡äes complementares do cancelamento    ³
								//³ da baixa                                            ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								IF nOperFK2 == 1 .and. EXISTBLOCK("F080EST")
									ExecBlock("F080EST",.F.,.F.)
								Endif

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ PONTO DE ENTRADA F080EST2                           ³
								//³ PE para grava‡oes complementares do cancelamento    ³
								//³ da baixa                                            ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								IF EXISTBLOCK("F080EST2")
									ExecBlock("F080EST2",.F.,.F.)
								Endif

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Grava os lancamentos das contas orcamentarias - SIGAPCO    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If SE5->E5_TIPODOC == "ES"
									PcoDetLan("000005","02","FINA080")
								ElseIf Alltrim(SE5->E5_ORIGEM) == "FINA091"
									PcoDetLan("000024", "01", "FINA091",.T.)
								Else
									PcoDetLan("000005","01","FINA080",.T.,"00000601")
									PcoDetLan("000006","01","FINA090",.T.)
								EndIf

								RestArea(aAreaAnt)
							Else
								//Cancelo os registros de valores acessoriso (Multas, Juros etc)
								If SE5->E5_TIPODOC == "VA" //Valores Acessórios
									SE5->(dbSetOrder(2))
									cChaveVA := xFilial("SE5")+"VA"+cChave
									While !SE5->(EOF()) .and. cChaveVA == SE5->(E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ)
										RecLock("SE5")
										SE5->E5_SITUACA := "C"
										If lDtCanBx
											SE5->E5_DTCANBX := dDataBase
										EndIf
										SE5->(Dbskip())
									EndDO
								Else
									RecLock("SE5")
									SE5->E5_SITUACA := "C"
									If lDtCanBx
										SE5->E5_DTCANBX := dDataBase
									EndIf
								EndIf
								MsUnLock()
							Endif
						Else
							lExclusao := .T.

							//Posiciona a FK5 para mandar a operação de alteração com base no registro posicionado da SE5
							If SE5->E5_TIPODOC $ "VL|BA"

								aAreaAnt := GetArea()
								//Adicionado apenas para garantir o posicionamento da FKA
								If !EMPTY(FKA->FKA_IDORIG) .and. !EMPTY(SE5->E5_IDORIG) .and. FKA->FKA_IDORIG <> SE5->E5_IDORIG
									nOrFKABkp:= FKA->(IndexOrd())
									FKA->(dbSetOrder(3))//FKA_FILIAL+FKA_TABORI+FKA_IDORIG
									FKA->(MsSeek(xFilial("FKA")+SE5->E5_TABORI+SE5->E5_IDORIG))
									FKA->(dbSetOrder(nOrFKABkp))
								EndIf

								oModelBx  := FWLoadModel("FINM020")
								oModelBx:SetOperation( 4 ) //Alteração
								oModelBx:Activate()
								oModelBx:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
								oModelBx:SetValue( "MASTER", "HISTMOV"    , cHistCan070 )
								oSubFKA := oModelBx:GetModel( "FKADETAIL" )
								oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

								//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
								//E5_OPERACAO 2 = Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK5
								//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
								oModelBx:SetValue( "MASTER", "E5_OPERACAO", 3 )
								cIdFk2:= SE5->E5_IDORIG
								If oModelBx:VldData()
									oModelBx:CommitData()
								Else
									lRet := .F.
									cLog := cValToChar(oModelBx:GetErrorMessage()[4]) + ' - '
									cLog += cValToChar(oModelBx:GetErrorMessage()[5]) + ' - '
									cLog += cValToChar(oModelBx:GetErrorMessage()[6])
									Help( ,,"M020VLDE3",,cLog, 1, 0 )
									lCancPFS := .F.
									DisarmTransaction()
									Break
								Endif
								oModelBx:DeActivate()
								oModelBx:Destroy()
								oModelBx:= Nil
								RestArea(aAreaAnt)
							Else
								//Cancelo os registros de valores acessoriso (Multas, Juros etc)
								If SE5->E5_TIPODOC == "VA" //Valores Acessórios
									SE5->(dbSetOrder(2))
									cChaveVA := xFilial("SE5")+"VA"+cChave
									While !SE5->(EOF()) .and. cChaveVA == SE5->(E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ)
										RecLock("SE5")
										dbDelete()
										MSUnlock()
										SE5->(Dbskip())
									EndDO
								Else
									RecLock("SE5")
									dbDelete()
									MsUnLock()
								Endif	
							Endif

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Grava os lancamentos das contas orcamentarias - SIGAPCO    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If SE5->E5_TIPODOC == "ES"
								PcoDetLan("000005","02","FINA080")
							ElseIf Alltrim(SE5->E5_ORIGEM) == "FINA091"
								PcoDetLan("000024", "01", "FINA091",.T.)
							Else
								PcoDetLan("000005","01","FINA080",.T.)
								PcoDetLan("000006","01","FINA090",.T.)
							EndIf

						EndIf

						//Motor de Retenção Exclusão dos impostos
						If _lTemMR .And. (_lPccMR .Or. _lIrfMR .Or. _lInsMR .Or. _lIssMR .Or. _lCidMR .Or. _lSesMR .Or. _lImpMR)
							FMRDelImp(SE5->E5_TABORI, SE5->E5_IDORIG)
						Endif
					Endif
				Next

				dbSetOrder(1)
				dbGoTo(nRecSe5)		//volta para o registro principal
				//Deleta Cheque gerado pela baixa				    ³
				nRecNo := 0
				nValor := 0
				dbSelectArea("SEF")
				If nRecDelSef > 0
					dbGoto( nRecDelSef )
					lRet := .T.
					If SEF->EF_IMPRESS != "C"
						//Reestruturacao SE5
						//Dados do Cheque - FKA
						If !Empty(SEF->EF_IDSEF)
							dbSelectArea("FKA")
							FKA->(dbSetOrder(3)) //FKA_FILIAL+FKA_TABORI+FKA_IDORIG
							If FKA->(MsSeek(xFilial("FKA")+"SEF"+SEF->EF_IDSEF))
								Reclock("FKA",.F.,.T.)
								dbDelete()
								MsUnlock()
							Endif
						Endif

						//Dados do Cheque - SEF
						Reclock("SEF",.F.,.T.)
						nValor := SEF->EF_VALOR
						dbDelete()
						MsUnlock()
					Endif
				Endif
				dbSetOrder(1)
				nRecNo := 0
				nValor := 0

				//Atualiza o totalizador
				If SubStr(cCheque,1,1) = "*" .And. nRecNo != 0
					dbGoTo( nRecNo )

					//Reestruturacao SE5
					//Dados do Cheque - FKA
					If !Empty(SEF->EF_IDSEF)
						dbSelectArea("FKA")
						FKA->(dbSetOrder(3)) //FKA_FILIAL+FKA_TABORI+FKA_IDORIG
						If FKA->(MsSeek(xFilial("FKA")+"SEF"+SEF->EF_IDSEF))
							Reclock("FKA",.F.,.T.)
							FKA->(dbDelete())
							MsUnlock()
						Endif
					Endif

					//Dados do Cheque - SEF
					Reclock("SEF")
					SEF->EF_VALOR -= nValor
					IF SEF->EF_VALOR == 0
						Reclock("SEF",.F.,.T.)
						SEF->(dbDelete())
						MsUnlock()
					Endif
				Endif

				If lAtuForn

					//Atualiza o Cadastro de Fornecedores
					dbSelectArea("SA2")
					If !Eof()
						RecLock( "SA2" )
						If SE2->E2_MOEDA > 1 .Or. cPaisLoc<>"BRA"
							nValPadrao := Round(NoRound(xMoeda(nValPadrao,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1),nCentMd1+1),nCentMd1)
							nValPadrao := Round(NoRound(xMoeda(nValPadrao,SE2->E2_MOEDA,nMoedaBco,SE2->E2_EMISSAO,nCentMd1+1),nCentMd1+1),nCentMd1)
						Endif
						IF SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
							SA2->A2_SALDUP		:= A2_SALDUP - nValPadrao
							SA2->A2_SALDUPM	:= A2_SALDUPM-xMoeda(nValPadrao,nMoedaBco,Val(GetMv("MV_MCUSTO")),SE2->E2_EMISSAO)
						Else
							SA2->A2_SALDUP		:= A2_SALDUP + nValPadrao
							SA2->A2_SALDUPM	:= A2_SALDUPM+xMoeda(nValPadrao,nMoedaBco,Val(GetMv("MV_MCUSTO")),SE2->E2_EMISSAO)
						Endif
						nAtraso:=dBaixa-SE2->E2_VENCTO
						If nAtraso > 1
							IF Dow(SE2->E2_VENCTO) == 1 .Or. Dow(SE2->E2_VENCTO) == 7
								IF Dow(dBaixa) == 2 .and. nAtraso <= 2
									nAtraso := 0
								EndIF
							EndIF
							nAtraso:=IIF(nAtraso<0,0,nAtraso)
							If SA2->A2_MATR < nAtraso
								Replace A2_MATR With nAtraso
							EndIf
						Endif
					Endif
				Endif
				//Atualiza saldos bancarios No cancelamento de baixa de adiantamento, o saldo do caixa/banco
				//deve diminuir, pois o capital saiu do caixa e voltou a quem solicitou o PA
				dbSelectArea("SE2")
				SE2->( dbGoto(nReg) )

				If lPaisMI .And. SE2->E2_TIPO $ MVPAGANT + "|" + MV_CPNEG .And. lF080ActSEK
					// MI: Actualiza status de la orden de pago (PA)
					F080ActSEK(SE2->E2_NUM, .F.)
				EndIf

				If lCOL4XMIL .And. SE2->E2_TIPO $ MVPAGANT
					// Colombia. Actualiza el estatus del impuesto (IT) 4xMil (GMF) en la anulacion de baja del PA
					FINXBJ4XML( SE2->E2_NUM,SE2->E2_PREFIXO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_EMISSAO,aBaixaSE5[nOpBaixa,11],aBaixaSE5[nOpBaixa,12],aBaixaSE5[nOpBaixa,13],.T.)
				EndIf
				If lMovBcoBx .And. SE2->E2_TIPO $ MVPAGANT + "|" + MV_CPNEG
					If lPaisMI
						AtuSalBco(aBaixaSE5[nOpBaixa,11],aBaixaSE5[nOpBaixa,12],aBaixaSE5[nOpBaixa,13],If(lExclusao,aBaixaSE5[nOpBaixa,7],dDataBase),;
									Round(NoRound(xMoeda(nValPgto, nMoedaTit, nMoedaBco, dBaixa, nCentMd1+1, nTxModTit, nTxModBco), nCentMd1+1), nCentMd1),"-")
					Else
						AtuSalBco(aBaixaSE5[nOpBaixa,11],aBaixaSE5[nOpBaixa,12],aBaixaSE5[nOpBaixa,13],If(lExclusao,aBaixaSE5[nOpBaixa,7],dDataBase),nValPgto,"-")
					EndIf
				Else
					//Caixa ou Bordero sem Cheque ou Debto.CC Quando for Debito em C.Corrente tem que estornar o saldo Bancario
					//Verifica o modulo para definir o tratamento do Caixa
					If (lEstorna .and. lMovBcoBx .and. SE5->E5_TIPODOC <> "BA") .OR. ;
						Left(aBaixaSE5[nOpBaixa,11],nTamCodA6) == Left(GetMv("MV_CXFIN"),nTamCodA6) .or. aBaixaSE5[nOpBaixa,11] $ GetMv("MV_CARTEIR")
						AtuSalBco(aBaixaSE5[nOpBaixa,11],aBaixaSE5[nOpBaixa,12],aBaixaSE5[nOpBaixa,13],If(lExclusao,aBaixaSE5[nOpBaixa,10],dDataBase),nValPgto,"+")
					Else
						//Atualiza saldo bancario quando motivo de baixa movimenta banco mas este motivo de baixa nao gera cheque
						If	( lMovBcoBx .and. !ChqMotBx(cDescrMo)) .AND. ;
							( !(Left(aBaixaSE5[nOpBaixa,11],3) == Left(GetMv("MV_CXFIN"),nTamCodA6)) .and. !(aBaixaSE5[nOpBaixa,11] $ GetMv("MV_CARTEIR")) )
							AtuSalBco(aBaixaSE5[nOpBaixa,11],aBaixaSE5[nOpBaixa,12],aBaixaSE5[nOpBaixa,13],If(lExclusao,aBaixaSE5[nOpBaixa,10],dDataBase),nValPgto,"+")
						//Russia usa cheque no Bank Statement mas deve atualizar o banco para todas os Payment request baixados
						ElseIf lIsRussia .and. (Type("lF080Auto")<>"U" .and. lF080Auto) .AND.  (ascan(aAutoCab,{|x| x[1] == 'AUTPAYORD'}) ) > 0
							AtuSalBco(aBaixaSE5[nOpBaixa,11],aBaixaSE5[nOpBaixa,12],aBaixaSE5[nOpBaixa,13],If(lExclusao,aBaixaSE5[nOpBaixa,7],dDataBase),nValPgto,"+")
						EndIf
					EndIf
				EndIf

				If lCanBorder .And. !Empty(SE2->E2_NUMBOR)
					If _lTemMR .and. F080TemMR(SA2->A2_COD,SA2->A2_LOJA)
						cChaveFK7 := xFilial("SE2") + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" + SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
						nImpBor := FinImpBor("P", cChaveFK7, SE2->E2_NUMBOR, "FK2")
					EndIf

					If nImpBor > 0 .Or. (lPccBaixa .And. SE2->(E2_PIS+E2_CSLL+E2_COFINS) > 0 .And. SE2->(E2_PRETPIS+E2_PRETCOF+E2_PRETCSL) != "111") .Or.;
						(lIRPFBaixa .And. SE2->E2_IRRF > 0 .And. SE2->E2_VRETIRF > 0) .Or. (lCalcIssBx .And. SE2->E2_ISS > 0 .And. SE2->E2_VRETISS > 0)
						//Atencao", Embora o parâmetro MV_CANBORP esteja 'S', o borderô nao foi cancelado pois
						//possui impostos Pis Cofins CSLL. Para cancelar esse borderô utilize a rotina de manutenção de borderô. Sugerimos também que utilize o parâmetro MV_CANBORP = 'N'
						IF !lF080Auto
							Aviso(STR0143,STR0160 + STR0177 +STR0162,{STR0078})
						Endif
						
						RecLock("SE2",.F.)
						
						If lPccBaixa .And. SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) > 0
							SE2->E2_PRETPIS := "4"
							SE2->E2_PRETCOF := "4"
							SE2->E2_PRETCSL := "4"
						EndIf
						
						If lIRPFBaixa .And. SE2->E2_VRETIRF > 0
							SE2->E2_PRETIRF := "4"
						EndIf
						
						SE2->(MSUnlock())
					Else
						//Apaga registro do titulo no SEA retirando-o do bordero
						nOrdem := SEA->(IndexOrd())
						dbSelectArea("SEA")
						DbSetOrder(2)
						If F080PesqBord(SE2->E2_NUMBOR,@cFilBor,"P",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_FILORIG)
							If SEA->(dbseek(cFilBor+SE2->(E2_NUMBOR+"P"+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
								While !Eof() .and. 	SEA->(EA_FILIAL+EA_NUMBOR+"P"+EA_PREFIXO+EA_NUM+EA_PARCELA+EA_TIPO+EA_FORNECE+EA_LOJA) == ;
													SE2->(cFilBor+E2_NUMBOR+"P"+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
									Reclock("SEA",.F.,.T.)
									dbDelete()
									Exit
								Enddo
							Endif
						EndIf
						
						If (__F080EXEA)
							ExecBlock("F080EXEA", .F., .F., {cFilBor, SE2->E2_NUMBOR, SE2->E2_FORNECE, SE2->E2_LOJA})
						EndIf

						dbSelectArea("SEA")
						dbSetOrder(nOrdem)
						RecLock("SE2",.F.)
						SE2->E2_NUMBOR := Space(Len(SE2->E2_NUMBOR))
						SE2->E2_PORTADO:= Space(Len(SE2->E2_PORTADO))

						If cPaisLoc == "BRA"
							SE2->E2_DTBORDE	:= CTOD("  /  /  ")
						EndIf						

						cDocSE2 := xFilial("SE2") + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" + SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
						cDocKey := FINBUSCAFK7(cDocSE2,"SE2")
						FINGFK3BOR(3,"FK7",cDocKey,aImpos,,,,cIdFk2)						
					EndIf
				Endif

				//---------------------------------------------------------
				// Gera lançamento contábil de estorno
				//---------------------------------------------------------
				IF nHdlPrv > 0 .And. (lPadraoBx .Or. lPadraoVd) .and. lContabilizou .and. lLanca 
					//-- Se for rotina automatica força exibir mensagens na tela, pois mesmo quando não exibe os lançametnos, a tela
					//-- sera exibida caso ocorram erros nos lançamentos padronizados
					If lF080Auto
						lSetAuto := _SetAutoMode(.F.)
						lSetHelp := HelpInDark(.F.)
						If Type('lMSHelpAuto') == 'L'
							lMSHelpAuto := !lMSHelpAuto
						EndIf
					EndIf

					If Empty(aPerg)
						lDigita := If( mv_par01 == 1, .T., .F. )
						lAglut  := If( mv_par02 == 1, .T., .F. )
					EndIf

					If UsaSeqCor()
						aAdd(aDiario,{"SE5",SE5->(RecNo()),cCodDiario,"E5_NODIA","E5_DIACTB"})
					Else
						aDiario := {}
					EndIf

					//----------------------------------------
					// Efetiva Lançamento Contabil
					//----------------------------------------
					If !lCtCanAut
						cA100Incl( cArquivo,;
								nHdlPrv,;
								3 /*nOpcx*/,;
								cLote,;
								lDigita,;
								lAglut,;
								/*cOnLine*/,;
								/*dData*/,;
								/*dReproc*/,;
								@aFlagCTB,;
								/*aDadosProva*/,;
								aDiario )
						aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
					Endif

					If lF080Auto
						HelpInDark(lSetHelp)
						_SetAutoMode(lSetAuto)
						If Type('lMSHelpAuto') == 'L'
							lMSHelpAuto := !lMSHelpAuto
						EndIf
					EndIf
				Endif
			Endif

			//Se for PABruto volta o valor dos impostos PCC
			If lPaBruto .and. nOpBaixa == 1 .and. TRIM(SE2->E2_TITADT) == "1"
				PABrtComp(.F.,.T.)
			EndIf

			//O recalculo do PCC (FINA379) nao deverá ocorrer quando a baixa cancelada nao reteve
			//os impostos e os mesmos foram retidos no titulo e em bordero
			If lPccBaixa .and. lRecalcPcc .and. !(nTotImpost > 0 .and. nPis+nCofins+nCsll == 0)
				//1 - Mês do periodo de verificacao
				//2 - Ano do periodo de verificacao
				//3 - Fornecedor De
				//4 - Fornecedor Até
				//5 - Mostra tela Contabilizacao (NAO, para este caso)
				SaveInter()
				aPar379 := {}
				aPar379 := {Month(dDatabase),Year(dDatabase),SE2->E2_FORNECE,SE2->E2_FORNECE,2}
				//proteção para não disposicionar a tabela
				aAreaSE2 := SE2->(GETAREA())
				aAreaSE5 := SE5->(GETAREA())
				Fina379()
				RestArea(aAreaSE5)
				RestArea(aAreaSE2)
				RestInter()
				Pergunte("FIN080",.F.)
			Endif
			FA373Bx(.F.)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Final da proteção via TTS				 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			/*-----------------------------+
			| Integração SIGAGFR x SIGAFIN |
			+-----------------------------*/
			If SuperGetMV( 'MV_NGMNTFI', .F., 'N' ) == 'S'
				
				/*------------------------------------------+
				| Realiza o cancelamento da baixa de multa. |
				+------------------------------------------*/
				NGBAIXASE2( 2 )
				
				/*------------------------------------------------+
				| Exclui apropriação de débito vinculado a multa. |
				+------------------------------------------------*/
				lPagAutFin := .F. 
				MNT765CONF( 5 )

			EndIf

			If !lFini055 .and. __lEAIF080
				llOpc  := ALTERA
				ALTERA := .F.  // Cancelamento de baixa.

				aEaiRet := FWIntegDef('FINA080',,,, 'FINA080')
				If !aEaiRet[1]
					Help(" ", 1, "HELP", STR0217, STR0218 + CRLF + aEaiRet[2], 3, 1)  // "Erro EAI" / "Problemas na integração EAI. Transação não executada."
					DisarmTransaction()
					lRet := .F.
				Endif

				ALTERA := llOpc
			Endif

			If lRet
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//--Efetua a exclusão da Parcela no PAMCARD - SIGATMS		³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !PamCanBx(SE2->E2_FILORIG,SE2->E2_NUM,SE2->E2_CODOPE)
					DisarmTransaction()
					lRet := .F.
					Break
				EndIf

				//Integração SIGAPFS x SIGAFIN
				If lCancPFS .And. FindFunction("JGrvBxPag")

					lCancPFS := JGrvBxPag(SE2->(RECNO()), 5, SE5->(RECNO()),, lExclusao)

					If !lCancPFS
						DisarmTransaction()
						Break
					EndIf
				EndIf
			EndIf

		End Transaction

		If lRet
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Finaliza a gravacao dos lancamentos do SIGAPCO ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			PcoFinLan("000005")

			SA6->(DbSetOrder(nOrdSa6), DbGoto(nRecSa6))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de entrada para pos-gravação do cancelamento  ³
			//³ e contabilização da baixa				            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF __F080PCAN
				ExecBlock("F080PCAN",.f.,.f.)
			Endif

			//Gera Log do cancelamento da baixa
			SE5->(dbGoto(nRecSe5))
			DbSelectArea("SE2")
			FinaCONC({{Iif(nOpcX==5,STR0114,STR0115+'-'+STR0006),;
			Iif(nOpcX==5,STR0114,STR0115+'-'+STR0006)+'-'+FunName(),'','',;
			STR0042 +' : ' + Alltrim(Transform(SE5->E5_VALOR,PesqPict("SE5","E5_VALOR")))}})
		Endif
	Endif

	dbSelectArea(cAlias)
	If nSalvRec > 0
		dbGoTo(nSalvRec)
	EndIf
	dbSetOrder(nOrdem)

	If lRet
		//Atualização TMS - Status do Contrato de Carreteiro
		If AllTrim(SE2->E2_ORIGEM) == 'SIGATMS'
			aAreaSE2 := SE2->(GetArea())
			TMSA250PBx(SE2->E2_FILORIG, SE2->E2_NUM)
			RestArea(aAreaSE2)
		EndIf

		//Trade-Easy
		//RRC - 05/12/2013 - Integração SIGACOM x SIGAESS e SIGAEIC x SIGAESS a partir dos títulos do SIGAFIN
		/*Verifica se não veio do ESSPS400 pois esta chamada pode ser decorrente da própria PS400BuscFat(), ao atualizar o câmbio do SIGAESS.
		Dessa forma, impede uma recursividade desnecessária*/
		If AvFlags("CONTROLE_SERVICOS_AQUISICAO") .And. !FwIsInCallStack("ESSPS400") .And. Empty(SE2->E2_BAIXA) .And. SE2->E2_TIPO == MVNOTAFIS
			lESSCOM := GetMv("MV_COMSEIC",,.F.) .And. GetMv("MV_ESS0012",,.F.) .And. GetMv("MV_ESS0013",,.F.) .And. AllTrim(SE2->E2_ORIGEM) == "MATA100"
			lESSEIC := GetMv("MV_ESS0022",,.T.) .And. /*AllTrim(SE2->E2_ORIGEM) == "SIGAEIC"*/ AllTrim(SE2->E2_PREFIXO) == "EIC" .And. SWD->(FieldPos("WD_MOEDA")) > 0 .And. SWD->(FieldPos("WD_VL_MOE")) > 0 .And. SWD->(FieldPos("WD_TX_MOE")) > 0 //MCF - 01/06/2016
			If lESSCOM .Or. lESSEIC
				PS400BuscFat("A",If(lESSCOM,"SIGACOM","SIGAEIC"),,SE2->E2_NUM,SE2->E2_PREFIXO,.T.,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_PARCELA)
			EndIf
		EndIf

		//Uso para bajas de anticipos, modifica la situación del antiticipo bajado
		//y se elinima el movimiento generado en SE% para la baja.
		IF ((cPaisloc $ "MEX|PER" .and. ((FUNNAME() == "MATA101N") .Or. (lChkLxProp .and. ChkLxProp("CancelacionAnticipo")))) .Or. lValPedim) .And. lF080Auto
			aBorrado := GetArea()
			FOR nX := 1 to Len(aRecBorra)
				If aRecBorra[nX][2] == "M"
					SE5->(dbGoto(aRecBorra[nX][1]))
					RecLock("SE5",.F.)
					SE5->E5_SITUACA := "C"
					If !lValPedim
						SE5->E5_HISTOR	:= PADR(SE5->E5_HISTOR,Len(SE5->E5_HISTOR)-16)+"###["+DTOS(dDatabase)+"]###"
					EndIf
					SE5->(MsUnlock())
				elseif aRecBorra[nX][2] == "N"
					SE5->(dbGoto(aRecBorra[nX][1]))
					RecLock("SE5",.F.)
					SE5->(DbDelete())
					SE5->(MsUnlock())
				EndIf
			NEXT
			RestArea(aBorrado)
			aRecBorra := {}
		endiF

		//Ajusta saldo do título, resíduo
		If nOpc1 == 1 .And. SE2->E2_MOEDA > 1 .And. nBaixa == 1
			LimpResid(cChaveSE2, 1, "P", .T.)
		EndIf
	Endif
	cBanco	:= CriaVar( "E5_BANCO" )
	cAgencia := CriaVar( "E5_AGENCIA")
	cConta	:= CriaVar( "E5_CONTA" )
    
	If lIsRussia 
		//return dDataBase for current day
		//volta a data base para o valor corrente, na RUSSIA temos cancelamentos na data original da baixa e nao na atual do sistema, rotina BankStatement RU06D07
		dDataBase := dDatSave
		IF !IsBlind() .And. nOpc1 == 1
			Aviso(STR0233, STR0234)
		Endif
	EndIf
    //Restaura Pergunte do FINA080
    If Len(aPerg) == 3
        mv_par01    :=  aRestPerg[1]
        mv_par02    :=  aRestPerg[2]
        mv_par03    :=  aRestPerg[3]
    EndIf

	//Métrica MI para cuantificar las veces que se anuló la baja total o parcial de un PA generado desde Orden de Pago
	If cPaisLoc <> "BRA" .And. nOpc1 == 1 .And. lRet .And. AllTrim(SE2->E2_TIPO) == 'PA' .And. AllTrim(SE2->E2_ORIGEM) $ "FINA085A|FINA850"
		If FwLibVersion() >= "20210517"
			If ROUND(nSaldoBX,2) + ROUND(SE2->E2_SDACRES,2) == ROUND(SE2->E2_VALOR,2) + ROUND(SE2->E2_ACRESC,2)
				FWMetrics():addMetrics("FA080CAN_Anulación_Baja_PA", {{"financeiro-protheus_cantidad-de-anulacion-de-bajas-de-pa-total", 1 }} )
			Else
				FWMetrics():addMetrics("FA080CAN_Anulación_Baja_PA", {{"financeiro-protheus_cantidad-de-anulacion-de-bajas-de-pa-parcial", 1 }} )
			EndIf
		EndIf
	Endif

	f080LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

	FwFreeArray(aBaixa)
	FwFreeArray(aAux)
	FwFreeArray(aMotBx)
	FwFreeArray(aImp)
	FwFreeArray(aImpos)
	FwFreeArray(aRestPerg)
	FwFreeArray(aAreaSE5)
	FwFreeArray(aAreaSE2)

Return /*Function fa080Can*/

//-------------------------------------------------------------------
/*/{Protheus.doc}fA080Grava
Grava as baixas
@author Wagner Xavier 
@since  06/05/1992
/*/
//-------------------------------------------------------------------
Function fA080Grava(cLanca)
	Local nx        := 0
	Local cArquivo  := ""
	Local lDigita   := mv_par01 == 1
	Local nTotal    := 0
	Local nHdlPrv   := 0
	Local lAglut    := mv_par02 == 1
	Local lPadraoBx := .F.
	Local lHdlPrv   := .F.
	Local cLoteOrig := cLote
	LOCAL cPadrao   := "530"
	Local nTotLtEZ  := 0
	Local nRecSeV	:= 0
	Local nRecSeZ	:= 0
	Local aCposDes  := {}
	Local nT 		:= 0
	Local aFlagCTB  := {}
	Local aDiario	:= {}
	Local nRecSE5   := 0
	Local nRecSe2   := 0
	Local nRecFK2   := 0 
	Local lAcessMul	:= .T.
	Local lAcessJur	:= .T.
	Local lAceDtBxa	:= .T.
	Local lAceDtDeb	:= .T.
	Local lAcessDes	:= .T.
	Local lRuSkipChk :=.F. 
	Local aCtBaixa  := {}
	Local lUsaFlag  := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/ )

	Default cLanca    := "N"

	//-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lF080DCNB := ExistBlock("F080DCNB")
    DEFAULT nTamLote  := TamSX3("E2_LOTE")[1]
	
	If GetMv("MV_LOTEFIN") == "S" .And. !Empty( cLoteFin ) .And. nTamLote > 4 .And. nTamLote <= TamSX3("CT2_LOTE")[1]
		cLote := cLoteFin
	Endif
	
	dbSelectArea("SE2")
	SE2->(dbGotop())

	While !SE2->(Eof())
		If SE2->E2_FILIAL != cFilial
			SE2->(dbSkip())
			Loop
		Endif
		
		SE2->(dbskip())
		nX	 := SE2->(Recno())
		SE2->(dbSkip(-1))
		
		//se vier da integracao Protheus X Tin nao e permitido alterar na baixa
		If AllTrim(SE2->E2_ORIGEM)=="FINI055" .And. !lF080Auto
			lAcessMul := .F.
			lAcessDes := .F.
			lAcessJur := .F.
			lAceDtBxa:= .F.
			lAceDtDeb := .F.
		
		//Ponto de entrada para desabilitar campos de Multa, Juros ou Descontos, data de baixa, data de debito
		ElseIf lF080DCNB
			aCposDes := ExecBlock("F080DCNB",.F.,.F.)
			If Len(aCposDes) > 0
				IF (nT := ascan(aCposDes,'MULTA')) > 0
					lAcessMul := .F.
				Endif
				IF (nT := ascan(aCposDes,'DESCONTO')) > 0
					lAcessDes := .F.
				Endif
				IF (nT := ascan(aCposDes,'JUROS')) > 0
					lAcessJur := .F.
				Endif
				IF (nT := ascan(aCposDes,'DATABAIXA')) > 0
					lAceDtBxa := .F.
				Endif
				IF (nT := ascan(aCposDes,'DATADEBITO')) > 0
					lAceDtDeb := .F.
				Endif
			Endif
		Endif

		Fa080TitW(cMarca,@nTotal,@nHdlPrv,@lHdlPrv,@lPadraoBx,@cArquivo,@cPadrao,@nTotLtEZ,lAcessMul,lAcessJur,lAcessDes,lAceDtBxa,lAceDtDeb,@aCtBaixa,@aFlagCTB)
	EndDo
	
	//Avisa quando totais nao baterem
	If lIsRussia
		lRuSkipChk := nTotGer==0
	Endif
	IF Str(nTotGer,16,2) != Str(nTotAGer,16,2) .and. !lRuSkipChk
		Help(" ",1,"TOTGERAL",, STR0122 +;
		Space(1) + Trans(nTotGer, "@E 99,999,999,999.99") +;
		Chr(10)  + STR0123 +;
		Space(1) + Trans(nTotAGer, "@E 99,999,999,999.99"), 4, 0)
	Elseif Str(nTotDesp,16,2) != Str(nTotADesp,16,2)
		Help(" ",1,"TOTDESP",, STR0122 +;
		Space(1) + Trans(nTotDesp, "@E 99,999,999,999.99") +;
		Chr(10)  + STR0123 +;
		Space(1) + Trans(nTotADesp, "@E 99,999,999,999.99"), 4, 0)
	Elseif Str(nTotDesc,16,2) != Str(nTotADesc,16,2)
		Help(" ",1,"TOTDESC",, STR0122 +;
		Space(1) + Trans(nTotDesc, "@E 99,999,999,999.99") +;
		Chr(10)  + STR0123 +;
		Space(1) + Trans(nTotADesc, "@E 99,999,999,999.99"), 4, 0)
	Elseif Str(nTotMul,16,2) != Str(nTotAMul,16,2)
		Help(" ",1,"TOTMULT",, STR0122 +;
		Space(1) + Trans(nTotMul, "@E 99,999,999,999.99") +;
		Chr(10)  + STR0123 +;
		Space(1) + Trans(nTotAMul, "@E 99,999,999,999.99"), 4, 0)
	Elseif Str(nTotJur,16,2) != Str(nTotAJur,16,2)
		Help(" ",1,"TOTJUROS",, STR0122 +;
		Space(1) + Trans(nTotJur, "@E 99,999,999,999.99") +;
		Chr(10)  + STR0123 +;
		Trans(nTotAJur, "@E 99,999,999,999.99"), 4, 1)
	Endif
	
	//Envia para Lancamento Contabil, se gerado arquivo
	IF nTotal > 0 .And. nHdlPrv > 0
		nRecSe2 := SE2->(RecNo())
		SE2->(DbGoto(0))
		
		nRecFK2 := FK2->(Recno())
		FK2->(DbGoto(0))		
		
		nRecSE5 := SE5->(Recno())
		SE5->(DbGoto(0))		
		
		DbSelectArea("SEV")
		nRecSeV := SEV->(RecNo())
		SEV->(DbGoto(0))
		
		DbSelectArea("SEZ")
		nRecSeZ := SEZ->(RecNo())
		SEZ->(DbGoto(0))
		
		If nTotAGer != 0
			VALOR      := nTotAGer - nTotLtEZ
			ABATIMENTO := 0
			
			//Zero as variáveis de impostos (Configurador de Tributos)
			FINVARCTB()
			
			nTotal += DetProva(nHdlPrv, cPadrao, "FINA080" /*cPrograma*/, cLote,/*nLinha*/,/*lExecuta*/,/*cCriterio*/,/*lRateio*/,;
					/*cChaveBusca*/,/*aCT5*/,/*lPosiciona*/,/*@aFlagCTB*/,/*aTabRecOri*/,/*aDadosProva*/)
			
			If nTotLtEZ > 0
				VALOR      := nTotLtEZ
				ABATIMENTO := 0
				
				nTotal += DetProva(nHdlPrv, "537" /*cPadrao*/, "FINA080" /*cPrograma*/, cLote,/*nLinha*/,/*lExecuta*/,/*cCriterio*/,;
									/*lRateio*/,/*cChaveBusca*/,/*aCT5*/,/*lPosiciona*/,/*@aFlagCTB*/,/*aTabRecOri*/,/*aDadosProva*/ )
			Endif
		Endif

		If UsaSeqCor()
			aAdd(aDiario, {"SE5", nRecSE5, cCodDiario, "E5_NODIA", "E5_DIACTB"})
		Else
			aDiario := {}
		EndIf
		
		//Efetiva Lançamento Contabil
		cA100Incl(cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, lDigita, lAglut, /*cOnLine*/, /*dData*/, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, aDiario)
		
		aFlagCTB := {}
		
		If LanceiCTB			
			/* Marca flag de contabilizacao da baixa nas FKs */
			If !Empty(aCtBaixa) .and. !lUsaFlag
				For nX := 1 to Len(aCtBaixa)
					If aCtBaixa[nX, ALIAS] == "FK2"
						dbSelectArea("FK2")
						FK2->(dbSetOrder(1))
						If FK2->(dbSeek( xFilial("FK2") + aCtBaixa[nX, IDORIG] ))
							RecLock("FK2",.F.)
							FK2->FK2_LA := "S"
							MsUnlock()
						EndIf
					ElseIf aCtBaixa[nX, ALIAS] == "FK5"
						dbSelectArea("FK5")
						FK5->(dbSetOrder(1))
						If FK5->(dbSeek( xFilial("FK5") + aCtBaixa[nX, IDORIG] ))
							RecLock("FK5",.F.)
							FK5->FK5_LA := "S"
							MsUnlock()
						EndIf
					Elseif aCtBaixa[nX, ALIAS] == "SE5"
						dbSelectArea("SE5")
						DbGoTo(aCtBaixa[nX, IDORIG])
						If SE5->(!BoF() .And. !EoF())
							RecLock("SE5",.F.)
							SE5->E5_LA := "S"
							MsUnlock()
						EndIf
					EndIf
				Next nX
			EndIf
		EndIf

		SE2->(dbGoTo(nRecSe2))
		SEV->(dbGoTo(nRecSeV))
		SEZ->(dbGoTo(nRecSeZ))
		DbSelectArea("SE5")
		SE5->(DbGoto(nRecSE5))
		FK2->(DbGoto(nRecFK2))
	Endif
	
	cLote := cLoteOrig
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc}fa080Cheq
Consistencia do numero do cheque
@author Wagner Xavier 
@since  23/03/1993
/*/
//-------------------------------------------------------------------
Function fa080Cheq(lHelp)
	Local cAlias	:= Alias()
	Local lRet		:= .T.

	DEFAULT lHelp := .T.

	IF Empty(cCheque) .or. SE2->E2_IMPCHEQ == "S"
		dbSelectArea(cAlias)
		Return(.T.) /*Function fa080Cheq*/
	Endif
	dbSelectArea("SEF")
	dbSetOrder(1)

	If Existblock("Fa080chq")
		lRet:=Execblock("Fa080chq",.F.,.F.)
	EndIf
	If lRet
		If SEF->( dbSeek(cFilial+cBanco+cAgencia+cConta+cCheque) )
			If Subs(cCheque,1,1) != "*"
				If lHelp
					Help(" ",1,"CHEQEXIST")
				Endif
				lRet:=.F.
			Else
				lRet:=.T.
			Endif
			If lRet
				lRet := VldUser("EF_NUM") // Chama a validacao de usuario
			Endif
			dbSelectArea(cAlias)
		EndIf
	EndIf

Return lRet  /*Function fa080Cheq*/

//-------------------------------------------------------------------
/*/{Protheus.doc}FA080ChecF
Retorna Expresao para Indice Condicional
@author Antonio Maniero Jr. 
@since  17/03/1994
/*/
//-------------------------------------------------------------------
Function FA080ChecF()
	Local cFiltro := ""
	Local lFunctionOrigemComex as Logical

	lFunctionOrigemComex := findfunction("comex.generics.filterLoteOrigemComex")

	cFiltro := 'E2_FILIAL=="'+xFilial("SE2")+'".And.'
	cFiltro += '!(E2_TIPO $ "'+MVPROVIS+"/"+MVPAGANT+"/"+MVABATIM+"/"+MV_CPNEG+'").and.'
	cFiltro += 'E2_NATUREZ>="'+cNatDe+'".and.E2_NATUREZ<="'+cNatAte+'".and.'
	cFiltro += 'DTOS(E2_VENCREA)>="'+DTOS(dVencDe)+'".and.DTOS(E2_VENCREA)<="'+DTOS(dVencAte)+'"'

	// Se trabalha com liberacao de pagto., filtra os registros que ultrapassem o valor
	// minimo
	If GetMv("MV_CTLIPAG")
		If TcSrvType() == "AS/400" .or. TcSrvType() == "iSeries"  //"iSeries" eh o retorno do Top4 para AS/400
			cFiltro += '.And. !(SE2->E2_DATALIB == CTOD("") .And. (SE2->E2_SALDO+SE2->E2_SDACRES-SE2->E2_SDDECRE)>'+Str(GetMV("MV_VLMINPG"),17,2)+')'
		Else
			cFiltro += '.And. !(Empty(SE2->E2_DATALIB).And.(SE2->E2_SALDO+SE2->E2_SDACRES-SE2->E2_SDDECRE)>'+Str(GetMV("MV_VLMINPG"),17,2)+')'
		Endif
	Endif

	If !Empty(cFil080)
		cFiltro := '(' +cFiltro+ ').and.(' +cFil080+')'
	Endif

	// Verifica se o titulo esta bloqueado - Gestao de Contratos
	If !Empty(SE2->(FieldPos("E2_MSBLQL")))
		cFiltro += ".And. E2_MSBLQL != '1'"
	EndIf

	// AAF - Titulos originados no SIGAEFF não devem ser alterados 
	if lFunctionOrigemComex
		cFiltro += comex.generics.filterLoteOrigemComex()
	else
		cFiltro += ".AND. !('SIGAEFF' $ E2_ORIGEM) "
	endIf

 	// Permite apenas baixa de títulos que não estejam em borderô.
	If mv_par04 == 2
		cFiltro += " .AND. Empty(E2_NUMBOR) "
	EndIf

	// Para o Brasil, apresenta somente os titulos cuja moeda e' a mesma do banco
	// selecionado para baixa.
	// Caso a moeda do banco estiver vazia ou caso o motivo de baixa nao movimente banco, considero apenas a moeda forte
	If FXMultSld()
		If SA6->A6_MOEDA > 1
			cFiltro += ".AND. E2_MOEDA == " + StrZero( SA6->A6_MOEDA, 2 ) + " "
			If cPaisLoc=="BRA"
				cFiltro+=" .and. Eval({||FXVldBxBco('"+cBanco+"','"+cAgencia+"','"+cConta+"',SE2->E2_NATUREZ, SE2->E2_MOEDA,.F.)}) "
			Endif
		Endif
	EndIf

	If TcSrvType() == "AS/400" .or. TcSrvType() == "iSeries"  //"iSeries" eh o retorno do Top4 para AS/400
		cFiltro := "("+cFiltro+").And.(E2_SALDO>0 .Or. E2_OK='xx')"
	Else
		cFiltro += " .And. E2_SALDO >0 "
	Endif

	//-----------------------------------------------------
	// Complemento de filtro Siafi
	//-----------------------------------------------------
	cFiltro += FinTemDH(.T. /*lFiltro*/,/*cAlias*/,.F. /*lHelp*/, .F./*lTop*/)

	//-----------------------------------------------------
	// Complemento de filtro Adiantamento N Moedas
	//-----------------------------------------------------
	cFiltro += FXNMoedas("2")

Return cFiltro /*Function FA080ChecF*/

//-------------------------------------------------------------------
/*/{Protheus.doc}FA080Estrang
Funcao utilizada para consistir o valor digitado em M.Forte 
@author Wilson Junior 
@since  20/05/1994
/*/
//-------------------------------------------------------------------
Function FA080Estrang(nTxMoeda AS NUMERIC, nTolerCp AS NUMERIC) AS LOGICAL
	Local lRet AS LOGICAL
	Local nValEstAnt AS NUMERIC

	lRet 		:= .F.
	nValEstAnt	:= 0

	DEFAULT nTxMoeda := 0
	DEFAULT nTolerCp := SuperGetMv("MV_TOLERCP",.F.,0)

	If ExistBlock("FA080CMI")
		ExecBlock("FA080CMI",.F.,.F.)
	Endif

    nValEstAnt := (nVA+nJuros+nMulta-nDescont+nOtrga+nImpSubst+nAcresc-nDecresc+nTolerCp)
	nValEstAnt := Round(nValEstrang - Round(NoRound(xMoeda(nValEstAnt,nMoedaBco,SE2->E2_MOEDA,,3,,nTxMoeda),3),2),2)
	IF nValEstAnt <= SE2->E2_SALDO
		lRet := .T.
	ElseIf cPaisLoc == "CHI"
		If Abs( nValEstAnt - SE2->E2_SALDO ) <= ( (1/(10**( MsDecimais(SE2->E2_MOEDA)-1)))/2 )
			lRet := .T.
		Endif
	Endif
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080GrVen
Funcao que grava os dados do VENDOR  
@author Pilar S. Albaladejo 
@since  19/01/1995
/*/
//-------------------------------------------------------------------
Function Fa080GrVen(cTitOrig, lPadraoVd, cLanca, aVendor, cOrigem, lUsaFlag )

	Local cAlias   := Alias()
	Local nRec     := 0
	Local cBcoVen  := ""
	Local cLojVen  := ""
	Local nMoeda   := 1
	Local cFilOrig := SE2->E2_FILORIG
	Local cKeyTit1 := ""
	Local cIDDOC   := ""	
	
	Default lUsaFlag := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/ )

	If cOrigem != Nil
		cFilOrig := cFilant
	EndIf

	DbSelectArea("SA6")
	SA6->(DbSeek(xFilial("SA6") + SE9->(E9_BANCO+E9_AGENCIA+E9_CONTA)))
	DbSelectArea("SA2")
	SA2->(dbSetOrder(1))

	cBcoVen := SA6->A6_CODFOR
	cLojVen := SA6->A6_LOJFOR
	nMoeda	:= SA6->A6_MOEDA

	If Empty(cBcoVen)
		cBcoVen := Padr(If(Empty(SA6->A6_COD), "000001", SA6->A6_COD), Len(SA2->A2_COD))
		cLojVen := Padr("01", Len(SA2->A2_LOJA))
	Endif

	If !SA2->(dbSeek(xFilial("SA2") + cBcoVen + cLojVen))
		RecLock("SA2",.T.)
		SA2->A2_FILIAL	:= xFilial("SA2")
		SA2->A2_COD		:= cBcoVen
		SA2->A2_LOJA	:= cLojVen
		SA2->A2_NOME	:= SA6->A6_NOME
		SA2->A2_END		:= Iif(Empty(SA6->A6_END),"...",SA6->A6_END)
		SA2->A2_MUN		:= Iif(Empty(SA6->A6_MUN),"...",SA6->A6_MUN)
		SA2->A2_EST		:= Iif(Empty(SA6->A6_EST),"SP",SA6->A6_EST)
		SA2->A2_NREDUZ	:= Iif(Empty(SA6->A6_NREDUZ),Subs(SA6->A6_NOME,1,20),SA6->A6_NREDUZ)
		MSUnlock()
	Endif

	If Valtype(aVendor ) == "A"
		cPrefV		:= aVendor[4]
		cNumV		:= aVendor[5]
		cParcV		:= aVendor[6]
		cTipV		:= aVendor[7]
		dDataVencV	:= aVendor[8]
		nTxAcresv	:= aVendor[9]
		cNaturV		:= aVendor[10]
		nValTitV	:= aVendor[11]

		cKeyTit1 := xFilial("SE2")+"|"+ cPrefV +"|"+ cNumV +"|"+ cParcV +"|"+ cTipV +"|"+ SA2->A2_COD +"|"+ cLojVen
		cIDDOC   := FINGRVFK7("SE2",cKeyTit1)
	Endif

	dbSelectArea("SE2")
	nRec := Recno()
	RecLock( "SE2", .T. )

	SE2->E2_FILIAL 	:= xFilial("SE2")
	SE2->E2_PREFIXO	:= cPrefV
	SE2->E2_NUM 	:= cNumV
	SE2->E2_PARCELA	:= cParcV
	SE2->E2_TIPO	:= cTipV
	SE2->E2_NOMFOR 	:= SA2->A2_NOME
	SE2->E2_EMIS1	:= dDatabase
	SE2->E2_VALOR	:= nValTitV
	SE2->E2_SALDO	:= nValTitV
	SE2->E2_VLCRUZ 	:= nValTitV
	SE2->E2_EMISSAO	:= dDataBase
	SE2->E2_VENCORI	:= dDataVencV
	SE2->E2_RATEIO 	:= "N"
	SE2->E2_LA		:= If(!lUsaFlag .And. lPadraoVd .And. cLanca == "S", cLanca, "N")	
	SE2-> E2_VENCTO 	:= dDataVencV
	SE2-> E2_VENCREA	:= DataValida(SE2->E2_VENCTO,.T.)
	SE2-> E2_FORNECE	:= SA2->A2_COD
	SE2-> E2_LOJA		:= cLojVen
	SE2-> E2_MOEDA		:= nMoeda
	SE2-> E2_NATUREZ	:= cNaturV
	SE2-> E2_MOVIMEN	:= dDataBase
	SE2-> E2_FILORIG	:= cFilOrig

	Fa080CalcV(nTxAcresv) // Funcao que calcula o valor do titulo de VENDOR
	SE2-> E2_ACRESC 	:= nValAcres
	SE2-> E2_SDACRES	:= nValAcres

	If cOrigem != Nil
		SE2->E2_ORIGEM := cOrigem
	Endif

	//Ponto de entrada para tratamento complementar a gravação do titulo de VENDOR
	If ExistBlock("F080VEND")
		ExecBlock("F080VEND",.F.,.F., { nRec } )
	Endif

	MSUnlock( )

	dbGoto( nRec )
	cTitOrig := cPrefV + cNumV + cParcV + cTipV + SA2->A2_COD
	dbSelectArea( cAlias )
	
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080CalcV
Funcao que calcula o valor do titulo de VENDOR  
@author Pilar S. Albaladejo 
@since  18/01/1995
/*/
//-------------------------------------------------------------------
Function Fa080CalcV(nTaxa)
	Local cAlias := Alias(), lRet := .T.

	If nTaxa == Nil
		nTaxa := 1
	Endif
	nValAcres := (SE2->E2_VALOR * (1 + (nTaxa / 100))) - SE2->E2_VALOR

	dbSelectArea(cAlias)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080VerVd
Funcao que verifica dados obrigatorios do vendor	  
@author Pilar S. Albaladejo 
@since  18/01/1995
/*/
//-------------------------------------------------------------------
Function Fa080VerVd()

	Local lErro := .F.
	Local lRet	:= .T.
	Local lF080VdOk := ExistBlock("F080VDOK")

	If Empty(cContrato)
		lErro := .T.
	ElseIf Empty(cNumV)
		lErro := .T.
	ElseIf Empty(cTipV)
		lErro := .T.
	ElseIf Empty(cNaturV)
		lErro := .T.
	ElseIf !lF080VdOk .and. Empty(nTxAcresV)
		lErro := .T.
	ElseIf Empty(dDataVencV)
		lErro := .T.
	Endif

	If lErro
		Help(" " , 1 , "FA080DADVEND")
		lRet := .F.
	Else
		If lF080VdOk
			lRet := ExecBlock("F080VDOK",.F.,.F.)
		Endif
	Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fa080digit
Funcao que permite ou nao a digitacao dos dados bancarios	  
@author Pilar S. Albaladejo 
@since  18/01/1995
/*/
//-------------------------------------------------------------------
function fa080digit()
	lRet := .t.
	If !MovBcoBx( cMotBx, .T. ) .or. SE2->E2_IMPCHEQ == "S" .or. lChqPre
		lRet := .f.
	Endif
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fa080Adiant
Processa baixa de adiantamento.	  
@author Vincius S. Barreira 
@since  26/10/1994
/*/
//-------------------------------------------------------------------
Function fa080Adiant( lPadrao, cLanca, nTxMoeda, lusaFlag , lMultNat )

	Local nTamSeq		:= TamSX3("E5_SEQ")[1]
	Local cSequencia	:= Replicate("0",nTamSeq)
	Local nMoedaBco := Max( MoedaBco(cBanco,cAgencia,cConta), 1 )
	Local nMoedaTit := SE2->E2_MOEDA
	Local nTxModBco := If( cPaisLoc<>"BRA", aTxMoedas[Max(nMoedaBco		,1)][2]	, 0 )
	Local nTxModTit := If( cPaisLoc<>"BRA", aTxMoedas[Max(SE2->E2_MOEDA	,1)][2]	, 0 )
	Local lAcreDecre := .F.
	Local cTipo := ALLTRIM(SE2->E2_TIPO)
	local cModalid := nil
	Local lBxDtFin	:= SuperGetMv("MV_BXDTFIN",,"1") == "2"

	// REESTRUTURACAO SE5
	Local oSubFK2	// BAIXAS A PAGAR
	Local oSubFK5	// MOVTO BANCARIO
	Local oSubFK6	// Valores acessórios
	Local cLog 		:= ""
	Local cCamposE5 := ""
	Local lRet := .T.
	Local nI := 0
	Local cChaveTit := ""
	Local cChaveFK7 := ""
	Local cIdFK2	:= ""
	Local nRecSE5	:= 0
	Local nCMBaixa 	:= 0
	Local cNatureza	:= SE2->E2_NATUREZ
	Local lEstorDP	:= (!lPaisMI .Or. SuperGetMv("MV_ESTORDP",.F.,"N") == 'S')
	Local cFunName	:= FunName()
	Local lfn080mFk2:= FindFunction("fn080mFk2")
	Local lfn080mFk5:= FindFunction("fn080mFk5")
	Local lfn080mFk6:= FindFunction("fn080mfk6")
	
	DEFAULT lMultNat  := .F.
	Default lUsaFlag  := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/ )
	DEFAULT nTxMoeda  := 0

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT _lTemMR	  := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
    DEFAULT lSE5FI080 := ExistBlock("SE5FI080")
    DEFAULT lSpbInUse := SpbInUse() .AND. VerCpoSPB()
    DEFAULT nTamHist  := TamSX3("E5_HISTOR")[1]

	If Type( "DDEBITO" ) == "U"
		dDebito := Iif( FwIsInCallStack( "FA450CMP" ) .And. !Empty( SE5->E5_DATA ), SE5->E5_DATA, dDataBase )
	EndIf

	If cPaisLoc == "MEX"
		MaFisIni(SE2->E2_FORNECE,SE2->E2_LOJA,"F","N","",,"",,,"","","","","","","","",,,,"","","",,,"",,,,"","","")
		cModalid := IIF(!empty(MaFisRet(,"NF_NATUREZA")),MaFisRet(,"NF_NATUREZA"),cNatureza)
	EndIf

	If cPaisLoc == "BRA"
		nTxModBco := nTxMoeda
	EndIf

	If MovBcoBx(cMotBx, .T.)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Estorna saldo bancario. 												 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AtuSalBco(cBanco,cAgencia,cConta,dBaixa,nValPgto,"+")
	Endif

	lAcreDecre := .T.

	//Obtém sequencia de baixa 
	cSequencia 	:= FaNxtSeqBx("SE2",.T.) 

	//Dados da tabela auxiliar com o código do título a pagar
	cChaveTit := xFilial("SE2", SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
	cChaveFK7 := FINBuscaFK7(cChaveTit, "SE2", SE2->E2_FILORIG)

	//Baixa de PA ou geração de Mov do mesmo não gera novo processo, utiliza o processo criado na inclusão
	If _lTemMR
		FKA->(dbSetOrder(3))
		If FKA->(MsSeek(xFilial("FKA") + "SE2" + cChaveFK7))
			lNewProc := .F.
			BxGerMovPA(.T.)
			_cTabOri := "SE2"
			_cIdOrig := cChaveFK7
		EndIf
	EndIf

	//Gera movimentacao bancaria a pagar - baixa do adiantamento
	//REESTRUTURACAO SE5
	//Carrego model de Bx Pagar
	If cPaisLoc=="BRA" .Or. lEstorDP
		oModelBxP:SetOperation( 3 ) //Inclusao
		oModelBxP:Activate()
		oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
		If lIsRussia .and. (Type("lF080Auto")<>"U" .and. lF080Auto) .AND.  (nT := aScan(aAutoCab,{|x| x[1]='AUTIDPROC'}) ) > 0
			oModelBxP:SetValue("MASTER","IDPROC",cIDProc)
		Else	
			oModelBxP:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo	
		EndIf
		oSubFK2  := oModelBxP:GetModel("FK2DETAIL")
		oSubFK3  := oModelBxP:GetModel("FK3DETAIL")
		oSubFK4  := oModelBxP:GetModel("FK4DETAIL")
		oSubFK5  := oModelBxP:GetModel("FK5DETAIL")
		oSubFK6  := oModelBxP:GetModel("FK6DETAIL")
		oSubFKA  := oModelBxP:GetModel("FKADETAIL")

		//Dados da tabela auxiliar com o código do título a pagar
		cIdFK2 	 := FWUUIDV4()

		For nI := 1 To 7
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza a Movimentacao Bancaria 							 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF nI == 1
				cCpoTp := "nValPgto"
				cTpDoc := Iif(MovBcoBx(cMotBx, .T.),"VL","BA")
				cHistMov := If(!Empty(cHist070),cHist070,OemToAnsi( STR0112 ))
			Elseif nI == 2
				cCpoTp := "nDescont"
				cTpDoc := "DC"
				cHistMov := OemToAnsi( STR0112 ) //"BAIXA DE ADIANTAMENTO"
				cCpoCalc := "nDescCalc"
			Elseif nI == 3
				nJuros := IIf(cPaisLoc<>"CHI",nJuros,nOtrga + nImpSubst)
				cCpoTp := "nJuros"
				cTpDoc := "JR"
				cHistMov := OemToAnsi( STR0112 ) //"BAIXA DE ADIANTAMENTO"
				cCpoCalc := "nJurosCalc"
			Elseif nI == 4
				cCpoTp := "nMulta"
				cTpDoc := "MT"
				cHistMov := OemToAnsi( STR0112 ) //"BAIXA DE ADIANTAMENTO"
				cCpoCalc := "nMultaCalc"
			Elseif nI == 5
				cCpoTp := IIf(cPaisLoc<>"CHI","nCM","nDifCambio")
				cTpDoc := "CM"
				cHistMov := OemToAnsi( STR0112 ) //"BAIXA DE ADIANTAMENTO"
				cCpoCalc := "nCMCalc"
			Elseif nI == 6
				cCpoTp := "nImpSubst"
				cTpDoc := "IS"
				cHistMov := OemToAnsi( STR0112 ) //"BAIXA DE ADIANTAMENTO"
				cCpoCalc := "nImpSubCalc"
			Elseif nI == 7
				cCpoTp	 := "nVA"
				cTpDoc	 := "VA"
				cHistMov := ""		// Valores Acessórios (histórico virá da FKD).
				cCpoCalc := "nVACalc"
			Endif

			cHistMov := SubStr(Alltrim(cHistMov),1,nTamHist)
			IF &cCpoTp != 0 .or. nI == 1

				lRet := Iif( lBxDtFin, DtMovFin(dDatabase,,"1"), .T.) 
				IF !lret
					return(.f.)
				Endif

				//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
				If !Empty(cCamposE5)
					cCamposE5 += "}|"
				Endif
				cCamposE5 += "{"
				
				cBenef := IIF(Empty(cBenef),SE2->E2_NOMFOR,cBenef)

				cBenef := NoAcento(strtran(cBenef,"'"," ")) //retirando " ' " para evitar error log na gravação da E5
				cBenef := NoAcento(strtran(cBenef,'"'," ")) //retirando ' " ' para evitar gravação em branco na E5
				cBenef := NoAcento(strtran(cBenef,'|'," ")) //retirando ' | ' para evitar travamento na gravação do model

				cCamposE5 += " {'E5_DTDIGIT' , dDataBase}"
				cCamposE5 += ",{'E5_PREFIXO' , SE2->E2_PREFIXO}"
				cCamposE5 += ",{'E5_NUMERO'  , SE2->E2_NUM}"
				cCamposE5 += ",{'E5_PARCELA' , SE2->E2_PARCELA}"
				cCamposE5 += ",{'E5_TIPO'    , SE2->E2_TIPO}"
				cCamposE5 += ",{'E5_FORNECE' , SE2->E2_FORNECE}"
				cCamposE5 += ",{'E5_CLIFOR'  , SE2->E2_FORNECE}"
				cCamposE5 += ",{'E5_LOJA'    , SE2->E2_LOJA}"
				cCamposE5 += ",{'E5_BENEF'   , '"+cBenef +"' }"
				If cPaisLoc == "BRA"
					cCamposE5 += ",{'E5_TPDESC'  , '"+cTpDesc+"' }"
				EndIf

				If nI = 5
					cCamposE5 += ",{'E5_IDENTEE'    , SE2->E2_IDENTEE}"
				Endif

				//Movimento principal (baixa e banco)
				If nI == 1

					nCMBaixa := IIf(cPaisLoc<>"CHI",nCM,nDifCambio)

					// Valores acessórios no registro principal da baixa.
					cCamposE5 += ",{'E5_VLJUROS' , "+cValToChar(nJuros)+" }"
					cCamposE5 += ",{'E5_VLMULTA' , "+cValToChar(nMulta)+" }"
					cCamposE5 += ",{'E5_VLCORRE' , "+cValToChar(nCMBaixa)+" }"
					cCamposE5 += ",{'E5_VLDESCO' , "+cValToChar(nDescont)+" }"
					cCamposE5 += ",{'E5_VLACRES' , "+cValToChar(nAcresc)+" }"
					cCamposE5 += ",{'E5_VLDECRE' , "+cValToChar(nDecresc)+" }"
					cCamposE5 += ",{'E5_BANCO'   , '"+cBanco   +"' }"
					cCamposE5 += ",{'E5_AGENCIA' , '"+cAgencia +"' }"
					cCamposE5 += ",{'E5_CONTA'   , '"+cConta   +"' }"
					cCamposE5 += ",{'E5_DTDISPO' , STOD('" + DTOS(dDebito) + "')}"
					cCamposE5 += Iif(cTpDoc == "VL", ",{'E5_FORNECE' , SE2->E2_FORNECE}", ",{'E5_FORNECE' , SE2->E2_FORNECE}")

					//Relacionamento FKA X FK2
					If !oSubFKA:IsEmpty()
						//Inclui a quantidade de linhas necessárias
						oSubFKA:AddLine()
						//Vai para linha criada
						oSubFKA:GoLine( oSubFKA:Length() )
					Endif
					oSubFKA:SetValue( 'FKA_IDORIG', cIdFK2 )
					oSubFKA:SetValue( 'FKA_TABORI', "FK2" )

					//Dados da baixa a pagar
					oSubFK2:SetValue( "FK2_DATA"   , dBaixa )
					oSubFK2:LoadValue( "FK2_NATURE" , IIF(cPaisLoc $ "MEX|PER" .AND. cTipo $ "PA" .AND. ((FUNNAME() == "MATA101N") .Or. (lChkLxProp .and. ChkLxProp("CancelacionAnticipo"))), cModalid , SE2->E2_NATUREZ) )
					oSubFK2:SetValue( "FK2_RECPAG" , IIF(cPaisLoc $ "MEX|PER" .AND. cTipo $ "PA" .AND. ((FUNNAME() == "MATA101N") .Or. (lChkLxProp .and. ChkLxProp("CancelacionAnticipo"))), "P" , "R" ) )
					oSubFK2:SetValue( "FK2_HISTOR" , cHistMov )
					oSubFK2:SetValue( "FK2_MOTBX"  , TrazCodMot(cMotBx) )
					oSubFK2:SetValue( "FK2_ORIGEM" , FunName() )
					oSubFK2:SetValue( "FK2_SEQ"    , cSequencia )
					oSubFK2:SetValue( "FK2_IDDOC"  , cChaveFK7 )
					oSubFK2:SetValue( "FK2_LOTE"   , cLoteFin )
					oSubFK2:SetValue( "FK2_TPDOC"  , cTpDoc )
					oSubFK2:SetValue( "FK2_CCUSTO" , SE2->E2_CCUSTO )
					oSubFK2:SetValue( "FK2_DOC"    , If(Empty(cNumBor),SE2->E2_NUMBOR,cNumBor) )	// Vem do Fina240()
					oSubFK2:SetValue( "FK2_FILORI" , SE2->E2_FILORIG )
					oSubFK2:SetValue( "FK2_AUTBCO" , cAutentica )
					oSubFK2:SetValue( "FK2_MOEDA" , StrZero(nMoedaBco,2) )
					oSubFK2:SetValue( "FK2_MULNAT", If(lMultNat,"1","2"))
					If lIsRussia .AND. Type("cOrdPag") == "C" //Used to link the writeoff to that especific payment order.
						oSubFK2:SetValue( "FK2_ORDREC", cOrdPag)
					Endif

					If !lUsaFlag
						oSubFK2:SetValue( "FK2_LA" , If( lPadrao .And. ( cLanca == "S" ), "S", "N" ) )
					Endif

					If ( cPaisLoc <> "BRA" )
						If lPaisMI .And. (cFunName $ "FINA080|FINA086") .And. lfn080mFk2
							fn080mFk2(@oSubFK2,cCpoTp,nMoedaBco,nMoedaTit,nTxModTit,nTxModBco)//actualiza FK2_VALOR y FK2_VLMOE2 (fina086)
						Else
							oSubFK2:SetValue( "FK2_VALOR" , xMoeda( &cCpoTp, 1, nMoedaBco,,,, nTxModBco ) )
							oSubFK2:SetValue( "FK2_VLMOE2", xMoeda( &cCpoTp, 1, nMoedaTit,,,, nTxModTit ) )
						EndIf
						oSubFK2:SetValue( "FK2_TXMOED", nTxModBco )
					Else
						oSubFK2:SetValue( "FK2_VALOR" , &cCpoTp )
						oSubFK2:SetValue( "FK2_TXMOED", nTxModBco )
						If nValEstrang != 0 .and. nI == 1  // VL ou BA
							oSubFK2:SetValue( "FK2_VLMOE2", nValEstrang )
						Else
							oSubFK2:SetValue( "FK2_VLMOE2", xMoeda(&cCpoTp,nMoedaBco,SE2->E2_MOEDA,,,,nTxMoeda) )
						EndIf
					EndIf

					// Gravacao de dados complementares da baixa
					If lSE5FI080
						cCamposE5 := ExecBlock('SE5FI080',.f.,.f.,{cCamposE5,oSubFK2})
					EndIf

					//Dados do Movimento
					If cTpDoc == "VL"	//Se movimenta banco

						//Relacionamento FKA X FK5
						If !oSubFKA:IsEmpty()
							//Inclui a quantidade de linhas necessárias
							oSubFKA:AddLine()
							//Vai para linha criada
							oSubFKA:GoLine( oSubFKA:Length() )
						Endif
						oSubFKA:SetValue( 'FKA_IDORIG', FWUUIDV4() )
						oSubFKA:SetValue( 'FKA_TABORI', "FK5" )

						//Dados do movimento bancario
						oSubFK5:SetValue( "FK5_RECPAG" , IIF(cPaisLoc $ "MEX|PER" .AND. cTipo $ "PA" .AND. FUNNAME() == "MATA101N", "P" , "R" ) )
						oSubFK5:SetValue( "FK5_HISTOR" , cHistMov) //"BAIXA DE ADIANTAMENTO"
						oSubFK5:SetValue( "FK5_DATA"   , dBaixa )
						oSubFK5:SetValue( "FK5_DTDISP" , dDebito )
						oSubFK5:LoadValue( "FK5_NATURE" , IIF(cPaisLoc $ "MEX|PER" .AND. cTipo $ "PA" .AND. FUNNAME() == "MATA101N", cModalid , SE2->E2_NATUREZ) )
						oSubFK5:SetValue( "FK5_BANCO"  , cBanco )
						oSubFK5:SetValue( "FK5_AGENCI" , cAgencia )
						oSubFK5:SetValue( "FK5_CONTA"  , cConta )
						oSubFK5:SetValue( "FK5_NUMCH"  , cCheque )
						oSubFK5:SetValue( "FK5_SEQ"    , cSequencia )
						oSubFK5:SetValue( "FK5_MOEDA"  , StrZero(SE2->E2_MOEDA,2) )
						oSubFK5:SetValue( "FK5_VLMOE2" , SE2->E2_VALOR )
						oSubFK5:SetValue( "FK5_ORIGEM" , FunName() )
						oSubFK5:SetValue( "FK5_TPDOC"  , cTpDoc )
						oSubFK5:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
						oSubFK5:SetValue( "FK5_DOC"    , If(Empty(cNumBor),SE2->E2_NUMBOR,cNumBor) )	// Vem do Fina240()
						oSubFK5:SetValue( "FK5_FILORI" , SE2->E2_FILORIG )
						oSubFK5:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
						oSubFK5:SetValue( "FK5_LOTE"   , cLoteFin )

						If ( cPaisLoc <> "BRA" )
							If lPaisMI .And. (cFunName $ "FINA080|FINA086") .And. lfn080mFk5
								fn080mFk5(@oSubFK5,cCpoTp,nMoedaBco,nMoedaTit,nTxModTit,nTxModBco,nJuros)//actualiza FK5_VALOR y FK5_VLMOE2 (fina086)
							Else
								oSubFK5:SetValue( "FK5_VALOR" , xMoeda( nJuros, 1, nMoedaBco,,,, nTxModBco ))
								oSubFK5:SetValue( "FK5_VLMOE2", xMoeda( nJuros, 1, nMoedaTit,,,, nTxModTit ))
							EndIf
							oSubFK5:SetValue( "FK5_TXMOED", nTxModBco )
						Else
							oSubFK5:SetValue( "FK5_VALOR" , &cCpoTp )
							oSubFK5:SetValue( "FK5_MOEDA" , StrZero(nMoedaBco,2) )
							oSubFK5:SetValue( "FK5_TXMOED", nTxModBco )
							If nValEstrang != 0
								oSubFK5:SetValue( "FK5_VLMOE2", nValEstrang )
							Else
								oSubFK5:SetValue( "FK5_VLMOE2", xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,,,,nTxMoeda) )
							EndIf
						EndIf

						If lSpbInUse
							oSubFK5:SetValue( "FK5_MODSPB" , cModSpb )
						Endif

						If !lUsaFlag
							oSubFK5:SetValue( "FK5_LA" , If( lPadrao .And. ( cLanca == "S" ), "S", "N" ) )
						Endif

						If oSubFKA:Length() > 1
							oSubFKA:GoLine(1)
						EndIf
					Else
						cCamposE5 += ",{'E5_BANCO'   , '"+cBanco   +"' }"
						cCamposE5 += ",{'E5_AGENCIA' , '"+cAgencia +"' }"
						cCamposE5 += ",{'E5_CONTA'   , '"+cConta   +"' }"
						cCamposE5 += ",{'E5_NUMCHEQ' , '"+cCheque  +"' }"
						cCamposE5 += ",{'E5_DTDISPO' , STOD('" + DTOS(dDebito) + "')}"
					Endif
				Else
					// Grava valores acessórios (FKD).
					If cTpDoc == "VA" .and. nVA != 0
						FSetFK6FKD(oSubFK6,cChaveFK7,cIdFK2)
					Else
						If !oSubFK6:IsEmpty()
							//Inclui a quantidade de linhas necessárias
							oSubFK6:AddLine()

							//Vai para linha criada
							oSubFK6:GoLine( oSubFK6:Length() )
						Endif

						// Grava valores acessórios.
						oSubFK6:SetValue( "FK6_VALMOV" , &cCpoTp )
						oSubFK6:SetValue( "FK6_VALCAL" , &cCpoCalc )
						oSubFK6:SetValue( "FK6_TPDESC" , If(cTpDesc == 'C',"1","2" ))
						oSubFK6:SetValue( "FK6_TPDOC"  , cTpDoc )
						oSubFK6:SetValue( "FK6_RECPAG" , "P" )
						oSubFK6:SetValue( "FK6_TABORI" , "FK2" )
						oSubFK6:SetValue( "FK6_HISTOR" , cHistMov )
						oSubFK6:SetValue( "FK6_IDORIG" , cIdFK2)
						If lPaisMI .And. lfn080mFk6
							fn080mFk6(@oSubFK6, &cCpoTp, SE2->E2_MOEDA, nMoedaBco, nTxMoeda, nTxModBco, cTpDoc)
						EndIf
					Endif

					// Gravacao de dados complementares da baixa
					If lSE5FI080
						cCamposE5 := ExecBlock('SE5FI080',.f.,.f.,{cCamposE5,oSubFK6})
					EndIf
				Endif

				//---------------------------------------------------------
				// Gravação de Dados Complementares SE5 para: Pagamentos
				//---------------------------------------------------------
				If ExistBlock("FA080ADTSE5")
					ExecBlock("FA080ADTSE5",.F.,.F.)
				EndIf
			Endif
		Next nI

		If lRet
			cCamposE5 += "}"
			oModelBxP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
			//Grava os dados
			If oModelBxP:VldData()
				oModelBxP:CommitData()
				nRecSE5 := oModelBxP:GetValue("MASTER","E5_RECNO")
				SE5->(dbGoTo(nRecSE5))
			Else
				lRet := .F.
				cLog := cValToChar(oModelBxP:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelBxP:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelBxP:GetErrorMessage()[6])

				Help( ,,"M020VLDA1",,cLog, 1, 0 )
			Endif
		Endif
		oModelBxP:DeActivate()
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080DtVen
Valida a Data de Vencimento do VENDOR	  
@author Pilar S. Albaladejo 
@since  24/01/1995
/*/
//-------------------------------------------------------------------
Function Fa080DtVen(dData)
	Local lRet := .T.

	If dData < dDataBase
		Help(" ",1,"FA080DTVEN")
		lRet := .F.
	Endif
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080Corr
Sugere o valor da corr. monetaria p/ titulos <> moeda 1	  
@author Pilar S. Albaladejo 
@since  30/01/1996
/*/
//-------------------------------------------------------------------
Function Fa080Corr(nEstOriginal as Numeric, nTxMoeda as Numeric) as Logical
	Local cFunName As Character
	Local nValor1 as Numeric 
	Local cAlias as Character   
	Local lF080CM as Logical
	Local nBaseCorrecao as Numeric
	Local nCasDec as Numeric
	Local cTipoCm as Character   
	Local lMoedaBco as Logical 
	Local lOrigem as Logical
	Local lGerCM as Logical
	Local lATxMoeda as Logical
	Local dDataCot  as Date 
	Local nTaxaCorr as Numeric
	Local lFunName as Logical
	Local lTitMoed as Logical
	Local lUsaVlrOri As Logical	
	
	Default nTxMoeda     := 0
	Default nEstOriginal := nValEstrang
    Default lFina450     := FwIsInCallStack("FINA450")
	Default __lCpoJuro   := .F.
	Default __lCpoMult   := .F.
	Default __lCpoDesc   := .F.
	Default __lTxMoeda   := .F.
	
	cFunName      := Upper(AllTrim(FunName()))
	nValor1       := 0 
	cAlias        := Alias()
	lF080CM       := ExistBlock("F080CM")
	nBaseCorrecao := 0
	nCasDec       := TamSx3("E2_TXMOEDA")[2]
	cTipoCm       := SuperGetMv("MV_TIPOCM", .T., "T") 
	lMoedaBco     := Type("nMoedaBco") == "U"
	lOrigem       := (FwIsInCallStack('FINA430') .Or. FwIsInCallStack('FINA750'))
	lGerCM        := Iif(cPaisLoc == "BRA", SuperGetMv("MV_CALCCM", .T., "N") == "S", .T.)
	lATxMoeda     := Type("aTxMoedas") == "A" .And. Len(aTxMoedas) >= SE2->E2_MOEDA
	dDataCot      := SE2->E2_EMISSAO
	nTaxaCorr     := SE2->E2_TXMOEDA
	lFunName      := cFunName $ "FINA080|FINA750|EICAP100|EECAF200|EICAP100|EFFEX400|EFFEX401"
	lTitMoed      := !lMoedaBco .And. SE2->E2_MOEDA > 1 .And. nMoedaBco > 1 .And. SE2->E2_MOEDA <> nMoedaBco
	lFunName      := Iif(!lFunName, lFina450, lFunName)
	lOrigem       := Iif(!lOrigem, lFina450, lOrigem)
	lUsaVlrOri    := .F.
	
	If cTipoCm == "O" // Pelo Original (O)
		nBaseCorrecao := nEstOriginal
	Else //Pelo Total (T)
		nBaseCorrecao := nValEstrang 
	EndIf
	
	If cPaisLoc <> "BRA"
		nTxMoeda := IF((SE2->E2_MOEDA <= 0 .Or. SE2->E2_MOEDA > Len(aTxMoedas)), 1, aTxMoedas[SE2->E2_MOEDA][2])		
	ElseIf cFunName $ "FINA080|FINA750" .OR. (Type("lF080Auto")<>"U" .and. lF080Auto)
		lUsaVlrOri := (cTipoCm == "T" .And. (__lCpoJuro .Or. __lCpoMult .Or. __lCpoDesc .Or. __lTxMoeda ))
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula o valor na moeda escolhida na data da ultima variacao   ³
	//³ ou na data de emissao (caso nao tenha sofrido ainda nenhuma	    ³
	//³ variacao.														³
	//³ Calcula o valor na moeda escolhida para a database.				³
	//³ Subtrai um valor do outro para apurar a variacao. 				³
	//³ A Correcao pode ser parametrizada para ser calculada pelo Origi-³
	//³ nal ou pelo Total (Parametro MV_TIPOCOM)           				³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE2")
	
	If Round(nBaseCorrecao,2) == Round(SE2->E2_VALOR,2) .And. Empty(SE2->E2_DTVARIA)
		nValor1 := SE2->E2_VLCRUZ
	Else
		If !Empty(SE2->E2_DTVARIA)
			dDataCot  := SE2->E2_DTVARIA
			nTaxaCorr := SE2->E2_TXMDCOR
		EndIf
		
		If lUsaVlrOri
			nValor1 := xMoeda(nEstOriginal, SE2->E2_MOEDA, 1, dDataCot, nCasDec, nTaxaCorr)
			nValor1 := ((Round(nValor1, 2) + nJuros + nMulta) - nDescont)
		Else
			nValor1 := xMoeda(nBaseCorrecao, SE2->E2_MOEDA, 1, dDataCot, nCasDec, nTaxaCorr)
		EndIf
	EndIf
	
	If (!lTitMoed .And. lFunName) .Or. !(SE2->E2_MOEDA == 1 .And. lATxMoeda)
		If __nTxTitBx > 0 // Taxa para baixa pode ser diferente da E2_TXMOEDA (SIGAEIC manda por execauto)
			nValorM := xMoeda(nBaseCorrecao, SE2->E2_MOEDA, 1, dBaixa, nCasDec, __nTxTitBx 						, nTxMoeda)
		Else		
			If lUsaVlrOri
				nValorM := xMoeda(nEstOriginal, SE2->E2_MOEDA, 1, dBaixa, nCasDec, Iif(lTitMoed, SE2->E2_TXMOEDA, nTxMoeda))
				nValorM := ((Round(nValorM, 2) + nJuros + nMulta) - nDescont)
			Else			
				nValorM := xMoeda(nBaseCorrecao, SE2->E2_MOEDA, 1, dBaixa, nCasDec, Iif(lTitMoed, SE2->E2_TXMOEDA	, nTxMoeda))
			EndIf
		EndIf
	Else
		nValorM := xMoeda(nBaseCorrecao, SE2->E2_MOEDA, 1, dBaixa, nCasDec, aTxMoedas[SE2->E2_MOEDA][2])
	EndIf
	
	If "SIGAEIC" $ UPPER(SE2->E2_ORIGEM) .And. Type("nValEIC") <> "U"
		nValEIC := nValorM
	Endif
	
	//Verifica atraves do parametro MV_CALCCM se sera calculada a correcao monetaria.
	//Caso o parametro nao exista, sera assumido "S", O PE F080CM serve para calculo alternativo da CM
	If lGerCM .And. ((!lMoedaBco .And. SE2->E2_MOEDA > 1 .And. SE2->E2_MOEDA <> nMoedaBco) .Or. (lMoedaBco .And. SE2->E2_MOEDA > 1 .And. lOrigem))
		nCM := Round(nValorM, 2) - Round(nValor1, 2)
		
		If lF080CM
			nCM := ExecBlock("F080CM",.F.,.F.)
		EndIf
	Else
		nCM := 0
	Endif
	
	If !lF080CM .and. nCM != 0 .And. AllTrim(SE2->E2_ORIGEM) == "MATA100"
		If ((nTxMoeda == SE2->E2_TXMOEDA .And. SE2->E2_TXMOEDA > 0) .Or. RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA) == nTxMoeda .and. SE2->E2_TXMOEDA == 0 ) .And. nTaxaCorr == 0 
			nCM := 0
		EndIf
	EndIf
	
	If cPaisLoc =="CHI" .And. Type("oDifCambio") == "O"
		nDifCambio := (nValPgto -(nBaseCorrecao * (SE2->E2_VLCRUZ/SE2->E2_VALOR) ) )
		oDifCambio:Refresh()
	EndIf
	
	dbSelectArea(cAlias)
	nCMCalc := IIf(cPaisLoc <> "CHI", nCM, nDifCambio)
	__lCpoJuro := .F.
	__lCpoMult := .F.
	__lCpoDesc := .F.
	__lTxMoeda :=.F.
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc}fA080TitW
Função utilizada para Baixa de Titulos - Windows 	  
@author Wagner Xavier 
@since  26/05/1992
/*/
//-------------------------------------------------------------------
Function Fa080TitW(cMarca,nTotal,nHdlPrv,lHdlPrv,lPadraoBx,cArquivo,cPadrao,nTotLtEZ,lAcessMul,lAcessJur,lAcessDes,lAceDtBxa,lAceDtDeb,aCtBaixa,aFlagCTB )
	
	Local lPanelFin := IsPanelFin()
	Local nOpca
	LOCAL lMovBco  	:= .T.
	LOCAL lBaixou  	:= .F.
	LOCAL oDlgLote
	LOCAL oTitulo
	LOCAL oParcela
	Local oPrefixo
	Local oNomeFor
	LOCAL oBaixa
	LOCAL oHist070
	LOCAL oMotBx
	LOCAL oValor
	LOCAL oTotAbat
	LOCAL oParciais
	LOCAL oDescont
	LOCAL oMulta
	LOCAL oJuros
	LOCAL oBenef
	LOCAL oAcresc
	LOCAL oDecresc
	Local nSalvRec  := RecNO( )
	LOCAL cNomeFor
	LOCAL cParcela
	LOCAL cMoeda
	LOCAL nValLiq  := 0
	LOCAL aMotBx	:= ReadMotBx()
	LOCAL aDescMotBx := {}
	Local aCmc7:={}
	LOCAL aModalSPB := {"1=TED","2=CIP","3=COMP"}
	LOCAL oModSpb
	Local nTxMoeda := 0
	Local nUltLin
	Local oMultNat
	Local lMultNat := .F.
	Local nTolerCp := SuperGetMv("MV_TOLERCP",.F.,0)
	Local nI := 0
	Local nLinha := 0
	LOCAL lFa080Lt := Existblock("FA080LT")
	Local dDataCan := CTOD("")
	Local lIRPFBaixa := .f.
	Local lAcessImp:= .T.
	Local lCalcIssBx :=	IsIssBx("P")
	Local cTipo
	Local oTipo
	Local nCentMd1	:= MsDecimais(1)
	Local nPgtoIRRF  := 0
	Local lCarret     := .F.
	Local lEmBordero	:= .F.
	Local lInssBx 	:=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
	Local nMinINS1 	:= SuperGetMv("MV_MININSS",.F.,0)
	Local nLimInss 	:= GetMv("MV_LIMINSS",.F.,0)
	Local nMinINS2 	:= SuperGetMv("MV_VLRETIN",.F.,0)
	//Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
	Local lInsPub 	:=	SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And. nLimInss == 0 .And. nMinINS2 == 0 
	Local oInss		:= NIL
	Local aPcc		:= {}
	Local nSalImp	:= 0
	Local aButtons	:= {}
	Local lOFINI055	:= .F.
	Local oMyBar	:= NIL
	Local oFont24	:= TFont():New("Arial",10,24,,.F.,,,,.T.,.F.)
	Local oTxMoeda
	Local aTitCalc	:= {}
	Local lRetBor   := .T.

	cBenef	:= CriaVar("E5_BENEF")

	PRIVATE nBaseIrpf := 0
	PRIVATE lUsaCmc7 := .F., lChqPre := .F.
	PRIVATE oVlEstrang
	PRIVATE oCM
	PRIVATE oValPgto
	Private oPis
	Private oCofins
	Private oCsll
	Private oIrrf
	Private oIss
	PRIVATE aDadosRef := Array(7)
	PRIVATE aDadosRet := Array(7)
	PRIVATE aRecnosSE2 := {}
	PRIVATE nOldValPgto := 0
	Private nBaseIns	:= 0 //Inss Baixa
	Private nVretInss	:= 0
	Private aRecnoINSS	:= {}
	Private aBordINSS	:= {}
	Private cPretIns	:= ""
	Private nInss		:= 0
	Private nVlMPub 	:= SuperGetMv("MV_VLMPUB" ,.T.,10)
	PRIVATE nValTt  := 0
	PRIVATE aDadosIr := Array(3)		//IRRF na baixa
	Private lEmpPub := IsEmpPub()
	Private lAplMinP := .F.
	Private nOldTxMoed := 0
	
	
	aFill(aDadosIr,0)
	aFill(aDadosRef,0)
	aFill(aDadosRet,0)

	DEFAULT lAcessMul	:= .T.
	DEFAULT lAcessJur	:= .T.
	DEFAULT lAcessDes	:= .T.
	DEFAULT lAceDtBxa:= .T.
	DEFAULT lAceDtDeb := .T.
	DEFAULT aCtBaixa := {} 
	DEFAULT aFlagCTB := {}

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT _lTemMR	  := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
    DEFAULT lFa080PCC := ExistBlock("FA080PCC")
    DEFAULT lImp10925 := ExistBlock("FA080IMP")
    DEFAULT lPCCBaixa := (SuperGetMv("MV_BX10925",.T.,"2") == "1")
    DEFAULT lSpbInUse := SpbInUse() .AND. VerCpoSPB()
	DEFAULT lFA080ACES := ExistBlock("FA080ACES")

	If (ExistBlock( "FA080CMC" ) )
		lUsaCmc7:=ExecBlock("FA080CMC",.F.,.F.)
	Endif

	IF ExistBlock("F080MNAT")
		lMultNat := ExecBlock("F080MNAT",.F.,.F.)
	Endif

	//se estiver sendo chamado via rotina automática a partir da compensação entre carteiras nao deve processar ISS E IR
	If !_lIssMR .And. !Funname() == "FINA450" .and. (Type("lF080Auto")<>"U" .and. lF080Auto)
		lCalcIssBx := .F.
	EndIf

	//Retorna o Array aDescMotbx contendo apenas a descricao do motivo das Baixas
	If len( aDescMotbx ) ==0
		For NI := 1 to Len(aMotBx)
			If Substr(aMotBx[nI],34,01) == "A" .or. Substr(aMotBx[nI],34,01) =="P"
				AADD( aDescMotbx,Substr(aMotBx[nI],07,10))
			EndIf
		Next
	EndIf

	While !Eof()
		If SE2->E2_OK != cMarca
			dbSKip()
			Loop
		Else
			Exit
		EndIf
	EndDo

	//Se não selecionou nenhum titulo para baixar, retorna sem fazer nada.
	IF SE2->(EOF())
		RETURN lBaixou
	ENDIF

	// Se for um titulo de adiantamento, verifica se existem cheques nao liberados, pois se existir, nao permitir a baixa
	// Isso ocorre quando o parametro MV_LIBCHEQ esta igual a N, foi gerado um cheque para o adiantamento e este
	// ainda nao foi liberado
	If (Type('lF080Auto') =='U' .or. ! lF080Auto) .And.;
		Alltrim(SE2->E2_TIPO) $ MVPAGANT
		SEF->(DbSetOrder(3))
		SEF->(MsSeek(xFilial("SEF")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+Pad(E2_NUMBCO,Len(SEF->EF_NUM)))))
		If SEF->EF_LIBER == "N"
			Help(" ",1,"NOCHQADT")
			Return lBaixou
		Endif
	Endif

	//Posiciona Fornecedor no SA2
	dbSelectArea("SA2")
	SA2->(dbSeek(xFilial("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA))

	lIRPFBaixa := FA080IRPF()
	lIRProg := IIf( cPaisLoc == "BRA", IIf(!Empty(SA2->A2_IRPROG), SA2->A2_IRPROG, "2"), "2")

	If SA2->A2_MINPUB == "2"
		lAplMinP := .T.
	EndIf

	// Posiciona na Natureza do titulo
	DbSelectArea("SED")
	SED->( DbSetOrder(1) )
	SED->( DbSeek(xFilial("SED") + SE2->E2_NATUREZ) )

	dbSelectArea("SE2")

	//Carrega Variaveis da Baixa
	nSalvRec := RecNo()
	lEmBordero:= F080EmBord() // Melhoria DSERFINP-10020
	cTitulo  := SE2->E2_PREFIXO + " " + SE2->E2_NUM+ " " + SE2->E2_PARCELA
	cParcela := SE2->E2_PARCELA
	dEmissao := SE2->E2_EMISSAO
	dVencRea := SE2->E2_VENCREA
	cTipo    := SE2->E2_TIPO
	cNomeFor := SE2->E2_FORNECE + " - " + Subst(SA2->A2_NOME,1,40)
	cHist    := SE2->E2_HIST
	dBaixa   := CriaVar("E2_BAIXA")
	dDebito  := dDatabase

	dDataCan	:= SE2->E2_DATACAN //FRS - Sit. Titulo

	If cPaisLoc == "BRA"
		nTxMoeda	 := If(SE2->E2_MOEDA > 1,If(SE2->E2_TXMOEDA > 0, SE2->E2_TXMOEDA,RecMoeda(dBaixa,SE2->E2_MOEDA)),0)
	Endif
	dDtCredito  := dDataBase
	If SE2->E2_IMPCHEQ == "S"  // Cheque s/ Titulo
		cCheque		:= SE2->E2_NUMBCO
	Else
		cCheque		:= CRIAVAR("E2_NUMBCO")
	Endif
	cHist070	:= Criavar("E5_HISTOR")		//Inicilizador padrao
	If Empty(cHist070)
		cHist070 := OemToAnsi(STR0007)+Space(Len(cHist070)-24)  // "Valor recebido s/ T¡tulo"
	Endif
	cMotBx		:= aDescMotBx[nFirstRsn] 	//NORMAL
	nValor		:= SE2->E2_VALOR
	nTotAbat	:= SumAbatPag(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_FORNECE,SE2->E2_MOEDA,"S",dBaixa,SE2->E2_LOJA)
	dbGoto(nSalvRec)
	nParciais	:= SE2->E2_VALOR-SE2->E2_SALDO
	nAcrescF 	:= SE2->E2_SDACRES
	nDecrescF	:= SE2->E2_SDDECRE
	nAcresc		:= Round(Noround(xMoeda(SE2->E2_SDACRES,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
	nDecresc	:= Round(Noround(xMoeda(SE2->E2_SDDECRE,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)

	nValTot	     := SE2->E2_VLCRUZ
	nValEstrang  := SE2->E2_SALDO-nTotAbat-SE2->E2_SDACRES+SE2->E2_SDDECRE
	nValOrig     := SE2->E2_SALDO-nTotAbat

	// Para titulos de vendor antigos
	If STR(SE2->E2_VALOR,17,2) == STR(SE2->E2_SALDO,17,2) .and. ;
		SE2->E2_SDACRES == 0 .and. SE2->E2_ACRESC > 0
		nAcresc	:= Round(Noround(xMoeda(SE2->E2_ACRESC,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
		nAcrescF := SE2->E2_ACRESC
	Endif

	// Ponto de entrada para acrescimo
	If ExistBlock("F080ACRE")
		ExecBlock("F080ACRE",.F.,.F.)
	Endif

	nDescont    	:= 0
	nOldDescont		:= 0
	nMulta      	:= 0
	nOldMulta      	:= 0
	nJuros      	:= 0
	nOldJuros      	:= 0
	nPis			:= 0
	nOldPis			:= 0
	nCofins			:= 0
	nOldCofins		:= 0
	nCsll			:= 0
	nOldCsll		:= 0
	nVlRetPis		:= 0
	nVlRetCof		:= 0
	nVlRetCsl		:= 0
	nValPgto		:= 0
	nOldValPgto		:= 0
	nOldIrrf		:= 0
	nDiferImp		:= 0
	nIrrf			:= 0
	nVlRetIrf		:= 0
	nBaseIrpf		:= 0
	nIss			:= 0
	nOldIss			:= 0
	nInss			:= Iif(SuperGetMv("MV_INSIRF",.F.,"2") == "2" .And. (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1")),SE2->E2_INSS,0)//Valor do INSS descontado na emissão
	nValPgto		:= Round(Noround(xMoeda(SE2->E2_SALDO-nTotAbat,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)+nMulta+nJuros-nDescont+nAcresc-nDecresc-;
								If(!_lPccMR, (nPis+nCoFins+nCsll), 0) - If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0)
	nOldValPgto 	:= nValPgto
	dOldData		:= CTOD("//")
	nInss			:=	0
	_nBasLeg        := 0
	__BordeImp      := IIf(__BordeImp == Nil, FindFunction("BorderoImp"), __BordeImp)
	
	// Cálculo de valores acessórios.
	nVa	:= FValAcess(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NATUREZ, /*lBaixados*/,/*cCodVa*/,"P",dBaixa,/*aValAces*/,SE2->E2_MOEDA,nMoedaBco,nTxMoeda)

	If __BordeImp .And. !Empty(SE2->E2_NUMBOR) .And. !SE2->E2_TIPO $ MVPAGANT+"|"+MVPROVIS+"|"+MV_CPNEG
		lRetBor := !BorderoImp(SE2->E2_FILORIG, SE2->E2_NUMBOR, "P", SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA)	 
	Endif
	
	lRetBor := IIf(__BordeImp, lRetBor, VLDBOR(SE2->E2_NUMBOR,"P",cFilAnt))
	
	//Motor de retenções.
	If _lTemMR
		F080VldImp(.F.)
	EndIf

	//Calcula ISS na Baixa
	If lCalcIssBx .and. Empty(SE2->E2_NUMBOR)  // (1) Emissao, (2) Baixa
		F080IssBx()
	EndIf

	//Calcula Impostos pela Baixa
	If !_lIrfMR .And. lIRPFBaixa .And. lRetBor
		//Novo calculo de IRRF pela Baixa
		//Calculo para o  IRRF
		//o primeiro parametro, neste caso vai zerado pois o calculo
		//eh feito com base no saldo do titulo
		nIRRF := FCalcIRBx(0, SA2->A2_TIPO, dBaixa, dDebito, /*lAltValor*/, /*nTxmoeda*/, cMotBx )
	Endif

	If lPccBaixa
		fA080Data(/*nTxMoeda*/, /*lButOk*/, /*lHelp*/, /*oDtBaixa*/,aTitCalc)
		If (dBaixa < dLastPcc .Or. lEmpPub)
			f080TotMes(dBaixa,.T.,,.F.)
		Else
			If !SE2->E2_TIPO $ MVPAGANT+"/"+MVPROVIS .And. lRetBor
				If Empty(_nBasLeg)
					nSalImp := salRefPag(SA2->A2_COD+SA2->A2_LOJA,_lPccMR, _lIrfMR, _lInsMR, _lIssMR, _lCidMR, _lSesMR)
				Else
					nSalImp := _nBasLeg
				EndIf

				If SE2->E2_MOEDA > 1
					nSalImp := xMoeda(nSalImp,SE2->E2_MOEDA,1,dBaixa,,SE2->E2_TXMOEDA)
				EndIf
				
				nSalImp += F080JuMuDe()

				If !_lPccMR
					aPcc    := newMinPcc(dBaixa, nSalImp, SED->ED_CODIGO, "P", SA2->A2_COD + SA2->A2_LOJA, /*nIss*/, /*nIns*/, /*nIrf*/, /*lMin*/, /*lIgnrOrg*/, cMotBx,,nTxmoeda)
					nPis    := aPcc[2]
					nCofins := aPcc[3]
					nCsll   := aPcc[4]
					If len(aPCC)>4
						aTitCalc := aPCC[5]
					Endif
				EndIf
			Else
				nPis	:= 0
				nCofins := 0
				nCsll	:= 0
			EndIf
		EndIf

		If lFa080PCC
			ExecBlock("FA080PCC",.F.,.F.,{nPis, nCofins, nCsll, nIrrf, nSalImp})
		Endif

		//Ponto de entrada para manipular os valores de impostos(nPis, nCofins, nCsll)
		If lImp10925 .and. (nPis+nCofins+nCsll) > 0
			ExecBlock("FA080IMP",.F.,.F.)
		EndIf
	Endif

	If lEmpPub .And. lAplMinP .And. (nPis+nCoFins+nCsll+nIrrf+aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5]< nVlMPub  .And. ;
		!(aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] == 0 .And. aDadosRet[1] > 0))
		nPis := nCoFins := nCsll := nIrrf := 0
	EndIf
	nInss		:= 0
	nBaseIns	:= 0
	nVretInss	:= 0

	fa080Val(nValPgto,nTxMoeda,,,,,,aTitCalc)
	nOldValPgto := nValPgto
	nCM         	:= 0
	cMoeda 		:= IIF(Empty(SE2->E2_MOEDA),"1",AllTrim(Str(SE2->E2_MOEDA,2)))
	cDescMoeda 	:= SubStr(GetMV("MV_SIMB"+cMoeda),1,3)
	cTexto1	 	:= OemToAnsi(STR0084) + SubStr(GetMV("MV_SIMB"+cMoeda),1,3) //"Valor Original "
	If Empty(cBenef)
		dbSelectArea("SA2")
		SA2->(dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA))
		dbSelectArea("SE2")
		cBenef   := SA2->A2_NOME
	Endif

	//Analisa se o titulo foi gerado a partir de um cheque pre datado
	lChqPre := .f.
	dbSelectArea("SE5")
	dbSetOrder(2)
	If SE5->(dbSeek( xFilial("SE5") + "CD" + SE2->E2_PREFIXO + ;
			SE2->E2_NUM + SE2->E2_PARCELA + SE2->E2_TIPO + dToS(SE2->E2_EMISSAO )+;
			SE2->E2_FORNECE + SE2->E2_LOJA ))

		lChqPre := .T.
		cBanco   := SE5->E5_BANCO
		cAgencia := SE5->E5_AGENCIA
		cConta   := SE5->E5_CONTA
		cCheque  := SE5->E5_NUMCHEQ
		cBenef   := SE5->E5_BENEF
	EndIf

	// Carrega as variaveis bancarias
	Fa080BDev()

	// Pré-inicializa a modalidade de SPB                                 ³
	If lSpbInUse
		If !Empty(SE2->E2_MODSPB)
			cModSpb := SE2->E2_MODSPB
		Else
		cModSpb := "1"
		Endif
	Endif

	If lFa080Lt		// ponto de entrada para manipulacao do titulo antes da baixa
		Execblock("FA080LT" ,.F.,.F.)
	Endif

	//---------------------------------------------------------------------------
	// PONTO DE ENTRADA FA080ACES
	//---------------------------------------------------------------------------
	// Permite ou nao que o usuario altere os valores dos impostos da lei 10925
	// calculados automaticamente pelo sistema.
	// Variáveis disponíveis para serem alteradas :
	//
	// lAcessImp ( .T. - PERMITE  /  .F. - NAO PERMITE )
	//---------------------------------------------------------------------------
	If ExistBlock("FA080ACES")
		lAcessImp := ExecBlock("FA080ACES",.F.,.F.)
	Endif

	//Reestruturacao SE5
	//Obtenho os valores calculados de juros, multas, descontos etc
	nDescCalc 	:= nDescont + nDecresc
	nJurosCalc 	:= IIf(cPaisLoc<>"CHI",nJuros + nAcresc,nOtrga)
	nVACalc 	:= nVA
	nMultaCalc 	:= nMulta
	nCMCalc		:= IIf(cPaisLoc<>"CHI",nCM,nDifCambio)
	nDifCambio	:= nDifCambio
	nImpSubCalc	:= nImpSubst
	lOFINI055 	:= (ALLTRIM(SE2->E2_ORIGEM) =="FINI055")

	DEFINE MSDIALOG oDlgLote FROM	31,15 TO 680,574 TITLE OemToAnsi(STR0007)  PIXEL OF oMainWnd //"Baixas a Pagar"

	//Faz o calculo automatico de dimensoes de objetos
	oSize := FwDefSize():New(.T.,,,oDlgLote )

	oSize:lLateral := .F.
	oSize:lProp	:= .T. // Proporcional

	oSize:AddObject( "1STROW" ,  100, 18, .T., .T. ) // Totalmente dimensionavel
	oSize:AddObject( "2NDROW" ,  100, 82, .T., .T. ) // Totalmente dimensionavel

	oSize:Process() // Dispara os calculos

	a1stRow := {oSize:GetDimension("1STROW","LININI"),;
				oSize:GetDimension("1STROW","COLINI"),;
				oSize:GetDimension("1STROW","LINEND"),;
				oSize:GetDimension("1STROW","XSIZE")}

	a2ndRow := {oSize:GetDimension("2NDROW","LININI"),;
				oSize:GetDimension("2NDROW","COLINI"),;
				oSize:GetDimension("2NDROW","LINEND"),;
				oSize:GetDimension("2NDROW","XSIZE")}

	//////////////////
	//DADOS DO TITULO

	If IsPanelFin()
		@ 000, a1stRow[2] + 000 GROUP oMyBar  TO a1stRow[1] - 1, (a1stRow[4]-7) OF oDlgLote PIXEL 
		@ 010, a1stRow[2] + 008 SAY cCadastro+" - "+Upper(STR0003) FONT oFont24 COLOR CLR_HBLUE OF oDlgLote PIXEL //"BAIXAR"
	Endif

	@ a1stRow[1] + 000, a1stRow[2] + 000 GROUP oGrp1 TO a1stRow[3], (a1stRow[4]-7) LABEL STR0015 OF oDlgLote  PIXEL //"Principal"
	@ a2ndRow[1] + 000, a2ndRow[2] + 000 GROUP oGrp2 TO a2ndRow[3], 135 LABEL STR0013 OF oDlgLote   PIXEL //"Dados Gerais"
	@ a2ndRow[1] + 000, a2ndRow[2] + 139 GROUP oGrp3 TO a2ndRow[3], (a2ndRow[4]-7) LABEL STR0014 OF oDlgLote   PIXEL //"Valores da Baixa"

	If lUsaCmc7
		aCmc7:=LjLeCmc7(1)
		If Len(aCmc7) > 0
			cBanco  :=aCmc7[1]
			cAgencia:=aCmc7[2]
			cConta  :=aCmc7[3]
			cCheque :=aCmc7[4]
		Endif
	Endif

	// Ponto de Entrada para o escolher se a data exibida é a E2_VENCREA ou a E2_VENCTO
	If Type("dBxDt_Venc") == "U"
		dBxDt_Venc := SE2->E2_VENCREA
	EndIf

	@ a1stRow[1] + 008, a1stRow[2] + 004 SAY STR0092			SIZE 31,07 OF oDlgLote PIXEL //Prefixo
	@ a1stRow[1] + 008, a1stRow[2] + 027 MSGET oPrefixo VAR SE2->E2_PREFIXO	SIZE 25,08 OF oDlgLote PIXEL When .F.
	@ a1stRow[1] + 008, a1stRow[2] + 060 SAY STR0093 			SIZE 31,07 OF oDlgLote PIXEL //Numero
	@ a1stRow[1] + 008, a1stRow[2] + 085 MSGET oTitulo VAR SE2->E2_NUM		SIZE 70,08 OF oDlgLote PIXEL When .F.
	@ a1stRow[1] + 008, a1stRow[2] + 165 SAY STR0094 			SIZE 31,07 OF oDlgLote PIXEL //Parcela
	@ a1stRow[1] + 008, a1stRow[2] + 188 MSGET oParcela VAR SE2->E2_PARCELA	SIZE 25,08 OF oDlgLote PIXEL When .F.
	@ a1stRow[1] + 008, a1stRow[2] + 220 SAY STR0095			SIZE 31,07 OF oDlgLote PIXEL //Tipo
	@ a1stRow[1] + 008, a1stRow[2] + 238 MSGET oTipo VAR cTipo	F3 "SE2RDO" SIZE 30,08 OF oDlgLote PIXEL HASBUTTON
	oTipo:lReadOnly := .T.

	@ a1stRow[1] + 020, a1stRow[2] + 004 SAY STR0019 			SIZE 22,07 OF oDlgLote PIXEL //"Fornecedor"
	@ a1stRow[1] + 020, a1stRow[2] + 027 MSGET oCodFor VAR SE2->E2_FORNECE F3 "SA2" SIZE 70,08 OF oDlgLote PIXEL HASBUTTON
	oCodFor:lReadOnly := .T.
	@ a1stRow[1] + 020, a1stRow[2] + 105 MSGET oNomeFor VAR SA2->A2_NOME SIZE 165,08 OF oDlgLote PIXEL When .F.

	@ a1stRow[1] + 032, a1stRow[2] + 004 SAY STR0098 			SIZE 31,07 OF oDlgLote PIXEL //"Natureza"
	@ a1stRow[1] + 032, a1stRow[2] + 027 MSGET oNaturez VAR SE2->E2_NATUREZ	F3 "SED" SIZE 70,08 OF oDlgLote PIXEL HASBUTTON
	oNaturez:lReadOnly := .T.
	@ a1stRow[1] + 032, a1stRow[2] + 105 SAY STR0017 			SIZE 31,07 OF oDlgLote PIXEL //"Emiss„o"
	@ a1stRow[1] + 032, a1stRow[2] + 133 MSGET SE2->E2_EMISSAO	SIZE 48,08 OF oDlgLote PIXEL When .F. HASBUTTON
	@ a1stRow[1] + 032, a1stRow[2] + 189 SAY STR0018 			SIZE 49,07 OF oDlgLote PIXEL //"Vencto.Atual"
	@ a1stRow[1] + 032, a1stRow[2] + 222 MSGET SE2->E2_VENCREA	SIZE 48,08 OF oDlgLote PIXEL When .F. HASBUTTON


	//////////////////
	//DADOS GERAIS
	nUltLin := 10 + a2ndRow[1]

	@ nUltLin,005 SAY OemToAnsi(STR0020)		SIZE 38,07 OF oDlgLote  PIXEL //"Hist.Emiss„o"
	@ nUltLin,065 MSGET oHist VAR cHist			SIZE 65,08 OF oDlgLote  PIXEL When .F.
	nUltLin += 12

	@ nUltLin,005 SAY OemToAnsi(STR0021)		SIZE 39,07 OF oDlgLote  PIXEL //"Portador"
	@ nUltLin,065 MSGET oPortado VAR cPortado	SIZE 65,08 OF oDlgLote  PIXEL When .F.
	nUltLin += 12

	@ nUltLin,005 SAY OemToAnsi(STR0029)		SIZE 37,07 OF oDlgLote  PIXEL //"Mot.Baixa"

	@ nUltLin,065 COMBOBOX oMotBx VAR cMotBx ITEMS aDescMotbx SIZE 65,47 OF oDlgLote  PIXEL ;
	ON CHANGE (fa080ChkVdr(),oBanco:lReadOnly := !fa080digit()) Valid fa080BDev() .and. FA080VlNat(cMotBx)

	nUltLin += 18

	@ nUltLin,005 SAY OemToAnsi(STR0022)		SIZE 40,07 OF oDlgLote  PIXEL //"Banco"
	@ nUltLin,065 MSGET oBanco VAR cBanco 		SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON F3 "SA6" Valid (!MovBcobx(cMotBx, .T.) .and. Empty(cBanco)) .or. (CarregaSA6(@cBanco,@cAgencia,@cConta,.T.) .and. fa080BcoCx() .and. fa80AltTela(@nTxMoeda,,,,aTitCalc).and.;
															  											Fa080Refr(oJuros, oMulta, oDescont, oBaixa))
	oBanco:lReadOnly := !fa080digit()
	nUltLin += 12

	@ nUltLin,005 SAY OemToAnsi(STR0023)		SIZE 39,07 OF oDlgLote  PIXEL //"Agˆncia"
	@ nUltLin,065 MSGET oAgencia VAR cAgencia	SIZE 65,08 OF oDlgLote  PIXEL When fa080digit() Valid ;
	CarregaSA6(@cBanco,@cAgencia,,.T.) .and. fa80AltTela(@nTxMoeda,,,,aTitCalc).and.;
	Fa080Refr(oJuros, oMulta, oDescont, oBaixa)
	nUltLin += 12

	@ nUltLin,005 SAY OemToAnsi(STR0024)		SIZE 41,07 OF oDlgLote  PIXEL //"Conta"
	@ nUltLin,065 MSGET oConta VAR cConta 		SIZE 65,08 OF oDlgLote  PIXEL When fa080digit() Valid ;
	If(CarregaSA6(@cBanco,@cAgencia,@cConta,.T.,,.T.) .AND. ( FXVldBxBco( cBanco, cAgencia, cConta, SE2->E2_NATUREZ, SE2->E2_MOEDA ) ),FaPrNumChq(cBanco,cAgencia,cConta,@oCheque,@cCheque) .And. ;
	fa80AltTela(@nTxMoeda,,,,aTitCalc).and.;
	Fa080Refr(oJuros, oMulta, oDescont, oBaixa),oBanco:SetFocus())

	nUltLin += 12

	@ nUltLin,005 SAY OemToAnsi(STR0027)		SIZE 40,07 OF oDlgLote  PIXEL //"Cheque No."
	@ nUltLin,065 MSGET oCheque VAR cCheque	SIZE 65,08 OF oDlgLote  PIXEL  Picture PesqPict( "SEF","EF_NUM") When (fa080digit() .and. faDigiChq()) Valid fa080Cheq()
	nUltLin += 12

	@ nUltLin,005 SAY OemToAnsi(STR0025)		SIZE 38,07 OF oDlgLote  PIXEL //"Data Pagto."
	@ nUltLin,065 MSGET oBaixa VAR dBaixa 		SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON ON CHANGE (nValTt  := nValPgto,lDtPag:=.T.,iif((dBaixa < dLastPcc .Or. lEmpPub), f080TotMes(dBaixa,.T.,,,dOldData # dBaixa),),If(lIRPFBaixa.and.FunName()<>"FINA415", Fa080Irrf(nPgtoIRRF,dBaixa,lCarret,.T.,nOldIrrf) , .T.));
																								 Valid Iif(dOldData # dBaixa, fa080Data(@nTxMoeda, /*lButOk*/, /*lHelp*/, /*oDtBaixa*/,aTitCalc), .T.) .and. Iif(SuperGetMv("MV_BXDTFIN",,"1") == "2", DtMovFin(dBaixa,,"1"), .T.);
	When lAceDtBxa
	dOldData := dBaixa
	dDebito  := dBaixa
	nUltLin += 12
	nOldIrrf := nIrrf

	@ nUltLin,005 SAY OemToAnsi(STR0026)		SIZE 39,07 OF oDlgLote  PIXEL //"Hist.Baixa"
	@ nUltLin,065 MSGET oHist070 VAR cHist070	SIZE 65,08 OF oDlgLote  PIXEL Picture "@!" VALID CheckSX3("E5_HISTOR") When VisualSX3("E5_HISTOR")
	nUltLin += 12

	@ nUltLin,005 SAY OemToAnsi(STR0028)	 	SIZE 36,07 OF oDlgLote  PIXEL //"Beneficiário"
	@ nUltLin,065 MSGET oBenef VAR cBenef		SIZE 65,08 OF oDlgLote  PIXEL Picture "@!" When cNivel >= NivelSx3("E5_BENEF") .and. fa080digit()
	nUltLin += 12

	If cPaisLoc == "BRA"
		@ nUltLin,005 SAY STR0129 	SIZE 53, 07 OF oDlgLote  PIXEL //"Taxa contratada"
		@ nUltLin,065 MSGET oTxMoeda VAR nTxMoeda  SIZE 65,08 OF oDlgLote  PIXEL Hasbutton Picture PesqPict( "SM2","M2_MOEDA"+AllTrim(Str(SE2->E2_MOEDA))) ;
		When SE2->E2_MOEDA > 1	 Valid fa80AltTela(nTxMoeda,,,,aTitCalc) .and. Fa080Refr(oJuros, oMulta, oDescont, oBaixa, oTxMoeda)
		nUltLin += 12
	Endif
	If lSpbInUse
		@ nUltLin,005 SAY STR0128 SIZE 32, 07 OF oDlgLote  PIXEL //"Modalidade SPB"
		@ nUltLin,065 COMBOBOX oModSPB VAR cModSpb ITEMS aModalSpb SIZE 65,47 OF oDlgLote  PIXEL ;
						When MovBcoBx(cMotBx,.T.)
		nUltLin+= 12
	Endif
	
	// Somente exibe a opcao Rateio Multiplas Naturezas se parametro MV_MULNATP = .T.  
	If MV_MULNATP
		@ nUltLin,005 SAY STR0132 SIZE 100, 07 OF oDlgLote  PIXEL   //"Rateio Mult.Naturezas"
		@ nUltLin,065 CHECKBOX oMultNat VAR lMultNat PROMPT "" SIZE 11,11 OF oDlgLote  PIXEL
		nUltLin += 12
	Endif

	//////////////////
	//DADOS DA BAIXA
	nUltLin := 10 + a2ndRow[1]

	@ nUltLin,144 SAY oTexto1 VAR cTexto1 		SIZE 53,07 OF oDlgLote  PIXEL //"Valor Original"
	@ nUltLin,210 MSGET oValor VAR nValor		SIZE 65,08 OF oDlgLote  PIXEL When .F. Picture PesqPict("SE2","E2_VALOR") HASBUTTON
	nUltLin+= 12

	@ nUltLin,144 SAY OemToAnsi(STR0035)		SIZE 53,07 OF oDlgLote  PIXEL //"- Abatimentos"
	@ nUltLin,210 MSGET oTotAbat VAR nTotAbat	SIZE 65,08 OF oDlgLote  PIXEL When .F. Picture PesqPict("SE2","E2_VALOR") HASBUTTON
	nUltLin+= 12

	@ nUltLin,144 SAY OemToAnsi(STR0036)  		SIZE 53,07 OF oDlgLote  PIXEL //"- Pagtos.Parciais"
	@ nUltLin,210 MSGET oParciais VAR nParciais	SIZE 65,08 OF oDlgLote  PIXEL When .F. Picture PesqPict("SE2","E2_VALOR") HASBUTTON
	nUltLin+= 12

	@ nUltLin,144 SAY OemToAnsi(STR0121)		SIZE 53,07 OF oDlgLote  PIXEL //"- Decrescimo"
	@ nUltLin,210 MSGET oDecresc VAR nDecresc	SIZE 65,08 OF oDlgLote  PIXEL Picture PesqPict("SE2","E2_SDDECRE") When .f. HASBUTTON	//Valid Fa080Val(nDecresc) .and. nDecresc<=Moeda(SE2->E2_SALDO,1,"P",dBaixa)
	nUltLin+= 12

	@ nUltLin,144 SAY OemToAnsi(STR0120)  		SIZE 53,07 OF oDlgLote  PIXEL //"+ Acrescimo"
	@ nUltLin,210 MSGET oAcresc VAR nAcrescF 	SIZE 65,08 OF oDlgLote  PIXEL Picture PesqPict("SE2","E2_SDACRES") When .f. HASBUTTON	//Valid Fa080Val(nAcresc)
	nUltLin+= 12

	@ nUltLin,144 SAY OemToAnsi(STR0037)		SIZE 53,07 OF oDlgLote  PIXEL //"- Descontos"
	@ nUltLin,210 MSGET oDescont VAR nDescont	SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON Picture PesqPict("SE2","E2_DESCONT") Valid Iif(nOldDescont # nDescont, (Fa080Val(nDescont,nTxMoeda,.T.,,,,,aTitCalc),nOldDescont := nDescont), .T.);
	When lAcessDes
	nUltLin+= 12

	@ nUltLin,144 SAY OemToAnsi(STR0038)		SIZE 53,07 OF oDlgLote  PIXEL //"+ Multa"
	@ nUltLin,210 MSGET oMulta VAR nMulta 		SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON Picture PesqPict("SE2","E2_MULTA") Valid Iif(nOldMulta # nMulta, (Fa080Val(nMulta,nTxMoeda,.T.,,,.T.,,aTitCalc),nOldMulta := nMulta), .T.);
	When lAcessMul
	nUltLin+= 12

	@ nUltLin,144 SAY OemToAnsi(STR0039)  		SIZE 53,7 OF oDlgLote  PIXEL //"+ Tx.Permanenc."
	@ nUltLin,210 MSGET oJuros VAR nJuros 		SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON Picture PesqPict("SE2","E2_JUROS") Valid Iif(nOldJuros # nJuros, (Fa080Val(nJuros,nTxMoeda,.T.,,,.T.,,aTitCalc),nOldJuros := nJuros), .T.);
	When lAcessJur
	nUltLin+= 12

	nLinha := nUltLin

	//Get do ISS na baixa
	If cPaisLoc == "BRA"

		//ISS
		If (!_lTemMR .Or. !_lIssMR)
			@ nLinha, 144 SAY "- Iss"			SIZE 53,07 OF oDlgLote  PIXEL
			@ nLinha, 210 MSGET oIss VAR nIss	SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALLIQ")  ;
			Valid ( Iif(nOldIss # nIss, (Fa080Val(nIss,,,.T.,,,,aTitCalc),nOldIss := nIss), .T.)) When !lEmBordero .And. ((lCalcIssBx .and. nIss > 0 ) .and. !lOFINI055 ) .And. (nOldIss>0 .Or. nIss>0 .Or. lFA080ACES)	
			nLinha +=12
		EndIf

		If (!_lTemMR .Or. !_lInsMR)
			If !(lInsPub .And. SE2->E2_TIPO $ MVPAGANT+"/INA") //PA de Inss Baixa Empresa Publica
				@ nLinha,144 SAY "- Inss"	SIZE 53,07 OF oDlgLote PIXEL
				@ nLinha,210 MSGET oInss VAR nInss	SIZE 65, 08 OF oDlgLote PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALLIQ")  ;
						Valid ( Iif(nOldInss # nInss, Fa080Val(nInss,,,.T.,,,,aTitCalc), .T.));
				WHEN (lInssBx .And. nInss > 0 ) .and.  !lOFINI055
				nLinha +=12
			Endif
		EndIf

		If (!_lTemMR .Or. !_lIrfMR)
			//IRRF
			@ nLinha,144 SAY "- Irrf"				SIZE 53,07 OF oDlgLote  PIXEL
			@ nLinha,210 MSGET oIrrf VAR nIrrf		SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON  Picture PesqPict("SE2","E2_IRRF")  ;
			Valid ( Iif(nOldIRRF # nIrrf, Fa080Val(nIrrf,,,.T.,,,,aTitCalc),  .T.)) When !lEmBordero .And. (nOldIRRF>0 .Or. nIrrf>0 .Or. lFA080ACES) .AND. FA080IRPF() .And. !lOFINI055 	
			nLinha +=12
		EndIf

		If (!_lTemMR .Or. !_lPccMR) .and. lPccBaixa
			//PCC
			@ nLinha,144 SAY "- Pis"			SIZE 53,07 OF oDlgLote  PIXEL
			@ nLinha,210 MSGET oPis VAR nPis	SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON Picture PesqPict("SE2","E2_PIS")  ;
			Valid ( Iif(nOldPis # nPis, Fa080Val(nPis,,,.T.,,,,aTitCalc), .T.)) When  !lOFINI055  .and. !lEmBordero .And. (nOldPis>0 .Or. nPis>0 .Or. lFA080ACES)	
			oPis:SetEnable( lAcessImp )
			nOldPis := nPis
			nLinha +=12

			@ nLinha,144 SAY "- Cofins" 			SIZE 53,07 OF oDlgLote  PIXEL
			@ nLinha,210 MSGET oCofins VAR nCofins	SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON Picture PesqPict("SE2","E2_COFINS") ;
			Valid ( Iif(nOldCofins # nCofins, Fa080Val(nCofins,,,.T.,,,,aTitCalc), .T.)) when  !lOFINI055 .and. !lEmBordero .And. (nOldCofins>0 .Or. nCofins>0 .Or. lFA080ACES)	
			oCofins:SetEnable( lAcessImp )
			nOldCofins := nCofins
			nLinha +=12

			@ nLinha,144 SAY "- Csll"				SIZE 53,07 OF oDlgLote  PIXEL
			@ nLinha,210 MSGET oCsll VAR nCsll		SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON Picture PesqPict("SE2","E2_CSLL") ;
			Valid ( Iif(nOldCsll # nCsll, Fa080Val(nCsll,,,.T.,,,,aTitCalc), .T.)) when  !lOFINI055 .and. !lEmBordero .And. (nOldCsll>0 .Or. nCsll>0 .Or. lFA080ACES)	
			oCsll:SetEnable( lAcessImp )
			nOldCsll := nCsll
			nLinha +=12
		EndIf
		If (_lTemMR .And. _nImpMR > 0)
			@ nLinha, 144 SAY "  Retenções"	SIZE 53,07 OF oDlgLote PIXEL
			@ nLinha, 210 MSGET _nTotImp SIZE 65, 08 OF oDlgLote PIXEL  When .F. Picture PesqPict("SE2","E2_ISS") HASBUTTON
			nLinha +=12
		EndIf
	Endif
	// Valores acessórios.
	@ nLinha,144 SAY STR0204		SIZE 53,07 OF oDlgLote PIXEL	//"+ Valores Acessórios"
	@ nLinha,210 MSGET oVA VAR nVA	SIZE 65, 08 OF oDlgLote PIXEL HASBUTTON Picture PesqPict("FKD","FKD_VALOR") When  .F.
	nOldVA := nVA
	nLinha +=12

	nValTot	     := SE2->E2_VLCRUZ
	nValEstrang  := SE2->E2_SALDO-nTotAbat-SE2->E2_SDACRES+SE2->E2_SDDECRE
	nValOrig     := SE2->E2_SALDO-nTotAbat
	nEstOriginal := nValEstrang-(xMoeda(nJuros+nVA+nMulta-nDescont,nMoedaBco,SE2->E2_MOEDA,,3,,nTxMoeda))
	nValMoeda   := Round(Noround(xMoeda(nValOrig,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
	nValMoeda1  := Round(NoRound(xMoeda(SE2->E2_VALOR-nTotAbat,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
	nValPgto    := nValMoeda+nMulta+nJuros+nVA-nDescont+nAcresc-nDecresc-If(!_lPccMR, (nPis+nCoFins+nCsll), 0) - If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0) - If(!_lInsMR, nInss, 0) - _nImpMR

	IF (nMulta+nJuros+nDescont+nAcresc+nDecresc+nPis+nCoFins+nCsll) > 0 .or. Round(nValEstrang - xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,3,,nTxMoeda),2 ) > 0.01
		nValEstrang := Round(NoRound(xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
	EndIF

	nValLiq	    := nValPgto-nMulta-nJuros-nVA+nDescont-nAcresc+nDecresc + If(!_lPccMR, (nPis+nCoFins+nCsll), 0) - If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0) - If(!_lInsMR, nInss, 0) - _nImpMR

	FA080CORR(nEstOriginal,nTxMoeda)

	@ nLinha,144 SAY OemToAnsi(STR0041)			SIZE 53,07 OF oDlgLote  PIXEL //"= Valor Pago"
	@ nLinha,210 MSGET oValPgto VAR nValPgto	SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALOR")  When !lEmBordero ;
	Valid ( oValPgto:Refresh(),;
	fa80AltTela(nTxMoeda,,,,aTitCalc),;
	Fa080ValVR(nTxMoeda,nTolerCp,,lIRPFBaixa,,lBaixou,aTitCalc))
	nLinha += 12

	cTexto2 	:= OemToAnsi(STR0042) + SubStr(GetMV("MV_SIMB"+cMoeda),1,3) //"Valor "
	@ nLinha,144 SAY oTexto2 VAR cTexto2			SIZE 53,07 OF oDlgLote  PIXEL //"Valor "
	@ nLinha,210 MSGET oVlEstrang VAR nValEstrang	SIZE 65,08 OF oDlgLote  PIXEL HASBUTTON Picture PesqPict("SE2","E2_VALOR")  ;
	When (!lEmBordero .And. SE2->E2_MOEDA > 1) Valid FA080Estrang(nTxMoeda,nTolerCP) .and.  fa80AltTela(nTxMoeda,,,,aTitCalc) .And.Fa080Refr(oJuros, oMulta, oDescont, oBaixa)
	nLinha += 12

	@ nLinha, 144 SAY OemToAnsi(STR0040) 		SIZE 53,07 OF oDlgLote  PIXEL //"+ Corr.Monet ria"
	@ nLinha, 210 MSGET oCM VAR nCM				SIZE 65,08 OF oDlgLote  PIXEL Hasbutton Picture PesqPict("SE2","E2_CORREC") ;
		When SE2->E2_MOEDA > 1 .and. (IIf(GetMv("MV_CALCCM") == "S",.T.,.F.))

	//Atualiza o valor caso seja necessario calcular juros no titulo
	nValMax := SE2->E2_SALDO
	fa080Data(/*nTxMoeda*/, /*lButOk*/, /*lHelp*/, /*oDtBaixa*/,aTitCalc)

	If _lTemMR
		Aadd(aButtons, {"NOTE", {||F080ConImp()},,STR0216,STR0216})
	EndIf

	_nValPgto := nValPgto

	If lPanelFin  //Chamado pelo Painel Financeiro
		ACTIVATE MSDIALOG oDlgLote  CENTERED ON INIT FaMyBar(oMyBar,{||nOpca := 1,;
																	Fa080But(nOpca,lMovBco,@lBaixou,@cTitulo,@oTitulo,;
																	@cParcela,@oParcela,@cNomeFor,@oNomeFor,;
																	@cBanco,@oBanco,@cAgencia,@oAgencia,@cConta,@oConta,;
																	@oBaixa,@oBenef,@cHist070,@oHist070,@cMotBx,@oMotBx,;
																	@aDescMotBx,@nValor,;
																	@oValor,@nTotAbat,@oTotAbat,@nParciais,@oParciais,@oDescont,;
																	@oMulta,@oJuros,@oValPgto,@oVlEstrang,@oCM,@oDlgLote,cMarca,;
																	@nTotal, @nHdlPrv, @lHdlPrv, @lPadraoBx,@cArquivo,@nValLiq,@cPadrao,;
																	@cHist,@oHist,@oAcresc,@oDecresc,@nAcrescF,@nDecrescF,;
																	aModalSpb,@oModSpb,lSpbInUse,@nTxMoeda,@oMultNat,@lMultNat,@nTotLtEZ,nTolerCp,aMotBx,;
																	@nPis,@nCoFins,@nCsll,@oPis,@oCoFins,@oCsll,lPccBaixa,@nOldValPgto,@nIrrf,@oIrrf,@nIss,;
																	@oIss,@cTipo,@oTipo,@nBaseIrpf, @dDataCan,@nInss,@oInss,@aTitCalc,@aCtBaixa,@aFlagCTB),lEmBordero := F080EmBord() },;
																	{||nOpca := 0,;
																	Fa080But(nOpca,lMovBco,@lBaixou,@cTitulo,@oTitulo,;
																	@cParcela,@oParcela,@cNomeFor,@oNomeFor,;
																	@cBanco,@oBanco,@cAgencia,@oAgencia,@cConta,@oConta,;
																	@oBaixa,@oBenef,@cHist070,@oHist070,@cMotBx,@oMotBx,;
																	@aDescMotBx,@nValor,;
																	@oValor,@nTotAbat,@oTotAbat,@nParciais,@oParciais,@oDescont,;
																	@oMulta,@oJuros,@oValPgto,@oVlEstrang,@oCM,@oDlgLote,cMarca,;
																	@nTotal, @nHdlPrv, @lHdlPrv, @lPadraoBx,@cArquivo,@nValLiq,@cPadrao,;
																	@cHist,@oHist,@oAcresc,@oDecresc,@nAcrescF,@nDecrescF,;
																	aModalSpb,@oModSpb,lSpbInUse,@nTxMoeda,@oMultNat,@lMultNat,@nTotLtEZ,nTolerCp,aMotBx,;
																	@nPis,@nCoFins,@nCsll,@oPis,@oCoFins,@oCsll,lPccBaixa,@nOldValPgto,@nIrrf,@oIrrf,@nIss,;
																	@oIss,@cTipo,@oTipo,@nBaseIrpf, @dDataCan,@nInss,@oInss,@aTitCalc,@aCtBaixa,@aFlagCTB),lEmBordero := F080EmBord() })


	Else
		ACTIVATE MSDIALOG oDlgLote ON INIT EnchoiceBar(oDlgLote,{||nOpca := 1,;
																	Fa080But(nOpca,lMovBco,@lBaixou,@cTitulo,@oTitulo,;
																	@cParcela,@oParcela,@cNomeFor,@oNomeFor,;
																	@cBanco,@oBanco,@cAgencia,@oAgencia,@cConta,@oConta,;
																	@oBaixa,@oBenef,@cHist070,@oHist070,@cMotBx,@oMotBx,;
																	@aDescMotBx,@nValor,;
																	@oValor,@nTotAbat,@oTotAbat,@nParciais,@oParciais,@oDescont,;
																	@oMulta,@oJuros,@oValPgto,@oVlEstrang,@oCM,@oDlgLote,cMarca,;
																	@nTotal, @nHdlPrv, @lHdlPrv, @lPadraoBx,@cArquivo,@nValLiq,@cPadrao,;
																	@cHist,@oHist,@oAcresc,@oDecresc,@nAcrescF,@nDecrescF,;
																	aModalSpb,@oModSpb,lSpbInUse,@nTxMoeda,@oMultNat,@lMultNat,@nTotLtEZ,nTolerCp,aMotBx,;
																	@nPis,@nCoFins,@nCsll,@oPis,@oCoFins,@oCsll,lPccBaixa,@nOldValPgto,@nIrrf,@oIrrf,@nIss,;
																	@oIss,@cTipo,@oTipo,@nBaseIrpf, @dDataCan,@nInss,@oInss,@aTitCalc,@aCtBaixa,@aFlagCTB ),lEmBordero := F080EmBord() },;
																	{||nOpca := 0,;
																	Fa080But(nOpca,lMovBco,@lBaixou,@cTitulo,@oTitulo,;
																	@cParcela,@oParcela,@cNomeFor,@oNomeFor,;
																	@cBanco,@oBanco,@cAgencia,@oAgencia,@cConta,@oConta,;
																	@oBaixa,@oBenef,@cHist070,@oHist070,@cMotBx,@oMotBx,;
																	@aDescMotBx,@nValor,;
																	@oValor,@nTotAbat,@oTotAbat,@nParciais,@oParciais,@oDescont,;
																	@oMulta,@oJuros,@oValPgto,@oVlEstrang,@oCM,@oDlgLote,cMarca,;
																	@nTotal, @nHdlPrv, @lHdlPrv, @lPadraoBx,@cArquivo,@nValLiq,@cPadrao,;
																	@cHist,@oHist,@oAcresc,@oDecresc,@nAcrescF,@nDecrescF,;
																	aModalSpb,@oModSpb,lSpbInUse,@nTxMoeda,@oMultNat,@lMultNat,@nTotLtEZ,nTolerCp,aMotBx,;
																	@nPis,@nCoFins,@nCsll,@oPis,@oCoFins,@oCsll,lPccBaixa,@nOldValPgto,@nIrrf,@oIrrf,@nIss,;
																	@oIss,@cTipo,@oTipo,@nBaseIrpf, @dDataCan,@nInss,@oInss,@aTitCalc,@aCtBaixa,@aFlagCTB ),lEmBordero := F080EmBord() }) CENTERED
	Endif

Return lBaixou

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080OK
Verifica se dados digitados esta OK  	  
@author Wagner Xavier 
@since  26/05/1992
/*/
//-------------------------------------------------------------------
Function Fa080OK(cBanco,cAgencia,cConta,nValPgto,dBaixa,nJuros,nCM,nMulta,;
				 nDescont,nTotAbat,lMovBco,nValliq,aDescMotBx,lSpbinUse,nTxMoeda,nTolerCp,;
				 nPis,nCoFins,nCsll,nIrrf,nIss,nInss,nVA)

	Local nOrdSEF := SEF->(IndexOrd())

	DEFAULT nVa       := 0

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lSpbInUse := SpbInUse() .AND. VerCpoSPB()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se valor da baixa ‚ maior que o valor m ximo a receber       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF Str(nValPgto,17,2) > Str((xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoedaBco,dBaixa,3,nTxMoeda)+nJuros + nVa + nMulta-nDescont-nTotAbat+nAcresc-nDecresc+nTolerCp-nPis-nCoFins-nCsll-nIrrf-nIss-nInss),17,2)
		Help(" ",1,"ValorMaior")
		If ( SE2->E2_MOEDA == 1 )
			Return .F.
		EndIf
		//    Avisa o usuario, porém deixa o usuario efetuar a baixa
		//    pois ocorre de o cliente receber o mesmo numero de US$
		//    com a cotação acima a data cotacao diaria
	Endif

	// Valores acessórios.
	IF nVA > 0 .and. nValPgto - nJuros - nMulta + nDescont + nOtrga - nDifCambio - nTolerCp - nAcresc + nDecresc < nVA
		Help(" ",1,"VLRMENORQVA")
		Return .F.
	EndIf

	dbSelectArea("SE2")
	If Empty(cMotBx)
		cMotBx := aDescMotBx[nFirstRsn]  //NORMAL
	Endif
	IF Empty(dBaixa) .or. (nValPgto < 0 ) .or. Empty(cMotBx)
		Help(" ",1,"FA070INV")
		DbSelectArea("SE2")
		Return .F.
	EndIF

	IF (nTotAbat = 0 .and. nDescont = 0 .and. nDecresc = 0 .and. nPis = 0 .and. ;
		nCofins = 0 .and. nCsll = 0 .and. nIrrf = 0 .and. nIss = 0.and. nValPgto = 0) .or. ;
		(nValPgto=0.and.(nTotAbat+nDescont+nDecresc+nPis+nCofins+nCsll+nIrrf+nIss+nInss)!=xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoedaBco,dBaixa,,nTxMoeda))
		Help(" ",1,"FA070INV")
		Return .F.
	EndIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Caso motivo seja VENDOR, dever   ser contabilizado na baixa. 			   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF SE2->E2_IMPCHEQ != "S"
		IF ((MovBcoBx(cMotBx, .T.) .and. (Empty(dBaixa) .Or. Empty(cBanco) .Or. Empty(cConta))) .Or. ;
				( nValPgto < 0 ))
			Help(" ",1,"FA080VAZ")
			DbSelectArea ("SE2")
			Return .F.
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se cheque existe e nÆo foi gerado por rotina cheques s/Titulo   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF !Empty(cCheque) .and. Substr(cCheque,1,1) != "*" .and. !lChqPre .and. SE2->E2_IMPCHEQ != "S"
		nOrdSEF := SEF->(IndexOrd())
		SEF->(dbSetOrder(1))
		If SEF->(dbSeek(xFilial("SEF")+cBanco+cAgencia+cConta+cCheque))
			Help(" ",1,"CHEQEXIST")
			dbSelectArea("SE2")
			Return .F.
		Endif
		SEF->(dbSetOrder(nOrdSEF))
	Endif

	IF nValPgto < (nMulta+nJuros+nVA+nAcresc)
		Help(" ",1,"FA070INV")
		DbSelectArea("SE2")
		Return .F.
	Endif

	If TrazCodMot(cMotBx) == "VEN"
		IF (nValPgto-nAcresc+nDecresc) != nValLiq
			Help(" ",1,"FA080BXPARC")
			dbSelectArea("SE2")
			Return .F.
			// Verifica os dados preenchidos para geracao do titulo de vendor
		ElseIf !FA080VerVd()
			dbSelectArea("SE2")
			Return .F.
		Endif
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se modalidade do SPB é valida.								 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lSpbInUse
		cModSpb := Substr(cModSpb,1,1)
		IF !(SpbTipo("SE2",cModSpb,SE2->E2_TIPO))
			Return .f.
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se natureza tem mov bancario e vice versa de acordo com o motivo da baixa ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !FA080VlNat(cMotBx)
		Return .f.
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080But
Recarrega Variaveis 	  
@author Wagner Xavier 
@since  26/05/1992
/*/
//-------------------------------------------------------------------
Function Fa080But(nOpca,lMovBco,lBaixou,cTitulo,oTitulo,;
	cParcela,oParcela,cNomeFor,oNomeFor,;
	cBanco,oBanco,cAgencia,oAgencia,cConta,oConta,;
	oBaixa,oBenef,cHist070,oHist070,cMotBx,oMotBx,aDescMotBx,nValor,;
	oValor,nTotAbat,oTotAbat,nParciais,oParciais,oDescont,;
	oMulta,oJuros,oValPgto,oVlEstrang,oCM,oDlgLote,cMarca,;
	nTotal, nHdlPrv, lHdlPrv, lPadraoBx,cArquivo,nValLiq,cPadrao,;
	cHist,oHist,oAcresc,oDecresc,nAcrescF,nDecrescF,;
	aModalSpb,oModSpb,lSpbInUse,nTxMoeda,oMultNat,lMultNat,nTotLtEZ,nTolerCp,aMotBx,;
	nPis,nCoFins,nCsll,oPis,oCoFins,oCsll,lPccBaixa,nOldValPgto,nIrrf,oIrrf,nIss,;
	oIss,cTipo,oTipo,nBaseIrpf, dDataCan,nInss,oInss,aTitCalc,aCtBaixa,aFlagCTB)

	Local nSalvRec
	LOCAL lPadraoVd
	LOCAL cContabiliza := GETMV("MV_CTBAIXA")
	LOCAL lContabiliza
	Local cLanca	:= Iif(mv_par03==1,"S","N")
	Local lFa080tit := Existblock("FA080TIT")
	LOCAL lRet:=.T.
	Local nTamTitOri := TamParcela("E2_PARCELA",19,20,21)
	Local lOk := .F. //Controla se foi confirmada a distribuicao
	Local aColsSEV := {}
	Local lContabMnat
	Local nOldVlPis := 0
	Local nOldVlCof := 0
	Local nOldVlCsl := 0
	Local nOldVlIrf := 0
	Local lIRPFBaixa := IIf(	cPaisLoc = "BRA" , SA2->A2_CALCIRF == "2", .F.) .And. ;
								Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S" .And. ;
										!SE2->E2_TIPO $ MVPAGANT

	Local lCalcIssBx :=	IsIssBx("P")
	Local nI := 0
	Local aCopiaDesc
	Local aGrvLctPco := {	{"000005","03","FINA080"}, ;
							{"000005","04","FINA080"}  }	
	Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	Local nCentMd1	:= MsDecimais(1)
	Local aAreaSA2  := {}
	Local lFinVDoc	:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios
	Local lDtBaixa	:= .F.
	Local aPcc			:= {}
	Local llOpc		:= .F.
	Local aEaiRet	:= {}
	Local cIDMovE5  := ""
    Local aAreaCTB := {}
	Local lRetBor  := .T.

	DEFAULT nTxMoeda   := 0
	DEFAULT aTitCalc   := {}
	DEFAULT aCtBaixa   := {}
	DEFAULT aFlagCTB   := {}

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT __lEAIF080 := FWHasEAI("FINA080",.T.,,.T.)
    DEFAULT _lTemMR	   := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
    DEFAULT lFa080PCC  := ExistBlock("FA080PCC")
    DEFAULT lImp10925  := ExistBlock("FA080IMP")
    DEFAULT lPCCBaixa  := (SuperGetMv("MV_BX10925",.T.,"2") == "1")
    DEFAULT lSpbInUse  := SpbInUse() .AND. VerCpoSPB()
    DEFAULT nTamCodA6  := TamSX3("A6_COD")[1]

	If nOpca == 1

		If lBxLote .And. (nDescont+nMulta+nJuros > 0 .and. SE2->E2_IMPCHEQ == "S")
			If !Empty(AllTrim(cCheque))
				If !(Round(nValPgto,2) == Round(ValCheq(),2))
					Help(" ",1,"JACHQSTIT")
					nValPgto 	+= nDescont - (nJuros + nMulta)
					nValEstrang := Round(NoRound(xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
					nDescont	:= 0
					nMulta		:= 0
					nJuros		:= 0
					lBaixou := .F.
					Return lBaixou
				Endif
			Endif
		EndIf

		// Ponto de Entrada - para confirmacao da baixa
		If lFa080Tit
			lRet	:= ExecBlock("FA080TIT",.F.,.F.)
		Endif

		If !lRet
			Return lRet
		EndIf
		If MovBcoBx(cMotBx) .and. !CarregaSa6(cBanco,cAgencia,cConta,.T.,,.T.)
			Return .F.
		EndIf
		//Verifica se motivo de baixa para titulo cancelado possui movimentacao financeira
		If !FA080VlCan(SE2->E2_DATACAN, cMotBx)
			Return .F.
		EndIf

		//Verifica se motivo de baixa para titulo cancelado possui movimentacao financeira
		If !FA080VlCan(SE2->E2_DATACAN, cMotBx)
			Return .F.
		EndIf

		If !( FXVldBxBco( cBanco, cAgencia, cConta, SE2->E2_NATUREZ, SE2->E2_MOEDA ) )
			Return .F.
		EndIf

		// Verifica se data do movimento ‚ menor que data limite de movimentacao no financeiro
		If SuperGetMv("MV_BXDTFIN",,"1") == "2" .and.!DtMovFin(,,"1")
			Return
		Endif

		If !Fa080OK(cBanco,cAgencia,cConta,nValPgto,dBaixa,nJuros,;
			nCM,nMulta,nDescont,nTotAbat,lMovBco,nValLiq,aDescMotBx,lSpbInUse,;
			nTxMoeda,nTolerCp,nPis,nCoFins,nCsll,nIrrf,nIss,nInss,nVA)
			Return .F.
		EndIf

		// Caso esteja ligado o controle de solicitacao de notas de credito e exista alguma pendencia para este titulo
		If cPaisLoc <> "BRA"
			SCU->(DbSetOrder(2))
		Endif
		If cPaisloc <> "BRA" .And. SuperGetMv('MV_SOLNCP') .And. SE2->E2_TIPO == MVNOTAFIS ;
			.And. SCU->(MsSeek(xFilial()+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_NUM+SE2->E2_PREFIXO)).And. Empty(SCU->CU_NCRED)
			HELP(" ",1,"SOLNCPAB")
			Return .F.
		Endif

		nValPadrao := nValPgto-(nJuros+nVA+Iif(SE2->E2_MOEDA<=1,nCM,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc-If(!_lPccMR, (nPis+nCoFins+nCsll), 0))

		// Verifica se já possui data de baixa, indicando que ocorreram baixas no título anteriormente
		If EMPTY(SE2->E2_BAIXA)
			lDtBaixa := .F.
		Else
			lDtBaixa := .T.
		EndIf
		If !_lIrfMR .And. !lIRPFBaixa
			nValPadrao -= nIrrf
		EndIf

		If !_lIssMR .And. !lCalcIssBx
			nValPadrao -= nIss
		EndIf

		If Empty( cMotBx )
			cMotBx := aDescMotBx[nFirstRsn]  //NORMAL
		Endif
		// Identifica se contab. deve ocorrer na baixa ou geração de cheques e se
		// o tipo do titulo for PA e existir cheque deve ser contabilizado
		dbSelectArea("SEF")
		dbSetOrder(3)
		If SE2->E2_TIPO $ MVPAGANT .and. SEF->(dbseek(xFilial("SEF")+SE2->E2_PREFIXO+SE2->E2_NUM+;
				SE2->E2_PARCELA+SE2->E2_TIPO))
			lContabiliza := .T.
		Else
			lContabiliza := IIf(cContabiliza = "B" .Or. cContabiliza = "A", .T., .F.)
		EndIf
		SEF->( dbSetOrder(1))

		// Verifica onde ocorrer  a contabilização
		// Se for informado num. do cheque, deve contabilizar pela baixa
		// Se não informou num. do cheque ou num. cheque come‡ar com "*" na geração
		If (!Empty( cCheque ) .and. SubStr( cCheque, 1, 1 ) != "*" .and. SE2->E2_IMPCHEQ != "S") .or. ;
			cContabiliza = "B" .Or. cContabiliza = "A" .or. ;
			cBanco $ Left(GetMv("MV_CXFIN"),nTamCodA6) .or. cBanco$GetMV("MV_CARTEIR")
			lContabiliza := .T.
		Endif
		// Caso motivo seja VENDOR, deverá ser contabilizado na baixa.
		If TrazCodMot(cMotBx) $ "VEN/DEB"
			lContabiliza := .T.
		EndIF

		If MovBcoBx(cMotBx, .T.) .and. !ChqMotBx(cMotBx)
			lContabiliza := .T.
		EndIF

		//Não contabilizar baixas de títulos de origem PLS
		If "PLS" $ SE2->E2_ORIGEM
			lContabiliza := .F.
		EndIf

		// Soma nos totalizadores
		nTotAGer  += nValPgto
		nTotADesc += nDescont+nDecresc
		nTotAMul  += nMulta
		nTotAJur  += nJuros+nAcresc
		nTotADesp += Iif(SE2->E2_MOEDA<=1,nCM,0)
		cPadrao   := "530"
		//----------------------------------------------------------------------
		// Contabiliza se existir o lan‡amento e:
		//  - a contabilização for feita na baixa (parâmetro MV_CTBAIXA) ou
		//  - se digitou numero de cheque ou se a contabilização for on-line
		//  Verifica existencia do lan‡amento padrão da baixa e/ou do geração
		//  do título referente ao Vendor.
		//  Lançamento Padrão referente a baixa   := "530"
		//  Lançamento Padrão referente ao Vendor := "518"
		//----------------------------------------------------------------------
		lPadraoBx := VerPadrao(cPadrao) .And. lContabiliza
		lPadraoVd := VerPadrao( "518" ) .And. lContabiliza
		VALOR := 0
		ABATIMENTO := nTotAbat
		nRegSE2:= SE2->(Recno())
		cNumBor := SE2->E2_NUMBOR

		If MV_MULNATP .and. lMultNat
			MultNatB("SE2",.F.,STR(mv_par05,1),@lOk,@aColsSEV,@lMultNat)
		Endif

		// Inicializa a gravacao dos lancamentos do SIGAPCO
		PcoIniLan("000005")

		// Inicio da proteção TTS.
		Begin Transaction
			aAreaSA2 := SA2->(GetArea())
			
			lBaixou :=	fa080Grv(lPadraoBx,lPadraoVd,,cLanca,,nTxMoeda,,,lMultNat,,,@aCtBaixa,aTitCalc)
			
			If !lBaixou
				DisarmTransaction()
				Break
			EndIf

			RestArea(aAreaSA2)
			IF lBaixou
				// Grava título do IRRF e informações relacionadas quando IRPF na Baixa
				If _lIrfMR .And. lIRPFBaixa
					RestArea(aAreaSA2)
					RecLock("SE2")
					SE2->E2_VRETIRF += If(_nIrfMR, _nIrfMR, nIrrf)
					If SA2->A2_TIPO == "F"
						If lDtBaixa
							SE2->E2_IRRF += If(_nIrfMR, _nIrfMR, nIrrf)
						Else
							SE2->E2_IRRF := If(_nIrfMR, _nIrfMR, nIrrf)
						EndIf
					Endif
					MsUnlock()
				Else
					// Caso tenha havido retenção na inclusão do pagamento
					//antecipado efetua a exclusão do título de IR (TXA)
					If SE2->E2_TIPO $ MVPAGANT .And. SE2->E2_IRRF > 0
						F241DelTxIR("FINA080",SE2->(Recno()),SE2->E2_IRRF)
					EndIf
				EndIf

				/* Gravação do valor retido de ISS na Baixa */
				If _lIssMR .And. lCalcIssBx
					RecLock("SE2")
					SE2->E2_VRETISS += If(_lIssMR, _nIssMR, nIss)
					SE2->(MsUnlock())
				EndIf

				If !_lPccMR .And. lPccBaixa
					If !_lPccMR
						nOldVlPis := SE2->E2_PIS
						nOldVlCof := SE2->E2_COFINS
						nOldVlCsl := SE2->E2_CSLL
						nOldVlIrf := SE2->E2_IRRF
						nOldVlIss := SE2->E2_ISS
					EndIf

					Reclock("SE2")
					If !_lPccMR
						SE2->E2_VRETPIS += nPis
						SE2->E2_VRETCOF += nCofins
						SE2->E2_VRETCSL += nCsll
					Else
						SE2->E2_VRETPIS += _nPisMR
						SE2->E2_VRETCOF += _nCofMR
						SE2->E2_VRETCSL += _nCslMR
					EndIf
					MsUnlock()
				Endif

				// Verifica se esta utilizando multiplas naturezas
				// Chama rotina de gravacao do SEV e SEZ
				If MV_MULNATP .and. lMultNat .and. lOk
					lContabMNat := lContabiliza .and. mv_par03 == 1
					
					MultNatC("SE2" /*cAlias*/, @nHdlPrv /*@nHdlPrv*/, @nTotal /*@nTotal*/, @cArquivo /*@cArquivo*/, lContabMNat /*lContabiliza*/, .T. /*lBxLote*/, STR( mv_par05, 1 ) /*cReplica*/,;
								@nTotLtEZ /*nTotLtEZ*/, lOk /*lOk*/, aColsSEV /*aCols*/, lBaixou /*lBaixou*/, aGrvLctPco /*aGrvLctPco*/, lUsaFlag /*lUsaFlag*/, @aFlagCTB /*@aFlagCTB*/	)
					
					lHdlPrv := nHdlPrv > 0
				Endif

				//Reposiciono o arquivo de bancos para a contabilizacao
				SA6->(DbSetOrder(1))
				SA6->(dbSeek(xFilial()+cBanco+cAgencia+cConta))

				//Reposiciono o arquivo de fornecedores para a contabilizacao
				SA2->(dbSetOrder(1))
				SA2->(MsSeek(xFilial("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA))

				IF ( lPadraoBx .or. lPadraoVd ) .and. cLanca == "S" .and. !lHdlPrv
					nHdlPrv := HeadProva( cLote, "FINA080" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
					lHdlPrv := .T.
				Endif

				IF lPadraoBx .and. cLanca == "S" .and. !lMultNat
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						cIDMovE5 := SE5->E5_IDORIG 
						aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )

						aAreaCTB := SE5->(GetArea())
						DbSelectArea("SE5")
						SE5->(DbSetOrder(21))
						If SE5->(DbSeek(xFilial("SE5")+ cIDMovE5))
							While SE5->(!EoF()) .and. SE5->E5_IDORIG == cIDMovE5
								If SE5->E5_TIPODOC  $ "JR|DC|VA|MT"
									aAdd( aFlagCTB, {"E5_LA" , "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
								EndIf
								SE5->(DbSkip())
							EndDo
						EndIf
						RestArea(aAreaCTB)	
					Endif
					
					nTotal += DetProva( nHdlPrv, cPadrao, "FINA080" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/,;
										/*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
				Endif
				
				IF lPadraoVd .and. cLanca == "S" .and. TrazCodMot(cMotBx) == "VEN" .and. !lMultNat
					dbSelectArea( "SE2" )
					IF (dbSeek( cFilial +  Left(SE2-> E2_TITORIG,nTamTitOri) ) )
						If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
							aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
							aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
						Endif
						
						nTotal += DetProva( nHdlPrv, "518" /*cPadrao*/, "FINA080" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/,;
						/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
					Endif
				Endif
				
				If lPccBaixa
					Reclock("SE2")
					SE2->E2_PIS := nOldVlPis
					SE2->E2_COFINS := nOldVlCof
					SE2->E2_CSLL := nOldVlCsl
					MsUnlock()
				Endif

				PcoDetLan("000005","01","FINA080")
			Endif

			If !lFini055 .and. __lEAIF080
				llOpc  := ALTERA
				ALTERA := .T.  // Baixa de título.

				aEaiRet := FWIntegDef('FINA080',,,, 'FINA080')
				If !aEaiRet[1]
					Help(" ", 1, "HELP", STR0217, STR0218 + CRLF + aEaiRet[2], 3, 1)  // "Erro EAI" / "Problemas na integração EAI. Transação não executada."
					DisarmTransaction()
				Endif

				ALTERA := llOpc
			Endif
		End Transaction

		//Envio de e-mail pela rotina de checklist de documentos obrigatorios
		IF lFinVDoc
			CN062ValDocs("04",.F.,.T.)
		EndIf

		// Finaliza a gravacao dos lancamentos do SIGAPCO
		PcoFinLan("000005")

		// Pontos de Entrada
		If (ExistTemplate( "FA080PE" ) )
			ExecTemplate("FA080PE",.F.,.F.)
		Endif
		If (ExistBlock( "FA080PE" ) )
			ExecBlock("FA080PE",.F.,.F.)
		Endif

		If FindFunction("NGBAIXASE2") .And. GetNewPar( "MV_NGMNTFI","N" ) == 'S'
			NGBAIXASE2(1)

			//--------------------------------------------
			// Função que gera uma apropriação de débito
			// da multa, (Integração SIGAFIN - SIGAMNT).
			//---------------------------------------------
			If FindFunction( "MNT765CONF" ) //Se for executado a baixa automática de pagaento da multa;
				lPagAutFin := .F. //Variável utilizada em fonte especifico do SIGAMNT;
				MNT765CONF( 3 ) 	//Executa a função que gera APD;
			EndIf

		Endif

		dbSelectArea("SE2")
		dbGoTo(nRegSE2)
	Else
		// Limpa marca para titulo com baixa abortada.
		dbSelectArea("SE2")
		Begin Transaction
			RecLock ("SE2",.F.)
			Replace E2_OK with ""
		End Transaction
	Endif

	While SE2->(!Eof())
		If SE2->E2_OK != cMarca
			If SE2->E2_OK == "xx"
				SE2->(dbSKip())
				nProxRec := SE2->(Recno())
				SE2->(dbSkip(-1))
				RecLock ("SE2",.F.)
				Replace E2_OK with ""
				dbGoto(nProxRec)
			Else
				SE2->(dbSKip())
			Endif
		Else
			Exit
		Endif
	EndDo

	If SE2->(Eof())
		If lIsRussia
			DBGoBottom()
		EndIf
		oDlgLote:End()
		Return lBaixou
	EndIf

	//Posiciona Fornecedor no SA2
	dbSelectArea("SA2")
	SA2->(dbSeek(xFilial("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA))

	SED->(DbSetOrder(1))
	SED->(DbSeek(xFilial("SED")+SE2->E2_NATUREZ))

	_nBasLeg   := 0
	__BordeImp := IIf(__BordeImp == Nil, FindFunction("BorderoImp"), __BordeImp)
	
	If __BordeImp .And. !Empty(SE2->E2_NUMBOR) .And. !SE2->E2_TIPO $ MVPAGANT+"|"+MVPROVIS+"|"+MV_CPNEG
		lRetBor := !BorderoImp(SE2->E2_FILORIG, SE2->E2_NUMBOR, "P", SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA)	 
	Endif
	
	lRetBor := IIf(__BordeImp, lRetBor, VLDBOR(SE2->E2_NUMBOR,"P",cFilAnt))	
	
	//Motor de retenções.
	If _lTemMR
		F080VldImp(.F.)
	EndIf

	lIRPFBaixa := IIf(cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.) .And. ;
	Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S" .And. !SE2->E2_TIPO $ MVPAGANT

	lIRProg := IIf( cPaisLoc = "BRA" , IIf(!Empty(SA2->A2_IRPROG), SA2->A2_IRPROG, "2"), "2")

	dbSelectArea("SE2")

	//Carrega Variaveis da Baixa
	nSalvRec    := RecNo()
	cTitulo		:= SE2->E2_PREFIXO + " " + SE2->E2_NUM+ " " + SE2->E2_PARCELA
	cParcela    := SE2->E2_PARCELA
	cTipo		:= SE2->E2_TIPO
	dEmissao    := SE2->E2_EMISSAO
	dVencRea    := SE2->E2_VENCREA
	cNomeFor    := SE2->E2_FORNECE + " - " + Subst(SA2->A2_NOME,1,40)
	cHist		:= SE2->E2_HIST
	dBaixa      := CriaVar("E2_BAIXA")
	dDebito		:= dDatabase

	If cPaisLoc == "BRA"
		nTxMoeda	 := If(SE2->E2_MOEDA > 1,If(SE2->E2_TXMOEDA > 0, SE2->E2_TXMOEDA,RecMoeda(dBaixa,SE2->E2_MOEDA)),0)
	Endif

	dDtCredito  := dDataBase
	cHist070    := Criavar("E5_HISTOR")		//Inicilizador padrao

	If Empty(cHist070)
		cHist070 := OemToAnsi(STR0007)+Space(Len(cHist070)-24)  // "Valor recebido s/ T¡tulo"
	Endif

	nValor	    := SE2->E2_VALOR
	nTotAbat    := SumAbatPag(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_FORNECE,SE2->E2_MOEDA,"S",dBaixa,SE2->E2_LOJA)

	dbGoto(nSalvRec)
	nParciais   := SE2->E2_VALOR-SE2->E2_SALDO
	nDescont    := 0
	nMulta      := 0
	nJuros      := 0
	nVA			:= 0
	nAcrescF 	:= SE2->E2_SDACRES
	nDecrescF	:= SE2->E2_SDDECRE
	nAcresc		:= Round(Noround(xMoeda(SE2->E2_SDACRES,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
	nDecresc	:= Round(Noround(xMoeda(SE2->E2_SDDECRE,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)

	// Para titulos de vendor antigos
	If STR(SE2->E2_VALOR,17,2) == STR(SE2->E2_SALDO,17,2) .and. SE2->E2_SDACRES == 0 .and. SE2->E2_ACRESC > 0
		nAcresc	:= Round(Noround(xMoeda(SE2->E2_ACRESC,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
		nAcrescF := SE2->E2_ACRESC
	Endif

	// Ponto de entrada para alterar o valor do acrescimo
	If ExistBlock("F080ACRE")
		ExecBlock("F080ACRE",.F.,.F.)
	EndIF

	nPis			:= 0
	nCofins			:= 0
	nCsll			:= 0
	nVlRetPis		:= 0
	nVlRetCof		:= 0
	nVlRetCsl		:= 0
	nValPgto		:= 0
	nOldJuros		:= 0
	nOldMulta		:= 0
	nOldDescont		:= 0
	nOldValPgto		:= 0
	nDiferImp		:= 0
	nIrrf			:= 0
	nIss			:= 0
	lBaixou			:= .F.
	nValPgto		:= Round(Noround(xMoeda(SE2->E2_SALDO-nTotAbat,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)+nMulta+nJuros+nVA-nDescont+nAcresc-nDecresc-;
								If(!_lPccMR, (nPis+nCoFins+nCsll), 0) - If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0)

	nOldValPgto 	:= nValPgto

	//IRRF - BAIXA
	nVlRetIrf		:= 0
	aDadosIr		:= Array(3)
	aFill(aDadosIR,0)

	aDadosRef := Array(7)
	AFill( aDadosRef, 0 )

	//Reestruturacao SE5
	nDescCalc 	:= 0
	nJurosCalc 	:= 0
	nVACalc 	:= 0
	nMultaCalc 	:= 0
	nCorrCalc	:= 0
	nDifCboCalc	:= 0
	nImpSubCalc	:= 0
	nPisCalc	:= 0
	nCofCalc	:= 0
	nCslCalc	:= 0
	nIrfCalc	:= 0
	nIssCalc	:= 0
	nPisBaseR 	:= 0
	nCofBaseR	:= 0
	nCslBaseR 	:= 0
	nIrfBaseR 	:= 0
	nIssBaseR 	:= 0
	nPisBaseC 	:= 0
	nCofBaseC 	:= 0
	nCslBaseC 	:= 0
	nIrfBaseC 	:= 0
	nIssBaseC 	:= 0
	nCidBase	:= 0

	F080IssBx()

	//Calcula Impostos pela Baixa
	If !_lIrfMR .And. lIRPFBaixa
		nIRRF := FCalcIRBx(0, SA2->A2_TIPO, dBaixa, dDebito, /*lAltValor*/, /*nTxmoeda*/, cMotBx)
		nOldValPgto := nValPgto
	Endif

	If Type("lEmpPub") <> "L"
		lEmpPub	:= IsEmpPub()
	EndIf

	If lPccBaixa
		fA080Data(/*nTxMoeda*/, /*lButOk*/, /*lHelp*/, /*oDtBaixa*/,aTitCalc)
		If (dBaixa < dLastPcc .Or. lEmpPub)
			f080TotMes(dBaixa,.T.,,.F.)
		Else
			If lRetBor .And. !SE2->E2_TIPO $ MVPAGANT+"/"+MVPROVIS
				nSalImp := _nBasLeg 
				
				If Empty(nSalImp)
					nSalImp := salRefPag(SA2->A2_COD+SA2->A2_LOJA,_lPccMR, _lIrfMR, _lInsMR, _lIssMR, _lCidMR, _lSesMR)
				EndIf

				If SE2->E2_MOEDA > 1
					nSalImp := xMoeda(nSalImp,SE2->E2_MOEDA,1,dBaixa,,SE2->E2_TXMOEDA)
				EndIf
				
				nSalImp += F080JuMuDe()
				
				If !_lPccMR
					aPcc    := newMinPcc(dDataBase, nSalImp, SED->ED_CODIGO, "P", SA2->A2_COD + SA2->A2_LOJA, /*nIss*/, /*nIns*/, /*nIrf*/, /*lMin*/, /*lIgnrOrg*/, cMotBx,,nTxmoeda)
					nPis    := aPcc[2]
					nCofins := aPcc[3]
					nCsll   := aPcc[4]
					If len(aPCC)>4
						aTitCalc := aPCC[5]
					Endif
				EndIf
			Else
				nPis	:= 0
				nCofins := 0
				nCsll	:= 0
			EndIf
		EndIf
		
		If lFa080PCC
			ExecBlock("FA080PCC",.F.,.F.,{nPis, nCofins, nCsll, nIrrf, nSalImp})
		Endif

		//Ponto de entrada para manipular os valores de impostos(nPis, nCofins, nCsll)
		If lImp10925 .and. (nPis+nCofins+nCsll) > 0
			ExecBlock("FA080IMP",.F.,.F.)
		EndIf
	Endif

	// Cálculo de valores acessórios.
	nVa	:= FValAcess(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NATUREZ, /*lBaixados*/,/*cCodVa*/,"P",dBaixa,/*aValAces*/,SE2->E2_MOEDA,nMoedaBco,nTxMoeda)

	If Type("nVlMPub") <> "N"
		nVlMPub	:= 	SuperGetMv("MV_VLMPUB" ,.T.,10)
	EndIf

	If Type("lAplMinP") <> "L"
		lAplMinP := .F.
		If SA2->A2_MINPUB == "2"
			lAplMinP := .T.
		EndIf
	EndIf

	If lEmpPub .And. lAplMinP .And. lIRPFBaixa .And. (nPis+nCoFins+nCsll+nIrrf+aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5]< nVlMPub  .And. ;
		!(aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] == 0 .And. aDadosRet[1] > 0))
		nPis := nCoFins := nCsll := nIrrf := 0
	EndIf

	fa080Val(nValPgto,nTxMoeda,,,,,,aTitCalc)
	cMoeda 	   := IIF(Empty(SE2->E2_MOEDA),"1",AllTrim(Str(SE2->E2_MOEDA,2)))
	cDescMoeda := SubStr(GetMV("MV_SIMB"+cMoeda),1,3)
	cTexto1	   := OemToAnsi(STR0084) + SubStr(GetMV("MV_SIMB"+cMoeda),1,3)  //"Valor Original "
	cTexto2	   := OemToAnsi(STR0042) + SubStr(GetMV("MV_SIMB"+cMoeda),1,3) //"Valor "

	If Type("oTexto1")=="O"
		oTexto1:Refresh()
	Endif

	If Type("oTexto2")=="O"
		oTexto2:Refresh()
	Endif

	If SE2->E2_IMPCHEQ == "S"  // Cheque s/ Titulo
		cCheque		:= SE2->E2_NUMBCO
	Else
		cCheque		:= CRIAVAR("E2_NUMBCO")
	Endif

	nValTot	    := SE2->E2_VLCRUZ
	nValEstrang := nValOrig	  := SE2->E2_SALDO-nTotAbat
	nEstOriginal:= nValEstrang-(xMoeda(nJuros+nVA+nMulta-nDescont,nMoedaBco,SE2->E2_MOEDA,,3,,nTxMoeda))
	nValMoeda   := Round(Noround(xMoeda(nValOrig,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
	nValMoeda1  := Round(NoRound(xMoeda(SE2->E2_VALOR-nTotAbat,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
	nValPgto    := nValMoeda+nMulta+nJuros+nVA-nDescont+nAcresc-nDecresc-nPis-nCoFins-nCsll-nIrrf-nIss-nInss-_nImpMR

	nOldValPgto := nValPgto
	IF (nMulta+nJuros+nDescont+nAcresc+nDecresc+nPis+nCoFins+nCsll+nIrrf+nIss) > 0 .or. Round(nValEstrang - xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,3,,nTxMoeda),2 ) > 0.01
		nValEstrang := Round(NoRound(xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
	EndIF
	FA080Corr(nEstOriginal,nTxMoeda)
	nValLiq	    := nValPgto-nMulta-nJuros-nVA+nDescont-nAcresc+nDecresc+nPis+nCoFins+nCsll+nIrrf+nIss+nInss

	cBenef	    := CriaVar("E5_BENEF")

	//³Analisa se o titulo foi gerado a partir de um cheque pre datado
	lChqPre := .f.
	dbSelectArea("SE5")
	dbSetOrder(2)
	If SE5->(dbSeek( xFilial("SE5") + "CD" + SE2->E2_PREFIXO + ;
			SE2->E2_NUM + SE2->E2_PARCELA + SE2->E2_TIPO + dToS(SE2->E2_EMISSAO )+;
			SE2->E2_FORNECE + SE2->E2_LOJA ))

		lChqPre := .T.
		cBanco   := SE5->E5_BANCO
		cAgencia := SE5->E5_AGENCIA
		cConta   := SE5->E5_CONTA
		cCheque  := SE5->E5_NUMCHEQ
		cBenef   := SE5->E5_BENEF
	EndIf

	If Empty(cBenef)
		dbSelectArea("SA2")
		SA2->(dbSeek(cFilial+SE2->E2_FORNECE+SE2->E2_LOJA))
		dbSelectArea("SE2")
		cBenef   := SA2->A2_NOME
	Endif

	lMultNat		:= .F.

	IF ExistBlock("F080MNAT")
		lMultNat := ExecBlock("F080MNAT",.f.,.f.)
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Pesquisa o codigo do motivo da baixa e atribui a descricao do motivo da baixa            ³
	//³a variavel cMotBx, pois eh assim que o ComboBox le os motivos da baixa (pela descricao). ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(CriaVar("E5_MOTBX"))
		cMotBx := CriaVar("E5_MOTBX")
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Retorna o Array aDescMotbx contendo apenas a descricao do  ³
	//³ motivo das Baixas. 						  				   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aCopiaDesc := aDescMotBx
	aDescMotbx := {}
	For NI := 1 to Len(aMotBx)
		AADD( aDescMotbx,Substr(aMotBx[nI],07,10))
	Next

	nAscan := Ascan(aMotBx,{|e| AllTrim(Upper(cMotBx))==AllTrim(Upper(Substr(e,7,10)))})
	cMotBx := If(Empty(cMotBx) .Or. nAscan = 0,aDescMotBx[nFirstRsn],aDescMotBx[nAscan]) 	//NORMAL
	aDescMotBx := aCopiaDesc
	Fa080BDev()

	//Reestruturacao SE5
	//Obtenho os valores calculados de juros, multas, descontos etc
	nDescCalc 	:= nDescont + nDecresc
	nJurosCalc 	:= IIf(cPaisLoc<>"CHI",nJuros + nAcresc,nOtrga)
	nVACalc 	:= nVA
	nMultaCalc 	:= nMulta
	nCMCalc		:= IIf(cPaisLoc<>"CHI",nCM,nDifCambio)
	nDifCambio	:= nDifCambio
	nImpSubCalc	:= nImpSubst

	oTitulo :Refresh()
	oNomeFor:Refresh()
	oTipo:Refresh()
	oBanco  :Refresh()
	oBanco  :SetFocus()
	oAgencia:Refresh()
	oConta  :Refresh()
	oCheque :Refresh()
	oBaixa  :Refresh()
	oHist070:Refresh()
	oMotBx  :Refresh()
	oValor  :Refresh()
	oTotAbat:Refresh()
	oParciais:Refresh()
	oDescont:Refresh()
	oMulta  :Refresh()
	oJuros  :Refresh()
	oValPgto:Refresh()
	oBenef  :Refresh()
	oHist   :Refresh()
	oAcresc :Refresh()
	oDecresc:Refresh()

	
	If MV_MULNATP
		oMultNat:Refresh()
	Endif

	If SE2->E2_MOEDA > 1 .And. Type("oValEstrang") == "O"
		oVlEstrang:Refresh()
		oCM:Refresh()
	Endif

	If cPaisLoc == "BRA"
		If lIRPFBaixa
			oIrrf:Refresh()
		Endif
		//Tratamento de impostos Pis Cofins e Csll na baixa
		If (!_lTemMR .Or. !_lPccMR) .and. lPccBaixa
			oPis	:Refresh()
			oCofins	:Refresh()
			oCsll	:Refresh()
		Endif
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Pr‚-inicializa a modalidade de SPB                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lSpbInUse
		If !Empty(SE2->E2_MODSPB)
			cModSpb := SE2->E2_MODSPB
		Else
		cModSpb := "1"
		Endif
		oModSpb:Refresh()
	Endif
	fa080ChkVdr()

Return lBaixou

//-------------------------------------------------------------------
/*/{Protheus.doc}fA080Data
Funcao utilizada para consistir a Data  
@author Wagner Xavier 
@since  26/05/1992
/*/
//-------------------------------------------------------------------
Function fA080Data(nTxMoeda, lButOk, lHelp, oDtBaixa,aTitCalc)
	LOCAL lRet			:=	.T.
	Local cNomeCpo		:=	'E2_EMISSAO'
	Local lFINA080MN 	:= FWIsInCallStack("FA080TIT")

	DEFAULT nTxMoeda   :=	0
	DEFAULT lButOk     := .F.  //Se a chamada da funcao foi feita do botao OK
	DEFAULT lHelp      := .F.
	DEFAULT oDtBaixa   := NIL
	DEFAULT aTitCalc   := {}

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT __lPodeTVA := ExistFunc("FAPodeTVA")
	
	If ExistBlock("F080FILEMI")
		cNomeCpo := ExecBlock("F080FILEMI",.F.,.F.,{})
		If SE2->(FieldPos(cNomeCpo)) ==0
			cNomeCpo := 'E2_EMISSAO'
		EndIf
	EndIf

	//Valores Acessórios
	If __lExistVA == NIL
		__lExistVA 		:= TableInDic("FKD") .and. TableInDic("FKC") .and. FindFunction("FINA080VA")
	EndIF

	IF dBaixa < SE2->(&cNomeCpo)
		IF lHelp
			Help( " ", 1, "DATAERRP",, STR0150,1,0 ) //"Data do pagamento não pode ser menor que a data de emissâo do título correspondente"
		Endif
		lRet := .F.
	Endif

	If lRet .and. ExistBlock("FA080DT")
		lRet := ExecBlock("FA080DT", .F., .F., dBaixa)
	EndIf

	//Quando chamado do botao ok, nao efetuar os calculos novamente
	If !lButOk .and. lRet
		dbSelectArea("SE2")

		If cPaisLoc == "BRA"
			If (nT := ascan(aAutoCab, {|x| x[1] == "AUTTXMOEDA"}) ) > 0
				nTxMoeda :=	Iif(nTxMoeda == 0, aAutoCab[nT,2], nTxMoeda)
			Else			
				nTxMoeda := RecMoeda(dBaixa, SE2->E2_MOEDA)
				
				If nMoedaBco > 1 .And. SE2->E2_MOEDA != nMoedaBco  
					nTxMoeda := RecMoeda(dBaixa, nMoedaBco)
				ElseIf (SE2->E2_MOEDA == 1) .Or. (SE2->E2_TXMOEDA > 0 .And. Empty(SE2->E2_DTVARIA))
					nTxMoeda := SE2->E2_TXMOEDA
				Endif
			EndIf

			__nTxMoeda := nTxMoeda
		EndIf	

		If ( Len(_aImpMR) == 0 .or. ( Len(_aImpMR) > 0 .and. nJuros == 0 ) ) .And.  FunName() <> "FINA631"
			fa080Juros(nMoedaBco, , ,,nTxMoeda)
		EndIf		
		
		If FwIsInCallStack("FA080TIT") .And. nJuros == 0 .And. (SE2->E2_VALJUR == 0 .Or. SE2->E2_PORCJUR == 0)
			nJuros := nOldJuros
		EndIf

		// Recalcula o valor acessório.
		If __lPodeTVA .and. __lExistVA
			//-----------------------------------------------------------------------------
			// Cálculo de Valores Acessorios
			//-----------------------------------------------------------------------------
			// Se for baixa MANUAL, o calculo de VA será feito AQUI
			If lFINA080MN
				If !lF080Auto .and. (Empty(cOldVA) .or. (!Empty(oDtBaixa) .AND. oDtBaixa:lModified))
					//Caso se modifique a data de baixa, será refeito o cálculo de VA
					If (!Empty(oDtBaixa) .AND. oDtBaixa:lModified)
						cOldVa := ""
					Endif

					//O Model realiza os cálculos VA
					oModelVA := FWLoadModel("FINA080VA")
					oModelVA:SetOperation( MODEL_OPERATION_UPDATE )
					oModelVA:Activate()
					cOldVA  := oModelVA:GetXMLData()
					oModelVa:Deactivate()
					oModelVa:Destroy()
					oModelVa := NIL
				Elseif !Empty(cOldVa) .and. nVa == 0
					//O Model realiza os cálculos VA
					oModelVA := FWLoadModel("FINA080VA")
					oModelVA:SetOperation( MODEL_OPERATION_UPDATE )
					oModelVA:Activate()
					oModelVA:LoadXMLData( cOldVA )
					FN080VAGrv( oModelVA )
					oModelVa:Deactivate()
					oModelVa:Destroy()
					oModelVa := NIL
				Endif
			Else
				nVa	:= FValAcess(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, /*lBaixados*/, /*cCodVa*/, "P", dBaixa, /*aValAces*/, SE2->E2_MOEDA, nMoedaBco, nTxMoeda)
			Endif
		Endif

		// Recalcula o total da baixa.
		fa080Val(1, nTxMoeda,,, .T.,,,aTitCalc)
	EndIF

	If lButOk .and. lRet .And. nValPgto < 0 
		Help(" ",1,"FA070INV")
		lRet := .F.
	EndIf


	If lRet
		dOldData := dBaixa
	Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fA080Dbeva
Trata o dbeval para marcar e desmarcar item 
@author Wagner Xavier 
@since  26/05/1992
/*/
//-------------------------------------------------------------------
Function fA080Dbeva()
	Local lSavTTS
	Local lBxTit 	:= .T.
	Local lBxTitVL	:= .T.
	Local nSaldo 	:= xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoedaBco)

	IF nValor <= nTotGer .And. nValor+nSaldo <= nTotGer .And. nQtdtit <= nNroTit
		lSavTTS := __TTSInUse
		__TTSInUse := .f.

		RecLock("SE2",.f.)
		SE2->E2_OK := cMarca
		SE2->(MsUnlock())
		lBxTit := .T.
		lBxTitVL := .T.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PONTO DE ENTRADA F080BXLT                                     ³
		//³ Verifica se titulo pode ser marcado para baixa ou nÆo. Caso	  ³
		//³ tenha sido alterada a marca‡Æo do titulo, ExecBlock dever     ³
		//³ retornar .F., para nÆo haver altera‡Æo dos acumuladores de    ³
		//³ valores e numero de titulos.                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF (ExistBlock("F080BXLT")) .and. !Empty(E2_OK)
			lBxTit := ExecBlock("F080BXLT",.F.,.F.)
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de entrada que permite ao usuário determinar se um    ³
		//³título deve ou não ser selecionado, de acordo com as regras ³
		//³estabelecidas no ponto de entrada.  O PE F080BXLT não       ³
		//³controlava a marcação dos títulos, sendo necessário criar   ³
		//³este novo PE por questão de legado. Retorno .F. impede sel. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (ExistBlock("F080BXVL")) .and. !Empty(E2_OK)
			lBxTitVL := ExecBlock("F080BXVL",.F.,.F.)
			If ValType(lBxTitVL) == "L" .AND. !lBxTitVL
				If SE2->E2_OK == cMarca
					RecLock("SE2",.F.)
					SE2->E2_OK := "  "
					SE2->(MsUnlock())
				Endif
			Else
				lBxTitVL := .T.
			Endif
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Caso tenha integracao SIGAPFS (MV_JURXFIN = .T.), valida as regras para manipulação do título.  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lBxTitVL .And. !Fa080Juri(.F., .F.)
			RecLock("SE2",.F.)
			SE2->E2_OK := "  "
			SE2->(MsUnlock())
			lBxTitVL := .F.
		EndIf

		__TTSInUse := lSavTTS
		If lBxTit .AND. lBxTitVL
			nValor+=nSaldo
			nQtdtit++
		Endif
	Else
		lSavTTS := __TTSInUse
		__TTSInUse := .f.
		RecLock("SE2",.f.)
		SE2->E2_OK := "  "
		SE2->(MsUnlock())
		__TTSInUse := lSavTTS
	EndIF
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc}fa080ValVR
Funcao utilizada para consistir o valor digitado 
@author Antonio Maniero Jr.
@since  13/05/1994
/*/
//-------------------------------------------------------------------
Function fa080ValVR(nTxMoeda,nTolerCp,lCalcRet,lIRPFBaixa,lAtOldPgto,lBaixou,aTitCalc)
	Local nCentMd1   := MsDecimais(1)
	Local lRet       := .F.
	Local lAltValor  := .F.
	Local nTxMdaOr	 := 0
	Local nSalImp    := 0
	Local lJurMulDes := (SuperGetMv("MV_IMPBAIX",.t.,"2") == "1")
	Local nPgAux	 := 0
	Local aImp		 := {nIrrf,nPis,nCofins,nCsll,nIss,nInss}
	Local aPcc		 := {}
	Local lInssBx    :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
	Local lMVBP10925 := SuperGetMv("MV_BP10925",.F.,"1") == "2" // 1- Valor bruto da baixa parcial / 2- Valor da baixa parcial menos os impostos.
	Local lCideBX    := cPaisLoc == "BRA" .And. SuperGetMv("MV_FGCIDE",.T.,"2") == "1" // Define o fato gerador do imposto CIDE. 1 = Baixa ou 2 = Emissão
	Local lIRProg 		:= IIf( cPaisLoc == "BRA"  , IIf(!Empty(SA2->A2_IRPROG), SA2->A2_IRPROG, "2"), "2")
	Local nInss			:= Iif(SuperGetMv("MV_INSIRF",.F.,"2") == "2" .And. (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1")),SE2->E2_INSS,0)//Valor do INSS descontado na emissão
	Local lJaSubtPCC := .F.
	Local lCalcIssBx :=	IsIssBx("P") .And. !SE2->E2_TIPO $ MVPAGANT
	Local lMVCNBImpg := GetNewPar("MV_CNBIMPG",.F.)
	Local nValSaldo  := 0
	Local lValidImp  := .T.
	Local lReadVar	 := VALTYPE(__ReadVar) == "C"
	Local nCasDec    := TamSx3("E2_TXMOEDA")[2]
	Local lRetBor    := .T.
	
	DEFAULT nTxMoeda   := 0
	DEFAULT nTolerCp   := SuperGetMv("MV_TOLERCP",.F.,0)
	DEFAULT lCalcRet   := .T.
	DEFAULT lIRPFBaixa := .F.
	DEFAULT lAtOldPgto := .F. // Atualiza nOldValPgto no final das validações, mas somente se lMVBP10925 = .T.
	DEFAULT lBaixou    := .F.
	DEFAULT lBxLote    := .F.
	DEFAULT cMotBx     := ""
	DEFAULT aTitCalc   := {}

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT _lTemMR	   := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
    DEFAULT lFa080PCC  := ExistBlock("FA080PCC")
    DEFAULT lFina450   := FwIsInCallStack("FINA450")
    DEFAULT lImp10925  := ExistBlock("FA080IMP")
    DEFAULT lPCCBaixa  := (SuperGetMv("MV_BX10925",.T.,"2") == "1")

	__BordeImp := IIf(__BordeImp == Nil, FindFunction("BorderoImp"), __BordeImp)
	lAltValor  := (STR(nValPgto,17,2) != STR(nOldValPgto,17,2) .or. lFina450) .And. !FwIsInCallStack("fa430gera")	
	__lAltVrBx := lAltValor //Seta variavel Private p/ controle de baixas parciais (REINF - Bloco 40)
	lEmpPub    := Iif(Type("lEmpPub") == "L", lEmpPub, IsEmpPub())
	lAplMinP   := Iif(Type("lAplMinP") == "L", lAplMinP, SA2->A2_MINPUB == "2") 
	lCalcRet   := !SE2->E2_TIPO $ (MVPAGANT+"|"+MV_CPNEG) //Não cálculo de Impostos para títulos de crédito.
	nValPgto   := Iif(lBaixou .And. FwIsInCallStack("fA080TitW"), 0, nValPgto)
	lRet       := lF080Auto 
	
	If cPaisLoc<>"BRA" .And. SE2->E2_MOEDA == 1
		nTxMoeda:=Iif(nMoedaBco>0,aTxMoedas[nMoedaBco][2],1)
		nTxMdaOr:=aTxMoedas[SE2->E2_MOEDA][2]
	EndIf
	
	If __BordeImp .And. !Empty(SE2->E2_NUMBOR) .And. !SE2->E2_TIPO $ MVPAGANT+"|"+MVPROVIS+"|"+MV_CPNEG
		lRetBor := !BorderoImp(SE2->E2_FILORIG, SE2->E2_NUMBOR, "P", SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA)	 
	Endif
	
	lRetBor := IIf(__BordeImp, lRetBor, VLDBOR(SE2->E2_NUMBOR,"P",cFilAnt))	
	
	If _lTemMR .And. _nValPgto <> nValPgto .And. ReadVar() == "NVALPGTO"
		F080VldImp(FwIsInCallStack("FA080CAN"), nValPgto, lAltValor)
	EndIf

	if !(SE2->(EOF()))
		If !((SE2->E2_IMPCHEQ == "S" .or. lChqPre) .And. Round(nValPgto,2) != Round((nValMoeda+nMulta+nJuros+nVA-nDescont+nAcresc-nDecresc-nPis-nCoFins-nCsll-nIrrf-nIss),2))
			nValTot		:= SE2->E2_VLCRUZ
			nValEstrang := SE2->E2_SALDO-nTotAbat
			nValOrig	:= nValEstrang
			
			nValMoeda1 := (SE2->E2_VALOR-nTotAbat)
			nValMoeda  := nValOrig
			nAcresc    := SE2->E2_SDACRES
			nDecresc   := SE2->E2_SDDECRE			
			
			If cPaisLoc == "BRA"
				If nMoedaBco != SE2->E2_MOEDA 
					If nMoedaBco > 1
						nValMoeda1 := Round(xMoeda(nValMoeda1, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA ), nTxMoeda), 2)
						nValMoeda  := Round(xMoeda(nValMoeda, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA ), nTxMoeda), 2)
						nAcresc    := Iif(nAcresc > 0,  Round(xMoeda(nAcresc, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA ), nTxMoeda), 2), 0)
						nDecresc   := Iif(nDecresc > 0, Round(xMoeda(nDecresc, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA ), nTxMoeda), 2), 0)
					Else
						nValMoeda1 := Round(xMoeda(nValMoeda1, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda, 0), 2)
						nValMoeda  := Round(xMoeda(nValMoeda,  SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda, 0), 2)
						nAcresc    := Iif(nAcresc > 0,  Round(xMoeda(nAcresc, SE2->E2_MOEDA, 1, dBaixa, nCasDec,  nTxMoeda, 0), 2), 0)
						nDecresc   := Iif(nDecresc > 0, Round(xMoeda(nDecresc, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda, 0), 2), 0)					
					EndIf
				EndIf
			Else
				nValMoeda1	:=  Round(NoRound(xMoeda(SE2->E2_VALOR - nTotAbat, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1,,nTxMoeda), nCentMd1+1), nCentMd1)
				nValMoeda	:=  Round(NoRound(xMoeda(nValOrig, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1,, nTxMoeda), nCentMd1+1), nCentMd1)
				nAcresc     :=  Round(NoRound(xMoeda(SE2->E2_SDACRES, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1,, nTxMoeda), nCentMd1+1), nCentMd1)
				nDecresc    :=  Round(NoRound(xMoeda(SE2->E2_SDDECRE, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1,, nTxMoeda), nCentMd1+1), nCentMd1)
			EndIf
			
			//Ponto de entrada para alterar o valor do acrescimo
			If ExistBlock("F080ACRE")
				ExecBlock("F080ACRE",.F.,.F.)
			EndIf
			
			If cPaisLoc <> "BRA"
				nValEstrang := Round(NoRound(xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,0,nTxMoeda),nCentMd1+1),nCentMd1)
			Else				
				If nMoedaBco != SE2->E2_MOEDA
					If nMoedaBco > 1 .And. SE2->E2_MOEDA > 1 
						nValEstrang := Round(xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA )), 2)
					ElseIf nMoedaBco > 1
						nValEstrang := Round(xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, 0), 2)
					Else
						nValEstrang := Round(xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda), 2)
					EndIf
				Else
					nValEstrang := nValPgto
				EndIf
			EndIf
			
			If lCalcRet .And. lAltValor //Executa o recalculo de retencao
				F080IssBx( @lJaSubtPCC )
				lJaSubtPCC := lJaSubtPCC .And. FwIsInCallStack( "FINA450" )//Verificar somente para compensacao entre carteiras

				If lIRPFBaixa .and. !lFina450

					//MV_IMPBAIX = 2 e os valores de multa e juros não podem ser maior ou igual ao valor que será pago 
					If !lJurMulDes .and. ((nValPgto <= (nMulta + nJuros)))
						lValidImp := .F.
					EndIf
					
					If !_lIrfMR .And. lValidImp .and. !( "MATA100" $ SE2->E2_ORIGEM .And. Empty( SE2->E2_BASEIRF ) .And. Empty( SE2->E2_IRRF ) )
						nBaseIRRF := Iif(nMoedaBco == 1, nValPgto, Round(xMoeda(nValPgto, nMoedaBco, 1, dBaixa, nCasDec, nTxMoeda, 0), 2))
						nIRRF := FCalcIRBx(nBaseIRRF, SA2->A2_TIPO, dBaixa, dDebito, lAltValor, /*nTxmoeda*/, cMotBx )
					Endif
					
					If lPCCBaixa
						If (dBaixa < dLastPcc .Or. lEmpPub)
							F080TotMes(dBaixa,.T.,,,,.T.)
						Else
							If !SE2->E2_TIPO $ MVPAGANT+"/"+MVPROVIS .And. lRetBor
								nSalImp := nValPgto
								If lJurMulDes
									nSalImp += IIF(lReadVar .and. __ReadVar == "nMulta",nMulta,0)
									nSalImp += IIF(lReadVar .and. __ReadVar == "nJuros",nJuros,0)
									nSalImp -= IIF(lReadVar .and. __ReadVar == "nDescont",nDescont,0)
									nSalImp += IIF(lReadVar .and. __ReadVar == "nVA"     ,nVA,0)
									nSalImp += IIF(lReadVar .and. __ReadVar == "nAcresc" ,nAcresc,0)
									nSalImp -= IIF(lReadVar .and. __ReadVar == "nDecresc",nDecresc,0)
								Else
									nSalImp -= (nMulta + nJuros + nAcresc - nDecresc - nDescont + nVa) 
								EndIf
								If !_lPccMR
									If nSalImp > 0
										aPcc    := newMinPcc(dBaixa, nSalImp, SED->ED_CODIGO, "P", SA2->A2_COD + SA2->A2_LOJA, nIss, nInss, nIRRF, /*lMin*/, /*lIgnrOrg*/, cMotBx,,nTxmoeda)
										nPis    := aPcc[2]
										nCofins := aPcc[3]
										nCsll   := aPcc[4]
										If len(aPCC)>4
											aTitCalc := aPCC[5]
										Endif
									Else
										nPis    := nCofins := nCsll := 0
									EndIf
								Endif
							Else
								nPis	:= 0
								nCofins := 0
								nCsll	:= 0
							EndIf
						EndIf

						If lFa080PCC
							ExecBlock("FA080PCC",.F.,.F.,{nPis, nCofins, nCsll, nIrrf, nSalImp})
						Endif

						//Ponto de entrada para manipular os valores de impostos(nPis, nCofins, nCsll)
						If lImp10925 .and. (nPis+nCofins+nCsll) > 0
							ExecBlock("FA080IMP",.F.,.F.)
						EndIf
					EndIf
				Else
					If !lFina450
						If lPCCBaixa
							If (dBaixa < dLastPcc .Or. lEmpPub)
								F080TotMes(dBaixa,.T.,,!lBxLote)
							Else
								If !SE2->E2_TIPO $ MVPAGANT+"/"+MVPROVIS .And. lRetBor
									nSalImp := nValPgto
									If lJurMulDes
										nSalImp += IIF(lReadVar .and. __ReadVar == "nMulta",nMulta,0)
										nSalImp += IIF(lReadVar .and. __ReadVar == "nJuros",nJuros,0)
										nSalImp -= IIF(lReadVar .and. __ReadVar == "nDescont",nDescont,0)
										nSalImp += IIF(lReadVar .and. __ReadVar == "nVA"     ,nVA,0)
										nSalImp += IIF(lReadVar .and. __ReadVar == "nAcresc" ,nAcresc,0)
										nSalImp -= IIF(lReadVar .and. __ReadVar == "nDecresc",nDecresc,0)
									Else
										nSalImp -= (nMulta + nJuros + nAcresc - nDecresc - nDescont)
									EndIF
									If !_lPccMR
										If nSalImp > 0
											aPcc    := newMinPcc(dBaixa, nSalImp, SED->ED_CODIGO, "P", SA2->A2_COD + SA2->A2_LOJA, nIss, nInss, nIRRF, /*lMin*/, /*lIgnrOrg*/, cMotBx,,nTxmoeda)
											nPis    := aPcc[2]
											nCofins := aPcc[3]
											nCsll   := aPcc[4]
											If len(aPCC)>4
												aTitCalc := aPCC[5]
											Endif
										Else
											nPis    := nCofins := nCsll := 0
											If lCalcIssBx
												nIss := 0
											EndIf
											If lIRPFBaixa
												nIrrf := 0
											EndIf
										EndIf
									EndIf
								Else
									nPis	:= 0
									nCofins := 0
									nCsll	:= 0
								EndIf
							EndIf

							If lFa080PCC
								ExecBlock("FA080PCC",.F.,.F.,{nPis, nCofins, nCsll, nIrrf, nSalImp})
							Endif

							//Ponto de entrada para manipular os valores de impostos(nPis, nCofins, nCsll)
						If lImp10925 .and. (nPis+nCofins+nCsll) > 0
								ExecBlock("FA080IMP",.F.,.F.)
							EndIf
						EndIf
					Endif
				EndIf
				nBSCLCPCC := nSalImp
			Endif

			If lEmpPub .And. lAplMinP .And. lIRPFBaixa .And. (nPis+nCoFins+nCsll+nIrrf+aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5]< nVlMPub .And. ;
				!(aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] == 0 .And. aDadosRet[1] > 0))
				nPis := nCoFins := nCsll := nIrrf := 0
				nValPgto := nOldValPgto
			EndIf

			// CIDE
			If !_lCidMR .And. lCideBX .And. Empty(SE2->E2_NUMBOR)
				nCidBase := nValPgto
				
				If lJurMulDes
					nCidBase += IIF(lReadVar .and. __ReadVar == "nMulta",nMulta,0)
					nCidBase += IIF(lReadVar .and. __ReadVar == "nJuros",nJuros,0)
					nCidBase += IIF(lReadVar .and. __ReadVar == "nDescont",nDescont,0)
					nCidBase += IIF(lReadVar .and. __ReadVar == "nVA"     ,nVA,0)
				Else
					nCidBase -= (nMulta + nJuros + nAcresc) - nDescont
				EndIf
				
				nCide := FCalcCIDE(nCidBase, SE2->E2_NATUREZ, SE2->E2_FORNECE, SE2->E2_LOJA)
			EndIf

			If lAltValor
				If lMVBP10925 .and. !lEmpPub  // Se for empresa pública já foi abatido na função f080TotMes os valores de nPis + nCofins + nCsll + nIrrf, e não deve ser abatido novamente.
					If !lJaSubtPCC
						nValPgto	:= nValPgto - If(!_lPccMR, (nPis+nCoFins+nCsll), 0) - If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0) - _nImpMR
						nValEstrang := nValEstrang-(Round(NoRound(xMoeda((If(!_lPccMR, (nPis+nCoFins+nCsll), 0) + _nImpMR + If(!_lIrfMR, nIrrf, 0) + If(!_lIssMR, nIss, 0)),nMoedaBco,SE2->E2_MOEDA,,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1))
					EndIf
				Else
					nValPgto		:= nValPgto
				EndIf
				nValLiq := nValPgto - nMulta + nJuros + nVA + nDescont - nAcresc + nDecresc + If(!_lPccMR, (nPis+nCoFins+nCsll), 0) + If(!_lIrfMR, nIrrf, 0) + If(!_lIssMR, nIss, 0) 

				nEstOriginal := nValEstrang-(Round(NoRound(xMoeda(nJuros+nMulta-nDescont+nAcresc-nDecresc - If(!_lPccMR, (nPis+nCoFins+nCsll), 0) - _nImpMR -;
													If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0),nMoedaBco,SE2->E2_MOEDA,,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1))
			Endif

			If (lMVBP10925 .or. nValPgto >= SE2->E2_SALDO ) .And. lAltValor
				nOldValPgto	:= nValPgto
				If nValPgto == SE2->E2_BASEPIS
					nValPgto := nValPgto - If(!_lInsMR, Iif(!lInssBx,SE2->E2_INSS,0), 0) - If(!_lIrfMR, Iif(lIRPFBaixa,0,SE2->E2_IRRF), 0)
				EndIf
				If !lJurMulDes
					If (nPis+nCoFins+nCsll+nIrrf+nIss) == 0
						nValPgto := nValPgto - If(!_lPccMR, (nPis+nCoFins+nCsll), 0) - If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0)
					EndIf
				EndIf
				If nValPgto < 0
					nValPgto := nOldValPgto
				Endif

				If SE2->E2_MOEDA == 1 .AND. nMoedaBco == 1
					nValEstrang := nValPgto // nValEstrang = variavel que contem o valor do campo "valor pago" na baixa
				EndIf

				If lAtOldPgto .or. (lAltValor .and. nOldValPgto <> nValPgto)
					nOldValPgto	 := nValPgto
				EndIf
			EndIf

			If !lF080Auto
				fa080Corr(nEstOriginal, nTxMoeda)
				
				//Valores na moeda do banco ->> converter para a moeda do título
				nValSaldo := (nMulta + nJuros + nVA - nDescont + nTolerCP - nPis - nCoFins - nCsll - nIrrf - nIss)
				nValSaldo += SE2->E2_INSS + If(lIRPFBaixa, 0, SE2->E2_IRRF)
				nValSaldo := xMoeda(nValSaldo, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCentMd1 + 1,, nTxMoeda)
				nValSaldo := Round(NoRound(nValSaldo, nCentMd1 + 1), nCentMd1)
				
				//Valores que já estão na moeda do título
				nValSaldo += SE2->(E2_SALDO + E2_SDACRES - E2_SDDECRE)
				If lIsRussia
					nValSaldo -= nTotAbat
				EndIf

				//Valida se não estou tentando baixar valor maior que o saldo
				lRet :=  (nValEstrang <= nValSaldo)

				If nTxMoeda > 0
					nValMax := SE2->E2_SALDO - ((aImp[1] + aImp[2] + aImp[3] + aImp[4] + aImp[5]) / nTxMoeda)
				Else
					nValMax := SE2->E2_SALDO - aImp[1] - aImp[2] - aImp[3] - aImp[4] - aImp[5]
				EndIf
				nValMax += nMulta + nJuros + nVA + nAcresc + (nPis + nCofins + nCsll)

				// Valor do pagamento.
				nPgAux := nValPgto - max(nJuros, 0) - max(nMulta, 0)

				If lRet
					IF nTxMoeda > 0 .and. nMoedaBco != SE2->E2_MOEDA 
						If SE2->E2_MOEDA > 1
							lRet := Round(NoRound(nValMax * nTxMoeda ,nCentMd1+1),nCentMd1) >= Round(NoRound(nPgAux ,nCentMd1+1),nCentMd1)
						else
							lRet := Round(NoRound(nValMax/nTxMoeda ,nCentMd1+1),nCentMd1) >= Round(NoRound(nPgAux ,nCentMd1+1),nCentMd1)
						EndIf 
					else
						lRet := nValMax >= nPgAux
					EndIf
				Endif

				If !(__lShoHelp := lRet)
					Help(" ",1,"ValorMaior")
					//Executou o recalculo na totmes entao tenho que voltar o valor pago inteiro.
					If lCalcRet .And. lAltValor .And. !lIRPFBaixa .And. !lF080Auto
						nValPgto := nValPgto + nIss
					Endif
				Endif
			Endif
		Else
			nValPgto := nOldValPgto
			lRet := .F.
		EndIf

		If Type("nOldInss") != "N"
			nOldInss := 0
		EndIf

		If lRet
			nOldIRRF := If(!_lIrfMR, nIrrf, nOldIRRF)
			nOldIss  := If(!_lIssMR, nIss,  nOldIss)
			nOldInss := If(!_lInsMR, nInss, nOldInss)
			If !_lPccMR
				nOldPis    := nPis
				nOldCofins := nCofins
				nOldCsll   := nCsll
			EndIf

			If (lF080Auto .And. (nPis+nCofins+nCsll)>0 .and. nPgtoAuto ==  nValOrig) //baixa total do título
				If !(FwIsInCallStack("Fa450cmp")) .And. ( !lMVCNBImpg .Or. ( lMVCNBImpg .And. !(FwIsInCallStack("Fa430gera"))))
					nValPgto := nValPgto - (nPis + nCofins + nCsll)
				EndIf
			Endif
		Endif
	EndIF

	If  (!lBxLote .or. Type("nValLiq")!="U" ) .and. lMVBP10925 .and. (nValLiq != nValPgto)    //é baixa parcial .AND. é baixa parcial Líquida
		If cPaisLoc <> "BRA"
			nValMoeda1	:= xMoeda( nValPgto - nTotAbat	, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1, nTxMdaOr, nTxMoeda )
			nValMoeda	:= xMoeda( nValPgto				, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1, nTxMdaOr, nTxMoeda )
			nAcresc     := xMoeda( SE2->E2_SDACRES		, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1, nTxMdaOr, nTxMoeda )
			nDecresc    := xMoeda( SE2->E2_SDDECRE		, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1, nTxMdaOr, nTxMoeda )
		Else
			nValMoeda1	:= xMoeda( nValPgto - nTotAbat	, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1, nTxMoeda )
			nValMoeda	:= xMoeda( nValPgto				, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1, nTxMoeda )
			nAcresc     := xMoeda( SE2->E2_SDACRES		, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1, nTxMoeda )
			nDecresc    := xMoeda( SE2->E2_SDDECRE		, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1, nTxMoeda )
		EndIf

		nValMoeda1	:= Round( NoRound( nValMoeda1, nCentMd1+1 ), nCentMd1 )
		nValMoeda	:= Round( NoRound( nValMoeda , nCentMd1+1 ), nCentMd1 )
		nAcresc     := Round( NoRound( nAcresc   , nCentMd1+1 ), nCentMd1 )
		nDecresc    := Round( NoRound( nDecresc  , nCentMd1+1 ), nCentMd1 )

		If lMVBP10925 .And. lAltValor
			If (nPis + nCoFins + nCsll + nIrrf + nIss) == 0 .and. lJurMulDes
				nValPgto := nValMoeda + nOtrGa + nImpSubst + nAcresc - nDecresc
			EndIf
			nOldValPgto := nValPgto
		EndIf
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fA080Val
Funcao utilizada para consistir o valor digitado	
@author Wagner Xavier
@since  26/05/1992
/*/
//-------------------------------------------------------------------
Function fA080Val(nVal, nTxMoeda, lCalcImp, lAtuVlr, lDtBaix, lRecMot, lValidVA,aTitCalc)
	Local nCentMd1		:= MsDecimais(1)
	LOCAL nValLiq		:= 0
	Local nTxMdaOr		:= 0
	Local lAtuPgtJur	:= .F.
	Local lIRPFBaixa	:= .F.
	Local nValNArred	:= 0
	Local lCideBX		:= SuperGetMv("MV_FGCIDE",.T.,"2") == "1" // Define o fato gerador do imposto CIDE. 1 = Baixa ou 2 = Emissão
	Local aPcc			:= {}
	Local lMVBP10925    := SuperGetMv("MV_BP10925",.F.,"1") == "2" // 1- Valor bruto da baixa parcial / 2- Valor da baixa parcial menos os impostos.	
	Local lJurMulDes	:= SuperGetMv("MV_IMPBAIX",.t.,"2") == "1"
	Local lData			:= .F.
	Local nAntImp		:= 0
	Local lAltTxMoed	:= .F.
	Local nBaseIRRF		:= 0 
	Local cCampo        := AllTrim(ReadVar())
	Local ldDebito      := Type("dDebito") <> "U" 
	Local ldOldData     := Type("dOldData") <> "U"
	Local nVlOrigOld    := 0
	Local nVlEstrOld    := 0
	Local nVlrjuros     := 0
	Local nVlrImpos     := 0 
	Local nCasDec       := TamSx3("E2_TXMOEDA")[2]
	Local lRetBor       := .T.
	Local lIRProg 		:= .T.
	Local nTxMoedAux	:= 0
	Local nFTXIRAux		:= 0
	Local nSalImp       := 0 //Declarada para uso em P.E
	
	Default nVal      := 0
	Default nTxMoeda  := 1
	Default lCalcImp  := .F.
	Default lAtuVlr   := .F.
	Default lDtBaix	  := .F.
	Default lRecMot	  := .F.
	Default lValidVA  := .F.
	Default aTitCalc  := {}

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lFa080PCC := ExistBlock("FA080PCC")
    DEFAULT lImp10925 := ExistBlock("FA080IMP")
    DEFAULT lPCCBaixa := (SuperGetMv("MV_BX10925",.T.,"2") == "1")
	
	If cPaisLoc =="BRA" .And. !SE2->E2_TIPO $ MVPAGANT .And. SA2->A2_CALCIRF == "2"
		lIRPFBaixa := Posicione("SED", 1, xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") == "S"
	EndIf 	
	
	nOldPgto   := Iif (type("nOldPgto") == "U", nValPgto, nOldPgto)
	cMotBx     := Iif (Type("cMotBx") =="U", "", cMotBx)
	__BordeImp := IIf(__BordeImp == Nil, FindFunction("BorderoImp"), __BordeImp)
	
	If (Type("lDtPag")<>"U" .and. lDtPag .And. ldOldData .And. dBaixa == dOldData .AND.;
		ldDebito .And. Type("dOldDeb")<>"U" .And. dDebito == dOldDeb )
		lDtPag := .F.
		Return (.T.)
	ElseIf (Type("lDtPag")<>"U" .and. lDtPag .And. ((ldOldData .And. dBaixa <> dOldData) .Or. ; // Se muda a data tem que recalcular os impostos
		( ldDebito .And. dBaixa <> dDebito )))
		lCalcImp := .T.
		lData		:= .T.
	ElseIf VALTYPE(__ReadVar)=="C" .and. __ReadVar$"nTxMoeda" .and. ( Type("nOldTxMoed") == "N" .and. nTxMoeda <> nOldTxMoed )
		nOldTxMoed := If(nOldTxMoed == 0, nTxMoeda, nOldTxMoed)
		lAltTxMoed := .T.
	EndIf
	
	If cCampo $ "DBAIXA|DDEBITO"
		If (cCampo == "DBAIXA" .And. ldOldData .And. dBaixa == dOldData) .Or. (cCampo == "DDEBITO" .And. ldDebito .And. dBaixa == dDebito)
			Return (.T.)
		EndIf
		
		nOldPgto := nValPgto
	EndIf
	
	If Type("lEmpPub") != "L"
		lEmpPub := IsEmpPub()
	EndIf

	If Type("lAplMinP") != "L"
		lAplMinP := .F.
		If SA2->A2_MINPUB == "2"
			lAplMinP := .T.
		EndIF
	EndIF
	
	If __BordeImp .And. !Empty(SE2->E2_NUMBOR) .And. !SE2->E2_TIPO $ MVPAGANT+"|"+MVPROVIS+"|"+MV_CPNEG
		lRetBor := !BorderoImp(SE2->E2_FILORIG, SE2->E2_NUMBOR, "P", SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA)	 
	Endif
	
	lRetBor := IIf(__BordeImp, lRetBor, VLDBOR(SE2->E2_NUMBOR,"P",cFilAnt))	
	
	If cPaisLoc <>"BRA"
		nCentMd1:=4
		nTxMoeda:=Iif(nMoedaBco>0,aTxMoedas[nMoedaBco][2],1)
		nTxMdaOr:= If((SE2->E2_MOEDA <= 0 .Or. SE2->E2_MOEDA > Len(aTxMoedas)), 1, aTxMoedas[SE2->E2_MOEDA][2])	
	EndIf

	If !(nDescont <= xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,dBaixa,,nTxMoeda) .and. ((SE2->E2_IMPCHEQ == "S" .or. lChqPre) .And. !(nDescont+nMulta+nJuros > 0)))
		nOtrGa      := If (Type("nOtrGa") != "N",0,nOtrGa)
		nDifCambio  := If (Type("nDifCambio") != "N",0,nDifCambio)
		nImpSubst   := If (Type("nImpSubst") != "N",0,nImpSubst)
		nAcresc     := If (Type("nAcresc") != "N",0,nAcresc)
		nDecresc    := If (Type("nDecresc") != "N",0,nDecresc)

		IF !lValidVA .and. nVal < 0
			Help(" ",1,"VALNEGAT")
			Return .F.
		Endif

		DEFAULT nTxMoeda := 0

		nValTot		:= SE2->E2_VLCRUZ
		nValEstrang := SE2->E2_SALDO-nTotAbat
		nValOrig    := nValEstrang
		
		If SE2->E2_MOEDA == 1 .And. nValEstrang >= _nImpMR
			nValEstrang -= _nImpMR 
		EndIf
		
		If cPaisLoc == "BRA"
			nValMoeda1	:= (SE2->E2_VALOR - nTotAbat)
			nValMoeda	:= nValOrig
			nValNArred	:= nValMoeda
			nAcresc     := SE2->E2_SDACRES
			nDecresc    := SE2->E2_SDDECRE
			
			If SE2->E2_MOEDA != nMoedaBco
				If SE2->E2_MOEDA == 1
					nValNArred  := xMoeda(nValOrig, 1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda)
					nValMoeda1	:= Round(xMoeda(nValMoeda1,      1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2)
					nValMoeda	:= Round(xMoeda(nValOrig,        1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2)
					nAcresc     := Round(xMoeda(SE2->E2_SDACRES, 1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2)
					nDecresc    := Round(xMoeda(SE2->E2_SDDECRE, 1, nMoedaBco, dBaixa, nCasDec, 0, nTxMoeda), 2)
				ElseIf nMoedaBco == 1 
					nValNArred  := xMoeda(nValOrig, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda, 0)
					nValMoeda1	:= Round(xMoeda(nValMoeda1,      SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda, 0), 2)
					nValMoeda	:= Round(xMoeda(nValOrig,        SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda, 0), 2)
					nAcresc     := Round(xMoeda(SE2->E2_SDACRES, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda, 0), 2)
					nDecresc    := Round(xMoeda(SE2->E2_SDDECRE, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda, 0), 2)
				Else
					nValNArred := xMoeda(nValOrig, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA ), nTxMoeda)
					nValMoeda1 := Round(xMoeda(nValMoeda1,      SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA ), nTxMoeda), 2)
					nValMoeda  := Round(xMoeda(nValOrig,        SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA ), nTxMoeda), 2)
					nAcresc    := Round(xMoeda(SE2->E2_SDACRES, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA ), nTxMoeda), 2)
					nDecresc   := Round(xMoeda(SE2->E2_SDDECRE, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, IIF( __nTxTitBx > 0 , __nTxTitBx , SE2->E2_TXMOEDA ), nTxMoeda), 2)
				EndIf 
				__nVlrAjst	:= nValNArred
			Endif
		ElseIf cPaisLoc <> "BRA"
			nValMoeda1	:= xMoeda( SE2->E2_VALOR - nTotAbat	, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1,, nTxMoeda )
			nValMoeda	:= xMoeda( nValOrig					, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1,, nTxMoeda )
			nAcresc     := xMoeda( SE2->E2_SDACRES			, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1,, nTxMoeda )
			nDecresc    := xMoeda( SE2->E2_SDDECRE			, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1,, nTxMoeda )
			nValMoeda1	:= Round( NoRound( nValMoeda1, nCentMd1+1 ), nCentMd1 )
			nValNArred	:= nValMoeda
			nValMoeda	:= Round( NoRound( nValMoeda , nCentMd1+1 ), nCentMd1 )
			nAcresc     := Round( NoRound( nAcresc   , nCentMd1+1 ), nCentMd1 )
			nDecresc    := Round( NoRound( nDecresc  , nCentMd1+1 ), nCentMd1 )
		EndIf		

		// Ponto de entrada para alterar o valor do acrescimo
		If ExistBlock("F080ACRE")
			ExecBlock("F080ACRE",.F.,.F.)
		EndIf
		
		//Calculo os impostos de Pis Cofins e Csll
		If lCalcImp		
			If (VALTYPE(__ReadVar)=="C" .and. __ReadVar$"nMulta|nDescont|nJuros|nValPgto|nVA")
				If ((nMulta+nDescont+nJuros+nVA) # (nOldMulta+nOldDescont+nOldJuros+nOldVA)) 
					nValPgto := salRefPag(SE2->E2_FORNECE+SE2->E2_LOJA, _lPccMR, _lIrfMR, _lInsMR, _lIssMR, _lCidMR, _lSesMR)
				EndIf
				
				nValPgto := nValPgto + IIF(lJurMulDes ,nAcresc - nDecresc, 0)
			Else
				If lAltTxMoed
					nValPgto 	:= nValMoeda
					nPis := nCoFins := nCsll := nIrrf := nIss := nInss := 0
				Else
					nValPgto := nValMoeda+nMulta+nJuros+nVA-nDescont+nOtrGa+nImpSubst+nAcresc-nDecresc -;
						If(!_lPccMR, (nPis+nCoFins+nCsll), 0) - If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0) - If(!_lInsMR, nInss, 0)
				EndIf
			EndIf
			
			nOldValPgto	 := nValPgto
			
			If nOldPgto <> nValPgto
				F080IssBx(,nTxMoeda)
			EndIf
			
			If !_lIrfMR .And. lIRPFBaixa .And. !lF080Auto  .and. ((nOldPgto <> nValPgto) .or. lRecMot)
				
				If SE2->E2_BASEIRF > 0 .And. SE2->E2_MOEDA > 1 .And. nOldTxMoed <> nTxMoeda .And. SE2->(E2_VALOR == E2_SALDO) //Baixa total
					If !(cPaisLoc == "BRA" .And. (!Empty(SA2->A2_IRPROG) .And. SA2->A2_IRPROG == '1'))
						lIRProg := .F.
					Endif
					
					If Alltrim(SE2->E2_ORIGEM) == 'MATA100'	//Bases sempre gravadas em Real quando vem de Compras
						nBaseIRRF := nValPgto
					ElseIf SA2->A2_TIPO == "F" .Or. ( SA2->A2_TIPO == 'J' .And. lIRProg)
						If SE2->E2_TXMOEDA > 0
							nTxMoedAux	:= SE2->E2_TXMOEDA
						Else
							nTxMoedAux	:= RecMoeda(SE2->E2_EMISSAO, SE2->E2_MOEDA)
						Endif

						nFTXIRAux := nTxMoeda
						nTxMoeda  := nF080TXIR

						If nTxMoeda <= 0
							nTxMoeda := nFTXIRAux
						Endif

						nBaseIRRF	:= xMoeda(SE2->E2_BASEIRF, 1, SE2->E2_MOEDA, SE2->E2_EMISSAO, nCasDec, 0, nTxMoedAux)  
						nBaseIRRF 	:= Round(xMoeda(nBaseIRRF, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxMoeda, 0), 2)  
					Else						
						nBaseIRRF := Round(xMoeda(SE2->E2_BASEIRF, SE2->E2_MOEDA, 1, dBaixa, nCasDec, Iif(nF080TXIR>0,nF080TXIR,nTxMoeda), 0), 2)  
					Endif
				EndIf							
				nIRRF := FCalcIRBx( nBaseIRRF , SA2->A2_TIPO, dBaixa, dDebito, Nil, Iif(nF080TXIR > 0 , nF080TXIR , nTxMoeda ), cMotBx )
			Endif			
			
			If lPCCBaixa
				If (dBaixa < dLastPcc .Or. lEmpPub)
					F080TotMes(dBaixa,.T.,,,,,nTxmoeda)
				Else
					If lPCCBaixa .And. !SE2->E2_TIPO $ MVPAGANT+"/"+MVPROVIS .And. lRetBor
						nSalImp := nValPgto 
						If lData // ao alterar a data deve ser levado em conta o valor alterado para calculo do imposto
							nAntImp	:= If(!_lPccMR, (nPis+nCofins+nCsll), 0) + If(!_lIrfMR, nIrrf, 0) + If(!_lIssMR, nIss, 0)
							If nOldPgto <> nValPgto
								If nOldPgto+nPis+nCofins+nCsll+nIrrf+nIss == SE2->E2_SALDO // NÃO ALTEROU O VALOR
									nSalImp	:= SE2->E2_SALDO // Não alterou o valor
								Else
									nSalImp	:= nOldPgto //deve ser visto o valor alterado
								EndIf
							Else
								nSalImp	:= SE2->E2_SALDO // se mudou a data tem que recalcular os impostos de acordo com o saldo
							EndIf
						EndIf

						If lDtBaix .or. lRecMot
							nSalImp := salRefPag(SA2->A2_COD+SA2->A2_LOJA, _lPccMR, _lIrfMR, _lInsMR, _lIssMR, _lCidMR, _lSesMR,, nTxMoeda)
						Endif

						If lJurMulDes .And. (((nMulta + nJuros + SE2->E2_SDACRES) > 0) .Or. ((nDescont + SE2->E2_SDDECRE) > 0))
							If SE2->E2_MOEDA == 1 .and. nMoedaBco == 1 
								If (lRecMot .Or. lDtBaix) .And. SE2->(E2_SDACRES+SE2->E2_SDDECRE) > 0 
									nSalImp += SE2->E2_SDACRES					
									nSalImp -= SE2->E2_SDDECRE
								EndIf

								nSalImp += (nMulta + nJuros)
								nSalImp -= (nDescont)
							Else
								nSalImp += xMoeda((nMulta+nJuros-nDescont), nMoedaBco,SE2->E2_MOEDA,  dBaixa, nCentMd1+1,, nTxMoeda )
							Endif
						EndIf
						
						If cPaisLoc <> "BRA" 
							nSalImp := xMoeda( nSalImp, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1, nTxMdaOr, nTxMoeda )
						elseIf SE2->E2_MOEDA > 1
							nSalImp := xMoeda( nSalImp, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCentMd1+1, nTxMoeda )
						EndIf

						If !_lPccMR
							If !FwIsInCallStack('FINA450') .and. ((nOldPgto <> nValPgto) .or. lRecMot)
								aPcc    := newMinPcc(dBaixa, nSalImp, SED->ED_CODIGO, "P", SA2->A2_COD + SA2->A2_LOJA, /*nIss*/, /*nIns*/, /*nIrf*/, /*lMin*/, /*lIgnrOrg*/, cMotBx,,nTxmoeda)
								nPis    := aPcc[2]
								nCofins := aPcc[3]
								nCsll   := aPcc[4]
								If len(aPCC)>4
									aTitCalc := aPCC[5]
								Endif
							EndIf
						EndIf
					Else
						nPis	:= 0
						nCofins := 0
						nCsll	:= 0
					EndIf
				EndIf

				If lFa080PCC
					ExecBlock("FA080PCC",.F.,.F.,{nPis, nCofins, nCsll, nIrrf, nSalImp})
				Endif

				//Ponto de entrada para manipular os valores de impostos(nPis, nCofins, nCsll)
				If lImp10925 .and. (nPis+nCofins+nCsll) > 0
					ExecBlock("FA080IMP",.F.,.F.)
				EndIf
			EndIf

			If !_lCidMR .And. lCideBX
				nCidBase := nValPgto 

				IF lJurMulDes
					nCidBase += (nMulta+nJuros-nDescont)
				EndIf
				
				//Calculo CIDE
				If SE2->E2_MOEDA > 1 .And. lAltTxMoed .And. nMoedaBCO == 1
					nCidBase := xMoeda(nCidBase, 1, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda)
				EndIf
				
				nCide := FCalcCIDE(nCidBase, SE2->E2_NATUREZ, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_FILORIG, SE2->E2_MOEDA, nTxMoeda, dBaixa)
			EndIf

			If __ReadVar$"nMulta#nDescont#nJuros#nVA"
				lAtuPgtJur := .T.
			Endif
		Endif
		
		If __ReadVar$"dBaixa#dDebito"
			lAtuPgtJur := .T.
		Endif
		
		If (!(Type("nValTt")<>"U" .And. nValTt  < nValLiq) .And. !__ReadVar $ "cBanco|cAgencia|cConta") .or. lRecMot
			nValPgto := If(nValNArred > nValMoeda, nValNArred, nValMoeda) + nMulta+nJuros+nVA-nDescont+nOtrGa+nImpSubst+nAcresc-nDecresc -;
						If(!_lPccMR, (nPis+nCoFins+nCsll), 0) - If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0) - If(!_lInsMR, nInss, 0) - _nImpMR
		EndIf
		
		If cPaisLoc == "BRA" .And. lF080Auto .And. (nT := Ascan(aAutoCab, {|x| x[1] == "AUTVLRPG"})) > 0 	
			//Para baixas via ExecAuto com valor zero na AUTVLRPG, considera-o e nao recalcula valores
			If aAutoCab[nT,2] == 0 .And. !FwIsInCallStack("FINA415")
				nValPgto := 0
			EndIf
		Endif

		If lAtuPgtJur
			nOldValPgto := nValPgto
			nOldPgto := nValPgto
		Endif
		
		If (nMulta+nJuros+nVA+nDescont+nAcresc+nDecresc+nPis+nCoFins+nCsll+nIrrf+nIss) > 0 .or. Round(nValEstrang - xMoeda(nValNArred,nMoedaBco,SE2->E2_MOEDA,dBaixa,3,,nTxMoeda),2 ) > 0.01
			If cPaisLoc <> "BRA"
				nValEstrang := Round(NoRound(xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,nTxMoeda,nTxMdaOr),nCentMd1+1),nCentMd1)
			Else
				If SE2->E2_MOEDA != nMoedaBco
					If nMoedaBco > 1 .And. SE2->E2_MOEDA > 1
						nValEstrang := Round(xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, SE2->E2_TXMOEDA), 2)
					ElseIf nMoedaBco > 1
						nValEstrang := Round(xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, 0), 2)
						__nVlrAjst	:= xMoeda(nValEstrang, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTxMoeda, 0)
					Else
						nValEstrang := Round(xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda), 2)
					EndIf
				Else
					nValEstrang := nValPgto
				EndIf
			Endif
		Endif
		
		nValLiq := nValPgto-nMulta-nJuros-nVA+nDescont-nOtrGa-nImpSubst-nAcresc+nDecresc + If(!_lPccMR, (nPis+nCoFins+nCsll), 0) +;
					If(!_lIrfMR, nIrrf, 0) + If(!_lIssMR, nIss, 0) + If(!_lInsMR, nInss, 0)
		
		nEstOriginal := nValEstrang - Round(NoRound(xMoeda(nJuros+nVA+nMulta-nDescont+nOtrGa+nImpSubst+nAcresc-nDecresc - If(!_lPccMR, (nPis+nCoFins+nCsll), 0) -;
					If(!_lIrfMR, nIrrf, 0) - If(!_lIssMR, nIss, 0),nMoedaBco,SE2->E2_MOEDA,,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)	
		
		nVlOrigOld := nEstOriginal
		nVlEstrOld := nValEstrang	
		nVlrjuros  := Abs((nJuros+nVA+nMulta+nOtrGa+nImpSubst+nAcresc) - (nDescont+nDecresc))
		
		If SE2->E2_MOEDA > 1
			If (cPaisLoc == "BRA" .And. (!__lCpoJuro .Or. !__lCpoMult .Or. !__lCpoDesc .Or. !__lTxMoeda))
				__lCpoJuro := (cCampo $ "NJUROS|M->NJUROS") .And. nJuros > 0
				__lCpoMult := (cCampo $ "NMULTA|M->NMULTA") .And. nMulta > 0
				__lCpoDesc := (cCampo $ "NDESCONT|M->NDESCONT") .And. nDescont > 0
				__lTxMoeda := (cCampo $ "NTXMOEDA|M->NTXMOEDA") .And.  nTxMoeda > 0
			EndIf			
			
			If (nT := Ascan(aAutoCab, {|x| x[1] == "AUTVLRPG"}) ) > 0 
				If nVlrjuros > 0 .And. SE2->E2_MOEDA != nMoedaBco
					If nMoedaBco == 1 
						nVlrjuros := Round(xMoeda(nVlrjuros, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda), 2)
					else
						nVlrjuros := Round(xMoeda(nVlrjuros, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, SE2->E2_TXMOEDA), 2)
					EndIf
				EndIf
				
				If !_lPccMR .And. (nPis+nCoFins+nCsll) > 0
					nVlrImpos += Round(xMoeda((nPis+nCoFins+nCsll), 1, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda), 2)
				EndIf 
				
				If !_lIrfMR .And. nIrrf > 0
					nVlrImpos += Round(xMoeda(nIrrf, 1, SE2->E2_MOEDA, dBaixa, nCasDec, 0, Iif(nF080TXIR > 0 , nF080TXIR , nTxMoeda )), 2) 
				EndIf
				
				If !_lIssMR .And. nIss > 0
					nVlrImpos += Round(xMoeda(nIss, 1, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda), 2) 
				EndIf

				If !( lIntegracao .AND. UPPER(Alltrim(SE2->E2_ORIGEM)) == "SIGAEIC" .AND. __nTxTitBx > 0 ) // EIC manda o AUTVLRPG na moeda do banco.
					nEstOriginal := (aAutoCab[nT,2]-IIF(lMVBP10925, nVlrImpos, 0))				
					nValEstrang  := (nEstOriginal+IIF(lMVBP10925, nVlrjuros, 0))
				EndIf
			EndIf
		EndIf

		FA080Corr(nEstOriginal, nTxMoeda)
		nEstOriginal := nVlOrigOld
		nValEstrang  := nVlEstrOld
		
		If lAtuVlr .or. lRecMot
			nOldValPgto	 := nValPgto
		Endif
	Else
		If (nDescont+nMulta+nJuros+nVA > 0 .and. SE2->E2_IMPCHEQ == "S")
			IF SEF->(MSSEEK(xFilial("SEF")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_NUMBCO)))
				If !(Round(nValPgto,2) == Round(SEF->EF_VALOR,2))
					Help(" ",1,"JACHQSTIT")
				Endif
			Endif
		Endif
	EndIf
	
	nOldIRRF := If(!_lIrfMR, nIrrf, 0)
	nOldIss := If(!_lIssMR, nIss, 0)
	nOldInss := If(!_lInsMR, nInss, 0)

	If !_lPccMR
		nOldPis	:= nPis
		nOldCofins	:= nCofins
		nOldCsll	:= nCsll
	EndIf

	nOldTxMoed := nTxMoeda

	If cCampo $ "DBAIXA|DDEBITO"
		nValPgto := nOldPgto
		lDtPag := .F.
	Endif

	If nValPgto < 0
		Help(" ",1,"FA070INV")
		Return(.F.)
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080Vdr
Funcao que cadastra dados para processar VENDOR 	
@author Pilar S. Albaladejo
@since  18/01/1995
/*/
//-------------------------------------------------------------------
Function Fa080Vdr(aVendor, nVlrtitV, dVencTitV)

	LOCAL lRet := .T.
	LOCAL nOpcA
	LOCAL oDlgVendor

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variaveis para o tratamento do Vendor 						 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cBancoV		:= CriaVar("E9_BANCO")
	cAgenciaV	:= CriaVar("E9_AGENCIA")
	cContrato	:= CriaVar("E9_NUMERO")
	cPrefV		:= CriaVar("E2_PREFIXO")
	cNumV 		:= CriaVar("E2_NUM")
	cParcV		:= CriaVar("E2_PARCELA")
	cTipV 		:= CriaVar("E2_TIPO")
	cNaturV		:= CriaVar("E2_NATUREZ")
	nValAcres	:= CriaVar("E2_ACRESC")
	dDataVencV	:= CriaVar("E2_VENCTO")
	nTxAcresV	:= CriaVar("E9_TXACRES")
	nValtitV 	:= 0
	cFornecV 	:= Space(6)
	dDataVencV	:= If(dVencTitV == Nil, SE2->E2_VENCTO, dVencTitV)
	nValTitV 	:= If(nVlrtitV == Nil, SE2->E2_SALDO, nVlrtitV)
	cNaturV		:= GetMV("MV_NATVEND")+Space(10-Len(GetMv("MV_NATVEND")))
	aVendor		:= If(Type("aVendor") != "A",{},aVendor)

	If ExistBlock("F080TITV")
		lRet := ExecBlock("F080TITV",.F.,.F.)
	EndIf

	If lRet .and. TrazCodMot(cMotBx) $ "VEN"

		While .T.
			nOpca := 0

			DEFINE MSDIALOG oDlgVendor FROM	98,73 TO 295,495 TITLE OemToAnsi(STR0106) PIXEL //"Baixa por Vendor"

			//Labels
			@ 001,003 TO 95, 098 LABEL "" OF oDlgVendor  PIXEL
			@ 001,103 TO 80, 210 LABEL "" OF oDlgVendor  PIXEL

			//lado esquerdo
			@ 008,011 SAY OemToAnsi(STR0091) 	SIZE 40, 7 OF oDlgVendor PIXEL //"Nro.Contrato"
			@ 006,053 MSGET cContrato	 		SIZE 43,10 OF oDlgVendor PIXEL Hasbutton F3 "SE9" Picture  "@!"  Valid ( Fa080Contr(cContrato) )
			@ 023,011 SAY OemToAnsi(STR0022 )	SIZE 20, 7 OF oDlgVendor PIXEL //"Banco"
			@ 020,053 MSGET cBancoV 		 	SIZE 43,10 OF oDlgVendor PIXEL Picture  "!!!"
			@ 037,011 SAY OemToAnsi(STR0023 )	SIZE 26, 7 OF oDlgVendor PIXEL //"Agˆncia"
			@ 034,053 MSGET cAgenciaV	 		SIZE 43,10 OF oDlgVendor PIXEL Picture  "@!"
			@ 051,011 SAY OemToAnsi(STR0092 ) 	SIZE 23, 7 OF oDlgVendor PIXEL //"Prefixo"
			@ 048,053 MSGET cPrefV			 	SIZE 43,10 OF oDlgVendor PIXEL Picture  "@!"
			@ 064,011 SAY OemToAnsi(STR0093 )	SIZE 24, 7 OF oDlgVendor PIXEL //"Numero"
			@ 062,053 MSGET cNumV			 	SIZE 43,10 OF oDlgVendor PIXEL Picture  "@!"  Valid NaoVazio()
			@ 078,011 SAY OemToAnsi(STR0094 )	SIZE 25, 7 OF oDlgVendor PIXEL //"Parcela"
			@ 076,053 MSGET cParcV			 	SIZE 43,10 OF oDlgVendor PIXEL Picture  "@!"

			//lado direito
			@ 0008,109 SAY OemToAnsi(STR0095 )	SIZE 40, 7 OF oDlgVendor PIXEL //"Tipo"
			@ 006,154 MSGET cTipV			 	SIZE 55,10 OF oDlgVendor PIXEL Hasbutton Picture  "@!" F3 "05" Valid ( Fa080NRV(cPrefV,cNumV,cParcV,cTipV) ;
			.And. Fa080Tip(cTipV) )
			@ 023,109 SAY OemToAnsi(STR0096) 	SIZE 41, 7 OF oDlgVendor PIXEL //"Data Vencto."
			@ 020,154 MSGET dDataVencV  		SIZE 55,10 OF oDlgVendor PIXEL Hasbutton Valid Fa080DtVen(dDataVencV)
			@ 037,109 SAY OemToAnsi(STR0097)  	SIZE 41, 7 OF oDlgVendor PIXEL //"Tx.Acrescimo"
			@ 034,154 MSGET nTxAcresV	 		SIZE 55,10 OF oDlgVendor PIXEL Hasbutton Picture  PesqPict("SE9", "E9_TXACRES")
			@ 051,109 SAY OemToAnsi(STR0098) 	SIZE 41, 7 OF oDlgVendor PIXEL //"Natureza"
			@ 048,154 MSGET cNaturV 		 	SIZE 55,10 OF oDlgVendor PIXEL Hasbutton Picture  "@!" Valid Fa080Nat(cNaturV) F3 "SED"
			@ 064,109 SAY OemToAnsi(STR0099)  	SIZE 40, 7 OF oDlgVendor PIXEL //"Valor T¡tulo"
			@ 062,154 MSGET nValTitV		 	SIZE 55,10 OF oDlgVendor PIXEL Hasbutton Picture  PesqPict("SE2","E2_VALOR")

			DEFINE SBUTTON FROM 84, 143 TYPE 1 ENABLE OF oDlgVendor ACTION ( nOpcA := 1,If(Fa080Nat(cNaturV),oDlgVendor:End(),.F.))
			DEFINE SBUTTON FROM 84, 172 TYPE 2 ENABLE OF oDlgVendor ACTION ( oDlgVendor:End() )
			ACTIVATE MSDIALOG oDlgVendor CENTERED
			If nOpcA == 1
				lRet := Fa080VerVd()
				If !lRet
					Loop
				EndIF
				// Atualiza dados do vendor (matriz enviada por referencia)
				aVendor := {cContrato, cBancoV, cAgenciaV, cPrefV, cNumV, cParcV, cTipV, dDataVencV, nTxAcresV, cNaturV, nValTitV}
				Exit
			Else
				// Se cancelar, inicializa os dados do titulo de Vendor para evitar gravacao de titulo invalido
				cContrato	:= CriaVar("E9_NUMERO")
				cBancoV		:= CriaVar("E9_BANCO")
				cAgenciaV	:= CriaVar("E9_AGENCIA")
				cPrefV		:= CriaVar("E2_PREFIXO")
				cNumV 		:= CriaVar("E2_NUM")
				cParcV		:= CriaVar("E2_PARCELA")
				cTipV 		:= CriaVar("E2_TIPO")
				dDataVencV	:= CriaVar("E2_VENCTO")
				nTxAcresV	:= CriaVar("E9_TXACRES")
				cNaturV		:= GetMV("MV_NATVEND")+Space(10-Len(GetMv("MV_NATVEND")))
				nValTitV 	:= If(nVlrtitV == Nil, SE2->E2_SALDO, nVlrtitV)
				aVendor		:= {}
				lRet := .F.
				Exit
			EndIf

		EndDO
	Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080Contr
Funcao que procura o contrato do VENDOR		
@author Pilar S. Albaladejo
@since  18/01/1995
/*/
//-------------------------------------------------------------------
Function Fa080Contr(cContr)

	LOCAL cAlias := Alias(), lRet := .T.
	LOCAL lF080BXVEND := ExistBlock("F080BXVEND")
	LOCAL aBxVendo:= {}

	dbSelectArea("SE9")
	IF ! dbSeek(cFilial+cContr)
		HELP(" " , 1 , "FA080NOCONTR")
		lRet := .F.
	Else

		If lF080BXVEND
			aBxVendo := ExecBlock("F080BXVEND",.f.,.f.,{cContrato})
			cBancoV:= aBxVendo[1][1]
			cAgenciaV:= aBxVendo[1][2]
			cPrefV:= aBxVendo[1][3]
			cNumV:= aBxVendo[1][4]
			cParcV:= aBxVendo[1][5]
			cTipV:= aBxVendo[1][6]
			dDataVencV:= aBxVendo[1][7]
			nTxAcresV:= aBxVendo[1][8]
			cNaturV:= aBxVendo[1][9]
			nValTitV:= aBxVendo[1][10]

		Else
			nTxAcresV:= SE9->E9_TXACRES
			cBancoV	:= SE9->E9_BANCO
			cAgenciaV:= SE9->E9_AGENCIA
		EndIf
	Endif

	dbSelectArea(cAlias)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fa080Nrv
Funcao que procura o titulo a ser gerado pelo VENDOR		
@author Pilar S. Albaladejo
@since  18/01/1995
/*/
//-------------------------------------------------------------------
Function fa080Nrv(cPref,cNum,cParc,cTip)

	LOCAL lRet := .T., nRec

	dbSelectArea("SE2")
	nRec := Recno()
	IF dbSeek(cFilial+cPref+cNum+cParc+cTip)
		HELP(" " , 1 , "FA080TITEX")
		lRet := .F.
	Endif
	dbGoto(nRec)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080Tip
Valida o tipo do titulo no VENDOR		
@author Pilar S. Albaladejo
@since  18/01/1995
/*/
//-------------------------------------------------------------------
Function Fa080Tip(cTipo)
	LOCAL cAlias := Alias(), lRet := .T.

	dbSelectArea("SX5")
	If !dbSeek(cFilial+"05"+cTipo)
		Help(" ",1,"FA080NOTIP")
		lRet := .F.
	Else
		If cTipo $ MVABATIM
			Help(" ",1,"FA080NOAB")
			lRet := .F.
		Endif
	Endif

	dbSelectArea(cAlias)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080Nat
Valida a Natureza do titulo no VENDOR			
@author Pilar S. Albaladejo
@since  18/01/1995
/*/
//-------------------------------------------------------------------
Function Fa080Nat(cNat)

	Local cAlias := Alias(), lRet := .T.

	dbSelectArea("SED")
	IF !dbSeek(xFilial()+cNat)
		IF cNat != GetMv("MV_NATVEND")
			Help(" ",1,"FA080NONAT")
			lRet := .F.
		Else
			RecLock("SED",.T.)
			SED->ED_FILIAL		:=  xFilial("SED")
			SED->ED_CODIGO   	:=  GetMv("MV_NATVEND")
			SED->ED_DESCRIC  	:=  "Natureza de Vendor"
			SED->ED_CALCIRF  	:=  "N"
			SED->ED_CALCISS  	:=  "N"
			SED->ED_PERCIRF  	:=  0
			SED->ED_CALCCSL		:= "N"
			SED->ED_CALCCOF		:= "N"
			SED->ED_CALCPIS		:= "N"
			SED->ED_TIPO		:= "2"
			MsUnlock()
		Endif

		//294 - Natureza sintetica/Analitica
	ElseIf !FinVldNat( .F., cNat, 2 )
		lRet := .F.
	Endif

	dbSelectArea(cAlias)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fA080Grv
Função utilizada para atualizar a baixa efetuada			
@author Wagner Xavier
@since  26/05/1992
/*/
//-------------------------------------------------------------------
Function fA080Grv(lPadraoBx,lPadraoVd,lCNAB,cLanca,cArqEnt,nTxMoeda,dDebito,nVlImpPCC,lMultNat,lUsaFlag,lAltBord,aCtBaixa,aTitCalc)

	Local lIntegracao := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
	Local nSaldo
	Local i
	Local cTpDoc:=""
	Local cHistMov:=""
	Local cNum
	Local cPrefixo
	Local cParcela
	Local cTipo
	Local cLoja
	Local nSalvRec
	Local cFornece
	Local nRecNo:=0
	Local lAdiantamento := .f.
	Local nTamSeq 		:= TamSX3("E5_SEQ")[1]
	Local cSequencia 	:= Replicate("0",nTamSeq)
	Local lFina390 	:= Iif(SE2->E2_IMPCHEQ == "S",.T.,.F.)
	Local lFa080VIR	:= ExistBlock("FA080VIR")
	Local cChave_EF
	Local nOrdBx
	Local nAtraso 		:= 0
	Local nToler 		:= SuperGetMv("MV_TOLERCP",.F.,0)
	Local lAcreDecre := .F.
	Local cModRetPIS := GetNewPar( "MV_RT10925", "1" )
	Local cGeraDirf  	:= ""
	Local aArea
	Local cChave		:= ""
	Local aAreaSED 	:= {}
	local cFilCorr  := cFilAnt
	//Considero juros multa ou desconto na base do imposto.
	// 1 = Considera valores juros multa ou desconto
	// 2 = Nao considera valores juros multa ou desconto
	Local lContrRet := .T.
	Local lBxCnab   := GetMv("MV_BXCNAB") == "S"
	Local nVlMinImp := GetNewPar("MV_VL10925",5000)
	Local nSavRec := 0
	Local lRetParc := .T.
	Local aRecnos := {}
	Local aRecSFQ := {}
	Local nLoop := 0
	Local cPrefOri  := SE2->E2_PREFIXO
	Local cNumOri   := SE2->E2_NUM
	Local cParcOri  := SE2->E2_PARCELA
	Local cTipoOri  := SE2->E2_TIPO
	Local cCfOri    := SE2->E2_FORNECE
	Local cLojaOri  := SE2->E2_LOJA
	Local lElimResd := cPaisLoc == "PER" .AND. FunName() == 'FINA415' 	
	Local nMoedaBco := IIf(lElimResd, SE2->E2_MOEDA, Max( MoedaBco(cBanco,cAgencia,cConta), 1 )) 
	Local nMoedaTit := SE2->E2_MOEDA
	Local nTxModBco := If( cPaisLoc<>"BRA", aTxMoedas[Max(nMoedaBco		,1)][2]	, 0 )
	Local nTxModTit := If( cPaisLoc<>"BRA", aTxMoedas[Max(SE2->E2_MOEDA	,1)][2]	, 0 )
	Local dVenc		:= dDataBase
	Local lBaseSE2 := SuperGetMv("MV_BS10925",.T.,"1") == "1"
	Local cNatureza := ""
	Local nBaseRet := 0  //Base de retencao

	//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
	//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
	//3-Nao Controla
	Local cNccRet  := SuperGetMv("MV_NCCRET",.F.,"1")

	Local lSest := .T.  //Verifica campo de SEST

	Local lIRPFBaixa := IIf( cPaisLoc = "BRA" , SA2->A2_CALCIRF == "2", .F.) .And. ;
	!SE2->E2_TIPO $ MVPAGANT

	Local lAplVlMin := .T.
	Local lRetManual	:= .F.
	Local cSeqCheque	:= Replicate("0",TamSX3("EF_SEQUENC")[1])
	Local cContabiliza := GETMV("MV_CTBAIXA")
	Local lCalcIssBx :=	IsIssBx("P")
	Local lLibCheq 		:= SuperGetMv( "MV_LIBCHEQ", .F., 'N' ) == "S"
	Local cMvCxFin 	:= SuperGetMv("MV_CXFIN",.F.,'')
	Local cMvCarteir 	:= SuperGetMv("MV_CARTEIR",.F.,'')
	Local nRegSEF := 0
	Local lBordero   := If (lContrRet,(SE2->E2_PRETPIS = '4' .OR. SE2->E2_PRETCOF = '4' .OR. SE2->E2_PRETCSL = '4') .And.;
	!Empty(SE2->E2_NUMBOR),.F.)

	Local lEmBordero	:= (!Empty(SE2->E2_NUMBOR) .AND. cPaisLoc == "BRA" .AND. SE2->E2_TIPO <> MVPAGANT)
	Local nCentMd1	:= MsDecimais(1)
	Local lAtuSldNat := .T.
	Local lTpDesc	:= .T.	 //Verifica campo TPDESC na tabela SE5 (<C>ondicional ou <I>ncondicional)
	Local lE2TpDesc		:= SE2->(ColumnPos("E2_TPDESC"))	> 0 //Verifica campo TPDESC na tabela SE2 (<C>ondicional ou <I>ncondicional)
	Local lGerTXBord := .T. // .T. nao gerou os TX na geracao do bordero
	Local aAreaSE2 := {}
	Local cChaveIR := ""
	Local aAreaSA2 := {}
	Local cFilter  := ""
	Local lCideBX    := SuperGetMv("MV_FGCIDE",.T.,"2") == "1" // Define o fato gerador do imposto CIDE. 1 = Baixa ou 2 = Emissão
	Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
	//Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
	Local lAcmPJ 	 	:= SuperGetMv("MV_INSACPJ",.T.,"2") == "1"  //1 = Acumula    2= Não acumula
	//Ponto de entrada para deletar provisorios ao inves de baixa-los
	Local lF50DelPr	:= ExistBlock("F50DELPR")
	Local lDelProvis	:= If(lF50DelPr, ExecBlock("F50DELPR",.F.,.F.), .F.)
	Local lSubstPR	:= FwIsInCallStack("Fa050Subst")

	//REESTRUTURACAO SE5
	Local oModelBxPA:= nil //FWLoadModel("FINM020")	//Model de baixas a pagar auxiliar
	Local oSubFK2  								//BAIXAS A PAGAR - Model Baixa
	Local oSubFK3								//IMPOSTOS CALCULADOS - Model Baixa
	Local oSubFK4								//IMPOSTOS RETIDOS - Model Baixa
	Local oSubFK5								//MOVTO BANCARIO - Model Baixa
	Local oSubFK6								//VALORES COMPLEMENTARES - Model Baixa
	Local oSubFKA								//TABELA DE RASTREIO - Model Baixa
	Local oSubFKAA								//TABELA DE RASTREIO - Model Baixa Ausiliar (retencao impostos)
	Local oSubFK2A								//BAIXAS A PAGAR - Model Baixa Ausiliar (retencao impostos)
	Local oSubFK3A								//IMPOSTOS CALCULADOS - Model Baixa Auxiliar (retencao impostos)
	Local oSubFKAM								//TABELA DE RASTREIO - Model de Movimento bancario
	Local oSubFK5M 								//MOVTO BANCARIO - Model Movimento Bancario
	Local cLog			:= ""
	Local cChaveTit		:= ""
	Local cChaveFK7		:= ""
	Local cCamposE5		:= ""
	Local cCamposE5M	:= ""
	Local lRet 			:= .T.
	Local cCamposE5A	:= ""
	Local cCamposIR		:= ""
	Local cChaveCH		:= ""
	Local lModelMov		:= .F.
	Local nX			:= 0
	Local nI			:= 0
	Local aImpostos		:= {}
	Local cIdFK4		:= ""
	Local cIdFk4IR		:= ""
	Local nJRBaixa 		:= 0
	Local nCMBaixa 		:= 0
	Local lBxTxa        := SuperGetMv("MV_BXTXA",.F.,"1") == "1"
	Local cTipoCM       := GetMV("MV_TIPOCM")
	Local nTamFK2ARQ    := TamSx3("FK2_ARCNAB")[1]
	Local nTamE5ARQ     := TamSx3("E5_ARQCNAB")[1]
	Local nSaldoAtu     := 0
	Local lBxParc       := .F.
	Local nValPa        := 0
	Local aCamposSE2	:= {}
	Local mv050old	    := ""
	Local lMVCNBImpg    := GetNewPar("MV_CNBIMPG",.F.)
	Local nRecNow 	    := 0
	Local nOrdNow		:= 0
	Local cParcPA 	    := GetMv("MV_1DUP")
	Local aTit			:= {}
	Local lAtuForn      := SuperGetMv("MV_ATUFORN",.F.,.T.)
	Local lAchouFor     := .F.
	Local nValFK		:= 0
	Local nValFK2		:= 0
	Local aAreaCTB		:= {}
	Local cIDMovE5		:= ""
	Local lBxDtFin		:= SuperGetMv("MV_BXDTFIN",,"1") == "2"
	Local nCasDec       := TamSx3("E2_TXMOEDA")[2]	
	Local nSaldup       := 0
	Local nSaldupm      := 0
	Local nMCusto       := 0
	Local nValCalc      := 0
	Local nValMovi      := 0 
	Local nTxEsp		:= 0
	Local nSE2Recno     := 0
	Local nSE5Recno     := 0
	//Gravação do FK3_CODRET e FK4_CODRET
	Local lFKCodRet		:= (cPaisLoc == "BRA" .and. FK3->(FieldPos("FK3_CODRET")) > 0 .and. FK4->(FieldPos("FK4_CODRET")) > 0)
	Local cCodRet		:= ""
	Local aCodRet		:= {}
	Local lSimpIRAlu	As Logical
	Local cQuery        As character 
	Local lVldSEQ	  	As Logical
	Local cFunName		:= FunName()
	Local lfn080BxFk2	:= FindFunction("fn080BxFk2")
	Local aTitPai       As Array
	Local lfn080mFk6	:= FindFunction("fn080mFk6")
	Local lfn450fk6		:= FindFunction("fn450fk6")

	If Type("cArqCnab") <> "U" // Oriundo do Fina430 via ExecAuto (não possui o parametro cArqEnt no fA080Grv)
		cArqEnt:=cArqCnab
	EndIF	
	cArqEnt  := Iif(cArqEnt==Nil," ",cArqEnt)		// Oriundo do Fina430 (Arquivo Cnab)
	// feita por lote.
	Private cTitOrig
	Private aBaixaSE5 := {}
	Private lBdImp	:= .F.
	Private lMsErroAuto := .F.

	Default dDebito   := dBaixa
	Default nVlImpPCC := 0
	Default lMultNat  := .F.
	Default lUsaFlag  := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/ )
	Default lAltBord  := .F.
	Default aCtBaixa  := {}
	Default nTxMoeda  := 0
	Default aTitCalc  := {}

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT _lTemMR   := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
    DEFAULT lF80GRVFK := ExistBlock("F80GRVFK")
    DEFAULT lFina450  := FwIsInCallStack("FINA450")
    DEFAULT lIntPFS   := SuperGetMv("MV_JURXFIN",.T.,.F.)
    DEFAULT lPCCBaixa := (SuperGetMv("MV_BX10925",.T.,"2") == "1")
    DEFAULT lSE5FI080 := ExistBlock("SE5FI080")
    DEFAULT lSpbInUse := SpbInUse() .AND. VerCpoSPB()
    DEFAULT nTamCodA6 := GetSx3Cache("A6_COD", "X3_TAMANHO")
    DEFAULT nTamHist  := GetSx3Cache("E5_HISTOR", "X3_TAMANHO")

	lVldSEQ	:= .F.
	aTitPai := {}

	If cPaisloc=="BRA"
		nTxModBco := nTxMoeda
	Endif

	lSimpIRAlu	:= .F.
	If __nDedSimpl == Nil
		__nDedSimpl  := SuperGetMV("MV_FVL1171",.F.,528) //Valor do desconto simplificado do IRPF
	EndIf
	If __lDicSimpl == NIL
	    __lDicSimpl := (AliasInDic("DKE") .And. DKE->(FieldPos("DKE_IRSIMP")) > 0) .And. FK4->(FieldPos("FK4_DEDIRS")) > 0
	Endif

	If Type("aDadosRet") == "U"
		aDadosRet := Array(7)
		aFill(aDadosRet,0)
	Endif

	//IRRF - BAIXA
	If Type("aDadosIr") == "U"
		aDadosIR := Array(3)
		aFill(aDadosIR,0)
	Endif

	If Type("aRecnosSE2") == "U"
		aRecnosSE2 := {}
	Endif

	If Type("cTpDesc") == "U"
		cTpDesc:="I"
	Endif

	If Type("lEmpPub") != "L"
		lEmpPub := IsEmpPub()
	EndIf

	If Type("lAplMinP") != "L"
		lAplMinP := .F.
		If SA2->A2_MINPUB == "2"
			lAplMinP := .T.
		EndIF
	EndIF

	If Type("nVretInss") != "N"
		nVretInss := 0
	EndIf

	If Type("cPretIns") != "N"
		cPretIns := ""
	EndIf

	If lPCCBaixa .and. dBaixa >= dLastPcc .and. !lEmpPub
		nVlMinImp	:= 0
	EndIf

	If Type("lVlrMaior") == "U"
		Private lVlrMaior := .F.
	EndIf

	If Type("nVlrMaior") == "U"
		Private nVlrMaior := 0
	EndIf

	If Type("lMonedaC") == "U"
		Private lMonedaC := .F.
	EndIf

	If cPaisLoc == "MEX" .AND. lMonedaC
		fn450AsgMn(@nMoedaBco, @nTxModBco)
	EndIf

    nF080TXIR := Iif(!(TYPE("nF080TXIR") == 'N'),0,nF080TXIR)

	//se estiver sendo chamado via rotina automática a partir da compensação entre carteiras,
	//nao deve processar ISS E IR
	If lFina450 .and. (Type("lF080Auto")<>"U" .and. lF080Auto)
		lCalcIssBx := .F.
	EndIf

	lCNAB		:= Iif(lCNAB==Nil,.F.,lCnab)
	nOtrGa      := If (Type("nOtrGa") != "N",0,nOtrGa)
	nDifCambio  := If (Type("nDifCambio") != "N",0,nDifCambio)
	nImpSubst   := If (Type("nImpSubst") != "N",0,nImpSubst)
	nAcresc     := If (Type("nAcresc") != "N",0,nAcresc)
	nDecresc    := If (Type("nDecresc") != "N",0,nDecresc)
	cModSpb		:= If (Type("cModSpb") != "C","1",cModSpb)
	cAutentica	:= If (Type("cAutentica") != "C",Space(25),cAutentica)
	nPis		:= If (Type("nPis") != "N",0,nPis)
	nCofins		:= If (Type("nCofins") != "N",0,nCofins)
	nCsll		:= If (Type("nCsll") != "N",0,nCsll)
	nVlRetPis 	:= If (Type("nVlRetPis") != "N",0,nVlRetPis)
	nVlRetCof 	:= If (Type("nVlRetCof") != "N",0,nVlRetCof)
	nVlRetCsl	:= If (Type("nVlRetCsl") != "N",0,nVlRetCsl)
	nDiferImp	:= If (Type("nDiferImp") != "N",0,nDiferImp)
	nIrrf		:= If (Type("nIrrf") != "N",0,nIrrf)
	nVlRetIrf 	:= If (Type("nVlRetIrf") != "N",0,nVlRetIrf)
	nBaseIrpf 	:= If (Type("nBaseIrpf") != "N",0,nBaseIrpf)
	nIss		:= If (Type("nIss") != "N",0,nIss)
	nInss		:= If (Type("nInss") != "N",0,nInss)
	nCide		:= If (Type("nCide") != "N",0,nCide)
	lIntegracao := Iif(Type("lIntegracao" ) != "L",.F.,lIntegracao)
	nVA			:= If (Type("nVA") != "N", 0, nVA)


	If FunName() != "FINA080"
		lGerImp := !(FwIsInCallStack("FINA631") .And. (SuperGetMv("MV_IMPTRAN",.F.,"1") == "2" ))

		// Correcao monetaria em baixas por outras rotinas
		nCMCalc	:= IIf(cPaisLoc<>"CHI",nCM,nDifCambio)
	EndIf

	If lCnab .and. !lMVCNBImpg
		lPccBaixa := .F.
	Endif

	//Verificar ou nao o limite de 5000 para Pis cofins Csll
	// 1 = Verifica o valor minimo de retencao
	// 2 = Nao verifica o valor minimo de retencao
	If SE2->E2_APLVLMN == "2"
		lAplVlMin := .F.
	Endif
	If lBaseSE2 .And. SE2->(E2_BASEPIS + E2_BASECOF + E2_BASECSL) > 0 .And.;
	(nValPgto+nPis+nCofins+nCsll+nIrrf+nIss+nDescont+nTotAbat-nJuros-nMulta) > If(!Empty(SE2->E2_BASEPIS),SE2->E2_BASEPIS,If(!Empty(SE2->E2_BASECOF),SE2->E2_BASECOF,SE2->E2_BASECSL))
		nBaseRet := If(!Empty(SE2->E2_BASEPIS),SE2->E2_BASEPIS,If(!Empty(SE2->E2_BASECOF),SE2->E2_BASECOF,SE2->E2_BASECSL))
	Else
		nBaseRet := nValPgto+nDescont+nTotAbat-nJuros-nVA-nMulta
		If !lPccBaixa
			nBaseRet += If(!_lPccMR, (nPis+nCofins+nCsll), nBaseRet)
		EndIf

		If !_lInsMR .And. !lInssBx
			nBaseRet += nInss
		EndIf

		If !_lIrfMR .And. !lIRPFBaixa
			nBaseRet += nIrrf
		EndIf

		If !_lIssMR .And. !lCalcIssBx
			nBaseRet += nIss
		EndIf

		If !_lSesMR .And. !lSest
			nBaseRet += SE2->E2_SEST
		Endif
	Endif
	If (Type('nInsCalc') != "N" .Or. Type('nInsBaseR') != "N" .Or. Type('nInsBaseC') != "N")
		nInsCalc := nInsBaseR := nInsBaseC := nBaseRet
	EndIf
	DEFAULT nTxMoeda := 0
	If SE2->E2_SALDO + SE2->E2_SDACRES == 0
		Return .f. /*Function fA080Grv*/
	Endif

	oModelBxPA := FWLoadModel("FINM020")	//Model de baixas a pagar auxiliar
	//- valida a existencia o model
	If oModelBxP == nil 
		oModelBxP  := FWLoadModel("FINM020")	//Model de baixas a pagar		
	EndIf
	If oModelMov == nil 
		oModelMov  := FWLoadModel("FINM030") 	//Model de Movimento bancario
	EndIf 
	
	lGerouSef := .F.

	//verifica se existem os campos de valores de acrescimo e decrescimo no SE5
	lAcreDecre := .T.
	If  nAcresc > nValPgto .And. lFina450
		nAcresc	:= nValPgto
	Endif

	// Grava Dados do Vendor
	If TrazCodMot(cMotBx) == "VEN"
		Fa080GrVen( @cTitOrig, lPadraoVd, cLanca )
	EndIf

	// Atualiza a baixa do título
	nValPadrao := nValPgto - (Iif(SE2->E2_MOEDA<=1,nCM,0)+nJuros+nVA+nMulta-nDescont+nOtrga+nImpSubst+nAcresc-nDecresc)
	nValPadrao += If(!_lPccMR .and. lPccBaixa,  nPis+nCoFins+nCsll, 0)
	nValPadrao += If(!_lIrfMR .and. lIRPFBaixa, nIrrf, 0)
	nValPadrao += If(!_lIssMR .and. lCalcIssBx, nIss,  0)
	nValPadrao += If(!_lInsMR .and. lInssBx,    nInss, 0)
	nValPadrao += _nImpMR

	//Verifica se saldo estava em outra moeda, caso estiver, converte valor recebido pela taxa diaria da moeda
	If cPaisLoc<>"BRA"
		nMoedaBco:=Iif(nMoedaBco>0,nMoedaBco,1)
		nTxMoeda:=Iif (SE2->E2_MOEDA > 1 ,aTxMoedas[SE2->E2_MOEDA][2],aTxMoedas[nMoedaBco][2])
	EndIF

	//Ajusta decimais na compensacao de carteiras em dolares, residuos de arredondamento
	If cPaisLoc == "PAR" .And. lFina450 .And. nMoedaTit > 1
		nCentMd1 := MsDecimais(nMoedaTit)	
	Endif

	If nModulo == 17 //Baixa SIGAEIC
		nSaldo := Round(NoRound(SE2->E2_SALDO-nValEstrang,nCentMd1+1),nCentMd1)
	Else
		If cPaisLoc == "BRA"
			If nMoedaBco != SE2->E2_MOEDA
				If nMoedaBco > 1 .And. SE2->E2_MOEDA > 1 
					nValEstrang := xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, SE2->E2_TXMOEDA)
				ElseIf nMoedaBco > 1
					nValEstrang := xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, 0)
				Else
					nValEstrang := xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda)					
				EndIf
				nSaldo := ( SE2->E2_SALDO - Round(nValEstrang, 2) ) + xMoeda( ( nJuros + nMulta + nAcresc ) - ( nDescont + nDecresc ) + nVA , nMoedaBco, SE2->E2_MOEDA , dBaixa, nCasDec, 0, nTxMoeda)
			Else			
				nValEstrang := nValPgto
				nSaldo := (SE2->E2_SALDO - Round(nValEstrang, 2) + ( ( nJuros + nMulta + nAcresc ) - ( nDescont + nDecresc ) + nVA ) )
			EndIf			
		Else
			If cPaisLoc == "MEX" .AND. lMonedaC .AND. FindFunction("fn450nSal") 
				nSaldo:= 0
				fn450nSal('SE2',nValPadrao,SE2->E2_MOEDA,nMoedaBco,nTxMoeda,0,@nSaldo)
			Else
				nSaldo := Round(NoRound(SE2->E2_SALDO-xMoeda(nValPadrao,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
			EndIf
		Endif
	EndIf
	
	//Verifico se existe tolerancia de pagamento
	If nSaldo != 0 .and. nToler > 0
		If cPaisLoc == "BRA" .And. nMoedaBco == SE2->E2_MOEDA .And. nSaldo > 0
			If !_lPccMR .And. lPccBaixa .And. nSaldo >= (nPis+nCoFins+nCsll)
				nSaldo -= (nPis+nCoFins+nCsll) 			
			EndIf
			
			If !_lIrfMR .And. lIRPFBaixa .And. nSaldo >= nIrrf
				nSaldo -= nIrrf
			EndIf
			
			If !_lIssMR .And. lCalcIssBx .And. nSaldo >= nIss
				nSaldo -= nIss
			EndIf
			
			If SE2->E2_MOEDA == 1 .And. nSaldo >= _nImpMR
				nSaldo -= _nImpMR
			EndIf		
		EndIf
		
		//Pagamentos a menor
		If nToler > 0 .And. nSaldo > 0
			If nSaldo <= nToler
				nDescont += nSaldo
				nSaldo   := 0
			EndIf
			//Pagamentos a maior
		ElseIf nToler > 0 .and. nSaldo < 0
			nJuros += Abs(nSaldo)
			nSaldo += Abs(nSaldo)
		Endif
	Else
		If nSaldo >= 0.01
			If cPaisLoc <> "BRA" .And. SE2->E2_MOEDA<=1
				nSaldo := Round(NoRound(SE2->E2_SALDO-xMoeda(nValPadrao,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
			Else			
				If nMoedaBco != SE2->E2_MOEDA
					If nMoedaBco > 1 .And. SE2->E2_MOEDA > 1 
						nSaldo := Round(NoRound(SE2->E2_SALDO-xMoeda(nValPadrao, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, SE2->E2_TXMOEDA),nCentMd1+1),nCentMd1)
					ElseIf nMoedaBco > 1
						nSaldo := Round(NoRound(SE2->E2_SALDO-xMoeda(nValPadrao, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, 0),nCentMd1+1),nCentMd1)
					Else
						nSaldo := Round(NoRound(SE2->E2_SALDO-xMoeda(nValPadrao, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda),nCentMd1+1),nCentMd1)
					EndIf
				Else
					nSaldo := Round(NoRound(SE2->E2_SALDO-nValPadrao,nCentMd1+1),nCentMd1)
				EndIf
			EndIf
		Else
			nSaldo := 0
		Endif
	Endif
	
	nSalTit := xMoeda(SE2->E2_SALDO, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTxMoeda) //Converte o saldo do titulo a moeda 1.
	
	If lCNAB
		If (nSalTit == 0 .Or. (nSalTit > 0 .and. (Round(nSalTit,2) < Round(nValPadrao,2) .Or. lVlrMaior)))
			//Caso haja pagamento do titulo mais de uma vez e o titulo ja se encontre
			//baixado, gero um PA para informar o pagamento a maior em minha conta bancaria.
			//Este processo somente sera "startado" se for num retorno
			//CNAB (lCNAB = .T.) e se for parametrizado para tal (MV_PAG2TIT = "1")
			If SuperGetMv("MV_PAG2TIT",,"2") == "1"
				//Gero PA na SE2 e seu movimento na SE5
				nSaldoAtu := nSalTit
				nValPa	 := IIF(lVlrMaior, nVlrMaior, nValPgto)
				lBxParc	 := lVlrMaior
				//Verifico se o titulo sofreu apenas uma baixa parcial antes da recepcao do CNAB
				//Neste caso o valor do adiantamento será o valor do principal pago a maior
				If nSalTit > 0 .and. Round(nSalTit,2) < Round(nValPadrao,2)
					nValPgto	:= nSaldoAtu+(nJuros+Iif(SE2->E2_MOEDA<=1,nCm,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc)
					nValPa		:= nValPadrao - nSalTit
					nValPadrao	:= nValPgto-(nJuros+Iif(SE2->E2_MOEDA<=1,nCm,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc)
					lBxParc		:= .T.
				Endif
				For nX := 1 To fCount()
					IF Alltrim(FieldName(nX)) $ "E2_PREFIXO#E2_NUM#E2_NATUREZ#E2_FORNECE#E2_LOJA#E2_NOMFOR#E2_FILORIG"
						Aadd(aCamposSE2, {FieldName(nX), FieldGet(nX)})
					Endif
				Next
				nRecNow := SE2->(RECNO())
				nOrdNow := SE2->(IndexOrd())
				//Verifico Parcela
				cParcPA := GetMv("MV_1DUP")
				SE2->(dbSetOrder(1))
				While SE2->(dbSeek(xFilial("SE2")+SE2->(E2_PREFIXO+E2_NUM)+cParcPA+Substr(MVPAGANT,1,3)))
					cParcPa := Soma1(cParcPa)
				Enddo

				aTit := {}
				For nX := 1 To Len(aCamposSE2)
					If !Empty(aCamposSE2[nX][2])
						AADD(aTit , {aCamposSE2[nX][1] , aCamposSE2[nX][2] , NIL})
					Endif
				Next

				aTit	:= {}
				SE2->(DbGoTo(nRecNow))
				AADD(aTit , {"E2_FILIAL" ,xFilial("SE2")    , NIL})
				AADD(aTit , {"E2_PREFIXO",SE2->E2_PREFIXO	, NIL})
				AADD(aTit , {"E2_NUM"    ,SE2->E2_NUM       , NIL})
				AADD(aTit , {"E2_PARCELA",SE2->E2_PARCELA   , NIL})
				AADD(aTit , {"E2_TIPO"   ,MVPAGANT          , NIL})
				AADD(aTit , {"AUTBANCO"	, cBanco			, NIL})
				AADD(aTit , {"AUTAGENCIA", cAgencia			, NIL})
				AADD(aTit , {"AUTCONTA"	, cConta			, NIL})
				AADD(aTit , {"E2_NATUREZ",SE2->E2_NATUREZ   , NIL})
				AADD(aTit , {"E2_FORNECE",SE2->E2_FORNECE   , NIL})
				AADD(aTit , {"E2_LOJA"   ,SE2->E2_LOJA      , NIL})
				AADD(aTit , {"E2_EMISSAO",Ddatabase         , NIL})
				AADD(aTit , {"E2_VENCTO" ,Ddatabase         , NIL})
				AADD(aTit , {"E2_VENCREA",Ddatabase   		, NIL})
				AADD(aTit , {"E2_VALOR"  ,nValPa            , NIL})
				AADD(aTit , {"E2_EMIS1"  ,Ddatabase         , NIL})
				AADD(aTit , {"E2_VLCRUZ" ,nValPa           	, NIL})
				AADD(aTit , {"E2_HIST"   ,STR0210			, NIL}) //"Adiant.Bx.Duplicada-CNAB"
				AADD(aTit , {"E2_ORIGEM" ,"FINA430"         , NIL})

				Pergunte("FIN050",.F.)
				mv050old := mv_par09
				mv_par09 := 1

				MSExecAuto({|x, y, z| FINA050(x, y, z)}, aTit,, 3)

				If lMsErroAuto
					MostraErro()
				Else
					If ExistBlock("F80PCNB")
						Execblock("F80PCNB",.F.,.F.)  // Dados complementares na PA do CNAB
					EndIf
				EndIf

				mv_par09 := mv050old
				Pergunte("AFI430",.F.)

				SE2->(DbGoTo(nRecNow))
				If !lBxParc
					Return .f.
				Endif
			Else
				Return .f.
			Endif
		Endif
	EndIf

	If SE2->E2_MOEDA > 1 .OR. nMoedaBco > 1
		//³For‡a saldo = 0 quando diferen‡a == 0.01 por problema de arredondamento³
		If Round(NoRound(nSaldo,3),2) <= 0.01
			nSaldo := 0
		Endif
	Endif

	If lAtuSldNat
		// Caso seja a baixa do titulo provisório em sua substituição não deve-se atualizar o saldo da natureza
		If !(lSubstPR .And. !lDelProvis) .And. !lMultNat
			// Nao precisa atualizar a baixa dos abatimentos, pois o valor pago jah eh liquido dos abatimentos
			AtuSldNat(SE2->E2_NATUREZ, dBaixa, SE2->E2_MOEDA, "3", "P", Iif(SE2->E2_MOEDA > 1, nValEstrang, nValpgto),Iif(SE2->E2_MOEDA > 1, nValpgto, nValEstrang) , If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"-","+"),,FunName(),"SE2",SE2->(Recno()),0)
		EndIf
	Endif

	If !(SE2->E2_TIPO $ MVTXA+"#"+MVPAGANT+"#"+"INA") .or. (SE2->E2_TIPO $ "INA#"+MVTXA+"#"+MVPAGANT .and. lBxTxa) //Não atualiza os campos de baixa no SE2 para titulos de INSS Antecipado
		RecLock("SE2")
		nSE2Rec := Recno()
		SE2->E2_BAIXA	  := iif(SE2->E2_BAIXA <= dBaixa, dBaixa, SE2->E2_BAIXA)
		SE2->E2_LOTE	  := cLoteFin
		SE2->E2_MOVIMEN  := dBaixa
		If (lPaisMI .Or. (cPaisLoc == "MEX" .and. lMonedaC)) .and. FindFunction("Fn450Gsts")
			Fn450Gsts( '1',nMoedaBco , SE2->E2_MOEDA, nTxMoeda)
		Else
			SE2->E2_DESCONT  := nDescont + nDecresc
			SE2->E2_MULTA	  := nMulta
		EndIf
		If ( cPaisLoc != "BRA" )
			If SE2->E2_MOEDA<=1
				SE2->E2_VALLIQ := Round(NoRound(xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
			Else
				SE2->E2_VALLIQ :=Round(NoRound(xMoeda(nValPgto,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
			EndIf
		Else
			If Type("lIntegracao")<>"U" .and. lIntegracao .And. UPPER(ALLTRIM(SE2->E2_ORIGEM)) == "SIGAEIC" .And.;
			cTipoCM =='T' .And. FunName() <> "FINA080"
				SE2->E2_VALLIQ := If (E2_VLCRUZ == nValTot, nValpgto, nValTot)
			ELse
				SE2->E2_VALLIQ := nValpgto
			Endif
		Endif

		If  Round(NoRound(nValPgto,3),2) < Round(Noround(xMoeda(SE2->E2_SDACRES,SE2->E2_MOEDA,nMoedaBco,dDataBase,3,nTxMoeda),3),2)
			If (lPaisMI .Or. (cPaisLoc == "MEX" .and. lMonedaC)) .and. FindFunction("Fn450Gsts")
				Fn450Gsts( '2',nMoedaBco , SE2->E2_MOEDA, nTxMoeda)
			Else
				If SE2->E2_MOEDA > 1 .And. nMoedaBco == 1 //Título em moeda estrangeira com banco em moeda 1
					SE2->E2_SDACRES  -= nValEstrang
				Else
					SE2->E2_SDACRES  -= nValPgto
				EndIf
			EndIf
		Else
			SE2->E2_SDACRES  := 0
		EndIf

		SE2->E2_SDDECRE  := 0
		If cPaisLoc == "CHI"
			SE2->E2_OTRGA   := nOtrga
			SE2->E2_CAMBIO  := SE2->E2_CAMBIO + nDifCambio
			SE2->E2_IMPSUBS := nImpSubst
			SE2->E2_JUROS	:= nOtrga + nImpsubst
			SE2->E2_CORREC	:= nDifCambio
		Else
			If (lPaisMI .Or. (cPaisLoc == "MEX" .and. lMonedaC)) .and. FindFunction("Fn450Gsts")
				Fn450Gsts( '3',nMoedaBco , SE2->E2_MOEDA, nTxMoeda)
			ElseIf SE2->E2_ORIGEM != 'FINA171'
				SE2->E2_JUROS	:= nJuros + nAcresc
				SE2->E2_CORREC	:= nCm
			EndIf
		EndIf
		If !Empty(cBanco)
			SE2->E2_BCOPAG   := cBanco
		Endif
		If !Empty(cCheque)
			SE2->E2_NUMBCO   := cCheque
		Endif
		//Para TOP limpa-se a marca.
		//Para Codebase gravo "xx" para manter o titulo no filtro e possibilitar contabilizacao
		//e baixa correta.
		If TcSrvType() == "AS/400" .or. TcSrvType() == "iSeries"  //"iSeries" eh o retorno do Top4 para AS/400
			SE2->E2_OK		  := Iif(E2_OK==cMarca,"xx" ,E2_OK)
		Else
			SE2->E2_OK		  := Iif(E2_OK==cMarca,"  " ,E2_OK)
		Endif

		If !Empty(cPortado)
			SE2->E2_PORTADO  := cPortado
		Endif
		If TrazCodMot(cMotBx) == "VEN"
			SE2->E2_TITORIG	:= cTitOrig
		Endif

		//Marco que o titulo tem os impostos calculados
		//pela baixa (Pis, Cofins e Csll)
		If lContrRet .And. lPCCBaixa .and. !(lBordero .and. nSaldo <> 0)
			SE2->E2_PRETPIS := "3"
			SE2->E2_PRETCOF := "3"
			SE2->E2_PRETCSL := "3"
		Endif
		SE2->(MsUnlock())

		IF (Str(nSaldo,16,2)=Str(nTotAbat,16,2)) .AND. !lIsRussia
			nSaldo := 0
		Endif

		//Verifica se existe solicitacao de NCP e caso exista atualiza o campo CU_DTBAIXA...
		If cPaisLoc <> "BRA"
			A055AtuDtBx("1",SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NUM,SE2->E2_PREFIXO,SE2->E2_BAIXA)
		EndIf

		dbSelectArea("SE2")
		nSalvRec := SE2->( RecNo() )
		cNum	 := SE2->E2_NUM
		cPrefixo := SE2->E2_PREFIXO
		cParcela := SE2->E2_PARCELA
		cFornece := SE2->E2_FORNECE
		cTipo	 := SE2->E2_TIPO
		cLoja 	 := SE2->E2_LOJA
		nOrdBx	 := SE2->(IndexOrd())

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Baixar titulos de abatimento se for baixa total				 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF nSaldo = 0
			//atualiza status do adiantamento de viagem
			If (ALLTRIM(SE2->E2_ORIGEM) $ "FINA667|FINA677")
				FINATURES(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),.T.,SE2->E2_ORIGEM,"P")
			Endif

			cQuery := "UPDATE "+RetSqlName('SE2')
			cQuery += " SET E2_SALDO = 0,"
			cQuery += " E2_SDACRES   = 0,"
			cQuery += " E2_SDDECRE   = 0,"
			cQuery += " E2_BCOPAG    = '"+cBanco+"',"
			cQuery += " E2_BAIXA     = '"+dTos(dBaixa)+"',"
			cQuery += " E2_MOVIMEN   = '"+dTos(dBaixa)+"',"
			cQuery += " E2_LOTE      = '"+cLoteFin+"'"
			cQuery += " WHERE E2_FILIAL = '"+xFilial("SE2",SE2->E2_FILORIG)+"'"
			cQuery += " AND E2_PREFIXO  = '"+cPrefixo+"'"
			cQuery += " AND E2_NUM      = '"+cNum+"'"
			cQuery += " AND E2_PARCELA  = '"+cParcela+"'"			
			cQuery += " AND E2_TIPO     IN "+FormatIn( MVABATIM, "|")
			cQuery += " AND E2_TITPAI= '"+PadR( cPrefixo+cNum+cParcela+cTipo+cFornece+cLoja , TamSx3('E2_TITPAI')[1] ) +"'"
			cQuery += " AND D_E_L_E_T_ = ' ' "
			If TcSQLExec(cQuery) != 0 
				UserException(TcSQLError())
			EndIf 
		Endif

		dbSelectArea("SE2")
		dbGoto(nSalvRec)
	ElseIf !lBxTxa .and. SE2->E2_OK <> 'TA'
		RecLock("SE2")
		SE2->E2_OK :=  "TA"
		SE2->E2_BAIXA	  := iif(SE2->E2_BAIXA <= dBaixa, dBaixa, SE2->E2_BAIXA)
		MsUnlock()
	EndIf

	nSalvRec := SE2->( RecNo() )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada p/ alteracao da data de vencto do IR (Salvador) ³
	//³ Guardo o Recno para caso o Rdmake nao retorne ao titulo baixado, ³
	//³ o sistema force isto, evitando problemas na continuidade do pro- ³
	//³ cesso de baixa do titulo.                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lFa080VIR .and. !Empty(SE2->E2_IRRF)
		nRecno := SE2->(Recno())
		Execblock("FA080VIR",.F.,.F.)
		dbGoTo(nRecno)
		nRecno := 0
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a Movimentacao Bancaria							 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIRPFBaixa .and. nValpgto < nIrrf
		nValPadrao := nValPgto
	Else
		nValPadrao := nValPgto-(nJuros+nVA+nMulta+nAcresc)+(nDescont+nDecresc + If(!_lPccMR, (nPis+nCoFins+nCsll), 0) +;
						If(!_lIrfMR, nIrrf, 0) + If(!_lIssMR, nIss, 0) + If(!_lInsMR, nInss, 0)) //Valor Original
	EndIf
	nJuros := nJuros + nAcresc
	nDescont := nDescont + nDecresc
	cSequencia 	:= Replicate("0",nTamSeq)

	If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
		lAdiantamento := .t.
		fa080adiant( lPadraoBx, cLanca, nTxMoeda, lUsaFlag, lMultNat )
	Endif

	//Caso o titulo nao tenha impostos e os mesmos tenham sido digitados manualmente,
	//altero variavel para gravacao dos titulos de impostos
	If Empty(nVlImpPCC) .And. nPis+nCofins+nCsll > 0
		lRetManual := .T.
	EndIf

	If !lAdiantamento
		//Obtém sequencia de baixa 
		cSequencia 	:= FaNxtSeqBx("SE2",.T., , , , , @lVldSEQ )

		If lVldSEQ
			lRet	:= .F.
		Else
			//REESTRUTURACAO SE5
			//Carrego model de Bx Pagar
			oModelBxP:SetOperation( 3 ) //Inclusao
			oModelBxP:Activate()
			oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
			If lIsRussia .and. (Type("lF080Auto")<>"U" .and. lF080Auto) .AND.  (nT := aScan(aAutoCab,{|x| x[1]='AUTIDPROC'}) ) > 0
				oModelBxP:SetValue("MASTER","IDPROC",cIDProc)
			Else	
				oModelBxP:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo	
			EndIf
			oSubFK2  := oModelBxP:GetModel("FK2DETAIL")
			oSubFK3  := oModelBxP:GetModel("FK3DETAIL")
			oSubFK4  := oModelBxP:GetModel("FK4DETAIL")
			oSubFK5  := oModelBxP:GetModel("FK5DETAIL")
			oSubFK6  := oModelBxP:GetModel("FK6DETAIL")
			oSubFKA  := oModelBxP:GetModel("FKADETAIL")

			//Dados da tabela auxiliar com o código do título a pagar2
			cChaveTit := xFilial("SE2",SE2->E2_FILORIG) + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM     + "|" + SE2->E2_PARCELA + "|" + ;
			SE2->E2_TIPO    + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
			cChaveFK7 := FINBuscaFK7(cChaveTit, "SE2", SE2->E2_FILORIG)

			cIdFK2     := FWUUIDV4()
			For nI:=1 To 7
				
				// Atualiza a Movimentacao Bancaria
				IF nI == 1
					/*If "SIGAEIC" $ UPPER(SE2->E2_ORIGEM) .And. Type("lIntegracao")<>"U" .and. lIntegracao .and. Type("nValEIC")<>"U" .And. cTipoCM =='T'
					cCpoTp := "nValEIC"
					Else*/
					cCpoTp := "nValPgto"
					//Endif
					If lIsRussia
						cTpDoc := "BA"
					Else
						cTpDoc := Iif(MovBcoBx(cMotBx, .T.),"VL","BA")
						//Se o motibo de baixa gerar cheque, pelas novas especificacoes, será gravado:
						//um movimento BA para a baixa
						//um movimento CH na geração do cheque
						If ChqMotBx(cMotBx) .or.;
						SUBSTR(cMotBx,1,3) == "CEC" .or. SE2->E2_IMPCHEQ == "S" .or. ;
						!lLibCheq  .or. (lCnab .and. !Empty(cLoteFin))
							cTpDoc := "BA"
						Endif
						If (lCnab .AND. Empty(cLoteFin)) .or. ;
						(cBanco $ Left(cMvCxFin,nTamCodA6) .and. MovBcoBx(cMotBx, .T.)) .or. ;
						(IF(lCnab, !lBxCnab, .T.) .And. cBanco $ cMvCarteir .and. MovBcoBx(cMotBx, .T.)) .or. ;
						(MovBcoBx(cMotBx, .T.) .and. !ChqMotBx(cMotBx) .and. !lCnab)
							cTpDoc := "VL"		// For‡a mov banc ria quando CAIXA ou Via CNAB
						Endif
					EndIf
					cHistMov := Iif(!Empty(cHist070),cHist070,OemToAnsi( STR0111 )) //"Valor pago s /Titulo"
				Elseif nI == 2
					cCpoTp := "nDescont"
					cTpDoc := "DC"
					cHistMov := OemToAnsi( STR0107 ) //"Desconto s/Pgto de Titulo"
					cCpoCalc := "nDescCalc"
				Elseif nI == 3
					cCpoTp := IIf(cPaisLoc<>"CHI","nJuros","nOtrga")
					cTpDoc := "JR"
					cHistMov := OemToAnsi( STR0108 ) //"Juros s/Pgto de Titulo"
					cCpoCalc := "nJurosCalc"
				Elseif nI == 4
					cCpoTp := "nMulta"
					cTpDoc := "MT"
					cHistMov := OemToAnsi( STR0109 ) //"Multa s/Pgto de Titulo"
					cCpoCalc := "nMultaCalc"
				Elseif nI == 5
					cCpoTp := IIf(cPaisLoc<>"CHI","nCM","nDifCambio")
					cTpDoc := "CM"
					cHistMov := OemToAnsi( STR0110 ) //"Correcao Monet s/Pgto de Titulo"
					cCpoCalc := "nCMCalc"
				Elseif nI == 6
					cCpoTp := "nImpSubst"
					cTpDoc := "IS"
					cHistMov := OemToAnsi( STR0108 ) //"Juros s/Pgto de Titulo"
					cCpoCalc := "nImpSubCalc"
				Elseif nI == 7
					cCpoTp	 := "nVA"
					cTpDoc	 := "VA"
					cHistMov := ""		// Valores Acessórios (histórico virá da FKD).
					cCpoCalc := "nVACalc"
				Endif

				cHistMov := SubStr(Alltrim(cHistMov),1,nTamHist)

				// Verifica se existe cheque já relacionado anteriormente para este t¡tulo. 
				// Deve buscar pelo registro do Cheque com a sequencia em branco 
				// (Cheque gerado pelo FINA390 - Cheque s/ título.
				If lFina390
					dbSelectArea("SEF")
					dbSetOrder(3)
					cChave_EF := xFilial("SEF")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO
					If DbSeek(cChave_EF)
						DO WHILE (cChave_EF == SEF->EF_FILIAL + SEF->EF_PREFIXO+SEF->EF_TITULO;
						+SEF->EF_PARCELA+SEF->EF_TIPO) .and. !(SEF->(EOF()))

							IF Empty(SEF->EF_SEQUENC) .and. SEF->EF_FORNECE+SEF->EF_LOJA == SE2->E2_FORNECE+SE2->E2_LOJA
								cBanco  :=SEF->EF_BANCO
								cAgencia:=SEF->EF_AGENCIA
								cConta  :=SEF->EF_CONTA
								cCheque :=SEF->EF_NUM
								nRegSEF := RECNO()
								EXIT
							Endif
							SEF->(DbSkip())
						ENDDO
					Endif
				Endif

				IF &cCpoTp != 0 .or. nI == 1

					lRet := Iif(lBxDtFin, DtMovFin(dDatabase,,"1"), .T.) 
					IF !lret					
						//-- Objeto local 
						oModelBxPA:DeActivate()
						oModelBxPA:Destroy()
						oModelBxPA:= Nil
						// Objeto static não destroi
						oModelBxP:DeActivate()
						oModelMov:DeActivate()
						return(.f.)
					Endif

					//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
					If !Empty(cCamposE5)
						cCamposE5 += "|"
					Endif
					cCamposE5 += "{"

					cBenef := IIF(Empty(cBenef),SE2->E2_NOMFOR,cBenef)

					cBenef := NoAcento(strtran(cBenef,"'"," ")) //retirando " ' " para evitar error log na gravação da E5
					cBenef := NoAcento(strtran(cBenef,'"'," ")) //retirando ' " ' para evitar gravação em branco na E5
					cBenef := NoAcento(strtran(cBenef,'|'," ")) //retirando ' | ' para evitar travamento na gravação do model

					cCamposE5 += " {'E5_DTDIGIT' , dDataBase}"
					cCamposE5 += ",{'E5_PREFIXO' , SE2->E2_PREFIXO}"
					cCamposE5 += ",{'E5_NUMERO'  , SE2->E2_NUM}"
					cCamposE5 += ",{'E5_PARCELA' , SE2->E2_PARCELA}"
					cCamposE5 += ",{'E5_TIPO'    , SE2->E2_TIPO}"
					cCamposE5 += ",{'E5_FORNECE' , SE2->E2_FORNECE}"
					cCamposE5 += ",{'E5_CLIFOR'  , SE2->E2_FORNECE}"
					cCamposE5 += ",{'E5_LOJA'    , SE2->E2_LOJA}"
					cCamposE5 += ",{'E5_BENEF'   , '"+cBenef +"' }"			
					If lTpDesc .AND. lE2TpDesc .and. SE2->E2_DECRESC > 0  .and. nDescont == nDecresc
						cCamposE5 += ",{'E5_TPDESC'  , SE2->E2_TPDESC }"
					ElseIf lTpDesc
						cCamposE5 += ",{'E5_TPDESC'  , '"+cTpDesc+"' }"
					EndIf

					If _lIssMR .Or. lCalcIssBx
						cCamposE5 += ",{'E5_VRETISS' , " + If(_nIssMR > 0, cValToChar(_nIssMR), cValToChar(nIss)) + " }"
					Endif

					If nI = 5
						cCamposE5 += ",{'E5_IDENTEE'    , SE2->E2_IDENTEE}"
					Endif

					//Movimento principal (baixa e banco)
					If nI == 1

						nJRBaixa := IIf(cPaisLoc<>"CHI",nJuros,nOtrga)
						nCMBaixa := IIf(cPaisLoc<>"CHI",nCM,nDifCambio)
						If cPaisLoc == "MEX" .AND. lMonedaC .AND. FindFunction("Fn450CnvAc")
							//Fn450CnvAc(@nJRBaixa,@nMulta,@nCMBaixa,@nDescont,@nAcresc,@nDecresc,@nJuros,nMoedaBco,nTxMoeda )
							Fn450CnvAc(nJRBaixa,nMulta,nCMBaixa,nDescont,nAcresc,nDecresc,nMoedaBco,nTxMoeda,@cCamposE5 )
						Else
							cCamposE5 += ",{'E5_VLJUROS' , "+cValToChar(nJRBaixa)+" }"
							cCamposE5 += ",{'E5_VLMULTA' , "+cValToChar(nMulta)+" }"
							cCamposE5 += ",{'E5_VLCORRE' , "+cValToChar(nCMBaixa)+" }"
							cCamposE5 += ",{'E5_VLDESCO' , "+cValToChar(nDescont)+" }"
							cCamposE5 += ",{'E5_VLACRES' , "+cValToChar(nAcresc)+" }"
							cCamposE5 += ",{'E5_VLDECRE' , "+cValToChar(nDecresc)+" }"
						EndIf
						cCamposE5 += ",{'E5_BANCO'   , '"+cBanco   +"' }"
						cCamposE5 += ",{'E5_AGENCIA' , '"+cAgencia +"' }"
						cCamposE5 += ",{'E5_CONTA'   , '"+cConta   +"' }"
						cCamposE5 += ",{'E5_DTDISPO' , STOD('" + DTOS(dDebito) + "')}"
						cCamposE5 += ",{'E5_FORNECE' , SE2->E2_FORNECE}"
						cCamposE5 += ",{'E5_ARQCNAB'	, '" + SubStr(Alltrim(cArqEnt),1,nTamE5ARQ) + "'}"

						//Relacionamento FKA X FK2
						If !oSubFKA:IsEmpty()
							//Inclui a quantidade de linhas necessárias
							oSubFKA:AddLine()
							//Vai para linha criada
							oSubFKA:GoLine( oSubFKA:Length() )
						Endif

						oSubFKA:SetValue( 'FKA_IDORIG', cIdFK2 )
						oSubFKA:SetValue( 'FKA_TABORI', "FK2" )
						If lIsRussia .AND. Type("cIDProc") == "C"
							oSubFKA:SetValue( 'FKA_IDPROC', cIDProc )
						EndIf

						//Dados da baixa a pagar
						oSubFK2:SetValue( "FK2_DATA"   , dBaixa )
						oSubFK2:LoadValue( "FK2_NATURE" , SE2->E2_NATUREZ )
						oSubFK2:SetValue( "FK2_RECPAG" , "P" )
						oSubFK2:SetValue( "FK2_HISTOR" , cHistMov )
						oSubFK2:SetValue( "FK2_MOTBX"  , TrazCodMot(cMotBx) )
						oSubFK2:SetValue( "FK2_ORIGEM" , FunName() )
						oSubFK2:SetValue( "FK2_SEQ"    , cSequencia )
						oSubFK2:SetValue( "FK2_IDDOC"  , cChaveFK7 )
						oSubFK2:SetValue( "FK2_LOTE"   , cLoteFin )
						oSubFK2:SetValue( "FK2_TPDOC"  , cTpDoc )
						oSubFK2:SetValue( "FK2_CCUSTO" , SE2->E2_CCUSTO )
						oSubFK2:SetValue( "FK2_DOC"    , If(Empty(cNumBor),SE2->E2_NUMBOR,cNumBor) )	// Vem do Fina240()
						oSubFK2:SetValue( "FK2_ARCNAB" , SubStr(Alltrim(cArqEnt),1,nTamFK2ARQ))
						oSubFK2:SetValue( "FK2_FILORI" , SE2->E2_FILORIG )
						oSubFK2:SetValue( "FK2_AUTBCO" , cAutentica )
						oSubFK2:SetValue( "FK2_MULNAT", If(lMultNat,"1","2"))
						If lIsRussia .AND. Type("cOrdPag") == "C" //Used to link the writeoff to that especific payment order.
							oSubFK2:SetValue( "FK2_ORDREC", cOrdPag)
						Endif

						nMoedaBco := Max( SA6->A6_MOEDA, 1)
						If ( cPaisLoc <> "BRA" )
							If cPaisLoc == "MEX" .AND. lMonedaC .AND. FindFunction("fn450mFk2")
								fn450mFk2(@oSubFK2,cCpoTp,@nMoedaBco,nMoedaTit,nTxModTit,nTxModBco,cTpDoc)
							Else
								If lIsRussia
									nValFK	:= &(cCpoTp)
									nValFK2	:= &(cCpoTp)
									nValFK	:= Round(NoRound(xMoeda( nValFK , 1, nMoedaBco,,nCentMd1+1,, nTxModBco ),nCentMd1+1),nCentMd1)
									nValFK2	:= Round(NoRound(xMoeda( nValFK2, 1, nMoedaTit,,nCentMd1+1,, nTxModTit ),nCentMd1+1),nCentMd1)
									oSubFK2:SetValue( "FK2_VALOR" , nValFK )
									oSubFK2:SetValue( "FK2_VLMOE2", nValFK2 )
								ElseIf lElimResd .AND. FindFunction("fn080ERFk2")
									fn080ERFk2(@oSubFK2,cCpoTp,@nMoedaBco,nMoedaTit,nTxModTit,nTxModBco,nCentMd1)
								Else
									If lPaisMI .And. cFunName == "FINA080" .And. lfn080BxFk2
										fn080BxFk2(@oSubFK2,cCpoTp,nMoedaBco,nMoedaTit,nTxModTit,nTxModBco,nCentMd1)
									Else
										oSubFK2:SetValue( "FK2_VALOR" , Round(NoRound(xMoeda( &cCpoTp, 1, nMoedaBco,,nCentMd1+1,, nTxModBco ),nCentMd1+1),nCentMd1) )
										oSubFK2:SetValue( "FK2_VLMOE2", Round(NoRound(xMoeda( &cCpoTp, 1, nMoedaTit,,nCentMd1+1,, nTxModTit ),nCentMd1+1),nCentMd1) )
									EndIf
								EndIf
								oSubFK2:SetValue( "FK2_TXMOED", nTxModBco )
								oSubFK2:SetValue( "FK2_MOEDA" , StrZero(nMoedaBco,2) )
							EndIf
						Else
							oSubFK2:SetValue( "FK2_VALOR" , &cCpoTp )
							oSubFK2:SetValue( "FK2_MOEDA" , StrZero(nMoedaBco,2) )
							
							If nValEstrang != 0 .and. cTpDoc $ "BA|VL"
								If __nVlrAjst > 0 .And. SE2->E2_MOEDA == 1 .And. (nValEstrang - SE2->E2_SALDO) > 0.01 
									nValEstrang := Round(xMoeda(__nVlrAjst, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, 0),2)
								EndIf		
								oSubFK2:SetValue( "FK2_VLMOE2", nValEstrang )
							Else
								oSubFK2:SetValue( "FK2_VLMOE2", Iif(i!=4 .or. SE2->E2_MOEDA<=1,Round(NoRound(xMoeda(&cCpoTp.,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1),0) )
							EndIf
							
							If (SE2->E2_MOEDA > 1 .Or. nMoedaBco > 1)
								oSubFK2:SetValue("FK2_TXMOED", nTxMoeda)
							Endif
						EndIf

						If FwIsInCallStack("Fa050Subst") //Baixa ref. substituicao de titulo Provisorio para Efetivo.
							oSubFK2:SetValue("FK2_LA", "S")
						Else
							oSubFK2:SetValue("FK2_LA", "N")
							If lPadraoBx .And. cLanca == "S"							
								Aadd(aCtBaixa, { "FK2",cIdFK2 })
							EndIf
						EndIf

						//Gravo Marca da MultNat
						If MV_MULNATP .and. lMultNat
							oSubFK2:SetValue( "FK2_MULNAT" , "1" )
						Endif

						//------------------------------------------------------
						// Grava os valores agregados ao titulo no totalizador
						//------------------------------------------------------
						//Reestruturacao SE5
						//aImpostos[1] = codigo imposto
						//aImpostos[2] = imposto calculado
						//aImpostos[3] = natureza
						//aImpostos[4] = cIdFK4
						//aImpostos[5] = imposto retido
						//aImpostos[6] = base calculado
						//aImpostos[7] = base retencao
						//aImpostos[8] = Código tipo de retenção (FKM)
						//aImpostos[9] = CNPJ/CPF de Retenção
						//aImpostos[10] = Codigo de retenção (SE2->E2_CODRET)
						//aImpostos[11] = Dedução IR Aluguel Simp. 

						If _lTemMR 
							nImpos := Len(_aImpMR)

							For nX := 1 To nImpos
								If lFKCodRet .and. Len(_aImpMR[nX])>=23
									cCodRet :=  _aImpMR[nX,23]
								Else
									cCodRet := ""
								EndIf
								aAdd(aImpostos, {_aImpMR[nX,8], _aImpMR[nX,3], _aImpMR[nX,10],"", _aImpMR[nX,5], _aImpMR[nX,2], _aImpMR[nX,4], _aImpMR[nX,1], SA2->A2_CGC, cCodRet})
							Next nX
						EndIf
						
						If !_lIrfMR .And. lIRPFBaixa .And. nIrfBaseC > 0 
							
							If lFKCodRet
								cCodRet := SE2->E2_CODRET
							Else 
								cCodRet := ""
							Endif
							If __oRatIRF == Nil .OR. Empty(__oRatIRF:aRatIRF)
								aAdd(aImpostos,{"IRF", nIrfCalc, &(SuperGetMV("MV_IRF")), "", nIrrf, nIrfBaseC, nIrfBaseR, "", SA2->A2_CGC, cCodRet, .F.})
							Else
								For nX := 1 To Len(__oRatIRF:aRatIRF)
									lSimpIRAlu := If(len(__oRatIRF:aRatIRF[nX])>10, __oRatIRF:aRatIRF[nX][11], .F.)	
									If __oRatIRF:aRatIRF[nX][6] != 0
										aAdd(aImpostos,{"IRF", __oRatIRF:aRatIRF[nX][6], &(SuperGetMV("MV_IRF")), "", __oRatIRF:aRatIRF[nX][6], __oRatIRF:aRatIRF[nX][5], __oRatIRF:aRatIRF[nX][5], "", __oRatIRF:aRatIRF[nX][3], cCodRet, lSimpIRAlu})
									EndIf
								Next nX
							EndIf
						Endif

						If !_lPccMR .And. lContrRet .and. lPccBaixa
							
							aCodRet := getCodRet()
							If nPisBaseC > 0 .And. nPisCalc > 0
								If __lAtuVlr .And. (nPisCalc - nPis) <= ABS(0.01)
									nPisCalc := nPis
								EndIf 

								aadd(aImpostos,{"PIS",nPisCalc ,SuperGetMV("MV_PISNAT"),"", nPis    , nPisBaseC, nPisBaseR, "", SA2->A2_CGC, aCodRet[1]})
							EndIf
							
							If nCofBaseC > 0 .And. nCofCalc > 0
								aadd(aImpostos,{"COF", nCofCalc, SuperGetMV("MV_COFINS"), "", nCofins , nCofBaseC, nCofBaseR, "", SA2->A2_CGC, aCodRet[2]})
							EndIf
							
							If nCslBaseC > 0 .And. nCslCalc > 0
								If __lAtuVlr .And. (nCslCalc - nCsll) <= ABS(0.01)
									nCslCalc := nCsll
								EndIf

								aadd(aImpostos,{"CSL", nCslCalc, SuperGetMV("MV_CSLL"), "", nCsll, nCslBaseC, nCslBaseR, "", SA2->A2_CGC, aCodRet[3]})
							EndIf
						Endif
						cCodRet := ""
						If !_lIssMR .And. lCalcIssBx .And. nIssBaseC > 0 .And. nIssCalc > 0    
							aadd(aImpostos,{"ISS", nIssCalc, &(GetMv("MV_ISS")), "", nIss, nIssBaseC, nIssBaseR, "", SA2->A2_CGC, cCodRet})
						Endif

						If !_lCidMR .And. lCideBx .And. nCide > 0
							cNatureza := SuperGetMV("MV_CIDE",.T.,"CIDE")
							If ( Empty(cNatureza), cNatureza := "CIDE", Nil )
							aadd(aImpostos,{"CID", nCide, cNatureza, "", nCide, nCidBase, nCidBase, "", SA2->A2_CGC,cCodRet})
						Endif
						If lIsRussia 		 
							aImpostos:= RU06XFUN60(IIF(Type("cOrdPag")=="C",cOrdPag,""),dBaixa,oSubFK2:GetValue("FK2_VALOR"),xFILIAL("SE2"),SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)		
						EndIf

						//Grava FK3 E/OU FK4
						For nX := 1 to Len(aImpostos)
							//Gravar FK4 se os valores de PCC forem maiores que zero
							If aImpostos[nX][2] > 0 .OR. (lIRPFBaixa .AND. aImpostos[nX,1] == "IRF")

								cIdFK4 := ""
								If aImpostos[nX][5] > 0   //Houve retencao
									cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
									aImpostos[nX,4] := cIdFK4

									If _lTemMR .And. nX <= nImpos
										_aImpMR[nX,6] := cIdFK4
									EndIf

									//Guardo o IDFK4 do IRF para usar posteriormente
									If aImpostos[nX,1] == "IRF"
										cIdFk4IR := cIdFK4
									Endif

								Endif

								If !oSubFK3:IsEmpty()
									//Inclui a quantidade de linhas necessárias
									oSubFK3:AddLine()

									//Vai para linha criada
									oSubFK3:GoLine( oSubFK3:Length() )
								Endif

								//---------------------------------------------
								// Grava Imposto calculado
								//---------------------------------------------
								oSubFK3:SetValue( "FK3_IDFK3" , GetSx8Num('FK3', 'FK3_IDFK3'))
								oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
								oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
								oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nX][1] )
								oSubFK3:SetValue( "FK3_RECPAG", "P" )
								oSubFK3:SetValue( "FK3_MOEDA" , "01" )
								oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nX][2] )
								oSubFK3:LoadValue( "FK3_NATURE", aImpostos[nX][3] )
								oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG  )
								oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nX][6] )
								oSubFK3:SetValue( "FK3_IDORIG", cIdFK2 )
								oSubFK3:SetValue( "FK3_TABORI", "FK2")
								oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nx,4] )
								If lFKCodRet 
									oSubFK3:SetValue( "FK3_CODRET" , aImpostos[nx,10] )
								EndIf

								If _lTemMR
									oSubFK3:SetValue( "FK3_CODFKM", aImpostos[nX,8] )
									oSubFK3:SetValue( "FK3_CLIFOR", SA2->A2_COD )
									oSubFK3:SetValue( "FK3_LOJA"  , SA2->A2_LOJA )
									oSubFK3:SetValue( "FK3_CGC"   , aImpostos[nX][9] )
									oSubFK3:SetValue( "FK3_RAICGC", Substr(aImpostos[nX][9], 1, 8) )

									If SE2->E2_MOEDA > 1
										nTxEsp:=Iif(aImpostos[nX,1]=='IRF' .And. nF080TXIR > 0 , nF080TXIR , nTxMoeda )								
										oSubFK3:SetValue("FK3_VLMOE2", Round(xMoeda(aImpostos[nX][2],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxEsp),2))
									Else
										oSubFK3:SetValue("FK3_VLMOE2", aImpostos[nX][2])
									EndIf
								Endif

								//---------------------------------------------
								// Grava Imposto Retido
								//---------------------------------------------
								If aImpostos[nX][5] > 0   //Houve retencao
									If !oSubFK4:IsEmpty()
										//Inclui a quantidade de linhas necessárias
										oSubFK4:AddLine()

										//Vai para linha criada
										oSubFK4:GoLine( oSubFK4:Length() )
									Endif

									oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nx,4])
									oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
									oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
									oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nx,1] )
									oSubFK4:SetValue( "FK4_RECPAG", "P" )
									oSubFK4:SetValue( "FK4_MOEDA" , "01" )
									oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nX,5] )
									oSubFK4:LoadValue( "FK4_NATURE", aImpostos[nX,3])
									oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
									oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX][7] )
									If lFKCodRet 
										oSubFK4:SetValue( "FK4_CODRET" , aImpostos[nx,10] )
									EndIf
									If FK4->(FieldPos("FK4_CLIFOR")) > 0
										oSubFK4:SetValue( "FK4_CLIFOR", SA2->A2_COD )
										oSubFK4:SetValue( "FK4_LOJA"  , SA2->A2_LOJA )
									EndIf
									If Len(aImpostos[nX])> 10 .And. aImpostos[nX][11]
										If __lDicSimpl
											oSubFK4:SetValue("FK4_DEDIRS", __nDedSimpl )
										EndIf
									Endif
									If _lTemMR
										oSubFK4:SetValue( "FK4_CODFKM", aImpostos[nX,8] ) 
										oSubFK4:SetValue( "FK4_CGC"   , aImpostos[nX][9] )
										oSubFK4:SetValue( "FK4_RAICGC", Substr(aImpostos[nX][9], 1, 8) )

										If SE2->E2_MOEDA > 1
											nTxEsp:=Iif(aImpostos[nX,1]=='IRF' .And. nF080TXIR > 0 , nF080TXIR , nTxMoeda )	
											oSubFK4:SetValue("FK4_VLMOE2", Round(xMoeda(aImpostos[nX,5],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,,nTxEsp),2))
										Else
											oSubFK4:SetValue("FK4_VLMOE2", aImpostos[nX,5])
										EndIf

										If nX <= nImpos .And. Len(_aImpMR[nX,7]) > 0 .And. _aImpMR[nX,7,1] > 0
											FK3->(DbGoTo(_aImpMR[nX,7,1]))
											RecLock("FK3")
											FK3->FK3_IDRET := _aImpMR[nX,6]
											FK3->(MsUnlock())
										EndIf
									Endif
								Endif
							Endif
						Next

						For nx:= 1 to len(aTitCalc)
							FINGFK3BOR(2,aTitCalc[nx,1],aTitCalc[nx,2],aImpostos,.F.)
						Next

						If !_lIrfMR .And. lIRPFBaixa
							//IRRF - BAIXA
							FGRVSFQIR(nIrrf,nBaseIrpf,aDadosIr,cSequencia,@cCamposIR,cIdFk4IR)

							//Se o título estiver em bordero, verifica se gerou título IR (fina241) ou nao (fina240)
							If !Empty(SE2->E2_NUMBOR) .and. SE2->E2_VRETIRF > 0 .and. (EMPTY(SE2->E2_PRETIRF) .or. SE2->E2_PRETIRF == "1")

								aAreaSE2 := SE2->(GetArea())
								cChaveIR := SE2->(E2_PREFIXO+E2_NUM+E2_PARCIR)+MVTAXA

								aAreaSA2 := SA2->(GetArea())
								dbSelectArea("SA2")
								If (dbSeek(xFilial("SA2")+GetMV("MV_UNIAO")))
									cChaveIR +=SA2->(A2_COD+A2_LOJA)
								Endif
								cFilter := SE2->(DbFilter())
								dbSelectArea("SE2")
								dbSetOrder(1)
								If !Empty(cFilter)
									//Limpa o filtro para fazer a pesquisa do titulo de IR
									//pois na baixa em lote a SE2 vem filtrada somente com os titulos selecionado
									SET FILTER TO
								EndIf
								If SE2->(dbSeek(xFilial("SE2")+cChaveIR))
									lGerTXBord := .F.
								Endif
								//volta o filtro
								SET FILTER TO &cFilter.
								SE2->(RestArea(aAreaSE2))
								SA2->(RestArea(aAreaSA2))
								If !lGerTXBord .and. !(SE2->E2_SALDO>nValPgto) // grava os valores de retenção em bordero quando for a ultima baixa
									//grava a geracao do IR na movimentacao da baixa, para que nao seja considerado na baixa de outro titulo
									// pois já foi retido na geracao do bordero
									cCamposIR := ",{'E5_VRETIRF' , SE2->E2_VRETIRF }"
									cCamposIR += ",{'E5_PRETIRF' , '4'}"
									cCamposIR += ",{'E5_BASEIRF' , SE2->E2_BASEIRF }"
								Endif
							EndIf
							cCamposE5 += cCamposIR
						Endif

						If !lEmBordero .And. (_nPisMR+_nCofMR+_nCslMR) > 0
							cCamposE5 += ",{'E5_VRETPIS' , " + cValToChar(_nPisMR) + " }"
							cCamposE5 += ",{'E5_VRETCOF' , " + cValToChar(_nCofMR) + " }"
							cCamposE5 += ",{'E5_VRETCSL' , " + cValToChar(_nCslMR) + " }"
						Endif

						If !lEmBordero .And. _nIrfMR > 0
							cCamposE5 += ",{'E5_VRETIRF' , " + cValToChar(_nIrfMR) + " }"
						Endif

						If lContrRet .and. lPccBaixa

							If !_lPccMR .And. (!lEmBordero .or. lRetManual)
								cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nPis)+" }"
								cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nCofins)+" }"
								cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nCsll)+" }"
							Endif

							If (dBaixa < dLastPCC  .Or. lEmpPub)
								Do Case
									Case cModRetPIS == "1"
									If !_lPccMR
										If (aDadosRet[1] + nBaseRet	> nVlMinImp .OR. !lAplVlMin) .AND. (nPis + nCofins + nCsll > 0)
											lRetParc := .T.

											//Rotina para gerar titulo de adiantamento
											If cNCCRet == "1" .and. nDiferImp < 0
												FGerCredRt(Abs(nDiferImp),SE2->E2_MOEDA,cSequencia)
											Endif

											//Exclui a Marca de "pendente recolhimento" dos demais registros
											If aDadosRet[1] > 0
												aRecnos := aClone( aDadosRet[ 6 ] )
												cPrefOri  := SE2->E2_PREFIXO
												cNumOri   := SE2->E2_NUM
												cParcOri  := SE2->E2_PARCELA
												cTipoOri  := SE2->E2_TIPO
												cCfOri    := SE2->E2_FORNECE
												cLojaOri  := SE2->E2_LOJA

												For nLoop := 1 to Len( aRecnos )
													SE5->( dbGoto( aRecnos[ nLoop ] ) )

													If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL);
														.and. SE5->E5_PRETPIS <> "7" .And. SE5->E5_PRETCOF <> "7" .And. SE5->E5_PRETCSL<> "7"

														//Atualiza a informação de retencao de impostos em outro titulo
														//Carrego o Model
														aAreaAnt := GetArea()
														oModelBxPA := FWLoadModel("FINM020")
														oModelBxPA:SetOperation( 4 ) //Alteração
														oModelBxPA:Activate()
														oModelBxPA:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
														oSubFKAA := oModelBxPA:GetModel( "FKADETAIL" )
														oSubFKAA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

														//Atualizar o status de retencao de impostos
														oSubFK3A:= oModelBxPA:GetModel( "FK3DETAIL" )

														For nX := 1 to Len(aImpostos)
															If oSubFK3A:SeekLine({{"FK3_IMPOS",aImpostos[nX,1]}})		//Nome do imposto
																If aImpostos[nX,1] != "IRF" .and. Empty(oSubFK3A:GetValue("FK3_IDRET") )
																	oSubFK3A:SetValue( "FK3_IDRET",aImpostos[nX,4] )		//cIdFk4
																Endif
															Endif
														Next

														cCamposE5A := "{{'E5_PRETPIS' , '2'}"
														cCamposE5A += ",{'E5_PRETCOF' , '2'}"
														cCamposE5A += ",{'E5_PRETCSL' , '2'}}"
														oModelBxPA:SetValue( "MASTER", "E5_CAMPOS", cCamposE5A )

														//Grava os dados
														If oModelBxPA:VldData()
															oModelBxPA:CommitData()
														Else
															lRet := .F.
															cLog := cValToChar(oModelBxPA:GetErrorMessage()[4]) + ' - '
															cLog += cValToChar(oModelBxPA:GetErrorMessage()[5]) + ' - '
															cLog += cValToChar(oModelBxPA:GetErrorMessage()[6])
															Help( ,,"M020VLDI1",,cLog, 1, 0 )
															Exit
														Endif

														oModelBxPA:DeActivate()
														oModelBxPA:Destroy()
														oModelBxPA:= Nil
														RestArea(aAreaAnt)
													Endif

													dbSelectArea("SFQ")
													RecLock("SFQ",.T.)
													SFQ->FQ_FILIAL  := xFilial("SFQ")
													SFQ->FQ_ENTORI  := "SE5"
													SFQ->FQ_PREFORI := cPrefOri
													SFQ->FQ_NUMORI  := cNumOri
													SFQ->FQ_PARCORI := cParcOri
													SFQ->FQ_TIPOORI := cTipoOri
													SFQ->FQ_CFORI   := cCfOri
													SFQ->FQ_LOJAORI := cLojaOri
													SFQ->FQ_SEQORI  := cSequencia

													SFQ->FQ_ENTDES  := "SE5"
													SFQ->FQ_PREFDES := SE5->E5_PREFIXO
													SFQ->FQ_NUMDES  := SE5->E5_NUMERO
													SFQ->FQ_PARCDES := SE5->E5_PARCELA
													SFQ->FQ_TIPODES := SE5->E5_TIPO
													SFQ->FQ_CFDES   := SE5->E5_CLIFOR
													SFQ->FQ_LOJADES := SE5->E5_LOJA
													SFQ->FQ_SEQDES  := SE5->E5_SEQ

													SFQ->FQ_FILDES := SE5->E5_FILIAL

													MsUnlock()

												Next nLoop

												aRecSFQ := aClone( aRecnosSE2 )

												//Emissao
												For nLoop := 1 to Len( aRecSFQ )
													SE2->( dbGoto( aRecSFQ[nLoop]) )

													RecLock( "SE2", .F. )
													SE2->E2_PRETPIS := "2"
													SE2->E2_PRETCOF := "2"
													SE2->E2_PRETCSL := "2"
													SE2->( MsUnlock() )

													dbSelectArea("SFQ")

													RecLock("SFQ",.T.)
													SFQ->FQ_FILIAL  := xFilial("SFQ")
													SFQ->FQ_ENTORI  := "SE2"
													SFQ->FQ_PREFORI := cPrefOri
													SFQ->FQ_NUMORI  := cNumOri
													SFQ->FQ_PARCORI := cParcOri
													SFQ->FQ_TIPOORI := cTipoOri
													SFQ->FQ_CFORI   := cCfOri
													SFQ->FQ_LOJAORI := cLojaOri

													SFQ->FQ_ENTDES  := "SE2"
													SFQ->FQ_PREFDES := SE2->E2_PREFIXO
													SFQ->FQ_NUMDES  := SE2->E2_NUM
													SFQ->FQ_PARCDES := SE2->E2_PARCELA
													SFQ->FQ_TIPODES := SE2->E2_TIPO
													SFQ->FQ_CFDES   := SE2->E2_FORNECE
													SFQ->FQ_LOJADES := SE2->E2_LOJA
													SFQ->FQ_SEQORI  := cSequencia
													SFQ->FQ_FILDES := SE2->E2_FILIAL
													MsUnlock()
												Next nLoop
											EndIf

											//Retorna do ponteiro do SE2 para a parcela
											SE5->( MsGoto( nSavRec ) )
										Else
											If nVlRetPis + nVlRetCof + nVlRetCsl > 0

												If !lRetManual .And. !lEmBordero
													//Atualiza a informação de retencao de impostos no titulo que está sendo baixado
													//Carrego o Model
													cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
													cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
													cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
													cCamposE5 += ",{'E5_PRETPIS' , '1'}"
													cCamposE5 += ",{'E5_PRETCOF' , '1'}"
													cCamposE5 += ",{'E5_PRETCSL' , '1'}"
												EndIf
											Else
												//nesse caso o titulo teve seus impostos retidos em outro título, porem sua baixa foi cancelada.
												SFQ->(DBSetOrder(2))
												If SFQ->(DbSeek(xFilial("SFQ")+"SE5"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
													//Verifico se se trata realmente de PCC
													//Apos a implementacao do IRRF na Baixa, o campo FQ_TPIMP ficou
													//Vazio = PCC
													//Preenchido = sigla do imposto (IRF, por exemplo)
													If Empty(SFQ->FQ_TPIMP)

														cCamposE5 += ",{'E5_VRETPIS' , SE2->E2_PIS}"
														cCamposE5 += ",{'E5_VRETCOF' , SE2->E2_COFINS}"
														cCamposE5 += ",{'E5_VRETCSL' , SE2->E2_CSLL}"
														cCamposE5 += ",{'E5_PRETPIS' , '2'}"
														cCamposE5 += ",{'E5_PRETCOF' , '2'}"
														cCamposE5 += ",{'E5_PRETCSL' , '2'}"

														//Atualiza o registro da SFQ, apontando para a baixa correta
														RecLock("SFQ", .F.)
														SFQ->FQ_SEQDES := cSequencia
														SFQ->(MsUnlock())
													EndIf
												Endif
											EndIf
											lRetParc := .F.
										EndIf
									EndIf
								Case cModRetPIS == "2"
									If !_lPccMR
										//³ Efetua a retencao
										nSavRec := SE5->( Recno() )
										//³ Exclui a Marca de "pendente recolhimento" dos demais registros
										If aDadosRet[1] > 0
											aRecnos := aClone( aDadosRet [ 6 ] )

											cPrefOri  := SE2->E2_PREFIXO
											cNumOri   := SE2->E2_NUM
											cParcOri  := SE2->E2_PARCELA
											cTipoOri  := SE2->E2_TIPO
											cCfOri    := SE2->E2_FORNECE
											cLojaOri  := SE2->E2_LOJA

											For nLoop := 1 to Len( aRecnos )

												SE5->( dbGoto( aRecnos[ nLoop ] ) )

												If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)

													//Atualiza a informação de retencao de impostos em outro titulo
													//Carrego o Model
													aAreaAnt := GetArea()
													oModelBxPA := FWLoadModel("FINM020")
													oModelBxPA:SetOperation( 4 ) //Alteração
													oModelBxPA:Activate()
													oModelBxPA:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
													oSubFKAA := oModelBxPA:GetModel( "FKADETAIL" )
													oSubFKAA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

													//Atualizar o status de retencao de impostos
													oSubFK3A:= oModelBxPA:GetModel( "FK3DETAIL" )
													For nX := 1 to Len(aImpostos)
														If oSubFK3A:SeekLine({{"FK3_IMPOS",aImpostos[nX,1]}})		//Nome do imposto
															If aImpostos[nX,1] != "IRF"
																oSubFK3A:SetValue( "FK3_IDRET",aImpostos[nX,4] )		//cIdFk4
															Endif
														Endif
													Next

													cCamposE5A += "{{'E5_PRETPIS' , '2'}"
													cCamposE5A += ",{'E5_PRETCOF' , '2'}"
													cCamposE5A += ",{'E5_PRETCSL' , '2'}}"

													oModelBxPA:SetValue( "MASTER", "E5_CAMPOS", cCamposE5A )
													//Grava os dados
													If oModelBxPA:VldData()
														oModelBxPA:CommitData()
													Else
														lRet := .F.
														cLog := cValToChar(oModelBxPA:GetErrorMessage()[4]) + ' - '
														cLog += cValToChar(oModelBxPA:GetErrorMessage()[5]) + ' - '
														cLog += cValToChar(oModelBxPA:GetErrorMessage()[6])
														Help( ,,"M020VLDI1",,cLog, 1, 0 )
														Exit
													Endif
													oModelBxPA:DeActivate()
													oModelBxPA:Destroy()
													oModelBxPA:= Nil
													RestArea(aAreaAnt)

												EndIf

												If nSavRec <> aRecnos[ nLoop ]
													dbSelectArea("SFQ")
													RecLock("SFQ",.T.)
													SFQ->FQ_FILIAL  := xFilial("SFQ")
													SFQ->FQ_ENTORI  := "SE5"
													SFQ->FQ_PREFORI := cPrefOri
													SFQ->FQ_NUMORI  := cNumOri
													SFQ->FQ_PARCORI := cParcOri
													SFQ->FQ_TIPOORI := cTipoOri
													SFQ->FQ_CFORI   := cCfOri
													SFQ->FQ_LOJAORI := cLojaOri
													SFQ->FQ_SEQORI  := cSequencia

													SFQ->FQ_ENTDES  := "SE5"
													SFQ->FQ_PREFDES := SE5->E5_PREFIXO
													SFQ->FQ_NUMDES  := SE5->E5_NUMERO
													SFQ->FQ_PARCDES := SE5->E5_PARCELA
													SFQ->FQ_TIPODES := SE5->E5_TIPO
													SFQ->FQ_CFDES   := SE5->E5_CLIFOR
													SFQ->FQ_LOJADES := SE5->E5_LOJA
													SFQ->FQ_SEQDES  := SE5->E5_SEQ
													SFQ->FQ_FILDES := SE5->E5_FILIAL

													MsUnlock()
												Endif
											Next nLoop

											aRecSFQ := aClone( aRecnosSE2 )

											//Emissao
											For nLoop := 1 to Len( aRecSFQ )

												SE2->( dbGoto( aRecSFQ[nLoop]) )

												RecLock( "SE2", .F. )

												SE2->E2_PRETPIS := "2"
												SE2->E2_PRETCOF := "2"
												SE2->E2_PRETCSL := "2"

												SE2->( MsUnlock() )

												dbSelectArea("SFQ")
												RecLock("SFQ",.T.)
												SFQ->FQ_FILIAL  := xFilial("SFQ")
												SFQ->FQ_ENTORI  := "SE2"
												SFQ->FQ_PREFORI := cPrefOri
												SFQ->FQ_NUMORI  := cNumOri
												SFQ->FQ_PARCORI := cParcOri
												SFQ->FQ_TIPOORI := cTipoOri
												SFQ->FQ_CFORI   := cCfOri
												SFQ->FQ_LOJAORI := cLojaOri

												SFQ->FQ_ENTDES  := "SE2"
												SFQ->FQ_PREFDES := SE2->E2_PREFIXO
												SFQ->FQ_NUMDES  := SE2->E2_NUM
												SFQ->FQ_PARCDES := SE2->E2_PARCELA
												SFQ->FQ_TIPODES := SE2->E2_TIPO
												SFQ->FQ_CFDES   := SE2->E2_FORNECE
												SFQ->FQ_LOJADES := SE2->E2_LOJA

												SFQ->FQ_FILDES := SE2->E2_FILIAL
												MsUnlock()
											Next nLoop
										Endif
										
										// Retorna do ponteiro do SE1 para a parcela
										SE5->( MsGoto( nSavRec ) )
										Reclock( "SE2", .F. )
										lRetParc := .T.
									EndIf
								Case cModRetPIS == "3"
									If !_lPccMR
										//Grava a Marca de "pendente recolhimento" dos demais registros
										If nVlRetPis + nVlRetCof + nVlRetCsl > 0 .And. !lEmBordero
											//Atualiza a informação de retencao de impostos no titulo que está sendo baixado	 Carrego o Model
											cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
											cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
											cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
											cCamposE5 += ",{'E5_PRETPIS' , '1'}"
											cCamposE5 += ",{'E5_PRETCOF' , '1'}"
											cCamposE5 += ",{'E5_PRETCSL' , '1'}"
										EndIf

										lRetParc := .F.
									EndIf
								EndCase
							EndIf
						EndIf

						IF !_lPccMR .And. lContrRet .and. lPccBaixa .And. dBaixa >= dLastPCC .And. !lEmpPub
							aAreaPub := GetArea()
							DbSelectArea("SE2")
							SE2->(DbGoto(nSalvRec))
							If SE2->(E2_PIS+E2_COFINS+E2_CSLL) > 0 .And. (nPis+nCofins+nCsll) == 0
								cCamposE5 += ",{'E5_PRETPIS' , '1'}"
								cCamposE5 += ",{'E5_PRETCOF' , '1'}"
								cCamposE5 += ",{'E5_PRETCSL' , '1'}"
							EndIf
							RestArea(aAreaPub)
						ElseIf _lPccMR .And. (_nPisMR+_nCofMR+_nCslMR) == 0
							cCamposE5 += ",{'E5_PRETPIS' , '1'}"
							cCamposE5 += ",{'E5_PRETCOF' , '1'}"
							cCamposE5 += ",{'E5_PRETCSL' , '1'}"
						EndIF
						If lEmpPub .And. lAplMinP .And. lIRPFBaixa
							aAreaPub := GetArea()
							DbSelectArea("SE2")
							SE2->(DbGoto(nSalvRec))
							If SE2->(E2_PIS+E2_COFINS+E2_CSLL+E2_IRRF) > 0 .And. (nPis+nIrrf+nCofins+nCsll) == 0
								If !_lPccMR
									cCamposE5 += ",{'E5_PRETPIS' , '1'}"
									cCamposE5 += ",{'E5_PRETCOF' , '1'}"
									cCamposE5 += ",{'E5_PRETCSL' , '1'}"
								EndIf

								If !_lIrfMR
									cCamposE5 += ",{'E5_PRETIRF' , '1'}"
								EndIf
							EndIf
							RestArea(aAreaPub)
						EndIf
						If lInssBx .And. cPaisLoc = "BRA" .And. !(SE2->E2_TIPO $ MVPAGANT+"/INA")//Inss Baixa

							If nInss > 0.00
								cGeraDirf := SE2->E2_DIRF
								cCodRetIr := SE2->E2_CODRET

								cCamposE5+= ",{'E5_VRETINS',  "+cValToChar(nInss)+"  }"
								cCamposE5+= ",{'E5_PRETINS', '"+cPretIns+"'  }"
							ElseIf nInss == 0 .And. ((SA2->A2_TIPO == "J" .And. lAcmPJ) .Or. SA2->A2_TIPO == "F" )
								If nInsCalc > 0 .And. nVretInss > 0
									cPretIns := "1"
								EndIf

								cCamposE5+= ",{'E5_VRETINS',  "+cValToChar(nVretInss)+"  }"
								cCamposE5+= ",{'E5_PRETINS', '"+cPretIns+"'  }"
							Endif
							If _lIrfMR .And. _nIrfMR == 0
								cCamposE5 += ",{'E5_PRETIRF' , '1'}"
							Endif
						Endif

						// Gravacao de dados complementares da baixa
						If lSE5FI080
							cCamposE5 := ExecBlock('SE5FI080',.f.,.f.,{cCamposE5,oSubFK2})
						EndIf

						//Dados do Movimento
						If cTpDoc == "VL" .And. !lIsRussia	//Se movimenta banco
							//Relacionamento FKA X FK5
							If !oSubFKA:IsEmpty()
								//Inclui a quantidade de linhas necessárias
								oSubFKA:AddLine()
								//Vai para linha criada
								oSubFKA:GoLine( oSubFKA:Length() )
							Endif
							oSubFKA:SetValue( 'FKA_IDORIG', FWUUIDV4() )
							oSubFKA:SetValue( 'FKA_TABORI', "FK5" )

							//Movimento Bancario
							oSubFK5:SetValue( "FK5_RECPAG" , "P" )
							oSubFK5:SetValue( "FK5_HISTOR" , cHistMov )
							oSubFK5:SetValue( "FK5_DATA"   , dBaixa )
							oSubFK5:SetValue( "FK5_DTDISP" , dDebito )
							oSubFK5:LoadValue( "FK5_NATURE" , SE2->E2_NATUREZ )
							oSubFK5:SetValue( "FK5_BANCO"  , cBanco )
							oSubFK5:SetValue( "FK5_AGENCI" , cAgencia )
							oSubFK5:SetValue( "FK5_CONTA"  , cConta )
							oSubFK5:SetValue( "FK5_NUMCH"  , cCheque )
							oSubFK5:SetValue( "FK5_SEQ"    , cSequencia )
							oSubFK5:SetValue( "FK5_MOEDA"  , StrZero(SE2->E2_MOEDA,2) )
							oSubFK5:SetValue( "FK5_VLMOE2" , SE2->E2_VALOR )
							oSubFK5:SetValue( "FK5_ORIGEM" , FunName() )
							oSubFK5:SetValue( "FK5_TPDOC"  , cTpDoc )
							oSubFK5:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
							oSubFK5:SetValue( "FK5_DOC"    , If(Empty(cNumBor),SE2->E2_NUMBOR,cNumBor) )	// Vem do Fina240()
							oSubFK5:SetValue( "FK5_FILORI" , SE2->E2_FILORIG )
							oSubFK5:SetValue( "FK5_LOTE"   , cLoteFin )

							If  lIsRussia .AND. Type("cOrdPag") == "C" //Used to link the writeoff to that especific payment order. 
								oSubFK5:SetValue( "FK5_ORDREC"   , cOrdPag )
								cCamposE5 += ",{'E5_ORDREC'   , '" + cOrdPag + "' }"
							EndIf

							If ( cPaisLoc <> "BRA" )
								oSubFK5:SetValue( "FK5_VALOR" , Round(NoRound(xMoeda( &cCpoTp, 1, nMoedaBco,,nCentMd1+1,, nTxModBco ),nCentMd1+1),nCentMd1) )
								oSubFK5:SetValue( "FK5_VLMOE2", Round(NoRound(xMoeda( &cCpoTp, 1, nMoedaTit,,nCentMd1+1,, nTxModTit ),nCentMd1+1),nCentMd1) )
								oSubFK5:SetValue( "FK5_TXMOED", nTxModBco )
								oSubFK5:SetValue( "FK5_MOEDA" , StrZero(nMoedaBco,2) )
							Else
								oSubFK5:SetValue( "FK5_VALOR" , &cCpoTp )
								oSubFK5:SetValue( "FK5_MOEDA" , StrZero(nMoedaBco,2) )
								If nValEstrang != 0
									oSubFK5:SetValue( "FK5_VLMOE2", nValEstrang )
								Else
									oSubFK5:SetValue( "FK5_VLMOE2", Iif(i!=4 .or. SE2->E2_MOEDA<=1,Round(NoRound(xMoeda(&cCpoTp.,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1),0) )
								EndIf
								If (SE2->E2_MOEDA > 1 .Or. nMoedaBco > 1)
									oSubFK5:SetValue( "FK5_TXMOED", nTxMoeda )
								Endif
							EndIf

							If lSpbInUse
								oSubFK5:SetValue( "FK5_MODSPB" , cModSpb )
							Endif

							If FwIsInCallStack("Fa050Subst") //Baixa ref. substituicao de titulo Provisorio para Efetivo.
								oSubFK5:SetValue( "FK5_LA" , "S" )
							Else
								If lPadraoBx .And. cLanca == "S"								
									Aadd(aCtBaixa, { "FK5",oSubFKA:GetValue("FKA_IDORIG") })
								Else
									oSubFK5:SetValue( "FK5_LA" , "N" )
								EndIf
							Endif
						Else
							cCamposE5 += ",{'E5_BANCO'   , '"+cBanco   +"' }"
							cCamposE5 += ",{'E5_AGENCIA' , '"+cAgencia +"' }"
							cCamposE5 += ",{'E5_CONTA'   , '"+cConta   +"' }"
							cCamposE5 += ",{'E5_NUMCHEQ' , '"+cCheque  +"' }"
							cCamposE5 += ",{'E5_DTDISPO' , STOD('" + DTOS(dDebito) + "')}"
						Endif
						
						If lF80GRVFK
							oSubFK5 := ExecBlock('F80GRVFK',.f.,.f.,{oSubFK5,nI})
						Endif				
					Else
						If oSubFKA:SeekLine({{'FKA_TABORI',"FK2"}})
							// Grava valores acessórios (FKD).
							If cTpDoc == "VA" .and. nVA != 0
								FSetFK6FKD(oSubFK6,cChaveFK7,cIdFK2,"P",dBaixa,SE2->E2_MOEDA,nMoedaBco,nTxMoeda,nCentMd1+1)
							Else
								If !oSubFK6:IsEmpty()
									//Inclui a quantidade de linhas necessárias
									oSubFK6:AddLine()
									//Vai para linha criada
									oSubFK6:GoLine( oSubFK6:Length() )
								Endif

								//Grava Valores acessórios.
								nValMovi := &cCpoTp
								nValCalc := &cCpoCalc							
								nValMovi := Iif(nValMovi == 0, nValCalc, nValMovi)
								nValCalc := Iif(nValCalc == 0, nValMovi, nValCalc)
								If cPaisLoc == "MEX" .AND. lMonedaC .AND. lfn450fk6
									fn450fk6(@oSubFK6,nValMovi,nValCalc,SE2->E2_MOEDA,nMoedaBco, nTxMoeda,cTpDoc)
								Else
									oSubFK6:SetValue( "FK6_VALMOV" , nValMovi)
									oSubFK6:SetValue( "FK6_VALCAL" , nValCalc)
								EndIf
								oSubFK6:SetValue( "FK6_TPDESC" , If(cTpDesc == 'C',"1","2" ))
								oSubFK6:SetValue( "FK6_TPDOC"  , cTpDoc )
								oSubFK6:SetValue( "FK6_RECPAG" , "P" )
								oSubFK6:SetValue( "FK6_IDORIG" , cIdFK2 )
								oSubFK6:SetValue( "FK6_TABORI" , "FK2" )
								oSubFK6:SetValue( "FK6_HISTOR" , cHistMov )
								If lPaisMI .And. lfn080mFk6
									fn080mFk6(@oSubFK6, nValMovi, SE2->E2_MOEDA, nMoedaBco, nTxMoeda, nTxModBco, cTpDoc)
								EndIf
							Endif

							If lF80GRVFK
								oSubFK6 := ExecBlock('F80GRVFK',.f.,.f.,{oSubFK6,nI})
							Endif

							// Gravacao de dados complementares da baixa
							If lSE5FI080
								cCamposE5 := ExecBlock('SE5FI080',.f.,.f.,{cCamposE5,oSubFK6})
							EndIf
						Endif
					Endif

					// Caso exista cheque já relacionado anteriormente para este titulo, atualiza sequencia.
					If lFina390
						dbSelectArea("SEF")
						MsGoto(nRegSEF)
						If !Eof()
							RecLock("SEF",.f.)
							SEF->EF_SEQUENC := cSequencia
							SEF->(MsUnlock())
						Endif
					Endif
					If !Empty(cCamposE5)
						cCamposE5 += "}"
					Endif
				Endif
			Next
		Endif
	Endif

	// Atualiza o Cadastro de Cheques Emitidos, se for em Banco
	If lRet .and. MovBcoBx(cMotBx, .T.) .and. !lAdiantamento .And. !lCNAB .and. TrazCodMot(cMotBx) != "DEB" .And. ChqMotBx(cMotBx)
		
		// Se for cheque pre-datado, nao cria novo cheque, pois este já foi criado quando da emissao do pre'datado.
		//GRAVACAO DO REGISTRO DA BAIXA NO SEF
		If !lChqPre .and. nValPgto > 0 .and. SE2->E2_IMPCHEQ != "S" .And.;
		!cBanco $ Left(GetMv("MV_CXFIN"),nTamCodA6) .And. !cBanco $ GetMv("MV_CARTEIR")

			cChaveCH := ""
			//Informar o novo campo EF_IDSEF nas inclusões de SEF:
			cChaveCH := FWUUIDV4()

			RecLock("SEF",.T.)
			SEF->EF_FILIAL	:= xfilial()
			SEF->EF_NUM		:= cCheque
			SEF->EF_BANCO	:= cBanco
			SEF->EF_AGENCIA	:= cAgencia
			SEF->EF_CONTA	:= cConta
			SEF->EF_VALOR	:= nValPgto
			SEF->EF_DATA	:= dBaixa
			SEF->EF_BENEF	:= IIF(Empty(cBenef),SA2->A2_NOME,cBenef)
			SEF->EF_PORTADO	:= cPortado
			SEF->EF_HIST	:= cHist070
			SEF->EF_PREFIXO	:= SE2->E2_PREFIXO
			SEF->EF_TITULO	:= SE2->E2_NUM
			SEF->EF_PARCELA	:= SE2->E2_PARCELA
			SEF->EF_FORNECE	:= SE2->E2_FORNECE
			SEF->EF_LOJA	:= SE2->E2_LOJA
			SEF->EF_TIPO	:= SE2->E2_TIPO
			SEF->EF_IMPRESS	:= If(!Empty(cCheque),"A"," ")
			SEF->EF_SEQUENC	:= cSequencia
			SEF->EF_ORIGEM 	:= "FINA080"
			SEF->EF_FILORIG	:= SE2->E2_FILORIG
			SEF->EF_FILCHQ  := cFilCorr
			SEF->EF_IDSEF	:= cChaveCH		//ID do cheque
			MsUnlock()
			lGerouSef := .T.

			//Em caso de baixa onde eh informado o cheque, gero FKA para o mesmo
			//Caso nao informe, nao devo gerar jah que FKA_IDORIG sera preenchido pela geracao de cheques (FINA190)
			If !Empty(cChaveCH)
				//Dados do movimento bancario do Cheque
				If !oSubFKA:IsEmpty()
					//Inclui a quantidade de linhas necessárias
					oSubFKA:AddLine()
					//Vai para linha criada
					oSubFKA:GoLine( oSubFKA:Length() )
				Endif

				//Dados do Cheque  //revisar
				oSubFKA:SetValue( 'FKA_IDORIG', cChaveCH )
				oSubFKA:SetValue( 'FKA_TABORI', 'SEF' )
				If lIsRussia .AND. Type("cIDProc") == "C"
					oSubFKA:SetValue( 'FKA_IDPROC', cIDProc )
				EndIf
			Endif

			If ExistBlock("FA080SEF")
				Execblock("FA080SEF",.F.,.F.)
			Endif
		Endif

		//Gera registro no SE5 para a geracao do cheque e gera cheque no SEF.
		If lGerouSef

			cSeqCheque := Soma1(cSequencia,nTamSeq)

			If !Empty(cCheque) // Somente gera movimento banc rio caso cheque preenchido.

				//Model de Movimento bancario
				If oModelMov == nil 
					oModelMov := FWLoadModel("FINM030")
				EndIf
				oModelMov:SetOperation( 3 ) //Inclusao
				oModelMov:Activate()
				oSubFK5M  := oModelMov:GetModel("FK5DETAIL")
				oSubFKAM  := oModelMov:GetModel("FKADETAIL" )

				//Grava movimento do cheque - FK5
				If lLibCheq .And. Subs(cCheque,1,1)!="*"
					RecLock("SEF")
					SEF->EF_LIBER   := "S"
					If lPadraoBx .And. cLanca == "S" .and. cContabiliza $ "BA" .and. !lUsaFlag
						SEF->EF_LA  := "S"
					EndIf
					MsUnlock()

					// Inclui registro no SE5 para a geracao do cheque
					cCamposE5M += "{ {'E5_DTDIGIT',dDataBase     }"
					cCamposE5M += " ,{'E5_BENEF'  ,'"+cBenef +"' }}"

					oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5M )
					oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
					oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo

					lModelMov	 := .T.

					//Dados do movimento bancario do Cheque
					If !oSubFKAM:IsEmpty()
						//Inclui a quantidade de linhas necessárias
						oSubFKAM:AddLine()
						//Vai para linha criada
						oSubFKAM:GoLine( oSubFKAM:Length() )
					Endif

					cHistMov := Iif(!Empty(cHist070),cHist070,OemToAnsi( STR0111 )) //"Valor pago s /Titulo"

					oSubFKAM:SetValue( 'FKA_IDORIG', FWUUIDV4() )
					oSubFKAM:SetValue( 'FKA_TABORI', 'FK5' )

					If lIsRussia .AND. Type("cIDProc") == "C"
						oSubFKA:SetValue( 'FKA_IDPROC', cIDProc )
					EndIf

					oSubFK5M:SetValue( "FK5_RECPAG" , "P" )
					oSubFK5M:SetValue( "FK5_HISTOR" , cHistMov )
					oSubFK5M:SetValue( "FK5_DATA"   , dBaixa )
					oSubFK5M:SetValue( "FK5_DTDISP" , dDebito )
					oSubFK5M:LoadValue( "FK5_NATURE" , SE2->E2_NATUREZ )
					oSubFK5M:SetValue( "FK5_BANCO"  , cBanco )
					oSubFK5M:SetValue( "FK5_AGENCI" , cAgencia )
					oSubFK5M:SetValue( "FK5_CONTA"  , cConta )
					oSubFK5M:SetValue( "FK5_NUMCH"  , cCheque )
					oSubFK5M:SetValue( "FK5_SEQ"    , cSeqCheque )
					oSubFK5M:SetValue( "FK5_VALOR"  , nValPgto )
					oSubFK5M:SetValue( "FK5_ORIGEM" , FunName() )
					oSubFK5M:SetValue( "FK5_TPDOC"  , "CH" )
					oSubFK5M:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
					oSubFK5M:SetValue( "FK5_FILORI" , SE2->E2_FILORIG )
					oSubFK5M:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
					oSubFK5M:SetValue( "FK5_LOTE"   , cLoteFin )
					If lSpbInUse
						oSubFK5M:SetValue( "FK5_MODSPB" , cModSpb )
					Endif
					If lPadraoBx .And. cLanca == "S"
						Aadd(aCtBaixa, { "FK5",oSubFKAM:GetValue("FKA_IDORIG") })
					Else
						oSubFK5M:SetValue( "FK5_LA" , "N" )
					EndIf

					If nValEstrang != 0
						oSubFK5M:SetValue( "FK5_VLMOE2", nValEstrang )
					Else
						oSubFK5M:SetValue( "FK5_VLMOE2", Iif(i!=4 .or. SE2->E2_MOEDA<=1,Round(NoRound(xMoeda(&cCpoTp.,nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1),0) )
					EndIf
					If (SE2->E2_MOEDA > 1 .Or. nMoedaBco > 1)
						oSubFK5M:SetValue( "FK5_TXMOED", nTxMoeda )
					Endif
				Endif

				//GRAVACAO DO REGISTRO DO CHEQUE DA BAIXA NO SEF (SE HOUVER NRO DE CHEQUE)
				If Subs(cCheque,1,1)!="*"
					//Gera cheque
					cSeqCheque := Soma1(cSequencia,nTamSeq)
					//Informar o novo campo EF_IDSEF nas inclusões de SEF:
					cChaveCH := FWUUIDV4()

					RecLock("SEF",.T.)
					SEF->EF_FILIAL	:= xfilial()
					SEF->EF_NUM		:= cCheque
					SEF->EF_BANCO	:= cBanco
					SEF->EF_AGENCIA	:= cAgencia
					SEF->EF_CONTA	:= cConta
					SEF->EF_VALOR	:= nValPgto
					SEF->EF_DATA	:= dBaixa
					SEF->EF_BENEF	:= IIF(Empty(cBenef),SA2->A2_NOME,cBenef)
					SEF->EF_PORTADO	:= cPortado
					SEF->EF_HIST	:= cHist070
					SEF->EF_LIBER	:= If(lLibCheq,"S"," ")
					SEF->EF_SEQUENC	:= cSeqCheque
					SEF->EF_ORIGEM	:= "FINA080"
					SEF->EF_FILORIG	:= cFilant
					SEF->EF_FILCHQ  := cFilCorr
					SEF->EF_IDSEF	:= cChaveCH		//ID do cheque
					MsUnlock()

					//Gero informacao de amarracao apenas se gerei movimento bancario
					If lModelMov
						//Dados do Cheque
						If !oSubFKAM:IsEmpty()
							//Inclui a quantidade de linhas necessárias
							oSubFKAM:AddLine()
							//Vai para linha criada
							oSubFKAM:GoLine( oSubFKAM:Length() )
						Endif
						oSubFKAM:SetValue( 'FKA_IDORIG', cChaveCH )
						oSubFKAM:SetValue( 'FKA_TABORI', 'SEF' )
					Endif
				EndIf

				//Grava os dados
				If lModelMov
					If oModelMov:VldData()
						oModelMov:CommitData()

						nRecSE5 := oModelMov:GetValue("MASTER","E5_RECNO")
						SE5->(dbGoTo(nRecSE5))
					Else
						lRet := .F.
						cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
						cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
						cLog += cValToChar(oModelMov:GetErrorMessage()[6])

						Help( ,,"M020VLDI6",,cLog, 1, 0 )
					Endif
					oModelMov:DeActivate()
				Else
					oModelMov:DeActivate()
				Endif
			Endif
		EndIf

		// Atualiza o totalizador
		If lRet .and. SubStr(cCheque,1,1) = "*" .and. nValPgto > 0 .And. SE2->E2_IMPCHEQ != "S"
			dbSelectArea("SEF")
			SEF->( MsSeek(xFilial("SEF")+cBanco+cAgencia+cConta+cCheque+cSeqCheque) )
			nRecNo := 0
			While !SEF->( Eof() )	.And. SEF->EF_FILIAL	 =	 cFilial  ;
			.And. SEF->EF_BANCO	 =  cBanco	 ;
			.And. SEF->EF_AGENCIA =  cAgencia ;
			.And. SEF->EF_CONTA	 =  cConta	 ;
			.And. SEF->EF_NUM 	 =  cCheque
				nRecNo := IIf(Empty(SEF->EF_TITULO),SEF->(RecNo()),nRecNo)
				dbSkip( )
			Enddo
			If nRecNo == 0 .And. !cBanco $ Left(GetMv("MV_CXFIN"),nTamCodA6) .And. !cBanco $ GetMv("MV_CARTEIR")

				//Para cheque com * no numero, nao sera gerado registro de rastreio (FKA) pois nao tem movto bancario.
				//Pois o rastreio somente sera gerado na impressao do cheque.
				//Gera cheque
				cSeqCheque := Soma1(cSequencia,nTamSeq)

				RecLock("SEF",.T.)
				SEF->EF_FILIAL	:= xFilial("SEF")
				SEF->EF_NUM		:= cCheque
				SEF->EF_BANCO	:= cBanco
				SEF->EF_AGENCIA	:= cAgencia
				SEF->EF_CONTA	:= cConta
				SEF->EF_VALOR	:= nValPgto
				SEF->EF_DATA	:= dBaixa
				SEF->EF_BENEF	:= IIF(Empty(cBenef),SA6->A6_NOME,cBenef)
				SEF->EF_SEQUENC	:= PadL("1",TamSX3("EF_SEQUENC")[1],"0")
				SEF->EF_ORIGEM	:= "FINA080"
				MsUnlock()

			Else
				dbGoTo( nRecNo )
				RecLock("SEF")
				SEF->EF_VALOR	+= nValPgto
				SEF->EF_DATA	:= dBaixa
				SEF->(MsUnlock())
			Endif
		Endif
	Endif

	//Encerro a gravacao da Baixa (oModelBxP)
	If lRet .and. !lAdiantamento

		FWModelActive(oModelBxP)
		oModelBxP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
		//Grava os dados
		If oModelBxP:VldData()
			oModelBxP:CommitData()

			nRecSE5 := oModelBxP:GetValue("MASTER","E5_RECNO")
			nSavRec := nRecSE5
			SE5->(dbGoTo(nRecSE5))
			If lPadraoBx .And. cLanca == "S"
				cIDMovE5 := SE5->E5_IDORIG
				Aadd(aCtBaixa, { "SE5", nRecSE5 })

				aAreaCTB := SE5->(GetArea())
				DbSelectArea("SE5")
				SE5->(DbSetOrder(21))
				If SE5->(DbSeek(xFilial("SE5")+ cIDMovE5))
					While SE5->(!EoF()) .and. SE5->E5_IDORIG == cIDMovE5
						If SE5->E5_TIPODOC  $ "JR|DC|VA|MT"
							Aadd(aCtBaixa, { "SE5", SE5->( Recno() ) })
						EndIf
						SE5->(DbSkip())
					EndDo
				Endif

				RestArea(aAreaCTB)

			EndIf
			
			// Atualiza saldo bancario na baixa por lote
			If FwIsInCallStack('Fa080Lot') .Or. ( FwIsInCallStack("fa430gera") .And. !FwIsInCallStack("Fa080Tit") )
				If !lAdiantamento .And. MovBcoBx(cMotBx, .T.)
					If (!ChqMotBx(cMotBx) .and. IF(lCnab, !lBxCnab, .T.) ) .Or.;
					(cBanco $ Left(GetMv("MV_CXFIN"),nTamCodA6) .Or. cBanco $ GetMv("MV_CARTEIR")) .Or.;
					((!Empty(cCheque) .And. Substr(cCheque,1,1) != "*") .And. GetMV("MV_LIBCHEQ") == "S" .And. SE2->E2_IMPCHEQ != "S")

						AtuSalBco( cBanco, cAgencia, cConta, dDebito, nValPgto, "-" )
					EndIf
				Endif
			EndIf
		Else
			lRet := .F.
			cLog := cValToChar(oModelBxP:GetErrorMessage()[4]) + ' - '
			cLog += cValToChar(oModelBxP:GetErrorMessage()[5]) + ' - '
			cLog += cValToChar(oModelBxP:GetErrorMessage()[6])

			Help( ,,"M020VLDI5",,cLog, 1, 0 )
		Endif
	Endif

	If lCNAB
		__aCtb430 := aCtBaixa
	Endif

	If ValType(oModelBxPA) <> "U"
		oModelBxPA:DeActivate()
		oModelBxPA:Destroy()
		oModelBxPA:= Nil
	EndIf
	If ValType(oModelBxP) <> "U"
		oModelBxP:DeActivate()
	EndIF
	If ValType(oModelMov) <> "U"
		oModelMov:DeActivate()
	EndIf

	oSubFK2:= Nil
	oSubFK3:= Nil
	oSubFK4:= Nil
	oSubFK5:= Nil
	oSubFK6:= Nil
	oSubFKA:= Nil
	oSubFKAA:= Nil
	oSubFK2A:= Nil
	oSubFK3A:= Nil
	oSubFKAM:= Nil
	oSubFK5M:= Nil
	
	nSE2Recno := SE2->(RECNO())
	nSE5Recno := SE5->(RECNO())
	
	If lRet
		Begin Sequence

		dbSelectArea("SEF")
		SEF->(dbSetOrder(1))
		dbSelectArea("SE2")
		SE2->(dbSetOrder(nOrdBx))
		SE2->(dbGoto(nSalvRec))
		SED->(MsSeek(xFilial("SED", SE2->E2_FILORIG)+SE2->E2_NATUREZ))
		lAchouFor := SA2->(MsSeek(xFilial("SA2", SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA))
		
		If lAtuForn .And. lAchouFor //Atualiza o Cadastro de Fornecedores
			nMCusto := Val(GetMv("MV_MCUSTO"))
			
			If nMoedaBco = 1 .And. nMoedaBco == SE2->E2_MOEDA
				nSaldup  := Round(nValPgto, 2)
			ElseIf SE2->E2_MOEDA == 1
				nSaldup  := Round(xMoeda(nValPgto, nMoedaBco, 1, dBaixa, nCasDec, nTxMoeda), 2)
			ElseIf nMoedaBco == 1
				nSaldup  := xMoeda(nValPgto, 1, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda)
				nSaldup  := xMoeda(nSaldup, SE2->E2_MOEDA, 1, SE2->E2_EMISSAO, nCasDec, SE2->E2_TXMOEDA)
			ElseIf nMoedaBco == SE2->E2_MOEDA 
				nSaldup  := Round(xMoeda(nValPgto, SE2->E2_MOEDA, 1, SE2->E2_EMISSAO, nCasDec, SE2->E2_TXMOEDA), 2)
			Else
				nSaldup  := xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTxMoeda, SE2->E2_TXMOEDA)
				nSaldup  := Round(xMoeda(nSaldup, SE2->E2_MOEDA, 1, SE2->E2_EMISSAO, nCasDec, SE2->E2_TXMOEDA), 2)
			EndIf
			
			If SE2->E2_TXMOEDA > 0 .And. nMCusto == SE2->E2_MOEDA   
				nSaldupm := Round(xMoeda(nSaldup, 1, nMCusto, SE2->E2_EMISSAO, nCasDec, 0, SE2->E2_TXMOEDA), 2)
			Else
				nSaldupm := Round(xMoeda(nSaldup, 1, nMCusto, SE2->E2_EMISSAO, nCasDec, 0), 2)
				nSaldup	 := Round(nSaldup, 2)
			EndIf
			
			RecLock("SA2")
			
			If SE2->E2_TIPO $ MVPAGANT+"|"+MV_CPNEG
				SA2->A2_SALDUP	+= nSaldup
				SA2->A2_SALDUPM	+= nSaldupm
			Else
				SA2->A2_SALDUP  -= nSaldup
				SA2->A2_SALDUPM	-= nSaldupm
			Endif
			
			If (nAtraso := (dBaixa - SE2->E2_VENCTO)) > 1
				If (Dow(SE2->E2_VENCTO) == 1 .Or. Dow(SE2->E2_VENCTO) == 7) .And. Dow(dBaixa) == 2 .And. nAtraso <= 2
					nAtraso := 0
				EndIf
				
				If SA2->A2_MATR < nAtraso
					SA2->A2_MATR := nAtraso
				EndIf
			Endif
			
			SA2->(MSUnlock())
			dbSelectArea("SE2")
			SE2->(dbGoTo(nSalvRec))
		Endif
		
		dbSelectArea("SE2")
		dbGoto(nSalvRec)

		//Altera o vencimento dos impostos
		If !_lPccMR .And. !lPccBaixa
			AltVencImp(SE2->E2_BAIXA)
		Endif

		//Acerto dos impostos Pis, Cofins e Csll
		If !_lPccMR .And. (cPaisLoc=="BRA") .And. !lPccBaixa .and. (nJuros > 0 .or. nDescont > 0 .or. nMulta > 0 ) .and. (SE2->E2_PIS+SE2->E2_COFINS+SE2->E2_CSLL > 0)
			F080Impost(nSalvRec,.F.,nJuros,nMulta,nDescont,nValPgto)
		Endif

		If lRetManual
			lRetParc := .T.
		EndIf

		//Posiciono o SE5 para titulos que não sejam adiantamendo (PA/NDF)
		If !lAdiantamento
			SE5->(dbGoTo(nSavRec))
		EndIf

		//Gravação FK3/FK4 dos impostos via conf Motor Retenção
		If _lTemMR
			If (SE2->E2_TIPO $ MVPAGANT)
				FMRDelImp(_cTabOri, _cIdOrig)
			ElseIf Len(_aImpMR) > 0
				FinGrvImp("1" , SE2->(Recno()), _aImpMR, "FINA080", .F., {}, {}, .F., .F., .T., dBaixa, "FK2",cSequencia)
			EndIf

			//Posiciono o SE5 para titulos que não sejam adiantamendo (PA/NDF)
			If !lAdiantamento
				SE5->(dbGoTo(nSavRec))
			EndIf
		EndIf
		
		If !lIsRussia
			//Gravo os titulos de impostos Pis Cofins Csll quando controlados pela baixa
			If (lContrRet .and. lPccBaixa .and. lRetParc .and. lGerImp ).or. ;
				(lCalcIssBx  .and. nIss > 0) .OR. (lIRPFBaixa .AND. nIrrf > 0.00)

				cGeraDirf := If(Empty(SE2->E2_CODRET), "2", "1")

				If !_lIrfMR .And. SE2->E2_IRRF > 0 .and. !lIRPFBaixa //teve IR na emissão
					aArea := SE2->(GetArea())
					cChave := SE2->(E2_PREFIXO+E2_NUM+E2_PARCIR)+MVTAXA
					//prefixo+loja do titulo de ir
					cChave += GetMV("MV_UNIAO")+Space(Len(E2_FORNECE)-Len(GetMV("MV_UNIAO")))+PadR( "00", Len( SE2->E2_LOJA ), "0" )
					SE2->(DBSetOrder(1))
					If SE2->(DbSeek(xFilial("SE2",SE2->E2_FILORIG)+cChave))
						cGeraDirf := If(Empty(SE2->E2_CODRET), "2", "1")
					EndIf
					RestArea(aArea)
				EndIf
				aAreaSED  := SED->(GetArea())
				If !(lRet := FGrvImpPcc(@nPis,@nCofins,@nCsll,nSalvRec,.F.,lRetParc,cSequencia,"FINA080",SE2->E2_MOEDA,cGeraDirf,nIrrf,nIss,,,,_lPccMR,_lIrfMR,_lInsMR,_lIssMR,_lCidMR,_lSesMR,IIF(__oRatIRF <> Nil,__oRatIRF:aRatIRF,Nil)))
					Break
				EndIf
				RestArea(aAreaSED)
			Endif

			// Retenção CIDE na BAIXA
			If lCideBX .And. nCide > 0
				// Calcula o vencto do imposto
				dVenc := F050VIMP("CIDE",dBaixa,dDataBase)
				// Gravação do Título de CIDE
				FGrvCIDE( nCide, dBaixa, dVenc, nSalvRec, cSequencia, "FINA080")
			EndIf
		EndIf

		// Integração SIGAPFS x SIGAFIN
		If lIntPFS .And. FindFunction("JSetImpLan")
			JSetImpLan(SE2->(RECNO()))
		EndIf
		
		// Integração SIGAPFS x SIGAFIN
		If lRet .And. FindFunction("JGrvBxPag") .And. lIntPFS
			lRet := JGrvBxPag(nSE2Recno, 3, nSE5Recno)
			If !lRet
				If InTransact()
					RollBackDelTran()
				EndIf
			EndIf
		EndIf

		dbSelectArea("SE2")
		dbGoto(nSalvRec)
		If !(SE2->E2_TIPO $ "INA" +"/"+ IIF(!lBxTxa,MVTXA,'')) .OR. FwIsInCallStack("FINA870")//Não atualiza os campos de baixa no SE2 para titulos de INSS Antecipado
			RecLock("SE2")
			Replace E2_SALDO	  With nSaldo
			IF cPaisLoc=="EUA"
				If FUNNAME() # "FINA884"
					Replace E2_SLPLAID    With nSaldo //With E2_SLPLAID - (&cCpotp)
				EndIF
			ENDIF
			MsUnlock()

			//---------------------------------------------------------------------------------------------------
			// Busca o titulo pai - necessario em caso de baixa de titulo gerado na inclusao de titulo a receber
			//---------------------------------------------------------------------------------------------------
			cChaveTit := SE2->(E2_FILIAL+"|"+E2_PREFIXO+"|"+E2_NUM+"|"+E2_PARCELA+"|"+E2_TIPO+"|"+E2_FORNECE+"|"+E2_LOJA)
			aTitPai := F080TitPai('SE2',cChaveTit)

			FINGRVFK7('SE2', cChaveTit,, aTitPai[1], aTitPai[2])
		EndIf
		
		If SE2->E2_PREFIXO=="AGP" // Força a baixa dos títulos aglutinados na FI9 caso eles já tenham sido baixados na SE2
			dbSelectArea("FI9")
			dbSetOrder(3)
			If dbSeek(xFilial("FI9",SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)
				RecLock("FI9")
				Replace FI9->FI9_STATUS WITH "B"
				MsUnlock()
			Endif
			dbSelectArea("SE2")
		Endif

		FA373Bx(.T.)

		// Actualizaciones MI
		If lAdiantamento .And. lPaisMI .And. !IsInCallStack("fn086Grv")
			If Round(SE2->E2_SALDO,2) + Round(SE2->E2_SDACRES,2) == 0 .And. FindFunction("F080ActSEK")
				// Actualiza status de la orden de pago
				F080ActSEK(SE2->E2_NUM, .T.)
			EndIf

			If FindFunction("F080ActPA")
				// Actualiza valor y status SE5 del PA (si MV_ESTORDP=N)
				F080ActPA(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_EMISSAO, nValPgto, nMoedaBco, nMoedaTit, dBaixa, nTxModBco, nTxModTit)
			EndIf
			If cPaisLoc == "COL" .and. FindFunction("FINXBJ4XML")
				//Colombia. Actualiza el estatus del impuesto (IT) 4xMil (GMF) en la baja del PA
				FINXBJ4XML( SE2->E2_NUM,SE2->E2_PREFIXO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_EMISSAO,cBanco,cAgencia,cConta,.F.)
			EndIf
		EndIf

		//Gera Log da baixa
		DbSelectArea("SE2")
		FinaCONC({{STR0006,STR0006+' - '+FunName(),'','',;
		STR0111 +' : ' + Alltrim(Transform(SE5->E5_VALOR,PesqPict("SE5","E5_VALOR")))}})
		End Sequence
	Endif

	FWFreeArray(aTitPai)

Return lRet /*Function fA080Grv*/

//-------------------------------------------------------------------
/*/{Protheus.doc}fa080ChkVdr
Verifica se o Combo do Motivo da Baixa est  como VENDOR		
@author Vincius S. Barreira
@since  18/12/1995
/*/
//-------------------------------------------------------------------
Function fa080ChkVdr()
	If TrazCodMot(cMotBx) == "VEN"
		Fa080Vdr()
	Endif

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc}ValidaTot
Verifica Valor total 		
@author Vincius S. Barreira
@since  18/12/1995
/*/
//-------------------------------------------------------------------
Function ValidaTot(cLote)
	LOCAL lRet := .t.
	Do Case
		Case !CarregaSa6(@cBanco,@cAgencia,@cConta,.T.,,.T.)
		lRet := .F.
		Case Empty(cLote)
		lRet := .F.
		Case nTotGer+nTotDesp-nTotDesc+nTotMul+nTotJur != nDebConta //(Soma despesa)
		Help(" ",1,"VLRTOTINV")
		lRet := .f.
	EndCase
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}MontaTot
Monta Valor total 		
@author Vincius S. Barreira
@since  18/12/1995
/*/
//-------------------------------------------------------------------
Function MontaTot(oGet)
	nDebConta := nTotGer+nTotDesp-nTotDesc+nTotMul+nTotJur
	oGet:refresh()
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc}Fa080Inverte
Marca e Desmarca Titulos, invertendo a marca‡†o existente 		
@author Wagner Xavier
@since  07/11/1995
/*/
//-------------------------------------------------------------------
Function Fa080Inverte(cMarca,oValor,oQtda,lTodos)
	LOCAL nReg 		:= SE2->(Recno())
	LOCAL lBxTit 	:= .T.
	LOCAL lBxTitVL 	:= .T.
	LOCAL lVldTit 	:= .F.
	Local lF080VLAD := ExistBlock("F080VLAD")
	Local lFinVDoc	:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios
	Local lPrimeiro :=.T.
	Local nTxMoeda  := 0
	Local nCentMd1	:= MsDecimais(1)
	Local nCont 	:= 0
	
	If __lVlTitAd == NIL
		__lVlTitAd	:= GetNewPar("MV_VLTITAD",.F.)
	Endif

	DEFAULT lTodos := .T.

	dbSelectArea("SE2")
	If lTodos
		dbSeek(cFilial)
	EndIf
	While !lTodos .or. (!Eof() .and. cFilial == SE2->E2_FILIAL)
		If (lTodos .And. SE2->(MsRLock())) .Or. !lTodos

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Caso tenha sido gerado pelo SigaEic e do tipo INV e do BRASIL nao podera se baixado se nao for pela rotina automatica ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (Type('lF080Auto') == 'U' .or. !lF080Auto) .and. lIntegracao .and. cPaisloc = "BRA" .and.  SE2->E2_TIPO = "INV"  .and. UPPER(SE2->E2_ORIGEM) = "SIGAEIC"
				HELP(" ",1,"FAORIEIC")
				//DFS - 16/03/11 - Deve-se verificar se os títulos foram gerados por módulos Trade-Easy, antes de apresentar a mensagem.
				// NCF - 25/03/13 - Acrescentado o módulo SIGAESS (Siscoserv)
			Elseif (Type('lF080Auto') == 'U' .or. !lF080Auto) .and. cPaisloc = "BRA" .AND. UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEEC/SIGAEFF/SIGAEDC/SIGAECO/SIGAESS" .AND. !(cModulo $ "EEC/EFF/EDC/ECO/ESS")
				HELP(" ",1,"FAORIEEC")
			Else
				IF E2_OK == cMarca
					SE2->E2_OK := "  "
					//Calculo da Moeda caso o titulo possua taxa cadastrada
					nTxMoeda := If(SE2->E2_MOEDA > 1,If(SE2->E2_TXMOEDA > 0 .and. Empty(SE2->E2_DTVARIA), SE2->E2_TXMOEDA,RecMoeda(dBaixa,SE2->E2_MOEDA)),0)
					nValor -= xMoeda((SE2->E2_SALDO+SE2->E2_SDACRES-SE2->E2_SDDECRE),SE2->E2_MOEDA,nMoedaBco,,,nTxMoeda)
					nQtdtit--
					nValor := Iif(nValor<0,0,nValor)
					nQtdTit:= Iif(nQtdTit<0,0,nQtdTit)
				Else
					lBxTit := .T.
					lBxTitVL := .T.
					lVldTit:=.F.
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Verifica se existe Adiantamento ou Devolucao ³
					//³ para o Fornecedor do título a ser baixado.   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If __lVlTitAd.And. !(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG)
						nBusca := F090BuscAD( "__SE2", SE2->E2_FORNECE, SE2->E2_LOJA )
						If nBusca <> 0
							lAD := .T.
							cMsg := STR0144 //"O Fornecedor deste titulo possui "
							Do Case
								Case nBusca = 1 // Adiantamento
								cMsg += STR0145 //"Adiantamento."
								Case nBusca = 2 // Devolucao
								cMsg += STR0146 //"Devolucao."
							End Case
							cMsg += chr(13)+chr(10)
							cMsg += STR0147 //"Deseja mesmo assim baixa-lo ?"
							If isBlind()
								If lF080VLAD
									If (ExecBlock("F080VLAD",.F.,.F.))
										SE2->E2_OK := cMarca
										lVldTit:=.T.
									Endif
								Endif
							Else
								If MsgYesNo( cMsg )
									SE2->E2_OK := cMarca
									lVldTit:=.T.
								Endif
							Endif
						Else
							SE2->E2_OK := cMarca
							lVldTit:=.T.
						Endif
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica se existe Adiantamento de INSS      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					ElseIf 	__lVlTitAd .And. SE2->E2_TIPO $ MVINSS
						nBusca := 0
						If !Empty(SE2->E2_TITPAI)
							If F090LocINA( SE2->E2_TITPAI )
								If !isBlind()
									If MsgYesNo( "Existem titulos de INSS retido em pagamentos antecipados ainda pendentes de compensação para este fornecedor, efetua a baixa mesmo assim?" )
										SE2->E2_OK := cMarca
										lVldTit:=.T.
									Endif
								Else
									SE2->E2_OK := "  "
									lVldTit:=.F.
								Endif
							EndIf
						Endif

					Else
						SE2->E2_OK := cMarca
						lVldTit:=.T.
					Endif
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Caso tenha integracao SIGAPFS (MV_JURXFIN = .T.), valida as regras para manipulacao do título.  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lVldTit .And. !Fa080Juri(lTodos, @lPrimeiro)
						SE2->E2_OK := "  "
						cMarca	  := "  "
						Return .F.
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Caso tenha integracao Documentos  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					IF lFinVDoc
						If !CN062ValDocs("04",.F.,.F.,lTodos,@lPrimeiro)
							SE2->E2_OK := "  "
							lVldTit:=.F.
						EndIf
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ PONTO DE ENTRADA F080BXLT                                     ³
					//³ Verifica se titulo pode ser marcado para baixa ou nÆo. Caso	  ³
					//³ tenha sido alterada a marca‡Æo do titulo, ExecBlock dever     ³
					//³ retornar .F., para nÆo haver altera‡Æo dos acumuladores de    ³
					//³ valores e numero de titulos.                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					IF (ExistBlock("F080BXLT")) .and. !Empty(E2_OK)
						lBxTit := ExecBlock("F080BXLT",.F.,.F.)
					Endif

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ PONTO DE ENTRADA F080BXVL                                  ³
					//³Ponto de entrada que permite ao usuário determinar se um    ³
					//³título deve ou não ser selecionado, de acordo com as regras ³
					//³estabelecidas no ponto de entrada.  O PE F080BXLT não       ³
					//³controlava a marcação dos títulos, sendo necessário criar   ³
					//³este novo PE por questão de legado. Retorno .F. impede sel. ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If (ExistBlock("F080BXVL")) .and. !Empty(E2_OK)
						lBxTitVL := ExecBlock("F080BXVL",.F.,.F.)
						If ValType(lBxTitVL) == "L" .AND. !lBxTitVL
							If SE2->E2_OK == cMarca
								RecLock("SE2",.F.)
								SE2->E2_OK := "  "
								MsUnlock()
							Endif
						Else
							lBxTitVL := .T.
						Endif
					Endif

					If lBxTit .AND. lVldTit .AND. lBxTitVL
						//Calculo da Moeda caso o titulo possua taxa cadastrada
						nTxMoeda	 := If(SE2->E2_MOEDA > 1,If(SE2->E2_TXMOEDA > 0 .and. Empty(SE2->E2_DTVARIA), SE2->E2_TXMOEDA,RecMoeda(dBaixa,SE2->E2_MOEDA)),0)
						nValor += xMoeda((SE2->E2_SALDO+SE2->E2_SDACRES-SE2->E2_SDDECRE),SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda)
						nQtdtit++
					Endif
				Endif

			Endif
		EndIf
		If nOpc1 == 1 .And. dBaixa < SE2->E2_EMISSAO
			If nCont <> 1
				Help( " ", 1, "DATAERRP",,STR0195,1,0 )
			Endif
			SE2->E2_OK := "  "
			nCont := 1
		Endif
		If lTodos
			SE2->(dbSkip())
		Else
			Exit
		EndIf
	Enddo
	SE2->(dbGoto(nReg))
	oValor:Refresh()
	oQtda:Refresh()
	oMark:oBrowse:Refresh(.t.)
Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} fa080BcoCx
Correcao de n§. do cheque para Banco = "CX"

@author Mauricio Pequim Jr 
@since 17/03/1998
/*/
//-------------------------------------------------------------------
Function fa080BcoCx()
	Local lRet := .T.

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lFa080Bco := ExistBlock("FA080BCO")
    DEFAULT nTamCodA6 := TamSX3("A6_COD")[1]

	If cBanco $ Left(GetMv("MV_CXFIN"),nTamCodA6) .Or.  cBanco $ GetMv("MV_CARTEIR")

		cCheque := Space(15)
		If Type("oCheque")=="O"
			oCheque:Refresh()
		Endif

	Endif

	If lFa080Bco
		lRet := ExecBlock("FA080BCO", .F., .F., {cBanco,cAgencia,cConta})
	Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080BDev
Limpa conteudo de Bco/Age/Cta/N.Chque se baixa DEVOLUCAO

@author Mauricio Pequim Jr 
@since 02/06/1998
/*/
//-------------------------------------------------------------------
FUNCTION Fa080BDev(lValida AS LOGICAL) AS LOGICAL
	LOCAL aArea     AS ARRAY
	LOCAL aAreaSef  AS ARRAY
	LOCAL cChave_EF AS CHARACTER
	LOCAL lRet      AS LOGICAL
	LOCAL nTamChq   AS NUMERIC
    
	DEFAULT lValida := .T.

	aArea     := GetArea()
	aAreaSef  := SEF->(GetArea())
	lRet      := .T.
	nTamChq   := TamSX3("EF_NUM")[1]
    cChave_EF := ""

	If !MovBcoBx(cMotBx, .T.)
		cBanco	 := CriaVar("A6_COD")
		cAgencia := CriaVar("A6_AGENCIA")
		cConta	 := CriaVar("A6_NUMCON")
		cCheque  := CriaVar("EF_NUM")
        __nTxMoeda := RecMoeda(__dBaixa,1)
		If Type('lF080Auto') == 'U' .or. !lF080Auto .And. Type("oBanco") == "O" .and. Type("oCheque")=="O"
			oBanco:Refresh()
			oAgencia:Refresh()
			oConta:Refresh()
			oCheque:Refresh()
		Endif
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se tem cheque relacionado ao Titulo, vasculha SEF c/ sequencia em  ³
		//³ branco (Gerado pelo Chq s/ Titulo) e carrega Bco/Ag/Conta e N§Chq  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SEF")
		dbSetOrder(3)
		If SE2->E2_IMPCHEQ=="S" .and. SEF->(dbseek(xFilial("SEF")+SE2->E2_PREFIXO+SE2->E2_NUM+;
		SE2->E2_PARCELA+SE2->E2_TIPO))

			cChave_EF := xFilial("SEF")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO
			DO WHILE (cChave_EF == SEF->EF_FILIAL + SEF->EF_PREFIXO+SEF->EF_TITULO;
			+SEF->EF_PARCELA+SEF->EF_TIPO) .and. !(SEF->(EOF()))
				IF empty(SEF->EF_SEQUENC) .and. SE2->(E2_FORNECE+E2_LOJA) == SEF->(EF_FORNECE+EF_LOJA)
					cBanco  :=SEF->EF_BANCO
					cAgencia:=SEF->EF_AGENCIA
					cConta  :=SEF->EF_CONTA
					cCheque :=SEF->EF_NUM
					If Type('lF080Auto') == 'U' .or. !lF080Auto .And. Type("oBanco") == "O" .and. Type("oCheque")=="O"
						oBanco:Refresh()
						oAgencia:Refresh()
						oConta:Refresh()
						oCheque:Refresh()
					Endif
					If !Empty(SEF->EF_NUM)
						EXIT
					Endif
				Endif
				SEF->(DbSkip())
			ENDDO
		EndIf
		Sef->(RestArea(aAreaSef))
		RestArea(aArea)
	Endif

	lRet:=Fa080ValCh(lValida)

	If TrazCodMot(cMotBx) == "DEB"  .and. lRet
		cCheque 	:= space(nTamChq)
		If Type('lF080Auto') == 'U' .or. !lF080Auto .And. Type("oBanco") == "O" .and. Type("oCheque")=="O"
			oCheque:Refresh()
			oBanco:Refresh()
			oAgencia:Refresh()
			oConta:Refresh()
		EndIF
	Endif

Return (lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} F080MtBx
Ponto de Entrada para validar o motivo da baixa digitada.

@author Andrea V. Santiago 
@since 29/06/2011
/*/
//-------------------------------------------------------------------
Function F080MtBx()
	Local lRet      := .T.
	Local lF080MtBx := Existblock("F080MTBX")

	If	lF080MtBx
		lRet := ExecBlock("F080MTBX",.F.,.F.)
	Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FA080Refre
Da Refresh() nos objetos

@author Mauricio Pequim Jr
@since 27/08/1998
/*/
//-------------------------------------------------------------------
FUNCTION FA080Refre(nCampo)
	DEFAULT nCampo := 0
	IF SE2->E2_MOEDA > 1
		oVlEstrang:Refresh()
		If Type('lF080Auto') == 'U' .or. !lF080Auto
			IIf( cPaisloc <> "CHI",oCm:Refresh(),.T.)
		EndIF
	ENDIF
	If nCampo == 1 // Valor do Pagto.
		If (SE2->E2_IMPCHEQ == "S" .or. lChqPre) .And. Round(nValPgto,2) != Round((nValMoeda+nMulta+nJuros+nVA-nDescont+nAcresc-nDecresc-nPis-nCoFins-nCsll-nIrrf-nIss),2)
			Help(" ",1,"JACHQSTIT")
			nValPgto := nOldValPgto
			Return .F.
		Endif
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} Sel080Baixa
Seleciona Baixas a serem canceladas  

@author Andreia dos Santos
@since 03/11/1998
/*/
//-------------------------------------------------------------------
Function Sel080Baixa(cTipoDoc As Character,cPrefixo As Character,cNum As Character,cParcela As Character,;
                    cTipo As Character,nTotComp As Numeric,lBaixaAbat As Logical,cFornece As Character,;
					cLoja As Character,lBxCEC As Logical,lFltrOrdPg As Logical,lRetHelp As Logical,;
                    nTotImpost As Numeric,lAglImp As Logical,lConsCMP As Logical,lPegaPCC As Logical,;
					nTotaIRPF As Numeric,cIdentee As Character,lBxLiq As Logical,cFilialOrig As Character,lTodas As Logical)
    LOCAL __k As Numeric
    LOCAL cTipoBaixa As Character
    LOCAL nRecAtu As Numeric
    LOCAL cSequencia As Character
    LOCAL lEstornada As logical
    LOCAL aBaixa As Array
    LOCAL cNumero As Character
    LOCAL cFunName As Character
    Local lValPedim As Logical
    
    __k := 0
    cTipoBaixa := ""
    nRecAtu := 0
    cSequencia := ""
    lEstornada := .f.
    aBaixa := {}
    cNumero := ""
    cFunName := FunName()
    lValPedim := (cPaisLoc $ "MEX" .And. cFunName $ "MATA447" .And. FindFunction("LxVldBaixa"))

	/*/
	//           ..:: Paises Localizados ::..
	// A variavel lFltrOrdPg servira para definir se a
	// Ordem de Pago podera ser baixada ou nao por esta rotina.
	//	      lFltrOrdPg = Filtra Orden de Pago
	/*/
	DEFAULT lFltrOrdPg	:= .F.
	DEFAULT lRetHelp	:= .F.
	DEFAULT nTotImpost	:= 0
	DEFAULT nTotaIRPF	:= 0
	DEFAULT lAglImp		:= .F.
	DEFAULT lConsCMP	:= .F.
	DEFAULT lPegaPCC	:= .F.
	DEFAULT cIdentee	:= ""
	DEFAULT lBxLiq		:= .F.
	DEFAULT cFilialOrig	:= ""
	DEFAULT lTodas 		:= .F.

	If cPaisLoc $ "MEX|PER"
		If Type("aBorra") != "A"
			aBorra := {}
		EndIf
	EndIf

	lBxCec := IIF(lBxCec == NIL,.F.,lBxCec)

	FOR __k := 1 TO Len(cTipoDoc) Step 4

		cTipoBaixa := AllTrim(Substr(cTipoDoc,__k,3 ) )
		//³Procura pela baixas dependendo do Tipodoc passado como parametro
		dbSelectArea("SE5")
		SE5->(dbSetOrder(2))
		SE5->(dbSeek(xFilial("SE5")+cTipoBaixa+cPrefixo+cNum+cParcela+cTipo))
		While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .and. ;
				SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO==cTipoBaixa+cPrefixo+cNum+cParcela+cTipo

			IF cPaisloc $ "MEX|PER" .and. cFunName == "MATA101N" .and. lF080Auto
				IF SE5->E5_SITUACA == "C" .AND. SE5->E5_RECPAG == "P"
					SE5->(dbSkip())
					Loop
				EndIF

				If Len(aBorra) > 0
					if aBorra[nFR3][1] == ALLTRIM( SUBSTR( SE5->E5_HISTOR , 6, TAMSX3("F1_DOC")[1] ) ) .and. aBorra[nFR3][2] <> SE5->(recno())
						dbSkip()
						Loop
					endif
					if aBorra[nFR3][1] <> ALLTRIM( SUBSTR( SE5->E5_HISTOR , 6, TAMSX3("F1_DOC")[1] ) ) .and. aBorra[nFR3][2] <> SE5->(recno())
						dbSkip()
						Loop
					endif
				EndIf
			Endif
			
			If !Empty(cFilialOrig)
				If SE5->E5_FILORIG <> cFilialOrig
					dbSkip()
					Loop
				EndIf
			EndIf
					
			If  !lTodas .And. SE5->E5_MOTBX $ "FAT#DSD" .or. (SE5->E5_MOTBX $ "STP" .and. cFunName <> "FINA050" .and. !lF080Auto .And. SE2->E2_TIPO $ MVPROVIS )
				dbSkip()
				Loop
			Endif

			If SE5->E5_MOTBX $"PCC,IRF,ISS,IMR"
				IF SE5->E5_SITUACA != "C"
					If SE5->E5_MOTBX $ "PCC|IMR"
						nTotImpost += SE5->E5_VALOR
					Else
						nTotaIRPF  += SE5->E5_VALOR
					EndIf
				Endif
				If !lPegaPCC
					dbSkip()
					Loop
				Endif
			Else
				//Baixa que reteve IRRF
				IF SE5->E5_SITUACA != "C" .and. SE5->E5_PRETIRF $ " /4"
					nTotaIRPF  += SE5->E5_VRETIRF
				Endif
			Endif

			If lFltrOrdPg .And. !Empty( SE5->E5_ORDREC )
				lRetHelp := .T.
				dbSkip()
				Loop
			Endif

			If cPaisLoc == "BRA"
				If !Empty(SE5->E5_AGLIMP) .And. SE5->E5_TIPO $ MVTAXA+"/"+MVTXA
					lAglImp := .T.
					dbSkip()
					Loop
				EndIf
			Endif

			If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
				If cPaisLoc == "BRA"
					If cTipoBaixa == "BA"	// Verifica se eh BA de inclusao do PA quando a pergunta 'Mov. Bco. S/ Chq' = NAO
						If !(MovBcoPA(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_FORNECE,SE5->E5_LOJA))
							dbSkip()
							Loop
						Else
							If SE5->E5_RECPAG <> "R" .or. SE5->E5_SITUACA == "C"
								dbSkip()
								Loop
							Else	// baixas de adiantamento (NORmal,DEVolucao,DACao)
								lBaixaAbat := .t.
							EndIf
						EndIf
					ElseIf cTipoBaixa == "VL"	// baixas de adiantamento (NORmal,DEVolucao,DACao)
						lBaixaAbat := .t.
					EndIf
				Else
					//³Verifica se as baixas sao de adiantamento (NORmal,DEVolucao,DACao)
					If cTipoBaixa =="VL" .or. cTipoBaixa =="BA"
						lBaixaAbat := .t.
					EndIf
				EndIf
				IF (SE5->E5_SITUACA == "C"  .or. SE5->E5_RECPAG != "R") .And. IIf(cpaisloc$"BRA|MEX",.T.,Empty(SE5->E5_ORDREC))
					//Se evita la entrada a baixa de PA cuando se trata de baja de anticipos de entrada.
					if cFunName <> "MATA101N" .AND. SE2->E2_TIPO <> MVPAGANT
						//Permite cancelar a baixa de PA pela baixa automática quando a mesma gerou como BA e totalizador
						If !( AllTrim( Upper( SE5->E5_ARQCNAB ) ) $ "|FINA090|FINA091|" .And. !Empty( SE5->E5_DOCUMEN ) .And. cTipoBaixa == "BA" )
							SE5->(dbSkip())
							Loop
						EndIf
					endif
				EndIF
			Else
				IF (SE5->E5_SITUACA == "C" .or. SE5->E5_RECPAG != "P") .And. IIf(cpaisloc$"BRA|MEX",.T.,Empty(SE5->E5_ORDREC))
					SE5->(dbSkip())
					Loop
				EndIF
				If (SE5->E5_SITUACA == "C"  .And. lIsRussia .and. SE5->E5_ORIGEM = 'RU06D07' .and.  !Empty(SE5->E5_ORDREC))
					SE5->(dbSkip())
					Loop
				EndIf
			Endif

			IF SE5->E5_CLIFOR != cFornece .OR. SE5->E5_LOJA != cLoja
				SE5->(dbSkip())
				Loop
			EndIF

			IF !lTodas .And. SE5->E5_MOTBX == "LIQ" .and. !Empty(SE5->E5_DOCUMEN) .and. SE5->E5_ORIGEM <> 'FINA718'
				lBxLiq	:= .T.
				SE5->(dbSkip())
				Loop
			EndIF

			If cTipoBaixa == "BA" .and. ( SE5->E5_TIPO $ MVPAGANT+"/"+MV_CPNEG) .AND. !EMPTY(SE5->E5_DOCUMEN) .And. IIf(cpaisloc=="BRA",.T.,Empty(SE5->E5_ORDREC))
				//Permite cancelar a baixa de PA pela baixa automática quando a mesma gerou como BA e totalizador
				If ( !( AllTrim( Upper( SE5->E5_ARQCNAB ) ) $ "|FINA090|FINA091|" ) .and. Empty(SE5->E5_NUMERO) ) .or.; // Se o MotBx "NOR" foi config. "Mov. Bancaria = N", o E5_ARQCNAB fica em branco
				( !( Empty(SE2->E2_NUMBOR) .and. MovBcoBx("NOR",.F.) ) .and. !( AllTrim(SE5->E5_DOCUMEN) == Alltrim(SE2->E2_NUMBOR) ) )
					//³Incrementa o valor compensado quando for baixa de compensacao e
					//³o titulo for PA ou NDF.
					nTotComp += SE5->E5_VALOR
					dbskip()
					loop
				EndIf
			EndIf

			nRecAtu := SE5->(recno())
			IF (cPaisloc $ "MEX|PER" .And. ((cFunName == "MATA101N") .Or. (lChkLxProp .and. ChkLxProp("CancelacionAnticipo")))) .Or. lValPedim
				AADD(aRecBorra,{nRecAtu,"M"})
			EndIf

			cSequencia := SE5->E5_SEQ
			//³Verifica se existe uma baixa cancelada para esta baixa efetuada
			SE5->(dbSeek(cFilial+"ES"+cPrefixo+cNum+cParcela+cTipo))
			While !SE5->(Eof()) .and. SE5->E5_FILIAL==cFilial .and. ;
			SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="ES"+cPrefixo+cNum+cParcela+cTipo

				If SE5->E5_MOTBX == "FAT"  .or. ( SE5->E5_MOTBX $ "STP" .and. cFunName <> "FINA050" )
					dbSkip()
					Loop
				Endif

				IF SE5->E5_CLIFOR != cFornece .OR. SE5->E5_LOJA != cLoja
					SE5->(dbSkip())
					Loop
				EndIF

                If !Empty(cFilialOrig)
                    If SE5->E5_FILORIG <> cFilialOrig
                        dbSkip()
                        Loop
                    EndIf
                EndIf

				If SE5->E5_SEQ == cSequencia .And. !lValPedim
					If IsBxEsFK2(SE5->E5_IDORIG)
						lEstornada := .T.
						Exit				
					Else
						SE5->(dbSkip())
						Loop
					EndIf
				EndIf
				SE5->( dbSkip() )
			EndDo
			
			SE5->(dbGoTo(nRecAtu))
			If (lEstornada .Or. ALLTRIM(SE5->E5_MOTBX) == "DAC" .And. ALLTRIM(SE5->E5_TIPO) == ALLTRIM(MVPAGANT) .And. SE5->E5_SITUACA == "C")
				lEstornada := .f.
				SE5->(dbSkip())
				Loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atenção, o array aBaixaSE5 ‚ o elemento fundamental para que ³
			//³a baixa funcione a contento. Se for necess rio alter -lo,deve³
			//³ser feito com a MAXIMA ATENCAO, pois as variaveis tratadas na³
			//³funcao est„o com posi‡”es fixas dentro do array              ³
			//³Mem¢ria de Calculo do array em quest„o.                      ³
			//³                                                             ³
			//³Informação        Posicao     Tamanho  					    ³
			//³                                                             ³
			//³Prefixo            01           03  					        ³
			//³Numero             02           12           				³
			//³Parcela            03           01						    ³
			//³Tipo               04           03					        ³
			//³Cliente/Fornec     05           06					        ³
			//³Loja               06           02					        ³
			//³Data da baixa      07           08					        ³
			//³Valor              08           15					        ³
			//³Sequencia          09           02					        ³
			//³Data Dispon.       10           08					        ³
			//³Banco              11           03					        ³
			//³Agencia            12           05					        ³
			//³Conta              13           10					        ³
			//³Dt. Disponibil.    14           08				            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (cTipoBaixa =="CP" .or. (SE5->E5_MOTBX == "CEC" .And. !Empty(cIdentee))) .and. !lConsCMP
				//³Incrementa o valor compensado quando for baixa de compensacao e
				//³for o titulo principal.
				nTotComp += SE5->E5_VALOR
				If SE5->E5_MOTBX == "CEC" .And. !Empty(cIdentee)
					lBxCEC := .T.
				Endif
			Else
				If FwIsInCallStack("Fa450Can") .and. !Empty(cCompCan) .and. SE5->E5_IDENTEE <> cCompCan
					SE5->(dbSkip())
					Loop
				Else
					cNumero := SE5->E5_NUMERO+Iif(Len(SE5->E5_NUMERO)==TamSx3("E5_NUMERO")[1],Space(Len(SE5->E5_NUMERO)),"")

					If !lValPedim .or. aScan(aBaixa,SE5->E5_PREFIXO + " " + cNumero + " " + SE5->E5_PARCELA + " " + E5_TIPO + " " + ;
					  E5_CLIFOR + " " + E5_LOJA + " ") == 0
						Aadd(aBaixa,SE5->E5_PREFIXO + " " + cNumero + " " + SE5->E5_PARCELA + " " + E5_TIPO + " " + E5_CLIFOR + ;
						" " + E5_LOJA + " " + Dtoc(E5_DATA) + " " + Transf( E5_VALOR , "@E 9999,999,999.99" ) + "   " + E5_SEQ  )
					EndIf

					If cPaisLoc == "BRA"
						Aadd(aBaixaSE5,{ SE5->E5_PREFIXO, SE5->E5_NUMERO, SE5->E5_PARCELA, SE5->E5_TIPO, SE5->E5_CLIFOR, ;
						SE5->E5_LOJA, SE5->E5_DATA, SE5->E5_VALOR, SE5->E5_SEQ, SE5->E5_DTDISPO, ;
						SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DTDISPO, SE5->E5_VRETPIS, ;
						SE5->E5_VRETCOF, SE5->E5_VRETCSL, SE5->E5_PRETPIS, SE5->E5_PRETCOF, SE5->E5_PRETCSL, ;
						SE5->E5_TIPODOC, SE5->E5_VRETIRF, SE5->E5_PRETIRF, SE5->E5_VLDESCO, SE5->E5_VLJUROS, ;
						SE5->E5_VLMULTA, SE5->E5_VRETINS, SE5->E5_PRETINS })
					ElseIF lIsRussia
						Aadd(aBaixaSE5,{ SE5->E5_PREFIXO, SE5->E5_NUMERO, SE5->E5_PARCELA, SE5->E5_TIPO, SE5->E5_CLIFOR, ;
						                 SE5->E5_LOJA, SE5->E5_DATA, SE5->E5_VALOR, SE5->E5_SEQ, SE5->E5_DTDISPO, SE5->E5_BANCO, ;
						                 SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DTDISPO, SE5->E5_VRETPIS, SE5->E5_VRETCOF, ;
						                 SE5->E5_VRETCSL, SE5->E5_PRETPIS, SE5->E5_PRETCOF, SE5->E5_PRETCSL, SE5->E5_TIPODOC, ;
						                 SE5->E5_VRETIRF, SE5->E5_PRETIRF, SE5->E5_VLDESCO, SE5->E5_VLJUROS, SE5->E5_VLMULTA, ;
										 0,0,SE5->E5_ORDREC})
					Else
						Aadd(aBaixaSE5,{ SE5->E5_PREFIXO, SE5->E5_NUMERO, SE5->E5_PARCELA, SE5->E5_TIPO, SE5->E5_CLIFOR, ;
						SE5->E5_LOJA, SE5->E5_DATA, SE5->E5_VALOR, SE5->E5_SEQ, SE5->E5_DTDISPO, SE5->E5_BANCO, ;
						SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DTDISPO, SE5->E5_VRETPIS, SE5->E5_VRETCOF, ;
						SE5->E5_VRETCSL, SE5->E5_PRETPIS, SE5->E5_PRETCOF, SE5->E5_PRETCSL, SE5->E5_TIPODOC, ;
						SE5->E5_VRETIRF, SE5->E5_PRETIRF, SE5->E5_VLDESCO, SE5->E5_VLJUROS, SE5->E5_VLMULTA, ;
						0,0})
					EndIf
				EndIf
			EndIf
			SE5->(dbSkip())
		EndDo
	Next __k

Return( aBaixa )

//-------------------------------------------------------------------
/*/{Protheus.doc} fA080Cont
Valida Bco/Agen/Cta e titulos c/cheque gerado anteriormente

@author Mauricio Pequim Jr
@since 05/11/1998
/*/
//-------------------------------------------------------------------
Function fA080Cont()
	LOCAL lRet:=.T.

	//Baixa de titulo com cheque j  gerado
	If Empty(cBanco+cAgencia+cConta) .and. SE2->E2_IMPCHEQ == "S"
		lRet := .T.
	Else
		lRet := CarregaSa6(cBanco,cAgencia,cConta,,,.T.)
	Endif
	Return lRet

	Static Function Get080Mark()
	Local cMarca

	cMarca :=GetMark()
	While cMarca == "xx"
		cMarca := Getmark()
	Enddo
Return cMarca

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080SetMd
Mostra a tela de taxas de moeda 

@author Fernando Machima
@since 09/01/2001
/*/
//-------------------------------------------------------------------
Static Function Fa080SetMd()
 
	Local nReturn := 0
	
	If FindFunction ("Bx080SetMd")
		nReturn := Bx080SetMd(aTxMoedas)
	Else
		Alert(STR0243) //Por favor, pedir para o administrador do sistema atualizar o fonte FINXFUMI.PRW
	Endif	

Return(nReturn)

//-------------------------------------------------------------------
/*/{Protheus.doc} VerCpoSPB
Verifica existencia dos campos de SPB  

@author Mauricio Pequim Jr 
@since 22/09/2001
/*/
//-------------------------------------------------------------------
Function VerCpoSPB()

	Local lRet := .T.
	Local nK

	dbSelectArea("SE2")
	IF ! (cPaisLoc = "BRA" )
		lRet := .F.
	Endif
	If lRet
		dbSelectArea("SX5")
		For nK := 0 to 9
			cTabela := "X"+Alltrim(STR(nK))
			If !DbSeek(cFilial+cTabela)
				lRet := .F.
				Exit
			Endif
		Next
	Endif
	IF !File("SIGAADV.SPB")
		nHdlMot := MSFCreate("SigaAdv.SPB",0)
		IF nHdlMot == -1
			HELP(" ",1,"MOT_ERROR")
			Final("Erro F_"+str(ferror(),2)+" em SIGAADV.SPB")
		Endif
		fClose(nHdlMot)
	Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F080SPB
Abre tela para digitação dos dados de SPB

@param Utiliza SPB ou nao  
@param Clearing 
@param Tipo de Pagamento (Tabela 59)    
@param Stored a ser disparada     
@param Hora do agendamento da operacao

@author Mauricio Pequim Jr 
@since 22/09/2001
/*/
//-------------------------------------------------------------------
Function F080SPB(lSpbInUse,cClearing,cTipoPgto,cStored,cHora)
	Local nOpca := 0
	Local oClearing
	Local aClearing := {"TED","CIP"}
	Local oTpPagto

	DEFAULT cClearing := "TED"

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lSpbInUse := SpbInUse() .AND. VerCpoSPB()

	If lSpbInUse
		If TrazCodMot(cMotBx) $ "SPB"
			//	tela dos dados complementares para SPB
			While .T.
				DEFINE MSDIALOG oDlgs FROM	22,9 TO 115,400 TITLE STR0122 PIXEL //"Dados SPB"

				@ 020, 014 COMBOBOX oClearing VAR cClearing ITEMS aClearing SIZE 30,50 OF oDlgs PIXEL
				@ 020, 050 MSGET oTpPagto VAR cTipoPgto	F3 "X9" Picture "@!" Valid ExistCpo("SX5", + "X9" + cTipoPgto) SIZE 30, 11 OF oDlgs PIXEL
				@ 020, 084 MSGET cHora	Picture "99:99" Valid !Empty(cHora) .and. VldHoraSPB(cHora) SIZE 30, 11 OF oDlgs PIXEL

				@ 010, 014 SAY STR0123 SIZE 20, 7 OF oDlgs PIXEL  //"Clearing"
				@ 010, 050 SAY STR0124 SIZE 50, 7 OF oDlgs PIXEL  //"Tipo Pgto"
				@ 010, 084 SAY STR0125 SIZE 49, 7 OF oDlgs PIXEL  //"Hora Agendamento"

				@ 004, 007 TO 036, 150 OF oDlgs PIXEL

				DEFINE SBUTTON FROM 07, 155 TYPE 1 ACTION (nOpca:=1,IF(F080VldSPB(cClearing,cTipoPgto,@cStored,cHora),oDlgs:End(),nOpca:=2)) ENABLE OF oDlgs
				DEFINE SBUTTON FROM 21, 155 TYPE 2 ACTION (nOpca:=0,oDlgs:End()) ENABLE OF oDlgs

				ACTIVATE MSDIALOG oDlgs CENTERED
				If nOpca == 1
					Exit
				Endif
				nOpca := 0
			Enddo
		Endif
	Endif
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} F080BxSPB
Valida e executa emissao de dadodos para SPB

@param Utiliza SPB ou nao  
@param Clearing 
@param Tipo de Pagamento (Tabela 59)    
@param Stored a ser disparada     
@param Hora do agendamento da operacao
@param Codigo de Barras
@param Numero Evento SPB

@author Mauricio Pequim Jr 
@since 22/09/2001
/*/
//-------------------------------------------------------------------
Function F080BxSPB(cClearing,cTipoPgto,cStored,cHora,cCodbar,nEventoSpb)
	
	Local lRet := .T.

	If FindFunction ("Bx80BxSPB")
		lRet := Bx80BxSPB(cClearing,cTipoPgto,cStored,cHora,cCodbar,nEventoSpb)
	Else
		Alert(STR0244) //Por favor, pedir para o administrador do sistema atualizar o fonte FINXOLD.PRX
	Endif	

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} TrazCodSPB
Retorna o codigo da Stored a ser utilizada

@param Codigo do SPB (Clearing+Tipo Pgto) 

@author Mauricio Pequim Jr 
@since 23/09/2001
/*/
//-------------------------------------------------------------------
Function TrazCodSPB( cCodSPB )
	LOCAL nPos
	LOCAL aCodSPB := ReadCodSPB()
	nPos := Ascan(aCodSPB, {|x| Substr(x,1,5) = Upper(cCodSPB) })
	If nPos > 0
		cStored := Upper(Substr(aCodSPB[nPos],6,4))
	Else
		cStored := Space(4)
	EndIf
Return cStored

//-------------------------------------------------------------------
/*/{Protheus.doc} ReadCodSPB
Leitura do arquivo SIGAADV.SPB para carregar array aMotBx c/
o Codigo da mensagem do SPB a ser utilizado 

@author Mauricio Pequim Jr 
@since 22/09/2001
/*/
//-------------------------------------------------------------------
Function ReadCodSPB()
	Local nHdlCod := 0
	Local nBytes:=0
	Local nTamArq
	Local xBuffer
	Local aCodSpb:={}

	If !FILE("SIGAADV.SPB")
		nHdlCod := fCreate("SigaAdv.SPB")
		If nHdlCod == -1
			HELP(" ",1,"SPB_ERROR")
			Final("Erro F_"+str(ferror(),2)+" em SIGAADV.SPB")
		EndIf
		fClose(nHdlCod)
	EndIf

	nHdlCod := FOPEN("SIGAADV.SPB",64)

	If nHdlCod <0
		HELP(" ",1,"SIGAADV.SPB")
		Final("SIGAADV.SPB")
	EndIf
	nTamArq:=FSEEK(nHdlCod,0,2)	// VerIfica tamanho do arquivo
	FSEEK(nHdlCod,0,0)			// Volta para inicio do arquivo

	While nBytes<nTamArq

		xBuffer:=Space(11)
		FREAD(nHdlCod,@xBuffer,11)

		AADD(aCodSpb,Upper(SubStr(xBuffer,1,9)))
		nBytes+=11
	Enddo

	Fclose(nHdlCod)

Return aCodSpb

//-------------------------------------------------------------------
/*/{Protheus.doc} F080VldSPB
Valida os dados do SPB no momento da baixa

@param Codigo do Clearing SPB						
@param Tipo de Pagamento (Tabela 59)				
@param Mensagem do piloto SPB a ser utilizada			
@param Hora do Agendamento	

@author Mauricio Pequim Jr 
@since 22/09/2001
/*/
//-------------------------------------------------------------------
Function F080VldSPB(cClearing,cTipoPgto,cStored,cHora)
	Local lRet := .T.

	If	!VldHoraSPB(cHora) .or. Empty(cTipoPgto)
		lRet := .F.
	Endif
	If lRet
		cStored := TrazCodSPB(cClearing+cTipoPgto)
		If Empty(cStored)
			MSGSTOP("Operacao nao cadastrada na Tabela de SPB.")
			lRet := .F.
		Endif
	Endif
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} VldHoraSPB
Consiste se a hora digitada ‚ v lida.

@author Mauricio Pequim Jr 
@since 24/09/2001
/*/
//-------------------------------------------------------------------
Function VldHoraSPB(cHora)

	Local lRet		:= .F.
	Local cHoras	:= Substr(cHora,1,2)
	Local cMinutos := Substr(cHora,4,2)

	If cHoras >= "00" .And. cHoras < "24" .And. cMinutos >= "00" .And. cMinutos < "60"
		lRet := .T.
	EndIf
	If ( !lRet)
		Help(" ",1,"VLDHORA")
	EndIf

Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080ValEstrang
Validacao do valor recebido em moeda estrangeira

@author Claudio D. de Souza
@since 17/09/2003
/*/
//-------------------------------------------------------------------
Function Fa080ValEstrang(nValEstrang,nTxMoeda,nValPgto,dBaixa,oValPgto,oTxMoeda,;
							nJuros,nMulta,nDescont,nOtrga,nImpSubst,nEstOriginal,nVA)

	Local nValPgOld  := nValPgto
	Local nTxMdaOr   := 0
	Local nCentMd1   := MsDecimais(1)
	Local nTxMoedOld := nTxMoeda

	If cPaisLoc <> "BRA"
		nTxMoeda := Iif(nMoedaBco > 0, aTxMoedas[nMoedaBco][2], 1)
		nTxMdaOr := aTxMoedas[SE2->E2_MOEDA][2]
	EndIf

	If nTxMoeda > 0
		// Converte o valor em moeda estrangeira para identificar o valor total do pagto.
		If cPaisLoc <> "BRA"
			nValPgto := Round(NoRound(xMoeda(nValEstrang,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMdaOr,nTxMoeda),nCentMd1+1),nCentMd1)
		Else
			If __nTxTitBx > 0
				nValPgto := Round(NoRound(xMoeda(nValEstrang,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1, __nTxTitBx, nTxMoeda),nCentMd1+1),nCentMd1)
			Else
				nValPgto := Round(NoRound(xMoeda(nValEstrang,SE2->E2_MOEDA,nMoedaBco,dBaixa,nCentMd1+1,nTxMoeda),nCentMd1+1),nCentMd1)
			EndIf
		EndIf

		//Problemas de arredondamento
		If ABS(nValPgOld - nValPgto) <= ABS(0.01)
			nValpgto := nValPgOld
		Endif

		// Verifica a taxa utilizada
		If SE2->E2_MOEDA <> nMoedaBco
			nTxMoeda := Round(NoRound(nValPgto / nValEstrang,5),TamSX3("M2_MOEDA"+AllTrim(Str(SE2->E2_MOEDA)))[2])
		EndIf

		If SE2->E2_MOEDA > 1 .And. nTxMoedOld <> nTxMoeda .And. FunName() $ "FINA080|FINA750|FINA703" //Vld para não permitir alt da taxa acordada, a partir da ediç do Vlr estrang
			nTxMoeda := nTxMoedOld
		EndIf

		// Calcula a correcao monetaria
		nEstOriginal := nValEstrang - Round(NoRound(xMoeda(nJuros+nVA+nMulta-nDescont+nOtrga+nImpSubst,nMoedaBco,SE2->E2_MOEDA,,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)
		FA080CORR(nEstOriginal,nTxMoeda)

		// Somente atualiza os objetos caso nao seja rotina automatica
		If ValType(oTxMoeda) == "O"
			// Atualiza os objetos
			If cPaisLoc=="BRA"
				oTxMoeda:Refresh()
			EndIf
			oValPgto:Refresh()
		EndIf

	Endif
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} AltVencImp
Altera data de vencimento dos titulos de impostos quando da
baixa do titulo principal.

@author Mauricio Pequim Jr
@since 27/02/2004
/*/
//-------------------------------------------------------------------
Function AltVencImp(dDtBaixa as Date)
	Local aArea		 As Array
	Local aSE2	     As Array
	Local cUniao	 As Character
	Local cTipoFor   As Character
	Local cTipoTx    As Character
	Local aChave     As Array
	Local nY         as Numeric
	Local lAtVcImp	 As Logical

	aArea		 	:= {}
	aSE2	     	:= {}
	cUniao	 		:= ""
	cTipoFor   		:= "J"
	cTipoTx    		:= ""
	aChave     		:= {}
	nY         		:= 0
	//permite Alteração da data de vencimento dos impostos na baixa do título
	lAtVcImp	 	:= SuperGetMv("MV_ATVCIMP", .F., .F.)
	
	Default dDtBaixa := dDataBase
	
	If cPaisLoc == "BRA" .And. SE2->(E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL) > 0 .And. lAtVcImp
		aArea := GetArea()
		aSE2  := SE2->(GetArea())
		SE2->(DbSetOrder(1))
		
		cTipoFor := If(SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG == "1", "F", cTipoFor)
		cTipoTx  := If(SE2->E2_TIPO $ MVPAGANT+"|"+MV_CPNEG, MVTXA, MVTAXA)
		cUniao	 := PadR(SuperGetMv("MV_UNIAO"), TamSX3("E2_FORNECE")[1])
		
		If SE2->E2_IRRF > 0 .And. !(SA2->A2_CALCIRF == "2" .And. !SE2->E2_TIPO $ MVPAGANT)
			Aadd(aChave, {"IRRF", SE2->(E2_PREFIXO+E2_NUM+E2_PARCIR) + cTipoTx + cUniao, SE2->E2_CODRET, cTipoFor})
		EndIf
		
		If SE2->(E2_PIS+E2_COFINS+E2_CSLL) > 0
			If SE2->E2_PIS > 0
				Aadd(aChave, {"PIS", SE2->(E2_PREFIXO+E2_NUM+E2_PARCPIS) + cTipoTx + cUniao, , })
			EndIf
			
			If SE2->E2_COFINS > 0
				Aadd(aChave, {"COFINS", SE2->(E2_PREFIXO+E2_NUM+E2_PARCCOF) + cTipoTx + cUniao, , })
			EndIf
			
			If SE2->E2_CSLL > 0
				Aadd(aChave, {"CSLL", SE2->(E2_PREFIXO+E2_NUM+E2_PARCSLL) + cTipoTx + cUniao, , })
			EndIf	
		EndIf
		
		For nY := 1 To Len(aChave)
			If SE2->(MsSeek(xFilial("SE2")+aChave[nY,2])) .And. SE2->E2_SALDO > 0
				Reclock("SE2")
				SE2->E2_VENCREA := F050VImp(aChave[nY, 1], SE2->E2_EMISSAO, SE2->E2_EMIS1, dDtBaixa, aChave[nY, 3], aChave[nY, 4])
				SE2->E2_VENCTO  := SE2->E2_VENCREA
				SE2->(MsUnlock())
			EndIf
		Next nY
		
		RestArea(aSE2)
		RestArea(aArea)
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} MoedaBco
Valida Bco/Agen/Cta e titulos c/cheque gerado anteriormente

@param cBco Codigo do Banco
@param cAg Codigo da agencia
@param cCC Codigo da conta

@Return nMd Numero da moeda do banco 
	    0 - erro na busca ou nao encontrou 

@author Cristiano Denardi
@since 07/05/2004
/*/
//-------------------------------------------------------------------
Function MoedaBco( cBco, cAg, cCC )

	Local aArea	:= GetArea()
	Local nMd	:= 0	// Moeda usada pelo Banco
	Local lPar	:= .T.	// Validacao os parametros passados a funcao

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Validacao das variaveis usadas na funcao ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Do Case
		Case ( cBco   == Nil ) .Or. Empty(cBco  )
		lPar := .F.
		Case ( cAg    == Nil ) .Or. Empty(cAg   )
		lPar := .F.
		Case ( cCC    == Nil ) .Or. Empty(cCC   )
		lPar := .F.
	EndCase

	If lPar
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Busca a Moeda do Banco Informado ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SA6")
		DbSetOrder(1) // A6_FILIAL+A6_COD+A6_AGENCIA+A6_NUMCON
		DbSeek( xFilial("SA6")+cBco+cAg+cCC )
		If Found()
			If cPaisLoc <> "CHI"
				nMd := SA6->A6_MOEDA
			Else
				nMd := Max(IIf(Type("SA6->A6_MOEDAP")=="U",SA6->A6_MOEDA,SA6->A6_MOEDAP),1)
			EndIf
		Endif
	Endif

	RestArea(aArea)
Return( nMd )

//-------------------------------------------------------------------
/*/{Protheus.doc} F080Impost

@author Mauricio Pequim
@since 05/11/1998
/*/
//-------------------------------------------------------------------
Function F080Impost(nRegSe2,lCancel,nJuros,nMulta,nDescont,nValPgto,nVA)

	Local aArea	:= GetArea()
	Local aAreaSA2	:= SA2->(GetArea())
	Local nBaseImp := 0
	Local cForUniao := ""
	Local cLojUniao := ""
	Local nValImp := 0
	Local cPrefNum := If( cPaisLoc=="BRA", SE2->(E2_PREFIXO+E2_NUM), "" )
	Local cParcPis := If( cPaisLoc=="BRA", SE2->E2_PARCPIS, "" )
	Local cParcCof := If( cPaisLoc=="BRA", SE2->E2_PARCCOF, "" )
	Local cParcCsl := If( cPaisLoc=="BRA", SE2->E2_PARCSLL, "" )
	Local nX := 0
	Local cChaveImp := ""
	Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

	Default lCancel := .F.
	Default nVA		:= 0

	If ( cPaisLoc == "BRA" )
		//Se o usuario fez opcao por nao calcular impostos na baixa
		If SuperGetMv("MV_IMPBAIX",.t.,"2") == "2"
			Return .T.
		Endif

		DbSelectArea("SA2")
		DbSetOrder(1)
		MsSeek(xFilial("SA2")+GetMv("MV_UNIAO")+Space(Len(A2_COD)-Len(GetMv("MV_UNIAO")))+"00")
		cForUniao	:= SA2->A2_COD
		cLojUniao	:= SA2->A2_LOJA

		dbSelectArea("SE2")
		dbSetOrder(1)

		//Abro o SE2 com outro alias pois pode estar filtrado pela
		//Baixa por lote
		If Select("__SE2") == 0
			ChkFile("SE2",.F.,"__SE2")
		Else
			DbSelectArea("__SE2")
		EndIf
		dbSetOrder(1)
		dbGoto(nRegSE2)

		nBaseImp	:= __SE2->(E2_VALOR+E2_IRRF+E2_ISS+E2_SEST+E2_PIS+E2_COFINS+E2_CSLL)

		nBaseImp	+= Iif(!lInssBx,__SE2->E2_INSS,0)


		//Calculo o valor do imposto sobre os valores de juros e descontos
		If nDescont > 0 .and. nValPgto == 0  //Baixa por desconto
			nValPisBx := ( (nJuros + nMulta - nDescont + nVA) * __SE2->E2_PIS ) / __SE2->E2_VALOR
			nValCofBx := ( (nJuros + nMulta - nDescont + nVA) * __SE2->E2_COFINS ) / __SE2->E2_VALOR
			nValCslBx := ( (nJuros + nMulta - nDescont + nVA) * __SE2->E2_CSLL ) / __SE2->E2_VALOR
		Else
			nValPisBx := ( (nJuros + nMulta - nDescont + nVA) * __SE2->E2_PIS ) / nBaseImp
			nValCofBx := ( (nJuros + nMulta - nDescont + nVA) * __SE2->E2_COFINS ) / nBaseImp
			nValCslBx := ( (nJuros + nMulta - nDescont + nVA) * __SE2->E2_CSLL ) / nBaseImp
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Analise dos codigos das naturezas envolvidas                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 to 3
			Do Case
				Case nX == 1	//Pis
				cNatureza	:= GetMv("MV_PISNAT",.F.,"PIS")
				cValor		:= "nValPisBx"
				cChaveImp	:= IIf(ABS(nValPisBx) > 0, cPrefNum+cParcPis+"TX "+cForUniao+cLojUniao, "")
				Case nX == 2	//Cofins
				cNatureza	:= GetMv("MV_COFINS",.F.,"COF")
				cValor		:= "nValCofBx"
				cChaveImp	:= IIf(ABS(nValCofBx) > 0, cPrefNum+cParcCof+"TX "+cForUniao+cLojUniao, "")
				Case nX == 3	//Csll
				cNatureza	:= GetMv("MV_CSLL",.F.,"CSL")
				cValor		:= "nValCslBx"
				cChaveImp	:= IIf(ABS(nValCslBx) > 0, cPrefNum+cParcCsl+"TX "+cForUniao+cLojUniao, "")
			EndCase

			nValImp := &(cValor)

			If ABS(nValImp) > 0
				If MsSeek(xFilial("SE2")+cChaveImp)
					RecLock("__SE2")
					If lCancel
						If nValImp > 0 .and. E2_SALDO > 0
							E2_ACRESC -= nValImp
							E2_SDACRES -= nValImp
						Else
							E2_DECRESC -= ABS(nValImp)
							E2_SDDECRE -= ABS(nValImp)
						Endif
					Else
						If nValImp > 0 .and. E2_SALDO > 0
							E2_ACRESC += nValImp
							E2_SDACRES += nValImp
						Else
							E2_DECRESC += ABS(nValImp)
							E2_SDDECRE += ABS(nValImp)
						Endif
					Endif
					If E2_ACRESC < 0
						E2_ACRESC := 0
					ENDIF
					If E2_DECRESC < 0
						E2_DECRESC := 0
					ENDIF
					If E2_SDACRES < 0
						E2_SDACRES := 0
					ENDIF
					If E2_SDDECRE < 0
						E2_SDDECRE := 0
					ENDIF
					MsUnlock()
				Endif
			Endif
		Next

		RestArea(aAreaSA2)
		RestArea(aArea)
		SE2->(dbGoto(nRegSE2))
	Endif
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} F080TotMes
Verifica o total de notas do Fornecedor que vencem no mesmo mes.

@author Mauricio Pequim
@since 19/10/2004
/*/
//-------------------------------------------------------------------
Function F080TotMes(dReferencia,lCalcRet,lCalcPA,lSE2,lAltData,lCpoValor,nTxmoeda)

	Local aAreaSE2		:= SE2->( GetArea() )
	Local aRecnos		:= {}
	Local dDataIni		:= FirstDay( dReferencia )
	Local dDataFim		:= LastDay( dReferencia )
	Local nVlMinImp		:= GetNewPar("MV_VL10925",5000)
	Local nValorPg		:= 0
	Local nValTit		:= 0
	Local nVlrTit		:= 0
	Local lSest			:= .T.  //Verifica campo de SEST
	Local cModRetPIS 	:= GetNewPar( "MV_RT10925", "1" )
	Local lContrRet		:= .T.

	//Considero juros multa ou desconto na base do imposto.
	// 1 = Considera valores juros multa ou desconto
	// 2 = Nao considera valores juros multa ou desconto
	Local lJurMulDes 	:= (SuperGetMv("MV_IMPBAIX",.t.,"2") == "1")
	Local lAltValor		:= .F.
	Local lAltJuros		:= IIF(FwIsInCallStack('FA080TIT'),STR(nJuros,17,2)   != STR(nOldJuros  ,17,2) .Or.;
			STR(nMulta,17,2)   != STR(nOldMulta  ,17,2) .Or.;
			STR(nDescont,17,2) != STR(nOldDescont,17,2), .F.)

	Local lAltJurLt	:= IIF(FwIsInCallStack('FA080Lot'),STR(nJuros,17,2)   != STR(nOldJuros  ,17,2) .Or.;
			STR(nMulta,17,2)   != STR(nOldMulta  ,17,2) .Or.;
			STR(nDescont,17,2) != STR(nOldDescont,17,2), .F.)

	//Controla o Pis Cofins e Csll na baixa
	Local nValOutImp 	:= 0
	Local cModTot		:= GetNewPar( "MV_MT10925", "1" )
	Local lBaseSE2		:= SuperGetMv("MV_BS10925",.T.,"1") == "1"
	Local nProp			:= 1
	Local nProp2		:= 1
	Local nBaseRet		:= 0  //Base de retencao
	Local nSE2Reg		:= SE2->(RECNO())

	//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
	//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
	//3-Nao Controla
	Local cNccRet		:= SuperGetMv("MV_NCCRET",.F.,"1")
	Local cChaveTit		:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
	Local nX 			:= 0
	Local lTodasFil		:= ExistBlock("MT103FRT")
	Local lConFil		:= SuperGetMv("MV_CONSFIL",.F.,.F.)
	Local aFil10925		:= {}
	Local cFilAtu		:= IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL )
	Local aArea			:= GetArea()

	Local aFor10925		:= {}
	Local lVerForLj		:= ExistBlock("F080LOJA")
	Local cQuery		:= ""
	Local nLoop			:= 0
	Local aValorBx		:= {}
	Local lAltBxVal		:= .F.
	Local lCalcIssBx 	:=	.F.
	Local lAplVlMin		:= .T.
	Local aDadosImp		:= Array(5)
	Local aTitBsImp		:= {}
	Local lGravou		:= .F.
	Local lLojaAtu		:= ( GetNewPar( "MV_LJ10925", "1" ) == "1" )
	Local nTamTit		:= TamSX3("E5_PREFIXO")[1]+TamSX3("E5_NUMERO")[1]+TamSX3("E5_PARCELA")[1]+TamSX3("E5_TIPO")[1]
	Local nTamTit2		:= TamSX3("E5_PREFIXO")[1]+TamSX3("E5_NUMERO")[1]+TamSX3("E5_PARCELA")[1]
	Local lAchouPa		:= .F.
	Local lValPgto		:= SuperGetMv("MV_BP10925",.T.,"1") == "2" //1- Valor bruto da baixa parcial / 2- Valor da baixa parcial menos os impostos
	Local nValProp		:= 0
	Local nTotAdto		:= 0
	Local lBaixaAbat 	:= .F.
	Local lBxCec		:= .F.
	Local lNotBax		:= .F.
	Local nTotImpost 	:= 0
	Local lAglImp		:= .F.
	Local aBaixa		:= {}
	Local nY			:= 0
	Local lDigitado		:= .F.
	Local aTitulos		:= {}
	Local lImpInFat		:= .F.
	Local nImpRetEmi 	:= 0
	Local lCpoVlMin		:= .T.
	Local lSE2DtBor		:= cPaisLoc == "BRA"
	Local cTitAtual		:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
	Local lPaBruto		:= GetNewPar("MV_PABRUTO","2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor
	Local nValAbat		:= 0
	Local nImpPaBrt 	:= 0 //Imposto do PA Bruto
	Local nKco			:= 0
	Local aRecSE2 		:= {}
	Local nRecSE2 		:= 0
	Local nT			:= 0
	Local lVerSfq 		:= .F.
	Local lVerifPCC 	:= cPaisLoc == "BRA"
	Local nTamForn 		:= 0
	Local lGrvIRE2 		:= .F.
	Local nINSSAnts 	:= 0
	Local nIRAnts   	:= 0
	Local lTBxOTits 	:= .F.
	Local nBaseOrig 	:= 0
	Local nBaixaParc 	:= 0
	Local lIRPFBaixa 	:= IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.) .And. !SE2->E2_TIPO $ MVPAGANT
	Local lPrImPA		:= !lPaBruto .And. SuperGetMv("MV_PAPRIME",.T.,"2") == "1"
	Local cFormClcPCC	:= GetMV("MV_RCPCCBX",.T.,"1")
	Local nInss 		:= 0
	Local aStruct   	:= {}
	Local aCampos   	:= {}
	Local cAliasQry 	:= ""
	Local cSepNeg   	:= If("|"$MV_CPNEG,"|",",")
	Local cSepPag  		:= If("|"$MVPAGANT,"|",",")
	Local cSepProv  	:= If("|"$MVPROVIS,"|",",")
	Local cSepTxa   	:= If("|"$MVTXA,"|",",")
	Local cSepTx	 	:= If("|"$MVTAXA,"|",",")
	Local cAliasSE2 	:= ""

	Local nTotCsl   	:= 0 // Totais do PCC de todos os titulos do mesmo mes.
	Local nTotPis   	:= 0
	Local nTotCof   	:= 0
	Local aDocumen		:= {}
	Local nIssPa		:= nPccPa	:=	nIrPa	:=	nVrPa	:=	0
	Local nJ			:= 0
	Local cChaveSe2		:= ""
	Local cDocumen		:= ""
	Local aAreaSe5		:= GetArea()
	Local nPccBx		:= 0
	Local nSE5Reg		:= 0
	Local lPropPA 		:= SuperGetMv("MV_COMPCP",,.F.) //Verifica se vai proporcionalizar quando PA>NF e PA liquido.
	Local aNf			:= {}

	//Chamado SDFPWW
	Local cAglutPCC  	:= SuperGetMV("MV_PCCAGFR",,"1")
	Local cAglutFil  	:= SuperGetMV("MV_PCCAGFL",,"1")
	Local aAreaSM0   	:= {}
	Local aAreaSA2   	:= {}
	Local cCGCSM0    	:= ""
	Local cCGCFor    	:= ""
	Local cForTipo   	:= ""
	Local cEmpAtu    	:= ""
	Local lTitBor	 	:= .F. //No array aDadosRet tenho dados de titulos que possuam bordero de pagamento (FINA241).
	Local lNfComp	 	:= .F. //Existe titulo a pagar que possuem compensacao.
	Local nIssComp	 	:= 0   //Valor do ISS da NF referente a compensacao.
	Local nPropIss	 	:= 0  //Proporcionalizar o ISS caso seja na emissao e o titulo possua compensacao.
	Local cFunName	 	:= Alltrim(funname())
	Local lAltdesc 	 	:= iIF(cFunName=="FINA080" .or. FwIsInCallStack("FINA080"),nOldDescont != nDescont,.F.)
	Local lAltMulta	 	:= iIF(cFunName=="FINA080" .or. FwIsInCallStack("FINA080"),nOldMulta != nMulta,.F.)
	Local lFIN080PCC 	:= Existblock("FIN080PCC")
	//Criado o array aDadosBor para armazenar o valores de PCC que foram calculados na baixa parcial de um titulo em bordero
	//para que possa subtrair este valor de PCC calculado do valor total a ser retido do titulo, pois estava somando o valor a ser retido mais o valor
	//calculado do PCC na baixa parcial
	//[1] - Valor PIS parcial [2] - Valor COFINS parcial  [3] - Valor CSLL parcial
	Local aDadosBor 	:= {0,0,0}
	Local lTemDadosBor 	:= .F.
	Local lSomouIss 	:= .F.
	Local cFilBusca 	:= ""
	Local lInssBx 		:= SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
	Local nMinINS1 		:= SuperGetMv("MV_MININSS",.F.,0)
	Local nLimInss 		:= GetMv("MV_LIMINSS",.F.,0)
	Local nMinINS2 		:= SuperGetMv("MV_VLRETIN",.F.,0)
	//Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
	Local lInsPub 		:= SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And. nLimInss == 0 .And. nMinINS2 == 0 
	Local lAltPgto		:= .F.
	Local dDataAtu 		:= dReferencia
	Local dBaixaIni 	:= dReferencia
	Local dBaixaFim 	:= dReferencia
	Local nK 			:= 0
	Local cFiliais  	:= ""
	Local cVencPub		:= SuperGetMV("MV_VENPUB", .F., "M")
	Local dDebtIni		:= dReferencia
	Local dDebtFim  	:= dReferencia
	Local nVlMPub		:= SuperGetMv("MV_VLMPUB",.T.,10)
	Local oQuerySE5     As Object
	Local nParam        As Numeric

	Default nTxmoeda	:= SE2->E2_TXMOEDA

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT __lFINA090  := IsInCallStack("FINA090")
    DEFAULT lFina450    := FwIsInCallStack("FINA450")
    DEFAULT lMotBxMBco  := (SuperGetMv("MV_MB10925",.t.,"2") == "1")
    DEFAULT lPCCBaixa   := (SuperGetMv("MV_BX10925",.T.,"2") == "1")

    lAltValor := STR(nValPgto,17,2) != STR(nOldValPgto,17,2) .or. (lFina450 .and. FwIsInCallStack('MSVLDGAUTO'))

	aFill(aDadosImp,0)

	If Type("lAplMinP") != "L"
		lAplMinP := .F.
		If SA2->A2_MINPUB == "2"
			lAplMinP := .T.
		EndIF
	EndIF

	If Type("lF080Auto") == "U"
		Private lF080Auto as Logical
		lF080Auto := .F.
	EndIf
	
	lF080Auto := If(__lFINA090, .F., lF080Auto)

	If Type("lEmpPub") == "U"
		lEmpPub := IsEmpPub() .And. lIRPFBaixa .And. lAplMinP
	EndIf

	If lPCCBaixa .and. dReferencia >= dLastPcc .and. !lEmpPub
		nVlMinImp	:= 0
	EndIf

	PRIVATE aBaixaSE5 := {}

	Default lCalcRet := .F.
	Default lCalcPA  := .F.
	Default lSE2  := .T.   //Variavel para controle do uso do alias alternativo __SE2 para alguns posicionamentos.
	Default lAltData := .F.
	Default lCpoValor := .F.

	//se estiver sendo chamado via rotina automática a partir da compensação entre carteiras,
	//nao deve processar ISS E IR
	If lFina450 .and. (Type("lF080Auto")<>"U" .and. lF080Auto)
		lCalcIssBx := .F.
	Else
		lCalcIssBx := IsIssBx("P")
	EndIf

	nInss 	 := SE2->E2_INSS
	nIss     := If(Type("nIss") != "N",0,nIss)
	nValComp := If(Type("nValComp") != "N",0,nValComp)
	nValLiq  := If(Type("nValLiq") != "N",0,nValLiq)
	dBaixa	 := If(Type("dBaixa") != "D",dDataBase,dBaixa)
	nTotAbat := If(Type("nTotAbat") != "N",SumAbatPag( SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_FORNECE, SE2->E2_MOEDA, "S", dBaixa, SE2->E2_LOJA ),nTotAbat)

	nTamForn := If(lVerifPCC,TAMSX3("E2_FORNPAI")[1],0)
	lBxLote := IIf(Type("lBxLote")=="U",.F.,lBxLote)

	oQuerySE5 := NIL
	nParam	  := 1

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ POR MAIS ESTRANHO QUE PARE€A, ESTA FUNCAO DEVE SER CHAMADA AQUI! ³
	//³                                                                  ³
	//³ A função SomaAbat reabre o SE2 com outro nome pela ChkFile para  ³
	//³ efeito de performance. Se o alias auxiliar para a SumAbat() n„o  ³
	//³ estiver aberto antes da IndRegua, ocorre Erro de & na ChkFile,   ³
	//³ pois o Filtro do SE2 uptrapassa 255 Caracteres.                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SomaAbat("","","","P")

	//Verificar ou nao o limite de 5000 para Pis cofins Csll
	// 1 = Verifica o valor minimo de retencao
	// 2 = Nao verifica o valor minimo de retencao
	If SE2->E2_APLVLMN == "2"
		lAplVlMin := .F.
	Endif

	If lEmpPub .And. lIRPFBaixa
		If SuperGetMV("MV_IN4815", .F., "S") == "S"
			dDataAtu := dReferencia
			For nK:=1 To 7
				If Dow(dDataAtu ) == 7
					Exit
				EndIf
				dDataAtu++
			Next nK
			dBaixaIni := dDataAtu-7
			dBaixaFim := dDataAtu
		EndIf
		If lIRPFBaixa .And. lPCCBaixa
			If cVencPub == "D"
				dBaixaIni := dBaixaFim := dDebtIni := dDebtFim :=  dBaixa
			ElseIf cVencPub == "M"
				dBaixaIni := dDebtIni := FirstDay(dBaixa)
				dBaixaFim := dDebtFim := LastDay(dBaixa)
			EndIF
		EndIF
	EndIF

	nDiferImp := 0

	//Garanto o tamanho dos arrays de retencao
	If Len(aDadosRef) < 7
		aDadosRef := Array(7)
		AFill( aDadosRef, 0 )
	Endif
	If Len(aDadosRet) < 7
		aDadosRet := Array(7)
		AFill( aDadosRet, 0 )
	Endif

	If Type("aRecnosSE2") == "U"
		aRecnosSE2 := {}
	Endif

	aValorBx := Array(3)
	AFill( aValorBx, 0 )

	If cAglutPCC == "2" .Or. cAglutPCC == "3"
		If lVerForLj
			Help( ,, 'HELP',, STR0181 , 1, 0) //'Parâmetro MV_PCCAGFR deve ser "1=Não Aglutina" para utilizar o ponto de entrada "F080LOJA"'
			Return .T.
		EndIf
	EndIf
	If (cAglutFil == "2" .Or. cAglutFil == "3") .And. lTodasFil
		Help( ,, 'HELP',, STR0182 , 1, 0) //'Parâmetro MV_PCCAGFL deve ser "1=Não Aglutina" para utilizar o ponto de entrada "MT103FRT"'
		Return .T.
	EndIf

	If !lPccBaixa
		Return .T.
	Endif

	//Natureza nao retem imposto
	If cModTot == "2" //Considera apenas titulos com retencao de PCC
		SED->(dbSetOrder(1))
		If lCalcPA
			cNatur := M->E2_NATUREZ
		Else
			cNatur := SE2->E2_NATUREZ
		Endif
		SED->(MsSeek(xFilial("SED")+cNatur))
		If !(SED->ED_CALCPIS == "S" .and. ( IIF(cPaisLoc == "BRA" , SA2->A2_RECPIS  == "2" , .F. ) ) ) .and.;
		!(SED->ED_CALCCSL == "S" .and. ( IIF(cPaisLoc == "BRA" ,SA2->A2_RECCSLL == "2" , .F. ) ) ) .and.;
		!(SED->ED_CALCCOF == "S" .and. ( IIF(cPaisLoc == "BRA" ,SA2->A2_RECCOFI == "2" , .F. ) ) )
			Return .T.
		Endif
	Endif

	//Titulo ja teve retencao na emissao
	If !lCalcPA .And. (!(SE2->E2_PRETPIS $ "1#3#7") .OR. !(SE2->E2_PRETCOF $ "1#3#7") .OR. !(SE2->E2_PRETCSL $ "1#3#7"))
		Return .T.
	Endif

	// Verificar se eh PA para não gerar recalculo de impostos.
	If !lCalcPA .And. (SE2->E2_TIPO $ MVPAGANT)
		Return .T.
	Endif

	// Faz verificacao das baixas do titulo.
	// Consiste se o motivo gera ou nao movimento bancario.
	If lMotBxMBco .And. !lCalcPA .And. !Fa080MovBc()
		nValPgto += nPis+nCofins+nCsll+nIrrf+nIss
		nOldValPgto := nValPgto
		nPis := 0
		nCofins := 0
		nCsll := 0
		nIrrf := 0
		nVlRetPis := 0
		nVlRetCof := 0
		nVlRetCsl := 0
		Return .T.
	Endif

	//Se o valor liquidado for diferente do valor da baixa total, foi um valor digitado
	If nValLiq > 0 .and. (nValLiq+nTotAbat) != SE2->E2_SALDO .and. !lMotBxMBco
		lDigitado := .T.
		If !lAltValor  .AND. ((nValLiq+nTotAbat) == nValOrig)
			Return .T.
		Endif
	Endif

	//Se a validação nao partiu do campo de valor
	If !lDigitado .and. !lAltValor .and. !lAltJuros .and. ( Type('lF080Auto') =='U' .or. !lF080Auto)  .And. !lAltJurLt
		nValPgto += nPis+nCofins+nCsll
		If (lIRPFBaixa .and. !lCpoValor)
			nValPgto += nIrrf
		EndIf
		If lCalcIssBx
			nValPgto += nIss
		EndIf
		nOldValPgto := nValPgto
	ElseIf (lIRPFBaixa .and. !lCpoValor .and. !lAltJuros .And. !lAltJurLt)
		nValPgto += nIrrf
		If lCalcIssBx
			nValPgto += nIss
		EndIf
	Endif

	lAltPgto	:=	.F.
	//Se baixa parcial que contem decrescimo ou acrescimo devo subtrair ou acrescentar o valor.
	If FwIsInCallStack("FINA080")
		If lAltValor .And. nValPgto <> nValOrig // baixa parcial
			If SE2->E2_VALOR == SE2->E2_SALDO .And. (nDecresc + nAcresc) > 0 //primeira baixa
				nValPgto := nValPgto - nDecresc + nAcresc
				lAltPgto	:=	.T.
			Endif
		Endif
	Endif

	nTotCsl   := 0 // Totais do PCC de todos os titulos do mesmo mes.
	nTotPis   := 0
	nTotCof   := 0

	If lCalcRet .and. lAplVlMin

		aFil10925 := {}
		aAreaSA2  := SA2->(GetArea())
		SA2->(DbSetOrder(1))
		If !lCalcPA
			SA2->(MsSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))
		Else
			SA2->(MsSeek(xFilial("SA2")+M->(E2_FORNECE+E2_LOJA)))
		EndIf
		aAreaSM0 := SM0->(GetArea())
		If !Empty(cCGCFor := SA2->A2_CGC)
			cForTipo := SA2->A2_TIPO
			SA2->(DbSetOrder(3))
			cEmpAtu  := SM0->M0_CODIGO
			cCGCSM0  := SM0->M0_CGC
			SM0->(DbSetOrder(1))
			SM0->(MsSeek(cEmpAnt))
		Else
			aFil10925 := { cFilant }
		EndIf

		//Se parametro "MV_PCCAGFR" existe com conteudo diferente de 1
		If cAglutFil == "2" .Or. cAglutFil == "3"
			Do While !SM0->(Eof()) .And. SM0->M0_CODIGO == cEmpAtu
				//Verifica se a filial tem o mesmo CGC/Raiz de CGC
				If (cAglutFil == "2" .And. cCGCSM0 == SM0->M0_CGC) .Or. (cAglutFil == "3" .And. Left(cCGCSM0,8) == Left(SM0->M0_CGC,8))
					//Verifica se na filial existe cliente de mesmo CGC/Raiz de CGC
					cFilBusca := IF(lFWCodFil, FWGETCODFILIAL,SM0->M0_CODFIL)
					If (cAglutPCC != "2" .And. cAglutPCC != "3") .Or. (SA2->(MsSeek(xFilial("SA2",cFilBusca)+Left(cCGCFor,Iif(cForTipo != "F" .And. cAglutPCC == "3",8,14)))) .And. cForTipo == SA2->A2_TIPO)
						AAdd(aFil10925,cFilBusca)
					EndIf
				EndIf
				SM0->(DbSkip())
			EndDo

			//Verifico todas as filiais apenas quando SA2 compartilhado
		ElseIf lTodasFil
			aFil10925 := ExecBlock( "MT103FRT", .F., .F. )
		Else
			If !Empty (FwFilial("SE2")) .And. lConFil
				aFil10925 := FAFIL10925()
			Else
				aFil10925 := { cFilAnt }
			Endif
		Endif

		For nKco := 1 to Len(aFil10925)
			cFiliais += "'"+xFilial("SE5", aFil10925[nKco])+"'"
			If nKco < Len(aFil10925)
				cFiliais += ","
			EndIf
		Next nKco

		SM0->(RestArea(aAreaSM0))
		SA2->(RestArea(aAreaSA2))

		//Retorna array com os codigos de cliente/loja para verificacao da retencao
		//(Raiz do CGC)
		If lVerForLj .And. cAglutPCC != "2" .And. cAglutPCC != "3"
			aFor10925 := ExecBlock("F080LOJA",.F.,.F.)
		Endif

		AFill( aDadosRef, 0 )
		AFill( aDadosRet, 0 )
		aRecnosSE2 := {}
		nValComp := 0
		lTitBor	:=	.F.

		dbSelectArea("SE5")
		AFill( aDadosBor, 0 )
		lSomouIss	:= .F.
		For nKco := 1 to Len(aFil10925)

			If !Empty(cCGCFor) .And. ( cAglutPCC == "2" .Or. cAglutPCC == "3" )
				aAreaSA2 := SA2->(GetArea())
				SA2->(DbSetOrder(3))
				SA2->(MsSeek(xFilial("SA2")+Left(cCGCFor,8)))
				aFor10925 := {}
				Do While !SA2->(Eof()) .And. xFilial("SA2")+Left(cCGCFor,8) == SA2->A2_FILIAL+Left(SA2->A2_CGC,8)
					//Mesmo tipo de Fornecedor e Novo no vetor
					If cForTipo == SA2->A2_TIPO .And. AScan(aFor10925,{|x| x[1]+x[2] == SA2->(A2_COD+A2_LOJA) }) == 0
						//Nao pode ser pessoa fisica e aglutina por Raiz de CNPJ
						If cForTipo != "F" .And. cAglutPCC == "3" .And. Left(SA2->A2_CGC,8) == Left(cCGCFor,8)
							SA2->(AAdd(aFor10925,{A2_COD,A2_LOJA}))
							//Pessoa Fisica ou aglutina por CPF/CNPJ identico
						ElseIf ( cForTipo == "F" .Or. cAglutPCC == "2" ) .And. SA2->A2_CGC == cCGCFor
							SA2->(AAdd(aFor10925,{A2_COD,A2_LOJA}))
						EndIf
					EndIf
					SA2->(DbSkip())
				EndDo
				SA2->(RestArea(aAreaSA2))
			EndIf
		Next nKco

		aCampos := { "E5_VALOR","E5_VRETPIS","E5_VRETCOF","E5_VRETCSL","E5_VLJUROS","E5_VLMULTA","E5_VLDESCO"}

		If lCalcIssBx
			aadd(aCampos,"E5_VRETISS")
		Endif

		If lIRPFBaixa
			aadd(aCampos,"E5_PRETIRF")
		Endif

		If lInssBx // Inss Baixa
			aadd(aCampos,"E5_PRETINS")
			aadd(aCampos,"E5_VRETINS")
		Endif
		aStruct := SE5->( dbStruct() )

		SE5->( dbCommit() )

		cQuery := "SELECT E5_PREFIXO,E5_NUMERO,E5_PARCELA,E5_TIPO,E5_CLIFOR,E5_LOJA,"
		cQuery += "E5_SEQ,E5_VALOR,E5_VRETPIS,E5_VRETCOF,E5_VRETCSL,E5_DATA,E5_VLJUROS,"
		cQuery += "E5_VLMULTA,E5_VLDESCO,E5_PRETPIS,E5_PRETCOF,E5_PRETCSL,E5_MOTBX,"
		cQuery += "E5_DOCUMEN,E5_FORNADT,E5_LOJAADT,E5_RECPAG,E5_FILORIG, "

		If lCalcIssBx
			cQuery += "E5_VRETISS,"
		Endif

		cQuery += "E5_PRETIRF, E5_VRETIRF,"

		cQuery += "SE5.R_E_C_N_O_ RECNOSE5,"

		cQuery += "COALESCE(FK7_PREFIX,'') FK7_PREFIX,"
		cQuery += "COALESCE(FK7_NUM,'') FK7_NUM,"
		cQuery += "COALESCE(FK7_PARCEL,'') FK7_PARCEL,"
		cQuery += "COALESCE(FK7_TIPO,'') FK7_TIPO,"
		cQuery += "COALESCE(FK7_CLIFOR,'') FK7_CLIFOR,"
		cQuery += "COALESCE(FK7_LOJA,'') FK7_LOJA "

		cQuery += " FROM "

		cQuery += RetSqlName( "SE5" ) + " SE5 "

		cQuery += " LEFT JOIN " + RetSqlName("FK2") + " FK2 "
		cQuery += " ON FK2.FK2_IDFK2 = SE5.E5_IDORIG "
		cQuery += " AND FK2.D_E_L_E_T_ = ? "

		cQuery += " LEFT JOIN " + RetSqlName("FK7") + " FK7 "
		cQuery += " ON FK7.FK7_IDDOC = FK2.FK2_IDCOMP "
		cQuery += " AND FK7.D_E_L_E_T_ = ? "

		cQuery += "WHERE "

		cQuery += "E5_FILIAL IN (?) AND "

		If Len(aFor10925) > 0  //Verificar determinados fornecedores (raiz do CNPJ)
			cQuery += "( "
			For nLoop := 1 to Len(aFor10925)
				cQuery += "(E5_CLIFOR = ? AND "
				cQuery += "E5_LOJA= ? ) OR "
			Next
			//Retiro o ultimo OR
			cQuery := Left( cQuery, Len( cQuery ) - 4 )
			cQuery += ") AND "
		Else  //Apenas o Fornecedor Atual
			If !lCalcPA
				cQuery += "E5_CLIFOR= ? AND "
				If lLojaAtu  //Considero apenas a loja atual
					cQuery += "E5_LOJA= ? AND "
				EndIf
			Else
				cQuery += "E5_CLIFOR= ? AND "
				If lLojaAtu  //Considero apenas a loja atual
					cQuery += "E5_LOJA= ? AND "
				EndIf
			Endif
		Endif
		If lEmpPub .And. lIRPFBaixa
			cQuery += "E5_DATA>= ? AND "
			cQuery += "E5_DATA<= ? AND "
		Else
			cQuery += "E5_DATA>= ? AND "
			cQuery += "E5_DATA<= ? AND "
		EndIf
		cQuery += "E5_TIPO NOT IN (?) AND "
		cQuery += "E5_TIPO NOT IN (?) AND "
		cQuery += "E5_TIPO NOT IN (?) AND "
		cQuery += "E5_RECPAG = ? AND "
		cQuery += "(E5_MOTBX NOT IN (?) OR (E5_MOTBX NOT IN (?) AND E5_MOTBX= ? AND (E5_PRETPIS= ? OR E5_PRETCOF=?  OR E5_PRETCSL= ? ))) AND "
		cQuery += "E5_SITUACA <> ? AND "

		//Apenas titulos que tem retencao de PIS,Cofins e CSLL
		If cModTot == "2"
			cQuery += " ((E5_VRETPIS > ? OR E5_VRETCOF > ? OR E5_VRETCSL > ?) OR (E5_MOTBX = ? )) AND "
		Endif

		cQuery += "SE5.D_E_L_E_T_ = ? "
		cQuery += "AND NOT EXISTS ( "
		cQuery += "SELECT A.E5_NUMERO "
		cQuery += "FROM "+RetSqlName("SE5")+" A "
		cQuery += "WHERE A.E5_FILIAL IN (?) AND "
		cQuery +=		"A.E5_PREFIXO=SE5.E5_PREFIXO AND "
		cQuery +=		"A.E5_NUMERO=SE5.E5_NUMERO AND "
		cQuery +=		"A.E5_PARCELA=SE5.E5_PARCELA AND "
		cQuery +=		"A.E5_TIPO=SE5.E5_TIPO AND "
		cQuery +=		"A.E5_CLIFOR=SE5.E5_CLIFOR AND "
		cQuery +=		"A.E5_LOJA=SE5.E5_LOJA AND "
		cQuery +=		"A.E5_SEQ=SE5.E5_SEQ AND "
		cQuery +=		"A.E5_TIPODOC= ? AND "
		cQuery +=		"A.E5_RECPAG<> ? AND "
		cQuery +=		"A.D_E_L_E_T_ = ?)"

		If !lEmpPub
			cQuery +=	" AND ( CASE WHEN E5_MOTBX = ? AND E5_TIPO = ? THEN  "
			cQuery +=	 				"(SELECT COUNT(*) AS REG "
			cQuery +=	 					"FROM "+RetSqlName("SE2")+" MES "
			cQuery +=	 					"WHERE MES.E2_FILIAL = SE5.E5_FILIAL AND MES.E2_PREFIXO = E5_PREFIXO "
			cQuery +=	 						"AND MES.E2_NUM=SE5.E5_NUMERO AND MES.E2_PARCELA=SE5.E5_PARCELA "
			cQuery +=	 						"AND MES.E2_TIPO=SE5.E5_TIPO AND MES.E2_FORNECE=SE5.E5_CLIFOR "
			cQuery +=	 						"AND MES.E2_LOJA=SE5.E5_LOJA AND MES.D_E_L_E_T_ = ? "
			cQuery +=	 						"AND MES.E2_TIPO = ? "

			cQuery +=	 						"AND SUBSTRING(E5_DATA, 7, 2) = SUBSTRING(MES.E2_EMISSAO, 7, 2) "
			cQuery +=	 						"AND SUBSTRING(E5_DATA, 5, 2) = SUBSTRING(MES.E2_EMISSAO, 5, 2) "
			cQuery +=	 						"AND SUBSTRING(E5_DATA, 1, 4) = SUBSTRING(MES.E2_EMISSAO, 1, 4) "

			cQuery +=								") "
			cQuery +=	 				"WHEN E5_MOTBX = ? AND E5_TIPO <> ? THEN "
			cQuery +=	 				 "(SELECT COUNT(*) AS REG "
			cQuery +=	 					"FROM "+RetSqlName("SE2")+" MES "
			cQuery +=	 					"WHERE MES.E2_FILIAL    = FK7.FK7_FILTIT "
			cQuery +=							"AND MES.E2_PREFIXO = FK7.FK7_PREFIX "
			cQuery +=							"AND MES.E2_NUM     = FK7.FK7_NUM " 
			cQuery +=							"AND MES.E2_PARCELA = FK7.FK7_PARCEL "
			cQuery +=							"AND MES.E2_TIPO    = FK7.FK7_TIPO "
			cQuery +=							"AND MES.E2_FORNECE = FK7.FK7_CLIFOR "
			cQuery +=							"AND MES.E2_LOJA    = FK7.FK7_LOJA "
			cQuery +=	 						"AND MES.D_E_L_E_T_ = ? "
			cQuery +=	 						"AND MES.E2_TIPO = ? "

			cQuery +=	 						"AND SUBSTRING(E5_DATA, 7, 2) = SUBSTRING(MES.E2_EMISSAO, 7, 2) "
			cQuery +=	 						"AND SUBSTRING(E5_DATA, 5, 2) = SUBSTRING(MES.E2_EMISSAO, 5, 2) "
			cQuery +=	 						"AND SUBSTRING(E5_DATA, 1, 4) = SUBSTRING(MES.E2_EMISSAO, 1, 4) "

			cQuery +=								") "

			cQuery +=				"WHEN E5_MOTBX <> ? THEN 1 "
			cQuery +=	 	"END )  > 0 "
		EndIf
		If lFIN080PCC
			cQuery += ExecBlock("FIN080PCC", .F. , .F. , cQuery)
		Endif

		cQuery += " ORDER BY RECNOSE5"

		cQuery := ChangeQuery( cQuery )

		oQuerySE5 := FwExecStatement():New(cQuery)

		oQuerySE5:SetString(nParam++, Space(1))
		oQuerySE5:SetString(nParam++, Space(1))
		oQuerySE5:SetIn(nParam++, StrTokArr2(StrTran(cFiliais,"'",""),","))

		If Len(aFor10925) > 0
			For nLoop := 1 to Len(aFor10925)
				oQuerySE5:SetString(nParam++, aFor10925[nLoop,1])
				oQuerySE5:SetString(nParam++, aFor10925[nLoop,2])
			Next
		Else
			If !lCalcPA
				oQuerySE5:SetString(nParam++, SE2->E2_FORNECE)
				If lLojaAtu
					oQuerySE5:SetString(nParam++, SE2->E2_LOJA)
				EndIf
			Else
				oQuerySE5:SetString(nParam++, M->E2_FORNECE)
				If lLojaAtu
					oQuerySE5:SetString(nParam++, M->E2_LOJA)
				EndIf
			EndIf
		Endif

		If lEmpPub .And. lIRPFBaixa
			oQuerySE5:SetDate(nParam++, dBaixaIni)
			oQuerySE5:SetDate(nParam++, dBaixaFim)
		Else
			oQuerySE5:SetDate(nParam++, dDataIni)
			oQuerySE5:SetDate(nParam++, dDataFim)
		EndIf

		oQuerySE5:SetIn(nParam++, StrTokArr2(MVABATIM,"|"))
		oQuerySE5:SetIn(nParam++, StrTokArr2(MV_CPNEG,cSepNeg))
		oQuerySE5:SetIn(nParam++, StrTokArr2(MVPROVIS,cSepProv))
		oQuerySE5:SetString(nParam++, 'P')

		oQuerySE5:SetIn(nParam++, StrTokArr2("FAT,IRF,PCC,LIQ,STP,DSD",","))
		oQuerySE5:SetIn(nParam++, StrTokArr2("FAT,IRF,LIQ,STP",","))
		oQuerySE5:SetString(nParam++, 'PCC')
		oQuerySE5:SetString(nParam++, '4')
		oQuerySE5:SetString(nParam++, '4')
		oQuerySE5:SetString(nParam++, '4')		
		oQuerySE5:SetString(nParam++, 'C')

		If cModTot == "2"
			oQuerySE5:SetNumeric(nParam++, 0)
			oQuerySE5:SetNumeric(nParam++, 0)
			oQuerySE5:SetNumeric(nParam++, 0)
			oQuerySE5:SetString(nParam++, 'CMP')
		Endif

		oQuerySE5:SetString(nParam++, Space(1))
		oQuerySE5:SetIn(nParam++, StrTokArr2(StrTran(cFiliais,"'",""),","))		

		oQuerySE5:SetString(nParam++, 'ES')
		oQuerySE5:SetString(nParam++, 'P')
		oQuerySE5:SetString(nParam++, Space(1))

		If !lEmpPub
			oQuerySE5:SetString(nParam++, 'CMP')
			oQuerySE5:SetString(nParam++, MVPAGANT)
			oQuerySE5:SetString(nParam++, Space(1))
			oQuerySE5:SetString(nParam++, MVPAGANT)
			oQuerySE5:SetString(nParam++, 'CMP')
			oQuerySE5:SetString(nParam++, MVPAGANT)
			oQuerySE5:SetString(nParam++, Space(1))				
			oQuerySE5:SetString(nParam++, MVPAGANT)
			oQuerySE5:SetString(nParam++, 'CMP')
		EndIf

		cAliasQRY := oQuerySE5:OpenAlias()

		While !( cAliasQRY )->( Eof())

			cFilAnt := ( cAliasQRY )->E5_FILORIG
			nImpRetEmi := 0
			SE5->(DbGoto(  ( cAliasQRY )->RECNOSE5  ))

			// Consiste se o motivo gera ou nao movimento bancario.
			If lMotBxMBco
				If !Fa080MovBc((cAliasQRY)->E5_MOTBX)
					(cAliasQRY)->(DbSkip())
					Loop
				Endif
			Endif

			//Verificar ou nao o limite de 5000 para Pis cofins Csll
			// 1 = Verifica o valor minimo de retencao
			// 2 = Nao verifica o valor minimo de retencao (estes nao serao considerados na soma dos 5000)
			If SE2->E2_APLVLMN == "2"
				(cAliasQRY)->(DbSkip())
				Loop
			Endif

			//Verifico se as compensacoes foram realizados com PA ou NDF e que nao retem PCC
			If !F241CmpPcc(cAliasQRY,cChaveTit)
				(cAliasQRY)->(DbSkip())
				Loop
			Endif

			//Desconsidera os registros da SE5 com PRET* = 5 (da compensacao)
			If (cAliasQRY)->E5_PRETPIS $ "5|6" .Or. (cAliasQRY)->E5_PRETCOF == "5|6" .OR. (cAliasQRY)->E5_PRETCSL == "5|6"
				(cAliasQRY)->(DbSkip())
				Loop
			EndIf

			nProp := 1
			nProp2 := 1
			nBasePcc := 0
			nValOutImp := 0
			If lSE2 .and. !lBxLote
				cAliasSE2 := "SE2"
			Else
				cAliasSE2 := "__SE2"
			Endif

			If ( cAliasQRY )->E5_VRETPIS + ( cAliasQRY )->E5_VRETCOF + ( cAliasQRY )->E5_VRETCSL > 0
				(cAliasSE2)->(dbSetOrder(1))
				IF !((cAliasSE2)->(MsSeek(IIf(Empty(SE5->E5_FILORIG),xFilial("SE2"),FWxFilial("SE2",SE5->E5_FILORIG))+(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))))
					(cAliasQRY)->(DbSkip())
					Loop
				Endif

				//Se for PA, verifica se houve baixa parcial para carregar varivael
				//nProp2 com o percentual proporcional para recalcular os impostos.
				If (cAliasSE2)->E2_TIPO $ MVPAGANT
					If (cAliasSE2)->E2_VALOR - (cAliasSE2)->E2_SALDO > 0
						nProp2 := (((cAliasSE2)->E2_VALOR - (cAliasSE2)->E2_SALDO) / (cAliasSE2)->E2_VALOR)
					Endif
				Endif

				If 'NOTFAT' $ (cAliasSE2)->E2_FATURA
					If ((cAliasSE2)->E2_INSS > 0 .and. !lInssBx) .or. ((cAliasSE2)->E2_IRRF > 0 .and. !lIRPFBaixa) .or.  ((cAliasSE2)->E2_ISS > 0 .and. !lCalcIssBx)
						nValOutImp := f080OutImp(nValPgto)
						lImpInFat := .T.
					EndIf
				Else
					If !lInssBx
						nValOutImp += (cAliasSE2)->E2_INSS
					Endif

					If !lIRPFBaixa
						nValOutImp += (cAliasSE2)->E2_IRRF
					EndIf

					If !lCalcIssBx
						nValOutImp += (cAliasSE2)->E2_ISS
					EndIf
				Endif

				nVlrTit := (cAliasSE2)->(E2_VALOR)+ nValOutImp

				If lSest
					nVlrTit += (cAliasSE2)->E2_SEST
				Endif

				nImpRetEmi := nVlrTit - (cAliasSE2)->(E2_VALOR)

				If lBaseSE2
					nBasePCC := (cAliasSE2)->(E2_BASEPIS)
				Endif

				//aTitulos
				//[1] Chave do titulo
				//[2]	Valor Baixado bruto
				//[3]	PCC Retido
				//[4]	PCC Retido em baixa intermediaria (sera somado para compor a proporcao na ultima baixa)

				//Array para somar os valores de titulo e valores baixados
				If (nX := Ascan(aTitulos,{|x| x[1] == (cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)})) == 0
					aadd(aTitulos,{(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA),nVlrTit,0,0})
					nX := Len(aTitulos)
					aTitulos[nX,2] := nVlrTit		//Somo as bases
				Endif

				nValProp := (cAliasQRY)->(E5_VALOR)+If(!lJurMulDes,(cAliasQRY)->(E5_VLDESCO-E5_VLJUROS-E5_VLMULTA),0)
				cDocumen	:=	""	//Trata baixa de titulos que tenham sido compensados totalmente com um PA.
				aAreaSe5	:= GetArea("SE5")
				nPccBx	:=	0
				If lPccBaixa
					nSE5Reg	:=	SE5->(Recno())
					DbSelectArea("SE5")
					SE5->(DbSetOrder(7))
					cChaveSe5	:= (cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)

					If SE5->(Dbseek(xFilial("SE5")+cChaveSe5))  .and. SE5->E5_MOTBX == "CMP"
						//somente considera E5_DOCUMEN se for compensação, pois este campo pode ser preenchido no bordero
						cDocumen	:=	SE5->E5_DOCUMEN
					Endif

					While !EOF() .And. SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) = cChaveSe5  .And.;
					SE5->E5_FILIAL = xFilial("SE5") .And. !Empty(cDocumen)
						If SE5->E5_SITUACA <> "C" .And. SE5->E5_MOTBX $ "PCC" .And. Alltrim(SE5->E5_DOCUMEN) == Alltrim(cDocumen) .And.;
						(SE5->E5_PRETPIS == " #4" .Or. SE5->E5_PRETCOF == " #4" .Or. SE5->E5_PRETCSL == " #4")
							nPccBx	+=	SE5->E5_VALOR
						Endif
						SE5->(Dbskip())
					Enddo

					RestArea(aAreaSe5)
					SE5->(dbGoto(nSE5Reg))
					//Baixa pelo valor liquido da baixa digitada devo somar os impostos quando retidos
					//(MV_BP10925 = 1)
					If !lValPgto .and. nPccBx > 0 //indica que houve baixa parcial em mês anterior
						If !Empty( ( cAliasQRY )->E5_PRETPIS )
							nPccBx	+=	( cAliasQRY )->E5_VRETPIS
						Endif
						If !Empty( ( cAliasQRY )->E5_PRETCOF )
							nPccBx	+=	( cAliasQRY )->E5_VRETCOF
						Endif
						If !Empty( ( cAliasQRY )->E5_PRETCSL )
							nPccBx	+=	( cAliasQRY )->E5_VRETCSL
						Endif
						If lCalcIssBx
							nPccBx	+=	( cAliasQRY )->E5_VRETISS
						EndIf
					EndIf
					If GetMv("MV_BP10925")= "1"
						If Empty( ( cAliasQRY )->E5_PRETPIS ) .And. Empty( ( cAliasQRY )->E5_PRETCOF ) .And. Empty( ( cAliasQRY )->E5_PRETCSL )
							nValProp	+= nPccBx
						Elseif ((cAliasQRY)->E5_PRETPIS$"1/2" .OR. (cAliasQRY)->E5_PRETCOF$"1/2" .OR. (cAliasQRY)->E5_PRETCSL$"1/2") .and. nPccBx > 0
							nValProp	+= (nPccBx-( cAliasQRY )->E5_VRETPIS-( cAliasQRY )->E5_VRETCOF-( cAliasQRY )->E5_VRETCSL)
						EndIf
					EndIf

				Endif
				If !lSE2 .or. lBxLote
					//quando a baixa é por lote, este utiliza o alias __SE2, o mesmo utilizando na funcao SumAbatPag
					// desposicionando-o. Guardado o recno
					nRecSE2 := (cAliasSE2)->(Recno())
				EndIf
				nValAbat := SumAbatPag(	(cAliasSE2)->E2_PREFIXO,(cAliasSE2)->E2_NUM,(cAliasSE2)->E2_PARCELA,;
				(cAliasSE2)->E2_FORNECE,(cAliasSE2)->E2_MOEDA,"V",(cAliasQRY)->E5_DATA,;
				(cAliasSE2)->E2_LOJA,,,,, (cAliasSE2)->E2_TIPO)

				If !lSE2 .or. lBxLote
					(cAliasSE2)->(DBGoto(nRecSE2))
					nRecSE2 := 0
				EndIf

				If nValProp + nValAbat == (cAliasSE2)->E2_VALOR
					nValProp += nValAbat
				EndIf
				
				If lInssBx .And. !(lInsPub .And. SE2->E2_TIPO $ MVPAGANT+"/INA") //Inss Baixa
					If Empty( (cAliasQRY)->E5_PRETINS ) .And.; //Titulo de PCC pendente de retencao
					(( cAliasQRY )->E5_PRETPIS $ "1" .Or. ( cAliasQRY )->E5_PRETCOF $ "1" .Or. ( cAliasQRY )->E5_PRETCSL $ "1") .And.;
					lPccBaixa
						If (cAliasQRY)->E5_VRETINS	 > 0 .And. Empty((cAliasSE2)->E2_NUMBOR)
							nValProp += (cAliasQRY)->E5_VRETINS
						ElseIf (cAliasSE2)->E2_VRETINS > 0 .And. !Empty((cAliasSE2)->E2_NUMBOR) .And. (cAliasSE2)->E2_PRETINS = "4"
							nValProp += (cAliasSE2)->E2_VRETINS
						Endif

						If lIRPFBaixa
							If (cAliasSE2)->E2_VRETIRF > 0 .And. !Empty((cAliasSE2)->E2_NUMBOR) .And. Empty((cAliasSE2)->E2_PRETIRF) .And.;
							(cAliasSE2)->E2_SALDO == 0
								nValProp += (cAliasSE2)->E2_VRETIRF
							Endif
						Endif
					Endif
				Endif

				//Apenas para titulos diferentes do titulo que esta sendo baixado ou baixas parciais pelo valor líquido
				If (cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) != cChaveTit .Or. lValPgto
					//Somo o valor do ISS caso seja retido na baixa
					If lCalcIssBx
						nValProp += (cAliasQRY)->(E5_VRETISS)
						lSomouIss := .T.
					Endif

					//Somo o valor do IR caso seja retido na baixa
					If lIRPFBaixa
						//Soma o valor do imposto somente quando houver retenção no movimento
						If ((cAliasQRY)->(E5_PRETIRF)  $ "3|4" .and. (cAliasSE2)->E2_SALDO = 0) .Or. ((cAliasQRY)->(E5_PRETIRF) $ " " .And. (cAliasSE2)->E2_SALDO = 0 .AND. (cAliasSE2)->E2_VALLIQ ==(cAliasQRY)->(E5_VALOR) ) .Or.;
						((cAliasQRY)->E5_PRETIRF  == " " .And. lValPgto .and. !((cAliasQry)->E5_TIPO $ MVPAGANT)) //FwIsInCallStack("FA080Lot"))
							If !((cAliasQry)->E5_TIPO $ MVPAGANT) .Or. ( (cAliasQry)->E5_TIPO $ MVPAGANT .and. !lPaBruto)
								nValProp += (cAliasQRY)->E5_VRETIRF
							EndIf
						Elseif((cAliasQRY)->(E5_PRETIRF) $ " " .And. (cAliasSE2)->E2_SALDO = 0)
							aTitulos[nX,3]+= (cAliasQRY)->E5_VRETIRF
						EndIf
					Endif
				Endif

				aTitulos[nX,3]+= nValProp

				//Baixa pelo valor bruto digitado nao devo somar os impostos exceto na baixa final (saldo = 0)
				//(MV_BP10925 = 1)
				If !lValPgto .and. (Empty( ( cAliasQRY )->E5_PRETPIS ) .Or. Empty( ( cAliasQRY )->E5_PRETCOF ) .Or. Empty( ( cAliasQRY )->E5_PRETCSL )) .AND.;
				((cAliasSE2)->E2_VALOR ==(cAliasQRY)->(E5_VALOR + E5_VRETPIS+E5_VRETCOF+E5_VRETCSL) + nImpRetEmi)  // INDICA A BAIXA TOTAL DO TITULO
					If (aTitulos[nX,2] == nImpRetEmi+ aTitulos[nX,3]+(cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)) .OR.;
					(cAliasQry)->E5_TIPO $ MVPAGANT
						nValProp += aTitulos[nX,4]+(cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
					Else
						aTitulos[nX,4]+= (cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)

						If lIRPFBaixa
							aTitulos[nX,4]+= (cAliasQRY)->E5_VRETIRF
							//Diminuo o valor do IR do valor proporcional pois esta nao eh a ultima baixa do titulo
							//ou teve apenas baixa proporcional.
							//Desta forma nao se compromete o calculo do PCC
							If	( (cAliasQRY)->E5_PRETIRF  == " " .And. FwIsInCallStack("FA080Lot") ) .And. ;
							(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) != cChaveTit .Or. (lAltValor .And. lValPgto)
								nValProp -= (cAliasQRY)->E5_VRETIRF
							Endif
						Endif

					Endif

					If nPccBx==0
						aTitulos[nX,3]+= (cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
					Endif

					//Baixa pelo valor liquido da baixa digitada devo somar os impostos quando retidos
					//(MV_BP10925 = 2) ou MV_BP10925 = 1 e O TITULO ESTIVER BAIXADO TOTAL ATRAEVES DE SEGUNDA BAIXA
				ElseIF (lValPgto .AND. (( cAliasQRY )->E5_PRETPIS $ " |7" .Or. ( cAliasQRY )->E5_PRETCOF $ " |7" .Or. ( cAliasQRY )->E5_PRETCSL $ " |7"));
				.OR. (Empty((cAliasSE2)->E2_FATURA)  .And. (cAliasSE2)->E2_SALDO==0 .AND. !lValPgto .AND.;
				(Empty( ( cAliasQRY )->E5_PRETPIS ) .Or. Empty( ( cAliasQRY )->E5_PRETCOF ) .Or. Empty( ( cAliasQRY )->E5_PRETCSL )))

					If   !(lValPgto .And. lPropPA .And. lPrImPA .And. !Empty((cAliasQRY)->E5_DOCUMEN) .And.(MVPAGANT $(cAliasSE2)->E2_TIPO)) ;
					.and. !(Empty((cAliasQRY)->E5_DOCUMEN) .and. MVPAGANT $(cAliasSE2)->E2_TIPO)
						If lCalcIssBx
							If lIRPFBaixa .And. (((cAliasQRY)->(E5_PRETIRF)  $ " "  .And. (cAliasSE2)->E2_SALDO = 0)) .And.;
							((cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) != cChaveTit .Or. (lValPgto))
								//Neste caso o ISS foi somado anteriormente.
								nValProp       += (cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
								aTitulos[nX,3] += (cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
							Else
								lSomouIss	:= .T.
								nValProp       += (cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL+Iif(SA2->A2_TIPO == "J",E5_VRETISS,0))
								aTitulos[nX,3] += (cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL+Iif(SA2->A2_TIPO == "J",E5_VRETISS,0))

								If (SE2->E2_ISS - (cAliasQry)->E5_VRETISS) > 0 .And. !lValPgto
									nValProp += SE2->E2_ISS - (cAliasQry)->E5_VRETISS
									aTitulos[nX,3] += SE2->E2_ISS - (cAliasQry)->E5_VRETISS
								EndIf
							Endif
						Else
							nValProp       += (cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
							aTitulos[nX,3] += (cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
						EndIf
					Endif

					If nPccBx>0 .and. !lValPgto
						nValProp += nImpRetEmi
					Endif
				Else

					If (nValProp+nImpRetEmi+IIF( lCalcIssBx, (cAliasQRY)->E5_VRETISS, 0)) == aTitulos[nX,2]
						If lCalcIssBx
							lSomouIss := .T.
							nValProp       += (cAliasQRY)->E5_VRETISS
							aTitulos[nX,3] += (cAliasQRY)->E5_VRETISS
						EndIf
					ElseIf (nValProp+nImpRetEmi) <> aTitulos[nX,2]
						If nValProp <>(cAliasQRY)->(E5_VALOR+E5_VLDESCO-E5_VLJUROS-E5_VLMULTA)
							nValProp += nImpRetEmi
						EndIf
					Endif

				EndIf

				//Somo o valor dos impostos retidos na emissao para proporcionalizar corretamente
				If (aTitulos[nX,2] == aTitulos[nX,3] + nImpRetEmi) 

					nPropIss := 0 //Caso o titulo possua uma compensacao e o ISS for na emissao devo proporcionalizar para realizar a soma.
					If (!Empty(cDocumen) .And. MVPAGANT $ cDocumen).And. !lCalcIssBx .And. !((cAliasSE2)->E2_TIPO $ MVPAGANT)
						nPropIss := (((cAliasSE2)->E2_ISS * nValProp) / (cAliasSE2)->	E2_VALOR) / 100
						nImpRetEmi := nImpRetEmi - (cAliasSE2)->E2_ISS	 + ((cAliasSE2)->E2_ISS	 * nPropIss)
					EndIf

					nValProp += nImpRetEmi
				EndIf

				If lCalcIssBx .And. lValPgto .And. !lSomouIss
					nValProp += (cAliasQRY)->E5_VRETISS
					aTitulos[nX,3] += (cAliasQRY)->E5_VRETISS
				EndIf
				If (cAliasQRY)->E5_VALOR == 0
					//para baixas que tiveram o valor zerado recompoe o valor do IR e INSS, ISS retido na emissao
					//para obter corretamente o valor da baixa parcial em relacao ao valor total
					If !lIRPFBaixa
						nValProp += (cAliasSE2)->E2_VRETIRF
					EndIf
					If (cAliasSE2)->(E2_INSS) > 0 .And. !lInssBx
						nValProp += (cAliasSE2)->(E2_INSS)
					EndIf
					If !lCalcIssBx
						nValProp += (cAliasSE2)->(E2_ISS)
					ElseIf !lValPgto
						nValProp += (cAliasSE2)->(E2_ISS)-(cAliasQRY)->E5_VRETISS
					EndIf

				EndIf
				If MVPAGANT $(cAliasSE2)->E2_TIPO .And. lCalcIssBx .and. lValPgto
					nVlrTit += (cAliasSE2)->E2_ISS
				EndIf

				lNfComp	:=	.F.
				nIssComp	:=	0
				If !lCalcIssBx .And. (!Empty(cDocumen) .And. MVPAGANT $ cDocumen) .And. !(MVPAGANT $(cAliasSE2)->E2_TIPO)
					lNfComp	 :=	.T.
					nIssComp := (cAliasSE2)->E2_ISS
				Endif
				If (cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == cChaveTit
					nProp := nValProp/nVlrTit
				Else
					lTBxOTits := .T.
					If !lGrvIRE2
						nINSSAnts += (cAliasSE2)->(E2_INSS)
						If !lIRPFBaixa
							nIRAnts   += (cAliasSE2)->E2_VRETIRF
						Endif
					EndIf
					nProp := nValProp /nVlrTit
				EndIf

				IF ( cAliasQRY )->E5_MOTBX == "PCC" .And. (cAliasSE2)->E2_SALDO > 0 //Se veio do borderô e está com o saldo maior que zero (aberto)
					nProp := 1
				Endif

				If nBasePcc > 0
					nVlrTit := nBasePcc * nProp
				Endif

				//Incrementa a base de calculo para gerar os titulos se nao for
				//compensação entre carteiras e baixa de impostos via bordero
				//O registro de compensacao do PA nao deve integrar a base (este eh feito com o registro do
				//titulo principal
				If !(cAliasQRY)->E5_MOTBX $ "PCC#IRF#CEC"  .or. ;
				!((cAliasQRY)->E5_MOTBX $ "CMP" .AND. (cAliasQRY)->E5_TIPO $ MVPAGANT)
					If nBasePcc == 0
						nVlrTit := nVlrTit * nProp
					Endif
					aDadosRef[1] += nVlrTit * nProp2
				EndIf
			Else
				If !(cAliasQRY)->E5_MOTBX $ "PCC#IRF#CEC" .and. ;
				!((cAliasQRY)->E5_MOTBX $ "CMP" .and. SUBSTR((cAliasQRY)->E5_DOCUMEN,nTamTit2+1,3) $ MV_CPNEG) .and. ; //Desconsiderar compensacoes com NDF
				!((cAliasQRY)->E5_MOTBX $ "CMP" .AND. (cAliasQRY)->E5_TIPO $ MVPAGANT)
					aDadosRef[1] += (cAliasQRY)->(E5_VALOR+E5_VLDESCO-E5_VLJUROS-E5_VLMULTA)
				EndIf
			Endif

			//Incrementa a base de calculo para gerar os titulos
			If (cAliasQRY)->E5_MOTBX == "PCC"
				aDadosRef[1] += nVlrTit - (cAliasQRY)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
			EndIf

			//Guardo os valores compensados entre carteiras para recompor a base de calculo
			If (cAliasQRY)->E5_MOTBX == "CEC" .And. (cAliasQRY)->E5_RECPAG == "P" .And.;
			(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == cChaveTit .and. SuperGetMV( "MV_CC10925" , , 1) <> 2
				nValComp += (cAliasQRY)->E5_VALOR
			EndIf

			//Recalcula o valor do titulo principal para adicionar no campo
			// com os valores de titulos retidos
			aAreaQry := GetArea()
			SFQ->(dbSetOrder(1))
			cChaveSE5 := (cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)
			If SFQ->(MsSeek(xFilial("SFQ")+cAliasSE2+cChaveSE5))
				While SFQ->(!Eof()) .and. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
				SFQ->(FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI+FQ_CFORI+FQ_LOJAORI) == cChaveSE5
					cChaveSFQ := SFQ->(FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES)
					(cAliasSE2)->(dbSetOrder(1))
					If (cAliasSE2)->(MsSeek(xFilial(cAliasSE2)+cChaveSFQ))
						aDadosRef[1] += (cAliasSE2)->E2_VALOR
					EndIf
					SFQ->(dbSkip())
				EndDo
			EndIf
			RestArea(aAreaQry)

			If lSE2 .and. !lBxLote
				cAliasSE2 := "SE2"
			Else
				cAliasSE2 := "__SE2"
			Endif

			If (cAliasQRY)->E5_MOTBX == "CMP" .OR. ( cAliasQRY )->E5_VRETPIS + ( cAliasQRY )->E5_VRETCOF + ( cAliasQRY )->E5_VRETCSL  > 0// .or. (lEmpPub .and. M->E2_TIPO $ MVPAGANT)


				(cAliasSE2)->(dbSetOrder(1))
				IF !((cAliasSE2)->(MsSeek(xFilial("SE2")+(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))))
					(cAliasQRY)->(DbSkip())
					Loop
				Endif

				//aTitulos
				//[1] Chave do titulo
				//[2]	Valor Baixado bruto
				//[3]	PCC Retido
				//[4]	PCC Retido em baixa intermediaria (sera somado para compor a proporcao na ultima baixa)

				If (cAliasQRY)->E5_MOTBX == "CMP" .AND. !(cAliasQRY)->E5_TIPO $ MVPAGANT

					nVlrTit := (cAliasSE2)->(E2_VALOR+E2_IRRF+E2_ISS)

					nVlrTit += Iif(!lInssBx,(cAliasSE2)->E2_INSS,0)

					If lSest
						nVlrTit += (cAliasSE2)->E2_SEST
					Endif

					If lCalcIssBx
						nVlrTit -= (cAliasSE2)->E2_ISS
					Endif

					//Array para somar os valores de titulo e valores baixados
					If (nX := Ascan(aTitulos,{|x| x[1] == (cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)})) == 0
						aadd(aTitulos,{(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA),nVlrTit,0,0})
						nX := Len(aTitulos)
						aTitulos[nX,2] := nVlrTit		//Somo as bases
					Endif
					aTitulos[nX,3]+= (cAliasQRY)->(E5_VALOR+E5_VLDESCO-E5_VLJUROS-E5_VLMULTA)
				EndIf

				If (Ascan(aTitBsImp,{|x| x == (cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ)})) = 0

					If !((cAliasQRY)->E5_MOTBX $ "CMP#FAT#LIQ#STP")
						//Armazeno os valores calculados por titulo.
						If (cAliasSE2)->E2_PIS > 0
							aDadosImp[1] += (cAliasSE2)->E2_PIS * nProp
							lGravou := .T.
						EndIf

						If (cAliasSE2)->E2_COFINS > 0
							aDadosImp[2] += (cAliasSE2)->E2_COFINS * nProp
							lGravou := .T.
						EndIf

						If (cAliasSE2)->E2_CSLL > 0
							aDadosImp[3] += (cAliasSE2)->E2_CSLL * nProp
							lGravou := .T.
						EndIf

						If !Empty((cAliasSE2)->E2_NUMBOR) .and. (cAliasSE2)->E2_SALDO > 0
							If (cAliasSE2)->E2_PRETPIS $ "1#2#4"
								aDadosBor[1] +=  (cAliasSE2)->E2_PIS * nProp
								lTemDadosBor := .T.
							EndIf

							If (cAliasSE2)->E2_PRETCOF $ "1#2#4"
								aDadosBor[2] +=  (cAliasSE2)->E2_COFINS * nProp
								lTemDadosBor := .T.
							EndIf

							If (cAliasSE2)->E2_PRETCSL $ "1#2#4"
								aDadosBor[3] +=  (cAliasSE2)->E2_CSLL * nProp
								lTemDadosBor := .T.
							EndIf

						EndIf
					EndIf

					//Somo valores dos impostos de IRRF/ISS/INSS dos titulos que foram compensados
					//por PA que não reteve impostos, para recompor a base de calculo
					If (cAliasSE2)->(E2_IRRF+E2_ISS+E2_INSS) > 0 .AND. !(cAliasQRY)->E5_TIPO $ MVPAGANT .And.;
					(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) != cChaveTit
						aAreaSE5 := (cAliasQRY)->(GetArea())
						dbSelectArea("SE5")
						dbSetOrder(7)
						If MsSeek(xFilial("SE5")+SUBSTR((cAliasQRY)->E5_DOCUMEN,1,nTamTit)+(cAliasQRY)->E5_FORNADT+;
						(cAliasQRY)->E5_LOJAADT)
							If	(SE5->E5_PRETPIS == "1" .Or. SE5->E5_PRETCOF == "1" .Or. SE5->E5_PRETCSL == "1")
								aDadosImp[4] += (cAliasSE2)->E2_ISS
								aDadosImp[4] += Iif(!lInssBx,(cAliasSE2)->E2_INSS,0)
								If lIRPFBaixa //Somar o valor do IR que nao reteve somente em caso de ir na baixa.
									aDadosImp[4] += (cAliasSE2)->(E2_IRRF)
								EndIf
								lGravou := .T.
							EndIf
						EndIf
						RestArea(aAreaSE5)
					EndIf

					//Somo valores dos impostos de IRRF/ISS/INSS dos titulos do tipo PA (Pagto Adiantado)
					//que foram compensados, para recompor a base de calculo(nBaseImp) do PIS/COF/CSL

					If (cAliasSE2)->(If(lIRPFBaixa,0,E2_IRRF)+E2_ISS+If(lPrImPA .Or. lInssBx,0,E2_INSS)) > 0 .AND. (cAliasQRY)->E5_TIPO $ MVPAGANT .And.;
					SUBSTR((cAliasQRY)->E5_DOCUMEN,1,nTamTit)+(cAliasQRY)->(E5_FORNADT+E5_LOJAADT) == cChaveTit
						aAreaSE5 := (cAliasQRY)->(GetArea())
						dbSelectArea("SE5")
						dbSetOrder(7)
						If MsSeek(xFilial("SE5")+(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))
							SFQ->(dbSetOrder(2))
							cChaveSE5 := SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)
							If SFQ->(MsSeek(xFilial("SFQ")+"SE5"+cChaveSE5))
								lAchouPa := .T.
							EndIf

							If	(SE5->E5_PRETPIS $ "1# " .Or. SE5->E5_PRETCOF $ "1# " .Or. SE5->E5_PRETCSL $ "1# ") .And.;
							!lAchouPa
								aDadosImp[5] += (cAliasSE2)->(E2_IRRF+E2_ISS)
								aDadosImp[5] += Iif(!lInssBx,(cAliasSE2)->E2_INSS,0)
								lGravou := .T.
								AAdd( aRecnos, ( cAliasQRY )->RECNOSE5 )
							EndIf
						EndIf
						RestArea(aAreaSE5)
					EndIf

					If lGravou
						AADD(aTitBsImp,(cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ))
						lGravou := .F.
					Endif
				Endif
			EndIf

			nImpostos := 0

			// QUANDO FOR RETIDO NELE MESMO OU RETIDO EM BORDERO, DESCONSIDERO ESSE VALOR PARA SABER QUAL O TOTAL DE PCC QUE REALMENTE DEVO
			If ( cAliasQRY )->E5_PRETPIS $ " #3#4" .or. (( cAliasQRY )->E5_PRETPIS $ "2" .and. ((cAliasQRY)->E5_TIPO $ MVPAGANT .or. F080RetPA("SE5",(cAliasQRY)->E5_PREFIXO, (cAliasQRY)->E5_NUMERO,(cAliasQRY)->E5_PARCELA,(cAliasQRY)->E5_TIPO,(cAliasQRY)->E5_CLIFOR,(cAliasQRY)->E5_LOJA )))
				aDadosRef[1] += (cAliasQRY)->E5_VRETPIS * nProp2
				nImpostos += (cAliasQRY)->E5_VRETPIS * nProp2
				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->E5_VRETPIS + ( cAliasQRY )->E5_VRETCOF + ( cAliasQRY )->E5_VRETCSL > 0 .And.;
				!((cAliasQRY)->E5_MOTBX $ "CMP#FAT#LIQ#STP")
					aDadosImp[1] -= (cAliasQRY)->E5_VRETPIS * nProp2
					lVerSFQ := .T.
				Endif
			EndIf

			If ( cAliasQRY )->E5_PRETCOF $ " #3#4" .or. (( cAliasQRY )->E5_PRETPIS $ "2" .and. ((cAliasQRY)->E5_TIPO $ MVPAGANT .or. F080RetPA("SE5",(cAliasQRY)->E5_PREFIXO, (cAliasQRY)->E5_NUMERO,(cAliasQRY)->E5_PARCELA,(cAliasQRY)->E5_TIPO,(cAliasQRY)->E5_CLIFOR,(cAliasQRY)->E5_LOJA )) )
				aDadosRef[1] += ( cAliasQRY )->E5_VRETCOF * nProp2
				nImpostos += (cAliasQRY)->E5_VRETCOF * nProp2
				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->E5_VRETPIS + ( cAliasQRY )->E5_VRETCOF + ( cAliasQRY )->E5_VRETCSL  > 0 .And.;
				!((cAliasQRY)->E5_MOTBX $ "CMP#FAT#LIQ#STP")
					aDadosImp[2] -= (cAliasQRY)->E5_VRETCOF * nProp2
					lVerSFQ := .T.
				Endif
			EndIf

			If ( cAliasQRY )->E5_PRETCSL $ " #3#4" .or. (( cAliasQRY )->E5_PRETPIS $ "2" .and. ((cAliasQRY)->E5_TIPO $ MVPAGANT .or. F080RetPA("SE5",(cAliasQRY)->E5_PREFIXO, (cAliasQRY)->E5_NUMERO,(cAliasQRY)->E5_PARCELA,(cAliasQRY)->E5_TIPO,(cAliasQRY)->E5_CLIFOR,(cAliasQRY)->E5_LOJA )) )
				aDadosRef[1] += ( cAliasQRY )->E5_VRETCSL * nProp2
				nImpostos += (cAliasQRY)->E5_VRETCSL * nProp2
				//Armazeno os valores calculados por titulo, retirando os valores retidos
				If ( cAliasQRY )->E5_VRETPIS + ( cAliasQRY )->E5_VRETCOF + ( cAliasQRY )->E5_VRETCSL  > 0 .And.;
				!((cAliasQRY)->E5_MOTBX $ "CMP#FAT#LIQ#STP")
					aDadosImp[3] -= (cAliasQRY)->E5_VRETCSL * nProp2
					lVerSFQ := .T.
				Endif
			EndIf

			If !lGrvIRE2     //se jah gravou o conteudo do E2, para nao gravar várias vezes no caso de várias baixas parciais
				If !lIRPFBaixa
					aDadosRef[1] += (cAliasSE2)->E2_VRETIRF
				Endif
				aDadosRef[1] += Iif(!lInssBx,(cAliasSE2)->E2_INSS,0)
				lGrvIRE2 := .T.
			EndIf

			//Verificação de pendencias de PCC
			//Exemplo:
			//Titulo A teve o imposto retido no titulo B em bordero.
			//Ambos foram baixados
			//Ao verificar esta baixa, o valor do imposto calculado era menor que o imposto retido no titulo B
			//Neste caso o imposto do titulo A seria sempre deduzido nos borderos posteriores
			If lVerSfq .and. (aDadosBor[1] + aDadosBor[2] + aDadosBor[3]) == 0
				aRecSE2 := FImpExcTit("SE2",( cAliasQRY )->E5_PREFIXO,( cAliasQRY )->E5_NUMERO,( cAliasQRY )->E5_PARCELA,( cAliasQRY )->E5_TIPO,( cAliasQRY )->E5_CLIFOR,( cAliasQRY )->E5_LOJA, ,( cAliasQRY )->E5_SEQ)
				nRecSE2 := 	__SE2->(RECNO())
				For nT := 1 to Len(aRecSE2)
					__SE2->(MSGoto(aRecSE2[nT]))
					aDadosImp[1] += __SE2->E2_PIS
					aDadosImp[2] += __SE2->E2_COFINS
					aDadosImp[3] += __SE2->E2_CSLL
				Next
				__SE2->(MSGoto(nRecSE2))
				lVerSfq := .F.
			Endif

			If !SE2->(Eof()) .And. (cAliasSE2)->E2_SALDO == 0 .and. lPCCBaixa .and. Empty(( cAliasQRY )->E5_PRETPIS) .and. Empty(( cAliasQRY )->E5_PRETCOF) .and. Empty(( cAliasQRY )->E5_PRETCSL);
			.and. !(( cAliasQRY )->E5_MOTBX == "CMP" .and. ( cAliasQRY )->E5_TIPO == MVPAGANT)
				// Ajusta os PRET (impostos retidos nele mesmo)
				RecLock("SE2",.F.)
				SE2->E2_PRETPIS := "3"
				SE2->E2_PRETCOF := "3"
				SE2->E2_PRETCSL := "3"
				MsUnlock()
				If aDadosImp[1] # 0 .or. aDadosImp[2] # 0 .or. aDadosImp[3] # 0 .or. aDadosImp[4] # 0 .or. aDadosImp[5] # 0
					If cNCCRet == "1"
						aFill(aDadosImp,0) // Não pode haver PCC a ser retido ainda se a baixa do título já tiver sido total !
					EndIf
				Endif
			Endif

			//Guardo o valor dos impostos descontados para que seja recomposta a base de calculo
			If (cAliasQRY)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == cChaveTit
				//Caso o sistema gravar como valor de pagamento na baixa parcial, o valor da baixa menos os impostos
				//calculados, não ha a necessidade de recompor a base de calculo
				If lValPgto
					aDadosRef[7] += nImpostos
				EndIf
			Endif
			//PRET == "1" -> pendente de retenção
			If ( cAliasQRY )->E5_PRETPIS == "1" .Or. ( cAliasQry )->E5_PRETCOF == "1" .Or. ( cAliasQry )->E5_PRETCSL == "1"

				If ( cAliasQRY )->E5_PRETPIS == "1"
					aDadosRef[2] += ( cAliasQRY )->E5_VRETPIS * nProp2
					nTotPis      += ( cAliasQRY )->E5_VRETPIS * nProp2
				EndIf

				If ( cAliasQRY )->E5_PRETCOF == "1"
					aDadosRef[3] += ( cAliasQRY )->E5_VRETCOF * nProp2
					nTotCof      += ( cAliasQRY )->E5_VRETCOF * nProp2
				EndIf

				If ( cAliasQRY )->E5_PRETCSL == "1"
					aDadosRef[4] += ( cAliasQRY )->E5_VRETCSL * nProp2
					nTotCsl	    += ( cAliasQRY )->E5_VRETCSL * nProp2
				EndIf

				AAdd( aRecnos, ( cAliasQRY )->RECNOSE5 )

				// Acumula os valores das baixas realizadas parcialmente
				// para ser utilizada na analise de possiveis problemas
				// de arredondamento que ocorrem na baixa total.
			Else

				If Empty((cAliasQRY)->E5_PRETPIS)
					aValorBx[1] += ( cAliasQRY )->E5_VRETPIS
				EndIf

				If Empty((cAliasQRY)->E5_PRETCOF)
					aValorBx[2] += ( cAliasQRY )->E5_VRETCOF
				EndIf

				If Empty((cAliasQRY)->E5_PRETCSL)
					aValorBx[3] += ( cAliasQRY )->E5_VRETCSL
				EndIf

			Endif

			( cAliasQRY )->( dbSkip())

		EndDo

		// Fecha a area de trabalho da query
		( cAliasQRY )->( dbCloseArea() )
		FWFreeObj(oQuerySE5)
		dbSelectArea( "SE2" )

		//Titulos em bordero que tem retencao de PCC pendente
		//Exemplo:
		//3 titulos de 4000 com calculo de PCC
		//Coloque o primeiro titulo em bordero e ao baixar o segundo, o imposto devera
		//ser calculado por 8000 (soma dois titulos)
		//Se baixar ou gerar bordero para o terceiro, este devera reter apenas sobre a sua base
		If lSE2DtBor

			aStruct := SE2->( dbStruct() )

			SE2->( dbCommit() )

			cAliasQry := GetNextAlias()

			cQuery := "SELECT E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_FORNECE,E2_LOJA,"
			cQuery += "E2_VALOR,E2_VRETPIS,E2_VRETCOF,E2_VRETCSL,E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,"
			cQuery += "E2_NUMBOR,E2_PIS,E2_COFINS,E2_CSLL,E2_IRRF,E2_ISS,E2_INSS, E2_SALDO, "

			If lSE2DtBor
				cQuery += "E2_DTBORDE,"
			Endif
			If lCpoVlMin
				cQuery += "E2_APLVLMN,"
			Endif

			If lSest
				cQuery += "E2_SEST,"
			Endif

			If lVerifPCC
				cQuery += "E2_ORIGEM, E2_NUMTIT,E2_FORNPAI,"
			Endif

			If lBaseSE2
				cQuery += "E2_BASEPIS,"
			Endif

			cQuery += "	R_E_C_N_O_ RECNOSE2 FROM "
			cQuery += RetSqlName( "SE2" ) + " SE2A "
			cQuery += "WHERE "

			cQuery += "E2_FILIAL IN ("
			cQuery += cFiliais
			cQuery += ") AND "


			If Len(aFor10925) > 0  //Verificar determinados fornecedores (raiz do CNPJ)
				cQuery += "( "
				For nLoop := 1 to Len(aFor10925)
					cQuery += "(E2_FORNECE ='"   + aFor10925[nLoop,1]  + "' AND "
					cQuery += "E2_LOJA='"       + aFor10925[nLoop,2]  + "') OR "
				Next
				//Retiro o ultimo OR
				cQuery := Left( cQuery, Len( cQuery ) - 4 )
				cQuery += ") AND "
			Else  //Apenas Fornecedor e Loja atuais
				cQuery += "E2_FORNECE ='"     + SE2->E2_FORNECE        + "' AND "
				If lLojaAtu  //Considero apenas a loja atual
					cQuery += "E2_LOJA='"        + SE2->E2_LOJA           + "' AND "
				Endif
			Endif

			cQuery += "(E2_DTBORDE >= '" + DToS( dDataIni )					+ "' AND "
			cQuery += "E2_DTBORDE <= '" + DToS( dDataFim )					+ "') AND "
			cQuery += "E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")			+ " AND "
			cQuery += "E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)		+ " AND "
			cQuery += "E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)	+ " AND "
			cQuery += "E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepPag)		+ " AND "
			cQuery += "(E2_SALDO>0 OR E2_NUMBOR <> '"+SPACE(LEN(E2_NUMBOR))+"') AND "
			cQuery += "E2_NUMBOR <> '"+SPACE(LEN(E2_NUMBOR))+"' AND "

			cQuery += " (E2_PIS > 0 OR E2_COFINS > 0 OR E2_CSLL > 0 ) AND "

			//Verificar ou nao o limite de 5000 para Pis cofins Csll
			// 1 = Verifica o valor minimo de retencao
			// 2 = Nao verifica o valor minimo de retencao (NAO SERAO CONSIDERADOS PARA A SOMA DOS 5000)
			If lCpoVlMin
				cQuery += " E2_APLVLMN <> '2' AND "
			Endif

			If !lVerifPCC
				cQuery += "D_E_L_E_T_ = ' '"
			Else
				cQuery += " SE2A.D_E_L_E_T_ = ' ' "
				cQuery += " UNION "

				cQuery += "SELECT E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_FORNECE,E2_LOJA,"
				cQuery += "E2_VALOR,E2_VRETPIS,E2_VRETCOF,E2_VRETCSL,E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,"
				cQuery += "E2_NUMBOR,E2_PIS,E2_COFINS,E2_CSLL,E2_IRRF,E2_ISS,E2_INSS,E2_SALDO, "

				If lSE2DtBor
					cQuery += "E2_DTBORDE,"
				Endif
				If lCpoVlMin
					cQuery += "E2_APLVLMN,"
				Endif
				If lSest
					cQuery += "E2_SEST,"
				Endif
				If lVerifPCC
					cQuery += "E2_ORIGEM, E2_NUMTIT,E2_FORNPAI,"
				Endif

				If lBaseSE2
					cQuery += "E2_BASEPIS,"
				Endif

				cQuery += "	R_E_C_N_O_ RECNOSE2 FROM "
				cQuery += RetSqlName( "SE2" ) + " SE2B "
				cQuery += "WHERE "

				cQuery += "E2_FILIAL IN ("
				cQuery += cFiliais
				cQuery += ") AND "

				If Len(aFor10925) > 0  //Verificar determinados fornecedores (raiz do CNPJ)
					cQuery += "( "
					For nLoop := 1 to Len(aFor10925)
						cQuery += "(E2_FORNPAI ='"   + PADR(aFor10925[nLoop,1]+ aFor10925[nLoop,2],nTamForn) + "') OR "
					Next
					//Retiro o ultimo OR
					cQuery := Left( cQuery, Len( cQuery ) - 4 )
					cQuery += ") AND "
				Else  //Apenas Fornecedor e Loja atuais
					cQuery += "E2_FORNPAI ='"   + PADR(SE2->(E2_FORNECE+E2_LOJA),nTamForn) + "' AND "
				Endif
				cQuery += " E2_EMISSAO BETWEEN '"+Dtos( dDataIni) +"' AND '"+Dtos( dDataFim) +"' AND "
				cQuery += " E2_ORIGEM LIKE 'FINA374%' AND "
				cQuery += " (E2_TIPO IN " + FormatIn(MVTXA,cSepTxa)  + " OR "
				cQuery += " E2_TIPO IN " + FormatIn(MVTAXA,cSepTx) + ") AND "
				cQuery += " SE2B.D_E_L_E_T_ = ' ' "

			Endif

			cQuery := ChangeQuery( cQuery )

			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

			For nLoop := 1 To Len( aStruct )
				If !Empty( AScan( aCampos, AllTrim( aStruct[nLoop,1] ) ) )
					TcSetField( cAliasQry, aStruct[nLoop,1], aStruct[nLoop,2],aStruct[nLoop,3],aStruct[nLoop,4])
				EndIf
			Next nLoop

			While !( cAliasQRY )->( Eof())

				//VERIFICA VALORES APURADOS VIA FINA374
				If ( cAliasQRY )->E2_TIPO $ MVTXA .AND. "FINA374" $ ( cAliasQRY )->E2_ORIGEM
					aDadosImp[1]  	+=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='PIS',( cAliasQRY )->E2_VALOR,0)
					aDadosImp[2]  	+=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='COF',( cAliasQRY )->E2_VALOR,0)
					aDadosImp[3]  	+=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='CSL',( cAliasQRY )->E2_VALOR,0)
					aDadosREF[2]  	+=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='PIS',( cAliasQRY )->E2_VALOR,0)
					aDadosREF[3]  	+=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='COF',( cAliasQRY )->E2_VALOR,0)
					aDadosREF[4]  	+=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='CSL',( cAliasQRY )->E2_VALOR,0)
				ElseIf ( cAliasQRY )->E2_TIPO $ MVTAXA .AND. "FINA374" $ ( cAliasQRY )->E2_ORIGEM
					aDadosImp[1]  	-=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='PIS',( cAliasQRY )->E2_VALOR,0)
					aDadosImp[2]  	-=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='COF',( cAliasQRY )->E2_VALOR,0)
					aDadosImp[3]  	-=  If(SUBSTR(( cAliasQRY )->E2_NUMTIT,8,3)=='CSL',( cAliasQRY )->E2_VALOR,0)
				Else
					//Caso o titulo que esteja sendo baixado estiver em bordero e for selecionado para verificacao
					//da base do PCC, descarto neste momento. Assim o mesmo sera considerado apenas uma vez, no calculo
					//final. Anteriormente era considerado neste ponto (por estar em bordero) e no calculo da base, fazendo
					//atingir base de retencao de forma equivocada.
					If cTitAtual == ( cAliasQRY )->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) .and. ;
					!Empty(( cAliasQRY )->(E2_NUMBOR))
						( cAliasQRY )->( dbSkip())
					Endif

					If ( cAliasQRY )->(E2_SALDO) == 0   //adicionado a validação de borderô para
						( cAliasQRY )->( dbSkip())
						Loop
					Endif

					nVlrTit := ( cAliasQRY )->E2_VALOR

					If !lInssBx
						nVlrTit += ( cAliasQRY )->E2_INSS
					EndIf

					If !lIRPFBaixa
						nVlrTit += ( cAliasQRY )->E2_IRRF
					EndIf

					If !lCalcIssBx
						nVlrTit += ( cAliasQRY )->E2_ISS
					EndIf

					If lSest
						nVlrTit += ( cAliasQRY )->E2_SEST
					Endif

					If lBaseSE2 .and. ( cAliasQRY )->E2_BASEPIS > 0
						nVlrTit := ( cAliasQRY )->E2_BASEPIS
					Endif

					aDadosRef[1] += nVlrTit

					lTitBor	:=	.T.

					//Armazeno os valores calculados por titulo.
					If (cAliasQRY)->E2_PRETPIS $ "1#2#4"
						aDadosImp[1] += (cAliasQRY)->E2_PIS
						aDadosRef[2] += (cAliasQRY)->E2_PIS
					Endif

					If (cAliasQRY)->E2_PRETCOF $ "1#2#4"
						aDadosImp[2] += (cAliasQRY)->E2_COFINS
						aDadosRef[3] += (cAliasQRY)->E2_COFINS
					Endif

					If (cAliasQRY)->E2_PRETCSL $ "1#2#4"
						aDadosImp[3] += (cAliasQRY)->E2_CSLL
						aDadosRef[4] += (cAliasQRY)->E2_CSLL
					Endif
					If !lTemDadosBor .and. (cAliasQRY)->E2_SALDO > 0
						If (cAliasQRY)->E2_PRETPIS $ "2|4"
							aDadosBor[1] +=  (cAliasQRY)->E2_PIS
						EndIf

						If (cAliasQRY)->E2_PRETCOF $ "2|4"
							aDadosBor[2] +=  (cAliasQRY)->E2_COFINS
						EndIf

						If (cAliasQRY)->E2_PRETCSL $ "2|4"
							aDadosBor[3] +=  (cAliasQRY)->E2_CSLL

						EndIf

					EndIf
					//Guardo registros para acertar a pendencia de retencao
					If ((cAliasQRY)->E2_PRETPIS = '1' .OR. (cAliasQRY)->E2_PRETCOF = '1' .OR. (cAliasQRY)->E2_PRETCSL = '1' )
						AAdd( aRecnosSE2, (cAliasQRY)->RECNOSE2)
					Endif

				Endif
				( cAliasQRY )->( dbSkip())

			EndDo
			//subtrai o valor ja retido do bordero somente no final, senao ira substrair mais de 1x o mesmo valor
			If aDadosBor[1] + aDadosBor[2] + aDadosBor[3] > 0
				aDadosImp[1] -= aDadosBor[1]
				aDadosRef[2] -= aDadosBor[1]

				aDadosImp[2] -= aDadosBor[2]
				aDadosRef[3] -= aDadosBor[2]

				aDadosImp[3] -= aDadosBor[3]
				aDadosRef[4] -= aDadosBor[3]
			EndIf

			// Fecha a area de trabalho da query
			( cAliasQRY )->( dbCloseArea() )
			dbSelectArea( "SE2" )
			dbSetOrder(1)

		Endif

		aDadosRef[ 6 ] := AClone( aRecnos )

	Endif
	cFilAnt := cFilAtu
	RestArea(aArea)
	aDadosRet := aClone(aDadosRef)

	//Calculo do Pis, Cofins e Csll
	If !lCalcPA //Se nao for inclusao de PA
		SE2->(dbGoto(nSE2Reg))
		SED->(dbSetOrder(1))
		SED->(MsSeek(xFilial("SED")+SE2->E2_NATUREZ))
		SA2->(dbSetOrder(1))
		SA2->(MsSeek(xFilial("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA))

		If !lCalcIssBx .And. lPABruto //ISS na emissao e PaBruto = 1
			aDocumen	:=	{}	//Trata baixa de titulos que tenham sido compensados totalmente com um PA.
			If lIRPFBaixa .And. lPCCBaixa
				aAreaSe2	:= GetArea("SE2")
				nJ			:=	nIssPa	:=	nPccPa	:=	nIrPa	:=	0
				aNf		:=	{}
				DbSelectArea("SE5")
				SE5->(DbSetOrder(7))

				cChaveSe2	:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
				SE5->(Dbseek(xFilial("SE5")+cChaveSe2))
				While !EOF() .And. SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) = cChaveSe2  .And. SE5->E5_FILIAL = xFilial("SE5")

					If TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ)) .Or. Empty(SE5->E5_DOCUMEN)
						SE5->(Dbskip())
						Loop
					Endif

					If Ascan(aNf,SE5->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA)) == 0
						Aadd(aNf,SE5->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))
					Endif

					If Ascan(aDocumen,SE5->E5_DOCUMEN) == 0
						Aadd(aDocumen,SE5->E5_DOCUMEN)
					Endif
					SE5->(Dbskip())
				Enddo
				For nJ:=1 to Len(aDocumen)
					If SE2->(Dbseek(xFilial("SE2")+aDocumen[nJ]))
						If Len(aNf)>1 .And. (SE2->E2_SALDO > 0 .Or. Empty(SE2->E2_BAIXA))
							nIssPa	:=	nPccPa	:=	nIrPa	:=	nVrPa	:=	0
						Else
							nIssPa	+=	SE2->E2_ISS
							nPccPa	+= SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
							nIrPa		+= If(SE2->E2_VRETIRF>0,SE2->E2_VRETIRF,SE2->E2_IRRF)
							nVrPa		+= SE2->E2_VALOR
						Endif
					Endif
				Next
				RestArea(aAreaSe2)
				SE2->(dbGoto(nSE2Reg))
			Endif
		Endif
		//Se considera valores de multa juros desconto ou se a validação partiu do campo de valor
		If lJurMulDes .OR. lAltValor
			nBaseImp := nValPgto + nValComp
			//Verificar se o valor do pagamento eh realmente diferente do valor do saldo do titulo, para confirma oper. de baixa parcial
			If VALTYPE(__ReadVar)=="C" .and. __ReadVar$"nMulta#nDescont#nJuros#nValPgto#nVA".and.lJurMulDes
				// *************************************************************
				// Bloco novo utilizado somente para o calculo do campo Multa *
				// *************************************************************
				If SE2->E2_SALDO  - nValPgto <= 0 .and. !lAltValor
					nBaseImp := nValPgto - (nDescont-nTotAbat-nDecresc) + Iif(!lAltPgto,(nJuros+nVA+nMulta+nAcresc),-(nJuros+nVA+nMulta+nAcresc))
				EndIf
			Else
				// *******************************************************
				// Bloco Antigo não tirado para evitar incopatibilidade *
				// *******************************************************
				lAltValor := Str(nValPgto-nDescont-nTotAbat+nJuros+nVA+nMulta+nAcresc-nDecresc,17,2) # Str(nOldValPgto,17,2)
				If lAltValor .and. lJurMulDes
					//Caso seja uma baixa parcial, alterar a base de calculo do PCC, para acrescentar os impostos
					nBaseImp := nValPgto+nDescont-nJuros-nVA-nMulta-nAcresc+nDecresc
				Endif
			EndIf
		Else
			If !lAltdesc .and. !lAltMulta .and. !lAltJuros .And. !lAltJurLt           // NESTE PONTO FICA NVLPAGTO E BASEIMP = 7760
				nBaseImp := nValPgto+nDescont+nTotAbat-nJuros-nVA-nMulta-nAcresc+nDecresc
			Else
				If cFunName=="FINA080" .or. FwIsInCallStack("FINA080")
					nBaseImp := nValPgto+nTotAbat
				Else
					nBaseImp := nValPgto+nTotAbat-nJuros-nVA-nMulta-nAcresc+nDecresc
				Endif
			EndIf
		Endif

		//Reestruturacao SE5 - Não usar para mais nada (Pequim)
		//Base de calculo
		nBaseCalc := nBaseImp

		lImpInFat := .F.

		If 'NOTFAT' $ SE2->E2_FATURA
			nValOutImp := f080OutImp(nValPgto)
			lImpInFat := .T.
		Else
			nValOutImp := Iif(!lInssBx,SE2->E2_INSS,0)
		Endif

		If !lImpInFat
			If lSest
				nValOutImp += SE2->E2_SEST
			Endif

			If !lCalcIssBx
				nValOutImp += SE2->E2_ISS
			Endif

			If !lIRPFBaixa
				nValOutImp += SE2->E2_IRRF
			EndIf

		Endif

		//Verificação para diferenciar se for baixa parcial
		lAltBxVal := STR(SE2->E2_VALOR,17,2) != STR(SE2->E2_SALDO,17,2)

		nTotDif := (nDescont + nTotAbat + nDecresc) - (nJuros + nVA + nMulta + nAcresc)

		If (!lAltValor .Or. (lAltValor .And. nValPgto + nTotDif == SE2->E2_SALDO)) .And. (!lAltData .Or. nValPgto == SE2->E2_SALDO)
			If Len(aDocumen) > 0 .And. lPABruto .And. Len(aNf) == 1
				nBaseImp += Iif(nVrPa >= SE2->E2_VALOR ,nValOutImp ,0)
			Else
				If 'NOTFAT' $ SE2->E2_FATURA .and. !(lCalcIssBx .and. lIRPFBaixa)
					nBaseImp += nValOutImp + Iif(!lPropPa,If(!lValPgto,aDadosRet[7],0) + aDadosImp[4] - aDadosImp[5],0) + nValComp
				ElseIf !('NOTFAT' $ SE2->E2_FATURA)
					nBaseImp += nValOutImp + Iif(!lPropPa,If(!lValPgto,aDadosRet[7],0) + aDadosImp[4] - aDadosImp[5],0) + nValComp
				EndIf
				If lNfComp
					nBaseImp -=	 Iif(nIssComp>0,nIssComp,0)
				Endif
			Endif

			//Se o titulo tiver impostos e foi gerado por uma fatura e nao teve baixa parcial
			If lImpInFat .and. SE2->E2_BASEPIS > 0 .and. SE2->E2_SALDO == SE2->E2_VALOR
				nBaseImp := SE2->E2_BASEPIS
				lImpInFat := .F.
			Endif

		Endif

		//Se for pa bruto e tiver baixado o valor dos impostos de um PA do titulo,
		//busco o valor no SE5 para recompor a base.
		If lPABruto .And. Len(aDocumen) > 0
			nImpPaBrt   := PABrtComp()
			nBaseImp    += nImpPaBrt
		EndIf

		//Caso o titulo possua o valor de base dos impostos preenchidos, considero
		//esse valor com base para calculo, desprezando o valor da nota fiscal
		If SE2->E2_MOEDA == 1
			If 'NOTFAT' $ SE2->E2_FATURA .and. !(lCalcIssBx .or. lIRPFBaixa)
				nValTit := SE2->E2_VALOR + nValOutImp		//valor bruto do titulo reconstituido (valor + outros impostos)
			ElseIf !('NOTFAT' $ SE2->E2_FATURA)
				nValTit := SE2->E2_VALOR + nValOutImp		//valor bruto do titulo reconstituido (valor + outros impostos)
			Elseif 'NOTFAT' $ SE2->E2_FATURA .and. (lCalcIssBx .or. lIRPFBaixa)
				nValTit := SE2->E2_BASEPIS
			EndIf
		Else
			nValTit := SE2->E2_VLCRUZ + nValOutImp		//valor bruto do titulo reconstituido (valor + outros impostos)
		Endif

		If SE2->E2_BASEPIS > 0
			nProp := SE2->E2_BASEPIS/nValtit				//Proporcao entre a base e o valor bruto do titulo
			nValTit := SE2->E2_BASEPIS
			If !( (lAltdesc .or. lAltMulta) .and. (lJurMulDes)) .and.;
			(	!lAltValor .And. !lAltData .And. ;
			(nValPgto <> SE2->E2_SALDO-nDescont-nTotAbat) .And.;
			(nValPgto <> SE2->(E2_SALDO-E2_DECRESC-nTotAbat)) .And.;
			!(lFina450 .And. Type("lF080Auto")<>"U" .And. lF080Auto .And. lPCCBaixa)) //se nValPgto e SE2->E2_SALDO são iguais, significa que está fazendo a baixa do resíduo do título
				//então n pode considerar o valor total incluso no E2_BASEPIS, mas sim o valor proporcional
				nBaseImp := SE2->E2_BASEPIS				          //Base liquida para calculo dos impostos
			ElseIf !lAltValor .And. (nBaseImp == SE2->E2_SALDO+nValOutImp .or.;
			IIf((SE2->E2_BAIXA <> CTOD("  /  /  ") .and. SE2->(E2_IRRF+If(!lInssBx,E2_INSS,0)+E2_ISS) > 0) .or. lImpInFat , ;
			nBaseImp == SE2->E2_SALDO+nValOutImp,.F.))
				nBaseImp 	:= nBaseImp + If(lNfComp,SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL),0)

				If lIRPFBaixa .And. (lValPgto .Or. lAltBxVal)
					If (lValPgto .And. aDadosImp[4]> 0) .Or. !lValPgto
						nBaseImp += SE2->E2_VRETIRF
					Endif
				Endif
				If lCalcIssBx
					If (lValPgto .And. aDadosImp[4]> 0) .Or. !lValPgto
						nBaseImp += SE2->E2_VRETISS
					Endif
				Endif

				If lInssBx .And. lAltBxVal .And. nBaseImp < SE2->E2_SALDO //Não devo somar na baixa total ou baixa restante do titulo.
					If !(lInsPub .And. SE2->E2_TIPO $ MVPAGANT+"/INA") //PA de Inss Baixa Empresa Publica
						nBaseImp += SE2->E2_VRETINS
					Endif
				Endif
				nBaseImp := nBaseImp  * If(lJurMulDes,1,nProp)

			Else
				nBaseImp	:= nBaseImp
			EndIf
			If lPABruto .And. lValPgto
				nBaseImp += nImpPaBrt
			EndIf
		Else
			nProp := 1
			If !lAltValor .and. !lJurMulDes
				nBaseImp := nValTit 				//Base liquida para calculo dos impostos
				//Se for pa bruto e tiver baixado o valor dos impostos de um PA do titulo,
				//busco o valor no SE5 para recompor a base.
				If lPABruto .And. lValPgto
					nBaseImp += nImpPaBrt
				EndIf
			Else
				If !lAltValor .and. lJurMulDes .and. nBaseImp == SE2->E2_SALDO
					nBaseImp 	:= nBaseImp + If(!lValPgto,SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL),0)
				Else
					nBaseImp	:= nBaseImp
				EndIf
			EndIf
		Endif

		If lAltValor
			nBaseOrig := nValTit
		Else
			nBaseOrig := nBaseImp
		Endif

		//Procura pelas baixas deste titulo caso seja baixa parcial e esteja baixando em mes diferente
		If lAltBxVal .and. lAltValor
			aBaixa := Sel080Baixa("VL /BA /CP /",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,@nTotAdto,@lBaixaAbat,SE2->E2_FORNECE,SE2->E2_LOJA,@lBxCec,.F.,@lNotBax,@nTotImpost,@lAglImp,.T.,,,,,SE2->E2_FILORIG)
			For nY := 1 to Len(aBaixaSE5)
				If (!lJurMulDes .And. !aBaixaSE5[nY][4] $ MVPAGANT) .Or. (lJurMulDes .And. aBaixaSE5[nY][21] == "CP")
					nBaixaParc += ((aBaixaSE5[nY][8] * Iif(aBaixaSE5[nY][21] != "CP", nProp,1)) + If(lValPgto, If(!(aBaixaSE5[nY][18] $ '1#5#2') ,aBaixaSE5[nY][15],0)+If(!(aBaixaSE5[nY][19] $ '1#5#2'),aBaixaSE5[nY][16],0)+If(!(aBaixaSE5[nY][20] $ '1#5#2'),aBaixaSE5[nY][17],0),0))
				EndIf
			Next
		EndIf

		If lAltValor
			If !lJurMulDes
				nBaseOrig -= nBaixaParc
			EndIf
			If lF080Auto .and. (Type("l450")<>"U" .and. !l450)
				nBaseImp := nPgtoAuto
			Endif
			nBaseImp := nBaseImp * nProp
		Else
			nBaseImp := (nBaseImp - nBaixaParc) * Iif(lJurMulDes,nProp,1)
		Endif

		nBaseImp := Iif(nBaseImp > nBaseOrig .And. !lJurMulDes, nBaseOrig, nBaseImp)

		If (!lAltValor .And. lAltData .And. nValPgto <> SE2->E2_SALDO) .And. !lImpInFat
			nBaseImp += nValOutImp
		Endif

		//Base diferenciada para calculo dos impostos
		nBaseRet := nBaseImp += nValComp

		//Se for fatura, a base de impostos deve considerar o somatorio dos outros impostos
		//para verificacao do valor acima de 5000.
		//Isto já eh feito normalmente para os titulos nao gerados por fatura
		If lImpInFat
			If !('NOTFAT' $ SE2->E2_FATURA) .or. ('NOTFAT' $ SE2->E2_FATURA .and. !(lCalcIssBx .or. lIRPFBaixa))
				nBaseRet += nValOutImp
			EndIf
		Endif

		If Len(aDocumen) > 0 .And. lPABruto
			If !lCalcIssBx .And. nIssPa > 0 .And. Len(aNf) == 1
				If nIssPa > SE2->E2_ISS
					nBaseImp -= nIssPa
					nBaseImp += (nIssPa-SE2->E2_ISS)
				ElseiF nIssPa < SE2->E2_ISS
					nBaseImp += (SE2->E2_ISS-nIssPa)
				Endif
			Endif
			nBaseImp += If(lIRPFBaixa,nIrPa,0)
			nBaseImp += If(lPccBaixa,nPccPa,0)
		Endif

		//PIS
		If SE2->E2_PIS > 0
			If cFormClcPCC == "1" // Recalcula sempre o imposto
				If SE2->E2_MOEDA > 1
					nBaseImp:= nValTit*nTxmoeda
				EndIf
				nPis := Round(( nBaseImp * SE2->E2_PIS ) / nValTit ,2)
				//Verifico possiveis problemas de arredondamento
				If ABS(SE2->E2_PIS - (aDadosRet[2] + aValorBx[1] + nPis)) == 0.01
					nPis += (SE2->E2_PIS - (aDadosRet[2] + aValorBx[1] + nPis)	)
				EndIf
				//Reestruturacao SE5 - Não utilizar para mais nada (Pequim)
				nPisCalc  := nPis
				nPisBaseC  := nBaseImp

				If (aDadosImp[1] <> 0 .And. If(!lTitBor .And. !lNfComp, ROUND(aDadosImp[1],2) <> ROUND(aDadosRet[2],2) .And. SE2->E2_SALDO > 0, SE2->E2_SALDO > 0) .And.;
				(!lJurMulDes .Or. (lJurMulDes .and. SE2->E2_SALDO == SE2->E2_VALOR))) .Or.;
				(!lJurMulDes .and. SE2->E2_SALDO <> SE2->E2_VALOR .And. aValorBx[1] > 0) .And. !lAltValor .And. Len(aDocumen) = 0
					//Necessario que este elemento aDadosImp[1] seja arredondado pq o nPis foi arredondado anteriormente senao calcula valor incorreto.
					nPis += Iif(lNfComp,Round(aDadosRet[2],2),Iif(aDadosImp[1]>0,Iif(lJurMulDes,Round(aDadosImp[1],2),NoRound(aDadosImp[1],2)),0))
					If nPis < 0
						nPis := 0
					EndIf
				EndIf
			ElseIf cFormClcPCC == "2" .and. SE2->E2_VALOR == SE2->E2_SALDO // Considera valor do título a pagar
				nPis := SE2->E2_PIS
				//Reestruturacao SE5 - Não utilizar para mais nada (Pequim)
				nPisCalc := nPis
				nPisBaseC := SE2->E2_BASEPIS
			EndIf
		EndIf

		// COFINS
		If SE2->E2_COFINS > 0
			If cFormClcPCC == "1" // Recalcula sempre o imposto
				If SE2->E2_MOEDA > 1
					nBaseImp:= nValTit*nTxmoeda
				EndIf
				nCofins := Round(( nBaseImp * SE2->E2_COFINS ) / nValTit ,2)
				//Verifico possiveis problemas de arredondamento
				If ABS(SE2->E2_COFINS - (aDadosRet[3] + aValorBx[2] + nCofins)) == 0.01
					nCofins += SE2->E2_COFINS - (aDadosRet[3] + aValorBx[2] + nCofins)
				EndIf
				//Reestruturacao SE5 - Não utilizar para mais nada (Pequim)
				nCofCalc := nCofins
				nCofBaseC := nBaseImp

				If (aDadosImp[2] <> 0 .And. If(!lTitBor .And. !lNfComp, ROUND(aDadosImp[2],2) <> ROUND(aDadosRet[3],2) .And. SE2->E2_SALDO > 0, SE2->E2_SALDO > 0) .And. ;
				(!lJurMulDes .or. (lJurMulDes .and. SE2->E2_SALDO == SE2->E2_VALOR))) .Or.;
				(!lJurMulDes .and. SE2->E2_SALDO <> SE2->E2_VALOR .And. aValorBx[2] > 0) .And. !lAltValor .And. Len(aDocumen) = 0
					//Necessario que este elemento aDadosImp[2] seja arredondado pq o nCofins foi arredondado anteriormente senao calcula valor incorreto.
					
					If (!lNfComp .And. aDadosImp[2] > 0) .Or. lNfComp
						nCofins += Iif(lNfComp,Round(aDadosRet[3],2),Round(aDadosImp[2],2))
					EndIf

					If nCofins < 0
						nCofins := 0
					EndIf
				EndIf
			ElseIf cFormClcPCC == "2" .and. SE2->E2_VALOR == SE2->E2_SALDO // Considera valor do título a pagar
				nCofins := SE2->E2_COFINS
				//Reestruturacao SE5 - Não utilizar para mais nada (Pequim)
				nCofCalc := nCofins
				nPisBaseC := SE2->E2_BASECOF
			EndIf
		EndIf

		// CSLL
		If SE2->E2_CSLL > 0
			If cFormClcPCC == "1" // Recalcula sempre o imposto
				If SE2->E2_MOEDA > 1
					nBaseImp:= nValTit*nTxmoeda
				EndIf
				//Verifico possiveis problemas de arredondamento
				nCsll := Round(( nBaseImp * SE2->E2_CSLL ) / nValTit ,2)
				If ABS(SE2->E2_CSLL - (aDadosRet[4] + aValorBx[3] + nCsll)) == 0.01
					nCsll += SE2->E2_CSLL - (aDadosRet[4] + aValorBx[3] + nCsll)
				EndIf
				//Reestruturacao SE5 - Não utilizar para mais nada (Pequim)
				nCslCalc := nCsll
				nCslBaseC := nBaseImp

				If (aDadosImp[3] <> 0 .And. If(!lTitBor .And. !lNfComp,ROUND(aDadosImp[3],2) <> ROUND(aDadosRet[4],2) .And. SE2->E2_SALDO > 0,SE2->E2_SALDO > 0)  .And.;
				(!lJurMulDes .or. (lJurMulDes .and. SE2->E2_SALDO == SE2->E2_VALOR))) .Or.;
				(!lJurMulDes .and. SE2->E2_SALDO <> SE2->E2_VALOR .And. aValorBx[3] > 0)  .And. !lAltValor .And. Len(aDocumen) = 0
					//Necessario que este elemento aDadosImp[3] seja arredondado pq o nCsll foi arredondado anteriormente senao calcula valor incorreto.
					If (!lNfComp .And. aDadosImp[3] > 0) .Or. lNfComp
						nCsll += Iif(lNfComp,Round(aDadosRet[4],2),Round(aDadosImp[3],2))
					EndIf
		
					If nCsll < 0
						nCsll := 0
					EndIf
				EndIf
			ElseIf cFormClcPCC == "2" .and. SE2->E2_VALOR == SE2->E2_SALDO // Considera valor do título a pagar
				nCsll := SE2->E2_CSLL
				//Reestruturacao SE5 - Não utilizar para mais nada (Pequim)
				nCslCalc := nCsll
				nCslBaseC := SE2->E2_BASECSL
			EndIf
		EndIf
	Else
		SED->(dbSetOrder(1))
		SED->(MsSeek(xFilial("SED")+M->E2_NATUREZ))
		SA2->(dbSetOrder(1))
		SA2->(MsSeek(xFilial("SA2")+M->E2_FORNECE+M->E2_LOJA))

		//Se considera valores de multa juros desconto ou se a validação partiu do campo de valor
		If lJurMulDes .or. lAltValor
			nBaseImp := nValPgto
		Else
			If (Type("nDescont") = "U")
				nDescont := 0
			Endif
			If (Type("nJuros") = "U")
				nJuros := 0
			Endif
			If (Type("nMulta") = "U")
				nMulta := 0
			Endif
			If (Type("nAcresc") = "U")
				nAcresc := 0
			Endif
			If (Type("nDecresc") = "U")
				nDecresc := 0
			Endif

			// Valores acessórios.
			If (Type("nVA") = "U")
				nVA := 0
			Endif

			nBaseImp := nValPgto+nDescont+nTotAbat-nJuros-nVA-nMulta-nAcresc+nDecresc
		Endif

		lImpInFat := .F.

		If 'NOTFAT' $ M->E2_FATURA
			nValOutImp := f080OutImp(nValPgto)
			lImpInFat := .T.
		Else
			nValOutImp := M->(E2_IRRF+E2_ISS)
			nValOutImp += Iif(!lInssBx,M->E2_INSS,0)
		Endif

		If !lImpInFat
			If lSest
				nValOutImp += M->E2_SEST
			Endif

			If !lCalcIssBx
				nValOutImp += M->E2_ISS
			Endif

			If !lIRPFBaixa
				nValOutImp += M->E2_IRRF
			EndIf
		Endif

		If M->E2_BASEPIS > 0
			nValTit := M->E2_BASEPIS
		Else
			nValTit := M->E2_VALOR + nValOutImp
		Endif

		If !M->E2_TIPO $ MVPAGANT
			nBaseImp := nBaseImp - nValOutImp
		Endif

		If !lAltValor
			nBaseImp += nValOutImp + aDadosRef[7]
		Endif

		//Base diferenciada para calculo dos impostos
		nBaseRet := nBaseImp
		If lBaseSE2
			If M->E2_BASEPIS > 0
				nBaseRet := (M->E2_BASEPIS * nBaseImp) / nValTit
			Endif
		Endif
		//Se for fatura, a base de impostos deve considerar o somatorio dos outros impostos
		//para verificacao do valor acima de 5000.
		//Isto já eh feito normalmente para os titulos nao gerados por fatura
		If lImpInFat
			nBaseRet += nValOutImp
		Endif

		//PIS
		If M->E2_PIS > 0
			nPis := ( nBaseImp * M->E2_PIS ) / nValTit

			//Reestruturacao SE5 - Não utilizar para mais nada (Pequim)
			nPisCalc := nPis
			nPisBaseC := nBaseImp

			If !lAltValor .And. cNCCRet == "2" .And. NoRound(aDadosImp[1],2) <> NoRound(aDadosRet[2],2) .And.	SE2->E2_SALDO > 0
				nPis += If (aDadosImp[1] > 0, aDadosImp[1], 0)
				If nPis < 0
					nPis := 0
				EndIf
			EndIf
		EndIf

		// COFINS
		If M->E2_COFINS > 0
			nCofins := ( nBaseImp * M->E2_COFINS ) / nValTit

			//Reestruturacao SE5 - Não utilizar para mais nada (Pequim)
			nCofCalc := nCofins
			nCofBaseC := nBaseImp

			If !lAltValor .And. cNCCRet == "2" .And. NoRound(aDadosImp[2],2) <> NoRound(aDadosRet[3],2) .And. SE2->E2_SALDO > 0
				nCofins += If (aDadosImp[2] > 0, aDadosImp[2], 0)
				If nCofins < 0
					nCofins := 0
				EndIf
			EndIf
		EndIf

		// CSLL
		If M->E2_CSLL > 0
			nCsll := ( nBaseImp * M->E2_CSLL ) / nValTit

			//Reestruturacao SE5 - Não utilizar para mais nada (Pequim)
			nCalcCsl  := nCsll
			nCofBaseC := nBaseImp

			If !lAltValor .And. cNCCRet == "2" .And. NoRound(aDadosImp[3],2) <> NoRound(aDadosRet[4],2) .And. SE2->E2_SALDO > 0
				nCsll += If (aDadosImp[3] > 0, aDadosImp[3], 0)
				If nCsll < 0
					nCsll := 0
				EndIf
			EndIf
		EndIf

	Endif

	//se estiver fazendo uma baixa parcial
	If aDadosRet[1] > 0
		//se estiver considerando baixas de outros titulos
		//tem que tirar o INSS e IR referente aos titulos que estao considerando (anteriores)
		If lTBxOTits
			aDadosRet[1] -= (nINSSAnts + nIRAnts)
		ElseIF SE2->E2_SALDO > nValPgto
			//se não estiver considerando baixas de outros titulos
			//tem que tirar o INSS e IR referente ao titulo atual
			aDadosRet[1] -= SE2->E2_IRRF
			If !lInssBx
				aDadosRet[1] -= SE2->E2_INSS
			Endif
		EndIf
	EndIf

	//Verifico o valor a reter
	If lContrRet
		//Nao retem Pis,Cofins,CSLL
		If cModRetPis == "3"  //Nao retem PIS
			nVlRetPis := nPis
			nVlRetCof := nCofins
			nVlRetCsl := nCsll
			nPis := 0
			nCofins := 0
			nCsll := 0
		Else
			//Calculo do Sistema
			IF cModRetPis == "1"
				If aDadosRet[1]+ (nBaseRet) <= nVlMinImp .and. lAplVlMin
					nVlRetPis := nPis
					nVlRetCof := nCofins
					nVlRetCsl := nCsll
					nPis := 0
					nCofins := 0
					nCsll := 0
					aDadosRet[2] := 0
					aDadosRet[3] := 0
					aDadosRet[4] := 0
				Endif
			Endif

			If nPis+nCofins+nCsll+nIrrf+ aDadosRet[2]+ aDadosRet[3]+ aDadosRet[4] > 0

				If nPis+nCofins+nCsll+aDadosRet[2]+ aDadosRet[3]+ aDadosRet[4] > 0
					//Para esse caso, os valores já vêm somados das linhas 11678, 11696 e 11714(Fonte 226 de 9/set).
					// Por isso nao deve fazer a soma novamente
					If !(ROUND(aDadosImp[3],2) <> ROUND(aDadosRet[4],2) .And. SE2->E2_SALDO > 0  .And.;
						(!lJurMulDes .or. (lJurMulDes .and. SE2->E2_SALDO == SE2->E2_VALOR)))  .And. ;
						(Empty(cDocumen) .Or. (!Empty(cDocumen) .And. lPropPA .And. lPrImPA )) .And.;
						nPccBx >= 0 .And. !lTemDadosBor

						nVlRetPis := nPis
						nVlRetCof := nCofins
						nVlRetCsl := nCsll

						nTotPis += SE2->E2_PIS
						nTotCsl += SE2->E2_CSLL
						nTotCof += SE2->E2_COFINS

						//Em caso de titulo parcelado e com impostos no mesmo valor era calculado somente sobre o valor de uma parcela.
						nPis    := nVlRetPis + Iif(nTotPis <> SE2->E2_PIS,aDadosRet[2], 0)
						nCofins := nVlRetCof + Iif(nTotCof <> SE2->E2_COFINS,aDadosRet[3], 0)
						nCsll   := nVlRetCsl + Iif(nTotCsl <> SE2->E2_CSLL,aDadosRet[4], 0)

						//Empresa Pública
						If lEmpPub .and. lAplMinP .and. nPis+nCofins+nCsll+nIrrf+aDadosRet[2]+ aDadosRet[3]+ aDadosRet[4] <= nVlMPub
							nPis := 0
							nCofins := 0
							nCsll := 0
						Endif

					EndIf
				Endif
				nValorPg := nValPgto - nPis - nCofins - nCsll - nIrrf - nIss

				If nValorPg < 0
					nValorPg += nPis + nCofins + nCsll // deixa descontado valor de IR e ISS para realizar a proporcao somente para o PCC

					nTotARet := nPis + nCofins + nCsll + nIrrf + nIss

					nDiferImp := nValorPg - nTotARet

					If nDiferImp < 0
						nFatorRed := 1 - ( Abs( nDiferImp ) / nTotARet )
						nPis  := NoRound( nPis * nFatorRed, 2 )
						nCofins := NoRound( nCofins * nFatorRed, 2 )
						nCsll := nValorPg - ( nPis + nCofins + nIrrf )
					Endif
				EndIf
			Else
				//Natureza nao calculou Pis/Cofins/Csll
				aDadosRet[1] := 0
			Endif
		Endif
	Endif

	SE2->( RestArea( aAreaSE2 ) )

	// tratamento que substitui o calculo de PCC quando houve retenção com proporcionalização
	If lPrImPA .and. SE2->E2_VALOR> SE2->E2_SALDO .AND. (SE2->E2_PRETPIS =="7" .OR. SE2->E2_PRETCOF =="7" .OR. SE2->E2_PRETCSL =="7").and. SE2->E2_BASEPIS> nVlMinImp
		nPis:= SE2->E2_PIS - SE2->E2_VRETPIS
		nCofins:= SE2->E2_COFINS - SE2->E2_VRETCOF
		nCsll := SE2->E2_CSLL - SE2->E2_VRETCSL

	EndIf
	If !lAltValor .or. lAltData .or. lValPgto
		nValPgto -= nPis+nCofins+nCsll+nIrrf+nIss
		If nValPgto == 0 //O valor dos impostos foi igual ao valor da baixa
			If nPis > 0.01
				nValPgto := 0.01
				nPis -= 0.01
			EndIf
		EndIf
	Endif

	nOldValPgto := nValPgto
	nOldPis		:= nPis
	nOldCofins	:= nCofins
	nOldCsll	:= nCsll
	nOldIrrf	:= nIrrf

	//Reestruturacao SE5 - Não utilizar para mais nada (Pequim)
	//Revisar a cumulatividade de base (nBaseRet)
	If lEmpPub 
		nTotARet := If(!_lPccMR, (nPis+nCofins+nCsll), 0) + If(!_lIrfMR, nIrrf, 0)
		If nTotARet > nVlMPub .or. !lAplMinP
			nPisBaseR := If (nPis > 0   , nBaseRet, 0)
			nCofBaseR := If (nCofins > 0, nBaseRet, 0)
			nCslBaseR := If (nCsll > 0 	, nBaseRet, 0)
		Else
			//Empresa Pública
			If lAplMinP .and. nPis+nCofins+nCsll+nIrrf+aDadosRet[2]+ aDadosRet[3]+ aDadosRet[4] <= nVlMPub
				nPis := 0
				nCofins := 0
				nCsll := 0
			Else
				nPisBaseR := If (nPis > 0   , nBaseRet, 0)
				nCofBaseR := If (nCofins > 0, nBaseRet, 0)
				nCslBaseR := If (nCsll > 0 	, nBaseRet, 0)
			Endif
		Endif
	Else
		If nCsll > 0
			nPisBaseR   := nCsll * 100
			nCofBaseR   := nCsll * 100
			nCslBaseR   := nCsll * 100
		Else
			nPisBaseR   := (nCofins * 100) / 3
			nCofBaseR   := nPisBaseR
			nCslBaseR   := 0
		Endif
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} FGerCredRt
Gera titulo de Credito para fornecedor no caso de retencao seja menor do que zero

@param nValtot Alias Valor do Titulo 
@param nMoeda Moeda do Titulo
@param cSeq Sequencia de baixa 

@Return NIL
@author Mauricio Pequim
@since 20/10/2004
/*/
//-------------------------------------------------------------------
Function FGerCredRt(nValtot,nMoeda,cSeq)

    ADupCredRt(nValtot,"501",nMoeda,.T.)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} FImpDelTit
Funcao que traz os registros do titulo aglutinador

@param cAlias Alias do registro  do titulo principal SE5
@param cPrefixo 
@param cNumero
@param cParcela
@param cTipo 
@param cClifor
@param cLoja
@param cSeq Sequencia da Baixa

@Return NIL
@author Eduardo Riera
@since 11/08/2003
/*/
//-------------------------------------------------------------------
Function FImpDelTit(cAlias,cPrefixo,cNumero,cParcela,cTipo,cCliFor,cLoja,cSeq)

	Local aRecnos  := {}
	Local aArea    := GetArea()
	Local aAreaSE5 := SE5->(GetArea())
	Local lMultFil:= .F.

	//--- Tratamento Gestao Corporativa
	Local lGestao   := Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
	//
	Local cFilFwSE5 := IIF( lGestao, FwFilial("SE5") , xFilial("SE5") )

	Local lQuery    := .F.
	Local cQuery    := ""
	Local cAliasSFQ := ""
	Local lAddRec := .T.

	lMultFil:= .T.

	cAliasSFQ := "SFQQUERY"

	lQuery := .T.

	cQuery := "SELECT SE5.R_E_C_N_O_ RECTIT,E5_FILIAL "

	If lMultFil
		cQuery += ",FQ_FILDES"
	Endif

	cQuery += " FROM "
	cQuery += RetSqlName("SE5") + " SE5, "
	cQuery += RetSqlName("SFQ") + " SFQ "
	cQuery += " WHERE "

	If !lMultFil
		cQuery += "E5_FILIAL  = '"+xFilial("SE5")+"' AND "
	Endif

	cQuery += "E5_PREFIXO = FQ_PREFDES AND "
	cQuery += "E5_NUMERO  = FQ_NUMDES  AND "
	cQuery += "E5_PARCELA = FQ_PARCDES AND "
	cQuery += "E5_TIPO    = FQ_TIPODES AND "
	cQuery += "E5_CLIFOR  = FQ_CFDES   AND "
	cQuery += "E5_LOJA    = FQ_LOJADES AND "
	cQuery += "E5_SEQ 	 = FQ_SEQDES  AND "
	cQuery += "SE5.D_E_L_E_T_ = ' '    AND "

	cQuery += "FQ_FILIAL  = '"+xFilial("SFQ")+"' AND "
	cQuery += "FQ_ENTORI  = '"+ cAlias+   "' AND "
	cQuery += "FQ_PREFORI = '"+ cPrefixo+ "' AND "
	cQuery += "FQ_NUMORI  = '"+ cNumero+  "' AND "
	cQuery += "FQ_PARCORI = '"+ cParcela+ "' AND "
	cQuery += "FQ_TIPOORI = '"+ cTipo+ "'    AND "
	cQuery += "FQ_CFORI   = '"+ cCliFor+ "'  AND "
	cQuery += "FQ_LOJAORI = '"+ cLoja+ "'    AND "
	cQuery += "FQ_SEQORI  = '"+ cSeq + "' AND "
	cQuery += "SFQ.D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSFQ,.T.,.T.)

	While (cAliasSFQ)->(!Eof())
		lAddRec := .T.

		If lMultFil
			If !Empty( cFilFwSE5 )     // !Empty(xFilial("SE5"))
				If Empty((cAliasSFQ)->FQ_FILDES)
					lAddRec := (xFilial("SE5") == (cAliasSFQ)->E5_FILIAL)
				Else
					lAddRec := ((cAliasSFQ)->E5_FILIAL == (cAliasSFQ)->FQ_FILDES)
				Endif
			Else
				lAddRec := (xFilial("SE5") == (cAliasSFQ)->E5_FILIAL)
			Endif
		Endif

		If lAddRec
			Aadd(aRecnos,(cAliasSFQ)->RECTIT)
		Endif

		(cAliasSFQ)->(dbSkip())

	EndDo

	If lQuery
		dbSelectArea(cAliasSFQ)
		dbCloseArea()
		dbSelectArea("SFQ")
	EndIf

	RestArea(aAreaSE5)
	RestArea(aArea)

Return(aRecnos)

//-------------------------------------------------------------------
/*/{Protheus.doc} FImpDelSFQ
Funcao que exclui os registro s de relacionamento de titulos

@param cAlias Alias do registro  do titulo principal SE5
@param cPrefixo 
@param cNumero
@param cParcela
@param cTipo 
@param cClifor
@param cLoja
@param cSeq Sequencia da Baixa

@Return NIL
@author Eduardo Riera
@since 11/08/2003
/*/
//-------------------------------------------------------------------
Function FImpDelSFQ(cAlias,cPrefixo,cNumero,cParcela,cTipo,cCliFor,cLoja,cSeq)
	Local aArea 		:= GetArea()
	Local aAreaSe1		:= SE1->(GetArea())
	Local aAreaSe5		:= SE5->(GetArea())

	SFQ->(dbSetOrder(1))
	If SFQ->(MsSeek(xFilial("SFQ")+cAlias+cPrefixo+cNumero+cParcela+cTipo+cClifor+cLoja))
		While SFQ->(!Eof()) .And. SFQ->FQ_FILIAL == xFilial("SFQ") .And.;
		SFQ->FQ_ENTORI == cAlias    .And. ;
		SFQ->FQ_PREFORI == cPrefixo .And.;
		SFQ->FQ_NUMORI  == cNumero  .And.;
		SFQ->FQ_PARCORI == cParcela .And. ;
		SFQ->FQ_TIPOORI == cTipo    .And. ;
		SFQ->FQ_CFORI   == cCliFor  .And.;
		SFQ->FQ_LOJAORI == cLoja

			If FwIsInCallStack("FA070CAN") .AND. FwIsInCallStack("FINA061")
				FDelSFQCR(1,cAlias,cPrefixo,cNumero,cParcela,cTipo,cCliFor,cLoja,cSeq)
			Endif
			If	SFQ->FQ_SEQORI == cSeq
				RecLock("SFQ",.F.)
				SFQ->(dbDelete())
				MsUnlock()
			Endif
			SFQ->(dbSkip())
		EndDo
	Endif

	If FwIsInCallStack("FA070CAN") .AND. FwIsInCallStack("FINA061") //Para titulos que foram baixados e possuam bordero.
		FDelSFQCR(2,cAlias,cPrefixo,cNumero,cParcela,cTipo,cCliFor,cLoja,cSeq)
	Endif

	RestArea(aArea)
	RestArea(aAreaSe1)
	RestArea(aAreaSe5)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} FDelTxBx
Deleta titulos de imposto Pis Cofins Csll gerados na baixa

@author Mauricio Pequim Jr
@since 20/10/2004
/*/
//-------------------------------------------------------------------
Function FDelTxBx(cPrefixo,cNumero,cParcela,cTipo,cCliFor,cLoja,cSeq,cParcPis,cParcCof,cParcCsl)

	Local aArea	:= SE2->(GetArea())
	Local aAreaSA2	:= SA2->(GetArea())
	Local cForUniao := ""
	Local cLojUniao := ""
	Local cChaveImp := ""
	Local cNatPis 	:= GetMv("MV_PISNAT",.F.,"PIS")
	Local cNatCof	:= GetMv("MV_COFINS",.F.,"COF")
	Local cNatCsl	:= GetMv("MV_CSLL",.F.,"CSL")
	Local nRegSe2	:= SE2->(RECNO())
	Local lF241Nat := ExistBlock("F241NAT")
	Local nX
	Local cLojaUni:= Replicate("0",Len(SA2->A2_LOJA))

	Local cNaturs := ""
	Local cNatIrf	:= &(GetMv("MV_IRF"))
	Local lIRPFBaixa :=		IIf( cPaisLoc == "BRA" , SA2->A2_CALCIRF == "2", .F.) .And. ;
	!SE2->E2_TIPO $ MVPAGANT


	Local cTitPai := Pad(cPrefixo+cNumero+cParcela+cTipo+cCliFor+cLoja,TamSx3("E2_TITPAI")[1])
	// ****************************
	// Utilizado para integração *
	// com SIGAPCO               *
	// ****************************
	Local aRecPCO := {}
	Local lAtuSldNat := .T.
	Local lExistFJU := FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")
	Local nRecBkp := 0

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lIntPFS	:= SuperGetMv("MV_JURXFIN",.T.,.F.)

	If ( cPaisLoc == "BRA" )
		// Nao permitir a exclusao do titulo caso a baixa
		// cancelada seja a do Tx (imposto).
		If !(cTipo $ MVTXA+"/"+MVTAXA)
			DbSelectArea("SA2")
			SA2->(DbSetOrder(1))
			SA2->(MsSeek(xFilial("SA2")+GetMv("MV_UNIAO")+Space(Len(SA2->(A2_COD))-Len(GetMv("MV_UNIAO")))+cLojaUni))
			cForUniao	:= SA2->A2_COD
			cLojUniao	:= SA2->A2_LOJA

			dbSelectArea("SE2")
			SE2->(dbSetOrder(1))

			//Abro o SE2 com outro alias pois pode estar filtrado pela
			//Baixa por lote
			If Select("__SE2") == 0
				ChkFile("SE2",.F.,"__SE2")
			Else
				DbSelectArea("__SE2")
			EndIf
			__SE2->(dbSetOrder(6)) // E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO                                                                                               
			__SE2->(dbGoto(nRegSE2))

			//Apago os titulos de impostos
			cChaveImp	:= cForUniao+cLojUniao+cPrefixo+cNumero
			If lIRPFBaixa
				cNaturs := cNatPis+"/"+cNatCof+"/"+cNatCsl+"/"+cNatIrf+"/"
			Else
				cNaturs := cNatPis+"/"+cNatCof+"/"+cNatCsl+"/"
			Endif
			//Ponto de entrada onde serao retornados os codigos de natureza utilizados
			//alternativamente pára os titulos de Pis, Cofins e Csll
			If lF241Nat
				cNaturs += ExecBlock("F241NAT",.F.,.F.)
			Endif

			//Apaga registros de Pis, Cofins e Csll gerados por essa baixa
			If __SE2->(MsSeek(xFilial("SE2")+cChaveImp))
				While __SE2->(E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM) == xFilial("SE2") + cChaveImp

					If __SE2->E2_TIPO $ MVTXA+"/"+MVTAXA
						//Se nao existir E2_TITPAI, valida da forma antiga
						//Se E2_TITPAI vazio (titulos antigos), valida da forma antiga
						//Se E2_TITPAI preenchido, pre-valida com a chave do titulo principal
						If (IIf(!Empty(__SE2->(E2_TITPAI)),__SE2->(E2_TITPAI) == cTitPai,.T.))
							If	Alltrim(__SE2->E2_NATUREZ) $ cNaturs .and. __SE2->E2_SEQBX == cSeq
								If STR(__SE2->E2_SALDO,17,2) == STR(__SE2->E2_VALOR,17,2)

									// **********************************************
									// Grava recnos para a integração com SIGAPCO  *
									// **********************************************
									aAdd( aRecPCO , __SE2->(recno()) )

									If lExistFJU
										nRecBkp := SE2->(RECNO())
										SE2->(DBGoto( __SE2->(RECNO()) ) )
										FinGrvEx("P")
										SE2->(DBGoto( nRecBkp ) )
									Endif

									FINDELFKs(__SE2->E2_FILIAL+"|"+__SE2->E2_PREFIXO+"|"+__SE2->E2_NUM+"|"+__SE2->E2_PARCELA+"|"+__SE2->E2_TIPO+"|"+__SE2->E2_FORNECE+"|"+__SE2->E2_LOJA,"SE2")

									RecLock("__SE2")
									If lAtuSldNat
										AtuSldNat(__SE2->E2_NATUREZ, __SE2->E2_VENCREA, __SE2->E2_MOEDA, "2", "P", __SE2->E2_VALOR, __SE2->E2_VLCRUZ, "-",,FunName(),"__SE2",__SE2->(Recno()),0)
									Endif

									// Integração SIGAPFS x SIGAFIN - Deleta os desdobramentos para os titulos filhos, quando estes forem gerados na baixa do titulo Pai.
									Iif(FindFunction("JDelTitCP") .AND. lIntPFS, JDelTitCP(__SE2->(Recno())), Nil)
									
									__SE2->(dbDelete())
									__SE2->(MsUnlock())
								Else // E2_SALDO <> E2_VALOR
									
									RecLock("__SE2")
									__SE2->E2_TITPAI := ""
									__SE2->(MsUnlock())

									ClearIdPai(__SE2->E2_FILIAL+"|"+__SE2->E2_PREFIXO+"|"+__SE2->E2_NUM+"|"+__SE2->E2_PARCELA+"|"+__SE2->E2_TIPO+"|"+__SE2->E2_FORNECE+"|"+__SE2->E2_LOJA,"SE2")

								Endif
							EndIf
						EndIf
					EndIf
					__SE2->(dbSkip())
				Enddo
			Endif

			//Apaga registros de NCC gerados por essa baixa (Pis, Cofins, Csll)
			__SE2->(dbSetOrder(1))
			cChaveImp	:= cPrefixo+cNumero+cParcela+left(MV_CPNEG,3)+cCliFor+cLoja
			If __SE2->(MsSeek(xFilial("SE2")+cChaveImp))
				While !Eof() .and. E2_FILIAL == xFilial("SE2") .and. ;
				cChaveImp == __SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
					If __SE2->E2_SEQBX == cSeq .and. STR(__SE2->E2_SALDO,17,2) == STR(__SE2->E2_VALOR,17,2)
						If lExistFJU
							nRecBkp := SE2->(RECNO())
							SE2->(DBGoto( __SE2->(RECNO()) ) )
							FinGrvEx("P")
							SE2->(DBGoto( nRecBkp ) )
						Endif

						RecLock("__SE2")
						dbDelete()
						MsUnlock()
					Endif
					dbSkip()
				Enddo
			Endif

			// **********************************************
			// Grava recnos para a integração com SIGAPCO  *
			// **********************************************
			For nX := 1 to len(aRecPCO)

				DbSelectArea("SE2")
				DbGoto(aRecPCO[nX])
				If aRecPCO[nX]== SE2->(Recno())
					If ALLTRIM(SE2->E2_NATUREZ)==AllTrim(GetMv("MV_PISNAT"))

						PCODetLan("000002","10","FINA050",.T.)

					ElseIf ALLTRIM(SE2->E2_NATUREZ)==AllTrim(GetMv("MV_COFINS"))

						PCODetLan("000002","11","FINA050",.T.)

					ElseIf ALLTRIM(SE2->E2_NATUREZ)==AllTrim(GetMv("MV_CSLL"))

						PCODetLan("000002","12","FINA050",.T.)

					EndIf
				EndIf
			Next
			RestArea(aAreaSA2)
			RestArea(aArea)
			dbGoto(nRegSE2)
		Endif
	Endif
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} FDelTxInss
Deleta titulos do imposto Inss gerados na baixa.

@author Andrea V. Santiago
@since 30/04/2014
/*/
//-------------------------------------------------------------------
Function FDelTxInss(cPrefixo,cNumero,cParcela,cTipo,cCliFor,cLoja,cSeq,lAltVr)

	Local aArea		:= SE2->(GetArea())
	Local cChaveImp	:= ""
	Local nRegSe2	:= SE2->(RECNO())
	Local lInssBx 	:=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
	Local lAtuSldNat:= FindFunction("AtuSldNat") .AND. AliasInDic("FIV") .AND. AliasInDic("FIW")
	Local cTpTit	:=	""
	Local nMinINS1 	:= SuperGetMv("MV_MININSS",.F.,0)
	Local nLimInss 	:= GetMv("MV_LIMINSS",.F.,0)
	Local nMinINS2 	:= SuperGetMv("MV_VLRETIN",.F.,0)
	Local lInsPub 	:= SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And.;
						nLimInss == 0 .And. nMinINS2 == 0 //Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
	Local lF080NATINS := ExistBlock("F080NATINS")
	Local cNatuIns	:= ""

	If lInssBx
		cTpTit	:=	MVINSS
	Else
		If cTipo $ MVPAGANT
			cTpTit	:=	"INA"
		Else
			cTpTit	:=	MVINSS
		Endif
	Endif

	If ( cPaisLoc == "BRA" )

		dbSelectArea("SE2")
		dbSetOrder(1)

		If Select("__SE2") == 0 //Abro o SE2 com outro alias pois pode estar filtrado pela	Baixa por lote
			ChkFile("SE2",.F.,"__SE2")
		Else
			DbSelectArea("__SE2")
		EndIf

		cChaveImp	:= xFilial("SE2")+cPrefixo+cNumero//+cParcInss+IF(cTipo$MVPAGANT,"INA",MVINSS)

		If FwIsInCallStack("FINA340") .And. lInsPub
			__SE2->( dbSetOrder(1))
		Endif

		If MsSeek(cChaveImp)

			While !Eof( ) .And. __SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM) == xFilial("SE2")+cPrefixo+cNumero

				If lF080NATINS .And. !__SE2->E2_TIPO $ MVNOTAFIS
					cNatuIns := ExecBlock("F080NATINS",.F.,.F.)
				EndIf

				If AllTrim(__SE2->E2_NATUREZ) = Iif(lF080NATINS .And. !__SE2->E2_TIPO $ MVNOTAFIS, AllTrim(cNatuIns), AllTrim(&(GetMv("MV_INSS"))))  .And. __SE2->E2_SALDO != 0 .And.;
				__SE2->E2_TIPO == cTpTit //(cTipo$MVPAGANT,"INA",MVINSS)

					If FwIsInCallStack("FINA340") .And. lInsPub//Inss Baixa Empresa Publica
						If Alltrim(__SE2->E2_ORIGEM) == "FINA340"
							PCODetLan("000002","07","FINA050",.T.) //Apaga o lancamento do INSS gerado no PCO
							If lAtuSldNat //Atualiza o saldo.
								AtuSldNat(__SE2->E2_NATUREZ, __SE2->E2_VENCREA, __SE2->E2_MOEDA, "2", "P", __SE2->E2_VALOR, __SE2->E2_VLCRUZ, "-",,FunName(),"__SE2",__SE2->(Recno()),0)
							Endif
							RecLock( "__SE2" ,.F.,.T.)
							__SE2->(DbDelete( ))
						Else
							__SE2->(dbSkip())
							Loop
						Endif
					Else
						If __SE2->E2_SEQBX == cSeq //Baixa que gerou o titulo referente ao imposto.
							PCODetLan("000002","07","FINA050",.T.) //Apaga o lancamento do INSS gerado no PCO
							If lAtuSldNat //Atualiza o saldo.
								AtuSldNat(__SE2->E2_NATUREZ, __SE2->E2_VENCREA, __SE2->E2_MOEDA, "2", "P", __SE2->E2_VALOR, __SE2->E2_VLCRUZ, "-",,FunName(),"__SE2",__SE2->(Recno()),0)
							Endif
							RecLock( "__SE2" ,.F.,.T.)
							__SE2->(DbDelete( ))
						Else//Baixa que não corresponde ao titulo do imposto gerado.
							lAltVr	:=	.F.
						Endif
					Endif
				EndIf
				__SE2->(dbSkip())
			Enddo
		Endif

		SE2->(RestArea(aArea))
		SE2->(DbGoto(nRegSE2))
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080MovBc
Funcao para verificar o nao se o motivo de baixa gerou 
movimento bancario  

@author Nilton Pereira  
@since 31/05/2005
/*/
//-------------------------------------------------------------------
Function Fa080MovBc(cMotInfo)

	Local lMovBco  := .F.
	Local cMotBx1	:= Iif(Type("cMotBx")=="U", "", cMotBx) //validação criada para rotina de Compens. Receber onde esta variavel nao existira

	Default cMotInfo := ""

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lMotBxMBco := (SuperGetMv("MV_MB10925",.t.,"2") == "1")

	// Consiste se o motivo gera ou nao movimento bancario.
	If lMotBxMBco
		If Empty(cMotInfo)
			//Se movimenta banco (motivo completo)
			If MovBcoBx(cMotBx1,.T.)
				lMovBco := .T.
			Endif
		Else
			//Se movimenta banco (motivo resumido)
			If MovBcoBx(cMotInfo,.F.)
				lMovBco := .T.
			Endif
		Endif
	Endif

Return lMovBco

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080ValCh
Funcao para verificar a existencia de cheque sobre titulo

@author Paulo Augusto 
@since 21/07/2005
/*/
//-------------------------------------------------------------------
Function Fa080ValCh(lValida)
	Local lRet:=.T.
	DEFAULT lValida := .T.

	If  lValida .And. (!(MovBcoBx(cMotBx,.T.)) .Or. !(ChqMotBx(cMotBx))) .And. SE2->E2_IMPCHEQ=="S"
		Help(" ",1,"CH_BAIXA",,STR0148+CRLF+STR0200,1,0)
		lRet:=.F.
	EndIf

Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} F080IssBx
Calculo do ISS pela baixa
@param nTxMoeda, numeric, taxa da moeda no momento da baixa

@author Mauricio Pequim Jr
@since 19/10/2004
/*/
//-------------------------------------------------------------------
Function F080IssBx( lJaSubtPCC, nTxMoeda )

	Local aAreaSE2  := SE2->( GetArea() )
	Local nValTit := 0
	Local lSest := .T.  //Verifica campo de SEST
	Local lAltValor := STR(nValPgto,17,2) != STR(nOldValPgto,17,2)
	Local nValOutImp := 0
	Local nSE2Reg := SE2->(RECNO())
	Local nBaseImp   := 0
	Local lRndIss := SuperGetMv("MV_RNDISS",.F.,.F.)
	Local lCalcIssBx :=	IsIssBx("P")

	//Considero juros multa ou desconto na base do imposto.
	// 1 = Considera valores juros multa ou desconto
	// 2 = Nao considera valores juros multa ou desconto
	Local lJurMulDes := (SuperGetMv("MV_IMPBAIX",.t.,"2") == "1")

	Local lIRPFBaixa := IIf(	cPaisLoc == "BRA" , SA2->A2_CALCIRF == "2", .F.) .And. ;
						Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S" .And. ;
						!SE2->E2_TIPO $ MVPAGANT

	Local lAltJuros	:= IIF( FwIsInCallStack('FA080TIT') .Or. FwIsInCallStack('FA080TITW') ,;
						STR(nJuros,17,2)   != STR(nOldJuros  ,17,2) .Or.;
						STR(nMulta,17,2)   != STR(nOldMulta  ,17,2) .Or.;
						STR(nDescont,17,2) != STR(nOldDescont,17,2), .F.)

	Local lInssBx 	:=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
	Local nVRetISS  := 0
	Local nTxModInc := 0 
	Local nValAuxImp := 0
	Local nCentMd1 := MsDecimais(1)

	Default lJaSubtPCC := .F.
	Default nTxMoeda := 0

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lFina450   := FwIsInCallStack("FINA450")
    DEFAULT lPCCBaixa  := (SuperGetMv("MV_BX10925",.T.,"2") == "1")

	//Base de impostos diferenciada
	//Local lBaseImp	 := F050BSIMP(2)	//Verifica a existência dos campos

	//se estiver sendo chamado via rotina automática a partir da compensação entre carteiras,
	//nao deve processar ISS E IR
	If lFina450 .and. (Type("lF080Auto")<>"U" .and. lF080Auto)
		lCalcIssBx := .F.
	EndIf

	IF lAltValor
		nIss := 0
	EndIF

	If !_lIssMR .And. lCalcIssBx  .and. SE2->E2_TRETISS == "2"

		SE2->(dbGoto(nSE2Reg))
		SED->(dbSetOrder(1))
		SED->(MsSeek(xFilial("SED")+SE2->E2_NATUREZ))
		SA2->(dbSetOrder(1))
		SA2->(MsSeek(xFilial("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA))

		nVRetISS := FVRetISSBx()
		
		//Se considera valores de multa juros desconto ou se a validação partiu do campo de valor
		If !lJurMulDes
			nBaseImp := nValPgto + nDescont + nTotAbat - nJuros - nMulta - nAcresc + nDecresc
		Else
			nBaseImp := nValPgto
		Endif

		nValOutImp := If(!_lIrfMR, SE2->E2_IRRF, 0)

		If !_lInsMR .And. !lInssBx
			nValOutImp += SE2->E2_INSS
		Endif

		If !_lSesMR .And. lSest
			nValOutImp += SE2->E2_SEST
		Endif

		If !_lPccMR .And. !lPccBaixa
			nValOutImp += SE2->(E2_PIS+E2_COFINS+E2_CSLL)
		Endif

		If !_lIrfMR .And. lIRPFBaixa
			nValOutImp -= SE2->E2_IRRF
		Endif

		If SE2->E2_MOEDA > 1 .and. !EMPTY(nTxMoeda)
			If SE2->E2_TXMOEDA > 0
				nTxModInc:= SE2->E2_TXMOEDA
			else
				nTxModInc:= RecMoeda(SE2->E2_EMIS1,SE2->E2_MOEDA)
			EndIf
			//restaura o valor dos impostos para moeda de inclusão do título
			nValAuxImp := nValOutImp
			nValOutImp := Round(xMoeda(nValOutImp,SA6->A6_MOEDA,SE2->E2_MOEDA,dBaixa,nCentMd1+1,nTxModInc,),nCentMd1)

			nValTit := SE2->E2_VALOR + nValOutImp + _nImpEmMR
			
			//restaura os valores para moeda 1 para composição de base
			nValTit := Round(xMoeda(nValTit,SE2->E2_MOEDA,SA6->A6_MOEDA,dBaixa,nCentMd1+1,nTxModInc,),nCentMd1)
			nValOutImp := Round(xMoeda(nValOutImp,SE2->E2_MOEDA,SA6->A6_MOEDA,dBaixa,nCentMd1+1,nTxMoeda,),nCentMd1)
		else
			nValTit := SE2->E2_VLCRUZ + nValOutImp + _nImpEmMR
		EndIf

		If !lAltValor
			nBaseImp += nValOutImp + _nImpEmMR + _nImpBxMR
		Endif

		If  (nValPgto-nPis-nCoFins-nCsll-nIrrf- Iif(nIss > 0, nIss, SE2->(E2_ISS - E2_VRETISS)) <> SE2->E2_SALDO .and. SE2->E2_ISS > 0 .AND. (nIss == 0 .Or. lJurMulDes )  .and. SE2->E2_ISS <> nVRetISS ) .Or. lAltValor 
			
			If lRndIss
				nIss := Round(( nBaseImp * SE2->E2_ISS ) / nValTit ,nCentMd1)
			Else
				nIss := NoRound(( nBaseImp * SE2->E2_ISS ) / nValTit ,nCentMd1)
			Endif

			/* Se o valor do ISS não for maior que o valor que dispensa a retenção, o imposto não recolhido */
			If nIss <= GETMV("MV_VRETISS",.T.,25.00)
				nIss := 0
			EndIf
		Else
			nIss := SE2->E2_ISS - nVRetISS
		Endif
	Endif

	//Reestruturacao SE5
	nIssCalc	:= nIss
	nIssBaseR 	:= nBaseImp
	nIssBaseC 	:= nBaseImp

	SE2->( RestArea( aAreaSE2 ) )

	If !lAltValor .And. !lAltJuros .And. !lFina450
		If !lIRPFBaixa
			nValPgto -= If(!_lPccMR, (nPis+nCofins+nCsll), 0) + If(!_lIrfMR, nIrrf, 0) + nIss
			nOldValPgto := nValPgto
			lJaSubtPCC := .T.
		EndIf
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} F080VldRec
Verifica se o valor pago e menor que o valor da soma 
de Juros, Multa,acrescimo  e Desconto

@author Paulo Augusto 
@since 04/04/2006
/*/
//-------------------------------------------------------------------
Function F080VldRec()

	Local lRet   := .T.
	Local cBxPag := GetNewPar("MV_VLBXPAG", "3")

	If cBxPag == "1"
		lRet := .T.
	Else
		If nValPgto < (nMulta + nJuros + nVA + nAcresc - nDescont - nDecresc)
			If cBxPag == "2"
				lRet := MsgYesNo(STR0219 + CRLF + STR0157)    // "Atencao! O valor pago é menor que a soma dos valores de juros, multa, acrescimo, desconto e valores acessórios."  ## "Deseja confirmar a baixa?"
			ElseIf cBxPag == "3"
				MsgAlert(STR0219 + CRLF + STR0158)  // "Atencao! O valor pago é menor que a soma dos valores de juros, multa, acrescimo, desconto e valores acessórios." ## "Favor modificar os valores."
				lRet := .F.
			EndIf
		EndIf
	Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F080OutImp
Retorna valor de outros impostos para titulo gerado por
de Juros, Multa,acrescimo  e Desconto

@author Mauricio Pequim Jr 
@since 30/05/2007
/*/
//-------------------------------------------------------------------
Function F080OutImp(nValTFt)

	Local aArea			:= GetArea()
	Local lSest			:= .T.  //Verifica campo de SEST
	Local nTotTit		:= 0
	Local nTotImp		:= 0
	Local lCalcIssBx	:= IsIssBx("P")
	Local cQuery		:= ""
    
    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lFina450    := FwIsInCallStack("FINA450")

	//se estiver sendo chamado via rotina automática a partir da compensação entre carteiras,
	//nao deve processar ISS E IR
	If lFina450 .and. (Type("lF080Auto")<>"U" .and. lF080Auto)
		lCalcIssBx := .F.
	EndIf

	dbSelectArea("SE2")
	dbSetOrder(9)  //Fornece+Loja+PrefFat+NumFat

	cQuery := "SELECT Sum(E2_VALOR) TOTTIT, Sum(E2_IRRF) TOTIRF , Sum(E2_INSS) TOTINS "

	If lSest
		cQuery += ", Sum(E2_SEST) TOTSES "
	Endif

	If !lCalcIssBx
		cQuery += ", Sum(E2_ISS) TOTISS "
	Endif

	cQuery += "FROM " + RetSQLname("SE2") + " SE2 WHERE "
	cQuery += "E2_FILIAL = '"	+ xFilial("SE2")	+ "' And "
	cQuery += "E2_FORNECE = '"	+ SE2->E2_FORNECE	+ "' And "
	cQuery += "E2_LOJA = '" 	+ SE2->E2_LOJA   	+ "' And "
	cQuery += "E2_FATPREF = '"	+ SE2->E2_PREFIXO	+ "' And "
	cQuery += "E2_FATURA = '"   + SE2->E2_NUM 	+ "' And "
	cQuery += "D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBOUT", .F., .T.)

	TCSetField('TRBOUT', "TOTTIT", "N",17,2)
	TCSetField('TRBOUT', "TOTIRF", "N",17,2)
	TCSetField('TRBOUT', "TOTINS", "N",17,2)
	If lSest
		TCSetField('TRBOUT', "TOTSES", "N",17,2)
	Endif
	If !lCalcIssBx
		TCSetField('TRBOUT', "TOTISS", "N",17,2)
	Endif

	dbSelectArea("TRBOUT")
	nTotTit	:= TRBOUT->TOTTIT
	nTotImp	:= TRBOUT->(TOTIRF+TOTINS)

	If lSest
		nTotImp	+= TRBOUT->(TOTSES)
	Endif

	If !lCalcIssBx
		nTotImp	+= TRBOUT->(TOTISS)
	Endif

	dbCloseArea()

	RestArea(aArea)

Return nTotImp

//-------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de menu Funcional  

@param Parametros do array a Rotina:                           
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transação a ser efetuada:                        
          	  1 - Pesquisa e Posiciona em um Banco de Dados         
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                         
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  

@return Array com opcoes da rotina
@author Ana Paula N. Silva 
@since 21/11/2006
/*/
//-------------------------------------------------------------------
Static Function MenuDef()                  			  //Indica se o release e 11.5
	Local lFa080BUT := ExistBlock("FA080BUT")              			  //Indica se o release e 11.5
	Private aRotina := { { OemToAnsi(STR0001), "AxPesqui" , 0 , 1,,.F.},; //"Pesquisar"
	{ OemToAnsi(STR0002), "AxVisual"  	 , 0 , 2},; //"Visualizar"
	{ OemToAnsi(STR0003), "FA080Tit" 	 , 0 , 4},; //"Baixar"
	{ OemToAnsi(STR0004), "FA080Lot"	 , 0 , 4},; //"Lote"
	{ OemToAnsi(STR0005), "FA080Can"	 , 0 , 5},; //"Canc Baixa"
	{ OemToAnsi(STR0115), "FA080Exc"	 , 0 , 5,53},;	//"Excluir Baixa"
	{ OemToAnsi(STR0194), "CTBC662" 	 , 0 , 8},;	//"Tracker Contábil"
	{ OemToAnsi(STR0127),"FA040Legenda"	 , 0 , 6, ,.F.} } //"Le&genda"

	If lIsRussia
		aRotina := RU06XFUN76("FINA080",aRotina,{OemToAnsi(STR0001),OemToAnsi(STR0002),;
		OemToAnsi(STR0003),OemToAnsi(STR0004),OemToAnsi(STR0005),OemToAnsi(STR0194),OemToAnsi(STR0127),OemToAnsi(STR0235)})
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica no parametro se gera um Contas a Pagar ³
	//³ quando existir taxa na admistradora do cartao,  ³
	//³ para habilitar menu de baixa por adminstradora  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SuperGetMV("MV_LJGERTX",,.F.)
		aAdd( aRotina,	{ STR0176, "LJXBxAdmFi" , 0 , 4 }) //"Baixa Adm/Fin."
	Endif

	//Rateio Multinatureza
	If FindFunction("F050CMNT") .and. MV_MULNATP
		aAdd( aRotina,	{ STR0214 ,"F050CMNT()", 0 , 2})	//"Consulta Rateio Multi Naturezas"
	Endif
	
	If cPaisLoc == "BRA"
		Aadd(aRotina, {OemToAnsi(STR0215),"FINCRET('SE2')", 0, 2}) //'Consulta de Retenções'
	EndIF

	If lFa080BUT			
		ExecBlock("FA080BUT",.F.,.F.)
	Endif

Return(aRotina)

//-------------------------------------------------------------------
/*/{Protheus.doc} FinA080T
Chamada semi-automatica utilizado pelo gestor financeiro

@author Marcelo Celi Marques 
@since 26/03/2008
/*/
//-------------------------------------------------------------------
Function FinA080T(aParam)
	cRotinaExec := "FINA080"
	ReCreateBrow("SE2",FinWindow)
	FinA080(,aParam[1],.T.)
	ReCreateBrow("SE2",FinWindow)
	dbSelectArea("SE2")

	INCLUI := .F.
	ALTERA := .F.

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} f080DMotBx
Gravação da variavel para validacao se houve alteracao no
motivo de baixa.

@author Adrianne Furtado 
@since 11/09/2008
/*/
//-------------------------------------------------------------------
Function f080DMotBx(cMotBx)
Public cOldMotBx := cMotBx
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} FaActBord()
Gera bordero no momento da Baixa

@param cNumBor   
@param cPort240 
@param cAgen240
@param cConta240
@param dDataBord
@param cModPgto
@param cTipoPag

@author Totvs
@since 09/10/2017
@version 1.0
/*/
//-----------------------------------------------------------------------
Function FaActBord(cNumBor,cPort240,cAgen240,cConta240,dDataBord,cModPgto,cTipoPag)

	Local lRet := .T.

	If FindFunction ("BxActBord")
		lRet := BxActBord(cNumBor,cPort240,cAgen240,cConta240,dDataBord,cModPgto,cTipoPag)
	Else
		Alert(STR0244) //Por favor, pedir para o administrador do sistema atualizar o fonte FINXOLD.PRX
	Endif

Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc} FaGrvActBd()
Gera bordero no momento da baixa e atualiza os
registros relacionados

@param cNumBor   
@param cPort240 
@param cAgen240
@param cConta240
@param dDataBord
@param cModPgto
@param cTipoPag

@author Totvs
@since 09/10/2017
@version 1.0
/*/
//-----------------------------------------------------------------------
Function FaGrvActBd(cNumBor,cPort240,cAgen240,cConta240,dDataBord,cModPgto,cTipoPag)
	
	If FindFunction ("BxGrvActBd")
		BxGrvActBd(cNumBor,cPort240,cAgen240,cConta240,dDataBord,cModPgto,cTipoPag)
	Else
		Alert(STR0244) //Por favor, pedir para o administrador do sistema atualizar o fonte FINXOLD.PRX
	Endif

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} FaDadosBrd()
Verifica existencia de bordero e carrega os dados
basicos do mesmo

@param cNumBor   
@param cPort240 
@param cAgen240
@param cConta240
@param dDataBord
@param cModPgto
@param cTipoPag
@param lDadosDig

@author Totvs
@since 09/10/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Function FaDadosBrd(cNumBor,cPort240,cAgen240,cConta240,dDataBord,cModPgto,cTipoPag,lDadosDig)
	
	If FindFunction ("BxDadosBrd")
	    BxDadosBrd(cNumBor,cPort240,cAgen240,cConta240,dDataBord,cModPgto,cTipoPag,@lDadosDig)
	Else
		Alert(STR0244) //Por favor, pedir para o administrador do sistema atualizar o fonte FINXOLD.PRX
	Endif

Return .T.
//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080bAval
Bloco de marcacao

@author Marcelo Akama  
@since 27/02/2009
/*/
//-------------------------------------------------------------------
Static Function Fa080bAval(cAliasSE2,cMarca,oValor,oQtda)

	Local lRet := FA080Integ(.F.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se possui movimento de baixa valido						³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE2->E2_TIPO $ "INA"
		If F090PagINA(SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
			HELP(" ",1,"SE2BLOQ")
			lRet := .F.
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso tenha sido gerado pelo SigaEic e do tipo INV e do BRASIL nao podera se baixado se nao for pela rotina automatica ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet
		If (Type('lF080Auto') == 'U' .or. !lF080Auto) .and. lIntegracao .and. cPaisloc = "BRA" .and.  SE2->E2_TIPO = "INV"  .and. UPPER(SE2->E2_ORIGEM) = "SIGAEIC"
			HELP(" ",1,"FAORIEIC")
			Return .F.
		Endif

		//DFS - 16/03/11 - Deve-se verificar se os títulos foram gerados por módulos Trade-Easy, antes de apresentar a mensagem.
		// NCF - 25/03/13 - Acrescentado o módulo SIGAESS (Siscoserv)
		If (Type('lF080Auto') == 'U' .or. !lF080Auto) .and. cPaisloc = "BRA" .AND. UPPER(Alltrim(SE2->E2_ORIGEM)) $ "SIGAEEC/SIGAEFF/SIGAEDC/SIGAECO/SIGAESS" .AND. !(cModulo $ "EEC/EFF/EDC/ECO/ESS")
			HELP(" ",1,"FAORIEEC")
			Return .F.
		Endif

		If mv_par04 == 2	// Nao permite baixa se o titulo estiver num bordero.
			If !Empty( SE2->E2_NUMBOR )
				Help(" " , 1 , "FA080NAOBAIXA")
				Return .F. /*Function Fa080bAval*/
			Endif
		Endif

		// Verifica se o registro nao esta sendo utilizado em outro terminal
		If (cAliasSE2)->(MsRLock())
			FA080Inverte(cMarca,oValor,oQtda,.F.) // Marca o registro e trava
			lRet := .T.
		Else
			IW_MsgBox(STR0166,STR0143,"STOP")  //"Este titulo está sendo utilizado em outro terminal, não pode ser utilizado na fatura"###"Atenção"
			lRet := .F.
		Endif
	Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FVRetISSBx
Verifica o total de ISS já retido em baixas parciais

@author Adrianne Furtado  
@since 13/04/2009
/*/
//-------------------------------------------------------------------
Function FVRetISSBx()
	Local aArea 	:= SE5->(GetArea())
	Local nVRetISS	:= 0
	Local lAchouEst	:= .F.

	SE5->(DbSetOrder(7))
	If SE5->(DBSeek(xFilial("SE5")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
		While SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) ==;
		SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
			If SE5->E5_SITUACA <> 'C' .And. !(SE5->E5_TIPODOC $ 'VL|ES') .and. SE5->E5_ARQCNAB<>"FINA090"
				nVRetISS += SE5->E5_VRETISS
			ElseIf SE5->E5_TIPODOC == 'VL'
				nRegBxVl := SE5->(Recno())
				cChaveVl := SE5->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ)

				//Verifica se houve movimento de estorno
				If SE5->(dbSeek(cChaveVl))
					While SE5->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ) == cChaveVl
						If SE5->(E5_TIPODOC) == "ES"
							lAchouEst := .T.
							Exit
						Endif
						SE5->(DbSkip())
					EndDo
				Endif

				SE5->(dbGoTo(nRegBxVl))
				nVRetISS += Iif(lAchouEst, 0, SE5->E5_VRETISS)
				lAchouEst := .F.
			ElseIf SE5->E5_TIPODOC == 'ES' .And. SE5->E5_MOTBX == "CMP"
				nVRetISS -= SE5->E5_VRETISS
			EndIf
			SE5->(DbSkip())
		EndDo
	EndIf

	RestArea(aArea)
Return nVRetISS

//-------------------------------------------------------------------
/*/{Protheus.doc} fa80AltTela
Atualização da tela de baixa
@param nTxMoeda, Numeric, Taxa atual da moeda em que o título será baixado
@param nCasDec, Numeric, Numero de casas decimais consideradas na conversão da moeda
@param cMotBx, char, Motivo de baixa atual informado pelo usuário
@param cOldMotBx, char, Motivo de baixa anterior
@return lRet, Logical,  retorna .T. para atualização de tela efetuada com sucesso

@author Pâmela Bernardo 
@since 19/03/2020
/*/
//-------------------------------------------------------------------
Static Function fa80AltTela(nTxMoeda As Numeric, nCasDec As Numeric,cMotBx As Character,cOldMotBx As Character, aTitCalc As Array, lPgtoMaior As Logical) As Logical
	
	Local lRet       As Logical
	Local lBanco     As Logical
	Local lVlrPgto   As Logical
	Local lVlrEstr   As Logical
	Local lTxMoeda   As Logical
	Local lDbaixa    As Logical
	Local lDacao     As Logical	
	Local lMotBx     As Logical
	Local nVlrPagto  As Numeric
	Local nMoedPart  As Numeric
	Local nTaxaPart  As Numeric
	Local nTaxaDest  As Numeric
	Local cReadvar   As Character
	Local lBxLot	 As Logical
	Local lAtuValor  As Logical
	Local nTxMdaOr   As Numeric
	Local nCentMd1   As Numeric
	Local nValPgOld  As Numeric
	Local nTxMoedOld As Numeric
	Local nTotPgto	 As Numeric
	Local lIRPFBaixa As Logical
	Local nTolerCp 	 As Numeric
	Local lMoeTitBco As Logical
	Local lCtrlAcres As Logical
	Local lCtrlDecre As Logical
	Local nConfTribu As Numeric
	Local nVlrMoeBco As Numeric
	Local nVlrCMBco	 As Numeric
	Local lIssBx 	 As Logical
	Local lPccBx     As Logical 	
	
	Default nTxMoeda   := 0
	Default nCasDec    := TamSx3("E2_TXMOEDA")[2]	
	Default cMotBx     := ""
	Default cOldMotBx  := ""
	Default aTitCalc   := {}
	Default lPgtoMaior := .F.

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lMotBxMBco := (SuperGetMv("MV_MB10925",.t.,"2") == "1")

	lRet      := .T.
	lBanco    := .F. 
	lVlrPgto  := .F.
	lVlrEstr  := .F.
	lTxMoeda  := .F.
	lDbaixa   := .F.
	lDacao    := .F.	
	lMotBx    := .F.
	nVlrPagto := 0
	nMoedPart := 0
	nTaxaPart := 0
	nTaxaDest := 0
	cReadvar  := AllTrim(Readvar())
	lBxLot	   := FwIsInCallStack('FA080TITW')
	lAtuValor  := .F.
	nTxMdaOr   := 0
	nCentMd1   := MsDecimais(1)
	nValPgOld  := nValPgto
	nTxMoedOld := nTxMoeda
	nTotPgto   := 0
	lIRPFBaixa :=	 .F. 
	nTolerCp   := SuperGetMv("MV_TOLERCP",.F.,0)
	lMoeTitBco := (nMoedaBco > 1 .and. SE2->E2_MOEDA > 1 .and. nMoedaBco <> SE2->E2_MOEDA)
	lCtrlAcres := .F.
	lCtrlDecre := .F.	
	nMoedaBco  := If(nMoedaBco <= 0, 1, nMoedaBco)
	nMoedPart  := nMoedaBco
	__lShoHelp := .T.
	nConfTribu := Len(_aImpMR)
	nVlrMoeBco := 0
	nVlrCMBco  := 0
	lIssBx 	   := SuperGetMv("MV_MRETISS",.F.,"1") == "2"
	lPccBx     := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	
	
	SA6->(DbSetOrder(1))
	If SA6->(DbSeek(xFilial("SA6")+cBanco+cAgencia+cConta)) .And. !Empty(SA6->A6_MOEDA)
		nMoedaBco	:= SA6->A6_MOEDA
		nVlrMoeBco	:= RecMoeda(dBaixa, nMoedaBco)
	EndIf	

	If cPaisLoc == "BRA"
		lIRPFBaixa := SA2->A2_CALCIRF == "2" .And. !SE2->E2_TIPO $ MVPAGANT .And.; 
				Posicione("SED", 1, xFilial("SED", SE2->E2_FILORIG) + SE2->E2_NATUREZ, "ED_CALCIRF") == "S"
	EndIf

	//função Fa080ValEstrang
	If cPaisLoc <> "BRA" .And. SE2->E2_MOEDA == 1
		nTxMoeda := Iif(nMoedaBco > 0, aTxMoedas[nMoedaBco][2], 1)
		nTxMdaOr := aTxMoedas[SE2->E2_MOEDA][2]
	EndIf
	
	Do Case
		Case cReadvar $ "CBANCO+CAGENCIA+CCONTA"
			lBanco := __nMoedBco != nMoedaBco
		Case cReadvar == "NVALPGTO"
			lVlrPgto := oValPgto != Nil .And. oValPgto:lModified			
		Case cReadvar == "NVALESTRANG"
			lVlrEstr := oVlEstrang != Nil .And. oVlEstrang:lModified
		Case cReadvar == "NTXMOEDA"
			lTxMoeda := (nTxMoeda != __nTxMoeda .Or. nTxMoeda <= 0)
		Case cReadvar == "DBAIXA"
			lDbaixa := dBaixa != __dBaixa
		Case cReadvar == "CMOTBX"
			If (AllTrim(cMotBx) == "DACAO")
				lDacao := .T.
			EndIf
			lMotBx := .T.
		
	EndCase
	
	If lRet		

		Do Case			
			Case lBanco
				nVlrCMBco := nTxMoeda
				If SE2->E2_MOEDA > 1
					If nTxMoeda > 1 .And. SE2->E2_TXMOEDA == 0 .And. nTxMoeda == nVlrMoeBco
						nTaxaPart := nTxMoeda
					ElseIf nTxMoeda > 1 .And. SE2->E2_TXMOEDA == 0 .And. nTxMoeda <> nVlrMoeBco
						nTaxaPart	:= RecMoeda(dBaixa, SE2->E2_MOEDA)

						If nVlrMoeBco > 1
							nTxMoeda	:= RecMoeda(dBaixa, nMoedaBco)
						Else
							nTxMoeda	:= nTaxaPart
						Endif

					 	nTxMoedOld	:= nTxMoeda
						nVlrCMBco   := nTxMoeda
					Else
						nTaxaPart := If(SE2->E2_TXMOEDA != 0, SE2->E2_TXMOEDA, RecMoeda(dBaixa, SE2->E2_MOEDA))
						nVlrCMBco := nTaxaPart
					EndIf
				Else
					If SA6->A6_MOEDA > 1 .And. nTaxaPart == 0
						nTaxaPart := RecMoeda(dBaixa, SA6->A6_MOEDA)
					Endif

					If nMoedPart <> SE2->E2_MOEDA
						nMoedPart := SE2->E2_MOEDA
					Endif
				EndIf
				
				If nMoedaBco > 1
					nTaxaDest := Iif(SE2->E2_MOEDA == nMoedaBco, nTaxaPart, RecMoeda(dBaixa, nMoedaBco))
				EndIf
				
				lAtuValor := .T.

				FA080CORR(nEstOriginal,nVlrCMBco)
				
			Case lVlrPgto				
				nTaxaPart := nTaxaDest := 0
				
				If (nMoedaBco > 1 .Or. SE2->E2_MOEDA > 1)
					If nMoedaBco > 1
						nTaxaPart := Iif(nTxMoeda != 0, nTxMoeda, RecMoeda(dBaixa, nMoedaBco))
						
						If SE2->E2_MOEDA > 1 .And. SE2->E2_MOEDA != nMoedaBco
							nTaxaDest := Iif(SE2->E2_TXMOEDA != 0, SE2->E2_TXMOEDA, RecMoeda(dBaixa, SE2->E2_MOEDA))	
						EndIf
					ElseIf (nTaxaDest := nTxMoeda) == 0
						nTaxaDest := nTxMoeda := Iif(SE2->E2_TXMOEDA != 0, SE2->E2_TXMOEDA, RecMoeda(dBaixa, SE2->E2_MOEDA))
					EndIf
				EndIf

				If nMoedaBco == 1 .AND. SE2->E2_MOEDA > 1 // Banco em Real e Título em moeda 2, conveter o valor máximo de pagamento para real
					nTotPgto	 := SE2->E2_SALDO + xMoeda(+nJuros+nVA+nMulta-nDescont-nTotAbat+nOtrga+nImpSubst+nAcresc-nDecresc+nTolerCp-nPis-nCoFins-nCsll-nIrrf-nIss , nMoedaBco ,SE2->E2_MOEDA, dBaixa, nCasDec, , nTaxaDest)
				Else
					nTotPgto	 := SE2->E2_SALDO+nJuros+nVA+nMulta-nDescont-nTotAbat+nOtrga+nImpSubst+nAcresc-nDecresc+nTolerCp-nPis-nCoFins-nCsll-nIrrf-nIss
				EndIf				

				nVlrPagto := xMoeda(nValPgto, nMoedaBco, SE2->E2_MOEDA, dBaixa, nCasDec, nTaxaPart, nTaxaDest)
				
				If (lRet := Round(nVlrPagto, 2) <= nTotPgto)
					nValEstrang := Round(nVlrPagto, 2)
					
					lRet := Fa080ValVR(nTxMoeda, Nil, Nil, lIRPFBaixa, Nil, Nil,aTitCalc)
					
					If lBxLot // Valor do Pagto da baixa em lote.
						If (SE2->E2_IMPCHEQ == "S" .or. lChqPre) .And. Round(nValPgto,2) != Round((nValMoeda+nMulta+nJuros+nVA-nDescont+nAcresc-nDecresc-nPis-nCoFins-nCsll-nIrrf-nIss),2)
							Help(" ",1,"JACHQSTIT")
							nValPgto := nOldValPgto
							lRet := .F.
						Endif
					Endif
				EndIf
			Case lVlrEstr

				If lMoeTitBco
					nTaxaPart := If(SE2->E2_TXMOEDA != 0, SE2->E2_TXMOEDA, RecMoeda(dBaixa, SE2->E2_MOEDA))
					nTaxaDest := nTxMoeda
				Else
					nTaxaPart := nTxMoeda
				EndIf
				
				nVlrPagto := xMoeda(nValEstrang, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest)
				nValPgto := xMoeda(nValEstrang, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest)
				
				If !lMoeTitBco
					lRet := Fa080ValVR(nTxMoeda,,,lIRPFBaixa,,,aTitCalc)
				EndIf

			Case lTxMoeda	

				If nTxMoeda > 0
					nTaxaDest := nTxMoeda
					
					If SE2->E2_MOEDA > 1
						nTaxaPart := If(SE2->E2_TXMOEDA != 0, SE2->E2_TXMOEDA, RecMoeda(dBaixa, SE2->E2_MOEDA))
						
						If (nMoedaBco == 1 .Or. nMoedaBco == SE2->E2_MOEDA)  
							nTaxaPart := nTaxaDest
							nTaxaDest := 0
						EndIf
					EndIf
					
					If ((nConfTribu == 0) .Or. (nConfTribu > 0 .And. nJuros == 0)) .And.  FunName() <> "FINA631"
						fa080Juros(nMoedaBco, , ,,nTxMoeda)
					EndIf
					
					Fa080Val(0,nTxMoeda, .T.,,.T.,,,aTitCalc)

					lAtuValor := .T.

					If nConfTribu > 0 .And. AllTrim(SE2->E2_ORIGEM) $ "MATA100|MATA103"
						F080VldImp(.F., nValPgto, .F.)
					EndIf
				else
					lRet := .F.					
				EndIf
			Case lDbaixa
		
				If SE2->E2_MOEDA > 1
					nTaxaPart := If(SE2->E2_TXMOEDA != 0, SE2->E2_TXMOEDA, RecMoeda(dBaixa, SE2->E2_MOEDA))
				EndIf
				
				If nMoedaBco > 1
					nTaxaDest := RecMoeda(dBaixa, nMoedaBco)
				EndIf
				
				nVlrPagto := xMoeda(nValEstrang, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest)
				nValPgto  := Round(nVlrPagto, 2)
				nTxMoeda  := If(nTaxaDest > 0, nTaxaDest, nTaxaPart)

			Case lMotBx
				If lDacao

					If SE2->E2_MOEDA > 1
						nTaxaPart := If(SE2->E2_TXMOEDA != 0, SE2->E2_TXMOEDA, RecMoeda(dBaixa, SE2->E2_MOEDA))
					EndIf
					
					nValPgto := xMoeda(nValEstrang, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest)
					nTxMoeda := nTaxaPart

				EndIf
				If lMotBxMBco //MV_MB10925
					if MovBcoBx(cMotBx,.T.) <> MovBcoBx(cOldMotBx,.T.)
						Fa080Val(0,nTxMoeda,.T.,,,.T.,,aTitCalc)
					EndIF
				EndIF
		EndCase
		
		__lOk := lRet
		
		If !lRet
			If __lShoHelp .And. (lVlrPgto .Or. lVlrEstr)
				Help(" ", 1, "VALORMAIOR")
			EndIf
			
			If lTxMoeda
				Help(" ", 1, "TAXAMOV",,STR0242,2,0)
			EndIf		
		EndIf
		
		If (lVlrPgto .Or. lVlrEstr)
			lPgtoMaior := (!lRet .And. (lVlrPgto .Or. lVlrEstr))
		EndIf
		
		If lRet .and. lAtuValor

			If SE2->E2_MOEDA > 1 .And. SA6->(DbSeek(xFilial("SA6")+cBanco+cAgencia+cConta)) .And. !Empty(SA6->A6_MOEDA) .And. SA6->A6_MOEDA == 1 .And. SE2->E2_TXMOEDA == 0
				nTaxaPart := RecMoeda(dBaixa,SE2->E2_MOEDA)
				If nTxMoeda > 0 .And.  nTxMoeda <> nTaxaPart .And. !(lBanco .And. nMoedPart <> nMoedaBco .And. nMoedPart <> SE2->E2_MOEDA)
					nTaxaPart := nTxMoeda
				Endif
			Endif

			If __nAcresc > 0 .And. (SE2->E2_SALDO + SE2->E2_SDACRES) > 0 .And. !(SE2->E2_SALDO + SE2->E2_SDACRES) == nValEstrang
				nValEstrang := SE2->E2_SALDO + SE2->E2_SDACRES

				If SE2->E2_SDACRES > 0 .And. SE2->E2_MOEDA == 1 .And. (lIRPFBaixa .Or. lIssBx .Or. lPccBx) .And. (nPis+nCofins+nCsll+nIrrf+nIss) > 0
					If lIRPFBaixa .And. nIrrf > 0
						nValEstrang -= nIrrf
					EndIf 

					If lPccBx .And. (nPis+nCofins+nCsll) > 0
						nValEstrang -= nPis+nCofins+nCsll
					EndIf 

					If lIssBx .And. nIss > 0
						nValEstrang -= nIss
					EndIf 
				EndIf
				
			EndIf

			If __nDecresc > 0 .And. (SE2->E2_SALDO - SE2->E2_SDDECRE) > 0 .And. !(SE2->E2_SALDO - SE2->E2_SDDECRE) == nValEstrang
				nValEstrang := SE2->E2_SALDO - SE2->E2_SDDECRE

				If SE2->E2_SDDECRE > 0 .And. SE2->E2_MOEDA == 1 .And. (lIRPFBaixa .Or. lIssBx .Or. lPccBx) .And. (nPis+nCofins+nCsll+nIrrf+nIss) > 0
					If lIRPFBaixa .And. nIrrf > 0
						nValEstrang -= nIrrf
					EndIf 

					If lPccBx .And. (nPis+nCofins+nCsll) > 0
						nValEstrang -= nPis+nCofins+nCsll
					EndIf 

					If lIssBx .And. nIss > 0
						nValEstrang -= nIss
					EndIf 
				EndIf
			EndIf

			nVlrPagto := xMoeda(nValEstrang, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest)
			nValPgto := Round(nVlrPagto, nCentMd1)
			nDescCalc := 0
			nJurosCalc := 0
			__nVlrAjst := nVlrPagto

			lCtrlAcres := .F.
			lCtrlDecre := .F.

			If (__nAcresc > 0 .And. nAcresc == 0 .And. SE2->E2_SDACRES > 0) .Or. ( __nAcresc > 0 .And. nAcresc != SE2->E2_SDACRES )
				nAcresc := SE2->E2_SDACRES
				lCtrlAcres := .T.
			Endif

			If (__nDecresc > 0 .And. nDecresc == 0 .And. SE2->E2_SDDECRE > 0) .Or. ( __nDecresc > 0 .And. nDecresc != SE2->E2_SDDECRE )
				nDecresc := SE2->E2_SDDECRE
				lCtrlDecre := .T.
			Endif
			
			If nDescont > 0
				nDescont := xMoeda(nDescont, nMoedPart, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest) 
			EndIf
			If nJuros > 0
				nJuros := xMoeda(nJuros, nMoedPart, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest) 
			EndIf
			If nMulta > 0
				nMulta := xMoeda(nMulta, nMoedPart, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest) 
			EndIf
			If nAcresc > 0
				If !lCtrlAcres
					nAcresc	:= xMoeda(nAcresc, nMoedPart, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest) 
				Else
					nAcresc := xMoeda(nAcresc, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest) 
				Endif
				nJurosCalc += nAcresc
			Endif
			If nDecresc > 0
				If !lCtrlDecre
					nDecresc := xMoeda(nDecresc, nMoedPart, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest)
				Else
					nDecresc := xMoeda(nDecresc, SE2->E2_MOEDA, nMoedaBco, dBaixa, nCasDec, nTaxaPart, nTaxaDest) 
				Endif
				nDescCalc += nDecresc
			Endif			
            IF !EMPTY(nVA)
                nVa	:= FValAcess(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, /*lBaixados*/, /*cCodVa*/, "P", dBaixa, /*aValAces*/, SE2->E2_MOEDA, nMoedaBco, nTxMoeda)
                IF !EMPTY(nVA)
                    nVA := Round(nVA,2)
                ENDIF
                Fa080Val(0,nTxMoeda, .T.,,.T.,,,aTitCalc)
            ENDIF
			
			If SE2->E2_MOEDA > 1 .And. nTxMoedOld <> nTxMoeda .And. FunName() $ "FINA080|FINA750|FINA703" //Vld para não permitir alt da taxa acordada, a partir da ediç do Vlr estrang
				nTxMoeda := nTxMoedOld
			Else
				nTxMoeda	:= nTaxaPart
				If SE2->E2_TXMOEDA > 0 .And. lBanco
					nTxMoeda	:= SE2->E2_TXMOEDA
				ElseIf SE2->E2_TXMOEDA == 0 .And. lBanco .And. nMoedaBco > 1
					nTxMoeda	:= RecMoeda(dBaixa, nMoedaBco)
				ElseIf nTaxaDest > 0
					nTxMoeda	:= nTaxaDest
				Endif
			EndIf

			// A chamada do Fa080Val() em trechos acima atualiza Base e Valor do IR
			// Quando temos o P.E. F80L9816 em uso é necessario atualizar as variaveis de 
			// valores na tela, pois pode ter havido alteração do valor/taxa da base do IRRF
			IF !lBxLot
                If lIRPFBaixa .And. !lF080Auto .And. nF080TXIR>0
                    Fa080Val(nIrrf,nTxMoeda,,.T.,,,,)
                EndIF
			EndIF

		EndIf
	EndIf	
	
	If lRet
		nEstOriginal := nValEstrang - Round(NoRound(xMoeda(nJuros+nVA+nMulta-nDescont+nOtrga+nImpSubst,nMoedaBco,SE2->E2_MOEDA,,nCentMd1+1,,nTxMoeda),nCentMd1+1),nCentMd1)

		IF lVlrPgto .and. SE2->E2_MOEDA > 1
			oVlEstrang:Refresh()
			If cPaisloc <> "CHI" .and. (Type('lF080Auto') == 'U' .or. !lF080Auto)
				If oCm != Nil
					oCm:Refresh()
				EndIf
			EndIF
		ENDIF

		//Problemas de arredondamento
		If ABS(nValPgOld - nValPgto) <= ABS(0.01)
			nValpgto := nValPgOld
		Endif
		
		__nTxMoeda := nTxMoeda
		__dBaixa   := dBaixa
		__cBcoAgCt := cBanco+cAgencia+cConta
		__nMoedBco := nMoedaBco
		
		nVlDesOld := nDescont
		nVlJurOld := nJuros
		nVlMulOld := nMulta
		f080DMotBx(cMotBx)
	EndIf
	
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080Refr
Função para dar Refresh na tela de baixa
@param oJuros, object, Objeto da tela de juros
@param oMulta, object, Objeto da tela de Multa
@param oDescont, object, Objeto da tela de desconto
@param oDtBaixa, object, Objeto da tela de data da baixa
@param oTxMoeda, object, Objeto da tela de taxa da moeda
@return lRet, Logical,  retorna .T. para atualização de tela efetuada com sucesso

@author Pâmela Bernardo 
@since 03/04/2020
/*/
//-------------------------------------------------------------------
Static Function Fa080Refr(oJuros As object, oMulta As object, oDescont As object, oDtBaixa As object, oTxMoeda As object) As Logical
	Local lRet 		 As Logical
	Local lIRPFBaixa As Logical

	Default oJuros     := Nil
	Default oMulta     := Nil
	Default oDescont   := Nil
	Default oDtBaixa   := Nil
	Default oTxMoeda   := Nil

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lPCCBaixa  := (SuperGetMv("MV_BX10925",.T.,"2") == "1")

	lRet 		 := .T.
	lIRPFBaixa 	 := .F. 

	If cPaisLoc == "BRA"
		lIRPFBaixa := SA2->A2_CALCIRF == "2" .And. !SE2->E2_TIPO $ MVPAGANT .And.; 
				Posicione("SED", 1, xFilial("SED", SE2->E2_FILORIG) + SE2->E2_NATUREZ, "ED_CALCIRF") == "S"
	EndIf

	If oJuros != Nil
		oJuros:Refresh()
	EndIf
	If oMulta != Nil
		oMulta:Refresh()
	EndIf
	If oDescont != Nil
		oDescont:Refresh()
	EndIf
	If SE2->E2_MOEDA > 1 
		If oCm != Nil
			oCm:Refresh()
		EndIf
		If oVlEstrang != Nil
			oVlEstrang:Refresh()
		EndIf
	Endif
	If lPccBaixa
		If oCofins != Nil
			oCofins:Refresh()
		EndIf
		If oPis != Nil
			oPis:Refresh()
		EndIf
		If oCsll != Nil
			oCsll:Refresh()
		EndIf
	EndIf
	If lIRPFBaixa .and. oIrrf != Nil
		oIrrf:Refresh()
	EndIf
	If oDtBaixa != Nil
		oDtBaixa:Refresh()
	EndIf
	If oValPgto != Nil
		oValPgto:Refresh()
	EndIf

	If oTxMoeda != Nil
		oTxMoeda:Refresh()
	EndIf


Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080IrBx
Verifica se o título possui TX de IR Gerado na Baixa e já baixado

@author Adrianne Furtado 
@since 01/12/2009
/*/
//-------------------------------------------------------------------
Function Fa080IrBx(cSeqBx as Character, lSeek As Logical) as Logical
	Local lRet  		as Logical //informa se o título principal possui TX de IR Gerado na Baixa e já baixado.
	Local aAreaSe2  	as Array
	Local lIRPFBaixa 	as Logical
	Local cNatIrf 		as Character
	Local aImpIRF 		as Array
	Local nX			as Numeric

	Default cSeqBx	 := SE5->E5_SEQ
	Default lSeek   := .T.

	aAreaSe2  := SE2->(GetArea())

	lRet := .F.

	lIRPFBaixa := IIf( cPaisLoc == "BRA" , SA2->A2_CALCIRF == "2", .F.) .And. ;
	Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S" 	

	//Se tem IR na baixa.
	If lIRPFBaixa .Or. ( SE2->E2_TIPO $ MVPAGANT )
		cNatIrf    := &(SuperGetMv("MV_IRF",.T.,"'IRF'"))
		aImpIRF	:= ImpCtaPg(cNatIrf, lSeek)

		For nX := 1 to Len(aImpIRF)
			SE2->(DBGoto(aImpIRF[nX][9]))
			If SE2->E2_SEQBX == cSeqBx .and. SE2->E2_VALOR != SE2->E2_SALDO
				lRet := .T.
				Exit
			EndIf
		Next nX	

		FwFreeArray(aImpIRF)
	EndIf

	SE2->(RestArea(aAreaSe2))
	FwFreeArray(aAreaSe2)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080Juri(lTodos, lPrimeiro)
Rotina para verificar se tem integracao com o SIGAPFS e realizar
as validacoes da integracao.

@param lTodos    Se .T. indica se foi precionada a opção de selecionar todos os título
@param lPrimeiro  Quando encontrar o primeiro título que não atenda a validação e
exibir a mensagem, retorna por referencia que não serão exibidas
novas mensagens caso ocorram inconsistencias nos próximos títulos.

@Return lRet   .T. Se o título é valido para ser manipulado.

@author Luciano Pereira dos Santos
@since 09/10/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function Fa080Juri(lTodos, lPrimeiro)
	Local lRet      := .T.

	Default lTodos    := .F.
	Default lPrimeiro := .T.

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lIntPFS	  := SuperGetMv("MV_JURXFIN",.T.,.F.)

	If lIntPFS .And. FindFunction("JVldBxPag")
		lRet := JVldBxPag(SE2->(RECNO()), lTodos, @lPrimeiro)
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FA080VlCan
Valida motivo de baixa de titulos cancelados.

@author Fabricio Romera 
@since 24/06/2010
/*/
//-------------------------------------------------------------------
Static Function FA080VlCan(dDataCan, cMotBx)
	Local lRet := .T.

	If !GetMv("MV_CTLIPAG")
		Return lRet
	End If

	//Verifica se titulo esta cancelado
	If Empty(dDataCan)
		Return lRet
	End If

	//Verifica se motivo de baixa possui movimentacao financeira
	lRet := !MovBcoBx(cMotBx, .T. )

	If !lRet
		Help(" ",1,"MOTIVO DE BAIXA", , ;
		STR0175,1,0) //"Título cancelado não permite motivo de baixa com movimentação financeira"
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080Irrf
Função para calculo do IRRF e gravação da varialvel nIrrf   
Esta funcao deve ser melhorada para ser a TotMes do Irrf

@author Acacio Egas 
@since 14/12/2010
/*/
//-------------------------------------------------------------------
Static Function Fa080Irrf(nPgtoIRRF,dData,lCarret,lRecalc,nOldIrrf)

	DEFAULT nOldIrrf  := 0
	DEFAULT cMotBx    := ""
	DEFAULT dDebito   := stod("")

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lF80L9816 := ExistBlock("F80L9816")

	If SE2->E2_PRETIRF = '1'
	
		// Lei 9.816 de 1999, para determinar a base de cálculo dos Tributos Federais
		If lF80L9816			
			nF080TXIR := ExecBlock("F80L9816", .F., .F., {SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),;
														 dBaixa,dDebito, 4})
		EndIF	

		//Novo calculo de IRRF pela Baixa
		//Calculo para o  IRRF
		//o primeiro parametro, neste caso vai zerado pois o calculo
		//eh feito com base no saldo do titulo
		nIRRF := FCalcIRBx(0,SA2->A2_TIPO,dBaixa,dDebito,/*lAltValor*/,Iif(nF080TXIR > 0 , nF080TXIR , Nil ),cMotBx)														 

		If nIRRF # nOldIrrf
			nValPgto += nOldIrrf
			nValPgto -= nIRRF
			nOldValPgto := nValPgto
			nOldIrrf    := nIrrf
		EndIf
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080Lib
Ponto de Entrada para a confirmacao da tela de baixa manual   
de contas a pagar.

@author Andrea Verissimo  
@since 02/01/2011
/*/
//-------------------------------------------------------------------
Static Function Fa080Lib()
	Local lFa080Lib := ExistBlock("FA080LIB")
	Local lRetorno  := .T.

	If lFa080Lib
		lRetorno := ExecBlock("FA080LIB",.F.,.F.)
	Endif

Return lRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} FinFatAbat
Funcao para somar abatimentos dos titulos que geram a fatura.  

@author Marivaldo  
@since 18/03/2011
/*/
//-------------------------------------------------------------------
Function FinFatAbat(cPrefixo,cNum,cFornece,cLoja)
	Local nTotIss := 0
	Local nTotIns := 0
	Local nTotIrf := 0
	Local nTotPis := 0
	Local nTotCof := 0
	Local nTotCsl := 0
	Local nTotSes := 0
	Local aArea	  := GetArea()
	Local cAliasFat := ""

	cQuery := "SELECT SUM(E2_VRETIRF) E2_VRETIRF,SUM(E2_VRETISS) E2_VRETISS,SUM(E2_VRETPIS) E2_VRETPIS,SUM(E2_VRETCOF) E2_VRETCOF,SUM(E2_VRETCSL) E2_VRETCSL,SUM(E2_INSS) E2_INSS, SUM(E2_SEST) E2_SEST "
	cQuery += "FROM " + RetSqlName("SE2") + " "
	cQuery += "WHERE E2_FATPREF='" + cPrefixo + "' AND E2_FATURA ='" + cNum + "' AND E2_FATFOR = '" + cFornece + "' AND E2_FATLOJ='" + cLoja + "'"

	cAliasFat := CriaTrab(,.F.)

	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasFat, .F., .T. )

	nTotIss	:= (cAliasFat)->E2_VRETISS
	nTotIns	:= (cAliasFat)->E2_INSS
	nTotIrf	:= (cAliasFat)->E2_VRETIRF
	nTotPis	:= (cAliasFat)->E2_VRETPIS
	nTotCof	:= (cAliasFat)->E2_VRETCOF
	nTotCsl	:= (cAliasFat)->E2_VRETCSL
	nTotSes	:= (cAliasFat)->E2_SEST

	(cAliasFat)->(DbCloseArea())

	RestArea(aArea)

Return {nTotIss,nTotIns,nTotIrf,nTotPis,nTotCof,nTotCsl,nTotSes}

//-------------------------------------------------------------------
/*/{Protheus.doc} FA080VlNat
Valida natureza que realizam movimentos bancarios.   

@author Totvs
@since 08/08/2011
/*/
//-------------------------------------------------------------------
Static Function FA080VlNat(cMotBx)
	Local lRet := .T.

	//----------------------------------------------------------------
	// Verifica se motivo de baixa possui movimentacao financeira    
	//----------------------------------------------------------------
	If MovBcoBx(cMotBx, .T. ) .And. Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_MOVBCO") == "2"
		Help(" ",1,"MOTIBAIXA", , "",1,0) //"Motivo de baixa inválido para a natureza selecionada. Verifique a opção de movimentação bancária da natureza e não prosseguir."
		lRet:=.F.
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FA080Integ
Valida a integdef de baixas a pagar  

@author Jandir Deodato 
@since 30/08/2012
/*/
//-------------------------------------------------------------------
Function FA080Integ(lCancel,lMsg)
	Local aSave := GetArea()
	Local lRet := .T.
	Local cMSG := NIL
	Local aRetMsg := {}
	Local oXX4 := NIL
	Local cRotina := 'FINA080'

	Default lCancel := .F.
	Default lMsg := .T.

	If !(alltrim(SE2->E2_TIPO) =="PR")
		If lCancel
			cMSG:='REVERSALOFACCOUNTPAYABLEDOCUMENTDISCHARGE'
		Else
			cMSG:='ACCOUNTPAYABLEDOCUMENTDISCHARGE'
		Endif

		If FWHasEAI(cRotina,.T.,,.T.)

			If AllTrim(SE2->E2_ORIGEM)=="FINI055" .and. lRet  .and. !lCancel
				If FWHasEAI("FINI070A",.T.,,.T.)
					SE2->(MsUnlock())
					SetRotInteg('FINI070A')
					MsgRun ( STR0185+" "+rTrim(SE2->E2_NUM)+ " " +STR0186,STR0187,{||aRetMsg:=FinI070A()} )//"Atualizando título" "a valor presente..." "Valor Presente"
					RecLock("SE2",.F.)
					If ValType(aRetMsg[1]) <> "U" .and.  !aRetMsg[1]
						If (valtype(aRetMsg[2]) <> "U" .and. aRetMsg[2] <> Nil .and. !Empty(aRetMsg[2]))
							MsgAlert(STR0188+ CRLF+ aRetMsg[2])//"Foi realizada uma tentativa de atualização do título, e foi retornada a seguinte mensagem:"
						Else
							MsgAlert(STR0189+ " " + rTrim(SE2->E2_NUM)+" ."+STR0190)//"Ocorreu um erro inesperado na tentativa de atualização do título " "Verifique as configurações da integração e tente novamente."
						Endif
						lRet :=.F.
					ElseIF Valtype(aRetMsg[1]) =="U"
						MsgAlert(STR0189+ " " + rTrim(SE2->E2_NUM)+" ."+STR0190)//"Ocorreu um erro inesperado na tentativa de atualização do título " "Verifique as configurações da integração e tente novamente."
						lRet:=.F.
					Endif
				Else
					lRet:=.F.
					MsgAlert(STR0191)//"Para realizar as baixas de integrações como TIN, é necessário cadastrar o adapter da rotina FINI070A - UPDATECONTRACTPARCEL."
				Endif
			Endif
		Endif
	Endif
	RestArea(aSave)

	If !EMPTY(oXX4)
		oXX4:CleanUp()
		FreeObj(oXX4)
		oXX4 := NIL
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080Desc
Abre tela para a configuracao do tipo do desconto a ser enviado no bloco
F100 do SPED PIS/COFINS. 

@author Andrea V. Santiago
@since 06/12/2012
/*/
//-------------------------------------------------------------------
Function Fa080Desc(lTpDesc,lNatApura)
	Local oDlgDesc, oVlDesc

	If cPaisLoc == "BRA" .And. lTpDesc .And. lNatApura	 .And. nDescont > 0

		DEFINE MSDIALOG oDlgDesc FROM 10,05 TO 14,45 TITLE "Tipo de Desconto " // "Tipo de Desconto"

		@	6,2 Say "Desconto: " SIZE 31,07 OF oDlgDesc PIXEL
		@  5,35  MSCOMBOBOX oVlDesc VAR cTpDesc ITEMS {"C=Condicional","I=Incondicional"} SIZE 70, 47 OF oDlgDesc PIXEL

		DEFINE SBUTTON FROM 5,120 TYPE 1 ACTION oDlgDesc:End() ENABLE OF oDlgDesc
		ACTIVATE MSDIALOG oDlgDesc CENTERED

	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} F080CanBx
Valida o cancelamento das baixas efetuadas quando há retenção de impostos
na baixa

@author Pedro Pereira Lima
@since 05/09/2013
/*/
//-------------------------------------------------------------------
Function F080CanBx(aBaixa,nOpcBx,lPccBx)
	Local lRet		:= .T.
	Local nTamBx	:= Len(aBaixa)
	Local lTemJur := .F.
	Local lCalcImp := .F.
	Local lEmpPub  :=  IsEmpPub()

	Default lPccBx	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"

	//Verifica se possui Juros calculado na baixa
	DBSelectArea("SE5")
	SE5->(DBSetORder(2)) //E5_FILIAL, E5_TIPODOC, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_DATA, E5_CLIFOR, E5_LOJA, E5_SEQ.
	If SE5->(DBSeek( xFilial("SE5") + padr("JR", TamSx3("E5_TIPODOC")[1] ) +  SE2->(E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + DTOS(E2_BAIXA) + E2_FORNECE + E2_LOJA) ))
		lTemJur := .T.
	EndIf

	If SE2->(E2_COFINS + E2_PIS + E2_CSLL + E2_IRRF + E2_ISS) > 0
		lCalcImp := .T.
	EndIf

	If Type("lEmpPub") <> "L"
		lEmpPub	:= IsEmpPub()
	EndIf

	If (nTamBx > 1) .And. (nOpcBx < nTamBx)
		If lPccBx .and. (lCalcImp .OR. lTemJur)
			lRet := .F.
			Help(" ",1,"FINIMPBX")
		EndIf
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F080RetPA
Verifica se a retenção de impostos em outro título foi feita em uma PA

@author Karen Honda
@since 19/09/2014
/*/
//-------------------------------------------------------------------
Static Function F080RetPA(cAlias,cPrefixo, cNum , cParcela, cTipo, cFornece , cLoja)
	Local aAreaSE2 := SE2->(GetArea())
	Local lAchouRel := .F.
	If AliasIndic("SFQ")
		dbSelectArea("SFQ")
		dbSetOrder(2) //FQ_FILIAL, FQ_ENTDES, FQ_PREFDES, FQ_NUMDES, FQ_PARCDES, FQ_TIPODES, FQ_CFDES, FQ_LOJADES
		If MsSeek(xFilial("SFQ")+cAlias+cPrefixo + cNum + cParcela+  cTipo +  cFornece + cLoja )
			If SFQ->FQ_TIPOORI $ MVPAGANT
				lAchouRel := .T.
			EndIf
		EndIF
	EndIf
	RestArea(aAreaSE2)

Return lAchouRel

//-------------------------------------------------------------------
/*/{Protheus.doc} F080MovPA
Verifica se PA possui movimentacao bancaria em outro título foi feita em uma PA

@author Karen Honda
@since 19/09/2014
/*/
//-------------------------------------------------------------------
Function F080MovPA(lVerMov As Logical, cPrefixo As Character, cNum As Character, cParcela As Character,;
					cTipo As Character, cFornece As Character, cLoja As Character, cFilSE5 As Character,;
					lExtReinf As Logical)
	
	Local nRecnoSE5 as Numeric
	Local cQry      as Character
	Local cTblTmp   as Character
	Local cCampoChq as Character
	Local aMotBx    as Array
	Local aArea := GetArea()

	Default lVerMov   := .F.
	Default cPrefixo  := ""
	Default cNum      := ""
	Default cParcela  := ""
	Default cTipo     := ""
	Default cFornece  := ""
	Default cLoja     := ""
	Default cFilSE5   := ""
	Default lExtReinf := .F.

	//Inicializa variáveis
	nRecnoSE5 := 0
	cQry      := ""
	cTblTmp   := ""
	cCampoChq := Padr("", TamSX3("E5_NUMCHEQ")[1])
	aMotBx    := {}

	cMotBxBco := FMotBxBco()

	If !Empty(cMotBxBco)
		aMotBx := &(StrTran(StrTran(cMotBxBco, "(", "{"), ")", "}"))
	EndIf

	If Empty(cFilSE5)
		cFilSE5 := xFilial("SE5")
	EndIf

	If lVerMov
		If lExtReinf 		//Se for utilizada pelo extrator do REINF
			If __oMovPA == Nil
				cQry := "SELECT SE5.R_E_C_N_O_ FROM " + RetSqlName("SE5") + " SE5 "
				cQry += "LEFT JOIN " + RetSqlName("SEF") + " SEF "
				cQry += "ON EF_FILIAL = ? AND EF_PREFIXO = E5_PREFIXO AND EF_TITULO = E5_NUMERO AND EF_PARCELA = E5_PARCELA "
				cQry += "AND EF_TIPO = E5_TIPO AND EF_FORNECE = E5_FORNECE AND EF_LOJA = E5_LOJA AND EF_NUM <> '' AND SEF.D_E_L_E_T_ = ' ' "
				cQry += "WHERE E5_FILIAL = ? AND E5_PREFIXO = ? AND "
				cQry += "E5_NUMERO = ? AND E5_PARCELA = ? AND "
				cQry += "E5_TIPO = ? AND E5_CLIFOR = ? AND "
				cQry += "E5_LOJA = ? AND E5_MOTBX IN (?) AND "
				cQry += "((E5_TIPODOC = 'PA' ) OR (E5_TIPODOC = 'BA' AND EF_LIBER = 'S') OR "
				cQry += "(E5_TIPODOC = 'CH' AND E5_NUMCHEQ <> ? AND EF_LIBER = 'S') ) AND "
				cQry += "E5_RECPAG = 'P' AND E5_SITUACA = ' ' AND SE5.D_E_L_E_T_ = ' ' "
				
				//Descarta PA caso tenha sido baixado (adiantamento devolvido pelo fornecedor)
				cQry += "AND NOT EXISTS (
				cQry += "	SELECT A.E5_NUMERO
				cQry += "	FROM " + RetSqlName("SE5") + " A
				cQry += "	WHERE A.E5_FILIAL=SE5.E5_FILIAL
				cQry += "	AND A.E5_PREFIXO=SE5.E5_PREFIXO
				cQry += "	AND A.E5_NUMERO=SE5.E5_NUMERO
				cQry += "	AND A.E5_PARCELA=SE5.E5_PARCELA
				cQry += "	AND A.E5_TIPO=SE5.E5_TIPO
				cQry += "	AND A.E5_FORNECE=SE5.E5_FORNECE
				cQry += "	AND A.E5_LOJA=SE5.E5_LOJA
				cQry += "	AND A.E5_RECPAG = 'R'
				cQry += "	AND A.D_E_L_E_T_=' ')

				cQry := ChangeQuery(cQry)
				__oMovPA := FWPreparedStatement():New(cQry)
			EndIf

			__oMovPA:SetString(1, xFilial("SEF"))
			__oMovPA:SetString(2, cFilSE5)
			__oMovPA:SetString(3, cPrefixo)
			__oMovPA:SetString(4, cNum)
			__oMovPA:SetString(5, cParcela)
			__oMovPA:SetString(6, cTipo)
			__oMovPA:SetString(7, cFornece)
			__oMovPA:SetString(8, cLoja)
			__oMovPA:SetIn(9, aMotBx)
			__oMovPA:SetString(10, cCampoChq)

			cQry := __oMovPA:GetFixQuery()
			cTblTmp := MpSysOpenQuery(cQry)
		Else
			If __oMovPA2 == Nil		//Se for utilizada por outros processos (versão antiga)
				cQry := "SELECT  R_E_C_N_O_ FROM " + RetSqlName("SE5") + " "
				cQry += "WHERE E5_FILIAL = ? AND E5_PREFIXO = ? AND "
				cQry += "E5_NUMERO = ? AND E5_PARCELA = ? AND "
				cQry += "E5_TIPO = ? AND E5_CLIFOR = ? AND "
				cQry += "E5_LOJA = ? AND E5_MOTBX IN (?) AND "
				cQry += "((E5_TIPODOC = 'PA' ) OR (E5_TIPODOC = 'BA' AND E5_NUMCHEQ <> ? ) OR "
				cQry += "(E5_TIPODOC = 'CH' AND E5_NUMCHEQ <> ? )) AND "
				cQry += "E5_RECPAG = 'P' AND E5_SITUACA = ' ' AND D_E_L_E_T_ = ' ' "
				cQry := ChangeQuery(cQry)
				__oMovPA2 := FWPreparedStatement():New(cQry)
			EndIf

			__oMovPA2:SetString(1, cFilSE5)
			__oMovPA2:SetString(2, cPrefixo)
			__oMovPA2:SetString(3, cNum)
			__oMovPA2:SetString(4, cParcela)
			__oMovPA2:SetString(5, cTipo)
			__oMovPA2:SetString(6, cFornece)
			__oMovPA2:SetString(7, cLoja)
			__oMovPA2:SetIn(8, aMotBx)
			__oMovPA2:SetString(9, cCampoChq)
			__oMovPA2:SetString(10, cCampoChq)

			cQry := __oMovPA2:GetFixQuery()
			cTblTmp := MpSysOpenQuery(cQry)
		Endif
	Else
		If __oMovCnb == Nil
			cQry := "SELECT  R_E_C_N_O_ FROM " + RetSqlName("SE5") + " "
			cQry += "WHERE E5_FILIAL = ? AND E5_PREFIXO = ? AND "
			cQry += "E5_NUMERO = ? AND E5_PARCELA = ? AND "
			cQry += "E5_TIPO = ? AND E5_CLIFOR = ? AND "
			cQry += "E5_LOJA = ? AND E5_MOTBX IN (?) AND "
			cQry += "E5_RECPAG = 'P' AND E5_SITUACA = ' ' AND D_E_L_E_T_ = ' ' "
			cQry := ChangeQuery(cQry)
			__oMovCnb := FWPreparedStatement():New(cQry)
		EndIf

		__oMovCnb:SetString(1, cFilSE5)
		__oMovCnb:SetString(2, cPrefixo)
		__oMovCnb:SetString(3, cNum)
		__oMovCnb:SetString(4, cParcela)
		__oMovCnb:SetString(5, cTipo)
		__oMovCnb:SetString(6, cFornece)
		__oMovCnb:SetString(7, cLoja)
		__oMovCnb:SetIn(8, aMotBx)

		cQry := __oMovCnb:GetFixQuery()
		cTblTmp := MpSysOpenQuery(cQry)
	Endif

	If (cTblTmp)->(!Eof())
		nRecnoSE5 := (cTblTmp)->R_E_C_N_O_
	EndIf

	(cTblTmp)->(DbCloseArea())
	RestArea(aArea)

Return nRecnoSE5


//-------------------------------------------------------------------
/*/{Protheus.doc} checkAcento
VALIDAÇÃO PARA NÃO PERMITIR O USO DE ASPAS POIS OCORRE ERRO DE QUERY

@author Totvs
@since 10/12/2015
@version P12.1.07
/*/
//-------------------------------------------------------------------
Static Function checkAcento() as Logical
	Local lRet 		as Logical
	Local cReadVar  as Character
	Local nAt 		as Numeric
	Local nAt2 		as Numeric

	lRet := .T.
	cReadVar :=  &(ReadVar())
	nAt := At("'",cReadVar)
	nAt2 := At('"',cReadVar)

	If nAt > 0 .or. nAt2 > 0
		MsgStop(STR0202,STR0143)//"Não é permitido o uso de aspas!"
		lRet := .F.
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} ValCheq
Retorna o valor do cheque gerado 

@author Totvs
@since 14/07/2015
@version P12.1.07
/*/
//-------------------------------------------------------------------
Static Function ValCheq()
	Local nValor 		:= 0
	Local aArea   	:= GetArea()
	Local cQry			:= ""
	Local cAliasQry		:= GetNextAlias()

	cQry := " Select EF_VALOR ValCheq "
	cQry += " From " + RetSqlName("SEF") + " SEF "
	cQry += " Where EF_FILIAL 	= '" + xFilial("SEF") + "' "
	cQry += " AND EF_PREFIXO 	= '" + SE2->E2_PREFIXO + "' "
	cQry += " AND EF_TITULO 		= '" + SE2->E2_NUM + "' "
	cQry += " AND EF_PARCELA 	= '" + SE2->E2_PARCELA + "' "
	cQry += " AND EF_TIPO 		= '" + SE2->E2_TIPO + "' "
	cQry += " AND EF_NUM  		= '" + SE2->E2_NUMBCO + "' AND "
	cQry += " SEF.D_E_L_E_T_ = ' ' "

	cQry := ChangeQuery(cQry)

	dbUseArea( .T.,"TOPCONN",TCGENQRY(,,cQry),cAliasQry,.F.,.T. )

	nValor := (cAliasQry)->VALCHEQ

	(cAliasQry)->(DbCloseArea())

	RestArea(aArea)

Return nValor

//-------------------------------------------------------------------
/*/{Protheus.doc} FA080EstBL
Gera estorno na FK5, referente ao cancelamento de baixas a receber realizadas em lote

@param cLoteFin, Lote financeiro da baixa
@param cHistorico, Histórico que será salvo no registro de estorno na FK5
@return Nil

@author Marylly Araújo Silva
@since 10/12/2015
@version P12.1.07
/*/
//-------------------------------------------------------------------
Static Function FA080EstBL( cLoteFin AS CHARACTER, cHistorico AS CHARACTER, dDtBaixa AS DATE)
	Local oModelMov	 AS OBJECT
	Local oSubFK5	 AS OBJECT
	Local oSubFKA	 AS OBJECT
	Local oModelAux	 AS OBJECT
	Local oSubFK5aux AS OBJECT
	Local oSubFKAaux AS OBJECT
    Local cLog       AS CHARACTER
    Local cProcFK5   AS CHARACTER
    Local cIDFK5     AS CHARACTER
    Local nX         AS NUMERIC
	Local nValorES   AS NUMERIC
	Local aAuxFK5    AS ARRAY
	Local aCamposFK5 AS ARRAY
	Local aAreaFK5   AS ARRAY
	Local aAreaSE5   AS ARRAY
    LOCAL cIDProc    AS CHARACTER
    LOCAL cFilProc   AS CHARACTER
    LOCAL cFilOrig   AS CHARACTER
	LOCAL cChaveTit	 AS CHARACTER
	LOCAL cChaveFK7	 AS CHARACTER

	oModelMov   := Nil
	oSubFK5     := Nil
	oSubFKA     := Nil
	oModelAux   := Nil
	oSubFK5aux  := Nil
	oSubFKAaux  := Nil
	cLog        := ""
	cProcFK5    := ""
	nX          := 0
	aAuxFK5     := {}
	aCamposFK5  := FK5->( DbStruct() )
	nValorES    := SE5->E5_VALOR
	cIDFK5      := ""
	aAreaFK5    := FK5->( GetArea() )
	aAreaSE5    := SE5->( GetArea() )
    cIdProc     := ""
    cFilProc    := cFilAnt
    cFilOrig    := cFilAnt
	cChaveTit 	:= xFilial("SE2", SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
	cChaveFK7 	:= FINBuscaFK7(cChaveTit, "SE2", SE2->E2_FILORIG)

	If __lIDFK7 == NIL
		__lIDFK7 := FK5->(FieldPos("FK5_IDFK7")) > 0
	EndIf

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT nTamLote := TamSX3("E2_LOTE")[1]

	//-- Pega o ID do movimento na FK5
	FK5->( dbSetOrder( 2 ) ) //-- FK5_FILIAL, FK5_LOTE, FK5_TPDOC, FK5_RECPAG
	If	FK5->( msSeek( FWxFilial("FK5") + cLoteFin + "BL" + "P" ) ) .OR.;
        FK5->( msSeek( FWxFilial("FK5") + cLoteFin + "VL" + "P" ) ) .OR.;
        FK5->( msSeek( FWxFilial("FK5") + cLoteFin + "CH" + "P" ) ) .OR.;
        GetFK5IdMv(dDtBaixa,@cIdProc,@cFilProc)
        cIDFK5 := FK5->FK5_IDMOV
	Else
		//-- Busca por registro do movimento totalizador de lote na SE5 (BL|VL|CH)
		SE5->(dbSetOrder(5))
		SE5->(msSeek( xFilial("SE5")+ PADR(cLoteFin, nTamLote) ))
		While SE5->(!Eof() .And. cLoteFin == E5_LOTE )
			If SE5->(Empty(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO) .And. E5_TIPODOC $ "BL|VL|CH" )
				//-- Carrego MODEL para migrar FK's caso necess rio.
				oModelMov := FWLoadModel("FINM030")
				oModelMov:Activate()
				cIDFK5 := oModelMov:GetValue("FK5DETAIL","FK5_IDMOV")
				oModelMov:DeActivate()
				oModelMov:Destroy()
				oModelMov:= Nil
				Exit
			EndIF
			SE5->(DbSkip())
		EndDo
		SE5->( RestArea( aAreaSE5 ) )
	EndIf

	FK5->( RestArea( aAreaFK5 ) )

	//-- Posiciona no BL da SE5 para carregar o processo no model e pegar os valores da FK5 para gravar no estorno
	If !Empty( cIDFK5 )

        //-- Verifica se Altera a Filial - Verificado Qdo a Baixa/lote ocorreu em outra filial
		IF cFilProc != cFilAnt
			cFilAnt := cFilProc
		ENDIF

		SE5->( DbSetOrder( 21 ) ) //-- E5_FILIAL + E5_IDORIG
		If SE5->( msSeek( FWxFilial("SE5") + cIDFK5 ) )
			
            //-- Pega o número do processo do BL gerado na baixa em lote
    		cProcFK5 := FINProcFKs( cIDFK5, "FK5" )

			oModelAux := FWLoadModel( "FINM030" )
			oModelAux:SetOperation( MODEL_OPERATION_UPDATE ) //-- Inclusao
			oModelAux:Activate()
			oSubFKAaux := oModelAux:GetModel( "FKADETAIL" )
			oSubFK5aux := oModelAux:GetModel( "FK5DETAIL" )

			If oSubFKAaux:SeekLine( { { "FKA_IDORIG", cIDFK5 } } )
				For nX := 1 To Len( aCamposFK5 )
					aAdd( aAuxFK5, oSubFK5aux:GetValue( aCamposFK5[nX][1] ) )
				Next nX
			Endif
			oModelAux:DeActivate()
			oModelAux:Destroy()
			oModelAux:= Nil
		Endif
		SE5->( RestArea( aAreaSE5 ) )

        //-- Restaura Filial 
		IF cFilAnt != cFilOrig
			cFilAnt := cFilOrig
		ENDIF

		//-- Inicializo o model
		oModelMov := FWLoadModel( "FINM030" )
		oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
		oSubFKA := oModelMov:GetModel( "FKADETAIL" )

		oModelMov:SetOperation( MODEL_OPERATION_INSERT )    //-- Inclusao
		oModelMov:Activate()
		oModelMov:SetValue( "MASTER", "E5_GRV", .F. )       //-- Informa se vai gravar SE5 ou não
		oModelMov:SetValue( "MASTER", "NOVOPROC", .F. )     //-- Não cria um novo processo
		oModelMov:SetValue( "MASTER", "IDPROC", cProcFK5 )  //-- Define o número do processo para o estorno do BL

		If !oSubFKA:IsEmpty()
			oSubFKA:AddLine()
		Endif

		oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
		oSubFKA:SetValue( "FKA_TABORI", "FK5" )

		If Len( aAuxFK5 ) > 0
			For nX := 1 To Len(aCamposFK5)
				If aCamposFK5[nX][1] <> 'FK5_MSUIDT'
					oSubFK5:SetValue( aCamposFK5[nX][1], aAuxFK5[nX] )
				Endif	
			Next nX
		Endif

		oSubFK5:SetValue( "FK5_TPDOC", "ES" )
		oSubFK5:SetValue( "FK5_RECPAG", "R" )
		oSubFK5:SetValue( "FK5_HISTOR", cHistorico )
		oSubFK5:SetValue( "FK5_VALOR", nValorES )
		oSubFK5:SetValue( "FK5_DATA", dDataBase )
		oSubFK5:SetValue( "FK5_DTDISP", dDataBase )
		oSubFK5:SetValue( "FK5_FILORI", SE2->E2_FILORIG )

		If __lIDFK7
			oSubFK5:SetValue( "FK5_IDFK7", cChaveFK7)
		Endif

		oSubFK5:SetValue( "FK5_DOC", SE5->E5_DOCUMEN ) //Grava numero do bordero na FK5

		cBanco := oSubFK5:GetValue("FK5_BANCO")
		cAgenc := oSubFK5:GetValue("FK5_AGENCI")
		cCont  := oSubFK5:GetValue("FK5_CONTA")

		If oModelMov:VldData()
			oModelMov:CommitData()
		Else
			cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
			cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
			cLog += cValToChar(oModelMov:GetErrorMessage()[6])

			Help( , , "M30F080EST", , cLog, 1, 0 )
		Endif
		oModelMov:DeActivate()
		oModelMov:Destroy()
		oModelMov:= Nil
	Endif

	SE5->( RestArea( aAreaSE5 ) )

Return Nil

/*/{Protheus.doc} IntegDef
Função para integração via Mensagem Única Totvs.

@author  Felipe Raposo
@version P12.1.22
@since   10/05/2018
/*/
//-------------------------------------------------------------------
Static Function IntegDef(cXml, cTypeTrans, cTypeMsg, cVersion, cTransac)
Return FINI080(cXml, cTypeTrans, cTypeMsg, cVersion, cTransac)

//-------------------------------------------------------------------
/*/{Protheus.doc}F080JuMuDe
Retorna a soma dos valores acessórios juros, multa, desconto,acréscimo e
decréscimo que irá compor a base de retenção do pcc

@author Sivaldo Oliveira
@since  08/11/2017
@version 12
/*/
//-------------------------------------------------------------------
Function F080JuMuDe() As Numeric
	Local nJuMuDe As Numeric
	Local lAcao As Logical
	Local lJuMuDe As Logical

	//Inicilaiza variáveis
	nJuMuDe := 0
	lJuMuDe := SuperGetMv("MV_IMPBAIX",.T.,"2") == "1"

	If lJuMuDe
		lAcao := FwIsInCallStack("FA080Tit") .or. FwIsInCallStack("F241Impost") .or. FwIsInCallStack("fA091Aut") .or. FwIsInCallStack("fA090Aut") .or. FwIsInCallStack("FA080TitW")

		If lAcao
			If Type("nJuros") = "N"
				nJuMuDe += nJuros
			EndIf

			If Type("nMulta") = "N"
				nJuMuDe += nMulta
			EndIf

			If Type("nAcresc") = "N"
				nJuMuDe += nAcresc
			EndIf

			If Type("nDecresc") = "N"
				nJuMuDe -= nDecresc
			EndIf

			If Type("nDescont") = "N"
				nJuMuDe -= nDescont
			EndIf

			If Type("nVA") = "N"
				nJuMuDe += nVA
			EndIf
		EndIf
	EndIf

Return nJuMuDe


//--------------------------------------------------------------------------
/*/{Protheus.doc}FMotBxBco
Monta o IN para query com os motivos de baixa que geram movimento bancário

@author Mauricio Pequim Jr / Wilson Fernando Matocheck
@since  06/03/2018
@version 12
/*/
//--------------------------------------------------------------------------
Function FMotBxBco()
	Local aMotBx As Array
	Local aMotBxBco As Array
	Local nLenBx As Numeric
	Local nI As Numeric

	//Inicializa variáveis.
	aMotBx := {}
	aMotBxBco := {}
	nLenBx := 0
	nI := 0

	If cMotBxBco == Nil
		aMotBx := ReadMotBx()
		nLenBx := Len( aMotBx )
		cMotBxBco := ""

		For nI := 1 to nLenBx
			//-------------------------------------------------------
			// Estrutura da aMotBxBco
			// 1 - Sigla do Motivo de Baixa
			// 2 - Descrição do Motivo de Baixa
			// 3 - Movimenta Banco (S/N)
			// 4 - Comissão (S/N)
			// 5 - Carteira (A/P/R)
			// 5 - Cheque (S/N)
			//-------------------------------------------------------
			aMotBxBco := Strtokarr2( aMotBx[nI], '³' )
			If Alltrim(aMotBxBco[5]) $ "A|P" .and. Alltrim(aMotBxBco[3]) == "S"
				cMotBxBco += PadR(aMotBxBco[1],3) + "|"
			EndIf
		Next nI

		cMotBxBco := Substr(cMotBxBco, 1, Len(cMotBxBco)-1 )
		cMotBxBco := FormatIN(cMotBxBco,"|")
	Endif

Return cMotBxBco

//--------------------------------------------------------------------------
/*/{Protheus.doc} F080EmBord
Verifico se titulo está em borderô e se será permitido Baixa Parcial para titulo de borderôoooo

@author Rodrigo Pirolo
@since  23/08/2018
@version 12
/*/
//--------------------------------------------------------------------------
Static Function F080EmBord()

	Local lRet			:= .F.
	Local lEmBordero	:= !Empty(SE2->E2_NUMBOR) .AND. cPaisLoc == "BRA" .AND. SE2->E2_TIPO <> MVPAGANT

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lBxParBor := SuperGetMv("MV_BXPARBO",.T.,.F.)

	// Melhoria DSERFINP-10020
	// Possibilitar a baixa parcial de títulos a pagar vinculados em um borderô
	//
	// Parametro MV_BXPARBO
	//						.F. (Default) - Não Permite Baixa Parcial do Titulo em Bordero.
	//						.T. - Permite a Baixa Parcial do Titulo em Bordero.

	If lBxParBor .AND. lEmBordero
		// Se estiver com IDCNAB preenchido não é permitido baixar parcial
		If Empty(SE2->E2_IDCNAB)
			lRet := .F.
		Else

			lRet := .T.
		EndIf
	Else
		lRet := lEmBordero
	EndIf

Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc} F080VldImp()
C?culo dos impostos a serem retidos
@author  Sivaldo Oliveira
@since 07/11/2017
@version 12
/*/
//-------------------------------------------------------------------
Static Function F080VldImp(lCancel As Logical, nValPgto As Numeric, lAltValor )
	Local nZ         As Numeric
	Local nImpos     As Numeric
	Local nBasMR     As Numeric
	Local aImpos     As Array
	Local aBasMR     As Array
	Local aImpConf   As Array
	Local nCasDec    As Numeric
	Local lBordero   As Logical
	Local aBaseImp   As Array
	Local nBaseDif   As Numeric
	Local cIdFK0     As Character
	Local cChaveTit  As Character
	Local cIdDocFK7  As Character
	Local nTxaConIRF As Numeric
	Local nBasDifIRF As Numeric
	Local aGrossUp   As Array
	Local nQuantBase As Numeric

	Default nValPgto  := 0
	Default lCancel   := .F.
	Default lAltValor := .F.
	
	//Inicilaiza variaveis
	nZ         := 0
	nImpos     := 0
	nBasMR     := 0
	aImpos     := {}
	aBasMR     := {}
	nCasDec    := TamSx3("E2_TXMOEDA")[2]
	lBordero   := .F.
	aBaseImp   := {}
	nBaseDif   := 0
	cIdFK0     := ""
	cChaveTit  := ""
	cIdDocFK7  := ""
	nTxaConIRF := 0
	nBasDifIRF := 0
	aGrossUp   := {}
	_lPccMR    := .F.
	_lIrfMR    := .F.
	_lInsMR    := .F.
	_lIssMR    := .F.
	_lCidMR    := .F.
	_lSesMR    := .F.
	_lImpMR    := .F.
	_nImpMR    := 0
	_nTotImp   := 0
	aImpConf   := {}
	_nPisMR    := 0
	_nCofMR    := 0
	_nCslMR    := 0
	_nIrfMR    := 0
	_nInsMR    := 0
	_nIssMR    := 0
	_nCidMR    := 0
	_nSesMR    := 0
	_aImpMR    := {}
	_nImpEmMR  := 0
	_nImpBxMR  := 0
	_nBasLeg   := 0
	nQuantBase := 0
	
	//Valida quais os impostos configurados pelo motor de reten?es
	If !SE2->E2_TIPO $ MVPAGANT+"|"+MVABATIM+"|"+MVPROVIS+"|"+MV_CPNEG+"|"+MVTAXA+"|"+MVTXA+"|INA"
		cChaveTit := xFilial("SE2", SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA		
		cIdDocFK7 := FINBuscaFK7(cChaveTit, "SE2", SE2->E2_FILORIG)
		aImpConf  := FinImpConf("1", SE2->E2_FILORIG, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, cIdDocFK7, SE2->E2_EMISSAO, @__oImpConf, @__oQryFKQ)
		nImpos    := Len(aImpConf)

		For nZ := 1 To nImpos
			Do Case
				Case aImpConf[nZ,1] $ "PIS|COF|CSL"
					_lPccMR := .T.
					_lPccBxMR := aImpConf[nZ,2] == "2"
				Case aImpConf[nZ,1] == "IRF"
					_lIrfMR := .T.
				Case aImpConf[nZ,1] == "INSS"
					_lInsMR := .T.
				Case aImpConf[nZ,1] == "ISS"
					_lIssMR := .T.
				Case aImpConf[nZ,1] == "CIDE"
					_lCidMR := .T.
				Case aImpConf[nZ,1] == "SEST"
					_lSesMR := .T.
				OtherWise
					_lImpMR := .T.
			EndCase
			
			//Retenção na primeira baixa
			If aImpConf[nZ,7] == "1" .And. aImpConf[nZ,5] $ "1|2" .And. SE2->E2_SALDO == SE2->E2_VALOR
				nBaseDif := SE2->E2_VALOR
				
				If SE2->E2_MOEDA > 1
					nBaseDif := NoRound(xMoeda(nBaseDif, SE2->E2_MOEDA, 1, dBaixa, nCasDec, SE2->E2_TXMOEDA), nCasDec)
				EndIf
				
				Aadd(aBaseImp, {aImpConf[nZ,1], nBaseDif})
			EndIf
		Next nZ
	EndIf

	If !Empty(SE2->E2_NUMBOR) .And. Alltrim(Posicione("SEA",4,FWxFilial("SEA",SE2->E2_FILORIG) + SE2->(E2_NUMBOR+"P"+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA), "EA_ORIGEM")) == "FINA241"	
		lBordero := .T.
		SEA->(DbGoTo(0))
	EndIf

	If !lCancel .And. !lBordero .And. nImpos > 0	
		nBasMR := IIf(Empty(nValPgto), SE2->E2_SALDO, nValPgto)
		
		If Empty(nValPgto) .Or. Round(xMoeda(nValPgto, SE2->E2_MOEDA, 1, dBaixa, nCasDec, SE2->E2_TXMOEDA), 2) >= _nValPgto
			aBasMR := FinBaseMR(nBasMR, .F., SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA,;
				_lPccMR, _lIrfMR, _lInsMR, _lIssMR, _lCidMR, _lSesMR, SE2->E2_MOEDA, SE2->E2_TXMOEDA, dBaixa)
			
			nBasMR    := aBasMR[1] //Base de retenção
			_nImpEmMR += aBasMR[2] //Impostos retidos pelo motor - EMISSAO
			_nImpBxMR += aBasMR[3] //Impostos retidos pelo motor e legado - BAIXA		
			
			If _nImpEmMR > 0 .And. (nQuantBase := Len(aBaseImp)) > 0
				For nZ := 1 To nQuantBase				
					aBaseImp[nZ,2] += _nImpEmMR
				Next nZ
			EndIf
		EndIf
		
		If SE2->E2_MOEDA > 1		
			If Empty(nValPgto)
				nBasMR := Round(xMoeda(nBasMR, SE2->E2_MOEDA, 1, dBaixa, nCasDec, SE2->E2_TXMOEDA), 2)
			EndIf
			
			AAdd(aGrossUp, {"", SE2->E2_MOEDA, SE2->E2_EMISSAO, dBaixa, nCasDec, SE2->E2_TXMOEDA, nTxMoeda})
			
			If lF80L9816 .And. _lIrfMR
				SA2->(DbSetOrder(1))
				SA2->(DbSeek(xFilial("SA2", SE2->E2_FILORIG)+ SE2->(E2_FORNECE+E2_LOJA)))
				
				If AllTrim(SA2->A2_TIPO) == "X" .And. SA2->A2_GROSSIR $ "1|2|3"
					nTxaConIRF := ExecBlock("F80L9816", .F., .F., {SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA), dBaixa, dDebito, 4})
					
					If nTxaConIRF > 0					
						aGrossUp := {}
						
						If nValPgto <= 0 
							nBasDifIRF := Round(xMoeda(SE2->E2_SALDO, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxaConIRF), 2)
						Else
							nBasDifIRF := xMoeda(nValPgto, 1, SE2->E2_MOEDA, dBaixa, nCasDec, 0, nTxMoeda)
							nBasDifIRF := Round(xMoeda(nBasDifIRF, SE2->E2_MOEDA, 1, dBaixa, nCasDec, nTxaConIRF), 2)						
						EndIf
						
						AAdd(aBaseImp, {"IRF", nBasDifIRF})
						AAdd(aGrossUp, {"IRF", SE2->E2_MOEDA, SE2->E2_EMISSAO, dBaixa, nCasDec, nTxMoeda, nTxaConIRF})
					EndIf
				EndIf
			EndIf
		EndIf
		
		If ((nQuantBase > 0) .Or. (Len(aBaseImp) > 0))
			cIdFK0 := FINGRVFK7("SE2", cChaveTit)
		EndIf
		
		//Cáculo motor de retençoes.
		aImpos := FinCalImp("1", SE2->E2_NATUREZ, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_FILORIG, nBasMR, dBaixa, .T., aBaseImp, SE2->E2_TIPO, cChaveTit, cIdFK0, {}, lAltValor, aGrossUp)
		
		//Vlr p/ gravação dos vrets
		F080AtuImp(Aclone(aImpos))
		
		_aImpMR  := Aclone(aImpos)
		_nTotImp := _nImpMR
		_nBasLeg := nBasMR
		
		FwFreeArray(aBaseImp)
		FwFreeArray(aGrossUp)
	EndIf
Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} F080ConImp()
Consulta de impostos Motor de reten?es.
@author  Sivaldo Oliveira
@since 07/11/2017
@version 12
/*/
//-------------------------------------------------------------------
Static Function F080ConImp()
	Local aImpMR As Array
	Local nOpcao As Numeric
	Local nVlr As Numeric
	Default _aImpMR := {}

	//Inicializa vari?eis.
	aImpMR := Aclone(_aImpMR)
	nOpcao := 1
	nVlr := 0

	If Len(aImpMR) > 0
		nVlr := _nImpMR
		nOpcao := FINMRET(aImpMR, 'SE2', .T., @nVlr)

		//Se houve alguma altera?o nos impostos
		If nOpcao != 1 .And. _nImpMR != nVlr
			If nVlr <= 0
				_nTotImp -= _nImpMR
				nValPgto += _nImpMR
				_nImpMR := 0
			Else
				nVlr := (_nImpMR - nVlr)

				If nVlr > 0
					nValPgto += nVlr
					_nTotImp -= nVlr
					_nImpMR -= nVlr
				Else
					nValPgto += nVlr
					_nTotImp += (nVlr * (-1))
					_nImpMR += (nVlr * (-1))
				EndIf
			EndIf

			//atual vari?eis para gravar os vrets
			F080AtuImp(Aclone(aImpMR))

			_aImpMR := Aclone(aImpMR)
			nOldValPgto := nValPgto
			nOldPgto := nValPgto
			_nValPgto := nValPgto
			nValEstrang := nValPgto
			oRetMotor:Refresh()
			oValPgto:Refresh()
		EndIf
	EndIf

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} F080AtuImp()
Atualiza as vari?eis para grava?o dos vrets
@author  Sivaldo Oliveira
@since 07/11/2017
@version 12
/*/
//-------------------------------------------------------------------
Static Function F080AtuImp(aImpos As Array)
	Local nZ As Numeric
	Local nImpos As Numeric

	Default aImpos := {}

	//Inicializa vari?eis
	nZ := 0
	nImpos := Len(aImpos)
	_nPisMR := 0
	_nCofMR := 0
	_nCslMR := 0
	_nIrfMR := 0
	_nInsMR := 0
	_nIssMR := 0
	_nCidMR := 0
	_nSesMR := 0
	_nImpMR := 0

	For nZ := 1 To nImpos
		If (aImpos[nZ,9] != "2") .Or. (aImpos[nZ,13] != "1") .Or. (aImpos[nZ,14] != "1")
			Loop
		EndIf

		//Vlr de imps a ser abatido do valor a de pagto
		_nImpMR += aImpos[nZ,5]

		//Vari?eis para gravar os Vrets.
		Do Case
			Case aImpos[nZ,8] == "PIS"
				_nPisMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "COF"
				_nCofMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "CSL"
				_nCslMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "IRF"
				_nIrfMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "INSS"
				_nInsMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "ISS"
				_nIssMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "CIDE"
				_nCidMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "SEST"
				_nSesMR += aImpos[nZ,5]
		EndCase
	Next nZ

Return Nil

//--------------------------------------------------------------------------
/*/{Protheus.doc} F080PesqBord()
Pesquisa Bordero em todas as filiais e atualiza o parametro
cFilBor com a filial em que foi encontrada o bordero

@Param cNumBor Numero do bordero SEA
@Param cFilBor Filial posicionada passada como referencia
@Param cCart Carteira que deve ser considerada na SEA (P/R)
@Param cPrefixo Prefixo do titulo
@Param cNumero Numero do titulo
@Param cParcela Parcela do titulo 
@Param cTipo Tipo do titulo
@Param cCliFor Fornecedor/Cliente informado no titulo 
@Param cLoja Loja do fornecedor/cliente
@Param cFilOrig Filial de origem do titulo

@author Vitor Duca 
@since 15/07/2019
@version 12.1.23
/*/
//---------------------------------------------------------------------------
Static Function F080PesqBord(cNumBor as Character,cFilBor as Character,cCart as Character,cPrefixo as Character,cNumero as Character,cParcela as Character,;
					cTipo as Character,cCliFor as Character,cLoja as Character,cFilOrig as Character) as Logical
	Local lRet			as Logical
	Local cAlias 		as Character
	Local aFiliais  	as Array
	Local nPos 			as Numeric
	Local aArea			as Array 
	Local cFilFwSEA 	as Character
	Local cAliasQry		as Character
	
	//Inicialização das variaveis
	lRet 		:= .F.
	cAlias		:= Alias()
	aFiliais  	:= {}        
	nPos      	:= 0
	aArea		:= {}
	cAliasQry	:= "BORSEA"
	//--- Tratamento Gestao Corporativa
	cFilFwSEA := FwFilial("SEA")

	Default cCart	:= ""

	If !Empty( cFilFwSEA ) // Se o SEA for exclusivo, pesquisa o bordero em todas as filiais
		aArea	:= GetArea()

		BeginSql Alias cAliasQry
			SELECT SEA.EA_FILIAL, R_E_C_N_O_ RECNO
				FROM %Table:SEA% SEA
				WHERE SEA.EA_FILIAL IN ( SELECT EA_FILIAL FROM %Table:SEA% 
														WHERE EA_FILORIG = %Exp:cFilOrig% 
															AND EA_PREFIXO = %Exp:cPrefixo% 
															AND EA_NUM = %Exp:cNumero% 
															AND EA_PARCELA = %Exp:cParcela% 			
															AND EA_TIPO = %Exp:cTipo% 				
															AND EA_FORNECE = %Exp:cCliFor% 
															AND EA_LOJA = %Exp:cLoja% 	
															AND EA_NUMBOR = %Exp:cNumBor%
															AND EA_CART = %Exp:cCart%		
															AND %NotDel%	 
															GROUP BY EA_FILIAL )
					AND SEA.EA_FILORIG = %Exp:cFilOrig% 
					AND SEA.EA_PREFIXO = %Exp:cPrefixo% 
					AND SEA.EA_NUM = %Exp:cNumero% 
					AND SEA.EA_PARCELA = %Exp:cParcela% 			
					AND SEA.EA_TIPO = %Exp:cTipo% 				
					AND SEA.EA_FORNECE = %Exp:cCliFor% 
					AND SEA.EA_LOJA = %Exp:cLoja%
					AND EA_NUMBOR = %Exp:cNumBor%
					AND EA_CART = %Exp:cCart%		 			
					AND SEA.%NotDel%
					GROUP BY SEA.EA_FILIAL, R_E_C_N_O_
					ORDER BY SEA.EA_FILIAL
		EndSql

		IF !(cAliasQry)->( EOF() )
			AADD( aFiliais , { (cAliasQry)->EA_FILIAL,(cAliasQry)->RECNO} )
		Endif

		lRet	:= .T.
		(cAliasQry)->( DbCloseArea() )

		RestArea( aArea )
	Else
		SEA->(DbSetOrder(2))	//EA_FILIAL+EA_NUMBOR+EA_CART+EA_PREFIXO+EA_NUM+EA_PARCELA+EA_TIPO+EA_FORNECE+EA_LOJA
		lRet := SEA->( MsSeek( xFilial( "SEA" ) + cNumBor + cCart ) )
		cFilBor := SEA->EA_FILIAL
	Endif
		
	nPos := aScan(aFiliais,{|x| x[1]== cFilAnt})

	If nPos > 0
		cFilBor := aFiliais[nPos,1]
		//Posiciono no borderô da filial corrente.
		SEA->(dbGoto(aFiliais[nPos,2]))
	ElseIf Len(aFiliais)>=1
		cFilBor := aFiliais[1,1]
		//Posiciono no borderô da primeira filial.
		SEA->(dbGoto(aFiliais[1,2]))
	Endif

	dbSelectArea( cAlias )

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} IntegMnta()
Verifica a integração Financeiro e manutenção de ativos, e aplica 
o desconto direto na SE2

@author Vitor Duca
@since 27/01/2020
@version 12
/*/
//-------------------------------------------------------------------
Static Function IntegMnta()
	Local aArea := {}
	Local cAliasQry := GetNextAlias()

	//Caso exista o P.E. MNTA7655 já é realizado o desconto diretamente na SE2
	If !ExistBlock("MNTA7655")
		aArea := GetArea()
		cQuery := " SELECT TRX.TRX_DESCON"
		cQuery += " FROM " + RetSqlName( "TRX" )+" TRX"
		cQuery += " WHERE TRX.TRX_NUMSE2 = '" + SE2->E2_NUM + "'"
		cQuery += " AND	TRX.D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)
		dbUseArea( .T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasQry,.F.,.T. )

		nDescont  := ( cAliasQRY )->TRX_DESCON //Desconto
		RestArea( aArea )
	EndIf

Return nDescont	


//-------------------------------------------------------------------
/*/{Protheus.doc} FA080TXIR
Executa o ponto de entrada F080TXIR nas operações de inclusão e cancelamento
de baixa

@author Norberto M de Melo
@since 22/04/2020
@version 12
/*/
//-------------------------------------------------------------------
Static Function FA080TXIR(cChave As Char, cOrigem As Char, nOpc As Numeric, dDataOp As Date) As Numeric
	Local nRet As Numeric

	Default cChave  := ""
	Default cOrigem := ""
	Default nOpc    := 0
	Default dDataOp := dDataBase
	
	//Inicializa variáveis.
	nRet := 0
	
	If (nOpc != 0 .And. "ESS" $ cOrigem .And. !Empty(cChave) .And. !Empty(dDataOp))
		nRet := EXECBLOCK("F080TXIR", .F., .F., {cChave, dDataOp, nOpc})
	EndIf

Return nRet

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} F080TxMoed
Função para retornar a taxa da moeda no cálculo do IRRF na baixa

@param dData, date, Data de referência para a contação da moeda
@return nRet, Taxa da moeda 

@author pequim
@since 05/03/2020
@version 1.0
@type Function
/*/
//---------------------------------------------------------------------------------------
Function F080TxMoed(dData)

	Local nTaxMoeda := 0 

	DEFAULT dData := dDataBase

	If SE2->E2_MOEDA > 1 	
		If __nTxMoeAt > 0
			nTaxMoeda := __nTxMoeAt
		Else	
			nTaxMoeda := If(SE2->E2_TXMOEDA > 0, SE2->E2_TXMOEDA, RecMoeda(dData,SE2->E2_MOEDA) )
		Endif
	Endif

Return nTaxMoeda

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080PCCBx
Verifica se o título possui TX de PCC Gerado na Baixa e já baixado

@author Karen Honda
@since 04/08/2010
/*/
//-------------------------------------------------------------------
Function Fa080PCCBx(cSeqBx As Character, lSeek As Logical) as Logical
	Local lTemBx	as Logical //informa se o título principal possui TX de IR Gerado na Baixa e já baixado.
	Local nX 		as Numeric
	Local aAreaSe2  as Array
	Local cNatPis 	as Character 
	Local cNatCof	as Character 
	Local cNatCsl	as Character 

	Local aImpPIS	as Array
	Local aImpCOF	as Array
	Local aImpCSL	as Array

	Default cSeqBx	:= SE5->E5_SEQ
	Default lSeek   := .T.

    //-- Diretiva DEFAULT utilizada na inicalização de Estáticas
    DEFAULT lPCCBaixa := (SuperGetMv("MV_BX10925",.T.,"2") == "1")
	
	lTemBx := .F.
	aAreaSe2  := SE2->(GetArea())

	//Se tem PCC na baixa.
	If lPCCBaixa .Or. ( SE2->E2_TIPO $ MVPAGANT )
		cNatPis := SuperGetMv("MV_PISNAT",.T.,"PIS")
		cNatCof	:= SuperGetMv("MV_COFINS",.T.,"COF")
		cNatCsl	:= SuperGetMv("MV_CSLL",.T.,"CSL")

		aImpPIS	:= ImpCtaPg(cNatPis, lSeek)
		aImpCOF	:= ImpCtaPg(cNatCof, lSeek)
		aImpCSL	:= ImpCtaPg(cNatCsl, lSeek)

		For nX := 1 to Len(aImpPIS)
			SE2->(DBGoto(aImpPIS[nX][9]))
			If SE2->E2_SEQBX == cSeqBx .and. SE2->E2_VALOR != SE2->E2_SALDO
				lTemBx := .T.
				Exit
			EndIf
		Next nX
		If !lTemBx
			For nX := 1 to Len(aImpCOF)
				SE2->(DBGoto(aImpCOF[nX][9]))
				If SE2->E2_SEQBX == cSeqBx .and. SE2->E2_VALOR != SE2->E2_SALDO
					lTemBx := .T.
					Exit
				EndIf
			Next nX

			If !lTemBx
				For nX := 1 to Len(aImpCSL)
					SE2->(DBGoto(aImpCSL[nX][9]))
					If SE2->E2_SEQBX == cSeqBx .and. SE2->E2_VALOR != SE2->E2_SALDO
						lTemBx := .T.
						Exit
					EndIf
				Next nX
			EndIf

		EndIf

		FwFreeArray(aImpCSL)
		FwFreeArray(aImpCOF)
		FwFreeArray(aImpPIS)

	EndIf

	SE2->(RestArea(aAreaSe2))
	FwFreeArray(aAreaSe2)

Return lTemBx

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa080ISSBx
Verifica se o título possui TX de ISS Gerado na Baixa e já baixado

@author Karen Honda
@since 04/08/2010
/*/
//-------------------------------------------------------------------
Function Fa080ISSBx(cSeqBx as Character, lSeek As Logical) as Logical
	Local lRet  		as Logical //informa se o título principal possui TX de IR Gerado na Baixa e já baixado.
	Local aAreaSe2  	as Array
	Local lCalcIssBx 	as Logical
	Local cNatISS 		as Character
	Local aImpISS 		as Array
	Local nX			as Numeric

	Default cSeqBx	 := SE5->E5_SEQ
	Default lSeek    := .T.

	aAreaSe2  := SE2->(GetArea())

	lRet := .F.

	lCalcIssBx	:= IsIssBx("P")

	//Se tem ISS na baixa.
	If lCalcIssBx .Or. ( SE2->E2_TIPO $ MVPAGANT )
		cNatISS    := &(SuperGetMv("MV_ISS",.T.,"'ISS'"))
		aImpISS	:= ImpCtaPg(cNatISS, lSeek)

		For nX := 1 to Len(aImpISS)
			SE2->(DBGoto(aImpISS[nX][9]))
			If SE2->E2_SEQBX == cSeqBx .and. SE2->E2_VALOR != SE2->E2_SALDO
				lRet := .T.
				Exit
			EndIf
		Next nX	

		FwFreeArray(aImpISS)

	EndIf
	
	SE2->(RestArea(aAreaSe2))
	FwFreeArray(aAreaSe2)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} IsBxEsFK2
Verifica se a baixa SE5 se encontra na FK2
(para ter certeza que a chave do título é da carteira a pagar)

@author rafael.rondon
@since 15/10/2020
/*/
//-------------------------------------------------------------------
Static Function IsBxEsFK2(cIdFK2 As Character) AS Logical

	Local lRet 		:= .F. As Logical
	Local cQry 		:= ""  As Character

	Default cIdFK2 := ""

	If __oObJFK2 == NIL
		cQry 	:= " SELECT COUNT(*) QUANT FROM ? "
		cQry 	+= " WHERE D_E_L_E_T_ = ? "
		cQry 	+= " AND FK2_FILIAL = ? "
		cQry 	+= " AND FK2_IDFK2 = ? "
		cQry := ChangeQuery(cQry)
		__oObJFK2 := FWPreparedStatement():New(cQry)
	EndIf

	__oObJFK2:setUnsafe(1, RetSqlName('FK2'))
	__oObJFK2:SetString(2, " ")
	__oObJFK2:SetString(3, xFilial("FK2"))
	__oObJFK2:SetString(4, cIdFK2)

	cQry := __oObJFK2:GetFixQuery()

	lRet	:= (MpSysExecScalar(cQry,"QUANT") == 1)

Return lRet

/*/{Protheus.doc} F080TemMR
	Verifica se o fornecedor em questão possui amarração com o 
	configurador de tributos

	@Type Static Function
	@author Vitor Duca
	@since 03/12/2020
	@version 1.0
	@param cCodFor, Character, Codigo do fornecedor
	@param cLoja, Character, Loja do fornecedor
	@return lRet, Logical, Se achou a amarração com o configurador
	@example
	F080TemMR(SA2->A2_COD,SA2->A2_LOJA)
/*/
Static Function F080TemMR(cCodFor As Character, cLoja As Character) As Logical
	Local lRet As Logical
	Local aArea As Array

	Default cCodFor := ""
	Default cLoja	:= ""

	aArea := GetArea()
	lRet := .F.

	FOK->(DbSetOrder(1))
	lRet := FOK->(MsSeek(xFilial("FOK")+cCodFor+cLoja))

	RestArea(aArea)
Return lRet


//-------------------------------------------------------------------------
/*/{Protheus.doc} f080CRatIR
Função para criar o objeto __oRatIRF

@author rafael rondon
@since  14/06/2021
@version 12.1.33
@param 
/*/
//-------------------------------------------------------------------------
Function f080CRatIR() As Object

Local cCdRetIRRt	As Character

cCdRetIRRt    := SuperGetMv("MV_RETIRRT",.T.,"3208")

f080LRatIR(.F.)

If Alltrim(SE2->E2_CODRET) $ cCdRetIRRt
	If FindFunction("FinXRatIR")
		If __oRatIRF == Nil
			__oRatIRF := FinBCRateioIR():New()
		EndIf
		__oRatIRF:SetFilOrig(cFilAnt)
		__oRatIRF:SetForLoja(SE2->E2_FORNECE,SE2->E2_LOJA)
		__oRatIRF:SetIRBaixa(.T.)
	EndIf
EndIf	

Return __oRatIRF

//-------------------------------------------------------------------------
/*/{Protheus.doc} f080LRatIR
Função para limpar o objeto __oRatIRF

@author rafael rondon
@since  14/06/2021
@version 12.1.33
@param lExclui, Logical, Define se ira excluir o Objeto da memoria
/*/
//-------------------------------------------------------------------------
Function f080LRatIR(lExclui as Logical)

    Default lExclui := .T.

    If __oRatIRF <> Nil
        __oRatIRF:Clean()
        If lExclui
            FwFreeObj(__oRatIRF)
            __oRatIRF := Nil
        EndIf    
    EndIf

Return

//-------------------------------------------------------------------------
/*/{Protheus.doc} f080SRatIR
Função para setar o objeto __oRatIRF

@author rafael rondon
@since  14/06/2021
@version 12.1.33
@param oObj, Object, Objeto que sera atribuido ao oRatIrf
/*/
//-------------------------------------------------------------------------
Function f080SRatIR(obj as Object)
    __oRatIRF := obj
Return 

/*/{Protheus.doc} F080ClearM
	Função reponsável por distuir o model criado

	@type  Function
	@author Nilton Rodrigues
	@since 17/01/2022
	@version 12.1.33
	@return Nil
	/*/
Function F080ClearM() 

	If oModelBxP != nil 
		oModelBxP:Destroy()
		oModelBxP:= nil 
	EndIf 

	If oModelMov != nil 
		oModelMov:Destroy()
		oModelMov:= nil 
	EndIf 

Return 

//-------------------------------------------------------------------------
/*/{Protheus.doc} ChekSX1
    Função consultar API SX1

@author Norberto M de Melo
@since  24/08/2022
@version 1
/*/
//-------------------------------------------------------------------------
STATIC FUNCTION ChekSX1(nX1Ordem AS NUMERIC) AS LOGICAL
    LOCAL lRet AS LOGICAL
    LOCAL _oPergunte AS OBJECT

    _oPergunte := FwSx1Util():New()
    _oPergunte:AddGroup("FIN080")
    _oPergunte:SearchGroup()
	IF LEN(_oPergunte:GetGroup("FIN080")) > 1 .AND. !Empty(_oPergunte:GetGroup("FIN080")[2])
        lRet := LEN(_oPergunte:GetGroup("FIN080")[2]) >= nX1Ordem
    ENDIF
    FWFReeObj(_oPergunte)
RETURN lRet

//-------------------------------------------------------------------------
/*/{Protheus.doc} GetFK5IdMv
    Consulta Tabela FK5 por movimentos totalizadores MV_BXCNAB

@author Norberto M de Melo
@since  09/12/2022
@version 1
/*/
//-------------------------------------------------------------------------
STATIC FUNCTION GetFK5IdMv(dDtBaixa AS DATE, cIdProc AS CHARACTER, cFilProc AS CHARACTER) AS LOGICAL
    LOCAL lRet AS LOGICAL
    LOCAL cFK5Tmp AS CHARACTER    
    LOCAL aAreaAtual AS ARRAY

    DEFAULT dDtBaixa := dDataBase
    DEFAULT cIdProc := ""
    DEFAULT cFilProc := cFilAnt

    aAreaAtual := GETAREA()
    cFK5Tmp := GetNextAlias()

	BeginSQL Alias cFK5Tmp
		SELECT  FK5.FK5_FILIAL FILIAL, FKA.FKA_IDPROC IDPROC, FK5.FK5_IDMOV IDMOV, FK5.R_E_C_N_O_ RECNOFK5
		FROM	   %Table:FK5% FK5
        INNER JOIN %Table:SE5% SE5 ON SE5.E5_IDORIG = FK5.FK5_IDMOV
        INNER JOIN %Table:FKA% FKA ON FKA.FKA_IDORIG = SE5.E5_IDORIG
		WHERE	
                FK5.FK5_DATA = %exp:DTOS(dDtBaixa)%
            AND FK5.FK5_TPDOC IN ('BL','VL','CH')
            AND FK5.FK5_BANCO  = %exp:SE5->E5_BANCO%
            AND FK5.FK5_AGENCI = %exp:SE5->E5_AGENCIA%
            AND FK5.FK5_CONTA  = %exp:SE5->E5_CONTA%
            AND FK5.FK5_RECPAG = 'P'
            AND FK5.FK5_LOTE   = %exp:SE5->E5_LOTE%
            AND FK5.%NotDel%
	EndSQL

    IF lRet := !(cFK5Tmp)->(EOF())
        FK5->(DBGOTO((cFK5Tmp)->RECNOFK5))
        cIdProc := (cFK5Tmp)->IDPROC
        cFilProc := (cFK5Tmp)->FILIAL
    ENDIF

    (cFK5Tmp)->(DBCLOSEAREA())
    RESTAREA(aAreaAtual)

RETURN lRet

//-------------------------------------------------------------------------
/*/{Protheus.doc} F080RAltBx
Retorna o valor da variável __lAltVrBx, indicando que houve alteração de valor

@author Pâmela Bernardo
@since  20/12/2022
@version 1
/*/
//-------------------------------------------------------------------------
Function F080RAltBx() 

Return __lAltVrBx

//-------------------------------------------------------------------------
/*/{Protheus.doc} F080RatIr
Retorna array do rateio de IRPF, indicando que houve alteração de valor

@author Pâmela Bernardo
@since  12/01/2022
@version 1
/*/
//-------------------------------------------------------------------------
Function F080RatIr()
	Local aRet As Array

	aRet := {}
	If __oRatIRF <> Nil
		aRet := __oRatIRF:aRatIRF
	EndIf
	
Return aRet

//-------------------------------------------------------------------------
/*/{Protheus.doc} FA080IRPF
Retorna Logical que avalia se o Ir é pela Baixa

@author Jailton Urbano
@since  06/06/2023
@version 1
/*/
//-------------------------------------------------------------------------
Static Function FA080IRPF()
	Local lRet As Logical
	lRet :=	.f.

	If cPaisLoc == "BRA" .And. ;
		(!_lIrfMR .And. SA2->A2_CALCIRF == "2") .And. ;
		(Posicione("SED",1,xfilial("SED") + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S") .And. ;
		!SE2->E2_TIPO $ MVPAGANT
		lRet := .t.
	EndIf

Return lRet

/*/{Protheus.doc} fa080Exc
	Botão de exclusão da baixa a receber, que redireciona para a mesma função
	responsavel pelo cancelamento da baixa.

	Obs: Necessário chamar o botão com uma função diferente para que a
	rotina de 'Privilegio' (SIGACFG) possa diferenciar a ação do usuario.
	
	@author fabio.casagrande
	@since 25/03/2024
/*/
Function fa080Exc(cAlias, nReg, nOpcx, aEncho, nOpbaixa)

	Default cAlias := "SE2"
	Default nReg := 0
	Default nOpcx := 0
	Default aEncho  := {}
	Default nOpbaixa := 0

	fa080Can(cAlias, nReg, nOpcx, aEncho, nOpbaixa)

Return


/*/{Protheus.doc} ClearIdPai
	Limpa campo FK7_IDPAI do titulo filho, desvinculando os titulos pai e filho.	
	
	@author rafael.rondon
	@since 13/03/2025
/*/
Static Function ClearIdPai( cChaveFK7 as character, cAlias as character)

	Local aArea		:= FWGetArea()		as array
	Local cIdDoc	:= ''				as character

	Default cChaveFK7	:= ''
	Default cAlias		:= ''	

	If __lFK7IDPA == NIL
		__lFK7IDPA := FK7->(FieldPos("FK7_IDPAI")) > 0
	EndIf

	If __lFK7IDPA

		cIdDoc	:= FINGRVFK7(cAlias , cChaveFK7) 

		dbSelectArea('FK7')
		FK7->(DBSetOrder(1)) // FK7_FILIAL+FK7_IDDOC                                                                                                                                            
		If FK7->(DBSeek(xFilial('FK7') + cIdDoc))
			Reclock('FK7',.F.)
				FK7->FK7_IDPAI := ''
			FK7->(MSUnlock())
		EndIf
	EndIf

	FWRestArea(aArea)

Return

/*/{Protheus.doc} F080TitPai
	Busca a tabela e chave do titulo pai.

	@param cAliasTit, character, tabela do titulo filho
	@param cChaveTit, character, chave do titulo filho

	@return aFK7TitPai, array,	aFK7TitPai[1] - chave do titulo pai
								aFK7TitPai[2] - tabela do titulo pai
	@type  Static Function
	@author Marcos Pires
	@since 07/10/2025
/*/
Static Function F080TitPai(cAliasTit as Character, cChaveTit as Character) as Array
Local lUseClass    as Logical
Local oObjTitPai   as Object
Local aFK7TitPai   as Array
Local cIDDoc       as Character

Default cAliasTit := ""
Default cChaveTit := ""

lUseClass  := FindClass('totvs.protheus.backoffice.fin.bills.related.BillRelated')
oObjTitPai := Nil
aFK7TitPai := {"",""}
cIdDoc     := ""

If lUseClass
	oObjTitPai := totvs.protheus.backoffice.fin.bills.related.BillRelated():New()
	lUseClass := oObjTitPai:canUseRelatedBill()
EndIf

If lUseClass
	cIdDoc := FinBuscaFK7(cChaveTit, cAliasTit)
	If Empty(cIDDoc) .Or. Empty(FK7->FK7_IDPAI)
		aFK7TitPai := oObjTitPai:getTitPai('SE2', cChaveTit )
	EndIf
EndIf

FWFreeObj(oObjTitPai)

Return aFK7TitPai

//-------------------------------------------------------------------------------------
/*{Protheus.doc} reposSA6
    @description Reposiciona na SA6 caso os campos de banco não forem vazios e se os 
					mesmos forem diferentes da posição atual da SA6.
				Função utilizada após voltar do ponto de entrada FA080POS.
    
    @author guilhermed.santos
    @since 17/12/2025
    @return Nil
*/
//-------------------------------------------------------------------------------------
static function reposSA6()
	local aAreaSA6 as array

	aAreaSA6 := {}

	if !(empty(cBanco) .or. empty(cAgencia) .or. empty(cConta)) .and. (cBanco <> SA6->A6_COD .or. cAgencia <> SA6->A6_AGENCIA .or. cConta <> SA6->A6_NUMCON)

		aAreaSA6 := SA6->(getArea())

		dbSelectArea("SA6")
		SA6->(dbSetOrder(1)) //A6_FILIAL+A6_COD+A6_AGENCIA+A6_NUMCON
		if !SA6->(dbSeek(xFilial("SA6") + cBanco + cAgencia + cConta))
			restArea(aAreaSA6)
		endIf
	endIf

return
