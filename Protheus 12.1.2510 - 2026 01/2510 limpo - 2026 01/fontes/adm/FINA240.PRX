#Include "FINA240.ch"
#Include "PROTHEUS.Ch"
#Include "topconn.ch"
#Include "FwLibVersion.ch"

Static nLote
Static aSelFil		:= {}
Static lFWCodFil 	:= .T.
Static aPswUser		:= nil
Static aPswGrupo	:= nil
Static lF240Des 	:= ExistBlock("F240Des")
Static lF240EASY 	:= ExistBlock("F240EASY")
Static lF240ADCM 	:= ExistBlock("F240ADCM")
Static lF240GAVE 	:= ExistBlock("F240GAVE")
Static lF240FIL 	:= ExistBlock("F240FIL")
Static lF240MARK 	:= ExistBlock("F240MARK")
Static lF240NBOR 	:= ExistBlock("F240NBOR")
Static lF240FPGT	:= Existblock("F240FPGT")
Static lF240AFIL 	:= ExistBlock("F240AFIL")
Static lF240ARQ		:= ExistBlock("F240ARQ")
Static lF240ALMOD	:= ExistBlock("F240ALMOD")
Static lF240ICNB	:= ExistBlock("F240ICNB")
Static lFA240NAR	:= ExistBlock("FA240NAR")
Static lF240TIT		:= ExistBlock("F240TIT")
Static lF240OK2		:= ExistBlock("F240OK2")
Static lF240IND		:= NIL
Static __oFIN2401  := NIL
Static __lFina241	:= .F.
Static aIndices		:= {}
Static aPesqui		:= {}
Static aCbx			:= {}
Static lFKDBx		:= ExistFunc("FAtuFKDBx")	//  VA
Static __lMotorRet	:= NIL
Static __oFIN2402	:= NIL
Static nF240Index	:= 1
Static aNewIndex	:= Nil
Static lSubCtaEA	:= .F.
Static __l241Canc   := Nil
Static _oBorDtCan	:= Nil
Static __lAPICP     := NIL
Static __lExecSt    := NIL
Static __oQueryFKF  as Object
Static __of240qryA  as Object
//-----------------------------------------
/*/{Protheus.doc} FinA240
Envia titulo para bordero de Pagamento

@type function
@author Wagner Xavier
@since 21/05/1993
@version 1.0

/*/
//-----------------------------------------
Function FinA240(nPosArotina,lAutomato)

	LOCAL lBrowse 	:= ExistBlock("F240BROWSE")
	LOCAL cBrowse	:= ""

	SetKey (VK_F12,{|a,b| AcessaPerg("F240BR",.T.)})
	pergunte("F240BR",.F.)

	DEFAULT nPosArotina := 0
	DEFAULT lAutomato   := .F.

	//------------------------------------------------------------------------
	// Parametros
	//------------------------------------------------------------------------
	// mv_par01			Considera Titulos ?	  			Normais / Adiantamentos
	// mv_par02		Considera Filial ?  			(apenas Codebase)
	// mv_par03		Da Filial ?						(apenas Codebase)
	// mv_par04		Ate a Filial ?					(apenas Codebase)
	// mv_par05		Marcar Titulos Automatic. ?
	// mv_par06		Calculo dos Impostos ?			1-Vencimento Real
	// 			                                 	2-Geracao Bordero
	//												3-Ambas
	// mv_par07		Mostra Lancamento ?
	// mv_par08		Seleciona Filiais ?				(apenas TOP)
	//------------------------------------------------------------------------

	PRIVATE cFil240		:= ""
	PRIVATE c240FilBT	:= space(60)
	Private aRotina		:= MenuDef()
	Private xConteudo
	Private cPadrao 	:= ""
	Private cBanco   	:= CriaVar("E1_PORTADO")
	Private cAgencia 	:= CriaVar("E1_AGEDEP")
	Private cConta 		:= CriaVar("E1_CONTA")
	Private cCtBaixa 	:= GetMv("MV_CTBAIXA")
	Private cAgen240 	:= CriaVar("A6_AGENCIA")
	Private cConta240	:= CriaVar("A6_NUMCON")
	Private cModPgto  	:= CriaVar("EA_MODELO")
	Private cTipoPag 	:= CriaVar("EA_TIPOPAG")
	Private cMarca   	:= GetMark( )
	Private cCadastro
	Private aGetMark 	:= {}

	lSubCtaEA := SEA->(FieldPos("EA_SUBCTA")) > 0

	// Procura o Lote do Financeiro
	LoteCont( "FIN" )

	__lExecSt	 	:= FwLibVersion() >= "20211116"
	cCadastro := STR0005  //"Border“ de Pagamentos"

	dbSelectArea("SE2")

	If lBrowse
		cBrowse := ExecBlock("F240BROWSE",.F.,.F.)
	EndIf

	If nPosArotina > 0 // Sera executada uma opcao diretamento de aRotina, sem passar pela mBrowse
		dbSelectArea("SE2")
		bBlock := &( "{ |a,b,c,d,e| " + aRotina[ nPosArotina,2 ] + "(a,b,c,d,e) }" )
		Eval( bBlock, Alias(), (Alias())->(Recno()),nPosArotina,lAutomato)
	Else
		mBrowse( 6, 1,22,75,"SE2",,"E2_NUMBOR",,,,FA040Legenda("SE2"),,,,,,,,IIf(lBrowse, cBrowse, Nil))
	Endif

	dbSelectArea("SE2")

Return

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA240Borde
Define os titulos a serem incluidos no bordero do pagamento

@type function
@author Wagner Xavier
@since 21/05/1993
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function FA240Borde(cAlias,nReg,nOpcx,lAutomato)
	Local lPanelFin 	:= IsPanelFin()
	Local oPanel		:= NIL
	Local cMoeda240		:= ""
	Local cVar 			:= ""
	Local lInverte	 	:= .F.
	Local aMoedas 		:= GetMoedas()
	Local oFnt 			:= NIL
	Local cContrato		:= CriaVar("E9_NUMERO")
	Local cSubconta		:= CriaVar("EE_SUBCTA")
	Local nSavRec		:= SE2->(RecNo())
	Local nHdlLock		:= 0
	Local nOpca			:= 0
	Local cSetFilter	:= SE2->(DBFILTER()) // Salva o filtro atual, para restaurar no final da rotina
	Local cOldPort240	:= ""
	Local bOk1			:= NIL
	Local bOk2			:= NIL
	Local bOk3			:= NIL
	Local cMv_par01		:= ""
	Local nMv_par02		:= 0 //salvar os parametros anteriores
	Local aSize 		:= {}
	Local aCampos 		:= {}
	Local aRestrict		:= {}
	Local cArqNew		:= ""
	Local lTEMP			:= .F.
	Local aVars			:= {}
	Local aVarsOld		:= {}
	Local nX			:= 0
	Local cIndTemp1		:= CriaTrab(,.F.)
	Local cIndTemp2		:= CriaTrab(,.F.)
	Local nEspLarg		:= 2
	Local nEspLin		:= 2
	Local aBut240		:= {}
	Local bSet16
	Local nIndice		:= 1
	Local lBlqBor		:= .T.
	Local aAltMark		:= {}
	Local nPos			:= 0
	Local lIntPFS		:= SuperGetMv("MV_JURXFIN",.T.,.F.)
	Local aCores		:= {}
	Local aLegenda		:={	{"BR_VERDE"   ,STR0096},;	//"Disponivel"
							{"BR_VERMELHO",STR0097}}    //"Bloqueado por Rateio"
	Local lFinVDoc		:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios
	Local nOrdem  		:= 0
	Local lPAOk	  		:= !GetNewPar("MV_VLTITAD",.F.)
	Local lPrimeiro		:=.T. //na pre marcação, indica se deve mostrar ou não o help. Para multiplas marcações, deve mostrar apenas uma vez, quando possui docs
	Local aTmpFil		:= {}
	Local lF240TBor		:= ExistBlock("F240TBOR")
	Local lF240Semaf	:= ExistBlock("F240SEMA")
	Local lF240Bord		:= ExistBlock("F240BORD")
	Local lF240TDOK		:= ExistBlock("F240TDOK")
	Local lF240BTN		:= ExistBlock("F240BTN")
	Local l240Bor		:= ExistBlock("F240BOR")
	Local lPergDtAg  	:= Type("mv_par11") == "D" .and. Type("mv_par12") == "D" .and. mv_par10 == 1
	Local dDtAgIni   	:= ""
	Local dDtAgFim   	:= ""
	Local lSE2DtBor		:= 	(cPaisLoc == "BRA")
	Local lJFilBco      := SuperGetMv( "MV_JFILBCO", .F., .F. ) .And. FindFunction("JURF3SA6") .And. FindFunction("JurVldSA6") //Indica se filtra as contas correntes vinculadas ao escritório logado - SIGAPFS.
	Local cEscrit       := Iif(lJFilBco, JurGetDados("NS7", 4, xFilial("NS7") + cFilant + cEmpAnt, "NS7_COD"), "") // Código do escritório relacionado a filial logada - SIGAPFS.
	Local cF3Bco        := Iif(lJFilBco, "SA6JUR", "SA6")
	Local lIsBlind      := IsBlind()
	Local l240Versao	:= SEA->( ColumnPos( "EA_VERSAO" ) ) > 0
	Local lCanBorder	:= GetMv("MV_CANBORP") == "S"//Cancelamento do borderô
	Local cFilSEA       := ""
	Local nTamNroBor    := Len(SE2->E2_NUMBOR)
	Local cQuery        := ""
	Local cTiposAbat    := ""
	Local nErro         := 0
	Local nIndiceSE2    := 1
	Local cFilBor		:= ""
	Local oGetBco		As Object
	Local oGetAge		As Object
	Local oGetCon		As Object 
	
	Private cAliasSE2	:= "SE2"
	Private lVldAD		:= .F.
	Private nValor		:= 0
	Private nQtdTit 	:= 0
	Private cPort240 	:= Criavar("EF_BANCO")
	Private nMoeda		:= 1
	Private dVenIni240	:= dDataBase
	Private dVenFim240	:= dDataBase
	Private cNumBor 	:= Space(6)
	Private nLimite 	:= 0
	Private lChkTCB	 	:= .F.
	Private lChkAPI	 	:= .F.
	Private lLibTCB	 	:= .F.
	Private lLibAPI	 	:= .F.
	Private lVldBco		:= .T.

	//Variaveis que serão utilizadas na consulta padrão SEEBOR
	PRIVATE cPort060	:= Criavar("EF_BANCO",.F.)
	Private cAgen060    := CriaVar("EF_AGENCIA",.F.)
	Private cConta060   := Criavar("EF_CONTA",.F.)

	DEFAULT lAutomato := .F.

	If lF240IND == NIL
		lF240IND		:= ExistBlock("F240IND")
	Endif

	aBut240 := {{"PESQUISA",{||Fa240Pesq(oMark,cAliasSE2,nIndice)}, STR0053,STR0001}} //"Pesquisar..(CTRL-P)"###"Pesquisar"
	bSet16 := SetKey(16,{||Fa240Pesq(oMark,cAliasSE2,nIndice)})

	// Verifica se data do movimento Não ‚ menor que data limite de movimentacao no financeiro
	If !DtMovFin(,,"1")
		Return
	Endif

	// Semáforo para utilização do Bordero
	// Não permite o acesso simultãneo … rotina por mais de 1 usuario.
	If lF240Semaf

		// Ponto de entrada para executar o semaforo
		If ExecBlock("F240SEMA",.F.,.F.)
			IF ( nHdlLock := MSFCREATE("FINA240.L"+cEmpAnt)) < 0
				MsgAlert(STR0042+chr(13)+chr(10)+;	// "A Funcao de geracao de bordero esta sendo utilizada por"
							STR0043+chr(13)+chr(10)+;	// "outro usuario. Por questoes de integridade de dados, nao"
							STR0044+chr(13)+chr(10)+;	// "‚ permitida a utilização desta rotina por mais de um usu rio"
							STR0045,STR0005)				// "simultaneamente. Tente novamente mais tarde."###Border“ de Pagamentos
				Return
			Endif

			// Grava no sem foro informa‡”es sobre quem est  utilizando o Bordero
			FWrite(nHdlLock,"Operador: "+cUserName+chr(13)+chr(10)+;
							"Empresa.: "+cEmpAnt+chr(13)+chr(10)+;
							"Filial..: "+cFilAnt+chr(13)+chr(10))
		Endif
	Endif

	// Verifica numero do ultimo Bordero Gerado	
	If Empty(cNumBor := GetMV("MV_NUMBORP"))
		cNumbor := "000000"
	EndIf
	
	cFilBor	:= SX6->X6_FIL
	cNumBor := Soma1(Pad(cNumbor, nTamNroBor), nTamNroBor)	 
	cFilSEA := xFilial("SEA")
	SEA->(dbSetOrder(2))
	
	While .T.
		If SEA->(DbSeek(cFilSEA + cNumBor + "P", .T.))
			cNumBor := Soma1(cNumBor)
		Else
			Exit
		Endif
	Enddo		
	
	SEA->(dbSetOrder(1))
	
	If GetNewPar("MV_VLTITAD",.F.)
		Aadd(aBut240, { 'PENDENTE', { || F090VlMark(.T.,cAliasSE2,cMarca,oValor,oQtda,oMark,nValor,"FINA240")}, STR0056, STR0057 } ) //"Verifica se ha Titulos com Adiantamento ou Devolucao"###"Validador"
	Endif
	
	If lIntPFS
		Aadd( aBut240, { 'BR_VERDE', { || BrwLegenda(STR0081,STR0082,aLegenda) }, STR0083, STR0081 } ) //"Documento"###"Status"###"Legenda"###"Legenda"
	EndIf

	While .T.

		// Inicializa variaveis de banco, agencia e conta
		cPort240  := Criavar("A6_COD")
		cAgen240  := CriaVar("A6_AGENCIA")
		cConta240 := CriaVar("A6_NUMCON")

		// Busca por um novo numero de bordero (ainda nao usado)
		lTEMP := .F.

		//Guardo o indice de entrada para a rotina de pesquisa
		nIndice := SE2->(IndexOrd())

		While .T.
			If !MayIUseCode("E2_NUMBOR" + cFilBor + cNumBor)  //verifica se esta na memoria, sendo usado busca o proximo numero disponivel
				cNumBor := Soma1(cNumBor)
			Else
				Exit
			EndIf
		Enddo

		cMoeda240 := cVar := aMoedas[1]
		nOpc      := 0
		
		If !lF240GAVE
			aSize := MSADVSIZE()
			
			If lPanelFin //Chamado pelo Painel Financeiro
				dbSelectArea(cAlias)
				oPanelDados := FinWindow:GetVisPanel()
				oPanelDados:FreeChildren()
				aDim := DLGinPANEL(oPanelDados)
				DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )
				//-------------------------------------------------------------------------
				// Observacao Importante quanto as coordenadas calculadas abaixo:
				// ------------------------------------------------------------------------
				// a funcao DlgWidthPanel() retorna o dobro do valor da area do	painel,
				// sendo assim este deve ser dividido por 2 antes da subtracao e redivisao
				// por 2 para a centralizacao. 					 ³
				//-------------------------------------------------------------------------
				nEspLarg := ((DlgWidthPanel(oPanelDados)/2) - 196) /2
				nEspLin  := 0
			Else
				nEspLarg := 2
				nEspLin  := 2
				DEFINE MSDIALOG oDlg FROM  15,6 TO 380,412 TITLE STR0014 PIXEL  //"Border“s de Pagamentos"  
			Endif

			oDlg:lMaximized := .F.
			oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
			oPanel:Align := CONTROL_ALIGN_ALLCLIENT

			@ 00+nEspLin,  nEspLarg TO 32+nEspLin,  200+nEspLarg OF oPanel  PIXEL 
			@ 34+nEspLin,  nEspLarg TO 91+nEspLin,  200+nEspLarg OF oPanel  PIXEL
			@ 93+nEspLin,  nEspLarg TO 120+nEspLin, 200+nEspLarg OF oPanel  PIXEL
			@ 122+nEspLin, nEspLarg TO 160+nEspLin, 200+nEspLarg OF oPanel  PIXEL

			nEspLarg := nEspLarg -1
			
			@ 06+nEspLin, 009+nEspLarg SAY STR0015	   SIZE 23, 7 OF oPanel PIXEL  //"N£mero"
			@ 06+nEspLin, 045+nEspLarg SAY STR0016		SIZE 32, 7 OF oPanel PIXEL  //"Vencto de"
			@ 06+nEspLin, 090+nEspLarg SAY STR0017		SIZE 32, 7 OF oPanel PIXEL  //"At‚"
			@ 06+nEspLin, 135+nEspLarg SAY STR0018		SIZE 53, 7 OF oPanel PIXEL  //"Limite Valor"
			@ 40+nEspLin, 009+nEspLarg SAY STR0019		SIZE 23, 7 OF oPanel PIXEL  //"Banco"
			@ 40+nEspLin, 045+nEspLarg SAY STR0020		SIZE 32, 7 OF oPanel PIXEL  //"Agˆncia"
			@ 40+nEspLin, 085+nEspLarg SAY STR0021		SIZE 32, 7 OF oPanel PIXEL  //"Conta"
			@ 40+nEspLin, 151+nEspLarg SAY STR0142		SIZE 53, 7 OF oPanel PIXEL  //"Sub Conta"
			@ 67+nEspLin, 009+nEspLarg SAY STR0022		SIZE 53, 7 OF oPanel PIXEL  //"Contrato"
			@ 130+nEspLin, 009+nEspLarg SAY STR0023		SIZE 23, 7 OF oPanel PIXEL  //"Moeda"
			@ 130+nEspLin, 063+nEspLarg SAY STR0024		SIZE 22, 7 OF oPanel PIXEL  //"Modelo"
			@ 130+nEspLin, 097+nEspLarg SAY STR0025		SIZE 32, 7 OF oPanel PIXEL  //"Tipo Pagto"

			IF l240Bor
				lBlqBor:= ExecBlock("F240BOR",.F.,.F.,{lBlqBor})
			Endif

			//Linha 1
			@ 15+nEspLin, 009+nEspLarg MSGET cNumBor         		SIZE 32, 10 OF oPanel PIXEL ;
			Picture "@!" Valid If(!Empty(cNumBor).And.FA240Num(cNumBor, cFilBor),.T.,.F.) when lBlqBor
			@ 15+nEspLin, 045+nEspLarg MSGET dVenIni240        	SIZE 45, 10 OF oPanel PIXEL  HASBUTTON
			@ 15+nEspLin, 090+nEspLarg MSGET dVenFim240        	SIZE 45, 10 OF oPanel PIXEL  HASBUTTON ;
															Valid   If(nOpc<>0,FA240DATA(dVenIni240,dVenFim240),.T.)
			@ 15+nEspLin, 135+nEspLarg MSGET nLimite         		SIZE 60, 10 OF oPanel PIXEL HASBUTTON ;
															Picture "@E 999,999,999,999.99"  Valid If(nOpc<>0,nLimite >= 0,.T.)
			//Linha 2
			@ 49+nEspLin,   9+nEspLarg MSGET oGetBco VAR cPort240        		SIZE 10, 10 OF oPanel PIXEL HASBUTTON Picture "@!" F3 cF3Bco;
				Valid F240VldBco(@cPort240,@cAgen240,@cConta240,.F.,.F., oGetAge) .And. Iif(lJFilBco, JurVldSA6("1", {cEscrit, cPort240, cAgen240, cConta240}), .T.) ON CHANGE F240CHKTCB(oTcb, oApi, 1)
			@ 49+nEspLin,  45+nEspLarg MSGET oGetAge VAR cAgen240        		SIZE 26, 10 OF oPanel PIXEL Picture "@!"  ;
				Valid F240VldBco(@cPort240,@cAgen240,@cConta240,.F.,.F., oGetCon) .And. Iif(lJFilBco, JurVldSA6("2", {cEscrit, cPort240, cAgen240, cConta240}), .T.) ON CHANGE F240CHKTCB()
			@ 49+nEspLin,  85+nEspLarg MSGET oGetCon VAR cConta240       		SIZE 62, 10 OF oPanel PIXEL Picture "@!"  ;
				Valid F240VldBco(@cPort240,@cAgen240,@cConta240,.T.,.T., oGetBco) .And. Iif(lJFilBco, JurVldSA6("3", {cEscrit, cPort240, cAgen240, cConta240}), .T.) ON CHANGE F240CHKTCB()		
			@ 49+nEspLin, 151+nEspLarg MSGET cSubconta       		SIZE 42, 10 OF oPanel PIXEL Picture "@S3" F3 "SEEBOR" Valid Iif(!F240CHKSUBC(cPort240,cAgen240,cConta240,cSubconta),.F.,.T.)	 	

			//Linha 3
			@ 095+nEspLin, 009+nEspLarg CHECKBOX    oTcb VAR lChkTCB PROMPT STR0141 When (.F.) SIZE 140,15 OF oDlg PIXEL  Valid   If(lChkTCB, F240ARQTCB(),.T.) ON CHANGE F240CHKTCB(oTcb, oApi, 2)
			@ 75+nEspLin, 009+nEspLarg MSGET cContrato       		SIZE 42, 10 OF oPanel PIXEL Picture "@S3"

			@ 110+nEspLin, 009+nEspLarg CHECKBOX    oApi VAR lChkAPI PROMPT STR0151 When (lLibAPI) SIZE 140,15 OF oDlg PIXEL  ON CHANGE F240CHKTCB(oTcb, oApi, 3) 
			
			@ 140+nEspLin, 009+nEspLarg MSCOMBOBOX oCbx VAR cMoeda240 ITEMS aMoedas SIZE 46, 13 OF oPanel PIXEL ;
						Valid F240VldMd(cPort240,cAgen240,cConta240,Val(cMoeda240))
			
			
			@ 140+nEspLin, 063+nEspLarg MSGET cModPgto SIZE 25, 10 OF oPanel PIXEL Picture "@!"  Valid F240CHKMOD(nOpc, cModPgto) F3 "58" HASBUTTON
			@ 140+nEspLin, 097+nEspLarg MSGET cTipoPag SIZE 25, 10 OF oPanel PIXEL Picture "@!"  Valid If(nOpc<>0,ExistCpo("SX5", + "59" + cTipoPag),.T.) F3 "59" HASBUTTON

			If lPanelFin //Chamado pelo Painel Financeiro
				oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])
				ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
				{||cVar:=cMoeda240,nOpc:=1,Iif(F240TudoOk(oDlg),oDlg:End(),nOpc:=0)},;
				{||oDlg:End()})

				cAlias := FinWindow:cAliasFile
				dbSelectArea(cAlias)

			Else
				DEFINE SBUTTON FROM 169, 142 TYPE 1 ENABLE OF oPanel ACTION (cVar:=cMoeda240,nOpc:=1,;
																			Iif(F240TudoOk(oDlg),oDlg:End(),nOpc:=0))
				DEFINE SBUTTON FROM 169, 170 TYPE 2 ENABLE OF oPanel ACTION oDlg:End()

				ACTIVATE MSDIALOG oDlg CENTERED
			Endif
		Else
			AADD(aVars,cNumBor)
			AADD(aVars,dVenIni240)
			AADD(aVars,dVenFim240)
			AADD(aVars,nLimite)
			AADD(aVars,cPort240)
			AADD(aVars,cAgen240)
			AADD(aVars,cConta240)
			AADD(aVars,cContrato)
			AADD(aVars,cMoeda240)
			AADD(aVars,aMoedas)

			AADD(aVars,cModPgto)
			AADD(aVars,cTipoPag)
			AADD(aVars,nOpc)
			aVarsOld := aVars
			aVars := Execblock("F240GAVE",.F.,.F.,aVars)

			//Valida retorno do PE F240GAVE
			If ValType(aVars) != "A" .OR. Len(aVars) < 13
				aVars := aVarsOld
				ConOut("Retorno do PE F240GAVE invalido.")
			Endif

			cNumBor   := aVars[1]
			dVenIni240:= aVars[2]
			dVenFim240:= aVars[3]
			nLimite   := aVars[4]
			cPort240  := aVars[5]
			cAgen240  := aVars[6]
			cConta240 := aVars[7]
			cContrato := aVars[8]
			cMoeda240 := aVars[9]
			aMoedas   := aVars[10]
			cModPgto  := aVars[11]
			cTipoPag  := aVars[12]
			nOpc      := aVars[13]
			cVar      := cMoeda240
		Endif

		If lPergDtAg
			dDtAgIni := mv_par11
			dDtAgFim := mv_par12
		EndIf

		fa240Perg()

		// Recupera os valores da conf. apos inicializacao
		If lPergDtAg
			If !Empty(dDtAgFim) .and. Empty(mv_par11)
				mv_par11 := dDtAgIni
				mv_par12 := dDtAgFim
			EndIf
		EndIf

		If nOpc != 1
			DbClearFilter()
			dbSetOrder(1)
			Exit
		EndIF
		nMoeda := Val(Substr(cVar,1,2))

		// Execblock a ser executado antes da Indregua
		IF lF240FIL
			cMv_par01 := mv_par01
			nMv_par02 := mv_par02
			cFil240 := ExecBlock("F240FIL",.f.,.f.)
			mv_par01 := cMv_par01
			mv_par02 := nMv_par02
		Else
			cFIl240 := ""
		Endif

		//Gestao - Selecao de filiais
		aSelFil	:= {}
		
		If (lLibTCB .Or. lIsBlind .Or. mv_par08 == 2)
			aSelFil := {cFilAnt}
		Else
			aSelFil := AdmGetFil(.F.,.T.,"SE2")
			
			If Len(aSelFil) == 0
				Exit
			EndIf		
		EndIf

		//Inicializa o array aRestrict com campos que devem ser apresentados,independente das configuração do dicionário.
		aRestrict := F240Restr(lAutomato)
		lTEMP     := .T.
		cAliasSE2 := "SE2TMP"
		
		//Funcao para montar e processar a query
		cArqNew := F240QryA(.F., cAliasSE2, aCampos, aRestrict, cIndTemp1, cIndTemp2, aSelFil, aTmpFil, cModPgto, .F.)
		
		//Incluindo o botao para atualizar a lista somente para ambientes que utilizam query
		If aScan(aBut240,{|x| x[1] == "PMSRRFSH"}) == 0
			aAdd(aBut240,{"PMSRRFSH",{|| MsAguarde({|| F240QryA(.T., cAliasSE2, aCampos, aRestrict, cIndTemp1, cIndTemp2, aSelFil, aTmpFil, cModPgto, .T.)},;
			STR0041, STR0092, .F.)}, STR0093})		//"Atualizando"###"Aguarde, atualizando a lista"###"Atualizar"
		Endif

		If cArqNew == "NOACESS"  // Caso o usuario não tenha nenhuma permissão aborta o processo do bordero
			Help(" ",1,"RECNO")
			FreeUsedCode() //libera codigos de correlativos reservados pela MayIUseCode()
			Return
		EndIf

		If cModPgto == "45" .AND. !lIsBlind //Verifica se existem titulos para fornecedores sem chave pix ativa
			f240VrfChP()
		endIf

		If !Empty( cArqNew )
			dbselectarea(cAliasSE2)
			dbGoTop()
		EndIf

		If (cAliasSE2)->( BOF() ) .and. (cAliasSE2)->( EOF() )
			Help(" ",1,"RECNO")
			FreeUsedCode() //libera codigos de correlativos reservados pela MayIUseCode()
			If !Empty( cArqNew )
				dbSelectArea(cAliasSE2)
				dbCloseArea()
			EndIf
			If !lIsBlind
				Loop
			Else
				Return
			Endif
		EndIf

		bWhile := { || !Eof() }

		nValor  := 0    // valor total dos titulos,mostrado no rodape do browse
		nQtdTit := 0    // quantidade de titulos,mostrado no rodape do browse
		nOpca   := 0

		SX3->(dbSetOrder(1))

		DEFINE FONT oFnt NAME "Arial" SIZE 12,14 BOLD

		//Realiza ou nao pre-marcacao
		(cAliasSE2)->( DBEVAL({ |a| FA240DBEVA(nLimite,dVenIni240,dVenFim240,cAliasSE2,,@lPrimeiro)},bWhile) )

		//PONTO DE ENTRADA PARA ALTERAR A ORDEM DOS CAMPOS NA MARKBROWSE

		// Caso a rotina tenha sido chamada através da automação de testes, não apresenta a interface.
		If !lAutomato
			If lF240MARK
				aAltMark := ExecBlock("F240MARK",.F.,.F.,aCampos)
				nPos := Ascan(aAltMark,{|X|X[1] == "E2_OK"})

				//FORCA O PRIMEIRO CAMPO SER SEMPRE O E2_OK
				If nPos != 1
					aCampos := {}
					aAdd(aCampos,{"E2_OK","","  ",""})
					aEval(aAltMark,{|Z| If(Z[1] <> "E2_OK",aAdd(aCampos,{Z[1],Z[2],Z[3],Z[4]}),NIL)})
				Else
					aCampos := aAltMark
				Endif
			Endif
			dbselectarea(cAliasSE2)

			//Faz o calculo automatico de dimensoes de objetos
			oSize := FwDefSize():New(.T.)

			oSize:lLateral := .F.
			oSize:lProp	:= .T. // Proporcional

			oSize:AddObject( "1STROW" ,  100, 10, .T., .T. ) // Totalmente dimensionavel
			oSize:AddObject( "2NDROW" ,  100, 90, .T., .T. ) // Totalmente dimensionavel

			oSize:aMargins := { 2, 2, 1, 2 } // Espaco ao lado dos objetos 0, entre eles 3

			oSize:Process() // Dispara os calculos

			a1stRow := {oSize:GetDimension("1STROW","LININI"),;
						oSize:GetDimension("1STROW","COLINI"),;
						oSize:GetDimension("1STROW","LINEND"),;
						oSize:GetDimension("1STROW","COLEND")}

			a2ndRow := {oSize:GetDimension("2NDROW","LININI"),;
						oSize:GetDimension("2NDROW","COLINI"),;
						oSize:GetDimension("2NDROW","LINEND"),;
						oSize:GetDimension("2NDROW","COLEND")}

			DEFINE MSDIALOG oDlg1 TITLE STR0005 From oSize:aWindSize[1],oSize:aWindSize[2] to oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL //"Border“ de Pagamentos"
			oDlg1:lMaximized := .T.

			////////
			// Panel
			@ a1stRow[1] + 001, a1stRow[2] + 001 To a1stRow[3],a1stRow[4] PIXEL OF oDlg1
			@ a1stRow[1] + 003, a1stRow[2] + 005 Say STR0015 FONT oDlg1:oFont PIXEL Of oDlg1 // "N£mero"
			@ a1stRow[1] + 003, a1stRow[2] + 060 Say cNumbor Picture "@!" FONT oFnt PIXEL Of oDlg1

			@ a1stRow[1] + 012, a1stRow[2] + 005 Say STR0030  PIXEL Of oDlg1 //"Valor Total:"
			@ a1stRow[1] + 012, a1stRow[2] + 060 Say oValor VAR nValor Picture "@E 999,999,999,999.99" SIZE 50,8  PIXEL Of oDlg1
			@ a1stRow[1] + 012, a1stRow[2] + 150 Say STR0031  PIXEL Of oDlg1 //"Quantidade:"
			@ a1stRow[1] + 012, a1stRow[2] + 200 Say oQtda VAR nQtdTit Picture "@E 99999" SIZE 50,8  PIXEL Of oDlg1
			// Panel
			////////

			/////////////
			// MarkBrowse
			Aadd(aCores, {'Fa240Juri(cAliasSE2)','BR_VERDE'} )
			Aadd(aCores, {'!Fa240Juri(cAliasSE2)','BR_VERMELHO'} )

			(cAliasSE2)->(Dbgotop())

			IF At( "E2_FILIAL" , (cAliasSE2)->( IndexKey() ) ) > 0
				oMark := MsSelect():New(cAliasSE2,"E2_OK","!E2_SALDO",aCampos,@lInverte,@cMarca,{a2ndRow[1],a2ndRow[2],a2ndRow[3],a2ndRow[4]},"Fa240Top(1)","Fa240Top(2)",,,aCores)
			Else
				oMark := MsSelect():New(cAliasSE2,"E2_OK","!E2_SALDO",aCampos,@lInverte,@cMarca,{a2ndRow[1],a2ndRow[2],a2ndRow[3],a2ndRow[4]},,,,,aCores)
			EndIf

			oMark:bMark := {|| FA240Disp(cMarca,lInverte,oValor,oQtda)}
			oMark:bAval	:= {|| Fa240Mark(cMarca,oValor,oQtda,cAliasSE2)}
			oMark:oBrowse:lhasMark = .t.
			oMark:oBrowse:lCanAllmark := .t.
			oMark:oBrowse:bAllMark := { || FA240Inverte(cMarca,oValor,oQtda,,cAliasSE2) }
			// MarkBrowse
			/////////////

			If !lPAOk
				If !MsgYesNo(STR0133) 		// 	"Deseja validar se fornecedor possui Adiantamentos?"
					lPAOk := .T.
				EndIf
			EndIf

			bOk1 := {|| If( lPAOk, lVldAD := .T., Nil ) }
			bOk2 := {|| nOpca := 1,oDlg1:End()}
			bOk3 := {|| MsgInfo(STR0058,STR0055) } //"Antes de confirmar as baixas, execute o botao para validar titulos cujo Fornecedor possua Adiantamento ou Devolucao."

			If lPanelFin //Chamado pelo Painel Financeiro
				ACTIVATE MSDIALOG oDlg1 ON INIT (FaMyBar(oDlg1,{|| ( Eval(bOk1), If(lVldAd,Eval(bOk2),Eval(bOk3)) ) },;
				{|| nOpca := 2,oDlg1:End()},aBut240),IIf(lF240IND,oMark:oBrowse:Refresh(.T.),.T.))
			Else
				ACTIVATE MSDIALOG oDlg1 ON INIT (EnchoiceBar(oDlg1,{|| ( Eval(bOk1),If(F240Conf(), If(lVldAd,Eval(bOk2),Eval(bOk3)),)) },;
				{|| nOpca := 2,oDlg1:End()},,IIF(lF240BTN, aBut240 := ExecBlock("F240BTN",.F.,.F.,aBut240),aBut240)),IIf(lF240IND,oMark:oBrowse:Refresh(.T.),.T.)) CENTER
			Endif
		Else
			nOpcA := 1
		EndIf

		SetKey(16,bSet16)

		If nQtdTit == 0 .and. nValor = 0
			Exit
		EndIf

		If nValor <= 0
			Help(" ",1,"FA240VALOR")
			Loop
		EndIf
		
		//Execblock para validar as informacoes para geracao do bordero
		If nOpca == 1
			IF lF240TDOK
				nOpca := If( ExecBlock( "F240TDOK", .f., .f., { cMarca, cAliasSE2 } ),1,2)
			Endif
		Endif
		
		If nOpcA == 2							// Redigita / Abandona
			FreeUsedCode()  //libera codigos de correlativos reservados pela MayIUseCode()
			Exit
		EndIf
		
		If nOpcA == 1 //Confirma
			Begin Transaction
				nMoeda := Val(Substr(cVar,1,2))
				DbSelectArea(cAliasSE2)
				(cAliasSE2)->(DbGotop())
				cTiposAbat := FormatIn(MVABATIM, "|") 
				nIndiceSE2 := SE2->(IndexOrd())
				
				While !(cAliasSE2)->(Eof())
					If (cAliasSE2)->E2_OK != cMarca
						(cAliasSE2)->(DbSkip())
						Loop
					EndIf
					
					SE2->(MsGoTo((cAliasSE2)->NUM_REG))
					
					//Verifica se tem um registro solto na SEA para evitar que dê chave duplicada quando MV_CANBORP == s
					If lCanBorder
						FClearBrd(cNumBor)
					Endif
					
					//Guarda o portador anterior para envia-lo ao PE F240TBOR, caso o usuario nao queira que seja alterado o portador
					cOldPort240 := (cAliasSE2)->E2_PORTADO
					
					DbSelectArea("SEA")
					RecLock("SEA",.T. )
					SEA->EA_FILIAL  := xFilial("SEA")
					SEA->EA_PORTADO := cPort240
					SEA->EA_AGEDEP  := cAgen240
					SEA->EA_NUMCON  := cConta240
					SEA->EA_NUMBOR  := cNumBor
					SEA->EA_DATABOR := dDataBase
					SEA->EA_PREFIXO := SE2->E2_PREFIXO
					SEA->EA_NUM     := SE2->E2_NUM
					SEA->EA_PARCELA := SE2->E2_PARCELA
					SEA->EA_TIPO    := SE2->E2_TIPO
					SEA->EA_FORNECE := SE2->E2_FORNECE
					SEA->EA_LOJA	:= SE2->E2_LOJA
					SEA->EA_CART    := "P"
					SEA->EA_MODELO  := cModPgto
					SEA->EA_TIPOPAG := cTipoPag
					SEA->EA_FILORIG := SE2->E2_FILORIG
					SEA->EA_ORIGEM  := "FINA240"
					
					If l240Versao
						SEA->EA_VERSAO := "0001"
					Endif
					
					If lSubCtaEA
						SEA->EA_SUBCTA := cSubConta
					EndIf

					If FindFunction("F713VldUso") .and. F713VldUso()
						SEA->EA_BORAPI := IIF(lChkAPI,'S','N')
					Endif

					SEA->(MsUnlock())
					FKCOMMIT()
					
					RecLock("SE2",.F.)
					SE2->E2_NUMBOR  := cNumBor
					SE2->E2_PORTADO := cPort240
					
					If lSE2DtBor
						SE2->E2_DTBORDE := dDataBase
					EndIf
					
					SE2->(MsUnlock())
					FKCOMMIT()
					
					//Envio de e-mail pela rotina de checklist de documentos obrigatorios
					IF lFinVDoc
						CN062ValDocs("06",.F.,.T.)
					EndIf
					
					//Gravo o numero do bordero em todos os titulos de abatimentos
					SE2->(DbSetOrder(17))
					If SE2->(DbSeek(SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
						cQuery := "UPDATE " + RetSqlName("SE2") + " SET "
						cQuery += "E2_NUMBOR = '" + cNumBor + "', E2_PORTADO = '" + cPort240 + "' "
						cQuery += "WHERE E2_FILIAL = '" + SE2->E2_FILIAL + "' "
						cQuery += "AND E2_PREFIXO  = '" + SE2->E2_PREFIXO + "' "
						cQuery += "AND E2_NUM = '" + SE2->E2_NUM + "' "
						cQuery += "AND E2_PARCELA = '" + SE2->E2_PARCELA + "' "
						cQuery += "AND E2_TIPO IN " + cTiposAbat + " "
						cQuery += "AND E2_FORNECE = '" + SE2->E2_FORNECE + "' "
						cQuery += "AND E2_LOJA = '" + SE2->E2_LOJA + "' "
						cQuery += "AND D_E_L_E_T_ = ' ' "
						
						If (nErro := TCSqlExec(cQuery)) != 0
							Help(Nil, Nil, "F240GERBOR", Nil, STR0147 + ": " + SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA), 1, 0, Nil, Nil, Nil, Nil, Nil, {})
							DisarmTransaction()
							Break
						EndIf
					EndIf
					
					DbSelectArea("SE2")
					SE2->(DbSetOrder(nIndiceSE2))
					SE2->(MsGoTo((cAliasSE2)->NUM_REG))
					
					If lF240TBor
						ExecBlock("F240TBOR",.f.,.f.,{cOldPort240,cPort240})
					Endif
					
					(cAliasSE2)->(DbSkip())
				EndDo
				
				//Grava o numero do bordero atualizado
				If GetMV("MV_NUMBORP") < cNumbor
					PutMV("MV_NUMBORP",cNumbor)
				Endif	
			End Transaction
			
			//Chama rotina para geração/transmissão do arquivo de cnab via TCB
			If lChkTCB .And. nErro == 0
				lPergunte := pergunte("AFI420",.F.)
				
				mv_par01 := cNumBor		     // Do Bordero 		  		 
				mv_par02 := cNumBor		     // Ate Bordero   	  		 
				mv_par03 := 'tcbpenv.2pe'	 // Arq.Configuracao   		 
				mv_par04 := 'C:\CNAB'		 // Arq. Saida			  		 
				mv_par05 := cPort240	     // Banco       		  		 
				mv_par06 := cAgen240	     // Agencia 			  		 
				mv_par07 := cConta240	     // Conta       		  		 
				mv_par08 := cSubconta		 // Sub-Conta			  		 
				mv_par09 := 2	 			 // Modelo 1/Modelo 2  		 
				mv_par11 := xFilial("SE2")	 // Filial de     	       
				mv_par12 := xFilial("SE2")	 // Filial Ate
				
				//Seto as variáveis que foram alimentadas no FINA240 antes da chamada da Fa420Gera()
				nQtdTitLote := 0
				nQtdLinLote := 0
				nSomaVlLote := 0
				nSomaAbLot	:= 0	
				nQtdTotTit	:= 0
				nQtdLnLote  := 0
				Fa420Gera("SE2", lAutomato)
			Endif
		EndIf
		Exit
	EndDo

	If nErro == 0 .And. nOpca == 1 .And. lF240Bord
		ExecBlock("F240Bord",.F.,.F.)
	EndIf

	// Apaga o semáforo
	If lF240Semaf
		fclose(nHdlLock)
		Ferase("FINA240.L"+cEmpAnt)
	EndIf

	//Libera os registros
	If lTEMP
		dbSelectArea(cAliasSE2)
		dbGoTop()
		While !EOF()
			SE2->(dbGoto((cAliasSE2)->NUM_REG))
			SE2->(MsUnlock())
			(cAliasSE2)->(MsUnlock())
			dbSkip()
		Enddo

		If Select(cAliasSE2) > 0
			DbSelectArea(cAliasSE2)
			DbCloseArea()
		EndIf
	EndIf

	If nErro == 0
		F240Clean() //Deleta tabela temporária no banco de dados criada da função F240MTTMP (FINA240.PRW)
	EndIf
	
	//Restaura os indices
	nOrdem := SE2->(INDEXORD())

	dbSelectArea( "SE2" )
	Set Filter To &cSetFilter.
	dbSetOrder(nOrdem)

	//Gestao
	For nX := 1 TO Len(aTmpFil)
		CtbTmpErase(aTmpFil[nX])
	Next

	If nSavRec > 0
		dbGoTo(nSavRec)
	Endif

	If lPanelFin .And. nErro == 0
		dbSelectArea(FinWindow:cAliasFile)
		FinVisual(FinWindow:cAliasFile,FinWindow,(FinWindow:cAliasFile)->(Recno()),.T.)
	Endif

	FwFreeArray(aIndices)
	FwFreeArray(aNewIndex)
Return

/*/{Protheus.doc} FA240Num
Verifica se o numero do bordero informado existe.

@type 		function
@author		Wagner Xavier
@since		21/05/1993
@version	1.0

/*/
Function FA240Num(cNumBor As Character, cFilBor As Character) As Logical

	Local cFilSEA	As Character
	Local lRetorna	As Logical
	Local nSavRec	As Numeric

	cNumBor		:= IIf(Len(cNumBor) < 6, PadR(cNumBor, 6), cNumBor)
	lRetorna	:= .T.
	nSavRec		:= 0
	cFilSEA		:= FwXFilial("SEA")

	If ValType(cFilBor) != "C"
		GetMV("MV_NUMBORP")
		cFilBor := SX6->X6_FIL
	EndIf

	DbSelectArea("SEA")
	nSavRec := SEA->(Recno())
	SEA->(DbSetOrder(1))
	SEA->(DbSeek(cFilSEA + cNumBor, .T.))
	While cFilSEA == SEA->EA_FILIAL .and. cNumBor == SEA->EA_NUMBOR .And. !(EoF())
		If SEA->EA_CART == "P"
			Help(" ", 1, "F240BORDE")
			lRetorna := .F.
			Exit
		Endif
		DbSkip(1)
	EndDO

	//verifica se esta na memoria, sendo usado busca o proximo numero disponivel
	If lRetorna .And. !(MayIUseCode("E2_NUMBOR" + cFilBor + cNumBor))
		Help(" ", 1, "F240BORDE")
		lRetorna := .F.
	EndIf

	//Validacao extra para o numero do bordero
	If lRetorna .And. lF240NBOR
		lRetorna := ExecBlock("F240NBOR",.F.,.F.,cNumBor)
	Endif

	If nSavRec > 0
		SEA->(DbGoTo(nSavRec))
	Endif

Return lRetorna

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA240NumC
Verifica se o numero do bordero informado existe

@author Wagner Xavier
@since 21/05/1993
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function FA240NumC()
	Local lRetorna	:=.F.
	Local nSavRec	:= 0
	Local cAlias	:= Alias()
	Local cFilBor := ""
	Local cFilAtu	:= xFilial(cAlias)


	If Fa150PesqBord(mv_par01,@cFilBor)
		cFilAtu := FWxFilial((cAlias),cFilBor)
	Else
		cFilAtu := xFilial(cAlias)
	Endif

	If Empty(cFilAtu) .Or. (lFWCodFil .And. Empty(FwFilial("SEA"))) .or. (!lFWCodFil .And. Empty(xFilial("SEA")))
		If Fa150PesqBord(mv_par01,@cFilBor)
			cFilAtu := FWxFilial('SEA',cFilBor)
		Else
			cFilAtu := xFilial('SEA')
		Endif
	Endif

	dbSelectArea( "SEA" )
	nSavRec := SEA->( RecNo() )
	SEA->( dbSetOrder(1) )

	SEA->( dbSeek(cFilAtu+mv_par01,.t.) )
	While cFilAtu == EA_FILIAL .and. mv_par01 == EA_NUMBOR .and. !eof()
		If SEA->EA_CART == "P"
			lRetorna := .T.
			Exit
	Endif
	DbSkip(1)
	EndDO
	If !lRetorna
		Help(" ",1,"F240NOBORD")
	EndIf

	dbGoto(nSavRec)
	dbSelectArea(cAlias)
Return lRetorna

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA240Data
Verifica se data final é maior que data inicial

@author Wagner Xavier
@since 21/05/1993
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function FA240Data(dVenIni240,dVenFim240)
	LOCAL lRet:=.T.
	IF dVenFim240<dVenIni240
		Help(" ",1,"DATAMENOR")
		lRet:=.F.
	EndIF
Return lRet

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA240Canc
Cancela os borderos

@author Paulo Boschetti
@since 21/05/1993
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function FA240Canc(cAlias As Character, nReg As Numeric, nPosArotina As Numeric, lAutomato As Logical)
	Local lPanelFin   := IsPanelFin()
	Local cChave	  := ""
	LOCAL nSavRec 	  := SE2->( Recno() )
	Local lF240Can	  := ExistBlock("F240CAN")
	Local lF240Pcb	  := ExistBlock("F240PCB")
	Local lDeleta 	  := .T.
	Local lF240Ok	  := ExistBlock("F240Ok")
	Local cOldPortado := ""
	Local lPergunte   := .F.
	Local lRet 		  := .T.
	Local aBordImp    := {}
	Local lPccBaixa   := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	Local lIssBaixa   := SuperGetMv("MV_MRETISS",.F.,"1") == "2"
	Local cQuery      := ""
	Local cTiposAbat  := ""
	Local cE2NumBor   := ""
	Local cE2Portado  := ""
	Local nRegistSE2  := 0
	Local dDtGerBor	  := CTOD("  /  /  ")

	Default lAutomato := .F.	
	
	__l241Canc   := Iif(__l241Canc == Nil, FindFunction("F241DtCanc"), __l241Canc)
	
	//Verifica se data do movimento Não ‚ menor que data limite de movimentacao no financeiro
	If !DtMovFin(,,"1")
		lRet := .F.
	Endif

	// Verifica as perguntas selecionadas
	If lRet
		pergunte("AFI240",.F.)
		If lPanelFin
			lPergunte := PergInPanel("AFI240",.T.)
		Else
		lPergunte := pergunte("AFI240",.T.)
		Endif
		If !lPergunte
			lRet := .F.
		EndIf
	Endif

	If lRet
		DbSelectArea("SED")
		DbSelectArea("SA2")
		SED->(DbSetOrder(1))
		SA2->(DbSetOrder(1))		
		
		dbSelectArea("SEA")
		dbSetOrder(2)	//EA_FILIAL+EA_NUMBOR+EA_CART+EA_PREFIXO+EA_NUM+EA_PARCELA+EA_TIPO+EA_FORNECE+EA_LOJA
		If !MsSeek( xFilial("SEA")+mv_par01+"P" )
			Help(" ",1,"F240NOBORD")
			lRet := .F.
		Endif
	Endif

	If lRet .And. __l241Canc .And. !F241DtCanc(dDataBase, SEA->EA_NUMBOR, SEA->EA_CART, SEA->EA_FILIAL, @dDtGerBor, @_oBorDtCan, .F.)
		Help(" ",1,"FA240DTCAN",,STR0148 + SEA->EA_NUMBOR + STR0149 + DTOC(dDtGerBor) + STR0150,1,1) //"Não é permitido cancelar o borderô "### " com data anterior à sua geração (" ### ")."
		lRet := .F.
	EndIf

	If lRet .and. lF240Ok
		If !ExecBlock("F240OK",.F.,.F.)
			lRet := .F.
		Endif
	Endif

	If lRet .And. !lAutomato
		If __lAPICP == NIL
			__lAPICP := FindFunction("F717VldUso") .and. F717VldUso()
		Endif

		If __lAPICP .And. SEA->EA_BORAPI == "S"
			If !MSGYESNO( STR0153 + CRLF + STR0154 + CRLF + STR0155 , STR0156 ) //"Esse borderô foi configurado para registrado online. " # "O cancelamento do borderô através desta rotina não realiza atualização de forma automática no banco, necessária retirada manual. ". # Deseja prosseguir?" # "Registro online de pagamentos"
				lRet := .F.
			Endif
		Endif
	Endif

	if lRet .and. F241Baixa(cFilial,mv_par01)
		help(" ",1,"FA240BAIXA",,STR0086,1,1) //"Borderô com baixa (s). Cancele a (s) baixa (s) primeiro para depois cancelar o borderô."
		lRet := .F.
	endIf

	// Procura os registros que compoem o bordero a ser cancelado
	If lRet
		Begin Transaction
			cTiposAbat := FormatIn(MVABATIM, "|")
			cE2NumBor  := Space(Len(SE2->E2_NUMBOR))
			cE2Portado := Space(Len(SE2->E2_PORTADO))
			
			While !Eof() .And. xFilial("SEA") == SEA->EA_FILIAL .And. SEA->EA_NUMBOR == mv_par01 .And. SEA->EA_CART == "P"
				cLoja := Iif(Empty(SEA->EA_LOJA) , "" , SEA->EA_LOJA)
				
				//Borderos gerados em versao anterior
				IF Empty(SEA->EA_FILORIG)
					cChave := xFilial("SE2")+SEA->EA_PREFIXO+SEA->EA_NUM+SEA->EA_PARCELA+SEA->EA_TIPO+SEA->EA_FORNECE+cLoja
				Else //Borderos gerados a partir da versao 7.10
					cChave := xFilial("SE2",SEA->EA_FILORIG)+SEA->EA_PREFIXO+SEA->EA_NUM+SEA->EA_PARCELA+SEA->EA_TIPO+SEA->EA_FORNECE+cLoja
				Endif
				
				//Verifica qual a rotina de geração do borderô
				If AllTrim(SEA->EA_ORIGEM) $ "FINA241|FINA590|FINA590S"
					lRet := .F.
					SED->(DbSeek(xFilial("SED", SE2->E2_FILORIG)+SE2->E2_NATUREZ))
					SA2->(DbSeek(xFilial("SA2", SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA)) 
					
					If lPccBaixa .And. "S" $ SED->(ED_CALCPIS+ED_CALCCOF+ED_CALCCSL) .And. "2" $ SA2->(A2_RECPIS+A2_RECCOFI+A2_RECCSLL)
						lRet := .T.
					ElseIf SED->ED_CALCIRF == "S" .And. SA2->A2_CALCIRF == "2"
						lRet := .T.
					ElseIf lIssBaixa .And. SA2->A2_RECISS == "N"
						lRet := .T.
					EndIf
					
					If lRet
						If Len(aBordImp) == 0
							Aadd(aBordImp, {SEA->(Recno()), cChave})
						EndIf
						SEA->(DbSkip())
						Loop
					EndIf
				EndIf
				
				DbSelectArea("SE2")
				SE2->(DbSetOrder(1))
				
				If SE2->(MsSeek(cChave)) .And. SE2->E2_SALDO > 0
					lDeleta := .T.
					
					//Ponto de Entrada para controle de permissÆo da deleção do titulo em bordero.
					If lF240PCB
						lDeleta := ExecBlock("F240PCB",.f.,.f.)
					EndIf
					
					If lDeleta
						cFilOrig    := SE2->E2_FILORIG
						cOldPortado := SE2->E2_PORTADO
						nRegistSE2  := SE2->(Recno())
						
						RecLock("SE2")
						SE2->E2_NUMBOR  := Space(6)
						SE2->E2_PORTADO := cE2Portado
						If cPaisLoc == "BRA"
							SE2->E2_DTBORDE	:= CTOD("  /  /  ")
						EndIf
						SE2->(MsUnlock())
						FKCOMMIT()
						
						SE2->(DbSetOrder(17))
						If SE2->(DbSeek(SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))						
							//Deleto o numero do bordero em todos os titulos de abatimentos
							cQuery := "UPDATE " + RetSqlName("SE2") + " SET "
							cQuery += "E2_NUMBOR = '" + cE2NumBor + "', E2_PORTADO = '" + cE2Portado + "' "
							cQuery += "WHERE E2_FILIAL = '" + SE2->E2_FILIAL + "' "
							cQuery += "AND E2_PREFIXO = '" + SE2->E2_PREFIXO + "' "
							cQuery += "AND E2_NUM = '" + SE2->E2_NUM + "' "
							cQuery += "AND E2_PARCELA = '" + SE2->E2_PARCELA + "' "
							cQuery += "AND E2_TIPO IN " + cTiposAbat + " "
							cQuery += "AND E2_FORNECE = '" + SE2->E2_FORNECE + "' "
							cQuery += "AND E2_LOJA = '" + SE2->E2_LOJA + "' "
							cQuery += "AND D_E_L_E_T_ = ' ' "
							
							If TCSqlExec(cQuery) != 0
								Help(Nil, Nil, "F240CANBOR", Nil, STR0145 + ": " + AllTrim(SEA->EA_NUMBOR) + " " + STR0146 + ": " + SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA), 1, 0, Nil, Nil, Nil, Nil, Nil, {})
								DisarmTransaction()
								Break
							EndIf
						EndIf
						
						SE2->(DbSetOrder(1))
						SE2->(DbGoto(nRegistSE2))
						DbSelectArea("SEA")
						RecLock("SEA",.F.,.T.)
						DbDelete()
						SEA->(MsUnlock())
						FKCOMMIT()
						
						If lF240Can
							ExecBlock("F240CAN",.f.,.f.,{cOldPortado})
						EndIf
					Endif
				Endif
				
				DbSelectArea("SEA")
				SEA->(DbSkip())
			Enddo
			
			If Len(aBordImp) > 0
				If Type("cLote") == "U"
					Private cLote := LoteCont("FIN")
				EndIf
				
				SEA->(DbGoto(aBordImp[1,1]))
				SE2->(DbSetOrder(1))
				SE2->(DbSeek(aBordImp[1,2]))			
				FA241Canc(Nil, Nil, Nil, Nil, .T.)
				FwFreeArray(aBordImp)
			EndIf
		End Transaction
	Endif

	DbSelectArea("SE2")
	
	If nSavRec > 0
		SE2->(DbGoTo(nSavRec))
	Endif

    If _oBorDtCan <> Nil
        _oBorDtCan:Destroy()
        _oBorDtCan:= Nil
    EndIf

Return nil

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA240Chec2
Cancela os borderos

@author Alexandre Effting
@since 21/05/2008
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function FA240Chec2()
	
	Local cFiltro 	:= " "
	Local lFA240PA	:= ExistBlock("FA240PA")

	cFiltro += "E2_TIPO NOT IN " + FormatIn(MVPROVIS + "|" + MV_CPNEG + "|PRE|" + MVABATIM, "|")  + " AND "

	If lF240FPGT
		cFiltro += ExecBlock("F240FPGT", .F., .F.)
	EndIf

	If FwIsInCallStack("FINA245") /* considera somente titulos normais */
		cFiltro += "E2_TIPO <> '" + MVPAGANT + "' AND "
	Else
		// Verifica MV_PAR01 -> 1 - Normais / 2 - Adiantamento
		If MV_PAR01 == 1  // 1 -> Titulos Normais   2-> Adiantamentos
			cFiltro += "E2_TIPO <> '" + MVPAGANT + "' AND "
		ElseIf  MV_PAR01 == 2
			cFiltro += "E2_TIPO = '" + MVPAGANT + "' AND E2_NUMBCO = '" +  Space(TamSX3("E2_NUMBCO")[1]) + "' AND "
		Else  //Ambos
			cFiltro += "(E2_TIPO <> '" + MVPAGANT + "' OR E2_NUMBCO = '" +  Space(TamSX3("E2_NUMBCO")[1]) + "') AND "
		EndIf
	EndIf

	//Ignora os títulos que possuem cheques emitidos.
	cFiltro += " E2_IMPCHEQ <> 'S' AND "

	If SE2->(FieldPos("E2_NUMSOL")) > 0
		cFiltro += " E2_NUMSOL = '" + Space(Len(SE2->E2_NUMSOL)) + "' AND "
	EndIf

	If !IsInCallStack("FINA245")
		cFiltro += "E2_MOEDA = " + AllTrim(Str(nMoeda, 2)) + " AND "
	EndIf

	cFIltro += "(E2_SALDO>0 AND E2_NUMBOR = '" + Space(TAMSX3("E2_NUMBOR")[1]) + "')"

	// Verifica se pode baixar sem aprovação
	If GetMv("MV_CTLIPAG")
		cFiltro += " AND (E2_DATALIB <> ' '"
		cFiltro += " OR (E2_SALDO + E2_SDACRES - E2_SDDECRE <= " + AllTrim(Str(GetMv("MV_VLMINPG"), 17, 2)) + "))"
	EndIf

	If !IsInCallStack("FINA245") .And. !(Empty(c240FilBT))
		cFiltro := "(" + cFiltro + ") AND (" + c240FilBT + ")"
	EndIf

	// PONTO DE ENTRADA PARA ALTERACAO DO FILTRO
	If lF240AFIL
		cFiltro := ExecBlock("F240AFIL", .F., .F., {cFiltro})
	EndIf

	// PONTO DE ENTRADA PARA PERMITIR TÍTULOS DO TIPO "PA" NO BORDERÔ
	If lFA240PA
		lFA240PA := ExecBlock("FA240PA") // Caso permitir PA no borderô
		If lFA240PA
			cFiltro:= StrTran(cFiltro, "E2_TIPO <> '" + MVPAGANT + "' AND ", "") // remove condição do filtro.
		EndIf
	EndIf

Return cFiltro

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa240Sis
Geração do Arquivo de Envio de Titulos a Pagar SisPag

@author Vinicius S.Barreira
@since 15/05/1995
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function Fa240Sis()
	Local lPanelFin := IsPanelFin()
	LOCAL aSays		:={}
	LOCAL aButtons	:={}
	LOCAL nOpca 	:= 0
	LOCAL lF240Ger 	:= ExistBlock("F240Ger")
	LOCAL cOldFil	:= cFilAnt
	Local lIsBlind  := IsBlind()

	Private xConteudo

	cFilAnt := Fa300FilLog()

	If cFilAnt <> cOldFil
		SM0->(DbSeek(cEmpAnt+cFilAnt))
	EndIf

	// Verifica se data do movimento Não ‚ menor que data limite de movimentacao no financeiro
	If !DtMovFin(,,"1")
		Return
	Endif

	Pergunte("FIN240",.F.)
	nOpca := 1
	
	If !lIsBlind
		nOpca := 0
		AADD (aSays, STR0033)		// "   Esta opção gera o Arquivo de  Comunicação Banc ria  SisPag"
		AADD (aSays, STR0034)		// "para o  Border“ de Pagamentos. Dever  ser  informado o  N§ do"
		AADD (aSays, STR0035)		// "Border“ que se quer enviar, o Nome do Arquivo de Configuração"
		AADD (aSays, STR0036)		// "(CNAB SisPag) e o Nome do Arquivo a ser Gerado."
	
		If lPanelFin  //Chamado pelo Painel Financeiro
			aButtonTxt := {}
			AADD(aButtonTxt,{STR0039,STR0039, {||Pergunte("FIN240",.T. )}}) // Parametros
			FaMyFormBatch(aSays,aButtonTxt,{||nOpca:= 1},{||nOpca:= 0})
		Else
			AADD(aButtons, { 1,.T.,{|o| nOpca:= 1,o:oWnd:End()}} )
			AADD(aButtons, { 2,.T.,{|o| o:oWnd:End() }} )
			AADD(aButtons, { 5,.T.,{|| Pergunte("FIN240",.T. ) } } )
			FormBatch( STR0038, aSays, aButtons )
		Endif
	EndIf

	If nOpca == 1
		If lF240Ger
			If !execBlock("F240Ger",.F.,.F.)
			Return(Nil)
			Endif
		Endif
		
		Processa({||SisPagGer("SE2")})
	Endif

	If cFilAnt <> cOldFil
		SM0->(DbSeek(cEmpAnt+cOldFil))
	EndIf

	cFilAnt := cOldFil
Return

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SisPagGer
Gera Arquivo Remessa SisPag

@author Vinicius S.Barreira
@since 15/05/1995
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function SisPagGer(cAlias)
	LOCAL lResp		:= .T.
	LOCAL nUltDisco	:= 0
	Local lErro		:= .F.
	Local cHeadLote := ""
	Local cDeta     := ""
	Local cDetb     := ""
	Local cDetc     := ""
	Local cTraiLote := ""
	Local cLOCABCO  := "" // Banco da Localiza
	Local cLOCAPRO  := ""
	Local lFirst    := .T.
	Local aArea		:= GetArea()
	Local aAreaSEA  := SEA->(GetArea())
	Local aAreaSE2  := SE2->(GetArea())
	Local aAreaFK7  := FK7->(GetArea())
	Local aAreaFWM  := FWM->(GetArea())
	Local lAchou	:= .F.
	Local lIsItau	:= .F.
	Local aOrdSE2	:= {}
	Local cChave	:= ""
	Local cFil240Tc	:= ""
	Local cModelo	:= SEA->EA_MODELO
	Local lF240Grv  := ExistBlock("F240GRV")
	Local lF240Bco	:= ExistBlock("F240BCO")
	Local lF240Sum	:= ExistBlock("F240SUM")
	Local lF240SumA := ExistBlock("F240SUMA")
	Local lF240SumD := ExistBlock("F240SUMD")
	Local lF240FilTc:= ExistBlock("F240FILTC")
	Local lF240TGRV := ExistBlock("F240TGRV")
	Local lNewIndice:= FaVerInd()  //Verifica a existencia dos indices de IDCNAB sem filial (Função localizada no FINA430)
	Local cChaveID  := ""
	Local nOrdCNAB  := Iif(lNewIndice,13,11)
	Local nAbatim	:= 0
	Local cFilFwSE2 := xFilial("SE2")
	Local cFilAux		:= ""
	Local lF240LBDA := ExistBlock("F240LBDA")
	Local lAutLibBor
	
	Private nHdlBco 	:= 0
	Private nHdlSaida 	:= 0,nSeq := 0,nRegSeq := 0,nRegLote := 0,cBanco,cAgencia,cConta,cSubConta
	Private nTotLinha 	:= 1 //Total de linhas do arquivo Inicio com uma linha para o Header e uma para o lote

	// Ponto de Entrada F240ARQ
	// Utilizado na verificação da existencia de arquivo com mesmo nome contido em mv_par04 (nome do arquivo a ser gerado).
	If lF240ARQ
		ExecBlock("F240ARQ",.F.,.F.)
	Endif

	dbSelectArea("SEA")
	dbSetOrder(1)
	dbSeek(xFilial("SEA")+mv_par01,.T.)
	
	While SEA->(!Eof()) .And. SEA->EA_NUMBOR <= mv_par02 .and. SEA->EA_FILIAL == xFilial()
		If SEA->EA_CART == "P"
			cBanco  := SEA->EA_PORTADO
			cAgencia:= SEA->EA_AGEDEP
			cConta  := SEA->EA_NUMCON
			lAchou  := .T.
			lErro	:= .F.
			Exit
		Endif
		SEA->(DbSkip())
	Enddo
	
	If !lAchou
		Help(" ",1,"BANC240")
		lErro := .T.
	EndIf
	
	//Verifico e posiciono SA6
	If !lErro .and. !CarregaSa6(cBanco,cAgencia,cConta,.T.)
		lErro := .T.
	Endif
	
	If !lErro
		dbSelectArea("SEE")
		If !dbSeek(xFilial("SEE")+cBanco+cAgencia+cConta)
			Help(" ",1,"PAR240")
			lErro := .T.
		Else
			cSubConta := SEE->EE_SUBCTA
		Endif
	EndIf
	
	If !lErro
		lIsItau := IIF(SEA->EA_PORTADO == "341",.T.,.F.)
		//Ponto de entrada F240BCO
		//Tem como funcao validar se o portador, cadastrado no SA6 com um outro
		//numero que nao seja "341" eh o banco Itau de forma a nao gerar Segmento B
		//Explo: Cliente cadastra os bancos em sequencia (001...007) e o 007 representa o Itau
		//Retornar .T. se o portador for o Itau ou .F. caso contrario
		If lF240Bco
			lIsItau := ExecBlock("F240BCO",.F.,.F.,SEA->EA_PORTADO)
		Endif
		
		If !(lResp := AbrePar())  //Abertura Arquivo ASC II
			lErro := .T.
		Endif
	EndIf
	
	If lErro
		SEA->(RestArea(aAreaSEA))
		SE2->(RestArea(aAreaSE2))
		SEA->(RestArea(aAreaSEA))
		RestArea(aArea)
		Return .F.
	EndIf

	//---------------------------------------------------------------------------
	// Analisa o tipo de bordero e define quais headers, traillers e detalhes
	// de lote que ser„o utilizados.
	//---------------------------------------------------------------------------
	/* Identificadores
		A - Header Arquivo
		B - Header Lote 1   ÄÄ´ Header Lote Cheque/OP/DOC/Cred.CC
		C - Header Lote 2   ÄÄ´ Header Lote Cob Ita£/Outros Bancos
		D - Trailer Lote 1  ÄÄ´ Trailler Lote Cheque/OP/DOC/Cred.CC
		E - Trailer Lote 2  ÄÄ´ Trailler Lote Cob Ita£/Outros Bancos
		F - Trailer Arquivo
		G - Segmento A  Cheque/OP/DOC/Cred.CC
		H - Segmento B  ""          ""
		I - Segmento L  ÄÄÄÄÄÄ´ Cob Ita£/Outros Bancos
	------------------------------------------------------------------------- */
	cHeadLote := ""
	cDeta     := ""
	cDetb     := ""
	cDetc     := ""
	cDetJ52   := ""
	cTraiLote := ""

	lFirst := .T.
	nLote	 := 0
	nRegSeq	 := 0
	dbSelectArea("SEA")
	ProcRegua(SEA->(LastRec()))
	
	While SEA->(!Eof()) .And. SEA->EA_NUMBOR <= mv_par02 .and. SEA->EA_FILIAL == xFilial("SEA")
		cModelo	:= SEA->EA_MODELO
		cNumBor	:= SEA->EA_NUMBOR
		cHeadLote := ""
		cDeta     := ""
		cDetb     := ""
		cDetc     := ""
		cTraiLote := ""
		
		If SEA->(EA_PORTADO + EA_AGEDEP + EA_NUMCON) != cBanco+cAgencia+cConta
			SEA->(DbSkip())
			Loop //Despreza borderos de outros bancos
		Endif
		
		If SEA->EA_CART != "P"			
			SEA->(DbSkip())
			Loop // Despreza borderos de outras carteiras
		Endif
		
		If (Empty( SEA->EA_MODELO ) .or. Empty( SEA->EA_TIPOPAG ))
			Help(" ",1,"FA240SIS")
			Exit
		Endif
		
		IF lF240LBDA
			lAutLibBor := ExecBlock("F240LBDA",.f.,.f.)
			
			IF !lAutLibBor
				SEA->(DBSkip())
				Loop
			Endif
		ENDIF
		
		If lF240ALMOD
			cModelo:= ExecBlock("F240ALMOD",.F.,.F.,{cModelo})
		EndIf
		
		Do Case
			Case cModelo $ "01#06"  // 01 - Credito em conta corrente / 06 - Credito em conta corrente mesma titularidade
				cHeadLote := "B"
				cDeta     := "G"
				cTraiLote := "D"
			Case cModelo == "02"  // Cheque pagamento / administrativo
				cHeadLote := "B"
				cDeta     := "G"
				cTraiLote := "D"
			Case cModelo $ "03#07"  // Doc C # Doc D
				cHeadLote := "B"
				cDeta     := "G"
				//Para o Itau o Segmento B e opcional no envio de DOC e TED
				If SEA->EA_PORTADO != "341" .and. !lIsItau
					cDetb     := "H"
				Endif
				cTraiLote := "D"
			Case cModelo == "04"  // Op a disposicao Com aviso
				cHeadLote := "B"
				cDeta     := "G"
				cDetb     := "H"
				cTraiLote := "D"
			Case cModelo == "05"  // Credito em conta poupanca
				cHeadLote := "B"
				cDeta     := "G"
				cTraiLote := "D"
			Case cModelo == "10"  // Op a disposicao Sem aviso
				cHeadLote := "B"
				cDeta     := "G"
				cTraiLote := "D"
			Case cModelo == "13"  // Pagamento a Concessionarias
				cHeadLote := "C"
				cDeta     := "O"
				cTraiLote := "K"
			Case cModelo $ "19#28"  // 19-Pagamento de IPTU / 28- GR-PR com Codigo de Barras
				cHeadLote := "C"
				cDeta     := "O"
				cTraiLote := "K"
				//-----------------------------------------
				// Identificacao dos Tributos
				//-----------------------------------------
				// 16 - Pagamento de Tributos DARF
				// 17 - Pagamento de Tributos GPS
				// 18 - Pagamento de Tributos DARF SIMPLES
				// 21 - Pagamento de Tributos DARJ
				// 22 - Pagamento de Tributos GARE ICMS SP
				// 25 - Pagamento de Tributos IPVA (SP e MG)
				// 27 - Pagamento de Tributos DPVAT
				// 29 - GR-PR sem Codigo de Barras
				// 35 - Pagamento de Tributos FGTS - GFIP
			Case cModelo $ "16|17|18|21|22|25|27|29|35"
				cHeadLote := "C"
				cDeta     := "N"
				cDetc     := "W"
				cTraiLote := "I"
			Case cModelo == "30"  // Liquidacao de titulos em cobranca no Ita£
				cHeadLote := "C"
				cDeta     := "J"
				cDetJ52   := "5"
				cTraiLote := "E"
			Case cModelo == "31"  // Pagamento de titulos em outros bancos
				cHeadLote := "C"
				cDeta     := "J"
				cDetJ52   := "5"
				cTraiLote := "E"
			Case cModelo == "41"  // TED - Outro Titular
				cHeadLote := "B"
				cDeta     := "G"
				//Para o Itau o Segmento B e opcional no envio de DOC e TED
				If SEA->EA_PORTADO != "341"  .and. !lIsItau
					cDetb     := "H"
				Endif
				cTraiLote := "D"
			Case cModelo == "43"  // TED - Mesmo Titular
				cHeadLote := "B"
				cDeta     := "G"
				//Para o Itau o Segmento B e opcional no envio de DOC e TED
				If SEA->EA_PORTADO != "341"  .and. !lIsItau
					cDetb     := "H"
				Endif
				cTraiLote := "D"
		Endcase
		
		//Grava o Header do Arquivo
		If lFirst
			Fa240Linha("A")
			lFirst := .F.
		Endif
		
		nLote++ // Usada dentro do arquivo de configuracao para identificar o num. do lote
		Fa240Linha(cHeadLote)
		nSeq  	  := 0
		nRegLote   := 0	// Usada pelo arquivo de configuracao para identificar o numero sequencial do registro no lote
		nSomaValor := 0
		nSomaVal1  := 0
		nSomaAbat  := 0
		nSomaAbLot := 0
		nSomaAcres := 0
		nSomaDecre := 0
		
		//Processa um bordero
		While SEA->(!Eof()) .And. SEA->EA_NUMBOR == cNumBor .And. SEA->EA_FILIAL == xFilial("SEA")

			If SEA->EA_CART != "P"
				// Despreza borderos de outras carteiras
				SEA->(DbSkip())
				Loop
			Endif

			// Borderos gerados em versao anterior
			IF Empty(SEA->EA_FILORIG) .AND. !Empty( cFilFwSE2 )
				cChave := xFilial("SE2")+SEA->EA_PREFIXO+SEA->EA_NUM+SEA->EA_PARCELA+SEA->EA_TIPO+SEA->EA_FORNECE+SEA->EA_LOJA
			Else //Borderos gerados a partir da versao 7.10
				cFilAux :=cFilAnt
				cFilAnt :=SEA->EA_FILORIG
				cChave  := xFilial("SE2")+SEA->EA_PREFIXO+SEA->EA_NUM+SEA->EA_PARCELA+SEA->EA_TIPO+SEA->EA_FORNECE+SEA->EA_LOJA
				cFilAnt :=cFilAux
			Endif
			SE2->(dbSetOrder(1))
			SE2->(MsSeek(cChave))

			//Pocisiona na FK7
			dbSelectArea("FK7")
			FK7->(dbSetOrder(2)) //FK7_FILIAL+FK7_ALIAS+FK7_CHAVE
			FK7->(dbSeek(xFilial("FK7")+"SE2"+cChave))

			//Posiciona na FWM - Aglutinação INSS
			dbSelectArea("FWM")
			FWM->(dbSetOrder(2)) //FWM_FILIAL+FWM_SUBPRO
			FWM->(dbSeek(xFilial("FWM")+SE2->E2_NUM))

			IncProc("Bord. num: " + SEA->EA_NUMBOR + " Mod: " + SEA->EA_MODELO + " Tit: " + SEA->(EA_PREFIXO+EA_NUM+EA_PARCELA+EA_TIPO))

			If SE2->(Eof())
				Help(" ",1,"BORD240")
				SEA->(MsSeek(IncLast(xFilial("SEA")+cNumBor),.T.))
				Exit
			Endif

			IF SE2->E2_SALDO == 0 .Or. SE2->E2_TIPO $ MVABATIM
				SEA->(dbSkip())
				Loop
			EndIF
			IF SE2->E2_TIPO $MVRECANT+"/"+MVPROVIS
				SEA->(dbSkip())
				Loop
			EndIF

			// Ponto entrada para filtrar titulos de bordero
			If lF240FILTC
				cFil240Tc := ExecBlock("F240FILTC",.F.,.F.)
				IF ! &cFil240Tc
					SEA->(dbSkip())
					Loop
				EndIf
			EndIf

			// Posiciona no fornecedor
			SA2->( dbSeek(FWxFilial("SA2", SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA) )

			nSeq++
			nRegSeq++
			nRegLote++
			If lF240Sum
				nSomaValor += ExecBlock("F240SUM",.F.,.F.)
			Else
				nSomaValor += SE2->E2_SALDO+SE2->E2_SDACRES-SE2->E2_SDDECRE
			Endif

			nAbatim	+= SumAbatPag(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,;
										SE2->E2_FORNECE,1,"S",dDataBase,SE2->E2_LOJA)
			nSomaAbat  += nAbatim
			nSomaAbLot += nAbatim

			If lF240SumA
				nSomaAcres += ExecBlock("F240SUMA",.F.,.F.)
			Else
				nSomaAcres += SE2->E2_SDACRES
			Endif

			If lF240SumD
				nSomaDecre += ExecBlock("F240SUMD",.F.,.F.)
			Else
				nSomaDecre += SE2->E2_SDDECRE
			Endif

			If Empty(SE2->E2_IDCNAB) // So gera outro identificador, caso o titulo ainda nao o tenha
				// Gera identificador do registro CNAB no titulo enviado
				cIdCnab := GetSxENum("SE2", "E2_IDCNAB","E2_IDCNAB"+cEmpAnt,nOrdCNAB)
				cChaveID := If(lNewIndice,cIdCnab,xFilial("SE2")+cIdCnab)

				dbSelectArea("SE2")
				aOrdSE2 := SE2->(GetArea())
				dbSetOrder(nOrdCNAB)
				While SE2->(MsSeek(cChaveID))
					ConOut("Id CNAB " + cIdCnab + " já existe para o arquivo SE2. Gerando novo número ")
					If ( __lSx8 )
						ConfirmSX8()
					EndIf
					cIdCnab := GetSxENum("SE2", "E2_IDCNAB","E2_IDCNAB"+cEmpAnt,nOrdCNAB)
					cChaveID := If(lNewIndice,cIdCnab,xFilial("SE2")+cIdCnab)
				EndDo

				// Ponto de entrada para tratamento da variavel cIdCnab
				If lF240ICNB
				cIdCnab := ExecBlock("F240ICNB",.F.,.F.,{cIdCnab})
				EndIf

				SE2->(RestArea(aOrdSE2))
				Reclock("SE2")
				SE2->E2_IDCNAB := cIdCnab
				MsUnlock()
				ConfirmSx8()
			Endif

			// Grava as linhas de detalhe de acordo com o tipo do bordero
			Fa240Linha( cDeta ,@cLocaBco,@cLocaPro,@cDetb,lIsItau)
			Fa240Linha( cDetb ,@cLocaBco,@cLocaPro)
			Fa240Linha( cDetc ,@cLocaBco,@cLocaPro)
			If cModelo $ "30|31"
				nSeq++
				Fa240Linha( cDetJ52 ,@cLocaBco,@cLocaPro)
			EndIf

			If lF240Grv
				ExecBlock("F240Grv",.F.,.F.)
			EndIf

			dbSelectArea("SEA")
			dbSkip( )
		EndDo


		// Grava o trailler de lote
		fa240linha(cTraiLote)
	EndDO

	// Grava o trailler de arquivo
	fa240linha("F")

	// Fecha os arquivos Ascii
	FCLOSE( nHdlSaida )
	FCLOSE( nHdlBco )

	// Atualiza N£mero do ultimo Disco
	dbSelectArea("SEE")
	IF !Eof()
		Reclock("SEE")
		nUltDisco := VAL(EE_ULTDSK)+1
		Replace EE_ULTDSK With StrZero(nUltDisco,TamSx3("EE_ULTDSK")[1])
		MsUnlock( )
	EndIF

	// Ponto de Entrada F240TGRV
	// Permite customizar regra apos terminar a gravacao do arquivo
	If lF240TGRV
		ExecBlock( "F240TGRV", .F., .F. )
	EndIf

	RestArea(aAreaFWM)
	RestArea(aAreaFK7)
	RestArea(aAreaSE2)
	RestArea(aAreaSEA)
	RestArea(aArea)

Return(.T.)

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa240Linha
Grava linha do Arquivo Remessa SisPag

@author Vinicius S.Barreira
@since 15/05/1995
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function Fa240Linha( cParametro ,cLocaBco,cLocaPro, cDetB, lIsItau)
	Local nLidos := 0
	Local nTamArq := 0
	Local nTam := 0
	Local nDec := 0
	Local cConteudo := ""
	Local lTemConf := .F.

	DEFAULT cDetB := ""
	DEFAULT lIsItau := .F.

	cLocaBco := If(Empty(cLocaBco),"",cLocaBco)
	cLocaPro := If(Empty(cLocaPro),"",cLocaPro)
	If ValType( cParametro ) # "C" .or. Empty( cParametro )
		Return .T.
	Endif

	// L - Arquivo de Parametrização
	nLidos := 0
	FSEEK(nHdlBco,0,0)
	nTamArq := FSEEK(nHdlBco,0,2)
	FSEEK(nHdlBco,0,0)

	While nLidos <= nTamArq

		// Verifica o tipo qual registro foi lido
	xBuffer := Space(85)
	FREAD(nHdlBco,@xBuffer,85)

	If SubStr( xBuffer,1,1) == cParametro
		nTam := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
		nDec := Val(SubStr(xBuffer,23,1))
		cConteudo := SubStr(xBuffer,24,60)

			//Necessito verificar quando for Itau, se vai ser emitido aviso ao
			//favorecido, para gerar o segmento B
			If lIsItau .and. cParametro == "G"  // Segmento A
			If SubStr(xBuffer,17,3) == "230"  //Posicao onde se informa se envia aviso
					If &(Alltrim(cConteudo)) $ "3/5/9"  //Envia aviso
						cDetB := "H"
					Endif
				Endif
			Endif

			If ( "Codigo Banco   "==SubStr(xBuffer,2,15) .Or.;
				"Num. Agencia   "==SubStr(xBuffer,2,15) .Or.;
				"Num. C/C.      "==SubStr(xBuffer,2,15) )
				If (!SubStr(xBuffer,2,15)$cLOCAPRO )
					cLOCABCO += &(ALLTRIM(cConteudo))
					cLOCAPRO += SubStr(xBuffer,2,15)
				EndIf
			EndIf
			If ( ("CGC"$Upper(SubStr(xBuffer,2,15)) .And.;
				AllTrim(cConteudo)=='"16670085000155"' ) .Or.;
				cLOCABCO=="34101403000000034594" )
				Alert(STR0079) //"CONFIGURACAO INVALIDA"
				lGrava := .F.
			Else
				lTemConf := .T.
				lGrava := fA240Grava(nTam,nDec,cConteudo)
			EndIf
		IF !lGrava
			Exit
		Endif
	Endif

	nLidos += 85
	EndDO

	If lTemConf
		FWRITE(nHdlSaida,CHR(13)+CHR(10))
		nTotLinha++ // Incremento o total de linhas do arquivo
	EndIf

Return

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} NumTitulo
Retorna a chave de localização do t¡tulo

@author Vinicius S.Barreira
@since 15/05/1995
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function NumTitulo()
	Local cRetorno := ""

	cRetorno := SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCELA + SE2->E2_TIPO + ;
				SE2->E2_FORNECE

Return cRetorno

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} NumTitLoja
Retorna a chave de localização do t¡tulo + Forn + Loja

@author Vinicius S.Barreira
@since 15/05/1995
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function NumTitLoja()
	Local cRetorno := ""

	cRetorno := SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCELA + SE2->E2_TIPO + ;
				SE2->E2_FORNECE + SE2->E2_LOJA

Return cRetorno

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} AbrePar
Abre arquivo de Parametros

@author Wagner Xavier
@since 26/05/1992
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Static Function AbrePar()
	Local cArqEnt    As Char
	Local cArqSaida  As Char
	Local cMvLocEnv  As Char
	Local nPonto     As Numeric
	Local nBarra     As Numeric
	Local nContraBar As Numeric
	Local cMvpar04   As Char
	Local cExtensao  As Char
	
	//Inicializa variáveis
	cArqEnt    := MV_PAR03
	cArqSaida  := ""
	cMvLocEnv  := Alltrim(SuperGetMV("MV_LOCENV", .F., "")) //Parâmetro onde será gravado o diretório
	nPonto     := AT(".", mv_par04)
	nBarra     := AT("/", mv_par04)
	nContraBar := AT("\", mv_par04) 
	cMvpar04   := TRIM(mv_par04)
	cExtensao  := ""
	
	//Define a extensão do arquivo.
	If (nPonto == 0 .Or. Len(cExtensao := SubStr(cMvpar04, (nPonto+1))) == 0) 
		cExtensao := TRIM(SEE->EE_EXTEN)
	EndIf
	
	If Empty(cMvLocEnv)
		If nPonto > 0 .And. (nBarra+nContraBar) > 0
			cArqSaida := SubStr(cMvpar04, 1, (nPonto-1)) + "." + cExtensao
		ElseIf (nBarra+nContraBar) > 0
			cArqSaida := Alltrim(mv_par04) + "." + cExtensao
		else
			Help(" ", 1, "F150ARQ", Nil, STR0128, 1, 0) //"Nome do Arquivo de Saida Inválido
			Return .F.
		EndIf
	ElseIf !Empty(cMvLocEnv) .And. !Empty(mv_par04) .And. AT(":", mv_par04) == 0 .And. ;
		(nBarra == 0 .Or. nContraBar == 0 ) .And. (AT("/", cMvLocEnv) > 0 .Or. AT("\", cMvLocEnv) > 0)		
		//Verifica qual barra está o parâmetro , e o que está na ultima posição através do RAT
		If AT("/", cMvLocEnv) > 0 .And. RAT("/", SUBSTR(cMvLocEnv, LEN(cMvLocEnv), 1)) == 0
			If nPonto > 0
				cArqSaida := cMvLocEnv + "/" + SubStr(cMvpar04, 1, (nPonto - 1)) + "." + cExtensao
			Else
				cArqSaida := cMvLocEnv + "/" + cMvpar04 + "." + cExtensao
			Endif
		Elseif AT("/", cMvLocEnv) > 0 .And. RAT("/", SUBSTR(cMvLocEnv, LEN(cMvLocEnv), 1)) > 0
			If nPonto > 0
				cArqSaida := cMvLocEnv + SubStr(cMvpar04, 1, (nPonto - 1)) + "." + cExtensao
			Else
				cArqSaida := cMvLocEnv + cMvpar04 + "." + cExtensao
			Endif
		Elseif AT("\", cMvLocEnv) > 0 .And. RAT("\", SUBSTR(cMvLocEnv, LEN(cMvLocEnv), 1)) == 0
			If nPonto > 0
				cArqSaida := cMvLocEnv+"\"+SubStr(cMvpar04, 1, (nPonto - 1)) + "." + cExtensao
			Else
				cArqSaida := cMvLocEnv + "\" + cMvpar04 + "." + cExtensao
			Endif
		ElseIf AT("\", cMvLocEnv) > 0 .And. RAT("\", SUBSTR(cMvLocEnv, LEN(cMvLocEnv), 1)) > 0
			If nPonto > 0
				cArqSaida := cMvLocEnv + SubStr(cMvpar04, 1, (nPonto - 1)) + "." + cExtensao
			Else
				cArqSaida := cMvLocEnv + cMvpar04 + "." + cExtensao
			Endif
		EndIf
	ElseIf !Empty(cMvLocEnv) .And. Empty(mv_par04) .Or. (nBarra > 0 .Or. nContraBar > 0 .Or. AT(":", mv_par04) > 0 )
		Help(" ", 1, "F150ARQ", Nil, STR0129, 1, 0) //"Nome do Arquivo de Saida Inválido
		Return .F.
	EndIf
	
	//Ponto de entrada para alterar o nome da variavel cArqSaida
	If lFA240NAR
		cArqSaida := ExecBlock("FA240NAR",.F.,.F.,cArqSaida)
	EndIf
	
	If !FILE(cArqEnt)
		Help(" ", 1, "NOARQPAR")
		Return .F.
	EndIf
	
	nHdlBco := FOPEN(cArqEnt,0+64)
	//Cria Arquivo Saida
	nHdlSaida := MSFCREATE(cArqSaida, 0)
Return .T.

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} AbrePar
Rotina de Geração do Arquivo de Remessa de Comunicação Bancária p/ Contas a Receber

@author Pilar S. Albaladejo
@since 14/04/1994
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function fA240Grava( nTam,nDec,cConteudo )
	Local lConteudo := .T., cCampo

	While .T.

		// Analisa conteudo
		IF Empty(cConteudo)
			cCampo := Space(nTam)
		Else
			lConteudo := fa150Orig( cConteudo )
			IF !lConteudo
				Exit
			Else
				IF ValType(xConteudo)="D"
					cCampo := GravaData(xConteudo,.F.)
				Elseif ValType(xConteudo)="N"
					cCampo := Substr(Strzero(xConteudo,nTam,nDec),1,nTam)
				Else
					cCampo := Substr(xConteudo,1,nTam)
				Endif
			Endif
		Endif
		
		IF Len(cCampo) < nTam  //Preenche campo a ser gravado, caso menor
			cCampo := cCampo+Space(nTam-Len(cCampo))
		Endif
		
		Fwrite( nHdlSaida,cCampo,nTam )
		Exit
	Enddo

Return lConteudo

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa240DbEva
Trata o dbeval para marcar e desmarcar item

@author Wagner Xavier
@since 20/05/1992
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function Fa240DbEva(nLimite,dVenIni240,dVenFim240, cAliasSE2,aGetMark,lPrimeiro,lFina241)
	Local cFilAtu   := cFilAnt
	Local aAreaOld  := GetArea()
	Local lCondic   := .F.
	Local lBxTit	:= .T.
	Local lFinVDoc	:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios

	//--- Tratamento Gestao Corporativa
	Local lGestao   := FWSizeFilial() > 2	// Indica se usa Gestao Corporativa

	DEFAULT cAliasSE2 := "SE2"
	DEFAULT lFina241 := .F.

	SE2->(dbGoto((cAliasSE2)->NUM_REG))
	lCondic := SE2->(MsRLock()) .AND. (cAliasSE2)->(MsRLock())

	__lFina241 := lFina241

	//Motor de retenções
	If __lMotorRet == NIL
		__lMotorRet := If(FindFunction("FTemMotor"), FTemMotor(), .F.)
	Endif

	If lCondic

		If __lFina241 .and. __lMotorRet
			F240GETRet()
		Endif

		If MV_PAR05 == 1 .And. (nValor + (cAliasSE2)->E2_SALDO  <= (nLimite) .Or. Empty(nLimite)) .And. (cAliasSE2)->E2_VENCREA >= dVenIni240 .And. (cAliasSE2)->E2_VENCREA <= dVenFim240 .and. (cAliasSE2)->E2_SALDO > 0

			//Se for exclusivo, troco a filial corrente pela filial do titulo que esta sendo marcado
			If lGestao    // CHG

			If !Empty( FwFilial("SE2") )
				cFilAnt := (cAliasSE2)->E2_FILIAL
			Endif

			Else

			If !Empty((cAliasSE2)->E2_FILIAL)
				cFilAnt := (cAliasSE2)->E2_FILIAL
			Endif

			EndIf

			lBxTit := .T.

			// Caso tenha integracao SIGAPFS e seja um titulo com natureza juridica sem rateio finalizado
			If !Fa240Juri()
				lBxTit := .F.
			EndIf
			//-------------------------------------------------------------------------------------------
			// PONTO DE ENTRADA F240TIT
			// Verifica se titulo pode ser marcado para baixa ou nÆo.
			// Caso tenha sido alterada a marcação do titulo, ExecBlock deverá retornar .F., para nÆo
			// haver alteração dos acumuladores de valores e numero de titulos.
			// O 4º parametro informa se o registro dever  ser Lockado ou nÆo.
			//-------------------------------------------------------------------------------------------
			IF lF240TIT .and. Empty((cAliasSE2)->E2_OK)
				lBxTit := ExecBlock("F240tit",.F.,.F.,.F.)
			Endif

			// Caso tenha integracao Documentos
			IF lBxTit .And. lFinVDoc
				If !CN062ValDocs("06",.F.,.F.,.T.,@lPrimeiro)
					lBxTit := .F.
				EndIf
			EndIf

			If lBxTit
				If ValType(aGetMark)<>"U"
					If (nPos := Ascan(aGetMark,{|x| x==(cAliasSE2)->NUM_REG})) == 0
						(cAliasSE2)->E2_OK := "  "
					Else
						(cAliasSE2)->E2_OK := cMarca
						nTotAbat := F240GETSOMA()
						nValor   += ((cAliasSE2)->E2_SALDO + (cAliasSE2)->E2_SDACRES - (cAliasSE2)->E2_SDDECRE) - nTotAbat + (cAliasSE2)->E2_VLACES //  VA
						nQtdTit++
					Endif
				Else
					(cAliasSE2)->E2_OK := cMarca
					nTotAbat := F240GETSOMA()
					nValor   += ((cAliasSE2)->E2_SALDO + (cAliasSE2)->E2_SDACRES - (cAliasSE2)->E2_SDDECRE) - nTotAbat + (cAliasSE2)->E2_VLACES	//  VA
					nQtdTit++
				Endif
			Else
				(cAliasSE2)->(MsUnlock())
				SE2->(MsUnlock())	//destravo registro do arquivo principal para que possa liberar para outro usuário
			Endif
		Else

			If ValType(aGetMark)<>"U"
				If (nPos := Ascan(aGetMark,{|x| x==(cAliasSE2)->NUM_REG})) > 0
					(cAliasSE2)->E2_OK := cMarca
					nTotAbat := F240GETSOMA()
					nValor   += ((cAliasSE2)->E2_SALDO + (cAliasSE2)->E2_SDACRES - (cAliasSE2)->E2_SDDECRE) - nTotAbat + (cAliasSE2)->E2_VLACES	//  VA
					nQtdTit++
				Endif
			Else
				(cAliasSE2)->E2_OK := "  "
			Endif

			// Caso tenha integracao Documentos
			If lBxTit .And. lFinVDoc
				If !CN062ValDocs("06",.F.)
					(cAliasSE2)->E2_OK := "  "
					nTotAbat := F240GETSOMA()
					nValor   -= ((cAliasSE2)->E2_SALDO + (cAliasSE2)->E2_SDACRES - (cAliasSE2)->E2_SDDECRE) - nTotAbat + (cAliasSE2)->E2_VLACES	//  VA
					nQtdTit--
				EndIf
			EndIf

			(cAliasSE2)->(MsUnlock())
			SE2->(MsUnlock())	//destravo registro do arquivo principal para que possa liberar para outro usuário
		Endif
	Endif

	cFilAnt := cFilAtu
	RestArea(aAreaold)

Return Nil

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa240Mark
Trata o dbeval para marcar e desmarcar item

@author Nilton Pereira
@since 03/11/2007
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function Fa240Mark(cMarca,oValor,oQtda,cAliasSE2,nReg)
	Local lRet	:= .T.
	Local lVld	:= .F.
	Local lCondic := .F.

	DEFAULT cAliasSE2 := "SE2"

	SE2->(dbGoto((cAliasSE2)->NUM_REG))
	lCondic := SE2->(MsRLock(nReg)) .AND. (cAliasSE2)->(MsRLock(nReg))

	If lCondic .and. EMPTY(SE2->E2_NUMBOR) .and. SE2->E2_SALDO > 0
		If GetNewPar("MV_VLTITAD",.F.) .And. ( (cAliasSE2)->E2_OK <> cMarca )
			If F090VlMark(.F.,cAliasSE2,cMarca,oValor,oQtda,oMark,nValor,"FINA240")
				lVld := .T.
			Endif
		Else
			lVld := .T.
		Endif
		If lVld
			FA240Inverte(cMarca,oValor,oQtda,.F.,cAliasSE2)
			lRet := .T.
		Else
			lRet := .F.
		Endif
	Else
		IW_MsgBox(STR0054,STR0055,"STOP") //"Este titulo está sendo utilizado em outro terminal, não pode ser utilizado na fatura"###"Atenção"
		lRet := .F.
	Endif
	oMark:oBrowse:Refresh(.t.)
	SE2->(dbGoto((cAliasSE2)->NUM_REG))
Return lRet

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa240Inverte
Inverte as marcacoes dos títulos

@author Wagner Xavier
@since 11/01/1996
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function Fa240Inverte(cMarca,oValor,oQtda,lTudo,cAliasSE2)
	Local nReg := (cAliasSE2)->(Recno())
	Local lBxTit := .T.
	Local cFilAtu := cFilAnt
	Local lCondic := .F.
	Local lFinVDoc	:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios
	Local lPrimeiro:=.T.
	//--- Tratamento Gestao Corporativa
	Local lGestao   := FWSizeFilial() > 2	// Indica se usa Gestao Corporativa

	DEFAULT cAliasSE2 := "SE2"
	Default lTudo := .T.

	dbSelectArea(cAliasSE2)

	If lTudo
		dbgotop()
	Endif

	While !Eof()

		SE2->(dbGoto((cAliasSE2)->NUM_REG))
		lCondic := SE2->(MsRLock()) .AND. (cAliasSE2)->(MsRLock())

		//Preenche o campo impostos retidos
		If __lFina241
			F240GETRet()
		Endif

		If lCondic .and. Empty(SE2->E2_NUMBOR) .and. SE2->E2_SALDO > 0

			//Se for exclusivo, troco a filial corrente pela filial do titulo que esta sendo marcado
			If lGestao    // CHG
			If !Empty( FwFilial("SE2") )
				cFilAnt := (cAliasSE2)->E2_FILIAL
			Endif
			Else
			If !Empty((cAliasSE2)->E2_FILIAL)
				cFilAnt := (cAliasSE2)->E2_FILIAL
			Endif
			EndIf

			lBxTit := .T.

			IF	(cAliasSE2)->E2_OK == cMarca
				(cAliasSE2)->E2_OK := "  "

				//-------------------------------------------------------------------------------------------
				// PONTO DE ENTRADA F240DES - Inverso do F240TIT
				// Executado quando o titulo é desmarcado.
				// ExecBlock deve retornar .F., para nÆo haver alteração dos acumuladores de valores e numero de titulos.
				// O 4º parametro informa se o registro dever  ser Lockado ou nÆo no PE
				//-------------------------------------------------------------------------------------------
				If lF240Des .and. Empty((cAliasSE2)->E2_OK)
					lBxTit := ExecBlock("F240DES",.F.,.F.,.F.)
				EndIf

				(cAliasSE2)->(MsUnlock())
				SE2->(MsUnlock())	//destravo registro do arquivo principal para que possa liberar para outro usuário

				If lBxTit
					nTotAbat := F240GETSOMA()
					nValor   -= ((cAliasSE2)->E2_SALDO+(cAliasSE2)->E2_SDACRES-(cAliasSE2)->E2_SDDECRE) - nTotAbat + (cAliasSE2)->E2_VLACES	//  VA
					nQtdTit--
				EndIf
			Else
				lBxTit := .T.

				// Caso tenha integracao Documentos
				IF lFinVDoc
					If !CN062ValDocs("06",.F.,.F.,lTudo,@lPrimeiro)
						lBxTit := .F.
					EndIf
				EndIf

				// Caso tenha integracao SIGAPFS e seja um titulo com natureza juridica sem rateio finalizado
				If !Fa240Juri()
					Help(" ",1,"F240JURI",, STR0080,1,0) // "Nao permite baixar titulos com rateio juridico incompleto"
					lBxTit := .F.
				EndIf
				(cAliasSE2)->E2_OK := cMarca

				//-------------------------------------------------------------------------------------------
				// PONTO DE ENTRADA F240TIT
				// Verifica se titulo pode ser marcado para baixa ou nÆo.
				// Caso tenha sido alterada a marcação do titulo, ExecBlock deverá retornar .F., para nÆo
				// haver alteração dos acumuladores de valores e numero de titulos.
				// O 4º parametro informa se o registro dever ser Lockado ou nÆo.
				//-------------------------------------------------------------------------------------------
				IF lF240TIT .and. !Empty((cAliasSE2)->E2_OK)
					lBxTit := ExecBlock("F240TIT",.F.,.F.,.F.)
				Endif
				If lBxTit
					nTotAbat := F240GETSOMA()
					nValor   += ((cAliasSE2)->E2_SALDO+(cAliasSE2)->E2_SDACRES-(cAliasSE2)->E2_SDDECRE) - nTotAbat + (cAliasSE2)->E2_VLACES	//  VA
					nQtdTit++
				Else
					(cAliasSE2)->E2_OK := "  "
					(cAliasSE2)->(MsUnlock())
					SE2->(MsUnlock())	//destravo registro do arquivo principal para que possa liberar para outro usuário
				Endif
			Endif
		Endif
		If !lTudo
			Exit
		Endif
		dbSkip()
	Enddo

	cFilAnt := cFilAtu
	nQtdTit:= Iif(nQtdTit<0,0,nQtdTit)
	(cAliasSE2)->(dbGoto(nReg))
	oValor:Refresh()
	oQtda:Refresh()
	oMark:oBrowse:Refresh(.t.)

Return Nil

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} $F240GETSOMA
Esta função Verifica se o calculo da função SOMAABAT() já foi efetuado para o registro atual de cAliasSE2
@type function
@author norbertom
@since 04/08/2017
@version 1.0
@return $numerico, $Valor de Abatimento do título posicionado, caso houver.
@example
	nTotAbat := F240GETSOMA()
/*/
//-----------------------------------------------------------------------------------------------------------------------
STATIC Function F240GETSOMA()
	Local nRet := 0
		If (cAliasSE2)->CALCULADO == '1'
			nRet := (cAliasSE2)->VLSOMAABAT
		Else
			nRet := SomaAbat((cAliasSE2)->E2_PREFIXO,(cAliasSE2)->E2_NUM,(cAliasSE2)->E2_PARCELA,"P",(cAliasSE2)->E2_MOEDA,,(cAliasSE2)->E2_FORNECE)
			(cAliasSE2)->VLSOMAABAT := nRet
			(cAliasSE2)->CALCULADO := '1'
		EndIf
Return nRet

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} $F240GETRET
Esta função Verifica se o calculo da função SOMAABAT() já foi efetuado para o registro atual de cAliasSE2
@type function
@author PEQUIM
@since 04/08/2017
@version 1.0
@return $numerico, $Valor de retenção realizada pelo título, caso houver.
@example
	nTotAbat := F240GETRET()
/*/
//-----------------------------------------------------------------------------------------------------------------------
STATIC Function F240GETRET()
	Local nRetencao := 0
	Local cChaveTit := 0
	Local cChaveFK7 := 0

		If (cAliasSE2)->CALCULADO == '1'
			nRetencao := (cAliasSE2)->VLSOMARET
		Else

			If FTemMotor()
				cChaveTit := xFilial("SE2", (cAliasSE2)->E2_FILORIG)	+ "|" +;
											(cAliasSE2)->E2_PREFIXO		+ "|" +;
											(cAliasSE2)->E2_NUM			+ "|" +;
											(cAliasSE2)->E2_PARCELA		+ "|" +;
											(cAliasSE2)->E2_TIPO		+ "|" +;
											(cAliasSE2)->E2_FORNECE		+ "|" +;
											(cAliasSE2)->E2_LOJA
				cChaveFK7 := FINGRVFK7("SE2", cChaveTit)

				nRetencao := FINXVRET("P", cChaveFK7)
			Endif

			(cAliasSE2)->VLSOMARET := nRetencao

		EndIf

Return nRetencao

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa240Disp
Exibe Valores na tela

@author Pilar S. Albaladejo
@since 20/12/1996
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function Fa240Disp(cMarca,lInverte,oValor,oQtda)
	Local lBxTit := .T.

	If IsMark("E2_OK",cMarca,lInverte)
		//-----------------------------------------------------------------------------
		// PONTO DE ENTRADA F240TIT
		// Verifica se titulo pode ser marcado para baixa ou nÆo. Caso tenha sido
		// alterada a marcação do titulo, ExecBlock deverá retornar .F., para nÆo
		// haver alteração dos acumuladores de valores e numero de titulos.
		// O 4º parametro informa se o registro dever ser Lockado ou não no PE
		//-----------------------------------------------------------------------------
		lBxTit := .T.
		IF lF240TIT .and. !Empty("E2_OK")
			lBxTit := ExecBlock("F240TIT",.F.,.F.,.T.)
		Endif
		If lBxTit
			nTotAbat := SomaAbat(E2_PREFIXO,E2_NUM,E2_PARCELA,"P",E2_MOEDA,,E2_FORNECE)
			nValor   += (E2_SALDO+E2_SDACRES-E2_SDDECRE) - nTotAbat	+ (cAliasSE2)->E2_VLACES	//  VA
			nQtdTit++
		Endif
	Else
		//-----------------------------------------------------------------------------
		// PONTO DE ENTRADA F240DES - Inverso do F240TIT
		// Executado quando o titulo é desmarcado.
		// ExecBlock deve retornar .F., para nÆo haver alteração dos acumuladores de
		// valores e numero de titulos. O 4º parametro informa se o registro dever 
		// ser Lockado ou nÆo no PE
		//-----------------------------------------------------------------------------
		If lF240Des .and. Empty("E2_OK")
			lBxTit := ExecBlock("F240Des",.F.,.F.,.T.)
		EndIf
		If lBxTit
			nTotAbat := SomaAbat(E2_PREFIXO,E2_NUM,E2_PARCELA,"P",E2_MOEDA,,E2_FORNECE)
			nValor   -= (E2_SALDO+E2_SDACRES-E2_SDDECRE) - nTotAbat + (cAliasSE2)->E2_VLACES	//  VA
			nQtdTit--
			nQtdTit:= Iif(nQtdTit<0,0,nQtdTit)
		EndIf
	End

	oValor:Refresh()
	oQtda:Refresh()
	oMark:oBrowse:Refresh(.t.)

Return

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SomaVal1
Retorna o valor total dos titulos remetidos exceto abatimentos

@author Pilar S. Albaladejo
@since 03/03/1997
@version 1.0

/*/
//-----------------------------------------------------------------------------------------------------------------------
Function SomaVal1()

	//Variaveis PRIVATE da remessa de arquivo CNAB - FINA150/FINA420
	nSomaValor	:= If(Type("nSomaValor") != "N", 0, nSomaValor)
	nSomaAbat	:= If(Type("nSomaAbat") != "N", 0, nSomaAbat)

	If Type("nSomaVal1") == "U"
		nSomaVal1 := (nSomaValor - nSomaAbat)
	Else
		nSomaVal1 += (nSomaValor - nSomaAbat)
	Endif

Return nSomaVal1 * 100

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc}SomaVLot1
Retorna o valor total dos titulos remetidos do lote exceto abatimen.

@return nSomaVLot1 -  Retorna valor total do lote sem abatimento.

@author Leonardo Castro da Silva
@since  04/04/2016
/*/
//-----------------------------------------------------------------------------------------------------------------------
Function SomaVLot1()

	//Variaveis PRIVATE da remessa de arquivo CNAB - FINA150/FINA420
	nSomaVlLote	:= If(Type("nSomaVlLote") != "N", 0, nSomaVlLote)
	nSomaAbLot	:= If(Type("nSomaAbLot") != "N", 0, nSomaAbLot)

	If Type("nSomaVLot1") == "U"
		nSomaVLot1 := (nSomaVlLote - nSomaAbLot)
	Else
		nSomaVLot1 += (nSomaVlLote - nSomaAbLot)
	Endif

Return nSomaVLot1 * 100

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc}fa240Perg
Chama Pergunta Principal

@author Mauricio Pequim Jr
@since  14/05/1998
/*/
//-----------------------------------------------------------------------------------------------------------------------
Function fa240Perg()

	SetKey (VK_F12,{|a,b| AcessaPerg("F240BR",.T.)})
	pergunte("F240BR",.F.)

Return

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc}Fa240Lote
Retorna o numero do lote de serviço (Usado na configuracao do SISPAG)

@author Mauricio Pequim Jr
@since  14/05/1998
/*/
//-----------------------------------------------------------------------------------------------------------------------
Function Fa240Lote()
Return nLote			// esta variavel armazena o sequencial do lote por segmento do arquivo SISPAG

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc}Fa240Lin
Retorna o total de linhas do arquivo  (Usado na configuracao do SISPAG)

@author Mauricio Pequim Jr
@since  15/01/2003
/*/
//-----------------------------------------------------------------------------------------------------------------------
Function Fa240Lin()
Return nTotLinha		// esta variavel armazena o numero de linhas do arquivo

//-------------------------------------------------------------------
/*{Protheus.doc} Fa240Pesq
Pesquisa no arquivo temprário
@author Mauricio Pequim Jr

@version P12
@since   03/01/2018
@return  Nil
@obs Função utilizada nas rotinas FINA240 e FINA241
*/
//-------------------------------------------------------------------
Function Fa240Pesq(oMark, cAliasSE2, nIndice)
	Local nX       := 0
	Local nPesqui  := Len(aPesqui)
	Local nIndices := 0
	
	If nPesqui == 0 .And. (nIndices := Len(aIndices)) > 0
		For nX := 1 to nIndices
			cDescInd := Alltrim(aIndices[nX,1])
			aAdd(aPesqui, {cDescInd, nX})
			aAdd(aCbx, cDescInd)
		Next
	Endif
	
	dbSelectArea(cAliasSE2)
	nRet := F240Psq(oMark:oBrowse, aPesqui)
	oMark:oBrowse:Refresh(.T.)
Return Nil

//-------------------------------------------------------------------
/*{Protheus.doc} F240Psq
Pesquina no arquivo temprário
@author Mauricio Pequim Jr

@version P12
@since   03/01/2018
@return  Nil
@obs Função utilizada nas rotinas FINA240 e FINA241
*/
//-------------------------------------------------------------------
Function F240Psq(oBrowse, aPesqui)
	Local oDlg		:= NIL
	Local oCbx		:= NIL
	Local cCampo	:= SPACE(100)
	Local cOrd		:= ""
	Local lSeek		:= .F.
	Local nRet		:= 0
	Local cAlias	:= Alias()
	Local nRecOri 	:= (cAlias)->(Recno())
	Local nPosInd   := 0
	
	DEFINE MSDIALOG oDlg FROM 00,00 TO 100,550 PIXEL TITLE STR0001 //"Pesquisar"

	@ 05,05 COMBOBOX oCBX VAR cOrd ITEMS aCbx SIZE 236,15 PIXEL OF oDlg FONT oDlg:oFont
	@ 22,05 MSGET oBigGet VAR cCampo SIZE 236,12 PIXEL

	DEFINE SBUTTON FROM 05,245 TYPE 1 OF oDlg ENABLE ACTION (nRet := 1, lSeek := .T., oDlg:End() )
	DEFINE SBUTTON FROM 20,245 TYPE 2 OF oDlg ENABLE ACTION oDlg:End()
	ACTIVATE MSDIALOG oDlg CENTERED
	
	If lSeek .And. (nPosInd := aScan(aCbx, Alltrim(cOrd))) > 0		
		nRet := nRecOri
		(cAlias)->(DbSetOrder(aPesqui[nPosInd,2]))
		
		If (cAlias)->(DbSeek(RTRIM(cCampo)))
			nRet := (cAlias)->(Recno())
		EndIf
		
		If oBrowse != Nil
			oBrowse:Refresh()
		EndIf
	Endif

Return nRet

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F240TudoOk
Verifica se dados essenciais foram digitados

@author Mauricio Pequim Jr
@since  15/01/2003
/*/
//-----------------------------------------------------------------------------------------------------------------------
Function F240TudoOk(oDlg)
	Local nX
	Local lRet := .T.
	Local uRetPE
	Local CQueryF70 := ""
	Local cAliasQry := ""
	Local lTemF70 := AliasIndic("F70")
	Local aArea := GetArea()

	For nX := 1 To Len(oDlg:aControls)
		If ValType(oDlg:aControls[nX]) == "O" .And.;
			!Empty(oDlg:aControls[nX]:bValid)

			lRet:=Eval(oDlg:aControls[nX]:bValid)
			If ValType(lRet) != "L"
				lRet := .T.
			Endif
			If !lRet
				Exit // Sai no primeiro campo invalido
			Endif
		Endif
	Next
	If lRet
		If lF240OK2
			uRetPE := ExecBlock("F240OK2")
			If ValType(uRetPE) == "L"
				lRet := uRetPE
			Else
				lRet := .F.
			EndIf
		EndIf
	EndIf
	If lRet .and. !lChkAPI
		If cModPgto $ "45/47" .and. lTemF70
			cQueryF70 := "SELECT F70_ACTIVE  " 
			cQueryF70 += "FROM " + RetSQLName("F70") + " F70 "
			cQueryF70 += "WHERE F70.F70_COD = '"+cPort240+"' AND "
			cQueryF70 += " F70.F70_AGENCI = '"+cAgen240+"' AND "
			cQueryF70 += " F70.F70_NUMCON = '"+cConta240+"' AND "
			cQueryF70 += " F70.F70_ACTIVE = '1' AND "
			cQueryF70 += " F70.D_E_L_E_T_ = ' '"
			cQueryF70 := ChangeQuery(cQueryF70)
		
			cAliasQry := GetNextAlias()
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQueryF70),cAliasQry,.F.,.T.)
		
			If (cAliasQry)->(EOF())
				Help(" ",1,"F240TEMF70",, STR0140,1,0) //Os modelos de borderô 45 e 47 requerem uma chave PIX ativa para o banco selecionado
				lRet := .F.
			Endif
    	EndIf
	Endif
	RestArea(aArea)
Return lRet

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa240Top
Define Topo da MsSelect()

@author Mauricio Pequim Jr
@since  15/01/2003
/*/
//-----------------------------------------------------------------------------------------------------------------------
Function Fa240Top(nTipo)

	Local cRetorno := ""
	Local cIndice := ""

	If Select( cAliasSE2 ) > 0
		cIndice := (cAliasSE2)->( IndexKey() )
	EndIf

	If !Empty( cIndice ) .And. At( "E2_FILIAL" , cIndice ) == 1
		// mv_par 02 = Considera Filiais Abaixo
		// nTipo = 1 -> Verificando o topo da MsSelect
		// nTipo = 2 -> Verificando o fim da Msselect
		cRetorno := IIF(mv_par08==1, IIf(nTipo==1, xFilial("SE2",aSelFil[1]), xFilial("SE2",aSelFil[Len(aSelFil)])), xFilial("SE2",aSelFil[1]))
	Else
		If At( "+" , cIndice ) <> 0
			cIndice := SubStr( cIndice , 1 , At( "+" , cIndice ) - 1 )
		EndIf

		cRetorno := PadC( "" , Len( (cAliasSE2)->( &(cIndice) ) ) , Iif( nTipo == 1 , Space( 1 ) , "Z" ) )
	EndIf
Return(cRetorno )

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SomaAcres
Retorna o valor total dos acrescimos dos titulos remetidos

@author Mauricio Pequim Jr
@since  15/01/2003
/*/
//-----------------------------------------------------------------------------------------------------------------------
Function SomaAcres()
Return nSomaAcres * 100

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SomaDecre
Retorna o valor total dos decrescimos dos titulos remetidos

@author Mauricio Pequim Jr
@since  15/01/2003
/*/
//-----------------------------------------------------------------------------------------------------------------------
Function SomaDecre()
Return nSomaDecre * 100

//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GetMoedas
Obter as moedas utilizadas pelo sistema

@author Mauricio Pequim Jr
@since  15/01/2003
/*/
//-----------------------------------------------------------------------------------------------------------------------
Static Function GetMoedas()
	Local aRet     := {}
	Local aArea    := GetArea()
	Local aAreaSx6 := Sx6->(GetArea())
	Local cFilSx6

	// Inicializa array com as moedas existentes.
	GetMv("MV_MOEDA1")
	cFilSx6 := SX6->X6_FIL
	While Substr(SX6->X6_VAR,1,8) == "MV_MOEDA" .And. ;
			SX6->(!Eof()) .And. SX6->X6_FIL == cFilSx6
		If Substr(SX6->X6_VAR,9,1) != "P" .AND. Substr(SX6->X6_VAR,9,2) != "CM" // Desconsiderar plural e MV_MOEDACM
			Aadd( aRet, StrZero(Val(Substr(SX6->X6_VAR,9,2)),2) + " " + GetMv(SX6->X6_VAR) )
		Endif
		SX6->(DbSkip())
	EndDo
	ASort(aRet)
	Sx6->(RestArea(aAreaSx6))
	RestArea(aArea)

Return aRet

//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} MenuDef
Utilizacao de menu Funcional

Parametros do array aRotina
1. Nome a aparecer no cabecalho
2. Nome da Rotina associada
3. Reservado
4. Tipo de Transação a ser efetuada:
	1 - Pesquisa e Posiciona em um Banco de Dados
	2 - Simplesmente Mostra os Campos
	3 - Inclui registros no Bancos de Dados
	4 - Altera o registro corrente
	5 - Remove o registro corrente do Banco de Dados
5. nIvel de acesso
6. Habilita Menu Funcional

@author Ana Paula N. Silva
@version P12
@since   29/11/2006
@return  Array com opcoes da rotina.
*/
//-----------------------------------------------------------------------------------------------------------------------
Static Function MenuDef()
	Local aRotina := { { STR0001, "AxPesqui"      , 0 , 1,,.F.} ,;  //"Pesquisar"
					{ STR0002, "FA240Borde"    , 0 , 3} ,;  //"Bordero"
					{ STR0003, "FA240Canc"     , 0 , 3} ,;  //"Cancelar"
					{ STR0083, "FA040Legenda"  , 0 ,7, ,.F.  }}  	//"Legenda"
Return(aRotina)


//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} FinA240T
Chamada semi-automatica utilizado pelo gestor financeiro

@author Marcelo Celi Marques
@version P12
@since  31/03/08
@return  nIl
*/
//-----------------------------------------------------------------------------------------------------------------------
Function FinA240T(aParam)
	cRotinaExec := "FINA240"
	ReCreateBrow("SE2",FinWindow)
	FinA240(aParam[1])
	ReCreateBrow("SE2",FinWindow)
	dbSelectArea("SE2")

	INCLUI := .F.
	ALTERA := .F.

Return .T.


//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} F240MTTMP
Montagem do Temporário

@author Mauricio Pequim Jr
@version P12
@since  28/09/2006
@return  nIl
*/
//-----------------------------------------------------------------------------------------------------------------------
Function F240MTTMP(cQuery,aCampos, aRestrict,cAliasSE2, lFina241)
	Local cChaveFK7 as Character
	Local cIDDOCFK7 as Character

	Local nX		 := 0
	Local aEstruct	 := {}
	Local aArea		 := GetArea()
	Local cFilSE2	 := ""
	Local lFA240PA	 := ExistBlock("FA240PA") // PE que permite a seleção de PA com mov. bancária na tela de Borderô
	Local nTcSql	 := 0

	//--- Tratamento VALORES ACESSORIOS - CP - INICIO
	Local cPictVa  	 := PesqPict( "FKD", "FKD_SALDO" )
	Local nVA		 := 0
	//--- Tratamento VALORES ACESSORIOS - CP - FIM
	Local cFilFwSE2  := xFilial("SE2")
	Local cQuery2	 := ''
	Local cCampos	 := ''
	Local cExcepts   := "E2_ORIGEM"
	Local nMoedaBco	 := Max(MoedaBco(cPort240,cAgen240,cConta240),1)
	Local aSeek		 := {}

	DEFAULT lFina241 := .F.

	//Atibuição de valores
	cChaveFK7  := ''
	cIDDOCFK7  := ''
	__lFina241 := lFina241

	//Motor de retenções
	__lMotorRet := If(FindFunction("FTemMotor"), FTemMotor(), .F.)

	// PONTO DE ENTRADA PARA PERMITIR TÍTULOS DO TIPO "PA" NO BORDERÔ
	If lFA240PA
		lFA240PA := ExecBlock("FA240PA") // Caso permitir PA no borderô
		IF lFA240PA
			cFiltro:= STRTRAN(cQuery, "E2_TIPO <> '" + MVPAGANT + "' AND ", "") // remove condição do filtro.
		Endif
	EndIf

	// Montagem dos campos na Array
	aCampos := {}
	AADD(aCampos,{"E2_OK","","  ",""})

	dbSelectArea("SX3")
	SX3->(dbSetOrder(1))
	dbSeek ("SE2")
	//Adiciona o campo E2_FILIAL no browse somente se o SE2 estiver exclusivo e em uso.
	If !Empty( cFilFwSE2 ) .Or. X3USO(x3_usado) .And. cNivel >= x3_nivel .AND. ASCAN(aRestrict,{|x| alltrim(upper(x)) == alltrim(upper(x3_campo))}) > 0
		AAdd(aCampos,{X3_CAMPO,"",AllTrim(X3Titulo()),X3_PICTURE})
		AAdd(aEstruct,{X3_CAMPO,X3_TIPO,X3_TAMANHO,X3_DECIMAL})
		SX3->(dbSkip())
	EndIf

	While !EOF() .And. (x3_arquivo == "SE2")
		cCampoSX3 := alltrim(upper(x3_campo))

		IF ( ( ASCAN(aRestrict,{|x| alltrim(upper(x)) == cCampoSX3 }) > 0) .Or. ;
			( (SX3->X3_TIPO != "M" .and. (X3USO(x3_usado) .or. AllTrim(X3_CAMPO) $ cExcepts) .AND. ;
				cNivel >= x3_nivel .and. X3_CONTEXT != "V") ) )

			AAdd( aCampos,	{ X3_CAMPO,	""     , AllTrim(X3Titulo()), X3_PICTURE } )
			AAdd( aEstruct,	{ X3_CAMPO,	X3_TIPO, X3_TAMANHO,		  X3_DECIMAL } )
		Endif
		SX3->(dbSkip())
	Enddo

	// VA - INICIO
	If lFKDBx
		Aadd( aCampos	, { "E2_VLACES"	, ""	,STR0130, cPictVa 	}) // ###STR0130 "Valor Acessório"
		Aadd( aEstruct	, { "E2_VLACES"	, "N"	,16		,2			})
	EndIf
	// VA - FIM

	If aScan(aEstruct, {|x| Alltrim(UPPER(x[1])) == Alltrim(UPPER("E2_OK"))}) == 0
		AADD(aEstruct,{"E2_OK","C",2,0})
	Endif

	If aScan(aEstruct, {|x| Alltrim(UPPER(x[1])) == Alltrim(UPPER("NUM_REG"))}) == 0
		AADD(aEstruct,{"NUM_REG","N",10,0})
	Endif

	AADD(aEstruct,{"VLSOMAABAT","N",14,2})
	AADD(aEstruct,{"CALCULADO","C",1,0})

	If __lFina241
		AADD(aEstruct,{"VLSOMARET","N",16,2})
		AADD(aCampos,{"VLSOMARET",'','Retenções','@E 9,999,999,999,999.99'})
	Endif

	//Deleta a tabela temporária no banco de dados, caso já exista
	If __oFIN2401 <> Nil
		__oFIN2401:Delete()
		__oFIN2401 := Nil
	Endif

	//-----------------------------------------------------------
	// Criação da Tabela Temporaria
	//-----------------------------------------------------------
	__oFIN2401 := FWTemporaryTable():New( cAliasSE2 )
	__oFIN2401:SetFields( aEstruct )

	//Adiciono o índice da tabela temporária
	For nX := 1 To Len(aIndices)
		Aadd(aSeek, {aIndices[nX][1], aIndices[nX][2], nX})

		cTmpIdx := "Tmp_Idx_" + StrZero((nX + 1), 2)
		aChave	:= StrTokArr(AllTrim(aIndices[nX][3]), "+")

		__oFIN2401:AddIndex(cTmpIdx, aChave)
	Next

	__oFIN2401:Create()

	cQuery2 := " INSERT "
	If AllTrim(TcGetDb()) == "ORACLE"
		cQuery2 += " /*+ APPEND */ "
	EndIf

	AEval( aRestrict, { |e,i| cCampos += If( i == 1, AllTrim(e), "," + AllTrim(e) ) } )

	cCampos += ',E2_OK, NUM_REG'

	If AllTrim(TcGetDb()) == "DB2"
		cQuery := STRTRAN( cQuery, "FOR READ ONLY", "" )
	EndIf

	cQuery2 += " INTO " + __oFIN2401:GetRealName() + " (" + cCampos + " ) " + cQuery

	Processa( { || nTcSql := TcSQLExec(cQuery2) } )

	If nTcSql < 0
		Help( " ", 1, "F240MTTMP", , STR0138, 1, 0 ) //"Não foi possivel montar a tabela temporaria, favor verificar o seu ambiente Protheus."
	EndIf

	(cAliasSE2)->(DbGoTop())
	// ---------------------------------------------------------------------------------------

	If lFA240PA
		lFA240PA := ExecBlock("FA240PA")
	EndIf

	While !(cAliasSE2)->(EOF())

		If FwIsInCallStack("FINA240")
			If cModPgto == '47'
				cChaveFK7 := (cAliasSE2)->E2_FILIAL+"|"+(cAliasSE2)->E2_PREFIXO+"|"+(cAliasSE2)->E2_NUM+"|"+ (cAliasSE2)->E2_PARCELA +"|"+;
								(cAliasSE2)->E2_TIPO+"|"+(cAliasSE2)->E2_FORNECE+"|"+(cAliasSE2)->E2_LOJA
				cIDDOCFK7 := FINGRVFK7("SE2", cChaveFK7)

				If F240QrCode(cIDDOCFK7)
					(cAliasSE2)->(DBDelete())
					(cAliasSE2)->(DbSkip())
					Loop
				EndIf

			EndIf
		EndIf

		// Para o Brasil, apresenta somente os titulos cuja moeda e' a mesma do banco
		// selecionado para baixa.
		// Caso a moeda do banco estiver vazia ou caso o motivo de baixa nao movimente banco, considero apenas a moeda forte
		If cPaisLoc=="BRA" .and. nMoedaBco > 1 .and. !FXVldBxBco(cPort240,cAgen240,cConta240,(cAliasSE2)->E2_NATUREZ, (cAliasSE2)->E2_MOEDA,.F.)
			(cAliasSE2)->(DBDelete())
			(cAliasSE2)->(DbSkip())
			Loop
		EndIf

		// Se ativou o parametro MV_F240QRY, deve fazer o filtro direto na Query,
		// para nao interferir posteriormente no filtro da IndRegua e MsSelect
		If !Empty( cFil240 ) .And. !( &cFil240 )
			(cAliasSE2)->(DBDelete())
			(cAliasSE2)->(DbSkip())
			Loop
		EndIf

		If lFKDBx
			nVA  := FValAcess( (cAliasSE2)->E2_PREFIXO, (cAliasSE2)->E2_NUM, (cAliasSE2)->E2_PARCELA, (cAliasSE2)->E2_TIPO, (cAliasSE2)->E2_FORNECE, (cAliasSE2)->E2_LOJA, (cAliasSE2)->E2_NATUREZ, .T., /*cCodVa*/, "P",dDataBase,/*aValAces*/, (cAliasSE2)->E2_MOEDA, /*nMoedaBco*/, /*nTxMoeda*/ )
			(cAliasSE2)->E2_VLACES	:= nVA
		EndIf
		If !lFA240PA .and. Alltrim((cAliasSE2)->E2_TIPO) $ MVPAGANT
			If AllTrim(xFilial("SE2")) <> AllTrim((cAliasSE2)->E2_FILIAL)
				cFilSE2 := xFilial("SE2", (cAliasSE2)->E2_FILORIG)
			Else
				cFilSE2 := xFilial("SE2")
			EndIf

			SE5->(DbSetOrder(7))			
			If (SE5->(dbSeek(cFilSE2 + (cAliasSE2)->(E2_PREFIXO+E2_NUM+E2_PARCELA + "PA " + E2_FORNECE + E2_LOJA))))				
				(cAliasSE2)->(DBDelete())
				(cAliasSE2)->(Dbskip())
				Loop				
			Endif
		Endif

		(cAliasSE2)->(DbSkip())

	EndDo

	If FwIsInCallStack("FINA240")
		If __oQueryFKF <> Nil 
			__oQueryFKF:Destroy()
			__oQueryFKF := Nil
		EndIf
	EndIf
	

	(cAliasSE2)->(__DBPack())

	RestArea(aArea)

Return cAliasSE2

//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} f240QryA
Montagem do Temporário

@author Pablo Gollan Carreras
@version P12
@since  12/01/2010
@return  nIl
*/
//-----------------------------------------------------------------------------------------------------------------------
Static Function f240QryA(lAtua, cAliasSE2, aCampos, aRestrict, cIndTemp1, cIndTemp2, aSelFil, aTmpFil, cModPgto, lRefresh)
	Local nOrder as Numeric	
	Local cBranch as Character
	Local lBranch as Logical
	
	Local cQuery		:= ""
	Local cFiltro		:= ""
	Local nOldInd		:= IndexOrd()
	Local lPergDtAg		:= Type("mv_par11") == "D" .and. Type("mv_par12") == "D" .and. mv_par10 == 1
	Local lGestao		:= FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
	Local cFilFwSE2		:= IIF( lGestao , FwFilial("SE2") , xFilial("SE2") )
	Local cTmpSE2Fil	:= ""
	Local lBlockEasy	:= .T.
	Local lIntPFS		:= SuperGetMv("MV_JURXFIN", .T., .F.) // Integração SIGAPFS x SIGAFIN
	Local nPosIndex		:= 0
	Local nF240Ind		:= 0
	Local lTemF72       := AliasIndic("F72")
	Local lTemFKF      	:= AliasIndic("FKF")

	DEFAULT aSelFil		:= {}
	DEFAULT aTmpFil		:= {}
	Default lRefresh	:= .F.

	nOrder    := 1
	cBranch   := ""
	lBranch   := FindFunction("totvs.protheus.backoffice.ngf.util.BranchRelation")

	If lF240IND == NIL
		lF240IND	:= ExistBlock("F240IND")
	Endif

	dbSelectArea("SE2")

	If lAtua .And. Select(cAliasSE2) # 0
		aGetMark := F240Markdos(cAliasSE2)
		dbSelectArea(cAliasSE2)
		dbCloseArea()
		F240Clean() //Deleta tabela temporária no banco de dados criada da função F240MTTMP
	Endif

	cFiltro := FA240Chec2()
	cQuery := "SELECT "
	aEval(aRestrict,{|x| cQuery += x + ", "})
	cQuery += "E2_OK, SE2.R_E_C_N_O_ NUM_REG "
	cQuery += "FROM " + RetSqlName("SE2") + " SE2 "

	If cModPgto == "45" .AND. lTemF72 
		cBranch := "SE2.E2_FILIAL = SA2.A2_FILIAL "
		If lBranch 
			cBranch  := totvs.protheus.backoffice.ngf.util.BranchRelation( {'SE2','E2_FILIAL','SE2'}, {'SA2','A2_FILIAL','SA2'}  )
		EndIf
		CQuery += "INNER JOIN " + RetSqlName("SA2") + " SA2 "
		CQuery += "ON SE2.E2_FORNECE = SA2.A2_COD "
		CQuery += "AND SE2.E2_LOJA = SA2.A2_LOJA "
		cQuery += "AND " + cBranch + " "
        cQuery += "AND SA2.D_E_L_E_T_ = ? "
		CQuery += "LEFT JOIN " + RetSqlName("F72") + " F72 "
		CQuery += "ON SE2.E2_FORNECE = F72.F72_COD "
		CQuery += "AND SE2.E2_LOJA = F72.F72_LOJA "
		CQuery += "AND SA2.A2_FILIAL = F72.F72_FILIAL "
        cQuery += "AND F72.D_E_L_E_T_ = ? "
		cQuery += "AND F72.F72_ACTIVE = ? "

	EndIf

	If cModPgto == "47" .AND. lTemFKF
		cQuery += "INNER JOIN  " + RetSQLName("FK7") + " FK7 "
        cQuery += "ON E2_FILIAL = FK7_FILTIT "
        cQuery += "AND E2_PREFIXO = FK7_PREFIX "
        cQuery += "AND E2_NUM = FK7_NUM "
        cQuery += "AND E2_PARCELA = FK7_PARCEL "
        cQuery += "AND E2_TIPO = FK7_TIPO "
        cQuery += "AND E2_FORNECE = FK7_CLIFOR "
        cQuery += "AND E2_LOJA = FK7_LOJA "
        cQuery += "AND FK7.D_E_L_E_T_ = ? "
		cQuery += "INNER JOIN "
		cQuery += "   " + RetSqlName("FKF") + " FKF "
        cQuery += "   ON FKF.FKF_FILIAL = FK7.FK7_FILIAL " 
        cQuery += "   AND FKF.FKF_IDDOC = FK7.FK7_IDDOC "
        cQuery += "   AND FKF.D_E_L_E_T_ = ? "
	EndIf

	If lIntPFS .And. FWAliasInDic("OHF") .And. FindFunction("JFilBorPag") .And. SuperGetMv("MV_JURXFIN", .T., .F.) // Integração SIGAPFS x SIGAFIN
		cQuery += JFilBorPag(.F.) //Aqui contém a clausula Where
	Else
		cQuery += " WHERE "
	EndIf

	If lLibTCB
		cQuery += "E2_FILORIG = ? AND "
	ElseIf mv_par08 == 1
		If Empty( cFilFwSE2 )
			cQuery += "E2_FILORIG ? AND "
		Else
			cQuery += "E2_FILIAL ? AND "
		EndIf
	Else
		cQuery += "E2_FILIAL = ? AND "
	EndIf
	
	If MV_PAR09 == 1 //Considera Forma de Pgto?
		cQuery += "E2_FORMPAG = ? AND "
	Endif

	If lPergDtAg .and. mv_par10 == 1 .and. !Empty(mv_par12) // Considera Agendamento
		cQuery += "E2_DATAAGE <> ' ' AND "
		cQuery += "E2_DATAAGE BETWEEN ? AND ? AND "
	EndIf

	cQuery += "E2_VENCREA BETWEEN ? AND ? AND "

	If lF240EASY
		lBlockEasy := ExecBlock("F240EASY",.F.,.F.)
	Endif

	If ValType(lBlockEasy) != "L" .Or. lBlockEasy
		//---------------------------------------------------------------------------------
		// Títulos originados pelos módulos de comércio exterior não devem ser alterados
		//---------------------------------------------------------------------------------
		If FindFunction("EasyOrigem") .And. FindFunction("F050EasyOrig")
			cQuery += "( E2_ORIGEM NOT IN ('SIGAEEC','SIGAEDC','SIGAECO','SIGAEFF','SIGAESS')) AND "
		Else
			cQuery += "( E2_ORIGEM NOT IN ('SIGAEIC','SIGAEEC','SIGAEDC','SIGAECO','SIGAEFF','SIGAESS')) AND "
		EndIf
	EndIf

	cQuery += "SE2.D_E_L_E_T_ = ? AND "

	If cModPgto == "45" .AND. lTemF72 
		CQuery += " ( F72.F72_COD IS NOT NULL OR ( (SA2.A2_BANCO IS NOT NULL AND SA2.A2_AGENCIA IS NOT NULL AND SA2.A2_NUMCON IS NOT NULL) AND "
		CQuery += " ( SA2.A2_BANCO <> ' ' AND SA2.A2_AGENCIA <> ' ' AND SA2.A2_NUMCON <> ' ' ) ) ) AND "
	EndIf

	If cModPgto == "47" .AND. lTemFKF
	CQuery += " ( FK7_FILTIT IS NOT NULL AND FK7.FK7_IDDOC IS NOT NULL OR ( (FKF.FKF_FILIAL IS NOT NULL AND FKF.FKF_IDDOC IS NOT NULL) AND "
	CQuery += " ( FKF.FKF_FILIAL <> ' ' AND FKF.FKF_IDDOC <> ' ' ) ) ) AND "
	EndIf

	cQuery += cFiltro + " "
	cQuery += "ORDER BY E2_FILIAL, E2_VENCREA"
	cQuery := ChangeQuery(cQuery)
	__of240qryA := FWPreparedStatement():New(cQuery)

	//Valores dos binds da query
	If cModPgto == "45" .AND. lTemF72 
		__of240qryA:SetString(nOrder++, ' ')
		__of240qryA:SetString(nOrder++, ' ')
		__of240qryA:SetString(nOrder++, '1')
	EndIf

	If cModPgto == "47" .AND. lTemFKF
		__of240qryA:SetString(nOrder++, ' ')
		__of240qryA:SetString(nOrder++, ' ')
	EndIf

	If lLibTCB
		__of240qryA:SetString(nOrder++, cFilAnt)
	ElseIf mv_par08 == 1
		If Empty( cFilFwSE2 )
			__of240qryA:SetUnsafe(nOrder++, GetRngFil( aSelFil, "SE2", .T., @cTmpSE2Fil, , .T. ))
		Else
			__of240qryA:SetUnsafe(nOrder++, GetRngFil( aSelFil, "SE2", .T., @cTmpSE2Fil ))
		EndIf
	Else
		__of240qryA:SetString(nOrder++, xFilial("SE2"))
	EndIf

	If MV_PAR09 == 1 //Considera Forma de Pgto?
		__of240qryA:SetString(nOrder++, cModPgto)
	EndIf

	If lPergDtAg .and. mv_par10 == 1 .and. !Empty(mv_par12) // Considera Agendamento
		__of240qryA:SetDate(nOrder++, mv_par11)
		__of240qryA:SetDate(nOrder++, mv_par12)
	EndIf

	__of240qryA:SetDate(nOrder++, dVenIni240)
	__of240qryA:SetDate(nOrder++, dVenFim240)
	__of240qryA:SetString(nOrder++,' ')

	cQuery := __of240qryA:getFixQuery()

	If lF240IND .And. lRefresh
		If aNewIndex == Nil
			aNewIndex := F240Index(aIndices)
		EndIf

		nF240Ind := ExecBlock("F240IND", .F., .F., {.T., AClone(aNewIndex)})

		If !(FwSIXUtil():ExistIndex("SE2", (RetAsc(nF240Ind, 1, .T.)))) .Or. (nPosIndex := AScan(aNewIndex, {|indice| indice[1] == nF240Ind})) == 0
			nF240Ind	:= 1
			nPosIndex	:= 1
		EndIf

		nF240Index := nPosIndex

		SE2->(DbSetOrder(nF240Ind))
	EndIf

	cArqNew := F240MTTMP(cQuery, aCampos, aRestrict, cAliasSE2)

	If lF240IND
		SE2->(DbSetOrder(nOldInd))
	Endif

	dbSelectArea(cArqNew)
	(cArqNew)->(dbgotop())

	If lAtua
		nValor := 0
		nQtdTit := 0
		nTotAbat := 0
		nVA	:= 0 		// VA
		If !(cArqNew)->(Eof())
			dbEval({|x| fa240DbEva(nLimite,dVenIni240,dVenFim240,cAliasSE2,aGetMark)},{|| !Eof()})
			(cArqNew)->(dbGoTop())
		Endif
		oValor:Refresh()
		oQtda:Refresh()
		oMark:oBrowse:Refresh(.T.)
	Endif

	dbSelectArea(cArqNew)
	(cArqNew)->(DbSetOrder(nF240Index))
	(cArqNew)->(DbGoTop())

	If __of240qryA <> Nil 
		__of240qryA:Destroy()
		__of240qryA := Nil
	EndIf

Return cArqNew

//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} FA240JURI
Verifica se tem integracao SIGAPFS e é titulo com natureza juridica sem rateio finalizado

@author Pablo Gollan Carreras
@version P12
@since  12/01/2010
@return  nIl
*/
//-----------------------------------------------------------------------------------------------------------------------
Function Fa240Juri(cAlias)
	Local lRet := .T. //informa se o valor do título principal foi completamente rateado
	Local lIntPFS := SuperGetMv("MV_JURXFIN",.T.,.F.)
	Local aArea 	:= GetArea()
	Local aAreaSED := GetArea()
	Local aAreaNVR := GetArea()

	DEFAULT cAlias := "SE2"

	SED->(DbSetOrder(1))
	SED->(DbSeek(cFilial + (cAlias)->E2_NATUREZ))
	If lIntPFS .And. !Empty(SED->ED_GRPNAT) .And. SED->ED_RATOBR == "2"

		DbSelectarea("NVR")
		NVR->(DbSetorder(1))
		If NVR->( dbSeek( xFilial("NVR") + (cAlias)->E2_PREFIXO + (cAlias)->E2_NUM + (cAlias)->E2_PARCELA + (cAlias)->E2_TIPO + (cAlias)->E2_FORNECE + (cAlias)->E2_LOJA ) )
			DbSelectarea("NVS")
			NVS->( dbSetorder(1) )
			NVS->( dbSeek( xFilial("NVS") + NVR->NVR_PROCES )	)
			nSdoJuri := 0
			While NVS->( !EOF() ) .AND. NVS->NVS_PROCES == NVR->NVR_PROCES
				nSdoJuri += NVS->NVS_VALOR
				NVS->( DBSKIP() )
			End
			If nSdoJuri <> (cAlias)->E2_VALOR
				lRet := .F.
			Else
				lRet := .T.
			EndIf
		EndIf
	EndIf
	RestArea( aAreaSED )
	RestArea( aAreaNVR )
	RestArea( aArea )
Return lRet

//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} F240Markdos
Funcao que gravará os registros selecionados antes de executar o refresh da tela

@author Clovis Magenta
@version P12
@since  12/02/2010
@return  nIl
*/
//-----------------------------------------------------------------------------------------------------------------------
Function F240Markdos(cAlias)
	Local aMarkdos := {}
	Local aArea 	:= GetArea()
	Local aAreaAlias	:= (cAlias)->(GetArea())

	dbSelectArea(cAlias)
	(cAlias)->(dbGoTop())
	While (cAlias)->(!EOF())
		If (cAlias)->E2_OK == cMarca
			Aadd(aMarkdos, (cAlias)->NUM_REG )
		Endif
		(cAlias)->(dbSkip())
	Enddo

	RestArea(aAreaAlias)
	RestArea(aArea)

Return aMarkdos

//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} F240VldBco
Realiza validacao do banco informado e atualiza agencia e conta caso exista o codigo do banco.

@author Gustavo Henrique
@version P12
@since  16/11/2010
@return  nIl
*/
//-----------------------------------------------------------------------------------------------------------------------
Function F240VldBco( cPort240, cAgen240, cConta240, lVldHelp, lVldBlqCta, oGet)
	Local lRet 		:= .T.
	Local cCampo	As Character
	Local cAg240	As Character
	Local cCc240	As Character
	Local lHelpBco  As Logical

	Default cPort240   := ""
	Default cAgen240   := ""
	Default cConta240  := ""
	Default lVldHelp   := .F.
	Default lVldBlqCta := .F.
	Default oGet	   := Nil

	lHelpBco := .T.
	cCampo	 := AllTrim(ReadVar())

	If oGet != Nil .And. (!lVldBco .Or. (lVldHelp .And. lVldBlqCta))
		If !lVldBco .And. cCampo $ "CPORT240|CAGEN240"
			lRet := Iif(cCampo == "CPORT240", (CarregaSA6(@cPort240, @cAg240, @cCc240, .T.)), (CarregaSA6(@cPort240, @cAgen240, @cCc240, .T.)))

			If lRet
				cAgen240	:= Iif(cCampo == "CAGEN240", cAgen240, cAg240)
				cConta240	:= cCc240
				oGet:SetFocus()
			EndIf
		ElseIf !(lVldBco := CarregaSA6( @cPort240, @cAgen240, @cConta240, lVldHelp, Nil, lVldBlqCta ))
			lRet := !lVldBco
			oGet:SetFocus()
		EndIf
	ElseIf AllTrim( cPort240 ) # AllTrim( SA6->A6_COD )
		
		cAgen240	:= Iif(Empty(cAgen240), CriaVar( "A6_AGENCIA" ), cAgen240)
		cConta240	:= Iif(Empty(cConta240), CriaVar( "A6_NUMCON"  ), cConta240)
		
		If cCampo == "CPORT240" 
			cAgen240  := ""
			cConta240 := ""
		EndIf

		If cCampo == "CAGEN240" 
			cConta240 := ""
			lHelpBco  := .F.
		EndIf

		lRet := CarregaSA6( @cPort240, @cAgen240, @cConta240, lHelpBco )

		//Chama rotina para verificar se o Banco + Agencia + Conta está configurado para transmissão do borderô via TCB para inibição do checkbox
		F240CHKTCB()

	EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} F240Conf
Ponto de Entrada para a confirmacao da criacao do bordero de pagamento e permanecer na tela de selecao de titulos.

@author Andrea Verissimo
@version P12
@since  02/02/2011
@return  nIl
*/
//-----------------------------------------------------------------------------------------------------------------------
Static Function F240Conf()
	Local lF240Conf := ExistBlock("F240CONF")
	Local lRetorno  := .T.

	If lF240Conf
		lRetorno := ExecBlock("F240CONF",.F.,.F.)
	Endif

Return lRetorno

//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} F240VldMd
Valida a combinacao entre a moeda do banco e a moeda da dos titulos a serem selecionados (tela inicial)

@author Mauricio Pequim Jr
@version P12
@since  14/04/2011
@return  nIl
*/
//-----------------------------------------------------------------------------------------------------------------------
Function F240VldMd(cPort240,cAgen240,cConta240,nMoeda240)
	Local lRet := .T.
	Local nMoedaBco := Max(MoedaBco(cPort240,cAgen240,cConta240),1)

	// Para o Brasil, apresenta somente os titulos cuja moeda e' a mesma do banco em caso de banco em moeda estrangeira
	If FXMultSld() .and. nMoedaBco > 1
		If nMoedaBco != nMoeda240
			Help(" ",1,"F240MOEDA",, STR0094,1,0) //"Para bancos em moeda estrangeira, os borderô somente poderá ter títulos em moeda igual a do banco"
		lRet := .F.
	Endif
	Endif

Return lRet

//-----------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} F240RetFils
Retorna filiais que o usuario logado tem acesso

@author Gustavo Henrique
@version P12
@since  21/09/2011
@return  nIl
*/
//-----------------------------------------------------------------------------------------------------------------------
Function F240RetFils( cFilIni, cFilFim )
	Local cFils		:= ""
	Local i			:= 0
	Local j			:= 0
	Local nTamFil   := ""

	Default cFilIni	:= Space( TamSX3( "E2_FILIAL" )[1] )
	Default cFilFim	:= PadR( "Z", TamSX3( "E2_FILIAL" )[1], "Z" )

	nTamFil := len(cFilIni)

	// --------------------------------------------------------------------------
	// SIGAPSW.PRW:RSWRET()	Retorna um vetor com informacoes do ultimo usuario ou
	//						grupo posicionado pela funcao PswSeek.
	// RSWRET()[2][6]		Vetor contendo as empresas, cada elemento contem a
	// 						empresa e a filial. Ex:"9901", se existir "@@@@"
	//						significa acesso a todas as empresas.
	// --------------------------------------------------------------------------
	If aPswUser == nil
		PswOrder( 1 )
		PswSeek( __cUserId, .T. )
		aPswUser := PswRet()
	Else
		PswOrder( 2 )
		PswSeek( aPswUser[1][2], .T. )
	Endif

	// Prioriza informacao do grupo?
	If ( ValType( aPswUser ) == "A" ) .and. ( aPswUser[2][11] )
		For i := 1 To Len( aPswUser[1][10] )
			// Pesquisa o(s) Grupo(s) que o Usuario participa
			PswOrder( 1 )
			If PswSeek( aPswUser[1][10][i], .F. )
				aPswGrupo := FwGrpEmp(aPswUser[1][10][i])
				If ( ValType( aPswGrupo ) == "A" )
					For j := 1 To Len( aPswGrupo)
						If	aPswGrupo[j] == "@@@@"
							cFils := "@@"
							Exit
						ElseIf	SubStr( aPswGrupo[j], 1, Len(cEmpAnt) ) == cEmpAnt
							If  SubStr( aPswGrupo[j], 3, nTamFil ) >= cFilIni .And. ;
								SubStr( aPswGrupo[j], 3, nTamFil ) <= cFilFim
								cFils += SubStr( aPswGrupo[j], 3, nTamFil ) + "/"
							EndIf
						EndIf
					Next j
				EndIf
			EndIf
		Next i
	// Prioriza Informacao do Usuario
	Else
		If ( ValType( aPswUser ) == "A" )
			For i := 1 To Len( aPswUser[2][6] )
				If	aPswUser[2][6][i] == "@@@@"
					cFils := "@@"
					Exit
				ElseIf	SubStr( aPswUser[2][6][i], 1, 2 ) == cEmpAnt
					If  SubStr( aPswUser[2][6][i], 3, 2 ) >= cFilIni .And. ;
						SubStr( aPswUser[2][6][i], 3, 2 ) <= cFilFim
						cFils += SubStr( aPswUser[2][6][i], 3, LEN(aPswUser[2][6][i]) ) + "/"
					EndIf
				EndIf
			Next i
		EndIf
	EndIf

Return cFils

//-------------------------------------------------------------------
/*{Protheus.doc} F240Clean
Função responsável por limpar o arquivo temporário criado na função
@author Fabio Casagrande Lima

@version P12
@since   14/12/2016
@return  Nil
@obs Função utilizada nas rotinas FINA240 e FINA241
*/
//-------------------------------------------------------------------
Function F240Clean(lLimpa241)
	Default lLimpa241 := .F.

	If __oFIN2401 <> Nil
		__oFIN2401:Delete()
		__oFIN2401 := Nil
	Endif

	If __oFIN2402 <> Nil
		__oFIN2402:Destroy()
		__oFIN2402 := Nil
	Endif

	If lLimpa241
		__lFina241 := .F.
	Endif

Return

//-------------------------------------------------------------------
/*{Protheus.doc} F240GetName
Retorna o nome real da tabela do objeto __oFIN2401
@author Fabio Casagrande Lima

@version P12
@since   14/12/2016
@return  Nil
@obs Função utilizada nas rotinas FINA240 e FINA241
*/
//-------------------------------------------------------------------
Function F240GetName()
	Local cRealName As Character

	cRealName := ""

	If __oFIN2401 <> Nil
		cRealName := __oFIN2401:GetRealName()
	Endif

Return cRealName

//-------------------------------------------------------------------
/*{Protheus.doc} F240Restr
Montagem dos campos para a MarkBrowse
@author Mauricio Pequim Jr

@version P12
@since   14/12/2016
@return  Nil
@obs Função utilizada nas rotinas FINA240 e FINA241
*/
//-------------------------------------------------------------------
Function F240Restr(lAutomato, lBorAut)
	Local nX := 0
	Local cCampoSX3 := ""
	Local aRestrict := {"E2_FILIAL"	, "E2_PREFIXO",	"E2_NUM"	, "E2_PARCELA",	"E2_TIPO"  , "E2_NATUREZ", "E2_PORTADO", "E2_FORNECE", "E2_LOJA"   , ;
						"E2_NOMFOR"	, "E2_VENCREA",	"E2_NUMBCO"	, "E2_SALDO"  ,	"E2_MOEDA" , "E2_NUMBOR" , "E2_FATPREF", "E2_FATURA" , "E2_ORDPAGO", ;
						"E2_ANOBASE", "E2_MESBASE",	"E2_SDACRES", "E2_SDDECRE",	"E2_PLLOTE", "E2_IDCNAB" , "E2_FILORIG", "E2_CODBAR" , "E2_PLOPELT", ;
						"E2_NODIA"  , "E2_EMIS1"  , "E2_ARQRAT", "E2_ORIGEM" }

	Local lBordAuto := .F.
	Local aUsrSE2	:= {}

	DEFAULT lAutomato := .F.
	DEFAULT lBorAut := .F.

	aIndices	:= {}
	aPesqui		:= {}
	aCbx		:= {}

	lBordAuto := (lAutomato .or. lBorAut)

	//Motor de retenções
	__lMotorRet := If(FindFunction("FTemMotor"), FTemMotor(), .F.)

	//Tela de indices para seleção
	FinCposSix("SE2",@aIndices,@aRestrict,,,lBordAuto, @nF240Index)

	// Adiciona no array aRestrict os campos que serão exibidos no browse do bordero.
	dbSelectArea("SX3")
	dbSetOrder(1)
	dbSeek("SE2")

	While SX3->(!EOF()) .And. (x3_arquivo == "SE2")
		cCampoSX3 := alltrim(upper(x3_campo))

		If ( (ascan(aRestrict,{|x| alltrim(upper(x)) == cCampoSX3 }) == 0) .and. X3USO(SX3->X3_USADO) .and.;
			(SX3->X3_TIPO!="M") .and. (SX3->X3_CONTEXT != "V") .and. (cNivel >= SX3->X3_NIVEL) )

			aadd(aRestrict, SX3->X3_CAMPO)
		Endif
		SX3->(dbSkip())
	Enddo

	aUsrSE2:= {}

	// Ponto de entrada para adicionar campos de usuarios ao vetor de campos aRestrict
	If lF240ADCM
		aUsrSE2:= ExecBlock("F240ADCM",.F.,.F.)
		If Len(aUsrSE2) >= 0
			dbSelectArea("SX3")
			dbSetOrder(2)
			For nX := 1 to Len(aUsrSE2)
				If SX3->(dbSeek(aUsrSE2[nx])) .and. ;
					ascan(aRestrict, {|x| Alltrim(Upper(x)) == Alltrim(upper(aUsrSE2[nx])) }) == 0 .and.;
					(SX3->X3_TIPO!="M") .and. (SX3->X3_CONTEXT != "V")
					aadd( aRestrict, aUsrSE2[nX] )
				Endif
			next nX
			dbSetOrder(1)
		Endif
	EndIf

Return aRestrict


//----------------------------------------------------------------------------------
/*{Protheus.doc} FClearBrd
Limpeza de registros indevidos no SEA de titulo sendo incluido em borderô
Esta rotina ajusta a base SEA do seguinte processo
- MV_CANBORP = 'S' (retira o titulo do bordero no cancelamento da baixa)
- No cancelamento da baixa, o registro da SEA não estava sendo deletada
- Ao tentar incluir esse titulo num novo borderô, ocorria violação de chave única

@author Mauricio Pequim Jr
@version P12
@since   18/03/2020
@return  Nil
@obs Função utilizada nas rotinas FINA240, FINA241 e FINA590
*/
//----------------------------------------------------------------------------------
Function FClearBrd(cNumBor)

	Local cQuery := ""
	Local nRecSEA := 0

	DEFAULT cNumBor := ""

	If !Empty(cNumBor)
		
		If __oFIN2402 == NIL
		
			cQuery := " SELECT R_E_C_N_O_ NREGX "
			cQuery += "FROM " + RetSqlName("SEA") + " "
			cQuery += "WHERE "
			cQuery +=     "EA_FILIAL = ? "
			cQuery += "AND EA_PREFIXO = ? "
			cQuery += "AND EA_NUM = ? "
			cQuery += "AND EA_PARCELA = ? "
			cQuery += "AND EA_TIPO = ? "
			cQuery += "AND EA_FORNECE = ? "
			cQuery += "AND EA_LOJA = ? "
			cQuery += "AND EA_FILORIG = ? "			
			cQuery += "AND EA_NUMBOR <> ? "
			cQuery += "AND EA_CART = 'P' "
			cQuery += "AND D_E_L_E_T_ = ' ' "

			cQuery := ChangeQuery(cQuery)
			__oFIN2402:=FWPreparedStatement():New(cQuery)
		Endif
	
		__oFIN2402:SetString(1,xFilial("SEA",SE2->E2_FILORIG))
		__oFIN2402:SetString(2,SE2->E2_PREFIXO)
		__oFIN2402:SetString(3,SE2->E2_NUM)
		__oFIN2402:SetString(4,SE2->E2_PARCELA)
		__oFIN2402:SetString(5,SE2->E2_TIPO)
		__oFIN2402:SetString(6,SE2->E2_FORNECE)
		__oFIN2402:SetString(7,SE2->E2_LOJA)
		__oFIN2402:SetString(8,SE2->E2_FILORIG)		
		__oFIN2402:SetString(9,cNumBor)
			
		cQuery := __oFIN2402:GetFixQuery()

		nRecSEA := MpSysExecScalar(cQuery,"NREGX")

		If nRecSEA > 0
			SEA->(dbGoTo(nRecSEA))
			RecLock("SEA")
			dbDelete()
			MsUnlock()
		Endif

	Endif

Return

//----------------------------------------
/*/{Protheus.doc} $F240CHKTCB
Valida se o banco, agencia e conta 
estão configurados para transmissão 
do borderô via TCB

@author Robson
@since 10/09/2020
@version 12
/*/
//----------------------------------------
Static Function F240CHKTCB(oCbx, oApi, nOpc)
	Local aArea As Array
	Local oLayout As Object
	Default nOpc := 0 //controle para recarregar a  lChkTCB e lChkAPI
	
	//Inicializa variáveis	
	aArea   := GetArea()
	oLayout := JsonObject():new()
	lLibTCB := .F.
	lLibAPI := .F.
	
	//alterou o banco, então reinicia as variaveis
	If nOpc == 1
		lChkTCB := .F.
		lChkAPI := .F.
	EndIf

	dbSelectArea("SA6")
	SA6->(DbSetOrder(1))

	If SA6->(FieldPos("A6_TCB")) > 0
		lLibTCB := (SA6->(DbSeek(xFilial("SA6")+cPort240+cAgen240+cConta240)) .And. SA6->A6_TCB == "1")
	EndIf

	If SA6->(FieldPos("A6_CFGAPIP")) > 0
		lLibAPI := (SA6->(DbSeek(xFilial("SA6")+cPort240+cAgen240+cConta240)) .And. SA6->A6_CFGAPIP $ "1|3")
		If lLibAPI
			oLayout:FromJson(SA6->A6_CFGBOLP)  
			If oLayout:hasProperty('credentials') .And. oLayout['credentials']:hasProperty('typeCredentials')
				lLibAPI :=  oLayout['credentials']['typeCredentials'] $ "P|A" // Configurado para API pagar ou API Pagar + Extrato
			EndIf
		EndIf
	EndIf

	//Inverte se marcou TCB
	If nOpc == 2 //marcou tcb
		lChkAPI := .F.
		If oCbx <> nil .And. oApi <> nil
			oCbx:Refresh()
			oApi:Refresh()
		EndIf
	ElseIf nOpc == 3 //marcou api
		lChkTCB := .F.
		If oCbx <> nil .And. oApi <> nil
			oCbx:Refresh()
			oApi:Refresh()
		EndIf
	EndIf

	//Atualiza variaveis da consulta padrão SEEBOR
	cPort060	:= cPort240
	cAgen060    := cAgen240
	cConta060   := cConta240

	RestArea(aArea)
	FwFreeArray(aArea)	
Return

//----------------------------------------
/*/{Protheus.doc} $F240ARQTCB
Valida se os arquivos de envio e retorno do 
CNAB TCB foram gerados na pasta system

@author Robson
@since 10/09/2020
@version 12
@return lRet, Logical, indica se o arquivo
de envio existem na pasta system
/*/
//----------------------------------------
Static Function F240ARQTCB() As Logical
	Local lRet As Logical
	
	//Inicializa variável.
	lRet := .F.
	
	If !(lRet := FILE("\system\tcbpenv.2pe"))
		Help(" ", 1, "HELP", Nil, STR0143, 1 , 1 , NIL, NIL, NIL, NIL, NIL, {STR0144})
	Endif

Return lRet

//----------------------------------------
/*/{Protheus.doc} $F240CHKSUBC
Valida se o banco, agencia, conta e Subconta 
existe na tabela SEE

@author Robson
@since 10/09/2020
@version 12
@Param cPort240, Char, Código do banco
@Param cAgen240, Char, Código da agência
@Param cConta240, Char, Número da conta
@Param cSubconta, Char, Código da Sub Conta
@return lRet, Logical, indica que os parâmetros de 
bancos estão cadastrados
/*/
//----------------------------------------
Static Function F240CHKSUBC(cPort240 As Char, cAgen240 As Char, cConta240 As Char, cSubconta As Char) As Logical
	Local lRet As Logical
	
	//Inicializa variável
	lRet := .T.
	
	Default cPort240  := " "
	Default cAgen240  := " "
	Default cConta240 := " "
	Default cSubconta := " "
	
	If lChkTCB
		dbSelectArea("SEE")
		SEE->(dbSetOrder(1))
		
		If (lRet := SEE->(DbSeek(xFilial("SEE")+cPort240+cAgen240+cConta240+cSubconta)))
			cSubConta := SEE->EE_SUBCTA
		Else
			Help(" ", 1, "PAR240")
		EndIf
	Endif

	If lChkAPI
		lRet := !Empty(cSubConta) 

		If !lRet
			HELP(" ", 1, "APIPAGAR",, STR0152, 2, 0) //"A Sub conta deve ser informada, por favor verifique!"
		Endif

		If lRet 
			lRet := ExistCpo("SEE", cPort240 + cAgen240 + cConta240 + cSubconta)
		Endif
	Endif
	
Return lRet

/*/{Protheus.doc} F240Index
Monta array para passar no PE F240IND durante a execução via botão Refresh. 

@author		Rafael Riego
@since 		10/09/2021
@version	12
@param 		aIndex, array, array de índices montado conforme função FinRetSix (FINXFIN.PRX)
@return 	array, array contendo os índices selecionados pelo usuário {1=Número do Índice;2=Índice}
/*/
Static Function F240Index(aIndex As Array) As Array

	Local aDateCpo		As Array
	Local aCamposBKP	As Array

	Local cIndex		As Character

	Local nCampo		As Numeric
	Local nIndice		As Numeric
	Local nPosIndice	As Numeric

	aDateCpo 	:= {}
	aNewIndex 	:= {}
	nCampo		:= 0
	nPosIndice	:= 0
	aCamposBKP 	:= FwSX3Util():GetListFieldsStruct("SE2", .F.)

	AEval(aCamposBKP, {|campo| IIf(campo[2] == "D", AAdd(aDateCpo, campo[1]), Nil)}) 

	//Efetua ajuste no índice caso o mesmo possua campo(s) numérico(s)
	For nIndice := 1 To Len(aIndex)
		cIndex := aIndices[nIndice][3]

		While (nCampo := AScan(aDateCpo, {|campo| ("+" + campo) $ cIndex .Or. (campo +  "+") $ cIndex})) > 0
			cIndex := StrTran(cIndex, aDateCpo[nCampo], "DTOS(" + aDateCpo[nCampo] + ")")
		End
		AAdd(aNewIndex, {SE2->(RetOrder("SE2", cIndex)), aIndices[nIndice][1]})
	Next nIndice

	FwFreeArray(aDateCpo)
	FwFreeArray(aCamposBKP)

Return aNewIndex

/*/{Protheus.doc} F240CHKMOD
	Validação do modelo de pagamento que será usado no bordero
	@type  Function
	@author Vitor Duca
	@since 09/01/2023
	@version 1.0
	@param nOpc, Numeric, Verifica a operação que esta sendo executada
	@param cModPgto, Character, Codigo do modelo de pagamento (Tabela 58 SX5)
	@return lRet, Logical, Define se o modelo selecionado podera ser usado na geração do bordero
/*/
Function F240CHKMOD(nOpc As Numeric, cModPgto As Character) As Logical
	Local lRet As Logical
	DEFAULT nOpc := 0
	DEFAULT cModPgto := ""

	lRet := .T.

	If nOpc <> 0 
		lRet := ExistCpo("SX5", + "58" + cModPgto)
	Endif

	If lRet .and. lChkAPI
		If FindFunction("totvs.protheus.backoffice.ngf.bills.bb.ValidBorderoBB")
			lRet := totvs.protheus.backoffice.ngf.bills.bb.ValidBorderoBB(cModPgto)
		Endif	
	Endif	
			
Return lRet

/*{Protheus.doc} F240QrCode
Verifica se existe um Pix QRCode vinculado ao fornecedor quando a condição de pagamento do borderô for 46(Pix QRCode).

@author Samara Morais
@version P12
@since   02/09/2025
@param cPixQrCode, Character, Recebe o valor do pix QrCode
@param aRetQrCode, Array, Retorno da Query
@return lRet, Logical, Define se o índice indicado é válido como QrCode
*/
Static Function F240QrCode(cIDDOCFK7 as Character) as Logical
	Local cQuery as character
	Local cPixQrCode as character
	Local aRetQrCode as Array
	Local lRet as logical
	Local cSGBD as character 


	DEFAULT cIDDOCFK7 := ''

	//Inicia variável
	cPixQrCode := ''
	cQuery     := ''
	aRetQrCode := {}
	lRet 	   := .F.
	cSGBD      := Upper(TcGetDb())


	If __oQueryFKF == NIL
		//Query que faz a busca do ID do QRCode na FKF
		cQuery := " SELECT "
		If cSGBD $ "POSTGRES"
			cQuery += " ENCODE(FKF_PAGPIX,'escape') AS QRCODE "
		Else
			cQuery += " CAST(FKF_PAGPIX AS VARCHAR(500)) QRCODE   "
		EndIf
		
		cQuery += " FROM " + RetSqlName("FKF") + " FKF "
		cQuery += " WHERE FKF_IDDOC = ? "
		cQuery += " AND D_E_L_E_T_ = ? "

		cQuery := ChangeQuery(cQuery)
		//Verifica de acordo com a lib qual será o tratamento
		__oQueryFKF := IIF(__lExecSt, FwExecStatement():New(cQuery), FWPreparedStatement():New(cQuery))
	EndIf

	//Valores dos binds da query
	__oQueryFKF:SetString(1,cIDDOCFK7)
	__oQueryFKF:SetString(2,' ')

	//Verifica de acordo com a lib qual será o tratamento
	cPixQrCode := IIf(__lExecSt, (__oQueryFKF:ExecScalar("QRCODE") ), (MpSysExecScalar(__oQueryFKF:GetFixQuery(), "QRCODE") ))

	//Faz a verificação dos títulos que estão no range da data e guarda os que possuem chave QrCode
	aRetQrCode := FinQRCode(cPixQrCode,.F.,.T.)
	If Len(aRetQrCode) > 0
		If Empty(aRetQrCode[2]) .AND. Empty(aRetQrCode[3])
			lRet := .T.
		EndIf
	EndIf


Return lRet

/*/{Protheus.doc} f240VrfChP
	Verifica se existem titulos vinculados a fornecedores sem chave Pix ativas
	@author Luiz C Walker
	@since 20/10/2025
	@version P12
	@return lRet, Logical, Define se existem registros
	/*/
Function f240VrfChP() as logical

	Local cArea		 as character
	Local cAliasTMP	 as character
	Local cBranch 	 as character
	Local cQuery 	 as character
	Local cTmpSE2Fil as character
	Local cFilFwSE2  as character
	Local cListaForn as character
	Local cTemp		 as character
	Local cTargetDir as character

	Local lRet 		 as logical
	Local lTemF72	 as logical
	Local lBranch 	 as logical
	Local lGrvArq	 as logical

	Local nOrder 	 as numeric
	Local nRegs 	 as numeric

	Local of240qryB as Object

	cArea 		:= GetArea()
	cBranch 	:= ""
	cQuery 		:= " "
	cTmpSE2Fil	:= ""
	cFilFwSE2 	:= xFilial("SE2")
	cListaForn  := STR0163 //"Fornecedores sem PIX ativo:"
	cTemp		:= GetTempPath(.F., .F.)

	lRet 		:= .F.
	lTemF72		:= AliasIndic("F72")
	lBranch 	:= FindFunction("totvs.protheus.backoffice.ngf.util.BranchRelation")
	lGrvArq		:= .F.

	nOrder  	:= 1
	nRegs 		:= 0

	If lTemF72

		cBranch := "SE2.E2_FILIAL = SA2.A2_FILIAL "
		If lBranch
			cBranch  := totvs.protheus.backoffice.ngf.util.BranchRelation( {'SE2','E2_FILIAL','SE2'}, {'SA2','A2_FILIAL','SA2'}  )
		EndIf

		cFiltro := FA240Chec2()
		cQuery := "SELECT DISTINCT "
		cQuery += "SE2.E2_FILIAL, "
		cQuery += "SE2.E2_FORNECE, "
		cQuery += "SE2.E2_LOJA, "
		cQuery += "SE2.E2_NOMFOR, "
		cQuery += "F72.F72_CHVPIX, "
		cQuery += "F72.F72_ACTIVE "
		cQuery += "FROM " + RetSqlName("SE2") + " SE2 "
		cQuery += "LEFT JOIN "+ RetSqlName("SA2")+" SA2 ON "
		cQuery += " ? AND "
		cQuery += "SA2.A2_COD = SE2.E2_FORNECE AND "
		cQuery += "SA2.A2_LOJA = SE2.E2_LOJA AND "
		cQuery += "SA2.D_E_L_E_T_ = ? "
		cQuery += "LEFT JOIN "+ RetSqlName("F72")+" F72 ON "
		cQuery += "F72.F72_FILIAL = SA2.A2_FILIAL AND "
		cQuery += "F72.F72_COD = SA2.A2_COD AND "
		cQuery += "F72.F72_LOJA = SA2.A2_LOJA AND "
		cQuery += "F72.F72_ACTIVE = ? AND "
		cQuery += "F72.D_E_L_E_T_ = ? "
		cQuery += "WHERE "
		if mv_par08 == 1
			cQuery += "SE2.E2_FILIAL ? AND "
		else
			cQuery += "SE2.E2_FILIAL = ? AND "
		endIf
		cQuery += "SE2.E2_VENCREA BETWEEN ? AND "
		cQuery += "? AND "
		cQuery += "SE2.D_E_L_E_T_ = ? AND "
		cQuery += " ? "
		cQuery += "ORDER BY "
		cQuery += "SE2.E2_FILIAL, SE2.E2_FORNECE, SE2.E2_LOJA "

		cQuery := ChangeQuery(cQuery)
		of240qryB := FwExecStatement():New(cQuery)

		of240qryB:SetUnsafe(nOrder++, cBranch)
		of240qryB:SetString(nOrder++,' ')
		of240qryB:SetString(nOrder++,'1')
		of240qryB:SetString(nOrder++,' ')

		If mv_par08 == 1
			If Empty( cFilFwSE2 )
				of240qryB:SetUnsafe(nOrder++, GetRngFil( aSelFil, "SE2", .T., @cTmpSE2Fil, , .T. ))
			Else
				of240qryB:SetUnsafe(nOrder++, GetRngFil( aSelFil, "SE2", .T., @cTmpSE2Fil ))
			EndIf
		Else
			of240qryB:SetString(nOrder++, xFilial("SE2"))
		EndIf

		of240qryB:SetDate(nOrder++, dVenIni240)
		of240qryB:SetDate(nOrder++, dVenFim240)
		of240qryB:SetString(nOrder++, ' ')
		of240qryB:SetUnsafe(nOrder++, cFiltro)

		cQuery	:= of240qryB:getFixQuery()
		cAliasTMP := of240qryB:OpenAlias()

		(cAliasTMP)->(DbGoTop())
		While (cAliasTMP)->(!Eof())
			if Empty((cAliasTMP)->F72_CHVPIX) .Or. (cAliasTMP)->F72_ACTIVE == '2'
				nRegs++
				if mv_par08 == 1
					cListaForn += CRLF + STR0164 + AllTrim((cAliasTMP)->E2_FILIAL) + STR0166 + STR0165 + AllTrim((cAliasTMP)->E2_FORNECE) + Space(1) + AllTrim((cAliasTMP)->E2_LOJA) + STR0166 + AllTrim((cAliasTMP)->E2_NOMFOR)
				else
					cListaForn += CRLF + STR0165 + AllTrim((cAliasTMP)->E2_FORNECE) + Space(1) + AllTrim((cAliasTMP)->E2_LOJA) + STR0166 + AllTrim((cAliasTMP)->E2_NOMFOR)
				endIf
			endIf
			(cAliasTMP)->(DbSkip())
		EndDo

		if nRegs > 0
			lRet := .T.
			if FWAlertYesNo(STR0158 +CRLF+ STR0159) //"Existem títulos para fornecedores sem chave pix ou sem chave principal ativa, estes titulos não serão apresentados para seleção. "+ CRLF + "Deseja gerar um arquivo com a relação destes fornecedores?"

				if ShowLog(cListaForn) //Se clicou em 'Salvar' irá abrir a Dialog para salvar o arquivo
					cTargetDir := tFileDialog( "*.txt",STR0160, , cTemp, .T., ) //"Seleção de diretório"
					if !Empty( cTargetDir )
						f240ArqFor(cAliasTMP, cTargetDir) //Gera o arquivo com a lista de fornecedores
					endIf
				endIf
			endIf
		endIf

		(cAliasTMP)->(DbCloseArea())
	EndIf

	RestArea(cArea)

Return lRet

/*/{Protheus.doc} f240ArqFor
	Gera um arquivo txt com a lista de fornecedores sem chave Pix ativa
	@type  Function
	@author Luiz C Walker
	@since 29/10/2025
	@param cAliasTMP, Character, Nome do Alias temporário com os fornecedores
	@param cTargetDir, Character, Caminho onde o arquivo será salvo
	@return lRet, logical, Define se o arquivo foi gerado com sucesso
	/*/
Function f240ArqFor(cAliasTMP As Character, cTargetDir As Character) As logical

	Local lRet As Logical

	Local aArea As Array

	Local cNmArquivo As Character
	Local cListaForn As Character
	Local cExtensao  As Character

	Local oFile As Object

	Default cAliasTMP := ""
	Default cTargetDir := ""

	lRet		:= .F.
	aArea 		:= GetArea()
	cExtensao	:= ".txt"
	cNmArquivo 	:= ProcName()+cExtensao //Nome do arquivo
	cListaForn  := STR0163 //"Fornecedores sem PIX ativo:"
	oFile 		:= FWFileWriter():New(cTargetDir+cNmArquivo, .T.)

	if !(Empty(cAliasTMP) .Or. Empty(cTargetDir))
		lRet := .T.
	EndIf

	if lRet
		If oFile:Exists()
			lRet := oFile:Erase() //Verifica se o arquivo já existe, se sim o apaga
		endIf

		oFile:Create()

		if lRet .And. oFile:Exists()
			(cAliasTMP)->(DbGoTop())
			While (cAliasTMP)->(!Eof())
				if Empty((cAliasTMP)->F72_CHVPIX) .Or. (cAliasTMP)->F72_ACTIVE == '2'
					if mv_par08 == 1
						cListaForn += CRLF + STR0164 + AllTrim((cAliasTMP)->E2_FILIAL) + STR0166 + STR0165 + AllTrim((cAliasTMP)->E2_FORNECE) + Space(1) + AllTrim((cAliasTMP)->E2_LOJA) + STR0166 + AllTrim((cAliasTMP)->E2_NOMFOR)
					else
						cListaForn += CRLF + STR0165 + AllTrim((cAliasTMP)->E2_FORNECE) + Space(1) + AllTrim((cAliasTMP)->E2_LOJA) + STR0166 + AllTrim((cAliasTMP)->E2_NOMFOR)
					endIf

					oFile:Write(cListaForn)
					oFile:SetCaseSensitive(.T.)

					cListaForn := ""
				Endif
				(cAliasTMP)->(DbSkip())
			EndDo

			//Encerra o arquivo
			oFile:Close()
			FWAlertSuccess(STR0161 + CRLF + cTargetDir) //"Arquivo salvo com sucesso no caminho: "
		else
			FWAlertError( STR0162 ) //"Não foi possível criar o arquivo."
		endIf
	endIf

	RestArea(aArea)

Return lRet
