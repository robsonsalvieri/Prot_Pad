#include 'protheus.ch'

#include 'tlpp-core.th'
#include 'tlpp-rest.th'

namespace totvs.protheus.backoffice.fin.taf.integration

//-------------------------------------------------------------------
/*/{Protheus.doc} TafIntegration
    @description Classe responsável por retornar os dados das baixas a pagar
    para a integração com o TAF. Extende PayableBillsData porque a PayableBillsData
    centraliza os principais métodos para adequar os dados à forma como o TAF espera
    receber.
	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type class
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
class PayableWriteOffData from totvs.protheus.backoffice.fin.taf.integration.PayableBillsData
    public method new() as object

    //override methods ==============================
    protected method loadMapFields()
    protected method getQuery() as character
    protected method getOrder() as character
    protected method setCalcData()
    protected method getCalcNatureOfIncome() as array
    protected method getFilterFKW() as character
    protected method isValidNatureOfIncomeFKY() as logical
    //===============================================

    protected method getPaymentSequence() as character
    protected method shoudGetFKW() as logical
    protected method getNatureOfIncomeFromFKY() as array
    protected method joinNatureOfIncomeLists() as array
    protected method getFK2FromBorderaux() as array
    protected method getExecNatureOfIncomeFromFKY() as object

    protected method getMainQuery() as character
    protected method getQueryAdvancePaymentDefault() as character
    protected method getQueryAdvancePaymentWithCheck() as character
    protected method getQueryAdvancePayment() as character
    protected method setParametersMainQuery()
    protected method setParametersAdvancePaymentDefault()
    protected method setParametersAdvancePaymentWithCheck()
    protected method getAdvancePaymentWithCheckCommonTable() as character
    protected method getRatioForPccInWriteoff() as numeric 
    protected method getWriteoffsSummary(cIdDoc as character) as json
    protected method getGrossValuesToPccRatio(nSE2Recno as numeric) as json

    protected data oExecNatureOfIncomeFromFKY as object
    protected data oExecNatureOfIncomeFromFKYWithTaxAlocation as object
    protected data oExecWriteoffsSummary as object
    protected data oExecGrossValues as object
    protected data nParamOrder as numeric
endClass

//-------------------------------------------------------------------
/*/{Protheus.doc} new
	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method new() as object class PayableWriteOffData
    _Super:new()
    self:clear()
    self:nParamOrder := 1
return self

//-------------------------------------------------------------------
/*/{Protheus.doc} getOrder
	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getOrder() class PayableWriteOffData
return SqlOrder(SE2->(IndexKey( 1 )))

//-------------------------------------------------------------------
/*/{Protheus.doc} setCalcData
    Método herdado da classe totvs.protheus.backoffice.fin.abstract.DefaultGetModel
    Define o conteúdo dos campos calculados para cada registro retornado na query principal do
    FwAdapterBaseV2.
	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method setCalcData() class PayableWriteOffData

    self:lIrAtWriteOff := (self:cAlias)->A2_CALCIRF == "2"
    
    self:jCalcData['participatingCode'] := self:getCalcParticipatingCode()
    self:jCalcData['operationType'] := '0' //Carteira: 0=A Pagar; 1=A Receber //Pareado com a NF
    self:jCalcData['natureOfIncome'] := self:getCalcNatureOfIncome()
    self:jCalcData['billDate'] := dToC(self:getCalcBillDate())
    self:jCalcData['paymentDate'] := dToC((self:cAlias)->DTPAY)
    self:jCalcData['paymentSequence'] := self:getPaymentSequence()
return

//-------------------------------------------------------------------
/*/{Protheus.doc} loadMapFields
	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method loadMapFields() class PayableWriteOffData
    self:addMapFields('E2_FILIAL', "E2_FILIAL", .F.)
    self:addMapFields('branch', 'E2_FILORIG', .T.)
    self:addMapFields('billNumber', 'E2_NUM', .T.)
    self:addMapFields('billPrefix', 'E2_PREFIXO', .T.)
    self:addMapFields('billInstallment', 'E2_PARCELA', .T.)
    self:addMapFields('E2_TIPO', "E2_TIPO", .F.)
    self:addMapFields('E2_EMIS1', "E2_EMIS1", .F.)
    self:addMapFields('E2_EMISSAO', "E2_EMISSAO", .F.)
    self:addMapFields('E2_FORNECE', 'E2_FORNECE', .F.)
    self:addMapFields('E2_LOJA', 'E2_LOJA', .F.)
    self:addMapFields('E2_NUMBOR', 'E2_NUMBOR', .F.)
    self:addMapFields('E2_SALDO', 'E2_SALDO', .F.)

    self:addMapFields('FK2_IDFK2', 'FK2_IDFK2', .F.)
    self:addMapFields('FK2_VALOR', 'FK2_VALOR', .F.)
    self:addMapFields('DTPAY', 'DTPAY', .F., .F., { 'DTPAY', 'D', TamSX3('FK2_DATA')[1], 0 })
    self:addMapFields('paymentSequence', 'SEQ', .F., .F., { 'SEQ', 'C', TamSX3('FK2_SEQ')[1], 0 })
    self:addMapFields('finSentTaf', 'REINF', .T., .F., { 'REINF', 'C', TamSX3('FK2_REINF')[1], 0 })

    self:addMapFields('A2_CALCIRF', 'A2_CALCIRF', .F.)
    self:addMapFields('SE2RECNO', 'SE2RECNO', .F., .F., { 'SE2RECNO', 'N', 14, 0 })
    self:addMapFields('CPF', 'CPF', .F., .F., { 'CPF', 'C', TamSX3('FKJ_CPF')[1], 0 })

    self:addMapFields('FK7_IDDOC', 'FK7_IDDOC', .F.)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
    @description Consulta todas as movimentações bancárias que poderão
    ou não compor o T158.
    Isso envolve baixas geradas na FK2 ou emissão de PA (que não gera 
    FK2. Quando possui movimentação bancária, gera FK5). Para não perder
    performance com LEFT JOIN condicionado, consultamos separadamente os casos abaixo
    e unimos os resultados.
    1) baixas (relacionadas à FK2) 
    2) PAs com baixa via dinheiro ou CNAB (o relacionamento entre FK5 e FK7 é direto, 1:1)
    3) PAs com cheque (o relacionamento entre FK5 e FK7 é indireto, 1:n, passando pela FKA e SEF - veja o método getAdvancePaymentWithCheckCommonTable())
    
    Importante: Em algumas situações, a movimentação bancária do PA gera FK5 com sequência de baixa em branco.
    Foi combinado com o TAF que todos os PAs, sempre deverão retornar 0 na sequência de baixa.

	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getQuery() as character class PayableWriteOffData
    local cQuery := "" as character

    self:nParamOrder := 1

    if self:oMainExec == NIL
             
        cQuery := " SELECT ? FROM ( "

        cQuery += self:getMainQuery()

        cQuery += " UNION "

        cQuery += self:getQueryAdvancePaymentDefault()

        cQuery += " UNION "

        cQuery += self:getQueryAdvancePaymentWithCheck()

        cQuery += ") TEMPTABLE "

        cQuery := changeQuery(cQuery)

        self:oMainExec := FWExecStatement():new(cQuery)
        
        self:oMainExec:setUnsafe(self:nParamOrder++, "#QueryFields#")

        self:setParametersMainQuery()
        self:setParametersAdvancePaymentDefault()
        self:setParametersAdvancePaymentWithCheck()
    endIf

    cQuery := self:oMainExec:getFixQuery()
return cQuery



//-------------------------------------------------------------------
/*/{Protheus.doc} getMainQuery
    @description Retorna a consulta principal das baixas, baseada na FK2.
	@author guilherme.sordi@totvs.com.br
	@since 17/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getMainQuery() as character class PayableWriteOffData
    local cQuery := "" as character

    cQuery += " SELECT ? "
    cQuery += " , FK7.FK7_IDDOC "
    cQuery += " , COALESCE(FKJ_CPF, '') CPF, FK2_DATA DTPAY, FK2_IDFK2, FK2_VALOR, FK2_SEQ SEQ, FK2_REINF REINF "
    cQuery += " , SE2.R_E_C_N_O_ SE2RECNO "
    cQuery += " FROM ? FK2 "

    cQuery += " JOIN ? FK7 ON  "
    cQuery += " FK2.FK2_IDDOC = FK7.FK7_IDDOC "
    cQuery += " AND FK7.D_E_L_E_T_ = ' ' "

    cQuery += " JOIN ? SE2 ON "
    cQuery += " FK7.FK7_FILTIT = SE2.E2_FILIAL "
    cQuery += " AND FK7.FK7_PREFIX = SE2.E2_PREFIXO "
    cQuery += " AND FK7.FK7_NUM = SE2.E2_NUM "
    cQuery += " AND FK7.FK7_PARCEL = SE2.E2_PARCELA "
    cQuery += " AND FK7.FK7_TIPO = SE2.E2_TIPO "
    cQuery += " AND FK7.FK7_CLIFOR = SE2.E2_FORNECE "
    cQuery += " AND FK7.FK7_LOJA = SE2.E2_LOJA "
    cQuery += " AND FK7.FK7_ALIAS = 'SE2' "
    cQuery += " AND SE2.D_E_L_E_T_ = ' ' "
    
    cQuery += " JOIN ? SA2 "
    cQuery += " ON ? "
    cQuery += " AND SE2.E2_FORNECE = SA2.A2_COD "
    cQuery += " AND SE2.E2_LOJA = SA2.A2_LOJA "
    cQuery += " AND SA2.D_E_L_E_T_ = ' ' "

    cQuery += " LEFT JOIN ? FKJ "
    cQuery += " ON SA2.A2_COD = FKJ_COD "
    cQuery += " AND SA2.A2_LOJA = FKJ.FKJ_LOJA "
    cQuery += " AND ? "
    cQuery += " AND SE2.E2_CODRET IN ( ? ) "
    cQuery += " AND FKJ.D_E_L_E_T_ = ' ' "
    
    cQuery += " WHERE FK2.D_E_L_E_T_ = ' ' "
    cQuery += " AND FK2_FILORI = ? "
    cQuery += " AND FK2_DATA BETWEEN ? AND ? "
    cQuery += " AND FK2.FK2_RECPAG = 'P' "
    cQuery += " AND FK2.FK2_TPDOC NOT IN ('DC','D2','JR','J2','TL','MT','M2','CM','C2','TR','TE','E2','CH','ES') "
    cQuery += " AND NOT EXISTS ( "
    cQuery += "     SELECT FK2EST.FK2_IDDOC  "
    cQuery += "     FROM  ? FK2EST  "
    cQuery += "     WHERE FK2EST.FK2_FILIAL = FK2.FK2_FILIAL"
    cQuery += "     AND FK2EST.FK2_IDDOC = FK2.FK2_IDDOC  "
    cQuery += "     AND FK2EST.FK2_SEQ = FK2.FK2_SEQ  "
    cQuery += "     AND FK2EST.FK2_TPDOC = 'ES'  "
    cQuery += "     AND FK2EST.D_E_L_E_T_ = ' ' "
    cQuery += " ) "
    cQuery += " AND FK2.FK2_MOTBX NOT IN ( ? ) "
    cQuery += " ? "
return cQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} setParametersMainQuery
    @description Preenche os parâmetros na ordem em que aparecem na query
    gerada pelo método getMainQuery().
	@author guilherme.sordi@totvs.com.br
	@since 17/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method setParametersMainQuery() class PayableWriteOffData
    local aMotBxNotConsider := {} as array

    If self:lPCCAtWriteOff 
		aMotBxNotConsider := {'FAT','LIQ','DEV','PCC','IRF','ISS','IMR'}
	Else
		aMotBxNotConsider := {'PCC','IRF','ISS','IMR'}
	Endif

    self:oMainExec:setUnsafe(self:nParamOrder++, self:getMapFieldsToString({"CPF", "FK2_IDFK2", "FK2_VALOR", "DTPAY", "SEQ", "REINF", "FK7_IDDOC", "SE2RECNO"}))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FK2"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FK7"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("SE2"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("SA2"))
    self:oMainExec:setUnsafe(self:nParamOrder++, FWJoinFilial("SE2", "SA2"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FKJ"))
    self:oMainExec:setUnsafe(self:nParamOrder++, FWJoinFilial("SA2", "FKJ"))
    self:oMainExec:setIn(self:nParamOrder++, self:aCodeRentOrRoyalties)
    self:oMainExec:setString(self:nParamOrder++, self:jParameters['branch'])
    self:oMainExec:setDate(self:nParamOrder++, self:jParameters['initialDate'])
    self:oMainExec:setDate(self:nParamOrder++, self:jParameters['finalDate'])
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FK2"))
    self:oMainExec:setIn(self:nParamOrder++, aMotBxNotConsider)
    self:oMainExec:setUnsafe(self:nParamOrder++, "#QueryWhere#") 
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setParametersMainQuery
    @description Retorna a query padrão de PAs, que possuem movimento bancário
    via espécio ou CNAB. Cenário em que o relacionamento entre FK5 e FK7 é 1:1.
	@author guilherme.sordi@totvs.com.br
	@since 17/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getQueryAdvancePaymentDefault() as character class PayableWriteOffData
    local cQuery := "" as character    
    local cFK5Relation := "" as character    
    
    cFK5Relation += " JOIN ? FK5 "
    cFK5Relation += " ON FK7_IDDOC = FK5_IDDOC "
    cFK5Relation += " AND FK5.D_E_L_E_T_ = ' ' "
    cFK5Relation += " AND FK5.FK5_TPDOC = 'PA' "
    cFK5Relation += " AND FK5.FK5_RECPAG = 'P' "
    cFK5Relation += " AND NOT EXISTS ( "
    cFK5Relation += "     SELECT FK5EST.FK5_IDDOC "
    cFK5Relation += "     FROM ? FK5EST "
    cFK5Relation += "     WHERE FK5EST.FK5_FILIAL = FK5.FK5_FILIAL "
    cFK5Relation += "     AND FK5EST.FK5_IDDOC = FK5.FK5_IDDOC "
    cFK5Relation += "     AND FK5EST.FK5_SEQ = FK5.FK5_SEQ "
    cFK5Relation += "     AND FK5EST.FK5_TPDOC = 'ES' "
    cFK5Relation += "     AND FK5.FK5_RECPAG = 'R' "
    cFK5Relation += "     AND FK5EST.D_E_L_E_T_ = ' ' "
    cFK5Relation += " ) "

    cQuery := self:getQueryAdvancePayment(cFK5Relation)
return cQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} setParametersMainQuery
    @description Preenche os parâmetros na ordem em que aparecem na query
    gerada pelo método getQueryAdvancePaymentDefault().
	@author guilherme.sordi@totvs.com.br
	@since 17/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method setParametersAdvancePaymentDefault() class PayableWriteOffData
    self:oMainExec:setUnsafe(self:nParamOrder++, self:getMapFieldsToString({"CPF", "FK2_IDFK2", "FK2_VALOR", "DTPAY", "SEQ", "REINF", "FK7_IDDOC", "SE2RECNO"}))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("SE2"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FK7"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("SA2"))
    self:oMainExec:setUnsafe(self:nParamOrder++, FWJoinFilial("SE2", "SA2"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FKJ"))
    self:oMainExec:setUnsafe(self:nParamOrder++, FWJoinFilial("SA2", "FKJ"))
    self:oMainExec:setIn(self:nParamOrder++, self:aCodeRentOrRoyalties)
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FKF"))

    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FK5"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FK5"))

    self:oMainExec:setString(self:nParamOrder++, self:jParameters['branch'])
    self:oMainExec:setString(self:nParamOrder++, MVPAGANT)
    self:oMainExec:setDate(self:nParamOrder++, self:jParameters['initialDate'])
    self:oMainExec:setDate(self:nParamOrder++, self:jParameters['finalDate'])
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setParametersMainQuery
    @description Retorna a query de PAs que possuem movimento bancário
    via cheque. Cenário em que o relacionamento entre FK5 e FK7 é 1:n,
    e o relacionamento passa pelas tabelas FKA e SEF.
    O relacionamento entre FK5 e FK7, nesse caso, foi escrito para ser utilizado como
    uma expressão de tabela comum, mas a super classe FWAdapterBaseV2 não permite o uso 
    de expressão de tabela comum. Portanto, o relacionamento está sendo feito em uma
    subquery criada no método getAdvancePaymentWithCheckCommonTable() e nomeada como
    "PACOMCHEQUE".
	@author guilherme.sordi@totvs.com.br
	@since 17/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getQueryAdvancePaymentWithCheck() as character class PayableWriteOffData
    local cQuery := "" as character    
    local cFK5Relation := "" as character    
    
    cFK5Relation += " JOIN ( ? ) PACOMCHEQUE "
    cFK5Relation += " ON FK7.FK7_IDDOC = PACOMCHEQUE.FK7_IDDOC "
    cFK5Relation += " JOIN ? FK5 "
    cFK5Relation += " ON PACOMCHEQUE.FK5_IDMOV = FK5.FK5_IDMOV "

    cQuery := self:getQueryAdvancePayment(cFK5Relation)
return cQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} setParametersMainQuery
    @description Preenche os parâmetros na ordem em que aparecem na query
    gerada pelo método getQueryAdvancePaymentWithCheck().
	@author guilherme.sordi@totvs.com.br
	@since 17/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method setParametersAdvancePaymentWithCheck() class PayableWriteOffData
    self:oMainExec:setUnsafe(self:nParamOrder++, self:getMapFieldsToString({"CPF", "FK2_IDFK2", "FK2_VALOR", "DTPAY", "SEQ", "REINF", "FK7_IDDOC", "SE2RECNO"}))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("SE2"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FK7"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("SA2"))
    self:oMainExec:setUnsafe(self:nParamOrder++, FWJoinFilial("SE2", "SA2"))
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FKJ"))
    self:oMainExec:setUnsafe(self:nParamOrder++, FWJoinFilial("SA2", "FKJ"))
    self:oMainExec:setIn(self:nParamOrder++, self:aCodeRentOrRoyalties)
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FKF"))

    self:oMainExec:setUnsafe(self:nParamOrder++, self:getAdvancePaymentWithCheckCommonTable())
    self:oMainExec:setUnsafe(self:nParamOrder++, retSqlName("FK5"))
    
    self:oMainExec:setString(self:nParamOrder++, self:jParameters['branch'])
    self:oMainExec:setString(self:nParamOrder++, MVPAGANT)
    self:oMainExec:setDate(self:nParamOrder++, self:jParameters['initialDate'])
    self:oMainExec:setDate(self:nParamOrder++, self:jParameters['finalDate'])
return

//-------------------------------------------------------------------
/*/{Protheus.doc} setParametersMainQuery
    @description Retorna a query de PA com movimento bancário, pemitindo 
    que o relacionamento entre as tabelas FK5 e FK7 seja passado por parâmetro,
    removendo possível duplicidade de código ao consultar PAs com movimento bancário
    via espécie ou CNAB (relacionamento 1:1) e via cheque (relacionamento 1:n).
    A mesma consulta poderia ser feita com LEFT JOIN, mas deu-se preferência a 
    duas consultas com UNION por questões de performance.
	@author guilherme.sordi@totvs.com.br
	@since 17/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getQueryAdvancePayment(cFK5Relation as character) as character class PayableWriteOffData
    local cQuery := "" as character

    cQuery := " SELECT ? "
    cQuery += " , FK7.FK7_IDDOC "
    cQuery += " , COALESCE(FKJ_CPF, '') CPF, FK5_DATA DTPAY, '' FK2_IDFK2, 0 FK2_VALOR, '0' SEQ, FKF_REINF REINF "
    cQuery += " , SE2.R_E_C_N_O_ SE2RECNO "
    cQuery += " FROM ? SE2 "

    cQuery += " JOIN ? FK7 "
    cQuery += " ON FK7.FK7_FILTIT = SE2.E2_FILIAL "
    cQuery += " AND FK7.FK7_PREFIX = SE2.E2_PREFIXO "
    cQuery += " AND FK7.FK7_NUM = SE2.E2_NUM "
    cQuery += " AND FK7.FK7_PARCEL = SE2.E2_PARCELA "
    cQuery += " AND FK7.FK7_TIPO = SE2.E2_TIPO "
    cQuery += " AND FK7.FK7_CLIFOR = SE2.E2_FORNECE "
    cQuery += " AND FK7.FK7_LOJA = SE2.E2_LOJA "
    cQuery += " AND FK7.FK7_ALIAS = 'SE2' "
    cQuery += " AND SE2.D_E_L_E_T_ = ' ' "
    
    cQuery += " JOIN ? SA2 "
    cQuery += " ON ? "
    cQuery += " AND SE2.E2_FORNECE = SA2.A2_COD "
    cQuery += " AND SE2.E2_LOJA = SA2.A2_LOJA "
    cQuery += " AND SA2.D_E_L_E_T_ = ' ' "

    cQuery += " LEFT JOIN ? FKJ "
    cQuery += " ON SA2.A2_COD = FKJ_COD "
    cQuery += " AND SA2.A2_LOJA = FKJ.FKJ_LOJA "
    cQuery += " AND ? "
    cQuery += " AND SE2.E2_CODRET IN ( ? ) "
    cQuery += " AND FKJ.D_E_L_E_T_ = ' ' "
    
    cQuery += " JOIN ? FKF "
    cQuery += " ON FK7.FK7_IDDOC = FKF.FKF_IDDOC "
    cQuery += " AND FKF.D_E_L_E_T_ = ' ' "

    cQuery += cFK5Relation

    cQuery += " WHERE SE2.D_E_L_E_T_ = ' ' "
    cQuery += " AND SE2.E2_FILORIG = ? "
    cQuery += " AND SE2.E2_TIPO = ? "
    cQuery += " AND FK5_DATA BETWEEN ? AND ? "
return cQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} getAdvancePaymentWithCheckCommonTable
    @description Retorna consulta que relaciona movimento bancário de cheque
    com o registro do pagamento antecipado para ser usado como Commom Table Expression.
	@author guilherme.sordi@totvs.com.br
	@since 13/05/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getAdvancePaymentWithCheckCommonTable() as character class PayableWriteOffData
    local cQuery := "" as character
    local oExec as object
    local nParamOrder := 1 as numeric

    cQuery := " SELECT FK7.FK7_IDDOC, FK5.FK5_IDMOV
    cQuery += " FROM ? FK7
    cQuery += " JOIN ? PA "
    cQuery += "     ON FK7_IDDOC = PA.FKA_IDORIG "
    cQuery += "     AND PA.FKA_TABORI = 'SE2' "
    cQuery += "     AND PA.D_E_L_E_T_ = ' ' "
    cQuery += " JOIN ? CHEQUES "
    cQuery += "     ON PA.FKA_FILIAL = CHEQUES.FKA_FILIAL "
    cQuery += "     AND PA.FKA_IDPROC = CHEQUES.FKA_IDPROC "
    cQuery += "     AND CHEQUES.D_E_L_E_T_ = ' ' "
    cQuery += " JOIN ? SEF "
    cQuery += "     ON SEF.EF_IDSEF = CHEQUES.FKA_IDORIG "
    cQuery += "     AND CHEQUES.FKA_TABORI = 'SEF' "
    cQuery += "     AND SEF.D_E_L_E_T_ = ' ' "
    cQuery += " JOIN ? AGLUTINADOR "
    cQuery += "     ON SEF.EF_FILIAL = AGLUTINADOR.EF_FILIAL "
    cQuery += "     AND SEF.EF_BANCO = AGLUTINADOR.EF_BANCO "
    cQuery += "     AND SEF.EF_AGENCIA = AGLUTINADOR.EF_AGENCIA "
    cQuery += "     AND SEF.EF_CONTA = AGLUTINADOR.EF_CONTA "
    cQuery += "     AND AGLUTINADOR.D_E_L_E_T_ = ' ' "
    cQuery += " JOIN ? CHEQUESMOV "
    cQuery += "     ON AGLUTINADOR.EF_IDSEF = CHEQUESMOV.FKA_IDORIG "
    cQuery += "     AND CHEQUESMOV.FKA_TABORI = 'SEF' "
    cQuery += "     AND CHEQUESMOV.D_E_L_E_T_ = ' ' "
    cQuery += " JOIN ? MOV "
    cQuery += "     ON CHEQUESMOV.FKA_FILIAL = MOV.FKA_FILIAL "
    cQuery += "     AND CHEQUESMOV.FKA_IDPROC = MOV.FKA_IDPROC "
    cQuery += "     AND MOV.D_E_L_E_T_ = ' ' "
    cQuery += " JOIN ? FK5 "
    cQuery += "     ON MOV.FKA_IDORIG = FK5.FK5_IDMOV "
    cQuery += "     AND MOV.FKA_TABORI = 'FK5' "
    cQuery += "     AND FK5.D_E_L_E_T_ = ' ' "
    cQuery += "     AND NOT EXISTS ( "
    cQuery += "         SELECT FK5_IDMOV "
    cQuery += "         FROM ? ESTORNO "
    cQuery += "         WHERE ESTORNO.FK5_FILIAL = FK5.FK5_FILIAL "
    cQuery += "         AND ESTORNO.FK5_BANCO = FK5.FK5_BANCO "
    cQuery += "         AND ESTORNO.FK5_AGENCI = FK5.FK5_AGENCI "
    cQuery += "         AND ESTORNO.FK5_CONTA = FK5_CONTA "
    cQuery += "         AND ESTORNO.FK5_NUMCH = FK5.FK5_NUMCH "
    cQuery += "         AND ESTORNO.FK5_SEQ = FK5.FK5_SEQ "
    cQuery += "         AND FK5.FK5_TPDOC = 'CH' "
    cQuery += "         AND ESTORNO.FK5_TPDOC = 'ES' "
    cQuery += "         AND FK5.FK5_RECPAG = 'P' "
    cQuery += "         AND ESTORNO.FK5_RECPAG = 'R' "
    cQuery += "     ) "
    cQuery += " WHERE FK7_TIPO = 'PA' "
    cQuery += " AND FK7.D_E_L_E_T_ = ' ' "

    cQuery := changeQuery(cQuery)    

    oExec := FWExecStatement():new(cQuery)

    oExec:setUnsafe(nParamOrder++, retSQLName("FK7"))
    oExec:setUnsafe(nParamOrder++, retSQLName("FKA"))
    oExec:setUnsafe(nParamOrder++, retSQLName("FKA"))
    oExec:setUnsafe(nParamOrder++, retSQLName("SEF"))
    oExec:setUnsafe(nParamOrder++, retSQLName("SEF"))
    oExec:setUnsafe(nParamOrder++, retSQLName("FKA"))
    oExec:setUnsafe(nParamOrder++, retSQLName("FKA"))
    oExec:setUnsafe(nParamOrder++, retSQLName("FK5"))
    oExec:setUnsafe(nParamOrder++, retSQLName("FK5"))

    cQuery := oExec:getFixQuery()

return cQuery


//-------------------------------------------------------------------
/*/{Protheus.doc} getFK2FromBorderaux
    Retorna uma lista de IDFK2 criadas na geração do borderô. Será nos casos em que o 
    imposto configurado na baixa é gerado pela rotina de borderô com impostos em vez
    da efetivação da baixa do título.
	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getFK2FromBorderaux() as array class PayableWriteOffData
    local jBillData := JsonObject():new() as json
    local aFK2List := {} as array

    jBillData['prefix'] := (self:cAlias)->E2_PREFIXO
    jBillData['number'] := (self:cAlias)->E2_NUM
    jBillData['installment'] := (self:cAlias)->E2_PARCELA
    jBillData['type'] := (self:cAlias)->E2_TIPO
    jBillData['supplier'] := (self:cAlias)->E2_FORNECE
    jBillData['unit'] := (self:cAlias)->E2_LOJA

    aFK2List := FTemBorImp(NIL, (self:cAlias)->FK7_IDDOC, jBillData) //FINA989
    default aFK2List := {}
return aFK2List

//-------------------------------------------------------------------
/*/{Protheus.doc} getCalcNatureOfIncome
    Retorna as naturezas de rendimentos que se relacionam com a baixa posicionada
    em self:cAlias.
	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getCalcNatureOfIncome() as array class PayableWriteOffData
    local aNatureOfIncomeFromFKY := {} as array
    local aNatureOfIncomeFromFKW := {} as array
    local aNatureOfIncomeList := {} as array
    local aIdFk2ListFromBorderauxWithTaxes := {} as array
    local lGetDataFromBorderauxFK2 := .F. as logical

    if !Empty((self:cAlias)->E2_NUMBOR)
        aIdFk2ListFromBorderauxWithTaxes := self:getFK2FromBorderaux()
        lGetDataFromBorderauxFK2 := ( len(aIdFk2ListFromBorderauxWithTaxes) > 0 )
    endIf

    if lGetDataFromBorderauxFK2        
        aNatureOfIncomeFromFKY := self:getNatureOfIncomeFromFKY(aIdFk2ListFromBorderauxWithTaxes)
    else
        aNatureOfIncomeFromFKY := self:getNatureOfIncomeFromFKY( { (self:cAlias)->FK2_IDFK2 } )
    endIf

    if self:shoudGetFKW()
        aNatureOfIncomeFromFKW := self:getNatureOfIncomeFromFKW(self:getRatioForPccInWriteoff())
    endIF

    aNatureOfIncomeList := self:joinNatureOfIncomeLists(aNatureOfIncomeFromFKY, aNatureOfIncomeFromFKW)
        
return aNatureOfIncomeList

//-------------------------------------------------------------------
/*/{Protheus.doc} joinNatureOfIncomeLists
    @description Hoje nós não distinguimos o imposto dentro da natureza de rendimento.
    Então podemos ter a mesma natureza de rendimento na FKY e na FKW para impostos diferentes, 
    por exemplo, PCC na emissão e IR na baixa. O IR vamos pegar na FKY, mas o PCC vamos pegar na FKW.
    Nesse caso, esse método ajuda a não duplicar a natureza de rendimento.
    No futuro, quando estivermos dintinguindo os impostos dentro de cada natureza, com seus respectivos
    valores etc., esse método não será mais necessário (pelo menos não a proteção para não duplicar a 
    natureza de rendimentos).
	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method joinNatureOfIncomeLists(aList1 as array, aList2 as array) as array class PayableWriteOffData
    local aNewList := {} as array
    local nX := 1 as numeric
    local lAlreadyExists := .F. as logical

    default aList1 := {}
    default aList2 := {}

    aNewList := aClone(aList1)

    for nX := 1 to len(aList2)
        lAlreadyExists := aScan(aNewList, {|jNatureOfIncome| jNatureOfIncome['code'] == aList2[nX]['code']}) > 0
        if !lAlreadyExists
            aAdd(aNewList, aList2[nX])
        endIf
    next
    
return aNewList

//-------------------------------------------------------------------
/*/{Protheus.doc} getExecNatureOfIncomeFromFKY
    @description Retorna o objeto prepare statement para
    buscar a natureza de rendimento na tabela FKY, tanto com quanto
    sem rateio de IR por CPF.
	@author guilherme.sordi@totvs.com.br
	@since 17/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getExecNatureOfIncomeFromFKY() as object class PayableWriteOffData
    local cQuery := "" as character
    local oExec as object

    if self:oExecNatureOfIncomeFromFKYWithTaxAlocation == NIL
        cQuery := " SELECT ? "
        cQuery += " FROM ? FKY "

        cQuery += " LEFT JOIN ? FK4  "
        cQuery += " ON FKY_IDORIG = FK4_IDFK4 "
        cQuery += " AND FKY_TABORI = 'FK4' "
        cQuery += " AND ? "
        cQuery += " AND FK4.D_E_L_E_T_ = ? "
        
        cQuery += " LEFT JOIN ? FK3  "
        cQuery += " ON FKY_IDORIG = FK3_IDFK3 "
        cQuery += " AND FKY_TABORI = 'FK3' "
        cQuery += " AND ? "
        cQuery += " AND FK3.D_E_L_E_T_ =? "

        cQuery += " WHERE FKY_FILIAL = ? "
        cQuery += " AND FKY_IDFK2 IN ( ? ) "
        cQuery += " AND FKY.D_E_L_E_T_ = ? "

        cQuery += " AND (FK3_CGC = ? OR FK4_CGC = ?) "
        cQuery += " AND (FKY_BASETR <> ? OR FKY_BASENR <> ? ) "

        cQuery := changeQuery(cQuery)
        self:oExecNatureOfIncomeFromFKYWithTaxAlocation := FWExecStatement():new(cQuery)
    endIf  

    if self:oExecNatureOfIncomeFromFKY == NIL
        cQuery := " SELECT ? "
        cQuery += " FROM ? FKY "
        cQuery += " WHERE FKY_FILIAL = ? "
        cQuery += " AND FKY_IDFK2 IN ( ? ) "
        cQuery += " AND FKY.D_E_L_E_T_ = ? "
        cQuery += " AND (FKY_BASETR <> ? OR FKY_BASENR <> ? ) "

        cQuery := changeQuery(cQuery)
        self:oExecNatureOfIncomeFromFKY := FWExecStatement():new(cQuery)
    endIf  

    if self:hasIndividualIncomeTaxAlocation()
        oExec := self:oExecNatureOfIncomeFromFKYWithTaxAlocation
    else
        oExec := self:oExecNatureOfIncomeFromFKY
    endIf    

return oExec

//-------------------------------------------------------------------
/*/{Protheus.doc} getNatureOfIncomeFromFKY
    Retorna as naturezas de rendimento com base em uma lista de idFK2.

    Tributes
    Iniciamos o desenvolvimento do preenchimento o objeto "tributes", que relaciona todos os 
    tributos da FKW e da FKW, mas esbarramos em alguns complicadores e decidimos liberar no futuro.
    Por exemplo, em alguns casos, devemos agrupar determinados tipos de impostos (ver AgregTrib).

    Tributes - taxRate
    Na concepção do projeto foi mapeada uma propriedade chamada taxRate para o objeto tributo.
    A ideia seria preencher com a alíquota do tributo, para alimentar um campo do TAF. Porém, 
    esse campo não é obrigatório no layout do REINF e o extrator atual (FINA989) não envia esse campo.
    Na verdade, sequer existe um campo referente a essa informação na FKW ou na FKW. Por isso, não
    enviamos essa propriedade nesse componente.

    O campo FKY_VLBRUT é recente, então não podemos considerá-lo se não existir ou for igual a zero.
    O registro deve possuir FKY_BASETR ou FKY_BASENR maior que zero. Se ambos estiverem zerados, devemos
    desconsiderar o registro (provavelmente a existência desse registro é consequência de algum erro do passado).

	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getNatureOfIncomeFromFKY(aIdFk2 as array) as array class PayableWriteOffData
    local jNatureOfIncome as json
    local jTribute as json
    local aList := {} as array

    local nParam := 1 as numeric
    local cFields := "" as character
    local cAlias := "" as character
    local cLifeTime := "600" as character
    local cTimeOut := "120" as character
    local oExec as object
    local nNaturePosition := 0 as numeric
    local nGrossValue := 0 as numeric

    if empty(aIdFK2) .or. empty(aIdFk2[1])
        return aList
    endIf

    oExec := self:getExecNatureOfIncomeFromFKY()

    default aIdFk2 := { (self:cAlias)->FK2_IDFK2 }    

    cFields := " FKY_IDFKY, FKY_NATREN, FKY_TPIMP, FKY_BASETR, FKY_BASENR, FKY_VLIMP "
    if self:lHasGrossValueField
        cFields += ", FKY_VLBRUT "
    endIf
    
    if self:hasIndividualIncomeTaxAlocation()
        oExec:setUnsafe(nParam++, cFields)
        oExec:setUnsafe(nParam++, retSqlName("FKY"))
        oExec:setUnsafe(nParam++, retSqlName("FK4"))
        oExec:setUnsafe(nParam++, FWJoinFilial("FKY", "FK4"))
        oExec:setString(nParam++, " ")
        oExec:setUnsafe(nParam++, retSqlName("FK3"))
        oExec:setUnsafe(nParam++, FWJoinFilial("FKY", "FK3"))
        oExec:setString(nParam++, " ")
        oExec:setString(nParam++, xFilial("FKY", self:jParameters['branch']))
        oExec:setIn(nParam++, aIdFk2)   
        oExec:setString(nParam++, " ")     
        oExec:setString(nParam++, (self:cAlias)->CPF)
        oExec:setString(nParam++, (self:cAlias)->CPF)
        oExec:setNumeric(nParam++, 0)
        oExec:setNumeric(nParam++, 0)
    else
        oExec:setUnsafe(nParam++, cFields)
        oExec:setUnsafe(nParam++, retSqlName("FKY"))
        oExec:setString(nParam++, xFilial("FKY", self:jParameters['branch']))
        oExec:setIn(nParam++, aIdFk2)
        oExec:setString(nParam++, " ")
        oExec:setNumeric(nParam++, 0)
        oExec:setNumeric(nParam++, 0)
    endIf

    cAlias := oExec:openAlias(nil, cLifeTime, cTimeOut)

    while !(cAlias)->(eof())
        if self:lHasGrossValueField .and. (cAlias)->FKY_VLBRUT > 0
            nGrossValue := (cAlias)->FKY_VLBRUT
        else
            nGrossValue := (cAlias)->FKY_BASETR + (cAlias)->FKY_BASENR
        endIf

        if self:isValidNatureOfIncomeFKY(cAlias)
            jTribute := JsonObject():new()
            jTribute['id'] := (cAlias)->FKY_IDFKY
            jTribute['taxCode'] := (cAlias)->FKY_TPIMP
            jTribute['baseValue'] := (cAlias)->FKY_BASETR
            jTribute['nonWithheldBaseValue'] := (cAlias)->FKY_BASENR
            jTribute['taxValue'] := (cAlias)->FKY_VLIMP
            
            nNaturePosition := aScan(aList, {|jNatureOfIncome| jNatureOfIncome['code'] == (cAlias)->FKY_NATREN} )
            if nNaturePosition == 0
                jNatureOfIncome := JsonObject():new()
                jNatureOfIncome['code'] := (cAlias)->FKY_NATREN   
                jNatureOfIncome['grossValue'] := nGrossValue 
                // jNatureOfIncome['tributes'] := { jTribute }    
                aAdd(aList, jNatureOfIncome)
            else
                // aAdd(jNatureOfIncome['tributes'], jTribute)
            endIf
        endIf

        (cAlias)->(dbSkip())
    endDo

    (cAlias)->(dbCloseArea())

return aList

//-------------------------------------------------------------------
/*/{Protheus.doc} getFilterFKW
    @description Define um filtro para a consulta na tabela FKW.

    No caso da busca de títulos, não deve trazer PCC, porque para o REINF
    o fato gerador do PCC é sempre a baixa. Note que o método getFilterFKW
    da classe PayableBillsData filtra FKW que não são de PCC.

    No caso da busca de baixas:
    - deve buscar as retenções de PCC na FKW quando o parâmetro MV_BX10925 estiver na emissão
    - deve buscar todas as retenções quando for PA

    Logo, quando não for PA, filtramos só PCC.
    
	@author guilherme.sordi@totvs.com.br
	@since 22/03/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getFilterFKW() as character class PayableWriteOffData
    local cFilterFKW := "" as character

    if !(self:cAlias)->E2_TIPO == MVPAGANT
        cFilterFKW := " AND FKW_TPIMP IN ('PIS', 'COF', 'CSL') "
    endIf
return cFilterFKW

//-------------------------------------------------------------------
/*/{Protheus.doc} getPaymentSequence
	@author guilherme.sordi@totvs.com.br
	@since 18/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method getPaymentSequence() as character class PayableWriteOffData
    local cSequence := allTrim((self:cAlias)->SEQ) as character
    if cSequence == "0"
        cSequence := StrZero(val(cSequence), self:nLenSequence)
    endIf
return cSequence

//-------------------------------------------------------------------
/*/{Protheus.doc} isValidNatureOfIncomeFKY
    @description Quando não tem imposto (TPIMP = 'SEMIMP'), a natureza de rendimento será
    informada apenas no T158, a partir da FKY. 
    Exceções à regra:
    1) Naturezas de rendimento do grupo 20 (ex.: publicidade). Nesse caso,
    ela será informada no T154 ou no T158 dependendo de como estiver a configuração do fornecedor. 
    Quando configurado com IR na emissão, a natureza de rendimento será informada no T154 e quando configurado
    com IR na baixa será informado no T158.
    2) Pagamento antecipado. Nesse caso, o T158 apresentará a natureza de rendimento a partir da FKW
    e não da FKY, porque PA só gera FKW.
	@author guilherme.sordi@totvs.com.br
	@since 18/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method isValidNatureOfIncomeFKY(cAliasNatureOfIncome as character) as logical class PayableWriteOffData
    local lIsValid := .T. as logical
    local cCode := (cAliasNatureOfIncome)->FKY_NATREN 
    local lGroup20 := Substr(cCode,1,2) == "20"

    lIsValid := !lGroup20 .or. self:lIrAtWriteOff
    
return lIsValid

//-------------------------------------------------------------------
/*/{Protheus.doc} shoudGetFKW
    @description Retorna se, para o registro em questão, devemos olhar a natureza
    de rendimentos na tabela FKW.
    Atualmente, os cenários em que devemos olhar FKW são:
    PCC na emissão - Mandamos PCC no T158 porque legalmente o fato gerador de 
    PCC é o pagamento.
    PA - A emissão do título de PA já é um pagamento, então o PA sempre vai no
    T158 mesmo gerando FKW. Observação: Mesmo que não gere FKW na emissão por
    estar configurado para não gerar movimento bancário na emissão, quando
    for gerado o movimento bancário seja por cheque ou por CNAB, o movimento
    bancário vai gerar um registro na FKW.
	@author guilherme.sordi@totvs.com.br
	@since 24/04/2024
	@type method
	@version 12.1.2310
/*/
//-------------------------------------------------------------------
method shoudGetFKW() as logical class PayableWriteOffData
    local lShoud := !self:lPCCAtWriteOff .or. (self:cAlias)->E2_TIPO == MVPAGANT
return lShoud


//-------------------------------------------------------------------
/*/{Protheus.doc} getRatioForPccInWriteoff
    @description Obtém a razão valor da baixa sobre valor do título.
    Essa razão será usada para calcular o valor bruto que deve ser informado para 
    cada baixa. O resultado final será basicamente FKW_VLBRUT * razão.
    
    Essa esse método herda a lógica da função NatPropBX do Extrator (FINA989.prw).
    Portanto, se algo for alterado no extrator, precisa alterar aqui também.

    Na lógica atual, a razão é calculada pela relação entre o valor líquido da baixa e 
    o valor bruto do título. A diferença é compensada no cálculo da última baixa, onde 
    o valor dos impostos é somado ao valor da baixa, e, nesse caso, considera-se o 
    valor da baixa residual + total de impostos do título / valor bruto do título.
    No final das contas os valores vão bater, mas para os casos em que a última baixa
    ainda não ocorreu, o valor calculado da razão e, consequentemente, do valor bruto, é questionável.
    Essa lógica pode mudar nas próximas versões. Mas precisa mudar tanto aqui quanto no legado.
    
    Na grande maioria dos casos, cada título possui uma única baixa. Então só
    vamos calcular o valor bruto do título quando realmente precisarmos.

	@author guilherme.sordi@totvs.com.br
	@since 07/10/2024
	@type method
	@version 12.1.2410
/*/
//-------------------------------------------------------------------
method getRatioForPccInWriteoff() as numeric class PayableWriteOffData
    local nRatio := 1 as numeric
    local jWriteoffSummary := JsonObject():new() as json
    local jGrossValues := JsonObject():new() as json

    if (self:cAlias)->E2_TIPO == MVPAGANT
        nRatio := 1
        return nRatio
    endIf

    if (self:cAlias)->E2_SALDO > 0 
        nRatio := (self:cAlias)->FK2_VALOR / self:getGrossValuesToPccRatio((self:cAlias)->SE2RECNO)['billValue']
    else

        jWriteoffSummary := self:getWriteoffsSummary((self:cAlias)->FK7_IDDOC)        
        if jWriteoffSummary['count'] == 1           
            nRatio := 1
        else

            jGrossValues := self:getGrossValuesToPccRatio((self:cAlias)->SE2RECNO)
            if (self:cAlias)->SEQ == jWriteoffSummary['maxSeq']
                nRatio := ((self:cAlias)->FK2_VALOR + jGrossValues['taxesValue']) / jGrossValues['taxesValue']
            else 
                nRatio := (self:cAlias)->FK2_VALOR / jGrossValues['billValue']
            endIf

        endIf
    endIf
return nRatio

//-------------------------------------------------------------------
/*/{Protheus.doc} getWriteoffsSummary
    @description Retorna um JSON com um resumo das baixas do título, contendo
    as seguintes propriedades:
    count: numeric, Total de baixas que o título já sofreu
    maxSeq: string, Última sequencia de baixa utilizada

	@author guilherme.sordi@totvs.com.br
	@since 07/10/2024
	@type method
	@version 12.1.2410
/*/
//-------------------------------------------------------------------
method getWriteoffsSummary(cIdDoc as character) as json class PayableWriteOffData
    local cQuery := '' as character
    local cAlias := '' as character
    local jSummary := {'count': 0, 'maxSeq': '00'} as json

    if self:oExecWriteoffsSummary == NIL
        cQuery := " SELECT COALESCE(COUNT(*),0) COUNTREC, COALESCE(MAX(FK2_SEQ),'00') MAXSEQ "
        cQuery += " FROM " + RetSqlName("FK2") + " FK2 "
        cQuery += " WHERE FK2_IDDOC = ? " 
        cQuery += " AND NOT EXISTS ( SELECT FK2EST.FK2_IDDOC FROM " + RetSqlName("FK2") + " FK2EST"
        cQuery += " WHERE FK2EST.FK2_FILIAL = FK2.FK2_FILIAL"
        cQuery += " AND FK2EST.FK2_IDDOC = FK2.FK2_IDDOC "
        cQuery += " AND FK2EST.FK2_SEQ = FK2.FK2_SEQ "
        cQuery += " AND FK2EST.FK2_TPDOC = ? "
        cQuery += " AND FK2EST.D_E_L_E_T_ = ? ) " 
        cQuery += " AND FK2.D_E_L_E_T_ = ?

        cQuery := changeQuery(cQuery)

        self:oExecWriteoffsSummary := FWExecStatement():new(cQuery, '120', '300')
    endIf

    self:oExecWriteoffsSummary:setString(1, cIdDoc)
    self:oExecWriteoffsSummary:setString(2, 'ES')
    self:oExecWriteoffsSummary:setString(3, ' ')
    self:oExecWriteoffsSummary:setString(4, ' ')

    cAlias := self:oExecWriteoffsSummary:openAlias()
    
    if !(cAlias)->(eof())
        jSummary['count'] := (cAlias)->COUNTREC
        jSummary['maxSeq'] := (cAlias)->MAXSEQ
    endIf
    (cAlias)->(dbCloseArea())

return jSummary

//-------------------------------------------------------------------
/*/{Protheus.doc} getGrossValuesToPccRatio
    @description Obtem um JSON com as seguintes propriedades:
    billValue: Valor bruto do título
    taxesValue: Valor total dos impostos do título
	@author guilherme.sordi@totvs.com.br
	@since 07/10/2024
	@type method
	@version 12.1.2410
/*/
//-------------------------------------------------------------------
method getGrossValuesToPccRatio(nSE2Recno as numeric) as json class PayableWriteOffData
    local cQuery := "" as character
    local cAlias := "" as character
    local cValueFields := " E2_VRETPIS + E2_VRETCOF + E2_VRETCSL + E2_VRETINS + E2_VALOR " as character
    local cTaxesFields := " E2_VRETPIS + E2_VRETCOF + E2_VRETCSL + E2_VRETINS + E2_VRETIRF + E2_VRETISS " as character
    local jGrossValues := {"billValue": 1, "taxesValue": 1} as json

    default nSE2Recno := (self:cAlias)->SE2RECNO

    If !self:lIssAtWriteOff
		cValueFields += " + E2_VRETISS "
	EndIf

	If !self:lIrAtWriteOff
		cValueFields += " + E2_VRETIRF "
	EndIf

    if self:oExecGrossValues == NIL
        cQuery := " SELECT (?) BILL_VALUE, (?) TAXES_VALUE "
        cQuery += " FROM "+ retSQLName("SE2") +" SE2 "
        cQuery += " WHERE R_E_C_N_O_ = ? "

        cQuery := changeQuery(cQuery)        

        self:oExecGrossValues := FwExecStatement():new(cQuery, "120", "300")
    endIf

    self:oExecGrossValues:setUnsafe(1, cValueFields)
    self:oExecGrossValues:setUnsafe(2, cTaxesFields)
    self:oExecGrossValues:setNumeric(3, nSE2Recno)

    cAlias := self:oExecGrossValues:openAlias()
    
    if !(cAlias)->(eof())
        jGrossValues['billValue'] := (cAlias)->BILL_VALUE
        jGrossValues['taxesValue'] := (cAlias)->TAXES_VALUE
    endIf
    (cAlias)->(dbCloseArea())

return jGrossValues
