#include 'tlpp-core.th'

namespace portal.cliente.util
USING NAMESPACE totvs.protheus.backoffice.ngf.util

Static __oTemporaryTable := NIL As Object
Static __cTableTemporary := "" As Character
Static __aBranches := {} As Array

/*/{Protheus.doc} CreateTemporaryCustomers
	Cria a tabela temporaria dos clientes vinculados ao usuario
	@type  Function
	@author Vitor Duca
	@since 09/06/2022
	@version 1.0
	@param aCustomers, Array, Array de customers que é enviado pelo front
	@return __cTableTemporary, Character, Nome da tabela temporaria
/*/
Function CreateTemporaryCustomers(aCustomers As Array, cTable As Character) As Character
	Local nCountCustomers := 0 As Numeric
	Local aFields := {} As Array
	Local cSetInBranch := "" As Character
	Local nLimit := 15 As Numeric
	Local cQuery := "" As Character
	Local cInsert := "" As Character
	Local cMessageErro := "" As Character
	Local cBDName := ALLTRIM(tcGetdb()) As Character
	Local cTableNameReal := RetSqlName("SA1") As Character
	Local nQtdCustomers := Len(aCustomers) As Numeric
	Local cQueryCustomers := "" As Character

	Aadd(aFields, {"FILIAL", "C", TamSX3("A1_FILIAL")[1],  0})
	Aadd(aFields, {"CLIENTE", "C", TamSX3("A1_COD")[1],  0})
	Aadd(aFields, {"LOJA", "C", TamSX3("A1_LOJA")[1],  0})

	If __oTemporaryTable <> NIL
		cMessageErro := IIf(TcSQLExec("TRUNCATE TABLE " + __cTableTemporary) < 0, TCSQLERROR(), "")
		If !Empty(cMessageErro)
			USEREXCEPTION( cMessageErro )
		Endif
	Endif

	If __oTemporaryTable == NIL
		__oTemporaryTable := FwTemporaryTable():new()
		__oTemporaryTable:SetFields(aFields)
		__oTemporaryTable:AddIndex("1",{"FILIAL","CLIENTE", "LOJA"})
		__oTemporaryTable:Create()

		__cTableTemporary := __oTemporaryTable:GetRealName()
	Endif

	__aBranches := PopulateBranchesToCustomer(cTable, aCustomers)

	If !Empty(__cTableTemporary)
		For nCountCustomers := 1 To nQtdCustomers
			SetInQuery(@cSetInBranch, aCustomers[nCountCustomers]["branchId"])

			If !Empty(cQueryCustomers)
				cQueryCustomers += 'OR '
			Endif

			cQueryCustomers += " ( "
			cQueryCustomers += " A1_COD = '" + aCustomers[nCountCustomers]["customerId"] + "' AND "
			cQueryCustomers += " A1_LOJA = '" + aCustomers[nCountCustomers]["storeId"] + "' "
			cQueryCustomers += " ) "

			If nCountCustomers == nLimit .or. nCountCustomers == nQtdCustomers
				nLimit += nLimit

				cQueryCustomers += " ) "

				cQuery := "SELECT  A1_FILIAL, A1_COD, A1_LOJA "
				cQuery += "FROM " + cTableNameReal + " "
				cQuery += "WHERE A1_FILIAL IN (" + cSetInBranch + ") "
				cQuery += " AND ( " + cQueryCustomers
				cQuery += " AND D_E_L_E_T_ = ' ' "

				cQueryCustomers := ""

				cInsert := totvs.protheus.backoffice.ngf.util.FunctionToDb(cBDName, "INSERT")
				cInsert += " INTO " + __cTableTemporary + " (FILIAL, CLIENTE, LOJA) " + cQuery

				cMessageErro := IIf(TcSQLExec(cInsert) < 0, TCSQLERROR(), "")

				If !Empty(cMessageErro)
					DestroyTemporaryCustomers()
					USEREXCEPTION( cMessageErro )
					Exit
				Endif
			Endif

		Next nCountCustomers
	Endif

Return __cTableTemporary

/*/{Protheus.doc} DestroyTemporaryCustomers
	Deleta a tabela temporaria e restaura as variaveis estaticas
	@type  Static Function
	@author Vitor Duca
	@since 09/06/2022
	@version 1.0
/*/
Function DestroyTemporaryCustomers()

	If __oTemporaryTable <> Nil
		__cTableTemporary := ""
		FwFreeArray(__aBranches)
		__aBranches := {}
		__oTemporaryTable:Delete()
		__oTemporaryTable := Nil
	Endif
	FinEraseTmpFil()
Return

/*/{Protheus.doc} BranchesToCustomerForTable
	Faz a montagem do IN das filiais que serão listados os movimentos
	@type  Function
	@author Vitor Duca
	@since 09/06/2022
	@version 1.0
	@param cTable, Character, Prefixo da tabela
	@param aCustomer, Array, Clientes
	@return cInBranch, Character, Expressão de IN que sera colocada na query
/*/
Function BranchesToCustomerForTable(cTable As Character, aCustomer As Array) As Character

	If Empty(__aBranches)
		__aBranches := PopulateBranchesToCustomer(cTable, aCustomer)
	EndIf

Return FinSelFil(__aBranches, cTable, .F., .T.)

/*/{Protheus.doc} PopulateBranchesToCustomer
	Popula array de filiais do cliente 
	@type  Function
	@author Sidney Santos
	@since 08/04/2024
	@version 1.0
	@param cTable, Character, Prefixo da tabela
	@param aCustomer, Array, Array com os usuários do portal
	@return aBranches, Array, Filiais que o usuário tem acesso
/*/
function PopulateBranchesToCustomer(cTable as character, aCustomer as array) as array
	local nCountCustomers      as numeric
	local nCountBranches       as numeric
	local aBranchesForCustomer as array
	local oHash                as object
	local cFilTest             as character

	oHash := FwHashMap():new()
	// laco por cliente
	for nCountCustomers := 1 to Len(aCustomer)
		aBranchesForCustomer := aCustomer[nCountCustomers]["branches"]
		//laco por filial do cliente
		for nCountBranches := 1 to Len(aBranchesForCustomer)
			cFilTest := FwXFilial(cTable, aBranchesForCustomer[nCountBranches]["totalId"])
			if !oHash:ContainsKey(cFilTest)
				oHash:put(cFilTest, cFilTest)
			endIf
		next nCountBranches
	next nCountCustomers

return oHash:values()

/*/{Protheus.doc} SetInQuery
	Prepara as strings que serão utilizado no IN da query
	@type  Static Function
	@author Vitor Duca
	@since 09/06/2022
	@version 1.0
	@param cSetInQuery, Character, String que sera alterar por referencia
	@param cValue, Character, valor que deve ser gravado na string
/*/
Static Function SetInQuery(cSetInQuery As Character, cValue As Character)
	If Empty(cSetInQuery)
		cSetInQuery := " '" + cValue + "' "
	Elseif !cValue $ cSetInQuery
		cSetInQuery += "," + " '" + cValue + "' "
	Endif
Return
