#include 'tlpp-core.th'
#include 'backoffice.fin.tabledata.service.ch'

NAMESPACE totvs.protheus.backoffice.fin.tabledata
USING NAMESPACE totvs.protheus.backoffice.fin.apiutil
USING NAMESPACE totvs.protheus.backoffice.fin.functions
USING NAMESPACE gfin.api.tables
USING NAMESPACE gfin.util

Static __lCT2INCONS := CT2->(FieldPos("CT2_INCONS")) > 0

/*/{Protheus.doc} className
	classe para retorno de lista de itens
	@author user
	@since 20/10/2022
	@version version
/*/
Class TableData From FWAdapterBaseV2
	Public Data cAlias         	as Character
	Public Data aRespFields    	as Array
	Public Data aFilters    	as Array
	Public Data lFieldsUsado   	as Logical
	Public Data lFieldsBrowser 	as Logical
	Public Data lMSBLQL        	as Logical
	Public Data cAddFields	   	as Character
	Private Data oTmpTable		as Object

	Public Method new()
	Public Method destroy()
	Private Method setParams()
	Public Method setMapFields()
	Private Method setCustom()
	Private Method responseCustom()
	Public Method prepareItems()
	Public Method getResponse()
	Public Method prepareItemsCustom()
	Public Method createTableTemporary()
	Public Method execTemporaryTable()
EndClass

/*/{Protheus.doc} new
	construtor da classe
	@author renato.ito
	@since 20/10/2022
/*/
Method new() Class TableData
	::cAlias := ""
	::aRespFields := {}
	::aFilters := {}
	::lFieldsUsado := .F.
	::lFieldsBrowser := .F.
	::lMSBLQL := .F.
	::cAddFields := ""
	::oTmpTable := NIL
	_Super:new('GET')
	If MethIsMemberOf( self, "setUseSpaces", .T. )
		::setUseSpaces(.T.)
	Endif
Return Self

/*/{Protheus.doc} destroy
	limpa da memória as variáveis
	@author renato.ito
	@since 20/10/2022
/*/
Method destroy() Class TableData
	::cAddFields := ""
	If ::oTmpTable <> NIL
		::oTmpTable:Delete()
		::oTmpTable := NIL
	Endif	
	FwFreeArray(::aRespFields)
Return

/*/{Protheus.doc} getItems
	retorna a lista de itens no formato json
	@author renato.ito
	@since 20/10/2022
	@param cAlias, character, tabela do sistema
	@param jQueryParams, json, query params da requisicao
	@param jHeaders, json, headres da requisicao
	@param cCustomQuery, Character, query customizada
	@param lUseOrderQry, Logical, define se utilizará o setOrderQuery
	@return json, json com a lista de itens
/*/
Method prepareItems(cAlias as Character, jQueryParams as Json, jHeaders as Json, cCustomQuery as Character, lUseOrderQry as Logical) Class TableData

	Default lUseOrderQry := .F.

	::cAlias := UPPER(cAlias)
	::setParams(jQueryParams, jHeaders, lUseOrderQry)
	::setMapFields()
	If !Empty(cCustomQuery)
		::setQuery(cCustomQuery)
	Else
		::setQuery(queryDefault(::cAlias, ::lMSBLQL))
	EndIf
	If ::Execute()
		// Gera o arquivo Json com o retorno da Query
		::FillGetResponse()
	EndIf
Return ::getJSONResponse()

/*/{Protheus.doc} getResponse
	prepara a resposta para a API
	@author renato.ito
	@since 20/10/2022
	@return json, json com a lista de itens
/*/
Method getResponse() Class TableData
Return ::getJSONResponse()

/*/{Protheus.doc} getItemsCustom
	retorna a lista de itens no formato json para querys personalizadas
	@author renato.ito
	@since 20/10/2022
	@param cAlias, character, id da query
	@param jQueryParams, json, query params da requisicao
	@param jHeaders, json, headres da requisicao
	@return json, json com a lista de itens
/*/
Method prepareItemsCustom(cAliasID as Character, jQueryParams as Json, jHeaders as Json) Class TableData
	cAliasID := UPPER(cAliasID)
	Do Case
		Case cAliasID == "SA1FIN"
			SA1FIN(jQueryParams, jHeaders, Self)
		Case cAliasID == "SE1ACFLEG"
			SE1LEG(jQueryParams, jHeaders, Self, "ACF")
		Case cAliasID == "CV8CT2INCONS"
			CV8CT2INCONS(jQueryParams, jHeaders, Self)
		Case cAliasID == "MOTBX"
			MOTBX(jQueryParams, jHeaders, Self)
		Case cAliasID == "PCQUERY"
			PCQUERY(jQueryParams, jHeaders, Self)
		Case cAliasID == "FI2BOL"
			FI2BOL(jQueryParams, jHeaders, Self)
	EndCase
Return

/*/{Protheus.doc} setParams
	configuras os parametros recebidos pela api
	@author renato.ito
	@since 20/10/2022
	@param jQueryParams, json, query params da requisicao
	@param jHeaders, json, headres da requisicao
	@param lUseOrderQry, Logical, define se utilizará o setOrderQuery
	@return json, json com a lista de itens
/*/
Method setParams(jQueryParams as Json, jHeaders as Json, lUseOrderQry as Logical) Class TableData
	Local lFilterFilial := .F. 					as Logical
	Local aBranches 	:= {} 					As Array
	Local cQueryWhere 	:= "" 					As Character	
	Local jBranches		:= JsonObject():new()	As Json
	Local nBranches		:= 0					As Numeric

	Default lUseOrderQry := .F.

	// indica qual pagina devemos retornar
	If jQueryParams:hasProperty('page')
		::setPage(Val(jQueryParams['page']))
	EndIf

	// indica o tamanho da pagina
	If jQueryParams:hasProperty('pagesize')
		::setPageSize(Val(jQueryParams['pagesize']))
	ElseIf jQueryParams:hasProperty('pageSize')
		::setPageSize(Val(jQueryParams['pageSize']))
	EndIf

	// indica o filtro querystring recebido (pode se utilizar um filtro oData)
	If jQueryParams:hasProperty('filter') .and. !Empty(AllTrim(jQueryParams['filter']))
		aadd(::aFilters, {"FILTER", "(" + jQueryParams['filter'] + ")"})
		lFilterFilial := "_FILIAL" $ UPPER(jQueryParams['filter'])
	EndIf

	If !Empty(::aFilters)
		::SetUrlFilter(::aFilters)
	EndIf

	// order da query
	If jQueryParams:hasProperty('order') .and. !Empty(jQueryParams['order'])
		::SetOrder(UPPER(jQueryParams['order']))
		If lUseOrderQry
			::SetOrderQuery(UPPER(jQueryParams['order']))
		EndIf
	Else
		::SetOrder(normalizeIndex((::cAlias)->(IndexKey(1))))
	EndIf

	// adiciona os fields
	If jQueryParams:hasProperty('fields')
		::aRespFields := STRtokARR(UPPER(jQueryParams['fields']), ',')
	EndIf
	// adiciona os fields usado
	If jQueryParams:hasProperty('usado')
		If UPPER(jQueryParams['usado']) == 'S'
			::lFieldsUsado:= .T.
		EndIf
	EndIf
	// adiciona os fields browser
	If jQueryParams:hasProperty('browser')
		If UPPER(jQueryParams['browser']) == 'S'
			::lFieldsBrowser:= .T.
		EndIf
	EndIf
	If jQueryParams:hasProperty('msblql')
		If UPPER(jQueryParams['msblql']) == 'S'
			::lMSBLQL:= .T.
		EndIf
	EndIf

	// trata as filiais encaminhadas no header para o filtro
	If /*!lFilterFilial .And.*/ jHeaders:hasProperty('branches')
	 	aBranches := STRtokARR(UPPER(jHeaders['branches']), ',')
	Else	
		jBranches := gfin.util.branchesOfUser()
		For nBranches := 1 to len(jBranches)
			Aadd(aBranches, jBranches[nBranches]['totalId'])
		Next nBranches
	Endif	

	If Len(aBranches) > 0
	 	cQueryWhere := " AND " + ::cAlias + "." + gfin.api.tables.getCutAliasName(::cAlias) + "_FILIAL" + " IN (" + gfin.util.branchesFormatToIn(aBranches, ::cAlias) + ")"
	 	::SetWhere(cQueryWhere)
	Endif

Return

/*/{Protheus.doc} setMapFields
	configuras os campos na classe e trata quais serao retornados
	@author renato.ito
	@since 20/10/2022
/*/
Method setMapFields(cAlias as Character) Class TableData
	Local aAllFields    := {}                     as Array
	Local aFieldsLGPD   := {}                     as Array
	Local aStruct       := {}                     as Array
	Local lVerifyLGPD   := .F.                    as Logical
	Local lAllFields    := .F.                    as Logical
	Local lAddField     := .F.                    as Logical
	Local lFilterFields := Len(::aRespFields) > 0 as Logical
	Local nField        := 0                      as Numeric

	If Empty(cAlias)
		cAlias := ::cAlias
	EndIf

	aAllFields := FWSX3Util():GetAllFields(cAlias, .F.)
	If !::lFieldsUsado .And. !::lFieldsBrowser .And. !lFilterFields
		lAllFields := .T.
	EndIf

	aFieldsLGPD := FwProtectedDataUtil():UsrAccessPDField(__cUserID, aAllFields)
	// verifica a necessidade de testar LGPD
	lVerifyLGPD := Len(aAllFields) <> Len(aFieldsLGPD)

	// adiciona os campos enviados
	For nField := 1 To Len(aAllFields)
		lAddField  := .F.
		cField     := aAllFields[nField]
		lFieldLGPD := lVerifyLGPD .and. aScan(aFieldsLGPD , cField) == 0
		aStruct    := FWSX3Util():GetFieldStruct(cField)

		// logica para verificar se o campo deve entrar na query e retornar
		If lAllFields .Or. "_FILIAL" $ cField
			lAddField  := .T.
		Else
			If ::lFieldsUsado
				lAddField := X3Uso(GetSX3Cache(cField, 'X3_USADO'), 6) // modulo 6 SIGAFIN
			EndIf
			If !lAddField .And. ::lFieldsBrowser
				lAddField := GetSX3Cache(cField, 'X3_BROWSE' ) == 'S'
			EndIf
			If !lAddField .And. lFilterFields
				lAddField := AScan(::aRespFields, cField) > 0
			EndIf
		EndIf
		If lAddField
			::cAddFields += "," + cField
		EndIf

		::AddMapFields(;
			cField,;
			cField,;
			lAddField,;
			.F.,;
			{cField, aStruct[2], aStruct[3], aStruct[4]},;
			If(lFieldLGPD, "'" + STR0001 + "'", NIL);  // Confidencial
		)
	Next nField
	::setFields(::cAddFields)
Return

/*/{Protheus.doc} createTableTemporary
	Cria tabela temporaria que será utilizada na listagem dos registros
	@author Vitor Duca
	@since 09/08/2023
	@version 1.0
	@param jQueryParams, Json, Query params da requisição
	@param jHeaders, Json, Header da requisição
	@param aStruct, Array, Estrutura da tabela temporaria que sera criada
	@param aIndex, Array, Indices que serão criados na tabela temporaria
	@return ::oTmpTable, Object, Objeto criado contendo as informações da tabela temporaria
/*/
Method createTableTemporary(jQueryParams As Json, jHeaders As Json, aStruct As Array, aIndex As Array) Class TableData
	Local nX := 0	As Numeric
	Local nY := 0	As Numeric

	::oTmpTable := FwTemporaryTable():new()
	::oTmpTable:SetFields(aStruct)

	For nX := 1 to Len(aIndex)
		::oTmpTable:AddIndex(cValToChar(nX),	aIndex[nX])
	Next nX

	::oTmpTable:Create()

	::cAlias := ::oTmpTable:GetAlias()

	//Retirar o branches para não validar as filiais quando for tabela temporaria
	If jHeaders:hasProperty("branches")
		jHeaders:DelName("branches")
	Endif	

	::setParams(jQueryParams, jHeaders)
	::setQuery(" SELECT #QueryFields# FROM " + ::oTmpTable:getRealName() + " WHERE D_E_L_E_T_ = ' ' #QueryWhere#")

	For nY := 1 to Len(aStruct)
		::AddMapFields(;
			aStruct[nY][1],;
			aStruct[nY][1],;
			.T.,;
			.F.,;
			{aStruct[nY][1], aStruct[nY][2], aStruct[nY][3], aStruct[nY][4]},;
		)

		If nY == 1
			::cAddFields += aStruct[nY][1]
		Else
			::cAddFields += "," + aStruct[nY][1]
		Endif	
	Next nY

	::setFields(::cAddFields)

Return ::oTmpTable

/*/{Protheus.doc} execTemporaryTable
	executa a resposta para a API de tabela temporaria
	@author Vitor Duca
	@since 09/08/2023
/*/
Method execTemporaryTable() Class TableData
	If ::Execute()
		// Gera o arquivo Json com o retorno da Query
		::FillGetResponse()
	EndIf
Return

/*/{Protheus.doc} queryDefault
	query padrao para utilização na classe
	@author renato.ito
	@since 20/10/2022
	@param cAlias, character, codigo da tabela
	@param lverifyMSBLQL, logical, .t. = verifica se existe o campo e não retorna bloqueados
	@return json, json com a lista de itens
/*/
Function queryDefault(cAlias as Character, lverifyMSBLQL as Logical) as Character
	Local cQuery  := ""  as Character
	Local lMSBLQL := .F. as Logical
	Local cMSBLQL := ""  as Character

	If lverifyMSBLQL
		If (cAlias)->(FieldPos(cAlias +"_MSBLQL")) > 0
			cMSBLQL := cAlias +"_MSBLQL"
			lMSBLQL := .T.
		ElseIf (cAlias)->(FieldPos(SUBSTR(cAlias, 2) +"_MSBLQL")) > 0
			cMSBLQL := SUBSTR(cAlias, 2) +"_MSBLQL"
			lMSBLQL := .T.
		EndIf
	EndIf

	cQuery := " SELECT #QueryFields# "
	cQuery += " FROM " + RetSqlName(cAlias) + " " + cAlias
	cQuery += " WHERE  " + cAlias + ".D_E_L_E_T_ = ' ' "
	If lverifyMSBLQL .And. lMSBLQL
		cQuery += " AND  " + cAlias + "." + cMSBLQL + " <> '1' "
	EndIf
	cQuery += " #QueryWhere# "
Return cQuery

/*/{Protheus.doc} SA1FIN
	tratamento para adicionar os títulos em aberto do cliente
	adiciona a propriedades:
	{
		open: number - quandidade de títulos em aberto,
		openlabel: string - 1 se existe títulos em aberto e 0 se não existir,
	}
	@type  Function
	@author renato.ito
	@since 20/10/2022
	@version version
	@param jQueryParams, json, query params
	@param jHeaders, json, headers
/*/
Function SA1FIN(jQueryParams as Json, jHeaders as Json, oSelf as Object)
	oSelf:prepareItems('SA1', jQueryParams, jHeaders)
	responseSA1FIN(oSelf:OjsonObj:oJsonObj)
Return

/*/{Protheus.doc} SE1LEG
	Tratamento para adicionar legenda customizada
	{
		status: string - legenda customizada
	}
	@type  Function
	@author Vitor Duca
	@since 02/12/2022
	@version 1.0
	@param jQueryParams, json, query params
	@param jHeaders, json, headers
/*/
Function SE1LEG(jQueryParams as Json, jHeaders as Json, oSelf as Object, cIdLeg As Character)
	oSelf:prepareItems('SE1', jQueryParams, jHeaders)
	responseSE1LEG(oSelf:OjsonObj:oJsonObj, cIdLeg)
Return

/*/{Protheus.doc} CV8CT2INCONS
	Tratamento para adicionar legenda customizada
	{
		status: string - legenda customizada
	}
	@type  Function
	@author renato.ito
	@since 24/07/2023
	@version 1.0
	@param jQueryParams, json, query params
	@param jHeaders, json, headers
	@param oSelf, json, Object, instancia da classe
/*/
Function CV8CT2INCONS(jQueryParams as Json, jHeaders as Json, oSelf as Object)
	Local cQuery  := "" as Character
	Local cFields := "" as Character

	cFields := "CT2_FILIAL,"
	cFields += "CT2_DATA,"
	cFields += "CT2_PROCES,"
	cFields += "CV8_FILIAL,"
	cFields += "CV8_DATA,"
	cFields += "CV8_HORA,"
	cFields += "CV8_USER,"
	cFields += "CV8_PROC"

	oSelf:aRespFields := STRtokARR(UPPER(cFields), ',')

	cQuery := getQueryCV8Incons(cFields)
	oSelf:setMapFields('CV8')
	oSelf:prepareItems('CT2', jQueryParams, jHeaders, cQuery)
	If __lCT2INCONS
		responseCV8CT2INCONS(oSelf:OjsonObj:oJsonObj)
	EndIf
Return

/*/{Protheus.doc} MOTBX
	Lista os motivos de baixa de acordo com a existencia da tabela F7G
	@type  Function
	@author Vitor Duca
	@since 09/08/2023
	@version 1.0
	@param jQueryParams, json, query params
	@param jHeaders, json, headers
	@param oSelf, object, Objeto que contem a classe TableData
/*/
Function MOTBX(jQueryParams as Json, jHeaders as Json, oSelf as Object)
	Local aStruct := {} 	As Array
	Local aMotBx := {}		As Array
	Local oAliasTmp := NIL	As Object
	Local cAliasTmp := ""	As Character
	Local nX := 0			As Numeric

	aMotBx := ReadMotBx()

	// Somente os tipos que movimentam banco
	aAdd(oSelf:aFilters, {"FILTER", "(f7g_movbco eq 'S')"})	

	If AliasInDic("F7G")
		oSelf:prepareItems('F7G', jQueryParams, jHeaders)
	Else
		Aadd(aStruct, {"F7G_SIGLA", "C", 3,  0})
		Aadd(aStruct, {"F7G_DESCRI", "C", 10,  0})
		Aadd(aStruct, {"F7G_CART", "C", 1,  0})
		Aadd(aStruct, {"F7G_MOVBCO", "C", 1,  0})

		oAliasTmp := oSelf:createTableTemporary(jQueryParams, jHeaders, aStruct, {{"F7G_SIGLA", "F7G_CART"}})
		cAliasTmp := oAliasTmp:getAlias()

		For nX := 1 to Len(aMotBx)
			RecLock(cAliasTmp, .T.)
				(cAliasTmp)->F7G_SIGLA	:= Substr(aMotBx[nX],1,3)
				(cAliasTmp)->F7G_DESCRI	:= Substr(aMotBx[nX],7,10)
				(cAliasTmp)->F7G_CART	:= Substr(aMotBx[nX],34,1)
				(cAliasTmp)->F7G_MOVBCO	:= Substr(aMotBx[nX],19,1)
			msUnLock()
		Next nX

		oSelf:execTemporaryTable()
	Endif
Return

/*/{Protheus.doc} PCQUERY
	Fluxo para query do browse customizavel do portal do cliente
	@type  Function
	@author Renato Ito
	@since 04/07/2023
	@version 1.0
	@param jQueryParams, json, query params
	@param jHeaders, json, headers
	@param oSelf, object, Objeto que contem a classe TableData
/*/
Function PCQUERY(jQueryParams as Json, jHeaders as Json, oSelf as Object)
	Local aCliID       := {} as Array
	Local aCliKEY      := {} as Array
	Local nCli         := 0  as Numeric
	Local cUser        := "" as Character
	Local cFunction    := "" as Character
	Local cAlias       := "" as Character
	Local cCustomQuery := "" as Character
	Local jUserRow     := JsonObject():new() as Json

	if jHeaders:hasProperty('x-pc-customers') .and. jHeaders:hasProperty('x-pc-user') .and. jQueryParams:hasProperty('queryFunction') .and. jQueryParams:hasProperty('queryAlias') 

		aCliID := StrTokArr2(jHeaders['x-pc-customers'], '|', .T.)

		for nCli := 1 to len(aCliID)
			aadd(aCliKEY, StrTokArr2(aCliID[nCli], ',', .T.))
		next

		cUser     := jHeaders['x-pc-user']
		cFunction := jQueryParams['queryFunction']
		cAlias    := jQueryParams['queryAlias']
		if jQueryParams:hasProperty('userFilter')
			jUserRow:fromJson(jQueryParams['userFilter'])
		endIf
		cCustomQuery := Execblock(cFunction, .f., .f., {aCliKEY, cUser, jUserRow})
		
		jHeaders['branches'] = ""

		oSelf:prepareItems(cAlias, jQueryParams, jHeaders, cCustomQuery)
	endIf
Return

/*/{Protheus.doc} FI2BOL
	Consulta customizada na ocorrencias que estão relacionadas com boletos
	que foram registrados via API
	@type  Function
	@author Vitor Duca
	@since 31/03/2025
	@version 1.0
	@param jQueryParams, json, query params
	@param jHeaders, json, headers
	@param oSelf, json, Object, instancia da classe
/*/
Function FI2BOL(jQueryParams as Json, jHeaders as Json, oSelf as Object)
	Local cQuery  := "" 					as Character
	Local nItem	  := 0						as Numeric
	Local jResponse := JsonObject():new()	as Json
	Local jFI2Histor := JsonObject():new()	as Json
	Local lUseOrderQry := .T.               as Logical

	cQuery := getQueryOcurrencies()
	
	// adiciona os fields
	If jQueryParams:hasProperty('fields')
		oSelf:aRespFields := STRtokARR(UPPER(jQueryParams['fields']), ',')
	EndIf

	oSelf:setMapFields('SA6')
	oSelf:setMapFields('SEA')
	oSelf:setMapFields('SE1')
	oSelf:prepareItems('FI2', jQueryParams, jHeaders, cQuery, lUseOrderQry)

	jResponse := oSelf:OjsonObj:oJsonObj

	If jResponse:hasProperty('items') .And. ValType(jResponse['items']) == 'A'
		For nItem := 1 To Len(jResponse['items'])
			If jResponse['items'][nItem]:hasProperty('fi2_opeapi') .and. jResponse['items'][nItem]['fi2_opeapi'] == "C"
				If jResponse['items'][nItem]:hasProperty('fi2_histor')
					jFI2Histor:FromJson(jResponse['items'][nItem]['fi2_histor'])
					If jFI2Histor:hasProperty("dadosBorderoCancelamento")
						jResponse['items'][nItem]['a6_cod'] := jFI2Histor["dadosBorderoCancelamento"]["ea_portado"]
						jResponse['items'][nItem]['a6_agencia'] := jFI2Histor["dadosBorderoCancelamento"]["ea_agedep"]
						jResponse['items'][nItem]['a6_numcon'] := jFI2Histor["dadosBorderoCancelamento"]["ea_numcon"]
					Endif
				Endif
			Endif
		Next
	EndIf
	
	oSelf:OjsonObj:oJsonObj := jResponse
Return
