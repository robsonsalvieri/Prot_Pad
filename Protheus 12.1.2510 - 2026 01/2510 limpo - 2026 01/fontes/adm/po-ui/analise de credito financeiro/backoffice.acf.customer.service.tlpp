#include 'tlpp-core.th'
#Include "FWMVCDEF.ch"
#include 'totvs.ch'
#include 'backoffice.acf.customer.service.ch'

NAMESPACE totvs.protheus.backoffice.acf.customer
USING NAMESPACE totvs.protheus.backoffice.fin.apiutil
USING NAMESPACE totvs.protheus.backoffice.fin.functions

/*/{Protheus.doc} CreditCustomer
	classe para retorno das informações credito dos clientes
	@author Vitor Duca
	@since 20/10/2022
	@version 1.0
/*/
Class CreditCustomer
	Private Data cId as character //Id do Cliente que sera detalhado
	Private Data aKeyCustomer as Array //Matriz contendo a chave de busca do cliente
	Private Data aKeyHistory As Array //Matriz contendo a chave de busca do historico
	Private Data jResponse As Json //Response retornado pelo serviço
	Private Data jBodyRequest As Json //Body da requisição
	Private Data jHeaderRequest As Json //Header da requisição
	Private Data jQueryRequest As Json //Query Param da requisição
	Private Data cPathParam As Character //Path Param da requisição
	Private Data lIsLicenseActive As Logical //Define se possui licenciamento para uso da VADU
	Private Data lActivateCustomer As Logical //Define se a API de ajuste de credito irá ativar o cliente
	Private Data cFilBkp As Character //Guarda o valor da cFilAnt para ser restaurado
	Private Data lUseMockDataClass as logical

	Public Method new() CONSTRUCTOR
	Public Method destroy()

	//SET E GET
	Public Method setKeyCustomer(cId)
	Public Method setKeyHistory(cId)
	Public Method setPathParam(cPathParam)
	Public Method setBodyRequest(jBodyRequest)
	Public Method setQueryRequest(jQueryRequest)
	Public Method setHeaderRequest(jHeaderRequest)

	//METODOS HTTP
	Public  Method getById()
	Public  Method postVadu()
	Public  Method getVaduByID()
	Private Method getTokenVadu()
	Public 	Method getAttachments()
	Public  Method postHistory()
	Public  Method putHistory()
	Public  Method putBlockCustomer()
	Public  Method putNewCreditCustomer()

	//AUXILIARES
	Private Method prepareResponse()
	Public  Method IsLicenseActive()
	Private Method prepareCommitModel()
	Private Method newAttachments(aAttachments)
	Public  Method newExceptionError(jResponse,cFunction)
	Private Method hasMockData(cKey as character) as logical
	Private Method getMockData(cKey as character) as json

EndClass

/*/{Protheus.doc} new
	construtor da classe
	@author renato.ito
	@since 20/10/2022
/*/
Method new() Class CreditCustomer
	::cId := ""
	::aKeyCustomer := {}
	::jResponse := NIL
	::jBodyRequest := JsonObject():new()
	::jHeaderRequest := JsonObject():new()
	::jQueryRequest := JsonObject():new()
	::lIsLicenseActive := FwLSEnable(3042) .Or. FwLSEnable(4224)
	::lActivateCustomer := .F.
	::aKeyHistory := {}
	::cFilBkp := cFilAnt
	::lUseMockDataClass := FindClass('totvs.protheus.backoffice.fin.general.MockData')
Return Self

/*/{Protheus.doc} destroy
   Destroi o objeto limpando da memoria
    @author Vitor Duca
    @since 26/10/2022
    @version 1.0
    @return return_var, return_type, return_description
/*/
Method destroy() Class CreditCustomer
	If ::jHeaderRequest:hasProperty('dataBase') .and. !Empty(::jHeaderRequest['dataBase'])
		dDataBase := Date()
	Endif
	cFilAnt := ::cFilBkp
Return FwFreeObj(self)

/*/{Protheus.doc} setKeyCustomer
    Seta a chave que sera utiliza para buscar o cliente na SA1
    @author Vitor Duca
    @since 26/10/2022
    @version 1.0
    @param cId, Character, PathParam contendo a chave da SA1 (A1_FILIAL|A1_COD|A1_LOJA)
/*/
Method setKeyCustomer(cId as Character) Class CreditCustomer
	::aKeyCustomer := STRtokARR2(cId, '|', .T.)

	::aKeyCustomer[1] := Padr(::aKeyCustomer[1], TamSx3("A1_FILIAL")[1])
	::aKeyCustomer[2] := Padr(::aKeyCustomer[2], TamSx3("A1_COD")[1])
	::aKeyCustomer[3] := Padr(::aKeyCustomer[3], TamSx3("A1_LOJA")[1])

	cFilAnt := FXRetFil("SA1", ::aKeyCustomer[1])
Return

/*/{Protheus.doc} setKeyHistory
    Seta a chave que sera utiliza para buscar o historico na F7F
    @author Vitor Duca
    @since 12/12/2022
    @version 1.0
    @param cId, Character, PathParam contendo a chave da F7F (F7F_FILIAL|F7F_IDHIST)
/*/
Method setKeyHistory(cId as Character) Class CreditCustomer
	::aKeyHistory := STRtokARR2(cId, '|', .T.)

	::aKeyHistory[1] := Padr(::aKeyHistory[1], TamSx3("F7F_FILIAL")[1])
	::aKeyHistory[2] := Padr(::aKeyHistory[2], TamSx3("F7F_IDHIST")[1])

Return

/*/{Protheus.doc} setBodyRequest
	Seta o body enviado na requisição
	@author Vitor Duca
	@since 28/10/2022
	@version 1.0
	@param jBodyRequest, Json, Body enviado na requisição
/*/
Method setBodyRequest(jBodyRequest As Json) Class CreditCustomer
	::jBodyRequest:FromJson(jBodyRequest:ToJson())
Return

/*/{Protheus.doc} setPathParam
	Seta a pathparam enviada na requisição
	@author user
	@since 28/10/2022
	@version version
	@param cPathParam, Character, pathparam enviada na requisição
/*/
Method setPathParam(cPathParam As Character) Class CreditCustomer
	::cPathParam := cPathParam
Return

/*/{Protheus.doc} setQueryRequest
	Seta a query param enviada na requisição
	@author user
	@since 28/10/2022
	@version version
	@param jQueryRequest, Json, QueryParam enviada na requisição
/*/
Method setQueryRequest(jQueryRequest As Json) Class CreditCustomer
	::jQueryRequest:FromJson(jQueryRequest:ToJson())
Return

/*/{Protheus.doc} setHeaderRequest
	Seta o header enviado na requisição
	@author Vitor Duca
	@since 16/11/2022
	@version 1.0
	@param jHeaderRequest, Json, Header enviado na requisição
/*/
Method setHeaderRequest(jHeaderRequest) Class CreditCustomer
	::jHeaderRequest:FromJson(jHeaderRequest:ToJson())

	If ::jHeaderRequest:hasProperty('dataBase') .and. !Empty(::jHeaderRequest['dataBase'])
		dDataBase := Stod(totvs.protheus.backoffice.fin.apiutil.jsonStringToIso(::jHeaderRequest['dataBase']))
	Endif

	If ::jHeaderRequest:hasProperty('activatecustomer') .and. !Empty(::jHeaderRequest['activatecustomer'])
		::lActivateCustomer := Upper(::jHeaderRequest['activatecustomer']) == "S"
	Endif

	If ::jHeaderRequest:hasProperty('idhistory') .and. !Empty(::jHeaderRequest['idhistory'])
		::setKeyHistory(::jHeaderRequest['idhistory'])
	Endif
Return

/*/{Protheus.doc} getById
    Retorna os detalhes para analise de credito do cliente informado na pathParam da requisição
    @author Vitor Duca
    @since 26/10/2022
    @version version
    @return ::jResponse, Json, Response que sera enviado via REST 
/*/
Method getById() Class CreditCustomer
	Local nCountPendente   	:= 0     											As Numeric
	Local nCountVencidos   	:= 0     											As Numeric
	Local nValueVencidos  	:= 0     											As Numeric
	Local nValuePendente   	:= 0     											As Numeric
	Local nMoedaLc 			:= 0												As Numeric
	Local nMCusto 			:= Val(Alltrim(SuperGetMV("MV_MCUSTO",.F.,"2")))	As Numeric
	Local aLimitCredit      := {}												As Array
	Local cFilterType		:= ""												As Character

	If SA1->(MsSeek(::aKeyCustomer[1]+::aKeyCustomer[2]+::aKeyCustomer[3]))

		//Prepara a estrutura do response
		::prepareResponse()

		//Detalhes dos titulos
		nCountPendente := customerBills("pendente", NIL, SA1->A1_COD, SA1->A1_LOJA, SA1->A1_FILIAL, " COUNT(SE1.E1_NUM) ")
		nCountVencidos := customerBills("vencido", NIL, SA1->A1_COD, SA1->A1_LOJA, SA1->A1_FILIAL, " COUNT(SE1.E1_NUM) ")
		nValueVencidos := customerBills("vencido_saldo_moeda",, SA1->A1_COD, SA1->A1_LOJA, SA1->A1_FILIAL)
		nValuePendente := customerBills("pendente_saldo_moeda",, SA1->A1_COD, SA1->A1_LOJA, SA1->A1_FILIAL)

		::jResponse['customer']['code'] := SA1->A1_COD
		::jResponse['customer']['store'] := SA1->A1_LOJA
		::jResponse['customer']['branch'] := SA1->A1_FILIAL
		::jResponse['customer']['recno'] := SA1->(Recno())

		::jResponse['details']['bills']['open'] := nCountPendente + nCountVencidos
		::jResponse['details']['bills']['overdue']['quantity'] := nCountVencidos
		::jResponse['details']['bills']['pending']['quantity'] := nCountPendente
		::jResponse['details']['bills']['overdue']['value'] := nValueVencidos
		::jResponse['details']['bills']['pending']['value'] := nValuePendente
		::jResponse['details']['bills']['currency'] := 1

		//Filtro que sera utilizado para visualizar os registros que fizeram parte da regra
		cFilterType := formatFilterIn('e1_tipo', MVABATIM +"|"+ MVCOFINS +"|"+ MVPIS +"|"+ MVCS +"|"+ MVRECANT +"|"+ MV_CRNEG +"|"+ MVPROVIS,"|")
		::jResponse['details']['bills']['filter'] := "contains(e1_filial, '" + AllTrim(SA1->A1_FILIAL) + "') and e1_saldo ne 0 " +;
			"and e1_cliente eq '" + SA1->A1_COD + "' and e1_loja eq '" + SA1->A1_LOJA + "' " +;
			cFilterType;

		//Detalhe inadimplencia
		::jResponse['details']['nonpayment'] := Round((nValueVencidos / (nValuePendente + nValueVencidos)) * 100, 2)

		//Detalhe titulos pagos em atraso ultimos 12 meses
		::jResponse['details']['payments']['total']['quantity'] := customerBills("pagos", NIL, SA1->A1_COD, SA1->A1_LOJA, SA1->A1_FILIAL, " COUNT(SE1.E1_NUM) ")
		::jResponse['details']['payments']['total']['value'] := customerBills("pagos_valor_moeda", NIL, SA1->A1_COD, SA1->A1_LOJA, SA1->A1_FILIAL)
		::jResponse['details']['payments']['delay']['quantity'] := customerBills("pagos_atraso", NIL, SA1->A1_COD, SA1->A1_LOJA, SA1->A1_FILIAL, " COUNT(SE1.E1_NUM) ")
		::jResponse['details']['payments']['delay']['value'] := customerBills("pagos_atraso_valor_moeda", NIL, SA1->A1_COD, SA1->A1_LOJA, SA1->A1_FILIAL)
		::jResponse['details']['payments']['currency'] := 1

		//Detalhe limite de credito
		nMoedaLc := SA1->A1_MOEDALC

		If Empty(nMoedaLc)
			nMoedaLc := nMCusto
		Endif

		aLimitCredit := customerLimitCredit(SA1->A1_FILIAL, SA1->A1_COD, SA1->A1_LOJA)

		::jResponse['details']['creditlimit']['value'] := aLimitCredit[1]
		::jResponse['details']['creditlimit']['balance'] := aLimitCredit[2]
		::jResponse['details']['creditlimit']['currency'] :=  nMoedaLc

	Endif

Return ::jResponse

/*/{Protheus.doc} postVadu
	Realiza a consulta no VADU
	@author Vitor Duca
	@since 28/10/2022
	@version 1.0
	@return ::jResponse, Json, Response que sera enviado via REST 
/*/
Method postVadu() Class CreditCustomer
	Local cToken := "" As Character
	Local aHeaders := {} As Array
	Local oRest As Object
	Local jResponse := JsonObject():new() As Json

	If ::jBodyRequest <> NIL
		cToken := ::getTokenVadu()

		If !Empty(cToken)
			aadd(aHeaders, 'Content-Type: application/json')
			aadd(aHeaders, 'Authorization: Bearer ' + cToken)

			oRest := FwRest():New("https://www.creditbox.com.br")
			oRest:SetPostParams(::jBodyRequest:ToJson())
			oRest:SetPath("/CreditBox.dll/CreditBoxReport/JSONGerarReport")

			If self:hasMockData('postVadu')
				jResponse['response'] := self:getMockData('postVadu')
			Else
				If oRest:Post(aHeaders)
					jResponse['response'] := JsonObject():new()
					jResponse['response']:FromJSON(oRest:GetResult())
				Endif
			Endif
			
			If jResponse:hasProperty('response') .and. jResponse['response']:hasProperty('iniciado') .and. !jResponse['response']['iniciado']
				jResponse := totvs.protheus.backoffice.fin.apiutil.answerFormat(.F., 412, STR0013, "")//"Cadastro do CNPJ não encontrado no Creditbox"
			Endif
		Else
			jResponse := totvs.protheus.backoffice.fin.apiutil.answerFormat(.F., 401, STR0001, STR0002) //"Não foi possivel realizar a autenticação no VADU"#"Verifique se o parametro MV_FVADUCH existe na base e se esta com o conteudo correto"
		Endif
	Endif

Return jResponse

/*/{Protheus.doc} getVaduByID
	Verifica se o processo ja foi concluido no VADU e grava no historico a consulta realizada
	@author Vitor Duca
	@since 28/10/2022
	@version 1.0
	@return ::jResponse, Json, Response que sera enviado via REST 
/*/
Method getVaduByID() Class CreditCustomer
	Local aHeaders := {} As Array
	Local oRest As Object
	Local jResponse := JsonObject():new() As Json
	Local jApiMsg := JsonObject():new() As Json
	Local cToken := "" As Character
	Local nX := 0 As Numeric
	Local jResponseCommit := NIL as Json
	Local cFileName := "" As Character
	Local cBase64 := "" As Character
	Local lHasResponse := .F. as Logical

	If !Empty(::cPathParam)
		cToken := ::getTokenVadu()

		If !Empty(cToken)
			aAdd(aHeaders, "Accept-Encoding: UTF-8")
			aadd(aHeaders, 'Content-Type: application/json; charset=utf-8')
			aadd(aHeaders, 'Authorization: Bearer ' + cToken)

			oRest := FwRest():New("https://www.creditbox.com.br")
			oRest:SetPath("/CreditBox.dll/CreditBoxReport/JSONConsultarReport/" + ::cPathParam)

			//Metrica de acesso as consultas na Dimensa
			FWLsPutAsyncInfo("LS006", RetCodUsr(), "06", "FIN_CREDITBOX")

			While .T.
				Sleep(4000)

				if self:hasMockData('getVaduByID')
					jResponse['response'] := self:getMockData('getVaduByID')
					lHasResponse := .T.
				else 
					if oRest:Get(aHeaders)
						jResponse['response'] := JsonObject():new()
						jResponse['response']:FromJSON(oRest:GetResult())
						lHasResponse := .T.
					endIf
				endIf

				If lHasResponse

					//-9 = Processo não encontrado -1 = Processo finalizado com falha
					If jResponse['response']['situacao'] == -9 .or. jResponse['response']['situacao'] == -1
						Exit
					Endif

					// 0 = Gerando arquivo PDF -2 = Intervalo de consultas não permitido
					If jResponse['response']['situacao'] == 0 .or. jResponse['response']['situacao'] == -2
						Loop
					Else
						SA1->(DbSetOrder(1))
						If SA1->(DbSeek(::aKeyCustomer[1]+::aKeyCustomer[2]+::aKeyCustomer[3]))
							::jBodyRequest["f7f_filial"] := SA1->A1_FILIAL
							::jBodyRequest["f7f_codcli"] := SA1->A1_COD
							::jBodyRequest["f7f_loja"] := SA1->A1_LOJA
							::jBodyRequest["f7f_hist"] := "1"
							::jBodyRequest["f7f_txtjus"] := STR0010 //"Consulta realizada na VADU"

							jApiMsg:FromJson(jResponse:ToJson())

							For nX := 1 to Len(jResponse['response']['resultados'])
								If jResponse['response']['resultados'][nX]['formato'] == "PDF"
									cFileName := 'dimensa-' + SA1->A1_CGC + ".pdf"
									cBase64 := jResponse['response']['resultados'][nX]['conteudo']

									//Elimina do json que sera gravado no campo f7f_apimsg o base 64 do pdf
									ADel(jApiMsg['response']['resultados'], nX)
									ASize(jApiMsg['response']['resultados'], Len(jApiMsg['response']['resultados']) -1)
									Exit
								Endif
							Next nX

							::jBodyRequest["f7f_apimsg"] := JsonObject():new()
							::jBodyRequest["f7f_apimsg"]:FromJson(jApiMsg:ToJson())

							//Grava consulta no historico de credito do cliente
							jResponseCommit := ::postHistory()

							If jResponseCommit["response"]:hasProperty("credithistory")
								jResponse['response']['idhistory'] := jResponseCommit["response"]["credithistory"]["f7f_idhist"]
								totvs.protheus.backoffice.fin.functions.newDocument(cFileName, cBase64, F7F->F7F_IDHIST, "F7F")
							Endif
						Endif
						Exit
					Endif
				Endif
			End Do
		Else
			jResponse := totvs.protheus.backoffice.fin.apiutil.answerFormat(.F., 401, STR0001, STR0002) //"Não foi possivel realizar a autenticação no VADU"#"Verifique se o parametro MV_FVADUCH existe na base e se esta com o conteudo correto"
		Endif
	Endif

Return jResponse

/*/{Protheus.doc} getTokenVadu
	Recupera o token utilizado nas comunicação com a VADU
	@author Vitor Duca
	@since 01/11/2022
	@version 1.0
	@return ::jResponse, Json, Response que sera enviado via REST 
/*/
Method getTokenVadu() Class CreditCustomer
	Local aHeaders := {} As Array
	Local oRest As Object
	Local jResponse := JsonObject():New() As Json
	Local cToken := "" As Character

	aadd(aHeaders, 'Content-Type: application/json')
	aadd(aHeaders, 'Authorization: Bearer ' + SuperGetMV("MV_FVADUCH", .F., ""))

	oRest := FwRest():New("https://www.creditbox.com.br")
	oRest:setPath("/CreditBox.dll/Autenticacao/JSONPegarToken" )

	If self:hasMockData('getTokenVadu')
		jResponse := self:getMockData('getTokenVadu')
	Else
		If oRest:Get(aHeaders)
			jResponse:FromJSON(oRest:GetResult())
		Endif
	EndIf

	if jResponse:hasProperty('token')
		cToken := jResponse["token"]
	endIf

Return cToken

/*/{Protheus.doc} getAttachments
	Retorna os anexos do historico de credito do cliente
	@author Vitor Duca
	@since 16/12/2022
	@version 1.0
	@param cIdHistory, Character, Id da tabela de historico
/*/
Method getAttachments(cIdHistory As Character) Class CreditCustomer
	Local cQuery := "" As Character
	Local cAliasQuery := "" As Character
	Local jResponse := NIL As Json
	Local oFile := NIL As Object
	Local cDirDocs := lower(Alltrim(MsDocPath())) + "\" As Character	//	Retorna Pasta do Banco de Conhecimentos
	Local cFile := "" As Character
	Local aAttachments := {} As Array

	cQuery := "SELECT ACB.ACB_OBJETO ANEXO"
	cQuery += "FROM " + RetSqlName("AC9") + " AC9 "
	cQuery += "INNER JOIN " + RetSqlName("ACB") + " ACB ON ACB.ACB_FILIAL = AC9.AC9_FILIAL "
	cQuery += "AND ACB.ACB_CODOBJ = AC9.AC9_CODOBJ "
	cQuery += "AND ACB.D_E_L_E_T_ = '' "
	cQuery += "WHERE AC9.AC9_FILIAL = '" + xFilial("AC9") + "' "
	cQuery += 	"AND AC9.AC9_ENTIDA = 'F7F' "
	cQuery += 	"AND AC9.AC9_CODENT = '" + cIdHistory + "' "
	cQuery += 	"AND AC9.D_E_L_E_T_ = '' "

	cAliasQuery := MpSysOpenQuery(changeQuery(cQuery))

	While (cAliasQuery)->(!Eof())

		oFile := FwFileReader():New(cDirDocs + (cAliasQuery)->ANEXO)

		If (oFile:Open())
			cFile := oFile:FullRead()
			cFile := Encode64(cFile)
			Aadd(aAttachments, {'filename': AllTrim((cAliasQuery)->ANEXO), 'base64Data': cFile})
		Endif

		oFile:Close()
		(cAliasQuery)->(DbSkip())
	End Do

	(cAliasQuery)->(DbCloseArea())

	if Len(aAttachments) > 0
		jResponse := JsonObject():new()
		jResponse["anexos"] := aAttachments
	Endif

Return jResponse

/*/{Protheus.doc} prepareResponse
	Prepara o layout do response na consulta dos detalhes de credito
	@author Vitor Duca
	@since 26/10/2022
	@version 1.0
/*/
Method prepareResponse() Class CreditCustomer
	::jResponse := JsonObject():new()
	::jResponse['customer'] := JsonObject():new()
	::jResponse['details'] := JsonObject():new()
	::jResponse['details']['bills'] := JsonObject():new()
	::jResponse['details']['bills']['overdue'] := JsonObject():new()
	::jResponse['details']['bills']['pending'] := JsonObject():new()
	::jResponse['details']['payments'] := JsonObject():new()
	::jResponse['details']['payments']['total'] := JsonObject():new()
	::jResponse['details']['payments']['delay'] := JsonObject():new()
	::jResponse['details']['creditlimit'] := JsonObject():new()
Return

/*/{Protheus.doc} IsLicenseActive
	Verifica se esta ativo a licença para uso do VADU
	@author user
	@since 04/11/2022
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	/*/
Method IsLicenseActive() Class CreditCustomer
Return ::lIsLicenseActive

/*/{Protheus.doc} postHistory
	Gravação na tabela do histórico de crédito
	@author Vitor Duca
	@since 28/10/2022
	@version 1.0
	@return jResponse, Json, Response que será enviado na requisição
/*/
Method postHistory() Class CreditCustomer
	Local oModel := NIL As Object
	Local jResponse := NIL As Json
	Local aStructF7F := {} As Array
	Local nFields := 0 As Numeric

	jResponse := JsonObject():new()
	F7F->(DbGoTop())

	If VALTYPE(::jBodyRequest) == "J"
		Begin Transaction
			SetMaster('F7F')
			SetPKModel({'F7F_FILIAL','F7F_CODCLI','F7F_LOJA'})
			oModel := FWLoadModel("FINMTEM")
			oModel:SetOperation(MODEL_OPERATION_INSERT)
			oModel:Activate()

			::prepareCommitModel(oModel:GetModel('MASTER'), MODEL_OPERATION_INSERT)

			If oModel:VldData() .and. oModel:CommitData()
				jResponse := answerFormat(.T., 201, STR0004, "") //"Registro cadastrado com sucesso!"
				jResponse["response"]["credithistory"] := JsonObject():new()

				aStructF7F := F7F->(DbStruct())

				For nFields := 1 to Len(aStructF7F)
					jResponse["response"]["credithistory"][Lower(aStructF7F[nFields][1])] := F7F->&(aStructF7F[nFields][1])
				Next nFields

			Else
				jResponse := answerFormat(.F., 400, STR0005, cValToChar(oModel:GetErrorMessage()[6])) //"Não foi possivel incluir o registro"
			Endif
		End Transaction
		JResponse := ::newExceptionError(jResponse, "postHistory" )
	Endif

Return jResponse

/*/{Protheus.doc} putHistory
	Altera um registro da tabela dos historicos de credito
	@author Vitor Duca
	@since 12/12/2022
	@version 1.0
	@return jResponse, Json, Resposta JSON que sera enviada para a requisição
/*/
Method putHistory() Class CreditCustomer
	Local oModel := NIL As Object
	Local jResponse := NIL As Json

	Private lMsErroAuto := .F.

	jResponse := JsonObject():new()
	F7F->(DbGoTop())
	F7F->(DbSetOrder(2))

	If F7F->(DbSeek(::aKeyHistory[1]+::aKeyHistory[2])) .and. VALTYPE(::jBodyRequest) == "J"
		Begin Transaction
			SetMaster('F7F')
			SetPKModel({'F7F_FILIAL','F7F_IDHIST'})
			oModel := FWLoadModel("FINMTEM")
			oModel:SetOperation(MODEL_OPERATION_UPDATE)
			oModel:Activate()

			::prepareCommitModel(oModel:GetModel('MASTER'), MODEL_OPERATION_UPDATE)

			If oModel:VldData() .and. oModel:CommitData()
				jResponse := answerFormat(.T., 201, STR0011, "") //"Registro alterado com sucesso!"
				jResponse["response"]["credithistory"] := JsonObject():new()
				jResponse["response"]["credithistory"] := ::jBodyRequest
			Else
				jResponse := answerFormat(.F., 400, STR0012, cValToChar(oModel:GetErrorMessage()[6])) //"Não foi possivel alterar o registro"
			Endif
		End Transaction

		JResponse := ::newExceptionError(jResponse, "putHistory" )

	Endif

Return jResponse

/*/{Protheus.doc} prepareCommitModel
    Realiza as operações no modelo da tabela F7F
    @type  Function
    @author Vitor Duca
    @since 17/11/2022
    @version 1.0
    @param jFields, JSON, Contem os campos da tabela
    @param oModel, Object, contem o modelo de dados da tabela F7F que ira sofrer alterações
    @param nOperation, Numeric, Operação do modelo de dados
/*/
Method prepareCommitModel(oModel As Object, nOperation As Numeric) Class CreditCustomer
	Local nX := 0 as Numeric
	Local aProperty := {} as Array
	Local cField := "" As Character

	aProperty := ::jBodyRequest:getNames()

	For nX := 1 To Len(aProperty)

		cField := Upper(aProperty[nX])

		//Não altera esses campos caso tenham sido enviados indevidamente
		If nOperation == MODEL_OPERATION_UPDATE .and. cField $ "F7F_FILIAL|F7F_CODCLI|F7F_LOJA"
			Loop
		Endif

		DO CASE
		CASE FWSX3Util():GetFieldType( cField ) == "D"
			oModel:setValue(cField, Stod(totvs.protheus.backoffice.fin.apiutil.jsonStringToIso(::jBodyRequest[aProperty[nX]])))

		CASE ValType( ::jBodyRequest[aProperty[nX]] ) == 'J'
			oModel:setValue(cField, ::jBodyRequest[aProperty[nX]]:ToJson())

		OTHERWISE
			oModel:setValue(cField, ::jBodyRequest[aProperty[nX]])

		END CASE
	Next nX

	If nOperation == MODEL_OPERATION_INSERT
		oModel:setValue('F7F_IDHIST', FWUUIDV4())

		If !::jBodyRequest:hasProperty('f7f_user')
			oModel:setValue('F7F_USER', cUserName)
		Endif

		If !::jBodyRequest:hasProperty('f7f_hora')
			oModel:setValue('F7F_HORA', Time())
		Endif
	Endif

Return

/*/{Protheus.doc} putBlockCustomer
	Bloquear o cliente e incluir o historico
	@author Vitor Duca
	@since 17/11/2022
	@version 1.0

	Formato esperado do JSON
		{
			justification:
			attachments:
		}
		
	@return jResponse, Json, Resposta da requisição
/*/
Method putBlockCustomer() Class CreditCustomer
	Local jResponse := JsonObject():new() As Json
	Local jResponseCommit := JsonObject():new() As Json
	Local aAttachments := {} As Array
	
	SA1->(DbSetOrder(1))
	If SA1->(DbSeek(::aKeyCustomer[1]+::aKeyCustomer[2]+::aKeyCustomer[3]))
		Begin Transaction
			If SA1->(FieldPos("A1_MSBLQL")) > 0
				RecLock("SA1", .F.)
				SA1->A1_MSBLQL := '1'
				SA1->(MsUnlock())
			Endif

			::jBodyRequest["f7f_filial"] := SA1->A1_FILIAL
			::jBodyRequest["f7f_codcli"] := SA1->A1_COD
			::jBodyRequest["f7f_loja"] := SA1->A1_LOJA
			::jBodyRequest["f7f_hist"] := "3"
			::jBodyRequest["f7f_txtjus"] := ::jBodyRequest["justification"]
			::jBodyRequest["f7f_hora"] := Time()

			aAttachments := ::jBodyRequest["attachments"]

			//Deleta as propriedades para chamar as funções de inclusão ou alteração do registro
			::jBodyRequest:DelName("justification")
			::jBodyRequest:DelName("attachments")

			If Empty(::aKeyHistory)
				jResponseCommit := ::postHistory()
			Else
				jResponseCommit := ::putHistory()
			Endif

			If jResponseCommit:hasProperty("result") .and. jResponseCommit["result"]
				jResponse := answerFormat(.T., 200, STR0006, "") //"Cliente bloqueado com sucesso!"
				jResponse["response"]["customer"] := JsonObject():new()
				jResponse["response"]["customer"]["a1_msblql"] := '1'

				::newAttachments(aAttachments)

			Else
				jResponse := answerFormat(.F., 400, STR0005, jResponseCommit["response"]["detailedMessage"]) //"Não foi possivel incluir o registro"
				DisarmTransaction()
				Break
			Endif
		End Transaction

		JResponse := ::newExceptionError(jResponse, "putBlockCustomer" )

	Endif
Return jResponse

/*/{Protheus.doc} putNewCreditCustomer
	Ajusta o credito do cliente e incluir o historico
	@author Vitor Duca
	@since 18/11/2022
	@version 1.0

	Formato esperado do JSON
		{
			credit:
			datecredit:
			risk:
			justification:
			attachments:
		}
		

	@return jResponse, Json, Resposta da requisição
/*/
Method putNewCreditCustomer() Class CreditCustomer
	Local nOldLimit := 0 As Numeric
	Local nOldRisk := "" As Character
	Local lMsblql := SA1->(FieldPos("A1_MSBLQL")) > 0 As Logical
	Local lRet := .T. As Logical
	Local aLimitCredit := {} As Array
	Local cDateCredit := ::jBodyRequest["datecredit"] As Character
	Local aAttachments := {} As Array
	Local jResponse := JsonObject():new() As Json
	
	SA1->(DbSetOrder(1))
	If SA1->(DbSeek(::aKeyCustomer[1]+::aKeyCustomer[2]+::aKeyCustomer[3]))

		If lMsblql .and. SA1->A1_MSBLQL == '1' .and. !::lActivateCustomer
			jResponse := answerFormat(.F., 400, STR0007, STR0008) //"Não foi possivel ajustar o crédito"#"O cliente encontra-se inativo"
			lRet := .F.
		Endif

		If lRet
			Begin Transaction
				nOldLimit := SA1->A1_LC
				nOldRisk := SA1->A1_RISCO

				RecLock("SA1", .F.)
				SA1->A1_LC := ::jBodyRequest["credit"]
				SA1->A1_RISCO := ::jBodyRequest["risk"]
				SA1->A1_VENCLC := Stod(totvs.protheus.backoffice.fin.apiutil.jsonStringToIso(cDateCredit))

				If lMsblql .and. ::lActivateCustomer
					SA1->A1_MSBLQL := '2'
				Endif
				SA1->(MsUnlock())

				::jBodyRequest["f7f_filial"] := SA1->A1_FILIAL
				::jBodyRequest["f7f_codcli"] := SA1->A1_COD
				::jBodyRequest["f7f_loja"] := SA1->A1_LOJA
				::jBodyRequest["f7f_hist"] := "2"
				::jBodyRequest["f7f_txtjus"] := ::jBodyRequest["justification"]
				::jBodyRequest["f7f_hora"] := Time()
				::jBodyRequest["f7f_limant"] := nOldLimit
				::jBodyRequest["f7f_limatu"] := ::jBodyRequest["credit"]
				::jBodyRequest["f7f_risant"] := nOldRisk
				::jBodyRequest["f7f_risatu"] := ::jBodyRequest["risk"]

				aAttachments := ::jBodyRequest["attachments"]

				//Deleta as propriedades para chamar as funções de inclusão ou alteração do registro
				::jBodyRequest:DelName("credit")
				::jBodyRequest:DelName("datecredit")
				::jBodyRequest:DelName("risk")
				::jBodyRequest:DelName("justification")
				::jBodyRequest:DelName("attachments")

				If Empty(::aKeyHistory)
					jResponseCommit := ::postHistory()
				Else
					jResponseCommit := ::putHistory()
				Endif

				If jResponseCommit:hasProperty("result") .and. jResponseCommit["result"]
					jResponse := answerFormat(.T., 200, STR0009, "") //"Crédito ajustado com sucesso!"
					jResponse["response"]["customer"] := JsonObject():new()
					jResponse["response"]["customer"]["a1_lc"] := ::jBodyRequest["f7f_limatu"]
					jResponse["response"]["customer"]["a1_risco"] := ::jBodyRequest["f7f_risatu"]
					jResponse["response"]["customer"]["a1_venclc"] := cDateCredit

					::newAttachments(aAttachments)

					If lMsblql .and. ::lActivateCustomer
						jResponse["response"]["customer"]["a1_msblql"] := '2'
					Endif

					//Retorna as informações de saldo e novo limite para atualização do card Limite de credito
					aLimitCredit := customerLimitCredit(::aKeyCustomer[1], ::aKeyCustomer[2], ::aKeyCustomer[3])

					jResponse["response"]["creditlimit"] := JsonObject():new()
					jResponse["response"]["creditlimit"]["value"] := aLimitCredit[1]
					jResponse["response"]["creditlimit"]["balance"] := aLimitCredit[2]
				Else
					jResponse := answerFormat(.F., 400, STR0005, jResponseCommit["response"]["detailedMessage"]) //"Não foi possivel incluir o registro"
					DisarmTransaction()
					Break
				Endif
			End Transaction

			JResponse := ::newExceptionError(jResponse, "putNewCreditCustomer" )
		Endif
	Endif
Return jResponse

/*/{Protheus.doc} newAttachments
	Grava novos anexos no historico de credito
	@author Vitor Duca
	@since 15/12/2022
	@version 1.0
	@param aAttachments, Array, Matriz contendo os anexos que serão gravados
/*/
Method newAttachments(aAttachments As Array) Class CreditCustomer
	Local nAttachments := len(aAttachments) As Numeric
	Local nCount := 0 As Numeric
	Local cFileName := "" As Character
	Local cBase64 := "" As Character

	If nAttachments > 0
		For nCount := 1 to nAttachments
			cFileName := aAttachments[nCount]["filename"]
			cBase64 := aAttachments[nCount]["base64Data"]
			totvs.protheus.backoffice.fin.functions.newDocument(cFileName, cBase64, F7F->F7F_IDHIST, "F7F")
		Next nCount
	Endif
Return

/*/{Protheus.doc} newExceptionError
	Simula uma mensagem de erro dentro de uma transaction - Rotina Automática
	@author Pequim
	@since 23/02/2024
	@version 1.0
	@param jResponse, Json, Resposta
/*/
Method newExceptionError(jResponse As Json, cFunction as character) Class CreditCustomer 
	DEFAULT cFunction := ''

	If Type("lMsErroAuto") == 'L' .and. lMsErroAuto
		jResponse := answerFormat(.F., 500, STR0005 , cFunction ) //"Não foi possivel incluir o registro"
	Endif

Return jResponse


/*/{Protheus.doc} hasMockData
	@description Verifica se existem dados simulados para a chave informada
	@author guilherme.sordi@totvs.com.br
	@since 29/08/2024
	@version 12.1.2310
	@param cKey, character, Chave de identificação dos dados simulados
/*/
Method hasMockData(cKey as character) as logical Class CreditCustomer
	local lHasMockData := .F. as logical
	local oMockData as object

	if self:lUseMockDataClass
		oMockData := totvs.protheus.backoffice.fin.general.MockData():getInstance()
		lHasMockData := oMockData:getMockData():hasProperty(cKey)
	endIf
return lHasMockData


/*/{Protheus.doc} getMockData
	@description Retorna os dados simulados para a chave informada
	@author guilherme.sordi@totvs.com.br
	@since 29/08/2024
	@version 12.1.2310
	@param cKey, character, Chave de identificação dos dados simulados
/*/
Method getMockData(cKey as character) as json Class CreditCustomer
	local jMockData := JsonObject():new() as json
	local oMockData as object

	if self:lUseMockDataClass
		oMockData := totvs.protheus.backoffice.fin.general.MockData():getInstance()
		if oMockData:getMockData():hasProperty(cKey)
			jMockData:fromJson(oMockData:getMockData()[cKey]:toJson())
		endIf
	endIf
return jMockData
