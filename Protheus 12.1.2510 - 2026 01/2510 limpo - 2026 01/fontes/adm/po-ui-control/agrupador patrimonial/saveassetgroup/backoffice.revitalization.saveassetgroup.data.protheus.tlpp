#include "tlpp-core.th"

namespace totvs.protheus.backoffice.revitalization.saveassetgroup
using namespace totvs.protheus.backoffice.reconciliation.util

//-------------------------------------------------------------------
/*/{Protheus.doc} SaveAssetGroupProtheusData
Classe responsavél por salvar os dados da entidade na tabela FM3 e FM4

@type class
/*/
//-------------------------------------------------------------------
Class SaveAssetGroupProtheusData
	Public  method new()
	Public  method getData() as Object
	Public  method postSaveAssetGroup()
Endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} new
Construtor da classe

@return o objeto
@type Method
/*/
//-------------------------------------------------------------------
Method new() class SaveAssetGroupProtheusData
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} getData
Responsável por retornar o objeto com os dados da entidade GroupAssetsHeader

@return o objeto
@type Method
/*/
//-------------------------------------------------------------------
Method getData() class SaveAssetGroupProtheusData As Object
	static __oActiveData As Object

	If ValType(__oActiveData) == "U"
		__oActiveData := SaveAssetGroupProtheusData():new()
	EndIf
Return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} postSaveAssetGroup
Responsável por salvar os dados da entidade GroupAssetsHeader no Protheus

@param jBody as Json
@return jReturn as Character
@type
/*/
//-------------------------------------------------------------------
Method postSaveAssetGroup(jBody as Json) class SaveAssetGroupProtheusData
	Local i         			:= 0
	Local cCodGroup 			:= "" as Character
	Local jReturn   			:= JsonObject():new() as Json
	Local cBase 	  			:= "" as Character
	Local cItem 	  			:= "" as Character
	Local cChapa 	  			:= "" as Character
	Local cQuantd 				:= "" as Character
	Local cDescr 	  			:= "" as Character
	Local cGrupo 	  			:= "" as Character
	Local cLocal 	  			:= "" as Character
	Local cTipo 	  			:= "" as Character
	Local cFilOri 	  			:= "" as Character
	Local lDeleteAsset  	    := .F. as Logical
	Local lMultiFil 			:= FM4->(FieldPos("FM4_FILORI")) > 0 as Logical
	JReturn["status"] := "success"

	DbSelectArea("FM3")
	FM3->(DbSetOrder(1))
	// Verifica se o agrupador já existe
	If jBody:hasProperty('codassets')
		cCodGroup       := JBody["codassets"]
		FM3->(dbSeek(xFilial("FM3")+jBody["codassets"]))
		Reclock("FM3", .F.)
		FM3->FM3_FILIAL := xFilial("FM3")
		FM3->FM3_CODIGO := cCodGroup
		FM3->FM3_DESCR  := jBody['desc']
		FM3->FM3_CODUSR := RetCodUsr()
		FM3->FM3_DATAGR := dDataBase
		FM3->FM3_HORAGR := Time()
		FM3->FM3_SITUAC := jBody['type']
		FM3->FM3_DATAIN := Stod(jBody['startDate'])
		FM3->FM3_DATAFI := Stod(jBody['endDate'])
		FM3->(MsUnlock())
	Else
		// Caso não exista, cria um novo registro

		//Identifica o próximo código disponível
		cCodGroup       := GetSXENum("FM3", "FM3_CODIGO")

		While (FM3->(dbSeek(xFilial("FM3")+cCodGroup)))
			cCodGroup       := GetSXENum("FM3", "FM3_CODIGO")
		EndDo

		Reclock("FM3", .T.)
		FM3->FM3_FILIAL := xFilial("FM3")
		FM3->FM3_CODIGO := cCodGroup
		FM3->FM3_DESCR  := jBody['desc']
		FM3->FM3_CODUSR := RetCodUsr()
		FM3->FM3_DATAGR := dDataBase
		FM3->FM3_HORAGR := Time()
		FM3->FM3_SITUAC := jBody['type']
		FM3->FM3_DATAIN := Stod(jBody['startDate'])
		FM3->FM3_DATAFI := Stod(jBody['endDate'])
		FM3->(MsUnlock())

		FM3->(ConfirmSX8())
	EndIf

	JReturn["codassets"] := cCodGroup

	If len(JBody["items"]) > 0
		DbSelectArea("FM4")
		FM4->(DbSetOrder(2))
		For i := 1 to len(JBody["items"])
		 	cBase 	  	:= PadR(jBody['items'][i]["n1_cbase"], TAMSX3("FM4_CBASE")[1], " ")
			cItem 	  	:= PadR(jBody['items'][i]["n1_item"], TAMSX3("FM4_ITEM")[1], " ")
			cChapa 	  	:= PadR(jBody['items'][i]["n1_chapa"], TAMSX3("FM4_CHAPA")[1], " ")
			cQuantd   	:= jBody['items'][i]["n1_quantd"]
			cDescr 	  	:= PadR(jBody['items'][i]["n1_descric"], TAMSX3("FM4_DESCR")[1], " ")
			cGrupo 	  	:= PadR(jBody['items'][i]["n1_grupo"], TAMSX3("FM4_GRUPO")[1], " ")
			cLocal 	  	:= PadR(jBody['items'][i]["n1_local"], TAMSX3("FM4_LOCAL")[1], " ")
			cTipo 	  	:= PadR(jBody['items'][i]["n3_tipo"], TAMSX3("FM4_TIPO")[1], " ")
			lDeleteAsset:= jBody['items'][i]["deleteAsset"]
			If lMultiFil
				cFilOri :=PadR(jBody['items'][i]["n1_filial"], TAMSX3("FM4_FILIAL")[1], " ")
			EndIf

			// Verifica se o ativo já existe no agrupador
			If FM4->(dbSeek(xFilial("FM4")+cCodGroup+cBase+cItem+cTipo+cFilOri))
				// Caso exista, atualiza o registro
				If lDeleteAsset == .T.
					// Caso o ativo tenha sido removido do agrupador, exclui o registro
					RecLock("FM4",.F.)
					FM4->(DbDelete())
					FM4->(MsUnlock())
				Else
					// Caso o ativo não tenha sido removido do agrupador, atualiza o registro
					Reclock("FM4", .F.)
					FM4->FM4_FILIAL  := xFilial("FM4")
					If lMultiFil
						FM4->FM4_FILORI := cFilOri
					EndIf
					FM4->FM4_CBASE   := cBase
					FM4->FM4_ITEM    := cItem
					FM4->FM4_CHAPA   := cChapa
					FM4->FM4_QUANTD  := cQuantd
					FM4->FM4_DESCR   := cDescr
					FM4->FM4_GRUPO   := cGrupo
					FM4->FM4_LOCAL   := cLocal
					FM4->FM4_TIPO    := cTipo
					FM4->FM4_CODIGO  := cCodGroup
					FM4->(MsUnlock())
				Endif
			else
				// Caso não exista, cria um novo registro
				Reclock("FM4", .T.)
				FM4->FM4_FILIAL  := xFilial("FM4")
				If lMultiFil
					FM4->FM4_FILORI := cFilOri
				EndIf
				FM4->FM4_CBASE   := cBase
				FM4->FM4_ITEM    := cItem
				FM4->FM4_CHAPA   := cChapa
				FM4->FM4_QUANTD  := cQuantd
				FM4->FM4_DESCR   := cDescr
				FM4->FM4_GRUPO   := cGrupo
				FM4->FM4_LOCAL   := cLocal
				FM4->FM4_CODIGO  := cCodGroup
				FM4->FM4_TIPO	 := cTipo
				FM4->(MsUnlock())
			Endif
		Next
	Endif

Return jReturn:ToJSON()
