#include "tlpp-core.th"
#include "backoffice.accountingindicators.entitygroups.data.protheus.ch"

namespace totvs.protheus.backoffice.accountingindicators.entitygroups
//-------------------------------------------------------------------
/*/{Protheus.doc} EntityGroupsProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class EntityGroupsProtheusData from FWAdapterBaseV2
	Public  method new()
	Public  method getAll()
	static  method getData()

	Public method postSaveEntityGroups()
	Public method getCodPla()
	Public method getNextCode()
	Public method verifyExistCode()

	Private method validEntityGroups()
	Private method incrementCTSOrder()	
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} EntityGroupsProtheusData
Metodo construtor
@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class EntityGroupsProtheusData
	Default cVerbo := "GET"
	Default lList  := .T.
	_Super:New(cVerbo, lList)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} EntityGroupsProtheusData
Método para chamada e validação do tratamento de dados
/*/
//-------------------------------------------------------------------
method getData() class EntityGroupsProtheusData
	static __oActiveData As Object

	If ValType(__oActiveData) == "U"
		__oActiveData := EntityGroupsProtheusData():new()
	EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca dos registros da SN1 e SN3
/*/
//-------------------------------------------------------------------
method getAll(cSearch as Character, cCodPla as Character, cConTag as Character, cOrdem as Character, nPage as Numeric, nPageSize as Numeric) class EntityGroupsProtheusData
	Local aArea   := GetArea() As Array
	Local cWhere  := '' as Character
	Local lSearch := !Empty(cSearch) as Logical
	Local lDetail := !Empty(cCodPla) .And. !Empty(cConTag) .And. !Empty(cOrdem) as Logical

	Default nPage     := 1
	Default nPageSize := 10

	addMapFields(self, lDetail)

	::setUseSpaces(.T.)
	::setPage(nPage)
	::setPageSize(nPageSize)
	::SetQuery(getQuery())

	if lSearch
		cWhere := "CTS_FILIAL = '" + xFilial("CTS") +"' AND "
		cWhere += "( CTS_CONTAG LIKE '%" + cSearch + "' OR CTS_DESCCG LIKE '%" + cSearch + "%' OR CTS_DESCCG LIKE '%" + Upper(cSearch) + "%') AND "
		cWhere += "CTS_ENTGRP = '1' AND CTS_LINHA = '001'"
	elseif lDetail
		cWhere := "CTS_FILIAL = '" + xFilial("CTS") +"' AND "
		cWhere += "CTS_CODPLA = '"+cCodPla+"' AND "
		cWhere += "CTS_CONTAG = '"+cConTag+"' AND "
		cWhere += "CTS_ORDEM  = '"+cOrdem+"' AND "
		cWhere += "CTS_ENTGRP = '1' "
	else
		cWhere := "CTS_FILIAL = '" + xFilial("CTS") +"' AND "
		cWhere += "CTS_ENTGRP = '1' AND CTS_LINHA = '001'"
	endif

	cWhere += " AND D_E_L_E_T_ = ' '"

	::SetWhere(cWhere)
	::SetOrder("CTS.CTS_FILIAL, CTS.CTS_CONTAG, CTS.CTS_DESCCG, CTS_LINHA")

	If ::Execute()
		::FillGetResponse()
	EndIf

	RestArea(aArea)
	FwFreeArray(aArea)
return


//-------------------------------------------------------------------
/*/{Protheus.doc} addMapFields
Realiza o mapeamento dos campos que serão retornados
/*/
//-------------------------------------------------------------------
Static Function addMapFields(oSelf as Object,lFlagFilter as Logical)
	If lFlagFilter
		oSelf:addMapFields("CTS_FILIAL", "CTS_FILIAL", .T., .F.,{"CTS_FILIAL", "C", TamSx3("CTS_FILIAL")[1], 0}, "CTS.CTS_FILIAL")
		oSelf:addMapFields("CTS_DESCCG", "CTS_DESCCG", .T., .F.,  {"CTS_DESCCG", "C",  TamSx3("CTS_DESCCG")[1], 0},  "CTS.CTS_DESCCG")
		oSelf:addMapFields("CTS_NOME",   "CTS_NOME", .T., .F.,  {"CTS_NOME", "C",  TamSx3("CTS_NOME")[1], 0},  "CTS.CTS_NOME")
		oSelf:addMapFields("CTS_CONTAG",  "CTS_CONTAG", .T., .F.,  {"CTS_CONTAG", "C",  TamSx3("CTS_CONTAG")[1], 0},  "CTS.CTS_CONTAG")
		oSelf:addMapFields("CTS_CODPLA",  "CTS_CODPLA", .T., .F.,  {"CTS_CODPLA", "C",  TamSx3("CTS_CODPLA")[1], 0},  "CTS.CTS_CODPLA")
		oSelf:addMapFields("CTS_CT1INI", "CTS_CT1INI", .T., .F.,  {"CTS_CT1INI", "C",  TamSx3("CTS_CT1INI")[1], 0},  "CTS.CTS_CT1INI")
		oSelf:addMapFields("CTS_CT1FIM", "CTS_CT1FIM", .T., .F.,  {"CTS_CT1FIM", "C",  TamSx3("CTS_CT1FIM")[1], 0},  "CTS.CTS_CT1FIM")
		oSelf:addMapFields("CTS_CTTINI", "CTS_CTTINI", .T., .F.,  {"CTS_CTTINI", "C",  TamSx3("CTS_CTTINI")[1], 0},  "CTS.CTS_CTTINI")
		oSelf:addMapFields("CTS_CTTFIM", "CTS_CTTFIM", .T., .F.,  {"CTS_CTTFIM", "C",  TamSx3("CTS_CTTFIM")[1], 0},  "CTS.CTS_CTTFIM")
		oSelf:addMapFields("CTS_CTDINI", "CTS_CTDINI", .T., .F.,  {"CTS_CTDINI", "C",  TamSx3("CTS_CTDINI")[1], 0},  "CTS.CTS_CTDINI")
		oSelf:addMapFields("CTS_CTDFIM", "CTS_CTDFIM", .T., .F.,  {"CTS_CTDFIM", "C",  TamSx3("CTS_CTDFIM")[1], 0},  "CTS.CTS_CTDFIM")
		oSelf:addMapFields("CTS_CTHINI", "CTS_CTHINI", .T., .F.,  {"CTS_CTHINI", "C",  TamSx3("CTS_CTHINI")[1], 0},  "CTS.CTS_CTHINI")
		oSelf:addMapFields("CTS_CTHFIM", "CTS_CTHFIM", .T., .F.,  {"CTS_CTHFIM", "C",  TamSx3("CTS_CTHFIM")[1], 0},  "CTS.CTS_CTHFIM")
		oSelf:addMapFields("CTS_TPSALD", "CTS_TPSALD", .T., .F.,  {"CTS_TPSALD", "C",  TamSx3("CTS_TPSALD")[1], 0},  "CTS.CTS_TPSALD")
		oSelf:addMapFields("CTS_ORDEM", "CTS_ORDEM", .T., .F.,  {"CTS_ORDEM", "C",  TamSx3("CTS_ORDEM")[1], 0},  "CTS.CTS_ORDEM")
		oSelf:addMapFields("CTS_LINHA", "CTS_LINHA", .T., .F.,  {"CTS_LINHA", "C",  TamSx3("CTS_LINHA")[1], 0},  "CTS.CTS_LINHA")
		oSelf:addMapFields("CTS_ENTGRP", "CTS_ENTGRP", .T., .F.,  {"CTS_ENTGRP", "C",  TamSx3("CTS_ENTGRP")[1], 0},  "CTS.CTS_ENTGRP")
	else
		oSelf:addMapFields("CTS_FILIAL", "CTS_FILIAL", .T., .F.,{"CTS_FILIAL", "C", TamSx3("CTS_FILIAL")[1], 0}, "CTS.CTS_FILIAL")
		oSelf:addMapFields("CTS_CONTAG",  "CTS_CONTAG", .T., .F.,  {"CTS_CONTAG", "C",  TamSx3("CTS_CONTAG")[1], 0},  "CTS.CTS_CONTAG")
		oSelf:addMapFields("CTS_DESCCG", "CTS_DESCCG", .T., .F.,  {"CTS_DESCCG", "C",  TamSx3("CTS_DESCCG")[1], 0},  "CTS.CTS_DESCCG")
		oSelf:addMapFields("CTS_CODPLA",  "CTS_CODPLA", .T., .F.,  {"CTS_CODPLA", "C",  TamSx3("CTS_CODPLA")[1], 0},  "CTS.CTS_CODPLA")
		oSelf:addMapFields("CTS_ENTGRP", "CTS_ENTGRP", .T., .F.,  {"CTS_ENTGRP", "C",  TamSx3("CTS_ENTGRP")[1], 0},  "CTS.CTS_ENTGRP")
		oSelf:addMapFields("CTS_ORDEM", "CTS_ORDEM", .T., .F.,  {"CTS_ORDEM", "C",  TamSx3("CTS_ORDEM")[1], 0},  "CTS.CTS_ORDEM")
	EndIf

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getQuery() As Character
	Local cQuery As Character
	cQuery := " SELECT #QueryFields#"
	cQuery += " FROM " + RetSqlName("CTS") + " CTS"
	cQuery += " WHERE #QueryWhere#"
Return cQuery


//-------------------------------------------------------------------
/*/{Protheus.doc} protetctor
Verifica  se a tabela CTS existe no banco de dados

@author Totvs
/*/
//-------------------------------------------------------------------
Method validEntityGroups() class EntityGroupsProtheusData
	Local aValid := {} as Array

	aAdd(aValid, .F.)
	aAdd(aValid, STR0001) //"A tabela de Visões Gerenciais não existe no banco de dados"
	aAdd(aValid, '')
	aAdd(aValid, '')
	aAdd(aValid, '')

	If ChkFile("CTS")
		aValid[1] := .T.
		aValid[2] := ""
		aValid[3] := ""
		aValid[4] := ""
		aValid[5] := ""
	EndIf

Return aValid


/*/{Protheus.doc} getCodPla
    Função que retorna o código Codigo da Visao Gerencial a ser utilizado
    @author Totvs
/*/
Method getCodPla() class EntityGroupsProtheusData
	Local cCodPla     := '' as Character
	Local cAliasCTS   := GetNextAlias() as Character

	cQuery := "SELECT CTS_CODPLA"
	cQuery += " FROM " + RetSQLName("CTS")
	cQuery += " WHERE CTS_FILIAL = '" + xFilial("CTS") +"' AND CTS_ENTGRP = '1' AND  D_E_L_E_T_ = ' '"

	dbUseArea(.T., "TOPCONN", TcGenQry(,, cQuery), cAliasCTS, .T., .F.)

	If (cAliasCTS)->(!EOF())
		cCodPla := (cAliasCTS)->CTS_CODPLA //Pega ultimo utilizado
	else
		cCodPla := MpSysExecScalar("SELECT MAX(CTS_CODPLA) NUMMAX FROM "+RetSqlName("CTS")+" WHERE CTS_FILIAL = '" + xFilial("CTS") + "' ", "NUMMAX")
		cCodPla := PadR(Soma1(cCodPla), TamSx3("CTS_CODPLA")[1])
	EndIf

	(cAliasCTS)->(dbCloseArea())

Return cCodPla


Method incrementCTSOrder() class EntityGroupsProtheusData
	Local cCustomOrder  := '' as Character
	Local cQuery        := '' as Character
	Local cAliasTmp     := GetNextAlias() as Character

	cQuery := "SELECT COALESCE(MAX(CTS_ORDEM), '0000000000')  CTSORDEM"
	cQuery += " FROM " + RetSQLName("CTS")
	cQuery += " WHERE CTS_FILIAL = '" + xFilial("CTS") +"' AND CTS_ENTGRP = '1' AND  D_E_L_E_T_ = ' '"

	dbUseArea(.T., "TOPCONN", TcGenQry(,, cQuery), cAliasTmp, .T., .F.)

	If (cAliasTmp)->(!EOF())
		cCustomOrder := (cAliasTmp)->CTSORDEM //Pega ultimo utilizado
	EndIf

	(cAliasTmp)->(dbCloseArea())
	If (cCustomOrder <> '')
		cCustomOrder := Soma1(cCustomOrder)
	EndIf

Return cCustomOrder


//-------------------------------------------------------------------
/*/{Protheus.doc} getNextCode
    Retorna o próximo código a ser utilizado

    @author Totvs
/*/
//-------------------------------------------------------------------
Method getNextCode(cCodPla) class EntityGroupsProtheusData
	Local cContag := '' as Character
	// Local cExist  := .F. as Logical

	dbSelectArea("CTS")
	dbSetOrder(2)
	dbSeek(xFilial()+cCodPla+"zzzzzzzzzzzzzzzzzzzz",.T.)
	dbSkip(-1)

	if CTS->CTS_CODPLA <> cCodPla
		cContag := "000"
	else
		cContag := CTS->CTS_CONTAG
	endif

	cContag := PadR(Soma1(AllTrim(cContag)),TamSx3("CTS_CONTAG")[1])
	cContag := StrZero(Val(cContag),TamSx3("CTS_CONTAG")[1],0)
Return cContag


//-------------------------------------------------------------------
/*/{Protheus.doc} verifyExistCode
    Metodo que verifica se o codigo informado já existe em um agrupaodr contábil

    @param cCod - Codigo a ser verificado
    @author Totvs
/*/
//-------------------------------------------------------------------
method verifyExistCode(cCodPla as Character, cCode as Character) class EntityGroupsProtheusData
	Local lExist := .F. as Logical

	cQuery := "SELECT CTS_CODPLA FROM "+ RetSqlName("CTS")
	cQuery += " WHERE CTS_FILIAL = '" + xFilial("CTS") + "' AND CTS_CODPLA = '" + cCodPla + "' AND CTS_CONTAG = '" + cCode + "' AND CTS_ENTGRP = '1'"

	cContag := MpSysExecScalar(cQuery, "CTS_CODPLA")
	lExist  := !Empty(cContag)

Return lExist


/*/{Protheus.doc} postSaveEntityGroups
    Método que grava o JSON na tabela CTS
    @author Totvs
    @since 05/04/2022
    @version 12.1.33
    @param jBody
    @return aValid[2], return_type: character,
    return_description: aValid contém as mensagens de validação negativas,
    caso esteja vazio a validação está ok
/*/
Method postSaveEntityGroups(jBody, nOpcAuto) class EntityGroupsProtheusData
	Local nI      := 0   as Numeric
	Local aValid  := ::validEntityGroups() as Array
	Local cCodPla := ''  as Character
	Local cContag := ''  as Character
	Local cDesccg := ''  as Character
	Local cOrdem  := ''  as Character
	Local cLinha  := ''  as Character
	Local lDelete := .F. as Logical
	Local lAltera := .F. as Logical
	Local nSeq    := 0   as Numeric

	if aValid[1] //Em caso de alteração o aValid pode ter sido alterado

		dbSelectArea("CTS")
		CTS->(DbSetOrder(1))
		if nOpcAuto == 3 .OR. nOpcAuto == 4 // inclusão ou alteração

			// Primeiro item é o cabeçalho
			cCodPla := jBody["entitys"][1]["cts_codpla"]
			cOrdem  := jBody["entitys"][1]["cts_ordem"]
			cContag := jBody["entitys"][1]["cts_contag"]
			cDesccg := jBody["entitys"][1]["cts_desccg"]

			if Empty(cCodPla) .Or. cCodPla == "null" .Or. Empty(cOrdem) .Or. cOrdem == "null"
				cCodPla := ::getCodPla()
				cOrdem  := ::incrementCTSOrder(jBody)
			else
				lAltera := .T.
				cCodPla := PadR(cCodPla, TamSx3("CTS_CODPLA")[1])
				cOrdem  := PadR(cOrdem, TamSx3("CTS_ORDEM")[1])
			endif

			for nI := 1 to Len(jBody["entitys"])

				cLinha  := PadR(jBody["entitys"][nI]["xx_linha"], TamSx3("CTS_LINHA")[1]) // linha verdadeira
				lDelete := jBody["entitys"][nI]["xx_delete"]

				// verifica se é alteração / inclusão / exclusão da linha
				if CTS->(dbSeek(xFilial("CTS")+cCodPla+cOrdem+cLinha)) // altera

					// verifica se é exclusão
					if lDelete
						RecLock("CTS", .F.)
						CTS->(DbDelete())
						CTS->(MsUnlock())
					else
						// altera
						RecLock("CTS", .F.)
						CTS->CTS_DESCCG  := cDesccg
						CTS->CTS_CONTAG  := cContag
						CTS->CTS_CODPLA  := cCodPla
						CTS->CTS_ORDEM   := cOrdem
						CTS->CTS_CLASSE  := '2'
						CTS->CTS_CT1INI  := jBody["entitys"][nI]["cts_ct1ini"]
						CTS->CTS_CT1FIM  := jBody["entitys"][nI]["cts_ct1fim"]
						CTS->CTS_CTTINI  := jBody["entitys"][nI]["cts_cttini"]
						CTS->CTS_CTTFIM  := jBody["entitys"][nI]["cts_cttfim"]
						CTS->CTS_CTDINI  := jBody["entitys"][nI]["cts_ctdini"]
						CTS->CTS_CTDFIM  := jBody["entitys"][nI]["cts_ctdfim"]
						CTS->CTS_CTHINI  := jBody["entitys"][nI]["cts_cthini"]
						CTS->CTS_CTHFIM  := jBody["entitys"][nI]["cts_cthfim"]
						CTS->CTS_TPSALD  := jBody["entitys"][nI]["cts_tpsald"]
						// CTS->CTS_LINHA   := jBody["entitys"][nI]["cts_linha"]
						CTS->CTS_LINHA   := jBody["entitys"][nI]["xx_linha"]
						CTS->(MsUnlock())

					endif
				else
					// inclui
					// verifica a existência do cContag
					if nI == 1 // irá verificar apenas uma vez
						if ::verifyExistCode(cCodPla, cContag)
							cContag := ::getNextCode(cCodPla)
						endif
					Endif

					RecLock("CTS", .T.)
					CTS->CTS_FILIAL  := xFilial("CTS")
					CTS->CTS_DESCCG  := cDesccg
					CTS->CTS_CONTAG  := cContag
					CTS->CTS_CODPLA  := cCodPla
					CTS->CTS_ORDEM   := cOrdem
					CTS->CTS_CLASSE  := '2'
					CTS->CTS_IDENT   := '1'
					CTS->CTS_CT1INI  := jBody["entitys"][nI]["cts_ct1ini"]
					CTS->CTS_CT1FIM  := jBody["entitys"][nI]["cts_ct1fim"]
					CTS->CTS_CTTINI  := jBody["entitys"][nI]["cts_cttini"]
					CTS->CTS_CTTFIM  := jBody["entitys"][nI]["cts_cttfim"]
					CTS->CTS_CTDINI  := jBody["entitys"][nI]["cts_ctdini"]
					CTS->CTS_CTDFIM  := jBody["entitys"][nI]["cts_ctdfim"]
					CTS->CTS_CTHINI  := jBody["entitys"][nI]["cts_cthini"]
					CTS->CTS_CTHFIM  := jBody["entitys"][nI]["cts_cthfim"]
					CTS->CTS_TPSALD  := jBody["entitys"][nI]["cts_tpsald"]
					CTS->CTS_LINHA   := jBody["entitys"][nI]["xx_linha"]
					CTS->CTS_ENTGRP  := '1'
					CTS->(MsUnlock())
				endif

			next

			// Se alterou realiza a correção do sequencial
			if lAltera
				If CTS->(DbSeek(xFilial('CTS')+cCodPla+cOrdem))
					While CTS->(!Eof()) .And. xFilial('CTS')+cCodPla+cOrdem == CTS->(CTS_FILIAL+CTS_CODPLA+CTS_ORDEM)
						nSeq += 1
						RecLock("CTS",.F.)
						CTS->CTS_LINHA := StrZero(nSeq, TamSx3("CTS_LINHA")[1],0)
						CTS->(MsUnlock())
						CTS->(DbSkip())
					End
				EndIf
			endif

			aValid[2] := cCodPla
			aValid[3] := cOrdem
			aValid[4] := cContag
			aValid[5] := cDesccg
		elseif nOpcAuto == 5 // exclusão

			cCodPla := jBody["entitys"][1]["cts_codpla"]
			cOrdem  := jBody["entitys"][1]["cts_ordem"]
			cContag := jBody["entitys"][1]["cts_contag"]
			cDesccg := jBody["entitys"][1]["cts_desccg"]
			
			If CTS->(DbSeek(xFilial('CTS')+cCodPla+cOrdem))
					While CTS->(!Eof()) .And. xFilial('CTS')+cCodPla+cOrdem == CTS->(CTS_FILIAL+CTS_CODPLA+CTS_ORDEM)
						nSeq += 1
						RecLock("CTS",.F.)
						CTS->(dbDelete())
						CTS->(MsUnlock())
						CTS->(DbSkip())
					End
				EndIf
		endif

	endif
Return aValid






