#include "tlpp-core.th"

namespace totvs.protheus.backoffice.reconciliation.newdataexport
using namespace totvs.protheus.backoffice.reconciliation.util
using namespace totvs.protheus.backoffice.reconciliation.matchprocessing

static _lCpoCfgTrb


//-------------------------------------------------------------------
/*/{Protheus.doc} NewDataExportProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class NewDataExportProtheusData from FWAdapterBaseV2
    Public method new()
    Public method getAll()
    static method getData() As object
endclass

/*/{Protheus.doc} NewDataExportProtheusData
Metodo construtor

@author Totvs
/*/
method new(cVerbo, lList) Class NewDataExportProtheusData
    Default cVerbo := "GET"
    Default lList  := .T.
    _Super:New(cVerbo, lList)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} NewDataExportProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class NewDataExportProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := NewDataExportProtheusData():new()
    EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca das configuracoes do conciliador

@author Totvs
/*/
//-------------------------------------------------------------------
method getAll() class NewDataExportProtheusData
    Local aArea := GetArea() As Array
    Local cCodCfg := tcGetQryParams("codcfg") As Character
    Local cTabOri := tcGetQryParams("tabori") As Character
    Local cTabDes := tcGetQryParams("tabdes") As Character
    Local cCpoIdOri := "" As Character
    Local cCpoIdDes := "" As Character
    Local cAliasOri := GetNextAlias() As Character
    Local cAliasDes := GetNextAlias() As Character
    Local jHeaders  := JsonObject():new() as Json
    Local jResponse := JsonObject():new() as Json
    Local jUnion    := JsonObject():new() as Json
    Local jCfgTrib  := JsonObject():new() as Json
    Local oMatchProc := MatchProcessingProtheusData():New()
    Local aItems  := {} As Array
    Local nI := 0 As Numeric
    Local nJ := 0 As Numeric
    Local nPos := 0 As Numeric
    Local nReSize := 0 As Numeric
    Local lProgress := .F. As Logical
    Local lCfgTrib  := .F. As Logical
    Local cIdMatch := "" As Character
    Local cHeaderOri := "" As Character
    Local cHeaderDes := "" As Character
    Local aItemsOri  := {} As Array
    Local aErrorDes  := {} As Array
    Local cCpoUnion  := "" As Character
    Local nTamCodCon := 0
    Local nTamIdMatch := 0
    Local uJsonTest   := NIL
    Local uRet             As variant

    QLB->(dbSetOrder(1))
    If QLB->(dbSeek(FWxFilial("QLB")+cCodCfg))
        uRet := jHeaders:FromJson(AllTrim(QLB->QLB_FIELDS))
        lProgress := ValType(uRet) == "U"
        cCpoIdOri := QLB->QLB_CIDORI
        cCpoIdDes := QLB->QLB_CIDDES
    EndIf

    If lProgress
        uRet := jUnion:FromJson(AllTrim(QLB->QLB_TABGRP))
        If ValType(uRet) <> "U"
            jUnion["unionori"] := ""
        EndIf
    EndIf

    If lProgress
        If jUnion["unionori"] <> Nil
            For nI := 1 to Len(jUnion["unionori"])
                nReSize := 0
                For nJ := 1 to Len(jUnion["unionori"][nI]["fields"])
                    If Empty(jUnion["unionori"][nI]["fields"][nJ]["cpopai"])
                        cCpoUnion := jUnion["unionori"][nI]["fields"][nJ]["cpofil"]
                    Else
                        cCpoUnion := jUnion["unionori"][nI]["fields"][nJ]["cpopai"]
                    EndIf

                    If (nPos := aScan(jHeaders["data_ori"],{|x| x==cCpoUnion})) > 0
                        aDel(jHeaders["data_ori"],nPos)
                        nReSize++
                    EndIf
                    cHeaderOri += cCpoUnion+","
                Next nJ
            Next nI

            If nReSize > 0
                aSize(jHeaders["data_ori"],Len(jHeaders["data_ori"])-nReSize)
            EndIf
            
            If _lCpoCfgTrb == NIL
                _lCpoCfgTrb := QLB->(FieldPos("QLB_CFGTRB")) > 0 
            EndIf

            // CFGTRIB
            If _lCpoCfgTrb
                uRet  := jCfgTrib:FromJson(AllTrim(QLB->QLB_CFGTRB))
                lCfgTrib := ValType(uRet) == "U" .And. ValType(uRet) == "U" .And. ;
                    (jCfgTrib:hasProperty("tribori") .And. jCfgTrib:hasProperty("tribdes"))
            EndIf
            If !lCfgTrib
                //JSON vazio, apenas para não causar erro na passagem como parâmetro
                jCfgTrib:FromJson('{"tribori":{"field":"","col_taxes":[]},"tribdes":{"field":"","col_taxes":[]}}')
            EndIf
        EndIf

        cHeaderOri += oMatchProc:tcRetSQLExpression(jHeaders["data_ori"],", ",cCpoIdOri, nil, .T., , ,jCfgTrib["tribori"]["col_taxes"])+", CODCON, IDMATCH"

        If jUnion["uniondes"] <> Nil
            For nI := 1 to Len(jUnion["uniondes"])
                nReSize := 0
                For nJ := 1 to Len(jUnion["uniondes"][nI]["fields"])
                    If Empty(jUnion["uniondes"][nI]["fields"][nJ]["cpopai"])
                        cCpoUnion := jUnion["uniondes"][nI]["fields"][nJ]["cpofil"]
                    Else
                        cCpoUnion := jUnion["uniondes"][nI]["fields"][nJ]["cpopai"]
                    EndIf

                    If (nPos := aScan(jHeaders["data_des"],{|x| x==cCpoUnion})) > 0
                        aDel(jHeaders["data_des"],nPos)
                        nReSize++
                    EndIf
                    cHeaderDes += cCpoUnion+","
                Next nJ
            Next nI

            If nReSize > 0
                aSize(jHeaders["data_des"],Len(jHeaders["data_des"])-nReSize)
            EndIf
        EndIf

        cHeaderDes += oMatchProc:tcRetSQLExpression(jHeaders["data_des"],", ",cCpoIdDes, nil, .T., , ,jCfgTrib["tribdes"]["col_taxes"])+", CODCON, IDMATCH"

        getQuery(cTabOri,@cAliasOri,cHeaderOri)
        getQuery(cTabDes,@cAliasDes,cHeaderDes)

        aStructOri := (cAliasOri)->(dbStruct())
        aStructDes := (cAliasDes)->(dbStruct())

        If !(cAliasOri)->(Eof())
            nTamCodCon  := Len((cAliasOri)->(CODCON))
            nTamIdMatch := Len((cAliasOri)->(IDMATCH))
        EndIf

        cCabec := getCabecCSV(cAliasOri,aStructOri, cAliasDes, aStructDes, cCodCfg)
        jResponse['fields'] := StrToArray(cCabec,",")

        cLinhaVaziaOri := getEmptyLine(aStructOri,.T.)
        cLinhaVaziaDes := getEmptyLine(aStructDes)

        aItemsOri := getLineCSVArray(cAliasOri, aStructOri, cCodCfg)
        //Uso Json no destino devido a performance de busca no objeto Json
        // ser superior ao aScan
        oItemsDes := getLineCSVJson(cAliasDes, aStructDes, cCodCfg)

        (cAliasOri)->(dbCloseArea())
        (cAliasDes)->(dbCloseArea())

        For nI := 1 to Len(aItemsOri)
            cIdMatch := aItemsOri[nI,1]

            nTamOri := Len(aItemsOri[nI,2])

            nTamDes := 0
            If oItemsDes[cIdMatch] <> Nil
                nTamDes := Len(oItemsDes[cIdMatch])
            EndIf

            nTamFor := nTamOri

            If nTamOri < nTamDes
                nTamFor := nTamDes
            EndIf

            For nJ := 1 to nTamFor
                cLinha := ""

                If nJ > nTamOri
					cLinha += cLinhaVaziaOri+'"CODCON":"'+Left(cIdMatch,nTamCodCon)+'","IDMATCH":"'+Right(cIdMatch,nTamIdMatch)+'",'
                Else
                    cLinha += aItemsOri[nI,2,nJ]
                EndIf

                If nTamDes == 0
                    cLinha += RetLineError(cLinhaVaziaDes,"1")
                Else
                    If nJ > nTamDes
                        cLinha += cLinhaVaziaDes
                    Else
                        cLinha += oItemsDes[cIdMatch,nJ]
                    EndIf
                EndIf
                If !Empty(cLinha)
                    uJsonTest := JsonObject():New()
                    If uJsonTest:FromJson("{"+cLinha+"}") == NIL
                        aAdd(aItems, JsonObject():New())
                        aItems[Len(aItems)] := uJsonTest
                        uJsonTest := NIL
                    EndIf
                EndIf
            Next nJ
            oItemsDes:delName(cIdMatch)

        Next nI

        aErrorDes := oItemsDes:getNames()
        cLinhaVaziaOri := RetLineError(cLinhaVaziaOri,"2")
        For nI := 1 to Len(aErrorDes)

            cIdMatch := aErrorDes[nI]
            For nJ := 1 to Len(oItemsDes[cIdMatch])
                cLinha := cLinhaVaziaOri+'"CODCON":"'+Left(cIdMatch,nTamCodCon)+'","IDMATCH":"'+Right(cIdMatch,nTamIdMatch)+'",'
                cLinha += oItemsDes[cIdMatch,nJ]
            Next nJ
            If !Empty(cLinha)
                uJsonTest := JsonObject():New()
                If uJsonTest:FromJson("{"+cLinha+"}") == NIL
                    aAdd(aItems, JsonObject():New())
                    aItems[Len(aItems)] := uJsonTest
                    uJsonTest := NIL
                EndIf
            EndIf
        Next

        jResponse['items'] := aItems
    EndIf

    RestArea(aArea)
    FwFreeArray(aArea)

return jResponse

//-------------------------------------------------------------------
/*/{Protheus.doc} getQuery
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getQuery(cTabela, cAliasQry, cSelect) As Character
    Local cQuery As Character

    cQuery := " SELECT "+cSelect+;
                " FROM "+cTabela+;
                " WHERE IDMATCH <> ' ' "+;
                " ORDER BY CODCON, IDMATCH "

    dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.F.)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} getLineCSVArray
Retorna um array contendo as linhas da Origem

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getLineCSVArray(cAliasQry, aStruct, cCodCfg)
    Local aItems := {} as Array
    Local aArrayRet := {} as Array
    Local cCodConc := "" as Character
    Local cIdMatch := "" as Character
    Local aTitulos := Array(Len(aStruct)) as Array
    Local nI       := 0
    Local cCampo   := "" as Character

    // Inicializa valores padrão
    DEFAULT cAliasQry := ""
    DEFAULT aStruct := {}
    DEFAULT cCodCfg := ""

    For nI := 1 to Len(aStruct)
        cCampo := aStruct[nI, 1]
        If cCampo == "CODCON" .Or. cCampo == "IDMATCH"
            aTitulos[nI] := cCampo // Para CODCON e IDMATCH, o título é o próprio campo
        ElseIf _lCpoCfgTrb .And. FwTabPref(cCampo) == "T" //CFGTRIB
            aTitulos[nI] := AllTrim(TCGetTribTitle(cCampo, cCodCfg, "tabori", .T.))+' ('+cCampo+')' 
        Else
            aTitulos[nI] := AllTrim(FwX3Titulo(cCampo)) + ' (' + cCampo + ')'
        EndIf
    Next nI

    // Processa os registros
    (cAliasQry)->(dbGoTop())
    While !(cAliasQry)->(Eof())

        If cCodConc+cIdMatch <> (cAliasQry)->(CODCON+IDMATCH)
            If !Empty(cIdMatch)
                aAdd(aArrayRet,{cCodConc+cIdMatch,aItems})
            EndIf
            aItems := {}
            cCodConc := (cAliasQry)->(CODCON)
            cIdMatch := (cAliasQry)->(IDMATCH)
        EndIf

        cLinha := getLineStruct(cAliasQry, aStruct, .T., aTitulos)+","

        aAdd(aItems, cLinha)

        (cAliasQry)->(dbSkip())
    EndDo

    If Len(aItems) > 0
        aAdd(aArrayRet,{cCodConc+cIdMatch,aItems})
    EndIf

Return aArrayRet

//-------------------------------------------------------------------
/*/{Protheus.doc} getLineCSVJson
Retorna um Json contendo as linhas do Destino

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getLineCSVJson(cAliasQry, aStruct, cCodCfg)
    Local aItems := {} as Array
    Local oJsonRet := JsonObject():New()
    Local cCodConc := "" as Character
    Local cIdMatch := "" as Character
    Local aTitulos := Array(Len(aStruct))
    Local nI       := 0 as Numeric
    Local cCampo   := "" as Character

    DEFAULT cAliasQry := ""
    DEFAULT cCodCfg := ""
    DEFAULT aStruct := {}

    (cAliasQry)->(dbGoTop())
    For nI := 1 to Len(aStruct)
        cCampo := aStruct[nI, 1]
        If cCampo == "CODCON" .Or. cCampo == "IDMATCH"
            aTitulos[nI] := cCampo // Para CODCON e IDMATCH, o título é o próprio campo
        ElseIf _lCpoCfgTrb .And. FwTabPref(cCampo) == "T" //CFGTRIB
            aTitulos[nI] := AllTrim(TCGetTribTitle(cCampo, cCodCfg, "tabdes", .T.))+' ('+cCampo+')' 
        Else
            aTitulos[nI] := AllTrim(FwX3Titulo(cCampo)) + ' (' + cCampo + ')'
        EndIf
    Next nI

    While !(cAliasQry)->(Eof())

        If cCodConc+cIdMatch <> (cAliasQry)->(CODCON+IDMATCH)
            If !Empty(cIdMatch)
                oJsonRet[cCodConc+cIdMatch] := aItems
            EndIf
            aItems := {}
            cCodConc := (cAliasQry)->(CODCON)
            cIdMatch := (cAliasQry)->(IDMATCH)
        EndIf

        cLinha := getLineStruct(cAliasQry, aStruct, , aTitulos)

        aAdd(aItems, cLinha)

        (cAliasQry)->(dbSkip())
    EndDo

    If Len(aItems)>0
        oJsonRet[cCodConc+cIdMatch] := aItems
    EndIf

Return oJsonRet

//-------------------------------------------------------------------
/*/{Protheus.doc} getLineStruct
Retorna a linha do CSV de acordo com a estrutura da tabela

@author Totvs
/*/
//-------------------------------------------------------------------

Static Function getLineStruct(cAliasQry, aStruct, lIdMatch, aTitulos)
    Local cLinha := ""
    Local nI := 0
    Local cCampo := ""

    DEFAULT cAliasQry := ""
    DEFAULT aStruct   := {}
	DEFAULT lIdMatch  := .F.
	DEFAULT aTitulos  := {}

    For nI := 1 to Len(aStruct)

        cCampo := aStruct[nI,1]

        If !lIdMatch .And. (cCampo=="CODCON" .Or. cCampo=="IDMATCH")
            Loop
        EndIf

        If nI > 1
            cLinha += ","
        EndIf

        If aStruct[nI,2] == "C"
            cLinha += '"' + aTitulos[nI] + '":"'
			//No aStruct a data vem como C / Só verifico se é data se o campo tiver tamanho 8
            If aStruct[nI,3] == 8 .And. FWSX3Util():GetFieldType(cCampo) == "D"
                cLinha += DTOC(STOD(&('(cAliasQry)->('+cCampo+')')))
            Else
                cLinha += &('(cAliasQry)->('+cCampo+')')
            EndIf
            cLinha += '"'
        ElseIf aStruct[nI,2] == "N"
            cLinha += '"' + aTitulos[nI] + '":'
            cLinha += cValToChar(&('(cAliasQry)->('+cCampo+')'))
        EndIf
    Next nI

Return cLinha

//-------------------------------------------------------------------
/*/{Protheus.doc} getCabecCSV
Retorna o Cabeçalho do CSV de acordo com a estrutura da tabela

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getCabecCSV(cAliasOri, aStructOri, cAliasDes, aStructDes, cCodCfg)
    Local cCabec := ""
    Local nI := 0 as Numeric
    Local cCampo := ""

    DEFAULT cAliasOri := ""
    DEFAULT cAliasDes := ""
    DEFAULT cCodCfg := ""
    DEFAULT aStructOri := {}
    DEFAULT aStructDes := {}

    For nI := 1 to Len(aStructOri)
        If nI > 1
            cCabec += ","
        EndIf

        cCampo := aStructOri[nI,1]

        If cCampo == "IDMATCH" .Or. cCampo == "CODCON"
            cCabec += cCampo
        Else
            If _lCpoCfgTrb .And. FwTabPref(cCampo) == "T" //CFGTRIB
                cCampo := AllTrim(TCGetTribTitle(cCampo, cCodCfg, "tabori", .T.))+' ('+cCampo+')' 
            Else     
                cCampo := AllTrim(FWX3Titulo(cCampo))+' ('+cCampo+')'
            EndIf
            cCabec += cCampo
        EndIf
    Next nI

    For nI := 1 to Len(aStructDes)
        cCampo := aStructDes[nI,1]

        If cCampo == "IDMATCH" .Or. cCampo == "CODCON"
            Loop
        EndIf

        If _lCpoCfgTrb .And. FwTabPref(cCampo) == "T" //CFGTRIB
            cCampo := AllTrim(TCGetTribTitle(cCampo, cCodCfg, "tabdes", .T.))+' ('+cCampo+')' 
        Else     
            cCampo := AllTrim(FWX3Titulo(cCampo))+' ('+cCampo+')'
        EndIf
        cCabec += ','+cCampo
    Next nI

Return cCabec

//-------------------------------------------------------------------
/*/{Protheus.doc} getEmptyLine
Retorna uma linha em branco de acordo com a estrutura da tabela

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function getEmptyLine(aStruct, lOrigem, cCodCfg)
    Local cLInhaVazia := "" as Character
    Local nI := 0
    Local cCampo := ""
    Local cTypeTable := ""

    DEFAULT aStruct := {}
    DEFAULT lOrigem := .F.
    DEFAULT cCodCfg := ""

    If lOrigem
        cTypeTable := "tabori"
    Else
        cTypeTable := "tabdes"
    EndIf

    For nI := 1 to Len(aStruct)
        cCampo := aStruct[nI,1]

        If cCampo == "IDMATCH" .Or. cCampo == "CODCON"
            Loop
        EndIf

        If aStruct[nI,2] == "C"
            cLinhaVazia += '"'+AllTrim(FwX3Titulo(cCampo))+' ('+cCampo+')'+'":""'+","
        Else
            If _lCpoCfgTrb .And. FwTabPref(cCampo) == "T" //CFGTRIB
                cLinhaVazia += AllTrim(TCGetTribTitle(cCampo, cCodCfg, cTypeTable, .T.))+' ('+cCampo+')'+'":0'+","
            Else
                cLinhaVazia += '"'+AllTrim(FwX3Titulo(cCampo))+' ('+cCampo+')'+'":0'+","
            EndIf
        EndIf
    Next nI

    If !lOrigem .And. Len(cLinhaVazia) > 0
        cLinhaVazia := Left(cLinhaVazia,Len(cLinhaVazia)-1)
    EndIf

Return cLinhaVazia

//-------------------------------------------------------------------
/*/{Protheus.doc} RetLineError
Retorna a linha vazia com mensagem de erro

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function RetLineError(cLinhaVazia,cTipo)
Local cLineError := ""

If cTipo == "1"
    cLineError := "PROBLEMA: Chave CODCON + IDMATCH nao encontrada no destino."+cLinhaVazia
Else
    cLineError := Left(cLinhaVazia,Len(cLinhaVazia)-3)+'"PROBLEMA: Chave CODCON + IDMATCH nao encontrada na origem.",'
EndIf

Return cLineError
