#Include "BACKOFFICE.RECONCILIATION.DELETERECONCILIATIONHEADER.DATA.PROTHEUS.ch"
#include "tlpp-core.th"

namespace totvs.protheus.backoffice.reconciliation.DeleteReconciliationHeader
using namespace totvs.protheus.backoffice.reconciliation.util


//-------------------------------------------------------------------
/*/{Protheus.doc} DeleteReconciliationHeaderProtheusData
Classe responsavel pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class DeleteReconciliationHeaderProtheusData
Public  method new()
Public  method postByBody()
Public  method getData() as Object
Private method delHeaders()
Private method execDelete()
Private method execDeleteFin()
Private method isConfigFin() as Logical
endclass

/*/{Protheus.doc} DeleteReconciliationHeaderProtheusData
Metodo construtor

@author Totvs
/*/
method new() class DeleteReconciliationHeaderProtheusData
return

/*/{Protheus.doc} getData
Metodo para chamada e validacao do tratamento de dados

@author Totvs
/*/
method getData() class DeleteReconciliationHeaderProtheusData as Object
static __oActiveData as Object

If ValType(__oActiveData) == "U"
    __oActiveData := DeleteReconciliationHeaderProtheusData():new()
EndIf
return __oActiveData

/*/{Protheus.doc} postByBody
Metodo responsavel pela busca e gravacao das delecoes de matches

@author Totvs
/*/
method postByBody(jBody as Json) class DeleteReconciliationHeaderProtheusData
Local aResponse := {} as Array
Local lContinue := .T. as Logical
Local cError    := "" as Character

lContinue := ::delHeaders(jBody,@cError)

If lContinue
    aAdd(aResponse, lContinue)
    aAdd(aResponse, '{}')
Else
    aAdd(aResponse, lContinue)
    aAdd(aResponse, cError)
EndIf

return aResponse

/*/{Protheus.doc} getMatches
Metodo responsavel pela busca dos matches

@author Totvs
/*/
method delHeaders(jBody as Json, cError as Character) class DeleteReconciliationHeaderProtheusData
Local cCodCon    as Character
Local cCodCfg    as Character
Local aIDs      := {} as Array
Local lContinue := .T. as Logical

DEFAULT cError := ""

If ValType(jBody["codcon"]) == "C" .And. ValType(jBody["codcfg"]) == "C"
    cCodCon := jBody["codcon"]
    cCodCfg := jBody["codcfg"]
    aIDs    := jBody["msuidt"]

    lContinua := ::execDelete(cCodCon, cCodCfg, aIDs, @cError)
Else
    cError := STR0001 //"Conteúdo do corpo inválido."
    lContinue := .F.
EndIf

return lContinue

/*/{Protheus.doc} DelMatches
    Executa os updates nas tabelas de origem e destino para
    desmarcar os matches
    @author user
/*/
Method execDelete(cCodCon as Character, cCodCfg as Character, aIDs as Array, cError as Character) class DeleteReconciliationHeaderProtheusData
Local cQryUpd                                                   As Character
Local lContinue := .T.                                          As Logical
Local cTabCT2   := RetSQLName("CT2")                            As Character
Local cNameDB   := Alltrim(TcGetDB())                           As Character
Local lDelItens := (ValType(aIDs) == "A" .And. len(aIDs) > 0)   As Logical
Local cQLDIn    := ""                                           As Character
Local cQLDFil   := GetBranchiesForConditional("QLD")            As Character
Local aUUIDTMP   := {}                                          As Array
Local cUUIDTMP   := ""                                          As Character
Local aUUIDs     := {}                                          As Array
Local i          := 0                                           As Numeric
Local j          := 0                                           As Numeric
Local lCfgFin    := .F.                                         As Logical


DEFAULT cError := ""

lCfgFin := ::isConfigFin(cCodCfg)

If lDelItens
    cQLDIn := FormatIn(ArrTokStr(aIDs,'/'),'/')
    If cNameDB == "POSTGRES"
        cQLDIn := Lower( cQLDIn )
    EndIf
EndIf

If (CT2->(FieldPos("CT2_IDCONC")) > 0) .And. !lCfgFin

    aUUIDTMP := RetUUIDTMP(cQLDFil,cQLDIn,cCodCon,cCodCfg,lDelItens) // Busco os ID´s Da TMP posicionada

    for j:=1 to Len(aUUIDTMP)

        cUUIDTMP := aUUIDTMP[j] //Percorro todas as posições do array
        cQryUpd :=  " UPDATE "+cTabCT2
        cQryUpd +=  " SET CT2_IDCONC = ' ' "

        If "ORACLE" $ cNameDB
            aUUIDs := StrTokArr(cUUIDTMP, ",") // Converto a string em um array de strings
            cQryUpd += "WHERE CT2_MSUIDT IN ("
            for i := 1 to LEN(aUUIDs)
                cQryUpd += "HEXTORAW(" + aUUIDs[i] + ")"
                cQryUpd += IIf(i < LEN(aUUIDs),", ","")
            next i
            cQryUpd += ")"
        Else
            cQryUpd += " WHERE CT2_MSUIDT IN("+cUUIDTMP+")"
        EndIf

        If TcSqlExec(cQryUpd) <> 0
            Conout(TCSqlError())
            cError += STR0002+"CT2" //"Tabela: "
            lContinue := .F.
        EndIf
    next j
    
EndIf

If lContinue
    If lCfgFin
        ::execDeleteFin(cCodCon, cCodCfg, aIDs)
    Endif
    
    If lDelItens
        cQryUpd := "UPDATE "+RetSQLName("QLD")+" SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_  "+;
        " WHERE QLD_FILIAL = '"+xFilial("QLD")+"' AND QLD_CODCON = '"+cCodCon+"' AND QLD_CODCFG = '"+cCodCfg+"' "+;
        " AND QLD_IDITEM IN "+cQLDIn+" "+;
        " AND D_E_L_E_T_ = ' ' "
    Else
        cQryUpd := "UPDATE "+RetSQLName("QLD")+" SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_  "+;
        " WHERE QLD_FILIAL = '"+xFilial("QLD")+"' AND QLD_CODCON = '"+cCodCon+"' AND QLD_CODCFG = '"+cCodCfg+"' AND D_E_L_E_T_ = ' ' "
    EndIf

    If TcSqlExec(cQryUpd) <> 0
        Conout(TCSqlError())
        cError += STR0002+"QLD" //"Tabela: "
        lContinue := .F.
    EndIf
Endif

If lContinue
    // Marco como deletado os registros já conciliados na tabela QLC
    cQueryQLC :=  " UPDATE "+RetSQLName("QLC")+" "
    cQueryQLC +=  " SET D_E_L_E_T_ = '*' , "
    cQueryQLC +=  "     R_E_C_D_E_L_ = R_E_C_N_O_ "
    cQueryQLC +=  "     WHERE QLC_FILIAL = '" +xFilial("QLC")+ "' "
    cQueryQLC +=  "         AND QLC_CODCFG = '"+ cCodCfg+ "' "
    cQueryQLC +=  "         AND QLC_CODCON = '"+ cCodCon + "' "
    cQueryQLC +=  "         AND D_E_L_E_T_ = ' ' "
    cQueryQLC +=  "         AND ( "
    cQueryQLC +=  "         SELECT COUNT(*) AS COUNTITEMS FROM "+RetSQLName("QLD")+" "
    cQueryQLC +=  "         WHERE QLD_FILIAL = '" +xFilial("QLD")+ "' "
    cQueryQLC +=  "             AND QLD_CODCON = '"+ cCodCon+ "' "
    cQueryQLC +=  "             AND QLD_CODCFG = '"+ cCodCfg + "' "
    cQueryQLC +=  "             AND D_E_L_E_T_ = ' ' "
    cQueryQLC +=  "         ) < 1 "

    If TcSqlExec(cQueryQLC) <> 0
        Conout(TCSqlError())
        cError += STR0002+"QLC" //"Tabela: "
        lContinue := .F.
    EndIf
EndIf

If !lContinue
    cError += STR0003+" "+cCodCon+" "+STR0004  //""DeleteReconciliationHeader Erro: Nao foi possivel deletar a conciliação:"
EndIf

Return lContinue

/*/{Protheus.doc} execDeleteFin
    Executa os updates nas tabelas de origem e destino para
    desmarcar os matches das conciliações financeiras
    @author Vitor Duca
    @since 27/02/2025
    @version 1.0
    @param cCodCon, character, Codigo da conciliação QLC_CODCON
    @param cCodCfg, character, Codigo da regra QLC_CODCFG
    @param aIDs, array, Matriz contendo os ID's enviados na requisição
    @return void
/*/
Method execDeleteFin(cCodCon as character, cCodCfg as character, aIDs as array) class DeleteReconciliationHeaderProtheusData
    local cQuery := ""  as character
    local cTmpTbl := "" as character
    local oPrepareStatement as Object
    local cError := ""  as character
    local lItensSelected := .F. as logical
    local nParam := 1   as numeric
    local aRecFK5 := {} as array
    local aRecSIG := {} as array
    local cNameDB := ALLTRIM(tcGetdb()) as character
    local nID := 0 as numeric

    lItensSelected := ValType(aIDs) == "A" .And. len(aIDs) > 0

    If lItensSelected .and. cNameDB $ "POSTGRES" 
        For nID := 1 to len(aIDs)
            aIDs[nID] := Lower(aIDs[nID])
        next
    Endif

    cQuery := "SELECT QLD_UNION UNIONMAT, FK5.R_E_C_N_O_ RECNOFK5, SIG.R_E_C_N_O_ RECNOSIG "
    cQuery += "FROM " + retSqlName("QLD") + " QLD "
    cQuery += "LEFT JOIN " + retSqlName("FK5") + " FK5 ON "

    If cNameDB $ "POSTGRES"
        cQuery += "QLD.QLD_IDITEM = CAST(FK5.FK5_MSUIDT AS VARCHAR) "
    Else
        cQuery += "RTRIM(QLD.QLD_IDITEM) = FK5.FK5_MSUIDT "
    EndIf

    cQuery += "AND FK5.D_E_L_E_T_ = ? "
    cQuery += "LEFT JOIN " + retSqlName("SIG") + " SIG ON "

    If cNameDB $ "POSTGRES"
        cQuery += "QLD.QLD_IDITEM = CAST(SIG.IG_MSUIDT AS VARCHAR) "
    Else
        cQuery += "RTRIM(QLD.QLD_IDITEM) = SIG.IG_MSUIDT "
    EndIf

    cQuery += "AND SIG.D_E_L_E_T_ = ? "
    cQuery += "WHERE QLD.QLD_FILIAL ? "
    cQuery += "AND QLD.QLD_CODCON = ? "
    cQuery += "AND QLD.QLD_CODCFG = ? "

    If lItensSelected
        cQuery += "AND QLD.QLD_IDITEM IN (?) "
    Endif
    
    cQuery += "AND QLD.D_E_L_E_T_ = ? "

    oPrepareStatement := FWExecStatement():New(cQuery)
    oPrepareStatement:SetString(nParam++, " ") //FK5.D_E_L_E_T_
    oPrepareStatement:SetString(nParam++, " ") //SIG.D_E_L_E_T_
    oPrepareStatement:SetUnsafe(nParam++, FinSelFil(GetListOfProfileBranchies("QLD"), "QLD", .F., .T., 150)) //QLD.QLD_FILIAL
    oPrepareStatement:SetString(nParam++, cCodCon) //QLD.QLD_CODCON
    oPrepareStatement:SetString(nParam++, cCodCfg) //QLD.QLD_CODCFG

    If lItensSelected
        oPrepareStatement:SetIn(nParam++, aIDs) //QLD.QLD_IDITEM
    Endif

    oPrepareStatement:SetString(nParam++, " ") //QLD.D_E_L_E_T_

    cTmpTbl := oPrepareStatement:openAlias()

    While (cTmpTbl)->(!Eof())

        If (cTmpTbl)->UNIONMAT == "SIG"
            Aadd(aRecSIG, (cTmpTbl)->RECNOSIG)
        Else
            Aadd(aRecFK5, (cTmpTbl)->RECNOFK5)
        Endif

        (cTmpTbl)->(DbSkip())
    EndDo

    (cTmpTbl)->(DbCloseArea())

    F475PosCan(;
        cCodCon,; //Processo de Conciliação no TOTVS Conciliador (QLC/QLD)
        cCodCfg,; //Código da regra de conciliação (0023/0024)
        "",; //Codigo identificador do match (QLD_REGMAT)
        "",; //Sequencial no identificador do match (QLD_SEQMAT)
        "",; //RealName da tabela temporária que contém os registros FK5 (DESTINO) ou SIG (ORIGEM)
        "",; //UUID do registro para cancelamento match (0024)
        @cError,; //Utilizado para devolver ao FRONT o erro caso ocorra.
        .T.,; //Define se quem esta chamando é o gerenciar conciliações
        aRecFK5,; //Recnos dos movimentos que serão utilizados no cancelamento da conciliação
        aRecSIG; //Recnos dos itens do extrato que serão utilizados no cancelamento da conciliação
    )
    
Return

/*/{Protheus.doc} isConfigFin
    Define se quem esta realizando o cancelamento da conciliação é uma configuração
    financeira
    @author Vitor Duca
    @since 03/06/2025
    @version 1.0
    @param cCodCfg, character, Codigo da regra QLC_CODCFG
    @return lCfgFin, logical, Retorna se a regra é financeira ou não
/*/
Method isConfigFin(cCodCfg as Character) As Logical class DeleteReconciliationHeaderProtheusData
    Local lCfgFin := cCodCfg $ '0023|0024'  As Logical
    Local aAreaQLB := {}                    As Array

    If !lCfgFin .and. QLB->(FieldPos("QLB_CFGORI")) > 0
        aAreaQLB := QLB->(FwGetArea())

        If QLB->(DbSeek(FwXFilial("QLB") + Padr(cCodCfg, TamSx3("QLB_CODCFG")[1] )))
            lCfgFin := QLB->QLB_CFGORI $ '0023|0024'
        Endif

        FwRestArea(aAreaQLB)
    Endif

return lCfgFin

//-------------------------------------------------------------------
/*/{Protheus.doc} RetUUIDTMP
Retorna o UUID da tabela TMP

@author TOTVS
@since 24/06/2024
@version 12
@param
/*/
//-------------------------------------------------------------------
Static Function RetUUIDTMP(cQLDFil,cQLDIn,cCodCon,cCodCfg,lDelItens)

    Local cIDsTMP    := GetNextAlias() as Character
    Local cNameDB    := Alltrim(TcGetDB()) as Character
    Local cQryIn     := ""
    Local aUUIDTMP   := {} as Array
    Local cUUIDCompare 	:= "" as Character
    Local nLimitIN  	:= 0  as Numeric

    // Em oracle o campo CT2_MSUIDT possui 32 posições, necessário tirar os espaços do campo QLD_IDITEM (36 posições)
    // para usar esta subconsulta comparando com os campos de UUID
    cQryIn := Iif(cNameDB == "ORACLE", " SELECT RTRIM(QLD_IDITEM) IDITEM "," SELECT QLD_IDITEM IDITEM " )

    cQryIn += " FROM "+RetSQLName("QLD")+" QLD "
    cQryIn += " WHERE "+cQLDFil+" "

    //Quando a exclusão é por item, selecionar apenas os IDs envolvidos na exclusão
    If lDelItens
        cQryIn += " AND QLD.QLD_IDITEM IN "+cQLDIn+" "
    EndIf

    cQryIn += " AND QLD.QLD_CODCON = '"+cCodCon+"' "
    cQryIn += " AND QLD.QLD_CODCFG = '"+cCodCfg+"' "
    cQryIn += " AND QLD.D_E_L_E_T_ = ' ' "

    dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQryIn),cIDsTMP,.T.,.T.)

    // Separo os IDs e guardo na variável aUUIDTMP
    nLimitIN := 0
    While !(cIDsTMP)->(Eof())

        IIf(nLimitIN > 999, (aAdd(aUUIDTMP,""), aUUIDTMP[Len(aUUIDTMP)] := cUUIDCompare, cUUIDCompare := "", nLimitIN := 0), 0)

		If !Empty(cUUIDCompare)
			cUUIDCompare += ", "
		EndIf

		cUUIDCompare+= "'"+AllTrim((cIDsTMP)->(IDITEM))+"'"
		nLimitIN++

        (cIDsTMP)->(dbSkip())
    EndDo
    (cIDsTMP)->(dbCloseArea())

    If !Empty(cUUIDCompare)
		aAdd(aUUIDTMP,"")
		aUUIDTMP[Len(aUUIDTMP)] := cUUIDCompare
		cUUIDCompare := ""
	EndIf

Return aUUIDTMP
