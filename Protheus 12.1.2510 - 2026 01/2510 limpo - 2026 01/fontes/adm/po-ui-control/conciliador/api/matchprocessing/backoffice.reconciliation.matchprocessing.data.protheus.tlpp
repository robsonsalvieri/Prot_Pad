#include "tlpp-core.th"
#include "totvs.ch"
#include "backoffice.reconciliation.matchprocessing.data.protheus.ch"

namespace totvs.protheus.backoffice.reconciliation.matchprocessing
using namespace totvs.protheus.backoffice.reconciliation.util

static nTamRegMat
static nTamSeqMat
static nTamDesMat
static nTamCodcon
static _lPostgres
static _lOracle
static _nTamUUID := 36 //Fixo para remover RTRIM da regra de match
static _lCpoIdCOnc
static _lMVIdConc
static _cCpoEntidades
static _nTamCT2_DC
static nTamCodCfg
static nTamTipMat := 2
static nTamCompar := 2
static _nTamPref
static _nTamNum
static _ntamParc
static _nTamTipo
static _nTamCli
static _nTamLoja
static _oQryFK5
static _lFk5Fk7
static nTamF2DVal := 14
static nDecF2DVal := 2
static nTamF2DTrib := 6
static _lCpoCfgTrb

//-------------------------------------------------------------------
/*/{Protheus.doc} MatchProcessingProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class MatchProcessingProtheusData from FWAdapterBaseV2
    private Data cCfgOri   as Character
    private Data cCodCfg   as Character

    Public  method new()
    Public  method postByBody()
    Public  method tcRetWhere()
    Public  method tcRetSQLExpression()
    Public  method tcGetConditionalQuery()
    Private method tcPrepareTemp()
    Private method tcExecSQLExpress()
    Private method tcRetTable()
    Private method tcCriaProcMatch()
    Private method tcChavtoVar()
    Private method tcCondtoVar()
    Private method tcProcMatch()
    Private method tcProcDeclare()
    Private method tcCondUpdate()
    Private method tcLoadTamSX()
    Private method tcQueryUnion()
    Private method tcRetQuery()
    Private method tcRetSelectUnion()
    Private method tcRetUnion()
    Private method tcValidFields()
    Private method tcConditionalQuery()
    Private method tcCheckReconciliation() as logical
    Private method tcFillTaxValues()

    Static  method getData() As object
endclass

/*/{Protheus.doc} MatchProcessingProtheusData
Metodo construtor

@author Totvs
/*/
method new(cVerbo, lList) Class MatchProcessingProtheusData
    Default cVerbo := "POST"
    Default lList  := .T.
    ::cCodCfg      := ""
    ::cCfgOri      := ""
    _Super:New(cVerbo, lList)
return

/*/{Protheus.doc} MatchProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
method getData() class MatchProcessingProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := MatchProcessingProtheusData():new()
    EndIf
return __oActiveData

/*/{Protheus.doc} getByBody
Metodo responsável pela busca das configuracoes de acordo com as filiais
informadas

@author Totvs
/*/
method postByBody(jBody as Json) class MatchProcessingProtheusData
Local cReturn := "" as Character
Local cTableOri := "" as Character
Local cTableDes := "" as Character
Local lProgress as logical
Local aResponse := {} as Array

cReturn := ::tcPrepareTemp(jBody,@lProgress,@cTableOri,@cTableDes)

If lProgress
    aAdd(aResponse, .T.)
    aAdd(aResponse, '{"tabori": "'+cTableOri+'", "tabdes": "'+cTableDes+'"}')
Else
    aAdd(aResponse, .F.)
    aAdd(aResponse, cReturn)
Endif

return aResponse

/*/{Protheus.doc} prepareTemp
    Prepare temp table for use
    @author TOTVS
    @since 29/07/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method tcPrepareTemp(jBody as Json,lProgress as Logical, cTableOri as Character, cTableDes as Character) class MatchProcessingProtheusData
Local cCodCfg      := ""                 as Character
Local jHeaders     := JsonObject():New() as Json
Local jRegrasMatch := JsonObject():New() as Json
Local jUnion       := JsonObject():New() as Json
Local jTotal       := JsonObject():New() as Json
Local jCfgTrib     := JsonObject():New() as Json
Local cAliasOri    := ""                 as Character
Local cAliasDes    := ""                 as Character
Local cSQLSelOri   := ""                 as Character
Local cSQLSelDes   := ""                 as Character
Local cWhereOri    := ""                 as Character
Local cWhereDes    := ""                 as Character
Local cError       := ""                 as Character
Local cReturn      := ""                 as Character
Local cCpoIdOri    := ""                 as Character
Local cCpoIdDes    := ""                 as Character
Local cView        := ""                 as Character
Local cOriLink     := ""                 as Character
Local cDesLink     := ""                 as Character
Local cCondition   := ""                 as Character
Local cBDname      := Upper( TCGetDB() ) as Character
Local lAutomato    := .F.                as Logical
Local uRet                               as variant
Local cMatchOrd    := ""                 as Character
Local nI           := 0                  as Numeric
Local lCfgTrib     := .F.                as Logical

DEFAULT cTableOri := ""
DEFAULT cTableDes := ""

cCodCfg   := jBody["codcfg"]
cView     := If(Valtype(jBody["view"]) == "C", jBody["view"], "0")
lAutomato := (ValType(jBody["robo"])<>"U")
lProgress := ValType(cCodCfg)=="C"

If _lPostgres == NIL
    _lPostgres := Alltrim(cBDname) $ "POSTGRES"
EndIf

If _lOracle == Nil
    _lOracle := Alltrim(cBDname) $ "ORACLE"
Endif

If _lMVIdConc == NIL
    _lMVIdConc :=  (SuperGetMV("MV_FILCONC", .F., "1")=="1")
EndIf

If _lCpoIdCOnc == NIL
    _lCpoIdCOnc := CT2->(FieldPos("CT2_IDCONC"))>0 .And. _lMVIdConc
EndIf

If _lCpoCfgTrb == NIL
    _lCpoCfgTrb := QLB->(FieldPos("QLB_CFGTRB")) > 0 .And. FWAliasInDic("F2D", .F.)
EndIf

If lProgress
    QLB->(dbSetOrder(1))
    If QLB->(dbSeek(FWxFilial("QLB")+cCodCfg))
        ::cCodCfg := cCodCfg
        uRet      := jHeaders:FromJson(AllTrim(QLB->QLB_FIELDS))
        lProgress := ValType(uRet) == "U"

        //Monta o Select da Query
        If lProgress
            If QLB->(FieldPos("QLB_CFGORI")) > 0
                ::cCfgOri := QLB->QLB_CFGORI
            Endif
            cAliasOri := QLB->QLB_TABORI
            cAliasDes := QLB->QLB_TABDES

            If (lProgress := ::tcCheckReconciliation(@cReturn, jBody))
                If Empty(QLB->QLB_CIDORI)
                    lProgress := .F.
                Else
                    cCpoIdOri := QLB->QLB_CIDORI
                EndIf

                If Empty(QLB->QLB_CIDDES)
                    lProgress := .F.
                Else
                    cCpoIdDes := QLB->QLB_CIDDES
                EndIf

                If lProgress
                    uRet := jRegrasMatch:FromJson(AllTrim(QLB->QLB_REGMAT))
                    jTotal:FromJson(AllTrim(QLB->QLB_TOTAL))
                    lProgress := ValType(uRet) == "U"
                EndIf

                If lProgress
                    //Validacao de campos para query
                    ::tcValidFields(jHeaders, jRegrasMatch, cAliasDes)

                    If QLB->(FieldPos("QLB_TABGRP")) > 0
                        jUnion:fromJson(AllTrim(QLB->QLB_TABGRP))
                    EndIf

                    // CFGTRIB -> Por enquanto este atributo esta no QLB_FIELDS
                    If _lCpoCfgTrb 
                        uRet  := jCfgTrib:FromJson(AllTrim(QLB->QLB_CFGTRB))
                        lCfgTrib := ValType(uRet) == "U" .And. (jCfgTrib:hasProperty("tribori") .And. jCfgTrib:hasProperty("tribdes"))
                    EndIf
                    If lCfgTrib .And. _lCpoCfgTrb
                        // Se o campo de link entre F2D e tabori não estiver na configuração, adicionar automaticamente
                        If !Empty(jCfgTrib["tribori"]["idfield"]) 
                            If !(jUnion["unionori"] <> NIL .and. !Empty(jUnion["unionori"]))
                                If aScan(jHeaders["data_ori"], {|x| x = jCfgTrib["tribori"]["idfield"]}) == 0
                                    aAdd(jHeaders["data_ori"], jCfgTrib["tribori"]["idfield"])
                                EndIf
                            EndIf
                        EndIf

                        // Se o campo de link entre F2D e tabdes não estiver na configuração, adicionar automaticamente
                        If !Empty(jCfgTrib["tribdes"]["idfield"]) .And.;
                         aScan(jHeaders["data_des"], {|x| x = jCfgTrib["tribdes"]["idfield"]}) == 0
                            aAdd(jHeaders["data_des"], jCfgTrib["tribdes"]["idfield"])
                        EndIf

                    Else
                        //JSON vazio, apenas para não causar erro na passagem como parâmetro
                        jCfgTrib:FromJson('{"tribori":{"idfield":"","col_taxes":[]},"tribdes":{"idfield":"","col_taxes":[]}}')
                    EndIf

                    If jUnion["unionori"] <> NIL  .and. !Empty(jUnion["unionori"])
                        cSQLSelOri := ::tcQueryUnion(cCodCfg, '1', cCpoIdOri, cAliasOri, cView, jUnion["unionori"], jHeaders['data_ori'], jBody, @cMatchOrd, jCfgTrib["tribori"]["col_taxes"], jCfgTrib["tribori"]["idfield"])
                    Else
                        cSQLSelOri := ::tcRetQuery(cCodCfg, jHeaders, cCpoIdOri, cAliasOri, '1', jCfgTrib["tribori"]["col_taxes"])
                    EndIf

                    If jUnion["uniondes"] <> NIL .and. !Empty(jUnion["uniondes"])
                        cSQLSelDes := ::tcQueryUnion(cCodCfg, '2', cCpoIdDes, cAliasDes, cView, jUnion["uniondes"], jHeaders['data_des'], jBody)
                    Else
                        cSQLSelDes := ::tcRetQuery(cCodCfg, jHeaders, cCpoIdDes, cAliasDes, '2', jCfgTrib["tribdes"]["col_taxes"])
                    EndIf
                Else
                    cReturn := STR0001 //"Preencher o campo QLB_CIDORI ou QLB_CIDDES"
                EndIf
            Endif

            If lProgress
                For nI := 1 to Len(jRegrasMatch["rules"])
                    //A validação é feita somente quando existe tabela de link = CV3 e se o RTRIM() é utilizado nos campos de UUID
                    If jRegrasMatch["rules"][nI]["rule"]["ori_link"] <> NIL
                        cOriLink   := Upper(jRegrasMatch["rules"][nI]["rule"]["ori_link"])
                    EndIf

                    If jRegrasMatch["rules"][nI]["rule"]["des_link"] <> NIL
                        cDesLink   := Upper(jRegrasMatch["rules"][nI]["rule"]["des_link"])
                    EndIf

                    If jRegrasMatch["rules"][nI]["rule"]["condition"] <> NIL
                        cCondition := Upper(jRegrasMatch["rules"][nI]["rule"]["condition"])
                    EndIf

                    If  "RTRIM(CV3_ID" $ cOriLink  .Or.;
                        "RTRIM(CV3_ID" $ cDesLink  .Or.;
                        "RTRIM(CV3_ID" $ cCondition

                        If !Empty(cOriLink)
                            cOriLink := StrTran(cOriLink,"RTRIM(CV3_IDORIG)","CV3_IDORIG")
                            cOriLink := StrTran(cOriLink,"RTRIM(CV3_IDDEST)","CV3_IDDEST")
                            jRegrasMatch["rules"][nI]["rule"]["ori_link"]  := cOriLink
                        EndIf

                        If !Empty(cDesLink)
                            cDesLink := StrTran(cDesLink,"RTRIM(CV3_IDORIG)","CV3_IDORIG")
                            cDesLink := StrTran(cDesLink,"RTRIM(CV3_IDDEST)","CV3_IDDEST")
                            jRegrasMatch["rules"][nI]["rule"]["des_link"]  := cDesLink
                        EndIf

                        If !Empty(cCondition)
                            cCondition := StrTran(cCondition,"RTRIM(CV3_IDORIG)","CV3_IDORIG")
                            cCondition := StrTran(cCondition,"RTRIM(CV3_IDDEST)","CV3_IDDEST")
                            jRegrasMatch["rules"][nI]["rule"]["condition"] := cCondition
                        EndIf

                    EndIf
                Next nI
            EndIf
        Else
            cReturn := STR0002 //"Campo QLB_FIELDS incorreto no cadastro"
        EndIf

        //Monta o Where de acordo com o filtro recebido
        If lProgress
            If (jUnion["unionori"] == NIL .or. Empty(jUnion["unionori"]))
                cWhereOri := ::tcRetWhere(jBody["tabori"], cView, "1", cAliasOri,"01", cCpoIdOri, ,cCodCfg,::tcGetConditionalQuery(jRegrasMatch,"tabori"))
            EndIf

            If (jUnion["uniondes"] == NIL .or. Empty(jUnion["uniondes"]))
                cWhereDes := ::tcRetWhere(jBody["tabdes"], cView, "2", cAliasDes,"01", cCpoIdDes, ,cCodCfg,::tcGetConditionalQuery(jRegrasMatch,"tabdes"))
            EndIf

            //Monta as temporárias
            cError := ::tcExecSQLExpress(cSQLSelOri+cWhereOri,@cTableOri,lAutomato,.T.,cCpoIdOri, jCfgTrib["tribori"])
            If Empty(cError)
                cError += ::tcExecSQLExpress(cSQLSelDes+cWhereDes,@cTableDes,lAutomato,,cCpoIdDes, jCfgTrib["tribdes"])
                If !Empty(cError)
                    cError += tcDropTable(cTableOri)
                    lProgress := .F.
                    cReturn := cError
                Else
                    cError := ::tcProcMatch(cAliasOri,cAliasDes,cTableOri,cTableDes,cCpoIdOri,cCpoIdDes,jRegrasMatch,cMatchOrd,jTotal)
                    If !Empty(cError)
                        cReturn := cError
                        lProgress := .F.
                    EndIf
                EndIf
            Else
                lProgress := .F.
                cReturn := cError
            EndIf
        EndIf
    Else
        lProgress := .F.
        cReturn := STR0003 //"A configuracao informada não existe"
    EndIf
Else
    cReturn := STR0004 //"Propriedade codcfg não informada ou inválida"
EndIf

Return cReturn

/*/{Protheus.doc} tcRetSQLExpression
    @author TOTVS
    @since 29/07/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method tcRetSQLExpression(aSQLArr as Array, cSeparator as Character, cCpoIDCon as Character,;
                            lCabec as Logical, lExcel As logical, cAlias as Character, cCodCfg as Character, aTaxes as Array) class MatchProcessingProtheusData
Local cRet        := "" as Character
Local cConcat     := "" as Character
Local nI          := 0  as Numeric
Local cMeusCpos   := "" as Character
Local lConcilBanc := .F.

DEFAULT aSQLArr    := {}
DEFAULT cSeparator := ""
DEFAULT cCpoIDCon  := ""
DEFAULT lCabec     := .F.
DEFAULT lExcel     := .F.
DEFAULT cAlias     := ""
DEFAULT cCodCfg    := ""
DEFAULT aTaxes     := {} //CFGTRIB

IF ("IG" $ cCpoIDCon .or. "FK5" $ cCpoIDCon) .and. !lExcel
    cMeusCpos := "E5_PREFIXO|E5_NUMERO|E5_PARCELA|E5_TIPO|E5_CLIFOR|E5_LOJA|E5_CREDITO"
    lConcilBanc := .T.
Endif

cConcat :=  tcRetConcat()

If !lCabec
    tcProcessLGPD(aSQLArr)
EndIf

For nI := 1 to Len(aSQLArr)
    If !(cCpoIDCon $ aSQLArr[nI] )
        If nI > 1
            cRet += cSeparator
        EndIf
        If aSQLArr[nI]  $ cMeusCpos
            cRet += " ' ' "+ aSQLArr[nI]
        Else
            cRet += aSQLArr[nI]
        Endif
    Endif
Next

If !Empty(cRet) .And. !Empty(cCpoIDCon)
    cRet += cSeparator+"COALESCE(CAST("+cCpoIDCon+" AS VARCHAR("+cValToChar(_nTamUUID)+")), ' ') "+cCpoIDCon
EndIf

If !lExcel
    If lCabec
        If "CT2"$cCpoIDCon .And. _lCpoIdCOnc
            cRet += cSeparator+" CT2_IDCONC "
        EndIf
        cRet += cSeparator+" TABELA "
        cRet += cSeparator+" REGMATCH "
        cRet += cSeparator+" DESMATCH "
        cRet += cSeparator+" SEQMATCH "
        cRet += cSeparator+" CODCON "
        cRet += cSeparator+" IDDELETE "
        cRet += cSeparator+" RECONCILED "
        cRet += cSeparator+" IDMATCH "
        cRet += cSeparator+" COMPARISON "
        cRet += cSeparator+" CODCFG "
        cRet += cSeparator+" TYPEMATCH "

        If _lCpoCfgTrb .And. !lConcilBanc .And. ValType(aTaxes) == "A" .And. Len(aTaxes) > 0 //CFGTRIB
            For nI := 1 to Len(aTaxes)
                //Adicionar o marcador T_ + field + __ + taxname -> Para evitar colunas duplicadas
                cRet += cSeparator+" T_"+aTaxes[nI]["field"] + " "
            Next nI
        EndIf

    Else
        ::tcLoadTamSX()

        If "CT2"$cCpoIDCon .And. _lCpoIdCOnc
            cRet += cSeparator+" CT2_IDCONC "
        EndIf
        cRet += cSeparator+" '"+cAlias+"' TABELA "
        cRet += cSeparator+" COALESCE(QLD_REGMAT,'"+Space(nTamRegMat)+"') REGMATCH "
        cRet += cSeparator+" COALESCE(QLD_DESMAT,'"+Space(nTamDesMat)+"') DESMATCH "
        cRet += cSeparator+" COALESCE(QLD_SEQMAT,'"+Space(nTamSeqMat)+"') SEQMATCH "
        cRet += cSeparator+" COALESCE(QLD_CODCON,'"+Space(ntamCodCon)+"') CODCON "
        cRet += cSeparator+" '"+Space(nTamRegMat+nTamSeqMat)+"' IDDELETE "

        // O Conciliador ira validar se o registro já foi conciliado em outra configuração de conciliação e o registro não será disponibilizado para conciliação.
        If _lMVIdConc
            cRet += cSeparator+" CASE WHEN QLD_SEQMAT <> '"+Space(nTamSeqMat)+"' THEN 'S' ELSE 'N' END RECONCILED "
        Else // O Conciliador não ira realizar a validação, e disponibilizará o registro para ser conciliado, mesmo que ele já tenha sido conciliado em outra configuração de conciliação.
            cRet += cSeparator+" CASE WHEN QLD_SEQMAT <> '"+Space(nTamSeqMat)+"' AND QLD_CODCFG <> '"+cCodCfg+"' THEN 'N' WHEN QLD_SEQMAT <> '"+Space(nTamSeqMat)+"' THEN 'S' ELSE 'N' END RECONCILED "
        EndIf
        cRet += cSeparator+" COALESCE(QLD_REGMAT " + cConcat + " QLD_SEQMAT, '"+Space(nTamRegMat+nTamSeqMat)+"') IDMATCH "

        If QLD->(FieldPos("QLD_COMPAR")) > 0
            cRet += cSeparator+" CASE WHEN QLD_COMPAR = 'AD' THEN 'AD' WHEN QLD_COMPAR = 'MD' THEN 'MD' ELSE 'N' END COMPARISON "
        Else
            cRet += cSeparator+" ' ' COMPARISON "
        EndIf
		cRet += cSeparator+" COALESCE(QLD_CODCFG,'"+Space(ntamCodCfg)+"') CODCFG "

        cRet += cSeparator+" "
        If QLD->(FieldPos("QLD_TIPMAT")) > 0
            cRet += " CASE WHEN COALESCE(QLD_TIPMAT,'"+Space(nTamTipMat)+"') <> '"+Space(nTamTipMat)+"' THEN COALESCE(QLD_TIPMAT,'"+Space(nTamTipMat)+"') ELSE "
        Endif

        If _lPostgres
            cRet += "CAST( "
        EndIf

        cRet += "CASE "
        If QLD->(FieldPos("QLD_COMPAR")) > 0
            cRet += " WHEN QLD_COMPAR = 'AD' THEN 'AD'" // Automático Divergente
            cRet += " WHEN QLD_COMPAR = 'MD' THEN 'MD'" // Manual Divergente
        Endif
        cRet += " WHEN COALESCE(QLD_REGMAT,'"+Space(nTamRegMat)+"') = '"+Replicate("9", nTamRegMat)+"' THEN 'M' "
        cRet += " WHEN COALESCE(QLD_REGMAT,'"+Space(nTamRegMat)+"') = '"+Replicate("9", (nTamRegMat - 1)) + "8" +"' THEN 'I'"
        cRet += " WHEN COALESCE(QLD_REGMAT,'"+Space(nTamRegMat)+"') <> '"+Space(nTamRegMat)+"' THEN 'A'"
        cRet += " ELSE ' ' END "

        If _lPostgres
            cRet += " AS CHAR(2))"
        EndIf

        If QLD->(FieldPos("QLD_TIPMAT")) > 0
            cRet += " END "
        Endif

        cRet += " TYPEMATCH "

        If _lCpoCfgTrb .And. !lConcilBanc .And. ValType(aTaxes) == "A" .And. Len(aTaxes) > 0 //CFGTRIB
            For nI := 1 to Len(aTaxes)
                //Adicionar o marcador T_ + field 
                cRet += cSeparator+" 0 T_"+aTaxes[nI]["field"]+" "
            Next nI
        EndIf
    EndIf
Else
    If _lCpoCfgTrb .And. !lConcilBanc .And. ValType(aTaxes) == "A" .And. Len(aTaxes) > 0 //CFGTRIB com Excel
            For nI := 1 to Len(aTaxes)
                //Adicionar o marcador T_ + field 
                cRet += cSeparator+" T_"+aTaxes[nI]["field"]+" "
            Next nI
    EndIf
EndIf

Return cRet

/*/{Protheus.doc} tcRetWhere
    @author TOTVS
    @since 30/07/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method tcRetWhere(aWhereArr as Array, cView as Character, cTipItem as Character, cAliasQry as Character,;
                  cMoedaLC as Character, cCpoUUID as Character, jFilters as Json, cCodCfg as Character, aConditionalQuery as Array) class MatchProcessingProtheusData
Local cType       := ""   as Character
Local cWhere      := ""   as Character
Local cCampo      := ""   as Character
Local cReturn     := ""   as Character
Local cSubStr     := ""   as Character
Local nI          := 0    as Numeric
Local nX          := 0    as Numeric
Local nTamArray   := 0    as Numeric
Local aValue      := {}   as Array
Local uValue              as variant
Local cTempTable  := ""   as Character
Local cCondBranch := GetBranchiesForConditional(cAliasQry) as Character
Local cQLDFil     := GetBranchiesForConditional("QLD")     as Character
Local cBDname     := Upper( TCGetDB() )                    as Character

DEFAULT aWhereArr         := {}
DEFAULT cView             := "0"
DEFAULT cTipItem          := ""
DEFAULT cAliasQry         := ""
DEFAULT cMoedaLC          := ""
DEFAULT cCpoUUID          := ""
DEFAULT cCodCfg           := ""
DEFAULT aConditionalQuery := {}

// As variáveis estaticas estarão com conteúdo nulo quando o metodo tcRetWhere
// for chamado de outras classes que instanciam a matchprocessing
If _lPostgres == NIL
    _lPostgres := (Alltrim(cBDname) $ "POSTGRES")
EndIf

If _lOracle == NIL
    _lOracle := (AllTrim(cBDname) $ "ORACLE")
EndIf

If _lMVIdConc == NIL
    _lMVIdConc :=  (SuperGetMV("MV_FILCONC", .F., "1")=="1")
EndIf

If _lCpoIdCOnc == NIL
    _lCpoIdCOnc := CT2->(FieldPos("CT2_IDCONC"))>0 .And. _lMVIdConc
EndIf

If _lCpoCfgTrb == NIL
    _lCpoCfgTrb := QLB->(FieldPos("QLB_CFGTRB")) > 0 .And. FWAliasInDic("F2D", .F.)
EndIf

cTempTable  := If(cTipItem == "1", "TEMPORI", "TEMPDES")
cSubStr := If(_lOracle, "SUBSTR", "SUBSTRING")

If cAliasQry == "CT2"
    cWhere += RetWhereEntity(aWhereArr)
EndIf

For nI := 1 to Len(aWhereArr)
    uValue      := aWhereArr[nI]["value"]
    cType       := aWhereArr[nI]["type"]
    cCampo      := aWhereArr[nI]["field"]
    cOperation  := UPPER(aWhereArr[nI]["operation"])
    cIdQuery    := aWhereArr[nI]["idquery"]  // Id da query complementar

    If jFilters <> NIL .And.  jFilters[cCampo] <> NIL
        cCampo := jFilters[cCampo]
    EndIf

    If cOperation != "QUERY" .and. (Empty(cCampo) .Or. &(cAliasQry)->(FieldPos(cCampo))==0)  //aqui kco
        Loop
    EndIf

    If Empty(uValue) .And. (cType == 'D' .Or. cType == 'C') .And. cOperation <> "IN" .And. cOperation <> "NOT IN"
        uValue := " "
    EndIf

    If ValType(uValue) == "C" .And. !Empty(uValue)
        uValue := tcClearSql(uValue) // Limpeza de comandos de SQL
    EndIf

    If cAliasQry == "CT2" .And. IsEntity(cCampo)
        Loop
    EndIf

    //Query complementar
    If cOperation == "QUERY" .and. !Empty(aConditionalQuery)
        uValue :=  If(ValType(uValue) != "L", .F., uValue)
        If uValue // .T. = Executa a ConditionalQuery
            ::tcConditionalQuery(aConditionalQuery, cIdQuery, @cWhere )
        Endif

    ElseIf cOperation <> "IN" .And. cOperation <> "NOT IN"
        If cType == "N"
            If ValType(uValue) == "C"
                uValue := Val(uValue)
            EndIf

            If uValue > 0
                If !Empty(cWhere)
                    cWhere += " AND "
                EndIf
                cWhere += cCampo
                cWhere += cOperation
                cWhere += cValToChar(uValue)
            EndIf
        Else
            If !Empty(cWhere)
                cWhere += " AND "
            EndIf

            If cType == "D"
                uValue := StrTran(uValue,"-","")
            ElseIf cType == "L"
                uValue := If(uValue,"T","F")
            EndIf

            cWhere += cCampo
            cWhere += " "
            cWhere += cOperation
            cWhere += "'"+uValue+"'"
        EndIf

    ElseIf cOperation == "IN"
        If cType == "N"
            If !Empty(uValue)
                If !Empty(cWhere)
                    cWhere += " AND "
                EndIf

                cWhere += cCampo
                cWhere += " "
                cWhere += cOperation

                // Segundo parâmetro de StrRTokArr esta como " ,"
                // para que a função entenda que tanto a virgula como o espaço sejam vistos como separadores em campos numéricos
                aValue := StrTokArr( uValue , " ,")
                nTamArray := Len(aValue)
                uValue := ""
                For nX := 1 to nTamArray

                    If AllTrim(aValue[nX]) == CValToChar(Val(aValue[nX]))
                        uValue += ""+AllTrim(aValue[nX])+""
                        If nX < nTamArray
                            uValue += ","
                        EndIf
                    EndIf
                Next

                cWhere += "("+uValue+")"

            EndIf

        ElseIf cType == "C"

            If Empty(uValue) .And. cCampo == "CT2_LOTE"                
                cWhere += " AND CT2_LOTE <> ' ' "  //Força a inserção do campo CT2_LOTE na query, pois faz parte do índice                
            ElseIf !Empty(uValue)
                If !Empty(cWhere)
                    cWhere += " AND "
                EndIf

                cWhere += cCampo
                cWhere += " "
                cWhere += cOperation

                If cType == "C"

                    aValue := StrTokArr( uValue , ",")
                    nTamArray := Len(aValue)
                    uValue := ""
                    For nX := 1 to nTamArray
                        uValue += "'"+AllTrim(aValue[nX])+"'"
                        If nX < nTamArray
                            uValue += ","
                        EndIf
                    Next

                    cWhere += "("+uValue+")"

                EndIf
            EndIf
        EndIf
    elseIf cOperation == "NOT IN" // Implementação da condição de não esta contido em
        If cType == "N"
            If !Empty(uValue)
                If !Empty(cWhere)
                    cWhere += " AND "
                EndIf

                cWhere += cCampo
                cWhere += " "
                cWhere += cOperation

                // Segundo parâmetro de StrRTokArr esta como " ,"
                // para que a função entenda que tanto a virgula como o espaço sejam vistos como separadores em campos numéricos
                aValue := StrTokArr( uValue , " ,")
                nTamArray := Len(aValue)
                uValue := ""
                For nX := 1 to nTamArray

                    If AllTrim(aValue[nX]) == CValToChar(Val(aValue[nX]))
                        uValue += ""+AllTrim(aValue[nX])+""
                        If nX < nTamArray
                            uValue += ","
                        EndIf
                    EndIf
                Next

                cWhere += "("+uValue+")"

            EndIf

        ElseIf cType == "C"

            If !Empty(uValue)
                If !Empty(cWhere)
                    cWhere += " AND "
                EndIf

                cWhere += cCampo
                cWhere += " "
                cWhere += cOperation

                If cType == "C"

                    aValue := StrTokArr( uValue , ",")
                    nTamArray := Len(aValue)
                    uValue := ""
                    For nX := 1 to nTamArray
                        uValue += "'"+AllTrim(aValue[nX])+"'"
                        If nX < nTamArray
                            uValue += ","
                        EndIf
                    Next

                    cWhere += "("+uValue+")"

                EndIf
            EndIf
        EndIF

    EndIf

Next

cReturn := " WHERE "

If !Empty(cCondBranch)
    cReturn += cCondBranch+" AND "
EndIf

If !Empty(cWhere)
    cReturn += cWhere+" AND "
EndIf

If cAliasQry == "CT2"

    If !Empty(cMoedaLC)
        cReturn += " CT2_MOEDLC = '"+cMoedaLC+"' AND "
    EndIf

    cReturn += " CT2_DC IN('1','2','3') AND "

    If _lCpoIdConc
        ::tcLoadTamSX()
        cReturn += " (CT2_IDCONC = ' ' OR QLD_SEQMAT <> ' ') AND "
    EndIf

    If CT2->(FieldPos("CT2_ESTCAN")) > 0
        cReturn += " CT2_ESTCAN = ' ' AND "
    EndIf

EndIf

If !Empty(cCpoUUID)
    cReturn += cCpoUUID+" IS NOT NULL AND "
EndIf

If !Empty(cAliasQry)
    cReturn += cAliasQry+"."
EndIf

cReturn += "D_E_L_E_T_ = ' ' "

// Não mostrar registros que já foram conciliados
If _lMVIdConc
    cReturn += " AND NOT EXISTS (SELECT 1 FROM " + RetSQLName("QLD") + " QLD WHERE "+cQLDFil+" AND QLD.QLD_CODCFG <> '"+cCodCfg+"' AND QLD.QLD_TPITEM = '"+cTipItem+"' "
    cReturn += " AND QLD.QLD_IDITEM = CAST("+cCpoUUID+" AS CHAR("+cValToChar(_nTamUUID)+")) "
    cReturn += " AND QLD.D_E_L_E_T_ = ' ') "
EndIf

//Tratamento concliado, não conciliado e ambos
If cView == "0"
    cReturn += ") "+cTempTable
ElseIf cView == "1"
    cReturn += ") "+cTempTable+" WHERE RECONCILED = 'S'"
ElseIf cView == "2"
    cReturn += ") "+cTempTable+" WHERE RECONCILED = 'N'"
EndIf

Return cReturn

/*/{Protheus.doc} ExecSQLExpress
    @author TOTVS
    @since 30/07/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method tcExecSQLExpress(cSQLExpression as Character, cTableTmp as Character, lAutomato as Logical, lTmpOri as Logical, cCpoUUID as Character, jCfgTrib as JSON) class MatchProcessingProtheusData
Local cSQL          := ""  as Character
Local cError        := ""  as Character
Local cCpoInsert    := ""  as Character
Local cSetupTimeout := ""  as Character
Local aStruct       := {}  as Array
Local oStruct       := tcTreatsFilter():New() as Object
Local nI            := 0   as Numeric
Local lCfgTrib      := .F. as Logical
Local lConcilBanc   := .F. as Logical

DEFAULT cSQLExpression := ""
DEFAULT cTableTmp      := ""
DEFAULT lAutomato      := .F.
DEFAULT lTmpOri        := .F.
DEFAULT cCpoUUID       := ""
DEFAULT jCfgTrib       := JsonObject():New()

If lAutomato
    Conout(STR0005) //"entrou no callStack"
    If lTmpOri
        cTableTmp := "TCTMPORI"
    Else
        cTableTmp := "TCTMPDES"
    EndIf
EndIf

//Alimenta campos para obter estrutura
aStruct := oStruct:tcGetStruct(cSQLExpression)
oStruct:tcKillObjects()

aEval(aStruct, {|x| cCpoInsert += IIf(x[1]=="CT2_IDCONC","",x[1]+",")})

IF ("IG" $ cCpoUUID .or. "FK5" $ cCpoUUID)
    lConcilBanc := .T.
Endif

If !Empty(cCpoUUID)
    cCpoInsert += cCpoUUID +", "
EndIf

If "CT2"$cCpoUUID .And. _lCpoIdCOnc
    cCpoInsert += "CT2_IDCONC, "
EndIf

cCpoInsert += " TABELA, REGMATCH, DESMATCH, SEQMATCH, CODCON, IDDELETE, RECONCILED, IDMATCH, COMPARISON, CODCFG, TYPEMATCH "

// CFGTRIB
If _lCpoCfgTrb .And. ValType(jCfgTrib) == "J" .And. jCfgTrib:hasProperty("col_taxes") .And. ValType(jCfgTrib["col_taxes"]) == "A" .And. Len(jCfgTrib["col_taxes"]) > 0 
    For nI := 1 to Len(jCfgTrib["col_taxes"])
        cCpoInsert += ", " + " T_"+jCfgTrib["col_taxes"][nI]["field"]+ " "
    Next nI
    
    lCfgTrib := .T. 
EndIf

::tcLoadTamSX()

//Adiciona campos para registrar o Match
If !Empty(cCpoUUID)
    AAdd(aStruct, {cCpoUUID, "C", _nTamUUID, 0})
EndIf

AAdd(aStruct, {"TABELA"    , "C", 3                    , 0})
AAdd(aStruct, {"REGMATCH"  , "C", nTamRegMat           , 0})
AAdd(aStruct, {"DESMATCH"  , "C", nTamDesMat           , 0})
AAdd(aStruct, {"SEQMATCH"  , "C", nTamSeqMat           , 0})
AAdd(aStruct, {"CODCON"    , "C", nTamCodCon           , 0})
AAdd(aStruct, {"IDDELETE"  , "C", nTamRegMat+nTamSeqMat, 0})
AAdd(aStruct, {"RECONCILED", "C", 1                    , 0})
AAdd(aStruct, {"IDMATCH"   , "C", nTamRegMat+nTamSeqMat, 0})
AAdd(aStruct, {"COMPARISON", "C", nTamCompar           , 0})
AAdd(aStruct, {"CODCFG"    , "C", nTamCodCfg           , 0})
AAdd(aStruct, {"TYPEMATCH" , "C", nTamTipMat           , 0})

// CFGTRIB
If _lCpoCfgTrb .And. lCfgTrib
    For nI := 1 to Len(jCfgTrib["col_taxes"])
        AAdd(aStruct, {"T_"+jCfgTrib["col_taxes"][nI]["field"]+" ", "N", nTamF2DVal, nDecF2DVal})
    Next nI 
EndIf

/*
    To-Do: TCConfig após disponibilidade pela Tec
    Essa funcionalidade se encarregará do gerenciamento da Temporaria,
    Permanência no banco, Exclusão  etc
*/

///Criacao da tabela temporaria com recno automatico

cTableTmp := "%SHTMP%"  //Identificador para criação de tabela temporaria compartilhada

cSetupTimeout   := TCConfig("SETTEMPKEEPALIVE=18000") // Setar timeout de inatividade em segundos (5 Horas)

If cSetupTimeout == "OK - SETTEMPKEEPALIVE TO 18000"

    FWDBCreate(cTableTmp, aStruct, "TOPCONN", .T.)      // Criação da tabela
    cTableTmp := TCConfig("GETTEMPNAME=" + cTableTmp)   // Capturar nome real da tabela

    DBUseArea(.T., "TOPCONN", cTableTmp, cTableTmp, .T., .F.) // Temporária compartilhada faz abertura com o nome REAL da tabela
    DBCreateIndex(cTableTmp+"1", cCpoUUID)
    DBCreateIndex(cTableTmp+"2", "RECONCILED+REGMATCH+"+cCpoUUID)   

    //Alimenta tabela temporaria
    cSQL := "INSERT INTO " + cTableTmp
    cSQL += " ("+cCpoInsert+") "
    cSQL += " ("+cSQLExpression+") "

    If TCSQLExec(cSQL) <> 0
        Conout(TCSQLError())
        cError := STR0011   + STR0012 //"matchProcessing Error: " "Nao foi possivel inserir dados na tabela temporaria: "
        cError += cTableTmp + STR0007 //". Para mais detalhes, verificar arquivo console.log"
    Endif

    IF _lCpoCfgTrb .And. Empty(cError) .AND. lCfgTrib
        ::tcFillTaxValues(cTableTmp, jCfgTrib)
    Endif
    
    IF Empty(cError) .AND. lConcilBanc .AND. "FK5" $ cCpoUUID
        cError := FInsertFin(cTableTmp)
    Endif

    DBCloseArea()

Else
    Conout(cSetupTimeout)
    cError += STR0011   + STR0013 //"matchProcessing Error: " "Não foi possível definir o tempo de timeout na tabela temporária."
    cError += cTableTmp + STR0007 //". Para mais detalhes, verificar arquivo console.log"
EndIf

//Limpa objetos
FwFreeArray(aStruct)
FreeObj(oStruct)
Return cError

/*/{Protheus.doc} tcCriaProcMatch
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
Method tcCriaProcMatch(cAliasOri as Character, cAliasDes as Character,;
                      cTableOri as Character, cTableDes as Character,;
                      cCpoIdOri as Character, cCpoIdDes as Character,;
                      jRegrasMatch as json, cNomProc as Character,;
                      cMatchOrd as Character, jTotal as json) class MatchProcessingProtheusData

Local cError     := "" as Character
Local cQuery     := "" as Character
Local cPopTemp1  := "" as Character
Local cPoptemp2  := "" as Character
Local cSumTotOri := "" as Character
Local cSumTotDes := "" as Character
Local cIdRule    := "" as Character
Local cIdLegend  := "" as Character
Local cNameRule  := "" as Character
Local cSeqMatch  := "" as Character
Local cConcat    := "" as Character
Local lAliasLink := .F. as Logical
Local nPTratRec  := 0 as Numeric
Local cNameDB    := Alltrim(TcGetDB()) as Character
Local cFilCondCV3:= "" as Character
Local nI         := 0  As Numeric
Local nJ         := 0  As Numeric
Local cComparison:= "AD" as Character
Local cFieldsOri := "" as Character
Local cFieldsDes := "" as Character
Local cMaxSeq    := "" as Character
Local nMaxMatch  := 0  as Numeric
Local cTypeMatch := "" as Character
Local lConcilBanc := .F. as Logical
Local cAdditionalCondition_Ori := "" as Character
Local cAdditionalCondition_Des := "" as Character
Local cTribAtu      := "" as Character
Local cTribColumn   := "" as Character

DEFAULT cNomProc := ""
DEFAULT cMatchOrd := ""

cNomProc := GetNextAlias()+"_"+cEmpAnt
lConcilBanc := ::cCodCfg $ "0023|0024" .or. ::cCfgOri $ "0023|0024"

While TCSPExist( cNomProc )
    If TcSqlExec(" DROP PROCEDURE " + cNomProc) <> 0
        cNomProc := GetNextAlias()+"_"+cEmpAnt
    Else
        Exit
    Endif
EndDo

If !TCSPExist( cNomProc )

    cIdRule     := jRegrasMatch["idrule"]
    cMaxSeq     := tcMaxSeqMatch(cTableOri, ::cCodCfg, cIdRule) //Max match utilizado como controle do número de match automático
    cIdLegend   := jRegrasMatch["idlegend"]
    cNameRule   := jRegrasMatch["name"]
    cAliasLink  := jRegrasMatch["linktable"]
    lAliasLink  := ValType(cAliasLink) <> "U"

    cCposChvOri := jRegrasMatch["rule"]["ori_fields"]
    cCposChvDes := jRegrasMatch["rule"]["des_fields"]
    cCondition  := jRegrasMatch["rule"]["condition"]

    // Os campos de tributos possuem um nome diferente na tabela temporária
    // Neste trecho é feito a "tradução" do nome do imposto para o nome da coluna, de acordo com o QLB_CFGTRIB
    If (_lCpoCfgTrb .And. jRegrasMatch["rule"]:hasProperty("ori_taxfields");
     .And. ValType(jRegrasMatch["rule"]["ori_taxfields"]) == "A" .And. Len(jRegrasMatch["rule"]["ori_taxfields"]) > 0) 
        For nI := 1 to Len(jRegrasMatch["rule"]["ori_taxfields"])
            cTribAtu := jRegrasMatch["rule"]["ori_taxfields"][nI]
            
            cTribColumn := TCGetTribColumn(cTribAtu, ::cCodCfg, "tabori")
            If !Empty(cTribColumn)
                cCposChvOri := StrTran(cCposChvOri, cTribAtu, cTribColumn)
                // cCondition := " " + cCondition + " " // Espaços para evitar substituição na string para regras fixas
                cCondition := StrTran(" " + cCondition + " ", " "+ cTribAtu +" ", " "+ cTribColumn +" " ) //Pesquiso com espaços para evitar substituição na string para regras fixas
            EndIf

        Next nI
    EndIf

    If (_lCpoCfgTrb .And. jRegrasMatch["rule"]:hasProperty("des_taxfields");
     .And. ValType(jRegrasMatch["rule"]["des_taxfields"]) == "A" .And. Len(jRegrasMatch["rule"]["des_taxfields"]) > 0) 
        For nI := 1 to Len(jRegrasMatch["rule"]["des_taxfields"])
            cTribAtu := jRegrasMatch["rule"]["des_taxfields"][nI]
            
            cTribColumn := TCGetTribColumn(cTribAtu, ::cCodCfg, "tabdes")
            If !Empty(cTribColumn)
                cCposChvDes := StrTran(cCposChvDes, cTribAtu, cTribColumn)
                // cCondition := " " + cCondition + " " // Espaços para evitar substituição na string para regras fixas
                cCondition := StrTran(" " + cCondition + " ", " "+ cTribAtu +" ", " "+ cTribColumn +" " ) //Pesquiso com espaços para evitar substituição na string para regras fixas
            EndIf

        Next nI
    EndIf

    If !Empty(jRegrasMatch["rule"]["max_match"])
        nMaxMatch   := If(ValType(jRegrasMatch["rule"]["max_match"]) = 'N', jRegrasMatch["rule"]["max_match"], Val((jRegrasMatch["rule"]["max_match"])))
    Endif

    cAdditionalCondition_Ori  := jRegrasMatch["rule"]["additionalcondition_ori"]

    If ValType(cAdditionalCondition_Ori) == "U"
        cAdditionalCondition_Ori := ""
    Else
        cAdditionalCondition_Ori := tcClearSql(cAdditionalCondition_Ori,.T.) //Remove possível código indevido
    EndIf

    cAdditionalCondition_Des  := jRegrasMatch["rule"]["additionalcondition_des"]

    If ValType(cAdditionalCondition_Des) == "U"
        cAdditionalCondition_Des := ""
    Else
        cAdditionalCondition_Des :=  tcClearSql(cAdditionalCondition_Des,.T.) //Remove possível código indevido
    EndIf

    If !Empty(cMatchOrd)
        cCposAux := cCposChvOri
        cCposChvOri := "" //Zera a variável para reconstruir sem duplicados
        While len(cCposAux) > 0
            nPosField := AT(',',cCposAux)
            //Se possuir vírgula, trata as variáveis, se não será o último campo
            If nPosField > 0
                //Se não encontrar o campo no cMatchOrd, incrementa no cCposAux
                If !(SUBSTR(cCposAux,1,nPosField-1) $ cMatchOrd)
                    cCposChvOri += SUBSTR(cCposAux,1,nPosField)
                    cCposAux := SUBSTR(cCposAux,nPosField+1,len(cCposAux))
                EndIf
            Else
                If !(Alltrim(cCposAux) $ cMatchOrd)
                    cCposChvOri += Alltrim(cCposAux)
                Else
                    //Se o ultimo campo não for incrementado, faço o substring para retirar a última virgula
                    cCposChvOri := SUBSTR(cCposChvOri,1,len(cCposChvOri)-1)
                EndIf
                cCposAux := ""
            EndIf
        EndDo
        If !Empty(cCposChvOri)
            cCposChvOri += ","
        EndIf
        cCposChvOri += cMatchOrd
    EndIf

    cPopTemp1 := ::tcChavtoVar(cCposChvOri)
    cPoptemp2 := ::tcChavtoVar(cCposChvDes)

    If lAliasLink
        cWhereOri := jRegrasMatch["rule"]["ori_link"]
    EndIf
    If lAliasLink
        cWhereDes := jRegrasMatch["rule"]["des_link"]
    EndIf

    // Valido se a chave valid existe nos totais
    If ValType(jTotal) <> "U"
        For nI := 1 To Len(jTotal["totalori"])
            // Origem
            If jTotal["totalori"][nI]["valid"] <> NIL .And. jTotal["totalori"][nI]["fields"] <> NIL
                If jTotal["totalori"][nI]["valid"] == .T.
                    cFieldsOri := jTotal["totalori"][nI]["total"]
                    If _lCpoCfgTrb .And. jTotal["totalori"][nI]:hasProperty("taxfields") .And. Valtype(jTotal["totalori"][nI]["taxfields"]) == "A";
                     .And. Len(jTotal["totalori"][nI]["taxfields"]) > 0
                        For nJ := 1 to Len(jTotal["totalori"][nI]["taxfields"])
                            cTribAtu := jTotal["totalori"][nI]["taxfields"][nJ] //Pega o tributo atual
                            cTribColumn := TCGetTribColumn(cTribAtu, ::cCodCfg, "tabori") //Identifica o nome da coluna do tributo
                            cFieldsOri := StrTran(cFieldsOri, cTribAtu, cTribColumn) // Substitui as colunas de impostos pelos nomes das colunas criados na matchprocessing
                        Next nJ
                    EndIf
                EndIf
            EndIf
        Next nI
        For nI := 1 To Len(jTotal["totaldes"])
            // Destino
            If jTotal["totaldes"][nI]["valid"] <> NIL .And. jTotal["totaldes"][nI]["fields"] <> NIL
                If jTotal["totaldes"][nI]["valid"] == .T.
                    cFieldsDes := jTotal["totaldes"][nI]["total"]
                    If _lCpoCfgTrb .And. jTotal["totaldes"][nI]:hasProperty("taxfields") .And. Valtype(jTotal["totaldes"][nI]["taxfields"]) == "A";
                     .And. Len(jTotal["totaldes"][nI]["taxfields"]) > 0
                        For nJ := 1 to Len(jTotal["totaldes"][nI]["taxfields"])
                            cTribAtu := jTotal["totaldes"][nI]["taxfields"][nJ] //Pega o tributo atual
                            cTribColumn := TCGetTribColumn(cTribAtu, ::cCodCfg, "tabdes") //Identifica o nome da coluna do tributo
                            cFieldsDes := StrTran(cFieldsDes, cTribAtu, cTribColumn) // Substitui as colunas de impostos pelos nomes das colunas criados na matchprocessing
                        Next nJ
                    EndIf
                EndIf
            EndIf
        Next nI
    EndIf

    If _lPostgres
        cTypeMatch += "CAST( "
    EndIf

    If !Empty(cIdLegend)
        cTypeMatch +=  " '"+cIdLegend+"' "
    ElseIf !Empty(cIdRule)
        cTypeMatch += "'A'"
    Else
        cTypeMatch += " '"+ Space(nTamTipMat)+"' "
    Endif

    If _lPostgres
        cTypeMatch += " AS CHAR(2))"
    EndIf

    If _lOracle .And. cAliasDes == "CT2"
        TcSqlExec("ANALYZE TABLE "+cTableOri+" COMPUTE STATISTICS")
        TcSqlExec("ANALYZE TABLE "+cTableDes+" COMPUTE STATISTICS")
    EndIf

    ::tcLoadTamSX()

    cConcat := tcRetConcat()

    cQuery :=  " CREATE PROCEDURE "+cNomProc+" ( "+CRLF+;
               " @OUT_RESULT Char( 01 ) output ) AS "+CRLF+;
               " DECLARE @REGMATCH Char( "+cValToChar(nTamRegMat)+" ) "+CRLF+;
               " DECLARE @DESMATCH Char( "+cValToChar(nTamDesMat)+" ) "+CRLF+;
               " DECLARE @SEQMATCH Char( "+cValToChar(nTamSeqMat)+" ) "+CRLF+;
               " DECLARE @TYPEMATCH Char( "+cValToChar(nTamTipMat)+" ) "+CRLF+;
               " DECLARE @NEWTYPEMATCH Char( "+cValToChar(nTamTipMat)+" ) "+CRLF+;
               " DECLARE @IDMATCH Char( "+cValToChar(nTamRegMat+nTamSeqMat)+" ) "+CRLF+;
               " DECLARE @iSeqMatch Integer "+CRLF+;
               " DECLARE @iSeqFlag Integer "+CRLF+;
               " DECLARE @iMaxSeqMat Integer "+CRLF+;
               " DECLARE @iNroRegs Integer "+CRLF+;
               " DECLARE @ins_error Integer "+CRLF+;
               " DECLARE @iLoop Integer "+CRLF+;
               " DECLARE @iTranCount Integer "+CRLF+;
               " DECLARE @IDMATCHOLD Char ( "+cValToChar(nTamRegMat+nTamSeqMat)+" ) "+CRLF+;
               " DECLARE @ValOri Float "+CRLF +;
               " DECLARE @iMaxMatch Integer "+CRLF

    If !AllTrim(cCpoIdOri) $ cCposChvOri
        cQuery += ::tcProcDeclare(cCpoIdOri)
    EndIf

    If !AllTrim(cCpoIdDes) $ cCposChvDes
        cQuery += ::tcProcDeclare(cCpoIdDes)
    EndIf

    If cAliasDes == "CT2"
        cQuery +=   " DECLARE @ValDesDb Float "+CRLF+;
                    " DECLARE @ValDesCr Float "+CRLF

        If !("CT2_DC"$cCposChvDes)
            If _nTamCT2_DC == Nil
                _nTamCT2_DC := TamSX3("CT2_DC")[1]
            EndIf
            cQuery +=  " DECLARE @CT2_DC Char("+cValToChar(_nTamCT2_DC)+") "+CRLF
        EndIf
    Else
        cQuery +=   " DECLARE @ValDes Float "+CRLF
    EndIf

    cQuery += ::tcProcDeclare(cCposChvOri)
    cQuery += ::tcProcDeclare(cCposChvDes)

    //Alimenta campos para obter estrutura
    If !Empty(cFieldsOri)
        cSumTotOri := "@SumTotOri"
        cQuery    += " DECLARE @SumTotOri Float "+CRLF
    EndIf

    If !Empty(cFieldsDes)
        cSumTotDes := '@SumTotDes'
        cQuery    += " DECLARE @SumTotDes Float "+CRLF
    EndIf

    cQuery +=  " BEGIN "+CRLF

    // Caso já existam matchs na tabela temporário verifico qual o número maximo de sequencia para implentar o próximo match
    If cMaxSeq <> '0'
        cQuery += "     SELECT @iSeqMatch	 = "+cMaxSeq+" "+CRLF
    Else
        cQuery += "     SELECT @iSeqMatch	 = 0 "+CRLF
    EndIf

    If cAliasDes == "CT2"
        cQuery += "     SELECT @ValDesDb = 0 "+CRLF+;
                  "     SELECT @ValDesCr = 0 "+CRLF+;
                  "     SELECT @CT2_DC = ' ' "+CRLF
    Else
        cQuery += "     SELECT @ValDes	 = 0 "+CRLF
    EndIf

    cQuery +=   "     SELECT @OUT_RESULT  = '0' "+CRLF+;
                "     SELECT @iLoop       = 0 "+CRLF+;
                "     SELECT @ValOri	  = 0 "+CRLF+;
                "     SELECT @IDMATCHOLD  = ' ' "+CRLF+;
                "     SELECT @iMaxMatch	 = " + CValToChar(nMaxMatch) + " "+CRLF+;
                "     DECLARE POPTEMP01 insensitive  CURSOR FOR "+CRLF

    If ValType(cCposChvOri) <> "U" .And. ValType(cAliasOri) <> "U"
        If cFieldsOri <> ""
            cQuery +=  "     SELECT DISTINCT "+cCposChvOri+", "+cFieldsOri+CRLF
        Else
            cQuery +=  "     SELECT DISTINCT "+cCposChvOri+CRLF
        EndIf

        If !AllTrim(cCpoIdOri) $ cCposChvOri
            cQuery +=  ","+cCpoIdOri
        EndIf

        cQuery +=  "     FROM "+cTableOri+" "+cAliasOri+" "
    EndIf

    If lAliasLink
        cQuery += ", "+RetSQLName(cAliasLink)+" "+cAliasLink+CRLF
    EndIf

    cQuery += " WHERE SEQMATCH = ' ' "
    cQuery += " AND RECONCILED = 'N' "

	If !Empty(cAdditionalCondition_Ori)
        cQuery += cAdditionalCondition_Ori
    EndIf

    If lAliasLink .And. ValType(cWhereOri) <> "U"
        cQuery += " AND "+cWhereOri
    EndIf

    If !Empty(cMatchOrd)
        cQuery += "   ORDER BY "+cMatchOrd
    EndIf

    cQuery +=  "     FOR READ ONLY "+CRLF+;
               "     OPEN POPTEMP01 "+CRLF+;
               "     FETCH POPTEMP01 "+CRLF
    If cFieldsOri <> ""
        cQuery += "  INTO "+cPopTemp1+", "+cSumTotOri+CRLF
    else
        cQuery += "  INTO "+cPopTemp1+CRLF
    EndIf

    If !AllTrim(cCpoIdOri)$ cCposChvOri
        cQuery +=  ", @"+cCpoIdOri
    EndIf

    cQuery +=  "     WHILE @@Fetch_Status  = 0 BEGIN "+CRLF+;
               "         SELECT @iNroRegs = @iNroRegs + 1 "+CRLF+;
               "         SELECT @iSeqMatch = @iSeqMatch + 1 "+CRLF+;
               "         SELECT @iSeqFlag = 0 "+CRLF

    // Condição para validar se os valores são iguais e atualizar o campo COMPARISON
    If !Empty(cSumTotOri) .And. !Empty(cSumTotDes)

        If cAliasDes == "CT2"
            cQuery +=  "             If ((@ValDesDb > 0 and Round(@ValOri,2) <> Round(@ValDesDb,2)) or (@ValDesCr > 0 and Round(@ValOri,2) <> Round(@ValDesCr,2))) and @IDMATCHOLD  <> ' ' Begin "+CRLF
        Else
            cQuery +=  "             If Round(@ValOri,2) <> Round(@ValDes,2) AND @IDMATCHOLD <> ' ' Begin "+CRLF
        EndIf

        cQuery +=   "                 UPDATE "+cTableOri+CRLF+;
                    "                 SET COMPARISON = '"+cComparison+"' " +CRLF+;
                    "                 WHERE "+::tcCondUpdate("",cIdRule)+" AND IDMATCH = @IDMATCHOLD"+CRLF+;
                    "                 UPDATE "+cTableDes+CRLF+;
                    "                 SET COMPARISON = '"+cComparison+"' " +CRLF+;
                    "                 WHERE "+::tcCondUpdate("",cIdRule)+" AND IDMATCH = @IDMATCHOLD"+CRLF+;
                    "             End "+CRLF

        If cAliasDes == "CT2"
            cQuery +=   "     SELECT @ValDesDb = 0 "+CRLF+;
                        "     SELECT @ValDesCr = 0 "+CRLF+;
                        "     SELECT @CT2_DC = ' ' "+CRLF
        Else
            cQuery +=   "     SELECT @ValDes	 = 0 "+CRLF
        EndIf

        cQuery +=  "     SELECT @ValOri = "+cSumTotOri+CRLF+;
                   "     SELECT @IDMATCHOLD  = ' ' "+CRLF
    EndIf

    cQuery +=  "         IF @iNroRegs = 1 BEGIN "+CRLF+;
               "             BEGIN TRAN "+CRLF+;
               "             SELECT @iNroRegs = @iNroRegs "+CRLF+;
               "         END "+CRLF+;
               "         DECLARE POPTEMP02 insensitive  CURSOR FOR "+CRLF

    If ValType(cCposChvDes) <> "U" .And. ValType(cAliasDes) <> "U"

        If lConcilBanc
            cQuery +=  "     SELECT "
        Else
            cQuery +=  "     SELECT DISTINCT "
        EndIf

        cQuery +=  cCposChvDes+", REGMATCH, DESMATCH, IDMATCH, SEQMATCH, TYPEMATCH "

		If cFieldsDes <> ""
			cQuery +=", " + cFieldsDes +CRLF
        Endif

        If cAliasDes == "CT2" .And. !("CT2_DC"$cCposChvDes)
            cQuery +=  ", CT2_DC "+CRLF
        EndIf

         If !AllTrim(cCpoIdDes)$cCposChvDes
            cQuery += ", "+cCpoIdDes
        EndIf

        If lConcilBanc
            cQuery +=  " FROM ( SELECT DISTINCT " +CRLF

            If !Empty(nMaxMatch) .AND. nMaxMatch > 0 .and. cNameDB $ "MSSQL7|MSSQL"
                cQuery += " TOP (@iMaxMatch) "
            Endif

            cQuery += cCposChvDes+", REGMATCH, DESMATCH, IDMATCH, SEQMATCH, TYPEMATCH "+CRLF

            If cFieldsDes <> "" .And. cFieldsOri <> ""
                cQuery +=", " + cFieldsDes +CRLF
            Endif

            If !AllTrim(cCpoIdDes)$cCposChvDes
                cQuery += ", "+cCpoIdDes
            EndIf

        Endif

        cQuery += "     FROM "+cTableDes+" "+cAliasDes+" "
    EndIf

    If lAliasLink
        cQuery += ", "+RetSQLName(cAliasLink)+" "+cAliasLink+CRLF
    EndIf

    cQuery += " WHERE RECONCILED = 'N' AND "
    cQuery += " (REGMATCH = '"+cIdRule+"' OR REGMATCH = ' ') "

	If !Empty(cAdditionalCondition_Des)
        cQuery += cAdditionalCondition_Des
    EndIf

    cQuery +=  " AND "

    // Ajuste de Performance para adicionar filial da CV3 na procedure
    If lAliasLink .And. cAliasLink == 'CV3'
        cFilCondCV3 := GetBranchiesForConditional(cAliasLink)
        If cFilCondCV3 <> ''
            cFilCondCV3 := cFilCondCV3 + 'AND '
        EndIf
    EndIf

    cQuery += ::tcCondtoVar(cFilCondCV3+cCondition,cCposChvOri)+CRLF

    If !Empty(nMaxMatch) .AND. nMaxMatch > 0 .and. cNameDB $ "ORACLE"
        cQuery += " AND ROWNUM <= @iMaxMatch "  + CRLF
    Endif

    If lConcilBanc
        cQuery += ") " + cAliasDes +" "+ CRLF
    EndIf

    IIf(cNameDB$"MSSQL7|MSSQL",;
        cSeqMatch := " RIGHT('"+Replicate('0',nTamSeqMat)+"'+RTRIM(CAST(@iSeqMatch AS CHAR("+cValToChar(nTamSeqMat)+"))),"+cValToChar(nTamSeqMat)+") ",;
        cSeqMatch := " TO_CHAR(@iSeqMatch,'FM"+Replicate('0',nTamSeqMat)+"') ")

    cQuery +=  "         FOR READ ONLY "+CRLF+;
               "         OPEN POPTEMP02 "+CRLF+;
               "         FETCH POPTEMP02 "+CRLF
    If cFieldsDes <> ""
        cQuery += "      INTO "+cPopTemp2+", @REGMATCH, @DESMATCH, @IDMATCH, @SEQMATCH, @TYPEMATCH, "+cSumTotDes +CRLF
    else
        cQuery += "      INTO "+cPopTemp2+", @REGMATCH, @DESMATCH, @IDMATCH, @SEQMATCH, @TYPEMATCH "+CRLF
    EndIf

    If cAliasDes == "CT2" .And. !("CT2_DC"$cCposChvDes)
        cQuery +=  ", @CT2_DC "+CRLF
    EndIf

    If !AllTrim(cCpoIdDes) $ cCposChvDes
        cQuery += ", @"+cCpoIdDes
    EndIf

    cQuery +=  "         If @@Fetch_Status <> 0 Begin "+CRLF+;
               "            SELECT @iSeqMatch = @iSeqMatch - 1 "+CRLF+;
               "         End "+CRLF+;
               "         WHILE @@Fetch_Status  = 0 BEGIN "+CRLF

    If cSumTotDes <> ""
        If cAliasDes == "CT2"
            cQuery +=   "           If @CT2_DC = '1' Begin "+CRLF+;
                        "               SELECT @ValDesDb  = @ValDesDb + "+cSumTotDes+" "+CRLF+;
                        "           End Else If @CT2_DC = '2' Begin "+CRLF+;
                        "               SELECT @ValDesCr  = @ValDesCr + "+cSumTotDes+" "+CRLF+;
                        "           End Else Begin "+CRLF+;
                        "               SELECT @ValDesDb  = @ValDesDb + "+cSumTotDes+" "+CRLF+;
                        "               SELECT @ValDesCr  = @ValDesCr + "+cSumTotDes+" "+CRLF+;
		                "           End "+CRLF
        Else
            cQuery +=  "         SELECT @ValDes = @ValDes + "+cSumTotDes+" "+CRLF
        EndIf
    Endif

    cQuery += "           SELECT @NEWTYPEMATCH =  "+cTypeMatch + " "+CRLF
    cQuery +=  "             If @SEQMATCH = ' ' Begin "+CRLF+;
               "                 SELECT @IDMATCHOLD = ('"+cIdRule+"' " + cConcat + " "+ cSeqMatch + " ) "+CRLF+;
               "                 UPDATE "+cTableOri+CRLF+;
               "                 SET REGMATCH = '"+cIdRule+"', DESMATCH = '"+cNameRule+"', "+CRLF+;
               "                 IDMATCH = ('"+cIdRule+"' " + cConcat + " "+ cSeqMatch + " ) , " +CRLF+;
               "                 SEQMATCH = "+ cSeqMatch +" , "+ CRLF+;
               "                 TYPEMATCH = @NEWTYPEMATCH " + CRLF +;
               "                 WHERE "+::tcCondUpdate(cCposChvOri,cIdRule)+" AND SEQMATCH = ' ' "+CRLF+;
               "                 UPDATE "+cTableDes+CRLF+;
               "                 SET REGMATCH = '"+cIdRule+"', DESMATCH = '"+cNameRule+"', "+CRLF+;
               "                 IDMATCH = ('"+cIdRule+ "' " + cConcat + " "+ cSeqMatch + " ) , " +CRLF+;
               "                 SEQMATCH = "+ cSeqMatch +" , "+ CRLF +;
               "                 TYPEMATCH = @NEWTYPEMATCH " + CRLF + ;
               "                 WHERE "+::tcCondUpdate(cCposChvDes,cIdRule)+CRLF+;
               "             End Else Begin "+CRLF+;
			   "                 SELECT @IDMATCHOLD = @IDMATCH "+CRLF+;
               "                 UPDATE "+cTableOri+CRLF+;
               "                 SET REGMATCH = @REGMATCH, DESMATCH = @DESMATCH, IDMATCH = @IDMATCH, SEQMATCH = @SEQMATCH , TYPEMATCH = @TYPEMATCH"+CRLF+;
               "                 WHERE "+::tcCondUpdate(cCposChvOri,cIdRule)+" AND SEQMATCH = ' ' "+CRLF+;
               "                 If @iSeqMatch > 1 AND @iSeqFlag = 0 Begin "+CRLF+;
               "                     SELECT @iSeqMatch = @iSeqMatch - 1 "+CRLF+;
               "                     SELECT @iSeqFlag = 1 "+CRLF+;
               "                 End "+CRLF

    If !Empty(cSumTotOri)
        cQuery +=  "              SELECT @ValOri = SUM("+cFieldsOri+") FROM "+cTableOri+" WHERE "+::tcCondUpdate("",cIdRule)+" AND IDMATCH = @IDMATCH"+CRLF
    EndIf

    // Condição para voltar os valores para o estado anterior no campo COMPARISON
    If !Empty(cSumTotOri) .And. !Empty(cSumTotDes)
        If cAliasDes == "CT2"
            cQuery +=  "          If (Round(@ValOri,2) = Round(@ValDesDb,2) and @ValDesCr = 0) or (Round(@ValOri,2) = Round(@ValDesCr,2) and @ValDesDb = 0) or (Round(@ValOri,2) = Round(@ValDesCr,2) and Round(@ValOri,2) = Round(@ValDesDb,2)) Begin "+CRLF
        Else
            cQuery +=  "          If Round(@ValOri,2) = Round(@ValDes,2) Begin "+CRLF
        EndIf

        cQuery +=   "                 UPDATE "+cTableOri+CRLF+;
                    "                 SET COMPARISON = 'N' " +CRLF+;
                    "                 WHERE "+::tcCondUpdate("",cIdRule)+" AND IDMATCH = @IDMATCHOLD"+CRLF+;
                    "                 UPDATE "+cTableDes+CRLF+;
                    "                 SET COMPARISON = 'N' " +CRLF+;
                    "                 WHERE "+::tcCondUpdate("",cIdRule)+" AND IDMATCH = @IDMATCHOLD"+CRLF+;
                    "             End "+CRLF
    EndIf

    cQuery +=  "                 If @iSeqMatch > 1 AND @iSeqFlag = 0 Begin "+CRLF+;
               "                     SELECT @iSeqMatch = @iSeqMatch - 1 "+CRLF+;
               "                     SELECT @iSeqFlag = 1 "+CRLF+;
               "                 End "+CRLF+;
               "             End "+CRLF+;
               "             FETCH POPTEMP02 "+CRLF
    If cFieldsDes <> ""
        cQuery += "      INTO "+cPopTemp2+", @REGMATCH, @DESMATCH, @IDMATCH, @SEQMATCH, @TYPEMATCH, "+cSumTotDes +CRLF
    else
        cQuery += "      INTO "+cPopTemp2+", @REGMATCH, @DESMATCH, @IDMATCH, @SEQMATCH, @TYPEMATCH "+CRLF
    EndIf

    If cAliasDes == "CT2" .And. !("CT2_DC"$cCposChvDes)
        cQuery +=  ", @CT2_DC "+CRLF
    EndIf

    If !AllTrim(cCpoIdDes)$cCposChvDes
        cQuery += ", @"+cCpoIdDes
    EndIf

    cQuery +=     "      END "+CRLF

    // Em postgres ao fazer o fetch no segundo cursos e não encontrar registros a variavel que
    // controla os laços de repetição dos dois cursores recebe = 1, para evitar o problema
    // é atribuido novamente o valor o em fim_cur para que o cursor poptemp1 passe para o próximo registro
    If _lPostgres
        cQuery += "         SELECT @fim_CUR  = 0"+CRLF
    EndIf

    cQuery +=  "         CLOSE POPTEMP02 "+CRLF+;
               "         DEALLOCATE POPTEMP02 "+CRLF+;
               "         IF @iNroRegs >= 4000 BEGIN "+CRLF+;
               "             commit tran "+CRLF+;
               "             SELECT @iNroRegs = 0 "+CRLF+;
               "         END "+CRLF+;
               "         FETCH POPTEMP01 "+CRLF
    If cFieldsOri <> ""
        cQuery += "      INTO "+cPopTemp1+", "+cSumTotOri+CRLF
    else
        cQuery += "      INTO "+cPopTemp1 +CRLF
    EndIf

    If !AllTrim(cCpoIdOri)$cCposChvOri
        cQuery += ", @"+cCpoIdOri
    EndIf

    cQuery +=  "     END "+CRLF+;
               "     CLOSE POPTEMP01 "+CRLF+;
               "     DEALLOCATE POPTEMP01 "+CRLF

    // Condição para validar se os valores são iguais e atualizar o campo COMPARISON
    If !Empty(cSumTotOri) .And. !Empty(cSumTotDes)
        cQuery +=  "             If @IDMATCHOLD <> ' ' Begin "+CRLF

        If cAliasDes == "CT2"
            cQuery +=  " If ((@ValDesDb > 0 and Round(@ValOri,2) <> Round(@ValDesDb,2)) or (@ValDesCr > 0 and Round(@ValOri,2) <> Round(@ValDesCr,2))) Begin "+CRLF
        Else
            cQuery +=  " If Round(@ValOri,2) <> Round(@ValDes,2) Begin "+CRLF
        EndIf

        cQuery +=   "                    UPDATE "+cTableOri+CRLF+;
                    "                    SET COMPARISON = '"+cComparison+"' " +CRLF+;
                    "                    WHERE "+::tcCondUpdate("",cIdRule)+" AND IDMATCH = @IDMATCHOLD"+CRLF+;
                    "                    UPDATE "+cTableDes+CRLF+;
                    "                    SET COMPARISON = '"+cComparison+"' " +CRLF+;
                    "                     WHERE "+::tcCondUpdate("",cIdRule)+" AND IDMATCH = @IDMATCHOLD"+CRLF+;
                    "                End Else Begin "+CRLF+;
                    "                    UPDATE "+cTableOri+CRLF+;
                    "                    SET COMPARISON = 'N' " +CRLF+;
                    "                    WHERE "+::tcCondUpdate("",cIdRule)+" AND IDMATCH = @IDMATCHOLD"+CRLF+;
                    "                    UPDATE "+cTableDes+CRLF+;
                    "                    SET COMPARISON = 'N' " +CRLF+;
                    "                     WHERE "+::tcCondUpdate("",cIdRule)+" AND IDMATCH = @IDMATCHOLD"+CRLF+;
                    "                End "+CRLF+;
                    "             End "+CRLF
    EndIf

    cQuery +=   "     IF @iNroRegs > 0 BEGIN "+CRLF+;                
                "         select @iTranCount = 0 "+CRLF+;
                "     END "+CRLF+;
                "     SELECT @OUT_RESULT = '1' "+CRLF+;
                " END "

    cQuery := CtbAjustaP(.T., cQuery, @nPTratRec)
    cQuery := MsParse(cQuery, cNameDB)
    cQuery := CtbAjustaP(.F., cQuery, nPTratRec)

     //Ajusta o último commit
    If "SQL"$cNameDB
        cQuery := StrTran(cQuery, "SET @iTranCount  = 0", "commit tran")
    ElseIf cNameDB == "ORACLE"    
        cQuery := StrTran(cQuery, "viTranCount  := 0", "commit")
    EndIf

	//A variavel fim_cur fica com o nome vFim_cur ao passar pelo MSParse
    If _lPostgres
        cQuery	:= StrTran( cQuery, 'vfim_CUR', 'fim_CUR' )
    EndIf

    IIf(Empty(cQuery),;
        (conout(MsParseError()),;
            cError := STR0011  + STR0006,;  //"matchProcessing Error: " "Error on the procedure creation (MSPARSE) "
            cError += cNomProc + STR0007),; //". Para mais detalhes, verificar arquivo console.log"
        cError := "")

    If Empty(cError)
        IIf(TcSqlExec(cQuery) <> 0,;
            (conout(TCSqlError()),;
                cError := STR0011  + STR0008,;  //"matchProcessing Error: " "Error on the procedure creation (TCSQLEXEC) "
                cError += cNomProc + STR0007),; //". Para mais detalhes, verificar arquivo console.log"
            cError := "")
    EndIf
EndIf

Return cError

/*/{Protheus.doc} tcChavtoVar
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
method tcChavtoVar(cCposChave as Character) class MatchProcessingProtheusData
Default cCposChave := ""
Return "@"+StrTran(StrTran(cCposChave," ",""),",",", @")

/*/{Protheus.doc} tcCondtoVar
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
method tcCondtoVar(cCondition as Character, cCposChvOri as Character) Class MatchProcessingProtheusData
Local aCposChave := {} as Array
Local nI := 0 as Numeric
Local cField := "" as Character

aCposChave := StrToArray(cCposChvOri,",")
For nI := 1 to Len(aCposChave)
    cField := AllTrim(aCposChave[nI])
    If cField$cCondition
        cCondition := StrTran(cCondition,cField,"@"+cField)
    EndIf
Next

Return cCondition

/*/{Protheus.doc} tcProcMatch
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
method tcProcMatch( cAliasOri as Character, cAliasDes as Character,;
                    cTableOri as Character, cTableDes as Character,;
                    cCpoIdOri as Character, cCpoIdDes as Character,;
                    jRegrasMatch as Json, cMatchOrd as Character,;
                    jTotal as Json) Class MatchProcessingProtheusData
Local nI        := 0 as Numeric
Local cError    := "" as Character
Local cNomProc  := "" as Character
Local aResult   := {} as Array

For nI:=1 to Len(jRegrasMatch["rules"])
    If Empty(cError)
        cError := ::tcCriaProcMatch(cAliasOri,cAliasDes,cTableOri,cTableDes,cCpoIdOri,cCpoIdDes,jRegrasMatch["rules"][nI],@cNomProc,cMatchOrd,jTotal)
        If Empty(cError)
            aResult := TCSPEXEC(xProcedures(Left(cNomProc,10)))

            IIf(Empty(aResult) .or. aResult[1] = "0",;
                (conout(TCSQLError()),;
                cError := STR0009+cNomProc+" "+TcSQLError()),; //"Erro na execucao do Match via procedure: "
                cError := "")

            If Empty(cError)
                IIf(TcSqlExec(" DROP PROCEDURE " + cNomProc) <> 0,;
                    (conout(TCSQLError()),;
                        cError := STR0011 + STR0010,;   //"matchProcessing Error: " "Erro na exclusao da procedure "
                        cError += cNomProc + STR0007),; //". Para mais detalhes, verificar arquivo console.log"
                    cError := "")
            EndIf
        EndIf
    EndIf
Next

Return cError

/*/{Protheus.doc} tcProcDeclare
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
method tcProcDeclare(cCposChave as Character) Class MatchProcessingProtheusData
Local aCposChave := {} as Array
Local nI     := 0  as Numeric
Local cField := "" as Character
Local cTipo  := "" as Character
Local cSQL   := "" as Character
Local aTamFil:= {} as ARRAY

aCposChave := StrToArray(cCposChave,",")
For nI := 1 to Len(aCposChave)
    cField  := AllTrim(aCposChave[nI])
    
    //Campos com prefixo T_ são tributos da F2D
    If _lCpoCfgTrb .And. FwTabPref(cField) == "T"
        aTamFil := {nTamF2DVal,nDecF2DVal,"N"} //O tamanho do campo é o tamanho do F2D_VALOR = Origem do valor
    Else
        //Fixo 36 pois as tabelas temporárias foram criadas com 36
        //Ajuste para remover o RTRIM da regra de match
        If "_MSUID"$cField
            aTamFil := {36,0,"C"}
        Else
            aTamFil := TamSx3(cField)
        EndIf

    EndIf 
        cTipo := IIf(Len(aTamFil) > 0,;
                    IIf(aTamFil[3] == "N",;
                        IIF(aTamFil[2] > 0,;
                            "float",;
                            "integer"),;
                    "varchar("+cValToCHar(aTamFil[1])+")"),;
                "")

    cSQL += IIf(Len(aTamFil) > 0, "DECLARE @"+cField+" "+cTipo+CRLF, "")
Next

Return cSQL

/*/{Protheus.doc} tcProcDeclare
    (long_description)
    @author user
    @since 26/08/2021
    @version version
    @param param_name, param_type, param_descr
    @return return_var, return_type, return_description
    /*/
method tcCondUpdate(cCposChave as Character, cIdrule as Character) class MatchProcessingProtheusData
Local aCposChave := {} as Array
Local cSQL := "" as Character
Local nI := 0 as Numeric
Local cField := "" as Character

DEFAULT cIdRule := " "

If cCposChave = ''
    cSQL := " RECONCILED = 'N' AND (REGMATCH = '"+cIdRule+"' OR REGMATCH = ' ') "
Else
    cSQL := " RECONCILED = 'N' AND (REGMATCH = '"+cIdRule+"' OR REGMATCH = ' ') AND "

    aCposChave := StrToArray(cCposChave,",")
    For nI := 1 to Len(aCposChave)
        cSQL += IIf(nI > 1, " AND ", "")
        cField := AllTrim(aCposChave[nI])
        cSQL += cField+" = @"+cField
    Next
EndIf

Return cSQL

//-------------------------------------------------------------------
/*/{Protheus.doc} tcLoadTamSX
Metodo que retorna tamanho dos campos de match

@author Totvs
/*/
//-------------------------------------------------------------------
method tcLoadTamSX() class MatchProcessingProtheusData

If ValType(nTamRegMat) == "U"
    nTamRegMat := TamSx3("QLD_REGMAT")[1]
    nTamSeqMat := TamSx3("QLD_SEQMAT")[1]
    nTamDesMat := TamSx3("QLD_DESMAT")[1]
    nTamCodcon := TamSx3("QLD_CODCON")[1]
    nTamCodCfg := TamSx3("QLD_CODCFG")[1]
    If QLD->(FieldPos("QLD_COMPAR")) > 0
        nTamCompar := TamSx3("QLD_COMPAR")[1]
    Endif
    If QLD->(FieldPos("QLD_TIPMAT")) > 0
        nTamTipMat := TamSx3("QLD_TIPMAT")[1]
    Endif
    _nTamPref := TamSx3("E1_PREFIXO")[1]
    _nTamNum  := TamSx3("E1_NUM")[1]
    _nTamParc := TamSx3("E1_PARCELA")[1]
    _nTamTipo := TamSx3("E1_TIPO")[1]
    _nTamCli  := TamSx3("E1_CLIENTE")[1]
    _nTamLoja := TamSx3("E1_LOJA")[1]

    If FWAliasInDic("F2D", .F.)
        If F2D->(FieldPos("F2D_VALOR")) > 0
            nTamF2DVal := TamSX3("F2D_VALOR")[1]
            nDecF2DVal := TamSX3("F2D_VALOR")[2]
            nTamF2DTrib := TamSX3("F2D_TRIB")[1]
        EndIf
    EndIf
EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetQuery
Metodo que retorna a query montada

@author Totvs
/*/
//-------------------------------------------------------------------
method tcRetQuery(cCodCfg as character, jHeaders as Json, cCpoID as character, cAlias as character, cTipo as character, aTaxes as Array) class MatchProcessingProtheusData
    Local cRetQry       := ""                                   As Character
    Local cJsonItem     := ""                                   As Character
    Local cQLDFil       := GetBranchiesForConditional("QLD")    As Character

    DEFAULT cCodCfg := ""
    DEFAULT cCpoID  := ""
    DEFAULT cAlias  := ""
    DEFAULT cTipo   := ""
    DEFAULT aTaxes  := {}

    cJsonItem := IIf(cTipo == "1","data_ori","data_des")
    cCpoId    := trim(cCpoId)

    cRetQry := " SELECT "
    cRetQry += ::tcRetSQLExpression(jHeaders[cJsonItem],", ",cCpoId, .T.,    ,       ,        , aTaxes ) //Cabecalho da query
    cRetQry += " FROM ( SELECT "
    cRetQry += ::tcRetSQLExpression(jHeaders[cJsonItem],", ",cCpoId, .F., nil, cAlias, cCodCfg, aTaxes) //Itens da query
    cRetQry += " FROM "+RetSQLName(cAlias)+" "+cAlias

    If ((cCodCfg == "0024") .Or. ((QLB->(FieldPos("QLB_CFGORI")) > 0) .And. (QLB->QLB_CFGORI == "0024"))) .And. cAlias == "SIG"
        cRetQry += " INNER JOIN "+RetSQLName("QLD")+" QLD ON "
    Else
        cRetQry += " LEFT JOIN "+RetSQLName("QLD")+" QLD ON "
    Endif

    cRetQry +=  cQLDFil
    cRetQry += " AND QLD_TPITEM = '"+cTipo+"' "
    cRetQry += " AND QLD_CODCFG = '"+cCodCfg+"' "
    cRetQry += " AND QLD_IDITEM = CAST("+cCpoId+" AS CHAR("+cValToChar(_nTamUUID)+")) "
    cRetQry += " AND QLD.D_E_L_E_T_ = ' ' "

Return cRetQry

//-------------------------------------------------------------------
/*/{Protheus.doc} tcQueryUnion
Metodo que retorna a query com union

@author Totvs
/*/
//-------------------------------------------------------------------
method tcQueryUnion(cCodCfg as character, cTipo as character, cCpoID as character, cAlias as character, cView as character,;
                        jUnion as array, jHeaders as array, jBody as Json, cMatchOrd as character, aTaxes as Array, cTribLink as Character) class MatchProcessingProtheusData
    Local nI        := 0
    Local nJ        := 0
    Local cTabUnion := ""
    Local cIdUnion  := ""
    Local cRetQuery := ""
    Local aHeaders  := {}
    Local aCposPai  := {}
    Local aCposFil  := {}
    Local jFilters  :=  JsonObject():new() as Json
    Local jTribLink :=  JsonObject():new() as Json
    Local cTempTab  := ""
    Local cFieldType := ""
    
    DEFAULT aTaxes := {}
    DEFAULT cTribLink := ""

    cTempTab := If(cTipo == "1", "TEMPORI", "TEMPDES")

    //Quando houver impostos do configurador de tributos, adicionar campo de link automaticamente
    If _lCpoCfgTrb .And. Len(aTaxes) > 0 .And. !Empty(cTribLink) 
        jTribLink:fromJson('{"cpopai": "", "cpofil": "'+cTribLink+'"}')
    EndIf

    For nI:=1 to Len(jUnion)
        cTabUnion := jUnion[nI]["table"]
        cIdUnion  := jUnion[nI]["cpoid"]
        cMatchOrd := jUnion[nI]["matchorder"]
        
        // adicionar campo de link automaticamente no jUnion
        If _lCpoCfgTrb .And. Len(aTaxes) > 0 .And. !Empty(cTribLink) .And. aScan(jUnion[nI]["fields"], {|x| x["cpofil"] = cTribLink}) == 0
            aAdd(jUnion[nI]["fields"], jTribLink)
        EndIf

        For nJ:=1 to Len(jUnion[nI]["fields"])
            If Empty(jUnion[nI]["fields"][nJ]["cpopai"])
                aAdd(aHeaders, jUnion[nI]["fields"][nJ]["cpofil"])

                cFieldType := FWSX3Util():GetFieldType((jUnion[nI]["fields"][nJ]["cpofil"]))
                If cFieldType == "N" .OR. cFieldType == "L"
                    aAdd(aCposPai, "0 "+jUnion[nI]["fields"][nJ]["cpofil"])
                Else
                    aAdd(aCposPai, "' ' "+jUnion[nI]["fields"][nJ]["cpofil"])
                EndIf
            Else
                aAdd(aHeaders, jUnion[nI]["fields"][nJ]["cpopai"])
                aAdd(aCposPai, jUnion[nI]["fields"][nJ]["cpopai"])
                jFilters[jUnion[nI]["fields"][nJ]["cpopai"]] := jUnion[nI]["fields"][nJ]["cpofil"]
            EndIf

            If Empty(jUnion[nI]["fields"][nJ]["cpofil"])

                cFieldType := FWSX3Util():GetFieldType((jUnion[nI]["fields"][nJ]["cpopai"]))
                If cFieldType == "N" .OR. cFieldType == "L"
                    aAdd(aCposFil, "0 "+jUnion[nI]["fields"][nJ]["cpopai"])
                Else
                    aAdd(aCposFil, "' ' "+jUnion[nI]["fields"][nJ]["cpopai"])
                EndIf
            Else
                aAdd(aCposFil, jUnion[nI]["fields"][nJ]["cpofil"])
            EndIf
        Next nJ

        For nJ:=1 to Len(jHeaders)
            If aScan(aHeaders, {|x| x = jHeaders[nJ]}) == 0
                aAdd(aHeaders, jHeaders[nJ])
                aAdd(aCposPai, jHeaders[nJ])

                cFieldType := FWSX3Util():GetFieldType(jHeaders[nJ])
                If cFieldType == "N" .OR. cFieldType == "L"
                    aAdd(aCposFil, "0 "+jHeaders[nJ])
                Else
                    aAdd(aCposFil, "' ' "+jHeaders[nJ])
                EndIf

            EndIf
        Next nJ

        If nI == 1
            cRetQuery := ::tcRetSelectUnion(cCodCfg, cTipo, cCpoId, cAlias, aHeaders, aCposPai, jBody, aTaxes)
        EndIf

        cRetQuery += ::tcRetUnion(cCodCfg, cTipo, cIdUnion, cTabUnion, aCposFil, jFilters, jBody, aTaxes)
    Next nI

    //Tratamento concliado, não conciliado e ambos
    If !Empty(cRetQuery)
        If cView == "0"
            cRetQuery += ") "+cTempTab
        ElseIf cView == "1"
            cRetQuery += ") "+cTempTab+" WHERE RECONCILED = 'S'"
        ElseIf cView == "2"
            cRetQuery += ") "+cTempTab+" WHERE RECONCILED = 'N'"
        EndIf
    EndIf

Return cRetQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetSelectUnion
Metodo que retorna o select do Union

@author Totvs
/*/
//-------------------------------------------------------------------
method tcRetSelectUnion(cCodCfg as character, cTipo as character, cCpoId as character, cAlias as character,;
                            aHeaders as array,  aCposPai as array, jBody as json, aTaxes as Array) class MatchProcessingProtheusData
    Local cRetQuery := ""
    Local cQLDFil   := GetBranchiesForConditional("QLD")  as character

    DEFAULT aTaxes := {}

    cRetQuery := " SELECT "
    cRetQuery += ::tcRetSQLExpression(aHeaders,", ",cCpoId, .T.,    ,       ,        , aTaxes ) //Cabecalho da query
    cRetQuery += " FROM ( SELECT "
    cRetQuery += ::tcRetSQLExpression(aCposPai,", ",cCpoId, .F., nil, cAlias, cCodCfg, aTaxes ) //Itens da query
    cRetQuery += " FROM "+RetSQLName(cAlias)+" "+cAlias
    cRetQuery += " LEFT JOIN "+RetSQLName("QLD")+" QLD ON "
    cRetQuery +=  cQLDFil
    cRetQuery += " AND QLD_TPITEM = '"+cTipo+"' "
    cRetQuery += " AND QLD_CODCFG = '"+cCodCfg+"' "
    cRetQuery += " AND QLD_IDITEM = CAST("+cCpoId+" AS CHAR("+cValToChar(_nTamUUID)+")) "
    cRetQuery += " AND QLD.D_E_L_E_T_ = ' ' "
    cRetQuery += ::tcRetWhere(jBody["tabori"], "", cTipo, cAlias,"01", cCpoId, ,cCodCfg,)

Return cRetQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetUnion
Metodo que retorna a string do UNION

@author Totvs
/*/
//-------------------------------------------------------------------
method tcRetUnion(cCodCfg as character, cTipo as character, cCpoId as character, cAlias as character,;
                     aCposFil as array, jFilters as json, jBody as Json, aTaxes as Array) class MatchProcessingProtheusData

    Local cRetQuery := ""
    Local cQLDFil   := GetBranchiesForConditional("QLD") as  character

    DEFAULT aTaxes  := {} 

    cRetQuery := " UNION SELECT "
    cRetQuery += ::tcRetSQLExpression(aCposFil, ", ", cCpoId, .F., nil, cAlias, cCodCfg, aTaxes) //Itens da query
    cRetQuery += " FROM "+RetSQLName(cAlias)+" "+cAlias
    cRetQuery += " LEFT JOIN "+RetSQLName("QLD")+" QLD ON "
    cRetQuery +=  cQLDFil
    cRetQuery += " AND QLD_TPITEM = '"+cTipo+"' "
    cRetQuery += " AND QLD_CODCFG = '"+cCodCfg+"' "
    cRetQuery += " AND QLD_IDITEM = CAST("+cCpoId+" AS CHAR("+cValToChar(_nTamUUID)+")) "
    cRetQuery += " AND QLD.D_E_L_E_T_ = ' ' "
    cRetQuery += ::tcRetWhere(jBody["tabori"], "", cTipo, cAlias,"01", cCpoId, jFilters, cCodCfg,)

Return cRetQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} tcValidFields
Metodo que valida se campos utilizados nas condicoes estao presentes
no Select e inclui se necessario

@author Totvs
/*/
//-------------------------------------------------------------------
method tcValidFields(jHeaders as Json, jRegrasMatch as Json, cAliasDes as Character) class MatchProcessingProtheusData
Local nI        := 0  as Numeric
Local nX        := 0  as Numeric
Local aRulesOri := {} as Array
Local aRulesDes := {} as Array
Local aFieldBal := {} as Array
Local lTaxOri  := .F. as Logical
Local lTaxDes  := .F. as Logical

//Verifica todas as regras de Match
For nI := 1 To Len(jRegrasMatch["rules"])
    aRulesOri := StrToArray(jRegrasMatch["rules"][nI]["rule"]["ori_fields"], ",")
    aRulesDes := StrToArray(jRegrasMatch["rules"][nI]["rule"]["des_fields"], ",")

    lTaxOri := _lCpoCfgTrb .And. jRegrasMatch["rules"][nI]["rule"]:hasProperty("ori_taxfields") .And.;
             ValType(jRegrasMatch["rules"][nI]["rule"]["ori_taxfields"]) == "A" .And. Len(jRegrasMatch["rules"][nI]["rule"]["ori_taxfields"]) > 0
    
    lTaxDes := _lCpoCfgTrb .And. jRegrasMatch["rules"][nI]["rule"]:hasProperty("des_taxfields") .And.;
             ValType(jRegrasMatch["rules"][nI]["rule"]["des_taxfields"]) == "A" .And. Len(jRegrasMatch["rules"][nI]["rule"]["des_taxfields"]) > 0

    //Tratamento para campos de origem
    For nX := 1 To Len(aRulesOri)
        //Se for tributo, não adicionar neste momento, serão adicionados na estrutura na tcExecSQLExpress
        If (lTaxOri .And. aScan(jRegrasMatch["rules"][nI]["rule"]["ori_taxfields"], {|x| x = aRulesOri[nX]}) <> 0 )
            Loop
        Else
            If aScan(jHeaders["data_ori"], {|x| x = aRulesOri[nX]}) == 0 .And. !("MSUIDT" $ aRulesOri[nX])
                aAdd(jHeaders["data_ori"], aRulesOri[nX])
            EndIf
        EndIf
    Next nX

    //Tratamento para campos de destino
    For nX := 1 To Len(aRulesDes)
        //Se for tributo, não adicionar neste momento, serão adicionados na estrutura na tcExecSQLExpress
        If (lTaxDes .And. aScan(jRegrasMatch["rules"][nI]["rule"]["des_taxfields"], {|x| x = aRulesDes[nX]}) <> 0 )
            Loop
        Else
            If aScan(jHeaders["data_des"], {|x| x = aRulesDes[nX]}) == 0 .And. !("MSUIDT" $ aRulesDes[nX])
                aAdd(jHeaders["data_des"], aRulesDes[nX])
            EndIf
        EndIf
    Next nX
Next nI

If cAliasDes == "CT2"
    //Tratamento para a consulta de saldos das contas contábeis. Por hora, apenas quando a CT2 é o destino
    
    //Campos utilizados na query da API getaccountbalance (Função getQuery()), são necessários para consultar os saldos
    aAdd(aFieldBal, "CT2_FILIAL")
    aAdd(aFieldBal, "CT2_CREDIT")
    aAdd(aFieldBal, "CT2_DEBITO")
    aAdd(aFieldBal, "CT2_VALOR")
    aAdd(aFieldBal, "CT2_DC")
    aAdd(aFieldBal, "CT2_MOEDLC")

    // Caso não estejam entre os campos selecionados, adicionar o campo no jHeaders para serem incluídos na temporária
    For nI := 1 to Len(aFieldBal)
        If aScan(jHeaders["data_des"], {|x| x = aFieldBal[nI]}) == 0
            aAdd(jHeaders["data_des"], aFieldBal[nI])
        EndIf
    Next nI
EndIf

FwFreeArray(aRulesOri)
FwFreeArray(aRulesDes)
FwFreeArray(aFieldBal)
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} IsEntity
Valida de se o campo é uma entidade contábil
O Where desses campos será montado na função WhereEntity()

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function IsEntity(cCampo as Character)
DEFAULT cCampo := ""
DEFAULT _cCpoEntidades :=   'CT2_DEBITO|'+;
                            'CT2_CREDIT|'+;
                            'CT2_CCD|'+;
                            'CT2_CCC|'+;
                            'CT2_ITEMD|'+;
                            'CT2_ITEMC|'+;
                            'CT2_CLVLDB|'+;
                            'CT2_CLVLCR|'+;
                            'CT2_EC05DB|'+;
                            'CT2_EC05CR|'+;
                            'CT2_EC06DB|'+;
                            'CT2_EC06CR|'+;
                            'CT2_EC07DB|'+;
                            'CT2_EC07CR|'+;
                            'CT2_EC08DB|'+;
                            'CT2_EC08CR|'+;
                            'CT2_EC09DB|'+;
                            'CT2_EC09CR'
Return (cCampo$_cCpoEntidades)

//-------------------------------------------------------------------
/*/{Protheus.doc} RetWhereEntity
Monta a condição Where das entidades contábeis

@author Totvs
/*/
//-------------------------------------------------------------------
Function RetWhereEntity(aWhereArr as Array, cDebCred as Character)
Local nI := 0
Local cWhere  := ""
Local cCampo  := ""
Local cOperation := ""
Local cValue  := ""
Local cDebito := ""
Local cCredit := ""
Local cCCD    := ""
Local cCCC    := ""
Local cItemD  := ""
Local cItemC  := ""
Local cClVlDB := ""
Local cClVlCR := ""
Local cEC05DB := ""
Local cEC05CR := ""
Local cEC06DB := ""
Local cEC06CR := ""
Local cEC07DB := ""
Local cEC07CR := ""
Local cEC08DB := ""
Local cEC08CR := ""
Local cEC09DB := ""
Local cEC09CR := ""

DEFAULT aWhereArr := {}
Default cDebCred  := ''

For nI := 1 to Len(aWhereArr)
    cCampo      := aWhereArr[nI]["field"]
    If IsEntity(cCampo)
        cValue      := aWhereArr[nI]["value"]
        cOperation  := aWhereArr[nI]["operation"]

        If cCampo=="CT2_DEBITO"
            cDebito := RetCondEntity(cCampo, cOperation, cValue, cDebito)
        EndIf

        If cCampo=="CT2_CREDIT"
            cCredit := RetCondEntity(cCampo, cOperation, cValue, cCredit)
        EndIf

        If cCampo=="CT2_CCD"
            cCCD := RetCondEntity(cCampo, cOperation, cValue, cCCD)
        EndIf

        If cCampo$"CT2_CCC"
            cCCC := RetCondEntity(cCampo, cOperation, cValue, cCCC)
        EndIf

        If cCampo=="CT2_ITEMD"
            cItemD := RetCondEntity(cCampo, cOperation, cValue, cItemD)
        EndIf

        If cCampo$"CT2_ITEMC"
            cItemC := RetCondEntity(cCampo, cOperation, cValue, cItemC)
        EndIf

        If cCampo=="CT2_CLVLDB"
            cClVlDB := RetCondEntity(cCampo, cOperation, cValue, cClVlDB)
        EndIf

        If cCampo$"CT2_CLVLCR"
            cClVlCR := RetCondEntity(cCampo, cOperation, cValue, cClVlCR)
        EndIf

        If cCampo=="CT2_EC05DB"
            cEC05DB := RetCondEntity(cCampo, cOperation, cValue, cEC05DB)
        EndIf

        If cCampo$"CT2_EC05CR"
            cEC05CR := RetCondEntity(cCampo, cOperation, cValue, cEC05CR)
        EndIf

        If cCampo=="CT2_EC06DB"
            cEC06DB := RetCondEntity(cCampo, cOperation, cValue, cEC06DB)
        EndIf

        If cCampo$"CT2_EC06CR"
            cEC06CR := RetCondEntity(cCampo, cOperation, cValue, cEC06CR)
        EndIf

        If cCampo=="CT2_EC07DB"
            cEC07DB := RetCondEntity(cCampo, cOperation, cValue, cEC07DB)
        EndIf

        If cCampo$"CT2_EC07CR"
            cEC07CR := RetCondEntity(cCampo, cOperation, cValue, cEC07CR)
        EndIf

        If cCampo=="CT2_EC08DB"
            cEC08DB := RetCondEntity(cCampo, cOperation, cValue, cEC08DB)
        EndIf

        If cCampo$"CT2_EC08CR"
            cEC08CR := RetCondEntity(cCampo, cOperation, cValue, cEC08CR)
        EndIf

        If cCampo=="CT2_EC09DB"
            cEC09DB := RetCondEntity(cCampo, cOperation, cValue, cEC09DB)
        EndIf

        If cCampo$"CT2_EC09CR"
            cEC09CR := RetCondEntity(cCampo, cOperation, cValue, cEC09CR)
        EndIf
    EndIf
Next nI

cWhere += WhereEntity(cDebito, cCredit, cDebCred)
cWhere += WhereEntity(cCCD   , cCCC,    cDebCred)
cWhere += WhereEntity(cItemD , cItemC,  cDebCred)
cWhere += WhereEntity(cClVlDB, cClVlCR, cDebCred)
cWhere += WhereEntity(cEC05DB, cEC05CR, cDebCred)
cWhere += WhereEntity(cEC06DB, cEC06CR, cDebCred)
cWhere += WhereEntity(cEC07DB, cEC07CR, cDebCred)
cWhere += WhereEntity(cEC08DB, cEC08CR, cDebCred)
cWhere += WhereEntity(cEC09DB, cEC09CR, cDebCred)


If !Empty(cWhere)
    cWhere := Left(cwhere,Len(cWhere)-4)
EndIf

Return cWhere

//-------------------------------------------------------------------
/*/{Protheus.doc} RetCondEntity
Retorna a condição SQL para os campos de entidades contábeis

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function RetCondEntity(cCampo as Character, cOperation as Character, cValue as Character, cCondSQL as Character)
Local cRet := ""
Local cRetAux := ""
Local nI   := 0
Local nTamCpo := TamSX3(cCampo)[1]
Local aValue  := {}
Local nTamValue := 0

DEFAULT cCampo    := ""
DEFAULT cOperation:= ""
DEFAULT cValue    := ""
DEFAULT cCondSQL  := ""

cRet := cCondSQL

If cOperation == "IN" .Or. cOperation == "NOT IN"
    If !Empty(cValue)
        If !Empty(cRet)
            cRet += " AND "
        EndIf

        aValue := StrTokArr( cValue , ",")

        cValue := ""

        For nI := 1 to Len(aValue)
            If nI>1
                cValue += ","
            EndIf
            cValue += "'"+PadR(AllTrim(aValue[nI]),nTamCpo)+"'"
        Next

        cRet += cCampo+" "+cOperation+"("+cValue+")"
    EndIf
Else
    cRetAux := ""
    If cOperation == "=" .Or. cOperation == "<>"        
        cRetAux := cCampo+cOperation+"'"+PadR(cValue,nTamCpo)+"'"
    ElseIf ">"$cOperation .And. !Empty(cValue) //Se for branco a zzz eu não coloco no where
        cRetAux := cCampo+cOperation+"'"+PadR(AllTrim(cValue),nTamCpo)+"'"        
    ElseIf "<"$cOperation 
        cValue := AllTrim(cValue)
        nTamValue := Len(cValue)
        If Upper(cValue) <> Replicate("Z",nTamValue) //Se for branco a zzz eu não coloco no where                 
            cRetAux := cCampo+cOperation+"'"+PadR(cValue,nTamCpo)+"'"
        EndIf    
    EndIf
    
    If !Empty(cRetAux) 
        If !Empty(cRet)
            cRet += " AND "        
        EndIf        
        cRet += cRetAux
    EndIf
EndIf

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} WhereEntity
Monta o Where dos grupos de entidade

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function WhereEntity(cDebito as Character, cCredit as Character, cDebCred as Character)
Local cWhere := ""

DEFAULT cDebito := ""
DEFAULT cCredit := ""
DEFAULT cDebCred := ""

If cDebCred == '1' // Condição Débito
    If !Empty(cDebito)
        cWhere := "("+cDebito+") "
    EndIf

    If !Empty(cWhere)
        cWhere := "("+cWhere+") AND "
    EndIf
ElseIf cDebCred == '2' // Condição Crédito
    If !Empty(cCredit)
        cWhere := "("+cCredit+") "
    EndIf

    If !Empty(cWhere)
        cWhere := "("+cWhere+") AND "
    EndIf
Else
    If !Empty(cDebito)
        cWhere := "("+cDebito+") "
    EndIf

    If !Empty(cCredit)
        If !Empty(cWhere)
            cWhere += " OR "
        EndIf
        cWhere += "("+cCredit+") "
    EndIf

    If !Empty(cWhere)
        cWhere := "("+cWhere+") AND "
    EndIf
EndIf

Return cWhere


/*/{Protheus.doc} tcMaxSeqMatch
Retorna o maior sequencial de match da tabela posicionada

@author Totvs
/*/
Function tcMaxSeqMatch(cTable as Character, cCodCfg as Character, cIdRule as Character)
Local cSeqMatch := "0" As Character

Default cTable    := ""
Default cCodCfg   := ""

If ValType(cTable) == "C" .And. !Empty(cTable)
    tcNextSeqMatch(cTable, @cSeqMatch, cIdRule, cCodCfg, .T.)
    While left(cSeqMatch,1)=="0"
        cSeqMatch:=right(cSeqMatch,len(cSeqMatch)-1)
    EndDo

    If Empty(cSeqMatch)
        cSeqMatch := "0"
    EndIf
    TcRefresh(cTable) // Resetar tempo de timeout
EndIf
return cSeqMatch


//-------------------------------------------------------------------
/*/{Protheus.doc} tcConditionalQuery
Metodo que retorna a string de busca utilizando Conditional Query

@author Totvs
/*/
//-------------------------------------------------------------------
method tcConditionalQuery(aConditionalQuery as array, cIdQuery as character, cWhere as character) class MatchProcessingProtheusData
    Local nItem := 0 As Numeric
    Local nX := 0 As Numeric
    Local aTableAux:= {} As Array
    Local cQueryConditional As Character
    Local jTableAux As Json

    for nItem := 1 to len(aConditionalQuery)

        if aConditionalQuery[nItem]['idquery'] == cIdQuery
            if !Empty(cWhere)
                cWhere += ' AND '
            endif
            cQueryConditional = aConditionalQuery[nItem]['query'] // ? precisa tratar a sql. Tem que proteger
            aTableAux = aConditionalQuery[nItem]['tableaux']  // ? se a tabela não existir o que fazemos?

            for nX := 1 to len(aTableAux)
                jTableAux := aTableAux[nX]
                cQueryConditional := strtran(cQUeryConditional, '{'+jTableAux['alias']+'}', RetSQLName(jTableAux['table']))
            next

            if !Empty(cQueryConditional)
                cWhere += ' EXISTS (' + cQueryConditional  +' )'
            Endif
        Endif
    Next

Return cWhere

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetConditionalQuery
Metodo que retorna o array da Conditional Query
@author Totvs
/*/
//-------------------------------------------------------------------
method tcGetConditionalQuery(jRegrasMatch as Json, cOriOrDes as character) class MatchProcessingProtheusData

    Local aConditionalQuery := {} as Array

    If jRegrasMatch:hasproperty("conditionalQuery") .and. jRegrasMatch["conditionalQuery"]:hasproperty(cOriOrDes) .and. !Empty(jRegrasMatch["conditionalQuery"][cOriOrDes])
        aConditionalQuery :=  jRegrasMatch["conditionalQuery"][cOriOrDes]
    Endif

Return aConditionalQuery

/*/{Protheus.doc} tcCheckReconciliation
    Realiza validações antes de exibir os registros para conciliação
    @author Vitor Duca
    @since 13/01/2025
    @version 1.0
    @param cReturn, Character, Mensagem de retorno para localizar as falhas no processo
    @param jBody, Json, Corpo da requisição REST que foi enviado
    @return Logical, Define se a conciliação pode prosseguir
/*/
Method tcCheckReconciliation(cReturn as character, jBody as json) as logical class MatchProcessingProtheusData
    local dLimitReconciliation := Date()    as date

    If _lFk5Fk7 == NIL
        _lFk5Fk7 := (FK5->(FieldPos("FK5_IDFK7")) > 0)
    Endif

    If QLB->QLB_TABDES == "FK5" .And. !_lFk5Fk7
        cReturn := STR0015 + ' ' + QLB->QLB_CODCFG + '.  '  //'Não foi possível carregar a configuração'
        cReturn += STR0016                          //"Para o uso desta configuração é necessário executar a atualização de dicionário para criação do campo FK5_IDFK7."
        return .F.
    Endif

    If ((QLB->QLB_CODCFG == "0024") .Or. ((QLB->(FieldPos("QLB_CFGORI")) > 0) .And. (QLB->QLB_CFGORI == "0024")))
        dLimitReconciliation := SuperGetMV( "MV_DATAREC", .F., "" )

        If Stod(StrTran(jBody["tabdes"][1]["value"], "-", "")) <= dLimitReconciliation ;
            .Or. Stod(StrTran(jBody["tabdes"][2]["value"], "-", "")) <= dLimitReconciliation
            cReturn := STR0017 //"Período informado está abaixo da data limite para conciliação bancária."
            return .F.
        Endif
    Endif
return .t.

//--------------------------------------------------------------------------
/*/{Protheus.doc} FInsertFin
Realiza o Insert de campos específicos da regra 0024 Conciliacao Manual

@author Totvs
/*/
//--------------------------------------------------------------------------
Static Function FInsertFin(cTableTmp as Character) As Character
    Local cError         := ""                                                                 as Character
    Local cBDname        := Upper( TCGetDB() )                                                 as Character
    Local cIsNull        := totvs.protheus.backoffice.ngf.util.FunctionToDb(cBDname, "ISNULL") as Character
    Local cAliasTmp      := IIF( cBDname $ "POSTGRES", "", cTableTmp + "." )                   as Character
    Local cUpdate        := ""                                                                 as Character
    Local lCreditField   := (cTableTmp)->(FieldPos("E5_CREDITO")) > 0                          as Logical
    Local lExistIDFK7    := (cTableTmp)->(FieldPos("FK5_IDFK7")) > 0                           as Logical
    Local lExistKeyBills := .F.                                                                as Logical

    lExistKeyBills :=   (cTableTmp)->(FieldPos("E5_PREFIXO")) > 0 ;
                        .and. (cTableTmp)->(FieldPos("E5_NUMERO")) > 0 ;
                        .and. (cTableTmp)->(FieldPos("E5_PARCELA")) > 0 ;
                        .and. (cTableTmp)->(FieldPos("E5_TIPO")) > 0 ;
                        .and. (cTableTmp)->(FieldPos("E5_CLIFOR")) > 0 ;
                        .and. (cTableTmp)->(FieldPos("E5_LOJA")) > 0

    If lExistIDFK7 .and. lExistKeyBills
        If cBDname $ "POSTGRES|ORACLE"
            cUpdate := "UPDATE " + cTableTmp
            cUpdate += " SET "
            cUpdate +=       "(" + cAliasTmp + "E5_PREFIXO,"
            cUpdate +=       cAliasTmp + "E5_NUMERO,"
            cUpdate +=       cAliasTmp + "E5_PARCELA,"
            cUpdate +=       cAliasTmp + "E5_TIPO,"
            cUpdate +=       cAliasTmp + "E5_CLIFOR,"
            cUpdate +=       cAliasTmp + "E5_LOJA"
            
            If lCreditField
                cUpdate +=       "," +cAliasTmp + "E5_CREDITO "
            Endif

            cUpdate +=                              ") = "
            cUpdate +=      "( SELECT " 
            cUpdate +=               cIsNull + "(FK7.FK7_PREFIX,' '),"
            cUpdate +=               cIsNull + "(FK7.FK7_NUM,' '),"
            cUpdate +=               cIsNull + "(FK7.FK7_PARCEL,' '),"
            cUpdate +=               cIsNull + "(FK7.FK7_TIPO,' '),"
            cUpdate +=               cIsNull + "(FK7.FK7_CLIFOR,' '),"
            cUpdate +=               cIsNull + "(FK7.FK7_LOJA,' ')"
            
            if lCreditField
                cUpdate +=               "," + cIsNull + "(FK8.FK8_CREDIT,' ') "
            Endif

            cUpdate +=           " FROM " + RetSQLName("FK5") + " FK5 "
            cUpdate +=              " LEFT JOIN " + RetSQLName("FK7") + " FK7 "
            cUpdate +=                  "ON FK5.FK5_IDFK7 = FK7.FK7_IDDOC AND FK7.D_E_L_E_T_ = ' ' "
            cUpdate +=              " LEFT JOIN " + RetSQLName("FK8") + " FK8 "
            cUpdate +=                  "ON FK5.FK5_IDMOV = FK8.FK8_IDMOV AND FK8.D_E_L_E_T_ = ' ' "
            cUpdate +=          " WHERE FK5.FK5_IDMOV = " + cTableTmp + ".FK5_IDMOV "
            cUpdate +=              "AND FK5.D_E_L_E_T_ = ' ')"
        Else
            cUpdate := "UPDATE " + cTableTmp
            cUpdate += " SET "
            cUpdate +=       cTableTmp + ".E5_PREFIXO = " + cIsNull + "(FK7.FK7_PREFIX,' '), "
            cUpdate +=       cTableTmp + ".E5_NUMERO = " + cIsNull + "(FK7.FK7_NUM,' '), "
            cUpdate +=       cTableTmp + ".E5_PARCELA = " + cIsNull + "(FK7.FK7_PARCEL,' '), "
            cUpdate +=       cTableTmp + ".E5_TIPO = " + cIsNull + "(FK7.FK7_TIPO,' '), "
            cUpdate +=       cTableTmp + ".E5_CLIFOR = " + cIsNull + "(FK7.FK7_CLIFOR,' '), "
            cUpdate +=       cTableTmp + ".E5_LOJA = " + cIsNull + "(FK7.FK7_LOJA,' ') "

            If lCreditField
                cUpdate +=       ", " + cTableTmp + ".E5_CREDITO = " + cIsNull + "(FK8.FK8_CREDIT,' ') "
            Endif

            cUpdate +=      " FROM " + RetSQLName("FK5") + " FK5 "
            cUpdate +=           " LEFT JOIN " + RetSQLName("FK7") + " FK7 "
            cUpdate +=               "ON FK5.FK5_IDFK7 = FK7.FK7_IDDOC AND FK7.D_E_L_E_T_ = ' ' "
            cUpdate +=           " LEFT JOIN " + RetSQLName("FK8") + " FK8 "
            cUpdate +=               "ON FK5.FK5_IDMOV = FK8.FK8_IDMOV AND FK8.D_E_L_E_T_ = ' ' "
            cUpdate +=      " WHERE FK5.FK5_IDMOV = " + cAliasTmp + "FK5_IDMOV "
            cUpdate +=          "AND FK5.D_E_L_E_T_ = ' ' "

        Endif

        cError := FinExecQuery(cTableTmp, cUpdate, " [UPD] - FINSERTFIN ")
    Endif

Return cError

//--------------------------------------------------------------------------
/*/{Protheus.doc} FinExecQuery
Executa as querys diretamente no banco (Operacoes de UPDATE nas temporarias).

@author Totvs
/*/
//--------------------------------------------------------------------------
Static Function FinExecQuery(cTableTmp as Character, cQuery as Character, cIdentifier as Character) as Character
    Local cError := "" as Character

    Default cTableTmp := ""
    Default cQuery := ""
    Default cIdentifier := " [UPD] "

    If TCSQLExec(cQuery) <> 0
        Conout(TCSQLError())
        cError := STR0011   + STR0012 + cIdentifier //"matchProcessing Error: " "Nao foi possivel inserir dados na tabela temporaria: "
        cError += cTableTmp + STR0007 //". Para mais detalhes, verificar arquivo console.log"
    Else
    	dbCommitAll()
		TcRefresh(cTableTmp)
    Endif
Return cError

//--------------------------------------------------------------------------
/*/{Protheus.doc} tcFillTaxValues
Metodo responsável por preencher os valores de tributos na tabela temporária vindos da F2D.

@author Totvs
/*/
//--------------------------------------------------------------------------
method tcFillTaxValues(cTable as Character, jCfgTrib as JSON) class MatchProcessingProtheusData
    Local cQuery        := "" as Character
    Local cError        := "" as Character
    Local cIdField      := "" as Character
    Local cTribAtu      := "" as Character
    Local cBranchAtu    := "" as Character
    Local cAlias        := "" as Character
    Local cTribCol      := "" as Character
    Local cF2DFil       := GetBranchiesForConditional("F2D")  as character

    Local nI        := 0  as Numeric
    Local nX        := 0  as Numeric

    If ValType(jCfgTrib) == "J" .And. jCfgTrib:hasProperty("idfield") .And. !Empty(jCfgTrib["idfield"])

        cIdField := jCfgTrib["idfield"]
        cAlias  := SubStr(cIdField, 1, 3)
        
        If SubStr(cAlias, 3, 1) == '_'
            cAlias  := "S"+SubStr(cAlias, 1, 2) 
        EndIf

        If _lOracle
        // O Oracle não permite UPDATE ... FROM como no SQL Server/Postgres.
        // Em vez disso, o MERGE é usado para realizar atualizações condicionais (WHEN MATCHED).
        // A subquery inline em USING é usada no lugar de uma CTE, já que Oracle não permite CTE diretamente dentro do MERGE.
            cQuery := " MERGE INTO "+cTable+" "+cAlias+" "+ CRLF
            cQuery += " USING (" + CRLF
        Else
            // Para SQL e Postgres, o UPDATE será feito relacionando uma CTE com um UPDATE
            cQuery := " WITH trb AS (" + CRLF
        EndIf

        // O SELECT é o mesmo para todos os bancos homologados
        cQuery += "     SELECT" + CRLF
        cQuery += "         F2D.F2D_IDREL," + CRLF

        For nI := 1 to Len(jCfgTrib["col_taxes"])
            cTribCol    := "T_" + jCfgTrib["col_taxes"][nI]["field"]
            cQuery += "         SUM(CASE WHEN " + CRLF
            For nX := 1 to Len(jCfgTrib["col_taxes"][nI]["items"])
                cTribAtu    := jCfgTrib["col_taxes"][nI]["items"][nX]["ruletax"]
                cBranchAtu  := jCfgTrib["col_taxes"][nI]["items"][nX]["branch"]

                //Para cada imposto a ser preenchido, é utilizado um CASE WHEN somando o valor do tributo
                If nX == 1
                    cQuery += "             ( F2D.F2D_FILIAL = '"+cBranchAtu+"' AND F2D.F2D_TRIB = '"+cTribAtu+"' ) " + CRLF
                Else
                    cQuery += "             OR " + CRLF
                    cQuery += "             ( F2D.F2D_FILIAL = '"+cBranchAtu+"' AND F2D.F2D_TRIB = '"+cTribAtu+"' ) "+ CRLF 
                EndIf

            Next nX
            cQuery += "         THEN F2D.F2D_VALOR ELSE 0 END) AS "+cTribCol+ " "
            
            If nI < Len(jCfgTrib["col_taxes"])
                cQuery += ", " + CRLF
            EndIf
        Next nI

        //O campo de ID do tributo recebido no cIdField é relacionado com a F2D por meio do F2D_IDREL
        cQuery += "     FROM "+RetSQLName("F2D")+" F2D " + CRLF
        cQuery += "     INNER JOIN "+cTable+" "+cAlias+" " + CRLF
        cQuery += "         ON F2D.F2D_IDREL = "+cAlias+"."+cIdField+" " + CRLF
        cQuery += "             AND "+cAlias+".D_E_L_E_T_ = ' ' " + CRLF
        cQuery += "     WHERE " + CRLF
        cQuery += "         "+cF2DFil+" " + CRLF
        cQuery += "         AND F2D.D_E_L_E_T_ = ' ' " + CRLF 
        cQuery += "     GROUP BY F2D.F2D_IDREL " + CRLF 
        cQuery += " ) " + CRLF 

        // A estrutura do comando de UPDATE é diferente para cada Oracle, Postgres e SQL. O Oracle ira utilizar 
        // o comando MERGE para o UPDATE e 
        If _lOracle
            
            cQuery += " trb " + CRLF 
            cQuery += " ON ("+cAlias+"."+cIdField+" = trb.F2D_IDREL) " + CRLF 
            
            // O comando WHEN MATCHED THEN executa o UPDATE quando a condição do ON é satisfeita.
            cQuery += " WHEN MATCHED THEN " + CRLF 
            cQuery += "     UPDATE SET " + CRLF 
            
            For nI := 1 to Len(jCfgTrib["col_taxes"])
                cTribCol    := "T_" + jCfgTrib["col_taxes"][nI]["field"]

                cQuery += "         "+cAlias+"."+cTribCol+" = trb."+cTribCol+" "  

                If nI < Len(jCfgTrib["col_taxes"])
                    cQuery += ", " + CRLF
                EndIf
            Next nI

            cQuery += " WHERE "+cAlias+".D_E_L_E_T_ = ' '" + CRLF 

        ElseIf _lPostgres

            // O PostgreSQL não permite acessar CTE diretamente no WHERE de um UPDATE, 
            // mas suporta UPDATE ... FROM, que permite atualizar usando resultados externos.

            // UPDATE: necessário usar o nome real da tabela no Postgres.
            cQuery += " UPDATE "+cTable+" " + CRLF 
            cQuery += " SET " + CRLF 

            For nI := 1 to Len(jCfgTrib["col_taxes"])
                cTribCol    := "T_" + jCfgTrib["col_taxes"][nI]["field"]

                cQuery += "         "+cTribCol+" = trb."+cTribCol+" "  

                If nI < Len(jCfgTrib["col_taxes"])
                    cQuery += ", " + CRLF
                EndIf
            Next nI

            // FROM trb: indica de onde vêm os dados de atualização.
            // WHERE: faz o "match" com base na chave (cIdField (EX: D1_IDTRIB) = F2D_IDREL).

            cQuery += "         FROM trb " + CRLF
            cQuery += "         WHERE trb.F2D_IDREL = "+cTable+"."+cIdField+"" + CRLF 
        Else // SQL Server

            // O SQL Server suporta UPDATE ... FROM ... JOIN diretamente, o que permite combinar a CTE com a tabela temporaria.
            cQuery += " UPDATE "+cAlias+" " + CRLF 
            cQuery += " SET " + CRLF 

            For nI := 1 to Len(jCfgTrib["col_taxes"])
                cTribCol    := "T_" + jCfgTrib["col_taxes"][nI]["field"]

                cQuery += "         "+cAlias+"."+cTribCol+" = trb."+cTribCol+" "  

                If nI < Len(jCfgTrib["col_taxes"])
                    cQuery += ", " + CRLF
                EndIf
            Next nI

            // Para usar dados de um CTE, necessário trazer o CTE no FROM e fazer o JOIN para o "match" entre CTE e a tabela temporária.
            cQuery += "         FROM "+cTable+" "+cAlias+" " + CRLF
            cQuery += "         INNER JOIN trb ON trb.F2D_IDREL = "+cAlias+"."+cIdField+";" + CRLF 
        EndIf

        If TcSqlExec(cQuery) <> 0
            cError := STR0018//"Erro na consulta dos valores de tributos. Para mais detalhes, verificar arquivo console.log"
            conout(TCSqlError(), cError)
        EndIf
    EndIf 

Return cError
