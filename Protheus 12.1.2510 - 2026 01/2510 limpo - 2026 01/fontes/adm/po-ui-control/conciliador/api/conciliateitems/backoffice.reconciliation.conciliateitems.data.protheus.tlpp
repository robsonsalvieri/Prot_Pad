#include "tlpp-core.th"
#include "backoffice.reconciliation.conciliateitems.data.protheus.ch"

namespace totvs.protheus.backoffice.reconciliation.conciliateitem
using namespace totvs.protheus.backoffice.reconciliation.util

static _lCpoCfgTrb

//-------------------------------------------------------------------
/*/{Protheus.doc} ConciliateItemsProtheusData
Classe responsável pela consulta de dados

@author Totvs
/*/
//-------------------------------------------------------------------
class ConciliateItemsProtheusData from FWAdapterBaseV2
    Public method new()
    Public method getAll()
    Public method getAllFilter()
    static method getData() As object
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} ConciliateItemsProtheusData
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new(cVerbo as Character, lList as Logical) Class ConciliateItemsProtheusData
    Default cVerbo := "GET"
    Default lList  := .T.
    _Super:New(cVerbo, lList)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} ConciliateItemsProtheusData
Método para chamada e validação do tratamento de dados

@author Totvs
/*/
//-------------------------------------------------------------------
method getData() class ConciliateItemsProtheusData As Object
    static __oActiveData As Object

    If ValType(__oActiveData) == "U"
        __oActiveData := ConciliateItemsProtheusData():new()
    EndIf
return __oActiveData

//-------------------------------------------------------------------
/*/{Protheus.doc} getAll
Metodo responsável pela busca das configuracoes do conciliador

@author Totvs
/*/
//-------------------------------------------------------------------
method getAll(cTable as Character, nPage as Numeric, nPageSize as Numeric, aFieldsApi as Array,; 
                cSort as Character, aUrlFilter as Array, cMatch as Character, cFormatDate as Character,;
                lExcel as Logical, jBody as Json, cCodCfg as Character, cTypeTable as Character) class ConciliateItemsProtheusData
    Local aArea  := GetArea() As Array
    Local cWhere := "" As Character

    DEFAULT cTable     := ""
    DEFAULT nPage      := 1
    DEFAULT nPageSize  := 10
    DEFAULT cSort      := ""
    DEFAULT aUrlFilter := {}
    DEFAULT cMatch     := ""
    DEFAULT cFormatDate:= ""
    DEFAULT lExcel     := .F.
    DEFAULT cCodCfg    := ""
    DEFAULT cTypeTable := ""

    If TCCanOpen(cTable)

        AddMapFields(self,cTable,aFieldsApi,cFormatDate,lExcel,cCodCfg,cTypeTable)

        ::setPage(nPage)
        ::setPageSize(nPageSize)
        ::SetQuery(GetQuery(cTable))
            
        cWhere := "D_E_L_E_T_ = ' ' "
        cWhere += InterceptFilter(aUrlFilter, cMatch, jBody)

        ::SetWhere(cWhere)
        ::SetOrder("R_E_C_N_O_")   
        
        If !Empty(cSort)            
            ::SetOrderQuery(cSort)        
        EndIf
            
        If Len(aUrlFilter) > 0                       
            ::SetUrlFilter(aUrlFilter)
        EndIf
        
        If TCCanOpen(cTable) // Segunda camada de proteção
            If ::Execute()
                ::FillGetResponse()
            EndIf
        EndIf

        TcRefresh(cTable) // Resetar tempo de timeout
    EndIf

    RestArea(aArea)
    FwFreeArray(aArea)    
return

//-------------------------------------------------------------------
/*/{Protheus.doc} AddMapFields
Realiza o mapeamento dos campos que serão retornados

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function AddMapFields(oSelf as Object, cTable as Character, aFieldsApi as Array,cFormatDate as Character, lExcel as Logical,;
    cCodCfg as Character, cTypeTable as Character)
    Local aStructTmp := {} As Array
    Local cAliasAux  := "" As Character
    Local cALiasOld  := "" As Character
    Local cField     := "" As Character
    Local cTipo      := "" As Character
    Local cWidth     := "" As Character
    Local cOrdem     := "" As Character
    Local cTitulo    := "" As Character  
    Local cConcat    := "" As Character  
    Local cTypeMatch := "" As Character 
    Local nTamanho   := 0  As Numeric
    Local nDecimal   := 0  As Numeric   
    Local nI         := 0  As Numeric
    Local cDataBase  := Alltrim(TcGetDB())
    Local lPostgres := IIf(cDataBase$"POSTGRES", .T., .F.) as Logical
    Local cSubStr   := IIf('SQL'$cDataBase,'SUBSTRING','SUBSTR')
    Local nTamF2DVal    := 0
    Local nDecF2DVal    := 0
    
    If !Empty(cTable)
        cConcat := tcRetConcat()
        cAliasAux := GetNextAlias()
        DBUseArea( .T., "TOPCONN", cTable, (cAliasAux), .T., .T. )
        If Select(cAliasAux) > 0
            aStructTmp := (cAliasAux)->(dbStruct())
            (cAliasAux)->(dbCloseArea())
        EndIf        
        
        For nI := 1 to Len(aStructTmp)

            If nI == 1 
                cOrdem := "01"
                oSelf:AddMapFields(Iif(lExcel,STR0001,"RECONCILED"), "RECONCILED", .T., .F., {"RECONCILED", "C", 1, 0}, "TMP.RECONCILED")

                //Adiciona informacoes do dicionario - SX3 dos campos                
                aAdd(aFieldsApi, {  cOrdem,;
                                    "reconciled",;
                                    STR0001,; //"Conciliado"
                                    "C",;
                                    1,;
                                    0,;
                                    "",;
                                    "100px",;
                                    "" })
                
                cOrdem := "02"

                If lPostgres
                    cTypeMatch += "CAST( "
                EndIf

                cTypeMatch += "CASE "
                cTypeMatch += " WHEN TMP.COMPARISON = 'AD' THEN 'AD'" // Automático Divergente
                cTypeMatch += " WHEN TMP.COMPARISON = 'MD' THEN 'MD'" // Manual Divergente
                cTypeMatch += " WHEN TMP.REGMATCH = '"+Replicate("9", ( TamSx3("QLD_REGMATCH")[1] - 1)) + "8" +"' THEN 'I'"
                cTypeMatch += " WHEN TMP.REGMATCH = '"+Replicate("9", TamSx3("QLD_REGMATCH")[1])+"' THEN 'M' "
                cTypeMatch += " WHEN TMP.REGMATCH <> '"+Space(TamSx3("QLD_REGMATCH")[1])+"' THEN 'A'"
                cTypeMatch += "ELSE '' END"

                If lPostgres 
                    cTypeMatch += " AS CHAR(2))"
                EndIf             

               oSelf:AddMapFields(Iif(lExcel,STR0002,"TYPEMATCH"), "TYPEMATCH", .T., .F., {"TYPEMATCH", "C", 2, 0}, cTypeMatch)

                //Adiciona informacoes do dicionario - SX3 dos campos                
                aAdd(aFieldsApi, {  cOrdem,;
                                    "typematch",;
                                    STR0002,; //"Tipo Match"
                                    "C",;
                                    1,;
                                    0,;
                                    "",;
                                    "120px",;
                                    "" })

                cOrdem := "03"   
                oSelf:addMapFields(Iif(lExcel,STR0003,"codcon"), "codcon", .T., .F., {"codcon", "C", TamSx3("QLD_CODCON")[1], 0}, "TMP.CODCON")

                //Adiciona informacoes do dicionario - SX3 dos campos                
                aAdd(aFieldsApi, {  cOrdem,;
                                    "codcon",;
                                    STR0003,; //"Cd. Concilia"
                                    "C",;
                                    10,;
                                    0,;
                                    "",;
                                    "100px",;
                                    "" })
                
                cOrdem := "04"
                oSelf:AddMapFields(Iif(lExcel,STR0004,"IDMATCH"), "IDMATCH", .T., .F., {"IDMATCH", "C", 13, 0}, "TMP.IDMATCH")

                //Adiciona informacoes do dicionario - SX3 dos campos                
                aAdd(aFieldsApi, {  cOrdem,;
                                    "idmatch",;
                                    STR0004,; //"Id Match"
                                    "C",;
                                    14,;
                                    0,;
                                    "999.9999999999",;
                                    "140px",;
                                    "" })  
            EndIf
            
            cField := aStructTmp[nI,1]

            If cField$"REGMATCH|DESMATCH|SEQMATCH|RECONCILED|IDMATCH|TYPEMATCH"
                Loop
            EndIf

            cAliasAux := FwTabPref(cField)

            If _lCpoCfgTrb == NIL
                _lCpoCfgTrb := QLB->(FieldPos("QLB_CFGTRB")) > 0 .And. !Empty(cCodCfg) .And. !Empty(cTypeTable);
                 .And. FWAliasInDic("F2D", .F.)
            EndIf

            If cAliasAux == "T" .And. _lCpoCfgTrb //CFGTRIB
                //Retorna o tipo do campo no SX3
                cTipo    := "N"

                If nTamF2DVal == 0
                    nTamF2DVal  := TamSX3("F2D_VALOR")[1]
                    nDecF2DVal  := TamSX3("F2D_VALOR")[2]
                EndIf
                
                nTamanho := nTamF2DVal
                nDecimal := nDecF2DVal

                cTitulo := TCGetTribTitle(cField, cCodCfg, cTypeTable, .T.)
                nTamTit  := Len(cTitulo)
            Else 
                //Retorna o tipo do campo no SX3
                cTipo    := FWSX3Util():GetFieldType(aStructTmp[nI,1])
                
                nTamanho := aStructTmp[nI,3]
                nDecimal := aStructTmp[nI,4]
                nTamTit  := Len(AllTrim(FWX3Titulo(cField)))
            EndIf

            If nTamTit < 10 .And. nTamanho < 10
                //DEFAULT - Tratamento para campos pequenos
                cWidth := "100px"
            Else
                If nTamTit > nTamanho
                    cWidth := CValToChar(nTamTit * 12) + "px"
                Else
                    cWidth := CValToChar(nTamanho * 12) + "px"
                EndIf            
            EndIf

            If cAliasOld <> cAliasAux .And. !Empty(cAliasAux) .And. cAliasAux <> "T" //CFGTRIB   

                If !AliasInDic(cAliasAux)        
                    Loop //Prevenção de erros
                EndIf
                
                dbSelectArea(cAliasAux)                
                cAliasOld := cAliasAux
            EndIf                       

            If cField <> "CODCON"
                If cTipo=="D" .And. cFormatDate=="1"                    
                    oSelf:AddMapFields(Iif(lExcel .and. !Empty(AllTrim(FWX3Titulo(cField))),AllTrim(FWX3Titulo(cField)),cField), cField, .T., .F., {cField, "C", nTamanho, nDecimal},; 
                                        cSubStr+"(TMP."+cField+",7,2)"+cConcat+"'/'"+cConcat+;
                                        cSubStr+"(TMP."+cField+",5,2)"+cConcat+"'/'"+cConcat+;
                                        cSubStr+"(TMP."+cField+",1,4)")                    
                Else
                    If cAliasAux == "T" .And. _lCpoCfgTrb  //CFGTRIB
                        oSelf:AddMapFields(cField, cField, .T., .F., {cField, cTipo, nTamanho, nDecimal}, "TMP."+cField)
                    Else
                        oSelf:AddMapFields(Iif(lExcel .and. !Empty(AllTrim(FWX3Titulo(cField))) ,AllTrim(FWX3Titulo(cField)),cField), cField, .T., .F., {cField, cTipo, nTamanho, nDecimal}, "TMP."+cField)
                    EndIf
                EndIf
            EndIf


            //Adiciona informacoes do dicionario - SX3 dos campos
            If !("_MSUID"$cField) .And. cField <> "CODCON"                  
                cOrdem  := Soma1(cOrdem)
                
                If cAliasAux <> "T" .Or. !_lCpoCfgTrb //CFGTRIB
                    cTitulo := FWX3Titulo(cField)                          
                    aAdd(aFieldsApi, { cOrdem,;
                                    AllTrim(Lower(cField)),;
                                    AllTrim(If(Empty(cTitulo), Lower(cField), cTitulo)),;
                                    cTipo,;
                                    nTamanho,;
                                    nDecimal,;
                                    AllTrim(X3Picture(cField)),;
                                    cWidth})                        
                Else
                    aAdd(aFieldsApi, { cOrdem,;
                                    AllTrim(Lower(cField)),;
                                    AllTrim(If(Empty(cTitulo), Lower(cField), cTitulo)),;
                                    cTipo,;
                                    nTamanho,;
                                    nDecimal,;
                                    AllTrim(X3Picture("F2D_VALOR")),;
                                    cWidth})                        

                EndIf

            EndIf            
        Next

        TcRefresh(cTable)// Resetar tempo de timeout
        
    EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} GetQuery
Realiza a query para busca de informações

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function GetQuery(cTableTmp) As Character
    Local cQuery As Character

    cQuery := " SELECT #QueryFields#"
    cQuery += " FROM " + cTableTmp + ' TMP '
    cQuery += " WHERE #QueryWhere#"
Return cQuery

//-------------------------------------------------------------------
/*/{Protheus.doc} InterceptFilter
Intercepta os filtros para tratamento de campos que não existem nos
temporários, aqueles que são gerados por case ou campos concatenados
e like realizado sem o método ::SetUrlFilter

@author Totvs
/*/
//-------------------------------------------------------------------
Static Function InterceptFilter(aUrlFilter as Array, cMatch as Character, jBody as Json) as Character    
    Local cFilter   := "" as Character
    Local cWhereAux := "" as Character
    Local cField    := "" as Character    
    Local nAt       := 0  as Numeric    
    Local nI        As Numeric

    //Tratamentos para filtro composto
    If Valtype(jBody) == "J" .And. ValType(jBody["fields"]) == "A"       
        For nI := 1 To Len(jBody["fields"])
            cFilter := StrTran(jBody["fields"][nI]["value"],"'","")
            If cFilter <> '' // Só adiciona o filtro se tiver valor
                If "typematch" $ Lower(jBody["fields"][nI]["field"])   
                    If "A" = cFilter
                        cWhereAux += " AND TMP.REGMATCH <> '"+Replicate("9", TamSx3("QLD_REGMATCH")[1])+"' AND TMP.REGMATCH <> ' ' AND COMPARISON <> 'AD' AND COMPARISON <> 'MD' "
                    ElseIf "M" = cFilter
                        cWhereAux += " AND TMP.REGMATCH = '"+Replicate("9", TamSx3("QLD_REGMATCH")[1])+"' "
                    ElseIf "AD" = cFilter .Or. "MD" = cFilter
                        cWhereAux += " AND COMPARISON = '"+cFilter+"'"
                    EndIf                  
                ElseIf "reconciled" $ Lower(jBody["fields"][nI]["field"])        
                    cWhereAux += " AND TMP.IDMATCH <> ' ' AND TMP.RECONCILED = '"+cFilter+"'"       
                Else
                    If "idmatch" $ Lower(jBody["fields"][nI]["field"])
                        cWhereAux += " AND TMP.IDMATCH LIKE ('%"+cFilter+"%')"
                    Else //Tratamento para campos numericos 
                        //Aplica filtro match
                        If AllTrim(cMatch) == "1" //Apenas registros com match
                            cWhereAux += " AND TMP.IDMATCH <> ' ' "
                        ElseIf AllTrim(cMatch) == "2" //Apenas registros sem match
                            cWhereAux += " AND TMP.IDMATCH = ' ' "
                        EndIf 
                        cField := Upper(StrTran(jBody["fields"][nI]["field"],"'",""))
                        If Len(TamSX3(cField)) > 0 
                            If TamSX3(cField)[3] == "N"
                                cFilter := StrTran(cFilter,".","") //Remove pontos desnecessarios
                                cFilter := StrTran(cFilter,",",".") //Transforma virgula em ponto, tratamento de banco de dados
                                cWhereAux += " AND "+cField+" = '"+CValToChar(Val(cFilter))+"'"
                            ElseIf cField == "CT2_HIST"
                                cWhereAux += " AND "+cField+" LIKE '%"+Upper(cFilter)+"%'"
                            Else
                                cWhereAux += " AND "+cField+" = '"+cFilter+"'"
                            EndIf
                        EndIf
                    EndIf   
                EndIf
            EndIf
        Next nI
    Else
        //Aplica filtro match
        If AllTrim(cMatch) == "1" //Apenas registros com match
            cWhereAux += " AND TMP.REGMATCH <> '"+Space(TamSx3("QLD_REGMATCH")[1])+"' "
        ElseIf AllTrim(cMatch) == "2" //Apenas registros sem match
            cWhereAux += " AND TMP.REGMATCH = '"+Space(TamSx3("QLD_REGMATCH")[1])+"' "
        EndIf 
        //Tratamentos para ::SetUrlFilter
        If ValType(aUrlFilter) == "A" .And. Len(aUrlFilter) > 0
            If "typematch" $ Lower(aUrlFilter[1][2])
                If "'A'" $ aUrlFilter[1][2]
                    aUrlFilter[1][2] := "typematch eq 'A'"            
                ElseIf "'M'" $ aUrlFilter[1][2]
                    aUrlFilter[1][2] := "typematch eq 'M'"         
                ElseIf "'AD'" $ aUrlFilter[1][2]
                    aUrlFilter[1][2] := "typematch eq 'AD'"     
                ElseIf "'MD'" $ aUrlFilter[1][2]
                    aUrlFilter[1][2] := "typematch eq 'MD'"  
                EndIf        
            Else 
                nAt := At(",", aUrlFilter[1][2])
                cFilter := AllTrim(SubStr(aUrlFilter[1][2], nAt+1))
                cFilter := SubStr(cFilter, 1, Len(cFilter)-1)
                cFilter := StrTran(cFilter,"'","")
                
                If "idmatch" $ Lower(aUrlFilter[1][2])
                    cWhereAux += " AND TMP.IDMATCH LIKE ('%"+cFilter+"%')"
                    aUrlFilter := {} //Limpa array para nao utilizar método ::SetUrlFilter
                Else //Tratamento para campos numericos                               
                    nAt    := At("(",aUrlFilter[1][2])+1 //Posicao inicial do campo
                    cField := AllTrim(SubStr(aUrlFilter[1][2], nAt))
                    nAt    := At(",",cField)-1 //Posicao final do campo 
                    cField := AllTrim(Upper(SubStr(cField, 1, nAt)))

                    If Len(TamSX3(cField)) > 0 .And. TamSX3(cField)[3] == "N"
                        cFilter := StrTran(cFilter,".","") //Remove pontos desnecessarios
                        cFilter := StrTran(cFilter,",",".") //Transforma virgula em ponto, tratamento de banco de dados
                        cWhereAux += " AND "+cField+" = '"+CValToChar(Val(cFilter))+"'"
                        aUrlFilter := {} //Limpa array para nao utilizar método ::SetUrlFilter
                    EndIf                  
                EndIf                      
            EndIf
        EndIf
    EndIf    
Return cWhereAux
