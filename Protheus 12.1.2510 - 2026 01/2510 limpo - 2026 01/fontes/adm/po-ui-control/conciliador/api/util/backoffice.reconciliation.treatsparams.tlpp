#include "tlpp-core.th"
#include "backoffice.reconciliation.treatsparams.ch"

namespace totvs.protheus.backoffice.reconciliation.util
using namespace totvs.protheus.backoffice.reconciliation.userprofile
using namespace totvs.protheus.backoffice.reconciliation.matchreconciliate

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetPageAndPageSize
Retorna pagina e tamanho da pagina para a consulta
@param nPage: página
@param nPage: Tamanho da página

@author Totvs
/*/
//-------------------------------------------------------------------
Function tcGetPageAndPageSize(nPage as Numeric, nPageSize as Numeric)
    If (oRest:getQueryRequest():GetJsonText("pageSize") != "null")
        nPageSize := Val(oRest:getQueryRequest():GetJsonText("pageSize"))
    EndIf

    If (oRest:getQueryRequest():GetJsonText("page") != "null")
        nPage := Val(oRest:getQueryRequest():GetJsonText("page"))
    EndIf
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetHeaders
Retorna as Empresa e Filial utilizadas

@author Totvs
/*/
//-------------------------------------------------------------------
Function tcGetHeaders()
    Local cFilAtu      As Character
    Local aHeadersApi  As Array

    If (oRest:getHeaderRequest():GetJsonText("tenantId") != "null")
        aHeadersApi := StrTokArr(oRest:getHeaderRequest():GetJsonText("tenantId"), ",")

        //Altera Empresa e Filial
        If ValType(aHeadersApi) == "A" .And. Len(aHeadersApi) > 1
            cFilAtu := Upper(AllTrim(aHeadersApi[2]))

            If FWFilExist(cEmpAnt, cFilAtu) //Verifica se encontrou Empresa-Filial
                cFilAnt := cFilAtu
            EndIf
        EndIf
    EndIf
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetFilters
Retorna filtros enviados na chamada da API
@param cFilters: Filtros

@author Totvs
/*/
//-------------------------------------------------------------------
Function tcGetFilters()
    Local aUrlFilter  As Array

    If (oRest:getQueryRequest():GetJsonText("filter") != "null")
        aUrlFilter := { ;
                        {"FILTER", DecodeUtf8(oRest:getQueryRequest():GetJsonText("filter"))};
                      }
    EndIf
Return aUrlFilter

//-------------------------------------------------------------------
/*/{Protheus.doc} tcTreatsFilter
Classe para tratar os filtros para tabelas de origem x destino
Utiliza a tabela QLB

@author Totvs
/*/
//-------------------------------------------------------------------
class tcTreatsFilter
// Declaração das Propriedades da Classe
private Data jFilter     As Json
private Data nPosJson    As Numeric
private Data aFilters    As Array
Private Data aJsonFields As Array
private Data cField      As Character

// Declaração dos Métodos da Classe
public method New() CONSTRUCTOR
public method tcPutFieldSettings()
public method tcGetStruct()
public method tcClearObjects()
public method tcKillObjects()
public method tcSetStruct()
private method tcGetFieldSettings()
endclass

//-------------------------------------------------------------------
/*/{Protheus.doc} tcTreatsFilter
Metodo construtor

@author Totvs
/*/
//-------------------------------------------------------------------
method new() class tcTreatsFilter
::jFilter     := JsonObject():new()
::aFilters    := {}
::aJsonFields := {}
::cField      := ""
return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcPutFieldsSettings
Inserts the setting fields in the json object

@author Totvs
/*/
//-------------------------------------------------------------------
method tcPutFieldSettings(jResposta As Json, jProfile as Json) class tcTreatsFilter
Local nI As Numeric
Local cFilter As Character
Local aFilters := {} As Array
Local uRet

Default jResposta := JsonObject():new()
Default jProfile  := JsonObject():new()

aFilters := AddFiltersProfile(jProfile)

For nI := 1 to Len(jResposta["items"])
    cFilter := jResposta["items"][nI]["filter"]

    If !Empty(cFilter)
        uRet := ::jFilter:fromJson(cFilter)

        If ValType(uRet) == "U"
            ::tcGetFieldSettings(jResposta, nI, aFilters)

            If ValType(jProfile["totalLedger"]) == "L"
                jResposta["items"][Len(jResposta["items"])]["filter"]["totalLedger"] := jProfile["totalLedger"]
            EndIf
        EndIf
    EndIf
Next

//Destroi objetos da classe
::tcKillObjects()
return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetFieldSettings
Search and add field's settings

@author Totvs
/*/
//-------------------------------------------------------------------
method tcGetFieldSettings(jResposta as Json, nPosJson as Numeric, aFiltersProfile as Array) class tcTreatsFilter
Local nPos   As Numeric
Local nI     As Numeric
Local cValue As Character

If ValType(::jFilter) <> "U"
    jResposta["items"][nPosJson]["filter"] := JsonObject():new()
    ::tcClearObjects() //Limpa objetos

    //Tabela origem
    For nI := 1 to Len(::jFilter["tabori"])
        aAdd(::aFilters, JsonObject():new())
        nPos := Len(::aFilters)
        ::aFilters[nPos] := ::jFilter["tabori"][nI]

        cValue := ""
        If Len(aFiltersProfile) > 0
            cValue := GetFiltersValue(1, ::aFilters[nPos]["field"], ::aFilters[nPos]["operation"], aFiltersProfile)
        EndIf

        ::aFilters[nPos]["value"] := cValue
        ::cField := ::aFilters[nPos]["field"]//Armazena campo

        ::tcSetStruct() //Insere informacoes SX3 do campo
    Next

    If Len(::aFilters) > 0
        jResposta["items"][nPosJson]["filter"]["tabori"] := AClone(::aFilters)
    EndIf

    ::tcClearObjects() //Limpa objetos

    //Tabela destino
    For nI := 1 to Len(::jFilter["tabdes"])
        aAdd(::aFilters, JsonObject():new())
        nPos := Len(::aFilters)
        ::aFilters[nPos] := ::jFilter["tabdes"][nI]

        cValue := ""
        If Len(aFiltersProfile) > 0
            cValue := GetFiltersValue(2, ::aFilters[nPos]["field"], ::aFilters[nPos]["operation"], aFiltersProfile)
        EndIf

        ::aFilters[nPos]["value"] := cValue
        ::cField := ::aFilters[nPos]["field"]//Armazena campo

        ::tcSetStruct() ////Insere informacoes SX3 do campo
    Next

    If Len(::aFilters) > 0
        jResposta["items"][nPosJson]["filter"]["tabdes"] := AClone(::aFilters)
    EndIf
EndIf
FwFreeArray(aFiltersProfile)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetStruct
Returns table´s struct

@author Totvs
/*/
//-------------------------------------------------------------------
method tcGetStruct(cSql as Character) class tcTreatsFilter
Local nAt               as Numeric
Local nI                as Numeric
Local cFields           as Character
Local aStructAux := {}  as Array
Local aFldStrAux := {}  as Array
Local aFields    := {}  as Array

DEFAULT cSql    := ""

If !Empty(cSql) //Query enviada por parametro
    nAt := At("SELECT", cSql)+6 //Posicao inicial
    cFields := SubStr(cSql, nAt, Len(cSql))

    nAt := At("FROM", cFields)-1 //Posicao final
    cFields := SubStr(cFields, 1, nAt)

    aFields := StrTokArr2(cFields, ",") //Armazena campos em array

    If Len(aFields) > 0
        For nI := 1 To Len(aFields)
            aFldStrAux := FWSX3Util():GetFieldStruct( AllTrim( StrTran(aFields[nI],"'","") ) )
            If Len(aFldStrAux) > 0
                aAdd(aStructAux, aFldStrAux)
            EndIf
        Next
    EndIf
EndIf

//Limpa arrays
FwFreeArray(aFldStrAux)
FwFreeArray(aFields)
return aClone(aStructAux)

//-------------------------------------------------------------------
/*/{Protheus.doc} tcSetStruct
Insert field´s properties

@author Totvs
/*/
//-------------------------------------------------------------------
method tcSetStruct(aHeader as Array) class tcTreatsFilter
Local nPosFilter := 0 as Numeric
Local nLenJson   := 0 as Numeric
Local nI         := 0 as Numeric
Local uComboBox  as Variant
Local aArea := GetArea() as Array
Local aFieldStru := {}

If ValType(aHeader) <> "U" .And. Len(aHeader) > 0
    ::tcClearObjects() //Limpa objetos

    //Carrega campos do Header
    For nI := 1 To Len(aHeader)
        uComboBox := tcGetComboBox(aHeader[nI, 2])
        uComboBox := If(ValType(uComboBox) == "A" .And. Len(uComboBox) > 0, uComboBox, "")
        nLenJson++

        aAdd(::aJsonFields, JsonObject():new())
        ::aJsonFields[nLenJson]["order"]   := aHeader[nI, 1]
        ::aJsonFields[nLenJson]["field"]   := AllTrim(aHeader[nI, 2])
        ::aJsonFields[nLenJson]["title"]   := AllTrim(aHeader[nI, 3])
        ::aJsonFields[nLenJson]["type"]    := AllTrim(aHeader[nI, 4])
        ::aJsonFields[nLenJson]["size"]    := aHeader[nI, 5]
        ::aJsonFields[nLenJson]["decimal"] := aHeader[nI, 6]
        ::aJsonFields[nLenJson]["picture"] := AllTrim(aHeader[nI, 7])
        ::aJsonFields[nLenJson]["width"]   := aHeader[nI, 8]
        ::aJsonFields[nLenJson]["cbox"]    := uComboBox
    Next
ElseIf ValType(::cField) <> "U" .And. !Empty(::cField)
    nPosFilter := Len(::aFilters)
    aFieldStru := FWSX3Util():GetFieldStruct( ::cField )

    If Len(aFieldStru) > 0
        uComboBox := tcGetComboBox(::cField)
        uComboBox := If(ValType(uComboBox) == "A" .And. Len(uComboBox) > 0, uComboBox, "")

        ::aFilters[nPosFilter]["title"]   := AllTrim(FWX3Titulo(::cField))
        ::aFilters[nPosFilter]["type"]    := aFieldStru[2]
        ::aFilters[nPosFilter]["size"]    := aFieldStru[3]
        ::aFilters[nPosFilter]["decimal"] := aFieldStru[4]
        ::aFilters[nPosFilter]["picture"] := AllTrim(X3Picture(::cField))
        ::aFilters[nPosFilter]["width"]   := CValToChar(aFieldStru[3] * 10) + "px"
        ::aFilters[nPosFilter]["cbox"]    := uComboBox
    EndIf
EndIf

//Restaura area
RestArea(aArea)
return ::aJsonFields

//-------------------------------------------------------------------
/*/{Protheus.doc} tcClearObjects
Clear classe's objects

@author Totvs
/*/
//-------------------------------------------------------------------
method tcClearObjects() class tcTreatsFilter
aSize(::aFilters, 0)
aSize(::aJsonFields, 0)
return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcKillObjects
Destroys classe´s object tcTreatsFilter

@author Totvs
/*/
//-------------------------------------------------------------------
method tcKillObjects() class tcTreatsFilter
FwFreeArray(::aFilters)
FwFreeArray(::aJsonFields)
::jFilter     := Nil
return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetQryParams
Retorna conteudo dos parametros enviados
@param cQryParams: conteudo do parametro

@author Totvs
/*/
//-------------------------------------------------------------------
Function tcGetQryParams(cNameParam)
    Local cQryParams := ""

    If (oRest:getQueryRequest():GetJsonText(cNameParam) != "null")
        cQryParams := oRest:getQueryRequest():GetJsonText(cNameParam)
    EndIf
Return cQryParams

/*/{Protheus.doc} tcSetMatchManual
Retorna a proxima sequencia disponivel na temporaria

@author Totvs
/*/
Function tcNextSeqMatch(cTable As Character, cSeqMatch As Character, cRegMatch As Character, cCodCfg As Character, lMatchPrc as Logical)
    Local cQuery    := ""       As Character
	Local cSeqMtQLC := ""       As Character
	Local cSeqMtTbl := ""       As Character
    Local cCodConc  := ""       As Character
    Local nTamSeqMatch := ""    As Character
    Local nQry      := 0        As Numeric
	Local oSeqQLC	:= NIL      As Object
	Local oSeqTbl	:= NIL      As Object

	Default cTable      := ""
	Default cRegMatch   := "999"
    Default cSeqMatch   := ""
    Default cCodCfg     := ""
    Default lMatchPrc   := .F. // Chamada da matchprocessing
    
	nTamSeqMatch := TamSx3("QLD_SEQMAT")[1]

    //Verifica se ja existe conciliação e reutiliza o sequencial
    If FindFunction("totvs.protheus.backoffice.reconciliation.matchreconciliate.tcGetUserSession")
        cCodConc := tcGetUserSession(cCodCfg)
    Endif

	If !Empty(cCodConc) .and. !tcGetFilterSession(cCodCfg, "", .F.)
		cQuery := "SELECT MAX(QLD.QLD_SEQMAT) SEQMATCH "
		cQuery += "FROM " + RetSQLName("QLC") + " QLC "
		cQuery += "INNER JOIN " + RetSQLName("QLD") + " QLD "
		cQuery += "ON QLD.QLD_FILIAL = QLC.QLC_FILIAL "
		cQuery += "AND QLD.QLD_CODCON = QLC.QLC_CODCON "
		cQuery += "AND QLD.QLD_CODCFG = QLC.QLC_CODCFG "
		cQuery += "AND QLD.D_E_L_E_T_ = ? "
		cQuery += "WHERE QLC.QLC_FILIAL = ? "
		cQuery += "AND QLC.QLC_CODCFG = ? "
		cQuery += "AND QLC.QLC_CODUSR = ? "
		cQuery += "AND QLC.QLC_DATCON = ? "
		cQuery += "AND QLD.QLD_REGMAT = ? "
		cQuery += "AND QLC.D_E_L_E_T_ = ? "

        nQry := 1
		oSeqQLC := FWExecStatement():New(cQuery)
		oSeqQLC:SetString(nQry++, " ") 				//QLD.D_E_L_E_T_
		oSeqQLC:SetString(nQry++, xFilial("QLC"))	//QLC.QLC_FILIAL
		oSeqQLC:SetString(nQry++, cCodCfg) 			//QLC.QLC_CODCFG
		oSeqQLC:SetString(nQry++, RetCodUsr()) 		//QLC.QLC_CODUSR
		oSeqQLC:SetString(nQry++, DToS(dDataBase)) 	//QLC.QLC_DATCON
		oSeqQLC:SetString(nQry++, cRegMatch) 	    //QLD.QLD_REGMAT
		oSeqQLC:SetString(nQry++, " ") 				//QLC.D_E_L_E_T_

		cSeqMtQLC := oSeqQLC:ExecScalar("SEQMATCH")
	Endif

	If Empty(cSeqMtQLC)
		cSeqMtQLC := StrZero( 0 , nTamSeqMatch )
	Endif

	If ValType(cTable) == "C" .And. !Empty(cTable)
		cQuery := "SELECT MAX(SEQMATCH) SEQMATCH"
		cQuery += " FROM " + cTable
		If lMatchPrc 
            cQuery += " WHERE REGMATCH <> ? "
        Else 
            cQuery += " WHERE REGMATCH = ? "
        EndIf
		cQuery += " AND D_E_L_E_T_ = ? "
		cQuery  := ChangeQuery(cQuery)

        nQry := 1

		oSeqTbl := FWExecStatement():New(cQuery)

        If lMatchPrc
		    oSeqTbl:SetString(nQry++, "999")
		Else    
            oSeqTbl:SetString(nQry++, cRegMatch)
		EndIf

        oSeqTbl:SetString(nQry++, " ")

		cSeqMtTbl := oSeqTbl:ExecScalar("SEQMATCH")

		TcRefresh(cTable) // Resetar tempo de timeout

		If Empty(cSeqMtTbl)
			cSeqMtTbl := StrZero( 0 , nTamSeqMatch )
		Endif
	Endif

	cSeqMatch := cSeqMtTbl

	If cSeqMtQLC > cSeqMtTbl
		cSeqMatch := cSeqMtQLC
	Endif

    If !lMatchPrc
	    cSeqMatch := Soma1(cSeqMatch)
    EndIf 
return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcSetResponse
Adiciona resposta padrao na api
Quando lPadrao = T, nao trata e utiliza retorno padrao ja enviado
pela api

@author Totvs
/*/
//-------------------------------------------------------------------
Function tcSetResponse(lResponse As Logical, cChaveRes As Character, cResponse As Character, lPadrao As Logical)
Local cReturn := "" As Character

If ValType(oRest) == "O"
    If ValType(lResponse) == "L" .And. ValType(cChaveRes) == "C" .And. ValType(cResponse) == "C"
        oRest:setKeyHeaderResponse("Content-Type", "application/json")

        If lPadrao
            cReturn := cResponse
        Else
            cReturn := If(!Empty(cChaveRes) .And. !Empty(cResponse), '{"'+cChaveRes+'": "'+cResponse+'"}', '{}')
        EndIf

        If lResponse
            oRest:setResponse(cReturn)
        Else
            oRest:setFault(cReturn)
        EndIf
    EndIf
EndIf
return

//-------------------------------------------------------------------
/*/{Protheus.doc} tcGetComboBox
Tratamento para retornar ComboBox do SX3 em formato Json
pela api

@author Totvs
/*/
//-------------------------------------------------------------------
Function tcGetComboBox(cField)
Local cComboBox := "" As Character
Local cColorBox := "" As Character
Local nI        := 0  As Numeric
Local nAt       := 0  As Numeric
Local aComboBox := {} As Array
Local aColorBox := {} As Array
Local aRetBox   := {} As Array

Default cField := ""

If !Empty(cField)
    If Alltrim(Lower(cField)) == "reconciled"
        cComboBox := "S=Conciliado;N=Nao Conciliado"
        cColorBox := "color-01;color-08"
    ElseIf Alltrim(Lower(cField)) == "typematch"
        cComboBox := "A=Automático;M=Manual;AD=Automático Divergente;MD=Manual Divergente;I=Ignorado"
        cColorBox := "color-12;color-06;color-07;color-09;color-10"
    Else
        cComboBox := AllTrim(Posicione("SX3", 2, AllTrim(cField), "X3_CBOX"))
    EndIf

    If !Empty(cComboBox)
        aComboBox := StrTokArr2(cComboBox, ";")
        aColorBox := StrTokArr2(cColorBox, ";")

        For nI := 1 To Len(aComboBox)
            nAt := At("=", aComboBox[nI])

            aAdd(aRetBox, JsonObject():new())
            aRetBox[Len(aRetBox)]["value"] := SubStr(aComboBox[nI], 1, nAt-1)
            aRetBox[Len(aRetBox)]["label"] := SubStr(aComboBox[nI], nAt+1, Len(aComboBox[nI]))

            If ValType(aColorBox) == "A" .And. Len(aColorBox) > 0 .And. ValType(aColorBox[nI]) == "C"
                aRetBox[Len(aRetBox)]["color"] := aColorBox[nI]
            EndIf
        Next
    EndIf
EndIf
Return aRetBox

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetConcat
Retorna o caracter para concatenar strings de acordo com o BD

@author Totvs
/*/
//-------------------------------------------------------------------
Function tcRetConcat()
Return IIF("SQL"$AllTrim(Upper(TcGetDb())), "+", "||")

//-------------------------------------------------------------------
/*/{Protheus.doc} tcRetConcat
Retorna o tamanho do campo UUID
32 para Oracle
36 para SQL e Postgres

@author Totvs
/*/
//-------------------------------------------------------------------
Function tcRetTamUID()
Return IIf("ORACLE"$AllTrim(Upper(TcGetDb())),32,36)

//-------------------------------------------------------------------
/*/{Protheus.doc} tcDropTable
Realiza o drop das tabela temporaria passada por parametro

@author Totvs
/*/
Function tcDropTable(cTableTmp As Character)
Local cError := "" As Character

If ValType(cTableTmp) == "C" .And. !Empty(cTableTmp)

    If TcCanOpen(cTableTmp) //Verificar se a tabela existe
        If !(TCDelFile(cTableTmp)) // TcDelFile exclui a tabela temporária
            conout(TCSQLError())
            cError := STR0001 //"Nao foi possivel excluir a tabela temporaria: "
            cError += cTableTmp + STR0002 //". Para mais detalhes, verificar arquivo console.log"
        EndIf
    EndIf
Else
    cError := STR0003 //"Nao foi possivel encontrar a tabela temporária"
EndIf
Return cError

//-------------------------------------------------------------------
/*/{Protheus.doc} tcProcessLGPD
Faz o tratamento dos campos para atender à LGPD

@author Totvs
/*/
Function tcProcessLGPD(aCposLGPD)
Local aRetLGPD := {}
Local nI       := 0
Local nTam     := 0
DEFAULT aCposLGPD := {}

aRetLGPD := FwProtectedDataUtil():UsrAccessPDField(__cUserID, aCposLGPD)

If Len(aRetLGPD) <> Len(aCposLGPD)
    For nI := 1 to Len(aCposLGPD)
        cField  := aCposLGPD[nI]
        If aScan(aRetLGPD , cField) == 0
            nTam := TAMSX3(cField)[1]
            aCposLGPD[nI] := "'"+REPLICATE("*", nTam)+"' as "+cField
        EndIf
    Next nI
EndIf

Return aRetLGPD

//-------------------------------------------------------------------
/*/{Protheus.doc} tcClearSql
Faz o tratamento dos campos evitar o uso de comandos de banco de dados nos campos

@author Totvs
/*/
Function tcClearSql(cValue, lAditionalCondition)

Local cValueInput := ""

Default cValue := ""
Default lAditionalCondition := .F.

cValue = UPPER(cValue)
cValueInput := cValue
cValue = RTrim(cValue)

If !lAditionalCondition
    cValue = StrTran(cValue,"=","")
    cValue = StrTran(cValue,"'","")
    cValue = StrTran(cValue,"(","")
    cValue = StrTran(cValue,")","")
    cValue = StrTran(cValue,"<","[")
    cValue = StrTran(cValue,">","]")
    cValue = StrTran(cValue,"'","")
    cValue = StrTran(cValue," AND ","")
    cValue = StrTran(cValue," OR ","")
    cValue = StrTran(cValue,"*","")
    cValue = StrTran(cValue,"¨","")
    cValue = StrTran(cValue,"&","")
    cValue = StrTran(cValue,"OR 1=1","")
EndIf

cValue = StrTran(cValue,"UPDATE","")
cValue = StrTran(cValue,"SHUTDOWN","")
cValue = StrTran(cValue,"--","")
cValue = StrTran(cValue,"#","")
cValue = StrTran(cValue,"$","")
cValue = StrTran(cValue,"%","")
cValue = StrTran(cValue,"INSERT","")
cValue = StrTran(cValue,"DROP","")
cValue = StrTran(cValue,"DELET","")
cValue = StrTran(cValue,"XP_","")
cValue = StrTran(cValue,"SELECT","")

/* Se houver diferenças entre o contéudo de entrada e o conteúdo tratado, 
 significa que foi encontrado código SQL que deve ser removido dos filtros. */
If ( Upper(RTrim(cValueInput)) != Upper(RTrim(cValue)) )
    cValueInput := ""
EndIf

Return cValueInput

/*/{Protheus.doc} userBranches
  Função para retornar as filiais que o usuário tem acesso.
  Cópia de BranchesofUsers - SIGAFIN
  @type function
  @version 12.1.33
  @author totvs
  @since 09/12/2021
  @return Object, jSon filiais de acesso do usuário
/*/
Function userBranches(cOrigem As Character)
  Local nGrupo    As Numeric
  Local nGrpFil   As Numeric
  Local aBranches As Array
  Local aPswUser  As Array
  Local aPswGrp   As Array
  Local aFiliais  As Array
  Local cGrpRule  As Character
  Local jBranches As Json

  Default cOrigem := ""

  PswOrder(1)
  PswSeek(__cUserId, .T.)

  aPswUser  := PswRet()
  aBranches := {}
  aPswGrp   := {}
  aFiliais  := {}
  aGrpFil   := {}
  cGrpRule  := AllTrim(FWUsrGrpRule(__cUserId))

  If cGrpRule $ "1|3"                     // Prioriza grupo ou soma
    For nGrupo := 1 To Len(aPswUser[1][10])             // [1][10] A Vetor com os grupos, adiciona as filiais do grupo
      If PswSeek(aPswUser[1][10][nGrupo], .F.)          // Pesquisa o(s) Grupo(s) que o Usuario participa
        aPswGrp := FwGrpEmp(aPswUser[1][10][nGrupo])
        For nGrpFil := 1 To Len(aPswGrp)
          aAdd(aGrpFil, aPswGrp[nGrpFil])
        Next nGrpFil
      EndIf
    Next nGrupo
    If cGrpRule $ "1"
      aFiliais := aGrpFil
    EndIf
  ElseIf cGrpRule == "2"                // Desconsiderar
    aFiliais  := AClone(aPswUser[2][6])
  EndIf

  If cGrpRule == "3"                    // Somar
    aFiliais  := AClone(aPswUser[2][6])
    If Empty(aFiliais)
        If !Empty(aGrpFil)
          aFiliais := aGrpFil
        EndIf
    Else
      If !aFiliais[1] == "@@@@" .And. !Empty(aGrpFil)       // usuário não possui acesso a todas filiais e existe filiais configuradas no grupo
        For nGrpFil := 1 To Len(aGrpFil)                    // regra para não duplicar
          If AScan(aFiliais, { |x| x $ aGrpFil[nGrpFil]}) == 0
            Aadd(aFiliais, aGrpFil[nGrpFil])
          EndIf
        Next nGrpFil
      EndIf
    EndIf
  EndIf

  aBranches := companyFormat(aFiliais, cOrigem)
  jBranches := JsonObject():New()
  jBranches["items"] := aBranches
Return jBranches

/*/{Protheus.doc} companyFormat
  Função para formatar As filiais que o usuário tem acesso.
  Cópia de definitionOfCompany - SIGAFIN

  @type function
  @version 12.1.33
  @author totvs
  @since 09/12/2021
  @param branchesInfo, array, filiais
  @return Array, array com informações das filiais
  {
    "branchId": string,
    "totalId": string,
    "companyId": string,
    "unitId": string,
    "companyName": string,
    "unitName": string,
    "branchName": string
  }
/*/
Function companyFormat(aBranchesInfo As Array, cOrigem As Character) As Array
  Local nFil         as Numeric
  Local nLenBranch   as Numeric
  Local nLenCompany  as Numeric
  Local nLenUnit     as Numeric
  Local nLenBranchId as Numeric
  Local nLenEmp      as Numeric
  Local cLayout      as Character
  Local cBranchName  as Character
  Local aSM0         as Array
  Local aBranches    as Array
  Local aTables      as Array
  Local aModeAccess  as Array
  Local lSharedTable as Logical

  nLenBranch   := FWSizeFilial()
  nLenCompany  := Len(FWSM0Layout(, 1))
  nLenUnit     := Len(FWSM0Layout(, 2))
  nLenBranchId := Len(FWSM0Layout(, 3))
  aBranches    := {}
  nLenEmp      := Len(cEmpAnt)
  lSharedTable := .T.
  aTables      := {}
  aModeAccess  := {}

  aModeAccess  := ModeAccessTables(cOrigem)

  If Len(aModeAccess) > 0
    lSharedCompany  := aModeAccess[1]
    lSharedUnit     := aModeAccess[2]
    lSharedBranch  := aModeAccess[3]
  EndIf
  
  // Para o Fechamento Contábil e Agrupador Patrimonial, toda a tabela deve estar compartilhada (CCC) 
  // para seleção de mais de uma filial

  // Após validar os APPs CTBA960 e ATFA510 no mesmo modelo de trabalho do Conciliador (Bloco ELSE), 
  // devemos remover este comportamento diferente, e considerar apenas o modelo do conciliador
  If cOrigem == "CTBA960" .Or. cOrigem == "ATFA510"
    If lSharedCompany .And. lSharedUnit .And. lSharedBranch
        lSharedTable := .T.
    Else
        lSharedTable := .F.
    EndIf
  Else
    // Para o Conciliador, só não permitiremos a seleção de mais de uma filial se as tabelas 
    // estiverem em modo totalmente exclusivo (EEE)
    If !lSharedCompany .And. !lSharedUnit .And. !lSharedBranch
        lSharedTable := .F.
    Else
        lSharedTable := .T.
    EndIf
  EndIf

  // Compartilhamento CCC
  If lSharedTable //Se QLC totalmente compartilhada, verifica filiais que usuario tem acesso
    If aBranchesInfo[1] == "@@@@"
        aSM0 := FwLoadSM0()

        For nFil := 1 To Len(aSM0)
            If aSM0[nFil][1] == cEmpAnt
                cLayout := aSM0[nFil][2]

                aAdd(aBranches, JsonObject():New())
                aBranches[Len(aBranches)]["branch"] := cLayout
                aBranches[Len(aBranches)]["label"]  := AllTrim(aSM0[nFil][7])
                aBranches[Len(aBranches)]["group"]  := AllTrim(aSM0[nFil][1])
            EndIf
        Next nFil
    Else
        For nFil := 1 To Len(aBranchesInfo)
            cLayout := aBranchesInfo[nFil]
            If SubStr(cLayout, 1, nLenEmp) == cEmpAnt
                cLayout := SubStr(cLayout, nLenEmp + 1)
                cLayout := PadR(cLayout, nLenBranch)
                cBranchName  := AllTrim(FWFilialName(cEmpAnt, cLayout))

                aAdd(aBranches, JsonObject():New())
                aBranches[Len(aBranches)]["branch"] := cLayout
                aBranches[Len(aBranches)]["label"]  := AllTrim(cBranchName)
                aBranches[Len(aBranches)]["group"]  := cEmpAnt
            EndIf
        Next nFil
    EndIf
  // Compartilhamento EEE
  Else //Se hover alguma exclusividade na tabela, exibe apenas filial logada
    aAdd(aBranches, JsonObject():New())
    aBranches[Len(aBranches)]["branch"] := cFilAnt
    aBranches[Len(aBranches)]["label"]  := AllTrim(FwFilialName())
    aBranches[Len(aBranches)]["group"]  := cEmpAnt
  EndIf
Return aBranches

/*/{Protheus.doc} GetBranchiesForConditional
  Função para retornar as condicionais de filiais das queries.
  @type function
  @version 12.1.33
  @author totvs
  @since 29/12/2021
  @return cBranchiesCondition, condiciopnais de filiais para query
/*/
Function GetBranchiesForConditional(cTable as Character, cOrigem as Character) as Character
Local cBranchiesCondition := "" as Character
Local cBranchField := "" as Character
Local nI := 0 as Numeric
Local oUserBranchies as Object
Local aBranchies as Array
Local lSharedTable := .F. as Logical

Default cOrigem := "" // "" == "CTBA940" - Conciliador

oUserBranchies := UserProfileProtheusData():getData()
aBranchies := oUserBranchies:getProfile( /* cParamType */ , cOrigem )

If ValType(cTable) == "C" .And. !Empty(cTable)
    cBranchField := GetBranchField(cTable)

    If !Empty(cBranchField)
        lSharedTable := FWModeAccess(cTable, 1) == "C" .And.;
                            FWModeAccess(cTable, 2) == "C" .And.;
                            FWModeAccess(cTable, 3) == "C"

        cBranchiesCondition := cBranchField+" = '"+FwXFilial(cTable, cFilAnt)+"'"

        If ValType(aBranchies) == "A" .And. Len(aBranchies) > 1 .And. aBranchies[1]
            // Por enquanto, apenas a origem "" (Conciliador)
            // Se o aBranchied[2][1] for "[]", as filiais foram limpas da seleção de filiais 
            If cOrigem == "" .And. (Len(aBranchies[2]) > 0 .And. aBranchies[2][1]<>"[]")
                filterProfileBranches(@aBranchies, cOrigem)
            EndIf
            //Verificação após o filtro de filiais do profile
            If Len(aBranchies[2]) > 0 .OR. cOrigem <> ""
                If lSharedTable .Or. (Len(aBranchies[2]) == 1 .And. aBranchies[2,1]<>"[]") //Uma filial ou tabela compartilhada
                    cBranchiesCondition := cBranchField+" = '"+FwXFilial(cTable, aBranchies[2][1])+"'"
                ElseIf Len(aBranchies[2]) > 1 //Varias filiais
                    cBranchiesCondition := cBranchField+" IN ("
                    For nI := 1 To Len(aBranchies[2])
                        cBranchiesCondition += "'"+FwXFilial(cTable, aBranchies[2][nI])+"',"
                    Next
                    cBranchiesCondition := SubStr(cBranchiesCondition, 1, Len(cBranchiesCondition)-1)+")"
                EndIf
            Else
                cBranchiesCondition := ""
            EndIf
        EndIf
    EndIf
EndIf

return cBranchiesCondition

/*/{Protheus.doc} GetBranchField
  Função para retornar campo da filial da tabela ou temporario.
  @type function
  @version 12.1.33
  @author totvs
  @since 29/12/2021
  @return cBranchField, campo de filial da tabela
/*/
Static Function GetBranchField(cTable)
Local cBranchField := "" as Character
If !(cTable)->(FieldPos(cTable+"_FILIAL"))
    cBranchField := SubStr(cTable, 2, 2)+"_FILIAL"
Else
    cBranchField := cTable+"_FILIAL"
EndIf
Return cBranchField

/*/{Protheus.doc} AddFiltersProfile
  Função para armazenar as informacoes de filtros
  de profile do usuario em array
  @type function
  @version 12.1.33
  @author totvs
  @since 10/03/2022
  @return aFilters, informacoes dos filtros
/*/
Static Function AddFiltersProfile(jFilters as Json)
Local nI          := 0  as Numeric
Local aFilters    := {} as Array
Local aFiltersAux := {} as Array

//Filtros origem
If ValType(jFilters["tabori"]) == "A"
    For nI := 1 To Len(jFilters["tabori"])
        aAdd(aFiltersAux, {jFilters["tabori"][nI]["field"],;
                           jFilters["tabori"][nI]["operation"],;
                           jFilters["tabori"][nI]["value"]})
    Next nI

    aAdd(aFilters, aClone(aFiltersAux))
EndIf

aFiltersAux := {}

//Filtros destino
If ValType(jFilters["tabdes"]) == "A"
    For nI := 1 To Len(jFilters["tabdes"])
        aAdd(aFiltersAux, {jFilters["tabdes"][nI]["field"],;
                           jFilters["tabdes"][nI]["operation"],;
                           jFilters["tabdes"][nI]["value"]})
    Next nI

    aAdd(aFilters, aClone(aFiltersAux))
EndIf
FwFreeArray(aFiltersAux)
Return aFilters

/*/{Protheus.doc} GetFiltersValue
  Função para retornar as informacoes de filtros
  de profile do usuario
  @type function
  @version 12.1.33
  @author totvs
  @since 10/03/2022
  @return cResponse, valores dos filtros
/*/
Static Function GetFiltersValue(nType as Numeric, cField as Character, cOperation as Character,;
                                    aFilters as Array)
Local cResponse := "" as Character
Local nPos := 0 as Numeric

DEFAULT nType      := 0
DEFAULT cField     := ""
DEFAULT cOperation := ""
DEFAULT aFilters   := {}

If !Empty(cOperation) .AND. (!Empty(cField) .OR. Upper(cOperation) == 'QUERY')
    If(nPos := aScan(aFilters[nType], {|x| AllTrim(Upper(x[1])) == AllTrim(Upper(cField)) .And.;
                    AllTrim(Upper(x[2])) == AllTrim(Upper(cOperation))})) > 0
        cResponse := aFilters[nType][nPos][3]
    Endif
EndIf

Return cResponse

/*/{Protheus.doc} RetUsedFields
  Função para retornar os campos usados da tabela
  @type function
  @version 12.1.33
  @author totvs
  @since 04/04/2022
  @return aStructAux, campos usados da tabela
/*/
Function RetUsedFields(cTable)
Local nI := 0 as Numeric
Local aStructAux := {} as Array
Local aStruct    := FWSX3Util():GetListFieldsStruct(cTable , .F.) as Array

aStruct := FWVetByDic(aStruct, cTable) //Trata campos com informacoes do dicionario SX3

For nI := 1 To Len(aStruct)
    aAdd(aStructAux, aClone(aStruct[nI]))
Next
FwFreeArray(aStruct)

Return aStructAux

/*/{Protheus.doc} RetConfiguration
  Função para retornar se configuracao existe
  @type function
  @author totvs
  @since 28/11/2022
  @return lRet - Se encontrou a configuracao
/*/
Function RetConfiguration(cCodCfg)
Local lRet     := .F. as Logical
Local aArea    := GetArea() as Array
Local aAreaQLB := QLB->(GetArea()) as Array

Default cCodCfg := ""

If !Empty(cCodCfg)
    QLB->(dbSetOrder(1)) //QLB_FILIAL+QLB_CODCFG
    lRet := QLB->(dbSeek(FWxFilial("QLB")+PadR(cCodCfg, TamSx3("QLB_CODCFG")[1])))
EndIf

//Restaura areas
RestArea(aAreaQLB)
RestArea(aArea)
Return lRet

/*/{Protheus.doc} ReconciliateMetrics
	(long_description)
	@type  Static Function
	@author user
	@since date
	@version version
	@param param, param_type, param_descr
	@return return, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
/*/
Function ReconciliateMetrics(cEvent, cIdMetric, cSubRoutine, nQuant)

Local cFunBkp := FunName() as Character
Local nModBkp := nModulo as Numeric

Default cEvent      := ""
Default cIdMetric   := ""
Default cSubRoutine := Alltrim(ProcName(1))
Default nQuant      := 1

nModulo := 34 //Ajusta modulo para Contabil, necessário pois chamada PO-UI
SetFunName("CTBA940") //Ajusta a rotina, necessário pois chamada PO-UI

If cEvent == "01" //Quantidade de chamadas ou Total de Registros
    FWCustomMetrics():SetSumMetric(cSubRoutine, cIdMetric, nQuant) //Metrica
EndIf

//Restaura modulo e rotina originais
SetFunName(cFunBkp)
nModulo := nModBkp

Return

/*/{Protheus.doc} GetListOfProfileBranchies
  Função para retornar lista de filiais das queries utilizando bind.
  @type function
  @version 12.1.2410
  @author totvs
  @since 09/12/2024
  @param cTable, character, codigo da tabela
  @param cOrigem, character, produto que chama
  @return aBranchies, lista de filiais do profile
/*/
Function GetListOfProfileBranchies(cTable as Character, cOrigem as Character) as array
    Local cRetBranches := ""    as character
    Local aBranches := {}       as array
    Local nRemove := 0          as numeric
    
    cRetBranches := GetBranchiesForConditional(cTable, cOrigem)
    
    If !Empty(cRetBranches)
        If SubStr(cTable, 1, 1) == "S"
            nRemove := 10
        Else
            nRemove := 11
        EndIf
        cRetBranches := SubStr(cRetBranches, nRemove, Len(cRetBranches))
        
        cRetBranches :=  StrTran(cRetBranches," IN (","")
        cRetBranches :=  StrTran(cRetBranches,")","")
        cRetBranches :=  StrTran(cRetBranches,"'","")
        cRetBranches :=  StrTran(cRetBranches,"=","")

        aBranches := StrTokArr(AllTrim(cRetBranches),",")
    Else
        aADD(aBranches, FwXFilial(cTable, cFilAnt))
    EndIf

return aBranches

/*/{Protheus.doc} filterProfileBranches
  Função para remover do array de filiais do profile, as filiais que o usuário não deve acessar de acordo com a 
  filial logada e o compartilhamento das filiais.
  @type function
  @version 12.1.2510
  @author totvs
  @since 24/01/2025
  @params
    aProfile - Array com as filiais selecionadas no profile atual - Parâmetro passado por referencia*
    cOrigin: Character - App que realizou a chamada da API
  @return
/*/
Function filterProfileBranches(aProfile as Array, cOrigin as Character)

    Local lSharedTable as Logical

    Local lSharedBranch     as Logical
    Local lSharedUnit       as Logical
    Local lSharedCompany    as Logical
    
    Local lHasUnit          as Logical
    Local lHasCompany       as Logical

    Local cSM0Layout        as Character
    Local cCompanyLogged    as Character
    Local cUnitLogged       as Character
    Local aUnitBusiness     as Array
    Local aBranchesList     as Array

    Local aTables           as Array
    Local aFiltered         as Array
    Local aBranches         as Array
    Local aModeAccess       as Array

    Local nI                as Numeric
    Local nX                as Numeric

    lSharedBranch       := .F.
    lSharedUnit         := .F.
    lSharedCompany      := .F.
    lHasUnit            := .F.
    lHasCompany         := .F.

    cSM0Layout          := ""
    cCompanyLogged      := ""
    cUnitLogged         := ""
    aUnitBusiness       := {}
    aBranchesList       := {}
    aFiltered           := {}
    aModeAccess         := {}
    aBranches           := {}

    nI                  := 0
    nX                  := 0
    aModeAccess :=  ModeAccessTables(cOrigin)
    
    // aModeAccess[1] = Nível de Empresa
    // aModeAccess[2] = Nível de Unidade de Negócio
    // aModeAccess[3] = Nível de Filial

    If Len(aModeAccess) > 0
        lSharedCompany  := aModeAccess[1]
        lSharedUnit     := aModeAccess[2]
        lSharedBranch   := aModeAccess[3]
    EndIf
    
    If lSharedCompany .And. lSharedUnit .And. lSharedBranch
        lSharedTable := .T.
    EndIf

    //Se estiver totalmente compartilhada, não há necessidade de filtrar nenhuma filial
    If !lSharedTable

        cSM0Layout  := AllTrim(FWSM0Layout()) // Colocar um AllTrim
        //Não verifico se há "F" porque a filial é obrigatória
        lHasCompany := "E" $ cSM0Layout
        lHasUnit    := "U" $ cSM0Layout
        
        // Compartilhamento CCE
        // Filial: Compartilhada; Unidade: Compartilhada; Empresa: Exclusiva
        If lSharedBranch .And. lSharedUnit .And. !lSharedCompany 

            // Se no cSM0Layout não tiver empresa (!lHasCompany), mas tiver unidade de negócio e filiais compartilhadas
            // considero como tabela totalmente compartilhada, já que não há níveis validos exclusívos 
            // EEFF; EEUUFF;
            If lHasCompany 
                cCompanyLogged := FwCompany()
                
                //EEUUFF
                If lHasUnit
                    aUnitBusiness  := FwAllUnitBusiness(cCompanyLogged)
                    
                    For nI := 1 to Len(aUnitBusiness)
                        aBranchesList := FWAllFilial(cCompanyLogged, aUnitBusiness[nI] ,, .F. )
                        For nX := 1 to Len(aBranchesList) // Laço semelhante ao do else, componentizar
                            
                            aAdd(aBranches, aBranchesList[nX])
                        Next nX 
                    Next nI
                //EEFF
                Else
                    aBranches := FWAllFilial(cCompanyLogged , , , .F. )
                EndIf
            EndIf

        // Compartilhamento CEE
        // Filial: Compartilhada; Unidade: Exclusiva; Empresa: Exclusiva
        ElseIf lSharedBranch .And. !lSharedUnit .And. !lSharedCompany
            
            //EEUUFF; EEFF; UUFF; FF
            cCompanyLogged  := FwCompany()
            cUnitLogged     := FwUnitBusiness()
            
            // Se não houver empresa e/ou unidade de negócio, a função FWAllFilial retornara a lista de filiais de acordo
            // com os parâmetros recebidos, se cCompanyLogged e/ou cUnitLogged estiverem vazios, ele desconsiderará estes níveis
            // na filtragem de filiais
            aBranches := FwAllFilial(cCompanyLogged, cUnitLogged ,, .F. )

        EndIf

        If Len(aBranches) > 0
            For nI := 1 to Len(aProfile[2])
                For nX := 1 to Len(aBranches)
                    If (aProfile[2][nI] == aBranches[nX])
                        AADD(aFiltered, aProfile[2][nI])
                    EndIf
                Next nX
            Next nI
            aProfile[2] := AClone(aFiltered)
        EndIf
    EndIf

    FwFreeArray(aUnitBusiness)
    FwFreeArray(aBranchesList)
    FwFreeArray(aFiltered)
    FwFreeArray(aBranches)
    FwFreeArray(aTables)
    FwFreeArray(aModeAccess)

Return

/*/{Protheus.doc} ModeAccessTables
  Função que retorna o nível de compartilhamento das tabelas de acordo com a origem enviada.
  @type function
  @version 12.1.2410
  @author totvs
  @since 24/01/2025
  @params
    cOrigin: Character - App que realizou a chamada da API
  @return 
    aModeAccess: Array - Array de 3 posições para indicar o nível de compartilhamento das tabelas
        aModeAccess[1] = Nível de Empresa
        aModeAccess[2] = Nível de Unidade de Negócio
        aModeAccess[3] = Nível de Filial
/*/
Function ModeAccessTables(cOrigin as Character)

    Local aModeAccess   as Array
    Local aTables       as Array
    Local nI            as Numeric
    
    aModeAccess         := {}
    aTables             := {}
    nI                  := 0

    AADD(aModeAccess, .F.) //Nível de empresa
    AADD(aModeAccess, .F.) //Nível de unidade de negócio
    AADD(aModeAccess, .F.) //Nível de filiais

    If cOrigin == "CTBA960"
        AADD( aTables, "QLF" )
        AADD( aTables, "QLK" )
        AADD( aTables, "QLI" )
        AADD( aTables, "QLJ" )
    ElseIf cOrigin == "ATFA510"
        AADD( aTables, "FM3" )
        AADD( aTables, "FM4" )
    Else
        AADD( aTables, "QLC" )
        AADD( aTables, "QLD" )
    EndIf

    //As tabelas do array aTables devem trabalhar no mesmo modo de compartilhamento. 
    // Se encontrada qualquer ocorrência de exclusívidade, todas as tabelas deste nível serão consideradas exclusívas.

    For nI := 1 to Len(aTables)
        //Nível de empresa
        If FWModeAccess(aTables[nI], 1) == "C"
            aModeAccess[1] := .T.
        Else   
            aModeAccess[1] := .F.
            Exit
        EndIf
    Next nI

    For nI := 1 to Len(aTables)
        //Nível de unidade de negócio
        If FWModeAccess(aTables[nI], 2) == "C"
            aModeAccess[2] := .T.
        Else   
            aModeAccess[2] := .F.
            Exit
        EndIf
    Next nI

    For nI := 1 to Len(aTables)
        //Nível de branchs
        If FWModeAccess(aTables[nI], 3) == "C"
            aModeAccess[3] := .T.
        Else   
            aModeAccess[3] := .F.
            Exit
        EndIf
    Next nI

Return aModeAccess

/*/{Protheus.doc} TCGetTribTitle
  Função que retorna o título do tributo contido na F2D.
  @type function
  @version 12.1.2510
  @author totvs
  @since 22/10/2025
  @params
    cField: Character - Nome do campo de tributo na tabela temporaria
    cCodCfg: Character - Configuração de Conciliação
    cOrigin: Character - Tipo da tabela, se é origem ou destino
    lIdentifier: Logical - Se deve retornar com o caractere identificador "(T)"
  @return 
    cReturn: Character - String com o nome do titulo do tributo contido no QLB_CFGTRB e o identificador caso lIdentifier for true
/*/
function TCGetTribTitle(cField as Character, cCodCfg as Character, cTypeTable as Character, lIdentifier as Logical) as Character
    Local jCfgTrib  as JSON
    Local uRet      as variant
    Local nI        as Numeric
    Local cReturn   as Character
    Local cOrder    as Character

    jCfgTrib := JsonObject():New()
    nI       := 0
    cReturn  := ""
    cOrder := SubStr(cField, 3, Len(cField) - 2)

    QLB->(dbSetOrder(1))
    If QLB->(FieldPos("QLB_CFGTRB")) > 0
        If QLB->(dbSeek(FWxFilial("QLB")+cCodCfg))
            uRet := jCfgTrib:FromJson(AllTrim(QLB->QLB_CFGTRB))
            If ValType(uRet) == "U"
                If cTypeTable == "tabori"
                    For nI := 1 to Len(jCfgTrib["tribori"]["col_taxes"])
                        If cOrder == jCfgTrib["tribori"]["col_taxes"][nI]["field"]
                            cReturn := jCfgTrib["tribori"]["col_taxes"][nI]["tax"]
                            Exit
                        EndIf
                    Next nI
                Else
                    For nI := 1 to Len(jCfgTrib["tribdes"]["col_taxes"])
                        If cOrder == jCfgTrib["tribdes"]["col_taxes"][nI]["field"]
                            cReturn := jCfgTrib["tribdes"]["col_taxes"][nI]["tax"]
                            Exit
                        EndIf
                    Next nI
                EndIf
                If !Empty(cReturn) .And. lIdentifier 
                    cReturn :=  "(T) " + cReturn
                EndIf
            EndIf
        EndIf
    EndIf

Return cReturn

/*/{Protheus.doc} TCGetTribColumn
  Função que retorna a coluna da tabela temporária referente ao tributo enviado.
  @type function
  @version 12.1.2510
  @author totvs
  @since 22/10/2025
  @params
    cTrib: Character - Nome do tributo
    cCodCfg: Character - Configuração de Conciliação
    cTypeTable: Character - Tipo da tabela, se é origem ou destino
  @return 
    cReturn: Character - String com o nome da coluna do tributo na tabela temporária
/*/
function TCGetTribColumn(cTrib as Character, cCodCfg as Character, cTypeTable as Character) as Character
    Local jCfgTrib  as JSON
    Local uRet      as variant
    Local nI        as Numeric
    Local cReturn   as Character

    Default cTypeTable := ""

    jCfgTrib := JsonObject():New()
    nI       := 0
    cReturn  := ""

    QLB->(dbSetOrder(1))
    If QLB->(FieldPos("QLB_CFGTRB")) > 0
        If QLB->(dbSeek(FWxFilial("QLB")+cCodCfg))
            uRet := jCfgTrib:FromJson(AllTrim(QLB->QLB_CFGTRB))
            If ValType(uRet) == "U"
                If cTypeTable == "tabori"
                    For nI := 1 to Len(jCfgTrib["tribori"]["col_taxes"])
                        If cTrib == jCfgTrib["tribori"]["col_taxes"][nI]["tax"]
                            cReturn := "T_" + jCfgTrib["tribori"]["col_taxes"][nI]["field"]
                            Exit
                        EndIf
                    Next nI
                Else
                    For nI := 1 to Len(jCfgTrib["tribdes"]["col_taxes"])
                        If cTrib == jCfgTrib["tribdes"]["col_taxes"][nI]["tax"]
                            cReturn := "T_" + jCfgTrib["tribdes"]["col_taxes"][nI]["field"]
                            Exit
                        EndIf
                    Next nI
                EndIf
            EndIf
        EndIf
    EndIf

Return cReturn
