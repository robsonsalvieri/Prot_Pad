#INCLUDE "FINA150.CH"
#include "PROTHEUS.ch"
#Include "fileio.ch"

Static __oTemp
Static __lPIXImp   := Nil
Static __lVldExtC  := Nil
Static __lFinPix   := Nil
Static __lBaImpPix := Nil   
Static __lIsBlind  := Nil
Static __lBordImp  := Nil
Static __lSitCPix  := Nil
Static __nCasasDc  := Nil
Static __lF150GRV  := ExistBlock("F150GRV")
Static __lF150CBR  := ExistBlock("FA150CBR")
Static __cCHR1310  As Character
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FINA150  ³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera‡„o do Arquivo de Envio de Titulos ao Banco            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FINA150()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FINA150(nPosAuto as Numeric)

Local lOk       as Logical
Local aSays     as Array
Local aButtons  as Array
Local lPanelFin as Logical
Local lPergunte as Logical

PRIVATE cCadastro as Character
PRIVATE cNomeSai  as Character
PRIVATE cArqBkp   as Character
PRIVATE lAborta   as Logical
Private nTecla	  as Numeric

lOk       := .F.
aSays     := {}
aButtons  := {}
lPanelFin := IsPanelFin()
lPergunte := .F.

cCadastro := OemToAnsi(STR0005)  // "Comunica‡„o Banc ria - Envio Cobrança"
cNomeSai  := ""
cArqBkp   := ""
lAborta   := .F.
nTecla	  := nil

If !IsBlind() .AND. GetHlpLGPD({"A1_NOME","A6_COD"})
	Return .F.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ A fun‡„o SomaAbat reabre o SE1 com outro nome pela ChkFile, pois ³
//³ o filtro do SE1, desconsidera os abatimentos					 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SomaAbat("","","","R")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para parametros   ³
//³ mv_par01		 // Do Bordero 		   ³
//³ mv_par02		 // Ate o Bordero 	   ³
//³ mv_par03		 // Arq.Config 		   ³
//³ mv_par04		 // Arq. Saida    	   ³
//³ mv_par05		 // Banco     		   ³
//³ mv_par06		 // Agenciao     	   ³
//³ mv_par07		 // Conta   		   ³
//³ mv_par08		 // Sub-Conta  		   ³
//³ mv_par09		 // Cnab 1 / Cnab 2    ³
//³ MV_PAR10		 // Considera Filiais  ³
//³ MV_PAR11		 // De Filial   	   ³
//³ MV_PAR12		 // Ate Filial         ³
//³ MV_PAR13		 // Quebra por ?	   ³
//³ MV_PAR14		 // Seleciona Filial?  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica as perguntas selecionadas                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lPanelFin
	lPergunte := PergInPanel("AFI150",.T.)
Else
	lPergunte := pergunte("AFI150",.T.)
Endif

If lPergunte
	dbSelectArea("SE1")
	dbSetOrder(1)
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa o log de processamento                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogIni( aButtons )
	
	If nPosAuto <> Nil
		lOk	:= .T.
	Else
		aADD(aSays,STR0015) // "Esta rotina permite gerar o arquivo de envio do CNAB de cobrança, com base nas ocorrências"
		aADD(aSays,STR0016) // "cadastradas e com os borderôs de cobrança gerados."

		If lPanelFin  //Chamado pelo Painel Financeiro
			aButtonTxt := {}
			If Len(aButtons) > 0
				AADD(aButtonTxt,{STR0021,STR0021,aButtons[1][3]}) // Visualizar
			Endif
			AADD(aButtonTxt,{STR0003,STR0003, {||Pergunte("AFI150",.T. )}}) // Parametros
			FaMyFormBatch(aSays,aButtonTxt,{||lOk:=.T.},{||lOk:=.F.})
		Else
			aADD(aButtons, { 5,.T.,{|| Pergunte("AFI150",.T. ) } } )
			aADD(aButtons, { 1,.T.,{|| lOk := .T.,FechaBatch()}} )
			aADD(aButtons, { 2,.T.,{|| FechaBatch() }} )

			FormBatch( cCadastro, aSays, aButtons ,,,540)
		Endif
	Endif

	If lOk
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ProcLogAtu("INICIO")

		fa150Gera("SE1")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ProcLogAtu("FIM")
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Recupera a Integridade dos dados                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE1")
	dbSetOrder(1)
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fA150Gera³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Comunica‡„o Banc ria - Envio                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fA150Gera(cAlias)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA150                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fa150Gera(cAlias)

PRIVATE cBanco,cAgencia,xConteudo
PRIVATE nHdlBco    	:= 0
PRIVATE nHdlSaida  	:= 0
PRIVATE cBuffWrite  := "" As Character 
PRIVATE nSeq       	:= 0
PRIVATE nSomaValor	:= 0
PRIVATE nSomaVlLote	:= 0
PRIVATE nQtdTotTit	:= 0
PRIVATE nQtdTitLote	:= 0
PRIVATE nSomaAcres	:= 0
PRIVATE nSomaDecre	:= 0
PRIVATE nBorderos	:= 0
PRIVATE xBuffer		:= ""
PRIVATE nLidos		:= 0
PRIVATE nTotCnab2	:= 0 // Contador de Lay-out nao deletar
PRIVATE nLotCnab2	:= 1 // Contador de Lotes do arquivo
PRIVATE nLinha		:= 0 // Contador de Linhas nao deletar
PRIVATE nQtdLinLote	:= 0 // Contador de linhas do detalhe do lote
PRIVATE nTotLinArq	:= 0 // Contador de linhas do CNAB
Private lAtualiza   := .F.

Processa({|lEnd| fa150Ger(cAlias)})  // Chamada com regua

nBorderos  := 0
nSeq       := 0
nSomaValor := 0
nSomaVlLote:= 0
nQtdTotTit := 0
nQtdTitLote:= 0
nLotCnab2  := 1
nTotLinArq := 0
lAtualiza  := .F.

FCLOSE(nHdlBco)
if len(cBuffWrite) > 0 
   	fwrite(nHdlSaida,cBuffWrite, Len(cBuffWrite))
   	cBuffWrite := ''
endif
FCLOSE(nHdlSaida)

Return .T.


/*/
{Protheus.doc} fA150Ger
description
@type function
@version  
@author Wagner Xavier
@since 26/05/92
@param cAlias, character, Alias da tabela de contas a receber (SE1)
@return logical, return_description, Retorno lógico
/*/
Function fA150Ger(cAlias as Character) as Logical
Local nTamArq    as Numeric
Local lHeader    as Logical
Local lFirst     as Logical
Local lFirst2    as Logical
Local nTam       as Numeric
Local nDec       as Numeric
Local nUltDisco  as Numeric
Local nGrava     as Numeric
Local aBordero   as Array
Local nSavRecno  as Numeric
Local lRecicl    as Logical
Local cFile      as Character
Local lFIN150_1  as Logical
Local lFIN150_2  as Logical
Local lFIN150_3  as Logical
Local lFINA150   as Logical
Local lFinCnab2  as Logical
Local nRegEmp    as Numeric
Local cFilDe     as Character
Local cFilAte    as Character
Local cNumBorAnt as Character
Local cCliAnt    as Character
Local lFirstBord as Logical
Local lBorBlock  as Logical
Local lAchouBord as Logical
Local lF150Exc   as Logical
Local lIdCnab    as Logical
Local cArqGerado as Character
Local lF150Sum   as Logical
Local lAtuDsk    as Logical
Local lCnabEmail as Logical
Local cFilBor    as Character
Local nOrdSE1    as Numeric
Local lF150Ord   as Logical
Local lNovoLote  as Logical
Local lF150SumA  as Logical
Local lF150SumD  as Logical
Local lF150BBCO  as Logical
Local lBCOBORD   as Logical
Local lFimLin    as Logical
Local lTrailler  as Logical
Local cAliasTrb  as Character
Local lF150NoGrv as Logical
Local cLstSit    as Character
Local aHlpSit    as Array
Local aBorApi	 As Array
Local cHlpSit    as Character
Local cHlpBor	 As Character
Local nStatBkp   as Numeric
Local lGestao    as Logical
Local cFilFwSE1  as Character
Local cQuery     as Character
Local lHeadMod2  as Logical
Local bWhile2    as Block
Local cOrder     as Character
Local nValor     as Numeric
Local cCart      as Character
Local lQuery     as Logical
Local aSelFil    as Array
Local lSE1Acces  as Logical
Local bWhile     as Block
Local nX         as Numeric
Local cLinCnab   as Character
Local cCodOfi    As Character
Local cTipoChr	 As Character
Local aTipoChr	 As Array

Private lErroCBar As Logical

nTamArq    := 0
lHeader    := .F.
lFirst     := .F.
lFirst2    := .F.
nTam       := 0
nDec       := 0
nUltDisco  := 0
nGrava     := 0
aBordero   := {}
nSavRecno  := recno()
lRecicl    := GETMV("MV_RECICL")
cFile      := ""
lFIN150_1  := ExistBlock("FIN150_1")
lFIN150_2  := ExistBlock("FIN150_2")
lFIN150_3  := ExistBlock("FIN150_3")
lFINA150   := ExistBlock("FIN150")
lFinCnab2  := ExistBlock("FINCNAB2")
nRegEmp    := SM0->(RecNo())
cFilDe     := ""
cFilAte    := ""
cNumBorAnt := CRIAVAR("E1_NUMBOR",.F.)
cCliAnt    := CRIAVAR("E1_CLIENTE",.F.)
lFirstBord := .T.
lBorBlock  := .F.
lAchouBord := .F.
lF150Exc   := ExistBlock("F150EXC")
lIdCnab    := .T.
cArqGerado := ""
lF150Sum   := ExistBlock("F150SUM")
lAtuDsk    := .F.
lCnabEmail := .F.
cFilBor    := ""
nOrdSE1    := 5
lF150Ord   := ExistBlock("F150ORD")
lNovoLote  := .F.
lF150SumA  := ExistBlock("F150SUMA")
lF150SumD  := ExistBlock("F150SUMD")
lF150BBCO  := ExistBlock("F150BBCO")
lBCOBORD   := .T.
lFimLin    := .T.
lTrailler  := .F.
cAliasTrb  := ""
lF150NoGrv := ExistBlock("F150NOGRV")
cLstSit    := ""
aHlpSit    := {}
aBorApi	   := {}
cHlpSit    := ""
cHlpBor	   := ""
nStatBkp   := 0
lGestao    := FWSizeFilial() > 2 // Indica se usa Gestao Corporativa
cFilFwSE1  := FwFilial("SE1")
cQuery     := ""
lHeadMod2  := .F.
bWhile2    := {||.T.}
cOrder     := ""
nValor     := 0
cCart      := "R"
lQuery     := IfDefTopCTB() // verificar se pode executar query (TOPCONN)
aSelFil    := {}
lSE1Acces  := Iif( lGestao, FWModeAccess("SE1",1) == "C", FWModeAccess("SE1",3) == "C")
bWhile     := {||.T.}
nX         := 1
cLinCnab   := ""
cCodOfi    := ""
cTipoChr   := ""
aTipoChr   := {chr(1),chr(2),chr(3),chr(4)}

lErroCBar  := .F.

ProcRegua(SE1->(RecCount()))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona no Banco indicado                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cBanco  := mv_par05
cAgencia:= mv_par06
cConta  := mv_par07
cSubCta := mv_par08

dbSelectArea("SA6")
If !(dbSeek(xFilial("SA6")+cBanco+cAgencia+cConta))
	Help(" ",1,"FA150BCO")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento com o erro  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogAtu("ERRO","FA150BCO",Ap5GetHelp("FA150BCO"))

	Return .F.
ElseIf Max(SA6->A6_MOEDA,1) > 1

	Help( "  ", 1, "MOEDACNAB" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento com o erro  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogAtu("ERRO","FA150BCO",Ap5GetHelp("FA150BCO"))

	Return .F.
Endif

dbSelectArea("SEE")
SEE->( dbSeek(xFilial("SEE")+cBanco+cAgencia+cConta+cSubCta) )
If !SEE->( found() )
	Help(" ",1,"PAR150")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento com o erro  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogAtu("ERRO","PAR150",Ap5GetHelp("PAR150"))

	Return .F.
Else
	If !Empty(SEE->EE_FAXFIM) .and. !Empty(SEE->EE_FAXATU) .and. Val(SEE->EE_FAXFIM)-Val(SEE->EE_FAXATU) < 100
		Help(" ",1,"FAIXA150")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento com o erro  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ProcLogAtu("ERRO","FAIXA150",Ap5GetHelp("FAIXA150"))

	Endif
Endif

// Verifica se será gerado uma linha no final do arquivo.
// Se nao existir o campo que determina se deve ou nao saltar
// a linha na gravacao do trailler do arquivo, ou se existir e
// estiver como "1-Sim", Grava o final de linha (Chr(13)+Chr(10))
If SEE->EE_FIMLIN == "1"
	lFimLin := .T.
Else
	lFimLin := .F.
EndIf

// MV_PAR10 - Considera filiais? -> 1-Sim / 2-Não.
if MV_PAR10 == 2
	cFilDe := cFilAnt
	cFilAte:= cFilAnt
Else
	cFilDe := MV_PAR11
	cFilAte:= MV_PAR12
Endif

nTotCnab2 := 0
nSeq := 0

If lRecicl
	cFile := "RECICL" + Substr(cNumEmp,1,2) + ".TXT"
	If !File(cFile)
		lRecicl := .F.
	Else
		CArqRecicl(cFile, .T.)
	EndIf
EndIf

If lF150Ord
	nOrdSE1 := ExecBlock("F150ORD",.F.,.F.)
EndIf

//Gestao
If lQuery
	// MV_PAR14 - Seleciona filiais? -> 1-Sim / 2-Não.
	If MV_PAR14 == 1
		// SE1 totalmente compartilhado nao habilita tela de selecao de filiais
		If lSE1Acces
			aSelFil := {cFilAnt}
		Else
			aSelFil := AdmGetFil(.F.,.T.,"SE1")
		Endif

		If Len(aSelFil) > 0
			cFilDe  := aSelFil[1]
			cFilAte := aTail(aSelFil)

			dbSelectArea("SM0")
			dbSetOrder(1) // M0_CODIGO, M0_CODFIL.
			MsSeek(cEmpAnt + cFilDe, .T.)
			bWhile := {|| Left(SM0->M0_CODFIL, FWSizeFilial()) <= cFilAte}
		Else
			bWhile := {|| .F.}  // Se não selecionou nenhuma filial, não processa nada.
		Endif
	Else
		dbSelectArea("SM0")
		dbSetOrder(1) // M0_CODIGO, M0_CODFIL.
		MsSeek(cEmpAnt + cFilDe, .T.)
		bWhile := {|| Left(SM0->M0_CODFIL, FWSizeFilial()) <= cFilAte}
	Endif
Else
	dbSelectArea("SM0")
	dbSetOrder(1) // M0_CODIGO, M0_CODFIL.
	MsSeek(cEmpAnt + cFilDe, .T.)
	lAchouBord := .F.
	bWhile := {|| FWGETCODFILIAL <= cFilAte}
Endif

While SM0->(!Eof()) .and. SM0->M0_CODIGO == cEmpAnt .and. Eval(bWhile)

	cFilAnt := FWGETCODFILIAL

	// Gestao
	// MV_PAR14 - Seleciona filiais? -> 1-Sim / 2-Não.
	If lQuery .and. MV_PAR14 == 1
		// Verifico se a filial esta contida na matriz de filiais selecionadas pelo usuario
		If aScan(aSelFil, cFilAnt) = 0
			SM0->(dbSkip())
			Loop
		Endif
	Endif

	dbSelectArea("SE1")
	SE1->( dbSetOrder(nOrdSE1) )

	If (MV_PAR13 == 1 .And. mv_par09 == 2) .Or.;
		MV_PAR13 == 3 .Or. mv_par09 == 1 // Quebra por Bordero no CNAB modelo 2, ou se nao quebra ou se for CNAB modelo 1
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicia a leitura do arquivo de Titulos                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lGestao
			SE1->( MSSeek( FWCompany("SE1") + FWUnitBusiness("SE1") + FWFilial("SE1") + mv_par01, .T. ) )
			bWhile2 := { || !SE1->( Eof()) .and. E1_NUMBOR >= mv_par01 .AND. E1_NUMBOR <= mv_par02 .and. FWCompany("SE1") + FWUnitBusiness("SE1") + FWFilial("SE1") == E1_FILIAL }
		Else
			SE1->( MSSeek(xFilial("SE1")+mv_par01,.T.))
			bWhile2 := { || !SE1->( Eof()) .and. E1_NUMBOR >= mv_par01 .AND. E1_NUMBOR <= mv_par02 .and. xFilial("SE1")==E1_FILIAL }
		EndIf

		cAliasTrb := "SE1"
	Elseif MV_PAR13 == 2 .And. mv_par09 == 2 // Quebra por Cliente no CNAB modelo 2
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicia a leitura do arquivo de Titulos                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cOrder := "E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO"

		cAliasTrb := GetNextAlias()
		cQuery := "SELECT SE1.R_E_C_N_O_ RECNOSE1 "
		cQuery += "FROM "+	RetSqlName("SE1") + " SE1"
		cQuery += " WHERE E1_FILIAL = '" + xFilial("SE1") + "'"
		cQuery += " AND E1_NUMBOR <> '" + Space(Len(SE1->E1_NUMBOR)) + "'"
		cQuery += " AND E1_NUMBOR between '" + mv_par01 + "' AND '" + mv_par02 + "'"
		cQuery += " AND D_E_L_E_T_ = ' ' "
		cQuery += " ORDER BY "+SqlOrder(cOrder)
		cQuery := ChangeQuery(cQuery)

		dbSelectArea("SA1")
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasTrb, .F., .T.)
		bWhile2 := { || !(cAliasTrb)->( Eof()) }
	Endif

	// Processa SE1 filtrado por bordero em ordem de cliente ou em ordem de bordero
	While Eval(bWhile2)

		If MV_PAR13 == 2 .And. mv_par09 == 2 // quebra por cliente, CNAB modelo 2
			SE1->(MsGoto((cAliasTrb)->RECNOSE1))
		Endif

		lAchouBord := .T.
		IncProc()

		//PCREQ-3782 - Bloqueio por situação de cobrança
		cLstSit := F023VerBlq("2","0009")
		// Valida se está em situação de cobrança que bloqueia o envio de CNAB
		If SE1->E1_SITUACA $ cLstSit .AND. aScan(aHlpSit,SE1->E1_NUMBOR) == 0
			aadd(aHlpSit,SE1->E1_NUMBOR)//{SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA}
		Endif

		IF Empty(SE1->E1_NUMBOR) .or. SE1->E1_SITUACA $ cLstSit .or. (SE1->E1_NUMBOR == cNumBorAnt .and. lBorBlock )
			(cAliasTrb)->( dbSkip() )
			Loop
		EndIF

		If lF150BBCO
			lBCOBORD := Execblock("F150BBCO",.F.,.F.)
			lBCOBORD := IF(ValType(lBCOBORD) == "L", lBCOBORD, .T.)
		EndIf
		IF (SE1->E1_PORTADO<>cBanco .Or. cAgencia<>SE1->E1_AGEDEP .Or. SE1->E1_CONTA<>cConta) .And. lBCOBORD
			(cAliasTrb)->( dbSkip() )
			Loop
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verificacao do usuario se o bordero deve ser considerado     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lF150Exc
			If !(ExecBlock("F150EXC",.F.,.F.))
				(cAliasTrb)->( dbSkip() )
				Loop
			Endif
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o portador do bordero ‚ o mesmo dos parametros   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		// Se mudou o bordero ou se CNAB modelo 2, com quebra por cliente e mudou o cliente
		If SE1->E1_NUMBOR != cNumBorAnt .Or. (MV_PAR13 == 2 .And. mv_par09 == 2 .And. SE1->E1_CLIENTE != cCliAnt) .or. lFirstBord
			// Se CNAB modelo 2 e mudou o bordero ou cliente
			If (mv_par09 == 2 .And. (MV_PAR13 == 1 .And. SE1->E1_NUMBOR != cNumBorAnt) .Or. (MV_PAR13 == 2 .And. SE1->E1_CLIENTE != cCliAnt)) .And. !lFirstBord
				lNovoLote := .T. // Para criar Trailler de Lote e Header do novo lote
			Endif
			lFirstBord := .F.
			dbSelectArea("SEA")
			If Fa150PesqBord(SE1->E1_NUMBOR,@cFilBor,cCart,.T.)
				While SEA->EA_NUMBOR == SE1->E1_NUMBOR .and. SEA->EA_FILIAL == cFilBor .and. !Eof()
					If SEA->EA_CART == "R"
						cNumBorAnt := SE1->E1_NUMBOR
						cCliAnt	  := SE1->E1_CLIENTE
						lBorBlock := .F.
						If cBanco+cAgencia+cConta != SEA->(EA_PORTADO+EA_AGEDEP+EA_NUMCON) .And. lBCOBORD
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Bordero pertence a outro Bco/Age/Cta ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							Help(" ",1,"NOBCOBORD",,cNumBorAnt,4,1)

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Atualiza o log de processamento com o erro  ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							ProcLogAtu("ERRO","NOBCOBORD",Ap5GetHelp("NOBCOBORD")+cNumBorAnt)

							lBorBlock := .T.
						Endif

						If SEA->EA_BORAPI == "S" .And. !lBorBlock
							AADD(aBorApi, SE1->E1_NUMBOR)
							lBorBlock	:= .T.
						EndIf

						Exit
					Else
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Bordero pertence a outra Carteira (Pagar) ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						lBorBlock := .T.
						SEA->(dbSkip())
						Loop
					Endif
				Enddo
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Bordero nÆo foi achado no SEA        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Help(" ",1,"BORNOXADO",,SE1->E1_NUMBOR,4,1)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o log de processamento com o erro  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ProcLogAtu("ERRO","BORNOXADO",Ap5GetHelp("BORNOXADO")+SE1->E1_NUMBOR)

				lBorBlock := .T.
			Endif
		Endif
		
		dbSelectArea(cAliasTrb)
		
		If lBorBlock
			(cAliasTrb)->( dbSkip() )
			Loop
		Endif

		IF SE1->E1_TIPO $ MVRECANT+"/"+MVPROVIS
			(cAliasTrb)->( dbSkip() )
			Loop
		EndIF

		IF SE1->E1_SALDO == 0
			(cAliasTrb)->( dbSkip() )
			Loop
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	  	//³ Ponto de entrada para desprezar a gravação do título que ³
	  	//³ tenha algum impedimento no arquivo de envio.	         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lF150NoGrv
			If !(Execblock("F150NOGRV",.F.,.F.))
				(cAliasTrb)->(dbSkip())
				Loop
			EndIf
		EndIf
	    
		//Posiciona no Contrato bancario
		dbSelectArea("SE9")
		SE9->(dbSetOrder(1))
		SE9->(MsSeek(xFilial("SE9")+SE1->(E1_CONTRAT+E1_PORTADO+E1_AGEDEP)))
	   
	    //Posiciona no cliente
		dbSelectArea("SA1")
		SA1->(DbSetOrder(1))
		SA1->(MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA))
		
		//Se o Header do arquivo nao foi criado, cria.
		If !lHeadMod2  //Modelo 2
			lHeadMod2:=AbrePar(@cArqGerado)	//Abertura Arquivo ASC II
			// Se houve erro na criacao do arquivo, abandona o processo
			If ! lHeadMod2
				Exit
			Endif
		Endif
		
		lCnabEmail := (SA1->A1_BLEMAIL == "1")
		
		If lFIN150_1
			Execblock("FIN150_1",.F.,.F.)
		Endif

		dbSelectArea(cAliasTrb)

		// Mudou de Bordero e nao eh o primeiro bordero. Cria Trailler de Lote e Novo Header de lote.
		If lNovoLote .And. mv_par09 == 2 .And. (MV_PAR13 == 1 .Or. MV_PAR13 == 2)
			nLotCnab2++
			nTotLinArq += nQtdLinLote  // Total das linhas do arquivo.

			// CNAB Modelo 2, gera Trailler do Lote anterior e Header do novo lote
			RodaLote2(nHdlSaida,MV_PAR03)
			HeadLote2(nHdlSaida,MV_PAR03)
			cNumBorAnt	:= SE1->E1_NUMBOR
			lNovoLote 	:= .F.
			nQtdTitLote := 0
			nQtdLinLote := 0
			nSomaVlLote := 0
		Endif

		If lRecicl
			dbSelectArea("CTEMP")
			If MsSeek(xFilial("SE1")+SE1->E1_NUMBCO)
				RecLock("CTEMP")
				dbDelete()
				MsUnLock()
			EndIf
		EndIf

		nSeq++
		nQtdTitLote ++
		nQtdTotTit ++
		lAtualiza := .T.
		
		If ( MV_PAR09 == 1 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Le Arquivo de Parametrizacao                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nLidos:=0
			FSEEK(nHdlBco,0,0)
			nTamArq:=FSEEK(nHdlBco,0,2)
			FSEEK(nHdlBco,0,0)
			
			lIdCnab  := .T.
			cLinCnab := ""			
			
			While nLidos <= nTamArq

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica o tipo qual registro foi lido                       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				xBuffer:=Space(85)
				FREAD(nHdlBco,@xBuffer,85)

				cTipoChr	:= SubStr(xBuffer,1,1)				

				Do Case
					Case cTipoChr == aTipoChr[1]
						IF lHeader
							nLidos+=85
							Loop
						EndIF
					Case cTipoChr == aTipoChr[2]
						lFirst2 := .F. //Controle do detalhe tipo 5
						IF !lFirst
							lFirst := .T.

							If SubStr(cBuffWrite,1,1) == "0" .And. MV_PAR09 == 1 .And. __lF150GRV
								fwrite(nHdlSaida , cBuffWrite + Chr(13) + Chr(10))
								cBuffWrite	:= ""
							Else
								F150Write(nHdlSaida,CHR(13)+CHR(10))
							Endif

							If lFINA150
								Execblock("FIN150",.F.,.F.)
							Endif
						EndIF
					Case cTipoChr == aTipoChr[4] .and.  lCnabEmail
						IF !lFirst2
							nSeq++
							lFirst2 := .T.
							F150Write(nHdlSaida,CHR(13)+CHR(10))
						Endif
					Case cTipoChr == aTipoChr[3]
						nLidos+=85
						Loop
					Otherwise
						nLidos+=85
						Loop
				EndCase
				
				nTam      := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
				nDec      := Val(SubStr(xBuffer,23,1))
				cConteudo := SubStr(xBuffer,24,60)
				nGrava    := fA150Grava(nTam, nDec, cConteudo, @aBordero, Nil, lFinCnab2, @lIdCnab, cFilBor, @cLinCnab)
				cLinCnab  := IIf(cTipoChr == aTipoChr[1],"",cLinCnab) 
				
				If nGrava != 1
					nSeq--
					Exit
				Endif
				
				dbSelectArea("SE1")
				nLidos+=85
			EndDO
			
			If nGrava == 3
				Exit
			Endif
			
			cCodOfi := SA6->A6_COD
			
			If !cCodOfi $ "341" // Itaú
				If SA6->A6_BCOOFI $ "341"
					cCodOfi := SA6->A6_BCOOFI
				ElseIf SEE->EE_CODOFI $ "341"
					cCodOfi := SEE->EE_CODOFI
				EndIf
			EndIf
			
			If cCodOfi == "341" .And. SEE->EE_NRBYTES == 400 .And. Empty(SE1->E1_CODBAR) .AND. Empty(SE1->E1_CODDIG)// Itaú				
				CodBarE1(cLinCnab, 63, 8, 121, 6, 127, 13, cCodOfi)
			Endif
		Else
			nGrava := fA150Grava(,,,@aBordero,,lFinCnab2,@lIdCnab) 
		EndIf

		If lF150Sum
			nValor := ExecBlock("F150SUM",.F.,.F.)
			nSomaValor	+= nValor
			nSomaVlLote += nValor
		ElseIf nTecla == nil .Or. nTecla == 1
			nSomaValor	+= SE1->E1_SALDO+SE1->E1_SDACRES-SE1->E1_SDDECRE
			nSomaVlLote += SE1->E1_SALDO+SE1->E1_SDACRES-SE1->E1_SDDECRE
   		Endif

	   	If lF150SumA
			nSomaAcres += ExecBlock("F150SUMA",.F.,.F.)
		ElseIf nTecla == nil .Or. nTecla == 1
		  	nSomaAcres += SE1->E1_SDACRES
		Endif

		If lF150SumD
			nSomaDecre += ExecBlock("F150SUMD",.F.,.F.)
		ElseIf nTecla == nil .Or. nTecla == 1
		  	nSomaDecre += SE1->E1_SDDECRE
		Endif

		If nGrava == 1
			lAtuDsk := .T.
			If ( MV_PAR09 == 1 )
				lIdCnab := .T.	// Para obter novo identificador do registro CNAB na rotina FA150GRAVA
				F150Write(nHdlSaida,CHR(13)+CHR(10), , .T.)
				IF !lHeader
					lHeader := .T.
				EndIF
			Endif
			dbSelectArea("SEA")
			SEA->(DbSetOrder(1))
			If SEA->(MsSeek(cFilBor+SE1->E1_NUMBOR+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
				Reclock("SEA")
				SEA->EA_TRANSF := "S"
				MsUnlock() 
			Endif
			If lRecicl
				dbSelectArea("SE1")
				RecLock("SE1")
				Replace E1_OCORREN With "01"
				MsUnLock()
			EndIf
		ElseIf nGrava == 3
			Exit
		Endif

		If lFIN150_2
			nSeq++
			If !(Execblock("FIN150_2",.f.,.f.))		// N„o incrementou
				nSeq--
			Endif
		Endif
		dbSelectArea("SE1")
		(cAliasTrb)->( dbSkip())
	Enddo

	If lAborta
		Exit
	EndIf

	//PCREQ-3782 - Bloqueio por situação de cobrança
	//Informa quais títulos não serão enviados por bloqueio de siuação de cobrança
	If len(aHlpSit) >= 1
			cHlpSit := CRLF
		For nX := 1 to len(aHlpSit)
			cHlpSit += aHlpSit[nX] + CRLF//aHlpSit[nX,1] +" - "+ aHlpSit[nX,2] +" - "+ aHlpSit[nX,3]
		Next nX
		Help(" ",1,"BLQENCNAB",,STR0024+CRLF+cHlpSit,1,0) //Os borderôs abaixo não foram enviados devido bloqueio por situação de cobrança
	Endif

	nX	:= 1
	If Len(aBorApi) >= 1
		cHlpBor := CRLF
		For nX := 1 to Len(aBorApi)
			cHlpBor += aBorApi[nX] + CRLF //aBorApi[nX,1] +" - "+ aBorApi[nX,2] +" - "+ aBorApi[nX,3]
		Next nX

		Help(" ",1,"BLQENVCNAB",,STR0044 + CRLF + cHlpBor,1,0) //Os arquivos de CNAB não foram gerados para os borderôs abaixo, já que os mesmos foram enviados por comunicação on-line.
	EndIf

	If MV_PAR13 == 2 .And. mv_par09 == 2 // Quebra por cliente CNAB modelo 2
		(cAliasTrb)->(DbCloseArea())
	Endif
	If lGestao
		If lAchouBord .And. Empty( cFilFwSE1 )
			Exit
		EndIf
	Else
		If Empty( cFilFwSE1 )
			Exit
		Endif
	EndIf
	dbSelectArea("SM0")
	dbSkip()
EndDO

SM0->(dbgoto(nRegEmp))
cFilAnt := FWGETCODFILIAL

If !lAchouBord
	Help(" ",1,"BORD150")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento com o erro  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogAtu("ERRO","BORD150",Ap5GetHelp("BORD150"))

	Return .F.
EndIF

// Se conseguiu criar o Header do arquivo, entao cria o Trailler
If lHeadMod2

	If ( mv_par09 == 1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Registro Trailler                              		  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nSeq++
		nLidos:=0
		FSEEK(nHdlBco,0,0)
		nTamArq:=FSEEK(nHdlBco,0,2)
		FSEEK(nHdlBco,0,0)
		While nLidos <= nTamArq

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Tipo qual registro foi lido                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			xBuffer:=Space(85)
			FREAD(nHdlBco,@xBuffer,85)

			IF SubStr(xBuffer,1,1) == CHR(3)
				lTrailler := .T.
				nTam := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
				nDec := Val(SubStr(xBuffer,23,1))
				cConteudo:= SubStr(xBuffer,24,60)
				nGrava:=fA150Grava( nTam,nDec,cConteudo,@aBordero,.T.,lFinCnab2,.F.,cFilBor)
			Endif
			nLidos+=85
		End
		If lTrailler .And. lFimLin
			F150Write(nHdlSaida,CHR(13)+CHR(10))
		Endif
	Else
		nTotLinArq += nQtdLinLote  // Total das linhas do arquivo.
		RodaCnab2(nHdlSaida,MV_PAR03,lFimLin)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Numero do ultimo Disco                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SEE")
	IF !Eof() .and. nGrava != 3 .and. lAtuDsk
		Reclock("SEE")
		nUltDisco:=VAL(EE_ULTDSK)+1
		Replace EE_ULTDSK With StrZero(nUltDisco,TamSx3("EE_ULTDSK")[1])
		MsUnlock()
	EndIF

	dbSelectArea( cAlias )
	dbGoTo( nSavRecno )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Fecha o arquivos utilizados                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	FCLOSE(nHdlBco)
	if len(cBuffWrite) > 0 
   		fwrite(nHdlSaida,cBuffWrite)
   		cBuffWrite := ''
    endif
	FCLOSE(nHdlSaida)

	If GetRemoteType() == 5 // WebApp
		If CpyS2TW(cNomeSai) <> 0
			Help(" ",1, "CpyS2TW",, STR0045, 1, 0) // "Falha no download do arquivo!"
		EndIf
	EndIf

	If nGrava == 3 // Abandonou a rotina, quando o bordero ja foi enviado.
		// Apaga o arquivo de saida, para nao caracterizar um erro no programa a geracao incompleta do arquivo quando o usuario cancelar.
		If FErase(cArqGerado) = 0
			If !Empty(cArqBkp)
				nStatBkp := FRenameEx( cArqBkp , cNomeSai  )
				If nStatBkp <> 0
					Help(" ",1,"F150ERRREST",,Str(fError(),4),1,0)
				EndIf
			EndIf
		EndIf

		ProcLogAtu("ERRO","",STR0019) //"Processo Cancelado por usuário. Arquivo não gerado"
	Else
		ProcLogAtu("ALERTA","",STR0020+cArqGerado) //"Processo Finalizado. Arquivo gerado: "
	Endif

	If lRecicl
		dbSelectArea("CTEMP")
		Pack
		CArqRecicl(cFile, .F.)
	EndIF

	If lFIN150_3
		Execblock("FIN150_3",.F.,.F.)
	Endif

Endif

//Ponto de entrada para verificacao do conteudo da variavel nQtdTotTit
If ExistBlock ("F150QTDT")
	ExecBlock("F150QTDT",.F.,.F.,{nQtdTotTit,nGrava})
EndIf

If lErroCBar
	Help(" ", 1, "ERRCDBAR",, STR0046, 1, 0) //"Erro na geração do código de barras / linha digitável de um ou mais títulos."
EndIf

dbSelectArea( cAlias )
dbGoTo( nSavRecno )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Recupera a Integridade dos dados                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RetIndex("SE1")
dbSetOrder(1)
dbClearFilter()

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AbrePar   ³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Abre arquivo de Parametros                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³AbrePar()                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA150                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function AbrePar(cArqGerado As Character, lPix As Logical) As Logical

	Local aArea		As Array
	Local cArqEnt	As Character
	Local cArqSaida	As Character
	Local cDirEnvio	As Character
	Local cHoraBkp	As Character
	Local lF150Arq	As Logical
	Local nOpcArq	As Numeric
	Local nStatBkp	As Numeric
	Local cArqDrv 	As Character
	Local cArqDir	As Character
	Local cArqNom	As Character
	Local cArqExt	As Character

	Default lPix := .F.

	aArea		:= GetArea()
	cArqEnt		:= MV_PAR03
	cArqSaida	:= ""
	cDirEnvio	:= AllTrim(SuperGetMV("MV_LOCENV", .F., .F.))
	cHoraBkp	:= ""
	lF150Arq	:= ExistBlock("F150ARQ")
	nOpcArq		:= 0
	nStatBkp	:= 0

	If __lVldExtC == Nil
		__lVldExtC := FindFunction("VldExtCNAB")
	EndIf

	//MV_LOCENV - Parâmetro onde será gravado o diretório
	If Empty(cDirEnvio) .or. (lPix .and. GetRemoteType() <> 2)	// Nao trata Unix

		If AT(".",mv_par04)>0 .and. (AT("/",mv_par04)>0 .or. AT("\",mv_par04)>0)
			cArqSaida:=SubStr(TRIM(mv_par04),1,AT(".",mv_par04)-1)+"."+TRIM(SEE->EE_EXTEN)

		elseif (AT("/",mv_par04)>0 .or. AT("\",mv_par04)>0)
			cArqSaida:= alltrim(mv_par04)+"."+TRIM(SEE->EE_EXTEN)
		else
			Help(" ",1,"F150ARQ",,STR0022,1,0) //"Nome do Arquivo de Saida Inválido
			Return .F.
		EndIf

	ElseIf !Empty(MV_PAR04) .And. At(":", MV_PAR04) == 0 .And. (At("/", MV_PAR04) == 0 .Or. At("\", MV_PAR04) == 0) ;
			.And. (At("/", cDirEnvio) > 0	.Or. At("\", cDirEnvio) > 0)

		If At("/", cDirEnvio) > 0 .And. RAt("/", SubStr(cDirEnvio, Len(cDirEnvio), 1)) == 0

			If AT(".",mv_par04)>0
				cArqSaida := cDirEnvio + "/" + SubStr(Trim(MV_PAR04), 1, At(".", MV_PAR04) - 1) + "." + Trim(SEE->EE_EXTEN)
			Else
				cArqSaida := cDirEnvio + "/" + Trim(MV_PAR04) + "." + Trim(SEE->EE_EXTEN)
			Endif

		ElseIf At("/", cDirEnvio) > 0 .And. RAt("/", SubStr(cDirEnvio, Len(cDirEnvio), 1)) > 0

			If AT(".",mv_par04)>0
				cArqSaida := cDirEnvio + SubStr(Trim(MV_PAR04), 1, At(".", MV_PAR04) - 1) + "." + Trim(SEE->EE_EXTEN)
			Else
				cArqSaida := cDirEnvio + Trim(MV_PAR04) + "." + Trim(SEE->EE_EXTEN)
			Endif

		ElseIf At("\" ,cDirEnvio) > 0 .And. RAt("\", SubStr(cDirEnvio, Len(cDirEnvio), 1)) == 0

			If AT(".",mv_par04)>0
				cArqSaida := cDirEnvio + "\" + SubStr(Trim(MV_PAR04), 1, At(".", MV_PAR04) - 1) + "." + Trim(SEE->EE_EXTEN)
			Else
				cArqSaida := cDirEnvio + "\" + Trim(MV_PAR04) + "." + Trim(SEE->EE_EXTEN)
			Endif

		ElseIf At("\", cDirEnvio) > 0 .And. RAt("\", SubStr(cDirEnvio, Len(cDirEnvio), 1)) > 0

			If AT(".",mv_par04)>0
				cArqSaida := cDirEnvio + SubStr(Trim(MV_PAR04), 1, At(".", MV_PAR04) - 1) + "." + Trim(SEE->EE_EXTEN)
			Else
				cArqSaida := cDirEnvio + Trim(MV_PAR04) + "." + Trim(SEE->EE_EXTEN)
			Endif
		 EndIf

	ElseIf Empty(MV_PAR04) .Or. (At("/", MV_PAR04) > 0 .Or. At("\", MV_PAR04) > 0 .Or. At(":", MV_PAR04) > 0)

		Help(" ",1,"F150ARQ",,STR0023,1,0) //"Nome do Arquivo de Saida Inválido
		Return .F.

	EndIf

	If lF150Arq .and. !FWIsInCallStack("FA150PIX")
		cArqSaida := ExecBlock("F150ARQ",.F.,.F.,cArqSaida)
	EndIf

	If GetRemoteType() == 2	// Linux / Unix
		cArqSaida := Lower(StrTran(cArqSaida,"\","/"))
	EndIf

	If GetRemoteType() == 5 // WebApp
		SplitPath(cArqSaida, @cArqDrv, @cArqDir, @cArqNom, @cArqExt)
		cArqSaida := "/spool/" + IIF(Empty(cArqSaida), "CnabArqRec", cArqNom) + cArqExt
	EndIf

	cArqGerado := cArqSaida

	nPosFim := RAt("/", cArqGerado)

	If !(nPosFim > 0)
		nPosFim := RAt("\", cArqGerado)
	EndIf

	If !(ExistDir(Left(cArqGerado, nPosFim))) // Desconsidera WebApp na validação do diretório
		Help("", 1, "NODIR")
		Return .F.
	EndIf

	IF !(File(cArqEnt))
		Help(" ",1,"NOARQPAR")
		//Atualiza o log de processamento com o erro
		ProcLogAtu("ERRO","NOARQPAR",Ap5GetHelp("NOARQPAR"))
		Return .F.
	ElseIf __lVldExtC .And. !(VldExtCNAB(SubStr(cArqEnt, At(".", cArqEnt) + 1), "FINA150"))
		Return .F.
	Else
		If (MV_PAR09 == 1)
			nHdlBco := FOpen(cArqEnt, 0 + 64)
		EndIf
	EndIf

	//Cria Arquivo Saida
	cNomeSai := AllTrim(cArqSaida)

	If File(cNomeSai)
		nOpcArq := Aviso(STR0028 + " !!!" , + ;
		STR0029 + " '" + Alltrim(cNomeSai) + "' " + STR0030 + CRLF + CRLF + ;
		STR0031 + CRLF + CRLF + ;
		STR0032 + CRLF + CRLF + ;
		STR0033 + CRLF + CRLF + CRLF + CRLF + ;
		STR0012 , {STR0034,STR0035,STR0001} )
		If nOpcArq == 2
			cHoraBkp := Time()
				cArqBkp  := AllTrim(cNomeSai) + "_" + DToS(ddatabase) + "_" + SubStr(cHoraBkp, 1, 2) + SubStr(cHoraBkp, 4, 2) + ".bkp"
			nStatBkp := FRenameEx( cNomeSai , cArqBkp )
			If nStatBkp <> 0
				Help(" ",1,"F150ERRBKP",,Str(fError(),4),1,0)
				lAborta := .T.
				Return .F.
			EndIf
		ElseIf nOpcArq == 3
			lAborta := .T.
			Return .F.
		EndIf
	EndIf

	If ( MV_PAR09 == 1 )
		nHdlSaida:=MSFCREATE(cArqSaida,0)
	Else
		nHdlSaida:=HeadCnab2(cArqSaida,MV_PAR03)
	Endif

	RestArea(aArea)

Return .T.

/*/
{Protheus.doc} fA150Grava
description
@type function
@version  
@author Wagner Xavier
@since 26/05/92
@param nTam, numeric, param_description
@param nDec, numeric, param_description
@param cConteudo, character, param_description
@param aBordero, array, param_description
@param lTrailler, logical, param_description
@param lFinCnab2, logical, param_description
@param lIdCnab, logical, param_description
@param cFilBor, character, param_description
@return numeric, return_description
/*/

STATIC Function fA150Grava( nTam as Numeric,nDec as Numeric,cConteudo as Character,aBordero as Array,lTrailler as Logical,lFinCnab2 as Logical,lIdCnab as Logical,cFilBor as Character, cBuffLinha As Character) as Numeric
Local nRetorno  as Numeric
Local nX        as Numeric
Local oDlg      as Object
Local oRad      as Object
Local cIdCnab   as Character
Local aGetArea  as Array
Local aOrdSE1   as Array
Local lPanelFin as Logical
Local cChaveID  as Character
Local nOrdCNAB  as Numeric
Local nPos      as Numeric 
Local cAux      as Character
Local cCodOfi   as Character   

DEFAULT lIdCnab    := .F.
DEFAULT cFilBor    := xFilial("SEA")
Default cBuffLinha := ""
nRetorno  := 1
nX        := 1
oDlg      := Nil
oRad      := Nil
cIdCnab   := ""
aGetArea  := GetArea()
aOrdSE1   := {}
lPanelFin := IsPanelFin()
cChaveID  := ""
nOrdCNAB  := 19
nPos 	  := 0
cAux	  := ""
cCodOfi   := ""

lTrailler := IIF( lTrailler==NIL, .F., lTrailler ) // Para imprimir o trailler
                                                   // caso se deseje abandonar
                                                   // a gera‡Æo do arquivo
                                                   // de envio pela metade

lFinCnab2 := Iif( lFinCnab2 == Nil, .F., lFinCnab2 )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ O retorno podera' ser :                                  ³
//³ 1 - Grava Ok                                             ³
//³ 2 - Ignora bordero                                       ³
//³ 3 - Abandona rotina                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se titulo ja' foi enviado                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SEA")
SEA->(DbSetOrder(1))
If	(!SE1->( Eof()) .and. SE1->E1_NUMBOR >= mv_par01 .AND. SE1->E1_NUMBOR <= mv_par02 .and. xFilial("SE1")==SE1->E1_FILIAL) .And.;
	(SEA->(MsSeek(cFilBor+SE1->E1_NUMBOR+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO)))
	If SEA->EA_TRANSF == "S"
		nX := ASCAN(aBordero,SubStr(SE1->E1_NUMBOR,1,6))
		If nX == 0
			nOpc := 0
			aSize := MSADVSIZE()
			If lPanelFin  //Chamado pelo Painel Financeiro
				oPanelDados := FinWindow:GetVisPanel()
				oPanelDados:FreeChildren()
				aDim := DLGinPANEL(oPanelDados)
				DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Observacao Importante quanto as coordenadas calculadas abaixo: ³
				//³ -------------------------------------------------------------- ³
				//³ a funcao DlgWidthPanel() retorna o dobro do valor da area do	 ³
				//³ painel, sendo assim este deve ser dividido por 2 antes da sub- ³
				//³ tracao e redivisao por 2 para a centralizacao. 					 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nEspLarg := ((DlgWidthPanel(oPanelDados)/2) - 114) /2
				nEspLin  := 0

		   Else
		   	nEspLarg := 0
		   	nEspLin  := 0
				DEFINE MSDIALOG oDlg FROM  010,037 TO 140,383 TITLE OemToAnsi(STR0009) PIXEL  // "Bordero Existente"
			Endif
			oDlg:lMaximized := .F.
			oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
			oPanel:Align := CONTROL_ALIGN_ALLCLIENT

			@ 027+nEspLin,006+nEspLarg TO 057+nEspLin, 120+nEspLarg LABEL OemToAnsi(STR0012) OF oPanel  PIXEL  //"Para prosseguir escolha uma das op‡äes"

			@ 011+nEspLin, 007+nEspLarg SAY OemToAnsi(STR0010)+" "+Alltrim(SE1->E1_NUMBOR)+" "+OemToAnsi(STR0011) 			SIZE 101, 007 OF oPanel PIXEL  // "O border“ n£mero:"
			@ 035+nEspLin, 011+nEspLarg RADIO oRad VAR nTecla 3D	 		SIZE 069, 011 PROMPT OemToAnsi(STR0013),OemToAnsi(STR0014) OF oPanel PIXEL  // "Gera com esse border“"###"Ignora esse border“"

			If lPanelFin  //Chamado pelo Painel Financeiro
				ACTIVATE MSDIALOG oDlg CENTERED ON INIT FaMyBar(oDlg,{||nOpc:=1,oDlg:End()},{||nOpc:=0,oDlg:End()})

		   Else
				DEFINE SBUTTON FROM 011, 0140 TYPE 1 ENABLE OF oPanel Action (nOpc:=1,oDlg:End())
				DEFINE SBUTTON FROM 024, 0140 TYPE 2 ENABLE OF oPanel Action (nOpc:=0,oDlg:End())
				ACTIVATE MSDIALOG oDlg Centered
			Endif

			If nOpc == 1
				If nTecla == 1
					nRetorno := 1
					nBorderos++
				Else
					nRetorno := 2
				EndIf
			Else
				nRetorno := 3
				lAborta := .T.
			EndIf
		Else
			nRetorno := Int(Val(SubStr(aBordero[nX],7,1)))
		EndIf
	EndIf
EndIf

If nRetorno == 1 .or. ( lTrailler .and. nBorderos > 0 )

	If MV_PAR09 == 1
		If !lTrailler .and. lIdCnab .And. Empty(SE1->E1_IDCNAB) // So gera outro identificador, caso o titulo ainda nao o tenha, pois pode ser um re-envio do arquivo
			// Gera identificador do registro CNAB no titulo enviado
			cIdCnab := GetSxENum("SE1", "E1_IDCNAB","E1_IDCNAB"+cEmpAnt,nOrdCNAB)
			cChaveID := cIdCnab
			dbSelectArea("SE1")
			aOrdSE1 := SE1->(GetArea())
			dbSetOrder(nOrdCNAB)
			While SE1->(MsSeek(cChaveID))
				ConOut("Id CNAB " + cIdCnab + " já existe para o arquivo SE1. Gerando novo número ")
				If ( __lSx8 )
					ConfirmSX8()
				EndIf
				cIdCnab := GetSxENum("SE1", "E1_IDCNAB","E1_IDCNAB"+cEmpAnt,nOrdCNAB)
				cChaveID := cIdCnab
			EndDo

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de entrada para tratamento da variavel cIdCnab     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistBlock ("F150ICNB")
				cIdCnab := ExecBlock("F150ICNB",.F.,.F.,{cIdCnab})
			EndIf

			SE1->(RestArea(aOrdSE1))
			Reclock("SE1")
			SE1->E1_IDCNAB := cIdCnab
			MsUnlock()
			ConfirmSx8()
			lIdCnab := .F. // Gera o identificacao do registro CNAB apenas uma vez no
								// titulo enviado
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Analisa conteudo                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF Empty(cConteudo)
			cCampo:=Space(nTam)
		Else
			lConteudo := fa150Orig( cConteudo )
			IF !lConteudo
				RestArea(aGetArea)
				Return nRetorno
			Else
				IF ValType(xConteudo)="D"
					cCampo := GravaData(xConteudo,.F.)
				Elseif ValType(xConteudo)="N"
					cCampo:=Substr(Strzero(xConteudo,nTam,nDec),1,nTam)
				Else
					cCampo:=Substr(xConteudo,1,nTam)
				EndIf
			EndIf
		EndIf
		
		If Len(cCampo) < nTam  //Preenche campo a ser gravado, caso menor
			cCampo:=cCampo+Space(nTam-Len(cCampo))
		EndIf
		
		F150Write(nHdlSaida,cCampo,nTam, Nil, @cBuffLinha)
	Else
		nTotCnab2++
		DetCnab2(nHdlSaida,MV_PAR03,lIdCnab,"SE1")
		lIdCnab := .T.	// Para obter novo identificador do registro CNAB na rotina
							// DetCnab2
		cCodOfi := SA6->A6_COD
		If !cCodOfi $ "341" // Itaú
			If SA6->A6_BCOOFI $ "341"
				cCodOfi := SA6->A6_BCOOFI
			ElseIf SEE->EE_CODOFI $ "341"
				cCodOfi := SEE->EE_CODOFI
			EndIf
		EndIf
		If cCodOfi == "341" .And. (SEE->EE_NRBYTES == 240 .Or. SEE->EE_NRBYTES == 400) // Itaú
			If Empty(SE1->E1_CODBAR) .AND. Empty(SE1->E1_CODDIG)
				nPos := Len(cBuffWrite) - SEE->EE_NRBYTES - 1
				cAux := Substr(cBuffWrite, nPos, SEE->EE_NRBYTES)
				While nPos > 0				
					If (SEE->EE_NRBYTES == 240 .And. Substr(cAux,14,1 ) == "P") .Or. (SEE->EE_NRBYTES == 400 .And. Substr(cAux,1,1 ) == "1")
						CodBarE1(cAux, , , , , , , cCodOfi)
						exit 
					EndIf
					nPos := nPos - SEE->EE_NRBYTES - 2
					cAux := Substr(cBuffWrite, nPos, SEE->EE_NRBYTES)
				EndDo
			EndIf
		EndIf
		If lFinCnab2
			nSeq := Execblock("FINCNAB2",.F.,.F.,{nHdlSaida,nSeq,nTotCnab2})
		EndIf
	EndIf	
EndIf

If nX == 0
	Aadd(aBordero,Substr(SE1->E1_NUMBOR,1,6)+Str(nRetorno,1))
EndIf
RestArea(aGetArea)

If lPanelFin  //Chamado pelo Painel Financeiro
	cAlias := FinWindow:cAliasFile
	dbSelectarea(cAlias)
	FinVisual(cAlias,FinWindow,(cAlias)->(Recno()),.T.)
Endif

Return nRetorno

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NossoNum ³ Autor ³ Paulo Boschetti       ³ Data ³ 05/11/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna digito de controle                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ 		                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NossoNum( )

Local cNumero := ""
Local nTam := TamSx3("EE_FAXATU")[1]

While !MayIUseCode( SEE->(EE_FILIAL+EE_CODIGO+EE_AGENCIA+EE_CONTA+EE_SUBCTA))  //verifica se esta na memoria, sendo usado
	Sleep(100)
EndDo
// Reposiciona o registro da SEE devido a atualização da outra Thread. 
SEE->(DbGoto(SEE->(Recno()))) 

cNumero := StrZero(Val(SEE->EE_FAXATU),nTam)

If Empty(SE1->E1_NUMBCO)

	RecLock("SE1",.F.)
	Replace SE1->E1_NUMBCO With cNumero
	SE1->( MsUnlock( ) )

	RecLock("SEE",.F.)
	Replace SEE->EE_FAXATU With Soma1(cNumero, nTam)
	SEE->( MsUnlock() )

EndIf

Leave1Code(SEE->(EE_FILIAL+EE_CODIGO+EE_AGENCIA+EE_CONTA+EE_SUBCTA))
DbSelectArea("SE1")

Return(SE1->E1_NUMBCO)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Fa150Chav³ Autor ³ Paulo Boschetti       ³ Data ³ 10/11/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Fa150Num()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA130                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa150Chav()
LOCAL lRetorna := .T.
LOCAL cVar   := READVAR()

// Valida se existe a conta Oficial
If  (cVar == "M->EE_CTAOFI" .or. cVar == "M->EE_AGEOFI" .OR. cVar == "M->EE_CODOFI" )
	If !EMPTY(M->EE_CODOFI) .AND. !EMPTY(M->EE_AGEOFI).AND. !EMPTY(M->EE_CTAOFI)
		If FWIsInCallStack("FINA130") .and. !existcpo("SA6",M->EE_CODOFI+M->EE_AGEOFI+M->EE_CTAOFI)
			lRetorna := .F.
		EndIf
	EndIf
elseIf !Empty(m->ee_codigo) .And. !Empty(m->ee_agencia) .And. !Empty(m->ee_conta) .And. !Empty(m->ee_subcta)
	dbSelectArea("SEE")
	dbSetOrder(1)
	SEE->( MsSeek(xFilial("SEE")+m->ee_codigo+m->ee_agencia+m->ee_conta+m->ee_subcta) )
	If SEE->( Found() )
		Help(" ",1,"FA150NUM")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento com o erro  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ProcLogAtu("ERRO","FA150NUM",Ap5GetHelp("FA150NUM"))

		lRetorna := .F.
	EndIf
	If FunName() == "FINA130" .and. !existcpo("SA6",m->ee_codigo+m->ee_agencia+m->ee_conta)
		lRetorna := .F.
	EndIf

Endif
Return lRetorna


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fa150Orig ³ Autor ³ Wagner Xavier         ³ Data ³ 10/11/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se expressao e' valida para Remessa CNAB.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA150                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fa150Orig( cForm )
Local bBlock:=ErrorBlock()
Private lRet := .T.

BEGIN SEQUENCE
	xConteudo := &cForm
END SEQUENCE
ErrorBlock(bBlock)
Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SomaValor³ Autor ³ Vinicius Barreira     ³ Data ³ 09/01/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o valor total dos titulos remetidos                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SomaValor()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SomaValor()
Return nSomaValor * 100
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³SomaVlLote³ Autor ³ Claudio Donizete      ³ Data ³ 28/12/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o valor dos titulos remetidos do lote              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SomaVlLote()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SomaVlLote()
Return nSomaVlLote * 100
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³QtdTotTit ³ Autor ³ Claudio Donizete      ³ Data ³ 28/12/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a qtde. total dos titulos remetidos                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ QtdTotTit()  	                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function QtdTotTit()
Return nQtdTotTit
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³QtdTitLote³ Autor ³ Claudio Donizete      ³ Data ³ 28/12/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a qtde. dos titulos remetidos do lote              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ QtdTitLote()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function QtdTitLote()
Return nQtdTitLote

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Fa150PesqB³ Autor ³ Claudio D. de Souza   ³ Data ³ 20/09/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pesquisa Bordero em todas as filiais e atualiza o parametro|±±
±±³          ³ cFilBor com a filial em que foi encontrada o bordero       |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Fa420PesqBord(cNumBor,cFilBor)							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA420                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa150PesqBord(cNumBor,cFilBor,cCart,lVldBco)
Local cFilOld 	:= cFilAnt
Local cFilPos	:= ""
Local lRet 		:= .F.
Local nInc		:= 0
Local cAlias	:= Alias()
Local aSM0		:= AdmAbreSM0()
Local aFiliais  := {}
Local nPos      := 0

//--- Tratamento Gestao Corporativa
Local cFilFwSEA := FwFilial("SEA")

Default cCart	:= ""
Default lVldBco  := .F. 

// Se deve pesquisar com a carteira do bordero "P" ou "R"
If !Empty( cCart )
	SEA->( dbSetOrder( 2 ) )
Else
	SEA->( dbSetOrder( 1 ) )
EndIf

If !Empty( cFilFwSEA ) // Se o SEA for exclusivo, pesquisa o bordero em todas as filiais
	For nInc := 1 To Len( aSM0 )
		If aSM0[nInc][1] == cEmpAnt
			cFilAnt := aSM0[nInc][2]
			If SEA->( MsSeek( xFilial( "SEA" ) + cNumBor + cCart ) )
				aadd(aFiliais,{SEA->EA_FILIAL,SEA->(Recno())})
				lRet	:= .T.
			EndIf
		EndIf
	Next
Else
	lRet := SEA->( MsSeek( xFilial( "SEA" ) + cNumBor + cCart ) )
	cFilBor := SEA->EA_FILIAL
Endif

//-- Realizo a validação do banco para posicionar na SEA correta, quando localizado o borderô em mais de uma filial
If lVldBco .And. Len(aFiliais) > 1
	For nInc := 1 To Len(aFiliais)
		SEA->(dbGoto(aFiliais[nInc,2]))

		If cBanco + cAgencia + cConta == SEA->(EA_PORTADO+EA_AGEDEP+EA_NUMCON)
			cFilPos := aFiliais[nInc,1]
			Exit
		EndIf 
	Next 
EndIf

nPos := aScan(aFiliais,{|x| x[1]== Iif(!Empty(cFilPos), cFilPos, cFilOld)})
If nPos > 0
	cFilBor := aFiliais[nPos,1]
	//Posiciono no borderô da filial corrente.
	SEA->(dbGoto(aFiliais[nPos,2]))
ElseIf Len(aFiliais)>=1
	cFilBor := aFiliais[1,1]
	//Posiciono no borderô da primeira filial.
	SEA->(dbGoto(aFiliais[1,2]))
Endif 

// Restaura ambiente
cFilAnt := cFilOld

dbSelectArea( cAlias )

Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FINA150T   ³ Autor ³ Marcelo Celi Marques ³ Data ³ 15.05.08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Chamada semi-automatica utilizado pelo gestor financeiro   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA150                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FINA150T(aParam)

	cRotinaExec := "FINA150"
	ReCreateBrow("SE1",FinWindow)
	FINA150()
	ReCreateBrow("SE1",FinWindow)

	dbSelectArea("SE1")

	INCLUI := .F.
	ALTERA := .F.

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AdmAbreSM0³ Autor ³ Orizio                ³ Data ³ 22/01/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna um array com as informacoes das filias das empresas ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function AdmAbreSM0()
	Local aArea			:= SM0->( GetArea() )
	Local aRetSM0		:= FWLoadSM0()

	RestArea( aArea )
Return aRetSM0


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³F150LinLot³ Autor ³ Gustavo Henrique     ³ Data ³ 08/08/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna o total de linhas do detalhe do lote		         ³±±
±±³          ³ Usado na configuracao do CNAB2 Receber   				 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Configurador do CNAB2 Receber	 						 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function F150LinLot()
Return nQtdLinLote+1		// esta variavel armazena o numero de linhas, considerando os segmentos do detalhe do lote

//-------------------------------------------------------------------
/*/{Protheus.doc}CARQRECICL
Cria arquivo temporário / Txt com os números reciclados dos títulos
no processo de CNAB.

@param cFile - Nome do arquivo de reciclagem (.TXT)
@param lTemp - Define se cria o arquivo temporário ou o próprio .TXT

@author Rodrigo Oliveira
@since  25/05/2018
/*/
//-------------------------------------------------------------------

Function CArqRecicl(cFile, lTemp)

	Local aArea		:= GetArea()
	Local nTmArqRec	:= 0
    Local nHdl		:= 0
    Local cFil		:= ""
    Local cNosNum	:= ""
    Local nTamFil	:= FWGETTAMFILIAL
    Local nTamNNum	:= TamSX3("E1_NUMBCO")[1]
    Local nLin		:= nTamFil + nTamNNum
    Local aStru		:= { {"FILIAL  ", "C", nTamFil, 0},;
    					{"NOSSONUM", "C", nTamNNum, 0}}
    Local nI		:= 0
    Local cBuf		:= Space(nLin)

	If lTemp
		If ( nHdl	:= fOpen(cFile, FO_READWRITE + FO_SHARED) ) == -1
			Help(" ",1,"F200RECICL",,STR0025 + str(ferror(),4),1,0) // 'Erro de abertura: FERROR nº '
		Else
			If(__oTemp <> NIL)

				__oTemp:Delete()
				__oTemp := NIL

			EndIf

			//Criando a tabela temporaria
			__oTemp := FwTemporaryTable():New("CTEMP")
			//Setando as colunas
			__oTemp:SetFields(aStru)
			//Criando o indicie
			__oTemp:AddIndex("1",{"FILIAL", "NOSSONUM"})
			//Criando a Tabela Temporaria
			__oTemp:Create()

			nTmArqRec := FSeek(nHdl,0,2)
		  	FSeek(nHdl,0,0)
		  	For nI := 1 to nTmArqRec
		  		FRead(nHdl, @cBuf, nLin)
		  		cFil 	:= Left(cBuf,nTamFil)
		  		cNosNum	:= SubStr(cBuf, nTamFil + 1, nTamNNum)
		  		RecLock("CTEMP",.T.)
		  		Replace FILIAL		With xFilial("SE1")
		  		Replace NOSSONUM 	With cNosNum
		  		MsUnlock()
		  		FSeek(nHdl,2,1)
		  		nI	+= (nLin + 1)
		  	Next
		EndIf
	Else
		If FERASE(cFile) == -1
			Help(" ",1,"F150RECICL",,STR0026 + str(ferror(),4),1,0) // 'Não foi possível deletar o arquivo de reciclagem: FERROR nº '
		Else
			If !(CTEMP->(BOF()) .And. CTEMP->(EOF()) )
				If ( nHdl := fCreate(cFile) ) == -1
					Help(" ",1,"F150RECICL",,STR0027 + str(ferror(),4),1,0) // 'Erro na geração do arquivo de reciclagem: FERROR nº '
				Else
					CTEMP->(DbGoTop())
					While !Eof()
						nTmArqRec := FSeek(nHdl,0,FS_END)
						If nTmArqRec > 0
							FWrite(nHdl, Chr(13) + Chr(10) + CTEMP->FILIAL + PadR(CTEMP->NOSSONUM, nTamNNum))
						Else
							FWrite(nHdl, CTEMP->FILIAL + PadR(CTEMP->NOSSONUM, nTamNNum))
						EndIf
						DbSkip()
					EndDo
					CTEMP->(DbCloseArea())
				EndIf
			EndIf
		Endif
	EndIf

	fClose(nHdl)
	RestArea(aArea)

Return


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FA150PIX ³ Autor ³ Rodrigo Franco     ³ Data ³ 30/10/2020  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Comunicação Bancária - Envio Arquivo PIX                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FA150PIX()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA150                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FA150PIX(aBanSel, aTitSel)
	Local nI         := 0
	Local nTamArq    := 0
	Local lHeader    := .F.
	Local lFirst     := .F.
	Local lFirst2    := .F.
	LOCAL nTam       := 0
	Local nDec       := 0 
	Local nUltDisco  := 0
	Local nGrava     := 0
	Local lFinCnab2  := ExistBlock("FINCNAB2")
	Local nRegEmp    := SM0->(RecNo())
	Local cFilDe     := ""
	Local cFilAte    := ""
	Local lIdCnab    := .T.
	Local cArqGerado := ""
	Local lAtuDsk    := .F.
	Local lFimLin	 := .T.
	Local lTrailler  := .F.
	Local nStatBkp   := 0
	Local cFilFwSE1  := FwFilial("SE1")
	Local lHeadMod2  := .F.
	Local bWhile 	 := {||.T.}
	Local nVlrPix	 := 0
	Local nTxMoeda 	 := 0
	Local cMVFINPIX4 := SuperGetMV("MV_FINPIX4", .F., 'SSS')
	Local lMVCNABIMP := SuperGetMV("MV_CNABIMP", .F., .F.)
	Local lConsACDC  := Substr(cMVFINPIX4, 1, 1) == "S"
	Local lConsVA 	 := Substr(cMVFINPIX4, 2, 1) == "S"
	Local lConsImp 	 := Substr(cMVFINPIX4, 3, 1) == "S"
	Local nTitulos   := 0
	Local cMensagem  := STR0038 
	Local cTituloMsg := STR0042
	Local cTitulos   := ""
	Local lHaTitulo  := .F.
	Local nBaseImpos := 0	
	Local nVASoma    := 0
	Local nVASubtra  := 0
	Local lImposCalc := .T.
	Local cSituaCob  := ""
	Local nRecnoSE1  := 0
	Local nAbatImpos := 0
	Local nOutrosAba := 0
	
	Private cBanco
	Private cAgencia
	Private xConteudo
	Private nHdlBco    	:= 0
	Private nHdlSaida  	:= 0
	Private nSeq       	:= 0
	Private nSomaValor	:= 0
	Private nSomaVlLote	:= 0
	Private nQtdTotTit	:= 0
	Private nQtdTitLote	:= 0
	Private nSomaAcres	:= 0
	Private nSomaDecre	:= 0
	Private nBorderos	:= 0
	Private xBuffer		:= ""
	Private nLidos		:= 0
	Private nTotCnab2	:= 0 // Contador de Lay-out nao deletar
	Private nLotCnab2	:= 1 // Contador de Lotes do arquivo
	Private nLinha		:= 0 // Contador de Linhas nao deletar
	Private nQtdLinLote	:= 0 // Contador de linhas do detalhe do lote
	Private nTotLinArq	:= 0 // Contador de linhas do CNAB
	Private aFlagCTB   As Array
	Private cLote      As String
	Private cArquivo   As String
	Private nTotal     As Numeric
	Private nHdlPrv    As Numeric
	Private lCabec     As Logical
	Private lCtbPixOn  As Logical
	Private lMostraCtb As Logical
	Private lAglutCtb  As Logical
	Private lCancPix   As Logical
	Private lAtualiza  As Logical
	Private cBuffWrite  As String

	Default aBanSel := {}
	Default aTitSel := {}
	
	ProcRegua(SE1->(RecCount()))
	Pergunte("FINA890",.F.)
	lMostraCtb := MV_PAR01 == 1
	lCtbPixOn  := MV_PAR02 == 1
	lAglutCtb  := MV_PAR03 == 1
	aFlagCTB   := {}	
	
	Pergunte("AFI150",.F. )
	MV_PAR01    := ""
	MV_PAR02    := ""
	MV_PAR03    := aBanSel[6]
	MV_PAR04    := aBanSel[7]
	MV_PAR05    := aBanSel[1]
	MV_PAR06    := aBanSel[2]
	MV_PAR07    := aBanSel[3]
	MV_PAR08    := aBanSel[5]
	MV_PAR09 	:= 1
	MV_PAR10    := 2
	MV_PAR11    := ""
	MV_PAR12    := ""
	MV_PAR13	:= 3
	MV_PAR14	:= 2
	
	cBanco  := mv_par05
	cAgencia:= mv_par06
	cConta  := mv_par07
	cSubCta := mv_par08
	cChvPix := AllTrim(aBanSel[4])
	lCabec   := .F.
	nTotal   := 0
	cArquivo := ""
	cBuffWrite  := ""
	
	DbSelectArea("F70")
	F70->(DbSetOrder(2))
	F70->(DbSeek(FWxFilial("F70")+cChvPix))
	
	DbSelectArea("SA6")
	If !SA6->(DbSeek(xFilial("SA6")+cBanco+cAgencia+cConta))
		Help(" ",1,"FA150BCO")
		ProcLogAtu("ERRO","FA150BCO",Ap5GetHelp("FA150BCO"))
		Return .F.
	ElseIf Max(SA6->A6_MOEDA,1) > 1
		Help( "  ", 1, "MOEDACNAB" )
		ProcLogAtu("ERRO","FA150BCO",Ap5GetHelp("FA150BCO"))
		Return .F.
	Endif
	
	dbSelectArea("SEE")
	SEE->(DbSetOrder(1))
	
	If !SEE->(DbSeek(xFilial("SEE")+cBanco+cAgencia+cConta+cSubCta))
		Help(" ",1,"PAR150")
		ProcLogAtu("ERRO","PAR150",Ap5GetHelp("PAR150"))
		Return .F.
	ElseIf !Empty(SEE->EE_FAXFIM) .And. !Empty(SEE->EE_FAXATU) .And. Val(SEE->EE_FAXFIM) - Val(SEE->EE_FAXATU) < 100
		Help(" ", 1, "FAIXA150")
		ProcLogAtu("ERRO", "FAIXA150", Ap5GetHelp("FAIXA150"))
	Endif
	
	/*Verifica se será gerado uma linha no final do arquivo.
	Se nao existir o campo que determina se deve ou nao saltar
	a linha na gravacao do trailler do arquivo, ou se existir e
	estiver como "1-Sim", Grava o final de linha (Chr(13)+Chr(10))*/
	lFimLin   := SEE->EE_FIMLIN == "1"
	cFilDe    := cFilAnt
	cFilAte   := cFilAnt
	nTotCnab2 := 0
	nSeq      := 0
	
	DbSelectArea("SM0")
	SM0->(DbSetOrder(1))
	SM0->(MsSeek(cEmpAnt + cFilDe, .T.))
	bWhile := {|| Left(SM0->M0_CODFIL, FWSizeFilial()) <= cFilAte}
	
	__lIsBlind  := IIf(__lIsBlind == Nil, IsBlind(), __lIsBlind)
	__lPIXImp   := IIf(__lPIXImp == Nil, FindFunction("PIXGerImp"), __lPIXImp)
	__lFinPix   := IIf(__lFinPix == Nil, ExistBlock("FINVLPIX"), __lFinPix)
	__lBaImpPix := IIf(__lBaImpPix == Nil, FindFunction("BaseImpPix"), __lBaImpPix)	
	__lBordImp  := IIf(__lBordImp == Nil, FindFunction("BorderoImp"), __lBordImp)	
	__lSitCPix  := IIf(__lSitCPix == Nil, FindFunction("F022SITPIX"), __lSitCPix)
	__nCasasDc  := IIf(__nCasasDc == Nil, TamSX3("FK1_TXMOED")[2], __nCasasDc)
	
	DbSelectArea("SA1")
	DbSelectArea("SE9")
	DbSelectArea("F71")
	F71->(DbSetOrder(3))
	
	BEGIN TRANSACTION
		nTitulos := Len(aTitSel) 
		
		While SM0->(!Eof()) .And. SM0->M0_CODIGO == cEmpAnt .And. Eval(bWhile)
			cFilAnt := FWGETCODFILIAL
			
			//Inicia a leitura do arquivo de Titulos
			For nI := 1 To nTitulos
				lCancPix   := aTitSel[nI,14] == 'C'
				cChaveF71  := aTitSel[nI,9]
				nVASoma    := 0
				nVASubtra  := 0
				nAbatImpos := 0
				nOutrosAba := 0
				nBaseImpos := 0
				lImposCalc := .T.
				
				F71->(dbSetOrder(3))
				If !F71->(MsSeek(cChaveF71))
					Loop
				EndIf
				
				DbSelectArea("SE1")
				SE1->(dbSetOrder(1))
				
				If !SE1->(MsSeek(FWxFilial("SE1")+aTitSel[nI,2]+aTitSel[nI,3]+aTitSel[nI,4]+aTitSel[nI,5]))
					Loop
				EndIf
				
				If SE1->E1_TIPO $ MVRECANT+"|"+MVPROVIS
					Loop
				EndIF
				
				If !lCancPix .And. SE1->E1_SALDO == 0
					Loop
				EndIf
				
				SE9->(DbSetOrder(1))
				SA1->(DbSetOrder(1))
				SE9->(MsSeek(xFilial("SE9")+SE1->(E1_CONTRAT+aBanSel[1]+aBanSel[2])))
				SA1->(MsSeek(xFilial("SA1", SE1->E1_FILORIG)+F71->F71_CODCLI+F71->F71_LOJCLI))
				
				If !lHeadMod2
					lHeadMod2 := AbrePar(@cArqGerado, .T.)
					
					If !lHeadMod2
						Exit	
					Endif
				Endif
				
				If !lCancPix
					nTxMoeda  := SE1->E1_TXMOEDA
					nRecnoSE1 := SE1->(Recno()) 
					
					If __lBordImp .And. !lMVCNABIMP
						lImposCalc := BorderoImp(SE1->E1_FILORIG, SE1->E1_NUMBOR, "R", SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA)
					EndIf					
					
					If SE1->E1_MOEDA > 1 .And. (Empty(nTxMoeda) .Or. !Empty(SE1->E1_DTVARIA))
						nTxMoeda := RecMoeda(Iif(Empty(SE1->E1_DTVARIA), dDataBase, SE1->E1_DTVARIA), SE1->E1_MOEDA)
					EndIf
					
					If __lBaImpPix
						nBaseImpos := BaseImpPix(nRecnoSE1, @nVASoma, @nVASubtra, @nAbatImpos, nTxMoeda, @nOutrosAba)
					EndIf
					
					If __lPIXImp .And. !lImposCalc
						If !PIXGerImp(nBaseImpos, nTxMoeda)
							Loop
						EndIf
					EndIf					
					
					If __lFinPix
						nVlrPix := ExecBlock("FINVLPIX")
					Else
						nVlrPix := SE1->E1_SALDO
						
						If lConsACDC .And. SE1->(E1_SDACRES+E1_SDDECRE) > 0
							nVlrPix += (SE1->E1_SDACRES - SE1->E1_SDDECRE)
						EndIf
						
						If lConsVA .And. ((nVASoma > 0) .Or. (nVASubtra != 0 ))							
							nVlrPix   += Round((nVASoma - Abs(nVASubtra)), 2)
						EndIf
						
						If lConsImp .And. (nAbatImpos+nOutrosAba) > 0
							If SE1->E1_MOEDA > 1
								If nAbatImpos > 0
									nAbatImpos := xMoeda(nAbatImpos, 1, SE1->E1_MOEDA, dDataBase, __nCasasDc, 0, nTxMoeda)
								EndIf
								
								If nOutrosAba > 0
									nOutrosAba := xMoeda(nOutrosAba, 1, SE1->E1_MOEDA, dDataBase, __nCasasDc, 0, nTxMoeda)
								EndIf
							EndIf
							
							nVlrPix -= (Round(nAbatImpos, 2) + Round(nOutrosAba, 2))
						EndIf					
					EndIf
					
					If nVlrPix < (nVASoma + SE1->E1_SDACRES)
						If !Empty(cTitulos) 
							cTitulos += CRLF
						EndIf
						
						cTitulos += SE1->E1_PREFIXO+"-"+SE1->E1_NUM+"-"+SE1->E1_PARCELA+"-"+SE1->E1_TIPO
						Loop
					EndIf
					
					If nVlrPix > 0
						Reclock("F71")
						F71->F71_VLRPIX := nVlrPix      
						F71->(MsUnlock())
					EndIf
				EndIf
				
				nQtdTitLote ++
				nQtdTotTit  ++
				nSomaValor	+= F71->F71_VLRPIX
				nSomaVlLote += F71->F71_VLRPIX
				nSomaAcres  += SE1->E1_SDACRES
				nSomaDecre  += SE1->E1_SDDECRE			
				lHaTitulo   := .T.
				lAtualiza   := .T.
				
				//Le Arquivo de Parametrizacao
				nLidos := 0
				FSEEK(nHdlBco, 0, 0)
				nTamArq := FSEEK(nHdlBco, 0, 2)
				FSEEK(nHdlBco, 0, 0)
				lIdCnab := .T.
				
				While nLidos <= nTamArq
					xBuffer := Space(85)
					FREAD(nHdlBco, @xBuffer, 85)
					
					Do Case
						Case SubStr(xBuffer,1,1) == CHR(1)
							IF lHeader
								nLidos += 85
								Loop
							EndIF
						Case SubStr(xBuffer,1,1) == CHR(2)
							lFirst2 := .F. //Controle do detalhe tipo 5
							IF !lFirst
								lFirst := .T.
								nSeq++
								F150Write(nHdlSaida,CHR(13)+CHR(10))
							EndIF
						Case SubStr(xBuffer,1,1) == CHR(4)
							IF !lFirst2
								nSeq++
								lFirst2 := .T.
								F150Write(nHdlSaida,CHR(13)+CHR(10))
							Endif
						Case SubStr(xBuffer,1,1) == CHR(3)
							nLidos+=85
							Loop
						Otherwise
							nLidos+=85
							Loop
					EndCase
					
					nTam      := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
					nDec      := Val(SubStr(xBuffer,23,1))
					cConteudo := SubStr(xBuffer,24,60)
					nGrava    := fA150GrPIX(nTam, nDec, cConteudo, Nil, lFinCnab2, @lIdCnab)
					
					If nGrava != 1
						nSeq--
						Exit
					Endif
					
					nLidos += 85
				EndDO
				
				If nGrava == 3
					Exit
				Endif
				
				If nGrava == 1
					lAtuDsk := .T.
					
					If MV_PAR09 == 1
						lIdCnab := .T.	// Para obter novo identificador do registro CNAB na rotina 
						
						F150Write(nHdlSaida,CHR(13)+CHR(10))

						IF !lHeader
							lHeader := .T.
						EndIF
					Endif
					
					F71->(DbSetOrder(3))
					If F71->(MsSeek(cChaveF71))
						Reclock("F71",.F.)
						F71->F71_CODBAN := aBanSel[1]
						F71->F71_AGENCI := aBanSel[2]
						F71->F71_NUMCON := aBanSel[3]
						F71->F71_FILBCO := aBanSel[8]  
						F71->F71_TPCHV  := aBanSel[9]  
						F71->F71_CHVPIX := aBanSel[4]
						
						If aTitSel[nI,13] == "1"
							F71->F71_STATUS := "6"
						Else
							F71->F71_STATUS := "2"
						Endif
						
						F71->F71_DTPSP  := ddatabase
						F71->F71_HRPSP  := TIME()            
						F71->(MsUnlock())
					Endif
					
					//Atualiza para Carteira PIX
                    SE1->(DbGoto(nRecnoSE1))
                    
					If SE1->E1_SITUACA == "0" 
						cSituaCob := IIf(__lSitCPix, F022SITPIX(), "")
						cSituaCob := IIf(Empty(cSituaCob), SE1->E1_SITUACA, cSituaCob)					
						
						Reclock("SE1", .F.)
						SE1->E1_SITUACA := cSituaCob
						SE1->(MsUnlock())
					EndIf
					
					If nI < nTitulos
						nSeq++
					EndIf
					
					//Contabilização PIX
					F150CtbPix()
				ElseIf nGrava == 3
					Exit
				Endif
			Next
			
			If Empty(cFilFwSE1 )
				Exit
			Endif
			
			dbSelectArea("SM0")
			SM0->(DbSkip())
		EndDO
		
		SM0->(dbgoto(nRegEmp))
		cFilAnt := FWGETCODFILIAL
		
		If lHaTitulo .And. lHeadMod2 //Se há títulos e conseguiu criar o Header do arquivo, entao cria o Trailler
			If nTotal > 0 //Contabilização
				F150CtbInc(cArquivo, @nHdlPrv, cLote, nTotal, Nil, Nil)
			Endif			
			
			If mv_par09 == 1
				//Monta Registro Trailler
				nSeq   ++
				nLidos := 0
				FSEEK(nHdlBco, 0, 0)
				nTamArq := FSEEK(nHdlBco, 0, 2)
				FSEEK(nHdlBco, 0, 0)
				
				While nLidos <= nTamArq
					xBuffer := Space(85)
					FREAD(nHdlBco, @xBuffer, 85)
					
					If SubStr(xBuffer,1,1) == CHR(3)
						lTrailler := .T.
						nTam      := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
						nDec      := Val(SubStr(xBuffer,23,1))
						cConteudo := SubStr(xBuffer,24,60)
						nGrava    := fA150GrPIX(nTam, nDec, cConteudo, .T., lFinCnab2, .F.)
					Endif
					
					nLidos+=85
				EndDo
				
				If lTrailler .And. lFimLin
					F150Write(nHdlSaida,CHR(13)+CHR(10))
				Endif
			Else
				nTotLinArq += nQtdLinLote //Total das linhas do arquivo.
				RodaCnab2(nHdlSaida, MV_PAR03, lFimLin)
			EndIf
			
			//Atualiza Numero do ultimo Disco
			DbSelectArea("SEE")
			IF SEE->(!Eof()) .And. nGrava != 3 .and. lAtuDsk
				Reclock("SEE")
				nUltDisco := (VAL(EE_ULTDSK) + 1)
				SEE->EE_ULTDSK := StrZero(nUltDisco, TamSx3("EE_ULTDSK")[1])
				SEE->(MsUnlock())
			EndIF
			
			//Fecha o arquivos utilizados
			FCLOSE(nHdlBco)
			If len(cBuffWrite) > 0 
   				fwrite(nHdlSaida,cBuffWrite, Len(cBuffWrite))
   				cBuffWrite := ''
			EndIF
			FCLOSE(nHdlSaida)

			If nGrava == 3 // Abandonou a rotina, quando o bordero ja foi enviado.
				// Apaga o arquivo de saida, para nao caracterizar um erro no programa a geracao incompleta do arquivo quando o usuario cancelar.
				If FErase(cArqGerado) = 0
					If !Empty(cArqBkp)
						nStatBkp := FRenameEx( cArqBkp , cNomeSai  )
						If nStatBkp <> 0
							Help(" ",1,"F150ERRREST",,Str(fError(),4),1,0)
						EndIf
					EndIf
				EndIf
				ProcLogAtu("ERRO","",STR0019) //"Processo Cancelado por usuário. Arquivo não gerado"
			Else
				ProcLogAtu("ALERTA","",STR0020+cArqGerado) //"Processo Finalizado. Arquivo gerado: "
			Endif
		Endif
	END TRANSACTION 
	
	If lHaTitulo .And. nGrava == 1
		cMensagem  := STR0036 + cArqGerado + STR0037
		cTituloMsg := STR0043 
	EndIf
	
	If !Empty(cTitulos)
		Help(Nil, Nil, "VLRENVIO", Nil, STR0039 + CRLF + cTitulos + CRLF + STR0040, 2, 0, Nil, Nil, Nil, Nil, Nil, {STR0041})
		
		If !lHaTitulo
			If !Empty(nHdlBco)
				FClose(nHdlBco)
			EndIf
			
			If !Empty(nHdlSaida)
				FClose(nHdlSaida)
			EndIf
		EndIf	
	EndIf
	
	If !__lIsBlind
		MsgAlert(cMensagem, cTituloMsg)
	EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fA150GrPIX³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de Geracao do Arquivo de Remessa de Comunicacao      ³±±
±±³          ³Bancaria                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1:=fa150Grava(ExpN1,ExpN2,ExpC1)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA150                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function fA150GrPIX( nTam,nDec,cConteudo,lTrailler,lFinCnab2,lIdCnab)
	Local nRetorno := 1
	Local aGetArea := GetArea()
	Local lPanelFin := IsPanelFin()
	
	//Para imprimir o trailler caso se deseje abandonar a gera‡Æo do arquivo de envio pela metade
	lTrailler := Iif(lTrailler == Nil, .F., lTrailler)
	lFinCnab2 := Iif(lFinCnab2 == Nil, .F., lFinCnab2)
	
	//O retorno poderá ser: 1->Grava Ok, 2->Ignora bordero, 3->Abandona rotina
	//Verifica se titulo ja' foi enviado
	If nRetorno == 1 .Or. (lTrailler .And. nBorderos > 0)
		If !lTrailler .and. lIdCnab			
			lIdCnab := .F. // Gera o identificacao do registro CNAB apenas uma vez no titulo enviado
		Endif
		
		//Analisa conteudo
		IF Empty(cConteudo)
			cCampo := Space(nTam)
		Else
			lConteudo := fa150Orig( cConteudo )
			
			If !lConteudo
				RestArea(aGetArea)
				Return nRetorno
			Else
				If ValType(xConteudo) == "D"
					cCampo := GravaData(xConteudo,.F.)
				ElseIf ValType(xConteudo) == "N"
					cCampo := Substr(Strzero(xConteudo, nTam, nDec), 1, nTam)
				Else
					cCampo := Substr(xConteudo, 1, nTam)
				EndIf
			EndIf
		EndIf
		
		If Len(cCampo) < nTam  //Preenche campo a ser gravado, caso menor
			cCampo := cCampo + Space(nTam - Len(cCampo))
		EndIf
		
		F150Write( nHdlSaida,cCampo,nTam )
	EndIf
	
	RestArea(aGetArea)
	
	If lPanelFin
		cAlias := FinWindow:cAliasFile
		dbSelectarea(cAlias)
		FinVisual(cAlias,FinWindow,(cAlias)->(Recno()),.T.)
	Endif
Return nRetorno

/*/{Protheus.doc} F150CtbPix()
Efetua a contabilização dos títulos gerados para PIX
Necessário ter a SE1 e F71 posicionados

@version    12.1.23/12.1.25/12.1.27
@author     Edson Melo
@return     lRet, Logical, .T. Cancela retenção do título, .F. Não cancela retenção do título por estar em PIX
@since      13/11/2020
/*/
Function F150CtbPix()
	Local cPadrao   As String
	Local lPadrao   As Logical
	Local cCartAtu  As String
	Local cCartAnt  As String
	Local cBancoAnt As String
	Local cAgencAnt As String
	Local cContaAnt As String
	
	If !lCancPix
		cPadrao  := "54G" //Carteira para PIX
	Else
		cPadrao  := "54H" //PIX para Carteira
	EndIf
	
	lPadrao  := VerPadrao(cPadrao)
	
	If !lCancPix
		cCartAtu  := "K"
		cCartAnt  := SE1->E1_SITUACA
		cBancoAnt := SE1->E1_PORTADOI
		cAgencAnt := SE1->E1_AGEDEP
		cContaAnt := SE1->E1_CONTA
	Else
		//Verifica se o título está em borderô
		cCartAtu  := SE1->E1_SITUACA
		cCartAnt  := "K"
		cBancoAnt := F71->F71_CODBAN
		cAgencAnt := F71->F71_AGENCI
		cContaAnt := F71->F71_NUMCON
	EndIf
	
	//[01] = FWI_LA ('S' ou 'N')
	//[02] = FWI_LANPAD (Lançamento Padrão utilizado)
	//[03] = FWI_VALOR (Valor da Movimentação)
	//[04] = FWI_DESCON (Desconto da Movimentação)
	//[05] = FWI_IOF (Valor do IOF)
	//[06] = FWI_SITUAC (Carteira Atual)
	//[07] = FWI_SITANT (Carteira Anterior)
	//[08] = FWI_BCOANT (Portador Anterior)
	//[09] = FWI_AGEANT (Agência Anterior)
	//[10] = FWI_CONANT (Número da Conta Anterior)
	//[11] = FWI_CONTRA (Contrato)
	//[12] = FWI_IDMOV (Id da Movimentação na FK5)
	//[13] = FWI_NUMBOR (Número do Borderô)
	
	FinAGrvFWI({"N", cPadrao, F71->F71_VLRPIX, 0, 0, cCartAtu, cCartAnt, cBancoAnt, cAgencAnt, cContaAnt, "", "", ""}, {.T.,lCancPix})
	
	aAdd(aFlagCTB, {"FWI_LA", "S", "FWI", FWI->(Recno()), 0, 0, 0})
	
	If lPadrao .and. lCtbPixOn
		If !lCabec
			cLote   := LoteCont("FIN")
			nHdlPrv := HeadProva(cLote, "FINA150", __cUserId, @cArquivo )
			lCabec := .T.
		EndIf
		
		If lCabec		
			nTotal += DetProva(nHdlPrv, cPadrao, "FINA150" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/,;
							/*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, /*@aFlagCTB*/, /*aTabRecOri*/, /*aDadosProva*/)
		EndIf
	EndIf
Return

/*/{Protheus.doc} F150CtbInc()
Efetua a contabilização dos títulos gerados para PIX

@version    12.1.23/12.1.25/12.1.27
@author     Edson Melo
@return     lRet, Logical, .T. Cancela retenção do título, .F. Não cancela retenção do título por estar em PIX
@since      13/11/2020
/*/

Static Function F150CtbInc(cArquivo,nHdlPrv,cLoteATF,nTotal,aDadosProva,aDiario)

Default aDadosProva := nil
Default aDiario	    := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava Rodapé 									  	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nHdlPrv > 0
	RodaProva( nHdlPrv , nTotal, aDadosProva )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Envia para Lan‡amento Cont bil 						³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	cA100Incl( cArquivo, nHdlPrv, 3, cLoteATF, lMostraCtb, lAglutCtb,,,, @aFlagCTB, aDadosProva,aDiario )
	INCLUI := .F. //Não tirar - Impede a abertura do wizard FINA891 após o processamento do FA150PIX

	aFlagCTB := {}  
	aDiario  := {}
	nHdlPrv := 0
Endif

Return Nil

//----------------------------------------
/*/{Protheus.doc} UltimaRem
	Grava e retorna a última sequência do
	arquivo de remessa gerado pelo modelo
	Pix.
	
	@author Sivaldo Oliveira
	@since 16/08/2021
	@version P12
	
	Return cUltimaRem, Char, última sequência 
	de remessa gerada.
	/*/
//----------------------------------------
Function UltimaRem() As Char
	Local lTemCampo  As Logical
	Local cUltimaRem As Char	
	Local nUltimaRem As Numeric
	Local nTamCampo  As Numeric
	Local aAreaAtual As Array
	
	//Inicializa variáveis.
	aAreaAtual := GetArea()
	lTemCampo  := SA6->(FieldPos("A6_ULTREM")) > 0 
	cUltimaRem := ""	
	nUltimaRem := 1
	nTamCampo  := 10
	
	If lTemCampo
		DbSelectArea("SA6")
		SA6->(DbSetOrder(1))
		nTamCampo  := TamSx3("A6_ULTREM")[1]
		nUltimaRem := (1 + Val(SA6->A6_ULTREM))
		cUltimaRem := StrZero(nUltimaRem, nTamCampo)
		
		If !Empty(SA6->A6_COD)
			RecLock("SA6")
			SA6->A6_ULTREM := cUltimaRem 
			SA6->(MsUnlock())
		EndIf
	Else
		cUltimaRem := StrZero(nUltimaRem, nTamCampo) 	
	EndIf
	
	RestArea(aAreaAtual)
	FwFreeArray(aAreaAtual)
Return cUltimaRem

//----------------------------------------
/*/{Protheus.doc} TotalVA
	Retorna o total de valores acessórios do 
	do título.
	
	@author Sivaldo Oliveira
	@since 26/08/2021
	@version P12
	
	@Param cOperador, Char, indica qual totalizador
	do valor acessório será considerado.
	
	@Param cCarteira, Char, Indica qual a carteira do
	título(P = Pagar, R = Receber).
	
	Return nTotalVa, Numeric, Total do(s) valor(es) acessório(s). 
	/*/
//----------------------------------------
Function TotalVA(cOperador As Char, cCarteira As Char) As Numeric
	Local nTotalVa   As Numeric
	Local Quantidade As Numeric
	Local nContador  As Numeric	
	Local aValores   As Array
	
	//Parâmetros padrões da rotina
	Default cOperador := ""
	Default cCarteira := ""
	
	//Inicializa variáveis	
	nTotalVa   := 0
	Quantidade := 0
	nContador  := 0
	aValores   := {}
	cCarteira  := AllTrim(cCarteira)
	
	If cCarteira $ "R|P"
		cOperador := AllTrim(cOperador)
		
		If cCarteira == "R"
			nTotalVa := FValAcess(SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ,; 
			.F., "", "R", dDataBase, aValores, SE1->E1_MOEDA, SE1->E1_MOEDA, 0, "", .F.)
		Else
			nTotalVa := FValAcess(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ,;
			.F., "", "P", dDataBase, aValores, SE2->E2_MOEDA, SE2->E2_MOEDA, 0, "", .F.)
		EndIf
		
		If (Quantidade := Len(aValores)) > 0
			nSomaValor  := IIf(Type("nSomaValor") == "N", nSomaValor,  0)
			nSomaVlLote := IIf(Type("nSomaVlLote") == "N", nSomaVlLote, 0)
			lAtualiza   := IIf(Type("lAtualiza") == "L", lAtualiza,  .T.)		
			
			If cOperador $ "-|+"
				nTotalVa := 0
				
				For nContador := 1 To Quantidade
					If (cOperador == "+" .And. aValores[nContador,3] <= 0) .Or. (cOperador == "-" .And. aValores[nContador,3] > 0)
						Loop
					EndIf
					
					nTotalVa += aValores[nContador,3]
				Next
			EndIf
			
			If lAtualiza
				nSomaValor  += nTotalVa
				nSomaVlLote += nTotalVa
				lAtualiza   := .F.
			EndIf
			
			FwFreeArray(aValores)		
		EndIf
	EndIf
Return nTotalVa

//----------------------------------------
/*/{Protheus.doc} F150Write
	Função para controle do buffer, em casos onde
	usa o broker e os arquivos são muito grandes o fwrite fica lento.
	
	@author Jailton Urbano
	@since 25/07/2023
	@version P12
	
	Return não há
	/*/
//----------------------------------------
Function F150Write(nH , cBuff, nTam, lDetalhe, cBuffLinha As Character)
	Local cValorBuff As Character
	
	//Parâmetros de entrada
	Default cBuff      := ""
	Default nTam  	   := len(cBuff)
	Default nH         := 0
	Default lDetalhe   := .F.
	Default cBuffLinha := ""
	
	//Inicializa variáveis.
	cValorBuff := ""
	
	If __cCHR1310 == Nil 
		__cCHR1310 := CHR(13)+CHR(10)
	EndIf
	
	If mv_par09 == 1 .And. __lF150GRV .And. lDetalhe		
		// Ponto de Entrada Permite gravar linhas adicionais apos confirmar a gravacao da linha de
		// detalhe tipo "1", atendendo assim a IN09 da ANS (ABR/09) que dispoem sobre
		// a informacao dos dados dos beneficiarios (dependentes) no boleto bancario
		
		fWrite(nH, + cBuffWrite + CHR(13) + CHR(10))
		cBuffWrite := ''
		ExecBlock("F150GRV", .F., .F., { nH } )
	Else
		If Valtype(cBuffWrite) == "U"
			Private cBuffWrite := ""
		EndIf
		
		cValorBuff := Substr(cBuff,1,nTam)
		cBuffWrite += cValorBuff

		If len(cBuffWrite) > 64000
			fwrite(nH , cBuffWrite)
			cBuffWrite := ''
		Endif
		
		If cValorBuff != __cCHR1310
			cBuffLinha += cValorBuff
		EndIf
	EndIf

return

/*/{Protheus.doc}
	@function CodBarE1
	@description Gera o Código de Barras
	@type function
	@autor: Alecsandre Ap. F. S. Ferreira
	@param cLinCnab, character, conteúdo da linha do arquivo Cnab
	@param nPosNNum, numeric, posição inicial do nosso número
	@param nTamNNum, numeric, tamanho do nosso número
	@param nPosVcto, numeric, posição inicial do vencimento
	@param nTamVcto, numeric, tamanho do vencimento
	@param nPosSaldo, numeric, posição inicial do saldo do título
	@param nTamSld, numeric, tamanho do saldo do título
	@param cCodBco, character, código do banco
	@since 27/11/2023
/*/
Static Function CodBarE1(cLinCnab As Character, nPosNNum As Numeric, nTamNNum As Numeric, nPosVcto As Numeric,;
		nTamVcto As Numeric, nPosSaldo As Numeric, nTamSld As Numeric, cCodBco As Character)

	Local cCodBar     As Character
	Local cCodDig     As Character
	Local cDvMd10A3   As Character
	Local cDvMd10A4   As Character
	Local cDvMod11    As Character
	Local cHashMod11  As Character
	Local cAgenciaE1  As Character
 	Local cContaE1    As Character
	Local cContaDv    As Character
	Local cCarteiraE1 As Character
	Local cNosNum     As Character
	Local cVecto      As Character
	Local cVectoAux   As Character
	Local cSaldo      As Character
	Local nNrBytes    As Numeric
	Local lVldCodBar  As Logical
	Local nNewFator   As Numeric

	Default cLinCnab  := ""
	Default cCodBco   := ""
	Default nPosNNum  := 63
	Default nTamNNum  := 8
	Default nPosVcto  := 121
	Default nTamVcto  := 6
	Default nPosSaldo := 127
	Default nTamSld   := 13

	cCodBar     := ""
	cCodDig     := ""
	cContaDv    := ""
	cDvMd10A3   := ""
	cDvMd10A4   := ""
	cDvMod11    := ""
	cHashMod11  := ""
	cNosNum     := ""
	cVecto      := ""
	cVectoAux   := ""
	cSaldo      := ""
	cAgenciaE1  := Alltrim(SEE->EE_AGENCIA)
	cContaE1    := Alltrim(SEE->EE_CONTA)
	cCarteiraE1 := Alltrim(SEE->EE_CODCART)
	nNrBytes    := SEE->EE_NRBYTES
	lVldCodBar  := .T.
	nNewFator   := 0

	If !Empty(SEE->EE_AGEOFI) .AND. !Empty(SEE->EE_CTAOFI)
		cAgenciaE1 := Alltrim(SEE->EE_AGEOFI)
		cContaE1 := Alltrim(SEE->EE_CTAOFI)
	Endif

	If cCodBco == '341' // Itaú

		If nNrBytes == 240
			nPosNNum  := 41
			nTamNNum  := 8
			nPosVcto  := 78
			nTamVcto  := 8
			nPosSaldo := 86
			nTamSld   := 15
		EndIf
		// Pega Linha da ultima quebra de linha
		cNosNum := Substr(cLinCnab, nPosNNum, nTamNNum)
		If !Empty(cNosNum)
			cVectoAux := Substr(cLinCnab, nPosVcto, nTamVcto) // ddmmaa
			cVecto := dtos(ctod(Left(cVectoAux, 2) + "/" + Substr(cVectoAux, 3, 2) + "/" + Right(cVectoAux, 2))) // aaaammdd
			cSaldo := StrTran(Substr(cLinCnab, nPosSaldo, nTamSld), '.', '')
		Endif

		If !Empty(cAgenciaE1) .and. !Empty(cContaE1) .and. !Empty(cCarteiraE1) .and. !Empty(cNosNum)
			// Adequando Tamanhos de Campo do Layout
			cAgenciaE1  := Left(Replicate("0", 4 - Len(cAgenciaE1)) + cAgenciaE1, 4)
			cContaE1    := Left(Replicate("0", 5 - Len(cContaE1)) + cContaE1, 5)
			cContaDv    := Mod10(cAgenciaE1+cContaE1) // SA6->A6_DVCTA
			cCarteiraE1 := Left(Replicate("0", 3 - Len(cCarteiraE1)) + cCarteiraE1, 3)
			cNosNum     := Right(cNosNum, 8)
			cCodBco     := Left(Replicate("0", 3 - Len(cCodBco)) + cCodBco, 3)
			cDvMd10A4   := GerMod10(cAgenciaE1, cContaE1, cCarteiraE1, cNosNum)		// DAC Modulo 10 Anexo 4 31 a 31 01 9(01)

			// Bloco 1
			cHashMod11 += cCodBco													// Banco 					   01 a 03 03 9(03)
			cHashMod11 += "9"														// Moeda 					   04 a 04 01 9(01)      

			If cVecto >= "20250222" // A partir de 22/02/2025, o fator retorna para "1000" adicionando "1" a cada dia subsequente a este fator
				nNewFator := 9000
			EndIf
			// Bloco 2
			cHashMod11 += StrZero(SToD(cVecto) - CToD("07/10/97") - nNewFator, 4)	// Fator Vencimento 		   06 a 09 04 9(04)
			cHashMod11 += StrZero(Val(cSaldo), 10)									// Valor 					   10 a 19 10 9(08)V9(2)
			cHashMod11 += cCarteiraE1												// Carteira 				   20 a 22 03 9(03)
			cHashMod11 += cNosNum													// Nosso Número 			   23 a 30 08 9(08)
			cHashMod11 += cDvMd10A4 												// DAC Ag/Con/Cart/NosNum An 4 31 a 31 01 9(01)
			cHashMod11 += cAgenciaE1 												// Agência              	   32 a 35 04 9(04)
			cHashMod11 += cContaE1													// Conta                	   36 a 40 05 9(05)
			cHashMod11 += cContaDv 													// DAC Modulo 10 A3			   41 a 41 01 9(01)
			cHashMod11 += '000' 													// Fixo 3 0s				   42 a 44 03 9(03)

			cDvMod11 := Mod11(cHashMod11)											// DAC Modulo 11
			// Inserção Mod11 na 5ª Posição
			cCodBar := Left(cHashMod11, 4) + cDvMod11 + Right(cHashMod11, 39)

			If __lF150CBR
				cCodBar := ExecBlock("FA150CBR", .F., .F., cCodBar)
			Endif

			lVldCodBar := VldCodBar(cCodBar, .F., .F.)
			If !lVldCodBar
				lErroCBar := .T.
			EndIf

			If !Empty(cCodBar) .AND. lVldCodBar
				cCodDig := FinCBLD(cCodBar)
			Endif

			If !Empty(cCodBar) .AND. !Empty(cCodDig)
				Reclock("SE1", .F.)
					SE1->E1_CODBAR := cCodBar
					SE1->E1_CODDIG := cCodDig
				SE1->(MsUnlock())
			Endif
		Endif
	Endif
Return

/*/{Protheus.doc}
	@function GerMod10
	@description Calcular do Digito verificador para o nosso número do Banco Itau, Anexo 3
	@type function
	@autor: Alecsandre Ap. F. S. Ferreira
	@since 27/11/2023
	@return character, Digito Verificador
/*/
Static Function GerMod10(cAgenciaE1 As Character, cContaE1 As Character, cCarteiraE1 As Character, cNosNum As Character) As Character
	Local cDVMod10 As Character

	Default cAgenciaE1 := ""
	Default cContaE1 := ""
	Default cCarteiraE1 := ""
	Default cNosNum := ""

	cDvMod10 := ""

	If ((cCarteiraE1 $ '126|131|146|150|168') .And. !Empty(cCarteiraE1) .And. !Empty(cNosNum))
		cDVMod10 := Mod10(Alltrim(cCarteiraE1) + Alltrim(cNosNum))
	ElseIf (!Empty(cAgenciaE1) .And. !Empty(cContaE1) .And. !Empty(cCarteiraE1) .And. !Empty(cNosNum))
		cDVMod10 := Mod10(cAgenciaE1 + cContaE1 + cCarteiraE1 + cNosNum)
	EndIf
Return cDVMod10

/*/{Protheus.doc} 
	@function Mod10
	@description Calculo para expressão no Mod10 Itau
	@type function
	@author Alecsandre Ap. F. S. Ferreira
	@since 27/11/2023
	@return character, Digito Verificador
/*/
Static Function Mod10(cHashMod10 as Character) As Character
	Local nFor As Numeric
	Local nTot As Numeric
	Local nAux As Numeric
	Local cAux As Character

	Default cHashMod10 := ""

	nTot := 0
	nAux := 0
	cAux := "0"

	For nFor := 1 To Len(cHashMod10)
		If (nFor % 2 = 1)
			nAux := 2
		Else
			nAux := 1
		Endif
		cAux := StrZero(nAux * Val(Left(Right(cHashMod10, nFor), 1)), 2)
		nTot += Val(Left(cAux, 1)) + Val(Right(cAux, 1)) // Caso maior que 9, somar 1 algarimos com o outro
	Next nFor

	nTot := nTot % 10
	nTot := If(nTot == 0, 0, 10 - nTot)
Return Str(nTot, 1)

/*/{Protheus.doc}
	@funciton Mod11
	@description Calculo para expressão no Mod11 Itau
	@type function
	@author Alecsandre Ap.s F. S. Ferreira
	@since 27/11/2023
	@return character, Digito Verificador
/*/
Static Function Mod11(cHashMod11 as Character) As Character
	Local nFor As Numeric
	Local nTot As Numeric
	Local nSeqCdBr As Numeric
	Local cAux As Character
	Local cDvMod11 As Character

	Default cHashMod11 := ""

	nTot := 0
	cAux := ""
	cDvMod11 := ""

	If Len(cHashMod11) == 43
		nSeqCdBr := 2
		For nFor := 1 To 43
			If nSeqCdBr > 9
				nSeqCdBr := 2
			Endif
			cAux := StrZero((nSeqCdBr * Val(Left(Right(cHashMod11, nFor), 1))), 2)
			nTot += Val(cAux)
			nSeqCdBr += 1
		Next

		nTot := nTot % 11
		nTot := If(nTot == 0 .Or. nTot == 1 .Or. nTot == 10 .Or. nTot == 11, 1, 11 - nTot)

		cDvMod11 := Str(nTot, 1)
	Endif
Return cDvMod11
