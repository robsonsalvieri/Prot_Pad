#Include "Protheus.ch"
#Include "GCTXDEF.CH"
#Include "CNTXFUN.CH"
#Include "FWMVCDEF.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"

#DEFINE TOTALTRAN 42 //Numero total de transacoes

//Constantes do Cabecalho
#DEFINE CONTRATO		01	//Indice do Codigo do Contrato
#DEFINE REVISAO			02	//Indice da Revisao
#DEFINE PLAN_MED		03	//Indice do codigo da Planilha ou da Medicao
#DEFINE FORNECEDOR		04	//Indice do codigo do Fornecedor
#DEFINE LOJAFOR			05	//Indice da loja do fornecedor
#DEFINE CLIENTE			06	//Indice do codigo do cliente
#DEFINE LOJACLI			07	//Indice da loja do cliente

//Constantes do Item
#DEFINE CONT_ITEM		01	//Indice do Codigo do Contrato
#DEFINE REV_ITEM		02	//Indice da Revisao
#DEFINE NUM_ITEM		03	//Indice do Codigo da Planilha ou do contrato
#DEFINE ITEM			04	//Indice do nro do Item
#DEFINE VL_TOTAL		05	//Indice do valor total do item

Static cScrAglu		:= ""
Static _aWhenMdls	:= Nil //Armazena WHEN dos campos de usuário de modelos p/ nao realizar multiplas chamadas ao FWSX3Util
Static _aHeadCNZ	:= Nil
Static _aWhenOrig	:= Nil //Armazena WHEN original(antes de modificações)
Static _aErroAlc 	:= Nil // Armazena o erro do modelo
Static _bTrueWhen	:= Nil
Static _lVldFrete	:= Nil

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtaAbatCauc?Autor ?Sergio Silveira      ?Data ?3/02/2006 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ?Abatimento de Caucao                                        ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ?CtaAbatCauc()                                               ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ?Generico                                                    ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?PROGRAMADOR  ?DATA   ?BOPS ? MOTIVO DA ALTERACAO                    ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?             ?       ?     ?                                        ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtaAbatCauc( nOper, aContrato, aRecGer, cPessoa, cLoja, cNFiscal, cSerie, dDEmissao, nValBrut )

Local aAbati     := {}
Local aStruct    := {}

Local cQuery     := ""
Local cAliasCN8  := ""
Local cAliasCNI  := ""
Local cTipo      := ""
Local cPrefixo   := ""
Local cNumero    := ""
Local cContrato  := ""
Local cRevisa    := ""
Local cNovoIt    := ""

Local nVlrEntrad := 0
Local nVlrGerad  := 0
Local nVlrAbati  := 0
Local nLoop      := 0
Local nValorEst  := 0
Local cEspCtr    := ""
Local cFilCTR	   := cFilAnt
Local lCntVlAbt  := ExistBlock("CNTVLABT")
Local uVlrAbati
Local cCauPRF		:= GetNewPar( "MV_CAUCPRF", "CPX" )

Default dDEmissao := dDataBase

cContrato 	:= aContrato[1]
cRevisa   	:= aContrato[2]
cFilCTR	:= IIF (Len(aContrato) >= 4, aContrato[4], cFilCTR)

dbSelectArea("CN9")
dbSetOrder(1)
If MsSeek(xFilial("CN9",cFilCTR)+cContrato+cRevisa)

	cEspCtr := Posicione("CN1",1,xFilial("CN1",cFilCTR)+CN9->CN9_TPCTO,"CN1_ESPCTR")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	//?Apura a soma do valor dos titulos gerados                     ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?

	For nLoop := 1 to Len( aRecGer )
		If cEspCtr == "1"
			SE2->( MsGoto( aRecGer[ nLoop ] ) )
			nVlrEntrad += SE2->E2_VALOR
		Else
			SE1->( MsGoto( aRecGer[ nLoop ] ) )
			nVlrEntrad += SE1->E1_VALOR
		EndIf
	Next nLoop

	If nOper == 1

		aAbati := CtaTpCauc(cFilCTR)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		//³Verifica as caucoes de abatimento do contrato deste fornecedor ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?

		cAliasCN8 := GetNextAlias()

		aStruct := CN8->( dbStruct() )

		cQuery  := ""
		cQuery  += "SELECT CN8.*,R_E_C_N_O_ RECNO FROM "
		cQuery  += RetSqlName( "CN8" ) + " CN8 "
		cQuery  += "WHERE "
		cQuery  += "CN8_FILIAL='" + xFilial( "CN8",cFilCTR) + "' AND "
		cQuery  += "CN8_CONTRA='" + cContrato + "' AND "
		cQuery  += "CN8_REVISA='" + cRevisa   + "' AND "
		If cEspCtr == "1"
			cQuery  += "CN8_FORNEC='" + cPessoa   + "' AND "
			cQuery  += "CN8_LOJA='"   + cLoja     + "' AND "
		Else
			cQuery  += "CN8_CLIENT='" + cPessoa   + "' AND "
			cQuery  += "CN8_LOJACL='" + cLoja     + "' AND "
		EndIf
		cQuery  += "CN8_VLRRET > 0 AND "
		cQuery  += "D_E_L_E_T_ = ' ' "

		cQuery  := ChangeQuery( cQuery )

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery), cAliasCN8,.T.,.T.)

		For nLoop := 1 To Len( aStruct )
			If aStruct[ nLoop, 2 ] <> "C" .And. !Empty( ( cAliasCN8 )->( FieldPos( aStruct[ nLoop, 1 ] ) ) )
				TcSetField( cAliasCN8, aStruct[ nLoop, 1 ],aStruct[ nLoop, 2 ],aStruct[ nLoop, 3 ],aStruct[ nLoop, 4 ] )
			EndIf
		Next nLoop

		While !( cAliasCN8 )->( Eof() ) .And. nVlrEntrad > nVlrGerad

			If !Empty( aScan(aAbati, ( cAliasCN8 )->CN8_TPCAUC ) )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
				//³Calcula o valor a ser abatido?
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
				nVlrAbati := (if(AllTrim( ( cAliasCN8 )->CN8_TPABAT ) == "1", ( cAliasCN8 )->CN8_VLEFET, nVlrEntrad) * ( cAliasCN8 )->CN8_PERCAB) / 100
				if nVlrAbati >  ( cAliasCN8 )->CN8_VLRRET
					nVlrAbati := ( cAliasCN8 )->CN8_VLRRET
				endif
				if (nVlrGerad + nVlrAbati) >= nVlrEntrad
					nVlrAbati := nVlrEntrad + nVlrGerad
				endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
				//?Ponto de Entrada para manipular o valor do abatimento ?
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
				If lCntVlAbt
					uVlrAbati := ExecBlock("CNTVLABT",.F.,.F.,{nVlrAbati,( cAliasCN8 )->RECNO})
					If Valtype(uVlrAbati) == "N"
						nVlrAbati := uVlrAbati
					EndIf
				EndIf

				CN8->( MsGoto( ( cAliasCN8 )->RECNO ) )
				Reclock( "CN8", .F.)
				CN8->CN8_VLRRET -= nVlrAbati
				MsUnlock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ??
				//?Localiza o titulo de antecipacao pertencente a caucao  ?
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ??
				If cEspCtr == "1"
					cTipo     := "PA "
					cPrefixo  := PadR( cCauPRF, Len( SE2->E2_PREFIXO ) )
					cNumero   := StrZero( Val( CN8->CN8_CODIGO ), Len( SE2->E2_NUM ) )

					cPessoa   := CN8->CN8_FORNEC
					cLoja     := CN8->CN8_LOJA

					dbSelectArea("SE2")
					SE2->( dbSetOrder( 1 ) )
					SE2->( MsSeek( xFilial("SE2",cFilCTR) + cPrefixo + cNumero + Space(Len(SE2->E2_PARCELA)) + cTipo + cPessoa + cLoja ) )
				Else
					cTipo     := "RA "
					cPrefixo  := PadR( cCauPRF, Len( SE1->E1_PREFIXO ) )
					cNumero   := StrZero( Val( CN8->CN8_CODIGO ), Len( SE1->E1_NUM ) )

					cPessoa   := CN8->CN8_CLIENT
					cLoja     := CN8->CN8_LOJACL

					dbSelectArea("SE1")
					SE1->( dbSetOrder( 1 ) )
					SE1->( MsSeek( xFilial("SE1",cFilCTR) + cPrefixo + cNumero + Space(Len(SE1->E1_PARCELA)) + cTipo + cPessoa + cLoja ) )
				EndIf

				If Found()

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Gerando baixas por compensacao dos titulos de entrada ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					CtaGerBaixa( nVlrAbati, aRecGer, Recno(), cEspCtr )

					nVlrGerad += nVlrAbati

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Cria o registro desta NF na tabela de notas fiscais da caucao ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Verifica o ultimo item criado                                 ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?

					cAliasCNI := GetNextAlias()

					cQuery  := ""
					cQuery  += "SELECT MAX( CNI_ITEM ) ITEMMAX FROM "
					cQuery  += RetSqlName( "CNI" ) + " CNI "
					cQuery  += "WHERE "
					cQuery  += "CNI_FILIAL='" + xFilial( "CN8" ,cFilCTR) + "' AND "
					cQuery  += "CNI_CODIGO='" + CN8->CN8_CODIGO  + "' AND "
					cQuery  += "D_E_L_E_T_ = ' ' "

					cQuery  := ChangeQuery( cQuery )

					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery), cAliasCNI,.T.,.T.)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Soma um ao item                                               ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					cNovoIt := SomaIt( ( cAliasCNI )->ITEMMAX )

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Fecha a area de trabalho da query                             ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					( cAliasCNI )->( dbCloseArea() )

					dbSelectArea( "CNI" )

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Inclui o registro                                             ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					RecLock( "CNI", .T. )
					CNI->CNI_FILIAL  := xFilial( "CNI" , cFilCTR)
					CNI->CNI_CODIGO  := CN8->CN8_CODIGO
					CNI->CNI_ITEM    := cNovoIt
					CNI->CNI_DATA    := dDEmissao
					CNI->CNI_NOTA    := cNFiscal
					CNI->CNI_SERIE   := cSerie
					CNI->CNI_VLRNF   := nValBrut
					CNI->CNI_VLRCAU  := nVlrAbati

					CNI->( MsUnlock() )

				EndIf

			EndIf

			( cAliasCN8 )->( dbSkip() )

		EndDo

		( cAliasCN8 )->( dbCloseArea() )
	ElseIf nOper == 2

		aAbati := CtaTpCauc(cFilCTR)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		//³Verifica as caucoes de abatimento do contrato?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?

		cAliasCN8 := GetNextAlias()

		aStruct := CN8->( dbStruct() )

		cQuery  := ""
		cQuery  += "SELECT CN8.*,R_E_C_N_O_ RECNO FROM "
		cQuery  += RetSqlName( "CN8" ) + " CN8 "
		cQuery  += "WHERE "
		cQuery  += "CN8_FILIAL='" + xFilial( "CN8" ,cFilCTR ) + "' AND "
		cQuery  += "CN8_CONTRA='" + cContrato + "' AND "
		cQuery  += "CN8_REVISA='" + cRevisa   + "' AND "
		If cEspCtr == "1"
			cQuery  += "CN8_FORNEC='" + cPessoa   + "' AND "
			cQuery  += "CN8_LOJA='"   + cLoja     + "' AND "
		Else
			cQuery  += "CN8_CLIENT='" + cPessoa   + "' AND "
			cQuery  += "CN8_LOJACL='" + cLoja     + "' AND "
		EndIf
		cQuery  += "D_E_L_E_T_ = ' ' "

		cQuery  := ChangeQuery( cQuery )

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery), cAliasCN8,.T.,.T.)

		For nLoop := 1 To Len( aStruct )
			If aStruct[ nLoop, 2 ] <> "C" .And. !Empty( ( cAliasCN8 )->( FieldPos( aStruct[ nLoop, 1 ] ) ) )
				TcSetField( cAliasCN8, aStruct[ nLoop, 1 ],aStruct[ nLoop, 2 ],aStruct[ nLoop, 3 ],aStruct[ nLoop, 4 ] )
			EndIf
		Next nLoop

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ??
		//³Percorre as caucoes dos contratos ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ??
		While !( cAliasCN8 )->( Eof() )

			If !Empty( aScan(aAbati, ( cAliasCN8 )->CN8_TPCAUC ) )


				If cEspCtr == "1"
					cTipo     := "PA "
					cPrefixo  := PadR( cCauPRF, Len( SE2->E2_PREFIXO ) )
					cNumero   := StrZero( Val( (cAliasCN8)->CN8_CODIGO ), Len( SE2->E2_NUM ) )

					cPessoa   := (cAliasCN8)->CN8_FORNEC
					cLoja     := (cAliasCN8)->CN8_LOJA

					dbSelectArea("SE2")
					SE2->( dbSetOrder( 1 ) )
					SE2->( MsSeek( xFilial("SE2") + cPrefixo + cNumero + Space(Len(SE2->E2_PARCELA)) + cTipo + cPessoa + cLoja ) )
				Else
					cTipo     := "RA "
					cPrefixo  := PadR( cCauPRF, Len( SE1->E1_PREFIXO ) )
					cNumero   := StrZero( Val( (cAliasCN8)->CN8_CODIGO ), Len( SE1->E1_NUM ) )

					cPessoa   := (cAliasCN8)->CN8_CLIENT
					cLoja     := (cAliasCN8)->CN8_LOJACL

					dbSelectArea("SE1")
					SE1->( dbSetOrder( 1 ) )
					SE1->( MsSeek( xFilial("SE1") + cPrefixo + cNumero + StrZero(1,Len(SE1->E1_PARCELA)) + cTipo + cPessoa + cLoja ) )
				EndIf

				If Found()
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Estorna as baixas por compensacao                     ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					nValorEst := 0
					CtaEstBaixa( aRecGer, Recno(), @nValorEst, cEspCtr )

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Incrementa o saldo a ser retido                       ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					CN8->( MsGoto( ( cAliasCN8 )->RECNO ) )
					Reclock( "CN8", .F.)
					CN8->CN8_VLRRET += nValorEst
					MsUnlock()

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Estorna a tabela de notas fiscais da caucao           ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					cAliasCNI := GetNextAlias()

					cQuery  := ""
					cQuery  += "SELECT R_E_C_N_O_ RECNO FROM "
					cQuery  += RetSqlName( "CNI" ) + " CNI "
					cQuery  += "WHERE "
					cQuery  += "CNI_FILIAL='" + xFilial( "CN8" ,cFilCTR ) + "' AND "
					cQuery  += "CNI_CODIGO='" + CN8->CN8_CODIGO  + "' AND "
					cQuery  += "CNI_NOTA='"   + Left(cNFiscal, TAMSX3("CNI_NOTA")[1]) + "' AND "
					cQuery  += "CNI_SERIE='"  + cSerie           + "' AND "
					cQuery  += "D_E_L_E_T_ = ' ' "

					cQuery  := ChangeQuery( cQuery )

					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery), cAliasCNI,.T.,.T.)

					While !( cAliasCNI )->( Eof() )

						CNI->( MsGoto( ( cAliasCNI )->RECNO ) )

						RecLock( "CNI", .F. )
						CNI->( dbDelete() )
						CNI->( MsUnlock() )

						( cAliasCNI )->( dbSkip() )

					EndDo

					( cAliasCNI )->( dbCloseArea() )

					dbSelectArea( "CNI" )

				EndIf

			EndIf

			( cAliasCN8 )->( dbSkip() )

		EndDo

		( cAliasCN8 )->( dbCloseArea() )

	EndIf
EndIf

Return(nil)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ?CtaTpCauc ?Autor ?Sergio Silveira      ?Data ?3/02/2006 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ?Gera Array com os tipos de caucao de abatimento             ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ?ExpA1 := CtaTpCauc()                                        ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ?ExpA1 := Tipos de caucao de abatimento                      ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ?Generico                                                    ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?PROGRAMADOR  ?DATA   ?BOPS ? MOTIVO DA ALTERACAO                    ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?             ?       ?     ?                                        ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function CtaTpCauc(cFilCTR)

Local aArea      := GetArea()
Local aTpCauc    := {}

Local cQuery     := ""
Local cAliasCN3  := ""

cAliasCN3 := GetNextAlias()

cQuery  := ""
cQuery  += "SELECT CN3_CODIGO FROM "
cQuery  += RetSqlName( "CN3" ) + " CN3 "
cQuery  += "WHERE "
cQuery  += "CN3_FILIAL='" + xFilial( "CN3" ,cFilCTR ) + "' AND "
cQuery  += "CN3_ABATI='1' AND "
cQuery  += "D_E_L_E_T_ = ' ' "

cQuery  := ChangeQuery( cQuery )

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery), cAliasCN3,.T.,.T.)

While !( cAliasCN3 )->( Eof() )
	aAdd(aTpCauc, ( cAliasCN3 )->CN3_CODIGO )
	( cAliasCN3 )->( dbSkip() )
EndDo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
//?Fecha a area de trabalho da query           ?
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
( cAliasCN3 )->( dbCloseArea() )

RestArea(aArea)
return(aTpCauc)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtaGerBaixa?Autor ?Sergio Silveira      ?Data ?3/02/2006 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ?Faz a baixa por compensacao dos titulos contrato x NFE      ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros?                                                            ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ?CtaExcProv( )                                               ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ?                                                            ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ?Generico                                                    ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?PROGRAMADOR  ?DATA   ?BOPS ? MOTIVO DA ALTERACAO                    ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?             ?       ?     ?                                        ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function CtaGerBaixa( nVlrBaixa, aRecGer, nRecno, cEspCtr )

Local aNDF       := { nRecno }
Local aNDFDados  := NIL
Local aValores   := {}
Private nTaxaD	 := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Altera o avalores para fazer a compensacao parcial do titulo?
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cEspCtr == "1"
	dbSelectArea( "SE2" )
	SE2->( MsGoto( nRecno ) )

	nTaxaD	     := SE2->E2_TXMOEDA
	aValores     := FaVlAtuCP("SE2",dDataBase)
	aValores[12] := nVlrBaixa
Else
	dbSelectArea( "SE1" )
	SE1->( MsGoto( nRecno ) )

	aValores     := FaVlAtuCR("SE1",dDataBase)
	aValores[12] := nVlrBaixa
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//?Marca para gravar o campo de baixa por caucao              ?
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len( aValores ) < 13
	ASize( aValores, 13 )
EndIf

aValores[13] := .T.

If cEspCtr == "1"
	aNDFDados := { { SE2->( Recno() ), NIL, aClone( aValores ) } }

	MaIntBxCP( 2, aRecGer, NIL, aNDF, NIL, NIL, NIL, NIL, aNDFDados, nVlrBaixa )
Else
	aNDFDados := { { SE1->( Recno() ), NIL, aClone( aValores ) } }

	MaIntBxCR( 3, aRecGer, NIL, aNDF, NIL, NIL, NIL, NIL, aNDFDados, NIL, nVlrBaixa )
EndIf

Return( Nil )


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtaEstBaixa?Autor ?Sergio Silveira      ?Data ?3/02/2006 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ?Estorna as baixas por compensacao dos titulos contrato x NFE³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros?                                                            ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ?CtaExcProv( )                                               ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ?                                                            ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ?Generico                                                    ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?PROGRAMADOR  ?DATA   ?BOPS ? MOTIVO DA ALTERACAO                    ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?             ?       ?     ?                                        ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function CtaEstBaixa( aRecGer, nRecnoPA, nValorEst, cEspCtr )

Local aEst       := {}
Local aEstorno   := {}
Local aStructSE5 := {}
Local nLoop      := 0
Local nPos       := 0

aEstorno  := {}

If cEspCtr == "1"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//?Obtem o array das baixas para estorno das mesmas           ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nLoop := 1 To Len( aRecGer )

		SE2->( MsGoto( aRecGer[ nLoop ] ) )

		cAliasQry := GetNextAlias()

		aStructSE5 := SE5->( dbStruct() )

		cQuery := ""
		cQuery += "SELECT E5_DOCUMEN,E5_VALOR FROM " + RetSqlName( "SE5" ) + " SE5 "
		cQuery += "WHERE "
		cQuery += "E5_PREFIXO='" + SE2->E2_PREFIXO + "' AND "
		cQuery += "E5_NUMERO='"  + SE2->E2_NUM     + "' AND "
		cQuery += "E5_PARCELA='" + SE2->E2_PARCELA + "' AND "
		cQuery += "E5_TIPO='"    + SE2->E2_TIPO    + "' AND "
		cQuery += "E5_CLIFOR='"  + SE2->E2_FORNECE + "' AND "
		cQuery += "E5_LOJA='"    + SE2->E2_LOJA    + "' AND "
		cQuery += "SUBSTRING(E5_HISTOR,1,12)<>'//CMP--CTR..' AND "
		cQuery += "D_E_L_E_T_=' '"

		cQuery := ChangeQuery( cQuery )

		dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQuery ), cAliasQry, .F., .T. )

		nPos := AScan( aStructSE5, { |x| Alltrim( x[1] ) == "E5_VALOR" } )
		TcSetField( cAliasQry, aStructSE5[nPos,1], aStructSE5[nPos,2], aStructSE5[nPos,3], aStructSE5[nPos,4] )

		While !( cAliasQry )->( Eof() )

			aEst := {}
			AAdd( aEst, ( cAliasQry )->E5_DOCUMEN )
			AAdd( aEstorno, AClone( aEst ) )

			nValorEst += ( cAliasQry )->E5_VALOR
			( cAliasQry )->( dbSkip() )

		EndDo

		( cAliasQry )->( dbCloseArea() )

	Next nLoop

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//?Efetua o estorno das baixas por compensacao                ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty( aEstorno )
		MaIntBxCP(2,aRecGer,,NIL,,{.F.,.F.,.F.,.F.,.F.,.F.},, aEstorno )
	EndIf
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//?Obtem o array das baixas para estorno das mesmas           ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nLoop := 1 To Len( aRecGer )

		SE1->( MsGoto( aRecGer[ nLoop ] ) )

		cAliasQry := GetNextAlias()

		aStructSE5 := SE5->( dbStruct() )

		cQuery := ""
		cQuery += "SELECT E5_DOCUMEN,E5_VALOR FROM " + RetSqlName( "SE5" ) + " SE5 "
		cQuery += "WHERE "
		cQuery += "E5_PREFIXO='" + SE1->E1_PREFIXO + "' AND "
		cQuery += "E5_NUMERO='"  + SE1->E1_NUM     + "' AND "
		cQuery += "E5_PARCELA='" + SE1->E1_PARCELA + "' AND "
		cQuery += "E5_TIPO='"    + SE1->E1_TIPO    + "' AND "
		cQuery += "E5_CLIFOR='"  + SE1->E1_CLIENTE + "' AND "
		cQuery += "E5_LOJA='"    + SE1->E1_LOJA    + "' AND "
		cQuery += "SUBSTRING(E5_HISTOR,1,12)='//CMP--CTR..' AND "
		cQuery += "D_E_L_E_T_=' '"

		cQuery := ChangeQuery( cQuery )

		dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQuery ), cAliasQry, .F., .T. )

		nPos := AScan( aStructSE5, { |x| Alltrim( x[1] ) == "E5_VALOR" } )
		TcSetField( cAliasQry, aStructSE5[nPos,1], aStructSE5[nPos,2], aStructSE5[nPos,3], aStructSE5[nPos,4] )

		While !( cAliasQry )->( Eof() )

			aEst := {}
			AAdd( aEst, ( cAliasQry )->E5_DOCUMEN )
			AAdd( aEstorno, AClone( aEst ) )

			nValorEst += ( cAliasQry )->E5_VALOR
			( cAliasQry )->( dbSkip() )

		EndDo

		( cAliasQry )->( dbCloseArea() )

	Next nLoop

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//?Efetua o estorno das baixas por compensacao                ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty( aEstorno )
		MaIntBxCR(3,aRecGer,,NIL,,{.F.,.F.,.F.,.F.,.F.,.F.},, aEstorno )
	EndIf
EndIf

Return( Nil )

//-------------------------------------------------------------------
/*/{Protheus.doc} SchedCtaAl()
Processa o envio de Aviso sobre vencimento do Contrato por Schedule

@author jose.eulalio
@since 20/07/2015
@version 1.0
@return Nil
/*/
//-------------------------------------------------------------------
Function SchedCtaAl(aParam)
Local nX			:= 0
Local aFilial		:= {}
Local aArea
Local cCnSched
Local dDataSched

//Abre módulo GCT
RpcSetType(3)
RpcSetEnv(aParam[1],aParam[2],,,"GCT")

aArea		:= GetArea()
cCnSched	:= SuperGetMV("MV_CNSCHED",.F.,"0") //Verifica o parâmetro de envio de alerta no GCT.
dDataSched	:= GetNewPar( "MV_CNSCHAT", "" )

//Gera Array com Filiais que deverão ser verificadas no Agendamento
dbSelectArea("SM0")
SM0->(dbGoTop())

While SM0->(!EOF())
	If AllTrim(aParam[1]) == AllTrim(SM0->M0_CODIGO) .And. AllTrim(aParam[2]) == AllTrim(SM0->M0_CODFIL)
    	AADD(aFilial,{SM0->M0_CODIGO,SM0->M0_CODFIL})
    EndIf
    SM0->(dbSkip())
EndDo

RestArea(aArea)

//Fecha o módulo
RpcClearEnv()

//Verifica se deve ser atualizado pelo Schedule no dia
If cCnSched $ "23" .And. !Empty(dDataSched) .And. dDataSched < dDataBase

	For nX:=1 To Len(aFilial)

		//Abre módulo nas filiais indicada
		RpcSetType(3)
		RpcSetEnv(aFilial[nX,01],aFilial[nX,02],,,"GCT")

		//Dispara email informando vencimento, caso configurado
		CtaAlert()

		//Atualiza somente uma vez parametro de controle pelo Schedule
		If dDataSched < dDataBase
			PutMV( "MV_CNSCHAT", dDataBase )
		EndIf

		RpcClearEnv()

	Next nX

EndIf

Return

/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ?GCTLoad   ?Autor ?Marcelo Custodio     ?Data ?2/08/2006 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ?Rotina executada durante a incializacao do modulo SIGAGCT   ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ?GCTLoad( )                                                  ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ?Generico                                                    ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GCTInitFun()
Local dData 	:= GetNewPar( "MV_ATUGCT", CTOD("//") )
Local dDataSched:= GetNewPar( "MV_CNSCHAT", CTOD("//") )
Local cCnSched	:= SuperGetMV("MV_CNSCHED",.F.,"0") //Verifica o parâmetro de envio de alerta no GCT.
Local cQuery 	:= ""
Local cAlias 	:= ""

If !Empty(dData)
	//-- Verifica data da ultima execucao da rotina de alerta dos contratos
	If (cCnSched $ "1|3" .And. dData < dDataBase) .Or. (cCnSched $ "3" .And. dDataSched < dDataBase)
		CtaAlert() //- Dispara a função que alerta o término ou proximidade do término do contrato

		If !IsBlind()
			//Verifica compatibilidade entre as tabelas do módulo GCT e Financeiro
			CheckCpt()
		EndIf

		If cCnSched $ "2|3"
			PutMV( "MV_CNSCHAT",dDataBase) 	//-- Atualiza parametro de controle pelo Schedule
		EndIf
		PutMV("MV_ATUGCT",dDataBase) 		//--  Atualiza parametro de controle
	EndIf
EndIf

//- Gera transacoes do sistema - funcao retirada da lib

dbSelectArea("CNO")

cQuery := "SELECT COUNT(*) AS TOTAL FROM "+ RetSQLName("CNO") +" CNO WHERE "
cQuery += "CNO.CNO_FILIAL = '"+ xFilial("CNO") +"' AND "
cQuery += "CNO.D_E_L_E_T_ = ' '"

cAlias := GetNextAlias()
cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.F.,.T.)

If (cAlias)->(RecCount()) < TOTALTRAN
	CtaGerTra()
EndIf

(cAlias)->(dbCloseArea())

Return

/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ?CtaAlert  ?Autor ?Marcelo Custodio     ?Data ?2/08/2006 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ?Verifica os contratos terminados ou em data de denuncia     ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ?CtaAlert()                                                  ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ?Generico                                                    ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CtaAlert()
Local cQuery 	:= 	""
Local cArqTrb	:=	GetNextAlias()
Local dDtComp	:=	dDataBase
Local nX		:=  0
Local nCompEve := SuperGetMV("MV_COMPEVE", .F., 1)

//-- Filtra contratos ativo do sistema
cQuery := " SELECT "
cQuery += " CN9.CN9_FILIAL, "
cQuery += " CN9.CN9_NUMERO, "
cQuery += " CN9.CN9_REVISA, "
cQuery += " CN9.CN9_DTINIC, "
cQuery += " CN9.CN9_DTFIM , "
cQuery += " CN9.CN9_TPCTO   "
cQuery += " FROM "+RetSQLName("CN9")+" CN9 "
cQuery += " WHERE "
If nCompEve == 2
	cQuery += " CN9.CN9_FILIAL = '"+xFilial("CN9")+"' AND "
EndIf
cQuery += " CN9.CN9_SITUAC = '"+DEF_SVIGE+"' AND "
cQuery += " CN9.D_E_L_E_T_ = ' '"

cQuery := ChangeQuery( cQuery )
dbUseArea( .T., "TopConn", TCGenQry(,,cQuery), cArqTrb, .T., .T. )

//-- Atualiza campos de data
TCSetField(cArqTrb,"CN9_DTINIC","D",08,0)
TCSetField(cArqTrb,"CN9_DTFIM" ,"D",08,0)

dbSelectArea("CN1")//Tipo de Contrato
CN1->(dbSetOrder(1))

While !(cArqTrb)->(Eof())

	//-- Posiciona no tipo de contrato
	CN1->(MsSeek(xFilial("CN1")+(cArqTrb)->CN9_TPCTO))

	dbSelectArea("CN9")
	CN9->(dbSetOrder(1))
	//-- Verifica se o contrato chegou a data de termino e emite alerta de termino do contrato
	If (cArqTrb)->CN9_DTFIM == dDataBase
		If MsSeek((cArqTrb)->(CN9_FILIAL+CN9_NUMERO+CN9_REVISA))
			GCTSendMsg("039", "", STR0124, {(cArqTrb)->CN9_NUMERO,(cArqTrb)->CN9_REVISA,(cArqTrb)->CN9_DTINIC,(cArqTrb)->CN9_DTFIM,(cArqTrb)->CN9_FILIAL}) //"Término do Contrato - (SIGAGCT)"
        EndIf
	Else //- Verifica se o contrato chegou a data de denuncia de acordo com o periodo de dias informado no cadastro de tipos de contrato
		If CN9->(MsSeek((cArqTrb)->(CN9_FILIAL+CN9_NUMERO+CN9_REVISA)))
			aDts := CtaDtAviso((cArqTrb)->CN9_TPCTO,xFilial("CN1")) 		//-- Carrega os dias de aviso estabelecidos no tipo de contrato
			For nX:=1 to len(aDts)
				dDtComp := (cArqTrb)->CN9_DTFIM - aDts[nX]
				If (dDataBase == dDtComp .And. dDataBase < (cArqTrb)->CN9_DTFIM) .And. !Empty(aDts[nX])
					GCTSendMsg("038", "", STR0125, {(cArqTrb)->CN9_NUMERO,(cArqTrb)->CN9_REVISA,(cArqTrb)->CN9_DTINIC,(cArqTrb)->CN9_DTFIM,(cArqTrb)->CN9_FILIAL}) //"Aviso de Vencimento - (SIGAGCT)"
				EndIf
			Next nX
		EndIf
	EndIf
	(cArqTrb)->(dbSkip())
EndDo

(cArqTrb)->(dbCloseArea())
Return

/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ?CtaGerTra ?Autor ?Marcelo Custodio     ?Data ?1/09/2006 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ?Gera transacaoes no arquivo CNO                             ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ?CtaGerTra()                                                 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ?Generico                                                    ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CtaGerTra()
Local aTrans :={}
Local cCodFil:= xFilial("CNO")
Local nx

aAdd(aTrans,{"001",STR0001,""})//"Controle Total"
aAdd(aTrans,{"002",STR0002,"001"})//"Cauções - Contr. Total"
aAdd(aTrans,{"003",STR0003,"002"})//"Cauções - Inclusão"
aAdd(aTrans,{"004",STR0004,"002"})//"Cauções - Edição"
aAdd(aTrans,{"005",STR0005,"002"})//"Cauções - Exclusão"
aAdd(aTrans,{"006",STR0006,"001"})//"Planilhas - Contr. Total"
aAdd(aTrans,{"007",STR0007,"006"})//"Planilhas - Inclusão"
aAdd(aTrans,{"008",STR0008,"006"})//"Planilhas - Edição"
aAdd(aTrans,{"009",STR0009,"006"})//"Planilhas - Exclusão"
aAdd(aTrans,{"010",STR0010,"001"})//"Cronogramas - Contr. Total"
aAdd(aTrans,{"011",STR0011,"010"})//"Cronogramas - Inclusão"
aAdd(aTrans,{"012",STR0012,"010"})//"Cronogramas - Edição"
aAdd(aTrans,{"013",STR0013,"010"})//"Cronogramas - Exclusão"
aAdd(aTrans,{"014",STR0014,"001"})//"Documentos - Contr. Total"
aAdd(aTrans,{"015",STR0015,"014"})//"Documentos - Inclusão"
aAdd(aTrans,{"016",STR0016,"014"})//"Documentos - Edição"
aAdd(aTrans,{"017",STR0017,"014"})//"Documentos - Exclusão"
aAdd(aTrans,{"018",STR0018,"001"})//"Controlar Situação"
aAdd(aTrans,{"019",STR0019,"001"})//"Movimentações - Contr. Total"
aAdd(aTrans,{"020",STR0020,"019"})//"Medições - Contr. Total"
aAdd(aTrans,{"021",STR0021,"020"})//"Medições - Inclusão"
aAdd(aTrans,{"022",STR0022,"020"})//"Medições - Edição"
aAdd(aTrans,{"023",STR0023,"020"})//"Medições - Exclusão"
aAdd(aTrans,{"024",STR0024,"020"})//"Medições - Encerramento"
aAdd(aTrans,{"025",STR0025,"020"})//"Medições - Estorno"
aAdd(aTrans,{"026",STR0026,"019"})//"Revisões - Contr. Total"
aAdd(aTrans,{"027",STR0027,"026"})//"Revisões - Inclusão"
aAdd(aTrans,{"028",STR0028,"026"})//"Revisões - Edição"
aAdd(aTrans,{"029",STR0029,"026"})//"Revisões - Exclusão"
aAdd(aTrans,{"030",STR0030,"026"})//"Revisões - Aprovação"
aAdd(aTrans,{"031",STR0031,"002"})//"Caucoes - Visualizacao"
aAdd(aTrans,{"032",STR0032,"006"})//"Planilhas - Visualizacao"
aAdd(aTrans,{"033",STR0033,"010"})//"Cronogramas - Visualizacao"
aAdd(aTrans,{"034",STR0034,"014"})//"Documentos - Visualizacao"
aAdd(aTrans,{"035",STR0035,"020"})//"Medicoes - Visualizacao"
aAdd(aTrans,{"037",STR0036,"001"})//"Contratos - Visualizacao"
aAdd(aTrans,{"038",STR0037,"014"})//"Documentos - Banco de Conhec."
aAdd(aTrans,{"039",STR0038,"001"})//"Documentos - Banco de Conhec."
aAdd(aTrans,{"040",STR0039,"001"})//"Baixar Retenção"
aAdd(aTrans,{"041",STR0057,"001"})//"Controle de Acessos"
aAdd(aTrans,{"042",STR0060,"001"})//"Avaliações"
aAdd(aTrans,{"046",STR0061,"001"})//"Avaliações de Visualização"
aAdd(aTrans,{"047",STR0084,"001"})//"Contratos - Banco de Conhec."

dbSelectArea("CNO")

dbSetOrder(1)
For nx:=1 to len(aTrans)
	If !MsSeek(cCodFil+aTrans[nx,1])
		RecLock("CNO",.T.)
		CNO->CNO_FILIAL := cCodFil
		CNO->CNO_CODTRA := aTrans[nx,1]
	else
		RecLock("CNO",.F.)
	EndIf

	CNO->CNO_DESCRI := aTrans[nx,2]
	CNO->CNO_CODPAI := aTrans[nx,3]
	MsUnlock()
Next
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³CNCstEsp   ?Autor ?Marcelo Custodio      ?Data ?04.09.2006 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ?Consulta especifica dos fornecedores do contrato (CNC)        ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?Uso      ?CNTA200/CNTA090/CNTA130                                       ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CNCstEsp(nPar) 

	Local cProg      := FunName()
	Local cContra    := ""
	Local cRevisa	 := ""
	Local cFornec    := ""
	Local cLoja      := ""
	Local cTpCtr	 := ""
	Local nPos       := 0
	Local nx         := 0
	Local ny         := 0
	Local nPosCod    := 0
	Local nPosLoja   := 0
	Local lExport    := .F.
	Local lArray     := .F.
	Local aColsBck   := {}
	Local aHeaderBck := {}
	Local lIncOld    := INCLUI
	Local aNoFields  := {}
	Local lBck       := .F.
	Local aFornClone := {}
	Local aRet       := {}
	Local aRows		:= {}
	Local lBxRet	:= IsInCallstack("CN100CtrRet")
	Local lAdian	:= IsInCallstack("CN100CtrAdia")
	Local oModal	:= NIL
	Local cFilAtu	:= cFilAnt
	Local cFilCTR	:= cFilAnt
	Local oModelAux := FwModelActive()
	Local oModel	:= Nil
	Local oModelCNA	:= Nil
	Local oModelCNC	:= Nil
	Local aSaveLines	:= FWSaveRows()
	Default nPar		:= 1
	
	If Type("aHeader")=="A"
		 lBck := .T.
	     aHeaderBck:= aHeader
	     aColsBck  := aCols
	EndIf
	
	Private aCols  := {}
	Private aHeader:= {}
	
	INCLUI := .F.
	
	//Proteção para quando a tela de definição de valores do filtro é executada antes da abertura do browse
	If ProcName(9) == "FILTERASK" .Or. ( oModelAux == Nil .And. !(FwIsInCallStack("CN120Manut") .Or. FwIsInCallStack("CN120Inc") .Or. FwIsInCallStack("CN130Manut") .Or. FwIsInCallStack("CN100CtrRet")))
			If nPar == 1
				ConPad1( ,,,"FOR", , , .F. )
			Else
				ConPad1( ,,,"CLI", , , .F. )
			EndIf
		INCLUI := lIncOld
		Return .T.
	EndIf
	
	If (( cProg == "CNTA300" .And. !lBxRet .And. !lAdian ) .Or. (cProg == "CNTA121" .Or. cProg == "TECA870" .Or. cProg == "TECA930" ))
	
		If (cProg == "CNTA300" .Or. cProg == "TECA870")
			oModel := FwModelActive()
			INCLUI := (oModel:GetOperation() = MODEL_OPERATION_INSERT)
		Else
			If cProg <> "TECA930"
				cFilCTR := FwFldGet("CND_FILCTR")
				cFilAnt := cFilCTR
				
				CN9->(DbSetOrder(1))
				CN9->(DbSeek( xFilial("CN9", cFilCTR) + FwFldGet("CND_CONTRA") + FwFldGet("CND_REVISA") ))		
			EndIf	
			cTpCtr := CN9->CN9_ESPCTR	
			oModel := FwLoadModel(IIF(cTpCtr=="2", "CNTA301", "CNTA300"))
			oModel:SetOperation( MODEL_OPERATION_VIEW )
			oModel:Activate()
		EndIf
	
		oModelCNC	:= oModel:GetModel("CNCDETAIL")
		oModelCNA	:= oModel:GetModel("CNADETAIL")
	
		cTpCtr := oModel:GetValue("CN9MASTER","CN9_ESPCTR")
	
		If cTpCtr == "1"
			aNoFields := {"CNC_FILIAL","CNC_NUMERO","CNC_REVISA","CNC_CODED","CNC_NUMPR","CNC_CLIENT","CNC_LOJACL","CNC_NOMECL"}
			cContra := oModelCNA:GetValue("CNA_CONTRA")
			cFornec := oModelCNA:GetValue("CNA_FORNEC")
		 	cLoja   := oModelCNA:GetValue("CNA_LJFORN")
		Else
			aNoFields := {"CNC_FILIAL","CNC_NUMERO","CNC_REVISA","CNC_CODED","CNC_NUMPR","CNC_CODIGO","CNC_LOJA","CNC_NOME"}
			cContra := oModelCNA:GetValue("CNA_CONTRA")
			cFornec := oModelCNA:GetValue("CNA_CLIENT")
		 	cLoja   := oModelCNA:GetValue("CNA_LOJACL")
		Endif
	
		aHdAux	:= oModelCNC:aHeader
		For nX := 1 To Len(aHdAux)
			If aScan(aNoFields,{|x| x == aHdAux[nX,2] } ) == 0
				AADD(aHeader, aClone(aHdAux[nX]))
			EndIf
		Next nX
	
		aFornClone	:= {}
		aRows := FwSaveRows()
	
		For nX := 1 To oModelCNC:Length()
			oModelCNC:GoLine(nX)
			If oModelCNC:IsDeleted() .Or.;
					(FWFldGet("CN9_ESPCTR") == "1" .And. (Empty(FwFldGet("CNC_CODIGO")) .Or. Empty(FwFldGet("CNC_LOJA")))) .Or.;
					(FWFldGet("CN9_ESPCTR") == "2" .And. (Empty(FwFldGet("CNC_CLIENT")) .Or. Empty(FwFldGet("CNC_LOJACL"))))
				Loop
			EndIf
	
			If cTpCtr == "1"
				aAdd(aFornClone, FwFldGet("CNC_CODIGO")+FwFldGet("CNC_LOJA"))
			Else
				aAdd(aFornClone, FwFldGet("CNC_CLIENT")+FwFldGet("CNC_LOJACL"))
			EndIf
	
			AADD(aCols, {})
			For nY := 1 To Len(aHeader)
				AADD(aTail(aCols), FwFldGet(aHeader[nY,2]))
			Next
			AADD(aTail(aCols), .F.)
	
		Next nX
	
		FwRestRows(aRows)
		
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		//?Trata chamada da consulta de acordo com a rotina?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		Do Case
			Case cProg == "CNTA200" .OR. cProg $ "CNTA100|CNTA300" //Rotina de planilha ou contrato
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
				//?Verifica se a chamada foi realizada pela baixa  ?
				//?de caucao de retencao do sistema                ?
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
				If Type("lBxCNT") == "L" .And. lBxCNT
					cTpCtr := CN9-> CN9_ESPCTR				
					
					cContra := CN9->CN9_NUMERO
					If cTpCtr == "1"
			   		 	cFornec := CriaVar("CNT_FORNEC",.F.)
					 	cLoja   := CriaVar("CNT_LJFORN",.F.)
					Else
			   		 	cFornec := CriaVar("CNT_CLIENT",.F.)
					 	cLoja   := CriaVar("CNT_LOJACL",.F.)
					Endif
				Else
					cRevisa := Posicione("CN9",1,xFilial("CN9")+M->CNA_CONTRA,"CN9_REVATU")
					CN9->(MsSeek(xFilial('CN9')+M->CNA_CONTRA+cRevisa))
					cTpCtr := CN9-> CN9_ESPCTR
	
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Verifica se o contrato ja se encontra incluso   ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					If Type("lContrEd") == "L" .And. !lContrEd
						If cTpCtr == "1"
							cContra := M->CNA_CONTRA
							cFornec := M->CNA_FORNEC
						 	cLoja   := M->CNA_LJFORN
						Else
							cContra := M->CNA_CONTRA
							cFornec := M->CNA_CLIENT
						 	cLoja   := M->CNA_LOJACL
						Endif
				 	Else
				 		If cTpCtr == "1"
					 		lArray := .T.
				   		 	cFornec := Space(Len(CNA->CNA_FORNEC))
						 	cLoja   := Space(Len(CNA->CNA_LJFORN))
						Else
					 		lArray := .T.
				   		 	cFornec := Space(Len(CNA->CNA_CLIENT))
						 	cLoja   := Space(Len(CNA->CNA_LOJACL))
						Endif
				 	EndIf
			 	EndIf
			Case cProg == "CNTA120"//Medicao
				cContra := M->CND_CONTRA
				CN9->(MsSeek(xFilial('CN9')+cContra))
				cTpCtr := CN9->CN9_ESPCTR
				cFilCTR:= M->CND_FILCTR
				If cTpCtr == "1"
				 	cFornec := M->CND_FORNEC
			 		cLoja   := M->CND_LJFORN
			 	Else
				 	cFornec := M->CND_CLIENT
			 		cLoja   := M->CND_LOJACL
			 	Endif
			Case cProg == "CNTA090"//Caucoes
				cRevisa := Posicione("CN9",1,xFilial("CN9")+M->CN8_CONTRA,"CN9_REVATU")
				CN9->(MsSeek(xFilial('CN9')+M->CN8_CONTRA+cRevisa))
				cTpCtr := CN9-> CN9_ESPCTR
				If cTpCtr == "1"
					cContra := M->CN8_CONTRA
				 	cFornec := M->CN8_FORNEC
			 		cLoja   := M->CN8_LOJA
			 	Else
					cContra := M->CN8_CONTRA
				 	cFornec := M->CN8_CLIENT
			 		cLoja   := M->CN8_LOJACL
			 	Endif
			Case cProg == "CNTA220"//Avaliacao de Fornecedores
				cContra := M->CNM_CONTRA
			 	cFornec := M->CNM_FORNEC
			 	cLoja   := M->CNM_LOJA
		EndCase
	
		If cTpCtr == "1"
			aNoFields := {"CNC_FILIAL","CNC_NUMERO","CNC_REVISA","CNC_CODED","CNC_NUMPR","CNC_CLIENT","CNC_LOJACL","CNC_NOMECL"}
		Else
			aNoFields := {"CNC_FILIAL","CNC_NUMERO","CNC_REVISA","CNC_CODED","CNC_NUMPR","CNC_CODIGO","CNC_LOJA","CNC_NOME"}
		Endif
	
		cRevisa := CnUltRev(cContra,cFilCTR)
		CN9->(MsSeek(xFilial('CN9',cFilCTR)+cContra+cRevisa))
	
		If !lArray .And. (!(cProg $ "CNTA100|CNTA300") .Or. Type("lBxCNT") == "L" .And. lBxCNT)
			If cTpCtr == "1"
				CN100LdAl(2,"CNC",aCols,aHeader,"CNC.CNC_NUMERO = '"+ cContra +"' AND CNC.CNC_REVISA = '" +cRevisa +"'",{"CNC_CODIGO","CNC_LOJA"},,aNoFields,/*cQuery*/,/*cSeek*/,/*cWhile*/,cFilCTR)
			Else
				CN100LdAl(2,"CNC",aCols,aHeader,"CNC.CNC_NUMERO = '"+ cContra +"' AND CNC.CNC_REVISA = '" +cRevisa +"'",{"CNC_CLIENT","CNC_LOJACL"},,aNoFields,/*cQuery*/,/*cSeek*/,/*cWhile*/,cFilCTR)
			Endif
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Preenche acols com o array dos fornecedores       ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	
			If Type("aForn") != "A" .And. cTpCtr == "1"
				aForn := aEval(oGetDad1:aCols,{|x| {x[aScan(aHeader1,{|x| AllTrim(x[2]) == "CNC_CODIGO"})],x[aScan(aHeader1,{|x| AllTrim(x[2]) == "CNC_LOJA"})]}})
			Else
				aForn := aEval(oGetDad1:aCols,{|x| {x[aScan(aHeader1,{|x| AllTrim(x[2]) == "CNC_CLIENT"})],x[aScan(aHeader1,{|x| AllTrim(x[2]) == "CNC_LOJACL"})]}})
			EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Retira os elementos deletados do aCols                                                    ?
			//?- aForn pode conter elementos deletados mesmo quando for uma "atualizacao" do contrato    ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			aFornClone := {}
			For ny := 1 to Len(aForn)
				If !aForn[ny,Len(aHeader1)+1]
					aAdd(aFornClone, aForn[ny])
				EndIf
			Next
			FillGetDados(1,"CNC",1,,,{|| .T. },aNoFields,,,,,.T.,aHeader,aFornClone)
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	//?Ponto de entrada para customiza o array dos fornecedores        ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	If ExistBlock("CNCFldEsp")
		aRet := ExecBlock("CNCFldEsp",.f.,.f.,{aHeader,aCols})
	
		If Valtype(aRet) == "A"
			If Len(aRet)>=1 .And. Valtype(aRet[1]) == "A"
				aHeader := aClone(aRet[1])
			EndIf
			If Len(aRet)>=2 .And. Valtype(aRet[2]) == "A"
				aCols := aClone(aRet[2])
			EndIf
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	//?Encontra posicao do fornecedor quando selecionado ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	If cTpCtr == "1"
		nPosCod:=aScan(aHeader,{|x| AllTrim(x[2]) == "CNC_CODIGO"})
		nPosLoja:=aScan(aHeader,{|x| AllTrim(x[2]) == "CNC_LOJA"})
	Else
		nPosCod:=aScan(aHeader,{|x| AllTrim(x[2]) == "CNC_CLIENT"})
		nPosLoja:=aScan(aHeader,{|x| AllTrim(x[2]) == "CNC_LOJACL"})
	Endif
	If !Empty(cFornec) .Or. !Empty(cLoja)
		nPos:=ascan(aCols,{|x| x[nPosCod]==cFornec .AND. x[nPosLoja]==cLoja})
	EndIf

	oModal  := FWDialogModal():New()//Cria tela de consulta dos fornecedores/Clientes
    oModal:SetEscClose(.T.)	
    oModal:SetTitle(STR0056)//"Consulta - Fornecedores/Clientes do Contrato"
	oModal:SetSubTitle(FwSX2Util():GetX2Name("CNC"))		
    oModal:SetSize(200, 350)//Seta a largura e altura da janela em pixel
 
    oModal:createDialog()
    oModal:addCloseButton(, STR0047) //OK
	oModal:setCloseBlock({|| If(len(aCols)>0,lExport:=.T.,lExport:=.F.), , oModal:DeActivate() })

	oGet := MsNewGetDados():New(005,005,100,232,0,,,,,,,,,,oModal:getPanelMain(),aHeader,aCols)
	oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	If nPos > 0
		oGet:nAt := oGet:OBROWSE:NAT := nPos//Posiciona no registro quando houver
	EndIf
	
	oGet:oBrowse:blDblClick := {|| If(len(aCols)>0,lExport:=.T.,lExport:=.F.), oModal:DeActivate()}
	oModal:Activate()
	
	If !Empty(aCols)
		If lExport .And. cTpCtr == "1"
			dbSelectArea("SA2")
			dbSetOrder(1)
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Posiciona no registro da SA2 selecionado        ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			MsSeek(xFilial("SA2")+aCols[oGet:nAt,nPosCod]+aCols[oGet:nAt,nPosLoja])
		Else
			dbSelectArea("SA1")
			dbSetOrder(1)
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Posiciona no registro da SA1 selecionado        ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			MsSeek(xFilial("SA1")+aCols[oGet:nAt,nPosCod]+aCols[oGet:nAt,nPosLoja])
		EndIf
	EndIf
	
	If !(cProg $ "CNTA300|CNTA120|TECA870")
		If Valtype(oModel) == 'O' .And. oModel:IsActive()
			oModel:DeActivate()
			oModel := Nil
			If Valtype(oModelAux) == 'O' .And. oModelAux:IsActive()
				FWModelActive( oModelAux )
			EndIf
		EndIf
		
		cFilAnt := cFilAtu	
	EndIf
	
	If lBck
		aHeader:= aHeaderBck
		aCols  := aColsBck
	EndIf
	
	INCLUI := lIncOld
	FWRestRows(aSaveLines)
Return lExport

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³CtaVend    ?Autor ?Marcelo Custodio      ?Data ?20.10.2006 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ?Retorna array com os vendedores relacionados ao contrato      ³±?
±±?         ?aVend[x,1] - Codigo do Vendedor                               ³±?
±±?         ?aVend[x,2] - Percentual de comissao                           ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?Uso      ?CNTA120                                                       ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtaVend(cContra, cFilCTR, cRevisa)
Local aVend  := {}
Local cQuery := ""
Local cAlias := GetNextAlias()
Local aPercCm := TamSX3("CNU_PERCCM")
Default cFilCtr:= cFilAnt
Default cRevisa:= Nil

//Seleciona amarracao vendedores X contrato
cQuery := "SELECT CNU.CNU_CODVD,CNU.CNU_PERCCM FROM "+RetSQLName("CNU")+" CNU "
cQuery += "WHERE CNU.CNU_FILIAL = '"+xFilial("CNU", cFilCTR)+"' AND "
cQuery += "CNU.CNU_CONTRA = '"+cContra+"' AND "
cQuery += "CNU.D_E_L_E_T_ = ' '"

If (CNURevisa())

	If (cRevisa == Nil)
		cRevisa := CnUltRev(cContra, cFilCtr)
	EndIf

	cQuery += " AND CNU.CNU_REVISA = '"+ cRevisa +"'"
EndIf

If (CNU->(ColumnPos('CNU_ITEM') > 0))	
	cQuery += " ORDER BY CNU.CNU_ITEM,CNU.CNU_CODVD"
Else
	cQuery += " ORDER BY CNU.CNU_CODVD"
EndIf

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.F.,.T.)

TCSetField( cAlias, "CNU_PERCCM", "N", aPercCm[1] , aPercCm[2])

While (cAlias)->(!Eof())
	aAdd(aVend,{(cAlias)->CNU_CODVD,(cAlias)->CNU_PERCCM})
	(cAlias)->(dbSkip())
EndDo
(cAlias)->(dbCloseArea())

Return aVend

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±?
±±³Fun‡„o    ³CntQtdVend?Autor ?Felipe Bittar         ?Data ?19/12/08 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±?
±±³Descri‡„o ?Funcao de Contagem do Numero de Vendedores Utilizados.     ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±?
±±³Retorno   ?Numero de Vendedores                                       ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±?
±±?Uso      ?CNTA100                                                    ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
/*/
Function CntQtdVend(cTab)

Local cCnt     := "1"
Local aStruct  := ""
Local lContinua:= .T.
Local nVend    := 0

Default cTab := "SE1"

nVend := 0

Do Case

	Case cTab == "SE1"
		aStruct := SE1->(dbStruct())
		While ( lContinua )
			If (   aScan(aStruct,{|x| Trim(x[1]) == "E1_VEND"+cCnt})  != 0 ) .AND. ;
			     ( aScan(aStruct,{|x| Trim(x[1]) == "E1_COMIS"+cCnt}) != 0 ) .AND. ;
			     ( aScan(aStruct,{|x| Trim(x[1]) == "E1_VALCOM"+cCnt})!= 0 )
				nVend++
				cCnt := Soma1(cCnt,1)
			Else
				lContinua := .F.
			EndIf
		EndDo

	Case cTab == "SC5"
		aStruct := SC5->(dbStruct())
		While ( lContinua )
			If (   aScan(aStruct,{|x| Trim(x[1]) == "C5_VEND"+cCnt})  != 0 ) .AND. ;
			     ( aScan(aStruct,{|x| Trim(x[1]) == "C5_COMIS"+cCnt}) != 0 )
				nVend++
				cCnt := Soma1(cCnt,1)
			Else
				lContinua := .F.
			EndIf
		EndDo

	Case cTab == "SC6"
		aStruct := SC6->(dbStruct())
		While ( lContinua )
			If ( aScan(aStruct,{|x| Trim(x[1]) == "C6_COMIS"+cCnt}) != 0 )
				nVend++
				cCnt := Soma1(cCnt,1)
			Else
				lContinua := .F.
			EndIf
		EndDo

EndCase

nVend := Max(nVend,5)

Return(nVend)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³CtaAvalGCT ?Autor ?Marcelo Custodio      ?Data ?20.10.2006 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ?Executa baixa da planilha durante a geracao da NF             ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±?Uso      ?CNTA120                                                       ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtaAvalGCT(nOper,aContratos,cContrato,cPlanilha,cItemMed,nQuant,aMedicao,cMedicao,nVlrTot,cRevisa)
Local nPosContra := 0
Local nPosMed    := 0
Local nServico   := 1
Local lAtuSaldo  := .T.
Local cFilCTR		:= CNTBuscFil(xFilial('CND'),cMedicao)
DEFAULT nVlrTot  := 0
DEFAULT cRevisa  := ''

If (nPosContra := aScan(aContratos,{|x| x[1] == cContrato})) == 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//?Posiciona no contrato                  ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	CN9->( dbSetOrder(1) )
	If CN9->( dbSeek(xFilial("CN9",cFilCTR) + cContrato + cRevisa) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//?Verifica se o contrato possui revisao  ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If CN9->CN9_SITUAC == DEF_SREVD
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//?Posiciona na revisao atual             ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aAdd(aContratos,{CN9->CN9_NUMERO,CN9->CN9_REVATU,{},cFilCTR})
		Else
			aAdd(aContratos,{CN9->CN9_NUMERO,CN9->CN9_REVISA,{},cFilCTR})
		EndIf

		nPosContra := Len(aContratos)
	EndIf
EndIf

If (lAtuSaldo := !Empty(nPosContra))
	CNE->(dbSetOrder(1))
	CNE->(MsSeek(xFilial("CNE")+aContratos[nPosContra,1]+aContratos[nPosContra,2]+cPlanilha+cMedicao+cItemMed))
	If CNE->CNE_EXCEDE == '1'
		lAtuSaldo := .F.
	EndIf
EndIf

If lAtuSaldo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Localizar medicao do contrato   		   ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	CND->(dbSetOrder(1))
	If CND->(MsSeek(xFilial("CND")+aContratos[nPosContra,1]+aContratos[nPosContra,2]+cPlanilha+cMedicao))
		nServico := If(CND->CND_SERVIC == "2",2,1)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//?Baixa o saldo a receber da planilha                                    ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !CN300RetSt('SEMIFIXO',0,cPlanilha,cContrato) //Planilhas semifixas n?o possuem saldo no item.
		CNB->(dbSetOrder(1))
		If CNB->(MsSeek(xFilial("CNB",cFilCTR)+aContratos[nPosContra,1]+aContratos[nPosContra,2]+cPlanilha+Left(cItemMed,Len(CNB->CNB_ITEM))))
			If nServico == 2
				nQuant := Round((nVlrTot/CNE->CNE_VUNORI),TamSX3("CNB_SLDREC")[2])
			EndIf

			Reclock("CNB",.F.)
				If nOper == 1
					CNB->CNB_SLDREC -= nQuant
				Else
					CNB->CNB_SLDREC += nQuant
				EndIf
			CNB->(MsUnlock())
		EndIf
	EndIf

	If nOper == 1 .And. ValType(aMedicao) == "A"
		If (nPosMed := aScan(aMedicao,{|x| x[3]+x[4] == cMedicao+cItemMed})) == 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//?Verifica se o contrato possui revisao  ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If CN9->CN9_SITUAC == DEF_SREVD
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//?Posiciona na revisao atual             ?
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd(aMedicao,{CN9->CN9_NUMERO,CN9->CN9_REVATU,cMedicao,cItemMed,cPlanilha})
			Else
				aAdd(aMedicao,{CN9->CN9_NUMERO,CN9->CN9_REVISA,cMedicao,cItemMed,cPlanilha})
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	//?PE para atualizar o saldo da planilha/contrato  ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	If ExistBlock("CNTATUSL")
		ExecBlock("CNTATUSL",.F.,.F.,{CN9->CN9_NUMERO,CN9->CN9_REVISA,cPlanilha,cItemMed})
	EndIf
EndIf

Return

/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtaDtAviso ?Autor ?Marcelo Custodio     ?Data ?2/05/2007 ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ?Retorna array com os periodos para emissao do alerta de     ³±?
±±?         ?vencimento                                                  ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ?CtaDtAviso(cExp01)                                          ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros?cExp01 - Codigo do tipo de contrato                         ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CtaDtAviso(cTpCto,cFilCtr)
Local aDts 	:= {}
Local aRet 	:= {}
Local aRetU	:= {}
Local cDias	:= ""
Local cDig 	:= ""
Local nX   	:= 0

Default cFilCtr := xFilial("CN1")

//- Posiciona no tipo de contrato
dbSelectArea("CN1")
CN1->(dbSetOrder(1))

If CN1->(MsSeek(cFilCtr+cTpCto))
	//-- Verifica se o compatibilizador foi executado
	If valtype(CN1->CN1_PRDALT) == "C"
		cDias := AllTrim(CN1->CN1_PRDALT)
	Else
		aAdd(aDts,str(CN1->CN1_PRDALT))
	EndIf

	//-- Monta array com os periodos informados
	If len(aDts) == 0
		aAdd(aDts,"")

		For nX:=1 to len(cDias)
			cDig := SubStr(cDias,nX,1)
			Do Case
				Case IsDigit(cDig)
					aDts[len(aDts)] += cDig
				OtherWise
					aAdd(aDts,"")
			EndCase
		Next
	EndIf
EndIf
aEval(aDts,{|x| aAdd(aRet,val(x))})

//-- Ponto de entrada para alteração de dias anteriores ao termino para de aviso.
If ExistBlock("CNDTAVENC")
	aRetU := ExecBlock("CNDTAVENC",.F.,.F.,{aRet})
	If ValType(aRetU) == "A" .And. Len(aRetU) >= 1
		aRet := aRetU
	EndIf
EndIf

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±?
±±³Funcao    ³CNTAvalGCT?Autor ³Marcelo Custodio       ?Data ?7/03/2007³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±?
±±³Descri‡…o ³Processa titulo a pagar gerado para o GCT                   ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±?
±±³Sintaxe   ³CNTAvalGCT(nExp01,nExp02,nExp03,nExp04,@nExp05)             ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±?
±±³Parametros³nExp01 - Total da retencao                                  ³±?
±±?         ³nExp02 - Total do desconto                                  ³±?
±±?         ³nExp03 - Total da multa                                     ³±?
±±?         ³nExp04 - Total da bonificacao                               ³±?
±±?         ³nExp05 - Valor do titulo - Referencia                       ³±?
±±?         ³aExp06 - Armazena os contratos e medicoes processadas pela  ³±?
±±?         ?        nota                                               ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Function CNTAvalGCT(nGCTRet,nGCTDesc,nGCTMult,nGCTBoni,nVlCruz,aContra,lGCTBloq)
Default aContra	:= {}
Default lGCTBloq:= .F.

If !Empty(aContra)
	lGCTBloqu := (SE2->(FieldPos("E2_MSBLQL")) > 0) .And. POSICIONE("CND",4,xFilial("CND")+aContra[1,4],"CND_AUTFRN") == "2"
EndIf

//-- Verifica se existe retencao de contrato
If	nGCTRet > 0
	SE2->E2_RETCNTR := nGCTRet
	SE2->E2_VALOR	-= SE2->E2_RETCNTR
	SE2->E2_SALDO	-= SE2->E2_RETCNTR
	nVlCruz			-= SE2->E2_RETCNTR
EndIf

//-- Verifica se existe desconto de contrato
If	nGCTDesc > 0
	SE2->E2_MDDESC := nGCTDesc
	SE2->E2_VALOR	-= SE2->E2_MDDESC
	SE2->E2_SALDO	-= SE2->E2_MDDESC
	nVlCruz			-= SE2->E2_MDDESC
EndIf

//-- Verifica se existe multa de contrato
If	nGCTMult > 0
	SE2->E2_MDMULT := nGCTMult
	SE2->E2_VALOR	-= SE2->E2_MDMULT
	SE2->E2_SALDO	-= SE2->E2_MDMULT
	nVlCruz			-= SE2->E2_MDMULT
EndIf

//-- Verifica se existe bonificao de contrato
If	nGCTBoni > 0
	SE2->E2_MDBONI := nGCTBoni
	SE2->E2_VALOR	+= SE2->E2_MDBONI
	SE2->E2_SALDO	+= SE2->E2_MDBONI
	nVlCruz			+= SE2->E2_MDBONI
EndIf

//-- Verifica se o titulo deve ser bloqueado
If	lGCTBloq
	SE2->E2_MSBLQL := "1"	//- Bloqueia titulo
EndIf

If ExistBlock("CNTGERSE2")
	ExecBlock("CNTGERSE2",.F.,.F.,{aContra})
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±?
±±³Funcao    ³CNTAvalSC5?Autor ³Marcelo Custodio       ?Data ?4/08/2007³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±?
±±³Descri‡…o ³Processa titulo a receber gerado para o GCT considerando os ³±?
±±?         ³valores de retencao, multa, bonificacao e descontos da      ³±?
±±?         ³medicao                                                     ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±?
±±³Sintaxe   ³CNTAvalSC5(aExp01,nExp02,lExp03)                            ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±?
±±³Parametros³aExp01 - Armazena as medicoes do pedido de venda            ³±?
±±?         ³nExp02 - Armazena a proporcao do titulo financeiro          ³±?
±±?         ³lExp03 - Informa se e o ultimo titulo do recebimento        ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Function CNTAvalSC5(aMedicao,nProp,lTitFim)

Local aArea     := GetArea()
Local aAreaSC5  := SC5->( GetArea() )
Local cFilSC5  := xFilial("SC5")
Local cFilSC6  := xFilial("SC6")
Local cFilCN9  := ""
Local cFilCNQ  := xFilial("CNQ")
Local cFilCNP  := ""
Local cFilCNR  := xFilial("CNR")
Local cFilCTR  := ""
Local cQuery   := ""
Local cAliasQr := ""
Local lGCTAdia := GetNewPar("MV_CNADIA", "N") == "S"
Local lGCTRet  := GetNewPar( "MV_CNRETNF", "N" ) == "S"
Local nGCTRet  := 0
Local nGCTDesc := 0
Local nGCTMult := 0
Local nGCTBoni := 0
Local nAdiant  := 0
Local nTotItem := 0
Local nValor   := 0
Local nX       := 0
Local cMedicao := ""
Local aTot     := {{0,0},{0,0},{0,0},{0,0}}//Armazena os totais e os saldos
Local lIncTot  := .T.
Local aC6Valor := TamSX3("C6_VALOR")
Local aCNQValor := TamSX3("CNQ_VALOR")
Local aCNRValor := TamSX3("CNR_VALOR")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//?Verifica se existe controle de retencao, desconto ou multa ?
//?de contrato no titulo financeiro                           ?
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lGCTRet
	CN9->(dbSetOrder(1))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//?Verifica se e a primeira execucao        ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If valType(aMedicao[len(aMedicao),1]) != "A"
		For nx:=1 to len(aMedicao)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//?Posiciona no contrato                  ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cFilCTR  := CNTBuscFil(xFilial('CND'),aMedicao[nx,3])
			cFilCN9  := xFilial("CN9",cFilCTR)
			cFilCNP  := xFilial("CNP",cFilCTR)

			If lGCTRet .And. CN9->(MsSeek(cFilCN9+aMedicao[nx,1]+aMedicao[nx,2]))

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//?Verifica se o contrato possui retencao ?
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If CN9->CN9_FLGCAU = '1' .And. CN9->CN9_TPCAUC = '2'

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//?Seleciona o valor do item do pedido    ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cQuery := "SELECT SC6.C6_VALOR "
					cQuery += "FROM "+RetSQLName("SC5")+" SC5, "+RetSQLName("SC6")+" SC6 WHERE "
					cQuery += "SC5.C5_FILIAL  = '"+cFilSC5+"' AND "
					cQuery += "SC6.C6_FILIAL  = '"+cFilSC6+"' AND "
					cQuery += "SC5.C5_MDCONTR = '"+aMedicao[nx,1]+"' AND "
					cQuery += "SC5.C5_MDNUMED = '"+aMedicao[nx,3]+"' AND "
					cQuery += "SC6.C6_ITEMED  = '"+aMedicao[nx,4]+"' AND "
					cQuery += "SC5.C5_NUM     = SC6.C6_NUM AND "
					cQuery += "SC5.D_E_L_E_T_ = ' ' AND "
					cQuery += "SC6.D_E_L_E_T_ = ' '"

					cQuery := ChangeQuery(cQuery)
					cAliasQr := GetNextAlias()
					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQr,.F.,.T.)

					TCSetField(cAliasQr,"C6_VALOR" ,"N",aC6Valor[1],aC6Valor[2])

					If !(cAliasQr)->(Eof())
                        nTotItem := (cAliasQr)->C6_VALOR //Valor total do item
			 		EndIf

					(cAliasQr)->(dbCloseArea())
                    
                    If !lGCTAdia //-- Calcula valor do adiantamento apenas quando o desconto não foi realizado na geração pedido               
                        nAdiant := CalcAdiant(aMedicao[nX,1], aMedicao[nX,2], aMedicao[nX,3], aMedicao[nX,5], aMedicao[nX,4], nTotItem)
                    EndIf
				EndIf

                nGCTRet += ((nTotItem - nAdiant) * CN9->CN9_MINCAU ) / 100 //-- Calcula total retido
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//?Verifica se mudou a medicao            ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cMedicao != aMedicao[nx,3]
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
				//?Soma descontos nao aplicados na medicao ?
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
				cQuery := "SELECT SUM(CNQ.CNQ_VALOR) AS CNQ_VALOR "
				cQuery += "FROM "+RetSQLName("CNQ")+" CNQ, "+RetSQLName("CNP")+" CNP WHERE "
				cQuery += "CNQ.CNQ_FILIAL = '"+cFilCNQ+"' AND "
				cQuery += "CNP.CNP_FILIAL = '"+cFilCNP+"' AND "
				cQuery += "CNQ.CNQ_TPDESC = CNP.CNP_CODIGO AND "
				cQuery += "CNQ.CNQ_CONTRA = '"+aMedicao[nx,1]+"' AND "
				cQuery += "CNQ.CNQ_NUMMED = '"+aMedicao[nx,3]+"' AND "
				cQuery += "CNP.CNP_FLGPED = '2' AND "
				cQuery += "CNQ.D_E_L_E_T_ = ' ' AND "
				cQuery += "CNP.D_E_L_E_T_ = ' '"

				cQuery := ChangeQuery(cQuery)
				cAliasQr := GetNextAlias()
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQr,.F.,.T.)

				TCSetField(cAliasQr,"CNQ_VALOR" ,"N",aCNQValor[1],aCNQValor[2])

				If !(cAliasQr)->(Eof())
					nGCTDesc += (cAliasQr)->(CNQ_VALOR)//Soma descontos
				EndIf

				(cAliasQr)->(dbCloseArea())

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//?Soma multas nao aplicadas na medicao ?
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cQuery := "SELECT SUM(CNR.CNR_VALOR) AS CNR_VALOR "
				cQuery += "FROM "+RetSQLName("CNR")+" CNR WHERE "
				cQuery += "CNR.CNR_FILIAL = '"+cFilCNR+"' AND "
				cQuery += "CNR.CNR_NUMMED = '"+aMedicao[nx,3]+"' AND "
				cQuery += "CNR.CNR_FLGPED = '2' AND "
				cQuery += "CNR.CNR_TIPO   = '1' AND "
				cQuery += "CNR.D_E_L_E_T_ = ' '"

				cQuery := ChangeQuery(cQuery)
				cAliasQr := GetNextAlias()
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQr,.F.,.T.)

				TCSetField(cAliasQr,"CNR_VALOR" ,"N",aCNRValor[1],aCNRValor[2])

				If !(cAliasQr)->(Eof())
					nGCTMult += (cAliasQr)->(CNR_VALOR)//Soma multas
				EndIf

				(cAliasQr)->(dbCloseArea())

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//?Soma bonificacoes nao aplicadas na medicao ?
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cQuery := "SELECT SUM(CNR.CNR_VALOR) AS CNR_VALOR "
				cQuery += "FROM "+RetSQLName("CNR")+" CNR WHERE "
				cQuery += "CNR.CNR_FILIAL = '"+cFilCNR+"' AND "
				cQuery += "CNR.CNR_NUMMED = '"+aMedicao[nx,3]+"' AND "
				cQuery += "CNR.CNR_FLGPED = '2' AND "
				cQuery += "CNR.CNR_TIPO   = '2' AND "
				cQuery += "CNR.D_E_L_E_T_ = ' '"

				cQuery := ChangeQuery(cQuery)
				cAliasQr := GetNextAlias()
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQr,.F.,.T.)

				TCSetField(cAliasQr,"CNR_VALOR" ,"N",aCNRValor[1],aCNRValor[2])

				If !(cAliasQr)->(Eof())
					nGCTBoni += (cAliasQr)->(CNR_VALOR)//Soma bonificoes
				EndIf
				(cAliasQr)->(dbCloseArea())

			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//?Armazena medicao para evitar repeticao ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cMedicao := aMedicao[nx,3]
		Next nX
	Else
		lIncTot := .F.
	EndIf

	If !lIncTot
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//?Carrega os totais do array aMedicao    ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aTot := aMedicao[len(aMedicao),1]
		nGCTRet  := aTot[1,2]
		nGCTDesc := aTot[2,2]
		nGCTMult := aTot[3,2]
		nGCTBoni := aTot[4,2]
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//?Gera os totais na primeira execucao    ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aTot[1,1] := aTot[1,2] := nGCTRet
		aTot[2,1] := aTot[2,2] := nGCTDesc
		aTot[3,1] := aTot[3,2] := nGCTMult
		aTot[4,1] := aTot[4,2] := nGCTBoni
	EndIf

	If lGCTRet .AND. nGCTRet > 0
		If !lTitFim
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Proporcionaliza o valor da retencao de acordo com a parcela ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			nValor := Round(nGCTRet*nProp,TamSX3("E1_RETCNTR")[2])

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Atualiza saldos da retencao ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			If nValor > aTot[1,1]
				nValor    := aTot[1,1]
				aTot[1,1] := 0
			Else
				aTot[1,1] -= nValor
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Carrega o saldo restante    ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			nValor    := aTot[1,1]
			aTot[1,1] := 0
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//?Atualiza valores do titulo a receber ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SE1->E1_RETCNTR := nValor

		SE1->E1_VALOR	-= SE1->E1_RETCNTR
		SE1->E1_SALDO	-= SE1->E1_RETCNTR
		SE1->E1_VLCRUZ  -= xMoeda(SE1->E1_RETCNTR,SE1->E1_MOEDA,1,SE1->E1_EMISSAO)
	EndIf
	If nGCTDesc > 0
		If !lTitFim
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Proporcionaliza o valor do desconto de acordo com a parcela ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			nValor := Round(nGCTDesc*nProp,TamSX3("E1_MDDESC")[2])

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Atualiza saldos de desconto ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			If nValor > aTot[2,1]
				nValor    := aTot[2,1]
				aTot[2,1] := 0
			Else
				aTot[2,1] -= nValor
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Carrega o saldo restante    ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			nValor    := aTot[2,1]
			aTot[2,1] := 0
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//?Atualiza valores do titulo a receber ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SE1->E1_MDDESC := nValor

		SE1->E1_VALOR	-= SE1->E1_MDDESC
		SE1->E1_SALDO	-= SE1->E1_MDDESC
		SE1->E1_VLCRUZ  -= xMoeda(SE1->E1_MDDESC,SE1->E1_MOEDA,1,SE1->E1_EMISSAO)
	EndIf
	If nGCTMult > 0
		If !lTitFim
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//?Proporcionaliza o valor da multa de acordo com a parcela ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nValor := Round(nGCTMult*nProp,TamSX3("E1_MDMULT")[2])

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//?Atualiza saldos da multa ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nValor > aTot[3,1]
				nValor    := aTot[3,1]
				aTot[3,1] := 0
			Else
				aTot[3,1] -= nValor
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Carrega o saldo restante    ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			nValor    := aTot[3,1]
			aTot[3,1] := 0
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//?Atualiza valores do titulo a receber ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SE1->E1_MDMULT := nValor

		SE1->E1_VALOR	+= SE1->E1_MDMULT
		SE1->E1_SALDO	+= SE1->E1_MDMULT
		SE1->E1_VLCRUZ  += xMoeda(SE1->E1_MDMULT,SE1->E1_MOEDA,1,SE1->E1_EMISSAO)
	EndIf
	If nGCTBoni > 0
		If !lTitFim
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//?Proporcionaliza o valor da bonificacao de acordo com a parcela ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nValor := Round(nGCTBoni*nProp,TamSX3("E1_MDBONI")[2])

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//?Atualiza saldos da bonificacao ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nValor > aTot[4,1]
				nValor    := aTot[4,1]
				aTot[4,1] := 0
			Else
				aTot[4,1] -= nValor
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Carrega o saldo restante    ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			nValor    := aTot[4,1]
			aTot[4,1] := 0
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//?Atualiza valores do titulo a receber ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SE1->E1_MDBONI := nValor

		SE1->E1_VALOR	-= SE1->E1_MDBONI
		SE1->E1_SALDO	-= SE1->E1_MDBONI
		SE1->E1_VLCRUZ  -= xMoeda(SE1->E1_MDBONI,SE1->E1_MOEDA,1,SE1->E1_EMISSAO)
	EndIf

	If lIncTot
		aAdd(aMedicao,{aTot,"","",""})
	Else
		aMedicao[len(aMedicao),1] := aTot
	EndIf
EndIf

RestArea(aAreaSC5)
RestArea(aArea)
Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±?
±±³Funcao    ³CntProcGct?Autor ³Marcelo Custodio       ?Data ?7/03/2007³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±?
±±³Descri‡…o ³Calcula os valores de retencao, desconto e multas no        ³±?
±±?         ³documento de entrada                                        ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±?
±±³Sintaxe   ³A130GctCtr(lExp01,lExp02,lExp03,lExp04,@nExp05,@nExp06,     ³±?
±±³Sintaxe   ?          @nExp07,@nExp08,aExp09)                          ³±?
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±?
±±³Parametros³lExp01 - Informa se calcula retencao                        ³±?
±±?         ³lExp02 - Informa se calcula desconto                        ³±?
±±?         ³lExp03 - Informa se calcula multa                           ³±?
±±?         ³lExp04 - Informa se calcula bonificacao                     ³±?
±±?         ³nExp05 - Retorna total da retencao - Referencia             ³±?
±±?         ³nExp06 - Retorna total do desconto - Referencia             ³±?
±±?         ³nExp07 - Retorna total da multa - Referencia                ³±?
±±?         ³nExp08 - Retorna total da bonificacao - Referencia          ³±?
±±?         ³aExp09 - Armazena os contratos e medicoes processadas na    ³±?
±±?         ?        nota                                               ³±?
±±?         ³lExp10 - Informa se o titulo deve ser gerado bloqueado      ³±?
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Function CntProcGct(lGCTRet,lGCTDesc,lGCTMult,lGCTBoni,nGCTRet,nGCTDesc,nGCTMult,nGCTBoni,aContra)
	Local aAreas   := {SC7->(GetArea()),CN9->(GetArea()),GetArea()}
	Local nLoop    := 0
	Local cFilSC7  := xFilial("SC7")
	Local cFilCTR  := ""
	Local cFilCN9  := ""
	Local cFilCNP  := ""
	Local cFilCND  := xFilial("CND")
	Local cFilCNQ  := xFilial("CNQ")
	Local cFilCNR  := xFilial("CNR")
	Local cQuery   := ""
	Local cAliasQr := ""
	Local bBusca   := {|x| SC7->(C7_CONTRA+C7_CONTREV+C7_PLANILH+C7_MEDICAO) == x[1]+x[2]+x[3]+x[4] }
	Local nPosPedido := GDFieldPos("D1_PEDIDO")
	Local nPosQuant  := GDFieldPos("D1_QUANT")
	Local nPosVlUni  := GDFieldPos("D1_VUNIT")
	Local nPosItem   := GDFieldPos("D1_ITEMPC")
	Local nPosTotal  := GDFieldPos("D1_TOTAL")
	Local nPosDesc   := GDFieldPos("D1_VALDESC")
    Local lGCTAdia	 := GetNewPar("MV_CNADIA", "N") == "S"
	Local lM103VRet  := ExistBlock("M103VRET")
	Local nM103VRet  := 0
    Local nAdiant    := 0
	Local aCNQValor := TamSX3("CNQ_VALOR")
	Local aCNRValor := TamSX3("CNR_VALOR")
	
    Default lGCTRet  := .T.
	Default lGCTDesc := .T.
	Default lGCTMult := .T.
	Default lGCTBoni := .T.	
    Default nGCTRet  := 0
    Default nGCTDesc := 0
    Default nGCTMult := 0
    Default nGCTBoni := 0
    Default aContra  := {}
	
	//Inicializa variaveis de totalizacao
	nGCTRet  := 0
	nGCTDesc := 0
	nGCTMult := 0
	
	//Verifica se existe controle de retencao, desconto ou multa de contrato no titulo financeiro
	If lGCTRet .OR. lGCTDesc .OR. lGCTMult .Or. lGCTBoni
		SC7->(dbSetOrder(1))
		CN9->(dbSetOrder(1))
		
		For nLoop := 1 to Len( aCols )
			If !ATail( aCols[ nLoop ] )
				If SC7->( MsSeek( cFilSC7 + aCols[ nLoop, nPosPedido ] + aCols[ nLoop, nPosItem ] ) .And.  !Empty( SC7->C7_CONTRA ))
					nPerc := CNTXPerc(SC7->C7_NUM , aCols[ nLoop,nPosQuant] * aCols [nLoop, nPosVlUni])

					cFilCTR := CNTBuscFil(cFilCND,SC7->C7_MEDICAO)
                    cFilCN9 := xFilial("CN9",cFilCTR)
                    cFilCNP := xFilial("CNP",cFilCTR)
					
                    If !lGCTAdia .Or. lGCTRet //-- Calcula valor do adiantamento apenas quando o desconto não foi realizado na geração pedido
                        nAdiant := CalcAdiant(SC7->C7_CONTRA, SC7->C7_CONTREV, SC7->C7_MEDICAO, SC7->C7_PLANILH, SC7->C7_ITEMED, aCols[nLoop,nPosTotal]-aCols[nLoop,nPosDesc])
                    EndIf

					If lGCTRet//Verifica controle de retencao
						If CN9->(dbSeek(cFilCN9+SC7->C7_CONTRA) .And. (CN9_FLGCAU = '1' .And. CN9_TPCAUC = '2'))							
							If !lM103VRet
								nGCTRet += ((aCols[nLoop,nPosTotal]-aCols[nLoop,nPosDesc]-nAdiant) * CN9->CN9_MINCAU ) / 100
							Else
								If ValType( nM103VRet := ExecBlock("M103VRET",.F.,.F.,{SC7->C7_CONTRA,SC7->C7_CONTREV,SC7->C7_PLANILH})) == "N"
									nGCTRet += ((aCols[nLoop,nPosTotal]-aCols[nLoop,nPosDesc]-nAdiant) * nM103VRet ) / 100
								EndIf
							EndIf
						EndIf
					EndIf
					
					//Verifica controle de desconto/multa
					If aScan(aContra, bBusca) == 0						
						aAdd(aContra,{SC7->C7_CONTRA,SC7->C7_CONTREV,SC7->C7_PLANILH,SC7->C7_MEDICAO})
					EndIf
										
					cAliasQr := GetNextAlias()
					
					//Soma descontos nao aplicados na medicao					
					cQuery := "SELECT SUM(CNQ.CNQ_VALOR) AS CNQ_VALOR "
					cQuery += "FROM "+RetSQLName("CNQ")+" CNQ, "+RetSQLName("CNP")+" CNP WHERE "
					cQuery += "CNQ.CNQ_FILIAL = '"+cFilCNQ+"' AND "
					cQuery += "CNP.CNP_FILIAL = '"+cFilCNP+"' AND "
					cQuery += "CNQ.CNQ_TPDESC = CNP.CNP_CODIGO AND "
					cQuery += "CNQ.CNQ_CONTRA = '"+SC7->C7_CONTRA+"' AND "
					cQuery += "CNQ.CNQ_NUMMED = '"+SC7->C7_MEDICAO+"' AND "
					cQuery += "CNP.CNP_FLGPED = '2' AND "
					cQuery += "CNQ.D_E_L_E_T_ = ' ' AND "
					cQuery += "CNP.D_E_L_E_T_ = ' '"

					cQuery := ChangeQuery(cQuery)
					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQr,.F.,.T.)

					TCSetField(cAliasQr,"CNQ_VALOR" ,"N",aCNQValor[1],aCNQValor[2])

					If !(cAliasQr)->(Eof())
						nGCTDesc += (cAliasQr)->(CNQ_VALOR) * nPerc
					EndIf

					(cAliasQr)->(dbCloseArea())

					//Soma multas nao aplicadas na medicao					
					cQuery := "SELECT SUM(CNR.CNR_VALOR) MULTAS, 0 BONIF "
					cQuery += "FROM "+RetSQLName("CNR")+" CNR WHERE "
					cQuery += "CNR.CNR_FILIAL = '"+cFilCNR+"' AND "
					cQuery += "CNR.CNR_NUMMED = '"+SC7->C7_MEDICAO+"' AND "
					cQuery += "CNR.CNR_FLGPED = '2' AND "
					cQuery += "CNR.CNR_TIPO = '1' AND "
					cQuery += "CNR.D_E_L_E_T_ = ' '"
					
					cQuery += " UNION ALL "
					
					//Soma bonificacoes nao aplicadas na medicao
					cQuery += "SELECT 0 MULTAS, SUM(CNR.CNR_VALOR) BONIF "
					cQuery += "FROM "+RetSQLName("CNR")+" CNR WHERE "
					cQuery += "CNR.CNR_FILIAL = '"+cFilCNR+"' AND "
					cQuery += "CNR.CNR_NUMMED = '"+SC7->C7_MEDICAO+"' AND "
					cQuery += "CNR.CNR_FLGPED = '2' AND "
					cQuery += "CNR.CNR_TIPO = '2' AND "
					cQuery += "CNR.D_E_L_E_T_ = ' '"

					cQuery := ChangeQuery(cQuery)					
					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQr,.F.,.T.)

					TCSetField(cAliasQr,"MULTAS","N",aCNRValor[1],aCNRValor[2])
					TCSetField(cAliasQr,"BONIF" ,"N",aCNRValor[1],aCNRValor[2])

					If !(cAliasQr)->(Eof())
						While ( (cAliasQr)->(!Eof()) )							
							nGCTMult += (cAliasQr)->MULTAS	* nPerc
							nGCTBoni += (cAliasQr)->BONIF	* nPerc							
							(cAliasQr)->(dbSkip())
						EndDo
					EndIf
					(cAliasQr)->(dbCloseArea())
				EndIf
			EndIf
		Next nLoop		
	EndIf

	aEval(aAreas,{|x|RestArea(x), FwFreeArray(x)})	
Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ³GravaGCT  ºAutor  ³Aline Sebrian       ?Data ? 06/12/10   º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para estornar a quantidade ainda não entregue ao    º±?
±±?         ?  saldo do contrato, planilha e cronograma durante a elimi-º±?
±±?         ?nação de Resíduos no Pedido de Compras.				 	  º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Function GravaGCT(nTotItem,nQtdItem,nMoeda,nTxMoeda,dEmissao,lResiduo)

Local cQuery		:= ""
Local cCronog		:= ""
Local cParcel		:= ""
Local cFilCtr		:= cFilAnt
Local cAliasCNT		:= ""
Local lMedeve		:= .F.
Local lContinua		:= .T.
Local lFisico		:= .F.
Local lFixo			:= .T.
Local lValor		:= .T.
Local lRecorrente	:= .T.
Local lVldVige		:= GetNewPar("MV_CNFVIGE","N") == "N"
Local lSeekCND		:= .F.
Local dDtFim		:= dDataBase
Local nQtItCNE		:= 0
Local nVlTot		:= TamSX3("CND_VLTOT")[2]
Local cQryRes		:= ""

//-- Posiciona na Medição CND
DbSelectArea("CND")

//-- Para medições geradas pela CNTA121 ou CNTA120, o índice de busca é diferente
If IsNewMed(SC7->C7_CONTRA, SC7->C7_CONTREV, SC7->C7_MEDICAO)
	CND->(dbSetOrder(7)) //-- CND_FILIAL, CND_CONTRA, CND_REVISA, CND_NUMMED
	lSeekCND := MsSeek(xFilial("CND")+SC7->C7_CONTRA+SC7->C7_CONTREV+SC7->C7_MEDICAO)	
Else
	CND->(dbSetOrder(1)) //-- CND_FILIAL, CND_CONTRA, CND_REVISA, CND_NUMERO, CND_NUMMED
	lSeekCND := MsSeek(xFilial("CND")+SC7->C7_CONTRA+SC7->C7_CONTREV+SC7->C7_PLANILH+SC7->C7_MEDICAO)
EndIf

If lSeekCND
	dDtFim := CND->CND_DTFIM
	cFilCTR := CND->CND_FILCTR

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona no contrato CN9       ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("CN9")
	CN9->(DbSetOrder(1))
	If CN9->(MsSeek(xFilial("CN9",cFilCTR)+CND->CND_CONTRA+CND->CND_REVISA))
		If lVldVige .And.((CN9->CN9_SITUAC <> DEF_SVIGE) .Or. (CN9->CN9_DTINIC > dDataBase .Or. CN9->CN9_DTFIM < dDataBase))  //Contrato finalizado ou fora do período da vigência
			lContinua := .F.
		EndIf

		If lContinua .And. (CN9->CN9_SITUAC <> DEF_SVIGE)
			lContinua := .F.
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		//³Verifica se o contrato ?fixo  ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		dbSelectArea("CNA")
		CNA->(dbSetOrder(1))
		CNA->(MsSeek(xFilial("CNA",cFilCTR)+SC7->C7_CONTRA+SC7->C7_CONTREV+SC7->C7_PLANILH))
		dbSelectArea("CN1")
		CN1->(dbSetOrder(1))
  		If CN1->(MsSeek(xFilial("CN1",cFilCTR)+CN9->CN9_TPCTO))
			lFixo   := CN300RetSt("FIXO",0,SC7->C7_PLANILH)
			lValor  := CN300RetSt("PREVFINANC",0,SC7->C7_PLANILH)
			lMedeve := CN300RetSt("MEDEVE",0,SC7->C7_PLANILH)
			lFisico := Cn300RetSt("FISICO",0,SC7->C7_PLANILH)
			lRecorrente := Cn300RetSt("RECORRENTE",0,SC7->C7_PLANILH)
			lSemiFix:= Cn300RetSt("SEMIFIXO",0,SC7->C7_PLANILH)
		EndIf

		If !lRecorrente
			RecLock("CN9",.F.)
				If lFixo .Or. lValor
					CN9->CN9_SALDO += xMoeda(nTotItem,nMoeda,CN9->CN9_MOEDA,dDtFim,nVlTot,,nTxMoeda)
				Else
					CN9->CN9_VLATU -= xMoeda(nTotItem,nMoeda,CN9->CN9_MOEDA,dDtFim,nVlTot,,nTxMoeda)//Atualiza valor do contrato
					If Empty(CN9->CN9_REVISA)//Se contrato original atualiza valor inicial
                        CN9->CN9_VLINI -= xMoeda(nTotItem,nMoeda,CN9->CN9_MOEDA,dDtFim,nVlTot,,nTxMoeda)//Atualiza valor do contrato
					EndIf
				EndIf
			CN9->(MsUnlock())
		Endif

	 	If !Empty(CND->CND_RETCAC)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Verifica se existe retencao para a medicao e se ?
			//?a mesma se encontra baixada                     ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			cQuery := "SELECT COUNT(*) AS RETQTD "
			cQuery += "  FROM "+RetSQLName("CNT")+" CNT"
			cQuery += " WHERE CNT.CNT_FILIAL = '"+xFilial("CNT",cFilCTR)+"'"
			cQuery += "   AND CNT.CNT_CONTRA = '"+CND->CND_CONTRA+"'"
			cQuery += "   AND CNT.CNT_NUMMED = '"+CND->CND_NUMMED+"'"
			cQuery += "   AND CNT.CNT_VLBX   > 0"
			cQuery += "   AND D_E_L_E_T_ = ' '"

			cAliasCNT := GetNextAlias()
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCNT,.F.,.T.)

			lContinua := ((cAliasCNT)->RETQTD == 0)

			(cAliasCNT)->(dbCloseArea())
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		//?Atualiza saldo da planilha                      ?
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		If lContinua .And. lValor .And. !lRecorrente
			dbSelectArea("CNA")
			CNA->(dbSetOrder(1))
			If CNA->(MsSeek(xFilial("CNA", cFilCTR)+SC7->C7_CONTRA+SC7->C7_CONTREV+SC7->C7_PLANILH))
				RecLock("CNA",.F.)
					CNA->CNA_SALDO += xMoeda(nTotItem,nMoeda,CN9->CN9_MOEDA,dDtFim,nVlTot,,nTxMoeda)
				MsUnlock()

				If !lMedeve .And. !Empty(CNA->CNA_CRONOG)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					//?Atualiza saldo do cronograma quando nao houver  ?
					//?medicao eventual                                ?
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
					cCronog := CNA->CNA_CRONOG
					dbSelectArea("CNF")

					If !Empty(CND->CND_PARCEL)
						CNF->(dbSetorder(3))
						CNF->(MsSeek(xFilial("CNF",cFilCTR)+CND->CND_CONTRA+CND->CND_REVISA+cCronog+CND->CND_PARCEL))
					Else
						CNF->(dbSetorder(2))
						CNF->(MsSeek(xFilial("CNF",cFilCTR)+CND->CND_CONTRA+CND->CND_REVISA+cCronog+CND->CND_COMPET))
					EndIf
                    
                    If CNF->(Found())
                        cParcel := CNF->CNF_PARCEL

                        RecLock("CNF")
                            If CNF->CNF_VLREAL > 0
                                CNF->CNF_VLREAL -= xMoeda(nTotItem,nMoeda,CN9->CN9_MOEDA,dDtFim,nVlTot,,nTxMoeda)
                            EndIf
                            CNF->CNF_SALDO  += xMoeda(nTotItem,nMoeda,CN9->CN9_MOEDA,dDtFim,nVlTot,,nTxMoeda)
                        CNF->(MsUnlock())

                        If (GetNewPar( "MV_CNPROVI" ,  "S" ) == "S")
                            IncProc( STR0021 )//"Processando títulos provisórios"

                            CN100ETit(CND->CND_CONTRA,CND->CND_REVISA,cCronog,CNF->CNF_PARCEL)
                            If CNF->CNF_SALDO > 0
                                CN100CTit(CND->CND_CONTRA,CND->CND_REVISA,cCronog,CNF->CNF_PARCEL,CNF->CNF_SALDO)
                            EndIf
                        EndIf
                    EndIf
				EndIf

			EndIf
		EndIf

		If lContinua  .And. !lRecorrente
            dbSelectArea("CNE")
            dbSetOrder(1)
            If MsSeek(xFilial("CNE")+SC7->C7_CONTRA+SC7->C7_CONTREV+SC7->C7_PLANILH+SC7->C7_MEDICAO+SC7->C7_ITEMED)

                nQtItCNE	:= CNE->CNE_QUANT

                RecLock("CNE",.F.)
                    CNE->CNE_QUANT  := nQtdItem
                    CNE->CNE_PERC   := (CNE->CNE_QUANT*100)/CNE->CNE_QTDSOL
                    CNE->CNE_VLUNIT := SC7->C7_PRECO
                    CNE->CNE_VLTOT  := (CNE->CNE_QUANT * CNE->CNE_VLUNIT)
                    CNE->CNE_RESID  := "S"
                MsUnlock()

                If lFisico
                    dbSelectArea("CNS")
                    dbSetOrder(1)
                    If MsSeek(xFilial("CNS",cFilCTR)+CND->CND_CONTRA+CND->CND_REVISA+cCronog+cParcel+CNE->CNE_ITEM)
                        RecLock("CNS",.F.)
                            CNS->CNS_RLZQTD := iIf(nQtdItem==0,(CNS->CNS_RLZQTD-nQtItCNE),nQtdItem)
                            CNS->CNS_SLDQTD := (CNS->CNS_PRVQTD-CNS->CNS_RLZQTD)
                        MsUnlock()
                    EndIf
                EndIf
            EndIf

            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
            //?Atualiza saldo dos itens da planilha            ?
            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
            dbSelectArea("CNB")
            dbSetOrder(1)
            If MsSeek(xFilial("CNB",cFilCTR)+SC7->C7_CONTRA+SC7->C7_CONTREV+SC7->C7_PLANILH+SC7->C7_ITEMED)

                cQryRes := GetNextAlias()

                BeginSQL Alias cQryRes
                    SELECT COUNT(*) AS RETQTD FROM 	%Table:CND% CND
                    WHERE CND.%NotDel% 
                        AND CND.CND_FILIAL = %xFilial:CND% 
                        AND CND.CND_CONTRA = %Exp:SC7->C7_CONTRA% 
                EndSQL	
                    
                RecLock("CNB",.F.)
                    If (cQryRes)->RETQTD > 1 //Se houver medicoes ja realizada, deve considerar o saldo ja medido no momento da Eliminacao de Residuo 
                        If CNB->CNB_QTDMED - nQtdItem > 0
                            CNB->CNB_QTDMED -= nQtItCNE - nQtdItem 
                            CNB->CNB_SLDMED += nQtItCNE - nQtdItem 
                        EndIf
                    else
                        CNB->CNB_QTDMED := nQtdItem
                        If SC7->C7_QUJE > 0 
                            CNB->CNB_SLDMED += IIf(lSemifix,0,(nQtItCNE - nQtdItem) )// CNB->CNB_QTDMED)  
                        else
                            CNB->CNB_SLDMED += nQtItCNE
                        EndIf
                    EndIf
                MsUnlock()

                (cQryRes)->(dbCloseArea())
            EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			//?Atualiza saldo da planilha de Medicao do Contrato ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
			dbSelectArea("CXN")
			dbSetOrder(1) //CXN_FILIAL+CXN_CONTRA+CXN_REVISA+CXN_NUMMED+CXN_NUMPLA+CXN_PARCEL
			If  MsSeek(xFilial("CXN",cFilCTR)+CND->CND_CONTRA+CND->CND_REVISA+SC7->C7_MEDICAO+SC7->C7_PLANILH+cParcel)
				RecLock("CXN",.F.)
				CXN->CXN_VLLIQD -= xMoeda(nTotItem,nMoeda,CN9->CN9_MOEDA,dDtFim,nVlTot,,nTxMoeda)
				CXN->CXN_VLTOT -= xMoeda(nTotItem,nMoeda,CN9->CN9_MOEDA,dDtFim,nVlTot,,nTxMoeda)					
				MsUnlock()
			EndIf
			
			RecLock("CND",.F.)
				If CND->CND_VLTOT > 0 
					CND->CND_VLTOT  -= xMoeda(nTotItem,nMoeda,CN9->CN9_MOEDA,dDtFim,nVlTot,,nTxMoeda)//Atualiza valor da medicao... 
				EndIf
				CND->CND_RESID  := "S"
			MsUnlock()
			
		Endif
	Endif
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ³GCTRateio ºAutor  ? TOTVS             ?Data ? 23/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para montar a tela do rateio                        º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Function GCTRateio(oGetDados,aRatGCT,nOpc,aBusca,aAuxRat,lAtuCNZ)
Local oDlgRateio	:= nil
Local oGetRateio	:= nil
Local oPercRat		:= nil

Local nI			:= 0
Local nCtb			:= 0
Local nLin			:= oGetDados:nAt
Local nPItem		:= 0	

Local nPItPlan		:= 0
Local nPPerc		:= 0
Local nOpcX			:= 0

Local aButtons		:= {}
Local aLocalCols	:= {}
Local aHeadCNZ		:= GCTHeadCNZ()
Local aAlter		:= {"CNZ_PERC","CNZ_CC","CNZ_CONTA","CNZ_ITEMCT","CNZ_CLVL"}
Local aVarCab		:= {}
Local aVarItem		:= {}
Local aRetAutRat	:= {}
Local aCTBEnt	  	:= CTBEntArr()
Local aCNETab		:= {aClone(aHeader),aClone(oGetDados:Acols[nLin])}

Local bExecCancel	:= {||oDlgRateio:End()}
Local bFieldOk		:= {|lRet|	lRet := ValRateioDados(oGetRateio:aCols,oGetRateio:nAt,nPPerc,@nPercRat,@nPercaRat,oPercRat,oPercARat),lRet }
Local bLinhaOk		:= {|lRet| 	lRet := ValidLineRat(oGetRateio,,aCNETab),lRet}
Local bTudoOk		:= {|lRet|	lRet := ValidTudoRat(oGetRateio,nOpc,aCNETab),lRet}
Local bDelOk		:= {||	SubPercRat(oGetRateio,nPPerc,@nPercRat,@nPercaRat,oPercRat,oPercARat), .t.}

Local cContrato		:= aBusca[1]
Local cRevisao		:= aBusca[2]
Local cPlanMed		:= aBusca[3]
Local cProg      	:= FunName()
Local cAlias    	:= Iif(cProg == "CNTA120" , "CND","CNA")
Local cFilCtr		:= cFilAnt
Local cCampoCR		:= ""
Local cCampoDB		:= ""
Local cCampo        := ""

Local nPosConta		:= 0
Local nPosCC		:= 0
Local nPosItCnt		:= 0
Local nPosClCnt		:= 0
Local nPosEnCR5		:= 0
Local nPosEnDB5		:= 0
Local nPosEnCR6		:= 0
Local nPosEnDB6		:= 0
Local nPosEnCR7		:= 0
Local nPosEnDB7		:= 0
Local nPosEnCR8		:= 0
Local nPosEnDB8		:= 0
Local nPosEnCR9		:= 0
Local nPosEnDB9		:= 0

Local lCNZAutRat	:= ExistBlock("CNZAUTRAT")
Local lAltera		:= .T.
Local lTemCntCC		:= .F.

PRIVATE nPercRat	:= 0
PRIVATE nPercARat	:= 100

Default aAuxRat  	:= {}
Default lAtuCNZ	:= .F. // Atualizar a CNZ mesmo quando nao clicar no botao Rateio e verificar itens novos

aadd(aButtons,{'AUTOM',{|| AdmRatExt(aHeadCNZ,oGetRateio:aCols,{ |x,y,z,w| GCTCarCC(x,y,@z,w) }) },STR0062,OemToAnsi(STR0063)}) //"Rateio" // 'Escolha de Rateio Pre-Configurado'

If cProg == "CNTA120"
	cFilCtr := If(nOpc == 3,M->CND_FILCTR,CND->CND_FILCTR)
EndIf

If Len(aRatGCT)==0
	aRatGCT := GetRatInBase(oGetDados,cAlias,,cFilCtr)
Elseif lAtuCNZ
	aRatGCT := GetRatInBase(oGetDados,cAlias,aRatGCT,cFilCtr)
Endif

GetVarRateio(aVarCab,aVarItem)

nPPerc   := aScan(aHeadCNZ,{|x| alltrim(x[2]) == "CNZ_PERC"})

nPItem	 := aScan(oGetDados:aHeader,{ |x| alltrim(x[2]) == aVarItem[ITEM] })
nPItPlan := aScan(aRatGCT,{|x| alltrim(x[1]) + alltrim(x[2]) + alltrim(x[3]) + alltrim(x[4]) == alltrim(cContrato) + alltrim(cRevisao) + alltrim(cPlanMed) + alltrim(oGetDados:aCols[nLin,nPItem]) })

If nPItPlan > 0
	For nI := 1 to len(aRatGCT[nPItPlan][5])
		nPercRat += aRatGCT[nPItPlan][5][nI,nPPerc]
	Next nI

	nPercARat -= nPercRat
	aLocalCols := aClone(aRatGCT[nPItPlan][5])
Else
	If lCNZAutRat .And. Len(aRatGCT) > 0
		If Len(aRatGCT[1]) >= 5
			aLocalCols := aClone(aRatGCT[1][5])
		EndIf
	EndIf
Endif

// Ponto de entrada para preenchimento automatico de campos no rateio
If lCNZAutRat
	aRetAutRat := ExecBlock("CNZAUTRAT",.F.,.F.,{aHeadCNZ,aLocalCols,nOpc})
	If ValType(aRetAutRat) == "A"
		aLocalCols := aClone(aRetAutRat)
	EndIf
EndIf

dbSelectArea("SX3")
SX3->(dbSetOrder(1))
If nOpc == 2 .Or. nOpc == 5
	lAltera := .F.
	aAlter	 := {}
Else
	//- Verifica campos do usuario
	SX3->(dbSeek("CNZ"))
	While !SX3->(Eof()) .and. X3_ARQUIVO == "CNZ"
	cCampo := SX3->X3_CAMPO
		If GetSX3Cache(cCampo , "X3_PROPRI" ) == "U" .And. GetSX3Cache( cCampo, "X3_VISUAL" ) != "V"
			Aadd( aAlter, cCampo )
		Endif
		SX3->(dbSkip())
	Enddo

	//- Verifica Entidades adicionais
	SX3->(DbSetOrder(2))
	For nCtb := 1 To Len(aCTBEnt)
		cCampoCR := "CNZ_EC"+aCTBEnt[nCtb]+"CR"
		cCampoDB := "CNZ_EC"+aCTBEnt[nCtb]+"DB"
		If CNZ->(FieldPos(cCampoCR)) > 0
			If SX3->(DbSeek(cCampoCR)) .And. GetSX3Cache( cCampoCR, "X3_VISUAL" ) != "V"
				Aadd(aAlter,cCampoCR)
			EndIf
			If SX3->(DbSeek(cCampoDB)) .And. GetSX3Cache( cCampoCR, "X3_VISUAL" )  != "V"
				Aadd(aAlter,cCampoDB)
			EndIf
		EndIf
	Next nCtb
Endif

MsSeek(cAlias)

If Len(oGetDados:aHeader) > 0	
	nPosConta	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_CONTA"})
	nPosCC		:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_CC"})
	nPosItCnt	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_ITEMCT"})
	nPosClCnt	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_CLVL"})
		
	If Len(aCTBEnt) > 0
		nPosEnCR5	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_EC05CR"})
		nPosEnDB5	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_EC05DB"})
		nPosEnCR6	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_EC06CR"})
		nPosEnDB6	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_EC06DB"})
		nPosEnCR7	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_EC07CR"})
		nPosEnDB7	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_EC07DB"})
		nPosEnCR8	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_EC08CR"})
		nPosEnDB8	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_EC08DB"})
		nPosEnCR9	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_EC09CR"})
		nPosEnDB9	:= Ascan(oGetDados:aHeader,{|x| AllTrim(x[2])=="CNE_EC09DB"})
	EndIf
EndIf

If IsInCallStack('cn130manut') .And. Len(oGetDados:aCols) > 0 .And. (INCLUI .Or. ALTERA) // Verifica se a rotina foi chamada no cadastro de medicoes, se ha itens preenchidos e se é alteração ou inclusão

	If ( nPosConta > 0 			.And. !Empty(oGetDados:aCols[nLin,nPosConta])	);
		.Or. ( nPosCC > 0 		.And. !Empty(oGetDados:aCols[nLin,nPosCC]) 		);
		.Or. ( nPosItCnt > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosItCnt])	);
		.Or. ( nPosClCnt > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosClCnt]) 	);
		.Or. ( nPosEnCR5 > 0    .And. !Empty(oGetDados:aCols[nLin,nPosEnCR5])	);
		.Or. ( nPosEnDB5 > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosEnDB5])	);
		.Or. ( nPosEnCR6 > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosEnCR6])	);
		.Or. ( nPosEnDB6 > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosEnDB6])	);
		.Or. ( nPosEnCR7 > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosEnCR7])	);
		.Or. ( nPosEnDB7 > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosEnDB7])	);
		.Or. ( nPosEnCR8 > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosEnCR8])	);
		.Or. ( nPosEnDB8 > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosEnDB8])	);
		.Or. ( nPosEnCR9 > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosEnCR9])	);
		.Or. ( nPosEnDB9 > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosEnDB9])	)

		lTemCntCC := .T.
	EndIf

	If lTemCntCC // Verifica se ha valores de entidades contábeis preenchidos para utilizar o rateio
		If MsgYesNo(STR0055) // "Há valores de entidades contábeis preenchidos, deseja apagar os valores para utilizar o rateio?"                                                                                                                                                                                                                                                                                                                                                                                                                  
			lAtuCNZ := .F.
		Else
			lAtuCNZ := .T. // Nao mostra tela de rateio se nao limpar os campos
		EndIf
	EndIf
EndIf

If !lAtuCNZ

	DEFINE MSDIALOG oDlgRateio FROM 100,100 TO 370,600 TITLE STR0042 Of oMainWnd PIXEL //"Rateio por Centro de Custo"

		@ 018,003 SAY RetTitle(aVarCab[CONTRATO])  		OF oDlgRateio PIXEL SIZE 30,09
		@ 018,035 SAY ALLTRIM(M->&(aVarCab[CONTRATO])) 	OF oDlgRateio PIXEL SIZE 50,09

		@ 018,090 SAY STR0043								OF oDlgRateio PIXEL SIZE 25,09 //"Revisao"
		@ 018,115 SAY Alltrim(M->&(aVarCab[REVISAO]))		OF oDlgRateio PIXEL SIZE 18,09

		@ 018,138 SAY STR0044  								OF oDlgRateio PIXEL SIZE 18,09 //"Item"
		@ 018,156 SAY oGetDados:aCols[nLin][nPItem]  		OF oDlgRateio PIXEL SIZE 25,09

		oGetRateio 	:= MsNewGetDados():New(030,005,105,245,IIF(lAltera,GD_INSERT+GD_UPDATE+GD_DELETE,0),"AllwaysTrue","AllwaysTrue","+CNZ_ITEM",aAlter,,999,/*fieldok*/,/*superdel*/,/*delok*/,oDlgRateio,aHeadCNZ,aLocalCols)

		oGetRateio:bFieldOk	:= bFieldOk
		oGetRateio:bLinhaOk	:= bLinhaOk
		oGetRateio:bDelOk	:= bDelOk
		oGetRateio:lUpdate := .t.

		@ 110,005 Say OemToAnsi("% Rateada: ") FONT oDlgRateio:oFont OF oDlgRateio PIXEL	 // "% Rateada: "
		@ 110,035 Say oPercRat VAR nPercRat Picture PesqPict("CNZ","CNZ_PERC") FONT oDlgRateio:oFont COLOR CLR_HBLUE OF oDlgRateio PIXEL

		@ 110,184 Say OemToAnsi("% A Ratear: ") FONT oDlgRateio:oFont OF oDlgRateio PIXEL	 // "% A Ratear: "
		@ 110,217 Say oPercARat VAR nPercARat Picture PesqPict("CNZ","CNZ_PERC") FONT oDlgRateio:oFont COLOR CLR_HBLUE OF oDlgRateio PIXEL

	ACTIVATE MSDIALOG oDlgRateio CENTERED ON INIT EnchoiceBar(oDlgRateio,{|| Iif(eval(bTudoOk) .And. (INCLUI .Or. ALTERA), nOpcX := 1,nOpcX := 0), Iif(nOpcX == 1,oDlgRateio:End(),Iif(INCLUI .Or. ALTERA, Nil, oDlgRateio:End()))},bExecCancel,,aButtons)

EndIf

If nOpcX == 1
	If Len(oGetDados:aCols) > 0 
		If nPosConta > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosConta])
			oGetDados:aCols[nLin,nPosConta] := ""
		EndIf
		If nPosCC > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosCC])
			oGetDados:aCols[nLin,nPosCC] := ""
		EndIf
		If nPosItCnt > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosItCnt])
			oGetDados:aCols[nLin,nPosItCnt] := ""
		EndIf
		If nPosClCnt > 0 	.And. !Empty(oGetDados:aCols[nLin,nPosClCnt])
			oGetDados:aCols[nLin,nPosClCnt] := ""
		EndIf
	
		////////////////////////////////////////////////////////////////////////////////////////
		// Verifica se existe mais entidades contabeis para limpar o campo caso exista rateio //
		////////////////////////////////////////////////////////////////////////////////////////
		If Len(aCTBEnt) > 0
			If nPosEnCR5 > 0 .And. !Empty(oGetDados:aCols[nLin,nPosEnCR5])
				oGetDados:aCols[nLin,nPosEnCR5] := ""
			EndIf

			If nPosEnDB5 > 0 .And. !Empty(oGetDados:aCols[nLin,nPosEnDB5])
				oGetDados:aCols[nLin,nPosEnDB5] := ""
			EndIf

			If nPosEnCR6 > 0 .And. !Empty(oGetDados:aCols[nLin,nPosEnCR6])
				oGetDados:aCols[nLin,nPosEnCR6] := ""
			EndIf

			If nPosEnDB6 > 0 .And. !Empty(oGetDados:aCols[nLin,nPosEnDB6])
				oGetDados:aCols[nLin,nPosEnDB6] := ""
			EndIf
			
			If nPosEnCR7 > 0 .And. !Empty(oGetDados:aCols[nLin,nPosEnCR7])
				oGetDados:aCols[nLin,nPosEnCR7] := ""
			EndIf

			If nPosEnDB7 > 0 .And. !Empty(oGetDados:aCols[nLin,nPosEnDB7])
				oGetDados:aCols[nLin,nPosEnDB7] := ""
			EndIf

			If nPosEnCR8 > 0 .And. !Empty(oGetDados:aCols[nLin,nPosEnCR8])
				oGetDados:aCols[nLin,nPosEnCR8] := ""
			EndIf

			If nPosEnDB8 > 0 .And. !Empty(oGetDados:aCols[nLin,nPosEnDB8])
				oGetDados:aCols[nLin,nPosEnDB8] := ""
			EndIf

			If nPosEnCR9 > 0 .And. !Empty(oGetDados:aCols[nLin,nPosEnCR9])
				oGetDados:aCols[nLin,nPosEnCR9] := ""
			EndIf

			If nPosEnDB9 > 0 .And. !Empty(oGetDados:aCols[nLin,nPosEnDB9])
				oGetDados:aCols[nLin,nPosEnDB9] := ""
			EndIf
		EndIf

	EndIf
	
	/////////////////////
	// Atualiza objeto //
	/////////////////////
	oGetDados:Refresh()
	
	If nPItPlan > 0
		aRatGCT[nPItPlan,5] := aUpdCols(oGetRateio:aCols)
	Else
		aLocalCols := GetDefaultLine(aHeadCNZ)

		//adicionar o item do plano e um aCols vazio
		aAdd(aRatGCT,	{	alltrim(M->&(aVarCab[CONTRATO])),;
							alltrim(M->&(aVarCab[REVISAO])),;
							alltrim(M->&(aVarCab[PLAN_MED])),;
							alltrim(oGetDados:aCols[nLin,nPItem]),;
							aLocalCols})

		aRatGCT[len(aRatGCT),5] := aUpdCols(oGetRateio:aCols)
	EndIf
	aAuxRat := aClone(aRatGCT)
	lAtvRat := .T. // Ativou o rateio
Endif

FwFreeArray(aCNETab)
FwFreeArray(aAlter)
FwFreeArray(aHeadCNZ)
FwFreeArray(aCTBEnt)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ³GCTHeadCNZºAutor  ? TOTVS             ?Data ? 23/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Cabeçalho da Getdados do arquivo de rateio                 º±?
±±?         ?														 	  º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Function GCTHeadCNZ()
	Local aRetHead	:= {}
	Local cNoFields	:= "CNZ_FILIAL|CNZ_CONTRA|CNZ_CODPLA|CNZ_NUMMED|CNZ_REVISA|CNZ_FORNEC|CNZ_LJFORN|CNZ_CLIENT|CNZ_LOJACL|CNZ_ITCONT|CNZ_VALOR1|CNZ_VALOR2|CNZ_VALOR3|CNZ_VALOR4|CNZ_VALOR5|"

	If _aHeadCNZ == NIL
		
		_aHeadCNZ := {}
		SX3->(dbSetOrder(1))

		SX3->(DBSeek("CNZ"))

		While SX3->(!EOF()) .And. (SX3->X3_ARQUIVO == "CNZ")
			If X3USO(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL .And. !(SX3->X3_CAMPO $ cNoFields)
				AADD(_aHeadCNZ,{ TRIM(x3Titulo()),;
								SX3->X3_CAMPO,;
								SX3->X3_PICTURE,;
								SX3->X3_TAMANHO,;
								SX3->X3_DECIMAL,;
								SX3->X3_VALID,;
								SX3->X3_USADO,;
								SX3->X3_TIPO,;
								SX3->X3_F3,;
								SX3->X3_CONTEXT } )
			EndIf

			SX3->(dbSkip())
		EndDo		
	EndIf
	aRetHead := aClone(_aHeadCNZ)
Return(aRetHead)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ³GetDefaultLineºAutor  ? TOTVS           ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao prepara a linha default da aCols		              º±?
±±?         ?														 	  º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/

Static Function GetDefaultLine(aHeadCNZ)
Local aRetCols	:= {}
Local nI			:= 0
Local nItem 		:= TamSX3("CNZ_ITEM")[1]

aAdd( aRetCols, array( len(aHeadCNZ) + 1 ) )

For nI  := 1 to len(aHeadCNZ)
	If Alltrim(aHeadCNZ[nI,2]) == "CNZ_ITEM"
		aRetCols[len(aRetCols),nI] := strzero(1,nItem)
	Else
		aRetCols[len(aRetCols),nI] := CriaVar(aHeadCNZ[nI,2])
	Endif
Next nI

aRetCols[len(aRetCols),len(aHeadCNZ) + 1] := .f.

Return(aRetCols)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ³aUpdCols ºAutor  ? TOTVS                ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para desconsiderar registros deletados da aCols     º±?
±±?         ?														 	  º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/

Static Function aUpdCols(aCols)
Local aColsUpd	:= {}
Local nI		:= 0

For nI := 1 to len(aCols)
	If !(aCols[nI,len(aCols[nI])])
		aAdd(aColsUpd,aCols[nI])
	Endif
Next nI
Return(aColsUpd)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ³ValRateioDados ºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para validacao dos campos da GetDados do ALIAS CNZ  º±?
±±?         ?														 	  º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Static Function ValRateioDados(aCols,nAt,nPPerc,nPercRat,nPercaRat,oPercRat,oPercARat)
Local nI	:= 0
Local lRet	:= .t.
Local cField:= ""
Local cValid:= ""

Do Case
	Case Alltrim(ReadVar()) == "M->CNZ_PERC"
		If &(ReadVar()) <= 100
			nPercRat  := 0
			nPercARat := 100

			For nI := 1 to len(aCols)
				If nAt <> nI
					If !(aCols[nI,len(aCols[nI])])
						nPercRat += aCols[nI,nPPerc]
					Endif
				Endif
			Next nI

			nPercRat += &(ReadVar())

			If nPercRat > 100
				lRet := .f.
			Else
				nPercARat -= nPercRat
			Endif

			oPercRat:Refresh()
			oPercARat:Refresh()
		Endif
	Otherwise
		SX3->(DbSetOrder(2)) //ordena pelo nome do campo
		cField := SubStr( ReadVar(), 4 )
		If SX3->( DbSeek( cField ) )
			cValid :=  GetSX3Cache( cField, "X3_VALID" )
			If !Empty( cValid  )
				lRet := &( cValid )
			Endif
				cValid := GetSX3Cache( cField, "X3_VLDUSER" )
			If lRet .and. !Empty( cValid )
				lRet := &( cValid )
			Endif
		Endif
End Case

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ? ValidLineRat ºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para validacao da linha da GetDados do ALIAS CNZ    º±?
±±?         ?														 	  º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Static Function ValidLineRat(oGetRateio,nLin,aCNETab)
Local lRet			:= .T.
Local nPPer			:= aScan(oGetRateio:aHeader,{|x| alltrim(x[2]) == "CNZ_PERC"})
Local nPCC			:= aScan(oGetRateio:aHeader,{|x| alltrim(x[2]) == "CNZ_CC"})
Local nPConta   	:= aScan(oGetRateio:aHeader,{|x| alltrim(x[2]) == "CNZ_CONTA"})
Local nPItCon   	:= aScan(oGetRateio:aHeader,{|x| alltrim(x[2]) == "CNZ_ITEMCT"})
Local nPClvl   		:= aScan(oGetRateio:aHeader,{|x| alltrim(x[2]) == "CNZ_CLVL"})
Local aHeadCNE		:= {}
Local nPedTitInd	:= 0
Local lPedido 		:= .F.
Local aLinhaCNE		:= {}

Default nLin 	:= oGetRateio:nAt

If !oGetRateio:aCols[nLin,len(oGetRateio:aHeader)+1]
	Do Case
		Case oGetRateio:aCols[nLin,nPPer] == 0
			lRet := .f.
			Aviso(STR0045,STR0046,{STR0047}) //"Percentual Zerado" ## "Defina um valor maior que zero." ##  "OK"
		Case Empty(oGetRateio:aCols[nLin,nPCC])
			lRet := .f.
			Aviso(STR0048,STR0049,{STR0047}) // "Sem C. Custo" ## 	"Não h?informação de centro de custo." ## "OK"
	End Case
EndIf

If lRet
	aHeadCNE	:= aCNETab[1]
	aLinhaCNE	:= aCNETab[2]
	nPedTitInd	:= aScan(aHeadCNE,{|x| ALLTRIM(x[2]) == "CNE_PEDTIT"})
	lPedido		:= aLinhaCNE[nPedTitInd] == "1" 

	lRet:= MedDuplRat(oGetRateio:aHeader,oGetRateio:aCols,nLin,,lPedido)
EndIf

If lRet
	lRet := CtbAmarra(Alltrim(oGetRateio:aCols[nLin,nPConta]),Alltrim(oGetRateio:aCols[nLin,nPCC]),Alltrim(oGetRateio:aCols[nLin,nPItCon]),Alltrim(oGetRateio:aCols[nLin,nPClvl]))
EndIf

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ? ValidTudoRat ºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para validacao da GetDados do ALIAS CNZ             º±?
±±?         ?														 	  º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Static Function ValidTudoRat(oGetRateio,nOpc,aCNETab)
Local lRet			:= .T.
Local lCNZVldRat	:= ExistBlock("CNZVLDRAT")
Local lRetVldRat	:= .T.
Local nI			:= 0
Local nPercTotal	:= 0
Local nPPer			:= aScan(oGetRateio:aHeader,{|x| alltrim(x[2]) == "CNZ_PERC"})
Local nDel			:= 0

For nI := 1 to len(oGetRateio:aCols)
	If !oGetRateio:aCols[nI,len(oGetRateio:aHeader)+1]
		nPercTotal += oGetRateio:aCols[nI,nPPer]
		lRet := ValidLineRat(oGetRateio,nI,aCNETab)

		If !lRet
			Exit
		Endif
	Else
		nDel++
	Endif
Next nI

If nDel == len(oGetRateio:aCols)
	lRet := .t.
Else
	If lRet
		If nPercTotal <> 100
			lRet := .f.
			Aviso(STR0053,STR0054,{STR0047}) // "Percentual" ##"A soma dos percentuais diferem de 100%." ## "OK"
		Endif
	Endif
Endif

// Ponto de entrada para validar as informacoes digitadas no rateio
If lRet .And. lCNZVLDRAT
	lRetVldRat := ExecBlock("CNZVLDRAT",.F.,.F.,{nOpc,oGetDados:aHeader,oGetDados:aCols,oGetDados:nAt,oGetRateio:aHeader,oGetRateio:aCols})
	If ValType(lRetVldRat) == "L"
		lRet := lRetVldRat
	EndIf
EndIf

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ? SubPercRat   ºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para atualizar os controle de percentual ?mretear  º±?
±±?         ?e pércentual rateado                  				 	  º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Static Function SubPercRat(oGetRateio,nPPerc,nPercRat,nPercaRat,oPercRat,oPercARat)
Local nLin	:= oGetRateio:nAt

If !oGetRateio:aCols[nLin,len(oGetRateio:aHeader)+1] //pq no delok do objeto, ele ainda nao atualizou o campo deletado, entao, faz-se a logica inversa
	If nPercRat > 0
		nPercRat 	-= oGetRateio:aCols[nLin,nPPerc]
	Endif
	If nPercARat < 100
		nPercARat   += oGetRateio:aCols[nLin,nPPerc]
	Endif
Else
	If nPercRat < 100
		nPercRat 	+= oGetRateio:aCols[nLin,nPPerc]
	Endif
	If nPercARat > 0
		nPercARat   -= oGetRateio:aCols[nLin,nPPerc]
	Endif
Endif

oPercRat:Refresh()
oPercARat:Refresh()

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ? GetRatInBase ºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para carregar os dados do rateio                    º±?
±±?         ?                                      				 	  º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Function GetRatInBase(oGetDados,cAlias,aRatGCT,cFilCtr)
Local nI		:= 0
Local nItem     := 0//aScan(oGetDados:aHeader,{|x| alltrim(x[2]) == "CNB_ITEM" })
Local aRet		:= {}
Local aVarCab	:= {}
Local aVarItem	:= {}
Local nRecRat	:= 0

Default cAlias  := ""
Default aRatGCT := {}

GetVarRateio(aVarCab,aVarItem,cAlias)

nItem := aScan(oGetDados:aHeader,{|x| alltrim(x[2]) == aVarItem[ITEM] })

For nI := 1 to len(oGetDados:aCols)
	If !(oGetDados:aCols[nI,len(oGetDados:aHeader) + 1])


		aAdd(aRet,{	Alltrim(M->&(aVarCab[CONTRATO])),;
					Alltrim(M->&(aVarCab[REVISAO])),;
					Alltrim(M->&(aVarCab[PLAN_MED])),;
					Alltrim(oGetDados:aCols[nI,nItem]),;
					nil})

		If Len(aRatGCT) > 0
			nRecRat := Ascan(aRatGCT,{|x| x[4] == aRet[Len(aRet),4] .And. x[3] == aRet[Len(aRet),3]})
			If nRecRat > 0
				If aRatGCT[nRecRat,5,1,2] > 0
					aRet[len(aRet),5] := aClone(aRatGCT[nRecRat,5])
				Else
					nRecRat := 0
				Endif
			Endif
		Endif

		If nRecRat = 0
			aRatCols := RetRateio(oGetDados:aCols[nI,nItem],M->&(aVarCab[CONTRATO]),M->&(aVarCab[PLAN_MED]),M->&(aVarCab[REVISAO]),,cFilCtr)
			aRet[len(aRet),5] := aClone(aRatCols)
		Endif
		nRecRat := 0
	Endif
Next nI

Return(aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ? RetRateio    ºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para retorna os dados da base do ALIAS CNZ          º±?
±±?         ?                                      				 	  º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT													  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Static Function RetRateio(cItemPlan,cContrato,cPlanMed,cRevisao,lRecRat,cFilCtr)
Local cQry			:= ""
Local cAliasQry	:= GetNextAlias()
Local cFields		:= ""
Local aDadoRat		:= {}
Local aAux			:= {}
Local aHeadCNZ		:= {}
Local nI			:= 0

Default lRecRat := .f.

If lRecRat
	cFields := "R_E_C_N_O_ CNZREC"
Else
	aHeadCNZ	:= 	GCTHeadCNZ()
	cFields 	:= 	MountFieldsOfHeader(aHeadCNZ)
Endif

cQry := "SELECT " + chr(13) + chr(10)
cQry += cFields + chr(13) + chr(10)
cQry += " FROM     " + chr(13) + chr(10)
cQry += "	" + RetSQLName("CNZ") + " CNZ " + chr(13) + chr(10)
cQry += "WHERE " + chr(13) + chr(10)
cQry += "	CNZ_FILIAL = '"+xFilial("CNZ",cFilCTR)+"' " + chr(13) + chr(10)
cQry += "	AND " + chr(13) + chr(10)
cQry += "	CNZ_CONTRA = '"+cContrato+"' " + chr(13) + chr(10)
cQry += "	AND  " + chr(13) + chr(10)
cQry += "	CNZ_REVISA = '"+cRevisao+"' " + chr(13) + chr(10)
cQry += "	AND " + chr(13) + chr(10)

If IsInCallstack("CNTA200") .or. IsInCallstack("CN200Manut") .or. IsInCallstack("CN100Manut")
	cQry += "	CNZ_CODPLA = '"+cPlanMed+"' " + chr(13) + chr(10)
Else
	cQry += "	CNZ_NUMMED = '"+cPlanMed+"' " + chr(13) + chr(10)
Endif

cQry += "	AND " + chr(13) + chr(10)
cQry += "	CNZ_ITCONT = '"+cItemPlan+"' " + chr(13) + chr(10)
cQry += "	AND " + chr(13) + chr(10)
cQry += "	D_E_L_E_T_ = ' ' " + chr(13) + chr(10)

cQry := ChangeQuery( cQry )

If Select(cAliasQry) > 0
	(cAliasQry)->(dbClosearea())
Endif

dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQry ), cAliasQry, .F., .T. )

While (cAliasQry)->(!Eof())

	If lRecRat
		aAdd(aDadoRat,(cAliasQry)->CNZREC)
	Else
		For nI := 1 to len(aHeadCNZ)
			aAdd(aAux,(cAliasQry)->&(aHeadCNZ[nI,2]))
		Next nI

		aAdd(aAux,.f.)
		aAdd(aDadoRat,aAux)
		aAux := {}
	endif
	(cAliasQry)->(dbSkip())
EndDo

If Len(aDadoRat) == 0 .and. !lRecRat
	aDadoRat := GetDefaultLine(aHeadCNZ)
Endif

(cAliasQry)->(dbClosearea())
Return(aDadoRat)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ³MountFieldsOfHeaderºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para retorna a string com os campo do cabeço da GetDadosº±?
±±?         ?                                      				 	      º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT											       		  º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Static Function MountFieldsOfHeader(aHeadCNZ)
Local cRetFields	:= ""
Local nI			:= 0

For nI := 1 to len(aHeadCNZ)
	cRetFields += Alltrim(aHeadCNZ[nI,2]) + "," + chr(13) + chr(10)
Next nI

nPLastVirg := Rat(",",cRetFields)

cRetFields := Substr(cRetFields,1,nPLastVirg -1)

Return(cRetFields)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ³GetVarRateio ºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao que preenchem os Arrays parametrizados com os     º±?
±±?         ?campos de cabeçalho e itens do contrato provenientes do  º±?
±±?         ?cadastros de planilha ou manutencao de medições.         º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT		       						        		º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Static Function GetVarRateio(aRetCab,aRetIt,cAlias)
Default aRetCab := nil
Default aRetIt	:= nil

Default cAlias  := ""

If Empty(cAlias)
	If IsInCallstack("CNTA200") .or. IsInCallstack("CN200Manut") .or. IsInCallstack("CN100Manut")
		If aRetCab <> nil
			aRetCab := {	"CNA_CONTRA",;
							"CNA_REVISA",;
							"CNA_NUMERO",;
							"CNA_FORNEC",;
							"CNA_LJFORN",;
							"CNA_CLIENT",;
							"CNA_LOJACL";
						}
		EndIf
		If aRetIt <> nil
			aRetIt	:= {	"CNB_CONTRA",;
							"CNB_REVISA",;
							"CNB_NUMERO",;
							"CNB_ITEM",;
							"CNB_VLTOT";
		           		}
	    EndIf
	Else
		If aRetCab <> nil
			aRetCab	:= {	"CND_CONTRA",;
							"CND_REVISA",;
							"CND_NUMMED",;
							"CND_FORNEC",;
							"CND_LJFORN",;
							"CND_CLIENT",;
							"CND_LOJACL";
						}
		EndIf
		If aRetIt <> nil
			aRetIt	:= {	"CNE_CONTRA",;
							"CNE_REVISA",;
							"CNE_NUMMED",;
							"CNE_ITEM",;
							"CNE_VLTOT";
						}
		EndIf
	Endif
ElseIf  cAlias == "CNA"
		If aRetCab <> nil
			aRetCab := {	"CNA_CONTRA",;
							"CNA_REVISA",;
							"CNA_NUMERO",;
							"CNA_FORNEC",;
							"CNA_LJFORN",;
							"CNA_CLIENT",;
							"CNA_LOJACL";
						}
		EndIf
		If aRetIt <> nil
			aRetIt	:= {	"CNB_CONTRA",;
							"CNB_REVISA",;
							"CNB_NUMERO",;
							"CNB_ITEM",;
							"CNB_VLTOT";
		           		}
	    EndIf
ElseIf cAlias == "CND"
		If aRetCab <> nil
			aRetCab	:= {	"CND_CONTRA",;
							"CND_REVISA",;
							"CND_NUMMED",;
							"CND_FORNEC",;
							"CND_LJFORN",;
							"CND_CLIENT",;
							"CND_LOJACL";
						}
		EndIf
		If aRetIt <> nil
			aRetIt	:= {	"CNE_CONTRA",;
							"CNE_REVISA",;
							"CNE_NUMMED",;
							"CNE_ITEM",;
							"CNE_VLTOT";
						}
		EndIf
EndIf

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ?GravaCNZ ºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ?Funcao auxiliar para a gravacao dos dados do rateio   º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros?aExp01 - Conteudo do Rateio por Centro de Custo       º±?
±±?         ?oExp01 - Objeto com cabecalho e item da Medicao       º±?
±±?         ?         ou Planilha                                  º±?
±±?         ?nExp01 - Opcao selecionada                            º±?
±±?         ?aExp02 - Array com os cabecalhos de planilhas         º±?
±±?         ?aExp03 - Array com os itens das planilhas             º±?
±±?         ?cExp01 - Especie do contrato - compra/venda           º±?
±±?         ?aExp04 - Array com os cabecalhos da medicao           º±?
±±?         ?aExp05 - Array com os itens das medicao               º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ?SIGAGCT											     º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravaCNZ(aDados,oGetDados,nOpc,aPlani,aPlIt,cEspCtr,aHeader,aCols,aHeaderCNB,cTipo,cFilCtr)
Local nI		:= 0
Local nX		:= 0
Local nPItem	:= 0//aScan(oGetDados:aHeader,{|x| alltrim(x[2]) == "CNB_ITEM"})
Local nPVlTotal	:= 0//aScan(oGetDados:aHeader,{|x| alltrim(x[2]) == "CNB_VLTOT"})

Local nBItem    :=  aScan(aHeaderCNB,{ |x| alltrim(x[2]) == "CNB_ITEM" })
Local nBTotal   :=  aScan(aHeaderCNB,{ |x| alltrim(x[2]) == "CNB_VLTOT" })

Local cCodEnt	:= ""
Local cLojEnt	:= ""
Local aVarCab	:= {}
Local aVarItem	:= {}

Default aPlani	 := ""
Default aPlIt	 := ""
Default cEspCtr := "NOT_CALL_CNA100"
Default cTipo   := ""
Default aHeader := {}
Default aCols   := {}

If !alltrim(str(nOpc)) $ "3|4|5|12"
	Return()
Endif

If !(oGetDados==NIL)
	aHeader := oGetDados:aHeader
	aCols   := oGetDados:aCols
EndIf
If !Empty(cTipo) .And. nOpc<>3 .And. !Len(aDados) > 0
	aDados := aClone(CarregaCNZ(aDados,oGetDados,cEspCtr,aPlani,aPlIt,aHeaderCNB,cTipo,aHeader,aCols))
EndIf

If cEspCtr == "NOT_CALL_CNA100"
	GetVarRateio(aVarCab,aVarItem)
	aSort(aDados,,,{|x,y| x[1]+x[2]+x[3]+x[4] < y[1]+y[2]+y[3]+y[4]})

	/*
	aDados
		aDados[i,1] - Codigo do contrato
		aDados[i,2] - Revisao da Planilha
		aDados[i,3] - Codigo da Planilha
		aDados[i,4] - Item da Planilha
		aDados[i,5] - array acols
			aDados[i,5,n] - array com as linhas do acols
			aDados[i,5,n,x] - colunas do aCols
	*/

	nPItem		:= aScan(aHeader,{|x| alltrim(x[2]) == aVarItem[ITEM]})
	nPVlTotal	:= aScan(aHeader,{|x| alltrim(x[2]) == aVarItem[VL_TOTAL]})

	If !Empty(M->&(aVarCab[FORNECEDOR]))
		cCodEnt := M->&(aVarCab[FORNECEDOR])
		cLojEnt	:= M->&(aVarCab[LOJAFOR])
		cEspCtr := "1"
	Else
		cCodEnt := M->&(aVarCab[CLIENTE])
		cLojEnt	:= M->&(aVarCab[LOJACLI])
		cEspCtr := "2"
	Endif

	For nI := 1 to len(aCols)
		If aCols[nI,len(aHeader) + 1]
			ManipulaCNZ(M->&(aVarCab[CONTRATO]),M->&(aVarCab[PLAN_MED]),M->&(aVarCab[REVISAO]),aCols[nI,nPItem],aCols[nI,nPVlTotal],aDados,{cCodEnt,cLojEnt,cEspCtr},5,)
		Else
			ManipulaCNZ(M->&(aVarCab[CONTRATO]),M->&(aVarCab[PLAN_MED]),M->&(aVarCab[REVISAO]),aCols[nI,nPItem],aCols[nI,nPVlTotal],aDados,{cCodEnt,cLojEnt,cEspCtr},nOpc,)
		Endif
	Next nI
Else

	For nX := 1 to len(aPlani)
   		dbSelectArea("CNA")
		dbSetOrder(1)

		dbSeek(xFilial("CNA",cFilCTR)+CN9->CN9_NUMERO+CN9->CN9_REVISA)
    	For nI := 1 to len(aPlIt[nX])

    		If !Empty(CNA->CNA_FORNEC)
				cCodEnt := CNA->CNA_FORNEC
				cLojEnt	:= CNA->CNA_LJFORN
				cEspCtr := "1"
			Else
				cCodEnt :=  CNA->CNA_CLIENT
				cLojEnt	:=  CNA->CNA_LOJACL
				cEspCtr := "2"
			Endif
			ManipulaCNZ(aPlani[nX,2],aPlani[nX,3],CNA->CNA_REVISA,aPlIt[nX,nI,nBItem],aPlIt[nX,nI,nBTotal],aDados,{cCodEnt,cLojEnt,cEspCtr},nOpc,Iif(aPlIt[nX,nI,Len(aPlIt[nX,nI])],.T.,.F.),cFilCtr)
		Next nI
	Next nX

Endif

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ³ManipulaCNZºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao para manipulação dos dados da CNZ               º±?
±±?         ?de acordo com a nOpc                   			      º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT											      º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Static Function ManipulaCNZ(cContrato,cPlanMed,cRevisao,cItemPlan,nTotal,aDados,aDataHead,nOpc,lDelIt,cFilCtr)
Local cField		:= ""
Local nI			:= 0
Local nPItem		:= aScan(aDados,{|x| alltrim(x[1]) + alltrim(x[2]) + alltrim(x[3]) + alltrim(x[4]) == Alltrim(cContrato) + Alltrim(cRevisao) + Alltrim(cPlanMed) + Alltrim(cItemPlan)})
Local nOrder		:= 0
Local aRecords		:= {}
Local aHeadCNZ		:= GCTHeadCNZ()
Local aDadosItem	:= Iif(nPItem > 0, aClone(aDados[nPItem,5]), {})
Local aDadosFix		:= {cContrato,cRevisao,cPlanMed,cItemPlan}
Local aVarCab		:= {}
Local aAreaCNZ		:= CNZ->(GetArea())
Local nContra		:= TamSx3("CNZ_CONTRA")[1]
Local nRevisa		:= TamSx3("CNZ_REVISA")[1]
Local nItCont		:= TamSx3("CNZ_ITCONT")[1]
Local nItem		:= TamSx3("CNZ_ITEM")[1]

Default lDelIt	:= .F.

GetVarRateio(aVarCab)

If Len(aDadosItem) == 0
	If nOpc == 4
		nOpc := 5
	Endif
Endif

Do Case
	Case nOpc == 3 .Or. nOpc == 12
		For nI := 1 to len(aDadosItem)
			RecordCNZ(aDadosFix,aDadosItem,nTotal,nI,,aDataHead)
		Next nI
		//Registros de rateio existentes em tabela CNZ, que nao existem no array aDadosItem,
		//deverao ser excluidos do arquivo. Isto denota, que o item foi apagado da getdados, pela
		//tela de rateio.
		ClearCNZNotFound(aDadosFix,aDadosItem,lDelIt)
	Case nOpc == 4
		nPItem := aScan(aHeadCNZ,{|x| alltrim(x[2]) == "CNZ_ITEM"})

		If aVarCab[CONTRATO] == "CNA_CONTRA"
			nOrder := 1
			cField := "CNZ_CODPLA"
		Else
			nOrder := 2
			cField := "CNZ_NUMMED"
		Endif

		CNZ->(DbSetOrder(nOrder)) //CNZ_FILIAL+CNZ_CONTRA+CNZ_REVISA+CNZ_NUMMED+CNZ_ITCONT+CNZ_ITEM

		For nI := 1 to len(aDadosItem)
			If !(CNZ->(DbSeek( xFilial("CNZ") +;
							PadR(aDadosFix[1],nContra)	+;
							PadR(aDadosFix[2],nRevisa)	+;
							PadR(aDadosFix[3],TamSx3(cField)[1])	+;
							PadR(aDadosFix[4],nItCont)	+;
							PadR(aDadosItem[nI,nPItem],nItem);
							) ) )

				RecordCNZ(aDadosFix,aDadosItem,nTotal,nI,,aDataHead)
			Else
				RecordCNZ(aDadosFix,aDadosItem,nTotal,nI,.t.,aDataHead)
			Endif
		Next nI

		//Registros de rateio existentes em tabela CNZ, que nao existem no array aDadosItem,
		//deverao ser excluidos do arquivo. Isto denota, que o item foi apagado da getdados, pela
		//tela de rateio.
		ClearCNZNotFound(aDadosFix,aDadosItem,lDelIt)//,@nDetCtb,aDadosProva)
	Case nOpc == 5
		aRecords := RetRateio(cItemPlan,cContrato,cPlanMed,cRevisao,.T.,cFilCtr)

		If len(aRecords) > 0
			For nI := 1 to len(aRecords)
				CNZ->(MsGoto(aRecords[nI]))

				//chamada da DetProva - para o LP 6A3 - Lancamento da Exclusao do Rateio do Item da Planilha de Contrato
				//nDetCtb += DetProva(aDadosProva[1],"69C","CNTA200",aDadosProva[2])

				Reclock("CNZ",.F.)
					CNZ->(Dbdelete())
				CNZ->(MSUnlock())
			Next nI
		Endif
End Case

RestArea(aAreaCNZ)
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ?RecordCNZ ºAutor  ? TOTVS          ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ?Funcao que persiste os dados na base para o ALIAS CNZ  º±?
±±?         ?                                                       º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT											      º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Static Function RecordCNZ(aFixData,aInsData,nTotal,nLin,lAltera,aDataHead)
	Local nY			:= 0
	Local nPerc			:= 0
	Local nValor		:= 0
	Local bUpdFornec
	Local bUpdClient
	Local bUpdEntity
	Local aHeadCNZ		:= GCTHeadCNZ()
	Local lInsert
	
	Default lAltera		:= .f.
	
	bUpdFornec  := {|| CNZ->CNZ_FORNEC := aDataHead[1],CNZ->CNZ_LJFORN := aDataHead[2] }
	bUpdClient	:= {|| CNZ->CNZ_CLIENT := aDataHead[1],CNZ->CNZ_LOJACL := aDataHead[2] }
	bUpdEntity 	:= IIF( empty(aDataHead[3]) .or. aDataHead[3] == "1",bUpdFornec,bUpdClient)
	
	lInsert	:= !lAltera
	
	RecLock("CNZ",lInsert)
	
	If lInsert
		CNZ->CNZ_FILIAL := xFilial("CNZ")
		CNZ->CNZ_CONTRA	:= aFixData[1]
		CNZ->CNZ_REVISA	:= aFixData[2]
	
		If IsInCallstack("CNTA200") .or. IsInCallstack("CN200Manut") .or. IsInCallstack("CN100Manut")
			CNZ->CNZ_CODPLA	:= aFixData[3]
		Else
			CNZ->CNZ_NUMMED	:= aFixData[3]
		Endif
	
		CNZ->CNZ_ITCONT	:= aFixData[4]
	Endif
	
	For nY := 1 to len(aHeadCNZ)
		CNZ->&(aHeadCNZ[nY,2]) := aInsData[nLin,nY]
	
		If Alltrim(aHeadCNZ[nY,2]) == "CNZ_PERC"
			nPerc := aInsData[nLin,nY]
		Endif
	Next nY
	
	Eval(bUpdEntity)
	
	nValor := (nPerc * nTotal) / 100
	
	CNZ->CNZ_VALOR1 := nValor
	CNZ->CNZ_VALOR2 := xMoeda(nValor,1,2,dDatabase)
	CNZ->CNZ_VALOR3 := xMoeda(nValor,1,3,dDatabase)
	CNZ->CNZ_VALOR4 := xMoeda(nValor,1,4,dDatabase)
	CNZ->CNZ_VALOR5 := xMoeda(nValor,1,5,dDatabase)
	
	CNZ->(MsUnlock())

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±?
±±ºPrograma  ³ClearCNZNotFoundºAutor ? TOTVS      ?Data ?3/02/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºDescricao ³Registros de rateio existentes em tabela CNZ, que nao   º±?
±±?         ³existem no array aDadosItem, deverao ser excluidos do   º±?
±±?         ³arquivo. Isto denota, que o item foi apagado da         º±?
±±?         ³getdados, pela tela de rateio.                          º±?
±±?         ?                                                       º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±?
±±ºUso       ?SIGAGCT											      º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±?
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±?
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß?
*/
Static Function ClearCNZNotFound(aDadosFix,aDadosItem,lDelIt)

Local aArrayRec	:= RetRateio(aDadosFix[4],aDadosFix[1],aDadosFix[3],aDadosFix[2],.T.)
Local aHeadCNZ	:= GCTHeadCNZ()
Local nI		:= 0
Local nP		:= 0
Local nPItem	:= aScan(aHeadCNZ,{|x| alltrim(x[2]) == "CNZ_ITEM"})

Default lDelIt:= .F.

If len(aArrayRec) > 0
	For nI := 1 to len(aArrayRec)

		CNZ->(MsGoto(aArrayRec[nI]))

 		nP := aScan(aDadosItem,{|x| alltrim(x[nPItem]) == Alltrim(CNZ->CNZ_ITEM)})

		If nP == 0	.Or. lDelIt
			RecLock("CNZ",.f.)
			CNZ->(dbDelete())
			CNZ->(MSUnlock())
		Endif
	Next nI
Endif

Return()



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CarregaCNZºAutor  ³Aline Sebrian    ?Data ?4/12/2011 º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ?Funcao auxiliar para carregar os dados do rateio      º±?
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros?aExp01 - Conteudo do Rateio por Centro de Custo       º±?
±±?         ?oExp01 - Objeto com cabecalho e item da Medicao       º±?
±±?         ?         ou Planilha                                  º±?
±±?         ?nExp01 - Opcao selecionada                            º±?
±±?         ?aExp02 - Array com os cabecalhos de planilhas         º±?
±±?         ?aExp03 - Array com os itens das planilhas             º±?
±±?         ?cExp01 - Se gravacao do contrato ou planilha          º±?
±±?         ?aExp04 - Array com o aheader do item da planilha      º±?
±±?         ?cExp05 - Verifica se e planilha ou medicao            º±?
±±?         ?aExp05 - Array com os cabecalhos de plan ou medicao   º±?
±±?         ?aExp06 - Array com os itens das plani ou medicao      º±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ?SIGAGCT											     º±?
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CarregaCNZ(aDados,oGetDados,cEspCtr,aPlani,aPlIt,aHeaderCNB,cTipo,aHeader,aCols)
Local nPItem	 := 0
Local nX         := 0
Local nY         := 0
Local nDados     := 1

Local aHeadCNZ	 := GCTHeadCNZ()
Local aLocalCols := {}
Local aVarCab    := {}
Local aVarItem   := {}
Local aRatGCT    := {}

Local nNumRat     := 0

If !(oGetDados==NIL)
	aHeader := oGetDados:aHeader
	aCols   := oGetDados:aCols
EndIf

GetVarRateio(aVarCab,aVarItem)

aLocalCols := GetDefaultLine(aHeadCNZ)

If (cEspCtr=="NOT_CALL_CNA100")
	If cTipo == "CNB"
		nPItem	 := aScan(aHeader,{ |x| alltrim(x[2]) == "CNB_ITEM" })
	Else
		nPItem	 := aScan(aHeader,{ |x| alltrim(x[2]) == "CNE_ITEM" })
	EndIf

	For nX:=1 to len(aCols)
		//adicionar o item do plano e um aCols vazio
		if len(adados) >= nX
			aAdd(aRatGCT,{alltrim(aDados[nX,1]),;
					      alltrim(aDados[nX,2]),;
	    				  alltrim(aDados[nX,3]),;
	    				  alltrim(aCols[nX,nPItem]),;
	    				  aLocalCols})

				aRatGCT[nX,5] := aUpdCols(aDados[nX,5])
		EndIf
	Next nX
Else
    nPItem	 := aScan(aHeaderCNB,{ |x| alltrim(x[2]) == "CNB_ITEM" })

	aSort(aDados,,,{|x,y| x[1]+x[2]+x[3]+x[4] < y[1]+y[2]+y[3]+y[4]})

	For nX:=1 to len(aPlani)
		For nY:= 1 to len(aPlIt[nX])
			//Verifica se item da planilha possui rateio CC
			If nDados<=Len(aDados)
				If (nNumRat:= aScan(aDados[nDados,5],{|x| x[2] > 0}))>0
					//adicionar o item do plano e um aCols vazio
					If aDados[nDados,3] == aPlani[nX][3] .And.aDados[nDados,4] == aPlIt[nX,nY,nPItem]
						aAdd(aRatGCT,{alltrim(aDados[nDados,1]),;
								      alltrim(aDados[nDados,2]),;
		     						  alltrim(aDados[nDados,3]),;
		    						  alltrim(aPlIt[nX,nY,nPItem]),;
		      						  aLocalCols})

						aRatGCT[nDados,5] := aUpdCols(aDados[nDados,5])
						nDados++
					EndIf
				EndIf
			EndIf
		Next nY
	Next nX
EndIf

Return aRatGCT

//-------------------------------------------------------------------
/*/{Protheus.doc} CNTBuscFil
Busca filial do contrato conforme numero da medição que foi informada

@author leonardo.quintania
@since 09/10/2013
@version P11.90
/*/
//-------------------------------------------------------------------
Function CNTBuscFil(cFilMed,cMedicao)
Local cFilCTR	:= cFilAnt
Local aArea   := GetArea()

CND->(dbSetOrder(4))
If CND->(MsSeek(cFilMed+cMedicao))
	cFilCTR:= CND->CND_FILCTR
EndIf

RestArea(aArea)
Return cFilCTR
//-------------------------------------------------------------------
/*/{Protheus.doc} GCTAjEsCtr
Funcao que processo o ajuste do campo CN9_ESPCTR via job

@author andre.oliveira
@since 14/11/2013
@version P11.90

//- Alterado conceito
@since 25/10/2017
@version V12.1.17
/*/
//-------------------------------------------------------------------
Function GCTAjEsCtr()
Local cAliasProc := GetNextAlias()
Local cAliasCN9  := ""

BeginSQL Alias cAliasProc
SELECT 	COUNT(*) REGS
FROM 	%Table:CN9% CN9
WHERE	CN9.CN9_FILIAL = %xFilial:CN9% AND
		CN9.CN9_ESPCTR = %Exp:CriaVar("CN9_ESPCTR",.F.)% AND
		CN9.%NotDel%
EndSQL

If (cAliasProc)->REGS > 0
	cAliasCN9 := GetNextAlias()

	BeginSQL Alias cAliasCN9
	SELECT 	CN9.R_E_C_N_O_ CN9RECNO,
			CN1.CN1_ESPCTR

	FROM 	%Table:CN9% CN9

	JOIN 	%Table:CN1% CN1 ON
			CN1.CN1_FILIAL = %xFilial:CN1% AND
			CN1.CN1_CODIGO = CN9.CN9_TPCTO AND
			CN1.%NotDel%

	WHERE 	CN9.CN9_FILIAL = %xFilial:CN9% AND
			CN9.CN9_ESPCTR = ' ' AND
			CN9.%NotDel%
	EndSQL

	While !(cAliasCN9)->(EOF())
		CN9->(MsGoTo((cAliasCN9)->CN9RECNO))
		If RecLock("CN9",.F.)
			CN9->CN9_ESPCTR := (cAliasCN9)->CN1_ESPCTR
			CN9->(MsUnLock())
		EndIf
		(cAliasCN9)->(dbSkip())
	End
	(cAliasCN9)->(dbCloseArea())
EndIf
(cAliasProc)->(dbCloseArea())
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} GCTAjusCli
Funcao que processa o ajuste do campo CN9_CLIENT e CN9_LOJACL via job

@author andre.oliveira
@since 14/11/2013
@version P11.90

//- Alterado conceito
@since 25/10/2017
@version V12.1.17
/*/
//-------------------------------------------------------------------
Function GCTAjusCli()
Local cAliasProc := GetNextAlias()
Local cAliasCN9  := ""

BeginSQL Alias cAliasProc
SELECT 	COUNT(*) REGS
FROM 	%Table:CN9%
WHERE 	CN9_FILIAL = %xFilial:CN9% AND
		CN9_CLIENT <> %Exp:CriaVar("CN9_CLIENT",.F.)% AND
		%NotDel%
EndSQL

If (cAliasProc)->REGS > 0
	cAliasCN9 := GetNextAlias()

	BeginSQL Alias cAliasCN9

	SELECT 	CN9_NUMERO,
			CN9_REVISA,
			CN9_CLIENT,
			CN9_LOJACL,
			R_E_C_N_O_ CN9RECNO

	FROM 	%Table:CN9%

	WHERE 	%NotDel% AND
			CN9_FILIAL = %xFilial:CN9% AND
			CN9_CLIENT <> %Exp:CriaVar("CN9_CLIENT",.F.)%
	EndSQL

	While !(cAliasCN9)->(EOF())
		RecLock("CNC",.T.)
		CNC->CNC_FILIAL := xFilial("CNC")
		CNC->CNC_NUMERO := (cAliasCN9)->CN9_NUMERO
		CNC->CNC_REVISA := (cAliasCN9)->CN9_REVISA
		CNC->CNC_CLIENT := (cAliasCN9)->CN9_CLIENT
		CNC->CNC_LOJACL := (cAliasCN9)->CN9_LOJACL
		CNC->(MsUnLock())

		CN9->(MsGoTo((cAliasCN9)->CN9RECNO))
		RecLock("CN9",.F.)
		CN9->CN9_CLIENT := CriaVar("CN9_CLIENT",.F.)
		CN9->CN9_LOJACL := CriaVar("CN9_LOJACL",.F.)
		CN9->(MsUnLock())

		(cAliasCN9)->(dbSkip())
	End
	(cAliasCN9)->(dbCloseArea())
EndIf
(cAliasProc)->(dbCloseArea())
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} GCTAjuFCtr
Funcao que processa o ajuste do campo CN9_CLIENT e CN9_LOJACL via job

@author andre.oliveira
@since 14/11/2013
@version P11.90

//- Alterado conceito
@since 25/10/2017
@version V12.1.17
/*/
//-------------------------------------------------------------------
Function GCTAjuFCtr()
Local cAliasProc := GetNextAlias()
Local cAliasCN9  := ""

BeginSQL Alias cAliasProc
SELECT	COUNT(*) REGS
FROM 	%Table:CN9%
WHERE 	CN9_FILIAL = %xFilial:CN9% AND
		CN9_FILCTR = %Exp:CriaVar("CN9_FILCTR",.F.)% AND
		%NotDel%
EndSQL

If (cAliasProc)->REGS > 0
	cAliasCN9 := GetNextAlias()

	BeginSQL Alias cAliasCN9

	SELECT 	CN9.R_E_C_N_O_ CN9RECNO,
			CND.R_E_C_N_O_ CNDRECNO
	FROM 	%Table:CN9% CN9

	LEFT JOIN %Table:CND% CND ON
			CND.%NotDel% AND
			CND.CND_FILIAL = %xFilial:CND% AND
			CND.CND_CONTRA = CN9.CN9_NUMERO AND
			CND.CND_REVISA = CN9.CN9_REVISA

	WHERE 	CN9.%NotDel% AND
			CN9.CN9_FILIAL = %xFilial:CN9% AND
			CN9.CN9_FILCTR = %Exp:CriaVar("CN9_FILCTR",.F.)%
	EndSQL

	SM0->(dbSetOrder(1))
	While !(cAliasCN9)->(EOF())
		CN9->(MsGoTo((cAliasCN9)->CN9RECNO))
		SM0->(dbSeek(cEmpAnt+AllTrim(CN9->CN9_FILIAL)))

		RecLock("CN9",.F.)
		CN9->CN9_FILCTR := FWCodFil()
		CN9->(MsUnLock())

		If Empty((cAliasCN9)->CNDRECNO)
			(cAliasCN9)->(dbSkip())
		Else
			While !(cAliasCN9)->(EOF()) .And. CN9->(Recno()) == (cAliasCN9)->CN9RECNO
				CND->(MsGoTo((cAliasCN9)->CNDRECNO))
				RecLock("CND",.F.)
				CND->CND_FILCTR := FWCodFil()
				CND->(MsUnLock())
				(cAliasCN9)->(dbSkip())
			End
		EndIf
	End
	(cAliasCN9)->(dbCloseArea())
EndIf
(cAliasProc)->(dbCloseArea())
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} GCTAjNuPla
Ajuste para preencher o número da planilha nas parcelas do cronograma

@author andre.oliveira
@since 09/10/2013
@version P11.90

//- Alterado conceito
@since 25/10/2017
@version V12.1.17
/*/
//-------------------------------------------------------------------
Function GCTAjNuPla()
Local cAliasProc := GetNextAlias()
Local cAliasCNF  := ""

BeginSQL Alias cAliasProc
SELECT	COUNT(*) REGS
FROM 	%Table:CNF%
WHERE 	%NotDel% AND
		CNF_FILIAL = %xFilial:CNF% AND
		CNF_NUMPLA = %Exp:CriaVar("CNF_NUMPLA",.F.)%
EndSQL

If (cAliasProc)->REGS > 0
	cAliasCNF := GetNextAlias()

	BeginSQL Alias cAliasCNF

	SELECT 	CNF.R_E_C_N_O_ CNFRECNO,
			CNA.CNA_NUMERO

	FROM 	%Table:CNF% CNF

	JOIN 	%Table:CNA% CNA ON
			CNA.%NotDel% AND
			CNA.CNA_FILIAL = %xFilial:CNA% AND
			CNA.CNA_CONTRA = CNF.CNF_CONTRA AND
			CNA.CNA_REVISA = CNF.CNF_REVISA AND
			CNA.CNA_CRONOG = CNF.CNF_NUMERO

	WHERE 	CNF.%NotDel% AND
			CNF.CNF_FILIAL = %xFilial:CNF% AND
			CNF.CNF_NUMPLA = %Exp:CriaVar("CNF_NUMPLA",.F.)%

	EndSQL

	While !(cAliasCNF)->(EOF())
		CNF->(MsGoTo((cAliasCNF)->CNFRECNO))
		RecLock("CNF",.F.)
		CNF->CNF_NUMPLA := (cAliasCNF)->CNA_NUMERO
		CNF->(MsUnLock())
		(cAliasCNF)->(dbSkip())
	End
	(cAliasCNF)->(dbCloseArea())
EndIf
(cAliasProc)->(dbCloseArea())
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} CNTRetorno
Efetua validações  e devolve retorno ao usuario da consulta CNC001

@author leonardo.quintania
@since 09/10/2013
@version P11.90
/*/
//-------------------------------------------------------------------
Function CNTRetorno(nOpc)
Local cEspCtr	:= ''
Local cRet		:= ''
Local cFilCtr	:= ""

If FwIsInCallStack("CNTA121")
	cFilCtr := M->CND_FILCTR
	cEspCtr := IIF(Cn300RetSt('COMPRA',,,, cFilCtr),'1','2')	
ElseIf FwIsInCallStack("CN100CtrRet")//Precisa avaliar o CN100CtrRet antes do CNTA300, pois nesse cenário ambas as funções estão na pilha
	cEspCtr := CN9->CN9_ESPCTR
ElseIf(FwIsInCallStack("CNTA300RUS") .Or. FwIsInCallStack("CNTA300"))
	cEspCtr := FWFldGet("CN9_ESPCTR")		
EndIf

If nOpc == 1
	cRet := If(cEspCtr == "1",SA2->A2_COD,SA1->A1_COD)
Else
	cRet := If(cEspCtr == "1",SA2->A2_LOJA,SA1->A1_LOJA)
EndIf

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MtGetRotOpc()
Função ara retornar item do menu selecionado

@param aMenuDef - Menudef()
@param cFuncao - Função a ser encontrada
@param nOpc - paramentro usado somente para a recursividade

@author guilherme.pimentel
@since 21/01/2014
@version 1.0
@return Nil
/*/
//-------------------------------------------------------------------

Function MtGetRotOpc(aMenuDef,cFuncao,nOpc)
Local nI      := 0
Local nRotOpc := 0
Default nOpc  := 0

For nI:= 1 to Len(aMenuDef)
	If ValType(aMenuDef[nI,2]) == "C"
		If cFuncao == aMenuDef[nI,2]
			nRotOpc := Iif(nOpc<>0,nOpc,nI)
			Exit
		EndIf
	Else
		nRotOpc := MtGetRotOpc(aMenuDef[nI,2],cFuncao,nI)
	EndIf
Next nI

Return nRotOpc

//-------------------------------------------------------------------
/*/{Protheus.doc} MtBCMod()
Funcao para bloquear campos modelo de dados

@author guilherme.pimentel
@since 21/01/2014
@version 1.0
@return Nil
/*/
//-------------------------------------------------------------------
Function MtBCMod(oModel,aMod,bBlock,cModelo)
	local nX := 0
	local nY := 0
	Local aWhenUsr:= {}
	Local oStruct := Nil
	Local aCampos := {}
	Default cModelo := '1'

	If IsFalseBlc(bBlock)
		bBlock := FwBuildFeature( STRUCT_FEATURE_WHEN, ".F.")//Ajusta bloco de acordo com padrão do framework
	ElseIf IsTrueBlc(bBlock)
		bBlock := GetTrueWhen()//Ajusta bloco de acordo com padrão do framework
	EndIf

	If cModelo == '1' // Bloqueio total de todos os campos
		For nX := 1 to Len(aMod)
			aWhenUsr := GCTGetWhen(oModel:GetModel(aMod[nX]), .T.) // Guarda o When dos campos
			
			oModel:GetModel(aMod[nX]):GetStruct():SetProperty("*",MODEL_FIELD_WHEN,bBlock)

			If Len(aWhenUsr) > 0
				GCTRstWhen(oModel:GetModel(aMod[nX]), aWhenUsr)
				FwFreeArray(aWhenUsr)
			EndIf
		Next nX
	ElseIf cModelo == '2'
		For nX := 1 to Len(aMod)
			oStruct := oModel:GetModel(aMod[nX,1]):GetStruct()
			aCampos := aMod[nX,2]
			For nY := 1 to Len(aCampos)
				oStruct:SetProperty(aCampos[nY],MODEL_FIELD_WHEN,bBlock)
			Next nY
		Next nX
	EndIf

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} CnRevAtu(cContra,cRev)
Função para atualizar a revisão atual do contrato

@author alexandre.gimenez
@since 23/01/2014
@version 1.0
@return Nil
/*/
//-------------------------------------------------------------------
Function CnRevAtu(cContra,cRev,cTipo)
local aArea    := CN9->(GetArea())
Local cRevAnt  := CnRevAnt()

CN9->(DbSetOrder(1))
If CN9->(MsSeek(xFilial('CN9')+cContra+cRevAnt))
	Reclock( "CN9", .F.)
		If cTipo == '1' //Inclui revisão
			CN9->CN9_REVATU := cRev
		Else// Exclui revisao
			CN9->CN9_REVATU := ''
		EndIf
	CN9->(MsUnlock())
EndIf
CN9->(RestArea(aArea))
Return Nil


//-------------------------------------------------------------------
/*/{Protheus.doc} CnCauAtu(oModel,cRev)
Função para atualizar a caucao manual durante a aprovacao
 do contrato

@author aline.sebrian
@since 24/02/2014
@version 1.0
@return Nil
/*/
//-------------------------------------------------------------------
Function CnCauAtu(oModel,cRev)
local aArea       := GetArea()
Local oModelCN8	:= oModel:GetModel("CN8DETAIL")
Local nCauc       := 0

//Atualiza a caução manual (CN8)
For nCauc := 1 to oModelCN8:Length()
	oModelCN8:GoLine(nCauc)

	DbSelectArea("CN8")
	DbSetOrder(1)
	If DbSeek(xFilial('CN8')+oModelCN8:GetValue("CN8_CODIGO"))
		Reclock( "CN8", .F.)
			CN8->CN8_REVISA := cRev
		MsUnlock()
	EndIf
Next nCauc

RestArea(aArea)
Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} CnSitAtu(cContra,cRev)
Função para atualizar situacao da revisao anterior para 10-Revisado

@author aline.sebrian
@since 24/02/2014
@version 1.0
@return Nil
/*/
//-------------------------------------------------------------------
Function CnSitAtu(cContra,cRev)
Local aArea    	:= GetArea()
Local aAreaCN9  := CN9->(GetArea())
Local cRevAnt  	:= CnRevAnt()

DbSelectArea("CN9")
CN9->(DbSetOrder(1))
If CN9->(MsSeek(xFilial('CN9')+cContra+cRevAnt)) .And. Reclock( "CN9", .F.)
    CN9->CN9_SITUAC := "10"
	CN9->(MsUnlock())
EndIf

RestArea(aArea)
RestArea(aAreaCN9)
Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} CnRevAnt()
Função retorna numero da revisão anterior

@author aline.sebrian
@since 24/02/2014
@version 1.0
@return Nil
/*/
//-------------------------------------------------------------------
Function CnRevAnt(lModel,cCtrRev)
Local nRevisa 	:= TamSX3("CN9_REVISA")[1]
Local cRevAnt	:= ""
Local oModel	:= Nil

Default lModel 	:= .T.
Default cCtrRev	:= CN9->CN9_REVISA

If lModel
	oModel	:= FwModelActive()
	cRevAnt	:= Tira1(oModel:GetModel("CN9MASTER"):GetValue("CN9_REVISA"))
Else
	If 	!Empty(cCtrRev)
		cRevAnt	:= Tira1(cCtrRev)
	EndIf
EndIf

If cRevAnt == Replicate('0',nRevisa)
	cRevAnt := Space(nRevisa)
EndIf

Return cRevAnt

//-------------------------------------------------------------------
/*/{Protheus.doc} CnContab(cPadrao)
Contabiliza o contrato
@author aline.sebrian
@since 24/02/2014
@version 1.0
@return Nil
/*/
//-------------------------------------------------------------------
Function cnContab(cPadrao)

LOCAL aArea     := GetArea()
LOCAL aCtbDia	:= {}

LOCAL cLoteCtb  := ""

LOCAL lDigita   := .F.
LOCAL lPadrao   := .F.

LOCAL nHdlPrv   := 0
LOCAL nTotal    := 0

Local lReajAuto		:= IsInCallStack("CN310Reaj")
Local lBxFluig		:= IsInCallStack("MTFlgLbDoc") .Or. IsInCallStack("U_MTFlgLbDoc")
Local lAprova		:= IsInCallStack("A097ProcLib") .Or. IsInCallStack("A097ProcSup")
Local lPortal		:= IsInCallStack('put_aprrev') .Or. IsInCallStack('post_readj') .Or. IsInCallStack('post_rein')

Private cArquivo := " "

dbSelectArea("CN9")
CN9->(dbSetOrder(1))

If lReajAuto .Or. lBxFluig .Or. lAprova .Or. lPortal
	Pergunte("CNT100",.F.)
EndIf

lDigita := MV_PAR02 == 1
lPadrao := VerPadrao(cPadrao)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
//³Lancamento Contabil?
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
If ( lPadrao .and. MV_PAR01 == 1 )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	//?Verifica o numero do lote contabil                        ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	dbSelectArea("SX5")
	dbSetOrder(1)
	If MsSeek(xFilial()+"09GCT")
		cLoteCtb := AllTrim(X5Descri())
	Else
		cLoteCtb := "GCT "
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	//?Executa o execblock                                       ?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	If At(UPPER("EXEC"),X5Descri()) > 0
		cLoteCtb := &(X5Descri())
	EndIf

	nHdlPrv := HeadProva(cLoteCtb,"CNTA300",Substr(cUsuario,7,6),@cArquivo)
	nTotal  += DetProva(nHdlPrv,cPadrao,"CNTA300",cLoteCtb)
	RodaProva(nHdlPrv,nTotal)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Envia para Lancamento Contabil?
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc == "PTG"
		aCtbDia := {{"CN9",CN9->(RECNO()),CN9->CN9_DIACTB,"CN9_NODIA"}}
	Else
	    aCtbDia := {}
	EndIF
	cA100Incl(cArquivo,nHdlPrv,3,cLoteCtb,lDigita,.F.,,,,,,aCtbDia)
EndIf

RestArea(aArea)
Return(.T.)


//-------------------------------------------------------------------
/*/{Protheus.doc} MTGetAllMd()
Funcao para retornar todos os modelos de Model

@author alexandre.gimenez
@since 14/03/2014
@version 1.0
@return aRet
/*/
//-------------------------------------------------------------------
Function MtGetAllMd(aException)
Local oModel	:= FwModelActive()
Local aRet		:= {}
Local nX		:= 0
Default aException := {}

For nX := 1 to len(oModel:GetAllSubModels())
	If  aScan(aException,oModel:GetAllSubModels()[nX]:CID) == 0
		aAdd(aRet,oModel:GetAllSubModels()[nX]:CID)
	EndIf
Next nX

Return aRet

//-------------------------------------------------------------------
/*{Protheus.doc} CheckCpt
Verifica compatibilidade entre as tabelas dos módulos GCT e Financeiro

@author jose.delmondes
@since 22/01/2015
@version P11.80
*/
//-------------------------------------------------------------------
Function CheckCpt()
Local cModoCN9	:=	FWModeAccess("CN9",3)
Local cModoCND	:=	FWModeAccess("CND",3)
Local cModoSE1	:=	FWModeAccess("SE1",3)
Local cModoSE2	:=	FWModeAccess("SE2",3)
Local cGCTFIN		:= 	SuperGetMv("MV_GCTFIN",.F.,.T.)

If cGCTFIN .And. (cModoCN9 != cModoSE1 .Or. cModoCN9 != cModoSE2 .Or. cModoCND != cModoSE1 .Or. cModoCND != cModoSE2)
	MsgAlert(STR0058+Chr(13)+Chr(10)+Chr(13)+Chr(10)+STR0059, STR0051+"!")
EndIf

Return

//-------------------------------------------------------------------
/*{Protheus.doc} MigCN9xCNN
Migra permissões da CN9 para CNN

@author israel.escorizza
@since 03/03/2015
@version Totvs 12.1.4
*/
//-------------------------------------------------------------------

Function CNMgCN9CNN(cCNNFil,cContra,cUsrCod,cGrpCod,cTraCod)
	Local aArea := GetArea()

	dbSelectArea("CNN")
	dbSetOrder(1)

	//Procura se existe registro na CNN com as mesmas informações
	If (!dbSeek(cCNNFil+cUsrCod+cContra+"001") .AND. !dbSeek(cCNNFil+cUsrCod+cContra+"042"))
		RecLock("CNN",.T.)
			CNN->CNN_FILIAL := cCNNFil
			CNN->CNN_CONTRA := cContra
			CNN->CNN_USRCOD := cUsrCod
			CNN->CNN_GRPCOD := cGrpCod
			CNN->CNN_TRACOD := cTraCod
		CNN->(MsUnlock())
	EndIf

	dbSelectArea("CN9")
	dbSetOrder(1)

	If dbSeek(cCNNFil+cContra)
		While(CN9->CN9_NUMERO == cContra)
			RecLock("CN9",.F.)
				CN9->CN9_USUAVA := ""
			CN9->(MSUnlock())
			CN9->(dbSkip())
		EndDo
	EndIf

	RestArea(aArea)

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} GrpAprCrt()
Retorna o Grupo de Aprovação do contrato da CN1 ou CN9

@author jose.eulalio
@since 31/03/2014
@version 1.0
@return cGrpApr
/*/
//-------------------------------------------------------------------
Function GrpAprCrt(cNumDoc,cFilCtr)
	Local aAreas		:= {CN9->(GetArea()), CN1->(GetArea()), GetArea()}	
	Local cGrpApr		:= ""	

	Default cNumDoc	:= ""
	Default cFilCtr := xFilial("CN1")
	
	CN9->(dbSetOrder(1))
	If CN9->(MsSeek(cFilCtr+cNumDoc))
		If !Empty(CN9->CN9_APROV)
			cGrpApr := CN9->CN9_APROV
		Else			
			CN1->(dbSetOrder(1))
			If CN1->(MsSeek(cFilCtr+CN9->CN9_TPCTO))				
				cGrpApr := CN1->CN1_GRPSIT				
			EndIf
		EndIf
	EndIf	

	aEval(aAreas, {|x| RestArea(x) })
	FwFreeArray(aAreas)
Return(cGrpApr)

/*/{Protheus.doc} CnGetRevAt()
Retorna a Revisão Atual do Contrato

@author jose.eulalio
@since 09/04/2014
@version 1.0
@return cRevAtu
/*/
Function CnGetRevAt(cContrato, cFilCtr as Character)
	Local aAreas	:= {}
	Local cRevAtu	:= ""
	Local cChave	:= ""
	Default cFilCtr := cFilAnt
	Default cContrato := ""

	
	aAreas	:= {CN9->(GetArea()),GetArea()}
	CN9->( DbSetOrder(8) ) // CN9_FILIAL + CN9_NUMERO + CN9_REVATU
	cChave := xFilial("CN9", cFilCtr) + cContrato
	If CN9->(DbSeek(cChave))
		While (CN9->(!EOF() .And. CN9_FILIAL + CN9_NUMERO == cChave))			
			If(cRevAtu < CN9->CN9_REVISA)
				cRevAtu := CN9->CN9_REVISA
			EndIf			
			CN9->(DbSkip())
		EndDo
	EndIf		
	aEval(aAreas, {|x| RestArea(x), aSize(x,0)})
	
Return cRevAtu

/*/{Protheus.doc} CnGetRevVg()
Retorna a Revisão Vigente do Contrato

@author Israel Escorizza
@since 10/08/2015
@version 1.0
@return cRevVig
/*/
Function CnGetRevVg(cContrato, cFilCtr as Character)
	Local aAreas	:= {CN9->(GetArea()),GetArea()}
	Local cRevVig	:= ""
	Local cChave	:= ""
	Default cContrato := ""
	Default cFilCtr := cFilAnt
	
	cChave := xFilial("CN9", cFilCtr) + cContrato
	
	CN9->( DbSetOrder(7) ) // CN9_FILIAL + CN9_NUMERO + CN9_SITUAC
	If 	CN9->( DbSeek(cChave + DEF_SVIGE)) .Or. ;
		CN9->( DbSeek(cChave + DEF_SPARA))		//Contrato paralisado e' uma revisão vigente
	
		cRevVig := CN9->CN9_REVISA
	EndIf
	aEval(aAreas, {|x| RestArea(x), aSize(x,0)})
Return cRevVig

//-------------------------------------------------------------------
/*/{Protheus.doc} CnVigente()
Retorna a Revisão Vigente do Contrato

@author Israel Escorizza
@since 10/08/2015
@version 1.0
@return lRet
/*/
//-------------------------------------------------------------------
Function CnVigente(cContra,cRevAtu,cRevVg)
Local aArea	:= GetArea()
Local lRet 	:= .F.
DEFAULT cRevVig 	:= ""
DEFAULT cRevAtu 	:= ""
DEFAULT cContrato	:= ""

If !Empty(cContra)
	If Empty(cRevVig)
		cRevVig := CnGetRevVg(cContra)		
	EndIf

	If Empty(cRevAtu)
		DbSelectArea("CN9")
		CN9->( DbSetOrder(8) ) // CN9_FILIAL + CN9_NUMERO + CN9_REVATU
		If CN9->( DbSeek(xFilial("CN9") + cContrato))
			While CN9->CN9_NUMERO == cContrato .AND. CN9->(!EOF())
				If (cRevAtu < CN9->CN9_REVISA,cRevAtu := CN9->CN9_REVISA,)
				CN9->(DbSkip())
			EndDo
		EndIf
	EndIf
EndIf

If (cRevAtu == cRevVig,lRet:=.T.,lRet:=.F.)

RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GCTAlcEnt(oModel,nTipOpr,nOpr,cTipDoc,cNumDoc,cNumRev,aCampos)
Controla Fluxo de aprovação por alçadas, incluindo entidades contábeis

Parametros:
oModel		Modelo ativo do chamador da função.
nTipOpr	Tipo de operação executado pelo modelo.
nOpr  		Operacao a ser executada pela função.
		 		1 = Inclusao do documento
		 		2 = (Disponivel)
				3 = Exclusao do documento
				4 = Aprovacao do documento
				5 = Rejeiçao do documento
cTipDoc	Tipo do Documento.
cNumDoc	Numero do documento.
cNumRev	Numero da revisão do documento.
aCampos	Array de campos para MaAlcDoc.
aHeader Array do cabeçalho para MaAlcDoc.
aCols Array das colunas para MaAlcDoc.
cAprovSup Caracter para indicar superior que está aprovando alçada.

@author Israel Escorizza
@since 14/05/2015
@version 1.0
@return lRet
/*/
//-------------------------------------------------------------------

Function GCTAlcEnt(oModel,nTipOpr,nOpr,cTipDoc,cNumDoc,cNumRev,aCampos,aHeader,aCols,N,cAprovSup)
Local aArea		:= GetArea()
Local aAreaSCR  := {}
Local aRows		:= {}

//- Parametro de aprovação aglutinada no Fluig.
Local lAglFlg	:= SuperGetMV("MV_CNAGFLG",.F.,.F.)	//- Aglutinação de aprovações no Fluig

//- Parametros de aprovação por entidade contabil referente ao Contrato.
Local cAprRVEC	:= SuperGetMV("MV_APRRVEC",.F.,"")	//- Tipos de Revisões por Entidade Contábil
Local nAprCTEC	:= SuperGetMV("MV_APRCTEC",.F.,0 )  //- Aprovação de Contrato por Entidade Contábil
Local lAprCInv	:= SuperGetMV("MV_APRCINV",.F.,.F.) //- Fluxo Inverso de Aprovação de Contrato

//- Parametros de aprovação por entidade contabil referente a Medição.
Local nAprMDEC	:= SuperGetMV("MV_APRMDEC",.F.,0 )	 //- Aprovação de Medição por Entidade Contábil 0-Desativado; 1-Compra; 2-Venda; 3-Todos
Local lAprMInv	:= SuperGetMV("MV_APRMINV",.F.,.F.) //- Fluxo Inverso de Aprovação de Medição

//- Variaveis de tratamento de tipos de contrato
Local cAprTipRev:= Cn300RetSt("TIPREV",,,CnGetCtNum(cNumDoc,cTipDoc))
Local lCompra	:= .F.

//- Variaveis de tratativa de cadastro de tipo de alçada
Local lAlcCtDoc	:= .T.		//- Contrato com alçada de documento
Local lAlcCtEc	:= .T.		//- Contrato com alçada de entidade contábil

//- Variaveis de tratamento para compatibilização com aHead e aCols
Local aHeadItem	:= {}
Local aColsItem	:= {}
Local aHeadRat	:= {}
Local aColsRat	:= {}
Local aHeadS 	:= {}
Local aColsS	:= {}

//- Variavis de tratamento de modelos de contrato
Local oModelCN9	:= Nil
Local oModelCNA	:= Nil
Local oModelCNB	:= Nil
Local oModelCNZ	:= Nil

Local nX		:= 0
Local nQtdSCR 	:= 0

Local cCNZFil 	:= ""
Local cSCRFil	:= ""
Local cFilBkp	:= cFilAnt
Local cFilCtr	:= cFilAnt

Local lRet 		:= .T.
Local oModelSCR := FwModelActive()
Local lTemAlcCTB := .F.
Local lLiberaAlc := .F.
Local lGerouAlcE := .F.
Local cTipoSCR 	 := ""
Local cNumDocAux := ""
Local aRecnosEst := {}
Local lCnAlcFlg	 := ExistBlock("CnAlcFlg") 	 // Função Fluig (descontinuado)
Local lFCnAlcFlg := FindFunction("CnAlcFlg") .And. GetRPORelease() < "12.1.033" 
Local lCNTA121 	 := .F.
Local lCnta120	 := .F.
Local lGerouAlc	 := .F.
Local lUsaEntCtb := .F.
Local aTaxMoed 	 := {}
Private nMoedaPed := NIL
Private nTxMoeda := NIL
Default aCampos := {}
Default aHeader	:= {}
Default aCols	:= {}
Default N		:= 0
Default oModel	:= NIL
Default cAprovSup := ""

//- Variaveis de segurança para não desposicionar aHead e aCols devido a FillGetDados
aHeadS	:= aClone(aHeader)
aColsS	:= aClone(aCols)

If Empty(cNumDoc)
	lRet := .F.
ElseIf oModel == NIL .AND. (Empty(nTipOpr) .AND. Empty(nOpr))
	lRet := .F.
ElseIf oModel != Nil .AND. Empty(nTipOpr)
	nTipOpr	:= oModel:GetOperation()
EndIf

If lRet
	If cTipDoc $ 'IC|CT|IR|RV'
		cFilCtr := CnFilCtr(cNumDoc)
	EndIf
	cSCRFil := xFilial('SCR', cFilCtr)

	DO CASE
		CASE cTipDoc == "CT"
			If !isInCallStack('U_MTFlgLbDoc')
				If oModel == NIL .Or. oModel:GetId() # "CNTA300|CNTA301"
					oModel := FWLoadModel(If(CN9->CN9_ESPCTR == "1","CNTA300","CNTA301"))
					oModel:SetOperation(nTipOpr)
					oModel:Activate()
				EndIf
				
				aRows	:= FWSaveRows()
				
				oModelCN9	:= oModel:GetModel("CN9MASTER")
				oModelCNA	:= oModel:GetModel("CNADETAIL")
				oModelCNB	:= oModel:GetModel("CNBDETAIL")
				oModelCNZ 	:= oModel:GetModel("CNZDETAIL")
			EndIf
			
			DO CASE
				CASE nOpr == 1 //Inclusão de Alçada CT

					aTaxMoed  := TaxMoed(oModel)
					nMoedaPed := aTaxMoed[1]//Tipo da moeda
					nTxMoeda  := aTaxMoed[2]//Taxa da moeda de acordo com o dia

					cFilCtr		:= oModelCN9:GetValue("CN9_FILCTR")
					cFilAnt		:= cFilCtr //Os documentos devem ser gerados na filial de origem do contrato
					lAlcCtDoc := Cn300RetSt("ALCCTDOC",0,,oModelCN9:GetValue("CN9_NUMERO"),cFilCtr,.T.) .And. !Empty(oModelCN9:GetValue("CN9_APROV"))
					lAlcCtEc  := Cn300RetSt("ALCCTEC" ,0,,oModelCN9:GetValue("CN9_NUMERO"),cFilCtr,.T.)
					lCompra	  := Cn300RetSt("COMPRA"  ,0,,oModelCN9:GetValue("CN9_NUMERO"),cFilCtr,.T.)

					If !lAprCInv .And. lAlcCtEc .And. ( ((nAprCTEC == 1 .Or. nAprCTEC == 3) .And. lCompra) .Or. ((nAprCTEC == 2 .Or. nAprCTEC == 3) .And. !lCompra) )
						For nX := 1 To oModelCNA:Length()
							aHeadRat := {}
							aColsRat := {}
							aHeadItem := {}
							aColsItem := {}
							oModel:GetModel('CNADETAIL'):GoLine(nX)

							cSeek 	:= xFilial("CNZ")+oModelCN9:GetValue("CN9_NUMERO")+oModelCN9:GetValue("CN9_REVISA")+oModelCNA:GetValue("CNA_NUMERO")
							bWhile := {|| CNZ->(CNZ_FILIAL+CNZ_CONTRA+CNZ_REVISA+CNZ_CODPLA)}
							FillGetDados(1,'CNZ',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadRat,aColsRat, , ,)

							cSeek 	:= xFilial("CNB")+oModelCN9:GetValue("CN9_NUMERO")+oModelCN9:GetValue("CN9_REVISA")+oModelCNA:GetValue("CNA_NUMERO")
							bWhile := {|| CNB->(CNB_FILIAL+CNB_CONTRA+CNB_REVISA+CNB_NUMERO)}
							FillGetDados(1,'CNB',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadItem,aColsItem, , ,)

							If MaEntCtb("CNB","CNZ",cNumDoc,"IC",aHeadItem,aColsItem,aHeadRat,aColsRat,1,dDataBase)
								cTipDoc := "IC"
								lRet := .F.
							EndIf
						Next nX
						
						If lRet .And. lAlcCtDoc
							lRet := MaAlcDoc(aCampos[1],dDataBase,1,"",.F.)
						EndIf
					Else
						If lAlcCtDoc
							lRet := MaAlcDoc(aCampos[1],dDataBase,1,"",.F.)
						EndIf
						
						If lRet .And. lAprCInv .And. lAlcCtEc .And. (((nAprCTEC == 1 .Or. nAprCTEC == 3) .And. lCompra) .Or. ((nAprCTEC == 2 .Or. nAprCTEC == 3) .And. !lCompra))
							If !(isInCallStack('U_MTFlgLbDoc') .Or. isInCallStack('MTFlgLbDoc'))
								For nX := 1 To oModelCNA:Length()
									aHeadRat := {}
									aColsRat := {}
									aHeadItem := {}
									aColsItem := {}
									oModel:GetModel('CNADETAIL'):GoLine(nX)

									cSeek 	:= xFilial("CNZ")+oModelCN9:GetValue("CN9_NUMERO")+oModelCN9:GetValue("CN9_REVISA")+oModelCNA:GetValue("CNA_NUMERO")
									bWhile := {|| CNZ->(CNZ_FILIAL+CNZ_CONTRA+CNZ_REVISA+CNZ_CODPLA)}
									FillGetDados(1,'CNZ',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadRat,aColsRat, , ,)

									cSeek 	:= xFilial("CNB")+oModelCN9:GetValue("CN9_NUMERO")+oModelCN9:GetValue("CN9_REVISA")+oModelCNA:GetValue("CNA_NUMERO")
									bWhile := {|| CNB->(CNB_FILIAL+CNB_CONTRA+CNB_REVISA+CNB_NUMERO)}
									FillGetDados(1,'CNB',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadItem,aColsItem, , ,)

									If MaEntCtb("CNB","CNZ",cNumDoc,"IC",aHeadItem,aColsItem,aHeadRat,aColsRat,1,dDataBase)
										cTipDoc := "IC"
										lRet := .F.
									EndIf
								Next nX
							Else
								CNA->(DbSeek(xFilial("CNA")+CN9->CN9_NUMERO+CN9->CN9_REVISA ))
								While (xFilial("CNA")+CNA->CNA_CONTRA+CNA->CNA_REVISA) == (xFilial("CNA")+CN9->CN9_NUMERO+CN9->CN9_REVISA )
									aHeadRat := {}
									aColsRat := {}
									aHeadItem := {}
									aColsItem := {}

									cSeek 	:= xFilial("CNZ")+CN9->(CN9_NUMERO+CN9_REVISA)+CNA->CNA_NUMERO
									bWhile := {|| CNZ->(CNZ_FILIAL+CNZ_CONTRA+CNZ_REVISA+CNZ_CODPLA)}
									FillGetDados(1,'CNZ',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadRat,aColsRat, , ,)

									cSeek 	:= xFilial("CNB")+CN9->(CN9_NUMERO+CN9_REVISA)+CNA->CNA_NUMERO
									bWhile := {|| CNB->(CNB_FILIAL+CNB_CONTRA+CNB_REVISA+CNB_NUMERO)}
									FillGetDados(1,'CNB',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadItem,aColsItem, , ,)

									If MaEntCtb("CNB","CNZ",cNumDoc,"IC",aHeadItem,aColsItem,aHeadRat,aColsRat,1,dDataBase)
										cTipDoc := "IC"
										lRet := .F.
									EndIf
								EndDo
							EndIf
						EndIf
					EndIf
				
				CASE nOpr == 4 //Aprovação de Alçada CT
					cFilAnt		:= CN9->CN9_FILCTR //Os documentos devem ser gerados na filial de origem do contrato
					lAlcCtEc	:= Cn300RetSt("ALCCTEC", 0,, CN9->CN9_NUMERO, CN9->CN9_FILCTR, .F.)
					lCompra		:= Cn300RetSt("COMPRA" , 0,, CN9->CN9_NUMERO, CN9->CN9_FILCTR, .F.)
					lTemAlcCTB	:= lAlcCtEc .And. ( ( (nAprCTEC == 1 .Or. nAprCTEC == 3) .And. lCompra )  .Or. ( ( nAprCTEC == 2 .Or. nAprCTEC == 3) .And. !lCompra ) )
					
					If lTemAlcCTB
						If lAprCInv
							If CNA->( MsSeek( FWxFilial("CNA") + CN9->( CN9_NUMERO + CN9_REVISA ) ) )
								aAreaSCR := SCR->( GetArea() )
								While CNA->( CNA_FILIAL + CNA_CONTRA + CNA_REVISA ) == FWxFilial("CNA") + CN9->( CN9_NUMERO + CN9_REVISA )
									aHeadRat := {}
									aColsRat := {}
									aHeadItem := {}
									aColsItem := {}
			
									cSeek := FWxFilial("CNZ") + CN9->( CN9_NUMERO + CN9_REVISA ) + CNA->CNA_NUMERO
									bWhile := {|| CNZ->( CNZ_FILIAL + CNZ_CONTRA + CNZ_REVISA + CNZ_CODPLA )}
									FillGetDados( 1, 'CNZ', 1, cSeek, bWhile, {||.T.}, , , , , , , aHeadRat, aColsRat, , , )
			
									cSeek := FWxFilial("CNB") + CN9->( CN9_NUMERO + CN9_REVISA ) + CNA->CNA_NUMERO
									bWhile := {|| CNB->( CNB_FILIAL + CNB_CONTRA + CNB_REVISA + CNB_NUMERO )}
									FillGetDados( 1, 'CNB', 1, cSeek, bWhile, {||.T.}, , , , , , , aHeadItem, aColsItem, , , )
										
									cNumDoc := Left( cNumDoc, TamSX3('CN9_NUMERO')[1] + TamSX3('CN9_REVISA')[1] )
									If MaEntCtb( "CNB", "CNZ", cNumDoc, "IC", aHeadItem, aColsItem, aHeadRat, aColsRat, 1, dDataBase )
										cTipDoc := "IC"
										lGerouAlcE := .T.
									EndIf
									CNA->( dbSkip() )
								EndDo
								RestArea( aAreaSCR )
								aSize ( aAreaSCR, 0 )
								aAreaSCR := Nil
							EndIf
							
							If lGerouAlcE
								lLiberaAlc := .F.
							Else
								lLiberaAlc := .T.
							EndIf
						Else
							lLiberaAlc := .T.
						EndIf
					Else
						lLiberaAlc := .T.
					EndIf
					
					If lLiberaAlc
						lRet := LiberaAlc( oModel, cTipDoc, cAprovSup)
					Else
						lRet := MaAlcDoc( {SCR->CR_NUM,SCR->CR_TIPO,SCR->CR_TOTAL,SCR->CR_APROV,,SCR->CR_GRUPO,,,,,SCR->CR_OBS}, dDataBase, 4 )
					EndIf
					
			ENDCASE

		CASE cTipDoc == "IC"
			DO 	CASE
			CASE nOpr == 4 //Aprovação de Alçada IC
				
				lRet := AprAlcCTB( @cTipDoc, lAprCInv, oModel, cAprovSup )
										
			ENDCASE

		CASE cTipDoc == "RV"
			If oModel == NIL .Or. oModel:GetId() # "CNTA300|CNTA301"
				If nOpr == 4
					dbSelectArea("CN9")
					CN9->(dbSetOrder(1))
					CN9->(MsSeek(xFilial("CN9")+Left(SCR->CR_NUM,TamSX3('CN9_NUMERO')[1]+TamSX3('CN9_REVISA')[1])))
					cAprTipRev := Cn300RetSt("TIPREV",,,CN9->CN9_NUMERO,CN9->CN9_FILCTR,.F.)
					A300SATpRv(cAprTipRev)//Seta a variável estática do fonte CNTA300 indicando que se trata de um aprovação de revisão
					
					oModel := FWLoadModel(If(CN9->CN9_ESPCTR == "1","CNTA300","CNTA301"))
					oModel:SetOperation(nTipOpr)
					oModel:Activate()				
				Else
					oModel := FWModelActive()
				EndIf
				
				aRows	:= FWSaveRows()
			EndIf

			oModelCN9	:= oModel:GetModel("CN9MASTER")
			oModelCNA	:= oModel:GetModel("CNADETAIL")
			oModelCNB	:= oModel:GetModel("CNBDETAIL")

			cFilCtr		:= oModelCN9:GetValue("CN9_FILCTR")
			lAlcCtDoc	:= Cn300RetSt("ALCCTDOC",0,,oModelCN9:GetValue("CN9_NUMERO"),cFilCtr,.T.) .And. !Empty(oModelCN9:GetValue("CN9_APROV"))
			lAlcCtEc	:= Cn300RetSt("ALCCTEC" ,0,,oModelCN9:GetValue("CN9_NUMERO"),cFilCtr,.T.)
			cFilAnt		:= cFilCtr //Os documentos devem ser gerados na filial de origem do contrato
			cSCRFil		:= xFilial('SCR', cFilCtr)
			
			DO CASE
			CASE nOpr == 1 //Inclusão de alçada RV

				aTaxMoed  := TaxMoed(oModel)
				nMoedaPed := aTaxMoed[1]//Tipo da moeda
				nTxMoeda  := aTaxMoed[2]//Taxa da moeda de acordo com o dia

				If !lAprCInv .And. (cAprTipRev != DEF_REV_GRAPR .Or. cAprTipRev != DEF_REV_ABERT)
					If lAlcCtEc .And. cAprTipRev $ cAprRVEC
						For nX := 1 To oModelCNA:Length()
							aHeadRat := {}
							aColsRat := {}
							aHeadItem := {}
							aColsItem := {}
							oModelCNA:GoLine(nX)

							If GeraAlcPlan(oModelCNA)
								cSeek 	:= xFilial("CNZ")+oModelCN9:GetValue("CN9_NUMERO")+oModelCN9:GetValue("CN9_REVISA")+oModelCNA:GetValue("CNA_NUMERO")
								bWhile := {|| CNZ->(CNZ_FILIAL+CNZ_CONTRA+CNZ_REVISA+CNZ_CODPLA)}
								FillGetDados(1,'CNZ',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadRat,aColsRat, , ,)

								cSeek 	:= xFilial("CNB")+oModelCN9:GetValue("CN9_NUMERO")+oModelCN9:GetValue("CN9_REVISA")+oModelCNA:GetValue("CNA_NUMERO")
								bWhile := {|| CNB->(CNB_FILIAL+CNB_CONTRA+CNB_REVISA+CNB_NUMERO)}
								FillGetDados(1,'CNB',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadItem,aColsItem, , ,)

								If !AlcDifEC(oModel,cNumDoc,aHeadItem,aColsItem,aHeadRat,aColsRat)
									cTipDoc := "IR"
									lRet := .F.
								EndIf
							EndIf
						Next nX
					EndIf
					If lRet .And. lAlcCtDoc .And. GeraAlcCtr(oModelCNA)
						MaAlcDoc(aCampos[1],dDataBase,1,"",.F.)					
					EndIf
				Else
					If lRet .And. lAlcCtDoc .And. GeraAlcCtr(oModelCNA)
						lRet := MaAlcDoc(aCampos[1],dDataBase,1,"",.F.)
					EndIf
					If lRet .And. lAlcCtEc .And. (cAprTipRev != DEF_REV_GRAPR .Or. cAprTipRev != DEF_REV_ABERT)
						For nX := 1 To oModelCNA:Length()
							aHeadRat := {}
							aColsRat := {}
							aHeadItem := {}
							aColsItem := {}
							oModelCNA:GoLine(nX)

							cSeek 	:= xFilial("CNZ")+oModelCN9:GetValue("CN9_NUMERO")+oModelCN9:GetValue("CN9_REVISA")+oModelCNA:GetValue("CNA_NUMERO")
							bWhile := {|| CNZ->(CNZ_FILIAL+CNZ_CONTRA+CNZ_REVISA+CNZ_CODPLA)}
							FillGetDados(1,'CNZ',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadRat,aColsRat, , ,)

							cSeek 	:= xFilial("CNB")+oModelCN9:GetValue("CN9_NUMERO")+oModelCN9:GetValue("CN9_REVISA")+oModelCNA:GetValue("CNA_NUMERO")
							bWhile := {|| CNB->(CNB_FILIAL+CNB_CONTRA+CNB_REVISA+CNB_NUMERO)}
							FillGetDados(1,'CNB',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadItem,aColsItem, , ,)

							If GeraAlcPlan(oModelCNA)
								If !AlcDifEC(oModel,cNumDoc,aHeadItem,aColsItem,aHeadRat,aColsRat)
									cTipDoc := "IR"
									lRet := .F.
								EndIf							
							EndIf

						Next nX
					EndIf
				EndIf
				
			CASE nOpr == 3 //Exclusão de alçada RV/IR 
			
				lRet := MaAlcDoc( aCampos[1], dDataBase, 3, "", .F. )
				If SCR->( dbSeek( cSCRFil + "IR" + cNumDoc ) )
					While SCR->( !EOF() ) .And. SCR->CR_FILIAL + SCR->CR_TIPO + Left(AllTrim(SCR->CR_NUM),Len(cNumDoc)) == cSCRFil + "IR" + cNumDoc
						lRet := MaAlcDoc( {SCR->CR_NUM,"IR",SCR->CR_TOTAL,SCR->CR_LIBAPRO,,},, 3 )
						SCR->( dbSkip() )
					EndDo
				EndIf				
			
			CASE nOpr == 4 //Aprovação de alçada RV
				
				lTemAlcCTB := lAlcCtEc .And. cAprTipRev $ cAprRVEC .And. cAprTipRev != DEF_REV_GRAPR .And. cAprTipRev != DEF_REV_ABERT
				nQtdSCR := PegaQtdSCR( SCR->CR_TIPO, SCR->CR_NUM )				
				lLiberaAlc := (nQtdSCR <= 1)
				
				If lTemAlcCTB .And. lAprCInv .And. lLiberaAlc //Se todos os documentos padrão(RV) foram aprovados, mas tiver alçada contábil, avalia entidades contábeis(IR)
					aAreaSCR := SCR->( GetArea() )
					For nX := 1 To oModelCNA:Length()
						aHeadRat := {}
						aColsRat := {}
						aHeadItem := {}
						aColsItem := {}
						oModelCNA:GoLine(nX)

						cSeek 	:= xFilial("CNZ")+oModelCN9:GetValue("CN9_NUMERO")+oModelCN9:GetValue("CN9_REVISA")+oModelCNA:GetValue("CNA_NUMERO")
						bWhile := {|| CNZ->(CNZ_FILIAL+CNZ_CONTRA+CNZ_REVISA+CNZ_CODPLA)}
						FillGetDados(1,'CNZ',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadRat,aColsRat, , ,)

						cSeek 	:= xFilial("CNB")+oModelCN9:GetValue("CN9_NUMERO")+oModelCN9:GetValue("CN9_REVISA")+oModelCNA:GetValue("CNA_NUMERO")
						bWhile := {|| CNB->(CNB_FILIAL+CNB_CONTRA+CNB_REVISA+CNB_NUMERO)}
						FillGetDados(1,'CNB',1,cSeek,bWhile,{||.T.}, , , , , , ,aHeadItem,aColsItem, , ,)

						lRet := AlcDifEC(oModel,cNumDoc,aHeadItem,aColsItem,aHeadRat,aColsRat)
						If !lRet
							lGerouAlcE := .T.
							cTipDoc := "IR"
						EndIf
					Next nX
					RestArea( aAreaSCR )
					aSize ( aAreaSCR, 0 )
					aAreaSCR := Nil
					
					lLiberaAlc := !(lGerouAlcE) //Se não gerou alçada contábil, pode liberar documento(nesse caso, tornar revisão vigente)
				EndIf
				
				If lLiberaAlc
					lRet := LiberaAlc( oModel, cTipDoc, cAprovSup )
				Else
					lRet := MaAlcDoc( {SCR->CR_NUM,SCR->CR_TIPO,SCR->CR_TOTAL,SCR->CR_APROV,,SCR->CR_GRUPO,,,,,SCR->CR_OBS}, dDataBase, 4 )
				EndIf
			
			CASE nOpr == 5 //Estorno de alçada RV/IR
						
				cTipoSCR := AllTrim(SCR->CR_TIPO)
				
				If cTipoSCR == "IR"
					aAdd( aRecnosEst, {SCR->(Recno()),5} ) //Recno para estornar o IR
					
					//Se não for o fluxo inverso, verifica os recnos para estornar/excluir os RVs gerados pós aprovação do IR
					If lRet .And. !lAprCInv 
						cNumDocAux := aCampos[1][1]
						If SCR->( msSeek( cSCRFil + "RV" + cNumDocAux ) )
							While SCR->( !EOF() ) .And. SCR->CR_FILIAL + AllTrim(SCR->CR_TIPO) + Left(AllTrim(SCR->CR_NUM),Len(cNumDocAux)) == cSCRFil + "RV" + cNumDocAux
								aAdd( aRecnosEst, {SCR->(Recno()),3} ) //Recno para excluir o RV
								SCR->( dbSkip() )
							EndDo
						EndIf
					EndIf
				ElseIf cTipoSCR == "RV"
					aAdd( aRecnosEst, {SCR->(Recno()),5} ) //Recno para estornar o RV
					
					//Se for o fluxo inverso, verifica os recnos para estornar/excluir os IRs gerados pós aprovação do RV
					If lRet .And. lAprCInv
						If SCR->( msSeek( cSCRFil + "IR" + cNumDoc ) )
							While SCR->( !EOF() ) .And. SCR->CR_FILIAL + AllTrim(SCR->CR_TIPO) + Left(AllTrim(SCR->CR_NUM),Len(cNumDoc)) == cSCRFil + "IR" + cNumDoc
								aAdd( aRecnosEst, {SCR->(Recno()),3} ) //Recno para excluir o IR
								SCR->( dbSkip() )
							EndDo
						EndIf
					EndIf
				EndIf
				
				//Realiza os estornos de todas as SCRs envolvidas
				If Len(aRecnosEst) > 0
					For nX := 1 To Len(aRecnosEst)
						SCR->( dbGoTo( aRecnosEst[nX][1] ) )					
						MaAlcDoc( { SCR->CR_NUM, SCR->CR_TIPO, SCR->CR_TOTAL, SCR->CR_LIBAPRO,, },, aRecnosEst[nX][2] )
					Next nX 
				EndIf
				
				aSize( aRecnosEst, 0 )
				aRecnosEst := Nil
			
			ENDCASE
		CASE cTipDoc == "IR"
			dbSelectArea("CN9")
			CN9->(dbSetOrder(1))
			CN9->(MsSeek(xFilial("CN9")+Left(SCR->CR_NUM,TamSX3('CN9_NUMERO')[1]+TamSX3('CN9_REVISA')[1])))
			cAprTipRev := Cn300RetSt("TIPREV",,,CN9->CN9_NUMERO,CN9->CN9_FILCTR,.F.)
			A300SATpRv(cAprTipRev)//Seta a variável estática do fonte CNTA300 indicando que se trata de um aprovação de revisão
			
			If oModel == NIL .Or. oModel:GetId() # "CNTA300|CNTA301"
				oModel := FWLoadModel(If(CN9->CN9_ESPCTR == "1","CNTA300","CNTA301"))
				oModel:SetOperation(nTipOpr)
				oModel:Activate()
			ElseIf !oModel:IsActive()
				oModel:Activate()
			EndIf
			aRows	:= FWSaveRows()		

			DO CASE
			CASE nOpr == 4 //Aprovação de alçada IR
				
				lRet := AprAlcCTB( @cTipDoc, lAprCInv, oModel, cAprovSup )
				
			ENDCASE

		CASE cTipDoc == "MD"
			cCNZFil := xFilial('CNE') //- Variavel preenchida devido gestão corporativa.        

			lCNTA121 := (FwIsInCallStack('CNTA121') .Or. FwIsInCallStack('CN121AlcMd')).And. !FwIsInCallStack('CN121OldMd')
			lCnta120 := (FwIsInCallStack('CNTA120') .Or. Cn121OriMd('CNTA120'))

			If lCNTA121
				If oModel == NIL .Or. oModel:GetId() # "CNTA121"
					oModel := FWModelActive()
				EndIf
				oModelCND	:= oModel:GetModel("CNDMASTER")
				oModelCXN	:= oModel:GetModel("CXNDETAIL")
				oModelCNE	:= oModel:GetModel("CNEDETAIL")
				oModelCNZ 	:= oModel:GetModel("CNZDETAIL")			
				lCompra := Cn300RetSt("COMPRA", 0,, oModelCND:GetValue('CND_CONTRA'), oModelCND:GetValue('CND_FILCTR'), .F.)
			Else
				lCompra := Cn300RetSt("COMPRA", 0,, CND->CND_CONTRA, CND->CND_FILCTR, .F.)
				nAprMDEC	:= 0//- Proteção para não execução de aprovações por entidades contábeis na medição proveniente do fonte CNTA120
				lAprMInv	:= .F.
			EndIf
			
			aRows	:= FWSaveRows()
			
			DO CASE
				CASE nOpr == 1 .And. lCNTA121 //Inclusão de alçada MD (CNTA121)
					lUsaEntCtb	:= (nAprMDEC == 3) .Or. (nAprMDEC == 1 .And. lCompra) .Or. (nAprMDEC == 2 .And. !lCompra)

					If 	lUsaEntCtb .And. !lAprMInv //Fluxo normal(Entidade depois Padrão)
						If !(lGerouAlc := EntCtbTpIM(oModel, cNumDoc))//Gera alçada por entidade caso necessário
							If GeraDocMD(oModelCXN) //Verifica se deve gerar alçada padrão
								lGerouAlc := !(MaAlcDoc(aCampos[1],dDataBase,1,"",.F.))
							EndIf
						EndIf
					Else//Fluxo inverso(Padrão depois Entidade)
						If GeraDocMD(oModelCXN) //Verifica se deve gerar alçada padrão
							lGerouAlc := !(MaAlcDoc(aCampos[1],dDataBase,1,"",.F.))					
						Else
							lGerouAlc := .F.
						EndIf

						If !lGerouAlc .And. lUsaEntCtb .And. lAprMInv
							lGerouAlc := EntCtbTpIM(oModel, cNumDoc)//Gera alçada por entidade caso necessário					
						EndIf
					EndIf
					
					lRet := !lGerouAlc
					If lGerouAlc //Se gerou alçada, deve bloquear a CND
						BloqCNDSit(oModelCND)//Atualiza situacao da medicao p/ bloqueada
					ElseIf (oModelCND:GetValue("CND_SITUAC") == "B" .Or. oModelCND:GetValue("CND_ALCAPR") == "B")  
						oModelCND:LoadValue("CND_SITUAC", "A") // caso seja apagado o grupo de aprovação de uma medição que anteriormente estava em alçada, libera os campos referentes a situação
						oModelCND:LoadValue("CND_ALCAPR", "L")
					EndIf
				CASE nOpr == 1 .And. lCnta120 //Inclusão de alçada MD (CNTA120)

					lRet := MaAlcDoc(aCampos[1],dDataBase,1,"",.F.)
					
					If !lRet
						BloqCNDSit()//Atualiza situacao da medicao p/ bloqueada
					EndIf
				CASE nOpr == 3 //Exclusão
					lRet := MaAlcDoc(aCampos[1],dDataBase,3,"",.F.)
					If SCR->(dbSeek(cSCRFil+"IM"+cNumDoc))
						While !SCR->(EOF()) .AND. SCR->(CR_FILIAL+CR_TIPO+Left(alltrim(SCR->CR_NUM),Len(cNumDoc))) == cSCRFil+"IM"+cNumDoc
							MaAlcDoc({SCR->CR_NUM,"IM",SCR->CR_TOTAL,SCR->CR_LIBAPRO,,},,3)
							SCR->(dbSkip())
						EndDo
					EndIf

				CASE nOpr == 4 //Aprovação de alçada MD
					If 	(((nAprMDEC == 1 .Or. nAprMDEC == 3) .And. lCompra) .Or. ;
						((nAprMDEC == 2 .Or. nAprMDEC == 3) .And. !lCompra)) .And. lAprMInv

						lRet := MaAlcDoc({SCR->CR_NUM,SCR->CR_TIPO,SCR->CR_TOTAL,SCR->CR_APROV,,SCR->CR_GRUPO,,,,,SCR->CR_OBS},dDataBase,4)
						CXN->(dbSetOrder(1))

						If lRet
							If CXN->(MsSeek(xFilial("CXN")+CND->(CND_CONTRA+CND_REVISA+CND_NUMMED)))
								While CXN->(CXN_FILIAL+CXN_CONTRA+CXN_REVISA+CXN_NUMMED)==xFilial("CXN")+CND->(CND_CONTRA+CND_REVISA+CND_NUMMED)
									aHeadRat  := {}
									aColsRat  := {}
									aHeadItem := {}
									aColsItem := {}

									If CXN->CXN_CHECK .AND. Cn300RetSt('ALCMDEC',0,CXN->CXN_NUMPLA,CXN->CXN_CONTRA,CND->CND_FILCTR)
										cSeek 	:= xFilial("CNE")+CXN->(CXN_CONTRA+CXN_REVISA+CXN_NUMPLA)+CND->(CND_NUMMED)
										bWhile := {|| CNE->(	CNE_FILIAL+CNE_CONTRA+CNE_REVISA+CNE_NUMERO+CNE_NUMMED)}
										FillGetDados(2,'CNE',1,cSeek,bWhile,{||.T.}, , , , , ,.F.,aHeadItem,aColsItem, , ,)

										//- Busca Rateio da Medição
										cSeek 	:= cCNZFil+CXN->(CXN_CONTRA+CXN_REVISA)+CND->(CND_NUMMED)+CXN->(CXN_NUMPLA)
										bWhile := {|| CNZ->(CNZ_FILIAL+CNZ_CONTRA+CNZ_REVISA+CNZ_NUMMED+CNZ_CODPLA)}
										FillGetDados(2,'CNZ',5,cSeek,bWhile,{||.T.}, , , , , ,.F.,aHeadRat,aColsRat, , ,)

										//- Laço para impedir rateio com percentual 0
										nX := 1
										While nX <= Len(aColsRat)
											If aColsRat[1][aScan(aHeadRat,{|x| Alltrim(x[2]) == "CNZ_PERC"})] == 0
												aDel(aColsRat,nX)
												aSize(aColsRat,Len(aColsRat)-1)
											Else
												nX++
											EndIf
										EndDo
										cNumDoc := Left(cNumDoc,TamSX3('CND_NUMMED')[1])
										If MaEntCtb("CNE","CNZ",cNumDoc,"IM",aHeadItem,aColsItem,aHeadRat,aColsRat,1,dDataBase)
											lRet := .F.
										EndIf
									EndIf
									CXN->(dbSkip())
								EndDo
							Else
								cSeek := xFilial("CNE")+CND->(CND_CONTRA+CND_REVISA+CND_NUMERO+CND_NUMMED)
								bWhile := {|| CNE->(CNE_FILIAL+CNE_CONTRA+CNE_REVISA+CNE_NUMERO+CNE_NUMMED)}
								FillGetDados(1,'CNE',1,cSeek,bWhile,{||.T.}, , , , , ,.F.,aHeadItem,aColsItem, , ,)

								//- Busca Rateio da Medição
								cSeek 	:= xFilial("CNZ")+CND->(CND_CONTRA+CND_REVISA+CND_NUMMED)
								bWhile := {|| CNZ->(CNZ_FILIAL+CNZ_CONTRA+CNZ_REVISA+CNZ_NUMMED)}
								FillGetDados(1,'CNZ',2,cSeek,bWhile,{||.T.}, , , , , ,.F.,aHeadRat,aColsRat, , ,)

								//- Laço para impedir rateio com percentual 0
								nX := 1
								While nX <= Len(aColsRat)
									If aColsRat[1][aScan(aHeadRat,{|x| Alltrim(x[2]) == "CNZ_PERC"})] == 0
										aDel(aColsRat,nX)
										aSize(aColsRat,Len(aColsRat)-1)
									Else
										nX++
									EndIf
								EndDo
								If MaEntCtb("CNE","CNZ",cNumDoc,"IM",aHeadItem,aColsItem,aHeadRat,aColsRat,1,dDataBase)
									lRet := .F.
								EndIf
							EndIf

							If lRet
								lRet := LiberaAlc( oModel, cTipDoc, cAprovSup )
							EndIf
						EndIf
					Else
						lRet := LiberaAlc( oModel, cTipDoc, cAprovSup )
					EndIf
			ENDCASE

		CASE cTipDoc == "IM"
			CND->(MsSeek(cSCRFil+Left(AllTrim(SCR->CR_NUM),TAMSX3('CND_NUMMED')[1])))

			DO CASE
			CASE nOpr == 4 //Aprovação de alçada IM
				MaAlcDoc({SCR->CR_NUM,SCR->CR_TIPO,SCR->CR_TOTAL,SCR->CR_APROV,,SCR->CR_GRUPO,,,,,SCR->CR_OBS},dDataBase,4)
				If lAprMInv
					If MtGLastDBM(SCR->CR_TIPO,SCR->CR_NUM)
						LiberaAlc( oModel, cTipDoc, cAprovSup )
					EndIf
				Else
					If MtGLastDBM(SCR->CR_TIPO, SCR->CR_NUM,,, SCR->CR_GRUPO, SCR->CR_ITGRP)
						If PegaQtdSCR(SCR->CR_TIPO, SCR->CR_NUM) == 0
							If CN300RetSt('ALCMDDOC',2,/**/,CND->CND_CONTRA,CND->CND_FILCTR)
								aAdd(aCampos,{CND->CND_NUMMED,"MD",CND->CND_VLTOT,""	,"",CND->CND_APROV,"",CND->CND_MOEDA,0,dDataBase,""})
								lRet := MaAlcDoc(aCampos[1],dDataBase,1,"",.F.)
							EndIf

							If lRet
								LiberaAlc( oModel, cTipDoc, cAprovSup )
							EndIf
						EndIf
					EndIf
				EndIf
			ENDCASE

		OTHERWISE
			MsgAlert(STR0075)
			lRet := .F.
	ENDCASE
EndIf

If (cFilAnt != cFilBkp)
	cFilAnt := cFilBkp //Restaura filial
EndIf

If lAglFlg .And. !lRet .And. (cTipDoc $ "CT|IC" .Or. (Type("aFluigIR") <> "U" ;
.And. Len(aFluigIR) > 0 .And. !IsInCallStack("Cn300Grv")))
	If Type("aFluigIR") <> "U" .And. Len(aFluigIR) > 0
		For nX := 1 To Len(aFluigIR)
			If lCnAlcFlg
				ExecBlock("CnAlcFlg", .F., .F., {aFluigIR[nX],cNumRev,cTipDoc})
			Elseif lFCnAlcFlg
				CnAlcFlg(aFluigIR[nX],cNumRev,cTipDoc)
			Endif	
		Next nI
	Else
		If lCnAlcFlg
			ExecBlock("CnAlcFlg", .F., .F., {cNumDoc,cNumRev,cTipDoc})
		Elseif lFCnAlcFlg
			CnAlcFlg(cNumDoc,cNumRev,cTipDoc)
		Endif		
	Endif
ElseIf !lRet .And. cTipDoc == "RV" .And. IsInCallStack('LiberaAlc') .And. (cAprTipRev == DEF_REV_GRAPR .Or. cAprTipRev == DEF_REV_ABERT)
	If lCnAlcFlg
		ExecBlock("CnAlcFlg", .F., .F., {oModelCN9:GetValue("CN9_NUMERO"),oModelCN9:GetValue("CN9_REVISA"),"RV"})
	Elseif lFCnAlcFlg
		CnAlcFlg(oModelCN9:GetValue("CN9_NUMERO"),oModelCN9:GetValue("CN9_REVISA"),"RV")
	Endif	
EndIf

aHeader	:= aClone(aHeadS)
aCols	:= aClone(aColsS)

If Len(aRows) > 0
	FWRestRows(aRows)
	FwFreeArray(aRows)
EndIf
If IsInCallstack('A094Commit')
	oModelSCR:Activate()
	If (cTipDoc $ 'IC|CT|IR|RV')
		CNT300Rese() //Reinicializa as variáveis estáticas.
	EndIf
EndIF
RestArea(aArea)

If ValType(oModel) == "O" .And. oModel:HasErrorMessage()
	
	_aErroAlc	:= oModel:GetErrorMessage()
	
EndIf

Asize(aTaxMoed,0)//zeragem do array
aTaxMoed := nil

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GCTAltEC(oModel,cTable,cDetail,cDoc,cRevVig,nIndice,bSeek)
Verifica se foram alterados cronograma Fisico, cronograma Financeiro e
itens das planilhas na revisão de um contrato.

Parametros:
oModel		Modelo ativo.
cTable		Tabela na qual ser?realizada a comparação.
cDetail	Modelo que contem o detalhe da tabela que ser?utilizada.
cDoc		Numero do documento.
cRevVig	Revisão vigente antes da alteração.
nIndice	Indice da tabela que ser?utilizado na pesquisa.
bSeek		Bloco de código contendo condição de pesquisa para ser realizada a comparação (normalmente o indice)
aNotComp	Array de campos que devem ser desconsiderados na comparação

Exemplo:
GCTAltEC(oModel,'CNF','CNFDETAIL','XXXXXXXXXX','YYY',3, {|| xFilial("CNF")+cDoc+cRevVig+oDetail:GetValue("CNF_NUMERO")+oDetail:GetValue("CNF_PARCEL")}})

@author Israel Escorizza
@since 14/05/2015
@version 1.0
@return aRet

/*/
//-------------------------------------------------------------------
Function GCTAltEC(oModel,cTable,cDetail,cDoc,cRevVig,nIndex,bSeek,aNotComp)
Local cCampo		:= ""	//- Campo comparado
Local aHead		:= {}	//- Header da tabela a ser comparada.
Local aAlter		:= {} 	//- {Campo,Valor Original, Valor Novo}
Local aRet			:= {} 	//- {Linha do modelo, {aAlter}}
Local nL			:= 0	//- Variavel de controle da linha
Local nC			:= 0	//- Variavel de controle do campo

Local lAprCInv	:= SuperGetMV("MV_APRCINV",.F.,.F.) //- Fluxo Inverso de Aprovação de Contrato
Local oDetail	:= Nil
Local lContinua := .T.

Default oModel  := FwModelActive()
Default cRevVig := CnGetRevVg(cDoc)
Default aNotComp := {}

IIF (Empty(cTable) .OR. Empty(bSeek), lContinua := .F.,)
IIf (Empty(cDetail), lContinua := .F., oDetail := oModel:GetModel(cDetail))

If lContinua
	((cTable))->(dbSetOrder(nIndex))
	aHead := oDetail:GetStruct():GetFields()
	For nL := 1 to oDetail:Length()
		If oDetail:IsUpdated(nL) .OR. lAprCInv
			oDetail:GoLine(nL)
			If (cTable)->(MsSeek(Eval(bSeek)))
				For nC := 1 to Len(aHead)
					cCampo := Alltrim(aHead[nC][MODEL_FIELD_IDFIELD])
					If !(aHead[nC][MODEL_FIELD_VIRTUAL]).AND. oDetail:GetValue(cCampo) <> (cTable)->(&cCampo)
						If !Empty(aNotComp) .AND. !aScan(aNotComp, cCampo)
							aAdd(aAlter,{cCampo,(cTable)->(&cCampo),oDetail:GetValue(cCampo)})
						EndIf
					EndIf
				Next nC			
			ElseIf lAprCInv .AND. !Empty(oDetail:GetValue((cTable)+Iif(cTable == 'CNB',"_PRODUT","_PARCEL")))
				For nC := 1 to Len(aHead)
					cCampo := Alltrim(aHead[nC][MODEL_FIELD_IDFIELD])
					If !Empty(aNotComp) .AND. !aScan(aNotComp, cCampo) .AND. !(aHead[nC][MODEL_FIELD_VIRTUAL])
						aAdd(aAlter,{cCampo,(cTable)->(&cCampo),oDetail:GetValue(cCampo)})
					EndIf
				Next nC
			ElseIf cTable == "CNB"
				For nC := 1 to Len(aHead)
					cCampo := Alltrim(aHead[nC][MODEL_FIELD_IDFIELD])
					If !(aHead[nC][MODEL_FIELD_VIRTUAL])
						If !Empty(aNotComp) .AND. !aScan(aNotComp, cCampo)
							aAdd(aAlter,{cCampo,(cTable)->(&cCampo),oDetail:GetValue(cCampo)})
						EndIf
					EndIf
				Next nC
			EndIf
			If Len(aAlter)
				aAdd(aRet,{nL,aAlter})
				aAlter := {}
			EndIf
		EndIf
	Next nL
EndIf

Return aRet


//-------------------------------------------------------------------
/*/{Protheus.doc} AlcDifEC(oModel,cNumDoc,aHeadCNB,aColsCNB)
Gera alçada por entidade contabil somente para itens alterados

Parametros:
oModel		Modelo ativo.
cNumDoc	Numero do documento.
aHeadCNB	Cabeçalho 	CNB	(Itens da Planilha)
aColsCNB	Colunas 	CNB	(Itens da Planilha)
aHeadCNZ	Cabeçalho	CNZ	(Rateio)
aColsCNZ	Colunas	    CNZ	(Rateio)

@author Israel Escorizza
@since 09/06/2015
@version 1.0
@return lRet

/*/
//-------------------------------------------------------------------
Function AlcDifEC(oModel,cNumDoc,aHeadCNB,aColsCNB,aHeadCNZ,aColsCNZ)
	Local lRet			:= .T.
	Local lMantem		:= .F.
	Local oModelCNS 	:= oModel:GetModel("CNSDETAIL")
	Local oModelCNB 	:= oModel:GetModel("CNBDETAIL")
	Local aChangeCNF 	:= {}
	Local aChangeCNS 	:= {}
	Local aChangeCNB 	:= {}
	Local aColsCNBBk	:= AClone(aColsCNB)
	Local aColsCNZBk	:= AClone(aColsCNZ)
	Local cChaveB		:= ""
	Local cChaveZ		:= ""
	Local nC			:= 1
	Local nD			:= 0
	Local nTamContra	:= TamSX3('CN9_NUMERO')[1]
	Local aChvIndCNB	:= {}
	Local aChvIndCNZ	:= {}
	Local cContra		:= ""
	Local cRevisa		:= ""
	Local cPlanilha		:= ""
	Local bSeek			:= {||}

	//- Ajusta tamanho da variavel para ser compativel com tamanho do documento de aprovação.
	cNumDoc		:= Left(cNumDoc,nTamContra+TamSX3('CN9_REVISA')[1])
	cContra		:= oModel:GetValue("CN9MASTER" 	, "CN9_NUMERO")
	cRevisa		:= oModel:GetValue("CN9MASTER" 	, "CN9_REVISA")
	cPlanilha	:= oModel:GetValue("CNADETAIL"	, "CNA_NUMERO")

	bSeek 		:= {|| xFilial("CNF")+cDoc+cRevVig+oDetail:GetValue("CNF_NUMERO")+oDetail:GetValue("CNF_PARCEL")}
	aChangeCNF	:= GCTAltEC(oModel,'CNF','CNFDETAIL',cContra,,3,bSeek,{"CNF_REVISA"}) //Obtem alteracoes no cronograma financeiro(CNF)

	If (Len(aChangeCNF) > 0) //- Verifica se foi realizada alteração no cronograma financeiro (CNF)
		
		AjsCNBVal(aHeadCNB, aColsCNB, cContra)/*Ajusta valores da CNB de acordo com os parâmetros da revisoes*/

		If MaEntCtb("CNB","CNZ",cNumDoc,"IR",aHeadCNB,aColsCNB,aHeadCNZ,aColsCNZ,1,dDataBase)
			lRet := .F.
		EndIf
	Else
		
		bSeek := {|| xFilial("CNS")+cDoc+cRevVig+oDetail:GetValue("CNS_CRONOG")+oDetail:GetValue("CNS_PARCEL")+oDetail:GetValue("CNS_ITEM")}
		aChangeCNS := GCTAltEC(oModel,'CNS','CNSDETAIL',cContra,,1,bSeek,{"CNS_REVISA"}) //- Obtem alterações no cronograma fisico (CNS)
		
		bSeek := {|| xFilial("CNB")+cDoc+cRevVig+oDetail:GetModel():GetValue("CNADETAIL", "CNA_NUMERO")+oDetail:GetValue("CNB_ITEM")}
		aChangeCNB := GCTAltEC(oModel,'CNB','CNBDETAIL',cContra,,1,bSeek,{"CNB_REVISA","CNB_PRCORI","CNB_QTDORI", "CNB_DTANIV"}) //- Obtem alterações nos itens (CNB).

		aChvIndCNB := {	aScan(aHeadCNB, {|x| Alltrim(x[2]) == 'CNB_CONTRA'}),;
						aScan(aHeadCNB, {|x| Alltrim(x[2]) == 'CNB_REVISA'}),;
						aScan(aHeadCNB, {|x| Alltrim(x[2]) == 'CNB_NUMERO'}),;
						aScan(aHeadCNB, {|x| Alltrim(x[2]) == 'CNB_ITEM'})}	
			
		While nC <= Len(aColsCNB)/*	<aColsCNB> contêm os dados dos registros da revisão atual. */
			lMantem := .F.
			cChaveB := ""
			aEval(aChvIndCNB, {|x| cChaveB += aColsCNB[nC, x] })//- Monta Posicionamento dos campos chave no aHeadCNB

			For nD := 1 to Len(aChangeCNS) //Verifica se houve mudanças no cronograma físico
				oModelCNS:GoLine(aChangeCNS[nD][1])
				If cChaveB == oModelCNS:GetValue("CNS_CONTRA")+oModelCNS:GetValue("CNS_REVISA")+oModelCNS:GetValue("CNS_PLANI")+oModelCNS:GetValue("CNS_ITEM")
					lMantem := .T.
				EndIf
			Next nD

			If !lMantem
				For nD := 1 to Len(aChangeCNB)
					oModelCNB:GoLine(aChangeCNB[nD,1])
					/*Verifica se a linha atual da aCols é uma das linhas do modelo que foram modificadas(contidas em <aChangeCNB>).*/
					If (cChaveB == cContra+cRevisa+cPlanilha+oModelCNB:GetValue("CNB_ITEM")) .OR. oModelCNB:IsInserted()
						lMantem := .T.			
					EndIf
				Next nD
			EndIf
			
			If !lMantem
				aDel(aColsCNB,nC)
				aSize(aColsCNB,Len(aColsCNB)-1)
			Else
				nC++
			EndIf
		EndDo

		aChvIndCNZ := {	aScan(aHeadCNZ, {|x| Alltrim(x[2]) == 'CNZ_CONTRA'}),;
						aScan(aHeadCNZ, {|x| Alltrim(x[2]) == 'CNZ_REVISA'}),;
						aScan(aHeadCNZ, {|x| Alltrim(x[2]) == 'CNZ_CODPLA'}),;
						aScan(aHeadCNZ, {|x| Alltrim(x[2]) == 'CNZ_ITCONT'})}	
		nC:= 1
		While nC <= Len(aColsCNZ)
			lMantem := .F.
			cChaveZ := ""
			aEval(aChvIndCNZ, {|x| cChaveZ += aColsCNZ[nC, x] })
			
			For nD := 1 To Len(aColsCNB)
				cChaveB := ""
				aEval(aChvIndCNB, {|x| cChaveB += aColsCNB[nD, x] })

				If cChaveB == cChaveZ
					lMantem := .T.
				EndIf
			Next nD
			If !lMantem
				aDel(aColsCNZ,nC)
				aSize(aColsCNZ,Len(aColsCNZ)-1)
			Else
				nC++
			EndIf
		EndDo
	
		If Empty(aColsCNB) // Caso nenhum item tenha sofrido alteração, envia todos os itens para que possa ser gerada a alçada de aprovação
			aColsCNZ := AClone(aColsCNZBk)
		EndIf
			
		AjsCNBVal(aHeadCNB, aColsCNB, oModel:GetValue("CN9MASTER", "CN9_NUMERO"), aColsCNBBk)/*Ajusta valores da CNB de acordo com os parâmetros da revisoes*/

		If MaEntCtb("CNB","CNZ",cNumDoc,"IR",aHeadCNB,aColsCNB,AHeadCNZ,aColsCNZ,1,dDataBase)
			lRet := .F.
		EndIf
	EndIf

	FwFreeArray(aColsCNBBk)
	FwFreeArray(aColsCNZBk)
	FwFreeArray(aChangeCNF)
	FwFreeArray(aChangeCNS)
	FwFreeArray(aChangeCNB)
	FwFreeArray(aChvIndCNB)
	FwFreeArray(aChvIndCNZ)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MTBlcVld
	Função para montar valid customizado em rotinas MVC
@author Alexandre Gimenez
@since 15/12/2015
@version 1.0
@param cAlias, caractere, tabela de <cField>(não utilizado, descontinuado)
@param cField, caractere, nome do campo que deve ser considerado na validação
@param cValid, caractere, validação a ser utilizada na construção do bloco de valid
@param lAddX3Valid	, lógico, informa se considera o X3_VALID(se falso, sobrescreve totalmente o valid do dicionário)
@param lOnlyVld		, lógico, não adiciona funções do framework no bloco de validação(só tem propósito se <lBuildFeat> for falso)
@param lBuildFeat	, lógico, utiliza o método <FWBuildFeature> para criação do bloco de validação(sempre que possível, utilizar essa opção como .T.)
@return bRet, code-block, bloco de validação de <cField>
/*/
//-------------------------------------------------------------------
Function MTBlcVld(cAlias,cField,cValid,lAddX3Valid,lOnlyVld, lBuildFeat)
	Local aAreaSX3	:= SX3->(GetArea())
	Local cBloco 	:= ""
	Local cVldUser	:= AllTrim(Posicione("SX3",2,cField,"X3_VLDUSER"))
	Local cX3Valid	:= AllTrim(Posicione("SX3",2,cField,"X3_VALID"))
	Local bRet
	Local cFinalVld	:= ""
	Local nTamanho 	:= 3
	Local aValids 	:= {}
	Local nX 		:= 0

	Default cValid		:= cX3Valid
	Default lAddX3Valid	:= .F.
	Default lOnlyVld	:= .F.
	Default lBuildFeat	:= .F.

	If lAddX3Valid .And. !Empty(cX3Valid)//Nesse cenário, deve-se incluir a validação atual(do dicionário), ou seja, adiciona-se uma nova validação à existente
		aAdd(aValids,cX3Valid)
	EndIf

	If !Empty(cVldUser)
		aAdd(aValids,cVldUser)
	EndIf

	If !Empty(cValid)
		aAdd(aValids,cValid)
	EndIf

	nTamanho := Len(aValids)
	for nX := 1 to nTamanho
		cFinalVld += aValids[nX]
		if nX < nTamanho
			cFinalVld += ' .And. '
		endif	
	next nX

	cBloco := "{|a,b,c,d,e| "

	If lOnlyVld
		cBloco += " lRet := "
	Else
		cBloco += " FWInitCpo(a,b,c,d),lRet := "
	EndIf

	cBloco += cFinalVld

	If lBuildFeat //Nesse cenário, utiliza o método fornecido pelo framework
		bRet := FWBuildFeature( STRUCT_FEATURE_VALID, cFinalVld)
	Else
		If lOnlyVld
			cBloco	+= ",lRet}"
		Else
			cBloco += ",FWCloseCpo(a,b,c,lRet,.T.),lRet}"
		EndIf
		bRet := &(cBloco)
	EndIf

	SX3->(RestArea(aAreaSX3))
	FwFreeArray(aAreaSX3)
	FwFreeArray(aValids)
Return bRet

//-------------------------------------------------------------------
/*/{Protheus.doc} CnRejDoc(cTipDoc)
Rejeita SCR e documento gerador.

@author Israel Escorizza
@since 21/01/2016
@version 1.0
@return lRet
/*/
//-------------------------------------------------------------------
Function CnRejDoc(cTipDoc)
Local lRet 		:= .F.
Local aArea 		:= GetArea()
Local cTipo		:= ""
Local cNumDoc		:= ""
Local cFilCtr 	:= ""
Local cFilScr		:= ""
Local cQuery		:= ""
Local cTmpAlias	:= ""

Begin Transaction
	If RecLock("SCR",.F.)
		SCR->CR_DATALIB := dDataBase
		SCR->CR_USERLIB := SCR->CR_USER
		SCR->CR_LIBAPRO := SCR->CR_APROV
		SCR->CR_STATUS := "06"
		If SCR->(MsUnlock())
			//- Realiza rejeição do documento originador da aprovação.
			If cTipDoc $ "CT|IC|RV|IR"
				cTipo	 := Iif(cTipDoc $ "CT|IC" ,"'CT','IC'","'RV','IR'")
				cNumDoc := LEFT(SCR->CR_NUM,Iif(cTipDoc $ "CT|IC",TAMSX3('CN9_NUMERO')[1],TAMSX3('CN9_NUMERO')[1]+TAMSX3('CN9_REVISA')[1]))
				cFilCtr := xFilial("CN9",cFilAnt)
				cFilScr := CnFilCtr(cNumdoc)

				CN9->(dbSetOrder(1)) 		//- CN9_FILIAL+CN9_NUMERO+CN9_REVISA
				If CN9->(MsSeek(cFilCtr+cNumDoc))
					RecLock("CN9",.F.)
					CN9->CN9_SITUAC := "11"
					lRet := CN9->(MsUnlock())
				EndIf

			ElseIf cTipDoc $ "MD|IM"
				cTipo	 := "'MD','IM'"
				cNumDoc := LEFT(SCR->CR_NUM, TAMSX3('CND_NUMMED')[1])
				cFilCtr := xFilial("CND",cFilAnt)
				cFilScr := xFilial('SCR')

				CND->(dbSetOrder(4)) 		//- CND_FILIAL+CND_NUMMED
				If CND->(MsSeek(cFilCtr+cNumDoc)) .And. RecLock("CND",.F.)
					RecLock("CND",.F.)
				 	CND->CND_ALCAPR := "R"
					CND->CND_SITUAC := "R"
					lRet := CND->(MsUnlock())
				EndIf
			EndIf

			//- Realiza rejeição das alçadas que ainda não foram aprovadas.
			If lRet
				cTmpAlias := GetNextAlias()
				cQuery += " SELECT "
				cQuery += " SCR.R_E_C_N_O_ "
				cQuery += " FROM	"
				cQuery +=   RetSqlName("SCR")+" SCR "
				cQuery += " WHERE "
				cQuery += " SCR.CR_FILIAL 	= 		'"+cFilScr	+"'	 	AND "
				cQuery += " SCR.CR_NUM 		LIKE 	'"+cNumDoc		   	+"%'	AND "

				cQuery += " SCR.CR_TIPO		IN		("+cTipo			+")	 	AND "
				cQuery += " SCR.CR_STATUS	IN		('01','02','04')			AND "
				cQuery += " SCR.D_E_L_E_T_	= 		' '"

				cQuery  := ChangeQuery( cQuery )
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery), cTmpAlias,.T.,.T.)

				While !(cTmpAlias)->(EOF()) .And. lRet
					SCR->(MsGoto((cTmpAlias)->R_E_C_N_O_))
					If RecLock("SCR",.F.)
						SCR->CR_DATALIB := dDataBase
						SCR->CR_STATUS := "05"
						lRet := SCR->(MsUnlock()) .And. lRet
					Else
						lRet := .F.
					EndIf
					(cTmpAlias)->(DbSkip())
				EndDo
			EndIf
		EndIf
	EndIf
	If !lRet //- Valida Transação
		DisarmTransaction()
		Help(" ",1,"",,STR0076,1,1)
	EndIf
End Transaction

RestArea(aArea)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} CnGetAprDc(cNumDoc,cNumRev,cTipo)
Função que retorna o grupo de aprovador do documento (contrato)

@author Israel Escorizza
@since 26/02/2016
@version 1.0
@return lRet
/*/
//-------------------------------------------------------------------
Function CnGetAprDc(cNumDoc,cNumRev,cTipo)
Local aArea		:= GetArea()
Local aRows		:= FWSaveRows()
Local cAprovDc	:= ""

Default cNumDoc	:= ""
Default cNumRev	:= ""
Default cTipo 	:= ""

If cTipo $ "RV|IR" .And. cNumRev == ""
	cNumRev := SUBSTR(cNumDoc,TAMSX3('CN9_NUMERO')[1]+1,TAMSX3('CN9_REVISA')[1])
EndIf
cNumDoc := LEFT(cNumDoc,TAMSX3('CN9_NUMERO')[1])

dbSelectArea('CN9')
CN9->(dbSetOrder(1))
CN9->(dbSeek(xFilial("CN9",cFilAnt)+cNumDoc+cNumRev))
cAprovDc := CN9->CN9_APROV

FWRestRows(aRows)
RestArea(aArea)
Return cAprovDc

//=======================================================================
/*/{Protheus.doc} CnGetCtNum(cNumDoc,cTipo)
Função que retorna o numero de um contrato dependendo do tipo de aprovação

@author Israel Escorizza
@since 26/04/2016
@version 1.0
@return cNumCtr
/*/
//=======================================================================
Function CnGetCtNum(cNumDoc,cTipo)
Local aArea		:= GetArea()
Local aRows		:= FWSaveRows()
//Local oModel		:= FWModelActive()
Local cNumMed		:= ""
Local cNumCtr		:= ""
Local aAreaCND		:= {}

Default cNumDoc	:= ""
Default cTipo		:= ""

If cTipo $ "CT|IC"
	cNumCTR := Nil
EndIf

If cTipo $ "RV|IR"
	cNumCTR := LEFT(cNumDoc,TAMSX3('CN9_NUMERO')[1])
EndIf


If cTipo $ "MD|IM"
		cNumMed:= LEFT(cNumDoc,TAMSX3('CND_NUMMED')[1])
		dbSelectArea('CND')
		aAreaCND:= CND->(GetArea())
		CND->(dbSetOrder(4))
		CND->(dbSeek(xFilial("CND")+cNumMed))
		cNumCtr := CND->CND_CONTRA
		RestArea(aAreaCND)
EndIf

FWRestRows(aRows)
RestArea(aArea)
Return cNumCtr

//-------------------------------------------------------------------
/*/{Protheus.doc} CnListaScr(cNumDoc,cNumRev,cTipo,cWhere,lAprovado)
Função que lista todas aprovações geradas para determinado contrato/medição

Parametros:
cNumDoc	Número do documento.
cNumRev	Número da revisão.
aTipo		Array dos tipos de documento 'CT','IC','RV','IR','MD','IM' pesquisados
LAprovado	Busca registros j?aprovados
cWhere		Condição de busca para customização da query

@return	aRet	Array contendo o numero das SCRs geradas
						[1] R_E_C_N_O_ (SCR)
						[2] CR_NUM
						[3] CR_GRUPO
						[4] CR_APROV

@author 	Israel Escorizza
@since 		08/03/2016

@version 	1.0
/*/
//-------------------------------------------------------------------
Function CnListaScr(cNumDoc,cNumRev,aTipo,cWhere,lAprovado)
Local aArea		:= GetArea()
Local aRows		:= FWSaveRows()
Local aRet			:= {}

Local cNumApr		:= AllTrim(cNumDoc)+AllTrim(cNumRev)
Local cAliasSCR	:= GetNextAlias()
Local cQuery		:= ""

Local nX			:= 0

Default aTipo		:= {}
Default cWhere	:= ""
Default lAprovado	:= .F.

cQuery := " SELECT "
cQuery += " R_E_C_N_O_, CR_NUM, CR_GRUPO, CR_APROV "
cQuery += " FROM " + RetSqlName( "SCR" ) + " SCR "
cQuery += " WHERE "
cQuery += " CR_NUM LIKE '" + cNumApr + "%' "

If !Empty(aTipo) 	//- Adiciona tipos especificos de aprovação
	cQuery += " AND CR_TIPO IN ( "
	For nX := 1 To Len(aTipo)
		cQuery += "'"+aTipo[nX]+"'"
		If nX < Len(aTipo)
			cQuery += ", "
		EndIf
	Next nX
	cQuery += ") "
EndIf

If !lAprovado		//- Somente status bloqueado
	cQuery += " AND CR_STATUS = '02' "
EndIf

If !Empty(cWhere)	//- Validação variavel informada pela chamada
	cQuery += " AND " + cWhere
EndIf

cQuery += " AND D_E_L_E_T_ = ' ' "
cQuery += " ORDER BY CR_GRUPO, CR_APROV "

cQuery  := ChangeQuery( cQuery )
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery), cAliasSCR,.T.,.T.)

While !(cAliasSCR)->(Eof())
	aAdd(aRet,{(cAliasSCR)->R_E_C_N_O_, (cAliasSCR)->CR_NUM, (cAliasSCR)->CR_GRUPO, (cAliasSCR)->CR_APROV})
	(cAliasSCR)->(dbSkip())
EndDo

FWRestRows(aRows)
RestArea(aArea)
Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GetScrAglu()
Função para retornar a variavel estatica cScrAglu
@return	cCnScrAglu
@author 	Israel Escorizza
@since 		08/03/2016
@version 	1.0
/*/
//-------------------------------------------------------------------
Function GetScrAglu()
Return cScrAglu

//-------------------------------------------------------------------
/*/{Protheus.doc} SetScrAglu(cValor)
Função para atribuir a variavel estatica cScrAglu
@return	cCnScrAglu
@author 	Israel Escorizza
@since 		08/03/2016
@version 	1.0
/*/
//-------------------------------------------------------------------
Function SetScrAglu(cValor)
cScrAglu := cValor
Return cScrAglu

//------------------------------------------------------------------
/*/{Protheus.doc} GetPropMdl()
Função que guarda o status das propriedades de um modelo (grid) MVC


@author 	Matheus Lando
@since 		04/02/2016
/*/
//-------------------------------------------------------------------
Function GetPropMdl(oModelGrid)
Local aProp := {}

If oModelGrid:ClassName()=='FWFORMGRID'
	Aadd(aProp,oModelGrid:CanInsertLine())
	Aadd(aProp,oModelGrid:CanUpdateLine())
	Aadd(aProp,oModelGrid:CanDeleteLine())
EndIf

Return aProp

//------------------------------------------------------------------
/*/{Protheus.doc} RstPropMdl()
Função que "restaura" as propriedades de um modelo (grid) MVC

@author 	Matheus Lando
@since 		04/02/2016
/*/
//-------------------------------------------------------------------
Function RstPropMdl(oModelGrid,aProp)

If oModelGrid:ClassName()=='FWFORMGRID'

	oModelGrid:SetNoInsertLine(!aProp[1])
	oModelGrid:SetNoUpdateLine(!aProp[2])
	oModelGrid:SetNoDeleteLine(!aProp[3])
EndIf

Return

//=======================================================================================
/*/{Protheus.doc} CnGetUsrCp(oModel)
Função para retornar array contendo os submodelos e campos que possuem campos de usuario
@return	aRet
@author 	Israel Escorizza
@since 		06/04/2016
@version 	1.0
/*/
//=======================================================================================
Function CnGetUsrCp(oModel)
Local aArea	:= GetArea()
Local aRows	:= FWSaveRows( oModel )

Local aSubMod	:= {}
Local aSubFld	:= {}
Local aUsrFld	:= {}
Local aRet		:= {}

Local cMdName	:= ""
Local cFdName	:= ""

Local nX		:= 0
Local nY		:= 0

Default oModel := Nil

If ValType(oModel) != Nil
	SX3->(dbSetOrder(2))
	aSubMod := oModel:GetAllSubModels()

	For nX := 1 To Len(aSubMod)
		aUsrFld := {}
		cMdName := aSubMod[nX]:GetID()
		aSubFld := oModel:GetModel(cMdName):GetStruct():GetFields()

		For nY := 1 to Len(aSubFld)
			cFdName := aSubFld[nY][3]
			If SX3->(MsSeek(cFdName)) .And. ( GetSx3Cache( cFdName, "X3_PROPRI" ) == "U" )
				aAdd(aUsrFld,cFdName)
			EndIf
		Next nY

		If Len(aUsrFld) > 0
			aAdd(aRet,{cMdName,aUsrFld})
		EndIf
	Next nX
EndIf

FWRestRows(aRows)
RestArea(aArea)
Return aRet

//------------------------------------------------------------------
/*/{Protheus.doc} CnRevAtu()
Função que retorna o codigo da ultima revisão do contrato.

@author 	jose.delmondes
@since 		14/04/2016
/*/
//-------------------------------------------------------------------
Function CnUltRev(cContra, cFilCtr)
Local cAliasRev := GetNextAlias()
Local cUltRev	:= ""
Default cFilCtr := cFilAnt

BeginSQL Alias cAliasRev
	SELECT MAX(CN9_REVISA) AS CN9_REVISA
	FROM %Table:CN9% CN9
	WHERE CN9.CN9_FILIAL = %Exp:xFilial("CN9",cFilCTR)% AND CN9.CN9_NUMERO = %Exp:cContra% AND CN9.%NotDel%
EndSQL

cUltRev := (cAliasRev)->CN9_REVISA

(cAliasRev)->(dbCloseArea())

Return cUltRev

//=============================================================================
/*/{Protheus.doc} GCTEstApr()
Função responsável por realizar o estorno da aprovação. somente valido caso
niveis superiores não tenham realizado aprovação.

@author Israel.Escorizza
@since 02/02/2016
@return
/*/
//=============================================================================
Function GCTEstApr()
Local aArea			:= GetArea()
Local aSaveLines	:= FwSaveRows()
Local aCampos		:= {}
Local lRet			:= .T.
Local nTamDoc		:= IIf(SCR->CR_TIPO $ 'IM|MD',TAMSX3('CND_NUMMED')[1],TAMSX3('CN9_NUMERO')[1])
Local nTamRev		:= IIf(SCR->CR_TIPO $ 'IM|MD',TAMSX3('CND_REVISA')[1],TAMSX3('CN9_REVISA')[1])
Local cNumDoc		:= SubStr(SCR->CR_NUM,1,nTamDoc)
Local cNumRev		:= SubStr(SCR->CR_NUM,nTamDoc+1,nTamRev)
Local cFilCtr		:= CnFilCtr(cNumDoc)
Local cSituac		:= SCR->CR_STATUS
Local cTipo	 		:= SCR->CR_TIPO
Local cMensagem     := ""
Local cMsgHelp		:= STR0095
Local aSolHelp		:= {""}
Local lEstAprPE		:= ExistBlock("CNESTAPR")
Local nRecSCR		:= SCR->(RecNo())

If cSituac != "03" //Validação da situação da aprovação.
	lRet := .F.
	Help( ,, "CNEST001",, STR0092, 1, 0,,,,,, {""} ) //"Ação não disponivel para a situação atual da aprovação."
EndIf

//Valida Revisão atual do contrato para estorno da aprovação
If lRet .And. cTipo $ "IC|CT|IR|RV" .And. Val(cNumRev) < Val(CnGetRevAt(cNumDoc))
	lRet := .F.
	Help( ,, "CNEST002",, STR0093, 1, 0,,,,,, {""} ) //"Ação não disponivel pois a aprovação não corresponde a revisão atual do contrato."
EndIf

//Valida Medição já encerrada
If lRet .And. cTipo $ "IM|MD"
	dbSelectArea("CND")
	CND->(dbSetOrder(4))
	If CND->(dbSeek(xFilial('CND')+cNumDoc)) .And. !Empty(CND->CND_DTFIM)
		lRet := .F.		
		Help( ,, "CNEST003",, STR0094, 1, 0,,,,,, {""} ) //"Ação não disponivel pois a medição já está encerrada."
	EndIf
EndIf

If lRet
	If cTipo $ "IR|RV"
		cMensagem := STR0096 //"Essa operação irá desfazer a aprovação desse documento."
	Else	
		cMensagem := STR0077 //"Essa operação estorna todos os níveis e reinicia o processo de aprovação."
	EndIf

	If lRet := IIF(IsBlind(), .T., MSGYESNO( cMensagem + CRLF + STR0078 )) //" Confirma o estorno?"
		Begin Transaction
			
			If cTipo $ "IC|CT"
		 		CN9->( dbSetOrder( 1 ) ) //CN9_FILIAL+CN9_NUMERO+CN9_REVISA
		 		If 	CN9->( MsSeek( cFilCtr + cNumDoc ) )
		 			CN100SitCh( CN9->CN9_NUMERO, CN9->CN9_REVISA, "02", CN9->CN9_APROV, .F. )
		 			CN100SitCh( CN9->CN9_NUMERO, CN9->CN9_REVISA, "04", CN9->CN9_APROV, .F. ) 
		 		EndIf
			
			ElseIf cTipo $ "IR|RV"
			
		 		CN9->( dbSetOrder( 1 ) ) //CN9_FILIAL+CN9_NUMERO+CN9_REVISA
		 		If 	CN9->( MsSeek( cFilCtr + cNumDoc + cNumRev ) )
		 			oModel := FWLoadModel( Iif( CN9->CN9_ESPCTR == "1", "CNTA300", "CNTA301" ) )
					oModel:SetOperation( MODEL_OPERATION_UPDATE )
					oModel:Activate()
					
					lRet := CN300GerApr( oModel:GetModel('CN9MASTER'), 5, MODEL_OPERATION_UPDATE )					
					
					If lRet
						RecLock("CN9")
						CN9->CN9_SITUAC := "A"
						CN9->( MsUnlock() )
						
						If CN9->( MSSeek( cFilCtr + cNumDoc + CnRevAnt( .F., CN9->CN9_REVISA ) ) ) .And. CN9->CN9_SITUAC != '05'
							RecLock('CN9')
							CN9->CN9_SITUAC := '05'
							MsUnlock()
						EndIf
					EndIf
		 		EndIf
			
			ElseIf cTipo $ "IM|MD"
			
				dbSelectArea('CND')
		 		CND->(dbSetOrder(4))
		 		If 	CND->(MsSeek(xFilial('CND')+cNumDoc))
		 			If Cn121OriMd('CNTA120')
		 				aAdd(aCampos, {CND->CND_NUMMED,"MD",CND->CND_VLTOT,"","",CND->CND_APROV,"",CND->CND_MOEDA,0,CND->CND_DTINIC})
						GCTAlcEnt(,,3,"MD",CND->CND_NUMMED,CND->CND_REVISA,aCampos)
						lAlc := GCTAlcEnt(,,1,"MD",CND->CND_NUMMED,CND->CND_REVISA,aCampos)
						If !lAlc
							RecLock("CND",.F.)
								CND->CND_ALCAPR := Iif(lAlc,"L","B")
							    CND->CND_SITUAC := Iif(lAlc,CND->CND_SITUAC,"B")
							MsUnlock("CND")
						EndIf
		 			Else
			 			oModel := FWLoadModel('CNTA121')
						oModel:SetOperation(MODEL_OPERATION_UPDATE)
						If (lRet := oModel:Activate())
			 				Cn121AlcMd(oModel)
						Else
							cMsgHelp := oModel:GetErrorMessage()[6]
							aSolHelp := {oModel:GetErrorMessage()[7]}
						EndIf
		 			EndIf
		 		EndIf
		 		
			EndIf
			
			If lEstAprPE
				ExecBlock("CNESTAPR",.F.,.F.,{nRecSCR, lRet})
			EndIf
			
			If !lRet
				Help( ,, "CNEST004",, cMsgHelp, 1, 0,,,,,, aSolHelp ) //"Não foi possivel realizar o estorno."							
				DisarmTransaction()
			EndIf
			
		End Transaction
	EndIf
EndIf

FWRestRows(aSaveLines)
FwFreeArray(aSaveLines)
RestArea(aArea)
FwFreeArray(aArea)
Return lRet

//=============================================================================
/*/{Protheus.doc} CnSomaN(xValOri,nQtdSoma)
Função criada para somar nQtdSoma.

@author Israel.Escorizza
@since 17/02/2017
@return
/*/
//=============================================================================
Function CnSomaN(xValOri,nQtdSoma)
Local xRet	:= 0
Local nX	:= 0

Default xValOri  := 0
Default nQtdSoma := 0

xRet := xValOri
For nX := 1 To nQtdSoma
	xRet := Soma1(xRet)
Next nX

Return xRet

//=============================================================================
/*/{Protheus.doc} CnTiraN(xValOri,nQtdTira)
Função criada para retirar nQtdSoma.

@author Israel.Escorizza
@since 17/02/2017
@return
/*/
//=============================================================================
Function CnTiraN(xValOri,nQtdTira)
Local xRet	:= 0
Local nX	:= 0

Default xValOri  := 0
Default nQtdSoma := 0

xRet := xValOri
For nX := 1 To nQtdSoma
	xRet := Tira1(xRet)
Next nX

Return xRet
//-------------------------------------------------------------------
/*/{Protheus.doc} CnFilCtr()
Retorna a filila do contrato

@author Israel Escorizza
@since 10/08/2015
@version 1.0
@return cFilCtr
/*/
//-------------------------------------------------------------------
Function CnFilCtr(cContrato)
	Local aAreas	:= {CN9->(GetArea()), GetArea()}	
	Local cFilCtr	:= xFilial("SCR")
	DEFAULT cContrato := ""

	cContrato := LEFT(cContrato, GetSX3Cache("CN9_NUMERO", "X3_TAMANHO"))
	If !Empty(cFilCtr)		
		CN9->( DbSetOrder(7) ) // CN9_FILIAL + CN9_NUMERO + CN9_SITUAC
		If CN9->( DbSeek(xFilial("CN9") + cContrato))
			cFilCtr := CN9->CN9_FILCTR
		EndIf
	EndIf

	aEval(aAreas, {|x| RestArea(x) })
	FwFreeArray(aAreas)
Return cFilCtr

//----------------------------------------------------------------------------------------
/*/{Protheus.doc} CnNotaDev()
Rotina responsável pelo controle processamento de uma nota de devolução.
A rotina é responsável por:
	- Validação de viabilidade da execução
	- Restauração de saldo no contrato/planilha/item/cronograma
	- Alteração de situação da medição.

@Param	nOper	-	Operação a ser realizada
					0 (Default)	- Restauração de saldo (nota de entrada de devolução)
					1			- Reconsumo de saldo (exclusão da nota de entrada de devolução)

		aDocDev	-	Informações referentes ao documento de devolução
					[1] SF1.F1_DOC
					[2] SF1.F1_SERIE
					[3]	SF1.F1_FORNECE
					[4]	SF1.F1_LOJA

@author Israel Escorizza
@since 17/04/2017
@version 1.0
@return lRet
/*/
//----------------------------------------------------------------------------------------
Function CnNotaDev(nOper,aDocDev)
Local lRet 			:= .T.
Local nX			:= 1

Default	nOper		:= 0
Default	aDocDev		:= {}

aNotasEst := CnGetNtSai(aDocDev)

While lRet .And. nX <= Len(aNotasEst)
	nOpc := CnVlNotDev(nOper,aNotasEst[nX])

	If nOpc == 1
		lRet := CnProcSld(nOper,aNotasEst[nX]) .And. CnAltMdSit(nOper,aNotasEst[nX])
	ElseIf nOpc == 2
		Help('',1,'CnNotaDev1',,STR0064,4) //"A transação será realizada, porém as tratativas do contrato não serão atualizado!"
	ElseIf nOpc == 0
		lRet := .F.
		Help('',1,'CnNotaDev2',,STR0065,4) //"A transação não será realizada, pois o contrato está com o está em revisão. Aprove a revisão para dar andamento!"
	EndIf
	nX++
End

Return lRet

//----------------------------------------------------------------------------------------
/*/{Protheus.doc} CnGetNtSai()
Rotina responsável pela validação da execução de uma nota de devolução.

@author Israel Escorizza, Henrique.Testi
@since 17/04/2017
@version 1.0
@return aNotasEst
/*/
//----------------------------------------------------------------------------------------
Function CnGetNtSai(aDocDev) As Array
	Local aNotasEst as Array
	Local cQuery    as Character
	Local oQuery    as Object
	Local nParam    as Numeric
	Local cDoc      as Character
	Local cSerie    as Character
	Local cFornece  as Character
	Local cLoja     as Character
	Local cTipo     as Character

	aNotasEst 	:= {}
	cQuery 		:= ""
	nParam 		:= 1

	cDoc := aDocDev[1]
	cSerie := aDocDev[2]
	cFornece := aDocDev[3]
	cLoja := aDocDev[4]
	cTipo := "D" //Devolução

	cQuery += " SELECT DISTINCT "
	cQuery += "CND.CND_FILCTR, SF1.F1_DOC, SC5.C5_FILIAL, SC5.C5_MDCONTR, SC5.C5_MDNUMED, SC5.C5_MDPLANI, "
	cQuery += "SC6.C6_ITEMED, SD2.D2_PEDIDO, SD2.D2_QUANT, SD2.D2_TOTAL, "
	cQuery += "SD1.D1_ITEM, SD1.D1_QUANT, SD1.D1_TOTAL, "
	cQuery += "CND.CND_COMPET, CNA.CNA_CRONOG, CNA.CNA_CRONCT, "
	cQuery += "CND.CND_FILIAL, COALESCE(CXN.CXN_PARCEL, CND.CND_PARCEL, ' ') PARCEL, "	

	cQuery += "( SELECT SUM(XSD1.D1_TOTAL) "
    cQuery += "FROM "+RetSQLName("SD1")+" XSD1 "
    cQuery += "WHERE "
    cQuery += "    XSD1.D1_FILIAL = ? "
    cQuery += "    AND XSD1.D1_DOC = SF1.F1_DOC "
    cQuery += "    AND XSD1.D1_SERIE = SF1.F1_SERIE "
    cQuery += "    AND XSD1.D1_NFORI = SD2.D2_DOC "
    cQuery += "    AND XSD1.D1_SERIORI = SD2.D2_SERIE "
    cQuery += "    AND XSD1.D1_ITEMORI = SD2.D2_ITEM "
    cQuery += "    AND XSD1.D1_FORNECE = SD2.D2_CLIENTE "
    cQuery += "    AND XSD1.D1_LOJA = SD2.D2_LOJA "
    cQuery += "    AND XSD1.D_E_L_E_T_ = ' ' "
	cQuery += ") AS CND_TOTNOT, "

	cQuery += "( SELECT SUM(XSD1.D1_TOTAL) "
	cQuery += "	FROM "+RetSQLName("SD1")+" XSD1 "
	cQuery += "	WHERE "
	cQuery += "		XSD1.D1_FILIAL = ? "
	cQuery += "		AND XSD1.D1_NFORI = SD2.D2_DOC "
	cQuery += "		AND XSD1.D1_SERIORI = SD2.D2_SERIE "
	cQuery += "		AND XSD1.D1_ITEMORI = SD2.D2_ITEM "
	cQuery += "		AND XSD1.D1_FORNECE = SD2.D2_CLIENTE "
	cQuery += "		AND XSD1.D1_LOJA = SD2.D2_LOJA "
	cQuery += "		AND XSD1.D_E_L_E_T_ = ' ' "
	cQuery += ") AS CND_TOTDEV "

	cQuery += " FROM "+RetSQLName("SF1")+" SF1 "

	cQuery += " JOIN "+RetSQLName("SD1")+" SD1 ON "
	cQuery += "      SD1.D1_FILIAL = ? "
	cQuery += "  AND SD1.D1_DOC = SF1.F1_DOC "
	cQuery += "  AND SD1.D1_SERIE = SF1.F1_SERIE "
	cQuery += "  AND SD1.D1_FORNECE = SF1.F1_FORNECE "
	cQuery += "  AND SD1.D1_LOJA = SF1.F1_LOJA "
	cQuery += "  AND SD1.D1_TIPO = SF1.F1_TIPO "
	cQuery += "  AND SD1.D_E_L_E_T_ = ? "

	cQuery += " JOIN "+RetSQLName("SD2")+" SD2 ON "
	cQuery += "      SD2.D2_FILIAL = ? "
	cQuery += "  AND SD2.D2_DOC = SD1.D1_NFORI "
	cQuery += "  AND SD2.D2_SERIE = SD1.D1_SERIORI "
	cQuery += "  AND SD2.D2_CLIENTE = SD1.D1_FORNECE "
	cQuery += "  AND SD2.D2_LOJA = SD1.D1_LOJA "
	cQuery += "  AND SD2.D2_ITEM = SD1.D1_ITEMORI "
	cQuery += "  AND SD2.D_E_L_E_T_ = ? "

	cQuery += " JOIN "+RetSQLName("SC6")+" SC6 ON "
	cQuery += "      SC6.C6_FILIAL = ? "
	cQuery += "  AND SC6.C6_NUM = SD2.D2_PEDIDO "
	cQuery += "  AND SC6.C6_ITEM = SD2.D2_ITEMPV "
	cQuery += "  AND SC6.D_E_L_E_T_ = ? "

	cQuery += " JOIN "+RetSQLName("SC5")+" SC5 ON "
	cQuery += "      SC5.C5_FILIAL = ? "
	cQuery += "  AND SC5.C5_NUM = SC6.C6_NUM "
	cQuery += "  AND SC5.D_E_L_E_T_ = ? "

	cQuery += " JOIN "+RetSQLName("CND")+" CND ON "
	cQuery += "      CND.CND_FILIAL = ? "
	cQuery += "  AND CND.CND_NUMMED = SC5.C5_MDNUMED "
	cQuery += "  AND CND.D_E_L_E_T_ = ? "

	cQuery += " LEFT JOIN "+RetSQLName("CXN")+" CXN ON "
	cQuery += "      CXN.CXN_FILIAL = ? "
	cQuery += "  AND CXN.CXN_CONTRA = SC5.C5_MDCONTR "
	cQuery += "  AND CXN.CXN_NUMPLA = SC5.C5_MDPLANI "
	cQuery += "  AND CXN.CXN_NUMMED = SC5.C5_MDNUMED "
	cQuery += "  AND CXN.D_E_L_E_T_ = ? "

	cQuery += " JOIN "+RetSQLName("CNA")+" CNA ON "
	cQuery += "      CNA.CNA_FILIAL = ? "
	cQuery += "  AND CNA.CNA_CONTRA = COALESCE(CXN.CXN_CONTRA, CND.CND_CONTRA) "
	cQuery += "  AND CNA.CNA_REVISA = COALESCE(CXN.CXN_REVISA, CND.CND_REVISA) "
	cQuery += "  AND CNA.CNA_NUMERO = COALESCE(CXN.CXN_NUMPLA, CND.CND_NUMERO) "
	cQuery += "  AND CNA.D_E_L_E_T_ = ? "

	cQuery += " WHERE SF1.F1_FILIAL  = ? "
	cQuery += "   AND SF1.F1_DOC     = ? "
	cQuery += "   AND SF1.F1_SERIE   = ? "
	cQuery += "   AND SF1.F1_FORNECE = ? "
	cQuery += "   AND SF1.F1_LOJA    = ? "
	cQuery += "   AND SF1.F1_TIPO    = ? "
	cQuery += "   AND SF1.D_E_L_E_T_ = ? "

	cQuery += " ORDER BY C5_FILIAL, C5_MDCONTR, C5_MDNUMED, C5_MDPLANI"

	oQuery := FWExecStatement():New(ChangeQuery( cQuery ))

	oQuery:setString(nParam++, FwXFilial("SD1"))
	oQuery:setString(nParam++, FwXFilial("SD1"))
	oQuery:setString(nParam++, FwXFilial("SD1"))
	oQuery:setString(nParam++, Space(1))
	oQuery:setString(nParam++, FwXFilial("SD2"))
	oQuery:setString(nParam++, Space(1))
	oQuery:setString(nParam++, FwXFilial("SC6"))
	oQuery:setString(nParam++, Space(1))
	oQuery:setString(nParam++, FwXFilial("SC5"))
	oQuery:setString(nParam++, Space(1))
	oQuery:setString(nParam++, FwXFilial("CND"))
	oQuery:setString(nParam++, Space(1))
	oQuery:setString(nParam++, FwXFilial("CXN"))
	oQuery:setString(nParam++, Space(1))
	oQuery:setString(nParam++, FwXFilial("CNA"))
	oQuery:setString(nParam++, Space(1))
	oQuery:setString(nParam++, FwXFilial("SF1"))
	oQuery:setString(nParam++, cDoc)
	oQuery:setString(nParam++, cSerie)
	oQuery:setString(nParam++, cFornece)
	oQuery:setString(nParam++, cLoja)
	oQuery:setString(nParam++, cTipo)
	oQuery:setString(nParam++, Space(1))
	
	cAliasTmp := oQuery:OpenAlias()

	While !(cAliasTmp)->(Eof())

		aAdd(aNotasEst,{(cAliasTmp)->CND_FILCTR,;				//- [1]  Filial contrato;
						(cAliasTmp)->C5_MDCONTR,;				//- [2]  Numero do contrato
						CnGetRevAt((cAliasTmp)->C5_MDCONTR),;	//- [3]  Revisão atual do contrato;
						(cAliasTmp)->C5_MDNUMED,;				//- [4]  Numero da medição
						(cAliasTmp)->CND_COMPET,;				//- [5]  Competência da Medição
						(cAliasTmp)->C5_MDPLANI,;				//- [6]  Planilha da medição;
						(cAliasTmp)->C6_ITEMED, ;				//- [7]  Item da medição;
						(cAliasTmp)->CNA_CRONOG,;				//- [8]  Cronograma Financeiro;
						(cAliasTmp)->CNA_CRONCT,;				//- [9]  Cronograma Contábil;
						(cAliasTmp)->PARCEL,;					//- [10] Parcela do cronograma;
						(cAliasTmp)->D2_PEDIDO,;				//- [11] Num. Pedido de venda;
						(cAliasTmp)->D2_QUANT,;					//- [12] Qtd. Item na NF Saida
						(cAliasTmp)->D2_TOTAL,;					//- [13] Vlr. Item na NF Saida;
						(cAliasTmp)->D1_QUANT,;					//- [14] Qtd. Item na NF Entrada;
						(cAliasTmp)->D1_TOTAL,;					//- [15] Vlr. Item na NF Entrada;
						(cAliasTmp)->CND_FILIAL,;				//- [16] Filial da medição;
						(cAliasTmp)->CND_TOTDEV,;				//- [17] Total devolvido da medição;
						(cAliasTmp)->CND_TOTNOT;				//- [18] Total devolvido da medição nesta nota;
						})
		(cAliasTmp)->(dbSkip())
	EndDo

	(cAliasTmp)->(dbCloseArea())

	FwFreeObj(oQuery)
Return aNotasEst

//----------------------------------------------------------------------------------------
/*/{Protheus.doc} CnVlNotDev(nOper,aNotDev)
Rotina responsável pela validação da execução de uma nota de devolução.
			nOper	-	Operação a ser realizada
				0 (Default)	- Restauração de saldo (nota de entrada de devolução)
				1			- Reconsumo de saldo (exclusão da nota de entrada de devolução)
			aNotDev - Array com as informações para realizar as validações
				[1]  Filial contrato;
				[2]  Numero do contrato
				[3]  Revisão atual do contrato;
				[4]  Numero da medição
				[5]  Competência da Medição
				[6]  Planilha da medição;
				[7]  Item da medição;
				[8]  Cronograma Financeiro;
				[9]  Cronograma Contábil;
				[10] Parcela do cronograma;
				[11] Num. Pedido de venda;
				[12] Qtd. Item na NF Saida
				[13] Vlr. Item na NF Saida;
				[14] Qtd. Item na NF Entrada;
				[15] Vlr. Item na NF Entrada;
				[16] Filial da medição;
				[17] Total devolvido da medição;
				[18] Total devolvido da medição nesta nota;

@author Israel Escorizza
@since 17/04/2017
@version 1.0
@return lRet
/*/
//----------------------------------------------------------------------------------------
Function CnVlNotDev(nOper,aNotDev)
Local aArea		:= GetArea()
Local cFilDev	:= ""
Local cContra	:= ""
Local cRevisa	:= ""
Local nRet		:= 1

Default nOper 	:= 0
Default aNotDev := {}

If Len(aNotDev) > 0

	cFilDev := xFilial("CN9", aNotDev[1])
	cContra	:= aNotDev[2]
	cRevisa	:= aNotDev[3]

	DbSelectArea("CN9")
	CN9->( DbSetOrder(1) ) // CN9_FILIAL+CN9_NUMERO+CN9_REVISA
	If CN9->( DbSeek(cFilDev + cContra + cRevisa))
		//Valiar se é um Contrato de venda
		If Cn300RetSt("COMPRA",,,,,cContra)
			nRet := 2
		Else
			//Validar status do Contrato para não realizar a devolução de contratos cancelado, Sol. Finalização e Finalizafdo
			If CN9->CN9_SITUAC $ DEF_SCANC+'|'+DEF_SSPAR+'|'+DEF_SFINA
				nRet := 2
			//Contratos em revisão não podem fazer a devolução
			ElseIf CN9->CN9_SITUAC == DEF_SREVS
				nRet := 0
			Else
				//Validar Conrato GCP
				If !Empty(CN9->CN9_CODED)
					nRet := 2
				Else
					//Validar Contratos do GS
					DbSelectArea("TFJ")
					TFJ->( DbSetOrder(5) ) //TFJ_FILIAL+TFJ_CONTRT+TFJ_CONREV
					If TFJ->( DbSeek(cFilDev + cContra + cRevisa))
						nRet := 2
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aArea)
Return nRet


//----------------------------------------------------------------------------------------
/*/{Protheus.doc} CnProcSld()
Rotina responsável pela restauração de saldo no contrato/planilha/item/cronograma

@author Israel Escorizza
@since 17/04/2017
@version 1.0
@return lRet
/*/
//----------------------------------------------------------------------------------------
Function CnProcSld(nOper,aNotEst)
Local 	lRet		:= .T.
Local 	aArea 		:= GetArea()
Local 	aRows		:= FWSaveRows()

Local 	lCtrSld		:= .T.
Local 	lAtuItm		:= .T.
Local	lCrgFin		:= .F.
Local 	lCrgFis		:= .F.
Local	lCrgCtb		:= .F.

Local 	nMod		:= 0
Local	nQtd		:= 0
Local 	nVal		:= 0
Local 	nTotMult 	:= 0
Local 	nTotBoni 	:= 0

Local	cSeekCtr	:= ""

Default nOper		:= 0
Default aNotasEst	:= {}

If (lRet := !Empty(aNotasEst))
	cSeekCtr :=  xFilial("CN9", aNotEst[1])+aNotEst[2]+aNotEst[3]
	CN9->(dbSetOrder(1))	//- CN9_FILIAL+CN9_NUMERO+CN9_REVISA
	CNA->(dbSetOrder(1))	//- CNA_FILIAL+CNA_CONTRA+CNA_REVISA+CNA_NUMERO

	If 	(lRet := (CN9->(MsSeek(cSeekCtr)) .And. CNA->(MsSeek(cSeekCtr+aNotEst[6]))))
		lCtrSld	:= !(!Cn300RetSt('FIXO') .AND. Cn300RetSt('MEDEVE') .AND. !Cn300RetSt('PREVFINANC'))
		lAtuItm	:= !(!Cn300RetSt('FIXO') .AND. Cn300RetSt('MEDEVE'))
		lCrgFin	:= !Empty(aNotEst[8])
		lCrgCtb	:= !Empty(aNotEst[9])

		If lAtuItm
			CNB->(dbSetOrder(1))	//- CNB_FILIAL+CNB_CONTRA+CNB_REVISA+CNB_NUMERO+CNB_ITEM
			lRet := CNB->(MsSeek(cSeekCtr+aNotEst[6]+aNotEst[7]))
		EndIf

		If lCrgFin
			CNF->(dbSetOrder(2))	 //- CNF_FILIAL+CNF_CONTRA+CNF_REVISA+CNF_NUMERO+CNF_COMPET
			If (lRet := CNF->(MsSeek(cSeekCtr+aNotEst[8]+aNotEst[5])))
				CNS->(dbSetOrder(1)) //- CNS_FILIAL+CNS_CONTRA+CNS_REVISA+CNS_CRONOG+CNS_PARCEL+CNS_ITEM
				lCrgFis := CNS->(MsSeek(cSeekCtr+aNotEst[8]+aNotEst[10]+aNotEst[7]))
			EndIf
		EndIf

		If lCrgCtb
			CNV->(dbSetOrder(1))	//- CNV_FILIAL+CNV_CONTRA+CNV_REVISA+CNV_NUMERO
			lRet := CNV->(MsSeek(cSeekCtr+aNotEst[9]))
		EndIf
	EndIf

	If 	lRet
		nMod := Iif(nOper == 0,1,-1)
		nQtd := aNotEst[14]
		nVal := aNotEst[15]

		//Resgatar os valores de Multa e Bonificação
		nTotMult := CnGetMulBo(aNotEst[4] , "1")
		nTotBoni := CnGetMulBo(aNotEst[4] , "2")

		If nTotMult > 0
			nVal -= nTotMult
		EndIf

		If nTotBoni > 0
			nVal += nTotBoni
		EndIf

		nQtd *= nMod
		nVal *= nMod

		//Verificação quando realizar uma exclusão da nota de devolução
		If nOper == 1
			lRet :=   !((lCrgFin .And. (CNF->CNF_SALDO  + nVal < 0)) .OR.;
			 			(lCrgFis .And. (CNS->CNS_SLDQTD + nQtd < 0)) .OR.;
			 			(lAtuItm .And. ((CNB->CNB_SLDREC + nQtd < 0) .OR. (CNB->CNB_SLDMED + nQtd < 0))) .OR.;
			 		    (lCtrSld .And. (CN9->CN9_SALDO + nVal < 0)))
		Else
			lRet :=  !(!lCtrSld .And. (CN9->CN9_VLINI - nVal < 0) .And. (CN9->CN9_VLATU - nVal < 0))
		EndIf

		If !lRet
			Help('',1,'CnProcSld1',,STR0066,4) //"Não será possivel realizar a exclusão da NF de devolução por divergências nos saldos da NF com o contrato!"
		Else
			Begin Transaction	//- Inicia Processo de estorno|restauração do saldo
				If 	lCrgFin .And. (lRet := RecLock('CNF',.F.))
					If CNF->CNF_VLREAL > 0 
						CNF->CNF_VLREAL	-= nVal	//- Vl.Realizado
					EndIf
					CNF->CNF_SALDO  += nVal	//- Saldo Parc.
					CNF->(MsUnlock())
				EndIf

				If 	lRet .And. lCrgFis	.And. (lRet := RecLock('CNS',.F.))
					CNS->CNS_RLZQTD -=	nQtd	//- Qtd Medida
					CNS->CNS_SLDQTD	+= 	nQtd	//- Saldo
					CNS->(MsUnlock())
				EndIf

				If 	lRet .And. lAtuItm	.And. (lRet := RecLock('CNB',.F.))
					CNB->CNB_QTDMED -= nQtd		//- Qtd. Medida
					CNB->CNB_SLDREC	+= nQtd		//- Sld Receber
					CNB->CNB_SLDMED	+= nQtd		//- Saldo
					CNB->(MsUnlock())
				EndIf

				If 	lRet
					If lCtrSld
						If	(lRet := RecLock('CNA',.F.))
							CNA->CNA_SALDO += nVal		//- Saldo
							CNA->(MsUnlock())
						EndIf

						If lRet .And. (lRet := RecLock('CN9',.F.))
							CN9->CN9_SALDO += nVal		//- Saldo
							CN9->(MsUnlock())
						EndIf
					Else
						If (lRet := RecLock('CN9',.F.))
							CN9->CN9_VLATU -= nVal		//- Valor Atual
							CN9->CN9_VLINI -= nVal
							CN9->(MsUnlock())
						EndIf
					EndIf
				EndIf

				If lRet == .F.
					Help('',1,'CnProcSld2',,STR0067,4) //"Inclusão da NF de devolução não realizada.//Não foi possivel retornar saldo ao contrato."
					DisarmTransaction()
				EndIf
			End Transaction
		EndIf
	EndIf
EndIf

FwRestRows(aRows)
RestArea(aArea)
Return lRet

//----------------------------------------------------------------------------------------
/*/{Protheus.doc} CnAltMdSit()
Rotina responsável pela Alteração de situação da medição.

@author Israel Escorizza
@since 17/04/2017
@version 1.0
@return lRet
/*/
//----------------------------------------------------------------------------------------
Function CnAltMdSit(nOper,aNotDev)
Local lRet := .T.
Local aArea		:= GetArea()
Local cFilDev	:= ""
Local cContra	:= ""
Local cRevisa	:= ""
Local cNumMed	:= ""
Local cNumPla	:= ""
Local cValor	:= ""
Local nTotDev	:= 0
Local nTotMult	:= 0
Local nTotBoni	:= 0

Default nOper 	:= 0
Default aNotDev := {}

If lRet := Len(aNotDev) >= 18
	cFilDev	:= aNotDev[16]
	cContra	:= aNotDev[2]
	cRevisa	:= aNotDev[3]
	cNumMed	:= aNotDev[4]
	cNumPla	:= aNotDev[6]
	nTotDev := aNotDev[17]
	nTotNot	:= aNotDev[18]

	//Resgatar os valores de Multa e Bonificação
	nTotMult := CnGetMulBo(cNumMed , "1")
	nTotBoni := CnGetMulBo(cNumMed , "2")

	If nTotMult > 0
		nTotDev -= nTotMult
		nTotNot	-= nTotMult
	EndIf

	If nTotBoni > 0
		nTotDev += nTotBoni
		nTotNot	+= nTotBoni
	EndIf

	DbSelectArea("CND")
	CND->( DbSetOrder(1) ) //CND_FILIAL+CND_CONTRA+CND_REVISA+CND_NUMERO+CND_NUMMED
	If CND->(DbSeek(cFilDev + cContra + cRevisa + cNumPla + cNumMed))
		If nOper == 0
			If CND->CND_VLTOT - nTotDev == 0 //"Medição Totalmente Devolvida "
				cValor := 'T'
			ElseIf nTotDev > 0 //"Medição Parcialmente Devolvida "
				cValor := 'P'
			EndIf
		Else
			If nTotDev - nTotNot == 0  	//"Medição encerrada"
				cValor := 'L'
			Else
				cValor := 'P' //"Medição Parcialmente Devolvida "
			EndIf
		EndIf

		If lRet
			RecLock('CND',.F.)
			CND->CND_ALCAPR := cValor
			CND->(MsUnlock())
		EndIf
	EndIf
EndIf

RestArea(aArea)
Return lRet
							   //-------------------------------------------------------------------
/*/{Protheus.doc} CnGetMulBo()
Retorna a Revisão Atual do Contrato

@author filipe.goncalves
@since 27/04/2017
@version 1.0
@return nTotal
/*/
//-------------------------------------------------------------------
Function CnGetMulBo(cNumMed , cTipo)
Local aArea		:= GetArea()
Local cAliasTmp	:= ""
Local cQuery	:= ""
Local nTotal	:= 0

DEFAULT cNumMed := ""
DEFAULT cTipo 	:= ""

//Verifica soma de multas da medição
cQuery += " SELECT SUM(CNR.CNR_VALOR) CNR_TOTVAL "
cQuery += " FROM "
cQuery += RetSqlName( "CNR" ) +" CNR "
cQuery += " WHERE "
cQuery += " CNR.CNR_FILIAL = '"+xFilial('CNR')+"' AND "
cQuery += " CNR.CNR_NUMMED = '"+cNumMed+"' AND	"

If cTipo ==  "1"
	cQuery += " CNR.CNR_TIPO = '1' AND	"
Else
	cQuery += " CNR.CNR_TIPO = '2' AND	"
Endif

cQuery += " CNR.D_E_L_E_T_	= '' "

cQuery    := ChangeQuery( cQuery )
cAliasTmp := GetNextAlias()
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery), cAliasTmp,.T.,.T.)

nTotal := (cAliasTmp)->CNR_TOTVAL
(cAliasTmp)->(dbCloseArea())
RestArea(aArea)
Return nTotal

//-------------------------------------------------------------------
/*/{Protheus.doc} CnTpProd()
Retorna o tipo dos produtos da planilha

@author jose.delmondes
@since 25/04/2017
@version 1.0
@return 1 = Produto; 2 = Servico; 3 = Misto;
/*/
//-------------------------------------------------------------------
Function CnTpProd(cRotina, cPlan, cContra, cRev, nLinha, cFilCtr)
Local aArea	:= GetArea()
Local aSaveLines	:= {}
Local cAliasCNB	:= ""
Local lServ := .F.
Local lProd := .F.
Local nRet	:= 3
Local nX	:= 0
Local oModel	:= Nil
Local oModelCNB	:= Nil

DEFAULT cContra	:= ""
DEFAULT cRev	:= ""
DEFAULT nLinha	:= 0
DEFAULT cFilCtr	:= cFilAnt

dbSelectArea("SB5")
dbSetOrder(1)

If cRotina == "CNTA300"

	oModel	:= FwModelActive()
	oModelCNB	:= oModel:GetModel("CNBDETAIL")
	aSaveLines	:= FWSaveRows()

	For nX := 1 To oModelCNB:Length()
		oModelCNB:GoLine(nX)
		If !oModelCNB:IsDeleted() .And. oModelCNB:GetLine() <> nLinha
			If lProd .And. lServ
				Exit
			EndIf

			//Verifica se itens são do tipo serviço ou produto
			If oModelCNB:GetValue('CNB_TIPO') == '2'
				lServ := .T.
			Else
				lProd := .T.
			EndIf
		EndIf
	Next nX

	FWRestRows(aSaveLines)

ElseIf cRotina $ "CNTA120|CNTA121"

	//Executa Query para carregar produtos da planilha
	cAliasCNB := GetNextAlias()

	BeginSQL Alias cAliasCNB
		SELECT		CNB.CNB_PRODUT,
					ISNULL(B5_TIPO, "1") AS B5TIPO
		FROM		%Table:CNB% CNB
		LEFT JOIN 	%Table:SB5% SB5
		ON			SB5.B5_FILIAL	= %xFilial:SB5%
					AND SB5.B5_COD	= CNB.CNB_PRODUT
					AND SB5.%NotDel%
		WHERE 		CNB.CNB_FILIAL	= %exp: xFilial('CNB', cFilCtr)% AND
					CNB.CNB_CONTRA	= %exp:cContra% AND
					CNB.CNB_REVISA	= %exp:cRev% AND
					CNB.CNB_NUMERO	= %exp:cPlan% AND
					CNB.%NotDel%
	EndSQL

	While !(cAliasCNB)->(Eof())

		If lProd .And. lServ
			Exit
		EndIf

		//Verifica se itens são do tipo serviço ou produto
		If (cAliasCNB)->B5TIPO == '2'
			lServ := .T.
		Else
			lProd := .T.
		EndIf

		(cAliasCNB)->(dbSkip())
	End

	(cAliasCNB)->(dbCloseArea())

EndIf

If lServ .And. !lProd //planilha de serviços
	nRet := 2
ElseIf lProd .And. !lServ //planilha de produtos
	nRet := 1
EndIf

RestArea(aArea)

Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} IsNewMed()
Verifica se a medição foi gerada através da nova rotina de medições (CNTA121)
@author jose.delmondes
@since 08/06/2017
@version 1.0
@return true, caso a medição tenha sido gerada pela rotina CNTA121
/*/
//-------------------------------------------------------------------
Function IsNewMed(cContra,cRevisa,cNumMed)
Local lRet	:= .F.
Local aArea	:= GetArea()
Local aAreaCXN	:= {}

dbSelectArea("CXN")

aAreaCXN := CXN->(GetArea())

dbSetOrder(1)

if dbSeek(xFilial("CXN")+cContra+cRevisa+cNumMed)
	lRet = .T.
EndIf

RestArea(aAreaCXN)
RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GCTSolic()
Verifica se a solicitação partiu do módulo SIGAGCT -
Função utilizada na integraçao com outros módulos

@author jose.delmondes
@since 03/08/2017
@version 1.0
@return true, caso a solicitação tenha partido do GCT
/*/
//-------------------------------------------------------------------
Function GCTSolic(cContra,cRevisa,cNumMed)
Local lGCT	:= .F.
Local lGS	:= .F.
Local lRet	:= .F.

lGCT	:= FunName() $ "CNTA120*CNTA300*CNTA121" .Or. IsInCallStack("CN121Estorn")	// Solicitacao realizada pelo modulo SIGAGCT
lGS		:= FunName() $ "TECA930*TECA870*TECA934" 											// Solicitacao realizada pelo modulo SIGATEC
lRet	:= lGCT .Or. lGS																		// Solicitacao realizada pelos modulos SIGAGCT ou SIGATEC

Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc} NomeSX3
Função para retornar o nome do campo de acordo com o SX3
@author israel.escorizza
@since 17/08/2017
@version V12.1.17
@return lRet
/*/
//--------------------------------------------------------------------
Function NomeSX3(cCampo)
Local cName	 	:= FWSX3UTIL():GetDescription(cCampo)

Return cName

//------------------------------------------------------------------
/*/{Protheus.doc} GCTGetWhen(oModel)
Faz o Backup do when dos campos do modelo

@author 	jose.delmondes
@since 		22/08/2017
@version 	1.0
/*/
//-------------------------------------------------------------------
Function GCTGetWhen(oModel, lFldsUser, oStructMdl, lCacheOrig)
	Local aRet	:= {}
	Local cModelId	:= ""
	Local nX	:=	0
	Default	lFldsUser := .F. //Deseja armazenar apenas campos de usuário
	Default oStructMdl:= Nil
	Default lCacheOrig:= .F. //Deseja realizar o cache do when original do modelo(antes de qualquer modificação)

	If (oStructMdl == Nil)
		oStructMdl	:= oModel:Getstruct()
		cModelId	:= oModel:GetId()
	EndIf

	If !Empty(cModelId)		
		If (lFldsUser)
			If _aWhenMdls == Nil
				_aWhenMdls := JsonObject():New()
			EndIf
			If _aWhenMdls:HasProperty(cModelId)
				Return aClone(_aWhenMdls[cModelId])
			EndIf
		ElseIf(lCacheOrig)
			If _aWhenOrig == Nil
				_aWhenOrig := JsonObject():New()
			EndIf
			If _aWhenOrig:HasProperty(cModelId)
				Return aClone(_aWhenOrig[cModelId])
			EndIf		
		EndIf
	EndIf

	For nX := 1 To len(oStructMdl:aFields)
		If !lFldsUser .Or. (lFldsUser .And. FWSX3Util():GetOwner(oStructMdl:aFields[nX][MODEL_FIELD_IDFIELD]) == "U")
			aAdd( aRet , { oStructMdl:aFields[nX][MODEL_FIELD_IDFIELD] , oStructMdl:aFields[nX][MODEL_FIELD_WHEN] } )
		EndIf
	Next nX

	If !Empty(cModelId)		
		If lFldsUser
			_aWhenMdls[cModelId] := aClone(aRet)
		ElseIf lCacheOrig
			_aWhenOrig[cModelId] := aClone(aRet)
		EndIf
	EndIf
Return aRet

//------------------------------------------------------------------
/*/{Protheus.doc} GCTRstWhen(oModel)
Restaura o when dos campos do modelo

@author 	jose.delmondes
@since 		22/08/2017
@version 	1.0
/*/
//-------------------------------------------------------------------
Function GCTRstWhen( oModel , aWhen, oStructMdl, lUsaOrigem)
	Local nX :=	0
	Default oStructMdl := Nil
	Default lUsaOrigem := .F.

	If (oStructMdl == Nil)
		oStructMdl:= oModel:GetStruct()
		If lUsaOrigem
			aWhen := GCTGetWhen(oModel, .F., Nil, lUsaOrigem)
		EndIf
	EndIf

	For nX := 1 To len(aWhen)
		oStructMdl:SetProperty( aWhen[nX][1] , MODEL_FIELD_WHEN , aWhen[nX][2] )
	Next nX

	If lUsaOrigem
		FwFreeArray(aWhen)
	EndIf
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} GCTCarCC()
Carrega as definições de rateio externo

@author jose.delmondes
@since 02/03/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Function GCTCarCC(aCols, aHeader, cItem, lPrimeiro)
Local aEntidades	:= {}

Local lCusto		:= CtbMovSaldo("CTT")
Local lItem			:= CtbMovSaldo("CTD")
Local lCLVL			:= CtbMovSaldo("CTH")

Local nPosPerc		:= aScan( aHeader , {|x| AllTrim(x[2]) == "CNZ_PERC" 	} )
Local nPosItem		:= aScan( aHeader , {|x| AllTrim(x[2]) == "CNZ_ITEM" 	} )
Local nPosCC		:= aScan( aHeader , {|x| AllTrim(x[2]) == "CNZ_CC"		} )
Local nPosConta		:= aScan( aHeader , {|x| AllTrim(x[2]) == "CNZ_CONTA"	} )
Local nPosItemCta	:= aScan( aHeader , {|x| AllTrim(x[2]) == "CNZ_ITEMCT"	} )
Local nPosCLVL		:= aScan( aHeader , {|x| AllTrim(x[2]) == "CNZ_CLVL"	} )
Local nHeader		:= 0
Local nEnt			:= 0
Local nDeb			:= 0

If lPrimeiro
	//-- Se ja foi informado algum rateio, limpar o aCols
	If aCols[Len(aCols)][nPosPerc] <> 0
		ASize(aCols,0)
		Aadd(aCols, Array(Len(aHeader) + 1))

		For nHeader := 1 To Len(aHeader)
			aCols[Len(aCols)][nHeader] := CriaVar(aHeader[nHeader][2])
		Next
	EndIf

	cItem := Soma1(cItem)
	nPercARat 	:= 100
	nPercRat 	:= 0

	aCols[Len(aCols)][nPosItem]  := cItem
	aCols[Len(aCols)][Len(aHeader)+1] := .F.
Else

	If aCols[Len(aCols)][nPosPerc] = 0
		nCols := Len(aCols)
		cItem := aCols[nCols][nPosItem]
	Else
		If Len(aCols) > 0
			cItem := aCols[Len(aCols)][nPosItem]
		Endif

		Aadd(aCols, Array(Len(aHeader) + 1))
		cItem := Soma1(cItem)
	EndIf

	For nHeader := 1 To Len(aHeader)
		aCols[Len(aCols)][nHeader] := CriaVar(aHeader[nHeader][2])
	Next

	aCols[Len(aCols)][nPosItem] := cItem

	If !Empty(CTJ->CTJ_DEBITO)
		aCols[Len(aCols)][nPosConta]	:= CTJ->CTJ_DEBITO
	Else
		aCols[Len(aCols)][nPosConta]	:= CTJ->CTJ_CREDIT
	Endif

	If lCusto
		If !Empty(CTJ->CTJ_CCD)
			aCols[Len(aCols)][nPosCc]	:= CTJ->CTJ_CCD
		Else
			aCols[Len(aCols)][nPosCc]	:= CTJ->CTJ_CCC
		Endif
	EndIf

	If lItem
		If !Empty(CTJ->CTJ_ITEMD)
			aCols[Len(aCols)][nPosItemCta]	:= CTJ->CTJ_ITEMD
		Else
			aCols[Len(aCols)][nPosItemCta]	:= CTJ->CTJ_ITEMC
		Endif
	EndIf

	If lClVl
		If !Empty(CTJ->CTJ_CLVLDB)
			aCols[Len(aCols)][nPosClVl]	:= CTJ->CTJ_CLVLDB
		Else
			aCols[Len(aCols)][nPosClVl]	:= CTJ->CTJ_CLVLCR
		Endif
	EndIf

	aCols[Len(aCols)][nPosPerc] := CTJ->CTJ_PERCEN
	aCols[Len(aCols)][Len(aHeader) + 1] := .F.
	nPercRat	+= CTJ->CTJ_PERCEN
	nPercARat	-= CTJ->CTJ_PERCEN

	aEntidades := CtbEntArr()
	For nEnt := 1 to Len(aEntidades)
		For nDeb := 1 to 2
			cCpo := "CNZ_EC"+aEntidades[nEnt]
			cCTJ := "CTJ_EC"+aEntidades[nEnt]
			If nDeb == 1
				cCpo += "DB"
				cCTJ += "DB"
			Else
				cCpo += "CR"
				cCTJ += "CR"
			EndIf
			nPosHead := aScan(aHeader,{|x| AllTrim(x[2]) == Alltrim(cCpo) } )
			If nPosHead > 0 .And. CTJ->(FieldPos(cCTJ)) > 0
				aCols[Len(aCols)][nPosHead] := CTJ->(&(cCTJ))
			EndIf
		Next nDeb
	Next nEnt
EndIf

Return .T.

//------------------------------------------------------------------
/*/{Protheus.doc} GCTRatMVC(oModel, cItem, lPrimeiro)
Importa rateio pré-configurado para o modelo

@author 	jose.delmondes
@since 		22/08/2017
@version 	1.0
/*/
//-------------------------------------------------------------------
Function GCTRatMVC(oModel, cItem, lPrimeiro)
Local aEntidades	:= CtbEntArr()
Local lCusto		:= CtbMovSaldo("CTT")
Local lItem			:= CtbMovSaldo("CTD")
Local lCLVL			:= CtbMovSaldo("CTH")
Local cCpo		:= ''
Local cCTJ		:= ''
Local nEnt		:= 0
Local nDeb		:= 0
Local nTamItem	:= GetSx3Cache('CNZ_ITEM', 'X3_TAMANHO')

If Empty(cItem)
	cItem := StrZero(0,nTamItem)
EndIf

If lPrimeiro //-- Primeira chamada, utilizada para limpar o modelo
	If oModel:Length() > 1 .Or. !Empty( oModel:GetValue('CNZ_PERC') )	//-- Verifica se o modelo jah esta preenchido
		CNTA300DlMd( oModel , 'CNZ_ITEM' )	//-- Deleta itens do modelo
		If oModel:GetOperation() == MODEL_OPERATION_UPDATE	//-- Adiciona nova linha em branco, em operacao de alteracao
			oModel:AddLine()
			If oModel:Length() > oModel:Length(.T.) //Se há linhas deletadas que não foram excluídas em definitivo(por exemplo, na alteração de uma revisão)
				cItem := StrZero(Max(0,oModel:Length()-1),nTamItem)
			EndIf
		EndIf
	EndIf
	If Empty(oModel:GetValue('CNZ_ITEM'))
		cItem := Soma1(cItem)
		oModel:LoadValue( 'CNZ_ITEM' , cItem )
	EndIf
Else
	cItem := soma1(cItem) //-- Atualiza item
    If Len(cItem) == nTamItem
        If oModel:IsUpdated()
            oModel:AddLine()	//-- Adiciona nova linha no modelo
            oModel:SetValue( 'CNZ_ITEM' , cItem )
        EndIf
        
        oModel:SetValue( 'CNZ_PERC' , CTJ->CTJ_PERCEN )

        If !Empty(CTJ->CTJ_DEBITO)
            oModel:SetValue( 'CNZ_CONTA' , CTJ->CTJ_DEBITO )
        Else
            oModel:SetValue( 'CNZ_CONTA' , CTJ->CTJ_CREDIT )
        Endif

        If lCusto
            If !Empty(CTJ->CTJ_CCD)
                oModel:SetValue( 'CNZ_CC' , CTJ->CTJ_CCD )
            Else
                oModel:SetValue( 'CNZ_CC' , CTJ->CTJ_CCC )
            Endif
        EndIf

        If lItem
            If !Empty(CTJ->CTJ_ITEMD)
                oModel:SetValue( 'CNZ_ITEMCT' , CTJ->CTJ_ITEMD )
            Else
                oModel:SetValue( 'CNZ_ITEMCT' , CTJ->CTJ_ITEMC )
            Endif
        EndIf

        If lClVl		
            If !Empty(CTJ->CTJ_CLVLDB)
                oModel:SetValue( 'CNZ_CLVL' , CTJ->CTJ_CLVLDB )
            Else
                oModel:SetValue( 'CNZ_CLVL' , CTJ->CTJ_CLVLCR )
            Endif
        EndIf

        //-- Entidades contabeis adicionais
        For nEnt := 1 to Len(aEntidades)
            For nDeb := 1 to 2
                cCpo := "CNZ_EC"+aEntidades[nEnt]
                cCTJ := "CTJ_EC"+aEntidades[nEnt]

                If nDeb == 1
                    cCpo += "DB"
                    cCTJ += "DB"
                Else
                    cCpo += "CR"
                    cCTJ += "CR"
                EndIf
                oModel:SetValue( cCpo , CTJ->(&(cCTJ)) )
            Next nDeb
        Next nEnt
    EndIf
EndIf

Return

//------------------------------------------------------------------
/*/{Protheus.doc} GCTSX7TAB()
Função condicional do gatilho do campo CNB_QUANT
@author 	antenor.silva
@since 		18/12/2017
@version 	1.0
/*/
//-------------------------------------------------------------------
Function GCTSX7TAB()
Return !EMPTY(FWFLDGET('CNB_TABPRC')) .And. Empty(A300GTpRev())

//-------------------------------------------------------------------
/*/{Protheus.doc} CNTXPerc()
Calcula o percentual do valor do pedido utilizado no item da nota 

@author jose.delmondes
@since 28/09/2016
@version 1.0
/*/
//-------------------------------------------------------------------
Function CNTXPerc(cNumPed,nTotItem)
Local nPerc	:= 0
Local cAliasTot	:= GetNextAlias()

BeginSQL Alias cAliasTot
	
	SELECT SUM(C7_TOTAL) TOTAL 
	FROM %Table:SC7% SC7
	WHERE SC7.C7_FILIAL = %Exp:cFilAnt%
	AND SC7.C7_NUM = %Exp:cNumPed% 
	AND SC7.%NotDel%
	
EndSql

nPerc := nTotItem / (cAliasTot)->(TOTAL)

(cAliasTot)->(dbCloseArea())

Return nPerc

//---------------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GctLoadBan
 Função para verificar e exibir banner de novidades do gct.

cUrl - URL da página 

@author Israel.escorizza
@since  23/05/2018

/*/
//---------------------------------------------------------------------------------------------------------------------------------
Function GctLoadBan(cTitle,cUrl,lOption)
Local oProfile	:= Nil
Local oTIBrowser:= Nil
Local oPanel	:= Nil
Local oDlg 		:= Nil
Local dDate		:= Date()
Local aLoad		:= {}

Local lDisable	:= .F. 

DEFAULT	cTitle 	:= STR0085 
DEFAULT cUrl 	:= "http://tdn.totvs.com/plugins/servlet/remotepageview?pageId=367238251"

If cPaisLoc == 'BRA'
	oProfile:= FwProfile():New()
	oProfile:SetTask("BANNERGCT")
	oProfile:SetType("SHOW")
	
	aLoad := oProfile:Load()
	If Empty(aLoad)
	   cShow	:="00000000"
	   lDisable := .F.
	Else
	   cShow	:= aLoad[1]
	   lDisable := aLoad[2] .And. lOption
	EndIf
	
	If !lDisable .And. (STOD(cShow) + 7 < dDate)
		aTam := MsAdvSize()
		oDlg := FWDialogModal():New()
		
		oDlg:SetBackground(.F.)  
		oDlg:SetTitle(cTitle)
		oDlg:SetEscClose(.T.)
		oDlg:SetSize((aTam[4]-aTam[2])*0.89,(aTam[3]-aTam[1])*0.80) 
		oDlg:EnableFormBar(.T.)
		
		oDlg:CreateDialog() 
		oDlg:CreateFormBar()
		oDlg:AddCloseButton()
		
		/*
		If lOption
			oDlg:AddButton( "Desabilitar novidades"			, {|| lDisable := .T.	  ,eval(oDlg:bClose)}, "Desabilita  novidades para este usuário", , .T., .F., .F. )
			oDlg:AddButton( "Não exibir nos próximos 7 dias", {|| cShow := DTOS(dDate),eval(oDlg:bClose)}, "Desabilita  temporariamente este informe para o usuário", , .T., .F., .F. )
		Else
			oDlg:AddButton( "Apresentar novidades ao iniciar módulo", {|| lDisable := .F., cShow := "00000000" ,eval(oDlg:bClose)}, "Habilita novidades para este usuário", , .T., .F., .F. )
		EndIf
		*/
		
		oPanel := oDlg:getPanelMain()   
		
		oTIBrowser := TIBrowser():New(0,0,(aTam[3]-aTam[1])*0.8, (aTam[4]-aTam[2])*0.8,cUrl,oPanel)
		
		oTIBrowser:GoHome()                   
		
		oDlg:Activate()
		
		aTam := aSize(aTam,0)
        aTam := Nil
		
		oProfile:SetProfile({cShow,lDisable})
		oProfile:Save()
	EndIf
	
	oProfile:Destroy()
	oProfile:= Nil
	aLoad := aSize(aLoad,0)
	aLoad := Nil 
EndIf
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} CNTXAlcTp(cChave)
Retorna o tipo do contrato (compra ou venda) a partir da chave do 
documento (CT,RV,IC,IR), contida na tabela SCR (CR_TIPO)

@author jose.delmondes
@since 15/06/2016
@version 1.0
/*/
//-------------------------------------------------------------------
Function CNTXAlcTp( cChave , cTipoDoc )
	Local aAreas	:= { CN9->(GetArea()), CND->(GetArea()),GetArea()}
	Local cContra	:= ''
	Local cRev		:= ''
	Local cMed		:= ''
	Local nTipo 	:= 0
	Local cFilCtr	:= cFilAnt
	Default cTipoDoc := ''

	If cTipoDoc $ 'MD*IM'	
		cMed := Left( cChave , TamSX3('CND_NUMMED')[1] )	
		
		CND->( dbsetOrder( 4 ) )	
		If CND->( dbSeek( xFilial( 'CND' ) + cMed ) )
			cContra := CND->CND_CONTRA
			cRev	:= CND->CND_REVISA
			cFilCtr	:= CND->CND_FILCTR
		EndIf	
	Else	
		cContra	:= Left( cChave , TamSX3('CN9_NUMERO')[1] )
		cRev	:= SubStr( cChave , TamSX3('CN9_NUMERO')[1] + 1 , TamSX3('CN9_REVISA')[1]  )	
	EndIf

	CN9->( dbSetOrder( 1 ) )
	If CN9->( dbSeek( xFilial( 'CN9', cFilCtr) + cContra + cRev ) )	
		nTipo := IIF(Cn300RetSt( 'COMPRA' , , , CN9->CN9_NUMERO , CN9->CN9_FILCTR , .F.), 1, 2)	
	EndIf

	aEval(aAreas, {|x| RestArea(x) })
	FwFreeArray(aAreas)
Return nTipo

//-------------------------------------------------------------------
/*/{Protheus.doc} CNTXLFor( cChave , oModel )
Carrega fornecedores/clientes do contrato para rotina de aprovacao de
documentos.

@author jose.delmondes
@since 15/06/2016
@version 1.0
/*/
//-------------------------------------------------------------------
Function CNTXLFor( cChave , oModel )
	Local aAreas	:= {SCR->(GetArea()), SAK->(GetArea()), GetArea()}
	Local nTamContra:= TamSX3('CN9_NUMERO')[1]
	Local nTamRevisa:= TamSX3('CN9_REVISA')[1]
	Local nTamPlan	:= TamSX3('CNA_NUMERO')[1]
	Local nDecTot	:= TAMSX3("CNA_VLTOT")[2]
	Local cContra	:= Left( cChave , nTamContra )
	Local cRev		:= SubStr( cChave , (nTamContra + 1) , nTamRevisa  )
	Local cPlanilha	:= ""
	Local cAliasCNC := GetNextAlias( )
	Local nTipoCtr 	:= CNTXAlcTp( cChave )
	Local lPrimeiro	:= .T.
	Local oMdlScr	:= oModel:GetModel():GetModel("FieldSCR")
	Local nMoedOri	:= 0
	Local nMoedDest	:= 0
	Local nValor	:= 0
	Local nValorAux := 0
	Local nValorDoc := 0
	Local lFiltPlan	:= .F.
	Local nIniPlan	:= nTamContra + nTamRevisa + 1
	Local lAdiciona	:= .F.

	SCR->(DbGoTo(oMdlScr:GetDataId()))
	nMoedOri := SCR->CR_MOEDA
	nValorDoc:= SCR->CR_TOTAL	
	If (lFiltPlan := (SCR->CR_TIPO $ "IR|IC|"))
		cPlanilha := SubStr( cChave , nIniPlan , nTamPlan )
	EndIf

	SAK->(DbSetOrder(1))//AK_FILIAL+AK_COD
	nMoedDest := IIF(SAK->(DbSeek(xFilial("SAK") + SCR->CR_APROV)), SAK->AK_MOEDA, nMoedOri)

	BeginSQL Alias cAliasCNC
		column CNA_DTINI as Date
		column CNA_DTFIM as Date
		
		SELECT	CNC.CNC_CODIGO , CNC.CNC_LOJA , CNC.CNC_CLIENT , CNC.CNC_LOJACL ,
				CNA.CNA_NUMERO , CNA.CNA_TIPPLA , CNA.CNA_VLTOT , CNA.CNA_DTINI , CNA.CNA_DTFIM, CNA.R_E_C_N_O_ CNARECNO
			
		FROM 	%table:CNA% CNA
		
		INNER JOIN %table:CNC% CNC ON	(CNC.CNC_CODIGO = CNA.CNA_FORNEC AND
										CNC.CNC_LOJA = CNA.CNA_LJFORN AND
										CNC.CNC_CLIENT = CNA.CNA_CLIENT AND
										CNC.CNC_LOJACL = CNA.CNA_LOJACL AND
										CNC.CNC_NUMERO = CNA.CNA_CONTRA AND
										CNC.CNC_REVISA = CNA.CNA_REVISA AND
										CNC.CNC_FILIAL = CNA.CNA_FILIAL AND
										CNC.%Notdel%)
		
		WHERE	CNA.CNA_CONTRA = %exp:cContra% AND
				CNA.CNA_REVISA = %exp:cRev% AND
				CNA.CNA_FILIAL = %xfilial:CNA% AND
				CNA.%Notdel%

		ORDER BY CNA.CNA_NUMERO
		
	EndSQL

	While ( cAliasCNC )->( !Eof( ) )
		
		nValor := Cn300VlApr( Nil, ( cAliasCNC )->CNARECNO)

		lAdiciona := (nValor > 0 .Or. nValorDoc == 0 .Or. (cAliasCNC)->CNA_VLTOT == 0)
		if lAdiciona .And. lFiltPlan
			lAdiciona := ((cAliasCNC)->CNA_NUMERO == cPlanilha)
		endif

		If lAdiciona

			If lPrimeiro
				lPrimeiro := .F.
			Else
				oModel:AddLine( )
			EndIf
			
			If nTipoCtr == 1
				oModel:LoadValue( 'CNC_CODIGO'	, ( cAliasCNC )->CNC_CODIGO )
				oModel:LoadValue( 'CNC_LOJA' 	, ( cAliasCNC )->CNC_LOJA 	)
				oModel:LoadValue( 'CNC_NOME'	, Posicione( 'SA2' , 1 , xFilial( 'SA2' ) + ( cAliasCNC )->CNC_CODIGO + ( cAliasCNC )->CNC_LOJA , 'A2_NOME' ) )
			Else
				oModel:LoadValue( 'CNC_CLIENT'	, ( cAliasCNC )->CNC_CLIENT )
				oModel:LoadValue( 'CNC_LOJACL' 	, ( cAliasCNC )->CNC_LOJACL )
				oModel:LoadValue( 'CNC_NOMECL'	, Posicione( 'SA1' , 1 , xFilial( 'SA1' ) + ( cAliasCNC )->CNC_CLIENT + ( cAliasCNC )->CNC_LOJACL , 'A1_NOME' ) )
			EndIf
			
			oModel:LoadValue( 'CNC_NUMPLA'	, ( cAliasCNC )->CNA_NUMERO	)
			oModel:LoadValue( 'CNC_TIPPLA'	, ( cAliasCNC )->CNA_TIPPLA	)
			oModel:LoadValue( 'CNC_DESCRI'	, Posicione( 'CNL' , 1 , xFilial( 'CNL' ) + ( cAliasCNC )->CNA_TIPPLA , "CNL_DESCRI" ) )			
			
			If(nMoedOri != nMoedDest)
				nValor := xMoeda(nValor,nMoedOri,nMoedDest,SCR->CR_EMISSAO, nDecTot,SCR->CR_TXMOEDA)
			EndIf
			
			oModel:LoadValue( 'CNC_VLTOT'	, nValor )
			oModel:LoadValue( 'CNC_DIASV'	, ( cAliasCNC )->CNA_DTFIM - ( cAliasCNC )->CNA_DTINI )
			
			nValorAux += nValor
		EndIf		
		
		(cAliasCNC)->(DbSkip())		
	EndDo

	( cAliasCNC )->( dbCloseArea( ) )

	If oMdlScr:HasField("CR_TOTAL")
		oMdlScr:LoadValue("CR_TOTAL", nValorAux)
	ElseIf(oMdlScr:HasField("CR_DTOTAL"))
		oMdlScr:LoadValue("CR_DTOTAL", nValorAux)
	EndIf

	CNTA300BlMd( oModel , .T. )
	oModel:GoLine( 1 )

	aEval(aAreas, {|x| RestArea(x), aSize(x, 0)})
Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} CNTXLForMd( cChave , oModel )
Carrega fornecedores/clientes da medicao para rotina de aprovacao de
documentos.

@author jose.delmondes
@since 15/06/2016
@version 1.0
/*/
//-------------------------------------------------------------------
Function CNTXLForMd( cChave , cTipoDoc , oModel )
	Local aAreas	:= {CND->(GetArea()), CNA->(GetArea()), CXN->(GetArea()), GetArea()}
	Local cMedicao	:= Left( cChave , TamSX3('CND_NUMMED')[1] )
	Local cPlanilha	:= ''
	Local nTipoCtr 	:= CNTXAlcTp( cChave , cTipoDoc )
	Local oMdlScr	:= oModel:GetModel():GetModel("FieldSCR")
	Local nMoedOri	:= 0
	Local nMoedDest	:= 0
	Local nValor	:= 0
	Local nDecTot	:= TAMSX3("CNA_VLTOT")[2]
	Local nValorAux := 0

	SCR->(DbGoTo(oMdlScr:GetDataId()))
	nMoedOri := SCR->CR_MOEDA

	SAK->(DbSetOrder(1))//AK_FILIAL+AK_COD
	nMoedDest := IIF(SAK->(DbSeek(xFilial("SAK") + SCR->CR_APROV)), SAK->AK_MOEDA, nMoedOri)

	dbSelectArea( 'CND' )
	CND->( dbSetOrder( 4 ) )

	If CND->( dbSeek( xFilial('CND') + cMedicao ) )
		
		dbSelectArea('CNA')
		CNA->( dbSetOrder( 1 ) )
		
		If IsNewMed( CND->CND_CONTRA , CND->CND_REVISA , CND->CND_NUMMED )
			
			dbSelectArea('CXN')
			CXN->( dbSetOrder( 1 ) )
			
			If cTipoDoc == 'IM'
				
				cPlanilha := SubStr( cChave , TamSX3('CND_NUMMED')[1] + 1 , TamSX3('CNA_NUMERO')[1]  )
				
				If CXN->( dbSeek( xFilial('CXN') + CND->CND_CONTRA + CND->CND_REVISA + CND->CND_NUMMED + cPlanilha ) )
						
					If nTipoCtr == 1
						oModel:LoadValue( 'CNC_CODIGO'	, CXN->CXN_FORNEC )
						oModel:LoadValue( 'CNC_LOJA' 	, CXN->CXN_LJFORN )
						oModel:LoadValue( 'CNC_NOME'	, Posicione( 'SA2' , 1 , xFilial( 'SA2' ) + CXN->CXN_FORNEC + CXN->CXN_LJFORN , 'A2_NOME' ) )
					Else
						oModel:LoadValue( 'CNC_CLIENT'	, CXN->CXN_CLIENT )
						oModel:LoadValue( 'CNC_LOJACL' 	, CXN->CXN_LJCLI )
						oModel:LoadValue( 'CNC_NOMECL'	, Posicione( 'SA1' , 1 , xFilial( 'SA1' ) + CXN->CXN_CLIENT + CXN->CXN_LJCLI , 'A1_NOME' ) )
					EndIf
					
					If CNA->( dbSeek( xFilial( 'CNA' , CND->CND_FILCTR ) + CND->CND_CONTRA + CND->CND_REVISA + CXN->CXN_NUMPLA ) )

						oModel:LoadValue( 'CNC_NUMPLA'	, CNA->CNA_NUMERO )
						oModel:LoadValue( 'CNC_TIPPLA'	, CNA->CNA_TIPPLA )
						oModel:LoadValue( 'CNC_DESCRI'	, Posicione( 'CNL' , 1 , xFilial( 'CNL' ) + CNA->CNA_TIPPLA , "CNL_DESCRI" ) )
						
						nValor := CND->CND_VLTOT
						If(nMoedOri != nMoedDest)
							nValor := xMoeda(nValor,nMoedOri,nMoedDest,SCR->CR_EMISSAO, nDecTot,SCR->CR_TXMOEDA)
						EndIf
						
						oModel:LoadValue( 'CNC_VLTOT'	, nValor )
						oModel:LoadValue( 'CNC_DIASV'	, CNA->CNA_DTFIM - CNA->CNA_DTINI )

						nValorAux += nvalor
					
					EndIf	

				EndIf
			
			Else
			
				If CXN->( dbSeek( xFilial('CXN') + CND->CND_CONTRA + CND->CND_REVISA + CND->CND_NUMMED ) )
					
					While !CXN->(Eof()) .And. CXN->( CXN_FILIAL + CXN_CONTRA + CXN_REVISA + CXN_NUMMED )  == CND->( CND_FILIAL + CND_CONTRA + CND_REVISA + CND_NUMMED )
						
						If CXN->CXN_CHECK
						
							If ( nTipoCtr == 1 .And. !Empty( oModel:GetValue( 'CNC_CODIGO' ) ) ) .Or. ( nTipoCtr == 2 .And. !Empty( oModel:GetValue( 'CNC_CLIENT' ) ) )
								oModel:AddLine()
							EndIf
						
							If nTipoCtr == 1
								oModel:LoadValue( 'CNC_CODIGO'	, CXN->CXN_FORNEC )
								oModel:LoadValue( 'CNC_LOJA' 	, CXN->CXN_LJFORN )
								oModel:LoadValue( 'CNC_NOME'	, Posicione( 'SA2' , 1 , xFilial( 'SA2' ) + CXN->CXN_FORNEC + CXN->CXN_LJFORN , 'A2_NOME' ) )
							Else
								oModel:LoadValue( 'CNC_CLIENT'	, CXN->CXN_CLIENT )
								oModel:LoadValue( 'CNC_LOJACL' 	, CXN->CXN_LJCLI )
								oModel:LoadValue( 'CNC_NOMECL'	, Posicione( 'SA1' , 1 , xFilial( 'SA1' ) + CXN->CXN_CLIENT + CXN->CXN_LJCLI , 'A1_NOME' ) )
							EndIf
							
							If CNA->( dbSeek( xFilial( 'CNA' , CND->CND_FILCTR ) + CND->CND_CONTRA + CND->CND_REVISA + CXN->CXN_NUMPLA ) )
		
								oModel:LoadValue( 'CNC_NUMPLA'	, CNA->CNA_NUMERO )
								oModel:LoadValue( 'CNC_TIPPLA'	, CNA->CNA_TIPPLA )
								oModel:LoadValue( 'CNC_DESCRI'	, Posicione( 'CNL' , 1 , xFilial( 'CNL' ) + CNA->CNA_TIPPLA , "CNL_DESCRI" ) ) 	
								
								nValor := CXN->(CXN_VLTOT - CXN_VLRADI)
								If HasCpoFrete() .And. nTipoCtr == 1
									nValor := nValor + CXN->(CXN_FRETE + CXN_DESPES + CXN_SEGURO)
								Endif
								If(nMoedOri != nMoedDest)
									nValor := xMoeda(nValor,nMoedOri,nMoedDest,SCR->CR_EMISSAO, nDecTot,SCR->CR_TXMOEDA)
								EndIf
								
								oModel:LoadValue( 'CNC_VLTOT'	, nValor )
								oModel:LoadValue( 'CNC_DIASV'	, CNA->CNA_DTFIM - CNA->CNA_DTINI )

								nValorAux += nvalor
							
							EndIf	
					
						EndIf
						
						CXN->(DbSkip())
					End
				EndIf
			EndIf
			
		Else
			
			If nTipoCtr == 1
				oModel:LoadValue( 'CNC_CODIGO'	, CND->CND_FORNEC )
				oModel:LoadValue( 'CNC_LOJA' 	, CND->CND_LJFORN )
				oModel:LoadValue( 'CNC_NOME'	, Posicione( 'SA2' , 1 , xFilial( 'SA2' ) + CND->CND_FORNEC + CND->CND_LJFORN , 'A2_NOME' ) )
			Else
				oModel:LoadValue( 'CNC_CLIENT'	, CND->CND_CLIENT )
				oModel:LoadValue( 'CNC_LOJACL' 	, CND->CND_LOJACL )
				oModel:LoadValue( 'CNC_NOMECL'	, Posicione( 'SA1' , 1 , xFilial( 'SA1' ) + CND->CND_CLIENT + CND->CND_LOJACL , 'A1_NOME' ) )
			EndIf
				
			If CNA->( dbSeek( xFilial( 'CNA' , CND->CND_FILCTR ) + CND->CND_CONTRA + CND->CND_REVISA + CND->CND_NUMERO ) )
				
				oModel:LoadValue( 'CNC_NUMPLA'	, CNA->CNA_NUMERO )
				oModel:LoadValue( 'CNC_TIPPLA'	, CNA->CNA_TIPPLA )
				oModel:LoadValue( 'CNC_DESCRI'	, Posicione( 'CNL' , 1 , xFilial( 'CNL' ) + CNA->CNA_TIPPLA , "CNL_DESCRI" ) ) 	
				
				nValor := CND->CND_VLTOT	
				If(nMoedOri != nMoedDest)
					nValor := xMoeda(nValor,nMoedOri,nMoedDest,SCR->CR_EMISSAO, nDecTot,SCR->CR_TXMOEDA)
				EndIf
				
				oModel:LoadValue( 'CNC_VLTOT'	, nValor )
				oModel:LoadValue( 'CNC_DIASV'	, CNA->CNA_DTFIM - CNA->CNA_DTINI )

				nValorAux += nvalor
			
			EndIf
				
		EndIf	
		
	EndIf

	If oMdlScr:HasField("CR_TOTAL")
		oMdlScr:LoadValue("CR_TOTAL", nValorAux)
	ElseIf(oMdlScr:HasField("CR_DTOTAL"))
		oMdlScr:LoadValue("CR_DTOTAL", nValorAux)
	EndIf

	CNTA300BlMd( oModel , .T. )
	oModel:GoLine( 1 )

	aEval(aAreas, {|x| RestArea(x), aSize(x, 0)})
Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} GCTLog
Visualiza um texto de log e dá opção de salvar o arquivo ao usuário

@param cTitulo, character, Título da dialog onde é exibido o log
@param cTexto, character, Texto a ser exibido e salvo
@param nTipo, numérico, Botões para usuário (1 = Ok; 2 = Confirmar e Cancelar)
@param lEdit, lógico, Define se o Log pode ser editado pelo usuário

@return lRetMens, Define se a janela foi confirmada

@example
    GCTLog("Teste de Log", "Log GCT", 1, .T.)
    GCTLog("Teste de Log", "Log GCT", 2, .F.)
    
@author janaina.jesus
@since 24/07/2018
@version 1.0
/*/
//-------------------------------------------------------------------
Function GCTLog(cMsg, cTitulo, nTipo, lEdit)
Local lRetMens := .F.
Local oDlgMens
Local oBtnOk, cTxtConf := ""
Local oBtnCnc, cTxtCancel := ""
Local oBtnSlv
Local oFntTxt
Local oMsg

Default cMsg    := ""
Default cTitulo := "SIGAGCTLog"
Default nTipo   := 1 //1=Ok; 2= Confirmar e Cancelar
Default lEdit   := .F.
 
//--Definindo os textos dos botões
If(nTipo == 1)
	cTxtConf:='&Ok'
Else
	cTxtConf:='&Confirmar'
	cTxtCancel:='C&ancelar'
EndIf
//--Criando a janela centralizada com os botões
DEFINE FONT oFntTxt NAME "Mono AS" SIZE 7,15   //6,15
DEFINE MSDIALOG oDlgMens TITLE cTitulo FROM 0,0  TO 420,780 PIXEL
@ 5,5 GET oMsg VAR cMsg MEMO SIZE 430,185 OF oDlgMens PIXEL

oMsg:lWordWrap	:= .F.
oMsg:Align 		:= CONTROL_ALIGN_TOP
If !lEdit
	oMsg:lReadOnly := .T.
EndIf
 
If (nTipo==1)
	@ 192, 290 BUTTON oBtnOk  PROMPT cTxtConf   SIZE 045, 015 ACTION (lRetMens:=.T., oDlgMens:End()) OF oDlgMens PIXEL
ElseIf(nTipo==2)
	@ 192, 240 BUTTON oBtnOk  PROMPT cTxtConf   SIZE 045, 015 ACTION (lRetMens:=.T., oDlgMens:End()) OF oDlgMens PIXEL
	@ 192, 290 BUTTON oBtnCnc PROMPT cTxtCancel SIZE 045, 015 ACTION (lRetMens:=.F., oDlgMens:End()) OF oDlgMens PIXEL
EndIf
 
//Botão de Salvar em Txt
@ 192, 005 BUTTON oBtnSlv PROMPT "&Salvar em .txt" SIZE 045, 015 ACTION (fSalvArq(cMsg, cTitulo)) OF oDlgMens PIXEL
	ACTIVATE MSDIALOG oDlgMens CENTERED 
    
Return lRetMens
 
//-------------------------------------------------------------------
/*/{Protheus.doc} fSalvArq
Salva arquivo de log

@param cTitulo, character, Título do log
@param cTexto, character, Texto a ser salvo

@return True se salvou o arquivo, False se não

@author janaina.jesus
@since 24/07/2018
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function fSalvArq(cMsg, cTitulo)
Local cFileNom :='\x_arq_'+dToS(Date())+StrTran(Time(),":")+".txt"
Local cQuebra  := CRLF + STR0086 + CRLF
Local lOk      := .T.
Local cTexto   := ""
 
cFileNom := cGetFile( STR0087, STR0088,,'',.T., GETF_LOCALHARD) //--Caminho do arquivo
 
If !Empty(cFileNom)
	If ! ExistDir(SubStr(cFileNom,1,RAt('\',cFileNom)))
    	Alert(STR0089 + CRLF + SubStr(cFileNom, 1, RAt('\',cFileNom)) + "!")
		Return
	EndIf
 
	//--Criando a mensagem
	cTexto := "Função   - "+ FunName()       + CRLF
	cTexto += "Usuário  - "+ cUserName       + CRLF
	cTexto += "Data     - "+ dToC(dDataBase) + CRLF
	cTexto += "Hora     - "+ Time()          + CRLF
	cTexto += "Mensagem - "+ cTitulo + cQuebra  + cMsg + cQuebra
 
	If File(cFileNom) //--Verifico se o arquivo já existe
		lOk := MsgYesNo(STR0090, STR0051)
	EndIf
	 
	If lOk
		MemoWrite(cFileNom, cTexto)
	 	MsgInfo(STR0091 + CRLF + cFileNom, STR0051)
	EndIf
EndIf
Return

//=============================================================================
/*/{Protheus.doc} GctGatTes(cCodProd,lTE)
Função responsável por definir e gatilhar o TES para contratos e medições.

@Param 	cCodProd, 	caracter, 	Código do produto para verificação do TES.
@Param	lTE,		logico,		Informa se será verificada um Tipo de Entrada

@Return cTes,		caracter,	Código do TES para o produto informado.	

@author israel.escorizza
@since 01/08/2018
@version 1.0
/*/
//=============================================================================
Function GctGatTes(cCodProd,lTE)
//- Variaveis de controle de area ---------------------------------------------
Local aArea			:= GetArea()
Local aSaveLines	:= FwSaveRows()

//-	Variaveis para definição do TES -------------------------------------------
Local cTabTES		:= AllTrim(SuperGetMV("MV_ARQPROD",.F.,'SB1'))
Local cCpoTES		:= SUBSTR(cTabTES, -2, 2) 
Local cTes			:= ""

Default cCodProd	:= ""

If !Empty(cCodProd)
	If lTE 
		If Cn300RetSt('COMPRA')
			cTes := Posicione(cTabTES,1,xFilial(cTabTES)+cCodProd,cCpoTES+'_TE')
		EndIf
	Else
		If Cn300RetSt('VENDA')
			cTes := Posicione(cTabTES,1,xFilial(cTabTES)+cCodProd,cCpoTES+'_TS')
		EndIf
	EndIf
	
	If Empty(cTes)
		cTes := ""
	EndIf
EndIf

FWRestRows(aSaveLines)
RestArea(aArea)
Return cTes

//------------------------------------------------------------------
/*/{Protheus.doc} MdRevAtu()
Função que retorna o codigo da ultima revisão do contrato utilizada na medição.

@param cContra, caracter, numero do contrato
@return cUltRev, caracter, ultima revisão na medição

@author 	janaina.jesus
@since 		31/07/2018
/*/
//-------------------------------------------------------------------
Function MdRevAtu(cContra, cFilCtr)
Local aArea     := GetArea()
Local cAliasRev := GetNextAlias()
Local cUltRev	:= ""
Default cFilCtr := cFilAnt

BeginSQL Alias cAliasRev
	SELECT MAX(CND_REVISA) AS CND_REVISA
	FROM %Table:CND% CND
	WHERE CND.CND_FILIAL = %Exp:xFilial("CND")% AND CND.CND_CONTRA= %Exp:cContra% AND CND.%NotDel% AND CND.CND_FILCTR= %Exp:cFilCtr%
EndSQL

cUltRev := (cAliasRev)->CND_REVISA

(cAliasRev)->(dbCloseArea())

RestArea(aArea)
Return cUltRev

/*/{Protheus.doc} PegaQtdSCR
Função para retornar a quantidade de registros pendentes de aprovação
na tabela SCR, para o contrato informado

@param cTipo, Tipo de alçada 
@param cNum, Número do contrato
@Return nRet, Indica a quantidade de registros pendentes de aprovação

@author pedro.alencar
@since 01/03/2019
/*/
Static Function PegaQtdSCR( cTipo As Char, cNum As Char ) As Numeric
	Local nRet := 0 As Numeric
	Local aAreas := {SAL->(GetArea()), GetArea()} As Array 
	Local cQuery As Char	
	Local cTmpAlias As Char
	Local cTipoLiber As Char
	Local oQuery as Object
	Default cTipo := ""
	Default cNum := ""
	
	SAL->(dbSetOrder(3)) //AL_FILIAL+AL_COD+AL_APROV
	If !Empty(SCR->CR_APRORI) //Caso o documento tenha sido transferido para o superior, posiciona a tabela SAL pelo aprovador de origem.
		SAL->(MsSeek(xFilial("SAL")+SCR->(CR_GRUPO+CR_APRORI)))
	Else
		SAL->(MsSeek(xFilial("SAL")+SCR->(CR_GRUPO+CR_APROV)))
	EndIf  
	
	cTipoLiber := SAL->AL_TPLIBER //"U" = Por Usuário, "N" = Por Nível, "P" = Por Documento.

	If cTipo == "IC"
		cNum := PadR( cNum, TamSX3('CNB_CONTRA')[1] )
	ElseIf cTipo $ "RV|IR"
		cNum := PadR( cNum, TamSX3('CNB_CONTRA')[1] + TAMSX3('CNB_REVISA')[1] )
	ElseIf cTipo == "IM"
		cNum := PadR( cNum, TamSX3('CND_NUMMED')[1] )
	Else
		cNum := PadR( cNum, Len(SCR->CR_NUM) )
	EndIf		

	If cTipoLiber == "N" //Quando for aprovação por nível, realizo o Count pelo CR_NIVEL para identificar quantos níveis diferentes eu tenho
		cQuery := "SELECT COUNT(CR.CR_NIVEL) QTDE FROM ("
		cQuery += "SELECT CR_NUM, CR_NIVEL"
	ElseIf(cTipoLiber == "P") //Quando for por Documento, realizo o Count pelo CR_NUM para identificar quantos documentos diferentes eu tenho
		cQuery := "SELECT COUNT(CR.CR_NUM) QTDE FROM ("
		cQuery += "SELECT CR_NUM"
	Else
		cQuery := "SELECT COUNT(R_E_C_N_O_) QTDE"
	EndIf

	cQuery += " FROM " + RetSqlName("SCR")
	cQuery += " WHERE "
	cQuery += " CR_FILIAL = ? "
	cQuery += " AND CR_NUM LIKE ?"
	cQuery += " AND CR_TIPO = ? "
	cQuery += " AND CR_STATUS NOT IN (?)" 
	cQuery += " AND R_E_C_N_O_ <> ?" 
	cQuery += " AND D_E_L_E_T_ = ? "

	If cTipoLiber == "N"//Quando for aprovação por nível, conta quantos níveis diferentes estão pendentes de aprovação 
		cQuery += " GROUP BY CR_NUM, CR_NIVEL)  CR "
	ElseIf(cTipoLiber == "P") //Quando for por Documento, conta pelo numero do documento
		cQuery += " GROUP BY CR_NUM) CR "
	EndIf
	
	cQuery := ChangeQuery( cQuery )

	oQuery := FWExecStatement():New(cQuery) 	
	oQuery:SetString(1, FWxFilial("SCR"))
	oQuery:SetString(2, '%'+cNum+'%' )	
	oQuery:SetString(3, cTipo)
	oQuery:SetIn(4, {'03','05'})//'03' = Aprovado pelo usuário, '05' = Aprovado por outro usuário
	oQuery:SetNumeric(5, SCR->(RecNo()) ) //Não considera a SCR sendo aprovada
	oQuery:SetString(6, Space(1) )

	cTmpAlias := oQuery:OpenAlias()
	
	While ( cTmpAlias )->( ! EOF() )		
		nRet += ( cTmpAlias )->( QTDE )
		( cTmpAlias )->( DbSkip() )
	End
	
	( cTmpAlias )->( dbCloseArea() )
	
	aEval( aAreas , {|x| RestArea(x) } )
    FwFreeArray( aAreas )

	FreeObj(oQuery)
Return nRet

/*/{Protheus.doc} LiberaAlc
Função para liberar o bloqueio de alçadas, chamar a contabilização
e chamar a geração dos títulos provisórios

@param oModel, Modelo de dados do contrato
@param cTpAlcada, Indica o tipo de documento que está sendo liberada
@param cAprovSup, Indica superior que está aprovando alçada
@Return lRet, Indica se a liberação foi realizada com sucesso

@author pedro.alencar
@since 01/03/2019
/*/
Static Function LiberaAlc( oModel As Object, cTpAlcada As Char, cAprovSup As Char) As Logical
	Local lRet As Logical
	Local lTitProv As Logical
	Default oModel := Nil
	Default cTpAlcada := ""
	Default cAprovSup := ""
	
	lTitProv := .F.

	If !Empty(cAprovSup) //Verifica se o aprovador é superior
		lRet := A097ProcSup( SCR->(Recno()), 2,, cAprovSup,,,, dDataBase, oModel )
	Else
		lRet := A097ProcLib( SCR->(Recno()), 2,,,,, dDataBase, oModel )
	EndIf
	
	If lRet .And. cTpAlcada $ "CT|IC"
		lTitProv := ( GetNewPar( "MV_CNPROVI", "S" ) == "S" ) //Se gera títulos provisórios
		
		//Chama a contabilizacao do contrato
		CN100Contab( "694" )
		
		//Chama a contabilização por item da planilha
		CN100ConIt( "69L" )
		
		If lTitProv
			MsAguarde( {|| CN100CTit( CN9->CN9_NUMERO, CN9->CN9_REVISA )}, STR0079 ) //Gera Titulos provisorios
			MsAguarde( {|| CN100RecTi( CN9->CN9_NUMERO, CN9->CN9_REVISA )}, STR0079 ) //Gera Titulos provisorios recorrentes
		EndIf
	EndIF
	
Return lRet

/*/{Protheus.doc} AprAlcCTB
Função para aprovação de alçada contábil

@param cTpAlcada, Indica o tipo de documento a ser aprovado
@param lAprCInv, Indica se é aprovação de alçada no fluxo normal ou inverso
@param oModel, Modelo de dados do contrato 
@param cAprovSup, Indica superior que está aprovando alçada
@Return lRet, Indica se a aprovação foi realizada com sucesso

@author pedro.alencar
@since 22/03/2019
/*/
Static Function AprAlcCTB( cTpAlcada As Char, lAprCInv As Logical, oModel As Object, cAprovSup As Char ) As Logical
	Local lRet As Logical
	Local lAlcCtDoc As Logical
	Local lNivelLeg As Logical
	Local nQtdSCR As Numeric
	Local nVlrApr As Numeric
	Local cTipoDoc As Char
	Default cTpAlcada := ""
	Default lAprCInv := .F.
	Default oModel := Nil
	Default cAprovSup := ""
	
	lRet := .T.
	lNivelLeg := .T.
	nQtdSCR := PegaQtdSCR( SCR->CR_TIPO, SCR->CR_NUM )
	
	If lAprCInv //Fluxo de apovação invertido (Alçada de documento > Alçada contábil)
		If nQtdSCR <= 1
			lRet := LiberaAlc( oModel, cTpAlcada, cAprovSup )
		Else
			lRet := MaAlcDoc( {SCR->CR_NUM,SCR->CR_TIPO,SCR->CR_TOTAL,SCR->CR_APROV,,SCR->CR_GRUPO,,,,,SCR->CR_OBS}, dDataBase, 4 )
		EndIf
	Else //Fluxo de aprovação normal (Alçada contábil > Alçada de documento)
		If nQtdSCR <= 1
			CN9->( MsSeek( FWxFilial("CN9") + Left(SCR->CR_NUM,Len(CN9->CN9_NUMERO)) + CnGetRevAt(Left(SCR->CR_NUM,Len(CN9->CN9_NUMERO))) ) )
			lAlcCtDoc := Cn300RetSt( "ALCCTDOC", 0,, CN9->CN9_NUMERO, CN9->CN9_FILCTR, .F. )
			
			If lAlcCtDoc .And. !Empty(CN9->CN9_APROV) 
				lRet := MaAlcDoc( {SCR->CR_NUM,SCR->CR_TIPO,SCR->CR_TOTAL,SCR->CR_APROV,,SCR->CR_GRUPO,,,,,SCR->CR_OBS}, dDataBase, 4 )
				If lRet
					cTipoDoc := Iif( cTpAlcada == "IC", "CT", "RV" )
					nVlrApr	 := IIF((cTipoDoc == "RV"), Cn300VlApr(Nil, 0), CN9->CN9_VLATU)					
					lNivelLeg := MaAlcDoc( {CN9->(CN9_NUMERO+CN9_REVISA),cTipoDoc, nVlrApr,"","",CN9->CN9_APROV,"",CN9->CN9_MOEDA,0,dDataBase,""}, dDataBase, 1, "", .F. )
				EndIf
			Else
				lRet := LiberaAlc( oModel, cTpAlcada, cAprovSup )
			EndIf
			
			If !lNivelLeg //Tratamento trazido do legado, pois pode ter impacto nos trechos de tratamento do fluig na função GCTAlcEnt
				If cTpAlcada == "IC"
					cTpAlcada := "CT"
				ElseIf cTpAlcada == "IR"
					cTpAlcada := "RV"
				EndIf
			EndIf
		ElseIf nQtdSCR > 1
			lRet := MaAlcDoc( {SCR->CR_NUM,SCR->CR_TIPO,SCR->CR_TOTAL,SCR->CR_APROV,,SCR->CR_GRUPO,,,,,SCR->CR_OBS}, dDataBase, 4 )
		EndIf
	EndIf
Return lRet

/*/{Protheus.doc} PosMdRevAt
	Se posiciona no registro da CND cujo o numero seja <cNumMed> e que seja da ultima revisao.
@author philipe.pompeu
@since 31/01/2020
@return lResult, verdadeiro caso se posicione corretamente
/*/
Function PosMdRevAt(cNumMed)
	Local lResult	:= .F.	
	Local cRevAtu	:= ""
	Local cChave	:= ""
	
	CND->(dbSetOrder(4))//CND_FILIAL+CND_NUMMED
	cChave := xFilial("CND") + cNumMed
	If (lResult := ( CND->(MsSeek(cChave)) ))		
		cRevAtu := MdRevAtu(CND->CND_CONTRA, CND->CND_FILCTR)
		If CND->CND_REVISA != cRevAtu
			CND->(dbSetOrder(7))//CND_FILIAL+CND_CONTRA+CND_REVISA+CND_NUMMED
			cChave	:= CND->(CND_FILIAL + CND_CONTRA + cRevAtu + CND_NUMMED)
			lResult	:= CND->(DbSeek(cChave))			
		EndIf
	EndIf
Return( lResult )

/*/{Protheus.doc} VldEstorMd
	Valida o Estorno da Medicao: realiza diversas validacoes que antecedem o estorno da medicao.
@author philipe.pompeu
@since 24/02/2020
@return lContinua, verdadeiro caso seja possivel executar o estorno da medicao
/*/
Function VldEstorMd(lAprRev as Logical, cMedErro as Char, lAuto as Logical, lPlanil As Logical) as Logical
	Local aAreas	:= {CN9->(GetArea()), GetArea()}
	Local lContinua	:= .T.
	Local lAutoFor	:= (CND->CND_AUTFRN == "2")
	Local lMedServ	:= (CND->CND_SERVIC == "2")
    Local lEstMedRev:= FwIsInCallStack("EstMedRev")
	Local lVldVige 	:= (GetNewPar("MV_CNFVIGE","N") == "N") .And. !FwIsInCallStack("CN300REVPD") .And. !lEstMedRev
	Local dDataBloq	:= GetNewPar("MV_ATFBLQM",CTOD("")) //Data de Bloqueio da Movimentação - MV_ATFBLQM
	Local cFilCtr	:= CND->CND_FILCTR

	Default lAprRev	:= FwIsInCallStack("CN300REVPD")
	Default cMedErro:= "" //Variavel que possibilita obter a mensagem de erro
	Default lAuto	:= .F.
	Default lPlanil	:= .F.

	If lContinua
		lContinua := cn120vldMov(CND->CND_FILCTR, CND->CND_CONTRA, CND->CND_REVISA, @cMedErro)
	EndIf
	
	//Verifica se existe bloqueio contábil
	If lContinua .And. CtbValiDt(Nil, dDataBase,/*.T.*/ ,Nil ,Nil ,{"GCT001"}/*,"Data de apuração bloqueada pelo calendário contábil."*/)
		If!Empty(dDataBloq) .AND. ( dDataBase <= dDataBloq)			
			Help(" ",1,"ATFCTBBLQ") //P: Processo bloqueado pelo Calendário Contábil ou parâmetro de bloqueio nesta data ou período. S: Caso possível altere a data de referência do processo, verifique o parâmetro ou contate o responsável pelo Módulo Contábil.)
			lContinua := .F.
		End
	EndIf

	If lContinua .And. (!lAutoFor .Or. !lMedServ)
		lContinua := CN240VldUsr(CND->CND_CONTRA,DEF_TRAEST_MED,.T.,,cFilCtr)
	EndIf
	
	CN9->(dbSetOrder(1))
	If lContinua
		If ( lVldVige .And. CN9->(dbSeek(xFilial("CN9",cFilCTR)+CND->CND_CONTRA+CnGetRevVg(CND->CND_CONTRA, cFilCtr),.T.)))			
			//-- So permite o estorno se o contrato estiver vigente
			If (CN9->CN9_DTINIC > dDataBase .Or. CN9->CN9_DTFIM < dDataBase)
				lContinua := .F.
				Help( " ", 1, "CNTA120_07" )//Contrato fora do periodo de vigencia
				cMedErro := "CNTA120_07: " + STR0097
			EndIf
		EndIf 
		CN9->(dbSeek(xFilial("CN9",cFilCTR)+CND->CND_CONTRA+CnGetRevAt(CND->CND_CONTRA, cFilCtr),.T.))
	EndIf

	If lContinua .And. CN9->CN9_SITUAC == DEF_SSPAR
		lContinua := .F.
		Help("",1,"CNTA120_SF",,STR0106,4,1) //-- Ação não disponível para contrato em Sol. Finalização.
		cMedErro := "CNTA120_SF: " + STR0106
	EndIf
	If lContinua .And. CN9->CN9_SITUAC == DEF_SFINA
		lContinua := .F.
		Help("",1,"CNTA120_FN",,STR0098,4,1) //-- Ação não disponível para contrato Finalizado
		cMedErro := "CNTA120_FN: " + STR0098 //-- Ação não disponível para contrato Finalizado
	EndIF
	If lContinua .And. CN9->CN9_SITUAC == DEF_SCANC
		lContinua := .F.
		Help('',1,"CNTA120_10")	//-- Ação não disponível para contrato Cancelado
		cMedErro := "CNTA120_10: " + STR0099 //-- Ação não disponível para contrato Cancelado
	EndIf
	If lContinua .And. !lAprRev .And. !lEstMedRev .And. CN9->CN9_SITUAC == DEF_SREVS
		lContinua := .F.
		Help('',1,"CNTA120_11")	//-- Ação não disponível para contrato com Revisão em Aberto
		cMedErro := "CNTA120_11: " + STR0100 //-- Ação não disponível para contrato com Revisão em Aberto
	EndIf
	If lContinua .And. !lEstMedRev .And. (CN9->CN9_REVISA <> CND->CND_REVISA) //-- Verifica se a revisao da medição é a revisão atual
		lContinua := .F.
		Help('',1,"CNTA120_12")	//-- Estorno não permitido para revisões anteriores.
		cMedErro := "CNTA120_12: " + STR0101 //-- Estorno não permitido para revisões anteriores.
	EndIf
	If lContinua .And. nModulo <> 28
		dbSelectArea("TFJ")
		TFJ->(dbSetOrder(5))
		If TFJ->(MsSeek(xFilial("TFJ")+CN9->CN9_NUMERO+CN9->CN9_REVISA)) .And. Cn120IsMdGS( CND->CND_NUMMED )
			lContinua := .F.
			Help(" ",1,"CNTA120TEC") //-- Acao disponivel apenas para contratos sem vinculos com Gestão de Serviços
		EndIf
	EndIf

	If lContinua .And. !lAuto
		If lAprRev			
			lContinua := .T.
		ElseIf !lPlanil			
			lContinua := (Aviso("CNTA121",IIF(lAutoFor, STR0104, STR0105),{STR0102,STR0103}) == 1)//"Confirma estorno da Aut.Forn/Medicao?"
		EndIf
	EndIf
	aEval(aAreas, {|x| RestArea(x), aSize(x,0)})
Return lContinua

/*/{Protheus.doc} CNXStClean
	Limpa variaveis estaticas de cache do CNTXFUN
@author philipe.pompeu
@since 19/08/2020
@return Nil
/*/
Function CNXStClean()
	If (ValType(_aWhenMdls) == 'J')		
		FreeObj(_aWhenMdls)
	EndIf

	If (ValType(_aWhenOrig) == 'J')		
		FreeObj(_aWhenOrig)
	EndIf
Return Nil

/*/{Protheus.doc} CalcAdiant
Função obter o valor do adiantamento proporcional ao valor do item do pedido de compra/venda

@param cContra, Número do contrato
@param cRevisa, Número da revisão
@param cNumMed, Número da medição
@param cNumPla, Número da planilha
@param cItem, Número do item
@param nTotItem, Valor total do item
@Return nAdiant, Valor do adiantamento

@author juan.felipe
@since 04/02/2021
/*/
Static Function CalcAdiant(cContra, cRevisa, cNumMed, cNumPla, cItem, nTotItem)
    Local cAlias     := GetNextAlias()
    Local nAdiant    := 0
    
    Default cContra  := ""
    Default cRevisa  := ""
    Default cNumMed  := ""
    Default cNumPla  := ""
    Default cItem    := ""
    Default nTotItem := 0

    BeginSQL Alias cAlias //-- Consulta valor total da medição por planilha e valor do adiantamento
        SELECT ISNULL(CXN.CXN_VLTOT, CND.CND_VLTOT) AS VLTOT, //-- Caso for medição do CNTA120 considera a CND
               ISNULL(CXN.CXN_VLRADI, CND.CND_TOTADT) AS VLADT
        FROM %Table:CNE% CNE
        LEFT JOIN %Table:CXN% CXN ON
            CXN.CXN_FILIAL = %xFilial:CXN%  AND
            CXN.CXN_CONTRA = CNE.CNE_CONTRA AND
            CXN.CXN_REVISA = CNE.CNE_REVISA AND
            CXN.CXN_NUMPLA = CNE.CNE_NUMERO AND
            CXN.CXN_NUMMED = CNE.CNE_NUMMED AND
            CXN.%NotDel%
        INNER JOIN %Table:CND% CND ON
            CND.CND_FILIAL = %xFilial:CND% AND
            CND.CND_CONTRA = CNE_CONTRA    AND
            CND.CND_REVISA = CNE_REVISA    AND
            CND.CND_NUMMED = CNE_NUMMED    AND
            CND.%NotDel%
        WHERE 
            CNE.CNE_FILIAL = %xFilial:CNE% AND
            CNE.CNE_CONTRA = %Exp:cContra% AND
            CNE.CNE_REVISA = %Exp:cRevisa% AND
            CNE.CNE_NUMERO = %Exp:cNumPla% AND
            CNE.CNE_NUMMED = %Exp:cNumMed% AND
            CNE.CNE_ITEM   = %Exp:cItem%   AND
            CNE.%NotDel%
    EndSQL
    
    If !(cAlias)->(Eof()) //-- Valor do adiantamento proporcional ao valor do item
        nAdiant := (nTotItem / (cAlias)->VLTOT) * (cAlias)->VLADT
    EndIf

    (cAlias)->(dbCloseArea())
Return nAdiant

/*/{Protheus.doc} GCTGetObrg
	Obtem a obrigatoriedade dos campos de <oModel>
@author philipe.pompeu
@since 30/09/2021
@param oModel, instância de FWFormGridModel,Número da planilha
@return aRet, vetor, contêm lista de campos e sua obrigatoriedade
/*/
Function GCTGetObrg(oModel)
	Local aRet	:= {}
	Local nX	:=	0
	Local oStructMdl:= Nil

	oStructMdl	:= oModel:Getstruct()	

	For nX := 1 To len(oStructMdl:aFields)
		aAdd( aRet , { oStructMdl:aFields[nX][MODEL_FIELD_IDFIELD] , oStructMdl:aFields[nX][MODEL_FIELD_OBRIGAT] } )		
	Next nX
Return aRet

/*/{Protheus.doc} GCTRstObrg
	Restaura a obrigatoriedade dos campo em <aObrigat> no modelo <oModel>
@author philipe.pompeu
@since 30/09/2021
@param oModel, instância de FWFormGridModel,Número da planilha
@param aObrigat, vetor, contêm lista de campos e sua obrigatoriedade
/*/
Function GCTRstObrg( oModel , aObrigat)
	Local nX :=	0
	Local oStructMdl := Nil

	oStructMdl:= oModel:GetStruct()

	For nX := 1 To len(aObrigat)
		oStructMdl:SetProperty( aObrigat[nX][1] , MODEL_FIELD_OBRIGAT , aObrigat[nX][2] )
	Next nX
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} CnAlcFlg(cNumDoc,cNumRev,cTipo)
Função para aglutinação de SCRs por aprovador/grupo e gera alçada nos Fluig

Parametros:
cNumDoc	Número do documento.
cNumRev	Número da revisão.
aTipo		Array dos tipos de documento 'CT','IC','RV','IR','MD','IM' pesquisados

@return	lRet
@author 	Israel Escorizza
@since 		09/03/2016

@version 	1.0
/*/
//-------------------------------------------------------------------
Function CnAlcFlg(cNumDoc,cNumRev,cTipo)
Local lRet			:= .T.
Local aArea		:= GetArea()
Local aRows		:= FWSaveRows()

Local aReg			:= {}
Local aAprov		:= CnListaScr(cNumDoc,cNumRev,{cTipo},,)
Local nLenApr		:= Len(aAprov)

Local cGrpAtu		:= Iif( nLenApr > 0 , aAprov[1][3] , "")
Local cAprAtu		:= Iif( nLenApr > 0 , aAprov[1][4] , "")
Local cDocApr		:= ""

Local nX			:= 1

Default cNumDoc	:= ""
Default cNumRev	:= ""
Default cTipo		:= ""

While lRet .And. nX <= nLenApr
	If cGrpAtu != aAprov[nX][3] .Or. cAprAtu != aAprov[nX][4]
		//- Função que inicia processo do fluig e atualiza CR_FLUIG
		lRet := CnGerAlcFl(cTipo,AllTrim(cNumDoc+cNumRev),aReg,cDocApr)

		//- Atualiza Campos para continuidade do processo
		cGrpAtu := aAprov[nX][3]
		cAprAtu := aAprov[nX][4]
		cDocApr := ""
		aReg	 := {}
	EndIf

	aAdd(aReg,aAprov[nX][1])
	cDocApr+= aAprov[nX][2]
	If nX < nLenApr
		cDocApr+=", "
	EndIf

	nX++
EndDo

//- Função que inicia processo do fluig e atualiza CR_FLUIG
If lRet
	lRet := CnGerAlcFl(cTipo,AllTrim(cNumDoc+cNumRev),aReg,cDocApr) //-Chamada da função
EndIf

FWRestRows(aRows)
RestArea(aArea)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} CnGerAlcFl()
Função que efetiva a alçada no fluig, atualizando o campo CR_FLUIG das
SCRs aglutinadas

Parametros:

@return	lRet
@author 	Israel Escorizza
@since 		09/03/2016

@version 	1.0
/*/
//-------------------------------------------------------------------
Function CnGerAlcFl(cTipo,cNumDoc,aReg,cAglut)
Local aArea		:= GetArea()
Local aRows		:= FWSaveRows()
Local aNextTask	:= {}

Local lFluig		:= !Empty(AllTrim(GetNewPar("MV_ECMURL",""))) .And. FWWFFluig()
Local lRet 		:= .T.

Local cUser		:= ""
Local cProcess	:= ""
Local cCodUser	:= ""
Local cCodAprov	:= ""
Local cFilSav		:= ""

Local nX			:= 1

If lFluig .And. !Empty(aReg)
	SetScrAglu(cAglut) //- Define variavel estatica

	dbSelectArea('SCR')
	SCR->(dbGoTo(aReg[1]))

	cUser	:= MtUsrSolic(SCR->CR_TIPO,SCR->CR_NUM)
	cCodUser	:= FWWFColleagueId(cUser)
	cCodAprov	:= FWWFColleagueId(A097UsuApr(SCR->CR_APROV))

	If cTipo $ 'CT|IC|RV|IR'
		cFilSav	:= cFilAnt
		cFilAnt	:= CnFilCtr(SCR->CR_NUM)
	EndIf

	aNextTask 	:= {2,cCodUser,{cCodAprov}}
	StartProcess(cTipo,cCodUser,{cCodUser},,,,,aNextTask,.T.)
	cProcess	:= SCR->CR_FLUIG

	For nX := 2 To Len(aReg)
		SCR->(dbGoTo(aReg[nX]))
		Reclock("SCR",.F.)
		SCR->CR_FLUIG := cProcess
		MsUnlock()
	Next nX
Else
	lRet := .F.
EndIf

If !Empty(cFilSav)
	cFilAnt := cFilSav
EndIf
FWRestRows(aRows)
RestArea(aArea)
Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} CnVerAgFlg(cScrNum)
Função que verifica se Documento possui vinculo com aglutinação do fluig
@return	aRet
				[1] lRet	 	- Logico que define se existe aglutinação (.T./.F.)
				[2] cCrFluig 	- Valor do grupo de aprovação, quando este existir

@author 	Israel Escorizza
@since 		10/03/2016
@version 	1.0
/*/
//-------------------------------------------------------------------
Function CnVerAgFlg(cScrTip,cScrNum,cScrFlg)
Local aRet			:= {}
Local aArea		:= GetArea()
Local aRows		:= FWSaveRows()
Local cWhere		:= ""
Local lRet 		:= .F.
Local nNumLen		:= 0

Default cScrTip	:= SCR->CR_TIPO
Default cScrNum 	:= SCR->CR_NUM
Default cScfFlg	:= SCR->CR_FLUIG

DO 	CASE
	CASE cScrTip $ "CT|IC"
		 nNumLen	:= TAMSX3('CN9_NUMERO')[1]
	CASE cScrTip $ "RV|IR"
		 nNumLen	:= TAMSX3('CN9_NUMERO')[1]+TAMSX3('CN9_REVISA')[1]
	CASE cScrTip $ "MD|IM"
		 nNumLen	:= TAMSX3('CND_NUMMED')[1]
ENDCASE

cScrNum := LEFT(cScrNum,nNumLen)
If !Empty(cScrFlg)
	cWhere  := "CR_FLUIG = '"+cScrFlg+"'"

	If Len(CnListaScr(cScrNum,Nil,{cScrTip},cWhere,Nil)) > 1
		lRet := .T.
	EndIf
EndIf

aRet := {lRet,cScrFlg}

FWRestRows(aRows)
RestArea(aArea)
Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} CnClrAgFlg(cFlgApr)
Função para remover vinculo de aglutinação dos SCRs e remover aprovação
no Fluig.

@return	lRet
@author 	Israel Escorizza
@since 		10/03/2016
@version 	1.0
/*/
//-------------------------------------------------------------------
Function CnClrAgFlg(cFlgApr)
Local lRet 		:= .T.
Local aArea		:= GetArea()
Local aRows		:= FWSaveRows()
Local aList		:={}

Local cWhere		:= ""
Local nX			:= 1

Default cFlgApr	:=	""

If !Empty(cFlgApr)
	cWhere  := "CR_FLUIG = '"+cFlgApr+"'"
	aList := CnListaScr(,,,cWhere,)

	dbSelectArea('SCR')

	If !Empty(aList)
		For nX := 1 to Len(aList)
			SCR->(dbGoTo(aList[nX][1]))
			RecLock('SCR',.F.)
			SCR->CR_FLUIG := ""
			MsUnlock()
		Next nX
	EndIf

	//- Cancela aprovação no Fluig
	CancelProcess(Val(cFlgApr),FWWFUserID(Val(cFlgApr))," cancelado por aprovação Protheus.",.F.)
EndIf

FWRestRows(aRows)
RestArea(aArea)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} CNFlgVldSt(oModel)
Valida situação de processos do Fluig do modulo GCT e carrega o oModelCT

@since 24/11/2015
@version P12
@return lRet
/*/
//-------------------------------------------------------------------
Function CNFlgVldSt(oModel,oModelCT)

	Local cNum		:= PADR(oModel:GetValue('SCRMASTER','CR_NUM'),TAMSX3('CR_NUM')[1],' ')
	Local cUser		:= AllTrim(oModel:GetValue('SCRMASTER','CR_USER'))
	Local cTipo		:= oModel:GetValue('SCRMASTER','CR_TIPO')
	Local cFluig	:= Alltrim(cValToChar(oModel:GetWKNumProces()))
	Local cRev		:= ""
	Local cNumero	:= ""
	Local cSCRFil	:= ""
	Local lAchou	:= .F.


	If cTipo $ "CT|IC|RV|IR"
		cNumero := Substr(oModel:GetValue('SCRMASTER','CR_NUM'),1,TamSX3("CN9_NUMERO")[1])
		If cTipo $ "RV|IR"
			cRev := Substr(oModel:GetValue('SCRMASTER','CR_NUM'),Len(cNumero)+1,TamSX3("CN9_REVISA")[1])
		Endif
		cSCRFil := CnFilCtr(cNumero)
	Elseif cTipo $ "MD|IM"
		cNumero := Substr(oModel:GetValue('SCRMASTER','CR_NUM'),1,TamSX3("CND_NUMMED")[1])
		DbSelectArea("CND")
		CND->(DbSetOrder(4))
		CND->(MsSeek(xFilial("CND")+cNumero))
		cNumero := CND->CND_CONTRA
		cRev	 := CND->CND_REVISA
		cSCRFil := xFilial('SCR')
	Endif

	//Posiciona a alçada
	DbSelectArea("SCR")
	SCR->(DbSetOrder(2))
	If SCR->(DbSeek(cSCRFil+cTipo+cNum+cUser))
		While !Eof() .And. cSCRFil+cTipo+cNum+cUser == SCR->(CR_FILIAL+CR_TIPO+CR_NUM+CR_USER)
			If Alltrim(SCR->CR_FLUIG) == cFluig
				lAchou := .T.
				Exit
			Endif
			SCR->(dbSkip())
		EndDo
	Endif

Return lAchou

/*/{Protheus.doc} GeraAlcPlan
	Verifica se deve gerar alçada para planilha corrente em <oModelCNA>
@author philipe.pompeu
@since 08/12/2021
@param oModelCNA, objeto, instância de FwFormGrid do submodelo CNADETAIL
@return lResult, lógico, se deve gerar alçada p/ planilha corrente
*/
Static Function GeraAlcPlan(oModelCNA as Object) as Logical
	Local aArea		:= GetArea()
	Local aAreaCNA	:= CNA->(GetArea())
	Local lResult	:= .T.
	Local cRevAnt	:= ""
	Local oModel	:= Nil
	Local cContra	:= ""
	Local cFilCtr	:= ""
	Local cChave	:= ""
	Local lAprovTudo:= .F.
	Local lPrevFinanc:= .F.
	Local nTotAnt 	:= 0
	Local nTotAtu 	:= 0

	If (lResult := (oModelCNA:GetValue("CNA_SALDO") > 0))
		lAprovTudo := SuperGetMV("MV_CNALCRV",.F., .T.) /*Se <MV_CNALCRV> verdadeiro, sempre deve cair na alçada.*/

		If !lAprovTudo//Caso <MV_CNALCRV> falso, só cai na alçada caso aconteça mudança de valor
			oModel := oModelCNA:GetModel()
			cContra:= oModel:GetValue("CN9MASTER", "CN9_NUMERO")
			cFilCtr:= oModel:GetValue("CN9MASTER", "CN9_FILCTR")
			cRevAnt:= CnRevAnt(.F., oModel:GetValue("CN9MASTER", "CN9_REVISA"))

			CNA->(DbSetOrder(1))//CNA_FILIAL+CNA_CONTRA+CNA_REVISA+CNA_NUMERO
			cChave := xFilial("CNA", cFilCtr) + cContra + cRevAnt + oModelCNA:GetValue("CNA_NUMERO")
			If CNA->(DbSeek(cChave))
				nTotAnt := CNA->CNA_VLTOT + CNA->CNA_FRETE + CNA->CNA_DESPES + CNA->CNA_SEGURO
				nTotAtu := oModelCNA:GetValue("CNA_VLTOT") + oModelCNA:GetValue("CNA_FRETE") + oModelCNA:GetValue("CNA_DESPES") + oModelCNA:GetValue("CNA_SEGURO")
				lResult := nTotAnt <> nTotAtu //Compara o valor da planilha com o valor da revisão anterior
			EndIf		
		EndIf
	Else
		lPrevFinanc:= Cn300RetSt("PREVFINANC",,oModelCNA:GetValue("CNA_NUMERO"),oModelCNA:GetValue("CNA_CONTRA"))
		lResult	   := !lPrevFinanc
	EndIf

	RestArea(aAreaCNA)
	RestArea(aArea)
	
	ASize(aArea, 0)
	aArea := Nil
	ASize(aAreaCNA, 0)
	aAreaCNA := Nil
Return lResult

/*/{Protheus.doc} GeraAlcCtr
	Verifica se deve gerar alçada para contrato com base nas planilhas em <oModelCNA>
@author philipe.pompeu
@since 16/12/2021
@param oModelCNA, objeto, instância de FwFormGrid do submodelo CNADETAIL
@return lResult, lógico, se deve gerar alçada p/ o contrato
*/
Static Function GeraAlcCtr(oModelCNA as Object) as Logical
	Local aSaveLines:= FWSaveRows()
	Local lResult	:= .F.	
	Local nX		:= 0

	For nX := 1 To oModelCNA:Length()
		oModelCNA:GoLine(nX)
		If !(oModelCNA:IsDeleted())
			If GeraAlcPlan(oModelCNA) /*Se deve gerar alçada p/ ao menos uma planilha...*/
				lResult := .T.
				Exit
			EndIf			
		EndIf
	next nX
	FWRestRows(aSaveLines)
	FwFreeArray(aSaveLines)
Return lResult

/*/{Protheus.doc} AjsCNBVal
	Ajusta os valores em <aColsCNB> para considerarem os parâmetros MV_CNRVDIF/MV_CNRVSAL
Essa função é equivalente a função <Cn300VlApr> mas para a CNB durante a geração de alçada por entidades
@author philipe.pompeu
@since 17/01/2022
@param aHeadCNB	, vetor, metadado da CNB utilizado p/ preenchimento da <aColsCNB>
@param aColsCNB	, vetor, dados da CNB da revisão atual
@param cContra	, caractere, numero do contrato
@return Nil, nulo
*/
Static Function AjsCNBVal(aHeadCNB, aColsCNB, cContra, aBkpCNB)
	Local aAreas	:= {CNB->(GetArea()), GetArea()}
	Local nIndQuant	:= 0
	Local nIndVlTot	:= 0
	Local nIndVlUnit:= 0
	Local nIndSldMed:= 0
	Local nRecIndex	:= 0
	Local nC		:= 1
	Local cExpSeek	:= ""
	Local cAprRvDif	:= SuperGetMV('MV_CNRVDIF',.F.,"")	//- Tipos de revisão aprovação por dif. valor total
	Local cAprRvSal	:= SuperGetMV('MV_CNRVSAL',.F.,"")	//- Tipos de revisão aprovação por valor do saldo
	Local lAprRvDif	:= .F.
	Local lAprRvSal	:= .F.
	Local nVlUnit	:= 0
	Local nTotAtu	:= 0
	Local cChave	:= ""
	Local cTipRev	:= ""
	Local cRevVig	:= ""
	Local lSemAlt	:= .F.
	Default aBkpCNB := {}

	cTipRev		:= Cn300RetSt("TIPREV", /*nModo*/, /*cPlan*/, cContra)
	lAprRvSal	:= (cTipRev $ cAprRvSal)
	lAprRvDif	:= (cTipRev $ cAprRvDif)

	If (lAprRvSal .Or. lAprRvDif)		
		cRevVig	:= CnGetRevVg(cContra)		

		CNB->(DbSetOrder(1))//CNB_FILIAL+CNB_CONTRA+CNB_REVISA+CNB_NUMERO+CNB_ITEM
		cExpSeek:= StrTran(CNB->(IndexKey(IndexOrd())), "CNB_REVISA", "'"+ cRevVig +"'")

		nRecIndex	:= Len(aHeadCNB)
		nIndQuant	:= aScan(aHeadCNB, {|x| Alltrim(x[2]) == 'CNB_QUANT'})
		nIndVlUnit	:= aScan(aHeadCNB, {|x| Alltrim(x[2]) == 'CNB_VLUNIT'})
		nIndVlTot	:= aScan(aHeadCNB, {|x| Alltrim(x[2]) == 'CNB_VLTOT'})
		nIndSldMed	:= aScan(aHeadCNB, {|x| Alltrim(x[2]) == 'CNB_SLDMED'})

		If Empty(aColsCNB)
			aColsCNB := AClone(aBkpCNB)
			lSemAlt	:= .T.
		EndIf

		for nC := 1 to Len(aColsCNB)
			If lAprRvSal //- Aprovação por saldo
				aColsCNB[nC,nIndQuant] := aColsCNB[nC,nIndSldMed]
			ElseIf lAprRvDif //- Aprovação por diferença de valor do contrato/planilha
				If lSemAlt
					aColsCNB[nC,nIndQuant] := 0 //Zera pois não houve alterações, porém o perfil de aprovação pode estar zerado e deve gerar alçada
				Else
					CNB->(DbGoto(aColsCNB[nC,nRecIndex]))
					nTotAtu	:= CNB->CNB_VLTOT
					cChave	:= CNB->(&(cExpSeek))
					If CNB->(DbSeek(cChave))
						nVlUnit	:= (nTotAtu - CNB->CNB_VLTOT)					
						aColsCNB[nC,nIndQuant] := 1
						aColsCNB[nC,nIndVlUnit]:= nVlUnit 
					EndIf
				EndIf
			EndIf			
		next nC
		
	ElseIf Empty(aColsCNB)
		aColsCNB := AClone(aBkpCNB)
	EndIf
	
	aEval(aAreas, {|x| RestArea(x) })
	FwFreeArray(aAreas)
Return Nil

/*/{Protheus.doc} MedDuplRat
	Valida as as linhas da CNZ
@author jose.souza2
@since 10/02/2022
@aHeadCNZ, array, array contendo os dados do cabeçalho da tabela CNZ
@param aRateios, array, arrendo contendo os dados referente aos rateios
@param nLin, numérico, número da linha utilizado para comparação de conteúdo da linha do rateio
@return lRet 
*/
Function MedDuplRat(aHeadCNZ,aRateios,nLin,lValidLin,lPedido)

	Local lRet			:= .T.
	Local lCompra		:= CN121RetSt( "COMPRA"		, 0, , M->CND_CONTRA, .F. )
	Local nI			:= 0
	Local cChave    	:= ""
	Local cChaveLin 	:= ""
	Local nPCC			:= aScan(aHeadCNZ,{|x| alltrim(x[2]) == "CNZ_CC"})
	Local nPConta   	:= aScan(aHeadCNZ,{|x| alltrim(x[2]) == "CNZ_CONTA"})
	Local nPItCon   	:= aScan(aHeadCNZ,{|x| alltrim(x[2]) == "CNZ_ITEMCT"})
	Local nPClvl   		:= aScan(aHeadCNZ,{|x| alltrim(x[2]) == "CNZ_CLVL"})
	Local aCPos     	:={nPCC, nPConta, nPItCon, nPClvl}
	Local aEntAd    	:= CTBEntArr()
	Local nPosCpo   	:= 0
	Local oBusca		:= Nil
	Local nLinDupl      := 0
	Local cSolution     := ""
	Local cCpoCNZ		:= ""
	Default lValidLin	:= .T.
	Default lPedido     := .F.

	If !lCompra .Or. !lPedido .OR. (lCompra .And. !(SUPERGETMV('MV_RATDUPL',.F.,.F.)))
		oBusca	:= THashMap():New()
		For nI := 1 to Len(aEntAd)
			cCpoCNZ := "CNZ_EC" + aEntAd[nI] + "DB"
			nPosCpo := aScan(aHeadCNZ,{|x| alltrim(x[2]) == cCpoCNZ})
			If nPosCpo >0
				aAdd(aCpos,nPosCpo)
			Endif
				
			cCpoCNZ := "CNZ_EC" + aEntAd[nI] + "CR"
			nPosCpo := aScan(aHeadCNZ,{|x| alltrim(x[2]) == cCpoCNZ})
			If nPosCpo >0
				aAdd(aCpos,nPosCpo)
			Endif
		
		Next
		If lValidLin
			aEval(aCPos, {|x| cChaveLin += IIF(x > 0, Alltrim(aRateios[nLin,x]), "")})
			oBusca:Set(cChaveLin,nLin)
		Else
			nLin := -1 //Nesse caso todas as linhas serão processadas
		EndIf

		For nI := 1 to len(aRateios)
			If nI <> nLin .And. !aRateios[nI,len(aHeadCNZ)+1]
				cChave := ""
				aEval(aCPos, {|x| cChave += IIF(x > 0, Alltrim(aRateios[nI,x]), "")})

				If oBusca:Get(cChave, @nLinDupl)
					lRet		:= .F.
					nLinDupl	:= Min(nI,nLinDupl)
					cSolution	:= IIF(lCompra,STR0108,STR0109)
					Help(,,"MedDuplRat",,STR0107+ Str(nLinDupl), 1, 0,,,,,, {cSolution})
					Exit
				ElseIf !lValidLin
					oBusca:Set(cChave,nI)
				Endif
			Endif
		Next nI
		oBusca:Clean()
		FreeObj(oBusca)
	EndIf
	
Return lRet

/*/{Protheus.doc} GeraDocMD
	Verifica se deve gerar alçada do tipo MD para alguma das planilhas em <oModelCXN>
@author philipe.pompeu
@since 16/03/2022
@param oModelCXN, objeto, instância de FwFormGrid do submodelo CXNDETAIL
@return lGeraDoc, lógico, se deve gerar alçada tradicional p/ medição em questão
*/
Static Function GeraDocMD(oModelCXN as Object) as Logical
	Local lGeraDoc	:= .F.
	Local nX 		:= 0
	Local aSaveLines:= FWSaveRows()

	For nX := 1 To oModelCXN:Length()
		oModelCXN:GoLine(nX)
		lGeraDoc := lGeraDoc .Or.(oModelCXN:GetValue('CXN_CHECK') .And.;
		Cn300RetSt("ALCMDDOC",0,oModelCXN:GetValue("CXN_NUMPLA"),oModelCXN:GetValue("CXN_CONTRA"),oModelCND:GetValue('CND_FILCTR')))
	Next nX
	
	FWRestRows(aSaveLines)
	FwFreeArray(aSaveLines)
Return lGeraDoc

/*/{Protheus.doc} BloqCNDSit
	Bloqueia a medição atualizando seus campos de situação e alçada
@author philipe.pompeu
@since 16/03/2022
@param oModelCND, objeto, instância de FwFormGrid do submodelo CNDMASTER
@return Nil, nulo
*/
Static Function BloqCNDSit(oModelCND as Object)
	
	If ValType(oModelCND) == "O"
		oModelCND:LoadValue("CND_ALCAPR", "B")
		oModelCND:LoadValue("CND_SITUAC", "B")
	Else //CNTA120
		RecLock("CND",.F.)
		CND->CND_ALCAPR := "B"
		CND->CND_SITUAC := "B"
		CND->(MsUnlock())
	EndIf
Return Nil

/*/{Protheus.doc} EntCtbTpIM
	Gera alçada p/ entidade contábil para documentos do tipo IM(Item Medição).
@author philipe.pompeu
@since 16/03/2022
@param oModel, objeto, instância de MPFormModel do CNTA121
@return lGerouAlc, lógico, verdadeiro se gerou algum documento p/ aprovação
*/
Static Function EntCtbTpIM(oModel as Object, cNumDoc as Char) as Logical
	Local lGerouAlc	:= .F.
	Local nX	:= 0
	Local nY	:= 0
	Local nZ	:= 0
	Local oModelCND	:= Nil
	Local oModelCXN	:= Nil
	Local oModelCNZ	:= Nil
	Local oModelCNE	:= Nil
	Local aHeadRat	:= {}
	Local aColsRat	:= {}
	Local aHeadItem	:= {}
	Local aColsItem	:= {}
	Local nCNZItInd := 0
	Local nCNEPlInd	:= 0
	Local nCNZPlInd	:= 0
	Local aRateio	:= {}
	Local aSaveLines:= FWSaveRows()
	Local nNovaLinha := 0
	Local aTaxMoed := {}
	Private nMoedaPed := NIL
	Private nTxMoeda := NIL
	Default oModel	:= FwModelActive()
	Default cNumDoc	:= ""

	oModelCND	:= oModel:GetModel("CNDMASTER")
	oModelCXN	:= oModel:GetModel("CXNDETAIL")
	oModelCNE	:= oModel:GetModel("CNEDETAIL")
	oModelCNZ	:= oModel:GetModel("CNZDETAIL")

	aHeadItem	:= GCTGetHead("CNE")
	aHeadRat 	:= GCTGetHead("CNZ")
	nCNZItInd	:= aScan(aHeadRat, {|x| AllTriM(x[2]) == "CNZ_ITCONT"})
	nCNEPlInd	:= aScan(aHeadItem, {|x| AllTriM(x[2]) == "CNE_NUMERO"})
	nCNZPlInd	:= aScan(aHeadRat, {|x| AllTriM(x[2]) == "CNZ_CODPLA"})

	aTaxMoed  := TaxMoed(oModel)
	nMoedaPed := aTaxMoed[1]//Tipo da moeda
	nTxMoeda  := aTaxMoed[2]//Taxa da moeda de acordo com o dia
	
	For nX := 1 To  oModelCXN:Length()		
		aColsRat	:= {}
		aColsItem	:= {}
		oModelCXN:GoLine(nX)

		If oModelCXN:GetValue('CXN_CHECK') .And.;
			Cn300RetSt("ALCMDEC",0,oModelCXN:GetValue("CXN_NUMPLA"),oModelCXN:GetValue("CXN_CONTRA"),oModelCND:GetValue('CND_FILCTR'))

			For nY := 1 to oModelCNE:Length()
				oModelCNE:GoLine(nY)
				If !oModelCNE:IsDeleted()

					aAdd(aColsItem, GetColMdl(oModelCNE, aHeadItem))
					nNovaLinha := Len(aColsItem)

					If nCNEPlInd > 0 .And. Empty(aColsItem[nNovaLinha][nCNEPlInd])
						aColsItem[nNovaLinha][nCNEPlInd] := oModelCXN:GetValue("CXN_NUMPLA")
					EndIF
					
					For nZ := 1 to oModelCNZ:Length()
						oModelCNZ:GoLine(nZ)
						If !oModelCNZ:IsDeleted() .And. oModelCNZ:GetValue("CNZ_PERC") > 0
							aRateio := 	GetColMdl(oModelCNZ, aHeadRat)
							If nCNZItInd > 0 .And. Empty(aRateio[nCNZItInd])
								aRateio[nCNZItInd] := oModelCNE:GetValue("CNE_ITEM") //CNZ_ITCONT é utilizado p/ saber de qual item se trata o rateio
							EndIf
							If	nCNZPlInd > 0 .And. Empty(aRateio[nCNZPlInd])
								aRateio[nCNZPlInd] := oModelCXN:GetValue("CXN_NUMPLA")
							EndIf
							aAdd(aColsRat, aClone(aRateio))
						EndIf
					Next nZ
					
				EndIf
			Next nY			
			
			cNumDoc := Left(cNumDoc,TamSX3('CND_NUMMED')[1])
			If MaEntCtb("CNE","CNZ",cNumDoc,"IM",aHeadItem,aColsItem,aHeadRat,aColsRat,1,dDataBase)
				lGerouAlc := .T.
			EndIf			
		EndIf
	Next nX
	
	FwFreeArray(aHeadItem)
	FwFreeArray(aHeadRat)

	FwFreeArray(aColsItem)
	FwFreeArray(aColsRat)

	FWRestRows(aSaveLines)
	FwFreeArray(aSaveLines)
	Asize(aTaxMoed,0)//zeragem do array
	aTaxMoed := nil

Return lGerouAlc

/*/{Protheus.doc} GCTGetHead
	Cria um aHeader de <cTabela>
@author philipe.pompeu
@since 16/03/2022
@param cTabela, caractere, alias da tabela na SX3
@return aHeadTab, vetor, estrutura de <cTabela> no formato tradicional de aHeader
*/
Static Function GCTGetHead(cTabela as Char) as Array
	Local aHeadTab	:= {}
	
	aHeadTab := GdMontaHeader( 	NIL			,;	//01 -> Por Referencia contera o numero de campos em Uso
								NIL			,;	//02 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Virtuais
								NIL			,;	//03 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Visuais
								cTabela		,;	//04 -> Opcional, Alias do Arquivo Para Montagem do aHeader
								{}			,;	//05 -> Opcional, Campos que nao Deverao constar no aHeader
								NIL			,;	//06 -> Opcional, Carregar Todos os Campos
								.T.			,;	//07 -> Nao Carrega os Campos Virtuais
								NIL			,;	//08 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
								NIL			,;	//09 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
								.T.			,;	//10 -> Verifica se Deve Checar se o campo eh usado
								.T. 		,;	//11 -> Verifica se Deve Checar o nivel do usuario
								NIL			,;	//12 -> Utiliza Numeracao na GhostCol
								.F.			 )	//13 -> Carrega os Campos de Usuario
Return aHeadTab

/*/{Protheus.doc} GetColMdl
	Retorna uma linha no formato tradicional das aCols com base no aHeader informado em <aHeadMdl>, obtendo os dados à partir de <oSubModel>
@author philipe.pompeu
@since 16/03/2022
@param oSubModel, objeto, instância de FwFormGrid/FwFormModel
@param aHeadMdl, vetor, estrutura da tabela no formato aHeader tradicional
@return aLinha, vetor, uma linha à ser adicionado ao aCols
*/
Static Function GetColMdl(oSubModel as Object, aHeadMdl as Array) as Array
	Local aLinha	:= {}
	Local nTamHead	:= Len(aHeadMdl)
	Local cCampo	:= ""
	Local nX		:= 0

	aLinha := Array(nTamHead+1)
	aTail(aLinha) := .F.

	for nX := 1 to nTamHead
		cCampo := aHeadMdl[nX,2]
		If oSubModel:HasField(cCampo)
			aLinha[nX] := oSubModel:GetValue(cCampo)
		EndIf
	next nX

Return aLinha

/*/{Protheus.doc} IsFalseBlc
	Verifica se <bBlock> é um bloco cujo retorno é exclusivamente um retorno booleando falso(.F.)
@author philipe.pompeu
@since 15/06/2022
@param bBlock, code-block, bloco a ser verificado
@return lResult, lógico, se o bloco é falso
*/
Static Function IsFalseBlc(bBlock)
	Local lResult := .F.
	Local cBlock := ""
	If ValType(bBlock) == "B"
		cBlock	:= AllTrim(GetCbSource(bBlock))
		lResult	:= ((cBlock == "{|| .F. }") .Or. (cBlock == "{||.F.}"))		
	EndIf
Return lResult

/*/{Protheus.doc} IsTrueBlc
	Verifica se <bBlock> é um bloco cujo retorno é exclusivamente um retorno booleando verdadeiro(.T.)
@author philipe.pompeu
@since 15/06/2022
@param bBlock, code-block, bloco a ser verificado
@return lResult, lógico, se o bloco é verdadeiro
*/
Static Function IsTrueBlc(bBlock)
	Local lResult := .F.
	Local cBlock := ""
	If ValType(bBlock) == "B"		
		cBlock	:= AllTrim(GetCbSource(bBlock))
		lResult	:= ((cBlock == "{|| .T. }") .Or. (cBlock == "{||.T.}"))
	EndIf
Return lResult

/*/{Protheus.doc} GCTAlcErro
	Verifica se possui erro no modelo de dados e retorna a mensagem de erro caso tenha
@author jose.souza2
@since 29/06/2022
@param oModelAlc, objeto, modelo da rotina a ser utilizado
@return lTemErro, lógico, se o possui ou não erro
*/

Function GCTAlcErro(oModelAlc)
    Local lTemErro := .F.
    
    If lTemErro := !Empty(_aErroAlc)
        If ValType(oModelAlc) == "O" .And. oModelAlc:IsActive()
            oModelAlc:SetErrorMessage(,,,,_aErroAlc[5],_aErroAlc[6],_aErroAlc[7])
        EndIf

        aSize(_aErroAlc,0)//Limpa variável estática
    Endif

Return lTemErro

/*/{Protheus.doc} GCTVCondPg
	Valida os campos Condição de Pagamento(CN9_CONDPG/CNA_CONDPG/CND_CONDPG) do módulo GCT
@author philipe.pompeu
@since 23/11/2023
@param cCondPg, caractere, código da condição de pagamento
@return lValido, lógico, se é um código válido
*/
Function GCTVCondPg(cCondPg)
	Local aAreas	:= {SE4->(GetArea()), GetArea()}
	Local lValido	:= .F.

	If Empty(cCondPg)
		lValido := .T.
	Else		
		SE4->(DbSetOrder(1))	
		If (lValido := SE4->(DbSeek(xFilial("SE4") + cCondPg)))		
			lValido := (AllTrim(SE4->E4_TIPO) != "A")
			If !lValido
				Help(" ",1,"GCTVCONDPG",,STR0110, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0111})//Condição de pagamento não permitida no SIGAGCT.		
			EndIf
		Else
			Help(" ",1,"REGNOIS")
		EndIf
	EndIf

	aEval(aAreas, {|x| RestArea(x) })
	FwFreeArray(aAreas)
Return lValido

/*/{Protheus.doc} CNVlTxMoed
	Valida a existência de taxa cambial de <nMoeda> na data <dCambio>
@author philipe.pompeu
@since 27/02/2024
@param nMoeda, numérico, código da moeda
@param dCambio, data, data do câmbio
@return lResult, lógico, se há taxa de câmbio na data informada
*/
Function CNVlTxMoed(nMoeda, dCambio)
	Local lResult 	:= .T.
	Local cNomeMoeda:= ""
	Local cSolucao 	:= ""

	if (nMoeda > 1) //Só valida câmbio p/ moedas estrangeiras
		if !(lResult := RecMoeda(dCambio, nMoeda) > 0)

			cNomeMoeda	:= AllTrim(SuperGetMV("MV_MOEDA" + CValToChar(nMoeda) ))
			cSolucao 	:= I18N(STR0113,{ cNomeMoeda, DtoC(dCambio) }) //Informe uma taxa de câmbio para moeda #1 na data #2.
			Help(" ",1,"GCTCAMBIO",,STR0112, 1, 0, NIL, NIL, NIL, NIL, NIL, {cSolucao})//Taxa de câmbio não informada.
		endif
	endif
Return lResult

/*/{Protheus.doc} GCTSendMsg
	Função para enviar e-mail/msg através do EventInsert
@author alexandre.takaki
@since 27/03/2024
@param cEventId, caractere, Id do Evento
@param cText, caractere, texto que será enviado no e-mail
@param cTitle, caractere, título que será enviado no e-mail
@param aDados, array, dados enviados para a função MEnviaMail e agora sendo tratado no EventInsert
@return Nil, nulo
*/
Function GCTSendMsg(cEventId, cText, cTitle, aDados)

	Default cTitle 	:= ""
	Default aDados 	:= {}

	If (COMTemSXI(cEventId)) //Confere se existe evento cadastrado no Event Viewer (Tabela SXI)

		If ValType(aDados) == "A" .And. Len(aDados) > 0
			cText += GetMsgById(cEventId,aDados)
		EndIf

		EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventId, FW_EV_LEVEL_INFO, "", cTitle, cText, .T.)
		
	ElseIf GetRPORelease() < "12.1.2410" .And. FindFunction("MEnviaMail")

		If Empty(aDados)
			aDados := {cText}
		EndIf

		MEnviaMail(cEventId, aDados) //Emite alerta com log do processamento

	EndIf

Return(Nil)

/*/{Protheus.doc} GetMsgById
	Função que retorna a mensagem a ser enviada para o EventViewer conforme o padrão do m-messenger
@author alexandre.takaki
@since 01/04/2024
@param cEventId, caractere, Id do Evento
@param aDados, array, Array com os dados
@return cMensagem, caracteres
*/
Static Function GetMsgById(cEventId, aDados)

	Local cMensagem 	:= ""
	Local cPEAltMsg 	:= "MMENS" + Left(cEventId,3)
	Local cMsgPE 		:= ""

	Do Case
		Case cEventId == "038" //Vencimento do Contrato - (SIGAGCT)
			
     		cMensagem := STR0114 + CRLF//"Aviso de vencimento do contrato:"
     		cMensagem += STR0115 + I18N('#1 \ #2', {aDados[1] , aDados[2]} ) + CRLF//"Contrato\Revisao: "
			cMensagem += STR0116 + aDados[5]+ CRLF//"Filial : "
     		cMensagem += STR0117 + DTOC(aDados[3]) + CRLF//"Data de inicio: "
     		cMensagem += STR0118 + DTOC(aDados[4]) + CRLF//"Data de Termino: "

		Case cEventId == "039" //Termino do Contrato - (SIGAGCT)

     		cMensagem := STR0119 + CRLF//"Aviso de termino do contrato:"
     		cMensagem += STR0115 + I18N('#1 \ #2', {aDados[1] , aDados[2]} ) + CRLF//"Contrato\Revisao: "
			cMensagem += STR0116 + aDados[5]+ CRLF//"Filial : "
     		cMensagem += STR0117 + DTOC(aDados[3]) + CRLF//"Data de inicio: "
     		cMensagem += STR0118 + DTOC(aDados[4]) + CRLF//"Data de Termino: "

		Case cEventId == "040" //Limite de saldo das planilhas de contrato - (SIGAGCT)

			cMensagem := STR0123 + CRLF//"O saldo da planilha de contrato abaixo, atingiu o percentual minimo estabelecido. Informações: "
			cMensagem += STR0115 + I18N('#1 \ #2', {aDados[2] , aDados[3]} ) + CRLF//"Contrato\Revisao: "
			cMensagem += STR0116 + aDados[6]+ CRLF//"Filial : "
			cMensagem += STR0120 + aDados[1] + CRLF//"Planilha: "
			cMensagem += STR0121 + Transform(aDados[4],PesqPict("CNA","CNA_VLTOT")) + CRLF//"Valor Total: "
			cMensagem += STR0122 + Transform(aDados[5],PesqPict("CNA","CNA_SALDO")) + CRLF//"Saldo: "

		Case cEventId == "041" //"Apropriação Contábil"
			
			cMensagem := aDados[1] + CRLF	

		Case cEventId == "048" //Documento XXX nao apresentado, nao impediu a (liberacao / movimentacao) do titulo
			
			cMensagem := I18N(STR0126,{aDados[2], aDados[3], IIF(aDados[1]$'01|',STR0127,STR0128) }) //"Documento #1 - #2 n o apresentado, n o impediu a #3 do t tulo abaixo."
			cMensagem += CRLF + STR0116 + aDados[4] + CRLF	//"Filial: "
        	cMensagem += I18N(STR0129,{aDados[5]}) + CRLF	//"Prefixo: "
        	cMensagem += I18N(STR0130,{aDados[6]}) + CRLF	//"Numero: "
        	cMensagem += I18N(STR0131,{aDados[7]}) + CRLF	//"Parcela: "
   			cMensagem += I18N(STR0132,{aDados[8]}) + CRLF	//"Tipo: "
   			cMensagem += I18N(STR0133,{I18N('#1 / #2', {aDados[9] , aDados[10]})}) + CRLF //"Fornecedor: "

	EndCase	

	If ExistBlock(cPEAltMsg)
		cMsgPE 		:= ExecBlock(cPEAltMsg,.F.,.F.,{aDados,cMensagem})
		cMensagem	:= iif( ValType(cMsgPE)=="C",cMsgPE,cMensagem )
	EndIf

Return(cMensagem)

/*/{Protheus.doc} GetTrueWhen
	Retorna um WHEN sempre positivo no formato MVC
@author philipe.pompeu
@since 01/07/2024
@return _bTrueWhen, code-block, when sempre positivo no formato MVC
*/
Static Function GetTrueWhen()
	If _bTrueWhen == Nil
		_bTrueWhen := FwBuildFeature( STRUCT_FEATURE_WHEN, ".T.")
	EndIf
Return _bTrueWhen

/*/{Protheus.doc} CNNoWhenSet
	Atribui <xValue> ao campo <cField> do submodelo <oSubModel> ignorando a propriedade WHEN do campo em questão.
@author philipe.pompeu
@since 01/07/2024
@param oSubmodel, objeto, instância de FwFormGridModel ou FwFormFieldsModel
@param cField	, caractere, campo a ser atualizado
@param xValue	, indefinido, valor a ser atribuido
@return lResult, lógico, se atribuição ocorreu sem falhas
*/
Function CNNoWhenSet(oSubModel, cField, xValue)
	Local bWhen 	:= oSubModel:GetStruct():GetProperty(cField, MODEL_FIELD_WHEN)	
	Local lResult	:= .F.

	oSubModel:GetStruct():SetProperty(cField,MODEL_FIELD_WHEN, GetTrueWhen()) //Limpa o WHEN padrão do campo	
	
	lResult := oSubModel:SetValue(cField,xValue)
	
	oSubModel:GetStruct():SetProperty(cField,MODEL_FIELD_WHEN, bWhen) //Restaura campo original
Return lResult

/*/{Protheus.doc} MailsGrpAprv
	Retorna os usuários/emails associados aos grupos em <aGrupos>
@author claudio.miranda
@since 05/09/2024
@param aGrupos, array, lista de grupos que devem ser buscados.
@param aUsers, array, vetor onde os usuários serão incluidos
*/
Static Function MailsGrpAprv(aGrupos, aUsers)
	Local cUsuario := ""
	Local bBusca := {|x| AllTrim(x[1]) == AllTrim((cAliasSAL)->AL_USER) .Or. AllTrim(x[2]) == AllTrim(cUsuario) }
	Local oDBLAprov := Nil
	Local cAliasSAL	:= ""
	Default aUsers     := {}

	if Len(aGrupos) > 0
		cQuery   := "SELECT AL_USER "
		cQuery   += "FROM "+RetSqlName("SAL")+" SAL "
		cQuery   += "WHERE SAL.AL_FILIAL= ? AND "
		cQuery   += "SAL.AL_COD IN (?) AND "
		cQuery   += "SAL.D_E_L_E_T_= ? "
		cQuery   += "ORDER BY "+SqlOrder(SAL->(IndexKey()))
		cQuery   := ChangeQuery(cQuery)

		oDBLAprov := FWExecStatement():New(ChangeQuery( cQuery ))

		oDBLAprov:SetString(1, xFilial("SAL") )
		oDBLAprov:setIn(2, aGrupos)
		oDBLAprov:SetString(3, '')

		cAliasSAL := oDBLAprov:OpenAlias()		

		While (cAliasSAL)->(!Eof())
			cUsuario := UsrRetMail((cAliasSAL)->AL_USER)
			If (aScan(aUsers, bBusca )) == 0
				aAdd(aUsers,{ (cAliasSAL)->AL_USER, cUsuario })				
			EndIf		
			(cAliasSAL)->(dbSkip())
		EndDo

		(cAliasSAL)->(dbCloseArea())
		FreeObj(oDBLAprov)
	endif
Return

/*/{Protheus.doc} CNMsgGrpApr
	Função que foi migrada do MATXFUNC e que trata o envio de e-mail de notificação dos contratos do GCT
@author claudio.miranda
@since 05/09/2024
@param aDados, array, contem informações: Contrato, Revisão, Data de Inicio, Data Fim e Filial
@param aUsers, array, onde serão adicionados os usuários dos grupos de aprovação de alçada que devem receber os avisos
*/
Function CNMsgGrpApr(aDados, aUsers)
	Local nMsgGrpApr 	:= SuperGetMV("MV_CNGRMSG",.F.,0) // 0=usuários x eventos, 1=Grupo de Aprovação, 2=Todos, 3=Entidades Contábeis X Grp.Apr.
	Local cNumDoc 		:= aDados[1]+aDados[2]
	Local cFilCtr 		:= aDados[5]
	Local lAlcDocCtr	:= .F.
	Local lAlcEntCtb	:= .F.

	CN9->(dbSetOrder(1))
	If CN9->(MsSeek(cFilCtr+cNumDoc))
		lAlcDocCtr := (nMsgGrpApr == 1 .Or. nMsgGrpApr == 2 ) .And. Cn300RetSt( "ALCCTDOC"	, 0,, CN9->CN9_NUMERO, CN9->CN9_FILCTR, .F. )
		lAlcEntCtb := (nMsgGrpApr == 3 .Or. nMsgGrpApr == 2 ) .And. Cn300RetSt( "ALCCTEC"	, 0,, CN9->CN9_NUMERO, CN9->CN9_FILCTR, .F. )

		If (lAlcDocCtr)			
			MailsGrpAprv({GrpAprCrt(cNumDoc,cFilCtr)}, aUsers)
		EndIf

		If (lAlcEntCtb)
			MailsGrpAprv(GrpAprEntCtb(), aUsers)
		EndIf
	EndIf
Return

/*/{Protheus.doc} GrpAprEntCtb
	Retorna a lista de grupos de aprovação por entidade contábil do contrato posicionado
@author philipe.pompeu
@since 06/09/2024
@return aGrupos, vetor, lista de grupos de aprovação entidade contábil
*/
Static Function GrpAprEntCtb()	
	Local aGrupos := {}
	Local cQuery1		:= ""
	Local cQuery2		:= ""
	Local cTmpAlias		:= ""
	Local nX 			:= 0
	Local nY 			:= 0
	Local oDBLAprov	:= Nil
	Local oCheckDBL	:= Nil
	Local cFilDBL := xFilial("DBL")
	Local aParams 	:= {}
	Local aParVazio := {}
	Local nTamGrupo:= GetSx3Cache("DBL_GRUPO", "X3_TAMANHO")

	cQuery1 := "SELECT CNB_FILIAL AS FILIAL, CNB_CC AS CC, CNB_CONTA AS CONTA, CNB_ITEMCT AS ITEMC, CNB_CLVL AS CLVL FROM " + RetSqlName("CNB") + " CNB"
	cQuery1 += " WHERE CNB_FILIAL = ?"
	cQuery1 += " AND CNB_CONTRA = ?"
	cQuery1 += " AND CNB_REVISA = ?"
	cQuery1 += " AND CNB.D_E_L_E_T_ = ?"
	cQuery1 += " AND CNB_RATEIO = ?"
	cQuery1 += " UNION"
	cQuery1 += " SELECT CNZ_FILIAL AS FILIAL, CNZ_CC, CNZ_CONTA, CNZ_ITEMCT, CNZ_CLVL FROM " + RetSqlName("CNZ") + " CNZ"
	cQuery1 += " WHERE CNZ_FILIAL = ?"
	cQuery1 += " AND CNZ_CONTRA = ?"
	cQuery1 += " and CNZ_REVISA = ?"
	cQuery1 += " AND CNZ.D_E_L_E_T_ = ?"
	cQuery1 += " AND CNZ_NUMMED = ?"

	oDBLAprov := FWExecStatement():New(ChangeQuery( cQuery1 ))

	oDBLAprov:SetString(1, CN9->CN9_FILIAL)
	oDBLAprov:SetString(2, CN9->CN9_NUMERO)
	oDBLAprov:SetString(3, CN9->CN9_REVISA)
	oDBLAprov:SetString(4, Space(1))
	oDBLAprov:SetString(5, '2')
	oDBLAprov:SetString(6, CN9->CN9_FILIAL)
	oDBLAprov:SetString(7, CN9->CN9_NUMERO)
	oDBLAprov:SetString(8, CN9->CN9_REVISA)
	oDBLAprov:SetString(9, Space(1))
	oDBLAprov:SetString(10, Space(GetSx3Cache('CNZ_NUMMED', "X3_TAMANHO"))) //Garante que trará apenas os rateios do contrato, ignor
	cAliasTemp := oDBLAprov:OpenAlias()

	While (cAliasTemp)->(!Eof())

		if oCheckDBL == Nil //Só cria 1x

			aParams := (cAliasTemp)->({cFilDBL, Space(1), FieldPos('CC'),FieldPos('CONTA'),FieldPos('ITEMC'),FieldPos('CLVL')})
			aParVazio := {Space(GetSx3Cache('DBL_FILIAL', "X3_TAMANHO")),;
						  Space(1),;
						  Space(GetSx3Cache('DBL_CC', "X3_TAMANHO")),;
						  Space(GetSx3Cache('DBL_CONTA', "X3_TAMANHO")),;
						  Space(GetSx3Cache('DBL_ITEMCT', "X3_TAMANHO")),;
						  Space(GetSx3Cache('DBL_CLVL', "X3_TAMANHO"))}
			
			cQuery2 := "SELECT DBL_GRUPO FROM " + RetSqlName("DBL") + " DBL"
			cQuery2 += " WHERE DBL_FILIAL = ?"
			cQuery2 += " AND D_E_L_E_T_ = ?"			
			cQuery2 += " AND DBL_CC = ?"		
			cQuery2 += " AND DBL_CONTA = ?"		
			cQuery2 += " AND DBL_ITEMCT = ?"		
			cQuery2 += " AND DBL_CLVL = ?"		

			oCheckDBL := FWExecStatement():New(ChangeQuery( cQuery2 ))			
		endif		

		For nX := 6 to 3 step -1 //Começa com todos os parâmetros preenchidos e termina com apenas os três primeiros preenchidos.

			for nY := 1 to nX //Preenche os parâmetros com dados
				if nY > 2					
					oCheckDBL:SetString(nY, (cAliasTemp)->(FieldGet(aParams[nY])))
				else
					oCheckDBL:SetString(nY, aParams[nY])
				endif				
			next nY

			for nY := nX+1 to 6 //Preenche os parâmetros que devem estar vazios
				oCheckDBL:SetString(nY, aParVazio[nY])
			next			

			cTmpAlias := oCheckDBL:OpenAlias()			

			if (cTmpAlias)->(!Eof())
				aAdd(aGrupos,PadR((cTmpAlias)->(DBL_GRUPO), nTamGrupo))
				Exit //Achou um registro, pode sair do loop
			endif
			(cTmpAlias)->(dbClosearea())			
		Next nX
		(cAliasTemp)->(DbSkip())
	EndDo
	(cAliasTemp)->(dbClosearea())	

	FreeObj(oDBLAprov)
	FreeObj(oCheckDBL)

	FwFreeArray(aParams)
	FwFreeArray(aParVazio)
Return aGrupos

//-------------------------------------------------------------------
/*/{Protheus.doc} GCTGATCC
	Gatilho do centro de custo do produto ou da solicitação de compras para o contrato 
@author claudio.miranda
@since 21/10/2024
@return cRet, caracter, Retono código do centro de custo
/*///----------------------------------------------------------------
Function GCTGATCC()
	Local cRet 		 := ''
	Local lSeekSB1 	 := .T.
	Local aArea		 := GetArea()
	Local aSaveLines := FwSaveRows()
	Local lIsCotCall := (FWIsInCallStack("ExecCtrMdl") .Or. FWIsInCallStack("MATA161") .Or. ; //MATA161/MATA162
                        FWIsInCallStack("ExecModCtr"))      //PGCXANL
	If lIsCotCall
		SC1->(DbSetOrder(1))  // C1_FILIAL+C1_NUM+C1_ITEM+C1_ITEMGRD
		If SC1->(MsSeek(XFilial('SC1')+SC8->C8_NUMSC+SC8->C8_ITEMSC))
			cRet := SC1->C1_CC
			lSeekSB1 := .F.
		Endif
	Endif

	If lSeekSB1
		SB1->(DbSetOrder(1))  // B1_FILIAL+B1_COD
		If SB1->(MsSeek(xFilial('SB1')+FwFldGet('CNB_PRODUT')))
			cRet := SB1->B1_CC
		Endif
	Endif

	FWRestRows(aSaveLines)
	RestArea(aArea)
	FwFreeArray(aArea)
	FwFreeArray(aSaveLines)

Return(cRet) 

/*/{Protheus.doc} GctUtils
	Classe com métodos auxiliares genéricos do Gestão de Contratos.
@author philipe.pompeu
@since 06/02/2025
*/
Class GctUtils from LongNameClass
    Static Method DateToCompetency(dDate as Date) as Char
EndClass

/*/{Protheus.doc} DateToCompetency
	Retorna <dDate> no formato MM/YYYY
@author philipe.pompeu
@since 06/02/2025
@param dDate, date, data a ser convertida
@return cCompetency, char, competência MM/YYYY
*/
Method DateToCompetency(dDate as Date) as Char class GctUtils 
	Local cCompetency as Char
	Local cMonth as Char
	Local cYear as Char
	
	cMonth	:= StrZero(Month(dDate)	,2)
	cYear 	:= StrZero(Year(dDate)	,4)	

	cCompetency := I18N("#1/#2", {cMonth , cYear})
Return cCompetency

//----------------------------------------------------------------------
/*/{Protheus.doc} TaxMoed
	Função para manipulação dos dados da moeda e taxa da moeda no dia
@author Henrique.Testi
@since 22/05/2025
@return nMoedaPed, nTxMoeda
/*///-------------------------------------------------------------------
Static Function TaxMoed(oModel as Object)

	Local oModelCND9 as Object
	Local nMoedaPed as Numeric
	Local nTxMoeda  as Numeric

	If oModel:GetModel("CN9MASTER") != Nil
		oModelCND9 := oModel:GetModel("CN9MASTER")
		nMoedaPed := oModelCND9:GetValue("CN9_MOEDA")

	ElseIf oModel:GetModel("CNDMASTER") != Nil

		oModelCND9 := oModel:GetModel("CNDMASTER")	
		nMoedaPed := oModelCND9:GetValue("CND_MOEDA")
	EndIf

	If oModelCND9 != Nil
		nTxMoeda  := RecMoeda(dDatabase, nMoedaPed)	
	EndIf

Return { nMoedaPed, nTxMoeda }

/*/{Protheus.doc} HasCpoFrete
	Preenche a variavel Static _lVldFrete

@return _lVldFrete, logico, Retonar .T. caso encontre o função CtrCpoFret e os campos relacionados ao frete
@author ivan.magno
@since 17/09/2025
/*/
Static Function HasCpoFrete()

	If _lVldFrete == Nil
		_lVldFrete := GetRPORelease() >= "12.1.2510" .Or. (FindFunction("CtrCpoFret") .And. CtrCpoFret())
	Endif

Return _lVldFrete

/*/{Protheus.doc} GCTSomaEnc
	@description Soma valor de Frete + Despesa + Seguro de todas as planilhas
	@author henrique.testi, guilherme.sordi
	@since 15/10/2025
	@param cContra , character, número do contrato
	@param cRevisa , character, número da revisão
	@param cTable , character, alias da tabela onde será feita a soma (CNA ou CNB)
	@param oModelCNA , object, model da CNA
	return nTotal , numérico
*/
Function GCTSomaEnc(cContra as character, cRevisa as character, cTable as character, oModelCNA as object) as numeric
	Local aArea := {}      
	Local cKey := ""
	Local nLenCNA := 0
	Local nTotal := 0
	Local nX := 0

	Default cContra := ""
	Default cRevisa := ""
	Default cTable := "CNA"

	If HasCpoFrete()
		If oModelCNA <> Nil
			nLenCNA := oModelCNA:Length()
			For nX := 1 To nLenCNA
				oModelCNA:GoLine(nX)
				If !oModelCNA:IsDeleted()
					nTotal += oModelCNA:GetValue("CNA_FRETE") + oModelCNA:GetValue("CNA_DESPES") + oModelCNA:GetValue("CNA_SEGURO")
				EndIf
			Next nX
		Else
			aArea := { CNA->(FwGetArea()), CNB->(FwGetArea()), FwGetArea() }
				cKey := FwXFilial( "CNA" ) + cContra + cRevisa

			If "CNA" $ cTable 
				CNA->( DbSetOrder(1) ) //CNA_FILIAL+CNA_CONTRA+CNA_REVISA+CNA_NUMERO
				CNA->( MsSeek( cKey ))
				While !CNA->(Eof()) .And. CNA->(CNA_FILIAL+CNA_CONTRA+CNA_REVISA) == cKey
					
					nTotal += CNA->CNA_FRETE + CNA->CNA_DESPES + CNA->CNA_SEGURO
					
					CNA->(DbSkip())
				EndDo
			ElseIf "CNB" $ cTable 
				CNB->( DbSetOrder(1) ) //CNA_FILIAL+CNA_CONTRA+CNA_REVISA+CNA_NUMERO
				CNB->( MsSeek( cKey ))
				While !CNB->(Eof()) .And. CNB->(CNB_FILIAL+CNB_CONTRA+CNB_REVISA) == cKey
					
					nTotal += CNB->CNB_SLDFRT + CNB->CNB_SLDDSP + CNB->CNB_SLDSEG
					
					CNB->(DbSkip())
				EndDo
			EndIf
		    
			For nX := 1 To Len(aArea)
				FwRestArea(aArea[nX])
			Next
		EndIf
	EndIf

	FwFreeArray(aArea)

return nTotal

/*/{Protheus.doc} SetBlkFld
	@description Bloqueia e desbloqueia campos da estrutura na ViewDef
	@author henrique.testi
	@since 28/11/2025
	@param oStruct , estrutura a ser realizada a operação
	@param aFields , Campos a serem bloqueados/desbloqueados
	@param lOper   , operação a ser realizada: .F. - Bloqueia, .T. - Desbloqueia
	return Nil , Nulo
*/
Function SetBlkFld(oStruct as Object, aFields as Array, lOper As Logical)
	Local nX As Numeric

	Default aFields := {'*'}

	For nX := 1 to Len(aFields)
		oStruct:SetProperty(aFields[nX], MVC_VIEW_CANCHANGE, lOper)
	Next nX

Return Nil
