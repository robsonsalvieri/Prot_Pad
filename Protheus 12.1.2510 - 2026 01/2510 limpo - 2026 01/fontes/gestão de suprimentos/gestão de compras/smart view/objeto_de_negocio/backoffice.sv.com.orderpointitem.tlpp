#include "msobject.ch"
#include "protheus.ch"
#include "backoffice.sv.com.orderpointitem.ch"
#include "totvs.framework.treports.integratedprovider.th"

namespace totvs.protheus.backoffice.com.smartView.integratedProvider
 
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGACOM", tables="SB1,SB2", customTables="ALL", name="Listagem de Item em Ponto de Pedido", country="ALL")
 
//-----------------------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} orderpointitemReportsBusinessObjects
Classe para criação do Objeto de Negócio da Listagem de fornecedores
MATR440 - Item em ponto de pedido
Order Point Item
@author Everton Fregonezi Diniz
@since 15/12/2023
@version 1.0
*/
//-----------------------------------------------------------------------------------------------------------------------------------  
class orderpointitemReportsBusinessObjects from totvs.protheus.backoffice.com.smartView.integratedProvider.ComIntegratedProvider

	public method new() as object
	public method getSchema() as object

	protected method getQuery() as character
	protected method setCustomInfoToData() as object

endclass


//-----------------------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
 
@return object: self
 
@author Everton Fregonezi Diniz
@since 15/12/2023
@version 1.0
*/
//----------------------------------------------------------------------------------------------------------------------------------   
method new() class orderpointitemReportsBusinessObjects

    _Super:new()
    self:setDisplayName(STR0002)  // "Ponto de Pedido"
    self:setDescription(STR0003)  // "Listagem de Itens em Ponto de Pedido"
    self:setPergunte("COMT000002")

return self


//-----------------------------------------------------------------------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema
 
@author Everton Fregonezi Diniz
@since 15/12/2023
@version 1.0
*/
//-----------------------------------------------------------------------------------------------------------------------------------   
method getSchema() as object class orderpointitemReportsBusinessObjects

	self:comAddProperty("nPercToler"	, STR0011, "number")	// "% Tolerancia" 
	self:comAddProperty("nquantidade"	, STR0004, "number")	// "Quantidade"
	self:comAddProperty("nvlrestimado"	, STR0005, "number")	// "valor estimado"
	self:comAddProperty("cBase"			, STR0006, "string")	// "base"
	self:comAddProperty("dDtreferencia"	, STR0007, "date"  )	// "Data de referência"
	self:comAddProperty("nVlrUnitario"	, STR0008, "number")	// "valor unitário"
	self:comAddProperty("dDtPrazo"		, STR0009, "number")	// "Prazo de entrega (dias)"
	self:comAddProperty("SLDPRV"		, STR0010, "number")	// "Saldo Previsto"
	self:comAddProperty("SLDTOT"		, STR0012, "number")	// "Saldo Total (Armazéns)"

	self:aliasToSchema("SB1", {	"B1_COD","B1_DESC","B1_UM","B1_TIPO","B1_GRUPO","B1_LE","B1_TOLER",;
								"B1_QE","B1_UCOM","B1_DATREF","B1_CUSTD","B1_UPRC","B1_ESTFOR","B1_ESTSEG","B1_EMIN"} )
	self:aliasToSchema("SB2", {	"B2_FILIAL","B2_LOCAL","B2_QPEDVEN","B2_SALPEDI", "B2_QATU"})

	self:enableFilterByBranch("SB1")

return self:oSchema


//-----------------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} getQuery
Retorna a estrutura dos campos
 
@return object: self:oSchema
 
@author Everton Fregonezi Diniz
@since 15/12/2023
@version 1.0
*/
//-----------------------------------------------------------------------------------------------------------------------------------   
method getQuery(oFilter as object) as character class orderpointitemReportsBusinessObjects

	local cQuery		:= ""	as character
	local CJoinFilial 	:= ""	as character
	local cRetSqlSB2 	:= ""	as character
	local nX			:= 1	as numeric
	Local lArqSBZ		:= .F.	as logical

	lArqSBZ   	:= AllTrim(SuperGetMV("MV_ARQPROD",.F.,"SB1")) == "SBZ"
	cJoinFilial	:= FWJoinFilial("SB2", "SB1")
	cRetSqlSB2	:= RetSqlName("SB2")

	cQuery := " SELECT " + self:getAllFieldsToSQL() + ","
	cQuery += " (SELECT SUM(SB2_QTOT.B2_QATU) FROM " + cRetSqlSB2 + " SB2_QTOT WHERE " + cJoinFilial
	cQuery += " AND SB2_QTOT.B2_COD = SB1.B1_COD"
	cQuery += " AND SB2_QTOT.D_E_L_E_T_ = ' '"
	cQuery += " ) AS QTD_TOTAL"
	cQuery += " "
	cQuery += " FROM " + RetSqlName("SB1") + " SB1 "
	cQuery += " "
	
	if lArqSBZ
		cQuery += "		LEFT JOIN "  + RetSqlName("SBZ") + " SBZ "
		cQuery += "			ON	" + FWJoinFilial("SBZ", "SB1")
		cQuery += "			AND	BZ_COD 			= B1_COD "
		cQuery += "			AND	SBZ.D_E_L_E_T_	= ? "
	endif

	cQuery += "	"
	cQuery += "		INNER JOIN "  + cRetSqlSB2 + " SB2 "
	cQuery += "			ON	" + cJoinFilial
	cQuery += "			AND	B2_COD 			= B1_COD "
	if !Empty(MV_PAR16) .Or. !Empty(MV_PAR17)
		cQuery += "			AND	B2_LOCAL		>= ? "
		cQuery += "			AND	B2_LOCAL		<= ? "

		// pega o menor B2_QATU dentro da faixa (SQL padrão)
		/*Caso haja consideração do saldo do armazém (MV_PAR16 e MV_PAR17) retornará apenas o armazémm com o menor saldo de produto*/
		cQuery += " AND B2_QATU = ( SELECT MIN(SB2_SUB.B2_QATU) "
		cQuery += " FROM " + cRetSqlSB2 + " SB2_SUB "
		cQuery += " WHERE " + cJoinFilial
		cQuery += "   AND SB2_SUB.B2_COD    = SB2.B2_COD "
		cQuery += "   AND SB2_SUB.B2_LOCAL  >= ? "
		cQuery += "   AND SB2_SUB.B2_LOCAL  <= ? )"

	endif
	cQuery += "			AND	SB2.D_E_L_E_T_	= ? "
	cQuery += "	"
	cQuery += "	WHERE "
	cQuery += "			B1_FILIAL		IN (?) "
	cQuery += "		AND	B1_COD			>= ? "
	cQuery += "		AND	B1_COD			<= ? "

	if lArqSBZ
		cQuery += "		AND	(	(B1_LOCPAD >= ? AND B1_LOCPAD <= ?) "
		cQuery += "			OR	(BZ_LOCPAD >= ? AND BZ_LOCPAD <= ?)) "
	else
		cQuery += "		AND	B1_LOCPAD		>= ? "
		cQuery += "		AND	B1_LOCPAD		<= ? "
	endif

	cQuery += "		AND	B1_TIPO			>= ? "
	cQuery += "		AND	B1_TIPO			<= ? "
	cQuery += "		AND	B1_TIPO			!= ? "	// 'BN'
	cQuery += "		AND	B1_GRUPO		>= ? "
	cQuery += "		AND	B1_GRUPO		<= ? "
	cQuery += "		AND	B1_CONTRAT		!= ? "	// 'S'
	cQuery += "		AND	B1_MSBLQL		!= ? "	// '1'

	cQuery += "		AND	SB1.D_E_L_E_T_	= ? "	// ' '
	cQuery += self:setFilterOnWhere()
	cQuery += " ORDER BY " + SqlOrder(SB1->(IndexKey(1))) 

	if lArqSBZ
		self:jStatement['PARAM_'+strZero(nX++,3)] := ' '
	endif
	
	if !Empty(MV_PAR16) .Or. !Empty(MV_PAR17)
		self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR16
		self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR17

		// binds para o subselect do menor B2_QATU
		self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR16
		self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR17

	endif
	self:jStatement['PARAM_'+strZero(nX++,3)] := ' '
	self:jStatement['PARAM_'+strZero(nX++,3)] := self:getCustomParam('SV_MULTBRANCH', .T., "SB1")
	self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR01
	self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR02

	if lArqSBZ
		self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR07
		self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR08
		self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR07
		self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR08
	else
		self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR07
		self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR08
	endif
	
	self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR05
	self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR06
	self:jStatement['PARAM_'+strZero(nX++,3)] := 'BN'
	self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR03
	self:jStatement['PARAM_'+strZero(nX++,3)] := MV_PAR04
	self:jStatement['PARAM_'+strZero(nX++,3)] := 'S'
	self:jStatement['PARAM_'+strZero(nX++,3)] := '1'

	self:jStatement['PARAM_'+strZero(nX++,3)] := ' '

	cQuery := self:processSQLStatement(cQuery)

return cQuery

//-----------------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} setCustomInfoToData
Retorna a estrutura dos campos
 
@return object: self:oSchema
 
@author Everton Fregonezi Diniz
@since 15/12/2023
@version 1.0
*/
//-----------------------------------------------------------------------------------------------------------------------------------
method setCustomInfoToData(oFilter as object) as object class orderpointitemReportsBusinessObjects

	local cLocCQ	as character  
	local cFilSB2	as character  
	local cLocSB2	as character  
	local nX		as numeric
	local nSaldo	as numeric
	local nPrevis	as numeric
	local nEstSeg	as numeric
	local nQuant	as numeric
	local lQtdPrev	as logical

	nQuant		:= 0
	lQtdPrev	:= UPPER(SuperGetMV('MV_QTDPREV')) == "S"
	cLocCQ		:= GetMvNNR('MV_CQ','98')
		
	nQuant  := 0
	nSaldo  := 0 
	nPrevis := 0
	nNeces  := 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula o saldo atual de todos os almoxarifados ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	SB2->(dbSetOrder(1))
	if SB2->(dbSeek( FwxFilial("SB2") + (self:cAlias)->B1_COD ))

		while SB2->(!EOF()) .And. SB2->(B2_FILIAL + B2_COD) == FwxFilial("SB2") + (self:cAlias)->B1_COD
			
			if !(isProdMod((self:cAlias)->B1_COD)) .and. ( SB2->B2_LOCAL >= mv_par16 .And. SB2->B2_LOCAL <= mv_par17 ) .and. !( SB2->B2_LOCAL == cLocCQ .And. mv_par11 == 2 )
				
				nSaldo += (SaldoSB2(Nil,Nil,If(Empty(mv_par18),dDataBase,mv_par18),mv_par12==1,mv_par13==1)+SB2->B2_SALPEDI+SB2->B2_QACLASS+IIF(lQtdPrev,B2_SALPPRE,0))
				
				if mv_par14 == 1
					nSaldo -= SB2->B2_QPEDVEN
				endif
				
				nPrevis	+= SB2->B2_SALPEDI
				cFilSB2 := SB2->B2_FILIAL
				cLocSB2 := SB2->B2_LOCAL
				
			endif
			
			SB2->(dbSkip())
		enddo
	
	endif

	nEstSeg := CalcEstSeg((self:cAlias)->B1_ESTFOR, self:cAlias)

	if mv_par19 == 1
		nSaldo -= nEstSeg
	endif

	if (Round(nSaldo,4) <> 0) .Or. (mv_par09 == 1)
		
		do case
			
			case ( (self:cAlias)->B1_EMIN != 0 .And. MV_PAR09 == 1 )

				if ( mv_par10 == 2 .And. nSaldo < 0 )
					nSaldo -= (self:cAlias)->B1_LE
				endif

				nNeces := If((nSaldo < 0),Abs(nSaldo)+(self:cAlias)->B1_EMIN,;
					(If(QtdComp(nSaldo)==QtdComp((self:cAlias)->B1_EMIN),1,0);
					+ (self:cAlias)->B1_EMIN - nSaldo))

				//-- Soma 1 na quantidade da necessidade:
				//-- Ex: Ponto Pedido = 10 e Estoque = 9, ao inves de gerar 2 SCs de 1 pc ira gera 1 SC de 2 pcs (para sair do ponto de pedido)
				if nSaldo <  QtdComp((self:cAlias)->B1_EMIN) //-- Se o Saldo for menor que o Ponto do Pedido
					nNeces += 1
				endif

			case ( (self:cAlias)->B1_EMIN != 0 .And. MV_PAR09 == 2 )

				if ( mv_par10 == 2 .And. nSaldo < 0 )
					nSaldo -= (self:cAlias)->B1_LE
				endif

				nNeces := if((nSaldo < 0), Abs(nSaldo), ;
							( if(QtdComp(nSaldo) == QtdComp((self:cAlias)->B1_EMIN),1,0);
							+(self:cAlias)->B1_EMIN-nSaldo))

				//-- Soma 1 na quantidade da necessidade:
				//-- Ex: Ponto Pedido = 10 e Estoque = 9, ao inves de gerar 2 SCs de 1 pc ira gera 1 SC de 2 pcs (para sair do ponto de pedido)
				if nSaldo <  QtdComp((self:cAlias)->B1_EMIN) //-- Se o Saldo for menor que o Ponto do Pedido
					nNeces += 1
				endif

			case ((self:cAlias)->B1_LE != 0 .And. (nSaldo < 0  .or. mv_par09 == 2) )

				if ( mv_par10 == 2 .And. nSaldo < 0 )
					nNeces := Abs(nSaldo)+(self:cAlias)->B1_LE
				else
					nNeces := if(Abs(nSaldo) < (self:cAlias)->B1_LE, (self:cAlias)->B1_LE, if(nSaldo < 0, Abs(nSaldo), 0))
				endif

			otherwise
				nNeces := if(mv_par09 == 1,if(nSaldo < 0, Abs(nSaldo)+1, 0), 0)
		
		endcase
	
	else
		
		if RetFldProd((self:cAlias)->B1_COD,"B1_EMIN",self:cAlias) != 0
			nNeces := ( RetFldProd((self:cAlias)->B1_COD, "B1_EMIN", self:cAlias) )
			nNeces += 1
		endif

	endif

	if nNeces > 0
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o produto tem estrutura                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SG1")
		SG1->(dbSetOrder(1))	// G1_FILIAL + G1_COD + G1_COMP + G1_TRT
		if SG1->(dbSeek( fwxFilial("SG1") + (self:cAlias)->B1_COD ))
			aQtdes := CalcLote((self:cAlias)->B1_COD, nNeces, "F")
		else
			aQtdes := CalcLote((self:cAlias)->B1_COD, nNeces, "C")
		endif
		
		for nX := 1 to len(aQtdes)
			nQuant += aQtdes[nX]
		next nX
	
	endif

	if nQuant > 0

		self:setContentToData()

		self:jData["nquantidade"]	:= nQuant
		self:jData["SLDPRV"]		:= nSaldo - nPrevis
		self:jData["nPercToler"]	:= ((self:cAlias)->B1_LE * (self:cAlias)->B1_TOLER) / 100
		self:jData["dDtPrazo"]		:= CalcPrazo((self:cAlias)->B1_COD, nQuant)
		self:jData["dDtreferencia"]	:= self:varToTimeStamp(if((self:cAlias)->B1_UCOM < (self:cAlias)->B1_DATREF, (self:cAlias)->B1_DATREF, (self:cAlias)->B1_UCOM))
		self:jData["nvlrestimado"]	:= nQuant * if((self:cAlias)->(B1_UCOM < B1_DATREF), (self:cAlias)->B1_CUSTD, (self:cAlias)->B1_UPRC) 
		self:jData["cBase"]			:= if((self:cAlias)->(B1_UCOM < B1_DATREF), "STD", "U.CO" )	
		self:jData["nVlrUnitario"]	:= if((self:cAlias)->(B1_UCOM < B1_DATREF), (self:cAlias)->B1_CUSTD, (self:cAlias)->B1_UPRC)

		// Se considera armazém, soma todos os itens dos armazéns e alimenta o Saldo Total (Armazéns)
		if !Empty(MV_PAR16) .Or. !Empty(MV_PAR17)
			self:jData["SLDTOT"]	:= 	(self:cAlias)->QTD_TOTAL
		endif
	endif 
 
return
